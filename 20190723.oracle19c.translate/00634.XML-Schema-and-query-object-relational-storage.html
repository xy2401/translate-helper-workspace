<html lang="en-us" dir="ltr" xml:lang="en-us">
   <head>
      <meta http-equiv="Content-Type" content="text/html; charset=utf-8"></meta>
      <meta name="viewport" content="width=device-width, initial-scale=1"></meta>
      <meta http-equiv="X-UA-Compatible" content="IE=edge"></meta>
      <meta name="abstract" content="Advanced techniques for XML Schema-based data include using object-relational storage; annotating XML schemas; mapping Schema data types to SQL; using complexType extensions and restrictions; creating, specifying relational constraints on, and partitioning XML Schema-based data, storing XMLType data out of line, working with complex or large schemas, and debugging schema registration."></meta>
      <meta name="description" content="Advanced techniques for XML Schema-based data include using object-relational storage; annotating XML schemas; mapping Schema data types to SQL; using complexType extensions and restrictions; creating, specifying relational constraints on, and partitioning XML Schema-based data, storing XMLType data out of line, working with complex or large schemas, and debugging schema registration."></meta>
      <title>XML模式存储和查询：对象关系存储</title>
      <meta property="og:site_name" content="Oracle Help Center"></meta>
      <meta property="og:title" content="Developer&#39;s Guide "></meta>
      <meta property="og:description" content="Advanced techniques for XML Schema-based data include using object-relational storage; annotating XML schemas; mapping Schema data types to SQL; using complexType extensions and restrictions; creating, specifying relational constraints on, and partitioning XML Schema-based data, storing XMLType data out of line, working with complex or large schemas, and debugging schema registration."></meta>
      <link rel="stylesheet" href="/sp_common/book-template/ohc-book-template/css/book.css"></link>
      <link rel="shortcut icon" href="/sp_common/book-template/ohc-common/img/favicon.ico"></link>
      <meta name="application-name" content="Developer&#39;s Guide"></meta>
      <meta name="generator" content="DITA Open Toolkit version 1.8.5 (Mode = doc)"></meta>
      <meta name="plugin" content="SP_docbuilder HTML plugin release 18.2.2"></meta>
      <link rel="alternate" href="xml-db-developers-guide.pdf" title="PDF File" type="application/pdf"></link>
      <meta name="robots" content="all"></meta>
      <link rel="schema.dcterms" href="http://purl.org/dc/terms/"></link>
      <meta name="dcterms.created" content="2019-03-30T12:32:42-07:00"></meta>
      
      <meta name="dcterms.dateCopyrighted" content="2002, 2019"></meta>
      <meta name="dcterms.category" content="database"></meta>
      <meta name="dcterms.identifier" content="E96222-03"></meta>
      
      <meta name="dcterms.product" content="en/database/oracle/oracle-database/19"></meta>
      
      <link rel="prev" href="XML-Schema-and-query-basic.html" title="Previous" type="text/html"></link>
      <link rel="next" href="XPath-rewrite-for-object-relational-storage.html" title="Next" type="text/html"></link>
      <script>
        document.write('<style type="text/css">');
        document.write('body > .noscript, body > .noscript ~ * { visibility: hidden; }');
        document.write('</style>');
     </script>
      <script src="/sp_common/book-template/requirejs/require.js" data-main="/sp_common/book-template/ohc-book-template/js/book-config"></script>
      <script>
            if (window.require === undefined) {
                document.write('<script data-main="sp_common/book-template/ohc-book-template/js/book-config" src="sp_common/book-template/requirejs/require.js"><\/script>');
                document.write('<link href="sp_common/book-template/ohc-book-template/css/book.css" rel="stylesheet"/>');
            }
        </script>
      <script type="application/json" id="ssot-metadata">{"primary":{"category":{"short_name":"database","element_name":"Database","display_in_url":true},"suite":{"short_name":"oracle","element_name":"Oracle","display_in_url":true},"product_group":{"short_name":"not-applicable","element_name":"Not applicable","display_in_url":false},"product":{"short_name":"oracle-database","element_name":"Oracle Database","display_in_url":true},"release":{"short_name":"19","element_name":"Release 19","display_in_url":true}}}</script>
      
    <meta name="dcterms.title" content="XML DB Developer&#39;s Guide"></meta>
    <meta name="dcterms.isVersionOf" content="ADXDB"></meta>
    <meta name="dcterms.release" content="Release 19"></meta>
  </head>
   <body dir="ltr">
      <div class="noscript alert alert-danger text-center" role="alert">
         <a href="XML-Schema-and-query-basic.html" class="pull-left"><span class="glyphicon glyphicon-chevron-left" aria-hidden="true"></span>上一页</a> <a href="XPath-rewrite-for-object-relational-storage.html" class="pull-right">下一页<span class="glyphicon glyphicon-chevron-right" aria-hidden="true"></span></a> <span class="fa fa-exclamation-triangle" aria-hidden="true"></span>必须启用JavaScript才能正确显示此内容</div>
      <article>
         <header>
            <ol class="breadcrumb" vocab="http://schema.org/" typeof="BreadcrumbList">
               <li property="itemListElement" typeof="ListItem"><a href="index.html" property="item" typeof="WebPage"><span property="name">开发人员指南</span></a></li>
               <li property="itemListElement" typeof="ListItem"><a href="XML-Schema-and-object-relational-XMLType.html" property="item" typeof="WebPage"><span property="name">XML Schema和Object-Relational XMLType</span></a></li>
               <li class="active" property="itemListElement" typeof="ListItem">XML模式存储和查询：对象关系存储</li>
            </ol>
            <a id="GUID-B0C1A0B0-2DD1-491A-8CE1-1F857FD267B7" name="GUID-B0C1A0B0-2DD1-491A-8CE1-1F857FD267B7"></a><a id="ADXDB0700"></a>
            
            <h2 id="ADXDB-GUID-B0C1A0B0-2DD1-491A-8CE1-1F857FD267B7" class="sect2"><span class="enumeration_chapter">18</span> XML模式存储和查询：对象关系存储</h2>
         </header>
         <div class="ind"><script type="text/javascript">window.name='XML-Schema-and-query-object-relational-storage'</script><script type="text/javascript">
    function footdisplay(footnum,footnote) {
    var msg = window.open('about:blank', 'NewWindow' + footnum,
        'directories=no,height=100,location=no,menubar=no,resizable=yes,' +
        'scrollbars=yes,status=no,toolbar=no,width=598');
    msg.document.open('text/html');
    msg.document.write('<!DOCTYPE html ');
    msg.document.write('PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" ');
    msg.document.write('"http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">'); 
    msg.document.write('<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en-us" lang="en-us" dir="ltr"><head><title>');
   
    msg.document.write('Footnote&nbsp; ' + footnum);
    msg.document.write('<\/title><meta http-equiv="Content-Type" ');
    msg.document.write('content="text/html; charset=utf-8" />');
    msg.document.write('<meta http-equiv="Content-Script-Type" ');
    msg.document.write('content="text/javascript" />');
    msg.document.write('<style type="text/css"> <![CDATA[ ');
    msg.document.write('h1 {text-align: center; font-size: 14pt;}');
    msg.document.write('fieldset {border: none;}');
    msg.document.write('form {text-align: center;}');
    msg.document.write(' ]]u003e </style>');
    msg.document.write('<\/head><body><div id="footnote"><h1>Footnote&nbsp; ' + footnum + '<\/h1><p>');
    msg.document.write(footnote);
    msg.document.write('<\/p><form action="" method="post"><fieldset>');
    msg.document.write('<input type="button" value="OK" ');
    msg.document.write('onclick="window.close();" />');
    msg.document.write('<\/fieldset><\/form><\/div><\/body><\/html>');
    msg.document.close();
    setTimeout(function() {
        var height = msg.document.getElementById('footnote').offsetHeight;
        msg.resizeTo(598, height + 100);
    }
    , 100);
    msg.focus();
}
            </script><noscript>
               <p>此页面上的脚本内容仅用于导航目的，不会以任何方式更改内容。</p>
            </noscript>
            <div>
               <p>基于XML Schema的数据的高级技术包括使用对象关系存储;注释XML模式;将Schema数据类型映射到SQL;使用<code class="codeph">complexType</code>扩展和限制;创建，指定关系约束，分区基于XML Schema的数据，存储<code class="codeph">XMLType</code>数据，使用复杂或大型模式，以及调试模式注册。
               </p>
               <div class="section">
                  <div class="infoboxnotealso" id="GUID-B0C1A0B0-2DD1-491A-8CE1-1F857FD267B7__GUID-E7F26298-25E2-4630-AABB-A34E1ED9E534">
                     <p class="notep1">也可以看看：</p>
                     <ul style="list-style-type:disc">
                        <li>
                           <p><a href="XML-Schema-and-query-basic.html#GUID-C09824C1-6B02-4556-A265-B1749DEE8DE1" title="XML Schema是用于描述XML文档的内容和结构的标准。您可以注册，更新和删除与Oracle XML DB一起使用的XML架构。您可以定义用于基于XML模式的数据的存储结构，并将XML模式数据类型映射到SQL数据类型。">XML模式存储和查询：</a>基本信息，用于将XML模式与Oracle XML DB一起使用的基本信息</p>
                        </li>
                        <li>
                           <p>有关在Oracle XML DB中优化XPath表达式的信息，请参阅<a href="XPath-rewrite-for-object-relational-storage.html#GUID-35551023-CCAC-477B-8BBF-CD0E0B44C962" title="对于以对象方式存储的XMLType数据，涉及各种SQL函数的XPath表达式参数的查询通常可以自动重写为针对高度优化的基础SQL表的查询。">对象关系存储的XPath重写</a></p>
                        </li>
                        <li>
                           <p><a href="XML-Schema-evolution.html#GUID-F2E920B3-C6D7-428B-9E75-5CE9C21F9B5F" title="在向Oracle XML DB注册XML模式后，可以使用XML模式演变来更新XML模式。">XML Schema Evolution</a> ，了解有关在使用Oracle XML DB注册XML模式后更新XML模式的信息</p>
                        </li>
                        <li>
                           <p><a href="https://www.oracle.com/pls/topic/lookup?ctx=en/database/oracle/oracle-database/19/adxdb&amp;id=w3_org_tr_xschema0_primer" target="_blank">XML Schema第0部分：</a>引用XML Schema的<a href="https://www.oracle.com/pls/topic/lookup?ctx=en/database/oracle/oracle-database/19/adxdb&amp;id=w3_org_tr_xschema0_primer" target="_blank">Primer Second Edition</a></p>
                        </li>
                     </ul>
                  </div>
               </div>
               <!-- class="section" -->
            </div>
            <div>
               <ul class="ullinks">
                  <li class="ulchildlink"><a href="XML-Schema-and-query-object-relational-storage.html#GUID-79213AD7-C940-400B-BC11-5E401A1520A6">XML文档的对象关系存储</a><br>XML文档的对象关系存储基于将文档内容分解为一组SQL对象。这些SQL对象基于SQL 1999 Type框架。向Oracle XML DB注册XML模式时，将从模式自动生成所需的SQL类型定义。
                  </li>
                  <li class="ulchildlink"><a href="XML-Schema-and-query-object-relational-storage.html#GUID-F7E43D3A-67D8-432E-833A-DE0EA4CFCE7A">Oracle XML Schema Annotations</a><br>您可以注释XML模式以影响XML模式注册过程生成的对象和表。您可以通过向XML模式声明的<code class="codeph">complexType</code> ， <code class="codeph">element</code>和<code class="codeph">attribute</code>定义添加特定于Oracle的属性来完成此操作。
                  </li>
                  <li class="ulchildlink"><a href="XML-Schema-and-query-object-relational-storage.html#GUID-844D686D-D95A-4C5B-8624-71BABDBF1EF5">使用DBMS_XMLSCHEMA将XML架构数据类型映射到SQL数据类型</a><br>您可以使用PL / SQL包<code class="codeph">DBMS_XMLSCHEMA</code>将XML Schema属性和元素的数据类型映射到SQL数据类型。
                  </li>
                  <li class="ulchildlink"><a href="XML-Schema-and-query-object-relational-storage.html#GUID-9E0CF72F-9E08-4CB8-ABBC-66F8ECEF949B">Oracle XML DB中的complexType扩展和限制</a><br>在XML Schema中， <code class="codeph">complexType</code>值是基于<code class="codeph">complexContent</code>和<code class="codeph">simpleContent</code>声明的。Oracle XML DB定义了对<code class="codeph">complexType</code>各种扩展和限制。
                  </li>
                  <li class="ulchildlink"><a href="XML-Schema-and-query-object-relational-storage.html#GUID-7A85260C-44C1-4DEF-A000-6A66B24F1B71">创建基于XML模式的XMLType列和表</a><br>在向Oracle XML DB注册XML模式后，可以在定义<code class="codeph">XMLType</code>表或列时引用它。
                  </li>
                  <li class="ulchildlink"><a href="XML-Schema-and-query-object-relational-storage.html#GUID-8713E2AD-0D5F-4076-A2DE-BB0ECEFBFEA8">分区存储对象 - 关系的XMLType表和列的概述</a><br>使用对象关系存储的<code class="codeph">XMLType</code>列对对象关系<code class="codeph">XMLType</code>表或表进行分区时，使用列表，范围或散列分区，数据中的任何有序集合表（OCT）或外联表默认情况下会相应地自动分区。
                  </li>
                  <li class="ulchildlink"><a href="XML-Schema-and-query-object-relational-storage.html#GUID-EEF1789B-F8B0-4371-96FB-40D0547060BA">XMLType表和列的关系约束规范</a><br>对于以对象关系存储的<code class="codeph">XMLType</code>数据，您可以为在XML文档中仅出现一次的元素和属性指定典型的关系约束。
                  </li>
                  <li class="ulchildlink"><a href="XML-Schema-and-query-object-relational-storage.html#GUID-0EF2C8B6-927A-4F50-8126-47CD566A6B92">XMLType数据的外部存储</a><br>默认情况下，当<code class="codeph">XMLType</code>数据以对象关系方式存储时，子元素将映射到嵌入式SQL对象属性。有时，通过存储一些<code class="codeph">XMLType</code>数据可以获得更好的性能。使用XML模式注释<code class="codeph">xdb:SQLInline</code>来执行此操作。
                  </li>
                  <li class="ulchildlink"><a href="XML-Schema-and-query-object-relational-storage.html#GUID-A9BDECE7-16AF-4CA4-96D5-5B03FA3E94CE">使用复杂或大型XML模式的注意事项</a><br>XML模式可能很复杂。复杂模式的示例包括递归模式和包含循环或循环引用的模式。使用复杂或大型XML模式可能具有挑战性，并且需要考虑某些因素。
                  </li>
                  <li class="ulchildlink"><a href="XML-Schema-and-query-object-relational-storage.html#GUID-D17B71BD-2AC2-4EC6-ADE3-8FE626FEC156">调试XML数据的XML模式注册存储对象 - 关系</a><br>对于以对象关系存储的XML数据，您可以通过在调用PL / SQL过程<code class="codeph">DBMS_XMLSCHEMA.registerSchema</code>之前设置事件31098来监视在XML模式注册期间创建的对象类型和表。
                  </li>
               </ul>
               <div class="familylinks">
                  <div class="parentlink">
                     <p><strong>父主题：</strong> <a href="XML-Schema-and-object-relational-XMLType.html#GUID-817F95DE-D604-41DC-BCDE-76CDE30F9176" title="涵盖了XML Schema的使用和XMLType数据的对象关系存储。">XML模式和对象关系XMLType</a></p>
                  </div>
               </div>
            </div>
            <a id="ADXDB6305"></a><div class="props_rev_3"><a id="GUID-79213AD7-C940-400B-BC11-5E401A1520A6" name="GUID-79213AD7-C940-400B-BC11-5E401A1520A6"></a><h3 id="ADXDB-GUID-79213AD7-C940-400B-BC11-5E401A1520A6" class="sect3"><span class="enumeration_section">18.1</span> XML文档的对象关系存储</h3>
               <div>
                  <p>XML文档的对象关系存储基于将文档内容分解为一组SQL对象。这些SQL对象基于SQL 1999 Type框架。向Oracle XML DB注册XML模式时，将从模式自动生成所需的SQL类型定义。</p>
                  <p>从XML模式定义的每个<code class="codeph">complexType</code>生成SQL类型定义。<code class="codeph">complexType</code>定义的每个元素或属性都成为相应SQL类型中的SQL属性。Oracle XML DB自动将XML Schema Recommendation定义的47个标量数据类型映射到SQL支持的19个标量数据类型。为每个元素生成varray类型，这可以多次出现。
                  </p>
                  <p>生成的SQL类型允许将符合XML模式的XML内容分解并作为一组对象存储在数据库中，而不会丢失任何信息。当摄取XML文档时，XML模式定义的构造将直接映射到等效的SQL类型。这使得Oracle XML DB在管理XML时可以充分利用Oracle数据库的强大功能，并且可以显着减少存储文档所需的空间量。它还可以减少查询和更新XML内容所需的内存量。</p>
               </div>
               <div>
                  <ul class="ullinks">
                     <li class="ulchildlink"><a href="XML-Schema-and-query-object-relational-storage.html#GUID-7118A992-449B-4306-8579-8EF1C5890995">如何为对象关系XMLType存储存储集合</a><br>您可以将有序集合作为varray存储在有序集合表（OCT）中，该表可以是基于堆的表（推荐）或索引组织表（IOT）。您可以使用<code class="codeph">REF</code>作为数据的varray条目来存储实际数据。
                     </li>
                     <li class="ulchildlink"><a href="XML-Schema-and-query-object-relational-storage.html#GUID-9F4054FB-2277-4945-8A7C-FC0649AB2790">在对象关系存储的XML模式注册期间创建的SQL类型</a><br>当您注册XML模式以与对象存储的XML数据一起使用时，使用<code class="codeph">TRUE</code>作为参数<code class="codeph">GENTYPES</code>的值（ <code class="codeph">TRUE</code>是默认值）。然后，Oracle XML DB创建适当的SQL对象类型，以支持符合XML文档的对象关系存储。
                     </li>
                     <li class="ulchildlink"><a href="XML-Schema-and-query-object-relational-storage.html#GUID-54A3CBE8-19BE-43BB-8979-7769116B6F53">XML架构注册期间创建的默认表</a><br>您可以在XML模式注册中创建默认表。使用API和协议（如FTP和HTTP（S））插入文档时，默认表最有用，它们不提供任何表规范。
                     </li>
                     <li class="ulchildlink"><a href="XML-Schema-and-query-object-relational-storage.html#GUID-75FCD51E-73B6-4CA6-BE6F-94553B73E9E0">不要使用XML架构注册期间生成的内部构造</a><br>通常，在XML模式注册期间自动生成的SQL构造（数据类型，嵌套表和与外部存储关联的表）是Oracle XML DB的<span class="italic">内部</span>构造。 Oracle建议您<span class="italic">不要</span>在代码中使用它们。
                     </li>
                     <li class="ulchildlink"><a href="XML-Schema-and-query-object-relational-storage.html#GUID-D3206DC0-7581-4AD3-8B46-9F38555D47CB">生成的名称区分大小写</a><br>XML模式注册生成的任何SQL表，对象和属性的名称<span class="italic">区分大小写</span> 。
                     </li>
                     <li class="ulchildlink"><a href="XML-Schema-and-query-object-relational-storage.html#GUID-AF8651CF-49C5-4B13-A198-0AE1F0770439">对象关系存储的SYS_XDBPD $和DOM保真度</a><br>为了提供以对象关系存储的XML数据的DOM保真度，Oracle XML DB使用系统定义的二进制对象属性<code class="codeph">SYS_XDBPD$</code>将所有无法存储在任何其他对象属性中的信息记录为实例级元数据（位置描述符或PD）。
                     </li>
                  </ul>
                  <div class="familylinks">
                     <div class="parentlink">
                        <p><strong>父主题：</strong> <a href="XML-Schema-and-query-object-relational-storage.html#GUID-B0C1A0B0-2DD1-491A-8CE1-1F857FD267B7" title="基于XML Schema的数据的高级技术包括使用对象关系存储;注释XML模式;将Schema数据类型映射到SQL;使用complexType扩展和限制;创建，指定关系约束，分区基于XML Schema的数据，存储XMLType数据，使用复杂或大型模式，以及调试模式注册。">XML模式存储和查询：对象关系存储</a></p>
                     </div>
                  </div>
               </div>
               <a id="ADXDB6306"></a><div class="props_rev_3"><a id="GUID-7118A992-449B-4306-8579-8EF1C5890995" name="GUID-7118A992-449B-4306-8579-8EF1C5890995"></a><h4 id="ADXDB-GUID-7118A992-449B-4306-8579-8EF1C5890995" class="sect4"><span class="enumeration_section">18.1.1</span>如何为对象关系XMLType存储存储集合</h4>
                  <div>
                     <p>您可以将有序集合作为varray存储在有序集合表（OCT）中，该表可以是基于堆的表（推荐）或索引组织表（IOT）。您可以使用<code class="codeph">REF</code>作为数据的varray条目来存储实际数据。
                     </p>
                     <p>为对象存储的<code class="codeph">XMLType</code>数据注册XML模式并将注册参数<code class="codeph">GENTABLES</code>设置为<code class="codeph">TRUE</code> ，将自动创建默认表以存储关联的XML实例文档。
                     </p>
                     <p>存储时，顺序在XML集合元素之间保留。结果是<strong class="term">有序集合</strong> 。您可以通过以下方式将数据存储在有序集合中：</p>
                     <ul style="list-style-type:disc">
                        <li>
                           <p><strong class="term">Varray在一张桌子里</strong> 。集合中的每个元素都映射到SQL对象。SQL对象的集合作为一组行存储在表中，称为<strong class="term">有序集合表</strong> （ <strong class="term">OCT</strong> ）。所有集合都存储在OCT中。
                           </p>
                        </li>
                     </ul>
                     <p>您还可以使用外部存储来存储订购的集合。这对应于XML模式注释<code class="codeph">SQLInline = "false"</code> ，这意味着集合表（或LOB）中的<code class="codeph">REF</code>的varray跟踪集合内容，该集合内容存储在行外。
                     </p>
                     <p>在使用之前不需要注释XML模式。在处理不包含注释的XML模式时，Oracle XML DB使用一组默认假设。</p>
                     <p>如果您未提供本节中提到的任何注释，则Oracle XML DB会将集合存储为基于<span class="italic">堆的</span> OCT。您可以通过在<code class="codeph">DBMS_XMLSCHEMA.registerSchema</code>的<code class="codeph">OPTIONS</code>参数中传递<span class="bold"><code class="codeph">REGISTER_NT_AS_IOT</code></span>来强制将OCT存储为<strong class="term">索引组织表</strong> （ <strong class="term">IOT</strong> ）。
                     </p>
                     <div class="infoboxnote" id="GUID-7118A992-449B-4306-8579-8EF1C5890995__GUID-D6CFE58B-C5E3-4665-BFB2-26FD7F1746E7">
                        <p class="notep1">注意：</p>
                        <p>使用基于堆的OCT <span class="italic">而不是</span> IOT，除非Oracle明确建议您使用IOT。物联网存储具有以下重要限制：</p>
                        <ul style="list-style-type:disc">
                           <li>
                              <p>它禁用分区表（IOT）的分区。</p>
                           </li>
                           <li>
                              <p>它仅支持文档级Oracle Text索引。它禁用特定于元素或特定于属性的索引。</p>
                           </li>
                        </ul>
                     </div>
                     <div class="section"></div>
                     <!-- class="section" -->
                  </div>
                  <div>
                     <div class="relinfo">
                        <p><strong>相关话题</strong></p>
                        <ul>
                           <li><a href="XML-Schema-and-query-object-relational-storage.html#GUID-AC221997-9F02-423E-9F39-BA02046763B5" title="将XML模式注释xdb：SQLInline设置为false以将XML片段存储在线外。该元素映射到具有嵌入REF属性的SQL对象类型，该属性指向另一个存储在行外且与XML片段对应的XMLType实例。">将注释属性xdb：SQLInline设置为false以用于外线存储</a></li>
                           <li><a href="XML-Schema-and-query-object-relational-storage.html#GUID-8713E2AD-0D5F-4076-A2DE-BB0ECEFBFEA8" title="使用对象关系存储的XMLType列对对象关系XMLType表或表进行分区时，使用列表，范围或散列分区，数据中的任何有序集合表（OCT）或外联表默认情况下会相应地自动分区。">分区存储对象 - 关系的XMLType表和列的概述</a></li>
                        </ul>
                     </div>
                     <div class="infoboxnotealso" id="GUID-7118A992-449B-4306-8579-8EF1C5890995__GUID-12B95B23-26D0-4A24-B9D5-F012B912F7E5">
                        <p class="notep1">也可以看看：</p>
                        <p><a href="XML-Schema-and-query-object-relational-storage.html#GUID-79213AD7-C940-400B-BC11-5E401A1520A6" title="XML文档的对象关系存储基于将文档内容分解为一组SQL对象。这些SQL对象基于SQL 1999 Type框架。向Oracle XML DB注册XML模式时，将从模式自动生成所需的SQL类型定义。">XML文档的对象关系存储，</a>用于在使用对象关系存储手动创建<code class="codeph">XMLType</code>表和列时有关集合存储的信息</p>
                     </div>
                     <div class="familylinks">
                        <div class="parentlink">
                           <p><strong>父主题：</strong> <a href="XML-Schema-and-query-object-relational-storage.html#GUID-79213AD7-C940-400B-BC11-5E401A1520A6" title="XML文档的对象关系存储基于将文档内容分解为一组SQL对象。这些SQL对象基于SQL 1999 Type框架。向Oracle XML DB注册XML模式时，将从模式自动生成所需的SQL类型定义。">XML文档的对象关系存储</a></p>
                        </div>
                     </div>
                  </div>
                  
               </div><a id="ADXDB4465"></a><a id="ADXDB4464"></a><div class="props_rev_3"><a id="GUID-9F4054FB-2277-4945-8A7C-FC0649AB2790" name="GUID-9F4054FB-2277-4945-8A7C-FC0649AB2790"></a><h4 id="ADXDB-GUID-9F4054FB-2277-4945-8A7C-FC0649AB2790" class="sect4"><span class="enumeration_section">18.1.2</span>在对象关系存储的XML模式注册期间创建的SQL类型</h4>
                  <div>
                     <p>当您注册XML模式以与对象存储的XML数据一起使用时，使用<code class="codeph">TRUE</code>作为参数<code class="codeph">GENTYPES</code>的值（ <code class="codeph">TRUE</code>是默认值）。然后，Oracle XML DB创建适当的SQL对象类型，以支持符合XML文档的对象关系存储。
                     </p>
                     <p>默认情况下，所有SQL对象类型都是在注册XML模式的用户的数据库模式中创建的。如果使用注释<code class="codeph">xdb:defaultSchema</code> ，则Oracle XML DB会尝试使用指定的数据库模式创建对象类型。当前用户必须具有创建这些对象类型所需的权限。
                     </p>
                     <p><a href="XML-Schema-and-query-object-relational-storage.html#GUID-9F4054FB-2277-4945-8A7C-FC0649AB2790__CHDFCAFB">例18-1</a>显示了向Oracle XML DB注册XML模式<code class="codeph">purchaseOrder.xsd</code>时自动创建的SQL对象类型。</p>
                     <div class="infoboxnote" id="GUID-9F4054FB-2277-4945-8A7C-FC0649AB2790__GUID-E6485FBE-49DB-44AA-A84A-7886DD1C03A2">
                        <p class="notep1">注意：</p>
                        <p>默认情况下，SQL对象类型和属性的名称是系统生成的。这是<a href="XML-Schema-and-query-object-relational-storage.html#GUID-9F4054FB-2277-4945-8A7C-FC0649AB2790__CHDFCAFB">例18-1中</a>的情况。如果XML架构不包含属性<code class="codeph">SQLName</code> ，则SQL名称是从XML名称派生的。您可以使用XML模式注释来提供用户定义的名称（有关详细信息，请参阅<a href="XML-Schema-and-query-object-relational-storage.html#GUID-F7E43D3A-67D8-432E-833A-DE0EA4CFCE7A" title="您可以注释XML模式以影响XML模式注册过程生成的对象和表。您可以通过向XML模式声明的complexType，元素和属性定义添加特定于Oracle的属性来完成此操作。">Oracle XML模式注释</a> ）。
                        </p>
                     </div>
                     <div class="infoboxnote" id="GUID-9F4054FB-2277-4945-8A7C-FC0649AB2790__GUID-996A501A-0F38-4C63-BA50-AB4F9CB74B96">
                        <p class="notep1">注意：</p>
                        <p>从Oracle Database 12c第2版（12.2.0.1）开始，如果为<span class="italic">应用程序公共用户</span>注册对象关系存储的XML模式，则<span class="italic">必须</span>使用<code class="codeph">xdb:SQLType</code>注释模式中的每个复杂类型，以命名SQL数据类型。否则，会引发错误。
                        </p>
                     </div>
                     <div class="example" id="GUID-9F4054FB-2277-4945-8A7C-FC0649AB2790__CHDFCAFB">
                        <p class="titleinexample">示例18-1用于存储XMLType表的SQL对象类型</p><pre class="oac_no_warn" dir="ltr">DESCRIBE“PurchaseOrderType1668_T”“PurchaseOrderType1668_T”是不是最终名称空？输入-------------------- ------ ----------------------- -------- SYS_XDBPD $ XDB.XDB $ RAW_LIST_T参考VARCHAR2（30 CHAR）操作ActionsType1661_T拒绝RejectionType1660_T请求者VARCHAR2（128 CHAR）用户VARCHAR2（10 CHAR）CostCenter VARCHAR2（4 CHAR）ShippingInstructions ShippingInstructionsTyp1659_T SpecialInstructions VARCHAR2（2048 CHAR ）LineItems LineItemsType1666_T注意VARCHAR2（4000 CHAR）DESCRIBE“LineItemsType1666_T”“LineItemsType1666_T”是不是最终名称空？输入-------------------- ----- ------------------------ ------- SYS_XDBPD $ XDB.XDB $ RAW_LIST_T LineItem LineItem1667_COLL DESCRIBE“LineItem1667_COLL”“LineItem1667_COLL”VARRAY（2147483647）Of LineItemType1665_T“LineItemType1665_T”是不是最终名称空？输入------------------- ----- ------------------------- ------- SYS_XDBPD $ XDB.XDB $ RAW_LIST_T ItemNumber NUMBER（38）描述VARCHAR2（256 CHAR）Part PartType1664_T</pre></div>
                     <!-- class="example" -->
                  </div>
                  <div>
                     <div class="familylinks">
                        <div class="parentlink">
                           <p><strong>父主题：</strong> <a href="XML-Schema-and-query-object-relational-storage.html#GUID-79213AD7-C940-400B-BC11-5E401A1520A6" title="XML文档的对象关系存储基于将文档内容分解为一组SQL对象。这些SQL对象基于SQL 1999 Type框架。向Oracle XML DB注册XML模式时，将从模式自动生成所需的SQL类型定义。">XML文档的对象关系存储</a></p>
                        </div>
                     </div>
                  </div>
                  
               </div><a id="ADXDB4467"></a><a id="ADXDB4466"></a><div class="props_rev_3"><a id="GUID-54A3CBE8-19BE-43BB-8979-7769116B6F53" name="GUID-54A3CBE8-19BE-43BB-8979-7769116B6F53"></a><h4 id="ADXDB-GUID-54A3CBE8-19BE-43BB-8979-7769116B6F53" class="sect4"><span class="enumeration_section">18.1.3</span> XML模式注册期间创建的默认表</h4>
                  <div>
                     <p>您可以在XML模式注册中创建默认表。使用API和协议（如FTP和HTTP（S））插入文档时，默认表最有用，它们不提供任何表规范。</p>
                     <p>在这种情况下，XML实例将插入到默认表中。</p>
                     <p><a href="XML-Schema-and-query-object-relational-storage.html#GUID-54A3CBE8-19BE-43BB-8979-7769116B6F53__CEGGHHGE">例18-2</a>描述了默认的采购订单表。
                     </p>
                     <p>如果为属性<code class="codeph">xdb:defaultTable</code>提供值，则使用该名称创建<code class="codeph">XMLType</code>表。否则，它是使用内部生成的名称创建的。
                     </p>
                     <p>使用属性<code class="codeph">xdb:tableProps</code>和<code class="codeph">xdb:columnProps</code>指定的任何文本都将附加到生成的<code class="codeph">CREATE TABLE</code>语句中。
                     </p>
                     <div class="example" id="GUID-54A3CBE8-19BE-43BB-8979-7769116B6F53__CEGGHHGE">
                        <p class="titleinexample">示例18-2全局元素PurchaseOrder的默认表</p><pre class="pre codeblock"><code>DESCRIBE“PurchaseOrder1669_TAB”名称是否为空？输入--------------------------- ----- ----------------- ------ SYS.XMLTYPE表（XMLSchema“http://xmlns.oracle.com/xdb/documentation/purchaseOrder.xsd”元素“PurchaseOrder”）存储对象关系类型“PurchaseOrderType1668_T”</code></pre></div>
                     <!-- class="example" -->
                  </div>
                  <div>
                     <div class="familylinks">
                        <div class="parentlink">
                           <p><strong>父主题：</strong> <a href="XML-Schema-and-query-object-relational-storage.html#GUID-79213AD7-C940-400B-BC11-5E401A1520A6" title="XML文档的对象关系存储基于将文档内容分解为一组SQL对象。这些SQL对象基于SQL 1999 Type框架。向Oracle XML DB注册XML模式时，将从模式自动生成所需的SQL类型定义。">XML文档的对象关系存储</a></p>
                        </div>
                     </div>
                  </div>
                  
               </div><a id="ADXDB6229"></a><div class="props_rev_3"><a id="GUID-75FCD51E-73B6-4CA6-BE6F-94553B73E9E0" name="GUID-75FCD51E-73B6-4CA6-BE6F-94553B73E9E0"></a><h4 id="ADXDB-GUID-75FCD51E-73B6-4CA6-BE6F-94553B73E9E0" class="sect4"><span class="enumeration_section">18.1.4</span>不要使用XML模式注册期间生成的内部构造</h4>
                  <div>
                     <p>通常，在XML模式注册期间自动生成的SQL构造（数据类型，嵌套表和与外部存储关联的表）是Oracle XML DB的<span class="italic">内部</span>构造。 Oracle建议您<span class="italic">不要</span>在代码中使用它们。
                     </p>
                     <p>更准确地说，生成的SQL数据类型，嵌套表和与外部存储相关联的表基于特定的内部XML模式到对象类型映射，Oracle可以随时对其进行更改和重新定义。一般来说：</p>
                     <ul style="list-style-type:disc">
                        <li>
                           <p>不要使用任何生成的SQL数据类型。</p>
                        </li>
                        <li>
                           <p>不要访问或修改任何生成的嵌套表或外联表。</p>
                        </li>
                     </ul>
                     <p>但是，您可以修改生成的表的存储选项（例如分区），还可以在生成的表上创建索引和约束。您还可以自由使用Oracle XML DB提供的任何XML架构注释，包括命名生成的构造的注释。</p>
                  </div>
                  <div>
                     <div class="familylinks">
                        <div class="parentlink">
                           <p><strong>父主题：</strong> <a href="XML-Schema-and-query-object-relational-storage.html#GUID-79213AD7-C940-400B-BC11-5E401A1520A6" title="XML文档的对象关系存储基于将文档内容分解为一组SQL对象。这些SQL对象基于SQL 1999 Type框架。向Oracle XML DB注册XML模式时，将从模式自动生成所需的SQL类型定义。">XML文档的对象关系存储</a></p>
                        </div>
                     </div>
                  </div>
                  
               </div><a id="ADXDB4468"></a><div class="props_rev_3"><a id="GUID-D3206DC0-7581-4AD3-8B46-9F38555D47CB" name="GUID-D3206DC0-7581-4AD3-8B46-9F38555D47CB"></a><h4 id="ADXDB-GUID-D3206DC0-7581-4AD3-8B46-9F38555D47CB" class="sect4"><span class="enumeration_section">18.1.5</span>生成的名称区分大小写</h4>
                  <div>
                     <p>XML模式注册生成的任何SQL表，对象和属性的名称<span class="italic">区分大小写</span> 。
                     </p>
                     <p>例如，在<a href="XML-Schema-and-query-object-relational-storage.html#GUID-54A3CBE8-19BE-43BB-8979-7769116B6F53__CEGGHHGE">例18-2中</a> ，表<code class="codeph">PurchaseOrder1669_TAB</code>的名称是从元素<code class="codeph">PurchaseOrder</code>的名称派生的，因此它也是大小写混合的。因此，您必须使用带引号的标识符来引用此表： <span class="bold"><code class="codeph">"</code></span> <code class="codeph">PurchaseOrder1669_TAB</code> <span class="bold"><code class="codeph">"</code></span> 。如果不这样做会导致对象未找到错误，例如<code class="codeph">ORA-00942: table or view does not exist</code> 。
                     </p>
                  </div>
                  <div>
                     <div class="familylinks">
                        <div class="parentlink">
                           <p><strong>父主题：</strong> <a href="XML-Schema-and-query-object-relational-storage.html#GUID-79213AD7-C940-400B-BC11-5E401A1520A6" title="XML文档的对象关系存储基于将文档内容分解为一组SQL对象。这些SQL对象基于SQL 1999 Type框架。向Oracle XML DB注册XML模式时，将从模式自动生成所需的SQL类型定义。">XML文档的对象关系存储</a></p>
                        </div>
                     </div>
                  </div>
                  
               </div><a id="ADXDB4484"></a><div class="props_rev_3"><a id="GUID-AF8651CF-49C5-4B13-A198-0AE1F0770439" name="GUID-AF8651CF-49C5-4B13-A198-0AE1F0770439"></a><h4 id="ADXDB-GUID-AF8651CF-49C5-4B13-A198-0AE1F0770439" class="sect4"><span class="enumeration_section">18.1.6</span>对象关系存储的SYS_XDBPD $和DOM保真度</h4>
                  <div>
                     <p>为了提供以对象关系存储的XML数据的DOM保真度，Oracle XML DB使用系统定义的二进制对象属性<code class="codeph">SYS_XDBPD$</code>将所有无法存储在任何其他对象属性中的信息记录为实例级元数据（位置描述符或PD）。
                     </p>
                     <p>通过XML数据的对象关系存储，XML模式中声明的元素和属性将映射到相应SQL对象类型的单独属性。但是，XML实例文档中的以下信息不存储在这些对象属性中：</p>
                     <ul style="list-style-type:disc">
                        <li>
                           <p>命名空间声明</p>
                        </li>
                        <li>
                           <p>评论</p>
                        </li>
                        <li>
                           <p>前缀信息</p>
                        </li>
                     </ul>
                     <p>为了提供存储对象关系的XML数据的DOM保真度，Oracle XML DB使用单独的机制来跟踪此信息：它被记录为实例级元数据。</p>
                     <p>使用系统定义的二进制对象属性<code class="codeph">SYS_XDBPD$</code>在类型级别跟踪此元数据。该对象属性称为<strong class="term">位置描述符</strong> ，简称<strong class="term">PD</strong> 。
                     </p>
                     <p>PD仅供Oracle XML DB <span class="italic">内部使用</span> 。您永远不应该直接访问或操纵列PD。</p>
                     <p>位置描述符存储无法存储在任何其他对象属性中的所有信息。PD信息用于确保存储在Oracle XML DB中的所有XML文档的DOM保真度。 PD信息的示例包括：排序信息，注释，处理指令和命名空间前缀。</p>
                     <p>如果不需要DOM保真度，则可以通过在类型级别的XML模式<code class="codeph">SYS_XDBPD$</code>属性<code class="codeph">xdb:maintainDOM</code>设置为<code class="codeph">false</code>来禁止使用<code class="codeph">SYS_XDBPD$</code> 。
                     </p>
                     <div class="infoboxnote" id="GUID-AF8651CF-49C5-4B13-A198-0AE1F0770439__GUID-5A6B079D-FEC1-4FD0-865D-37994A8E4F49">
                        <p class="notep1">注意：</p>
                        <p>为清楚起见，本书中的许多示例中省略了对象属性<code class="codeph">SYS_XDBPD$</code> 。但是，它始终作为XML模式注册过程生成的所有SQL对象类型中的位置描述符（PD）列存在。
                        </p>
                        <p>通常，Oracle建议您不要禁止PD属性，因为如果没有PD列，额外信息（如注释和处理指令）可能会丢失。</p>
                     </div>
                     <div class="section"></div>
                     <!-- class="section" -->
                  </div>
                  <div>
                     <div class="relinfo">
                        <p><strong>相关话题</strong></p>
                        <ul>
                           <li><a href="XML-Schema-and-query-object-relational-storage.html#GUID-9F096CEA-7101-4CB9-AC16-2BC0EC370674" title="您可以在XML模式中显式指定SQLType值作为注释。您指定的SQL数据类型用于XML模式验证，覆盖默认的SQL数据类型。">声明属性时，可以覆盖XML模式中的SQLType值</a></li>
                           <li><a href="XML-Schema-and-query-object-relational-storage.html#GUID-ED63CA4B-1200-4000-89A3-DA8B4E48E597" title="默认情况下，基于complexType的元素映射到SQL对象类型，该类型包含与其每个子元素和属性对应的对象属性。您可以通过在输入XML模式中显式指定属性SQLType的值来覆盖此映射。">声明元素时覆盖XML模式中的SQLType值</a></li>
                        </ul>
                     </div>
                     <div class="infoboxnotealso" id="GUID-AF8651CF-49C5-4B13-A198-0AE1F0770439__GUID-7B77A148-1DCB-4722-8C9F-057B004A5464">
                        <p class="notep1">也可以看看：</p>
                        <p><a href="XML-Schema-and-query-basic.html#GUID-F809A6FE-28CD-4776-AB11-0B34ECBD9FF6" title="DOM保真度意味着保留XML文档中的所有信息，除了无关紧要的空白。您可以使用DOM保真度来确保存储在Oracle XML DB中的XML文档的准确性和完整性。">DOM Fidelity，</a>用于获取有关DOM数据的DOM保真度和二进制XML存储的信息</p>
                     </div>
                     <div class="familylinks">
                        <div class="parentlink">
                           <p><strong>父主题：</strong> <a href="XML-Schema-and-query-object-relational-storage.html#GUID-79213AD7-C940-400B-BC11-5E401A1520A6" title="XML文档的对象关系存储基于将文档内容分解为一组SQL对象。这些SQL对象基于SQL 1999 Type框架。向Oracle XML DB注册XML模式时，将从模式自动生成所需的SQL类型定义。">XML文档的对象关系存储</a></p>
                        </div>
                     </div>
                  </div>
                  
               </div>
            </div><a id="ADXDB4514"></a><div class="props_rev_3"><a id="GUID-F7E43D3A-67D8-432E-833A-DE0EA4CFCE7A" name="GUID-F7E43D3A-67D8-432E-833A-DE0EA4CFCE7A"></a><h3 id="ADXDB-GUID-F7E43D3A-67D8-432E-833A-DE0EA4CFCE7A" class="sect3"><span class="enumeration_section">18.2</span> Oracle XML模式注释</h3>
               <div>
                  <p>您可以注释XML模式以影响XML模式注册过程生成的对象和表。您可以通过向XML模式声明的<code class="codeph">complexType</code> ， <code class="codeph">element</code>和<code class="codeph">attribute</code>定义添加特定于Oracle的属性来完成此操作。
                  </p>
                  <p>您可以通过编辑XML模式文档手动添加此类注释，或者，对于最常见的注释，可以通过调用特定于注释的PL / SQL子程序来添加。请参阅“ <a href="../arpls/DBMS_XMLSCHEMA_ANNOTATE.html#ARPLS73580" target="_blank"><span><cite>Oracle数据库PL / SQL包和类型参考”</cite></span></a> ，“DBMS_XMLSCHEMA_ANNOTATE”一章。
                  </p>
                  <p>如果使用Altova XMLSpy编辑器手动编辑XML模式，则可以利用编辑器中的<span class="italic">Oracle</span>选项卡添加和编辑特定于Oracle的注释。请参<a href="XML-Schema-and-query-basic.html#GUID-0E11429E-1FF3-4C75-8B50-416A7F5C60C8__CEGIBHEB">见图17-2</a> 。
                  </p>
                  <p>Oracle XML DB使用的大多数XML属性都属于命名空间<code class="codeph">http://xmlns.oracle.com/xdb</code> 。用于将XML数据编码为二进制XML的XML属性属于命名空间<code class="codeph">http://xmlns.oracle.com/2004/CSX</code> 。为了简化注释XML模式的过程，Oracle建议您在XML模式的根元素中声明名称空间前缀。
                  </p>
               </div>
               <div>
                  <ul class="ullinks">
                     <li class="ulchildlink"><a href="XML-Schema-and-query-object-relational-storage.html#GUID-087E2342-9239-4D23-BA4F-36C3F7BF49CF">XML模式注释的常见用法</a><br>您可以注释XML模式以自定义对象关系表，对象和对象属性的名称，或者在XQuery表达式参数以递归XML数据为目标时允许XPath重写。
                     </li>
                     <li class="ulchildlink"><a href="XML-Schema-and-query-object-relational-storage.html#GUID-0B63577E-7129-4F6B-8DE3-E6688F87AD4D">XML Schema Annotation示例</a><br>示例XML架构说明了一些最重要的Oracle XML DB注释。
                     </li>
                     <li class="ulchildlink"><a href="XML-Schema-and-query-object-relational-storage.html#GUID-A5E5BCE6-D72E-47C1-B637-6A0CAF9D6359">使用DBMS_XMLSCHEMA_ANNOTATE注释XML模式</a><br>PL / SQL包<code class="codeph">DBMS_XMLSCHEMA_ANNOTATE</code>提供子程序来注释XML模式。与手动编辑XML模式相比，使用这些子程序通常更方便，更不容易出错。
                     </li>
                     <li class="ulchildlink"><a href="XML-Schema-and-query-object-relational-storage.html#GUID-429A6872-5258-439F-B427-7AFFD054C00C">可用的Oracle XML DB XML模式注释</a><br>将描述您可以在元素和属性声明中指定的Oracle XML DB注释，以及可用于操作它们的<code class="codeph">DBMS_XMLSCHEMA_ANNOTATE</code>包中的PL / SQL子程序。
                     </li>
                     <li class="ulchildlink"><a href="XML-Schema-and-query-object-relational-storage.html#GUID-B1B67DF3-8E3A-4383-B67F-D14EF98BFBE9">对象关系存储的XML模式注释指南</a><br>对于以对象方式存储的<code class="codeph">XMLType</code>数据，需要仔细规划，以优化性能。对关系数据也有类似的考虑：实体关系模型，索引，数据类型，表分区等。要启用XPath重写并获得最佳性能，可以使用XML模式注释实现许多此类设计选择。
                     </li>
                     <li class="ulchildlink"><a href="XML-Schema-and-query-object-relational-storage.html#GUID-0A560425-E6F2-4AA2-9818-B80EFE2D0AD3">查询已注册的XML模式以获取注释</a><br>您可以查询数据库视图<code class="codeph">USER_XML_SCHEMAS</code>和<code class="codeph">ALL_XML_SCHEMAS</code>以获取包含其所有注释的已注册XML模式。XML模式的注册版本包含一整套Oracle XML DB注释。这些注释由用户提供或在XML模式注册期间默认设置。
                     </li>
                  </ul>
                  <div class="familylinks">
                     <div class="parentlink">
                        <p><strong>父主题：</strong> <a href="XML-Schema-and-query-object-relational-storage.html#GUID-B0C1A0B0-2DD1-491A-8CE1-1F857FD267B7" title="基于XML Schema的数据的高级技术包括使用对象关系存储;注释XML模式;将Schema数据类型映射到SQL;使用complexType扩展和限制;创建，指定关系约束，分区基于XML Schema的数据，存储XMLType数据，使用复杂或大型模式，以及调试模式注册。">XML模式存储和查询：对象关系存储</a></p>
                     </div>
                  </div>
               </div>
               <a id="ADXDB4515"></a><div class="props_rev_3"><a id="GUID-087E2342-9239-4D23-BA4F-36C3F7BF49CF" name="GUID-087E2342-9239-4D23-BA4F-36C3F7BF49CF"></a><h4 id="ADXDB-GUID-087E2342-9239-4D23-BA4F-36C3F7BF49CF" class="sect4"><span class="enumeration_section">18.2.1</span> XML模式注释的常见用法</h4>
                  <div>
                     <p>您可以注释XML模式以自定义对象关系表，对象和对象属性的名称，或者在XQuery表达式参数以递归XML数据为目标时允许XPath重写。</p>
                     <p>想要注释XML模式的常见原因包括：</p>
                     <ul style="list-style-type:disc">
                        <li>
                           <p>确保由PL / SQL过程<code class="codeph">DBMS_XMLSCHEMA.registerSchema</code>创建的用于<code class="codeph">XMLType</code>数据的对象关系存储的表，对象和对象属性的名称易于识别并符合任何应用程序命名标准。将参数<code class="codeph">GENTYPES</code>或<code class="codeph">GENTABLES</code>设置为<code class="codeph">TRUE</code> （ <code class="codeph">TRUE</code>是每个参数的默认值）。
                           </p>
                        </li>
                        <li>
                           <p>防止在直接使用SQL时生成需要使用带引号的标识符的混合大小写名称。</p>
                        </li>
                        <li>
                           <p>在文档相关的递归XPath查询的情况下，允许对对象关系存储进行XPath重写。这适用于SQL / XML访问和查询函数的某些应用程序，其XQuery表达式参数以递归XML数据为目标。</p>
                        </li>
                     </ul>
                     <p>最常用的XML模式注释如下：</p>
                     <ul style="list-style-type:disc">
                        <li>
                           <p><code class="codeph">xdb:defaultTable</code> - 当参数<code class="codeph">GENTABLES</code>为<code class="codeph">TRUE</code>时为每个全局元素生成的默认表的名称。将其设置为空字符串<span class="bold"><code class="codeph">""</code></span>可防止为相关元素生成默认表。
                           </p>
                        </li>
                        <li>
                           <p><code class="codeph">xdb:SQLName</code> - 与XML架构中定义的每个元素或属性对应的SQL对象属性的名称。
                           </p>
                        </li>
                        <li>
                           <p><code class="codeph">xdb:SQLType</code> - 对于<code class="codeph">complexType</code>定义，对应的对象类型。对于<code class="codeph">simpleType</code>定义， <code class="codeph">SQLType</code>用于覆盖XML架构数据类型和SQL数据类型之间的默认映射。<code class="codeph">SQLType</code>一个常见用途是定义何时应将无界字符串存储为<code class="codeph">CLOB</code>值，而不是作为<code class="codeph">VARCHAR(4000) CHAR</code>值（默认值）。注意：您不能将数据类型<code class="codeph">NCHAR</code> ， <code class="codeph">NVARCHAR2</code>或<code class="codeph">NCLOB</code>用作<code class="codeph">SQLType</code>注释的值。
                           </p>
                           <div class="infoboxnote" id="GUID-087E2342-9239-4D23-BA4F-36C3F7BF49CF__STARTINGWITHORACLEDATABASE12CRELEAS-2195990D">
                              <p class="notep1">注意：</p>
                              <p>从Oracle Database 12c第2版（12.2.0.1）开始，如果为<span class="italic">应用程序公共用户</span>注册对象关系存储的XML模式，则<span class="italic">必须</span>使用<code class="codeph">xdb:SQLType</code>注释模式中的每个复杂类型，以命名SQL数据类型。否则，会引发错误。
                              </p>
                           </div>
                        </li>
                        <li>
                           <p><code class="codeph">xdb:SQLCollType</code> - 用于指定管理元素集合的varray类型。
                           </p>
                        </li>
                        <li>
                           <p><code class="codeph">xdb:maintainDOM</code> - 用于确定是否应为给定的<code class="codeph">complexType</code>定义维护DOM保真度</p>
                        </li>
                     </ul>
                     <p>您无需为任何这些属性指定值。默认情况下，Oracle XML DB在XML模式注册过程中提供适当的值。但是，如果您使用的是对象关系存储，那么Oracle建议您至少指定顶级SQL类型的名称，以便稍后引用它们。</p>
                  </div>
                  <div>
                     <div class="familylinks">
                        <div class="parentlink">
                           <p><strong>父主题：</strong> <a href="XML-Schema-and-query-object-relational-storage.html#GUID-F7E43D3A-67D8-432E-833A-DE0EA4CFCE7A" title="您可以注释XML模式以影响XML模式注册过程生成的对象和表。您可以通过向XML模式声明的complexType，元素和属性定义添加特定于Oracle的属性来完成此操作。">Oracle XML模式注释</a></p>
                        </div>
                     </div>
                  </div>
                  
               </div><a id="ADXDB4517"></a><a id="ADXDB4518"></a><a id="ADXDB4516"></a><div class="props_rev_3"><a id="GUID-0B63577E-7129-4F6B-8DE3-E6688F87AD4D" name="GUID-0B63577E-7129-4F6B-8DE3-E6688F87AD4D"></a><h4 id="ADXDB-GUID-0B63577E-7129-4F6B-8DE3-E6688F87AD4D" class="sect4"><span class="enumeration_section">18.2.2</span> XML模式注释示例</h4>
                  <div>
                     <p>示例XML架构说明了一些最重要的Oracle XML DB注释。</p>
                     <p><a href="XML-Schema-and-query-object-relational-storage.html#GUID-0B63577E-7129-4F6B-8DE3-E6688F87AD4D__BJFBCHGH">例18-3中</a>的XML模式类似于<a href="oracle-supplied-XML-schemas-and-examples.html#GUID-1CB2213C-C6E8-4BC4-86A3-EFDE51AEBEFD__BABDAGBF">示例A-2中</a>的XML模式，但它还定义了<code class="codeph">Notes</code>元素及其类型<code class="codeph">NotesType</code> 。
                     </p>
                     <ul style="list-style-type:disc">
                        <li>
                           <p><code class="codeph">schema</code>元素包含<code class="codeph">xdb</code>命名空间的声明。
                           </p>
                        </li>
                        <li>
                           <p>全局元素<code class="codeph">PurchaseOrder</code>的定义包括<code class="codeph">defaultTable</code>注释，该注释指定与此元素关联的默认表的名称是<code class="codeph">purchaseorder</code> 。
                           </p>
                        </li>
                        <li>
                           <p>全局复杂类型<code class="codeph">PurchaseOrderType</code>的定义包括<code class="codeph">SQLType</code>注释，该注释指定生成的SQL对象类型名为<code class="codeph">purchaseorder_t</code> 。在此类型的定义中，使用以下注释：</p>
                           <ul style="list-style-type:disc">
                              <li>
                                 <p>元素<code class="codeph">Reference</code>的定义包括一个<code class="codeph">SQLName</code>注释，它指定对应于XML元素<code class="codeph">Reference</code>的SQL属性被命名为<code class="codeph">reference</code> 。
                                 </p>
                              </li>
                              <li>
                                 <p>元素<code class="codeph">Actions</code>的定义包括<code class="codeph">SQLName</code>注释，该注释指定与XML元素<code class="codeph">Actions</code>对应的SQL属性名为<code class="codeph">action_collection</code> 。
                                 </p>
                              </li>
                              <li>
                                 <p>元素<code class="codeph">USER</code>的定义包括<code class="codeph">SQLName</code>注释，该注释指定与XML元素<code class="codeph">User</code>对应的SQL属性被命名为<code class="codeph">email</code> 。
                                 </p>
                              </li>
                              <li>
                                 <p>元素<code class="codeph">LineItems</code>的定义包括<code class="codeph">SQLName</code>注释，该注释指定对应于XML元素<code class="codeph">LineItems</code>的SQL属性被命名为<code class="codeph">lineitem_collection</code> 。
                                 </p>
                              </li>
                              <li>
                                 <p>元素<code class="codeph">Notes</code>的定义包括一个<code class="codeph">SQLType</code>注释，它指定与XML元素<code class="codeph">Notes</code>对应的SQL属性的数据类型是<code class="codeph">CLOB</code> 。</p>
                              </li>
                           </ul>
                        </li>
                        <li>
                           <p>全局复杂类型<code class="codeph">LineItemsType</code>的定义包括一个<code class="codeph">SQLType</code>注释，指定生成的SQL对象类型名为<code class="codeph">lineitems_t</code> 。在此类型的定义中，使用以下注释：</p>
                           <ul style="list-style-type:disc">
                              <li>
                                 <p>元素<code class="codeph">LineItem</code>的定义包括一个<code class="codeph">SQLName</code>注释，它指定对应于XML元素<code class="codeph">LineItems</code>的SQL属性的数据类型命名为<code class="codeph">lineitem_varray</code> ，以及一个<code class="codeph">SQLCollName</code>注释，指定管理该集合的SQL对象类型命名为<code class="codeph">lineitem_v</code> 。</p>
                              </li>
                           </ul>
                        </li>
                        <li>
                           <p>全局复杂类型<code class="codeph">LineItemType</code>的定义包括一个<code class="codeph">SQLType</code>注释，该注释指定生成的SQL对象类型名为<code class="codeph">lineitem_t</code> 。
                           </p>
                        </li>
                        <li>
                           <p>复杂类型<code class="codeph">PartType</code>的定义包括一个<code class="codeph">SQLType</code>注释，指定SQL对象类型名为<code class="codeph">part_t</code> 。它还包括注释<code class="codeph">xdb:maintainDOM = "false"</code> ，指定Oracle XML DB不需要基于此数据类型维护元素的DOM保真度。
                           </p>
                        </li>
                     </ul>
                     <p><a href="XML-Schema-and-query-object-relational-storage.html#GUID-0B63577E-7129-4F6B-8DE3-E6688F87AD4D__BJFGEIHH">例18-4</a>显示了注册<a href="XML-Schema-and-query-object-relational-storage.html#GUID-0B63577E-7129-4F6B-8DE3-E6688F87AD4D__BJFBCHGH">例18-3</a>的带注释的XML模式时创建的一些表和对象。
                     </p>
                     <p>以下是此XML架构注册的结果：</p>
                     <ul style="list-style-type:disc">
                        <li>
                           <p>创建了一个名为<code class="codeph">purchaseorder</code>的表。
                           </p>
                        </li>
                        <li>
                           <p>创建了称为<code class="codeph">purchaseorder_t</code> ， <code class="codeph">lineitems_t</code> ， <code class="codeph">lineitem_v</code> ， <code class="codeph">lineitem_t</code>和<code class="codeph">part_t</code>的类型。这些类型定义的属性根据提供的<code class="codeph">SQLName</code>注释命名。
                           </p>
                        </li>
                        <li>
                           <p><code class="codeph">purchaseorder_t</code>定义的<code class="codeph">Notes</code>属性是数据类型<code class="codeph">CLOB</code> 。</p>
                        </li>
                        <li>
                           <p>类型<code class="codeph">part_t</code>不包括位置描述符（PD）属性。
                           </p>
                        </li>
                        <li>
                           <p>创建了有序集合表（OCT）来管理<code class="codeph">LineItem</code>和<code class="codeph">Action</code>元素的集合。
                           </p>
                        </li>
                     </ul>
                     <div class="example" id="GUID-0B63577E-7129-4F6B-8DE3-E6688F87AD4D__BJFBCHGH">
                        <p class="titleinexample">示例18-3使用公共架构注释</p><pre class="pre codeblock"><code>&lt;xs：schema targetNamespace =“http://xmlns.oracle.com/xdb/documentation/purchaseOrder”xmlns：xs =“http://www.w3.org/2001/XMLSchema”xmlns：xdb =“http：/ /xmlns.oracle.com/xdb“xmlns：po =”http://xmlns.oracle.com/xdb/documentation/purchaseOrder“version =”1.0“&gt; &lt;xs：element name =”PurchaseOrder“type =”po： PurchaseOrderType“ <span class="bold">xdb：defaultTable</span> =”PURCHASEORDER“/&gt; &lt;xs：complexType name =”PurchaseOrderType“ <span class="bold">xdb：SQLType</span> =”PURCHASEORDER_T“&gt; &lt;xs：sequence&gt; &lt;xs：element name =”Reference“type =”po：ReferenceType“minOccurs =“1” <span class="bold">xdb：SQLName</span> =“REFERENCE”/&gt; &lt;xs：element name =“Actions”type =“po：ActionsType” <span class="bold">xdb：SQLName</span> =“ACTION_COLLECTION”/&gt; &lt;xs：element name =“Reject”type =“ po：RejectionType“minOccurs =”0“/&gt; &lt;xs：element name =”Requestor“type =”po：RequestorType“/&gt; &lt;xs：element name =”User“type =”po：UserType“minOccurs =”1“ <span class="bold">xdb：SQLName</span> =“EMAIL”/&gt; &lt;xs：element name =“CostCenter”type =“po：CostCenterType”/&gt; &lt;xs：element name =“ShippingInstructions”type =“po：ShippingInstructionsType”/&gt; &lt;xs：element name =“SpecialInstructions”type =“po：Spec ialInstructionsType“/&gt; &lt;xs：element name =”LineItems“type =”po：LineItemsType“ <span class="bold">xdb：SQLName</span> =”LINEITEM_COLLECTION“/&gt; <span class="bold">&lt;xs：element name =”Notes“type =”po：NotesType“xdb：SQLType =” CLOB“/&gt;</span> &lt;/ xs：sequence&gt; &lt;/ xs：complexType&gt; &lt;xs：complexType name =”LineItemsType“ <span class="bold">xdb：SQLType</span> =”LINEITEMS_T“&gt; &lt;xs：sequence&gt; &lt;xs：element name =”LineItem“type =” po：LineItemType“maxOccurs =”unbounded“ <span class="bold">xdb：SQLCollType</span> =”LINEITEM_V“ <span class="bold">xdb：SQLName</span> =”LINEITEM_VARRAY“/&gt; &lt;/ xs：sequence&gt; &lt;/ xs：complexType&gt; &lt;xs：complexType name =”LineItemType“ <span class="bold">xdb：SQLType</span> = “LINEITEM_T”&gt; &lt;xs：sequence&gt; &lt;xs：element name =“Description”type =“po：DescriptionType”/&gt; &lt;xs：element name =“Part”type =“po：PartType”/&gt; &lt;/ xs：sequence &gt; &lt;xs：attribute name =“ItemNumber”type =“xs：integer”/&gt; &lt;/ xs：complexType&gt; &lt;xs：complexType name =“PartType” <span class="bold">xdb：SQLType</span> =“PART_T” <span class="bold">xdb：maintainDOM</span> =“false”&gt; &lt; xs：attribute name =“Id”&gt; &lt;xs：simpleType&gt; &lt;xs：restriction base =“xs：string”&gt; &lt;xs：minLength value =“10”/&gt; &lt;xs：maxLength value =“14”/&gt; &lt;/ xs：restriction&gt; &lt;/ xs：simpleType&gt; &lt;/ xs：attribute&gt; &lt;xs：attribute name =“Quantity”type =“po：moneyType”/&gt; &lt;xs：attribute name =“UnitPrice”type =“po：quantityType”/&gt; &lt;/ xs：complexType&gt; <span class="bold">&lt;xs：simpleType name =“NotesType”&gt;</span> <span class="bold">&lt;xs ：restriction base =“xs：string”&gt;</span> <span class="bold">&lt;xs：minLength value =“1”/&gt;</span> <span class="bold">&lt;xs：maxLength value =“32767”/&gt;</span> <span class="bold">&lt;/ xs：restriction&gt;</span> <span class="bold">&lt;/ xs：simpleType&gt;</span> &lt;/ xs：schema&gt;</code></pre></div>
                     <!-- class="example" -->
                     <div class="example" id="GUID-0B63577E-7129-4F6B-8DE3-E6688F87AD4D__BJFGEIHH">
                        <p class="titleinexample">示例18-4注册带注释的XML模式</p><pre class="pre codeblock"><code>BEGIN DBMS_XMLSCHEMA.registerSchema（SCHEMAURL =&gt;'http://xmlns.oracle.com/xdb/documentation/purchaseOrder.xsd',SCHEMADOC =&gt; bfilename（'XMLDIR'，'purchaseOrder。Annotated.xsd'），LOCAL =&gt; TRUE，GENTYPES =&gt; TRUE，GENTABLES =&gt; TRUE，CSID =&gt; nls_charset_id（'AL32UTF8'））;结束; / SELECT table_name，xmlschema，element_name FROM USER_XML_TABLES; TABLE_NAME XMLSCHEMA ELEMENT_NAME ------------- ---------------------------------- -  ------------- PURCHASEORDER http://xmlns.oracle.com/xdb/documen PurchaseOrder tation / purchaseOrder.xsd选择了1行。DESCRIBE <span class="bold">purchaseorder</span>名称是否空？输入------------------------------ ----- -------------- --- SYS.XMLTYPE的表（XMLSchema“http://xmlns.oracle.com/xdb/documentation/purchaseOrder.xsd”ELEMENT“PurchaseOrder”）STORAGE对象关系类型“PURCHASEORDER_T”DESCRIBE <span class="bold">purchaseorder_t</span> PURCHASEORDER_T不是最终名称空？输入-------------------- ----- ------------------------ -  SYS_XDBPD $ XDB.XDB $ RAW_LIST_T REFERENCE VARCHAR2（30 CHAR）ACTION_COLLECTION ACTIONS_T拒绝REJECTION_T REQUESTOR VARCHAR2（128 CHAR）EMAIL VARCHAR2（10 CHAR）COSTCENTER VARCHAR2（4 CHAR）SHIPPINGINSTRUCTIONS SHIPPING_INSTRUCTIONS_T SPECIALINSTRUCTIONS VARCHAR2（2048 CHAR）LINEITEM_COLLECTION LINEITEMS_T备注CLOB DESCRIBE <span class="bold">lineitems_t</span> LINEITEMS_T不是最终名称空？输入-------------------- ----- ------------------------ -  SYS_XDBPD $ XDB.XDB $ RAW_LIST_T LINEITEM_VARRAY LINEITEM_V DESCRIBE <span class="bold">lineitem_v</span> LINEITEM_V VARRAY（2147483647）LINEITEM_T LINEITEM_T是不是最终名称空？输入-------------------- ----- ------------------------ -  SYS_XDBPD $ XDB.XDB $ RAW_LIST_T项目编号（38）说明VARCHAR2（256 CHAR）PART PART_T DESCRIBE <span class="bold">part_t</span> PART_T不是最终名称是否为空？输入-------------------- ----- ------------------------ -  ID VARCHAR2（14 CHAR）QUANTITY NUMBER（12,2）UNITPRICE NUMBER（8,4）SELECT table_name，parent_table_column FROM USER_NESTED_TABLES WHERE parent_table_name ='purchaseorder'; TABLE_NAME PARENT_TABLE_COLUMN ---------- ----------------------- SYS_NTNOHV + tfSTRaDTA9FETvBJw ==“XMLDATA”。“LINEITEM_COLLECTION”。“LINEITEM_VARRAY “SYS_NTV4bNVqQ1S4WdCIvBK5qjZA ==”XMLDATA“。”ACTION_COLLECTION“。”ACTION_VARRAY“选择了2行。
</code></pre></div>
                     <!-- class="example" -->
                  </div>
                  <div>
                     <div class="familylinks">
                        <div class="parentlink">
                           <p><strong>父主题：</strong> <a href="XML-Schema-and-query-object-relational-storage.html#GUID-F7E43D3A-67D8-432E-833A-DE0EA4CFCE7A" title="您可以注释XML模式以影响XML模式注册过程生成的对象和表。您可以通过向XML模式声明的complexType，元素和属性定义添加特定于Oracle的属性来完成此操作。">Oracle XML模式注释</a></p>
                        </div>
                     </div>
                  </div>
                  
               </div><a id="ADXDB6119"></a><a id="ADXDB6115"></a><div class="props_rev_3"><a id="GUID-A5E5BCE6-D72E-47C1-B637-6A0CAF9D6359" name="GUID-A5E5BCE6-D72E-47C1-B637-6A0CAF9D6359"></a><h4 id="ADXDB-GUID-A5E5BCE6-D72E-47C1-B637-6A0CAF9D6359" class="sect4"><span class="enumeration_section">18.2.3</span>使用DBMS_XMLSCHEMA_ANNOTATE注释XML模式</h4>
                  <div>
                     <p>PL / SQL包<code class="codeph">DBMS_XMLSCHEMA_ANNOTATE</code>提供子程序来注释XML模式。与手动编辑XML模式相比，使用这些子程序通常更方便，更不容易出错。
                     </p>
                     <p>特别是，您可以在脚本中使用PL / SQL子程序，您可以根据需要随时或多次运行该子程序。如果您使用的是大型XML架构或不希望手动修改的标准或其他第三方XML架构，则此功能尤其有用。</p>
                     <p>每个Oracle注释都有特定的PL / SQL子程序。例如，您使用PL / SQL过程<code class="codeph">setDefaultTable</code>添加<code class="codeph">xdb:defaultTable</code>注释，并使用<code class="codeph">removeDefaultTable</code>删除<code class="codeph">xdb:defaultTable</code>注释。
                     </p>
                     <p>每个注释子程序都有以下参数：</p>
                     <ul style="list-style-type:disc">
                        <li>
                           <p>要注释的XML模式。此参数为<code class="codeph">IN OUT</code> 。</p>
                        </li>
                        <li>
                           <p>要添加或删除注释的全局元素的名称。</p>
                        </li>
                        <li>
                           <p>注释（XML属性）值。</p>
                        </li>
                        <li>
                           <p>一个布尔标志，指示是否要覆盖任何相应的现有注释。默认情况下，它被覆盖。</p>
                        </li>
                     </ul>
                     <p>如果要注释的元素不是全局元素，则提供本地元素名称作为附加参数。全局和本地名称共同标识目标元素。具有本地名称的元素必须是具有全局名称的元素的后代。</p>
                     <p>如果使用SQL * Plus，则可以使用PL / SQL过程<code class="codeph">DBMS_XMLSCHEMA_ANNOTATE.printWarnings</code>在使用其他<code class="codeph">DBMS_XMLSCHEMA_ANNOTATE</code>子程序期间启用和禁用SQL * Plus警告的打印。默认情况下，不会打印任何警告。警告的一个示例是无法注释XML模式，因为没有元素具有您为注释子程序提供的名称。
                     </p>
                     <p><a href="XML-Schema-and-query-object-relational-storage.html#GUID-A5E5BCE6-D72E-47C1-B637-6A0CAF9D6359__CEGCJBBA">例18-5</a>使用PL / SQL包<code class="codeph">DBMS_XMLSCHEMA_ANNOTATE</code>子程序生成<a href="XML-Schema-and-query-object-relational-storage.html#GUID-0B63577E-7129-4F6B-8DE3-E6688F87AD4D__BJFBCHGH">示例18-3中</a>所示的带注释的XML模式。
                     </p>
                     <div class="infoboxnotealso" id="GUID-A5E5BCE6-D72E-47C1-B637-6A0CAF9D6359__GUID-6CE4644F-3B50-4A8C-9DB3-AF0FD3CC5897">
                        <p class="notep1">也可以看看：</p>
                        <p><a href="../arpls/DBMS_XMLSCHEMA_ANNOTATE.html#ARPLS73580" target="_blank"><span><cite>Oracle Database PL / SQL包和类型参考</cite></span></a> ，“DBMS_XMLSCHEMA_ANNOTATE”一章</p>
                     </div>
                     <div class="example" id="GUID-A5E5BCE6-D72E-47C1-B637-6A0CAF9D6359__CEGCJBBA">
                        <p class="titleinexample">示例18-5使用DBMS_XMLSCHEMA_ANNOTATE</p><pre class="oac_no_warn" dir="ltr">CREATE TABLE annotation_tab（id NUMBER，inp XMLType，out XMLType）; INSERT INTO annotation_tab VALUES（1，...未注释的XML模式......）; DECLARE架构XMLType; BEGIN SELECT t.inp INTO schema FROM annotation_tab t WHERE t.id = 1; DBMS_XMLSCHEMA_ANNOTATE。 <span class="bold">setDefaultTable</span> （schema，'PurchaseOrder'，' <span class="bold">PURCHASEORDER</span> '）; DBMS_XMLSCHEMA_ANNOTATE。 <span class="bold">setSQLType</span> （schema，'PurchaseOrderType'，' <span class="bold">PURCHASEORDER_T</span> '）; DBMS_XMLSCHEMA_ANNOTATE。 <span class="bold">setSQLName</span> （schema，'complexType'，'PurchaseOrderType'，'element'，' <span class="bold">Reference</span> '，' <span class="bold">REFERENCE</span> '）; DBMS_XMLSCHEMA_ANNOTATE。 <span class="bold">setSQLName</span> （schema，'complexType'，'PurchaseOrderType'，'element'，' <span class="bold">Actions</span> '，' <span class="bold">ACTIONS_COLLECTION</span> '）; DBMS_XMLSCHEMA_ANNOTATE。 <span class="bold">setSQLName</span> （schema，'complexType'，'PurchaseOrderType'，'element'，' <span class="bold">User</span> '，' <span class="bold">EMAIL</span> '）; DBMS_XMLSCHEMA_ANNOTATE。 <span class="bold">setSQLName</span> （schema，'complexType'，'PurchaseOrderType'，'element'，' <span class="bold">LineItems</span> '，' <span class="bold">LINEITEM_COLLECTION</span> '）; DBMS_XMLSCHEMA_ANNOTATE。 <span class="bold">setSQLType</span> （schema，'complexType'，'PurchaseOrderType'，'element'，'Notes'，' <span class="bold">CLOB</span> '）; DBMS_XMLSCHEMA_ANNOTATE。 <span class="bold">setSQLType</span> （schema，'LineItemsType'，' <span class="bold">LINEITEMS_T</span> '）; DBMS_XMLSCHEMA_ANNOTATE。 <span class="bold">setSQLCollType</span> （schema，'complexType'，'LineItemsType'，'LineItem'，' <span class="bold">LINEITEM_V</span> '）; DBMS_XMLSCHEMA_ANNOTATE。 <span class="bold">setSQLName</span> （schema，'complexType'，'LineItemsType'，'element'，' <span class="bold">LineItem</span> '，' <span class="bold">LINEITEM_VARRAY</span> '）; DBMS_XMLSCHEMA_ANNOTATE。 <span class="bold">setSQLType</span> （schema，'LineItemType'，' <span class="bold">LINEITEM_T</span> '）; DBMS_XMLSCHEMA_ANNOTATE。 <span class="bold">setSQLType</span> （schema，'PartType'，' <span class="bold">PART_T</span> '）; DBMS_XMLSCHEMA_ANNOTATE。 <span class="bold">disableMaintainDom</span> （schema，' <span class="bold">PartType</span> '）; UPDATE annotation_tab t SET t.out = schema WHERE t.id = 1;结束; /</pre></div>
                     <!-- class="example" -->
                  </div>
                  <div>
                     <div class="familylinks">
                        <div class="parentlink">
                           <p><strong>父主题：</strong> <a href="XML-Schema-and-query-object-relational-storage.html#GUID-F7E43D3A-67D8-432E-833A-DE0EA4CFCE7A" title="您可以注释XML模式以影响XML模式注册过程生成的对象和表。您可以通过向XML模式声明的complexType，元素和属性定义添加特定于Oracle的属性来完成此操作。">Oracle XML模式注释</a></p>
                        </div>
                     </div>
                  </div>
                  
               </div><a id="ADXDB4520"></a><a id="ADXDB4521"></a><a id="ADXDB4522"></a><a id="ADXDB4519"></a><div class="props_rev_3"><a id="GUID-429A6872-5258-439F-B427-7AFFD054C00C" name="GUID-429A6872-5258-439F-B427-7AFFD054C00C"></a><h4 id="ADXDB-GUID-429A6872-5258-439F-B427-7AFFD054C00C" class="sect4"><span class="enumeration_section">18.2.4</span>可用的Oracle XML DB XML模式注释</h4>
                  <div>
                     <p>将描述您可以在元素和属性声明中指定的Oracle XML DB注释，以及可用于操作它们的<code class="codeph">DBMS_XMLSCHEMA_ANNOTATE</code>包中的PL / SQL子程序。
                     </p>
                     <div class="section">
                        <p>除了具有前缀<code class="codeph">csx</code>注释之外的所有注释都适用于为对象关系存储注册的XML模式。
                        </p>
                        <p>以下注释适用于为二进制XML存储注册的XML模式：</p>
                        <ul style="list-style-type:disc">
                           <li>
                              <p><code class="codeph">XDB：defaultTable</code></p>
                           </li>
                           <li>
                              <p><code class="codeph">XDB：tableProps</code></p>
                           </li>
                        </ul>
                        <div class="infoboxnotealso" id="GUID-429A6872-5258-439F-B427-7AFFD054C00C__GUID-38C69C39-2E1E-484D-AB63-81A290B27362">
                           <p class="notep1">也可以看看：</p>
                           <p><a href="../arpls/DBMS_XMLSCHEMA_ANNOTATE.html#ARPLS73580" target="_blank"><span><cite>Oracle Database PL / SQL包和类型参考</cite></span></a> ，“DBMS_XMLSCHEMA_ANNOTATE”一章</p>
                        </div>
                     </div>
                     <!-- class="section" -->
                     <div class="tblformalwide" id="GUID-429A6872-5258-439F-B427-7AFFD054C00C__G1048403">
                        <p class="titleintable">表18-1元素中的注释</p>
                        <table cellpadding="4" cellspacing="0" class="FormalWide" title="元素中的注释" width="100%" border="1" summary="This table lists attributes you can specify in elements, with Oracle XML DB." frame="hsides" rules="rows">
                           <thead>
                              <tr align="left" valign="top">
                                 <th align="left" valign="bottom" width="30%" id="d86720e1985">属性和PL / SQL</th>
                                 <th align="left" valign="bottom" width="11%" id="d86720e1988">值</th>
                                 <th align="left" valign="bottom" width="13%" id="d86720e1991">默认</th>
                                 <th align="left" valign="bottom" width="46%" id="d86720e1994">描述</th>
                              </tr>
                           </thead>
                           <tbody>
                              <tr align="left" valign="top">
                                 <td align="left" valign="top" width="30%" id="d86720e1999" headers="d86720e1985 "><pre class="oac_no_warn" dir="ltr">XDB：columnProps</pre><p>没有适用的PL / SQL。</p>
                                 </td>
                                 <td align="left" valign="top" width="11%" headers="d86720e1999 d86720e1988 ">
                                    <p>任何列存储子句</p>
                                 </td>
                                 <td align="left" valign="top" width="13%" headers="d86720e1999 d86720e1991 ">
                                    <p><code class="codeph">空值</code></p>
                                 </td>
                                 <td align="left" valign="top" width="46%" headers="d86720e1999 d86720e1994 ">
                                    <p>指定插入缺省<code class="codeph">CREATE TABLE</code>语句的<code class="codeph">COLUMN</code>存储子句。它主要用于映射到SQL表的元素，即顶级元素声明和外部元素声明。
                                    </p>
                                 </td>
                              </tr>
                              <tr align="left" valign="top">
                                 <td align="left" valign="top" width="30%" id="d86720e2021" headers="d86720e1985 "><pre class="oac_no_warn" dir="ltr">XDB：defaultTable</pre><p>PL / SQL：</p><pre class="oac_no_warn" dir="ltr">setDefaultTable removeDefaultTable enableDefaultTableCreation disableDefaultTableCreation</pre></td>
                                 <td align="left" valign="top" width="11%" headers="d86720e2021 d86720e1988 ">
                                    <p>任何表名</p>
                                 </td>
                                 <td align="left" valign="top" width="13%" headers="d86720e2021 d86720e1991 ">
                                    <p>基于元素名称</p>
                                 </td>
                                 <td align="left" valign="top" width="46%" headers="d86720e2021 d86720e1994 ">
                                    <p>指定存储此XML架构的XML实例的SQL表的名称。这在从API和协议（例如FTP和HTTP（S））插入XML数据的情况下非常有用，其中未指定表名。适用于对象关系存储和二进制XML存储。</p>
                                 </td>
                              </tr>
                              <tr align="left" valign="top">
                                 <td align="left" valign="top" width="30%" id="d86720e2038" headers="d86720e1985 "><pre class="oac_no_warn" dir="ltr">XDB：maintainDOM</pre><p>PL / SQL：</p><pre class="oac_no_warn" dir="ltr">enableMaintainDOM disableMaintainDOM</pre></td>
                                 <td align="left" valign="top" width="11%" headers="d86720e2038 d86720e1988 ">
                                    <p><code class="codeph">true</code> | <code class="codeph">false</code></p>
                                 </td>
                                 <td align="left" valign="top" width="13%" headers="d86720e2038 d86720e1991 ">
                                    <p><code class="codeph">真正</code></p>
                                 </td>
                                 <td align="left" valign="top" width="46%" headers="d86720e2038 d86720e1994 ">
                                    <p>如果为<code class="codeph">true</code> ，则存储此元素的实例，以便它们在输出时保留DOM保真度。这意味着除了元素的排序之外，还保留所有注释，处理指令，命名空间声明等。
                                    </p>
                                    <p>如果为<code class="codeph">false</code> ，则不保证输出与输入具有相同的DOM操作。
                                    </p>
                                 </td>
                              </tr>
                              <tr align="left" valign="top">
                                 <td align="left" valign="top" width="30%" id="d86720e2068" headers="d86720e1985 "><pre class="oac_no_warn" dir="ltr">XDB：SQLCollType</pre><p>PL / SQL：</p><pre class="oac_no_warn" dir="ltr">setSQLCollType removeSQLCollType</pre></td>
                                 <td align="left" valign="top" width="11%" headers="d86720e2068 d86720e1988 ">
                                    <p>任何SQL集合类型</p>
                                 </td>
                                 <td align="left" valign="top" width="13%" headers="d86720e2068 d86720e1991 ">
                                    <p>从元素名称生成的名称</p>
                                 </td>
                                 <td align="left" valign="top" width="46%" headers="d86720e2068 d86720e1994 ">
                                    <p>与此XML元素对应的SQL集合类型的名称。必须使用<code class="codeph">maxOccurs</code> &gt; 1指定XML元素。
                                    </p>
                                 </td>
                              </tr>
                              <tr align="left" valign="top">
                                 <td align="left" valign="top" width="30%" id="d86720e2088" headers="d86720e1985 "><pre class="oac_no_warn" dir="ltr">XDB：SQLInline</pre><p>PL / SQL：</p><pre class="oac_no_warn" dir="ltr">setOutOfLine removeOutOfLine</pre></td>
                                 <td align="left" valign="top" width="11%" headers="d86720e2088 d86720e1988 ">
                                    <p><code class="codeph">true</code> | <code class="codeph">false</code></p>
                                 </td>
                                 <td align="left" valign="top" width="13%" headers="d86720e2088 d86720e1991 ">
                                    <p><code class="codeph">真正</code></p>
                                 </td>
                                 <td align="left" valign="top" width="46%" headers="d86720e2088 d86720e1994 ">
                                    <p>如果为<code class="codeph">true</code> ，则此元素作为嵌入对象属性内联存储（或者作为集合存储，如果<code class="codeph">maxOccurs</code> &gt; 1）。
                                    </p>
                                    <p>如果<code class="codeph">false</code> ，则<code class="codeph">REF</code>值被存储（或集合<code class="codeph">REF</code>值，如果<code class="codeph">maxOccurs</code> &gt; 1）。在某些情况下，此属性被强制为<code class="codeph">false</code> ，例如循环引用，其中SQL不支持内联。
                                    </p>
                                 </td>
                              </tr>
                              <tr align="left" valign="top">
                                 <td align="left" valign="top" width="30%" id="d86720e2133" headers="d86720e1985 "><pre class="oac_no_warn" dir="ltr">XDB：SQLName</pre><p>PL / SQL：</p><pre class="oac_no_warn" dir="ltr">setSQLName removeSQLName</pre></td>
                                 <td align="left" valign="top" width="11%" headers="d86720e2133 d86720e1988 ">
                                    <p>任何SQL标识符</p>
                                 </td>
                                 <td align="left" valign="top" width="13%" headers="d86720e2133 d86720e1991 ">
                                    <p>元素名称</p>
                                 </td>
                                 <td align="left" valign="top" width="46%" headers="d86720e2133 d86720e1994 ">
                                    <p>映射到此XML元素的SQL对象中的属性的名称。</p>
                                 </td>
                              </tr>
                              <tr align="left" valign="top">
                                 <td align="left" valign="top" width="30%" id="d86720e2150" headers="d86720e1985 "><pre class="oac_no_warn" dir="ltr">XDB：SQLTYPE</pre><p>PL / SQL：</p><pre class="oac_no_warn" dir="ltr">setSQLType removeSQLType</pre></td>
                                 <td align="left" valign="top" width="11%" headers="d86720e2150 d86720e1988 ">
                                    <p>任何SQL数据类型<a id="fn_1" name="fn_1" href="#fn_1" data="" see="" use="" dbms_xmlschema="" to="" map="" xml="" schema="" types="" sql="" ="" ="" onclick="footdisplay(1, "><sup>Foot 1</sup></a> ， <code class="codeph">NCHAR</code> ， <code class="codeph">NVARCHAR2</code>和<code class="codeph">NCLOB</code> <span class="italic">除外</span></p>
                                 </td>
                                 <td align="left" valign="top" width="13%" headers="d86720e2150 d86720e1991 ">
                                    <p>从元素名称生成的名称</p>
                                 </td>
                                 <td align="left" valign="top" width="46%" headers="d86720e2150 d86720e1994 ">
                                    <p>与此XML元素声明对应的SQL类型的名称。</p>
                                 </td>
                              </tr>
                              <tr align="left" valign="top">
                                 <td align="left" valign="top" width="30%" id="d86720e2191" headers="d86720e1985 "><pre class="oac_no_warn" dir="ltr">XDB：tableProps</pre><p>PL / SQL：</p><pre class="oac_no_warn" dir="ltr">setTableProps removeTableProps</pre></td>
                                 <td align="left" valign="top" width="11%" headers="d86720e2191 d86720e1988 ">
                                    <p>任何表存储子句</p>
                                 </td>
                                 <td align="left" valign="top" width="13%" headers="d86720e2191 d86720e1991 ">
                                    <p><code class="codeph">空值</code></p>
                                 </td>
                                 <td align="left" valign="top" width="46%" headers="d86720e2191 d86720e1994 ">
                                    <p>指定附加到缺省<code class="codeph">CREATE TABLE</code>语句的<code class="codeph">TABLE</code>存储子句。这对于全局和外部元素主要是有意义的。适用于对象关系存储和二进制XML存储。
                                    </p>
                                 </td>
                              </tr>
                           </tbody>
                        </table>
                     </div>
                     <!-- class="inftblhruleinformal" -->
                     <p class="tablefootnote"><sup class="tablefootnote">脚注1</sup></p><p>请参阅<a href="XML-Schema-and-query-object-relational-storage.html#GUID-844D686D-D95A-4C5B-8624-71BABDBF1EF5" title="您可以使用PL / SQL包DBMS_XMLSCHEMA将XML Schema属性和元素的数据类型映射到SQL数据类型。">使用DBMS_XMLSCHEMA将XML架构数据类型映射到SQL数据类型</a> 。
                        </p>
                     <p></p>
                     <div class="section">
                        <div class="infoboxnotealso" id="GUID-429A6872-5258-439F-B427-7AFFD054C00C__GUID-E3BEBCC7-972D-4501-B75A-308E5A9A39D8">
                           <p class="notep1">也可以看看：</p>
                           <p><a href="XML-Schema-and-query-basic.html#GUID-F8159034-643E-4B26-BA57-4D60AF6D65D3" title="注册XML模式后，您可以为符合该模式的文档创建对象关系XMLType表或列。您可以选择为表或列指定对象关系存储选项。">基于XML模式的数据的对象关系存储，</a>用于在为对象关系存储手动创建<code class="codeph">XMLType</code>表时指定存储选项的信息</p>
                        </div>
                     </div>
                     <!-- class="section" -->
                     <div class="tblformalwide" id="GUID-429A6872-5258-439F-B427-7AFFD054C00C__CHDCHIHD">
                        <p class="titleintable">表18-2元素中的注释声明全局complexType元素</p>
                        <table cellpadding="4" cellspacing="0" class="FormalWide" title="元素中的注释声明全局complexType元素" width="100%" border="1" summary="This table lists attributes that you can specify in elements declaring global complextypes." frame="hsides" rules="rows">
                           <thead>
                              <tr align="left" valign="top">
                                 <th align="left" valign="bottom" width="22%" id="d86720e2241">属性</th>
                                 <th align="left" valign="bottom" width="20%" id="d86720e2244">值</th>
                                 <th align="left" valign="bottom" width="21%" id="d86720e2247">默认</th>
                                 <th align="left" valign="bottom" width="37%" id="d86720e2250">描述</th>
                              </tr>
                           </thead>
                           <tbody>
                              <tr align="left" valign="top">
                                 <td align="left" valign="top" width="22%" id="d86720e2255" headers="d86720e2241 "><pre class="oac_no_warn" dir="ltr">XDB：maintainDOM</pre><p>PL / SQL：</p><pre class="oac_no_warn" dir="ltr">enableMaintainDom disableMaintainDom</pre></td>
                                 <td align="left" valign="top" width="20%" headers="d86720e2255 d86720e2244 ">
                                    <p><code class="codeph">true</code> | <code class="codeph">false</code></p>
                                 </td>
                                 <td align="left" valign="top" width="21%" headers="d86720e2255 d86720e2247 ">
                                    <p><code class="codeph">真正</code></p>
                                 </td>
                                 <td align="left" valign="top" width="37%" headers="d86720e2255 d86720e2250 ">
                                    <p>如果为<code class="codeph">true</code> ，则存储此元素的实例，以便它们在输出时保留DOM保真度。这意味着除了元素的排序之外，还保留所有注释，处理指令，命名空间声明等。
                                    </p>
                                    <p>如果为<code class="codeph">false</code> ，则不保证输出与输入具有相同的DOM操作。
                                    </p>
                                 </td>
                              </tr>
                              <tr align="left" valign="top">
                                 <td align="left" valign="top" width="22%" id="d86720e2285" headers="d86720e2241 "><pre class="oac_no_warn" dir="ltr">XDB：SQLTYPE</pre><p>PL / SQL：</p><pre class="oac_no_warn" dir="ltr">setSQLType removeSQLType</pre></td>
                                 <td align="left" valign="top" width="20%" headers="d86720e2285 d86720e2244 ">
                                    <p><span class="italic">除</span> <code class="codeph">NCHAR</code> ， <code class="codeph">NVARCHAR2</code>和<code class="codeph">NCLOB</code> <span class="italic">之外的</span>任何SQL数据类型<a id="fn_2" name="fn_2" href="#fn_2" data="" see="" use="" dbms_xmlschema="" to="" map="" xml="" schema="" types="" sql="" ="" ="" onclick="footdisplay(2, "><sup>Foot 2</sup></a></p>
                                 </td>
                                 <td align="left" valign="top" width="21%" headers="d86720e2285 d86720e2247 ">
                                    <p>从元素名称生成的名称</p>
                                 </td>
                                 <td align="left" valign="top" width="37%" headers="d86720e2285 d86720e2250 ">
                                    <p>与此XML元素声明对应的SQL类型的名称。</p>
                                 </td>
                              </tr>
                           </tbody>
                        </table>
                     </div>
                     <!-- class="inftblhruleinformal" -->
                     <p class="tablefootnote"><sup class="tablefootnote">脚注2</sup></p><p>请参阅<a href="XML-Schema-and-query-object-relational-storage.html#GUID-844D686D-D95A-4C5B-8624-71BABDBF1EF5" title="您可以使用PL / SQL包DBMS_XMLSCHEMA将XML Schema属性和元素的数据类型映射到SQL数据类型。">使用DBMS_XMLSCHEMA将XML架构数据类型映射到SQL数据类型</a> 。
                        </p>
                     <p></p>
                     <div class="section"></div>
                     <!-- class="section" -->
                  </div>
                  <div>
                     <div class="familylinks">
                        <div class="parentlink">
                           <p><strong>父主题：</strong> <a href="XML-Schema-and-query-object-relational-storage.html#GUID-F7E43D3A-67D8-432E-833A-DE0EA4CFCE7A" title="您可以注释XML模式以影响XML模式注册过程生成的对象和表。您可以通过向XML模式声明的complexType，元素和属性定义添加特定于Oracle的属性来完成此操作。">Oracle XML模式注释</a></p>
                        </div>
                     </div>
                  </div>
                  
               </div><a id="ADXDB5837"></a><div class="props_rev_3"><a id="GUID-B1B67DF3-8E3A-4383-B67F-D14EF98BFBE9" name="GUID-B1B67DF3-8E3A-4383-B67F-D14EF98BFBE9"></a><h4 id="ADXDB-GUID-B1B67DF3-8E3A-4383-B67F-D14EF98BFBE9" class="sect4"><span class="enumeration_section">18.2.5</span>对象关系存储的XML模式注释指南</h4>
                  <div>
                     <p>对于以对象方式存储的<code class="codeph">XMLType</code>数据，需要仔细规划，以优化性能。对关系数据也有类似的考虑：实体关系模型，索引，数据类型，表分区等。要启用XPath重写并获得最佳性能，可以使用XML模式注释实现许多此类设计选择。
                     </p>
                     <div class="section"></div>
                     <!-- class="section" -->
                  </div>
                  <div>
                     <ul class="ullinks">
                        <li class="ulchildlink"><a href="XML-Schema-and-query-object-relational-storage.html#GUID-72B2EF6A-A8A4-44E4-89BD-1AE5A0FACDE2">避免为未使用的顶级元素创建不必要的表</a><br>每当XML模式中的顶级元素<span class="italic">从未</span>在任何相应的XML实例的顶层使用时，您可以通过向XML模式中的元素添加注释<code class="codeph">xdb:defaultTable =</code> <span class="bold"><code class="codeph">""</code></span>来避免创建关联表。此属性的空值可防止创建默认表。
                        </li>
                        <li class="ulchildlink"><a href="XML-Schema-and-query-object-relational-storage.html#GUID-AA67137B-0987-44FC-8AAB-FA0C0DD36302">为默认表提供您自己的名称</a><br>出于调整目的，您可以检查查询的执行计划输出。这指的是作为对象存储的<code class="codeph">XMLType</code>数据的基础表。默认情况下，这些表具有系统生成的名称。Oracle建议您提供自己的表名，尤其是对于您确定感兴趣的表。
                        </li>
                        <li class="ulchildlink"><a href="XML-Schema-and-query-object-relational-storage.html#GUID-9895677F-D247-4BCF-965F-51BEBFECE916">如果不需要，请关闭DOM保真度</a><br>默认情况下，XML模式注册会生成保持DOM保真度的表。通常情况下，对于以数据为中心的XML数据，不需要DOM保真度。您可以通过使用不保持DOM保真度的对象关系表来提高存储，查询和数据修改的性能。
                        </li>
                        <li class="ulchildlink"><a href="XML-Schema-and-query-object-relational-storage.html#GUID-A6368882-0B0F-4913-91A7-358FA3E27794">使用时间戳数据类型注释与时间相关的元素</a><br>如果您的应用程序需要使用时区指示符，则使用<code class="codeph">xdb:SQLType = "</code> <span class="bold"><code class="codeph">TIMESTAMP WITH TIME ZONE</code></span> <code class="codeph">"</code>注释<code class="codeph">xs:time</code>和<code class="codeph">xs:dateTime</code>类型的任何XML模式元素。这确保了可以存储，检索和比较包含时区指示符的值。
                        </li>
                        <li class="ulchildlink"><a href="XML-Schema-and-query-object-relational-storage.html#GUID-3CC2FD41-D68C-443F-93F6-C8DFB5752D9C">添加表和列属性</a><br>如果基于对象关系的<code class="codeph">XMLType</code>数据的表或列需要指定其他属性（例如分区，表空间或压缩），请使用注释<code class="codeph">xdb:tableProps</code>或<code class="codeph">xdb:columnProps</code> 。例如，您可以执行此操作以添加主键或约束。
                        </li>
                        <li class="ulchildlink"><a href="XML-Schema-and-query-object-relational-storage.html#GUID-2BEC7690-3EB6-4995-9D47-19C061C4277E">存储大型馆藏</a><br>如果您有大型集合，那么您可能需要使用注释<code class="codeph">xdb:defaultTable</code>和<code class="codeph">xdb:SQLInline</code>来指定集合元素是否存储在行外。
                        </li>
                     </ul>
                     <div class="relinfo">
                        <p><strong>相关话题</strong></p>
                        <ul>
                           <li><a href="XPath-rewrite-for-object-relational-storage.html#GUID-35551023-CCAC-477B-8BBF-CD0E0B44C962" title="对于以对象方式存储的XMLType数据，涉及各种SQL函数的XPath表达式参数的查询通常可以自动重写为针对高度优化的基础SQL表的查询。">用于对象关系存储的XPath重写</a></li>
                        </ul>
                     </div>
                     <div class="infoboxnotealso" id="GUID-B1B67DF3-8E3A-4383-B67F-D14EF98BFBE9__GUID-502B5EAE-1707-4AB7-9832-23CB6820D16C">
                        <p class="notep1">也可以看看：</p>
                        <p><a href="XML-Schema-and-query-object-relational-storage.html#GUID-429A6872-5258-439F-B427-7AFFD054C00C__G1048403" title="此表列出了可以使用Oracle XML DB在元素中指定的属性。">表18-1</a></p>
                     </div>
                     <div class="familylinks">
                        <div class="parentlink">
                           <p><strong>父主题：</strong> <a href="XML-Schema-and-query-object-relational-storage.html#GUID-F7E43D3A-67D8-432E-833A-DE0EA4CFCE7A" title="您可以注释XML模式以影响XML模式注册过程生成的对象和表。您可以通过向XML模式声明的complexType，元素和属性定义添加特定于Oracle的属性来完成此操作。">Oracle XML模式注释</a></p>
                        </div>
                     </div>
                  </div>
                  <a id="ADXDB5838"></a><div class="props_rev_3"><a id="GUID-72B2EF6A-A8A4-44E4-89BD-1AE5A0FACDE2" name="GUID-72B2EF6A-A8A4-44E4-89BD-1AE5A0FACDE2"></a><h5 id="ADXDB-GUID-72B2EF6A-A8A4-44E4-89BD-1AE5A0FACDE2" class="sect5"><span class="enumeration_section">18.2.5.1</span>避免为未使用的顶级元素创建不必要的表</h5>
                     <div>
                        <p>每当XML模式中的顶级元素<span class="italic">从未</span>在任何相应的XML实例的顶层使用时，您可以通过向XML模式中的元素添加注释<code class="codeph">xdb:defaultTable =</code> <span class="bold"><code class="codeph">""</code></span>来避免创建关联表。此属性的空值可防止创建默认表。
                        </p>
                        <p>默认情况下，XML模式注册为模式中定义的每个顶级元素创建顶级表。某些此类元素可能在符合模式的XML实例中的顶级使用。例如，XML模式中的元素可能是顶级元素，以便用作<code class="codeph">REF</code>目标。
                        </p>
                        <p>您可以使用PL / SQL程序<code class="codeph">DBMS_XMLSCHEMA_ANNOTATE.disableDefaultTableCreation</code>为空加<code class="codeph">xdb:defaultTable</code>属性为不具有每个顶级元素<code class="codeph">xdb:defaultTable</code>属性。
                        </p>
                        <div class="infoboxnote" id="GUID-72B2EF6A-A8A4-44E4-89BD-1AE5A0FACDE2__GUID-57EDED1B-9EA6-4010-9FF3-068006A0DD82">
                           <p class="notep1">注意：</p>
                           <p>用作任何实例文档的根元素的任何顶级XML架构元素都必须具有非空的<code class="codeph">xdb:defaultTable</code>属性。
                           </p>
                        </div>
                     </div>
                     <div>
                        <div class="infoboxnotealso" id="GUID-72B2EF6A-A8A4-44E4-89BD-1AE5A0FACDE2__GUID-F43B14BD-0FA8-4CBA-9522-77041C3ACCCC">
                           <p class="notep1">也可以看看：</p>
                           <p>有关PL / SQL过程<code class="codeph">disableDefaultTableCreation</code>信息，请<a href="../arpls/DBMS_XMLSCHEMA_ANNOTATE.html#ARPLS73580" target="_blank"><span><cite>参见</cite></span></a> “ <a href="../arpls/DBMS_XMLSCHEMA_ANNOTATE.html#ARPLS73580" target="_blank"><span><cite>Oracle数据库PL / SQL包和类型参考”</cite></span></a> ，“DBMS_XMLSCHEMA_ANNOTATE”一章。
                           </p>
                        </div>
                        <div class="familylinks">
                           <div class="parentlink">
                              <p><strong>父主题：</strong> <a href="XML-Schema-and-query-object-relational-storage.html#GUID-B1B67DF3-8E3A-4383-B67F-D14EF98BFBE9" title="对于以对象方式存储的XMLType数据，需要仔细规划，以优化性能。对关系数据也有类似的考虑：实体关系模型，索引，数据类型，表分区等。要启用XPath重写并获得最佳性能，可以使用XML模式注释实现许多此类设计选择。">对象关系存储的XML模式注释准则</a></p>
                           </div>
                        </div>
                     </div>
                     
                  </div><a id="ADXDB5839"></a><div class="props_rev_3"><a id="GUID-AA67137B-0987-44FC-8AAB-FA0C0DD36302" name="GUID-AA67137B-0987-44FC-8AAB-FA0C0DD36302"></a><h5 id="ADXDB-GUID-AA67137B-0987-44FC-8AAB-FA0C0DD36302" class="sect5"><span class="enumeration_section">18.2.5.2</span>为默认表提供自己的名称</h5>
                     <div>
                        <p>出于调整目的，您可以检查查询的执行计划输出。这指的是作为对象存储的<code class="codeph">XMLType</code>数据的基础表。默认情况下，这些表具有系统生成的名称。Oracle建议您提供自己的表名，尤其是对于您确定感兴趣的表。
                        </p>
                        <p>您可以使用注释<code class="codeph">xdb:defaultTable</code>执行此操作<code class="codeph">xdb:defaultTable</code> 。
                        </p>
                        <div class="section"></div>
                        <!-- class="section" -->
                     </div>
                     <div>
                        <div class="relinfo">
                           <p><strong>相关话题</strong></p>
                           <ul>
                              <li><a href="XML-Schema-and-query-object-relational-storage.html#GUID-54A3CBE8-19BE-43BB-8979-7769116B6F53" title="您可以在XML模式注册中创建默认表。使用API和协议（如FTP和HTTP（S））插入文档时，默认表最有用，它们不提供任何表规范。">XML架构注册期间创建的默认表</a></li>
                           </ul>
                        </div>
                        <div class="familylinks">
                           <div class="parentlink">
                              <p><strong>父主题：</strong> <a href="XML-Schema-and-query-object-relational-storage.html#GUID-B1B67DF3-8E3A-4383-B67F-D14EF98BFBE9" title="对于以对象方式存储的XMLType数据，需要仔细规划，以优化性能。对关系数据也有类似的考虑：实体关系模型，索引，数据类型，表分区等。要启用XPath重写并获得最佳性能，可以使用XML模式注释实现许多此类设计选择。">对象关系存储的XML模式注释准则</a></p>
                           </div>
                        </div>
                     </div>
                     
                  </div><a id="ADXDB5840"></a><div class="props_rev_3"><a id="GUID-9895677F-D247-4BCF-965F-51BEBFECE916" name="GUID-9895677F-D247-4BCF-965F-51BEBFECE916"></a><h5 id="ADXDB-GUID-9895677F-D247-4BCF-965F-51BEBFECE916" class="sect5"><span class="enumeration_section">18.2.5.3</span>如果不需要则关闭DOM保真度</h5>
                     <div>
                        <p>默认情况下，XML模式注册会生成保持DOM保真度的表。通常情况下，对于以数据为中心的XML数据，不需要DOM保真度。您可以通过使用不保持DOM保真度的对象关系表来提高存储，查询和数据修改的性能。</p>
                        <p>您可以使用注释<code class="codeph">xdb:maintainDOM = "</code> <span class="bold"><code class="codeph">false</code></span> <code class="codeph">"</code>来执行此操作。
                        </p>
                        <div class="section"></div>
                        <!-- class="section" -->
                     </div>
                     <div>
                        <div class="relinfo">
                           <p><strong>相关话题</strong></p>
                           <ul>
                              <li><a href="XML-Schema-and-query-basic.html#GUID-F809A6FE-28CD-4776-AB11-0B34ECBD9FF6" title="DOM保真度意味着保留XML文档中的所有信息，除了无关紧要的空白。您可以使用DOM保真度来确保存储在Oracle XML DB中的XML文档的准确性和完整性。">DOM富达</a></li>
                           </ul>
                        </div>
                        <div class="familylinks">
                           <div class="parentlink">
                              <p><strong>父主题：</strong> <a href="XML-Schema-and-query-object-relational-storage.html#GUID-B1B67DF3-8E3A-4383-B67F-D14EF98BFBE9" title="对于以对象方式存储的XMLType数据，需要仔细规划，以优化性能。对关系数据也有类似的考虑：实体关系模型，索引，数据类型，表分区等。要启用XPath重写并获得最佳性能，可以使用XML模式注释实现许多此类设计选择。">对象关系存储的XML模式注释准则</a></p>
                           </div>
                        </div>
                     </div>
                     
                  </div><a id="ADXDB5842"></a><div class="props_rev_3"><a id="GUID-A6368882-0B0F-4913-91A7-358FA3E27794" name="GUID-A6368882-0B0F-4913-91A7-358FA3E27794"></a><h5 id="ADXDB-GUID-A6368882-0B0F-4913-91A7-358FA3E27794" class="sect5"><span class="enumeration_section">18.2.5.4</span>使用时间戳数据类型注释与时间相关的元素</h5>
                     <div>
                        <p>如果您的应用程序需要使用时区指示符，则使用<code class="codeph">xdb:SQLType = "</code> <span class="bold"><code class="codeph">TIMESTAMP WITH TIME ZONE</code></span> <code class="codeph">"</code>注释<code class="codeph">xs:time</code>和<code class="codeph">xs:dateTime</code>类型的任何XML模式元素。这确保了可以存储，检索和比较包含时区指示符的值。
                        </p>
                     </div>
                     <div>
                        <div class="familylinks">
                           <div class="parentlink">
                              <p><strong>父主题：</strong> <a href="XML-Schema-and-query-object-relational-storage.html#GUID-B1B67DF3-8E3A-4383-B67F-D14EF98BFBE9" title="对于以对象方式存储的XMLType数据，需要仔细规划，以优化性能。对关系数据也有类似的考虑：实体关系模型，索引，数据类型，表分区等。要启用XPath重写并获得最佳性能，可以使用XML模式注释实现许多此类设计选择。">对象关系存储的XML模式注释准则</a></p>
                           </div>
                        </div>
                     </div>
                     
                  </div><a id="ADXDB5843"></a><div class="props_rev_3"><a id="GUID-3CC2FD41-D68C-443F-93F6-C8DFB5752D9C" name="GUID-3CC2FD41-D68C-443F-93F6-C8DFB5752D9C"></a><h5 id="ADXDB-GUID-3CC2FD41-D68C-443F-93F6-C8DFB5752D9C" class="sect5"><span class="enumeration_section">18.2.5.5</span>添加表和列属性</h5>
                     <div>
                        <p>如果基于对象关系的<code class="codeph">XMLType</code>数据的表或列需要指定其他属性（例如分区，表空间或压缩），请使用注释<code class="codeph">xdb:tableProps</code>或<code class="codeph">xdb:columnProps</code> 。例如，您可以执行此操作以添加主键或约束。
                        </p>
                        <p>例如，要实现联机事务处理（OLTP）的表压缩，可以使用<code class="codeph">tableProps</code>属性添加<code class="codeph">COMPRESS FOR OLTP</code> 。
                        </p>
                     </div>
                     <div>
                        <div class="infoboxnotealso" id="GUID-3CC2FD41-D68C-443F-93F6-C8DFB5752D9C__GUID-4418A4E2-B58E-4621-A58B-F0EA5EE2CF30">
                           <p class="notep1">也可以看看：</p>
                           <p><a href="XML-Schema-and-query-basic.html#GUID-F8159034-643E-4B26-BA57-4D60AF6D65D3__BJFGGABH">示例17-9，</a>了解在手动创建<code class="codeph">XMLType</code>表和列时指定高级行压缩的示例</p>
                        </div>
                        <div class="familylinks">
                           <div class="parentlink">
                              <p><strong>父主题：</strong> <a href="XML-Schema-and-query-object-relational-storage.html#GUID-B1B67DF3-8E3A-4383-B67F-D14EF98BFBE9" title="对于以对象方式存储的XMLType数据，需要仔细规划，以优化性能。对关系数据也有类似的考虑：实体关系模型，索引，数据类型，表分区等。要启用XPath重写并获得最佳性能，可以使用XML模式注释实现许多此类设计选择。">对象关系存储的XML模式注释准则</a></p>
                           </div>
                        </div>
                     </div>
                     
                  </div><a id="ADXDB5844"></a><div class="props_rev_3"><a id="GUID-2BEC7690-3EB6-4995-9D47-19C061C4277E" name="GUID-2BEC7690-3EB6-4995-9D47-19C061C4277E"></a><h5 id="ADXDB-GUID-2BEC7690-3EB6-4995-9D47-19C061C4277E" class="sect5"><span class="enumeration_section">18.2.5.6</span>存储大型馆藏</h5>
                     <div>
                        <p>如果您有大型集合，那么您可能需要使用注释<code class="codeph">xdb:defaultTable</code>和<code class="codeph">xdb:SQLInline</code>来指定集合元素是否存储在行外。
                        </p>
                        <p><code class="codeph">complexType</code>定义的元素和属性的最大数量为1000。无法创建可以管理存储该类型实例时生成的SQL对象的单个表。如果您有大型集合，那么您可能会遇到表的1000列限制。
                        </p>
                        <p>您可以使用注释<code class="codeph">xdb:defaultTable</code>和<code class="codeph">xdb:SQLInline</code>来指定此类集合元素是否存储在行外。这意味着他们的数据存储在一个单独的表中 - 只有对该表中一行的引用存储在主集合表中。使用<code class="codeph">xdb:defaultTable</code>命名外联表。使用<code class="codeph">xdb:SQLInline = "</code> <span class="bold"><code class="codeph">false</code></span> <code class="codeph">",</code>注释可能较大的集合的每个元素<code class="codeph">",</code>以将其存储在行外。
                        </p>
                        <div class="infoboxnote" id="GUID-2BEC7690-3EB6-4995-9D47-19C061C4277E__GUID-960CF353-2CA1-4F32-8BC3-E5B793B0F3C7">
                           <p class="notep1">注意：</p>
                           <p>对于XML模式中的每个继承层次结构或替换组，将创建一个表，其列涵盖该层次结构或替换组的内容模型。这也可能导致达到1000列限制。</p>
                        </div>
                        <div class="section"></div>
                        <!-- class="section" -->
                     </div>
                     <div>
                        <div class="relinfo">
                           <p><strong>相关话题</strong></p>
                           <ul>
                              <li><a href="XML-Schema-and-query-object-relational-storage.html#GUID-5F470098-54C0-4FC6-8E7B-732487497F90" title="使用大型或复杂的XML模式时，可能会引发错误ORA-01792和ORA-04031。注册XML模式或创建基于XML模式定义的全局元素的表时，可以遇到它们。">ORA-01792和ORA-04031：大型XML模式的问题</a></li>
                              <li><a href="XML-Schema-and-query-object-relational-storage.html#GUID-AC221997-9F02-423E-9F39-BA02046763B5" title="将XML模式注释xdb：SQLInline设置为false以将XML片段存储在线外。该元素映射到具有嵌入REF属性的SQL对象类型，该属性指向另一个存储在行外且与XML片段对应的XMLType实例。">将注释属性xdb：SQLInline设置为false以用于外线存储</a></li>
                           </ul>
                        </div>
                        <div class="familylinks">
                           <div class="parentlink">
                              <p><strong>父主题：</strong> <a href="XML-Schema-and-query-object-relational-storage.html#GUID-B1B67DF3-8E3A-4383-B67F-D14EF98BFBE9" title="对于以对象方式存储的XMLType数据，需要仔细规划，以优化性能。对关系数据也有类似的考虑：实体关系模型，索引，数据类型，表分区等。要启用XPath重写并获得最佳性能，可以使用XML模式注释实现许多此类设计选择。">对象关系存储的XML模式注释准则</a></p>
                           </div>
                        </div>
                     </div>
                     
                  </div>
               </div><a id="ADXDB6116"></a><a id="ADXDB4524"></a><a id="ADXDB4523"></a><div class="props_rev_3"><a id="GUID-0A560425-E6F2-4AA2-9818-B80EFE2D0AD3" name="GUID-0A560425-E6F2-4AA2-9818-B80EFE2D0AD3"></a><h4 id="ADXDB-GUID-0A560425-E6F2-4AA2-9818-B80EFE2D0AD3" class="sect4"><span class="enumeration_section">18.2.6</span>查询已注册的XML模式以获取注释</h4>
                  <div>
                     <p>您可以查询数据库视图<code class="codeph">USER_XML_SCHEMAS</code>和<code class="codeph">ALL_XML_SCHEMAS</code>以获取包含其所有注释的已注册XML模式。XML模式的注册版本包含一整套Oracle XML DB注释。这些注释由用户提供或在XML模式注册期间默认设置。
                     </p>
                     <div class="section">
                        <p><a href="XML-Schema-and-query-object-relational-storage.html#GUID-0A560425-E6F2-4AA2-9818-B80EFE2D0AD3__CEGEGFAG">例18-6</a>说明了这一点。它将XML模式作为<code class="codeph">XMLType</code>实例返回。
                        </p>
                        <p>如<a href="XML-Schema-and-query-basic.html#GUID-26C1BFCD-5CC5-4608-A93E-24E5529B1077__BJFIJHJA">例17-3</a>和<a href="XML-Schema-and-query-basic.html#GUID-CA2A548B-11B3-4D83-9A21-53EC8CE6DDC9__BJFBGBEJ">例17-4所示</a> ，已注册的XML模式的位置取决于它是本地还是全局。如果要将特定注释信息投影到关系列，可以查询<code class="codeph">RESOURCE_VIEW</code> 。 <a href="XML-Schema-and-query-object-relational-storage.html#GUID-0A560425-E6F2-4AA2-9818-B80EFE2D0AD3__CHDCDCCD">例18-7</a>说明了这一点。它获取由XML模式声明的全局<code class="codeph">complexType</code>定义集，用于<code class="codeph">XMLType</code>数据的对象关系存储，以及相应的SQL对象类型和DOM保真度值。
                        </p>
                     </div>
                     <!-- class="section" -->
                     <div class="example" id="GUID-0A560425-E6F2-4AA2-9818-B80EFE2D0AD3__CEGEGFAG">
                        <p class="titleinexample">示例18-6查询已注册的XML架构的USER_XML_SCHEMAS视图</p><pre class="pre codeblock"><code>SELECT SCHEMA来自USER_XML_SCHEMAS WHERE SCHEMA_URL ='http://xmlns.oracle.com/xdb/documentation/purchaseOrder.xsd';</code></pre></div>
                     <!-- class="example" -->
                     <div class="example" id="GUID-0A560425-E6F2-4AA2-9818-B80EFE2D0AD3__CHDCDCCD">
                        <p class="titleinexample">示例18-7从已注册的XML模式查询元数据</p><pre class="pre codeblock"><code>SELECT ct.xmlschema_type_name，ct.sql_type_name，ct.dom_fidelity FROM RESOURCE_VIEW，XMLTable（XMLNAMESPACES（'http://xmlns.oracle.com/xdb/XDBResource.xsd'AS"r“，'http：//xmlns.oracle。 com / xdb / documentation / purchaseOrder'AS“po”，'http：//www.w3.org/2001/XMLSchema'AS“xs”，'http：//xmlns.oracle.com/xdb'AS“xdb” ）， <span class="bold">'/ R：资源/ R：内容/ XS：架构/ XS：的complexType'</span> PASSING RES COLUMNS xmlschema_type_name VARCHAR2（30）PATH <span class="bold">'@name'，sql_type_name</span> VARCHAR2（30）PATH <span class="bold">'@xdb：SQLTYPE'，dom_fidelity</span> VARCHAR2（ 6）路径' <span class="bold">@xdb：maintainDOM</span> '）ct WHERE equals_path（RES，'/ sys / schemas / SCOTT / xmlns.oracle / xdb / dococument /purchaseOrder.xsd'）= 1; XMLSCHEMA_TYPE_NAME SQL_TYPE_NAME DOM_FIDELITY ------------------------- ---------------------- -  ------------ PurchaseOrderType PURCHASEORDER_T true LineItemsType LINEITEMS_T true LineItemType LINEITEM_T true PartType PART_T true ActionsType ACTIONS_T true RejectionType REJECTION_T true ShippingInstructionsType SHIPPING_INSTRUCTIONS_T true 7行选中。</code></pre></div>
                     <!-- class="example" -->
                  </div>
                  <div>
                     <ul class="ullinks">
                        <li class="ulchildlink"><a href="XML-Schema-and-query-object-relational-storage.html#GUID-AAA8C662-CEBE-4F38-8C41-AE25CF502790">您可以将注释从一个XML架构应用到另一个XML架构</a><br>有时您需要将注释从一个XML模式应用到另一个XML模式。典型的用例是将旧版本的模式中的注释应用于新版本。您可以分别使用PL / SQL子程序<code class="codeph">getSchemaAnnotations</code>和<code class="codeph">setSchemaAnnotations</code>来获取和设置注释。
                        </li>
                     </ul>
                     <div class="familylinks">
                        <div class="parentlink">
                           <p><strong>父主题：</strong> <a href="XML-Schema-and-query-object-relational-storage.html#GUID-F7E43D3A-67D8-432E-833A-DE0EA4CFCE7A" title="您可以注释XML模式以影响XML模式注册过程生成的对象和表。您可以通过向XML模式声明的complexType，元素和属性定义添加特定于Oracle的属性来完成此操作。">Oracle XML模式注释</a></p>
                        </div>
                     </div>
                  </div>
                  <a id="ADXDB6117"></a><div class="props_rev_3"><a id="GUID-AAA8C662-CEBE-4F38-8C41-AE25CF502790" name="GUID-AAA8C662-CEBE-4F38-8C41-AE25CF502790"></a><h5 id="ADXDB-GUID-AAA8C662-CEBE-4F38-8C41-AE25CF502790" class="sect5"><span class="enumeration_section">18.2.6.1</span>您可以将注释从一个XML模式应用到另一个XML模式</h5>
                     <div>
                        <p>有时您需要将注释从一个XML模式应用到另一个XML模式。典型的用例是将旧版本的模式中的注释应用于新版本。您可以分别使用PL / SQL子程序<code class="codeph">getSchemaAnnotations</code>和<code class="codeph">setSchemaAnnotations</code>来获取和设置注释。
                        </p>
                        <p>PL / SQL函数<code class="codeph">getSchemaAnnotations</code>返回XML模式中的所有注释。PL / SQL过程<code class="codeph">setSchemaAnnotations</code>设置注释。这些子程序位于PL / SQL包<code class="codeph">DBMS_XMLSCHEMA_ANNOTATE</code> 。</p>
                     </div>
                     <div>
                        <div class="infoboxnotealso" id="GUID-AAA8C662-CEBE-4F38-8C41-AE25CF502790__GUID-6D263E04-2EBD-4E55-B6EC-5270D4E76D4C">
                           <p class="notep1">也可以看看：</p>
                           <p><a href="../arpls/DBMS_XMLSCHEMA_ANNOTATE.html#ARPLS73580" target="_blank"><span><cite>Oracle Database PL / SQL包和类型参考</cite></span></a> ，“DBMS_XMLSCHEMA_ANNOTATE”一章，了解有关PL / SQL子程序<code class="codeph">getSchemaAnnotations</code>和<code class="codeph">setSchemaAnnotations</code> 。
                           </p>
                        </div>
                        <div class="familylinks">
                           <div class="parentlink">
                              <p><strong>父主题：</strong> <a href="XML-Schema-and-query-object-relational-storage.html#GUID-0A560425-E6F2-4AA2-9818-B80EFE2D0AD3" title="您可以查询数据库视图USER_XML_SCHEMAS和ALL_XML_SCHEMAS以获取包含其所有注释的已注册XML模式。XML模式的注册版本包含一整套Oracle XML DB注释。这些注释由用户提供或在XML模式注册期间默认设置。">查询已注册的XML模式以获取注释</a></p>
                           </div>
                        </div>
                     </div>
                     
                  </div>
               </div>
            </div><a id="ADXDB4527"></a><div class="props_rev_3"><a id="GUID-844D686D-D95A-4C5B-8624-71BABDBF1EF5" name="GUID-844D686D-D95A-4C5B-8624-71BABDBF1EF5"></a><h3 id="ADXDB-GUID-844D686D-D95A-4C5B-8624-71BABDBF1EF5" class="sect3"><span class="enumeration_section">18.3</span>使用DBMS_XMLSCHEMA将XML模式数据类型映射到SQL数据类型</h3>
               <div>
                  <p>您可以使用PL / SQL包<code class="codeph">DBMS_XMLSCHEMA</code>将XML Schema属性和元素的数据类型映射到SQL数据类型。
                  </p>
                  <div class="infoboxnote" id="GUID-844D686D-D95A-4C5B-8624-71BABDBF1EF5__GUID-BF435932-5BE3-41C9-BA20-916CBDA6E4C8">
                     <p class="notep1">注意：</p>
                     <p><span class="italic">不要</span>直接访问从XML Schema数据类型的XML模式注册过程中所映射的SQL数据类型。这些SQL类型是Oracle XML DB实现的一部分。它们不会暴露在您的使用中。Oracle保留随时更改实施的权利，包括产品补丁。Oracle的这种更改对遵循XML抽象的应用程序没有影响，但它可能会影响直接访问这些数据类型的应用程序。
                     </p>
                  </div>
               </div>
               <div>
                  <ul class="ullinks">
                     <li class="ulchildlink"><a href="XML-Schema-and-query-object-relational-storage.html#GUID-21E2C662-DB44-4DE3-8AA7-05D87465801A">将XML模式数据类型映射到SQL的示例</a><br>示例说明了将XML架构数据类型映射到SQL数据类型。
                     </li>
                     <li class="ulchildlink"><a href="XML-Schema-and-query-object-relational-storage.html#GUID-73BF2445-E3AE-44AD-9DCE-669EFDD8299C">XML模式属性数据类型映射到SQL</a><br>XML属性声明可以根据基本类型，本地<code class="codeph">simpleType</code> ，全局<code class="codeph">simpleType</code>或对全局属性的引用（ <code class="codeph">ref=".."</code> ）来指定其XML Schema数据类型。SQL数据类型及其相关信息是从基本XML Schema类型派生的。
                     </li>
                     <li class="ulchildlink"><a href="XML-Schema-and-query-object-relational-storage.html#GUID-F800FE48-194A-4A60-B2D3-8382A3775D2C">XML模式元素数据类型映射到SQL</a><br>XML元素声明可以使用基本类型，本地或全局<code class="codeph">simpleType</code> ，本地或全局<code class="codeph">complexType</code>或对全局元素（ <code class="codeph">ref=".."</code> ）的引用来指定其XML Schema数据类型。SQL数据类型及其相关信息是从基本XML Schema类型派生的。
                     </li>
                     <li class="ulchildlink"><a href="XML-Schema-and-query-object-relational-storage.html#GUID-4920BA1A-5769-49C6-870E-E3CA30F0016C">XML Schema simpleType如何映射到SQL</a><br>XML <code class="codeph">simpleType</code>以各种方式映射到SQL对象类型，具体取决于<code class="codeph">simpleType</code>的定义方式。
                     </li>
                     <li class="ulchildlink"><a href="XML-Schema-and-query-object-relational-storage.html#GUID-EEE8E9EE-0397-4EE9-8496-DB20B1A82CC1">XML Schema complexType如何映射到SQL</a><br>XML <code class="codeph">complexType</code>以各种方式映射到SQL对象类型，具体取决于<code class="codeph">complexType</code>的定义方式。
                     </li>
                  </ul>
                  <div class="familylinks">
                     <div class="parentlink">
                        <p><strong>父主题：</strong> <a href="XML-Schema-and-query-object-relational-storage.html#GUID-B0C1A0B0-2DD1-491A-8CE1-1F857FD267B7" title="基于XML Schema的数据的高级技术包括使用对象关系存储;注释XML模式;将Schema数据类型映射到SQL;使用complexType扩展和限制;创建，指定关系约束，分区基于XML Schema的数据，存储XMLType数据，使用复杂或大型模式，以及调试模式注册。">XML模式存储和查询：对象关系存储</a></p>
                     </div>
                  </div>
               </div>
               <a id="ADXDB4529"></a><a id="ADXDB4528"></a><div class="props_rev_3"><a id="GUID-21E2C662-DB44-4DE3-8AA7-05D87465801A" name="GUID-21E2C662-DB44-4DE3-8AA7-05D87465801A"></a><h4 id="ADXDB-GUID-21E2C662-DB44-4DE3-8AA7-05D87465801A" class="sect4"><span class="enumeration_section">18.3.1</span>将XML模式数据类型映射到SQL的示例</h4>
                  <div>
                     <p>示例说明了将XML架构数据类型映射到SQL数据类型。</p>
                     <div class="section">
                        <p><a href="XML-Schema-and-query-object-relational-storage.html#GUID-21E2C662-DB44-4DE3-8AA7-05D87465801A__CIHIDFEB">示例18-8</a>使用属性<code class="codeph">SQLType</code>指定数据类型映射。它还使用属性<code class="codeph">SQLName</code>指定要用于各种XML元素和属性的对象属性。
                        </p>
                     </div>
                     <!-- class="section" -->
                     <div class="example" id="GUID-21E2C662-DB44-4DE3-8AA7-05D87465801A__CIHIDFEB">
                        <p class="titleinexample">示例18-8使用Attribute SQLType将XML模式数据类型映射到SQL数据类型</p><pre class="pre codeblock"><code>&lt;xs：schema xmlns：xs =“http://www.w3.org/2001/XMLSchema”xmlns：xdb =“http://xmlns.oracle.com/xdb”version =“1.0”&gt; &lt;xs：element name =“PurchaseOrder”type =“PurchaseOrderType”xdb：defaultTable =“PURCHASEORDER”/&gt; &lt;xs：complexType name =“PurchaseOrderType”xdb：SQLType =“PURCHASEORDER_T”&gt; &lt;xs：sequence&gt; &lt;xs：element name =“Reference” type =“ReferenceType”minOccurs =“1”xdb：SQLName =“REFERENCE”/&gt; &lt;xs：element name =“Actions”type =“ActionsType”xdb：SQLName =“ACTIONS”/&gt; &lt;xs：element name =“Reject “type =”RejectionType“minOccurs =”0“xdb：SQLName =”REJECTION“/&gt; &lt;xs：element name =”Requestor“type =”RequestorType“xdb：SQLName =”REQUESTOR“/&gt; &lt;xs：element name =”用户“type =”UserType“minOccurs =”1“xdb：SQLName =”USERID“/&gt; &lt;xs：element name =”CostCenter“type =”CostCenterType“xdb：SQLName =”COST_CENTER“/&gt; &lt;xs：element name = “ShippingInstructions”type =“ShippingInstructionsType”xdb：SQLName =“SHIPPING_INSTRUCTIONS”/&gt; &lt;xs：element name =“SpecialInstructions”type =“SpecialInstructionsType”xdb：SQLName =“SPECIAL_INSTRUCTIONS”/&gt; &lt;xs：element na me =“LineItems”type =“LineItemsType”xdb：SQLName =“LINEITEMS”/&gt; &lt;xs：element name =“Notes”type =“po：NotesType”xdb：SQLType =“CLOB”/&gt; &lt;/ xs：sequence&gt; &lt;/ xs：complexType&gt; &lt;xs：complexType name =“LineItemsType”xdb：SQLType =“LINEITEMS_T”&gt; &lt;xs：sequence&gt; &lt;xs：element name =“LineItem”type =“LineItemType”maxOccurs =“unbounded”xdb：SQLName =“LINEITEM”xdb：SQLCollType =“LINEITEM_V”/&gt; &lt;/ xs：sequence&gt; &lt;/ xs：complexType&gt; &lt;xs：complexType name =“LineItemType”xdb：SQLType =“LINEITEM_T”&gt; &lt;xs：sequence&gt; &lt;xs： element name =“Description”type =“DescriptionType”xdb：SQLName =“DESCRIPTION”/&gt; &lt;xs：element name =“Part”type =“PartType”xdb：SQLName =“PART”/&gt; &lt;/ xs：sequence&gt; &lt; xs：attribute name =“ItemNumber”type =“xs：integer”xdb：SQLName =“ITEMNUMBER”xdb：SQLType =“NUMBER”/&gt; &lt;/ xs：complexType&gt; &lt;xs：complexType name =“PartType”xdb：SQLType = “PART_T”&gt; &lt;xs：attribute name =“Id”xdb：SQLName =“PART_NUMBER”xdb：SQLType =“VARCHAR2”&gt; &lt;xs：simpleType&gt; &lt;xs：restriction base =“xs：string”&gt; &lt;xs：minLength value =“10”/&gt; &lt;xs：maxLength value =“14”/&gt; &lt;/ xs：restriction&gt; &lt;/ xs ：simpleType&gt; &lt;/ xs：attribute&gt; &lt;xs：attribute name =“Quantity”type =“moneyType”xdb：SQLName =“QUANTITY”/&gt; &lt;xs：attribute name =“UnitPrice”type =“quantityType”xdb：SQLName = “UNITPRICE”/&gt; &lt;/ xs：complexType&gt; <span class="bold">...</span>&lt;xs：complexType name =“ActionsType”xdb：SQLType =“ACTIONS_T”&gt; &lt;xs：sequence&gt; &lt;xs：element name =“Action”maxOccurs =“4”xdb：SQLName =“ACTION”xdb：SQLCollType =“ACTION_V” &gt; &lt;xs：complexType xdb：SQLType =“ACTION_T”&gt; &lt;xs：sequence&gt; &lt;xs：element name =“User”type =“UserType”xdb：SQLName =“ACTIONED_BY”/&gt; &lt;xs：element name =“Date” type =“DateType”minOccurs =“0”xdb：SQLName =“DATE_ACTIONED”/&gt; &lt;/ xs：sequence&gt; &lt;/ xs：complexType&gt; &lt;/ xs：element&gt; &lt;/ xs：sequence&gt; &lt;/ xs：complexType&gt; &lt; xs：complexType name =“RejectionType”xdb：SQLType =“REJECTION_T”&gt; &lt;xs：all&gt; &lt;xs：element name =“User”type =“UserType”minOccurs =“0”xdb：SQLName =“REJECTED_BY”/&gt; &lt; xs：element name =“Date”type =“DateType”minOccurs =“0”xdb：SQLName =“DATE_REJECTED”/&gt; &lt;xs：element name =“Comments”type =“CommentsType”minOccurs =“0”xdb：SQLName = “REASON_REJECTED”/&gt; &lt;/ xs：all&gt; &lt;/ xs：complexType&gt; &lt;xs：complexType name =“ShippingInstructionsType”xdb：SQLType =“SHIPPING_INSTRUCTIONS_T”&gt; &lt;xs：sequence&gt; &lt;xs：element name =“name”type = “NameType”minOccurs =“0”xdb：SQLName =“SHIP_TO_NAME”/&gt; &lt;xs：el ement name =“address”type =“AddressType”minOccurs =“0”xdb：SQLName =“SHIP_TO_ADDRESS”/&gt; &lt;xs：element name =“telephone”type =“TelephoneType”minOccurs =“0”xdb：SQLName =“SHIP_TO_PHONE “/&gt; &lt;/ xs：sequence&gt; &lt;/ xs：complexType&gt; <span class="bold">...</span>&lt;/ XS：模式&gt;</code></pre></div>
                     <!-- class="example" -->
                  </div>
                  <div>
                     <div class="familylinks">
                        <div class="parentlink">
                           <p><strong>父主题：</strong> <a href="XML-Schema-and-query-object-relational-storage.html#GUID-844D686D-D95A-4C5B-8624-71BABDBF1EF5" title="您可以使用PL / SQL包DBMS_XMLSCHEMA将XML Schema属性和元素的数据类型映射到SQL数据类型。">使用DBMS_XMLSCHEMA将XML模式数据类型映射到SQL数据类型</a></p>
                        </div>
                     </div>
                  </div>
                  
               </div><a id="ADXDB4530"></a><div class="props_rev_3"><a id="GUID-73BF2445-E3AE-44AD-9DCE-669EFDD8299C" name="GUID-73BF2445-E3AE-44AD-9DCE-669EFDD8299C"></a><h4 id="ADXDB-GUID-73BF2445-E3AE-44AD-9DCE-669EFDD8299C" class="sect4"><span class="enumeration_section">18.3.2</span>映射到SQL的XML模式属性数据类型</h4>
                  <div>
                     <p>XML属性声明可以根据基本类型，本地<code class="codeph">simpleType</code> ，全局<code class="codeph">simpleType</code>或对全局属性的引用（ <code class="codeph">ref=".."</code> ）来指定其XML Schema数据类型。SQL数据类型及其相关信息是从基本XML Schema类型派生的。
                     </p>
                     <p>属性声明可以根据以下任何一种指定其XML Schema数据类型：</p>
                     <ul style="list-style-type:disc">
                        <li>
                           <p>原始类型</p>
                        </li>
                        <li>
                           <p>全局<code class="codeph">simpleType</code> ，在此XML架构或外部XML架构中声明</p>
                        </li>
                        <li>
                           <p>引用在此XML模式或外部XML模式中声明的全局属性（ <code class="codeph">ref=".."</code> ）</p>
                        </li>
                        <li>
                           <p>本地<code class="codeph">simpleType</code></p>
                        </li>
                     </ul>
                     <p>在所有情况下，SQL数据类型，任何关联信息（长度，精度）和内存映射信息都是从属性所基于的<code class="codeph">simpleType</code>派生的。
                     </p>
                  </div>
                  <div>
                     <ul class="ullinks">
                        <li class="ulchildlink"><a href="XML-Schema-and-query-object-relational-storage.html#GUID-9F096CEA-7101-4CB9-AC16-2BC0EC370674">声明属性时，可以覆盖XML模式中的SQLType值</a><br>您可以在XML模式中显式指定<code class="codeph">SQLType</code>值作为注释。您指定的SQL数据类型用于XML模式验证，覆盖默认的SQL数据类型。
                        </li>
                     </ul>
                     <div class="familylinks">
                        <div class="parentlink">
                           <p><strong>父主题：</strong> <a href="XML-Schema-and-query-object-relational-storage.html#GUID-844D686D-D95A-4C5B-8624-71BABDBF1EF5" title="您可以使用PL / SQL包DBMS_XMLSCHEMA将XML Schema属性和元素的数据类型映射到SQL数据类型。">使用DBMS_XMLSCHEMA将XML模式数据类型映射到SQL数据类型</a></p>
                        </div>
                     </div>
                  </div>
                  <a id="ADXDB4531"></a><div class="props_rev_3"><a id="GUID-9F096CEA-7101-4CB9-AC16-2BC0EC370674" name="GUID-9F096CEA-7101-4CB9-AC16-2BC0EC370674"></a><h5 id="ADXDB-GUID-9F096CEA-7101-4CB9-AC16-2BC0EC370674" class="sect5"><span class="enumeration_section">18.3.2.1</span>在声明属性时，可以覆盖XML模式中的SQLType值</h5>
                     <div>
                        <p>您可以在XML模式中显式指定<code class="codeph">SQLType</code>值作为注释。您指定的SQL数据类型用于XML模式验证，覆盖默认的SQL数据类型。
                        </p>
                        <p>只允许以下特定形式的此类SQL数据类型覆盖：</p>
                        <ul style="list-style-type:disc">
                           <li>
                              <p>如果默认SQL数据类型为<code class="codeph">STRING</code>则可以使用<code class="codeph">CHAR</code> ， <code class="codeph">VARCHAR</code>或<code class="codeph">CLOB</code>覆盖它。</p>
                           </li>
                           <li>
                              <p>如果默认SQL数据类型是<code class="codeph">RAW</code>那么您可以使用<code class="codeph">RAW</code>或<code class="codeph">BLOB</code>覆盖它。</p>
                           </li>
                        </ul>
                     </div>
                     <div>
                        <div class="familylinks">
                           <div class="parentlink">
                              <p><strong>父主题：</strong> <a href="XML-Schema-and-query-object-relational-storage.html#GUID-73BF2445-E3AE-44AD-9DCE-669EFDD8299C" title="XML属性声明可以根据基本类型，本地simpleType，全局simpleType或对全局属性的引用来指定其XML Schema数据类型（ref =" data="" type="" .=").=" ="" ="">映射到SQL的XML模式属性数据类型</a></p>
                           </div>
                        </div>
                     </div>
                     
                  </div>
               </div><a id="ADXDB4532"></a><div class="props_rev_3"><a id="GUID-F800FE48-194A-4A60-B2D3-8382A3775D2C" name="GUID-F800FE48-194A-4A60-B2D3-8382A3775D2C"></a><h4 id="ADXDB-GUID-F800FE48-194A-4A60-B2D3-8382A3775D2C" class="sect4"><span class="enumeration_section">18.3.3</span>映射到SQL的XML模式元素数据类型</h4>
                  <div>
                     <p>XML元素声明可以使用基本类型，本地或全局<code class="codeph">simpleType</code> ，本地或全局<code class="codeph">complexType</code>或对全局元素（ <code class="codeph">ref=".."</code> ）的引用来指定其XML Schema数据类型。SQL数据类型及其相关信息是从基本XML Schema类型派生的。
                     </p>
                     <p>元素声明可以根据以下任何一种指定其XML Schema数据类型：</p>
                     <ul style="list-style-type:disc">
                        <li>
                           <p>指定属性声明类型的任何方法。请参阅<a href="XML-Schema-and-query-object-relational-storage.html#GUID-73BF2445-E3AE-44AD-9DCE-669EFDD8299C" title="XML属性声明可以根据基本类型，本地simpleType，全局simpleType或对全局属性的引用来指定其XML Schema数据类型（ref =" data="" type="" .=").=" ="" ="">映射到SQL的XML架构属性数据类型</a> 。</p>
                        </li>
                        <li>
                           <p>全局<code class="codeph">complexType</code> ，在此XML架构文档或外部XML架构中指定。
                           </p>
                        </li>
                        <li>
                           <p>引用全局元素（ <code class="codeph">ref="..."</code> ），它本身可以在此XML模式文档中或外部XML模式中。
                           </p>
                        </li>
                        <li>
                           <p>本地<code class="codeph">complexType</code> 。
                           </p>
                        </li>
                     </ul>
                  </div>
                  <div>
                     <ul class="ullinks">
                        <li class="ulchildlink"><a href="XML-Schema-and-query-object-relational-storage.html#GUID-ED63CA4B-1200-4000-89A3-DA8B4E48E597">声明元素时覆盖XML模式中的SQLType值</a><br>默认情况下，基于<code class="codeph">complexType</code>的元素映射到SQL对象类型，该类型包含与其每个子元素和属性对应的对象属性。您可以通过在输入XML模式中显式指定属性<code class="codeph">SQLType</code>的值来覆盖此映射。
                        </li>
                     </ul>
                     <div class="familylinks">
                        <div class="parentlink">
                           <p><strong>父主题：</strong> <a href="XML-Schema-and-query-object-relational-storage.html#GUID-844D686D-D95A-4C5B-8624-71BABDBF1EF5" title="您可以使用PL / SQL包DBMS_XMLSCHEMA将XML Schema属性和元素的数据类型映射到SQL数据类型。">使用DBMS_XMLSCHEMA将XML模式数据类型映射到SQL数据类型</a></p>
                        </div>
                     </div>
                  </div>
                  <a id="ADXDB4533"></a><div class="props_rev_3"><a id="GUID-ED63CA4B-1200-4000-89A3-DA8B4E48E597" name="GUID-ED63CA4B-1200-4000-89A3-DA8B4E48E597"></a><h5 id="ADXDB-GUID-ED63CA4B-1200-4000-89A3-DA8B4E48E597" class="sect5"><span class="enumeration_section">18.3.3.1</span>声明元素时覆盖XML模式中的SQLType值</h5>
                     <div>
                        <p>默认情况下，基于<code class="codeph">complexType</code>的元素映射到SQL对象类型，该类型包含与其每个子元素和属性对应的对象属性。您可以通过在输入XML模式中显式指定属性<code class="codeph">SQLType</code>的值来覆盖此映射。
                        </p>
                        <p>此处允许使用以下<code class="codeph">SQLType</code>值：</p>
                        <ul style="list-style-type:disc">
                           <li>
                              <p><code class="codeph">VARCHAR2</code></p>
                           </li>
                           <li>
                              <p><code class="codeph">生的</code></p>
                           </li>
                           <li>
                              <p><code class="codeph">CLOB</code></p>
                           </li>
                           <li>
                              <p><code class="codeph">BLOB</code></p>
                           </li>
                        </ul>
                        <p>它们表示在数据库中以文本形式存储XML数据。</p>
                        <p>例如，要将<code class="codeph">SQLType</code>从<code class="codeph">VARCHAR2</code>覆盖为<code class="codeph">CLOB</code> ，请使用<code class="codeph">xmlns:xdb="http://xmlns.oracle.com/xdb"</code>声明<code class="codeph">xdb</code>命名空间<code class="codeph">xmlns:xdb="http://xmlns.oracle.com/xdb"</code> ，然后使用<code class="codeph">xdb:SQLType = "CLOB"</code> 。
                        </p>
                        <p>处理以下特殊情况：</p>
                        <ul style="list-style-type:disc">
                           <li>
                              <p>如果在处理用于声明元素和在c <code class="codeph">omplexType</code>声明的元素的<code class="codeph">complexType</code>值时检测到循环，则强制<code class="codeph">SQLInline</code>属性为<code class="codeph">false</code> ，并将正确的SQL映射设置为<code class="codeph">REF</code> <code class="codeph">XMLType</code> 。
                              </p>
                           </li>
                           <li>
                              <p>如果<code class="codeph">maxOccurs &gt; 1</code> ，则可能会创建varray类型。
                              </p>
                              <ul style="list-style-type:disc">
                                 <li>
                                    <p>如果<code class="codeph">SQLInline</code> <code class="codeph">= "true"</code> ，则创建一个varray类型，其元素类型是先前确定的SQL数据类型。varray的基数基于属性<code class="codeph">maxOccurs</code>的值。您可以使用属性<code class="codeph">SQLCollType</code>指定varray类型的名称，也可以从元素名称派生。
                                    </p>
                                 </li>
                                 <li>
                                    <p>如果<code class="codeph">SQLInline = "false"</code> ，则SQL数据类型设置为<code class="codeph">XDB.XDB$XMLTYPE_REF_LIST_T</code> 。这是一种预定义的数据类型，表示指向<code class="codeph">XMLType</code>实例的<code class="codeph">REF</code>值数组。
                                    </p>
                                 </li>
                              </ul>
                           </li>
                           <li>
                              <p>如果元素是全局元素，或者<code class="codeph">SQLInline = "false"</code> ，则系统会创建默认表。您可以指定默认表的名称，也可以从元素名称派生。
                              </p>
                           </li>
                        </ul>
                     </div>
                     <div>
                        <div class="familylinks">
                           <div class="parentlink">
                              <p><strong>父主题：</strong> <a href="XML-Schema-and-query-object-relational-storage.html#GUID-F800FE48-194A-4A60-B2D3-8382A3775D2C" title="XML元素声明可以使用基本类型，本地或全局simpleType，本地或全局complexType或对全局元素的引用来指定其XML Schema数据类型（ref =" data="" type="" .=").=" ="" ="">映射到SQL的XML模式元素数据类型</a></p>
                           </div>
                        </div>
                     </div>
                     
                  </div>
               </div><a id="ADXDB4535"></a><a id="ADXDB4536"></a><a id="ADXDB4537"></a><a id="ADXDB4538"></a><a id="ADXDB4539"></a><a id="ADXDB4540"></a><a id="ADXDB4534"></a><div class="props_rev_3"><a id="GUID-4920BA1A-5769-49C6-870E-E3CA30F0016C" name="GUID-4920BA1A-5769-49C6-870E-E3CA30F0016C"></a><h4 id="ADXDB-GUID-4920BA1A-5769-49C6-870E-E3CA30F0016C" class="sect4"><span class="enumeration_section">18.3.4</span> XML Schema simpleType如何映射到SQL</h4>
                  <div>
                     <p>XML <code class="codeph">simpleType</code>以各种方式映射到SQL对象类型，具体取决于<code class="codeph">simpleType</code>的定义方式。
                     </p>
                     <p><a href="XML-Schema-and-query-object-relational-storage.html#GUID-4920BA1A-5769-49C6-870E-E3CA30F0016C__CIHHFDHA">图18-1</a>说明了一种这样的映射，XML字符串类型为SQL <code class="codeph">VARCHAR2</code>或<code class="codeph">CLOB</code> 。</p>
                     <div class="figure" id="GUID-4920BA1A-5769-49C6-870E-E3CA30F0016C__CIHHFDHA">
                        <p class="titleinfigure">图18-1 simpleType映射：XML字符串到SQL VARCHAR2或CLOB</p><img src="img/adxdb038.gif" width="228" alt="下面是图18-1的描述" title="下面是图18-1的描述" longdesc="img_text/adxdb038.html"><br><a href="img_text/adxdb038.html">“图18-1 simpleType映射：XML字符串到SQL VARCHAR2或CLOB”的描述</a></div>
                     <!-- class="figure" -->
                     <p><a href="XML-Schema-and-query-object-relational-storage.html#GUID-4920BA1A-5769-49C6-870E-E3CA30F0016C__CIHJFDGH" title="此表描述了XML字符串数据类型到SQL的映射。它包括默认映射。">表18-3</a>到<a href="XML-Schema-and-query-object-relational-storage.html#GUID-4920BA1A-5769-49C6-870E-E3CA30F0016C__CIHGIDDJ" title="此表描述了XML DATE数据类型到SQL的映射。">表18-6</a>显示了XML Schema <code class="codeph">simpleType</code>到SQL的缺省映射，如XML Schema定义中所指定。
                     </p>
                     <p>例如：</p>
                     <ul style="list-style-type:disc">
                        <li>
                           <p>XML Schema <span class="italic">原语</span>类型映射到最接近的SQL数据类型。例如， <code class="codeph">DECIMAL</code> ， <code class="codeph">POSITIVEINTEGER</code>和<code class="codeph">FLOAT</code>都映射到SQL <code class="codeph">NUMBER</code> 。</p>
                        </li>
                        <li>
                           <p>XML Schema <span class="italic">枚举</span>类型映射到具有单个<code class="codeph">RAW(</code> <span class="italic"><code class="codeph">n</code></span> <code class="codeph">)</code>对象属性的SQL对象类型。<span class="italic"><code class="codeph">n</code></span>的值由枚举声明中的可能值的数量确定。
                           </p>
                        </li>
                        <li>
                           <p>XML Schema <span class="italic">列表</span>或<span class="italic">union</span>类型映射到SQL字符串（ <code class="codeph">VARCHAR2</code>或<code class="codeph">CLOB</code> ）数据类型。
                           </p>
                        </li>
                     </ul>
                     <div class="tblformalwide" id="GUID-4920BA1A-5769-49C6-870E-E3CA30F0016C__CIHJFDGH">
                        <p class="titleintable">表18-3映射到SQL的XML模式字符串数据类型</p>
                        <table cellpadding="4" cellspacing="0" class="FormalWide" title="XML Schema String数据类型映射到SQL" width="100%" border="1" summary="This table describes the mapping of XML string datatypes to SQL. It includes the default mapping." frame="hsides" rules="rows">
                           <thead>
                              <tr align="left" valign="top">
                                 <th align="left" valign="bottom" width="14%" id="d86720e3876">XML模式字符串类型</th>
                                 <th align="left" valign="bottom" width="12%" id="d86720e3879">长度或MaxLength方面</th>
                                 <th align="left" valign="bottom" width="52%" id="d86720e3882">默认SQL数据类型</th>
                                 <th align="left" valign="bottom" width="22%" id="d86720e3885">兼容的SQL数据类型</th>
                              </tr>
                           </thead>
                           <tbody>
                              <tr align="left" valign="top">
                                 <td align="left" valign="top" width="14%" id="d86720e3890" headers="d86720e3876 ">
                                    <p><code class="codeph">串</code></p>
                                 </td>
                                 <td align="left" valign="top" width="12%" headers="d86720e3890 d86720e3879 ">
                                    <p>ñ</p>
                                 </td>
                                 <td align="left" valign="top" width="52%" headers="d86720e3890 d86720e3882 ">
                                    <p>如果<code class="codeph">n</code> &lt;4000则为<code class="codeph">VARCHAR2(n)</code> ，否则为<code class="codeph">VARCHAR2(4000)</code></p>
                                 </td>
                                 <td align="left" valign="top" width="22%" headers="d86720e3890 d86720e3885 ">
                                    <p><code class="codeph">CHAR</code> ， <code class="codeph">CLOB</code></p>
                                 </td>
                              </tr>
                              <tr align="left" valign="top">
                                 <td align="left" valign="top" width="14%" id="d86720e3915" headers="d86720e3876 ">
                                    <p><code class="codeph">串</code></p>
                                 </td>
                                 <td align="left" valign="top" width="12%" headers="d86720e3915 d86720e3879 ">
                                    <p>-</p>
                                 </td>
                                 <td align="left" valign="top" width="52%" headers="d86720e3915 d86720e3882 ">
                                    <p><code class="codeph">VARCHAR2(4000)</code>如果<code class="codeph">mapUnboundedStringToLob = "false"</code> ， <code class="codeph">CLOB</code></p>
                                 </td>
                                 <td align="left" valign="top" width="22%" headers="d86720e3915 d86720e3885 ">
                                    <p><code class="codeph">CHAR</code> ， <code class="codeph">CLOB</code></p>
                                 </td>
                              </tr>
                           </tbody>
                        </table>
                     </div>
                     <!-- class="inftblhruleinformal" -->
                     <div class="tblformalwide" id="GUID-4920BA1A-5769-49C6-870E-E3CA30F0016C__GUID-1F77BC9E-C5F8-4877-9F9D-A6FDBDB6BADB">
                        <p class="titleintable">表18-4映射到SQL的XML模式二进制数据类型（hexBinary / base64Binary）</p>
                        <table cellpadding="4" cellspacing="0" class="FormalWide" title="XML Schema二进制数据类型（hexBinary / base64Binary）映射到SQL" width="100%" border="1" summary="This table describes the mapping of binary datatypes to SQL. It includes the default mapping." frame="hsides" rules="rows">
                           <thead>
                              <tr align="left" valign="top">
                                 <th align="left" valign="bottom" width="27%" id="d86720e3951">XML Schema二进制类型</th>
                                 <th align="left" valign="bottom" width="12%" id="d86720e3954">长度或MaxLength方面</th>
                                 <th align="left" valign="bottom" width="50%" id="d86720e3957">默认SQL数据类型</th>
                                 <th align="left" valign="bottom" width="12%" id="d86720e3960">兼容的SQL数据类型</th>
                              </tr>
                           </thead>
                           <tbody>
                              <tr align="left" valign="top">
                                 <td align="left" valign="top" width="27%" id="d86720e3965" headers="d86720e3951 ">
                                    <p><code class="codeph">hexBinary</code> ， <code class="codeph">base64Binary</code></p>
                                 </td>
                                 <td align="left" valign="top" width="12%" headers="d86720e3965 d86720e3954 ">
                                    <p>ñ</p>
                                 </td>
                                 <td align="left" valign="top" width="50%" headers="d86720e3965 d86720e3957 ">
                                    <p>如果<code class="codeph">n</code> &lt;2000则<code class="codeph">RAW(n)</code> ，否则<code class="codeph">RAW(2000)</code></p>
                                 </td>
                                 <td align="left" valign="top" width="12%" headers="d86720e3965 d86720e3960 ">
                                    <p><code class="codeph">RAW</code> ， <code class="codeph">BLOB</code></p>
                                 </td>
                              </tr>
                              <tr align="left" valign="top">
                                 <td align="left" valign="top" width="27%" id="d86720e3993" headers="d86720e3951 ">
                                    <p><code class="codeph">hexBinary</code> ， <code class="codeph">base64Binary</code></p>
                                 </td>
                                 <td align="left" valign="top" width="12%" headers="d86720e3993 d86720e3954 ">
                                    <p>-</p>
                                 </td>
                                 <td align="left" valign="top" width="50%" headers="d86720e3993 d86720e3957 ">
                                    <p><code class="codeph">RAW(2000)</code>如果<code class="codeph">mapUnboundedStringToLob = "false"</code> ， <code class="codeph">BLOB</code></p>
                                 </td>
                                 <td align="left" valign="top" width="12%" headers="d86720e3993 d86720e3960 ">
                                    <p><code class="codeph">RAW</code> ， <code class="codeph">BLOB</code></p>
                                 </td>
                              </tr>
                           </tbody>
                        </table>
                     </div>
                     <!-- class="inftblhruleinformal" -->
                     <div class="tblformalwide" id="GUID-4920BA1A-5769-49C6-870E-E3CA30F0016C__GUID-FEC3D7EF-86BE-4E99-BC3D-76307B2341B2">
                        <p class="titleintable">表18-5数字XML模式基元类型到SQL的默认映射</p>
                        <table cellpadding="4" cellspacing="0" class="FormalWide" title="将数字XML模式基元类型默认映射到SQL" width="100%" border="1" summary="This table describes the default mapping of numeric XML primitive types to SQL. It includes the default data type." frame="hsides" rules="rows">
                           <thead>
                              <tr align="left" valign="top">
                                 <th align="left" valign="bottom" width="23%" id="d86720e4032">XML Schema简单类型</th>
                                 <th align="left" valign="bottom" width="17%" id="d86720e4035">默认SQL数据类型</th>
                                 <th align="left" valign="bottom" width="27%" id="d86720e4038">totalDigits（m），fractionDigits（n）指定</th>
                                 <th align="left" valign="bottom" width="33%" id="d86720e4041">兼容的SQL数据类型</th>
                              </tr>
                           </thead>
                           <tbody>
                              <tr align="left" valign="top">
                                 <td align="left" valign="top" width="23%" id="d86720e4046" headers="d86720e4032 ">
                                    <p><code class="codeph">浮动</code></p>
                                 </td>
                                 <td align="left" valign="top" width="17%" headers="d86720e4046 d86720e4035 ">
                                    <p><code class="codeph">数</code></p>
                                 </td>
                                 <td align="left" valign="top" width="27%" headers="d86720e4046 d86720e4038 ">
                                    <p><code class="codeph">NUMBER（M + N，n）的</code></p>
                                 </td>
                                 <td align="left" valign="top" width="33%" headers="d86720e4046 d86720e4041 ">
                                    <p><code class="codeph">FLOAT</code> ， <code class="codeph">DOUBLE</code> ， <code class="codeph">BINARY_FLOAT</code></p>
                                 </td>
                              </tr>
                              <tr align="left" valign="top">
                                 <td align="left" valign="top" width="23%" id="d86720e4069" headers="d86720e4032 ">
                                    <p><code class="codeph">双</code></p>
                                 </td>
                                 <td align="left" valign="top" width="17%" headers="d86720e4069 d86720e4035 ">
                                    <p><code class="codeph">数</code></p>
                                 </td>
                                 <td align="left" valign="top" width="27%" headers="d86720e4069 d86720e4038 ">
                                    <p><code class="codeph">NUMBER（M + N，n）的</code></p>
                                 </td>
                                 <td align="left" valign="top" width="33%" headers="d86720e4069 d86720e4041 ">
                                    <p><code class="codeph">FLOAT</code> ， <code class="codeph">DOUBLE</code> ， <code class="codeph">BINARY_DOUBLE</code></p>
                                 </td>
                              </tr>
                              <tr align="left" valign="top">
                                 <td align="left" valign="top" width="23%" id="d86720e4092" headers="d86720e4032 ">
                                    <p><code class="codeph">十进制</code></p>
                                 </td>
                                 <td align="left" valign="top" width="17%" headers="d86720e4092 d86720e4035 ">
                                    <p><code class="codeph">数</code></p>
                                 </td>
                                 <td align="left" valign="top" width="27%" headers="d86720e4092 d86720e4038 ">
                                    <p><code class="codeph">NUMBER（M + N，n）的</code></p>
                                 </td>
                                 <td align="left" valign="top" width="33%" headers="d86720e4092 d86720e4041 ">
                                    <p><code class="codeph">FLOAT</code> ， <code class="codeph">DOUBLE</code></p>
                                 </td>
                              </tr>
                              <tr align="left" valign="top">
                                 <td align="left" valign="top" width="23%" id="d86720e4112" headers="d86720e4032 ">
                                    <p><code class="codeph">整数</code></p>
                                 </td>
                                 <td align="left" valign="top" width="17%" headers="d86720e4112 d86720e4035 ">
                                    <p><code class="codeph">数</code></p>
                                 </td>
                                 <td align="left" valign="top" width="27%" headers="d86720e4112 d86720e4038 ">
                                    <p><code class="codeph">NUMBER（M + N，n）的</code></p>
                                 </td>
                                 <td align="left" valign="top" width="33%" headers="d86720e4112 d86720e4041 ">
                                    <p><code class="codeph">数</code></p>
                                 </td>
                              </tr>
                              <tr align="left" valign="top">
                                 <td align="left" valign="top" width="23%" id="d86720e4129" headers="d86720e4032 ">
                                    <p><code class="codeph">非负</code></p>
                                 </td>
                                 <td align="left" valign="top" width="17%" headers="d86720e4129 d86720e4035 ">
                                    <p><code class="codeph">数</code></p>
                                 </td>
                                 <td align="left" valign="top" width="27%" headers="d86720e4129 d86720e4038 ">
                                    <p><code class="codeph">NUMBER（M + N，n）的</code></p>
                                 </td>
                                 <td align="left" valign="top" width="33%" headers="d86720e4129 d86720e4041 ">
                                    <p><code class="codeph">数</code></p>
                                 </td>
                              </tr>
                              <tr align="left" valign="top">
                                 <td align="left" valign="top" width="23%" id="d86720e4146" headers="d86720e4032 ">
                                    <p><code class="codeph">positiveInteger</code></p>
                                 </td>
                                 <td align="left" valign="top" width="17%" headers="d86720e4146 d86720e4035 ">
                                    <p><code class="codeph">数</code></p>
                                 </td>
                                 <td align="left" valign="top" width="27%" headers="d86720e4146 d86720e4038 ">
                                    <p><code class="codeph">NUMBER（M + N，n）的</code></p>
                                 </td>
                                 <td align="left" valign="top" width="33%" headers="d86720e4146 d86720e4041 ">
                                    <p><code class="codeph">数</code></p>
                                 </td>
                              </tr>
                              <tr align="left" valign="top">
                                 <td align="left" valign="top" width="23%" id="d86720e4163" headers="d86720e4032 ">
                                    <p><code class="codeph">nonPositiveInteger</code></p>
                                 </td>
                                 <td align="left" valign="top" width="17%" headers="d86720e4163 d86720e4035 ">
                                    <p><code class="codeph">数</code></p>
                                 </td>
                                 <td align="left" valign="top" width="27%" headers="d86720e4163 d86720e4038 ">
                                    <p><code class="codeph">NUMBER（M + N，n）的</code></p>
                                 </td>
                                 <td align="left" valign="top" width="33%" headers="d86720e4163 d86720e4041 ">
                                    <p><code class="codeph">数</code></p>
                                 </td>
                              </tr>
                              <tr align="left" valign="top">
                                 <td align="left" valign="top" width="23%" id="d86720e4180" headers="d86720e4032 ">
                                    <p><code class="codeph">negativeInteger</code></p>
                                 </td>
                                 <td align="left" valign="top" width="17%" headers="d86720e4180 d86720e4035 ">
                                    <p><code class="codeph">数</code></p>
                                 </td>
                                 <td align="left" valign="top" width="27%" headers="d86720e4180 d86720e4038 ">
                                    <p><code class="codeph">NUMBER（M + N，n）的</code></p>
                                 </td>
                                 <td align="left" valign="top" width="33%" headers="d86720e4180 d86720e4041 ">
                                    <p><code class="codeph">数</code></p>
                                 </td>
                              </tr>
                              <tr align="left" valign="top">
                                 <td align="left" valign="top" width="23%" id="d86720e4197" headers="d86720e4032 ">
                                    <p><code class="codeph">长</code></p>
                                 </td>
                                 <td align="left" valign="top" width="17%" headers="d86720e4197 d86720e4035 ">
                                    <p><code class="codeph">NUMBER（20）</code></p>
                                 </td>
                                 <td align="left" valign="top" width="27%" headers="d86720e4197 d86720e4038 ">
                                    <p><code class="codeph">NUMBER（M + N，n）的</code></p>
                                 </td>
                                 <td align="left" valign="top" width="33%" headers="d86720e4197 d86720e4041 ">
                                    <p><code class="codeph">数</code></p>
                                 </td>
                              </tr>
                              <tr align="left" valign="top">
                                 <td align="left" valign="top" width="23%" id="d86720e4214" headers="d86720e4032 ">
                                    <p><code class="codeph">unsignedLong</code></p>
                                 </td>
                                 <td align="left" valign="top" width="17%" headers="d86720e4214 d86720e4035 ">
                                    <p><code class="codeph">NUMBER（20）</code></p>
                                 </td>
                                 <td align="left" valign="top" width="27%" headers="d86720e4214 d86720e4038 ">
                                    <p><code class="codeph">NUMBER（M + N，n）的</code></p>
                                 </td>
                                 <td align="left" valign="top" width="33%" headers="d86720e4214 d86720e4041 ">
                                    <p><code class="codeph">数</code></p>
                                 </td>
                              </tr>
                              <tr align="left" valign="top">
                                 <td align="left" valign="top" width="23%" id="d86720e4231" headers="d86720e4032 ">
                                    <p><code class="codeph">INT</code></p>
                                 </td>
                                 <td align="left" valign="top" width="17%" headers="d86720e4231 d86720e4035 ">
                                    <p><code class="codeph">NUMBER（10）</code></p>
                                 </td>
                                 <td align="left" valign="top" width="27%" headers="d86720e4231 d86720e4038 ">
                                    <p><code class="codeph">NUMBER（M + N，n）的</code></p>
                                 </td>
                                 <td align="left" valign="top" width="33%" headers="d86720e4231 d86720e4041 ">
                                    <p><code class="codeph">数</code></p>
                                 </td>
                              </tr>
                              <tr align="left" valign="top">
                                 <td align="left" valign="top" width="23%" id="d86720e4249" headers="d86720e4032 ">
                                    <p><code class="codeph">无符号整型</code></p>
                                 </td>
                                 <td align="left" valign="top" width="17%" headers="d86720e4249 d86720e4035 ">
                                    <p><code class="codeph">NUMBER（10）</code></p>
                                 </td>
                                 <td align="left" valign="top" width="27%" headers="d86720e4249 d86720e4038 ">
                                    <p><code class="codeph">NUMBER（M + N，n）的</code></p>
                                 </td>
                                 <td align="left" valign="top" width="33%" headers="d86720e4249 d86720e4041 ">
                                    <p><code class="codeph">数</code></p>
                                 </td>
                              </tr>
                              <tr align="left" valign="top">
                                 <td align="left" valign="top" width="23%" id="d86720e4266" headers="d86720e4032 ">
                                    <p><code class="codeph">短</code></p>
                                 </td>
                                 <td align="left" valign="top" width="17%" headers="d86720e4266 d86720e4035 ">
                                    <p><code class="codeph">NUMBER（5）</code></p>
                                 </td>
                                 <td align="left" valign="top" width="27%" headers="d86720e4266 d86720e4038 ">
                                    <p><code class="codeph">NUMBER（M + N，n）的</code></p>
                                 </td>
                                 <td align="left" valign="top" width="33%" headers="d86720e4266 d86720e4041 ">
                                    <p><code class="codeph">数</code></p>
                                 </td>
                              </tr>
                              <tr align="left" valign="top">
                                 <td align="left" valign="top" width="23%" id="d86720e4283" headers="d86720e4032 ">
                                    <p><code class="codeph">unsignedShort的</code></p>
                                 </td>
                                 <td align="left" valign="top" width="17%" headers="d86720e4283 d86720e4035 ">
                                    <p><code class="codeph">NUMBER（5）</code></p>
                                 </td>
                                 <td align="left" valign="top" width="27%" headers="d86720e4283 d86720e4038 ">
                                    <p><code class="codeph">NUMBER（M + N，n）的</code></p>
                                 </td>
                                 <td align="left" valign="top" width="33%" headers="d86720e4283 d86720e4041 ">
                                    <p><code class="codeph">数</code></p>
                                 </td>
                              </tr>
                              <tr align="left" valign="top">
                                 <td align="left" valign="top" width="23%" id="d86720e4300" headers="d86720e4032 ">
                                    <p><code class="codeph">字节</code></p>
                                 </td>
                                 <td align="left" valign="top" width="17%" headers="d86720e4300 d86720e4035 ">
                                    <p><code class="codeph">NUMBER（3）</code></p>
                                 </td>
                                 <td align="left" valign="top" width="27%" headers="d86720e4300 d86720e4038 ">
                                    <p><code class="codeph">NUMBER（M + N，n）的</code></p>
                                 </td>
                                 <td align="left" valign="top" width="33%" headers="d86720e4300 d86720e4041 ">
                                    <p><code class="codeph">数</code></p>
                                 </td>
                              </tr>
                              <tr align="left" valign="top">
                                 <td align="left" valign="top" width="23%" id="d86720e4317" headers="d86720e4032 ">
                                    <p><code class="codeph">UnsignedByte的</code></p>
                                 </td>
                                 <td align="left" valign="top" width="17%" headers="d86720e4317 d86720e4035 ">
                                    <p><code class="codeph">NUMBER（3）</code></p>
                                 </td>
                                 <td align="left" valign="top" width="27%" headers="d86720e4317 d86720e4038 ">
                                    <p><code class="codeph">NUMBER（M + N，n）的</code></p>
                                 </td>
                                 <td align="left" valign="top" width="33%" headers="d86720e4317 d86720e4041 ">
                                    <p><code class="codeph">数</code></p>
                                 </td>
                              </tr>
                           </tbody>
                        </table>
                     </div>
                     <!-- class="inftblhruleinformal" -->
                     <div class="tblformalwide" id="GUID-4920BA1A-5769-49C6-870E-E3CA30F0016C__CIHGIDDJ">
                        <p class="titleintable">表18-6映射到SQL的XML架构日期和时间数据类型</p>
                        <table cellpadding="4" cellspacing="0" class="FormalWide" title="XML Schema日期和时间数据类型映射到SQL" width="100%" border="1" summary="This table describes the mapping of XML DATE datatype to SQL." frame="hsides" rules="rows">
                           <thead>
                              <tr align="left" valign="top">
                                 <th align="left" valign="bottom" width="32%" id="d86720e4344">XML架构日期或时间类型</th>
                                 <th align="left" valign="bottom" width="29%" id="d86720e4347">默认SQL数据类型</th>
                                 <th align="left" valign="bottom" width="39%" id="d86720e4350">兼容的SQL数据类型</th>
                              </tr>
                           </thead>
                           <tbody>
                              <tr align="left" valign="top">
                                 <td align="left" valign="top" width="32%" id="d86720e4355" headers="d86720e4344 ">
                                    <p><code class="codeph">约会时间</code></p>
                                 </td>
                                 <td align="left" valign="top" width="29%" headers="d86720e4355 d86720e4347 ">
                                    <p><code class="codeph">TIMESTAMP</code></p>
                                 </td>
                                 <td align="left" valign="top" width="39%" headers="d86720e4355 d86720e4350 ">
                                    <p><code class="codeph">TIMESTAMP WITH TIME ZONE</code> ， <code class="codeph">DATE</code></p>
                                 </td>
                              </tr>
                              <tr align="left" valign="top">
                                 <td align="left" valign="top" width="32%" id="d86720e4371" headers="d86720e4344 ">
                                    <p><code class="codeph">时间</code></p>
                                 </td>
                                 <td align="left" valign="top" width="29%" headers="d86720e4371 d86720e4347 ">
                                    <p><code class="codeph">TIMESTAMP</code></p>
                                 </td>
                                 <td align="left" valign="top" width="39%" headers="d86720e4371 d86720e4350 ">
                                    <p><code class="codeph">TIMESTAMP WITH TIME ZONE</code> ， <code class="codeph">DATE</code></p>
                                 </td>
                              </tr>
                              <tr align="left" valign="top">
                                 <td align="left" valign="top" width="32%" id="d86720e4387" headers="d86720e4344 ">
                                    <p><code class="codeph">日期</code></p>
                                 </td>
                                 <td align="left" valign="top" width="29%" headers="d86720e4387 d86720e4347 ">
                                    <p><code class="codeph">日期</code></p>
                                 </td>
                                 <td align="left" valign="top" width="39%" headers="d86720e4387 d86720e4350 ">
                                    <p><code class="codeph">TIMESTAMP与时区</code></p>
                                 </td>
                              </tr>
                              <tr align="left" valign="top">
                                 <td align="left" valign="top" width="32%" id="d86720e4400" headers="d86720e4344 ">
                                    <p><code class="codeph">GDAY</code></p>
                                 </td>
                                 <td align="left" valign="top" width="29%" headers="d86720e4400 d86720e4347 ">
                                    <p><code class="codeph">日期</code></p>
                                 </td>
                                 <td align="left" valign="top" width="39%" headers="d86720e4400 d86720e4350 ">
                                    <p><code class="codeph">TIMESTAMP与时区</code></p>
                                 </td>
                              </tr>
                              <tr align="left" valign="top">
                                 <td align="left" valign="top" width="32%" id="d86720e4413" headers="d86720e4344 ">
                                    <p><code class="codeph">gMonth的</code></p>
                                 </td>
                                 <td align="left" valign="top" width="29%" headers="d86720e4413 d86720e4347 ">
                                    <p><code class="codeph">日期</code></p>
                                 </td>
                                 <td align="left" valign="top" width="39%" headers="d86720e4413 d86720e4350 ">
                                    <p><code class="codeph">TIMESTAMP与时区</code></p>
                                 </td>
                              </tr>
                              <tr align="left" valign="top">
                                 <td align="left" valign="top" width="32%" id="d86720e4426" headers="d86720e4344 ">
                                    <p><code class="codeph">gYear的</code></p>
                                 </td>
                                 <td align="left" valign="top" width="29%" headers="d86720e4426 d86720e4347 ">
                                    <p><code class="codeph">日期</code></p>
                                 </td>
                                 <td align="left" valign="top" width="39%" headers="d86720e4426 d86720e4350 ">
                                    <p><code class="codeph">TIMESTAMP与时区</code></p>
                                 </td>
                              </tr>
                              <tr align="left" valign="top">
                                 <td align="left" valign="top" width="32%" id="d86720e4439" headers="d86720e4344 ">
                                    <p><code class="codeph">gYearMonth的</code></p>
                                 </td>
                                 <td align="left" valign="top" width="29%" headers="d86720e4439 d86720e4347 ">
                                    <p><code class="codeph">日期</code></p>
                                 </td>
                                 <td align="left" valign="top" width="39%" headers="d86720e4439 d86720e4350 ">
                                    <p><code class="codeph">TIMESTAMP与时区</code></p>
                                 </td>
                              </tr>
                              <tr align="left" valign="top">
                                 <td align="left" valign="top" width="32%" id="d86720e4452" headers="d86720e4344 ">
                                    <p><code class="codeph">gMonthDay的</code></p>
                                 </td>
                                 <td align="left" valign="top" width="29%" headers="d86720e4452 d86720e4347 ">
                                    <p><code class="codeph">日期</code></p>
                                 </td>
                                 <td align="left" valign="top" width="39%" headers="d86720e4452 d86720e4350 ">
                                    <p><code class="codeph">TIMESTAMP与时区</code></p>
                                 </td>
                              </tr>
                              <tr align="left" valign="top">
                                 <td align="left" valign="top" width="32%" id="d86720e4465" headers="d86720e4344 ">
                                    <p><code class="codeph">持续时间</code></p>
                                 </td>
                                 <td align="left" valign="top" width="29%" headers="d86720e4465 d86720e4347 ">
                                    <p><code class="codeph">VARCHAR2（4000）</code></p>
                                 </td>
                                 <td align="left" valign="top" width="39%" headers="d86720e4465 d86720e4350 ">
                                    <p>没有</p>
                                 </td>
                              </tr>
                           </tbody>
                        </table>
                     </div>
                     <!-- class="inftblhruleinformal" -->
                     <div class="tblformalwide" id="GUID-4920BA1A-5769-49C6-870E-E3CA30F0016C__GUID-B26BBA39-EB38-4C85-9E77-AAB58E3BB21F">
                        <p class="titleintable">表18-7其他XML模式的原始和派生数据类型到SQL的缺省映射</p>
                        <table cellpadding="4" cellspacing="0" class="FormalWide" title="其他XML模式的原始和派生数据类型的默认映射到SQL" width="100%" border="1" summary="This table describes the default mapping of other XML primitive datatypes to SQL." frame="hsides" rules="rows">
                           <thead>
                              <tr align="left" valign="top">
                                 <th align="left" valign="bottom" width="38%" id="d86720e4487">XML Schema Primitive或Derived Type</th>
                                 <th align="left" valign="bottom" width="34%" id="d86720e4490">默认SQL数据类型</th>
                                 <th align="left" valign="bottom" width="27%" id="d86720e4493">兼容的SQL数据类型</th>
                              </tr>
                           </thead>
                           <tbody>
                              <tr align="left" valign="top">
                                 <td align="left" valign="top" width="38%" id="d86720e4498" headers="d86720e4487 ">
                                    <p><code class="codeph">布尔</code></p>
                                 </td>
                                 <td align="left" valign="top" width="34%" headers="d86720e4498 d86720e4490 ">
                                    <p><code class="codeph">RAW（1）</code></p>
                                 </td>
                                 <td align="left" valign="top" width="27%" headers="d86720e4498 d86720e4493 ">
                                    <p><code class="codeph">VARCHAR2</code></p>
                                 </td>
                              </tr>
                              <tr align="left" valign="top">
                                 <td align="left" valign="top" width="38%" id="d86720e4511" headers="d86720e4487 ">
                                    <p><code class="codeph">语言（串）</code></p>
                                 </td>
                                 <td align="left" valign="top" width="34%" headers="d86720e4511 d86720e4490 ">
                                    <p><code class="codeph">VARCHAR2（4000）</code></p>
                                 </td>
                                 <td align="left" valign="top" width="27%" headers="d86720e4511 d86720e4493 ">
                                    <p><code class="codeph">CLOB</code> ， <code class="codeph">CHAR</code></p>
                                 </td>
                              </tr>
                              <tr align="left" valign="top">
                                 <td align="left" valign="top" width="38%" id="d86720e4527" headers="d86720e4487 ">
                                    <p><code class="codeph">NMTOKEN（串）</code></p>
                                 </td>
                                 <td align="left" valign="top" width="34%" headers="d86720e4527 d86720e4490 ">
                                    <p><code class="codeph">VARCHAR2（4000）</code></p>
                                 </td>
                                 <td align="left" valign="top" width="27%" headers="d86720e4527 d86720e4493 ">
                                    <p><code class="codeph">CLOB</code> ， <code class="codeph">CHAR</code></p>
                                 </td>
                              </tr>
                              <tr align="left" valign="top">
                                 <td align="left" valign="top" width="38%" id="d86720e4543" headers="d86720e4487 ">
                                    <p><code class="codeph">NMTOKENS（串）</code></p>
                                 </td>
                                 <td align="left" valign="top" width="34%" headers="d86720e4543 d86720e4490 ">
                                    <p><code class="codeph">VARCHAR2（4000）</code></p>
                                 </td>
                                 <td align="left" valign="top" width="27%" headers="d86720e4543 d86720e4493 ">
                                    <p><code class="codeph">CLOB</code> ， <code class="codeph">CHAR</code></p>
                                 </td>
                              </tr>
                              <tr align="left" valign="top">
                                 <td align="left" valign="top" width="38%" id="d86720e4559" headers="d86720e4487 ">
                                    <p><code class="codeph">名称（字符串）</code></p>
                                 </td>
                                 <td align="left" valign="top" width="34%" headers="d86720e4559 d86720e4490 ">
                                    <p><code class="codeph">VARCHAR2（4000）</code></p>
                                 </td>
                                 <td align="left" valign="top" width="27%" headers="d86720e4559 d86720e4493 ">
                                    <p><code class="codeph">CLOB</code> ， <code class="codeph">CHAR</code></p>
                                 </td>
                              </tr>
                              <tr align="left" valign="top">
                                 <td align="left" valign="top" width="38%" id="d86720e4575" headers="d86720e4487 ">
                                    <p><code class="codeph">的NCName（串）</code></p>
                                 </td>
                                 <td align="left" valign="top" width="34%" headers="d86720e4575 d86720e4490 ">
                                    <p><code class="codeph">VARCHAR2（4000）</code></p>
                                 </td>
                                 <td align="left" valign="top" width="27%" headers="d86720e4575 d86720e4493 ">
                                    <p><code class="codeph">CLOB</code> ， <code class="codeph">CHAR</code></p>
                                 </td>
                              </tr>
                              <tr align="left" valign="top">
                                 <td align="left" valign="top" width="38%" id="d86720e4591" headers="d86720e4487 ">
                                    <p><code class="codeph">ID</code></p>
                                 </td>
                                 <td align="left" valign="top" width="34%" headers="d86720e4591 d86720e4490 ">
                                    <p><code class="codeph">VARCHAR2（4000）</code></p>
                                 </td>
                                 <td align="left" valign="top" width="27%" headers="d86720e4591 d86720e4493 ">
                                    <p><code class="codeph">CLOB</code> ， <code class="codeph">CHAR</code></p>
                                 </td>
                              </tr>
                              <tr align="left" valign="top">
                                 <td align="left" valign="top" width="38%" id="d86720e4607" headers="d86720e4487 ">
                                    <p><code class="codeph">IDREF</code></p>
                                 </td>
                                 <td align="left" valign="top" width="34%" headers="d86720e4607 d86720e4490 ">
                                    <p><code class="codeph">VARCHAR2（4000）</code></p>
                                 </td>
                                 <td align="left" valign="top" width="27%" headers="d86720e4607 d86720e4493 ">
                                    <p><code class="codeph">CLOB</code> ， <code class="codeph">CHAR</code></p>
                                 </td>
                              </tr>
                              <tr align="left" valign="top">
                                 <td align="left" valign="top" width="38%" id="d86720e4623" headers="d86720e4487 ">
                                    <p><code class="codeph">IDREFS</code></p>
                                 </td>
                                 <td align="left" valign="top" width="34%" headers="d86720e4623 d86720e4490 ">
                                    <p><code class="codeph">VARCHAR2（4000）</code></p>
                                 </td>
                                 <td align="left" valign="top" width="27%" headers="d86720e4623 d86720e4493 ">
                                    <p><code class="codeph">CLOB</code> ， <code class="codeph">CHAR</code></p>
                                 </td>
                              </tr>
                              <tr align="left" valign="top">
                                 <td align="left" valign="top" width="38%" id="d86720e4639" headers="d86720e4487 ">
                                    <p><code class="codeph">实体</code> 
                                    </p>
                                 </td>
                                 <td align="left" valign="top" width="34%" headers="d86720e4639 d86720e4490 ">
                                    <p><code class="codeph">VARCHAR2（4000）</code></p>
                                 </td>
                                 <td align="left" valign="top" width="27%" headers="d86720e4639 d86720e4493 ">
                                    <p><code class="codeph">CLOB</code> ， <code class="codeph">CHAR</code></p>
                                 </td>
                              </tr>
                              <tr align="left" valign="top">
                                 <td align="left" valign="top" width="38%" id="d86720e4656" headers="d86720e4487 ">
                                    <p><code class="codeph">实体</code></p>
                                 </td>
                                 <td align="left" valign="top" width="34%" headers="d86720e4656 d86720e4490 ">
                                    <p><code class="codeph">VARCHAR2（4000）</code></p>
                                 </td>
                                 <td align="left" valign="top" width="27%" headers="d86720e4656 d86720e4493 ">
                                    <p><code class="codeph">CLOB</code> ， <code class="codeph">CHAR</code></p>
                                 </td>
                              </tr>
                              <tr align="left" valign="top">
                                 <td align="left" valign="top" width="38%" id="d86720e4673" headers="d86720e4487 ">
                                    <p><code class="codeph">符号</code></p>
                                 </td>
                                 <td align="left" valign="top" width="34%" headers="d86720e4673 d86720e4490 ">
                                    <p><code class="codeph">VARCHAR2（4000）</code></p>
                                 </td>
                                 <td align="left" valign="top" width="27%" headers="d86720e4673 d86720e4493 ">
                                    <p><code class="codeph">CLOB</code> ， <code class="codeph">CHAR</code></p>
                                 </td>
                              </tr>
                              <tr align="left" valign="top">
                                 <td align="left" valign="top" width="38%" id="d86720e4689" headers="d86720e4487 ">
                                    <p><code class="codeph">任何URI</code></p>
                                 </td>
                                 <td align="left" valign="top" width="34%" headers="d86720e4689 d86720e4490 ">
                                    <p><code class="codeph">VARCHAR2（4000）</code></p>
                                 </td>
                                 <td align="left" valign="top" width="27%" headers="d86720e4689 d86720e4493 ">
                                    <p><code class="codeph">CLOB</code> ， <code class="codeph">CHAR</code></p>
                                 </td>
                              </tr>
                              <tr align="left" valign="top">
                                 <td align="left" valign="top" width="38%" id="d86720e4705" headers="d86720e4487 ">
                                    <p><code class="codeph">随便哪种</code></p>
                                 </td>
                                 <td align="left" valign="top" width="34%" headers="d86720e4705 d86720e4490 ">
                                    <p><code class="codeph">VARCHAR2（4000）</code></p>
                                 </td>
                                 <td align="left" valign="top" width="27%" headers="d86720e4705 d86720e4493 ">
                                    <p><code class="codeph">CLOB</code> ， <code class="codeph">CHAR</code></p>
                                 </td>
                              </tr>
                              <tr align="left" valign="top">
                                 <td align="left" valign="top" width="38%" id="d86720e4721" headers="d86720e4487 ">
                                    <p><code class="codeph">anySimpleType</code></p>
                                 </td>
                                 <td align="left" valign="top" width="34%" headers="d86720e4721 d86720e4490 ">
                                    <p><code class="codeph">VARCHAR2（4000）</code></p>
                                 </td>
                                 <td align="left" valign="top" width="27%" headers="d86720e4721 d86720e4493 ">
                                    <p><code class="codeph">CLOB</code> ， <code class="codeph">CHAR</code></p>
                                 </td>
                              </tr>
                              <tr align="left" valign="top">
                                 <td align="left" valign="top" width="38%" id="d86720e4737" headers="d86720e4487 ">
                                    <p><code class="codeph">的QName</code></p>
                                 </td>
                                 <td align="left" valign="top" width="34%" headers="d86720e4737 d86720e4490 ">
                                    <p><code class="codeph">XDB.XDB $ QNAME</code></p>
                                 </td>
                                 <td align="left" valign="top" width="27%" headers="d86720e4737 d86720e4493 ">
                                    <p>没有</p>
                                 </td>
                              </tr>
                              <tr align="left" valign="top">
                                 <td align="left" valign="top" width="38%" id="d86720e4749" headers="d86720e4487 ">
                                    <p><code class="codeph">规格化</code></p>
                                 </td>
                                 <td align="left" valign="top" width="34%" headers="d86720e4749 d86720e4490 ">
                                    <p><code class="codeph">VARCHAR2（4000）</code></p>
                                 </td>
                                 <td align="left" valign="top" width="27%" headers="d86720e4749 d86720e4493 ">
                                    <p>没有</p>
                                 </td>
                              </tr>
                              <tr align="left" valign="top">
                                 <td align="left" valign="top" width="38%" id="d86720e4761" headers="d86720e4487 ">
                                    <p><code class="codeph">代币</code></p>
                                 </td>
                                 <td align="left" valign="top" width="34%" headers="d86720e4761 d86720e4490 ">
                                    <p><code class="codeph">VARCHAR2（4000）</code></p>
                                 </td>
                                 <td align="left" valign="top" width="27%" headers="d86720e4761 d86720e4493 ">
                                    <p>没有</p>
                                 </td>
                              </tr>
                           </tbody>
                        </table>
                     </div>
                     <!-- class="inftblhruleinformal" -->
                  </div>
                  <div>
                     <ul class="ullinks">
                        <li class="ulchildlink"><a href="XML-Schema-and-query-object-relational-storage.html#GUID-07098CDC-609B-4A81-A112-0B54A27A103A">SQLType不支持NCHAR，NVARCHAR2和NCLOB SQLType值</a><br>Oracle XML DB信息<span class="italic">不</span>支持<code class="codeph">NCHAR</code> ， <code class="codeph">NVARCHAR2</code>和<code class="codeph">NCLOB</code>作为属性值<code class="codeph">SQLType</code> ：你不能指定一个XML元素或属性是为类型<code class="codeph">NCHAR</code> ， <code class="codeph">NVARCHAR2</code>或<code class="codeph">NCLOB</code> 。此外，如果您提供自己的数据类型，请不要使用任何这些数据类型。
                        </li>
                        <li class="ulchildlink"><a href="XML-Schema-and-query-object-relational-storage.html#GUID-0F8F7480-56F4-4910-9FD6-8566A1F70BC6">simpleType：XML字符串如何映射到SQL VARCHAR2与CLOB</a><br>如果XML模式将数据类型指定为<code class="codeph">maxLength</code>小于4000的字符串，则将其映射到指定长度的<code class="codeph">VARCHAR2</code>对象属性。如果未在架构中指定<code class="codeph">maxLength</code> ，则XML架构数据类型只能映射到LOB。</li>
                        <li class="ulchildlink"><a href="XML-Schema-and-query-object-relational-storage.html#GUID-F6855A35-3E83-4837-ABE9-320498CCC45B">XML模式时区如何映射到SQL</a><br>如果您的应用程序需要使用时区指示符，则使用属性<code class="codeph">SQLType</code>将SQL数据类型指定为<code class="codeph">TIMESTAMP WITH TIME ZONE</code> 。这可确保可以正确存储和检索包含时区指示符的值。
                        </li>
                     </ul>
                     <div class="familylinks">
                        <div class="parentlink">
                           <p><strong>父主题：</strong> <a href="XML-Schema-and-query-object-relational-storage.html#GUID-844D686D-D95A-4C5B-8624-71BABDBF1EF5" title="您可以使用PL / SQL包DBMS_XMLSCHEMA将XML Schema属性和元素的数据类型映射到SQL数据类型。">使用DBMS_XMLSCHEMA将XML模式数据类型映射到SQL数据类型</a></p>
                        </div>
                     </div>
                  </div>
                  <a id="ADXDB4541"></a><div class="props_rev_3"><a id="GUID-07098CDC-609B-4A81-A112-0B54A27A103A" name="GUID-07098CDC-609B-4A81-A112-0B54A27A103A"></a><h5 id="ADXDB-GUID-07098CDC-609B-4A81-A112-0B54A27A103A" class="sect5"><span class="enumeration_section">18.3.4.1</span> SQLType不支持NCHAR，NVARCHAR2和NCLOB SQLType值</h5>
                     <div>
                        <p>Oracle XML DB信息<span class="italic">不</span>支持<code class="codeph">NCHAR</code> ， <code class="codeph">NVARCHAR2</code>和<code class="codeph">NCLOB</code>作为属性值<code class="codeph">SQLType</code> ：你不能指定一个XML元素或属性是为类型<code class="codeph">NCHAR</code> ， <code class="codeph">NVARCHAR2</code>或<code class="codeph">NCLOB</code> 。此外，如果您提供自己的数据类型，请不要使用任何这些数据类型。
                        </p>
                        <div class="section"></div>
                        <!-- class="section" -->
                     </div>
                     <div>
                        <div class="relinfo">
                           <p><strong>相关话题</strong></p>
                           <ul>
                              <li><a href="XML-DB-restrictions.html#GUID-149CBDAE-C2DA-4D44-A1E4-30F31CD1E4C3" title="此处列出了与Oracle XML DB相关的限制。">Oracle XML DB限制</a></li>
                           </ul>
                        </div>
                        <div class="familylinks">
                           <div class="parentlink">
                              <p><strong>父主题：</strong> <a href="XML-Schema-and-query-object-relational-storage.html#GUID-4920BA1A-5769-49C6-870E-E3CA30F0016C" title="XML simpleType以各种方式映射到SQL对象类型，具体取决于simpleType的定义方式。">XML模式simpleType如何映射到SQL</a></p>
                           </div>
                        </div>
                     </div>
                     
                  </div><a id="ADXDB4542"></a><div class="props_rev_3"><a id="GUID-0F8F7480-56F4-4910-9FD6-8566A1F70BC6" name="GUID-0F8F7480-56F4-4910-9FD6-8566A1F70BC6"></a><h5 id="ADXDB-GUID-0F8F7480-56F4-4910-9FD6-8566A1F70BC6" class="sect5"><span class="enumeration_section">18.3.4.2</span> simpleType：XML字符串如何映射到SQL VARCHAR2与CLOB</h5>
                     <div>
                        <p>如果XML模式将数据类型指定为<code class="codeph">maxLength</code>小于4000的字符串，则将其映射到指定长度的<code class="codeph">VARCHAR2</code>对象属性。如果未在架构中指定<code class="codeph">maxLength</code> ，则XML架构数据类型只能映射到LOB。</p>
                        <p>当大多数字符串值很小并且只有一小部分字符串足够大以至于需要LOB时，这是次优的。</p>
                     </div>
                     <div>
                        <div class="infoboxnotealso" id="GUID-0F8F7480-56F4-4910-9FD6-8566A1F70BC6__GUID-0524D69D-BEFA-4092-8E7E-81DF86762A79">
                           <p class="notep1">也可以看看：</p>
                           <p><a href="XML-Schema-and-query-object-relational-storage.html#GUID-4920BA1A-5769-49C6-870E-E3CA30F0016C__CIHJFDGH" title="此表描述了XML字符串数据类型到SQL的映射。它包括默认映射。">表18-3</a></p>
                        </div>
                        <div class="familylinks">
                           <div class="parentlink">
                              <p><strong>父主题：</strong> <a href="XML-Schema-and-query-object-relational-storage.html#GUID-4920BA1A-5769-49C6-870E-E3CA30F0016C" title="XML simpleType以各种方式映射到SQL对象类型，具体取决于simpleType的定义方式。">XML模式simpleType如何映射到SQL</a></p>
                           </div>
                        </div>
                     </div>
                     
                  </div><a id="ADXDB4543"></a><div class="props_rev_3"><a id="GUID-F6855A35-3E83-4837-ABE9-320498CCC45B" name="GUID-F6855A35-3E83-4837-ABE9-320498CCC45B"></a><h5 id="ADXDB-GUID-F6855A35-3E83-4837-ABE9-320498CCC45B" class="sect5"><span class="enumeration_section">18.3.4.3</span> XML模式时区如何映射到SQL</h5>
                     <div>
                        <p>如果您的应用程序需要使用时区指示符，则使用属性<code class="codeph">SQLType</code>将SQL数据类型指定为<code class="codeph">TIMESTAMP WITH TIME ZONE</code> 。这可确保可以正确存储和检索包含时区指示符的值。
                        </p>
                        <p>以下XML Schema数据类型允许将可选的时区指示符作为其文字值的一部分：</p>
                        <ul style="list-style-type:disc">
                           <li>
                              <p><code class="codeph">XSD时间：DATETIME</code></p>
                           </li>
                           <li>
                              <p><code class="codeph">XSD：时间</code></p>
                           </li>
                           <li>
                              <p><code class="codeph">XSD：日期</code></p>
                           </li>
                           <li>
                              <p><code class="codeph">XSD：gYear的</code></p>
                           </li>
                           <li>
                              <p><code class="codeph">XSD：gMonth的</code></p>
                           </li>
                           <li>
                              <p><code class="codeph">XSD：GDAY</code></p>
                           </li>
                           <li>
                              <p><code class="codeph">XSD：gYearMonth的</code></p>
                           </li>
                           <li>
                              <p><code class="codeph">XSD：gMonthDay的</code></p>
                           </li>
                        </ul>
                        <p>默认情况下，XML模式注册将<code class="codeph">xsd:dateTime</code>和<code class="codeph">xsd:time</code>映射到SQL数据类型<code class="codeph">TIMESTAMP</code> ，并将所有其他日期类型映射到SQL数据类型<code class="codeph">DATE</code> 。</p>
                        <p>SQL数据类型<code class="codeph">TIMESTAMP</code>和<code class="codeph">DATE</code>不允许使用时区指示符。因此，如果您的应用程序需要时区信息，则必须使用属性<code class="codeph">SQLType</code>指定SQL数据类型<code class="codeph">TIMESTAMP WITH TIME ZONE</code> 。例如：</p><pre class="pre codeblock"><code>&lt;element name =“dob”type =“xsd：dateTime”xdb：SQLType =“ <span class="bold">TIMESTAMP WITH TIME ZONE</span> ”/&gt; &lt;attribute name =“endofquarter”type =“xsd：gMonthDay”xdb：SQLType =“ <span class="bold">TIMESTAMP WITH TIME ZONE</span> ” /&gt;</code></pre></div>
                     <div>
                        <ul class="ullinks">
                           <li class="ulchildlink"><a href="XML-Schema-and-query-object-relational-storage.html#GUID-E2EA0A87-F6F2-4512-9129-54DB1B714304">使用尾随Z表示UTC时区</a><br>您可以将XML架构时区组件指定为<code class="codeph">Z</code> ，以指示UTC时区。当具有尾随<code class="codeph">Z</code>值存储为SQL <code class="codeph">TIMESTAMP WITH TIME ZONE</code> ，时区实际存储为<code class="codeph">+00:00</code> 。检索到的值包含尾部<code class="codeph">+00:00</code>而不是原始<code class="codeph">Z</code></li>
                        </ul>
                        <div class="familylinks">
                           <div class="parentlink">
                              <p><strong>父主题：</strong> <a href="XML-Schema-and-query-object-relational-storage.html#GUID-4920BA1A-5769-49C6-870E-E3CA30F0016C" title="XML simpleType以各种方式映射到SQL对象类型，具体取决于simpleType的定义方式。">XML模式simpleType如何映射到SQL</a></p>
                           </div>
                        </div>
                     </div>
                     <a id="ADXDB4544"></a><div class="props_rev_3"><a id="GUID-E2EA0A87-F6F2-4512-9129-54DB1B714304" name="GUID-E2EA0A87-F6F2-4512-9129-54DB1B714304"></a><h6 id="ADXDB-GUID-E2EA0A87-F6F2-4512-9129-54DB1B714304" class="sect6"><span class="enumeration_section">18.3.4.3.1</span>使用尾随Z表示UTC时区</h6>
                        <div>
                           <p>您可以将XML架构时区组件指定为<code class="codeph">Z</code> ，以指示UTC时区。当具有尾随<code class="codeph">Z</code>值存储为SQL <code class="codeph">TIMESTAMP WITH TIME ZONE</code> ，时区实际存储为<code class="codeph">+00:00</code> 。检索到的值包含尾部<code class="codeph">+00:00</code>而不是原始<code class="codeph">Z</code></p>
                           <p>例如，如果输入XML文档中的值为<code class="codeph">1973-02-12T13:44:32</code> <span class="bold"><code class="codeph">Z</code></span>则输出为<code class="codeph">1973-02-12T13:44:32</code> <span class="bold"><code class="codeph">.000000+00:00</code></span> 。
                           </p>
                        </div>
                        <div>
                           <div class="familylinks">
                              <div class="parentlink">
                                 <p><strong>父主题：</strong> <a href="XML-Schema-and-query-object-relational-storage.html#GUID-F6855A35-3E83-4837-ABE9-320498CCC45B" title="如果您的应用程序需要使用时区指示符，则使用属性SQLType将SQL数据类型指定为TIMESTAMP WITH TIME ZONE。这可确保可以正确存储和检索包含时区指示符的值。">XML架构时区如何映射到SQL</a></p>
                              </div>
                           </div>
                        </div>
                        
                     </div>
                  </div>
               </div><a id="ADXDB4545"></a><div class="props_rev_3"><a id="GUID-EEE8E9EE-0397-4EE9-8496-DB20B1A82CC1" name="GUID-EEE8E9EE-0397-4EE9-8496-DB20B1A82CC1"></a><h4 id="ADXDB-GUID-EEE8E9EE-0397-4EE9-8496-DB20B1A82CC1" class="sect4"><span class="enumeration_section">18.3.5</span>如何将XML模式complexType映射到SQL</h4>
                  <div>
                     <p>XML <code class="codeph">complexType</code>以各种方式映射到SQL对象类型，具体取决于<code class="codeph">complexType</code>的定义方式。
                     </p>
                     <p>使用XML Schema， <code class="codeph">complexType</code>被映射到SQL对象类型，如下所示：</p>
                     <ul style="list-style-type:disc">
                        <li>
                           <p>在<code class="codeph">complexType</code>中声明的XML属性将映射到SQL对象属性。定义XML属性的<code class="codeph">simpleType</code>确定相应对象属性的SQL数据类型。
                           </p>
                        </li>
                        <li>
                           <p>在<code class="codeph">complexType</code>中声明的XML元素也映射到SQL对象属性。定义XML元素的<code class="codeph">simpleType</code>或<code class="codeph">complexType</code>确定相应对象属性的SQL数据类型。
                           </p>
                        </li>
                     </ul>
                     <p>如果使用属性<code class="codeph">maxOccurs</code> &gt; 1声明XML元素，则将其映射到SQL集合（对象）属性。该集合是一个varray值，它是一个有序集合表（OCT）。
                     </p>
                  </div>
                  <div>
                     <ul class="ullinks">
                        <li class="ulchildlink"><a href="XML-Schema-and-query-object-relational-storage.html#GUID-34E0393B-7055-4410-AA12-EC9B859211A0">complexType XML Schema声明中的属性规范</a><br>当元素基于全局<code class="codeph">complexType</code> ，必须为<code class="codeph">complexType</code>声明指定属性<code class="codeph">SQLType</code> 。您可以选择在元素声明中包含相同的<code class="codeph">SQLType</code>属性。
                        </li>
                     </ul>
                     <div class="familylinks">
                        <div class="parentlink">
                           <p><strong>父主题：</strong> <a href="XML-Schema-and-query-object-relational-storage.html#GUID-844D686D-D95A-4C5B-8624-71BABDBF1EF5" title="您可以使用PL / SQL包DBMS_XMLSCHEMA将XML Schema属性和元素的数据类型映射到SQL数据类型。">使用DBMS_XMLSCHEMA将XML模式数据类型映射到SQL数据类型</a></p>
                        </div>
                     </div>
                  </div>
                  <a id="ADXDB4546"></a><div class="props_rev_3"><a id="GUID-34E0393B-7055-4410-AA12-EC9B859211A0" name="GUID-34E0393B-7055-4410-AA12-EC9B859211A0"></a><h5 id="ADXDB-GUID-34E0393B-7055-4410-AA12-EC9B859211A0" class="sect5"><span class="enumeration_section">18.3.5.1</span> complexType XML模式声明中的属性规范</h5>
                     <div>
                        <p>当元素基于全局<code class="codeph">complexType</code> ，必须为<code class="codeph">complexType</code>声明指定属性<code class="codeph">SQLType</code> 。您可以选择在元素声明中包含相同的<code class="codeph">SQLType</code>属性。
                        </p>
                        <p>如果未为全局<code class="codeph">complexType</code>指定属性<code class="codeph">SQLType</code> ，则Oracle XML DB将使用内部生成的名称创建<code class="codeph">SQLType</code>属性。然后，引用此全局类型的元素<span class="italic">不能</span>具有<code class="codeph">SQLType</code>的不同值。以下代码是可以接受的：</p><pre class="pre codeblock"><code>&lt;xs：complexType name =“LineItemsType”xdb：SQLType =“LINEITEMS_T”&gt; &lt;xs：sequence&gt; &lt;xs：element name =“LineItem”type =“LineItemType”maxOccurs =“unbounded”xdb：SQLName =“LINEITEM”xdb： SQLCollType =“LINEITEM_V”/&gt; &lt;/ xs：sequence&gt; &lt;/ xs：complexType&gt; &lt;xs：complexType name =“LineItemType”xdb：SQLType =“LINEITEM_T”&gt; &lt;xs：sequence&gt; &lt;xs：element name =“Description” type =“DescriptionType”xdb：SQLName =“DESCRIPTION”/&gt; &lt;xs：element name =“Part”type =“PartType”xdb：SQLName =“PART”/&gt; &lt;/ xs：sequence&gt; &lt;xs：attribute name =“ ItemNumber“type =”xs：integer“xdb：SQLName =”ITEMNUMBER“xdb：SQLType =”NUMBER“/&gt; &lt;/ xs：complexType&gt; &lt;xs：complexType name =”PartType“xdb：SQLType =”PART_T“&gt; &lt;xs ：attribute name =“Id”xdb：SQLName =“PART_NUMBER”xdb：SQLType =“VARCHAR2”&gt; &lt;xs：simpleType&gt; &lt;xs：restriction base =“xs：string”&gt; &lt;xs：minLength value =“10”/&gt; &lt;xs：maxLength value =“14”/&gt; &lt;/ xs：restriction&gt; &lt;/ xs：simpleType&gt; &lt;/ xs：attribute&gt; &lt;xs：attribute name =“Quantity”type =“moneyType”xdb：SQLName =“QUANTITY” /&gt; &lt;xs：attribute name =“UnitPrice”type =“quantityType”xdb：SQLNa me =“UNITPRICE”/&gt; &lt;/ xs：complexType&gt;</code></pre></div>
                     <div>
                        <div class="familylinks">
                           <div class="parentlink">
                              <p><strong>父主题：</strong> <a href="XML-Schema-and-query-object-relational-storage.html#GUID-EEE8E9EE-0397-4EE9-8496-DB20B1A82CC1" title="XML complexType以各种方式映射到SQL对象类型，具体取决于complexType的定义方式。">XML模式complexType如何映射到SQL</a></p>
                           </div>
                        </div>
                     </div>
                     
                  </div>
               </div>
            </div><a id="ADXDB4639"></a><div class="props_rev_3"><a id="GUID-9E0CF72F-9E08-4CB8-ABBC-66F8ECEF949B" name="GUID-9E0CF72F-9E08-4CB8-ABBC-66F8ECEF949B"></a><h3 id="ADXDB-GUID-9E0CF72F-9E08-4CB8-ABBC-66F8ECEF949B" class="sect3"><span class="enumeration_section">18.4</span> Oracle XML DB中的complexType扩展和限制</h3>
               <div>
                  <p>在XML Schema中， <code class="codeph">complexType</code>值是基于<code class="codeph">complexContent</code>和<code class="codeph">simpleContent</code>声明的。Oracle XML DB定义了对<code class="codeph">complexType</code>各种扩展和限制。
                  </p>
                  <ul style="list-style-type:disc">
                     <li>
                        <p><code class="codeph">simpleContent</code>被声明为<code class="codeph">simpleType</code>的扩展。
                        </p>
                     </li>
                     <li>
                        <p><code class="codeph">complexContent</code>声明为以下之一：</p>
                        <ul style="list-style-type:disc">
                           <li>
                              <p>基础类型</p>
                           </li>
                           <li>
                              <p><code class="codeph">complexType</code>扩展</p>
                           </li>
                           <li>
                              <p><code class="codeph">complexType</code>限制</p>
                           </li>
                        </ul>
                     </li>
                  </ul>
               </div>
               <div>
                  <ul class="ullinks">
                     <li class="ulchildlink"><a href="XML-Schema-and-query-object-relational-storage.html#GUID-F1674D49-86AF-4B3E-9331-10C285DF1502">XML Schema中的complexType声明：处理继承</a><br>对于<code class="codeph">complexType</code> ，Oracle XML DB处理XML模式中的继承对于扩展类型和限制其他复杂类型的类型的处理方式不同</li>
                     <li class="ulchildlink"><a href="XML-Schema-and-query-object-relational-storage.html#GUID-D7A801E3-9051-4203-9BD1-F2385E20609C">如何将基于simpleContent的complexType映射到对象类型</a><br>基于<code class="codeph">simpleContent</code>声明的复杂类型映射到具有与XML属性对应的属性的对象类型和与body值对应的额外<code class="codeph">SYS_XDBBODY$</code>属性。body属性的数据类型基于定义主体类型的<code class="codeph">simpleType</code> 。
                     </li>
                     <li class="ulchildlink"><a href="XML-Schema-and-query-object-relational-storage.html#GUID-9A48AE16-7F55-4376-8DE1-CEF04BC2000E">any和anyAttribute声明如何映射到对象类型属性</a><br>Oracle XML DB将元素声明<code class="codeph">any</code>和属性声明<code class="codeph">anyAttribute</code>映射到<code class="codeph">VARCHAR2</code>属性，或者可选地映射到创建的对象类型中的大对象（LOB）。object属性存储与<code class="codeph">any</code>声明匹配的XML片段的文本。
                     </li>
                  </ul>
                  <div class="familylinks">
                     <div class="parentlink">
                        <p><strong>父主题：</strong> <a href="XML-Schema-and-query-object-relational-storage.html#GUID-B0C1A0B0-2DD1-491A-8CE1-1F857FD267B7" title="基于XML Schema的数据的高级技术包括使用对象关系存储;注释XML模式;将Schema数据类型映射到SQL;使用complexType扩展和限制;创建，指定关系约束，分区基于XML Schema的数据，存储XMLType数据，使用复杂或大型模式，以及调试模式注册。">XML模式存储和查询：对象关系存储</a></p>
                     </div>
                  </div>
               </div>
               <a id="ADXDB4641"></a><a id="ADXDB4642"></a><a id="ADXDB4640"></a><div class="props_rev_3"><a id="GUID-F1674D49-86AF-4B3E-9331-10C285DF1502" name="GUID-F1674D49-86AF-4B3E-9331-10C285DF1502"></a><h4 id="ADXDB-GUID-F1674D49-86AF-4B3E-9331-10C285DF1502" class="sect4"><span class="enumeration_section">18.4.1</span> XML Schema中的complexType声明：处理继承</h4>
                  <div>
                     <p>对于<code class="codeph">complexType</code> ，Oracle XML DB处理XML模式中的继承对于扩展类型和限制其他复杂类型的类型的处理方式不同</p>
                     <ul style="list-style-type:disc">
                        <li>
                           <p>对于声明为<span class="italic">扩展</span>其他复杂类型的复杂类型，与基类型对应的SQL类型被指定为当前SQL类型的超类型。只有子复杂类型中声明的附加属性和元素才会作为属性添加到子对象类型中。
                           </p>
                        </li>
                        <li>
                           <p>对于声明<span class="italic">限制</span>其他复杂类型的复杂类型，子复杂类型的SQL类型设置为与其基类型的SQL类型相同。这是因为SQL不支持通过继承机制限制对象类型。XML模式中的限制强加了任何约束。
                           </p>
                        </li>
                     </ul>
                     <p><a href="XML-Schema-and-query-object-relational-storage.html#GUID-F1674D49-86AF-4B3E-9331-10C285DF1502__BHABGCDF">例18-9</a>显示了XML模式的注册，该模式定义了基本<code class="codeph">complexType</code> <code class="codeph">Address</code>和两个扩展名<code class="codeph">USAddress</code>和<code class="codeph">IntlAddress</code> 。
                     </p>
                     <div class="infoboxnote" id="GUID-F1674D49-86AF-4B3E-9331-10C285DF1502__GUID-0FF85054-0239-466C-AC59-5C44F50A5510">
                        <p class="notep1">注意：</p>
                        <p>类型<code class="codeph">intladdr_t</code>创建为<span class="italic">最终</span>类型，因为相应的<code class="codeph">complexType</code>指定“ <code class="codeph">final</code> ”属性。默认情况下，所有<code class="codeph">complexTypes</code>都可以通过其他类型进行扩展和限制，因此所有SQL对象类型都将创建<span class="italic">为非</span> final类型。
                        </p>
                     </div><pre class="oac_no_warn" dir="ltr">CREATE TYPE addr_t AS OBJECT（SYS_XDBPD $ XDB.XDB $ RAW_LIST_T，“street”VARCHAR2（4000），“city”VARCHAR2（4000））NOT FINAL; CREATE TYPE usaddr_t UNDER addr_t（“zip”VARCHAR2（4000））NOT FINAL; CREATE TYPE intladdr_t UNDER addr_t（“country”VARCHAR2（4000））FINAL;</pre><p><a href="XML-Schema-and-query-object-relational-storage.html#GUID-F1674D49-86AF-4B3E-9331-10C285DF1502__BHAHEIHC">例18-10</a>显示了定义基本<code class="codeph">complexType</code> <code class="codeph">Address</code>的XML模式的注册以及禁止指定<code class="codeph">country</code>属性的受限类型<code class="codeph">LocalAddress</code> 。
                     </p>
                     <p>由于SQL继承不支持限制概念，因此对应于受限<code class="codeph">complexType</code>的SQL数据类型是父对象类型的空子类型。对于<a href="XML-Schema-and-query-object-relational-storage.html#GUID-F1674D49-86AF-4B3E-9331-10C285DF1502__BHAHEIHC">示例18-10</a>的XML模式，Oracle XML DB生成以下SQL类型：</p><pre class="pre codeblock"><code>CREATE TYPE addr_t AS OBJECT（SYS_XDBPD $ XDB.XDB $ RAW_LIST_T，“street”VARCHAR2（4000），“city”VARCHAR2（4000），“zip”VARCHAR2（4000），“country”VARCHAR2（4000））NOT FINAL; CREATE TYPE usaddr_t UNDER addr_t;</code></pre><div class="example" id="GUID-F1674D49-86AF-4B3E-9331-10C285DF1502__BHABGCDF">
                        <p class="titleinexample">示例18-9 XML模式继承：complexContent作为complexTypes的扩展</p><pre class="pre codeblock"><code>DECLARE doc VARCHAR2（3000）：='&lt;xs：schema xmlns：xs =“http://www.w3.org/2001/XMLSchema”xmlns：xdb =“http://xmlns.oracle.com/xdb”&gt; &lt;xs：complexType name =“Address”xdb：SQLType =“ADDR_T”&gt; &lt;xs：sequence&gt; &lt;xs：element name =“street”type =“xs：string”/&gt; &lt;xs：element name =“city”type =“xs：string”/&gt; &lt;/ xs：sequence&gt; &lt;/ xs：complexType&gt; &lt;xs：complexType name =“USAddress”xdb：SQLType =“USADDR_T”&gt; &lt;xs：complexContent&gt; &lt;xs：extension base =“Address “&gt; &lt;xs：sequence&gt; &lt;xs：element name =”zip“type =”xs：string“/&gt; &lt;/ xs：sequence&gt; &lt;/ xs：extension&gt; &lt;/ xs：complexContent&gt; &lt;/ xs：complexType&gt; &lt; xs：complexType name =“IntlAddress”final =“＃all”xdb：SQLType =“INTLADDR_T”&gt; &lt;xs：complexContent&gt; &lt;xs：extension base =“Address”&gt; &lt;xs：sequence&gt; &lt;xs：element name =“country “type =”xs：string“/&gt; &lt;/ xs：sequence&gt; &lt;/ xs：extension&gt; &lt;/ xs：complexContent&gt; &lt;/ xs：complexType&gt; &lt;/ xs：schema&gt;'; BEGIN DBMS_XMLSCHEMA.registerSchema（SCHEMAURL =&gt;'http：//www.oracle.com/PO.xsd'，SCHAMEDOC =&gt; doc）;结束;</code></pre></div>
                     <!-- class="example" -->
                     <div class="example" id="GUID-F1674D49-86AF-4B3E-9331-10C285DF1502__BHAHEIHC">
                        <p class="titleinexample">示例18-10 XML架构中的继承：complexTypes中的限制</p><pre class="pre codeblock"><code>DECLARE doc varchar2（3000）：='&lt;xs：schema xmlns：xs =“http://www.w3.org/2001/XMLSchema”xmlns：xdb =“http://xmlns.oracle.com/xdb”&gt; &lt;xs：complexType name =“Address”xdb：SQLType =“ADDR_T”&gt; &lt;xs：sequence&gt; &lt;xs：element name =“street”type =“xs：string”/&gt; &lt;xs：element name =“city”type =“xs：string”/&gt; &lt;xs：element name =“zip”type =“xs：string”/&gt; &lt;xs：element name =“country”type =“xs：string”minOccurs =“0”maxOccurs =“ 1“/&gt; &lt;/ xs：sequence&gt; &lt;/ xs：complexType&gt; &lt;xs：complexType name =”LocalAddress“xdb：SQLType =”USADDR_T“&gt; &lt;xs：complexContent&gt; &lt;xs：restriction base =”Address“&gt; &lt;xs ：sequence&gt; &lt;xs：element name =“street”type =“xs：string”/&gt; &lt;xs：element name =“city”type =“xs：string”/&gt; &lt;xs：element name =“zip”type = “xs：string”/&gt; &lt;xs：element name =“country”type =“xs：string”minOccurs =“0”maxOccurs =“0”/&gt; &lt;/ xs：sequence&gt; &lt;/ xs：restriction&gt; &lt;/ xs ：complexContent&gt; &lt;/ xs：complexType&gt; &lt;/ xs：schema&gt;'; BEGIN DBMS_XMLSCHEMA.registerSchema（SCHEMAURL =&gt;'http://www.oracle.com/PO.xsd'，SCHEMADOC =&gt; doc）;结束;</code></pre></div>
                     <!-- class="example" -->
                  </div>
                  <div>
                     <div class="familylinks">
                        <div class="parentlink">
                           <p><strong>父主题：</strong> <a href="XML-Schema-and-query-object-relational-storage.html#GUID-9E0CF72F-9E08-4CB8-ABBC-66F8ECEF949B" title="在XML Schema中，complexType值是基于complexContent和simpleContent声明的。Oracle XML DB定义了对complexType的各种扩展和限制。">Oracle XML DB中的complexType扩展和限制</a></p>
                        </div>
                     </div>
                  </div>
                  
               </div><a id="ADXDB4644"></a><a id="ADXDB4643"></a><div class="props_rev_3"><a id="GUID-D7A801E3-9051-4203-9BD1-F2385E20609C" name="GUID-D7A801E3-9051-4203-9BD1-F2385E20609C"></a><h4 id="ADXDB-GUID-D7A801E3-9051-4203-9BD1-F2385E20609C" class="sect4"><span class="enumeration_section">18.4.2</span>如何将基于simpleContent的complexType映射到对象类型</h4>
                  <div>
                     <p>基于<code class="codeph">simpleContent</code>声明的复杂类型映射到具有与XML属性对应的属性的对象类型和与body值对应的额外<code class="codeph">SYS_XDBBODY$</code>属性。body属性的数据类型基于定义主体类型的<code class="codeph">simpleType</code> 。
                     </p>
                     <p>对于<a href="XML-Schema-and-query-object-relational-storage.html#GUID-D7A801E3-9051-4203-9BD1-F2385E20609C__BHAFGHGJ">示例18-11</a>的XML模式，Oracle XML DB生成以下类型：</p><pre class="pre codeblock"><code>CREATE TYPE obj_t AS OBJECT（SYS_XDBPD $ XDB.XDB $ RAW_LIST_T，SYS_XDBBODY $ VARCHAR2（4000））;</code></pre><div class="example" id="GUID-D7A801E3-9051-4203-9BD1-F2385E20609C__BHAFGHGJ">
                        <p class="titleinexample">示例18-11 XML Schema complexType：将complexType映射到simpleContent</p><pre class="pre codeblock"><code>DECLARE doc VARCHAR2（3000）：='&lt;schema xmlns =“http://www.w3.org/2001/XMLSchema”targetNamespace =“http://www.oracle.com/emp.xsd”xmlns：emp =“ http://www.oracle.com/emp.xsd“xmlns：xdb =”http://xmlns.oracle.com/xdb“&gt; &lt;complexType name =”name“xdb：SQLType =”OBJ_T“&gt; &lt;simpleContent&gt; &lt;restriction base =“string”&gt; &lt;/ restriction&gt; &lt;/ simpleContent&gt; &lt;/ complexType&gt; &lt;/ schema&gt;'; BEGIN DBMS_XMLSCHEMA.registerSchema（SCHEMAURL =&gt;'http://www.oracle.com/emp.xsd'，SCHEMADOC =&gt; doc）;结束;</code></pre></div>
                     <!-- class="example" -->
                  </div>
                  <div>
                     <div class="familylinks">
                        <div class="parentlink">
                           <p><strong>父主题：</strong> <a href="XML-Schema-and-query-object-relational-storage.html#GUID-9E0CF72F-9E08-4CB8-ABBC-66F8ECEF949B" title="在XML Schema中，complexType值是基于complexContent和simpleContent声明的。Oracle XML DB定义了对complexType的各种扩展和限制。">Oracle XML DB中的complexType扩展和限制</a></p>
                        </div>
                     </div>
                  </div>
                  
               </div><a id="ADXDB4646"></a><a id="ADXDB4645"></a><div class="props_rev_3"><a id="GUID-9A48AE16-7F55-4376-8DE1-CEF04BC2000E" name="GUID-9A48AE16-7F55-4376-8DE1-CEF04BC2000E"></a><h4 id="ADXDB-GUID-9A48AE16-7F55-4376-8DE1-CEF04BC2000E" class="sect4"><span class="enumeration_section">18.4.3</span>如何将任何和任何属性声明映射到对象类型属性</h4>
                  <div>
                     <p>Oracle XML DB将元素声明<code class="codeph">any</code>和属性声明<code class="codeph">anyAttribute</code>映射到<code class="codeph">VARCHAR2</code>属性，或者可选地映射到创建的对象类型中的大对象（LOB）。object属性存储与<code class="codeph">any</code>声明匹配的XML片段的文本。
                     </p>
                     <ul style="list-style-type:disc">
                        <li>
                           <p><code class="codeph">namespace</code>属性可用于限制内容，以便它们属于指定的命名空间。
                           </p>
                        </li>
                        <li>
                           <p><code class="codeph">any</code>元素声明中的<code class="codeph">processContents</code>属性指示与<code class="codeph">any</code>声明匹配的内容所需的验证级别。
                           </p>
                        </li>
                     </ul>
                     <div class="infoboxnote" id="GUID-9A48AE16-7F55-4376-8DE1-CEF04BC2000E__GUID-2DE4011B-BFD5-420E-B13E-8B05FA6016E8">
                        <p class="notep1">注意：</p>从Oracle Database 12c第2版（12.2.0.1）开始，当多租户容器数据库（CDB）的公共用户或应用程序通用用户为对象关系<code class="codeph">XMLType</code>存储注册XML模式时，必须注释复杂类型使用<code class="codeph">xdb:SQLType</code>指定要使用的相应SQL类型。否则，会引发错误。
                     </div>
                     <p><a href="XML-Schema-and-query-object-relational-storage.html#GUID-9A48AE16-7F55-4376-8DE1-CEF04BC2000E__BHACFACC">例18-12中</a>的代码声明了一个<code class="codeph">any</code>元素，并将其映射到对象类型<code class="codeph">obj_t</code> <code class="codeph">SYS_XDBANY$</code>列。它还声明属性<code class="codeph">processContents</code>不验证与<code class="codeph">any</code>声明匹配的内容。
                     </p>
                     <p>对于<a href="XML-Schema-and-query-object-relational-storage.html#GUID-9A48AE16-7F55-4376-8DE1-CEF04BC2000E__BHACFACC">示例18-12</a>的XML模式，Oracle XML DB生成以下类型：</p><pre class="pre codeblock"><code>CREATE TYPE obj_t AS OBJECT（SYS_XDBPD $ XDB.XDB $ RAW_LIST_T，Name VARCHAR2（4000），Age NUMBER，SYS_XDBANY $ VARCHAR2（4000））;</code></pre><div class="example" id="GUID-9A48AE16-7F55-4376-8DE1-CEF04BC2000E__BHACFACC">
                        <p class="titleinexample">示例18-12 XML模式：将complexType映射到any / anyAttribute</p><pre class="pre codeblock"><code>DECLARE doc VARCHAR2（3000）：='&lt;schema xmlns =“http://www.w3.org/2001/XMLSchema”targetNamespace =“http://www.oracle.com/any.xsd”xmlns：emp =“ http://www.oracle.com/any.xsd“xmlns：xdb =”http://xmlns.oracle.com/xdb“&gt; &lt;complexType name =”Employee“xdb：SQLType =”OBJ_T“&gt; &lt;sequence&gt; &lt;element name =“Name”type =“string”/&gt; &lt;element name =“Age”type =“decimal”/&gt; &lt; <span class="bold">any</span> namespace =“http：//www/w3.org/2001/xhtml" <span class="bold">processContents =”跳过“</span> /&gt; &lt;/ sequence&gt; &lt;/ complexType&gt; &lt;/ schema&gt;'; BEGIN DBMS_XMLSCHEMA.registerSchema（SCHEMAURL =&gt;'http://www.oracle.com/emp.xsd'，SCHEMADOC =&gt; doc）;结束;</code></pre></div>
                     <!-- class="example" -->
                  </div>
                  <div>
                     <div class="familylinks">
                        <div class="parentlink">
                           <p><strong>父主题：</strong> <a href="XML-Schema-and-query-object-relational-storage.html#GUID-9E0CF72F-9E08-4CB8-ABBC-66F8ECEF949B" title="在XML Schema中，complexType值是基于complexContent和simpleContent声明的。Oracle XML DB定义了对complexType的各种扩展和限制。">Oracle XML DB中的complexType扩展和限制</a></p>
                        </div>
                     </div>
                  </div>
                  
               </div>
            </div><a id="ADXDB6318"></a><a id="ADXDB6319"></a><a id="ADXDB6320"></a><a id="ADXDB6317"></a><div class="props_rev_3"><a id="GUID-7A85260C-44C1-4DEF-A000-6A66B24F1B71" name="GUID-7A85260C-44C1-4DEF-A000-6A66B24F1B71"></a><h3 id="ADXDB-GUID-7A85260C-44C1-4DEF-A000-6A66B24F1B71" class="sect3"><span class="enumeration_section">18.5</span>创建基于XML模式的XMLType列和表</h3>
               <div>
                  <p>在向Oracle XML DB注册XML模式后，可以在定义<code class="codeph">XMLType</code>表或列时引用它。
                  </p>
                  <div class="section">
                     <p>如果在为基于XML模式的数据创建<code class="codeph">XMLType</code>表或列时未指定存储模型，则使用的存储模型是在注册引用的XML模式期间指定的模型。如果没有为XML模式注册指定存储模型，则使用<span class="italic">对象关系</span>存储。
                     </p>
                     <p><a href="XML-Schema-and-query-object-relational-storage.html#GUID-7A85260C-44C1-4DEF-A000-6A66B24F1B71__CEGIEAHJ">例18-13</a>显示了如何手动创建table <code class="codeph">purchaseorder</code> ，这是<code class="codeph">PurchaseOrder</code>元素的默认表。
                     </p>
                     <p>在<code class="codeph">CREATE TABLE</code>的语句<a href="XML-Schema-and-query-object-relational-storage.html#GUID-7A85260C-44C1-4DEF-A000-6A66B24F1B71__CEGIEAHJ">实施例18-13</a>等效于<code class="codeph">CREATE TABLE</code>即当设置参数由Oracle XML DB自动生成的语句<code class="codeph">GENTABLES</code>到<code class="codeph">TRUE</code>的XML模式注册期间。
                     </p>
                     <p>引用<a href="XML-Schema-and-query-object-relational-storage.html#GUID-7A85260C-44C1-4DEF-A000-6A66B24F1B71__CEGIEAHJ">示例18-13</a>的XML模式指定table <code class="codeph">purchaseorder</code>是<code class="codeph">PurchaseOrder</code>元素的默认表。当使用协议或PL / SQL将符合XML模式的XML文档插入Oracle XML DB存储库时，文档的内容将作为一行存储在表<code class="codeph">purchaseorder</code> 。
                     </p>
                     <p>将XML模式注册为<span class="italic">全局</span>模式时，必须先将默认表上的相应访问权限授予数据库的所有其他用户，然后才能使用符合全局注册的XML模式的实例文档。
                     </p>
                     <p>管理<code class="codeph">Action</code>元素集合的varray的每个成员都存储在有序集合表<code class="codeph">action_table</code> 。管理<code class="codeph">LineItem</code>元素集合的varray的每个成员都存储在有序集合表<code class="codeph">lineitem_table</code>的一行中。有序集合表是基于堆的。由于<code class="codeph">PRIMARY KEY</code>规范，它们自动包含伪列<code class="codeph">NESTED_TABLE_ID</code>和列<code class="codeph">SYS_NC_ARRAY_INDEX$</code> ，这些是将它们链接回父列所必需的。
                     </p>
                     <p>XML模式注册自动为集合生成有序集合表（OCT）。这些OCT被赋予系统生成的名称，这些名称很难处理。您可以使用SQL语句<code class="codeph">RENAME TABLE</code>为它们提供更有意义的名称。</p>
                     <p><a href="XML-Schema-and-query-object-relational-storage.html#GUID-7A85260C-44C1-4DEF-A000-6A66B24F1B71__CEGIEAHJ">示例18-13中</a>的<code class="codeph">CREATE TABLE</code>语句对应于具有单级嵌套的采购订单文档：管理<code class="codeph">LineItem</code>元素集合的varray是有序集合表<code class="codeph">lineitem_table</code> 。
                     </p>
                     <p>如果你有一个不同的XML模式，例如， <code class="codeph">Shipment</code>元素中的<code class="codeph">Shipments</code>元素集合又是一个<code class="codeph">LineItem</code>元素，那该怎么办？在这种情况下，您可以手动创建表，如<a href="XML-Schema-and-query-object-relational-storage.html#GUID-7A85260C-44C1-4DEF-A000-6A66B24F1B71__CEGEFCIG">例18-14</a>所示。
                     </p>
                     <p>SQL * Plus <code class="codeph">DESCRIBE</code>语句可用于查看有关<code class="codeph">XMLType</code>表的信息，如<a href="XML-Schema-and-query-object-relational-storage.html#GUID-7A85260C-44C1-4DEF-A000-6A66B24F1B71__CEGCEAAF">例18-15</a>所示。
                     </p>
                     <p><a href="XML-Schema-and-query-object-relational-storage.html#GUID-7A85260C-44C1-4DEF-A000-6A66B24F1B71__CEGCEAAF">示例18-15</a>的<code class="codeph">DESCRIBE</code>语句的输出显示有关表<code class="codeph">purchaseorder</code>的以下信息：</p>
                  </div>
                  <!-- class="section" -->
                  <div class="section">
                     <ul style="list-style-type:disc">
                        <li>
                           <p>该表是<code class="codeph">XMLType</code>表</p>
                        </li>
                        <li>
                           <p>该表被限制为存储<code class="codeph">PurchaseOrder</code>文件由所限定<code class="codeph">PurchaseOrder</code> XML模式</p>
                        </li>
                        <li>
                           <p>此表中的行存储为数据库中的一组对象</p>
                        </li>
                        <li>
                           <p>SQL类型<code class="codeph">purchaseorder_t</code>是此表的基础对象</p>
                        </li>
                     </ul>
                  </div>
                  <!-- class="section" -->
                  <div class="section"></div>
                  <!-- class="section" -->
                  <div class="example" id="GUID-7A85260C-44C1-4DEF-A000-6A66B24F1B71__CEGIEAHJ">
                     <p class="titleinexample">示例18-13创建符合XML模式的XMLType表</p><pre class="pre codeblock"><code>CREATE TABLE <span class="bold">purchaseorder</span> OF XMLType XMLSCHEMA“http：// localhost：8080 / source / schemas / poSource / xsd / <span class="bold">purchaseOrder.xsd</span> ”ELEMENT“ <span class="bold">PurchaseOrder</span> ”VARRAY“XMLDATA”。“ <span class="bold">ACTIONS</span> ”。“ACTION”STORE AS TABLE <span class="bold">action_table</span> （（PRIMARY） KEY（ <span class="bold">NESTED_TABLE_ID</span> ， <span class="bold">SYS_NC_ARRAY_INDEX $</span> ）））VARRAY“XMLDATA”。“LINEITEMS”。“LINEITEM”STORE AS TABLE <span class="bold">lineitem_table</span> （（PRIMARY KEY（ <span class="bold">NESTED_TABLE_ID</span> ， <span class="bold">SYS_NC_ARRAY_INDEX $</span> ）））;</code></pre></div>
                  <!-- class="example" -->
                  <div class="example" id="GUID-7A85260C-44C1-4DEF-A000-6A66B24F1B71__CEGEFCIG">
                     <p class="titleinexample">示例18-14为嵌套集合创建XMLType表</p><pre class="pre codeblock"><code>CREATE TABLE purchaseorder OF XMLType XMLSCHEMA“http：// localhost：8080 / source / schemas / poSource / xsd / purchaseOrder.xsd”ELEMENT“PurchaseOrder”VARRAY“XMLDATA”。“ACTIONS”。“ACTION”STORE AS TABLE action_table（（PRIMARY） KEY（NESTED_TABLE_ID，SYS_NC_ARRAY_INDEX $））） <span class="bold">VARRAY“XMLDATA”。“LINEITEMS”。“LINEITEM”</span>存储为表<span class="bold">lineitem_table</span> （（PRIMARY KEY（NESTED_TABLE_ID，SYS_NC_ARRAY_INDEX $）） <span class="bold">VARRAY“SHIPMENTS”。“SHIPMENT”</span> STORE AS TABLE <span class="bold">shipment_table</span> （（ PRIMARY KEY（NESTED_TABLE_ID，SYS_NC_ARRAY_INDEX $））））;</code></pre></div>
                  <!-- class="example" -->
                  <div class="example" id="GUID-7A85260C-44C1-4DEF-A000-6A66B24F1B71__CEGCEAAF">
                     <p class="titleinexample">示例18-15将DESCRIBE与基于XML模式的XMLType表一起使用</p><pre class="oac_no_warn" dir="ltr">DESCRIBE purchaseorder名称是否空？输入----------------------------------------- -------- ---------------------------- SYS.XMLTYPE的表（XMLSchema“http：// localhost：8080 / source / schemas / poSource / xsd / purchaseOrder.xsd“Element”PurchaseOrder“）STORAGE对象关系类型”PURCHASEORDER_T“</pre></div>
                  <!-- class="example" -->
               </div>
               <div>
                  <div class="relinfo">
                     <p><strong>相关话题</strong></p>
                     <ul>
                        <li><a href="XML-Schema-and-query-basic.html#GUID-5663C810-F20E-4CFE-99D5-96AC7D4081F4" title="XML模式可以注册为本地（默认情况下仅对其所有者可见）或全局（默认情况下对所有数据库用户可见）。">本地和全局XML模式</a></li>
                     </ul>
                  </div>
                  <div class="familylinks">
                     <div class="parentlink">
                        <p><strong>父主题：</strong> <a href="XML-Schema-and-query-object-relational-storage.html#GUID-B0C1A0B0-2DD1-491A-8CE1-1F857FD267B7" title="基于XML Schema的数据的高级技术包括使用对象关系存储;注释XML模式;将Schema数据类型映射到SQL;使用complexType扩展和限制;创建，指定关系约束，分区基于XML Schema的数据，存储XMLType数据，使用复杂或大型模式，以及调试模式注册。">XML模式存储和查询：对象关系存储</a></p>
                     </div>
                  </div>
               </div>
               
            </div><a id="ADXDB0730"></a><div class="props_rev_3"><a id="GUID-8713E2AD-0D5F-4076-A2DE-BB0ECEFBFEA8" name="GUID-8713E2AD-0D5F-4076-A2DE-BB0ECEFBFEA8"></a><h3 id="ADXDB-GUID-8713E2AD-0D5F-4076-A2DE-BB0ECEFBFEA8" class="sect3"><span class="enumeration_section">18.6</span>分区存储对象 - 关系的XMLType表和列的概述</h3>
               <div>
                  <p>使用对象关系存储的<code class="codeph">XMLType</code>列对对象关系<code class="codeph">XMLType</code>表或表进行分区时，使用列表，范围或散列分区，数据中的任何有序集合表（OCT）或外联表默认情况下会相应地自动分区。
                  </p>
                  <p>这种均<strong class="term">分化</strong>意味着OCT或外线表的分区遵循其父（基）表的分区方案。基表的每个分区都有一个相应的子表分区。子元素存储在子表分区中，该子分区对应于其父元素的基表分区。
                  </p>
                  <p>默认情况下，基表分区的存储属性也用于相应的子表分区。您可以覆盖给定子表分区的这些存储属性。</p>
                  <p>同样，默认情况下，OCT分区的名称与其基本（父）表的名称相同，但您可以通过指定要使用的名称来覆盖此行为。外联表分区的名称始终与其父表的分区（可以是基表或OCT）相同。</p>
                  <div class="infoboxnote" id="GUID-8713E2AD-0D5F-4076-A2DE-BB0ECEFBFEA8__GUID-930891E9-0479-40B1-9781-490BED9F80D8">
                     <p class="notep1">注意：</p>
                     <ul style="list-style-type:disc">
                        <li>
                           <p>Oracle Database 11g第1版（11.1）之前的版本中不提供以对象关系存储的<code class="codeph">XMLType</code>数据的分区。
                           </p>
                        </li>
                        <li>
                           <p>在Oracle Database 11g第2版（11.2.0.2）之前的版本中，不能对在线存储的<code class="codeph">XMLType</code>数据进行分级。从该版本开始，不共享外联表：如果该模式指定了一个外联表，则无法创建两个基于相同XML模式的顶级表。
                           </p>
                        </li>
                     </ul>
                     <p>您可以通过在<code class="codeph">CREATE TABLE</code>语句中指定关键字<code class="codeph">GLOBAL</code>来阻止OCT的分区。（从Oracle Database 11g第1版（11.1）开始，默认行为使用关键字<code class="codeph">LOCAL</code> ）。有关将非分区收集表转换为分区收集表的信息，请参阅“ <a href="../vldbg/evolve-nopartition-table.html#VLDBG00302" target="_blank"><span><cite>Oracle数据库VLDB和分区指南”</cite></span></a> 。
                     </p>
                     <p>您可以通过启用级别0x200的事件31178来阻止对外联表进行分区，从而允许外部共享：</p><pre class="oac_no_warn" dir="ltr">ALTER SESSION SET EVENTS'31178 TRACE NAME CONTEXT FOREVER，LEVEL 0x200'</pre></div>
               </div>
               <div>
                  <ul class="ullinks">
                     <li class="ulchildlink"><a href="XML-Schema-and-query-object-relational-storage.html#GUID-99B0AD73-F9C4-490B-BDDD-E52492E2CD64">分区XMLType数据存储对象关系的示例</a><br>您可以在XML模式注册或表创建期间为对象关系<code class="codeph">XMLType</code>基表指定分区信息。这里举例说明了这一点
                     </li>
                     <li class="ulchildlink"><a href="XML-Schema-and-query-object-relational-storage.html#GUID-969A9AAC-8531-48FC-8EB3-67E31EC5ED35">XMLType数据的分区维护存储对象 - 关系</a><br>您无需手动定义或维护子表分区。在基本（父）表上执行分区维护时，也会自动对子表执行相应的维护。
                     </li>
                  </ul>
                  <div class="infoboxnotealso" id="GUID-8713E2AD-0D5F-4076-A2DE-BB0ECEFBFEA8__GUID-A36EF1E8-B614-48E8-B450-BA2652E97C8A">
                     <p class="notep1">也可以看看：</p>
                     <p>有关使用关键字<code class="codeph">GLOBAL</code>和<code class="codeph">LOCAL</code>创建包含分区的表的信息，请<a href="../sqlrf/CREATE-TABLE.html#SQLRF01402" target="_blank"><span><cite>参见Oracle数据库SQL语言参考</cite></span></a></p>
                  </div>
                  <div class="familylinks">
                     <div class="parentlink">
                        <p><strong>父主题：</strong> <a href="XML-Schema-and-query-object-relational-storage.html#GUID-B0C1A0B0-2DD1-491A-8CE1-1F857FD267B7" title="基于XML Schema的数据的高级技术包括使用对象关系存储;注释XML模式;将Schema数据类型映射到SQL;使用complexType扩展和限制;创建，指定关系约束，分区基于XML Schema的数据，存储XMLType数据，使用复杂或大型模式，以及调试模式注册。">XML模式存储和查询：对象关系存储</a></p>
                     </div>
                  </div>
               </div>
               <a id="ADXDB4631"></a><a id="ADXDB4632"></a><a id="ADXDB4630"></a><div class="props_rev_3"><a id="GUID-99B0AD73-F9C4-490B-BDDD-E52492E2CD64" name="GUID-99B0AD73-F9C4-490B-BDDD-E52492E2CD64"></a><h4 id="ADXDB-GUID-99B0AD73-F9C4-490B-BDDD-E52492E2CD64" class="sect4"><span class="enumeration_section">18.6.1</span>分区XMLType数据存储对象关系的示例</h4>
                  <div>
                     <p>您可以在XML模式注册或表创建期间为对象关系<code class="codeph">XMLType</code>基表指定分区信息。这里举例说明了这一点
                     </p>
                     <div class="section">
                        <ul style="list-style-type:disc">
                           <li>
                              <p>在XML模式注册期间，使用XML Schema注释<code class="codeph">xdb:tableProps</code></p>
                           </li>
                           <li>
                              <p>在使用<code class="codeph">CREATE TABLE</code></p>
                           </li>
                        </ul>
                        <p><a href="XML-Schema-and-query-object-relational-storage.html#GUID-99B0AD73-F9C4-490B-BDDD-E52492E2CD64__BHADGCEG">例18-16</a>和<a href="XML-Schema-and-query-object-relational-storage.html#GUID-99B0AD73-F9C4-490B-BDDD-E52492E2CD64__BHABFFHC">例18-17</a>说明了这一点。这两个例子具有完全相同的效果。他们使用<code class="codeph">Reference</code>元素对base <code class="codeph">purchaseorder</code>表进行分区以指定范围。他们将行项目的子表与基表相对应。
                        </p>
                        <p><a href="XML-Schema-and-query-object-relational-storage.html#GUID-99B0AD73-F9C4-490B-BDDD-E52492E2CD64__BHADGCEG">示例18-16</a>显示了采购订单XML架构中的元素<code class="codeph">PurchaseOrder</code> ，注释为对基表及其子项的子表进行分区。
                        </p>
                        <p><a href="XML-Schema-and-query-object-relational-storage.html#GUID-99B0AD73-F9C4-490B-BDDD-E52492E2CD64__BHABFFHC">例18-17</a>指定了与<a href="XML-Schema-and-query-object-relational-storage.html#GUID-99B0AD73-F9C4-490B-BDDD-E52492E2CD64__BHADGCEG">例18-16中</a>相同的分区，但它在创建基表<code class="codeph">purchaseorder</code>期间执行了此操作。
                        </p>
                        <p><a href="XML-Schema-and-query-object-relational-storage.html#GUID-99B0AD73-F9C4-490B-BDDD-E52492E2CD64__BHADGCEG">例18-16</a>和<a href="XML-Schema-and-query-object-relational-storage.html#GUID-99B0AD73-F9C4-490B-BDDD-E52492E2CD64__BHABFFHC">例18-17</a>还显示了如何为各个子表分区指定对象存储选项。在这种情况下， <code class="codeph">STORAGE</code>子句指定最初为每个子表分区分配大小为14M的扩展区。
                        </p>
                        <div class="infoboxnotealso" id="GUID-99B0AD73-F9C4-490B-BDDD-E52492E2CD64__GUID-F053E303-0072-4F6F-A353-8A183A4D5AE8">
                           <p class="notep1">也可以看看：</p>
                           <ul style="list-style-type:disc">
                              <li>
                                 <p><a href="oracle-supplied-XML-schemas-and-examples.html#GUID-1CB2213C-C6E8-4BC4-86A3-EFDE51AEBEFD__BABDAGBF">例A-2</a></p>
                              </li>
                              <li>
                                 <p>有关分区对象关系数据的更多信息，请参见<a href="../adobj/partitioning-table-that-contain-oracle-objects.html#ADOBJ00608" target="_blank"><span><cite>“Oracle数据库对象关系开发人员指南”</cite></span></a></p>
                              </li>
                              <li>
                                 <p>有关分区的详细信息<a href="../vldbg/partition-create-tables-indexes.html#VLDBG1116" target="_blank"><span><cite>，请参见“Oracle数据库VLDB和分区指南”</cite></span></a></p>
                              </li>
                           </ul>
                        </div>
                     </div>
                     <!-- class="section" -->
                     <div class="example" id="GUID-99B0AD73-F9C4-490B-BDDD-E52492E2CD64__BHADGCEG">
                        <p class="titleinexample">示例18-16在XML架构注册期间指定分区信息</p><pre class="oac_no_warn" dir="ltr">&lt;xs：element name =“PurchaseOrder”type =“PurchaseOrderType”xdb：defaultTable =“PURCHASEORDER” <span class="bold">xdb：tableProps</span> =“VARRAY XMLDATA.LINEITEMS.LINEITEM STORE AS TABLE <span class="bold">lineitem_table</span> （（PRIMARY KEY（NESTED_TABLE_ID，SYS_NC_ARRAY_INDEX $））） <span class="bold">PARTITION</span> BY RANGE（XMLDATA.Reference）（ <span class="bold">PARTITION p1</span> VALUE少于（1000）VARRAY XMLDATA.LINEITEMS.LINEITEM <span class="bold">存储为表lineitem_p1</span> （ <span class="bold">STORAGE（MINEXTENTS 13）</span> ）， <span class="bold">PARTITION p2</span> VALUES少于（2000）VARRAY XMLDATA.LINEITEMS.LINEITEM <span class="bold">存储为表lineitem_p2</span> （ <span class="bold">STORAGE（MINEXTENTS 13）</span> ））“/&gt;</pre></div>
                     <!-- class="example" -->
                     <div class="example" id="GUID-99B0AD73-F9C4-490B-BDDD-E52492E2CD64__BHABFFHC">
                        <p class="titleinexample">示例18-17在表创建期间指定分区信息</p><pre class="oac_no_warn" dir="ltr">CREATE TABLE purchaseorder OF XMLType XMLSCHEMA“http：// localhost：8080 / source / schemas / poSource / xsd / purchaseOrder.xsd”ELEMENT“PurchaseOrder”VARRAY“XMLDATA”。“LINEITEMS”。“LINEITEM”STORE AS TABLE <span class="bold">lineitem_table</span> （（PRIMARY） KEY（NESTED_TABLE_ID，SYS_NC_ARRAY_INDEX $））） <span class="bold">PARTITION</span> BY RANGE（XMLDATA.Reference）（ <span class="bold">PARTITION p1</span> VALUES比（1000）VARRAY“XMLDATA”。“LINEITEMS”。“LINEITEM” <span class="bold">STORE AS TABLE lineitem_p1</span> （ <span class="bold">STORAGE（MINEXTENTS 13）</span> ）， <span class="bold">PARTITION p2</span> VALUES比（2000）VARRAY“XMLDATA”。“LINEITEMS”。“LINEITEM” <span class="bold">STORE AS TABLE lineitem_p2</span> （ <span class="bold">STORAGE（MINEXTENTS 13）</span> ））;</pre></div>
                     <!-- class="example" -->
                  </div>
                  <div>
                     <div class="familylinks">
                        <div class="parentlink">
                           <p><strong>父主题：</strong> <a href="XML-Schema-and-query-object-relational-storage.html#GUID-8713E2AD-0D5F-4076-A2DE-BB0ECEFBFEA8" title="使用对象关系存储的XMLType列对对象关系XMLType表或表进行分区时，使用列表，范围或散列分区，数据中的任何有序集合表（OCT）或外联表默认情况下会相应地自动分区。">对存储的对象 - 关系的XMLType表和列进行分区概述</a></p>
                        </div>
                     </div>
                  </div>
                  
               </div><a id="ADXDB4633"></a><div class="props_rev_3"><a id="GUID-969A9AAC-8531-48FC-8EB3-67E31EC5ED35" name="GUID-969A9AAC-8531-48FC-8EB3-67E31EC5ED35"></a><h4 id="ADXDB-GUID-969A9AAC-8531-48FC-8EB3-67E31EC5ED35" class="sect4"><span class="enumeration_section">18.6.2</span> XMLType数据的分区维护存储对象 - 关系</h4>
                  <div>
                     <p>您无需手动定义或维护子表分区。在基本（父）表上执行分区维护时，也会自动对子表执行相应的维护。</p>
                     <p>一般规则有一些例外，即您只在基表上执行分区维护。在以下情况下，您对子表执行维护：</p>
                     <ul style="list-style-type:disc">
                        <li>
                           <p>修改集合分区的<span class="italic">默认</span>物理存储属性</p>
                        </li>
                        <li>
                           <p>修改集合分区的物理存储属性</p>
                        </li>
                        <li>
                           <p>将集合分区移动到不同的段，可能在不同的表空间中</p>
                        </li>
                        <li>
                           <p>重命名集合分区</p>
                        </li>
                     </ul>
                     <p>例如，如果更改基表的表空间，则该更改不会级联到其子表分区。您必须在子表分区上手动使用<code class="codeph">ALTER TABLE MOVE PARTITION</code>来更改其表空间。
                     </p>
                     <p>除了这些异常操作之外，您只能在基表上执行所有分区维护。这包括添加，删除和拆分分区等操作。</p>
                     <p>子表还支持在线分区重新定义。您可以在联机重新定义基表期间将未分区的子表复制到分区子表。你可以通过指定的参数值<code class="codeph">copy_indexes =&gt; 0</code>和<code class="codeph">copy_constraints =&gt; false</code>的PL / SQL程序<code class="codeph">DBMS_REDEFINITION.copy_table_dependents</code> ，以保护新定义的子表的索引和约束。
                     </p>
                  </div>
                  <div>
                     <div class="infoboxnotealso" id="GUID-969A9AAC-8531-48FC-8EB3-67E31EC5ED35__GUID-95B8F30D-DBA3-4957-9D05-15A000C4815E">
                        <p class="notep1">也可以看看：</p>
                        <ul style="list-style-type:disc">
                           <li>
                              <p>有关SQL语句<code class="codeph">ALTER TABLE</code>信息，请<a href="../sqlrf/ALTER-TABLE.html#SQLRF01001" target="_blank"><span><cite>参见Oracle数据库SQL语言参考</cite></span></a></p>
                           </li>
                           <li>
                              <p><a href="../arpls/DBMS_REDEFINITION.html#ARPLS042" target="_blank"><span><cite>Oracle Database PL / SQL包和类型参考</cite></span></a>有关使用PL / SQL包<code class="codeph">DBMS_REDEFINITION</code>在线分区重定义的信息</p>
                           </li>
                        </ul>
                     </div>
                     <div class="familylinks">
                        <div class="parentlink">
                           <p><strong>父主题：</strong> <a href="XML-Schema-and-query-object-relational-storage.html#GUID-8713E2AD-0D5F-4076-A2DE-BB0ECEFBFEA8" title="使用对象关系存储的XMLType列对对象关系XMLType表或表进行分区时，使用列表，范围或散列分区，数据中的任何有序集合表（OCT）或外联表默认情况下会相应地自动分区。">对存储的对象 - 关系的XMLType表和列进行分区概述</a></p>
                        </div>
                     </div>
                  </div>
                  
               </div>
            </div><a id="ADXDB4111"></a><a id="ADXDB4513"></a><div class="props_rev_3"><a id="GUID-EEF1789B-F8B0-4371-96FB-40D0547060BA" name="GUID-EEF1789B-F8B0-4371-96FB-40D0547060BA"></a><h3 id="ADXDB-GUID-EEF1789B-F8B0-4371-96FB-40D0547060BA" class="sect3"><span class="enumeration_section">18.7</span> XMLType表和列的关系约束规范</h3>
               <div>
                  <p>对于以对象关系存储的<code class="codeph">XMLType</code>数据，您可以为在XML文档中仅出现一次的元素和属性指定典型的关系约束。
                  </p>
                  <p><a href="XML-Schema-and-query-object-relational-storage.html#GUID-EEF1789B-F8B0-4371-96FB-40D0547060BA__BABGHJIA">示例18-18</a>定义了标准数据库模式<code class="codeph">OE</code> <code class="codeph">XMLType</code>表<code class="codeph">purchaseorder</code>唯一性和外键约束。</p>
                  <p>对于以对象关系存储的<code class="codeph">XMLType</code>数据（例如表<code class="codeph">OE.purchaseorder</code> ，必须根据用于管理XML内容的SQL数据类型的对象属性指定约束。
                  </p>
                  <p><a href="XML-Schema-and-query-object-relational-storage.html#GUID-EEF1789B-F8B0-4371-96FB-40D0547060BA__BABGHJIA">例18-18</a>类似于<a href="how-to-use-XML-DB.html#GUID-B08A78A0-351B-431E-8F81-E02FFF0357D1__CHDGIABF">例3-8</a> ，它定义了二进制XML表的唯一性约束。但另外， <a href="XML-Schema-and-query-object-relational-storage.html#GUID-EEF1789B-F8B0-4371-96FB-40D0547060BA__BABGHJIA">示例18-18</a>定义了一个外键约束，该约束要求每个<code class="codeph">OE.purchaseorder</code>文档的元素<code class="codeph">User</code>是标准数据库模式<code class="codeph">HR</code>表<code class="codeph">employees</code>中的雇员的电子邮件地址。</p>
                  <p>与<a href="how-to-use-XML-DB.html#GUID-B08A78A0-351B-431E-8F81-E02FFF0357D1__CHDGIABF">示例3-8一样</a> ， <a href="XML-Schema-and-query-object-relational-storage.html#GUID-EEF1789B-F8B0-4371-96FB-40D0547060BA__BABGHJIA">示例18-18</a>的唯一性约束<code class="codeph">reference_is_unique</code>确保了存储在表中的所有文档的元素<code class="codeph">Reference</code>的唯一性。外键约束<code class="codeph">user_is_valid</code>确保元素<code class="codeph">User</code>的值对应于表<code class="codeph">HR.employees</code>列<code class="codeph">email</code>中的值。
                  </p>
                  <p>与XML文档<code class="codeph">DuplicateReference.xml</code>中的元素<code class="codeph">Reference</code>关联的文本节点包含与XML文档<code class="codeph">PurchaseOrder.xml</code>的对应节点相同的值。因此，尝试将这两个文档存储在Oracle XML DB中会违反约束<code class="codeph">reference_is_unique</code> 。
                  </p>
                  <p>与XML文档<code class="codeph">InvalidUser.xml</code>中的元素<code class="codeph">User</code>关联的文本节点包含值<code class="codeph">HACKER</code> 。表<code class="codeph">HR.employees</code>中没有条目，其中列<code class="codeph">email</code>的值是<code class="codeph">HACKER</code> 。尝试将此文档存储在Oracle XML DB中会违反外键约束<code class="codeph">user_is_valid</code> 。
                  </p>
                  <div class="section">
                     <div class="infoboxnotealso" id="GUID-EEF1789B-F8B0-4371-96FB-40D0547060BA__GUID-EC2F231E-5291-43A3-8C54-CC4C36F6B14E">
                        <p class="notep1">也可以看看：</p>
                        <ul style="list-style-type:disc">
                           <li>
                              <p><a href="how-to-use-XML-DB.html#GUID-B08A78A0-351B-431E-8F81-E02FFF0357D1" title="您可以使用SQL约束和数据库触发器来确保数据完整性属性，例如唯一性和外键关系。">使用SQL约束强制执行参照完整性</a> ，特别是<a href="how-to-use-XML-DB.html#GUID-B08A78A0-351B-431E-8F81-E02FFF0357D1__CHDGIABF">示例3-8</a></p>
                           </li>
                           <li>
                              <p><a href="how-to-use-XML-DB.html#GUID-8320CE79-5536-4252-BAF4-746692EBA596" title="您可以将SQL和XML的强大功能与数据库强制执行规则的能力结合起来。">实施XML数据完整性使用数据库</a>获取有关定义存储为二进制XML的<code class="codeph">XMLType</code>数据的<code class="codeph">XMLType</code>信息</p>
                           </li>
                        </ul>
                     </div>
                  </div>
                  <!-- class="section" -->
                  <div class="example" id="GUID-EEF1789B-F8B0-4371-96FB-40D0547060BA__BABGHJIA">
                     <p class="titleinexample">示例18-18存储对象 - 关系的XMLType表的完整性约束和触发器</p><pre class="pre codeblock"><code>ALTER TABLE purchaseorder ADD CONSTRAINT reference_is_unique UNIQUE（ <span class="bold">XMLDATA。“REFERENCE”</span> ）; ALTER TABLE purchaseorder ADD CONSTRAINT user_is_valid FOREIGN KEY（ <span class="bold">XMLDATA。“USERID”</span> ）REFERENCES hr.employees（email）; INSERT INTO purchaseorder VALUES（XMLType（bfilename（'XMLDIR'，'purchaseOrder.xml'），nls_charset_id（'AL32UTF8'）））; INSERT INTO purchaseorder VALUES（XMLType（bfilename（'XMLDIR'，'DuplicateReference.xml'），nls_charset_id（'AL32UTF8'）））; INSERT INTO purchaseorder * ERROR在第1行： <span class="bold">ORA-00001：唯一约束（QUINE.REFERENCE_IS_UNIQUE）违反</span> INSERT INTO purchaseorder VALUES（XMLType（bfilename（'XMLDIR'，'InvalidUser.xml'），nls_charset_id（'AL32UTF8'）））;在第1行INSERT INTO purchaseorder * ERROR： <span class="bold">ORA-02291：违反了完整性约束（QUINE.USER_IS_VALID） - 未</span> <span class="bold">找到</span> <span class="bold">父键</span>
</code></pre></div>
                  <!-- class="example" -->
               </div>
               <div>
                  <ul class="ullinks">
                     <li class="ulchildlink"><a href="XML-Schema-and-query-object-relational-storage.html#GUID-D8FB50DB-D87D-4F1F-99E1-D6D66EAC8541">将唯一约束添加到属性的父元素</a><br>要对可能出现多次的元素创建约束，请将varray存储为有序集合表（OCT）。然后，您可以在OCT上创建约束。例如，您可能希望基于重复自身的元素（集合）的属性创建唯一键。
                     </li>
                  </ul>
                  <div class="relinfo">
                     <p><strong>相关话题</strong></p>
                     <ul>
                        <li><a href="XML-Schema-and-query-object-relational-storage.html#GUID-D8FB50DB-D87D-4F1F-99E1-D6D66EAC8541" title="要对可能出现多次的元素创建约束，请将varray存储为有序集合表（OCT）。然后，您可以在OCT上创建约束。例如，您可能希望基于重复自身的元素（集合）的属性创建唯一键。">将唯一约束添加到属性的父元素</a></li>
                     </ul>
                  </div>
                  <div class="familylinks">
                     <div class="parentlink">
                        <p><strong>父主题：</strong> <a href="XML-Schema-and-query-object-relational-storage.html#GUID-B0C1A0B0-2DD1-491A-8CE1-1F857FD267B7" title="基于XML Schema的数据的高级技术包括使用对象关系存储;注释XML模式;将Schema数据类型映射到SQL;使用complexType扩展和限制;创建，指定关系约束，分区基于XML Schema的数据，存储XMLType数据，使用复杂或大型模式，以及调试模式注册。">XML模式存储和查询：对象关系存储</a></p>
                     </div>
                  </div>
               </div>
               <a id="ADXDB4617"></a><a id="ADXDB4616"></a><div class="props_rev_3"><a id="GUID-D8FB50DB-D87D-4F1F-99E1-D6D66EAC8541" name="GUID-D8FB50DB-D87D-4F1F-99E1-D6D66EAC8541"></a><h4 id="ADXDB-GUID-D8FB50DB-D87D-4F1F-99E1-D6D66EAC8541" class="sect4"><span class="enumeration_section">18.7.1</span>向属性的父元素添加唯一约束</h4>
                  <div>
                     <p>要对可能出现多次的元素创建约束，请将varray存储为有序集合表（OCT）。然后，您可以在OCT上创建约束。例如，您可能希望基于重复自身的元素（集合）的属性创建唯一键。</p>
                     <div class="section">
                        <p><a href="XML-Schema-and-query-object-relational-storage.html#GUID-D8FB50DB-D87D-4F1F-99E1-D6D66EAC8541__BABIGCIH">例18-19</a>显示了一个XML模式，它允许元素<code class="codeph">&lt;PhoneNumber&gt;</code>属性<code class="codeph">No</code>出现多次。该示例显示了如何添加唯一约束以确保在给定的实例文档中不能重复相同的电话号码。
                        </p>
                        <p>此示例中的约束适用于每个集合，而不适用于所有实例。这是通过使用集合id列创建连接索引来实现的。要在所有实例文档的所有集合中应用约束，请省略集合id列。</p>
                        <div class="infoboxnote" id="GUID-D8FB50DB-D87D-4F1F-99E1-D6D66EAC8541__GUID-9970F054-26BA-4C81-88F2-5F13C39B9DFA">
                           <p class="notep1">注意：</p>
                           <p>您只能创建一个<span class="italic">函数</span>约束作为存储为二进制XML的<code class="codeph">XMLType</code>数据的唯一或外键约束。</p>
                        </div>
                     </div>
                     <!-- class="section" -->
                     <div class="example" id="GUID-D8FB50DB-D87D-4F1F-99E1-D6D66EAC8541__BABIGCIH">
                        <p class="titleinexample">示例18-19将唯一约束添加到属性的父元素</p><pre class="pre codeblock"><code>BEGIN DBMS_XMLSCHEMA.registerSchema（SCHEMAURL =&gt;'emp.xsd'，SCHEMADOC =&gt;'&lt;xs：schema xmlns：xs =“http://www.w3.org/2001/XMLSchema”xmlns：xdb =“http：// xmlns.oracle.com/xdb“&gt; &lt;xs：element name =”Employee“xdb：SQLType =”EMP_TYPE“&gt; &lt;xs：complexType&gt; &lt;xs：sequence&gt; &lt;xs：element name =”EmployeeId“type =”xs： positiveInteger“/&gt; &lt;xs：element name =” <span class="bold">PhoneNumber</span> “maxOccurs =”10“/&gt; &lt;xs：complexType&gt; &lt;xs：attribute name =” <span class="bold">No</span> “type =”xs：integer“/&gt; &lt;/ xs：complexType&gt; &lt; / xs：element&gt; &lt;/ xs：sequence&gt; &lt;/ xs：complexType&gt; &lt;/ xs：element&gt; &lt;/ xs：schema&gt;'，LOCAL =&gt; FALSE，GENTYPES =&gt; FALSE）; END; / PL / SQL过程成功完成。CREATE TABLE emp_tab OF XMLType XMLSCHEMA“emp.xsd”ELEMENT“Employee”VARRAY XMLDATA。“ <span class="bold">PhoneNumber</span> ”STORE AS TABLE phone_tab;表创建。
</code></pre><pre class="pre codeblock"><code>ALTER TABLE phone_tab ADD <span class="bold">UNIQUE</span> （NESTED_TABLE_ID，“ <span class="bold">No</span> ”）;表改变了。
</code></pre><pre class="pre codeblock"><code>INSERT INTO emp_tab VALUES（XMLType（'&lt;Employee&gt; &lt;EmployeeId&gt; 1234 &lt;/ EmployeeId&gt; &lt;PhoneNumber <span class="bold">No =“1234”</span> /&gt; &lt;PhoneNumber <span class="bold">No =“2345”</span> /&gt; &lt;/ Employee&gt;'）。createSchemaBasedXML（'emp.xsd “））;已创建1行。
</code></pre><pre class="pre codeblock"><code>INSERT INTO emp_tab VALUES（XMLType（'&lt;Employee&gt; &lt;EmployeeId&gt; 3456 &lt;/ EmployeeId&gt; &lt;PhoneNumber <span class="bold">No =“4444”</span> /&gt; &lt;PhoneNumber <span class="bold">No =“4444”</span> /&gt; &lt;/ Employee&gt;'）。createSchemaBasedXML（'emp.xsd “））;</code></pre><p>这将返回预期结果：</p><pre class="pre codeblock"><code>*第1行的错误：ORA-00001： <span class="bold">违反了</span> <span class="bold">唯一约束</span> （SCOTT.SYS_C002136）
</code></pre></div>
                     <!-- class="example" -->
                  </div>
                  <div>
                     <div class="familylinks">
                        <div class="parentlink">
                           <p><strong>父主题：</strong> <a href="XML-Schema-and-query-object-relational-storage.html#GUID-EEF1789B-F8B0-4371-96FB-40D0547060BA" title="对于以对象关系存储的XMLType数据，您可以为在XML文档中仅出现一次的元素和属性指定典型的关系约束。">XMLType表和列的关系约束规范</a></p>
                        </div>
                     </div>
                  </div>
                  
               </div>
            </div><a id="ADXDB6367"></a><div class="props_rev_3"><a id="GUID-0EF2C8B6-927A-4F50-8126-47CD566A6B92" name="GUID-0EF2C8B6-927A-4F50-8126-47CD566A6B92"></a><h3 id="ADXDB-GUID-0EF2C8B6-927A-4F50-8126-47CD566A6B92" class="sect3"><span class="enumeration_section">18.8</span> XMLType数据的外部存储</h3>
               <div>
                  <p>默认情况下，当<code class="codeph">XMLType</code>数据以对象关系方式存储时，子元素将映射到嵌入式SQL对象属性。有时，通过存储一些<code class="codeph">XMLType</code>数据可以获得更好的性能。使用XML模式注释<code class="codeph">xdb:SQLInline</code>来执行此操作。
                  </p>
               </div>
               <div>
                  <ul class="ullinks">
                     <li class="ulchildlink"><a href="XML-Schema-and-query-object-relational-storage.html#GUID-AC221997-9F02-423E-9F39-BA02046763B5">将注释属性xdb：SQLInline设置为false以用于外线存储</a><br>将XML模式注释<code class="codeph">xdb:SQLInline</code>为<code class="codeph">false</code>以将XML片段存储在线外。该元素映射到具有嵌入<code class="codeph">REF</code>属性的SQL对象类型，该属性指向另一个存储在行外且与XML片段对应的<code class="codeph">XMLType</code>实例。
                     </li>
                     <li class="ulchildlink"><a href="XML-Schema-and-query-object-relational-storage.html#GUID-37820174-3776-4B5D-B96E-CA2515E7016C">将集合存储在外表中</a><br>您可以存储收集项目。父元素不是单个<code class="codeph">REF</code>列，而是包含指向集合成员的<code class="codeph">REF</code>值的varray值。
                     </li>
                  </ul>
                  <div class="familylinks">
                     <div class="parentlink">
                        <p><strong>父主题：</strong> <a href="XML-Schema-and-query-object-relational-storage.html#GUID-B0C1A0B0-2DD1-491A-8CE1-1F857FD267B7" title="基于XML Schema的数据的高级技术包括使用对象关系存储;注释XML模式;将Schema数据类型映射到SQL;使用complexType扩展和限制;创建，指定关系约束，分区基于XML Schema的数据，存储XMLType数据，使用复杂或大型模式，以及调试模式注册。">XML模式存储和查询：对象关系存储</a></p>
                     </div>
                  </div>
               </div>
               <a id="ADXDB4619"></a><a id="ADXDB4620"></a><a id="ADXDB5882"></a><a id="ADXDB4621"></a><a id="ADXDB4618"></a><div class="props_rev_3"><a id="GUID-AC221997-9F02-423E-9F39-BA02046763B5" name="GUID-AC221997-9F02-423E-9F39-BA02046763B5"></a><h4 id="ADXDB-GUID-AC221997-9F02-423E-9F39-BA02046763B5" class="sect4"><span class="enumeration_section">18.8.1</span>设置注释属性xdb：对于Out-Line-Storage存储，SQLInline为false</h4>
                  <div>
                     <p>将XML模式注释<code class="codeph">xdb:SQLInline</code>为<code class="codeph">false</code>以将XML片段存储在线外。该元素映射到具有嵌入<code class="codeph">REF</code>属性的SQL对象类型，该属性指向另一个存储在行外且与XML片段对应的<code class="codeph">XMLType</code>实例。
                     </p>
                     <div class="section">
                        <p>默认情况下，当<code class="codeph">XMLType</code>数据以对象关系存储时，子XML元素将映射到嵌入式SQL对象属性。但是，有些情况下，外部存储可提供更好的性能。在这种情况下，将XML模式注释（属性） <code class="codeph">xdb:SQLInline</code>为<code class="codeph">false</code> ，以便Oracle XML DB生成具有嵌入<code class="codeph">REF</code>属性的SQL对象类型。该<code class="codeph">REF</code>点到另一个<code class="codeph">XMLType</code>实例存储脱节和对应于所述XML片段。还会创建默认的<code class="codeph">XMLType</code>表，以存储外部片段。
                        </p>
                        <p><a href="XML-Schema-and-query-object-relational-storage.html#GUID-AC221997-9F02-423E-9F39-BA02046763B5__I1030591">图18-2</a>说明了<code class="codeph">complexType</code>到SQL的外部存储映射。
                        </p>
                        <div class="figure" id="GUID-AC221997-9F02-423E-9F39-BA02046763B5__I1030591">
                           <p class="titleinfigure">图18-2将complexType映射到SQL以进行外线存储</p><img src="img/adxdb010.gif" width="373" alt="下面是图18-2的描述" title="下面是图18-2的描述" longdesc="img_text/adxdb010.html"><br><a href="img_text/adxdb010.html">“图18-2将complexType映射到SQL以进行外线存储”</a></div>
                        <!-- class="figure" -->
                        <div class="infoboxnote" id="GUID-AC221997-9F02-423E-9F39-BA02046763B5__GUID-4D82F318-C491-4EF5-9099-BB6E1FDE7798">
                           <p class="notep1">注意：</p>
                           <p>从Oracle Database 11g第2版（11.2.0.2）开始，您只能创建<span class="italic">一个</span>使用XML模式的<code class="codeph">XMLType</code>表，该XML模式将生成<code class="codeph">an out-of-line table</code> 。如果您尝试创建使用相同XML架构的第二个表，则会引发错误。
                           </p>
                        </div>
                        <p>在<a href="XML-Schema-and-query-object-relational-storage.html#GUID-AC221997-9F02-423E-9F39-BA02046763B5__CHDCEIGC">例18-20中</a> ，属性<code class="codeph">xdb:SQLInline</code>元素<code class="codeph">Addr</code> <code class="codeph">xdb:SQLInline</code>值为<code class="codeph">false</code> 。生成的SQL对象类型<code class="codeph">obj_t2</code>具有带有嵌入<code class="codeph">REF</code>对象属性的<code class="codeph">XMLType</code>列。<code class="codeph">REF</code>属性指向表<code class="codeph">addr_tab</code>中SQL对象类型<code class="codeph">obj_t1</code>的<code class="codeph">XMLType</code>实例。表<code class="codeph">addr_tab</code>存储在行外。它有<code class="codeph">street</code>和<code class="codeph">city</code>列。
                        </p>
                        <p>注册此XML模式时，Oracle XML DB会生成<a href="XML-Schema-and-query-object-relational-storage.html#GUID-AC221997-9F02-423E-9F39-BA02046763B5__BHAHAIEC">示例18-21中</a>所示的<code class="codeph">XMLType</code>表和类型。
                        </p>
                        <p>表<code class="codeph">emp_tab</code>包含所有员工信息，它包含一个对象引用，该引用指向表<code class="codeph">addr_tab</code>的行外存储的地址信息。
                        </p>
                        <p>此模型的一个优点是，它允许您直接查询外联表（ <code class="codeph">addr_tab</code> ），以查找地址信息。<a href="XML-Schema-and-query-object-relational-storage.html#GUID-AC221997-9F02-423E-9F39-BA02046763B5__CHDDDBCI">示例18-22</a>说明了直接查询表<code class="codeph">addr_tab</code>以获取所有员工的不同城市信息。
                        </p>
                        <p>此存储模型的缺点是，为了获取整个<code class="codeph">Employee</code>元素，您必须访问该地址的附加表。
                        </p>
                     </div>
                     <!-- class="section" -->
                     <div class="example" id="GUID-AC221997-9F02-423E-9F39-BA02046763B5__CHDCEIGC">
                        <p class="titleinexample">示例18-20将OutIn-Line存储的SQLInline设置为False</p><pre class="oac_no_warn" dir="ltr">DECLARE doc VARCHAR2（3000）：='&lt;schema xmlns =“http://www.w3.org/2001/XMLSchema”targetNamespace =“http://www.oracle.com/emp.xsd”xmlns：emp =“ http://www.oracle.com/emp.xsd“xmlns：xdb =”http://xmlns.oracle.com/xdb“&gt; &lt;complexType name =”EmpType“xdb：SQLType =”EMP_T“&gt; &lt;sequence&gt; &lt;element name =“Name”type =“string”/&gt; &lt;element name =“Age”type =“decimal”/&gt; &lt;element name =“Addr” <span class="bold">xdb：SQLInline =“false”</span> xdb：defaultTable =“ADDR_TAB”&gt; &lt;complexType xdb：SQLType =“ADDR_T”&gt; &lt;sequence&gt; &lt;element name =“Street”type =“string”/&gt; &lt;element name =“City”type =“string”/&gt; &lt;/ sequence&gt; &lt;/ complexType&gt; &lt; / element&gt; &lt;/ sequence&gt; &lt;/ complexType&gt; &lt;element name =“Employee”type =“emp：EmpType”xdb：defaultTable =“EMP_TAB”/&gt; &lt;/ schema&gt;'; BEGIN DBMS_XMLSCHEMA.registerSchema（SCHEMAURL =&gt;'emp.xsd'，SCHEMADOC =&gt; doc，ENABLE_HIERARCHY =&gt; DBMS_XMLSCHEMA.ENABLE_HIERARCHY_NONE）;结束; /</pre></div>
                     <!-- class="example" -->
                     <div class="example" id="GUID-AC221997-9F02-423E-9F39-BA02046763B5__BHAHAIEC">
                        <p class="titleinexample">示例18-21生成的XMLType表和类型</p><pre class="oac_no_warn" dir="ltr">DESCRIBE emp_tab名称是否为空？输入----------------------------- -------- ------------ ---------------------------------------------- SYS表。 XMLTYPE（XMLSchema“emp.xsd”元素“Employee”）STORAGE对象关系类型“EMP_T”DESCRIBE addr_tab名称是否为空？输入----------------------------- -------- ------------ -------------------------------------------- SYS.XMLTYPE的表格（ XMLSchema“emp.xsd”元素“Addr”）存储对象 - 关系类型“ADDR_T”DESCRIBE emp_t emp_t不是最终名称是否为空？输入----------------------------- -------- ------------ -------- SYS_XDBPD $ XDB.XDB $ RAW_LIST_T名称VARCHAR2（4000 CHAR）年龄NUMBER Addr <span class="bold">REF OF XMLTYPE</span> DESCRIBE addr_t Name Null？输入----------------------------- -------- ------------ -------- SYS_XDBPD $ XDB.XDB $ RAW_LIST_T街道VARCHAR2（4000 CHAR）城市VARCHAR2（4000 CHAR）</pre></div>
                     <!-- class="example" -->
                     <div class="example" id="GUID-AC221997-9F02-423E-9F39-BA02046763B5__CHDDDBCI">
                        <p class="titleinexample">例18-22查询外线表</p><pre class="oac_no_warn" dir="ltr">INSERT INTO emp_tab VALUES（XMLType（'&lt;x：Employee xmlns：xsi =“http://www.w3.org/2001/XMLSchema-instance”xmlns：x =“http://www.oracle.com/emp。 xsd“xsi：schemaLocation =”http://www.oracle.com/emp.xsd emp.xsd“&gt; &lt;Name&gt; Abe Bee &lt;/ Name&gt; &lt;Age&gt; 22 &lt;/ Age&gt; &lt;Addr&gt; &lt;Street&gt; A Street &lt;/ Street&gt; &lt;城市&gt;旧金山&lt;/ City&gt; &lt;/ Addr&gt; &lt;/ x：员工&gt;'））; INSERT INTO emp_tab VALUES（XMLType（'&lt;x：Employee xmlns：xsi =“http://www.w3.org/2001/XMLSchema-instance”xmlns：x =“http://www.oracle.com/emp。 xsd“xsi：schemaLocation =”http://www.oracle.com/emp.xsd emp.xsd“&gt; &lt;Name&gt; Cecilia Dee &lt;/ Name&gt; &lt;Age&gt; 23 &lt;/ Age&gt; &lt;Addr&gt; &lt;Street&gt; C Street &lt;/ Street&gt; &lt;城市&gt;红木城&lt;/ City&gt; &lt;/ Addr&gt; &lt;/ x：员工&gt;'））; <span class="bold">。 。 。</span>
</pre><pre class="oac_no_warn" dir="ltr">SELECT DISTINCT XMLCast（XMLQuery（'/ Addr / City'PASSING OBJECT_VALUE AS“。”RETURNING CONTENT）AS VARCHAR2（20））FROM addr_tab; CITY -------------红木城旧金山</pre></div>
                     <!-- class="example" -->
                  </div>
                  <div>
                     <div class="familylinks">
                        <div class="parentlink">
                           <p><strong>父主题：</strong> <a href="XML-Schema-and-query-object-relational-storage.html#GUID-0EF2C8B6-927A-4F50-8126-47CD566A6B92" title="默认情况下，当XMLType数据以对象关系方式存储时，子元素将映射到嵌入式SQL对象属性。有时，通过存储一些XMLType数据可以获得更好的性能。使用XML模式注释xdb：SQLInline来执行此操作。">XMLType数据的外部存储</a></p>
                        </div>
                     </div>
                  </div>
                  
               </div><a id="ADXDB4626"></a><a id="ADXDB5883"></a><a id="ADXDB4627"></a><a id="ADXDB4628"></a><a id="ADXDB4629"></a><a id="ADXDB4625"></a><div class="props_rev_3"><a id="GUID-37820174-3776-4B5D-B96E-CA2515E7016C" name="GUID-37820174-3776-4B5D-B96E-CA2515E7016C"></a><h4 id="ADXDB-GUID-37820174-3776-4B5D-B96E-CA2515E7016C" class="sect4"><span class="enumeration_section">18.8.2</span>在外联表中存储集合</h4>
                  <div>
                     <p>您可以存储收集项目。父元素不是单个<code class="codeph">REF</code>列，而是包含指向集合成员的<code class="codeph">REF</code>值的varray值。
                     </p>
                     <div class="section">
                        <p>例如，假设每个员工都有一个地址列表，该列表将映射到外部存储，如<a href="XML-Schema-and-query-object-relational-storage.html#GUID-37820174-3776-4B5D-B96E-CA2515E7016C__CHDJHBIE">例18-23</a>所示。
                        </p>
                        <p>在注册此XML模式期间，Oracle XML DB生成表<code class="codeph">emp_tab</code>和<code class="codeph">addr_tab</code>并键入<code class="codeph">emp_t</code>和<code class="codeph">addr_t</code> ，如<a href="XML-Schema-and-query-object-relational-storage.html#GUID-AC221997-9F02-423E-9F39-BA02046763B5__CHDCEIGC">例18-20所示</a> 。但是，这次，类型<code class="codeph">emp_t</code>包含指向地址的<code class="codeph">REF</code>值的varray，而不是单个<code class="codeph">REF</code>属性，如<a href="XML-Schema-and-query-object-relational-storage.html#GUID-37820174-3776-4B5D-B96E-CA2515E7016C__BHAJFCCG">例18-24</a>所示。
                        </p>
                        <p><code class="codeph">REF</code>值的varray在一个中间表中存储在行外。也就是说，除了创建刚刚提到的表和类型之外，XML模式注册还创建了存储<code class="codeph">REF</code>值列表的中间表。此表具有系统生成的名称，但您可以重命名它。例如，为了在其上创建索引，这可能很有用。
                        </p>
                        <p><a href="XML-Schema-and-query-object-relational-storage.html#GUID-37820174-3776-4B5D-B96E-CA2515E7016C__CHDDAJBJ">示例18-26</a>显示了一个查询，该查询选择所有旧金山员工的姓名以及他们居住的街道。该示例查询元素<code class="codeph">City</code>上的地址表，并与employee表连接。显示的explain-plan片段表示表<code class="codeph">emp_tab_reflist</code>和<code class="codeph">emp_tab</code>之间的连接。
                        </p>
                        <p>要提高性能，可以在中间表<code class="codeph">emp_tab_reflist</code>的<code class="codeph">REF</code>值上创建索引。这使Oracle XML DB可以查询地址表，获取相关行的对象引用（ <code class="codeph">REF</code> ），将其与存储<code class="codeph">REF</code>值列表的中间表连接，然后将该表与employee表连接起来。
                        </p>
                        <p>仅当<code class="codeph">REF</code>具有<span class="italic">作用域</span>或具有参照约束时，才能在<code class="codeph">REF</code>值上创建索引。范围内的<code class="codeph">REF</code>列仅存储指向特定表中对象的指针。该<code class="codeph">REF</code>值在表<code class="codeph">emp_tab_reflist</code>只在表对象点<code class="codeph">addr_tab</code> ，因此可以创建一个范围约束和上一个索引<code class="codeph">REF</code>列，如图<a href="XML-Schema-and-query-object-relational-storage.html#GUID-37820174-3776-4B5D-B96E-CA2515E7016C__CHDIAFAE">实施例18-27</a> 。
                        </p>
                     </div>
                     <!-- class="section" -->
                     <div class="example" id="GUID-37820174-3776-4B5D-B96E-CA2515E7016C__CHDJHBIE">
                        <p class="titleinexample">示例18-23存储超出行的集合</p><pre class="pre codeblock"><code>DECLARE doc VARCHAR2（3000）：='&lt;schema xmlns =“http://www.w3.org/2001/XMLSchema”targetNamespace =“http://www.oracle.com/emp.xsd”xmlns：emp =“ http://www.oracle.com/emp.xsd“xmlns：xdb =”http://xmlns.oracle.com/xdb“&gt; &lt;complexType name =”EmpType“xdb：SQLType =”EMP_T“&gt; &lt;sequence&gt; &lt;element name =“Name”type =“string”/&gt; &lt;element name =“Age”type =“decimal”/&gt; &lt;element name =“Addr” <span class="bold">xdb：SQLInline =“false”</span> <span class="bold">maxOccurs =“unbounded”</span> xdb：defaultTable =“ADDR_TAB”&gt; &lt;complexType xdb：SQLType =“ADDR_T”&gt; &lt;sequence&gt; &lt;element name =“Street”type =“string”/&gt; &lt;element name =“City”type =“string”/&gt; &lt;/ sequence&gt; &lt;/ complexType&gt; &lt;/ element&gt; &lt;/ sequence&gt; &lt;/ complexType&gt; &lt;element name =“Employee”type =“emp：EmpType”xdb：defaultTable =“EMP_TAB”/&gt; &lt;/ schema&gt;'; BEGIN DBMS_XMLSCHEMA.registerSchema（SCHEMAURL =&gt;'emp.xsd'，SCHEMADOC =&gt; doc，ENABLE_HIERARCHY =&gt; DBMS_XMLSCHEMA.ENABLE_HIERARCHY_NONE）;结束; /</code></pre></div>
                     <!-- class="example" -->
                     <div class="example" id="GUID-37820174-3776-4B5D-B96E-CA2515E7016C__BHAJFCCG">
                        <p class="titleinexample">例18-24生成的外线集合类型</p><pre class="pre codeblock"><code>DESCRIBE emp_t emp_t不是最终名称空？输入-------------------------------------- -------- --- ----------------------- SYS_XDBPD $ XDB.XDB $ RAW_LIST_T Name VARCHAR2（4000 CHAR）Age NUMBER Addr <span class="bold">XDB.XDB $ XMLTYPE_REF_LIST_T</span>
</code></pre></div>
                     <!-- class="example" -->
                     <div class="example" id="GUID-37820174-3776-4B5D-B96E-CA2515E7016C__GUID-F7F6B2D2-A3B0-4392-8A56-421BA1A88013">
                        <p class="titleinexample">示例18-25重命名REF值的中间表</p><pre class="pre codeblock"><code>DECLARE gen_name VARCHAR2（4000）; BEGIN SELECT TABLE_NAME INTO gen_name FROM USER_NESTED_TABLES WHERE PARENT_TABLE_NAME ='EMP_TAB'; EXECUTE IMMEDIATE'RENAME“'|| gen_name ||'”TO <span class="bold">emp_tab_reflist</span> ';结束; / DESCRIBE <span class="bold">emp_tab_reflist</span>名称是否为空？输入----------------------- -------- ---------------- COLUMN_VALUE <span class="bold">REF OF XMLTYPE</span>
</code></pre></div>
                     <!-- class="example" -->
                     <div class="example" id="GUID-37820174-3776-4B5D-B96E-CA2515E7016C__CHDDAJBJ">
                        <p class="titleinexample">例18-26针对外部集合的XPath重写</p><pre class="pre codeblock"><code>SELECT em.name，ad.street FROM emp_tab，XMLTable（XMLNAMESPACES（'http://www.oracle.com/emp.xsd'AS“x”），'/ x：Employee'PASSING OBJECT_VALUE COLUMNS name VARCHAR2（20） PATH'Name'）em，XMLTable（XMLNAMESPACES（'http://www.oracle.com/emp.xsd'AS“x”），'/ x：Employee / Addr'PASSING OBJECT_VALUE COLUMNS street VARCHAR2（20）PATH' Street'，city VARCHAR2（20）PATH'City'）ad ad adity ='San Francisco'; NAME STREET -------------------- -------------------- Abe Bee A Street Eve Fong E Street George Hu G Street Iris Jones I Street Karl Luomo K Street Marina Namur M Street Omar Pinano O Street Quincy Roberts Q Street 8行入选。
</code></pre><pre class="oac_no_warn" dir="ltr">| 4 |表访问完全| EMP_TAB_REFLIST | 32 | 640 | 2（0）| 00:00:01 | | 5 |按INDEX ROWID表的访问权限| EMP_TAB | 1 | 29 | 1（0）| 00:00:01 | | * 6 | INDEX UNIQUE SCAN | SYS_C005567 | 1 | | 0（0）| 00:00:01 |</pre></div>
                     <!-- class="example" -->
                     <div class="example" id="GUID-37820174-3776-4B5D-B96E-CA2515E7016C__CHDIAFAE">
                        <p class="titleinexample">例18-27带有REF索引的外线集合的XPath重写</p><pre class="pre codeblock"><code>ALTER TABLE emp_tab_reflist <span class="bold">ADD SCOPE FOR</span> （COLUMN_VALUE）是addr_tab; CREATE INDEX reflist_idx ON emp_tab_reflist（COLUMN_VALUE）;</code></pre><p>与<a href="XML-Schema-and-query-object-relational-storage.html#GUID-37820174-3776-4B5D-B96E-CA2515E7016C__CHDDAJBJ">例18-26</a>中相同的查询的解释计划片段显示索引<code class="codeph">reflist_idx</code>被拾取。
                        </p><pre class="pre codeblock"><code>| 4 |按INDEX ROWID表的访问权限| EMP_TAB_REFLIST | 1 | 20 | 1（0）| 00:00:01 | | * 5 | INDEX RANGE SCAN | <span class="bold">REFLIST_IDX</span> | 1 | | 0（0）| 00:00:01 | | 6 |按INDEX ROWID表的访问权限| EMP_TAB | | | | | | * 7 | INDEX UNIQUE SCAN | SYS_C005567 | 1 | | 0（0）| 00:00:01 |</code></pre></div>
                     <!-- class="example" -->
                  </div>
                  <div>
                     <div class="familylinks">
                        <div class="parentlink">
                           <p><strong>父主题：</strong> <a href="XML-Schema-and-query-object-relational-storage.html#GUID-0EF2C8B6-927A-4F50-8126-47CD566A6B92" title="默认情况下，当XMLType数据以对象关系方式存储时，子元素将映射到嵌入式SQL对象属性。有时，通过存储一些XMLType数据可以获得更好的性能。使用XML模式注释xdb：SQLInline来执行此操作。">XMLType数据的外部存储</a></p>
                        </div>
                     </div>
                  </div>
                  
               </div>
            </div><a id="ADXDB6368"></a><div class="props_rev_3"><a id="GUID-A9BDECE7-16AF-4CA4-96D5-5B03FA3E94CE" name="GUID-A9BDECE7-16AF-4CA4-96D5-5B03FA3E94CE"></a><h3 id="ADXDB-GUID-A9BDECE7-16AF-4CA4-96D5-5B03FA3E94CE" class="sect3"><span class="enumeration_section">18.9</span>使用复杂或大型XML模式的注意事项</h3>
               <div>
                  <p>XML模式可能很复杂。复杂模式的示例包括递归模式和包含循环或循环引用的模式。使用复杂或大型XML模式可能具有挑战性，并且需要考虑某些因素。</p>
               </div>
               <div>
                  <ul class="ullinks">
                     <li class="ulchildlink"><a href="XML-Schema-and-query-object-relational-storage.html#GUID-CDED9D6F-A153-4A83-BBC3-C2ECC428196D">XML模式中的循环和循环依赖关系</a><br>W3C XML Schema Recommendation允许<code class="codeph">complexTypes</code>和global元素包含递归引用。这种结构允许实例文档，其中所讨论的元素在递归层次结构中可以无限次出现。
                     </li>
                     <li class="ulchildlink"><a href="XML-Schema-and-query-object-relational-storage.html#GUID-B43E7FEE-51C2-413F-A7FB-B023374CB26C">支持递归模式</a><br>对于外联表中的递归结构的<code class="codeph">REF</code>可能使重写XPath查询变得困难，因为在编译时不知道结构的深度。要启用XPath重写， <code class="codeph">DOCID</code>列将指向任何递归结构中的根文档。
                     </li>
                     <li class="ulchildlink"><a href="XML-Schema-and-query-object-relational-storage.html#GUID-80571C92-AB92-40F6-B067-01E228534C9D">XML片段可以映射到大对象（LOB）</a><br>您可以将用于复杂元素的SQL数据类型指定为<code class="codeph">CLOB</code>或<code class="codeph">BLOB</code> 。</li>
                     <li class="ulchildlink"><a href="XML-Schema-and-query-object-relational-storage.html#GUID-5F470098-54C0-4FC6-8E7B-732487497F90">ORA-01792和ORA-04031：大型XML模式的问题</a><br>使用大型或复杂的XML模式时，可能会引发错误<code class="codeph">ORA-01792</code>和<code class="codeph">ORA-04031</code> 。注册XML模式或创建基于XML模式定义的全局元素的表时，可以遇到它们。
                     </li>
                     <li class="ulchildlink"><a href="XML-Schema-and-query-object-relational-storage.html#GUID-32930A3C-AFD4-4950-94B6-B26ACAFBC70D">使用集合加载和检索大型文档的注意事项</a><br>Oracle XML DB配置文件<code class="codeph">xdbconfig.xml</code>具有控制加载操作使用的内存量的参数： <code class="codeph">xdbcore-loadableunit-size</code>和<code class="codeph">xdbcore-xobmem-bound</code> 。
                     </li>
                  </ul>
                  <div class="familylinks">
                     <div class="parentlink">
                        <p><strong>父主题：</strong> <a href="XML-Schema-and-query-object-relational-storage.html#GUID-B0C1A0B0-2DD1-491A-8CE1-1F857FD267B7" title="基于XML Schema的数据的高级技术包括使用对象关系存储;注释XML模式;将Schema数据类型映射到SQL;使用complexType扩展和限制;创建，指定关系约束，分区基于XML Schema的数据，存储XMLType数据，使用复杂或大型模式，以及调试模式注册。">XML模式存储和查询：对象关系存储</a></p>
                     </div>
                  </div>
               </div>
               <a id="ADXDB4656"></a><a id="ADXDB4655"></a><div class="props_rev_3"><a id="GUID-CDED9D6F-A153-4A83-BBC3-C2ECC428196D" name="GUID-CDED9D6F-A153-4A83-BBC3-C2ECC428196D"></a><h4 id="ADXDB-GUID-CDED9D6F-A153-4A83-BBC3-C2ECC428196D" class="sect4"><span class="enumeration_section">18.9.1</span> XML模式中的循环和循环依赖关系</h4>
                  <div>
                     <p>W3C XML Schema Recommendation允许<code class="codeph">complexTypes</code>和global元素包含递归引用。这种结构允许实例文档，其中所讨论的元素在递归层次结构中可以无限次出现。
                     </p>
                     <p>例如， <code class="codeph">complexType</code>定义可以<span class="italic">包含</span>基于相同<code class="codeph">complexType</code>的元素，或者<code class="codeph">complexType</code>可以包含对其自身的引用。在这两种情况下，参考可以是直接的或间接的。
                     </p>
                     <div class="example" id="GUID-CDED9D6F-A153-4A83-BBC3-C2ECC428196D__BABBFFDC">
                        <p class="titleinexample">示例18-28具有循环依赖关系的XML模式</p><pre class="pre codeblock"><code>&lt;？xml version =“1.0”encoding =“UTF-8”？&gt; &lt;xs：schema xmlns：xs =“http://www.w3.org/2001/XMLSchema”xmlns：xdb =“http://xmlns.oracle.com/xdb”elementFormDefault =“qualified”attributeFormDefault =“unqualified “&gt; &lt;xs：element name =”person“type =”personType“xdb：defaultTable =”PERSON_TABLE“/&gt; &lt;xs：complexType name =” <span class="bold">personType</span> “xdb：SQLType =”PERSON_T“&gt; &lt;xs：sequence&gt; &lt;xs： element name =“descendant”type =“ <span class="bold">personType</span> ”minOccurs =“0”maxOccurs =“unbounded”xdb：SQLName =“DESCENDANT”xdb：defaultTable =“DESCENDANT_TABLE”/&gt; &lt;/ xs：sequence&gt; &lt;xs：attribute name =“ personName“use =”required“xdb：SQLName =”PERSON_NAME“&gt; &lt;xs：simpleType&gt; &lt;xs：restriction base =”xs：string“&gt; &lt;xs：maxLength value =”20“/&gt; &lt;/ xs：restriction&gt; &lt; / xs：simpleType&gt; &lt;/ xs：attribute&gt; &lt;/ xs：complexType&gt; &lt;/ xs：schema&gt;</code></pre><p><a href="XML-Schema-and-query-object-relational-storage.html#GUID-CDED9D6F-A153-4A83-BBC3-C2ECC428196D__BABBFFDC">例18-28中</a>的XML模式包括循环依赖项。<code class="codeph">complexType</code> <code class="codeph">personType</code>由<code class="codeph">personName</code>属性和<code class="codeph">descendant</code>元素的集合组成。<code class="codeph">descendant</code>元素被定义为<code class="codeph">personType</code>类型。
                        </p>
                     </div>
                     <!-- class="example" -->
                  </div>
                  <div>
                     <ul class="ullinks">
                        <li class="ulchildlink"><a href="XML-Schema-and-query-object-relational-storage.html#GUID-E95371E5-432C-43E2-8ABE-606982BE93AB">对于循环XML模式依赖项将参数GENTABLES设置为TRUE</a><br>Oracle XML DB支持涉及循环模式依赖性的XML模式。它通过检测周期，打破它们并将递归元素作为行存储在XML模式注册期间创建的单独<code class="codeph">XMLType</code>表中来完成此操作。
                        </li>
                        <li class="ulchildlink"><a href="XML-Schema-and-query-object-relational-storage.html#GUID-71DC594A-3BAA-4EBF-9B0C-0E1BAC5A0CC9">XML Schema中的complexType声明：处理周期</a><br>SQL对象类型不允许循环。生成对象类型时，XML模式中的循环会被破坏，方法是引入一个<code class="codeph">REF</code>属性来完成循环。部分数据存储在行外，但它作为父XML文档的一部分进行检索。
                        </li>
                        <li class="ulchildlink"><a href="XML-Schema-and-query-object-relational-storage.html#GUID-CD3986D6-D50C-4E84-9690-30DE8577C12D">XML模式中的循环引用</a><br>XML模式可以以这样的方式相互依赖，即它们不能以通常的方式一个接一个地注册。
                        </li>
                     </ul>
                     <div class="familylinks">
                        <div class="parentlink">
                           <p><strong>父主题：</strong> <a href="XML-Schema-and-query-object-relational-storage.html#GUID-A9BDECE7-16AF-4CA4-96D5-5B03FA3E94CE" title="XML模式可能很复杂。复杂模式的示例包括递归模式和包含循环或循环引用的模式。使用复杂或大型XML模式可能具有挑战性，并且需要考虑某些因素。">使用复杂或大型XML架构的注意事项</a></p>
                        </div>
                     </div>
                  </div>
                  <a id="ADXDB4657"></a><div class="props_rev_3"><a id="GUID-E95371E5-432C-43E2-8ABE-606982BE93AB" name="GUID-E95371E5-432C-43E2-8ABE-606982BE93AB"></a><h5 id="ADXDB-GUID-E95371E5-432C-43E2-8ABE-606982BE93AB" class="sect5"><span class="enumeration_section">18.9.1.1</span>对于循环XML模式依赖关系将参数GENTABLES设置为TRUE</h5>
                     <div>
                        <p>Oracle XML DB支持涉及循环模式依赖性的XML模式。它通过检测周期，打破它们并将递归元素作为行存储在XML模式注册期间创建的单独<code class="codeph">XMLType</code>表中来完成此操作。
                        </p>
                        <p>因此，在注册定义此类结构的XML模式时，确保将参数<code class="codeph">GENTABLES</code>设置为<code class="codeph">TRUE</code>非常重要。可以通过向XML模式添加<code class="codeph">xdb:defaultTable</code>批注来指定用于存储递归元素的表的名称。
                        </p>
                     </div>
                     <div>
                        <div class="familylinks">
                           <div class="parentlink">
                              <p><strong>父主题：</strong> <a href="XML-Schema-and-query-object-relational-storage.html#GUID-CDED9D6F-A153-4A83-BBC3-C2ECC428196D" title="W3C XML Schema Recommendation允许complexTypes和global元素包含递归引用。这种结构允许实例文档，其中所讨论的元素在递归层次结构中可以无限次出现。">XML模式中的循环和循环依赖关系</a></p>
                           </div>
                        </div>
                     </div>
                     
                  </div><a id="ADXDB4660"></a><a id="ADXDB4663"></a><a id="ADXDB4659"></a><a id="ADXDB4661"></a><a id="ADXDB4658"></a><div class="props_rev_3"><a id="GUID-71DC594A-3BAA-4EBF-9B0C-0E1BAC5A0CC9" name="GUID-71DC594A-3BAA-4EBF-9B0C-0E1BAC5A0CC9"></a><h5 id="ADXDB-GUID-71DC594A-3BAA-4EBF-9B0C-0E1BAC5A0CC9" class="sect5"><span class="enumeration_section">18.9.1.2</span> XML Schema中的complexType声明：处理周期</h5>
                     <div>
                        <p>SQL对象类型不允许循环。生成对象类型时，XML模式中的循环会被破坏，方法是引入一个<code class="codeph">REF</code>属性来完成循环。部分数据存储在行外，但它作为父XML文档的一部分进行检索。
                        </p>
                        <div class="infoboxnote" id="GUID-71DC594A-3BAA-4EBF-9B0C-0E1BAC5A0CC9__GUID-51F33F51-9DB3-4558-B69B-C7ED2D4A4B38">
                           <p class="notep1">注意：</p>
                           <p>从Oracle Database 11g第2版（11.2.0.2）开始，您只能创建<span class="italic">一个</span>使用XML模式的<code class="codeph">XMLType</code>表，该XML模式将生成<code class="codeph">an out-of-line table</code> 。如果您尝试创建使用相同XML架构的第二个表，则会引发错误。
                           </p>
                        </div>
                        <p>XML模式允许在复杂类型的定义之间循环。<a href="XML-Schema-and-query-object-relational-storage.html#GUID-71DC594A-3BAA-4EBF-9B0C-0E1BAC5A0CC9__I1044847">图18-3</a>示出了这一点，其中，复杂类型的定义<code class="codeph">CT1</code>可以引用另一个复杂类型<code class="codeph">CT2</code> ，而定义<code class="codeph">CT2</code>引用第一类型<code class="codeph">CT1</code> 。
                        </p>
                        <p>XML模式允许复杂类型的定义之间的循环。<a href="XML-Schema-and-query-object-relational-storage.html#GUID-71DC594A-3BAA-4EBF-9B0C-0E1BAC5A0CC9__BHAGBAFH">例18-29</a>创建了一个长度为2的循环：</p>
                        <p>SQL类型不允许在类型定义中使用循环。但是，它们确实支持<strong class="term">弱循环</strong> ，即涉及<code class="codeph">REF</code> （引用）对象属性的循环。循环XML模式定义以这样一种方式映射到SQL对象类型，即通过在适当的位置强制<code class="codeph">SQLInline = "false"</code>来避免循环。这会创建一个弱的SQL循环。
                        </p>
                        <p>对于<a href="XML-Schema-and-query-object-relational-storage.html#GUID-71DC594A-3BAA-4EBF-9B0C-0E1BAC5A0CC9__BHAGBAFH">示例18-29</a>的XML模式，Oracle XML DB生成以下类型：</p><pre class="pre codeblock"><code>CREATE TYPE ct1 AS OBJECT（SYS_XDBPD $ XDB.XDB $ RAW_LIST_T，“e1”VARCHAR2（4000），“e2” <span class="bold">REF</span> XMLType）NOT FINAL; CREATE TYPE ct2 AS OBJECT（SYS_XDBPD $ XDB.XDB $ RAW_LIST_T，“e1”VARCHAR2（4000），“e2”CT1）NOT FINAL;</code></pre><div class="figure" id="GUID-71DC594A-3BAA-4EBF-9B0C-0E1BAC5A0CC9__I1044847">
                           <p class="titleinfigure">图18-3相同XML模式中不同complexType之间的交叉引用</p><img src="img/adxdb012.gif" width="279" alt="下面是图18-3的描述" title="下面是图18-3的描述" longdesc="img_text/adxdb012.html"><br><a href="img_text/adxdb012.html">“图18-3相同XML模式中不同complexType之间的交叉引用”的描述</a></div>
                        <!-- class="figure" -->
                        <p>循环复杂类型的另一个例子涉及声明引用自身的复杂类型。在<a href="XML-Schema-and-query-object-relational-storage.html#GUID-71DC594A-3BAA-4EBF-9B0C-0E1BAC5A0CC9__BHADFCCI">例18-30中</a> ，类型<code class="codeph">SectionT</code>执行此操作。
                        </p>
                        <p>对于<a href="XML-Schema-and-query-object-relational-storage.html#GUID-71DC594A-3BAA-4EBF-9B0C-0E1BAC5A0CC9__BHADFCCI">示例18-30</a>的XML模式，Oracle XML DB生成以下类型：</p><pre class="pre codeblock"><code>CREATE TYPE body_coll AS VARRAY（32767 <a id="GUID-71DC594A-3BAA-4EBF-9B0C-0E1BAC5A0CC9__CIHGAFIH" name="GUID-71DC594A-3BAA-4EBF-9B0C-0E1BAC5A0CC9__CIHGAFIH" href="#GUID-71DC594A-3BAA-4EBF-9B0C-0E1BAC5A0CC9__CIHGAFIH" value="" this="" of="" 32767="" assumes="" that="" the="" initialization="" parameter="" max_string_size="" is="" extended.="" see="" oracle="" database="" sql="" language="" reference=")" ="" ="" onclick="footdisplay(3, "><sup>Foot 3</sup></a> ）OF VARCHAR2（32767 <a id="fnsrc_d86720e7840" name="fnsrc_d86720e7840" href="#fnsrc_d86720e7840" value="" this="" of="" 32767="" assumes="" that="" the="" initialization="" parameter="" max_string_size="" is="" extended.="" see="" oracle="" database="" sql="" language="" reference=")" ="" ="" onclick="footdisplay(3, "><sup>Footref 3</sup></a> ）; CREATE TYPE section_t AS OBJECT（SYS_XDBPD $ XDB.XDB $ RAW_LIST_T，“title”VARCHAR2（32767 <a id="fnsrc_d86720e7843" name="fnsrc_d86720e7843" href="#fnsrc_d86720e7843" value="" this="" of="" 32767="" assumes="" that="" the="" initialization="" parameter="" max_string_size="" is="" extended.="" see="" oracle="" database="" sql="" language="" reference=")" ="" ="" onclick="footdisplay(3, "><sup>Footref 3</sup></a> ），“body”BODY_COLL，“section”XDB.XDB $ REF_LIST_T）NOT FINAL;</code></pre><div class="infoboxnote" id="GUID-71DC594A-3BAA-4EBF-9B0C-0E1BAC5A0CC9__GUID-A577CD97-AA9D-4EEF-A88C-5C6A7A018BC2">
                           <p class="notep1">注意：</p>
                           <p>在<a href="XML-Schema-and-query-object-relational-storage.html#GUID-71DC594A-3BAA-4EBF-9B0C-0E1BAC5A0CC9__BHADFCCI">例18-30中</a> ，对象属性<code class="codeph">section</code>被声明为对<code class="codeph">XMLType</code>实例的<code class="codeph">REF</code>引用的varray。因为嵌入的部分可能不止一次出现，所以该属性是一个varray。它是对<code class="codeph">XMLType</code>实例的<code class="codeph">REF</code>引用的varray，以避免形成SQL对象的循环。
                           </p>
                        </div>
                        <p><a href="XML-Schema-and-query-object-relational-storage.html#GUID-71DC594A-3BAA-4EBF-9B0C-0E1BAC5A0CC9__I1044836">图18-4</a>示意性地说明了<code class="codeph">complexType</code>如何引用自身。
                        </p>
                        <div class="figure" id="GUID-71DC594A-3BAA-4EBF-9B0C-0E1BAC5A0CC9__I1044836">
                           <p class="titleinfigure">图18-4 XML模式中的自引用复杂类型</p><img src="img/adxdb037.gif" width="215" alt="下面是图18-4的描述" title="下面是图18-4的描述" longdesc="img_text/adxdb037.html"><br><a href="img_text/adxdb037.html">“图18-4 XML模式中的自引用复杂类型”的描述</a></div>
                        <!-- class="figure" -->
                        <div class="section"></div>
                        <!-- class="section" -->
                        <div class="example" id="GUID-71DC594A-3BAA-4EBF-9B0C-0E1BAC5A0CC9__BHAGBAFH">
                           <p class="titleinexample">示例18-29 XML模式：在complexType之间循环</p><pre class="pre codeblock"><code>DECLARE doc VARCHAR2（3000）：='&lt;xs：schema xmlns：xs =“http://www.w3.org/2001/XMLSchema”xmlns：xdb =“http://xmlns.oracle.com/xdb”&gt; &lt;xs：complexType name =“ <span class="bold">CT1</span> ”xdb：SQLType =“CT1”&gt; &lt;xs：sequence&gt; &lt;xs：element name =“e1”type =“xs：string”/&gt; &lt;xs：element name =“e2”type =“ <span class="bold">CT2</span> ”/&gt; &lt;/ xs：sequence&gt; &lt;/ xs：complexType&gt; &lt;xs：complexType name =“ <span class="bold">CT2</span> ”xdb：SQLType =“CT2”&gt; &lt;xs：sequence&gt; &lt;xs：element name =“e1”type =“xs：string”/&gt; &lt;xs：element name =“e2”type =“ <span class="bold">CT1</span> ”/&gt; &lt;/ xs：sequence&gt; &lt;/ xs：complexType&gt; &lt;/ xs：schema&gt;'; BEGIN DBMS_XMLSCHEMA.registerSchema（SCHEMAURL =&gt;'http://www.oracle.com/emp.xsd'，SCHEMADOC =&gt; doc）;结束;</code></pre></div>
                        <!-- class="example" -->
                        <div class="example" id="GUID-71DC594A-3BAA-4EBF-9B0C-0E1BAC5A0CC9__BHADFCCI">
                           <p class="titleinexample">示例18-30 XML架构：在complexTypes之间循环，自引用</p><pre class="pre codeblock"><code>DECLARE doc VARCHAR2（3000）：='&lt;xs：schema xmlns：xs =“http://www.w3.org/2001/XMLSchema”xmlns：xdb =“http://xmlns.oracle.com/xdb”&gt; &lt;xs：complexType name =“ <span class="bold">SectionT</span> ”xdb：SQLType =“SECTION_T”&gt; &lt;xs：sequence&gt; &lt;xs：element name =“title”type =“xs：string”/&gt; &lt;xs：choice maxOccurs =“unbounded”&gt; &lt;xs：element name =“body”type =“xs：string”xdb：SQLCollType =“BODY_COLL”/&gt; &lt;xs：element name =“section”type =“ <span class="bold">SectionT</span> ”/&gt; &lt;/ xs：choice&gt; &lt;/ xs ：sequence&gt; &lt;/ xs：complexType&gt; &lt;/ xs：schema&gt;'; BEGIN DBMS_XMLSCHEMA.registerSchema（SCHEMAURL =&gt;'http://www.oracle.com/section.xsd'，SCHEMADOC =&gt; doc）;结束;</code></pre></div>
                        <!-- class="example" -->
                     </div>
                     <div>
                        <div class="relinfo">
                           <p><strong>相关话题</strong></p>
                           <ul>
                              <li><a href="XML-Schema-and-query-object-relational-storage.html#GUID-CD3986D6-D50C-4E84-9690-30DE8577C12D" title="XML模式可以以这样的方式相互依赖，即它们不能以通常的方式一个接一个地注册。">XML模式中的循环引用</a></li>
                           </ul>
                        </div>
                        <div class="familylinks">
                           <div class="parentlink">
                              <p><strong>父主题：</strong> <a href="XML-Schema-and-query-object-relational-storage.html#GUID-CDED9D6F-A153-4A83-BBC3-C2ECC428196D" title="W3C XML Schema Recommendation允许complexTypes和global元素包含递归引用。这种结构允许实例文档，其中所讨论的元素在递归层次结构中可以无限次出现。">XML模式中的循环和循环依赖关系</a></p>
                           </div>
                        </div>
                     </div>
                     
                  </div><a id="ADXDB4665"></a><a id="ADXDB4666"></a><a id="ADXDB5884"></a><a id="ADXDB5885"></a><a id="ADXDB5886"></a><a id="ADXDB4664"></a><div class="props_rev_3"><a id="GUID-CD3986D6-D50C-4E84-9690-30DE8577C12D" name="GUID-CD3986D6-D50C-4E84-9690-30DE8577C12D"></a><h5 id="ADXDB-GUID-CD3986D6-D50C-4E84-9690-30DE8577C12D" class="sect5"><span class="enumeration_section">18.9.1.3</span> XML模式中的循环引用</h5>
                     <div>
                        <p>XML模式可以以这样的方式相互依赖，即它们不能以通常的方式一个接一个地注册。</p>
                        <p><a href="XML-Schema-and-query-object-relational-storage.html#GUID-CD3986D6-D50C-4E84-9690-30DE8577C12D__I1044849">如图18-5所示</a> 。
                        </p>
                        <p>在图的上半部分，显示了三个XML模式之间的间接循环引用的示例。</p>
                        <p>在图的下半部分，显示了两个XML模式之间的循环依赖关系的示例。首先介绍这个更简单的例子的细节。</p>
                        <div class="figure" id="GUID-CD3986D6-D50C-4E84-9690-30DE8577C12D__I1044849">
                           <p class="titleinfigure">图18-5 XML模式之间的循环引用</p><img src="img/adxdb013.gif" width="376" alt="下面是图18-5的描述" title="下面是图18-5的描述" longdesc="img_text/adxdb013.html"><br><a href="img_text/adxdb013.html">“图18-5 XML模式之间的循环引用”的描述</a></div>
                        <!-- class="figure" -->
                        <p>如果包含的XML模式不存在，则无法创建包含其他XML模式的XML模式。如果<code class="codeph">xm40a.xsd</code>不存在， <a href="XML-Schema-and-query-object-relational-storage.html#GUID-CD3986D6-D50C-4E84-9690-30DE8577C12D__BHAHABJJ">示例18-31中</a>的XML模式<code class="codeph">xm40.xsd</code>的注册将失败。
                        </p>
                        <p>但是，如果指定选项<code class="codeph">FORCE =&gt; TRUE</code> ，则可以创建XML模式<code class="codeph">xm40.xsd</code> ，如<a href="XML-Schema-and-query-object-relational-storage.html#GUID-CD3986D6-D50C-4E84-9690-30DE8577C12D__BHAHFACD">例18-32所示</a> ：</p>
                        <p>但是，尝试使用XML模式<code class="codeph">xm40.xsd</code> （如<a href="XML-Schema-and-query-object-relational-storage.html#GUID-CD3986D6-D50C-4E84-9690-30DE8577C12D__BHAHFAFF">例18-33</a> ）失败。
                        </p>
                        <p>如果使用<code class="codeph">FORCE</code>选项注册<code class="codeph">xm40a.xsd</code> ，如<a href="XML-Schema-and-query-object-relational-storage.html#GUID-CD3986D6-D50C-4E84-9690-30DE8577C12D__BHAHIGDH">例18-34所示</a> ，则可以使用两个XML模式，如<code class="codeph">CREATE TABLE</code>语句所示。
                        </p>
                        <p>因此，要注册这些相互依赖的XML模式，必须在<code class="codeph">DBMS_XMLSCHEMA.registerSchema</code>为每个模式使用<code class="codeph">FORCE</code>参数，如下所示：</p>
                        <ol>
                           <li>
                              <p>注册<code class="codeph">xm40.xsd</code>并将<code class="codeph">FORCE</code>模式设置为<code class="codeph">TRUE</code> ：</p><pre class="oac_no_warn" dir="ltr">DBMS_XMLSCHEMA.registerSchema（“xm40.xsd”，“&lt;schema ...”，...， <span class="bold">FORCE =&gt; TRUE</span> ）</pre><p>此时， <span class="italic">无法</span>使用<code class="codeph">xm40.xsd</code> 。
                              </p>
                           </li>
                           <li>
                              <p>在<code class="codeph">FORCE</code>模式下注册<code class="codeph">xm40a.xsd</code>设置为<code class="codeph">TRUE</code> ：</p><pre class="oac_no_warn" dir="ltr">DBMS_XMLSCHEMA.registerSchema（“xm40a.xsd”，“&lt;schema ...”，...， <span class="bold">FORCE =&gt; TRUE</span> ）</pre><p>第二个操作自动编译<code class="codeph">xm40.xsd</code>并使两个XML模式都可用。
                              </p>
                           </li>
                        </ol>
                        <div class="example" id="GUID-CD3986D6-D50C-4E84-9690-30DE8577C12D__BHAHABJJ">
                           <p class="titleinexample">示例18-31包含不存在的XML架构的XML架构</p><pre class="oac_no_warn" dir="ltr">BEGIN DBMS_XMLSCHEMA.registerSchema（SCHEMAURL =&gt;' <span class="bold">xm40.xsd</span> '，SCHEMADOC =&gt;'&lt;schema xmlns =“http://www.w3.org/2001/XMLSchema”xmlns：my =“xm40”targetNamespace =“xm40”&gt; <span class="bold">&lt;include schemaLocation =“xm40a.xsd”/&gt;</span> &lt;！ - 在此处定义全局复杂类型 - &gt; &lt;complexType name =“Company”&gt; &lt;sequence&gt; &lt;element name =“Name”type =“string”/&gt; &lt;element name =“Address”type =“string”/&gt; &lt;/ sequence&gt; &lt;/ complexType&gt; &lt;！ - 根据包含的架构定义全局元素 - &gt; &lt;element name =“Emp”type =“my：Employee”/ &gt; &lt;/ schema&gt;'，LOCAL =&gt; TRUE，GENTYPES =&gt; TRUE，GENTABLES =&gt; TRUE）;结束; /</pre></div>
                        <!-- class="example" -->
                        <div class="example" id="GUID-CD3986D6-D50C-4E84-9690-30DE8577C12D__BHAHFACD">
                           <p class="titleinexample">示例18-32使用FORCE选项注册XML架构xm40.xsd</p><pre class="oac_no_warn" dir="ltr">BEGIN DBMS_XMLSCHEMA.registerSchema（SCHEMAURL =&gt;'xm40.xsd'，SCHEMADOC =&gt;'&lt;schema xmlns =“http://www.w3.org/2001/XMLSchema”xmlns：my =“xm40”targetNamespace =“xm40”&gt; &lt;include schemaLocation =“xm40a.xsd”/&gt; &lt;！ - 在此处定义全局复杂类型 - &gt; &lt;complexType name =“Company”&gt; &lt;sequence&gt; &lt;element name =“Name”type =“string”/&gt; &lt;element name =“Address”type =“string”/&gt; &lt;/ sequence&gt; &lt;/ complexType&gt; &lt;！ - 根据包含的架构定义全局元素 - &gt; &lt;element name =“Emp”type =“my：Employee”/ &gt; &lt;/ schema&gt;'，LOCAL =&gt; TRUE，GENTYPES =&gt; TRUE，GENTABLES =&gt; TRUE，FORCE =&gt; <span class="bold">TRUE</span> ）;结束; /</pre></div>
                        <!-- class="example" -->
                        <div class="example" id="GUID-CD3986D6-D50C-4E84-9690-30DE8577C12D__BHAHFAFF">
                           <p class="titleinexample">示例18-33尝试使用循环XML架构创建表</p><pre class="oac_no_warn" dir="ltr">CREATE TABLE foo XMLType XMLSCHEMA“xm40.xsd”ELEMENT“Emp”;</pre></div>
                        <!-- class="example" -->
                        <div class="example" id="GUID-CD3986D6-D50C-4E84-9690-30DE8577C12D__BHAHIGDH">
                           <p class="titleinexample">例18-34使用FORCE选项注册XML模式xm40a.xsd</p><pre class="oac_no_warn" dir="ltr">BEGIN DBMS_XMLSCHEMA.registerSchema（SCHEMAURL =&gt;' <span class="bold">xm40a.xsd</span> '，SCHEMADOC =&gt;'&lt;schema xmlns =“http://www.w3.org/2001/XMLSchema”xmlns：my =“xm40”targetNamespace =“xm40”&gt; <span class="bold">&lt;include schemaLocation =“xm40.xsd”/&gt;</span> &lt;！ - 在此处定义全局复杂类型 - &gt; &lt;complexType name =“Employee”&gt; &lt;sequence&gt; &lt;element name =“Name”type =“string”/&gt; &lt;element name =“Age”type =“positiveInteger”/&gt; &lt;element name =“Phone”type =“string”/&gt; &lt;/ sequence&gt; &lt;/ complexType&gt; &lt;！ - 根据包含的架构定义全局元素 - &gt; &lt; element name =“Comp”type =“my：Company”/&gt; &lt;/ schema&gt;'，LOCAL =&gt; TRUE，GENTYPES =&gt; TRUE，GENTABLES =&gt; TRUE，FORCE =&gt; <span class="bold">TRUE</span> ）;结束; /</pre><pre class="oac_no_warn" dir="ltr">CREATE TABLE foo XMLType XMLSCHEMA“xm40.xsd”ELEMENT“Emp”; CREATE TABLE foo2 OF XMLType XMLSCHEMA“xm40a.xsd”ELEMENT“Comp”;</pre></div>
                        <!-- class="example" -->
                     </div>
                     <div>
                        <div class="familylinks">
                           <div class="parentlink">
                              <p><strong>父主题：</strong> <a href="XML-Schema-and-query-object-relational-storage.html#GUID-CDED9D6F-A153-4A83-BBC3-C2ECC428196D" title="W3C XML Schema Recommendation允许complexTypes和global元素包含递归引用。这种结构允许实例文档，其中所讨论的元素在递归层次结构中可以无限次出现。">XML模式中的循环和循环依赖关系</a></p>
                           </div>
                        </div>
                     </div>
                     
                  </div>
               </div><a id="ADXDB4667"></a><a id="ADXDB0710"></a><div class="props_rev_3"><a id="GUID-B43E7FEE-51C2-413F-A7FB-B023374CB26C" name="GUID-B43E7FEE-51C2-413F-A7FB-B023374CB26C"></a><h4 id="ADXDB-GUID-B43E7FEE-51C2-413F-A7FB-B023374CB26C" class="sect4"><span class="enumeration_section">18.9.2</span>支持递归模式</h4>
                  <div>
                     <p>对于外联表中的递归结构的<code class="codeph">REF</code>可能使重写XPath查询变得困难，因为在编译时不知道结构的深度。要启用XPath重写， <code class="codeph">DOCID</code>列将指向任何递归结构中的根文档。
                     </p>
                     <p>这使得一些XPath查询可以直接使用外联表，并使用此列加入。</p>
                     <p>与<strong class="term">文档相关的递归查询</strong>是使用接受XPath或XQuery表达式和<code class="codeph">XMLType</code>实例的SQL函数的查询，其中该XPath或XQuery表达式包含“ <code class="codeph">//</code> ”。如果可以在查询编译时确定满足以下两个条件，则可以<span class="italic">重写</span>与文档相关的递归查询：</p>
                     <ul style="list-style-type:disc">
                        <li>
                           <p>XPath或XQuery表达式所针对的<code class="codeph">XMLType</code>实例的所有片段都驻留在单个外联表中。
                           </p>
                        </li>
                        <li>
                           <p><code class="codeph">XMLType</code>实例的其他片段不驻留在同一个外联表中。
                           </p>
                        </li>
                     </ul>
                     <p>重写的查询是基于<code class="codeph">DOCID</code>列的外联表的<code class="codeph">DOCID</code> 。
                     </p>
                     <p>使用' <code class="codeph">//</code> '的其他查询也可以重写。例如，如果在模式的不同部分中存在多个相同类型的所有相同类型的<code class="codeph">address</code>元素，并且您经常使用“ <code class="codeph">//</code> ”查询所有<code class="codeph">address</code>元素，而不关心它们在文档中的特定位置，则可以进行重写。
                     </p>
                     <p>在模式注册期间，为外<code class="codeph">DOCID</code> <code class="codeph">XMLType</code>表生成另一个<code class="codeph">DOCID</code>列。此列存储文档的<code class="codeph">OID</code> （对象标识符值），即根元素。在表中插入数据时，将自动填充此列。您可以导出包含<code class="codeph">DOCID</code>列的表并稍后导入它们。
                     </p>
                     <div class="example" id="GUID-B43E7FEE-51C2-413F-A7FB-B023374CB26C__BHAEBJCA">
                        <p class="titleinexample">例18-35递归XML模式</p><pre class="pre codeblock"><code>&lt;schema targetNamespace =“AbcNS”xmlns =“http://www.w3.org/2001/XMLSchema”xmlns：abc =“AbcNS”xmlnm：xdb =“http：//xmlns.oracle.com.xdb”&gt; &lt; element name =“AbcCode”xdb：defaultTable =“ABCCODETAB”&gt; &lt;complexType&gt; &lt;sequence&gt; &lt;element ref =“abc：AbcSection”/&gt; &lt;/ sequence&gt; &lt;/ complexType&gt; &lt;/ element&gt; &lt;element name =“AbcSection” &gt; &lt;complexType&gt; &lt;sequence&gt; &lt;element name =“ID”type =“integer”/&gt; &lt;element name =“Contents”type =“string”/&gt; &lt;element ref =“abc：AbcSection”/&gt; &lt;/ sequence&gt; &lt;/ complexType&gt; &lt;/ element&gt; &lt;/ schema&gt;</code></pre></div>
                     <!-- class="example" -->
                  </div>
                  <div>
                     <ul class="ullinks">
                        <li class="ulchildlink"><a href="XML-Schema-and-query-object-relational-storage.html#GUID-25C3FAE7-5B36-4EFC-8747-5729321E22DB">defaultTable在常见的外线元素中共享</a><br>具有相同限定名称（名称空间和本地名称）和相同类型的外部元素存储在同一默认表中。作为一种特殊情况，您可以将循环元素结构的根元素存储在与子元素相同的表中。
                        </li>
                        <li class="ulchildlink"><a href="XML-Schema-and-query-object-relational-storage.html#GUID-6A4D3B64-7438-494E-9698-298716FC8C13">当DOCID存在时查询重写</a><br>在处理<code class="codeph">//</code> XPath表达式之前，请检查以查找同一元素的多个匹配项。如果<code class="codeph">//</code>下的所有匹配共享相同的<code class="codeph">defaultTable</code>则可以使用<code class="codeph">DOCID</code>对该表重写该查询。</li>
                        <li class="ulchildlink"><a href="XML-Schema-and-query-object-relational-storage.html#GUID-E4CCB4F6-6FE4-41F3-8B83-76393E0A1261">DOCID列创建禁用</a><br>您可以通过在调用<code class="codeph">DBMS_XMLSCHEMA.registerSchema</code>时指定<code class="codeph">OPTIONS</code>参数来禁用列<code class="codeph">DOCID</code>的创建。这会禁用在架构注册期间生成的所有<code class="codeph">XMLType</code>表中的<code class="codeph">DOCID</code>创建。
                        </li>
                     </ul>
                     <div class="familylinks">
                        <div class="parentlink">
                           <p><strong>父主题：</strong> <a href="XML-Schema-and-query-object-relational-storage.html#GUID-A9BDECE7-16AF-4CA4-96D5-5B03FA3E94CE" title="XML模式可能很复杂。复杂模式的示例包括递归模式和包含循环或循环引用的模式。使用复杂或大型XML模式可能具有挑战性，并且需要考虑某些因素。">使用复杂或大型XML架构的注意事项</a></p>
                        </div>
                     </div>
                  </div>
                  <a id="ADXDB4669"></a><a id="ADXDB4670"></a><a id="ADXDB4668"></a><div class="props_rev_3"><a id="GUID-25C3FAE7-5B36-4EFC-8747-5729321E22DB" name="GUID-25C3FAE7-5B36-4EFC-8747-5729321E22DB"></a><h5 id="ADXDB-GUID-25C3FAE7-5B36-4EFC-8747-5729321E22DB" class="sect5"><span class="enumeration_section">18.9.2.1</span> defaultTable在常见的外线元素之间共享</h5>
                     <div>
                        <p>具有相同限定名称（名称空间和本地名称）和相同类型的外部元素存储在同一默认表中。作为一种特殊情况，您可以将循环元素结构的根元素存储在与子元素相同的表中。</p>
                        <p>共享默认表的两个元素必须是外部元素，也就是说，外部元素的默认表不能与顶级元素的表相同。为此，请为两个元素指定<code class="codeph">xdb:SQLInline = "false"</code> ，并指定在两个元素中具有相同值的显式<code class="codeph">xdb:defaultTable</code>属性。
                        </p>
                        <p><a href="XML-Schema-and-query-object-relational-storage.html#GUID-25C3FAE7-5B36-4EFC-8747-5729321E22DB__CHDHDJBC">例18-36</a>显示了一个XML模式，其中包含存储在<code class="codeph">ABCSECTIONTAB</code>中的外<code class="codeph">ABCSECTIONTAB</code>表。</p>
                        <p><a href="XML-Schema-and-query-object-relational-storage.html#GUID-25C3FAE7-5B36-4EFC-8747-5729321E22DB__CHDHDJBC">例18-36中的</a>两个外联<code class="codeph">AbcSection</code>元素共享相同的默认表<code class="codeph">ABCSECTIONTAB</code> 。</p>
                        <p>但是， <a href="XML-Schema-and-query-object-relational-storage.html#GUID-25C3FAE7-5B36-4EFC-8747-5729321E22DB__BHAFGIHA">示例18-37</a>说明了<span class="italic">无效的</span>默认表共享：递归元素（ <code class="codeph">XyZSection</code> ）不共享相同的外联表。
                        </p>
                        <p>以下查询无法重写。</p><pre class="pre codeblock"><code>从xyzcode中选择XMLQuery（'// XyzSection'PASSING OBJECT_VALUE RETURNING CONTENT）;</code></pre><div class="example" id="GUID-25C3FAE7-5B36-4EFC-8747-5729321E22DB__CHDHDJBC">
                           <p class="titleinexample">例18-36外线表</p><pre class="pre codeblock"><code>&lt;schema targetNamespace =“AbcNS”xmlns =“http://www.w3.org/2001/XMLSchema”xmlns：abc =“AbcNS”xmlns：xdb =“http://xmlns.oracle.com/xdb”&gt; &lt; element name =“AbcCode”xdb：defaultTable =“ABCCODETAB”&gt; &lt;complexType&gt; &lt;sequence&gt; &lt;element ref =“abc：AbcSection”xdb：SQLInline =“false”/&gt; &lt;/ sequence&gt; &lt;/ complexType&gt; &lt;/ element&gt; &lt;element name =“AbcSection”xdb：defaultTable =“”&gt; &lt;complexType&gt; &lt;sequence&gt; &lt;element name =“ID”type =“integer”/&gt; &lt;element name =“Contents”type =“string”/&gt; &lt;element ref =“abc：AbcSection” <span class="bold">xdb：SQLInline =“false”</span> xdb：defaultTable =“ <span class="bold">ABCSECTIONTAB</span> ”/&gt; &lt;/ sequence&gt; &lt;/ complexType&gt; &lt;/ element&gt; &lt;/ schema&gt;</code></pre></div>
                        <!-- class="example" -->
                        <div class="example" id="GUID-25C3FAE7-5B36-4EFC-8747-5729321E22DB__BHAFGIHA">
                           <p class="titleinexample">示例18-37无效的默认表共享</p><pre class="pre codeblock"><code>&lt;schema targetNamespace =“XyzNS”xmlns =“http://www.w3.org/2001/XMLSchema”xmlns：xyz =“XyzNS”xmlns：xdb =“http://xmlns.oracle.com/xdb”&gt; &lt; element name =“XyzCode”xdb：defaultTable =“XYZCODETAB”&gt; &lt;complexType&gt; &lt;sequence&gt; &lt;element name =“CodeNumber”type =“integer”minOccurs =“0”/&gt; &lt;element ref =“xyz：XyzChapter”xdb： SQLInline =“false”/&gt; &lt;element ref =“xyz：XyzPara”xdb：SQLInline =“false”/&gt; &lt;/ sequence&gt; &lt;/ complexType&gt; &lt;/ element&gt; &lt;element name =“XyzChapter”xdb：defaultTable =“XYZCHAPTAB “&gt; &lt;complexType&gt; &lt;sequence&gt; &lt;element name =”Title“type =”string“/&gt; &lt;element ref =”xyz：XyzSection“xdb：SQLInline =”false“ <span class="bold">xdb：defaultTable =”XYZSECTIONTAB“</span> /&gt; &lt;/ sequence &gt; &lt;/ complexType&gt; &lt;/ element&gt; &lt;element name =“XyzPara”xdb：defaultTable =“XYZPARATAB”&gt; &lt;complexType&gt; &lt;sequence&gt; &lt;element name =“Title”type =“string”/&gt; &lt;element ref =“xyz ：XyzSection“xdb：SQLInline =”false“ <span class="bold">xdb：defaultTable =”Other_XYZSECTIONTAB</span> “/&gt; &lt;/ sequence&gt; &lt;/ complexType&gt; &lt;/ element&gt; &lt;element name =”XyzSection“&gt; &lt;complexType&gt; &lt;sequence&gt; &lt;element name =” ID“type =”integer“/&gt; &lt;element name =“Contents”type =“string”/&gt; &lt;element ref =“xyz：XyzSection”xdb：defaultTable =“XYZSECTIONTAB”/&gt; &lt;/ sequence&gt; &lt;/ complexType&gt; &lt;/ element&gt; &lt;/ schema&gt;</code></pre></div>
                        <!-- class="example" -->
                     </div>
                     <div>
                        <div class="familylinks">
                           <div class="parentlink">
                              <p><strong>父主题：</strong> <a href="XML-Schema-and-query-object-relational-storage.html#GUID-B43E7FEE-51C2-413F-A7FB-B023374CB26C" title="对于外联表中的递归结构的REF可能使重写XPath查询变得困难，因为在编译时不知道结构的深度。要启用XPath重写，DOCID列将指向任何递归结构中的根文档。">支持递归模式</a></p>
                           </div>
                        </div>
                     </div>
                     
                  </div><a id="ADXDB4671"></a><div class="props_rev_3"><a id="GUID-6A4D3B64-7438-494E-9698-298716FC8C13" name="GUID-6A4D3B64-7438-494E-9698-298716FC8C13"></a><h5 id="ADXDB-GUID-6A4D3B64-7438-494E-9698-298716FC8C13" class="sect5"><span class="enumeration_section">18.9.2.2</span>当DOCID存在时查询重写</h5>
                     <div>
                        <p>在处理<code class="codeph">//</code> XPath表达式之前，请检查以查找同一元素的多个匹配项。如果<code class="codeph">//</code>下的所有匹配共享相同的<code class="codeph">defaultTable</code>则可以使用<code class="codeph">DOCID</code>对该表重写该查询。</p>
                        <p>如果在根共享该表的情况下存在同一元素的其他事件，但不在<code class="codeph">//</code>下，则无法重写查询。
                        </p>
                        <p>例如，考虑这个元素结构：</p>
                        <p><code class="codeph">&lt;Book&gt;</code>包含<code class="codeph">&lt;Chapter&gt;</code>和<code class="codeph">&lt;Part&gt;</code> 。 <code class="codeph">&lt;Part&gt;</code>包含<code class="codeph">&lt;Chapter&gt;</code> 。
                        </p>
                        <p>假设两个<code class="codeph">&lt;Chapter&gt;</code>元素都存储在行外，并且它们共享相同的默认表。可以重写query <code class="codeph">/Book//Chapter</code>以反对<code class="codeph">&lt;Chapter&gt;</code>元素的默认表，因为<code class="codeph">&lt;Book&gt;</code>下的所有<code class="codeph">&lt;Chapter&gt;</code>元素共享相同的默认表。因此，此XPath查询是与文档相关的递归XPath查询。
                        </p>
                        <p>但是，无法重写诸如<code class="codeph">/Book/Part//Chapter</code>类的查询，即使<code class="codeph">&lt;Part&gt;</code>下的所有<code class="codeph">&lt;Chapter&gt;</code>元素共享同一个表，因为<code class="codeph">&lt;Book&gt;</code>下还有另一个<code class="codeph">&lt;Chapter&gt;</code>元素，这是同时共享该表的文档根目录。
                        </p>
                        <p>考虑使用<code class="codeph">DOCID</code>提取<code class="codeph">//AbcSection</code>的情况，如<a href="XML-Schema-and-query-object-relational-storage.html#GUID-25C3FAE7-5B36-4EFC-8747-5729321E22DB__CHDHDJBC">例18-36中</a>描述的XML模式：</p><pre class="oac_no_warn" dir="ltr">从abccodetab中选择XMLQuery（'// // AbcSection'PASSING OBJECT_VALUE RETURNING CONTENT）;</pre><p>两个<code class="codeph">AbcSection</code>元素都存储在同一个表<code class="codeph">abcsectiontab</code> 。提取适用于基础表<code class="codeph">abcsectiontab</code> 。
                        </p>
                        <p>当<code class="codeph">DOCID</code>存在时考虑此查询：</p><pre class="oac_no_warn" dir="ltr">SELECT XMLQuery（'/ AbcCode / AbcSection // AbcSection'PASSING OBJECT_VALUE RETURNING CONTENT）来自abccodetab;</pre><p>在这种情况和前一种情况下，所有可到达的<code class="codeph">AbcSection</code>元素都存储在同一个外联表中。但是，此查询无法检索<code class="codeph">/AbcCode/AbcSection</code>的第一个<code class="codeph">AbcSection</code>元素。由于连接条件是<code class="codeph">DOCID</code> ，它无法区分父文档中的不同位置，因此无法通过表<code class="codeph">abcsectiontab</code>上的直接查询来实现正确的结果。在这种情况下，不会发生查询重写，因为它不是与文档相关的递归XPath。如果此顶级<code class="codeph">AbcSection</code>未与其余部分存储<code class="codeph">AbcSection</code> ，则可以重写查询。
                        </p>
                     </div>
                     <div>
                        <div class="familylinks">
                           <div class="parentlink">
                              <p><strong>父主题：</strong> <a href="XML-Schema-and-query-object-relational-storage.html#GUID-B43E7FEE-51C2-413F-A7FB-B023374CB26C" title="对于外联表中的递归结构的REF可能使重写XPath查询变得困难，因为在编译时不知道结构的深度。要启用XPath重写，DOCID列将指向任何递归结构中的根文档。">支持递归模式</a></p>
                           </div>
                        </div>
                     </div>
                     
                  </div><a id="ADXDB4672"></a><div class="props_rev_3"><a id="GUID-E4CCB4F6-6FE4-41F3-8B83-76393E0A1261" name="GUID-E4CCB4F6-6FE4-41F3-8B83-76393E0A1261"></a><h5 id="ADXDB-GUID-E4CCB4F6-6FE4-41F3-8B83-76393E0A1261" class="sect5"><span class="enumeration_section">18.9.2.3</span> DOCID列创建禁用</h5>
                     <div>
                        <p>您可以通过在调用<code class="codeph">DBMS_XMLSCHEMA.registerSchema</code>时指定<code class="codeph">OPTIONS</code>参数来禁用列<code class="codeph">DOCID</code>的创建。这会禁用在架构注册期间生成的所有<code class="codeph">XMLType</code>表中的<code class="codeph">DOCID</code>创建。
                        </p>
                        <p><code class="codeph">OPTIONS</code>是数据类型<code class="codeph">PLS_INTEGER</code>的输入参数。其默认值为<code class="codeph">0</code> ，表示不使用任何选项。要禁止生成列<code class="codeph">DOCID</code> ，请将参数<code class="codeph">OPTIONS</code>设置为<code class="codeph">DBMS_XMLSCHEMA.REGISTER_NODOCID</code> （即<code class="codeph">1</code> ）。
                        </p>
                     </div>
                     <div>
                        <div class="infoboxnotealso" id="GUID-E4CCB4F6-6FE4-41F3-8B83-76393E0A1261__GUID-BEB9DBA0-52ED-4E58-9B41-9FA5A3801D3D">
                           <p class="notep1">也可以看看：</p>
                           <p><a href="../arpls/DBMS_XMLSCHEMA.html#ARPLS377" target="_blank"><span><cite>Oracle数据库PL / SQL包和类型参考</cite></span></a></p>
                        </div>
                        <div class="familylinks">
                           <div class="parentlink">
                              <p><strong>父主题：</strong> <a href="XML-Schema-and-query-object-relational-storage.html#GUID-B43E7FEE-51C2-413F-A7FB-B023374CB26C" title="对于外联表中的递归结构的REF可能使重写XPath查询变得困难，因为在编译时不知道结构的深度。要启用XPath重写，DOCID列将指向任何递归结构中的根文档。">支持递归模式</a></p>
                           </div>
                        </div>
                     </div>
                     
                  </div>
               </div><a id="ADXDB4638"></a><a id="ADXDB4637"></a><a id="ADXDB4636"></a><div class="props_rev_3"><a id="GUID-80571C92-AB92-40F6-B067-01E228534C9D" name="GUID-80571C92-AB92-40F6-B067-01E228534C9D"></a><h4 id="ADXDB-GUID-80571C92-AB92-40F6-B067-01E228534C9D" class="sect4"><span class="enumeration_section">18.9.3</span> XML片段可以映射到大对象（LOB）</h4>
                  <div>
                     <p>您可以将用于复杂元素的SQL数据类型指定为<code class="codeph">CLOB</code>或<code class="codeph">BLOB</code> 。</p>
                     <p>例如，在<a href="XML-Schema-and-query-object-relational-storage.html#GUID-80571C92-AB92-40F6-B067-01E228534C9D__I1044845">图18-6中</a> ，整个XML片段存储在LOB属性中。
                     </p>
                     <p>在<a href="XML-Schema-and-query-object-relational-storage.html#GUID-80571C92-AB92-40F6-B067-01E228534C9D__BHAFGFDA">例18-38中</a> ，XML模式使用注释<code class="codeph">SQLType = "CLOB"</code>定义元素<code class="codeph">Addr</code> ：</p>
                     <div class="figure" id="GUID-80571C92-AB92-40F6-B067-01E228534C9D__I1044845">
                        <p class="titleinfigure">图18-6将complexType XML片段映射到CLOB实例</p><img src="img/adxdb011.gif" width="249" alt="下面是图18-6的描述" title="下面是图18-6的描述" longdesc="img_text/adxdb011.html"><br><a href="img_text/adxdb011.html">“图18-6将complexType XML片段映射到CLOB实例”的说明</a></div>
                     <!-- class="figure" -->
                     <div class="example" id="GUID-80571C92-AB92-40F6-B067-01E228534C9D__BHAFGFDA">
                        <p class="titleinexample">示例18-38 Oracle XML DB XML架构：将complexType XML片段映射到LOB</p><pre class="oac_no_warn" dir="ltr">DECLARE doc VARCHAR2（3000）：='&lt;schema xmlns =“http://www.w3.org/2001/XMLSchema”targetNamespace =“http://www.oracle.com/emp.xsd”xmlns：emp =“ http://www.oracle.com/emp.xsd“xmlns：xdb =”http://xmlns.oracle.com/xdb“&gt; &lt;complexType name =”Employee“xdb：SQLType =”OBJ_T“&gt; &lt;sequence&gt; &lt;element name =“Name”type =“string”/&gt; &lt;element name =“Age”type =“decimal”/&gt; <span class="bold">&lt;element name =“Addr”xdb：SQLType =“CLOB”&gt;</span> &lt;complexType&gt; &lt;sequence&gt; &lt; element name =“Street”type =“string”/&gt; &lt;element name =“City”type =“string”/&gt; &lt;/ sequence&gt; &lt;/ complexType&gt; &lt;/ element&gt; &lt;/ sequence&gt; &lt;/ complexType&gt; &lt;/ schema &gt;'; BEGIN DBMS_XMLSCHEMA.registerSchema（SCHEMAURL =&gt;'http://www.oracle.com/PO.xsd'，SCHEMADOC =&gt; doc）;结束;</pre><p>注册此XML架构时，Oracle XML DB会生成以下类型和<code class="codeph">XMLType</code>表：</p><pre class="oac_no_warn" dir="ltr">CREATE TYPE obj_t AS OBJECT（SYS_XDBPD $ XDB.XDB $ RAW_LIST_T，Name VARCHAR2（4000），Age NUMBER，Addr CLOB）;</pre></div>
                     <!-- class="example" -->
                  </div>
                  <div>
                     <div class="familylinks">
                        <div class="parentlink">
                           <p><strong>父主题：</strong> <a href="XML-Schema-and-query-object-relational-storage.html#GUID-A9BDECE7-16AF-4CA4-96D5-5B03FA3E94CE" title="XML模式可能很复杂。复杂模式的示例包括递归模式和包含循环或循环引用的模式。使用复杂或大型XML模式可能具有挑战性，并且需要考虑某些因素。">使用复杂或大型XML架构的注意事项</a></p>
                        </div>
                     </div>
                  </div>
                  
               </div><a id="ADXDB6315"></a><div class="props_rev_3"><a id="GUID-5F470098-54C0-4FC6-8E7B-732487497F90" name="GUID-5F470098-54C0-4FC6-8E7B-732487497F90"></a><h4 id="ADXDB-GUID-5F470098-54C0-4FC6-8E7B-732487497F90" class="sect4"><span class="enumeration_section">18.9.4</span> ORA-01792和ORA-04031：大型XML模式的问题</h4>
                  <div>
                     <p>使用大型或复杂的XML模式时，可能会引发错误<code class="codeph">ORA-01792</code>和<code class="codeph">ORA-04031</code> 。注册XML模式或创建基于XML模式定义的全局元素的表时，可以遇到它们。
                     </p>
                     <ul style="list-style-type:disc">
                        <li>
                           <p><code class="codeph">ORA-01792：表或视图中的最大列数为1000</code></p>
                        </li>
                        <li>
                           <p><code class="codeph">ORA-04031: unable to allocate</code> <code class="codeph">bytes of shared memory ("</code> <span class="italic"><code class="codeph">string</code></span> <code class="codeph">bytes of shared memory ("</code> <span class="italic"><code class="codeph">string</code></span> <code class="codeph">","</code> <span class="italic"><code class="codeph">string</code></span> <code class="codeph">","</code> <span class="italic"><code class="codeph">string</code></span> <code class="codeph">","</code> <span class="italic"><code class="codeph">string</code></span> ” <code class="codeph">)</code></p>
                        </li>
                     </ul>
                     <p>当您尝试基于全局元素创建<code class="codeph">XMLType</code>表或列时会引发这些错误，并且全局元素被定义为包含大量元素和属性定义的<code class="codeph">complexType</code> 。
                     </p>
                     <p>仅在创建使用对象关系存储的<code class="codeph">XMLType</code>表或列时才会引发它们。使用SQL类型持久化表或列，SQL类型定义的每个对象属性都计为基础表中的一列。如果SQL类型包含基于其他SQL类型的对象属性，则这些类型定义的属性也将计为基础表中的列。
                     </p>
                     <p>如果所有SQL类型中的对象属性总数超过表中的Oracle数据库限制1000列，则无法创建存储表。当<code class="codeph">complexType</code>定义的元素和属性的总数达到1000时，无法创建可以管理在该类型的实例存储在数据库中时生成的SQL对象的单个表。
                     </p>
                     <div class="infobox-tip" id="GUID-5F470098-54C0-4FC6-8E7B-732487497F90__GUID-C550F651-743C-4A2E-8924-2378911A8A3A">
                        <p class="notep1">小费：</p>
                        <p>您可以使用以下查询来确定以对象方式存储的给定<code class="codeph">XMLType</code>表的列数：</p><pre class="pre codeblock"><code>SELECT count（*）FROM USER_TAB_COLS WHERE TABLE_NAME =' <span class="italic">&lt;table&gt;</span> '</code></pre><p>其中<span class="italic"><code class="codeph">&lt;the table&gt;</code></span>是您要检查的表。
                        </p>
                     </div>
                     <p>错误<code class="codeph">ORA-01792</code>报告已超出1000列限制。错误<code class="codeph">ORA-04031</code>报告在处理大量元素和属性定义期间内存不足。要解决包含太多元素和属性定义的问题，必须减少用于创建存储表的SQL类型中的对象属性总数。
                     </p>
                     <p>有两种方法可以实现这种减少：</p>
                     <ul style="list-style-type:disc">
                        <li>
                           <p>使用自上而下的技术，使用<span class="italic">多个</span> <code class="codeph">XMLType</code> <span class="italic">表</span>来管理XML文档。这减少了给定存储表的SQL类型层次结构中的SQL属性数。只要没有表需要管理超过1000个对象属性，问题就解决了。
                           </p>
                        </li>
                        <li>
                           <p>使用自底向上技术，该技术可减少SQL类型层次结构中SQL属性的数量， <span class="italic">折叠</span> XML架构定义的<span class="italic">某些元素和属性</span> ，以便将它们存储为单个<code class="codeph">CLOB</code>值。
                           </p>
                        </li>
                     </ul>
                     <p>这两种技术都依赖于注释XML模式来定义特定<code class="codeph">complexType</code>如何存储在数据库中。
                     </p>
                     <p>对于自上而下的技术，注释<code class="codeph">SQLInline = "false"</code>和<code class="codeph">defaultTable</code>强制XML文档中的某些子元素作为行存储在单独的<code class="codeph">XMLType</code>表中。Oracle XML DB使用<code class="codeph">XMLType</code>的<code class="codeph">REF</code>维护两个表之间的关系。这种方法的优秀候选者是XML模式，它可以执行以下任一操作：</p>
                     <ul style="list-style-type:disc">
                        <li>
                           <p>定义一个<span class="italic">选项</span> ，其中<span class="italic">选择</span>中的每个元素都定义为<code class="codeph">complexType</code></p>
                        </li>
                        <li>
                           <p>基于包含<span class="italic">大量元素和属性定义</span>的<code class="codeph">complexType</code> <span class="italic">定义元素</span></p>
                        </li>
                     </ul>
                     <p>自下而上的技术涉及通过选择将一些较低级别的<code class="codeph">complexType</code>元素存储为<code class="codeph">CLOB</code>值而不是作为对象来减少SQL对象类型中的属性总数。这是通过注解来实现<code class="codeph">complexType</code>或的使用<code class="codeph">complexType</code>与<code class="codeph">SQLType = "CLOB"</code> 。
                     </p>
                     <p>您使用哪种技术取决于应用程序以及要对数据执行的查询和更新的类型。</p>
                  </div>
                  <div>
                     <div class="familylinks">
                        <div class="parentlink">
                           <p><strong>父主题：</strong> <a href="XML-Schema-and-query-object-relational-storage.html#GUID-A9BDECE7-16AF-4CA4-96D5-5B03FA3E94CE" title="XML模式可能很复杂。复杂模式的示例包括递归模式和包含循环或循环引用的模式。使用复杂或大型XML模式可能具有挑战性，并且需要考虑某些因素。">使用复杂或大型XML架构的注意事项</a></p>
                        </div>
                     </div>
                  </div>
                  
               </div><a id="ADXDB4678"></a><div class="props_rev_3"><a id="GUID-32930A3C-AFD4-4950-94B6-B26ACAFBC70D" name="GUID-32930A3C-AFD4-4950-94B6-B26ACAFBC70D"></a><h4 id="ADXDB-GUID-32930A3C-AFD4-4950-94B6-B26ACAFBC70D" class="sect4"><span class="enumeration_section">18.9.5</span>加载和检索带有集合的大型文档的注意事项</h4>
                  <div>
                     <p>Oracle XML DB配置文件<code class="codeph">xdbconfig.xml</code>具有控制加载操作使用的内存量的参数： <code class="codeph">xdbcore-loadableunit-size</code>和<code class="codeph">xdbcore-xobmem-bound</code> 。
                     </p>
                     <p>如果满足以下条件，这些可让您优化加载过程：</p>
                     <ul style="list-style-type:disc">
                        <li>
                           <p>使用以下方法之一加载文档：</p>
                           <ul style="list-style-type:disc">
                              <li>
                                 <p>协议（FTP，HTTP（S）或DAV）</p>
                              </li>
                              <li>
                                 <p>PL / SQL函数<code class="codeph">DBMS_XDB_REPOS.createResource</code></p>
                              </li>
                              <li>
                                 <p>SQL <code class="codeph">INSERT</code>语句到<code class="codeph">XMLType</code>表（但不是<code class="codeph">XMLType</code>列）</p>
                              </li>
                           </ul>
                        </li>
                        <li>
                           <p>该文档是基于XML模式的，包含大型集合（ <code class="codeph">maxOccurs</code>设置为大数的元素）。
                           </p>
                        </li>
                        <li>
                           <p>文档中的集合存储为OCT。这是默认行为。</p>
                        </li>
                     </ul>
                     <p>在以下情况中，优化有时不是最理想的：</p>
                     <ul style="list-style-type:disc">
                        <li>
                           <p>当基表上有触发器时。</p>
                        </li>
                        <li>
                           <p>基表分区时。</p>
                        </li>
                        <li>
                           <p>集合存储在行外时（仅适用于SQL <code class="codeph">INSERT</code> ）。
                           </p>
                        </li>
                     </ul>
                     <p>这种优化背后的基本思想是它允许集合以有界大小交换进出内存。为了说明这个想法，请考虑以下示例符合采购订单XML架构：</p><pre class="pre codeblock"><code>&lt;PurchaseOrder&gt; &lt;LineItem itemID =“1”&gt; ...&lt;/ LineItem&gt;。。&lt;LineItem itemID =“10240”&gt; ...&lt;/ LineItem&gt; &lt;/ PurchaseOrder&gt;</code></pre><p>此处的采购订单文档包含10240个<code class="codeph">LineItem</code>元素的集合。在内存中创建整个文档然后将其推送到磁盘可能会导致内存使用过多，并且在某些情况下由于系统内存不足而导致加载失败。
                     </p>
                     <p>为避免这种情况，您可以在称为<strong class="term">可加载单元的</strong>有限内存块中创建文档。
                     </p>
                     <p>在示例的情况下，假设每个行项目需要1 KB的内存，并且您希望每个行项目使用512 KB的可加载单元。然后每个可装载单元包含512个行项目，并且大约有20个这样的单元。如果您希望文档的整个内存表示永远不会超过2 MB，则必须确保在任何时候内存中不会保留不超过4个可加载单元。您可以使用LRU机制交换可加载单元。</p>
                     <p>通过控制可加载单元的大小和文档大小的界限，您可以调整内存使用情况和加载或检索的性能。通常，较大的可加载单元大小转换为较少数量的磁盘访问，但它需要更多内存。这由配置参数<code class="codeph">xdbcore-loadableunit-size</code> ，其默认值为16 KB。您可以通过设置参数<code class="codeph">xdbcore-xobmem-bound</code>来指示要为文档指定的内存量，默认值为1 MB。这些参数的值以千字节为单位。因此， <code class="codeph">xdbcore-xobmem-bound</code>的默认值为1024， <code class="codeph">xdbcore-loadableunit-size</code>的默认值为16。这些是软限制，为系统提供有关如何最佳使用内存的一些指导。
                     </p>
                     <p>使用FTP加载文档时，创建可加载单元（LU）并刷新到磁盘的模式如下：</p><pre class="pre codeblock"><code>无LU创建LU1 [LineItems（LI）：1-512] LU1 [LI：1-512]，创建LU2 [LI：513-1024]。。LU1 [LI：1-512]，...，创建LU4 [LI：1517：2028] &lt; - 总内存大小= 2M交换LU1 [LI：1-512]，LU2 [LI：513-1024] ,. ..，LU4 [LI：1517-2028]，创建LU5 [LI：2029-2540]交换LU2 [LI：513-1024]，LU3，LU4，LU5，创建LU6 [LI：2541-2052]。。。换出LU16，LU17，LU18，LU10，创建LU20 [LI：9729-10240] Flush LU17，LU18，LU19，LU20</code></pre></div>
                  <div>
                     <ul class="ullinks">
                        <li class="ulchildlink"><a href="XML-Schema-and-query-object-relational-storage.html#GUID-1B84F42B-18DC-4BA5-A1C6-651101408B11">配置参数指南xdbcore-loadableunit-size和xdbcore-xobmem-bound</a><br>使用PGA大小和反复试验来确定配置参数<code class="codeph">xdbcore-loadableunit-size</code>和<code class="codeph">xdbcore-xobmem-bound</code>的最佳值。
                        </li>
                     </ul>
                     <div class="familylinks">
                        <div class="parentlink">
                           <p><strong>父主题：</strong> <a href="XML-Schema-and-query-object-relational-storage.html#GUID-A9BDECE7-16AF-4CA4-96D5-5B03FA3E94CE" title="XML模式可能很复杂。复杂模式的示例包括递归模式和包含循环或循环引用的模式。使用复杂或大型XML模式可能具有挑战性，并且需要考虑某些因素。">使用复杂或大型XML架构的注意事项</a></p>
                        </div>
                     </div>
                  </div>
                  <a id="ADXDB4679"></a><div class="props_rev_3"><a id="GUID-1B84F42B-18DC-4BA5-A1C6-651101408B11" name="GUID-1B84F42B-18DC-4BA5-A1C6-651101408B11"></a><h5 id="ADXDB-GUID-1B84F42B-18DC-4BA5-A1C6-651101408B11" class="sect5"><span class="enumeration_section">18.9.5.1</span>配置参数指南xdbcore-loadableunit-size和xdbcore-xobmem-bound</h5>
                     <div>
                        <p>使用PGA大小和反复试验来确定配置参数<code class="codeph">xdbcore-loadableunit-size</code>和<code class="codeph">xdbcore-xobmem-bound</code>的最佳值。
                        </p>
                        <p>通常情况下，如果你有1 GB的可寻址PG，那么给文档提供大约1/10的PGA。将<code class="codeph">xobcore-xobmem-bound</code>为1/10的可寻址PGA，即100M。在完整文档检索和加载期间， <code class="codeph">xdbcore-loadableunit-size</code>的值应尽可能接近<code class="codeph">xobcore-xobmem-bound</code>的值。
                        </p>
                        <p>首先将<code class="codeph">xdbcore-loadableunit-size</code>设置为<code class="codeph">xdbcore-xobmem-bound</code> （50 MB）值的一半。然后尝试加载文档。
                        </p>
                        <p>如果内存不足，则减小<code class="codeph">xdbcore-xobmem-bound</code>的值，并将<code class="codeph">xdbcore-loadableunot-size</code>设置<code class="codeph">xdbcore-loadableunot-size</code>值的一半。继续这种方式，直到文档成功加载。
                        </p>
                        <p>如果加载操作成功，则尝试增加<code class="codeph">xdbcore-loadableunit-size</code> ，以获得更好的性能。如果<code class="codeph">xdbcore-loadableunit-size</code>等于<code class="codeph">xdbcore-xobmem-bound</code> ，则尝试增加两个参数值以进一步提高性能。
                        </p>
                     </div>
                     <div>
                        <div class="familylinks">
                           <div class="parentlink">
                              <p><strong>父主题：</strong> <a href="XML-Schema-and-query-object-relational-storage.html#GUID-32930A3C-AFD4-4950-94B6-B26ACAFBC70D" title="Oracle XML DB配置文件xdbconfig.xml具有控制加载操作使用的内存量的参数：xdbcore-loadableunit-size和xdbcore-xobmem-bound。">使用集合加载和检索大型文档的注意事项</a></p>
                           </div>
                        </div>
                     </div>
                     
                  </div>
               </div>
            </div><a id="ADXDB4463"></a><div class="props_rev_3"><a id="GUID-D17B71BD-2AC2-4EC6-ADE3-8FE626FEC156" name="GUID-D17B71BD-2AC2-4EC6-ADE3-8FE626FEC156"></a><h3 id="ADXDB-GUID-D17B71BD-2AC2-4EC6-ADE3-8FE626FEC156" class="sect3"><span class="enumeration_section">18.10</span>调试XML数据的XML模式注册存储对象 - 关系</h3>
               <div>
                  <p>对于以对象关系存储的XML数据，您可以通过在调用PL / SQL过程<code class="codeph">DBMS_XMLSCHEMA.registerSchema</code>之前设置事件31098来监视在XML模式注册期间创建的对象类型和表。
                  </p>
                  <div class="section"><pre class="pre codeblock"><code>ALTER SESSION SET EVENTS ='31098 TRACE NAME CONTEXT FOREVER'</code></pre><p>设置此事件会导致生成所有<code class="codeph">CREATE TYPE</code>和<code class="codeph">CREATE TABLE</code>语句的日志。日志将写入用户会话跟踪文件，通常位于<code class="codeph">ORACLE_BASE/diag/rdbms/ORACLE_SID/ORACLE_SID/udump</code> 。此跟踪输出可以帮助诊断XML模式注册期间的问题。
                     </p>
                  </div>
                  <!-- class="section" -->
               </div>
               <div>
                  <div class="familylinks">
                     <div class="parentlink">
                        <p><strong>父主题：</strong> <a href="XML-Schema-and-query-object-relational-storage.html#GUID-B0C1A0B0-2DD1-491A-8CE1-1F857FD267B7" title="基于XML Schema的数据的高级技术包括使用对象关系存储;注释XML模式;将Schema数据类型映射到SQL;使用complexType扩展和限制;创建，指定关系约束，分区基于XML Schema的数据，存储XMLType数据，使用复杂或大型模式，以及调试模式注册。">XML模式存储和查询：对象关系存储</a></p>
                     </div>
                  </div>
               </div>
               
            </div>
            <hr><br><p style="text-decoration:underline">脚注图例</p>脚注3：<p>该值32767假定初始化参数<code class="codeph">MAX_STRING_SIZE</code>值为<code class="codeph">EXTENDED</code> 。请参见<a href="../sqlrf/Data-Types.html#SQLRF55623" target="_blank"><span><cite>Oracle数据库SQL语言参考</cite></span></a> 。
            </p><br></div>
      </article>
   </body>
</html>