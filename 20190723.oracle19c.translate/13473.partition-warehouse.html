<html lang="en-us" dir="ltr" xml:lang="en-us">
   <head>
      <meta http-equiv="Content-Type" content="text/html; charset=utf-8"></meta>
      <meta name="viewport" content="width=device-width, initial-scale=1"></meta>
      <meta http-equiv="X-UA-Compatible" content="IE=edge"></meta>
      <meta name="abstract" content="Partitioning features can improve performance in a data warehouse environment."></meta>
      <meta name="description" content="Partitioning features can improve performance in a data warehouse environment."></meta>
      <title>在数据仓库环境中使用分区</title>
      <meta property="og:site_name" content="Oracle Help Center"></meta>
      <meta property="og:title" content="VLDB and Partitioning Guide"></meta>
      <meta property="og:description" content="Partitioning features can improve performance in a data warehouse environment."></meta>
      <link rel="stylesheet" href="/sp_common/book-template/ohc-book-template/css/book.css"></link>
      <link rel="shortcut icon" href="/sp_common/book-template/ohc-common/img/favicon.ico"></link>
      <meta name="application-name" content="VLDB and Partitioning Guide"></meta>
      <meta name="generator" content="DITA Open Toolkit version 1.8.5 (Mode = doc)"></meta>
      <meta name="plugin" content="SP_docbuilder HTML plugin release 18.2.2"></meta>
      <link rel="alternate" href="vldb-and-partitioning-guide.pdf" title="PDF File" type="application/pdf"></link>
      <meta name="robots" content="all"></meta>
      <link rel="schema.dcterms" href="http://purl.org/dc/terms/"></link>
      <meta name="dcterms.created" content="2019-04-23T18:05:22-07:00"></meta>
      <meta name="dcterms.title" content="VLDB and Partitioning Guide"></meta>
      <meta name="dcterms.dateCopyrighted" content="2008, 2019"></meta>
      <meta name="dcterms.category" content="database"></meta>
      <meta name="dcterms.identifier" content="E96199-03"></meta>
      
      <meta name="dcterms.product" content="en/database/oracle/oracle-database/19"></meta>
      
      <link rel="prev" href="heatmap-ado-em.html" title="Previous" type="text/html"></link>
      <link rel="next" href="partition-oltp.html" title="Next" type="text/html"></link>
      <script>
        document.write('<style type="text/css">');
        document.write('body > .noscript, body > .noscript ~ * { visibility: hidden; }');
        document.write('</style>');
     </script>
      <script src="/sp_common/book-template/requirejs/require.js" data-main="/sp_common/book-template/ohc-book-template/js/book-config"></script>
      <script>
            if (window.require === undefined) {
                document.write('<script data-main="sp_common/book-template/ohc-book-template/js/book-config" src="sp_common/book-template/requirejs/require.js"><\/script>');
                document.write('<link href="sp_common/book-template/ohc-book-template/css/book.css" rel="stylesheet"/>');
            }
        </script>
      <script type="application/json" id="ssot-metadata">{"primary":{"category":{"short_name":"database","element_name":"Database","display_in_url":true},"suite":{"short_name":"oracle","element_name":"Oracle","display_in_url":true},"product_group":{"short_name":"not-applicable","element_name":"Not applicable","display_in_url":false},"product":{"short_name":"oracle-database","element_name":"Oracle Database","display_in_url":true},"release":{"short_name":"19","element_name":"Release 19","display_in_url":true}}}</script>
      
    <meta name="dcterms.isVersionOf" content="VLDBG"></meta>
    <meta name="dcterms.release" content="Release 19"></meta>
  </head>
   <body dir="ltr">
      <div class="noscript alert alert-danger text-center" role="alert">
         <a href="heatmap-ado-em.html" class="pull-left"><span class="glyphicon glyphicon-chevron-left" aria-hidden="true"></span>上一页</a> <a href="partition-oltp.html" class="pull-right">下一页<span class="glyphicon glyphicon-chevron-right" aria-hidden="true"></span></a> <span class="fa fa-exclamation-triangle" aria-hidden="true"></span>必须启用JavaScript才能正确显示此内容</div>
      <article>
         <header>
            <ol class="breadcrumb" vocab="http://schema.org/" typeof="BreadcrumbList">
               <li property="itemListElement" typeof="ListItem"><a href="index.html" property="item" typeof="WebPage"><span property="name">VLDB和分区指南</span></a></li>
               <li class="active" property="itemListElement" typeof="ListItem">在数据仓库环境中使用分区</li>
            </ol>
            <a id="GUID-31EBAE14-966E-438F-8141-51C06AFA0C10" name="GUID-31EBAE14-966E-438F-8141-51C06AFA0C10"></a><a id="VLDBG005"></a>
            
            <h2 id="VLDBG-GUID-31EBAE14-966E-438F-8141-51C06AFA0C10" class="sect2"><span class="enumeration_chapter">6</span>在数据仓库环境中使用分区</h2>
         </header>
         <div class="ind">
            <div>
               <p>分区功能可以提高数据仓库环境的性能。</p>
               <p>本章介绍了可显着增强数据访问并提高整体应用程序性能的分区功能。对于访问具有数百万行和数千兆字节数据的表和索引的应用程序，分区的改进尤其如此，如数据仓库环境中所示。数据仓库通常包含大型表，并且需要用于管理这些大型表的技术以及跨这些大型表提供良好的查询性能。</p>
               <p>本章包含以下部分：</p>
               <ul style="list-style-type:disc">
                  <li>
                     <p><a href="partition-warehouse.html#GUID-CD9A8484-D111-461B-8883-04F520A30CE4" title="数据仓库是一个关系数据库，专为查询和分析而不是事务处理而设计。">什么是数据仓库？</a></p>
                  </li>
                  <li>
                     <p><a href="partition-warehouse.html#GUID-5E478962-64EA-4CF8-8375-34A9EBAB46ED" title="分区有助于通过将数据库对象分成更小的部分来扩展数据仓库，从而可以访问更小，更易于管理的对象。直接访问较小的对象可满足数据仓库的可扩展性要求。">数据仓库中的可伸缩性</a></p>
                  </li>
                  <li>
                     <p><a href="partition-warehouse.html#GUID-78FC08BC-DB1C-41C5-8068-0F3905B1E5E1" title="良好的性能是成功数据仓库的要求。">在数据仓库中对性能进行分区</a></p>
                  </li>
                  <li>
                     <p><a href="partition-warehouse.html#GUID-59D360A4-518E-47A2-83E4-DB103AD995BF" title="数据仓库存储历史数据。数据仓库的重要部分是数据加载和清除。分区是一种强大的技术，可以帮助数据仓库进行数据管理。">数据仓库中的可管理性</a></p>
                  </li>
               </ul>
            </div><a id="VLDBG00501"></a><div class="props_rev_3"><a id="GUID-CD9A8484-D111-461B-8883-04F520A30CE4" name="GUID-CD9A8484-D111-461B-8883-04F520A30CE4"></a><h3 id="VLDBG-GUID-CD9A8484-D111-461B-8883-04F520A30CE4" class="sect3">什么是数据仓库？</h3>
               <div>
                  <p>数据仓库是一个关系数据库，专为查询和分析而不是事务处理而设计。</p>
                  <p>数据仓库通常包含从事务数据派生的历史数据，但可以包含来自其他来源的数据。数据仓库将分析工作负载与事务工作负载分开，并使组织能够合并来自多个源的数据。</p>
                  <p>除了关系数据库之外，数据仓库环境还可以包括提取，转换和加载（ETL）解决方案，分析处理和数据挖掘功能，客户端分析工具以及管理收集数据并将其传递到的过程的其他应用程序。商业用户。</p>
                  <div class="infoboxnotealso" id="GUID-CD9A8484-D111-461B-8883-04F520A30CE4__GUID-F40498A7-E6AC-41DB-9E18-78410B0C5DD5">
                     <p class="notep1">也可以看看：</p>
                     <p><a href="../dwhsg/introduction-data-warehouse-concepts.html#DWHSG-GUID-452FBA23-6976-4590-AA41-1369647AD14D" target="_blank"><span><cite>Oracle数据库数据仓库指南</cite></span></a></p>
                  </div>
               </div>
            </div><a id="VLDBG00502"></a><div class="props_rev_3"><a id="GUID-5E478962-64EA-4CF8-8375-34A9EBAB46ED" name="GUID-5E478962-64EA-4CF8-8375-34A9EBAB46ED"></a><h3 id="VLDBG-GUID-5E478962-64EA-4CF8-8375-34A9EBAB46ED" class="sect3">数据仓库中的可伸缩性</h3>
               <div>
                  <p>分区有助于通过将数据库对象分成更小的部分来扩展数据仓库，从而可以访问更小，更易于管理的对象。直接访问较小的对象可满足数据仓库的可扩展性要求。</p>
                  <p>本节包含以下主题：</p>
                  <ul style="list-style-type:disc">
                     <li>
                        <p><a href="partition-warehouse.html#GUID-B06D46B7-8827-41AC-A208-49D3C0112DAB" title="将大型数据库对象拆分为较小的部分的能力透明地简化了对非常大的数据库的有效管理。">更大的数据库</a></p>
                     </li>
                     <li>
                        <p><a href="partition-warehouse.html#GUID-78F4F2B4-7F09-4D3A-816B-BFE5258D5918" title="扫描大表所需的时间比扫描小表所需的时间长。对分区表的查询可以访问与表的总大小相比较小的一个或多个分区。">更大的单独表格：表格中的更多行</a></p>
                     </li>
                     <li>
                        <p><a href="partition-warehouse.html#GUID-3FD9CF8D-6875-43E2-8B7F-6A6C39B8F643" title="通过分区，用户更有可能查询隔离的和较小的数据集。">更多用户查询系统</a></p>
                     </li>
                     <li>
                        <p><a href="partition-warehouse.html#GUID-6BF2BE74-E7A9-439B-BD0D-399E767D3221" title="您可以使用较小的数据集更快地执行复杂查询。">更复杂的查询</a></p>
                     </li>
                  </ul>
               </div><a id="VLDBG1339"></a><div class="props_rev_3"><a id="GUID-B06D46B7-8827-41AC-A208-49D3C0112DAB" name="GUID-B06D46B7-8827-41AC-A208-49D3C0112DAB"></a><h4 id="VLDBG-GUID-B06D46B7-8827-41AC-A208-49D3C0112DAB" class="sect4">更大的数据库</h4>
                  <div>
                     <p>将大型数据库对象拆分为较小的部分的能力透明地简化了对非常大的数据库的有效管理。</p>
                     <p>您可以识别和操作单个分区和子分区以管理大型数据库对象。考虑分区对象的以下优点：</p>
                     <ul style="list-style-type:disc">
                        <li>
                           <p>可以在较低粒度级别上执行备份和恢复，以管理数据库的大小。</p>
                        </li>
                        <li>
                           <p>数据库对象的一部分可以放在压缩存储中，而其他部分可以保持未压缩。</p>
                        </li>
                        <li>
                           <p>分区可以将数据透明地存储在不同的存储层上，以降低保留大量数据的成本。有关更多信息，请参阅<a href="time-based-info.html#GUID-0193CE0F-4D9A-4D6F-8B19-E471DE94107C" title="Oracle数据库提供了基于时间管理和维护数据的策略。">管理和维护基于时间的信息</a> 。
                           </p>
                        </li>
                     </ul>
                  </div>
               </div><a id="VLDBG1340"></a><div class="props_rev_3"><a id="GUID-78F4F2B4-7F09-4D3A-816B-BFE5258D5918" name="GUID-78F4F2B4-7F09-4D3A-816B-BFE5258D5918"></a><h4 id="VLDBG-GUID-78F4F2B4-7F09-4D3A-816B-BFE5258D5918" class="sect4">更大的单独表格：表格中的更多行</h4>
                  <div>
                     <p>扫描大表所需的时间比扫描小表所需的时间长。对分区表的查询可以访问与表的总大小相比较小的一个或多个分区。</p>
                     <p>同样，查询可以利用索引上的分区消除。从磁盘读取较小部分索引比读取整个索引花费的时间更少。可以在逐个分区的基础上访问和维护与表共享分区策略的索引结构，例如本地分区索引。</p>
                     <p>如果使用并行执行来加速查询，DML和DDL语句，则数据库可以利用不同分区中的不同数据集。各个并行执行服务器可以处理由分区边界标识的自己的数据集。</p>
                  </div>
               </div><a id="VLDBG1341"></a><div class="props_rev_3"><a id="GUID-3FD9CF8D-6875-43E2-8B7F-6A6C39B8F643" name="GUID-3FD9CF8D-6875-43E2-8B7F-6A6C39B8F643"></a><h4 id="VLDBG-GUID-3FD9CF8D-6875-43E2-8B7F-6A6C39B8F643" class="sect4">更多用户查询系统</h4>
                  <div>
                     <p>通过分区，用户更有可能查询隔离的和较小的数据集。</p>
                     <p>因此，与所有用户查询相同且更大的数据集相比，数据库可以更快地返回结果。数据争用的可能性较小。</p>
                  </div>
               </div><a id="VLDBG1342"></a><div class="props_rev_3"><a id="GUID-6BF2BE74-E7A9-439B-BD0D-399E767D3221" name="GUID-6BF2BE74-E7A9-439B-BD0D-399E767D3221"></a><h4 id="VLDBG-GUID-6BF2BE74-E7A9-439B-BD0D-399E767D3221" class="sect4">更复杂的查询</h4>
                  <div>
                     <p>您可以使用较小的数据集更快地执行复杂查询。</p>
                     <p>如果正在访问较小的数据集，则更有可能在内存中处理复杂的计算，这从性能角度来看是有益的，并降低了应用程序的I / O要求。可能必须将更大的数据集写入临时表空间以完成查询，在这种情况下，会发生针对数据库存储的附加I / O操作。</p>
                  </div>
               </div>
            </div><a id="VLDBG1343"></a><div class="props_rev_3"><a id="GUID-78FC08BC-DB1C-41C5-8068-0F3905B1E5E1" name="GUID-78FC08BC-DB1C-41C5-8068-0F3905B1E5E1"></a><h3 id="VLDBG-GUID-78FC08BC-DB1C-41C5-8068-0F3905B1E5E1" class="sect3">在数据仓库中对性能进行分区</h3>
               <div>
                  <p>良好的性能是成功数据仓库的要求。</p>
                  <p>对数据库运行的分析应该在合理的时间内返回，即使查询访问大小为TB的表中的大量数据。分区可以提高数据访问和应用程序处理的速度，从而使成功的数据仓库不会过于昂贵。</p>
                  <p>本节包含以下主题：</p>
                  <ul style="list-style-type:disc">
                     <li>
                        <p><a href="partition-warehouse.html#GUID-A3C2D796-C396-4FDB-88EB-5C5455033394" title="分区修剪是数据仓库的基本性能特征。">数据仓库中的分区修剪</a></p>
                     </li>
                     <li>
                        <p><a href="partition-warehouse.html#GUID-6D8AC65A-04D7-40F8-B7F9-A7F094D3ACCB" title="分区连接通过最小化并行执行连接时并行执行服务器之间交换的数据量来减少查询响应时间。">分区 - 明智加入数据仓库</a></p>
                     </li>
                     <li>
                        <p><a href="partition-warehouse.html#GUID-81DD6045-A269-4BD2-9EBF-E430F8C3E51B" title="索引是与表相关联的可选结构，这些表允许SQL语句更快地对表执行。">数据仓库中的索引和分区索引</a></p>
                     </li>
                     <li>
                        <p><a href="partition-warehouse.html#GUID-10EAAF05-4233-4E8C-91BF-98FD3E9D6A88" title="数据仓库中用于提高性能的一种技术是创建摘要。摘要是特殊类型的聚合视图，它通过在执行前预先计算昂贵的连接和聚合操作并将结果存储在数据库的表中来改善查询执行时间。">物化视图和数据仓库中的分区</a></p>
                     </li>
                  </ul>
               </div><a id="VLDBG1344"></a><div class="props_rev_3"><a id="GUID-A3C2D796-C396-4FDB-88EB-5C5455033394" name="GUID-A3C2D796-C396-4FDB-88EB-5C5455033394"></a><h4 id="VLDBG-GUID-A3C2D796-C396-4FDB-88EB-5C5455033394" class="sect4">数据仓库中的分区修剪</h4>
                  <div>
                     <p>分区修剪是数据仓库的基本性能特征。</p>
                     <p>在分区修剪中，优化器分析SQL语句中的<code class="codeph">FROM</code>和<code class="codeph">WHERE</code>子句，以在构建分区访问列表时消除不需要的分区。因此，Oracle数据库仅对与SQL语句相关的分区执行操作。
                     </p>
                     <p>分区修剪大大减少了从磁盘检索的数据量并缩短了处理时间，从而提高了查询性能并优化了资源利用率。</p>
                     <p>本节包含以下主题：</p>
                     <ul style="list-style-type:disc">
                        <li>
                           <p><a href="partition-warehouse.html#GUID-B00AFD05-37FA-40B6-A8F4-2B714F87492A" title="优化器使用各种谓词进行修剪。">基本分区修剪技术</a></p>
                        </li>
                        <li>
                           <p><a href="partition-warehouse.html#GUID-5C53C677-F376-4611-83F6-85E8AC9EC79C" title="Oracle数据库修剪功能有效地处理涉及分区表的更复杂的谓词或SQL语句。">高级分区修剪技术</a></p>
                        </li>
                     </ul>
                     <p>有关分区修剪以及静态和动态分区修剪之间差异的详细信息，请参阅<a href="partition-availability.html#GUID-FA29787B-8700-49EA-B80D-54D667CF2752" title="分区可实现可用性，可管理性和性能。">可用性，可管理性和性能分区</a> 。
                     </p>
                  </div><a id="VLDBG1345"></a><div class="props_rev_3"><a id="GUID-B00AFD05-37FA-40B6-A8F4-2B714F87492A" name="GUID-B00AFD05-37FA-40B6-A8F4-2B714F87492A"></a><h5 id="VLDBG-GUID-B00AFD05-37FA-40B6-A8F4-2B714F87492A" class="sect5">基本分区修剪技术</h5>
                     <div>
                        <p>优化器使用各种谓词进行修剪。</p>
                        <p>三个谓词类型，相等，范围和<code class="codeph">IN</code> -list是最常用于分区修剪的谓词。例如，请考虑以下查询：</p><pre class="oac_no_warn" dir="ltr">SELECT SUM（amount_sold）day_sales FROM sales WHERE time_id = TO_DATE（'02 -JAN-1998'，'DD-MON-YYYY'）;</pre><p>由于<code class="codeph">sales</code>的分区列上存在等同谓词，因此查询将被删减为单个谓词，这将反映在以下执行计划中：</p><pre class="oac_no_warn" dir="ltr">-------------------------------------------------- --------------------------------------------- | Id |操作|名称|行|字节|成本（％CPU）|时间| Pstart | Pstop | -------------------------------------------------- --------------------------------------------- | 0 |选择声明| | | | 21（100）| | | | | 1 | SORT AGGREGATE | | 1 | 13 | | | | | | 2 | PARTITION RANGE SINGLE | | 485 | 6305 | 21（10）| 00:00:01 | 5 | 5 | | * 3 |表访问完全|销售| 485 | 6305 | 21（10）| 00:00:01 | 5 | 5 | -------------------------------------------------- ---------------------------------------------谓词信息（由操作ID）：---------------------------------------------- ----- 3  - 过滤器（“TIME_ID”= TO_DATE（'1998-01-02 00:00:00'，'yyyy-mm-dd hh24：mi：ss'））</pre><p>类似地， <code class="codeph">time_id</code>列和优化器上的范围或<code class="codeph">IN</code> -list谓词将用于修剪一组分区。分区类型起着可以使用谓词的作用。范围谓词不能用于对散列分区表进行修剪，但它们可用于所有其他分区策略。但是，在列表分区表上，范围谓词可能不会映射到一组连续的分区。Equality和<code class="codeph">IN</code> -list谓词可以修剪所有分区方法。
                        </p>
                     </div>
                  </div><a id="VLDBG1346"></a><div class="props_rev_3"><a id="GUID-5C53C677-F376-4611-83F6-85E8AC9EC79C" name="GUID-5C53C677-F376-4611-83F6-85E8AC9EC79C"></a><h5 id="VLDBG-GUID-5C53C677-F376-4611-83F6-85E8AC9EC79C" class="sect5">高级分区修剪技术</h5>
                     <div>
                        <p>Oracle数据库修剪功能有效地处理涉及分区表的更复杂的谓词或SQL语句。</p>
                        <p>常见的情况是分区表连接到另一个表的子集，受<code class="codeph">WHERE</code>条件的限制。例如，请考虑以下查询：</p><pre class="oac_no_warn" dir="ltr">SELECT t.day_number_in_month，SUM（s.amount_sold）FROM sales s，times t WHERE s.time_id = t.time_id AND t.calendar_month_desc ='2000-12'GROUP BY t.day_number_in_month;</pre><p>如果数据库进行嵌套循环与加入<code class="codeph">times</code>表上的右侧，那么查询将只访问对应于该行从分区<code class="codeph">times</code>表，所以修剪将隐含发生。但是，如果数据库执行散列或排序合并连接，则这是不可能的。如果具有<code class="codeph">WHERE</code>谓词的表与分区表相比相对较小，并且分区表的记录或分区的预期减少很大，则数据库使用递归子查询执行动态分区修剪。是否调用子查询修剪的决定是优化器的基于内部成本的决策。
                        </p>
                        <p>使用散列连接操作的示例执行计划如下所示：</p><pre class="oac_no_warn" dir="ltr">-------------------------------------------------- ------------------------------------------------ | ID |操作|名称|行|字节|成本（％CPU）|时间| Pstart | Pstop | -------------------------------------------------- ------------------------------------------------ | 0 |选择声明| | | | 761（100）| | | | | 1 | HASH GROUP BY | | 20 | 640 | 761（41）| 00：00：10 | | | | * 2 | HASH JOIN | | 19153 | 598K | 749（40）| 00：00：09 | | | | * 3 |表访问完全|时代| 30 | 570 | 17（6）| 00:00:01 | | | | 4 |分区范围子项| | 918K | 11M | 655（33）| 00：00：08 | KEY（SQ）| KEY（SQ）| | 5 |表访问完全|销售| 918 | 11M | 655（33）| 00：00：08 | KEY（SQ）| KEY（SQ）| -------------------------------------------------- ------------------------------------------------谓词信息（由操作ID标识）：------------------------------------------- -------- PLAN_TABLE_OUTPUT ----------------------------------------- -------------------------------------------------- ------- 2  - 访问（“S”。“TIME_ID”=“T”。“TIME_ID”）3  - 过滤器（“T”。“CALENDAR_MONTH_DESC”='2000-12'）</pre><p>此执行计划显示使用子查询在<code class="codeph">sales</code>表上发生动态分区修剪，如<code class="codeph">PSTART</code>和<code class="codeph">PSTOP</code>列中的<code class="codeph">KEY(SQ)</code>值所示。
                        </p>
                        <p>以下是使用<code class="codeph">OR</code>谓词进行高级修剪的示例。
                        </p><pre class="oac_no_warn" dir="ltr">SELECT p.promo_name promo_name，（s.profit  -  p.promo_cost）profit FROM promotion p，（SELECT sales.promo_id，SUM（sales。）QUANTITY_SOLD *（费用。UNIT_PRICE  - 费用。UNIT_COST））销售利润，成本WHERE（（sales.time_id BETWEEN TO_DATE（'01 -JAN-1998'，'DD-MON-YYYY'，'NLS_DATE_LANGUAGE = American'）和TO_DATE（'01 -JAN-1999'， 'DD-MON-YYYY'，'NLS_DATE_LANGUAGE = American'）或（sales.time_id BETWEEN TO_DATE（'01 -JAN-2001'，'DD-MON-YYYY'，'NLS_DATE_LANGUAGE = American'）和TO_DATE（'01  - JAN-2002'，'DD-MON-YYYY'，'NLS_DATE_LANGUAGE = American'）））AND sales.time_id = costs.time_id AND sales.prod_id = costs.prod_id）GROUP BY sales.promo_id）s WHERE s.promo_id = p.promo_id ORDER BY利益DESC;</pre><p>此查询连接<code class="codeph">sales</code>和<code class="codeph">costs</code>表。<code class="codeph">sales</code>表在<code class="codeph">time_id</code>列上按范围分区。查询中的一个条件是<code class="codeph">time_id</code>上的两个谓词，它们与<code class="codeph">OR</code>运算符组合在一起。此<code class="codeph">OR</code>谓词用于修剪<code class="codeph">sales</code>表中的分区，并执行<code class="codeph">sales</code>和<code class="codeph">costs</code>表之间的单个连接。执行计划如下：</p><pre class="oac_no_warn" dir="ltr">-------------------------------------------------- ------------------------------------------------ | ID |操作|名称|行|字节| TmpSp |成本（％CPU）|时间| Pstart时| Pstop | -------------------------------------------------- ------------------------------------------------ | 0 |选择声明| | 4 | 200 | | 3556（14）| 00：00：43 | | | | 1 |排序顺序| | 4 | 200 | | 3556（14）| 00：00：43 | | | | * 2 | HASH JOIN | | 4 | 200 | | 3555（14）| 00：00：43 | | | | 3 |表访问完整|促销| 503 | 16599 | | 16（0）| 00：00：01 | | | | 4 |查看| | 4 | 68 | | 3538（14）| 00：00：43 | | | | 5 | HASH GROUP BY | | 4 | 164 | | 3538（14）| 00：00：43 | | | | 6 |分区范围或| | 314K | 12M | | 3321（9）| 00：00：40 |键（或）|键（或）| | * 7 | HASH JOIN | | 314K | 12M | 440K | 3321（9）| 00：00：40 | | | | * 8 |表访问完全|销售| 402K | 7467K | | 400（39）| 00：00：05 |键（或）|键（或）| | 9 |表访问完全|成本| 82112 | 1764K | | 77（24）| 00：00：01 |键（或）|键（或）| -------------------------------------------------- ------------------------------------------------谓词信息（由操作ID标识）：------------------------------------------- -------- 2  - 访问（“S”。“PROMO_ID”=“P”。“PROMO_ID”）7  - 访问（“SALES”。“TIME_ID”=“COSTS”。“TIME_ID”和“销售” “。”PROD_ID“=”COSTS“。”PROD_ID“）8  - 过滤器（”SALES“。”TIME_ID“&lt;= TO_DATE（'1999-01-01 00:00:00'，'yyyy-mm-dd hh24： mi：ss'）和“SALES”。“TIME_ID”&gt; = TO_DATE（'1998-01-01 00:00:00'，'yyyy-mm-dd hh24：mi：ss'）或“SALES”。“TIME_ID “&gt; = TO_DATE（'2001-01-01 00:00:00'，'yyyy-mm-dd hh24：mi：ss'）和”SALES“。”TIME_ID“&lt;= TO_DATE（'2002-01-01 00 ：00：00'，'yyyy-mm-dd hh24：mi：ss'））</pre><p>当列在多列上进行范围分区时，数据库还会执行其他修剪。只要数据库可以保证在特定分区中不能满足特定谓词，就跳过该分区。这允许数据库优化多列上存在范围谓词的情况，或者在分区列的前缀上没有谓词的情况下。</p>
                        <p>有关<a href="partition-pruning.html#GUID-6C660105-8ECE-4426-A795-5884E84B0A48" title="Tips for partition pruning are introduced in this topic.">分区修剪的提示</a> ，请参阅<a href="partition-pruning.html#GUID-6C660105-8ECE-4426-A795-5884E84B0A48" title="本主题介绍了分区修剪的技巧。">分区修剪提示</a> 。
                        </p>
                     </div>
                  </div>
               </div><a id="VLDBG1347"></a><div class="props_rev_3"><a id="GUID-6D8AC65A-04D7-40F8-B7F9-A7F094D3ACCB" name="GUID-6D8AC65A-04D7-40F8-B7F9-A7F094D3ACCB"></a><h4 id="VLDBG-GUID-6D8AC65A-04D7-40F8-B7F9-A7F094D3ACCB" class="sect4">分区 - 明智加入数据仓库</h4>
                  <div>
                     <p>分区连接通过最小化并行执行连接时并行执行服务器之间交换的数据量来减少查询响应时间。</p>
                     <p>使用分区智能连接可显着缩短响应时间并改善CPU和内存资源的使用。并行分区连接通常用于高效且快速地处理大型连接。分区连接可以是完整的或部分的。Oracle数据库决定使用哪种类型的连接。</p>
                     <p>除了并行分区连接之外，使用<code class="codeph">SELECT</code> <code class="codeph">DISTINCT</code>子句和SQL窗口函数的查询可以执行并行分区操作。
                     </p>
                     <p>本节包含以下主题：</p>
                     <ul style="list-style-type:disc">
                        <li>
                           <p><a href="partition-warehouse.html#GUID-5279BF41-41BF-4F87-A64E-2AA58C22BD61" title="如果在同一个键上共同分区的两个表在查询中连接，则可能发生完全分区连接。">完全分区 - 明智的联接</a></p>
                        </li>
                        <li>
                           <p><a href="partition-warehouse.html#GUID-956E0532-BD25-44C6-B986-9D345BBAF663" title="Oracle数据库只能并行执行部分分区连接。">部分分区 - 明智的联接</a></p>
                        </li>
                        <li>
                           <p><a href="partition-warehouse.html#GUID-350066B8-5BEC-4053-80EF-A1502C5EFBDE" title="分区连接提供了几个好处。">分区 - 明智联接的好处</a></p>
                        </li>
                        <li>
                           <p><a href="partition-warehouse.html#GUID-236EECB8-50DB-4CE3-A755-45080AFF4428" title="在决定是否使用分区智能联接时，优化程序会权衡优缺点。">并行分区 - 明智联接的性能考虑因素</a></p>
                        </li>
                     </ul>
                     <div class="infoboxnotealso" id="GUID-6D8AC65A-04D7-40F8-B7F9-A7F094D3ACCB__FORADDITIONALINFORMATIONABOUTPARTIT-FB67663B">
                        <p class="notep1">也可以看看：</p>
                        <ul style="list-style-type:disc">
                           <li>
                              <p><a href="partition-wise-joins.html#GUID-7C28CD29-5189-4A53-9691-380E13515015" title="Partition-wise operations significantly reduce response time and improve the use of both CPU and memory resources.">分区智能操作</a>以获取有关分区<a href="partition-wise-joins.html#GUID-7C28CD29-5189-4A53-9691-380E13515015" title="分区操作可显着缩短响应时间并改善CPU和内存资源的使用。">操作</a>的其他信息</p>
                           </li>
                           <li>
                              <p><a href="../dwhsg/data-warehouse-optimizations-techniques.html#DWHSG-GUID-79C29A60-3477-448D-835D-2940D060D050" target="_blank"><span><cite>Oracle数据库数据仓库指南</cite></span></a> ，了解有关数据仓库和优化技术的信息</p>
                           </li>
                        </ul>
                     </div>
                  </div><a id="VLDBG1348"></a><div class="props_rev_3"><a id="GUID-5279BF41-41BF-4F87-A64E-2AA58C22BD61" name="GUID-5279BF41-41BF-4F87-A64E-2AA58C22BD61"></a><h5 id="VLDBG-GUID-5279BF41-41BF-4F87-A64E-2AA58C22BD61" class="sect5">完全分区 - 明智的联接</h5>
                     <div>
                        <p>如果在同一个键上共同分区的两个表在查询中连接，则可能发生完全分区连接。</p>
                        <p>这些表可以在分区级别或子分区级别，或者在分区和子分区级别的组合中进行共同分区。引用分区是保证共分区的简单方法。完全分区连接可以串行和并行执行。</p>
                        <p>有关分区智能联接的详细信息，请参阅<a href="partition-availability.html#GUID-FA29787B-8700-49EA-B80D-54D667CF2752" title="分区可实现可用性，可管理性和性能。">可用性，可管理性和性能分区</a> 。
                        </p>
                        <p>以下示例显示了<code class="codeph">orders</code>和<code class="codeph">order_items</code>表上的完全分区连接，其中<code class="codeph">order_items</code>表是引用分区的。
                        </p><pre class="oac_no_warn" dir="ltr">CREATE TABLE命令（order_id NUMBER（12）NOT NULL，order_date DATE NOT NULL，order_mode VARCHAR2（8），order_status VARCHAR2（1），CONSTRAINT orders_pk PRIMARY KEY（order_id））PARTITION BY RANGE（order_date）（PARTITION p_before_jan_2006 VALUE少于（ TO_DATE（'01 -JAN-2006'，'dd-MON-yyyy'）），PARTITION p_2006_jan值不到（截止日期（'01-FEB-2006'，'dd-MON-yyyy'）），PARTITION p_2006_feb VALUES LESS （截止日期（'01 -MAR-2006'，'dd-MON-yyyy'）），PARTITION p_2006_mar的价值不到（截止日期（'01-APR-2006'，'dd-MON-yyyy'）），PARTITION p_2006_apr价值不到（截止日期（'01 -MAY-2006'，'dd-MON-yyyy'）），PARTITION p_2006_可能价值低于（截止日期（'01 -JUN-2006'，'dd-MON-yyyy'））， PAR_TION p_2006_jun的价值不到（截止日期为（'01 -JUL-2006'，'dd-MON-yyyy'）），PARTITION p_2006_jul价值不到（截止日期为（'01 -AUG-2006'，'dd-MON-yyyy'） ），PARTITION p_2006_aug值不到（截止日期（'01 -SEP-2006'，'dd-MON-yyyy'）），PARTITION p_2006_sep值不超过（'01 -OCT-2006'，'dd-MON-y） yyy'）），PARTITION p_2006_oct的价值不到（截止日期（' -  NOV-2006'，'dd-MON-yyyy'）），PARTITION p_2006_nov值不到（截止日期为（'01 -DEC-2006'，'dd- MONYYyy'）），PARTITION p_2006_dec值不到（截止日期（'01 -JAN-2007'，'dd-MON-yyyy'）））并行; CREATE TABLE order_items（order_id NUMBER（12）NOT NULL，product_id NUMBER NOT NULL，Quantity NUMBER NOT NULL，sales_amount NUMBER NOT NULL，CONSTRAINT order_items_orders_fk FOREIGN KEY（order_id）REFERENCES orders（order_id））PARTITION BY REFERENCE（order_items_orders_fk）PARALLEL;</pre><p>典型的数据仓库查询将扫描大量数据。在底层执行计划中，已删除列<code class="codeph">Rows</code> ， <code class="codeph">Bytes</code> ， <code class="codeph">Cost (%CPU)</code> ， <code class="codeph">Time</code>和<code class="codeph">TQ</code> 。
                        </p><pre class="oac_no_warn" dir="ltr">EXPLAIN PLAN FOR SELECT o.order_date，sum（oi.sales_amount）sum_sales FROM orders o，order_items oi WHERE o.order_id = oi.order_id AND o.order_date BETWEEN TO_DATE（'01-FEB-2006'，'DD-MON-YYYY '）和TO_DATE（'31 -MAY-2006'，'DD-MON-YYYY'）GROUP BY o.order_id，o.order_date ORDER BY o.order_date; -------------------------------------------------- ------------------------------------------- | Id |操作|名称| Pstart时| Pstop | IN-OUT | PQ Distrib | -------------------------------------------------- ------------------------------------------- | 0 |选择声明| | | | | | | 1 | PX COORDINATOR | | | | | | | 2 | PX SEND QC（订购）| ：TQ10001 | | | P-&gt; S | QC（订单）| | 3 | SORT GROUP BY | | | | PCWP | | | 4 | PX RECEIVE | | | | PCWP | | | 5 | PX SEND RANGE | ：TQ10000 | | | P-&gt; P |范围| | 6 | SORT GROUP BY | | | | PCWP | | | 7 | PX PARTITION RANGE ITERATOR | | 3 | 6 | PCWC | | | * 8 | HASH JOIN | | | | PCWP | | | * 9 |表访问完全|订单| 3 | 6 | PCWP | | | 10 |表访问完全| ORDER_ITEMS | 3 | 6 | PCWP | | -------------------------------------------------- -------------------------------------------谓词信息（由操作ID标识）：------------------------------------------------ --- 8  - 访问（“O”。“ORDER_ID”=“OI”。“ORDER_ID”）9  - 过滤器（“O”。“ORDER_DATE”&lt;= TO_DATE（'2006-05-31 00:00:00' ，'syyyy-mm-dd hh24：mi：ss'））</pre></div>
                  </div><a id="VLDBG1349"></a><div class="props_rev_3"><a id="GUID-956E0532-BD25-44C6-B986-9D345BBAF663" name="GUID-956E0532-BD25-44C6-B986-9D345BBAF663"></a><h5 id="VLDBG-GUID-956E0532-BD25-44C6-B986-9D345BBAF663" class="sect5">部分分区 - 明智的联接</h5>
                     <div>
                        <p>Oracle数据库只能并行执行部分分区连接。</p>
                        <p>与完全分区连接不同，部分分区连接要求您只对连接键上的一个表进行分区，而不是两个表。分区表称为引用表。另一个表可能已分区，也可能未分区。部分分区连接比完全分区连接更常见。</p>
                        <p>为了执行部分分区连接，数据库根据引用表的分区动态分区或重新分区另一个表。在重新分区另一个表之后，执行类似于完全分区连接。</p>
                        <p>以下示例显示典型数据仓库方案中的调用详细信息记录表<code class="codeph">cdrs</code> 。该表是interval-hash分区的。
                        </p><pre class="oac_no_warn" dir="ltr">CREATE TABLE cdrs（id NUMBER，cust_id NUMBER，from_number VARCHAR2（20），to_number VARCHAR2（20），date_of_call DATE，distance VARCHAR2（1），call_duration_in_s NUMBER（4））PARTITION BY RANGE（date_of_call）INTERVAL（NUMTODSINTERVAL（1，' DAY'））哈希（cust_id）子公司的分配16（分区p0值不到（截止日期（'01 -JAN-2005'，'dd-MON-yyyy'）））并行;</pre><p><code class="codeph">cdrs</code>表与<code class="codeph">cust_id</code>列上的非分区<code class="codeph">callers</code>表连接，以对花费最多时间进行调用的客户进行排名。
                        </p><pre class="oac_no_warn" dir="ltr">用于选择的EXPLAIN PLAN c.cust_id，c.cust_last_name，c.cust_first_name，AVG（call_duration_in_s），COUNT（1），DENSE_RANK（）OVER（ORDER BY（AVG（call_duration_in_s）* COUNT（1））DESC）从来电者c排名，cdrs cdr WHERE cdr.cust_id = c.cust_id AND cdr.date_of_call BETWEEN TO_DATE（'01 -JAN-2006'，'dd-MON-yyyy'）和TO_DATE（'31 -DEC-2006'，'dd-MON- yyyy'）GROUP BY c.cust_id，c.cust_last_name，c.cust_first_name ORDER BY ranking;</pre><p>执行计划显示部分分区连接。在计划中，已删除列<code class="codeph">Rows</code> ， <code class="codeph">Bytes</code> ， <code class="codeph">Cost (%CPU)</code> ， <code class="codeph">Time</code>和<code class="codeph">TQ</code> 。
                        </p><pre class="oac_no_warn" dir="ltr">-------------------------------------------------- ------------------------------------------ | Id |操作|名称| Pstart时| Pstop | IN-OUT | PQ Distrib | -------------------------------------------------- ------------------------------------------ | 0 |选择声明| | | | | | | 1 | WINDOW NOSORT | | | | | | | 2 | PX COORDINATOR | | | | | | | 3 | PX SEND QC（订购）| ：TQ10002 | | | P-&gt; S | QC（订单）| | 4 |排序顺序| | | | PCWP | | | 5 | PX RECEIVE | | | | PCWP | | | 6 | PX SEND RANGE | ：TQ10001 | | | P-&gt; P |范围| | 7 | HASH GROUP BY | | | | PCWP | | | * 8 | HASH JOIN | | | | PCWP | | | 9 | PART JOIN FILTER CREATE | ：BF0000 | | | PCWP | | | 10 | BUFFER SORT | | | | PCWC | | | 11 | PX RECEIVE | | | | PCWP | | | 12 | PX SEND PARTITION（KEY）| ：TQ10000 | | | S-&gt; P | PART（KEY）| | 13 |表访问完全|来电者| | | | | | 14 | PX PARTITION RANGE ITERATOR | | 367 | 731 | PCWC | | | 15 | PX PARTITION HASH ALL | | 1 | 16 | PCWC | | | * 16 |表访问完全| CDRS | 5857 | 11696 | PCWP | | -------------------------------------------------- ------------------------------------------谓词信息（由操作ID标识） ：------------------------------------------------- -  8  - 访问（“CDR”。“CUST_ID”=“C”。“CUST_ID”）16  - 过滤器（“CDR”。“DATE_OF_CALL”&gt; = TO_DATE（'2006-01-01 00:00:00'， 'syyyy-mm-dd hh24：mi：ss'）和“CDR”。“DATE_OF_CALL”&lt;= TO_DATE（'2006-12-31 00:00:00'，'syyyy-mm-dd hh24：mi：ss' ））</pre></div>
                  </div><a id="VLDBG1350"></a><div class="props_rev_3"><a id="GUID-350066B8-5BEC-4053-80EF-A1502C5EFBDE" name="GUID-350066B8-5BEC-4053-80EF-A1502C5EFBDE"></a><h5 id="VLDBG-GUID-350066B8-5BEC-4053-80EF-A1502C5EFBDE" class="sect5">分区 - 明智联接的好处</h5>
                     <div>
                        <p>分区连接提供了几个好处。</p>
                        <p>以下主题描述了这些好处：</p>
                        <ul style="list-style-type:disc">
                           <li>
                              <p><a href="partition-warehouse.html#GUID-F19CEE41-E294-46DB-BEB0-01B7AC4BDBE1" title="并行执行时，分区连接可减少通信开销。">减少通信开销</a></p>
                           </li>
                           <li>
                              <p><a href="partition-warehouse.html#GUID-CAB00836-9030-4C55-AC55-F64345C57826" title="分区连接所需的内存少于要连接的表的完整数据集的等效连接操作。">减少内存要求</a></p>
                           </li>
                        </ul>
                     </div><a id="VLDBG1351"></a><div class="props_rev_3"><a id="GUID-F19CEE41-E294-46DB-BEB0-01B7AC4BDBE1" name="GUID-F19CEE41-E294-46DB-BEB0-01B7AC4BDBE1"></a><h6 id="VLDBG-GUID-F19CEE41-E294-46DB-BEB0-01B7AC4BDBE1" class="sect6">减少通信开销</h6>
                        <div>
                           <p>并行执行时，分区连接可减少通信开销。</p>
                           <p>在默认情况下，这种减少的发生是因为一组并行执行服务器并行执行连接操作需要将连接列上的每个表重新分配为不相交的行子集。然后，这些不相交的行子集由单个并行执行服务器成对地连接。</p>
                           <p>数据库可以避免重新分配分区，因为这两个表在连接列上进行了分区。此功能使每个并行执行服务器能够加入一对匹配的分区。在使用节点并行执行的Oracle Real Application Clusters配置中，使用并行执行的这种改进性能更加明显。</p>
                           <p>分区智能连接可显着减少互连流量。使用此功能是使用Oracle Real Application Clusters的大型决策支持系统（DSS）配置的关键。目前，大多数Oracle Real Application Clusters平台，如大规模并行处理（MPP）和对称多处理（SMP）集群，与其处理能力相比，提供有限的互连带宽。理想情况下，互连带宽应与磁盘带宽相当，但这种情况很少发生。因此，Oracle Real Application Clusters中的大多数连接操作都会遇到高互连延迟，而无需并行执行分区连接。</p>
                        </div>
                     </div><a id="VLDBG1352"></a><div class="props_rev_3"><a id="GUID-CAB00836-9030-4C55-AC55-F64345C57826" name="GUID-CAB00836-9030-4C55-AC55-F64345C57826"></a><h6 id="VLDBG-GUID-CAB00836-9030-4C55-AC55-F64345C57826" class="sect6">减少内存要求</h6>
                        <div>
                           <p>分区连接所需的内存少于要连接的表的完整数据集的等效连接操作。</p>
                           <p>对于串行连接，连接在一对匹配的分区上同时执行。如果数据在分区之间均匀分布，则内存需求除以分区数，并且并行服务器之间的数据分布没有偏差。</p>
                           <p>对于并行连接，内存要求取决于并行连接的分区对的数量。例如，如果并行度为20并且分区数为100，则需要5倍的内存，因为每个同时执行两个分区的20个连接。分区连接需要较少内存的事实对性能有直接的有益影响。例如，连接可能不需要在散列连接的构建阶段将块写入磁盘。</p>
                        </div>
                     </div>
                  </div><a id="VLDBG1353"></a><div class="props_rev_3"><a id="GUID-236EECB8-50DB-4CE3-A755-45080AFF4428" name="GUID-236EECB8-50DB-4CE3-A755-45080AFF4428"></a><h5 id="VLDBG-GUID-236EECB8-50DB-4CE3-A755-45080AFF4428" class="sect5">并行分区 - 明智联接的性能考虑因素</h5>
                     <div>
                        <p>在决定是否使用分区智能联接时，优化程序会权衡优缺点。</p>
                        <p>优化器根据以下内容选择是否使用分区智能联接：</p>
                        <ul style="list-style-type:disc">
                           <li>
                              <p>在分区大小不同的范围分区中，数据偏差会增加响应时间;某些并行执行服务器需要比其他服务器更长的时间来完成连接。Oracle建议使用散列分区和子分区来启用分区智能连接，因为散列分区（如果分区数是2的幂）可以限制倾斜的风险。理想情况下，散列分区键是唯一的，以最大限度地降低倾斜的风险。</p>
                           </li>
                           <li>
                              <p>如果可能，用于分区连接的分区数应该是查询服务器数量的倍数。例如，在16的并行度下，您可以拥有16个，32个甚至64个分区。如果存在奇数个分区，则使用的某些并行执行服务器少于其他服务器。例如，如果有17个均匀分布的分区对，则只有一对在最后一个连接上工作，而另一对必须等待。这是因为，在执行开始时，每个并行执行服务器在不同的分区对上工作。在第一阶段之后，只剩下一对。因此，单个并行执行服务器加入该剩余对，而所有其他并行执行服务器都空闲。</p>
                           </li>
                        </ul>
                        <p>在某些情况下，并行连接可能会导致远程I / O操作。例如，在MPP配置上运行的Oracle Real Application Clusters环境中，如果一对匹配的分区未在同一节点上并置，则由于远程I / O，分区连接需要额外的节点间通信。这是因为Oracle数据库必须将至少一个分区传输到执行连接的节点。在这种情况下，最好显式重新分配数据，而不是使用分区连接。</p>
                     </div>
                  </div>
               </div><a id="VLDBG1354"></a><div class="props_rev_3"><a id="GUID-81DD6045-A269-4BD2-9EBF-E430F8C3E51B" name="GUID-81DD6045-A269-4BD2-9EBF-E430F8C3E51B"></a><h4 id="VLDBG-GUID-81DD6045-A269-4BD2-9EBF-E430F8C3E51B" class="sect4">数据仓库中的索引和分区索引</h4>
                  <div>
                     <p>索引是与表相关联的可选结构，这些表允许SQL语句更快地对表执行。</p>
                     <p>尽管表扫描在许多数据仓库中非常常见，但索引通常可以加快查询速度。</p>
                     <p>B树和位图索引都可以在分区表上创建为本地索引，在这种情况下，它们会继承表的分区策略。可以在分区和非分区表上创建B树索引作为全局分区索引。</p>
                     <p>本节包含以下主题：</p>
                     <ul style="list-style-type:disc">
                        <li>
                           <p><a href="partition-warehouse.html#GUID-E8EA2E63-538F-4084-BD18-42C1ABD41B99" title="在本地索引中，特定索引分区中的所有键仅指存储在单个基础表分区中的行。">本地分区索引</a></p>
                        </li>
                        <li>
                           <p><a href="partition-warehouse.html#GUID-AD9D5F40-C8F8-4C6C-ADB5-BA3EE448D3B9" title="您可以在非分区表和分区表上创建非分区索引。">非分区索引</a></p>
                        </li>
                        <li>
                           <p><a href="partition-warehouse.html#GUID-EE7C7B09-81BD-4996-8AC1-42A50D26FC25" title="您可以在非分区表和分区表上创建全局分区索引。">全局分区索引</a></p>
                        </li>
                     </ul>
                     <p>有关分区索引的详细信息，请参阅<a href="partition-availability.html#GUID-FA29787B-8700-49EA-B80D-54D667CF2752" title="分区可实现可用性，可管理性和性能。">可用性，可管理性和性能分区</a> 。
                     </p>
                  </div><a id="VLDBG1355"></a><div class="props_rev_3"><a id="GUID-E8EA2E63-538F-4084-BD18-42C1ABD41B99" name="GUID-E8EA2E63-538F-4084-BD18-42C1ABD41B99"></a><h5 id="VLDBG-GUID-E8EA2E63-538F-4084-BD18-42C1ABD41B99" class="sect5">本地分区索引</h5>
                     <div>
                        <p>在本地索引中，特定索引分区中的所有键仅指存储在单个基础表分区中的行。</p>
                        <p>本地索引与底层表格相同。Oracle数据库在与基础表相同的列上对索引进行分区，创建相同数量的分区或子分区，并为它们提供与基础表的相应分区相同的分区边界。</p>
                        <p>当添加，删除，合并或拆分基础表中的分区时，或者添加或合并散列分区或子分区时，Oracle数据库还会自动维护索引分区。这可确保索引保持与表格相同。</p>
                        <p>对于数据仓库应用程序，本地非前缀索引可以提高性能，因为可以通过索引键上的范围查询并行扫描许多索引分区。以下示例在分区的<code class="codeph">customers_dw</code>表上创建本地B树索引：</p><pre class="oac_no_warn" dir="ltr">CREATE INDEX cust_last_name_ix ON customers_dw（last_name）LOCAL PARALLEL NOLOGGING;</pre><p>位图索引为低基数列使用非常有效的存储机制。位图索引用于数据仓库，尤其在实现<span class="italic">星型</span> <span class="italic">模式的</span>数据仓库中很常见。单个星型模式由中央大事实表和多个较小维度表组成，这些表描述事实表中的数据。
                        </p>
                        <p>例如，考虑一个<code class="codeph">sales</code>表，它是一个事实表，由维度表<code class="codeph">customers</code> ， <code class="codeph">products</code> ， <code class="codeph">promotions</code> ， <code class="codeph">times</code>和<code class="codeph">channels</code> 。位图索引启用星形转换，这是针对星形或星形外观类似架构的快速查询检索的优化。
                        </p>
                        <p>事实表外键列是位图索引的理想候选者，因为通常相对于总行数存在很少的不同值。事实表通常是范围或范围*分区，在这种情况下，您必须创建本地位图索引。不支持分区表上的全局位图索引。</p>
                        <p>以下示例在<code class="codeph">sales</code>表上创建本地分区位图索引：</p><pre class="oac_no_warn" dir="ltr">创建BITMAP指数prod_id_ix ON销售（prod_id）本地平行指数;</pre><div class="infoboxnotealso" id="GUID-E8EA2E63-538F-4084-BD18-42C1ABD41B99__GUID-8E633CB8-D003-446C-9FE3-051D8C718449">
                           <p class="notep1">也可以看看：</p>
                           <p>有关星形转换的更多信息，请<a href="../dwhsg/data-warehouse-optimizations-techniques.html#DWHSG8593" target="_blank"><span><cite>参见“Oracle数据库数据仓库指南”</cite></span></a></p>
                        </div>
                     </div>
                  </div><a id="VLDBG1356"></a><div class="props_rev_3"><a id="GUID-AD9D5F40-C8F8-4C6C-ADB5-BA3EE448D3B9" name="GUID-AD9D5F40-C8F8-4C6C-ADB5-BA3EE448D3B9"></a><h5 id="VLDBG-GUID-AD9D5F40-C8F8-4C6C-ADB5-BA3EE448D3B9" class="sect5">非分区索引</h5>
                     <div>
                        <p>您可以在非分区表和分区表上创建非分区索引。</p>
                        <p>非分区索引主要用于数据仓库环境中的非分区表，并且通常在需要在数据仓库环境中强制执行唯一约束的状态时强制实施唯一性。您可以在分区表上使用非分区全局索引来强制实施主键或唯一键。非分区（全局）索引对于通常根据分区键中未包含的列或列集上的等式谓词或<code class="codeph">IN</code> -list检索极少行的查询非常有用。在这些情况下，扫描单个索引比扫描多个索引分区以查找所有匹配行更快。
                        </p>
                        <p>除分区列以外的列上的唯一索引必须是全局的，因为不支持其键不包含分区键的唯一本地非前缀索引。由于受控数据加载过程和强制执行唯一约束的性能成本，因此并非总是在数据仓库中强制使用唯一键。对于具有数十亿行的表，全局索引可能会变得非常大。</p>
                        <p>以下示例在<code class="codeph">sales</code>表上创建全局唯一索引：</p><pre class="oac_no_warn" dir="ltr">CREATE UNIQUE INDEX sales_unique_ix ON sales（cust_id，prod_id，promo_id，channel_id，time_id）PARALLEL NOLOGGING;</pre><p>很少有查询从此索引中受益。在具有非常有限的数据加载窗口的系统中，请考虑不创建和维护它。</p>
                     </div>
                  </div><a id="VLDBG1357"></a><div class="props_rev_3"><a id="GUID-EE7C7B09-81BD-4996-8AC1-42A50D26FC25" name="GUID-EE7C7B09-81BD-4996-8AC1-42A50D26FC25"></a><h5 id="VLDBG-GUID-EE7C7B09-81BD-4996-8AC1-42A50D26FC25" class="sect5">全局分区索引</h5>
                     <div>
                        <p>您可以在非分区表和分区表上创建全局分区索引。</p>
                        <p>在全局分区索引中，特定索引分区中的键可以指存储在多个基础表分区或子分区中的行。全局索引可以是范围或散列分区，但可以在任何类型的分区表上定义。</p>
                        <p>通过指定<code class="codeph">GLOBAL</code>属性创建全局索引。数据库管理员负责在创建时定义全局索引的初始分区以及随时间维护分区。可以根据需要合并或拆分索引分区。
                        </p>
                        <p>如果存在一类使用表的访问路径通过索引检索几行的查询，并且通过对索引进行分区，则可以消除大部分查询的大部分索引，全局索引可能很有用。在分区表上，如果实现分区修剪所包含的一列或多列不包含表分区键，则会考虑全局分区索引。</p>
                        <p>以下示例在<code class="codeph">sales</code>表上创建全局散列分区索引：</p><pre class="oac_no_warn" dir="ltr">CREATE INDEX cust_id_prod_id_global_ix ON sales（cust_id，prod_id）HASH的全局分区（cust_id）（PARPTION p1 TABLESPACE tbs1，PARTITION p2 TABLESPACE tbs2，PARTITION p3 TABLESPACE tbs3，PARTITION p4 TABLESPACE tbs4）并行的NOLOGGING;</pre></div>
                  </div>
               </div><a id="VLDBG1359"></a><div class="sect3"><a id="GUID-10EAAF05-4233-4E8C-91BF-98FD3E9D6A88" name="GUID-10EAAF05-4233-4E8C-91BF-98FD3E9D6A88"></a><h4 id="VLDBG-GUID-10EAAF05-4233-4E8C-91BF-98FD3E9D6A88" class="sect4">物化视图和数据仓库中的分区</h4>
                  <div>
                     <p>数据仓库中用于提高性能的一种技术是创建摘要。摘要是特殊类型的聚合视图，它通过在执行前预先计算昂贵的连接和聚合操作并将结果存储在数据库的表中来改善查询执行时间。</p>
                     <p>例如，您可以创建汇总表以包含按地区和按产品划分的销售总额。</p>
                     <p>本指南和数据仓库文献中引用的摘要或汇总是使用称为物化视图的模式对象在Oracle数据库中创建的。数据仓库中的物化视图可提高查询性能。</p>
                     <p>数据库支持对物化视图进行透明重写，因此您无需修改原始查询即可利用物化视图中的预先计算结果。数据库不是执行查询，而是从一个或多个物化视图中检索预先计算的结果，对数据执行任何必要的附加操作，并返回查询结果。</p>
                     <div class="infoboxnotealso" id="GUID-10EAAF05-4233-4E8C-91BF-98FD3E9D6A88__GUID-28535BE6-628D-4082-9A4A-C2FFC090CE4D">
                        <p class="notep1">也可以看看：</p>
                        <p>有关数据仓库和物化视图的信息，请<a href="../dwhsg/basic-materialized-views.html#DWHSG-GUID-A7AE8E5D-68A5-4519-81EB-252EAAF0ADFF" target="_blank"><span><cite>参见“Oracle数据库数据仓库指南”</cite></span></a></p>
                     </div>
                  </div><a id="VLDBG14081"></a><a id="VLDBG1360"></a><div class="props_rev_3"><a id="GUID-F9C356AF-AAF0-4DF4-AE5F-01ECDBFDAFF1" name="GUID-F9C356AF-AAF0-4DF4-AE5F-01ECDBFDAFF1"></a><h5 id="VLDBG-GUID-F9C356AF-AAF0-4DF4-AE5F-01ECDBFDAFF1" class="sect5">分区物化视图</h5>
                     <div>
                        <p>物化视图的底层存储是表结构。您可以像分区表一样对物化视图进行分区。</p>
                        <p>当数据库重写查询以针对实例化视图运行时，查询可以利用相同的性能功能，从而使针对表运行的查询直接受益。重写的查询可以消除具体化的视图分区。如果需要连接回表或其他物化视图来检索查询结果，则重写的查询可以利用分区智能联接。</p>
                        <p><a href="partition-warehouse.html#GUID-F9C356AF-AAF0-4DF4-AE5F-01ECDBFDAFF1__CHDHDFFE">示例6-1</a>显示了如何创建压缩分区的物化视图，将销售结果聚合到国家/地区级别。此物化视图受益于查询，这些查询按国家/地区级别或更高级别向子区域或地区级别汇总销售数字。
                        </p>
                        <div class="example" id="GUID-F9C356AF-AAF0-4DF4-AE5F-01ECDBFDAFF1__CHDHDFFE">
                           <p class="titleinexample">示例6-1创建压缩分区的物化视图</p><pre class="oac_no_warn" dir="ltr">CREATE MATERIALIZED VIEW country_sales PARTITION BY HASH（country_id）PARTITIONS 16 COMPRESS FOR OLTP PARALLEL NOLOGGING ENABLE QUERY REWRITE as SELECT co.country_id，co.country_name，co.country_subregion，co.country_region，sum（sa.quantity_sold）country_quantity_sold，sum（sa。 amount_sold）country_amount_sold FROM sales sa，customers cu，countries co WHERE sa.cust_id = cu.cust_id AND cu.country_id = co.country_id GROUP BY co.country_id，co.country_name，co.country_subregion，co.country_region;</pre></div>
                        <!-- class="example" -->
                        <div class="section">
                           <div class="infoboxnotealso" id="GUID-F9C356AF-AAF0-4DF4-AE5F-01ECDBFDAFF1__GUID-0D90B21B-BA18-4C0B-B115-975BFFAC8071">
                              <p class="notep1">也可以看看：</p>
                              <p>有关数据仓库和物化视图的信息，请<a href="../dwhsg/basic-materialized-views.html#DWHSG-GUID-A7AE8E5D-68A5-4519-81EB-252EAAF0ADFF" target="_blank"><span><cite>参见“Oracle数据库数据仓库指南”</cite></span></a></p>
                           </div>
                        </div>
                        <!-- class="section" -->
                     </div>
                  </div>
               </div>
            </div><a id="VLDBG00504"></a><div class="props_rev_3"><a id="GUID-59D360A4-518E-47A2-83E4-DB103AD995BF" name="GUID-59D360A4-518E-47A2-83E4-DB103AD995BF"></a><h3 id="VLDBG-GUID-59D360A4-518E-47A2-83E4-DB103AD995BF" class="sect3">数据仓库中的可管理性</h3>
               <div>
                  <p>数据仓库存储历史数据。数据仓库的重要部分是数据加载和清除。分区是一种强大的技术，可以帮助数据仓库进行数据管理。</p>
                  <p>本节包含以下主题：</p>
                  <ul style="list-style-type:disc">
                     <li>
                        <p><a href="partition-warehouse.html#GUID-2AF83B38-5895-495F-B3E5-6529A2660AE8" title="可以使用分区交换负载（PEL）添加分区。">分区交换负载</a></p>
                     </li>
                     <li>
                        <p><a href="partition-warehouse.html#GUID-97F3FB90-D87C-4E9B-B9F6-36503DCF9280" title="分区维护操作最容易在本地索引上执行。">分区和索引</a></p>
                     </li>
                     <li>
                        <p><a href="partition-warehouse.html#GUID-557D44F3-4A54-4C49-AD82-5C8F6A81EE89" title="数据仓库通常保留数据的时间窗口。例如，存储三年的历史数据。">从表中删除数据</a></p>
                     </li>
                     <li>
                        <p><a href="partition-warehouse.html#GUID-3ABCDEA5-1EE6-4D9D-98FD-DD673702A214" title="可以逐个分区地压缩分区表中的数据。">分区和数据压缩</a></p>
                     </li>
                  </ul>
                  <div class="infoboxnotealso" id="GUID-59D360A4-518E-47A2-83E4-DB103AD995BF__GUID-B1730163-A77B-4B31-A6F5-187024303F4A">
                     <p class="notep1">也可以看看：</p>
                     <p><a href="https://www.oracle.com/pls/topic/lookup?ctx=en/database/oracle/oracle-database/19/vldbg&amp;id=TGSQL335" target="_blank"><span><cite>“Oracle数据库SQL调优指南”</cite></span></a> ，了解有关收集和管理分区索引，交换和表的统计信息的信息</p>
                  </div>
               </div><a id="VLDBG1361"></a><div class="props_rev_3"><a id="GUID-2AF83B38-5895-495F-B3E5-6529A2660AE8" name="GUID-2AF83B38-5895-495F-B3E5-6529A2660AE8"></a><h4 id="VLDBG-GUID-2AF83B38-5895-495F-B3E5-6529A2660AE8" class="sect4">分区交换负载</h4>
                  <div>
                     <p>可以使用分区交换负载（PEL）添加分区。</p>
                     <p>使用PEL时，您将创建一个看起来与单个分区完全相同的单独表，包括相同的索引和约束（如果有）。如果使用复合分区表，则单独的表必须使用与复合分区表的子分区策略匹配的分区策略。然后，您可以使用此单独的表交换现有的表分区。在数据加载方案中，可以将数据加载到单独的表中。在不影响表用户查询的情况下，在单独的表上构建索引并实现约束。然后执行PEL，与数据加载相比，这是一个影响非常小的事务。在数据仓库环境中，日常负载（按天使用范围分区策略）很常见。</p>
                     <p>以下示例显示<code class="codeph">sales</code>表的分区交换负载：</p><pre class="oac_no_warn" dir="ltr">ALTER TABLE sales ADD PARTITION p_sales_jun_2007 VALUE少于（TO_DATE（'01-FEB-2007'，'dd-MON-yyyy'））; CREATE TABLE sales_jun_2007 COMPRESS FOR OLTP AS SELECT * FROM sales WHERE 1 = 0;</pre><p>接下来，使用2007年6月的销售数量填充表<code class="codeph">sales_jun_2007</code> ，并创建已在<code class="codeph">sales</code>表上实现的等效位图索引和约束：</p><pre class="oac_no_warn" dir="ltr">CREATE BITMAP INDEX time_id_jun_2007_bix ON sales_jun_2007（time_id）NOLOGGING; CREATE BITMAP INDEX cust_id_jun_2007_bix ON sales_jun_2007（cust_id）NOLOGGING; CREATE BITMAP INDEX prod_id_jun_2007_bix ON sales_jun_2007（prod_id）NOLOGGING; CREATE BITMAP INDEX promo_id_jun_2007_bix ON sales_jun_2007（promo_id）NOLOGGING; CREATE BITMAP INDEX channel_id_jun_2007_bix ON sales_jun_2007（channel_id）NOLOGGING; ALTER TABLE sales_jun_2007 ADD CONSTRAINT prod_id_fk FOREIGN KEY（prod_id）REFERENCES products（prod_id）; ALTER TABLE sales_jun_2007 ADD CONSTRAINT cust_id_fk FOREIGN KEY（cust_id）REFERENCES customers（cust_id）; ALTER TABLE sales_jun_2007 ADD CONSTRAINT promo_id_fk FOREIGN KEY（promo_id）参考促销（promo_id）; ALTER TABLE sales_jun_2007 ADD CONSTRAINT time_id_fk FOREIGN KEY（time_id）REFERENCES times（time_id）; ALTER TABLE sales_jun_2007 ADD CONSTRAINT channel_id_fk FOREIGN KEY（channel_id）REFERENCES channels（channel_id）;</pre><p>接下来，交换分区：</p><pre class="oac_no_warn" dir="ltr">ALTER TABLE sales EXCHANGE PARTITION p_sales_jun_2007 WITH TABLE sales_jun_2007包括索引;</pre><p>有关分区交换负载的更多信息，请参阅<a href="partition-admin.html#GUID-F2C99CFA-1090-4A62-B452-D4E116A40A34" title="使用分区表和索引时，分区管理是一项重要任务。">分区管理</a> 。
                     </p>
                  </div>
               </div><a id="VLDBG1362"></a><div class="props_rev_3"><a id="GUID-97F3FB90-D87C-4E9B-B9F6-36503DCF9280" name="GUID-97F3FB90-D87C-4E9B-B9F6-36503DCF9280"></a><h4 id="VLDBG-GUID-97F3FB90-D87C-4E9B-B9F6-36503DCF9280" class="sect4">分区和索引</h4>
                  <div>
                     <p>分区维护操作最容易在本地索引上执行。</p>
                     <p>在进行分区管理时，本地索引不会使全局索引无效。在PEL语句中使用<code class="codeph">INCLUDING INDEXES</code>将本地索引与单独表上的等效索引进行交换，以便不会使索引分区失效。对于PEL，您可以将全局索引更新为负载的一部分。使用PEL语句的<code class="codeph">UPDATE GLOBAL INDEXES</code>扩展。如果索引需要更新，那么PEL需要更长的时间。
                     </p>
                  </div>
               </div><a id="VLDBG1364"></a><div class="props_rev_3"><a id="GUID-557D44F3-4A54-4C49-AD82-5C8F6A81EE89" name="GUID-557D44F3-4A54-4C49-AD82-5C8F6A81EE89"></a><h4 id="VLDBG-GUID-557D44F3-4A54-4C49-AD82-5C8F6A81EE89" class="sect4">从表中删除数据</h4>
                  <div>
                     <p>数据仓库通常保留数据的时间窗口。例如，存储三年的历史数据。</p>
                     <p>分区使得从表中清除数据变得非常容易。您可以使用<code class="codeph">DROP PARTITION</code>或<code class="codeph">TRUNCATE PARTITION</code>语句清除数据。常见策略还包括使用分区交换负载从表中卸载数据，并在删除分区之前用空表替换分区。归档您在清空或删除之前交换的单独表。
                     </p>
                     <p>drop或truncate操作会使全局索引或全局分区索引无效。本地索引仍然有效。删除表分区时，将删除本地索引分区。</p>
                     <p>以下示例显示如何从<code class="codeph">sales</code>表中删除分区<code class="codeph">sales_1995</code> ：</p><pre class="oac_no_warn" dir="ltr">ALTER TABLE销售DROP PARTITION sales_1995更新全球指数并行;</pre></div>
               </div><a id="VLDBG1365"></a><div class="props_rev_3"><a id="GUID-3ABCDEA5-1EE6-4D9D-98FD-DD673702A214" name="GUID-3ABCDEA5-1EE6-4D9D-98FD-DD673702A214"></a><h4 id="VLDBG-GUID-3ABCDEA5-1EE6-4D9D-98FD-DD673702A214" class="sect4">分区和数据压缩</h4>
                  <div>
                     <p>可以逐个分区地压缩分区表中的数据。</p>
                     <p>对于不经常更改的数据，使用压缩数据最有效。通常的数据仓库方案通常会在数据老化时看到很少的数据更改，而其他方案仅插入数据使用分区管理功能，您可以逐个分区地压缩数据。尽管Oracle数据库支持对所有DML操作进行压缩，但在非压缩表中修改数据仍然更有效。</p>
                     <p>更改分区以启用压缩仅适用于要插入分区的未来数据。要压缩分区中的现有数据，必须移动分区。可以在单个操作中完成启用压缩和移动分区。</p>
                     <p>要对具有位图索引的分区表使用表压缩，必须在首次引入压缩属性之前执行以下操作：</p>
                     <ol>
                        <li>
                           <p>标记位图索引<code class="codeph">UNUSABLE</code> 。</p>
                        </li>
                        <li>
                           <p>设置压缩属性。</p>
                        </li>
                        <li>
                           <p>重建索引。</p>
                        </li>
                     </ol>
                     <p>第一次将压缩分区作为现有的完全未压缩分区表的一部分时，必须先删除所有现有位图索引，或者在添加压缩分区之前将其标记为<code class="codeph">UNUSABLE</code> 。无论任何分区是否包含数据，都必须执行此操作。它还与导致一个或多个压缩分区成为表的一部分的操作无关。这不适用于仅具有B树索引的分区表。
                     </p>
                     <p>以下示例显示如何在<code class="codeph">sales</code>表中压缩<code class="codeph">SALES_1995</code>分区：</p><pre class="oac_no_warn" dir="ltr">ALTER TABLE销售MOVE PARTITION sales_1995 COMPRESS FOR OLTP PARALLEL NOLOGGING;</pre><p>如果表或分区在磁盘上占用的空间较少，则I / O约束环境中的大型表扫描的性能可能会提高。</p>
                  </div>
               </div>
            </div>
         </div>
      </article>
   </body>
</html>