<html lang="en-us" dir="ltr" xml:lang="en-us">
   <head>
      <meta http-equiv="Content-Type" content="text/html; charset=utf-8"></meta>
      <meta name="viewport" content="width=device-width, initial-scale=1"></meta>
      <meta http-equiv="X-UA-Compatible" content="IE=edge"></meta>
      <meta name="abstract" content="A trigger is like a stored procedure that Oracle Database invokes automatically whenever a specified event occurs."></meta>
      <meta name="description" content="A trigger is like a stored procedure that Oracle Database invokes automatically whenever a specified event occurs."></meta>
      <title>PL / SQL触发器</title>
      <meta property="og:site_name" content="Oracle Help Center"></meta>
      <meta property="og:title" content="Database PL/SQL Language Reference "></meta>
      <meta property="og:description" content="A trigger is like a stored procedure that Oracle Database invokes automatically whenever a specified event occurs."></meta>
      <link rel="stylesheet" href="/sp_common/book-template/ohc-book-template/css/book.css"></link>
      <link rel="shortcut icon" href="/sp_common/book-template/ohc-common/img/favicon.ico"></link>
      <meta name="application-name" content="Database PL/SQL Language Reference"></meta>
      <meta name="generator" content="DITA Open Toolkit version 1.8.5 (Mode = doc)"></meta>
      <meta name="plugin" content="SP_docbuilder HTML plugin release 18.2.2"></meta>
      <link rel="alternate" href="database-pl-sql-language-reference.pdf" title="PDF File" type="application/pdf"></link>
      <meta name="robots" content="all"></meta>
      <link rel="schema.dcterms" href="http://purl.org/dc/terms/"></link>
      <meta name="dcterms.created" content="2019-01-13T20:26:20-08:00"></meta>
      
      <meta name="dcterms.dateCopyrighted" content="1996, 2019"></meta>
      <meta name="dcterms.category" content="database"></meta>
      <meta name="dcterms.identifier" content="E96448-02"></meta>
      
      <meta name="dcterms.product" content="en/database/oracle/oracle-database/19"></meta>
      
      <link rel="prev" href="plsql-subprograms.html" title="Previous" type="text/html"></link>
      <link rel="next" href="plsql-packages.html" title="Next" type="text/html"></link>
      <script>
        document.write('<style type="text/css">');
        document.write('body > .noscript, body > .noscript ~ * { visibility: hidden; }');
        document.write('</style>');
     </script>
      <script src="/sp_common/book-template/requirejs/require.js" data-main="/sp_common/book-template/ohc-book-template/js/book-config"></script>
      <script>
            if (window.require === undefined) {
                document.write('<script data-main="sp_common/book-template/ohc-book-template/js/book-config" src="sp_common/book-template/requirejs/require.js"><\/script>');
                document.write('<link href="sp_common/book-template/ohc-book-template/css/book.css" rel="stylesheet"/>');
            }
        </script>
      <script type="application/json" id="ssot-metadata">{"primary":{"category":{"short_name":"database","element_name":"Database","display_in_url":true},"suite":{"short_name":"oracle","element_name":"Oracle","display_in_url":true},"product_group":{"short_name":"not-applicable","element_name":"Not applicable","display_in_url":false},"product":{"short_name":"oracle-database","element_name":"Oracle Database","display_in_url":true},"release":{"short_name":"19","element_name":"Release 19","display_in_url":true}}}</script>
      
    <meta name="dcterms.title" content="Database PL/SQL Language Reference"></meta>
    <meta name="dcterms.isVersionOf" content="LNPLS"></meta>
    <meta name="dcterms.release" content="Release 19"></meta>
  </head>
   <body dir="ltr">
      <div class="noscript alert alert-danger text-center" role="alert">
         <a href="plsql-subprograms.html" class="pull-left"><span class="glyphicon glyphicon-chevron-left" aria-hidden="true"></span>上一页</a> <a href="plsql-packages.html" class="pull-right">下一页<span class="glyphicon glyphicon-chevron-right" aria-hidden="true"></span></a> <span class="fa fa-exclamation-triangle" aria-hidden="true"></span>必须启用JavaScript才能正确显示此内容</div>
      <article>
         <header>
            <ol class="breadcrumb" vocab="http://schema.org/" typeof="BreadcrumbList">
               <li property="itemListElement" typeof="ListItem"><a href="index.html" property="item" typeof="WebPage"><span property="name">数据库PL / SQL语言参考</span></a></li>
               <li class="active" property="itemListElement" typeof="ListItem">PL / SQL触发器</li>
            </ol>
            <a id="GUID-217E8B13-29EF-45F3-8D0F-2384F9F1D231" name="GUID-217E8B13-29EF-45F3-8D0F-2384F9F1D231"></a><a id="LNPLS604"></a><a id="LNPLS020"></a>
            
            <h2 id="LNPLS-GUID-217E8B13-29EF-45F3-8D0F-2384F9F1D231" class="sect2"><span class="enumeration_chapter">9个</span> PL / SQL触发器</h2>
         </header>
         <div class="ind"><script type="text/javascript">window.name='plsql-triggers'</script><script type="text/javascript">
    function footdisplay(footnum,footnote) {
    var msg = window.open('about:blank', 'NewWindow' + footnum,
        'directories=no,height=100,location=no,menubar=no,resizable=yes,' +
        'scrollbars=yes,status=no,toolbar=no,width=598');
    msg.document.open('text/html');
    msg.document.write('<!DOCTYPE html ');
    msg.document.write('PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" ');
    msg.document.write('"http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">'); 
    msg.document.write('<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en-us" lang="en-us" dir="ltr"><head><title>');
   
    msg.document.write('Footnote&nbsp; ' + footnum);
    msg.document.write('<\/title><meta http-equiv="Content-Type" ');
    msg.document.write('content="text/html; charset=utf-8" />');
    msg.document.write('<meta http-equiv="Content-Script-Type" ');
    msg.document.write('content="text/javascript" />');
    msg.document.write('<style type="text/css"> <![CDATA[ ');
    msg.document.write('h1 {text-align: center; font-size: 14pt;}');
    msg.document.write('fieldset {border: none;}');
    msg.document.write('form {text-align: center;}');
    msg.document.write(' ]]u003e </style>');
    msg.document.write('<\/head><body><div id="footnote"><h1>Footnote&nbsp; ' + footnum + '<\/h1><p>');
    msg.document.write(footnote);
    msg.document.write('<\/p><form action="" method="post"><fieldset>');
    msg.document.write('<input type="button" value="OK" ');
    msg.document.write('onclick="window.close();" />');
    msg.document.write('<\/fieldset><\/form><\/div><\/body><\/html>');
    msg.document.close();
    setTimeout(function() {
        var height = msg.document.getElementById('footnote').offsetHeight;
        msg.resizeTo(598, height + 100);
    }
    , 100);
    msg.focus();
}
            </script><noscript>
               <p>此页面上的脚本内容仅用于导航目的，不会以任何方式更改内容。</p>
            </noscript>
            <div>
               <p>触发器就像Oracle Database在发生指定事件时自动调用的存储过程。</p>
               <div class="infoboxnote" id="GUID-217E8B13-29EF-45F3-8D0F-2384F9F1D231__GUID-17AE2955-1CC1-4C51-BE2A-3FBA1A67CF51">
                  <p class="notep1">注意：</p>
                  <p>数据库只能检测系统定义的事件。您无法定义自己的活动。</p>
               </div>
               <div class="section">
                  <p class="subhead1" id="GUID-217E8B13-29EF-45F3-8D0F-2384F9F1D231__GUID-D63D9504-6E46-4365-B76C-9F12D2067B22">话题</p>
               </div>
               <!-- class="section" -->
               <ul style="list-style-type:disc">
                  <li>
                     <p><a href="plsql-triggers.html#GUID-3CD2CC67-5AC2-4DD5-B7D3-12E5FAE082C9" title="与存储过程类似，触发器是一个名为PL / SQL的单元，存储在数据库中并可以重复调用。与存储过程不同，您可以启用和禁用触发器，但不能显式调用它。">触发器概述</a></p>
                  </li>
                  <li>
                     <p><a href="plsql-triggers.html#GUID-C08EA160-8FD2-4A10-9733-6F2D20C83E93" title="触发器允许您自定义数据库管理系统。">使用触发器的原因</a></p>
                  </li>
                  <li>
                     <p><a href="plsql-triggers.html#GUID-E76C8044-6942-4573-B7DB-3502FB96CF6F" title="在表或视图上创建DML触发器，其触发事件由DML语句DELETE，INSERT和UPDATE组成。">DML触发器</a></p>
                  </li>
                  <li>
                     <p><a href="plsql-triggers.html#GUID-4CF74E99-8859-4AB1-96E7-07898A2ABB9E">相关名称和伪记录</a></p>
                  </li>
                  <li>
                     <p><a href="plsql-triggers.html#GUID-FE23FCE8-DE36-41EF-80A9-6B4B49E80E5B" title="在架构或数据库上创建系统触发器。">系统触发器</a></p>
                  </li>
                  <li>
                     <p><a href="plsql-triggers.html#GUID-E11CFB2F-064F-42EB-8390-F025564AD107">触发器调用的子程序</a></p>
                  </li>
                  <li>
                     <p><a href="plsql-triggers.html#GUID-39111AAC-597E-4661-82A6-F3BE621F75BB">触发器编译，无效和重新编译</a></p>
                  </li>
                  <li>
                     <p><a href="plsql-triggers.html#GUID-FA7A16B6-F94D-4E4C-A326-F602FE9FE3E8">触发器中的异常处理</a></p>
                  </li>
                  <li>
                     <p><a href="plsql-triggers.html#GUID-78B64011-B288-4EDD-B595-2DDBB3835ACA">触发设计指南</a></p>
                  </li>
                  <li>
                     <p><a href="plsql-triggers.html#GUID-5B3A43E2-B9E1-4015-9A6C-0BE696853F3F">触发限制</a></p>
                  </li>
                  <li>
                     <p><a href="plsql-triggers.html#GUID-2585112C-C48F-40ED-B825-21DF975EA126">触发器触发的顺序</a></p>
                  </li>
                  <li>
                     <p><a href="plsql-triggers.html#GUID-6CD799AB-FAEF-493A-8A58-2394E400072C" title="默认情况下，CREATE TRIGGER语句在启用状态下创建触发器。要在禁用状态下创建触发器，请指定DISABLE。在禁用状态下创建触发器可以确保在启用它之前编译没有错误。">触发启用和禁用</a></p>
                  </li>
                  <li>
                     <p><a href="plsql-triggers.html#GUID-4F200DEC-9B4B-4DCC-A86D-1DB2E281A43C">触发更改和调试</a></p>
                  </li>
                  <li>
                     <p><a href="plsql-triggers.html#GUID-F1103CD4-A84F-4440-9250-872212BDC5A9">触发器和Oracle数据库数据传输实用程序</a></p>
                  </li>
                  <li>
                     <p><a href="plsql-triggers.html#GUID-2951D8A6-6C80-428F-840D-13A76A97E365">发布事件的触发器</a></p>
                  </li>
                  <li>
                     <p><a href="plsql-triggers.html#GUID-F843EE28-6D46-4AA2-B3B3-7CB5485B96CE">有关触发器的信息的视图</a></p>
                  </li>
               </ul>
            </div><a id="LNPLS2001"></a><div class="props_rev_3"><a id="GUID-3CD2CC67-5AC2-4DD5-B7D3-12E5FAE082C9" name="GUID-3CD2CC67-5AC2-4DD5-B7D3-12E5FAE082C9"></a><h3 id="LNPLS-GUID-3CD2CC67-5AC2-4DD5-B7D3-12E5FAE082C9" class="sect3"><span class="enumeration_section">9.1</span>触发器概述</h3>
               <div>
                  <p>与存储过程类似，触发器是一个名为PL / SQL的单元，存储在数据库中并可以重复调用。与存储过程不同，您可以启用和禁用触发器，但不能显式调用它。</p>
                  <p><span class="bold">启用</span>触发器时，数据库会自动调用它 - 也就是说，触发器<span class="bold">会</span>在其触发事件发生时触发。触发器被<span class="bold">禁用时</span> ，它不会触发。
                  </p>
                  <p>使用<code class="codeph">CREATE</code> <code class="codeph">TRIGGER</code>语句<code class="codeph">CREATE</code> <code class="codeph">TRIGGER</code> 。您可以根据<span class="bold">触发语句</span>及其作用的项来指定<span class="bold">触发事件</span> 。触发器被称为在项目<span class="bold">上</span> <span class="bold">创建</span>或<span class="bold">在</span>项目<span class="bold">上</span> <span class="bold">定义，</span>该项目是表格，视图，模式或数据库。您还可以指定<span class="bold">时间点</span> ，该<span class="bold">时间点</span>确定触发器在触发语句运行之前或之后是否触发，以及是否触发触发语句影响的每一行。默认情况下，会在启用状态下创建触发器。
                  </p>
                  <p>如果在表或视图上创建触发器，则触发事件由DML语句组成，触发器称为<span class="bold">DML触发器</span> 。
                  </p>
                  <p><span class="bold">交叉触发器</span>是DML触发器，仅用于基于版本的重新定义。
                  </p>
                  <p>如果在模式或数据库上创建触发器，则触发事件由DDL或数据库操作语句组成，触发器称为<span class="bold">系统触发器</span> 。
                  </p>
                  <p><span class="bold">条件触发器</span>是具有<code class="codeph">WHEN</code>子句的DML或系统触发器，该子句指定数据库为触发语句影响的每一行计算的SQL条件。
                  </p>
                  <p>触发器触发时，触发器引用的表可能正在进行其他用户事务中SQL语句所做的更改。在触发器中运行的SQL语句遵循独立SQL语句所执行的相同规则。特别：</p>
                  <ul style="list-style-type:disc">
                     <li>
                        <p>触发器中的查询将查看引用表的当前读取一致的物化视图以及同一事务中更改的任何数据。</p>
                     </li>
                     <li>
                        <p>触发器中的更新等待在继续之前释放现有数据锁。</p>
                     </li>
                  </ul>
                  <p><span class="bold"><code class="codeph">INSTEAD</code></span> <span class="bold"><code class="codeph">OF</code></span> <span class="bold">触发器</span>是：</p>
                  <ul style="list-style-type:disc">
                     <li>
                        <p>在非编辑视图的非编辑视图或嵌套表列上创建的DML触发器</p>
                     </li>
                     <li>
                        <p>在<code class="codeph">CREATE</code>语句上定义的系统触发器</p>
                     </li>
                  </ul>
                  <p>数据库触发<code class="codeph">INSTEAD</code> <code class="codeph">OF</code>触发器而不是运行触发语句。
                  </p>
                  <div class="infoboxnote" id="GUID-3CD2CC67-5AC2-4DD5-B7D3-12E5FAE082C9__GUID-6B773E51-CA6D-4249-B7F8-19F68A563B14">
                     <p class="notep1">注意：</p>
                     <p>触发器通常由其触发语句的名称（例如， <span class="italic"><code class="codeph">DELETE</code></span> <span class="italic">触发器</span>或<span class="italic"><code class="codeph">LOGON</code></span> <span class="italic">触发器</span> ），定义它的项的名称（例如， <span class="italic"><code class="codeph">DATABASE</code></span> <span class="italic">触发器</span>或<span class="italic"><code class="codeph">SCHEMA</code></span> <span class="italic">触发器</span> ）或其时间点（用于例如， <span class="italic"><code class="codeph">BEFORE</code></span> <span class="italic">语句触发器</span>或<span class="italic"><code class="codeph">AFTER</code></span> <span class="italic">每一行触发</span> ）。
                     </p>
                  </div>
                  <div class="section">
                     <div class="infoboxnotealso" id="GUID-3CD2CC67-5AC2-4DD5-B7D3-12E5FAE082C9__GUID-200E3209-7097-4A76-B893-7A5BC39B4066">
                        <p class="notep1">也可以看看：</p>
                        <ul style="list-style-type:disc">
                           <li>
                              <p><span class="q">“ <a href="CREATE-TRIGGER-statement.html#GUID-AF9E33F1-64D1-4382-A6A4-EC33C36F237B">CREATE TRIGGER Statement</a> ”</span>语法图</p>
                           </li>
                           <li>
                              <p><span class="q">“ <a href="plsql-triggers.html#GUID-E76C8044-6942-4573-B7DB-3502FB96CF6F" title="在表或视图上创建DML触发器，其触发事件由DML语句DELETE，INSERT和UPDATE组成。">DML触发器</a> ”</span></p>
                           </li>
                           <li>
                              <p><span class="q">“ <a href="plsql-triggers.html#GUID-FE23FCE8-DE36-41EF-80A9-6B4B49E80E5B" title="在架构或数据库上创建系统触发器。">系统触发器</a> ”</span></p>
                           </li>
                           <li>
                              <p><a href="../adfns/editions.html#ADFNS0203" target="_blank"><span class="italic">Oracle数据库开发指南</span></a> ，了解有关交叉触发器的信息</p>
                           </li>
                           <li>
                              <p>有关<code class="codeph">WHEN</code>子句的信息，请<code class="codeph">WHEN</code> <span class="q">“ <a href="CREATE-TRIGGER-statement.html#GUID-AF9E33F1-64D1-4382-A6A4-EC33C36F237B">CREATE TRIGGER语句</a> ”</span></p>
                           </li>
                        </ul>
                     </div>
                  </div>
                  <!-- class="section" -->
               </div>
            </div><a id="LNPLS769"></a><a id="LNPLS723"></a><div class="props_rev_3"><a id="GUID-C08EA160-8FD2-4A10-9733-6F2D20C83E93" name="GUID-C08EA160-8FD2-4A10-9733-6F2D20C83E93"></a><h3 id="LNPLS-GUID-C08EA160-8FD2-4A10-9733-6F2D20C83E93" class="sect3"><span class="enumeration_section">9.2</span>使用触发器的原因</h3>
               <div>
                  <p>触发器允许您自定义数据库管理系统。</p>
                  <p>例如，您可以使用触发器：</p>
                  <ul style="list-style-type:disc">
                     <li>
                        <p>自动生成虚拟列值</p>
                     </li>
                     <li>
                        <p>记录事件</p>
                     </li>
                     <li>
                        <p>收集有关表访问的统计信息</p>
                     </li>
                     <li>
                        <p>在针对视图发出DML语句时修改表数据</p>
                     </li>
                     <li>
                        <p>当子表和父表位于分布式数据库的不同节点上时，强制实施参照完整性</p>
                     </li>
                     <li>
                        <p>将有关数据库事件，用户事件和SQL语句的信息发布到订阅应用程序</p>
                     </li>
                     <li>
                        <p>在正常工作时间之后阻止对表的DML操作</p>
                     </li>
                     <li>
                        <p>防止无效的交易</p>
                     </li>
                     <li>
                        <p>实施您无法使用约束定义的复杂业务或参照完整性规则（请参阅<span class="q">“ <a href="plsql-triggers.html#GUID-C08EA160-8FD2-4A10-9733-6F2D20C83E93__CIHCEBAE">触发器和约束如何不同</a> ”</span> ）</p>
                     </li>
                  </ul>
                  <div class="infoboxnote" id="GUID-C08EA160-8FD2-4A10-9733-6F2D20C83E93__GUID-14BEA9EA-2AC7-42AF-8F7E-52D7B4A02E22">
                     <p class="notep1">警告：</p>
                     <p>触发器不是可靠的安全机制，因为它们是编程的并且易于禁用。要获得高可靠性安全性，请使用<a href="../dvadm/configuring-realms.html#DVADM-GUID-86DA4697-8BE2-4F27-92E3-C15843F9A3A6" target="_blank"><span class="italic">Oracle Database Vault管理员指南中</span></a>所述的<a href="../dvadm/configuring-realms.html#DVADM-GUID-86DA4697-8BE2-4F27-92E3-C15843F9A3A6" target="_blank"><span class="italic">Oracle Database Vault</span></a> 。
                     </p>
                  </div>
                  <div class="section" id="GUID-C08EA160-8FD2-4A10-9733-6F2D20C83E93__CIHCEBAE">
                     <p class="subhead2" id="GUID-C08EA160-8FD2-4A10-9733-6F2D20C83E93__GUID-DDFFCAAC-25E3-42C7-A287-1D12889A24A7">触发器和约束如何不同</p>
                  </div>
                  <!-- class="section" -->
                  <div class="section">
                     <p>触发器和约束都可以限制数据输入，但它们之间存在显着差异。</p>
                     <p>触发器始终仅适用于新数据。例如，触发器可以阻止DML语句将<code class="codeph">NULL</code>值插入数据库列，但该列可能包含在定义触发器之前或禁用触发器时插入到列中的<code class="codeph">NULL</code>值。
                     </p>
                     <p>约束可以仅应用于新数据（如触发器），也可以应用于新数据和现有数据。约束行为取决于约束状态，如<a href="https://www.oracle.com/pls/topic/lookup?ctx=en/database/oracle/oracle-database/19/lnpls&amp;id=SQLRF52214" target="_blank"><span class="italic">Oracle数据库SQL语言参考中所述</span></a> 。
                     </p>
                     <p>与强制执行相同规则的触发器相比，约束更容易编写并且更不容易出错。但是，触发器可以强制执行一些约束不能的复杂业务规则。Oracle强烈建议您仅在以下情况下使用触发器来约束数据输入：</p>
                     <ul style="list-style-type:disc">
                        <li>
                           <p>在子表和父表位于分布式数据库的不同节点上时强制实施参照完整性</p>
                        </li>
                        <li>
                           <p>要强制执行无法使用约束定义的复杂业务或参照完整性规则</p>
                        </li>
                     </ul>
                     <div class="infoboxnotealso" id="GUID-C08EA160-8FD2-4A10-9733-6F2D20C83E93__GUID-764F7673-B701-48A6-B1A3-53FA34731726">
                        <p class="notep1">也可以看看：</p>
                        <ul style="list-style-type:disc">
                           <li>
                              <p><a href="../adfns/data-integrity.html#ADFNS004" target="_blank"><span class="italic">“Oracle数据库开发指南”</span></a> ，了解有关使用约束来强制实施业务规则以及防止将无效信息输入表的信息</p>
                           </li>
                           <li>
                              <p><span class="q">“ <a href="plsql-triggers.html#GUID-AD8188E5-546E-46EB-A000-7EB9D17C3D0C">用于确保参照完整性的触发器</a> ”，</span>以获取有关使用触发器和约束来维护父表和子表之间的引用完整性的信息</p>
                           </li>
                        </ul>
                     </div>
                  </div>
                  <!-- class="section" -->
               </div>
            </div><a id="LNPLS609"></a><a id="LNPLS99888"></a><div class="props_rev_3"><a id="GUID-E76C8044-6942-4573-B7DB-3502FB96CF6F" name="GUID-E76C8044-6942-4573-B7DB-3502FB96CF6F"></a><h3 id="LNPLS-GUID-E76C8044-6942-4573-B7DB-3502FB96CF6F" class="sect3"><span class="enumeration_section">9.3</span> DML触发器</h3>
               <div>
                  <p>在表或视图上创建<span class="bold">DML触发器</span> ，其触发事件由DML语句<code class="codeph">DELETE</code> ， <code class="codeph">INSERT</code>和<code class="codeph">UPDATE</code> 。</p>
                  <p>要创建响应<code class="codeph">MERGE</code>语句而触发的触发器，请在<code class="codeph">MERGE</code>操作分解的<code class="codeph">INSERT</code>和<code class="codeph">UPDATE</code>语句上创建触发器。
                  </p>
                  <p>DML触发器是简单触发器或复合触发器。</p>
                  <p>一个<span class="bold">简单的DML触发器只</span>触发其中一个时间点：</p>
                  <ul style="list-style-type:disc">
                     <li>
                        <p>在触发语句运行之前</p>
                        <p>（触发器称为<span class="italic"><code class="codeph">BEFORE</code></span> <span class="italic">语句触发器</span>或<span class="italic">语句级</span> <span class="italic"><code class="codeph">BEFORE</code></span> <span class="italic">触发器。</span> ）
                        </p>
                     </li>
                     <li>
                        <p>触发语句运行后</p>
                        <p>（触发器称为<span class="italic"><code class="codeph">AFTER</code></span> <span class="italic">语句触发器</span>或<span class="italic">语句级</span> <span class="italic"><code class="codeph">AFTER</code></span> <span class="italic">触发器。</span> ）
                        </p>
                     </li>
                     <li>
                        <p>在触发语句影响的每一行之前</p>
                        <p>（触发器<span class="italic"><code class="codeph">BEFORE</code></span> <span class="italic">每个行触发器</span>或<span class="italic">行级</span> <span class="italic"><code class="codeph">BEFORE</code></span> <span class="italic">触发器</span> <span class="italic"><code class="codeph">BEFORE</code></span>被称为<span class="italic"><code class="codeph">BEFORE</code></span> <span class="italic">。</span> ）
                        </p>
                     </li>
                     <li>
                        <p>在触发语句影响的每一行之后</p>
                        <p>（触发器在<span class="italic">每个行触发器</span>或<span class="italic">行级</span> <span class="italic"><code class="codeph">AFTER</code></span> <span class="italic">触发器</span> <span class="italic"><code class="codeph">AFTER</code></span>称为<span class="italic">。</span> ）
                        </p>
                     </li>
                  </ul>
                  <p>在表或编辑视图上创建的<span class="bold">复合DML触发器</span>可以在前一个，一些或所有时间点<span class="bold">触发</span> 。复合DML触发器有助于编写一种方法，您希望为各种时序点实现的操作共享公共数据。
                  </p>
                  <p>在行级别触发的简单或复合DML触发器可以访问正在处理的行中的数据。有关详细信息，请参阅<span class="q">“ <a href="plsql-triggers.html#GUID-4CF74E99-8859-4AB1-96E7-07898A2ABB9E">关联名称和伪记录</a> ”</span> 。
                  </p>
                  <p><span class="bold"><code class="codeph">INSTEAD</code></span> <span class="bold"><code class="codeph">OF</code></span> <span class="bold">DML</span> <span class="bold">触发器</span>是在非编辑视图或非编辑视图的嵌套表列上创建的DML触发器。
                  </p>
                  <p>除了在<code class="codeph">INSTEAD</code> <code class="codeph">OF</code>触发器中，触发<code class="codeph">UPDATE</code>语句可以包括列列表。使用列列表时，仅在更新指定列时触发触发器。如果没有列列表，则会在更新关联表的任何列时触发触发器。
                  </p>
                  <div class="section">
                     <p class="subhead2" id="GUID-E76C8044-6942-4573-B7DB-3502FB96CF6F__GUID-73E3D770-4459-4417-8813-F4F61239FE27">话题</p>
                  </div>
                  <!-- class="section" -->
                  <div class="section">
                     <ul style="list-style-type:disc">
                        <li>
                           <p><a href="plsql-triggers.html#GUID-EC6A8FA1-9E60-4374-9905-639F4F100D83" title="DML触发器的触发事件可以由多个触发语句组成。当其中一个触发触发器时，触发器可以通过使用这些条件谓词来确定哪一个触发器。">检测触发DML语句的条件谓词</a></p>
                        </li>
                        <li>
                           <p><a href="plsql-triggers.html#GUID-9F06D45C-7C60-434E-A597-114A0C445671" title="INSTEAD OF DML触发器是在非编辑视图或非编辑视图的嵌套表列上创建的DML触发器。数据库触发INSTEAD OF触发器而不是运行触发DML语句。">INSTEAD OF DML触发器</a></p>
                        </li>
                        <li>
                           <p><a href="plsql-triggers.html#GUID-8A0DA171-BE6A-4798-A1A4-677B88EA16A0">复合DML触发器</a></p>
                        </li>
                        <li>
                           <p><a href="plsql-triggers.html#GUID-AD8188E5-546E-46EB-A000-7EB9D17C3D0C">确保参考完整性的触发器</a></p>
                        </li>
                     </ul>
                  </div>
                  <!-- class="section" -->
               </div><a id="LNPLS614"></a><a id="LNPLS750"></a><div class="props_rev_3"><a id="GUID-EC6A8FA1-9E60-4374-9905-639F4F100D83" name="GUID-EC6A8FA1-9E60-4374-9905-639F4F100D83"></a><h4 id="LNPLS-GUID-EC6A8FA1-9E60-4374-9905-639F4F100D83" class="sect4"><span class="enumeration_section">9.3.1</span>检测触发DML语句的条件谓词</h4>
                  <div>
                     <p>DML触发器的触发事件可以由多个触发语句组成。当其中一个触发触发器时，触发器可以通过使用这些<span class="bold">条件谓词</span>来确定哪一个触发器。
                     </p>
                     <div class="tblformal" id="GUID-EC6A8FA1-9E60-4374-9905-639F4F100D83__GUID-BAAE1E2E-72BD-4761-8CED-884BAAF3D08C">
                        <p class="titleintable">表9-1条件谓词</p>
                        <table cellpadding="4" cellspacing="0" class="Formal" title="条件谓词" width="100%" border="1" summary="This table has two columns. The left column lists the conditional predicates. The right column gives the condition under which each conditional predicate is true." frame="hsides" rules="rows">
                           <thead>
                              <tr align="left" valign="top">
                                 <th align="left" valign="bottom" width="36%" id="d67636e1061">条件谓词</th>
                                 <th align="left" valign="bottom" width="64%" id="d67636e1064">当且仅当：</th>
                              </tr>
                           </thead>
                           <tbody>
                              <tr align="left" valign="top">
                                 <td align="left" valign="top" width="36%" id="d67636e1069" headers="d67636e1061 ">
                                    <p><code class="codeph">INSERTING</code></p>
                                 </td>
                                 <td align="left" valign="top" width="64%" headers="d67636e1069 d67636e1064 ">
                                    <p><code class="codeph">INSERT</code>语句触发了触发器。
                                    </p>
                                 </td>
                              </tr>
                              <tr align="left" valign="top">
                                 <td align="left" valign="top" width="36%" id="d67636e1080" headers="d67636e1061 ">
                                    <p><code class="codeph">UPDATING</code></p>
                                 </td>
                                 <td align="left" valign="top" width="64%" headers="d67636e1080 d67636e1064 ">
                                    <p><code class="codeph">UPDATE</code>语句触发了触发器。
                                    </p>
                                 </td>
                              </tr>
                              <tr align="left" valign="top">
                                 <td align="left" valign="top" width="36%" id="d67636e1091" headers="d67636e1061 ">
                                    <p><code class="codeph">UPDATING ('</code> <span class="italic"><code class="codeph">column</code></span> <code class="codeph">')</code></p>
                                 </td>
                                 <td align="left" valign="top" width="64%" headers="d67636e1091 d67636e1064 ">
                                    <p>影响指定列的<code class="codeph">UPDATE</code>语句触发了触发器。
                                    </p>
                                 </td>
                              </tr>
                              <tr align="left" valign="top">
                                 <td align="left" valign="top" width="36%" id="d67636e1107" headers="d67636e1061 ">
                                    <p><code class="codeph">DELETING</code></p>
                                 </td>
                                 <td align="left" valign="top" width="64%" headers="d67636e1107 d67636e1064 ">
                                    <p><code class="codeph">DELETE</code>语句触发了触发器。
                                    </p>
                                 </td>
                              </tr>
                           </tbody>
                        </table>
                     </div>
                     <!-- class="inftblhruleinformal" -->
                     <p>条件谓词可以出现在<code class="codeph">BOOLEAN</code>表达式出现的任何位置。
                     </p>
                     <div class="example" id="GUID-EC6A8FA1-9E60-4374-9905-639F4F100D83__CIHBCDJH">
                        <p class="titleinexample">例9-1触发器使用条件谓词检测触发语句</p>
                        <p>此示例创建一个DML触发器，该触发器使用条件谓词来确定其四个可能的触发语句中的哪一个触发它。</p><pre class="oac_no_warn" dir="ltr">CREATE OR REPLACE TRIGGER吨BEFORE <span class="bold">INSERT OR</span> <span class="bold">UPDATE OF薪水，部门标识或</span> <span class="bold">删除</span>的雇员BEGIN CASE WHEN <span class="bold">插入</span> THEN DBMS_OUTPUT.PUT_LINE（ '插入'）;什么时候<span class="bold">更新（'工资'）</span>那么DBMS_OUTPUT.PUT_LINE（'更新工资'）;什么时候<span class="bold">更新（'department_id'）</span>那么DBMS_OUTPUT.PUT_LINE（'正在更新部门ID'）; <span class="bold">删除</span>那个DBMS_OUTPUT.PUT_LINE（'删除'）;结束案例;结束; /</pre></div>
                     <!-- class="example" -->
                  </div>
               </div><a id="LNPLS731"></a><a id="LNPLS615"></a><a id="LNPLS627"></a><a id="LNPLS20041"></a><div class="props_rev_3"><a id="GUID-9F06D45C-7C60-434E-A597-114A0C445671" name="GUID-9F06D45C-7C60-434E-A597-114A0C445671"></a><h4 id="LNPLS-GUID-9F06D45C-7C60-434E-A597-114A0C445671" class="sect4"><span class="enumeration_section">9.3.2安装</span> DML触发器</h4>
                  <div>
                     <p><code class="codeph">INSTEAD</code> <code class="codeph">OF</code> <code class="codeph">DML</code> <span class="bold">触发器</span>是在非编辑视图或非编辑视图的嵌套表列上创建的DML触发器。数据库触发<code class="codeph">INSTEAD</code> <code class="codeph">OF</code>触发器而不是运行触发DML语句。
                     </p>
                     <p><code class="codeph">INSTEAD</code> <code class="codeph">OF</code>触发器不能是有条件的。
                     </p>
                     <p><code class="codeph">INSTEAD</code> <code class="codeph">OF</code>触发器是更新本身不可更新的视图的唯一方法。设计<code class="codeph">INSTEAD</code> <code class="codeph">OF</code>触发器以确定要执行的操作，并对基础表执行适当的DML操作。
                     </p>
                     <p><code class="codeph">INSTEAD</code> <code class="codeph">OF</code>触发器始终是行级触发器。<code class="codeph">INSTEAD</code> <code class="codeph">OF</code>触发器可以读取<code class="codeph">OLD</code>和<code class="codeph">NEW</code>值，但不能更改它们。
                     </p>
                     <p>仅当触发语句对视图的指定嵌套表列的元素进行操作时，才会触发带有<code class="codeph">NESTED</code> <code class="codeph">TABLE</code>子句的<code class="codeph">INSTEAD</code> <code class="codeph">OF</code>触发器。触发器将触发每个已修改的嵌套表元素。
                     </p>
                     <div class="infoboxnotealso" id="GUID-9F06D45C-7C60-434E-A597-114A0C445671__GUID-BC972027-60C4-4C46-82EF-2CFE6D9AD835">
                        <p class="notep1">也可以看看：</p>
                        <ul style="list-style-type:disc">
                           <li>
                              <p>有关固有可更新视图的信息，请<a href="../sqlrf/CREATE-VIEW.html#SQLRF54782" target="_blank"><span class="italic">参见Oracle数据库SQL语言参考</span></a></p>
                           </li>
                           <li>
                              <p><span class="q">“ <a href="plsql-triggers.html#GUID-B42FDBCD-55F4-47E9-90BB-12B71D63D225">复合DML触发器结构</a> ”</span>有关复合DML的信息，可以使用<code class="codeph">INSTEAD</code> <code class="codeph">OF</code> <code class="codeph">EACH</code> <code class="codeph">ROW</code>部分触发</p>
                           </li>
                        </ul>
                     </div>
                     <div class="example" id="GUID-9F06D45C-7C60-434E-A597-114A0C445671__CIHFGDJG">
                        <p class="titleinexample">例9-2 INSTEAD OF触发器</p>
                        <p>此示例创建视图<code class="codeph">oe.order_info</code>以显示有关客户及其订单的信息。视图本身不可更新（因为<code class="codeph">orders</code>表的主键<code class="codeph">order_id</code>在连接视图的结果集中不是唯一的）。该示例创建一个<code class="codeph">INSTEAD</code> <code class="codeph">OF</code>触发器来处理定向到视图的<code class="codeph">INSERT</code>语句。触发器将行插入到视图， <code class="codeph">customers</code>和<code class="codeph">orders</code>的基表中。
                        </p><pre class="pre codeblock"><code>创建或替换视图order_info AS SELECT c.customer_id，c.cust_last_name，c.cust_first_name，o.order_id，o.order_date，o.order_status <span class="bold">FROM customers c，orders o</span> WHERE c.customer_id = o.customer_id;在order_info上创建或替换TRIGGER order_info_insert <span class="bold">INSTEAD OF INSERT</span> DECLARE duplicate_info EXCEPTION; PRAGMA EXCEPTION_INIT（duplicate_info，-00001）; BEGIN <span class="bold">INSERT INTO客户</span> <span class="bold">（customer_id，cust_last_name，cust_first_name）</span> <span class="bold">VALUES（</span> <span class="bold">：new.customer_id，</span> <span class="bold">：new.cust_last_name，</span> <span class="bold">：new.cust_first_name）;</span> <span class="bold">INSERT INTO订单（order_id，order_date，customer_id）</span> <span class="bold">VALUES（</span> <span class="bold">：new.order_id，</span> <span class="bold">：new.order_date，</span> <span class="bold">：new.customer_id）;</span> duplicate_info THEN RAISE_APPLICATION_ERROR（num =&gt; -20107，msg =&gt;'重复客户或订单ID'）时的异常; END order_info_insert; /</code></pre><p>查询以显示要插入的行不存在：</p><pre class="oac_no_warn" dir="ltr">SELECT COUNT（*）FROM order_info WHERE customer_id = 999;</pre><p>结果：</p><pre class="oac_no_warn" dir="ltr">COUNT（*）---------- 0选择1行。
</pre><p>在视图中插入行：</p><pre class="oac_no_warn" dir="ltr">INSERT INTO order_info VALUES（999，'Smith'，'John'，2500，TO_DATE（'13 -MAR-2001'，'DD-MON-YYYY'），0）;</pre><p>结果：</p><pre class="oac_no_warn" dir="ltr">已创建1行。
</pre><p>查询以显示已在视图中插入行：</p><pre class="oac_no_warn" dir="ltr">SELECT COUNT（*）FROM order_info WHERE customer_id = 999;</pre><p>结果：</p><pre class="oac_no_warn" dir="ltr">COUNT（*）----------选择了1行。
</pre><p>查询以显示已在<code class="codeph">customers</code>表中插入行：</p><pre class="oac_no_warn" dir="ltr">SELECT COUNT（*）FROM customers WHERE customer_id = 999;</pre><p>结果：</p><pre class="oac_no_warn" dir="ltr">COUNT（*）----------选择了1行。
</pre><p>查询以显示已在<code class="codeph">orders</code>表中插入行：</p><pre class="oac_no_warn" dir="ltr">SELECT COUNT（*）FROM orders WHERE customer_id = 999;</pre><p>结果：</p><pre class="oac_no_warn" dir="ltr">COUNT（*）----------选择了1行。</pre></div>
                     <!-- class="example" -->
                     <div class="example" id="GUID-9F06D45C-7C60-434E-A597-114A0C445671__CIHFBGDC">
                        <p class="titleinexample">示例9-3嵌套表视图上的触发器的INSTEAD OF</p>
                        <p>在此示例中，视图<code class="codeph">dept_view</code>包含由<code class="codeph">CAST</code>函数创建的嵌套员工<code class="codeph">emplist</code>表（在<a href="../sqlrf/CAST.html#SQLRF00613" target="_blank"><span class="italic">Oracle数据库SQL语言参考中</span></a>描述）。要修改<code class="codeph">emplist</code>列，该示例将在列上创建<code class="codeph">INSTEAD</code> <code class="codeph">OF</code>触发器。
                        </p><pre class="pre codeblock"><code>- 创建嵌套表元素的类型：CREATE OR REPLACE TYPE nte AUTHID DEFINER IS OBJECT（emp_id NUMBER（6），lastname VARCHAR2（25），job VARCHAR2（10），sal NUMBER（8,2））; /  - 嵌套表的创建类型：CREATE OR REPLACE TYPE emp_list_ IS TABLE of nte; /  - 创建视图：创建或替换视图<span class="bold">dept_view</span> AS SELECT d.department_id，d.department_name，CAST（MULTISET（SELECT e.employee_id，e.last_name，e.job_id，e.salary FROM employees e WHERE e.department_id = d .department_id）AS emp_list_） <span class="bold">emplist</span> FROM departments d; - 创建触发器：创建或替换TRIGGER dept_emplist_tr <span class="bold">INSTEAD OF INSERT ON NESTED TABLE emplist of dept_view</span> <span class="bold">REFERENCING NEW AS Employee</span> <span class="bold">PARENT AS Department</span> for EACH ROW BEGIN  - 在嵌套表上插入转换为插入基表：INSERT INTO employees（employee_id，last_name ，email，hire_date，job_id，salary，department_id）VALUES（：Employee.emp_id， -  employee_id：Employee.lastname， -  last_name：Employee.lastname ||'@ example.com'， -  email SYSDATE， -  hire_date ：Employee.job， -  job_id：Employee.sal， -  salary：Department.department_id  -  department_id）;结束; /</code></pre><p>在将行插入嵌套表之前查询视图：</p><pre class="oac_no_warn" dir="ltr">SELECT emplist FROM dept_view WHERE department_id = 10;</pre><p>结果：</p><pre class="oac_no_warn" dir="ltr">EMPLIST（EMP_ID，LASTNAME，JOB，SAL）---------------------------------------- ------ EMP_LIST_（NTE（200，'Whalen'，'AD_ASST'，4200））选择1行。
</pre><p>在将行插入嵌套表之前查询表：</p><pre class="oac_no_warn" dir="ltr">SELECT employee_id，last_name，job_id，salary FROM employees WHERE department_id = 10;</pre><p>结果：</p><pre class="oac_no_warn" dir="ltr">EMPLOYEE_ID LAST_NAME JOB_ID SALARY ----------- ------------------------- ---------- ----------选择200 Whalen AD_ASST 4200 1行。
</pre><p>在嵌套表中插入一行：</p><pre class="oac_no_warn" dir="ltr">INSERT INTO TABLE（SELECT d.emplist FROM dept_view d WHERE department_id = 10）VALUES（1001，'Glenn'，'AC_MGR'，10000）;</pre><p>将行插入嵌套表后的查询视图：</p><pre class="oac_no_warn" dir="ltr">SELECT emplist FROM dept_view WHERE department_id = 10;</pre><p>结果（格式化为适合页面）：</p><pre class="oac_no_warn" dir="ltr">EMPLIST（EMP_ID，LASTNAME，JOB，SAL）---------------------------------------- ---------------------------------------- EMP_LIST_（NTE（200，'Whalen'， 'AD_ASST'，4200），NTE（1001，'Glenn'，'AC_MGR'，10000））选择1行。
</pre><p>将行插入嵌套表后的查询表：</p><pre class="oac_no_warn" dir="ltr">SELECT employee_id，last_name，job_id，salary FROM employees WHERE department_id = 10;</pre><p>结果：</p><pre class="oac_no_warn" dir="ltr">EMPLOYEE_ID LAST_NAME JOB_ID SALARY ----------- ------------------------- ---------- ---------- 200 Whalen AD_ASST 4200 1001 Glenn AC_MGR 10000选择2行。</pre></div>
                     <!-- class="example" -->
                  </div>
               </div><a id="LNPLS652"></a><a id="LNPLS2005"></a><div class="props_rev_3"><a id="GUID-8A0DA171-BE6A-4798-A1A4-677B88EA16A0" name="GUID-8A0DA171-BE6A-4798-A1A4-677B88EA16A0"></a><h4 id="LNPLS-GUID-8A0DA171-BE6A-4798-A1A4-677B88EA16A0" class="sect4"><span class="enumeration_section">9.3.3</span>复合DML触发器</h4>
                  <div>
                     <p>在表或编辑视图上创建的复合DML触发器可以在多个时间点触发。每个时间点部分都有自己的可执行部分和可选的异常处理部分，但所有这些部分都可以访问常见的PL / SQL状态。公共状态在触发语句开始时建立，并在触发语句完成时被销毁，即使触发语句导致错误也是如此。</p>
                     <p>在非专用视图上创建的复合DML触发器实际上并不复合，因为它只有一个定时点部分。</p>
                     <p>复合触发器可以是有条件的，但不是自主的。</p>
                     <p>复合触发器的两个常见用途是：</p>
                     <ul style="list-style-type:disc">
                        <li>
                           <p>累积目标为第二个表的行，以便您可以定期批量插入它们</p>
                        </li>
                        <li>
                           <p>避免变异表错误（ORA-04091）</p>
                        </li>
                     </ul>
                     <div class="section">
                        <p class="subhead3" id="GUID-8A0DA171-BE6A-4798-A1A4-677B88EA16A0__GUID-F07BA0D5-8878-4B69-BFCA-4A2EF2F68642">话题</p>
                     </div>
                     <!-- class="section" -->
                     <div class="section">
                        <ul style="list-style-type:disc">
                           <li>
                              <p><a href="plsql-triggers.html#GUID-B42FDBCD-55F4-47E9-90BB-12B71D63D225">复合DML触发器结构</a></p>
                           </li>
                           <li>
                              <p><a href="plsql-triggers.html#GUID-67299530-50F0-4D99-B212-956A7E679CDC">复合DML触发器限制</a></p>
                           </li>
                           <li>
                              <p><a href="plsql-triggers.html#GUID-5F39A9BC-D1E3-4D71-A4E1-A2674E5132A0">复合DML触发器的性能优势</a></p>
                           </li>
                           <li>
                              <p><a href="plsql-triggers.html#GUID-B5E654D9-5875-40EC-AE24-E3A8CB37C9C5">使用具有批量插入的复合DML触发器</a></p>
                           </li>
                           <li>
                              <p><a href="plsql-triggers.html#GUID-E1150933-9B5F-4AA3-9F49-C222A1618BE5">使用复合DML触发器来避免变异表错误</a></p>
                           </li>
                        </ul>
                     </div>
                     <!-- class="section" -->
                  </div><a id="LNPLS655"></a><a id="LNPLS737"></a><div class="props_rev_3"><a id="GUID-B42FDBCD-55F4-47E9-90BB-12B71D63D225" name="GUID-B42FDBCD-55F4-47E9-90BB-12B71D63D225"></a><h5 id="LNPLS-GUID-B42FDBCD-55F4-47E9-90BB-12B71D63D225" class="sect5"><span class="enumeration_section">9.3.3.1</span>复合DML触发器结构</h5>
                     <div>
                        <p>复合触发器的可选声明部分声明其所有时序点部分都可以使用的变量和子程序。当触发器触发时，声明部分在任何定时点部分运行之前运行。变量和子程序在触发语句的持续时间内存在。</p>
                        <p>在非专用视图上创建的复合DML触发器实际上并不复合，因为它只有一个定时点部分。在非编辑视图上创建最简单的复合DML触发器的语法是：</p><pre class="oac_no_warn" dir="ltr">CREATE <span class="italic">触发器</span> FOR <span class="italic">dml_event_clause</span> ON <span class="italic">视图</span> COMPOUND TRIGGER INSTEAD OF EACH ROW是BEGIN <span class="italic">语句</span> ;结束每行;</pre><p>在表或版本视图上创建的复合DML触发器在<a href="plsql-triggers.html#GUID-B42FDBCD-55F4-47E9-90BB-12B71D63D225__CIHJGDGE" title="此表显示与表关联的复合触发器的可能触发点和相应的可选部分。">表9-2</a>中至少有一个定时点部分。如果触发器具有多个定时点部分，则它们可以按任何顺序排列，但不能重复定时点部分。如果没有定时点部分，那么在其定时点没有任何反应。
                        </p>
                        <div class="tblformal" id="GUID-B42FDBCD-55F4-47E9-90BB-12B71D63D225__CIHJGDGE">
                           <p class="titleintable">表9-2复合触发时序点部分</p>
                           <table cellpadding="4" cellspacing="0" class="Formal" title="复合触发定时点部分" width="100%" border="1" summary="This table show the possible trigger points and corresponding optional sections for a compound trigger associated with a table." frame="hsides" rules="rows">
                              <thead>
                                 <tr align="left" valign="top">
                                    <th align="left" valign="bottom" width="58%" id="d67636e1803">时间点</th>
                                    <th align="left" valign="bottom" width="42%" id="d67636e1806">部分</th>
                                 </tr>
                              </thead>
                              <tbody>
                                 <tr align="left" valign="top">
                                    <td align="left" valign="top" width="58%" id="d67636e1811" headers="d67636e1803 ">
                                       <p>在触发语句运行之前</p>
                                    </td>
                                    <td align="left" valign="top" width="42%" headers="d67636e1811 d67636e1806 ">
                                       <p><code class="codeph">BEFORE</code> <code class="codeph">STATEMENT</code> <code class="codeph">BEFORE</code></p>
                                    </td>
                                 </tr>
                                 <tr align="left" valign="top">
                                    <td align="left" valign="top" width="58%" id="d67636e1822" headers="d67636e1803 ">
                                       <p>触发语句运行后</p>
                                    </td>
                                    <td align="left" valign="top" width="42%" headers="d67636e1822 d67636e1806 ">
                                       <p><code class="codeph">AFTER</code> <code class="codeph">STATEMENT</code></p>
                                    </td>
                                 </tr>
                                 <tr align="left" valign="top">
                                    <td align="left" valign="top" width="58%" id="d67636e1833" headers="d67636e1803 ">
                                       <p>在触发语句影响的每一行之前</p>
                                    </td>
                                    <td align="left" valign="top" width="42%" headers="d67636e1833 d67636e1806 ">
                                       <p><code class="codeph">BEFORE</code> <code class="codeph">EACH</code> <code class="codeph">ROW</code></p>
                                    </td>
                                 </tr>
                                 <tr align="left" valign="top">
                                    <td align="left" valign="top" width="58%" id="d67636e1847" headers="d67636e1803 ">
                                       <p>在触发语句影响的每一行之后</p>
                                    </td>
                                    <td align="left" valign="top" width="42%" headers="d67636e1847 d67636e1806 ">
                                       <p><code class="codeph">AFTER</code> <code class="codeph">EACH</code> <code class="codeph">ROW</code></p>
                                    </td>
                                 </tr>
                              </tbody>
                           </table>
                        </div>
                        <!-- class="inftblhruleinformal" -->
                        <div class="infoboxnotealso" id="GUID-B42FDBCD-55F4-47E9-90BB-12B71D63D225__GUID-56588DAC-2F87-43C8-A3FC-7920B548534E">
                           <p class="notep1">也可以看看：</p>
                           <p>有关复合触发器语法的更多信息，请参阅<span class="q">“ <a href="CREATE-TRIGGER-statement.html#GUID-AF9E33F1-64D1-4382-A6A4-EC33C36F237B">CREATE TRIGGER语句</a> ”</span></p>
                        </div>
                        <p>复合DML触发器没有初始化部分，但<code class="codeph">BEFORE</code> <code class="codeph">STATEMENT</code>部分在任何其他时间点部分之前运行，可以进行任何必要的初始化。
                        </p>
                        <p>如果复合DML触发器既没有<code class="codeph">BEFORE</code> <code class="codeph">STATEMENT</code>部分也没有<code class="codeph">AFTER</code> <code class="codeph">STATEMENT</code>部分，并且其触发语句不影响任何行，则触发器永远不会触发。
                        </p>
                     </div>
                  </div><a id="LNPLS740"></a><div class="props_rev_3"><a id="GUID-67299530-50F0-4D99-B212-956A7E679CDC" name="GUID-67299530-50F0-4D99-B212-956A7E679CDC"></a><h5 id="LNPLS-GUID-67299530-50F0-4D99-B212-956A7E679CDC" class="sect5"><span class="enumeration_section">9.3.3.2</span>复合DML触发器限制</h5>
                     <div>
                        <p>除了<span class="q">“ <a href="plsql-triggers.html#GUID-5B3A43E2-B9E1-4015-9A6C-0BE696853F3F">Trigger Restrictions</a> ”之外</span> ，复合DML触发器还有以下限制：</p>
                        <ul style="list-style-type:disc">
                           <li>
                              <p><code class="codeph">OLD</code> ， <code class="codeph">NEW</code>和<code class="codeph">PARENT</code>不能出现在声明部分， <code class="codeph">BEFORE</code> <code class="codeph">STATEMENT</code>部分或<code class="codeph">AFTER</code> <code class="codeph">STATEMENT</code>部分中。
                              </p>
                           </li>
                           <li>
                              <p>只有<code class="codeph">BEFORE</code> <code class="codeph">EACH</code> <code class="codeph">ROW</code>部分才能更改<code class="codeph">NEW</code>的值。</p>
                           </li>
                           <li>
                              <p>定时点部分不能处理在另一个定时点部分引发的异常。</p>
                           </li>
                           <li>
                              <p>如果定时点部包括<code class="codeph">GOTO</code>语句，所述的目标<code class="codeph">GOTO</code>语句必须是在相同的定时点部分。
                              </p>
                           </li>
                        </ul>
                     </div>
                  </div><a id="LNPLS739"></a><div class="props_rev_3"><a id="GUID-5F39A9BC-D1E3-4D71-A4E1-A2674E5132A0" name="GUID-5F39A9BC-D1E3-4D71-A4E1-A2674E5132A0"></a><h5 id="LNPLS-GUID-5F39A9BC-D1E3-4D71-A4E1-A2674E5132A0" class="sect5"><span class="enumeration_section">9.3.3.3</span>复合DML触发器的性能优势</h5>
                     <div>
                        <p>当触发语句影响许多行时，复合DML触发器具有性能优势。</p>
                        <p>例如，假设此语句触发具有<a href="plsql-triggers.html#GUID-B42FDBCD-55F4-47E9-90BB-12B71D63D225__CIHJGDGE" title="此表显示与表关联的复合触发器的可能触发点和相应的可选部分。">表9-2中</a>所有四个定时点部分的复合DML触发器：</p><pre class="oac_no_warn" dir="ltr">INSERT INTO目标SELECT c1，c2，c3 FROM Source WHERE Source.c1&gt; 0</pre><p>虽然触发器的<code class="codeph">BEFORE</code> <code class="codeph">EACH</code> <code class="codeph">ROW</code>和<code class="codeph">AFTER</code> <code class="codeph">EACH</code> <code class="codeph">ROW</code>部分为列<code class="codeph">c1</code>大于零的每行<code class="codeph">Source</code>运行，但<code class="codeph">BEFORE</code> <code class="codeph">STATEMENT</code>部分仅在<code class="codeph">INSERT</code>语句运行之前运行，而<code class="codeph">AFTER</code> <code class="codeph">STATEMENT</code>部分仅在<code class="codeph">INSERT</code>语句运行之后运行。
                        </p>
                        <p>复合DML触发器在使用批量SQL时具有更高的性能优势，如<span class="q">“ <a href="plsql-optimization-and-tuning.html#GUID-61D1B533-DBB9-4150-91F9-0A4C9428391E" title="批量SQL最大限度地减少了PL / SQL和SQL之间通信的性能开销。包含批量SQL的PL / SQL功能是FORALL语句和BULK COLLECT子句。为SQL语句中出现的PL / SQL变量赋值称为绑定。">批量SQL和批量绑定</a> ”中所述</span> 。
                        </p>
                     </div>
                  </div><a id="LNPLS742"></a><a id="LNPLS741"></a><div class="props_rev_3"><a id="GUID-B5E654D9-5875-40EC-AE24-E3A8CB37C9C5" name="GUID-B5E654D9-5875-40EC-AE24-E3A8CB37C9C5"></a><h5 id="LNPLS-GUID-B5E654D9-5875-40EC-AE24-E3A8CB37C9C5" class="sect5"><span class="enumeration_section">9.3.3.4</span>使用具有批量插入的复合DML触发器</h5>
                     <div>
                        <div class="section">
                           <p>复合DML触发器可用于累积发往第二个表的行，以便您可以定期批量插入它们。要从复合触发器获得性能优势，必须在<code class="codeph">FORALL</code>语句中指定<code class="codeph">BULK</code> <code class="codeph">COLLECT</code> <code class="codeph">INTO</code> （否则， <code class="codeph">FORALL</code>语句会多次执行单行DML操作）。有关在<code class="codeph">FORALL</code>语句中使用<code class="codeph">BULK</code> <code class="codeph">COLLECT</code>子句的更多信息，请参阅<span class="q">“一起<a href="plsql-optimization-and-tuning.html#GUID-D67D19A6-4717-4556-B027-15C3DED0519A" title="在FORALL语句中，DML语句可以具有RETURNING BULK COLLECT INTO子句。对于FORALL语句的每次迭代，DML语句将指定的值存储在指定的集合中，而不会覆盖先前的值，因为相同的DML语句将在FOR LOOP语句中执行。">使用FORALL语句和BULK COLLECT子句</a> ”</span> 。
                           </p>
                           <div class="infoboxnotealso" id="GUID-B5E654D9-5875-40EC-AE24-E3A8CB37C9C5__GUID-83C6996D-8250-46D5-82F5-BF498411E6C4">
                              <p class="notep1">也可以看看：</p>
                              <p><span class="q">“ <a href="plsql-optimization-and-tuning.html#GUID-6D4A1425-64DD-4723-8AAE-87B0A51A2854" title="FORALL语句是批量SQL的一个特性，它将批处理中的DML语句从PL / SQL发送到SQL，而不是一次发送一个。">FORALL声明</a> ”</span></p>
                           </div>
                           <p><span class="bold">场景：</span>您希望将每个更改记录到<code class="codeph">hr</code> 。 <code class="codeph">employees</code> 。新表中的<code class="codeph">salary</code> ， <code class="codeph">employee_salaries</code> 。单个<code class="codeph">UPDATE</code>语句更新表<code class="codeph">hr</code>许多行。 <code class="codeph">employees</code> ;因此，将行批量插入<code class="codeph">employee</code> 。 <code class="codeph">salaries</code>比单独插入工具更有效。
                           </p>
                           <p><span class="bold">解决方案：</span>在表<code class="codeph">hr</code>更新时定义复合触发器。 <code class="codeph">employees</code> ，如<a href="plsql-triggers.html#GUID-B5E654D9-5875-40EC-AE24-E3A8CB37C9C5__CIHGJFAB">例9-4所示</a> 。您不需要<code class="codeph">BEFORE</code> <code class="codeph">STATEMENT</code>部分来初始化<code class="codeph">idx</code>或<code class="codeph">salaries</code> ，因为它们是状态变量，每次触发时都会初始化（即使触发语句被中断并重新启动）。
                           </p>
                           <div class="infoboxnote" id="GUID-B5E654D9-5875-40EC-AE24-E3A8CB37C9C5__GUID-8BF7A17F-4435-405D-896A-EC513AEF0E30">
                              <p class="notep1">注意：</p>
                              <p>要运行<a href="plsql-triggers.html#GUID-B5E654D9-5875-40EC-AE24-E3A8CB37C9C5__CIHGJFAB">示例9-4</a> ，您必须对程序包<code class="codeph">DBMS_LOCK</code>具有<code class="codeph">EXECUTE</code>特权。</p>
                           </div>
                        </div>
                        <!-- class="section" -->
                        <div class="example" id="GUID-B5E654D9-5875-40EC-AE24-E3A8CB37C9C5__CIHGJFAB">
                           <p class="titleinexample">示例9-4复合触发日志更改为另一个表中的一个表</p><pre class="oac_no_warn" dir="ltr">CREATE TABLE employee_salaries（employee_id NUMBER NOT NULL，change_date DATE NOT NULL，工资NUMBER（8,2）NOT NULL，CONSTRAINT pk_employee_salaries PRIMARY KEY（employee_id，change_date），CONSTRAINT fk_employee_salaries FOREIGN KEY（employee_id）REFERENCES employees（employee_id）ON DELETE CASCADE） /创建或替换TRIGGER maintain_employee_salaries更新员工薪水COMPOUND TRIGGER  - 声明部分： - 选择小阈值以显示示例如何工作：阈值CONSTANT SIMPLE_INTEGER：= 7; TYPE salaries_t是一个employee_salaries表％ROWTYPE INDEX BY SIMPLE_INTEGER;薪水salaries_t; idx SIMPLE_INTEGER：= 0; PROCEDURE flush_array IS n CONSTANT SIMPLE_INTEGER：= salaries.count（）; BEGIN <span class="bold">FORALL j IN 1..n</span> <span class="bold">INSERT INTO employee_salaries VALUES工资（j）;</span> salaries.delete（）; idx：= 0; DBMS_OUTPUT.PUT_LINE（'Flushed'|| n ||'rows'）; END flush_array; - 每行之后部分：每行开始之后idx：= idx + 1;工资（idx）.employee_id：=：NEW.employee_id;工资（idx）.change_date：= SYSTIMESTAMP;工资（idx）.salary：=：NEW.salary; IF idx&gt; = threshhold THEN flush_array（）;万一;每行后结束; - 声明后部分：声明之后是开始的flush_array（）;结束后的声明; END maintain_employee_salaries; /</pre><p>将部门50中每位员工的工资提高10％：</p><pre class="oac_no_warn" dir="ltr">UPDATE员工SET薪水=薪水* 1.1 WHERE department_id = 50 /</pre><p>结果：</p><pre class="oac_no_warn" dir="ltr">刷新7行刷新7行刷新7行刷新7行刷新7行刷新7行刷新3行45行更新。
</pre><p>等两秒钟：</p><pre class="oac_no_warn" dir="ltr">BEGIN DBMS_LOCK.SLEEP（2）;结束; /</pre><p>将部门50中每位员工的工资提高5％：</p><pre class="oac_no_warn" dir="ltr">UPDATE员工SET薪水=薪水* 1.05 WHERE department_id = 50 /</pre><p>结果：</p><pre class="oac_no_warn" dir="ltr">刷新7行刷新7行刷新7行刷新7行刷新7行刷新7行刷新3行45行更新。
</pre><p>请参阅employee_salaries表中反映的<code class="codeph">employee_salaries</code>表更改：</p><pre class="oac_no_warn" dir="ltr">SELECT employee_id，count（*）c FROM employee_salaries GROUP BY employee_id /</pre><p>结果：</p><pre class="oac_no_warn" dir="ltr">EMPLOYEE_ID C ----------- ---------- 120 2 121 2 122 2 123 2 124 2 125 2 ...选择199 2 45行。</pre></div>
                        <!-- class="example" -->
                     </div>
                  </div><a id="LNPLS744"></a><a id="LNPLS743"></a><div class="props_rev_3"><a id="GUID-E1150933-9B5F-4AA3-9F49-C222A1618BE5" name="GUID-E1150933-9B5F-4AA3-9F49-C222A1618BE5"></a><h5 id="LNPLS-GUID-E1150933-9B5F-4AA3-9F49-C222A1618BE5" class="sect5"><span class="enumeration_section">9.3.3.5</span>使用复合DML触发器避免变异表错误</h5>
                     <div>
                        <div class="section">
                           <p>复合DML触发器可用于避免<span class="q">“ <a href="plsql-triggers.html#GUID-73B70893-9E45-4C08-B327-13ECBE4BE920">变异表限制</a> ”中</span>解释的变异表错误（ORA-04091）。
                           </p>
                           <p><span class="bold">场景：</span>业务规则规定员工的工资增长不得超过员工部门平均工资的10％。必须通过触发器强制执行此规则。
                           </p>
                           <p><span class="bold">解决方案：</span>在表<code class="codeph">hr</code>更新时定义复合触发器。 <code class="codeph">employees</code> ，如<a href="plsql-triggers.html#GUID-E1150933-9B5F-4AA3-9F49-C222A1618BE5__CHDFGDAH">例9-5所示</a> 。每次触发器触发时都会初始化状态变量（即使触发语句被中断并重新启动）。
                           </p>
                        </div>
                        <!-- class="section" -->
                        <div class="example" id="GUID-E1150933-9B5F-4AA3-9F49-C222A1618BE5__CHDFGDAH">
                           <p class="titleinexample">例9-5复合触发器避免了变异表错误</p><pre class="oac_no_warn" dir="ltr">创建或替换TRIGGER Check_Employee_Salary_Raise更新员工薪资复合触发器Ten_Percent常数：= 0.1; TYPE Salaries_t是员工表。薪酬％TYPE; Avg_Salaries Salaries_t; TYPE Department_IDs_t是员工表。部门编号％TYPE; Department_IDs Department_IDs_t; - 声明集合类型和变量：TYPE Department_Salaries_t是员工表。工资％TYPE INDEX BY VARCHAR2（80）; Department_Avg_Salaries Department_Salaries_t;在声明之前是开始选择AVG（e。工资），NVL（e。Department_ID，-1）BULK收集到Avg_Salaries，Department_IDs FROM Employees e GROUP BY e。部门编号; FOR j IN 1 ..Department_IDs。COUNT（）LOOP Department_Avg_Salaries（Department_IDs（j））：= Avg_Salaries（j）;结束循环;在声明之前结束;每行开始之后如果：NEW.Salary  - ：Old。薪水&gt; Ten_Percent * Department_Avg_Salaries（：NEW.Department_ID）那么Raise_Application_Error（-20000，'升得太大'）;万一;每行后结束; END Check_Employee_Salary_Raise;</pre></div>
                        <!-- class="example" -->
                     </div>
                  </div>
               </div><a id="LNPLS660"></a><a id="LNPLS661"></a><a id="LNPLS770"></a><div class="props_rev_3"><a id="GUID-AD8188E5-546E-46EB-A000-7EB9D17C3D0C" name="GUID-AD8188E5-546E-46EB-A000-7EB9D17C3D0C"></a><h4 id="LNPLS-GUID-AD8188E5-546E-46EB-A000-7EB9D17C3D0C" class="sect4"><span class="enumeration_section">9.3.4</span>确保参照完整性的触发因素</h4>
                  <div>
                     <p>您可以使用触发器和约束来维护父表和子表之间的引用完整性，如<a href="plsql-triggers.html#GUID-AD8188E5-546E-46EB-A000-7EB9D17C3D0C__CIHIDBHH" title="此表显示维护父表和子表之间的引用完整性所需的约束和触发器的类型。">表9-3</a>所示。（有关约束的更多信息，请参阅<a href="../sqlrf/constraint.html#SQLRF52180" target="_blank"><span class="italic">Oracle数据库SQL语言参考</span></a> 。）
                     </p>
                     <div class="tblformal" id="GUID-AD8188E5-546E-46EB-A000-7EB9D17C3D0C__CIHIDBHH">
                        <p class="titleintable">表9-3确保参照完整性的约束和触发因素</p>
                        <table cellpadding="4" cellspacing="0" class="Formal" title="确保参照完整性的约束和触发因素" width="100%" border="1" summary="This table shows the kinds of constraints and triggers needed to maintain referential integrity between a parent and child table." frame="hsides" rules="rows">
                           <thead>
                              <tr align="left" valign="top">
                                 <th align="left" valign="bottom" width="10%" id="d67636e2652">表</th>
                                 <th align="left" valign="bottom" width="45%" id="d67636e2655">要在表上声明的约束</th>
                                 <th align="left" valign="bottom" width="45%" id="d67636e2658">触发器在表上创建</th>
                              </tr>
                           </thead>
                           <tbody>
                              <tr align="left" valign="top">
                                 <td align="left" valign="top" width="10%" id="d67636e2663" headers="d67636e2652 ">
                                    <p>亲</p>
                                 </td>
                                 <td align="left" valign="top" width="45%" headers="d67636e2663 d67636e2655 ">
                                    <p><code class="codeph">PRIMARY</code> <code class="codeph">KEY</code>或<code class="codeph">UNIQUE</code></p>
                                 </td>
                                 <td align="left" valign="top" width="45%" headers="d67636e2663 d67636e2658 ">
                                    <p>一个或多个触发器确保在更新或删除<code class="codeph">PRIMARY</code> <code class="codeph">KEY</code>或<code class="codeph">UNIQUE</code>值时，在相应的<code class="codeph">FOREIGN</code> <code class="codeph">KEY</code>值上发生所需的操作（ <code class="codeph">RESTRICT</code> ， <code class="codeph">CASCADE</code>或<code class="codeph">SET</code> <code class="codeph">NULL</code> ）。
                                    </p>
                                    <p>插入父表时不需要任何操作，因为不存在依赖的外键。</p>
                                 </td>
                              </tr>
                              <tr align="left" valign="top">
                                 <td align="left" valign="top" width="10%" id="d67636e2710" headers="d67636e2652 ">
                                    <p>儿童</p>
                                 </td>
                                 <td align="left" valign="top" width="45%" headers="d67636e2710 d67636e2655 ">
                                    <p><code class="codeph">FOREIGN</code> <code class="codeph">KEY</code> ，如果父和子在同一个数据库中。（数据库不支持分布式数据库的不同节点上的表之间的声明性引用约束。）
                                    </p>
                                    <p>禁用此外键约束以防止删除相应的<code class="codeph">PRIMARY</code> <code class="codeph">KEY</code>或<code class="codeph">UNIQUE</code>约束（使用<code class="codeph">CASCADE</code>选项显式除外）。
                                    </p>
                                 </td>
                                 <td align="left" valign="top" width="45%" headers="d67636e2710 d67636e2658 ">
                                    <p>一个触发器，确保在<code class="codeph">FOREIGN</code> <code class="codeph">KEY</code>插入或更新的值对应于父表中的<code class="codeph">PRIMARY</code> <code class="codeph">KEY</code>或<code class="codeph">UNIQUE</code>值。
                                    </p>
                                 </td>
                              </tr>
                           </tbody>
                        </table>
                     </div>
                     <!-- class="inftblhruleinformal" -->
                     <div class="section">
                        <p class="subhead3" id="GUID-AD8188E5-546E-46EB-A000-7EB9D17C3D0C__GUID-80C9F800-E0FC-4EC9-BFFD-CF5303398037">话题</p>
                     </div>
                     <!-- class="section" -->
                     <div class="section">
                        <ul style="list-style-type:disc">
                           <li>
                              <p><a href="plsql-triggers.html#GUID-2DC16B21-35B1-4D09-BD4E-02797AA278EA">子表的外键触发器</a></p>
                           </li>
                           <li>
                              <p><a href="plsql-triggers.html#GUID-DB24A169-3CB1-427E-AA2B-646B878FA20C">父表的UPDATE和DELETE RESTRICT触发器</a></p>
                           </li>
                           <li>
                              <p><a href="plsql-triggers.html#GUID-58AD982C-22E6-4A62-A2CE-643BE8C4E821">父表的UPDATE和DELETE SET NULL触发器</a></p>
                           </li>
                           <li>
                              <p><a href="plsql-triggers.html#GUID-2B9DF77A-171D-472B-A8F0-FF9730261D07">删除父表的CASCADE触发器</a></p>
                           </li>
                           <li>
                              <p><a href="plsql-triggers.html#GUID-193F9DBB-80B5-49FC-83D2-2FB533880833">父表的UPDATE CASCADE触发器</a></p>
                           </li>
                           <li>
                              <p><a href="plsql-triggers.html#GUID-BF2DDD06-E6B4-4EB5-945F-89FFA8468D6F">复杂约束检查的触发器</a></p>
                           </li>
                           <li>
                              <p><a href="plsql-triggers.html#GUID-9E6E59EF-F402-4B11-A4FF-268D9C0521EB">复杂安全授权的触发器</a></p>
                           </li>
                           <li>
                              <p><a href="plsql-triggers.html#GUID-6DF46DC3-1311-4A93-B509-16B396901E97">透明事件记录的触发器</a></p>
                           </li>
                           <li>
                              <p><a href="plsql-triggers.html#GUID-BD042B88-E2E7-4A7D-8FA2-8D0185F6455F">用于派生列值的触发器</a></p>
                           </li>
                           <li>
                              <p><a href="plsql-triggers.html#GUID-4F93F21E-BA7F-4378-87E6-46A8E4C03287">用于构建复杂可更新视图的触发器</a></p>
                           </li>
                           <li>
                              <p><a href="plsql-triggers.html#GUID-86F46BD4-9225-41D0-AAF7-DA467F8412A9">用于细粒度访问控制的触发器</a></p>
                           </li>
                        </ul>
                        <div class="infoboxnote" id="GUID-AD8188E5-546E-46EB-A000-7EB9D17C3D0C__GUID-F376FE1B-E967-4B16-8DC3-EFCF0595FD6D">
                           <p class="notep1">注意：</p>
                           <p>以下主题中的示例使用这些表，它们共享<code class="codeph">Deptno</code>列：</p><pre class="oac_no_warn" dir="ltr">CREATE TABLE emp（Empno NUMBER NOT NULL，Ename VARCHAR2（10），Job VARCHAR2（9），Mgr NUMBER（4），Hiredate DATE，Sal NUMBER（7,2），Comm NUMBER（7,2）， <span class="bold">Deptno NUMBER（2 ）NOT NULL</span> ）; CREATE TABLE dept（ <span class="bold">Deptno NUMBER（2）NOT NULL</span> ，Dname VARCHAR2（14），Loc VARCHAR2（13），Mgr_no NUMBER，Dept_type NUMBER）;</pre><p>几个触发器包括锁定行的语句（ <code class="codeph">SELECT</code> <code class="codeph">FOR</code> <code class="codeph">UPDATE</code> ）。在处理行时，此操作对于保持并发性是必需的。
                           </p>
                           <p>这些示例并不完全按照书面形式使用。它们用于帮助您设计自己的触发器。</p>
                        </div>
                     </div>
                     <!-- class="section" -->
                  </div><a id="LNPLS772"></a><a id="LNPLS771"></a><div class="props_rev_3"><a id="GUID-2DC16B21-35B1-4D09-BD4E-02797AA278EA" name="GUID-2DC16B21-35B1-4D09-BD4E-02797AA278EA"></a><h5 id="LNPLS-GUID-2DC16B21-35B1-4D09-BD4E-02797AA278EA" class="sect5"><span class="enumeration_section">9.3.4.1</span>子表的外键触发器</h5>
                     <div>
                        <p><a href="plsql-triggers.html#GUID-2DC16B21-35B1-4D09-BD4E-02797AA278EA__BCFGAHIB">例9-6中</a>的触发器确保在<code class="codeph">INSERT</code>或<code class="codeph">UPDATE</code>语句影响外键值之前，父键中存在相应的值。异常ORA-04091（变异表错误）允许触发器<code class="codeph">emp_dept_check</code>与<code class="codeph">UPDATE_SET_DEFAULT</code>和<code class="codeph">UPDATE_CASCADE</code>触发器一起使用。如果单独使用触发器<code class="codeph">emp_dept_check</code>则不需要此异常。
                        </p>
                        <div class="example" id="GUID-2DC16B21-35B1-4D09-BD4E-02797AA278EA__BCFGAHIB">
                           <p class="titleinexample">例9-6子表的外键触发器</p><pre class="oac_no_warn" dir="ltr">创建或替换TRIGGER emp_dept_check在插入或更新Deptno ON之前每次行（NEW.Deptno IS NOT NULL） - 在插入行或在emp表中更新DEPTNO之前， - 触发此触发器以验证新的外键值（DEPTNO） - 存在于dept表中。DECLARE Dummy INTEGER; - 用于游标提取Invalid_department EXCEPTION; Valid_department EXCEPTION; Mutating_table EXCEPTION; PRAGMA EXCEPTION_INIT（Invalid_department，-4093）; PRAGMA EXCEPTION_INIT（Valid_department，-4092）; PRAGMA EXCEPTION_INIT（Mutating_table，-4091）; - 用于验证父键值的游标存在。- 如果存在，则锁定父键的行，以便在此事务被提交或回滚之前由另一个事务删除。CURSOR Dummy_cursor（Dn NUMBER）是选择Deptno FROM dept WHERE Deptno = Dn FOR更新Deptno; BEGIN OPEN Dummy_cursor（：NEW.Deptno）; FETCH Dummy_cursor INTO Dummy; - 验证父密钥。- 如果未找到，请引发用户指定的错误代码和消息。- 如果找到，请在允许触发语句完成之前关闭游标：IF Dummy_cursor％NOTFOUND THEN RAISE Invalid_department; ELSE RAISE Valid_department;万一;关闭Dummy_cursor; Invalid_department，然后关闭Dummy_cursor; EXCEPTION; Raise_application_error（-20000，'无效部门'||'数字'|| TO_CHAR（：NEW.deptno））;当Valid_department那么关闭Dummy_cursor;当Mutating_table那么空;结束; /</pre></div>
                        <!-- class="example" -->
                     </div>
                  </div><a id="LNPLS774"></a><a id="LNPLS773"></a><div class="props_rev_3"><a id="GUID-DB24A169-3CB1-427E-AA2B-646B878FA20C" name="GUID-DB24A169-3CB1-427E-AA2B-646B878FA20C"></a><h5 id="LNPLS-GUID-DB24A169-3CB1-427E-AA2B-646B878FA20C" class="sect5"><span class="enumeration_section">9.3.4.2</span>父表的UPDATE和DELETE RESTRICT触发器</h5>
                     <div>
                        <p><a href="plsql-triggers.html#GUID-DB24A169-3CB1-427E-AA2B-646B878FA20C__BCFCCBAF">例9-7中</a>的触发器对<code class="codeph">dept</code>表的主键强制执行<code class="codeph">UPDATE</code>和<code class="codeph">DELETE</code> <code class="codeph">RESTRICT</code>引用操作。
                        </p>
                        <div class="infoboxnote" id="GUID-DB24A169-3CB1-427E-AA2B-646B878FA20C__GUID-C4C67C70-4C57-4A13-B98E-3ADAC0B04ECB">
                           <p class="notep1">警告：</p>
                           <p><a href="plsql-triggers.html#GUID-DB24A169-3CB1-427E-AA2B-646B878FA20C__BCFCCBAF">例9-7</a>中的触发器不适用于自引用表（包含主/唯一键和外键的表）。此外，此触发器不允许触发器循环（例如，当A触发B时，触发A）。
                           </p>
                        </div>
                        <div class="example" id="GUID-DB24A169-3CB1-427E-AA2B-646B878FA20C__BCFCCBAF">
                           <p class="titleinexample">例9-7父表的UPDATE和DELETE RESTRICT触发器</p><pre class="oac_no_warn" dir="ltr">在每个行的部门之间删除或更新之前创建或替换TRIGGER dept_restrict  - 在从dept删除行或更新dept的主键（DEPTNO）之前， - 检查emp中的从属外键值; - 如果发现任何问题，请回滚。DECLARE Dummy INTEGER; - 用于游标提取employees_present EXCEPTION; employees_not_present EXCEPTION; PRAGMA EXCEPTION_INIT（employees_present，-4094）; PRAGMA EXCEPTION_INIT（employees_not_present，-4095）; - 用于检查相关外键值的游标。CURSOR Dummy_cursor（Dn NUMBER）IS SELECT Deptno FROM emp WHERE Deptno = Dn; BEGIN OPEN Dummy_cursor（：OLD.Deptno）; FETCH Dummy_cursor INTO Dummy; - 如果找到依赖外键，则引发用户指定的错误代码和消息。如果未找到，请在允许触发语句完成之前关闭游标。如果Dummy_cursor％FOUND那么提升employees_present; - 依赖行存在ELSE RAISE employees_not_present; - 没有依赖行END IF;关闭Dummy_cursor; employees_present THEN CLOSE Dummy_cursor之外的例外情况; Raise_application_error（-20001，'员工出现在'||'部门'|| TO_CHAR（：OLD.DEPTNO））;雇员_not_present然后关闭Dummy_cursor;结束;</pre></div>
                        <!-- class="example" -->
                     </div>
                  </div><a id="LNPLS776"></a><a id="LNPLS775"></a><div class="props_rev_3"><a id="GUID-58AD982C-22E6-4A62-A2CE-643BE8C4E821" name="GUID-58AD982C-22E6-4A62-A2CE-643BE8C4E821"></a><h5 id="LNPLS-GUID-58AD982C-22E6-4A62-A2CE-643BE8C4E821" class="sect5"><span class="enumeration_section">9.3.4.3</span>父表的UPDATE和DELETE SET NULL触发器</h5>
                     <div>
                        <p><a href="plsql-triggers.html#GUID-58AD982C-22E6-4A62-A2CE-643BE8C4E821__BCFBGFDJ">例9-8中</a>的触发器对<code class="codeph">dept</code>表的主键强制执行<code class="codeph">UPDATE</code>和<code class="codeph">DELETE</code> <code class="codeph">SET</code> <code class="codeph">NULL</code>引用操作。
                        </p>
                        <div class="example" id="GUID-58AD982C-22E6-4A62-A2CE-643BE8C4E821__BCFBGFDJ">
                           <p class="titleinexample">例9-8父表的UPDATE和DELETE SET NULL触发器</p><pre class="oac_no_warn" dir="ltr">创建或替换TRIGGER dept_set_null删除或更新Deptno ON dept for EACH ROW  - 在从dept删除行或更新dept的主键（DEPTNO）之前， - 将emp中所有相应的从属外键值设置为NULL：BEGIN如果更新和：OLD.Deptno！=：NEW.Deptno或DELETING THEN UPDATE emp SET emp。Deptno = NULL WHERE emp。Deptno =：OLD.Deptno;万一;结束; /</pre></div>
                        <!-- class="example" -->
                     </div>
                  </div><a id="LNPLS778"></a><a id="LNPLS777"></a><div class="props_rev_3"><a id="GUID-2B9DF77A-171D-472B-A8F0-FF9730261D07" name="GUID-2B9DF77A-171D-472B-A8F0-FF9730261D07"></a><h5 id="LNPLS-GUID-2B9DF77A-171D-472B-A8F0-FF9730261D07" class="sect5"><span class="enumeration_section">9.3.4.4</span>删除父表的CASCADE触发器</h5>
                     <div>
                        <p><a href="plsql-triggers.html#GUID-2B9DF77A-171D-472B-A8F0-FF9730261D07__BCFHHHBD">例9-9中</a>的触发器对<code class="codeph">dept</code>表的主键强制执行<code class="codeph">DELETE</code> <code class="codeph">CASCADE</code>引用操作。
                        </p>
                        <div class="infoboxnote" id="GUID-2B9DF77A-171D-472B-A8F0-FF9730261D07__GUID-2824F160-25B9-430B-809B-6D2DFBC9F55E">
                           <p class="notep1">注意：</p>
                           <p>通常， <code class="codeph">DELETE</code> <code class="codeph">CASCADE</code>的代码与<code class="codeph">UPDATE</code> <code class="codeph">SET</code> <code class="codeph">NULL</code>或<code class="codeph">UPDATE</code> <code class="codeph">SET</code> <code class="codeph">DEFAULT</code>的代码组合在一起，以考虑更新和删除。
                           </p>
                        </div>
                        <div class="example" id="GUID-2B9DF77A-171D-472B-A8F0-FF9730261D07__BCFHHHBD">
                           <p class="titleinexample">示例9-9删除父表的CASCADE触发器</p><pre class="oac_no_warn" dir="ltr">创建或替换TRIGGER dept_del_cascade在每个行的部门删除之后 - 在从dept删除行之前， - 删除emp表中DEPTNO相同的所有行 -  DEPTNO从dept表中删除：BEGIN DELETE FROM emp WHERE emp。Deptno =：OLD.Deptno;结束; /</pre></div>
                        <!-- class="example" -->
                     </div>
                  </div><a id="LNPLS780"></a><a id="LNPLS779"></a><div class="props_rev_3"><a id="GUID-193F9DBB-80B5-49FC-83D2-2FB533880833" name="GUID-193F9DBB-80B5-49FC-83D2-2FB533880833"></a><h5 id="LNPLS-GUID-193F9DBB-80B5-49FC-83D2-2FB533880833" class="sect5"><span class="enumeration_section">9.3.4.5</span>父表的UPDATE CASCADE触发器</h5>
                     <div>
                        <p><a href="plsql-triggers.html#GUID-193F9DBB-80B5-49FC-83D2-2FB533880833__BCFDBJDA">示例9-10中</a>的触发器确保如果在<code class="codeph">dept</code>表中更新了部门号，则此更改将传播到<code class="codeph">emp</code>表中的从属外键。
                        </p>
                        <div class="infoboxnote" id="GUID-193F9DBB-80B5-49FC-83D2-2FB533880833__GUID-83C55361-3225-4780-A806-158CBEE33CCC">
                           <p class="notep1">注意：</p>
                           <p>因为触发器<code class="codeph">dept_cascade2</code>更新了<code class="codeph">emp</code>表，所以<a href="plsql-triggers.html#GUID-2DC16B21-35B1-4D09-BD4E-02797AA278EA__BCFGAHIB">示例9-6中</a>的<code class="codeph">emp_dept_check</code>触发器（如果启用）也会触发。由此产生的变异表错误被<code class="codeph">emp_dept_check</code>触发器捕获。仔细测试任何需要错误捕获的触发器，以确保它们始终在您的环境中正常工作。
                           </p>
                        </div>
                        <div class="example" id="GUID-193F9DBB-80B5-49FC-83D2-2FB533880833__BCFDBJDA">
                           <p class="titleinexample">例9-10父表的UPDATE CASCADE触发器</p><pre class="oac_no_warn" dir="ltr">- 生成要用作标志的序列号 - 用于确定列上是否发生更新：CREATE SEQUENCE Update_sequence INCREMENT BY 1 MAXVALUE 5000 CYCLE;创建或替换包装Integritypackage AUTHID DEFINER作为Updateseq NUMBER; END Integritypackage; /创建或更换包装盒Integritypackage AS END Integritypackage; /  - 创建标志col：ALTER TABLE emp ADD Update_id NUMBER;创建或替换TRIGGER dept_cascade1更新deptno ON部门DECLARE之前 - 在更新dept表（这是一个语句触发器）之前， - 生成序列号 - 并将其分配给公共变量UPDATESEQ  - 用户定义的包名为INTEGRITYPACKAGE： BEGIN Integritypackage。Updateseq：= Update_sequence。NEXTVAL;结束; /创建或替换TRETGER dept_cascade2删除或更新Deptno ON部门的每个行 - 对于更新的部门中的每个部门号， - 级联更新到emp表中的从属外键。- 仅当此触发器未更新子行时才进行级联更新：BEGIN IF UPDATING THEN UPDATE emp SET Deptno =：NEW.Deptno，Update_id = Integritypackage。Updateseq  - 来自1st WHERE emp。Deptno =：OLD.Deptno AND Update_id IS NULL; / *如果没有被同一触发语句* / END IF触发的第三个触发器更新，则只有NULL;如果删除那么 - 从dept删除行后， - 删除DEP表中DEPTNO相同的emp表中的所有行 -  DEPTNO从dept表中删除：DELETE FROM emp WHERE emp。Deptno =：OLD.Deptno;万一;结束; /创建或替换TRITGER dept_cascade3更新Deptno ON部门BEGIN UPDATE emp SET Update_id = NULL WHERE Update_id = Integritypackage。Updateseq;结束; /</pre></div>
                        <!-- class="example" -->
                     </div>
                  </div><a id="LNPLS782"></a><a id="LNPLS781"></a><div class="props_rev_3"><a id="GUID-BF2DDD06-E6B4-4EB5-945F-89FFA8468D6F" name="GUID-BF2DDD06-E6B4-4EB5-945F-89FFA8468D6F"></a><h5 id="LNPLS-GUID-BF2DDD06-E6B4-4EB5-945F-89FFA8468D6F" class="sect5"><span class="enumeration_section">9.3.4.6</span>复杂约束检查的触发器</h5>
                     <div>
                        <p>触发器可以强制执行完整性规则而不是参照完整性。<a href="plsql-triggers.html#GUID-BF2DDD06-E6B4-4EB5-945F-89FFA8468D6F__BCFECGBI">例9-11</a>中的触发器在允许触发语句运行之前进行了复杂的检查。
                        </p>
                        <div class="infoboxnote" id="GUID-BF2DDD06-E6B4-4EB5-945F-89FFA8468D6F__GUID-496CB999-2424-4719-A947-6E839874356C">
                           <p class="notep1">注意：</p>
                           <p><a href="plsql-triggers.html#GUID-BF2DDD06-E6B4-4EB5-945F-89FFA8468D6F__BCFECGBI">例9-11</a>需要这个数据结构：</p><pre class="oac_no_warn" dir="ltr">CREATE TABLE Salgrade（等级NUMBER，失败编号，编号NUMBER，Job_classification VARCHAR2（9））;</pre></div>
                        <div class="example" id="GUID-BF2DDD06-E6B4-4EB5-945F-89FFA8468D6F__BCFECGBI">
                           <p class="titleinexample">例9-11触发器检查复杂约束</p><pre class="oac_no_warn" dir="ltr">在Sal的插入或更新之前创建或替换TRIGGER salary_check，每个行的工作申请减去MESAL NUMBER; Maxsal NUMBER; Salary_out_of_range EXCEPTION; PRAGMA EXCEPTION_INIT（Salary_out_of_range，-4096）; BEGIN / *从SALGRADE表中检索员工新工作分类的最低和最高工资为MINSAL和MAXSAL：* / SELECT Losal，Hisal INTO Minsal，Maxsal FROM Salgrade WHERE Job_classification =：NEW.Job; / *如果员工的新工资低于或高于工作分类的限制，则提出例外。返回异常消息，并且回滚触发触发器的挂起INSERT或UPDATE语句：* / IF（：NEW.Sal &lt;Minsal OR：NEW.Sal&gt; Maxsal）然后提高Salary_out_of_range;万一; Salary_out_of_range之后的异常，然后Raise_application_error（-20300，'薪水'|| TO_CHAR（：NEW.Sal）||'超出'||'职业分类范围'||：NEW.Job ||'for employee'||： NEW.Ename）;当NO_DATA_FOUND那么Raise_application_error（-20322，'无效的工作分类'）;结束; /</pre></div>
                        <!-- class="example" -->
                     </div>
                  </div><a id="LNPLS784"></a><a id="LNPLS783"></a><div class="props_rev_3"><a id="GUID-9E6E59EF-F402-4B11-A4FF-268D9C0521EB" name="GUID-9E6E59EF-F402-4B11-A4FF-268D9C0521EB"></a><h5 id="LNPLS-GUID-9E6E59EF-F402-4B11-A4FF-268D9C0521EB" class="sect5"><span class="enumeration_section">9.3.4.7</span>复杂安全授权的触发器</h5>
                     <div>
                        <p>触发器通常用于对表数据强制执行复杂的安全授权。仅使用触发器强制执行无法使用数据库提供的数据库安全功能定义的复杂安全授权。例如，使用触发器禁止在周末和非工作时间更新<code class="codeph">employee</code>表。
                        </p>
                        <p>使用触发器强制执行复杂的安全授权时，最好使用<code class="codeph">BEFORE</code>语句触发器。使用<code class="codeph">BEFORE</code>语句触发器具有以下好处：</p>
                        <ul style="list-style-type:disc">
                           <li>
                              <p>在允许触发语句运行之前完成安全检查，以便未经授权的语句不会浪费任何工作。</p>
                           </li>
                           <li>
                              <p>安全检查仅针对触发语句，而不是针对受触发语句影响的每一行。</p>
                           </li>
                        </ul>
                        <p><a href="plsql-triggers.html#GUID-9E6E59EF-F402-4B11-A4FF-268D9C0521EB__BCFGEBAA">示例9-12中</a>的触发器通过在周末或非工作时间尝试更新表<code class="codeph">employees</code>时引发异常来强制实施安全性。
                        </p>
                        <div class="infoboxnotealso" id="GUID-9E6E59EF-F402-4B11-A4FF-268D9C0521EB__GUID-1DAE25DA-9CCD-4F7D-83A3-5EDC9D07B9D5">
                           <p class="notep1">也可以看看：</p>
                           <p>有关数据库安全功能的详细信息，请<a href="https://www.oracle.com/pls/topic/lookup?ctx=en/database/oracle/oracle-database/19/lnpls&amp;id=DBSEG-GUID-245AF418-2349-4657-9010-8C8D7849FD05" target="_blank"><span class="italic">参见“Oracle数据库安</span></a></p>
                        </div>
                        <div class="example" id="GUID-9E6E59EF-F402-4B11-A4FF-268D9C0521EB__BCFGEBAA">
                           <p class="titleinexample">例9-12触发器强制执行安全授权</p><pre class="oac_no_warn" dir="ltr">创建或替换TRIGGER Employee_permit_changes在插入或删除或更新员工之前DECLARE Dummy INTEGER; Not_on_weekends EXCEPTION; Nonworking_hours EXCEPTION; PRAGMA EXCEPTION_INIT（Not_on_weekends，-4097）; PRAGMA EXCEPTION_INIT（Nonworking_hours，-4099）;开始 - 检查周末：IF（TO_CHAR（Sysdate，'DAY'）='SAT'或TO_CHAR（Sysdate，'DAY'）='SUN'）然后升起Not_on_weekends;万一; - 检查工作时间（上午8点至下午6点）：IF（TO_CHAR（Sysdate，'HH24'）&lt;8或TO_CHAR（Sysdate，'HH24'）&gt; 18）然后提高Nonworking_hours;万一; Not_on_weekends THEN Raise_application_error（-20324，周末期间'可能不会改变'|''员工表'）的例外情况;当Nonworking_hours THEN Raise_application_error（-20326，'非工作时间''可能不会改变'|''emp表'）;结束; /</pre></div>
                        <!-- class="example" -->
                     </div>
                  </div><a id="LNPLS785"></a><div class="props_rev_3"><a id="GUID-6DF46DC3-1311-4A93-B509-16B396901E97" name="GUID-6DF46DC3-1311-4A93-B509-16B396901E97"></a><h5 id="LNPLS-GUID-6DF46DC3-1311-4A93-B509-16B396901E97" class="sect5"><span class="enumeration_section">9.3.4.8</span>透明事件记录的触发器</h5>
                     <div>
                        <p>当您希望在某些事件后透明地对数据库进行相关更改时，触发器非常有用。</p>
                        <p><code class="codeph">REORDER</code>触发器示例显示一个触发器，在满足某些条件时根据需要重新排序部件。（换句话说，输入了一个触发语句， <code class="codeph">PARTS_ON_HAND</code>值小于<code class="codeph">REORDER_POINT</code>值。）
                        </p>
                     </div>
                  </div><a id="LNPLS787"></a><a id="LNPLS786"></a><div class="props_rev_3"><a id="GUID-BD042B88-E2E7-4A7D-8FA2-8D0185F6455F" name="GUID-BD042B88-E2E7-4A7D-8FA2-8D0185F6455F"></a><h5 id="LNPLS-GUID-BD042B88-E2E7-4A7D-8FA2-8D0185F6455F" class="sect5"><span class="enumeration_section">9.3.4.9</span>派生列值的触发器</h5>
                     <div>
                        <p>触发器可以根据<code class="codeph">INSERT</code>或<code class="codeph">UPDATE</code>语句提供的值自动派生列值。此类触发器可用于强制特定列中的值取决于同一行中其他列的值。由于以下原因，必须<code class="codeph">BEFORE</code>触发才能完成此类操作：</p>
                        <ul style="list-style-type:disc">
                           <li>
                              <p>必须在<code class="codeph">INSERT</code>或<code class="codeph">UPDATE</code>发生之前派生依赖值，以便触发语句可以使用派生值。
                              </p>
                           </li>
                           <li>
                              <p>触发器必须触发受触发<code class="codeph">INSERT</code>或<code class="codeph">UPDATE</code>语句影响的每一行。
                              </p>
                           </li>
                        </ul>
                        <p>只要插入或更新了行， <a href="plsql-triggers.html#GUID-BD042B88-E2E7-4A7D-8FA2-8D0185F6455F__BCFDEHHE">示例9-13中</a>的触发器就会为表派生新的列值。
                        </p>
                        <div class="infoboxnote" id="GUID-BD042B88-E2E7-4A7D-8FA2-8D0185F6455F__GUID-EE67A5C1-D046-4C95-9514-EED2E852C087">
                           <p class="notep1">注意：</p>
                           <p><a href="plsql-triggers.html#GUID-BD042B88-E2E7-4A7D-8FA2-8D0185F6455F__BCFDEHHE">例9-13</a>需要对此数据结构进行此更改：</p><pre class="oac_no_warn" dir="ltr">ALTER TABLE Emp ADD（Uppername VARCHAR2（20），Soundexname VARCHAR2（20））;</pre></div>
                        <div class="example" id="GUID-BD042B88-E2E7-4A7D-8FA2-8D0185F6455F__BCFDEHHE">
                           <p class="titleinexample">例9-13触发器派生新的列值</p><pre class="oac_no_warn" dir="ltr">创建或替换TRIGGER在插入或更新Enfe ON Emp / *之前导出在更新ENAME字段之前，派生UPPERNAME和SOUNDEXNAME字段的值。限制用户直接更新这些字段：* / FOR EACH ROW BEGIN：NEW.Uppername：= UPPER（：NEW.Ename）; ：NEW.Soundexname：= SOUNDEX（：NEW.Ename）;结束; /</pre></div>
                        <!-- class="example" -->
                     </div>
                  </div><a id="LNPLS788"></a><div class="props_rev_3"><a id="GUID-4F93F21E-BA7F-4378-87E6-46A8E4C03287" name="GUID-4F93F21E-BA7F-4378-87E6-46A8E4C03287"></a><h5 id="LNPLS-GUID-4F93F21E-BA7F-4378-87E6-46A8E4C03287" class="sect5"><span class="enumeration_section">9.3.4.10</span>构建复杂可更新视图的触发器</h5>
                     <div>
                        <p>视图是提供表数据逻辑窗口的绝佳机制。但是，当视图查询变得复杂时，系统隐式地无法将视图上的DML转换为基础表上的DML。<code class="codeph">INSTEAD</code> <code class="codeph">OF</code>触发器有助于解决此问题。可以在视图上定义这些触发器，并触发它们而不是实际的DML。</p>
                        <p>考虑一个图书馆系统，书籍按标题排列。该库包含一系列书籍类型对象：</p><pre class="oac_no_warn" dir="ltr">创建或替换类型Book_t AS OBJECT（Booknum NUMBER，Title VARCHAR2（20），Author VARCHAR2（20），Available CHAR（1））; / CREATE OR REPLACE TYPE Book_list_t AS TABLE of Book_t; /</pre><p>表<code class="codeph">Book_table</code>创建并填充如下：</p><pre class="oac_no_warn" dir="ltr">DROP TABLE Book_table; CREATE TABLE Book_table（Booknum NUMBER，Section VARCHAR2（20），Title VARCHAR2（20），Author VARCHAR2（20），Available CHAR（1））; INSERT INTO Book_table（Booknum，Section，Title，Author，Available）VALUES（121001，'Classic'，'Iliad'，'Homer'，'Y'）; INSERT INTO Book_table（Booknum，Section，Title，Author，Available）VALUES（121002，'Novel'，'Gone with the Wind'，'Mitchell M'，'N'）; SELECT * FROM Book_table ORDER BY Booknum;</pre><p>结果：</p><pre class="oac_no_warn" dir="ltr">BOOKNUM SECTION TITLE AUTHOR A ---------- -------------------- --------------- ----- --------------------  -  121001 Classic Iliad Homer Y 121002 Novel Gone with the Wind Mitchell MN 2行入选。
</pre><p>创建表<code class="codeph">Library_table</code>并填充如下：</p><pre class="oac_no_warn" dir="ltr">DROP TABLE Library_table; CREATE TABLE Library_table（Section VARCHAR2（20））; INSERT INTO Library_table（Section）VALUES（'Novel'）; INSERT INTO Library_table（Section）VALUES（'Classic'）; SELECT * FROM Library_table ORDER BY Section;</pre><p>结果：</p><pre class="oac_no_warn" dir="ltr">SECTION --------------------经典小说2行选中。
</pre><p>您可以在表<code class="codeph">Book_table</code>和<code class="codeph">Library_table</code>上定义复杂视图，以创建库的逻辑视图，其中包含每个部分中的部分和书籍集合：</p><pre class="oac_no_warn" dir="ltr">创建或替换视图Library_view AS SELECT i。部分，CAST（MULTISET（选择b。Booknum，b。标题，b。作者，b。可从FROM Book_table b WHERE b。Section = i。部分）AS Book_list_t）BOOKLIST FROM Library_table i;</pre><p>（有关<code class="codeph">CAST</code>函数的信息，请参阅<a href="https://www.oracle.com/pls/topic/lookup?ctx=en/database/oracle/oracle-database/19/lnpls&amp;id=SQLRF00613" target="_blank"><span class="italic">Oracle数据库SQL语言参考</span></a> 。）
                        </p>
                        <p>通过在其上定义<code class="codeph">INSTEAD</code> <code class="codeph">OF</code>触发器来使<code class="codeph">Library_view</code>可更新：</p><pre class="oac_no_warn" dir="ltr">创建或替换TRIGGER Library_trigger INSTEAD OF INSERT ON Library_view for EACH ROW DECLARE Bookvar Book_t;我是INTEGER; BEGIN INSERT INTO Library_table VALUES（：NEW.Section）; FOR I IN 1 ..：NEW.Booklist。COUNT LOOP Bookvar：=：NEW.Booklist（i）; INSERT INTO Book_table（Booknum，Section，Title，Author，Available）VALUES（Bookvar.booknum，：NEW.Section，Bookvar。标题，Bookvar。作者，bookvar。可用）;结束循环;结束; /</pre><p>在<code class="codeph">Library_view</code>插入一个新行：</p><pre class="oac_no_warn" dir="ltr">INSERT INTO Library_view（Section，Booklist）VALUES（'History'，book_list_t（book_t（121330，'Alexander'，'Mirth'，'Y'）））;</pre><p>查看对<code class="codeph">Library_view</code>的影响：</p><pre class="oac_no_warn" dir="ltr">SELECT * FROM Library_view ORDER BY Section;</pre><p>结果：</p><pre class="oac_no_warn" dir="ltr">部分-------------------- BOOKLIST（BOOKNUM，TITLE，AUTHOR，AVAILABLE）------------------- -------------------------------------------------经典BOOK_LIST_T（BOOK_T（121001，'Iliad'，'Homer'，'Y'））历史BOOK_LIST_T（BOOK_T（121330，'亚历山大'，'欢乐'，'Y'））小说BOOK_LIST_T（BOOK_T（121002，'Gone with the Wind'，'Mitchell M'，'N'））选择了3行。
</pre><p>查看对<code class="codeph">Book_table</code>的影响：</p><pre class="oac_no_warn" dir="ltr">SELECT * FROM Book_table ORDER BY Booknum;</pre><p>结果：</p><pre class="oac_no_warn" dir="ltr">BOOKNUM SECTION TITLE AUTHOR A ---------- -------------------- --------------- ----- --------------------  -  121001 Classic Iliad Homer Y 121002 Novel Gone with the Wind Mitchell MN 121330历史Alexander Mirth Y 3行入选。
</pre><p>查看对<code class="codeph">Library_table</code>的影响：</p><pre class="oac_no_warn" dir="ltr">SELECT * FROM Library_table ORDER BY Section;</pre><p>结果：</p><pre class="oac_no_warn" dir="ltr">SECTION --------------------经典历史小说选3行。
</pre><p>同样，您还可以在嵌套表<code class="codeph">booklist</code>上定义触发器，以处理嵌套表元素的修改。
                        </p>
                     </div>
                  </div><a id="LNPLS789"></a><div class="props_rev_3"><a id="GUID-86F46BD4-9225-41D0-AAF7-DA467F8412A9" name="GUID-86F46BD4-9225-41D0-AAF7-DA467F8412A9"></a><h5 id="LNPLS-GUID-86F46BD4-9225-41D0-AAF7-DA467F8412A9" class="sect5"><span class="enumeration_section">9.3.4.11细粒度</span>访问控制的触发器</h5>
                     <div>
                        <p>您可以使用<code class="codeph">LOGON</code>触发器来运行与应用程序上下文关联的包。应用程序上下文捕获有关登录数据库的用户的与会话相关的信息。从那里，您的应用程序可以根据他或她的会话信息控制该用户拥有的访问权限。
                        </p>
                        <div class="infoboxnote" id="GUID-86F46BD4-9225-41D0-AAF7-DA467F8412A9__GUID-F4A0E51B-E376-42AF-A345-AA0495BB2797">
                           <p class="notep1">注意：</p>
                           <p>如果您具有非常特定的登录要求，例如阻止用户从防火墙外部或在工作时间之后登录，请考虑使用Oracle Database Vault而不是<code class="codeph">LOGON</code>触发器。使用Oracle Database Vault，您可以创建自定义规则以严格控制用户访问。
                           </p>
                        </div>
                        <div class="infoboxnotealso" id="GUID-86F46BD4-9225-41D0-AAF7-DA467F8412A9__GUID-ED043872-4D04-49DA-8428-691F566AA99E">
                           <p class="notep1">也可以看看：</p>
                           <ul style="list-style-type:disc">
                              <li>
                                 <p>有关创建<code class="codeph">LOGON</code>触发器以运行数据库会话应用程序上下文包的信息，请<code class="codeph">LOGON</code> <a href="https://www.oracle.com/pls/topic/lookup?ctx=en/database/oracle/oracle-database/19/lnpls&amp;id=DBSEG60634" target="_blank"><span class="italic">“Oracle数据库安全性指南</span></a></p>
                              </li>
                              <li>
                                 <p>有关Oracle Database Vault的信息，请参见<a href="../dvadm/introduction-to-oracle-database-vault.html#DVADM-GUID-0C8AF1B2-6CE9-4408-BFB3-7B2C7F9E7284" target="_blank"><span class="italic">“Oracle Database Vault管理员指南”</span></a></p>
                              </li>
                           </ul>
                        </div>
                     </div>
                  </div>
               </div>
            </div><a id="LNPLS663"></a><a id="LNPLS664"></a><a id="LNPLS724"></a><a id="LNPLS669"></a><a id="LNPLS682"></a><a id="LNPLS99955"></a><div class="props_rev_3"><a id="GUID-4CF74E99-8859-4AB1-96E7-07898A2ABB9E" name="GUID-4CF74E99-8859-4AB1-96E7-07898A2ABB9E"></a><h3 id="LNPLS-GUID-4CF74E99-8859-4AB1-96E7-07898A2ABB9E" class="sect3"><span class="enumeration_section">9.4</span>相关名称和伪记录</h3>
               <div>
                  <div class="infoboxnote" id="GUID-4CF74E99-8859-4AB1-96E7-07898A2ABB9E__GUID-DC263258-1EEF-4F4F-AC13-627BC769A001">
                     <p class="notep1">注意：</p>
                     <p>本主题仅适用于在行级别触发的触发器。那是：</p>
                     <ul style="list-style-type:disc">
                        <li>
                           <p>行级简单DML触发器</p>
                        </li>
                        <li>
                           <p>复合DML触发器具有行级时间点部分</p>
                        </li>
                     </ul>
                  </div>
                  <p>在行级别触发的触发器可以使用<span class="bold">相关名称</span>访问正在处理的行中的数据。默认相关名称为<code class="codeph">OLD</code> ， <code class="codeph">NEW</code>和<code class="codeph">PARENT</code> 。要更改相关名，请使用<code class="codeph">CREATE</code> <code class="codeph">TRIGGER</code>语句的<code class="codeph">REFERENCING</code>子句（请参阅<span class="q">“ <a href="CREATE-TRIGGER-statement.html#GUID-AF9E33F1-64D1-4382-A6A4-EC33C36F237B__BABEBAAB">referencing_clause :: =</a> ”</span> ）。
                  </p>
                  <p>如果在嵌套表上创建触发器，则<code class="codeph">OLD</code>和<code class="codeph">NEW</code>引用嵌套表的当前行， <code class="codeph">PARENT</code>引用父表的当前行。如果在表或视图上创建触发器，则<code class="codeph">OLD</code>和<code class="codeph">NEW</code>引用表或视图的当前行，并且未定义<code class="codeph">PARENT</code> 。
                  </p>
                  <p><code class="codeph">OLD</code> ， <code class="codeph">NEW</code>和<code class="codeph">PARENT</code>也称为<span class="bold">伪</span>记录，因为它们具有记录结构，但允许在比记录更少的上下文中。伪记录的结构是<span class="italic"><code class="codeph">table_name</code></span> <code class="codeph">%ROWTYPE</code> ，其中<span class="italic"><code class="codeph">table_name</code></span>是创建触发器的表的名称（对于<code class="codeph">OLD</code>和<code class="codeph">NEW</code> ）或父表的名称（对于<code class="codeph">PARENT</code> ）。
                  </p>
                  <p>在简单触发器的<span class="italic"><code class="codeph">trigger_body</code></span>或复合触发器的<span class="italic"><code class="codeph">tps_body</code></span>中，相关名称是绑定变量的占位符。使用以下语法引用伪记录的字段：</p><pre class="oac_no_warn" dir="ltr">： <span class="italic">pseudorecord_name</span> 。 <span class="italic">FIELD_NAME</span>
</pre><p>在条件触发器的<code class="codeph">WHEN</code>子句中，相关名称不是绑定变量的占位符。因此，请省略前面语法中的冒号。
                  </p>
                  <p><a href="plsql-triggers.html#GUID-4CF74E99-8859-4AB1-96E7-07898A2ABB9E__CIHDBHIH" title="该表有三列。第一列列出了DML触发器的三种可能的触发语句。第二列和第三列分别列出了每个触发语句的伪记录OLD和NEW的字段值。">表9-4</a>显示了触发语句正在处理的行的<code class="codeph">OLD</code>和<code class="codeph">NEW</code>字段的值。
                  </p>
                  <div class="tblformal" id="GUID-4CF74E99-8859-4AB1-96E7-07898A2ABB9E__CIHDBHIH">
                     <p class="titleintable">表9-4旧的和新的伪字段字段值</p>
                     <table cellpadding="4" cellspacing="0" class="Formal" title="旧的和新的伪字段字段值" width="100%" border="1" summary="This table has three columns. The first column lists the three possible triggering statements for a DML trigger. The second and third columns list the field values of the pseudorecords OLD and NEW, respectively, for each triggering statement." frame="hsides" rules="rows">
                        <thead>
                           <tr align="left" valign="top">
                              <th align="left" valign="bottom" width="27%" id="d67636e4324">触发声明</th>
                              <th align="left" valign="bottom" width="23%" id="d67636e4327">OLD.field值</th>
                              <th align="left" valign="bottom" width="51%" id="d67636e4333">NEW.field值</th>
                           </tr>
                        </thead>
                        <tbody>
                           <tr align="left" valign="top">
                              <td align="left" valign="top" width="27%" id="d67636e4341" headers="d67636e4324 ">
                                 <p><code class="codeph">插入</code></p>
                              </td>
                              <td align="left" valign="top" width="23%" headers="d67636e4341 d67636e4327 ">
                                 <p><code class="codeph">空值</code></p>
                              </td>
                              <td align="left" valign="top" width="51%" headers="d67636e4341 d67636e4333 ">
                                 <p>插入后的值</p>
                              </td>
                           </tr>
                           <tr align="left" valign="top">
                              <td align="left" valign="top" width="27%" id="d67636e4353" headers="d67636e4324 ">
                                 <p><code class="codeph">UPDATE</code></p>
                              </td>
                              <td align="left" valign="top" width="23%" headers="d67636e4353 d67636e4327 ">
                                 <p>更新前的值</p>
                              </td>
                              <td align="left" valign="top" width="51%" headers="d67636e4353 d67636e4333 ">
                                 <p>更新后的价值</p>
                              </td>
                           </tr>
                           <tr align="left" valign="top">
                              <td align="left" valign="top" width="27%" id="d67636e4364" headers="d67636e4324 ">
                                 <p><code class="codeph">删除</code></p>
                              </td>
                              <td align="left" valign="top" width="23%" headers="d67636e4364 d67636e4327 ">
                                 <p>预删除值</p>
                              </td>
                              <td align="left" valign="top" width="51%" headers="d67636e4364 d67636e4333 ">
                                 <p><code class="codeph">空值</code></p>
                              </td>
                           </tr>
                        </tbody>
                     </table>
                  </div>
                  <!-- class="inftblhruleinformal" -->
                  <p>伪记录的限制是：</p>
                  <ul style="list-style-type:disc">
                     <li>
                        <p>伪记录不能出现在记录级操作中。</p>
                        <p>例如，触发器不能包含此语句：</p><pre class="oac_no_warn" dir="ltr">：NEW：= NULL;</pre></li>
                     <li>
                        <p>伪记录不能是实际的子程序参数。</p>
                        <p>（伪记录字段可以是实际的子程序参数。）</p>
                     </li>
                     <li>
                        <p>触发器无法更改<code class="codeph">OLD</code>字段值。
                        </p>
                        <p>试图这样做会引起ORA-04085。</p>
                     </li>
                     <li>
                        <p>如果触发语句为<code class="codeph">DELETE</code> ，则触发器不能更改<code class="codeph">NEW</code>字段值。
                        </p>
                        <p>试图这样做会引起ORA-04084。</p>
                     </li>
                     <li>
                        <p><code class="codeph">AFTER</code>触发器无法更改<code class="codeph">NEW</code>字段值，因为触发语句在触发器触发之前运行。
                        </p>
                        <p>试图这样做会引起ORA-04084。</p>
                     </li>
                  </ul>
                  <p><code class="codeph">BEFORE</code>触发器可以在触发<code class="codeph">INSERT</code>或<code class="codeph">UPDATE</code>语句将它们放入表中之前更改<code class="codeph">NEW</code>字段值。
                  </p>
                  <p>如果语句同时触发<code class="codeph">BEFORE</code>触发器和<code class="codeph">AFTER</code>触发器，并且<code class="codeph">BEFORE</code>触发器更改<code class="codeph">NEW</code>字段值，则<code class="codeph">AFTER</code>触发器“看到”该更改。
                  </p>
                  <div class="example" id="GUID-4CF74E99-8859-4AB1-96E7-07898A2ABB9E__BCFBDJEC">
                     <p class="titleinexample">示例9-14触发日志对EMPLOYEES.SALARY的更改</p>
                     <p>此示例创建一个日志表和一个触发器，该触发器在任何<code class="codeph">UPDATE</code>语句影响<code class="codeph">EMPLOYEES</code>表的<code class="codeph">SALARY</code>列之后在日志表中插入一行，然后更新<code class="codeph">EMPLOYEES</code> 。 <code class="codeph">SALARY</code>并显示日志表。
                     </p>
                     <p>创建日志表：</p><pre class="oac_no_warn" dir="ltr">DROP TABLE Emp_log; CREATE TABLE Emp_log（Emp_id NUMBER，Log_date DATE，New_salary NUMBER，Action VARCHAR2（20））;</pre><p>创建在<code class="codeph">EMPLOYEES</code>之后在日志表中插入行的触发器。 <code class="codeph">SALARY</code>更新：</p><pre class="oac_no_warn" dir="ltr">创建或替换TRIGGER log_salary_increase更新员工工资后每行开始插入到Emp_log（Emp_id，Log_date，New_salary，Action）VALUES（：NEW.employee_id，SYSDATE，：NEW.salary，'New Salary'）;结束; /</pre><p>更新<code class="codeph">EMPLOYEES</code> 。 <code class="codeph">SALARY</code> ：</p><pre class="oac_no_warn" dir="ltr">UPDATE员工SET薪水=薪水+ 1000.0 WHERE Department_id = 20;</pre><p>结果：</p><pre class="oac_no_warn" dir="ltr">2行更新。
 </pre><p>显示日志表：</p><pre class="oac_no_warn" dir="ltr">SELECT * FROM Emp_log;</pre><p>结果：</p><pre class="oac_no_warn" dir="ltr">EMP_ID LOG_DATE NEW_SALARY ACTION ---------- --------- ---------- ----------------- --- 201 28-APR-10 13650新工资202 28-APR-10 6300新工资2行选择。
</pre></div>
                  <!-- class="example" -->
                  <div class="example" id="GUID-4CF74E99-8859-4AB1-96E7-07898A2ABB9E__CIHHEJCD">
                     <p class="titleinexample">例9-15条件触发器打印工资变更信息</p>
                     <p>此示例创建一个条件触发器，只要<code class="codeph">DELETE</code> ， <code class="codeph">INSERT</code>或<code class="codeph">UPDATE</code>语句影响<code class="codeph">EMPLOYEES</code>表，就会打印工资变更信息 - 除非该信息与总统有关。数据库评估每个受影响行的<code class="codeph">WHEN</code>条件。如果受影响的行的<code class="codeph">WHEN</code>条件为<code class="codeph">TRUE</code> ，则触发器语句运行之前触发器会触发该行。如果受影响的行的<code class="codeph">WHEN</code>条件不为<code class="codeph">TRUE</code> ，则触发器不会触发该行，但触发语句仍会运行。
                     </p><pre class="oac_no_warn" dir="ltr">创建或替换TRIGGER print_salary_changes之前在每个行的<span class="bold">时间内</span>删除或插入或更新员工<span class="bold">（NEW.job_id &lt;&gt;'AD_PRES'） - 不打印有关总统</span> DECLARE sal_diff NUMBER的信息; BEGIN sal_diff：=：NEW.salary  - ：OLD.salary; DBMS_OUTPUT.PUT（：NEW.last_name ||'：'）; DBMS_OUTPUT.PUT（'Old salary ='||：OLD.salary ||'，'）; DBMS_OUTPUT.PUT（'New salary ='||：NEW.salary ||'，'）; DBMS_OUTPUT.PUT_LINE（'差异：'|| sal_diff）;结束; /</pre><p>查询：</p><pre class="oac_no_warn" dir="ltr">SELECT last_name，department_id，salary，job_id FROM employees WHERE department_id IN（10,20,90）ORDER BY department_id，last_name;</pre><p>结果：</p><pre class="oac_no_warn" dir="ltr">LAST_NAME DEPARTMENT_ID SALARY JOB_ID ------------------------- ------------- -------- -  ---------- Whalen 10 4200 AD_ASST Fay 20 6000 MK_REP Hartstein 20 13000 MK_MAN De Haan 90 17000 AD_VP <span class="bold">King 90 24000 AD_PRES</span> Kochhar 90 17000 AD_VP <span class="bold">6行选择。</span>
</pre><p>触发声明：</p><pre class="oac_no_warn" dir="ltr">UPDATE员工SET薪水=薪水* 1.05 WHERE department_id IN（10,20,90）;</pre><p>结果：</p><pre class="oac_no_warn" dir="ltr">Whalen：老薪= 4200，新薪= 4410，差异：210 Hartstein：老薪= 13000，新薪= 13650，差异：650 Fay：老薪= 6000，新薪= 6300，差异：300 Kochhar：老薪= 17000，新工资= 17850，差异：850德哈恩：旧工资= 17000，新工资= 17850，差异：850 <span class="bold">6行更新。</span>
</pre><p>查询：</p><pre class="oac_no_warn" dir="ltr">SELECT salary FROM employees WHERE job_id ='AD_PRES';</pre><p>结果：</p><pre class="oac_no_warn" dir="ltr">SALARY ---------- <span class="bold">25200</span> 1行选中。
</pre></div>
                  <!-- class="example" -->
                  <div class="example" id="GUID-4CF74E99-8859-4AB1-96E7-07898A2ABB9E__BCFJDBEH">
                     <p class="titleinexample">示例9-16触发器修改CLOB列</p>
                     <p>此示例创建一个修改<code class="codeph">CLOB</code>列的<code class="codeph">UPDATE</code>触发器。
                     </p>
                     <p>有关<code class="codeph">TO_CLOB</code>和其他转换函数的信息，请参见<a href="../sqlrf/Single-Row-Functions.html#SQLRF20034" target="_blank"><span class="italic">Oracle数据库SQL语言参考</span></a> 。
                     </p><pre class="oac_no_warn" dir="ltr">DROP TABLE tab1; CREATE TABLE tab1（ <span class="bold">c1 CLOB</span> ）; INSERT INTO tab1 VALUES（'&lt;h1&gt; HTML Document Fragment &lt;/ h1&gt; &lt;p&gt;一些文字。'，3）;在tab1上更新之前创建或替换TRIGGER trg1每个行开始DBMS_OUTPUT.PUT_LINE（'旧值CLOB列：'||：OLD.c1）; DBMS_OUTPUT.PUT_LINE（'建议CLOB列的新值：'||：NEW.c1）; <span class="bold">：NEW.c1：=：NEW.c1 || TO_CLOB（'&lt;hr&gt; &lt;p&gt;标准页脚段落。“）;</span> DBMS_OUTPUT.PUT_LINE（'CLOB列的最终值：'||：NEW.c1）;结束; / SET SERVEROUTPUT ON; UPDATE tab1 SET c1 ='&lt;h1&gt;不同的文档片段&lt;/ h1&gt; &lt;p&gt;不同的文本。“; SELECT * FROM tab1;</pre></div>
                  <!-- class="example" -->
                  <div class="example" id="GUID-4CF74E99-8859-4AB1-96E7-07898A2ABB9E__BCFIAABG">
                     <p class="titleinexample">例9-17使用REFERENCING子句触发</p>
                     <p>此示例创建一个与相关名称<code class="codeph">new</code>相同的表，然后在该表上创建一个触发器。为避免表名与相关名之间发生冲突，触发器将相关名称引用为<code class="codeph">Newest</code> 。</p><pre class="oac_no_warn" dir="ltr">CREATE TABLE new（field1 NUMBER，field2 VARCHAR2（20））;创建或替换TRIGGER Print_salary_changes更新之前新的<span class="bold">REFERENCING新AS最新</span> FOR EACH ROW BEGIN <span class="bold">：最新</span> .Field2：= TO_CHAR（ <span class="bold">：最新</span> .field1）;结束; /</pre></div>
                  <!-- class="example" -->
               </div><a id="LNPLS753"></a><a id="LNPLS752"></a><div class="props_rev_3"><a id="GUID-C42CC16B-EAC1-4093-85C8-6359D08C912F" name="GUID-C42CC16B-EAC1-4093-85C8-6359D08C912F"></a><h4 id="LNPLS-GUID-C42CC16B-EAC1-4093-85C8-6359D08C912F" class="sect4"><span class="enumeration_section">9.4.1</span> OBJECT_VALUE伪列</h4>
                  <div>
                     <p>对象表上的DML触发器可以引用SQL伪列<code class="codeph">OBJECT_VALUE</code> ，它返回对象表的列的系统生成的名称。触发器还可以调用PL / SQL子程序，该子程序具有正式<code class="codeph">IN</code>参数，其数据类型为<code class="codeph">OBJECT_VALUE</code> 。</p>
                     <div class="infoboxnotealso" id="GUID-C42CC16B-EAC1-4093-85C8-6359D08C912F__GUID-6221940E-4F3A-430B-9969-526A83B18955">
                        <p class="notep1">也可以看看：</p>
                        <ul style="list-style-type:disc">
                           <li>
                              <p>有关<code class="codeph">OBJECT_VALUE</code>更多信息，请<code class="codeph">OBJECT_VALUE</code> <a href="../sqlrf/OBJECT_VALUE-Pseudocolumn.html#SQLRF50952" target="_blank"><span class="italic">Oracle数据库SQL语言参考</span></a></p>
                           </li>
                           <li>
                              <p>有关伪列的一般信息，请<a href="../sqlrf/Pseudocolumns.html#SQLRF0025" target="_blank"><span class="italic">参见Oracle数据库SQL语言参考</span></a></p>
                           </li>
                        </ul>
                     </div>
                     <p><a href="plsql-triggers.html#GUID-C42CC16B-EAC1-4093-85C8-6359D08C912F__BCFFIBBA">例9-18</a>创建了对象表<code class="codeph">tbl</code> ，表<code class="codeph">tbl_history</code>用于记录对<code class="codeph">tbl</code>更新，并触发<code class="codeph">Tbl_Trg</code> 。触发器针对受DML语句影响的每一行<code class="codeph">tb1</code>运行，导致<code class="codeph">tbl</code>对象<code class="codeph">t</code>的旧值和新值写入<code class="codeph">tbl_history</code> 。旧的和新的价值观是： <code class="codeph">OLD</code> 。 <code class="codeph">OBJECT_VALUE</code>和： <code class="codeph">NEW</code> 。 <code class="codeph">OBJECT_VALUE</code> 。</p>
                     <p>列<code class="codeph">n</code>所有值都增加了1。<code class="codeph">m</code>的值保持为0。
                     </p>
                     <div class="example" id="GUID-C42CC16B-EAC1-4093-85C8-6359D08C912F__BCFFIBBA">
                        <p class="titleinexample">例9-18触发器引用OBJECT_VALUE伪列</p>
                        <p>创建，填充和显示对象表：</p><pre class="oac_no_warn" dir="ltr">创建或替换类型t AUTHID DEFINER as OBJECT（n NUMBER，m NUMBER）/ CREATE TABLE tbl OF t / BEGIN for j IN 1..5 LOOP INSERT INTO tbl VALUES（t（j，0））;结束循环;结束; / SELECT * FROM tbl ORDER BY n;</pre><p>结果：</p><pre class="oac_no_warn" dir="ltr">NM ---------- ---------- 1 0 2 0 3 0 4 0 5 0 5行选择。
</pre><p>创建历史表和触发器：</p><pre class="oac_no_warn" dir="ltr">CREATE TABLE tbl_history（d DATE，old_obj t，new_obj t）/创建或替换TRETGER Tbl_Trg更新后，每次行开始执行tbl_history（d，old_obj，new_obj）VALUES（SYSDATE， <span class="bold">：OLD.OBJECT_VALUE</span> ， <span class="bold">：NEW.OBJECT_VALUE）</span> ）; END Tbl_Trg; /</pre><p>更新对象表：</p><pre class="oac_no_warn" dir="ltr">UPDATE tbl SET tbl.n = tbl.n + 1 /</pre><p>结果：</p><pre class="oac_no_warn" dir="ltr">5行更新。
</pre><p>显示旧值和新值：</p><pre class="oac_no_warn" dir="ltr">为j IN开始（SELECT d，old_obj，new_obj FROM tbl_history）LOOP DBMS_OUTPUT.PUT_LINE（jd ||' -  old：'|| j.old_obj.n ||''|| j.old_obj.m ||' -  -  new：'|| j.new_obj.n ||''|| j.new_obj.m）;结束循环;结束; /</pre><p>结果：</p><pre class="oac_no_warn" dir="ltr">28-APR-10  - 旧：1 0  - 新：2 0 28-APR-10  - 旧：2 0  - 新：3 0 28-APR-10  - 旧：3 0  - 新：4 0 28-APR-10  - 旧：4 0  - 新：5 0 28-APR-10  - 旧：5 0  - 新：6 0</pre></div>
                     <!-- class="example" -->
                  </div>
               </div>
            </div><a id="LNPLS99887"></a><div class="props_rev_3"><a id="GUID-FE23FCE8-DE36-41EF-80A9-6B4B49E80E5B" name="GUID-FE23FCE8-DE36-41EF-80A9-6B4B49E80E5B"></a><h3 id="LNPLS-GUID-FE23FCE8-DE36-41EF-80A9-6B4B49E80E5B" class="sect3"><span class="enumeration_section">9.5</span>系统触发器</h3>
               <div>
                  <p>在架构或数据库上创建<span class="bold">系统触发器</span> 。
                  </p>
                  <p>其触发事件由DDL语句（在<span class="q">“ <a href="CREATE-TRIGGER-statement.html#GUID-AF9E33F1-64D1-4382-A6A4-EC33C36F237B__CIHBDEFD">ddl_event</a> ”中</span>列出）或数据库操作语句（在<span class="q">“ <a href="CREATE-TRIGGER-statement.html#GUID-AF9E33F1-64D1-4382-A6A4-EC33C36F237B__CIHBABAH">database_event</a> ”中</span>列出）组成。
                  </p>
                  <p>系统触发器恰好在其中一个时间点触发：</p>
                  <ul style="list-style-type:disc">
                     <li>
                        <p>在触发语句运行之前</p>
                        <p>（触发器称为<span class="italic"><code class="codeph">BEFORE</code></span> <span class="italic">语句触发器</span>或<span class="italic">语句级</span> <span class="italic"><code class="codeph">BEFORE</code></span> <span class="italic">触发器。</span> ）
                        </p>
                     </li>
                     <li>
                        <p>触发语句运行后</p>
                        <p>（触发器称为<span class="italic"><code class="codeph">AFTER</code></span> <span class="italic">语句触发器</span>或<span class="italic">语句级</span> <span class="italic"><code class="codeph">AFTER</code></span> <span class="italic">触发器。</span> ）
                        </p>
                     </li>
                     <li>
                        <p>而不是触发<code class="codeph">CREATE</code>语句</p>
                        <p>（触发器称为<span class="italic"><code class="codeph">INSTEAD</code></span> <span class="italic"><code class="codeph">OF</code></span> <span class="italic"><code class="codeph">CREATE</code></span> <span class="italic">触发器</span> 。）
                        </p>
                     </li>
                  </ul>
                  <p>话题</p>
                  <ul style="list-style-type:disc">
                     <li>
                        <p><a href="plsql-triggers.html#GUID-6CF3A208-0BE7-45FF-928C-A755526933D0">SCHEMA触发器</a></p>
                     </li>
                     <li>
                        <p><a href="plsql-triggers.html#GUID-AC093015-E9EA-47B1-8B0C-51A1860AB12D">数据库触发器</a></p>
                     </li>
                     <li>
                        <p><a href="plsql-triggers.html#GUID-7B32FE4B-AB8E-48B0-A74C-599584A485A7">INSTEAD OF CREATE触发器</a></p>
                     </li>
                  </ul>
               </div><a id="LNPLS683"></a><a id="LNPLS99886"></a><div class="props_rev_3"><a id="GUID-6CF3A208-0BE7-45FF-928C-A755526933D0" name="GUID-6CF3A208-0BE7-45FF-928C-A755526933D0"></a><h4 id="LNPLS-GUID-6CF3A208-0BE7-45FF-928C-A755526933D0" class="sect4"><span class="enumeration_section">9.5.1</span> SCHEMA触发器</h4>
                  <div>
                     <p>在架构上创建<span class="bold"><code class="codeph">SCHEMA</code></span> <span class="bold">触发器</span> ，只要拥有它的用户是当前用户并启动触发事件，就会触发该触发器。
                     </p>
                     <p>假设user1和user2都拥有模式触发器，user1调用user2拥有的DR单元。在DR单元内，user2是当前用户。因此，如果DR单元启动user2拥有的模式触发器的触发事件，则触发该触发器。但是，如果DR单元启动user1拥有的模式触发器的触发事件，则该触发器不会触发。</p>
                     <p><a href="plsql-triggers.html#GUID-6CF3A208-0BE7-45FF-928C-A755526933D0__CIHFGGEH">例9-19</a>在示例模式<code class="codeph">HR</code>上创建<code class="codeph">BEFORE</code>语句触发器。当作为<code class="codeph">HR</code>连接的用户尝试删除数据库对象时，数据库会在删除对象之前触发该触发器。
                     </p>
                     <div class="example" id="GUID-6CF3A208-0BE7-45FF-928C-A755526933D0__CIHFGGEH">
                        <p class="titleinexample">例9-19样本模式HR上的BEFORE语句触发器</p><pre class="oac_no_warn" dir="ltr">在DROP ON hr之前创建或替换TRIGGER drop_trigger。SCHEMA BEGIN RAISE_APPLICATION_ERROR（num =&gt; -20000，msg =&gt;'不能丢弃对象'）;结束; /</pre></div>
                     <!-- class="example" -->
                  </div>
               </div><a id="LNPLS685"></a><a id="LNPLS745"></a><a id="LNPLS99885"></a><div class="props_rev_3"><a id="GUID-AC093015-E9EA-47B1-8B0C-51A1860AB12D" name="GUID-AC093015-E9EA-47B1-8B0C-51A1860AB12D"></a><h4 id="LNPLS-GUID-AC093015-E9EA-47B1-8B0C-51A1860AB12D" class="sect4"><span class="enumeration_section">9.5.2</span>数据库触发器</h4>
                  <div>
                     <p>在<span class="bold"><code class="codeph">DATABASE</code></span>上创建<span class="bold"><code class="codeph">DATABASE</code></span> <span class="bold">触发器</span> ，并在任何数据库用户启动触发事件时触发。
                     </p>
                     <p><a href="plsql-triggers.html#GUID-AC093015-E9EA-47B1-8B0C-51A1860AB12D__CIHEBJDD">例9-20</a>显示了记录错误的触发器的基本语法。在执行失败的语句（例如登录失败）后触发此触发器。
                     </p>
                     <div class="infoboxnote" id="GUID-AC093015-E9EA-47B1-8B0C-51A1860AB12D__GUID-80377E02-44E9-45DE-A77A-58DF0473145A">
                        <p class="notep1">注意：</p>
                        <p>仅当Oracle关系数据库管理系统（RDBMS）确定触发错误触发器是安全的时，才会触发<code class="codeph">AFTER</code> <code class="codeph">SERVERERROR</code>触发器。有关<code class="codeph">AFTER</code> <code class="codeph">SERVERERROR</code>触发器的更多信息，请参见<a href="CREATE-TRIGGER-statement.html#GUID-AF9E33F1-64D1-4382-A6A4-EC33C36F237B">CREATE TRIGGER语句</a> 。
                        </p>
                     </div>
                     <p><a href="plsql-triggers.html#GUID-AC093015-E9EA-47B1-8B0C-51A1860AB12D__CIHEFABC">例9-21中</a>的触发器在用户登录数据库后运行<code class="codeph">check_user</code>过程。
                     </p>
                     <div class="example" id="GUID-AC093015-E9EA-47B1-8B0C-51A1860AB12D__CIHEBJDD">
                        <p class="titleinexample">例9-20 AFTER语句触发数据库</p><pre class="oac_no_warn" dir="ltr">SERVERERROR ON DATABASE BEGIN IF（IS_SERVERERROR（1017））之后创建TRIGGER log_errors然后为空; - （替换处理登录错误的代码）ELSE NULL; - （替换记录错误代码的代码）END IF;结束; /</pre></div>
                     <!-- class="example" -->
                     <div class="example" id="GUID-AC093015-E9EA-47B1-8B0C-51A1860AB12D__CIHEFABC">
                        <p class="titleinexample">例9-21触发监视器登录</p><pre class="oac_no_warn" dir="ltr">创建或替换TRIGGER check_user登录DATABASE BEGIN后check_user;除了RAISE_APPLICATION_ERROR之外的其他例外情况（-20000，'意外错误：'|| DBMS_Utility。Format_Error_Stack）;结束; /</pre></div>
                     <!-- class="example" -->
                  </div>
               </div><a id="LNPLS1967"></a><a id="LNPLS1915"></a><div class="props_rev_3"><a id="GUID-7B32FE4B-AB8E-48B0-A74C-599584A485A7" name="GUID-7B32FE4B-AB8E-48B0-A74C-599584A485A7"></a><h4 id="LNPLS-GUID-7B32FE4B-AB8E-48B0-A74C-599584A485A7" class="sect4"><span class="enumeration_section">9.5.3</span> INSTEAD OF CREATE触发器</h4>
                  <div>
                     <p><code class="codeph">INSTEAD</code> <code class="codeph">OF</code> <code class="codeph">CREATE</code>触发器是一个<code class="codeph">SCHEMA</code>触发器，其触发事件是<code class="codeph">CREATE</code>语句。数据库触发触发器而不是执行其触发语句。
                     </p>
                     <p><a href="plsql-triggers.html#GUID-7B32FE4B-AB8E-48B0-A74C-599584A485A7__CIHBJFDG">例9-22</a>显示了当前模式上<code class="codeph">INSTEAD</code> <code class="codeph">OF</code> <code class="codeph">CREATE</code>触发器的基本语法。当前模式的所有者在当前模式中发出<code class="codeph">CREATE</code>语句时，将触发此触发器。
                     </p>
                     <div class="example" id="GUID-7B32FE4B-AB8E-48B0-A74C-599584A485A7__CIHBJFDG">
                        <p class="titleinexample">例9-22 INSTEAD OF CREATE触发架构</p><pre class="oac_no_warn" dir="ltr">创建或替换TRAGGER，以便在模式开始时创建立即执行'创建表T（n NUMBER，m NUMBER）';结束; /</pre></div>
                     <!-- class="example" -->
                  </div>
               </div>
            </div><a id="LNPLS746"></a><a id="LNPLS99884"></a><div class="props_rev_3"><a id="GUID-E11CFB2F-064F-42EB-8390-F025564AD107" name="GUID-E11CFB2F-064F-42EB-8390-F025564AD107"></a><h3 id="LNPLS-GUID-E11CFB2F-064F-42EB-8390-F025564AD107" class="sect3"><span class="enumeration_section">9.6</span>触发器调用的子程序</h3>
               <div>
                  <p>触发器可以调用用PL / SQL，C和Java编写的子程序。<a href="plsql-triggers.html#GUID-B5E654D9-5875-40EC-AE24-E3A8CB37C9C5__CIHGJFAB">例9-4中</a>的触发器调用PL / SQL子程序。<a href="plsql-triggers.html#GUID-E11CFB2F-064F-42EB-8390-F025564AD107__CIHGEEIC">例9-23中</a>的触发器调用Java子程序。
                  </p>
                  <p>由触发器调用的子程序无法运行事务控制语句，因为子程序在触发器主体的上下文中运行。</p>
                  <p>如果触发器调用调用者权限（IR）子程序，则创建触发器的用户（而不是运行触发语句的用户）将被视为当前用户。有关IR子程序的信息，请参阅<span class="q">“ <a href="plsql-subprograms.html#GUID-41D23DE7-3C07-41CF-962B-F92B696594B5" title="如果在DR单元（定义者权限单元）中包含已连接的用户数据库链接，则必须向将运行DR单元的用户授予INHERIT REMOTE PRIVILEGES权限。">Invoker的权利和定义者权利（AUTHID属性）</a> ”</span> 。
                  </p>
                  <p>如果触发器调用远程子程序，并且在执行触发器期间发现时间戳或签名不匹配，则远程子程序不会运行并且触发器无效。</p>
                  <div class="example" id="GUID-E11CFB2F-064F-42EB-8390-F025564AD107__CIHGEEIC">
                     <p class="titleinexample">示例9-23触发器调用Java子程序</p><pre class="oac_no_warn" dir="ltr">创建或替换<span class="bold">过程Before_delete（Id IN NUMBER，Ename VARCHAR2）</span> IS <span class="bold">LANGUAGE Java</span>名称'thjvTriggers.beforeDelete（oracle.jdbc。NUMBER，oracle.jdbc。CHAR）“;创建或替换<span class="bold">TRIGGER Pre_del_trigger</span>之前删除每个行<span class="bold">调用的</span>选项卡<span class="bold">Before_delete（：OLD.Id，：OLD.Ename）</span> /</pre><p>相应的Java文件是<code class="codeph">thjvTriggers</code> 。 <code class="codeph">java</code> ：</p><pre class="oac_no_warn" dir="ltr">import java.sql。* import java.io.* import oracle.jdbc。* import oracle.oracore。* public class thjvTriggers {public static void beforeDelete（NUMBER old_id，CHAR old_name）抛出SQLException，CoreException {Connection conn = JDBCConnection.defaultConnection（）;声明stmt = conn。的createStatement（）; String sql =“insert into logtab values（”+ old_id.intValue（）+“，'”+ old_ename.toString（）+“，BEFORE DELETE'）; stmt.executeUpdate（sql）; stmt.close（）; return; }}</pre></div>
                  <!-- class="example" -->
               </div>
            </div><a id="LNPLS2007"></a><div class="props_rev_3"><a id="GUID-39111AAC-597E-4661-82A6-F3BE621F75BB" name="GUID-39111AAC-597E-4661-82A6-F3BE621F75BB"></a><h3 id="LNPLS-GUID-39111AAC-597E-4661-82A6-F3BE621F75BB" class="sect3"><span class="enumeration_section">9.7</span>触发器编译，无效和重新编译</h3>
               <div>
                  <p><code class="codeph">CREATE</code> <code class="codeph">TRIGGER</code>语句编译触发器并将其代码存储在数据库中。如果发生编译错误，仍会创建触发器，但其触发语句失败，除非在这些情况下：</p>
                  <ul style="list-style-type:disc">
                     <li>
                        <p>触发器在禁用状态下创建。</p>
                     </li>
                     <li>
                        <p>触发事件是<code class="codeph">ON</code> <code class="codeph">DATABASE</code> <code class="codeph">STARTUP</code> <code class="codeph">AFTER</code> <code class="codeph">STARTUP</code> 。</p>
                     </li>
                     <li>
                        <p>触发事件是<code class="codeph">AFTER</code> <code class="codeph">LOGON</code> <code class="codeph">ON</code> <code class="codeph">DATABASE</code>或<code class="codeph">AFTER</code> <code class="codeph">LOGON</code> <code class="codeph">ON</code> <code class="codeph">SCHEMA</code> ，有人以<code class="codeph">SYSTEM</code>身份登录。</p>
                     </li>
                  </ul>
                  <p>要查看触发器编译错误，请使用SQL * Plus或Enterprise Manager中的<code class="codeph">SHOW</code> <code class="codeph">ERRORS</code>命令，或查询静态数据字典视图<code class="codeph">*_ERRORS</code> （在<a href="../refrn/USER_ERRORS.html#REFRN26065" target="_blank"><span class="italic">Oracle数据库参考中</span></a>描述）。
                  </p>
                  <p>如果触发器未成功编译，则其异常处理程序无法运行。有关示例，请参阅<span class="q">“ <a href="plsql-triggers.html#GUID-FA7A16B6-F94D-4E4C-A326-F602FE9FE3E8__CIHEAHFI">远程异常处理</a> ”</span> 。
                  </p>
                  <p>如果触发器引用另一个对象（例如子程序或包），并且该对象被修改或删除，则触发器将变为无效。下次发生触发事件时，编译器会尝试重新验证触发器（有关详细信息，请参阅“ <a href="../adfns/schema-object-dependency.html#ADFNS99967" target="_blank"><span class="italic">Oracle数据库开发指南”</span></a> ）。
                  </p>
                  <div class="infoboxnote" id="GUID-39111AAC-597E-4661-82A6-F3BE621F75BB__GUID-1996DCD7-1A04-49F4-AB2C-E1B75C586164">
                     <p class="notep1">注意：</p>
                     <p>由于<code class="codeph">DBMS_AQ</code>包用于将消息排入队列，因此无法维护触发器和队列之间的依赖关系。
                     </p>
                  </div>
                  <p>要手动重新编译触发器，请使用<code class="codeph">ALTER</code> <code class="codeph">TRIGGER</code>语句，如<span class="q">“ <a href="ALTER-TRIGGER-statement.html#GUID-BC319647-2D94-46D1-BF69-16CDFB507725" title="ALTER TRIGGER语句启用，禁用，编译或重命名数据库触发器。">ALTER TRIGGER语句</a> ”中所述</span> 。
                  </p>
               </div>
            </div><a id="LNPLS754"></a><a id="LNPLS686"></a><a id="LNPLS687"></a><a id="LNPLS751"></a><div class="props_rev_3"><a id="GUID-FA7A16B6-F94D-4E4C-A326-F602FE9FE3E8" name="GUID-FA7A16B6-F94D-4E4C-A326-F602FE9FE3E8"></a><h3 id="LNPLS-GUID-FA7A16B6-F94D-4E4C-A326-F602FE9FE3E8" class="sect3"><span class="enumeration_section">9.8</span>触发器中的异常处理</h3>
               <div>
                  <p>在大多数情况下，如果触发器运行引发异常的语句，并且异常不由异常处理程序处理，则数据库将回滚触发器及其触发语句的效果。</p>
                  <p>在下列情况下，数据库仅回滚触发器的效果，而不回滚触发语句的效果（并在跟踪文件和警报日志中记录错误）：</p>
                  <ul style="list-style-type:disc">
                     <li>
                        <p>触发事件是要么<code class="codeph">AFTER</code> <code class="codeph">STARTUP</code> <code class="codeph">ON</code> <code class="codeph">DATABASE</code>或<code class="codeph">BEFORE</code> <code class="codeph">SHUTDOWN</code> <code class="codeph">ON</code> <code class="codeph">DATABASE</code> 。</p>
                     </li>
                     <li>
                        <p>触发事件是<code class="codeph">AFTER</code> <code class="codeph">LOGON</code> <code class="codeph">ON</code> <code class="codeph">DATABASE</code> ，用户具有<code class="codeph">ADMINISTER</code> <code class="codeph">DATABASE</code> <code class="codeph">TRIGGER</code>权限。
                        </p>
                     </li>
                     <li>
                        <p>触发事件是<code class="codeph">AFTER</code> <code class="codeph">LOGON</code> <code class="codeph">ON</code> <code class="codeph">SCHEMA</code> ，用户拥有架构或具有<code class="codeph">ALTER</code> <code class="codeph">ANY</code> <code class="codeph">TRIGGER</code>权限。
                        </p>
                     </li>
                  </ul>
                  <p>在复合DML触发器的情况下，数据库仅回滚触发语句的效果，而不回滚触发器的效果。但是，在触发器中声明的变量将被重新初始化，并且在回滚触发语句之前计算的任何值都将丢失。</p>
                  <div class="infoboxnote" id="GUID-FA7A16B6-F94D-4E4C-A326-F602FE9FE3E8__GUID-9DD48E53-06C5-41FA-9959-56DC58573B03">
                     <p class="notep1">注意：</p>
                     <p>强制执行复杂安全授权或约束的触发器通常会引发用户定义的异常，这在<span class="q">“ <a href="plsql-error-handling.html#GUID-8844A6D8-FE6F-4DFF-B449-59AB076316C1">用户定义的异常</a> ”中</span>进行了解释。
                     </p>
                  </div>
                  <div class="infoboxnotealso" id="GUID-FA7A16B6-F94D-4E4C-A326-F602FE9FE3E8__GUID-2BA0DC42-ECA8-40D8-88CC-E14DB112FBD1">
                     <p class="notep1">也可以看看：</p>
                     <p><a href="plsql-error-handling.html#GUID-0502DC1A-F0A5-4180-A912-6A5CDC855F56" title="在编译存储的PL / SQL单元时，PL / SQL编译器会为不足以导致错误并阻止编译的条件生成警告 - 例如，使用不推荐的PL / SQL功能。">PL / SQL错误处理</a> ，有关异常处理的一般信息</p>
                  </div>
                  <div class="section" id="GUID-FA7A16B6-F94D-4E4C-A326-F602FE9FE3E8__CIHEAHFI">
                     <p class="subhead2" id="GUID-FA7A16B6-F94D-4E4C-A326-F602FE9FE3E8__GUID-2C376C61-7B85-49F5-9F2A-BCF8E586CC3B">远程异常处理</p>
                  </div>
                  <!-- class="section" -->
                  <div class="section">
                     <p>只有远程数据库可用时，访问远程数据库的触发器才能执行远程异常处理。如果远程数据库在本地数据库必须编译触发器时不可用，则本地数据库无法验证访问远程数据库的语句，并且编译失败。如果无法编译触发器，则其异常处理程序无法运行。</p>
                     <p><a href="plsql-triggers.html#GUID-FA7A16B6-F94D-4E4C-A326-F602FE9FE3E8__BCFDBDJH">例9-24中</a>的触发器具有访问远程数据库的<code class="codeph">INSERT</code>语句。触发器还有一个异常处理程序。但是，如果远程数据库在本地数据库尝试编译触发器时不可用，则编译将失败，并且异常处理程序无法运行。
                     </p>
                     <p><a href="plsql-triggers.html#GUID-FA7A16B6-F94D-4E4C-A326-F602FE9FE3E8__BCFEHHDA">例9-25</a>显示了<a href="plsql-triggers.html#GUID-FA7A16B6-F94D-4E4C-A326-F602FE9FE3E8__BCFDBDJH">例9-24中</a>问题的解决方法：将远程<code class="codeph">INSERT</code>语句和异常处理程序放在存储的子程序中，并让触发器调用存储的子程序。子程序以编译形式存储在本地数据库中，并带有用于访问远程数据库的验证语句。因此，当远程<code class="codeph">INSERT</code>语句因远程数据库不可用而失败时，子程序中的异常处理程序可以处理它。
                     </p>
                  </div>
                  <!-- class="section" -->
                  <div class="example" id="GUID-FA7A16B6-F94D-4E4C-A326-F602FE9FE3E8__BCFDBDJH">
                     <p class="titleinexample">示例9-24如果远程数据库不可用，则触发器无法处理异常</p><pre class="oac_no_warn" dir="ltr">创建或替换TRIGGER employees_tr插入员工后每行开始<span class="bold">- 当远程数据库不可用时，编译失败：</span> INSERT INTO employees @ remote（employee_id，first_name，last_name，email，hire_date，job_id）VALUES（99，'Jane' ，'Doe'，'jane.doe @ example.com'，SYSDATE，'ST_MAN'）;当其他人插入emp_log（Emp_id，Log_date，New_salary，Action）VALUES（99，SYSDATE，NULL，'无法插入'）时的异常;提高;结束; /</pre></div>
                  <!-- class="example" -->
                  <div class="example" id="GUID-FA7A16B6-F94D-4E4C-A326-F602FE9FE3E8__BCFEHHDA">
                     <p class="titleinexample">示例9-25 <span><a href="plsql-triggers.html#GUID-FA7A16B6-F94D-4E4C-A326-F602FE9FE3E8__BCFDBDJH">示例9-24的</a></span>变通方法</p><pre class="oac_no_warn" dir="ltr">创建或替换过程insert_row_proc AUTHID CURRENT_USER as no_remote_db EXCEPTION; - 声明异常PRAGMA EXCEPTION_INIT（no_remote_db，-20000）; - 将错误代码分配给例外BEGIN INSERT INTO employees @ remote（employee_id，first_name，last_name，email，hire_date，job_id）VALUES（99，'Jane'，'Doe'，'jane.doe @ example.com'，SYSDATE， 'ST_MAN'）;当其他人插入emp_log（Emp_id，Log_date，New_salary，Action）VALUES（99，SYSDATE，NULL，'无法插入行）时的例外情况。“）; RAISE_APPLICATION_ERROR（-20000，'远程数据库不可用。“）;结束; /创建或更换TRIGGER employees_tr在插入员工之后<span class="bold">每次行开始</span>插入<span class="bold">插件_row_proc;</span>结束; /</pre></div>
                  <!-- class="example" -->
               </div>
            </div><a id="LNPLS2002"></a><div class="props_rev_3"><a id="GUID-78B64011-B288-4EDD-B595-2DDBB3835ACA" name="GUID-78B64011-B288-4EDD-B595-2DDBB3835ACA"></a><h3 id="LNPLS-GUID-78B64011-B288-4EDD-B595-2DDBB3835ACA" class="sect3"><span class="enumeration_section">9.9</span>触发设计指南</h3>
               <div>
                  <ul style="list-style-type:disc">
                     <li>
                        <p>使用触发器确保每当发生特定事件时，都会执行任何必要的操作（无论哪个用户或应用程序发出触发语句）。</p>
                        <p>例如，使用触发器确保每当有人更新表时，都会更新其日志文件。</p>
                     </li>
                     <li>
                        <p>不要创建复制数据库功能的触发器。</p>
                        <p>例如，如果您可以对约束执行相同操作，请不要创建拒绝无效数据的<span class="q"><a href="plsql-triggers.html#GUID-C08EA160-8FD2-4A10-9733-6F2D20C83E93__CIHCEBAE">触发器</a></span> （请参阅<span class="q">“ <a href="plsql-triggers.html#GUID-C08EA160-8FD2-4A10-9733-6F2D20C83E93__CIHCEBAE">触发器和约束如何不同</a> ”</span> ）。
                        </p>
                     </li>
                     <li>
                        <p>不要创建依赖于SQL语句处理行的顺序的触发器（可能会有所不同）。</p>
                        <p>例如，如果变量的当前值取决于行触发器正在处理的行，则不要为行触发器中的全局包变量赋值。如果触发器更新全局包变量，则在<code class="codeph">BEFORE</code>语句触发器中初始化这些变量。
                        </p>
                     </li>
                     <li>
                        <p>在将行数据写入磁盘之前，使用<code class="codeph">BEFORE</code>行触发器修改行。
                        </p>
                     </li>
                     <li>
                        <p>使用<code class="codeph">AFTER</code>行触发器获取行ID并在操作中使用它。
                        </p>
                        <p>当触发语句导致ORA-02292时，将触发<code class="codeph">AFTER</code>行触发器。
                        </p>
                        <div class="infoboxnote" id="GUID-78B64011-B288-4EDD-B595-2DDBB3835ACA__GUID-4B436E08-F9DF-4557-AA87-FDAA21DC4DE4">
                           <p class="notep1">注意：</p>
                           <p>行触发<code class="codeph">AFTER</code>比<code class="codeph">BEFORE</code>行触发更有效。使用<code class="codeph">BEFORE</code>行触发器，首先读取受影响的数据块以获取触发器，然后读取触发器语句。使用<code class="codeph">AFTER</code>行触发器时，受影响的数据块仅对触发器具有读取权限。
                           </p>
                        </div>
                     </li>
                     <li>
                        <p>如果<code class="codeph">BEFORE</code>语句触发器的触发语句是与正在运行的<code class="codeph">UPDATE</code>语句冲突的<code class="codeph">UPDATE</code>或<code class="codeph">DELETE</code>语句，则数据库对<code class="codeph">SAVEPOINT</code>执行透明<code class="codeph">ROLLBACK</code>并重新启动触发语句。在触发语句成功完成之前，数据库可以多次执行此操作。每次数据库重新启动触发语句时，触发器都会触发。对<code class="codeph">SAVEPOINT</code>的<code class="codeph">ROLLBACK</code>不会撤消对触发器引用的包变量的更改。要检测此情况，请在包中包含计数器变量。
                        </p>
                     </li>
                     <li>
                        <p>不要创建递归触发器。</p>
                        <p>例如，不要创建一个<code class="codeph">AFTER</code> <code class="codeph">UPDATE</code>触发器，该触发器在定义触发器的表上发出<code class="codeph">UPDATE</code>语句。触发器以递归方式触发，直到内存不足为止。
                        </p>
                     </li>
                     <li>
                        <p>如果创建包含访问远程数据库的语句的触发器，则将该语句的异常处理程序放在存储的子程序中，并从触发器调用子程序。</p>
                        <p>有关更多信息，请参阅<span class="q">“ <a href="plsql-triggers.html#GUID-FA7A16B6-F94D-4E4C-A326-F602FE9FE3E8__CIHEAHFI">远程异常处理</a> ”</span> 。
                        </p>
                     </li>
                     <li>
                        <p>明智地使用<code class="codeph">DATABASE</code>触发器。每次任何数据库用户启动触发事件时，它们都会触发。
                        </p>
                     </li>
                     <li>
                        <p>如果触发器运行以下语句，则语句将返回触发器的所有者，而不是更新表的用户：</p><pre class="oac_no_warn" dir="ltr">SELECT用户名FROM USER_USERS;</pre></li>
                     <li>
                        <p>只有提交的触发器触发</p>
                        <p>触发器在创建成功的<code class="codeph">CREATE</code> <code class="codeph">TRIGGER</code>语句后隐式提交。因此，以下语句无法触发它创建的触发器：</p><pre class="oac_no_warn" dir="ltr">在数据库创建后创建或替换触发器my_trigger BEGIN NULL;结束; /</pre></li>
                     <li>
                        <p>要允许在同一个表上模块化安装具有触发器的应用程序，请创建多个相同类型的触发器，而不是运行一系列操作的单个触发器。</p>
                        <p>每个触发器都会看到先前触发的触发器所做的更改。每个触发器都可以看到<code class="codeph">OLD</code>和<code class="codeph">NEW</code>值。
                        </p>
                     </li>
                  </ul>
               </div>
            </div><a id="LNPLS755"></a><div class="props_rev_3"><a id="GUID-5B3A43E2-B9E1-4015-9A6C-0BE696853F3F" name="GUID-5B3A43E2-B9E1-4015-9A6C-0BE696853F3F"></a><h3 id="LNPLS-GUID-5B3A43E2-B9E1-4015-9A6C-0BE696853F3F" class="sect3"><span class="enumeration_section">9.10</span>触发限制</h3>
               <div>
                  <p>除了适用于所有PL / SQL单元的限制（ <a href="plsql-program-limits.html#GUID-00966B4C-B9A5-47D4-94AA-54AEBCC07CE9__BABIHIJG" title="此表总结了PL / SQL编译器的限制。">参见表C-1</a> ）之外，触发器还具有以下限制：</p>
                  <ul style="list-style-type:disc">
                     <li>
                        <p><a href="plsql-triggers.html#GUID-832B47C3-9CF3-4EC8-B2CC-EF688C61685C">触发器大小限制</a></p>
                     </li>
                     <li>
                        <p><a href="plsql-triggers.html#GUID-CC076546-C00D-4CC6-A664-82CCE4F64533">触发LONG和LONG RAW数据类型限制</a></p>
                     </li>
                     <li>
                        <p><a href="plsql-triggers.html#GUID-73B70893-9E45-4C08-B327-13ECBE4BE920">变异表限制</a></p>
                     </li>
                     <li>
                        <p>只有自治触发器才能运行TCL或DDL语句。</p>
                        <p>有关自主触发器的信息，请参阅<span class="q">“ <a href="static-sql.html#GUID-DD6F0BF4-A958-4EE2-8616-C7AE08910908" title="触发器必须是自治的才能运行TCL或DDL语句。">自主触发器</a> ”</span> 。
                        </p>
                     </li>
                     <li>
                        <p>触发器无法调用运行事务控制语句的子程序，因为子程序在触发器主体的上下文中运行。</p>
                        <p>有关触发器调用的子程序的更多信息，请参阅<span class="q">“ <a href="plsql-triggers.html#GUID-E11CFB2F-064F-42EB-8390-F025564AD107">触发器调用的子程序</a> ”</span> 。
                        </p>
                     </li>
                     <li>
                        <p>触发器无法访问<code class="codeph">SERIALLY_REUSABLE</code>包。
                        </p>
                        <p>有关<code class="codeph">SERIALLY_REUSABLE</code>包的信息，请参阅<span class="q">“ <a href="plsql-packages.html#GUID-001EF960-7491-411B-A5F3-D1260A45794B" title="对于SERIALLY_REUSABLE包，工作单元是服务器调用。">SERIALLY_REUSABLE包</a> ”</span> 。
                        </p>
                     </li>
                  </ul>
                  <div class="infoboxnotealso" id="GUID-5B3A43E2-B9E1-4015-9A6C-0BE696853F3F__GUID-C6F35B1E-4D99-4D79-87B2-54A9736D4B92">
                     <p class="notep1">也可以看看：</p>
                     <p><span class="q">“ <a href="plsql-triggers.html#GUID-67299530-50F0-4D99-B212-956A7E679CDC">复合DML触发限制</a> ”</span></p>
                  </div>
               </div><a id="LNPLS756"></a><div class="props_rev_3"><a id="GUID-832B47C3-9CF3-4EC8-B2CC-EF688C61685C" name="GUID-832B47C3-9CF3-4EC8-B2CC-EF688C61685C"></a><h4 id="LNPLS-GUID-832B47C3-9CF3-4EC8-B2CC-EF688C61685C" class="sect4"><span class="enumeration_section">9.10.1</span>触发尺寸限制</h4>
                  <div>
                     <p>触发器的大小不能超过32K。</p>
                     <p>如果触发器的逻辑需要超过60行PL / SQL源文本，则将大部分源文本放在存储的子程序中，并从触发器调用子程序。有关触发器调用的子程序的信息，请参阅<span class="q">“ <a href="plsql-triggers.html#GUID-E11CFB2F-064F-42EB-8390-F025564AD107">触发器调用的子程序</a> ”</span> 。
                     </p>
                  </div>
               </div><a id="LNPLS758"></a><div class="props_rev_3"><a id="GUID-CC076546-C00D-4CC6-A664-82CCE4F64533" name="GUID-CC076546-C00D-4CC6-A664-82CCE4F64533"></a><h4 id="LNPLS-GUID-CC076546-C00D-4CC6-A664-82CCE4F64533" class="sect4"><span class="enumeration_section">9.10.2</span>触发LONG和LONG RAW数据类型限制</h4>
                  <div>
                     <div class="infoboxnote" id="GUID-CC076546-C00D-4CC6-A664-82CCE4F64533__GUID-1A96C6FE-99DC-4FC5-9ADF-A62B3E29DE4D">
                        <p class="notep1">注意：</p>
                        <p>Oracle仅支持<code class="codeph">LONG</code>和<code class="codeph">LONG</code> <code class="codeph">RAW</code>数据类型，以便与现有应用程序向后兼容。
                        </p>
                     </div>
                     <p>除了适用于所有PL / SQL单元的限制（请参阅<span class="q">“ <a href="plsql-data-types.html#GUID-89ABA12C-6096-446C-9E2C-65687A0B8DA9">LONG和LONG RAW变量</a> ”</span> ）之外，触发器还具有以下限制：</p>
                     <ul style="list-style-type:disc">
                        <li>
                           <p>触发器不能声明<code class="codeph">LONG</code>或<code class="codeph">LONG</code> <code class="codeph">RAW</code>数据类型的变量。
                           </p>
                        </li>
                        <li>
                           <p>仅当列数据可以转换为数据类型<code class="codeph">CHAR</code>或<code class="codeph">VARCHAR2</code>触发器中的SQL语句才能引用<code class="codeph">LONG</code>或<code class="codeph">LONG</code> <code class="codeph">RAW</code>列。
                           </p>
                        </li>
                        <li>
                           <p>触发器不能将相关名称<code class="codeph">NEW</code>或<code class="codeph">PARENT</code>与<code class="codeph">LONG</code>或<code class="codeph">LONG</code> <code class="codeph">RAW</code>列一起使用。
                           </p>
                        </li>
                     </ul>
                  </div>
               </div><a id="LNPLS760"></a><a id="LNPLS688"></a><a id="LNPLS689"></a><a id="LNPLS759"></a><div class="props_rev_3"><a id="GUID-73B70893-9E45-4C08-B327-13ECBE4BE920" name="GUID-73B70893-9E45-4C08-B327-13ECBE4BE920"></a><h4 id="LNPLS-GUID-73B70893-9E45-4C08-B327-13ECBE4BE920" class="sect4"><span class="enumeration_section">9.10.3</span>变异表限制</h4>
                  <div>
                     <div class="infoboxnote" id="GUID-73B70893-9E45-4C08-B327-13ECBE4BE920__GUID-382F4498-6BCB-446D-901B-877FE5C57318">
                        <p class="notep1">注意：</p>
                        <p>本主题仅适用于行级简单DML触发器。</p>
                     </div>
                     <p><span class="bold">变异表</span>是由DML语句修改的表（可能由<code class="codeph">DELETE</code> <code class="codeph">CASCADE</code>约束的效果）。（由<code class="codeph">INSTEAD</code> <code class="codeph">OF</code>触发器修改的视图不被视为变异。）
                     </p>
                     <p>变异表限制可防止触发器查询或修改触发语句正在修改的表。当行级触发器遇到变异表时，会发生ORA-04091，触发触发器和触发语句的效果，并且控制权返回给发出触发语句的用户或应用程序，如<a href="plsql-triggers.html#GUID-73B70893-9E45-4C08-B327-13ECBE4BE920__BCFHJBBE">例9-26</a>所示。
                     </p>
                     <div class="infoboxnote" id="GUID-73B70893-9E45-4C08-B327-13ECBE4BE920__GUID-F8BD55B5-693F-4421-8EC2-070A842FE6CD">
                        <p class="notep1">警告：</p>
                        <p>Oracle数据库不会对访问远程节点的触发器强制执行变异表限制，因为数据库不支持分布式数据库的不同节点上的表之间的声明性引用约束。</p>
                        <p>同样，数据库不会对通过环回数据库链接连接的同一数据库中的表强制实施变异表限制。环回数据库链接通过将Oracle Net路径定义回包含该链接的数据库，使本地表显示为远程。</p>
                     </div>
                     <p>如果必须使用触发器来更新变异表，则可以通过以下任一方式避免变异表错误：</p>
                     <ul style="list-style-type:disc">
                        <li>
                           <p>使用复合DML触发器（请参阅<span class="q">“ <a href="plsql-triggers.html#GUID-E1150933-9B5F-4AA3-9F49-C222A1618BE5">使用复合DML触发器以避免变异表错误</a> ”</span> ）。
                           </p>
                        </li>
                        <li>
                           <p>使用临时表。</p>
                           <p>例如，而不是使用一个<code class="codeph">AFTER</code>每行触发器更新变异表，使用两个触发器，一个<code class="codeph">AFTER</code>每一行触发器更新临时表和<code class="codeph">AFTER</code>与从临时表中的值更新变异表语句触发器。
                           </p>
                        </li>
                     </ul>
                     <div class="section">
                        <p class="subhead3" id="GUID-73B70893-9E45-4C08-B327-13ECBE4BE920__GUID-9E33124B-D325-4D64-929F-50EDA5F5C27E">变异表限制放松</p>
                     </div>
                     <!-- class="section" -->
                     <div class="section">
                        <p>从Oracle Database <span class="italic">8g</span>第1版开始，从父表中删除会导致<code class="codeph">BEFORE</code>和<code class="codeph">AFTER</code>触发器触发一次。因此，您可以创建查询和修改父表和子表的行级和语句级触发器。这允许大多数外键约束操作通过其后行触发器实现（除非约束是自引用的）。更新级联，更新集null，更新集默认，删除集默认，插入缺少的父项以及维护子计数都可以轻松实现 - 请参阅<span class="q">“ <a href="plsql-triggers.html#GUID-AD8188E5-546E-46EB-A000-7EB9D17C3D0C">确保参照完整性的触发器</a> ”</span> 。
                        </p>
                        <p>但是，级联需要注意多行外键更新。触发器不会错过已更改但未由另一个事务提交的行，因为外键约束保证在调用后行触发器之前不会锁定匹配的外键行。</p>
                        <p>在<a href="plsql-triggers.html#GUID-73B70893-9E45-4C08-B327-13ECBE4BE920__BCFEFDIA">例9-27中</a> ，触发语句正确更新<code class="codeph">p</code>但在触发器更新<code class="codeph">f</code>时导致问题。首先，在触发语句的变化（1）至（2） <code class="codeph">p</code> ，和触发更新（1）至（2）中<code class="codeph">f</code> ，留下的在值（2）两行<code class="codeph">f</code> 。接下来，触发语句在<code class="codeph">p</code>更新（2）到（3），并且触发器在<code class="codeph">f</code>更新值（2）到（3）的两行。最后，语句在<code class="codeph">p</code>更新（3）到（4），并且触发器更新f中从（3）到（4）的所有三行。<code class="codeph">p</code>和<code class="codeph">f</code>的数据项之间的关系丢失。
                        </p>
                        <p>要避免此问题，请禁止对<code class="codeph">p</code>多行更新以更改主键并重用现有主键值，或者跟踪对外键值的更新并修改触发器以确保不会更新任何行两次。
                        </p>
                     </div>
                     <!-- class="section" -->
                     <div class="example" id="GUID-73B70893-9E45-4C08-B327-13ECBE4BE920__BCFHJBBE">
                        <p class="titleinexample">例9-26触发器导致变异表错误</p><pre class="oac_no_warn" dir="ltr">- 创建日志表DROP TABLE日志; CREATE TABLE log（emp_id NUMBER（6），l_name VARCHAR2（25），f_name VARCHAR2（20））; - 创建更新日志的触发器，然后读取员工创建或替换TRIGGER log_deletions删除员工后每个行拒绝n INTEGER; BEGIN INSERT INTO log VALUES（：OLD.employee_id，：OLD.last_name，：OLD.first_name）; SELECT COUNT（*）INTO n FROM employees; DBMS_OUTPUT.PUT_LINE（'现在有'|| n ||'员工。“）;结束; /  - 发出触发语句：DELETE FROM employees WHERE employee_id = 197;</pre><p>结果：</p><pre class="oac_no_warn" dir="ltr">DELETE FROM employees WHERE employee_id = 197 * ERROR在第1行： <span class="bold">ORA-04091：表HR.EMPLOYEES正在变异，触发器/函数可能看不到它</span> ORA-06512：在“HR.LOG_DELETIONS”，第10行ORA-04088：错误期间执行触发器'HR.LOG_DELETIONS'</pre><p>显示触发器的效果已回滚：</p><pre class="oac_no_warn" dir="ltr">SELECT count（*）FROM log;</pre><p>结果：</p><pre class="oac_no_warn" dir="ltr">COUNT（*）---------- 0选择1行。
</pre><p>显示触发语句的效果已回滚：</p><pre class="oac_no_warn" dir="ltr">SELECT employee_id，last_name FROM employees WHERE employee_id = 197;</pre><p>结果：</p><pre class="oac_no_warn" dir="ltr">EMPLOYEE_ID LAST_NAME ----------- ------------------------- 197菲尼1排选中。
</pre></div>
                     <!-- class="example" -->
                     <div class="example" id="GUID-73B70893-9E45-4C08-B327-13ECBE4BE920__BCFEFDIA">
                        <p class="titleinexample">示例9-27更新级联</p><pre class="oac_no_warn" dir="ltr">DROP TABLE p; CREATE TABLE p（p1 NUMBER CONSTRAINT pk_p_p1 PRIMARY KEY）;插入p VALUES（1）;插入p VALUES（2）;插入p VALUES（3）; DROP TABLE f; CREATE TABLE f（f1 NUMBER CONSTRAINT fk_f_f1 REFERENCES p）;插入价值观（1）;插入价值观（2）;插入价值观（3）;创建TRIGGER pt更新后p为每行开始更新f SET f1 =：NEW.p1 WHERE f1 =：OLD.p1;结束; /</pre><p>查询：</p><pre class="oac_no_warn" dir="ltr">SELECT * FROM p ORDER BY p1;</pre><p>结果：</p><pre class="oac_no_warn" dir="ltr">P1 ---------- 1 2 3</pre><p>查询：</p><pre class="oac_no_warn" dir="ltr">SELECT * FROM f ORDER BY f1;</pre><p>结果：</p><pre class="oac_no_warn" dir="ltr">F1 ---------- 1 2 3</pre><p>发出触发声明：</p><pre class="oac_no_warn" dir="ltr">更新p SET p1 = p1 + 1;</pre><p>查询：</p><pre class="oac_no_warn" dir="ltr">SELECT * FROM p ORDER BY p1;</pre><p>结果：</p><pre class="oac_no_warn" dir="ltr">P1 ---------- 2 3 4</pre><p>查询：</p><pre class="oac_no_warn" dir="ltr">SELECT * FROM f ORDER BY f1;</pre><p>结果：</p><pre class="oac_no_warn" dir="ltr">F1 ---------- 4 4 4</pre></div>
                     <!-- class="example" -->
                  </div>
               </div>
            </div><a id="LNPLS99985"></a><div class="props_rev_3"><a id="GUID-2585112C-C48F-40ED-B825-21DF975EA126" name="GUID-2585112C-C48F-40ED-B825-21DF975EA126"></a><h3 id="LNPLS-GUID-2585112C-C48F-40ED-B825-21DF975EA126" class="sect3"><span class="enumeration_section">9.11</span>触发器触发的顺序</h3>
               <div>
                  <p>如果为同一个表中的同一语句定义了两个或多个<span class="italic">具有不同时间点的</span>触发器，则它们按以下顺序触发：</p>
                  <ol>
                     <li>
                        <p>所有<code class="codeph">BEFORE</code> <code class="codeph">STATEMENT</code>触发器</p>
                     </li>
                     <li>
                        <p>所有<code class="codeph">BEFORE</code> <code class="codeph">EACH</code> <code class="codeph">ROW</code>触发器</p>
                     </li>
                     <li>
                        <p>所有<code class="codeph">AFTER</code> <code class="codeph">EACH</code> <code class="codeph">ROW</code>触发</p>
                     </li>
                     <li>
                        <p>所有<code class="codeph">AFTER</code> <code class="codeph">STATEMENT</code>触发</p>
                     </li>
                  </ol>
                  <p>如果可行，请使用单个复合触发器替换具有不同时间点的单个触发器集，该触发器按照您希望的顺序显式编码操作。有关复合触发器的信息，请参阅<span class="q">“ <a href="plsql-triggers.html#GUID-8A0DA171-BE6A-4798-A1A4-677B88EA16A0">复合DML触发器</a> ”</span> 。
                  </p>
                  <p>如果要创建<span class="italic">具有相同时间点的</span>两个或多个触发器，并且它们触发的顺序很重要，则可以使用<code class="codeph">FOLLOWS</code>和<code class="codeph">PRECEDES</code>子句控制其触发顺序（请参阅<span class="q">“ <a href="CREATE-TRIGGER-statement.html#GUID-AF9E33F1-64D1-4382-A6A4-EC33C36F237B__CIHDEBEI">FOLLOWS | PRECEDES</a> ”</span> ）。
                  </p>
                  <p>如果在表上创建了多个复合触发器，则：</p>
                  <ul style="list-style-type:disc">
                     <li>
                        <p>所有<code class="codeph">BEFORE</code> <code class="codeph">STATEMENT</code>部分在运行<code class="codeph">BEFORE</code> <code class="codeph">STATEMENT</code>计时点， <code class="codeph">BEFORE</code> <code class="codeph">EACH</code> <code class="codeph">ROW</code>部分在运行<code class="codeph">BEFORE</code> <code class="codeph">EACH</code> <code class="codeph">ROW</code>计时点，等等。
                        </p>
                        <p>如果使用<code class="codeph">FOLLOWS</code>子句指定了触发器执行顺序，则<code class="codeph">FOLLOWS</code>子句确定复合触发器部分的执行顺序。如果为某些但不是所有触发器指定了<code class="codeph">FOLLOWS</code> ，那么只有那些使用<code class="codeph">FOLLOWS</code>子句相关的触发器的执行顺序才能保证。
                        </p>
                     </li>
                     <li>
                        <p>所有<code class="codeph">AFTER</code> <code class="codeph">STATEMENT</code>部分在运行<code class="codeph">AFTER</code> <code class="codeph">STATEMENT</code>计时点， <code class="codeph">AFTER</code> <code class="codeph">EACH</code> <code class="codeph">ROW</code>部分在运行<code class="codeph">AFTER</code> <code class="codeph">EACH</code> <code class="codeph">ROW</code>计时点，等等。
                        </p>
                        <p>如果使用<code class="codeph">PRECEDES</code>子句指定了触发器执行顺序，则<code class="codeph">PRECEDES</code>子句确定复合触发器部分的执行顺序。如果为某些但不是所有触发器指定了<code class="codeph">PRECEDES</code> ，那么只有那些使用<code class="codeph">PRECEDES</code>子句相关的触发器的执行顺序才能保证。
                        </p>
                        <div class="infoboxnote" id="GUID-2585112C-C48F-40ED-B825-21DF975EA126__GUID-94E69BA4-1FCC-476D-ABF5-AB7BC4452811">
                           <p class="notep1">注意：</p>
                           <p><code class="codeph">PRECEDES</code>仅适用于<a href="../adfns/editions.html#ADFNS99909" target="_blank"><span class="italic">Oracle数据库开发指南</span></a>中描述的反向交叉触发器。
                           </p>
                        </div>
                     </li>
                  </ul>
                  <p>复合触发器的触发可以与简单触发器的触发交错。</p>
                  <p>当一个触发器导致另一个触发器触发时，触发器被称为<span class="bold">级联</span>触发器。该数据库允许最多32个触发器同时级联。要限制触发器级联的数量，请使用初始化参数<code class="codeph">OPEN_CURSORS</code> （在<a href="../refrn/OPEN_CURSORS.html#REFRN10137" target="_blank"><span class="italic">Oracle数据库参考中</span></a>描述），因为每次触发器触发时都会打开游标。
                  </p>
               </div>
            </div><a id="LNPLS2011"></a><div class="props_rev_3"><a id="GUID-6CD799AB-FAEF-493A-8A58-2394E400072C" name="GUID-6CD799AB-FAEF-493A-8A58-2394E400072C"></a><h3 id="LNPLS-GUID-6CD799AB-FAEF-493A-8A58-2394E400072C" class="sect3"><span class="enumeration_section">9.12</span>触发启用和禁用</h3>
               <div>
                  <p>默认情况下， <code class="codeph">CREATE</code> <code class="codeph">TRIGGER</code>语句在启用状态下创建触发器。要在禁用状态下创建触发器，请指定<code class="codeph">DISABLE</code> 。在禁用状态下创建触发器可以确保在启用它之前编译没有错误。
                  </p>
                  <div class="section">
                     <p>暂时禁用触发器的一些原因是：</p>
                  </div>
                  <!-- class="section" -->
                  <div class="section">
                     <ul style="list-style-type:disc">
                        <li>
                           <p>触发器指的是不可用的对象。</p>
                        </li>
                        <li>
                           <p>您必须执行大量数据加载，并且希望它在不触发触发器的情况下快速继续。</p>
                        </li>
                        <li>
                           <p>您正在重新加载数据。</p>
                        </li>
                     </ul>
                     <p>要启用或禁用单个触发器，请使用以下语句：</p><pre class="oac_no_warn" dir="ltr">ALTER TRIGGER [ <span class="italic">schema</span> 。] <span class="italic">trigger_name</span> {ENABLE | DISABLE};</pre><p>要在特定表上创建的所有版本中启用或禁用所有触发器，请使用以下语句：</p><pre class="oac_no_warn" dir="ltr">ALTER TABLE <span class="italic">table_name</span> {ENABLE |禁止所有触发器;</pre><p>在上述两个语句中， <span class="italic"><code class="codeph">schema</code></span>是包含触发器的模式的名称，默认值是您的模式。
                     </p>
                     <div class="infoboxnotealso" id="GUID-6CD799AB-FAEF-493A-8A58-2394E400072C__GUID-C9B48185-B119-407C-B731-212D2B474767">
                        <p class="notep1">也可以看看：</p>
                        <ul style="list-style-type:disc">
                           <li>
                              <p><span class="q">“ <a href="ALTER-TRIGGER-statement.html#GUID-BC319647-2D94-46D1-BF69-16CDFB507725" title="ALTER TRIGGER语句启用，禁用，编译或重命名数据库触发器。">ALTER TRIGGER声明</a> ”</span>有关更多信息， <code class="codeph">ALTER</code> <code class="codeph">TRIGGER</code>语句</p>
                           </li>
                           <li>
                              <p>有关<code class="codeph">ALTER</code> <code class="codeph">TABLE</code>语句的更多信息，请<a href="../sqlrf/ALTER-TABLE.html#SQLRF01001" target="_blank"><span class="italic">参见Oracle数据库SQL语言参考</span></a></p>
                           </li>
                        </ul>
                     </div>
                  </div>
                  <!-- class="section" -->
               </div>
            </div><a id="LNPLS2008"></a><div class="props_rev_3"><a id="GUID-4F200DEC-9B4B-4DCC-A86D-1DB2E281A43C" name="GUID-4F200DEC-9B4B-4DCC-A86D-1DB2E281A43C"></a><h3 id="LNPLS-GUID-4F200DEC-9B4B-4DCC-A86D-1DB2E281A43C" class="sect3"><span class="enumeration_section">9.13</span>触发更改和调试</h3>
               <div>
                  <div class="section">
                     <p>要更改触发器，您必须替换或重新创建它。（ <code class="codeph">ALTER</code> <code class="codeph">TRIGGER</code>语句仅启用，禁用，编译或重命名触发器。）
                     </p>
                     <p>要替换触发器，请将<code class="codeph">CREATE</code> <code class="codeph">TRIGGER</code>语句与<code class="codeph">OR</code> <code class="codeph">REPLACE</code>子句一起使用。
                     </p>
                     <p>要重新创建触发器，首先使用<code class="codeph">DROP</code> <code class="codeph">TRIGGER</code>语句将其<code class="codeph">DROP</code> ，然后使用<code class="codeph">CREATE</code> <code class="codeph">TRIGGER</code>语句再次创建它。
                     </p>
                     <p>要调试触发器，可以使用可用于存储子程序的工具。有关这些功能的信息，请参阅“ <a href="../adfns/coding-subprograms-and-packages.html#ADFNS99873" target="_blank"><span class="italic">Oracle数据库开发指南”</span></a> 。
                     </p>
                     <div class="infoboxnotealso" id="GUID-4F200DEC-9B4B-4DCC-A86D-1DB2E281A43C__GUID-E5F0E0F1-3B27-464E-A121-3C27271D5DB4">
                        <p class="notep1">也可以看看：</p>
                        <ul style="list-style-type:disc">
                           <li>
                              <p>有关<code class="codeph">CREATE</code> <code class="codeph">TRIGGER</code>语句的更多信息，请<span class="q"><a href="CREATE-TRIGGER-statement.html#GUID-AF9E33F1-64D1-4382-A6A4-EC33C36F237B">参见</a> “ <a href="CREATE-TRIGGER-statement.html#GUID-AF9E33F1-64D1-4382-A6A4-EC33C36F237B">CREATE TRIGGER语句</a> ”</span></p>
                           </li>
                           <li>
                              <p><span class="q">“ <a href="DROP-TRIGGER-statement.html#GUID-C664FDA9-656B-49D4-A86D-D08B615137E9" title="DROP TRIGGER语句从数据库中删除数据库触发器。">DROP TRIGGER语句</a> ”</span>有关更多信息， <code class="codeph">DROP</code> <code class="codeph">TRIGGER</code>声明</p>
                           </li>
                           <li>
                              <p><span class="q">“ <a href="ALTER-TRIGGER-statement.html#GUID-BC319647-2D94-46D1-BF69-16CDFB507725" title="ALTER TRIGGER语句启用，禁用，编译或重命名数据库触发器。">ALTER TRIGGER声明</a> ”</span>有关更多信息， <code class="codeph">ALTER</code> <code class="codeph">TRIGGER</code>语句</p>
                           </li>
                        </ul>
                     </div>
                  </div>
                  <!-- class="section" -->
               </div>
            </div><a id="LNPLS727"></a><div class="props_rev_3"><a id="GUID-F1103CD4-A84F-4440-9250-872212BDC5A9" name="GUID-F1103CD4-A84F-4440-9250-872212BDC5A9"></a><h3 id="LNPLS-GUID-F1103CD4-A84F-4440-9250-872212BDC5A9" class="sect3"><span class="enumeration_section">9.14</span>触发器和Oracle数据库数据传输实用程序</h3>
               <div>
                  <p>将数据传输到数据库的Oracle数据库实用程序（可能触发触发器）包括：</p>
                  <ul style="list-style-type:disc">
                     <li>
                        <p><span class="bold">SQL * Loader（</span> <span class="bold"><code class="codeph">sqlldr</code></span> <span class="bold">）</span></p>
                        <p>SQL * Loader将外部文件中的数据加载到Oracle数据库的表中。</p>
                        <p>在SQL * Loader常规加载期间， <code class="codeph">INSERT</code>触发fire。
                        </p>
                        <p>在SQL * Loader直接加载之前，将禁用触发器。</p>
                        <div class="infoboxnotealso" id="GUID-F1103CD4-A84F-4440-9250-872212BDC5A9__GUID-BE85A91A-D8DB-430E-88D1-00AEE5CB3AE2">
                           <p class="notep1">也可以看看：</p>
                           <p>有关SQL * Loader的更多信息，请参见<a href="../sutil/oracle-sql-loader-concepts.html#SUTIL003" target="_blank"><span class="italic">Oracle数据库实用</span></a>程序</p>
                        </div>
                     </li>
                     <li>
                        <p><span class="bold">数据泵导入（</span> <span class="bold"><code class="codeph">impdp</code></span> <span class="bold">）</span></p>
                        <p>数据泵导入（ <code class="codeph">impdp</code> ）读取由Data Pump Export（ <code class="codeph">expdp</code> ）创建的导出转储文件集，并将其写入Oracle数据库。
                        </p>
                        <p>如果目标数据库上不存在要导入的表，或者指定了<code class="codeph">TABLE_EXISTS_ACTION=REPLACE</code> ，则<code class="codeph">impdp</code>会在创建任何触发器之前创建并加载表，因此不会触发任何触发器。
                        </p>
                        <p>如果目标数据库上存在要导入的表，并且您指定了<code class="codeph">TABLE_EXISTS_ACTION=APPEND</code>或<code class="codeph">TABLE_EXISTS_ACTION=TRUNCATE</code> ，则<code class="codeph">impdp</code>会将行加载到现有表中，并在表上创建<code class="codeph">INSERT</code>触发器。
                        </p>
                        <div class="infoboxnotealso" id="GUID-F1103CD4-A84F-4440-9250-872212BDC5A9__GUID-EEC87C21-23F0-4DD9-B359-FBBAE7162691">
                           <p class="notep1">也可以看看：</p>
                           <p>有关数据泵导入的详细信息，请参见<a href="../sutil/datapump-import-utility.html#SUTIL300" target="_blank"><span class="italic">Oracle数据库实用程序</span></a></p>
                        </div>
                     </li>
                     <li>
                        <p><span class="bold">原始进口（</span> <span class="bold"><code class="codeph">imp</code></span> <span class="bold">）</span></p>
                        <p>原始导入（原始导入实用程序， <code class="codeph">imp</code> ）从原始导出（原始导出实用程序， <code class="codeph">exp</code> ）创建的转储文件中读取对象定义和表数据，并将它们写入目标数据库。
                        </p>
                        <div class="infoboxnote" id="GUID-F1103CD4-A84F-4440-9250-872212BDC5A9__GUID-9F29E91E-1349-478C-834D-D511957064BA">
                           <p class="notep1">注意：</p>
                           <p>要导入原始导出创建的文件，您必须使用原始导入。在所有其他情况下，Oracle建议您使用数据泵导入而不是原始导入。</p>
                        </div>
                        <p>如果目标数据库上不存在要导入的表，则<code class="codeph">imp</code>会在创建任何触发器之前创建并加载表，因此不会触发任何触发器。
                        </p>
                        <p>如果目标数据库上存在要导入的表，则Import <code class="codeph">IGNORE</code>参数确定在导入操作期间是否触发触发器。<code class="codeph">IGNORE</code>参数指定是否忽略对象创建错误，从而导致以下行为：</p>
                        <ul style="list-style-type:disc">
                           <li>
                              <p>如果<code class="codeph">IGNORE=n</code> （默认值），则<code class="codeph">imp</code>不会更改表，也不会触发触发器。
                              </p>
                           </li>
                           <li>
                              <p>如果<code class="codeph">IGNORE=y</code> ，则<code class="codeph">imp</code>将行加载到现有表中，并在表上创建<code class="codeph">INSERT</code>触发器。
                              </p>
                           </li>
                        </ul>
                        <div class="infoboxnotealso" id="GUID-F1103CD4-A84F-4440-9250-872212BDC5A9__GUID-09F7824E-26A9-49EB-A24F-D238A57B2E11">
                           <p class="notep1">也可以看看：</p>
                           <ul style="list-style-type:disc">
                              <li>
                                 <p>有关原始Import实用<a href="../sutil/oracle-original-import-utility.html#SUTIL001" target="_blank"><span class="italic">程序</span></a>的详细信息，请<a href="../sutil/oracle-original-import-utility.html#SUTIL001" target="_blank"><span class="italic">参见Oracle数据库实用</span></a>程序</p>
                              </li>
                              <li>
                                 <p>有关原始Export实用<a href="../sutil/oracle-original-export-utility.html#SUTIL3634" target="_blank"><span class="italic">程序</span></a>的详细信息，请<a href="../sutil/oracle-original-export-utility.html#SUTIL3634" target="_blank"><span class="italic">参见Oracle数据库实用</span></a>程序</p>
                              </li>
                              <li>
                                 <p>有关<code class="codeph">IGNORE</code>更多信息，请<code class="codeph">IGNORE</code> <a href="../sutil/oracle-original-import-utility.html#SUTIL1719" target="_blank"><span class="italic">Oracle数据库实用程序</span></a></p>
                              </li>
                           </ul>
                        </div>
                     </li>
                  </ul>
               </div>
            </div><a id="LNPLS790"></a><a id="LNPLS690"></a><a id="LNPLS2014"></a><div class="props_rev_3"><a id="GUID-2951D8A6-6C80-428F-840D-13A76A97E365" name="GUID-2951D8A6-6C80-428F-840D-13A76A97E365"></a><h3 id="LNPLS-GUID-2951D8A6-6C80-428F-840D-13A76A97E365" class="sect3"><span class="enumeration_section">9.15</span>发布事件的触发器</h3>
               <div>
                  <p>要使用触发器发布事件，请创建一个触发器：</p>
                  <ul style="list-style-type:disc">
                     <li>
                        <p>将事件作为触发事件</p>
                     </li>
                     <li>
                        <p>在<code class="codeph">DBMS_AQ</code>包中调用相应的子程序，该包提供Oracle Advanced Queuing（AQ）的接口</p>
                        <p>有关<code class="codeph">DBMS_AQ</code>程序包的信息，请参阅<a href="../arpls/DBMS_AQ.html#ARPLS004" target="_blank"><span class="italic">Oracle Database PL / SQL程序包和类型参考</span></a> 。
                        </p>
                        <p>有关AQ的信息，请参见“ <a href="../adque/jms-publish-subscribe.html#ADQUE1400" target="_blank"><span class="italic">Oracle数据库高级队列用户指南”</span></a> 。
                        </p>
                     </li>
                  </ul>
                  <p>通过启用和禁用此类触发器，您可以打开和关闭事件通知。有关启用和禁用触发器的信息，请参阅<span class="q">“ <a href="plsql-triggers.html#GUID-6CD799AB-FAEF-493A-8A58-2394E400072C" title="默认情况下，CREATE TRIGGER语句在启用状态下创建触发器。要在禁用状态下创建触发器，请指定DISABLE。在禁用状态下创建触发器可以确保在启用它之前编译没有错误。">触发器启用和禁用</a> ”</span> 。
                  </p>
                  <div class="section">
                     <p class="subhead2" id="GUID-2951D8A6-6C80-428F-840D-13A76A97E365__GUID-5008DFCA-011E-4063-83A7-67E5A7EE56F6">触发器如何发布事件</p>
                  </div>
                  <!-- class="section" -->
                  <div class="section">
                     <p>当数据库检测到事件时，它会触发在该事件上定义的所有已启用触发器，但以下情况除外：</p>
                     <ul style="list-style-type:disc">
                        <li>
                           <p>任何触发器都是触发事件的目标。</p>
                           <p>例如，所有<code class="codeph">DROP</code>事件的触发器在被丢弃时不会触发。
                           </p>
                        </li>
                        <li>
                           <p>在与触发事件相同的事务中修改但未提交的任何触发器。</p>
                           <p>例如，如果系统触发器中的递归DDL语句修改了另一个触发器，则同一事务中的事件无法触发修改后的触发器。</p>
                        </li>
                     </ul>
                     <p>当触发器触发并调用AQ时，AQ会发布事件并将触发器传递给发布上下文和指定的属性。触发器可以通过调用事件属性函数来访问属性。</p>
                     <p>触发器可以为AQ指定的属性（通过将它们作为<code class="codeph">IN</code>参数传递给AQ）然后使用事件属性函数进行访问取决于触发事件，该事件是数据库事件或客户端事件。
                     </p>
                     <div class="infoboxnote" id="GUID-2951D8A6-6C80-428F-840D-13A76A97E365__GUID-ABEBA277-DA06-404E-8622-95388B464152">
                        <p class="notep1">注意：</p>
                        <ul style="list-style-type:disc">
                           <li>
                              <p>触发器始终表现得像定义权限（DR）单元。事件的触发器操作作为操作的定义者（作为标注中包或函数的定义者，或作为队列中触发器的所有者）运行。由于触发器的所有者必须对基础队列，程序包或子程序具有<code class="codeph">EXECUTE</code>特权，因此此操作是一致的。有关DR单位的信息，请参阅<span class="q">“ <a href="plsql-subprograms.html#GUID-41D23DE7-3C07-41CF-962B-F92B696594B5" title="如果在DR单元（定义者权限单元）中包含已连接的用户数据库链接，则必须向将运行DR单元的用户授予INHERIT REMOTE PRIVILEGES权限。">Invoker的权利和定义者权利（AUTHID属性）</a> ”</span> 。
                              </p>
                           </li>
                           <li>
                              <p>数据库忽略所有事件的回调函数的返回状态。例如，数据库对<code class="codeph">SHUTDOWN</code>事件的返回状态不执行任何操作。
                              </p>
                           </li>
                        </ul>
                     </div>
                  </div>
                  <!-- class="section" -->
                  <div class="section">
                     <p class="subhead2" id="GUID-2951D8A6-6C80-428F-840D-13A76A97E365__GUID-288DD48A-5D26-4555-8116-F05BB4C10B07">话题</p>
                  </div>
                  <!-- class="section" -->
                  <div class="section">
                     <ul style="list-style-type:disc">
                        <li>
                           <p><a href="plsql-triggers.html#GUID-266DBF6D-AA74-490C-ADE5-962C10708C2D">事件属性函数</a></p>
                        </li>
                        <li>
                           <p><a href="plsql-triggers.html#GUID-5DEA2CE5-D61C-4E27-A36E-73348D9F619B">数据库事件触发器的事件属性函数</a></p>
                        </li>
                        <li>
                           <p><a href="plsql-triggers.html#GUID-F6473AD0-75D2-4E36-8B15-F93F0B5A8B79">客户端事件触发器的事件属性函数</a></p>
                        </li>
                     </ul>
                  </div>
                  <!-- class="section" -->
               </div><a id="LNPLS795"></a><a id="LNPLS794"></a><div class="props_rev_3"><a id="GUID-266DBF6D-AA74-490C-ADE5-962C10708C2D" name="GUID-266DBF6D-AA74-490C-ADE5-962C10708C2D"></a><h4 id="LNPLS-GUID-266DBF6D-AA74-490C-ADE5-962C10708C2D" class="sect4"><span class="enumeration_section">9.15.1</span>事件属性函数</h4>
                  <div>
                     <p>通过调用<a href="plsql-triggers.html#GUID-266DBF6D-AA74-490C-ADE5-962C10708C2D__CHDCFDJG" title="此表汇总了系统定义的事件属性。">表9-5中的</a>系统定义的事件属性函数，触发器可以检索触发事件的某些属性。并非所有触发器都可以调用所有事件属性函数 - 有关详细信息，请参阅<span class="q">“ <a href="plsql-triggers.html#GUID-5DEA2CE5-D61C-4E27-A36E-73348D9F619B">数据库事件触发器的</a></span> <span class="q"><a href="plsql-triggers.html#GUID-F6473AD0-75D2-4E36-8B15-F93F0B5A8B79">事件属性函数</a></span> <span class="q">”</span>和<span class="q">“ <a href="plsql-triggers.html#GUID-F6473AD0-75D2-4E36-8B15-F93F0B5A8B79">客户端事件触发器的事件属性函数</a> ”</span> 。
                     </p>
                     <div class="infoboxnote" id="GUID-266DBF6D-AA74-490C-ADE5-962C10708C2D__GUID-41DD780F-A0CE-4E83-8020-F38D20246EB1">
                        <p class="notep1">注意：</p>
                        <ul style="list-style-type:disc">
                           <li>
                              <p>在早期版本中，您必须通过<code class="codeph">SYS</code>包访问这些功能。现在，Oracle建议使用它们的公共同义词（ <a href="plsql-triggers.html#GUID-266DBF6D-AA74-490C-ADE5-962C10708C2D__CHDCFDJG" title="此表汇总了系统定义的事件属性。">表9-5</a>第一列中以<code class="codeph">ora_</code>开头的名称）访问它们。
                              </p>
                           </li>
                           <li>
                              <p>函数参数<code class="codeph">ora_name_list_t</code>在包<code class="codeph">DBMS_STANDARD</code>定义为：</p><pre class="oac_no_warn" dir="ltr">TYPE ora_name_list_t是VARCHAR2的表（2 *（ORA_MAX_NAME_LEN + 2）+1）;</pre></li>
                        </ul>
                     </div>
                     <div class="tblformalwide" id="GUID-266DBF6D-AA74-490C-ADE5-962C10708C2D__CHDCFDJG">
                        <p class="titleintable">表9-5系统定义的事件属性</p>
                        <table cellpadding="4" cellspacing="0" class="FormalWide" title="系统定义的事件属性" width="100%" border="1" summary="This table summarizes system-defined event attributes." frame="hsides" rules="rows">
                           <thead>
                              <tr align="left" valign="top">
                                 <th align="left" valign="bottom" width="32%" id="d67636e8038">属性</th>
                                 <th align="left" valign="bottom" width="21%" id="d67636e8041">返回类型和值</th>
                                 <th align="left" valign="bottom" width="47%" id="d67636e8044">例</th>
                              </tr>
                           </thead>
                           <tbody>
                              <tr align="left" valign="top">
                                 <td align="left" valign="top" width="32%" id="d67636e8049" headers="d67636e8038 "><pre class="oac_no_warn" dir="ltr">ora_client_ip_address</pre></td>
                                 <td align="left" valign="top" width="21%" headers="d67636e8049 d67636e8041 ">
                                    <p><code class="codeph">VARCHAR2</code> ：当底层协议为TCP / IP时， <code class="codeph">LOGON</code>事件中客户端的IP地址</p>
                                 </td>
                                 <td align="left" valign="top" width="47%" headers="d67636e8049 d67636e8044 "><pre class="oac_no_warn" dir="ltr">DECLARE v_addr VARCHAR2（11）; BEGIN IF（ora_sysevent ='LOGON'）那么v_addr：= <span class="bold">ora_client_ip_address</span> ;万一;结束; /</pre></td>
                              </tr>
                              <tr align="left" valign="top">
                                 <td align="left" valign="top" width="32%" id="d67636e8067" headers="d67636e8038 "><pre class="oac_no_warn" dir="ltr">ora_database_name</pre></td>
                                 <td align="left" valign="top" width="21%" headers="d67636e8067 d67636e8041 ">
                                    <p><code class="codeph">VARCHAR2(50)</code> ：数据库名称</p>
                                 </td>
                                 <td align="left" valign="top" width="47%" headers="d67636e8067 d67636e8044 "><pre class="oac_no_warn" dir="ltr">DECLARE v_db_name VARCHAR2（50）; BEGIN v_db_name：= <span class="bold">ora_database_name</span> ;结束; /</pre></td>
                              </tr>
                              <tr align="left" valign="top">
                                 <td align="left" valign="top" width="32%" id="d67636e8082" headers="d67636e8038 "><pre class="oac_no_warn" dir="ltr">ora_des_encrypted_password</pre></td>
                                 <td align="left" valign="top" width="21%" headers="d67636e8082 d67636e8041 ">
                                    <p><code class="codeph">VARCHAR2</code> ：正在创建或更改的用户的DES加密密码</p>
                                 </td>
                                 <td align="left" valign="top" width="47%" headers="d67636e8082 d67636e8044 "><pre class="oac_no_warn" dir="ltr">IF（ora_dict_obj_type ='USER'）然后插入event_table VALUES（ <span class="bold">ora_des_encrypted_password</span> ）;万一;</pre></td>
                              </tr>
                              <tr align="left" valign="top">
                                 <td align="left" valign="top" width="32%" id="d67636e8097" headers="d67636e8038 "><pre class="oac_no_warn" dir="ltr">ora_dict_obj_name</pre></td>
                                 <td align="left" valign="top" width="21%" headers="d67636e8097 d67636e8041 ">
                                    <p><code class="codeph">VARCHAR2(128)</code> ：发生DDL操作的字典对象的名称</p>
                                 </td>
                                 <td align="left" valign="top" width="47%" headers="d67636e8097 d67636e8044 "><pre class="oac_no_warn" dir="ltr">INSERT INTO event_table VALUES（'Changed object is'|| <span class="bold">ora_dict_obj_name</span> ）;</pre></td>
                              </tr>
                              <tr align="left" valign="top">
                                 <td align="left" valign="top" width="32%" id="d67636e8112" headers="d67636e8038 "><pre class="oac_no_warn" dir="ltr">ora_dict_obj_name_list（name_list OUT ora_name_list_t）</pre></td>
                                 <td align="left" valign="top" width="21%" headers="d67636e8112 d67636e8041 ">
                                    <p><code class="codeph">PLS_INTEGER</code> ：事件中修改的对象名称数</p>
                                    <p><code class="codeph">OUT</code>参数：在事件中修改的对象名称列表</p>
                                 </td>
                                 <td align="left" valign="top" width="47%" headers="d67636e8112 d67636e8044 "><pre class="oac_no_warn" dir="ltr">DECLARE name_list ora_name_list_t; number_modified PLS_INTEGER; BEGIN IF（ora_sysevent ='ASSOCIATE STATISTICS'）然后number_modified：= <span class="bold">ora_dict_obj_name_list（name_list）</span> ;万一;结束;</pre></td>
                              </tr>
                              <tr align="left" valign="top">
                                 <td align="left" valign="top" width="32%" id="d67636e8131" headers="d67636e8038 "><pre class="oac_no_warn" dir="ltr">ora_dict_obj_owner</pre></td>
                                 <td align="left" valign="top" width="21%" headers="d67636e8131 d67636e8041 ">
                                    <p><code class="codeph">VARCHAR2(128)</code> ：发生DDL操作的字典对象的所有者</p>
                                 </td>
                                 <td align="left" valign="top" width="47%" headers="d67636e8131 d67636e8044 "><pre class="oac_no_warn" dir="ltr">INSERT INTO event_table VALUES（'object owner is'|| <span class="bold">ora_dict_obj_owner</span> ）;</pre></td>
                              </tr>
                              <tr align="left" valign="top">
                                 <td align="left" valign="top" width="32%" id="d67636e8146" headers="d67636e8038 "><pre class="oac_no_warn" dir="ltr">ora_dict_obj_owner_list（owner_list OUT ora_name_list_t）</pre></td>
                                 <td align="left" valign="top" width="21%" headers="d67636e8146 d67636e8041 ">
                                    <p><code class="codeph">PLS_INTEGER</code> ：事件中修改的对象的所有者数</p>
                                    <p><code class="codeph">OUT</code>参数：事件中修改的对象的所有者列表</p>
                                 </td>
                                 <td align="left" valign="top" width="47%" headers="d67636e8146 d67636e8044 "><pre class="oac_no_warn" dir="ltr">DECLARE owner_list ora_name_list_t; number_modified PLS_INTEGER; BEGIN IF（ora_sysevent ='ASSOCIATE STATISTICS'）然后number_modified：= <span class="bold">ora_dict_obj_name_list（owner_list）</span> ;万一;结束;</pre></td>
                              </tr>
                              <tr align="left" valign="top">
                                 <td align="left" valign="top" width="32%" id="d67636e8165" headers="d67636e8038 "><pre class="oac_no_warn" dir="ltr">ora_dict_obj_type</pre></td>
                                 <td align="left" valign="top" width="21%" headers="d67636e8165 d67636e8041 ">
                                    <p><code class="codeph">VARCHAR2(20)</code> ：发生DDL操作的字典对象的类型</p>
                                 </td>
                                 <td align="left" valign="top" width="47%" headers="d67636e8165 d67636e8044 "><pre class="oac_no_warn" dir="ltr">INSERT INTO event_table VALUES（'此对象是'|| <span class="bold">ora_dict_obj_type</span> ）;</pre></td>
                              </tr>
                              <tr align="left" valign="top">
                                 <td align="left" valign="top" width="32%" id="d67636e8180" headers="d67636e8038 "><pre class="oac_no_warn" dir="ltr">ora_grantee（user_list OUT ora_name_list_t）</pre></td>
                                 <td align="left" valign="top" width="21%" headers="d67636e8180 d67636e8041 ">
                                    <p><code class="codeph">PLS_INTEGER</code> ：授权活动中的受助者数量</p>
                                    <p><code class="codeph">OUT</code>参数：授予活动中的受助者名单</p>
                                 </td>
                                 <td align="left" valign="top" width="47%" headers="d67636e8180 d67636e8044 "><pre class="oac_no_warn" dir="ltr">DECLARE user_list ora_name_list_t; number_of_grantees PLS_INTEGER; BEGIN IF（ora_sysevent ='GRANT'）那么number_of_grantees：= <span class="bold">ora_grantee（user_list）</span> ;万一;结束;</pre></td>
                              </tr>
                              <tr align="left" valign="top">
                                 <td align="left" valign="top" width="32%" id="d67636e8199" headers="d67636e8038 "><pre class="oac_no_warn" dir="ltr">ora_instance_num</pre></td>
                                 <td align="left" valign="top" width="21%" headers="d67636e8199 d67636e8041 ">
                                    <p><code class="codeph">NUMBER</code> ：实例编号</p>
                                 </td>
                                 <td align="left" valign="top" width="47%" headers="d67636e8199 d67636e8044 "><pre class="oac_no_warn" dir="ltr">IF（ <span class="bold">ora_instance_num</span> = 1）然后插入event_table VALUES（'1'）;万一;</pre></td>
                              </tr>
                              <tr align="left" valign="top">
                                 <td align="left" valign="top" width="32%" id="d67636e8214" headers="d67636e8038 "><pre class="oac_no_warn" dir="ltr">ora_is_alter_column（column_name IN VARCHAR2）</pre></td>
                                 <td align="left" valign="top" width="21%" headers="d67636e8214 d67636e8041 ">
                                    <p><code class="codeph">BOOLEAN</code> ：如果指定的列被更改，则为<code class="codeph">TRUE</code> ，否则为<code class="codeph">FALSE</code></p>
                                 </td>
                                 <td align="left" valign="top" width="47%" headers="d67636e8214 d67636e8044 "><pre class="oac_no_warn" dir="ltr">IF（ora_sysevent ='ALTER'和ora_dict_obj_type ='TABLE'）那么alter_column：= <span class="bold">ora_is_alter_column（'C'）</span> ;万一;</pre></td>
                              </tr>
                              <tr align="left" valign="top">
                                 <td align="left" valign="top" width="32%" id="d67636e8236" headers="d67636e8038 "><pre class="oac_no_warn" dir="ltr">ora_is_creating_nested_table</pre></td>
                                 <td align="left" valign="top" width="21%" headers="d67636e8236 d67636e8041 ">
                                    <p><code class="codeph">BOOLEAN</code> ：如果当前事件正在创建嵌套表，则为<code class="codeph">TRUE</code> ，否则为<code class="codeph">FALSE</code></p>
                                 </td>
                                 <td align="left" valign="top" width="47%" headers="d67636e8236 d67636e8044 "><pre class="oac_no_warn" dir="ltr">IF（ora_sysevent ='CREATE'和ora_dict_obj_type ='TABLE'和<span class="bold">ora_is_creating_nested_table</span> ）然后插入event_table VALUES（'创建嵌套表'）;万一;</pre></td>
                              </tr>
                              <tr align="left" valign="top">
                                 <td align="left" valign="top" width="32%" id="d67636e8257" headers="d67636e8038 "><pre class="oac_no_warn" dir="ltr">ora_is_drop_column（column_name IN VARCHAR2）</pre></td>
                                 <td align="left" valign="top" width="21%" headers="d67636e8257 d67636e8041 ">
                                    <p><code class="codeph">BOOLEAN</code> ：如果指定列被删除则为<code class="codeph">TRUE</code> ，否则为<code class="codeph">FALSE</code></p>
                                 </td>
                                 <td align="left" valign="top" width="47%" headers="d67636e8257 d67636e8044 "><pre class="oac_no_warn" dir="ltr">IF（ora_sysevent ='ALTER'和ora_dict_obj_type ='TABLE'）然后drop_column：= <span class="bold">ora_is_drop_column（'C'）</span> ;万一;</pre></td>
                              </tr>
                              <tr align="left" valign="top">
                                 <td align="left" valign="top" width="32%" id="d67636e8278" headers="d67636e8038 "><pre class="oac_no_warn" dir="ltr">ora_is_servererror（error_number IN VARCHAR2）</pre></td>
                                 <td align="left" valign="top" width="21%" headers="d67636e8278 d67636e8041 ">
                                    <p><code class="codeph">BOOLEAN</code> ：如果给定错误在错误堆栈上，则为<code class="codeph">TRUE</code> ，否则为<code class="codeph">FALSE</code></p>
                                 </td>
                                 <td align="left" valign="top" width="47%" headers="d67636e8278 d67636e8044 "><pre class="oac_no_warn" dir="ltr">如果<span class="bold">ora_is_servererror（error_number）</span>然后插入event_table VALUES（'服务器错误!!“）;万一;</pre></td>
                              </tr>
                              <tr align="left" valign="top">
                                 <td align="left" valign="top" width="32%" id="d67636e8299" headers="d67636e8038 "><pre class="oac_no_warn" dir="ltr">ora_login_user</pre></td>
                                 <td align="left" valign="top" width="21%" headers="d67636e8299 d67636e8041 ">
                                    <p><code class="codeph">VARCHAR2(128)</code> ：登录用户名</p>
                                 </td>
                                 <td align="left" valign="top" width="47%" headers="d67636e8299 d67636e8044 "><pre class="oac_no_warn" dir="ltr">SELECT <span class="bold">ora_login_user</span> FROM DUAL;</pre></td>
                              </tr>
                              <tr align="left" valign="top">
                                 <td align="left" valign="top" width="32%" id="d67636e8314" headers="d67636e8038 "><pre class="oac_no_warn" dir="ltr">ora_partition_pos</pre></td>
                                 <td align="left" valign="top" width="21%" headers="d67636e8314 d67636e8041 ">
                                    <p><code class="codeph">PLS_INTEGER</code> ：在<code class="codeph">INSTEAD</code> <code class="codeph">OF</code> <code class="codeph">CREATE</code> <code class="codeph">TABLE</code>触发器中，在SQL文本中的位置，您可以在其中插入<code class="codeph">PARTITION</code>子句</p>
                                 </td>
                                 <td align="left" valign="top" width="47%" headers="d67636e8314 d67636e8044 "><pre class="oac_no_warn" dir="ltr">- 将ora_sql_txt检索到sql_text变量v_n：= <span class="bold">ora_partition_pos</span> ; v_new_stmt：= SUBSTR（sql_text，1，v_n  -  1）|| ''|| my_partition_clause || ''|| SUBSTR（sql_text，v_n））;</pre></td>
                              </tr>
                              <tr align="left" valign="top">
                                 <td align="left" valign="top" width="32%" id="d67636e8344" headers="d67636e8038 "><pre class="oac_no_warn" dir="ltr">ora_privilege_list（privilege_list OUT ora_name_list_t）</pre></td>
                                 <td align="left" valign="top" width="21%" headers="d67636e8344 d67636e8041 ">
                                    <p><code class="codeph">PLS_INTEGER</code> ：grant或revoke事件中的权限数</p>
                                    <p><code class="codeph">OUT</code>参数：在事件中授予或撤消的权限列表</p>
                                 </td>
                                 <td align="left" valign="top" width="47%" headers="d67636e8344 d67636e8044 "><pre class="oac_no_warn" dir="ltr">DECLARE privilege_list ora_name_list_t; number_of_privileges PLS_INTEGER; BEGIN IF（ora_sysevent ='GRANT'或ora_sysevent ='REVOKE'）那么number_of_privileges：= <span class="bold">ora_privilege_list（privilege_list）</span> ;万一;结束;</pre></td>
                              </tr>
                              <tr align="left" valign="top">
                                 <td align="left" valign="top" width="32%" id="d67636e8363" headers="d67636e8038 "><pre class="oac_no_warn" dir="ltr">ora_revokee（user_list OUT ora_name_list_t）</pre></td>
                                 <td align="left" valign="top" width="21%" headers="d67636e8363 d67636e8041 ">
                                    <p><code class="codeph">PLS_INTEGER</code> ：撤销事件中的撤销次数</p>
                                    <p><code class="codeph">OUT</code>参数：事件中的撤销列表</p>
                                 </td>
                                 <td align="left" valign="top" width="47%" headers="d67636e8363 d67636e8044 "><pre class="oac_no_warn" dir="ltr">DECLARE user_list ora_name_list_t; number_of_users PLS_INTEGER; BEGIN IF（ora_sysevent ='REVOKE'）那么number_of_users：= <span class="bold">ora_revokee（user_list）</span> ;万一;结束;</pre></td>
                              </tr>
                              <tr align="left" valign="top">
                                 <td align="left" valign="top" width="32%" id="d67636e8382" headers="d67636e8038 "><pre class="oac_no_warn" dir="ltr">ora_server_error（位置IN PLS_INTEGER）</pre></td>
                                 <td align="left" valign="top" width="21%" headers="d67636e8382 d67636e8041 ">
                                    <p><code class="codeph">NUMBER</code> ：错误堆栈<a id="GUID-266DBF6D-AA74-490C-ADE5-962C10708C2D__CIHHCBGJ" name="GUID-266DBF6D-AA74-490C-ADE5-962C10708C2D__CIHHCBGJ" href="#GUID-266DBF6D-AA74-490C-ADE5-962C10708C2D__CIHHCBGJ" position="" 1="" is="" the="" top="" of="" stack=")" ="" onclick="footdisplay(1, "><sup>Foot 1</sup></a>上给定位置的错误代码</p>
                                 </td>
                                 <td align="left" valign="top" width="47%" headers="d67636e8382 d67636e8044 "><pre class="oac_no_warn" dir="ltr">INSERT INTO event_table VALUES（'top stack error'|| <span class="bold">ora_server_error（1）</span> ）;</pre></td>
                              </tr>
                              <tr align="left" valign="top">
                                 <td align="left" valign="top" width="32%" id="d67636e8400" headers="d67636e8038 "><pre class="oac_no_warn" dir="ltr">ora_server_error_depth</pre></td>
                                 <td align="left" valign="top" width="21%" headers="d67636e8400 d67636e8041 ">
                                    <p><code class="codeph">PLS_INTEGER</code> ：错误堆栈上的错误消息数</p>
                                 </td>
                                 <td align="left" valign="top" width="47%" headers="d67636e8400 d67636e8044 "><pre class="oac_no_warn" dir="ltr">n：= <span class="bold">ora_server_error_depth</span> ; - 将n与ora_server_error等函数一起使用</pre></td>
                              </tr>
                              <tr align="left" valign="top">
                                 <td align="left" valign="top" width="32%" id="d67636e8415" headers="d67636e8038 "><pre class="oac_no_warn" dir="ltr">ora_server_error_msg（位置IN PLS_INTEGER）</pre></td>
                                 <td align="left" valign="top" width="21%" headers="d67636e8415 d67636e8041 ">
                                    <p><code class="codeph">VARCHAR2</code> ：错误堆栈<a id="fnsrc_d67636e8423" name="fnsrc_d67636e8423" href="#fnsrc_d67636e8423" position="" 1="" is="" the="" top="" of="" stack=")" ="" onclick="footdisplay(1, "><sup>Footref 1</sup></a>上给定位置的错误消息</p>
                                 </td>
                                 <td align="left" valign="top" width="47%" headers="d67636e8415 d67636e8044 "><pre class="oac_no_warn" dir="ltr">INSERT INTO event_table VALUES（'top stack error message'|| <span class="bold">ora_server_error_msg（1）</span> ）;</pre></td>
                              </tr>
                              <tr align="left" valign="top">
                                 <td align="left" valign="top" width="32%" id="d67636e8432" headers="d67636e8038 "><pre class="oac_no_warn" dir="ltr">ora_server_error_num_params（位置IN PLS_INTEGER）</pre></td>
                                 <td align="left" valign="top" width="21%" headers="d67636e8432 d67636e8041 ">
                                    <p><code class="codeph">PLS_INTEGER</code> ：在错误堆栈<a id="fnsrc_d67636e8443" name="fnsrc_d67636e8443" href="#fnsrc_d67636e8443" position="" 1="" is="" the="" top="" of="" stack=")" ="" onclick="footdisplay(1, "><sup>Footref 1</sup></a>上的给定位置替换为错误消息（使用<code class="codeph">%s</code>格式）的字符串数</p>
                                 </td>
                                 <td align="left" valign="top" width="47%" headers="d67636e8432 d67636e8044 "><pre class="oac_no_warn" dir="ltr">n：= <span class="bold">ora_server_error_num_params（1）</span> ;</pre></td>
                              </tr>
                              <tr align="left" valign="top">
                                 <td align="left" valign="top" width="32%" id="d67636e8453" headers="d67636e8038 "><pre class="oac_no_warn" dir="ltr">ora_server_error_param（位置IN PLS_INTEGER，参数IN PLS_INTEGER）</pre></td>
                                 <td align="left" valign="top" width="21%" headers="d67636e8453 d67636e8041 ">
                                    <p><code class="codeph">VARCHAR2</code> ：在给定位置和参数编号<a id="fnsrc_d67636e8467" name="fnsrc_d67636e8467" href="#fnsrc_d67636e8467" position="" 1="" is="" the="" top="" of="" stack=")" ="" onclick="footdisplay(1, "><sup>Footref 1的</sup></a>错误消息中匹配替换值（ <code class="codeph">%s</code> ， <code class="codeph">%d</code>等）</p>
                                 </td>
                                 <td align="left" valign="top" width="47%" headers="d67636e8453 d67636e8044 "><pre class="oac_no_warn" dir="ltr">- “预期％s，找到％s”中的第二个％s：param：= <span class="bold">ora_server_error_param（1,2）</span> ;</pre></td>
                              </tr>
                              <tr align="left" valign="top">
                                 <td align="left" valign="top" width="32%" id="d67636e8476" headers="d67636e8038 "><pre class="oac_no_warn" dir="ltr">ora_sql_txt（sql_text OUT ora_name_list_t）</pre></td>
                                 <td align="left" valign="top" width="21%" headers="d67636e8476 d67636e8041 ">
                                    <p><code class="codeph">PLS_INTEGER</code> ：PL / SQL表中的元素数</p>
                                    <p><code class="codeph">OUT</code>参数：触发语句的SQL文本（如果语句很长，则分为多个集合元素）</p>
                                 </td>
                                 <td align="left" valign="top" width="47%" headers="d67636e8476 d67636e8044 "><pre class="oac_no_warn" dir="ltr">CREATE TABLE event_table（col VARCHAR2（2030））; DECLARE sql_text ora_name_list_t; n PLS_INTEGER; v_stmt VARCHAR2（2000）; BEGIN n：= <span class="bold">ora_sql_txt（sql_text）</span> ; FOR i IN 1..n LOOP <span class="bold">v_stmt：= v_stmt || SQL_TEXT（ⅰ）;</span>结束循环; INSERT INTO event_table VALUES（'触发语句的文本：'|| <span class="bold">v_stmt</span> ）;结束;</pre></td>
                              </tr>
                              <tr align="left" valign="top">
                                 <td align="left" valign="top" width="32%" id="d67636e8501" headers="d67636e8038 "><pre class="oac_no_warn" dir="ltr">ora_sysevent</pre></td>
                                 <td align="left" valign="top" width="21%" headers="d67636e8501 d67636e8041 ">
                                    <p><code class="codeph">VARCHAR2(20)</code> ：触发事件的名称，如语法中所示</p>
                                 </td>
                                 <td align="left" valign="top" width="47%" headers="d67636e8501 d67636e8044 "><pre class="oac_no_warn" dir="ltr">INSERT INTO event_table VALUES（ <span class="bold">ora_sysevent</span> ）;</pre></td>
                              </tr>
                              <tr align="left" valign="top">
                                 <td align="left" valign="top" width="32%" id="d67636e8516" headers="d67636e8038 "><pre class="oac_no_warn" dir="ltr">ora_with_grant_option</pre></td>
                                 <td align="left" valign="top" width="21%" headers="d67636e8516 d67636e8041 ">
                                    <p><code class="codeph">BOOLEAN</code> ：如果使用<code class="codeph">GRANT</code>选项授予权限，则为<code class="codeph">TRUE</code> ，否则为<code class="codeph">FALSE</code></p>
                                 </td>
                                 <td align="left" valign="top" width="47%" headers="d67636e8516 d67636e8044 "><pre class="oac_no_warn" dir="ltr">IF（ora_sysevent ='GRANT'和<span class="bold">ora_with_grant_option</span> = TRUE）然后插入event_table VALUES（'with grant option'）;万一;</pre></td>
                              </tr>
                              <tr align="left" valign="top">
                                 <td align="left" valign="top" width="32%" id="d67636e8540" headers="d67636e8038 "><pre class="oac_no_warn" dir="ltr">ora_space_error_info（error_number OUT NUMBER，error_type OUT VARCHAR2，object_owner OUT VARCHAR2，table_space_name OUT VARCHAR2，object_name OUT VARCHAR2，sub_object_name OUT VARCHAR2）</pre></td>
                                 <td align="left" valign="top" width="21%" headers="d67636e8540 d67636e8041 ">
                                    <p><code class="codeph">BOOLEAN</code> ：如果错误与空间不足情况有关，则为<code class="codeph">TRUE</code> ，否则为<code class="codeph">FALSE</code></p>
                                    <p><code class="codeph">OUT</code>参数：有关导致错误的对象的信息</p>
                                 </td>
                                 <td align="left" valign="top" width="47%" headers="d67636e8540 d67636e8044 "><pre class="oac_no_warn" dir="ltr">IF（ <span class="bold">ora_space_error_info（</span> <span class="bold">eno，typ，owner，ts，obj，subobj）= TRUE）</span>那么DBMS_OUTPUT.PUT_LINE（'|| <span class="bold">owner</span> ||'拥有的对象'|| <span class="bold">obj</span> ||'空间不足。“）;万一;</pre></td>
                              </tr>
                           </tbody>
                        </table>
                     </div>
                     <!-- class="inftblhruleinformal" -->
                     <p class="tablefootnote"><sup class="tablefootnote">脚注1</sup></p><p>位置1是堆栈的顶部。</p>
                     <p></p>
                  </div>
               </div><a id="LNPLS796"></a><a id="LNPLS20141"></a><div class="props_rev_3"><a id="GUID-5DEA2CE5-D61C-4E27-A36E-73348D9F619B" name="GUID-5DEA2CE5-D61C-4E27-A36E-73348D9F619B"></a><h4 id="LNPLS-GUID-5DEA2CE5-D61C-4E27-A36E-73348D9F619B" class="sect4"><span class="enumeration_section">9.15.2</span>数据库事件触发器的事件属性函数</h4>
                  <div>
                     <p><a href="plsql-triggers.html#GUID-5DEA2CE5-D61C-4E27-A36E-73348D9F619B__CHDHFBBG" title="此表汇总了系统管理器事件。">表9-6</a>总结了可以调用事件属性函数的数据库事件触发器。有关<a href="plsql-triggers.html#GUID-5DEA2CE5-D61C-4E27-A36E-73348D9F619B__CHDHFBBG" title="此表汇总了系统管理器事件。">表9-6中</a>的触发事件的更多信息，请参阅<span class="q">“ <a href="CREATE-TRIGGER-statement.html#GUID-AF9E33F1-64D1-4382-A6A4-EC33C36F237B__CIHBABAH">database_event</a> ”</span> 。
                     </p>
                     <div class="tblformalwide" id="GUID-5DEA2CE5-D61C-4E27-A36E-73348D9F619B__CHDHFBBG">
                        <p class="titleintable">表9-6数据库事件触发器</p>
                        <table cellpadding="4" cellspacing="0" class="FormalWide" title="数据库事件触发器" width="100%" border="1" summary="This table summarizes system manager events." frame="hsides" rules="rows">
                           <thead>
                              <tr align="left" valign="top">
                                 <th align="left" valign="bottom" width="19%" id="d67636e8677">触发事件</th>
                                 <th align="left" valign="bottom" width="19%" id="d67636e8680">当触发器触发时</th>
                                 <th align="left" valign="bottom" width="12%" id="d67636e8683">什么条件</th>
                                 <th align="left" valign="bottom" width="17%" id="d67636e8686">限制</th>
                                 <th align="left" valign="bottom" width="15%" id="d67636e8689">交易</th>
                                 <th align="left" valign="bottom" width="17%" id="d67636e8692">属性函数</th>
                              </tr>
                           </thead>
                           <tbody>
                              <tr align="left" valign="top">
                                 <td align="left" valign="top" width="19%" id="d67636e8697" headers="d67636e8677 "><pre class="oac_no_warn" dir="ltr">启动后</pre></td>
                                 <td align="left" valign="top" width="19%" headers="d67636e8697 d67636e8680 ">
                                    <p>打开数据库时。</p>
                                 </td>
                                 <td align="left" valign="top" width="12%" headers="d67636e8697 d67636e8683 ">
                                    <p>没有人允许</p>
                                 </td>
                                 <td align="left" valign="top" width="17%" headers="d67636e8697 d67636e8686 ">
                                    <p>触发器无法执行数据库操作。</p>
                                 </td>
                                 <td align="left" valign="top" width="15%" headers="d67636e8697 d67636e8689 ">
                                    <p>启动单独的事务并在触发触发器后提交它。</p>
                                 </td>
                                 <td align="left" valign="top" width="17%" headers="d67636e8697 d67636e8692 "><pre class="oac_no_warn" dir="ltr">ora_sysevent ora_login_user ora_instance_num ora_database_name</pre></td>
                              </tr>
                              <tr align="left" valign="top">
                                 <td align="left" valign="top" width="19%" id="d67636e8716" headers="d67636e8677 "><pre class="oac_no_warn" dir="ltr">关闭之前</pre></td>
                                 <td align="left" valign="top" width="19%" headers="d67636e8716 d67636e8680 ">
                                    <p>就在服务器开始关闭实例之前。</p>
                                    <p>这样可以完全关闭墨盒。对于异常实例关闭，此触发器可能不会触发。</p>
                                 </td>
                                 <td align="left" valign="top" width="12%" headers="d67636e8716 d67636e8683 ">
                                    <p>没有人允许</p>
                                 </td>
                                 <td align="left" valign="top" width="17%" headers="d67636e8716 d67636e8686 ">
                                    <p>触发器无法执行数据库操作。</p>
                                 </td>
                                 <td align="left" valign="top" width="15%" headers="d67636e8716 d67636e8689 ">
                                    <p>启动单独的事务并在触发触发器后提交它。</p>
                                 </td>
                                 <td align="left" valign="top" width="17%" headers="d67636e8716 d67636e8692 "><pre class="oac_no_warn" dir="ltr">ora_sysevent ora_login_user ora_instance_num ora_database_name</pre></td>
                              </tr>
                              <tr align="left" valign="top">
                                 <td align="left" valign="top" width="19%" id="d67636e8737" headers="d67636e8677 "><pre class="oac_no_warn" dir="ltr">在DB_ROLE_CHANGE之后</pre></td>
                                 <td align="left" valign="top" width="19%" headers="d67636e8737 d67636e8680 ">
                                    <p>在角色更改后第一次打开数据库时。</p>
                                 </td>
                                 <td align="left" valign="top" width="12%" headers="d67636e8737 d67636e8683 ">
                                    <p>没有人允许</p>
                                 </td>
                                 <td align="left" valign="top" width="17%" headers="d67636e8737 d67636e8686 ">
                                    <p>没有</p>
                                 </td>
                                 <td align="left" valign="top" width="15%" headers="d67636e8737 d67636e8689 ">
                                    <p>启动单独的事务并在触发触发器后提交它。</p>
                                 </td>
                                 <td align="left" valign="top" width="17%" headers="d67636e8737 d67636e8692 "><pre class="oac_no_warn" dir="ltr">ora_sysevent ora_login_user ora_instance_num ora_database_name</pre></td>
                              </tr>
                              <tr align="left" valign="top">
                                 <td align="left" valign="top" width="19%" id="d67636e8756" headers="d67636e8677 "><pre class="oac_no_warn" dir="ltr">在服务员之后</pre></td>
                                 <td align="left" valign="top" width="19%" headers="d67636e8756 d67636e8680 ">
                                    <p>有条件，每当发生指定的错误。无条件，无论何时发生任何错误。</p>
                                    <p>触发器不会触发<span class="q">“ <a href="CREATE-TRIGGER-statement.html#GUID-AF9E33F1-64D1-4382-A6A4-EC33C36F237B__CIHBABAH">database_event</a> ”中</span>列出的错误。
                                    </p>
                                 </td>
                                 <td align="left" valign="top" width="12%" headers="d67636e8756 d67636e8683 ">
                                    <p><code class="codeph">ERRNO</code> = <code class="codeph">eno</code></p>
                                 </td>
                                 <td align="left" valign="top" width="17%" headers="d67636e8756 d67636e8686 ">
                                    <p>取决于错误。</p>
                                 </td>
                                 <td align="left" valign="top" width="15%" headers="d67636e8756 d67636e8689 ">
                                    <p>启动单独的事务并在触发触发器后提交它。</p>
                                 </td>
                                 <td align="left" valign="top" width="17%" headers="d67636e8756 d67636e8692 "><pre class="oac_no_warn" dir="ltr">ora_sysevent ora_login_user ora_instance_num ora_database_name ora_server_error ora_is_servererror ora_space_error_info</pre></td>
                              </tr>
                           </tbody>
                        </table>
                     </div>
                     <!-- class="inftblhruleinformal" -->
                  </div>
               </div><a id="LNPLS798"></a><a id="LNPLS797"></a><div class="props_rev_3"><a id="GUID-F6473AD0-75D2-4E36-8B15-F93F0B5A8B79" name="GUID-F6473AD0-75D2-4E36-8B15-F93F0B5A8B79"></a><h4 id="LNPLS-GUID-F6473AD0-75D2-4E36-8B15-F93F0B5A8B79" class="sect4"><span class="enumeration_section">9.15.3</span>客户端事件触发器的事件属性函数</h4>
                  <div>
                     <p><a href="plsql-triggers.html#GUID-F6473AD0-75D2-4E36-8B15-F93F0B5A8B79__CHDGIJDB" title="此表汇总了客户端事件。">表9-7</a>总结了可以调用事件属性函数的客户端事件触发器。有关<a href="plsql-triggers.html#GUID-F6473AD0-75D2-4E36-8B15-F93F0B5A8B79__CHDGIJDB" title="此表汇总了客户端事件。">表9-7中</a>的触发事件的更多信息，请参阅<span class="q">“ <a href="CREATE-TRIGGER-statement.html#GUID-AF9E33F1-64D1-4382-A6A4-EC33C36F237B__CIHBDEFD">ddl_event</a> ”</span>和<span class="q">“ <a href="CREATE-TRIGGER-statement.html#GUID-AF9E33F1-64D1-4382-A6A4-EC33C36F237B__CIHBABAH">database_event</a> ”</span> 。
                     </p>
                     <div class="infoboxnote" id="GUID-F6473AD0-75D2-4E36-8B15-F93F0B5A8B79__GUID-65EA2764-0C9F-4AB3-85F7-88840723CEEF">
                        <p class="notep1">注意：</p>
                        <p>如果客户端事件触发器成为DDL操作的目标（例如<code class="codeph">CREATE</code> <code class="codeph">OR</code> <code class="codeph">REPLACE</code> <code class="codeph">TRIGGER</code> ），则它在以后的同一事务中无法触发。
                        </p>
                     </div>
                     <div class="tblformalwide" id="GUID-F6473AD0-75D2-4E36-8B15-F93F0B5A8B79__CHDGIJDB">
                        <p class="titleintable">表9-7客户端事件触发器</p>
                        <table cellpadding="4" cellspacing="0" class="FormalWide" title="客户端事件触发器" width="100%" border="1" summary="This table summarizes client events." frame="hsides" rules="rows">
                           <thead>
                              <tr align="left" valign="top">
                                 <th align="left" valign="bottom" width="13%" id="d67636e8908">触发事件</th>
                                 <th align="left" valign="bottom" width="16%" id="d67636e8911">当触发器触发时</th>
                                 <th align="left" valign="bottom" width="16%" id="d67636e8914">什么条件</th>
                                 <th align="left" valign="bottom" width="16%" id="d67636e8917">限制</th>
                                 <th align="left" valign="bottom" width="13%" id="d67636e8920">交易</th>
                                 <th align="left" valign="bottom" width="27%" id="d67636e8923">属性函数</th>
                              </tr>
                           </thead>
                           <tbody>
                              <tr align="left" valign="top">
                                 <td align="left" valign="top" width="13%" id="d67636e8928" headers="d67636e8908 "><pre class="oac_no_warn" dir="ltr">在更改之后</pre></td>
                                 <td align="left" valign="top" width="16%" headers="d67636e8928 d67636e8911 ">
                                    <p>目录对象被更改时</p>
                                 </td>
                                 <td align="left" valign="top" width="16%" headers="d67636e8928 d67636e8914 ">
                                    <p>关于对象， <code class="codeph">UID</code>和<code class="codeph">USER</code>类型和名称的简单条件</p>
                                 </td>
                                 <td align="left" valign="top" width="16%" headers="d67636e8928 d67636e8917 ">
                                    <p>触发器无法对导致生成事件的对象执行DDL操作。</p>
                                    <p>其他对象上的DDL仅限于编译对象，创建触发器以及创建，更改和删除表。</p>
                                 </td>
                                 <td align="left" valign="top" width="13%" headers="d67636e8928 d67636e8920 ">
                                    <p>在当前事务中触发触发器。</p>
                                 </td>
                                 <td align="left" valign="top" width="27%" headers="d67636e8928 d67636e8923 "><pre class="oac_no_warn" dir="ltr">ora_sysevent ora_login_user ora_instance_num ora_database_name ora_dict_obj_type ora_dict_obj_name ora_dict_obj_owner ora_des_encrypted_password（用于ALTER USER事件）ora_is_alter_column（用于ALTER TABLE事件）ora_is_drop_column（用于ALTER TABLE事件）</pre></td>
                              </tr>
                              <tr align="left" valign="top">
                                 <td align="left" valign="top" width="13%" id="d67636e8954" headers="d67636e8908 "><pre class="oac_no_warn" dir="ltr">在掉落之前掉落之前</pre></td>
                                 <td align="left" valign="top" width="16%" headers="d67636e8954 d67636e8911 ">
                                    <p>删除目录对象时</p>
                                 </td>
                                 <td align="left" valign="top" width="16%" headers="d67636e8954 d67636e8914 ">
                                    <p>关于对象， <code class="codeph">UID</code>和<code class="codeph">USER</code>类型和名称的简单条件</p>
                                 </td>
                                 <td align="left" valign="top" width="16%" headers="d67636e8954 d67636e8917 ">
                                    <p>触发器无法对导致生成事件的对象执行DDL操作。</p>
                                    <p>其他对象上的DDL仅限于编译对象，创建触发器以及创建，更改和删除表。</p>
                                 </td>
                                 <td align="left" valign="top" width="13%" headers="d67636e8954 d67636e8920 ">
                                    <p>在当前事务中触发触发器。</p>
                                 </td>
                                 <td align="left" valign="top" width="27%" headers="d67636e8954 d67636e8923 "><pre class="oac_no_warn" dir="ltr">ora_sysevent ora_login_user ora_instance_num ora_database_name ora_dict_obj_type ora_dict_obj_name ora_dict_obj_owner</pre></td>
                              </tr>
                              <tr align="left" valign="top">
                                 <td align="left" valign="top" width="13%" id="d67636e8980" headers="d67636e8908 "><pre class="oac_no_warn" dir="ltr">在分析之后进行分析</pre></td>
                                 <td align="left" valign="top" width="16%" headers="d67636e8980 d67636e8911 ">
                                    <p>发出<code class="codeph">ANALYZE</code>语句时</p>
                                 </td>
                                 <td align="left" valign="top" width="16%" headers="d67636e8980 d67636e8914 ">
                                    <p>关于对象， <code class="codeph">UID</code>和<code class="codeph">USER</code>类型和名称的简单条件</p>
                                 </td>
                                 <td align="left" valign="top" width="16%" headers="d67636e8980 d67636e8917 ">
                                    <p>触发器无法对导致生成事件的对象执行DDL操作。</p>
                                    <p>其他对象上的DDL仅限于编译对象，创建触发器以及创建，更改和删除表。</p>
                                 </td>
                                 <td align="left" valign="top" width="13%" headers="d67636e8980 d67636e8920 ">
                                    <p>在当前事务中触发触发器。</p>
                                 </td>
                                 <td align="left" valign="top" width="27%" headers="d67636e8980 d67636e8923 "><pre class="oac_no_warn" dir="ltr">ora_sysevent ora_login_user ora_instance_num ora_database_name ora_dict_obj_name ora_dict_obj_type ora_dict_obj_owner</pre></td>
                              </tr>
                              <tr align="left" valign="top">
                                 <td align="left" valign="top" width="13%" id="d67636e9009" headers="d67636e8908 "><pre class="oac_no_warn" dir="ltr">在协会统计之后的协会统计之前</pre></td>
                                 <td align="left" valign="top" width="16%" headers="d67636e9009 d67636e8911 ">
                                    <p>发出<code class="codeph">ASSOCIATE</code> <code class="codeph">STATISTICS</code>语句时</p>
                                 </td>
                                 <td align="left" valign="top" width="16%" headers="d67636e9009 d67636e8914 ">
                                    <p>关于对象， <code class="codeph">UID</code>和<code class="codeph">USER</code>类型和名称的简单条件</p>
                                 </td>
                                 <td align="left" valign="top" width="16%" headers="d67636e9009 d67636e8917 ">
                                    <p>触发器无法对导致生成事件的对象执行DDL操作。</p>
                                    <p>其他对象上的DDL仅限于编译对象，创建触发器以及创建，更改和删除表。</p>
                                 </td>
                                 <td align="left" valign="top" width="13%" headers="d67636e9009 d67636e8920 ">
                                    <p>在当前事务中触发触发器。</p>
                                 </td>
                                 <td align="left" valign="top" width="27%" headers="d67636e9009 d67636e8923 "><pre class="oac_no_warn" dir="ltr">ora_sysevent ora_login_user ora_instance_num ora_database_name ora_dict_obj_name ora_dict_obj_type ora_dict_obj_owner ora_dict_obj_name_list ora_dict_obj_owner_list</pre></td>
                              </tr>
                              <tr align="left" valign="top">
                                 <td align="left" valign="top" width="13%" id="d67636e9041" headers="d67636e8908 "><pre class="oac_no_warn" dir="ltr">在未经审查之前未经审核之前进行审计之前进行审计</pre></td>
                                 <td align="left" valign="top" width="16%" headers="d67636e9041 d67636e8911 ">
                                    <p>发出<code class="codeph">AUDIT</code>或<code class="codeph">NOAUDIT</code>语句时</p>
                                 </td>
                                 <td align="left" valign="top" width="16%" headers="d67636e9041 d67636e8914 ">
                                    <p>关于对象， <code class="codeph">UID</code>和<code class="codeph">USER</code>类型和名称的简单条件</p>
                                 </td>
                                 <td align="left" valign="top" width="16%" headers="d67636e9041 d67636e8917 ">
                                    <p>触发器无法对导致生成事件的对象执行DDL操作。</p>
                                    <p>其他对象上的DDL仅限于编译对象，创建触发器以及创建，更改和删除表。</p>
                                 </td>
                                 <td align="left" valign="top" width="13%" headers="d67636e9041 d67636e8920 ">
                                    <p>在当前事务中触发触发器。</p>
                                 </td>
                                 <td align="left" valign="top" width="27%" headers="d67636e9041 d67636e8923 "><pre class="oac_no_warn" dir="ltr">ora_sysevent ora_login_user ora_instance_num ora_database_name</pre></td>
                              </tr>
                              <tr align="left" valign="top">
                                 <td align="left" valign="top" width="13%" id="d67636e9073" headers="d67636e8908 "><pre class="oac_no_warn" dir="ltr">评论后的评论之前</pre></td>
                                 <td align="left" valign="top" width="16%" headers="d67636e9073 d67636e8911 ">
                                    <p>当对象被评论时</p>
                                 </td>
                                 <td align="left" valign="top" width="16%" headers="d67636e9073 d67636e8914 ">
                                    <p>关于对象， <code class="codeph">UID</code>和<code class="codeph">USER</code>类型和名称的简单条件</p>
                                 </td>
                                 <td align="left" valign="top" width="16%" headers="d67636e9073 d67636e8917 ">
                                    <p>触发器无法对导致生成事件的对象执行DDL操作。</p>
                                    <p>其他对象上的DDL仅限于编译对象，创建触发器以及创建，更改和删除表。</p>
                                 </td>
                                 <td align="left" valign="top" width="13%" headers="d67636e9073 d67636e8920 ">
                                    <p>在当前事务中触发触发器。</p>
                                 </td>
                                 <td align="left" valign="top" width="27%" headers="d67636e9073 d67636e8923 "><pre class="oac_no_warn" dir="ltr">ora_sysevent ora_login_user ora_instance_num ora_database_name ora_dict_obj_name ora_dict_obj_type ora_dict_obj_owner</pre></td>
                              </tr>
                              <tr align="left" valign="top">
                                 <td align="left" valign="top" width="13%" id="d67636e9099" headers="d67636e8908 "><pre class="oac_no_warn" dir="ltr">在创建之后创建</pre></td>
                                 <td align="left" valign="top" width="16%" headers="d67636e9099 d67636e8911 ">
                                    <p>创建目录对象时</p>
                                 </td>
                                 <td align="left" valign="top" width="16%" headers="d67636e9099 d67636e8914 ">
                                    <p>关于对象， <code class="codeph">UID</code>和<code class="codeph">USER</code>类型和名称的简单条件</p>
                                 </td>
                                 <td align="left" valign="top" width="16%" headers="d67636e9099 d67636e8917 ">
                                    <p>触发器无法对导致生成事件的对象执行DDL操作。</p>
                                    <p>其他对象上的DDL仅限于编译对象，创建触发器以及创建，更改和删除表。</p>
                                 </td>
                                 <td align="left" valign="top" width="13%" headers="d67636e9099 d67636e8920 ">
                                    <p>在当前事务中触发触发器。</p>
                                 </td>
                                 <td align="left" valign="top" width="27%" headers="d67636e9099 d67636e8923 "><pre class="oac_no_warn" dir="ltr">ora_sysevent ora_login_user ora_instance_num ora_database_name ora_dict_obj_type ora_dict_obj_name ora_dict_obj_owner ora_is_creating_nested_table（用于CREATE TABLE事件）</pre></td>
                              </tr>
                              <tr align="left" valign="top">
                                 <td align="left" valign="top" width="13%" id="d67636e9125" headers="d67636e8908 "><pre class="oac_no_warn" dir="ltr">在DDL之后的DDL之前</pre></td>
                                 <td align="left" valign="top" width="16%" headers="d67636e9125 d67636e8911 ">
                                    <p>发出大多数SQL DDL语句时。未通过PL / SQL子程序接口发出<code class="codeph">ALTER</code> <code class="codeph">DATABASE</code> ， <code class="codeph">CREATE</code> <code class="codeph">CONTROLFILE</code> ， <code class="codeph">CREATE</code> <code class="codeph">DATABASE</code>和DDL，例如创建高级队列。
                                    </p>
                                 </td>
                                 <td align="left" valign="top" width="16%" headers="d67636e9125 d67636e8914 ">
                                    <p>关于对象， <code class="codeph">UID</code>和<code class="codeph">USER</code>类型和名称的简单条件</p>
                                 </td>
                                 <td align="left" valign="top" width="16%" headers="d67636e9125 d67636e8917 ">
                                    <p>触发器无法对导致生成事件的对象执行DDL操作。</p>
                                    <p>其他对象上的DDL仅限于编译对象，创建触发器以及创建，更改和删除表。</p>
                                 </td>
                                 <td align="left" valign="top" width="13%" headers="d67636e9125 d67636e8920 ">
                                    <p>在当前事务中触发触发器。</p>
                                 </td>
                                 <td align="left" valign="top" width="27%" headers="d67636e9125 d67636e8923 "><pre class="oac_no_warn" dir="ltr">ora_sysevent ora_login_user ora_instance_num ora_database_name ora_dict_obj_name ora_dict_obj_type ora_dict_obj_owner</pre></td>
                              </tr>
                              <tr align="left" valign="top">
                                 <td align="left" valign="top" width="13%" id="d67636e9170" headers="d67636e8908 "><pre class="oac_no_warn" dir="ltr">在消除统计数据之前的灾难性统计数据之前</pre></td>
                                 <td align="left" valign="top" width="16%" headers="d67636e9170 d67636e8911 ">
                                    <p>当<code class="codeph">DISASSOCIATE</code> <code class="codeph">STATISTICS</code>声明发布时</p>
                                 </td>
                                 <td align="left" valign="top" width="16%" headers="d67636e9170 d67636e8914 ">
                                    <p>关于对象， <code class="codeph">UID</code>和<code class="codeph">USER</code>类型和名称的简单条件</p>
                                 </td>
                                 <td align="left" valign="top" width="16%" headers="d67636e9170 d67636e8917 ">
                                    <p>触发器无法对导致生成事件的对象执行DDL操作。</p>
                                    <p>其他对象上的DDL仅限于编译对象，创建触发器以及创建，更改和删除表。</p>
                                 </td>
                                 <td align="left" valign="top" width="13%" headers="d67636e9170 d67636e8920 ">
                                    <p>在当前事务中触发触发器。</p>
                                 </td>
                                 <td align="left" valign="top" width="27%" headers="d67636e9170 d67636e8923 "><pre class="oac_no_warn" dir="ltr">ora_sysevent ora_login_user ora_instance_num ora_database_name ora_dict_obj_name ora_dict_obj_type ora_dict_obj_owner ora_dict_obj_name_list ora_dict_obj_owner_list</pre></td>
                              </tr>
                              <tr align="left" valign="top">
                                 <td align="left" valign="top" width="13%" id="d67636e9202" headers="d67636e8908 "><pre class="oac_no_warn" dir="ltr">在获得资助之前获得资助</pre></td>
                                 <td align="left" valign="top" width="16%" headers="d67636e9202 d67636e8911 ">
                                    <p>发出<code class="codeph">GRANT</code>语句时</p>
                                 </td>
                                 <td align="left" valign="top" width="16%" headers="d67636e9202 d67636e8914 ">
                                    <p>关于对象， <code class="codeph">UID</code>和<code class="codeph">USER</code>类型和名称的简单条件</p>
                                 </td>
                                 <td align="left" valign="top" width="16%" headers="d67636e9202 d67636e8917 ">
                                    <p>触发器无法对导致生成事件的对象执行DDL操作。</p>
                                    <p>其他对象上的DDL仅限于编译对象，创建触发器以及创建，更改和删除表。</p>
                                 </td>
                                 <td align="left" valign="top" width="13%" headers="d67636e9202 d67636e8920 ">
                                    <p>在当前事务中触发触发器。</p>
                                 </td>
                                 <td align="left" valign="top" width="27%" headers="d67636e9202 d67636e8923 "><pre class="oac_no_warn" dir="ltr">ora_sysevent ora_login_user ora_instance_num ora_database_name ora_dict_obj_name ora_dict_obj_type ora_dict_obj_owner ora_grantee ora_with_grant_option ora_privilege_list</pre></td>
                              </tr>
                              <tr align="left" valign="top">
                                 <td align="left" valign="top" width="13%" id="d67636e9231" headers="d67636e8908 "><pre class="oac_no_warn" dir="ltr">在LOGOFF之前</pre></td>
                                 <td align="left" valign="top" width="16%" headers="d67636e9231 d67636e8911 ">
                                    <p>在用户注销开始时</p>
                                 </td>
                                 <td align="left" valign="top" width="16%" headers="d67636e9231 d67636e8914 ">
                                    <p><code class="codeph">UID</code>和<code class="codeph">USER</code>简单条件</p>
                                 </td>
                                 <td align="left" valign="top" width="16%" headers="d67636e9231 d67636e8917 ">
                                    <p>其他对象上的DDL仅限于编译对象，创建触发器以及创建，更改和删除表。</p>
                                 </td>
                                 <td align="left" valign="top" width="13%" headers="d67636e9231 d67636e8920 ">
                                    <p>在当前事务中触发触发器。</p>
                                 </td>
                                 <td align="left" valign="top" width="27%" headers="d67636e9231 d67636e8923 "><pre class="oac_no_warn" dir="ltr">ora_sysevent ora_login_user ora_instance_num ora_database_name</pre></td>
                              </tr>
                              <tr align="left" valign="top">
                                 <td align="left" valign="top" width="13%" id="d67636e9256" headers="d67636e8908 "><pre class="oac_no_warn" dir="ltr">登录后</pre></td>
                                 <td align="left" valign="top" width="16%" headers="d67636e9256 d67636e8911 ">
                                    <p>用户登录成功后</p>
                                 </td>
                                 <td align="left" valign="top" width="16%" headers="d67636e9256 d67636e8914 ">
                                    <p><code class="codeph">UID</code>和<code class="codeph">USER</code>简单条件</p>
                                 </td>
                                 <td align="left" valign="top" width="16%" headers="d67636e9256 d67636e8917 ">
                                    <p>其他对象上的DDL仅限于编译对象，创建触发器以及创建，更改和删除表。</p>
                                 </td>
                                 <td align="left" valign="top" width="13%" headers="d67636e9256 d67636e8920 ">
                                    <p>启动单独的事务并在触发触发器后提交它。</p>
                                 </td>
                                 <td align="left" valign="top" width="27%" headers="d67636e9256 d67636e8923 "><pre class="oac_no_warn" dir="ltr">ora_sysevent ora_login_user ora_instance_num ora_database_name ora_client_ip_address</pre></td>
                              </tr>
                              <tr align="left" valign="top">
                                 <td align="left" valign="top" width="13%" id="d67636e9280" headers="d67636e8908 "><pre class="oac_no_warn" dir="ltr">在重命名之后重命名之前</pre></td>
                                 <td align="left" valign="top" width="16%" headers="d67636e9280 d67636e8911 ">
                                    <p>发出<code class="codeph">RENAME</code>语句时</p>
                                 </td>
                                 <td align="left" valign="top" width="16%" headers="d67636e9280 d67636e8914 ">
                                    <p>关于对象， <code class="codeph">UID</code>和<code class="codeph">USER</code>类型和名称的简单条件</p>
                                 </td>
                                 <td align="left" valign="top" width="16%" headers="d67636e9280 d67636e8917 ">
                                    <p>触发器无法对导致生成事件的对象执行DDL操作。</p>
                                    <p>其他对象上的DDL仅限于编译对象，创建触发器以及创建，更改和删除表。</p>
                                 </td>
                                 <td align="left" valign="top" width="13%" headers="d67636e9280 d67636e8920 ">
                                    <p>在当前事务中触发触发器。</p>
                                 </td>
                                 <td align="left" valign="top" width="27%" headers="d67636e9280 d67636e8923 "><pre class="oac_no_warn" dir="ltr">ora_sysevent ora_login_user ora_instance_num ora_database_name ora_dict_obj_name ora_dict_obj_owner ora_dict_obj_type</pre></td>
                              </tr>
                              <tr align="left" valign="top">
                                 <td align="left" valign="top" width="13%" id="d67636e9309" headers="d67636e8908 "><pre class="oac_no_warn" dir="ltr">在翻新之后再进行翻新</pre></td>
                                 <td align="left" valign="top" width="16%" headers="d67636e9309 d67636e8911 ">
                                    <p>发出<code class="codeph">REVOKE</code>语句时</p>
                                 </td>
                                 <td align="left" valign="top" width="16%" headers="d67636e9309 d67636e8914 ">
                                    <p>关于对象， <code class="codeph">UID</code>和<code class="codeph">USER</code>类型和名称的简单条件</p>
                                 </td>
                                 <td align="left" valign="top" width="16%" headers="d67636e9309 d67636e8917 ">
                                    <p>触发器无法对导致生成事件的对象执行DDL操作。</p>
                                    <p>其他对象上的DDL仅限于编译对象，创建触发器以及创建，更改和删除表。</p>
                                 </td>
                                 <td align="left" valign="top" width="13%" headers="d67636e9309 d67636e8920 ">
                                    <p>在当前事务中触发触发器。</p>
                                 </td>
                                 <td align="left" valign="top" width="27%" headers="d67636e9309 d67636e8923 "><pre class="oac_no_warn" dir="ltr">ora_sysevent ora_login_user ora_instance_num ora_database_name ora_dict_obj_name ora_dict_obj_type ora_dict_obj_owner ora_revokee ora_privilege_list</pre></td>
                              </tr>
                              <tr align="left" valign="top">
                                 <td align="left" valign="top" width="13%" id="d67636e9338" headers="d67636e8908 "><pre class="oac_no_warn" dir="ltr">暂停后</pre></td>
                                 <td align="left" valign="top" width="16%" headers="d67636e9338 d67636e8911 ">
                                    <p>由于空间不足情况导致SQL语句暂停后。</p>
                                    <p>（触发器必须纠正条件，因此可以恢复语句。）</p>
                                 </td>
                                 <td align="left" valign="top" width="16%" headers="d67636e9338 d67636e8914 ">
                                    <p>关于对象， <code class="codeph">UID</code>和<code class="codeph">USER</code>类型和名称的简单条件</p>
                                 </td>
                                 <td align="left" valign="top" width="16%" headers="d67636e9338 d67636e8917 ">
                                    <p>触发器无法对导致生成事件的对象执行DDL操作。</p>
                                    <p>其他对象上的DDL仅限于编译对象，创建触发器以及创建，更改和删除表。</p>
                                 </td>
                                 <td align="left" valign="top" width="13%" headers="d67636e9338 d67636e8920 ">
                                    <p>在当前事务中触发触发器。</p>
                                 </td>
                                 <td align="left" valign="top" width="27%" headers="d67636e9338 d67636e8923 "><pre class="oac_no_warn" dir="ltr">ora_sysevent ora_login_user ora_instance_num ora_database_name ora_server_error ora_is_servererror ora_space_error_info</pre></td>
                              </tr>
                              <tr align="left" valign="top">
                                 <td align="left" valign="top" width="13%" id="d67636e9366" headers="d67636e8908 "><pre class="oac_no_warn" dir="ltr">在截止之后的截止之前</pre></td>
                                 <td align="left" valign="top" width="16%" headers="d67636e9366 d67636e8911 ">
                                    <p>当对象被截断时</p>
                                 </td>
                                 <td align="left" valign="top" width="16%" headers="d67636e9366 d67636e8914 ">
                                    <p>关于对象， <code class="codeph">UID</code>和<code class="codeph">USER</code>类型和名称的简单条件</p>
                                 </td>
                                 <td align="left" valign="top" width="16%" headers="d67636e9366 d67636e8917 ">
                                    <p>触发器无法对导致生成事件的对象执行DDL操作。</p>
                                    <p>其他对象上的DDL仅限于编译对象，创建触发器以及创建，更改和删除表。</p>
                                 </td>
                                 <td align="left" valign="top" width="13%" headers="d67636e9366 d67636e8920 ">
                                    <p>在当前事务中触发触发器。</p>
                                 </td>
                                 <td align="left" valign="top" width="27%" headers="d67636e9366 d67636e8923 "><pre class="oac_no_warn" dir="ltr">ora_sysevent ora_login_user ora_instance_num ora_database_name ora_dict_obj_name ora_dict_obj_type ora_dict_obj_owner</pre></td>
                              </tr>
                           </tbody>
                        </table>
                     </div>
                     <!-- class="inftblhruleinformal" -->
                  </div>
               </div>
            </div><a id="LNPLS691"></a><a id="LNPLS2012"></a><div class="props_rev_3"><a id="GUID-F843EE28-6D46-4AA2-B3B3-7CB5485B96CE" name="GUID-F843EE28-6D46-4AA2-B3B3-7CB5485B96CE"></a><h3 id="LNPLS-GUID-F843EE28-6D46-4AA2-B3B3-7CB5485B96CE" class="sect3"><span class="enumeration_section">9.16</span>关于触发器信息的视图</h3>
               <div>
                  <p><code class="codeph">*_TRIGGERS</code>静态数据字典视图显示有关触发器的信息。有关这些视图的信息，请参阅<a href="../refrn/ALL_TRIGGERS.html#REFRN20293" target="_blank"><span class="italic">Oracle数据库参考</span></a> 。
                  </p>
                  <div class="example" id="GUID-F843EE28-6D46-4AA2-B3B3-7CB5485B96CE__BCFHCBGE">
                     <p class="titleinexample">示例9-28查看有关触发器的信息</p>
                     <p>此示例创建一个触发器并首先查询静态数据字典视图<code class="codeph">USER_TRIGGERS</code> ，以显示其类型，触发事件以及创建它的表的名称，然后显示其正文。
                     </p><pre class="oac_no_warn" dir="ltr">创建或更换TRIGGER Emp_count删除员工后DECLARE n INTEGER; BEGIN SELECT COUNT（*）INTO n FROM employees; DBMS_OUTPUT.PUT_LINE（'现在有'|| n ||'员工。“）;结束; /</pre><p>这些SQL * Plus命令格式化查询结果。</p><pre class="oac_no_warn" dir="ltr">COLUMN Trigger_type FORMAT A15 COLUMN Triggering_event FORMAT A16 COLUMN Table_name FORMAT A11 COLUMN Trigger_body FORMAT A50 SET LONG 9999</pre><p>查询：</p><pre class="oac_no_warn" dir="ltr"><span class="bold">SELECT Trigger_type，Triggering_event，Table_name</span> <span class="bold">FROM USER_TRIGGERS</span> <span class="bold">WHERE Trigger_name ='EMP_COUNT';</span>
</pre><p>结果：</p><pre class="oac_no_warn" dir="ltr">TRIGGER_TYPE TRIGGERING_EVENT TABLE_NAME --------------- ---------------- -----------声明删除员工后</pre><p>查询：</p><pre class="oac_no_warn" dir="ltr">SELECT Trigger_body FROM <span class="bold">USER_TRIGGERS</span> WHERE Trigger_name ='EMP_COUNT';</pre><p>结果：</p><pre class="oac_no_warn" dir="ltr">TRIGGER_BODY ------------------------------------------------- -  DECLARE n INTEGER; BEGIN SELECT COUNT（*）INTO n FROM employees; DBMS_OUTPUT.PUT_LINE（'现在有'|| n ||'员工。“）;结束;</pre></div>
                  <!-- class="example" -->
               </div>
            </div>
         </div>
      </article>
   </body>
</html>