<html lang="en-us" dir="ltr" xml:lang="en-us">
   <head>
      <meta http-equiv="Content-Type" content="text/html; charset=utf-8"></meta>
      <meta name="viewport" content="width=device-width, initial-scale=1"></meta>
      <meta http-equiv="X-UA-Compatible" content="IE=edge"></meta>
      <title>分层查询</title>
      <meta property="og:site_name" content="Oracle Help Center"></meta>
      <meta property="og:title" content="SQL Language Reference "></meta>
      <meta property="og:description" content=""></meta>
      <link rel="stylesheet" href="/sp_common/book-template/ohc-book-template/css/book.css"></link>
      <link rel="shortcut icon" href="/sp_common/book-template/ohc-common/img/favicon.ico"></link>
      <meta name="application-name" content="SQL Language Reference"></meta>
      <meta name="generator" content="DITA Open Toolkit version 1.8.5 (Mode = doc)"></meta>
      <meta name="plugin" content="SP_docbuilder HTML plugin release 18.2.2"></meta>
      <link rel="alternate" href="sql-language-reference.pdf" title="PDF File" type="application/pdf"></link>
      <meta name="robots" content="all"></meta>
      <link rel="schema.dcterms" href="http://purl.org/dc/terms/"></link>
      <meta name="dcterms.created" content="2019-02-12T15:36:36-08:00"></meta>
      
      <meta name="dcterms.dateCopyrighted" content="1996, 2019"></meta>
      <meta name="dcterms.category" content="database"></meta>
      <meta name="dcterms.identifier" content="E96310-02"></meta>
      
      <meta name="dcterms.product" content="en/database/oracle/oracle-database/19"></meta>
      
      <link rel="prev" href="Creating-Simple-Queries.html" title="Previous" type="text/html"></link>
      <link rel="next" href="The-UNION-ALL-INTERSECT-MINUS-Operators.html" title="Next" type="text/html"></link>
      <script>
        document.write('<style type="text/css">');
        document.write('body > .noscript, body > .noscript ~ * { visibility: hidden; }');
        document.write('</style>');
     </script>
      <script src="/sp_common/book-template/requirejs/require.js" data-main="/sp_common/book-template/ohc-book-template/js/book-config"></script>
      <script>
            if (window.require === undefined) {
                document.write('<script data-main="sp_common/book-template/ohc-book-template/js/book-config" src="sp_common/book-template/requirejs/require.js"><\/script>');
                document.write('<link href="sp_common/book-template/ohc-book-template/css/book.css" rel="stylesheet"/>');
            }
        </script>
      <script type="application/json" id="ssot-metadata">{"primary":{"category":{"short_name":"database","element_name":"Database","display_in_url":true},"suite":{"short_name":"oracle","element_name":"Oracle","display_in_url":true},"product_group":{"short_name":"not-applicable","element_name":"Not applicable","display_in_url":false},"product":{"short_name":"oracle-database","element_name":"Oracle Database","display_in_url":true},"release":{"short_name":"19","element_name":"Release 19","display_in_url":true}}}</script>
      
    <meta name="dcterms.title" content="SQL Language Reference"></meta>
    <meta name="dcterms.isVersionOf" content="SQLRF"></meta>
    <meta name="dcterms.release" content="Release 19"></meta>
  </head>
   <body dir="ltr">
      <div class="noscript alert alert-danger text-center" role="alert">
         <a href="Creating-Simple-Queries.html" class="pull-left"><span class="glyphicon glyphicon-chevron-left" aria-hidden="true"></span>上一页</a> <a href="The-UNION-ALL-INTERSECT-MINUS-Operators.html" class="pull-right">下一页<span class="glyphicon glyphicon-chevron-right" aria-hidden="true"></span></a> <span class="fa fa-exclamation-triangle" aria-hidden="true"></span>必须启用JavaScript才能正确显示此内容</div>
      <article>
         <header>
            <ol class="breadcrumb" vocab="http://schema.org/" typeof="BreadcrumbList">
               <li property="itemListElement" typeof="ListItem"><a href="index.html" property="item" typeof="WebPage"><span property="name">SQL语言参考</span></a></li>
               <li property="itemListElement" typeof="ListItem"><a href="SQL-Queries-and-Subqueries.html" property="item" typeof="WebPage"><span property="name">SQL查询和子查询</span></a></li>
               <li class="active" property="itemListElement" typeof="ListItem">分层查询</li>
            </ol>
            <a id="GUID-0118DF1D-B9A9-41EB-8556-C6E7D6A5A84E" name="GUID-0118DF1D-B9A9-41EB-8556-C6E7D6A5A84E"></a><a id="SQLRF52333"></a><a id="SQLRF52334"></a><a id="SQLRF52332"></a>
            
            <h2 id="SQLRF-GUID-0118DF1D-B9A9-41EB-8556-C6E7D6A5A84E" class="sect2">分层查询</h2>
         </header>
         <div class="ind">
            <div>
               <div class="section">
                  <p>如果表包含分层数据，则可以使用分层查询子句以分层顺序选择行：</p>
               </div>
               <!-- class="section" -->
               <div class="section">
                  <p class="subhead1" id="GUID-0118DF1D-B9A9-41EB-8556-C6E7D6A5A84E__GUID-5377971A-F518-47E4-8781-F06FEB3EF993"><span class="italic">hierarchical_query_clause</span> :: =</p>
               </div>
               <!-- class="section" -->
               <div class="section">
                  <div class="figure" id="GUID-0118DF1D-B9A9-41EB-8556-C6E7D6A5A84E__GUID-A7DD7BDA-E5BE-4BFA-9785-17F587E15C32"><img src="img/hierarchical_query_clause.gif" alt="hierarchy_query_clause.eps的描述如下" title="hierarchy_query_clause.eps的描述如下" longdesc="img_text/hierarchical_query_clause.html"><br><a href="img_text/hierarchical_query_clause.html">hierarchy_query_clause.eps插图的描述</a></div>
                  <!-- class="figure" -->
                  <p><span class="italic"><code class="codeph">condition</code></span>可以是如所描述的任何条件<a href="Conditions.html#GUID-C2E3ED44-16E7-4924-9125-E1693B1022A8">的条件</a> 。
                  </p>
                  <p><code class="codeph">START</code> <code class="codeph">WITH</code>指定层次结构的根行。
                  </p>
                  <p><code class="codeph">CONNECT</code> <code class="codeph">BY</code>指定层次结构的父行和子行之间的关系。
                  </p>
                  <ul style="list-style-type:disc">
                     <li>
                        <p>即使数据中存在<code class="codeph">CONNECT</code> <code class="codeph">BY</code>循环， <code class="codeph">NOCYCLE</code>参数也会指示Oracle数据库从查询中返回行。将此参数与<code class="codeph">CONNECT_BY_ISCYCLE</code>伪列一起使用，以查看哪些行包含循环。有关更多信息，请参阅<a href="Hierarchical-Query-Pseudocolumns.html#GUID-DA181C6B-7B13-41E3-AAF5-5C19963D9D1C">CONNECT_BY_ISCYCLE Pseudocolumn</a> 。
                        </p>
                     </li>
                     <li>
                        <p>在分层查询中，必须使用<code class="codeph">PRIOR</code>运算符限定<span class="italic"><code class="codeph">condition</code></span>一个表达式以引用父行。例如，</p><pre class="oac_no_warn" dir="ltr">...PRIOR expr = expr或... expr = PRIOR expr</pre><p>如果<code class="codeph">CONNECT</code> <code class="codeph">BY</code> <span class="italic"><code class="codeph">condition</code></span>是复合的，那么只有一个条件需要<code class="codeph">PRIOR</code>运算符，尽管您可以有多个<code class="codeph">PRIOR</code>条件。例如：</p><pre class="oac_no_warn" dir="ltr">CONNECT BY last_name！='King'AND PRIOR employee_id = manager_id ......CONNECT BY PRIOR employee_id = manager_id和PRIOR account_mgr_id = customer_id ...
</pre><p><code class="codeph">PRIOR</code>是一元运算符，与一元+和 - 算术运算符具有相同的优先级。它为分层查询中当前行的父行计算紧接着的表达式。
                        </p>
                        <p>在将列值与相等运算符进行比较时，最常用的是<code class="codeph">PRIOR</code> 。（ <code class="codeph">PRIOR</code>关键字可以位于运营商的任何一侧。）<code class="codeph">PRIOR</code>使Oracle使用列中父行的值。在<code class="codeph">CONNECT</code> <code class="codeph">BY</code>子句中理论上可以使用等号（=）以外的运算符。但是，这些其他运算符创建的条件可能会导致可能组合的无限循环。在这种情况下，Oracle在运行时检测循环并返回错误。
                        </p>
                     </li>
                  </ul>
                  <p><code class="codeph">CONNECT</code> <code class="codeph">BY</code>条件和<code class="codeph">PRIOR</code>表达式都可以采用不相关子查询的形式。但是， <code class="codeph">CURRVAL</code>和<code class="codeph">NEXTVAL</code>不是有效的<code class="codeph">PRIOR</code>表达式，因此<code class="codeph">PRIOR</code>表达式不能引用序列。
                  </p>
                  <p>您可以使用<code class="codeph">CONNECT_BY_ROOT</code>运算符进一步细化分层查询，以限定选择列表中的列。此运算符通过不仅返回直接父行而是返回层次结构中的所有祖先行来扩展分层查询的<code class="codeph">CONNECT</code> <code class="codeph">BY</code> [ <code class="codeph">PRIOR</code> ]条件的功能。
                  </p>
                  <div class="infoboxnotealso" id="GUID-0118DF1D-B9A9-41EB-8556-C6E7D6A5A84E__GUID-388CCF70-181A-4519-B8E0-4842D2E9BAE4">
                     <p class="notep1">也可以看看：</p>
                     <p><a href="Hierarchical-Query-Operators.html#GUID-875C8985-4AEF-4DF1-BA23-3CDF5BCBCD8E">CONNECT_BY_ROOT</a>有关此运算符和<span class="q">“ <a href="Hierarchical-Queries.html#GUID-E3D35EF7-33C3-4D88-81B3-00030C47AE56">分层查询示例</a> ”的</span>更多信息</p>
                  </div>
                  <p>Oracle处理分层查询，如下所示：</p>
                  <ul style="list-style-type:disc">
                     <li>
                        <p>首先计算连接（如果存在），无论是在<code class="codeph">FROM</code>子句中还是在<code class="codeph">WHERE</code>子句谓词中指定了连接。
                        </p>
                     </li>
                     <li>
                        <p>评估<code class="codeph">CONNECT</code> <code class="codeph">BY</code>条件。
                        </p>
                     </li>
                     <li>
                        <p>将评估任何剩余的<code class="codeph">WHERE</code>子句谓词。
                        </p>
                     </li>
                  </ul>
                  <p><a id="d194094e314" class="indexterm-anchor"></a><a id="d194094e318" class="indexterm-anchor"></a>然后，Oracle使用来自这些评估的信息，使用以下步骤形成层次结构：</p>
                  <ol>
                     <li>
                        <p>Oracle选择层次结构的根行 - 满足<code class="codeph">START</code> <code class="codeph">WITH</code>条件的那些行。
                        </p>
                     </li>
                     <li id="GUID-0118DF1D-B9A9-41EB-8556-C6E7D6A5A84E__I2070828">
                        <p>Oracle选择每个根行的子行。每个子行必须满足<code class="codeph">CONNECT</code> <code class="codeph">BY</code>条件相对于其中一个根行的条件。
                        </p>
                     </li>
                     <li>
                        <p>Oracle选择连续几代子行。Oracle首先选择步骤<a href="Hierarchical-Queries.html#GUID-0118DF1D-B9A9-41EB-8556-C6E7D6A5A84E__I2070828">2中</a>返回的行的子项，然后选择这些子项的子项，依此类推。Oracle总是通过评估关于当前父行的<code class="codeph">CONNECT</code> <code class="codeph">BY</code>条件来选择子项。
                        </p>
                     </li>
                     <li>
                        <p><a id="d194094e357" class="indexterm-anchor"></a>如果查询包含没有连接的<code class="codeph">WHERE</code>子句，则Oracle将从层次结构中删除不满足<code class="codeph">WHERE</code>子句条件的所有行。Oracle分别为每一行评估此条件，而不是删除不满足条件的行的所有子项。
                        </p>
                     </li>
                     <li>
                        <p>Oracle按照<a href="Hierarchical-Queries.html#GUID-0118DF1D-B9A9-41EB-8556-C6E7D6A5A84E__I2066595">图9-1</a>中<a href="Hierarchical-Queries.html#GUID-0118DF1D-B9A9-41EB-8556-C6E7D6A5A84E__I2066595">所示</a>的顺序返回行。在图中，孩子出现在父母的下方。有关分层树的说明，请参<a href="Hierarchical-Query-Pseudocolumns.html#GUID-D91FFF59-ECB0-40F0-AB4C-7A9D27EBEEF1__I1009270">见图3-1</a> 。
                        </p>
                     </li>
                  </ol>
                  <div class="figure" id="GUID-0118DF1D-B9A9-41EB-8556-C6E7D6A5A84E__I2066595">
                     <p class="titleinfigure">图9-1分层查询</p><img src="img/sqlrf002.gif" alt="下面是图9-1的描述" title="下面是图9-1的描述" longdesc="img_text/sqlrf002.html"><br><a href="img_text/sqlrf002.html">“图9-1分层查询”的描述</a></div>
                  <!-- class="figure" -->
                  <p><a id="d194094e381" class="indexterm-anchor"></a>为了查找父行的子节点，Oracle计算父行的<code class="codeph">CONNECT</code> <code class="codeph">BY</code>条件的<code class="codeph">PRIOR</code>表达式以及表中每行的另一个表达式。条件为真的行是父项的子项。<code class="codeph">CONNECT</code> <code class="codeph">BY</code>条件可以包含其他条件以进一步过滤查询选择的行。
                  </p>
                  <p>如果<code class="codeph">CONNECT</code> <code class="codeph">BY</code>条件导致层次结构中出现循环，则Oracle将返回错误。如果一行既是父行（或祖父母或直接祖先）又是另一行的子（或孙子或直接后代），则会发生循环。
                  </p>
                  <div class="infoboxnote" id="GUID-0118DF1D-B9A9-41EB-8556-C6E7D6A5A84E__GUID-20704C68-1D3C-4EDD-A8D5-621CC2FDD65C">
                     <p class="notep1">注意：</p>
                     <p>在分层查询中，不要指定<code class="codeph">ORDER</code> <code class="codeph">BY</code>或<code class="codeph">GROUP</code> <code class="codeph">BY</code> ，因为它们将覆盖<code class="codeph">CONNECT</code> <code class="codeph">BY</code>结果的层次结构顺序。如果要订购同一父级的兄弟节点行，请使用<code class="codeph">ORDER</code> <code class="codeph">SIBLINGS</code> <code class="codeph">BY</code>子句。请参阅<span class="italic"><a href="SELECT.html#GUID-CFA006CA-6FF1-4972-821E-6996142A51C6__I2171079">order_by_clause</a></span> 。
                     </p>
                  </div>
               </div>
               <!-- class="section" -->
            </div><a id="SQLRF52336"></a><a id="SQLRF52337"></a><a id="SQLRF52338"></a><a id="SQLRF52339"></a><a id="SQLRF52340"></a><a id="SQLRF52335"></a><div class="props_rev_3"><a id="GUID-E3D35EF7-33C3-4D88-81B3-00030C47AE56" name="GUID-E3D35EF7-33C3-4D88-81B3-00030C47AE56"></a><h3 id="SQLRF-GUID-E3D35EF7-33C3-4D88-81B3-00030C47AE56" class="sect3">分层查询示例</h3>
               <div>
                  <div class="section">
                     <p class="subhead2" id="GUID-E3D35EF7-33C3-4D88-81B3-00030C47AE56__GUID-E3E642E8-5214-4403-BB3B-93BE6C278033">通过示例连接</p>
                  </div>
                  <!-- class="section" -->
                  <div class="section">
                     <p>以下分层查询使用<code class="codeph">CONNECT</code> <code class="codeph">BY</code>子句定义员工和经理之间的关系：</p><pre class="oac_no_warn" dir="ltr">SELECT employee_id，last_name，manager_id FROM employees CONNECT BY PRIOR employee_id = manager_id; EMPLOYEE_ID LAST_NAME MANAGER_ID ----------- ------------------------- ---------- 101 Kochhar 100 108 Greenberg 101 109 Faviet 108 110 Chen 108 111 Sciarra 108 112 Urman 108 113 Popp 108 200 Whalen 101 203 Mavris 101 204 Baer 101。 。 。</pre></div>
                  <!-- class="section" -->
                  <div class="section">
                     <p class="subhead2" id="GUID-E3D35EF7-33C3-4D88-81B3-00030C47AE56__GUID-D1993AA0-FA94-4A30-8944-BC6526B7B489">等级示例</p>
                  </div>
                  <!-- class="section" -->
                  <div class="section">
                     <p>下一个示例与前面的示例类似，但使用<code class="codeph">LEVEL</code>伪列显示父行和子行：</p><pre class="oac_no_warn" dir="ltr">SELECT employee_id，last_name，manager_id，LEVEL FROM employees CONNECT BY PRIOR employee_id = manager_id; EMPLOYEE_ID LAST_NAME MANAGER_ID等级----------- ------------------------- ---------- ---------- 101 Kochhar 100 1 108 Greenberg 101 2 109 Faviet 108 3 110 Chen 108 3 111 Sciarra 108 3 112 Urman 108 3 113 Popp 108 3 200 Whalen 101 2 203 Mavris 101 2 204 Baer 101 2 205希金斯101 2 206 Gietz 205 3 102 De Haan 100 1 ...</pre></div>
                  <!-- class="section" -->
                  <div class="section">
                     <p class="subhead2" id="GUID-E3D35EF7-33C3-4D88-81B3-00030C47AE56__GUID-192F2312-D10C-494C-A968-1C8237843BC6">从示例开始</p>
                  </div>
                  <!-- class="section" -->
                  <div class="section">
                     <p>下一个示例添加<code class="codeph">START</code> <code class="codeph">WITH</code>子句以指定层次结构的根行，使用<code class="codeph">SIBLINGS</code>子句添加<code class="codeph">ORDER</code> <code class="codeph">BY</code>子句以保留层次结构中的排序：</p><pre class="oac_no_warn" dir="ltr">SELECT last_name，employee_id，manager_id，LEVEL FROM employees START WITH employee_id = 100 CONNECT BY PRIOR employee_id = manager_id ORDER SIBLINGS BY last_name; LAST_NAME EMPLOYEE_ID MANAGER_ID等级------------------------- ----------- ---------- ---------- King 100 1 Cambrault 148 100 2 Bates 172 148 3 Bloom 169 148 3 Fox 170 148 3 Kumar 173 148 3 Ozer 168 148 3 Smith 171 148 3 De Haan 102 100 2 Hunold 103 102 3 Austin 105 103 4 Ernst 104 103 4 Lorentz 107 103 4 Pataballa 106 103 4 Errazuriz 147 100 2 Ande 166 147 3 Banda 167 147 3 ...
</pre><p>在<code class="codeph">hr.employees</code>表中，员工Steven King是公司的负责人，没有经理。他的员工中包括John Russell，他是80部门的经理。如果更新<code class="codeph">employees</code>表以将Russell设置为King的管理器，则在数据中创建一个循环：</p><pre class="oac_no_warn" dir="ltr">UPDATE员工SET manager_id = 145 WHERE employee_id = 100; SELECT last_name“Employee”，LEVEL，SYS_CONNECT_BY_PATH（last_name，'/'）“Path”FROM employees WHERE level &lt;= 3 AND department_id = 80 START WITH last_name ='King'CONNECT BY PRIOR employee_id = manager_id AND LEVEL &lt;= 4;错误：ORA-01436：用户数据中的CONNECT BY循环</pre><p><code class="codeph">CONNECT</code> <code class="codeph">BY</code>条件中的<code class="codeph">NOCYCLE</code>参数使Oracle无论循环如何都返回行。<code class="codeph">CONNECT_BY_ISCYCLE</code>伪列显示哪些行包含循环：</p><pre class="oac_no_warn" dir="ltr">SELECT last_name“Employee”，CONNECT_BY_ISCYCLE“Cycle”，LEVEL，SYS_CONNECT_BY_PATH（last_name，'/'）“Path”FROM employees WHERE level &lt;= 3 AND department_id = 80 START WITH last_name ='King'CONNECT BY NOCYCLE PRIOR employee_id = manager_id AND LEVEL &lt;= 4 ORDER BY“Employee”，“Cycle”，LEVEL，“Path”;员工周期级别路径------------------------- ---------- ----------  - ------------------------ Abel 0 3 / King / Zlotkey / Abel Ande 0 3 / King / Errazuriz / Ande Banda 0 3 / King / Errazuriz / Banda Bates 0 3 / King / Cambrault / Bates Bernstein 0 3 / King / Russell / Bernstein Bloom 0 3 / King / Cambrault / Bloom Cambrault 0 2 / King / Cambrault Cambrault 0 3 / King / Russell / Cambrault Doran 0 3 / King / Partners / Doran Errazuriz 0 2 / King / Errazuriz Fox 0 3 / King / Cambrault / Fox ......</pre></div>
                  <!-- class="section" -->
                  <div class="section">
                     <p class="subhead2" id="GUID-E3D35EF7-33C3-4D88-81B3-00030C47AE56__GUID-C4174B47-CA82-4580-86D3-173E499E1205">CONNECT_BY_ISLEAF示例</p>
                  </div>
                  <!-- class="section" -->
                  <div class="section">
                     <p>以下语句显示如何使用分层查询将列中的值转换为逗号分隔的列表：</p><pre class="oac_no_warn" dir="ltr">SELECT LTRIM（SYS_CONNECT_BY_PATH（warehouse_id，'，'），'，'）FROM（SELECT ROWNUM r，warehouse_id FROM仓库）WHERE CONNECT_BY_ISLEAF = 1 START WITH r = 1 CONNECT BY r = PRIOR r + 1 ORDER by warehouse_id; LTRIM（SYS_CONNECT_BY_PATH（WAREHOUSE_ID，'，'），'，'）----------------------------------- --------------------------------------------- 1,2,3 ，4,5,6,7,8,9</pre></div>
                  <!-- class="section" -->
                  <div class="section" id="GUID-E3D35EF7-33C3-4D88-81B3-00030C47AE56__I2069380">
                     <p class="subhead2" id="GUID-E3D35EF7-33C3-4D88-81B3-00030C47AE56__GUID-267FA07A-8754-4D84-A351-8FAD3C36F746">CONNECT_BY_ROOT示例</p>
                  </div>
                  <!-- class="section" -->
                  <div class="section">
                     <p>以下示例返回部门110中每个员工的姓氏，每个管理员位于层次结构中该员工之上的最高级别，经理和员工之间的级别数，以及两者之间的路径：</p><pre class="oac_no_warn" dir="ltr">SELECT last_name“Employee”，CONNECT_BY_ROOT last_name“Manager”，LEVEL-1“Pathlen”，SYS_CONNECT_BY_PATH（last_name，'/'）“Path”FROM employees WHERE LEVEL&gt; 1 and department_id = 110 CONNECT BY PRIOR employee_id = manager_id ORDER BY“Employee “，”经理“，”Pathlen“，”路径“;员工经理Pathlen Path --------------- --------------- ---------- ------ ------------------------ Gietz Higgins 1 / Higgins / Gietz Gietz King 3 / King / Kochhar / Higgins / Gietz Gietz Kochhar 2 / Kochhar / Higgins / Gietz Higgins King 2 / King / Kochhar / Higgins Higgins Kochhar 1 / Kochhar / Higgins</pre><p>以下示例使用<code class="codeph">GROUP</code> <code class="codeph">BY</code>子句返回部门110中每个员工的总薪水以及层次结构中该员工以上的所有员工：</p><pre class="oac_no_warn" dir="ltr">SELECT名称，SUM（薪水）“Total_Salary”FROM（SELECT CONNECT_BY_ROOT last_name as name，Salary FROM employees WHERE department_id = 110 CONNECT BY PRIOR employee_id = manager_id）GROUP BY name ORDER BY name，“Total_Salary”; NAME Total_Salary ------------------------- ------------ Gietz 8300 Higgins 20300 King 20300 Kochhar 20300</pre><p></p>
                     <div class="infoboxnotealso" id="GUID-E3D35EF7-33C3-4D88-81B3-00030C47AE56__GUID-2E95509C-B23B-45EC-9A11-2DFE548FD7B9">
                        <p class="notep1">也可以看看：</p>
                        <ul style="list-style-type:disc">
                           <li>
                              <p><a href="Hierarchical-Query-Pseudocolumns.html#GUID-D91FFF59-ECB0-40F0-AB4C-7A9D27EBEEF1">LEVEL Pseudocolumn</a>和<a href="Hierarchical-Query-Pseudocolumns.html#GUID-DA181C6B-7B13-41E3-AAF5-5C19963D9D1C">CONNECT_BY_ISCYCLE Pseudocolumn，</a>用于讨论这些伪列如何在分层查询中运行</p>
                           </li>
                           <li>
                              <p><a href="SYS_CONNECT_BY_PATH.html#GUID-D25A0F86-B559-4090-9164-7A2C84D1E11E">SYS_CONNECT_BY_PATH，</a>用于获取有关从根到节点检索列值路径的信息</p>
                           </li>
                           <li>
                              <p><span class="italic"><a href="SELECT.html#GUID-CFA006CA-6FF1-4972-821E-6996142A51C6__I2171079">order_by_clause</a></span>有关<code class="codeph">ORDER</code> <code class="codeph">BY</code>子句的<code class="codeph">SIBLINGS</code>关键字的更多信息</p>
                           </li>
                           <li>
                              <p><span class="italic"><a href="SELECT.html#GUID-CFA006CA-6FF1-4972-821E-6996142A51C6__I2077142">subquery_factoring_clause</a></span> ，支持递归子查询因子分析（递归WITH），并允许您查询分层数据。此功能比<code class="codeph">CONNECT</code> <code class="codeph">BY</code>更强大，因为它提供深度优先搜索和广度优先搜索，并支持多个递归分支。
                              </p>
                           </li>
                        </ul>
                     </div>
                  </div>
                  <!-- class="section" -->
               </div>
            </div>
         </div>
      </article>
   </body>
</html>