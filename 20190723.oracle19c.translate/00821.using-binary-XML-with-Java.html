<html lang="en-us" dir="ltr" xml:lang="en-us">
   <head>
      <meta http-equiv="Content-Type" content="text/html; charset=utf-8"></meta>
      <meta name="viewport" content="width=device-width, initial-scale=1"></meta>
      <meta http-equiv="X-UA-Compatible" content="IE=edge"></meta>
      <meta name="abstract" content="Topics here explain how to use Binary XML with Java."></meta>
      <meta name="description" content="Topics here explain how to use Binary XML with Java."></meta>
      <title>在Java中使用二进制XML</title>
      <meta property="og:site_name" content="Oracle Help Center"></meta>
      <meta property="og:title" content="Programmer&#39;s Guide"></meta>
      <meta property="og:description" content="Topics here explain how to use Binary XML with Java."></meta>
      <link rel="stylesheet" href="/sp_common/book-template/ohc-book-template/css/book.css"></link>
      <link rel="shortcut icon" href="/sp_common/book-template/ohc-common/img/favicon.ico"></link>
      <meta name="application-name" content="Programmer&#39;s Guide"></meta>
      <meta name="generator" content="DITA Open Toolkit version 1.8.5 (Mode = doc)"></meta>
      <meta name="plugin" content="SP_docbuilder HTML plugin release 18.2.2"></meta>
      <link rel="alternate" href="xml-developers-kit-programmers-guide.pdf" title="PDF File" type="application/pdf"></link>
      <meta name="robots" content="all"></meta>
      <link rel="schema.dcterms" href="http://purl.org/dc/terms/"></link>
      <meta name="dcterms.created" content="2019-01-11T05:58:48-08:00"></meta>
      
      <meta name="dcterms.dateCopyrighted" content="2001, 2019"></meta>
      <meta name="dcterms.category" content="database"></meta>
      <meta name="dcterms.identifier" content="E96292-01"></meta>
      
      <meta name="dcterms.product" content="en/database/oracle/oracle-database/19"></meta>
      
      <link rel="prev" href="XML-parsing-for-Java.html" title="Previous" type="text/html"></link>
      <link rel="next" href="using-XSLT-processor-for-Java.html" title="Next" type="text/html"></link>
      <script>
        document.write('<style type="text/css">');
        document.write('body > .noscript, body > .noscript ~ * { visibility: hidden; }');
        document.write('</style>');
     </script>
      <script src="/sp_common/book-template/requirejs/require.js" data-main="/sp_common/book-template/ohc-book-template/js/book-config"></script>
      <script>
            if (window.require === undefined) {
                document.write('<script data-main="sp_common/book-template/ohc-book-template/js/book-config" src="sp_common/book-template/requirejs/require.js"><\/script>');
                document.write('<link href="sp_common/book-template/ohc-book-template/css/book.css" rel="stylesheet"/>');
            }
        </script>
      <script type="application/json" id="ssot-metadata">{"primary":{"category":{"short_name":"database","element_name":"Database","display_in_url":true},"suite":{"short_name":"oracle","element_name":"Oracle","display_in_url":true},"product_group":{"short_name":"not-applicable","element_name":"Not applicable","display_in_url":false},"product":{"short_name":"oracle-database","element_name":"Oracle Database","display_in_url":true},"release":{"short_name":"19","element_name":"Release 19","display_in_url":true}}}</script>
      
    <meta name="dcterms.title" content="XML Developers Kit Programmers Guide"></meta>
    <meta name="dcterms.isVersionOf" content="ADXDK"></meta>
    <meta name="dcterms.release" content="Release 19"></meta>
  </head>
   <body dir="ltr">
      <div class="noscript alert alert-danger text-center" role="alert">
         <a href="XML-parsing-for-Java.html" class="pull-left"><span class="glyphicon glyphicon-chevron-left" aria-hidden="true"></span>上一页</a> <a href="using-XSLT-processor-for-Java.html" class="pull-right">下一页<span class="glyphicon glyphicon-chevron-right" aria-hidden="true"></span></a> <span class="fa fa-exclamation-triangle" aria-hidden="true"></span>必须启用JavaScript才能正确显示此内容</div>
      <article>
         <header>
            <ol class="breadcrumb" vocab="http://schema.org/" typeof="BreadcrumbList">
               <li property="itemListElement" typeof="ListItem"><a href="index.html" property="item" typeof="WebPage"><span property="name">程序员指南</span></a></li>
               <li property="itemListElement" typeof="ListItem"><a href="XDK-for-Java.html" property="item" typeof="WebPage"><span property="name">Oracle XML Developer's Kit for Java</span></a></li>
               <li class="active" property="itemListElement" typeof="ListItem">在Java中使用二进制XML</li>
            </ol>
            <a id="GUID-38D2C558-108C-449A-A9CD-BC2DAD163D5C" name="GUID-38D2C558-108C-449A-A9CD-BC2DAD163D5C"></a><a id="ADXDK985"></a><a id="ADXDK4440"></a>
            
            <h2 id="ADXDK-GUID-38D2C558-108C-449A-A9CD-BC2DAD163D5C" class="sect2"><span class="enumeration_chapter">13</span>将二进制XML与Java结合使用</h2>
         </header>
         <div class="ind">
            <div>
               <p>这里的主题解释了如何在Java中使用二进制XML。</p>
               <div class="section"> </div>
               <!-- class="section" -->
            </div><a id="ADXDK19188"></a><div class="props_rev_3"><a id="GUID-AE28E8A2-6782-4517-A8F3-9937198DE3CA" name="GUID-AE28E8A2-6782-4517-A8F3-9937198DE3CA"></a><h3 id="ADXDK-GUID-AE28E8A2-6782-4517-A8F3-9937198DE3CA" class="sect3">二进制XML for Java简介</h3>
               <div>
                  <p>二进制XML使得在XML文本和压缩二进制XML之间进行编码和解码成为可能。应用程序编程接口（API）在二进制XML之上提供，供XML应用程序直接使用。XML文档片段的压缩和解压缩有助于增量处理。</p>
                  <p>本章假定您熟悉XML Parser for Java。</p>
               </div>
               <div>
                  <div class="relinfo">
                     <p><strong>相关话题</strong></p>
                     <ul>
                        <li><a href="XML-parsing-for-Java.html#GUID-33E0EA2B-A08A-462E-86B4-3F944409663D" title="描述了针对Java的可扩展标记语言（XML）解析。">用于Java的XML解析</a></li>
                     </ul>
                  </div>
               </div>
               <a id="ADXDK19189"></a><div class="props_rev_3"><a id="GUID-5D946D12-1531-453E-BFD0-4B25320D9DF2" name="GUID-5D946D12-1531-453E-BFD0-4B25320D9DF2"></a><h4 id="ADXDK-GUID-5D946D12-1531-453E-BFD0-4B25320D9DF2" class="sect4">二进制XML存储格式 -  Java</h4>
                  <div>
                     <p>二进制XML是一种紧凑的XML-Schema-aware XML数据编码，但它可以与不基于XML模式的XML数据一起使用。您还可以将二进制XML用于数据库外部的XML数据（例如，在客户端应用程序中）。二进制XML允许对XML文档进行编码和解码，从文本到二进制，二进制到文本。二进制XML是具有本机数据库数据类型的解析后持久XML。</p>
                     <p>可以使用二进制XML存储选项创建<code class="codeph">XMLType</code>表和列。可以通过所有现有的结构化查询语言（SQL）运算符和函数以及对<code class="codeph">XMLType</code>进行操作的过程语言/结构化查询语言（PL / SQL）API来访问和操作二进制格式的XML数据。
                     </p>
                     <p>与非结构化存储相比，二进制XML提供了更高效的数据库存储，更新，索引，查询性能和片段提取。它可以将数据和元数据一起存储或单独存储。</p>
                     <div class="infoboxnotealso" id="GUID-5D946D12-1531-453E-BFD0-4B25320D9DF2__GUID-5682634E-83BD-4A85-96F9-7523D386D909">
                        <p class="notep1">也可以看看：</p>
                        <p><a href="../adxdb/intro-to-XML-DB.html#ADXDB0120" target="_blank"><span><cite>Oracle XML DB Developer's Guide，</cite></span></a>用于讨论Oracle XML DB中的所有存储模型。</p>
                     </div>
                  </div>
               </div><a id="ADXDK19190"></a><div class="props_rev_3"><a id="GUID-AD4B1CA9-CAAD-4F86-89DD-A77B33AEDBB3" name="GUID-AD4B1CA9-CAAD-4F86-89DD-A77B33AEDBB3"></a><h4 id="ADXDK-GUID-AD4B1CA9-CAAD-4F86-89DD-A77B33AEDBB3" class="sect4">二进制XML处理器</h4>
                  <div>
                     <p><span class="italic">二进制XML处理器</span>是用于处理二进制XML到文本和XML文本到二进制XML的组件的抽象术语。它还可以提供用于存储模式的缓存。二进制XML处理器可以发起或接收网络协议请求。
                     </p>
                     <p>二进制XML处理器的基类是<code class="codeph">BinXMLProcessor</code> 。
                     </p>
                  </div>
               </div>
            </div><a id="ADXDK19191"></a><div class="props_rev_3"><a id="GUID-346318B9-78D9-4B61-AE84-1EB09FA47B8C" name="GUID-346318B9-78D9-4B61-AE84-1EB09FA47B8C"></a><h3 id="ADXDK-GUID-346318B9-78D9-4B61-AE84-1EB09FA47B8C" class="sect3">使用二进制XML的模型</h3>
               <div>
                  <p>在应用程序中使用二进制XML有几种模型。这些小节描述了使用二进制XML的术语和模型。</p>
               </div><a id="ADXDK19192"></a><div class="props_rev_3"><a id="GUID-DCAAAD9D-B314-4B47-AA1F-B9C26B548D3B" name="GUID-DCAAAD9D-B314-4B47-AA1F-B9C26B548D3B"></a><h4 id="ADXDK-GUID-DCAAAD9D-B314-4B47-AA1F-B9C26B548D3B" class="sect4">二进制XML的使用术语</h4>
                  <div>
                     <p>描述了与二进制XML使用相关的术语。</p>
                     <ul style="list-style-type:disc">
                        <li>
                           <p><span class="italic">doc-id</span> ：每个编码的XML文档都由唯一的doc-id标识。它是一个16字节的全局用户标识符（GUID）或像URL一样的不透明字节序列。</p>
                        </li>
                        <li>
                           <p><span class="italic">令牌表</span> ：当文本XML文档没有与之关联的架构时，则使用令牌（或符号）表来最小化重复项的空间。
                           </p>
                        </li>
                        <li>
                           <p><span class="italic">词汇表id</span> ：可以是令牌表的schema-id或名称空间统一资源标识符（URI）。
                           </p>
                        </li>
                        <li>
                           <p><span class="italic">schema-id</span> ：作用于二进制XML处理器的模式的唯一不透明二进制标识符。schema-id对于二进制XML处理器是唯一的，并且仅在该二进制XML处理器的范围内可识别。即使架构发展，schema-id仍保持不变。schema-id表示整个模式文档集，包括导入和包含的模式。
                           </p>
                        </li>
                        <li>
                           <p><span class="italic">schema version</span> ：每个带注释的模式都有一个与之关联的版本号。版本号被指定为系统级注释的一部分。当演进模式时，它由二进制XML处理器递增（即，使用二进制XML处理器注册相同模式的新版本）。
                           </p>
                        </li>
                        <li>
                           <p><span class="italic">部分有效性</span> ：使用模式的二进制XML流编码意味着至少部分有效的模式。部分有效性意味着不对唯一键，keyref，标识符（ID）或DTD属性（如IDREF）进行验证。</p>
                        </li>
                     </ul>
                  </div>
               </div><a id="ADXDK19193"></a><div class="props_rev_3"><a id="GUID-C6CAD115-2D13-40D8-A2C9-583D300B1172" name="GUID-C6CAD115-2D13-40D8-A2C9-583D300B1172"></a><h4 id="ADXDK-GUID-C6CAD115-2D13-40D8-A2C9-583D300B1172" class="sect4">独立模型</h4>
                  <div>
                     <p>这是二进制XML的最简单的使用场景。有一个二进制XML处理器。</p>
                     <p>唯一可用的存储库是本地内存中的词汇表缓存，它不是持久的，只能在二进制XML处理器的生命周期中使用。所有模式必须在编码之前使用二进制XML Processor预先注册，或者在XML Processor看到<code class="codeph">xsi:SchemaLocation</code>标记时自动注册它们。对于解码，模式已在词汇表缓存中可用。
                     </p>
                  </div>
               </div><a id="ADXDK19194"></a><div class="props_rev_3"><a id="GUID-338EF075-9FC3-4FFA-A165-66839D894092" name="GUID-338EF075-9FC3-4FFA-A165-66839D894092"></a><h4 id="ADXDK-GUID-338EF075-9FC3-4FFA-A165-66839D894092" class="sect4">客户/服务器模型</h4>
                  <div>
                     <p>在客户端 - 服务器方案中，二进制XML处理器使用Java数据库连接（JDBC）连接到数据库。假设在编码之前向数据库注册了XML模式。</p>
                     <p>以下是如何实现这一目标的示例：</p><pre class="oac_no_warn" dir="ltr">BEGIN DBMS_XMLSCHEMA.registerSchema（SCHEMAURL =&gt;'http://xmlns.oracle.com/xdb/documentation/purchaseOrder.xsd',SCHEMADOC =&gt; bfilename（'XMLDIR'，'purchaseOrder.xsd'），CSID =&gt; nls_charset_id（' AL32UTF8'），GENTYPES =&gt; FALSE，OPTIONS =&gt; REGISTER_BINARYXML）;结束; /</pre><p>除非为数据指定单独的连接（使用<code class="codeph">associateDataConnection()</code> ），否则假定使用单个连接存储和检索所有数据和元数据以进行编码和解码。
                     </p>
                  </div>
               </div><a id="ADXDK19195"></a><div class="props_rev_3"><a id="GUID-CB4F1034-DFF8-4F5B-83AC-EC0398FA82C7" name="GUID-CB4F1034-DFF8-4F5B-83AC-EC0398FA82C7"></a><h4 id="ADXDK-GUID-CB4F1034-DFF8-4F5B-83AC-EC0398FA82C7" class="sect4">带存储库的Web服务模型</h4>
                  <div>
                     <p>在这种情况下，有多个客户端，每个客户端运行二进制XML处理器。一个编码，另一个解码。有一个公共存储库（不一定是数据库）连接到所有客户端以进行元数据存储。它可以是文件系统或其他一些存储库。</p>
                     <p>第一个二进制XML处理器确保在执行编码之前向存储库注册了模式，或者可以在编码时使用<code class="codeph">xsi:schemaLocation</code>标记自动注册模式。第二个二进制XML处理器用于解码，不知道模式的位置，并从存储库中获取模式。
                     </p>
                     <p>如果第一个二进制XML处理器注册了一个模式，而第二个二进制XML处理器在存储库中注册了相同的模式，则二进制XML处理器不会编译模式，而只是返回本地词汇表缓存中现有编译模式的<code class="codeph">vocabulary-id</code> 。
                     </p>
                     <p><code class="codeph">BinXMLProcessor</code>不是线程安全的，因此访问存储库的多个线程或客户端必须实现自己的线程安全方案。
                     </p>
                  </div>
               </div><a id="ADXDK19196"></a><div class="props_rev_3"><a id="GUID-8462F9AB-ED74-4D79-A75A-2E7DA7081F4D" name="GUID-8462F9AB-ED74-4D79-A75A-2E7DA7081F4D"></a><h4 id="ADXDK-GUID-8462F9AB-ED74-4D79-A75A-2E7DA7081F4D" class="sect4">没有存储库的Web服务模型</h4>
                  <div>
                     <p>在这种情况下，有多个客户端，每个客户端运行二进制XML处理器。编码和解码可以在不同的客户端上进行。没有共同的元数据存储库。</p>
                     <p>编码器必须确保传递给下一个客户端的二进制数据独立于模式：即具有内联标记定义。这可以通过在编码期间使用<code class="codeph">setProperty()</code>方法设置<code class="codeph">schemaAware</code> = <code class="codeph">false</code>和<code class="codeph">inlineTokenDefs</code> = <code class="codeph">true</code>来实现。解码时，不需要架构。
                     </p>
                  </div>
               </div>
            </div><a id="ADXDK19197"></a><div class="props_rev_3"><a id="GUID-A7BD5ED7-A114-4066-A2FF-DE400F37E6D5" name="GUID-A7BD5ED7-A114-4066-A2FF-DE400F37E6D5"></a><h3 id="ADXDK-GUID-A7BD5ED7-A114-4066-A2FF-DE400F37E6D5" class="sect3">二进制XML for Java的组件</h3>
               <div>
                  <p>描述了用于Java的二进制XML的组件。</p>
                  <p>这些是组件：</p>
                  <ul style="list-style-type:disc">
                     <li>
                        <p>二进制XML编码 - 二进制XML编码器将XML 1.0信息集转换为二进制XML。</p>
                     </li>
                     <li>
                        <p>二进制XML解码 - 二进制XML解码器将二进制XML转换为XML信息集。</p>
                     </li>
                     <li>
                        <p>二进制XML词汇表管理，包括模式管理和令牌管理。</p>
                     </li>
                  </ul>
               </div><a id="ADXDK19198"></a><div class="props_rev_3"><a id="GUID-D70995F6-C8A4-45E4-B6D1-D8258FBA37D2" name="GUID-D70995F6-C8A4-45E4-B6D1-D8258FBA37D2"></a><h4 id="ADXDK-GUID-D70995F6-C8A4-45E4-B6D1-D8258FBA37D2" class="sect4">二进制XML编码</h4>
                  <div>
                     <p>编码器是从<code class="codeph">BinXMLStream</code>创建的。它将XML文本作为输入，并将编码的二进制XML输出到<code class="codeph">BinXMLStream</code> 。它使用流式SAX读取XML文本。 XML文本的编码基于解析XML文本的结果。
                     </p>
                     <p>在编码器上设置<code class="codeph">schemaAware</code>标志，指定编码是模式感知还是无模式。
                     </p>
                     <p>对于模式感知编码，编码器确定是否已向词汇表管理器注册具有指定模式URL的模式。对于基于存储库或基于数据库的处理器，编码器基于架构URL向存储库或数据库查询已编译的架构。如果模式在数据库中可用，则以二进制XML格式从存储库或数据库中获取该模式，并向本地词汇表管理器注册。词汇表是架构。</p>
                     <p>还设置一个标志，指示编码生成独立于模式的二进制XML流。在这种情况下，生成的二进制XML流包含内联的所有标记定义，并且不依赖于模式或外部标记集。</p>
                     <p>如果编码是模式感知的，则编码器使用来自模式对象的数据类型信息来更有效地编码SAX流。存在与每个模式内置数据类型相关联的默认编码数据类型。使用模式的二进制XML流编码意味着至少部分有效使用模式（对于部分有效性，不对唯一密钥，keyref或ID或DTD属性（如IDREF）进行验证）。如果已知数据对于模式完全有效，则编码的二进制XML流存储该信息。</p>
                     <div class="infoboxnotealso" id="GUID-D70995F6-C8A4-45E4-B6D1-D8258FBA37D2__GUID-EC94B7DB-F670-4389-948B-4D95D1B8C358">
                        <p class="notep1">也可以看看：</p>
                        <p><a href="../adxdb/XML-Schema-and-query-basic.html#ADXDB0600" target="_blank"><span><cite>Oracle XML DB Developer's Guide，</cite></span></a>用于表示二进制编码数据类型及其来自XML模式数据类型的映射</p>
                     </div>
                     <p>如果没有与文本XML关联的模式，则为文本XML中的重复项生成整数标记ID。创建令牌ID和令牌定义的令牌表是一种重要的压缩技术。令牌定义作为令牌表存储在词汇表缓存中。如果设置了内联标记定义的属性，则标记定义以内联方式显示。</p>
                     <p>编码器上的另一个属性是指定PSVI（Post-Schema-Validated Infoset）信息作为二进制流的一部分。如果将其设置为true，则可以使用针对DOM上的PSVI的XDK扩展API来访问PSVI信息。如果<code class="codeph">psvi = true</code>则使用模式完全验证输入XML。如果<code class="codeph">psvi</code>为<code class="codeph">false</code>则输出二进制流中不包含PSVI信息。默认值为<code class="codeph">false</code> 。
                     </p>
                  </div>
                  <div>
                     <div class="relinfo">
                        <p><strong>相关话题</strong></p>
                        <ul>
                           <li><a href="using-binary-XML-with-Java.html#GUID-64183150-1F23-48A4-A1E8-81A0CD512429" title="令牌集可以从数据库或元数据存储库中获取，缓存在本地词汇表管理器中，并用于解码。在编码时，可以将令牌集推送到存储库以实现持久性。">令牌管理</a></li>
                        </ul>
                     </div>
                  </div>
                  
               </div><a id="ADXDK19199"></a><div class="props_rev_3"><a id="GUID-0A974367-AA47-40B2-A558-625A6BF3CE11" name="GUID-0A974367-AA47-40B2-A558-625A6BF3CE11"></a><h4 id="ADXDK-GUID-0A974367-AA47-40B2-A558-625A6BF3CE11" class="sect4">二进制XML解码</h4>
                  <div>
                     <p>二进制XML解码器将二进制XML转换为XML信息集。解码器是从<code class="codeph">BinXMLStream</code>创建的;它从此流中读取二进制XML并输出SAX事件或提供拉式<code class="codeph">InfosetReader</code> API以读取已解码的XML。</p>
                     <p>如果XML模式与<code class="codeph">BinXMLStream</code>相关联，则二进制XML解码器在解码之前使用词汇表id从词汇表缓存中检索关联的模式对象。如果模式在词汇表缓存中不可用并且服务器的连接信息可用，则从服务器获取模式。
                     </p>
                     <p>如果没有架构与<code class="codeph">BinXMLStream</code>相关联，则令牌定义可以在<code class="codeph">BinXMLStream</code>内联或存储在令牌集中。如果相应命名空间的标记未存储在本地词汇表缓存中，则从存储库中提取标记集。
                     </p>
                  </div>
               </div>
            </div><a id="ADXDK19200"></a><div class="props_rev_3"><a id="GUID-4B039190-876F-4A6A-8562-7E73AF36F40F" name="GUID-4B039190-876F-4A6A-8562-7E73AF36F40F"></a><h3 id="ADXDK-GUID-4B039190-876F-4A6A-8562-7E73AF36F40F" class="sect3">二进制XML词汇管理</h3>
               <div>
                  <p>二进制XML处理器具有不同的类型，具体取决于元数据（模式或令牌集）所在的位置 - 本地二进制XML处理器或存储库二进制XML处理器。</p>
               </div><a id="ADXDK19201"></a><div class="props_rev_3"><a id="GUID-7AD473C7-8966-4C17-AF64-7865D70FC486" name="GUID-7AD473C7-8966-4C17-AF64-7865D70FC486"></a><h4 id="ADXDK-GUID-7AD473C7-8966-4C17-AF64-7865D70FC486" class="sect4">架构管理</h4>
                  <div>
                     <p>对于元数据持久性，Oracle建议您使用DB二进制XML处理器。在这种情况下，模式和令牌集已在数据库中注册。词汇表管理器从数据库中提取模式或令牌集，并将其缓存在本地词汇表缓存中以进行编码和解码。</p>
                     <p>如果必须使用不是数据库的持久性元数据存储库，则可以插入自己的元数据存储库。您必须实现与此存储库<code class="codeph">BinXMLMetadataProvider</code>进行通信的接口。
                     </p>
                  </div>
                  <div>
                     <div class="relinfo">
                        <p><strong>相关话题</strong></p>
                        <ul>
                           <li><a href="using-binary-XML-with-Java.html#GUID-04F717C4-91CC-472B-99FB-38F133F80797" title="二进制XML处理器可以与数据库通信，以进行各种类型的二进制XML操作，包括存储和检索二进制XML模式，令牌集和二进制XML流。">二进制XML</a></li>
                        </ul>
                     </div>
                  </div>
                  <a id="ADXDK19202"></a><div class="props_rev_3"><a id="GUID-7F2B4014-6718-47F1-989E-C5F1493B2B81" name="GUID-7F2B4014-6718-47F1-989E-C5F1493B2B81"></a><h5 id="ADXDK-GUID-7F2B4014-6718-47F1-989E-C5F1493B2B81" class="sect5">二进制XML词汇管理的模式注册</h5>
                     <div>
                        <p>使用本地二进制XML处理器在本地注册XML模式。它包含一个词汇表管理器，用于维护用户在其存在期间提交的所有XML模式。与本地二进制XML处理器关联的词汇表管理器不提供XML架构持久性。</p>
                        <p>如果再次注册相同的XML模式（相同的模式位置和相同的目标名称空间），则不会对其进行解析，并返回现有的词汇表标识符。</p>
                        <p>如果注册了具有相同目标命名空间和不同模式位置的新XML模式，则使用新模式定义扩充现有XML模式定义。如果发生冲突，则会引发错误。</p>
                     </div>
                  </div><a id="ADXDK19203"></a><div class="props_rev_3"><a id="GUID-AE236BD0-59D1-40C9-A1B3-A9C3EE0B5641" name="GUID-AE236BD0-59D1-40C9-A1B3-A9C3EE0B5641"></a><h5 id="ADXDK-GUID-AE236BD0-59D1-40C9-A1B3-A9C3EE0B5641" class="sect5">架构识别</h5>
                     <div>
                        <p>每个模式由词汇表id标识。词汇表id在处理器的范围内，并且在处理器内是唯一的。任何使用模式验证的文档都需要使用最新版本的模式进行验证。</p>
                     </div>
                  </div><a id="ADXDK19204"></a><div class="props_rev_3"><a id="GUID-2A575201-65AD-4DF9-B655-6A42BEF25610" name="GUID-2A575201-65AD-4DF9-B655-6A42BEF25610"></a><h5 id="ADXDK-GUID-2A575201-65AD-4DF9-B655-6A42BEF25610" class="sect5">架构注释</h5>
                     <div>
                        <p>二进制XML模式注释只能出现在XML模式中的元素<code class="codeph">&lt;xsd:appInfo&gt;</code>中。词汇表管理器在XML模式注册期间解释用户级和系统级注释。所有其他模式注释（例如与数据库相关的注释）都将被忽略。
                        </p>
                     </div>
                  </div><a id="ADXDK19205"></a><div class="props_rev_3"><a id="GUID-40702A1D-8D84-4ACF-9872-338FF4FFC442" name="GUID-40702A1D-8D84-4ACF-9872-338FF4FFC442"></a><h5 id="ADXDK-GUID-40702A1D-8D84-4ACF-9872-338FF4FFC442" class="sect5">用户级注释</h5>
                     <div>
                        <p>用户级注释由用户在注册前指定。</p>
                        <p><code class="codeph">encodingType</code> - 此注释可以在<code class="codeph">xsd:element</code> ， <code class="codeph">xsd:attribute</code>或<code class="codeph">xsd:simpleType</code>元素中使用。它指示用于编码元素或属性的节点值的数据类型。对于字符串，此版本仅支持Unicode（UTF-8）编码的8位编码。
                        </p>
                     </div>
                  </div><a id="ADXDK19206"></a><div class="props_rev_3"><a id="GUID-EB8A2CDF-E1D0-4834-A43C-AC4EBCC0AD0E" name="GUID-EB8A2CDF-E1D0-4834-A43C-AC4EBCC0AD0E"></a><h5 id="ADXDK-GUID-EB8A2CDF-E1D0-4834-A43C-AC4EBCC0AD0E" class="sect5">系统级注释</h5>
                     <div>
                        <p>词汇管理器在注册时添加系统级注释。你无法覆盖它们。</p>
                     </div>
                  </div>
               </div><a id="ADXDK19207"></a><div class="props_rev_3"><a id="GUID-64183150-1F23-48A4-A1E8-81A0CD512429" name="GUID-64183150-1F23-48A4-A1E8-81A0CD512429"></a><h4 id="ADXDK-GUID-64183150-1F23-48A4-A1E8-81A0CD512429" class="sect4">令牌管理</h4>
                  <div>
                     <p>令牌集可以从数据库或元数据存储库中获取，缓存在本地词汇表管理器中，并用于解码。在编码时，可以将令牌集推送到存储库以实现持久性。</p>
                     <p>通过在编码器上设置标志，也可以将令牌定义作为二进制XML流的一部分包括在内。</p>
                  </div>
               </div>
            </div><a id="ADXDK19208"></a><div class="props_rev_3"><a id="GUID-AE12DDC0-142D-4742-8BE8-0F5557781F4F" name="GUID-AE12DDC0-142D-4742-8BE8-0F5557781F4F"></a><h3 id="ADXDK-GUID-AE12DDC0-142D-4742-8BE8-0F5557781F4F" class="sect3">使用Java二进制XML包</h3>
               <div>
                  <p>描述了二进制XML包的使用。</p>
                  <div class="section">
                     <p><code class="codeph">BinXMLStream</code>类表示二进制XML流。为二进制XML流定义的不同存储位置是：</p>
                  </div>
                  <!-- class="section" -->
                  <div class="section">
                     <ul style="list-style-type:disc">
                        <li>
                           <p><code class="codeph">InputStream</code> -stream用于阅读。
                           </p>
                        </li>
                        <li>
                           <p><code class="codeph">OutputStream</code> -stream用于写入。
                           </p>
                        </li>
                        <li>
                           <p>用于阅读的<code class="codeph">URL</code> 。
                           </p>
                        </li>
                        <li>
                           <p><code class="codeph">File</code>用于读写。
                           </p>
                        </li>
                        <li>
                           <p><code class="codeph">BLOB</code> -stream用于读写。
                           </p>
                        </li>
                        <li>
                           <p>用于读写的字节数组流。</p>
                        </li>
                        <li>
                           <p>在内存流中进行读写。</p>
                        </li>
                     </ul>
                     <p><code class="codeph">BinXMLStream</code>对象指定创建期间的存储类型。
                     </p>
                     <p>可以从<code class="codeph">BinXMLProcessor</code>工厂创建<code class="codeph">BinXMLStream</code>对象。可以使用JDBC连接（用于远程元数据访问），连接池，URL或<code class="codeph">PageManagerPool</code> （用于延迟内存存储）初始化此工厂。可以从<code class="codeph">BinXMLStream</code>创建<code class="codeph">BinXMLEncoder</code>和<code class="codeph">BinXMLDecoder</code>以进行编码或解码。
                     </p>
                     <p>下面是创建没有存储库的处理器，注册模式，将XML SAX事件编码为模式感知二进制格式以及存储在文件中的示例：</p><pre class="pre codeblock"><code>BinXMLProcessor proc = BinXMLProcessorFactory.createProcessor（）; proc.registerSchema（schemaURL）; BinXMLStream outbin = proc.createBinaryStream（outFile）; BinXMLEncoder enc = outbin.getEncoder（）; enc.setSchemaAware（真）; ContentHandler hdlr = enc.getContentHandler（）;</code></pre><p>除了获取<code class="codeph">ContentHandler</code> ，您还可以获取其他处理程序，例如：</p><pre class="pre codeblock"><code>LexicalHandler lexhdlr = enc.getLexicalHandler（）; DTDHandler dtdhdlr = encenc.getDTDHandler（）; DeclHandler declhdlr = enc.getDeclHandler（）; ErrorHandler errhdlr = enc.getErrorHandler（）;</code></pre><p>在生成SAX事件的应用程序中使用<code class="codeph">hdlr</code> 。
                     </p>
                     <p>2。下面是创建具有数据库存储库的处理器，解码模式感知二进制流以及使用pull API读取已解码的XML的示例。从数据库存储库中提取模式以进行解码。</p><pre class="pre codeblock"><code>DBBinXMLMetadataProvider dbrep = BinXMLMetadataProviderFactory.createDBMetadataProvider（）; BinXMLProcessor proc = BinXMLProcessorFactory.createProcessor（dbrep）; BinXMLStream inpbin = proc.createBinaryStream（blob）; BinXMLDecoder dec = inpbin.getDecoder（）; InfosetReader xmlreader = dec.getReader（）;</code></pre><p>使用<code class="codeph">xmlreader</code>从解码器以拉式方式读取XML。
                     </p>
                  </div>
                  <!-- class="section" -->
               </div><a id="ADXDK19209"></a><div class="props_rev_3"><a id="GUID-E442D9A0-CB3A-4CFF-8A39-B7A2F673C3E2" name="GUID-E442D9A0-CB3A-4CFF-8A39-B7A2F673C3E2"></a><h4 id="ADXDK-GUID-E442D9A0-CB3A-4CFF-8A39-B7A2F673C3E2" class="sect4">二进制XML编码器</h4>
                  <div>
                     <p>编码器接受XML输入，使用SAX事件解析和读取，并输出二进制XML。</p>
                  </div><a id="ADXDK19210"></a><div class="props_rev_3"><a id="GUID-A06592C1-D899-479A-ABF6-4759C88478AD" name="GUID-A06592C1-D899-479A-ABF6-4759C88478AD"></a><h5 id="ADXDK-GUID-A06592C1-D899-479A-ABF6-4759C88478AD" class="sect5">Schema-Less选项</h5>
                     <div>
                        <p>您可以在编码之前指定架构感知或无架构选项。默认值是无架构编码。</p>
                        <p>如果设置了schema-aware选项，则根据实例文档中指定的模式完成编码。在解码时也需要用于编码的带注释的模式。如果指定了无架构选项，则编码独立于架构，但默认情况下令牌是内联的。要覆盖默认值，请设置<code class="codeph">Inline-token = false.</code></p>
                     </div>
                  </div><a id="ADXDK19212"></a><a id="ADXDK19211"></a><div class="props_rev_3"><a id="GUID-66597AC6-1E3A-435E-AFE9-29CCD2458C71" name="GUID-66597AC6-1E3A-435E-AFE9-29CCD2458C71"></a><h5 id="ADXDK-GUID-66597AC6-1E3A-435E-AFE9-29CCD2458C71" class="sect5">内联令牌选项</h5>
                     <div>
                        <p>您可以设置一个选项，以便在编码之前使用内联标记定义创建二进制XML流。如果关闭内联，则必须确保编码器或解码器处理器使用相同的元数据存储库。默认情况下，令牌定义是内联的。</p>
                        <p>如果启用了架构感知选项，则会忽略标记<code class="codeph">Inline-token</code> 。
                        </p>
                        <div class="figure" id="GUID-66597AC6-1E3A-435E-AFE9-29CCD2458C71__GUID-0473E5AF-D727-4FDB-B634-E653BABF6C8A">
                           <p class="titleinfigure">图13-1二进制XML编码</p><img src="img/adxdk124.gif" width="363" alt="下面是图13-1的描述" title="下面是图13-1的描述" longdesc="img_text/adxdk124.html"><br><a href="img_text/adxdk124.html">“图13-1二进制XML编码”的描述</a></div>
                        <!-- class="figure" -->
                     </div>
                  </div>
               </div><a id="ADXDK19214"></a><a id="ADXDK19213"></a><div class="props_rev_3"><a id="GUID-F090EAE2-F039-4787-B91E-D9047AF88270" name="GUID-F090EAE2-F039-4787-B91E-D9047AF88270"></a><h4 id="ADXDK-GUID-F090EAE2-F039-4787-B91E-D9047AF88270" class="sect4">二进制XML解码器</h4>
                  <div>
                     <p>二进制XML解码器将二进制XML流作为输入并生成SAX事件作为输出，或者它提供拉取接口以读取解码的XML。对于XML模式感知的二进制XML流，二进制XML解码器与词汇表管理器交互以提取模式信息。</p>
                     <p>如果词汇表管理器不包含所需的模式，并且处理器是具有有效JDBC连接的二进制XML类型，则基于二进制XML流中的词汇表id从数据库或元数据存储库中获取远程模式。解码。类似地，可以从数据库或元数据存储库中获取令牌定义集。</p>
                     <div class="figure" id="GUID-F090EAE2-F039-4787-B91E-D9047AF88270__GUID-912C510F-EECF-4294-86E4-7C4F8FCD2DA6">
                        <p class="titleinfigure">图13-2二进制XML解码器</p><img src="img/adxdk123.gif" width="336" alt="下面是图13-2的描述" title="下面是图13-2的描述" longdesc="img_text/adxdk123.html"><br><a href="img_text/adxdk123.html">“图13-2二进制XML解码器”的描述</a></div>
                     <!-- class="figure" -->
                  </div>
               </div><a id="ADXDK19215"></a><div class="props_rev_3"><a id="GUID-04807B10-06DE-42E6-933B-68F2BB738E2A" name="GUID-04807B10-06DE-42E6-933B-68F2BB738E2A"></a><h4 id="ADXDK-GUID-04807B10-06DE-42E6-933B-68F2BB738E2A" class="sect4">架构注册概述</h4>
                  <div>
                     <p>您使用二进制XML处理器注册XML模式。架构是一个文本文件，可以包含用户级注释。作为注册过程的一部分，处理器添加系统级注释。然后，Schema Builder将处理生成的带注释的模式，以构建XML模式对象。</p>
                     <p>此XML架构对象存储在词汇表缓存中。词汇表缓存为每个XML架构对象分配唯一的词汇表id，该ID作为输出返回。XML模式的带注释的DOM表示被发送到二进制XML编码器。</p>
                  </div>
               </div><a id="ADXDK19216"></a><div class="props_rev_3"><a id="GUID-E5DBDA35-6C90-4FED-BF1E-5CEF2D6428BF" name="GUID-E5DBDA35-6C90-4FED-BF1E-5CEF2D6428BF"></a><h4 id="ADXDK-GUID-E5DBDA35-6C90-4FED-BF1E-5CEF2D6428BF" class="sect4">解析xsi：schemaLocation</h4>
                  <div>
                     <p>描述了如何解析<code class="codeph">xsi:schemaLocation</code> 。
                     </p>
                     <p>在编码期间，如果<code class="codeph">schemaAware</code>为true且属性<code class="codeph">ImplcitSchemaRegistration</code>为<code class="codeph">true</code> ，则XML实例文档的根元素中存在的第一个<code class="codeph">xsi:schemaLocation</code>标记会自动在本地词汇表管理器中注册该模式。没有显式注册其他<code class="codeph">schemaLocation</code>标记。如果处理器是面向数据库的，那么模式也在数据库中注册;类似地，对于任何基于元数据库的处
                     </p>
                     <p>如果编码设置为<code class="codeph">schemaAware</code>为<code class="codeph">false</code>或<code class="codeph">ImplcitSchemaRegistration</code>为<code class="codeph">false</code> ，则编码器将忽略所有<code class="codeph">xsi:schemaLocation</code>标记。
                     </p>
                  </div>
               </div><a id="ADXDK19217"></a><div class="props_rev_3"><a id="GUID-04F717C4-91CC-472B-99FB-38F133F80797" name="GUID-04F717C4-91CC-472B-99FB-38F133F80797"></a><h4 id="ADXDK-GUID-04F717C4-91CC-472B-99FB-38F133F80797" class="sect4">二进制XML</h4>
                  <div>
                     <p>二进制XML处理器可以与数据库通信，以进行各种类型的二进制XML操作，包括存储和检索二进制XML模式，令牌集和二进制XML流。</p>
                     <p><code class="codeph">DBBinXMLMetadataProvider</code>对象可以使用专用JDBC连接进行实例化，也可以使用连接池来访问模式和令牌集等词汇表信息。处理器还与一个或多个数据连接相关联以访问XML数据。
                     </p>
                     <p>数据库通信涉及以下方面：</p>
                     <ol>
                        <li>
                           <p>使用词汇表ID或架构URL提取已编译的二进制XML架构</p>
                           <p>要检索已编译的二进制XML模式以进行编码，将根据模式URL查询数据库。为了解码二进制XML模式，根据词汇表ID从数据库中获取它。</p>
                        </li>
                        <li>
                           <p>使用架构URL存储未编译的二进制XML架构并检索词汇表ID。</p>
                           <p>在编码期间遇到<code class="codeph">xsi:schemaLocation</code>标记时，会在数据库中注册模式以在数据库中进行持久存储。从数据库中检索与模式相关联的词汇表id以及编译模式的二进制版本;使用从数据库返回的词汇表id构建编译的架构对象并将其存储在本地缓存中。
                           </p>
                        </li>
                        <li>
                           <p>使用命名空间URL检索二进制令牌集。</p>
                           <p>如果要解码的二进制流与用于解码的令牌表相关联，则使用元数据连接从数据库中取出这些令牌表。</p>
                        </li>
                        <li>
                           <p>使用命名空间URL存储二进制令牌集</p>
                           <p>如果XML文本已经编码而没有模式，那么它会生成一组令牌定义的令牌。这些令牌表可以持久存储在数据库中。元数据连接用于将令牌集传输到数据库。</p>
                        </li>
                        <li>
                           <p>具有远程存储选项的二进制XML流</p>
                           <p>您有责任创建一个包含带有二进制XML的<code class="codeph">XMLType</code>列的表，用于存储编码结果并检索二进制XML以进行解码。可以使用Oracle Net Services和JDBC实现与数据库的通信。从JDBC查询的输出结果集中获取<code class="codeph">XMLType</code>对象。可以从<code class="codeph">XMLType</code>对象创建用于读取二进制数据或写出二进制数据的<code class="codeph">BinXMLStream</code> 。必须扩展<code class="codeph">XMLType</code>类以支持读取和写入二进制XML数据。
                           </p>
                        </li>
                     </ol>
                  </div>
               </div><a id="ADXDK19218"></a><div class="props_rev_3"><a id="GUID-8ED117C9-5082-4C23-AF00-7F0AB6C951ED" name="GUID-8ED117C9-5082-4C23-AF00-7F0AB6C951ED"></a><h4 id="ADXDK-GUID-8ED117C9-5082-4C23-AF00-7F0AB6C951ED" class="sect4">持久存储元数据</h4>
                  <div>
                     <p>您可以为元数据提供持久的后端存储。</p>
                     <p>本地词汇表管理器和缓存将元数据信息存储在内存中，用于<code class="codeph">BinXMLProcessor</code>的生命<code class="codeph">BinXMLProcessor</code> 。您可以通过实现接口<code class="codeph">BinXMLMetadataProvider</code>并将其插入<code class="codeph">BinXMLProcessor</code>来插入您自己的后端存储以获取元数据。目前，每个处理器仅支持一个元数据提供程序。
                     </p>
                     <p>您必须编写一个<code class="codeph">FileBinXMLMetadataProvider</code>实现了接口<code class="codeph">BinXMLMetadataProvider</code> 。编码器和解码器使用这些API从持久的后端存储中访问元数据。设置持久存储的配置信息：例如， <code class="codeph">FileBinXMLMetadataProvider</code>类中的文件系统的根目录。实例化<code class="codeph">FileBinXMLMetadataProvider</code>并将其插入<code class="codeph">BinXMLProcessor</code> 。
                     </p>
                  </div>
               </div>
            </div>
         </div>
      </article>
   </body>
</html>