<html lang="en-us" dir="ltr" xml:lang="en-us">
   <head>
      <meta http-equiv="Content-Type" content="text/html; charset=utf-8"></meta>
      <meta name="viewport" content="width=device-width, initial-scale=1"></meta>
      <meta http-equiv="X-UA-Compatible" content="IE=edge"></meta>
      <title>数据库概念</title>
      <meta property="og:site_name" content="Oracle Help Center"></meta>
      <meta property="og:title" content="Programmer&#39;s Guide"></meta>
      <meta property="og:description" content=""></meta>
      <link rel="stylesheet" href="/sp_common/book-template/ohc-book-template/css/book.css"></link>
      <link rel="shortcut icon" href="/sp_common/book-template/ohc-common/img/favicon.ico"></link>
      <meta name="application-name" content="Programmer&#39;s Guide"></meta>
      <meta name="generator" content="DITA Open Toolkit version 1.8.5 (Mode = doc)"></meta>
      <meta name="plugin" content="SP_docbuilder HTML plugin release 18.2.2"></meta>
      <link rel="alternate" href="c-c-programmers-guide.pdf" title="PDF File" type="application/pdf"></link>
      <meta name="robots" content="all"></meta>
      <link rel="schema.dcterms" href="http://purl.org/dc/terms/"></link>
      <meta name="dcterms.created" content="2019-01-11T03:52:01-08:00"></meta>
      
      <meta name="dcterms.dateCopyrighted" content="1996, 2019"></meta>
      <meta name="dcterms.category" content="database"></meta>
      <meta name="dcterms.identifier" content="E96467-01"></meta>
      
      <meta name="dcterms.product" content="en/database/oracle/oracle-database/19"></meta>
      
      <link rel="prev" href="precompiler-concepts.html" title="Previous" type="text/html"></link>
      <link rel="next" href="datatypes-and-host-variables.html" title="Next" type="text/html"></link>
      <script>
        document.write('<style type="text/css">');
        document.write('body > .noscript, body > .noscript ~ * { visibility: hidden; }');
        document.write('</style>');
     </script>
      <script src="/sp_common/book-template/requirejs/require.js" data-main="/sp_common/book-template/ohc-book-template/js/book-config"></script>
      <script>
            if (window.require === undefined) {
                document.write('<script data-main="sp_common/book-template/ohc-book-template/js/book-config" src="sp_common/book-template/requirejs/require.js"><\/script>');
                document.write('<link href="sp_common/book-template/ohc-book-template/css/book.css" rel="stylesheet"/>');
            }
        </script>
      <script type="application/json" id="ssot-metadata">{"primary":{"category":{"short_name":"database","element_name":"Database","display_in_url":true},"suite":{"short_name":"oracle","element_name":"Oracle","display_in_url":true},"product_group":{"short_name":"not-applicable","element_name":"Not applicable","display_in_url":false},"product":{"short_name":"oracle-database","element_name":"Oracle Database","display_in_url":true},"release":{"short_name":"19","element_name":"Release 19","display_in_url":true}}}</script>
      
    <meta name="dcterms.title" content="Pro*C/C++ Programmer&#39;s Guide"></meta>
    <meta name="dcterms.isVersionOf" content="LNPCC"></meta>
    <meta name="dcterms.release" content="Release 19"></meta>
  </head>
   <body dir="ltr">
      <div class="noscript alert alert-danger text-center" role="alert">
         <a href="precompiler-concepts.html" class="pull-left"><span class="glyphicon glyphicon-chevron-left" aria-hidden="true"></span>上一页</a> <a href="datatypes-and-host-variables.html" class="pull-right">下一页<span class="glyphicon glyphicon-chevron-right" aria-hidden="true"></span></a> <span class="fa fa-exclamation-triangle" aria-hidden="true"></span>必须启用JavaScript才能正确显示此内容</div>
      <article>
         <header>
            <ol class="breadcrumb" vocab="http://schema.org/" typeof="BreadcrumbList">
               <li property="itemListElement" typeof="ListItem"><a href="index.html" property="item" typeof="WebPage"><span property="name">程序员指南</span></a></li>
               <li property="itemListElement" typeof="ListItem"><a href="introduction-and-concepts.html" property="item" typeof="WebPage"><span property="name">介绍和概念</span></a></li>
               <li class="active" property="itemListElement" typeof="ListItem">数据库概念</li>
            </ol>
            <a id="GUID-54B5B0C8-CB28-4E84-A52C-F05CEBA92539" name="GUID-54B5B0C8-CB28-4E84-A52C-F05CEBA92539"></a><a id="LNPCC3108"></a>
            
            <h2 id="LNPCC-GUID-54B5B0C8-CB28-4E84-A52C-F05CEBA92539" class="sect2"><span class="enumeration_chapter">3</span>数据库概念</h2>
         </header>
         <div class="ind">
            <div>
               <p>本章介绍了一些基本的数据库概念以及如何执行事务处理。您将学习保护数据库一致性的基本技术，包括如何控制Oracle数据的更改是永久更改还是撤消。</p>
               <p>本章包含以下主题：</p>
               <ul style="list-style-type:disc">
                  <li>
                     <p><a href="database-concepts.html#GUID-32EB2446-F4A9-47A5-A9C1-28F90CCF589D">连接到数据库</a></p>
                  </li>
                  <li>
                     <p><a href="database-concepts.html#GUID-AE4C1784-5F16-4DB3-835C-9BEDCAA13414">高级连接选项</a></p>
                  </li>
                  <li>
                     <p><a href="database-concepts.html#GUID-2DA1A2A2-145D-4444-B391-806D8013397A">交易条款的定义</a> 
                     </p>
                  </li>
                  <li>
                     <p><a href="database-concepts.html#GUID-4225AA6B-A82A-49DD-A2FA-B730F9CAAF53">事务如何保护您的数据库</a></p>
                  </li>
                  <li>
                     <p><a href="database-concepts.html#GUID-13E912AB-0FD7-4F36-A34C-5CA5F25F0612">如何开始和结束交易</a></p>
                  </li>
                  <li>
                     <p><a href="database-concepts.html#GUID-31E8EFBB-10EB-4F87-8E37-6F4A27FFB557">使用COMMIT语句</a></p>
                  </li>
                  <li>
                     <p><a href="database-concepts.html#GUID-3573A6EF-0B59-452C-854C-09EAE705E526">使用SAVEPOINT语句</a></p>
                  </li>
                  <li>
                     <p><a href="database-concepts.html#GUID-522982CF-0A57-4795-9FFE-7DF4820DAA43">ROLLBACK声明</a></p>
                  </li>
                  <li>
                     <p><a href="database-concepts.html#GUID-19075C1F-9F8B-46B2-9F1E-A29F39777FB5">RELEASE选项</a></p>
                  </li>
                  <li>
                     <p><a href="database-concepts.html#GUID-E390067A-6EBF-4F4A-B0EB-C98B5318D6EC">SET TRANSACTION声明</a></p>
                  </li>
                  <li>
                     <p><a href="database-concepts.html#GUID-65DF517F-601E-4734-B1E9-004519DF8078">覆盖默认锁定</a></p>
                  </li>
                  <li>
                     <p><a href="database-concepts.html#GUID-56C7EE05-CBFF-467F-9C08-856500AF335E">获取跨COMMIT</a></p>
                  </li>
                  <li>
                     <p><a href="database-concepts.html#GUID-4037818F-8267-448A-8003-4099A1A67F09">分布式事务处理</a></p>
                  </li>
                  <li>
                     <p><a href="database-concepts.html#GUID-08C56A16-F6AC-443D-8B2B-9338CCB0D009">方针</a></p>
                  </li>
               </ul>
            </div><a id="LNPCC3109"></a><div class="props_rev_3"><a id="GUID-32EB2446-F4A9-47A5-A9C1-28F90CCF589D" name="GUID-32EB2446-F4A9-47A5-A9C1-28F90CCF589D"></a><h3 id="LNPCC-GUID-32EB2446-F4A9-47A5-A9C1-28F90CCF589D" class="sect3"><span class="enumeration_section">3.1</span>连接到数据库</h3>
               <div>
                  <p>CONNECT语句的完整语法将在接下来的几节中讨论。这里是：</p><pre class="oac_no_warn" dir="ltr">EXEC SQL CONNECT {：用户IDENTIFIED BY：oldpswd | ：usr_psw} [[AT {dbname | ：host_variable}] USING：connect_string] [{ALTER AUTHORIZATION：newpswd | IN {SYSDBA | SYSOPER} MODE}];</pre><p>在查询或操作数据之前，Pro * C / C ++程序必须连接到数据库。要登录，只需使用CONNECT语句即可<a id="d14014e99" class="indexterm-anchor"></a><a id="d14014e101" class="indexterm-anchor"></a><a id="d14014e103" class="indexterm-anchor"></a> 
                  </p><pre class="oac_no_warn" dir="ltr">EXEC SQL CONNECT：用户名IDENTIFIED BY：密码;</pre><p>其中<span class="italic">username</span>和<span class="italic">password</span>是<span class="bold">char</span>或VARCHAR主变量。
                  </p>
                  <p>或者，您可以使用该声明</p><pre class="oac_no_warn" dir="ltr">EXEC SQL CONNECT：usr_pwd;</pre><p>其中主机变量<span class="italic">usr_pwd</span>包含由斜杠字符（/）分隔的用户名和密码。
                  </p>
                  <p>这些是CONNECT语句的简化子集。</p>
                  <p>CONNECT语句必须是程序执行的第一个SQL语句。也就是说，其他SQL语句可以在物理上但不在逻辑上位于预编译单元中的CONNECT语句之前。<a id="d14014e134" class="indexterm-anchor"></a><a id="d14014e138" class="indexterm-anchor"></a></p>
                  <p>要分别提供Oracle用户名和密码，请将两个主机变量定义为字符串或VARCHAR。（如果提供包含用户名和密码的用户名，则只需要一个主机变量。） <a id="d14014e142" class="indexterm-anchor"></a><a id="d14014e146" class="indexterm-anchor"></a> 
                  </p>
                  <p>确保在执行CONNECT之前设置用户名和密码变量，否则它将失败。您的程序可以提示输入值，或者您可以按如下方式对它们进行硬编码： <a id="d14014e154" class="indexterm-anchor"></a> 
                  </p><pre class="oac_no_warn" dir="ltr">char * username =“SCOTT”; char *密码=“TIGER”; ...执行SQL WHENEVER SQLERROR ...EXEC SQL CONNECT：用户名IDENTIFIED BY：密码;</pre><p>但是，您无法将用户名和密码硬编码到CONNECT语句中。你也不能使用引用的文字。例如，以下两个语句都<span class="italic">无效</span> ：</p><pre class="oac_no_warn" dir="ltr">由TIGER识别的EXEC SQL CONNECT SCOTT;由'TIGER'识别的EXEC SQL CONNECT'SCOTT';</pre><p>建议不要使用硬编码用户名和密码。</p>
               </div>
               <div>
                  <div class="relinfo">
                     <p><strong>相关话题</strong></p>
                     <ul>
                        <li><a href="embedded-SQL-statements-and-directives.html#GUID-F8BE4EAD-B8A5-48CD-9328-CB49C0E64F6D">CONNECT（可执行的嵌入式SQL扩展）</a></li>
                     </ul>
                  </div>
               </div>
               <a id="LNPCC3110"></a><div class="props_rev_3"><a id="GUID-F1E92052-5823-4FAA-BE98-3B350E343846" name="GUID-F1E92052-5823-4FAA-BE98-3B350E343846"></a><h4 id="LNPCC-GUID-F1E92052-5823-4FAA-BE98-3B350E343846" class="sect4"><span class="enumeration_section">3.1.1</span>使用ALTER AUTHORIZATION子句更改密码</h4>
                  <div>
                     <p>Pro * C / C ++通过对EXEC SQL CONNECT语句的简单扩展，为客户端应用程序提供了一种在运行时更改用户密码的便捷方法。</p>
                     <p>本节描述了ALTER AUTHORIZATION子句的不同变体的可能结果。</p>
                  </div><a id="LNPCC3111"></a><div class="props_rev_3"><a id="GUID-3A5CE18B-C89B-4662-9EA3-00622566914A" name="GUID-3A5CE18B-C89B-4662-9EA3-00622566914A"></a><h5 id="LNPCC-GUID-3A5CE18B-C89B-4662-9EA3-00622566914A" class="sect5"><span class="enumeration_section">3.1.1.1</span>标准连接</h5>
                     <div>
                        <p>如果应用程序发出以下声明</p><pre class="oac_no_warn" dir="ltr">EXEC SQL CONNECT ..; / *没有ALTER AUTHORIZATION子句* /</pre><p>它执行正常的连接尝试。可能的结果包括：</p>
                        <ul style="list-style-type:disc">
                           <li>
                              <p>该应用程序将连接没有问题。</p>
                           </li>
                           <li>
                              <p>应用程序将连接，但会收到密码警告。警告表示密码已过期但处于允许登录的宽限期。此时，建议用户在帐户锁定之前更改密码。</p>
                           </li>
                           <li>
                              <p>应用程序将无法连接。可能的原因包括：</p>
                              <ul style="list-style-type:disc">
                                 <li>
                                    <p>密码不正确。</p>
                                 </li>
                                 <li>
                                    <p>该帐户已过期，可能处于锁定状态。</p>
                                 </li>
                              </ul>
                           </li>
                        </ul>
                     </div>
                  </div><a id="LNPCC3112"></a><div class="props_rev_3"><a id="GUID-96CE765C-12E6-4DD6-924D-33BA2AF3F520" name="GUID-96CE765C-12E6-4DD6-924D-33BA2AF3F520"></a><h5 id="LNPCC-GUID-96CE765C-12E6-4DD6-924D-33BA2AF3F520" class="sect5"><span class="enumeration_section">3.1.1.2</span>更改CONNECT上的密码</h5>
                     <div>
                        <p>以下CONNECT语句</p><pre class="oac_no_warn" dir="ltr">EXEC SQL CONNECT ..更改授权：newpswd;</pre><p>表示应用程序要将帐户密码更改为<code class="codeph">newpswd</code>指示的值。进行更改后，尝试以<code class="codeph">user</code> / <code class="codeph">newpswd</code>身份进行连接。这可以得到以下结果：</p>
                        <ul style="list-style-type:disc">
                           <li>
                              <p>该应用程序将连接没有问题</p>
                           </li>
                           <li>
                              <p>应用程序将无法连接。这可能是由于以下任何一种情况：</p>
                              <ul style="list-style-type:disc">
                                 <li>
                                    <p>密码验证由于某种原因失败。在这种情况下，密码保持不变。</p>
                                 </li>
                                 <li>
                                    <p>账号被锁了。不允许更改密码。</p>
                                 </li>
                              </ul>
                           </li>
                        </ul>
                     </div>
                  </div>
               </div><a id="LNPCC3113"></a><div class="props_rev_3"><a id="GUID-EF7D1526-862E-4067-8515-11DE00BAC500" name="GUID-EF7D1526-862E-4067-8515-11DE00BAC500"></a><h4 id="LNPCC-GUID-EF7D1526-862E-4067-8515-11DE00BAC500" class="sect4"><span class="enumeration_section">3.1.2</span>使用Oracle Net Services进行连接</h4>
                  <div>
                     <p>要使用Oracle Net Services驱动程序进行连接，请替换<code class="codeph">tnsnames.ora</code>配置文件或Oracle名称中定义的服务名称。
                     </p>
                     <p>如果您使用的是Oracle名称，则名称服务器将从网络定义数据库中获取服务名称。</p>
                     <p>有关<span class="italic">Oracle Net Services的</span>详细信息，请参阅“ <span class="italic">Oracle Net Services管理员指南”</span> 。
                     </p>
                  </div>
               </div><a id="LNPCC3114"></a><div class="props_rev_3"><a id="GUID-B7B0A5B6-B6FB-4DE3-81AA-C19AA1B4CBD0" name="GUID-B7B0A5B6-B6FB-4DE3-81AA-C19AA1B4CBD0"></a><h4 id="LNPCC-GUID-B7B0A5B6-B6FB-4DE3-81AA-C19AA1B4CBD0" class="sect4"><span class="enumeration_section">3.1.3</span>自动连接</h4>
                  <div>
                     <p>您可以使用用户名自动连接到Oracle<a id="d14014e301" class="indexterm-anchor"></a><a id="d14014e305" class="indexterm-anchor"></a></p><pre class="oac_no_warn" dir="ltr">CLUSTER $用户名</pre><p>其中<span class="italic">username</span>是当前操作系统用户名，CLUSTER $ <span class="italic">username</span>是有效的Oracle数据库用户名。（CLUSTER $的实际值在INIT.ORA参数文件中定义。）您只需将Pro * C / C ++预编译器传递给斜杠字符，如下所示：</p><pre class="oac_no_warn" dir="ltr">...char * oracleid =“/”; ...EXEC SQL CONNECT：oracleid;</pre><p>这会自动将您作为用户CLUSTER $ <span class="italic">username连接</span> 。例如，如果您的操作系统用户名是RHILL，并且CLUSTER $ RHILL是有效的Oracle用户名，则使用'/'连接会自动以CLUSTER $ RHILL用户身份登录Oracle。</p>
                     <p>您还可以将字符串中的“/”传递给预编译器。但是，该字符串不能包含尾随空格。例如，以下CONNECT语句将失败：</p><pre class="oac_no_warn" dir="ltr">...char oracleid [10] =“/”; ...EXEC SQL CONNECT：oracleid;</pre></div><a id="LNPCC3115"></a><div class="props_rev_3"><a id="GUID-C6D8480D-9BA4-4B99-BA76-20DB26F77352" name="GUID-C6D8480D-9BA4-4B99-BA76-20DB26F77352"></a><h5 id="LNPCC-GUID-C6D8480D-9BA4-4B99-BA76-20DB26F77352" class="sect5"><span class="enumeration_section">3.1.3.1</span> AUTO_CONNECT预编译器选项</h5>
                     <div>
                        <p>如果AUTO_CONNECT = YES，并且应用程序在处理第一个可执行SQL语句时尚未连接到数据库，则会尝试使用userid连接</p><pre class="oac_no_warn" dir="ltr">CLUSTER $ &lt;用户名&gt;</pre><p>其中<span class="italic">username</span>是您当前的操作系统用户或任务名称，CLUSTER $ username是有效的Oracle用户ID。AUTO_CONNECT的默认值为NO。</p>
                        <p>当AUTO_CONNECT = NO时，必须使用程序中的CONNECT语句连接到Oracle。</p>
                     </div>
                  </div><a id="LNPCC3116"></a><div class="props_rev_3"><a id="GUID-A74A3C2F-0B5A-4209-B551-80B17FEFB62D" name="GUID-A74A3C2F-0B5A-4209-B551-80B17FEFB62D"></a><h5 id="LNPCC-GUID-A74A3C2F-0B5A-4209-B551-80B17FEFB62D" class="sect5"><span class="enumeration_section">3.1.3.2</span> SYSDBA或SYSOPER系统特权</h5>
                     <div>
                        <p>在所有其他子句之后附加以下可选字符串，以使用SYSDBA或SYSOPER系统特权登录：</p><pre class="oac_no_warn" dir="ltr">[IN {SYSDBA | SYSOPER}模式]</pre><p>例如：</p><pre class="oac_no_warn" dir="ltr">EXEC SQL CONNECT ...在SYSDBA模式;</pre><p>以下是适用于此选项的限制：</p>
                        <ul style="list-style-type:disc">
                           <li>
                              <p>使用AUTO_CONNECT = YES预编译器选项设置时，不允许使用此选项。</p>
                           </li>
                           <li>
                              <p>在CONNECT语句中使用ALTER AUTHORIZATION关键字时，不允许使用此选项。</p>
                           </li>
                        </ul>
                     </div>
                     <div>
                        <div class="relinfo">
                           <p><strong>相关话题</strong></p>
                           <ul>
                              <li><a href="database-concepts.html#GUID-F1E92052-5823-4FAA-BE98-3B350E343846">使用ALTER AUTHORIZATION子句更改密码</a></li>
                           </ul>
                        </div>
                     </div>
                     
                  </div>
               </div>
            </div><a id="LNPCC3117"></a><div class="props_rev_3"><a id="GUID-AE4C1784-5F16-4DB3-835C-9BEDCAA13414" name="GUID-AE4C1784-5F16-4DB3-835C-9BEDCAA13414"></a><h3 id="LNPCC-GUID-AE4C1784-5F16-4DB3-835C-9BEDCAA13414" class="sect3"><span class="enumeration_section">3.2</span>高级连接选项</h3>
               <div>
                  <p>本节介绍高级连接的可用选项。</p>
               </div><a id="LNPCC3118"></a><div class="props_rev_3"><a id="GUID-266AEBC4-3E2E-4920-9D2E-EA08165EE4CD" name="GUID-266AEBC4-3E2E-4920-9D2E-EA08165EE4CD"></a><h4 id="LNPCC-GUID-266AEBC4-3E2E-4920-9D2E-EA08165EE4CD" class="sect4"><span class="enumeration_section">3.2.1</span>一些预赛</h4>
                  <div>
                     <p>网络中的通信点称为<span class="italic">节点</span> 。Oracle Net允许您通过网络从一个节点向另一个节点传输信息（SQL语句，数据和状态代码）。 <a id="d14014e414" class="indexterm-anchor"></a><a id="d14014e418" class="indexterm-anchor"></a><a id="d14014e422" class="indexterm-anchor"></a><a id="d14014e426" class="indexterm-anchor"></a> 
                     </p>
                     <p><span class="italic">协议</span>是用于访问网络的一组规则。规则建立了诸如故障后恢复的程序以及传输数据和检查错误的格式。<a id="d14014e434" class="indexterm-anchor"></a></p>
                     <p>用于连接到本地域中的默认数据库的Oracle Net语法只是使用数据库的服务名称。<a id="d14014e440" class="indexterm-anchor"></a></p>
                     <p>如果服务名称不在默认（本地）域中，则必须使用全局规范（指定所有域）。例如：</p><pre class="oac_no_warn" dir="ltr">HR.XX.ORACLE.COM</pre></div>
               </div><a id="LNPCC3120"></a><a id="LNPCC3119"></a><div class="props_rev_3"><a id="GUID-F290F256-66EA-47B1-9B05-49C2D5A28FD0" name="GUID-F290F256-66EA-47B1-9B05-49C2D5A28FD0"></a><h4 id="LNPCC-GUID-F290F256-66EA-47B1-9B05-49C2D5A28FD0" class="sect4"><span class="enumeration_section">3.2.2</span>并发登录</h4>
                  <div>
                     <p><a id="d14014e459" class="indexterm-anchor"></a><a id="d14014e463" class="indexterm-anchor"></a><a id="d14014e467" class="indexterm-anchor"></a><a id="d14014e471" class="indexterm-anchor"></a> Pro * C / C ++支持通过Oracle Net进行分布式处理。您的应用程序可以同时访问本地和远程数据库的任意组合，或者建立到同一数据库的多个连接。在<a href="database-concepts.html#GUID-F290F256-66EA-47B1-9B05-49C2D5A28FD0__I6015">图3-1中</a> ，应用程序与一个本地和三个远程Oracle数据库进行通信。ORA2，ORA3和ORA4只是CONNECT语句中使用的逻辑名称。
                     </p>
                     <div class="figure" id="GUID-F290F256-66EA-47B1-9B05-49C2D5A28FD0__I6015">
                        <p class="titleinfigure">图3-1通过Oracle Net连接</p><img src="img/lnpcc004.gif" width="515" alt="下面是图3-1的描述" title="下面是图3-1的描述" longdesc="img_text/lnpcc004.html"><br><a href="img_text/lnpcc004.html">“图3-1通过Oracle Net连接”的描述</a></div>
                     <!-- class="figure" -->
                     <p>通过消除不同机器和操作系统之间网络的边界，Oracle Net为Oracle工具提供了分布式处理环境。本节介绍Pro * C / C ++如何通过Oracle Net支持分布式处理。您将了解您的应用程序的用途<a id="d14014e483" class="indexterm-anchor"></a><a id="d14014e487" class="indexterm-anchor"></a><a id="d14014e491" class="indexterm-anchor"></a> 
                     </p>
                     <ul style="list-style-type:disc">
                        <li>
                           <p>直接或间接访问其他数据库</p>
                        </li>
                        <li>
                           <p>同时访问本地和远程数据库的任意组合</p>
                        </li>
                        <li>
                           <p>建立到同一数据库的多个连接</p>
                        </li>
                     </ul>
                     <p>有关安装Oracle Net和识别可用数据库的详细信息，请参阅<a href="../netag/identifying-and-accessing-database.html#NETAG-GUID-5BC573CE-BA12-4251-A987-429095385EC2" target="_blank">识别和访问数据库</a>以及系统特定的Oracle文档。<a id="d14014e512" class="indexterm-anchor"></a></p>
                  </div>
               </div><a id="LNPCC3121"></a><div class="props_rev_3"><a id="GUID-7131D874-1BED-4607-89BE-63C440B04B42" name="GUID-7131D874-1BED-4607-89BE-63C440B04B42"></a><h4 id="LNPCC-GUID-7131D874-1BED-4607-89BE-63C440B04B42" class="sect4"><span class="enumeration_section">3.2.3</span>默认数据库和连接</h4>
                  <div>
                     <p>每个节点都有一个<span class="italic">默认</span>数据库。如果在CONNECT语句中指定数据库名称但没有域，则连接到指定的本地或远程节点上的缺省数据库。 <a id="d14014e529" class="indexterm-anchor"></a><a id="d14014e531" class="indexterm-anchor"></a> 
                     </p>
                     <p><span class="italic">默认</span>连接由没有AT子句的CONNECT语句创建。连接可以是任何本地或远程节点上的任何默认或非默认数据库。没有AT子句的SQL语句是针对默认连接执行的。相反， <span class="italic">非默认</span>连接由具有AT子句的CONNECT语句进行。具有AT子句的SQL语句针对非默认连接执行。 <a id="d14014e544" class="indexterm-anchor"></a><a id="d14014e546" class="indexterm-anchor"></a> 
                     </p>
                     <p>所有数据库名称必须唯一，但两个或多个数据库名称可以指定相同的连接。也就是说，您可以与任何节点上的任何数据库建立多个连接。<a id="d14014e553" class="indexterm-anchor"></a></p>
                  </div>
               </div><a id="LNPCC3122"></a><div class="props_rev_3"><a id="GUID-08ADAF24-2F40-4034-91B6-FB2666C1366E" name="GUID-08ADAF24-2F40-4034-91B6-FB2666C1366E"></a><h4 id="LNPCC-GUID-08ADAF24-2F40-4034-91B6-FB2666C1366E" class="sect4"><span class="enumeration_section">3.2.4</span>显式连接</h4>
                  <div>
                     <p>通常，您建立与Oracle的连接，如下所示：</p><pre class="oac_no_warn" dir="ltr">EXEC SQL CONNECT：用户名IDENTIFIED BY：密码<span class="bold">;</span>
</pre><p>你也可以使用</p><pre class="oac_no_warn" dir="ltr">EXEC SQL CONNECT：usr_pwd;</pre><p>其中<span class="italic">usr_pwd</span>包含<span class="italic">用户名</span> / <span class="italic">密码</span> 。
                     </p>
                     <p>您可以使用userid自动连接到Oracle <a id="d14014e596" class="indexterm-anchor"></a> 
                     </p><pre class="oac_no_warn" dir="ltr">CLUSTER $用户名</pre><p>其中<span class="italic">username</span>是您当前的操作系统用户或任务名称，CLUSTER $ <span class="italic">username</span>是有效的Oracle用户ID。您只需将预编译器传递给斜杠（/）字符，如下所示：</p><pre class="oac_no_warn" dir="ltr">char oracleid ='/'; ...EXEC SQL CONNECT：oracleid;</pre><p>这会自动将您作为用户CLUSTER $ <span class="italic">username连接</span> 。
                     </p>
                     <p>如果未指定数据库和节点，则会连接到当前节点的缺省数据库。如果要连接到其他数据库，则必须明确标识该数据库。</p>
                     <p>使用<span class="italic">显式连接</span> ，您可以直接连接到另一个数据库，为连接提供将在SQL语句中引用的名称。您可以同时连接到多个数据库，也可以多次连接到同一个数据库。 <a id="d14014e624" class="indexterm-anchor"></a><a id="d14014e628" class="indexterm-anchor"></a><a id="d14014e632" class="indexterm-anchor"></a> 
                     </p>
                  </div><a id="LNPCC3123"></a><div class="props_rev_3"><a id="GUID-A1C9F5E6-D953-4A83-8A25-8E4CFA976A67" name="GUID-A1C9F5E6-D953-4A83-8A25-8E4CFA976A67"></a><h5 id="LNPCC-GUID-A1C9F5E6-D953-4A83-8A25-8E4CFA976A67" class="sect5"><span class="enumeration_section">3.2.4.1</span>单一显式连接</h5>
                     <div>
                        <p>在以下示例中，您将连接到远程节点上的单个非默认数据库：<a id="d14014e646" class="indexterm-anchor"></a></p><pre class="oac_no_warn" dir="ltr">/ *声明需要主机变量* / char username [10] =“scott”; char密码[10] =“老虎”; char db_string [20] =“NYNON”; / *为数据库连接提供唯一的名称* / EXEC SQL DECLARE DB_NAME DATABASE; / *连接到非默认数据库* / EXEC SQL CONNECT：username IDENTIFIED BY：password AT DB_NAME USING：db_string;</pre><p>此示例中的标识符用于以下目的：</p>
                        <ul style="list-style-type:disc">
                           <li>
                              <p>主机变量<span class="italic">username</span>和<span class="italic">password</span>标识有效用户。
                              </p>
                           </li>
                           <li>
                              <p>主机变量<span class="italic">db_string</span>包含用于连接到远程节点上的非默认数据库的Oracle Net语法。
                              </p>
                           </li>
                           <li>
                              <p>未声明的标识符DB_NAME命名非默认连接;它是Oracle使用的标识符， <span class="italic">而不是</span>主机或程序变量。
                              </p>
                           </li>
                        </ul>
                        <p>USING子句指定与DB_NAME关联的网络，计算机和数据库。稍后，使用AT子句（使用DB_NAME）的SQL语句将在<span class="italic">db_string</span>指定的数据库中执行。 <a id="d14014e681" class="indexterm-anchor"></a><a id="d14014e685" class="indexterm-anchor"></a><a id="d14014e689" class="indexterm-anchor"></a><a id="d14014e693" class="indexterm-anchor"></a> 
                        </p>
                        <p>或者，您可以在AT子句中使用字符主机变量，如以下示例所示：</p><pre class="oac_no_warn" dir="ltr">/ *声明需要主机变量* / char username [10] =“scott”; char密码[10] =“老虎”; char db_name [10] =“oracle1”; char db_string [20] =“NYNON”; / *使用db_name * / EXEC连接到非默认数据库SQL CONNECT：username IDENTIFIED BY：password AT：db_name USING：db_string; ...
</pre><p>如果<span class="italic">db_name</span>是主机变量，则不需要DECLARE DATABASE语句。仅当DB_NAME是未声明的标识符时，才必须在执行CONNECT之前执行DECLARE DB_NAME DATABASE语句...AT DB_NAME声明。
                        </p>
                     </div><a id="LNPCC3124"></a><div class="props_rev_3"><a id="GUID-0B254719-758F-4039-8FC7-99B281EC5989" name="GUID-0B254719-758F-4039-8FC7-99B281EC5989"></a><h6 id="LNPCC-GUID-0B254719-758F-4039-8FC7-99B281EC5989" class="sect6"><span class="enumeration_section">3.2.4.1.1</span> SQL操作</h6>
                        <div>
                           <p>如果授予该权限，则可以在非默认连接上执行任何SQL数据操作语句。例如，您可以执行以下语句序列：</p><pre class="oac_no_warn" dir="ltr">EXEC SQL AT DB_NAME SELECT ...EXEC SQL AT DB_NAME INSERT ...EXEC SQL AT DB_NAME UPDATE ...
</pre><p>在下一个示例中， <span class="italic">db_name</span>是主机变量：</p><pre class="oac_no_warn" dir="ltr">EXEC SQL AT：db_name DELETE ...
</pre><p>如果<span class="italic">db_name</span>是主机变量，则必须在DECLARE TABLE语句中定义SQL语句引用的所有数据库表。否则，预编译器会发出警告。 <a id="d14014e732" class="indexterm-anchor"></a> 
                           </p>
                        </div>
                        <div>
                           <div class="relinfo">
                              <p><strong>相关话题</strong></p>
                              <ul>
                                 <li><a href="syntactic-and-semantic-checking.html#GUID-FA93B032-BE6C-4933-992D-64CB1C271CDD">关于使用DECLARE TABLE</a></li>
                                 <li><a href="embedded-SQL-statements-and-directives.html#GUID-EE454E72-F832-4088-95A1-E6B6949470D3">DECLARE TABLE（Oracle嵌入式SQL指令）</a></li>
                              </ul>
                           </div>
                        </div>
                        
                     </div><a id="LNPCC3125"></a><div class="props_rev_3"><a id="GUID-119D6669-CA8C-4379-BB97-FC7FA7141FA9" name="GUID-119D6669-CA8C-4379-BB97-FC7FA7141FA9"></a><h6 id="LNPCC-GUID-119D6669-CA8C-4379-BB97-FC7FA7141FA9" class="sect6"><span class="enumeration_section">3.2.4.1.2</span> PL / SQL块</h6>
                        <div>
                           <p>您可以使用AT子句执行PL / SQL块。以下示例显示了语法：</p><pre class="oac_no_warn" dir="ltr">EXEC SQL AT：db_name EXECUTE begin / * PL / SQL block here * / end; END-EXEC;<a id="d14014e765" class="indexterm-anchor"></a></pre></div>
                     </div><a id="LNPCC3126"></a><div class="props_rev_3"><a id="GUID-3371BDE3-985B-43CD-B6CF-70044C8A1208" name="GUID-3371BDE3-985B-43CD-B6CF-70044C8A1208"></a><h6 id="LNPCC-GUID-3371BDE3-985B-43CD-B6CF-70044C8A1208" class="sect6"><span class="enumeration_section">3.2.4.1.3</span>光标控制</h6>
                        <div>
                           <p> </p>
                           <p>诸如OPEN，FETCH和CLOSE之类的游标控制语句是例外 - 它们从不使用AT子句。如果要将游标与显式标识的数据库关联，请使用DECLARE CURSOR语句中的AT子句，如下所示： <a id="d14014e783" class="indexterm-anchor"></a><a id="d14014e787" class="indexterm-anchor"></a><a id="d14014e791" class="indexterm-anchor"></a> 
                           </p><pre class="oac_no_warn" dir="ltr">EXEC SQL AT：db_name DECLARE emp_cursor CURSOR FOR ...EXEC SQL OPEN emp_cursor ...EXEC SQL FETCH emp_cursor ...EXEC SQL CLOSE emp_cursor;</pre><p>如果<span class="italic">db_name</span>是主机变量，则其声明必须在引用DECLAREd游标的所有SQL语句的范围内。例如，如果在一个子程序中打开游标，然后在另一个子程序中打开它，则必须全局声明<span class="italic">db_name</span> 。
                           </p>
                           <p>从光标打开，CLOSing或FETCHing时，不使用AT子句。如果在游标声明中没有使用AT子句，则SQL语句在DECLARE CURSOR语句的AT子句中指定的数据库中执行，或者在缺省数据库中执行。</p>
                           <p>AT： <span class="italic">host_variable</span>子句提供更改与游标关联的连接的功能。但是，您无法在光标打开时更改关联。请考虑以下示例： <a id="d14014e813" class="indexterm-anchor"></a><a id="d14014e817" class="indexterm-anchor"></a> 
                           </p><pre class="oac_no_warn" dir="ltr">EXEC SQL AT：db_name DECLARE emp_cursor CURSOR FOR ...strcpy（db_name，“oracle1”）; EXEC SQL OPEN emp_cursor; EXEC SQL FETCH emp_cursor INTO ...strcpy（db_name，“oracle2”）; EXEC SQL OPEN emp_cursor; / *非法，游标仍然打开* / EXEC SQL FETCH emp_cursor INTO ...
</pre><p>这是非法的，因为当您尝试执行第二个OPEN语句时， <span class="italic">emp_cursor</span>仍处于打开状态。不为不同的连接维护单独的游标;只有一个<span class="italic">emp_cursor</span> ，必须先关闭才能重新打开另一个连接。要调试最后一个示例，只需在重新打开之前关闭游标，如下所示：</p><pre class="oac_no_warn" dir="ltr">...EXEC SQL CLOSE emp_cursor; - 关闭游标第一个strcpy（db_name，“oracle2”）; EXEC SQL OPEN emp_cursor; EXEC SQL FETCH emp_cursor INTO ...
</pre></div>
                     </div><a id="LNPCC3127"></a><div class="props_rev_3"><a id="GUID-154D87A0-5CD3-42BF-B9F8-F67EE485C3A1" name="GUID-154D87A0-5CD3-42BF-B9F8-F67EE485C3A1"></a><h6 id="LNPCC-GUID-154D87A0-5CD3-42BF-B9F8-F67EE485C3A1" class="sect6"><span class="enumeration_section">3.2.4.1.4</span>动态SQL</h6>
                        <div>
                           <p> </p>
                           <p>动态SQL语句类似于游标控制语句，因为有些语句从不使用AT子句。</p>
                           <p>对于动态SQL方法1，如果要在非默认连接上执行语句，则必须使用AT子句。一个例子如下： <a id="d14014e849" class="indexterm-anchor"></a><a id="d14014e853" class="indexterm-anchor"></a><a id="d14014e857" class="indexterm-anchor"></a> 
                           </p><pre class="oac_no_warn" dir="ltr">EXEC SQL AT：db_name EXECUTE IMMEDIATE：sql_stmt;</pre><p>对于方法2,3和4，如果要在非默认连接中执行语句，则仅在DECLARE STATEMENT语句中使用AT子句。所有其他动态SQL语句（如PREPARE，DESCRIBE，OPEN，FETCH和CLOSE）从不使用AT子句。下一个示例显示方法2： <a id="d14014e866" class="indexterm-anchor"></a><a id="d14014e870" class="indexterm-anchor"></a> 
                           </p><pre class="oac_no_warn" dir="ltr">EXEC SQL AT：db_name DECLARE sql_stmt STATEMENT; EXEC SQL PREPARE sql_stmt FROM：sql_string; EXEC SQL EXECUTE sql_stmt;</pre><p>以下示例显示方法3：</p><pre class="oac_no_warn" dir="ltr">EXEC SQL AT：db_name DECLARE sql_stmt STATEMENT; EXEC SQL PREPARE sql_stmt FROM：sql_string;执行SQL DECLARE emp_cursor CURSOR FOR sql_stmt; EXEC SQL OPEN emp_cursor ...EXEC SQL FETCH emp_cursor INTO ...EXEC SQL CLOSE emp_cursor;</pre></div>
                     </div>
                  </div><a id="LNPCC3128"></a><div class="props_rev_3"><a id="GUID-F3E1E908-206A-4066-B51B-339D1DFE4144" name="GUID-F3E1E908-206A-4066-B51B-339D1DFE4144"></a><h5 id="LNPCC-GUID-F3E1E908-206A-4066-B51B-339D1DFE4144" class="sect5"><span class="enumeration_section">3.2.4.2</span>多个显式连接</h5>
                     <div>
                        <p>您可以将AT <span class="italic">db_name</span>子句用于多个显式连接，就像对单个显式连接一样。在以下示例中，您同时连接到两个非默认数据库：<a id="d14014e895" class="indexterm-anchor"></a><a id="d14014e899" class="indexterm-anchor"></a></p><pre class="oac_no_warn" dir="ltr">/ *声明需要主机变量* / char username [10] =“scott”; char密码[10] =“老虎”; char db_string1 [20] =“NYNON1”; char db_string2 [20] =“CHINON”; .../ *为每个数据库连接提供唯一的名称* / EXEC SQL DECLARE DB_NAME1 DATABASE; EXEC SQL DECLARE DB_NAME2 DATABASE; / *连接到两个非默认数据库* / EXEC SQL CONNECT：username IDENTIFIED BY：password AT DB_NAME1 USING：db_string1; EXEC SQL CONNECT：username IDENTIFIED BY：password AT DB_NAME2 USING：db_string2;</pre><p>声明标识符DB_NAME1和DB_NAME2，然后用于命名两个非默认节点上的默认数据库，以便以后的SQL语句可以按名称引用数据库。</p>
                        <p>或者，您可以在AT子句中使用主机变量，如以下示例所示：</p><pre class="oac_no_warn" dir="ltr">/ *声明需要主机变量* / char username [10] =“scott”; char密码[10] =“老虎”; char db_name [20]; char db_string [20]; int n_defs = 3; / *连接数* / ...for（i = 0; i &lt;n_defs; i ++）{/ *获取下一个数据库名称和OracleNet字符串* / printf（“数据库名称：”）;得到（DB_NAME）; printf（“OracleNet）string：”）;得到（db_string）; / *执行connect * / EXEC SQL CONNECT：username IDENTIFIED BY：password AT：db_name USING：db_string; }</pre><p>您还可以使用此方法建立到同一数据库的多个连接，如以下示例所示：</p><pre class="oac_no_warn" dir="ltr">strcpy（db_string，“NYNON”）; for（i = 0; i &lt;ndefs; i ++）{/ *连接到非默认数据库* / printf（“数据库名称：”）;得到（DB_NAME）; EXEC SQL CONNECT：username IDENTIFIED BY：password AT：db_name USING：db_string; } ...
</pre><p>您必须为连接使用不同的数据库名称，即使它们使用相同的OracleNet字符串。但是，您只需使用一个数据库名称即可将两次连接到同一数据库，因为该名称同时标识了默认数据库和非默认数据库。</p>
                     </div>
                  </div><a id="LNPCC3129"></a><div class="props_rev_3"><a id="GUID-17D3997B-B7AC-4734-8CA0-83FC0E6417AD" name="GUID-17D3997B-B7AC-4734-8CA0-83FC0E6417AD"></a><h5 id="LNPCC-GUID-17D3997B-B7AC-4734-8CA0-83FC0E6417AD" class="sect5"><span class="enumeration_section">3.2.4.3</span>确保数据完整性</h5>
                     <div>
                        <p>您的应用程序必须确保在两个或多个远程数据库上操作数据的事务的完整性。也就是说，程序必须提交或回滚事务中的<span class="italic">所有</span> SQL语句。如果网络出现故障或其中一个系统崩溃，这可能是不可能的。 <a id="d14014e932" class="indexterm-anchor"></a> 
                        </p>
                        <p>例如，假设您正在使用两个记帐数据库。您在一个数据库上记入一个帐户并在另一个数据库上记入一个帐户，然后在每个数据库中发出一个COMMIT。您的程序可以确保提交或回滚两个事务。</p>
                     </div>
                  </div>
               </div><a id="LNPCC3130"></a><div class="props_rev_3"><a id="GUID-B74EEF83-F1BA-467E-B4E6-B97D94D89AD1" name="GUID-B74EEF83-F1BA-467E-B4E6-B97D94D89AD1"></a><h4 id="LNPCC-GUID-B74EEF83-F1BA-467E-B4E6-B97D94D89AD1" class="sect4"><span class="enumeration_section">3.2.5</span>隐式连接</h4>
                  <div>
                     <p>通过Oracle分布式查询工具支持隐式连接，该工具不需要显式连接，但仅支持SELECT语句。分布式查询允许单个SELECT语句访问一个或多个非默认数据库上的数据。</p>
                     <p>分布式查询工具依赖于数据库链接，该链接为CONNECT <span class="italic">语句</span>而不是连接本身分配名称。 <a id="d14014e953" class="indexterm-anchor"></a>  在运行时，嵌入式SELECT语句由指定的Oracle Server执行，该服务器<span class="italic">隐式</span>连接到非默认数据库以获取所需的数据。 <a id="d14014e959" class="indexterm-anchor"></a> 
                     </p>
                  </div><a id="LNPCC3131"></a><div class="props_rev_3"><a id="GUID-E421FD4A-EF34-4AC2-9C08-D49110EDAA01" name="GUID-E421FD4A-EF34-4AC2-9C08-D49110EDAA01"></a><h5 id="LNPCC-GUID-E421FD4A-EF34-4AC2-9C08-D49110EDAA01" class="sect5"><span class="enumeration_section">3.2.5.1</span>单隐式连接</h5>
                     <div>
                        <p>在下一个示例中，您将连接到单个非默认数据库。首先，程序执行以下语句来定义数据库链接（数据库链接通常由DBA或用户以交互方式建立）： <a id="d14014e975" class="indexterm-anchor"></a><a id="d14014e979" class="indexterm-anchor"></a><a id="d14014e983" class="indexterm-anchor"></a> 
                        </p><pre class="oac_no_warn" dir="ltr">EXEC SQL CREATE DATABASE LINK db_link CONNECT TO username IDENTIFIED BY password USING'NYNON';</pre><p>然后，程序可以使用数据库链接查询非默认EMP表，如下所示： <a id="d14014e992" class="indexterm-anchor"></a> 
                        </p><pre class="oac_no_warn" dir="ltr">EXEC SQL SELECT ENAME，JOB INTO：emp_name，：job_title FROM emp @ db_link WHERE DEPTNO =：dept_number;</pre><p>数据库链接与嵌入式SQL语句的AT子句中使用的数据库名称无关。它只是告诉Oracle非缺省数据库的位置，路径，以及要使用的Oracle用户名和密码。数据库链接存储在数据字典中，直到显式删除。 <a id="d14014e1001" class="indexterm-anchor"></a> 
                        </p>
                        <p>在我们的示例中，默认Oracle Server使用数据库链接<span class="italic">db_link</span>通过Oracle Net登录到非默认数据库。查询将提交到默认服务器，但会“转发”到非默认数据库以供执行。 <a id="d14014e1011" class="indexterm-anchor"></a> 
                        </p>
                        <p>为了更容易地引用数据库链接，您可以交互式创建同义词，如下所示： <a id="d14014e1018" class="indexterm-anchor"></a> 
                        </p><pre class="oac_no_warn" dir="ltr">EXEC SQL CREATE SYNONYM emp FOR emp @ db_link;</pre><p>然后，您的程序可以查询非默认EMP表，如下所示：</p><pre class="oac_no_warn" dir="ltr">EXEC SQL SELECT ENAME，JOB INTO：emp_name，：job_title FROM emp WHERE DEPTNO =：dept_number;</pre><p>这为<span class="italic">emp</span>提供了位置透明度。 <a id="d14014e1034" class="indexterm-anchor"></a> 
                        </p>
                     </div>
                  </div><a id="LNPCC3132"></a><div class="props_rev_3"><a id="GUID-65667043-94EF-4833-B30A-B98F0C00241F" name="GUID-65667043-94EF-4833-B30A-B98F0C00241F"></a><h5 id="LNPCC-GUID-65667043-94EF-4833-B30A-B98F0C00241F" class="sect5"><span class="enumeration_section">3.2.5.2</span>多个隐式连接</h5>
                     <div>
                        <p>在以下示例中，您将同时连接到两个非默认数据库。首先，执行以下语句序列来定义两个数据库链接并创建两个同义词： <a id="d14014e1050" class="indexterm-anchor"></a> 
                        </p><pre class="oac_no_warn" dir="ltr">EXEC SQL CREATE DATABASE LINK db_link1通过password1使用'NYNON'连接到username1; EXEC SQL CREATE DATABASE LINK db_link2连接到username2通过password2识别'CHINON'; EXEC SQL CREATE SYNONYM emp FOR emp @ db_link1; EXEC SQL CREATE SYNONYM dept for dept @ db_link2;</pre><p>然后，您的程序可以查询非默认的EMP和DEPT表，如下所示：</p><pre class="oac_no_warn" dir="ltr">EXEC SQL SELECT ENAME，JOB，SAL，LOC FROM emp，dept WHERE emp。DEPTNO = dept。DEPTNO AND DEPTNO =：dept_number;</pre><p>甲骨文执行由执行在<span class="italic">db_link1</span>非默认EMP表和<span class="italic">db_link2</span>非默认DEPT表之间的连接查询。
                        </p>
                     </div>
                  </div>
               </div>
            </div><a id="LNPCC3133"></a><div class="props_rev_3"><a id="GUID-2DA1A2A2-145D-4444-B391-806D8013397A" name="GUID-2DA1A2A2-145D-4444-B391-806D8013397A"></a><h3 id="LNPCC-GUID-2DA1A2A2-145D-4444-B391-806D8013397A" class="sect3"><span class="enumeration_section">3.3</span>交易术语的定义</h3>
               <div>
                  <p>在深入研究交易主题之前，您应该了解本节中定义的术语。</p>
                  <p>Oracle管理的作业或任务称为<span class="italic">会话</span> 。运行应用程序或SQL * Forms等工具并连接到数据库时，将调用<span class="italic">用户会话</span> 。 <a id="d14014e1089" class="indexterm-anchor"></a><a id="d14014e1093" class="indexterm-anchor"></a> 
                  </p>
                  <p>Oracle允许用户会话同时工作并共享计算机资源。为此，Oracle必须控制<span class="italic">并发性</span> ，许多用户访问相同的数据。如果没有足够的并发控制，可能会丢失<span class="italic">数据完整性</span> 。也就是说，数据或结构的更改可能以错误的顺序进行。 <a id="d14014e1106" class="indexterm-anchor"></a><a id="d14014e1111" class="indexterm-anchor"></a> 
                  </p>
                  <p>Oracle使用<span class="italic">锁</span> （有时称为<span class="italic">enqueues</span> ）来控制对数据的并发访问。锁可以为您提供数据库资源的临时所有权，例如表或数据行。因此，在您完成数据之前，其他用户无法更改数据。 <a id="d14014e1124" class="indexterm-anchor"></a><a id="d14014e1128" class="indexterm-anchor"></a> 
                  </p>
                  <p>您永远不需要显式锁定资源，因为默认锁定机制可以保护Oracle数据和结构。但是，您可以在表或行上请求<span class="italic">数据锁定</span> ，以便覆盖默认锁定。您可以选择多种锁定<span class="italic">模式</span> ，例如<span class="italic">行共享</span>和<span class="italic">独占</span> 。 <a id="d14014e1147" class="indexterm-anchor"></a><a id="d14014e1149" class="indexterm-anchor"></a> 
                  </p>
                  <p>当两个或多个用户尝试访问同一数据库对象时，可能会发生<span class="italic">死锁</span> 。例如，如果每个用户尝试更新当前由另一个锁定的行，则更新同一个表的两个用户可能会等待。因为每个用户都在等待另一个用户持有的资源，所以在Oracle打破死锁之前都不能继续。Oracle向完成最少工作量的参与事务发出错误信号，并且“在等待资源时检测到死锁”Oracle错误代码返回到SQLCA中的<span class="italic">sqlcode</span> 。 <a id="d14014e1162" class="indexterm-anchor"></a> 
                  </p>
                  <p>当一个用户查询表并同时由另一个用户更新时，Oracle会为查询生成表的数据的<span class="italic">读一致</span>视图。也就是说，一旦查询开始并且随着查询的进行，查询读取的数据就不会改变。随着更新活动的继续，Oracle会获取表数据的<span class="italic">快照</span>并记录<span class="italic">回滚段中的</span>更改。Oracle使用回滚段中的信息来构建读取一致的查询结果，并在必要时撤消更改。
                  </p>
               </div>
            </div><a id="LNPCC3134"></a><div class="props_rev_3"><a id="GUID-4225AA6B-A82A-49DD-A2FA-B730F9CAAF53" name="GUID-4225AA6B-A82A-49DD-A2FA-B730F9CAAF53"></a><h3 id="LNPCC-GUID-4225AA6B-A82A-49DD-A2FA-B730F9CAAF53" class="sect3"><span class="enumeration_section">3.4</span>如何确保数据完整性</h3>
               <div>
                  <p>Oracle是面向事务的。也就是说，Oracle使用事务来确保数据完整性。事务是您为完成某项任务而定义的一系列一个或多个逻辑相关的SQL语句。Oracle将一系列SQL语句视为一个单元，以便语句带来的所有更改可以同时<span class="italic">提交</span> （永久）或<span class="italic">回滚</span> （撤消）。如果您的应用程序在事务中间失败，则数据库将自动恢复到其以前的（事务前）状态。 <a id="d14014e1195" class="indexterm-anchor"></a><a id="d14014e1199" class="indexterm-anchor"></a><a id="d14014e1203" class="indexterm-anchor"></a><a id="d14014e1207" class="indexterm-anchor"></a> 
                  </p>
                  <p>接下来的部分将向您展示如何定义和控制事务。具体来说，您将学习如何： <a id="d14014e1214" class="indexterm-anchor"></a> 
                  </p>
                  <ul style="list-style-type:disc">
                     <li>
                        <p>连接到数据库。</p>
                     </li>
                     <li>
                        <p>建立并发连接。</p>
                     </li>
                     <li>
                        <p>开始和结束交易。</p>
                     </li>
                     <li>
                        <p>使用COMMIT语句使事务永久化。</p>
                     </li>
                     <li>
                        <p>将SAVEPOINT语句与ROLLBACK TO语句一起使用以撤消部分事务。</p>
                     </li>
                     <li>
                        <p>使用ROLLBACK语句撤消整个事务。</p>
                     </li>
                     <li>
                        <p>指定RELEASE选项以释放资源并注销数据库。</p>
                     </li>
                     <li>
                        <p>使用SET TRANSACTION语句设置只读事务。</p>
                     </li>
                     <li>
                        <p>使用FOR UPDATE子句或LOCK TABLE语句覆盖默认锁定。</p>
                     </li>
                  </ul>
                  <p>有关本章中讨论的SQL语句的详细信息，请参阅<a href="../sqlrf/index.html" target="_blank"><span class="italic">Oracle数据库SQL语言参考</span></a> 。
                  </p>
               </div>
            </div><a id="LNPCC3135"></a><div class="props_rev_3"><a id="GUID-13E912AB-0FD7-4F36-A34C-5CA5F25F0612" name="GUID-13E912AB-0FD7-4F36-A34C-5CA5F25F0612"></a><h3 id="LNPCC-GUID-13E912AB-0FD7-4F36-A34C-5CA5F25F0612" class="sect3"><span class="enumeration_section">3.5</span>如何开始和结束交易</h3>
               <div>
                  <p>您在程序中使用第一个可执行SQL语句（除CONNECT之外）开始事务。当一个事务结束时，下一个可执行SQL语句会自动开始另一个事务。因此，每个可执行语句都是事务的一部分。因为它们无法回滚且无需提交，所以声明性SQL语句不被视为事务的一部分。 <a id="d14014e1265" class="indexterm-anchor"></a><a id="d14014e1269" class="indexterm-anchor"></a><a id="d14014e1273" class="indexterm-anchor"></a> 
                  </p>
                  <p>您可以通过以下方式之一结束交易： <a id="d14014e1280" class="indexterm-anchor"></a> 
                  </p>
                  <ul style="list-style-type:disc">
                     <li>
                        <p>使用或不使用RELEASE选项对COMMIT或ROLLBACK语句进行编码。这<span class="italic">明确</span>地对数据库进行永久或撤消更改。
                        </p>
                     </li>
                     <li>
                        <p>编写数据定义语句（例如，ALTER，CREATE或GRANT），在执行之前<span class="italic">和</span>之后发出自动COMMIT。这<span class="italic">隐式</span>地对数据库进行了永久性更改。 <a id="d14014e1301" class="indexterm-anchor"></a><a id="d14014e1305" class="indexterm-anchor"></a><a id="d14014e1309" class="indexterm-anchor"></a> 
                        </p>
                     </li>
                  </ul>
                  <p>当系统出现故障或用户会话因软件问题，硬件问题或强制中断而意外停止时，事务也会结束。Oracle回滚了该事务。 <a id="d14014e1316" class="indexterm-anchor"></a> 
                  </p>
                  <p>如果程序在事务中失败，Oracle会检测到错误并回滚事务。如果操作系统出现故障，Oracle会将数据库还原到以前的（事务前）状态。 <a id="d14014e1323" class="indexterm-anchor"></a><a id="d14014e1327" class="indexterm-anchor"></a> 
                  </p>
               </div>
            </div><a id="LNPCC3136"></a><div class="props_rev_3"><a id="GUID-31E8EFBB-10EB-4F87-8E37-6F4A27FFB557" name="GUID-31E8EFBB-10EB-4F87-8E37-6F4A27FFB557"></a><h3 id="LNPCC-GUID-31E8EFBB-10EB-4F87-8E37-6F4A27FFB557" class="sect3"><span class="enumeration_section">3.6</span>使用COMMIT语句</h3>
               <div>
                  <p>如果不使用COMMIT或ROLLBACK语句细分程序，Oracle会将整个程序视为单个事务（除非程序包含发出自动COMMITS的数据定义语句）。</p>
                  <p>您使用COMMIT语句永久更改数据库。在更改为COMMITted之前，其他用户无法访问更改的数据;他们在交易开始之前就看到了它。具体来说，是COMMIT语句<a id="d14014e1346" class="indexterm-anchor"></a><a id="d14014e1350" class="indexterm-anchor"></a><a id="d14014e1354" class="indexterm-anchor"></a> 
                  </p>
                  <ul style="list-style-type:disc">
                     <li>
                        <p>在当前事务期间对数据库进行永久性所有更改</p>
                     </li>
                     <li>
                        <p>使这些更改对其他用户可见</p>
                     </li>
                     <li>
                        <p>删除所有保存点（请参阅下一节）</p>
                     </li>
                     <li>
                        <p>释放所有行和表锁，但不解析锁</p>
                     </li>
                     <li>
                        <p>关闭CURRENT OF子句中引用的游标，或者，当MODE = ANSI时，关闭COMMIT语句中指定的连接的<span class="italic">所有</span>显式游标</p>
                     </li>
                     <li>
                        <p>结束交易</p>
                     </li>
                  </ul>
                  <p>COMMIT语句对主机变量的值或程序中的控制流没有影响。</p>
                  <p>当MODE = ORACLE时，CURRENT OF子句中未引用的显式游标在COMMIT之间保持打开状态。这可以提高性能。</p>
                  <p>因为它们是正常处理的一部分，COMMIT语句应该通过程序的主路径内联放置。在程序终止之前，它必须显式COMMIT挂起的更改。否则，Oracle会回滚它们。在以下示例中，您提交事务并断开与Oracle的连接： <a id="d14014e1387" class="indexterm-anchor"></a><a id="d14014e1391" class="indexterm-anchor"></a><a id="d14014e1393" class="indexterm-anchor"></a><a id="d14014e1397" class="indexterm-anchor"></a> 
                  </p><pre class="oac_no_warn" dir="ltr">EXEC SQL COMMIT WORK RELEASE;</pre><p>可选关键字WORK提供ANSI兼容性。RELEASE选项释放程序保存的所有Oracle资源（锁和游标）并注销数据库。 <a id="d14014e1406" class="indexterm-anchor"></a><a id="d14014e1410" class="indexterm-anchor"></a><a id="d14014e1414" class="indexterm-anchor"></a> 
                  </p>
                  <p>您不需要使用COMMIT语句跟随数据定义语句，因为数据定义语句在执行之前<span class="italic">和</span>之后发出自动COMMIT。因此，无论它们是成功还是失败，都会提交先前的交易。
                  </p>
               </div>
               <div>
                  <div class="relinfo">
                     <p><strong>相关话题</strong></p>
                     <ul>
                        <li><a href="database-concepts.html#GUID-56C7EE05-CBFF-467F-9C08-856500AF335E">获取跨COMMIT</a></li>
                     </ul>
                  </div>
               </div>
               <a id="LNPCC3137"></a><div class="props_rev_3"><a id="GUID-D244BF2E-4CC6-4353-9C8F-F7035DB2EE28" name="GUID-D244BF2E-4CC6-4353-9C8F-F7035DB2EE28"></a><h4 id="LNPCC-GUID-D244BF2E-4CC6-4353-9C8F-F7035DB2EE28" class="sect4"><span class="enumeration_section">3.6.1</span> DECLARE CURSOR语句中的WITH HOLD子句</h4>
                  <div>
                     <p>在COMMIT之后单词CURSOR之后保持打开的任何已使用WITH HOLD子句声明的游标。以下示例显示如何使用此子句：</p><pre class="oac_no_warn" dir="ltr">执行SQL DECLARE C1游标保持从EMP到7600和7700 END-EXEC之间的EMPNO中选择ENAME。</pre><p>不能为UPDATE声明游标。 DB2中使用WITH HOLD子句来覆盖默认值，即在提交时关闭所有游标。Pro * COBOL提供此子句是为了便于将应用程序从DB2迁移到Oracle。当MODE = ANSI时，Oracle使用DB2默认值，但必须在Declare Section中声明所有主机变量。要避免使用Declare Section，请使用<span class="italic">下面</span>描述的预编译器选项<span class="italic">CLOSE_ON_COMMIT</span> 。
                     </p>
                  </div>
                  <div>
                     <div class="relinfo">
                        <p><strong>相关话题</strong></p>
                        <ul>
                           <li><a href="embedded-SQL-statements-and-directives.html#GUID-A4D5E4DC-DC90-44F9-A43B-89037156A0B7">DECLARE CURSOR（嵌入式SQL指令）</a></li>
                        </ul>
                     </div>
                  </div>
                  
               </div><a id="LNPCC3138"></a><div class="props_rev_3"><a id="GUID-D6BE6530-B141-4FE7-A86F-1D09481B410A" name="GUID-D6BE6530-B141-4FE7-A86F-1D09481B410A"></a><h4 id="LNPCC-GUID-D6BE6530-B141-4FE7-A86F-1D09481B410A" class="sect4"><span class="enumeration_section">3.6.2</span> CLOSE_ON_COMMIT预编译器选项</h4>
                  <div>
                     <p>预编译器选项CLOSE_ON_COMMIT <span class="italic"> </span>可用于覆盖MODE = ANSI的默认行为（如果在命令行上指定MODE = ANSI，则在提交时未使用WITH HOLD子句声明的任何游标都将关闭）：</p><pre class="oac_no_warn" dir="ltr">CLOSE_ON_COMMIT = {是|没有}</pre><p>默认值为NO。必须仅在命令行或配置文件中输入此选项。</p>
                     <div class="infoboxnote" id="GUID-D6BE6530-B141-4FE7-A86F-1D09481B410A__GUID-EEC554DF-94B4-4E80-A9F0-668E3AE33C88">
                        <p class="notep1">注意：</p>
                        <p>仔细使用此选项;如果由于需要为每个OPEN语句重新解析而多次打开和关闭游标，则应用程序可能会变慢。</p>
                     </div>
                  </div>
                  <div>
                     <div class="relinfo">
                        <p><strong>相关话题</strong></p>
                        <ul>
                           <li><a href="precompiler-options.html#GUID-198ADD9B-90D5-4562-AD98-5BCF25216CF2">CLOSE_ON_COMMIT</a></li>
                           <li><a href="precompiler-options.html#GUID-A3A29202-076E-4813-A7FE-95F219D9FB0B">宏观和微观选择</a></li>
                        </ul>
                     </div>
                  </div>
                  
               </div>
            </div><a id="LNPCC3139"></a><div class="props_rev_3"><a id="GUID-3573A6EF-0B59-452C-854C-09EAE705E526" name="GUID-3573A6EF-0B59-452C-854C-09EAE705E526"></a><h3 id="LNPCC-GUID-3573A6EF-0B59-452C-854C-09EAE705E526" class="sect3"><span class="enumeration_section">3.7</span>使用SAVEPOINT语句</h3>
               <div>
                  <p>您可以使用SAVEPOINT语句标记和命名事务处理中的当前点。每个标记点称为<span class="italic">保存点</span> 。例如，以下语句标记名为<span class="italic">start_delete</span>的保存点： <a id="d14014e1527" class="indexterm-anchor"></a><a id="d14014e1531" class="indexterm-anchor"></a><a id="d14014e1535" class="indexterm-anchor"></a> 
                  </p><pre class="oac_no_warn" dir="ltr">EXEC SQL SAVEPOINT start_delete;</pre><p>保存点允许您划分长事务，使您可以更好地控制复杂的过程。例如，如果事务执行多个功能，则可以在每个功能之前标记保存点。然后，如果函数失败，您可以轻松地将Oracle数据恢复到以前的状态，恢复，然后重新执行该函数。 <a id="d14014e1544" class="indexterm-anchor"></a><a id="d14014e1548" class="indexterm-anchor"></a> 
                  </p>
                  <p>要撤消部分事务，可以将保存点与ROLLBACK语句及其TO SAVEPOINT子句一起使用。在以下示例中，您访问表MAIL_LIST以插入新列表，更新旧列表以及删除（一些）非活动列表。删除后，检查SQLCA中<span class="italic">sqlerrd</span>的第三个元素<span class="italic">是否</span>已删除的行数。如果数字意外大，则回滚到保存点<span class="italic">start_delete</span> ，仅撤消删除。 <a id="d14014e1561" class="indexterm-anchor"></a> 
                  </p><pre class="oac_no_warn" dir="ltr">...for（;;）{printf（“客户编号？“）; gets（temp）; cust_number = atoi（temp）; printf（”客户名称？“）; gets（cust_name）; EXEC SQL INSERT INTO mail_list（custno，cname，stat）VALUES（：cust_number，：cust_name，'ACTIVE'）; ...} for（;;）{printf（“客户编号？“）; gets（temp）; cust_number = atoi（temp）; printf（”新状态？“）; gets（new_status）; EXEC SQL UPDATE mail_list SET stat =：new_status WHERE custno =：cust_number;} / * mark savepoint * / EXEC SQL SAVEPOINT start_delete; EXEC SQL DELETE FROM mail_list WHERE stat ='INACTIVE'; if（sqlca .sqlerrd [2] &lt;25）/ *检查删除的行数* / printf（“删除的行数是％d \ n”，sqlca.sqlerrd [2]）;否则{printf（“撤消％d行的删除） \ n“，sqlca.sqlerrd [2]）; EXEC SQL WHENEVER SQLERROR GOTO sql_error; EXEC SQL ROLLBACK TO SAVEPOINT start_delete;} EXEC SQL WHENEVER SQLERROR CONTINUE; EXEC SQL COMMIT WORK RELEASE; exit（0）; sql_error：EXEC SQL WHENEVER SQLERROR CONTINUE; EXEC SQL ROLLBACK WORK RELEASE; printf（“Processing error \ n”）; exit（1）;</pre><p>回滚到保存点会删除在该保存点之后标记的所有保存点。但是，您回滚的保存点不会被删除。例如，如果标记五个保存点，则回滚到第三个保存点，仅删除第四个和第五个保存点。 <a id="d14014e1570" class="indexterm-anchor"></a> 
                  </p>
                  <p>如果为两个保存点指定相同的名称，则会删除较早的保存点。COMMIT或ROLLBACK语句将擦除所有保存点。</p>
               </div>
               <div>
                  <div class="relinfo">
                     <p><strong>相关话题</strong></p>
                     <ul>
                        <li><a href="handling-run-time-errors.html#GUID-EC094D1D-A3E6-4B11-8E0C-A53D5ED18872">关于使用WHENEVER指令</a></li>
                     </ul>
                  </div>
               </div>
               
            </div><a id="LNPCC3140"></a><div class="props_rev_3"><a id="GUID-522982CF-0A57-4795-9FFE-7DF4820DAA43" name="GUID-522982CF-0A57-4795-9FFE-7DF4820DAA43"></a><h3 id="LNPCC-GUID-522982CF-0A57-4795-9FFE-7DF4820DAA43" class="sect3"><span class="enumeration_section">3.8</span> ROLLBACK声明</h3>
               <div>
                  <p>您可以使用ROLLBACK语句撤消对数据库所做的挂起更改。例如，如果您犯了错误，例如从表中删除了错误的行，则可以使用ROLLBACK来恢复原始数据。TO SAVEPOINT子句允许您回滚到当前事务中的中间语句，因此您不必撤消所有更改。 <a id="d14014e1597" class="indexterm-anchor"></a><a id="d14014e1601" class="indexterm-anchor"></a><a id="d14014e1605" class="indexterm-anchor"></a><a id="d14014e1609" class="indexterm-anchor"></a><a id="d14014e1613" class="indexterm-anchor"></a> 
                  </p>
                  <p>如果启动未完成的事务（例如，SQL语句可能无法成功执行），则ROLLBACK允许您返回到起始点，以便数据库不会处于不一致状态。具体来说，就是ROLLBACK语句<a id="d14014e1620" class="indexterm-anchor"></a> 
                  </p>
                  <ul style="list-style-type:disc">
                     <li>
                        <p>撤消当前事务期间对数据库所做的所有更改</p>
                     </li>
                     <li>
                        <p>删除所有保存点</p>
                     </li>
                     <li>
                        <p>结束交易</p>
                     </li>
                     <li>
                        <p>释放所有行和表锁，但不解析锁</p>
                     </li>
                     <li>
                        <p>关闭CURRENT OF子句中引用的游标，或者当MODE = ANSI时，关闭<span class="italic">所有</span>显式游标</p>
                     </li>
                  </ul>
                  <p>ROLLBACK语句对主机变量的值或程序中的控制流没有影响。</p>
                  <p>当MODE = ORACLE时，CURRENT OF子句中未引用的显式游标在ROLLBACK之间保持打开状态。</p>
                  <p>具体来说，是ROLLBACK TO SAVEPOINT语句</p>
                  <ul style="list-style-type:disc">
                     <li>
                        <p>取消自指定的保存点被标记以来对数据库所做的更改</p>
                     </li>
                     <li>
                        <p>删除指定保存点后标记的所有保存点</p>
                     </li>
                     <li>
                        <p>释放自标记指定保存点以来获取的所有行和表锁</p>
                        <div class="infoboxnote" id="GUID-522982CF-0A57-4795-9FFE-7DF4820DAA43__GUID-63F08B2A-BAAD-46E7-AD45-7E38296378C4">
                           <p class="notep1">注意：</p>
                           <p>您不能在ROLLBACK TO SAVEPOINT语句中指定RELEASE选项。 <a id="d14014e1663" class="indexterm-anchor"></a><a id="d14014e1667" class="indexterm-anchor"></a> 
                           </p>
                        </div>
                     </li>
                  </ul>
                  <p>因为它们是异常处理的一部分，所以ROLLBACK语句应该放在错误处理例程中，离开程序的主路径。在以下示例中，您回滚事务并断开与Oracle的连接： <a id="d14014e1674" class="indexterm-anchor"></a><a id="d14014e1679" class="indexterm-anchor"></a> 
                  </p><pre class="oac_no_warn" dir="ltr">EXEC SQL ROLLBACK工作版;</pre><p>可选关键字WORK提供ANSI兼容性。RELEASE选项释放程序保存的所有资源并断开与数据库的连接。 <a id="d14014e1688" class="indexterm-anchor"></a><a id="d14014e1693" class="indexterm-anchor"></a> 
                  </p>
                  <p>如果WHENEVER SQLERROR GOTO语句分支到包含ROLLBACK语句的错误处理例程，则如果ROLLBACK因错误而失败，则程序可能会进入无限循环。您可以通过在ROLLBACK语句之前编写WHENEVER SQLERROR CONTINUE来避免这种情况，如以下示例所示： <a id="d14014e1700" class="indexterm-anchor"></a><a id="d14014e1705" class="indexterm-anchor"></a> 
                  </p><pre class="oac_no_warn" dir="ltr">执行SQL WHENEVER SQLERROR GOTO sql_error; for（;;）{printf（“员工编号？“）; gets（temp）; emp_number = atoi（temp）; printf（”员工姓名？“）; gets（emp_name）; EXEC SQL INSERT INTO emp（empno，ename）VALUES（：emp_number，：emp_name）; ...} ...sql_error：EXEC SQL WHENEVER SQLERROR CONTINUE; EXEC SQL ROLLBACK工作版; printf（“处理错误\ n”）;出口（1）;</pre><p>如果程序异常终止，Oracle会自动回滚事务。</p>
               </div>
               <div>
                  <div class="relinfo">
                     <p><strong>相关话题</strong></p>
                     <ul>
                        <li><a href="database-concepts.html#GUID-19075C1F-9F8B-46B2-9F1E-A29F39777FB5">RELEASE选项</a></li>
                     </ul>
                  </div>
               </div>
               <a id="LNPCC3141"></a><div class="props_rev_3"><a id="GUID-2805D7E7-333F-428C-A75D-F90AEB8D6661" name="GUID-2805D7E7-333F-428C-A75D-F90AEB8D6661"></a><h4 id="LNPCC-GUID-2805D7E7-333F-428C-A75D-F90AEB8D6661" class="sect4"><span class="enumeration_section">3.8.1</span>语句级回滚</h4>
                  <div>
                     <p>在执行任何SQL语句之前，Oracle会标记一个隐式保存点（不适用于您）。然后，如果语句失败，Oracle会自动将其回滚并将适用的错误代码返回到SQLCA中的<span class="italic">sqlcode</span> 。例如，如果INSERT语句通过尝试在唯一索引中插入重复值而导致错误，则回滚该语句。 <a id="d14014e1738" class="indexterm-anchor"></a><a id="d14014e1742" class="indexterm-anchor"></a> 
                     </p>
                     <p>Oracle还可以回滚单个SQL语句以打破死锁。Oracle向其中一个参与事务发出错误信号并回滚该事务中的当前语句。 <a id="d14014e1749" class="indexterm-anchor"></a><a id="d14014e1753" class="indexterm-anchor"></a> 
                     </p>
                     <p>只有失败的SQL语句启动的工作才会丢失;保存当前事务中该语句之前完成的工作。因此，如果数据定义语句失败，则不会撤消其前面的自动提交。 <a id="d14014e1760" class="indexterm-anchor"></a> 
                     </p>
                     <p>在执行SQL语句之前，Oracle必须对其进行解析，即检查它以确保它遵循语法规则并引用有效的数据库对象。执行SQL语句时检测到的错误会导致回滚，但在解析语句时检测到的错误则不会。</p>
                  </div>
               </div>
            </div><a id="LNPCC3142"></a><div class="props_rev_3"><a id="GUID-19075C1F-9F8B-46B2-9F1E-A29F39777FB5" name="GUID-19075C1F-9F8B-46B2-9F1E-A29F39777FB5"></a><h3 id="LNPCC-GUID-19075C1F-9F8B-46B2-9F1E-A29F39777FB5" class="sect3"><span class="enumeration_section">3.9</span> RELEASE选项</h3>
               <div>
                  <p>如果程序异常终止，Oracle会自动回滚更改。当您的程序未显式提交或回滚工作并使用RELEASE选项与Oracle断开连接时，会发生异常终止。当程序运行其程序，关闭打开的游标，显式提交或回滚工作，断开与Oracle的连接并将控制权返回给用户时，将发生正常终止。 <a id="d14014e1779" class="indexterm-anchor"></a><a id="d14014e1783" class="indexterm-anchor"></a><a id="d14014e1787" class="indexterm-anchor"></a> 
                  </p>
                  <p>如果它执行的最后一个SQL语句是，您的程序将正常退出</p><pre class="oac_no_warn" dir="ltr">EXEC SQL COMMIT WORK RELEASE;</pre><p>要么</p><pre class="oac_no_warn" dir="ltr">EXEC SQL ROLLBACK工作版;</pre><p>令牌WORK是可选的。否则，用户会话获取的锁和游标将在程序终止后保留，直到Oracle识别出用户会话不再处于活动状态。这可能导致多用户环境中的其他用户等待锁定资源所需的时间。 <a id="d14014e1800" class="indexterm-anchor"></a> 
                  </p>
               </div>
            </div><a id="LNPCC3143"></a><div class="props_rev_3"><a id="GUID-E390067A-6EBF-4F4A-B0EB-C98B5318D6EC" name="GUID-E390067A-6EBF-4F4A-B0EB-C98B5318D6EC"></a><h3 id="LNPCC-GUID-E390067A-6EBF-4F4A-B0EB-C98B5318D6EC" class="sect3"><span class="enumeration_section">3.10</span> SET TRANSACTION语句</h3>
               <div>
                  <p>您使用SET TRANSACTION语句开始只读事务。因为它们允许“可重复读取”，所以只读事务对于针对一个或多个表运行多个查询以及其他用户更新相同表时非常有用。SET TRANSACTION语句的示例如下： <a id="d14014e1816" class="indexterm-anchor"></a><a id="d14014e1821" class="indexterm-anchor"></a> 
                  </p><pre class="oac_no_warn" dir="ltr">EXEC SQL SET TRANSACTION READ ONLY;</pre><p>SET TRANSACTION语句必须是只读事务中的第一个SQL语句，并且只能在事务中出现一次。READ ONLY参数是必需的。它的使用不会影响其他交易。 <a id="d14014e1830" class="indexterm-anchor"></a><a id="d14014e1835" class="indexterm-anchor"></a><a id="d14014e1840" class="indexterm-anchor"></a> 
                  </p>
                  <p>只读事务中只允许SELECT，COMMIT和ROLLBACK语句。例如，包括INSERT，DELETE或SELECT FOR UPDATE OF语句会导致错误。 <a id="d14014e1847" class="indexterm-anchor"></a><a id="d14014e1852" class="indexterm-anchor"></a> 
                  </p>
                  <p>在只读事务期间，所有查询都引用数据库的相同快照，从而提供多表，多查询，读取一致的视图。其他用户可以像往常一样继续查询或更新数据。 <a id="d14014e1859" class="indexterm-anchor"></a><a id="d14014e1864" class="indexterm-anchor"></a> 
                  </p>
                  <p>COMMIT，ROLLBACK或数据定义语句结束只读事务。（回想一下，数据定义语句发出一个隐式COMMIT。） <a id="d14014e1871" class="indexterm-anchor"></a> 
                  </p>
                  <p>在以下示例中，作为商店经理，您可以使用只读事务生成摘要报告，以检查当天，过去一周和过去一个月的销售活动。在事务期间，该报告不受更新数据库的其他用户的影响。 <a id="d14014e1878" class="indexterm-anchor"></a> 
                  </p><pre class="oac_no_warn" dir="ltr">EXEC SQL SET TRANSACTION READ ONLY; EXEC SQL SELECT sum（saleamt）INTO：每日FROM销售额WHERE saledate = SYSDATE; EXEC SQL SELECT sum（saleamt）INTO：每周FROM sales WHERE saledate&gt; SYSDATE  -  7; EXEC SQL SELECT总和（saleamt）INTO：每月销售额WHERE saledate&gt; SYSDATE  -  30; EXEC SQL COMMIT WORK; / *只是结束交易，因为没有更改来制作永久* / / *格式和打印报告* /</pre></div>
            </div><a id="LNPCC3144"></a><div class="props_rev_3"><a id="GUID-65DF517F-601E-4734-B1E9-004519DF8078" name="GUID-65DF517F-601E-4734-B1E9-004519DF8078"></a><h3 id="LNPCC-GUID-65DF517F-601E-4734-B1E9-004519DF8078" class="sect3"><span class="enumeration_section">3.11</span>覆盖默认锁定</h3>
               <div>
                  <p>默认情况下，Oracle会自动为您锁定许多数据结构。但是，您可以在行或表上请求特定数据锁定，以便覆盖默认锁定。显式锁定允许您在事务期间共享或拒绝对表的访问，或确保多表和多查询读一致性。 <a id="d14014e1896" class="indexterm-anchor"></a><a id="d14014e1900" class="indexterm-anchor"></a><a id="d14014e1904" class="indexterm-anchor"></a><a id="d14014e1908" class="indexterm-anchor"></a> 
                  </p>
                  <p>使用SELECT FOR UPDATE OF语句，您可以显式锁定表的特定行，以确保它们在执行UPDATE或DELETE之前不会更改。但是，Oracle会在UPDATE或DELETE时自动获取行级锁。因此，仅当您要在UPDATE或DELETE <span class="italic">之前</span>锁定行时， <span class="italic">才</span>使用FOR UPDATE OF子句。 <a id="d14014e1916" class="indexterm-anchor"></a><a id="d14014e1920" class="indexterm-anchor"></a><a id="d14014e1924" class="indexterm-anchor"></a><a id="d14014e1928" class="indexterm-anchor"></a> 
                  </p>
                  <p>您可以使用LOCK TABLE语句显式锁定整个表。</p>
               </div><a id="LNPCC3145"></a><div class="props_rev_3"><a id="GUID-B44AF482-9E22-4C39-AC53-D9C4E5F61D96" name="GUID-B44AF482-9E22-4C39-AC53-D9C4E5F61D96"></a><h4 id="LNPCC-GUID-B44AF482-9E22-4C39-AC53-D9C4E5F61D96" class="sect4"><span class="enumeration_section">3.11.1</span>使用FOR UPDATE OF</h4>
                  <div>
                     <p>当DECLARE UPDATE或DELETE语句的CURRENT OF子句中引用的游标时，使用FOR UPDATE OF子句获取独占行锁。SELECT FOR UPDATE OF标识将要更新或删除的行，然后锁定活动集中的每一行。例如，当您想要对行中的现有值进行更新时，这很有用。在更新之前，您必须确保其他用户不会更改该行。 <a id="d14014e1946" class="indexterm-anchor"></a><a id="d14014e1950" class="indexterm-anchor"></a> 
                     </p>
                     <p>FOR UPDATE OF子句是可选的。例如，而不是编码</p><pre class="oac_no_warn" dir="ltr">EXEC SQL DECLARE emp_cursor CURSOR FOR SELECT ename，job，sal FROM emp WHERE deptno = 20 FOR更新sal;</pre><p>你可以删除FOR UPDATE OF子句并简单地编码</p><pre class="oac_no_warn" dir="ltr">EXEC SQL DECLARE emp_cursor CURSOR FOR SELECT ename，job，sal FROM emp WHERE deptno = 20;</pre><p>CURRENT OF子句指示预编译器在必要时添加FOR UPDATE子句。您可以使用CURRENT OF子句来引用游标中的最新行FETCHed。</p>
                  </div>
                  <div>
                     <div class="relinfo">
                        <p><strong>相关话题</strong></p>
                        <ul>
                           <li><a href="embedded-SQL.html#GUID-CB61E704-AA77-4F5F-BF67-A3E4F58C63C6">条款的当前条款</a></li>
                        </ul>
                     </div>
                  </div>
                  <a id="LNPCC3146"></a><div class="props_rev_3"><a id="GUID-5D916B5F-F9D7-4D37-8138-1ED8228E5ADC" name="GUID-5D916B5F-F9D7-4D37-8138-1ED8228E5ADC"></a><h5 id="LNPCC-GUID-5D916B5F-F9D7-4D37-8138-1ED8228E5ADC" class="sect5"><span class="enumeration_section">3.11.1.1</span>限制</h5>
                     <div>
                        <div class="section">
                           <p>如果使用FOR UPDATE OF子句，则无法引用多个表。</p>
                           <p>显式FOR UPDATE OF或隐式FOR UPDATE获取独占行锁。所有行都锁定在OPEN，而不是它们是FETCHed。COMMOU或ROLLBACK时释放行锁（除非您将ROLLBACK保存到保存点）。因此，在COMMIT之后，您无法从FOR UPDATE游标进行FETCH。 <a id="d14014e1988" class="indexterm-anchor"></a><a id="d14014e1993" class="indexterm-anchor"></a> 
                           </p>
                        </div>
                        <!-- class="section" -->
                     </div>
                  </div>
               </div><a id="LNPCC3147"></a><div class="props_rev_3"><a id="GUID-A62517E8-BF42-4E4D-B3A1-BD318DFB42BD" name="GUID-A62517E8-BF42-4E4D-B3A1-BD318DFB42BD"></a><h4 id="LNPCC-GUID-A62517E8-BF42-4E4D-B3A1-BD318DFB42BD" class="sect4"><span class="enumeration_section">3.11.2</span>使用LOCK TABLE</h4>
                  <div>
                     <p>您使用LOCK TABLE语句以指定的锁定模式锁定一个或多个表。例如，以下部分中的语句将EMP表锁定为<span class="italic">行共享</span>模式。行共享锁允许并发访问表;它们阻止其他用户锁定整个表以供独占使用。 <a id="d14014e2012" class="indexterm-anchor"></a><a id="d14014e2016" class="indexterm-anchor"></a><a id="d14014e2020" class="indexterm-anchor"></a><a id="d14014e2024" class="indexterm-anchor"></a><a id="d14014e2028" class="indexterm-anchor"></a><a id="d14014e2032" class="indexterm-anchor"></a> 
                     </p><pre class="oac_no_warn" dir="ltr">EXEC SQL LOCK表EMP在行分享模式NOWAIT;</pre><p>锁定模式确定可以在表格上放置哪些其他锁定。例如，许多用户可以同时获取表上的行共享锁，但一次只能有一个用户获得<span class="italic">独占</span>锁。虽然一个用户对表具有独占锁，但其他用户无法在该表中插入，更新或删除行。
                     </p>
                     <p>可选的关键字NOWAIT告诉Oracle如果某个表已被其他用户锁定，则不要等待该表。控制立即返回到您的程序，因此它可以在再次尝试获取锁之前执行其他工作。（您可以在SQLCA中检查<span class="italic">sqlcode</span>以查看LOCK TABLE是否失败。）如果省略NOWAIT，Oracle会等到表可用为止;等待没有设定限制。 <a id="d14014e2049" class="indexterm-anchor"></a><a id="d14014e2053" class="indexterm-anchor"></a><a id="d14014e2057" class="indexterm-anchor"></a><a id="d14014e2061" class="indexterm-anchor"></a> 
                     </p>
                     <p>表锁永远不会阻止其他用户查询表，并且查询永远不会获取表锁。因此，查询永远不会阻止另一个查询或更新，并且更新永远不会阻止查询。仅当两个不同的事务尝试更新同一行时，一个事务才会等待另一个事务完成。 <a id="d14014e2068" class="indexterm-anchor"></a> 
                     </p>
                     <p><a id="d14014e2074" class="indexterm-anchor"></a>任何LOCK TABLE语句都隐式关闭所有游标。
                     </p>
                     <p>当事务发出COMMIT或ROLLBACK时，将释放表锁。 <a id="d14014e2081" class="indexterm-anchor"></a> 
                     </p>
                  </div>
                  <div>
                     <div class="relinfo">
                        <p><strong>相关话题</strong></p>
                        <ul>
                           <li><a href="../cncpt/data-concurrency-and-consistency.html#CNCPT-GUID-2309ED19-A551-46DA-9E58-D957A22F9D6C" target="_blank"><span class="italic">锁定模式</span></a></li>
                        </ul>
                     </div>
                  </div>
               </div>
            </div><a id="LNPCC3148"></a><div class="props_rev_3"><a id="GUID-56C7EE05-CBFF-467F-9C08-856500AF335E" name="GUID-56C7EE05-CBFF-467F-9C08-856500AF335E"></a><h3 id="LNPCC-GUID-56C7EE05-CBFF-467F-9C08-856500AF335E" class="sect3"><span class="enumeration_section">3.12</span>获取COMMIT</h3>
               <div>
                  <p>如果要混合使用COMMIT和FETCH，请不要使用CURRENT OF子句。而是，选择每行的ROWID，然后使用该值在更新或删除期间标识当前行。一个例子如下： <a id="d14014e2104" class="indexterm-anchor"></a><a id="d14014e2110" class="indexterm-anchor"></a><a id="d14014e2114" class="indexterm-anchor"></a> 
                  </p><pre class="oac_no_warn" dir="ltr">...EXEC SQL DECLARE emp_cursor CURSOR FOR SELECT ename，sal，ROWID FROM emp WHERE job ='CLERK'; ...EXEC SQL OPEN emp_cursor; EXEC SQL WHENEVER未找到GOTO ......for（;;）{EXEC SQL FETCH emp_cursor INTO：emp_name，：salary，：row_id; ...EXEC SQL UPDATE emp SET sal =：new_salary WHERE ROWID =：row_id; EXEC SQL COMMIT; ...}</pre><p>但请注意，FETCHed行<span class="italic">未</span>锁定。因此，如果另一个用户在您读取之后但在更新或删除之前修改了一行，则可能会得到不一致的结果。
                  </p>
               </div>
            </div><a id="LNPCC3149"></a><div class="props_rev_3"><a id="GUID-4037818F-8267-448A-8003-4099A1A67F09" name="GUID-4037818F-8267-448A-8003-4099A1A67F09"></a><h3 id="LNPCC-GUID-4037818F-8267-448A-8003-4099A1A67F09" class="sect3"><span class="enumeration_section">3.13</span>分布式事务处理</h3>
               <div>
                  <p><span class="italic">分布式数据库</span>是包括不同节点处的多个物理数据库的单个逻辑数据库。<span class="italic">分布式语句</span>是使用数据库链接访问远程节点的任何SQL语句。<span class="italic">分布式事务</span>包括至少一个分布式语句，其更新分布式数据库的多个节点处的数据。如果更新仅影响一个节点，则事务是非分布式的。
                  </p>
                  <p>发出COMMIT时，对受分布式事务影响的每个数据库的更改将成为永久更改。如果您发出ROLLBACK，则撤消所有更改。但是，如果网络或计算机在提交或回滚期间出现故障，则分布式事务的状态可能未知或<span class="italic">存在疑问</span> 。在这种情况下，如果您具有FORCE TRANSACTION系统特权，则可以使用FORCE子句在本地数据库中手动提交或回滚事务。必须通过包含事务ID的带引号的文字来标识事务，该事务ID可以在数据字典视图DBA_2PC_PENDING中找到。一些例子如下： <a id="d14014e2151" class="indexterm-anchor"></a> 
                  </p><pre class="oac_no_warn" dir="ltr">EXEC SQL COMMIT FORCE '22 .31.83'; ...EXEC SQL ROLLBACK FORCE '25 .33.86';</pre><p>FORCE仅提交或回滚指定的事务，不会影响您当前的事务。您无法手动将不确定事务回滚到保存点。</p>
                  <p>COMMIT语句中的COMMENT子句允许您指定要与分布式事务关联的注释。如果事务有疑问，Oracle会将COMMENT指定的文本与事务ID一起存储在数据字典视图DBA_2PC_PENDING中。文本必须是带引号的文字，长度为50个字符。一个例子如下：</p><pre class="oac_no_warn" dir="ltr">EXEC SQL COMMIT COMMENT'怀疑trans;通知订单输入';</pre><div class="infoboxnote" id="GUID-4037818F-8267-448A-8003-4099A1A67F09__GUID-DB34755A-4057-4ED0-A63D-FEFAD4A13DAF">
                     <p class="notep1">注意：</p>
                     <p>COMMENT子句将在以后的版本中弃用。Oracle建议您改为使用事务命名。</p>
                  </div>
               </div>
               <div>
                  <div class="relinfo">
                     <p><strong>相关话题</strong></p>
                     <ul>
                        <li><a href="../cncpt/transactions.html#CNCPT-GUID-B97790CB-DF82-442D-B9D5-50CCE6BF9FBD" target="_blank"><span class="italic">交易</span></a></li>
                     </ul>
                  </div>
               </div>
            </div><a id="LNPCC3150"></a><div class="props_rev_3"><a id="GUID-08C56A16-F6AC-443D-8B2B-9338CCB0D009" name="GUID-08C56A16-F6AC-443D-8B2B-9338CCB0D009"></a><h3 id="LNPCC-GUID-08C56A16-F6AC-443D-8B2B-9338CCB0D009" class="sect3"><span class="enumeration_section">3.14</span>指南</h3>
               <div>
                  <p>以下指南将帮助您避免一些常见问题。</p>
               </div><a id="LNPCC3151"></a><div class="props_rev_3"><a id="GUID-6CE57034-7332-4E43-971F-E15B5311F974" name="GUID-6CE57034-7332-4E43-971F-E15B5311F974"></a><h4 id="LNPCC-GUID-6CE57034-7332-4E43-971F-E15B5311F974" class="sect4"><span class="enumeration_section">3.14.1</span>设计应用程序</h4>
                  <div>
                     <p>在设计应用程序时，在一个事务中将逻辑相关的操作组合在一起。精心设计的交易包括完成特定任务所需的所有步骤 - 不多也不少。</p>
                     <p>您引用的表中的数据必须保持一致状态。因此，事务中的SQL语句应以一致的方式更改数据。 <a id="d14014e2195" class="indexterm-anchor"></a><a id="d14014e2199" class="indexterm-anchor"></a> 例如，两个银行账户之间的资金转移应包括一个账户的借方和另一个账户的贷方。两个更新应该成功还是一起失败。不相关的更新（例如新存款到一个帐户）不应包含在交易中。
                     </p>
                  </div>
               </div><a id="LNPCC3152"></a><div class="props_rev_3"><a id="GUID-CD3D9177-3F99-45DB-86D5-292BC7F8B2FB" name="GUID-CD3D9177-3F99-45DB-86D5-292BC7F8B2FB"></a><h4 id="LNPCC-GUID-CD3D9177-3F99-45DB-86D5-292BC7F8B2FB" class="sect4"><span class="enumeration_section">3.14.2</span>获取锁</h4>
                  <div>
                     <p>如果您的应用程序包含SQL锁定语句，请确保请求锁定的Oracle用户具有获取锁定所需的权限。您的DBA可以锁定任何表。其他用户可以锁定他们拥有的表或他们有权使用的表，例如ALTER，SELECT，INSERT，UPDATE或DELETE。 <a id="d14014e2215" class="indexterm-anchor"></a> 
                     </p>
                  </div>
               </div><a id="LNPCC3153"></a><div class="props_rev_3"><a id="GUID-8A000499-B626-47EF-BB28-02BFF832E503" name="GUID-8A000499-B626-47EF-BB28-02BFF832E503"></a><h4 id="LNPCC-GUID-8A000499-B626-47EF-BB28-02BFF832E503" class="sect4"><span class="enumeration_section">3.14.3</span>使用PL / SQL</h4>
                  <div>
                     <p>如果PL / SQL块是事务的一部分，则块内的COMMIT和ROLLBACK会影响整个事务。在以下示例中，ROLLBACK撤消UPDATE <span class="italic">和</span> INSERT所做的更改： <a id="d14014e2235" class="indexterm-anchor"></a><a id="d14014e2240" class="indexterm-anchor"></a> 
                     </p><pre class="oac_no_warn" dir="ltr">EXEC SQL INSERT INTO EMP ...EXEC SQL EXECUTE BEGIN UPDATE emp ......DUP_VAL_ON_INDEX然后ROLLBACK的例外情况; ...结束; END-EXEC; ...
</pre></div>
               </div>
            </div>
         </div>
      </article>
   </body>
</html>