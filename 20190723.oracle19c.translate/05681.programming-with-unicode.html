<html lang="en-us" dir="ltr" xml:lang="en-us">
   <head>
      <meta http-equiv="Content-Type" content="text/html; charset=utf-8"></meta>
      <meta name="viewport" content="width=device-width, initial-scale=1"></meta>
      <meta http-equiv="X-UA-Compatible" content="IE=edge"></meta>
      <title>用Unicode编程</title>
      <meta property="og:site_name" content="Oracle Help Center"></meta>
      <meta property="og:title" content="Database Globalization Support Guide "></meta>
      <meta property="og:description" content=""></meta>
      <link rel="stylesheet" href="/sp_common/book-template/ohc-book-template/css/book.css"></link>
      <link rel="shortcut icon" href="/sp_common/book-template/ohc-common/img/favicon.ico"></link>
      <meta name="application-name" content="Database Globalization Support Guide"></meta>
      <meta name="generator" content="DITA Open Toolkit version 1.8.5 (Mode = doc)"></meta>
      <meta name="plugin" content="SP_docbuilder HTML plugin release 18.2.2"></meta>
      <link rel="alternate" href="database-globalization-support-guide.pdf" title="PDF File" type="application/pdf"></link>
      <meta name="robots" content="all"></meta>
      <link rel="schema.dcterms" href="http://purl.org/dc/terms/"></link>
      <meta name="dcterms.created" content="2019-02-12T02:55:13-08:00"></meta>
      
      <meta name="dcterms.dateCopyrighted" content="2007, 2019"></meta>
      <meta name="dcterms.category" content="database"></meta>
      <meta name="dcterms.identifier" content="E96349-02"></meta>
      
      <meta name="dcterms.product" content="en/database/oracle/oracle-database/19"></meta>
      
      <link rel="prev" href="supporting-multilingual-databases-with-unicode.html" title="Previous" type="text/html"></link>
      <link rel="next" href="oracle-globalization-development-kit.html" title="Next" type="text/html"></link>
      <script>
        document.write('<style type="text/css">');
        document.write('body > .noscript, body > .noscript ~ * { visibility: hidden; }');
        document.write('</style>');
     </script>
      <script src="/sp_common/book-template/requirejs/require.js" data-main="/sp_common/book-template/ohc-book-template/js/book-config"></script>
      <script>
            if (window.require === undefined) {
                document.write('<script data-main="sp_common/book-template/ohc-book-template/js/book-config" src="sp_common/book-template/requirejs/require.js"><\/script>');
                document.write('<link href="sp_common/book-template/ohc-book-template/css/book.css" rel="stylesheet"/>');
            }
        </script>
      <script type="application/json" id="ssot-metadata">{"primary":{"category":{"short_name":"database","element_name":"Database","display_in_url":true},"suite":{"short_name":"oracle","element_name":"Oracle","display_in_url":true},"product_group":{"short_name":"not-applicable","element_name":"Not applicable","display_in_url":false},"product":{"short_name":"oracle-database","element_name":"Oracle Database","display_in_url":true},"release":{"short_name":"19","element_name":"Release 19","display_in_url":true}}}</script>
      
    <meta name="dcterms.title" content="Database Globalization Support Guide"></meta>
    <meta name="dcterms.isVersionOf" content="NLSPG"></meta>
    <meta name="dcterms.release" content="Release 19"></meta>
  </head>
   <body dir="ltr">
      <div class="noscript alert alert-danger text-center" role="alert">
         <a href="supporting-multilingual-databases-with-unicode.html" class="pull-left"><span class="glyphicon glyphicon-chevron-left" aria-hidden="true"></span>上一页</a> <a href="oracle-globalization-development-kit.html" class="pull-right">下一页<span class="glyphicon glyphicon-chevron-right" aria-hidden="true"></span></a> <span class="fa fa-exclamation-triangle" aria-hidden="true"></span>必须启用JavaScript才能正确显示此内容</div>
      <article>
         <header>
            <ol class="breadcrumb" vocab="http://schema.org/" typeof="BreadcrumbList">
               <li property="itemListElement" typeof="ListItem"><a href="index.html" property="item" typeof="WebPage"><span property="name">数据库全球化支持指南</span></a></li>
               <li class="active" property="itemListElement" typeof="ListItem">用Unicode编程</li>
            </ol>
            <a id="GUID-71506A5D-94EB-489F-90E6-CB2ECCA04095" name="GUID-71506A5D-94EB-489F-90E6-CB2ECCA04095"></a><a id="NLSPG007"></a>
            
            <h2 id="NLSPG-GUID-71506A5D-94EB-489F-90E6-CB2ECCA04095" class="sect2"><span class="enumeration_chapter">7</span>使用Unicode编程</h2>
         </header>
         <div class="ind">
            <div>
               <p>本章介绍如何使用Unicode为Oracle数据库编程和访问产品。本章包含以下主题：</p>
               <ul style="list-style-type:disc">
                  <li>
                     <p><a href="programming-with-unicode.html#GUID-F04B0FDF-1B5C-4AF0-B330-C7F510426FE8">使用Unicode编程概述</a></p>
                  </li>
                  <li>
                     <p><a href="programming-with-unicode.html#GUID-4A7022C2-30DA-437C-9ACC-68427541C6CE">使用Unicode进行SQL和PL / SQL编程</a></p>
                  </li>
                  <li>
                     <p><a href="programming-with-unicode.html#GUID-C0EF74CA-C9C1-4651-B820-9B3E8FB70E8E">使用Unicode进行OCI编程</a></p>
                  </li>
                  <li>
                     <p><a href="programming-with-unicode.html#GUID-302CBDBC-3A81-415F-86B0-86BB56796B33">使用Unicode进行Pro * C / C ++编程</a></p>
                  </li>
                  <li>
                     <p><a href="programming-with-unicode.html#GUID-39A80CED-25E1-416B-8723-267A504599C0">使用Unicode进行JDBC编程</a></p>
                  </li>
                  <li>
                     <p><a href="programming-with-unicode.html#GUID-FA450F53-2904-4520-8A88-901DC5AEA2EE">使用Unicode进行ODBC和OLE DB编程</a></p>
                  </li>
                  <li>
                     <p><a href="programming-with-unicode.html#GUID-17D808D8-283E-4F9B-8E2C-D77A60FCEFBA">使用Unicode进行XML编程</a></p>
                  </li>
               </ul>
            </div><a id="NLSPG0072"></a><div class="props_rev_3"><a id="GUID-F04B0FDF-1B5C-4AF0-B330-C7F510426FE8" name="GUID-F04B0FDF-1B5C-4AF0-B330-C7F510426FE8"></a><h3 id="NLSPG-GUID-F04B0FDF-1B5C-4AF0-B330-C7F510426FE8" class="sect3"><span class="enumeration_section">7.1</span>使用Unicode编程概述</h3>
               <div>
                  <p><a id="d59478e181" class="indexterm-anchor"></a> Oracle提供了几种用于插入和检索Unicode数据的数据库访问产品。Oracle为常用的编程环境（如Java和C / C ++）提供数据库访问产品。数据在数据库和客户端程序之间透明转换，确保客户端程序独立于数据库字符集和国家字符集。此外，客户端程序有时甚至独立于数据库中使用的字符数据类型，例如<code class="codeph">NCHAR</code>或<code class="codeph">CHAR</code> 。
                  </p>
                  <p>为避免数据转换操作使数据库服务器过载，Oracle总是尝试将它们移动到客户端数据库访问产品。在少数情况下，必须在数据库中转换数据，这会影响性能。本章讨论数据转换路径的详细信息。</p>
               </div><a id="NLSPG800"></a><a id="NLSPG801"></a><a id="NLSPG334"></a><div class="props_rev_3"><a id="GUID-7973C9F3-62FE-41AB-8EDE-75504746B58C" name="GUID-7973C9F3-62FE-41AB-8EDE-75504746B58C"></a><h4 id="NLSPG-GUID-7973C9F3-62FE-41AB-8EDE-75504746B58C" class="sect4"><span class="enumeration_section">7.1.1</span>数据库访问产品堆栈和Unicode</h4>
                  <div>
                     <p>Oracle提供了一套全面的数据库访问产品，使来自不同开发环境的程序能够访问存储在数据库中的Unicode数据。这些产品列于下表中。</p>
                     <div class="tblformal" id="GUID-7973C9F3-62FE-41AB-8EDE-75504746B58C__CACBBCAG">
                        <p class="titleintable">表7-1 Oracle数据库访问产品</p>
                        <table cellpadding="4" cellspacing="0" class="Formal" title="Oracle数据库访问产品" width="100%" border="1" summary="This table lists database access products for different programming environments. " frame="hsides" rules="rows">
                           <thead>
                              <tr align="left" valign="top">
                                 <th align="left" valign="bottom" id="d59478e280">编程环境</th>
                                 <th align="left" valign="bottom" id="d59478e283">Oracle数据库访问产品</th>
                              </tr>
                           </thead>
                           <tbody>
                              <tr align="left" valign="top">
                                 <td align="left" valign="top" id="d59478e288" headers="d59478e280 ">
                                    <p>C / C ++</p>
                                 </td>
                                 <td align="left" valign="top" headers="d59478e288 d59478e283 ">
                                    <p>Oracle调用接口（OCI）</p>
                                    <p>Oracle Pro * C / C ++</p>
                                    <p>Oracle ODBC驱动程序</p>
                                    <p>用于OLE DB的Oracle Provider</p>
                                    <p>Oracle Data Provider for .NET</p>
                                 </td>
                              </tr>
                              <tr align="left" valign="top">
                                 <td align="left" valign="top" id="d59478e303" headers="d59478e280 ">
                                    <p>Java的</p>
                                 </td>
                                 <td align="left" valign="top" headers="d59478e303 d59478e283 ">
                                    <p>Oracle JDBC OCI或瘦驱动程序</p>
                                    <p>Oracle服务器端瘦驱动程序</p>
                                    <p>Oracle服务器端内部驱动程序</p>
                                 </td>
                              </tr>
                              <tr align="left" valign="top">
                                 <td align="left" valign="top" id="d59478e314" headers="d59478e280 ">
                                    <p>PL / SQL</p>
                                 </td>
                                 <td align="left" valign="top" headers="d59478e314 d59478e283 ">
                                    <p>Oracle PL / SQL和SQL</p>
                                 </td>
                              </tr>
                              <tr align="left" valign="top">
                                 <td align="left" valign="top" id="d59478e321" headers="d59478e280 ">
                                    <p>Visual Basic / C＃</p>
                                 </td>
                                 <td align="left" valign="top" headers="d59478e321 d59478e283 ">
                                    <p>Oracle ODBC驱动程序</p>
                                    <p>用于OLE DB的Oracle Provider</p>
                                 </td>
                              </tr>
                           </tbody>
                        </table>
                     </div>
                     <!-- class="inftblhruleinformal" -->
                     <p>下图显示了数据库访问产品如何访问数据库。</p>
                     <div class="figure" id="GUID-7973C9F3-62FE-41AB-8EDE-75504746B58C__I1005974">
                        <p class="titleinfigure">图7-1 Oracle数据库访问产品</p><img src="img/nlspg024.gif" alt="下面是图7-1的描述" title="下面是图7-1的描述" longdesc="img_text/nlspg024.html"><br><a href="img_text/nlspg024.html">“图7-1 Oracle数据库访问产品”的说明</a></div>
                     <!-- class="figure" -->
                     <p>该<a id="d59478e338" class="indexterm-anchor"></a><a id="d59478e340" class="indexterm-anchor"></a><a id="d59478e344" class="indexterm-anchor"></a> Oracle调用接口（OCI）是其他客户端数据库访问产品使用的最低级API。它为C / C ++程序提供了一种灵活的方式来访问存储在SQL <code class="codeph">CHAR</code>和<code class="codeph">NCHAR</code>数据类型中的Unicode数据。使用OCI，您可以以编程方式为要插入或检索的数据指定字符集（UTF-8，UTF-16和其他）。它通过Oracle Net访问数据库。</p>
                     <p><a id="d59478e354" class="indexterm-anchor"></a><a id="d59478e356" class="indexterm-anchor"></a> Oracle Pro * C / C ++使您可以在程序中嵌入SQL和PL / SQL。它使用OCI的Unicode功能为SQL <code class="codeph">CHAR</code>和<code class="codeph">NCHAR</code>数据类型提供UTF-16和UTF-8数据访问。
                     </p>
                     <p>该<a id="d59478e369" class="indexterm-anchor"></a><a id="d59478e371" class="indexterm-anchor"></a> Oracle ODBC驱动程序使在Windows平台上运行的C / C ++，Visual Basic和VBScript程序能够访问存储在数据库的SQL <code class="codeph">CHAR</code>和<code class="codeph">NCHAR</code>数据类型中的Unicode数据。它通过实现ODBC标准规范中指定的<code class="codeph">SQLWCHAR</code>接口提供UTF-16数据访问。
                     </p>
                     <p>该<a id="d59478e387" class="indexterm-anchor"></a><a id="d59478e389" class="indexterm-anchor"></a> Oracle Provider for OLE DB支持在Windows平台上运行的C / C ++，Visual Basic和VBScript程序访问存储在SQL <code class="codeph">CHAR</code>和<code class="codeph">NCHAR</code>数据类型中的Unicode数据。它通过宽字符串OLE DB数据类型提供UTF-16数据访问。
                     </p>
                     <p>该<a id="d59478e402" class="indexterm-anchor"></a><a id="d59478e404" class="indexterm-anchor"></a> Oracle Data Provider for .NET使在Windows平台上的任何.NET编程环境中运行的程序能够访问存储在SQL <code class="codeph">CHAR</code>和<code class="codeph">NCHAR</code>数据类型中的Unicode数据。它通过Unicode数据类型提供UTF-16数据访问。
                     </p>
                     <p>Oracle JDBC驱动程序是用于访问Oracle数据库的主要Java编程接口。Oracle提供以下JDBC驱动程序：</p>
                     <ul style="list-style-type:disc">
                        <li>
                           <p>该<a id="d59478e421" class="indexterm-anchor"></a><a id="d59478e425" class="indexterm-anchor"></a> JDBC应用程序使用的JDBC OCI驱动程序，需要OCI库</p>
                        </li>
                        <li>
                           <p>该<a id="d59478e433" class="indexterm-anchor"></a><a id="d59478e437" class="indexterm-anchor"></a> JDBC瘦驱动程序，它是纯Java驱动程序，主要由Java小程序使用，并支持TCP / IP上的Oracle Net协议</p>
                        </li>
                        <li>
                           <p>该<a id="d59478e445" class="indexterm-anchor"></a><a id="d59478e449" class="indexterm-anchor"></a> JDBC服务器端瘦驱动程序，一个纯Java驱动程序，用于在Java存储过程中连接到另一个Oracle服务器</p>
                        </li>
                        <li>
                           <p>该<a id="d59478e457" class="indexterm-anchor"></a><a id="d59478e461" class="indexterm-anchor"></a> JDBC服务器端内部驱动程序，用于在Oracle服务器内部访问数据库中的数据</p>
                        </li>
                     </ul>
                     <p>所有驱动程序都支持对数据库中的SQL <code class="codeph">CHAR</code>和<code class="codeph">NCHAR</code>数据类型进行Unicode数据访问。
                     </p>
                     <p>该<a id="d59478e477" class="indexterm-anchor"></a><a id="d59478e479" class="indexterm-anchor"></a> PL / SQL和SQL引擎代表客户端程序（如OCI和服务器端PL / SQL存储过程）处理PL / SQL程序和SQL语句。它们允许PL / SQL程序声明<code class="codeph">CHAR</code> ， <code class="codeph">VARCHAR2</code> ， <code class="codeph">NCHAR</code>和<code class="codeph">NVARCHAR2</code>变量，并访问数据库中的SQL <code class="codeph">CHAR</code>和<code class="codeph">NCHAR</code>数据类型。
                     </p>
                     <p>以下部分描述了每个数据库访问产品如何支持对Oracle数据库的Unicode数据访问，并提供了使用这些产品的示例：</p>
                     <ul style="list-style-type:disc">
                        <li>
                           <p><a href="programming-with-unicode.html#GUID-4A7022C2-30DA-437C-9ACC-68427541C6CE">使用Unicode进行SQL和PL / SQL编程</a></p>
                        </li>
                        <li>
                           <p><a href="programming-with-unicode.html#GUID-C0EF74CA-C9C1-4651-B820-9B3E8FB70E8E">使用Unicode进行OCI编程</a></p>
                        </li>
                        <li>
                           <p><a href="programming-with-unicode.html#GUID-302CBDBC-3A81-415F-86B0-86BB56796B33">使用Unicode进行Pro * C / C ++编程</a></p>
                        </li>
                        <li>
                           <p><a href="programming-with-unicode.html#GUID-39A80CED-25E1-416B-8723-267A504599C0">使用Unicode进行JDBC编程</a></p>
                        </li>
                        <li>
                           <p><a href="programming-with-unicode.html#GUID-FA450F53-2904-4520-8A88-901DC5AEA2EE">使用Unicode进行ODBC和OLE DB编程</a></p>
                        </li>
                     </ul>
                  </div>
               </div>
            </div><a id="NLSPG0073"></a><div class="props_rev_3"><a id="GUID-4A7022C2-30DA-437C-9ACC-68427541C6CE" name="GUID-4A7022C2-30DA-437C-9ACC-68427541C6CE"></a><h3 id="NLSPG-GUID-4A7022C2-30DA-437C-9ACC-68427541C6CE" class="sect3"><span class="enumeration_section">7.2</span>使用Unicode进行SQL和PL / SQL编程</h3>
               <div>
                  <p>SQL是所有程序和用户直接或间接访问Oracle数据库中数据的基本语言。PL / SQL是一种过程语言，它将SQL的数据操作功能与过程语言的数据处理能力相结合。SQL和PL / SQL都可以嵌入其他编程语言中。本节介绍可以为多语言应用程序部署的SQL和PL / SQL中与Unicode相关的功能。</p>
                  <p>本节包含以下主题：</p>
                  <ul style="list-style-type:disc">
                     <li>
                        <p><a href="programming-with-unicode.html#GUID-90FC7B1F-1453-44E3-BF76-69A9A6D9CFD1">SQL NCHAR数据类型</a></p>
                     </li>
                     <li>
                        <p><a href="programming-with-unicode.html#GUID-2D02C9D9-6D3F-499A-ABC3-2099F2290EE5">NCHAR与其他数据类型之间的隐式数据类型转换</a></p>
                     </li>
                     <li>
                        <p><a href="programming-with-unicode.html#GUID-11D2B944-166B-427C-92CA-2A4A871D3D7D">数据类型转换期间数据丢失的异常处理</a></p>
                     </li>
                     <li>
                        <p><a href="programming-with-unicode.html#GUID-B036442F-AD1D-439B-AACF-797FA4CB8A4F">隐式数据类型转换规则</a></p>
                     </li>
                     <li>
                        <p><a href="programming-with-unicode.html#GUID-A7E6259B-1007-43DF-8912-A4F37F9F4A2B">Unicode数据类型的SQL函数</a></p>
                     </li>
                     <li>
                        <p><a href="programming-with-unicode.html#GUID-8F54F7E3-633C-451F-9211-FE4E1C822F88">其他SQL函数</a></p>
                     </li>
                     <li>
                        <p><a href="programming-with-unicode.html#GUID-9F223401-9892-4380-92FA-656ADCF84B50">Unicode字符串文字</a></p>
                     </li>
                     <li>
                        <p><a href="programming-with-unicode.html#GUID-F59FC7E1-E8C6-466B-BEC2-9E3DD0D7B7CC">将UTL_FILE包与NCHAR数据一起使用</a></p>
                     </li>
                  </ul>
               </div><a id="NLSPG0071"></a><div class="props_rev_3"><a id="GUID-90FC7B1F-1453-44E3-BF76-69A9A6D9CFD1" name="GUID-90FC7B1F-1453-44E3-BF76-69A9A6D9CFD1"></a><h4 id="NLSPG-GUID-90FC7B1F-1453-44E3-BF76-69A9A6D9CFD1" class="sect4"><span class="enumeration_section">7.2.1</span> SQL NCHAR数据类型</h4>
                  <div>
                     <p>有三种SQL <code class="codeph">NCHAR</code>数据类型：</p>
                     <ul style="list-style-type:disc">
                        <li>
                           <p><a href="programming-with-unicode.html#GUID-2BDBDF40-9882-4397-9A1F-F8B8A8509511">NCHAR数据类型</a></p>
                        </li>
                        <li>
                           <p><a href="programming-with-unicode.html#GUID-B5448F80-C679-484D-BA0A-9C1FA81D0007">NVARCHAR2数据类型</a></p>
                        </li>
                        <li>
                           <p><a href="programming-with-unicode.html#GUID-CADC5C47-411B-4DC7-AA66-903DA16CACF7">NCLOB数据类型</a></p>
                        </li>
                     </ul>
                  </div><a id="NLSPG335"></a><div class="props_rev_3"><a id="GUID-2BDBDF40-9882-4397-9A1F-F8B8A8509511" name="GUID-2BDBDF40-9882-4397-9A1F-F8B8A8509511"></a><h5 id="NLSPG-GUID-2BDBDF40-9882-4397-9A1F-F8B8A8509511" class="sect5"><span class="enumeration_section">7.2.1.1</span> NCHAR数据类型</h5>
                     <div>
                        <p>将表列或PL / SQL变量定义为<code class="codeph">NCHAR</code>数据类型时，长度始终指定为字符数。例如，以下语句创建一个最大长度为30个字符的列：</p><pre class="oac_no_warn" dir="ltr">CREATE TABLE table1（column1 NCHAR（30））;</pre><p>列的最大字节数确定如下：</p><pre class="oac_no_warn" dir="ltr">最大字节数=（最大字符数）x（每个字符的最大字节数）</pre><p>例如，如果国家字符集是UTF8，则每个字符的最大字节长度为30个字符乘以3个字节，或90个字节。</p>
                        <p>在创建数据库时定义用于所有<code class="codeph">NCHAR</code>数据类型的国家字符集。国家字符集可以是UTF8或AL16UTF16。默认值为AL16UTF16。<a id="d59478e831" class="indexterm-anchor"></a><a id="d59478e833" class="indexterm-anchor"></a></p>
                        <p>当国家字符集为UTF8时，允许的最大列大小为32000个字符，当为AL16UTF16时，允许的最大列大小为8000。实际数据的最大字节数限制为16000。必须同时满足两个大小约束。在PL / SQL中， <code class="codeph">NCHAR</code>数据的最大长度为32767字节。您可以定义最多32767个字符的<code class="codeph">NCHAR</code>变量，但实际数据不能超过32767个字节。如果插入的值小于列长度，则Oracle会使用空白填充值，以填充较小的长度：最大字符长度或最大字节长度。
                        </p>
                        <div class="infoboxnote" id="GUID-2BDBDF40-9882-4397-9A1F-F8B8A8509511__GUID-C16BB030-5266-471B-BC4F-D0ADF8BAFA80">
                           <p class="notep1">注意：</p>
                           <p>UTF8可能会影响性能，因为它是一个可变宽度的字符集。<code class="codeph">NCHAR</code>字段的空白填充过多会降低性能。考虑使用<code class="codeph">NVARCHAR2</code>数据类型或更改为<code class="codeph">NCHAR</code>数据类型的AL16UTF16字符集。
                           </p>
                        </div>
                     </div>
                  </div><a id="NLSPG336"></a><div class="props_rev_3"><a id="GUID-B5448F80-C679-484D-BA0A-9C1FA81D0007" name="GUID-B5448F80-C679-484D-BA0A-9C1FA81D0007"></a><h5 id="NLSPG-GUID-B5448F80-C679-484D-BA0A-9C1FA81D0007" class="sect5"><span class="enumeration_section">7.2.1.2</span> NVARCHAR2数据类型</h5>
                     <div>
                        <p><code class="codeph">NVARCHAR2</code>数据类型指定使用国家字符集的可变长度字符串<a id="d59478e934" class="indexterm-anchor"></a><a id="d59478e936" class="indexterm-anchor"></a> 。使用<code class="codeph">NVARCHAR2</code>列创建表时，可以指定列的最大字符数。<code class="codeph">NVARCHAR2</code>长度始终以字符为单位，与<code class="codeph">NCHAR</code> 。如果值不超过列的最大长度，Oracle随后会按照您指定的方式将每个值完全存储在列中。Oracle不会将字符串值填充到最大长度。
                        </p>
                        <p>如果<code class="codeph">MAX_STRING_SIZE</code> <code class="codeph">=</code> <code class="codeph">STANDARD</code> ，则<code class="codeph">NVARCHAR2</code>类型的最大长度为4000个字符;如果<code class="codeph">MAX_STRING_SIZE</code> <code class="codeph">=</code> <code class="codeph">EXTENDED</code> <code class="codeph">MAX_STRING_SIZE</code> 32767个字符。这些长度基于使用UTF8;使用AL16UTF16时，值为2000和16383个字符。
                        </p>
                        <p>在PL / SQL中， <code class="codeph">NVARCHAR2</code>变量的最大长度为32767字节。您可以定义最多32767个字符的<code class="codeph">NVARCHAR2</code>变量，但实际数据不能超过32767个字节。
                        </p>
                        <p>以下语句创建一个包含一个<code class="codeph">NVARCHAR2</code>列的表，其最大字符长度为2000，最大长度（以字节为单位）为4000。
                        </p><pre class="oac_no_warn" dir="ltr">CREATE TABLE table2（column2 NVARCHAR2（2000））;</pre></div>
                  </div><a id="NLSPG337"></a><div class="props_rev_3"><a id="GUID-CADC5C47-411B-4DC7-AA66-903DA16CACF7" name="GUID-CADC5C47-411B-4DC7-AA66-903DA16CACF7"></a><h5 id="NLSPG-GUID-CADC5C47-411B-4DC7-AA66-903DA16CACF7" class="sect5"><span class="enumeration_section">7.2.1.3</span> NCLOB数据类型</h5>
                     <div>
                        <p><code class="codeph">NCLOB</code>是一个包含Unicode字符的字符大对象，最大大小为4千兆字节。与<code class="codeph">BLOB</code>数据类型不同， <code class="codeph">NCLOB</code>数据类型具有完全事务支持，因此通过SQL， <code class="codeph">DBMS_LOB</code>包或OCI进行的更改完全参与事务。可以提交并回滚对<code class="codeph">NCLOB</code>值的操作。但请注意，您无法在一个事务中将<code class="codeph">NCLOB</code>定位器保存在PL / SQL或OCI变量中，然后在另一个事务或会话中使用它。
                        </p>
                        <p>无论国家字符集如何， <code class="codeph">NCLOB</code>值都以与UCS-2兼容的格式存储在数据库中。Oracle将存储的Unicode值转换为客户端或服务器上请求的字符集，可以是固定宽度或可变宽度。使用可变宽度字符集将数据插入<code class="codeph">NCLOB</code>列时，Oracle会将数据转换为与UCS-2兼容的格式，然后再将其存储在数据库中。
                        </p>
                        <div class="infoboxnotealso" id="GUID-CADC5C47-411B-4DC7-AA66-903DA16CACF7__GUID-DEFD2C2D-4B81-4AFB-BA5D-032E88823688">
                           <p class="notep1">也可以看看：</p>
                           <p>有关<code class="codeph">NCLOB</code>数据类型的更多信息，请<code class="codeph">NCLOB</code> <a href="../adlob/introduction-to-large-objects.html#ADLOB45125" target="_blank"><span class="italic">Oracle Database SecureFiles和Large Objects Developer's Guide</span></a></p>
                        </div>
                     </div>
                  </div>
               </div><a id="NLSPG338"></a><div class="props_rev_3"><a id="GUID-2D02C9D9-6D3F-499A-ABC3-2099F2290EE5" name="GUID-2D02C9D9-6D3F-499A-ABC3-2099F2290EE5"></a><h4 id="NLSPG-GUID-2D02C9D9-6D3F-499A-ABC3-2099F2290EE5" class="sect4"><span class="enumeration_section">7.2.2</span> NCHAR与其他数据类型之间的隐式数据类型转换</h4>
                  <div>
                     <p>Oracle支持SQL <code class="codeph">NCHAR</code>数据类型与其他Oracle数据类型（如<code class="codeph">CHAR</code> ， <code class="codeph">VARCHAR2</code> ， <code class="codeph">NUMBER</code> ， <code class="codeph">DATE</code> ， <code class="codeph">ROWID</code>和<code class="codeph">CLOB</code>之间的隐式转换。 SQL <code class="codeph">NCHAR</code>数据类型也支持<code class="codeph">CHAR</code>和<code class="codeph">VARCHAR2</code>数据类型的任何隐式转换。您可以像SQL <code class="codeph">CHAR</code>数据类型一样使用SQL <code class="codeph">NCHAR</code>数据类型。
                     </p>
                     <p>当数据库和国家字符集不同时，SQL <code class="codeph">CHAR</code>数据类型和SQL <code class="codeph">NCHAR</code>数据类型之间的类型转换可能涉及字符集转换。如果目标数据是<code class="codeph">CHAR</code>或<code class="codeph">NCHAR</code>则可能会出现带空白的填充。</p>
                     <div class="infoboxnotealso" id="GUID-2D02C9D9-6D3F-499A-ABC3-2099F2290EE5__GUID-86CA036A-7A43-475E-8F50-993B4320D184">
                        <p class="notep1">也可以看看：</p>
                        <p><a href="../sqlrf/TO_NCHAR-character.html#SQLRF06136" target="_blank"><span class="italic">Oracle数据库SQL语言参考</span></a></p>
                     </div>
                  </div>
               </div><a id="NLSPG339"></a><div class="props_rev_3"><a id="GUID-11D2B944-166B-427C-92CA-2A4A871D3D7D" name="GUID-11D2B944-166B-427C-92CA-2A4A871D3D7D"></a><h4 id="NLSPG-GUID-11D2B944-166B-427C-92CA-2A4A871D3D7D" class="sect4"><span class="enumeration_section">7.2.3</span>数据类型转换期间数据丢失的异常处理</h4>
                  <div>
                     <p>数据丢失可能发生在<a id="d59478e1309" class="indexterm-anchor"></a><a id="d59478e1315" class="indexterm-anchor"></a>需要进行字符集转换时的数据类型转换。如果源字符集中的字符未在目标字符集中定义，则在其位置使用替换字符。例如，如果尝试将<code class="codeph">NCHAR</code>数据插入常规<code class="codeph">CHAR</code>列，并且<code class="codeph">NCHAR</code> （Unicode）表单中的字符数据无法转换为数据库字符集，则该字符将替换为数据库字符集定义的替换字符。<code class="codeph">NLS_NCHAR_CONV_EXCP</code>初始化参数控制字符类型转换期间数据丢失的行为。当此参数设置为<code class="codeph">TRUE</code> ，任何导致数据丢失的SQL语句都会返回<code class="codeph">ORA-12713</code>错误，并停止相应的操作。当此参数设置为<code class="codeph">FALSE</code> ，不会报告数据丢失，并且不可转换的字符将替换为替换字符。默认值为<code class="codeph">FALSE</code> 。此参数适用于隐式和显式转换。
                     </p>
                     <p>在PL / SQL中，在转换SQL <code class="codeph">CHAR</code>和<code class="codeph">NCHAR</code>数据类型期间发生数据丢失时，会引发隐式和显式转换的<code class="codeph">LOSSY_CHARSET_CONVERSION</code>异常。
                     </p>
                  </div>
               </div><a id="NLSPG802"></a><a id="NLSPG340"></a><div class="props_rev_3"><a id="GUID-B036442F-AD1D-439B-AACF-797FA4CB8A4F" name="GUID-B036442F-AD1D-439B-AACF-797FA4CB8A4F"></a><h4 id="NLSPG-GUID-B036442F-AD1D-439B-AACF-797FA4CB8A4F" class="sect4"><span class="enumeration_section">7.2.4</span>隐式数据类型转换规则</h4>
                  <div>
                     <p>在一些<a id="d59478e1431" class="indexterm-anchor"></a><a id="d59478e1433" class="indexterm-anchor"></a>例如，数据类型之间的转换只能在一个方向上进行。在其他情况下，可以在两个方向上进行转换。Oracle为数据类型之间的转换定义了一组规则。下表包含数据类型之间的转换规则。
                     </p>
                     <div class="tblformalwide" id="GUID-B036442F-AD1D-439B-AACF-797FA4CB8A4F__G1010142">
                        <p class="titleintable">表7-2数据类型之间的转换规则</p>
                        <table cellpadding="4" cellspacing="0" class="FormalWide" title="数据类型之间的转换规则" width="100%" border="1" summary="This table is described in the preceding text" frame="hsides" rules="rows">
                           <thead>
                              <tr align="left" valign="top">
                                 <th align="left" valign="bottom" width="29%" id="d59478e1448">声明</th>
                                 <th align="left" valign="bottom" width="71%" id="d59478e1451">规则</th>
                              </tr>
                           </thead>
                           <tbody>
                              <tr align="left" valign="top">
                                 <td align="left" valign="top" width="29%" id="d59478e1456" headers="d59478e1448 ">
                                    <p><code class="codeph">INSERT</code> / <code class="codeph">UPDATE</code>语句</p>
                                 </td>
                                 <td align="left" valign="top" width="71%" headers="d59478e1456 d59478e1451 ">
                                    <p>值将转换为目标数据库列的数据类型。</p>
                                 </td>
                              </tr>
                              <tr align="left" valign="top">
                                 <td align="left" valign="top" width="29%" id="d59478e1468" headers="d59478e1448 ">
                                    <p><code class="codeph">SELECT</code> <code class="codeph">INTO</code>语句</p>
                                 </td>
                                 <td align="left" valign="top" width="71%" headers="d59478e1468 d59478e1451 ">
                                    <p>来自数据库的数据将转换为目标变量的数据类型。</p>
                                 </td>
                              </tr>
                              <tr align="left" valign="top">
                                 <td align="left" valign="top" width="29%" id="d59478e1480" headers="d59478e1448 ">
                                    <p>变量分配</p>
                                 </td>
                                 <td align="left" valign="top" width="71%" headers="d59478e1480 d59478e1451 ">
                                    <p>等号右侧的值将转换为等号左侧的目标变量的数据类型。</p>
                                 </td>
                              </tr>
                              <tr align="left" valign="top">
                                 <td align="left" valign="top" width="29%" id="d59478e1487" headers="d59478e1448 ">
                                    <p>SQL和PL / SQL函数中的参数</p>
                                 </td>
                                 <td align="left" valign="top" width="71%" headers="d59478e1487 d59478e1451 ">
                                    <p><code class="codeph">CHAR</code> ， <code class="codeph">VARCHAR2</code> ， <code class="codeph">NCHAR</code>和<code class="codeph">NVARCHAR2</code>以相同的方式加载。用一个参数<code class="codeph">CHAR</code> ， <code class="codeph">VARCHAR2</code> ， <code class="codeph">NCHAR</code>或<code class="codeph">NVARCHAR2</code>数据类型进行比较的任何的形式参数<code class="codeph">CHAR</code> ， <code class="codeph">VARCHAR2</code> ， <code class="codeph">NCHAR</code>或<code class="codeph">NVARCHAR2</code>数据类型。如果参数和形式参数数据类型不完全匹配，则在将数据复制到函数入口上的参数并将其复制到函数出口上的参数时，将引入隐式转换。
                                    </p>
                                 </td>
                              </tr>
                              <tr align="left" valign="top">
                                 <td align="left" valign="top" width="29%" id="d59478e1530" headers="d59478e1448 ">
                                    <p>连接||操作或<code class="codeph">CONCAT</code>功能</p>
                                 </td>
                                 <td align="left" valign="top" width="71%" headers="d59478e1530 d59478e1451 ">
                                    <p>如果一个操作数是SQL <code class="codeph">CHAR</code>或<code class="codeph">NCHAR</code>数据类型而另一个操作数是<code class="codeph">NUMBER</code>或其他非字符数据类型，则另一个数据类型将转换为<code class="codeph">VARCHAR2</code>或<code class="codeph">NVARCHAR2</code> 。有关字符数据类型之间的串联，请参阅<span class="q">“ <a href="programming-with-unicode.html#GUID-B036442F-AD1D-439B-AACF-797FA4CB8A4F__I1006225">SQL NCHAR数据类型和SQL CHAR数据类型</a> ”</span> 。
                                    </p>
                                 </td>
                              </tr>
                              <tr align="left" valign="top">
                                 <td align="left" valign="top" width="29%" id="d59478e1560" headers="d59478e1448 ">
                                    <p>SQL <code class="codeph">CHAR</code>或<code class="codeph">NCHAR</code>数据类型和<code class="codeph">NUMBER</code>数据类型</p>
                                 </td>
                                 <td align="left" valign="top" width="71%" headers="d59478e1560 d59478e1451 ">
                                    <p>字符值将转换为<code class="codeph">NUMBER</code>数据类型。
                                    </p>
                                 </td>
                              </tr>
                              <tr align="left" valign="top">
                                 <td align="left" valign="top" width="29%" id="d59478e1579" headers="d59478e1448 ">
                                    <p>SQL <code class="codeph">CHAR</code>或<code class="codeph">NCHAR</code>数据类型和<code class="codeph">DATE</code>数据类型</p>
                                 </td>
                                 <td align="left" valign="top" width="71%" headers="d59478e1579 d59478e1451 ">
                                    <p>字符值将转换为<code class="codeph">DATE</code>数据类型。
                                    </p>
                                 </td>
                              </tr>
                              <tr align="left" valign="top">
                                 <td align="left" valign="top" width="29%" id="d59478e1598" headers="d59478e1448 ">
                                    <p>SQL <code class="codeph">CHAR</code>或<code class="codeph">NCHAR</code>数据类型和<code class="codeph">ROWID</code>数据类型</p>
                                 </td>
                                 <td align="left" valign="top" width="71%" headers="d59478e1598 d59478e1451 ">
                                    <p>字符值将转换为<code class="codeph">ROWID</code>数据类型。
                                    </p>
                                 </td>
                              </tr>
                              <tr align="left" valign="top">
                                 <td align="left" valign="top" width="29%" id="d59478e1617" headers="d59478e1448 ">
                                    <p id="GUID-B036442F-AD1D-439B-AACF-797FA4CB8A4F__I1006225">SQL <code class="codeph">NCHAR</code>数据类型和SQL <code class="codeph">CHAR</code>数据类型</p>
                                 </td>
                                 <td align="left" valign="top" width="71%" headers="d59478e1617 d59478e1451 ">
                                    <p>SQL <code class="codeph">NCHAR</code>数据类型和SQL <code class="codeph">CHAR</code>数据类型之间的比较更复杂，因为它们可以用不同的字符集进行编码。
                                    </p>
                                    <p>比较<code class="codeph">CHAR</code>和<code class="codeph">VARCHAR2</code>值时， <code class="codeph">CHAR</code>值将转换为<code class="codeph">VARCHAR2</code>值。
                                    </p>
                                    <p>比较<code class="codeph">NCHAR</code>和<code class="codeph">NVARCHAR2</code>值时， <code class="codeph">NCHAR</code>值将转换为<code class="codeph">NVARCHAR2</code>值。
                                    </p>
                                    <p>当SQL <code class="codeph">NCHAR</code>数据类型和SQL <code class="codeph">CHAR</code>数据类型之间进行比较时，如果它们以不同的字符集编码，则会发生字符集转换。SQL <code class="codeph">NCHAR</code>数据类型的字符集始终为Unicode，可以是UTF8或AL16UTF16编码，它们具有相同的字符库但是Unicode标准的编码不同。SQL <code class="codeph">CHAR</code>数据类型使用数据库字符集，该字符集可以是Oracle支持的任何字符集。Unicode是Oracle支持的任何字符集的超集，因此SQL <code class="codeph">CHAR</code>数据类型始终可以转换为SQL <code class="codeph">NCHAR</code>数据类型而不会丢失数据。
                                    </p>
                                 </td>
                              </tr>
                           </tbody>
                        </table>
                     </div>
                     <!-- class="inftblhruleinformal" -->
                  </div>
               </div><a id="NLSPG803"></a><a id="NLSPG804"></a><a id="NLSPG805"></a><a id="NLSPG341"></a><div class="props_rev_3"><a id="GUID-A7E6259B-1007-43DF-8912-A4F37F9F4A2B" name="GUID-A7E6259B-1007-43DF-8912-A4F37F9F4A2B"></a><h4 id="NLSPG-GUID-A7E6259B-1007-43DF-8912-A4F37F9F4A2B" class="sect4"><span class="enumeration_section">7.2.5</span> Unicode数据类型的SQL函数</h4>
                  <div>
                     <p>可以使用显式转换函数将SQL <code class="codeph">NCHAR</code>数据类型转换为SQL <code class="codeph">CHAR</code>数据类型和其他数据类型。本节中的示例使用以下语句创建的表：</p><pre class="oac_no_warn" dir="ltr">CREATE TABLE客户（ID NUMBER，名称NVARCHAR2（50），地址NVARCHAR2（200），生日DATE）;</pre><div class="infoboxnotealso" id="GUID-A7E6259B-1007-43DF-8912-A4F37F9F4A2B__GUID-DD3D3716-941F-4FB1-9437-5A129E3C43D2">
                        <p class="notep1">也可以看看：</p>
                        <p>有关SQL <code class="codeph">NCHAR</code>数据类型的显式转换函数的详细信息，请<a href="../sqlrf/Data-Types.html#SQLRF50975" target="_blank"><span class="italic">参见Oracle数据库SQL语言参考</span></a></p>
                     </div>
                     <div class="example" id="GUID-A7E6259B-1007-43DF-8912-A4F37F9F4A2B__GUID-FF24217D-38DA-4835-89AC-D0650F1851C3">
                        <p class="titleinexample">示例7-1使用TO_NCHAR函数填充Customers表</p>
                        <p><code class="codeph">TO_NCHAR</code>函数在运行时转换数据，而<code class="codeph">N</code>函数在编译时转换数据。
                        </p><pre class="oac_no_warn" dir="ltr">INSERT INTO客户VALUES（1000，TO_NCHAR（'John Smith'），N'500 Oracle Parkway'，sysdate）;</pre></div>
                     <!-- class="example" -->
                     <div class="example" id="GUID-A7E6259B-1007-43DF-8912-A4F37F9F4A2B__GUID-4FE44629-6F9A-4687-B030-023EF0E60512">
                        <p class="titleinexample">示例7-2使用TO_CHAR函数从客户表中进行选择</p>
                        <p>以下语句将<code class="codeph">name</code>的值从国家字符集中的字符转换为数据库字符集中的字符，然后根据<code class="codeph">LIKE</code>子句选择它们：</p><pre class="oac_no_warn" dir="ltr">SELECT name FROM customers WHERE TO_CHAR（name）LIKE'％Sm％';</pre><p>您应该看到以下输出：</p><pre class="oac_no_warn" dir="ltr">姓名--------------------------------------约翰史密斯</pre></div>
                     <!-- class="example" -->
                     <div class="example" id="GUID-A7E6259B-1007-43DF-8912-A4F37F9F4A2B__CACIACHB">
                        <p class="titleinexample">示例7-3使用TO_DATE函数从客户表中进行选择</p>
                        <p>使用<code class="codeph">N</code>函数显示<code class="codeph">NCHAR</code>或<code class="codeph">CHAR</code>数据可以作为<code class="codeph">TO_DATE</code>函数的参数传递。数据类型可以混合，因为它们在运行时转换。
                        </p><pre class="oac_no_warn" dir="ltr">DECLARE ndatestring NVARCHAR2（20）：= N'12-SEP-1975'; ndstr NVARCHAR2（50）; BEGIN SELECT name INTO ndstr FROM customers WHERE（birthdate）&gt; TO_DATE（ndatestring，'DD-MON-YYYY'，NLS_DATE_LANGUAGE ='AMERICAN'）;结束;</pre><p>如<a href="programming-with-unicode.html#GUID-A7E6259B-1007-43DF-8912-A4F37F9F4A2B__CACIACHB">例7-3所示</a> ，SQL <code class="codeph">NCHAR</code>数据可以传递给显式转换函数。使用多个字符串参数时，SQL <code class="codeph">CHAR</code>和<code class="codeph">NCHAR</code>数据可以混合在一起。
                        </p>
                     </div>
                     <!-- class="example" -->
                  </div>
               </div><a id="NLSPG806"></a><a id="NLSPG807"></a><a id="NLSPG808"></a><a id="NLSPG342"></a><div class="props_rev_3"><a id="GUID-8F54F7E3-633C-451F-9211-FE4E1C822F88" name="GUID-8F54F7E3-633C-451F-9211-FE4E1C822F88"></a><h4 id="NLSPG-GUID-8F54F7E3-633C-451F-9211-FE4E1C822F88" class="sect4"><span class="enumeration_section">7.2.6</span>其他SQL函数</h4>
                  <div>
                     <p>大多数SQL函数都可以使用SQL <code class="codeph">NCHAR</code>数据类型的参数以及混合字符数据类型。返回数据类型基于第一个参数的类型。如果将非字符串数据类型（如<code class="codeph">NUMBER</code>或<code class="codeph">DATE</code> ）传递给这些函数，则会将其转换为<code class="codeph">VARCHAR2</code> 。以下示例使用在<span class="q">“ <a href="programming-with-unicode.html#GUID-A7E6259B-1007-43DF-8912-A4F37F9F4A2B">用于Unicode数据类型的SQL函数</a> ”</span>中创建的<code class="codeph">customer</code>表。
                     </p>
                     <div class="infoboxnotealso" id="GUID-8F54F7E3-633C-451F-9211-FE4E1C822F88__GUID-7309E921-8B4C-417E-A41B-B42B0D740131">
                        <p class="notep1">也可以看看：</p>
                        <p><a href="../sqlrf/RPAD.html#SQLRF06103" target="_blank"><span class="italic">Oracle数据库SQL语言参考</span></a></p>
                     </div>
                     <div class="example" id="GUID-8F54F7E3-633C-451F-9211-FE4E1C822F88__GUID-275110E1-47F5-431A-9E89-4C4F01719A17">
                        <p class="titleinexample">例7-4 INSTR功能</p>
                        <p>在此示例中，字符串文字<code class="codeph">'Sm'</code>将转换为<code class="codeph">NVARCHAR2</code> ，然后由<code class="codeph">INSTR</code>扫描，以检测<code class="codeph">name</code>第一次出现此字符串的位置。
                        </p><pre class="oac_no_warn" dir="ltr"><a id="d59478e1974" class="indexterm-anchor"></a><a id="d59478e1976" class="indexterm-anchor"></a>来自客户的SELECT INSTR（名称，N'Sm'，1,1）;</pre></div>
                     <!-- class="example" -->
                     <div class="example" id="GUID-8F54F7E3-633C-451F-9211-FE4E1C822F88__GUID-7E86FEF4-3C16-4BE4-A6AE-9B30041D7277">
                        <p class="titleinexample">例7-5 CONCAT功能</p><pre class="oac_no_warn" dir="ltr">SELECT CONCAT（name，id）FROM customers;</pre><p><code class="codeph">id</code>转换为<code class="codeph">NVARCHAR2</code> ，然后与<code class="codeph">name</code>连接。
                        </p>
                     </div>
                     <!-- class="example" -->
                     <div class="example" id="GUID-8F54F7E3-633C-451F-9211-FE4E1C822F88__GUID-AF0EE263-44DA-4C73-976F-6EC3F37F3714">
                        <p class="titleinexample">例7-6 RPAD功能</p><pre class="oac_no_warn" dir="ltr"><a id="d59478e2000" class="indexterm-anchor"></a><a id="d59478e2002" class="indexterm-anchor"></a> SELECT RPAD（name，100，''）FROM customers;</pre><p>以下输出结果：</p><pre class="oac_no_warn" dir="ltr">RPAD（NAME，100，''）----------------------------------------- - 约翰·史密斯</pre><p>空格字符''将转换为<code class="codeph">NCHAR</code>字符集中的相应字符，然后填充到<code class="codeph">name</code>右侧，直到总显示长度达到100。
                        </p>
                     </div>
                     <!-- class="example" -->
                  </div>
               </div><a id="NLSPG343"></a><div class="props_rev_3"><a id="GUID-9F223401-9892-4380-92FA-656ADCF84B50" name="GUID-9F223401-9892-4380-92FA-656ADCF84B50"></a><h4 id="NLSPG-GUID-9F223401-9892-4380-92FA-656ADCF84B50" class="sect4"><span class="enumeration_section">7.2.7</span> Unicode字符串文字</h4>
                  <div>
                     <p>你可以输入<a id="d59478e2093" class="indexterm-anchor"></a><a id="d59478e2097" class="indexterm-anchor"></a> SQL和PL / SQL中的Unicode字符串文字如下：</p>
                     <ul style="list-style-type:disc">
                        <li>
                           <p>在用单引号括起来的字符串文字前面加上前缀<code class="codeph">N</code>这明确指示以下字符串文字是<code class="codeph">NCHAR</code>字符串文字。例如， <code class="codeph">N'résumé'</code>是<code class="codeph">NCHAR</code>字符串文字。有关此方法的限制的信息，请参阅<span class="q">“ <a href="programming-with-unicode.html#GUID-50BE1BB8-DB5C-43C8-93F2-6FC7E9E3251D">NCHAR字符串文字替换</a> ”</span> 。
                           </p>
                        </li>
                        <li>
                           <p>使用<code class="codeph">NCHR(</code> <span class="italic"><code class="codeph">n</code></span> <code class="codeph">)</code> SQL函数，该函数返回国家字符集中的字符代码单位，即AL16UTF16或UTF8。连接几个<code class="codeph">NCHR(</code> <span class="italic"><code class="codeph">n</code></span> <code class="codeph">)</code>函数的结果是<code class="codeph">NVARCHAR2</code>数据。这样，您可以绕过客户端和服务器字符集转换并直接创建<code class="codeph">NVARCHAR2</code>字符串。例如， <code class="codeph">NCHR(32)</code>表示空白字符。
                           </p>
                           <p>由于<code class="codeph">NCHR(</code> <span class="italic"><code class="codeph">n</code></span> <code class="codeph">)</code>与国家字符集相关联，因此结果值的可移植性仅限于使用相同的国家字符集运行的应用程序。如果这是一个问题，那么使用<code class="codeph">UNISTR</code>函数来删除可移植性限制。
                           </p>
                        </li>
                        <li>
                           <p>使用<code class="codeph">UNISTR</code> （' <span class="italic"><code class="codeph">string'</code></span> ）SQL函数。<code class="codeph">UNISTR</code> （' <span class="italic"><code class="codeph">string'</code></span> ）将字符串转换为国家字符集。为确保可移植性和保留数据，请仅包括以下格式的ASCII字符和Unicode编码： <code class="codeph">\xxxx</code> ，其中<code class="codeph">xxxx</code>是UTF-16编码格式的字符代码值的十六进制值。例如， <code class="codeph">UNISTR('G\0061ry')</code>代表<code class="codeph">'Gary'</code> 。ASCII字符将转换为数据库字符集，然后转换为国家字符集。Unicode编码直接转换为国家字符集。
                           </p>
                        </li>
                     </ul>
                     <p>最后两个方法可用于编码任何Unicode字符串文字。</p>
                  </div>
               </div><a id="NLSPG344"></a><div class="props_rev_3"><a id="GUID-50BE1BB8-DB5C-43C8-93F2-6FC7E9E3251D" name="GUID-50BE1BB8-DB5C-43C8-93F2-6FC7E9E3251D"></a><h4 id="NLSPG-GUID-50BE1BB8-DB5C-43C8-93F2-6FC7E9E3251D" class="sect4"><span class="enumeration_section">7.2.8</span> NCHAR字符串文字替换</h4>
                  <div>
                     <p>本节提供有关在执行<code class="codeph">NCHAR</code>字符串文字替换时如何避免数据丢失的信息。
                     </p>
                     <p>作为SQL或PL / SQL语句的一部分，任何文字的文本（带或不带前缀<code class="codeph">N</code> ）都编码在与语句其余部分相同的字符集中。在客户端，该语句位于客户端字符集中，该客户端字符集由<code class="codeph">NLS_LANG</code>定义的客户端字符集确定，或者在<code class="codeph">OCIEnvNlsCreate()</code>调用中指定，或者在JDBC中预定义为UTF-16。在服务器端，该语句位于数据库字符集中。
                     </p>
                     <ul style="list-style-type:disc">
                        <li>
                           <p>当SQL或PL / SQL语句从客户端传输到数据库服务器时，其字符集会相应地转换。请务必注意，如果数据库字符集不包含文本文字中使用的所有字符，则此转换中的数据将丢失。此问题比<code class="codeph">CHAR</code>文本文字更多地影响<code class="codeph">NCHAR</code>字符串文字。这是因为<code class="codeph">N'</code>文字被设计为独立于数据库字符集，并且应该能够提供客户端字符集支持的任何数据。
                           </p>
                           <p>为避免在转换为不兼容的数据库字符集时丢失数据，可以激活<code class="codeph">NCHAR</code>文字替换功能。该功能透明地用内部格式替换客户端的<code class="codeph">N'</code>文字。然后，数据库服务器在执行语句时将其解码为Unicode。
                           </p>
                        </li>
                        <li>
                           <p><span class="q">“ <a href="programming-with-unicode.html#GUID-B2870DFB-CA26-4415-B138-FD62F88AE7F2">在OCI中处理SQL NCHAR字符串文字</a> ”</span>和<span class="q">“ <a href="programming-with-unicode.html#GUID-447077D7-C7B0-4C2E-94A3-6C986DF99497">在JDBC中使用SQL NCHAR字符串文字</a> ”部分分别</span>显示了如何在OCI和JDBC中打开替换功能。由于许多应用程序（例如SQL * Plus）使用OCI连接到数据库，并且它们不显式控制<code class="codeph">NCHAR</code>文字替换，因此可以将客户端环境变量<code class="codeph">ORA_NCHAR_LITERAL_REPLACE</code>为<code class="codeph">TRUE</code>以控制它们的功能。默认情况下，关闭该功能以保持向后兼容性。
                           </p>
                        </li>
                     </ul>
                  </div>
               </div><a id="NLSPG345"></a><div class="props_rev_3"><a id="GUID-F59FC7E1-E8C6-466B-BEC2-9E3DD0D7B7CC" name="GUID-F59FC7E1-E8C6-466B-BEC2-9E3DD0D7B7CC"></a><h4 id="NLSPG-GUID-F59FC7E1-E8C6-466B-BEC2-9E3DD0D7B7CC" class="sect4"><span class="enumeration_section">7.2.9</span>将UTL_FILE包与NCHAR数据一起使用</h4>
                  <div>
                     <p><code class="codeph">UTL_FILE</code>包处理<code class="codeph">NVARCHAR2</code>数据类型的Unicode国家字符集数据。通过隐式转换支持<code class="codeph">NCHAR</code>和<code class="codeph">NCLOB</code> 。功能和程序包括以下内容：</p>
                     <ul style="list-style-type:disc">
                        <li>
                           <p><code class="codeph">FOPEN_NCHAR</code></p>
                           <p>此功能以输入或输出的国家字符集模式打开文件，并指定最大行大小。即使<code class="codeph">NVARCHAR2</code>缓冲区的内容可能是AL16UTF16或UTF8（取决于数据库的国家字符集），也始终以UTF8读取和写入文件的内容。有关详细信息，请参阅<span class="q">“ <a href="supporting-multilingual-databases-with-unicode.html#GUID-CD422E4F-C5C6-4E22-B95F-CA9CABBCB543">Oracle数据库中对Unicode标准的支持</a> ”</span> 。<code class="codeph">UTL_FILE</code>根据需要在UTF8和AL16UTF16之间进行转换。
                           </p>
                        </li>
                        <li>
                           <p><code class="codeph">GET_LINE_NCHAR</code></p>
                           <p>此过程从文件句柄标识的打开文件中读取文本，并将文本放在输出缓冲区参数中。该文件必须以国家字符集模式打开，并且必须以UTF8字符集进行编码。预期的缓冲区数据类型是<code class="codeph">NVARCHAR2</code> 。如果指定了另一种数据类型的变量，例如<code class="codeph">NCHAR</code> ， <code class="codeph">NCLOB</code>或<code class="codeph">VARCHAR2</code> ，则PL / SQL在读取文本后执行<code class="codeph">NVARCHAR2</code>标准隐式转换。
                           </p>
                        </li>
                        <li>
                           <p><code class="codeph">PUT_NCHAR</code></p>
                           <p>此过程将存储在buffer参数中的文本字符串写入由文件句柄标识的打开文件。必须以国家字符集模式打开该文件。文本字符串将以UTF8字符集写入。预期的缓冲区数据类型是<code class="codeph">NVARCHAR2</code> 。如果指定了另一种数据类型的变量，PL / SQL会在写入文本之前执行到<code class="codeph">NVARCHAR2</code>隐式转换。
                           </p>
                        </li>
                        <li>
                           <p><code class="codeph">PUT_LINE_NCHAR</code></p>
                           <p>除了将行分隔符附加到书写文本之外，此过程等效于<code class="codeph">PUT_NCHAR</code> 。
                           </p>
                        </li>
                        <li>
                           <p><code class="codeph">PUTF_NCHAR</code></p>
                           <p>此过程是<code class="codeph">PUT_NCHAR</code>过程的格式化版本。它接受带格式化元素\ n和％s的格式字符串，最多五个参数替换格式字符串中％s的连续实例。格式字符串和参数的预期数据类型是<code class="codeph">NVARCHAR2</code> 。如果指定了另一种数据类型的变量，PL / SQL会在格式化文本之前执行到<code class="codeph">NVARCHAR2</code>隐式转换。格式化文本以UTF8字符集写入文件句柄标识的文件。必须以国家字符集模式打开该文件。
                           </p>
                        </li>
                     </ul>
                     <p>上述函数和过程处理以UTF8字符集编码的文本文件，即Unicode CESU-8编码。有关CESU-8的更多信息，请参见<span class="q">“ <a href="appendix-A-locale-data.html#GUID-9221C05D-B37A-4586-94AD-1CFC35B796F5">通用字符集</a> ”</span> 。函数和过程在UTF8和数据库的国家字符集之间转换，根据需要可以是UTF8或AL16UTF16。
                     </p>
                     <div class="infoboxnotealso" id="GUID-F59FC7E1-E8C6-466B-BEC2-9E3DD0D7B7CC__GUID-758942EF-3F58-4F9C-B5AD-ACF843ABF06B">
                        <p class="notep1">也可以看看：</p>
                        <p>有关<code class="codeph">UTL_FILE</code>包的更多信息，请<a href="../arpls/UTL_FILE.html#ARPLS069" target="_blank"><span class="italic">参见Oracle Database PL / SQL包和类型参考</span></a></p>
                     </div>
                  </div>
               </div>
            </div><a id="NLSPG0074"></a><div class="props_rev_3"><a id="GUID-C0EF74CA-C9C1-4651-B820-9B3E8FB70E8E" name="GUID-C0EF74CA-C9C1-4651-B820-9B3E8FB70E8E"></a><h3 id="NLSPG-GUID-C0EF74CA-C9C1-4651-B820-9B3E8FB70E8E" class="sect3"><span class="enumeration_section">7.3</span>使用Unicode进行OCI编程</h3>
               <div>
                  <p>OCI是访问数据库的最低级API，因此它提供了最佳性能。将Unicode与OCI一起使用时，请考虑以下主题：</p>
                  <ul style="list-style-type:disc">
                     <li>
                        <p><a href="programming-with-unicode.html#GUID-B041724B-7150-4F0A-BEAE-8EAC3C491D8F">OCIEnvNlsCreate（）用于Unicode编程的函数</a></p>
                     </li>
                     <li>
                        <p><a href="programming-with-unicode.html#GUID-4AC863D8-FE42-4AAF-B51A-D8A33868C58F">OCI Unicode代码转换</a></p>
                     </li>
                     <li>
                        <p><a href="programming-with-unicode.html#GUID-FC745A1D-8798-4FF6-833C-5C2D8EBE7D92">在OCI中将UTF-8设置为NLS_LANG字符集</a></p>
                     </li>
                     <li>
                        <p><a href="programming-with-unicode.html#GUID-92A6049E-699E-44BE-BB50-E3E68A6B3A10">在OCI中绑定和定义SQL CHAR数据类型</a></p>
                     </li>
                     <li>
                        <p><a href="programming-with-unicode.html#GUID-B2187D85-D726-468F-9B8E-5BEABEFB30F9">在OCI中绑定和定义SQL NCHAR数据类型</a></p>
                     </li>
                     <li>
                        <p><a href="programming-with-unicode.html#GUID-B2870DFB-CA26-4415-B138-FD62F88AE7F2">在OCI中处理SQL NCHAR字符串文字</a></p>
                     </li>
                     <li>
                        <p><a href="programming-with-unicode.html#GUID-83EB573B-5265-45A5-A053-46F460D4CC64">在OCI中绑定和定义CLOB和NCLOB Unicode数据</a></p>
                        <div class="infoboxnotealso" id="GUID-C0EF74CA-C9C1-4651-B820-9B3E8FB70E8E__GUID-3F1406B0-954A-4282-8083-08637D845792">
                           <p class="notep1">也可以看看：</p>
                           <p><a href="OCI-programming-in-global-environment.html#GUID-EC6C34A4-EBA0-4AA6-BBDC-191A1068A2E9">全球环境中的OCI编程</a></p>
                        </div>
                     </li>
                  </ul>
               </div><a id="NLSPG346"></a><div class="props_rev_3"><a id="GUID-B041724B-7150-4F0A-BEAE-8EAC3C491D8F" name="GUID-B041724B-7150-4F0A-BEAE-8EAC3C491D8F"></a><h4 id="NLSPG-GUID-B041724B-7150-4F0A-BEAE-8EAC3C491D8F" class="sect4"><span class="enumeration_section">7.3.1</span>用于Unicode编程的OCIEnvNlsCreate（）函数</h4>
                  <div>
                     <p><code class="codeph">OCIEnvNlsCreate()</code>函数用于在创建OCI环境时指定SQL <code class="codeph">CHAR</code>字符集和SQL <code class="codeph">NCHAR</code>字符集。它是<code class="codeph">OCIEnvCreate()</code>函数的增强版本，并具有两个字符集ID的扩展参数。该<a id="d59478e2701" class="indexterm-anchor"></a> OCI_UTF16ID UTF-16字符集ID替换<a id="d59478e2705" class="indexterm-anchor"></a> Oracle9 <span class="italic">i</span>版本1（9.0.1）中引入了Unicode模式。例如：</p><pre class="oac_no_warn" dir="ltr">OCIEnv * envhp; status = OCIEnvNlsCreate（（OCIEnv **）＆envhp，（ub4）0，（void *）0，（void *（*）（））0，（void *（*）（））0，（void（*）（ ））0，（size_t）0，（void **）0，（ub2）OCI_UTF16ID，/ *元数据和SQL CHAR字符集* /（ub2）OCI_UTF16ID / * SQL NCHAR字符集* /）;</pre><p>不推荐使用OCI_UTF16标志与OCIEnvCreate <code class="codeph">OCIEnvCreate()</code>函数一起使用的Unicode模式。
                     </p>
                     <p>为SQL <code class="codeph">CHAR</code>和SQL <code class="codeph">NCHAR</code>字符集指定OCI_UTF16ID时，所有元数据以及绑定和定义的数据都以UTF-16编码。元数据包括SQL语句，用户名，错误消息和列名。因此，所有继承的操作都独立于<code class="codeph">NLS_LANG</code>设置，并且假定所有元<code class="codeph">text*</code>数据参数（ <code class="codeph">text*</code> ）都是UTF-16编码的Unicode文本数据类型（ <code class="codeph">utext*</code> ）。
                     </p>
                     <p>要在使用OCI_UTF16ID字符集ID初始化<code class="codeph">OCIEnv()</code>函数时准备SQL语句，请使用<code class="codeph">(utext*)</code>字符串调用<code class="codeph">OCIStmtPrepare()</code>函数。以下示例仅在Windows平台上运行。您可能需要更改其他平台的<code class="codeph">wchar_t</code>数据类型。
                     </p><pre class="oac_no_warn" dir="ltr">const wchar_t sqlstr [] = L“SELECT * FROM ENAME =：ename”; ...OCIStmt * stmthp; sts = OCIHandleAlloc（envh，（void **）＆stmthp，OCI_HTYPE_STMT，0，NULL）; status = OCIStmtPrepare（stmthp，errhp，（const text *）sqlstr，wcslen（sqlstr），OCI_NTV_SYNTAX，OCI_DEFAULT）;</pre><p>要绑定和定义数据，您不必设置<code class="codeph">OCI_ATTR_CHARSET_ID</code>属性，因为<code class="codeph">OCIEnv()</code>函数已使用UTF-16字符集ID初始化。绑定变量名称也必须是UTF-16字符串。
                     </p><pre class="oac_no_warn" dir="ltr">/ *插入Unicode数据* / OCIBindByName（stmthp1，＆bnd1p，errhp，（const text *）L“：ename”，（sb4）wcslen（L“：ename”），（void *）ename，sizeof（ename），SQLT_STR ，（void *）＆insname_ind，（ub2 *）0，（ub2 *）0，（ub4）0，（ub4 *）0，OCI_DEFAULT）; OCIAttrSet（（void *）bnd1p，（ub4）OCI_HTYPE_BIND，（void *）＆ename_col_len，（ub4）0，（ub4）OCI_ATTR_MAXDATA_SIZE，errhp）; .../ *检索Unicode数据* / OCIDefineByPos（stmthp2，＆dfn1p，errhp，（ub4）1，（void *）ename，（sb4）sizeof（ename），SQLT_STR，（void *）0，（ub2 *）0，（ub2 *）0，（ub4）OCI_DEFAULT）;</pre><p><code class="codeph">OCIExecute()</code>函数执行操作。
                     </p>
                     <div class="infoboxnotealso" id="GUID-B041724B-7150-4F0A-BEAE-8EAC3C491D8F__GUID-351A32F4-F15F-4683-A8DE-6426AD158269">
                        <p class="notep1">也可以看看：</p>
                        <p><span class="q">“ <a href="OCI-programming-in-global-environment.html#GUID-862EA6EF-0D7E-43DD-9ADE-D6648D8F7988">在OCI中指定字符集</a> ”</span></p>
                     </div>
                  </div>
               </div><a id="NLSPG347"></a><div class="props_rev_3"><a id="GUID-4AC863D8-FE42-4AAF-B51A-D8A33868C58F" name="GUID-4AC863D8-FE42-4AAF-B51A-D8A33868C58F"></a><h4 id="NLSPG-GUID-4AC863D8-FE42-4AAF-B51A-D8A33868C58F" class="sect4"><span class="enumeration_section">7.3.2</span> OCI Unicode代码转换</h4>
                  <div>
                     <p>统一<a id="d59478e2848" class="indexterm-anchor"></a><a id="d59478e2852" class="indexterm-anchor"></a>如果客户端和服务器字符集不同，则字符集转换发生在OCI客户端和数据库服务器之间。转换发生在客户端或服务器上，具体取决于具体情况，但通常在客户端。
                     </p>
                  </div><a id="NLSPG348"></a><div class="props_rev_3"><a id="GUID-337FC5E5-9A3F-4E49-B6C5-A94D82607BB9" name="GUID-337FC5E5-9A3F-4E49-B6C5-A94D82607BB9"></a><h5 id="NLSPG-GUID-337FC5E5-9A3F-4E49-B6C5-A94D82607BB9" class="sect5"><span class="enumeration_section">7.3.2.1</span>数据完整性</h5>
                     <div>
                        <p>您可以<a id="d59478e2931" class="indexterm-anchor"></a><a id="d59478e2935" class="indexterm-anchor"></a>如果您不恰当地调用OCI API，则会在转换期间丢失数据。如果服务器和客户端字符集不同，则当目标字符集的集合小于源字符集时，可能会丢失数据。如果两个字符集都是Unicode字符集（例如，UTF8和AL16UTF16），则可以避免此潜在问题。
                        </p>
                        <p>当您绑定或定义SQL <code class="codeph">NCHAR</code>数据类型，你应该设置<code class="codeph">OCI_ATTR_CHARSET_FORM</code>属性<code class="codeph">SQLCS_NCHAR</code> 。否则，您可能会丢失数据，因为在转换为国家字符集或从国家字符集转换之前，数据将转换为数据库字符集。仅当数据库字符集不是Unicode时才会发生这种情况。
                        </p>
                     </div>
                  </div><a id="NLSPG809"></a><a id="NLSPG349"></a><div class="props_rev_3"><a id="GUID-D8B3B7C5-6361-43F0-9164-3F32090D5376" name="GUID-D8B3B7C5-6361-43F0-9164-3F32090D5376"></a><h5 id="NLSPG-GUID-D8B3B7C5-6361-43F0-9164-3F32090D5376" class="sect5"><span class="enumeration_section">7.3.2.2</span>使用Unicode时的OCI性能影响</h5>
                     <div>
                        <p>冗余数据转换可能会导致OCI应用程序性能下降。这些转换发生在两种情况：</p>
                        <ul style="list-style-type:disc">
                           <li>
                              <p>当您绑定或定义SQL <code class="codeph">CHAR</code>数据类型，并设置<code class="codeph">OCI_ATTR_CHARSET_FORM</code>属性<code class="codeph">SQLCS_NCHAR</code> ，数据转换采取从成为了国家数据库字符集客户端字符的地方，从国家字符集数据库字符集。预计不会丢失任何数据，但即使只需要一次转换，也会发生两次转换。
                              </p>
                           </li>
                           <li>
                              <p>绑定或定义SQL <code class="codeph">NCHAR</code>数据类型并且未设置<code class="codeph">OCI_ATTR_CHARSET_FORM</code> ，数据转换将从客户端字符集发生到数据库字符集，并从数据库字符集发生到国家数据库字符集。在最坏的情况下，如果数据库字符集小于客户端，则可能会发生数据丢失。
                              </p>
                           </li>
                        </ul>
                        <p>为避免性能问题，应始终根据目标列的数据类型正确设置<code class="codeph">OCI_ATTR_CHARSET_FORM</code> 。如果你不知道自己的目标数据类型，那么你应该设置<code class="codeph">OCI_ATTR_CHARSET_FORM</code>属性<code class="codeph">SQLCS_NCHAR</code>绑定和定义时。
                        </p>
                        <p>下表包含有关OCI字符集转换的信息。</p>
                        <div class="tblformalwide" id="GUID-D8B3B7C5-6361-43F0-9164-3F32090D5376__G1010212">
                           <p class="titleintable">表7-3 OCI字符集转换</p>
                           <table cellpadding="4" cellspacing="0" class="FormalWide" title="OCI字符集转换" width="100%" border="1" summary="This table describes settings for OCI_ATTR_CHARSET_FORM, based on the type of the target columns." frame="hsides" rules="rows">
                              <thead>
                                 <tr align="left" valign="top">
                                    <th align="left" valign="bottom" id="d59478e3086">OCI客户端缓冲区的数据类型</th>
                                    <th align="left" valign="bottom" id="d59478e3089">OCI_ATTR_CHARSET_FORM</th>
                                    <th align="left" valign="bottom" id="d59478e3092">数据库中目标列的数据类型</th>
                                    <th align="left" valign="bottom" id="d59478e3095">之间的转换</th>
                                    <th align="left" valign="bottom" id="d59478e3098">评论</th>
                                 </tr>
                              </thead>
                              <tbody>
                                 <tr align="left" valign="top">
                                    <td align="left" valign="top" id="d59478e3103" headers="d59478e3086 ">
                                       <p><code class="codeph">utext</code></p>
                                    </td>
                                    <td align="left" valign="top" headers="d59478e3103 d59478e3089 ">
                                       <p><code class="codeph">SQLCS_IMPLICIT</code></p>
                                    </td>
                                    <td align="left" valign="top" headers="d59478e3103 d59478e3092 ">
                                       <p><code class="codeph">CHAR，VARCHAR2，</code></p>
                                       <p><code class="codeph">CLOB</code></p>
                                    </td>
                                    <td align="left" valign="top" headers="d59478e3103 d59478e3095 ">
                                       <p>OCI中的UTF-16和数据库字符集</p>
                                    </td>
                                    <td align="left" valign="top" headers="d59478e3103 d59478e3098 ">
                                       <p>没有意外的数据丢失</p>
                                    </td>
                                 </tr>
                                 <tr align="left" valign="top">
                                    <td align="left" valign="top" id="d59478e3125" headers="d59478e3086 ">
                                       <p><code class="codeph">utext</code></p>
                                    </td>
                                    <td align="left" valign="top" headers="d59478e3125 d59478e3089 ">
                                       <p><code class="codeph">SQLCS_NCHAR</code></p>
                                    </td>
                                    <td align="left" valign="top" headers="d59478e3125 d59478e3092 ">
                                       <p><code class="codeph">NCHAR，NVARCHAR2，</code></p>
                                       <p><code class="codeph">NCLOB</code></p>
                                    </td>
                                    <td align="left" valign="top" headers="d59478e3125 d59478e3095 ">
                                       <p>OCI中的UTF-16和国家字符集</p>
                                    </td>
                                    <td align="left" valign="top" headers="d59478e3125 d59478e3098 ">
                                       <p>没有意外的数据丢失</p>
                                    </td>
                                 </tr>
                                 <tr align="left" valign="top">
                                    <td align="left" valign="top" id="d59478e3147" headers="d59478e3086 ">
                                       <p><code class="codeph">utext</code></p>
                                    </td>
                                    <td align="left" valign="top" headers="d59478e3147 d59478e3089 ">
                                       <p><code class="codeph">SQLCS_NCHAR</code></p>
                                    </td>
                                    <td align="left" valign="top" headers="d59478e3147 d59478e3092 ">
                                       <p><code class="codeph">CHAR，VARCHAR2，</code></p>
                                       <p><code class="codeph">CLOB</code></p>
                                    </td>
                                    <td align="left" valign="top" headers="d59478e3147 d59478e3095 ">
                                       <p>OCI中的UTF-16和国家字符集</p>
                                       <p>数据库服务器中的国家字符集和数据库字符集</p>
                                    </td>
                                    <td align="left" valign="top" headers="d59478e3147 d59478e3098 ">
                                       <p>没有意外的数据丢失，但可能会降低性能，因为转换通过国家字符集</p>
                                    </td>
                                 </tr>
                                 <tr align="left" valign="top">
                                    <td align="left" valign="top" id="d59478e3171" headers="d59478e3086 ">
                                       <p><code class="codeph">utext</code></p>
                                    </td>
                                    <td align="left" valign="top" headers="d59478e3171 d59478e3089 ">
                                       <p><code class="codeph">SQLCS_IMPLICIT</code></p>
                                    </td>
                                    <td align="left" valign="top" headers="d59478e3171 d59478e3092 ">
                                       <p><code class="codeph">NCHAR，NVARCHAR2，</code></p>
                                       <p><code class="codeph">NCLOB</code></p>
                                    </td>
                                    <td align="left" valign="top" headers="d59478e3171 d59478e3095 ">
                                       <p>OCI中的UTF-16和数据库字符集</p>
                                       <p>数据库服务器中的数据库字符集和国家字符集</p>
                                    </td>
                                    <td align="left" valign="top" headers="d59478e3171 d59478e3098 ">
                                       <p>如果数据库字符集不是Unicode，则可能会丢失数据</p>
                                    </td>
                                 </tr>
                                 <tr align="left" valign="top">
                                    <td align="left" valign="top" id="d59478e3195" headers="d59478e3086 ">
                                       <p><code class="codeph">文本</code></p>
                                    </td>
                                    <td align="left" valign="top" headers="d59478e3195 d59478e3089 ">
                                       <p><code class="codeph">SQLCS_IMPLICIT</code></p>
                                    </td>
                                    <td align="left" valign="top" headers="d59478e3195 d59478e3092 ">
                                       <p><code class="codeph">CHAR，VARCHAR2，</code></p>
                                       <p><code class="codeph">CLOB</code></p>
                                    </td>
                                    <td align="left" valign="top" headers="d59478e3195 d59478e3095 ">
                                       <p>OCI中的<code class="codeph">NLS_LANG</code>字符集和数据库字符集</p>
                                    </td>
                                    <td align="left" valign="top" headers="d59478e3195 d59478e3098 ">
                                       <p>没有意外的数据丢失</p>
                                    </td>
                                 </tr>
                                 <tr align="left" valign="top">
                                    <td align="left" valign="top" id="d59478e3219" headers="d59478e3086 ">
                                       <p><code class="codeph">文本</code></p>
                                    </td>
                                    <td align="left" valign="top" headers="d59478e3219 d59478e3089 ">
                                       <p><code class="codeph">SQLCS_NCHAR</code></p>
                                    </td>
                                    <td align="left" valign="top" headers="d59478e3219 d59478e3092 ">
                                       <p><code class="codeph">NCHAR，NVARCHAR2，</code></p>
                                       <p><code class="codeph">NCLOB</code></p>
                                    </td>
                                    <td align="left" valign="top" headers="d59478e3219 d59478e3095 ">
                                       <p>OCI中的<code class="codeph">NLS_LANG</code>字符集和国家字符集</p>
                                    </td>
                                    <td align="left" valign="top" headers="d59478e3219 d59478e3098 ">
                                       <p>没有意外的数据丢失</p>
                                    </td>
                                 </tr>
                                 <tr align="left" valign="top">
                                    <td align="left" valign="top" id="d59478e3243" headers="d59478e3086 ">
                                       <p><code class="codeph">文本</code></p>
                                    </td>
                                    <td align="left" valign="top" headers="d59478e3243 d59478e3089 ">
                                       <p><code class="codeph">SQLCS_NCHAR</code></p>
                                    </td>
                                    <td align="left" valign="top" headers="d59478e3243 d59478e3092 ">
                                       <p><code class="codeph">CHAR，VARCHAR2，</code></p>
                                       <p><code class="codeph">CLOB</code></p>
                                    </td>
                                    <td align="left" valign="top" headers="d59478e3243 d59478e3095 ">
                                       <p>OCI中的<code class="codeph">NLS_LANG</code>字符集和国家字符集</p>
                                       <p>数据库服务器中的国家字符集和数据库字符集</p>
                                    </td>
                                    <td align="left" valign="top" headers="d59478e3243 d59478e3098 ">
                                       <p>没有意外的数据丢失，但可能会降低性能，因为转换通过国家字符集</p>
                                    </td>
                                 </tr>
                                 <tr align="left" valign="top">
                                    <td align="left" valign="top" id="d59478e3269" headers="d59478e3086 ">
                                       <p><code class="codeph">文本</code></p>
                                    </td>
                                    <td align="left" valign="top" headers="d59478e3269 d59478e3089 ">
                                       <p><code class="codeph">SQLCS_IMPLICIT</code></p>
                                    </td>
                                    <td align="left" valign="top" headers="d59478e3269 d59478e3092 ">
                                       <p><code class="codeph">NCHAR，NVARCHAR2，</code></p>
                                       <p><code class="codeph">NCLOB</code></p>
                                    </td>
                                    <td align="left" valign="top" headers="d59478e3269 d59478e3095 ">
                                       <p>OCI中的<code class="codeph">NLS_LANG</code>字符集和数据库字符集</p>
                                       <p>数据库服务器中的数据库字符集和国家字符集</p>
                                    </td>
                                    <td align="left" valign="top" headers="d59478e3269 d59478e3098 ">
                                       <p>可能会发生数据丢失，因为转换通过数据库字符集</p>
                                    </td>
                                 </tr>
                              </tbody>
                           </table>
                        </div>
                        <!-- class="inftblhruleinformal" -->
                     </div>
                  </div><a id="NLSPG350"></a><div class="props_rev_3"><a id="GUID-36DB4B6A-864A-4059-A119-5ADDBACD26A7" name="GUID-36DB4B6A-864A-4059-A119-5ADDBACD26A7"></a><h5 id="NLSPG-GUID-36DB4B6A-864A-4059-A119-5ADDBACD26A7" class="sect5"><span class="enumeration_section">7.3.2.3</span> OCI Unicode数据扩展</h5>
                     <div>
                        <p>数据转换可能导致<a id="d59478e3369" class="indexterm-anchor"></a><a id="d59478e3373" class="indexterm-anchor"></a>数据扩展，可能导致缓冲区溢出。对于绑定操作，必须将<code class="codeph">OCI_ATTR_MAXDATA_SIZE</code>属性设置为足够大的大小，以便在服务器上保存扩展数据。如果这很难做，那么您必须考虑更改表模式。为了定义操作，客户端应用程序必须为扩展数据分配足够的缓冲区空间。缓冲区的大小应该是扩展数据的最大长度。您可以通过以下计算估计最大缓冲区长度：</p>
                        <ol>
                           <li>
                              <p>获取列数据字节大小。</p>
                           </li>
                           <li>
                              <p>将其乘以客户端字符集中每个字符的最大字节数。</p>
                           </li>
                        </ol>
                        <p>这种方法是最简单，最快捷的方法，但可能不准确，浪费内存。它适用于任何字符集组合。例如，对于UTF-16数据绑定和定义，以下示例计算客户端缓冲区：</p><pre class="oac_no_warn" dir="ltr">ub2 csid = OCI_UTF16ID; oratext * selstmt =“SELECT ename FROM emp”; counter = 1; ...OCIStmtPrepare（stmthp，errhp，selstmt，（ub4）strlen（（char *）selstmt），OCI_NTV_SYNTAX，OCI_DEFAULT）; OCIStmtExecute（svchp，stmthp，errhp，（ub4）0，（ub4）0，（CONST OCISnapshot *）0，（OCISnapshot *）0，OCI_DESCRIBE_ONLY）; OCIParamGet（stmthp，OCI_HTYPE_STMT，errhp，＆myparam，（ub4）counter）; OCIAttrGet（（void *）myparam，（ub4）OCI_DTYPE_PARAM，（void *）＆col_width，（ub4 *）0，（ub4）OCI_ATTR_DATA_SIZE，errhp）; ...maxenamelen =（col_width + 1）* sizeof（utext）; cbuf =（utext *）malloc（maxenamelen）; ...OCIDefineByPos（stmthp，＆dfnp，errhp，（ub4）1，（void *）cbuf，（sb4）maxenamelen，SQLT_STR，（void *）0，（ub2 *）0，（ub2 *）0，（ub4）OCI_DEFAULT）; OCIAttrSet（（void *）dfnp，（ub4）OCI_HTYPE_DEFINE，（void *）＆csid，（ub4）0，（ub4）OCI_ATTR_CHARSET_ID，errhp）; OCIStmtFetch（stmthp，errhp，1，OCI_FETCH_NEXT，OCI_DEFAULT）; ...</pre></div>
                  </div>
               </div><a id="NLSPG351"></a><div class="props_rev_3"><a id="GUID-FC745A1D-8798-4FF6-833C-5C2D8EBE7D92" name="GUID-FC745A1D-8798-4FF6-833C-5C2D8EBE7D92"></a><h4 id="NLSPG-GUID-FC745A1D-8798-4FF6-833C-5C2D8EBE7D92" class="sect4"><span class="enumeration_section">7.3.3</span>在OCI中将UTF-8设置为NLS_LANG字符集</h4>
                  <div>
                     <p>对于支持Unicode UTF-8编码的OCI客户端应用程序，请使用AL32UTF8指定<a id="d59478e3467" class="indexterm-anchor"></a><a id="d59478e3471" class="indexterm-anchor"></a> <code class="codeph">NLS_LANG</code>字符集，除非数据库字符集是UTF8。如果数据库字符集是UTF8，请使用UTF8。
                     </p>
                     <p>不要将<code class="codeph">NLS_LANG</code>设置为AL16UTF16，因为AL16UTF16是服务器的国家字符集。如果需要使用UTF-16，则应在绑定或定义数据时使用<code class="codeph">OCIAttrSet()</code>函数将客户端字符集指定为<code class="codeph">OCI_UTF16ID</code> 。
                     </p>
                  </div>
               </div><a id="NLSPG352"></a><div class="props_rev_3"><a id="GUID-92A6049E-699E-44BE-BB50-E3E68A6B3A10" name="GUID-92A6049E-699E-44BE-BB50-E3E68A6B3A10"></a><h4 id="NLSPG-GUID-92A6049E-699E-44BE-BB50-E3E68A6B3A10" class="sect4"><span class="enumeration_section">7.3.4</span>在OCI中绑定和定义SQL CHAR数据类型</h4>
                  <div>
                     <div class="section">
                        <p>指定一个<a id="d59478e3565" class="indexterm-anchor"></a><a id="d59478e3567" class="indexterm-anchor"></a><a id="d59478e3571" class="indexterm-anchor"></a>用于绑定和定义具有SQL <code class="codeph">CHAR</code>数据类型的数据的Unicode字符集，您可能需要调用<code class="codeph">OCIAttrSet()</code>函数以在<code class="codeph">OCIBind()</code>或<code class="codeph">OCIDefine()</code> API之后设置适当的字符集ID。有两种典型案例：</p>
                     </div>
                     <!-- class="section" -->
                     <div class="section">
                        <ul style="list-style-type:disc">
                           <li>
                              <p>调用<code class="codeph">OCIBind()</code>或<code class="codeph">OCIDefine()</code>然后<code class="codeph">OCIAttrSet</code> （）以指定UTF-16 Unicode字符集编码。例如：</p><pre class="oac_no_warn" dir="ltr">...ub2 csid = OCI_UTF16ID; utext ename [100]; / *足够的缓冲区用于ENAME * / .../ *插入Unicode数据* / OCIBindByName（stmthp1，＆bnd1p，errhp，（oratext *）“：ENAME”，（sb4）strlen（（char *）“：ENAME”），（void *）ename，sizeof（ename）， SQLT_STR，（void *）＆insname_ind，（ub2 *）0，（ub2 *）0，（ub4）0，（ub4 *）0，OCI_DEFAULT）; OCIAttrSet（（void *）bnd1p，（ub4）OCI_HTYPE_BIND，（void *）＆csid，（ub4）0，（ub4）OCI_ATTR_CHARSET_ID，errhp）; OCIAttrSet（（void *）bnd1p，（ub4）OCI_HTYPE_BIND，（void *）＆ename_col_len，（ub4）0，（ub4）OCI_ATTR_MAXDATA_SIZE，errhp）; .../ *检索Unicode数据* / OCIDefineByPos（stmthp2，＆dfn1p，errhp，（ub4）1，（void *）ename，（sb4）sizeof（ename），SQLT_STR，（void *）0，（ub2 *）0，（ub2 *）0，（ub4）OCI_DEFAULT）; OCIAttrSet（（void *）dfn1p，（ub4）OCI_HTYPE_DEFINE，（void *）＆csid，（ub4）0，（ub4）OCI_ATTR_CHARSET_ID，errhp）; ...
</pre><p>如果绑定缓冲区属于<code class="codeph">utext</code>数据类型，则应在<code class="codeph">OCIBind()</code>或<code class="codeph">OCIDefine()</code>时添加<code class="codeph">OCIBind()</code> <code class="codeph">text</code> *）。<code class="codeph">OCI_ATTR_MAXDATA_SIZE</code>属性的值通常由服务器字符集的列大小确定，因为此大小仅用于在执行绑定操作时为服务器上的转换分配临时缓冲区空间。
                              </p>
                           </li>
                           <li>
                              <p>使用指定为UTF8或AL32UTF8的<code class="codeph">NLS_LANG</code>字符集调用<code class="codeph">OCIBind()</code>或<code class="codeph">OCIDefine()</code> 。
                              </p>
                              <p>可以在<code class="codeph">NLS_LANG</code>环境变量中设置UTF8或AL32UTF8。您以与不使用Unicode时完全相同的方式调用<code class="codeph">OCIBind()</code>和<code class="codeph">OCIDefine()</code> 。将<code class="codeph">NLS_LANG</code>环境变量设置为UTF8或AL32UTF8并运行以下OCI程序：</p><pre class="oac_no_warn" dir="ltr">...oratext ename [100]; / * ENAME的足够缓冲区大小* / .../ *插入Unicode数据* / OCIBindByName（stmthp1，＆bnd1p，errhp，（oratext *）“：ENAME”，（sb4）strlen（（char *）“：ENAME”），（void *）ename，sizeof（ename）， SQLT_STR，（void *）＆insname_ind，（ub2 *）0，（ub2 *）0，（ub4）0，（ub4 *）0，OCI_DEFAULT）; OCIAttrSet（（void *）bnd1p，（ub4）OCI_HTYPE_BIND，（void *）＆ename_col_len，（ub4）0，（ub4）OCI_ATTR_MAXDATA_SIZE，errhp）; .../ *检索Unicode数据* / OCIDefineByPos（stmthp2，＆dfn1p，errhp，（ub4）1，（void *）ename，（sb4）sizeof（ename），SQLT_STR，（void *）0，（ub2 *）0，（ub2 *）0，（ub4）OCI_DEFAULT）; ...</pre></li>
                        </ul>
                     </div>
                     <!-- class="section" -->
                  </div>
               </div><a id="NLSPG353"></a><div class="props_rev_3"><a id="GUID-B2187D85-D726-468F-9B8E-5BEABEFB30F9" name="GUID-B2187D85-D726-468F-9B8E-5BEABEFB30F9"></a><h4 id="NLSPG-GUID-B2187D85-D726-468F-9B8E-5BEABEFB30F9" class="sect4"><span class="enumeration_section">7.3.5</span>在OCI中绑定和定义SQL NCHAR数据类型</h4>
                  <div>
                     <div class="section">
                        <p><a id="d59478e3724" class="indexterm-anchor"></a><a id="d59478e3726" class="indexterm-anchor"></a><a id="d59478e3730" class="indexterm-anchor"></a> Oracle建议您使用UTF-16绑定访问SQL <code class="codeph">NCHAR</code>数据类型，或者在使用OCI时定义。从Oracle9 <span class="italic">i</span>开始，SQL <code class="codeph">NCHAR</code>数据类型是Unicode数据类型，编码为UTF8或AL16UTF16。访问SQL数据<code class="codeph">NCHAR</code>数据类型，设置<code class="codeph">OCI_ATTR_CHARSET_FORM</code>属性<code class="codeph">SQLCS_NCHAR</code>使得它执行而不会丢失数据的适当的数据转换结合或定义和执行之间。SQL <code class="codeph">NCHAR</code>数据类型中的数据长度始终为Unicode代码单元的数量。
                        </p>
                        <p>以下程序是针对<code class="codeph">NCHAR</code>数据列插入和获取数据的典型示例：</p><pre class="oac_no_warn" dir="ltr">...ub2 csid = OCI_UTF16ID; ub1 cform = SQLCS_NCHAR; utext ename [100]; / *足够的缓冲区用于ENAME * / .../ *插入Unicode数据* / OCIBindByName（stmthp1，＆bnd1p，errhp，（oratext *）“：ENAME”，（sb4）strlen（（char *）“：ENAME”），（void *）ename，sizeof（ename）， SQLT_STR，（void *）＆insname_ind，（ub2 *）0，（ub2 *）0，（ub4）0，（ub4 *）0，OCI_DEFAULT）; OCIAttrSet（（void *）bnd1p，（ub4）OCI_HTYPE_BIND，（void *）＆cform，（ub4）0，（ub4）OCI_ATTR_CHARSET_FORM，errhp）; OCIAttrSet（（void *）bnd1p，（ub4）OCI_HTYPE_BIND，（void *）＆csid，（ub4）0，（ub4）OCI_ATTR_CHARSET_ID，errhp）; OCIAttrSet（（void *）bnd1p，（ub4）OCI_HTYPE_BIND，（void *）＆ename_col_len，（ub4）0，（ub4）OCI_ATTR_MAXDATA_SIZE，errhp）; .../ *检索Unicode数据* / OCIDefineByPos（stmthp2，＆dfn1p，errhp，（ub4）1，（void *）ename，（sb4）sizeof（ename），SQLT_STR，（void *）0，（ub2 *）0，（ub2 *）0，（ub4）OCI_DEFAULT）; OCIAttrSet（（void *）dfn1p，（ub4）OCI_HTYPE_DEFINE，（void *）＆csid，（ub4）0，（ub4）OCI_ATTR_CHARSET_ID，errhp）; OCIAttrSet（（void *）dfn1p，（ub4）OCI_HTYPE_DEFINE，（void *）＆cform，（ub4）0，（ub4）OCI_ATTR_CHARSET_FORM，errhp）; ...</pre></div>
                     <!-- class="section" -->
                  </div>
               </div><a id="NLSPG354"></a><div class="props_rev_3"><a id="GUID-B2870DFB-CA26-4415-B138-FD62F88AE7F2" name="GUID-B2870DFB-CA26-4415-B138-FD62F88AE7F2"></a><h4 id="NLSPG-GUID-B2870DFB-CA26-4415-B138-FD62F88AE7F2" class="sect4"><span class="enumeration_section">7.3.6</span>在OCI中处理SQL NCHAR字符串文字</h4>
                  <div>
                     <div class="section">
                        <p>默认情况下，OCI中未启用<code class="codeph">NCHAR</code>文字替换。您可以通过将环境变量<code class="codeph">ORA_NCHAR_LITERAL_REPLACE</code>设置为<code class="codeph">TRUE</code>来在OCI中启用它。</p>
                        <p>您也可以通过启用OCI编程面值替换<code class="codeph">OCI_NCHAR_LITERAL_REPLACE_ON</code>和<code class="codeph">OCI_NCHAR_LITERAL_REPLACE_OFF</code>在模式<code class="codeph">OCIEnvCreate()</code>和<code class="codeph">OCIEnvNlsCreate()</code>例如， <code class="codeph">OCIEnvCreate(OCI_NCHAR_LITERAL_REPLACE_ON)</code>启用<code class="codeph">NCHAR</code>文字替换， <code class="codeph">OCIEnvCreate(OCI_NCHAR_LITERAL_REPLACE_OFF)</code>禁用它。
                        </p>
                        <p>例如，请考虑以下声明：</p><pre class="oac_no_warn" dir="ltr">int main（argc，argv）{OCIEnv * envhp; if（OCIEnvCreate（（OCIEnv **）＆envhp，（ub4）OCI_THREADED | OCI_NCHAR_LITERAL_REPLACE_ON，（dvoid *）0，（dvoid *（*）（dvoid *，size_t））0，（dvoid *（*）（dvoid *，dvoid） *，size_t））0，（void（*）（dvoid *，dvoid *））0，（size_t）0，（dvoid **）0））{printf（“FAILED：OCIEnvCreate（）\ n”;返回1 ;} ...}</pre><div class="infoboxnote" id="GUID-B2870DFB-CA26-4415-B138-FD62F88AE7F2__GUID-F27310A1-2F79-4956-91D8-900896E9E8C0">
                           <p class="notep1">注意：</p>
                           <p>启用<code class="codeph">NCHAR</code>文字替换后， <code class="codeph">OCIStmtPrepare</code>和<code class="codeph">OCIStmtPrepare2</code>在SQL文本中使用<code class="codeph">U'</code>文字转换<code class="codeph">N'</code>文字，并将生成的SQL文本存储在语句句柄中。因此，如果应用程序使用<code class="codeph">OCI_ATTR_STATEMENT</code>从OCI语句句柄中检索SQL文本，则SQL文本将返回原始文本中指定的<code class="codeph">U'</code>而不是<code class="codeph">N'</code> 。
                           </p>
                        </div>
                        <div class="infoboxnotealso" id="GUID-B2870DFB-CA26-4415-B138-FD62F88AE7F2__GUID-9423E3AA-B9DE-4327-94D7-4A28F44515D4">
                           <p class="notep1">也可以看看：</p>
                           <ul style="list-style-type:disc">
                              <li>
                                 <p><span class="q">“ <a href="programming-with-unicode.html#GUID-50BE1BB8-DB5C-43C8-93F2-6FC7E9E3251D">NCHAR String Literal Replacement</a> ”</span></p>
                              </li>
                              <li>
                                 <p>有关如何设置环境变量的信息，请参见<a href="../admin/getting-started-with-database-administration.html#ADMIN12475" target="_blank"><span class="italic">“Oracle数据库管理员指南”</span></a></p>
                              </li>
                           </ul>
                        </div>
                     </div>
                     <!-- class="section" -->
                  </div>
               </div><a id="NLSPG355"></a><div class="props_rev_3"><a id="GUID-83EB573B-5265-45A5-A053-46F460D4CC64" name="GUID-83EB573B-5265-45A5-A053-46F460D4CC64"></a><h4 id="NLSPG-GUID-83EB573B-5265-45A5-A053-46F460D4CC64" class="sect4"><span class="enumeration_section">7.3.7</span>在OCI中绑定和定义CLOB和NCLOB Unicode数据</h4>
                  <div>
                     <div class="section">
                        <p>为了写入（绑定）和读取（定义） <code class="codeph">CLOB</code>或<code class="codeph">NCLOB</code>列的UTF-16数据，必须将UTF-16字符集ID指定为<code class="codeph">OCILobWrite()</code>和<code class="codeph">OCILobRead()</code> 。将UTF-16数据写入<code class="codeph">CLOB</code>列时，请按如下方式调用<code class="codeph">OCILobWrite()</code> ：</p><pre class="oac_no_warn" dir="ltr">...ub2 csid = OCI_UTF16ID; err = OCILobWrite（ctx-&gt; svchp，ctx-&gt; errhp，lobp，＆amtp，offset，（void *）buf，（ub4）BUFSIZE，OCI_ONE_PIECE，（void *）0，（sb4（*）（））0，（ ub2）csid，（ub1）SQLCS_IMPLICIT）;</pre><p><code class="codeph">amtp</code>参数是Unicode代码单元数的数据长度。<code class="codeph">offset</code>参数指示数据从数据列开头的偏移量。必须为UTF-16数据设置<code class="codeph">csid</code>参数。
                        </p>
                        <p>要从<code class="codeph">CLOB</code>列读取UTF-16数据，请按如下方式调用<code class="codeph">OCILobRead()</code> ：</p><pre class="oac_no_warn" dir="ltr">...ub2 csid = OCI_UTF16ID; err = OCILobRead（ctx-&gt; svchp，ctx-&gt; errhp，lobp，＆amtp，offset，（void *）buf，（ub4）BUFSIZE，（void *）0，（sb4（*）（））0，（ub2） csid，（ub1）SQLCS_IMPLICIT）;</pre><p>数据长度始终以Unicode代码单位的数量表示。注意，一个Unicode补充字符被计为两个代码单元，因为编码是UTF-16。绑定或定义<code class="codeph">LOB</code>列后，可以使用<code class="codeph">OCILobGetLength()</code>测量存储在<code class="codeph">LOB</code>列中的数据长度。如果绑定或定义为UTF-16，则返回值是代码单元数中的数据长度。
                        </p><pre class="oac_no_warn" dir="ltr">err = OCILobGetLength（ctx-&gt; svchp，ctx-&gt; errhp，lobp，＆lenp）;</pre><p>如果您使用的是<code class="codeph">NCLOB</code> ，则必须设置<code class="codeph">OCI_ATTR_CHARSET_FORM</code>到<code class="codeph">SQLCS_NCHAR</code> 。</p>
                     </div>
                     <!-- class="section" -->
                  </div>
               </div>
            </div><a id="NLSPG0075"></a><div class="props_rev_3"><a id="GUID-302CBDBC-3A81-415F-86B0-86BB56796B33" name="GUID-302CBDBC-3A81-415F-86B0-86BB56796B33"></a><h3 id="NLSPG-GUID-302CBDBC-3A81-415F-86B0-86BB56796B33" class="sect3"><span class="enumeration_section">7.4</span>使用Unicode进行Pro * C / C ++编程</h3>
               <div>
                  <p>Pro * C / C ++提供了以下方法在数据库中插入或检索Unicode数据：</p>
                  <ul style="list-style-type:disc">
                     <li>
                        <p>使用<code class="codeph">VARCHAR</code> Pro * C / C ++数据类型或本机C / C ++ <code class="codeph">text</code>数据类型，程序可以访问存储在UTF8或AL32UTF8数据库的SQL <code class="codeph">CHAR</code>数据类型中的Unicode数据。或者，程序可以使用C / C ++本机<code class="codeph">text</code>类型。
                        </p>
                     </li>
                     <li>
                        <p>使用<code class="codeph">UVARCHAR</code> Pro * C / C ++数据类型或本机C / C ++ <code class="codeph">utext</code>数据类型，程序可以访问存储在数据库的<code class="codeph">NCHAR</code>数据类型中的Unicode数据。
                        </p>
                     </li>
                     <li>
                        <p>使用<code class="codeph">NVARCHAR</code> Pro * C / C ++数据类型，程序可以访问存储在<code class="codeph">NCHAR</code>数据类型中的Unicode数据。Pro * C / C ++程序中<code class="codeph">UVARCHAR</code>和<code class="codeph">NVARCHAR</code>之间的区别在于， <code class="codeph">UVARCHAR</code>数据类型的数据存储在<code class="codeph">utext</code>缓冲区中，而<code class="codeph">NVARCHAR</code>数据类型的数据存储在<code class="codeph">text</code>数据类型中。
                        </p>
                     </li>
                  </ul>
                  <p>Pro * C / C ++不使用用于SQL文本的Unicode OCI API。因此，嵌入式SQL文本必须以<code class="codeph">NLS_LANG</code>环境变量中指定的字符集进行编码。
                  </p>
                  <p>本节包含以下主题：</p>
                  <ul style="list-style-type:disc">
                     <li>
                        <p><a href="programming-with-unicode.html#GUID-BF774CCE-4DD8-4B99-8EBA-16FFFD8BA899">Unicode中的Pro * C / C ++数据转换</a></p>
                     </li>
                     <li>
                        <p><a href="programming-with-unicode.html#GUID-FE00BA33-A634-4962-92ED-F7A07EAD6D52">在Pro * C / C ++中使用VARCHAR数据类型</a></p>
                     </li>
                     <li>
                        <p><a href="programming-with-unicode.html#GUID-A7B21202-ED68-47A3-8C5C-4C3AB7008C8E">在Pro * C / C ++中使用NVARCHAR数据类型</a></p>
                     </li>
                     <li>
                        <p><a href="programming-with-unicode.html#GUID-386C60EE-7DAA-47DC-91C8-6905F5255733">在Pro * C / C ++中使用UVARCHAR数据类型</a></p>
                     </li>
                  </ul>
               </div><a id="NLSPG810"></a><a id="NLSPG356"></a><div class="props_rev_3"><a id="GUID-BF774CCE-4DD8-4B99-8EBA-16FFFD8BA899" name="GUID-BF774CCE-4DD8-4B99-8EBA-16FFFD8BA899"></a><h4 id="NLSPG-GUID-BF774CCE-4DD8-4B99-8EBA-16FFFD8BA899" class="sect4"><span class="enumeration_section">7.4.1</span> Unicode中的Pro * C / C ++数据转换</h4>
                  <div>
                     <p>数据<a id="d59478e4306" class="indexterm-anchor"></a><a id="d59478e4310" class="indexterm-anchor"></a>转换发生在OCI层，但是Pro * C / C ++预处理器指示OCI应根据Pro * C / C ++程序中使用的数据类型采用哪个转换路径。下表显示了转换路径。
                     </p>
                     <div class="tblformalwide" id="GUID-BF774CCE-4DD8-4B99-8EBA-16FFFD8BA899__G1010270">
                        <p class="titleintable">表7-4 Pro * C / C ++绑定和定义数据转换</p>
                        <table cellpadding="4" cellspacing="0" class="FormalWide" title="Pro * C / C ++绑定和定义数据转换" width="100%" border="1" summary="This table describes Pro*C/C++ conversion paths." frame="hsides" rules="rows">
                           <thead>
                              <tr align="left" valign="top">
                                 <th align="left" valign="bottom" id="d59478e4326">Pro * C / C ++数据类型</th>
                                 <th align="left" valign="bottom" id="d59478e4329">SQL数据类型</th>
                                 <th align="left" valign="bottom" id="d59478e4332">转换路径</th>
                              </tr>
                           </thead>
                           <tbody>
                              <tr align="left" valign="top">
                                 <td align="left" valign="top" id="d59478e4337" headers="d59478e4326 ">
                                    <p><code class="codeph">VARCHAR</code>或<code class="codeph">text</code></p>
                                 </td>
                                 <td align="left" valign="top" headers="d59478e4337 d59478e4329 ">
                                    <p><code class="codeph">CHAR</code></p>
                                 </td>
                                 <td align="left" valign="top" headers="d59478e4337 d59478e4332 ">
                                    <p>与数据库字符集之间的<code class="codeph">NLS_LANG</code>字符集在OCI中发生</p>
                                 </td>
                              </tr>
                              <tr align="left" valign="top">
                                 <td align="left" valign="top" id="d59478e4354" headers="d59478e4326 ">
                                    <p><code class="codeph">VARCHAR</code>或<code class="codeph">text</code></p>
                                 </td>
                                 <td align="left" valign="top" headers="d59478e4354 d59478e4329 ">
                                    <p><code class="codeph">NCHAR</code></p>
                                 </td>
                                 <td align="left" valign="top" headers="d59478e4354 d59478e4332 ">
                                    <p>在OCI中发生与数据库字符集之间的<code class="codeph">NLS_LANG</code>字符集</p>
                                    <p>数字服务器中出现了与国家字符集相关的数据库字符集</p>
                                 </td>
                              </tr>
                              <tr align="left" valign="top">
                                 <td align="left" valign="top" id="d59478e4373" headers="d59478e4326 ">
                                    <p><code class="codeph">NVARCHAR</code></p>
                                 </td>
                                 <td align="left" valign="top" headers="d59478e4373 d59478e4329 ">
                                    <p><code class="codeph">NCHAR</code></p>
                                 </td>
                                 <td align="left" valign="top" headers="d59478e4373 d59478e4332 ">
                                    <p><code class="codeph">NLS_LANG</code>字符集在国际字符集中的设置发生在OCI中</p>
                                 </td>
                              </tr>
                              <tr align="left" valign="top">
                                 <td align="left" valign="top" id="d59478e4387" headers="d59478e4326 ">
                                    <p><code class="codeph">NVARCHAR</code></p>
                                 </td>
                                 <td align="left" valign="top" headers="d59478e4387 d59478e4329 ">
                                    <p><code class="codeph">CHAR</code></p>
                                 </td>
                                 <td align="left" valign="top" headers="d59478e4387 d59478e4332 ">
                                    <p><code class="codeph">NLS_LANG</code>字符集在国际字符集中的设置发生在OCI中</p>
                                    <p>数据库服务器中的数据库字符集的国家字符集</p>
                                 </td>
                              </tr>
                              <tr align="left" valign="top">
                                 <td align="left" valign="top" id="d59478e4403" headers="d59478e4326 ">
                                    <p><code class="codeph">UVARCHAR</code>或<code class="codeph">utext</code></p>
                                 </td>
                                 <td align="left" valign="top" headers="d59478e4403 d59478e4329 ">
                                    <p><code class="codeph">NCHAR</code></p>
                                 </td>
                                 <td align="left" valign="top" headers="d59478e4403 d59478e4332 ">
                                    <p>国家字符集中的UTF-16发生在OCI中</p>
                                 </td>
                              </tr>
                              <tr align="left" valign="top">
                                 <td align="left" valign="top" id="d59478e4418" headers="d59478e4326 ">
                                    <p><code class="codeph">UVARCHAR</code>或<code class="codeph">utext</code></p>
                                 </td>
                                 <td align="left" valign="top" headers="d59478e4418 d59478e4329 ">
                                    <p><code class="codeph">CHAR</code></p>
                                 </td>
                                 <td align="left" valign="top" headers="d59478e4418 d59478e4332 ">
                                    <p>国家字符集的UTF-16发生在OCI中</p>
                                    <p>数据库字符集的国家字符集发生在数据库服务器中</p>
                                 </td>
                              </tr>
                           </tbody>
                        </table>
                     </div>
                     <!-- class="inftblhruleinformal" -->
                  </div>
               </div><a id="NLSPG357"></a><div class="props_rev_3"><a id="GUID-FE00BA33-A634-4962-92ED-F7A07EAD6D52" name="GUID-FE00BA33-A634-4962-92ED-F7A07EAD6D52"></a><h4 id="NLSPG-GUID-FE00BA33-A634-4962-92ED-F7A07EAD6D52" class="sect4"><span class="enumeration_section">7.4.2</span>在Pro * C / C ++中使用VARCHAR数据类型</h4>
                  <div>
                     <div class="section">
                        <p>Pro * C / C ++ <code class="codeph">VARCHAR</code>数据类型是<a id="d59478e4512" class="indexterm-anchor"></a><a id="d59478e4516" class="indexterm-anchor"></a>预处理到具有<code class="codeph">length</code>字段和<code class="codeph">text</code>缓冲区字段的结构。以下示例使用C / C ++ <code class="codeph">text</code>本机数据类型和<code class="codeph">VARCHAR</code> Pro * C / C ++数据类型来绑定和定义表列。
                        </p><pre class="oac_no_warn" dir="ltr">#include &lt;sqlca.h&gt; main（）{.../ *更改为STRING数据类型：* / EXEC ORACLE OPTION（CHAR_MAP = STRING）;文字ename [20]; / * unsigned short type * / varchar address [50]; / * Pro * C / C ++ varchar类型* / EXEC SQL SELECT ename，地址INTO：ename，：address FROM emp; / * ename以NULL结尾* / printf（L“ENAME =％s，ADDRESS =％。* s \ n”，ename，address.len，address.arr）; ...}</pre><p>在Pro * C / C ++程序中使用<code class="codeph">VARCHAR</code>数据类型或本机<code class="codeph">text</code>数据类型时，预处理器假定程序打算访问SQL <code class="codeph">CHAR</code>数据类型的列而不是数据库中的SQL <code class="codeph">NCHAR</code>数据类型。预处理器生成C / C ++代码，通过使用<code class="codeph">OCI_ATTR_CHARSET_FORM</code>属性的<code class="codeph">SQLCS_IMPLICIT</code>值进行绑定或定义来反映这一事实。因此，如果绑定或定义变量绑定到数据库中的SQL <code class="codeph">NCHAR</code>数据类型列，则在数据库服务器中进行隐式转换，以将数据从数据库字符集转换为国家数据库字符集，反之亦然。在转换期间，当数据库字符集小于国家字符集时，会发生数据丢失。
                        </p>
                     </div>
                     <!-- class="section" -->
                  </div>
               </div><a id="NLSPG358"></a><div class="props_rev_3"><a id="GUID-A7B21202-ED68-47A3-8C5C-4C3AB7008C8E" name="GUID-A7B21202-ED68-47A3-8C5C-4C3AB7008C8E"></a><h4 id="NLSPG-GUID-A7B21202-ED68-47A3-8C5C-4C3AB7008C8E" class="sect4"><span class="enumeration_section">7.4.3</span>在Pro * C / C ++中使用NVARCHAR数据类型</h4>
                  <div>
                     <p>该<a id="d59478e4635" class="indexterm-anchor"></a><a id="d59478e4639" class="indexterm-anchor"></a> Pro * C / C ++ <code class="codeph">NVARCHAR</code>数据类型类似于Pro * C / C ++ <code class="codeph">VARCHAR</code>数据类型。它应该用于访问数据库中的SQL <code class="codeph">NCHAR</code>数据类型。它告诉Pro * C / C ++预处理器将文本缓冲区绑定或定义到SQL <code class="codeph">NCHAR</code>数据类型的列。预处理器指定<code class="codeph">SQLCS_NCHAR</code>为值<code class="codeph">OCI_ATTR_CHARSET_FORM</code>绑定的属性或定义变量。因此，数据库中不会发生隐式转换。
                     </p>
                     <p>如果<code class="codeph">NVARCHAR</code>缓冲区绑定了SQL <code class="codeph">CHAR</code>数据类型的列，则<code class="codeph">NVARCHAR</code>缓冲区中的数据（以<code class="codeph">NLS_LANG</code>字符集编码）将转换为OCI中的国家字符集或从中转换为国家字符集，然后将数据转换为数据库数据库服务器中的字符集。当<code class="codeph">NLS_LANG</code>字符集的集合大于数据库字符集时，数据可能会丢失。
                     </p>
                  </div>
               </div><a id="NLSPG359"></a><div class="props_rev_3"><a id="GUID-386C60EE-7DAA-47DC-91C8-6905F5255733" name="GUID-386C60EE-7DAA-47DC-91C8-6905F5255733"></a><h4 id="NLSPG-GUID-386C60EE-7DAA-47DC-91C8-6905F5255733" class="sect4"><span class="enumeration_section">7.4.4</span>在Pro * C / C ++中使用UVARCHAR数据类型</h4>
                  <div>
                     <p><code class="codeph">UVARCHAR</code>数据类型预处理到具有<code class="codeph">length</code>字段和<code class="codeph">utext</code>缓冲区字段的结构。以下示例代码包含两个主机变量： <code class="codeph">ename</code>和<code class="codeph">address</code> 。<code class="codeph">ename</code>宿主变量声明为包含20个Unicode字符的<code class="codeph">utext</code>缓冲区。<code class="codeph">address</code>主机变量声明为包含50个Unicode字符的<code class="codeph">uvarchar</code>缓冲区。<code class="codeph">len</code>和<code class="codeph">arr</code>字段可作为结构的字段访问。
                     </p><pre class="oac_no_warn" dir="ltr">#include &lt;sqlca.h&gt; #include &lt;sqlucs2.h&gt; main（）{.../ *更改为STRING数据类型* / EXEC ORACLE OPTION（CHAR_MAP = STRING）; utext ename [20]; / * unsigned short type * / uvarchar address [50]; / * Pro * C / C ++ uvarchar类型* / EXEC SQL SELECT ename，地址INTO：ename，：address FROM emp; / * ename是以NULL结尾的* / wprintf（L“ENAME =％s，ADDRESS =％。* s \ n”，ename，address.len，address.arr）; ...}</pre><p>在Pro * C / C ++程序中使用<code class="codeph">UVARCHAR</code>数据类型或本机<code class="codeph">utext</code>数据类型时，预处理器假定程序打算访问SQL <code class="codeph">NCHAR</code>数据类型。预处理器通过结合或使用定义生成C / C ++代码<code class="codeph">SQLCS_NCHAR</code>为值<code class="codeph">OCI_ATTR_CHARSET_FORM</code>属性。因此，如果绑定或定义变量绑定到SQL <code class="codeph">NCHAR</code>数据类型的列，则数据库服务器中将发生数字与国家字符集的隐式转换。但是，在此方案中没有数据丢失，因为国家字符集总是比数据库字符集更大的集合。
                     </p>
                  </div>
               </div>
            </div><a id="NLSPG0076"></a><div class="props_rev_3"><a id="GUID-39A80CED-25E1-416B-8723-267A504599C0" name="GUID-39A80CED-25E1-416B-8723-267A504599C0"></a><h3 id="NLSPG-GUID-39A80CED-25E1-416B-8723-267A504599C0" class="sect3"><span class="enumeration_section">7.5</span>使用Unicode进行JDBC编程</h3>
               <div>
                  <p>Oracle提供以下内容<a id="d59478e4885" class="indexterm-anchor"></a><a id="d59478e4889" class="indexterm-anchor"></a> Java程序的JDBC驱动程序，用于访问Oracle数据库中的字符数据：</p>
                  <ul style="list-style-type:disc">
                     <li>
                        <p>JDBC OCI驱动程序</p>
                     </li>
                     <li>
                        <p>JDBC瘦驱动程序</p>
                     </li>
                     <li>
                        <p>JDBC服务器端内部驱动程序</p>
                     </li>
                     <li>
                        <p>JDBC服务器端瘦驱动程序</p>
                     </li>
                  </ul>
                  <p>Java程序可以在SQL <code class="codeph">CHAR</code>和<code class="codeph">NCHAR</code>数据类型的列中插入或检索字符数据。具体来说，JDBC使Java程序能够将Java字符串绑定或定义为SQL <code class="codeph">CHAR</code>和<code class="codeph">NCHAR</code>数据类型。由于Java的<code class="codeph">string</code>数据类型是UTF-16编码，因此从数据库中检索或插入的数据必须从UTF-16转换为数据库字符集或国家字符集，反之亦然。JDBC还允许您在Java字符串中指定PL / SQL和SQL语句，以便可以使用任何非ASCII模式对象名称和字符串文字。
                  </p>
                  <p>在数据库连接时，JDBC将服务器<code class="codeph">NLS_LANGUAGE</code>和<code class="codeph">NLS_TERRITORY</code>参数设置为与运行JDBC驱动程序的Java VM的语言环境相对应。此操作可确保服务器和Java客户端使用相同的语言进行通信。因此，从服务器返回的Oracle错误消息使用与客户端区域设置相同的语言。
                  </p>
                  <p>本节包含以下主题：</p>
                  <ul style="list-style-type:disc">
                     <li>
                        <p><a href="programming-with-unicode.html#GUID-76F911E3-904B-4DE4-92DD-8935EBED166D">将Java字符串绑定和定义为SQL CHAR数据类型</a></p>
                     </li>
                     <li>
                        <p><a href="programming-with-unicode.html#GUID-64E5E6BD-E65E-4C1F-81D4-9E3D052CED38">将Java字符串绑定和定义为SQL NCHAR数据类型</a></p>
                     </li>
                     <li>
                        <p><a href="programming-with-unicode.html#GUID-1C0A42B0-11F8-405B-98A9-18804C681B88">在不更改代码的情况下使用SQL NCHAR数据类型</a></p>
                     </li>
                     <li>
                        <p><a href="programming-with-unicode.html#GUID-447077D7-C7B0-4C2E-94A3-6C986DF99497">在JDBC中使用SQL NCHAR字符串文字</a></p>
                     </li>
                     <li>
                        <p><a href="programming-with-unicode.html#GUID-AA384DD0-E46C-477E-826F-F43A099BD651">JDBC中的数据转换</a></p>
                     </li>
                     <li>
                        <p><a href="programming-with-unicode.html#GUID-ACAD6716-4F54-47FA-9659-7BE7CBF67786">使用oracle.sql。Oracle对象类型中的CHAR</a></p>
                     </li>
                     <li>
                        <p><a href="programming-with-unicode.html#GUID-DDF4AED1-D62F-4CD7-9FCE-0A9FC6B2D74C">使用JDBC访问SQL CHAR数据的限制</a></p>
                     </li>
                  </ul>
               </div><a id="NLSPG360"></a><div class="props_rev_3"><a id="GUID-76F911E3-904B-4DE4-92DD-8935EBED166D" name="GUID-76F911E3-904B-4DE4-92DD-8935EBED166D"></a><h4 id="NLSPG-GUID-76F911E3-904B-4DE4-92DD-8935EBED166D" class="sect4"><span class="enumeration_section">7.5.1</span>将Java字符串绑定和定义为SQL CHAR数据类型</h4>
                  <div>
                     <p>Oracle JDBC <a id="d59478e5044" class="indexterm-anchor"></a><a id="d59478e5048" class="indexterm-anchor"></a>驱动程序允许您使用Java字符串绑定或定义变量来访问数据库中的SQL <code class="codeph">CHAR</code>数据类型。以下代码说明了如何将Java字符串绑定到<code class="codeph">CHAR</code>列。
                     </p><pre class="oac_no_warn" dir="ltr">int employee_id = 12345; String last_name =“Joe”; PreparedStatement pstmt = conn.prepareStatement（“INSERT INTO”+“employees（last_name，employee_id）VALUES（？，？）“）; pstmt.setString（1，last_name）; pstmt.setInt（2，employee_id）; pstmt.execute（）; / *执行以插入第一行* / employee_id + = 1; / *下一个员工编号* / last_name =“\ uFF2A \ uFF4F \ uFF45”; / *名称中的Unicode字符* / pstmt.setString（1，last_name）; pstmt.setInt（2，employee_id）; pstmt.execute（）; / *执行以插入第二行* /</pre><p>您可以通过指定其数据类型和长度来定义目标SQL列。使用数据类型和长度定义SQL <code class="codeph">CHAR</code>列时，JDBC使用此信息来优化从列中获取SQL <code class="codeph">CHAR</code>数据的性能。以下是定义SQL <code class="codeph">CHAR</code>列的示例。
                     </p><pre class="oac_no_warn" dir="ltr">OraclePreparedStatement pstmt =（OraclePreparedStatement）conn.prepareStatement（“SELECT ename，empno from emp”）; pstmt.defineColumnType（1，类型。VARCHAR，3）; pstmt.defineColumnType（2，类型。整数）; ResultSet rest = pstmt.executeQuery（）; String name = rset.getString（1）; int id = reset.getInt（2）;</pre><p>您必须将<code class="codeph">PreparedStatement</code> <code class="codeph">OraclePreparedStatement</code>转换为<code class="codeph">OraclePreparedStatement</code>以调用<code class="codeph">defineColumnType()</code> 。<code class="codeph">defineColumnType()</code>的第二个参数是目标SQL列的数据类型。第三个参数是字符数的长度。
                     </p>
                  </div>
               </div><a id="NLSPG361"></a><div class="props_rev_3"><a id="GUID-64E5E6BD-E65E-4C1F-81D4-9E3D052CED38" name="GUID-64E5E6BD-E65E-4C1F-81D4-9E3D052CED38"></a><h4 id="NLSPG-GUID-64E5E6BD-E65E-4C1F-81D4-9E3D052CED38" class="sect4"><span class="enumeration_section">7.5.2</span>将Java字符串绑定和定义为SQL NCHAR数据类型</h4>
                  <div>
                     <p>为了将Java字符串变量绑定或定义为SQL <code class="codeph">NCHAR</code>数据类型，Oracle提供了一个扩展的<code class="codeph">PreparedStatement</code> ，它具有<code class="codeph">setFormOfUse()</code>方法，通过该方法可以将绑定变量的目标列显式指定为SQL <code class="codeph">NCHAR</code>数据类型。以下代码说明了如何将Java字符串绑定到<code class="codeph">NCHAR</code>列。
                     </p><pre class="oac_no_warn" dir="ltr">int employee_id = 12345; String last_name =“Joe”oracle.jdbc。OraclePreparedStatement pstmt =（oracle.jdbc。OraclePreparedStatement）conn.prepareStatement（“INSERT INTO employees（last_name，employee_id）VALUES（？，？）“）; pstmt.setFormOfUse（1，oracle.jdbc。OraclePreparedStatement。FORM_NCHAR）; pstmt.setString（1，last_name）; pstmt.setInt（2，employee_id）; pstmt.execute（）; / *执行插入第一行* / employee_id + = 1; / *下一个员工编号* / last_name =“\ uFF2A \ uFF4F \ uFF45”; / *名称中的Unicode字符* / pstmt.setString（1，last_name）; pstmt.setInt（2，employee_id）; pstmt.execute（）; / *执行插入第二行* /</pre><p>您可以通过指定目标SQL <code class="codeph">NCHAR</code>列的数据类型，使用形式和长度来定义它们。JDBC使用此信息来优化从这些列中获取SQL <code class="codeph">NCHAR</code>数据的性能。以下是定义SQL <code class="codeph">NCHAR</code>列的示例。
                     </p><pre class="oac_no_warn" dir="ltr">OraclePreparedStatement pstmt =（OraclePreparedStatement）conn.prepareStatement（“SELECT ename，empno from emp”）; pstmt.defineColumnType（1，类型。VARCHAR，3，OraclePreparedStatement。FORM_NCHAR）; pstmt.defineColumnType（2，类型。整数）; ResultSet rest = pstmt.executeQuery（）; String name = rset.getString（1）; int id = reset.getInt（2）;</pre><p>要定义SQL <code class="codeph">NCHAR</code>列，必须指定与第一个参数中的SQL <code class="codeph">CHAR</code>列等效的数据类型，第二个参数中的字符数的长度以及<code class="codeph">defineColumnType()</code>的第四个参数中的使用形式。
                     </p>
                     <p>您可以绑定或定义针对<code class="codeph">NCHAR</code>列的Java字符串，而无需显式指定use参数的形式。这意味着以下内容：</p>
                     <ul style="list-style-type:disc">
                        <li>
                           <p>如果未在<code class="codeph">setString()</code>方法中指定参数，则JDBC假定bind或define变量用于SQL <code class="codeph">CHAR</code>列。因此，它会尝试将它们转换为数据库字符集。当数据到达数据库时，数据库隐式地将数据库字符集中的数据转换为国家字符集。在此转换期间，当数据库字符集是国家字符集的子集时，数据可能会丢失。由于国家字符集是UTF8或AL16UTF16，如果数据库字符集不是UTF8或AL32UTF8，则会发生数据丢失。
                           </p>
                        </li>
                        <li>
                           <p>由于在数据库中发生从SQL <code class="codeph">CHAR</code>到SQL <code class="codeph">NCHAR</code>数据类型的隐式转换，因此数据库性能会降低。
                           </p>
                        </li>
                     </ul>
                     <p>此外，如果为SQL <code class="codeph">CHAR</code>数据类型的列绑定或定义Java字符串，但指定了use参数的形式，则数据库的性能会降低。但是，数据不应丢失，因为国家字符集总是比数据库字符集更大的集合。
                     </p>
                  </div><a id="NLSPG978"></a><div class="props_rev_3"><a id="GUID-389D66B5-0693-41E9-848D-2842E84EE315" name="GUID-389D66B5-0693-41E9-848D-2842E84EE315"></a><h5 id="NLSPG-GUID-389D66B5-0693-41E9-848D-2842E84EE315" class="sect5"><span class="enumeration_section">7.5.2.1</span> NCHAR数据类型的新JDBC4.0方法</h5>
                     <div>
                        <p>JDBC 11.1增加了对新JDBC 4.0（JDK6）SQL数据类型<code class="codeph">NCHAR</code> ， <code class="codeph">NVARCHAR</code> ， <code class="codeph">LONGNVARCHAR</code>和<code class="codeph">NCLOB</code> 。要检索国家字符值，应用程序可以调用以下方法之一：</p>
                        <ul style="list-style-type:disc">
                           <li>
                              <p><code class="codeph">getNString</code></p>
                           </li>
                           <li>
                              <p><code class="codeph">getNClob</code></p>
                           </li>
                           <li>
                              <p><code class="codeph">getNCharacterStream</code></p>
                           </li>
                        </ul>
                        <p><code class="codeph">getNClob</code>方法验证检索到的值确实是<code class="codeph">NCLOB</code> 。否则，这些方法等同于没有字母<code class="codeph">N</code>相应方法。</p>
                        <p>要为国家字符类型的参数标记指定值，应用程序可以调用以下方法之一：</p>
                        <ul style="list-style-type:disc">
                           <li>
                              <p><code class="codeph">setNString</code></p>
                           </li>
                           <li>
                              <p><code class="codeph">setNCharacterStream</code></p>
                           </li>
                           <li>
                              <p><code class="codeph">setNClob</code></p>
                           </li>
                        </ul>
                        <p>这些方法等同于相应的方法，而字母<code class="codeph">N</code>前面没有调用<code class="codeph">setFormOfUse(..., OraclePreparedStatement.FORM_NCHAR)</code> 。
                        </p>
                        <div class="infoboxnotealso" id="GUID-389D66B5-0693-41E9-848D-2842E84EE315__GUID-E69E9B6F-D2F1-4154-AC80-9E9D8DE935D4">
                           <p class="notep1">也可以看看：</p>
                           <p>有关更多信息，请<a href="../jjdbc/globalization-support.html#JJDBC28647" target="_blank"><span class="italic">参见Oracle数据库JDBC开发人员指南</span></a></p>
                        </div>
                     </div>
                  </div>
               </div><a id="NLSPG362"></a><div class="props_rev_3"><a id="GUID-1C0A42B0-11F8-405B-98A9-18804C681B88" name="GUID-1C0A42B0-11F8-405B-98A9-18804C681B88"></a><h4 id="NLSPG-GUID-1C0A42B0-11F8-405B-98A9-18804C681B88" class="sect4"><span class="enumeration_section">7.5.3</span>在不更改代码的情况下使用SQL NCHAR数据类型</h4>
                  <div>
                     <p>Oracle JDBC驱动程序中引入了Java系统属性，以便客户判断是否应在Java应用程序中默认指定use参数的形式。此属性具有以下用途：</p>
                     <ul style="list-style-type:disc">
                        <li>
                           <p>可以迁移访问SQL <code class="codeph">CHAR</code>数据类型的现有应用程序，以支持全球部署的SQL <code class="codeph">NCHAR</code>数据类型，而无需更改代码行。
                           </p>
                        </li>
                        <li>
                           <p>在绑定和定义SQL <code class="codeph">NCHAR</code>列时，应用程序不需要调用<code class="codeph">setFormOfUse()</code>方法。应用程序代码可以保持中立，并且与后端数据库中使用的数据类型无关。使用此属性集，可以轻松地使用SQL <code class="codeph">CHAR</code>或SQL <code class="codeph">NCHAR</code>切换应用程序。</p>
                        </li>
                     </ul>
                     <p>Java系统属性在调用Java应用程序的命令行中指定。指定此标志的语法如下：</p><pre class="oac_no_warn" dir="ltr">java -Doracle.jdbc.defaultNChar = true &lt;application class&gt;</pre><p>通过指定此属性，Oracle JDBC驱动程序假定在应用程序中存在所有绑定和定义操作的use参数形式。</p>
                     <p>如果您具有包含SQL <code class="codeph">CHAR</code>和SQL <code class="codeph">NCHAR</code>列的数据库模式，那么在访问SQL <code class="codeph">CHAR</code>列时，由于在数据库服务器中进行了隐式转换，因此使用此标志可能会对性能产生一些影响。
                     </p>
                     <div class="infoboxnotealso" id="GUID-1C0A42B0-11F8-405B-98A9-18804C681B88__GUID-4FB1CC94-2C35-4D23-87E1-1773F402D47A">
                        <p class="notep1">也可以看看：</p>
                        <p><span class="q">“ <a href="programming-with-unicode.html#GUID-AA384DD0-E46C-477E-826F-F43A099BD651">JDBC中的数据转换</a> ”</span> ，以获取有关隐式转换对性能影响的更多信息</p>
                     </div>
                  </div>
               </div><a id="NLSPG363"></a><div class="props_rev_3"><a id="GUID-447077D7-C7B0-4C2E-94A3-6C986DF99497" name="GUID-447077D7-C7B0-4C2E-94A3-6C986DF99497"></a><h4 id="NLSPG-GUID-447077D7-C7B0-4C2E-94A3-6C986DF99497" class="sect4"><span class="enumeration_section">7.5.4</span>在JDBC中使用SQL NCHAR字符串文字</h4>
                  <div>
                     <p>在JDBC中使用<code class="codeph">NCHAR</code>字符串文字时，可能会丢失数据，因为在处理之前将字符转换为数据库字符集。有关详细信息，请参阅<span class="q">“ <a href="programming-with-unicode.html#GUID-50BE1BB8-DB5C-43C8-93F2-6FC7E9E3251D">NCHAR字符串文字替换</a> ”</span> 。
                     </p>
                     <p>通过启用属性集<code class="codeph">oracle.jdbc.convertNcharLiterals</code>可以实现保留<code class="codeph">NCHAR</code>字符串文字的所需行为。如果值为true，则启用此选项;否则，它被禁用。默认设置为false。它可以通过两种方式启用：a）作为Java系统属性或b）作为连接属性。启用后，将对VM中的所有SQL（系统属性）或连接（连接属性）执行转换。例如，可以将该属性设置为Java系统属性，如下所示：</p><pre class="oac_no_warn" dir="ltr">java -Doracle.jdbc.convertNcharLiterals =“true”...
</pre><p>或者，您可以将其设置为连接属性，如下所示：</p><pre class="oac_no_warn" dir="ltr">属性props = new Properties（）; ...props.setProperty（“oracle.jdbc.convertNcharLiterals”，“true”）; Connection conn = DriverManager.getConnection（url，props）;</pre><p>如果将其设置为连接属性，则会覆盖系统属性设置。</p>
                  </div>
               </div><a id="NLSPG364"></a><div class="props_rev_3"><a id="GUID-AA384DD0-E46C-477E-826F-F43A099BD651" name="GUID-AA384DD0-E46C-477E-826F-F43A099BD651"></a><h4 id="NLSPG-GUID-AA384DD0-E46C-477E-826F-F43A099BD651" class="sect4"><span class="enumeration_section">7.5.5</span> JDBC中的数据转换</h4>
                  <div>
                     <p>因为<a id="d59478e5668" class="indexterm-anchor"></a><a id="d59478e5672" class="indexterm-anchor"></a><a id="d59478e5676" class="indexterm-anchor"></a> Java字符串始终以UTF-16编码，JDBC驱动程序透明地将数据从数据库字符集转换为UTF-16或国家字符集。JDBC驱动程序采用的转换路径不同：</p>
                     <ul style="list-style-type:disc">
                        <li>
                           <p><a href="programming-with-unicode.html#GUID-51032586-15D4-41F1-9BDA-3559C54A8E32">OCI驱动程序的数据转换</a></p>
                        </li>
                        <li>
                           <p><a href="programming-with-unicode.html#GUID-B53EF51C-5617-4143-ABA1-F8D09C957A9A">瘦驱动程序的数据转换</a></p>
                        </li>
                        <li>
                           <p><a href="programming-with-unicode.html#GUID-D7B7D2C9-6C62-4A82-8C8C-24A02FFC4D47">服务器端内部驱动程序的数据转换</a></p>
                        </li>
                     </ul>
                  </div><a id="NLSPG811"></a><a id="NLSPG365"></a><div class="props_rev_3"><a id="GUID-51032586-15D4-41F1-9BDA-3559C54A8E32" name="GUID-51032586-15D4-41F1-9BDA-3559C54A8E32"></a><h5 id="NLSPG-GUID-51032586-15D4-41F1-9BDA-3559C54A8E32" class="sect5"><span class="enumeration_section">7.5.5.1</span> OCI驱动程序的数据转换</h5>
                     <div>
                        <p>对于OCI驱动程序，在将语句发送到数据库进行处理之前，SQL语句始终由驱动程序转换为数据库字符集。当数据库字符集既不是US7ASCII也不是WE8ISO8859P1时，驱动程序首先在Java中将SQL语句转换为UTF-8，然后在C中转换为数据库字符集。否则，它将SQL语句直接转换为数据库字符集。对于Java字符串绑定变量，下表总结了针对不同方案所采用的转换路径。对于Java字符串定义变量，采用相同的转换路径，但方向相反。</p>
                        <div class="tblformalwide" id="GUID-51032586-15D4-41F1-9BDA-3559C54A8E32__G1010302">
                           <p class="titleintable">表7-5 OCI驱动程序转换路径</p>
                           <table cellpadding="4" cellspacing="0" class="FormalWide" title="OCI驱动程序转换路径" width="100%" border="1" summary="This table summarizes OCI driver conversion paths for various types of SQL statements." frame="hsides" rules="rows">
                              <thead>
                                 <tr align="left" valign="top">
                                    <th align="left" valign="bottom" id="d59478e5789">使用形式</th>
                                    <th align="left" valign="bottom" id="d59478e5792">SQL数据类型</th>
                                    <th align="left" valign="bottom" id="d59478e5795">转换路径</th>
                                 </tr>
                              </thead>
                              <tbody>
                                 <tr align="left" valign="top">
                                    <td align="left" valign="top" id="d59478e5800" headers="d59478e5789 ">
                                       <p><code class="codeph">FORM_CHAR（默认）</code></p>
                                    </td>
                                    <td align="left" valign="top" headers="d59478e5800 d59478e5792 ">
                                       <p><code class="codeph">CHAR</code></p>
                                    </td>
                                    <td align="left" valign="top" headers="d59478e5800 d59478e5795 ">
                                       <p>在Java驱动程序中发生Java字符串的UTF-16编码与数据库字符集之间的转换。</p>
                                    </td>
                                 </tr>
                                 <tr align="left" valign="top">
                                    <td align="left" valign="top" id="d59478e5812" headers="d59478e5789 ">
                                       <p><code class="codeph">FORM_CHAR（默认）</code></p>
                                    </td>
                                    <td align="left" valign="top" headers="d59478e5812 d59478e5792 ">
                                       <p><code class="codeph">NCHAR</code></p>
                                    </td>
                                    <td align="left" valign="top" headers="d59478e5812 d59478e5795 ">
                                       <p>在Java驱动程序中发生Java字符串的UTF-16编码与数据库字符集之间的转换。然后，数据库字符集和国家字符集之间的转换发生在数据库服务器中。</p>
                                    </td>
                                 </tr>
                                 <tr align="left" valign="top">
                                    <td align="left" valign="top" id="d59478e5824" headers="d59478e5789 ">
                                       <p><code class="codeph">FORM_NCHAR</code></p>
                                    </td>
                                    <td align="left" valign="top" headers="d59478e5824 d59478e5792 ">
                                       <p><code class="codeph">NCHAR</code></p>
                                    </td>
                                    <td align="left" valign="top" headers="d59478e5824 d59478e5795 ">
                                       <p>Java字符串的UTF-16编码与国家字符集之间的转换发生在JDBC驱动程序中。</p>
                                    </td>
                                 </tr>
                                 <tr align="left" valign="top">
                                    <td align="left" valign="top" id="d59478e5836" headers="d59478e5789 ">
                                       <p><code class="codeph">FORM_NCHAR</code></p>
                                    </td>
                                    <td align="left" valign="top" headers="d59478e5836 d59478e5792 ">
                                       <p><code class="codeph">CHAR</code></p>
                                    </td>
                                    <td align="left" valign="top" headers="d59478e5836 d59478e5795 ">
                                       <p>Java字符串的UTF-16编码与国家字符集之间的转换发生在JDBC驱动程序中。然后，在数据库服务器中发生国家字符集和数据库字符集之间的转换。</p>
                                    </td>
                                 </tr>
                              </tbody>
                           </table>
                        </div>
                        <!-- class="inftblhruleinformal" -->
                     </div>
                  </div><a id="NLSPG812"></a><a id="NLSPG366"></a><div class="props_rev_3"><a id="GUID-B53EF51C-5617-4143-ABA1-F8D09C957A9A" name="GUID-B53EF51C-5617-4143-ABA1-F8D09C957A9A"></a><h5 id="NLSPG-GUID-B53EF51C-5617-4143-ABA1-F8D09C957A9A" class="sect5"><span class="enumeration_section">7.5.5.2</span>瘦驱动程序的数据转换</h5>
                     <div>
                        <p>在将语句发送到数据库进行处理之前，SQL语句始终由驱动程序转换为数据库字符集或UTF-8。当数据库字符集是以下字符集之一时，驱动程序将SQL语句转换为数据库字符集：</p>
                        <ul style="list-style-type:disc">
                           <li>
                              <p>US7ASCII</p>
                           </li>
                           <li>
                              <p>WE8ISO8859P1</p>
                           </li>
                           <li>
                              <p>WE8DEC</p>
                           </li>
                           <li>
                              <p>WE8MSWIN1252</p>
                           </li>
                        </ul>
                        <p>否则，驱动程序将SQL语句转换为UTF-8，并在处理之前通知数据库该语句需要进一步转换。反过来，数据库将SQL语句转换为数据库字符集。对于Java字符串绑定变量，下表中显示的转换路径是针对瘦驱动程序进行的。对于Java字符串定义变量，采用相同的转换路径，但方向相反。前面列出的四个字符集在表中称为<span class="bold">选定</span> <span class="bold">字符</span> <span class="bold">集</span> 。
                        </p>
                        <div class="tblformalwide" id="GUID-B53EF51C-5617-4143-ABA1-F8D09C957A9A__G1010326">
                           <p class="titleintable">表7-6瘦驱动程序转换路径</p>
                           <table cellpadding="4" cellspacing="0" class="FormalWide" title="瘦驱动程序转换路径" width="100%" border="1" summary="This table describes the conversion path for thin drivers. " frame="hsides" rules="rows">
                              <thead>
                                 <tr align="left" valign="top">
                                    <th align="left" valign="bottom" id="d59478e5964">使用形式</th>
                                    <th align="left" valign="bottom" id="d59478e5967">SQL数据类型</th>
                                    <th align="left" valign="bottom" id="d59478e5970">数据库字符集</th>
                                    <th align="left" valign="bottom" id="d59478e5973">转换路径</th>
                                 </tr>
                              </thead>
                              <tbody>
                                 <tr align="left" valign="top">
                                    <td align="left" valign="top" id="d59478e5978" headers="d59478e5964 ">
                                       <p><code class="codeph">FORM_CHAR（默认）</code></p>
                                    </td>
                                    <td align="left" valign="top" headers="d59478e5978 d59478e5967 ">
                                       <p><code class="codeph">CHAR</code></p>
                                    </td>
                                    <td align="left" valign="top" headers="d59478e5978 d59478e5970 ">
                                       <p>其中一个选定的字符集</p>
                                    </td>
                                    <td align="left" valign="top" headers="d59478e5978 d59478e5973 ">
                                       <p>Java驱动程序的UTF-16编码与数据库字符集之间的转换发生在瘦驱动程序中。</p>
                                    </td>
                                 </tr>
                                 <tr align="left" valign="top">
                                    <td align="left" valign="top" id="d59478e5993" headers="d59478e5964 ">
                                       <p><code class="codeph">FORM_CHAR（默认）</code></p>
                                    </td>
                                    <td align="left" valign="top" headers="d59478e5993 d59478e5967 ">
                                       <p><code class="codeph">NCHAR</code></p>
                                    </td>
                                    <td align="left" valign="top" headers="d59478e5993 d59478e5970 ">
                                       <p>其中一个选定的字符集</p>
                                    </td>
                                    <td align="left" valign="top" headers="d59478e5993 d59478e5973 ">
                                       <p>Java驱动程序的UTF-16编码与数据库字符集之间的转换发生在瘦驱动程序中。然后，数据库字符集和国家字符集之间的转换发生在数据库服务器中。</p>
                                    </td>
                                 </tr>
                                 <tr align="left" valign="top">
                                    <td align="left" valign="top" id="d59478e6008" headers="d59478e5964 ">
                                       <p><code class="codeph">FORM_CHAR（默认）</code></p>
                                    </td>
                                    <td align="left" valign="top" headers="d59478e6008 d59478e5967 ">
                                       <p><code class="codeph">CHAR</code></p>
                                    </td>
                                    <td align="left" valign="top" headers="d59478e6008 d59478e5970 ">
                                       <p>除了选定的字符集</p>
                                    </td>
                                    <td align="left" valign="top" headers="d59478e6008 d59478e5973 ">
                                       <p>Java串的UTF-16编码与UTF-8之间的转换发生在瘦驱动程序中。然后，UTF-8和数据库字符集之间的转换发生在数据库服务器中。</p>
                                    </td>
                                 </tr>
                                 <tr align="left" valign="top">
                                    <td align="left" valign="top" id="d59478e6023" headers="d59478e5964 ">
                                       <p><code class="codeph">FORM_CHAR（默认）</code></p>
                                    </td>
                                    <td align="left" valign="top" headers="d59478e6023 d59478e5967 ">
                                       <p><code class="codeph">NCHAR</code></p>
                                    </td>
                                    <td align="left" valign="top" headers="d59478e6023 d59478e5970 ">
                                       <p>除了选定的字符集</p>
                                    </td>
                                    <td align="left" valign="top" headers="d59478e6023 d59478e5973 ">
                                       <p>Java串的UTF-16编码与UTF-8之间的转换发生在瘦驱动程序中。然后，在数据库服务器中进行从UTF-8到数据库字符集的转换，然后到国家字符集的转换。</p>
                                    </td>
                                 </tr>
                                 <tr align="left" valign="top">
                                    <td align="left" valign="top" id="d59478e6038" headers="d59478e5964 ">
                                       <p><code class="codeph">FORM_NCHAR</code></p>
                                    </td>
                                    <td align="left" valign="top" headers="d59478e6038 d59478e5967 ">
                                       <p><code class="codeph">CHAR</code></p>
                                    </td>
                                    <td align="left" valign="top" headers="d59478e6038 d59478e5970 ">
                                       <p>任何</p>
                                    </td>
                                    <td align="left" valign="top" headers="d59478e6038 d59478e5973 ">
                                       <p>Java字符串的UTF-16编码与国家字符集之间的转换发生在瘦驱动程序中。然后，在数据库服务器中发生国家字符集和数据库字符集之间的转换。</p>
                                    </td>
                                 </tr>
                                 <tr align="left" valign="top">
                                    <td align="left" valign="top" id="d59478e6053" headers="d59478e5964 ">
                                       <p><code class="codeph">FORM_NCHAR</code></p>
                                    </td>
                                    <td align="left" valign="top" headers="d59478e6053 d59478e5967 ">
                                       <p><code class="codeph">NCHAR</code></p>
                                    </td>
                                    <td align="left" valign="top" headers="d59478e6053 d59478e5970 ">
                                       <p>任何</p>
                                    </td>
                                    <td align="left" valign="top" headers="d59478e6053 d59478e5973 ">
                                       <p>Java字符串的UTF-16编码与国家字符集之间的转换发生在瘦驱动程序中。</p>
                                    </td>
                                 </tr>
                              </tbody>
                           </table>
                        </div>
                        <!-- class="inftblhruleinformal" -->
                     </div>
                  </div><a id="NLSPG367"></a><div class="props_rev_3"><a id="GUID-D7B7D2C9-6C62-4A82-8C8C-24A02FFC4D47" name="GUID-D7B7D2C9-6C62-4A82-8C8C-24A02FFC4D47"></a><h5 id="NLSPG-GUID-D7B7D2C9-6C62-4A82-8C8C-24A02FFC4D47" class="sect5"><span class="enumeration_section">7.5.5.3</span>服务器端内部驱动程序的数据转换</h5>
                     <div>
                        <p>所有数据转换都发生在数据库服务器中，因为服务器端内部驱动程序在数据库内部工作。</p>
                     </div>
                  </div>
               </div><a id="NLSPG368"></a><div class="props_rev_3"><a id="GUID-ACAD6716-4F54-47FA-9659-7BE7CBF67786" name="GUID-ACAD6716-4F54-47FA-9659-7BE7CBF67786"></a><h4 id="NLSPG-GUID-ACAD6716-4F54-47FA-9659-7BE7CBF67786" class="sect4"><span class="enumeration_section">7.5.6</span>使用oracle.sql。Oracle对象类型中的CHAR</h4>
                  <div>
                     <p>JDBC驱动程序支持Oracle对象类型。Oracle对象始终作为数据库字符集或国家字符集中表示的对象从数据库发送到客户端。这意味着<span class="q">“ <a href="programming-with-unicode.html#GUID-AA384DD0-E46C-477E-826F-F43A099BD651">JDBC中</a></span>的数据转换<span class="q">”中</span>的数据转换路径不适用于Oracle对象访问。相反， <code class="codeph">oracle.sql.CHAR</code>类用于将对象类型的SQL <code class="codeph">CHAR</code>和SQL <code class="codeph">NCHAR</code>数据从数据库传递到客户端。
                     </p>
                     <p>本节包括以下主题：</p>
                     <ul style="list-style-type:disc">
                        <li>
                           <p><a href="programming-with-unicode.html#GUID-F9C1E4C1-C1F7-411A-A5B4-8748EBF16C0C">oracle.sql。CHAR</a></p>
                        </li>
                        <li>
                           <p><a href="programming-with-unicode.html#GUID-A2C9E2A8-FE6B-441B-98EB-06F41585B4AD">使用oracle.sql访问SQL CHAR和NCHAR属性。CHAR</a></p>
                        </li>
                     </ul>
                  </div><a id="NLSPG369"></a><div class="props_rev_3"><a id="GUID-F9C1E4C1-C1F7-411A-A5B4-8748EBF16C0C" name="GUID-F9C1E4C1-C1F7-411A-A5B4-8748EBF16C0C"></a><h5 id="NLSPG-GUID-F9C1E4C1-C1F7-411A-A5B4-8748EBF16C0C" class="sect5"><span class="enumeration_section">7.5.6.1</span> oracle.sql。CHAR</h5>
                     <div>
                        <p><code class="codeph">oracle.sql.CHAR</code>类具有转换字符数据的特殊功能。Oracle字符集是<code class="codeph">oracle.sql.的关键属性<code class="codeph">oracle.sql.CHAR</code>类。Oracle字符集总是在<code class="codeph">oracle.sql.时传入<code class="codeph">oracle.sql.构造CHAR</code>对象。没有已知的字符集， <code class="codeph">oracle.sql.的数据字节<code class="codeph">oracle.sql.CHAR</code>对象毫无意义。
                        </p>
                        <p><code class="codeph">oracle.sql.CHAR</code>类提供以下方法将字符数据转换为字符串：</p>
                        <ul style="list-style-type:disc">
                           <li>
                              <p><code class="codeph">的getString（）</code></p>
                              <p>转换<code class="codeph">oracle.sql.表示的字符序列<code class="codeph">oracle.sql.CHAR</code>对象为字符串，返回Java字符串对象。如果无法识别字符集，则<code class="codeph">getString()</code>返回<code class="codeph">SQLException</code> 。
                              </p>
                           </li>
                           <li>
                              <p><code class="codeph">的toString（）</code></p>
                              <p>与<code class="codeph">getString()</code>相同，但如果无法识别字符集，则<code class="codeph">toString()</code>将返回<code class="codeph">oracle.sql.的十六进制表示形式<code class="codeph">oracle.sql.CHAR</code>数据并不返回<code class="codeph">SQLException</code> 。
                              </p>
                           </li>
                           <li>
                              <p><code class="codeph">getStringWithReplacement（）</code></p>
                              <p>与<code class="codeph">getString()</code>相同，除了默认替换字符替换此<code class="codeph">oracle.sql.的字符集中没有Unicode表示的字符<code class="codeph">oracle.sql.CHAR</code>对象。此默认字符因字符集而异，但通常是问号。
                              </p>
                           </li>
                        </ul>
                        <p>您可能想要构造一个<code class="codeph">oracle.sql.CHAR</code>对象自己（例如，传入准备好的语句）。构造<code class="codeph">oracle.sql.CHAR</code>对象，必须向<code class="codeph">oracle.sql.提供字符集信息<code class="codeph">oracle.sql.使用<code class="codeph">oracle.sql.的实例的CHAR</code>对象<code class="codeph">oracle.sql.CharacterSet</code>类。<code class="codeph">oracle.sql.每个实例<code class="codeph">oracle.sql.CharacterSet</code>类表示Oracle支持的字符集之一。
                        </p>
                        <p>完成以下任务以构造<code class="codeph">oracle.sql.CHAR</code>对象：</p>
                        <ol>
                           <li>
                              <p>通过调用静态<code class="codeph">CharacterSet.make()</code>方法创建一个<code class="codeph">CharacterSet</code>实例。此方法创建字符集类。它需要输入有效的Oracle字符集（ <code class="codeph">OracleId)</code> 。例如：</p><pre class="oac_no_warn" dir="ltr">int OracleId = CharacterSet。JA16SJIS_CHARSET; //这是字符集832 ...CharacterSet mycharset = CharacterSet.make（OracleId）;</pre><p>Oracle支持的每个字符集都有一个唯一的预定义<code class="codeph">OracleId</code> 。始终可以将<code class="codeph">OracleId</code>引用为指定为<span class="italic"><code class="codeph">Oracle_character_set_name</code></span> <code class="codeph">_CHARSET</code>的字符集，其中<span class="italic"><code class="codeph">Oracle_character_set_name</code></span>是Oracle字符集。
                              </p>
                           </li>
                           <li>
                              <p>构造一个<code class="codeph">oracle.sql.CHAR</code>对象。将构造函数传递给构造函数（或表示字符串的字节）和<code class="codeph">CharacterSet</code>对象，该对象指示如何根据字符集解释字节。例如：</p><pre class="oac_no_warn" dir="ltr">String mystring =“teststring”; ...oracle.sql。CHAR mychar = new oracle.sql。CHAR（teststring，mycharset）;</pre><p><code class="codeph">oracle.sql.CHAR</code>类有多个构造函数：它们可以将字符串，字节数组或对象作为输入与<code class="codeph">CharacterSet</code>对象一起使用。对于字符串，在放入<code class="codeph">oracle.sql.之前，该字符串将转换为<code class="codeph">CharacterSet</code>对象指示的字符集<code class="codeph">oracle.sql.CHAR</code>对象。
                              </p>
                           </li>
                        </ol>
                        <p>服务器（数据库）和客户端（或客户端上运行的应用程序）可以使用不同的字符集。当您使用此类的方法在服务器和客户端之间传输数据时，JDBC驱动程序必须在服务器字符集和客户端字符集之间转换数据。</p>
                     </div>
                  </div><a id="NLSPG370"></a><div class="props_rev_3"><a id="GUID-A2C9E2A8-FE6B-441B-98EB-06F41585B4AD" name="GUID-A2C9E2A8-FE6B-441B-98EB-06F41585B4AD"></a><h5 id="NLSPG-GUID-A2C9E2A8-FE6B-441B-98EB-06F41585B4AD" class="sect5"><span class="enumeration_section">7.5.6.2</span>使用oracle.sql访问SQL CHAR和NCHAR属性。CHAR</h5>
                     <div>
                        <p>以下是使用SQL创建的对象类型的示例：</p><pre class="oac_no_warn" dir="ltr">CREATE TYPE person_type AS OBJECT（名称VARCHAR2（30），地址NVARCHAR2（256），年龄NUMBER）; CREATE TABLE员工（ID NUMBER，person PERSON_TYPE）;</pre><p>与此对象类型对应的Java类可以构造如下：</p><pre class="oac_no_warn" dir="ltr">公共类人员实现SqlData {oracle.sql。CHAR名称; oracle.sql。CHAR地址; oracle.sql。NUMBER年龄; // SqlData接口getSqlType（）{...}writeSql（SqlOutput stream）{...}readSql（SqlInput流，String sqltype）{...}}</pre><p><code class="codeph">oracle.sql.此处使用CHAR</code>类映射到Oracle对象类型的<code class="codeph">NAME</code>属性，该属性具有<code class="codeph">VARCHAR2</code>数据类型。JDBC使用数据库中<code class="codeph">VARCHAR2</code>数据的字节表示形式和与数据库字符集对应的<code class="codeph">CharacterSet</code>对象填充此类。以下代码从<code class="codeph">employees</code>表中检索<code class="codeph">person</code>对象：</p><pre class="oac_no_warn" dir="ltr">TypeMap map =（（OracleConnection）conn）.getTypeMap（）; map.put（“PERSON_TYPE”，Class.forName（“person”））; conn.setTypeMap（地图）; 。 。 。。 。 。ResultSet rs = stmt.executeQuery（“从员工中选择人员”）; rs.next（）; person p =（person）rs.getObject（1）; oracle.sql。CHAR sql_name = p.name; oracle.sql。CHAR sql_address = p.address; String java_name = sql_name.getString（）; String java_address = sql_address.getString（）;</pre><p><code class="codeph">oracle.sql.的<code class="codeph">getString()</code>方法<code class="codeph">oracle.sql.CHAR</code>类通过调用Oracle的Java数据转换类并返回Java字符串，将字节数组从数据库字符集或国家字符集转换为UTF-16。要使<code class="codeph">rs.getObject(1)</code>调用起作用，必须在类<code class="codeph">person</code>实现<code class="codeph">SqlData</code>接口，并且必须设置<code class="codeph">Typemap</code> <code class="codeph">map</code>以指示对象类型<code class="codeph">PERSON_TYPE</code>到Java类的映射。
                        </p>
                     </div>
                  </div>
               </div><a id="NLSPG371"></a><div class="props_rev_3"><a id="GUID-DDF4AED1-D62F-4CD7-9FCE-0A9FC6B2D74C" name="GUID-DDF4AED1-D62F-4CD7-9FCE-0A9FC6B2D74C"></a><h4 id="NLSPG-GUID-DDF4AED1-D62F-4CD7-9FCE-0A9FC6B2D74C" class="sect4"><span class="enumeration_section">7.5.7</span>使用JDBC访问SQL CHAR数据的限制</h4>
                  <div>
                     <p>本节包含以下主题：</p>
                     <ul style="list-style-type:disc">
                        <li>
                           <p><a href="programming-with-unicode.html#GUID-80320823-4869-4584-8426-3B1C7BCD669A">多字节数据库环境中的字符完整性问题</a></p>
                        </li>
                     </ul>
                  </div><a id="NLSPG813"></a><a id="NLSPG372"></a><div class="props_rev_3"><a id="GUID-80320823-4869-4584-8426-3B1C7BCD669A" name="GUID-80320823-4869-4584-8426-3B1C7BCD669A"></a><h5 id="NLSPG-GUID-80320823-4869-4584-8426-3B1C7BCD669A" class="sect5"><span class="enumeration_section">7.5.7.1</span>多字节数据库环境中的字符完整性问题</h5>
                     <div>
                        <p>当将字符数据插入数据库或从数据库中检索字符数据时，Oracle JDBC驱动程序会根据需要执行字符集转换。驱动程序将Java客户端使用的Unicode字符转换为Oracle数据库字符集字符，反之亦然。从Java Unicode字符集到数据库字符集再回到Java的往返字符数据可能会丢失一些信息。当多个Unicode字符映射到数据库字符集中的单个字符时，会发生这种情况。一个例子是Unicode全宽代字符（0xFF5E）及其到Oracle的JA16SJIS字符集的映射。此Unicode字符的往返转换将生成Unicode字符0x301C，即<a id="d59478e6751" class="indexterm-anchor"></a><a id="d59478e6753" class="indexterm-anchor"></a> wave dash（日本常用的字符表示范围），而不是波浪号。
                        </p>
                        <p>下图显示了波浪号角色的往返转换。</p>
                        <div class="figure" id="GUID-80320823-4869-4584-8426-3B1C7BCD669A__I1008863">
                           <p class="titleinfigure">图7-2字符完整性</p><img src="img/nlspg015.gif" alt="下面是图7-2的描述" title="下面是图7-2的描述" longdesc="img_text/nlspg015.html"><br><a href="img_text/nlspg015.html">“图7-2字符完整性”的描述</a></div>
                        <!-- class="figure" -->
                        <p>这个问题不是Oracle JDBC中的错误。不同操作系统中字符映射规范的模糊性是一个不幸的副作用。幸运的是，此问题仅影响少量Oracle字符集中的少量字符，例如JA16SJIS，JA16EUC，ZHT16BIG5和KO16KS5601。解决方法是避免使用这些字符进行完整的往返。</p>
                     </div>
                  </div>
               </div>
            </div><a id="NLSPG0077"></a><div class="props_rev_3"><a id="GUID-FA450F53-2904-4520-8A88-901DC5AEA2EE" name="GUID-FA450F53-2904-4520-8A88-901DC5AEA2EE"></a><h3 id="NLSPG-GUID-FA450F53-2904-4520-8A88-901DC5AEA2EE" class="sect3"><span class="enumeration_section">7.6</span>使用Unicode进行ODBC和OLE DB编程</h3>
               <div>
                  <p>你应该<a id="d59478e6840" class="indexterm-anchor"></a>在使用Windows平台时，使用Oracle ODBC驱动程序或Oracle Provider for OLE DB访问Oracle服务器。本节介绍这些驱动程序如何支持Unicode。它包括以下主题：</p>
                  <ul style="list-style-type:disc">
                     <li>
                        <p><a href="programming-with-unicode.html#GUID-9F8D4568-6119-4ED6-A3B2-3444C964D02B">ODBC和OLE DB中启用Unicode的驱动程序</a></p>
                     </li>
                     <li>
                        <p><a href="programming-with-unicode.html#GUID-67C78306-3FE9-4391-BAB4-F073325E424F">OCI在Unicode中的依赖性</a></p>
                     </li>
                     <li>
                        <p><a href="programming-with-unicode.html#GUID-635555B8-B4F2-4675-95F4-DBEEC3614675">Unicode中的ODBC和OLE DB代码转换</a></p>
                     </li>
                     <li>
                        <p><a href="programming-with-unicode.html#GUID-B5081204-AF04-4E7D-8B10-DA1255B0E294">ODBC Unicode数据类型</a></p>
                     </li>
                     <li>
                        <p><a href="programming-with-unicode.html#GUID-F2A2F3A5-64FF-47B0-94E0-9F00FB41394E">OLE DB Unicode数据类型</a></p>
                     </li>
                     <li>
                        <p><a href="programming-with-unicode.html#GUID-737B1514-13C8-41AE-8243-2831B556AD64">ADO访问</a></p>
                     </li>
                  </ul>
               </div><a id="NLSPG373"></a><div class="props_rev_3"><a id="GUID-9F8D4568-6119-4ED6-A3B2-3444C964D02B" name="GUID-9F8D4568-6119-4ED6-A3B2-3444C964D02B"></a><h4 id="NLSPG-GUID-9F8D4568-6119-4ED6-A3B2-3444C964D02B" class="sect4"><span class="enumeration_section">7.6.1</span> ODBC和OLE DB中启用Unicode的驱动程序</h4>
                  <div>
                     <p>Oracle的ODBC驱动程序和OLE DB的OLE提供程序可以正确处理Unicode数据而不会丢失数据。例如，如果安装日语字体和用于输入日语字符的输入法编辑器，则可以在英语Windows上运行包含日语数据的Unicode ODBC应用程序。</p>
                     <p>Oracle仅为Windows平台提供ODBC和OLE DB产品。对于UNIX平台，请与您的供应商联系。</p>
                  </div>
               </div><a id="NLSPG374"></a><div class="props_rev_3"><a id="GUID-67C78306-3FE9-4391-BAB4-F073325E424F" name="GUID-67C78306-3FE9-4391-BAB4-F073325E424F"></a><h4 id="NLSPG-GUID-67C78306-3FE9-4391-BAB4-F073325E424F" class="sect4"><span class="enumeration_section">7.6.2</span> Unicode中的OCI依赖性</h4>
                  <div>
                     <p>ODBC和OLE DB驱动程序使用OCI Unicode绑定和定义功能来处理Unicode数据。OCI Unicode数据绑定和定义功能独立于<code class="codeph">NLS_LANG</code> 。这意味着无论平台上的<code class="codeph">NLS_LANG</code>设置如何，都可以正确处理Unicode数据。
                     </p>
                     <div class="infoboxnotealso" id="GUID-67C78306-3FE9-4391-BAB4-F073325E424F__GUID-6B30F08B-B962-4D73-8579-B7845BF097B0">
                        <p class="notep1">也可以看看：</p>
                        <p><span class="q">“ <a href="programming-with-unicode.html#GUID-C0EF74CA-C9C1-4651-B820-9B3E8FB70E8E">使用Unicode进行OCI编程</a> ”</span></p>
                     </div>
                  </div>
               </div><a id="NLSPG814"></a><a id="NLSPG375"></a><div class="props_rev_3"><a id="GUID-635555B8-B4F2-4675-95F4-DBEEC3614675" name="GUID-635555B8-B4F2-4675-95F4-DBEEC3614675"></a><h4 id="NLSPG-GUID-635555B8-B4F2-4675-95F4-DBEEC3614675" class="sect4"><span class="enumeration_section">7.6.3</span> Unicode中的ODBC和OLE DB代码转换</h4>
                  <div>
                     <p>一般来说，没有多余<a id="d59478e7114" class="indexterm-anchor"></a>除非您指定与服务器不同的客户端数据类型，否则将发生数据转换。例如，如果将Unicode缓冲区<code class="codeph">SQL_C_WCHAR</code>与<code class="codeph">NCHAR</code>等Unicode数据列绑定，则ODBC和OLE DB驱动程序会在应用程序和OCI层之间绕过它。
                     </p>
                     <p>如果在获取之前未指定数据类型，而是使用客户端数据类型调用<code class="codeph">SQLGetData</code> ，则会发生下表中描述的转换。
                     </p>
                     <div class="tblformalwide" id="GUID-635555B8-B4F2-4675-95F4-DBEEC3614675__G1010369">
                        <p class="titleintable">表7-7 ODBC隐式绑定代码转换</p>
                        <table cellpadding="4" cellspacing="0" class="FormalWide" title="ODBC隐式绑定代码转换" width="100%" border="1" summary="This table describes conversions that occur when you do not specify data types before fetching, but call SQLGetData with client data types." frame="hsides" rules="rows">
                           <thead>
                              <tr align="left" valign="top">
                                 <th align="left" valign="bottom" id="d59478e7142">ODBC客户端缓冲区的数据类型</th>
                                 <th align="left" valign="bottom" id="d59478e7145">数据库中目标列的数据类型</th>
                                 <th align="left" valign="bottom" id="d59478e7148">获取转化次数</th>
                                 <th align="left" valign="bottom" id="d59478e7151">评论</th>
                              </tr>
                           </thead>
                           <tbody>
                              <tr align="left" valign="top">
                                 <td align="left" valign="top" id="d59478e7156" headers="d59478e7142 ">
                                    <p><code class="codeph">SQL_C_WCHAR</code></p>
                                 </td>
                                 <td align="left" valign="top" headers="d59478e7156 d59478e7145 ">
                                    <p><code class="codeph">CHAR，VARCHAR2，</code></p>
                                    <p><code class="codeph">CLOB</code></p>
                                 </td>
                                 <td align="left" valign="top" headers="d59478e7156 d59478e7148 ">
                                    <p>如果数据库字符集是<code class="codeph">NLS_LANG</code>字符集的子集，则转换按以下顺序进行：</p>
                                    <ul style="list-style-type:disc">
                                       <li>
                                          <p>数据库字符集</p>
                                       </li>
                                       <li>
                                          <p><code class="codeph">NLS_LANG</code></p>
                                       </li>
                                       <li>
                                          <p>OCI中的UTF-16</p>
                                       </li>
                                       <li>
                                          <p>ODBC中的UTF-16</p>
                                       </li>
                                    </ul>
                                 </td>
                                 <td align="left" valign="top" headers="d59478e7156 d59478e7151 ">
                                    <p>没有意外的数据丢失</p>
                                    <p>如果数据库字符集是<code class="codeph">NLS_LANG</code>字符集的子集，则可能会降低性能</p>
                                 </td>
                              </tr>
                              <tr align="left" valign="top">
                                 <td align="left" valign="top" id="d59478e7196" headers="d59478e7142 ">
                                    <p><code class="codeph">SQL_C_CHAR</code></p>
                                 </td>
                                 <td align="left" valign="top" headers="d59478e7196 d59478e7145 ">
                                    <p><code class="codeph">CHAR，VARCHAR2，</code></p>
                                    <p><code class="codeph">CLOB</code></p>
                                 </td>
                                 <td align="left" valign="top" headers="d59478e7196 d59478e7148 ">
                                    <p>如果数据库字符集是<code class="codeph">NLS_LANG</code>字符集的子集：</p>
                                    <p>OCI中的数据库字符集设置为<code class="codeph">NLS_LANG</code></p>
                                    <p>如果数据库字符集不是<code class="codeph">NLS_LANG</code>字符集的子集：</p>
                                    <p>数据库字符集，UTF-16，OCI和ODBC中的<code class="codeph">NLS_LANG</code>字符集</p>
                                 </td>
                                 <td align="left" valign="top" headers="d59478e7196 d59478e7151 ">
                                    <p>没有意外的数据丢失</p>
                                    <p>如果数据库字符集不是<code class="codeph">NLS_LANG</code>字符集的子集，则可能会降低性能</p>
                                 </td>
                              </tr>
                           </tbody>
                        </table>
                     </div>
                     <!-- class="inftblhruleinformal" -->
                     <p>您必须指定用于插入和更新操作的数据类型。</p>
                     <p>调用<code class="codeph">SQLGetData</code>但不立即调用ODBC客户端缓冲区的数据类型。因此， <code class="codeph">SQLFetch</code>没有这些信息。
                     </p>
                     <p>由于ODBC驱动程序可确保数据完整性，因此如果执行隐式绑定，则冗余转换可能会导致性能下降。您的选择是在性能与显式绑定或可用性与隐式绑定之间进行权衡。</p>
                  </div><a id="NLSPG815"></a><a id="NLSPG376"></a><div class="props_rev_3"><a id="GUID-7F91F220-ADD5-4101-B34B-6748C0BFFFB0" name="GUID-7F91F220-ADD5-4101-B34B-6748C0BFFFB0"></a><h5 id="NLSPG-GUID-7F91F220-ADD5-4101-B34B-6748C0BFFFB0" class="sect5"><span class="enumeration_section">7.6.3.1</span> OLE DB代码转换</h5>
                     <div>
                        <p>与ODBC不同，OLE DB仅允许您执行用于插入，更新和获取数据的隐式绑定。用于确定中间字符集的转换算法与ODBC的隐式绑定情况相同。</p>
                        <div class="tblformalwide" id="GUID-7F91F220-ADD5-4101-B34B-6748C0BFFFB0__GUID-416EC808-D122-4B71-8B72-64709760C4FD">
                           <p class="titleintable">表7-8 OLE DB隐式绑定</p>
                           <table cellpadding="4" cellspacing="0" class="FormalWide" title="OLE DB隐式绑定" width="100%" border="1" summary="This table describes implicit bindings for OLE DB code conversions." frame="hsides" rules="rows">
                              <thead>
                                 <tr align="left" valign="top">
                                    <th align="left" valign="bottom" id="d59478e7335">OLE_DB客户端缓冲区的数据类型</th>
                                    <th align="left" valign="bottom" id="d59478e7338">数据库中目标列的数据类型</th>
                                    <th align="left" valign="bottom" id="d59478e7341">In-Binding和Out-Binding转换</th>
                                    <th align="left" valign="bottom" id="d59478e7344">评论</th>
                                 </tr>
                              </thead>
                              <tbody>
                                 <tr align="left" valign="top">
                                    <td align="left" valign="top" id="d59478e7349" headers="d59478e7335 ">
                                       <p><code class="codeph">DBTYPE_WCHAR</code></p>
                                    </td>
                                    <td align="left" valign="top" headers="d59478e7349 d59478e7338 ">
                                       <p><code class="codeph">CHAR，VARCHAR2，</code></p>
                                       <p><code class="codeph">CLOB</code></p>
                                    </td>
                                    <td align="left" valign="top" headers="d59478e7349 d59478e7341 ">
                                       <p>如果数据库字符集是<code class="codeph">NLS_LANG</code>字符集的子集：</p>
                                       <p>与OCI中的<code class="codeph">NLS_LANG</code>字符集相关的数据库字符集。在OLE DB中将<code class="codeph">NLS_LANG</code>字符设置为UTF-16</p>
                                       <p>如果数据库字符集不是<code class="codeph">NLS_LANG</code>字符集的子集：</p>
                                       <p>在OCI中与UTF-16之间的数据库字符集</p>
                                    </td>
                                    <td align="left" valign="top" headers="d59478e7349 d59478e7344 ">
                                       <p>没有意外的数据丢失</p>
                                       <p>如果数据库字符集是<code class="codeph">NLS_LANG</code>字符集的子集，则可能会降低性能</p>
                                    </td>
                                 </tr>
                                 <tr align="left" valign="top">
                                    <td align="left" valign="top" id="d59478e7390" headers="d59478e7335 ">
                                       <p><code class="codeph">DBTYPE_CHAR</code></p>
                                    </td>
                                    <td align="left" valign="top" headers="d59478e7390 d59478e7338 ">
                                       <p><code class="codeph">CHAR，VARCHAR2，</code></p>
                                       <p><code class="codeph">CLOB</code></p>
                                    </td>
                                    <td align="left" valign="top" headers="d59478e7390 d59478e7341 ">
                                       <p>如果数据库字符集是<code class="codeph">NLS_LANG</code>字符集的子集：</p>
                                       <p>在OCI中与<code class="codeph">NLS_LANG</code>数据库字符集</p>
                                       <p>如果数据库字符集不是<code class="codeph">NLS_LANG</code>字符集的子集：</p>
                                       <p>在OCI中与UTF-16之间的数据库字符集。 OLE DB中的UTF-16到<code class="codeph">NLS_LANG</code>字符集</p>
                                    </td>
                                    <td align="left" valign="top" headers="d59478e7390 d59478e7344 ">
                                       <p>没有意外的数据丢失</p>
                                       <p>如果数据库字符集不是<code class="codeph">NLS_LANG</code>字符集的子集，则可能会降低性能</p>
                                    </td>
                                 </tr>
                              </tbody>
                           </table>
                        </div>
                        <!-- class="inftblhruleinformal" -->
                     </div>
                  </div>
               </div><a id="NLSPG816"></a><a id="NLSPG377"></a><div class="props_rev_3"><a id="GUID-B5081204-AF04-4E7D-8B10-DA1255B0E294" name="GUID-B5081204-AF04-4E7D-8B10-DA1255B0E294"></a><h4 id="NLSPG-GUID-B5081204-AF04-4E7D-8B10-DA1255B0E294" class="sect4"><span class="enumeration_section">7.6.4</span> ODBC Unicode数据类型</h4>
                  <div>
                     <p>在<a id="d59478e7505" class="indexterm-anchor"></a> ODBC Unicode应用程序，使用<code class="codeph">SQLWCHAR</code>存储Unicode数据。所有标准Windows Unicode函数都可用于<code class="codeph">SQLWCHAR</code>数据操作。例如， <code class="codeph">wcslen</code>计算<code class="codeph">SQLWCHAR</code>数据的字符数：</p><pre class="oac_no_warn" dir="ltr">SQLWCHAR sqlStmt [] = L“从emp中选择ename”; len = wcslen（sqlStmt）;</pre><p>Microsoft的ODBC 3.5规范为<code class="codeph">SQL_C_WCHAR</code> ， <code class="codeph">SQL_C_WVARCHAR</code>和<code class="codeph">SQL_WLONGVARCHAR</code>客户端定义了三个Unicode数据类型标识符;和服务器<code class="codeph">SQL_WCHAR</code> ， <code class="codeph">SQL_WVARCHAR</code>和<code class="codeph">SQL_WLONGVARCHAR</code>三个Unicode数据类型标识符。</p>
                     <p>对于绑定操作，请使用<code class="codeph">SQLBindParameter</code>为客户端和服务器指定数据类型。以下是Unicode绑定的示例，其中客户端缓冲区<code class="codeph">Name</code>表示Unicode数据（ <code class="codeph">SQL_C_WCHAR</code> ）绑定到与Unicode列关联的第一个绑定变量（ <code class="codeph">SQL_WCHAR</code> ）：</p><pre class="oac_no_warn" dir="ltr">SQLBindParameter（StatementHandle，1，SQL_PARAM_INPUT，SQL_C_WCHAR，SQL_WCHAR，NameLen，0，（SQLPOINTER）Name，0，＆Name）;</pre><p>下表根据SQL <code class="codeph">NCHAR</code>数据类型表示服务器的ODBC Unicode数据类型的数据类型映射。
                     </p>
                     <div class="tblformal" id="GUID-B5081204-AF04-4E7D-8B10-DA1255B0E294__G1010407">
                        <p class="titleintable">表7-9服务器ODBC Unicode数据类型映射</p>
                        <table cellpadding="4" cellspacing="0" class="Formal" title="服务器ODBC Unicode数据类型映射" width="100%" border="1" summary="This table describes data type mappings of the ODBC Unicode data types for the server against SQL NCHAR data types." frame="hsides" rules="rows">
                           <thead>
                              <tr align="left" valign="top">
                                 <th align="left" valign="bottom" id="d59478e7574">ODBC数据类型</th>
                                 <th align="left" valign="bottom" id="d59478e7577">Oracle数据类型</th>
                              </tr>
                           </thead>
                           <tbody>
                              <tr align="left" valign="top">
                                 <td align="left" valign="top" id="d59478e7582" headers="d59478e7574 ">
                                    <p><code class="codeph">SQL_WCHAR</code></p>
                                 </td>
                                 <td align="left" valign="top" headers="d59478e7582 d59478e7577 ">
                                    <p><code class="codeph">NCHAR</code></p>
                                 </td>
                              </tr>
                              <tr align="left" valign="top">
                                 <td align="left" valign="top" id="d59478e7591" headers="d59478e7574 ">
                                    <p><code class="codeph">SQL_WVARCHAR</code></p>
                                 </td>
                                 <td align="left" valign="top" headers="d59478e7591 d59478e7577 ">
                                    <p><code class="codeph">NVARCHAR2</code></p>
                                 </td>
                              </tr>
                              <tr align="left" valign="top">
                                 <td align="left" valign="top" id="d59478e7600" headers="d59478e7574 ">
                                    <p><code class="codeph">SQL_WLONGVARCHAR</code></p>
                                 </td>
                                 <td align="left" valign="top" headers="d59478e7600 d59478e7577 ">
                                    <p><code class="codeph">NCLOB</code></p>
                                 </td>
                              </tr>
                           </tbody>
                        </table>
                     </div>
                     <!-- class="inftblhruleinformal" -->
                     <p>根据ODBC规范， <code class="codeph">SQL_WCHAR</code> ， <code class="codeph">SQL_WVARCHAR</code>和<code class="codeph">SQL_WLONGVARCHAR</code>被视为Unicode数据，因此以字符数而不是字节数来度量。
                     </p>
                  </div>
               </div><a id="NLSPG817"></a><a id="NLSPG378"></a><div class="props_rev_3"><a id="GUID-F2A2F3A5-64FF-47B0-94E0-9F00FB41394E" name="GUID-F2A2F3A5-64FF-47B0-94E0-9F00FB41394E"></a><h4 id="NLSPG-GUID-F2A2F3A5-64FF-47B0-94E0-9F00FB41394E" class="sect4"><span class="enumeration_section">7.6.5</span> OLE DB Unicode数据类型</h4>
                  <div>
                     <p><a id="d59478e7693" class="indexterm-anchor"></a> OLE DB为Unicode C客户端提供<code class="codeph">wchar_t</code> ， <code class="codeph">BSTR</code>和<code class="codeph">OLESTR</code>数据类型。实际上， <code class="codeph">wchar_t</code>是最常见的数据类型，其他数据类型用于特定目的。以下示例分配静态SQL语句：</p><pre class="oac_no_warn" dir="ltr">wchar_t * sqlStmt = OLESTR（“SELECT ename FROM emp”）;</pre><p><code class="codeph">OLESTR</code>宏的工作方式与“L”修饰符完全相同，表示Unicode字符串。如果需要使用<code class="codeph">OLESTR</code>动态分配Unicode数据缓冲区，则使用<code class="codeph">IMalloc</code>分配器（例如， <code class="codeph">CoTaskMemAlloc</code> ）。但是，使用<code class="codeph">OLESTR</code>不是可变长度数据的常规方法;使用<code class="codeph">wchar_t</code> *代替通用字符串类型。<code class="codeph">BSTR</code>类似。它是一个字符串，在字符串前面的内存位置有一个长度前缀。某些函数和方法只能接受<code class="codeph">BSTR</code> Unicode数据类型。因此，必须使用<code class="codeph">SysAllocString</code>等特殊函数来操作<code class="codeph">BSTR</code> Unicode字符串，并使用<code class="codeph">SysFreeString</code>来释放内存。
                     </p>
                     <p>与ODBC不同，OLE DB不允许您显式指定服务器数据类型。设置客户端数据类型时，OLE DB驱动程序会在必要时自动执行数据转换。</p>
                     <p>下表显示了OLE DB数据类型映射。</p>
                     <div class="tblformal" id="GUID-F2A2F3A5-64FF-47B0-94E0-9F00FB41394E__G1010423">
                        <p class="titleintable">表7-10 OLE DB数据类型映射</p>
                        <table cellpadding="4" cellspacing="0" class="Formal" title="OLE DB数据类型映射" width="100%" border="1" summary="This table OLE DB data type to Oracle data type mapping." frame="hsides" rules="rows">
                           <thead>
                              <tr align="left" valign="top">
                                 <th align="left" valign="bottom" id="d59478e7760">OLE DB数据类型</th>
                                 <th align="left" valign="bottom" id="d59478e7763">Oracle数据类型</th>
                              </tr>
                           </thead>
                           <tbody>
                              <tr align="left" valign="top">
                                 <td align="left" valign="top" id="d59478e7768" headers="d59478e7760 ">
                                    <p><code class="codeph">DBTYPE_WCHAR</code></p>
                                 </td>
                                 <td align="left" valign="top" headers="d59478e7768 d59478e7763 ">
                                    <p><code class="codeph">NCHAR或NVARCHAR2</code></p>
                                 </td>
                              </tr>
                           </tbody>
                        </table>
                     </div>
                     <!-- class="inftblhruleinformal" -->
                     <p>如果指定了<code class="codeph">DBTYPE_BSTR</code> ，则假定它是<code class="codeph">DBTYPE_WCHAR</code>因为它们都是Unicode字符串。
                     </p>
                  </div>
               </div><a id="NLSPG379"></a><div class="props_rev_3"><a id="GUID-737B1514-13C8-41AE-8243-2831B556AD64" name="GUID-737B1514-13C8-41AE-8243-2831B556AD64"></a><h4 id="NLSPG-GUID-737B1514-13C8-41AE-8243-2831B556AD64" class="sect4"><span class="enumeration_section">7.6.6</span> ADO访问</h4>
                  <div>
                     <p>ADO <a id="d59478e7859" class="indexterm-anchor"></a>是一个使用OLE DB和ODBC驱动程序访问数据库的高级API。大多数数据库应用程序开发人员在Windows上使用ADO界面，因为可以从Visual Basic轻松访问它，Visual Basic是Internet Information Server（IIS）的Active Server Pages（ASP）的主要脚本语言。对于OLE DB和ODBC驱动程序，ADO只是一个OLE DB使用者或ODBC应用程序。ADO假定OLE DB和ODBC驱动程序是支持Unicode的组件;因此，它总是试图操纵Unicode数据。
                     </p>
                  </div>
               </div>
            </div><a id="NLSPG0078"></a><div class="props_rev_3"><a id="GUID-17D808D8-283E-4F9B-8E2C-D77A60FCEFBA" name="GUID-17D808D8-283E-4F9B-8E2C-D77A60FCEFBA"></a><h3 id="NLSPG-GUID-17D808D8-283E-4F9B-8E2C-D77A60FCEFBA" class="sect3"><span class="enumeration_section">7.7</span>使用Unicode进行XML编程</h3>
               <div>
                  <p>Unicode的XML支持对于全球市场的软件开发至关重要，因此可以用任何语言交换文本信息。Unicode统一支持几乎所有字符和语言，这使得在XML中支持多种语言变得更加容易。要在Oracle数据库中为XML启用Unicode，数据库的字符集必须为UTF-8。通过在应用程序中启用Unicode文本处理，您可以获得支持任何语言的基础。每个XML文档都是Unicode文本，并且可能是多语言的，除非保证只有一个已知的Unicode字符子集才会出现在您的文档中。因此，Oracle建议您为XML启用Unicode。 Java和许多其他现代编程环境都带有Unicode支持。</p>
                  <p>本节包括以下主题：</p>
                  <ul style="list-style-type:disc">
                     <li>
                        <p><a href="programming-with-unicode.html#GUID-10C5F2B6-12C4-4E08-B034-6DE4A4A016FD">使用Java以Unicode编写XML文件</a></p>
                     </li>
                     <li>
                        <p><a href="programming-with-unicode.html#GUID-1F6717E4-45B4-4BC8-A73E-40B62C42B312">使用Java读取Unicode的XML文件</a></p>
                     </li>
                     <li>
                        <p><a href="programming-with-unicode.html#GUID-5F6457AE-B949-4F6E-95BE-4D0D5C822B33">使用Java解析Unicode中的XML流</a></p>
                     </li>
                  </ul>
               </div><a id="NLSPG380"></a><div class="props_rev_3"><a id="GUID-10C5F2B6-12C4-4E08-B034-6DE4A4A016FD" name="GUID-10C5F2B6-12C4-4E08-B034-6DE4A4A016FD"></a><h4 id="NLSPG-GUID-10C5F2B6-12C4-4E08-B034-6DE4A4A016FD" class="sect4"><span class="enumeration_section">7.7.1</span>使用Java以Unicode编写XML文件</h4>
                  <div>
                     <p>读取和写入XML文件的一个常见错误是使用<code class="codeph">Reader</code>和<code class="codeph">Writer</code>类进行字符输入和输出。应避免使用<code class="codeph">Reader</code>和<code class="codeph">Writer</code> for XML文件，因为它需要基于运行时环境的默认字符编码进行字符集转换。
                     </p>
                     <p>例如，使用<code class="codeph">FileWriter</code>类不安全，因为它将文档转换为默认字符编码。如果文档包含默认字符编码中不可用的字符，则输出文件可能会出现解析错误或数据丢失。
                     </p>
                     <p>UTF-8很受XML文档的欢迎，但UTF-8通常不是Java的默认文件编码。因此，使用假定默认文件编码的Java类可能会导致问题。</p>
                     <p>以下示例说明如何避免这些问题：</p><pre class="oac_no_warn" dir="ltr">import java.io.*; import oracle.xml.parser.v2。*; public class I18nSafeXMLFileWritingSample {public static void main（String [] args）throws Exception {//创建测试文档XMLDocument doc = new XMLDocument（）; doc.setVersion（“1.0”）; doc.appendChild（doc.createComment（“这是一个测试空文档。”））; doc.appendChild（doc.createElement（“root”））; //创建文件文件file = new File（“myfile.xml”）; //创建一个二进制输出流来写入刚刚创建的文件FileOutputStream fos = new FileOutputStream（file）; //创建一个将Java字符流转换为UTF-8流的Writer OutputStreamWriter osw = new OutputStreamWriter（fos，“UTF8”）; //为效率缓冲Writer w = new BufferedWriter（osw）; //创建一个PrintWriter以适应打印方法PrintWriter out = new PrintWriter（w）; //通过连接对象doc.print（out）将文档打印到文件中; }}</pre></div>
               </div><a id="NLSPG381"></a><div class="props_rev_3"><a id="GUID-1F6717E4-45B4-4BC8-A73E-40B62C42B312" name="GUID-1F6717E4-45B4-4BC8-A73E-40B62C42B312"></a><h4 id="NLSPG-GUID-1F6717E4-45B4-4BC8-A73E-40B62C42B312" class="sect4"><span class="enumeration_section">7.7.2</span>使用Java读取Unicode的XML文件</h4>
                  <div>
                     <p>不要将XML文件作为文本输入读取。读取存储在文件系统中的XML文档时，请使用解析器自动检测文档的字符编码。避免使用<code class="codeph">Reader</code>类或在输入流上指定字符编码。给定没有外部编码信息的二进制输入流，解析器根据XML文档的字节顺序标记和编码声明自动计算出字符编码。可以使用以下示例代码成功解析任何支持的编码中的任何格式良好的文档：</p><pre class="oac_no_warn" dir="ltr">import java.io.*; import oracle.xml.parser.v2。*; public class I18nSafeXMLFileReadingSample {public static void main（String [] args）throws Exception {//创建xml文件的实例File file = new File（“myfile.xml”）; //创建二进制输入流FileInputStream fis = new FileInputStream（file）; //缓冲效率BufferedInputStream in = new BufferedInputStream（fis）; //获取解析器的实例DOMParser parser = new DOMParser（）; //解析xml文件parser.parse（in）; }}</pre></div>
               </div><a id="NLSPG382"></a><div class="props_rev_3"><a id="GUID-5F6457AE-B949-4F6E-95BE-4D0D5C822B33" name="GUID-5F6457AE-B949-4F6E-95BE-4D0D5C822B33"></a><h4 id="NLSPG-GUID-5F6457AE-B949-4F6E-95BE-4D0D5C822B33" class="sect4"><span class="enumeration_section">7.7.3</span>使用Java解析Unicode中的XML流</h4>
                  <div>
                     <p>当XML文档的源不是文件系统时，编码信息通常在读取文档之前可用。例如，如果输入文档以Java字符流或Reader的形式提供，则其编码是明显的，不应进行检测。解析器可以开始使用Unicode解析Reader而不考虑字符编码。</p>
                     <p>以下是使用外部编码信息解析文档的示例：</p><pre class="oac_no_warn" dir="ltr">import java.io.*; import java.net。*; import org.xml.sax。*; import oracle.xml.parser.v2。*; public class I18nSafeXMLStreamReadingSample {public static void main（String [] args）throws Exception {//创建xml文件的实例URL url = new URL（“http：//myhost/mydocument.xml”）; //创建与xml文档的连接URLConnection conn = url.openConnection（）; //获取输入流InputStream is = conn.getInputStream（）; //为效率缓冲BufferedInputStream bis = new BufferedInputStream（is）; / *弄清楚这里的字符编码* / / *编码信息的典型来源是内容类型头* / / *我们假设在这个例子中发现它是utf-8 * / String charset =“utf-8 “; //为UTF-8流创建一个InputSource InputSource in = new InputSource（bis）; in.setEncoding（charset）; //获取解析器的实例DOMParser parser = new DOMParser（）; //解析xml流parser.parse（in）; }}</pre></div>
               </div>
            </div>
         </div>
      </article>
   </body>
</html>