<html lang="en-us" dir="ltr" xml:lang="en-us">
   <head>
      <meta http-equiv="Content-Type" content="text/html; charset=utf-8"></meta>
      <meta name="viewport" content="width=device-width, initial-scale=1"></meta>
      <meta http-equiv="X-UA-Compatible" content="IE=edge"></meta>
      <title>性能调优</title>
      <meta property="og:site_name" content="Oracle Help Center"></meta>
      <meta property="og:title" content="Programmer&#39;s Guide to the Oracle Precompilers"></meta>
      <meta property="og:description" content=""></meta>
      <link rel="stylesheet" href="/sp_common/book-template/ohc-book-template/css/book.css"></link>
      <link rel="shortcut icon" href="/sp_common/book-template/ohc-common/img/favicon.ico"></link>
      <meta name="application-name" content="Programmer&#39;s Guide to the Oracle Precompilers"></meta>
      <meta name="generator" content="DITA Open Toolkit version 1.8.5 (Mode = doc)"></meta>
      <meta name="plugin" content="SP_docbuilder HTML plugin release 18.2.2"></meta>
      <link rel="alternate" href="programmers-guide-oracle-precompilers.pdf" title="PDF File" type="application/pdf"></link>
      <meta name="robots" content="all"></meta>
      <link rel="schema.dcterms" href="http://purl.org/dc/terms/"></link>
      <meta name="dcterms.created" content="2019-01-11T01:36:30-08:00"></meta>
      <meta name="dcterms.title" content="Programmer&#39;s Guide to the Oracle Precompilers"></meta>
      <meta name="dcterms.dateCopyrighted" content="2008, 2019"></meta>
      <meta name="dcterms.category" content="database"></meta>
      <meta name="dcterms.identifier" content="E96474-01"></meta>
      
      <meta name="dcterms.product" content="en/database/oracle/oracle-database/19"></meta>
      
      <link rel="prev" href="Oracle-reserved-words-keywords-namespaces.html" title="Previous" type="text/html"></link>
      <link rel="next" href="syntactic-and-semantic-checking.html" title="Next" type="text/html"></link>
      <script>
        document.write('<style type="text/css">');
        document.write('body > .noscript, body > .noscript ~ * { visibility: hidden; }');
        document.write('</style>');
     </script>
      <script src="/sp_common/book-template/requirejs/require.js" data-main="/sp_common/book-template/ohc-book-template/js/book-config"></script>
      <script>
            if (window.require === undefined) {
                document.write('<script data-main="sp_common/book-template/ohc-book-template/js/book-config" src="sp_common/book-template/requirejs/require.js"><\/script>');
                document.write('<link href="sp_common/book-template/ohc-book-template/css/book.css" rel="stylesheet"/>');
            }
        </script>
      <script type="application/json" id="ssot-metadata">{"primary":{"category":{"short_name":"database","element_name":"Database","display_in_url":true},"suite":{"short_name":"oracle","element_name":"Oracle","display_in_url":true},"product_group":{"short_name":"not-applicable","element_name":"Not applicable","display_in_url":false},"product":{"short_name":"oracle-database","element_name":"Oracle Database","display_in_url":true},"release":{"short_name":"19","element_name":"Release 19","display_in_url":true}}}</script>
      
    <meta name="dcterms.isVersionOf" content="ZZPRE"></meta>
    <meta name="dcterms.release" content="Release 19"></meta>
  </head>
   <body dir="ltr">
      <div class="noscript alert alert-danger text-center" role="alert">
         <a href="Oracle-reserved-words-keywords-namespaces.html" class="pull-left"><span class="glyphicon glyphicon-chevron-left" aria-hidden="true"></span>上一页</a> <a href="syntactic-and-semantic-checking.html" class="pull-right">下一页<span class="glyphicon glyphicon-chevron-right" aria-hidden="true"></span></a> <span class="fa fa-exclamation-triangle" aria-hidden="true"></span>必须启用JavaScript才能正确显示此内容</div>
      <article>
         <header>
            <ol class="breadcrumb" vocab="http://schema.org/" typeof="BreadcrumbList">
               <li property="itemListElement" typeof="ListItem"><a href="index.html" property="item" typeof="WebPage"><span property="name">程序员指南Oracle预编译器</span></a></li>
               <li class="active" property="itemListElement" typeof="ListItem">性能调优</li>
            </ol>
            <a id="GUID-3E208ADC-D434-4B51-B1D2-B78A04C564DE" name="GUID-3E208ADC-D434-4B51-B1D2-B78A04C564DE"></a><a id="ZZPRE962"></a>
            
            <h2 id="ZZPRE-GUID-3E208ADC-D434-4B51-B1D2-B78A04C564DE" class="sect2"><span class="enumeration_chapter">C</span>性能调优</h2>
         </header>
         <div class="ind">
            <div>
               <p>本附录包含以下部分：</p>
               <ul style="list-style-type:disc">
                  <li>
                     <p><a href="performance-tuning.html#GUID-0FF54C88-FB26-4A60-AFBA-33198CD70853">什么导致表现不佳？</a></p>
                  </li>
                  <li>
                     <p><a href="performance-tuning.html#GUID-1952F35A-2469-4B59-BDBE-BD530A47E59B">如何改进性能？</a></p>
                  </li>
                  <li>
                     <p><a href="performance-tuning.html#GUID-F45C7950-E32D-4755-9131-281EA1211B6B">使用主机阵列</a></p>
                  </li>
                  <li>
                     <p><a href="performance-tuning.html#GUID-34BF884E-F285-49C0-90CA-A3705CD66BC7">使用嵌入式PL / SQL</a></p>
                  </li>
                  <li>
                     <p><a href="performance-tuning.html#GUID-5C776C55-AB88-4AB0-BD89-02E18606AA50">优化SQL语句</a></p>
                  </li>
                  <li>
                     <p><a href="performance-tuning.html#GUID-3B41775E-6CB9-4DF2-B1B4-42A0952550C0">关于使用索引</a></p>
                  </li>
                  <li>
                     <p><a href="performance-tuning.html#GUID-8DC1ED54-9922-416D-9D9C-BF7232973FA4">利用行级锁定</a></p>
                  </li>
                  <li>
                     <p><a href="performance-tuning.html#GUID-0E9592D6-734E-456B-A29F-3C96CC236248">关于消除不必要的解析</a></p>
                  </li>
               </ul>
               <p>本附录向您展示了一些简单易用的方法，可以提高应用程序的性能。使用这些方法，您通常可以将处理时间缩短25％或更多。</p>
            </div><a id="ZZPRE963"></a><div class="props_rev_3"><a id="GUID-0FF54C88-FB26-4A60-AFBA-33198CD70853" name="GUID-0FF54C88-FB26-4A60-AFBA-33198CD70853"></a><h3 id="ZZPRE-GUID-0FF54C88-FB26-4A60-AFBA-33198CD70853" class="sect3"><span class="enumeration_section">C.1</span>性能不佳的原因是什么？
               </h3>
               <div>
                  <p><a id="d83369e90" class="indexterm-anchor"></a>性能不佳的一个原因是Oracle通信开销很高。Oracle必须一次处理一个SQL语句。因此，每个语句都会导致对Oracle的另一次调用以及更高的开销。在网络环境中，必须通过网络发送SQL语句，从而增加网络流量。繁重的网络流量会显着降低您的应用程序速度
                  </p>
                  <p>性能不佳的另一个原因是效率低下的SQL语句。因为SQL非常灵活，所以可以使用两个不同的语句获得相同的结果，但是一个语句可能效率较低。例如，以下两个<code class="codeph">SELECT</code>语句返回相同的行（每个部门的名称和编号至少有一名员工）：</p><pre class="oac_no_warn" dir="ltr">EXEC SQL SELECT DNAME，DEPTNO FROM DEPT OF DEPTNO IN（从EMP中选择DEPTNO）; EXEC SQL SELECT DNAME，来自DEPT的DEPTNO EXERE EXTS（从DEPE.DEPTNO = EMP.DEPTNO的EMP中选择DEPTNO）;</pre><p>但是，第一个语句较慢，因为它对<code class="codeph">DEPT</code>表中的每个部门号执行耗时的<code class="codeph">EMP</code>表全扫描。即使<code class="codeph">EMP</code>的<code class="codeph">DEPTNO</code>列已编制索引，也不会使用索引，因为子查询缺少一个命名<code class="codeph">DEPTNO</code>的<code class="codeph">WHERE</code>子句。</p>
                  <p>性能不佳的第三个原因是不必要的解析和绑定。回想一下，在执行SQL语句之前，Oracle必须解析并绑定它。解析意味着检查SQL语句以确保它遵循语法规则并引用有效的数据库对象。绑定意味着将SQL语句中的主机变量与其地址相关联，以便Oracle可以读取或写入其值。</p>
                  <p>许多应用程序管理游标很差。这导致不必要的解析和绑定，这显着增加了处理开销。</p>
               </div>
            </div><a id="ZZPRE964"></a><div class="props_rev_3"><a id="GUID-1952F35A-2469-4B59-BDBE-BD530A47E59B" name="GUID-1952F35A-2469-4B59-BDBE-BD530A47E59B"></a><h3 id="ZZPRE-GUID-1952F35A-2469-4B59-BDBE-BD530A47E59B" class="sect3"><span class="enumeration_section">C.2</span>如何改进性能？
               </h3>
               <div>
                  <p>如果您对预编译程序的性能不满意，可以通过多种方法减少开销。</p>
                  <p>您可以通过以下方式大大减少Oracle通信开销，尤其是在网络环境中：</p>
                  <ul style="list-style-type:disc">
                     <li>
                        <p>使用主机阵列</p>
                     </li>
                     <li>
                        <p>使用嵌入式PL / SQL</p>
                     </li>
                  </ul>
                  <p>您可以通过以下方式减少处理开销 - 有时是显着的 -</p>
                  <ul style="list-style-type:disc">
                     <li>
                        <p>优化SQL语句</p>
                     </li>
                     <li>
                        <p>使用索引</p>
                     </li>
                     <li>
                        <p>利用行级锁定</p>
                     </li>
                     <li>
                        <p>消除不必要的解析</p>
                     </li>
                  </ul>
               </div>
            </div><a id="ZZPRE965"></a><div class="props_rev_3"><a id="GUID-F45C7950-E32D-4755-9131-281EA1211B6B" name="GUID-F45C7950-E32D-4755-9131-281EA1211B6B"></a><h3 id="ZZPRE-GUID-F45C7950-E32D-4755-9131-281EA1211B6B" class="sect3"><span class="enumeration_section">C.3</span>使用主机阵列</h3>
               <div>
                  <p>主机阵列可以提高性能，因为它们允许您使用单个SQL语句操作整个数据集合。例如，假设您要将300名员工的工资插入<code class="codeph">EMP</code>表。如果没有阵列，您的程序必须执行300次单独插入 - 每个员工一次。对于数组，只需要一个<code class="codeph">INSERT</code> 。请考虑以下声明：</p><pre class="oac_no_warn" dir="ltr">EXEC SQL INSERT INTO EMP（SAL）VALUES（：薪水）;</pre><p><a id="d83369e209" class="indexterm-anchor"></a>如果<span class="italic">salary</span>是一个简单的宿主变量，Oracle会执行一次<code class="codeph">INSERT</code>语句，将一行插入<code class="codeph">EMP</code>表。在该行中， <code class="codeph">SAL</code>列具有<span class="italic">salary</span>的值。要以这种方式插入300行，必须执行300次<code class="codeph">INSERT</code>语句。
                  </p>
                  <p>但是，如果<span class="italic">salary</span>是大小为300的主机数组，Oracle会立即将所有300行插入到<code class="codeph">EMP</code>表中。在每一行中， <code class="codeph">SAL</code>列都具有<span class="italic">salary</span>数组中元素的值。
                  </p>
                  <p>有关更多信息，请参阅<a href="using-host-arrays.html#GUID-F8DD2840-4F8C-4093-A4F9-51C9FE9FA59F">使用主机阵列</a></p>
               </div>
            </div><a id="ZZPRE967"></a><a id="ZZPRE966"></a><div class="props_rev_3"><a id="GUID-34BF884E-F285-49C0-90CA-A3705CD66BC7" name="GUID-34BF884E-F285-49C0-90CA-A3705CD66BC7"></a><h3 id="ZZPRE-GUID-34BF884E-F285-49C0-90CA-A3705CD66BC7" class="sect3"><span class="enumeration_section">C.4</span>使用嵌入式PL / SQL</h3>
               <div>
                  <p><a href="performance-tuning.html#GUID-34BF884E-F285-49C0-90CA-A3705CD66BC7__BABGCIDB">如图C-1</a>所示，如果您的应用程序是数据库密集型的，您可以使用控制结构在PL / SQL块中对SQL语句进行分组，然后将整个块发送到Oracle。这可以大大减少应用程序与Oracle之间的通信。
                  </p>
                  <p><a id="d83369e278" class="indexterm-anchor"></a>此外，您可以使用PL / SQL子程序来减少从应用程序到Oracle的调用。例如，要执行十个单独的SQL语句，需要进行十次调用，但要执行包含十个SQL语句的子程序，只需要一次调用。
                  </p>
                  <p><a id="d83369e284" class="indexterm-anchor"></a>与匿名块不同，PL / SQL子程序可以单独编译并存储在Oracle数据库中。调用时，它们会立即传递给PL / SQL引擎。此外，只需要将子程序的一个副本加载到存储器中以供多个用户执行。
                  </p>
                  <div class="figure" id="GUID-34BF884E-F285-49C0-90CA-A3705CD66BC7__BABGCIDB">
                     <p class="titleinfigure">图C-1 PL / SQL提升性能</p><img src="img/image015.gif" alt="下面是图C-1的描述" title="下面是图C-1的描述" longdesc="img_text/image015.html"><br><a href="img_text/image015.html">“图C-1 PL / SQL提升性能”的描述</a></div>
                  <!-- class="figure" -->
                  <p>PL / SQL还可以与Oracle应用程序开发工具（如Oracle Forms和Oracle Reports）配合使用。通过为这些工具添加程序处理能力，PL / SQL提高了性能。使用PL / SQL，工具可以快速有效地进行任何计算，而无需调用Oracle。这节省了时间和<a id="d83369e296" class="indexterm-anchor"></a>减少网络流量。有关更多信息，请参阅<a href="using-embedded-PLSQL.html#GUID-F6E58CB5-C25B-47EE-B349-314F28961A56">使用嵌入式PL / SQL</a>和<a href="../lnpls/overview.html#LNPLS-GUID-2FBCFBBE-6B42-4DB8-83F3-55B63B75B1EB" target="_blank"><span class="italic">Oracle数据库PL / SQL语言参考</span></a> 。
                  </p>
               </div>
            </div><a id="ZZPRE968"></a><div class="props_rev_3"><a id="GUID-5C776C55-AB88-4AB0-BD89-02E18606AA50" name="GUID-5C776C55-AB88-4AB0-BD89-02E18606AA50"></a><h3 id="ZZPRE-GUID-5C776C55-AB88-4AB0-BD89-02E18606AA50" class="sect3"><span class="enumeration_section">C.5</span>优化SQL语句</h3>
               <div>
                  <p>对于每个SQL语句，Oracle优化器都会生成一个<span class="italic">执行计划</span> ，这是Oracle执行该语句所采取的一系列步骤。这些步骤由<a href="../adfns/fundamentals.html#ADFNS-GUID-EBCEA9FE-4F25-40DF-B5FD-682C3692E92F" target="_blank"><span class="italic">Oracle数据库高级应用程序开发人员指南</span></a>中的规则确定。遵循这些规则将帮助您编写最佳SQL语句。
                  </p>
               </div><a id="ZZPRE969"></a><div class="props_rev_3"><a id="GUID-2CA551D4-FD95-47E8-A25E-A3FF424167EA" name="GUID-2CA551D4-FD95-47E8-A25E-A3FF424167EA"></a><h4 id="ZZPRE-GUID-2CA551D4-FD95-47E8-A25E-A3FF424167EA" class="sect4"><span class="enumeration_section">C.5.1</span>优化器提示</h4>
                  <div>
                     <p>对于每个SQL语句，Oracle优化器都会生成一个<span class="italic">执行计划</span> ，这是Oracle执行该语句所采取的一系列步骤。在某些情况下，您可以向Oracle建议优化SQL语句的方法。这些建议叫做<a id="d83369e377" class="indexterm-anchor"></a> <span class="italic">提示</span> ，让您影响优化器做出的决策。
                     </p>
                     <p>提示不是指令;他们只是帮助优化者完成它的工作。一些提示限制了用于优化SQL语句的信息范围，而其他提示则提出了整体策略。您可以使用提示指定：</p>
                     <ul style="list-style-type:disc">
                        <li>
                           <p>SQL语句的优化方法</p>
                        </li>
                        <li>
                           <p>每个引用表的访问路径</p>
                        </li>
                        <li>
                           <p>加入加入订单</p>
                        </li>
                        <li>
                           <p>用于连接表的方法</p>
                        </li>
                     </ul>
                  </div>
               </div><a id="ZZPRE970"></a><div class="props_rev_3"><a id="GUID-F0BA871A-1D8F-4BFB-A4E7-41BD3A31A742" name="GUID-F0BA871A-1D8F-4BFB-A4E7-41BD3A31A742"></a><h4 id="ZZPRE-GUID-F0BA871A-1D8F-4BFB-A4E7-41BD3A31A742" class="sect4"><span class="enumeration_section">C.5.2</span>给出提示</h4>
                  <div>
                     <p>您可以通过在<code class="codeph">SELECT</code> ， <code class="codeph">UPDATE</code>或<code class="codeph">DELETE</code>语句中的动词后立即将它们放在C样式注释中来为优化器提供提示。您可以选择基于规则或基于成本的优化。通过基于成本的优化，提示有助于最大化吞吐量或响应时间。在以下示例中， <code class="codeph">ALL_ROWS</code>提示有助于最大化查询吞吐量：</p><pre class="oac_no_warn" dir="ltr">EXEC SQL SELECT / * + ALL_ROWS（基于成本）* / EMPNO，ENAME，SAL INTO：emp_number，：emp_name，：salary  - 主机数组FROM EMP WHERE DEPTNO =：dept_number;</pre><p>加号（+）必须紧跟注释开头，表示注释包含一个或多个提示。请注意，注释可以包含备注和提示。</p>
                     <p>有关优化程序提示的更多信息，请参阅<a href="../adfns/performance-and-scalability.html#ADFNS-GUID-826DD1D3-C722-4915-8790-E870D6B5123A" target="_blank">性能和可伸缩性</a> 。
                     </p>
                  </div>
               </div><a id="ZZPRE971"></a><div class="props_rev_3"><a id="GUID-FEC96095-8463-41F4-B615-9D94A0BFE4F3" name="GUID-FEC96095-8463-41F4-B615-9D94A0BFE4F3"></a><h4 id="ZZPRE-GUID-FEC96095-8463-41F4-B615-9D94A0BFE4F3" class="sect4"><span class="enumeration_section">C.5.3</span>跟踪设施</h4>
                  <div>
                     <div class="section">
                        <p>您可以使用SQL跟踪工具和<code class="codeph">EXPLAIN</code> <code class="codeph">PLAN</code>语句来标识可能会降低应用程序速度的SQL语句。跟踪工具为Oracle执行的每个SQL语句生成统计信息。从这些统计信息中，您可以确定哪些语句需要花费最多的时间来处理。然后，您可以将调整工作集中在这些语句上。
                        </p>
                        <p><code class="codeph">EXPLAIN</code> <code class="codeph">PLAN</code>语句显示应用程序中每个SQL语句的执行计划。您可以使用执行计划来识别低效的SQL语句。
                        </p>
                     </div>
                     <!-- class="section" -->
                  </div>
               </div>
            </div><a id="ZZPRE972"></a><div class="props_rev_3"><a id="GUID-3B41775E-6CB9-4DF2-B1B4-42A0952550C0" name="GUID-3B41775E-6CB9-4DF2-B1B4-42A0952550C0"></a><h3 id="ZZPRE-GUID-3B41775E-6CB9-4DF2-B1B4-42A0952550C0" class="sect3"><span class="enumeration_section">C.6</span>关于使用索引</h3>
               <div>
                  <p><a id="d83369e505" class="indexterm-anchor"></a>使用rowid， <span class="italic">索引</span>将表列中的每个不同值与包含该值的行相关联。使用<code class="codeph">CREATE INDEX</code>语句<code class="codeph">CREATE INDEX</code> 。
                  </p>
                  <p>您可以使用索引来提高返回少于表中行的15％的查询的性能。通过<span class="italic">完全扫描可以</span>更快地执行返回表中15％或更多行的查询<a id="d83369e518" class="indexterm-anchor"></a> ，即通过顺序读取所有行。在<code class="codeph">WHERE</code>子句中命名索引列的任何查询都可以使用索引。有关帮助您选择要编制索引的列的准则，请参阅<a href="../adfns/performance-and-scalability.html#ADFNS-GUID-826DD1D3-C722-4915-8790-E870D6B5123A" target="_blank">性能和可伸缩性</a> 。
                  </p>
               </div>
            </div><a id="ZZPRE973"></a><div class="props_rev_3"><a id="GUID-8DC1ED54-9922-416D-9D9C-BF7232973FA4" name="GUID-8DC1ED54-9922-416D-9D9C-BF7232973FA4"></a><h3 id="ZZPRE-GUID-8DC1ED54-9922-416D-9D9C-BF7232973FA4" class="sect3"><span class="enumeration_section">C.7</span>利用行级锁定</h3>
               <div>
                  <p><a id="d83369e549" class="indexterm-anchor"></a>默认情况下，Oracle会在行级而不是表级别锁定数据。行级锁定允许多个用户同时访问同一表中的不同行。由此带来的性能提升非常显着。
                  </p>
                  <p>您可以指定表级锁定，但会降低事务处理选项的有效性。有关表锁定的详细信息，请参阅<span class="q">“ <a href="defining-controlling-transactions.html#GUID-DA549A9A-0E41-4FFD-AF00-BF5373BE59CA">关于使用LOCK TABLE语句</a> ”</span> 。
                  </p>
                  <p>进行在线事务处理的应用程序从行级锁定中获益最多。如果您的应用程序依赖于表级锁定，请对其进行修改以利用行级锁定。通常，避免显式表级锁定。</p>
               </div>
            </div><a id="ZZPRE974"></a><div class="props_rev_3"><a id="GUID-0E9592D6-734E-456B-A29F-3C96CC236248" name="GUID-0E9592D6-734E-456B-A29F-3C96CC236248"></a><h3 id="ZZPRE-GUID-0E9592D6-734E-456B-A29F-3C96CC236248" class="sect3"><span class="enumeration_section">C.8</span>关于消除不必要的解析</h3>
               <div>
                  <p>消除不必要的解析需要正确处理游标并选择性地使用以下游标管理选项：</p>
                  <ul style="list-style-type:disc">
                     <li>
                        <p><code class="codeph">MAXOPENCURSORS</code><a id="d83369e590" class="indexterm-anchor"></a></p>
                     </li>
                     <li>
                        <p><code class="codeph">HOLD_CURSOR</code></p>
                     </li>
                     <li>
                        <p><code class="codeph">RELEASE_CURSOR</code></p>
                     </li>
                  </ul>
                  <p>这些选项会影响隐式和显式游标，游标缓存和私有SQL区域。</p>
                  <p>您可以使用ORACA获取游标缓存统计信息。请参阅<span class="q">“ <a href="error-handling-diagnostics.html#GUID-EECD612B-7EA7-4C51-A8FD-5F7EC854F510">关于使用Oracle通信区域</a> ”</span> 。
                  </p>
               </div><a id="ZZPRE975"></a><div class="props_rev_3"><a id="GUID-D681627C-8D13-4881-908F-07B230DB0EA4" name="GUID-D681627C-8D13-4881-908F-07B230DB0EA4"></a><h4 id="ZZPRE-GUID-D681627C-8D13-4881-908F-07B230DB0EA4" class="sect4"><span class="enumeration_section">C.8.1</span>关于处理显式游标</h4>
                  <div>
                     <p>回想一下，有两种类型的游标：隐式和显式。Oracle隐式声明了所有数据定义和数据操作语句的游标。但是，对于返回多行的查询，必须显式声明游标（或使用主机数组）。您使用<code class="codeph">DECLARE CURSOR</code>语句来声明显式游标。如何处理显式游标的打开和关闭会影响性能。
                     </p>
                     <p>如果需要重新评估活动集，只需重新打开游标即可。<code class="codeph">OPEN</code>语句将使用任何新的主机变量值。如果不先关闭光标，可以节省处理时间。
                     </p>
                     <p><a id="d83369e642" class="indexterm-anchor"></a>为了使性能调优更容易，预编译器允许您重新打开已打开的游标。但是，这是ANSI / ISO嵌入式SQL标准的Oracle扩展。因此，当<code class="codeph">MODE=ANSI</code> ，必须在重新打开之前关闭游标。
                     </p>
                     <p>只有在想要释放通过打开光标获取的资源（内存和锁）时才<code class="codeph">CLOSE</code>光标。例如，您的程序应该在退出之前关闭所有游标。
                     </p>
                  </div>
               </div><a id="ZZPRE976"></a><div class="props_rev_3"><a id="GUID-EF495012-0E1E-4E9B-9C05-153B86C956F4" name="GUID-EF495012-0E1E-4E9B-9C05-153B86C956F4"></a><h4 id="ZZPRE-GUID-EF495012-0E1E-4E9B-9C05-153B86C956F4" class="sect4"><span class="enumeration_section">C.8.2</span>光标控制</h4>
                  <div>
                     <p>通常，有三种方法可以控制显式声明的游标：</p>
                     <ul style="list-style-type:disc">
                        <li>
                           <p>使用<code class="codeph">DECLARE</code> ， <code class="codeph">OPEN</code>和<code class="codeph">CLOSE</code>语句</p>
                        </li>
                        <li>
                           <p>使用<code class="codeph">PREPARE</code> ， <code class="codeph">DECLARE</code> ， <code class="codeph">OPEN</code>和<code class="codeph">CLOSE</code>语句</p>
                        </li>
                        <li>
                           <p>当<code class="codeph">MODE=ANSI</code>时， <code class="codeph">COMMIT</code>关闭光标</p>
                        </li>
                     </ul>
                     <p>用第一种方法，注意不必要的解析。<code class="codeph">OPEN</code>语句执行解析，但前提是解析后的语句不可用，因为游标已关闭或从未打开过。您的程序应该<code class="codeph">DECLARE</code>游标，每次主机变量的值更改时重新打开它，并且只有在不再需要SQL语句时才<code class="codeph">CLOSE</code>它。
                     </p>
                     <p>使用第二种方式（动态SQL方法3和4）， <code class="codeph">PREPARE</code>语句执行解析，并且解析的语句可用，直到执行<code class="codeph">CLOSE</code>语句。您的程序应准备SQL语句并<code class="codeph">DECLARE</code>游标，每次主机变量的值更改时重新打开游标，如果SQL语句更改，则重新打开SQL语句并重新打开游标，并且仅在SQL语句为no时<code class="codeph">CLOSE</code>游标需要更久。
                     </p>
                     <p>如果可能，避免将<code class="codeph">OPEN</code>和<code class="codeph">CLOSE</code>语句放在循环中;这是不必要的重新解析SQL语句的潜在原因。在下一个示例中， <code class="codeph">OPEN</code>和<code class="codeph">CLOSE</code>语句都在外部<code class="codeph">while</code>循环内。当<code class="codeph">MODE=ANSI</code> ， <code class="codeph">CLOSE</code>语句必须如图所示定位，因为ANSI要求在重新打开之前关闭游标。
                     </p><pre class="oac_no_warn" dir="ltr">EXEC SQL DECLARE emp_cursor CURSOR FOR SELECT ename，sal from emp where sal&gt;：salary and sal &lt;=：salary + 1000;薪水= 0; while（salary &lt;5000）{EXEC SQL OPEN emp_cursor; while（SQLCODE == 0）{EXEC SQL FETCH emp_cursor INTO .......} salary + = 1000; EXEC SQL CLOSE emp_cursor; }</pre><p>但是，使用<code class="codeph">MODE=ORACLE</code> ，可以在不打开游标的情况下执行<code class="codeph">CLOSE</code>语句。通过将<code class="codeph">CLOSE</code>语句放在外部<code class="codeph">while</code>循环之外，可以避免在<code class="codeph">OPEN</code>语句的每次迭代时进行可能的重新分析。
                     </p><pre class="oac_no_warn" dir="ltr">...while（salary &lt;5000）{EXEC SQL OPEN emp_cursor; while（sqlca.sqlcode == 0）{EXEC SQL FETCH emp_cursor INTO .......} salary + = 1000; } EXEC SQL CLOSE emp_cursor;</pre></div>
               </div><a id="ZZPRE977"></a><div class="props_rev_3"><a id="GUID-513A69BF-C606-42DD-A091-143BC387190E" name="GUID-513A69BF-C606-42DD-A091-143BC387190E"></a><h4 id="ZZPRE-GUID-513A69BF-C606-42DD-A091-143BC387190E" class="sect4"><span class="enumeration_section">C.8.3</span>关于使用光标管理选项</h4>
                  <div>
                     <p>除非您更改其构成，否则只需解析一次SQL语句。例如，通过向其选择列表或<code class="codeph">WHERE</code>子句添加列来更改查询的组成。<code class="codeph">HOLD_CURSOR</code> ， <code class="codeph">RELEASE_CURSOR</code>和<code class="codeph">MAXOPENCURSORS</code>选项使您可以控制Oracle如何管理SQL语句的解析和重新分析。声明显式游标可以最大程度地控制解析。
                     </p>
                  </div>
               </div><a id="ZZPRE979"></a><a id="ZZPRE978"></a><div class="props_rev_3"><a id="GUID-B6733E0A-495A-4D78-B202-6FB5F878EE03" name="GUID-B6733E0A-495A-4D78-B202-6FB5F878EE03"></a><h4 id="ZZPRE-GUID-B6733E0A-495A-4D78-B202-6FB5F878EE03" class="sect4"><span class="enumeration_section">C.8.4</span>私有SQL区域和游标缓存</h4>
                  <div>
                     <p><a id="d83369e839" class="indexterm-anchor"></a>执行数据操作语句时，其关联的游标将链接到游标缓存中的条目。游标缓存是用于游标管理的不断更新的内存区域。游标缓存条目又链接到私有SQL区域。
                     </p>
                     <p>该<a id="d83369e846" class="indexterm-anchor"></a>私有SQL区域是Oracle在运行时动态创建的工作区，包含已解析的SQL语句，主机变量的地址以及处理该语句所需的其他信息。显式游标允许您命名SQL语句，访问其私有SQL区域中的信息，并在某种程度上控制其处理。
                     </p>
                     <p><a href="performance-tuning.html#GUID-B6733E0A-495A-4D78-B202-6FB5F878EE03__BABJGEHE">图C-2</a>表示程序完成插入和删除后的游标缓存。
                     </p>
                     <div class="figure" id="GUID-B6733E0A-495A-4D78-B202-6FB5F878EE03__BABJGEHE">
                        <p class="titleinfigure">图C-2通过游标缓存链接的游标</p><img src="img/image016.gif" alt="下面是图C-2的描述" title="下面是图C-2的描述" longdesc="img_text/image016.html"><br><a href="img_text/image016.html">“通过游标缓存链接的图C-2游标”的描述</a></div>
                     <!-- class="figure" -->
                  </div>
               </div><a id="ZZPRE980"></a><div class="props_rev_3"><a id="GUID-6D77C9F0-FB8A-48A0-A262-53BF30504C95" name="GUID-6D77C9F0-FB8A-48A0-A262-53BF30504C95"></a><h4 id="ZZPRE-GUID-6D77C9F0-FB8A-48A0-A262-53BF30504C95" class="sect4"><span class="enumeration_section">C.8.5</span>资源使用</h4>
                  <div>
                     <p>每个用户会话中的最大打开游标数由Oracle初始化参数<code class="codeph">OPEN_CURSORS</code> 。</p>
                     <p><code class="codeph">MAXOPENCURSORS</code>指定游标缓存的<span class="italic">初始</span>大小。如果需要新的游标且没有可用的缓存条目，Oracle会尝试重用一个条目。它的成功取决于<code class="codeph">HOLD_CURSOR</code>和<code class="codeph">RELEASE_CURSOR</code>的值，对于显式游标，它取决于游标本身的状态。
                     </p>
                     <p>如果<code class="codeph">MAXOPENCURSORS</code>的值小于实际需要的高速缓存条目数，则Oracle使用标记为可重用的第一个高速缓存条目。例如，假设<code class="codeph">INSERT</code>语句的高速缓存条目<span class="italic">E</span> （1）被标记为可重用，并且高速缓存条目的数量已经等于<code class="codeph">MAXOPENCURSORS</code> 。如果程序执行新语句，则可以将高速缓存条目<span class="italic">E</span> （1）及其私有SQL区域重新分配给新语句。要重新执行<code class="codeph">INSERT</code>语句，Oracle必须重新解析它并重新分配另一个缓存条目。
                     </p>
                     <p>如果找不到要重用的缓存条目，Oracle会分配一个额外的缓存条目。例如，如果<code class="codeph">MAXOPENCURSORS=8</code>并且所有八个条目都处于活动状态，则会创建第九个条目。如有必要，Oracle会继续分配其他缓存条目，直到内存不足或达到<code class="codeph">OPEN_CURSORS</code>设置的限制为止。这种动态分配增加了处理开销。
                     </p>
                     <p>因此，为<code class="codeph">MAXOPENCURSORS</code>指定一个较低的值可以节省内存，但会导致新的缓存条目的动态分配和解除分配。为<code class="codeph">MAXOPENCURSORS</code>指定一个高值可确保快速执行但使用更多内存。
                     </p>
                  </div>
               </div><a id="ZZPRE981"></a><div class="props_rev_3"><a id="GUID-D9C675E4-9D48-4E18-B119-311BD493468F" name="GUID-D9C675E4-9D48-4E18-B119-311BD493468F"></a><h4 id="ZZPRE-GUID-D9C675E4-9D48-4E18-B119-311BD493468F" class="sect4"><span class="enumeration_section">C.8.6</span>不经常执行</h4>
                  <div>
                     <p>有时， <span class="italic">不经常</span>执行的SQL语句与其私有SQL区域之间的链接应该是临时的。
                     </p>
                     <p>当<code class="codeph">HOLD_CURSOR=NO</code> （默认值）时，在Oracle执行SQL语句并关闭游标后，预编译器<code class="codeph">HOLD_CURSOR=NO</code>游标和游标缓存之间的链接标记为可重用。只要另一个SQL语句需要它指向的游标缓存条目，就会重用该链接。这将释放分配给私有SQL区域的内存并释放解析锁。但是，由于准备好的游标必须保持活动状态，因此即使<code class="codeph">HOLD_CURSOR=NO</code> ，也会保持其链接。</p>
                     <p><a id="d83369e969" class="indexterm-anchor"></a>当<code class="codeph">RELEASE_CURSOR=YES</code> ，在Oracle执行SQL语句并且游标关闭后，将自动释放私有SQL区域并丢失解析的语句。例如，如果<code class="codeph">MAXOPENCURSORS</code>在您的站点设置为低以节省内存，则可能需<code class="codeph">MAXOPENCURSORS</code> 。
                     </p>
                     <p>如果数据操作语句在数据定义语句之前并且它们引用相同的表，则为数据操作语句指定<code class="codeph">RELEASE_CURSOR=YES</code> 。这避免了数据操作语句获得的解析锁与数据定义语句所需的排它锁之间的冲突。
                     </p>
                     <p>当<code class="codeph">RELEASE_CURSOR=YES</code> ，将立即删除私有SQL区域和高速缓存条目之间的链接，并释放私有SQL区域。即使您指定<code class="codeph">HOLD_CURSOR=YES</code> ，Oracle仍必须为私有SQL区域重新分配内存并在执行之前重新分析SQL语句，因为<code class="codeph">RELEASE_CURSOR=YES</code>会覆盖<code class="codeph">HOLD_CURSOR=YES</code> 。</p>
                     <p>尽管如此，当<code class="codeph">RELEASE_CURSOR=YES</code> ，重新分析可能不需要额外的处理，因为Oracle会在其<span class="italic">共享SQL缓存中缓存</span> SQL语句和PL / SQL块的已解析表示。即使其光标关闭，解析后的表示仍然可用，直到它从缓存中老化。
                     </p>
                  </div>
               </div><a id="ZZPRE982"></a><div class="props_rev_3"><a id="GUID-1E39FE70-0A55-4AC8-BBC7-A0E71B6855C1" name="GUID-1E39FE70-0A55-4AC8-BBC7-A0E71B6855C1"></a><h4 id="ZZPRE-GUID-1E39FE70-0A55-4AC8-BBC7-A0E71B6855C1" class="sect4"><span class="enumeration_section">C.8.7</span>频繁执行</h4>
                  <div>
                     <p>应保持<span class="italic">频繁</span>执行的SQL语句与其私有SQL区域之间的链接，因为私有SQL区域包含执行该语句所需的所有信息。维护对此信息的访问使得后续执行语句的速度更快。
                     </p>
                     <p>当<code class="codeph">HOLD_CURSOR=YES</code> ，Oracle执行SQL语句后，将保持游标和游标缓存之间的链接。因此，解析的语句和分配的内存仍然可用。这对于您希望保持活动状态的SQL语句非常有用，因为它可以避免不必要的重新分析。
                     </p>
                     <p>当<code class="codeph">HOLD_CURSOR=YES</code>且<code class="codeph">RELEASE_CURSOR=NO</code> （缺省值）时，在Oracle执行SQL语句后，将保留高速缓存条目与专用SQL区域之间的链接，除非打开游标的数量超过<code class="codeph">MAXOPENCURSORS</code>的值，否则不会重复使用。这对于经常执行的SQL语句很有用，因为解析的语句和分配的内存仍然可用。
                     </p>
                     <p>使用默认值<code class="codeph">HOLD_CURSOR=YES</code>和<code class="codeph">RELEASE_CURSOR=NO</code> ，在执行具有早期Oracle版本的SQL语句后，其解析的表示仍然可用。对于Oracle数据库版本7，在类似条件下，解析后的表示只有在老化出共享SQL高速缓存之后才可用。通常，这不是问题，但如果在重新分析SQL语句之前引用对象的定义发生更改，则可能会出现意外结果。
                     </p>
                  </div>
               </div><a id="ZZPRE984"></a><a id="ZZPRE983"></a><div class="props_rev_3"><a id="GUID-97A1E85F-5DC8-4DE0-B9CD-D0F49553D2E4" name="GUID-97A1E85F-5DC8-4DE0-B9CD-D0F49553D2E4"></a><h4 id="ZZPRE-GUID-97A1E85F-5DC8-4DE0-B9CD-D0F49553D2E4" class="sect4"><span class="enumeration_section">C.8.8</span>参数交互</h4>
                  <div>
                     <div class="section">
                        <p><a href="performance-tuning.html#GUID-97A1E85F-5DC8-4DE0-B9CD-D0F49553D2E4__BABJGAGG" title="参数交互">表C-1</a>显示了<code class="codeph">HOLD_CURSOR</code>和<code class="codeph">RELEASE_CURSOR</code>如何相互作用。请注意， <code class="codeph">HOLD_CURSOR=NO</code>会覆盖<code class="codeph">RELEASE_CURSOR=NO</code> ，而<code class="codeph">RELEASE_CURSOR=YES</code>会覆盖<code class="codeph">HOLD_CURSOR=YES</code> 。</p>
                     </div>
                     <!-- class="section" -->
                     <div class="tblformal" id="GUID-97A1E85F-5DC8-4DE0-B9CD-D0F49553D2E4__BABJGAGG">
                        <p class="titleintable">表C-1 HOLD_CURSOR RELEASE_CURSOR交互</p>
                        <table cellpadding="4" cellspacing="0" class="Formal" title="HOLD_CURSOR RELEASE_CURSOR交互" width="100%" border="1" summary="parameter interactions" frame="hsides" rules="rows">
                           <thead>
                              <tr align="left" valign="top">
                                 <th align="left" valign="bottom" width="27%" id="d83369e1114">HOLD_CURSOR</th>
                                 <th align="left" valign="bottom" width="27%" id="d83369e1117">RELEASE_CURSOR</th>
                                 <th align="left" valign="bottom" width="46%" id="d83369e1120">链接是：</th>
                              </tr>
                           </thead>
                           <tbody>
                              <tr align="left" valign="top">
                                 <td align="left" valign="top" width="27%" id="d83369e1125" headers="d83369e1114 ">
                                    <p>没有</p>
                                 </td>
                                 <td align="left" valign="top" width="27%" headers="d83369e1125 d83369e1117 ">
                                    <p>没有</p>
                                 </td>
                                 <td align="left" valign="top" width="46%" headers="d83369e1125 d83369e1120 ">
                                    <p>标记为可重复使用</p>
                                 </td>
                              </tr>
                              <tr align="left" valign="top">
                                 <td align="left" valign="top" width="27%" id="d83369e1135" headers="d83369e1114 ">
                                    <p>是</p>
                                 </td>
                                 <td align="left" valign="top" width="27%" headers="d83369e1135 d83369e1117 ">
                                    <p>没有</p>
                                 </td>
                                 <td align="left" valign="top" width="46%" headers="d83369e1135 d83369e1120 ">
                                    <p>保持</p>
                                 </td>
                              </tr>
                              <tr align="left" valign="top">
                                 <td align="left" valign="top" width="27%" id="d83369e1145" headers="d83369e1114 ">
                                    <p>没有</p>
                                 </td>
                                 <td align="left" valign="top" width="27%" headers="d83369e1145 d83369e1117 ">
                                    <p>是</p>
                                 </td>
                                 <td align="left" valign="top" width="46%" headers="d83369e1145 d83369e1120 ">
                                    <p>立即删除</p>
                                 </td>
                              </tr>
                              <tr align="left" valign="top">
                                 <td align="left" valign="top" width="27%" id="d83369e1155" headers="d83369e1114 ">
                                    <p>是</p>
                                 </td>
                                 <td align="left" valign="top" width="27%" headers="d83369e1155 d83369e1117 ">
                                    <p>是</p>
                                 </td>
                                 <td align="left" valign="top" width="46%" headers="d83369e1155 d83369e1120 ">
                                    <p>立即删除</p>
                                 </td>
                              </tr>
                           </tbody>
                        </table>
                     </div>
                     <!-- class="inftblhruleinformal" -->
                  </div>
               </div>
            </div>
         </div>
      </article>
   </body>
</html>