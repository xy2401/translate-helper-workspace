<html lang="en-us" dir="ltr" xml:lang="en-us">
   <head>
      <meta http-equiv="Content-Type" content="text/html; charset=utf-8"></meta>
      <meta name="viewport" content="width=device-width, initial-scale=1"></meta>
      <meta http-equiv="X-UA-Compatible" content="IE=edge"></meta>
      <meta name="abstract" content="There are various maintenance operations that can be performed on partitioned tables and indexes."></meta>
      <meta name="description" content="There are various maintenance operations that can be performed on partitioned tables and indexes."></meta>
      <title>分区表和索引的维护操作</title>
      <meta property="og:site_name" content="Oracle Help Center"></meta>
      <meta property="og:title" content="VLDB and Partitioning Guide"></meta>
      <meta property="og:description" content="There are various maintenance operations that can be performed on partitioned tables and indexes."></meta>
      <link rel="stylesheet" href="/sp_common/book-template/ohc-book-template/css/book.css"></link>
      <link rel="shortcut icon" href="/sp_common/book-template/ohc-common/img/favicon.ico"></link>
      <meta name="application-name" content="VLDB and Partitioning Guide"></meta>
      <meta name="generator" content="DITA Open Toolkit version 1.8.5 (Mode = doc)"></meta>
      <meta name="plugin" content="SP_docbuilder HTML plugin release 18.2.2"></meta>
      <link rel="alternate" href="vldb-and-partitioning-guide.pdf" title="PDF File" type="application/pdf"></link>
      <meta name="robots" content="all"></meta>
      <link rel="schema.dcterms" href="http://purl.org/dc/terms/"></link>
      <meta name="dcterms.created" content="2019-04-23T18:05:22-07:00"></meta>
      <meta name="dcterms.title" content="VLDB and Partitioning Guide"></meta>
      <meta name="dcterms.dateCopyrighted" content="2008, 2019"></meta>
      <meta name="dcterms.category" content="database"></meta>
      <meta name="dcterms.identifier" content="E96199-03"></meta>
      
      <meta name="dcterms.product" content="en/database/oracle/oracle-database/19"></meta>
      
      <link rel="prev" href="maintenance-partition-can-be-performed.html" title="Previous" type="text/html"></link>
      <link rel="next" href="drop-partition-table.html" title="Next" type="text/html"></link>
      <script>
        document.write('<style type="text/css">');
        document.write('body > .noscript, body > .noscript ~ * { visibility: hidden; }');
        document.write('</style>');
     </script>
      <script src="/sp_common/book-template/requirejs/require.js" data-main="/sp_common/book-template/ohc-book-template/js/book-config"></script>
      <script>
            if (window.require === undefined) {
                document.write('<script data-main="sp_common/book-template/ohc-book-template/js/book-config" src="sp_common/book-template/requirejs/require.js"><\/script>');
                document.write('<link href="sp_common/book-template/ohc-book-template/css/book.css" rel="stylesheet"/>');
            }
        </script>
      <script type="application/json" id="ssot-metadata">{"primary":{"category":{"short_name":"database","element_name":"Database","display_in_url":true},"suite":{"short_name":"oracle","element_name":"Oracle","display_in_url":true},"product_group":{"short_name":"not-applicable","element_name":"Not applicable","display_in_url":false},"product":{"short_name":"oracle-database","element_name":"Oracle Database","display_in_url":true},"release":{"short_name":"19","element_name":"Release 19","display_in_url":true}}}</script>
      
    <meta name="dcterms.isVersionOf" content="VLDBG"></meta>
    <meta name="dcterms.release" content="Release 19"></meta>
  </head>
   <body dir="ltr">
      <div class="noscript alert alert-danger text-center" role="alert">
         <a href="maintenance-partition-can-be-performed.html" class="pull-left"><span class="glyphicon glyphicon-chevron-left" aria-hidden="true"></span>上一页</a> <a href="drop-partition-table.html" class="pull-right">下一页<span class="glyphicon glyphicon-chevron-right" aria-hidden="true"></span></a> <span class="fa fa-exclamation-triangle" aria-hidden="true"></span>必须启用JavaScript才能正确显示此内容</div>
      <article>
         <header>
            <ol class="breadcrumb" vocab="http://schema.org/" typeof="BreadcrumbList">
               <li property="itemListElement" typeof="ListItem"><a href="index.html" property="item" typeof="WebPage"><span property="name">VLDB和分区指南</span></a></li>
               <li property="itemListElement" typeof="ListItem"><a href="partition-admin.html" property="item" typeof="WebPage"><span property="name">分区管理</span></a></li>
               <li class="active" property="itemListElement" typeof="ListItem">分区表和索引的维护操作</li>
            </ol>
            <a id="GUID-A226B597-BCF1-49E2-8284-739A99D3F9ED" name="GUID-A226B597-BCF1-49E2-8284-739A99D3F9ED"></a><a id="VLDBG1118"></a>
            
            <h2 id="VLDBG-GUID-A226B597-BCF1-49E2-8284-739A99D3F9ED" class="sect2">分区表和索引的维护操作</h2>
         </header>
         <div class="ind">
            <div>
               <p>可以对分区表和索引执行各种维护操作。</p>
               <p>以下主题讨论了为表和索引执行分区和子分区维护的操作。</p>
               <ul style="list-style-type:disc">
                  <li>
                     <p><a href="maintenance-partition-tables-indexes.html#GUID-1F3607A1-6790-4C14-9DDA-57B5D84E32CB" title="本节介绍如何手动将新分区添加到分区表，并说明无法将分区专门添加到大多数分区索引的原因。">关于添加分区和子分区</a></p>
                  </li>
                  <li>
                     <p><a href="maintenance-partition-tables-indexes.html#GUID-229CCB70-4799-4E0D-B98E-FD52750BC483" title="合并分区是一种减少散列分区表或索引中分区数量或* -hash分区表中子分区数量的方法。">关于合并分区和子分区</a></p>
                  </li>
                  <li>
                     <p><a href="maintenance-partition-tables-indexes.html#GUID-BAFFE31C-07A2-4ED6-BDCF-8ECB79D7FE7D" title="您可以从范围，间隔，列表或复合*中删除分区 -  [范围| list]分区表。">关于删除分区和子分区</a></p>
                  </li>
                  <li>
                     <p><a href="maintenance-partition-tables-indexes.html#GUID-E08650B4-06B1-43F9-91B0-FBF685A3B848" title="您可以通过交换数据段将分区或子分区转换为非分区表，将非分区表转换为分区表的分区或子分区。">关于交换分区和子分区</a></p>
                  </li>
                  <li>
                     <p><a href="maintenance-partition-tables-indexes.html#GUID-0E7793F7-B38A-427E-846B-7A8651F2A523" title="使用ALTER TABLE MERGE PARTITION和SUBPARTITION SQL语句合并两个分区或子分区的内容。">关于合并分区和子分区</a></p>
                  </li>
                  <li>
                     <p><a href="maintenance-partition-tables-indexes.html#GUID-46FB9C24-F5CC-4326-9BEB-9B525BF7526E" title="本主题中介绍了表，分区和子分区的属性的修改。">关于修改表，分区和子分区的属性</a></p>
                  </li>
                  <li>
                     <p><a href="maintenance-partition-tables-indexes.html#GUID-AA8A163D-7812-41B3-9B97-73EFB4034607" title="本主题中介绍了列表分区和子分区中值的修改。">关于修改列表分区</a></p>
                  </li>
                  <li>
                     <p><a href="maintenance-partition-tables-indexes.html#GUID-763391C6-44E8-401D-8119-DC12926F5877" title="您可以使用ALTER TABLE MODIFY PARTITION SQL语句更改常规（堆组织）表的分区策略。">关于修改分区策略</a></p>
                  </li>
                  <li>
                     <p><a href="maintenance-partition-tables-indexes.html#GUID-3DB0B6A6-FD33-4355-8BAC-7C5B4BE4C4E0" title="使用ALTER TABLE语句的MOVE PARTITION子句更改分区的物理存储属性。">关于移动分区和子分区</a></p>
                  </li>
                  <li>
                     <p><a href="maintenance-partition-tables-indexes.html#GUID-6FF7CB6D-CC8D-4FCD-B92E-581C9CF0BB2E" title="重建索引提供了几个优点。">关于重建索引分区</a></p>
                  </li>
                  <li>
                     <p><a href="maintenance-partition-tables-indexes.html#GUID-3CB99D78-9D4B-453D-8FBB-A79BE7FD887E" title="您可以重命名表和索引的分区和子分区。">关于重命名分区和子分区</a></p>
                  </li>
                  <li>
                     <p><a href="maintenance-partition-tables-indexes.html#GUID-6BB84952-7021-4CBA-91ED-180E0656E02B" title="您可以将分区的内容拆分为两个新分区。">关于拆分分区和子分区</a></p>
                  </li>
                  <li>
                     <p><a href="maintenance-partition-tables-indexes.html#GUID-08DC6C40-64B8-4932-8FB6-E22BDC8F842B" title="截断分区类似于删除分区，除了分区清空其数据，但没有物理丢弃。">关于截断分区和子分区</a></p>
                  </li>
               </ul>
               <div class="infoboxnote" id="GUID-A226B597-BCF1-49E2-8284-739A99D3F9ED__GUID-538B4FB5-ECC3-411B-9856-8AE374231641">
                  <p class="notep1">注意：</p>
                  <p>在讨论受维护操作影响的索引或索引分区的可用性时，请考虑以下事项：</p>
                  <ul style="list-style-type:disc">
                     <li>
                        <p>只有<span class="italic">非</span>空的索引和索引分区才能被标记为<code class="codeph">UNUSABLE</code> 。如果它们为空，则<code class="codeph">USABLE</code> / <code class="codeph">UNUSABLE</code>状态保持不变。
                        </p>
                     </li>
                     <li>
                        <p>只有具有<code class="codeph">USABLE</code>状态的索引或索引分区才会被后续DML更新。</p>
                     </li>
                  </ul>
               </div>
               <div class="infoboxnotealso" id="GUID-A226B597-BCF1-49E2-8284-739A99D3F9ED__GUID-848BF461-57B6-4FBC-BA7C-8A5D53C6BBD2">
                  <p class="notep1">也可以看看：</p>
                  <p></p>
                  <ul style="list-style-type:disc">
                     <li>
                        <p>有关管理表的信息，请参见<a href="../admin/managing-tables.html#ADMIN015" target="_blank"><span><cite>“Oracle数据库管理员指南”</cite></span></a></p>
                     </li>
                     <li>
                        <p><a href="../sqlrf/ALTER-TABLE.html#SQLRF01001" target="_blank"><span><cite>Oracle数据库SQL语言参考</cite></span></a> ，用于更改分区表和索引的分区子句的确切语法，对其使用的任何限制以及创建和更改表所需的特定权限</p>
                     </li>
                  </ul>
               </div>
            </div><a id="VLDBG1125"></a><div class="props_rev_3"><a id="GUID-1F3607A1-6790-4C14-9DDA-57B5D84E32CB" name="GUID-1F3607A1-6790-4C14-9DDA-57B5D84E32CB"></a><h3 id="VLDBG-GUID-1F3607A1-6790-4C14-9DDA-57B5D84E32CB" class="sect3">关于添加分区和子分区</h3>
               <div>
                  <p>本节介绍如何手动将新分区添加到分区表，并说明无法将分区专门添加到大多数分区索引的原因。</p>
                  <p></p>
                  <p>本节包含以下主题：</p>
                  <ul style="list-style-type:disc">
                     <li>
                        <p><a href="maintenance-partition-tables-indexes.html#GUID-0E7205A9-5D01-4642-B7E9-02406200493E" title="您可以在表的最后一个现有分区或表的开头之后或在表的中间添加分区。">将分区添加到范围分区表</a></p>
                     </li>
                     <li>
                        <p><a href="maintenance-partition-tables-indexes.html#GUID-0F321544-0BB6-43A3-BEC0-A004B06AAD57" title="将分区添加到散列分区表时，数据库会使用散列函数确定的现有分区（由数据库选择）重新填充的行填充新分区。">将分区添加到散列分区表</a></p>
                     </li>
                     <li>
                        <p><a href="maintenance-partition-tables-indexes.html#GUID-CDAA2363-B83A-408C-82C9-3E3FA3928D2D" title="本主题中的示例显示如何将分区添加到列表分区表。">将分区添加到列表分区表</a></p>
                     </li>
                     <li>
                        <p><a href="maintenance-partition-tables-indexes.html#GUID-497B9404-C945-4665-B9B6-C67385785BD3" title="您无法将分区显式添加到区间分区表。插入该间隔的数据时，数据库会自动为间隔创建分区。">将分区添加到区间分区表</a></p>
                     </li>
                     <li>
                        <p><a href="maintenance-partition-tables-indexes.html#GUID-8C9CF9BB-E23F-41B0-A133-0FF9D6D330E8" title="可以在分区级别和哈希子分区级别添加分区。">关于将分区添加到复合* -Hash分区表</a></p>
                     </li>
                     <li>
                        <p><a href="maintenance-partition-tables-indexes.html#GUID-EE0535E2-4F8B-4DF4-B1EC-FFA36A48222A" title="可以在分区级别和列表子分区级别添加分区。">关于将分区添加到复合* -List分区表</a></p>
                     </li>
                     <li>
                        <p><a href="maintenance-partition-tables-indexes.html#GUID-BBA74E11-E01B-4936-9F1B-CC71F30996E0" title="可以在分区级别和范围子分区级别添加分区。">关于将分区添加到复合* -Range分区表</a></p>
                     </li>
                     <li>
                        <p><a href="maintenance-partition-tables-indexes.html#GUID-B4BDFFC8-2AB3-40E9-9F53-4DC1D59D055F" title="可以将分区或子分区添加到引用分区定义中的父表，就像可以将分区和子分区添加到范围，散列，列表或复合分区表中一样。">关于将分区或子分区添加到参考分区表</a></p>
                     </li>
                     <li>
                        <p><a href="maintenance-partition-tables-indexes.html#GUID-8E46823F-91D4-49C7-AA7A-B51DFAD2B2EE" title="您无法将分区显式添加到本地索引。相反，只有在将分区添加到基础表时，才会将新分区添加到本地索引。">添加索引分区</a></p>
                     </li>
                     <li>
                        <p><a href="maintenance-partition-tables-indexes.html#GUID-676087FC-D6DC-4533-95FD-6DC941CE4753" title="您可以使用ALTER TABLE语句的ADD PARTITION和ADD SUBPARTITION子句添加多个新分区和子分区。">添加多个分区</a></p>
                     </li>
                  </ul>
               </div><a id="VLDBG1126"></a><div class="props_rev_3"><a id="GUID-0E7205A9-5D01-4642-B7E9-02406200493E" name="GUID-0E7205A9-5D01-4642-B7E9-02406200493E"></a><h4 id="VLDBG-GUID-0E7205A9-5D01-4642-B7E9-02406200493E" class="sect4">将分区添加到范围分区表</h4>
                  <div>
                     <p>您可以在表的最后一个现有分区或表的开头之后或在表的中间添加分区。</p>
                     <div class="section">
                        <p>使用<code class="codeph">ALTER</code> <code class="codeph">TABLE</code> <code class="codeph">ADD</code> <code class="codeph">PARTITION</code>语句将新分区添加到“高”端（最后一个现有分区之后的点）。要在表的开头或中间添加分区，请使用<code class="codeph">SPLIT</code> <code class="codeph">PARTITION</code>子句。
                        </p>
                        <p>例如，考虑表， <code class="codeph">sales</code> ，其中包含除前12个月之外的当月数据。在1999年1月1日，您为January添加了一个分区，该分区存储在表空间<code class="codeph">tsx</code> 。
                        </p><pre class="oac_no_warn" dir="ltr">ALTER TABLE销售添加分数jan99价值低于（'01-FEB-1999'）TABLESPACE tsx;</pre><p>与范围分区表关联的本地索引和全局索引仍然可用。</p>
                     </div>
                     <!-- class="section" -->
                  </div>
               </div><a id="VLDBG1127"></a><div class="props_rev_3"><a id="GUID-0F321544-0BB6-43A3-BEC0-A004B06AAD57" name="GUID-0F321544-0BB6-43A3-BEC0-A004B06AAD57"></a><h4 id="VLDBG-GUID-0F321544-0BB6-43A3-BEC0-A004B06AAD57" class="sect4">将分区添加到散列分区表</h4>
                  <div>
                     <p>将分区添加到散列分区表时，数据库会使用散列函数确定的现有分区（由数据库选择）重新填充的行填充新分区。</p>
                     <div class="section">
                        <p>因此，如果表包含数据，则可能需要一些时间来添加散列分区。</p>
                        <p>以下语句显示了向表<code class="codeph">scubagear</code>添加散列分区的两种方法。选择第一个语句会添加一个新的哈希分区，其分区名称是系统生成的，并且放在默认表空间中。第二个语句还添加了一个新的哈希分区，但该分区显式命名为<code class="codeph">p_named</code>并在表空间<code class="codeph">gear5</code>创建。
                        </p><pre class="oac_no_warn" dir="ltr">ALTER TABLE scubagear ADD PARTITION; ALTER TABLE scubagear ADD PARTITION p_named TABLESPACE gear5;</pre><p>索引可能标记为<code class="codeph">UNUSABLE</code> ，如下表所述：</p>
                        <div class="tblformal" id="GUID-0F321544-0BB6-43A3-BEC0-A004B06AAD57__GUID-9E1855CE-813A-44F7-A491-5BAB8EEBEA66">
                           <table cellpadding="4" cellspacing="0" class="Formal" title="" width="100%" border="1" summary="Column 1 lists the table type, column 2 lists the indexes behavior when the index is marked unusable." frame="hsides" rules="rows">
                              <thead>
                                 <tr align="left" valign="top">
                                    <th align="left" valign="bottom" width="23%" id="d29958e669">表类型</th>
                                    <th align="left" valign="bottom" width="77%" id="d29958e672">指数行为</th>
                                 </tr>
                              </thead>
                              <tbody>
                                 <tr align="left" valign="top">
                                    <td align="left" valign="top" width="23%" id="d29958e677" headers="d29958e669 ">
                                       <p>常规（堆）</p>
                                    </td>
                                    <td align="left" valign="top" width="77%" headers="d29958e677 d29958e672 ">
                                       <p>除非您将<code class="codeph">UPDATE</code> <code class="codeph">INDEXES</code>指定为<code class="codeph">ALTER</code> <code class="codeph">TABLE</code>语句的一部分：</p>
                                       <ul style="list-style-type:disc">
                                          <li>
                                             <p>新分区的本地索引以及从中重新分配行的现有分区都标记为<code class="codeph">UNUSABLE</code> ，必须重建。
                                             </p>
                                          </li>
                                          <li>
                                             <p>所有全局索引或分区全局索引的所有分区都标记为<code class="codeph">UNUSABLE</code> ，必须重建。
                                             </p>
                                          </li>
                                       </ul>
                                    </td>
                                 </tr>
                                 <tr align="left" valign="top">
                                    <td align="left" valign="top" width="23%" id="d29958e709" headers="d29958e669 ">
                                       <p>索引组织</p>
                                    </td>
                                    <td align="left" valign="top" width="77%" headers="d29958e709 d29958e672 ">
                                       <ul style="list-style-type:disc">
                                          <li>
                                             <p>对于本地索引，行为与堆表相同。</p>
                                          </li>
                                          <li>
                                             <p>所有全局索引仍然可用。</p>
                                          </li>
                                       </ul>
                                    </td>
                                 </tr>
                              </tbody>
                           </table>
                        </div>
                        <!-- class="inftblhruleinformal" -->
                     </div>
                     <!-- class="section" -->
                  </div>
               </div><a id="VLDBG1128"></a><div class="props_rev_3"><a id="GUID-CDAA2363-B83A-408C-82C9-3E3FA3928D2D" name="GUID-CDAA2363-B83A-408C-82C9-3E3FA3928D2D"></a><h4 id="VLDBG-GUID-CDAA2363-B83A-408C-82C9-3E3FA3928D2D" class="sect4">将分区添加到列表分区表</h4>
                  <div>
                     <p>本主题中的示例显示如何将分区添加到列表分区表。</p>
                     <div class="section">
                        <p>以下语句说明了如何将新分区添加到列表分区表。在此示例中，为要添加的分区指定了物理属性和<code class="codeph">NOLOGGING</code> 。
                        </p><pre class="oac_no_warn" dir="ltr">ALTER TABLE q1_sales_by_region ADD PARTITION q1_nonmainland VALUES（'HI'，'PR'）存储（初始20K，下一个20K）TABLESPACE tbs_3 NOLOGGING;</pre><p>描述要添加的分区的文字值集中的任何值都不得存在于表的任何其他分区中。</p>
                        <p>您无法将分区添加到具有默认分区的列表分区表，但您可以拆分默认分区。通过这样做，您可以有效地创建由您指定的值定义的新分区，以及保留默认分区的第二个分区。</p>
                        <p>与列表分区表关联的本地索引和全局索引仍然可用。</p>
                     </div>
                     <!-- class="section" -->
                  </div>
               </div><a id="VLDBG1129"></a><div class="props_rev_3"><a id="GUID-497B9404-C945-4665-B9B6-C67385785BD3" name="GUID-497B9404-C945-4665-B9B6-C67385785BD3"></a><h4 id="VLDBG-GUID-497B9404-C945-4665-B9B6-C67385785BD3" class="sect4">将分区添加到区间分区表</h4>
                  <div>
                     <p>您无法将分区显式添加到区间分区表。插入该间隔的数据时，数据库会自动为间隔创建分区。</p>
                     <div class="section">
                        <p>但是，交换未在数据字典中实现的区间分区表的分区，意味着在区间定义之外的数据字典中具有显式条目，您必须使用<code class="codeph">ALTER</code> <code class="codeph">TABLE</code> <code class="codeph">LOCK</code> <code class="codeph">PARTITION</code>命令手动实现分区。
                        </p>
                        <p>要更改将来分区的间隔，请使用<code class="codeph">ALTER TABLE</code>语句的<code class="codeph">SET INTERVAL</code>子句。<code class="codeph">SET INTERVAL</code>子句将现有间隔分区转换为范围分区，确定定义范围分区的高值，并根据超出该高值的数据的需要自动创建指定间隔的分区。作为副作用，区间分区表没有<code class="codeph">MAXVALUES</code>的表示法。</p>
                        <p>您还可以使用<code class="codeph">SET INTERVAL</code>子句将现有范围分区或范围*复合分区表迁移到interval或interval- * partitioned表中。要禁用创建将来的间隔分区，并有效恢复到范围分区表，请在<code class="codeph">SET INTERVAL</code>子句中使用空值。创建的间隔分区将转换为具有当前高值的范围分区。
                        </p>
                        <p>要增加日期范围的间隔，必须确保您处于新间隔的相关边界。例如，如果每日间隔分区表事务中的最高时间间隔分区边界是2007年1月30日，并且您希望更改为每月分区间隔，则以下语句将导致错误：</p><pre class="oac_no_warn" dir="ltr">ALTER TABLE事务SET INTERVAL（NUMTOYMINTERVAL（1，'MONTH'）; ORA-14767：无法使用现有的上限指定此间隔</pre><p>您必须创建另一个具有2007年2月1日上限的每日分区才能成功更改为每月间隔：</p><pre class="oac_no_warn" dir="ltr">LOCK TABLE事务PARTITION FOR（TO_DATE（'31 -JAN-2007'，'dd-MON-yyyy'）在SHARE MODE中; ALTER TABLE事务SET INTERVAL（NUMTOYMINTERVAL（1，'MONTH'）;</pre><p>区间分区表的下层分区是范围分区。您可以拆分范围分区，以在区间分区表的范围部分中添加更多分区。</p>
                        <p>要在<code class="codeph">transactions</code>表上禁用间隔分区，请使用：</p><pre class="oac_no_warn" dir="ltr">ALTER TABLE事务SET INTERVAL（）;</pre></div>
                     <!-- class="section" -->
                  </div>
               </div><a id="VLDBG1130"></a><div class="props_rev_3"><a id="GUID-8C9CF9BB-E23F-41B0-A133-0FF9D6D330E8" name="GUID-8C9CF9BB-E23F-41B0-A133-0FF9D6D330E8"></a><h4 id="VLDBG-GUID-8C9CF9BB-E23F-41B0-A133-0FF9D6D330E8" class="sect4">关于将分区添加到复合* -Hash分区表</h4>
                  <div>
                     <p>可以在分区级别和哈希子分区级别添加分区。</p>
                     <ul style="list-style-type:disc">
                        <li>
                           <p><a href="maintenance-partition-tables-indexes.html#GUID-B4C6E5C8-07C6-4C2C-8D6F-AF575D613B17" title="本主题中的示例显示如何将新分区添加到[range |列表| interval] -hash分区表。">将分区添加到* -Hash分区表</a></p>
                        </li>
                        <li>
                           <p><a href="maintenance-partition-tables-indexes.html#GUID-FCD53D58-461E-4555-A8CC-77B2B181232D" title="使用ALTER TABLE语句的MODIFY PARTITION ADD SUBPARTITION子句将哈希子分区添加到[range |列表| interval] -hash分区表。">将子分区添加到* -Hash分区表</a></p>
                        </li>
                     </ul>
                  </div><a id="VLDBG1131"></a><div class="props_rev_3"><a id="GUID-B4C6E5C8-07C6-4C2C-8D6F-AF575D613B17" name="GUID-B4C6E5C8-07C6-4C2C-8D6F-AF575D613B17"></a><h5 id="VLDBG-GUID-B4C6E5C8-07C6-4C2C-8D6F-AF575D613B17" class="sect5">将分区添加到* -Hash分区表</h5>
                     <div>
                        <p>本主题中的示例显示如何将新分区添加到[range |列表| interval] -hash分区表。</p>
                        <div class="section">
                           <p>对于interval-hash分区表，将自动创建间隔分区。您可以指定<code class="codeph">SUBPARTITIONS</code>子句，该子句允许您添加指定数量的子分区，或指定<code class="codeph">SUBPARTITION</code>子句以命名特定的子分区。如果未指定<code class="codeph">SUBPARTITIONS</code>或<code class="codeph">SUBPARTITION</code>子句，则分区将继承子分区的表级缺省值。对于interval-hash分区表，只能将子分区添加到已实现的范围或间隔分区。
                           </p>
                           <p>此示例将范围分区<code class="codeph">q1_2000</code>添加到范围散列分区表<code class="codeph">sales</code> ，该分区表填充了2000年第一季度的数据。表空间<code class="codeph">tbs5</code>存储了八个子分区。无法明确设置子分区以使用表压缩。子分区从分区级别继承压缩属性，并在此示例中以压缩形式存储：</p><pre class="oac_no_warn" dir="ltr">ALTER TABLE销售添加分数q1_2000价值低于（2000,04,01）压缩子商品8商店在tbs5;</pre></div>
                        <!-- class="section" -->
                     </div>
                  </div><a id="VLDBG1132"></a><div class="props_rev_3"><a id="GUID-FCD53D58-461E-4555-A8CC-77B2B181232D" name="GUID-FCD53D58-461E-4555-A8CC-77B2B181232D"></a><h5 id="VLDBG-GUID-FCD53D58-461E-4555-A8CC-77B2B181232D" class="sect5">将子分区添加到* -Hash分区表</h5>
                     <div>
                        <p>使用<code class="codeph">ALTER</code> <code class="codeph">TABLE</code>语句的<code class="codeph">MODIFY</code> <code class="codeph">PARTITION</code> <code class="codeph">ADD</code> <code class="codeph">SUBPARTITION</code>子句将哈希子分区添加到[range |列表| interval] -hash分区表。
                        </p>
                        <div class="section">
                           <p>新添加的子分区使用由散列函数确定的同一分区的其他子分区重新填充的行填充。对于interval-hash分区表，只能将子分区添加到已实现的范围或间隔分区。</p>
                           <p>在以下示例中，存储在表空间<code class="codeph">us1</code>的新哈希子分区<code class="codeph">us_loc5</code>将添加到表<code class="codeph">diving</code>范围分区<code class="codeph">locations_us</code>中。
                           </p><pre class="oac_no_warn" dir="ltr">ALTER TABLE潜水MODIFY PARTITION locations_us添加子目录us_locs5 TABLESPACE us1;</pre><p>除非指定<code class="codeph">UPDATE</code> <code class="codeph">INDEXES</code>否则必须重建与添加和重新分区的子分区对应的索引子分区。</p>
                        </div>
                        <!-- class="section" -->
                     </div>
                  </div>
               </div><a id="VLDBG1133"></a><div class="props_rev_3"><a id="GUID-EE0535E2-4F8B-4DF4-B1EC-FFA36A48222A" name="GUID-EE0535E2-4F8B-4DF4-B1EC-FFA36A48222A"></a><h4 id="VLDBG-GUID-EE0535E2-4F8B-4DF4-B1EC-FFA36A48222A" class="sect4">关于将分区添加到复合* -List分区表</h4>
                  <div>
                     <p>可以在分区级别和列表子分区级别添加分区。</p>
                     <ul style="list-style-type:disc">
                        <li>
                           <p><a href="maintenance-partition-tables-indexes.html#GUID-36244E4D-9B8E-4DFA-93DF-F72E535D9A23" title="本主题中的示例显示如何将新分区添加到[range |列表| interval] -list partitioned table。">将分区添加到* -List分区表</a></p>
                        </li>
                        <li>
                           <p><a href="maintenance-partition-tables-indexes.html#GUID-3CD59C1E-E0BF-4D76-9B8C-96CC6CD6DC41" title="使用ALTER TABLE语句的MODIFY PARTITION ADD SUBPARTITION子句将列表子分区添加到[range |列表| interval] -list partitioned table。">将子分区添加到* -List分区表</a></p>
                        </li>
                     </ul>
                  </div><a id="VLDBG14071"></a><a id="VLDBG1134"></a><div class="props_rev_3"><a id="GUID-36244E4D-9B8E-4DFA-93DF-F72E535D9A23" name="GUID-36244E4D-9B8E-4DFA-93DF-F72E535D9A23"></a><h5 id="VLDBG-GUID-36244E4D-9B8E-4DFA-93DF-F72E535D9A23" class="sect5">将分区添加到* -List分区表</h5>
                     <div>
                        <p>本主题中的示例显示如何将新分区添加到[range |列表| interval] -list partitioned table。</p>
                        <div class="section">
                           <p>当插入特定间隔的数据时，数据库会自动创建间隔分区。您可以指定<code class="codeph">SUBPARTITION</code>子句以命名和提供子分区的值列表。如果未指定<code class="codeph">SUBPARTITION</code>子句，则分区将继承子分区模板。如果没有子分区模板，则会创建一个默认子分区。
                           </p>
                           <p><a href="maintenance-partition-tables-indexes.html#GUID-36244E4D-9B8E-4DFA-93DF-F72E535D9A23__CHDJJFDF">例4-28中</a>的语句向<code class="codeph">quarterly_regional_sales</code>表添加了一个新分区，该分区由range-list方法分区。为此新分区指定了一些新的物理属性，而为未指定的那些继承了表级缺省值。
                           </p>
                        </div>
                        <!-- class="section" -->
                        <div class="example" id="GUID-36244E4D-9B8E-4DFA-93DF-F72E535D9A23__CHDJJFDF">
                           <p class="titleinexample">示例4-28将分区添加到范围列表分区表</p><pre class="oac_no_warn" dir="ltr">ALTER TABLE quarterly_regional_sales ADD PARTITION q1_2000价值低于（1  -  4月（'1-APR-2000'，'DD-MON-YYYY'））存储（初始20K，下一个20K）表格ts3 NOLOGGING（SUBPARTITION q1_2000_northwest VALUES（'OR'，'WA） '），SUBPARTITION q1_2000_southwest VALUES（'AZ'，'UT'，'NM'），SUBPARTITION q1_2000_northeast VALUES（'NY'，'VM'，'NJ'），SUBPARTITION q1_2000_southeast VALUES（'FL'，'GA'）， SUBPARTITION q1_2000_northcentral VALUES（'SD'，'WI'），SUBPARTITION q1_2000_southcentral VALUES（'OK'，'TX'））;</pre></div>
                        <!-- class="example" -->
                     </div>
                  </div><a id="VLDBG1135"></a><div class="props_rev_3"><a id="GUID-3CD59C1E-E0BF-4D76-9B8C-96CC6CD6DC41" name="GUID-3CD59C1E-E0BF-4D76-9B8C-96CC6CD6DC41"></a><h5 id="VLDBG-GUID-3CD59C1E-E0BF-4D76-9B8C-96CC6CD6DC41" class="sect5">将子分区添加到* -List分区表</h5>
                     <div>
                        <p>使用<code class="codeph">ALTER</code> <code class="codeph">TABLE</code>语句的<code class="codeph">MODIFY</code> <code class="codeph">PARTITION</code> <code class="codeph">ADD</code> <code class="codeph">SUBPARTITION</code>子句将列表子分区添加到[range |列表| interval] -list partitioned table。
                        </p>
                        <div class="section">
                           <p>对于区间列表分区表，只能将子分区添加到已实现的范围或间隔分区。</p>
                           <p>以下语句将新子分区添加到范围列表分区表<code class="codeph">quarterly_regional_sales</code>的现有子分区集。新的子分区在表空间<code class="codeph">ts2</code>创建。
                           </p><pre class="oac_no_warn" dir="ltr">ALTER TABLE quarterly_regional_sales MODIFY PARTITION q1_1999 ADD SUBPARTITION q1_1999_south VALUES（'AR'，'MS'，'AL'）表空间ts2;</pre></div>
                        <!-- class="section" -->
                     </div>
                  </div>
               </div><a id="VLDBG1136"></a><div class="props_rev_3"><a id="GUID-BBA74E11-E01B-4936-9F1B-CC71F30996E0" name="GUID-BBA74E11-E01B-4936-9F1B-CC71F30996E0"></a><h4 id="VLDBG-GUID-BBA74E11-E01B-4936-9F1B-CC71F30996E0" class="sect4">关于将分区添加到复合* -Range分区表</h4>
                  <div>
                     <p>可以在分区级别和范围子分区级别添加分区。</p>
                     <ul style="list-style-type:disc">
                        <li>
                           <p><a href="maintenance-partition-tables-indexes.html#GUID-60ECC329-E35D-42DC-AAC8-E834C9A3AC78" title="本主题中的示例显示如何将新分区添加到[range |列表| interval] -range分区表。">将分区添加到* -Range分区表</a></p>
                        </li>
                        <li>
                           <p><a href="maintenance-partition-tables-indexes.html#GUID-57C6840F-E023-4035-B5B4-00B92168F63F" title="使用ALTER TABLE语句的MODIFY PARTITION ADD SUBPARTITION子句将范围子分区添加到[range |列表| interval] -range分区表。">将子分区添加到* -Range分区表</a></p>
                        </li>
                     </ul>
                  </div><a id="VLDBG14072"></a><a id="VLDBG1137"></a><div class="props_rev_3"><a id="GUID-60ECC329-E35D-42DC-AAC8-E834C9A3AC78" name="GUID-60ECC329-E35D-42DC-AAC8-E834C9A3AC78"></a><h5 id="VLDBG-GUID-60ECC329-E35D-42DC-AAC8-E834C9A3AC78" class="sect5">将分区添加到* -Range分区表</h5>
                     <div>
                        <p>本主题中的示例显示如何将新分区添加到[range |列表| interval] -range分区表。</p>
                        <div class="section">
                           <p>在特定时间间隔内插入数据时，数据库会自动为间隔范围分区表创建间隔分区。您可以为命名和为特定子分区提供范围指定<code class="codeph">SUBPARTITION</code>子句。如果未指定<code class="codeph">SUBPARTITION</code>子句，则分区将继承在表级别指定的子分区模板。如果没有子分区模板，则会创建一个最大值为<code class="codeph">MAXVALUE</code>子分区。
                           </p>
                           <p><a href="maintenance-partition-tables-indexes.html#GUID-60ECC329-E35D-42DC-AAC8-E834C9A3AC78__CHDHHJHA">示例4-29</a>将范围分区<code class="codeph">p_2007_jan</code>添加到范围范围的分区表<code class="codeph">shipments</code> ，其中填充了2007年1月订购的货件的数据。有三个子分区。子分区从分区级别继承压缩属性，并在此示例中以压缩形式存储：</p>
                        </div>
                        <!-- class="section" -->
                        <div class="example" id="GUID-60ECC329-E35D-42DC-AAC8-E834C9A3AC78__CHDHHJHA">
                           <p class="titleinexample">示例4-29将分区添加到范围范围分区表</p><pre class="oac_no_warn" dir="ltr">ALTER TABLE发货添加PARTITION p_2007_jan值不到（截止日期（'01-FEB-2007'，'dd-MON-yyyy'））COMPRESS（子公司p07_jan_e价值低于（2015年6月1日） MONYYyy'）），SUBPARTITION p07_jan_a价值低于（截止日期（'01 -MAR-2007'，'dd-MON-yyyy'）），SUBPARTITION p07_jan_l价值不到（截止日期（'01-APR-2007'，'） dd-MON-yyyy'）））;</pre></div>
                        <!-- class="example" -->
                     </div>
                  </div><a id="VLDBG1138"></a><div class="props_rev_3"><a id="GUID-57C6840F-E023-4035-B5B4-00B92168F63F" name="GUID-57C6840F-E023-4035-B5B4-00B92168F63F"></a><h5 id="VLDBG-GUID-57C6840F-E023-4035-B5B4-00B92168F63F" class="sect5">将子分区添加到* -Range分区表</h5>
                     <div>
                        <p>使用<code class="codeph">ALTER</code> <code class="codeph">TABLE</code>语句的<code class="codeph">MODIFY</code> <code class="codeph">PARTITION</code> <code class="codeph">ADD</code> <code class="codeph">SUBPARTITION</code>子句将范围子分区添加到[range |列表| interval] -range分区表。
                        </p>
                        <div class="section">
                           <p>对于区间范围分区表，只能将分区添加到已实现的范围或间隔分区。</p>
                           <p>以下示例将范围子分区添加<code class="codeph">delivery_date</code> <code class="codeph">shipments</code>表，其中包含2007年1月的<code class="codeph">order_date</code>和2007年4月1日或之后的<code class="codeph">delivery_date</code>所有值。
                           </p><pre class="oac_no_warn" dir="ltr">ALTER TABLE出货量修改分区p_2007_jan添加分配p07_jan_vl价值低于（MAXVALUE）;</pre></div>
                        <!-- class="section" -->
                     </div>
                  </div>
               </div><a id="VLDBG1139"></a><div class="props_rev_3"><a id="GUID-B4BDFFC8-2AB3-40E9-9F53-4DC1D59D055F" name="GUID-B4BDFFC8-2AB3-40E9-9F53-4DC1D59D055F"></a><h4 id="VLDBG-GUID-B4BDFFC8-2AB3-40E9-9F53-4DC1D59D055F" class="sect4">关于将分区或子分区添加到参考分区表</h4>
                  <div>
                     <p>可以将分区或子分区添加到引用分区定义中的父表，就像可以将分区和子分区添加到范围，散列，列表或复合分区表中一样。</p>
                     <p>添加操作会自动级联到任何后代引用分区表。将分区或子分区添加到主表时， <code class="codeph">DEPENDENT TABLES</code>子句可以为从属表设置特定属性。
                     </p>
                     <div class="infoboxnotealso" id="GUID-B4BDFFC8-2AB3-40E9-9F53-4DC1D59D055F__GUID-B301BA95-7C63-4DC7-BBE8-F989463971E3">
                        <p class="notep1">也可以看看：</p>
                        <p><a href="../sqlrf/CREATE-TABLE.html#SQLRF01402" target="_blank"><span><cite>Oracle数据库SQL语言参考</cite></span></a></p>
                     </div>
                  </div>
               </div><a id="VLDBG1140"></a><div class="props_rev_3"><a id="GUID-8E46823F-91D4-49C7-AA7A-B51DFAD2B2EE" name="GUID-8E46823F-91D4-49C7-AA7A-B51DFAD2B2EE"></a><h4 id="VLDBG-GUID-8E46823F-91D4-49C7-AA7A-B51DFAD2B2EE" class="sect4">添加索引分区</h4>
                  <div>
                     <p>您无法将分区显式添加到本地索引。相反，只有在将分区添加到基础表时，才会将新分区添加到本地索引。</p>
                     <div class="section">
                        <p>具体来说，如果在表上定义了本地索引并且您发出<code class="codeph">ALTER</code> <code class="codeph">TABLE</code>语句以添加分区，则还会在本地索引中添加匹配的分区。数据库将名称和默认物理存储属性分配给新索引分区，但您可以在<code class="codeph">ADD</code> <code class="codeph">PARTITION</code>操作完成后重命名或更改它们。
                        </p>
                        <p>通过首先修改索引的默认属性，可以在<code class="codeph">ADD</code> <code class="codeph">PARTITION</code>操作中为索引分区有效指定新的表空间。例如，假设一个本地索引， <code class="codeph">q1_sales_by_region_locix</code> ，是为列表分区表创建<code class="codeph">q1_sales_by_region</code> 。如果在添加新分区<code class="codeph">q1_nonmainland</code> ，如<a href="maintenance-partition-tables-indexes.html#GUID-CDAA2363-B83A-408C-82C9-3E3FA3928D2D" title="本主题中的示例显示如何将分区添加到列表分区表。">添加分区到列表分区表中所示</a> ，您已发出以下语句，则将在表空间<code class="codeph">tbs_4</code>创建相应的索引分区。
                        </p><pre class="oac_no_warn" dir="ltr">ALTER INDEX q1_sales_by_region_locix MODIFY DEFAULT属性表格tbs_4;</pre><p>否则，在添加索引分区后，您需要使用以下语句将索引分区移动到<code class="codeph">tbs_4</code> ：</p><pre class="oac_no_warn" dir="ltr">ALTER INDEX q1_sales_by_region_locix REBUILD PARTITION q1_nonmainland TABLESPACE tbs_4;</pre><p>您可以使用<code class="codeph">ALTER</code> <code class="codeph">INDEX</code>的<code class="codeph">ADD</code> <code class="codeph">PARTITION</code>语法将分区添加到散列分区的全局索引。数据库添加散列分区，并使用从散列函数确定的索引的现有散列分区重新索引的索引条目填充它们。以下语句将分区添加到<a href="partition-create-tables-indexes.html#GUID-A8991A7A-CEC0-4C6D-A886-17E0554BB3C6" title="散列分区全局索引可以提高索引的性能，其中索引中的少量叶块在多用户OLTP环境中具有高争用。">创建哈希分区全局索引中</a>显示的索引<code class="codeph">hgidx</code> ：</p><pre class="oac_no_warn" dir="ltr">ALTER INDEX hgidx ADD PARTITION p5;</pre><p>您无法将分区添加到范围分区的全局索引，因为最高分区始终具有<code class="codeph">MAXVALUE</code>的分区。要添加新的最高分区，请使用<code class="codeph">ALTER</code> <code class="codeph">INDEX</code> <code class="codeph">SPLIT</code> <code class="codeph">PARTITION</code>语句。
                        </p>
                     </div>
                     <!-- class="section" -->
                  </div>
               </div><a id="VLDBG14108"></a><div class="props_rev_3"><a id="GUID-676087FC-D6DC-4533-95FD-6DC941CE4753" name="GUID-676087FC-D6DC-4533-95FD-6DC941CE4753"></a><h4 id="VLDBG-GUID-676087FC-D6DC-4533-95FD-6DC941CE4753" class="sect4">添加多个分区</h4>
                  <div>
                     <p>您可以使用<code class="codeph">ALTER</code> <code class="codeph">TABLE</code>语句的<code class="codeph">ADD</code> <code class="codeph">PARTITION</code>和<code class="codeph">ADD</code> <code class="codeph">SUBPARTITION</code>子句添加多个新分区和子分区。
                     </p>
                     <div class="section">
                        <p>添加多个分区时，本地和全局索引操作与添加单个分区时相同。只有范围，列表和系统分区以及子分区才支持添加多个分区和子分区。</p>
                        <p>如果未定义<code class="codeph">MAXVALUE</code>分区，则可以<code class="codeph">MAXVALUE</code>上限值的升序列出的多个范围分区添加到范围分区或复合范围分区表的高端（在最后一个现有分区之后）。同样，如果<code class="codeph">DEFAULT</code>分区不存在，则可以使用新的分区值集将多个列表分区添加到表中。
                        </p>
                        <p>通过指定单个分区，可以使用单个SQL语句添加多个系统分区。例如，以下SQL语句将多个分区添加到<a href="partition-create-tables-indexes.html#GUID-F0BCECA4-A485-4DA2-863A-6DB7C064059C__CHDJDFAF">示例4-1</a>中创建的范围分区<code class="codeph">sales</code>表中：</p><pre class="oac_no_warn" dir="ltr">ALTER TABLE销售额增加PARTITION sales_q1_2007价值低于（截止日期（'01-APR-2007'，'dd-MON-yyyy'）），PARTITION sales_q2_2007价值低于（2007年7月1日'，'d-2007'，'dd-MON -yyyy'）），PARTITION sales_q3_2007价值不到（截止日期（'01 -OCT-2007'，'dd-MON-yyyy'）），PARTITION sales_q4_2007价值不到（截止日期为（'01 -JAN-2008'，'dd） -MON-yyyy'））;</pre><p>您可以使用<code class="codeph">BEFORE</code>子句仅为一个现有分区添加多个新系统分区。以下SQL语句提供了使用<code class="codeph">BEFORE</code>子句添加多个单独分区的示例：</p><pre class="oac_no_warn" dir="ltr">CREATE TABLE system_part_tab1（number1 integer，number2 integer）PARTITION BY SYSTEM（PARTITION p1，PARTITION p2，PARTITION p3，PARTITION p_last）; ALTER TABLE system_part_tab1在分区之前添加分区p4，分区p5，分区p6 p_last; SELECT SUBSTR（TABLE_NAME，1,18）table_name，TABLESPACE_NAME，SUBSTR（PARTITION_NAME，1,16）partition_name FROM USER_TAB_PARTITIONS WHERE TABLE_NAME ='SYSTEM_PART_TAB1'; TABLE_NAME TABLESPACE_NAME PARTITION_NAME ------------------ ----------------------------- -  ---------------- SYSTEM_PART_TAB1 USERS P_LAST SYSTEM_PART_TAB1 USERS P6 SYSTEM_PART_TAB1 USERS P5 SYSTEM_PART_TAB1 USERS P4 SYSTEM_PART_TAB1 USERS P3 SYSTEM_PART_TAB1 USERS P2 SYSTEM_PART_TAB1 USERS P1</pre></div>
                     <!-- class="section" -->
                  </div>
               </div>
            </div><a id="VLDBG1141"></a><div class="props_rev_3"><a id="GUID-229CCB70-4799-4E0D-B98E-FD52750BC483" name="GUID-229CCB70-4799-4E0D-B98E-FD52750BC483"></a><h3 id="VLDBG-GUID-229CCB70-4799-4E0D-B98E-FD52750BC483" class="sect3">关于合并分区和子分区</h3>
               <div>
                  <p>合并分区是一种减少散列分区表或索引中分区数量或* -hash分区表中子分区数量的方法。</p>
                  <p>当散列分区被合并时，其内容被重新分配到由散列函数确定的一个或多个剩余分区中。合并的特定分区由数据库选择，并在其内容重新分发后删除。如果在引用分区表定义的父表中合并散列分区或子分区，则引用分区表会自动继承新分区定义。</p>
                  <p>索引分区可能标记为<code class="codeph">UNUSABLE</code> ，如下表所述：</p>
                  <div class="tblformal" id="GUID-229CCB70-4799-4E0D-B98E-FD52750BC483__GUID-50E6E81C-521D-4F8F-AECA-48EF13EC9DB7">
                     <table cellpadding="4" cellspacing="0" class="Formal" title="" width="100%" border="1" summary="Column 1 lists the table type, column 2 lists the indexes behavior when the index is marked unusable." frame="hsides" rules="rows">
                        <thead>
                           <tr align="left" valign="top">
                              <th align="left" valign="bottom" width="23%" id="d29958e2462">表类型</th>
                              <th align="left" valign="bottom" width="77%" id="d29958e2465">指数行为</th>
                           </tr>
                        </thead>
                        <tbody>
                           <tr align="left" valign="top">
                              <td align="left" valign="top" width="23%" id="d29958e2470" headers="d29958e2462 ">
                                 <p>常规（堆）</p>
                              </td>
                              <td align="left" valign="top" width="77%" headers="d29958e2470 d29958e2465 ">
                                 <p>除非您将<code class="codeph">UPDATE</code> <code class="codeph">INDEXES</code>指定为<code class="codeph">ALTER</code> <code class="codeph">TABLE</code>语句的一部分：</p>
                                 <ul style="list-style-type:disc">
                                    <li>
                                       <p>还会删除与所选分区对应的任何本地索引分区。对应于一个或多个吸收分区的本地索引分区标记为<code class="codeph">UNUSABLE</code> ，必须重建。
                                       </p>
                                    </li>
                                    <li>
                                       <p>所有全局索引或分区全局索引的所有分区都标记为<code class="codeph">UNUSABLE</code> ，必须重建。
                                       </p>
                                    </li>
                                 </ul>
                              </td>
                           </tr>
                           <tr align="left" valign="top">
                              <td align="left" valign="top" width="23%" id="d29958e2502" headers="d29958e2462 ">
                                 <p>索引组织</p>
                              </td>
                              <td align="left" valign="top" width="77%" headers="d29958e2502 d29958e2465 ">
                                 <ul style="list-style-type:disc">
                                    <li>
                                       <p>如堆堆索引所述，某些本地索引标记为<code class="codeph">UNUSABLE</code> 。
                                       </p>
                                    </li>
                                    <li>
                                       <p>所有全局索引仍然可用。</p>
                                    </li>
                                 </ul>
                              </td>
                           </tr>
                        </tbody>
                     </table>
                  </div>
                  <!-- class="inftblhruleinformal" -->
                  <p>本节包含以下主题：</p>
                  <ul style="list-style-type:disc">
                     <li>
                        <p><a href="maintenance-partition-tables-indexes.html#GUID-8BAB2AF6-6AB8-4B15-89C6-56DDA52487EF" title="ALTER TABLE COALESCE PARTITION语句用于合并散列分区表中的分区。">在哈希分区表中合并分区</a></p>
                     </li>
                     <li>
                        <p><a href="maintenance-partition-tables-indexes.html#GUID-5B2B765D-57C4-4600-991D-461E52C1A9ED" title="ALTER TABLE COALESCE SUBPARTITION语句用于合并散列分区表中的子分区。">在* -Hash分区表中合并子分区</a></p>
                     </li>
                     <li>
                        <p><a href="maintenance-partition-tables-indexes.html#GUID-320603FD-0A7B-409D-A5E3-22C5D98E5A5A" title="您可以使用ALTER INDEX的COALESCE PARTITION子句指示数据库将散列分区全局索引中的索引分区数减少一。">合并散列分区全局索引</a></p>
                     </li>
                  </ul>
               </div><a id="VLDBG1142"></a><div class="props_rev_3"><a id="GUID-8BAB2AF6-6AB8-4B15-89C6-56DDA52487EF" name="GUID-8BAB2AF6-6AB8-4B15-89C6-56DDA52487EF"></a><h4 id="VLDBG-GUID-8BAB2AF6-6AB8-4B15-89C6-56DDA52487EF" class="sect4">在哈希分区表中合并分区</h4>
                  <div>
                     <p><code class="codeph">ALTER</code> <code class="codeph">TABLE</code> <code class="codeph">COALESCE</code> <code class="codeph">PARTITION</code>语句用于合并散列分区表中的分区。
                     </p>
                     <div class="section">
                        <p>以下语句通过合并分区将表中的分区数减少一个。</p><pre class="oac_no_warn" dir="ltr">ALTER TABLE ouu1 COALESCE PARTITION;</pre></div>
                     <!-- class="section" -->
                  </div>
               </div><a id="VLDBG1143"></a><div class="props_rev_3"><a id="GUID-5B2B765D-57C4-4600-991D-461E52C1A9ED" name="GUID-5B2B765D-57C4-4600-991D-461E52C1A9ED"></a><h4 id="VLDBG-GUID-5B2B765D-57C4-4600-991D-461E52C1A9ED" class="sect4">在* -Hash分区表中合并子分区</h4>
                  <div>
                     <p><code class="codeph">ALTER</code> <code class="codeph">TABLE</code> <code class="codeph">COALESCE</code> <code class="codeph">SUBPARTITION</code>语句用于合并散列分区表中的子分区。
                     </p>
                     <div class="section">
                        <p>以下语句将分区<code class="codeph">us_locations</code>的子分区的内容分发到同一分区的一个或多个剩余子分区（由散列函数确定）。对于区间分区表，您只能合并实现范围或间隔分区的哈希子分区。基本上，此操作与将子<code class="codeph">PARTITION</code> <a href="maintenance-partition-tables-indexes.html#GUID-FCD53D58-461E-4555-A8CC-77B2B181232D" title="Use the MODIFY PARTITION ADD SUBPARTITION clause of the ALTER TABLE statement to add a hash subpartition to a [range | list | interval]-hash partitioned table.">添加到* -Hash分区表中</a>讨论的<code class="codeph">MODIFY</code> <code class="codeph">PARTITION</code> <code class="codeph">ADD</code> <code class="codeph">SUBPARTITION</code>子句的<a href="maintenance-partition-tables-indexes.html#GUID-FCD53D58-461E-4555-A8CC-77B2B181232D" title="使用ALTER TABLE语句的MODIFY PARTITION ADD SUBPARTITION子句将哈希子分区添加到[range |列表| interval] -hash分区表。">反转</a> 。
                        </p><pre class="oac_no_warn" dir="ltr">ALTER TABLE潜水MODIFY PARTITION us_locations COALESCE SUBPARTITION;</pre></div>
                     <!-- class="section" -->
                  </div>
               </div><a id="VLDBG1144"></a><div class="props_rev_3"><a id="GUID-320603FD-0A7B-409D-A5E3-22C5D98E5A5A" name="GUID-320603FD-0A7B-409D-A5E3-22C5D98E5A5A"></a><h4 id="VLDBG-GUID-320603FD-0A7B-409D-A5E3-22C5D98E5A5A" class="sect4">合并散列分区全局索引</h4>
                  <div>
                     <p>您可以使用<code class="codeph">ALTER</code> <code class="codeph">INDEX</code>的<code class="codeph">COALESCE</code> <code class="codeph">PARTITION</code>子句指示数据库将散列分区全局索引中的索引分区数减少一。</p>
                     <div class="section">
                        <p>数据库根据散列分区的要求选择要合并的分区。以下语句将<a href="partition-create-tables-indexes.html#GUID-A8991A7A-CEC0-4C6D-A886-17E0554BB3C6" title="Hash partitioned global indexes can improve the performance of indexes where a small number of leaf blocks in the index have high contention in multiuser OLTP environments.">创建哈希分区全局索引</a>中<a href="partition-create-tables-indexes.html#GUID-A8991A7A-CEC0-4C6D-A886-17E0554BB3C6" title="散列分区全局索引可以提高索引的性能，其中索引中的少量叶块在多用户OLTP环境中具有高争用。">创建</a>的<code class="codeph">hgidx</code>索引中的分区数减少一个：</p><pre class="oac_no_warn" dir="ltr">ALTER INDEX hgidx COALESCE PARTITION;</pre></div>
                     <!-- class="section" -->
                  </div>
               </div>
            </div><a id="VLDBG1145"></a><div class="props_rev_3"><a id="GUID-BAFFE31C-07A2-4ED6-BDCF-8ECB79D7FE7D" name="GUID-BAFFE31C-07A2-4ED6-BDCF-8ECB79D7FE7D"></a><h3 id="VLDBG-GUID-BAFFE31C-07A2-4ED6-BDCF-8ECB79D7FE7D" class="sect3">关于删除分区和子分区</h3>
               <div>
                  <p>您可以从范围，间隔，列表或复合*中删除分区 -  [范围| list]分区表。</p>
                  <p>对于间隔分区表，您只能删除已实现的范围或间隔分区。对于散列分区表或复合* -hash分区表的哈希子分区，您必须执行合并操作。</p>
                  <p>您不能从引用分区表中删除分区。相反，父表上的放置操作级联到所有后代表。</p>
                  <p>本节包含以下主题：</p>
                  <ul style="list-style-type:disc">
                     <li>
                        <p><a href="maintenance-partition-tables-indexes.html#GUID-9E40E1DD-2844-4298-8897-86ED66F293DB" title="要删除表分区，请将DROP PARTITION或DROP SUBPARTITION与ALTER TABLE SQL语句一起使用。">丢弃表分区</a></p>
                     </li>
                     <li>
                        <p><a href="maintenance-partition-tables-indexes.html#GUID-09F5641F-821D-4971-81F8-583F7CD9CAA2" title="您可以在间隔分区表中删除间隔分区。">删除间隔分区</a></p>
                     </li>
                     <li>
                        <p><a href="maintenance-partition-tables-indexes.html#GUID-8F00310E-643E-4142-A4D8-68E2DF1FBEBE" title="您无法显式删除本地索引的分区。相反，仅当从基础表中删除分区时，才会删除本地索引分区。">删除索引分区</a></p>
                     </li>
                     <li>
                        <p><a href="maintenance-partition-tables-indexes.html#GUID-D413FE9E-7FFA-41E6-BA1B-E2C88095A947" title="您可以使用SQL ALTER TABLE语句的DROP PARTITION和DROP SUBPARTITION子句从范围或列表分区表中删除多个分区或子分区。">删除多个分区</a></p>
                     </li>
                  </ul>
               </div><a id="VLDBG1146"></a><div class="props_rev_3"><a id="GUID-9E40E1DD-2844-4298-8897-86ED66F293DB" name="GUID-9E40E1DD-2844-4298-8897-86ED66F293DB"></a><h4 id="VLDBG-GUID-9E40E1DD-2844-4298-8897-86ED66F293DB" class="sect4">丢弃表分区</h4>
                  <div>
                     <p>要删除表分区， <code class="codeph">SUBPARTITION</code> <code class="codeph">DROP</code> <code class="codeph">PARTITION</code>或<code class="codeph">DROP</code> <code class="codeph">SUBPARTITION</code>与<code class="codeph">ALTER</code> <code class="codeph">TABLE</code> SQL语句一起使用。
                     </p>
                     <p>以下语句删除表分区或子分区：</p>
                     <ul style="list-style-type:disc">
                        <li>
                           <p><code class="codeph">ALTER</code> <code class="codeph">TABLE</code> <code class="codeph">DROP</code> <code class="codeph">PARTITION</code>删除表分区</p>
                        </li>
                        <li>
                           <p><code class="codeph">ALTER</code> <code class="codeph">TABLE</code> <code class="codeph">DROP</code> <code class="codeph">SUBPARTITION</code>删除复合的子分区*  -  [range | list]分区表</p>
                        </li>
                     </ul>
                     <p>要保留分区中的数据，请使用<code class="codeph">MERGE</code> <code class="codeph">PARTITION</code>语句而不是<code class="codeph">DROP</code> <code class="codeph">PARTITION</code>语句。
                     </p>
                     <p>要删除分区中的数据而不删除分区，请使用<code class="codeph">TRUNCATE</code> <code class="codeph">PARTITION</code>语句。
                     </p>
                     <p>如果为表定义了本地索引，则此语句还会从本地索引中删除匹配的分区或子分区。除非满足以下任一条件，否则所有全局索引或分区全局索引的所有分区都标记为<code class="codeph">UNUSABLE</code> ：</p>
                     <ul style="list-style-type:disc">
                        <li>
                           <p>您指定<code class="codeph">UPDATE</code> <code class="codeph">INDEXES</code> （不能为索引组织表指定。请改用<code class="codeph">UPDATE</code> <code class="codeph">GLOBAL</code> <code class="codeph">INDEXES</code> 。）
                           </p>
                        </li>
                        <li>
                           <p>要删除的分区或其子分区为空</p>
                           <div class="infoboxnote" id="GUID-9E40E1DD-2844-4298-8897-86ED66F293DB__GUID-EF634043-5D37-4199-9371-AA8BCE9819D7">
                              <p class="notep1">注意：</p>
                              <p></p>
                              <ul style="list-style-type:disc">
                                 <li>
                                    <p>如果表只包含一个分区，则不能删除该分区。相反，你必须放弃表格。</p>
                                 </li>
                                 <li>
                                    <p>您不能删除interval-partitioned或interval- * composite分区表的range-partitioned部分中的最高范围分区。</p>
                                 </li>
                                 <li>
                                    <p>使用异步全局索引维护时，删除分区更新索引操作仅适用于元数据，并且所有全局索引仍然有效。</p>
                                 </li>
                              </ul>
                           </div>
                        </li>
                     </ul>
                     <p>以下部分包含一些删除表分区的方案。</p>
                     <ul style="list-style-type:disc">
                        <li>
                           <p><a href="maintenance-partition-tables-indexes.html#GUID-40D491DB-7965-4935-AB7A-F8D2DADA33C0" title="您可以使用多种方法从包含数据和全局索引的表中删除分区。">从包含数据和全局索引的表中删除分区</a></p>
                        </li>
                        <li>
                           <p><a href="maintenance-partition-tables-indexes.html#GUID-D2FC4255-EF84-4AEC-889C-F7D4B555A75F" title="您可以使用多种方法删除包含数据和参照完整性约束的分区。">删除包含数据和参照完整性约束的分区</a></p>
                        </li>
                     </ul>
                     <div class="infoboxnotealso" id="GUID-9E40E1DD-2844-4298-8897-86ED66F293DB__GUID-34D94A0C-8DC5-4784-845B-DBFFE4F05F3E">
                        <p class="notep1">也可以看看：</p>
                        <ul style="list-style-type:disc">
                           <li>
                              <p><a href="maintenance-partition-tables-indexes.html#GUID-0E7793F7-B38A-427E-846B-7A8651F2A523" title="使用ALTER TABLE MERGE PARTITION和SUBPARTITION SQL语句合并两个分区或子分区的内容。">关于合并分区和子分区</a>以获取有关合并分区的信息</p>
                           </li>
                           <li>
                              <p><a href="maintenance-partition-tables-indexes.html#GUID-08DC6C40-64B8-4932-8FB6-E22BDC8F842B" title="截断分区类似于删除分区，除了分区清空其数据，但没有物理丢弃。">关于截断分区和子分区</a>以获取有关截断分区的信息</p>
                           </li>
                           <li>
                              <p><a href="maintenance-partition-can-be-performed.html#GUID-087B87A6-959A-40C6-82AF-36E401FD089B" title="通过仅对元数据进行索引维护来优化分区维护操作DROP PARTITION和TRUNCATE PARTITION。">用于删除和截断分区的异步全局索引维护，</a>以获取有关删除分区的异步索引维护的信息</p>
                           </li>
                        </ul>
                     </div>
                  </div><a id="VLDBG1148"></a><a id="VLDBG1149"></a><a id="VLDBG1150"></a><a id="VLDBG1147"></a><div class="props_rev_3"><a id="GUID-40D491DB-7965-4935-AB7A-F8D2DADA33C0" name="GUID-40D491DB-7965-4935-AB7A-F8D2DADA33C0"></a><h5 id="VLDBG-GUID-40D491DB-7965-4935-AB7A-F8D2DADA33C0" class="sect5">从包含数据和全局索引的表中删除分区</h5>
                     <div>
                        <p>您可以使用多种方法从包含数据和全局索引的表中删除分区。</p>
                        <div class="section">
                           <p>如果分区包含数据并且在表上定义了一个或多个全局索引，则使用以下方法之一（方法1,2或3）删除表分区。</p>
                        </div>
                        <!-- class="section" -->
                        <div class="section">
                           <p class="subhead3" id="GUID-40D491DB-7965-4935-AB7A-F8D2DADA33C0__GUID-7B087ED8-EF71-48B2-B134-45070AB45A8E">方法1</p>
                        </div>
                        <!-- class="section" -->
                        <div class="section">
                           <p>发出<code class="codeph">ALTER</code> <code class="codeph">TABLE</code> <code class="codeph">DROP</code> <code class="codeph">PARTITION</code>语句而不维护全局索引。之后，您必须重建任何全局索引（无论是否已分区），因为索引（或索引分区）已标记为<code class="codeph">UNUSABLE</code> 。以下语句提供了从<code class="codeph">sales</code>表中删除分区<code class="codeph">dec98</code> ，然后重建其全局非分区索引的示例。
                           </p><pre class="oac_no_warn" dir="ltr">ALTER TABLE销售DROP PARTITION dec98; ALTER INDEX sales_area_ix REBUILD;</pre><p>如果索引<code class="codeph">sales_area_ix</code>是范围分区的全局索引，则索引的所有分区都需要重建。此外，无法在一个语句中重建索引的所有分区。您必须为索引中的每个分区发出单独的<code class="codeph">REBUILD</code>语句。以下语句将索引分区<code class="codeph">jan99_ix</code>重建为<code class="codeph">dec99_ix</code> 。
                           </p><pre class="oac_no_warn" dir="ltr">ALTER INDEX sales_area_ix REBUILD PARTITION jan99_ix; ALTER INDEX sales_area_ix REBUILD PARTITION feb99_ix; ALTER INDEX sales_area_ix REBUILD PARTITION mar99_ix; ...ALTER INDEX sales_area_ix REBUILD PARTITION dec99_ix;</pre><p>此方法最适用于大型表，其中被删除的分区包含表中总数据的很大一部分。虽然异步全局索引维护可以在不需要任何索引维护的情况下保持全局索引有效，但必须使用<code class="codeph">UPDATE</code> <code class="codeph">INDEXES</code>子句来启用此新功能。此行为可确保向后兼容性。
                           </p>
                        </div>
                        <!-- class="section" -->
                        <div class="section">
                           <p class="subhead3" id="GUID-40D491DB-7965-4935-AB7A-F8D2DADA33C0__GUID-B92F6A37-4E05-44DE-8A9C-7E03DEA53EFA">方法2</p>
                        </div>
                        <!-- class="section" -->
                        <div class="section">
                           <p>在发出<code class="codeph">ALTER</code> <code class="codeph">TABLE</code> <code class="codeph">DROP</code> <code class="codeph">PARTITION</code>语句之前，发出<code class="codeph">DELETE</code>语句以从分区中删除所有行。<code class="codeph">DELETE</code>语句更新全局索引。
                           </p>
                           <p>例如，要删除第一个分区，请发出以下语句：</p><pre class="oac_no_warn" dir="ltr">DELETE FROM sales partition（dec98）; ALTER TABLE销售DROP PARTITION dec98;</pre><p>当丢弃的分区包含表中总数据的一小部分时，此方法最适用于小型表或大型表。</p>
                        </div>
                        <!-- class="section" -->
                        <div class="section">
                           <p class="subhead3" id="GUID-40D491DB-7965-4935-AB7A-F8D2DADA33C0__GUID-38285045-3EFA-4CF9-A8C6-FB98A4884820">方法3</p>
                        </div>
                        <!-- class="section" -->
                        <div class="section">
                           <p>在<code class="codeph">ALTER</code> <code class="codeph">TABLE</code>语句中指定<code class="codeph">UPDATE</code> <code class="codeph">INDEXES</code> 。这样做可以利用新的异步全局索引维护。索引仍然有效。
                           </p><pre class="oac_no_warn" dir="ltr">ALTER TABLE销售DROP PARTITION dec98 UPDATE INDEXES;</pre></div>
                        <!-- class="section" -->
                     </div>
                  </div><a id="VLDBG1152"></a><a id="VLDBG1153"></a><a id="VLDBG1151"></a><div class="props_rev_3"><a id="GUID-D2FC4255-EF84-4AEC-889C-F7D4B555A75F" name="GUID-D2FC4255-EF84-4AEC-889C-F7D4B555A75F"></a><h5 id="VLDBG-GUID-D2FC4255-EF84-4AEC-889C-F7D4B555A75F" class="sect5">删除包含数据和参照完整性约束的分区</h5>
                     <div>
                        <p>您可以使用多种方法删除包含数据和参照完整性约束的分区。</p>
                        <div class="section">
                           <p>如果分区包含数据且表具有参照完整性约束，请选择以下方法之一（方法1或2）以删除表分区。此表仅具有本地索引，因此无需重建任何索引。</p>
                        </div>
                        <!-- class="section" -->
                        <div class="section">
                           <p class="subhead3" id="GUID-D2FC4255-EF84-4AEC-889C-F7D4B555A75F__GUID-AF4B1B6D-EAEB-491F-8C38-02D1CB7897CC">方法1</p>
                        </div>
                        <!-- class="section" -->
                        <div class="section">
                           <p>如果没有数据引用要删除的分区中的数据，则可以禁用引用表上的完整性约束，发出<code class="codeph">ALTER</code> <code class="codeph">TABLE</code> <code class="codeph">DROP</code> <code class="codeph">PARTITION</code>语句，然后重新启用完整性约束。
                           </p>
                           <p>此方法最适用于大型表，其中被删除的分区包含表中总数据的很大一部分。如果仍有数据引用要删除的分区中的数据，请确保删除所有引用数据，以便可以重新启用引用完整性约束。</p>
                        </div>
                        <!-- class="section" -->
                        <div class="section">
                           <p class="subhead3" id="GUID-D2FC4255-EF84-4AEC-889C-F7D4B555A75F__GUID-E4878DAD-6CD9-4291-9A6B-D36EC3B91D60">方法2</p>
                        </div>
                        <!-- class="section" -->
                        <div class="section">
                           <p>如果引用表中有数据，则可以在发出<code class="codeph">ALTER</code> <code class="codeph">TABLE</code> <code class="codeph">DROP</code> <code class="codeph">PARTITION</code>语句之前发出<code class="codeph">DELETE</code>语句以从分区中删除所有行。<code class="codeph">DELETE</code>语句强制执行参照完整性约束，还会触发触发器并生成重做和撤消日志。如果使用<code class="codeph">ON DELETE CASCADE</code>选项创建约束，则删除可以成功，同时删除引用表中的所有行。
                           </p><pre class="oac_no_warn" dir="ltr">DELETE FROM sales partition（dec94）; ALTER TABLE销售DROP PARTITION dec94;</pre><p>当被删除的分区包含表中总数据的一小部分时，此方法最适合小表或大表。</p>
                        </div>
                        <!-- class="section" -->
                     </div>
                  </div>
               </div><a id="VLDBG1154"></a><div class="props_rev_3"><a id="GUID-09F5641F-821D-4971-81F8-583F7CD9CAA2" name="GUID-09F5641F-821D-4971-81F8-583F7CD9CAA2"></a><h4 id="VLDBG-GUID-09F5641F-821D-4971-81F8-583F7CD9CAA2" class="sect4">删除间隔分区</h4>
                  <div>
                     <p>您可以在间隔分区表中删除间隔分区。</p>
                     <div class="section">
                        <p>此操作仅删除间隔的数据，并保留间隔定义。如果在刚刚删除的时间间隔中插入数据，则数据库将再次创建间隔分区。</p>
                        <p>您还可以在区间分区表中删除范围分区。在区间分区表中删除范围分区的规则遵循在范围分区表中删除范围分区的规则。如果将范围分区放在一组范围分区的中间，则下一个范围分区的下边界将移至刚刚删除的范围分区的下边界。您不能删除区间分区表的范围分区部分中的最高范围分区。</p>
                        <p>以下示例从<code class="codeph">sales</code>表中删除了September 2007间隔分区。只有本地索引，因此没有索引无效。
                        </p><pre class="oac_no_warn" dir="ltr">ALTER TABLE销售DROP PARTITION FOR（TO_DATE（'01 -SEP-2007'，'dd-MON-yyyy'））;</pre></div>
                     <!-- class="section" -->
                  </div>
               </div><a id="VLDBG1155"></a><div class="props_rev_3"><a id="GUID-8F00310E-643E-4142-A4D8-68E2DF1FBEBE" name="GUID-8F00310E-643E-4142-A4D8-68E2DF1FBEBE"></a><h4 id="VLDBG-GUID-8F00310E-643E-4142-A4D8-68E2DF1FBEBE" class="sect4">删除索引分区</h4>
                  <div>
                     <p>您无法显式删除本地索引的分区。相反，仅当从基础表中删除分区时，才会删除本地索引分区。</p>
                     <div class="section">
                        <p>如果全局索引分区为空，则可以通过发出<code class="codeph">ALTER</code> <code class="codeph">INDEX</code> <code class="codeph">DROP</code> <code class="codeph">PARTITION</code>语句显式删除它。但是，如果全局索引分区包含数据，则删除分区会导致下一个最高分区标记为<code class="codeph">UNUSABLE</code> 。例如，您希望删除索引分区P1，P2是下一个最高分区。您必须发出以下声明：</p><pre class="oac_no_warn" dir="ltr">ALTER INDEX npr DROP PARTITION P1; ALTER INDEX npr REBUILD PARTITION P2;</pre><div class="infoboxnote" id="GUID-8F00310E-643E-4142-A4D8-68E2DF1FBEBE__GUID-FF702298-FE8E-469C-9723-58D9450F65D5">
                           <p class="notep1">注意：</p>
                           <p>您不能删除全局索引中的最高分区。</p>
                        </div>
                     </div>
                     <!-- class="section" -->
                  </div>
               </div><a id="VLDBG14110"></a><div class="props_rev_3"><a id="GUID-D413FE9E-7FFA-41E6-BA1B-E2C88095A947" name="GUID-D413FE9E-7FFA-41E6-BA1B-E2C88095A947"></a><h4 id="VLDBG-GUID-D413FE9E-7FFA-41E6-BA1B-E2C88095A947" class="sect4">删除多个分区</h4>
                  <div>
                     <p>您可以使用SQL <code class="codeph">ALTER</code> <code class="codeph">TABLE</code>语句的<code class="codeph">DROP</code> <code class="codeph">PARTITION</code>和<code class="codeph">DROP</code> <code class="codeph">SUBPARTITION</code>子句从范围或列表分区表中删除多个分区或子分区。
                     </p>
                     <div class="section">
                        <p>例如，以下SQL语句从范围分区表<code class="codeph">sales</code>删除多个分区。
                        </p><pre class="oac_no_warn" dir="ltr">ALTER TABLE sales DROP PARTITION sales_q1_2008，sales_q2_2008，sales_q3_2008，sales_q4_2008;</pre><p>您不能删除表的所有分区。删除多个分区时，本地和全局索引操作与删除单个分区时相同。</p>
                     </div>
                     <!-- class="section" -->
                  </div>
               </div>
            </div><a id="VLDBG1156"></a><div class="props_rev_3"><a id="GUID-E08650B4-06B1-43F9-91B0-FBF685A3B848" name="GUID-E08650B4-06B1-43F9-91B0-FBF685A3B848"></a><h3 id="VLDBG-GUID-E08650B4-06B1-43F9-91B0-FBF685A3B848" class="sect3">关于交换分区和子分区</h3>
               <div>
                  <p>您可以通过交换数据段将分区或子分区转换为非分区表，将非分区表转换为分区表的分区或子分区。</p>
                  <p>您还可以将散列分区表转换为复合* -hash分区表的分区，或将复合* -hash分区表的分区转换为散列分区表。同样，您可以将范围或列表分区表转换为复合* -range或-list分区表的分区，或将复合* -range或-list分区表的分区转换为范围或列表 - 分区表。</p>
                  <p>交换表分区对于快速进出分区表的数据非常有用。例如，在数据仓库环境中，交换分区有助于将新的增量数据高速数据加载到现有分区表中。</p>
                  <p>OLTP和数据仓库环境受益于从分区表中交换旧数据分区。数据从分区表中清除，实际上没有被删除，之后可以单独归档。</p>
                  <p>交换分区时，将保留日志记录属性。您可以选择指定是否还要使用<code class="codeph">INCLUDING</code> <code class="codeph">INDEXES</code>子句交换本地索引，以及是否要<code class="codeph">WITH</code> <code class="codeph">VALIDATION</code>子句验证行是否正确映射。
                  </p>
                  <div class="infoboxnote" id="GUID-E08650B4-06B1-43F9-91B0-FBF685A3B848__GUID-1C179196-F91F-4219-8927-9F21CA848076">
                     <p class="notep1">注意：</p>
                     <p>为交换分区操作指定<code class="codeph">WITHOUT</code> <code class="codeph">VALIDATION</code> ，这通常是一个快速操作，因为它只涉及数据字典更新。但是，如果交换操作中涉及的表或分区表启用了主键或唯一约束，则执行交换操作，就像指定<code class="codeph">WITH</code> <code class="codeph">VALIDATION</code>以维护约束的完整性一样。
                     </p>
                     <p>要避免此验证活动的开销，请在执行交换分区操作之前为每个约束发出以下语句：</p><pre class="oac_no_warn" dir="ltr">ALTER TABLE <span class="italic">table_name</span> DISABLE CONSTRAINT <span class="italic">constraint_name</span> KEEP INDEX</pre><p>在交换后启用约束。</p>
                     <p>如果指定<code class="codeph">WITHOUT</code> <code class="codeph">VALIDATION</code> ，则必须确保要交换的数据属于您交换的分区。
                     </p>
                  </div>
                  <p>除非指定<code class="codeph">UPDATE</code> <code class="codeph">INDEXES</code> ，否则Oracle数据库<code class="codeph">UNUSABLE</code>正在将其分区交换为<code class="codeph">UNUSABLE</code>的表上的全局索引或所有全局索引分区进行标记。正在交换的表上的全局索引或全局索引分区仍然无效。
                  </p>
                  <p>您不能将<code class="codeph">UPDATE</code> <code class="codeph">INDEXES</code>用于索引组织表。请改用<code class="codeph">UPDATE</code> <code class="codeph">GLOBAL</code> <code class="codeph">INDEXES</code> 。
                  </p>
                  <p>如果在<code class="codeph">DBMS_STATS</code>表首选项<code class="codeph">INCREMENTAL</code>设置为true且<code class="codeph">INCREMENTAL_LEVEL</code>设置为<code class="codeph">TABLE</code>时在非分区表上收集统计信息，则使用分区交换操作维护分区表的增量统计信息。</p>
                  <div class="infoboxnote" id="GUID-E08650B4-06B1-43F9-91B0-FBF685A3B848__GUID-9EED4704-31E4-495F-B8CB-3018B18026E3">
                     <p class="notep1">注意：</p>
                     <p>在虚拟列的列统计信息出现故障的情况下，将删除列统计信息，而不是保留过时的统计信息。有关此删除的信息将写入警报日志文件。</p>
                  </div>
                  <p>本节包含以下主题：</p>
                  <ul style="list-style-type:disc">
                     <li>
                        <p><a href="maintenance-partition-tables-indexes.html#GUID-2DE24EE4-00EB-4D58-A428-8E6CBD7E7F34" title="可以使用FOR EXCHANGE WITH子句创建表，以与分区表的形状完全匹配，并且可以使用分区交换命令。但是，索引不会创建为此命令的操作。">使用分区表创建Exchange表</a></p>
                     </li>
                     <li>
                        <p><a href="maintenance-partition-tables-indexes.html#GUID-E8E3BD50-0C7C-4B8E-A673-9E38D3A8B8EF" title="要使用非分区表交换范围，散列或列表分区表的分区，或者反过来，请使用ALTER TABLE EXCHANGE PARTITION语句。">交换范围，哈希或列表分区</a></p>
                     </li>
                     <li>
                        <p><a href="maintenance-partition-tables-indexes.html#GUID-9A05E5AB-3A08-4502-A25B-4246E26CA2C0" title="您可以在间隔分区表中交换间隔分区。但是，必须确保已创建间隔分区，然后才能交换分区。">交换区间分区表的分区</a></p>
                     </li>
                     <li>
                        <p><a href="maintenance-partition-tables-indexes.html#GUID-09CE9F52-A5BE-4CFD-8164-867CAF96DDCF" title="您可以在引用分区表中交换分区，但必须确保您引用的数据在父表的相应分区中可用。">交换参考分区表的分区</a></p>
                     </li>
                     <li>
                        <p><a href="maintenance-partition-tables-indexes.html#GUID-77DFC31D-D3CD-44D8-A567-3617F59B2D06" title="您可以在存在虚拟列的情况下交换分区。">关于使用虚拟列交换表的分区</a></p>
                     </li>
                     <li>
                        <p><a href="maintenance-partition-tables-indexes.html#GUID-8E3836CA-6C40-4058-88C1-9D14E410128F" title="您可以使用* -hash分区表的分区及其所有哈希子分区来交换整个哈希分区表及其所有分区。">使用* -Hash分区交换哈希分区表</a></p>
                     </li>
                     <li>
                        <p><a href="maintenance-partition-tables-indexes.html#GUID-35E940E6-03F8-4205-B9E3-365F444DEF89" title="您可以使用ALTER TABLE EXCHANGE SUBPARTITION语句将* -hash分区表的哈希子分区转换为非分区表，反之亦然。">交换* -Hash分区表的子分区</a></p>
                     </li>
                     <li>
                        <p><a href="maintenance-partition-tables-indexes.html#GUID-24597C75-958D-4AE7-830D-0B24E5ECF1F1" title="您可以使用ALTER TABLE EXCHANGE PARTITION语句将列表分区表与* -list分区交换。">使用* -List分区交换列表分区表</a></p>
                     </li>
                     <li>
                        <p><a href="maintenance-partition-tables-indexes.html#GUID-B0AD8D31-07A7-4BA4-8E7A-3FC72DA87158" title="您可以使用ALTER TABLE EXCHANGE SUBPARTITION语句来交换* -list分区表的子分区。">关于交换* -List分区表的子分区</a></p>
                     </li>
                     <li>
                        <p><a href="maintenance-partition-tables-indexes.html#GUID-ACB2A5F0-D8BD-4E60-8C99-CE2AF382C8F6" title="您可以使用ALTER TABLE EXCHANGE PARTITION语句将范围分区的表与* -range分区交换。">使用* -Range分区交换范围分区表</a></p>
                     </li>
                     <li>
                        <p><a href="maintenance-partition-tables-indexes.html#GUID-CDB0D917-4AD4-49B6-972D-25B4A4FE3109" title="您可以使用ALTER TABLE EXCHANGE SUBPARTITION语句来交换* -range分区的子分区。">关于交换* -Range分区表的子分区</a></p>
                     </li>
                     <li>
                        <p><a href="maintenance-partition-tables-indexes.html#GUID-93BFB499-39A6-4DDE-88C3-BF7A63848E25" title="您可以使用ALTER TABLE EXCHANGE PARTITION和ALTER TABLE EXCHANGE SUBPARTITION SQL语句的CASCADE选项级联交换操作以引用分区子表。">关于使用级联选项交换分区</a></p>
                     </li>
                  </ul>
                  <div class="section">
                     <div class="infoboxnotealso" id="GUID-E08650B4-06B1-43F9-91B0-FBF685A3B848__GUID-0D5C9A72-F780-47C5-9A66-B5FCF3330115">
                        <p class="notep1">也可以看看：</p>
                        <p></p>
                        <ul style="list-style-type:disc">
                           <li>
                              <p><a href="view-info-partition-tables-indexes.html#GUID-2D424638-511C-4CC3-9BDE-53FFB1686ECD" title="You can display information about partitioned tables and indexes with Oracle Database views.">查看有关分区表和索引</a>的信息<a href="view-info-partition-tables-indexes.html#GUID-2D424638-511C-4CC3-9BDE-53FFB1686ECD" title="您可以使用Oracle数据库视图显示有关分区表和索引的信息。">，</a>以获取有关使用视图监视有关分区表和索引的详细信息的信息</p>
                           </li>
                           <li>
                              <p>有关增量统计信息的详细信息，请<a href="https://www.oracle.com/pls/topic/lookup?ctx=en/database/oracle/oracle-database/19/vldbg&amp;id=TGSQL413" target="_blank"><span><cite>参见“Oracle数据库SQL调优指</cite></span></a></p>
                           </li>
                           <li>
                              <p>有关<code class="codeph">DBMS_STATS</code>包的信息<a href="../arpls/DBMS_STATS.html#ARPLS-GUID-01FAB8ED-E4A3-4C3E-8FE2-88717DCDDA06" target="_blank"><span><cite>，请参见Oracle Database PL / SQL包和类型参考</cite></span></a></p>
                           </li>
                        </ul>
                     </div>
                  </div>
                  <!-- class="section" -->
               </div>
               <div class="sect3"><a id="GUID-2DE24EE4-00EB-4D58-A428-8E6CBD7E7F34" name="GUID-2DE24EE4-00EB-4D58-A428-8E6CBD7E7F34"></a><h4 id="VLDBG-GUID-2DE24EE4-00EB-4D58-A428-8E6CBD7E7F34" class="sect4">使用分区表创建Exchange表</h4>
                  <div>
                     <p>可以使用<code class="codeph">FOR</code> <code class="codeph">EXCHANGE</code> <code class="codeph">WITH</code>子句创建表，以与分区表的形状完全匹配，并且可以使用分区交换命令。但是，索引不会创建为此命令的操作。
                     </p>
                     <p>由于<code class="codeph">CREATE</code> <code class="codeph">TABLE</code>的<code class="codeph">FOR</code> <code class="codeph">EXCHANGE</code> <code class="codeph">WITH</code>子句提供了非分区表和分区表之间的精确匹配，因此这是对<code class="codeph">CREATE</code> <code class="codeph">TABLE</code> <code class="codeph">AS</code> <code class="codeph">SELECT</code>语句的改进。
                     </p>
                     <p>以下列表是<code class="codeph">CREATE</code> <code class="codeph">TABLE</code> <code class="codeph">FOR EXCHANGE WITH</code> DDL操作的效果摘要：</p>
                     <ul style="list-style-type:disc">
                        <li>
                           <p>此DDL操作的用例是为了便于创建用于交换分区DDL的表。</p>
                        </li>
                        <li>
                           <p>该操作根据列排序和列属性创建for exchange表的克隆。</p>
                        </li>
                        <li>
                           <p>列无法重命名。正在创建的表继承了for exchange表中的名称。</p>
                        </li>
                        <li>
                           <p>在DDL操作期间可以指定的唯一逻辑属性是表的分区规范。</p>
                           <p>partitioning子句仅与与复合分区表的分区交换相关。在这种情况下，具有<span class="italic">n</span>个子分区的分区与分区表交换，该分区表具有与子分区匹配的<span class="italic">n个</span>分区。在此方案中，您负责定义此交换的分区子句。
                           </p>
                           <p>子分区可以跨分区不对称。partitioning子句必须完全匹配要交换的分区的子分区。</p>
                        </li>
                        <li>
                           <p>可以指定的物理属性主要是表段属性。</p>
                        </li>
                        <li>
                           <p>使用此DDL操作复制的列属性包括但不限于以下内容：不可用列，不可见列，虚拟表达式列，功能索引表达式列以及其他内部设置和属性。</p>
                        </li>
                     </ul>
                     <p>以下是使用<code class="codeph">CREATE</code> <code class="codeph">TABLE</code>语句和<code class="codeph">FOR</code> <code class="codeph">EXCHANGE</code> <code class="codeph">WITH</code>子句创建表的示例，该表根据列排序和属性模拟现有表的形状。
                     </p>
                     <div class="example" id="GUID-2DE24EE4-00EB-4D58-A428-8E6CBD7E7F34__GUID-5A628646-19E6-4DF6-9057-57327C62EDB7">
                        <p class="titleinexample">示例4-30使用CREATE TABLE的FOR EXCHANGE WITH子句</p><pre class="oac_no_warn" dir="ltr">CREATE TABLE sales_by_year_table（prod_id NUMBER NOT NULL，cust_id NUMBER NOT NULL，time_id DATE NOT NULL，channel_id NUMBER NOT NULL，promo_id NUMBER NOT NULL，quantity_sold NUMBER（10,2）NOT NULL，amount_sold NUMBER（10,2）NOT NULL）PARTITION BY RANGE（time_id）（PARTITION sales_2016价值低于（截止日期（'01 -01-2017'，'dd-mm-yyyy'）），PARTITION sales_2017价值不到（截止日期为（01年01月1日，201日） -mm-yyyy'）），PARTITION sales_2018价值不到（截止日期（'01 -01-2019'，'dd-mm-yyyy'）），PARTITION sales_2019价值不到（截至_01  -  01-2020'， 'dd-mm-yyyy'）），PARTITION sales_future价值低于（MAXVALUE））; DESCRIBE sales_by_year_table名称是否为空？输入----------------------------------------- -------- ---------------------------- PROD_ID NOT NULL NUMBER CUST_ID NOT NULL NUMBER TIME_ID NOT NULL DATE CHANNEL_ID NOT NULL NUMBER PROMO_ID NOT NULL NUMBER QUANTITY_SOLD NOT NOT NULL NUMBER（10,2）AMOUNT_SOLD NOT NULL NUMBER（10,2）CREATE TABLE sales_later_year_table FOR EXCHANGE WITH TABLE sales_by_year_table; DESCRIBE sales_later_year_table名称是否为空？输入----------------------------------------- -------- ---------------------------- PROD_ID NOT NULL NUMBER CUST_ID NOT NULL NUMBER TIME_ID NOT NULL DATE CHANNEL_ID NOT NULL NUMBER PROMO_ID NOT NULL NUMBER QUANTITY_SOLD NOT NOT NULL NUMBER（10,2）AMOUNT_SOLD NOT NULL NUMBER（10,2）</pre></div>
                     <!-- class="example" -->
                  </div>
               </div><a id="VLDBG1157"></a><div class="props_rev_3"><a id="GUID-E8E3BD50-0C7C-4B8E-A673-9E38D3A8B8EF" name="GUID-E8E3BD50-0C7C-4B8E-A673-9E38D3A8B8EF"></a><h4 id="VLDBG-GUID-E8E3BD50-0C7C-4B8E-A673-9E38D3A8B8EF" class="sect4">交换范围，哈希或列表分区</h4>
                  <div>
                     <p>要使用非分区表交换范围，散列或列表分区表的分区，或者反过来，请使用<code class="codeph">ALTER</code> <code class="codeph">TABLE</code> <code class="codeph">EXCHANGE</code> <code class="codeph">PARTITION</code>语句。
                     </p>
                     <div class="section">
                        <p>以下是使用非分区表交换范围分区的示例。</p>
                     </div>
                     <!-- class="section" -->
                     <div class="example" id="GUID-E8E3BD50-0C7C-4B8E-A673-9E38D3A8B8EF__GUID-721F491B-E03F-4FCC-8DAD-3B049A26E5A0">
                        <p class="titleinexample">示例4-31交换范围分区</p><pre class="oac_no_warn" dir="ltr">CREATE TABLE sales_future_table（prod_id NUMBER NOT NULL，cust_id NUMBER NOT NULL，time_id DATE NOT NULL，channel_id NUMBER NOT NULL，promo_id NUMBER NOT NULL，quantity_sold NUMBER（10,2）NOT NULL，amount_sold NUMBER（10,2）NOT NULL）PARTITION BY RANGE（time_id）（PARTITION s_2020价值不到（截止日期（'01 -01-2021'，'dd-mm-yyyy'）），PARTITION s_2021价值低于（4月1日 -  '01 -01-2022'，'dd -mm-yyyy'）），PARTITION s_2022价值不到（截止日期（'01 -01-2023'，'dd-mm-yyyy'）））; CREATE TABLE sales_exchange_table FOR EXCHANGE WITH TABLE sales_future_table; INSERT INTO sales_exchange_table VALUES（1002,110，TO_DATE（'19 -02-2020'，'dd-mm-yyyy'），12,18,150,4800）; INSERT INTO sales_exchange_table VALUES（1001,100，TO_DATE（'12 -03-2020'，'dd-mm-yyyy'），10,15,400,6500）; INSERT INTO sales_exchange_table VALUES（1001,100，TO_DATE（'31 -05-2020'，'dd-mm-yyyy'），10,15,600,8000）; INSERT INTO sales_exchange_table VALUES（2105,101，TO_DATE（'25 -06-2020'，'dd-mm-yyyy'），12,19,100,3000）; INSERT INTO sales_exchange_table VALUES（1002,120，TO_DATE（'31 -08-2020'，'dd-mm-yyyy'），10,15,400,6000）; INSERT INTO sales_exchange_table VALUES（2105,101，TO_DATE（'25 -10-2020'，'dd-mm-yyyy'），12,19,250,7500）; ALTER TABLE sales_future_table EXCHANGE PARTITION s_2020 WITH TABLE sales_exchange_table; SELECT * FROM sales_future_table PARTITION（s_2020）; PROD_ID CUST_ID TIME_ID CHANNEL_ID PROMO_ID QUANTITY_SOLD AMOUNT_SOLD ---------- ---------- --------- ---------- ---- ------ ------------- ----------- 1002 110 19-FEB-20 12 18 150 4800 1001 100 12-MAR-20 10 15 400 6500 1001 100 31-MAY-20 10 15 600 8000 2105 101 25-JUN-20 12 19 100 3000 1002 120 31-AUG-20 10 15 400 6000 2105 101 25-OCT-20 12 19 250 7500选择6行。REM请注意，所有记录都已从sales_exchange_table SELECT * FROM sales_exchange_table中删除;没有选择行INSERT INTO sales_exchange_table VALUES（1002,110，TO_DATE（'15 -02-2021'，'dd-mm-yyyy'），12,18,300,9500）; INSERT INTO sales_exchange_table VALUES（1002,120，TO_DATE（'31 -03-2021'，'dd-mm-yyyy'），10,15,200,3000）; INSERT INTO sales_exchange_table VALUES（2105,101，TO_DATE（'25 -04-2021'，'dd-mm-yyyy'），12,19,150,9000）; ALTER TABLE sales_future_table EXCHANGE PARTITION s_2021 WITH TABLE sales_exchange_table; SELECT * FROM sales_future_table PARTITION（s_2021）; PROD_ID CUST_ID TIME_ID CHANNEL_ID PROMO_ID QUANTITY_SOLD AMOUNT_SOLD ---------- ---------- --------- ---------- ---- ------ ------------- ----------- 1002 110 15-FEB-21 12 18 300 9500 1002 120 31-MAR-21 10 15 200 3000 2105 101 25-APR-21 12 19 150 9000选择3行。
</pre></div>
                     <!-- class="example" -->
                  </div>
               </div><a id="VLDBG1158"></a><div class="props_rev_3"><a id="GUID-9A05E5AB-3A08-4502-A25B-4246E26CA2C0" name="GUID-9A05E5AB-3A08-4502-A25B-4246E26CA2C0"></a><h4 id="VLDBG-GUID-9A05E5AB-3A08-4502-A25B-4246E26CA2C0" class="sect4">交换区间分区表的分区</h4>
                  <div>
                     <p>您可以在间隔分区表中交换间隔分区。但是，必须确保已创建间隔分区，然后才能交换分区。</p>
                     <div class="section">
                        <p>以下示例显示了<code class="codeph">interval_sales</code>表的分区交换，使用截至2007年1月1日的每月分区进行间隔分区。此示例显示如何使用分区交换负载将2007年6月的数据添加到表中。假设<code class="codeph">interval_sales</code>表上只有本地索引，并且已在<code class="codeph">interval_sales_june_2007</code>表上创建了等效索引。
                        </p><pre class="oac_no_warn" dir="ltr">ALTER TABLE interval_sales EXCHANGE PARTITION FOR（TO_DATE（'01 -JUN-2007'，'dd-MON-yyyy'））WITH TABLE interval_sales_jun_2007包含索引;</pre><p>请注意使用<code class="codeph">FOR</code>语法来标识系统生成的分区。您可以通过查询<code class="codeph">*_TAB_PARTITIONS</code>数据字典视图来确定分区名称，以显示系统生成的分区名称。
                        </p>
                     </div>
                     <!-- class="section" -->
                  </div>
               </div><a id="VLDBG14073"></a><a id="VLDBG1159"></a><div class="props_rev_3"><a id="GUID-09CE9F52-A5BE-4CFD-8164-867CAF96DDCF" name="GUID-09CE9F52-A5BE-4CFD-8164-867CAF96DDCF"></a><h4 id="VLDBG-GUID-09CE9F52-A5BE-4CFD-8164-867CAF96DDCF" class="sect4">交换参考分区表的分区</h4>
                  <div>
                     <p>您可以在引用分区表中交换分区，但必须确保您引用的数据在父表的相应分区中可用。</p>
                     <div class="section">
                        <p><a href="maintenance-partition-tables-indexes.html#GUID-09CE9F52-A5BE-4CFD-8164-867CAF96DDCF__CHDEJFFI">例4-32</a>显示了范围分区<code class="codeph">orders</code>表和引用分区<code class="codeph">order_items</code>表的分区交换负载方案。<code class="codeph">order_items_dec_2006</code>表中的数据仅包含2006年12月具有<code class="codeph">order_date</code>订单的订单商品数据。
                        </p>
                        <p>必须在父表的交换分区上使用<code class="codeph">UPDATE GLOBAL INDEXES</code>或<code class="codeph">UPDATE INDEXES</code>才能使主键索引保持可用。另请注意，必须在<code class="codeph">order_items_dec_2006</code>表上创建或启用外键约束，才能使引用分区表上的分区交换成功。
                        </p>
                     </div>
                     <!-- class="section" -->
                     <div class="example" id="GUID-09CE9F52-A5BE-4CFD-8164-867CAF96DDCF__CHDEJFFI">
                        <p class="titleinexample">示例4-32为参考分区表交换分区</p><pre class="oac_no_warn" dir="ltr">ALTER TABLE命令EXCHANGE PARTITION p_2006_dec WITH TABLE orders_dec_2006 UPDATE GLOBAL INDEXES; ALTER TABLE order_items_dec_2006 ADD CONSTRAINT order_items_dec_2006_fk FOREIGN KEY（order_id）REFERENCES orders（order_id）; ALTER TABLE order_items EXCHANGE PARTITION p_2006_dec WITH TABLE order_items_dec_2006;</pre></div>
                     <!-- class="example" -->
                  </div>
               </div><a id="VLDBG1160"></a><div class="props_rev_3"><a id="GUID-77DFC31D-D3CD-44D8-A567-3617F59B2D06" name="GUID-77DFC31D-D3CD-44D8-A567-3617F59B2D06"></a><h4 id="VLDBG-GUID-77DFC31D-D3CD-44D8-A567-3617F59B2D06" class="sect4">关于使用虚拟列交换表的分区</h4>
                  <div>
                     <p>您可以在存在虚拟列的情况下交换分区。</p>
                     <p>为了使具有虚拟列的分区表上的分区交换成功，您必须创建一个表，该表与分区表的单个分区中的所有非虚拟列的定义相匹配。除非已在虚拟列上定义约束或索引，否则无需包括虚拟列定义。</p>
                     <p>在这种情况下，必须包含虚拟列定义以匹配分区表的约束和索引定义。此方案也适用于基于虚拟列的分区表。</p>
                  </div>
               </div><a id="VLDBG1161"></a><div class="props_rev_3"><a id="GUID-8E3836CA-6C40-4058-88C1-9D14E410128F" name="GUID-8E3836CA-6C40-4058-88C1-9D14E410128F"></a><h4 id="VLDBG-GUID-8E3836CA-6C40-4058-88C1-9D14E410128F" class="sect4">使用* -Hash分区交换哈希分区表</h4>
                  <div>
                     <p>您可以使用* -hash分区表的分区及其所有哈希子分区来交换整个哈希分区表及其所有分区。</p>
                     <div class="section">
                        <p>以下示例说明了范围哈希分区表的这一概念。</p>
                        <p>首先，创建一个哈希分区表：</p><pre class="oac_no_warn" dir="ltr">创建表t1（i NUMBER，j NUMBER）分段哈希（i）（分区p1，分区p2）;</pre><p>填充表，然后创建范围哈希分区表，如下所示：</p><pre class="oac_no_warn" dir="ltr">创建表t2（i NUMBER，j NUMBER）按范围划分的分区（j）哈希（i）的分区（分区p1值小于（10）（子区域t2_pls1，SUBPARTITION t2_pls2），分区p2值小于（20）（子区域t2_p2s1） ，SUBPARTITION t2_p2s2））;</pre><p>重要的是表<code class="codeph">t1</code>的分区键等于表<code class="codeph">t2</code>的子分区键。
                        </p>
                        <p>要将<code class="codeph">t1</code>的数据迁移到<code class="codeph">t2</code>并验证行，请使用以下语句：</p><pre class="oac_no_warn" dir="ltr">ALTER TABLE t2交换分区p1，表t1，带有验证;</pre></div>
                     <!-- class="section" -->
                  </div>
               </div><a id="VLDBG1162"></a><div class="props_rev_3"><a id="GUID-35E940E6-03F8-4205-B9E3-365F444DEF89" name="GUID-35E940E6-03F8-4205-B9E3-365F444DEF89"></a><h4 id="VLDBG-GUID-35E940E6-03F8-4205-B9E3-365F444DEF89" class="sect4">交换* -Hash分区表的子分区</h4>
                  <div>
                     <p>您可以使用<code class="codeph">ALTER</code> <code class="codeph">TABLE</code> <code class="codeph">EXCHANGE</code> <code class="codeph">SUBPARTITION</code>语句将* -hash分区表的哈希子分区转换为非分区表，反之亦然。
                     </p>
                     <div class="section">
                        <p>以下示例将表<code class="codeph">sales</code>的子分区<code class="codeph">q3_1999_s1</code>转换<code class="codeph">q3_1999_s1</code>分区表<code class="codeph">q3_1999</code> 。本地索引分区与<code class="codeph">q3_1999</code>上的相应索引交换。
                        </p><pre class="oac_no_warn" dir="ltr">ALTER TABLE sales EXCHANGE SUBPARTITION q3_1999_s1 with TABLE q3_1999包含索引;</pre></div>
                     <!-- class="section" -->
                  </div>
               </div><a id="VLDBG1163"></a><div class="props_rev_3"><a id="GUID-24597C75-958D-4AE7-830D-0B24E5ECF1F1" name="GUID-24597C75-958D-4AE7-830D-0B24E5ECF1F1"></a><h4 id="VLDBG-GUID-24597C75-958D-4AE7-830D-0B24E5ECF1F1" class="sect4">使用* -List分区交换列表分区表</h4>
                  <div>
                     <p>您可以使用<code class="codeph">ALTER</code> <code class="codeph">TABLE</code> <code class="codeph">EXCHANGE</code> <code class="codeph">PARTITION</code>语句将列表分区表与* -list分区交换。
                     </p>
                     <div class="section">
                        <p>语义与先前在<a href="maintenance-partition-tables-indexes.html#GUID-8E3836CA-6C40-4058-88C1-9D14E410128F" title="您可以使用* -hash分区表的分区及其所有哈希子分区来交换整个哈希分区表及其所有分区。">使用* -Hash分区交换哈希分区表时</a>所描述的相同。以下示例显示了列表列表分区表的交换分区方案。
                        </p><pre class="oac_no_warn" dir="ltr">CREATE TABLE customers_apac（id NUMBER，name VARCHAR2（50），email VARCHAR2（100），region VARCHAR2（4），credit_rating VARCHAR2（1））PARTITION BY LIST（credit_rating）（PARTITION poor VALUES（'P'），PARTITION mediocre VALUES （'C'），PARTITION良好价值（'G'），PARTITION优秀价值（'E'））;</pre><p>与APAC客户一起填写表格。然后创建一个列表列表分区表：</p><pre class="oac_no_warn" dir="ltr">CREATE TABLE客户（ID NUMBER，名称VARCHAR2（50），电子邮件VARCHAR2（100），区域VARCHAR2（4），credit_rating VARCHAR2（1））PARTITION BY LIST（区域）按列表排序（credit_rating）SUBPARTITION模板（SubPARTITION poor VALUES（ 'P'），SubPARTITION平庸价值（'C'），SubPARTITION良好价值（'G'），SubPARTITION优秀价值（'E'））（PARTITION americas VALUES（'AMER'），PARTITION emea VALUES（'EMEA'） ，PARTITION apac VALUES（'APAC'））;</pre><p>重要的是，在分区键<code class="codeph">customers_apac</code>表格中的子分区键匹配<code class="codeph">customers</code>表。
                        </p>
                        <p>接下来，交换<code class="codeph">apac</code>分区。
                        </p><pre class="oac_no_warn" dir="ltr">ALTER TABLE客户EXCHANGE PARTITION apac WITH TABLE customers_apac WITH VALIDATION;</pre></div>
                     <!-- class="section" -->
                  </div>
               </div><a id="VLDBG1164"></a><div class="props_rev_3"><a id="GUID-B0AD8D31-07A7-4BA4-8E7A-3FC72DA87158" name="GUID-B0AD8D31-07A7-4BA4-8E7A-3FC72DA87158"></a><h4 id="VLDBG-GUID-B0AD8D31-07A7-4BA4-8E7A-3FC72DA87158" class="sect4">关于交换* -List分区表的子分区</h4>
                  <div>
                     <p>您可以使用<code class="codeph">ALTER</code> <code class="codeph">TABLE</code> <code class="codeph">EXCHANGE</code> <code class="codeph">SUBPARTITION</code>语句来交换* -list分区表的子分区。
                     </p>
                     <p> </p>
                     <p><code class="codeph">ALTER</code> <code class="codeph">TABLE</code> <code class="codeph">EXCHANGE</code> <code class="codeph">SUBPARTITION</code>语句的语义与先前在<a href="maintenance-partition-tables-indexes.html#GUID-35E940E6-03F8-4205-B9E3-365F444DEF89" title="您可以使用ALTER TABLE EXCHANGE SUBPARTITION语句将* -hash分区表的哈希子分区转换为非分区表，反之亦然。">交换* -Hash分区表的子分区</a>中所述的相同。
                     </p>
                  </div>
               </div><a id="VLDBG1165"></a><div class="props_rev_3"><a id="GUID-ACB2A5F0-D8BD-4E60-8C99-CE2AF382C8F6" name="GUID-ACB2A5F0-D8BD-4E60-8C99-CE2AF382C8F6"></a><h4 id="VLDBG-GUID-ACB2A5F0-D8BD-4E60-8C99-CE2AF382C8F6" class="sect4">使用* -Range分区交换范围分区表</h4>
                  <div>
                     <p>您可以使用<code class="codeph">ALTER</code> <code class="codeph">TABLE</code> <code class="codeph">EXCHANGE</code> <code class="codeph">PARTITION</code>语句将范围分区的表与* -range分区交换。
                     </p>
                     <div class="section">
                        <p><code class="codeph">ALTER</code> <code class="codeph">TABLE</code> <code class="codeph">EXCHANGE</code> <code class="codeph">PARTITION</code>语句的语义与先前在<a href="maintenance-partition-tables-indexes.html#GUID-8E3836CA-6C40-4058-88C1-9D14E410128F" title="您可以使用* -hash分区表的分区及其所有哈希子分区来交换整个哈希分区表及其所有分区。">使用* -Hash分区交换哈希分区表时</a>所描述的相同。下面的示例显示了<code class="codeph">orders</code>表，它是<code class="codeph">order_date</code>分区的间隔， <code class="codeph">order_total</code>分区的子分区。该示例显示如何使用范围分区表交换单个月间隔。
                        </p><pre class="oac_no_warn" dir="ltr">CREATE TABLE orders_mar_2007（id NUMBER，cust_id NUMBER，order_date DATE，order_total NUMBER）PARTITION BY RANGE（order_total）（PARTITION p_small VALUES少于（1000），PARTITION p_medium值小于（10000），PARTITION p_large VALUES少于（100000）， PARTITION p_extraordinary VALUES（MAXVALUE））;</pre><p>使用2007年3月的订单填充表格。然后创建一个区间范围分区表：</p><pre class="oac_no_warn" dir="ltr">CREATE TABLE订单（id NUMBER，cust_id NUMBER，order_date DATE，order_total NUMBER）PARTITION BY RANGE（order_date）INTERVAL（NUMTOYMINTERVAL（1，'MONTH'））SUBPARTITION BY RANGE（order_total）SUBPARTITION模板（SUBPARTITION p_small VALUES少于（1000） ，SUBPARTITION p_medium值小于（10000），SubPARTITION p_large值小于（100000），SubPARTITION p_extraordinary值小于（MAXVALUE））（PARTITION p_before_2007值小于（'01 -JAN-2007'，'dd-MON-） YYYY'）））;</pre><p>重要的是，在分区键<code class="codeph">orders_mar_2007</code>表中的子分区键匹配<code class="codeph">orders</code>表。
                        </p>
                        <p>接下来，交换分区。</p><pre class="oac_no_warn" dir="ltr">ALTER TABLE命令EXCHANGE PARTITION FOR（TO_DATE（'01 -MAR-2007'，'dd-MON-yyyy'））WITH TABLE orders_mar_2007 WITH VALIDATION;</pre></div>
                     <!-- class="section" -->
                  </div>
               </div><a id="VLDBG1166"></a><div class="props_rev_3"><a id="GUID-CDB0D917-4AD4-49B6-972D-25B4A4FE3109" name="GUID-CDB0D917-4AD4-49B6-972D-25B4A4FE3109"></a><h4 id="VLDBG-GUID-CDB0D917-4AD4-49B6-972D-25B4A4FE3109" class="sect4">关于交换* -Range分区表的子分区</h4>
                  <div>
                     <p>您可以使用<code class="codeph">ALTER</code> <code class="codeph">TABLE</code> <code class="codeph">EXCHANGE</code> <code class="codeph">SUBPARTITION</code>语句来交换* -range分区的子分区。
                     </p>
                     <p><code class="codeph">ALTER</code> <code class="codeph">TABLE</code> <code class="codeph">EXCHANGE</code> <code class="codeph">SUBPARTITION</code>的语义与先前在<a href="maintenance-partition-tables-indexes.html#GUID-35E940E6-03F8-4205-B9E3-365F444DEF89" title="您可以使用ALTER TABLE EXCHANGE SUBPARTITION语句将* -hash分区表的哈希子分区转换为非分区表，反之亦然。">交换* -Hash分区表的子分区中</a>所描述的相同。
                     </p>
                  </div>
               </div><a id="VLDBG14111"></a><div class="props_rev_3"><a id="GUID-93BFB499-39A6-4DDE-88C3-BF7A63848E25" name="GUID-93BFB499-39A6-4DDE-88C3-BF7A63848E25"></a><h4 id="VLDBG-GUID-93BFB499-39A6-4DDE-88C3-BF7A63848E25" class="sect4">关于使用级联选项交换分区</h4>
                  <div>
                     <p>您可以使用<code class="codeph">ALTER</code> <code class="codeph">TABLE</code> <code class="codeph">EXCHANGE</code> <code class="codeph">PARTITION</code>和<code class="codeph">ALTER</code> <code class="codeph">TABLE</code> <code class="codeph">EXCHANGE</code> <code class="codeph">SUBPARTITION</code> SQL语句的<code class="codeph">CASCADE</code>选项级联交换操作以引用分区子表。
                     </p>
                     <p>级联交换操作要求将所有外键约束定义为<code class="codeph">ON</code> <code class="codeph">DELETE</code> <code class="codeph">CASCADE</code> 。</p>
                     <p>当指定<code class="codeph">ALTER</code> <code class="codeph">TABLE</code> <code class="codeph">EXCHANGE</code> <code class="codeph">PARTITION</code>和<code class="codeph">ALTER</code> <code class="codeph">TABLE</code> <code class="codeph">EXCHANGE</code> <code class="codeph">SUBPARTITION</code>的<code class="codeph">CASCADE</code>选项时， <code class="codeph">EXCHANGE</code>操作会级联以引用作为目标表的子项的分区表。交换操作可以针对引用分区层次结构中的任何级别，并从目标表开始级联到子表。子表上不需要特权，但对操作影响的所有表都适用对交换操作的普通限制。如果为没有引用已分区子项的表指定<code class="codeph">CASCADE</code>选项，则会忽略该选项。
                     </p>
                     <p>目标表的引用分区层次结构和交换表的引用分区层次结构必须匹配。如果多个相关表引用相同的父键，则不支持<code class="codeph">CASCADE</code>选项。具有多个依赖于相同主键的从属表使得内核无法明确地识别如何交换依赖分区。为操作指定的任何其他选项（例如<code class="codeph">UPDATE</code> <code class="codeph">INDEXES</code> ）适用于受操作影响的所有表。
                     </p>
                     <p>默认情况下，级联选项处于关闭状态，因此它们不会影响Oracle数据库兼容性。</p>
                  </div>
               </div>
            </div><a id="VLDBG1167"></a><div class="props_rev_3"><a id="GUID-0E7793F7-B38A-427E-846B-7A8651F2A523" name="GUID-0E7793F7-B38A-427E-846B-7A8651F2A523"></a><h3 id="VLDBG-GUID-0E7793F7-B38A-427E-846B-7A8651F2A523" class="sect3">关于合并分区和子分区</h3>
               <div>
                  <p>使用<code class="codeph">ALTER</code> <code class="codeph">TABLE</code> <code class="codeph">MERGE</code> <code class="codeph">PARTITION</code>和<code class="codeph">SUBPARTITION</code> SQL语句合并两个分区或子分区的内容。
                  </p>
                  <p>删除两个原始分区或子分区，以及任何相应的本地索引。您不能将此语句用于散列分区表或复合* -hash分区表的散列子分区。</p>
                  <p>您无法合并参考分区表的分区。相反，父表上的合并操作级联到所有后代表。但是，在主表上发出合并操作以合并分区或子分区时，可以使用<code class="codeph">DEPENDENT TABLES</code>子句为从属表设置特定属性。
                  </p>
                  <p>您可以将<code class="codeph">ONLINE</code>关键字与<code class="codeph">ALTER</code> <code class="codeph">TABLE</code> <code class="codeph">MERGE</code> <code class="codeph">PARTITION</code>和<code class="codeph">SUBPARTITION</code> SQL语句一起使用，以便为常规（堆组织）表启用联机合并操作。有关使用<code class="codeph">ONLINE</code>关键字的<a href="maintenance-partition-tables-indexes.html#GUID-DFCAA278-5300-48F8-8AA7-C1E57BC0E797__CHDHCBBD">示例</a> ，请参见<a href="maintenance-partition-tables-indexes.html#GUID-DFCAA278-5300-48F8-8AA7-C1E57BC0E797__CHDHCBBD">示例4-33</a> 。
                  </p>
                  <p>如果涉及的分区或子分区包含数据，则索引可以标记为<code class="codeph">UNUSABLE</code> ，如下表所述：</p>
                  <div class="tblformal" id="GUID-0E7793F7-B38A-427E-846B-7A8651F2A523__GUID-62C55005-CD3C-43C1-97D4-EC99C243B314">
                     <table cellpadding="4" cellspacing="0" class="Formal" title="" width="100%" border="1" summary="Column 1 lists the table type, column 2 lists the indexes behavior when the index is marked unusable." frame="hsides" rules="rows">
                        <thead>
                           <tr align="left" valign="top">
                              <th align="left" valign="bottom" width="23%" id="d29958e5934">表类型</th>
                              <th align="left" valign="bottom" width="77%" id="d29958e5937">指数行为</th>
                           </tr>
                        </thead>
                        <tbody>
                           <tr align="left" valign="top">
                              <td align="left" valign="top" width="23%" id="d29958e5942" headers="d29958e5934 ">
                                 <p>常规（堆）</p>
                              </td>
                              <td align="left" valign="top" width="77%" headers="d29958e5942 d29958e5937 ">
                                 <p>除非您将<code class="codeph">UPDATE</code> <code class="codeph">INDEXES</code>指定为<code class="codeph">ALTER</code> <code class="codeph">TABLE</code>语句的一部分：</p>
                                 <ul style="list-style-type:disc">
                                    <li>
                                       <p>数据库标记<code class="codeph">UNUSABLE</code>所有生成的相应本地索引分区或子分区。
                                       </p>
                                    </li>
                                    <li>
                                       <p>全局索引或分区全局索引的所有分区都标记为<code class="codeph">UNUSABLE</code> ，必须重建。
                                       </p>
                                    </li>
                                 </ul>
                              </td>
                           </tr>
                           <tr align="left" valign="top">
                              <td align="left" valign="top" width="23%" id="d29958e5974" headers="d29958e5934 ">
                                 <p>索引组织</p>
                              </td>
                              <td align="left" valign="top" width="77%" headers="d29958e5974 d29958e5937 ">
                                 <ul style="list-style-type:disc">
                                    <li>
                                       <p>数据库标记<code class="codeph">UNUSABLE</code>所有生成的相应本地索引分区。
                                       </p>
                                    </li>
                                    <li>
                                       <p>所有全局索引仍然可用。</p>
                                    </li>
                                 </ul>
                              </td>
                           </tr>
                        </tbody>
                     </table>
                  </div>
                  <!-- class="inftblhruleinformal" -->
                  <p>本节包含以下主题：</p>
                  <ul style="list-style-type:disc">
                     <li>
                        <p><a href="maintenance-partition-tables-indexes.html#GUID-DFCAA278-5300-48F8-8AA7-C1E57BC0E797" title="您可以将两个相邻范围分区的内容合并到一个分区中。">合并范围分区</a></p>
                     </li>
                     <li>
                        <p><a href="maintenance-partition-tables-indexes.html#GUID-EBB53BDB-23AB-4F35-BB88-4A7303FA5360" title="两个相邻间隔分区的内容可以合并为一个分区。">合并区间分区</a></p>
                     </li>
                     <li>
                        <p><a href="maintenance-partition-tables-indexes.html#GUID-49405446-99D3-42F1-A266-9E212F312D3C" title="合并列表分区时，要合并的分区可以是任意两个分区。">合并列表分区</a></p>
                     </li>
                     <li>
                        <p><a href="maintenance-partition-tables-indexes.html#GUID-E0C171F3-E3A8-423D-BCD9-EEA4570766A6" title="合并* -hash分区时，子分区将重新分为SUBPARTITIONS n或SUBPARTITION子句指定的子分区数。如果两者都不包含，则使用表级默认值。">合并* -Hash分区</a></p>
                     </li>
                     <li>
                        <p><a href="maintenance-partition-tables-indexes.html#GUID-2F78659B-EFAF-4631-B9A3-5CAEEF0CCD18" title="可以在分区级别合并分区，并且可以在列表子分区级别合并子分区。">关于合并* -List分区</a></p>
                     </li>
                     <li>
                        <p><a href="maintenance-partition-tables-indexes.html#GUID-DF15848C-77B6-4F99-93EA-28FC43E80DB0" title="分区可以在分区级别合并，子分区可以在范围子分区级别合并。">关于合并* -Range分区</a></p>
                     </li>
                     <li>
                        <p><a href="maintenance-partition-tables-indexes.html#GUID-54080399-6E59-4706-80C8-690159B20790" title="您可以将两个或多个分区或子分区的内容合并到一个新分区或子分区中，然后使用ALTER TABLE SQL语句的MERGE PARTITIONS和MERGE SUBPARTITIONS子句删除原始分区或子分区。">合并多个分区</a></p>
                     </li>
                  </ul>
                  <div class="section">
                     <div class="infoboxnotealso" id="GUID-0E7793F7-B38A-427E-846B-7A8651F2A523__GUID-57BFA06A-7B4E-434B-902A-5DE37ED7F389">
                        <p class="notep1">也可以看看：</p>
                        <p><a href="../sqlrf/ALTER-TABLE.html#SQLRF01001" target="_blank"><span><cite>Oracle数据库SQL语言参考</cite></span></a></p>
                     </div>
                  </div>
                  <!-- class="section" -->
               </div><a id="VLDBG14074"></a><a id="VLDBG1168"></a><div class="props_rev_3"><a id="GUID-DFCAA278-5300-48F8-8AA7-C1E57BC0E797" name="GUID-DFCAA278-5300-48F8-8AA7-C1E57BC0E797"></a><h4 id="VLDBG-GUID-DFCAA278-5300-48F8-8AA7-C1E57BC0E797" class="sect4">合并范围分区</h4>
                  <div>
                     <p>您可以将两个相邻范围分区的内容合并到一个分区中。</p>
                     <div class="section">
                        <p>不相邻的范围分区不能合并。生成的分区继承了两个合并分区的较高上限。</p>
                        <p>合并范围分区的一个原因是将历史数据保存在较大的分区中。例如，您可以拥有每日分区，将最旧的分区汇总到每周分区，然后可以将其汇总到每月分区，依此类推。</p>
                        <p><a href="maintenance-partition-tables-indexes.html#GUID-DFCAA278-5300-48F8-8AA7-C1E57BC0E797__CHDHCBBD">例4-33</a>显示了使用<code class="codeph">ONLINE</code>关键字合并范围分区的示例。
                        </p>
                     </div>
                     <!-- class="section" -->
                     <div class="example" id="GUID-DFCAA278-5300-48F8-8AA7-C1E57BC0E797__CHDHCBBD">
                        <p class="titleinexample">示例4-33合并范围分区</p><pre class="oac_no_warn" dir="ltr">- 首先，创建一个分区表，其中包含四个分区，每个分区各自 - 表空间，按日期列上的范围分区 -  CREATE TABLE four_seasons（一个DATE，两个VARCHAR2（60），三个NUMBER）PARTITION BY RANGE（一个）（PARTITION quarter_one VALUES比（截止时间（'01-APR-2017'，'dd-mon-yyyy'））TABLESPACE quarter_one，PARTITION quarter_two VALUES少于（2017年7月1日，'2017年7月'，'dd-mon） -yyyy'））TABLESPACE quarter_two，PARTITION quarter_three VALUES少于（截止时间（'01 -OCT-2017'，'dd-mon-yyyy'））TABLESPACE quarter_three，PARTITION quarter_four VALUES少于（截至_01-JAN-2018） '，'dd-mon-yyyy'））TABLESPACE quarter_four）; -   - 在four_seasons上创建本地PREFIXED索引 - 加前缀，因为索引的最左边的列匹配 - 分区键 -  CREATE INDEX i_four_seasons_l ON four_seasons（one，two）LOCAL（PARTITION i_quarter_one TABLESPACE i_quarter_one，PARTITION i_quarter_two TABLESPACE i_quarter_two， PARTITION i_quarter_three TABLESPACE i_quarter_three，PARTITION i_quarter_four TABLESPACE i_quarter_four）; SELECT TABLE_NAME，PARTITION_NAME FROM USER_TAB_PARTITIONS WHERE TABLE_NAME ='FOUR_SEASONS'; TABLE_NAME PARTITION_NAME ----------------------------------- ------------- ------------ FOUR_SEASONS QUARTER_FOUR FOUR_SEASONS QUARTER_ONE FOUR_SEASONS QUARTER_THREE FOUR_SEASONS QUARTER_TWO  - 接下来，合并前两个分区ALTER TABLE four_seasons MERGE PARTITIONS quarter_one，quarter_two INTO PARTITION quarter_two UPDATE INDEXES ONLINE; SELECT TABLE_NAME，PARTITION_NAME FROM USER_TAB_PARTITIONS WHERE TABLE_NAME ='FOUR_SEASONS'; TABLE_NAME PARTITION_NAME ----------------------------------- ------------- ------------四季_四季四季四季四季度</pre><p>如果省略<code class="codeph">ALTER</code> <code class="codeph">TABLE</code> <code class="codeph"><span class="codeinlineitalic">four_season</span></code>语句中的<code class="codeph">UPDATE</code> <code class="codeph">INDEXES</code>子句，则必须重建受影响分区的本地索引。
                        </p><pre class="oac_no_warn" dir="ltr">- 重建quarter_two的索引，该索引已被标记为不可用 - 因为它没有添加quarter_one的所有数据。- 重建索引可以纠正这种情况。- 更改表4_seasons修改分区quarter_two重建不可用的本地索引;</pre></div>
                     <!-- class="example" -->
                  </div>
               </div><a id="VLDBG1169"></a><div class="props_rev_3"><a id="GUID-EBB53BDB-23AB-4F35-BB88-4A7303FA5360" name="GUID-EBB53BDB-23AB-4F35-BB88-4A7303FA5360"></a><h4 id="VLDBG-GUID-EBB53BDB-23AB-4F35-BB88-4A7303FA5360" class="sect4">合并区间分区</h4>
                  <div>
                     <p>两个相邻间隔分区的内容可以合并为一个分区。</p>
                     <div class="section">
                        <p>不相邻的间隔分区不能合并。第一个间隔分区也可以与最高范围的分区合并。生成的分区继承了两个合并分区的较高上限。</p>
                        <p>合并间隔分区始终会导致转换点移动到两个合并分区的较高上限。结果是区间分区表的范围部分扩展到两个合并分区的上限。边界低于新合并分区的任何物化间隔分区将自动转换为范围分区，其上边界由其间隔的上边界定义。</p>
                        <p>例如，请考虑以下区间分区表事务：</p><pre class="oac_no_warn" dir="ltr">CREATE TABLE事务（id NUMBER，transaction_date DATE，value NUMBER）PARTITION BY RANGE（transaction_date）INTERVAL（NUMTODSINTERVAL（1，'DAY'））（PARTITION p_before_2007 VALUE少于（TO_DATE（'01 -JAN-2007'，'dd-） MON-YYYY'）））;</pre><p>将数据插入表的间隔部分可创建这些天的间隔分区。2007年1月15日和2007年1月16日的数据存储在相邻的间隔分区中。</p><pre class="oac_no_warn" dir="ltr">INSERT INTO交易价值（1，TO_DATE（'15 -JAN-2007'，'dd-MON-yyyy'），100）; INSERT INTO交易价值（2，TO_DATE（'16 -JAN-2007'，'dd-MON-yyyy'），600）; INSERT INTO交易价值（3，TO_DATE（'30 -JAN-2007'，'dd-MON-yyyy'），200）;</pre><p>接下来，合并两个相邻的间隔分区。新分区再次具有系统生成的名称。</p><pre class="oac_no_warn" dir="ltr">ALTER TABLE事务MERGE PARTITIONS FOR（TO_DATE（'15 -JAN-2007'，'dd-MON-yyyy'）），FOR（TO_DATE（'16 -JAN-2007'，'dd-MON-yyyy'））;</pre><p><code class="codeph">transactions</code>表的转换点现已移至2007年1月17日。区间分区表的范围部分包含两个范围分区：小于2007年1月1日的值和小于2007年1月17日的值。大于2007年1月17日的值落在区间分区表的间隔部分中。
                        </p>
                     </div>
                     <!-- class="section" -->
                  </div>
               </div><a id="VLDBG1170"></a><div class="props_rev_3"><a id="GUID-49405446-99D3-42F1-A266-9E212F312D3C" name="GUID-49405446-99D3-42F1-A266-9E212F312D3C"></a><h4 id="VLDBG-GUID-49405446-99D3-42F1-A266-9E212F312D3C" class="sect4">合并列表分区</h4>
                  <div>
                     <p>合并列表分区时，要合并的分区可以是任意两个分区。</p>
                     <div class="section">
                        <p>它们不需要相邻，就像范围分区一样，因为列表分区不假定分区的任何顺序。生成的分区由原始两个分区中的所有数据组成。如果将默认列表分区与任何其他分区合并，则生成的分区是默认分区。</p>
                        <p>以下语句将使用list方法分区的表的两个分区合并到一个分区中，该分区从表级缺省属性继承其所有属性。<code class="codeph">MAXEXTENTS</code>在语句中指定。
                        </p><pre class="oac_no_warn" dir="ltr">ALTER TABLE q1_sales_by_region MERGE PARTITIONS q1_northcentral，q1_southcentral INTO PARTITION q1_central STORAGE（MAXEXTENTS 20）;</pre><p>两个原始分区的值列表指定为：</p><pre class="oac_no_warn" dir="ltr">PARTITION q1_northcentral VALUES（'SD'，'WI'）PARTITION q1_southcentral VALUES（'OK'，'TX'）</pre><p>生成的<code class="codeph">sales_west</code>分区值列表包含表示这两个分区值列表的并集的集合，或者具体为：</p><pre class="oac_no_warn" dir="ltr">（ 'SD'， 'WI'， '行'， 'TX'）</pre></div>
                     <!-- class="section" -->
                  </div>
               </div><a id="VLDBG1171"></a><div class="props_rev_3"><a id="GUID-E0C171F3-E3A8-423D-BCD9-EEA4570766A6" name="GUID-E0C171F3-E3A8-423D-BCD9-EEA4570766A6"></a><h4 id="VLDBG-GUID-E0C171F3-E3A8-423D-BCD9-EEA4570766A6" class="sect4">合并* -Hash分区</h4>
                  <div>
                     <p>合并* -hash分区时，子分区将重新分为<code class="codeph">SUBPARTITIONS</code> <span class="italic"><code class="codeph">n</code></span>或<code class="codeph">SUBPARTITION</code>子句指定的子分区数。如果两者都不包含，则使用表级默认值。
                     </p>
                     <div class="section">
                        <p>分割* -hash分区时，属性的继承是不同的，而不是在合并两个* -hash分区时。分割分区时，新分区可以从原始分区继承属性，因为只有一个父分区。但是，合并分区时，必须从表级继承属性。</p>
                        <p>对于区间散列分区表，您只能合并两个相邻的间隔分区，或者使用第一个间隔分区合并最高范围的分区。在间隔散列分区表中合并间隔时，转换点会移动。</p>
                        <p>以下示例合并两个范围哈希分区：</p><pre class="oac_no_warn" dir="ltr">ALTER TABLE all_seasons MERGE PARTITIONS quarter_1，quarter_2 INTO PARTITION quarter_2 SUBPARTITIONS 8;</pre></div>
                     <!-- class="section" -->
                     <div class="section">
                        <div class="infoboxnotealso" id="GUID-E0C171F3-E3A8-423D-BCD9-EEA4570766A6__GUID-74D4D16A-A01F-45A0-BA84-FDA81616B23A">
                           <p class="notep1">也可以看看：</p>
                           <ul style="list-style-type:disc">
                              <li>
                                 <p><a href="maintenance-partition-tables-indexes.html#GUID-C8C1518E-0A19-46EE-9FFF-9245DE36E574" title="您可以使用ALTER TABLE SPLIT PARTITION语句拆分散列分区。">分割* -Hash分区</a>以获取有关拆分散列分区的信息</p>
                              </li>
                              <li>
                                 <p><a href="maintenance-partition-tables-indexes.html#GUID-EBB53BDB-23AB-4F35-BB88-4A7303FA5360" title="两个相邻间隔分区的内容可以合并为一个分区。">合并间隔分区</a>以获取有关合并间隔分区的信息</p>
                              </li>
                           </ul>
                        </div>
                     </div>
                     <!-- class="section" -->
                  </div>
               </div><a id="VLDBG1172"></a><div class="props_rev_3"><a id="GUID-2F78659B-EFAF-4631-B9A3-5CAEEF0CCD18" name="GUID-2F78659B-EFAF-4631-B9A3-5CAEEF0CCD18"></a><h4 id="VLDBG-GUID-2F78659B-EFAF-4631-B9A3-5CAEEF0CCD18" class="sect4">关于合并* -List分区</h4>
                  <div>
                     <p>可以在分区级别合并分区，并且可以在列表子分区级别合并子分区。</p>
                     <p>本节包含以下主题。</p>
                     <ul style="list-style-type:disc">
                        <li>
                           <p><a href="maintenance-partition-tables-indexes.html#GUID-C1F4B287-AAD9-4CF2-96E8-78A187C5EE0B" title="合并两个* -list分区时，如果存在模板，则生成的新分区将继承子分区模板中的子分区描述。如果不存在子分区模板，则为新分区创建单个默认子分区。">合并* -List分区表中的分区</a></p>
                        </li>
                        <li>
                           <p><a href="maintenance-partition-tables-indexes.html#GUID-B4CD7C6F-23FC-49C5-8C8E-DEF804D8F95E" title="您可以合并属于同一分区的任意两个任意列表子分区的内容。">合并* -List分区表中的子分区</a></p>
                        </li>
                     </ul>
                  </div><a id="VLDBG1173"></a><div class="props_rev_3"><a id="GUID-C1F4B287-AAD9-4CF2-96E8-78A187C5EE0B" name="GUID-C1F4B287-AAD9-4CF2-96E8-78A187C5EE0B"></a><h5 id="VLDBG-GUID-C1F4B287-AAD9-4CF2-96E8-78A187C5EE0B" class="sect5">合并* -List分区表中的分区</h5>
                     <div>
                        <p>合并两个* -list分区时，如果存在模板，则生成的新分区将继承子分区模板中的子分区描述。如果不存在子分区模板，则为新分区创建单个默认子分区。</p>
                        <div class="section">
                           <p>对于间隔列表分区表，您只能合并两个相邻的间隔分区，或者使用第一个间隔分区合并最高范围的分区。在间隔列表分区表中合并间隔时，转换点会移动。</p>
                           <p>以下语句合并范围列表分区<code class="codeph">stripe_regional_sales</code>表中的两个分区。该表存在子分区模板。
                           </p><pre class="oac_no_warn" dir="ltr">ALTER TABLE stripe_regional_sales MERGE PARTITIONS q1_1999，q2_1999 INTO PARTITION q1_q2_1999 STORAGE（MAXEXTENTS 20）;</pre><p>为此新分区指定了一些新的物理属性，而为未指定的那些继承了表级缺省值。新得到的分区<code class="codeph">q1_q2_1999</code>继承结合的分区的高价值<code class="codeph">q2_1999</code>和从表中的子分区的模板描述的子分区值列表的描述。
                           </p>
                           <p>结果分区中的数据由来自两个分区的数据组成。但是，可能存在数据库返回错误的情况。发生这种情况的原因是，当存在以下两个条件时，数据可能会映射出新分区：</p>
                           <p>通过始终在默认子分区模板中指定默认分区，可以消除此错误情况。</p>
                        </div>
                        <!-- class="section" -->
                        <div class="section">
                           <ul style="list-style-type:disc">
                              <li>
                                 <p>合并子分区的某些文字值未包含在子分区模板中。</p>
                              </li>
                              <li>
                                 <p>子分区模板不包含默认分区定义。</p>
                              </li>
                           </ul>
                        </div>
                        <!-- class="section" -->
                        <div class="section">
                           <div class="infoboxnotealso" id="GUID-C1F4B287-AAD9-4CF2-96E8-78A187C5EE0B__GUID-527E339A-0F9F-4BFC-AF14-C36CA1CC781E">
                              <p class="notep1">也可以看看：</p>
                              <ul style="list-style-type:disc">
                                 <li>
                                    <p><a href="maintenance-partition-tables-indexes.html#GUID-49405446-99D3-42F1-A266-9E212F312D3C" title="When you merge list partitions, the partitions being merged can be any two partitions.">合并列表分区</a>以获取有关合并* -list分区表中的<a href="maintenance-partition-tables-indexes.html#GUID-49405446-99D3-42F1-A266-9E212F312D3C" title="合并列表分区时，要合并的分区可以是任意两个分区。">分区</a>的信息</p>
                                 </li>
                                 <li>
                                    <p><a href="maintenance-partition-tables-indexes.html#GUID-EBB53BDB-23AB-4F35-BB88-4A7303FA5360" title="两个相邻间隔分区的内容可以合并为一个分区。">合并间隔分区</a>以获取有关合并间隔分区的信息</p>
                                 </li>
                              </ul>
                           </div>
                        </div>
                        <!-- class="section" -->
                     </div>
                  </div><a id="VLDBG1174"></a><div class="props_rev_3"><a id="GUID-B4CD7C6F-23FC-49C5-8C8E-DEF804D8F95E" name="GUID-B4CD7C6F-23FC-49C5-8C8E-DEF804D8F95E"></a><h5 id="VLDBG-GUID-B4CD7C6F-23FC-49C5-8C8E-DEF804D8F95E" class="sect5">合并* -List分区表中的子分区</h5>
                     <div>
                        <p>您可以合并属于<span class="italic">同一</span>分区的任意两个任意列表子分区的内容。
                        </p>
                        <p>生成的子分区值列表描述符包括要合并的分区的值列表中的所有文字值。</p>
                        <p>以下语句将使用range-list方法分区的表的两个子分区合并到位于表空间<code class="codeph">ts4</code>的新子分区中：</p><pre class="oac_no_warn" dir="ltr">ALTER TABLE quarterly_regional_sales MERGE SUBPARTITIONS q1_1999_northwest，q1_1999_southwest INTO SUBPARTITION q1_1999_west TABLESPACE ts4;</pre><p>原始两个分区的值列表是：</p>
                        <ul style="list-style-type:disc">
                           <li>
                              <p>子<code class="codeph">q1_1999_northwest</code>被描述为<code class="codeph">('WA','OR')</code></p>
                           </li>
                           <li>
                              <p>子<code class="codeph">q1_1999_southwest</code>被描述为<code class="codeph">('AZ','NM','UT')</code></p>
                           </li>
                        </ul>
                        <p>生成的子分区值列表包含表示这两个子分区值列表的并集的集合：</p>
                        <ul style="list-style-type:disc">
                           <li>
                              <p>子<code class="codeph">q1_1999_west</code>有一个值列表，描述为<code class="codeph">('WA','OR','AZ','NM','UT')</code></p>
                           </li>
                        </ul>
                        <p>生成的子分区所在的表空间和子分区属性由分区级默认属性确定，但显式指定的除外。如果正在重用任何现有的子分区名称，则新的子分区将继承正在重用其名称的子分区的子分区属性。</p>
                     </div>
                  </div>
               </div><a id="VLDBG1175"></a><div class="props_rev_3"><a id="GUID-DF15848C-77B6-4F99-93EA-28FC43E80DB0" name="GUID-DF15848C-77B6-4F99-93EA-28FC43E80DB0"></a><h4 id="VLDBG-GUID-DF15848C-77B6-4F99-93EA-28FC43E80DB0" class="sect4">关于合并* -Range分区</h4>
                  <div>
                     <p>分区可以在分区级别合并，子分区可以在范围子分区级别合并。</p>
                     <ul style="list-style-type:disc">
                        <li>
                           <p><a href="maintenance-partition-tables-indexes.html#GUID-1C935B50-CA2B-41CB-A08B-D0A0B82B2C04" title="合并两个* -range分区时，生成的新分区将继承子分区模板中的子分区描述（如果存在）。如果不存在子分区模板，则为新分区创建具有上边界MAXVALUE的单个子分区。">合并* -Range分区表中的分区</a></p>
                        </li>
                     </ul>
                  </div><a id="VLDBG1176"></a><div class="props_rev_3"><a id="GUID-1C935B50-CA2B-41CB-A08B-D0A0B82B2C04" name="GUID-1C935B50-CA2B-41CB-A08B-D0A0B82B2C04"></a><h5 id="VLDBG-GUID-1C935B50-CA2B-41CB-A08B-D0A0B82B2C04" class="sect5">合并* -Range分区表中的分区</h5>
                     <div>
                        <p>合并两个* -range分区时，生成的新分区将继承子分区模板中的子分区描述（如果存在）。如果不存在子分区模板，则为新分区创建具有上边界<code class="codeph">MAXVALUE</code>的单个子分区。
                        </p>
                        <div class="section">
                           <p>对于区间范围分区表，您只能合并两个相邻的间隔分区，或者使用第一个间隔分区合并最高范围的分区。在区间范围分区表中合并间隔时，转换点会移动。</p>
                           <p>以下语句合并月间隔范围分区<code class="codeph">orders</code>表中的两个分区。该表存在子分区模板。
                           </p><pre class="oac_no_warn" dir="ltr">ALTER TABLE命令MERGE PARTITIONS FOR（TO_DATE（'01 -MAR-2007'，'dd-MON-yyyy'）），FOR（TO_DATE（'01 -APR-2007'，'dd-MON-yyyy'））INTO PARTITION p_pre_may_2007;</pre><p>如果2007年3月和2007年4月的分区仍在间隔范围分区表的间隔部分中，则合并操作会将转换点移动到2007年5月1日。</p>
                           <p>分区<code class="codeph">p_pre_may_2007</code>的子分区从子分区模板继承其属性。结果分区中的数据由来自两个分区的数据组成。但是，可能存在数据库返回错误的情况。发生这种情况的原因是，当满足以下两个条件时，数据可能会映射出新分区：</p>
                           <p>通过始终在子分区模板中指定具有<code class="codeph">MAXVALUE</code>上限的子分区，可以消除错误条件。
                           </p>
                        </div>
                        <!-- class="section" -->
                        <div class="section">
                           <ul style="list-style-type:disc">
                              <li>
                                 <p>合并子分区的某些范围值未包含在子分区模板中。</p>
                              </li>
                              <li>
                                 <p>子分区模板没有具有<code class="codeph">MAXVALUE</code>上边界的子分区定义。
                                 </p>
                              </li>
                           </ul>
                        </div>
                        <!-- class="section" -->
                        <div class="section">
                           <div class="infoboxnotealso" id="GUID-1C935B50-CA2B-41CB-A08B-D0A0B82B2C04__GUID-AF8AAD2D-FFB1-4B6E-B1E9-FBFAAC281D96">
                              <p class="notep1">也可以看看：</p>
                              <ul style="list-style-type:disc">
                                 <li>
                                    <p><a href="maintenance-partition-tables-indexes.html#GUID-DFCAA278-5300-48F8-8AA7-C1E57BC0E797" title="You can merge the contents of two adjacent range partitions into one partition.">合并范围分区</a>以获取有关合并*范围分区表中的<a href="maintenance-partition-tables-indexes.html#GUID-DFCAA278-5300-48F8-8AA7-C1E57BC0E797" title="您可以将两个相邻范围分区的内容合并到一个分区中。">分区</a>的信息</p>
                                 </li>
                                 <li>
                                    <p><a href="maintenance-partition-tables-indexes.html#GUID-EBB53BDB-23AB-4F35-BB88-4A7303FA5360" title="两个相邻间隔分区的内容可以合并为一个分区。">合并间隔分区</a>以获取有关合并间隔分区的信息</p>
                                 </li>
                              </ul>
                           </div>
                        </div>
                        <!-- class="section" -->
                     </div>
                  </div>
               </div><a id="VLDBG14113"></a><div class="props_rev_3"><a id="GUID-54080399-6E59-4706-80C8-690159B20790" name="GUID-54080399-6E59-4706-80C8-690159B20790"></a><h4 id="VLDBG-GUID-54080399-6E59-4706-80C8-690159B20790" class="sect4">合并多个分区</h4>
                  <div>
                     <p>您可以将两个或多个分区或子分区的内容合并到一个新分区或子分区中，然后使用<code class="codeph">ALTER</code> <code class="codeph">TABLE</code> SQL语句的<code class="codeph">MERGE</code> <code class="codeph">PARTITIONS</code>和<code class="codeph">MERGE</code> <code class="codeph">SUBPARTITIONS</code>子句删除原始分区或子分区。
                     </p>
                     <div class="section">
                        <p><code class="codeph">MERGE</code> <code class="codeph">PARTITIONS</code>和<code class="codeph">MERGE</code> <code class="codeph">SUBPARTITIONS</code>条款与<code class="codeph">MERGE</code> <code class="codeph">PARTITION</code>和<code class="codeph">MERGE</code> <code class="codeph">SUBPARTITION</code>条款同义。
                        </p>
                        <p>例如，以下SQL语句将四个分区合并为一个分区，并删除合并的四个分区。</p><pre class="oac_no_warn" dir="ltr">ALTER TABLE t1 MERGE PARTITIONS p01，p02，p03，p04 INTO p0;</pre><p>合并多个范围分区时，分区必须相邻，并按其分区绑定值的升序指定。新分区继承最高原始分区的分区上限。</p>
                        <p>使用<code class="codeph">TO</code>语法合并多个范围分区时，可以指定要合并的最低和最高分区。指定分区之间的所有分区（包括指定的分区）都将合并到目标分区中。您不能将此语法用于列表和系统分区。
                        </p>
                        <p>例如，以下SQL语句将分区<code class="codeph">p01</code>到<code class="codeph">p04</code>合并到分区<code class="codeph">p0</code> 。
                        </p><pre class="oac_no_warn" dir="ltr">ALTER TABLE t1 MERGE PARTITIONS p01 TO p04 INTO p0;</pre><p>要合并的列表分区和系统分区不需要相邻，因为不会假定分区的排序。合并多个列表分区时，生成的分区值列表是要合并的所有分区的分区值列表集的并集。与其他列表分区合并的<code class="codeph">DEFAULT</code>列表分区将导致<code class="codeph">DEFAULT</code>分区。
                        </p>
                        <p>合并复合分区表的多个分区时，生成的新分区将继承子分区模板中的子分区描述（如果存在）。如果不存在子分区模板，则Oracle会从范围子分区创建一个<code class="codeph">MAXVALUE</code>子分区，或者从新分区的列表子分区创建一个<code class="codeph">DEFAULT</code>子分区。合并复合分区表的多个子分区时，要合并的子分区必须属于同一分区。
                        </p>
                        <p>合并多个分区时，本地和全局索引操作以及继承未指定物理属性的语义对于合并两个分区是相同的。</p>
                        <p>在以下SQL语句中，将合并按范围表<code class="codeph">sales</code>分区的四个分区。这四个对应于最早年份四个季度的分区将合并为一个包含年份全部销售数据的分区。
                        </p><pre class="oac_no_warn" dir="ltr">ALTER TABLE销售MERGE PARTITIONS sales_q1_2009，sales_q2_2009，sales_q3_2009，sales_q4_2009 INTO PARTITION sales_2009;</pre><p>可以将以前的SQL语句重写为以下SQL语句以获得相同的结果。</p><pre class="oac_no_warn" dir="ltr">ALTER TABLE销售MERGE PARTITIONS sales_q1_2009 TO sales_q4_2009 INTO PARTITION sales_2009;</pre></div>
                     <!-- class="section" -->
                  </div>
               </div>
            </div>
            <div class="sect2"><a id="GUID-46FB9C24-F5CC-4326-9BEB-9B525BF7526E" name="GUID-46FB9C24-F5CC-4326-9BEB-9B525BF7526E"></a><h3 id="VLDBG-GUID-46FB9C24-F5CC-4326-9BEB-9B525BF7526E" class="sect3">关于修改表，分区和子分区的属性</h3>
               <div>
                  <p>本主题中介绍了表，分区和子分区的属性的修改。</p>
                  <p></p>
                  <ul style="list-style-type:disc">
                     <li>
                        <p><a href="maintenance-partition-tables-indexes.html#GUID-C003E6DB-3867-4407-86D2-A51F30AF07CC" title="您可以修改表的默认属性，也可以修改复合分区表的分区。">关于修改默认属性</a></p>
                     </li>
                     <li>
                        <p><a href="maintenance-partition-tables-indexes.html#GUID-91F5E552-2729-48C5-8BE8-A6D372E8A747" title="可以修改表或索引的现有分区的属性。">关于修改分区的真实属性</a></p>
                     </li>
                  </ul>
               </div><a id="VLDBG1177"></a><div class="props_rev_3"><a id="GUID-C003E6DB-3867-4407-86D2-A51F30AF07CC" name="GUID-C003E6DB-3867-4407-86D2-A51F30AF07CC"></a><h4 id="VLDBG-GUID-C003E6DB-3867-4407-86D2-A51F30AF07CC" class="sect4">关于修改默认属性</h4>
                  <div>
                     <p>您可以修改表的默认属性，也可以修改复合分区表的分区。</p>
                     <p>修改默认属性时，新属性仅影响创建的未来分区或子分区。创建新分区或子分区时，仍可以专门覆盖默认值。您可以修改引用分区表的默认属性。</p>
                     <p>本节包含以下主题：</p>
                     <ul style="list-style-type:disc">
                        <li>
                           <p><a href="maintenance-partition-tables-indexes.html#GUID-1C8A5365-F6DD-4A81-8450-1B66E8BEA657" title="您可以使用ALTER TABLE的MODIFY DEFAULT ATTRIBUTES子句修改为范围，散列，列表，间隔或引用分区继承的默认属性。">修改表的默认属性</a></p>
                        </li>
                        <li>
                           <p><a href="maintenance-partition-tables-indexes.html#GUID-4A5B7F57-1581-4F39-8537-E7BDBF8D74E3" title="要修改创建子分区时继承的默认属性，请使用ALTER TABLE MODIFY DEFAULT ATTRIBUTES FOR PARTITION。">修改分区的默认属性</a></p>
                        </li>
                        <li>
                           <p><a href="maintenance-partition-tables-indexes.html#GUID-BE66AE33-A842-4F87-8F8D-BD19EB703B63" title="以与表分区类似的方式，您可以更改范围分区全局索引的分区或分区表的本地索引分区继承的默认属性。">修改索引分区的默认属性</a></p>
                        </li>
                     </ul>
                  </div><a id="VLDBG1178"></a><div class="props_rev_3"><a id="GUID-1C8A5365-F6DD-4A81-8450-1B66E8BEA657" name="GUID-1C8A5365-F6DD-4A81-8450-1B66E8BEA657"></a><h5 id="VLDBG-GUID-1C8A5365-F6DD-4A81-8450-1B66E8BEA657" class="sect5">修改表的默认属性</h5>
                     <div>
                        <p>您可以使用<code class="codeph">ALTER</code> <code class="codeph">TABLE</code>的<code class="codeph">MODIFY</code> <code class="codeph">DEFAULT</code> <code class="codeph">ATTRIBUTES</code>子句<code class="codeph">MODIFY</code>为范围，散列，列表，间隔或引用分区继承的默认属性。</p>
                        <div class="section">
                           <p>对于散列分区表，只能修改<code class="codeph">TABLESPACE</code>属性。
                           </p>
                        </div>
                        <!-- class="section" -->
                     </div>
                  </div><a id="VLDBG1179"></a><div class="props_rev_3"><a id="GUID-4A5B7F57-1581-4F39-8537-E7BDBF8D74E3" name="GUID-4A5B7F57-1581-4F39-8537-E7BDBF8D74E3"></a><h5 id="VLDBG-GUID-4A5B7F57-1581-4F39-8537-E7BDBF8D74E3" class="sect5">修改分区的默认属性</h5>
                     <div>
                        <p>要修改创建子分区时继承的默认属性，请使用<code class="codeph">ALTER</code> <code class="codeph">TABLE</code> <code class="codeph">MODIFY</code> <code class="codeph">DEFAULT</code> <code class="codeph">ATTRIBUTES</code> <code class="codeph">FOR</code> <code class="codeph">PARTITION</code> 。</p>
                        <div class="section">
                           <p>以下语句修改<code class="codeph">TABLESPACE</code> ，其中范围 - 散列分区表中的分区<code class="codeph">p1</code>未来子分区驻留在该<code class="codeph">TABLESPACE</code>中。
                           </p><pre class="oac_no_warn" dir="ltr">ALTER TABLE employees_subpartitions修改分区的默认属性p1 TABLESPACE ts1;</pre><p>由于范围哈希分区表的所有子分区必须共享相同的属性（ <code class="codeph">TABLESPACE</code>除外），因此它是唯一可以更改的属性。
                           </p>
                           <p>您无法修改尚未创建的间隔分区的默认属性。要更改创建区间分区表中未来子分区的方式，必须修改子分区模板。</p>
                        </div>
                        <!-- class="section" -->
                     </div>
                  </div><a id="VLDBG1180"></a><div class="props_rev_3"><a id="GUID-BE66AE33-A842-4F87-8F8D-BD19EB703B63" name="GUID-BE66AE33-A842-4F87-8F8D-BD19EB703B63"></a><h5 id="VLDBG-GUID-BE66AE33-A842-4F87-8F8D-BD19EB703B63" class="sect5">修改索引分区的默认属性</h5>
                     <div>
                        <p>以与表分区类似的方式，您可以更改范围分区全局索引的分区或分区表的本地索引分区继承的默认属性。</p>
                        <div class="section">
                           <p>为此，您使用<code class="codeph">ALTER</code> <code class="codeph">INDEX</code> <code class="codeph">MODIFY</code> <code class="codeph">DEFAULT</code> <code class="codeph">ATTRIBUTES</code>语句。如果要更改要由复合分区表的子分区继承的默认属性，请使用<code class="codeph">ALTER</code> <code class="codeph">INDEX</code> <code class="codeph">MODIFY</code> <code class="codeph">DEFAULT</code> <code class="codeph">ATTRIBUTES</code> <code class="codeph">FOR</code> <code class="codeph">PARTITION</code>语句。
                           </p>
                        </div>
                        <!-- class="section" -->
                     </div>
                  </div>
               </div><a id="VLDBG1181"></a><div class="props_rev_3"><a id="GUID-91F5E552-2729-48C5-8BE8-A6D372E8A747" name="GUID-91F5E552-2729-48C5-8BE8-A6D372E8A747"></a><h4 id="VLDBG-GUID-91F5E552-2729-48C5-8BE8-A6D372E8A747" class="sect4">关于修改分区的真实属性</h4>
                  <div>
                     <p>可以修改表或索引的现有分区的属性。</p>
                     <p></p>
                     <p>您无法更改<code class="codeph">TABLESPACE</code>属性。使用<code class="codeph">ALTER</code> <code class="codeph">TABLE</code> <code class="codeph">MOVE</code> <code class="codeph">PARTITION</code> / <code class="codeph">SUBPARTITION</code>将分区或子分区移动到新的表空间。
                     </p>
                     <p>本节包含以下主题：</p>
                     <ul style="list-style-type:disc">
                        <li>
                           <p><a href="maintenance-partition-tables-indexes.html#GUID-450BE98A-5ABC-4521-9BA4-01BC26A49B33" title="使用ALTER TABLE MODIFY PARTITION语句可以修改范围分区或列表分区的现有属性。">修改范围或列表分区的实际属性</a></p>
                        </li>
                        <li>
                           <p><a href="maintenance-partition-tables-indexes.html#GUID-AAA389BA-436E-4C99-9AAA-D83EE343827F" title="您可以使用ALTER TABLE MODIFY PARTITION语句来修改散列分区的属性。">修改哈希分区的真实属性</a></p>
                        </li>
                        <li>
                           <p><a href="maintenance-partition-tables-indexes.html#GUID-0B6418C4-C282-40D1-837A-6426F216BBA9" title="使用ALTER TABLE的MODIFY SUBPARTITION子句，您可以执行与先前为分区列出的操作相同的操作，但是在特定的复合分区表子分区级别。">修改子分区的真实属性</a></p>
                        </li>
                        <li>
                           <p><a href="maintenance-partition-tables-indexes.html#GUID-54312676-5FB3-4C36-83AE-9FC0B396E7E7" title="ALTER INDEX的MODIFY PARTITION子句使您可以修改索引分区或其子分区的实际属性。">修改索引分区的真实属性</a></p>
                        </li>
                     </ul>
                  </div><a id="VLDBG1182"></a><div class="props_rev_3"><a id="GUID-450BE98A-5ABC-4521-9BA4-01BC26A49B33" name="GUID-450BE98A-5ABC-4521-9BA4-01BC26A49B33"></a><h5 id="VLDBG-GUID-450BE98A-5ABC-4521-9BA4-01BC26A49B33" class="sect5">修改范围或列表分区的实际属性</h5>
                     <div>
                        <p>使用<code class="codeph">ALTER</code> <code class="codeph">TABLE</code> <code class="codeph">MODIFY</code> <code class="codeph">PARTITION</code>语句可以修改范围分区或列表分区的现有属性。
                        </p>
                        <p>您可以修改段属性（ <code class="codeph">TABLESPACE</code>除外），也可以分配和取消分配扩展区，将本地索引分区标记为<code class="codeph">UNUSABLE</code> ，或者重建已标记为<code class="codeph">UNUSABLE</code>本地索引。</p>
                        <p>如果这是* -hash分区表的范围分区，请注意以下内容：</p>
                        <ul style="list-style-type:disc">
                           <li>
                              <p>如果分配或取消分配扩展区，则会对指定分区的每个子分区执行此操作。</p>
                           </li>
                           <li>
                              <p>同样，更改任何其他属性会导致对该分区的所有子分区的那些属性进行相应的更改。分区级别的默认属性也会更改。要避免更改现有子分区的属性，请使用<code class="codeph">MODIFY</code> <code class="codeph">DEFAULT</code> <code class="codeph">ATTRIBUTES</code>语句的<code class="codeph">FOR</code> <code class="codeph">PARTITION</code>子句。
                              </p>
                           </li>
                        </ul>
                        <p>以下是修改分区的实际属性的一些示例。</p>
                        <p>此示例修改表<code class="codeph">sales</code>的范围分区<code class="codeph">sales_q1</code>的<code class="codeph">MAXEXTENTS</code>存储属性：</p><pre class="oac_no_warn" dir="ltr">ALTER TABLE销售MODIFY PARTITION sales_q1存储（MAXEXTENTS 10）;</pre><p>在以下示例中，range-hash分区表<code class="codeph">scubagear</code>中分区<code class="codeph">ts1</code>所有本地索引子分区都标记为<code class="codeph">UNUSABLE</code> ：</p><pre class="oac_no_warn" dir="ltr">ALTER TABLE scubagear MODIFY PARTITION ts1不可用的本地指数;</pre><p>对于区间分区表，您只能修改已创建的范围分区或间隔分区的实际属性。</p>
                     </div>
                  </div><a id="VLDBG1183"></a><div class="props_rev_3"><a id="GUID-AAA389BA-436E-4C99-9AAA-D83EE343827F" name="GUID-AAA389BA-436E-4C99-9AAA-D83EE343827F"></a><h5 id="VLDBG-GUID-AAA389BA-436E-4C99-9AAA-D83EE343827F" class="sect5">修改哈希分区的真实属性</h5>
                     <div>
                        <p>您可以使用<code class="codeph">ALTER</code> <code class="codeph">TABLE</code> <code class="codeph">MODIFY</code> <code class="codeph">PARTITION</code>语句来修改散列分区的属性。
                        </p>
                        <p>但是，由于各个散列分区的物理属性必须全部相同（ <code class="codeph">TABLESPACE</code>除外），因此限制为：</p>
                        <ul style="list-style-type:disc">
                           <li>
                              <p>分配新的范围</p>
                           </li>
                           <li>
                              <p>释放未使用的范围</p>
                           </li>
                           <li>
                              <p>标记本地索引子分区<code class="codeph">UNUSABLE</code> 
                              </p>
                           </li>
                           <li>
                              <p>重建标记为<code class="codeph">UNUSABLE</code>本地索引子分区</p>
                           </li>
                        </ul>
                        <p>以下示例重建与表的散列分区<code class="codeph">p1</code>关联的任何不可用的本地索引分区：</p><pre class="oac_no_warn" dir="ltr">ALTER TABLE departments_rebuild_index修改分区p1重建不可用的本地索引;</pre></div>
                  </div><a id="VLDBG1184"></a><div class="props_rev_3"><a id="GUID-0B6418C4-C282-40D1-837A-6426F216BBA9" name="GUID-0B6418C4-C282-40D1-837A-6426F216BBA9"></a><h5 id="VLDBG-GUID-0B6418C4-C282-40D1-837A-6426F216BBA9" class="sect5">修改子分区的真实属性</h5>
                     <div>
                        <p>使用<code class="codeph">ALTER</code> <code class="codeph">TABLE</code>的<code class="codeph">MODIFY</code> <code class="codeph">SUBPARTITION</code>子句，您可以执行与先前为分区列出的操作相同的操作，但是在特定的复合分区表子分区级别。
                        </p>
                        <p>例如：</p><pre class="oac_no_warn" dir="ltr">ALTER TABLE employees_rebuild_index MODIFY SUBPARTITION p3_s1 REBUILD不可用的本地索引;</pre></div>
                  </div><a id="VLDBG1185"></a><div class="props_rev_3"><a id="GUID-54312676-5FB3-4C36-83AE-9FC0B396E7E7" name="GUID-54312676-5FB3-4C36-83AE-9FC0B396E7E7"></a><h5 id="VLDBG-GUID-54312676-5FB3-4C36-83AE-9FC0B396E7E7" class="sect5">修改索引分区的真实属性</h5>
                     <div>
                        <p><code class="codeph">ALTER</code> <code class="codeph">INDEX</code>的<code class="codeph">MODIFY</code> <code class="codeph">PARTITION</code>子句使您可以修改索引分区或其子分区的实际属性。
                        </p>
                        <p>这些规则与表分区的规则非常相似，但与<code class="codeph">ALTER</code> <code class="codeph">INDEX</code>的<code class="codeph">MODIFY</code> <code class="codeph">PARTITION</code>子句不同，没有子条款可以重建不可用的索引分区，但是有一个子句用于合并索引分区或其子分区。在此上下文中，合并意味着在可能的情况下合并索引块以释放它们以供重用。
                        </p>
                        <p>您还可以使用<code class="codeph">MODIFY</code> <code class="codeph">PARTITION</code>子句为本地索引的子分区分配或取消分配存储，或将其标记为<code class="codeph">UNUSABLE</code> 。
                        </p>
                     </div>
                  </div>
               </div>
            </div>
            <div class="sect2"><a id="GUID-AA8A163D-7812-41B3-9B97-73EFB4034607" name="GUID-AA8A163D-7812-41B3-9B97-73EFB4034607"></a><h3 id="VLDBG-GUID-AA8A163D-7812-41B3-9B97-73EFB4034607" class="sect3">关于修改列表分区</h3>
               <div>
                  <p>本主题中介绍了列表分区和子分区中值的修改。</p>
                  <ul style="list-style-type:disc">
                     <li>
                        <p><a href="maintenance-partition-tables-indexes.html#GUID-C00C7FDE-11F6-4CF3-B46E-1A64490654E5" title="通过列表分区，您可以选择从定义值列表中添加文字值。">关于修改列表分区：添加值</a></p>
                     </li>
                     <li>
                        <p><a href="maintenance-partition-tables-indexes.html#GUID-C5819AF5-C357-4553-80E2-3ACA271F532B" title="通过列表分区，您可以选择从定义值列表中删除文字值。">关于修改列表分区：删除值</a></p>
                     </li>
                  </ul>
               </div><a id="VLDBG1186"></a><div class="props_rev_3"><a id="GUID-C00C7FDE-11F6-4CF3-B46E-1A64490654E5" name="GUID-C00C7FDE-11F6-4CF3-B46E-1A64490654E5"></a><h4 id="VLDBG-GUID-C00C7FDE-11F6-4CF3-B46E-1A64490654E5" class="sect4">关于修改列表分区：添加值</h4>
                  <div>
                     <p>通过列表分区，您可以选择从定义值列表中添加文字值。</p>
                     <p>本节包含以下主题：</p>
                     <ul style="list-style-type:disc">
                        <li>
                           <p><a href="maintenance-partition-tables-indexes.html#GUID-A91C71D9-0783-49EE-AB94-A48A9AD2727A" title="使用ALTER TABLE语句的MODIFY PARTITION ADD VALUES子句扩展现有分区的值列表。">为列表分区添加值</a></p>
                        </li>
                        <li>
                           <p><a href="maintenance-partition-tables-indexes.html#GUID-1597E3D3-46F7-4615-B55B-A06B47B54279" title="使用ALTER TABLE语句的MODIFY SUBPARTITION ADD VALUES子句扩展现有子分区的值列表。">为列表子分区添加值</a></p>
                        </li>
                     </ul>
                  </div><a id="VLDBG1187"></a><div class="props_rev_3"><a id="GUID-A91C71D9-0783-49EE-AB94-A48A9AD2727A" name="GUID-A91C71D9-0783-49EE-AB94-A48A9AD2727A"></a><h5 id="VLDBG-GUID-A91C71D9-0783-49EE-AB94-A48A9AD2727A" class="sect5">为列表分区添加值</h5>
                     <div>
                        <p>使用<code class="codeph">ALTER</code> <code class="codeph">TABLE</code>语句的<code class="codeph">MODIFY</code> <code class="codeph">PARTITION</code> <code class="codeph">ADD</code> <code class="codeph">VALUES</code>子句扩展现有分区的值列表。
                        </p>
                        <div class="section">
                           <p>添加的文字值不得包含在任何其他分区值列表中。相应地扩展任何对应的本地索引分区的分区值列表，并且任何全局索引或全局或本地索引分区仍然可用。</p>
                           <p>以下语句将一组新的状态代码（“ <code class="codeph">OK</code> ”，“ <code class="codeph">KS</code> ”）添加到现有分区列表中。
                           </p><pre class="oac_no_warn" dir="ltr">ALTER TABLE sales_by_region MODIFY PARTITION region_south ADD VALUES（'OK'，'KS'）;</pre><p>将值添加到其他分区时，存在默认分区会对性能产生影响。这是因为要向列表分区添加值，数据库必须检查默认分区中不存在要添加的值。如果默认分区中存在任何值，则会显示错误。</p>
                           <div class="infoboxnote" id="GUID-A91C71D9-0783-49EE-AB94-A48A9AD2727A__GUID-BE939F94-994D-4FA4-B552-64980EDD8E12">
                              <p class="notep1">注意：</p>
                              <p>数据库运行查询以检查默认分区中是否存在与要添加的文字值对应的行。因此，建议在表上创建一个本地前缀索引。这加速了查询的执行和整体操作。</p>
                           </div>
                           <p>您无法将值添加到默认列表分区。</p>
                        </div>
                        <!-- class="section" -->
                     </div>
                  </div><a id="VLDBG1188"></a><div class="props_rev_3"><a id="GUID-1597E3D3-46F7-4615-B55B-A06B47B54279" name="GUID-1597E3D3-46F7-4615-B55B-A06B47B54279"></a><h5 id="VLDBG-GUID-1597E3D3-46F7-4615-B55B-A06B47B54279" class="sect5">为列表子分区添加值</h5>
                     <div>
                        <p>使用<code class="codeph">ALTER</code> <code class="codeph">TABLE</code>语句的<code class="codeph">MODIFY</code> <code class="codeph">SUBPARTITION</code> <code class="codeph">ADD</code> <code class="codeph">VALUES</code>子句扩展现有子分区的值列表。
                        </p>
                        <div class="section">
                           <p>此操作与“ <a href="maintenance-partition-tables-indexes.html#GUID-C00C7FDE-11F6-4CF3-B46E-1A64490654E5" title="通过列表分区，您可以选择从定义值列表中添加文字值。">关于修改列表分区：添加值”中</a>描述的操作基本相同，但是，您使用<code class="codeph">MODIFY</code> <code class="codeph">SUBPARTITION</code>子句而不是<code class="codeph">MODIFY</code> <code class="codeph">PARTITION</code>子句。例如，要扩展子分区<code class="codeph">q1_1999_southeast</code>的值列表中的文字值范围，请使用以下语句：</p><pre class="oac_no_warn" dir="ltr">ALTER TABLE quarterly_regional_sales MODIFY SUBPARTITION q1_1999_southeast ADD VALUES（'KS'）;</pre><p>添加的文字值不得包含在拥有分区中的任何其他子分区值列表中。但是，它们可以是表中其他分区的子分区值列表中的文字值的副本。</p>
                           <p>对于区间列表复合分区表，只能将值添加到已创建的范围分区或间隔分区的子分区。要将值添加到尚未创建的间隔分区的子分区，必须修改子分区模板。</p>
                        </div>
                        <!-- class="section" -->
                     </div>
                  </div>
               </div><a id="VLDBG1189"></a><div class="props_rev_3"><a id="GUID-C5819AF5-C357-4553-80E2-3ACA271F532B" name="GUID-C5819AF5-C357-4553-80E2-3ACA271F532B"></a><h4 id="VLDBG-GUID-C5819AF5-C357-4553-80E2-3ACA271F532B" class="sect4">关于修改列表分区：删除值</h4>
                  <div>
                     <p>通过列表分区，您可以选择从定义值列表中删除文字值。</p>
                     <p>本节包含以下主题：</p>
                     <ul style="list-style-type:disc">
                        <li>
                           <p><a href="maintenance-partition-tables-indexes.html#GUID-F6D66AE5-1535-4809-B685-459ECCC3EFDF" title="使用ALTER TABLE语句的MODIFY PARTITION DROP VALUES子句从现有分区的值列表中删除文字值。">从列表分区中删除值</a></p>
                        </li>
                        <li>
                           <p><a href="maintenance-partition-tables-indexes.html#GUID-63402906-D104-481C-B530-7D1315A22913" title="使用ALTER TABLE语句的MODIFY SUBPARTITION DROP VALUES子句从现有子分区的值列表中删除文字值。">从列表子分区中删除值</a></p>
                        </li>
                     </ul>
                  </div><a id="VLDBG1190"></a><div class="props_rev_3"><a id="GUID-F6D66AE5-1535-4809-B685-459ECCC3EFDF" name="GUID-F6D66AE5-1535-4809-B685-459ECCC3EFDF"></a><h5 id="VLDBG-GUID-F6D66AE5-1535-4809-B685-459ECCC3EFDF" class="sect5">从列表分区中删除值</h5>
                     <div>
                        <p>使用<code class="codeph">ALTER</code> <code class="codeph">TABLE</code>语句的<code class="codeph">MODIFY</code> <code class="codeph">PARTITION</code> <code class="codeph">DROP</code> <code class="codeph">VALUES</code>子句从现有分区的值列表中删除文字值。
                        </p>
                        <div class="section">
                           <p>该语句始终通过验证执行，这意味着它会检查分区中是否存在与要删除的值集相对应的行。如果找到任何此类行，则数据库将返回错误消息，操作将失败。必要时，在尝试删除值之前，使用<code class="codeph">DELETE</code>语句从表中删除相应的行。
                           </p>
                           <div class="infoboxnote" id="GUID-F6D66AE5-1535-4809-B685-459ECCC3EFDF__GUID-DAE1E325-29B1-4538-BDF9-413371C65260">
                              <p class="notep1">注意：</p>
                              <p>您不能从描述分区的值列表中删除所有文字值。您必须使用<code class="codeph">ALTER TABLE DROP PARTITION</code>语句。
                              </p>
                           </div>
                           <p>任何对应的本地索引分区的分区值列表反映新值列表，并且任何全局索引或全局或本地索引分区仍然可用。</p>
                           <p>以下语句从现有分区值列表中删除一组状态代码（“ <code class="codeph">OK</code> ”和“ <code class="codeph">KS</code> ”）。
                           </p><pre class="oac_no_warn" dir="ltr">ALTER TABLE sales_by_region MODIFY PARTITION region_south DROP VALUES（'OK'，'KS'）;</pre><div class="infoboxnote" id="GUID-F6D66AE5-1535-4809-B685-459ECCC3EFDF__GUID-AA6B9442-F71C-463F-8991-F39056D48B43">
                              <p class="notep1">注意：</p>
                              <p>数据库运行查询以检查分区中是否存在与要删除的文字值对应的行。因此，建议在表上创建一个本地前缀索引。这加快了查询和整体操作。</p>
                           </div>
                           <p>您不能从默认列表分区中删除值。</p>
                        </div>
                        <!-- class="section" -->
                     </div>
                  </div><a id="VLDBG1191"></a><div class="props_rev_3"><a id="GUID-63402906-D104-481C-B530-7D1315A22913" name="GUID-63402906-D104-481C-B530-7D1315A22913"></a><h5 id="VLDBG-GUID-63402906-D104-481C-B530-7D1315A22913" class="sect5">从列表子分区中删除值</h5>
                     <div>
                        <p>使用<code class="codeph">ALTER</code> <code class="codeph">TABLE</code>语句的<code class="codeph">MODIFY</code> <code class="codeph">SUBPARTITION</code> <code class="codeph">DROP</code> <code class="codeph">VALUES</code>子句从现有子分区的值列表中删除文字值。
                        </p>
                        <div class="section">
                           <p>此操作与<a href="maintenance-partition-tables-indexes.html#GUID-C5819AF5-C357-4553-80E2-3ACA271F532B" title="通过列表分区，您可以选择从定义值列表中删除文字值。">关于修改列表分区：删除值的</a>描述基本相同，但是，您使用<code class="codeph">MODIFY</code> <code class="codeph">SUBPARTITION</code>子句而不是<code class="codeph">MODIFY</code> <code class="codeph">PARTITION</code>子句。例如，要删除子分区<code class="codeph">q1_1999_southeast</code>的值列表中的一组文字值，请使用以下语句：</p><pre class="oac_no_warn" dir="ltr">ALTER TABLE quarterly_regional_sales MODIFY SUBPARTITION q1_1999_southeast DROP VALUES（'KS'）;</pre><p>对于间隔列表复合分区表，只能从已创建的范围分区或间隔分区的子分区中删除值。要从尚未创建的间隔分区的子分区中删除值，必须修改子分区模板。</p>
                        </div>
                        <!-- class="section" -->
                     </div>
                  </div>
               </div>
            </div>
            <div class="sect2"><a id="GUID-763391C6-44E8-401D-8119-DC12926F5877" name="GUID-763391C6-44E8-401D-8119-DC12926F5877"></a><h3 id="VLDBG-GUID-763391C6-44E8-401D-8119-DC12926F5877" class="sect3">关于修改分区策略</h3>
               <div>
                  <p>您可以使用<code class="codeph">ALTER</code> <code class="codeph">TABLE</code> <code class="codeph">MODIFY</code> <code class="codeph">PARTITION</code> SQL语句<code class="codeph">ALTER</code>常规（堆组织）表的分区策略。
                  </p>
                  <p>修改分区策略（例如散列分区到复合范围散列分区）可以离线或在线执行。在在线模式下执行时，转换不会影响正在进行的DML操作。在脱机模式下执行时，转换不允许在修改期间进行并发DML操作。</p>
                  <p>索引作为表修改的一部分进行维护。修改分区策略时，索引列为新分区键前缀的所有未指定索引将自动转换为本地分区索引;否则，索引将转换为全局索引。</p>
                  <p>域索引不支持修改操作。<code class="codeph">UPDATE</code> <code class="codeph">INDEXES</code>子句不能更改最初定义索引列表的列或索引的唯一性属性或任何其他索引属性。
                  </p>
                  <p>有关将非分区表转换为分区表的信息，请参阅<a href="evolve-nopartition-table.html#GUID-5FDB7D59-DD05-40E4-8AB4-AF82EA0D0FE5" title="可以将非分区表转换为分区表，并在ALTER TABLE SQL语句中添加MODIFY子句。">将非分区表转换为分区表</a> 。
                  </p>
                  <p><a href="maintenance-partition-tables-indexes.html#GUID-763391C6-44E8-401D-8119-DC12926F5877__GUID-48123038-29A5-4133-B64D-3D7C564B34FC">例4-34</a>显示了使用<code class="codeph">ALTER</code> <code class="codeph">TABLE</code>将范围分区表在线转换为复合范围 - 散列分区表。在示例中的<code class="codeph">ALTER</code> <code class="codeph">TABLE</code>修改期间，将更新索引。
                  </p>
                  <div class="infoboxnote" id="GUID-763391C6-44E8-401D-8119-DC12926F5877__GUID-B1C8D002-005E-4FCC-920C-8496A776B681">
                     <p class="notep1">实时SQL：</p>
                     <p>在<a href="https://livesql.oracle.com/apex/livesql/docs/vldbg/partitioning/modify-partitioning-strategy.html" target="_blank"><span class="italic">修改表的分区策略时</span></a>查看并运行Oracle Live SQL上的相关示例。
                     </p>
                  </div>
                  <div class="example" id="GUID-763391C6-44E8-401D-8119-DC12926F5877__GUID-48123038-29A5-4133-B64D-3D7C564B34FC">
                     <p class="titleinexample">示例4-34修改分区策略</p><pre class="oac_no_warn" dir="ltr">CREATE TABLE mod_sales_partitioning（prod_id NUMBER NOT NULL，cust_id NUMBER NOT NULL，time_id DATE NOT NULL，channel_id NUMBER NOT NULL，promo_id NUMBER NOT NULL，quantity_sold NUMBER（10,2）NOT NULL，amount_sold NUMBER（10,2）NOT NULL）PARTITION BY RANGE（time_id）（PARTITION sales_q1_2017价值不到（截至_（01-APR-2017'，'dd-MON-yyyy'）），PARTITION sales_q2_2017价值低于（2017年7月1日'，2017年7月'，'dd -MON-yyyy'）），PARTITION sales_q3_2017价值不到（截止时间（'01 -OCT-2017'，'dd-MON-yyyy'）），PARTITION sales_q4_2017价值不到（截止日期：'01 -JAN-2018'， 'dd-MON-yyyy'）））; CREATE INDEX i1_cust_id_indx ON mod_sales_partitioning（cust_id）LOCAL; CREATE INDEX i2_time_id_indx ON mod_sales_partitioning（time_id）; CREATE INDEX i3_prod_id_indx ON mod_sales_partitioning（prod_id）; SELECT TABLE_NAME，PARTITIONING_TYPE FROM USER_PART_TABLES WHERE TABLE_NAME ='MOD_SALES_PARTITIONING'; TABLE_NAME PARTITION_NAME ------------------------- -------------- MOD_SALES_PARTITIONING RANGE SELECT TABLE_NAME，PARTITION_NAME来自USER_TAB_PARTITIONS WHERE TABLE_NAME ='MOD_SALES_PARTITIONING'; TABLE_NAME PARTITION_NAME ------------------------- -------------- MOD_SALES_PARTITIONING SALES_Q1_2017 MOD_SALES_PARTITIONING SALES_Q2_2017 MOD_SALES_PARTITIONING SALES_Q3_2017 MOD_SALES_PARTITIONING SALES_Q4_2017。 ..ALTER TABLE mod_sales_partitioning按范围修改分区（time_id）通过HASH（cust_id）SUBPARTITIONS进行的SUBPARTITION 8（PARTITION sales_q1_2017值不到（截止日期（'01-APR-2017'，'dd-MON-yyyy'）），PARTITION sales_q2_2017 VALUE少于（TO_DATE（'01 -JUL-2017'，'dd-MON-yyyy'）），PARTITION sales_q3_2017价值不到（截止日期（'01 -OCT-2017'，'dd-MON-yyyy'）），PARTITION sales_q4_2017 VALUES不到（TO_DATE（'01 -JAN-2018'，'dd-MON-yyyy'）））在线更新指数（i1_cust_id_indx LOCAL，i2_time_id_indx按范围进行全局分区（time_id）（PARTITION ip1_indx值不超过（MAXVALUE）））; SELECT TABLE_NAME，PARTITIONING_TYPE，SUBPARTITIONING_TYPE FROM USER_PART_TABLES WHERE TABLE_NAME ='MOD_SALES_PARTITIONING'; TABLE_NAME PARTITION SUBPARTIT --------------------------- -------------- ------ ---- MOD_SALES_PARTITIONING RANGE HASH SELECT TABLE_NAME，PARTITION_NAME，SUBPARTITION_NAME来自USER_TAB_SUBPARTITIONS，其中TABLE_NAME ='MOD_SALES_PARTITIONING'; TABLE_NAME PARTITION_NAME SUBPARTITION_NAME --------------------------- ------------------  - ---------------- MOD_SALES_PARTITIONING SALES_Q1_2017 SYS_SUBP567 MOD_SALES_PARTITIONING SALES_Q1_2017 SYS_SUBP568 MOD_SALES_PARTITIONING SALES_Q1_2017 SYS_SUBP569 MOD_SALES_PARTITIONING SALES_Q1_2017 SYS_SUBP570 ...
</pre></div>
                  <!-- class="example" -->
               </div>
            </div><a id="VLDBG1193"></a><div class="props_rev_3"><a id="GUID-3DB0B6A6-FD33-4355-8BAC-7C5B4BE4C4E0" name="GUID-3DB0B6A6-FD33-4355-8BAC-7C5B4BE4C4E0"></a><h3 id="VLDBG-GUID-3DB0B6A6-FD33-4355-8BAC-7C5B4BE4C4E0" class="sect3">关于移动分区和子分区</h3>
               <div>
                  <p>使用<code class="codeph">ALTER</code> <code class="codeph">TABLE</code>语句的<code class="codeph">MOVE</code> <code class="codeph">PARTITION</code>子句更改分区的物理存储属性。
                  </p>
                  <p>使用<code class="codeph">ALTER</code> <code class="codeph">TABLE</code>语句的<code class="codeph">MOVE</code> <code class="codeph">PARTITION</code>子句，您可以：</p>
                  <ul style="list-style-type:disc">
                     <li>
                        <p>重新聚类数据并减少碎片</p>
                     </li>
                     <li>
                        <p>将分区移动到另一个表空间</p>
                     </li>
                     <li>
                        <p>修改创建时属性</p>
                     </li>
                     <li>
                        <p>使用表压缩以压缩格式存储数据</p>
                     </li>
                  </ul>
                  <p>通常，您可以使用<code class="codeph">ALTER</code> <code class="codeph">TABLE</code> / <code class="codeph">INDEX</code> <code class="codeph">MODIFY</code> <code class="codeph">PARTITION</code>语句在一个步骤中<code class="codeph">ALTER</code>分区的物理存储属性。但是，有些物理属性（如<code class="codeph">TABLESPACE</code>无法使用<code class="codeph">MODIFY</code> <code class="codeph">PARTITION</code>进行<code class="codeph">MODIFY</code> 。在这些情况下，请使用<code class="codeph">MOVE</code> <code class="codeph">PARTITION</code>子句。修改某些其他属性（例如表压缩）仅影响将来的存储，但不会影响现有数据。
                  </p>
                  <p>如果要移动的分区包含任何数据，则可以根据下表将索引标记为<code class="codeph">UNUSABLE</code> ：</p>
                  <div class="tblformal" id="GUID-3DB0B6A6-FD33-4355-8BAC-7C5B4BE4C4E0__GUID-85C83634-E4E4-434F-A378-1AE2DE747897">
                     <table cellpadding="4" cellspacing="0" class="Formal" title="" width="100%" border="1" summary="Column 1 lists the table type, column 2 lists the indexes behavior when the index is marked unusable." frame="hsides" rules="rows">
                        <thead>
                           <tr align="left" valign="top">
                              <th align="left" valign="bottom" width="23%" id="d29958e9641">表类型</th>
                              <th align="left" valign="bottom" width="77%" id="d29958e9644">指数行为</th>
                           </tr>
                        </thead>
                        <tbody>
                           <tr align="left" valign="top">
                              <td align="left" valign="top" width="23%" id="d29958e9649" headers="d29958e9641 ">
                                 <p>常规（堆）</p>
                              </td>
                              <td align="left" valign="top" width="77%" headers="d29958e9649 d29958e9644 ">
                                 <p>除非您将<code class="codeph">UPDATE</code> <code class="codeph">INDEXES</code>指定为<code class="codeph">ALTER</code> <code class="codeph">TABLE</code>语句的一部分：</p>
                                 <ul style="list-style-type:disc">
                                    <li>
                                       <p>每个本地索引中的匹配分区标记为<code class="codeph">UNUSABLE</code> 。发出<code class="codeph">MOVE</code> <code class="codeph">PARTITION</code>后，必须重建这些索引分区。</p>
                                    </li>
                                    <li>
                                       <p>任何全局索引或分区全局索引的所有分区都标记为<code class="codeph">UNUSABLE</code> 。</p>
                                    </li>
                                 </ul>
                              </td>
                           </tr>
                           <tr align="left" valign="top">
                              <td align="left" valign="top" width="23%" id="d29958e9687" headers="d29958e9641 ">
                                 <p>索引组织</p>
                              </td>
                              <td align="left" valign="top" width="77%" headers="d29958e9687 d29958e9644 ">
                                 <p>为要移动的分区定义的任何本地或全局索引仍然可用，因为它们是基于主键的逻辑rowid。但是，这些rowid的猜测信息变得不正确。</p>
                              </td>
                           </tr>
                        </tbody>
                     </table>
                  </div>
                  <!-- class="inftblhruleinformal" -->
                  <p>本节包含以下主题：</p>
                  <ul style="list-style-type:disc">
                     <li>
                        <p><a href="maintenance-partition-tables-indexes.html#GUID-793919DF-78AB-4B9D-874D-54C37D97F67F" title="使用MOVE PARTITION子句移动分区。">移动表分区</a></p>
                     </li>
                     <li>
                        <p><a href="maintenance-partition-tables-indexes.html#GUID-5ABF9E89-C1DD-41E6-BD87-6770A50B882F" title="使用MOVE SUBPARTITION子句移动子分区。">移动子分区</a></p>
                     </li>
                     <li>
                        <p><a href="maintenance-partition-tables-indexes.html#GUID-62A89ED6-3E8A-4737-85D8-D5C51EC74FFC" title="常规表的ALTER TABLE MOVE PARTITION语句标记全局索引UNUSABLE的所有分区。">移动索引分区</a></p>
                     </li>
                  </ul>
                  <div class="infoboxnote" id="GUID-3DB0B6A6-FD33-4355-8BAC-7C5B4BE4C4E0__GUID-34FC37B3-3AC2-4FE4-9CEE-10B88B872D0B">
                     <p class="notep1">也可以看看：</p>
                     <p></p>
                     <ul style="list-style-type:disc">
                        <li>
                           <p>有关<code class="codeph">ALTER</code> <code class="codeph">TABLE</code> <code class="codeph">MOVE</code>语句的信息，请<a href="../sqlrf/ALTER-TABLE.html#SQLRF01001" target="_blank"><span><cite>参见Oracle数据库SQL语言参考</cite></span></a></p>
                        </li>
                        <li>
                           <p><a href="../admin/managing-tables.html#ADMIN11659" target="_blank"><span><cite>Oracle数据库管理员指南，</cite></span></a>用于移动表和分区的信息</p>
                        </li>
                     </ul>
                  </div>
               </div><a id="VLDBG1194"></a><div class="props_rev_3"><a id="GUID-793919DF-78AB-4B9D-874D-54C37D97F67F" name="GUID-793919DF-78AB-4B9D-874D-54C37D97F67F"></a><h4 id="VLDBG-GUID-793919DF-78AB-4B9D-874D-54C37D97F67F" class="sect4">移动表分区</h4>
                  <div>
                     <p>使用<code class="codeph">MOVE</code> <code class="codeph">PARTITION</code>子句移动分区。
                     </p>
                     <div class="section">
                        <p>例如，要将最活跃的分区移动到驻留在其自己的磁盘集上的表空间（以平衡I / O），不记录操作并压缩数据，请发出以下语句：</p><pre class="oac_no_warn" dir="ltr">ALTER TABLE部件移动分区depot2 TABLESPACE ts094 NOLOGGING COMPRESS;</pre><p>即使您未指定新的表空间，此语句也会删除旧的分区段并创建新的段。</p>
                        <p>如果要移动分区索引组织表的分区，则可以将<code class="codeph">MAPPING</code> <code class="codeph">TABLE</code>子句指定为<code class="codeph">MOVE</code> <code class="codeph">PARTITION</code>子句的一部分，并将映射表分区与表分区一起移动到新位置。
                        </p>
                        <p>对于interval或interval- * partitioned表，只能移动已实现的范围分区或间隔分区。分区移动操作不会移动间隔或interval- *分区表中的转换点。</p>
                        <p>您可以独立于主表中的分区移动引用分区表中的分区。</p>
                     </div>
                     <!-- class="section" -->
                  </div>
               </div><a id="VLDBG1195"></a><div class="props_rev_3"><a id="GUID-5ABF9E89-C1DD-41E6-BD87-6770A50B882F" name="GUID-5ABF9E89-C1DD-41E6-BD87-6770A50B882F"></a><h4 id="VLDBG-GUID-5ABF9E89-C1DD-41E6-BD87-6770A50B882F" class="sect4">移动子分区</h4>
                  <div>
                     <p>使用<code class="codeph">MOVE</code> <code class="codeph">SUBPARTITION</code>子句移动子分区。
                     </p>
                     <div class="section">
                        <p>以下语句显示如何在表的子分区中移动数据。在此示例中，还指定了<code class="codeph">PARALLEL</code>子句。
                        </p><pre class="oac_no_warn" dir="ltr">ALTER TABLE scuba_gear MOVE SUBPARTITION bcd_types TABLESPACE tbs23 PARALLEL（DEGREE 2）;</pre><p>您可以在引用分区表中移动子分区，而不依赖于主表中的子分区。</p>
                     </div>
                     <!-- class="section" -->
                  </div>
               </div><a id="VLDBG1196"></a><div class="props_rev_3"><a id="GUID-62A89ED6-3E8A-4737-85D8-D5C51EC74FFC" name="GUID-62A89ED6-3E8A-4737-85D8-D5C51EC74FFC"></a><h4 id="VLDBG-GUID-62A89ED6-3E8A-4737-85D8-D5C51EC74FFC" class="sect4">移动索引分区</h4>
                  <div>
                     <p>常规表的<code class="codeph">ALTER</code> <code class="codeph">TABLE</code> <code class="codeph">MOVE</code> <code class="codeph">PARTITION</code>语句标记全局索引<code class="codeph">UNUSABLE</code>所有分区。</p>
                     <div class="section">
                        <p>您可以通过使用<code class="codeph">ALTER</code> <code class="codeph">INDEX</code> <code class="codeph">REBUILD</code> <code class="codeph">PARTITION</code>语句单独重建每个分区来重建整个索引。您可以同时执行这些重建。
                        </p>
                        <p>您也可以简单地删除索引并重新创建它。</p>
                     </div>
                     <!-- class="section" -->
                  </div>
               </div>
            </div><a id="VLDBG1198"></a><div class="props_rev_3"><a id="GUID-6FF7CB6D-CC8D-4FCD-B92E-581C9CF0BB2E" name="GUID-6FF7CB6D-CC8D-4FCD-B92E-581C9CF0BB2E"></a><h3 id="VLDBG-GUID-6FF7CB6D-CC8D-4FCD-B92E-581C9CF0BB2E" class="sect3">关于重建索引分区</h3>
               <div>
                  <p>重建索引提供了几个优点。</p>
                  <p>重建索引分区的一些原因包括：</p>
                  <ul style="list-style-type:disc">
                     <li>
                        <p>恢复空间并提高性能</p>
                     </li>
                     <li>
                        <p>修复由介质故障引起的损坏的索引分区</p>
                     </li>
                     <li>
                        <p>使用SQL * Loader或导入实用程序加载基础表分区后重建本地索引分区</p>
                     </li>
                     <li>
                        <p>重建已标记为<code class="codeph">UNUSABLE</code>索引分区 
                        </p>
                     </li>
                     <li>
                        <p>为B树索引启用密钥压缩</p>
                     </li>
                  </ul>
                  <p>以下部分讨论了重建索引分区和子分区的选项。</p>
                  <p>本节包含以下主题：</p>
                  <ul style="list-style-type:disc">
                     <li>
                        <p><a href="maintenance-partition-tables-indexes.html#GUID-9D02A0D5-6530-40F9-A43D-CCB5DE74DB20" title="您可以使用多种方法重建全局索引分区。">关于重建全球索引分区</a></p>
                     </li>
                     <li>
                        <p><a href="maintenance-partition-tables-indexes.html#GUID-C08E6D09-44EB-4952-9BBB-72D2F65D5F44" title="您可以使用多种方法重建本地索引分区。">关于重建本地索引分区</a></p>
                     </li>
                  </ul>
               </div><a id="VLDBG1199"></a><div class="props_rev_3"><a id="GUID-9D02A0D5-6530-40F9-A43D-CCB5DE74DB20" name="GUID-9D02A0D5-6530-40F9-A43D-CCB5DE74DB20"></a><h4 id="VLDBG-GUID-9D02A0D5-6530-40F9-A43D-CCB5DE74DB20" class="sect4">关于重建全球索引分区</h4>
                  <div>
                     <p>您可以使用多种方法重建全局索引分区。</p>
                     <p></p>
                     <ul style="list-style-type:disc">
                        <li>
                           <p>通过发出<code class="codeph">ALTER</code> <code class="codeph">INDEX</code> <code class="codeph">REBUILD</code> <code class="codeph">PARTITION</code>语句重建每个分区（您可以同时运行重建）。
                           </p>
                        </li>
                        <li>
                           <p>删除整个全局索引并重新创建它。此方法更有效，因为表只扫描一次。</p>
                        </li>
                     </ul>
                     <p>对于带索引的分区表上的大多数维护操作，您可以选择通过在DDL语句上指定<code class="codeph">UPDATE</code> <code class="codeph">INDEXES</code>来避免重建索引。
                     </p>
                  </div>
               </div><a id="VLDBG1200"></a><div class="props_rev_3"><a id="GUID-C08E6D09-44EB-4952-9BBB-72D2F65D5F44" name="GUID-C08E6D09-44EB-4952-9BBB-72D2F65D5F44"></a><h4 id="VLDBG-GUID-C08E6D09-44EB-4952-9BBB-72D2F65D5F44" class="sect4">关于重建本地索引分区</h4>
                  <div>
                     <p>您可以使用多种方法重建本地索引分区。</p>
                     <p>使用<code class="codeph">ALTER</code> <code class="codeph">INDEX</code>或<code class="codeph">ALTER</code> <code class="codeph">TABLE</code>重建本地索引，如下所示：</p>
                     <ul style="list-style-type:disc">
                        <li>
                           <p><code class="codeph">ALTER</code> <code class="codeph">INDEX</code> <code class="codeph">REBUILD</code> <code class="codeph">PARTITION</code> / <code class="codeph">SUBPARTITION</code> 
                           </p>
                           <p>此语句无条件地重建索引分区或子分区。</p>
                        </li>
                        <li>
                           <p><code class="codeph">ALTER</code> <code class="codeph">TABLE</code> <code class="codeph">MODIFY</code> <code class="codeph">PARTITION</code> / <code class="codeph">SUBPARTITION</code> <code class="codeph">REBUILD</code> <code class="codeph">UNUSABLE</code> <code class="codeph">LOCAL</code> <code class="codeph">INDEXES</code> 
                           </p>
                           <p>此语句查找给定表分区或子分区的所有不可用索引并重建它们。如果已将其标记为<code class="codeph">UNUSABLE</code> ，则仅重建索引分区。</p>
                        </li>
                     </ul>
                     <p>以下部分包含有关重建索引的示例。</p>
                     <ul style="list-style-type:disc">
                        <li>
                           <p><a href="maintenance-partition-tables-indexes.html#GUID-E3F353CB-9748-44D4-B7B1-4BBAAF618D9D" title="ALTER INDEX REBUILD PARTITION语句重建索引的一个分区。">使用ALTER INDEX重建分区</a></p>
                        </li>
                        <li>
                           <p><a href="maintenance-partition-tables-indexes.html#GUID-BA018565-6EDF-4075-A0BA-64B56E9C6962" title="ALTER TABLE MODIFY PARTITION的REBUILD UNUSABLE LOCAL INDEXES子句使您可以重建不可用的索引分区。">使用ALTER TABLE重建索引分区</a></p>
                        </li>
                     </ul>
                  </div><a id="VLDBG1201"></a><div class="props_rev_3"><a id="GUID-E3F353CB-9748-44D4-B7B1-4BBAAF618D9D" name="GUID-E3F353CB-9748-44D4-B7B1-4BBAAF618D9D"></a><h5 id="VLDBG-GUID-E3F353CB-9748-44D4-B7B1-4BBAAF618D9D" class="sect5">使用ALTER INDEX重建分区</h5>
                     <div>
                        <p><code class="codeph">ALTER</code> <code class="codeph">INDEX</code> <code class="codeph">REBUILD</code> <code class="codeph">PARTITION</code>语句重建索引的一个分区。
                        </p>
                        <div class="section">
                           <p>它不能用于复合分区表。只能使用此命令重建实际物理段。重新创建索引时，还可以选择将分区移动到新的表空间或更改属性。</p>
                           <p>对于复合分区表，使用<code class="codeph">ALTER</code> <code class="codeph">INDEX</code> <code class="codeph">REBUILD</code> <code class="codeph">SUBPARTITION</code>重建索引的子分区。您可以将子分区移动到另一个表空间或指定并行子句。以下语句在表上重建本地索引的子分区，并将索引子分区移动到另一个表空间。
                           </p><pre class="oac_no_warn" dir="ltr">ALTER INDEX scuba REBUILD SUBPARTITION bcd_types TABLESPACE tbs23 PARALLEL（DEGREE 2）;</pre></div>
                        <!-- class="section" -->
                     </div>
                  </div><a id="VLDBG1202"></a><div class="props_rev_3"><a id="GUID-BA018565-6EDF-4075-A0BA-64B56E9C6962" name="GUID-BA018565-6EDF-4075-A0BA-64B56E9C6962"></a><h5 id="VLDBG-GUID-BA018565-6EDF-4075-A0BA-64B56E9C6962" class="sect5">使用ALTER TABLE重建索引分区</h5>
                     <div>
                        <p><code class="codeph">ALTER</code> <code class="codeph">TABLE</code> <code class="codeph">MODIFY</code> <code class="codeph">PARTITION</code>的<code class="codeph">REBUILD</code> <code class="codeph">UNUSABLE</code> <code class="codeph">LOCAL</code> <code class="codeph">INDEXES</code>子句使您可以重建不可用的索引分区。
                        </p>
                        <div class="section">
                           <p>但是，该语句不允许您为重建的索引分区指定任何新属性。以下示例查找并重建表<code class="codeph">scubagear</code> ，分区<code class="codeph">p1</code>任何不可用的本地索引分区。
                           </p><pre class="oac_no_warn" dir="ltr">ALTER TABLE scubagear修改分区p1重建不可用的本地索引;</pre><p><code class="codeph">ALTER</code> <code class="codeph">TABLE</code> <code class="codeph">MODIFY</code> <code class="codeph">SUBPARTITION</code>是用于重建不可用的本地索引子分区的子句。
                           </p>
                        </div>
                        <!-- class="section" -->
                     </div>
                  </div>
               </div>
            </div><a id="VLDBG1203"></a><div class="props_rev_3"><a id="GUID-3CB99D78-9D4B-453D-8FBB-A79BE7FD887E" name="GUID-3CB99D78-9D4B-453D-8FBB-A79BE7FD887E"></a><h3 id="VLDBG-GUID-3CB99D78-9D4B-453D-8FBB-A79BE7FD887E" class="sect3">关于重命名分区和子分区</h3>
               <div>
                  <p>您可以重命名表和索引的分区和子分区。</p>
                  <p>重命名分区的一个原因可能是分配有意义的名称，而不是在另一个维护操作中分配给分区的默认系统名称。</p>
                  <p>所有分区方法都支持<code class="codeph">FOR(</code> <span class="italic"><code class="codeph">value</code></span> <code class="codeph">)</code>方法来标识分区。您可以使用此方法将系统生成的分区名称重命名为更有意义的名称。这在interval或interval- *分区表中特别有用。
                  </p>
                  <p>您可以为引用分区的主表和子表单独重命名分区和子分区。主表上的重命名操作不会级联到后代表。</p>
                  <p>本节包含以下主题：</p>
                  <ul style="list-style-type:disc">
                     <li>
                        <p><a href="maintenance-partition-tables-indexes.html#GUID-8E79571C-5DB6-4FD1-86F3-2D2D263FA1D3" title="您可以使用ALTER TABLE RENAME PARTITION语句重命名范围，散列或列表分区。">重命名表分区</a></p>
                     </li>
                     <li>
                        <p><a href="maintenance-partition-tables-indexes.html#GUID-22AFE6A0-D3C4-4148-9567-4BE41B4FDBFD" title="您可以为表的子分区指定新名称。">重命名表子分区</a></p>
                     </li>
                     <li>
                        <p><a href="maintenance-partition-tables-indexes.html#GUID-DE4AAE36-5BC7-4E13-9888-F81DF12BE520" title="您可以使用ALTER INDEX语句重命名索引分区和子分区。">关于重命名索引分区</a></p>
                     </li>
                  </ul>
               </div><a id="VLDBG1204"></a><div class="props_rev_3"><a id="GUID-8E79571C-5DB6-4FD1-86F3-2D2D263FA1D3" name="GUID-8E79571C-5DB6-4FD1-86F3-2D2D263FA1D3"></a><h4 id="VLDBG-GUID-8E79571C-5DB6-4FD1-86F3-2D2D263FA1D3" class="sect4">重命名表分区</h4>
                  <div>
                     <p>您可以使用<code class="codeph">ALTER</code> <code class="codeph">TABLE</code> <code class="codeph">RENAME</code> <code class="codeph">PARTITION</code>语句重命名范围，散列或列表分区。
                     </p>
                     <div class="section">
                        <p>例如：</p><pre class="oac_no_warn" dir="ltr">ALTER TABLE scubagear RENAME PARTITION sys_p636 TO tank;</pre></div>
                     <!-- class="section" -->
                  </div>
               </div><a id="VLDBG1205"></a><div class="props_rev_3"><a id="GUID-22AFE6A0-D3C4-4148-9567-4BE41B4FDBFD" name="GUID-22AFE6A0-D3C4-4148-9567-4BE41B4FDBFD"></a><h4 id="VLDBG-GUID-22AFE6A0-D3C4-4148-9567-4BE41B4FDBFD" class="sect4">重命名表子分区</h4>
                  <div>
                     <p>您可以为表的子分区指定新名称。</p>
                     <div class="section">
                        <p>在这种情况下，您将使用<code class="codeph">ALTER</code> <code class="codeph">TABLE</code> <code class="codeph">RENAME</code> <code class="codeph">SUBPARTITION</code>语法。
                        </p>
                     </div>
                     <!-- class="section" -->
                  </div>
               </div><a id="VLDBG1206"></a><div class="props_rev_3"><a id="GUID-DE4AAE36-5BC7-4E13-9888-F81DF12BE520" name="GUID-DE4AAE36-5BC7-4E13-9888-F81DF12BE520"></a><h4 id="VLDBG-GUID-DE4AAE36-5BC7-4E13-9888-F81DF12BE520" class="sect4">关于重命名索引分区</h4>
                  <div>
                     <p>您可以使用<code class="codeph">ALTER</code> <code class="codeph">INDEX</code>语句重命名索引分区和子分区。
                     </p>
                     <ul style="list-style-type:disc">
                        <li>
                           <p><a href="maintenance-partition-tables-indexes.html#GUID-BC29A8E5-D59D-4B2B-AEBC-23AF5095A01E" title="使用ALTER INDEX RENAME PARTITION语句重命名索引分区。">重命名索引分区</a></p>
                        </li>
                        <li>
                           <p><a href="maintenance-partition-tables-indexes.html#GUID-CF02CEA2-2CF0-4866-AF75-22CCE6BDD104" title="使用ALTER INDEX RENAME SUBPARTITION语句重命名索引子分区。">重命名索引子分区</a></p>
                        </li>
                     </ul>
                  </div><a id="VLDBG1207"></a><div class="props_rev_3"><a id="GUID-BC29A8E5-D59D-4B2B-AEBC-23AF5095A01E" name="GUID-BC29A8E5-D59D-4B2B-AEBC-23AF5095A01E"></a><h5 id="VLDBG-GUID-BC29A8E5-D59D-4B2B-AEBC-23AF5095A01E" class="sect5">重命名索引分区</h5>
                     <div>
                        <p>使用<code class="codeph">ALTER</code> <code class="codeph">INDEX</code> <code class="codeph">RENAME</code> <code class="codeph">PARTITION</code>语句重命名索引分区。
                        </p>
                        <div class="section">
                           <p><code class="codeph">ALTER INDEX</code>语句不支持使用<code class="codeph">FOR(</code> <span class="italic"><code class="codeph">value</code></span> <code class="codeph">)</code>来标识分区。您必须在重命名操作中使用原始分区名称。
                           </p>
                        </div>
                        <!-- class="section" -->
                     </div>
                  </div><a id="VLDBG1208"></a><div class="props_rev_3"><a id="GUID-CF02CEA2-2CF0-4866-AF75-22CCE6BDD104" name="GUID-CF02CEA2-2CF0-4866-AF75-22CCE6BDD104"></a><h5 id="VLDBG-GUID-CF02CEA2-2CF0-4866-AF75-22CCE6BDD104" class="sect5">重命名索引子分区</h5>
                     <div>
                        <p>使用<code class="codeph">ALTER</code> <code class="codeph">INDEX</code> <code class="codeph">RENAME</code> <code class="codeph">SUBPARTITION</code>语句重命名索引子分区。
                        </p>
                        <div class="section">
                           <p>以下语句仅显示如何重命名具有系统生成名称的子分区，该子分区是将基础表添加到基础表的结果：</p><pre class="oac_no_warn" dir="ltr">ALTER INDEX scuba RENAME SUBPARTITION sys_subp3254 TO bcd_types;</pre></div>
                        <!-- class="section" -->
                     </div>
                  </div>
               </div>
            </div><a id="VLDBG00303"></a><div class="props_rev_3"><a id="GUID-6BB84952-7021-4CBA-91ED-180E0656E02B" name="GUID-6BB84952-7021-4CBA-91ED-180E0656E02B"></a><h3 id="VLDBG-GUID-6BB84952-7021-4CBA-91ED-180E0656E02B" class="sect3">关于拆分分区和子分区</h3>
               <div>
                  <p>您可以将分区的内容拆分为两个新分区。</p>
                  <p><code class="codeph">ALTER</code> <code class="codeph">TABLE</code>或<code class="codeph">ALTER</code> <code class="codeph">INDEX</code>语句的<code class="codeph">SPLIT</code> <code class="codeph">PARTITION</code>子句用于将分区的内容重新分配到两个新分区。当分区变得太大并导致备份，恢复或维护操作需要很长时间才能完成时，或者感觉分区中有太多数据时，请考虑这样做。您还可以使用<code class="codeph">SPLIT</code> <code class="codeph">PARTITION</code>子句重新分配I / O负载。此子句不能用于散列分区或子分区。
                  </p>
                  <p>如果要拆分的分区包含任何数据，则索引可能标记为<code class="codeph">UNUSABLE</code> ，如下表所述：</p>
                  <div class="tblformal" id="GUID-6BB84952-7021-4CBA-91ED-180E0656E02B__GUID-F11F75FA-24A6-4561-87BF-8C527685C133">
                     <table cellpadding="4" cellspacing="0" class="Formal" title="" width="100%" border="1" summary="Column 1 lists the table type, column 2 lists the indexes behavior when the index is marked unusable." frame="hsides" rules="rows">
                        <thead>
                           <tr align="left" valign="top">
                              <th align="left" valign="bottom" width="23%" id="d29958e11505">表类型</th>
                              <th align="left" valign="bottom" width="77%" id="d29958e11508">指数行为</th>
                           </tr>
                        </thead>
                        <tbody>
                           <tr align="left" valign="top">
                              <td align="left" valign="top" width="23%" id="d29958e11513" headers="d29958e11505 ">
                                 <p>常规（堆）</p>
                              </td>
                              <td align="left" valign="top" width="77%" headers="d29958e11513 d29958e11508 ">
                                 <p>除非您将<code class="codeph">UPDATE</code> <code class="codeph">INDEXES</code>指定为<code class="codeph">ALTER</code> <code class="codeph">TABLE</code>语句的一部分：</p>
                                 <ul style="list-style-type:disc">
                                    <li>
                                       <p>数据库在每个本地索引中标记<code class="codeph">UNUSABLE</code>新分区（有两个）。
                                       </p>
                                    </li>
                                    <li>
                                       <p>任何全局索引或分区全局索引的所有分区都标记为<code class="codeph">UNUSABLE</code> ，必须重建。
                                       </p>
                                    </li>
                                 </ul>
                              </td>
                           </tr>
                           <tr align="left" valign="top">
                              <td align="left" valign="top" width="23%" id="d29958e11545" headers="d29958e11505 ">
                                 <p>索引组织</p>
                              </td>
                              <td align="left" valign="top" width="77%" headers="d29958e11545 d29958e11508 ">
                                 <ul style="list-style-type:disc">
                                    <li>
                                       <p>数据库在每个本地索引中标记<code class="codeph">UNUSABLE</code>新分区（有两个）。
                                       </p>
                                    </li>
                                    <li>
                                       <p>所有全局索引仍然可用。</p>
                                    </li>
                                 </ul>
                              </td>
                           </tr>
                        </tbody>
                     </table>
                  </div>
                  <!-- class="inftblhruleinformal" -->
                  <p>除父表外，您不能拆分引用分区表中的分区或子分区。在父表中拆分分区或子分区时，拆分将级联到所有后代表。但是，当您在主表上发出<code class="codeph">SPLIT</code>语句以拆分分区或子分区时，可以使用<code class="codeph">DEPENDENT TABLES</code>子句为从属表设置特定属性。
                  </p>
                  <p>支持<code class="codeph">SPLIT</code>操作的分区维护作为联机操作，使用关键字<code class="codeph">ONLINE</code>进行堆组织表，在分区维护操作正在进行时启用并发DML操作。
                  </p>
                  <p>对于<code class="codeph">ONLINE</code>操作，无论您是否指定<code class="codeph">UPDATE</code> <code class="codeph">INDEXES</code>子句，默认情况下始终更新拆分索引。
                  </p>
                  <p>有关将关键字<code class="codeph">ONLINE</code>与<code class="codeph">SPLIT</code>操作一起使用的<a href="maintenance-partition-tables-indexes.html#GUID-C27329F1-00C6-4952-A411-4B9A278E4DE8__SPLITTINGAPARTITIONOFARANGE-PARTITI-F7059E9E">示例</a> ，请参见<a href="maintenance-partition-tables-indexes.html#GUID-C27329F1-00C6-4952-A411-4B9A278E4DE8__SPLITTINGAPARTITIONOFARANGE-PARTITI-F7059E9E">示例4-36</a> 。
                  </p>
                  <p>本节包含以下主题：</p>
                  <ul style="list-style-type:disc">
                     <li>
                        <p><a href="maintenance-partition-tables-indexes.html#GUID-C27329F1-00C6-4952-A411-4B9A278E4DE8" title="您可以使用ALTER TABLE SPLIT PARTITION语句拆分范围分区。">拆分范围分区表的分区</a></p>
                     </li>
                     <li>
                        <p><a href="maintenance-partition-tables-indexes.html#GUID-65E169AC-3224-405E-AD1D-9FBF4D5231BA" title="您可以使用ALTER TABLE SPLIT PARTITION语句拆分列表分区。">拆分列表分区表的分区</a></p>
                     </li>
                     <li>
                        <p><a href="maintenance-partition-tables-indexes.html#GUID-D329CC2A-57CB-470D-8990-89C5240F029C" title="您可以使用间隔分区表中的ALTER TABLE SPLIT PARTITION语句拆分范围或实现间隔分区。">拆分区间分区表的分区</a></p>
                     </li>
                     <li>
                        <p><a href="maintenance-partition-tables-indexes.html#GUID-C8C1518E-0A19-46EE-9FFF-9245DE36E574" title="您可以使用ALTER TABLE SPLIT PARTITION语句拆分散列分区。">拆分* -Hash分区</a></p>
                     </li>
                     <li>
                        <p><a href="maintenance-partition-tables-indexes.html#GUID-A0189FCC-2CD6-480F-8BDC-5160C1D232F2" title="可以在列表分区表的分区级别和子分区级别拆分分区。">在* -List分区表中拆分分区</a></p>
                     </li>
                     <li>
                        <p><a href="maintenance-partition-tables-indexes.html#GUID-FE363371-932E-4D94-AC73-1F6690B1A52A" title="您可以使用ALTER TABLE SPLIT PARTITION语句拆分范围分区。">拆分* -Range分区</a></p>
                     </li>
                     <li>
                        <p><a href="maintenance-partition-tables-indexes.html#GUID-B28D3E86-190D-44CC-A279-00D867A5B80B" title="您无法在本地索引中显式拆分分区。只有在基础表中拆分分区时才会拆分本地索引分区。">拆分索引分区</a></p>
                     </li>
                     <li>
                        <p><a href="maintenance-partition-tables-indexes.html#GUID-01C14320-0D7B-48BE-A5AD-003DDA761277" title="您可以使用ALTER TABLE语句的SPLIT PARTITION和SPLIT SUBPARTITION子句将一个分区或子分区的内容重新分配到多个分区或子分区中。">拆分成多个分区</a></p>
                     </li>
                     <li>
                        <p><a href="maintenance-partition-tables-indexes.html#GUID-5AEB1A3A-89F1-489B-824E-CCD955F94BD7" title="Oracle数据库通过创建两个新分区并将分区中的行重新分配到两个新分区来实现SPLIT PARTITION操作。">快速分割分割和分割子操作</a></p>
                     </li>
                  </ul>
                  <div class="infoboxnotealso" id="GUID-6BB84952-7021-4CBA-91ED-180E0656E02B__GUID-AF409B04-E26B-4655-B6D7-72E901FD64B2">
                     <p class="notep1">也可以看看：</p>
                     <p><a href="../sqlrf/ALTER-TABLE.html#SQLRF01001" target="_blank"><span><cite>Oracle数据库SQL语言参考</cite></span></a></p>
                  </div>
               </div><a id="VLDBG1209"></a><div class="props_rev_3"><a id="GUID-C27329F1-00C6-4952-A411-4B9A278E4DE8" name="GUID-C27329F1-00C6-4952-A411-4B9A278E4DE8"></a><h4 id="VLDBG-GUID-C27329F1-00C6-4952-A411-4B9A278E4DE8" class="sect4">拆分范围分区表的分区</h4>
                  <div>
                     <p>您可以使用<code class="codeph">ALTER</code> <code class="codeph">TABLE</code> <code class="codeph">SPLIT</code> <code class="codeph">PARTITION</code>语句拆分范围分区。
                     </p>
                     <div class="section">
                        <p>在SQL语句中，必须在要拆分分区的分区范围内指定分区键列的值。</p>
                        <p>您可以选择为拆分产生的分区指定新属性。如果在表上定义了本地索引，则此语句还会拆分每个本地索引中的匹配分区。</p>
                        <p>如果未指定新分区名称，则数据库将分配<code class="codeph">SYS_P</code> <span class="italic"><code class="codeph">n</code></span>形式的名称。您可以检查数据字典以找到分配给新本地索引分区的名称。您可能想要重命名它们。您未指定的任何属性都从原始分区继承。
                        </p>
                     </div>
                     <!-- class="section" -->
                     <div class="example" id="GUID-C27329F1-00C6-4952-A411-4B9A278E4DE8__GUID-93E946E8-A9E4-4F6B-9D04-1B5FFDE6C579">
                        <p class="titleinexample">示例4-35拆分范围分区表的分区并重建索引</p>
                        <p>在这个例子中， <code class="codeph">fee_katy</code>是表<code class="codeph">vet_cats</code>中的一个分区，它有一个本地索引<code class="codeph">jaf1</code> 。桌面上还有一个全球指数， <code class="codeph">vet</code> 。 <code class="codeph">vet</code>包含两个分区， <code class="codeph">vet_parta</code>和<code class="codeph">vet_partb</code> 。生成的两个新分区中的第一个包括原始分区中的所有行，其分区键列值映射低于指定值。第二个分区包含分区键列值映射大于或等于指定值的所有行。以下SQL语句拆分分区<code class="codeph">fee_katy</code> ，并重建索引分区。
                        </p><pre class="oac_no_warn" dir="ltr">ALTER TABLE vet_cats SPLIT PARTITION fee_katy at（100）INTO（PARTITION fee_katy1，PARTITION fee_katy2）; ALTER INDEX JAF1 REBUILD PARTITION fee_katy1; ALTER INDEX JAF1 REBUILD PARTITION fee_katy2; ALTER INDEX VET REBUILD PARTITION vet_parta; ALTER INDEX VET REBUILD PARTITION vet_partb;</pre></div>
                     <!-- class="example" -->
                     <div class="example" id="GUID-C27329F1-00C6-4952-A411-4B9A278E4DE8__SPLITTINGAPARTITIONOFARANGE-PARTITI-F7059E9E">
                        <p class="titleinexample">示例4-36在线拆分范围分区表的分区</p>
                        <p>在此示例中， <code class="codeph">ORDERS</code>表的<code class="codeph">sales_q4_2016</code>分区将分为每个月的单独分区。指定<code class="codeph">ONLINE</code>关键字以在分区维护操作正在进行时启用并发DML操作。
                        </p>
                        <p>如果<code class="codeph">ORDERS</code>表上有任何索引，那么这些索引将作为在线拆分的一部分自动维护。
                        </p><pre class="oac_no_warn" dir="ltr">CREATE TABLE订单（prod_id NUMBER（6），cust_id NUMBER，time_id DATE，channel_id CHAR（1），promo_id NUMBER（6），quantity_sold NUMBER（3），amount_sold NUMBER（10,2））PARTITION BY RANGE（time_id）（PARTITION sales_q1_2016价值低于（截止日期（'01-APR-2016'，'dd-MON-yyyy'）），PARTITION sales_q2_2016价值低于（7月6日（'01 -JUL-2016'，'dd-MON-yyyy'）） ，PARTITION sales_q3_2016价值不到（截止时间（'01 -OCT-2016'，'dd-MON-yyyy'）），PARTITION sales_q4_2016价值不到（截至（'01 -JAN-2017'，'dd-MON-yyyy'） ）））; ALTER TABLE订单SPLIT PARTITION sales_q4_2016 INTO（PARTITION sales_oct_2016价值不到（截止日期（'01 -NOV-2016'，'dd-MON-yyyy'）），PARTITION sales_nov_2016价值低于（去年十月（'01 -DEC-2016'， 'dd-MON-yyyy'）），PARTITION sales_dec_2016）ONLINE;</pre></div>
                     <!-- class="example" -->
                  </div>
               </div><a id="VLDBG1210"></a><div class="props_rev_3"><a id="GUID-65E169AC-3224-405E-AD1D-9FBF4D5231BA" name="GUID-65E169AC-3224-405E-AD1D-9FBF4D5231BA"></a><h4 id="VLDBG-GUID-65E169AC-3224-405E-AD1D-9FBF4D5231BA" class="sect4">拆分列表分区表的分区</h4>
                  <div>
                     <p>您可以使用<code class="codeph">ALTER</code> <code class="codeph">TABLE</code> <code class="codeph">SPLIT</code> <code class="codeph">PARTITION</code>语句拆分列表分区。
                     </p>
                     <div class="section">
                        <p><code class="codeph">SPLIT</code> <code class="codeph">PARTITION</code>子句使您可以指定一个文字值列表，用于定义插入了具有相应分区键值的行的分区。原始分区的其余行将插入第二个分区，其值列表包含原始分区中的其余值。您可以选择为拆分产生的两个分区指定新属性。
                        </p>
                        <p>以下语句将分区<code class="codeph">region_east</code>为两个分区：</p><pre class="oac_no_warn" dir="ltr">ALTER TABLE sales_by_region SPLIT PARTITION region_east VALUES（'CT'，'MA'，'MD'）INTO（PARTITION region_east_1 TABLESPACE tbs2，PARTITION region_east_2 STORAGE（INITIAL 8M））PARALLEL 5;</pre><p>原始<code class="codeph">region_east</code>分区的文字值列表指定为：</p><pre class="oac_no_warn" dir="ltr">PARTITION region_east VALUES（'MA'，'NY'，'CT'，'NH'，'ME'，'MD'，'VA'，'PA'，'NJ'）</pre><p>这两个新分区是：</p>
                        <ul style="list-style-type:disc">
                           <li>
                              <p><code class="codeph">region_east_1</code> ，其文字值列表为<code class="codeph">('CT','MA','MD')</code></p>
                           </li>
                           <li>
                              <p><code class="codeph">region_east_2</code>继承剩余的文字值列表<code class="codeph">('NY','NH','ME','VA','PA','NJ')</code></p>
                           </li>
                        </ul>
                        <p>各个分区具有在分区级别指定的新物理属性。该操作以5度的并行性执行。</p>
                        <p>您可以拆分默认列表分区，就像拆分任何其他列表分区一样。这也是将新分区添加到包含默认分区的列表分区表的唯一方法。拆分默认分区时，将创建由指定值定义的新分区，以及保留默认分区的第二个分区。</p>
                        <div class="infoboxnote" id="GUID-65E169AC-3224-405E-AD1D-9FBF4D5231BA__GUID-334B2EDE-84D0-4413-A121-C717D022E07E">
                           <p class="notep1">实时SQL：</p>
                           <p>在Oracle Live SQL上查看并运行Oracle Live SQL的相关示例<a href="https://livesql.oracle.com/apex/livesql/docs/vldbg/partitioning/split-list-partition.html" target="_blank"><span class="italic">：拆分列表分区表的DEFAULT分区</span></a> 。
                           </p>
                        </div>
                     </div>
                     <!-- class="section" -->
                     <div class="example" id="GUID-65E169AC-3224-405E-AD1D-9FBF4D5231BA__GUID-1410DBBB-613F-4204-A60B-DC90BED80D61">
                        <p class="titleinexample">示例4-37拆分列表分区表的默认分区</p>
                        <p>此示例拆分<code class="codeph">sales_by_region</code>的默认分区，从而创建新分区。
                        </p><pre class="oac_no_warn" dir="ltr">CREATE TABLE sales_by_region（dept_number NUMBER NOT NULL，dept_name VARCHAR2（20），quarterly_sales NUMBER（10,2），state VARCHAR2（2））PARTITION BY LIST（state）（PARTITION annual_north VALUES（'MN'，'WI'，'MI） '），PARTITION annual_south VALUES（'NM'，'TX'，'GA'），PARTITION annual_east VALUES（'MA'，'NY'，'NC'），PARTITION annual_west VALUES（'CA'，'OR'，' WA'），PARTITION unknown VALUES（DEFAULT））; SELECT PARTITION_NAME，HIGH_VALUE来自USER_TAB_PARTITIONS，其中TABLE_NAME ='SALES_BY_REGION'; PARTITION_NAME HIGH_VALUE -------------- ---------------未知默认年份_EAST'MA'，'NY'，'NC'YEARLY_NORTH'MN'， 'WI'，'MI'YEARLY_SOUTH'NM'，'TX'，'GA'YEARLY_WEST'CA'，'OR'，'WA 5行被选中。插入SALES_BY_REGION VALUES（002，'AUTO NORTH'，450000，'MN'）;插入SALES_BY_REGION VALUES（002，'AUTO NORTH'，495000，'WI'）;插入SALES_BY_REGION VALUES（002，'AUTO NORTH'，850000，'MI'）;插入SALES_BY_REGION VALUES（004，'AUTO SOUTH'，595000，'NM'）;插入SALES_BY_REGION VALUES（004，'AUTO SOUTH'，4825000，'TX'）;插入SALES_BY_REGION VALUES（004，'AUTO SOUTH'，945000，'GA'）;插入SALES_BY_REGION VALUES（006，'AUTO EAST'，2125000，'MA'）;插入SALES_BY_REGION VALUES（006，'AUTO EAST'，6101000，'NY'）;插入SALES_BY_REGION VALUES（006，'AUTO EAST'，741000，'NC'）;插入SALES_BY_REGION VALUES（008，'AUTO WEST'，7201000，'CA'）;插入SALES_BY_REGION VALUES（008，'AUTO WEST'，901000，'或'）;插入SALES_BY_REGION VALUES（008，'AUTO WEST'，1125000，'WA'）;插入SALES_BY_REGION VALUES（009，'AUTO MIDWEST'，1950000，'AZ'）;插入SALES_BY_REGION VALUES（009，'AUTO MIDWEST'，5725000，'UT'）; SELECT DEPT_NUMBER，DEPT_NAME，QUARTERLY_SALES，状态来自SALES_BY_REGION PARTITION（annual_north）; DEPT_NUMBER DEPT_NAME QUARTERLY_SALES ST ----------- -------------------- --------------- -  2 AUTO NORTH 450000 MN 2 AUTO NORTH 495000 WI 2 AUTO NORTH 850000 MI SELECT DEPT_NUMBER，DEPT_NAME，QUARTERLY_SALES，状态来自SALES_BY_REGION PARTITION（annual_south）; DEPT_NUMBER DEPT_NAME QUARTERLY_SALES ST ----------- -------------------- --------------- -  4 AUTO SOUTH 595000 NM 4 AUTO SOUTH 4825000 TX 4 AUTO SOUTH 945000 GA ... SELECT SALT_NUMBER，DEPT_NAME，QUARTERLY_SALES，状态来自SALES_BY_REGION PARTITION（未知）; DEPT_NUMBER DEPT_NAME QUARTERLY_SALES ST ----------- -------------------- --------------- -  9 AUTO MIDWEST 1950000 AZ 9 AUTO MIDWEST 5725000 UT <span class="bold">REM请注意以下ADD PARTITION语句失败。此操作失败，因为REM所有未定义的值都自动包含在DEFAULT分区中。</span>ALTER TABLE sales_by_region ADD PARTITION annual_midwest VALUES（'AZ'，'UT'）; <span class="bold">ORA-14323：DEFAULT分区存在时无法添加分区</span> <span class="bold">REM必须SPLIT DEFAULT分区才能添加新分区。</span>ALTER TABLE sales_by_region SPLIT PARTITION未知值（'AZ'，'UT'）INTO（PARTITION annual_midwest，PARTITION unknown）; SELECT PARTITION_NAME，HIGH_VALUE来自USER_TAB_PARTITIONS，其中TABLE_NAME ='SALES_BY_REGION'; PARTITION_NAME HIGH_VALUE -------------- --------------- UNKNOWN默认年份_EAST'MA'，'NY'，'NC'YEARLY_MIDWEST'AZ'， 'UT'YEARLY_NORTH'MN'，'WI'，'MI'YEARLY_SOUTH'NM'，'TX'，'GA'YEARLY_WEST'CA'，'OR'，'WA'6选择的行。SELECT DEPT_NUMBER，DEPT_NAME，QUARTERLY_SALES，状态来自SALES_BY_REGION PARTITION（annual_midwest）; DEPT_NUMBER DEPT_NAME QUARTERLY_SALES ST ----------- -------------------- --------------- -  9 AUTO MIDWEST 1950000 AZ 9 AUTO MIDWEST 5725000 UT SELECT DEPT_NUMBER，DEPT_NAME，QUARTERLY_SALES，状态来自SALES_BY_REGION PARTITION（未知）;没有选择行<span class="bold">REM再次拆分DEFAULT分区以添加新的“annual_mideast”分区。</span>ALTER TABLE sales_by_region SPLIT PARTITION未知值（'OH'，'IL'）INTO（PARTITION annual_mideast，PARTITION unknown）;表改变了。SELECT PARTITION_NAME，HIGH_VALUE来自USER_TAB_PARTITIONS，其中TABLE_NAME ='SALES_BY_REGION'; PARTITION_NAME HIGH_VALUE ------------------ ------------------ UNKNOWN DEFAULT YEARLY_EAST'MA'，'NY'，' NC'YEARLY_MIDEAST'OH'，'IL'YEARLY_MIDWEST'AZ'，'UT'YEARLY_NORTH'MN'，'WI'，'MI'YEARLY_SOUTH'NM'，'TX'，'GA'YEARLY_WEST'CA'，'OR' ，'WA'选择了7行。插入SALES_BY_REGION VALUES（007，'AUTO MIDEAST'，925000，'OH'）;插入SALES_BY_REGION VALUES（007，'AUTO MIDEAST'，1325000，'IL'）; SELECT DEPT_NUMBER，DEPT_NAME，QUARTERLY_SALES，状态来自SALES_BY_REGION PARTITION（annual_mideast）; DEPT_NUMBER DEPT_NAME QUARTERLY_SALES ST ----------- -------------------- --------------- -  7 AUTO MIDEAST 925000 OH 7 AUTO MIDEAST 1325000 IL SELECT DEPT_NUMBER，DEPT_NAME，QUARTERLY_SALES，状态来自SALES_BY_REGION PARTITION（未知）;没有选择任何行</pre></div>
                     <!-- class="example" -->
                  </div>
               </div><a id="VLDBG1211"></a><div class="props_rev_3"><a id="GUID-D329CC2A-57CB-470D-8990-89C5240F029C" name="GUID-D329CC2A-57CB-470D-8990-89C5240F029C"></a><h4 id="VLDBG-GUID-D329CC2A-57CB-470D-8990-89C5240F029C" class="sect4">拆分区间分区表的分区</h4>
                  <div>
                     <p>您可以使用间隔分区<code class="codeph">TABLE</code>的<code class="codeph">ALTER</code> <code class="codeph">TABLE</code> <code class="codeph">SPLIT</code> <code class="codeph">PARTITION</code>语句拆分范围或实现间隔分区。
                     </p>
                     <div class="section">
                        <p>在拆分范围分区表的分区中描述了在区间分区表中<a href="maintenance-partition-tables-indexes.html#GUID-C27329F1-00C6-4952-A411-4B9A278E4DE8" title="您可以使用ALTER TABLE SPLIT PARTITION语句拆分范围分区。">拆分范围分区</a> 。
                        </p>
                        <p>要拆分物化间隔分区，请在间隔分区中指定分区键列的值，以便拆分分区。生成的两个新分区中的第一个包括原始分区中的所有行，其分区键列值映射低于指定值。第二个分区包含分区键列值映射大于或等于指定值的所有行。拆分分区操作将转换点移动到刚拆分的分区的上边界，并且低于新拆分分区的所有物化间隔分区将隐式转换为范围分区，其上边界由间隔的上边界定义。</p>
                        <p>您可以选择为拆分产生的两个范围分区指定新属性。如果在表上定义了本地索引，则此语句还会拆分每个本地索引中的匹配分区。您无法拆分尚未创建的间隔分区。</p>
                        <p>以下示例显示在每月间隔分区表<code class="codeph">transactions</code>中拆分May 2007分区。
                        </p><pre class="oac_no_warn" dir="ltr">ALTER TABLE事务SPLIT PARTITION FOR（TO_DATE（'01 -MAY-2007'，'dd-MON-yyyy'））AT（TO_DATE（'15 -MAY-2007'，'dd-MON-yyyy'））;</pre></div>
                     <!-- class="section" -->
                  </div>
               </div><a id="VLDBG1212"></a><div class="props_rev_3"><a id="GUID-C8C1518E-0A19-46EE-9FFF-9245DE36E574" name="GUID-C8C1518E-0A19-46EE-9FFF-9245DE36E574"></a><h4 id="VLDBG-GUID-C8C1518E-0A19-46EE-9FFF-9245DE36E574" class="sect4">拆分* -Hash分区</h4>
                  <div>
                     <p>您可以使用<code class="codeph">ALTER</code> <code class="codeph">TABLE</code> <code class="codeph">SPLIT</code> <code class="codeph">PARTITION</code>语句拆分散列分区。
                     </p>
                     <div class="section">
                        <p>这与合并* -hash分区相反。拆分* -hash分区时，新的子分区将重新分配到<code class="codeph">SUBPARTITIONS</code>或<code class="codeph">SUBPARTITION</code>子句中指定的子分区数。或者，如果不包含此类子句，则新分区将从正在拆分的分区继承子分区（和表空间）的数量。
                        </p>
                        <p>分割* -hash分区时，属性的继承是不同的，而不是合并两个* -hash分区时。分割分区时，新分区可以从原始分区继承属性，因为只有一个父分区。但是，在合并分区时，必须从<span class="italic">表级</span>缺省值继承属性，因为有两个父级，并且新分区不能以另一个为代价继承。
                        </p>
                        <p>以下示例拆分范围哈希分区：</p><pre class="oac_no_warn" dir="ltr">ALTER TABLE all_seasons SPLIT PARTITION quarter_1 AT（TO_DATE（'16 -dec-1997'，'dd-mon-yyyy'））INTO（PARTITION q1_1997_1 SUBPARTITIONS 4 STORE IN（ts1，ts3），PARTITION q1_1997_2）;</pre><p>拆分interval-hash分区表的规则遵循拆分interval-partitioned表的规则。如<a href="maintenance-partition-tables-indexes.html#GUID-D329CC2A-57CB-470D-8990-89C5240F029C" title="您可以使用间隔分区表中的ALTER TABLE SPLIT PARTITION语句拆分范围或实现间隔分区。">拆分间隔分区表的分区中</a>所述，转换点将更改为拆分分区的较高边界。
                        </p>
                     </div>
                     <!-- class="section" -->
                  </div>
               </div><a id="VLDBG1213"></a><div class="props_rev_3"><a id="GUID-A0189FCC-2CD6-480F-8BDC-5160C1D232F2" name="GUID-A0189FCC-2CD6-480F-8BDC-5160C1D232F2"></a><h4 id="VLDBG-GUID-A0189FCC-2CD6-480F-8BDC-5160C1D232F2" class="sect4">在* -List分区表中拆分分区</h4>
                  <div>
                     <p>可以在列表分区表的分区级别和子分区级别拆分分区。</p>
                     <div class="section">
                        <ul style="list-style-type:disc">
                           <li>
                              <p><a href="maintenance-partition-tables-indexes.html#GUID-9CE3B6A2-53F8-477B-AF57-7FE28A38499E" title="您可以使用ALTER TABLE SPLIT PARTITION语句拆分列表分区。">拆分* -List分区</a></p>
                           </li>
                           <li>
                              <p><a href="maintenance-partition-tables-indexes.html#GUID-5FA38DE5-5CE0-4D72-A8DA-F6768AA59746" title="您可以使用ALTER TABLE SPLIT SUBPARTITION语句拆分列表子分区。">拆分* -List子分区</a></p>
                           </li>
                        </ul>
                     </div>
                     <!-- class="section" -->
                  </div><a id="VLDBG1214"></a><div class="props_rev_3"><a id="GUID-9CE3B6A2-53F8-477B-AF57-7FE28A38499E" name="GUID-9CE3B6A2-53F8-477B-AF57-7FE28A38499E"></a><h5 id="VLDBG-GUID-9CE3B6A2-53F8-477B-AF57-7FE28A38499E" class="sect5">拆分* -List分区</h5>
                     <div>
                        <p>您可以使用<code class="codeph">ALTER</code> <code class="codeph">TABLE</code> <code class="codeph">SPLIT</code> <code class="codeph">PARTITION</code>语句拆分列表分区。
                        </p>
                        <div class="section">
                           <p>拆分* -list分区表的分区类似于<a href="maintenance-partition-tables-indexes.html#GUID-65E169AC-3224-405E-AD1D-9FBF4D5231BA" title="您可以使用ALTER TABLE SPLIT PARTITION语句拆分列表分区。">拆分列表分区表的分区中</a>的描述。不能为任何一个新分区指定子分区文字值列表。新分区从正在拆分的原始分区继承子分区描述。
                           </p>
                           <p>以下示例拆分<code class="codeph">quarterly_regional_sales</code>表的<code class="codeph">q1_1999</code>分区：</p><pre class="oac_no_warn" dir="ltr">ALTER TABLE quarterly_regional_sales SPLIT PARTITION q1_1999 AT（TO_DATE（'15 -Feb-1999'，'dd-mon-yyyy'））INTO（PARTITION q1_1999_jan_feb TABLESPACE ts1，PARTITION q1_1999_feb_mar STORAGE（INITIAL 8M）TABLESPACE ts2）PARALLEL 5;</pre><p>此操作将分区<code class="codeph">q1_1999</code>为两个结果分区： <code class="codeph">q1_1999_jan_feb</code>和<code class="codeph">q1_1999_feb_mar</code> 。两个分区都从原始分区继承其子分区描述。各个分区具有新的物理属性，包括在分区级别指定的表空间。这些新属性成为新分区的默认属性。该操作以5度的并行性运行。
                           </p>
                           <p><code class="codeph">ALTER</code> <code class="codeph">TABLE</code> <code class="codeph">SPLIT</code> <code class="codeph">PARTITION</code>语句无法专门命名由复合分区表中的分区拆分产生的子分区。但是，对于父分区中具有分区名称<span class="italic"><code class="codeph">partition name_subpartition name</code></span>的名称的子分区，数据库使用新分区名称在新创建的子分区中生成相应的名称。为所有其他子分区分配<code class="codeph">SYS_SUBP</code> <span class="italic"><code class="codeph">n</code></span>形式的系统生成的名称。还为由未指定名称的拆分产生的任何分区的子分区分配系统生成的名称。为未命名的分区分配系统生成的分区名称，格式为<code class="codeph">SYS_P</code> <span class="italic"><code class="codeph">n</code></span> 。
                           </p>
                           <p>以下查询显示由表<code class="codeph">quarterly_regional_sales</code>上的先前拆分分区操作生成的子分区名称。它还反映了本章前面部分中对此表执行的其他操作的结果，因为它是在<a href="create-composite-partition-table.html#GUID-BE937517-A04E-45B9-A5C9-D7957B8D65F3" title="对于非复合范围分区表，范围列表复合分区表的范围分区被描述为相同。">关于创建复合范围列表分区表中创建的</a> 。
                           </p><pre class="oac_no_warn" dir="ltr">SELECT PARTITION_NAME，SUBPARTITION_NAME，TABLESPACE_NAME来自DBA_TAB_SUBPARTITIONS，其中TABLE_NAME ='QUARTERLY_REGIONAL_SALES'由PARTITION_NAME订购; PARTITION_NAME SUBPARTITION_NAME TABLESPACE_NAME -------------------- --------------------------- --- --------------- Q1_1999_FEB_MAR Q1_1999_FEB_MAR_WEST TS2 Q1_1999_FEB_MAR Q1_1999_FEB_MAR_NORTHEAST TS2 Q1_1999_FEB_MAR Q1_1999_FEB_MAR_SOUTHEAST TS2 Q1_1999_FEB_MAR Q1_1999_FEB_MAR_NORTHCENTRAL TS2 Q1_1999_FEB_MAR Q1_1999_FEB_MAR_SOUTHCENTRAL TS2 Q1_1999_FEB_MAR Q1_1999_FEB_MAR_SOUTH TS2 Q1_1999_JAN_FEB Q1_1999_JAN_FEB_WEST TS1 Q1_1999_JAN_FEB Q1_1999_JAN_FEB_NORTHEAST TS1 Q1_1999_JAN_FEB Q1_1999_JAN_FEB_SOUTHEAST TS1 Q1_1999_JAN_FEB Q1_1999_JAN_FEB_NORTHCENTRAL TS1 Q1_1999_JAN_FEB Q1_1999_JAN_FEB_SOUTHCENTRAL TS1 Q1_1999_JAN_FEB Q1_1999_JAN_FEB_SOUTH TS1 Q1_2000 Q1_2000_NORTHWEST TS3 Q1_2000 Q1_2000_SOUTHWEST TS3 Q1_2000 Q1_2000_NORTHEAST TS3 Q1_2000 Q1_2000_SOUTHEAST TS3 Q1_2000 Q1_2000_NORTHCENTRAL TS3 Q1_2000 Q1_2000_SOUTHCENTRAL TS3 Q2_1999 Q2_1999_NORTHWEST TS4 Q2_1999 Q2_1999_SOUTHWEST TS4 Q2_1999 Q2_1999_NORTHEAST TS4 Q2_1999 Q2_1999_SOUTHEAST TS4 Q2_1999 Q2_1999_NORTHCENTRAL TS 4 Q2_1999 Q2_1999_SOUTHCENTRAL TS4 Q3_1999 Q3_1999_NORTHWEST TS4 Q3_1999 Q3_1999_SOUTHWEST TS4 Q3_1999 Q3_1999_NORTHEAST TS4 Q3_1999 Q3_1999_SOUTHEAST TS4 Q3_1999 Q3_1999_NORTHCENTRAL TS4 Q3_1999 Q3_1999_SOUTHCENTRAL TS4 Q4_1999 Q4_1999_NORTHWEST TS4 Q4_1999 Q4_1999_SOUTHWEST TS4 Q4_1999 Q4_1999_NORTHEAST TS4 Q4_1999 Q4_1999_SOUTHEAST TS4 Q4_1999 Q4_1999_NORTHCENTRAL TS4 Q4_1999 Q4_1999_SOUTHCENTRAL TS4选择36行。</pre></div>
                        <!-- class="section" -->
                     </div>
                  </div><a id="VLDBG1215"></a><div class="props_rev_3"><a id="GUID-5FA38DE5-5CE0-4D72-A8DA-F6768AA59746" name="GUID-5FA38DE5-5CE0-4D72-A8DA-F6768AA59746"></a><h5 id="VLDBG-GUID-5FA38DE5-5CE0-4D72-A8DA-F6768AA59746" class="sect5">拆分* -List子分区</h5>
                     <div>
                        <p>您可以使用<code class="codeph">ALTER</code> <code class="codeph">TABLE</code> <code class="codeph">SPLIT</code> <code class="codeph">SUBPARTITION</code>语句拆分列表子分区。
                        </p>
                        <div class="section">
                           <p>拆分* -list分区表的列表子分区类似于<a href="maintenance-partition-tables-indexes.html#GUID-65E169AC-3224-405E-AD1D-9FBF4D5231BA" title="您可以使用ALTER TABLE SPLIT PARTITION语句拆分列表分区。">拆分列表分区表的分区中</a>的描述，但语法是<code class="codeph">SUBPARTITION</code>而不是<code class="codeph">PARTITION</code> 。例如，以下语句拆分<code class="codeph">quarterly_regional_sales</code>表的子分区：</p><pre class="oac_no_warn" dir="ltr">ALTER TABLE quarterly_regional_sales SPLIT SUBPARTITION q2_1999_southwest VALUES（'UT'）INTO（SUBPARTITION q2_1999_utah TABLESPACE ts2，SUBPARTITION q2_1999_southwest TABLESPACE ts3）PARALLEL;</pre><p>此操作将子分区<code class="codeph">q2_1999_southwest</code>为两个子分区：</p>
                           <ul style="list-style-type:disc">
                              <li>
                                 <p><code class="codeph">q2_1999_utah</code> ，文字值列表为<code class="codeph">('UT')</code> 
                                 </p>
                              </li>
                              <li>
                                 <p><code class="codeph">q2_1999_southwest</code>继承了<code class="codeph">('AZ','NM')</code>的剩余文字值列表</p>
                              </li>
                           </ul>
                           <p>各个子分区具有从正在拆分的子分区继承的新物理属性。</p>
                           <p>您只能在区间列表分区表中为范围分区或物化间隔分区拆分子分区。要更改将来间隔分区的子分区值，必须修改子分区模板。</p>
                        </div>
                        <!-- class="section" -->
                     </div>
                  </div>
               </div><a id="VLDBG1216"></a><div class="props_rev_3"><a id="GUID-FE363371-932E-4D94-AC73-1F6690B1A52A" name="GUID-FE363371-932E-4D94-AC73-1F6690B1A52A"></a><h4 id="VLDBG-GUID-FE363371-932E-4D94-AC73-1F6690B1A52A" class="sect4">拆分* -Range分区</h4>
                  <div>
                     <p>您可以使用<code class="codeph">ALTER</code> <code class="codeph">TABLE</code> <code class="codeph">SPLIT</code> <code class="codeph">PARTITION</code>语句拆分范围分区。
                     </p>
                     <div class="section">
                        <p>拆分* -range分区表的分区类似于<a href="maintenance-partition-tables-indexes.html#GUID-C27329F1-00C6-4952-A411-4B9A278E4DE8" title="您可以使用ALTER TABLE SPLIT PARTITION语句拆分范围分区。">拆分范围分区表的分区中</a>的描述。不能为任何一个新分区指定子分区范围值。新分区从正在拆分的原始分区继承子分区描述。
                        </p>
                        <p>以下示例拆分了区间范围分区<code class="codeph">orders</code>表的May 2007间隔分区：</p><pre class="oac_no_warn" dir="ltr">ALTER TABLE命令SPLIT PARTITION FOR（TO_DATE（'01 -MAY-2007'，'dd-MON-yyyy'））AT（TO_DATE（'15 -MAY-2007'，'dd-MON-yyyy'））INTO（PARTITION p_fh_may07，PARTITION p_sh_may2007）;</pre><p>此操作将间隔分区<code class="codeph">FOR('01-MAY-2007')</code>拆分为两个结果分区： <code class="codeph">p_fh_may07</code>和<code class="codeph">p_sh_may_2007</code> 。两个分区都从原始分区继承其子分区描述。已将6月2007分区之前的任何间隔分区转换为范围分区，如<a href="maintenance-partition-tables-indexes.html#GUID-EBB53BDB-23AB-4F35-BB88-4A7303FA5360" title="两个相邻间隔分区的内容可以合并为一个分区。">合并间隔分区中所述</a> 。
                        </p>
                        <p><code class="codeph">ALTER TABLE SPLIT PARTITION</code>语句无法专门命名由复合分区表中的分区拆分产生的子分区。但是，对于父分区中具有<span class="italic"><code class="codeph">partition name</code></span> <code class="codeph">_</code> <span class="italic"><code class="codeph">subpartition name</code></span>形式的<span class="italic"><code class="codeph">partition name</code></span> <span class="italic"><code class="codeph">subpartition name</code></span> ，数据库使用新分区名称在新创建的子分区中生成相应的名称。为所有其他子分区分配<code class="codeph">SYS_SUBP</code> <span class="italic"><code class="codeph">n</code></span>形式的系统生成的名称。还为由未指定名称的拆分产生的任何分区的子分区分配系统生成的名称。为未命名的分区分配系统生成的分区名称，格式为<code class="codeph">SYS_P</code> <span class="italic"><code class="codeph">n</code></span> 。
                        </p>
                        <p>以下查询显示对表<code class="codeph">orders</code>上的先前拆分分区操作产生的子分区名称和高值。它还反映了自创建以来本章前面几节中对此表执行的其他操作的结果。
                        </p><pre class="oac_no_warn" dir="ltr">BREAK ON partition_name SELECT partition_name，subpartition_name，high_value FROM user_tab_subpartitions WHERE table_name ='ORCERS'ORDER BY partition_name，subpartition_position; PARTITION_NAME SUBPARTITION_NAME HIGH_VALUE ------------------------- ---------------------- -------- --------------- P_BEFORE_2007 P_BEFORE_2007_P_SMALL 1000 P_BEFORE_2007_P_MEDIUM 10000 P_BEFORE_2007_P_LARGE 100000 P_BEFORE_2007_P_EXTRAORDINARY MAXVALUE P_FH_MAY07 SYS_SUBP2985 1000 SYS_SUBP2986 10000 SYS_SUBP2987 100000 SYS_SUBP2988 MAXVALUE P_PRE_MAY_2007 P_PRE_MAY_2007_P_SMALL 1000 P_PRE_MAY_2007_P_MEDIUM 10000 P_PRE_MAY_2007_P_LARGE 100000 P_PRE_MAY_2007_P_EXTRAORDINARY MAXVALUE P_SH_MAY2007 SYS_SUBP2989 1000 SYS_SUBP2990 10000 SYS_SUBP2991 100000 SYS_SUBP2992 MAXVALUE</pre></div>
                     <!-- class="section" -->
                  </div><a id="VLDBG1217"></a><div class="props_rev_3"><a id="GUID-C51ACA57-6814-4E22-B494-AA2F24D0EAE0" name="GUID-C51ACA57-6814-4E22-B494-AA2F24D0EAE0"></a><h5 id="VLDBG-GUID-C51ACA57-6814-4E22-B494-AA2F24D0EAE0" class="sect5">拆分* -Range子分区</h5>
                     <div>
                        <p>您可以使用<code class="codeph">ALTER</code> <code class="codeph">TABLE</code> <code class="codeph">SPLIT</code> <code class="codeph">SUBPARTITION</code>语句拆分范围子分区。
                        </p>
                        <div class="section">
                           <p>拆分* -range分区表的范围子分区类似于<a href="maintenance-partition-tables-indexes.html#GUID-C27329F1-00C6-4952-A411-4B9A278E4DE8" title="您可以使用ALTER TABLE SPLIT PARTITION语句拆分范围分区。">拆分范围分区表的分区中</a>的描述，但语法是<code class="codeph">SUBPARTITION</code>而不是<code class="codeph">PARTITION</code> 。例如，以下语句拆分<code class="codeph">orders</code>表的子分区：</p><pre class="oac_no_warn" dir="ltr">ALTER TABLE命令SPLIT SUBPARTITION p_pre_may_2007_p_large AT（50000）INTO（SUBPARTITION p_pre_may_2007_med_large TABLESPACE TS4，SUBPARTITION p_pre_may_2007_large_large TABLESPACE TS5）;</pre><p>此操作将子分区<code class="codeph">p_pre_may_2007_p_large</code>为两个子分区：</p>
                           <ul style="list-style-type:disc">
                              <li>
                                 <p><code class="codeph">p_pre_may_2007_med_large</code> ，值介于10000和50000之间</p>
                              </li>
                              <li>
                                 <p><code class="codeph">p_pre_may_2007_large_large</code> ，值介于50000和100000之间</p>
                              </li>
                           </ul>
                           <p>各个子分区具有从正在拆分的子分区继承的新物理属性。</p>
                           <p>您只能在范围分区或物化间隔分区的区间范围分区表中拆分子分区。要更改将来间隔分区的子分区边界，必须修改子分区模板。</p>
                        </div>
                        <!-- class="section" -->
                     </div>
                  </div>
               </div><a id="VLDBG1218"></a><div class="props_rev_3"><a id="GUID-B28D3E86-190D-44CC-A279-00D867A5B80B" name="GUID-B28D3E86-190D-44CC-A279-00D867A5B80B"></a><h4 id="VLDBG-GUID-B28D3E86-190D-44CC-A279-00D867A5B80B" class="sect4">拆分索引分区</h4>
                  <div>
                     <p>您无法在本地索引中显式拆分分区。只有在基础表中拆分分区时才会拆分本地索引分区。</p>
                     <div class="section">
                        <p>但是，您可以拆分全局索引分区，如以下示例所示：</p><pre class="oac_no_warn" dir="ltr">ALTER INDEX quon1 SPLIT PARTITION加拿大AT（100）INTO PARTITION加拿大1 ...，PARTITION加拿大2 ...）; ALTER INDEX quon1 REBUILD PARTITION canada1; ALTER INDEX quon1 REBUILD PARTITION canada2;</pre><p>正在拆分的索引可以包含索引数据，并且生成的分区不需要重建，除非原始分区以前标记为<code class="codeph">UNUSABLE</code> 。</p>
                     </div>
                     <!-- class="section" -->
                  </div>
               </div><a id="VLDBG14114"></a><div class="props_rev_3"><a id="GUID-01C14320-0D7B-48BE-A5AD-003DDA761277" name="GUID-01C14320-0D7B-48BE-A5AD-003DDA761277"></a><h4 id="VLDBG-GUID-01C14320-0D7B-48BE-A5AD-003DDA761277" class="sect4">拆分成多个分区</h4>
                  <div>
                     <p>您可以使用<code class="codeph">ALTER</code> <code class="codeph">TABLE</code>语句的<code class="codeph">SPLIT</code> <code class="codeph">PARTITION</code>和<code class="codeph">SPLIT</code> <code class="codeph">SUBPARTITION</code>子句将一个分区或子分区的内容重新分配到多个分区或子分区中。
                     </p>
                     <div class="section">
                        <p>拆分多个分区时，将丢弃与当前分区关联的段。每个新分区都会获得一个新段，并从当前源分区继承所有未指定的物理属性。拆分为多个分区时，也可以使用快速拆分。</p>
                        <p>您可以使用扩展拆分语法指定类似于create partitioned table SQL语句的新分区描述列表，而不是指定<code class="codeph">AT</code>或<code class="codeph">VALUES</code>子句。此外，最后一个新分区描述的范围或列表值子句是基于源分区的上限和为拆分产生的第一个（N-1）个新分区指定的绑定值派生的。
                        </p>
                        <p>以下SQL语句是将分区拆分为多个分区的示例。</p><pre class="oac_no_warn" dir="ltr">ALTER TABLE SPLIT PARTITION p0 INTO（分区p01值小于（25），分区p02值小于（50），分区p03值小于（75），分区p04）; ALTER TABLE SPLIT PARTITION p0 INTO（part p01 VALUES小于（25），PARTITION p02）;</pre><p>在第二个SQL示例中，分区<code class="codeph">p02</code>具有原始分区<code class="codeph">p0</code>上限。
                        </p>
                        <p>要将范围分区拆分为N个分区，必须在要拆分分区的分区范围内指定分区键列的（N-1）个值。指定的新非包含上限值必须按升序排列。第N个新分区的上限被分配了被分割的分区的上限值。可以选择性地指定由拆分产生的N个新分区的名称和物理属性。</p>
                        <p>要将列表分区拆分为N个分区，必须指定（N-1）个文字值列表，每个列表定义第一个（N-1）个分区，其中插入了具有相应分区键值的行。原始分区的其余行将插入到第N个新分区中，其值列表包含原始分区中的剩余文字值。没有两个值列表可以包含相同的分区值。指定的（N-1）值列表不能包含当前分区的所有分区值，因为第N个新分区将为空。此外，（N-1）值列表不能包含当前分区不存在的任何分区值。</p>
                        <p>将<code class="codeph">DEFAULT</code>列表分区或<code class="codeph">MAXVALUE</code>范围分区拆分为多个分区时，将使用文本值列表或指定的上限值创建第一个（N-1）个新分区，而拆分产生的第N个新分区具有<code class="codeph">DEFAULT</code>值或<code class="codeph">MAXVALUE</code> 。将复合分区表的分区拆分为多个分区假定现有的行为与继承分割产生的新分区的子分区的数量，名称，边界和物理属性有关。<code class="codeph">SPLIT_TABLE_SUBPARTITION</code>子句的扩展类似，允许将范围或列表子分区拆分为N个新子分区。
                        </p>
                        <p>SQL语句相对于本地和全局索引的行为保持不变。相应的本地索引分区被拆分为多个分区。如果分区表包含LOB列，则<code class="codeph">SPLIT</code> <code class="codeph">PARTITION</code>子句的现有语义将应用扩展语法;也就是说，为当前分区删除LOB数据和索引段，并为每个新分区的每个LOB列创建新段。当满足所需条件时，快速拆分优化将应用于多分区拆分操作。
                        </p>
                        <p>例如，以下SQL语句<code class="codeph">sales_Q4_2007</code>范围表<code class="codeph">sales</code>拆分划分的<code class="codeph">sales_Q4_2007</code>分区拆分为与下一年的季度对应的五个分区。在此示例中，分区<code class="codeph">sales_Q4_2008</code>隐式地成为拆分分区的上限。
                        </p><pre class="oac_no_warn" dir="ltr">ALTER TABLE销售SPLIT PARTITION sales_Q4_2007 INTO（PARTITION sales_Q4_2007价值不到（截至_（01-JAN-2008'，'dd-MON-yyyy'）），PARTITION sales_Q1_2008价值不到（截至_01-APR-2008'， 'dd-MON-yyyy'）），PARTITION sales_Q2_2008价值不到（截止日期（'01 -JUL-2008'，'dd-MON-yyyy'）），PARTITION sales_Q3_2008价值不到（截至_01 -OCT-2008） '，'dd-MON-yyyy'）），PARTITION sales_Q4_2008）;</pre><p>对于按列表分区的示例表<code class="codeph">customers</code> ，以下语句将分区<span class="bold">Europe</span>拆分为三个分区。
                        </p><pre class="oac_no_warn" dir="ltr">ALTER TABLE list_customers SPLIT PARTITION Europe INTO（PARTITION西欧VALUES（'GERMANY'，'FRANCE'），PARTITION南欧VALUES（'意大利'），PARTITION rest-europe）;</pre><p></p>
                     </div>
                     <!-- class="section" -->
                  </div>
               </div><a id="VLDBG00304"></a><div class="props_rev_3"><a id="GUID-5AEB1A3A-89F1-489B-824E-CCD955F94BD7" name="GUID-5AEB1A3A-89F1-489B-824E-CCD955F94BD7"></a><h4 id="VLDBG-GUID-5AEB1A3A-89F1-489B-824E-CCD955F94BD7" class="sect4">快速分割分割和分割子操作</h4>
                  <div>
                     <p>Oracle数据库通过创建两个新分区并将分区中的行重新分配到两个新分区来实现<code class="codeph">SPLIT</code> <code class="codeph">PARTITION</code>操作。
                     </p>
                     <p>这是一项耗时的操作，因为必须扫描正在拆分的分区的所有行，然后将它们逐个插入到新分区中。此外，如果您不使用<code class="codeph">UPDATE</code> <code class="codeph">INDEXES</code>子句，则本地索引和全局索引也需要重建。
                     </p>
                     <p>有时在拆分操作之后，一个新分区包含要拆分的分区中的所有行，而另一个分区不包含任何行。拆分表的第一个分区时经常会出现这种情况。数据库可以检测此类情况并可以优化拆分操作。此优化会导致快速拆分操作，其行为类似于添加分区操作。</p>
                     <p>具体而言，如果满足以下所有条件，数据库可以优化和加速<code class="codeph">SPLIT</code> <code class="codeph">PARTITION</code>操作：</p>
                     <ul style="list-style-type:disc">
                        <li>
                           <p>两个结果分区中的一个必须为空。</p>
                        </li>
                        <li>
                           <p>非空结果分区必须具有与要分割的分区相同的存储特性。特别：</p>
                           <ul style="list-style-type:disc">
                              <li>
                                 <p>如果要拆分的分区是复合的，那么新的非空结果分区中每个子分区的存储特性必须与要拆分的分区的子分区的存储特征相同。</p>
                              </li>
                              <li>
                                 <p>如果分区被分割包含<code class="codeph">LOB</code>列，则每个的存储特性<code class="codeph">LOB</code>在新的非空所得分区（子）分区必须相同的那些的<code class="codeph">LOB</code> （分）分区被拆分的分区。
                                 </p>
                              </li>
                              <li>
                                 <p>如果正在拆分具有溢出的索引组织表的分区，则新非空结果分区中的每个溢出（子）分区的存储特性必须与要分割的分区的溢出（子）分区的存储特性相同。</p>
                              </li>
                              <li>
                                 <p>如果正在拆分具有映射表的索引组织表的分区，则新的非空结果分区中的每个映射表（子）分区的存储特性必须与该分区的映射表（子）分区的存储特性相同分裂。</p>
                              </li>
                           </ul>
                        </li>
                     </ul>
                     <p>如果在拆分后满足这些条件，则即使您未指定<code class="codeph">UPDATE</code> <code class="codeph">INDEXES</code>子句，所有全局索引仍然可用。与两个结果分区关联的本地索引（子）分区如果在拆分之前可用，则仍然可用。对应于非空结果分区的本地索引（子）分区与分割的分区的本地索引（子）分区相同。对于<code class="codeph">SPLIT</code> <code class="codeph">SUBPARTITION</code>操作，同样的优化也适用。
                     </p>
                  </div>
               </div>
            </div><a id="VLDBG1219"></a><div class="props_rev_3"><a id="GUID-08DC6C40-64B8-4932-8FB6-E22BDC8F842B" name="GUID-08DC6C40-64B8-4932-8FB6-E22BDC8F842B"></a><h3 id="VLDBG-GUID-08DC6C40-64B8-4932-8FB6-E22BDC8F842B" class="sect3">关于截断分区和子分区</h3>
               <div>
                  <p>截断分区类似于删除分区，除了分区清空其数据，但没有物理丢弃。</p>
                  <p>使用<code class="codeph">ALTER</code> <code class="codeph">TABLE</code> <code class="codeph">TRUNCATE</code> <code class="codeph">PARTITION</code>语句从表分区中删除所有行。您不能截断索引分区。但是，如果为表定义了本地索引，则<code class="codeph">ALTER</code> <code class="codeph">TABLE</code> <code class="codeph">TRUNCATE</code> <code class="codeph">PARTITION</code>语句会截断每个本地索引中的匹配分区。除非指定<code class="codeph">UPDATE</code> <code class="codeph">INDEXES</code> ，否则任何全局索引都标记为<code class="codeph">UNUSABLE</code> ，必须重建。您不能将<code class="codeph">UPDATE</code> <code class="codeph">INDEXES</code>用于索引组织表。请改用<code class="codeph">UPDATE</code> <code class="codeph">GLOBAL</code> <code class="codeph">INDEXES</code> 。
                  </p>
                  <p>本节包含以下主题：</p>
                  <ul style="list-style-type:disc">
                     <li>
                        <p><a href="maintenance-partition-tables-indexes.html#GUID-603A7284-9B65-4A27-B192-9B7944851BF3" title="使用ALTER TABLE TRUNCATE PARTITION语句从表分区中删除所有行，包括或不包含回收空间。">关于截断表分区</a></p>
                     </li>
                     <li>
                        <p><a href="maintenance-partition-tables-indexes.html#GUID-2A1C159C-347E-457E-854F-4D67F89B83DB" title="您可以使用ALTER TABLE语句的TRUNCATE PARTITION子句截断范围或列表分区表中的多个分区。">截断多个分区</a></p>
                     </li>
                     <li>
                        <p><a href="maintenance-partition-tables-indexes.html#GUID-E4E0CACE-67CD-4C75-8B9D-0C16D858863D" title="使用ALTER TABLE TRUNCATE SUBPARTITION语句从复合分区表的子分区中删除所有行。">截断子分区</a></p>
                     </li>
                     <li>
                        <p><a href="maintenance-partition-tables-indexes.html#GUID-92748418-FB88-4A41-9CEF-E44D2D9A6464" title="您可以使用CASUNCE选项TRUNCATE TABLE，ALTER TABLE TRUNCATE PARTITION和ALTER TABLE TRUNCATE SUBPARTITION SQL语句对级联截断操作使用级联截断操作。">使用级联选项截断分区</a></p>
                     </li>
                  </ul>
                  <div class="section">
                     <div class="infoboxnotealso" id="GUID-08DC6C40-64B8-4932-8FB6-E22BDC8F842B__GUID-50894CF8-1291-4B3B-9E76-69F04F99B1E9">
                        <p class="notep1">也可以看看：</p>
                        <ul style="list-style-type:disc">
                           <li>
                              <p><a href="maintenance-partition-can-be-performed.html#GUID-087B87A6-959A-40C6-82AF-36E401FD089B" title="The partition maintenance operations DROP PARTITION and TRUNCATE PARTITION are optimized by making the index maintenance for metadata only.">用于删除和截断分区的异步全局索引维护，</a>以获取有关<a href="maintenance-partition-can-be-performed.html#GUID-087B87A6-959A-40C6-82AF-36E401FD089B" title="通过仅对元数据进行索引维护来优化分区维护操作DROP PARTITION和TRUNCATE PARTITION。">截断分区</a>的异步索引维护的信息</p>
                           </li>
                           <li>
                              <p><a href="maintenance-partition-tables-indexes.html#GUID-BAFFE31C-07A2-4ED6-BDCF-8ECB79D7FE7D" title="您可以从范围，间隔，列表或复合*中删除分区 -  [范围| list]分区表。">关于删除分区和子分区</a>有关删除分区的信息</p>
                           </li>
                        </ul>
                     </div>
                  </div>
                  <!-- class="section" -->
               </div><a id="VLDBG1220"></a><div class="props_rev_3"><a id="GUID-603A7284-9B65-4A27-B192-9B7944851BF3" name="GUID-603A7284-9B65-4A27-B192-9B7944851BF3"></a><h4 id="VLDBG-GUID-603A7284-9B65-4A27-B192-9B7944851BF3" class="sect4">关于截断表分区</h4>
                  <div>
                     <p>使用<code class="codeph">ALTER</code> <code class="codeph">TABLE</code> <code class="codeph">TRUNCATE</code> <code class="codeph">PARTITION</code>语句从表分区中删除所有行，包括或不包含回收空间。
                     </p>
                     <p>截断区间分区表中的分区不会移动转换点。您可以截断引用分区表中的分区和子分区。</p>
                     <ul style="list-style-type:disc">
                        <li>
                           <p><a href="maintenance-partition-tables-indexes.html#GUID-7772BC2E-2ECD-4136-9348-0D8D0F6BFB26" title="截断包含数据和全局索引的表分区时，可以使用多种方法之一。">截断包含数据和全局索引的表分区</a></p>
                        </li>
                        <li>
                           <p><a href="maintenance-partition-tables-indexes.html#GUID-FEAAC43A-1066-4697-8474-863181FE4F38" title="如果分区包含数据并具有参照完整性约束，则无法截断该分区。但是，如果没有其他数据引用要删除的分区中的任何数据，则可以使用多种方法之一。">截断包含数据和参照完整性约束的分区</a></p>
                        </li>
                     </ul>
                  </div><a id="VLDBG1222"></a><a id="VLDBG1223"></a><a id="VLDBG1224"></a><a id="VLDBG1221"></a><div class="props_rev_3"><a id="GUID-7772BC2E-2ECD-4136-9348-0D8D0F6BFB26" name="GUID-7772BC2E-2ECD-4136-9348-0D8D0F6BFB26"></a><h5 id="VLDBG-GUID-7772BC2E-2ECD-4136-9348-0D8D0F6BFB26" class="sect5">截断包含数据和全局索引的表分区</h5>
                     <div>
                        <p>截断包含数据和全局索引的表分区时，可以使用多种方法之一。</p>
                        <p>如果分区包含数据和全局索引，请使用以下方法之一（方法1,2或3）截断表分区。</p>
                        <div class="section">
                           <p class="subhead3" id="GUID-7772BC2E-2ECD-4136-9348-0D8D0F6BFB26__GUID-A8B2637A-58EC-4610-8D6F-13F377F2046B">方法1</p>
                        </div>
                        <!-- class="section" -->
                        <div class="section">
                           <p>在<code class="codeph">ALTER</code> <code class="codeph">TABLE</code> <code class="codeph">TRUNCATE</code> <code class="codeph">PARTITION</code>语句中保留全局索引。在此示例中，表<code class="codeph">sales</code>具有重建的全局索引<code class="codeph">sales_area_ix</code> 。
                           </p><pre class="oac_no_warn" dir="ltr">ALTER TABLE销售TRUNCATE PARTITION dec98; ALTER INDEX sales_area_ix REBUILD;</pre><p>此方法最适用于大型表，其中被截断的分区包含表中总数据的很大一部分。</p>
                        </div>
                        <!-- class="section" -->
                        <div class="section">
                           <p class="subhead3" id="GUID-7772BC2E-2ECD-4136-9348-0D8D0F6BFB26__GUID-A1210B85-4D3E-4CDF-BB7F-8D63EB5B610E">方法2</p>
                        </div>
                        <!-- class="section" -->
                        <div class="section">
                           <p>在发出<code class="codeph">ALTER</code> <code class="codeph">TABLE</code>之前，运行<code class="codeph">DELETE</code>语句以从分区中删除所有行<a id="d29958e13977" class="indexterm-anchor"></a> <code class="codeph">TRUNCATE</code> <code class="codeph">PARTITION</code>语句。<code class="codeph">DELETE</code>语句更新全局索引，还会触发触发器并生成重做和撤消日志。
                           </p>
                           <p>例如，要截断第一个分区，请运行以下语句：</p><pre class="oac_no_warn" dir="ltr">DELETE FROM sales PARTITION（dec98）; ALTER TABLE销售TRUNCATE PARTITION dec98;</pre><p>当截断的分区包含表中总数据的一小部分时，此方法最适用于小型表或大型表。</p>
                        </div>
                        <!-- class="section" -->
                        <div class="section">
                           <p class="subhead3" id="GUID-7772BC2E-2ECD-4136-9348-0D8D0F6BFB26__GUID-D06E8ED6-19E9-4739-A32E-B91232190EF9">方法3</p>
                        </div>
                        <!-- class="section" -->
                        <div class="section">
                           <p>在<code class="codeph">ALTER TABLE</code>语句中指定<code class="codeph">UPDATE</code> <code class="codeph">INDEXES</code> 。这会导致在截断分区时截断全局索引。
                           </p><pre class="oac_no_warn" dir="ltr">ALTER TABLE销售TRUNCATE PARTITION dec98 UPDATE INDEXES;</pre><p>通过异步全局索引维护，此操作是仅元数据操作。</p>
                        </div>
                        <!-- class="section" -->
                     </div>
                  </div><a id="VLDBG1226"></a><a id="VLDBG1227"></a><a id="VLDBG1225"></a><div class="props_rev_3"><a id="GUID-FEAAC43A-1066-4697-8474-863181FE4F38" name="GUID-FEAAC43A-1066-4697-8474-863181FE4F38"></a><h5 id="VLDBG-GUID-FEAAC43A-1066-4697-8474-863181FE4F38" class="sect5">截断包含数据和参照完整性约束的分区</h5>
                     <div>
                        <p>如果分区包含数据并具有参照完整性约束，则无法截断该分区。但是，如果没有其他数据引用要删除的分区中的任何数据，则可以使用多种方法之一。</p>
                        <p>选择以下任一方法（方法1或2）以截断表分区。</p>
                        <div class="section">
                           <p class="subhead3" id="GUID-FEAAC43A-1066-4697-8474-863181FE4F38__GUID-7376CAF8-6AEE-4AC5-90A5-2D30CE8883D4">方法1</p>
                        </div>
                        <!-- class="section" -->
                        <div class="section">
                           <p>禁用完整性约束，运行<code class="codeph">ALTER</code> <code class="codeph">TABLE</code> <code class="codeph">TRUNCATE</code> <code class="codeph">PARTITION</code>语句，然后重新启用完整性约束。此方法最适用于大型表，其中被截断的分区包含表中总数据的很大一部分。如果仍在其他表中引用数据，则必须删除该数据才能重新启用完整性约束。
                           </p>
                        </div>
                        <!-- class="section" -->
                        <div class="section">
                           <p class="subhead3" id="GUID-FEAAC43A-1066-4697-8474-863181FE4F38__GUID-ADD6B570-A92F-426F-85E8-0A163F2B2527">方法2</p>
                        </div>
                        <!-- class="section" -->
                        <div class="section">
                           <p>在发出<code class="codeph">ALTER</code> <code class="codeph">TABLE</code> <code class="codeph">TRUNCATE</code> <code class="codeph">PARTITION</code>语句之前，发出<code class="codeph">DELETE</code>语句以从分区中删除所有行。<code class="codeph">DELETE</code>语句强制执行参照完整性约束，还会触发触发器并生成重做和撤消日志。如果使用<code class="codeph">ON DELETE CASCADE</code>选项创建外键约束，则会删除引用表中的数据。
                           </p><pre class="oac_no_warn" dir="ltr">DELETE FROM sales partition（dec94）; ALTER TABLE销售TRUNCATE PARTITION dec94;</pre><p>当截断的分区包含表中总数据的一小部分时，此方法最适用于小型表或大型表。</p>
                        </div>
                        <!-- class="section" -->
                     </div>
                  </div>
               </div><a id="VLDBG14116"></a><div class="props_rev_3"><a id="GUID-2A1C159C-347E-457E-854F-4D67F89B83DB" name="GUID-2A1C159C-347E-457E-854F-4D67F89B83DB"></a><h4 id="VLDBG-GUID-2A1C159C-347E-457E-854F-4D67F89B83DB" class="sect4">截断多个分区</h4>
                  <div>
                     <p>您可以使用<code class="codeph">ALTER</code> <code class="codeph">TABLE</code>语句的<code class="codeph">TRUNCATE</code> <code class="codeph">PARTITION</code>子句截断范围或列表分区表中的多个分区。
                     </p>
                     <div class="section">
                        <p>在操作中截断本地索引的相应分区。除非指定了<code class="codeph">UPDATE</code> <code class="codeph">INDEXES</code>否则必须重建全局索引。
                        </p>
                        <p>在以下示例中， <code class="codeph">ALTER</code> <code class="codeph">TABLE</code> SQL语句截断<code class="codeph">TABLE</code>多个分区。请注意，数据被截断，但不会删除分区。
                        </p>
                        <div class="infoboxnote" id="GUID-2A1C159C-347E-457E-854F-4D67F89B83DB__GUID-31635179-EE91-4831-A4E8-5EB39B836A8B">
                           <p class="notep1">实时SQL：</p>
                           <p>在Oracle Live SQL上查看并运行Oracle Live SQL的相关示例<a href="https://livesql.oracle.com/apex/livesql/docs/vldbg/partitioning/truncate-partitions.html" target="_blank"><span class="italic">：截断范围分区表</span></a> 。
                           </p>
                        </div>
                     </div>
                     <!-- class="section" -->
                     <div class="example" id="GUID-2A1C159C-347E-457E-854F-4D67F89B83DB__GUID-461A8427-7529-4E61-A43F-527409033757">
                        <p class="titleinexample">示例4-38截断多个分区</p><pre class="oac_no_warn" dir="ltr">CREATE TABLE sales_partition_truncate（product_id NUMBER（6）NOT NULL，customer_id NUMBER NOT NULL，channel_id CHAR（1），promo_id NUMBER（6），sales_date DATE，quantity_sold INTEGER，amount_sold NUMBER（10,2））PARTITION BY RANGE（sales_date）SUBPARTITION BY LIST（channel_id）（PARTITION q3_2018值不到（截止日期为（'1-OCT-2018'，'DD-MON-YYYY'））（SUBPARTITION q3_2018_p_catalog VALUES（'C'），SUBPARTITION q3_2018_p_internet VALUES（'I'）， SUBPARTITION q3_2018_p_partners VALUES（'P'），SUBPARTITION q3_2018_p_direct_sales VALUES（'S'），SUBPARTITION q3_2018_p_tele_sales VALUES（'T'）），PARTITION q4_2018 VALUES（不到（'1-JAN-2019'，'DD-MON-YYYY） '））（SUBPARTITION q4_2018_p_catalog VALUES（'C'），SUBPARTITION q4_2018_p_internet VALUES（'I'），SUBPARTITION q4_2018_p_partners VALUES（'P'），SUBPARTITION q4_2018_p_direct_sales VALUES（'S'），SUBPARTITION q4_2018_p_tele_sales VALUES（'T'）），分区q1_2019价值低于（7月1日（'1-APR-2019'，'DD-MON-YYYY'））（提交q1_2019_p_cat alog VALUES（'C'），SUBPARTITION q1_2019_p_internet VALUES（'I'），SUBPARTITION q1_2019_p_partners VALUES（'P'），SUBPARTITION q1_2019_p_direct_sales VALUES（'S'），SUBPARTITION q1_2019_p_tele_sales VALUES（'T'）），PARTITION q2_2019 VALUE少于（TO_DATE（'1-JUL-2019'，'DD-MON-YYYY'））（SUBPARTITION q2_2019_p_catalog VALUES（'C'），SUBPARTITION q2_2019_p_internet VALUES（'I'），SUBPARTITION q2_2019_p_partners VALUES（'P'），SUBPARTITION q2_2019_p_direct_sales VALUES（'S'），SUBPARTITION q2_2019_p_tele_sales VALUES（'T'）），PARTITION q3_2019值少于（7月1日（'1-OCT-2019'，'DD-MON-YYYY'））（SUBPARTITION q3_2019_p_catalog VALUES（'C'） ），SUBPARTITION q3_2019_p_internet VALUES（'I'），SUBPARTITION q3_2019_p_partners VALUES（'P'），SUBPARTITION q3_2019_p_direct_sales VALUES（'S'），SUBPARTITION q3_2019_p_tele_sales VALUES（'T'）），PARTITION q4_2019 VALUE少于（TO_DATE（'1-） JAN-2020'，'DD-MON-YYYY'））（SUBPARTITION q4_2019_p_catalog VALUES（'C'），SUBPARTITION q4_2019_p_internet VALUES（'我'，SUBPARTITION q4_2019_p_partners VALUES（'P'），SUBPARTITION q4_2019_p_direct_sales VALUES（'S'），SUBPARTITION q4_2019_p_tele_sales VALUES（'T'）））; SELECT TABLE_NAME，PARTITION_NAME，SUBPARTITION_NAME FROM USER_TAB_SUBPARTITIONS WHERE TABLE_NAME ='SALES_PARTITION_TRUNCATE'; TABLE_NAME PARTITION_NAME SUBPARTITION_NAME ------------------------- --------------- ------- ------------ SALES_PARTITION_TRUNCATE Q1_2019 Q1_2019_P_CATALOG SALES_PARTITION_TRUNCATE Q1_2019 Q1_2019_P_DIRECT_SALES ...选择了30行。INSERT INTO sales_partition_truncate VALUES（1001,100，'C'，150，'10 -SEP-2018'，500,2000）; INSERT INTO sales_partition_truncate VALUES（1021,200，'C'，160，' -  11 -OV-2018'，100,1500）; INSERT INTO sales_partition_truncate VALUES（1001,100，'C'，150，'10-FEB-2019'，500,2000）; INSERT INTO sales_partition_truncate VALUES（1021,200，'S'，160，'16-FEB-2019'，100,1500）; INSERT INTO sales_partition_truncate VALUES（1002,110，'I'，180，'15 -JUN-2019'，100,1000）; INSERT INTO sales_partition_truncate VALUES（5010,150，'P'，200，'20 -AUG-2019'，1000,10000）; INSERT INTO sales_partition_truncate VALUES（1001,100，'T'，150，' -  12 -OCT-2019'，500,2000）; SELECT * FROM sales_partition_truncate; PRODUCT_ID CUSTOMER_ID C PROMO_ID SALES_DAT QUANTITY_SOLD AMOUNT_SOLD ---------- -----------  -  ---------- ---------  - ----------- ----------- 1001 100 C 150 10-SEP-18 500 2000 1021 200 C 160 16-NOV-18 100 1500 1001 100 C 150 10- FEB-19 500 2000 1021 200 S 160 16-FEB-19 100 1500 1002 110 I 180 15-JUN-19 100 1000 5010 150 P 200 20-AUG-19 1000 10000 1001 100 T 150 12-OCT-19 500 2000 7选中的行。ALTER TABLE sales_partition_truncate TRUNCATE PARTITIONS q3_2018，q4_2018; SELECT * FROM sales_partition_truncate; PRODUCT_ID CUSTOMER_ID C PROMO_ID SALES_DAT QUANTITY_SOLD AMOUNT_SOLD ---------- -----------  -  ---------- ---------  - ----------- ----------- 1001 100 C 150 10-FEB-19 500 2000 1021 200 S 160 16-FEB-19 100 1500 1002 110 I 180 15- JUN-19 100 1000 5010 150 P 200 20-AUG-19 1000 10000 1001 100 T 150 12-OCT-19 500 2000选择5行。SELECT TABLE_NAME，PARTITION_NAME，SUBPARTITION_NAME FROM USER_TAB_SUBPARTITIONS WHERE TABLE_NAME ='SALES_PARTITION_TRUNCATE'; TABLE_NAME PARTITION_NAME SUBPARTITION_NAME ------------------------- --------------- ------- ------------ SALES_PARTITION_TRUNCATE Q1_2019 Q1_2019_P_CATALOG SALES_PARTITION_TRUNCATE Q1_2019 Q1_2019_P_DIRECT_SALES ...SALES_PARTITION_TRUNCATE Q3_2018 Q3_2018_P_CATALOG SALES_PARTITION_TRUNCATE Q3_2018 Q3_2018_P_DIRECT_SALES SALES_PARTITION_TRUNCATE Q3_2018 Q3_2018_P_INTERNET SALES_PARTITION_TRUNCATE Q3_2018 Q3_2018_P_PARTNERS SALES_PARTITION_TRUNCATE Q3_2018 Q3_2018_P_TELE_SALES ...SALES_PARTITION_TRUNCATE Q4_2018 Q4_2018_P_CATALOG SALES_PARTITION_TRUNCATE Q4_2018 Q4_2018_P_DIRECT_SALES SALES_PARTITION_TRUNCATE Q4_2018 Q4_2018_P_INTERNET SALES_PARTITION_TRUNCATE Q4_2018 Q4_2018_P_PARTNERS SALES_PARTITION_TRUNCATE Q4_2018 Q4_2018_P_TELE_SALES ...选择了30行。
</pre></div>
                     <!-- class="example" -->
                  </div>
               </div><a id="VLDBG1228"></a><div class="props_rev_3"><a id="GUID-E4E0CACE-67CD-4C75-8B9D-0C16D858863D" name="GUID-E4E0CACE-67CD-4C75-8B9D-0C16D858863D"></a><h4 id="VLDBG-GUID-E4E0CACE-67CD-4C75-8B9D-0C16D858863D" class="sect4">截断子分区</h4>
                  <div>
                     <p>使用<code class="codeph">ALTER</code> <code class="codeph">TABLE</code> <code class="codeph">TRUNCATE</code> <code class="codeph">SUBPARTITION</code>语句从复合分区表的子分区中删除所有行。
                     </p>
                     <div class="section">
                        <p>截断子分区时，也会截断相应的本地索引子分区。</p>
                        <p>在以下示例中， <code class="codeph">ALTER</code> <code class="codeph">TABLE</code>语句截断<code class="codeph">TABLE</code>子分区中的数据。在此示例中，已删除行占用的空间可供表空间中具有<code class="codeph">DROP</code> <code class="codeph">STORAGE</code>子句的其他模式对象使用。请注意，数据被截断，但子分区不会被删除。
                        </p>
                     </div>
                     <!-- class="section" -->
                     <div class="example" id="GUID-E4E0CACE-67CD-4C75-8B9D-0C16D858863D__GUID-B273F97F-4084-4441-BC8C-459C6D11432C">
                        <p class="titleinexample">示例4-39截断多个子分区</p><pre class="oac_no_warn" dir="ltr">CREATE TABLE sales_partition_truncate（product_id NUMBER（6）NOT NULL，customer_id NUMBER NOT NULL，channel_id CHAR（1），promo_id NUMBER（6），sales_date DATE，quantity_sold INTEGER，amount_sold NUMBER（10,2））PARTITION BY RANGE（sales_date）SUBPARTITION BY LIST（channel_id）（PARTITION q3_2018值不到（截止日期为（'1-OCT-2018'，'DD-MON-YYYY'））（SUBPARTITION q3_2018_p_catalog VALUES（'C'），SUBPARTITION q3_2018_p_internet VALUES（'I'）， SUBPARTITION q3_2018_p_partners VALUES（'P'），SUBPARTITION q3_2018_p_direct_sales VALUES（'S'），SUBPARTITION q3_2018_p_tele_sales VALUES（'T'）），PARTITION q4_2018 VALUES（不到（'1-JAN-2019'，'DD-MON-YYYY） '））（SUBPARTITION q4_2018_p_catalog VALUES（'C'），SUBPARTITION q4_2018_p_internet VALUES（'I'），SUBPARTITION q4_2018_p_partners VALUES（'P'），SUBPARTITION q4_2018_p_direct_sales VALUES（'S'），SUBPARTITION q4_2018_p_tele_sales VALUES（'T'）），分区q1_2019价值低于（7月1日（'1-APR-2019'，'DD-MON-YYYY'））（提交q1_2019_p_cat alog VALUES（'C'），SUBPARTITION q1_2019_p_internet VALUES（'I'），SUBPARTITION q1_2019_p_partners VALUES（'P'），SUBPARTITION q1_2019_p_direct_sales VALUES（'S'），SUBPARTITION q1_2019_p_tele_sales VALUES（'T'）），PARTITION q2_2019 VALUE少于（TO_DATE（'1-JUL-2019'，'DD-MON-YYYY'））（SUBPARTITION q2_2019_p_catalog VALUES（'C'），SUBPARTITION q2_2019_p_internet VALUES（'I'），SUBPARTITION q2_2019_p_partners VALUES（'P'），SUBPARTITION q2_2019_p_direct_sales VALUES（'S'），SUBPARTITION q2_2019_p_tele_sales VALUES（'T'）），PARTITION q3_2019值少于（7月1日（'1-OCT-2019'，'DD-MON-YYYY'））（SUBPARTITION q3_2019_p_catalog VALUES（'C'） ），SUBPARTITION q3_2019_p_internet VALUES（'I'），SUBPARTITION q3_2019_p_partners VALUES（'P'），SUBPARTITION q3_2019_p_direct_sales VALUES（'S'），SUBPARTITION q3_2019_p_tele_sales VALUES（'T'）），PARTITION q4_2019 VALUE少于（TO_DATE（'1-） JAN-2020'，'DD-MON-YYYY'））（SUBPARTITION q4_2019_p_catalog VALUES（'C'），SUBPARTITION q4_2019_p_internet VALUES（'我'，SUBPARTITION q4_2019_p_partners VALUES（'P'），SUBPARTITION q4_2019_p_direct_sales VALUES（'S'），SUBPARTITION q4_2019_p_tele_sales VALUES（'T'）））; SELECT TABLE_NAME，PARTITION_NAME，SUBPARTITION_NAME FROM USER_TAB_SUBPARTITIONS WHERE TABLE_NAME ='SALES_PARTITION_TRUNCATE'; TABLE_NAME PARTITION_NAME SUBPARTITION_NAME ------------------------- --------------- ------- ------------ SALES_PARTITION_TRUNCATE Q1_2019 Q1_2019_P_CATALOG SALES_PARTITION_TRUNCATE Q1_2019 Q1_2019_P_DIRECT_SALES ...选择了30行。INSERT INTO sales_partition_truncate VALUES（1001,100，'C'，150，'10 -SEP-2018'，500,2000）; INSERT INTO sales_partition_truncate VALUES（1021,200，'C'，160，' -  11 -OV-2018'，100,1500）; INSERT INTO sales_partition_truncate VALUES（1001,100，'C'，150，'10-FEB-2019'，500,2000）; INSERT INTO sales_partition_truncate VALUES（1021,200，'S'，160，'16-FEB-2019'，100,1500）; INSERT INTO sales_partition_truncate VALUES（1002,110，'I'，180，'15 -JUN-2019'，100,1000）; INSERT INTO sales_partition_truncate VALUES（5010,150，'P'，200，'20 -AUG-2019'，1000,10000）; INSERT INTO sales_partition_truncate VALUES（1001,100，'T'，150，' -  12 -OCT-2019'，500,2000）; SELECT * FROM sales_partition_truncate; PRODUCT_ID CUSTOMER_ID C PROMO_ID SALES_DAT QUANTITY_SOLD AMOUNT_SOLD ---------- -----------  -  ---------- ---------  - ----------- ----------- 1001 100 C 150 10-SEP-18 500 2000 1021 200 C 160 16-NOV-18 100 1500 1001 100 C 150 10- FEB-19 500 2000 1021 200 S 160 16-FEB-19 100 1500 1002 110 I 180 15-JUN-19 100 1000 5010 150 P 200 20-AUG-19 1000 10000 1001 100 T 150 12-OCT-19 500 2000 7选中的行。ALTER TABLE sales_subpartition_truncate TRUNCATE SUBPARTITIONS q3_2018_p_catalog，q4_2018_p_catalog，q1_2019_p_catalog，q2_2019_p_catalog，q3_2019_p_catalog，q4_2019_p_catalog DROP STORAGE; SELECT * FROM sales_partition_truncate; PRODUCT_ID CUSTOMER_ID C PROMO_ID SALES_DAT QUANTITY_SOLD AMOUNT_SOLD ---------- -----------  -  ---------- ---------  - ----------- ----------- 1021 200 S 160 16-FEB-19 100 1500 1002 110 I 180 15-JUN-19 100 1000 5010 150 P 200 20- AUG-19 1000 10000 1001 100 T 150 12-OCT-19 500 2000选择了4行。SELECT TABLE_NAME，PARTITION_NAME，SUBPARTITION_NAME FROM USER_TAB_SUBPARTITIONS WHERE TABLE_NAME ='SALES_PARTITION_TRUNCATE'; TABLE_NAME PARTITION_NAME SUBPARTITION_NAME ------------------------- --------------- ------- ------------ SALES_PARTITION_TRUNCATE Q1_2019 Q1_2019_P_CATALOG SALES_PARTITION_TRUNCATE Q1_2019 Q1_2019_P_DIRECT_SALES ...选择了30行。
</pre></div>
                     <!-- class="example" -->
                  </div>
               </div><a id="VLDBG14115"></a><div class="props_rev_3"><a id="GUID-92748418-FB88-4A41-9CEF-E44D2D9A6464" name="GUID-92748418-FB88-4A41-9CEF-E44D2D9A6464"></a><h4 id="VLDBG-GUID-92748418-FB88-4A41-9CEF-E44D2D9A6464" class="sect4">使用级联选项截断分区</h4>
                  <div>
                     <p>您可以使用级联截断操作参考分区子表与<code class="codeph">CASCADE</code>的选项<code class="codeph">TRUNCATE</code> <code class="codeph">TABLE</code> ， <code class="codeph">ALTER</code> <code class="codeph">TABLE</code> <code class="codeph">TRUNCATE</code> <code class="codeph">PARTITION</code> ，和<code class="codeph">ALTER</code> <code class="codeph">TABLE</code> <code class="codeph">TRUNCATE</code> <code class="codeph">SUBPARTITION</code> SQL语句。
                     </p>
                     <div class="section">
                        <p>为<code class="codeph">TRUNCATE</code> <code class="codeph">TABLE</code>指定<code class="codeph">CASCADE</code>选项时，truncate table操作还会截断通过启用了<code class="codeph">ON</code> <code class="codeph">DELETE</code> <code class="codeph">CASCADE</code>已启用参照约束引用目标表的子表。这种级联动作递归地应用于孙子孙女，曾孙子孙女等。在根据启用的<code class="codeph">ON</code> <code class="codeph">DELETE</code> <code class="codeph">CASCADE</code>引用约束确定要截断的表集之后，如果通过来自集合外部的子节点的启用约束引用此集合中的任何表，则会引发错误。如果父级和子级通过多个引用约束连接，则如果至少有一个约束启用了<code class="codeph">ON</code> <code class="codeph">DELETE</code> <code class="codeph">CASCADE</code> ，则以父级为目标的<code class="codeph">TRUNCATE</code> <code class="codeph">TABLE</code> <code class="codeph">CASCADE</code>操作会成功。
                        </p>
                        <p>受操作影响的所有表都需要特权。为操作指定的任何其他选项（例如<code class="codeph">DROP</code> <code class="codeph">STORAGE</code>或<code class="codeph">PURGE</code> <code class="codeph">MATERIALIZED</code> <code class="codeph">VIEW</code> <code class="codeph">LOG</code> ）适用于受操作影响的所有表。
                        </p>
                        <p>指定<code class="codeph">CASCADE</code>选项时， <code class="codeph">TRUNCATE</code> <code class="codeph">PARTITION</code>和<code class="codeph">TRUNCATE</code> <code class="codeph">SUBPARTITION</code>操作将级联为引用作为目标表的子项的分区表。<code class="codeph">TRUNCATE</code>可以定位到引用分区层次结构中的任何级别，并从目标表开始级联到子表。子表上不需要特权，但<code class="codeph">TRUNCATE</code>操作的常见限制（例如表不能由不是分区约束的已启用参照约束引用）适用于受操作影响的所有表。
                        </p>
                        <p>如果为没有引用已分区子项的表指定<code class="codeph">CASCADE</code>选项，则会忽略该选项。为操作指定的任何其他选项（如<code class="codeph">DROP</code> <code class="codeph">STORAGE</code>或<code class="codeph">UPDATE</code> <code class="codeph">INDEXES</code> ）适用于受操作影响的所有表。
                        </p>
                        <p>默认情况下，级联选项处于关闭状态，因此它们不会影响Oracle数据库兼容性。</p><pre class="oac_no_warn" dir="ltr">ALTER TABLE销售TRUNCATE PARTITION dec2016 DROP STORAGE CASCADE UPDATE INDEXES;</pre></div>
                     <!-- class="section" -->
                  </div>
               </div>
            </div>
         </div>
      </article>
   </body>
</html>