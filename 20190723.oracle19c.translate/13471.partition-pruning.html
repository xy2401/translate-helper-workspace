<html lang="en-us" dir="ltr" xml:lang="en-us">
   <head>
      <meta http-equiv="Content-Type" content="text/html; charset=utf-8"></meta>
      <meta name="viewport" content="width=device-width, initial-scale=1"></meta>
      <meta http-equiv="X-UA-Compatible" content="IE=edge"></meta>
      <meta name="abstract" content="Partition pruning is an essential performance feature for data warehouses."></meta>
      <meta name="description" content="Partition pruning is an essential performance feature for data warehouses."></meta>
      <title>分区修剪</title>
      <meta property="og:site_name" content="Oracle Help Center"></meta>
      <meta property="og:title" content="VLDB and Partitioning Guide"></meta>
      <meta property="og:description" content="Partition pruning is an essential performance feature for data warehouses."></meta>
      <link rel="stylesheet" href="/sp_common/book-template/ohc-book-template/css/book.css"></link>
      <link rel="shortcut icon" href="/sp_common/book-template/ohc-common/img/favicon.ico"></link>
      <meta name="application-name" content="VLDB and Partitioning Guide"></meta>
      <meta name="generator" content="DITA Open Toolkit version 1.8.5 (Mode = doc)"></meta>
      <meta name="plugin" content="SP_docbuilder HTML plugin release 18.2.2"></meta>
      <link rel="alternate" href="vldb-and-partitioning-guide.pdf" title="PDF File" type="application/pdf"></link>
      <meta name="robots" content="all"></meta>
      <link rel="schema.dcterms" href="http://purl.org/dc/terms/"></link>
      <meta name="dcterms.created" content="2019-04-23T18:05:22-07:00"></meta>
      <meta name="dcterms.title" content="VLDB and Partitioning Guide"></meta>
      <meta name="dcterms.dateCopyrighted" content="2008, 2019"></meta>
      <meta name="dcterms.category" content="database"></meta>
      <meta name="dcterms.identifier" content="E96199-03"></meta>
      
      <meta name="dcterms.product" content="en/database/oracle/oracle-database/19"></meta>
      
      <link rel="prev" href="partition-availability.html" title="Previous" type="text/html"></link>
      <link rel="next" href="partition-wise-joins.html" title="Next" type="text/html"></link>
      <script>
        document.write('<style type="text/css">');
        document.write('body > .noscript, body > .noscript ~ * { visibility: hidden; }');
        document.write('</style>');
     </script>
      <script src="/sp_common/book-template/requirejs/require.js" data-main="/sp_common/book-template/ohc-book-template/js/book-config"></script>
      <script>
            if (window.require === undefined) {
                document.write('<script data-main="sp_common/book-template/ohc-book-template/js/book-config" src="sp_common/book-template/requirejs/require.js"><\/script>');
                document.write('<link href="sp_common/book-template/ohc-book-template/css/book.css" rel="stylesheet"/>');
            }
        </script>
      <script type="application/json" id="ssot-metadata">{"primary":{"category":{"short_name":"database","element_name":"Database","display_in_url":true},"suite":{"short_name":"oracle","element_name":"Oracle","display_in_url":true},"product_group":{"short_name":"not-applicable","element_name":"Not applicable","display_in_url":false},"product":{"short_name":"oracle-database","element_name":"Oracle Database","display_in_url":true},"release":{"short_name":"19","element_name":"Release 19","display_in_url":true}}}</script>
      
    <meta name="dcterms.isVersionOf" content="VLDBG"></meta>
    <meta name="dcterms.release" content="Release 19"></meta>
  </head>
   <body dir="ltr">
      <div class="noscript alert alert-danger text-center" role="alert">
         <a href="partition-availability.html" class="pull-left"><span class="glyphicon glyphicon-chevron-left" aria-hidden="true"></span>上一页</a> <a href="partition-wise-joins.html" class="pull-right">下一页<span class="glyphicon glyphicon-chevron-right" aria-hidden="true"></span></a> <span class="fa fa-exclamation-triangle" aria-hidden="true"></span>必须启用JavaScript才能正确显示此内容</div>
      <article>
         <header>
            <ol class="breadcrumb" vocab="http://schema.org/" typeof="BreadcrumbList">
               <li property="itemListElement" typeof="ListItem"><a href="index.html" property="item" typeof="WebPage"><span property="name">VLDB和分区指南</span></a></li>
               <li property="itemListElement" typeof="ListItem"><a href="partition-availability.html" property="item" typeof="WebPage"><span property="name">可用性，可管理性和性能的分区</span></a></li>
               <li class="active" property="itemListElement" typeof="ListItem">分区修剪</li>
            </ol>
            <a id="GUID-E677C85E-C5E3-4927-B3DF-684007A7B05D" name="GUID-E677C85E-C5E3-4927-B3DF-684007A7B05D"></a><a id="VLDBG00401"></a>
            
            <h2 id="VLDBG-GUID-E677C85E-C5E3-4927-B3DF-684007A7B05D" class="sect2">分区修剪</h2>
         </header>
         <div class="ind">
            <div>
               <p>分区修剪是数据仓库的基本性能特征。</p>
               <p>在分区修剪中，优化器分析SQL语句中的<code class="codeph">FROM</code>和<code class="codeph">WHERE</code>子句，以在构建分区访问列表时消除不需要的分区。此功能使Oracle数据库仅对与SQL语句相关的分区执行操作。
               </p>
               <p>讨论了以下主题：</p>
               <ul style="list-style-type:disc">
                  <li>
                     <p><a href="partition-pruning.html#GUID-45D3CCAF-17BC-4E79-8B7F-E65C7F1866F3" title="分区修剪大大减少了从磁盘检索的数据量并缩短了处理时间，从而提高了查询性能并优化了资源利用率。">分区修剪的好处</a></p>
                  </li>
                  <li>
                     <p><a href="partition-pruning.html#GUID-319F57EB-124A-4AFF-BBFC-B4EDA65212C4" title="可以对分区列执行分区修剪。">可用于分区修剪的信息</a></p>
                  </li>
                  <li>
                     <p><a href="partition-pruning.html#GUID-3F576B2F-FA87-472D-8B0F-27D88FD2B34F" title="Oracle是否使用分区修剪会反映在语句的执行计划中，无论是在EXPLAIN PLAN语句的计划表中还是在共享SQL区域中。">如何识别是否使用了分区修剪</a></p>
                  </li>
                  <li>
                     <p><a href="partition-pruning.html#GUID-9BDD910C-CD99-4470-B269-59A8020C95E6" title="Oracle主要根据静态谓词确定何时使用静态修剪。">静态分区修剪</a></p>
                  </li>
                  <li>
                     <p><a href="partition-pruning.html#GUID-DF8D6743-8786-4D7A-ACDF-0091F8E2FE3B" title="本主题介绍了Oracle动态分区修剪。">动态分区修剪</a></p>
                  </li>
                  <li>
                     <p><a href="partition-pruning.html#GUID-65DA5654-970B-4056-BFBF-C300C9A8AA2A" title="增强了分区修剪功能，以利用区域映射来修剪完整的分区。提供增强的修剪功能可以提供更好的性能，同时减少资源消耗并缩短信息时间。">使用区域映射进行分区修剪</a></p>
                  </li>
                  <li>
                     <p><a href="partition-pruning.html#GUID-6C660105-8ECE-4426-A795-5884E84B0A48" title="本主题介绍了分区修剪的技巧。">分区修剪技巧</a></p>
                  </li>
               </ul>
            </div><a id="VLDBG14026"></a><div class="props_rev_3"><a id="GUID-45D3CCAF-17BC-4E79-8B7F-E65C7F1866F3" name="GUID-45D3CCAF-17BC-4E79-8B7F-E65C7F1866F3"></a><h3 id="VLDBG-GUID-45D3CCAF-17BC-4E79-8B7F-E65C7F1866F3" class="sect3">分区修剪的好处</h3>
               <div>
                  <p>分区修剪大大减少了从磁盘检索的数据量并缩短了处理时间，从而提高了查询性能并优化了资源利用率。</p>
                  <p>如果在不同的列（使用全局分区索引）上对索引和表进行分区，则即使无法消除基础表的分区，分区修剪也会消除索引分区。</p>
                  <p>根据实际的SQL语句，Oracle数据库可能使用静态或动态修剪。静态修剪在编译时发生，其中包含有关事先访问的分区的信息。动态修剪在运行时发生，这意味着事先不知道语句要访问的确切分区。静态修剪的示例方案是包含<code class="codeph">WHERE</code>条件的SQL语句，该条件在分区键列上具有常量文字。动态修剪的一个示例是在<code class="codeph">WHERE</code>条件中使用运算符或函数。
                  </p>
                  <p>分区修剪会影响修剪发生的对象的统计信息，还会影响语句的执行计划。</p>
               </div>
            </div><a id="VLDBG14027"></a><a id="VLDBG1229"></a><div class="props_rev_3"><a id="GUID-319F57EB-124A-4AFF-BBFC-B4EDA65212C4" name="GUID-319F57EB-124A-4AFF-BBFC-B4EDA65212C4"></a><h3 id="VLDBG-GUID-319F57EB-124A-4AFF-BBFC-B4EDA65212C4" class="sect3">可用于分区修剪的信息</h3>
               <div>
                  <p>可以对分区列执行分区修剪。</p>
                  <p>当您在范围或列表分区列上使用范围， <code class="codeph">LIKE</code> ，相等和<code class="codeph">IN</code> -list谓词时，以及在散列分区列上使用相等和<code class="codeph">IN</code> -list谓词时，Oracle数据库会修剪分区。
                  </p>
                  <p>在复合分区对象上，Oracle数据库可以使用相关谓词在两个级别进行修剪。例如，请参阅表<code class="codeph">sales_range_hash</code> ，该表由<code class="codeph">s_saledate</code>列上的范围分区，并在<a href="partition-pruning.html#GUID-319F57EB-124A-4AFF-BBFC-B4EDA65212C4__BABDIGFB">示例3-1中</a>的列<code class="codeph">s_productid</code>上通过哈希进行子分区。
                  </p>
                  <p>Oracle使用分区列上的谓词来执行分区修剪，如下所示：</p>
                  <ul style="list-style-type:disc">
                     <li>
                        <p>使用范围分区时，Oracle仅访问分区<code class="codeph">sal99q2</code>和<code class="codeph">sal99q3</code> ，代表1999年第三和第四季度的分区。
                        </p>
                     </li>
                     <li>
                        <p>使用哈希子分区时，Oracle仅访问存储<code class="codeph">s_productid=1200</code>的行的每个分区中的一个子分区。子分区和谓词之间的映射是基于Oracle的内部哈希分布函数计算的。
                        </p>
                     </li>
                  </ul>
                  <p>引用分区表可以通过与引用表的连接来利用分区修剪。基于虚拟列的分区表受益于对SQL语句中使用虚拟列定义表达式的语句进行分区修剪。</p>
                  <div class="example" id="GUID-319F57EB-124A-4AFF-BBFC-B4EDA65212C4__BABDIGFB">
                     <p class="titleinexample">示例3-1创建具有分区修剪的表</p><pre class="oac_no_warn" dir="ltr">CREATE TABLE sales_range_hash（s_productid NUMBER，s_saledate DATE，s_custid NUMBER，s_totalprice NUMBER）PARRYTION BY RANGE（s_saledate）通过哈希（s_productid）子公司进行的子公司8（PARTITION sal99q1值小于（'01-APR-1999'，'DD- MONYYYY'）），PARTITION sal99q2价值不到（截止日期（'01 -JUL-1999'，'DD-MON-YYYY'）），PARTITION sal99q3价值低于（7月12日（'01 -OCT-1999'，' DD-MON-YYYY'）），PARTITION sal99q4值不到（截止日期（'01 -JAN-2000'，'DD-MON-YYYY'）））; SELECT * FROM sales_range_hash WHERE s_saledate BETWEEN（TO_DATE（'01 -JUL-1999'，'DD-MON-YYYY'））AND（TO_DATE（'01 -OCT-1999'，'DD-MON-YYYY'））和s_productid = 1200;</pre></div>
                  <!-- class="example" -->
               </div>
            </div><a id="VLDBG1230"></a><div class="props_rev_3"><a id="GUID-3F576B2F-FA87-472D-8B0F-27D88FD2B34F" name="GUID-3F576B2F-FA87-472D-8B0F-27D88FD2B34F"></a><h3 id="VLDBG-GUID-3F576B2F-FA87-472D-8B0F-27D88FD2B34F" class="sect3">如何识别是否使用了分区修剪</h3>
               <div>
                  <p>Oracle是否使用分区修剪会反映在语句的执行计划中，无论是在<code class="codeph">EXPLAIN</code> <code class="codeph">PLAN</code>语句的计划表中还是在共享SQL区域中。
                  </p>
                  <p>分区修剪信息反映在计划列<code class="codeph">PSTART</code> （ <code class="codeph">PARTITION_START</code> ）和<code class="codeph">PSTOP</code> （ <code class="codeph">PARTITION_STOP</code> ）中。对于序列语句，修剪信息也反映在<code class="codeph">OPERATION</code>和<code class="codeph">OPTIONS</code>列中。
                  </p>
                  <div class="infoboxnotealso" id="GUID-3F576B2F-FA87-472D-8B0F-27D88FD2B34F__GUID-1C3973A9-790A-4FD4-9B59-11E76F660B3C">
                     <p class="notep1">也可以看看：</p>
                     <p>有关<code class="codeph">EXPLAIN</code> <code class="codeph">PLAN</code>及其解释方法的更多信息，请<code class="codeph">EXPLAIN</code> <a href="../tgsql/generating-and-displaying-execution-plans.html#TGSQL271" target="_blank"><span><cite>“Oracle数据库SQL调优指南”</cite></span></a></p>
                  </div>
               </div>
            </div><a id="VLDBG1231"></a><div class="props_rev_3"><a id="GUID-9BDD910C-CD99-4470-B269-59A8020C95E6" name="GUID-9BDD910C-CD99-4470-B269-59A8020C95E6"></a><h3 id="VLDBG-GUID-9BDD910C-CD99-4470-B269-59A8020C95E6" class="sect3">静态分区修剪</h3>
               <div>
                  <p>Oracle主要根据静态谓词确定何时使用静态修剪。</p>
                  <p>在许多情况下，Oracle确定在编译时要访问的分区。如果使用静态谓词，则会发生静态分区修剪，但以下情况除外：</p>
                  <ul style="list-style-type:disc">
                     <li>
                        <p>使用子查询的结果进行分区修剪。</p>
                     </li>
                     <li>
                        <p>优化程序使用星形转换重写查询，并在星形转换后进行修剪。</p>
                     </li>
                     <li>
                        <p>最有效的执行计划是嵌套循环。</p>
                     </li>
                  </ul>
                  <p>这三种情况导致使用动态修剪。</p>
                  <p>如果在解析时Oracle可以识别访问哪个连续的分区集，则执行计划中的<code class="codeph">PSTART</code>和<code class="codeph">PSTOP</code>列显示正在访问的分区的开始值和结束值。任何其他分区修剪的情况，包括动态修剪，都会在<code class="codeph">PSTART</code>和<code class="codeph">PSTOP</code>显示KEY值，可选地还有一个附加属性。
                  </p>
                  <p>以下是一个例子：</p><pre class="oac_no_warn" dir="ltr">SQL&gt;解释select * from sales的计划，其中time_id = to_date（'01 -jan-2001'，'dd-mon-yyyy'）;解释。SQL&gt; select * from table（dbms_xplan.display）; PLAN_TABLE_OUTPUT ------------------------------------------------- ---------------------------------------------计划哈希值：3971874201 -------------------------------------------------- -------------------------------------------- | Id |操作|名称|行|字节|成本（％CPU）|时间| Pstart时| Pstop | -------------------------------------------------- -------------------------------------------- | 0 |选择声明| | 673 | 19517 | 27（8）| 00:00:01 | | | | 1 | PARTITION RANGE SINGLE | | 673 | 19517 | 27（8）| 00:00:01 | 17 | 17 | | * 2 |表访问完全|销售| 673 | 19517 | 27（8）| 00:00:01 | 17 | 17 | -------------------------------------------------- --------------------------------------------谓词信息（由操作识别ID）：  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  - - ---- 2  - 过滤器（“TIME_ID”= TO_DATE（'2001-01-01 00:00:00'，'yyyy-mm-dd hh24：mi：ss'））</pre><p>此计划显示Oracle访问分区号17，如<code class="codeph">PSTART</code>和<code class="codeph">PSTOP</code>列中所示。<code class="codeph">OPERATION</code>列显示<code class="codeph">PARTITION RANGE SINGLE</code> ，表示只访问了一个分区。如果<code class="codeph">OPERATION</code>显示<code class="codeph">PARTITION RANGE ALL</code> ，则正在访问所有分区，并且实际上不会进行修剪。然后<code class="codeph">PSTART</code>显示表的第一个分区， <code class="codeph">PSTOP</code>显示最后一个分区。
                  </p>
                  <p>无论创建了多少个间隔分区，在间隔分区表上进行全表扫描的执行计划显示1表示<code class="codeph">PSTART</code> ，1048575表示<code class="codeph">PSTOP</code> 。
                  </p>
               </div>
            </div><a id="VLDBG1232"></a><div class="props_rev_3"><a id="GUID-DF8D6743-8786-4D7A-ACDF-0091F8E2FE3B" name="GUID-DF8D6743-8786-4D7A-ACDF-0091F8E2FE3B"></a><h3 id="VLDBG-GUID-DF8D6743-8786-4D7A-ACDF-0091F8E2FE3B" class="sect3">动态分区修剪</h3>
               <div>
                  <p>本主题介绍了Oracle动态分区修剪。</p>
                  <p>如果可以进行修剪并且无法进行静态修剪，则会进行动态修剪。以下示例显示了多个动态修剪案例：</p>
                  <ul style="list-style-type:disc">
                     <li>
                        <p><a href="partition-pruning.html#GUID-07025249-EA81-44E7-A1C2-F56386248FA0" title="对分区列使用绑定变量的语句会导致动态修剪。">动态修剪与绑定变量</a></p>
                     </li>
                     <li>
                        <p><a href="partition-pruning.html#GUID-5B5893F9-4F64-46B1-B6CE-10BD1E7D6003" title="明确对分区列使用子查询的语句会导致动态修剪。">使用子查询进行动态修剪</a></p>
                     </li>
                     <li>
                        <p><a href="partition-pruning.html#GUID-273DE720-CEFF-43ED-8DB1-E0ADEB695433" title="使用星形转换由数据库转换的语句会导致动态修剪。">星变换的动态修剪</a></p>
                     </li>
                     <li>
                        <p><a href="partition-pruning.html#GUID-F57D9DC0-31D6-4A0F-A787-5A82723D88F5" title="使用嵌套循环连接最有效执行的语句使用动态修剪。">使用嵌套循环连接进行动态修剪</a></p>
                     </li>
                  </ul>
               </div><a id="VLDBG1233"></a><div class="props_rev_3"><a id="GUID-07025249-EA81-44E7-A1C2-F56386248FA0" name="GUID-07025249-EA81-44E7-A1C2-F56386248FA0"></a><h4 id="VLDBG-GUID-07025249-EA81-44E7-A1C2-F56386248FA0" class="sect4">动态修剪与绑定变量</h4>
                  <div>
                     <p>对分区列使用绑定变量的语句会导致动态修剪。</p>
                     <p>以下SQL语句就是一个示例。</p><pre class="oac_no_warn" dir="ltr">SQL&gt;解释select * from sales s的计划，其中time_id在（：a，：b，：c，：d）;解释。SQL&gt; select * from table（dbms_xplan.display）; PLAN_TABLE_OUTPUT ------------------------------------------------- --------------------------------------------------计划哈希值：513834092 --------------------------------------------- -------------------------------------------------- ---- | Id |操作|名称|行|字节|成本（％CPU）|时间| Pstart时| PSTOP | -------------------------------------------------- ------------------------------------------------- | 0 |选择声明| | 2517 | 72993 | 292（0）| 00:00:04 | | | | 1 | INLIST ITERATOR | | | | | | | | | 2 |分区范围ITERATOR | | 2517 | 72993 | 292（0）| 00:00:04 | KEY（I）| KEY（I）| | 3 |通过LOCAL INDEX ROWID表的访问权限销售| 2517 | 72993 | 292（0）| 00:00:04 | KEY（I）| KEY（I）| | 4 | BITMAP转换为ROWIDS | | | | | | | | | * 5 | BITMAP INDEX单一价值| SALES_TIME_BIX | | | | | KEY（I）| KEY（I）| -------------------------------------------------- -------------------------------------------------谓词信息（由操作ID标识）：------------------------------------------ --------- 5  - 访问（“TIME_ID”=：或“TIME_ID”=：B或“TIME_ID”=：C或“TIME_ID”=：D）</pre><p>对于并行执行计划，只有分区的开始和停止列包含分区修剪信息;操作列包含并行操作的信息，如以下示例所示：</p><pre class="oac_no_warn" dir="ltr">SQL&gt;解释select * from sales的计划，其中time_id在（：a，：b，：c，：d）;解释。SQL&gt; select * from table（dbms_xplan.display）; PLAN_TABLE_OUTPUT ------------------------------------------------- ------------------------------------------------计划哈希值：4058105390 ----------------------------------------------- -------------------------------------------------- | ID |操作|名称|行|字节|成本（％CP |时间| Pstart | Pstop | TQ | INOUT | PQ Dis | -------------------------- -------------------------------------------------- --------------------- | 0 | SELECT STATEMENT | | 2517 | 72993 | 75（36）| 00:00:01 | | | | | | | 1 | PX COORDINATOR | | | | | | | | | | | | 2 | PX SEND QC（RANDOM）|：TQ10000 | 2517 | 72993 | 75（36）| 00:00:01 | | | Q1,00 | P- &gt; S | QC（兰德| | 3 | PX BLOCK ITERATOR | | 2517 | 72993 | 75（36）| 00:00:01 | KEY（I）| KEY（I）| Q1,00 | PCWC | || * 4 | TABLE ACCESS FULL | SALES | 2517 | 72993 | 75（36）| 00:00:01 | KEY（I）| KEY（I）| Q1,00 | PCWP | | ----------- -------------------------------------------------- ------------------------------------谓词信息（由操作ID标识）：----- ---------------------------------------------- 4  -  filter（ “TIME_ID”=：或“TIME_ID”=：B或“TIME_ID”=：C或“TIME_ID”=：D）</pre><div class="infoboxnotealso" id="GUID-07025249-EA81-44E7-A1C2-F56386248FA0__GUID-26E87695-8CBB-4444-9E37-B30BD6FD3DC1">
                        <p class="notep1">也可以看看：</p>
                        <p>有关<code class="codeph">EXPLAIN PLAN</code>及其解释方法的更多信息，请<code class="codeph">EXPLAIN PLAN</code> <a href="../tgsql/generating-and-displaying-execution-plans.html#TGSQL271" target="_blank"><span><cite>“Oracle数据库SQL调优指南”</cite></span></a></p>
                     </div>
                  </div>
               </div><a id="VLDBG1234"></a><div class="props_rev_3"><a id="GUID-5B5893F9-4F64-46B1-B6CE-10BD1E7D6003" name="GUID-5B5893F9-4F64-46B1-B6CE-10BD1E7D6003"></a><h4 id="VLDBG-GUID-5B5893F9-4F64-46B1-B6CE-10BD1E7D6003" class="sect4">使用子查询进行动态修剪</h4>
                  <div>
                     <p>明确对分区列使用子查询的语句会导致动态修剪。</p>
                     <p>以下SQL语句就是一个示例。</p><pre class="oac_no_warn" dir="ltr">SQL&gt;解释来自sales中的select sum（amount_sold）的计划，其中time_id在（从fiscal_year = 2000的时间选择time_id）;解释。SQL&gt; select * from table（dbms_xplan.display）; PLAN_TABLE_OUTPUT PLAN_TABLE_OUTPUT ------------------------------------------------ -------------------------------------------------- - 计划哈希值：3827742054 ------------------------------------------- -------------------------------------------------- ------- | Id |操作|名称|行|字节|成本（％CPU）|时间| Pstart时| Pstop | -------------------------------------------------- -------------------------------------------------- | 0 |选择声明| | 1 | 25 | 523（5）| 00:00:07 | | | | 1 | SORT AGGREGATE | | 1 | 25 | | | | | | * 2 | HASH JOIN | | 191K | 4676K | 523（5）| 00:00:07 | | | | * 3 |表访问完全|时代| 304 | 3648 | 18（0）| 00:00:01 | | | | 4 |分区范围子项| | 918K | 11M | 498（4）| 00:00:06 | KEY（SQ）| KEY（SQ）| | 5 |表访问完全|销售| 918K | 11M | 498（4）| 00:00:06 | KEY（SQ）| KEY（SQ）| -------------------------------------------------- --------------------------------------------------谓词信息（由操作ID标识）：----------------------------------------- ---------- 2  - 访问（“TIME_ID”=“TIME_ID”）3  - 过滤器（“FISCAL_YEAR”= 2000）</pre><div class="infoboxnotealso" id="GUID-5B5893F9-4F64-46B1-B6CE-10BD1E7D6003__GUID-9599263C-6B40-484A-9986-8ABC1CEC1116">
                        <p class="notep1">也可以看看：</p>
                        <p>有关<code class="codeph">EXPLAIN PLAN</code>及其解释方法的更多信息，请<code class="codeph">EXPLAIN PLAN</code> <a href="../tgsql/generating-and-displaying-execution-plans.html#TGSQL271" target="_blank"><span><cite>“Oracle数据库SQL调优指南”</cite></span></a></p>
                     </div>
                  </div>
               </div><a id="VLDBG1235"></a><div class="props_rev_3"><a id="GUID-273DE720-CEFF-43ED-8DB1-E0ADEB695433" name="GUID-273DE720-CEFF-43ED-8DB1-E0ADEB695433"></a><h4 id="VLDBG-GUID-273DE720-CEFF-43ED-8DB1-E0ADEB695433" class="sect4">星变换的动态修剪</h4>
                  <div>
                     <p>使用星形转换由数据库转换的语句会导致动态修剪。</p>
                     <p>以下SQL语句就是一个示例。</p><pre class="oac_no_warn" dir="ltr">SQL&gt;解释选择p.prod_name，t.time_id，sum（s.amount_sold）来自销售额s，时间t，产品p的计划，其中s.time_id = t.time_id和s.prod_id = p.prod_id和t.fiscal_year = 2000和t.fiscal_week_number = 3和p.prod_category ='硬件'组由t.time_id，p.prod_name;解释。SQL&gt; select * from table（dbms_xplan.display）; PLAN_TABLE_OUTPUT ------------------------------------------------- -------------------------------------------------- ---计划哈希值：4020965003 ------------------------------------------ -------------------------------------------------- ---------- | Id |操作|名称|行|字节| Pstart时| Pstop | -------------------------------------------------- -------------------------------------------------- -  | 0 |选择声明| | 1 | 79 | | | | 1 | HASH GROUP BY | | 1 | 79 | | | | * 2 | HASH JOIN | | 1 | 79 | | | | * 3 | HASH JOIN | | 2 | 64 | | | | * 4 |表访问完全|时代| 6 | 90 | | | | 5 |分区范围子项| | 587 | 9979 | KEY（SQ）| KEY（SQ）| | 6 |通过LOCAL INDEX ROWID表的访问权限销售| 587 | 9979 | KEY（SQ）| KEY（SQ）| | 7 | BITMAP转换为ROWIDS | | | | | | | 8 | BITMAP和| | | | | | | 9 | BITMAP MERGE | | | | | | | 10 | BITMAP KEY ITERATION | | | | | | | 11 | BUFFER SORT | | | | | | | * 12 |表访问完全|时代| 6 | 90 | | | | * 13 | BITMAP INDEX RANGE SCAN | SALES_TIME_BIX | | | KEY（SQ）| KEY（SQ）| | 14 | BITMAP MERGE | | | | | | | 15 | BITMAP KEY ITERATION | | | | | | | 16 | BUFFER SORT | | | | | | | 17 |按INDEX ROWID表的访问权限|产品| 14 | 658 | | | | * 18 | INDEX RANGE SCAN | PRODUCTS_PROD_CAT_IX | 14 | | | | | * 19 | BITMAP INDEX RANGE SCAN | SALES_PROD_BIX | | | KEY（SQ）| KEY（SQ）| | 20 |按INDEX ROWID表的访问权限|产品| 14 | 658 | | | | * 21 | INDEX RANGE SCAN | PRODUCTS_PROD_CAT_IX | 14 | | | | -------------------------------------------------- -------------------------------------------------- - 谓词信息（由操作ID标识）：--------------------------------------- ------------ 2  -  access（“S”。“PROD_ID”=“P”。“PROD_ID”）3  - 访问（“S”。“TIME_ID”=“T”。“TIME_ID “）4  - 过滤器（”T“。”FISCAL_WEEK_NUMBER“= 3和”T“。”FISCAL_YEAR“= 2000）12  - 过滤器（”T“。”FISCAL_WEEK_NUMBER“= 3和”T“。”FISCAL_YEAR“= 2000） 13  - 访问（“S”。“TIME_ID”=“T”。“TIME_ID”）18  - 访问（“P”。“PROD_CATEGORY”=“硬件”）19  - 访问（“S”。“PROD_ID”=“P “。”PROD_ID“）21  - 访问（”P“。”PROD_CATEGORY“='硬件'）注-----  - 用于此语句的星形转换</pre><div class="infoboxnote" id="GUID-273DE720-CEFF-43ED-8DB1-E0ADEB695433__GUID-C81A4F68-0BE8-4FB6-B703-A828BCB8B617">
                        <p class="notep1">注意：</p>
                        <p>在此示例中，从计划表输出中删除了<code class="codeph">Cost (%CPU)</code>和<code class="codeph">Time</code>列。
                        </p>
                     </div>
                     <div class="infoboxnotealso" id="GUID-273DE720-CEFF-43ED-8DB1-E0ADEB695433__GUID-9235D6CF-F5A2-4989-84AD-CEFD8C55BCDA">
                        <p class="notep1">也可以看看：</p>
                        <p>有关<code class="codeph">EXPLAIN PLAN</code>及其解释方法的更多信息，请<code class="codeph">EXPLAIN PLAN</code> <a href="../tgsql/generating-and-displaying-execution-plans.html#TGSQL271" target="_blank"><span><cite>“Oracle数据库SQL调优指南”</cite></span></a></p>
                     </div>
                  </div>
               </div><a id="VLDBG1236"></a><div class="props_rev_3"><a id="GUID-F57D9DC0-31D6-4A0F-A787-5A82723D88F5" name="GUID-F57D9DC0-31D6-4A0F-A787-5A82723D88F5"></a><h4 id="VLDBG-GUID-F57D9DC0-31D6-4A0F-A787-5A82723D88F5" class="sect4">使用嵌套循环连接进行动态修剪</h4>
                  <div>
                     <p>使用嵌套循环连接最有效执行的语句使用动态修剪。</p>
                     <p>以下SQL语句就是一个示例。</p><pre class="oac_no_warn" dir="ltr">SQL&gt;解释select t.time_id的计划，sum（s.amount_sold）来自sales s，乘以t，其中s.time_id = t.time_id和t.fiscal_year = 2000，t.fiscal_week_number = 3 group by t.time_id;解释。SQL&gt; select * from table（dbms_xplan.display）; PLAN_TABLE_OUTPUT ------------------------------------------------- -------------------------------------------------- - 计划哈希值：50737729 -------------------------------------------- -------------------------------------------------- ------ | Id |操作|名称|行|字节|成本（％CPU）|时间| Pstart时| Pstop | -------------------------------------------------- -------------------------------------------------- | 0 |选择声明| | 6 | 168 | 126（4）| 00:00:02 | | | | 1 | HASH GROUP BY | | 6 | 168 | 126（4）| 00:00:02 | | | | 2 | NESTED LOOPS | | 3683 | 100K | 125（4）| 00:00:02 | | | | * 3 |表访问完全|时代| 6 | 90 | 18（0）| 00:00:01 | | | | 4 |分区范围ITERATOR | | 629 | 8177 | 18（6）| 00:00:01 | KEY | KEY | | * 5 |表访问完全|销售| 629 | 8177 | 18（6）| 00:00:01 | KEY | KEY | -------------------------------------------------- --------------------------------------------------谓词信息（由操作ID标识）：----------------------------------------- ---------- 3  - 过滤器（“T”。“FISCAL_WEEK_NUMBER”= 3和“T”。“FISCAL_YEAR”= 2000）5  - 过滤器（“S”。“TIME_ID”=“T”。 “TIME_ID”）</pre><div class="infoboxnotealso" id="GUID-F57D9DC0-31D6-4A0F-A787-5A82723D88F5__GUID-307C37D6-1724-4D35-9266-B7CFF340D655">
                        <p class="notep1">也可以看看：</p>
                        <p>有关<code class="codeph">EXPLAIN PLAN</code>及其解释方法的更多信息，请<code class="codeph">EXPLAIN PLAN</code> <a href="../tgsql/generating-and-displaying-execution-plans.html#TGSQL271" target="_blank"><span><cite>“Oracle数据库SQL调优指南”</cite></span></a></p>
                     </div>
                  </div>
               </div>
            </div><a id="VLDBG14224"></a><a id="VLDBG14225"></a><a id="VLDBG14101"></a><div class="props_rev_3"><a id="GUID-65DA5654-970B-4056-BFBF-C300C9A8AA2A" name="GUID-65DA5654-970B-4056-BFBF-C300C9A8AA2A"></a><h3 id="VLDBG-GUID-65DA5654-970B-4056-BFBF-C300C9A8AA2A" class="sect3">使用区域映射进行分区修剪</h3>
               <div>
                  <p>增强了分区修剪功能，以利用区域映射来修剪完整的分区。提供增强的修剪功能可以提供更好的性能，同时减少资源消耗并缩短信息时间。</p>
                  <p>区域映射是可以为表构建的独立访问结构。在表扫描期间，区域映射使您能够根据表列上的谓词修剪表的磁盘块和分区表的分区。区域映射与分区表的分区键列无关，因此具有区域映射的分区表上的语句可以基于非分区键列修剪分区。</p>
                  <div class="infoboxnotealso" id="GUID-65DA5654-970B-4056-BFBF-C300C9A8AA2A__GUID-A3F299E6-864B-4596-9592-9C09F3D54B92">
                     <p class="notep1">也可以看看：</p>
                     <p>有关区域映射和属性群集的信息，请<a href="../dwhsg/attribute-clustering.html#DWHSG-GUID-7B007A3C-53C2-4437-9E71-9ECECF8B4FAB" target="_blank"><span class="italic">参见“Oracle数据库数据仓库指南”</span></a></p>
                  </div>
                  <p>当区域映射列值与分区键列值相关时，使用区域映射进行分区修剪尤其有效。例如，关联可以在分区表本身的列之间，例如与同一分区表中的分区键列顺序日期相关的发货日期，或者在连接区映射列和分区表中，例如作为连接区域映射列维度表中的月份描述时间与分区表的分区键列日相关。</p>
                  <p><a href="partition-pruning.html#GUID-65DA5654-970B-4056-BFBF-C300C9A8AA2A__BABHBCEG">示例3-2</a>说明了对分区表的相关列的区域映射进行分区修剪。列<code class="codeph">s_shipdate</code>分区表中<code class="codeph">sales_range</code>与分区键列相关<code class="codeph">order_date</code> ，因为订单通常一两天内发货收到订单后。
                  </p>
                  <p>由于<code class="codeph">s_shipdate</code>与分区键列的相关性，此列上的任何选择性谓词<code class="codeph">s_shipdate</code>有可能为分区表<code class="codeph">sales_range</code>启用分区修剪，而不将列作为分区键的一部分。
                  </p>
                  <p>以下<code class="codeph">SELECT</code>语句查找1999年第一季度发布的所有订单：</p><pre class="oac_no_warn" dir="ltr">SELECT * FROM sales_range WHERE s_shipdate BETWEEN to_date（'01 / 01/1999'，'dd / mm / yyyy'）AND to_date（'03 / 01/1999'，'mm / dd / yyyy'）;</pre><p>在以前的<code class="codeph">SELECT</code>语句的执行计划中，区域映射用于分区修剪，也用于从必须访问的分区中修剪块。
                  </p>
                  <p>通过在执行计划的<code class="codeph">PSTART</code>和<code class="codeph">PSTOP</code>列中具有<code class="codeph">KEY(ZM)</code>来识别具有区域映射的分区修剪。所有访问的分区的块级别修剪由表访问时间（ <code class="codeph">id 2</code> ）处的过滤器谓词<code class="codeph">id 2</code> 。
                  </p>
                  <div class="example" id="GUID-65DA5654-970B-4056-BFBF-C300C9A8AA2A__BABHBCEG">
                     <p class="titleinexample">示例3-2具有属性聚类的分区表sales_range和相关列上的区域映射</p><pre class="oac_no_warn" dir="ltr">CREATE TABLE sales_range（s_productid NUMBER，s_saledate DATE，s_shipdate DATE，s_custid NUMBER，s_totalprice NUMBER）CLUSTERING BY（s_shipdate）with MATERIALIZED ZONEMAP PARTITION BY RANGE（s_saledate）（PARTITION sal99q1 VALUES少于（TO_DATE（'01 -APR-1999'， 'DD-MON-YYYY'）），PARTITION sal99q2价值不到（截止日期（'01 -JUL-1999'，'DD-MON-YYYY'）），分配sal99q3价值不到（7月12日（'01 -OCT-1999） '，'DD-MON-YYYY'）），PARTITION sal99q4值不到（截止日期（'01 -JAN-2000'，'DD-MON-YYYY'）））;</pre></div>
                  <!-- class="example" -->
                  <div class="example" id="GUID-65DA5654-970B-4056-BFBF-C300C9A8AA2A__GUID-DE5F25E7-383A-4A46-B6D9-BEF785DBE0DA">
                     <p class="titleinexample">示例3-3使用区域映射进行分区修剪的执行计划</p><pre class="oac_no_warn" dir="ltr">-------------------------------------------------- -------------------------------------------------- ----------- Id |操作|名称|行|字节|成本（％CPU）|时间| Pstart时| Pstop | -------------------------------------------------- -------------------------------------------------- ----------- 0 |选择声明| | | | 3（100）| | | | | 1 |分区范围ITERATOR | | 58 | 3306 | 3（0）| 00:00:01 | KEY（ZM）| KEY（ZM）| | * 2 |完全使用ZONEMAP的表访问| SALES_RANGE | 58 | 3306 | 3（0）| 00:00:01 | KEY（ZM）| KEY（ZM）| -------------------------------------------------- -------------------------------------------------- -----------</pre><pre class="oac_no_warn" dir="ltr">谓词信息（由操作ID标识）：----------------------------------------- ---------- 2  - 过滤器（（SYS_ZMAP_FILTER（'/ * ZM_PRUNING * / SELECT“ZONE_ID $”，BITAND时的情况（zm。“ZONE_STATE $”，1）= 1那么1个案例时（ zm。“MAX_1_S_SHIPDATE”&lt;：1或者zm。“MIN_1_S_SHIPDATE”&gt;：2）那么3 ELSE 2 END END FROM“SH”。“ZMAP $ _SALES_RANGE”zm WHERE zm。“ZONE_LEVEL $”= 0 ORDER BY zm。“ZONE_ID $“'，SYS_OP_ZONE_ID（ROWID），TO_DATE（'1999-01-01 00:00:00'，'syyyy-mm-dd hh24：mi：ss'），TO_DATE（'1999-03-01 00:00： 00'，'syyyy-mm-dd hh24：mi：ss'））&lt;3 AND“S_SHIPDATE”&gt; = TO_DATE（'1999-01-01 00:00:00'，'syyyy-mm-dd hh24：mi： ss'）和“S_SHIPDATE”&lt;= TO_DATE（'1999-03-01 00:00:00'，'syyyy-mm-dd hh24：mi：ss'）））</pre></div>
                  <!-- class="example" -->
               </div>
            </div><a id="VLDBG1237"></a><div class="props_rev_3"><a id="GUID-6C660105-8ECE-4426-A795-5884E84B0A48" name="GUID-6C660105-8ECE-4426-A795-5884E84B0A48"></a><h3 id="VLDBG-GUID-6C660105-8ECE-4426-A795-5884E84B0A48" class="sect3">分区修剪技巧</h3>
               <div>
                  <p>本主题介绍了分区修剪的技巧。</p>
                  <p>使用分区修剪时，应考虑以下事项：</p>
                  <ul style="list-style-type:disc">
                     <li>
                        <p><a href="partition-pruning.html#GUID-B3D411C4-FC7B-4630-ACB0-E49BFA540053" title="要从分区修剪中获得最大的性能优势，应避免使用需要数据库转换指定数据类型的构造。">数据类型转换</a></p>
                     </li>
                     <li>
                        <p><a href="partition-pruning.html#GUID-C3CEB8F8-064E-45C5-97EE-E3BF1D00D517" title="函数可以限制优化程序执行修剪的能力。">函数调用</a></p>
                     </li>
                     <li>
                        <p><a href="partition-pruning.html#GUID-88E16CEE-3CB1-4AD6-82B3-62B86B899A01" title="集合表可以限制优化程序执行修剪的能力。">收集表</a></p>
                     </li>
                  </ul>
               </div><a id="VLDBG1238"></a><div class="props_rev_3"><a id="GUID-B3D411C4-FC7B-4630-ACB0-E49BFA540053" name="GUID-B3D411C4-FC7B-4630-ACB0-E49BFA540053"></a><h4 id="VLDBG-GUID-B3D411C4-FC7B-4630-ACB0-E49BFA540053" class="sect4">数据类型转换</h4>
                  <div>
                     <p>要从分区修剪中获得最大的性能优势，应避免使用需要数据库转换指定数据类型的构造。</p>
                     <p>数据类型转换通常会导致动态修剪，否则可能会进行静态修剪。受益于静态修剪的SQL语句比受益于动态修剪的语句执行得更好。</p>
                     <p>使用Oracle <code class="codeph">DATE</code>数据类型时会发生数据类型转换的常见情况。Oracle <code class="codeph">DATE</code>数据类型不是字符串，但在查询数据库时仅表示为该字符串;表示的格式由实例或会话的NLS设置定义。因此，在将数据插入<code class="codeph">DATE</code>字段或在此类字段上指定谓词时，必须进行相同的反向转换。
                     </p>
                     <p>通过指定<code class="codeph">TO_DATE</code>转换，可以隐式或显式地进行转换。只有正确应用的<code class="codeph">TO_DATE</code>函数才能保证数据库可以唯一地确定日期值并将其用于静态修剪，这对单个分区访问尤其有用。
                     </p>
                     <p>请考虑以下针对<code class="codeph">sales</code>表运行的示例。您想知道2000年的总收入数字。有多种方法可以检索查询的答案，但并非每种方法都同样有效。
                     </p><pre class="oac_no_warn" dir="ltr">解释SELECT SUM（amount_sold）total_revenue FROM sales，WHERE time_id在'01 -JAN-00'和'31 -DEC-00'之间的计划;</pre><p>该计划现在应类似于以下内容：</p><pre class="oac_no_warn" dir="ltr">-------------------------------------------------- -------------------------------------------------- | Id |操作|名称|行|字节|成本（％CPU）|时间| Pstart时| Pstop | -------------------------------------------------- -------------------------------------------------- | 0 |选择声明| | 1 | 13 | 525（8）| 00:00:07 | | | | 1 | SORT AGGREGATE | | 1 | 13 | | | | | | * 2 |过滤器| | | | | | | | | 3 |分区范围ITERATOR | | 230K | 2932K | 525（8）| 00:00:07 | KEY | KEY | | * 4 |表访问完全|销售| 230K | 2932K | 525（8）| 00:00:07 | KEY | KEY | -------------------------------------------------- --------------------------------------------------谓词信息（由操作ID标识）：----------------------------------------- ---------- 2  - 过滤器（TO_DATE（'01 -JAN-00'）&lt;= TO_DATE（'31 -DEC-00'））4  - 过滤器（“TIME_ID”&gt; =''01-JAN -00'和“TIME_ID”&lt;='31-DEC-00'）</pre><p>在这种情况下， <code class="codeph">PSTART</code>和<code class="codeph">PSTOP</code>的关键字<code class="codeph">KEY</code>表示动态分区修剪在运行时发生。考虑以下情况。
                     </p><pre class="oac_no_warn" dir="ltr">解释来自销售的精选金额（amount_sold）的计划，其中time_id介于'01 -JAN-2000'和'31 -DEC-2000'之间;</pre><p>执行计划现在显示以下内容：</p><pre class="oac_no_warn" dir="ltr">-------------------------------------------------- -------------------------------------- | Id |操作|名称|行|字节|成本（％CPU）| Pstart时| Pstop | -------------------------------------------------- -------------------------------------- | 0 |选择声明| | 1 | 13 | 127（4）| | | | 1 | SORT AGGREGATE | | 1 | 13 | | | | | 2 |分区范围ITERATOR | | 230K | 2932K | 127（4）| 13 | 16 | | * 3 |表访问完全|销售| 230K | 2932K | 127（4）| 13 | 16 | -------------------------------------------------- --------------------------------------谓词信息（由操作ID识别）：--- ------------------------------------------------ 3  - 过滤器（“TIME_ID”&lt;= TO_DATE（'2000-12-31 00:00:00'，“syyyy-mm-dd hh24：mi：ss'））</pre><div class="infoboxnote" id="GUID-B3D411C4-FC7B-4630-ACB0-E49BFA540053__GUID-FB2F8EAD-76AB-486E-96B8-3BF0FFFE0A7F">
                        <p class="notep1">注意：</p>
                        <p><code class="codeph">Time</code>列已从执行计划中删除。
                        </p>
                     </div>
                     <p>执行计划显示静态分区修剪。该查询访问连续的分区列表13至16。在这种特殊情况下，指定日期格式的方式与NLS日期格式设置相匹配。虽然此示例显示了最有效的执行计划，但您不能依赖NLS日期格式设置来定义特定格式。</p><pre class="oac_no_warn" dir="ltr">alter session set nls_date_format ='fmdd month yyyy';解释来自销售的精选金额（amount_sold）的计划，其中time_id介于'01 -JAN-2000'和'31 -DEC-2000'之间;</pre><p>执行计划现在显示以下内容：</p><pre class="oac_no_warn" dir="ltr">-------------------------------------------------- --------------------------------------- | Id |操作|名称|行|字节|成本（％CPU）| Pstart时| Pstop | -------------------------------------------------- --------------------------------------- | 0 |选择声明| | 1 | 13 | 525（8）| | | | 1 | SORT AGGREGATE | | 1 | 13 | | | | | * 2 |过滤器| | | | | | | | 3 |分区范围ITERATOR | | 230K | 2932K | 525（8）| KEY | KEY | | * 4 |表访问完全|销售| 230K | 2932K | 525（8）| KEY | KEY | -------------------------------------------------- ---------------------------------------谓词信息（由操作ID标识）： - ------------------------------------------------- 2 - 过滤器（TO_DATE（'01 -JAN-2000'）&lt;= TO_DATE（'31 -DEC-2000'））4  - 过滤器（“TIME_ID”&gt; ='01-JAN-2000'和“TIME_ID”&lt;='31 -DEC-2000' ）</pre><div class="infoboxnote" id="GUID-B3D411C4-FC7B-4630-ACB0-E49BFA540053__GUID-30F3D909-0B3C-4EC0-BD99-0CCB55DFB40C">
                        <p class="notep1">注意：</p>
                        <p><code class="codeph">Time</code>列已从执行计划中删除。
                        </p>
                     </div>
                     <p>此计划使用动态修剪，再次效率低于静态修剪执行计划。要保证静态分区修剪计划，应显式转换数据类型以匹配分区列数据类型。例如：</p><pre class="oac_no_warn" dir="ltr">解释销售中选择金额（amount_sold）的计划，其中time_id介于to_date（'01 -JAN-2000'，'dd-MON-yyyy'）和to_date（'31 -DEC-2000'，'dd-MON-yyyy'）之间; -------------------------------------------------- -------------------------------------- | Id |操作|名称|行|字节|成本（％CPU）| Pstart时| Pstop | -------------------------------------------------- -------------------------------------- | 0 |选择声明| | 1 | 13 | 127（4）| | | | 1 | SORT AGGREGATE | | 1 | 13 | | | | | 2 |分区范围ITERATOR | | 230K | 2932K | 127（4）| 13 | 16 | | * 3 |表访问完全|销售| 230K | 2932K | 127（4）| 13 | 16 | -------------------------------------------------- --------------------------------------谓词信息（由操作ID识别）：--- ------------------------------------------------ 3  - 过滤器（“TIME_ID”&lt;= TO_DATE（'2000-12-31 00:00:00'，'syyyy-mm-dd hh24：mi：ss'））</pre><div class="infoboxnote" id="GUID-B3D411C4-FC7B-4630-ACB0-E49BFA540053__GUID-9EB6FF49-D906-49F2-9FAC-07B8377D61BC">
                        <p class="notep1">注意：</p>
                        <p><code class="codeph">Time</code>列已从执行计划中删除。
                        </p>
                     </div>
                     <div class="infoboxnotealso" id="GUID-B3D411C4-FC7B-4630-ACB0-E49BFA540053__GUID-E02543A1-66EF-46A1-A7CD-7281826AC601">
                        <p class="notep1">也可以看看：</p>
                        <p></p>
                        <ul style="list-style-type:disc">
                           <li>
                              <p>有关<code class="codeph">DATE</code>数据类型的详细信息，请<a href="../sqlrf/Data-Types.html#SQLRF00202" target="_blank"><span><cite>参见Oracle数据库SQL语言参考</cite></span></a></p>
                           </li>
                           <li>
                              <p>有关NLS设置和全球化问题的详细信息，请参阅<a href="../nlspg/setting-up-globalization-support-environment.html#NLSPG003" target="_blank"><span><cite>Oracle数据库全球化支持指南</cite></span></a></p>
                           </li>
                        </ul>
                     </div>
                  </div>
               </div><a id="VLDBG1239"></a><div class="props_rev_3"><a id="GUID-C3CEB8F8-064E-45C5-97EE-E3BF1D00D517" name="GUID-C3CEB8F8-064E-45C5-97EE-E3BF1D00D517"></a><h4 id="VLDBG-GUID-C3CEB8F8-064E-45C5-97EE-E3BF1D00D517" class="sect4">函数调用</h4>
                  <div>
                     <p>函数可以限制优化程序执行修剪的能力。</p>
                     <p>有几种情况，优化程序无法执行修剪。一个常见原因是在分区列顶部使用运算符。这可以是显式运算符（例如，函数），甚至是Oracle引入的隐式运算符，作为执行语句所必需的数据类型转换的一部分。例如，请考虑以下查询：</p><pre class="oac_no_warn" dir="ltr">SELECT SUM（quantity_sold）的销售计划FROM sales WHERE time_id = TO_TIMESTAMP（'1-jan-2000'，'dd-mon-yyyy'）;</pre><p>因为<code class="codeph">time_id</code>的类型为<code class="codeph">DATE</code>并且Oracle必须将其提升为<code class="codeph">TIMESTAMP</code>类型以获取相同的数据类型，所以此谓词在内部被重写为：</p><pre class="oac_no_warn" dir="ltr">TO_TIMESTAMP（time_id）= TO_TIMESTAMP（'1-jan-2000'，'dd-mon-yyyy'）</pre><p>该声明的执行计划如下：</p><pre class="oac_no_warn" dir="ltr">-------------------------------------------------- ------------------------------------------ | Id |操作|名称|行|字节|成本（％CPU）|时间| Pstart时| Pstop | -------------------------------------------------- ------------------------------------------ | 0 |选择声明| | 1 | 11 | 6（17）| 00:00:01 | | | | 1 | SORT AGGREGATE | | 1 | 11 | | | | | | 2 | PARTITION RANGE ALL | | 10 | 110 | 6（17）| 00:00:01 | 1 | 16 | | * 3 |表访问完全|销售| 10 | 110 | 6（17）| 00:00:01 | 1 | 16 | -------------------------------------------------- ------------------------------------------谓词信息（由操作ID标识） ：------------------------------------------------- -  3  - 过滤器（INTERNAL_FUNCTION（“TIME_ID”）= TO_TIMESTAMP（'1-jan-2000'，：B1））选择了15行</pre><p><code class="codeph">SELECT</code>语句访问所有分区，即使可能已经发生了修剪到单个分区。考虑一个示例来查找2000年的总销售收入数。构建查询的另一种方法是：</p><pre class="oac_no_warn" dir="ltr">用于SELECT SUM的EXPLAIN PLAN（amount_sold）FROM销售WHERE TO_CHAR（time_id，'yyyy'）='2000';</pre><p>此查询将对函数调用应用于分区键列，这通常会禁用分区修剪。执行计划显示没有分区修剪的全表扫描：</p><pre class="oac_no_warn" dir="ltr">-------------------------------------------------- -------------------------------------------- | Id |操作|名称|行|字节|成本（％CPU）|时间| Pstart时| Pstop | -------------------------------------------------- -------------------------------------------- | 0 |选择声明| | 1 | 13 | 527（9）| 00:00:07 | | | | 1 | SORT AGGREGATE | | 1 | 13 | | | | | | 2 | PARTITION RANGE ALL | | 9188 | 116K | 527（9）| 00:00:07 | 1 | 28 | | * 3 |表访问完全|销售| 9188 | 116K | 527（9）| 00:00:07 | 1 | 28 | -------------------------------------------------- --------------------------------------------谓词信息（由操作识别ID）：  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  - - ---- 3  - 过滤器（TO_CHAR（INTERNAL_FUNCTION（“TIME_ID”），'yyyy'）='2000'）</pre><p>避免在分区列上使用隐式或显式函数。如果您的查询通常使用函数调用，那么在这些情况下，请考虑使用虚拟列和虚拟列分区来从分区修剪中受益。</p>
                  </div>
               </div><a id="VLDBG1240"></a><div class="props_rev_3"><a id="GUID-88E16CEE-3CB1-4AD6-82B3-62B86B899A01" name="GUID-88E16CEE-3CB1-4AD6-82B3-62B86B899A01"></a><h4 id="VLDBG-GUID-88E16CEE-3CB1-4AD6-82B3-62B86B899A01" class="sect4">收集表</h4>
                  <div>
                     <p>集合表可以限制优化程序执行修剪的能力。</p>
                     <p>以下示例说明了<code class="codeph">EXPLAIN</code> <code class="codeph">PLAN</code>语句在包含Collection Tables时的样子，为了本讨论的目的，这些表是有序集合表或嵌套表。不执行全表访问，因为它仅限于所讨论的分区。
                     </p><pre class="oac_no_warn" dir="ltr">用于SELECT的EXPLAIN PLAN p.ad_textdocs_ntab FROM print_media_part p;解释。PLAN_TABLE_OUTPUT ------------------------------------------------- ----------------------计划哈希值：2207588228 ----------------------- ------------------------------------------------ | Id |操作|名称| Pstart时| Pstop | -------------------------------------------------- --------------------- | 0 |选择声明| | | | | 1 | PARTITION REFERENCE SINGLE | | KEY | KEY | | 2 |表访问完全| TEXTDOC_NT | KEY | KEY | | 3 | PARTITION RANGE ALL | | 1 | 2 | | 4 |表访问完全| PRINT_MEDIA_PART | 1 | 2 | -------------------------------------------------- ---------------------注意-----  - 用于此声明的动态采样</pre><div class="infoboxnotealso" id="GUID-88E16CEE-3CB1-4AD6-82B3-62B86B899A01__GUID-18FE7D6A-6F8E-49DF-9FAA-BB4056D477A9">
                        <p class="notep1">也可以看看：</p>
                        <p><a href="partition-create-tables-indexes.html#GUID-7F8EBE79-9FF2-4B2D-9764-C11263FA550F" title="Partitioning when using XMLType or object tables and columns follows the basic rules for partitioning.">在XMLType和Objects中</a>对<a href="partition-create-tables-indexes.html#GUID-7F8EBE79-9FF2-4B2D-9764-C11263FA550F" title="使用XMLType或对象表和列时的分区遵循分区的基本规则。">集合进行分区，以</a>获取<code class="codeph">EXPLAIN</code> <code class="codeph">PLAN</code>所基于的<code class="codeph">CREATE</code> <code class="codeph">TABLE</code>语句的示例</p>
                     </div>
                  </div>
               </div>
            </div>
         </div>
      </article>
   </body>
</html>