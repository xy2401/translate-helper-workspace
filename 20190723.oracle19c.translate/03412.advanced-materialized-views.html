<html lang="en-us" dir="ltr" xml:lang="en-us">
   <head>
      <meta http-equiv="Content-Type" content="text/html; charset=utf-8"></meta>
      <meta name="viewport" content="width=device-width, initial-scale=1"></meta>
      <meta http-equiv="X-UA-Compatible" content="IE=edge"></meta>
      <title>高级物化视图</title>
      <meta property="og:site_name" content="Oracle Help Center"></meta>
      <meta property="og:title" content="Data Warehousing Guide"></meta>
      <meta property="og:description" content=""></meta>
      <link rel="stylesheet" href="/sp_common/book-template/ohc-book-template/css/book.css"></link>
      <link rel="shortcut icon" href="/sp_common/book-template/ohc-common/img/favicon.ico"></link>
      <meta name="application-name" content="Data Warehousing Guide"></meta>
      <meta name="generator" content="DITA Open Toolkit version 1.8.5 (Mode = doc)"></meta>
      <meta name="plugin" content="SP_docbuilder HTML plugin release 18.2.2"></meta>
      <link rel="alternate" href="database-data-warehousing-guide.pdf" title="PDF File" type="application/pdf"></link>
      <meta name="robots" content="all"></meta>
      <link rel="schema.dcterms" href="http://purl.org/dc/terms/"></link>
      <meta name="dcterms.created" content="2019-01-09T00:20:13-08:00"></meta>
      
      <meta name="dcterms.dateCopyrighted" content="2001, 2019"></meta>
      <meta name="dcterms.category" content="database"></meta>
      <meta name="dcterms.identifier" content="E96243-01"></meta>
      
      <meta name="dcterms.product" content="en/database/oracle/oracle-database/19"></meta>
      
      <link rel="prev" href="basic-materialized-views.html" title="Previous" type="text/html"></link>
      <link rel="next" href="refreshing-materialized-views.html" title="Next" type="text/html"></link>
      <script>
        document.write('<style type="text/css">');
        document.write('body > .noscript, body > .noscript ~ * { visibility: hidden; }');
        document.write('</style>');
     </script>
      <script src="/sp_common/book-template/requirejs/require.js" data-main="/sp_common/book-template/ohc-book-template/js/book-config"></script>
      <script>
            if (window.require === undefined) {
                document.write('<script data-main="sp_common/book-template/ohc-book-template/js/book-config" src="sp_common/book-template/requirejs/require.js"><\/script>');
                document.write('<link href="sp_common/book-template/ohc-book-template/css/book.css" rel="stylesheet"/>');
            }
        </script>
      <script type="application/json" id="ssot-metadata">{"primary":{"category":{"short_name":"database","element_name":"Database","display_in_url":true},"suite":{"short_name":"oracle","element_name":"Oracle","display_in_url":true},"product_group":{"short_name":"not-applicable","element_name":"Not applicable","display_in_url":false},"product":{"short_name":"oracle-database","element_name":"Oracle Database","display_in_url":true},"release":{"short_name":"19","element_name":"Release 19","display_in_url":true}}}</script>
      
    <meta name="dcterms.title" content="Database Data Warehousing Guide"></meta>
    <meta name="dcterms.isVersionOf" content="DWHSG"></meta>
    <meta name="dcterms.release" content="Release 19"></meta>
  </head>
   <body dir="ltr">
      <div class="noscript alert alert-danger text-center" role="alert">
         <a href="basic-materialized-views.html" class="pull-left"><span class="glyphicon glyphicon-chevron-left" aria-hidden="true"></span>上一页</a> <a href="refreshing-materialized-views.html" class="pull-right">下一页<span class="glyphicon glyphicon-chevron-right" aria-hidden="true"></span></a> <span class="fa fa-exclamation-triangle" aria-hidden="true"></span>必须启用JavaScript才能正确显示此内容</div>
      <article>
         <header>
            <ol class="breadcrumb" vocab="http://schema.org/" typeof="BreadcrumbList">
               <li property="itemListElement" typeof="ListItem"><a href="index.html" property="item" typeof="WebPage"><span property="name">数据仓库指南</span></a></li>
               <li property="itemListElement" typeof="ListItem"><a href="part-optimizing-dw.html" property="item" typeof="WebPage"><span property="name">优化数据仓库</span></a></li>
               <li class="active" property="itemListElement" typeof="ListItem">高级物化视图</li>
            </ol>
            <a id="GUID-F7394DFE-7CF6-401C-A312-C36603BEB01B" name="GUID-F7394DFE-7CF6-401C-A312-C36603BEB01B"></a>
            
            <h2 id="DWHSG-GUID-F7394DFE-7CF6-401C-A312-C36603BEB01B" class="sect2"><span class="enumeration_chapter">6个</span>高级物化视图</h2>
         </header>
         <div class="ind">
            <div>
               <p>本章讨论使用实例化视图的高级主题。它包含以下主题：</p>
               <ul style="list-style-type:disc">
                  <li>
                     <p><a href="advanced-materialized-views.html#GUID-43FA865F-8C02-4B99-9202-49728BAA7687">关于分区和物化视图</a></p>
                  </li>
                  <li>
                     <p><a href="advanced-materialized-views.html#GUID-32823C98-D6FF-4F78-AE90-A98453C29A2A" title="不支持在分析视图或层次结构的查询上创建物化视图。">关于分析处理环境中的物化视图</a></p>
                  </li>
                  <li>
                     <p><a href="advanced-materialized-views.html#GUID-720A1289-A6A6-4A61-A185-FEC70D0F1E3A">关于物化视图和模型</a></p>
                  </li>
                  <li>
                     <p><a href="advanced-materialized-views.html#GUID-BC3675D3-C925-4D72-B953-34E7C818EB91">关于物化视图的安全问题</a></p>
                  </li>
                  <li>
                     <p><a href="advanced-materialized-views.html#GUID-EFE28ABF-C044-426F-93B8-C0009F591DBF">使实体化视图无效</a></p>
                  </li>
                  <li>
                     <p><a href="advanced-materialized-views.html#GUID-D4412AFE-C4BC-4287-A9BB-104AD5E9678E">改变物化视图</a></p>
                  </li>
                  <li>
                     <p><a href="advanced-materialized-views.html#GUID-0702359B-D379-4299-86C4-2958BCD4381D" title="即使物化视图标记为陈旧，实时物化视图也会为用户查询提供新数据。">使用实时物化视图</a></p>
                  </li>
               </ul>
            </div><a id="DWHSG8227"></a><div class="props_rev_3"><a id="GUID-43FA865F-8C02-4B99-9202-49728BAA7687" name="GUID-43FA865F-8C02-4B99-9202-49728BAA7687"></a><h3 id="DWHSG-GUID-43FA865F-8C02-4B99-9202-49728BAA7687" class="sect3"><span class="enumeration_section">6.1</span>关于分区和物化视图</h3>
               <div>
                  <p><a id="d25854e81" class="indexterm-anchor"></a><a id="d25854e85" class="indexterm-anchor"></a>由于数据仓库中保存的数据量很大，因此在设计数据库时，分区是一个非常有用的选项。对事实表进行分区可以提高可伸缩性，简化系统管理，并且可以定义可以高效重建的本地索引。对事实表进行分区还可以提高快速刷新物化视图的机会，因为这可以在物化视图上启用分区更改跟踪（PCT）刷新。对物化视图进行分区也有利于刷新，因为刷新过程可以在更多场景中使用并行DML，而基于PCT的刷新可以使用截断分区来有效地维护物化视图。
                  </p>
                  <div class="infoboxnotealso" id="GUID-43FA865F-8C02-4B99-9202-49728BAA7687__GUID-C0A88051-183F-4068-9B28-5A058CE6B1FD">
                     <p class="notep1">也可以看看：</p>
                     <p>有关分区的更多详细信息，请参见<a href="../vldbg/partition-concepts.html#VLDBG002" target="_blank"><span><cite>“Oracle数据库VLDB和分区指南”</cite></span></a></p>
                  </div>
                  <p>本节包含以下主题：</p>
                  <ul style="list-style-type:disc">
                     <li>
                        <p><a href="advanced-materialized-views.html#GUID-CE717BD7-15B7-4C8B-A172-6C50F5A802E1">关于分区更改跟踪</a></p>
                     </li>
                     <li>
                        <p><a href="advanced-materialized-views.html#GUID-0661E251-15FA-4845-A358-7209D9B22096">对物化视图进行分区</a></p>
                     </li>
                     <li>
                        <p><a href="advanced-materialized-views.html#GUID-B609252D-DD65-4617-8F38-B1AB52473AA5">对预构建表进行分区</a></p>
                     </li>
                     <li>
                        <p><a href="advanced-materialized-views.html#GUID-5AC25C22-427B-45B8-B949-B05AC8853310">滚动物化视图</a></p>
                     </li>
                  </ul>
               </div><a id="DWHSG00324"></a><div class="props_rev_3"><a id="GUID-CE717BD7-15B7-4C8B-A172-6C50F5A802E1" name="GUID-CE717BD7-15B7-4C8B-A172-6C50F5A802E1"></a><h4 id="DWHSG-GUID-CE717BD7-15B7-4C8B-A172-6C50F5A802E1" class="sect4"><span class="enumeration_section">6.1.1</span>关于分区更改跟踪</h4>
                  <div>
                     <p>它是<a id="d25854e143" class="indexterm-anchor"></a><a id="d25854e145" class="indexterm-anchor"></a>与整个物化视图相比，追踪新鲜到更细粒度的可能性和有利性。您可以通过<a href="glossary.html#GUID-32BF9E11-2C90-446A-9C66-4D0BA8DF7798"><span class="xrefglossterm">分区更改跟踪（PCT）</span></a>来实现此目的，这是一种识别物化视图中哪些行受特定详细信息表分区影响的方法。当一个或多个细节表被分区时，可以识别物化视图中对应于修改的细节分区的特定行;当修改分区而所有其他行保持新鲜时，这些行变得陈旧。
                     </p>
                     <p>您可以使用PCT来标识哪些物化视图行对应于特定分区。PCT还用于支持对详细信息表进行分区维护操作后的快速刷新。例如，如果截断或删除详细信息表分区，则会标识并删除实例化视图中受影响的行。</p>
                     <p>识别哪些物化视图行是新的或陈旧的，而不是将整个物化视图视为过时，允许查询重写使用<code class="codeph">QUERY_REWRITE_INTEGRITY</code> = <code class="codeph">ENFORCED</code>或<code class="codeph">TRUSTED</code>模式下新鲜的行。多个视图（例如<code class="codeph">DBA_MVIEW_DETAIL_PARTITION</code> ）详细说明了哪些分区过时或新鲜。如果通过物化视图中存在的连接相关表达式启用已更改表上的分区更改跟踪，则Oracle不会重写部分过时的物化视图。
                     </p>
                     <div class="infoboxnotealso" id="GUID-CE717BD7-15B7-4C8B-A172-6C50F5A802E1__GUID-C6E771CD-21C4-42DC-871F-C18680BECA1D">
                        <p class="notep1">也可以看看：</p>
                        <p><span class="q">“ <a href="advanced-materialized-views.html#GUID-F719C3F9-E3D7-4D29-8AC8-E7B0127A0697">关于加入依赖表达式和分区更改跟踪</a> ”</span>以获取更多信息</p>
                     </div>
                     <p>请注意，虽然分区更改跟踪跟踪分区和子分区级别（对于复合分区表）的过时性，但PCT刷新的粒度级别仅是顶级分区策略。因此，对复合分区表的一个子分区中的数据进行的任何更改都只会将受影响的单个子分区标记为过时，并且该表的其余部分可用于重写，但PCT刷新将刷新包含受影响的整个分区。子分区。</p>
                     <p>为了支持PCT，物化视图必须满足以下要求：</p>
                     <ul style="list-style-type:disc">
                        <li>
                           <p>必须对物化视图引用的至少一个详细信息表进行分区。</p>
                        </li>
                        <li>
                           <p>分区表必须使用范围，列表或带范围或列表的复合分区作为顶级分区策略。</p>
                        </li>
                        <li>
                           <p>顶级分区键必须只包含一列。</p>
                        </li>
                        <li>
                           <p>物化视图必须包含分区键列或分区标记或详细信息表的<code class="codeph">ROWID</code>或连接依赖表达式。
                           </p>
                        </li>
                        <li>
                           <p>如果使用<code class="codeph">GROUP</code> <code class="codeph">BY</code>子句，分区键列或分区标记或<code class="codeph">ROWID</code>或参加相关的表达式必须出现在<code class="codeph">GROUP</code> <code class="codeph">BY</code>子句。
                           </p>
                        </li>
                        <li>
                           <p>如果使用分析窗口函数或<code class="codeph">MODEL</code>子句，则分区键列或分区标记或<code class="codeph">ROWID</code>或连接依赖表达式必须存在于其各自的<code class="codeph">PARTITION</code> <code class="codeph">BY</code>子句中。
                           </p>
                        </li>
                        <li>
                           <p>数据修改只能在分区表上进行。如果对物化视图中具有连接依赖表达式的表执行PCT刷新，则不应在任何连接相关表中进行数据修改。</p>
                        </li>
                        <li>
                           <p><code class="codeph">COMPATIBILITY</code>初始化参数必须至少为9.0.0.0.0。
                           </p>
                        </li>
                     </ul>
                     <p>引用视图，远程表或外连接的物化视图不支持PCT。</p>
                     <div class="infoboxnotealso" id="GUID-CE717BD7-15B7-4C8B-A172-6C50F5A802E1__GUID-13A32E69-2B80-4385-A3E8-F5B10B9991C0">
                        <p class="notep1">也可以看看：</p>
                        <p>有关<code class="codeph">DBMS_MVIEW.PMARKER</code>函数和分区标记的详细信息，请<code class="codeph">DBMS_MVIEW.PMARKER</code> <a href="../arpls/DBMS_MVIEW.html#ARPLS027" target="_blank"><span><cite>Oracle Database PL / SQL包和类型参考</cite></span></a></p>
                     </div>
                     <p>本节包含以下主题：</p>
                     <ul style="list-style-type:disc">
                        <li>
                           <p><a href="advanced-materialized-views.html#GUID-BDF063E9-7769-4272-A54E-C5E199476C46">关于分区键和分区更改跟踪</a></p>
                        </li>
                        <li>
                           <p><a href="advanced-materialized-views.html#GUID-F719C3F9-E3D7-4D29-8AC8-E7B0127A0697">关于加入依赖表达式和分区更改跟踪</a></p>
                        </li>
                        <li>
                           <p><a href="advanced-materialized-views.html#GUID-6E6A5E4F-B8FE-4547-AE5A-DECFE04ABB79">关于分区标记和分区更改跟踪</a></p>
                        </li>
                        <li>
                           <p><a href="advanced-materialized-views.html#GUID-462D637E-27E2-4581-BD50-6CA79A854000">关于分区更改跟踪中的部分重写</a></p>
                        </li>
                     </ul>
                  </div><a id="DWHSG8229"></a><a id="DWHSG8228"></a><div class="props_rev_3"><a id="GUID-BDF063E9-7769-4272-A54E-C5E199476C46" name="GUID-BDF063E9-7769-4272-A54E-C5E199476C46"></a><h5 id="DWHSG-GUID-BDF063E9-7769-4272-A54E-C5E199476C46" class="sect5"><span class="enumeration_section">6.1.1.1</span>关于分区键和分区更改跟踪</h5>
                     <div>
                        <p>分区更改跟踪需要物化视图中的足够信息，以便能够将源分区详细信息表中的详细信息行与相应的物化视图行相关联。这可以通过在<code class="codeph">SELECT</code>列表中包含详细信息表分区键列来实现，如果使用<code class="codeph">GROUP</code> <code class="codeph">BY</code>则可以在<code class="codeph">GROUP</code> <code class="codeph">BY</code>列表中包含。
                        </p>
                        <p>考虑存储每日客户销售的物化视图的示例。以下示例使用<code class="codeph">sh</code>示例模式和三个详细信息表<code class="codeph">sales</code> ， <code class="codeph">products</code>和<code class="codeph">times</code>来创建实例化视图。 <code class="codeph">sales</code>表由<code class="codeph">time_id</code>列分区， <code class="codeph">products</code>由<code class="codeph">prod_id</code>列分区。 <code class="codeph">times</code>不是分区表。
                        </p>
                        <div class="example" id="GUID-BDF063E9-7769-4272-A54E-C5E199476C46__GUID-57C843AC-0CA8-4C49-92D3-5B9D7964F9ED">
                           <p class="titleinexample">示例6-1带分区键的物化视图</p><pre class="oac_no_warn" dir="ltr">使用ROWID创建物料化视图日志（prod_id，time_id，quantity_sold，amount_sold）包括新值;使用ROWID创建物料化视图日志（prod_id，prod_name，prod_desc）包括新值;使用ROWID（time_id，calendar_month_name，calendar_year）创建物料化视图日志，包括新值; CREATE MATERIALIZED VIEW cust_dly_sales_mv建立快速刷新需求快速启动作为选择的QUERY REWRITE s.time_id，p.prod_id，p.prod_name，COUNT（*），SUM（s.quantity_sold），SUM（s.amount_sold），COUNT（s。 quantity_sold），COUNT（s.amount_sold）FROM sales s，products p，times t WHERE s.time_id = t.time_id AND s.prod_id = p.prod_id GROUP BY s.time_id，p.prod_id，p.prod_name;</pre><p>对于<code class="codeph">cust_dly_sales_mv</code> ，在<code class="codeph">sales</code>表上启用了PCT，因为分区键列<code class="codeph">time_id</code>位于物化视图中。
                           </p>
                        </div>
                        <!-- class="example" -->
                     </div>
                  </div><a id="DWHSG8231"></a><a id="DWHSG8230"></a><div class="props_rev_3"><a id="GUID-F719C3F9-E3D7-4D29-8AC8-E7B0127A0697" name="GUID-F719C3F9-E3D7-4D29-8AC8-E7B0127A0697"></a><h5 id="DWHSG-GUID-F719C3F9-E3D7-4D29-8AC8-E7B0127A0697" class="sect5"><span class="enumeration_section">6.1.1.2</span>关于连接依赖表达式和分区更改跟踪</h5>
                     <div>
                        <p>由直接或间接通过等值连接到分区键上的分区详细信息表的表的列组成的表达式称为连接依赖表达式，该表达式是连接键的维度属性或维度分层父级。详细信息表路径中的表集称为连接依赖表。考虑以下：</p><pre class="oac_no_warn" dir="ltr">SELECT s.time_id，t.calendar_month_name FROM sales s，times t WHERE s.time_id = t.time_id;</pre><p>在此查询中， <code class="codeph">times</code>表是一个连接依赖表，因为它连接到分区键列<code class="codeph">time_id</code>上的<code class="codeph">sales</code>表。此外， <code class="codeph">calendar_month_name</code>是<code class="codeph">times.time_id</code>的维度层次结构属性，因为<code class="codeph">calendar_month_name</code>是<code class="codeph">times.mon_id</code>的属性， <code class="codeph">times.mon_id</code>是<code class="codeph">times.mon_id</code>的维度层次结构父<code class="codeph">times.time_id</code> 。因此，表达<code class="codeph">calendar_month_name</code>从<code class="codeph">times</code>表是一个连接依赖性表达。让我们考虑另一个例子：</p><pre class="oac_no_warn" dir="ltr">SELECT s.time_id，y.calendar_year_name FROM sales s，times_d d，times_m m，times_y y WHERE s.time_id = d.time_id AND d.day_id = m.day_id AND m.mon_id = y.mon_id;</pre><p>在这里， <code class="codeph">times</code>表规格化到<code class="codeph">times_d</code> ， <code class="codeph">times_m</code>和<code class="codeph">times_y</code>表。<code class="codeph">times_y</code>表中的表达式<code class="codeph">calendar_year_name</code>是一个依赖于连接的表达式，表<code class="codeph">times_d</code> ， <code class="codeph">times_m</code>和<code class="codeph">times_y</code>是依赖于连接的表。这是因为<code class="codeph">times_y</code>表通过<code class="codeph">times_m</code>和<code class="codeph">times_d</code>表间接连接到其分区键列<code class="codeph">time_id</code>上的sales表。
                        </p>
                        <p>这使用户可以创建包含聚合的实体化视图，这些聚合在某个级别上高于详细信息表的分区键。请考虑以下存储每月客户销售额的物化视图示例。</p>
                        <div class="example" id="GUID-F719C3F9-E3D7-4D29-8AC8-E7B0127A0697__GUID-88E6DF64-A0B7-4343-BF7A-CEAADF171F4A">
                           <p class="titleinexample">示例6-2创建物化视图：加入依赖表达式</p>
                           <p>假设存在先前定义的物化视图日志，可以使用以下DDL创建物化视图：</p><pre class="oac_no_warn" dir="ltr">CREATE MATERIALIZED VIEW cust_mth_sales_mv根据需求建立推荐的刷新快速启用QUERY REWRITE作为选择t.calendar_month_name，p.prod_id，p.prod_name，COUNT（*），SUM（s.quantity_sold），SUM（s.amount_sold），COUNT（s。 quantity_sold），COUNT（s.amount_sold）FROM sales s，products p，times t WHERE s.time_id = t.time_id AND s.prod_id = p.prod_id GROUP BY t.calendar_month_name，p.prod_id，p.prod_name;</pre><p>在这里，您可以使用连接相关表<code class="codeph">times</code>和<code class="codeph">times.calendar_month_name</code>是由<code class="codeph">times.time_id</code>确定的维度属性的关系将详细信息表行与其对应的物化视图行相关<code class="codeph">times.time_id</code> 。这样可以在<code class="codeph">sales</code>表上启用分区更改跟踪。除此之外， <code class="codeph">prod_id</code>在物化视图中存在分区键列<code class="codeph">prod_id</code> ，因此在产品表上启用了PCT。
                           </p>
                        </div>
                        <!-- class="example" -->
                     </div>
                  </div><a id="DWHSG8233"></a><a id="DWHSG8232"></a><div class="props_rev_3"><a id="GUID-6E6A5E4F-B8FE-4547-AE5A-DECFE04ABB79" name="GUID-6E6A5E4F-B8FE-4547-AE5A-DECFE04ABB79"></a><h5 id="DWHSG-GUID-6E6A5E4F-B8FE-4547-AE5A-DECFE04ABB79" class="sect5"><span class="enumeration_section">6.1.1.3</span>关于分区标记和分区更改跟踪</h5>
                     <div>
                        <p><code class="codeph">DBMS_MVIEW.PMARKER</code>函数旨在显着降低物化视图的基数（不同值与表行数的比率）（例子见<a href="advanced-materialized-views.html#GUID-6E6A5E4F-B8FE-4547-AE5A-DECFE04ABB79__i1009199">示例6-3</a> ）。该函数返回一个分区标识符，该标识符唯一标识指定分区表中指定行的分区或子分区。因此，使用<code class="codeph">DBMS_MVIEW.PMARKER</code>函数而不是<code class="codeph">SELECT</code>和<code class="codeph">GROUP</code> <code class="codeph">BY</code>子句中的分区键列。
                        </p>
                        <p>与物化视图中PL / SQL函数的一般情况不同，即使重写模式为<code class="codeph">QUERY_REWRITE_INTEGRITY = ENFORCED</code> ，使用<code class="codeph">DBMS_MVIEW.PMARKER</code>也不会阻止使用该物化视图进行重写。</p>
                        <p>作为使用<code class="codeph">PMARKER</code>功能的示例，请考虑计算典型数字，例如在给定年份内产品类别产生的收入。如果每月销售1000种不同的产品，则在物化视图中将产生12,000行。
                        </p>
                        <div class="example" id="GUID-6E6A5E4F-B8FE-4547-AE5A-DECFE04ABB79__i1009199">
                           <p class="titleinexample">示例6-3在物化视图中使用分区标记</p>
                           <p>考虑存储每个产品类别的年销售收入的物化视图的示例。在每个产品类别中有大约数百种不同的产品，包括物化视图中<code class="codeph">products</code>表的分区键列<code class="codeph">prod_id</code>将大大增加基数。相反，此物化视图使用<code class="codeph">DBMS_MVIEW.PMARKER</code>函数，该函数将物化视图的基数增加了<code class="codeph">products</code>表中分区数量的因子。
                           </p><pre class="oac_no_warn" dir="ltr">CREATE MATERIALIZED VIEW prod_yr_sales_mv建立需求快速刷新需要启动REERY REWRITE作为选择DBMS_MVIEW.PMARKER（p.rowid），p.prod_category，t.calendar_year，COUNT（*），SUM（s.amount_sold），SUM（s.quantity_sold） ，COUNT（s.amount_sold），COUNT（s.quantity_sold）FROM sales s，products p，times t WHERE s.time_id = t.time_id AND s.prod_id = p.prod_id GROUP BY DBMS_MVIEW.PMARKER（p.rowid）， p.prod_category，t.calendar_year;</pre><p><code class="codeph">prod_yr_sales_mv</code>在其<code class="codeph">SELECT</code>列表中的<code class="codeph">products</code>表上包含<code class="codeph">DBMS_MVIEW.PMARKER</code>函数。这使得对<code class="codeph">products</code>表的分区更改跟踪的基数影响明显小于分区键列<code class="codeph">prod_id</code> 。在此示例中， <code class="codeph">prod_yr_sales_mv</code>的所需聚合<code class="codeph">prod_yr_sales_mv</code>是按<code class="codeph">products.prod_category</code>分组。使用<code class="codeph">DBMS_MVIEW.PMARKER</code>函数，物化视图基数仅增加了<code class="codeph">products</code>表中分区数量的因子。这通常会明显小于包含分区键列的基数影响。
                           </p>
                           <p>请注意，由于<code class="codeph">SELECT</code>列表中存在与连接相关的表达式<code class="codeph">calendar_year</code> ，因此在<code class="codeph">sales</code>表上启用了分区更改跟踪。
                           </p>
                        </div>
                        <!-- class="example" -->
                     </div>
                  </div><a id="DWHSG8234"></a><div class="props_rev_3"><a id="GUID-462D637E-27E2-4581-BD50-6CA79A854000" name="GUID-462D637E-27E2-4581-BD50-6CA79A854000"></a><h5 id="DWHSG-GUID-462D637E-27E2-4581-BD50-6CA79A854000" class="sect5"><span class="enumeration_section">6.1.1.4</span>关于分区变更跟踪中的部分重写</h5>
                     <div>
                        <p>随后的<code class="codeph">INSERT</code>语句将新行添加到表<code class="codeph">sales</code>的<code class="codeph">sales_part3</code>分区。此时，由于<code class="codeph">cust_dly_sales_mv</code>使用分区键在表<code class="codeph">sales</code>具有PCT可用，因此Oracle可以在物化视图<code class="codeph">cust_dly_sales_mv</code>与<code class="codeph">sales_part3</code>分区对应的过时行（其他行在其新鲜状态中保持不变）。查询重写无法识别物化视图<code class="codeph">cust_mth_sales_mv</code>和<code class="codeph">prod_yr_sales_mv</code>的新部分，因为PCT可使用连接相关表达式在表销售中使用。仅当使用分区键或分区标记在详细信息表上提供PCT时，查询重写才能确定详细信息表更改的物化视图的新部分。
                        </p>
                     </div>
                  </div>
               </div><a id="DWHSG8235"></a><div class="props_rev_3"><a id="GUID-0661E251-15FA-4845-A358-7209D9B22096" name="GUID-0661E251-15FA-4845-A358-7209D9B22096"></a><h4 id="DWHSG-GUID-0661E251-15FA-4845-A358-7209D9B22096" class="sect4"><span class="enumeration_section">6.1.2</span>对物化视图进行分区</h4>
                  <div>
                     <div class="section">
                        <p>对物化视图进行分区涉及使用标准Oracle分区子句定义物化视图，如以下示例所示。此语句创建一个名为<code class="codeph">part_sales_mv</code>的物化视图，该视图使用三个分区，可以快速刷新，并且有资格进行查询重写：</p><pre class="oac_no_warn" dir="ltr">创建实质性视图part_sales_mv按范围划分的并行分区（time_id）（PARTITION month1 VALUE少于（7月-12-1998'，'DD-MM-YYYY'））PCTFREE 0存储（初始8M）TABLESPACE sf1，PARTITION month2 VALUES不到（截止日期（'31 -12-1999'，'DD-MM-YYYY'））PCT免费0存储（初始8M）表格sf2，分区月3价值低于（7月12日（'31 -12-2000'，'DD） -MM-YYYY'））PCTFREE 0存储（初始8M）表格sf3）构建推荐的刷新快速启用QUERY REWRITE作为SELECT s.cust_id，s.time_id，SUM（s.amount_sold）AS sum_dol_sales，SUM（s.quantity_sold）AS sum_unit_sales FROM sales s GROUP BY s.time_id，s.cust_id;</pre></div>
                     <!-- class="section" -->
                  </div>
               </div><a id="DWHSG8236"></a><div class="props_rev_3"><a id="GUID-B609252D-DD65-4617-8F38-B1AB52473AA5" name="GUID-B609252D-DD65-4617-8F38-B1AB52473AA5"></a><h4 id="DWHSG-GUID-B609252D-DD65-4617-8F38-B1AB52473AA5" class="sect4"><span class="enumeration_section">6.1.3</span>对预构建表进行分区</h4>
                  <div>
                     <div class="section">
                        <p><a id="d25854e709" class="indexterm-anchor"></a>或者，可以将物化视图注册到分区的预构建表。 <span class="q">“ <a href="advanced-materialized-views.html#GUID-1D0C81F8-6F6D-4E41-BEBC-A0F6B205A3AA">对物化视图</a></span>进行分区的好处<span class="q">”</span>描述了对预构建表进行分区的好处。以下示例说明了这一点：</p><pre class="oac_no_warn" dir="ltr">CREATE TABLE part_sales_tab_mv（time_id，cust_id，sum_dollar_sales，sum_unit_sale）PARALLEL PARTITION BY RANGE（time_id）（PARTITION month1 VALUE少于（TO_DATE（'31 -12-1998'，'DD-MM-YYYY'））PCTFREE 0 STORAGE（INITIAL） 8M）TABLESPACE sf1，PARTITION month2 VALUE少于（7月12日（'31 -12-1999'，'DD-MM-YYYY'））PCTFREE 0存储（初始8M）TABLESPACE sf2，分区第3个月值（不到（*） -12-2000'，'DD-MM-YYYY'））PCTFREE 0 STORAGE（INITIAL 8M）TABLESPACE sf3）AS SELECT s.time_id，s.cust_id，SUM（s.amount_sold）AS sum_dollar_sales，SUM（s.quantity_sold） AS sum_unit_sales FROM sales s GROUP BY s.time_id，s.cust_id; CREATE MATERIALIZED VIEW part_sales_tab_mv ON PREBUILT TABLE ENABLE QUERY REWRITE as SELECT s.time_id，s.cust_id，SUM（s.amount_sold）AS sum_dollar_sales，SUM（s.quantity_sold）AS sum_unit_sales FROM sales s GROUP BY s.time_id，s.cust_id;</pre><p>在此示例中，表<code class="codeph">part_sales_tab_mv</code>已分区超过三个月，然后注册实例化视图以使用预构建表。此物化视图符合查询重写的条件，因为已包含<code class="codeph">ENABLE</code> <code class="codeph">QUERY</code> <code class="codeph">REWRITE</code>子句。
                        </p>
                     </div>
                     <!-- class="section" -->
                  </div><a id="DWHSG8237"></a><div class="props_rev_3"><a id="GUID-1D0C81F8-6F6D-4E41-BEBC-A0F6B205A3AA" name="GUID-1D0C81F8-6F6D-4E41-BEBC-A0F6B205A3AA"></a><h5 id="DWHSG-GUID-1D0C81F8-6F6D-4E41-BEBC-A0F6B205A3AA" class="sect5"><span class="enumeration_section">6.1.3.1</span>对物化视图进行分区的好处</h5>
                     <div>
                        <p>当物化视图在细分表的分区键列或连接依赖表达式上进行分区时，使用<code class="codeph">TRUNCATE</code> <code class="codeph">PARTITION</code>语句在刷新期间删除物化视图的一个或多个分区，然后使用新数据重新填充分区更有效。除了<span class="q">“ <a href="advanced-materialized-views.html#GUID-CE717BD7-15B7-4C8B-A172-6C50F5A802E1">关于分区更改跟踪</a> ”中</span>描述的其他条件之外，如果满足以下条件，Oracle数据库将使用此快速刷新（称为PCT刷新）并带有分区截断。
                        </p>
                        <ul style="list-style-type:disc">
                           <li>
                              <p>物化视图在细分表的分区键列或连接相关表达式上进行分区。</p>
                           </li>
                           <li>
                              <p>如果使用分区键列或连接表达式启用PCT，则物化视图应为范围或列表分区。</p>
                           </li>
                           <li>
                              <p>PCT更新是非原子的。</p>
                           </li>
                        </ul>
                     </div>
                  </div>
               </div><a id="DWHSG8238"></a><div class="props_rev_3"><a id="GUID-5AC25C22-427B-45B8-B949-B05AC8853310" name="GUID-5AC25C22-427B-45B8-B949-B05AC8853310"></a><h4 id="DWHSG-GUID-5AC25C22-427B-45B8-B949-B05AC8853310" class="sect4"><span class="enumeration_section">6.1.4</span>滚动物化视图</h4>
                  <div>
                     <p>当数据仓库或数据集市包含时间维度时，通常需要归档最旧的信息，然后重新使用存储来获取新信息。这称为滚动窗口场景。如果事实表或物化视图包含时间维度并且由时间属性水平分区，则滚动物化视图的管理可以简化为一些快速分区维护操作，前提是推出的数据单位等于或等于与范围分区最不一致的。</p>
                     <p>如果您计划在数据仓库中使用滚动的物化视图，则应确定计划执行分区维护操作的频率，并且应该计划对事实表和物化视图进行分区，以减少旧数据所需的系统管理开销量。老了。另外一个考虑因素是您可能希望在不经常更新的分区上使用数据压缩。</p>
                     <p>您不限于使用范围分区。例如，使用时间值和键值的复合分区可以为您的数据提供良好的分区解决方案。</p>
                     <div class="infoboxnotealso" id="GUID-5AC25C22-427B-45B8-B949-B05AC8853310__GUID-8BAE7F52-08F0-4A6B-A4A1-864208143D3D">
                        <p class="notep1">也可以看看：</p>
                        <p><a href="refreshing-materialized-views.html#GUID-64068234-BDB0-4C12-AE70-75571046A586" title="每次在任何物化视图的基表上执行DML操作时，都会自动刷新使用ON STATEMENT刷新模式的物化视图。Oracle数据库对使用近似查询定义的物化视图执行快速刷新。在使用DBMS_REDEFINITION包在线重新定义表时，可以执行依赖于正在重新定义的表的快速可刷新实体化视图的增量刷新。您可以使用完整，快速或PCT刷新方法刷新基于混合分区表的实例化视图。">刷新物化视图</a>以获取有关<code class="codeph">CONSIDER</code> <code class="codeph">FRESH</code>更多详细信息以及有关压缩的详细信息</p>
                     </div>
                  </div>
               </div>
            </div><a id="DWHSG8239"></a><div class="props_rev_3"><a id="GUID-32823C98-D6FF-4F78-AE90-A98453C29A2A" name="GUID-32823C98-D6FF-4F78-AE90-A98453C29A2A"></a><h3 id="DWHSG-GUID-32823C98-D6FF-4F78-AE90-A98453C29A2A" class="sect3"><span class="enumeration_section">6.2</span>关于分析处理环境中的物化视图</h3>
               <div>
                  <p>本节讨论分析SQL使用的概念以及关系数据库如何处理这些类型的查询。它还说明了使用常见方案创建物化视图的最佳方法。</p>
                  <p>以下主题包含有关不同环境中的实例化视图的其他信息：</p>
                  <ul style="list-style-type:disc">
                     <li>
                        <p><a href="advanced-materialized-views.html#GUID-97D76353-0B1A-4685-868E-CAC915FDE194" title="不支持在分析视图或层次结构的查询上创建物化视图。">关于物化视图和分析视图</a></p>
                     </li>
                     <li>
                        <p><a href="advanced-materialized-views.html#GUID-0EF20810-E53B-4A81-82BE-61A0FB90086A">关于物化视图和分层多维数据集</a></p>
                     </li>
                     <li>
                        <p><a href="advanced-materialized-views.html#GUID-6C3EE0BD-93F7-4285-9062-A43A4F09272D">分区物化视图的好处</a></p>
                     </li>
                     <li>
                        <p><a href="advanced-materialized-views.html#GUID-BB7DF1AE-FECA-4D16-B1E7-F64E3792D444">关于压缩物化视图</a></p>
                     </li>
                     <li>
                        <p><a href="advanced-materialized-views.html#GUID-C2B7DB22-E6E6-471B-8D9F-BDE94157DA39">关于具有集合运算符的物化视图</a></p>
                     </li>
                  </ul>
               </div>
               <div class="sect3"><a id="GUID-97D76353-0B1A-4685-868E-CAC915FDE194" name="GUID-97D76353-0B1A-4685-868E-CAC915FDE194"></a><h4 id="DWHSG-GUID-97D76353-0B1A-4685-868E-CAC915FDE194" class="sect4"><span class="enumeration_section">6.2.1</span>关于物化视图和分析视图</h4>
                  <div>
                     <p>不支持在分析视图或层次结构的查询上创建物化视图。</p>
                  </div>
               </div><a id="DWHSG8241"></a><a id="DWHSG8242"></a><a id="DWHSG8240"></a><div class="props_rev_3"><a id="GUID-0EF20810-E53B-4A81-82BE-61A0FB90086A" name="GUID-0EF20810-E53B-4A81-82BE-61A0FB90086A"></a><h4 id="DWHSG-GUID-0EF20810-E53B-4A81-82BE-61A0FB90086A" class="sect4"><span class="enumeration_section">6.2.2</span>关于物化视图和分层多维数据集</h4>
                  <div>
                     <p>虽然数据仓库环境通常以星型模式的形式查看数据，但对于分析性SQL查询，数据以分层多维数据集的形式保存。分层多维数据集包括沿其每个维度的汇总层次聚合的数据，这些聚合跨维度组合。它包括商业智能查询所需的典型聚合集。</p>
                     <div class="example" id="GUID-0EF20810-E53B-4A81-82BE-61A0FB90086A__GUID-C915B982-A86F-4A53-8A1E-68BB537E1152">
                        <p class="titleinexample">示例6-4分层多维数据集</p>
                        <p>考虑具有两个维度的销售数据集，每个维度都具有四级层次结构：</p>
                        <ul style="list-style-type:disc">
                           <li>
                              <p>时间，包含（所有时间），年，季度和月份。</p>
                           </li>
                           <li>
                              <p>产品，包含（所有产品），部门，品牌和项目。</p>
                           </li>
                        </ul>
                        <p>这意味着分层多维数据集中有16个聚合组。这是因为四个时间级别乘以四个产品级别来生成立方体。<a href="advanced-materialized-views.html#GUID-0EF20810-E53B-4A81-82BE-61A0FB90086A__I1006832" title="此表说明了时间和产品维度的层次结构。">表6-1</a>显示了每个维度的四个级别。
                        </p>
                     </div>
                     <!-- class="example" -->
                     <div class="section">
                        <div class="tblformal" id="GUID-0EF20810-E53B-4A81-82BE-61A0FB90086A__I1006832">
                           <p class="titleintable">表6-1按时间和产品进行的滚动</p>
                           <table cellpadding="4" cellspacing="0" class="Formal" title="ROLLUP按时间和产品" width="100%" border="1" summary="This table illustrates the hierarchies for the Time and Product dimensions." frame="hsides" rules="rows">
                              <thead>
                                 <tr align="left" valign="top">
                                    <th align="left" valign="bottom" width="30%" id="d25854e984">按时间滚动</th>
                                    <th align="left" valign="bottom" width="70%" id="d25854e987">ROLLUP按产品分类</th>
                                 </tr>
                              </thead>
                              <tbody>
                                 <tr align="left" valign="top">
                                    <td align="left" valign="top" width="30%" id="d25854e992" headers="d25854e984 ">
                                       <p>年，季度，月份</p>
                                    </td>
                                    <td align="left" valign="top" width="70%" headers="d25854e992 d25854e987 ">
                                       <p>分裂，品牌，项目</p>
                                    </td>
                                 </tr>
                                 <tr align="left" valign="top">
                                    <td align="left" valign="top" width="30%" id="d25854e999" headers="d25854e984 ">
                                       <p>一年，季度</p>
                                    </td>
                                    <td align="left" valign="top" width="70%" headers="d25854e999 d25854e987 ">
                                       <p>分裂，品牌</p>
                                    </td>
                                 </tr>
                                 <tr align="left" valign="top">
                                    <td align="left" valign="top" width="30%" id="d25854e1006" headers="d25854e984 ">
                                       <p>年</p>
                                    </td>
                                    <td align="left" valign="top" width="70%" headers="d25854e1006 d25854e987 ">
                                       <p>师</p>
                                    </td>
                                 </tr>
                                 <tr align="left" valign="top">
                                    <td align="left" valign="top" width="30%" id="d25854e1013" headers="d25854e984 ">
                                       <p>一直</p>
                                    </td>
                                    <td align="left" valign="top" width="70%" headers="d25854e1013 d25854e987 ">
                                       <p>所有产品</p>
                                    </td>
                                 </tr>
                              </tbody>
                           </table>
                        </div>
                        <!-- class="inftblhruleinformal" -->
                        <p>请注意，随着您增加维度和级别的数量，要计算的组数量会急剧增加。此示例涉及16个组，但如果您要添加两个具有相同级别的维度，则将具有4 x 4 x 4 x 4 = 256个不同的组。另外，如果您的维度中有多个层次结构，请考虑类似的组增加。例如，时间维度可能具有累计到财务季度和财务年度的额外财务月份层次结构。处理群体爆炸一直是在线分析处理系统数据存储的主要挑战。</p>
                        <p>典型的在线分析查询对多维数据集的不同部分进行<a href="glossary.html#GUID-F7CC0204-822C-4C1F-AE7D-A7CC609C05C0"><span class="xrefglossterm">切片和切块</span></a> ，将一个级别的聚合与另一个级别的聚合进行比较。例如，查询可能会找到2002年1月份杂货部门的销售情况，并将它们与2001年全年的杂货部门的总销售额进行比较。
                        </p>
                     </div>
                     <!-- class="section" -->
                  </div>
               </div><a id="DWHSG8243"></a><div class="props_rev_3"><a id="GUID-6C3EE0BD-93F7-4285-9062-A43A4F09272D" name="GUID-6C3EE0BD-93F7-4285-9062-A43A4F09272D"></a><h4 id="DWHSG-GUID-6C3EE0BD-93F7-4285-9062-A43A4F09272D" class="sect4"><span class="enumeration_section">6.2.3</span>对物化视图进行分区的好处</h4>
                  <div>
                     <p>具有多个聚合组的物化视图在适当分区时为刷新和查询重写提供最佳性能。</p>
                     <p>滚动窗口场景中的PCT刷新需要在时间维度的某个级别上进行顶级分区。并且，针对此物化视图重写的查询的分区修剪需要在<code class="codeph">GROUPING_ID</code>列上进行分区。因此，这些物化视图的最有效分区方案是使用复合分区（（ <code class="codeph">time</code> ， <code class="codeph">GROUPING_ID</code> ）列上的范围列表）。通过以这种方式对实例化视图进行分区，您可以启用：</p>
                     <ul style="list-style-type:disc">
                        <li>
                           <p>PCT刷新，从而提高刷新性能。</p>
                        </li>
                        <li>
                           <p>分区修剪：只访问相关的聚合组，从而大大降低了查询处理成本。</p>
                        </li>
                     </ul>
                     <p>如果您不想使用PCT刷新，则可以在<code class="codeph">GROUPING_ID</code>列上按列表进行分区。
                     </p>
                  </div>
               </div><a id="DWHSG8244"></a><div class="props_rev_3"><a id="GUID-BB7DF1AE-FECA-4D16-B1E7-F64E3792D444" name="GUID-BB7DF1AE-FECA-4D16-B1E7-F64E3792D444"></a><h4 id="DWHSG-GUID-BB7DF1AE-FECA-4D16-B1E7-F64E3792D444" class="sect4"><span class="enumeration_section">6.2.4</span>关于压缩物化视图</h4>
                  <div>
                     <p>使用高度冗余数据时应考虑数据压缩，例如具有许多外键的表。特别是，使用<code class="codeph">ROLLUP</code>子句创建的物化视图可能是候选者。
                     </p>
                     <div class="infoboxnotealso" id="GUID-BB7DF1AE-FECA-4D16-B1E7-F64E3792D444__GUID-D26EC127-092A-4EA1-A934-D93A63CA2951">
                        <p class="notep1">也可以看看：</p>
                        <ul style="list-style-type:disc">
                           <li>
                              <p><a href="../sqlrf/ALTER-MATERIALIZED-VIEW.html#SQLRF52876" target="_blank"><span><cite>Oracle数据库SQL语言参考，</cite></span></a>用于数据压缩语法和限制</p>
                           </li>
                           <li>
                              <p>有关压缩的详细信息，请参阅<span class="q">“ <a href="basic-materialized-views.html#GUID-E75B9A93-BEFB-42A7-B9CB-38FA48EBB266">关于物化视图的存储和表压缩</a> ”</span></p>
                           </li>
                        </ul>
                     </div>
                  </div>
               </div><a id="DWHSG8245"></a><div class="props_rev_3"><a id="GUID-C2B7DB22-E6E6-471B-8D9F-BDE94157DA39" name="GUID-C2B7DB22-E6E6-471B-8D9F-BDE94157DA39"></a><h4 id="DWHSG-GUID-C2B7DB22-E6E6-471B-8D9F-BDE94157DA39" class="sect4"><span class="enumeration_section">6.2.5</span>关于具有集合运算符的物化视图</h4>
                  <div>
                     <p>Oracle数据库提供支持<a id="d25854e1136" class="indexterm-anchor"></a><a id="d25854e1140" class="indexterm-anchor"></a>物化视图，其定义查询涉及集合运算符。现在可以为查询重写启用具有集合运算符的物化视图。您可以使用<code class="codeph">ON</code> <code class="codeph">COMMIT</code>或<code class="codeph">ON</code> <code class="codeph">DEMAND</code>刷新刷新物化视图。
                     </p>
                     <p>如果定义查询具有支持快速刷新<code class="codeph">UNION</code> <code class="codeph">ALL</code>在在顶级运营商和每个查询块<code class="codeph">UNION</code> <code class="codeph">ALL</code> ，满足物化视图的要求与骨料或物化视图只联接。此外，物化视图必须包含一个常量列（称为<code class="codeph">UNION</code> <code class="codeph">ALL</code>标记），该列在每个查询块中具有不同的值，在下面的示例中，该列是第<code class="codeph">1 marker</code>列<code class="codeph">1 marker</code>和第<code class="codeph">2 marker</code>列<code class="codeph">2 marker</code> 。
                     </p>
                     <div class="infoboxnotealso" id="GUID-C2B7DB22-E6E6-471B-8D9F-BDE94157DA39__GUID-B5D588FD-4A69-47CE-984B-DAEDF545DA81">
                        <p class="notep1">也可以看看：</p>
                        <p><span class="q">“ <a href="basic-materialized-views.html#GUID-81A544CA-14C4-41B1-ACC1-5FF7960F18A6">在与UNION ALL物化视图快速刷新的限制</a></span>用于与物化视图的快速刷新的详细限制<span class="q">”</span> <code class="codeph">UNION</code> <code class="codeph">ALL</code> 。</p>
                     </div>
                  </div><a id="DWHSG8247"></a><a id="DWHSG8248"></a><a id="DWHSG8246"></a><div class="props_rev_3"><a id="GUID-5A727B3A-ADD4-4EA2-B73F-5AC0789B406E" name="GUID-5A727B3A-ADD4-4EA2-B73F-5AC0789B406E"></a><h5 id="DWHSG-GUID-5A727B3A-ADD4-4EA2-B73F-5AC0789B406E" class="sect5"><span class="enumeration_section">6.2.5.1</span>使用UNION ALL的物化视图示例</h5>
                     <div>
                        <div class="section">
                           <p>以下示例说明了如何创建涉及<code class="codeph">UNION</code> <code class="codeph">ALL</code>的快速可刷新的物化视图。</p>
                        </div>
                        <!-- class="section" -->
                        <div class="example" id="GUID-5A727B3A-ADD4-4EA2-B73F-5AC0789B406E__GUID-0AAA7B44-0790-4B59-98E4-5D47DC0BC6B1">
                           <p class="titleinexample">示例6-5使用具有两个连接视图的UNION ALL的物化视图</p>
                           <p>要创建具有两个连接视图的<code class="codeph">UNION</code> <code class="codeph">ALL</code>化视图，实例化视图日志必须具有rowid列，并且在以下示例中， <code class="codeph">UNION</code> <code class="codeph">ALL</code>标记是列， <code class="codeph">1 marker</code>和<code class="codeph">2 marker</code> 。
                           </p><pre class="oac_no_warn" dir="ltr">使用ROWID创建物料化视图登录销售;使用ROWID创建物料化视图登录客户; CREATE MATERIALIZED VIEW unionall_sales_cust_joins_mv REFRESH FAST ON COMMIT ENABLE QUERY REWRITE AS（选择c.rowid crid，s.rowid srid，c.cust_id，s.amount_sold，1个标记FROM sales s，customers c WHERE s.cust_id = c.cust_id AND c .cust_last_name ='Smith'）UNION ALL（SELECT c.rowid crid，s.rowid srid，c.cust_id，s.amount_sold，2 marker FROM sales s，customers c WHERE s.cust_id = c.cust_id AND c.cust_last_name = '棕色'）;</pre></div>
                        <!-- class="example" -->
                        <div class="example" id="GUID-5A727B3A-ADD4-4EA2-B73F-5AC0789B406E__GUID-CE59DA03-7059-4C7B-A5E4-25C2341C64DC">
                           <p class="titleinexample">示例6-6使用带有连接和聚合的UNION ALL的物化视图</p>
                           <p>以下示例显示了具有连接的物化视图的<code class="codeph">UNION</code> <code class="codeph">ALL</code>和具有聚合的物化视图。在这个例子中可以注意到几件事。可以使用Null或常量来确保相应<code class="codeph">SELECT</code>列列的数据类型匹配。此外， <code class="codeph">UNION</code> <code class="codeph">ALL</code>标记列可以是字符串文字，在以下示例中为<code class="codeph">'Year' umarker</code> ， <code class="codeph">'Quarter' umarker</code>或<code class="codeph">'Daily' umarker</code> ：</p><pre class="oac_no_warn" dir="ltr">使用ROWID，SEQUENCE（amount_sold，time_id）创建物料化视图登录销售包括新值;使用ROWID，SEQUENCE（time_id，fiscal_year，fiscal_quarter_number，day_number_in_week）创建物料化视图日志包括新值; CREATE MATERIALIZED VIEW unionall_sales_mix_mv REFRESH FAST ON DEMAND AS（选择'年'umarker，NULL，NULL，t.fiscal_year，SUM（s.amount_sold）amt，COUNT（s.amount_sold），COUNT（*）FROM sales s，times t WHERE s.time_id = t.time_id GROUP BY t.fiscal_year）UNION ALL（选择'Quarter'umarker，NULL，NULL，t.fiscal_quarter_number，SUM（s.amount_sold）amt，COUNT（s.amount_sold），COUNT（*）FROM sales s，times t WHERE s.time_id = t.time_id and t.fiscal_year = 2001 GROUP BY t.fiscal_quarter_number）UNION ALL（选择'Daily'umarker，s.rowid rid，t.rowid rid2，t.day_number_in_week，s。 amount_sold amt，1,1 FROM sales s，times t WHERE s.time_id = t.time_id AND t.time_id介于'01 -Jan-01'和'01 -Dec-31'）之间;</pre></div>
                        <!-- class="example" -->
                     </div>
                  </div>
               </div>
            </div><a id="DWHSG8249"></a><div class="props_rev_3"><a id="GUID-720A1289-A6A6-4A61-A185-FEC70D0F1E3A" name="GUID-720A1289-A6A6-4A61-A185-FEC70D0F1E3A"></a><h3 id="DWHSG-GUID-720A1289-A6A6-4A61-A185-FEC70D0F1E3A" class="sect3"><span class="enumeration_section">6.3</span>关于物化视图和模型</h3>
               <div>
                  <p>在SQL中提供基于数组的计算的模型可以在物化视图中使用。因为<code class="codeph">MODEL</code>子句计算可能很昂贵，所以您可能希望使用两个单独的物化视图：一个用于模型计算，一个用于<code class="codeph">SELECT</code> ...<code class="codeph">GROUP</code> <code class="codeph">BY</code>查询。例如，您可以创建以下物化视图，而不是使用一个长物化视图：</p><pre class="oac_no_warn" dir="ltr">CREATE MATERIALIZED VIEW my_groupby_mv REFRESH FAST ENABLE QUERY REWRITE AS SELECT country_name country，prod_name prod，calendar_year year，SUM（amount_sold）sale，COUNT（amount_sold）cnt，COUNT（*）cntstr FROM sales，times，customers，countries，products WHERE sales。 time_id = times.time_id AND sales.prod_id = products.prod_id AND sales.cust_id = customers.cust_id AND customers.country_id = countries.country_id GROUP BY country_name，prod_name，calendar_year; CREATE MATERIALIZED VIEW my_model_mv ENABLE QUERY REWRITE AS SELECT country，prod，year，sale，cnt FROM my_groupby_mv MODEL PARTITION BY（country）DIMENSION BY（prod，year）MEASURES（sale s）IGNORE NAV（s ['Shorts'，2000] = 0.2 * AVG（CV（），1996年和1999年之间的年份]，s ['Kids Pajama'，2000] = 0.5 * AVG（s）（CV（），1995年和1999年之间的年份]，s ['男孩Pajama'，2000] = 0.6 * AVG（s）[CV（），1994年和1999年之间的年份]，......&lt;数百个其他更新规则&gt;）;</pre><p>通过使用两个物化视图，您可以增量维护物化视图<code class="codeph">my_groupby_mv</code> 。物化视图<code class="codeph">my_model_mv</code>位于一个小得多的数据集上，因为它建立在<code class="codeph">my_groupby_mv</code> ，可以通过完全刷新来维护。
                  </p>
                  <p>具有模型的物化视图可以仅使用完全刷新或PCT刷新，并且仅可用于部分文本查询重写。</p>
                  <div class="infoboxnotealso" id="GUID-720A1289-A6A6-4A61-A185-FEC70D0F1E3A__GUID-A8CBF5AB-82C5-4793-BF59-F7C8E7C4F82B">
                     <p class="notep1">也可以看看：</p>
                     <p><a href="sql-modeling-data-warehouses.html#GUID-538F78AA-9BF3-46F2-93D1-39A8739B3237">SQL for Modeling</a>有关模型计算的更多详细信息</p>
                  </div>
               </div>
            </div><a id="DWHSG8251"></a><div class="props_rev_3"><a id="GUID-BC3675D3-C925-4D72-B953-34E7C818EB91" name="GUID-BC3675D3-C925-4D72-B953-34E7C818EB91"></a><h3 id="DWHSG-GUID-BC3675D3-C925-4D72-B953-34E7C818EB91" class="sect3"><span class="enumeration_section">6.4</span>关于物化视图的安全问题</h3>
               <div>
                  <p><a id="d25854e1363" class="indexterm-anchor"></a>创建一个<a id="d25854e1368" class="indexterm-anchor"></a>在您自己的模式中的物化视图中，您必须具有<code class="codeph">CREATE</code> <code class="codeph">MATERIALIZED</code> <code class="codeph">VIEW</code>特权以及对另一个模式中引用的任何表的<code class="codeph">SELECT</code>或<code class="codeph">READ</code>特权。要在另一个模式中<code class="codeph">CREATE</code> <code class="codeph">ANY</code> <code class="codeph">VIEW</code> ，您必须具有<code class="codeph">CREATE</code> <code class="codeph">ANY</code> <code class="codeph">MATERIALIZED</code> <code class="codeph">VIEW</code>特权，并且<code class="codeph">MATERIALIZED</code> <code class="codeph">VIEW</code>的所有者需要对所引用的表具有<code class="codeph">SELECT</code>或<code class="codeph">READ</code>权限（如果它们来自其他模式）。此外，如果在引用模式外部表的实例化视图上启用查询重写，则必须对模式外的每个表具有<code class="codeph">GLOBAL</code> <code class="codeph">QUERY</code> <code class="codeph">REWRITE</code>特权或<code class="codeph">QUERY</code> <code class="codeph">REWRITE</code>对象特权。
                  </p>
                  <p>如果物化视图位于预构建容器上，则创建者（如果与所有者不同）必须在容器表上具有<code class="codeph">READ WITH GRANT</code>或<code class="codeph">SELECT</code> <code class="codeph">WITH</code> <code class="codeph">GRANT</code>权限。
                  </p>
                  <p>如果在尝试创建实例化视图时继续获得权限错误并且您认为已授予所有必需权限，则问题很可能是由于未明确授予权限并尝试从角色继承权限代替。如果表位于不同的模式中，则物化视图的所有者必须已明确授予对引用表的<code class="codeph">SELECT</code>或<code class="codeph">READ</code>访问权限。
                  </p>
                  <p>如果使用指定的<code class="codeph">ON</code> <code class="codeph">COMMIT</code> <code class="codeph">REFRESH</code>创建实例化视图，则如果定义查询中的任何表都在所有者架构之外，则实例化视图的所有者需要额外的权限。在这种情况下，所有者在所有者架构之外的每个表上都需要<code class="codeph">ON</code> <code class="codeph">COMMIT</code> <code class="codeph">REFRESH</code>系统特权或<code class="codeph">ON</code> <code class="codeph">COMMIT</code> <code class="codeph">REFRESH</code>对象特权。
                  </p>
                  <div class="infoboxnotealso" id="GUID-BC3675D3-C925-4D72-B953-34E7C818EB91__GUID-1F2568A6-4F99-40D4-9C11-24AE6998C303">
                     <p class="notep1">也可以看看：</p>
                     <p><a href="advanced-materialized-views.html#GUID-B0671C37-8287-46D6-A3D9-236DC7917775">使用虚拟专用数据库（VPD）查询物化视图</a></p>
                  </div>
               </div><a id="DWHSG8252"></a><div class="props_rev_3"><a id="GUID-B0671C37-8287-46D6-A3D9-236DC7917775" name="GUID-B0671C37-8287-46D6-A3D9-236DC7917775"></a><h4 id="DWHSG-GUID-B0671C37-8287-46D6-A3D9-236DC7917775" class="sect4"><span class="enumeration_section">6.4.1</span>使用虚拟专用数据库（VPD）查询物化视图</h4>
                  <div>
                     <p>对于所有安全问题，物化视图用作直接查询物化视图时实际显示的视图。创建视图或物化视图时，所有者必须具有访问他们正在创建的视图或物化视图的基础基础关系的必要权限。使用这些权限，所有者可以发布其他用户可以访问的视图或物化视图，前提是他们已被授予对视图或物化视图的访问权限。</p>
                     <p>使用虚拟专用数据库的物化视图是类似的。创建实例化视图时，对于实例化视图所有者的实例化视图的基本关系，不得有任何VPD策略生效。如果存在任何VPD策略，则在创建<code class="codeph">USING TRUSTED CONSTRAINTS</code>化视图时必须使用<code class="codeph">USING TRUSTED CONSTRAINTS</code>子句。物化视图的所有者可以在新物化视图上建立VPD策略。访问实体化视图的用户必须遵守物化视图上的VPD策略。但是，它们不另外受制于物化视图的基础基础关系的VPD策略，因为对物化视图的所有者执行基础基础关系的安全处理。
                     </p>
                     <p>本节包含以下主题：</p>
                     <ul style="list-style-type:disc">
                        <li>
                           <p><a href="advanced-materialized-views.html#GUID-57A3CDF3-78C5-4168-A191-21379B2AA7FE">使用查询重写与虚拟专用数据库</a></p>
                        </li>
                        <li>
                           <p><a href="advanced-materialized-views.html#GUID-8DAFE057-C831-4C8C-9A4E-65E7D0F80034">物化视图和虚拟专用数据库的限制</a></p>
                        </li>
                     </ul>
                  </div><a id="DWHSG8253"></a><div class="props_rev_3"><a id="GUID-57A3CDF3-78C5-4168-A191-21379B2AA7FE" name="GUID-57A3CDF3-78C5-4168-A191-21379B2AA7FE"></a><h5 id="DWHSG-GUID-57A3CDF3-78C5-4168-A191-21379B2AA7FE" class="sect5"><span class="enumeration_section">6.4.1.1</span>使用虚拟专用数据库重写查询</h5>
                     <div>
                        <p>当你<a id="d25854e1550" class="indexterm-anchor"></a>使用查询重写访问物化视图，物化视图充当访问结构，就像索引一样。因此，以这种方式访问的物化视图的安全隐患与索引非常相似：所有安全检查都是针对请求查询中指定的关系执行的。索引或物化视图用于加快访问数据的性能，不提供任何额外的安全检查。因此，索引或物化视图的存在不会提供额外的安全检查。
                        </p>
                        <p>当您在VPD存在的情况下使用查询重写访问实体化视图时，这也适用。请求查询受到针对查询中指定的关系存在的任何VPD策略的约束。查询重写可能会重写查询以使用实体化视图而不是访问详细信息关系，但前提是它可以保证提供完全相同的行，就像没有发生重写一样。具体而言，查询重写必须保留并遵守针对请求查询中指定的关系的任何VPD策略。但是，当使用查询重写访问实例化视图时，针对实体化视图本身的任何VPD策略都不起作用。这是因为VPD策略已经针对请求查询中的关系保护了数据。</p>
                     </div>
                  </div><a id="DWHSG8254"></a><div class="props_rev_3"><a id="GUID-8DAFE057-C831-4C8C-9A4E-65E7D0F80034" name="GUID-8DAFE057-C831-4C8C-9A4E-65E7D0F80034"></a><h5 id="DWHSG-GUID-8DAFE057-C831-4C8C-9A4E-65E7D0F80034" class="sect5"><span class="enumeration_section">6.4.1.2</span>物化视图和虚拟专用数据库的限制</h5>
                     <div>
                        <div class="section">
                           <p>询问<a id="d25854e1580" class="indexterm-anchor"></a> rewrite不会将其完整和部分文本匹配模式与包含与活动VPD策略的关系的请求查询一起使用，但它确实使用了一般的重写方法。这是因为VPD透明地转换请求查询以影响VPD策略。如果查询重写是针对具有VPD策略的请求查询执行文本匹配转换，则效果将取消VPD策略。
                           </p>
                           <p>此外，在创建或刷新实例化视图时，实例化视图的所有者必须不具有对实例化视图的基本关系有效的任何活动VPD策略，否则将返回错误。物化视图所有者必须要么没有此类VPD策略，要么任何此类策略必须返回<code class="codeph">NULL</code> 。这是因为VPD将透明地修改实体化视图的定义查询，使得实体化视图包含的行集与实例化视图定义所指示的行集不匹配。
                           </p>
                           <p>解决此限制但仍然创建包含所需VPD指定的行子集的物化视图的一种方法是在用户帐户中创建物化视图，该用户帐户没有针对实例化视图的详细关系的活动VPD策略。此外，您可以在物化视图的<code class="codeph">WHERE</code>子句中包含谓词，该谓词体现了VPD策略的效果。当查询重写尝试重写具有该VPD策略的请求查询时，它会将请求查询上的VPD生成的谓词与您在创建实例化视图时直接指定的谓词进行匹配。
                           </p>
                        </div>
                        <!-- class="section" -->
                     </div>
                  </div>
               </div>
            </div><a id="DWHSG8250"></a><div class="props_rev_3"><a id="GUID-EFE28ABF-C044-426F-93B8-C0009F591DBF" name="GUID-EFE28ABF-C044-426F-93B8-C0009F591DBF"></a><h3 id="DWHSG-GUID-EFE28ABF-C044-426F-93B8-C0009F591DBF" class="sect3"><span class="enumeration_section">6.5使</span>实体化视图无效</h3>
               <div>
                  <div class="section">
                     <p><a id="d25854e1617" class="indexterm-anchor"></a><a id="d25854e1621" class="indexterm-anchor"></a>自动维护与物化视图相关的依赖关系以确保正确操作。创建实例化视图时，实例化视图取决于其定义中引用的详细信息表。对物化视图中的任何依赖项<code class="codeph">INSERT</code>任何DML操作（如<code class="codeph">INSERT</code>或<code class="codeph">DELETE</code> ， <code class="codeph">UPDATE</code>或DDL操作）都将导致其无效。要重新验证实例化视图，请使用<code class="codeph">ALTER</code> <code class="codeph">MATERIALIZED</code> <code class="codeph">VIEW</code> <code class="codeph">COMPILE</code>语句。
                     </p>
                     <p>物化视图在引用时会自动重新生效。在许多情况下，物化视图将成功且透明地重新验证。但是，如果已在实例化视图引用的表中删除列，或者实例化视图的所有者没有查询重写权限之一，并且该权限现已授予所有者，则应使用以下语句重新验证物化视图：</p><pre class="oac_no_warn" dir="ltr">ALTER MATERIALIZED VIEW mview_name COMPILE;</pre><p>可以通过查询数据字典视图<code class="codeph">USER_MVIEWS</code>或<code class="codeph">ALL_MVIEWS</code>来检查<code class="codeph">USER_MVIEWS</code>视图的<code class="codeph">ALL_MVIEWS</code> 。 <code class="codeph">STALENESS</code>列将显示<code class="codeph">FRESH</code> ， <code class="codeph">STALE</code> ， <code class="codeph">UNUSABLE</code> ， <code class="codeph">UNKNOWN</code> ， <code class="codeph">UNDEFINED</code>或<code class="codeph">NEEDS_COMPILE</code>以指示是否可以使用物化视图。状态自动维护。但是，如果物化视图的<code class="codeph">NEEDS_COMPILE</code>标记为<code class="codeph">NEEDS_COMPILE</code> ，则可以发出<code class="codeph">ALTER</code> <code class="codeph">MATERIALIZED</code> <code class="codeph">VIEW</code> ...<code class="codeph">COMPILE</code>语句，用于验证物化视图并获取正确的过期状态。如果一个物化视图的状态为<code class="codeph">UNUSABLE</code> ，你必须执行完整的刷新带来的物化视图回<code class="codeph">FRESH</code>状态。如果物化视图基于您永远不会刷新的预构建表，则必须删除并重新创建物化视图。不跟踪远程物化视图的陈旧性。因此，如果使用远程物化视图进行重写，则认为它们是可信的。
                     </p>
                  </div>
                  <!-- class="section" -->
               </div>
            </div><a id="DWHSG8255"></a><div class="props_rev_3"><a id="GUID-D4412AFE-C4BC-4287-A9BB-104AD5E9678E" name="GUID-D4412AFE-C4BC-4287-A9BB-104AD5E9678E"></a><h3 id="DWHSG-GUID-D4412AFE-C4BC-4287-A9BB-104AD5E9678E" class="sect3"><span class="enumeration_section">6.6</span>改变物化观点</h3>
               <div>
                  <div class="section">
                     <p><a id="d25854e1727" class="indexterm-anchor"></a>可以对物化视图进行以下修改：</p>
                  </div>
                  <!-- class="section" -->
                  <div class="section">
                     <ul style="list-style-type:disc">
                        <li>
                           <p>更改其刷新选项（ <code class="codeph">FAST/FORCE/COMPLETE/NEVER</code> ）。
                           </p>
                        </li>
                        <li>
                           <p>更改其刷新模式（ <code class="codeph">ON</code> <code class="codeph">COMMIT/ON</code> <code class="codeph">DEMAND</code> ）。
                           </p>
                        </li>
                        <li>
                           <p>重新编译它。</p>
                        </li>
                        <li>
                           <p>启用或禁用其用于查询重写。</p>
                        </li>
                        <li>
                           <p>考虑一下新鲜感。</p>
                        </li>
                        <li>
                           <p>分区维护操作。</p>
                        </li>
                        <li>
                           <p>启用查询计算</p>
                        </li>
                     </ul>
                     <p>通过删除然后重新创建物化视图来实现所有其他更改。修改操作的成功取决于是否满足变更要求。例如，如果所有基表上都存在物化视图日志，则快速刷新会成功。</p>
                     <p>当物化视图失效时，可以使用<code class="codeph">ALTER</code> <code class="codeph">MATERIALIZED</code> <code class="codeph">VIEW</code>语句的<code class="codeph">COMPILE</code>子句。此编译过程很快，并允许再次使用查询重写来使用实例化视图。
                     </p>
                     <div class="infoboxnotealso" id="GUID-D4412AFE-C4BC-4287-A9BB-104AD5E9678E__GUID-FE37E5E9-CD02-4786-BA38-AE9F48C02595">
                        <p class="notep1">也可以看看：</p>
                        <ul style="list-style-type:disc">
                           <li>
                              <p>有关<code class="codeph">ALTER</code> <code class="codeph">MATERIALIZED</code> <code class="codeph">VIEW</code>语句的更多信息，请<a href="../sqlrf/SQL-Statements-ALTER-LIBRARY-to-ALTER-SESSION.html#SQLRF009" target="_blank"><span><cite>参见Oracle数据库SQL语言参考</cite></span></a></p>
                           </li>
                           <li>
                              <p><span class="q">“使<a href="advanced-materialized-views.html#GUID-EFE28ABF-C044-426F-93B8-C0009F591DBF">实体化视图无效</a> ”</span></p>
                           </li>
                        </ul>
                     </div>
                  </div>
                  <!-- class="section" -->
               </div>
            </div>
            <div class="sect2"><a id="GUID-0702359B-D379-4299-86C4-2958BCD4381D" name="GUID-0702359B-D379-4299-86C4-2958BCD4381D"></a><h3 id="DWHSG-GUID-0702359B-D379-4299-86C4-2958BCD4381D" class="sect3"><span class="enumeration_section">6.7</span>使用实时物化视图</h3>
               <div>
                  <p>即使物化视图标记为陈旧，实时物化视图也会为用户查询提供新数据。</p>
                  <div class="infoboxnotealso" id="GUID-0702359B-D379-4299-86C4-2958BCD4381D__GUID-5884C45D-BD87-448E-AED6-E780C02360AD">
                     <p class="notep1">也可以看看：</p>
                     <ul style="list-style-type:disc">
                        <li>
                           <p><a href="advanced-materialized-views.html#GUID-17A24989-32A3-4B4D-BBF1-2491A932CB2E" title="实时物化视图是一种物化视图，即使物化视图由于数据更改而与其基表不同步，也可为用户查询提供新数据。">实时物化视图概述</a></p>
                        </li>
                        <li>
                           <p><a href="advanced-materialized-views.html#GUID-36EF3539-D946-4DE3-8C12-4AD0076F9A92" title="要创建实时物化视图，请使用CREATE MATERIALIZED VIEW语句中的ON QUERY COMPUTATION子句。">创建实时物化视图</a></p>
                        </li>
                        <li>
                           <p><a href="advanced-materialized-views.html#GUID-D0C3D49B-9577-43C7-9ECC-11A7DEEFBBE0" title="如果满足实时物化视图的先决条件，则可以通过更改其定义并启用查询计算，将现有物化视图转换为实时物化视图。">将现有物化视图转换为实时物化视图</a></p>
                        </li>
                        <li>
                           <p><a href="advanced-materialized-views.html#GUID-717B8857-DCB7-4BFB-A542-8074D6FE8D73" title="对于重写用户查询以使用实时物化视图的查询重写机制，必须为实时物化视图启用查询重写。">启用查询重写以使用实时物化视图</a></p>
                        </li>
                        <li>
                           <p><a href="advanced-materialized-views.html#GUID-BF04B46B-E71D-4619-92B4-47F5CC6964F4" title="如果为实时物化视图启用了查询重写，则查询重写可以使用实时物化视图向用户查询提供结果，即使实时物化视图是陈旧的。只有当所有基本实时物化视图都是新鲜的时，嵌套的实时物化视图才有资格进行查询重写。">在查询重写期间使用实时物化视图</a></p>
                        </li>
                        <li>
                           <p><a href="advanced-materialized-views.html#GUID-23657E4E-C3DF-4757-BE8A-22CC394D6A5E" title="您可以通过在查询中引用实时物化视图的名称来直接访问实时物化视图。">使用实时物化视图进行直接查询访问</a></p>
                        </li>
                        <li>
                           <p><a href="advanced-materialized-views.html#GUID-84838620-20F6-4929-85BD-FCB2D9603710" title="数据字典视图中的ON_QUERY_COMPUTATION列ALL_MVIEWS，DBA_MVIEWS和USER_MVIEWS指示实例化视图是否是实时物化视图。">列出实时物化视图</a></p>
                        </li>
                        <li>
                           <p><a href="advanced-materialized-views.html#GUID-D4EA2570-2984-4F10-9FC7-B4DA800DE1A5" title="要为使用实时物化视图的用户查询获得更好的性能，您可以遵循某些准则。">提高实时物化视图的性能</a></p>
                        </li>
                     </ul>
                  </div>
               </div>
               <div class="sect3"><a id="GUID-17A24989-32A3-4B4D-BBF1-2491A932CB2E" name="GUID-17A24989-32A3-4B4D-BBF1-2491A932CB2E"></a><h4 id="DWHSG-GUID-17A24989-32A3-4B4D-BBF1-2491A932CB2E" class="sect4"><span class="enumeration_section">6.7.1</span>实时物化视图概述</h4>
                  <div>
                     <p>实时物化视图是一种物化视图，即使物化视图由于数据更改而与其基表不同步，也可为用户查询提供新数据。</p>
                     <p>除非将SQL会话设置为过期容忍模式，否则标记为过时的实例化视图不能用于查询重写。需要实时数据的组织通常使用<code class="codeph">ON COMMIT</code>刷新模式，以确保通过对基表所做的更改来更新<code class="codeph">ON COMMIT</code>化视图。但是，当DML对基表的更改非常频繁且非常频繁时，此模式可能会导致资源争用并降低刷新性能。实时物化视图提供了一种轻量级解决方案，可通过动态重新计算数据从过时的物化视图中获取新数据。
                     </p>
                     <p>实时物化视图可以使用任何可用的非现场刷新方法，包括基于日志或基于PCT的刷新。它们可以按需使用或按计划自动刷新使用，但不能使用<code class="codeph">ON COMMIT</code>子句指定的自动刷新。
                     </p>
                     <div class="section">
                        <p class="subhead3" id="GUID-17A24989-32A3-4B4D-BBF1-2491A932CB2E__GUID-7BF29E2F-BE91-44CD-B756-77D8C564D819">实时物化视图的优点</p>
                        <ul style="list-style-type:disc">
                           <li>
                              <p>为物化视图提供改进的可用性</p>
                           </li>
                           <li>
                              <p>为访问可能过时的物化视图的用户查询提供新数据</p>
                           </li>
                        </ul>
                     </div>
                     <!-- class="section" -->
                     <div class="section">
                        <p class="subhead3" id="GUID-17A24989-32A3-4B4D-BBF1-2491A932CB2E__GUID-3A57CD0F-6878-4803-A912-F175BA445E66">实时物化视图如何工作？</p>
                        <p>实时物化视图使用称为<span class="italic">查询计算</span>的技术来提供具有陈旧物化视图的新数据。当查询访问实时物化视图时，Oracle数据库首先检查实时物化视图是否标记为陈旧。如果它不是陈旧的，则使用实时物化视图原样提供所需数据。如果将实时物化视图标记为陈旧，则使用查询计算技术生成新数据并返回正确的查询结果。
                        </p>
                        <p>实时物化视图使用类似基于日志的刷新技术，以提供具有陈旧物化视图的新数据。它们将现有数据与更改日志中记录的更改相结合，以获取最新数据。但是，与基于日志的刷新不同，实时物化视图不使用物化视图日志来更新实时物化视图中的数据。相反，当查询访问过时的实时物化视图时，使用查询计算重新计算的数据将直接用于回答查询。</p>
                        <p>通过在物化视图定义中使用<code class="codeph">ON QUERY COMPUTATION</code>子句创建实时物化视图。
                        </p>
                     </div>
                     <!-- class="section" -->
                  </div>
                  <div class="sect4"><a id="GUID-BB11FFAB-771D-44AD-89D7-0231031D7ECA" name="GUID-BB11FFAB-771D-44AD-89D7-0231031D7ECA"></a><h5 id="DWHSG-GUID-BB11FFAB-771D-44AD-89D7-0231031D7ECA" class="sect5"><span class="enumeration_section">6.7.1.1</span>使用实时物化视图的限制</h5>
                     <div>
                        <p>使用实时物化视图受到某些限制。</p>
                        <p></p>
                        <ul style="list-style-type:disc">
                           <li>
                              <p>在以下情况下无法使用实时物化视图：</p>
                              <ul style="list-style-type:disc">
                                 <li>
                                    <p>在基表上创建的一个或多个物化视图日志不可用或不存在。</p>
                                 </li>
                                 <li>
                                    <p>对于更改方案，不可行的，基于日志的或PCT刷新是不可行的。</p>
                                 </li>
                                 <li>
                                    <p>使用<code class="codeph">ON COMMIT</code>子句指定自动刷新。
                                    </p>
                                 </li>
                              </ul>
                           </li>
                           <li>
                              <p>如果实时物化视图是在一个或多个基本物化视图之上定义的嵌套物化视图，则只有在所有基本物化视图都是新的时才会发生查询重写。如果一个或多个基本物化视图过时，则不使用此实时物化视图执行查询重写。</p>
                           </li>
                        </ul>
                        <p>不共享直接访问实时物化视图的查询的游标。</p>
                     </div>
                  </div>
                  <div class="sect4"><a id="GUID-110EAD92-6D4B-4E46-ADB0-C32D964B75D0" name="GUID-110EAD92-6D4B-4E46-ADB0-C32D964B75D0"></a><h5 id="DWHSG-GUID-110EAD92-6D4B-4E46-ADB0-C32D964B75D0" class="sect5"><span class="enumeration_section">6.7.1.2</span>关于访问实时物化视图</h5>
                     <div>
                        <p>与物化视图一样，存在多种方法来访问存储在实时物化视图中的数据。</p>
                        <p></p>
                        <p>可以通过以下方式之一访问存储在实时物化视图中的数据：</p>
                        <ul style="list-style-type:disc">
                           <li>
                              <p>查询重写</p>
                              <p>重写与实时物化视图定义类似的用户查询以使用实时物化视图。</p>
                           </li>
                           <li>
                              <p>直接访问实时物化视图</p>
                              <p>用户查询使用其名称直接引用实时物化视图。</p>
                           </li>
                        </ul>
                        <p>在这两种情况下，实时物化视图的内容可以作为陈旧数据访问，也可以触发正确结果的查询计算。是否触发查询计算取决于环境和实际的SQL语句。</p>
                        <p><code class="codeph">EXPLAIN PLAN</code>语句的输出包含指示查询计算是否用于特定用户查询的消息。
                        </p>
                        <div class="infoboxnotealso" id="GUID-110EAD92-6D4B-4E46-ADB0-C32D964B75D0__GUID-35FE7EF7-6975-4FC2-9FCC-A76DB3984952">
                           <p class="notep1">也可以看看：</p>
                           <ul style="list-style-type:disc">
                              <li>
                                 <p><a href="advanced-materialized-views.html#GUID-23657E4E-C3DF-4757-BE8A-22CC394D6A5E" title="您可以通过在查询中引用实时物化视图的名称来直接访问实时物化视图。">使用实时物化视图进行直接查询访问</a></p>
                              </li>
                              <li>
                                 <p><a href="advanced-materialized-views.html#GUID-BF04B46B-E71D-4619-92B4-47F5CC6964F4" title="如果为实时物化视图启用了查询重写，则查询重写可以使用实时物化视图向用户查询提供结果，即使实时物化视图是陈旧的。只有当所有基本实时物化视图都是新鲜的时，嵌套的实时物化视图才有资格进行查询重写。">在查询重写期间使用实时物化视图</a></p>
                              </li>
                           </ul>
                        </div>
                     </div>
                  </div>
               </div>
               <div class="sect3"><a id="GUID-36EF3539-D946-4DE3-8C12-4AD0076F9A92" name="GUID-36EF3539-D946-4DE3-8C12-4AD0076F9A92"></a><h4 id="DWHSG-GUID-36EF3539-D946-4DE3-8C12-4AD0076F9A92" class="sect4"><span class="enumeration_section">6.7.2</span>创建实时物化视图</h4>
                  <div>
                     <p>要创建实时物化视图，请使用<code class="codeph">CREATE MATERIALIZED VIEW</code>语句中的<code class="codeph">ON QUERY COMPUTATION</code>子句。
                     </p>
                     <div class="section">
                        <p>您可以创建实时物化视图，即使它们不适用于所有更改方案的查询计算。创建实时物化视图的最低要求是它支持<code class="codeph">INSERT</code>操作的非现场刷新。如果遇到其他更改方案（例如混合DML操作），则查询计算对于所有类型的实时物化视图可能都不可行。
                        </p>
                     </div>
                     <!-- class="section" -->
                     <div class="p">
                        <p>实时物化视图必须使用不合适的基于日志的刷新机制（包括PCT刷新）。<code class="codeph">ON COMMIT</code>刷新模式不能用于实时物化视图。
                        </p>
                        <p><span class="bold">要创建实时物化视图：</span></p>
                     </div>
                     <!-- class="section" -->
                     <ol>
                        <li><span>确保实时物化视图的所有基表上都存在物化视图日志。</span></li>
                        <li><span>为实时物化视图所基于的所有表创建物化视图日志。</span></li>
                        <li><span>通过在<code class="codeph">CREATE MATERIALIZED VIEW</code>语句中包含<code class="codeph">ENABLE ON QUERY COMPUTATION</code>子句来创建实时物化视图。</span></li>
                     </ol>
                     <div class="example" id="GUID-36EF3539-D946-4DE3-8C12-4AD0076F9A92__GUID-31E0354C-A993-43AF-949B-961571DF5243">
                        <p class="titleinexample">示例6-7创建实时物化视图</p>
                        <p>此示例创建一个名为<code class="codeph">SUM_SALES_RTMV</code>的实时物化视图，该视图基于从<code class="codeph">SH</code>模式中的<code class="codeph">SALES</code>和<code class="codeph">PRODUCTS</code>表聚合的数据。在创建实时物化视图之前，请确保满足所需的先决条件。
                        </p>
                        <ol>
                           <li>
                              <p>在基表<code class="codeph">SALES</code>和<code class="codeph">PRODUCTS</code>上创建物化视图日志。</p>
                              <p>以下命令在<code class="codeph">SALES</code>表上创建<code class="codeph">SALES</code>化视图日志：</p><pre class="pre codeblock"><code>使用SEQUENCE，ROWID（prod_id，quantity_sold，amount_sold）创建物料化视图登录销售包括新价值;</code></pre><p>以下命令在<code class="codeph">PRODUCTS</code>表上创建实例化视图日志。
                              </p><pre class="pre codeblock"><code>使用ROWID创建物料化视图登录产品（prod_id，prod_name，prod_category，prod_subcategory）包括新值;</code></pre></li>
                           <li>
                              <p>通过在<code class="codeph">CREATE MATERIALIZED VIEW</code>语句中包含<code class="codeph">ON QUERY COMPUTATION</code>子句来创建实时物化视图。快速刷新方法用于此实时物化视图， <code class="codeph">ENABLE QUERY REWRITE</code>子句指示必须启用查询重写。
                              </p><pre class="pre codeblock"><code>CREATE MATERIALIZED VIEW sum_sales_rtmv REFRESH FAST ON DERMAND ENABLE QUERY REWRITE ENABLE QUERY COMPUTATION AS SELECT prod_name，SUM（quantity_sold）AS sum_qty，COUNT（quantity_sold）AS cnt_qty，SUM（amount_sold）AS sum_amt，COUNT（amount_sold）AS cnt_amt，COUNT（* ）AS cnt_star FROM sales，产品WHERE sales.prod_id = products.prod_id GROUP BY prod_name;</code></pre></li>
                        </ol>
                        <p>在创建<code class="codeph">SUM_SALES_RTMV</code>实时物化视图后，假定运行以下查询。
                        </p><pre class="pre codeblock"><code>SELECT prod_name，SUM（quantity_sold），SUM（amount_sold）FROM sales，products WHERE sales.prod_id = products.prod_id GROUP BY prod_name;</code></pre><p>如果<code class="codeph">SUM_SALES_RTMV</code>不是陈旧的，则使用存储在此实时物化视图中的数据返回查询结果。但是，如果<code class="codeph">SUM_SALES_RTMV</code>是陈旧的，并且使用具有查询计算的物化视图重写查询的成本低于基表访问，则通过组合<code class="codeph">SALES</code>和<code class="codeph">PRODUCTS</code>上的物化视图日志中的增量更改来回答查询。具有实时物化视图<code class="codeph">SUM_SALES_RTMV</code>的数据的表。</p>
                     </div>
                     <!-- class="example" -->
                  </div>
               </div>
               <div class="sect3"><a id="GUID-D0C3D49B-9577-43C7-9ECC-11A7DEEFBBE0" name="GUID-D0C3D49B-9577-43C7-9ECC-11A7DEEFBBE0"></a><h4 id="DWHSG-GUID-D0C3D49B-9577-43C7-9ECC-11A7DEEFBBE0" class="sect4"><span class="enumeration_section">6.7.3</span>将现有物化视图转换为实时物化视图</h4>
                  <div>
                     <p>如果满足实时物化视图的先决条件，则可以通过更改其定义并启用查询计算，将现有物化视图转换为实时物化视图。</p>
                     <div class="section">
                        <p><span class="bold">要将物化视图转换为实时物化视图：</span> 
                        </p>
                     </div>
                     <!-- class="section" -->
                     <ul>
                        <li><span>通过使用<code class="codeph">ALTER MATERIALIZED VIEW</code>语句中的<code class="codeph">ON QUERY COMPUTATION</code>子句修改实例化视图定义并启用查询计算。</span></li>
                     </ul>
                     <div class="section">
                        <p>通过使用<code class="codeph">ALTER MATERIALIZED VIEW</code>语句中的<code class="codeph">DISABLE ON QUERY COMPUTATION</code>子句<code class="codeph">DISABLE ON QUERY COMPUTATION</code>查询计算，可以将实时物化视图转换为常规物化视图。
                        </p>
                     </div>
                     <!-- class="section" -->
                     <div class="example" id="GUID-D0C3D49B-9577-43C7-9ECC-11A7DEEFBBE0__GUID-5DD6FF33-5D45-416B-946C-CA44A3772F37">
                        <p class="titleinexample">示例6-8将实体化视图转换为实时物化视图</p>
                        <p>物化视图<code class="codeph">SALES_RTMV</code>基于<code class="codeph">SALES</code> ， <code class="codeph">TIMES</code>和<code class="codeph">PRODUCTS</code>表，并使用快速刷新。物化视图日志存在于所有三个基表中。您想要修改此物化视图并将其转换为实时物化视图。
                        </p>
                        <ol>
                           <li>
                              <p>修改实例化视图定义并包含<code class="codeph">ON QUERY COMPUTATION</code>子句以将其更改为实时物化视图。
                              </p><pre class="pre codeblock"><code>ALTER MATERIALIZED VIEW sales_rtmv启用查询计算;</code></pre></li>
                           <li>
                              <p>查询<code class="codeph">DBA_MVIEWS</code>视图以确定是否为<code class="codeph">SALES_RTMV</code>启用了查询计算。</p><pre class="pre codeblock"><code><code class="codeph">SELECT mview_name, on_query_computation</code> <code class="codeph">FROM dba_mviews WHERE mview_name = 'SALES_RTMV';</code></code></pre></li>
                        </ol>
                     </div>
                     <!-- class="example" -->
                  </div>
               </div>
               <div class="sect3"><a id="GUID-717B8857-DCB7-4BFB-A542-8074D6FE8D73" name="GUID-717B8857-DCB7-4BFB-A542-8074D6FE8D73"></a><h4 id="DWHSG-GUID-717B8857-DCB7-4BFB-A542-8074D6FE8D73" class="sect4"><span class="enumeration_section">6.7.4</span>启用查询重写以使用实时物化视图</h4>
                  <div>
                     <p>对于重写用户查询以使用实时物化视图的查询重写机制，必须为实时物化视图启用查询重写。</p>
                     <div class="section">
                        <p>您可以通过修改实时物化视图的定义，在创建时或随后为实时物化视图启用查询重写。<code class="codeph">ENABLE QUERY REWRITE</code>子句用于启用查询重写。
                        </p>
                     </div>
                     <!-- class="section" -->
                     <div class="p">
                        <p>要为现有的实时物化视图启用查询重写，请执行以下操作：</p>
                     </div>
                     <!-- class="section" -->
                     <ul>
                        <li><span>运行<code class="codeph">ALTER MATERIALIZED VIEW</code>命令并包含<code class="codeph">ENABLE QUERY REWRITE</code>子句。</span></li>
                     </ul>
                     <div class="example" id="GUID-717B8857-DCB7-4BFB-A542-8074D6FE8D73__GUID-38AD3618-6915-4945-93AE-EC59DBF517BC">
                        <p class="titleinexample">示例6-9为实时物化视图启用查询重写</p>
                        <p>实时物化视图<code class="codeph">my_rtmv</code>使用快速刷新机制。您希望修改此实时物化视图的定义，并指定查询重写机制在重写查询时必须考虑此实时物化视图。
                        </p>
                        <p>以下命令为<code class="codeph">my_rtmv</code>启用查询重写：</p><code class="codeph">ALTER MATERIALIZED VIEW my_rtmv ENABLE QUERY REWRITE;</code></div>
                     <!-- class="example" -->
                  </div>
               </div>
               <div class="sect3"><a id="GUID-BF04B46B-E71D-4619-92B4-47F5CC6964F4" name="GUID-BF04B46B-E71D-4619-92B4-47F5CC6964F4"></a><h4 id="DWHSG-GUID-BF04B46B-E71D-4619-92B4-47F5CC6964F4" class="sect4"><span class="enumeration_section">6.7.5</span>在查询重写期间使用实时物化视图</h4>
                  <div>
                     <p>如果为实时物化视图启用了查询重写，则查询重写可以使用实时物化视图向用户查询提供结果，即使实时物化视图是陈旧的。只有当所有基本实时物化视图都是新鲜的时，嵌套的实时物化视图才有资格进行查询重写。</p>
                     <div class="section">
                        <p>运行用户查询时，查询重写首先检查是否有新的实体化视图可用于提供所需数据。如果不存在合适的物化视图，则查询重写将查找可用于重写用户查询的实时物化视图。新的物化视图优于实时物化视图，因为在为实时物化视图计算新数据时会产生一些开销。接下来，基于成本的优化器使用查询计算确定SQL查询的成本，然后决定是否将使用实时物化视图来回答此用户查询。</p>
                     </div>
                     <!-- class="section" -->
                     <div class="p">
                        <p>如果当前SQL会话的<code class="codeph">QUERY_REWRITE_INTEGRITY</code>模式设置为<code class="codeph">STALE_TOLERATED</code> ，则在查询重写期间不会使用查询计算。<code class="codeph">STALE_TOLERATED</code>重写模式表示不需要新的结果来满足查询，因此不需要查询计算。
                        </p>
                        <p><span class="bold">对于查询重写以使用实时物化视图：</span></p>
                     </div>
                     <!-- class="section" -->
                     <ol>
                        <li class="stepexpand"><span>确保<code class="codeph">QUERY_REWRITE_INTEGRITY</code>设置为<code class="codeph">ENFORCED</code>或<code class="codeph">TRUSTED</code>模式。<code class="codeph">QUERY_REWRITE_INTEGRITY</code>模式不应设置为<code class="codeph">STALE_TOLERATED</code>模式。</span></li>
                        <li class="stepexpand"><span>运行与用于定义实时物化视图的SQL查询匹配的用户查询。</span><div>
                              <p>任何可以重写以利用实时物化视图的查询都将使用具有查询计算的实时物化视图。</p>
                              <p>使用<code class="codeph">EXPLAIN PLAN</code>验证是否使用实时物化视图重写了查询。
                              </p>
                           </div>
                        </li>
                     </ol>
                     <div class="example" id="GUID-BF04B46B-E71D-4619-92B4-47F5CC6964F4__GUID-B4B383C0-0ACF-4E5E-B4EC-08DEBD4A43B1">
                        <p class="titleinexample">示例6-10在查询重写期间使用实时物化视图</p>
                        <p>此示例创建一个启用了查询重写的实时物化视图，然后演示查询重写使用它来为用户查询提供数据。</p>
                        <ol>
                           <li>
                              <p>在<code class="codeph">SALES</code>表上创建物化视图日志，该表是要创建的实时物化视图的基表。
                              </p>
                           </li>
                           <li>
                              <p>创建实时物化视图<code class="codeph">mav_sum_sales</code>并启用查询重写。
                              </p><pre class="pre codeblock"><code>创建物化视图mav_sum_sales快速启动需求快速启动查询计算启用QUERY REWRITE作为选择prod_id，sum（quantity_sold）作为sum_qty，count（quantity_sold）作为cnt_qty，sum（amount_sold）sum_amt，count（amount_sold）cnt_amt，count（*）as cnt_star FROM sales GROUP BY prod_id;</code></pre></li>
                           <li>
                              <p>运行以下查询：</p><pre class="pre codeblock"><code>SELECT prod_id，sum（quantity_sold），sum（amount_sold）FROM sales WHERE prod_id &lt;1000 GROUP BY prod_id;</code></pre><p>观察该查询类似于用于定义实时物化视图<code class="codeph">mav_sum_sales</code> 。由于不存在具有与查询类似的定义的其他物化视图，因此查询重写可以使用<code class="codeph">mav_sum_sales</code>实时物化视图来确定查询结果。您可以通过检查SQL游标缓存（例如，使用<code class="codeph">DBMS_XPLAN</code> ），使用SQL监视器或使用<code class="codeph">EXPLAIN PLAN</code>来验证是否已进行查询重写。</p>
                              <p>使用<code class="codeph">mav_sum_sales</code>的内部重写查询类似于以下语句：</p><pre class="pre codeblock"><code>SELECT prod_id，sum_qty，sum_amt FROM mav_sum_sales WHERE prod_id &lt;1000;</code></pre></li>
                           <li>
                              <p>验证是否使用实时物化视图来提供查询结果。使用<code class="codeph">EXPLAIN PLAN</code>语句查看查询的执行计划。
                              </p>
                              <p>以下执行计划显示了对实时物化视图的直接访问。如果物化视图过时，则执行计划将变得更加复杂，并且包括对其他对象的访问（例如，物化视图日志），具体取决于未完成的DML操作。</p><pre class="pre codeblock"><code>EXPLAIN PLAN for SELECT prod_id，sum（quantity_sold），sum（amount_sold）FROM sales WHERE prod_id &lt;1000 GROUP BY prod_id; SELECT plan_table_output FROM table（dbms_xplan.display（'plan_table'，null，'serial'））; PLAN_TABLE_OUTPUT ------------------------------------------------- ----------------------------------------------计划哈希值： 13616844 ------------------------------------------------- ---------------------------------------------- | Id |操作|名称|行|字节|成本（％CPU）|时间| -------------------------------------------------- --------------------------------------------- | 0 |选择声明| | 92 | 3588 | 3（0）| 00:00:01 | | * 1 | MAT_VIEW ACCESS FULL | MAV_SUM_SALES | 92 | 3588 | 3（0）| 00:00:01 | -------------------------------------------------- ---------------------------------------------谓词信息（由操作ID）：---------------------------------------------- ----- 1  - 过滤器（“PROD_ID”&lt;1000）注-----  - 使用动态统计：动态采样（level = 2）选择17行。</code></pre></li>
                        </ol>
                     </div>
                     <!-- class="example" -->
                  </div>
               </div>
               <div class="sect3"><a id="GUID-23657E4E-C3DF-4757-BE8A-22CC394D6A5E" name="GUID-23657E4E-C3DF-4757-BE8A-22CC394D6A5E"></a><h4 id="DWHSG-GUID-23657E4E-C3DF-4757-BE8A-22CC394D6A5E" class="sect4"><span class="enumeration_section">6.7.6</span>使用实时物化视图进行直接查询访问</h4>
                  <div>
                     <p>您可以通过在查询中引用实时物化视图的名称来直接访问实时物化视图。</p>
                     <div class="section">
                        <p>如果用户查询中指定的实时物化视图是新鲜的，则直接从实时物化视图中提取所需数据。如果实时物化视图过时，则必须使用<code class="codeph">FRESH_MV</code>提示执行查询计算并获取新数据。Oracle数据库不会自动对在用户查询中直接访问的实时物化视图执行查询计算。
                        </p>
                        <p>在直接访问实时物化视图时，从陈旧的实时物化视图中获取新数据：</p>
                     </div>
                     <!-- class="section" -->
                     <ul>
                        <li><span>在用户查询中使用<code class="codeph">FRESH_MV</code>提示指示必须执行查询计算。</span></li>
                     </ul>
                     <div class="example" id="GUID-23657E4E-C3DF-4757-BE8A-22CC394D6A5E__GUID-6D715D37-9A73-4C5C-8AA7-5EC1892DA477">
                        <p class="titleinexample">示例6-11创建实时物化视图并在查询中使用它</p>
                        <p>此示例创建基于<code class="codeph">SALES_NEW</code>表的实时物化视图<code class="codeph">MY_RTMV</code> 。<code class="codeph">SALES_NEW</code>表创建为<code class="codeph">SH.SALES</code>表的副本。创建实时物化视图后，将在行表中插入一行。接下来， <code class="codeph">fresh_mv</code>提示用于通过在用户查询中使用实体化视图名称从实时物化视图访问新数据。
                        </p>
                        <ol>
                           <li>
                              <p>在基表<code class="codeph">sales_new</code>上创建物化视图日志。
                              </p>
                              <p>基表上的物化视图日志对于创建实时物化视图是必需的。</p><pre class="pre codeblock"><code>在sales_new上创建MATERIALIZED VIEW LOG WITH sequence，ROWID（prod_id，cust_id，time_id，channel_id，promo_id，quantity_sold，amount_sold）包括新值;</code></pre></li>
                           <li>
                              <p>使用<code class="codeph">sales_new</code>作为基表创建名为<code class="codeph">my_rtmv</code>的实时物化视图。
                              </p>
                              <p><code class="codeph">ON QUERY COMPUTATION</code>子句指示创建实时物化视图。指定的刷新模式是基于日志的快速刷新。为实时物化视图启用了查询重写。
                              </p><pre class="pre codeblock"><code>CREATE MATERIALIZED VIEW my_rtmv REFRESH快速启用查询计算启用QUERY REWRITE作为SELECT prod_id，cust_id，channel_id，sum（quantity_sold）sum_q，count（quantity_sold）cnt_q，avg（quantity_sold）avg_q，sum（amount_sold）sum_a，count（amount_sold）cnt_a ，avg（amount_sold）avg_a FROM sales_new GROUP BY prod_id，cust_id，channel_id;</code></pre></li>
                           <li>
                              <p>在<code class="codeph">sales_new</code>插入一行，即实时物化视图的基表并提交此更改。
                              </p><pre class="pre codeblock"><code>INSERT INTO sales_new（prod_id，cust_id，time_id，channel_id，promo_id，quantity_sold，amount_sold）VALUES（116,100450，sysdate，9,9999,10,350）;承诺;</code></pre></li>
                           <li>
                              <p>直接查询实时物化视图，以显示在上一步中添加到实时物化视图基表的行的数据。</p><pre class="pre codeblock"><code>SELECT * from my_rtmv WHERE prod_id = 116 AND cust_id = 100450 AND channel_id = 9; PROD_ID CUST_ID CHANNEL_ID SUM_Q CNT_Q AVG_Q SUM_A CNT_A AVG_A ------- ------- ---------- ----- ----- -----  - --- ----- ------ 116 100450 9 1 1 1 11.99 1 11.99</code></pre><p>请注意，查询结果不会显示此数据的更新值。这是因为实时物化视图尚未通过对其基表所做的更改进行刷新。</p>
                           </li>
                           <li>
                              <p>在查询实时物化视图时包括<code class="codeph">FRESH_MV</code>提示，以显示基表中更新的行。
                              </p><pre class="pre codeblock"><code>SELECT / * + fresh_mv * / * FROM my_rtmv WHERE prod_id = 116 AND cust_id = 100450 AND channel_id = 9; PROD_ID CUST_ID CHANNEL_ID SUM_Q CNT_Q AVG_Q SUM_A CNT_A AVG_A ------- ------- ---------- ----- ----- -----  - --- ----- ------ 116 100450 9 11 2 5.5 361.99 2 180.995</code></pre><p>请注意，这次显示更新的行。这是因为<code class="codeph">FRESH_MV</code>提示触发实时物化视图的查询计算并重新计算新数据。
                              </p>
                           </li>
                        </ol>
                     </div>
                     <!-- class="example" -->
                  </div>
               </div>
               <div class="sect3"><a id="GUID-84838620-20F6-4929-85BD-FCB2D9603710" name="GUID-84838620-20F6-4929-85BD-FCB2D9603710"></a><h4 id="DWHSG-GUID-84838620-20F6-4929-85BD-FCB2D9603710" class="sect4"><span class="enumeration_section">6.7.7</span>列出实时物化视图</h4>
                  <div>
                     <p>数据字典视图中的<code class="codeph">ON_QUERY_COMPUTATION</code>列<code class="codeph">ALL_MVIEWS</code> ， <code class="codeph">DBA_MVIEWS</code>和<code class="codeph">USER_MVIEWS</code>指示<code class="codeph">USER_MVIEWS</code>化视图是否是实时物化视图。
                     </p>
                     <div class="section">
                        <p><code class="codeph">ON_QUERY_COMPUTATION</code>列中的Y值表示实时物化视图。
                        </p>
                     </div>
                     <!-- class="section" -->
                     <div class="p">要列出用户架构中的所有实时物化视图：</div>
                     <!-- class="section" -->
                     <ul>
                        <li><span>查询<code class="codeph">USER_MVIEWS</code>视图并显示<code class="codeph">USER_MVIEWS</code>视图的详细信息，并将<code class="codeph">ON_QUERY_COMPUTATION</code>列设置为Y.</span></li>
                     </ul>
                     <div class="example" id="GUID-84838620-20F6-4929-85BD-FCB2D9603710__GUID-3E8E705C-34BC-4668-9B9E-9CDD71FD5227">
                        <p class="titleinexample">示例6-12列出当前用户架构中的实时物化视图</p><pre class="pre codeblock"><code>SELECT owner，mview_name，rewrite_enabled，staleness FROM user_mviews WHERE on_query_computation ='Y'; OWNER MVIEW_NAME REWRITE_ENABLED STALENESS ------ ------------ ------------------- --------- --- SH SALES_RTMV N FRESH SH MAV_SUM_SALES Y FRESH SH MY_SUM_SALES_RTMV Y FRESH SH NEW_SALES_RTMV Y STALE</code></pre></div>
                     <!-- class="example" -->
                  </div>
               </div>
               <div class="sect3"><a id="GUID-D4EA2570-2984-4F10-9FC7-B4DA800DE1A5" name="GUID-D4EA2570-2984-4F10-9FC7-B4DA800DE1A5"></a><h4 id="DWHSG-GUID-D4EA2570-2984-4F10-9FC7-B4DA800DE1A5" class="sect4"><span class="enumeration_section">6.7.8</span>提高实时物化视图的性能</h4>
                  <div>
                     <p>要为使用实时物化视图的用户查询获得更好的性能，您可以遵循某些准则。</p>
                     <p></p>
                     <p>使用以下指南和实时物化视图：</p>
                     <ul style="list-style-type:disc">
                        <li>
                           <p>经常刷新实时物化视图以增强可能使用这些实时物化视图的查询的性能。</p>
                           <p>由于实时物化视图通过将基础表的增量更改与现有物化视图数据相结合来工作，因此当要计算的增量变化很小时，查询响应时间会增强。通过更加出色的DML操作，查询计算可能变得更加复杂（并且成本高昂），直到基本表访问变得更加高效（在查询重写的情况下）。</p>
                        </li>
                        <li>
                           <p>收集基表，实时物化视图和物化视图日志的统计信息，以使优化器能够准确地确定查询的成本。</p>
                           <p>对于查询重写，基于成本的重写机制使用优化器来确定是否应该使用重写的查询。优化程序使用统计信息来确定成本。</p>
                        </li>
                     </ul>
                  </div>
               </div>
            </div>
         </div>
      </article>
   </body>
</html>