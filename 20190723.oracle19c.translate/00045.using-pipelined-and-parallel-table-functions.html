<html lang="en-us" dir="ltr" xml:lang="en-us">
   <head>
      <meta http-equiv="Content-Type" content="text/html; charset=utf-8"></meta>
      <meta name="viewport" content="width=device-width, initial-scale=1"></meta>
      <meta http-equiv="X-UA-Compatible" content="IE=edge"></meta>
      <title>使用流水线和并行表函数</title>
      <meta property="og:site_name" content="Oracle Help Center"></meta>
      <meta property="og:title" content="Data Cartridge Developer&#39;s Guide"></meta>
      <meta property="og:description" content=""></meta>
      <link rel="stylesheet" href="/sp_common/book-template/ohc-book-template/css/book.css"></link>
      <link rel="shortcut icon" href="/sp_common/book-template/ohc-common/img/favicon.ico"></link>
      <meta name="application-name" content="Data Cartridge Developer&#39;s Guide"></meta>
      <meta name="generator" content="DITA Open Toolkit version 1.8.5 (Mode = doc)"></meta>
      <meta name="plugin" content="SP_docbuilder HTML plugin release 18.2.2"></meta>
      <link rel="alternate" href="data-cartridge-developers-guide.pdf" title="PDF File" type="application/pdf"></link>
      <meta name="robots" content="all"></meta>
      <link rel="schema.dcterms" href="http://purl.org/dc/terms/"></link>
      <meta name="dcterms.created" content="2019-01-10T07:34:53-08:00"></meta>
      <meta name="dcterms.title" content="Data Cartridge Developer&#39;s Guide"></meta>
      <meta name="dcterms.dateCopyrighted" content="1996, 2019"></meta>
      <meta name="dcterms.category" content="database"></meta>
      <meta name="dcterms.identifier" content="E96431-01"></meta>
      
      <meta name="dcterms.product" content="en/database/oracle/oracle-database/19"></meta>
      
      <link rel="prev" href="using-user-defined-aggregate-functions.html" title="Previous" type="text/html"></link>
      <link rel="next" href="designing-data-cartridges.html" title="Next" type="text/html"></link>
      <script>
        document.write('<style type="text/css">');
        document.write('body > .noscript, body > .noscript ~ * { visibility: hidden; }');
        document.write('</style>');
     </script>
      <script src="/sp_common/book-template/requirejs/require.js" data-main="/sp_common/book-template/ohc-book-template/js/book-config"></script>
      <script>
            if (window.require === undefined) {
                document.write('<script data-main="sp_common/book-template/ohc-book-template/js/book-config" src="sp_common/book-template/requirejs/require.js"><\/script>');
                document.write('<link href="sp_common/book-template/ohc-book-template/css/book.css" rel="stylesheet"/>');
            }
        </script>
      <script type="application/json" id="ssot-metadata">{"primary":{"category":{"short_name":"database","element_name":"Database","display_in_url":true},"suite":{"short_name":"oracle","element_name":"Oracle","display_in_url":true},"product_group":{"short_name":"not-applicable","element_name":"Not applicable","display_in_url":false},"product":{"short_name":"oracle-database","element_name":"Oracle Database","display_in_url":true},"release":{"short_name":"19","element_name":"Release 19","display_in_url":true}}}</script>
      
    <meta name="dcterms.isVersionOf" content="ADDCI"></meta>
    <meta name="dcterms.release" content="Release 19"></meta>
  </head>
   <body dir="ltr">
      <div class="noscript alert alert-danger text-center" role="alert">
         <a href="using-user-defined-aggregate-functions.html" class="pull-left"><span class="glyphicon glyphicon-chevron-left" aria-hidden="true"></span>上一页</a> <a href="designing-data-cartridges.html" class="pull-right">下一页<span class="glyphicon glyphicon-chevron-right" aria-hidden="true"></span></a> <span class="fa fa-exclamation-triangle" aria-hidden="true"></span>必须启用JavaScript才能正确显示此内容</div>
      <article>
         <header>
            <ol class="breadcrumb" vocab="http://schema.org/" typeof="BreadcrumbList">
               <li property="itemListElement" typeof="ListItem"><a href="index.html" property="item" typeof="WebPage"><span property="name">数据盒式开发人员指南</span></a></li>
               <li property="itemListElement" typeof="ListItem"><a href="building-data-cartridges.html" property="item" typeof="WebPage"><span property="name">构建数据磁带</span></a></li>
               <li class="active" property="itemListElement" typeof="ListItem">使用流水线和并行表函数</li>
            </ol>
            <a id="GUID-EFB94CFB-3E44-4236-B490-ADBB480C94D4" name="GUID-EFB94CFB-3E44-4236-B490-ADBB480C94D4"></a><a id="ADDCI2140"></a>
            
            <h2 id="ADDCI-GUID-EFB94CFB-3E44-4236-B490-ADBB480C94D4" class="sect2"><span class="enumeration_chapter">13</span>使用流水线和并行表功能</h2>
         </header>
         <div class="ind">
            <div>
               <p>表函数和通用数据类型<code class="codeph">ANYTYPE</code> ， <code class="codeph">ANYDATA</code>和<code class="codeph">ANYDATASET</code>通常与表函数一起使用。
               </p>
            </div><a id="ADDCI4678"></a><a id="ADDCI4679"></a><a id="ADDCI4677"></a><div class="props_rev_3"><a id="GUID-67CEE062-4AEE-4E06-87A3-609DAF0DFC0C" name="GUID-67CEE062-4AEE-4E06-87A3-609DAF0DFC0C"></a><h3 id="ADDCI-GUID-67CEE062-4AEE-4E06-87A3-609DAF0DFC0C" class="sect3"><span class="enumeration_section">13.1</span>表函数概述</h3>
               <div>
                  <p>表函数是生成可以像物理数据库表一样查询的行集合（嵌套表或varray）的函数。您在查询的<code class="codeph">FROM</code>子句中使用表函数，如数据库表的名称。
                  </p>
                  <p>表函数可以将行集合作为输入。输入集合参数可以是集合类型或<code class="codeph">REF CURSOR</code> 。</p>
                  <p>表函数可以并行执行，并且返回的行可以直接流式传输到下一个进程而无需中间分段。表函数返回的集合中的行也可以流水线化;这意味着它们在生成时被迭代返回，而不是在完成表函数输入的所有处理后在单个批处理中返回。</p>
                  <p>表函数的流式传输，流水线操作和并行执行可以通过以下方式提高性能：</p>
                  <ul style="list-style-type:disc">
                     <li>
                        <p>通过启用表函数的多线程并发执行</p>
                     </li>
                     <li>
                        <p>通过消除进程之间的中间分段</p>
                     </li>
                     <li>
                        <p>通过改进查询响应时间：对于非流水线表函数，必须构造表函数返回的整个集合，并在查询返回单个结果行之前将其返回到服务器。流水线操作可以在生成行时迭代地返回行。这也减少了表函数所需的内存，因为对象缓存不必实现整个集合。</p>
                     </li>
                     <li>
                        <p>通过迭代地提供表函数返回的集合中的结果行，因为生成行而不是等待整个集合在表或内存中暂存，然后返回整个集合</p>
                     </li>
                  </ul>
                  <p><a href="using-pipelined-and-parallel-table-functions.html#GUID-67CEE062-4AEE-4E06-87A3-609DAF0DFC0C__CIHHJFCF">图13-1</a>显示了一个典型的数据处理场景，在最终加载到数据库之前，数据经过几个（在本例中为三个）转换，由表函数实现。在这种情况下，表函数不是并行运行的，并且必须在每次转换后暂存整个结果集合。
                  </p>
                  <div class="figure" id="GUID-67CEE062-4AEE-4E06-87A3-609DAF0DFC0C__CIHHJFCF">
                     <p class="titleinfigure">图13-1具有非并行，非流水线表函数的典型数据处理</p><img src="img/addci044.gif" alt="下面是图13-1的描述" title="下面是图13-1的描述" longdesc="img_text/addci044.html"><br><a href="img_text/addci044.html">“图13-1具有非并行，非流水线表函数的典型数据处理”的描述</a></div>
                  <!-- class="figure" -->
                  <p>相比之下， <a href="using-pipelined-and-parallel-table-functions.html#GUID-67CEE062-4AEE-4E06-87A3-609DAF0DFC0C__I1006439">图13-2</a>显示了流和并行执行如何简化相同的场景。
                  </p>
                  <div class="figure" id="GUID-67CEE062-4AEE-4E06-87A3-609DAF0DFC0C__I1006439">
                     <p class="titleinfigure">图13-2使用流水线和并行执行的数据处理</p><img src="img/addci045.gif" alt="下面是图13-2的描述" title="下面是图13-2的描述" longdesc="img_text/addci045.html"><br><a href="img_text/addci045.html">“图13-2使用流水线和并行执行的数据处理”的描述</a></div>
                  <!-- class="figure" -->
               </div>
            </div><a id="ADDCI4680"></a><div class="props_rev_3"><a id="GUID-DA4B586B-A7EC-4B2B-80D0-A48298806FEF" name="GUID-DA4B586B-A7EC-4B2B-80D0-A48298806FEF"></a><h3 id="ADDCI-GUID-DA4B586B-A7EC-4B2B-80D0-A48298806FEF" class="sect3"><span class="enumeration_section">13.2</span>表函数概念</h3>
               <div>
                  <p>考虑表函数以及与这些表函数的流水线操作和并行执行相关的一些概念。</p>
               </div><a id="ADDCI4682"></a><a id="ADDCI4683"></a><a id="ADDCI4684"></a><a id="ADDCI4685"></a><a id="ADDCI4681"></a><div class="props_rev_3"><a id="GUID-B3C5E3EC-9041-428D-AD25-0C3BA6F09BED" name="GUID-B3C5E3EC-9041-428D-AD25-0C3BA6F09BED"></a><h4 id="ADDCI-GUID-B3C5E3EC-9041-428D-AD25-0C3BA6F09BED" class="sect4"><span class="enumeration_section">13.2.1</span>表函数</h4>
                  <div>
                     <p>表函数返回一个集合类型实例，可以通过调用查询的<code class="codeph">FROM</code>子句中的函数来查询表。表函数使用<code class="codeph">TABLE</code>关键字。
                     </p>
                     <p>以下示例显示了一个表函数<code class="codeph">GetBooks</code> ，它将<code class="codeph">CLOB</code>作为输入并返回集合类型<code class="codeph">BookSet_t</code>的实例。<code class="codeph">CLOB</code>列以某种格式（专有或遵循诸如XML之类的标准）存储书籍的目录列表。table函数返回所有目录及其相应的图书清单。集合类型<code class="codeph">BookSet_t</code>在<a href="using-pipelined-and-parallel-table-functions.html#GUID-B3C5E3EC-9041-428D-AD25-0C3BA6F09BED__CIHBGIFJ">例13-1中</a>定义。
                     </p>
                     <p><code class="codeph">CLOB</code>存储在表<code class="codeph">Catalogs</code> ，如<a href="using-pipelined-and-parallel-table-functions.html#GUID-B3C5E3EC-9041-428D-AD25-0C3BA6F09BED__CIHECFFI">例13-2所示</a> 。
                     </p>
                     <p>函数<code class="codeph">GetBooks()</code>在<a href="using-pipelined-and-parallel-table-functions.html#GUID-B3C5E3EC-9041-428D-AD25-0C3BA6F09BED__CIHBIIEH">例13-3中</a>定义。
                     </p>
                     <p><a href="using-pipelined-and-parallel-table-functions.html#GUID-B3C5E3EC-9041-428D-AD25-0C3BA6F09BED__CIHEJHJB">例13-4中</a>的查询返回所有目录及其相应的图书清单。
                     </p>
                     <div class="example" id="GUID-B3C5E3EC-9041-428D-AD25-0C3BA6F09BED__CIHBGIFJ">
                        <p class="titleinexample">示例13-1创建集合类型</p><pre class="oac_no_warn" dir="ltr">CREATE TYPE Book_t AS OBJECT（名称VARCHAR2（100），作者VARCHAR2（30），抽象VARCHAR2（1000））; CREATE TYPE BookSet_t AS TABLE of Book_t;</pre></div>
                     <!-- class="example" -->
                     <div class="example" id="GUID-B3C5E3EC-9041-428D-AD25-0C3BA6F09BED__CIHECFFI">
                        <p class="titleinexample">例13-2在表中存储Clob</p><pre class="oac_no_warn" dir="ltr">CREATE TABLE目录（名称VARCHAR2（30），cat CLOB）;</pre></div>
                     <!-- class="example" -->
                     <div class="example" id="GUID-B3C5E3EC-9041-428D-AD25-0C3BA6F09BED__CIHBIIEH">
                        <p class="titleinexample">示例13-3创建返回集合类型的函数</p><pre class="oac_no_warn" dir="ltr">创建功能GetBooks（一个CLOB）返回BookSet_t;</pre></div>
                     <!-- class="example" -->
                     <div class="example" id="GUID-B3C5E3EC-9041-428D-AD25-0C3BA6F09BED__CIHEJHJB">
                        <p class="titleinexample">示例13-4在查询中使用集合类型</p><pre class="oac_no_warn" dir="ltr">SELECT c.name，Book.name，Book.author，Book.abstract FROM Catalogs c，TABLE（GetBooks（c.cat））Book;</pre></div>
                     <!-- class="example" -->
                  </div>
               </div><a id="ADDCI4686"></a><div class="props_rev_3"><a id="GUID-4382D7CF-942A-479F-9726-2C801BE614FB" name="GUID-4382D7CF-942A-479F-9726-2C801BE614FB"></a><h4 id="ADDCI-GUID-4382D7CF-942A-479F-9726-2C801BE614FB" class="sect4"><span class="enumeration_section">13.2.2</span>流水线表功能</h4>
                  <div>
                     <p>如果生产者（转换）生成消费者（转换）消耗数据，则数据被称为流水线，而不是在输入到下一个转换之前在表或缓存中暂存。</p>
                     <p>管道传输使表函数能够更快地返回行，并且可以减少缓存表函数结果所需的内存。</p>
                     <p>流水线表函数可以在子集中返回表函数的结果集合。返回的集合的行为类似于可以根据需要获取的流。这使得可以使用像虚拟表这样的表函数。</p>
                     <p>流水线表功能可以通过两种方式实现：</p>
                     <ul style="list-style-type:disc">
                        <li>
                           <p>在本机PL / SQL方法中，使用者和生产者可以在单独的执行线程上运行（在相同或不同的进程上下文中），并通过管道或排队机制进行通信。这种方法类似于协同例程执行。</p>
                        </li>
                        <li>
                           <p>在接口方法中，使用者和生产者在同一个执行线程上运行。生成器在生成一组结果后显式地将控件返回给使用者。此外，生产者缓存当前状态，以便当消费者再次调用它时，它可以从中断状态恢复。</p>
                           <p>接口方法要求您以过程语言实现一组定义良好的接口。</p>
                        </li>
                     </ul>
                     <p>协同例程执行模型为实现流水线表函数提供了一种更简单的本机PL / SQL机制，但该模型不能用于用C或Java编写的表函数。另一方面，接口方法可以。接口方法要求生产者在返回之前将当前状态信息保存在上下文对象中，以便可以在下次调用时恢复此状态。</p>
                     <p>在本讨论中，术语<span class="italic">表函数</span>指的是<span class="italic">流水线</span>表函数 - 一个表函数，它以迭代的流水线方式返回集合。
                     </p>
                  </div>
               </div><a id="ADDCI4690"></a><a id="ADDCI4688"></a><a id="ADDCI4689"></a><a id="ADDCI4687"></a><div class="props_rev_3"><a id="GUID-A11569C5-BBF7-4838-9AE6-8BAEAEB58265" name="GUID-A11569C5-BBF7-4838-9AE6-8BAEAEB58265"></a><h4 id="ADDCI-GUID-A11569C5-BBF7-4838-9AE6-8BAEAEB58265" class="sect4"><span class="enumeration_section">13.2.3</span>具有REF CURSOR参数的流水线表函数</h4>
                  <div>
                     <p>一个<a id="d38518e483" class="indexterm-anchor"></a> pipelined table函数可以接受常规函数接受的任何参数。接受<code class="codeph">REF CURSOR</code>作为参数的表函数可以用作转换函数。也就是说，它可以使用<code class="codeph">REF CURSOR</code>来获取输入行，对它们执行一些转换，然后将结果输出（使用接口方法或本机PL / SQL方法）。
                     </p>
                     <p>例如，以下代码<code class="codeph">StockPivot</code>绘了定义<code class="codeph">StockPivot</code>函数的声明。此函数将类型的行（ <code class="codeph">Ticker, OpenPrice, ClosePrice</code> ）转换为表格的两行（ <code class="codeph">Ticker, PriceType, Price</code> ）。为行（ <code class="codeph">"ORCL", 41, 42</code> ）调用<code class="codeph">StockPivot</code>生成两行：（ <code class="codeph">"ORCL", "O", 41</code> ）和（ <code class="codeph">"ORCL", "C", 42</code> ）。
                     </p>
                     <p>表函数的输入数据可能来自表<code class="codeph">StockTable</code>等源：</p><pre class="oac_no_warn" dir="ltr">CREATE TABLE StockTable（ticker VARCHAR（4），openprice NUMBER，closeprice NUMBER）;</pre><p>声明在<a href="using-pipelined-and-parallel-table-functions.html#GUID-A11569C5-BBF7-4838-9AE6-8BAEAEB58265__CIHEGADE">例13-5中</a> 。
                     </p>
                     <p><a href="using-pipelined-and-parallel-table-functions.html#GUID-A11569C5-BBF7-4838-9AE6-8BAEAEB58265__CIHIGGCC">例13-6</a>使用<code class="codeph">StockPivot</code>表函数。
                     </p>
                     <p>在前面的查询中，流水线表函数<code class="codeph">StockPivot</code>从<code class="codeph">CURSOR</code>子查询<code class="codeph">SELECT * FROM StockTable</code> <code class="codeph">StockPivot</code>获取行，执行转换，并将结果作为表传递回用户。该函数为每个输入行生成两个输出行（集合元素）。
                     </p>
                     <p>请注意，当<code class="codeph">CURSOR</code>子查询从SQL传递到<code class="codeph">REF CURSOR</code>函数参数时，如前面的示例所示，当函数开始执行时，引用的游标将打开。
                     </p>
                     <div class="section">
                        <p>另请注意，基于表函数的<code class="codeph">REF CURSOR</code>变量不允许使用游标操作： <code class="codeph">SELECT FOR UPDATE</code>和<code class="codeph">WHERE CURRENT OF</code> 。</p>
                     </div>
                     <!-- class="section" -->
                     <div class="section">
                        <div class="infoboxnotealso" id="GUID-A11569C5-BBF7-4838-9AE6-8BAEAEB58265__GUID-1CB8B210-E43C-4EF3-9103-7979E2F93286">
                           <p class="notep1">也可以看看：</p>
                           <p><a href="example-for-pipelined-table-functions-interface-approach.html#GUID-B4BE4F35-B893-45D6-B8B4-235E23F80C6B">流水线表函数：接口方法</a>使用接口方法在C和Java中完整实现此表函数的<a href="example-for-pipelined-table-functions-interface-approach.html#GUID-B4BE4F35-B893-45D6-B8B4-235E23F80C6B">示例</a> 。
                           </p>
                        </div>
                     </div>
                     <!-- class="section" -->
                     <div class="example" id="GUID-A11569C5-BBF7-4838-9AE6-8BAEAEB58265__CIHEGADE">
                        <p class="titleinexample">示例13-5使用REF CURSOR参数声明流水线表函数</p><pre class="oac_no_warn" dir="ltr">- 为表函数的输出集合创建类型 - 和集合元素CREATE TYPE TickerType AS OBJECT（ticker VARCHAR2（4），PriceType VARCHAR2（1），price NUMBER）; CREATE TYPE TickerTypeSet AS TABLE OF TickerType; - 定义引用游标类型CREATE PACKAGE refcur_pkg IS TYPE refcur_t IS REF CURSOR RETURN StockTable％ROWTYPE; END refcur_pkg; /  - 创建表函数CREATE FUNCTION StockPivot（p refcur_pkg.refcur_t）RETURN TickerTypeSet PIPELINED ...; /</pre></div>
                     <!-- class="example" -->
                     <div class="example" id="GUID-A11569C5-BBF7-4838-9AE6-8BAEAEB58265__CIHIGGCC">
                        <p class="titleinexample">例13-6使用具有REF CURSOR参数的流水线表函数</p><pre class="oac_no_warn" dir="ltr">SELECT * FROM TABLE（StockPivot（CURSOR（SELECT * FROM StockTable）））;</pre></div>
                     <!-- class="example" -->
                  </div>
               </div><a id="ADDCI4691"></a><div class="props_rev_3"><a id="GUID-15ED880C-113D-4B44-8732-D70A0AAAD405" name="GUID-15ED880C-113D-4B44-8732-D70A0AAAD405"></a><h4 id="ADDCI-GUID-15ED880C-113D-4B44-8732-D70A0AAAD405" class="sect4"><span class="enumeration_section">13.2.4</span>表函数的并行执行</h4>
                  <div>
                     <p>同<a id="d38518e639" class="indexterm-anchor"></a>并行执行出现在<code class="codeph">SELECT</code>列表中的函数，该函数的执行被推送到多个从属扫描进程并由其执行。这些都在函数输入数据的一段上执行函数。
                     </p>
                     <p>例如，查询</p><pre class="oac_no_warn" dir="ltr">SELECT f（col1）FROM选项卡;</pre><p>如果<code class="codeph">f</code>是纯函数，则并行化。从属扫描过程执行的SQL类似于：</p><pre class="oac_no_warn" dir="ltr">SELECT f（col1）FROM tab WHERE ROWID BETWEEN：b1 AND：b2;</pre><p>每个从属扫描都在一系列rowid上运行，并将函数<code class="codeph">f</code>应用于每个包含的行。然后通过扫描过程执行函数<code class="codeph">f</code> ;它不是独立运行的。
                     </p>
                     <p>与<code class="codeph">SELECT</code>列表中出现的函数不同，在<code class="codeph">FROM</code>子句中调用表函数并返回集合。这会影响表函数输入数据在从属扫描之间进行分区的方式，因为分区方法必须适合表函数执行的操作。（例如， <code class="codeph">ORDER BY</code>操作要求输入进行范围分区，而<code class="codeph">GROUP BY</code>操作要求输入进行散列分区。）
                     </p>
                     <p>表函数本身在其声明中指定适合它的分区方法，如<span class="q">“ <a href="using-pipelined-and-parallel-table-functions.html#GUID-01F8C3F7-9D0D-41A8-806E-CDF6CD2A88B0">输入数据分区</a> ”中所述</span> 。然后，该功能以两阶段操作执行。首先，一组从属进程按照函数声明中的指示对数据进行分区;然后第二组从属扫描在分区数据上并行执行表函数。以下查询中的表函数具有<code class="codeph">REF CURSOR</code>参数：</p><pre class="oac_no_warn" dir="ltr">SELECT * FROM TABLE（f（CURSOR（SELECT * FROM tab）））;</pre><p>扫描由一组从属进程执行，这些从属进程将行（基于函数声明中指定的分区方法）重新分配给实际并行执行函数<code class="codeph">f</code>的第二组从属进程。
                     </p>
                  </div>
               </div>
            </div><a id="ADDCI4692"></a><div class="props_rev_3"><a id="GUID-6785018C-8D7E-453B-A6D0-843648118EA6" name="GUID-6785018C-8D7E-453B-A6D0-843648118EA6"></a><h3 id="ADDCI-GUID-6785018C-8D7E-453B-A6D0-843648118EA6" class="sect3"><span class="enumeration_section">13.3</span>流水线表功能</h3>
               <div>
                  <p>考虑实现流水线表函数所涉及的问题。</p>
               </div><a id="ADDCI4693"></a><div class="props_rev_3"><a id="GUID-B322B116-1D3D-4E5B-9625-2B31189589AF" name="GUID-B322B116-1D3D-4E5B-9625-2B31189589AF"></a><h4 id="ADDCI-GUID-B322B116-1D3D-4E5B-9625-2B31189589AF" class="sect4"><span class="enumeration_section">13.3.1</span>流水线表函数的实现选择</h4>
                  <div>
                     <p>如前所述，支持两种方法来实施<a id="d38518e808" class="indexterm-anchor"></a>流水线表函数：接口方法和PL / SQL方法。
                     </p>
                     <p>接口方法要求用户提供实现预定义Oracle接口的类型，该接口包括start，fetch和close操作。创建表函数时，该类型与表函数相关联。在查询执行期间，重复调用<code class="codeph">fetch</code>方法以迭代检索结果。使用接口方法，与表函数关联的实现类型的方法可以用任何支持的内部或外部语言（包括PL / SQL，C / C ++和Java）实现。
                     </p>
                     <p>使用PL / SQL方法，单个PL / SQL函数包含一个特殊指令，用于从函数中输出结果（集合的单个元素），而不是将整个集合作为单个值返回。原生PL / SQL方法实现起来比较简单，因为它只需要编写一个PL / SQL函数。</p>
                     <p>用于实现流水线表函数的方法不会影响它们的使用方式。无论用于实现它们的方法如何，流水线表函数都以完全相同的方式用于SQL语句中。</p>
                  </div>
               </div><a id="ADDCI4695"></a><a id="ADDCI4696"></a><a id="ADDCI4694"></a><div class="props_rev_3"><a id="GUID-E82D6DF1-721B-401C-8BF6-5ECD068FAE67" name="GUID-E82D6DF1-721B-401C-8BF6-5ECD068FAE67"></a><h4 id="ADDCI-GUID-E82D6DF1-721B-401C-8BF6-5ECD068FAE67" class="sect4"><span class="enumeration_section">13.3.2</span>声明流水线表函数</h4>
                  <div>
                     <div class="section">
                        <p>您可以通过指定<code class="codeph">PIPELINED</code>关键字来声明管道化表函数。此关键字表示该函数迭代地返回行。流水线表函数的返回类型必须是集合类型（嵌套<code class="codeph">table</code>或<code class="codeph">varray</code> ）。
                        </p>
                        <p><a href="using-pipelined-and-parallel-table-functions.html#GUID-E82D6DF1-721B-401C-8BF6-5ECD068FAE67__CIHCGIAE">例13-7</a>显示了使用接口方法实现的流水线表函数的声明。对于功能的接口程序<code class="codeph">GetBooks</code>和<code class="codeph">StockPivot</code>已经在实施的类型<code class="codeph">BookMethods</code>和<code class="codeph">StockPivotImpl</code>分别。
                        </p>
                        <p><a href="using-pipelined-and-parallel-table-functions.html#GUID-E82D6DF1-721B-401C-8BF6-5ECD068FAE67__CIHEIAEC">例13-8</a>显示了使用本机PL / SQL方法实现的相同表函数的声明。
                        </p>
                     </div>
                     <!-- class="section" -->
                     <div class="example" id="GUID-E82D6DF1-721B-401C-8BF6-5ECD068FAE67__CIHCGIAE">
                        <p class="titleinexample">例13-7为接口方法声明流水线表函数</p><pre class="oac_no_warn" dir="ltr">创建功能GetBooks（cat CLOB）返回BookSet_t使用BookMethods进行流水线操作; CREATE FUNCTION StockPivot（p refcur_pkg.refcur_t）RETURN TickerTypeSet PIPELINED使用StockPivotImpl;</pre></div>
                     <!-- class="example" -->
                     <div class="example" id="GUID-E82D6DF1-721B-401C-8BF6-5ECD068FAE67__CIHEIAEC">
                        <p class="titleinexample">示例13-8为本机PL / SQL方法声明流水线表函数</p><pre class="oac_no_warn" dir="ltr">创建功能GetBooks（cat CLOB）RETURN BookSet_t <span class="bold">PIPELINED IS</span> ...; CREATE FUNCTION StockPivot（p refcur_pkg.refcur_t）RETURN TickerTypeSet <span class="bold">PIPELINED IS ...</span>;</pre></div>
                     <!-- class="example" -->
                  </div>
               </div><a id="ADDCI4698"></a><a id="ADDCI4697"></a><div class="props_rev_3"><a id="GUID-708EEC7E-7DCF-478C-9AB1-A630446B708D" name="GUID-708EEC7E-7DCF-478C-9AB1-A630446B708D"></a><h4 id="ADDCI-GUID-708EEC7E-7DCF-478C-9AB1-A630446B708D" class="sect4"><span class="enumeration_section">13.3.3</span>实现本机PL / SQL方法</h4>
                  <div>
                     <div class="section">
                        <p>在PL / SQL中， <code class="codeph">PIPE ROW</code>语句使表函数管道连续并继续处理。该语句使PL / SQL表函数能够在生成后立即返回行。这在<a href="using-pipelined-and-parallel-table-functions.html#GUID-708EEC7E-7DCF-478C-9AB1-A630446B708D__CIHDGJAF">实施例13-9中说明</a> 。出于性能原因，PL / SQL运行时系统会批量向行提供行。
                        </p>
                        <p>在<a href="using-pipelined-and-parallel-table-functions.html#GUID-708EEC7E-7DCF-478C-9AB1-A630446B708D__CIHDGJAF">例13-9中</a> ， <code class="codeph">PIPE ROW(out_rec)</code>语句将数据从PL / SQL表函数中移出。
                        </p>
                        <p><code class="codeph">PIPE ROW</code>语句只能在流水线表函数体中使用;如果在其他任何地方使用它，则会引发错误。对于不返回任何行的流水线表函数，可以省略<code class="codeph">PIPE ROW</code>语句。
                        </p>
                        <p>流水线表函数必须具有不返回值的<code class="codeph">RETURN</code>语句。<code class="codeph">RETURN</code>语句将控制权传递回使用者，并确保下一次获取获取<code class="codeph">NO_DATA_FOUND</code>异常。
                        </p>
                     </div>
                     <!-- class="section" -->
                     <div class="example" id="GUID-708EEC7E-7DCF-478C-9AB1-A630446B708D__CIHDGJAF">
                        <p class="titleinexample">示例13-9为本机PL / SQL方法实现流水线表函数</p><pre class="oac_no_warn" dir="ltr">CREATE FUNCTION StockPivot（p refcur_pkg.refcur_t）RETURN TickerTypeSet PIPELINED IS out_rec TickerType：= TickerType（NULL，NULL，NULL）; in_rec p％ROWTYPE; BEGIN LOOP FETCH p INTO in_rec; p％NOTFOUND时退出; - 第一行out_rec.ticker：= in_rec。新浪体育讯北京时间; out_rec。PriceType：='O'; out_rec.price：= in_rec。OpenPrice; PIPE ROW（out_rec）; - 第二行out_rec。PriceType：='C'; out_rec。价格：= in_rec。ClosePrice; PIPE ROW（out_rec）;结束循环;关闭p;返回;结束; /</pre></div>
                     <!-- class="example" -->
                  </div>
               </div><a id="ADDCI4700"></a><a id="ADDCI4699"></a><div class="props_rev_3"><a id="GUID-FDB7769F-62F1-4C8E-8356-70629FACDE0A" name="GUID-FDB7769F-62F1-4C8E-8356-70629FACDE0A"></a><h4 id="ADDCI-GUID-FDB7769F-62F1-4C8E-8356-70629FACDE0A" class="sect4"><span class="enumeration_section">13.3.4</span> PL / SQL表函数之间的流水线操作</h4>
                  <div>
                     <div class="section">
                        <p>通过串行执行，结果是<a id="d38518e1074" class="indexterm-anchor"></a>使用类似于协同例程执行的方法从一个PL / SQL表函数流水线化到另一个PL / SQL表函数。<a href="using-pipelined-and-parallel-table-functions.html#GUID-FDB7769F-62F1-4C8E-8356-70629FACDE0A__CIHBGDJD">例13-10</a>管道结果从函数<code class="codeph">g</code>到函数<code class="codeph">f</code> 。
                        </p>
                        <p>并行执行的工作方式类似，只是每个函数在不同的进程或进程集中执行。</p>
                     </div>
                     <!-- class="section" -->
                     <div class="example" id="GUID-FDB7769F-62F1-4C8E-8356-70629FACDE0A__CIHBGDJD">
                        <p class="titleinexample">示例13-10将函数结果从一个函数移植到另一个函数</p><pre class="oac_no_warn" dir="ltr">SELECT * FROM TABLE（f（CURSOR（SELECT * FROM TABLE（g（）））））;</pre></div>
                     <!-- class="example" -->
                  </div>
               </div><a id="ADDCI4701"></a><div class="props_rev_3"><a id="GUID-B3132BF8-26CC-4DE7-A778-92D558BD59EA" name="GUID-B3132BF8-26CC-4DE7-A778-92D558BD59EA"></a><h4 id="ADDCI-GUID-B3132BF8-26CC-4DE7-A778-92D558BD59EA" class="sect4"><span class="enumeration_section">13.3.5</span>将PIPE ROW与AUTONOMOUS_TRANSACTION结合起来</h4>
                  <div>
                     <p>因为表函数在生成行时来回传递控制来调用例程，所以对表函数和<code class="codeph">PRAGMA AUTONOMOUS_TRANSACTION</code>的组合存在限制。如果表函数是自治事务的一部分，则它必须在每个<code class="codeph">PIPE ROW</code>语句之前执行<code class="codeph">COMMIT</code>或<code class="codeph">ROLLBACK</code> ，以避免调用子程序中的错误。
                     </p>
                  </div>
               </div><a id="ADDCI4702"></a><div class="props_rev_3"><a id="GUID-43335D83-F0E2-4ECC-91D6-DB2C639399D6" name="GUID-43335D83-F0E2-4ECC-91D6-DB2C639399D6"></a><h4 id="ADDCI-GUID-43335D83-F0E2-4ECC-91D6-DB2C639399D6" class="sect4"><span class="enumeration_section">13.3.6</span>实现接口方法</h4>
                  <div>
                     <div class="section">
                        <p>要使用接口方法，必须定义实现<code class="codeph">ODCITable</code>接口的实现类型。此接口由start，fetch和close例程组成，其签名由Oracle指定，并且您实现为该类型的方法。
                        </p>
                        <p>Oracle调用方法在执行包含表函数的查询时执行以下步骤：</p>
                     </div>
                     <!-- class="section" -->
                     <ol>
                        <li><span>首先使用<code class="codeph">ODCITableStart()</code>函数初始化扫描上下文参数。</span></li>
                        <li><span>获取以生成结果集合中的行的子集。必要时多次调用<code class="codeph">ODCITableFetch()</code>方法以返回整个集合。</span></li>
                        <li><span>在最后一个<code class="codeph">ODCITableFetch()</code>之后使用<code class="codeph">ODCITableClose()</code>关闭并清理（释放内存等<code class="codeph">ODCITableFetch()</code> 。</span></li>
                     </ol>
                     <div class="section">
                        <p><code class="codeph">ODCITable</code>接口还定义了两个可选的例程， <code class="codeph">ODCITablePrepare()</code>和<code class="codeph">ODCITableDescribe()</code> ，它们在编译时调用：</p>
                        <ul style="list-style-type:disc">
                           <li>
                              <p>在无法以静态方式定义的情况下， <code class="codeph">ODCITableDescribe()</code>确定表函数返回的数据类型的结构。
                              </p>
                           </li>
                           <li>
                              <p><code class="codeph">ODCITablePrepare()</code>初始化扫描上下文参数。如果实现此方法，则将其准备的扫描上下文传递给<code class="codeph">ODCITableStart()</code>例程，并在表函数的重新启动之间维护上下文。它还提供投影信息并支持瞬态匿名类型的返回。
                              </p>
                           </li>
                        </ul>
                        <div class="infoboxnotealso" id="GUID-43335D83-F0E2-4ECC-91D6-DB2C639399D6__GUID-5123E535-52DC-4251-8D48-9A928A075966">
                           <p class="notep1">也可以看看：</p>
                           <ul style="list-style-type:disc">
                              <li>
                                 <p><a href="pipelined-and-parallel-table-functions.html#GUID-9814FCDE-05BE-4F25-9861-FDC640F43E5C">ODCITableClose（）</a></p>
                              </li>
                              <li>
                                 <p><a href="pipelined-and-parallel-table-functions.html#GUID-C45BF680-3EBE-4E53-8A08-193ED22F61C8">ODCITableDescribe（）</a></p>
                              </li>
                              <li>
                                 <p><a href="pipelined-and-parallel-table-functions.html#GUID-54F5311D-8708-44AB-85A9-9CFE3EE79C76">ODCITableFetch（）</a></p>
                              </li>
                              <li>
                                 <p><a href="pipelined-and-parallel-table-functions.html#GUID-6022AD7F-BDE5-4D42-B8F9-D2B18AB6AD84">ODCITablePrepare（）</a></p>
                              </li>
                              <li>
                                 <p><a href="pipelined-and-parallel-table-functions.html#GUID-7C674A4F-7145-480E-883D-00C609B64DA0">ODCITableStart（）</a></p>
                              </li>
                           </ul>
                        </div>
                     </div>
                     <!-- class="section" -->
                  </div><a id="ADDCI4703"></a><div class="props_rev_3"><a id="GUID-93026BCE-7C11-4333-AA7F-19120ADFA135" name="GUID-93026BCE-7C11-4333-AA7F-19120ADFA135"></a><h5 id="ADDCI-GUID-93026BCE-7C11-4333-AA7F-19120ADFA135" class="sect5"><span class="enumeration_section">13.3.6.1</span>扫描上下文</h5>
                     <div>
                        <p>对于生成下一组行的fetch方法，表函数必须能够在接口例程的连续调用之间维护上下文以获取另一组行。此上下文称为扫描上下文，由实现类型的属性定义。表函数通过在实现类型的对象实例中对其进行建模来保留扫描上下文。</p>
                     </div>
                  </div><a id="ADDCI4704"></a><div class="props_rev_3"><a id="GUID-B9109CC7-E2BD-48EB-AF91-C6ABEF0BB855" name="GUID-B9109CC7-E2BD-48EB-AF91-C6ABEF0BB855"></a><h5 id="ADDCI-GUID-B9109CC7-E2BD-48EB-AF91-C6ABEF0BB855" class="sect5"><span class="enumeration_section">13.3.6.2</span>启动例程</h5>
                     <div>
                        <p>启动例程<code class="codeph">ODCITableStart()</code>是第一个被调用以开始从表函数中检索行的例程。此例程通常执行扫描所需的设置，创建扫描上下文（作为对象实例<code class="codeph">sctx</code> ）并将其返回给Oracle。但是，如果实现了<code class="codeph">ODCITablePrepare()</code> ，它将创建扫描上下文，然后将其传递给<code class="codeph">ODCITableStart()</code>例程。用户在<code class="codeph">SELECT</code>语句中指定的表函数的参数作为参数传递给此例程。
                        </p>
                        <p>请注意，表函数的任何<code class="codeph">REF CURSOR</code>参数必须在<code class="codeph">ODCITableStart()</code>的声明中声明为<code class="codeph">SYS_REFCURSOR</code>类型。普通的<code class="codeph">REF CURSOR</code>类型不能用作<code class="codeph">ODCITableStart()</code>形式参数类型。普通的<code class="codeph">REF CURSOR</code>类型只能在包中声明，并且包中定义的类型不能在类型方法中用作形式参数类型。要在<code class="codeph">ODCITableStart()</code>使用<code class="codeph">REF CURSOR</code>类型，必须使用系统定义的<code class="codeph">SYS_REFCURSOR</code>类型。
                        </p>
                        <div class="infoboxnotealso" id="GUID-B9109CC7-E2BD-48EB-AF91-C6ABEF0BB855__GUID-57C748B6-0D15-4C31-A757-54BC548E4787">
                           <p class="notep1">也可以看看：</p>
                           <ul style="list-style-type:disc">
                              <li>
                                 <p><a href="pipelined-and-parallel-table-functions.html#GUID-6022AD7F-BDE5-4D42-B8F9-D2B18AB6AD84">ODCITablePrepare（）</a></p>
                              </li>
                              <li>
                                 <p><a href="pipelined-and-parallel-table-functions.html#GUID-7C674A4F-7145-480E-883D-00C609B64DA0">ODCITableStart（）</a></p>
                              </li>
                           </ul>
                        </div>
                     </div>
                  </div><a id="ADDCI4705"></a><div class="props_rev_3"><a id="GUID-29D181AC-ECD0-4F68-8AE3-E4365CF3AD0C" name="GUID-29D181AC-ECD0-4F68-8AE3-E4365CF3AD0C"></a><h5 id="ADDCI-GUID-29D181AC-ECD0-4F68-8AE3-E4365CF3AD0C" class="sect5"><span class="enumeration_section">13.3.6.3</span>获取例程</h5>
                     <div>
                        <p>Oracle使用一次或多次调用获取例程<code class="codeph">ODCITableFetch()</code>来检索表函数结果集中的所有行。扫描上下文作为参数传入。此例程返回一行或多行的下一个子集。
                        </p>
                        <p>Oracle重复调用fetch例程，直到table函数返回了所有行。在每次调用<code class="codeph">ODCITableFetch()</code>返回更多行会减少必须进行的提取调用次数，从而提高性能。table函数应返回一个null集合，以指示已返回所有行。
                        </p>
                        <p><code class="codeph">nrows</code>参数指示满足当前OCI调用所需的行数。例如，如果当前OCI调用是请求<code class="codeph">100</code>行的<code class="codeph">ODCITableFetch()</code> ，并且已返回<code class="codeph">20</code>行，则<code class="codeph">nrows</code>参数等于<code class="codeph">80</code> 。允许获取函数返回不同数量的行。此参数的主要目的是防止<code class="codeph">ODCITableFetch()</code>返回比实际需要更多的行。如果<code class="codeph">ODCITableFetch()</code>返回的行数多于此参数的值，则会在后续的<code class="codeph">ODCITableFetch()</code>调用中缓存并返回这些行，或者如果在获取所有OCI语句句柄之前将其关闭，则会丢弃这些行。
                        </p>
                        <div class="infoboxnotealso" id="GUID-29D181AC-ECD0-4F68-8AE3-E4365CF3AD0C__GUID-6CD06611-EB41-4606-9DE5-D5FE651A88C3">
                           <p class="notep1">也可以看看：</p>
                           <p><a href="pipelined-and-parallel-table-functions.html#GUID-54F5311D-8708-44AB-85A9-9CFE3EE79C76">ODCITableFetch（）</a></p>
                        </div>
                     </div>
                  </div><a id="ADDCI4707"></a><a id="ADDCI4706"></a><div class="props_rev_3"><a id="GUID-A8636931-4B13-4D68-8289-3F29D1B687D7" name="GUID-A8636931-4B13-4D68-8289-3F29D1B687D7"></a><h5 id="ADDCI-GUID-A8636931-4B13-4D68-8289-3F29D1B687D7" class="sect5"><span class="enumeration_section">13.3.6.4</span>关闭例程</h5>
                     <div>
                        <p>在最后一次提取调用之后，Oracle会调用关闭例程<a href="pipelined-and-parallel-table-functions.html#GUID-9814FCDE-05BE-4F25-9861-FDC640F43E5C">ODCITableClose（）</a> 。扫描上下文作为参数传入。该例程执行必要的清理操作。
                        </p>
                        <div class="figure" id="GUID-A8636931-4B13-4D68-8289-3F29D1B687D7__GUID-517CBAB1-37B7-42BA-95D7-38C2D04D333F">
                           <p class="titleinfigure">图13-3表功能行源执行流程图</p><img src="img/addci046.gif" alt="下面是图13-3的描述" title="下面是图13-3的描述" longdesc="img_text/addci046.html"><br><a href="img_text/addci046.html">“图13-3表函数行执行流程图”的说明</a></div>
                        <!-- class="figure" -->
                     </div>
                  </div><a id="ADDCI4709"></a><a id="ADDCI4710"></a><a id="ADDCI4711"></a><a id="ADDCI4708"></a><div class="props_rev_3"><a id="GUID-A55E0878-7F31-4317-B599-3188035020B7" name="GUID-A55E0878-7F31-4317-B599-3188035020B7"></a><h5 id="ADDCI-GUID-A55E0878-7F31-4317-B599-3188035020B7" class="sect5"><span class="enumeration_section">13.3.6.5</span>描述返回的数据结构;描述方法</h5>
                     <div>
                        <p>有时，无法静态地从表函数定义返回类型的结构。如果行的形状在不同的查询中不同，则可能取决于调用表函数的实际参数。可以声明这样的表函数返回<code class="codeph">AnyDataSet</code> 。<code class="codeph">AnyDataSet</code>是一种通用集合类型。它可用于对任何集合（任何元素类型）进行建模，并具有一组相关的API（PL / SQL和C），使您能够构造<code class="codeph">AnyDataSet</code>实例并访问元素。
                        </p>
                        <p>以下示例显示声明为返回<code class="codeph">AnyDataSet</code>集合的表函数，该集合的结构在函数创建时未得到修复：</p><pre class="oac_no_warn" dir="ltr">创建函数AnyDocuments（VARCHAR2）使用DocumentMethods返回任何数据集;</pre><p>当格式取决于表函数的实际参数时，可以实现<code class="codeph">ODCITableDescribe()</code>例程来确定结果集合中元素的格式。Oracle在查询编译时调用<code class="codeph">ODCITableDescribe()</code>来检索特定类型信息。通常，例程使用用户参数来确定返回行的形状。返回集合中元素的格式通过返回<code class="codeph">AnyType</code>实例传递给Oracle。
                        </p>
                        <p><code class="codeph">AnyType</code>实例指定特定查询的返回行的实际结构。与<code class="codeph">AnyDataSet</code>一样， <code class="codeph">AnyType</code>具有一组关联的PL / SQL和C接口，用于构造和访问元数据信息。
                        </p>
                        <p><a href="using-pipelined-and-parallel-table-functions.html#GUID-A55E0878-7F31-4317-B599-3188035020B7__CIHCGJII">例13-11中</a>的查询，对于<code class="codeph">AnyDocuments</code>函数，返回书籍或杂志上的信息。
                        </p>
                        <p><a href="using-pipelined-and-parallel-table-functions.html#GUID-A55E0878-7F31-4317-B599-3188035020B7__CIHCEHGC">示例13-12</a>是<code class="codeph">ODCITableDescribe()</code>方法的实现，该方法查询指定位置的XML文档的DTD以返回相应的<code class="codeph">AnyType</code>值，无论是书籍还是杂志。通过使用字段名称和数据类型信息调用构造函数API来构造<code class="codeph">AnyType</code>实例。
                        </p>
                        <p>当Oracle调用<code class="codeph">ODCITableDescribe()</code> ，它使用<code class="codeph">AnyType</code> <code class="codeph">OUT</code>参数中返回的类型信息来解析命令行中的引用，例如对<code class="codeph">x.的引用<code class="codeph">x.<a href="using-pipelined-and-parallel-table-functions.html#GUID-A55E0878-7F31-4317-B599-3188035020B7__CIHCEHGC">例13-12中的</a> Abstract</code>属性。仅当返回的类型是命名类型且因此具有命名属性时，此功能才适用。
                        </p>
                        <p><code class="codeph">ODCITableDescribe()</code>另一个特性是它能够在执行<code class="codeph">SELECT *</code>查询时描述<code class="codeph">SELECT</code>列表参数，例如使用OCI接口。检索到的信息反映了<code class="codeph">ODCITableDescribe()</code>返回的每个顶级属性的一个<code class="codeph">SELECT</code>列表项。
                        </p>
                        <p>因为在编译时调用<code class="codeph">ODCITableDescribe()</code>方法，所以表函数应至少有一个在编译时具有值的参数，如常量。通过使用具有不同参数的表函数，您可以从函数中获得不同的返回类型，如<a href="using-pipelined-and-parallel-table-functions.html#GUID-A55E0878-7F31-4317-B599-3188035020B7__CIHCHGAB">例13-13所示</a> 。
                        </p>
                        <p>仅当使用接口方法实现表函数时， <code class="codeph">ODCITableDescribe()</code>功能才可用。返回<code class="codeph">ANYDATASET</code>的表函数的本机PL / SQL实现返回其结构对服务器不透明的行。
                        </p>
                        <div class="example" id="GUID-A55E0878-7F31-4317-B599-3188035020B7__CIHCGJII">
                           <p class="titleinexample">示例13-11查询AnyType数据</p><pre class="oac_no_warn" dir="ltr">SELECT * FROM TABLE（AnyDocuments（'http：//.../documents.xml'））x WHERE x。摘要像'％internet％';</pre></div>
                        <!-- class="example" -->
                        <div class="example" id="GUID-A55E0878-7F31-4317-B599-3188035020B7__CIHCEHGC">
                           <p class="titleinexample">示例13-12实现ODCITableDescribe（）方法</p><pre class="oac_no_warn" dir="ltr">CREATE TYPE Mag_t AS OBJECT（名称VARCHAR2（100），发布者VARCHAR2（30），抽象VARCHAR2（1000））;静态功能ODCITableDescribe（rtype OUT ANYTYPE，url VARCHAR2）是BEGIN联系指定的Web服务器并检索文档...检查XML doc schema以确定书籍或杂志......IF书籍THEN rtype = AnyType。AnyTypeGetPersistent（ 'SYS'， 'BOOK_T'）; ELSE rtype = AnyType。AnyTypeGetPersistent（ 'SYS'， 'MAG_T'）;万一;结束;</pre></div>
                        <!-- class="example" -->
                        <div class="example" id="GUID-A55E0878-7F31-4317-B599-3188035020B7__CIHCHGAB">
                           <p class="titleinexample">示例13-13使用返回AnyType的函数</p><pre class="oac_no_warn" dir="ltr">- 发出书籍SELECT x的查询。姓名，x。作者FROM TABLE（AnyDocuments（'Books.xml'））x; - 为杂志SELECT x发出查询。姓名，x。Publisher FROM TABLE（AnyDocuments（'Magazines.xml'））x;</pre></div>
                        <!-- class="example" -->
                        <div class="section">
                           <div class="infoboxnotealso" id="GUID-A55E0878-7F31-4317-B599-3188035020B7__GUID-C49DFFED-0420-4587-AE63-2B5E0688E241">
                              <p class="notep1">也可以看看：</p>
                              <ul style="list-style-type:disc">
                                 <li>
                                    <p><a href="pipelined-and-parallel-table-functions.html#GUID-C45BF680-3EBE-4E53-8A08-193ED22F61C8">ODCITableDescribe（）</a></p>
                                 </li>
                                 <li>
                                    <p><span class="q">“ <a href="using-pipelined-and-parallel-table-functions.html#GUID-7008AB9F-4C2B-4896-AF2D-1AB39910C9A0">Transient和Generic Types</a> ”</span>有关<code class="codeph">AnyDataSet</code>和<code class="codeph">AnyType</code></p>
                                 </li>
                              </ul>
                           </div>
                        </div>
                        <!-- class="section" -->
                     </div>
                  </div><a id="ADDCI4713"></a><a id="ADDCI4712"></a><div class="props_rev_3"><a id="GUID-1F6600B2-073F-444B-AF2C-4F3A760795D7" name="GUID-1F6600B2-073F-444B-AF2C-4F3A760795D7"></a><h5 id="ADDCI-GUID-1F6600B2-073F-444B-AF2C-4F3A760795D7" class="sect5"><span class="enumeration_section">13.3.6.6</span>准备执行查询;准备方法</h5>
                     <div>
                        <p>在查询编译时调用<code class="codeph">ODCITablePrepare()</code> 。它生成并保存信息以减少查询的执行时间。
                        </p>
                        <p>如果未实现<code class="codeph">ODCITablePrepare()</code> ，则<code class="codeph">ODCITableStart()</code>在每次调用时初始化上下文。但是，如果您实现了<code class="codeph">ODCITablePrepare()</code> ，它会初始化扫描上下文，在执行查询时<code class="codeph">ODCITableStart()</code>其传递给<code class="codeph">ODCITableStart()</code> ，从而缩短启动时间。此外，当<code class="codeph">ODCITablePrepare()</code>来实现， <code class="codeph">ODCITableClose()</code>是在查询过程中调用一次，而不是每次都表功能重新启动。这有以下好处：</p>
                        <ul style="list-style-type:disc">
                           <li>
                              <p>它通过减少对<code class="codeph">ODCITableClose()</code>的调用次数来减少执行时间。
                              </p>
                           </li>
                           <li>
                              <p>它允许在表函数重启之间保持扫描上下文。</p>
                           </li>
                        </ul>
                        <p><code class="codeph">ODCITablePrepare()</code>还为表函数提供投影信息。如果没有为返回用户定义类型（UDT）集合的表函数实现<code class="codeph">ODCITablePrepare()</code> ，则表函数必须设置每个元素的UDT的每个属性，因为它无法知道使用了哪些属性。相反，从常规表中选择仅获取所需的列，这在大多数情况下自然更快。但是，如果您实现了<code class="codeph">ODCITablePrepare()</code> ，它可以构建一个属性位置数组，在<code class="codeph">ODCITabFuncInfo</code>类型的参数中记录返回类型信息，并将此信息保存在扫描上下文中，如<a href="using-pipelined-and-parallel-table-functions.html#GUID-1F6600B2-073F-444B-AF2C-4F3A760795D7__CIHEHBAJ">例13-14所述</a> 。
                        </p>
                        <p>实现<code class="codeph">ODCITablePrepare()</code>还允许表函数返回瞬态匿名类型。在查询编译结束时调用<code class="codeph">ODCITablePrepare()</code> ，因此可以传递describe方法构建的表描述符对象（TDO）。describe方法可以构建并返回瞬态匿名TDO。 Oracle会转换此TDO，以便在查询执行期间使用它，并将转换后的TDO传递给<code class="codeph">RetType</code>属性中的prepare方法。如果describe方法返回非匿名类型的TDO，则该TDO与转换后的TDO相同。因此，如果表函数返回：</p>
                        <ul style="list-style-type:disc">
                           <li>
                              <p>作为命名集合类型， <code class="codeph">RetType</code>属性包含此类型的TDO。
                              </p>
                           </li>
                           <li>
                              <p><code class="codeph">AnyDataSet</code>和describe方法返回一个命名类型， <code class="codeph">RetType</code>属性包含命名类型的TDO。
                              </p>
                           </li>
                           <li>
                              <p><code class="codeph">AnyDataSet</code>和describe方法返回匿名类型，Oracle转换此类型， <code class="codeph">RetType</code>包含转换后的TDO。</p>
                           </li>
                        </ul>
                        <div class="example" id="GUID-1F6600B2-073F-444B-AF2C-4F3A760795D7__CIHEHBAJ">
                           <p class="titleinexample">示例13-14构建属性位置数组并将其保存在扫描上下文中</p><pre class="oac_no_warn" dir="ltr">CREATE TYPE SYS.ODCITabFuncInto AS OBJECT（Attrs SYS.ODCINumberList，RetType SYS.AnyType）;</pre><div class="infoboxnotealso" id="GUID-1F6600B2-073F-444B-AF2C-4F3A760795D7__GUID-B39CB605-DA78-4001-9121-266C5F0346C4">
                              <p class="notep1">也可以看看：</p>
                              <ul style="list-style-type:disc">
                                 <li>
                                    <p><a href="pipelined-and-parallel-table-functions.html#GUID-9814FCDE-05BE-4F25-9861-FDC640F43E5C">ODCITableClose（）</a></p>
                                 </li>
                                 <li>
                                    <p><a href="pipelined-and-parallel-table-functions.html#GUID-6022AD7F-BDE5-4D42-B8F9-D2B18AB6AD84">ODCITablePrepare（）</a></p>
                                 </li>
                                 <li>
                                    <p><a href="pipelined-and-parallel-table-functions.html#GUID-7C674A4F-7145-480E-883D-00C609B64DA0">ODCITableStart（）</a></p>
                                 </li>
                              </ul>
                           </div>
                        </div>
                        <!-- class="example" -->
                     </div>
                  </div>
               </div><a id="ADDCI4715"></a><a id="ADDCI4714"></a><div class="props_rev_3"><a id="GUID-127A407D-4EDC-4860-B3CA-2B978E153FF1" name="GUID-127A407D-4EDC-4860-B3CA-2B978E153FF1"></a><h4 id="ADDCI-GUID-127A407D-4EDC-4860-B3CA-2B978E153FF1" class="sect4"><span class="enumeration_section">13.3.7</span>查询表功能</h4>
                  <div>
                     <div class="section">
                        <p>流水线<a id="d38518e2038" class="indexterm-anchor"></a>表函数在<code class="codeph">SELECT</code>语句的<code class="codeph">FROM</code>子句中独立于实现使用，无论是在本机PL / SQL中还是通过接口方法。Oracle会从表函数实现中迭代检索结果行，如<a href="using-pipelined-and-parallel-table-functions.html#GUID-127A407D-4EDC-4860-B3CA-2B978E153FF1__CIHJCECB">例13-15所示</a> 。
                        </p>
                        <p>但是，如果表函数的输出仅由作为参数传递给它的值确定，那么函数总是为传入的每个相应值组合生成完全相同的结果值，则可以声明函数<code class="codeph">DETERMINISTIC</code>和Oracle自动为它缓冲行。但请注意，数据库无法知道标记为<code class="codeph">DETERMINISTIC</code>的函数是否确实是<code class="codeph">DETERMINISTIC</code> ，如果不是，则结果是不可预测的。
                        </p>
                     </div>
                     <!-- class="section" -->
                     <div class="example" id="GUID-127A407D-4EDC-4860-B3CA-2B978E153FF1__CIHJCECB">
                        <p class="titleinexample">示例13-15使用表函数迭代检索行</p><pre class="oac_no_warn" dir="ltr">选择x。Ticker，x。价格FROM TABLE（StockPivot（CURSOR（SELECT * FROM StockTable）））x WHERE x。PriceType = 'C';</pre></div>
                     <!-- class="example" -->
                  </div><a id="ADDCI4717"></a><a id="ADDCI4716"></a><div class="props_rev_3"><a id="GUID-6197E7B3-8E7C-4C0E-BCC4-1C02C9F7BA9C" name="GUID-6197E7B3-8E7C-4C0E-BCC4-1C02C9F7BA9C"></a><h5 id="ADDCI-GUID-6197E7B3-8E7C-4C0E-BCC4-1C02C9F7BA9C" class="sect5"><span class="enumeration_section">13.3.7.1</span>对表函数实现多次调用</h5>
                     <div>
                        <div class="section">
                           <p>在同一查询或单独查询中多次调用表函数会导致底层实现的多次执行。也就是说，通常，没有行的缓冲或重用，如<a href="using-pipelined-and-parallel-table-functions.html#GUID-6197E7B3-8E7C-4C0E-BCC4-1C02C9F7BA9C__CIHJAEHD">例13-16所示</a> 。
                           </p>
                        </div>
                        <!-- class="section" -->
                        <div class="example" id="GUID-6197E7B3-8E7C-4C0E-BCC4-1C02C9F7BA9C__CIHJAEHD">
                           <p class="titleinexample">示例13-16使用表函数的多个调用</p><pre class="oac_no_warn" dir="ltr">SELECT * FROM TABLE（f（...））t1，TABLE（f（...））t2 WHERE t1.id = t2.id; SELECT * FROM TABLE（f（））; SELECT * FROM TABLE（f（））;</pre></div>
                        <!-- class="example" -->
                     </div>
                  </div><a id="ADDCI4719"></a><a id="ADDCI4720"></a><a id="ADDCI4721"></a><a id="ADDCI4718"></a><div class="props_rev_3"><a id="GUID-9AC506C7-030B-495F-A910-51640E2C9CEE" name="GUID-9AC506C7-030B-495F-A910-51640E2C9CEE"></a><h5 id="ADDCI-GUID-9AC506C7-030B-495F-A910-51640E2C9CEE" class="sect5"><span class="enumeration_section">13.3.7.2</span>使用PL / SQL REF CURSOR变量</h5>
                     <div>
                        <div class="section">
                           <p>可以为表函数的查询定义PL / SQL <code class="codeph">REF CURSOR</code>变量，如<a href="using-pipelined-and-parallel-table-functions.html#GUID-9AC506C7-030B-495F-A910-51640E2C9CEE__CIHJBDCA">例13-17所示</a> 。
                           </p>
                           <p>表函数上的游标与普通游标具有相同的获取语义。基于表函数的<code class="codeph">REF CURSOR</code>赋值没有特殊语义。
                           </p>
                           <p>但是，SQL优化器不会跨PL / SQL语句进行优化;因此， <a href="using-pipelined-and-parallel-table-functions.html#GUID-9AC506C7-030B-495F-A910-51640E2C9CEE__CIHICDCB">实施例13-19</a>比<a href="using-pipelined-and-parallel-table-functions.html#GUID-9AC506C7-030B-495F-A910-51640E2C9CEE__CIHEAJDG">实施例13-18</a>运行得更好。
                           </p>
                           <p>此外， <a href="using-pipelined-and-parallel-table-functions.html#GUID-9AC506C7-030B-495F-A910-51640E2C9CEE__CIHEAJDG">示例13-18</a>由于与执行两个SQL语句相关的开销而较慢，并且因为它没有利用通过在两个函数之间流水线化结果实现的效率，如<a href="using-pipelined-and-parallel-table-functions.html#GUID-9AC506C7-030B-495F-A910-51640E2C9CEE__CIHICDCB">例13-19</a>所做的那样。
                           </p>
                        </div>
                        <!-- class="section" -->
                        <div class="example" id="GUID-9AC506C7-030B-495F-A910-51640E2C9CEE__CIHJBDCA">
                           <p class="titleinexample">示例13-17为表函数查询定义REF CURSOR变量</p><pre class="oac_no_warn" dir="ltr">打开c FOR SELECT * FROM TABLE（f（...））;</pre></div>
                        <!-- class="example" -->
                        <div class="example" id="GUID-9AC506C7-030B-495F-A910-51640E2C9CEE__CIHEAJDG">
                           <p class="titleinexample">例13-18使用REF CURSOR变量</p><pre class="oac_no_warn" dir="ltr">BEGIN OPEN r FOR SELECT * FROM TABLE（f（CURSOR（SELECT * FROM tab）））; SELECT * BULK COLLECT INTO rec_tab FROM TABLE（g（r））;结束;</pre></div>
                        <!-- class="example" -->
                        <div class="example" id="GUID-9AC506C7-030B-495F-A910-51640E2C9CEE__CIHICDCB">
                           <p class="titleinexample">例13-19更有效地使用REF CURSOR变量</p><pre class="oac_no_warn" dir="ltr">SELECT * FROM TABLE（g（CURSOR（SELECT * FROM TABLE（f（CURSOR（SELECT * FROM tab））））））;</pre></div>
                        <!-- class="example" -->
                     </div>
                  </div>
               </div><a id="ADDCI4723"></a><a id="ADDCI4722"></a><div class="props_rev_3"><a id="GUID-A3F00ED4-7A5A-42CA-A55F-05CCBB7DED3B" name="GUID-A3F00ED4-7A5A-42CA-A55F-05CCBB7DED3B"></a><h4 id="ADDCI-GUID-A3F00ED4-7A5A-42CA-A55F-05CCBB7DED3B" class="sect4"><span class="enumeration_section">13.3.8</span>在表函数内执行DML操作</h4>
                  <div>
                     <div class="section">
                        <p>必须使用自治事务pragma声明表函数，以便函数执行DML语句。该pragma导致函数在不由其他进程共享的自治事务中执行，如<a href="using-pipelined-and-parallel-table-functions.html#GUID-A3F00ED4-7A5A-42CA-A55F-05CCBB7DED3B__CIHIFFDH">例13-20所示</a> 。
                        </p>
                        <p>在并行执行期间，表函数的每个实例都会创建一个独立的事务。</p>
                     </div>
                     <!-- class="section" -->
                     <div class="example" id="GUID-A3F00ED4-7A5A-42CA-A55F-05CCBB7DED3B__CIHIFFDH">
                        <p class="titleinexample">示例13-20使用自治事务Pragma声明表函数</p><pre class="oac_no_warn" dir="ltr">CREATE FUNCTION f（p SYS_REFCURSOR）返回CollType PIPELINED是PRAGMA AUTONOMOUS_TRANSACTION;开始 ...结束;</pre></div>
                     <!-- class="example" -->
                  </div>
               </div><a id="ADDCI4725"></a><a id="ADDCI4726"></a><a id="ADDCI4724"></a><div class="props_rev_3"><a id="GUID-F277FF3E-CA33-4B18-B39C-6286C5A913E7" name="GUID-F277FF3E-CA33-4B18-B39C-6286C5A913E7"></a><h4 id="ADDCI-GUID-F277FF3E-CA33-4B18-B39C-6286C5A913E7" class="sect4"><span class="enumeration_section">13.3.9</span>对表函数执行DML操作</h4>
                  <div>
                     <div class="section">
                        <p>表函数不能是<code class="codeph">UPDATE</code> ， <code class="codeph">INSERT</code>或<code class="codeph">DELETE</code>语句中的目标表。例如，以下语句引发错误：</p><pre class="oac_no_warn" dir="ltr">UPDATE F（CURSOR（SELECT * FROM tab））SET col = value; INSERT INTO f（...）价值观（'任何'，'事物'）;</pre><p>但是，您可以在表函数上创建视图，并使用<code class="codeph">INSTEAD OF</code>触发器对其进行更新，如<a href="using-pipelined-and-parallel-table-functions.html#GUID-F277FF3E-CA33-4B18-B39C-6286C5A913E7__CIHIEICC">例13-21所示</a> 。
                        </p>
                        <p><a href="using-pipelined-and-parallel-table-functions.html#GUID-F277FF3E-CA33-4B18-B39C-6286C5A913E7__CIHDDHDG">例13-22</a>演示了当用户在<code class="codeph">BookTable</code>视图中插入行时如何触发<code class="codeph">INSTEAD OF</code>触发器：
                        </p>
                        <p>可以在基于表函数的视图上为所有DML操作定义<code class="codeph">INSTEAD OF</code>触发器。
                        </p>
                     </div>
                     <!-- class="section" -->
                     <div class="example" id="GUID-F277FF3E-CA33-4B18-B39C-6286C5A913E7__CIHIEICC">
                        <p class="titleinexample">示例13-21在表上创建视图</p><pre class="oac_no_warn" dir="ltr">创建视图BookTable AS SELECT x。姓名，x。作者FROM TABLE（GetBooks（'data.txt'））x;</pre></div>
                     <!-- class="example" -->
                     <div class="example" id="GUID-F277FF3E-CA33-4B18-B39C-6286C5A913E7__CIHDDHDG">
                        <p class="titleinexample">例13-22将行插入视图时如何触发INSTEAD OF触发器</p><pre class="oac_no_warn" dir="ltr">创建触发器BookTable_insert INSTEAD OF INSERT在BookTable上为每个行开始引用新的内容......结束;插入BookTable值（...）;</pre></div>
                     <!-- class="example" -->
                  </div>
               </div><a id="ADDCI4727"></a><div class="props_rev_3"><a id="GUID-F9B720FA-351A-4B07-8409-F2E6F46B0D62" name="GUID-F9B720FA-351A-4B07-8409-F2E6F46B0D62"></a><h4 id="ADDCI-GUID-F9B720FA-351A-4B07-8409-F2E6F46B0D62" class="sect4"><span class="enumeration_section">13.3.10</span>处理表函数中的异常</h4>
                  <div>
                     <div class="section">
                        <p>表函数中的异常处理与普通用户定义函数的处理方式相同。</p>
                        <p>某些语言（如C和Java）为用户提供的异常处理提供了一种机制。如果处理表函数内引发的异常，则表函数执行异常处理程序并继续处理。退出异常处理程序将控制到封闭范围。如果异常被清除，则执行正常进行。</p>
                        <p>表函数中的未处理异常会导致父事务回滚。</p>
                     </div>
                     <!-- class="section" -->
                  </div>
               </div>
            </div><a id="ADDCI4728"></a><div class="props_rev_3"><a id="GUID-C36634BB-613C-4D88-AC58-A58E1409DF24" name="GUID-C36634BB-613C-4D88-AC58-A58E1409DF24"></a><h3 id="ADDCI-GUID-C36634BB-613C-4D88-AC58-A58E1409DF24" class="sect3"><span class="enumeration_section">13.4</span>并行表函数</h3>
               <div>
                  <p>为一个<a id="d38518e2509" class="indexterm-anchor"></a>表函数要并行执行，它必须有一个分区输入参数。当且仅当满足以下两个条件时，才会为表函数启用并行性：</p>
                  <ul style="list-style-type:disc">
                     <li>
                        <p>该函数在其声明中有一个<code class="codeph">PARALLEL_ENABLE</code>子句。
                        </p>
                     </li>
                     <li>
                        <p>使用<code class="codeph">PARTITION BY</code>子句指定了一个<code class="codeph">REF CURSOR</code> 。
                        </p>
                        <p>如果没有为任何输入<code class="codeph">REF CURSOR</code>指定<code class="codeph">PARTITION BY</code>子句作为<code class="codeph">PARALLEL_ENABLE</code>子句的一部分，则SQL编译器无法确定如何正确分区数据。
                        </p>
                     </li>
                  </ul>
               </div><a id="ADDCI4730"></a><a id="ADDCI4731"></a><a id="ADDCI4729"></a><div class="props_rev_3"><a id="GUID-60D8ADBC-A689-4FA5-A806-E803AE94F112" name="GUID-60D8ADBC-A689-4FA5-A806-E803AE94F112"></a><h4 id="ADDCI-GUID-60D8ADBC-A689-4FA5-A806-E803AE94F112" class="sect4"><span class="enumeration_section">13.4.1</span>使用光标变量输入数据</h4>
                  <div>
                     <div class="section">
                        <p>您可以将一组行传递给<code class="codeph">REF CURSOR</code>参数中的PL / SQL函数，如<a href="using-pipelined-and-parallel-table-functions.html#GUID-60D8ADBC-A689-4FA5-A806-E803AE94F112__CIHBBFBA">例13-23所示</a> 。
                        </p>
                        <p>子查询的结果可以直接传递给函数，如<a href="using-pipelined-and-parallel-table-functions.html#GUID-60D8ADBC-A689-4FA5-A806-E803AE94F112__CIHJHBGA">例13-24所示</a> 。需要<code class="codeph">CURSOR</code>关键字来指示子查询的结果应作为<code class="codeph">REF CURSOR</code>参数传递。
                        </p>
                     </div>
                     <!-- class="section" -->
                     <div class="example" id="GUID-60D8ADBC-A689-4FA5-A806-E803AE94F112__CIHBBFBA">
                        <p class="titleinexample">示例13-23将一组行传递给REF CURSOR中的PL / SQL函数</p><pre class="oac_no_warn" dir="ltr">功能f（p1 IN SYS_REFCURSOR）返回...;</pre></div>
                     <!-- class="example" -->
                     <div class="example" id="GUID-60D8ADBC-A689-4FA5-A806-E803AE94F112__CIHJHBGA">
                        <p class="titleinexample">示例13-24将子查询中的结果直接传递给函数</p><pre class="oac_no_warn" dir="ltr">SELECT * FROM TABLE（f（CURSOR（SELECT empno FROM tab）））;</pre></div>
                     <!-- class="example" -->
                  </div><a id="ADDCI4733"></a><a id="ADDCI4734"></a><a id="ADDCI4735"></a><a id="ADDCI4732"></a><div class="props_rev_3"><a id="GUID-A56ECF67-9706-4140-8280-CB2135762AD3" name="GUID-A56ECF67-9706-4140-8280-CB2135762AD3"></a><h5 id="ADDCI-GUID-A56ECF67-9706-4140-8280-CB2135762AD3" class="sect5"><span class="enumeration_section">13.4.1.1</span>使用多个REF CURSOR输入变量</h5>
                     <div>
                        <div class="section">
                           <p>PL / SQL函数可以接受多个<code class="codeph">REF CURSOR</code>输入变量，如<a href="using-pipelined-and-parallel-table-functions.html#GUID-A56ECF67-9706-4140-8280-CB2135762AD3__CIHIFIJG">例13-25所示</a> 。
                           </p>
                           <p>可以调用函数<code class="codeph">g</code>如<a href="using-pipelined-and-parallel-table-functions.html#GUID-A56ECF67-9706-4140-8280-CB2135762AD3__CIHFJFEH">例13-26所示</a> 。
                           </p>
                           <p>您可以通过创建迭代返回数据的<code class="codeph">REF CURSOR</code>将表函数返回值传递给其他表函数，如<a href="using-pipelined-and-parallel-table-functions.html#GUID-A56ECF67-9706-4140-8280-CB2135762AD3__CIHEEJBG">例13-27所示</a> 。
                           </p>
                        </div>
                        <!-- class="section" -->
                        <div class="example" id="GUID-A56ECF67-9706-4140-8280-CB2135762AD3__CIHIFIJG">
                           <p class="titleinexample">例13-25通过REF CURSOR将一组行传递给PL / SQL函数</p><pre class="oac_no_warn" dir="ltr">创建功能g（p1 pkg.refcur_t1，p2 pkg.refcur_t2）返回...管道......;</pre></div>
                        <!-- class="example" -->
                        <div class="example" id="GUID-A56ECF67-9706-4140-8280-CB2135762AD3__CIHFJFEH">
                           <p class="titleinexample">示例13-26调用使用多个REF CURSOR参数的函数</p><pre class="oac_no_warn" dir="ltr">SELECT * FROM TABLE（g（CURSOR（SELECT empno FROM tab），CURSOR（SELECT * FROM emp））;</pre></div>
                        <!-- class="example" -->
                        <div class="example" id="GUID-A56ECF67-9706-4140-8280-CB2135762AD3__CIHEEJBG">
                           <p class="titleinexample">示例13-27使用REF CURSOR在表函数之间传递返回值</p><pre class="oac_no_warn" dir="ltr">SELECT * FROM TABLE（f（CURSOR（SELECT * FROM TABLE（g（...）））））;</pre></div>
                        <!-- class="example" -->
                     </div>
                  </div><a id="ADDCI4737"></a><a id="ADDCI4736"></a><div class="props_rev_3"><a id="GUID-05693808-65AB-4F7C-8881-E20DF095EF2F" name="GUID-05693808-65AB-4F7C-8881-E20DF095EF2F"></a><h5 id="ADDCI-GUID-05693808-65AB-4F7C-8881-E20DF095EF2F" class="sect5"><span class="enumeration_section">13.4.1.2</span>显式打开查询的REF CURSOR</h5>
                     <div>
                        <p>您可以显式打开查询的<code class="codeph">REF CURSOR</code> ，并将其作为参数传递给表函数，如<a href="using-pipelined-and-parallel-table-functions.html#GUID-05693808-65AB-4F7C-8881-E20DF095EF2F__CIHJGDDE">例13-28所示</a> 。
                        </p>
                        <div class="example" id="GUID-05693808-65AB-4F7C-8881-E20DF095EF2F__CIHJGDDE">
                           <p class="titleinexample">例13-28显式使用查询REF CURSOR作为表函数参数</p><pre class="oac_no_warn" dir="ltr">BEGIN OPEN r FOR SELECT * FROM TABLE（f（...））; - 必须返回单行结果集。SELECT * INTO rec FROM TABLE（g（r））;结束;</pre></div>
                        <!-- class="example" -->
                     </div>
                  </div><a id="ADDCI4739"></a><a id="ADDCI4738"></a><div class="props_rev_3"><a id="GUID-750FEF8E-A748-44C8-B7F7-444AFACA00BC" name="GUID-750FEF8E-A748-44C8-B7F7-444AFACA00BC"></a><h5 id="ADDCI-GUID-750FEF8E-A748-44C8-B7F7-444AFACA00BC" class="sect5"><span class="enumeration_section">13.4.1.3</span> PL / SQL REF CURSOR Java和C / C ++函数的参数</h5>
                     <div>
                        <p>并行和流水线表函数可以用C / C ++，Java或PL / SQL编写。与PL / SQL不同，C / C ++和Java不支持<code class="codeph">REF CURSOR</code>类型，但您仍然可以将<code class="codeph">REF CURSOR</code>参数传递给C / C ++和Java函数。
                        </p>
                        <p>如果将表函数实现为C调用，则传递给callout的<code class="codeph">IN REF CURSOR</code>参数将自动作为已执行的OCI语句句柄使用。您可以像任何其他已执行的语句句柄一样使用此句柄。
                        </p>
                        <p>作为<code class="codeph">IN OUT</code>参数传递的callout的<code class="codeph">REF CURSOR</code>参数在进入callout的过程中转换为执行语句句柄，并且语句句柄在转出时转换回<code class="codeph">REF CURSOR</code> 。（入站和出站语句句柄可能不同。）
                        </p>
                        <p>如果<code class="codeph">REF CURSOR</code>类型用作<code class="codeph">OUT</code>参数或调用的返回类型，则调用必须返回语句句柄，该句柄将转换为调用者的<code class="codeph">REF CURSOR</code> ，如<a href="using-pipelined-and-parallel-table-functions.html#GUID-05693808-65AB-4F7C-8881-E20DF095EF2F__CIHJGDDE">例13-28所示</a> 。
                        </p>
                        <p>如果函数编写为Java调用，则<code class="codeph">IN REF CURSOR</code>参数将自动转换为Java <code class="codeph">ResultSet</code>类的实例。仅当您使用基于OCI的胖JDBC驱动程序时， <code class="codeph">IN REF CURSOR</code>到<code class="codeph">ResultSet</code>映射才可用。此映射不适用于瘦JDBC驱动程序。与C调用中的已执行语句句柄一样，当<code class="codeph">REF CURSOR</code>是<code class="codeph">IN OUT</code>参数， <code class="codeph">OUT</code>参数或函数的返回类型时，Java <code class="codeph">ResultSet</code>将在其路径上转换回PL / SQL <code class="codeph">REF CURSOR</code>打给来电者。
                        </p>
                        <p>还支持预定义的弱<code class="codeph">REF CURSOR</code>类型<code class="codeph">SYS_REFCURSOR</code> 。使用<code class="codeph">SYS_REFCURSOR</code> ，您无需先在包中创建<code class="codeph">REF CURSOR</code>类型，然后才能使用它。这种弱<code class="codeph">REF CURSOR</code>类型可以在<a href="pipelined-and-parallel-table-functions.html#GUID-7C674A4F-7145-480E-883D-00C609B64DA0">ODCITableStart（）</a>方法中使用，该方法作为类型方法不能接受包类型。
                        </p>
                        <p>要使用强<code class="codeph">REF CURSOR</code>类型，您仍然必须创建一个PL / SQL包并在其中声明一个强<code class="codeph">REF CURSOR</code>类型。此外，如果使用强<code class="codeph">REF CURSOR</code>类型作为表函数的参数，则<code class="codeph">REF CURSOR</code>参数的实际类型必须与列类型匹配，否则会生成错误。
                        </p>
                        <p>要对弱<code class="codeph">REF CURSOR</code>参数进行分区，必须按<code class="codeph">ANY</code>分区，因为弱<code class="codeph">REF CURSOR</code>参数不能由<code class="codeph">RANGE</code>或<code class="codeph">HASH</code>分区。 Oracle建议您不要对表函数使用弱<code class="codeph">REF CURSOR</code>参数。
                        </p>
                        <div class="example" id="GUID-750FEF8E-A748-44C8-B7F7-444AFACA00BC__GUID-51BB05D7-E1F4-448E-A1D4-E142CF235D25">
                           <p class="titleinexample">例13-29在呼叫中使用REF CURSOR</p><pre class="oac_no_warn" dir="ltr">创建或替换PACKAGE p1 AS TYPE rc是REF光标;结束;创建或替换LIBARY MYLIB作为'mylib.so';创建或替换函数MyCallout（stmthp p1.rc）RETURN binary_integer AS LANGUAGE C LIBRARY MYLIB WITH CONTEXT PARAMETERS（context，stmthp ocirefcursor，RETURN sb4）; sb4 MyCallout（OCIExtProcContext * ctx，OCIStmt ** stmthp）OCIEnv * envhp; / * env。 handle * / OCISvcCtx * svchp; / * service handle * / OCIError * errhp; / *错误句柄* / OCISession * usrhp; / * user handle * / int errnum = 29400; / *选择一些oracle错误号* / char errmsg [512]; / *错误消息缓冲区* / size_t errmsglen; / *错误消息的长度* / OCIDefine * defn1p =（OCIDefine *）0; OCINumber * val =（OCINumber *）0; OCINumber * rval =（OCINumber *）0;剑状态= 0; double num = 0; val =（OCINumber *）OCIExtProcAllocCallMemory（ctx，sizeof（OCINumber））; / *获取OCI句柄* / if（GetHandles（ctx，＆envhp，＆svchp，＆errhp，＆usrhp，＆rval））返回-1; / *定义获取缓冲区* / psdro_checkerr（NULL，errhp，OCIDefineByPos（* stmthp，＆defn1p，errhp，（ub4）1，（dvoid *）＆num，（sb4）sizeof（num），SQLT_FLT，（dvoid *）0， （ub2 *）0，（ub2 *）0，（ub4）OCI_DEFAULT））; / * Fetch loop * / while（（status = OCIStmtFetch（* stmthp，errhp，（ub4）1，（ub4）OCI_FETCH_NEXT，（ub4）OCI_DEFAULT））== OCI_SUCCESS || status == OCI_SUCCESS_WITH_INFO）{printf（“val = ％LF \ n”个，NUM）; } return 0; }</pre></div>
                        <!-- class="example" -->
                     </div>
                  </div>
               </div><a id="ADDCI4741"></a><a id="ADDCI4742"></a><a id="ADDCI4743"></a><a id="ADDCI4744"></a><a id="ADDCI4740"></a><div class="props_rev_3"><a id="GUID-01F8C3F7-9D0D-41A8-806E-CDF6CD2A88B0" name="GUID-01F8C3F7-9D0D-41A8-806E-CDF6CD2A88B0"></a><h4 id="ADDCI-GUID-01F8C3F7-9D0D-41A8-806E-CDF6CD2A88B0" class="sect4"><span class="enumeration_section">13.4.2</span>输入数据分区</h4>
                  <div>
                     <p>该<a id="d38518e3028" class="indexterm-anchor"></a>表函数声明可以为一个<code class="codeph">REF CURSOR</code>参数指定数据分区，如<a href="using-pipelined-and-parallel-table-functions.html#GUID-01F8C3F7-9D0D-41A8-806E-CDF6CD2A88B0__CIHGECED">例13-30所示</a> 。<code class="codeph">PARALLEL_ENABLE</code>子句中的<code class="codeph">PARTITION BY</code>短语指定要分区的哪个输入游标以及用于分区的列。
                     </p>
                     <p>在列列表中指定显式列名时， <a id="d38518e3046" class="indexterm-anchor"></a><a id="d38518e3050" class="indexterm-anchor"></a>分区方法可以是<code class="codeph">RANGE</code>或<code class="codeph">HASH</code> 。输入行在指定列上进行散列或范围分区。
                     </p>
                     <p><code class="codeph">ANY</code>关键字使您可以指示函数行为独立于输入数据的分区。使用此关键字时，运行时系统会在从属服务器之间随机分区数据。此关键字适用于占用一行的函数，操作其列，并仅基于此行的列生成输出行。
                     </p>
                     <p>为了演示， <a href="using-pipelined-and-parallel-table-functions.html#GUID-01F8C3F7-9D0D-41A8-806E-CDF6CD2A88B0__CIHEDEFF">示例13-31中</a>的类似于pivot的函数<code class="codeph">StockPivot()</code>将类型的行<code class="codeph">(Ticker varchar(4), OpenPrice number, ClosePrice number)</code>作为输入，并生成该类型的行<code class="codeph">(Ticker varchar(4), PriceType varchar(1), Price number)</code> 。因此，行（ <code class="codeph">"ORCL", 41, 42</code> ）生成两行：（ <code class="codeph">"ORCL", "O", 41</code> ）和（ <code class="codeph">"ORCL", "C", 42</code> ）。
                     </p>
                     <p>您可以直接使用在<a href="using-pipelined-and-parallel-table-functions.html#GUID-A11569C5-BBF7-4838-9AE6-8BAEAEB58265__CIHEGADE">示例13-5中</a>创建的<code class="codeph">rec_tab_type</code> ，而不是<code class="codeph">TickerTypeSet</code> ，也可以使用相同的方式定义它。
                     </p>
                     <p>函数<code class="codeph">f()</code>可用于从<code class="codeph">Stocks</code>表生成另一个表，如<a href="using-pipelined-and-parallel-table-functions.html#GUID-01F8C3F7-9D0D-41A8-806E-CDF6CD2A88B0__CIHCCJBG">例13-32</a>所示。
                     </p>
                     <p>如果并行扫描<code class="codeph">StockTable</code>并在<code class="codeph">OpenPrice</code>分区，那么函数<code class="codeph">StockPivot()</code>将与扫描<code class="codeph">StockTable</code>的数据流运算符结合使用，因此会看到相同的分区。
                     </p>
                     <p>如果<code class="codeph">StockTable</code>未分区，并且其上的扫描不是并行执行，则<code class="codeph">AlternateStockTable</code>的插入也会按顺序运行，如<a href="using-pipelined-and-parallel-table-functions.html#GUID-01F8C3F7-9D0D-41A8-806E-CDF6CD2A88B0__CIHGIDHB">例13-33所示</a> 。
                     </p>
                     <p>如果函数<code class="codeph">g()</code>并行运行并由<code class="codeph">ANY</code>分区，则并行插入可以与<code class="codeph">g()</code>属于同一数据流运算符。
                     </p>
                     <p>只要指定了<code class="codeph">ANY</code>关键字，数据就会在从属中随机分区。这实际上意味着该功能在与输入参数相关联的扫描的同一从设备中执行。
                     </p>
                     <p>此处不需要重新分发或重新分配数据。在这种情况下，当光标<code class="codeph">p</code>本身未启用并行时，传入数据将在列列表中的列上随机分区。循环表队列用于此分区。
                     </p>
                     <p>如果在分区的<code class="codeph">XMLType</code>表上创建<code class="codeph">XMLIndex</code>索引，或者使用范围，列表或散列分区在<code class="codeph">XMLType</code>列上创建分区表，则该索引将与基表进行均分配置。
                     </p>
                     <div class="example" id="GUID-01F8C3F7-9D0D-41A8-806E-CDF6CD2A88B0__CIHGECED">
                        <p class="titleinexample">示例13-30为REF CURSOR参数指定数据分区</p><pre class="oac_no_warn" dir="ltr">CREATE函数F（P <span class="italic">ref_cursor_type）RETURN</span> rec_tab_type PIPELINED PARALLEL_ENABLE（分区P BY [{HASH | <span class="italic">RANGE}（column_list中</span> ）| ANY]）IS BEGIN ...结束;</pre></div>
                     <!-- class="example" -->
                     <div class="example" id="GUID-01F8C3F7-9D0D-41A8-806E-CDF6CD2A88B0__CIHEDEFF">
                        <p class="titleinexample">示例13-31实现StockPivot（）函数</p><pre class="oac_no_warn" dir="ltr">CREATE FUNCTION StockPivot（p refcur_pkg.refcur_t）RETURN rec_tab_type PIPELINED PARALLEL_ENABLE（PARTITION p BY ANY）是ret_rec rec_type;开始用于rec IN p LOOP ret_rec。股票代码：= rec。新浪体育讯北京时间; ret_rec。PriceType：=“O”; ret_rec。价格：= rec。OpenPrice; PIPE ROW（ret_rec）; ret_rec。股票代码：= rec。新浪体育讯北京时间; - 冗余;不需要ret_rec。PriceType：=“C”; ret_rec。价格：= rec。ClosePrice; PIPE ROW ret_rec;结束循环;返回;结束;</pre></div>
                     <!-- class="example" -->
                     <div class="example" id="GUID-01F8C3F7-9D0D-41A8-806E-CDF6CD2A88B0__CIHCCJBG">
                        <p class="titleinexample">例13-32使用REF CURSOR从另一个表生成表</p><pre class="oac_no_warn" dir="ltr">INSERT INTO AlternateStockTable SELECT * FROM TABLE（StockPivot（CURSOR（SELECT * FROM StockTable）））;</pre></div>
                     <!-- class="example" -->
                     <div class="example" id="GUID-01F8C3F7-9D0D-41A8-806E-CDF6CD2A88B0__CIHGIDHB">
                        <p class="titleinexample">例13-33使用REF CURSOR进行扫描和插入</p><pre class="oac_no_warn" dir="ltr">创建功能g（p refcur_pkg.refcur_t）返回...PIPELINED PARALLEL_ENABLE（从任何地方分开）开始......结束; INSERT INTO AlternateStockTable SELECT * FROM TABLE（f（CURSOR（SELECT * FROM Stocks））），TABLE（g（CURSOR（...）））WHERE <span class="italic">join_condition</span> ;</pre></div>
                     <!-- class="example" -->
                  </div>
               </div><a id="ADDCI4746"></a><a id="ADDCI4745"></a><div class="props_rev_3"><a id="GUID-9983C9CB-9B31-4169-A3A4-3B3DE8618AD4" name="GUID-9983C9CB-9B31-4169-A3A4-3B3DE8618AD4"></a><h4 id="ADDCI-GUID-9983C9CB-9B31-4169-A3A4-3B3DE8618AD4" class="sect4"><span class="enumeration_section">13.4.3</span>叶级表函数的并行执行</h4>
                  <div>
                     <p>并行执行表函数需要<code class="codeph">REF</code> <code class="codeph">CURSOR</code>作为输入参数。如果表函数本身并不需要一组行作为输入，那么必须重新设计该函数以要求<code class="codeph">REF</code> <code class="codeph">CURSOR</code>作为输入。
                     </p>
                     <p>例如，以下函数并行读取一组外部文件并返回它们包含的记录。要为<code class="codeph">REF CURSOR</code>提供工作，您可以先创建一个表并使用文件名填充它。然后，可以将此表上的<code class="codeph">REF CURSOR</code>作为参数传递给表函数<code class="codeph">readfiles()</code> ，如<a href="using-pipelined-and-parallel-table-functions.html#GUID-9983C9CB-9B31-4169-A3A4-3B3DE8618AD4__CIHCAJGD">例13-34所示</a> 。
                     </p>
                     <div class="example" id="GUID-9983C9CB-9B31-4169-A3A4-3B3DE8618AD4__CIHCAJGD">
                        <p class="titleinexample">例13-34使用REF CURSOR读取一组外部传感器</p><pre class="oac_no_warn" dir="ltr">CREATE TABLE filetab（filename VARCHAR（20））; INSERT INTO filetab VALUES（'file0'）; INSERT INTO filetab VALUES（'file1'）; ...INSERT INTO filetab VALUES（'fileN'）; SELECT * FROM TABLE（readfiles（CURSOR（SELECT filename FROM filetab）））; CREATE FUNCTION readfiles（p pkg.rc_t）RETURN coll_type PARALLEL_ENABLE（PARTITION p BY ANY）IS ret_rec rec_type;开始接收完成输入：= FALSE; WHILE（done = FALSE）LOOP完成：= readfilerecord（rec.filename，ret_rec）; PIPE ROW（ret_rec）;结束循环;结束循环;返回;结束;</pre></div>
                     <!-- class="example" -->
                  </div>
               </div>
            </div><a id="ADDCI4747"></a><div class="props_rev_3"><a id="GUID-29BF4664-DC92-4ABA-810D-0998AAA33563" name="GUID-29BF4664-DC92-4ABA-810D-0998AAA33563"></a><h3 id="ADDCI-GUID-29BF4664-DC92-4ABA-810D-0998AAA33563" class="sect3"><span class="enumeration_section">13.5</span>表函数的输入数据流</h3>
               <div>
                  <p>数据流是表函数对从光标参数中提取的行进行排序或聚类的方式。函数可以通过以下任何方式流式传输其输入数据：</p>
                  <ul style="list-style-type:disc">
                     <li>
                        <p>对输入行的排序没有限制。</p>
                     </li>
                     <li>
                        <p>在特定的一列或多列上订购它们。</p>
                     </li>
                     <li>
                        <p>将它们集中在特定键上。</p>
                     </li>
                  </ul>
                  <p>要控制输入流的行为，请使用<a href="using-pipelined-and-parallel-table-functions.html#GUID-03918C18-8C89-4D6C-AB22-F1E8FDF4728B__CIHECDFJ">示例13-36中</a>的语法。
                  </p>
                  <p>可以为函数的顺序或并行执行指定输入流。如果未指定<code class="codeph">ORDER BY</code>或<code class="codeph">CLUSTER BY</code>子句，则以随机顺序输入行。对于从SQL语句中的<code class="codeph">ORDER BY</code>子句的语义进行并行执行， <code class="codeph">ORDER BY</code>的语义是不同的。在SQL语句中， <code class="codeph">ORDER BY</code>子句全局排序整个数据集。在表函数中， <code class="codeph">ORDER BY</code>子句对从属服务器上运行的表函数的每个实例的本地各行进行排序。
                  </p>
                  <p>群集导致具有相同键值的行彼此相邻显示，但它不会对行进行任何排序。</p>
                  <p><code class="codeph">expr</code>应该是<code class="codeph">REFCURSOR</code>收到的<code class="codeph">REFCURSOR</code> 。
                  </p>
                  <p><a href="using-pipelined-and-parallel-table-functions.html#GUID-03918C18-8C89-4D6C-AB22-F1E8FDF4728B__CIHGDIBD">例13-35</a>说明了对输入流进行排序的语法。在该示例中，函数<code class="codeph">f()</code>接受类型<code class="codeph">(Region, Sales)</code>行并返回表单<code class="codeph">(Region, AvgSales)</code> ，显示每个区域的平均销售额。
                  </p>
               </div><a id="ADDCI4748"></a><a id="ADDCI4749"></a><div class="props_rev_3"><a id="GUID-03918C18-8C89-4D6C-AB22-F1E8FDF4728B" name="GUID-03918C18-8C89-4D6C-AB22-F1E8FDF4728B"></a><h4 id="ADDCI-GUID-03918C18-8C89-4D6C-AB22-F1E8FDF4728B" class="sect4"><span class="enumeration_section">13.5.1</span>设置输入流</h4>
                  <div>
                     <div class="example" id="GUID-03918C18-8C89-4D6C-AB22-F1E8FDF4728B__CIHGDIBD">
                        <p class="titleinexample">例13-35排序输入流</p><pre class="oac_no_warn" dir="ltr">CREATE函数F（P <span class="italic">ref_cursor_type）RETURN</span> tab_rec_type PIPELINED CLUSTER p BY（地区）PARALLEL_ENABLE（分区P BY HASH（地区））IS ret_rec rec_type; cnt号码;总数; BEGIN LOOP FETCH p INTO rec; p％NOTFOUND时退出; IF（组中的第一个rec）THEN cnt：= 1; sum：= rec。销售; ELSIF（组中的最后一个记录）那么如果（cnt &lt;&gt; 0）那么ret_rec。地区：= rec。区域; ret_rec。AvgSales：= sum / cnt; PIPE ROW（ret_rec）;万一; ELSE cnt：= cnt + 1; sum：= sum + rec。销售;万一;结束循环;返回;结束</pre></div>
                     <!-- class="example" -->
                     <div class="example" id="GUID-03918C18-8C89-4D6C-AB22-F1E8FDF4728B__CIHECDFJ">
                        <p class="titleinexample">例13-36控制输入数据流</p><pre class="oac_no_warn" dir="ltr">功能f（p ref_cursor_type）RETURN tab_rec_type [PIPELINED] {[ORDER | CLUSTER] expr BY column_list} PARALLEL_ENABLE（{PARTITION p BY [ANY | {HASH | RANGE} column_list]}）IS BEGIN ...结束;</pre></div>
                     <!-- class="example" -->
                  </div>
               </div><a id="ADDCI4750"></a><div class="props_rev_3"><a id="GUID-8066CFAA-7DDD-4929-8543-5F2373C1367B" name="GUID-8066CFAA-7DDD-4929-8543-5F2373C1367B"></a><h4 id="ADDCI-GUID-8066CFAA-7DDD-4929-8543-5F2373C1367B" class="sect4"><span class="enumeration_section">13.5.2</span>并行执行：分区和集群</h4>
                  <div>
                     <p>分区和聚类很容易混淆，但它们做了不同的事情。有时，在没有并行执行的集群的情况下进行分区就足够了。</p>
                     <p>考虑一个函数<code class="codeph">SmallAggr</code>对于每个执行内存中的工资的聚合<code class="codeph">department_id</code> ，其中<code class="codeph">department_id</code>可以是<code class="codeph">1</code> ， <code class="codeph">2</code> ，或<code class="codeph">3</code> 。函数的输入行可以通过<code class="codeph">department_id</code>上的<code class="codeph">HASH</code>进行分区，以便<code class="codeph">department_id</code>等于<code class="codeph">1</code>所有行都转到一个slave， <code class="codeph">department_id</code>等于<code class="codeph">2</code>所有行都转到另一个slave，依此类推。
                     </p>
                     <p>输入行不必在<code class="codeph">department_id</code>上聚类以在函数中执行聚合。每个slave可以有一个<code class="codeph">1</code>乘<code class="codeph">3</code>数组<code class="codeph">SmallSum[1..3]</code> ，其中每个<code class="codeph">department_id</code>总和在内存中添加到<code class="codeph">SmallSum[department_id]</code> 。另一方面，如果<code class="codeph">department_id</code>的唯一值的数量非常大，您可能希望使用群集来计算部门聚合并一次将它们写入磁盘一个<code class="codeph">department_id</code> 。
                     </p>
                  </div>
               </div>
            </div><a id="ADDCI4751"></a><div class="props_rev_3"><a id="GUID-8A9A03F7-91B0-4205-A7AC-58CAA8852DD6" name="GUID-8A9A03F7-91B0-4205-A7AC-58CAA8852DD6"></a><h3 id="ADDCI-GUID-8A9A03F7-91B0-4205-A7AC-58CAA8852DD6" class="sect3"><span class="enumeration_section">13.6</span>并行创建域索引</h3>
               <div>
                  <p>创建一个<a id="d38518e3638" class="indexterm-anchor"></a>域索引可能是一个漫长的过程，因为域索引通常处理大量数据。您可以通过使用表函数并行创建域索引来利用表函数的并行处理功能来缓解此瓶颈。
                  </p>
                  <p>通常， <code class="codeph">ODCIIndexCreate()</code>例程执行以下步骤：</p>
                  <ol>
                     <li>
                        <p>创建用于存储索引数据的表</p>
                     </li>
                     <li id="GUID-8A9A03F7-91B0-4205-A7AC-58CAA8852DD6__CIHFGIID">
                        <p>从基表中获取相关数据（如<code class="codeph">keycols</code>和<code class="codeph">rowid</code> ，对其进行转换，并将相关的转换数据插入到为存储索引数据而创建的表中。
                        </p>
                     </li>
                     <li>
                        <p>在存储索引数据的表上构建二级索引，以便在查询时更快地访问。</p>
                     </li>
                  </ol>
                  <p>第<a href="using-pipelined-and-parallel-table-functions.html#GUID-8A9A03F7-91B0-4205-A7AC-58CAA8852DD6__CIHFGIID">2</a>步是创建域索引的瓶颈。您可以通过将这些操作封装在并行表函数中并从<code class="codeph">ODCIIndexCreate()</code>函数调用该函数来加快此步骤。在<a href="using-pipelined-and-parallel-table-functions.html#GUID-A2D01076-AB16-4D79-89F3-67DBE0CB109D__CIHDDFGE">例13-37中</a> ，定义了表函数<code class="codeph">IndexLoad()</code>来做到这一点。
                  </p>
                  <p>其中<code class="codeph">p</code>是表单的游标：</p><pre class="oac_no_warn" dir="ltr">SELECT / * + PARALLEL（ <span class="italic">base_table</span> ， <span class="italic">par_degree</span> ）* / keycols，rowid FROM <span class="italic">base_table</span>
</pre><p>可以显式指定<span class="italic"><code class="codeph">par_degree</code></span>值;否则，它是从基表的并行度导出的。
                  </p>
                  <p>需要使用<a href="using-pipelined-and-parallel-table-functions.html#GUID-A2D01076-AB16-4D79-89F3-67DBE0CB109D__CIHGHDIB">示例</a> <code class="codeph">IndexMerge()</code>定义的函数<code class="codeph">IndexMerge()</code>来合并<code class="codeph">IndexLoad()</code>的多个实例的结果。
                  </p>
                  <p><code class="codeph">ODCIIndexCreate()</code>的新步骤将是：</p>
                  <ol>
                     <li>
                        <p>为索引创建元数据结构（用于存储索引数据的表）。</p>
                     </li>
                     <li>
                        <p>显式提交事务，以便<code class="codeph">IndexLoad()</code>函数可以访问已提交的数据。
                        </p>
                     </li>
                     <li>
                        <p>并行调用<code class="codeph">IndexLoad()</code> ，如以下代码示例所示。
                        </p>
                        <p>调用并行域索引加载的合并</p><pre class="oac_no_warn" dir="ltr">status：= ODCIIndexMerge（CURSOR（SELECT * FROM TABLE（ODCIIndexLoad（ia，parms，CURSOR（SELECT <span class="italic">key_cols</span> ，ROWID FROM <span class="italic">basetable</span> ）））））</pre></li>
                     <li>
                        <p>创建二级索引结构。</p>
                     </li>
                  </ol>
                  <div class="infoboxnotealso" id="GUID-8A9A03F7-91B0-4205-A7AC-58CAA8852DD6__GUID-1FB7D6B6-2DCB-4715-BC85-9598904A0C19">
                     <p class="notep1">也可以看看：</p>
                     <p><a href="extensible-indexing-interface.html#GUID-C14A0478-6EA1-4EAE-BAA6-AA59EE5D300C">ODCIIndexCreate（）</a></p>
                  </div>
               </div><a id="ADDCI4753"></a><a id="ADDCI4752"></a><div class="props_rev_3"><a id="GUID-A2D01076-AB16-4D79-89F3-67DBE0CB109D" name="GUID-A2D01076-AB16-4D79-89F3-67DBE0CB109D"></a><h4 id="ADDCI-GUID-A2D01076-AB16-4D79-89F3-67DBE0CB109D" class="sect4"><span class="enumeration_section">13.6.1</span>加载域索引</h4>
                  <div>
                     <div class="section">
                        <p>二级索引的形成非常耗时，Oracle建议您实现域索引的并行加载，如“并行加载域索引”部分所示，然后重新组合它们，如“合并并行域的结果”中所示索引加载“示例。</p>
                     </div>
                     <!-- class="section" -->
                     <div class="example" id="GUID-A2D01076-AB16-4D79-89F3-67DBE0CB109D__CIHDDFGE">
                        <p class="titleinexample">示例13-37并行加载域索引</p><pre class="oac_no_warn" dir="ltr">CREATE FUNCTION IndexLoad（ia ODCIIndexInfo，parms VARCHAR2，p refcur-type）RETURN status_code_type PARALLEL_ENABLE（PARTITION p BY ANY）PRAGMA AUTONOMOUS_TRANSACTION开始于rec IN p LOOP  - 处理每个rec并确定索引条目 - 从中获取索引存储表的名称参数ia  - 插入在ODCIIndexCreate END LOOP中创建的表中;承诺; - 显式提交自治txn RETURN ODCIConst。成功;结束;</pre></div>
                     <!-- class="example" -->
                     <div class="example" id="GUID-A2D01076-AB16-4D79-89F3-67DBE0CB109D__CIHGHDIB">
                        <p class="titleinexample">例13-38合并并行域索引加载的结果</p><pre class="oac_no_warn" dir="ltr">创建功能IndexMerge（p refcur-type）返回编号从开始输入循环开始（rec！= ODCIConst。成功）返回错误;结束循环;返回成功;结束;</pre></div>
                     <!-- class="example" -->
                  </div>
               </div>
            </div><a id="ADDCI4756"></a><a id="ADDCI4755"></a><div class="props_rev_3"><a id="GUID-7008AB9F-4C2B-4896-AF2D-1AB39910C9A0" name="GUID-7008AB9F-4C2B-4896-AF2D-1AB39910C9A0"></a><h3 id="ADDCI-GUID-7008AB9F-4C2B-4896-AF2D-1AB39910C9A0" class="sect3"><span class="enumeration_section">13.7</span>瞬态和通用类型</h3>
               <div>
                  <p>Oracle有三个特殊的SQL <a id="d38518e3872" class="indexterm-anchor"></a>数据类型<a id="d38518e3877" class="indexterm-anchor"></a>让你<a id="d38518e3882" class="indexterm-anchor"></a>动态封装和访问任何其他SQL类型的类型描述，数据实例和数据实例集，包括对象和集合类型。您还可以使用这三种特殊类型来创建匿名或未命名的类型，包括匿名集合类型。<a href="using-pipelined-and-parallel-table-functions.html#GUID-7008AB9F-4C2B-4896-AF2D-1AB39910C9A0__CIHDHEEI" title="类型及其描述">见表13-1</a> 。
                  </p>
                  <p>这三种SQL类型实现为opaque类型;数据库不知道这些类型的内部结构：只能通过实现函数（通常是3GL例程）来查询它们的数据。Oracle提供了OCI和PL / SQL API来实现这些功能。</p>
                  <div class="tblformal" id="GUID-7008AB9F-4C2B-4896-AF2D-1AB39910C9A0__CIHDHEEI">
                     <p class="titleintable">表13-1通用SQL类型</p>
                     <table cellpadding="4" cellspacing="0" class="Formal" title="通用SQL类型" width="100%" border="1" summary="Type and its description" frame="hsides" rules="rows">
                        <thead>
                           <tr align="left" valign="top">
                              <th align="left" valign="bottom" width="30%" id="d38518e3902">类型</th>
                              <th align="left" valign="bottom" width="70%" id="d38518e3905">描述</th>
                           </tr>
                        </thead>
                        <tbody>
                           <tr align="left" valign="top">
                              <td align="left" valign="top" width="30%" id="d38518e3910" headers="d38518e3902 ">
                                 <p><code class="codeph">SYS.ANYTYPE</code></p>
                              </td>
                              <td align="left" valign="top" width="70%" headers="d38518e3910 d38518e3905 ">
                                 <p>类型描述类型。<code class="codeph">SYS.ANYTYPE</code>可以包含任何SQL类型的类型描述，无论是命名还是未命名，包括对象类型和集合类型。
                                 </p>
                                 <p>一个<code class="codeph">ANYTYPE</code>可以包含持久性类型的类型描述，但一个<code class="codeph">ANYTYPE</code>本身是瞬时的：在该值<code class="codeph">ANYTYPE</code>本身不自动存储在数据库中。要创建持久性类型，请使用SQL中的<code class="codeph">CREATE TYPE</code>语句。</p>
                              </td>
                           </tr>
                           <tr align="left" valign="top">
                              <td align="left" valign="top" width="30%" id="d38518e3935" headers="d38518e3902 ">
                                 <p><code class="codeph">SYS.ANYDATA</code></p>
                              </td>
                              <td align="left" valign="top" width="70%" headers="d38518e3935 d38518e3905 ">
                                 <p>自描述数据实例类型。<code class="codeph">SYS.ANYDATA</code>包含给定类型的实例，包含数据以及类型的描述。从这个意义上说， <code class="codeph">SYS.ANYDATA</code>是自描述的。<code class="codeph">ANYDATA</code>可以持久存储在数据库中。
                                 </p>
                              </td>
                           </tr>
                           <tr align="left" valign="top">
                              <td align="left" valign="top" width="30%" id="d38518e3952" headers="d38518e3902 ">
                                 <p><code class="codeph">SYS.ANYDATASET</code></p>
                              </td>
                              <td align="left" valign="top" width="70%" headers="d38518e3952 d38518e3905 ">
                                 <p>自描述数据集类型。<code class="codeph">SYS.ANYDATASET</code>类型包含给定类型的描述以及该类型的一组数据实例。<code class="codeph">ANYDATASET</code>可以持久存储在数据库中。
                                 </p>
                              </td>
                           </tr>
                        </tbody>
                     </table>
                  </div>
                  <!-- class="inftblhruleinformal" -->
                  <p>这三种类型中的每一种都可以与数据库本机的任何内置类型一起使用，包括对象类型和集合类型，包括命名和未命名。这些类型提供了一种通用方式，可以使用类型描述，单个实例和其他类型的实例集动态工作。使用API，您可以创建任何类型的瞬态<code class="codeph">ANYTYPE</code>描述。同样，您可以创建任何SQL类型的数据值或将其转换（转换）为<code class="codeph">ANYDATA</code>并可以将<code class="codeph">ANYDATA</code> （返回）转换为SQL类型。同样，使用多组值和<code class="codeph">ANYDATASET</code> 。</p>
                  <p>泛型类型简化了存储过程的使用。您可以使用泛型类型来封装标准类型的描述和数据，并将封装的信息传递给泛型类型的参数。在过程的主体中，您可以详细说明如何处理封装数据以及任何类型的类型描述。</p>
                  <p>您还可以将各种基础类型的封装数据存储在<code class="codeph">ANYDATA</code>或<code class="codeph">ANYDATASET</code>类型的一个表列中。例如，您可以使用带有高级排队的<code class="codeph">ANYDATA</code>来为异构类型的数据建模队列。您可以像查询任何其他数据一样查询基础数据类型的数据。
                  </p>
                  <p>但请注意，在瞬态类型上创建的<code class="codeph">ANYDATA</code>和<code class="codeph">ANYDATASET</code>对象（例如通过<code class="codeph">ANYTYPE</code> API构造的未命名类型）不能永久存储在<code class="codeph">ANYDATA</code>或<code class="codeph">ANYDATASET</code>表列中。
                  </p>
                  <p>对应于三种通用SQL类型的是对它们进行建模的三种OCI类型。每个都有一组用于创建和访问相应类型的函数：</p>
                  <ul style="list-style-type:disc">
                     <li>
                        <p><code class="codeph">OCIType</code> ，对应于<code class="codeph">SYS.ANYTYPE</code></p>
                     </li>
                     <li>
                        <p><code class="codeph">OCIAnyData</code> ，对应于<code class="codeph">SYS.ANYDATA</code></p>
                     </li>
                     <li>
                        <p><code class="codeph">OCIAnyDataSet</code> ，对应于<code class="codeph">SYS.ANYDATASET</code></p>
                     </li>
                  </ul>
                  <div class="infoboxnotealso" id="GUID-7008AB9F-4C2B-4896-AF2D-1AB39910C9A0__GUID-2E932ECB-22AD-4EF7-8872-A7D2E7286CD5">
                     <p class="notep1">也可以看看：</p>
                     <ul style="list-style-type:disc">
                        <li>
                           <p><a href="https://www.oracle.com/pls/topic/lookup?ctx=en/database/oracle/oracle-database/19/addci&amp;id=LNOCI-GUID-169F309C-279B-410C-9844-E0ACC505F789" target="_blank"><span class="italic">Oracle调用接口程序员指南，</span></a>用于<code class="codeph">OCIType</code> ， <code class="codeph">OCIAnyData</code>和<code class="codeph">OCIAnyDataSet</code> API以及如何使用它们的详细信息</p>
                        </li>
                        <li>
                           <p> <a href="https://www.oracle.com/pls/topic/lookup?ctx=en/database/oracle/oracle-database/19/addci&amp;id=ARPLS-GUID-4AA6AA30-CAEE-4DCD-B214-9AD51D0229B4" target="_blank"><span class="italic">Oracle Database PL / SQL包和类型参考</span></a>有关<code class="codeph">ANYTYPE</code> ， <code class="codeph">ANYDATA</code>和<code class="codeph">ANYDATASET</code>类型的接口以及<code class="codeph">DBMS_TYPES</code>包的信息，该包定义了内置和用户定义类型的常量，用于<code class="codeph">ANYTYPE</code> ， <code class="codeph">ANYDATA</code>和<code class="codeph">ANYDATASET</code></p>
                        </li>
                        <li>
                           <p><a href="https://www.oracle.com/pls/topic/lookup?ctx=en/database/oracle/oracle-database/19/addci&amp;id=ADOBJ010" target="_blank"><span class="italic">Oracle数据库对象关系开发人员指南，</span></a>用于定义通用，瞬态和不透明类型。
                           </p>
                        </li>
                     </ul>
                  </div>
               </div>
            </div>
         </div>
      </article>
   </body>
</html>