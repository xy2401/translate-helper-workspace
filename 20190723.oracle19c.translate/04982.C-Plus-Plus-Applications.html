<html lang="en-us" dir="ltr" xml:lang="en-us">
   <head>
      <meta http-equiv="Content-Type" content="text/html; charset=utf-8"></meta>
      <meta name="viewport" content="width=device-width, initial-scale=1"></meta>
      <meta http-equiv="X-UA-Compatible" content="IE=edge"></meta>
      <title>C ++应用程序</title>
      <meta property="og:site_name" content="Oracle Help Center"></meta>
      <meta property="og:title" content="Programmer&#39;s Guide"></meta>
      <meta property="og:description" content=""></meta>
      <link rel="stylesheet" href="/sp_common/book-template/ohc-book-template/css/book.css"></link>
      <link rel="shortcut icon" href="/sp_common/book-template/ohc-common/img/favicon.ico"></link>
      <meta name="application-name" content="Programmer&#39;s Guide"></meta>
      <meta name="generator" content="DITA Open Toolkit version 1.8.5 (Mode = doc)"></meta>
      <meta name="plugin" content="SP_docbuilder HTML plugin release 18.2.2"></meta>
      <link rel="alternate" href="c-c-programmers-guide.pdf" title="PDF File" type="application/pdf"></link>
      <meta name="robots" content="all"></meta>
      <link rel="schema.dcterms" href="http://purl.org/dc/terms/"></link>
      <meta name="dcterms.created" content="2019-01-11T03:52:01-08:00"></meta>
      
      <meta name="dcterms.dateCopyrighted" content="1996, 2019"></meta>
      <meta name="dcterms.category" content="database"></meta>
      <meta name="dcterms.identifier" content="E96467-01"></meta>
      
      <meta name="dcterms.product" content="en/database/oracle/oracle-database/19"></meta>
      
      <link rel="prev" href="applications.html" title="Previous" type="text/html"></link>
      <link rel="next" href="Oracle-dynamic-SQL.html" title="Next" type="text/html"></link>
      <script>
        document.write('<style type="text/css">');
        document.write('body > .noscript, body > .noscript ~ * { visibility: hidden; }');
        document.write('</style>');
     </script>
      <script src="/sp_common/book-template/requirejs/require.js" data-main="/sp_common/book-template/ohc-book-template/js/book-config"></script>
      <script>
            if (window.require === undefined) {
                document.write('<script data-main="sp_common/book-template/ohc-book-template/js/book-config" src="sp_common/book-template/requirejs/require.js"><\/script>');
                document.write('<link href="sp_common/book-template/ohc-book-template/css/book.css" rel="stylesheet"/>');
            }
        </script>
      <script type="application/json" id="ssot-metadata">{"primary":{"category":{"short_name":"database","element_name":"Database","display_in_url":true},"suite":{"short_name":"oracle","element_name":"Oracle","display_in_url":true},"product_group":{"short_name":"not-applicable","element_name":"Not applicable","display_in_url":false},"product":{"short_name":"oracle-database","element_name":"Oracle Database","display_in_url":true},"release":{"short_name":"19","element_name":"Release 19","display_in_url":true}}}</script>
      
    <meta name="dcterms.title" content="Pro*C/C++ Programmer&#39;s Guide"></meta>
    <meta name="dcterms.isVersionOf" content="LNPCC"></meta>
    <meta name="dcterms.release" content="Release 19"></meta>
  </head>
   <body dir="ltr">
      <div class="noscript alert alert-danger text-center" role="alert">
         <a href="applications.html" class="pull-left"><span class="glyphicon glyphicon-chevron-left" aria-hidden="true"></span>上一页</a> <a href="Oracle-dynamic-SQL.html" class="pull-right">下一页<span class="glyphicon glyphicon-chevron-right" aria-hidden="true"></span></a> <span class="fa fa-exclamation-triangle" aria-hidden="true"></span>必须启用JavaScript才能正确显示此内容</div>
      <article>
         <header>
            <ol class="breadcrumb" vocab="http://schema.org/" typeof="BreadcrumbList">
               <li property="itemListElement" typeof="ListItem"><a href="index.html" property="item" typeof="WebPage"><span property="name">程序员指南</span></a></li>
               <li property="itemListElement" typeof="ListItem"><a href="applications.html" property="item" typeof="WebPage"><span property="name">应用</span></a></li>
               <li class="active" property="itemListElement" typeof="ListItem">C ++应用程序</li>
            </ol>
            <a id="GUID-320589F8-AE9F-4440-9551-1C52F449E486" name="GUID-320589F8-AE9F-4440-9551-1C52F449E486"></a><a id="LNPCC012"></a>
            
            <h2 id="LNPCC-GUID-320589F8-AE9F-4440-9551-1C52F449E486" class="sect2"><span class="enumeration_chapter">12</span> C ++应用程序</h2>
         </header>
         <div class="ind">
            <div>
               <p>本章介绍如何使用Pro * C / C ++预编译器预编译C ++嵌入式SQL应用程序，以及Pro * C / C ++如何生成C ++兼容代码。本章包含以下主题：</p>
               <ul style="list-style-type:disc">
                  <li>
                     <p><a href="C-Plus-Plus-Applications.html#GUID-E044AC96-3D03-49FA-B76C-7F0908BFA49E">了解C ++支持</a></p>
                  </li>
                  <li>
                     <p><a href="C-Plus-Plus-Applications.html#GUID-49186B13-90DB-4C73-869E-2DF6D8CDE224">预编译C ++</a></p>
                  </li>
                  <li>
                     <p><a href="C-Plus-Plus-Applications.html#GUID-EAC4F5AA-A221-4E17-B6CB-ECCFA0748392">示例程序</a> <a id="d72932e39" class="indexterm-anchor"></a></p>
                  </li>
               </ul>
            </div><a id="LNPCC3979"></a><div class="props_rev_3"><a id="GUID-E044AC96-3D03-49FA-B76C-7F0908BFA49E" name="GUID-E044AC96-3D03-49FA-B76C-7F0908BFA49E"></a><h3 id="LNPCC-GUID-E044AC96-3D03-49FA-B76C-7F0908BFA49E" class="sect3"><span class="enumeration_section">12.1</span>了解C ++支持</h3>
               <div>
                  <p>要了解Pro * C / C ++如何支持C ++，您必须了解Pro * C / C ++的基本功能。特别是，您必须了解Pro * C / C ++与Pro * C版本1的不同之处。</p>
                  <p>Pro * C / C ++的基本功能是：</p>
                  <ul style="list-style-type:disc">
                     <li>
                        <p>完整的C预处理器支持。您可以在Pro * C / C ++程序中使用<code class="codeph">#include</code> <code class="codeph">#define</code> ， <code class="codeph">#include</code> ， <code class="codeph">#ifdef</code>和其他预处理程序指令来处理预编译器本身必须处理的构造。
                        </p>
                     </li>
                     <li>
                        <p>使用本机C结构作为主变量，包括将结构（或指向结构的指针）作为主变量传递给函数的能力，以及写入返回主机结构或结构指针的函数。</p>
                     </li>
                  </ul>
                  <p>为了支持其C预处理器功能并使主变量能够在特殊的Declare Section之外声明，Pro * C / C ++包含了一个完整的C解析器。Pro * C / C ++解析器是一个C解析器;它无法解析C ++代码。</p>
                  <p>这意味着对于C ++支持，您必须能够禁用C解析器，或者至少部分禁用它。要禁用C解析器，Pro * C / C ++预编译器包含命令行选项，可让您控制Pro * C / C ++对源代码执行的C解析范围。</p>
               </div>
               <div>
                  <div class="relinfo">
                     <p><strong>相关话题</strong></p>
                     <ul>
                        <li><a href="datatypes-and-host-variables.html#GUID-D3262C5B-4A7F-44C7-A171-DC16441A31ED">Oracle数据类型</a></li>
                        <li><a href="C-Plus-Plus-Applications.html#GUID-49186B13-90DB-4C73-869E-2DF6D8CDE224">预编译C ++</a></li>
                     </ul>
                  </div>
               </div>
               <a id="LNPCC3980"></a><div class="props_rev_3"><a id="GUID-00167E7D-E2EE-46DC-9165-11314A0BDBDF" name="GUID-00167E7D-E2EE-46DC-9165-11314A0BDBDF"></a><h4 id="LNPCC-GUID-00167E7D-E2EE-46DC-9165-11314A0BDBDF" class="sect4"><span class="enumeration_section">12.1.1</span>无特殊宏处理</h4>
                  <div>
                     <p>将C ++与Pro * C / C ++一起使用不需要任何特殊的预处理或Pro * C / C ++外部的特殊宏处理器。无需在预编译器的输出上运行宏处理器即可实现C ++兼容性。</p>
                     <p>如果您是此版本之前的Pro * C / C ++预编译器版本的用户，并且您确实在预编译器输出上使用了宏处理器，那么您应该能够使用Pro * C / C ++预编译C ++应用程序，而无需更改码。</p>
                  </div>
               </div>
            </div><a id="LNPCC3981"></a><div class="props_rev_3"><a id="GUID-49186B13-90DB-4C73-869E-2DF6D8CDE224" name="GUID-49186B13-90DB-4C73-869E-2DF6D8CDE224"></a><h3 id="LNPCC-GUID-49186B13-90DB-4C73-869E-2DF6D8CDE224" class="sect3"><span class="enumeration_section">12.2</span> C ++的预编译</h3>
               <div>
                  <p>要控制预编译以使其适应C ++，有四个注意事项：</p>
                  <ul style="list-style-type:disc">
                     <li>
                        <p>预编译器的代码发射</p>
                     </li>
                     <li>
                        <p>解析能力</p>
                     </li>
                     <li>
                        <p>输出文件扩展名</p>
                     </li>
                     <li>
                        <p>系统头文件的位置</p>
                     </li>
                  </ul>
               </div><a id="LNPCC3982"></a><div class="props_rev_3"><a id="GUID-F558D5E9-59C1-4696-B4A6-7429C65AE6F0" name="GUID-F558D5E9-59C1-4696-B4A6-7429C65AE6F0"></a><h4 id="LNPCC-GUID-F558D5E9-59C1-4696-B4A6-7429C65AE6F0" class="sect4"><span class="enumeration_section">12.2.1</span>代码生成</h4>
                  <div>
                     <p>您必须能够指定预编译器生成的代码类型，C兼容代码或C ++兼容代码。Pro * C / C ++默认生成C代码。C ++不是C的完美超集。生成的代码需要进行一些更改，以便可以通过C ++编译器进行编译。</p>
                     <p>例如，除了发出应用程序代码之外，预编译器还会调用其运行时库SQLLIB。 SQLLIB中的函数是C函数。SQLLIB没有特殊的C ++版本。因此，如果要使用C ++编译器编译生成的代码，Pro * C / C ++必须将SQLLIB中调用的函数声明为C函数。</p>
                     <p>对于C输出，预编译器将生成诸如的原型</p><pre class="oac_no_warn" dir="ltr">void sqlora（unsigned long *，void *）;</pre><p>但对于C ++兼容代码，预编译器必须生成</p><pre class="oac_no_warn" dir="ltr">extern“C”{void sqlora（unsigned long *，void *）; };</pre><p>您可以使用预编译器选项CODE控制Pro * C / C ++生成的代码类型。此选项有三个值：CPP，KR_C和ANSI_C。可以通过考虑SQLLIB函数<span class="italic">sqlora</span>的声明如何在CODE选项的三个值之间不同来说明这些选项之间的差异：</p><pre class="oac_no_warn" dir="ltr">void sqlora（/ * _ unsigned long *，void * _ * /）; / * K＆R C * / void sqlora（unsigned long *，void *）; / * ANSI C * / extern“C”{/ * CPP * / void sqlora（unsigned long *，void *）; };</pre><p>指定CODE = CPP时，预编译器<a id="d72932e208" class="indexterm-anchor"></a></p>
                     <ul style="list-style-type:disc">
                        <li>
                           <p>生成C ++可编译代码。</p>
                        </li>
                        <li>
                           <p>为输出文件提供特定于平台的文件扩展名（后缀），例如“。C“或”.cc“，而不是标准的”.c“扩展名。（您可以使用CPP_SUFFIX选项覆盖它。）</p>
                        </li>
                        <li>
                           <p>导致PARSE选项的值默认为PARTIAL。您也可以指定PARSE = NONE。如果指定PARSE = FULL，则在预编译时发出错误。</p>
                        </li>
                        <li>
                           <p>允许在代码中使用C ++样式//注释。当CODE = CPP时，SQL语句和PL / SQL块中也允许使用这种注释方式。</p>
                        </li>
                        <li>
                           <p>Pro * C / C ++识别以// +开头的SQL优化器提示。<a id="d72932e228" class="indexterm-anchor"></a></p>
                        </li>
                        <li>
                           <p>要求OTT（对象类型转换器）生成的头文件必须包含在声明部分中。</p>
                           <div class="infoboxnotealso" id="GUID-F558D5E9-59C1-4696-B4A6-7429C65AE6F0__GUID-56991AFB-CD1F-410B-AF85-4CBC47CCE2E1">
                              <p class="notep1">也可以看看：</p>
                              <p><span class="q">“ <a href="precompiler-options.html#GUID-EA4E8928-3B92-4A29-BC1B-C726BFE4B79A">CODE</a> ”</span>有关CODE选项的KR_C和ANSI_C值的信息。
                              </p>
                           </div>
                        </li>
                     </ul>
                  </div>
               </div><a id="LNPCC3984"></a><a id="LNPCC3983"></a><div class="props_rev_3"><a id="GUID-EDDF500B-2973-4D1B-AC10-4952AE29E44D" name="GUID-EDDF500B-2973-4D1B-AC10-4952AE29E44D"></a><h4 id="LNPCC-GUID-EDDF500B-2973-4D1B-AC10-4952AE29E44D" class="sect4"><span class="enumeration_section">12.2.2</span>关于解析代码</h4>
                  <div>
                     <p>您必须能够控制Pro * C / C ++ C解析器对代码的影响。您可以使用PARSE预编译器选项来执行此操作，该选项控制预编译器的C解析器如何处理您的代码。</p>
                     <p>PARSE选项的值和效果是：</p>
                     <div class="tblformal" id="GUID-EDDF500B-2973-4D1B-AC10-4952AE29E44D__GUID-899802DA-238A-4581-9803-EBE92B86CA7E">
                        <p class="titleintable">表12-1 PARSE选项的值和效果</p>
                        <table cellpadding="4" cellspacing="0" class="Formal" title="PARSE期权的价值和影响" width="100%" border="1" summary="Values and Effects of the PARSE Option" frame="hsides" rules="rows">
                           <thead>
                              <tr align="left" valign="top">
                                 <th align="left" valign="bottom" width="31%" id="d72932e279">值</th>
                                 <th align="left" valign="bottom" width="69%" id="d72932e282">效果</th>
                              </tr>
                           </thead>
                           <tbody>
                              <tr align="left" valign="top">
                                 <td align="left" valign="top" width="31%" id="d72932e287" headers="d72932e279 ">
                                    <p>PARSE = NONE</p>
                                 </td>
                                 <td align="left" valign="top" width="69%" headers="d72932e287 d72932e282 ">
                                    <p>值NONE具有以下效果：</p>
                                    <ul style="list-style-type:disc">
                                       <li>
                                          <p>只有声明部分才能理解C预处理程序指令。</p>
                                       </li>
                                       <li>
                                          <p>您必须在Declare Section中声明所有主变量。</p>
                                       </li>
                                       <li>
                                          <p>预编译器发布1.x行为</p>
                                       </li>
                                    </ul>
                                 </td>
                              </tr>
                              <tr align="left" valign="top">
                                 <td align="left" valign="top" width="31%" id="d72932e304" headers="d72932e279 ">
                                    <p>PARSE =部分</p>
                                 </td>
                                 <td align="left" valign="top" width="69%" headers="d72932e304 d72932e282 ">
                                    <p>PARTIAL值具有以下效果：</p>
                                    <ul style="list-style-type:disc">
                                       <li>
                                          <p>所有预处理器指令都被理解</p>
                                       </li>
                                       <li>
                                          <p>您必须在Declare Section中声明所有主变量</p>
                                       </li>
                                    </ul>
                                    <p>如果CODE = CPP，则此选项值是默认值</p>
                                 </td>
                              </tr>
                              <tr align="left" valign="top">
                                 <td align="left" valign="top" width="31%" id="d72932e320" headers="d72932e279 ">
                                    <p>PARSE = FULL</p>
                                 </td>
                                 <td align="left" valign="top" width="69%" headers="d72932e320 d72932e282 ">
                                    <p>值FULL具有以下效果：</p>
                                    <ul style="list-style-type:disc">
                                       <li>
                                          <p>预编译器C解析器在您的代码上运行。</p>
                                       </li>
                                       <li>
                                          <p>所有预处理程序指令都被理解。</p>
                                       </li>
                                       <li>
                                          <p>您可以在任何可以在C中合法声明的地方声明主变量。</p>
                                       </li>
                                    </ul>
                                 </td>
                              </tr>
                           </tbody>
                        </table>
                     </div>
                     <!-- class="inftblhruleinformal" -->
                     <p>如果CODE选项的值不是CPP，则此选项值是默认值。当CODE = CPP时指定PARSE = FULL是错误的。</p>
                     <p>要生成C ++兼容代码，PARSE选项必须是NONE或PARTIAL。如果PARSE = FULL，则C语法分析器运行，并且它不理解代码中的C ++构造，例如类。</p>
                  </div>
               </div><a id="LNPCC3985"></a><div class="props_rev_3"><a id="GUID-F2D26A5A-6AF0-4B49-B250-212A0419D0D4" name="GUID-F2D26A5A-6AF0-4B49-B250-212A0419D0D4"></a><h4 id="LNPCC-GUID-F2D26A5A-6AF0-4B49-B250-212A0419D0D4" class="sect4"><span class="enumeration_section">12.2.3</span>输出文件名扩展名</h4>
                  <div>
                     <p>大多数C编译器都希望输入文件的默认扩展名为“.c”。但是，不同的C ++编译器可以期望不同的文件扩展名。CPP_SUFFIX选项提供了指定预编译器生成的文件扩展名的功能。此选项的值是一个字符串，不带引号或句点。例如，CPP_SUFFIX = cc或CPP_SUFFIX = C.<a id="d72932e365" class="indexterm-anchor"></a></p>
                  </div>
               </div><a id="LNPCC3986"></a><div class="props_rev_3"><a id="GUID-C5634ECF-D80C-44D8-BA5E-E730C6193912" name="GUID-C5634ECF-D80C-44D8-BA5E-E730C6193912"></a><h4 id="LNPCC-GUID-C5634ECF-D80C-44D8-BA5E-E730C6193912" class="sect4"><span class="enumeration_section">12.2.4</span>系统头文件</h4>
                  <div>
                     <p><a id="d72932e392" class="indexterm-anchor"></a> Pro * C / C ++在特定于平台的标准位置搜索标准系统头文件，例如<code class="codeph">stdio.h</code> 。Pro * C / C ++不会搜索带有扩展名的头文件，例如<code class="codeph">hpp</code>或<code class="codeph">h</code> ++。例如，在几乎所有UNIX系统上，文件<code class="codeph">stdio.h</code>都具有完整路径名<code class="codeph">/usr/include/stdio.h</code> 。
                     </p>
                     <p>但是C ++编译器有自己的<code class="codeph">stdio.h</code>版本，它不在标准系统位置。在为C ++进行预编译时，必须使用SYS_INCLUDE预编译器选项指定Pro * C / C ++搜索以查找系统头文件的目录路径。例如：<a id="d72932e417" class="indexterm-anchor"></a></p><pre class="oac_no_warn" dir="ltr">SYS_INCLUDE =（在/ usr /郎/ SC2.0.1 /包括，在/ usr /郎/ SC2.1.1 /包括）</pre><p>使用INCLUDE预编译器选项指定非系统头文件的位置。在INCLUDE选项指定的目录之前搜索SYS_INCLUDE选项指定的目录。</p>
                     <p>如果PARSE = NONE，则系统文件的SYS_INCLUDE和INCLUDE中指定的值不相关，因为Pro * C / C ++不需要包含系统头文件。（当然，您仍然可以使用EXEC SQL INCLUDE语句包含Pro * C / C ++特定的头文件，例如<code class="codeph">sqlca.h</code> 。）
                     </p>
                  </div>
                  <div>
                     <div class="relinfo">
                        <p><strong>相关话题</strong></p>
                        <ul>
                           <li><a href="precompiler-options.html#GUID-08EDB388-0406-4F03-9D9F-E0AAA8ADB2B5">包括</a></li>
                        </ul>
                     </div>
                  </div>
                  
               </div>
            </div><a id="LNPCC3987"></a><div class="props_rev_3"><a id="GUID-EAC4F5AA-A221-4E17-B6CB-ECCFA0748392" name="GUID-EAC4F5AA-A221-4E17-B6CB-ECCFA0748392"></a><h3 id="LNPCC-GUID-EAC4F5AA-A221-4E17-B6CB-ECCFA0748392" class="sect3"><span class="enumeration_section">12.3</span>示例程序</h3>
               <div>
                  <div class="section">
                     <p>本节包括三个包含C ++构造的Pro * C / C ++程序示例。这些程序中的每一个都可以在您的<code class="codeph">demo</code>目录中在线获得。
                     </p>
                  </div>
                  <!-- class="section" -->
               </div><a id="LNPCC3988"></a><div class="props_rev_3"><a id="GUID-C9F65B56-BF96-4BAA-B9C5-6B7053574FB0" name="GUID-C9F65B56-BF96-4BAA-B9C5-6B7053574FB0"></a><h4 id="LNPCC-GUID-C9F65B56-BF96-4BAA-B9C5-6B7053574FB0" class="sect4"><span class="enumeration_section">12.3.1</span> cppdemo1.pc</h4>
                  <div>
                     <div class="section"><pre class="oac_no_warn" dir="ltr">/ * cppdemo1.pc * *提示用户输入员工编号，然后在* emp表中查询员工的姓名，工资和佣金。*使用指标变量（在指标结构中）*确定佣金是否为空。 * / #include &lt;iostream.h&gt; #include &lt;stdio.h&gt; #include &lt;string.h&gt; //当code = cpp时，默认情况下Parse = partial，//因此可以完全识别和解析预处理器指令。#define UNAME_LEN 20 #define PWD_LEN 40 //当CODE = CPP或// PARSE = {PARTIAL | NONE}或两者都需要声明部分。EXEC SQL BEGIN DECLARE SECTION; VARCHAR用户名[UNAME_LEN]; // VARCHAR是ORACLE假型varchar密码[PWD_LEN]; //也可以是小写//为SELECT语句构造输出值//的主机结构struct empdat {VARCHAR emp_name [UNAME_LEN];浮动工资;浮动佣金; } emprec; //定义一个指示符结构，以对应于// host输出struct struct empind {short emp_name_ind;短sal_ind;简短的comm_ind; } emprec_ind; //输入主变量int emp_number; int total_queried; EXEC SQL END DECLARE SECTION; //定义一个C ++类对象，以匹配前面声明部分中所需的//结构。class emp {char ename [UNAME_LEN];浮动工资;浮动佣金; public：//定义//接受普通C对象的此C ++对象的构造函数。emp（empdat＆，empind＆）;朋友ostream＆operator &lt;&lt;（ostream＆，emp＆）; }; emp :: emp（empdat＆dat，empind＆ind）{strncpy（ename，（char *）dat.emp_name.arr，dat.emp_name.len）; ename [dat.emp_name.len] ='\ 0'; this-&gt; salary = dat.salary; this-&gt; commission =（ind.comm_ind &lt;0）？0：dat.commission; } ostream＆operator &lt;&lt;（ostream＆s，emp＆e）{return s &lt;&lt; e.ename &lt;&lt;“获得”&lt;&lt; e.salary &lt;&lt;“加上”&lt;&lt; e.commission &lt;&lt;“佣金。” &lt;&lt; endl &lt;&lt; endl; } //包含SQL通信区//可以使用#include或EXEC SQL INCLUDE #include &lt;sqlca.h&gt; //声明错误处理函数void sql_error（char * msg）; main（）{char temp_char [32]; //将sql_error（）注册为错误处理程序EXEC SQL WHENEVER SQLERROR DO sql_error（“ORACLE error：”）; //连接到ORACLE。程序调用sql_error（）//如果发生错误//连接到默认数据库时。//注意//复制到VARCHAR数组缓冲区时的（char *）强制转换。username.len = strlen（strcpy（（char *）username.arr，“SCOTT”））; password.len = strlen（strcpy（（char *）password.arr，“TIGER”））; EXEC SQL CONNECT：用户名IDENTIFIED BY：密码; //再次注意使用VARCHAR时的（char *）强制转换cout &lt;&lt;“\ n以用户身份连接到ORACLE：”&lt;&lt;（char *）username.arr &lt;&lt; endl &lt;&lt; endl; //循环，选择个别员工的结果total_queried = 0; while（1）{emp_number = 0; printf（“输入员工编号（0退出）：”）;得到（temp_char）; emp_number = atoi（temp_char）; if（emp_number == 0）中断; //当// 1403（“找不到数据”）条件发生时转移到notfound标签EXEC SQL WHENEVER NOT FOUND GOTO notfound; EXEC SQL SELECT ename，sal，comm INTO：emprec INDICATOR：emprec_ind //您还可以在SQL statemtents中使用// C ++样式FROM EMP //注释。在哪里EMPNO =：emp_number; {//基本思路是将C对象传递给// C ++构造函数，从而创建//通常的C ++方式使用的等效C ++对象（emprec，emprec_ind）; cout &lt;&lt; e; } total_queried ++;继续; notfound：cout &lt;&lt;“不是有效的员工编号 - 再试一次。” &lt;&lt; endl &lt;&lt; endl; } // end while（1）cout &lt;&lt; endl &lt;&lt;“返回的总行数为”&lt;&lt; total_queried &lt;&lt; endl; cout &lt;&lt;“祝你有愉快的一天！“&lt;&lt; endl &lt;&lt; endl; //断开与ORACLE EXEC SQL COMMIT WORK RELEASE的连接;退出（0）;} void sql_error（char * msg）{EXEC SQL WHENEVER SQLERROR CONTINUE; cout &lt;&lt; endl &lt;&lt; msg &lt;&lt; endl; cout &lt;&lt; sqlca.sqlerrm.sqlerrmc &lt;&lt; endl; EXEC SQL ROLLBACK RELEASE; exit（1）;}</pre></div>
                     <!-- class="section" -->
                  </div>
               </div><a id="LNPCC3989"></a><div class="props_rev_3"><a id="GUID-9BEE0210-E71C-4F84-A30D-D2898CBFF075" name="GUID-9BEE0210-E71C-4F84-A30D-D2898CBFF075"></a><h4 id="LNPCC-GUID-9BEE0210-E71C-4F84-A30D-D2898CBFF075" class="sect4"><span class="enumeration_section">12.3.2</span> cppdemo2.pc</h4>
                  <div>
                     <div class="section">
                        <p>下一个应用程序是一个简单的模块化示例首先，在SQL * Plus中执行以下SQL脚本<code class="codeph">cppdemo2.sql</code> ：</p><pre class="oac_no_warn" dir="ltr"><a id="d72932e528" class="indexterm-anchor"></a> Rem这是cppdemo2 C ++ Demo Rem程序附带的SQL脚本。在预编译empclass.pc文件之前运行此命令。/ CONNECT SCOTT / TIGER / CREATE或REPLACE VIEW emp_view AS SELECT ename，empno FROM EMP / CREATE OR REPLACE PACKAGE emp_package AS TYPE emp_cursor_type IS REF CURSOR RETURN emp_view％ROWTYPE; PROCEDURE open_cursor（curs IN OUT emp_cursor_type）; END emp_package; / CREATE OR REPLACE PACKAGE BODY emp_package AS PROCEDURE open_cursor（curs IN OUT emp_cursor_type）IS BEGIN OPEN curs FOR SELECT ename，empno FROM emp_view ORDER BY ename ASC;结束; END emp_package; / 出口 /</pre><p>头文件<code class="codeph">empclass.h</code>定义了类<code class="codeph">emp</code> ：</p><pre class="oac_no_warn" dir="ltr">//此类定义可以仅使用EXEC SQL INCLUDE指令包含在Pro * C / C ++应用程序中。因为//包含EXEC SQL语法，所以可能不会使用#include //指令包含它。必须使用CODE = CPP选项对包含此标头的任何程序进行预编译。在构建cppdemo2 C ++演示程序时使用此emp类定义。class emp {public：emp（）; //构造函数：ALLOCATE Cursor Variable~emp（）; // Desctructor：FREE Cursor Variable void open（）; // Open Cursor void fetch（）throw（int）; // Fetch（throw NOT FOUND条件）void close（）; //关闭Cursor void emp_error（）; //错误处理程序EXEC SQL BEGIN DECLARE SECTION; //当使用EXEC SQL INCLUDE包含时，类变量具有//全局范围，因此在预编译期间基本上被Pro * C / C ++视为普通//全局变量。char ename [10]; int empno; EXEC SQL END DECLARE SECTION; private：EXEC SQL BEGIN DECLARE SECTION; // Pro * C / C ++也将此视为一个简单的全局变量。SQL_CURSOR \ temp_cursor; EXEC SQL END DECLARE SECTION; };</pre><p><code class="codeph">empclass.pc</code>中的代码包含<code class="codeph">emp</code>方法：</p><pre class="oac_no_warn" dir="ltr">#include &lt;stdio.h&gt; #include &lt;stdlib.h&gt; //此示例使用// emp类实现共享的单个（全局）SQLCA以及此//应用程序的主程序。#define SQLCA_STORAGE_CLASS extern #include &lt;sqlca.h&gt; //在类体的实现中包含emp类规范以及使用它的应用程序。EXEC SQL INCLUDE empclass.h; emp :: emp（）{// WHENEVER语句的范围跨越整个模块。//请注意，错误处理函数实际上是emp类的成员函数。EXEC SQL WHENEVER SQLERROR DO emp_error（）; EXEC SQL ALLOCATE：emp_cursor; //构造函数 -  ALLOCATE Cursor。} emp :: ~emp（）{EXEC SQL FREE：emp_cursor; //析构函数 - 自由光标。} void emp :: open（）{EXEC SQL EXECUTE BEGIN emp_package.open_cursor（：emp_cursor）;结束; END-EXEC; } void emp :: close（）{EXEC SQL CLOSE：emp_cursor; void emp :: fetch（）throw（int）{EXEC SQL FETCH：emp_cursor INTO：ename，：empno; if（sqlca.sqlcode == 1403）抛出sqlca.sqlcode; //就像一个WHENEVER NOT FOUND语句。} void emp :: emp_error（）{printf（“％。* s \ n”，sqlca.sqlerrm.sqlerrml，sqlca.sqlerrm.sqlerrmc）; EXEC SQL WHENEVER SQLERROR CONTINUE; EXEC SQL ROLLBACK工作版;出口（1）; }</pre><p>主程序<code class="codeph">cppdemo2.pc</code>使用游标变量：</p><pre class="oac_no_warn" dir="ltr">// Pro * C / C ++示例程序演示了在C ++类框架中实现的Cursor Variables的简单使用。按如下方式构建此程序// // 1。在SQL * Plus // 2中执行cppdemo2.sql脚本。预编译empclass.pc程序如下//&gt; proc code = cpp sqlcheck = full user = scott / tiger lines = yes empclass // 3。预编译cppdemo2.pc程序如下//&gt; proc code = cpp lines = yes cppdemo2 // 4。编译和链接// //请注意，在预编译时，您可能必须使用// include选项指定各种包含目录。#include &lt;stdio.h&gt; #include &lt;stdlib.h&gt; #include &lt;sqlca.h&gt; static void sql_error（）{printf（“％。* s \ n”，sqlca.sqlerrm.sqlerrml，sqlca.sqlerrm.sqlerrmc） ; EXEC SQL WHENEVER SQLERROR CONTINUE; EXEC SQL ROLLBACK工作版;出口（1）; } //在此模块中物理包含emp类定义。EXEC SQL INCLUDE empclass.h; int main（）{EXEC SQL BEGIN DECLARE SECTION; char * uid =“scott / tiger”; EXEC SQL END DECLARE SECTION;执行SQL WHENEVER SQLERROR DO sql_error（）; EXEC SQL CONNECT：uid; emp * e = new emp（）; //调用构造函数 -  ALLOCATE游标变量。E-&gt;开（）; //打开光标。while（1）{//从Cursor中获取，捕获由fetch（）成员函数抛出的NOT FOUND条件。尝试{e-&gt; fetch（）; } catch（int code）{if（code == 1403）break; } printf（“员工：％s [％d] \ n”，e-&gt; ename，e-&gt; empno）; } e-&gt; close（）; //关闭光标。删除e; //调用析构函数 -  FREE游标变量。EXEC SQL ROLLBACK工作版; return（0）; }</pre></div>
                     <!-- class="section" -->
                  </div>
               </div><a id="LNPCC3990"></a><div class="props_rev_3"><a id="GUID-3E9AB68E-38A8-4DF7-8695-AB2D4C905BBF" name="GUID-3E9AB68E-38A8-4DF7-8695-AB2D4C905BBF"></a><h4 id="LNPCC-GUID-3E9AB68E-38A8-4DF7-8695-AB2D4C905BBF" class="sect4"><span class="enumeration_section">12.3.3</span> cppdemo3.pc</h4>
                  <div>
                     <div class="section"><pre class="oac_no_warn" dir="ltr">/ * * cppdemo3.pc：C ++继承的一个例子* *该程序找到所有销售人员并打印他们的名字*，然后是他们总共赚取多少（即包括*任何佣金）。* / #include &lt;iostream.h&gt; #include &lt;stdio.h&gt; #include &lt;sqlca.h&gt; #include &lt;string.h&gt; #define NAMELEN 10 class employee {//基类是一个简单的员工public：char ename [ NAMELEN]; int sal; employee（char *，int）; }; employee :: employee（char * ename，int sal）{strcpy（this-&gt; ename，ename）; this-&gt; sal = sal; } //推销员是一种员工类推销员：public employee {int comm; public：salesman（char *，int，int）;朋友ostream＆operator &lt;&lt;（ostream＆，salesman＆）; }; //继承员工属性salesman :: salesman（char * ename，int sal，int comm）：employee（ename，sal），comm（comm）{} ostream＆operator &lt;&lt;（ostream＆s，salesman＆m）{return s &lt;&lt; m.ename &lt;&lt; m.sal + m.comm &lt;&lt; endl; void print（char * ename，int sal，int comm）{salesman man（ename，sal，comm）; cout &lt;&lt; man; } main（）{EXEC SQL BEGIN DECLARE SECTION; char * uid =“scott / tiger”; char ename [NAMELEN]; int sal，comm;简短的comm_ind; EXEC SQL END DECLARE SECTION;执行SQL WHENEVER SQLERROR GOTO错误; EXEC SQL CONNECT：uid; EXEC SQL DECLARE c CURSOR FOR SELECT ename，sal，comm FROM emp WHERE job ='SALESMAN'ORDER BY ename; EXEC SQL OPEN c; cout &lt;&lt;“姓名薪水”&lt;&lt; endl &lt;&lt;“------ ------”&lt;&lt; endl; EXEC SQL WHENEVER NOT FOUND DO break; while（1）{EXEC SQL FETCH c INTO：ename，：sal，：comm：comm_ind; print（ename，sal，（comm_ind &lt;0）？0：comm）; } EXEC SQL CLOSE c;出口（0）;错误：cout &lt;&lt; endl &lt;&lt; sqlca.sqlerrm.sqlerrmc &lt;&lt; endl;出口（1）; }</pre></div>
                     <!-- class="section" -->
                  </div>
               </div>
            </div>
         </div>
      </article>
   </body>
</html>