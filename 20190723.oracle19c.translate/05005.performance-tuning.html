<html lang="en-us" dir="ltr" xml:lang="en-us">
   <head>
      <meta http-equiv="Content-Type" content="text/html; charset=utf-8"></meta>
      <meta name="viewport" content="width=device-width, initial-scale=1"></meta>
      <meta http-equiv="X-UA-Compatible" content="IE=edge"></meta>
      <title>性能调优</title>
      <meta property="og:site_name" content="Oracle Help Center"></meta>
      <meta property="og:title" content="Programmer&#39;s Guide"></meta>
      <meta property="og:description" content=""></meta>
      <link rel="stylesheet" href="/sp_common/book-template/ohc-book-template/css/book.css"></link>
      <link rel="shortcut icon" href="/sp_common/book-template/ohc-common/img/favicon.ico"></link>
      <meta name="application-name" content="Programmer&#39;s Guide"></meta>
      <meta name="generator" content="DITA Open Toolkit version 1.8.5 (Mode = doc)"></meta>
      <meta name="plugin" content="SP_docbuilder HTML plugin release 18.2.2"></meta>
      <link rel="alternate" href="c-c-programmers-guide.pdf" title="PDF File" type="application/pdf"></link>
      <meta name="robots" content="all"></meta>
      <link rel="schema.dcterms" href="http://purl.org/dc/terms/"></link>
      <meta name="dcterms.created" content="2019-01-11T03:52:01-08:00"></meta>
      
      <meta name="dcterms.dateCopyrighted" content="1996, 2019"></meta>
      <meta name="dcterms.category" content="database"></meta>
      <meta name="dcterms.identifier" content="E96467-01"></meta>
      
      <meta name="dcterms.product" content="en/database/oracle/oracle-database/19"></meta>
      
      <link rel="prev" href="reserved-words-keywords-namespaces.html" title="Previous" type="text/html"></link>
      <link rel="next" href="syntactic-and-semantic-checking.html" title="Next" type="text/html"></link>
      <script>
        document.write('<style type="text/css">');
        document.write('body > .noscript, body > .noscript ~ * { visibility: hidden; }');
        document.write('</style>');
     </script>
      <script src="/sp_common/book-template/requirejs/require.js" data-main="/sp_common/book-template/ohc-book-template/js/book-config"></script>
      <script>
            if (window.require === undefined) {
                document.write('<script data-main="sp_common/book-template/ohc-book-template/js/book-config" src="sp_common/book-template/requirejs/require.js"><\/script>');
                document.write('<link href="sp_common/book-template/ohc-book-template/css/book.css" rel="stylesheet"/>');
            }
        </script>
      <script type="application/json" id="ssot-metadata">{"primary":{"category":{"short_name":"database","element_name":"Database","display_in_url":true},"suite":{"short_name":"oracle","element_name":"Oracle","display_in_url":true},"product_group":{"short_name":"not-applicable","element_name":"Not applicable","display_in_url":false},"product":{"short_name":"oracle-database","element_name":"Oracle Database","display_in_url":true},"release":{"short_name":"19","element_name":"Release 19","display_in_url":true}}}</script>
      
    <meta name="dcterms.title" content="Pro*C/C++ Programmer&#39;s Guide"></meta>
    <meta name="dcterms.isVersionOf" content="LNPCC"></meta>
    <meta name="dcterms.release" content="Release 19"></meta>
  </head>
   <body dir="ltr">
      <div class="noscript alert alert-danger text-center" role="alert">
         <a href="reserved-words-keywords-namespaces.html" class="pull-left"><span class="glyphicon glyphicon-chevron-left" aria-hidden="true"></span>上一页</a> <a href="syntactic-and-semantic-checking.html" class="pull-right">下一页<span class="glyphicon glyphicon-chevron-right" aria-hidden="true"></span></a> <span class="fa fa-exclamation-triangle" aria-hidden="true"></span>必须启用JavaScript才能正确显示此内容</div>
      <article>
         <header>
            <ol class="breadcrumb" vocab="http://schema.org/" typeof="BreadcrumbList">
               <li property="itemListElement" typeof="ListItem"><a href="index.html" property="item" typeof="WebPage"><span property="name">程序员指南</span></a></li>
               <li property="itemListElement" typeof="ListItem"><a href="appendixes.html" property="item" typeof="WebPage"><span property="name">附录</span></a></li>
               <li class="active" property="itemListElement" typeof="ListItem">性能调优</li>
            </ol>
            <a id="GUID-70BC5747-18C2-4017-AC44-500891008097" name="GUID-70BC5747-18C2-4017-AC44-500891008097"></a><a id="LNPCC023"></a>
            
            <h2 id="LNPCC-GUID-70BC5747-18C2-4017-AC44-500891008097" class="sect2"><span class="enumeration_chapter">B</span>性能调整</h2>
         </header>
         <div class="ind">
            <div>
               <p>本附录向您展示了一些简单易用的方法，可以提高应用程序的性能。使用这些方法，您通常可以将处理时间缩短25％或更多。本附录包含以下主题：</p>
               <ul style="list-style-type:disc">
                  <li>
                     <p><a href="performance-tuning.html#GUID-202E5664-DE49-4AF2-84C4-46FD0E530382">什么导致表现不佳？</a></p>
                  </li>
                  <li>
                     <p><a href="performance-tuning.html#GUID-AA4A3450-10AC-4D68-817B-383E0E19C521">如何改进性能？</a></p>
                  </li>
                  <li>
                     <p><a href="performance-tuning.html#GUID-2989CC58-E238-41B7-B9A4-3401B2FAE8EE">关于使用主机阵列</a></p>
                  </li>
                  <li>
                     <p><a href="performance-tuning.html#GUID-969E1F8A-3380-4B6F-8337-15EE0E68D858">关于使用嵌入式PL / SQL</a></p>
                  </li>
                  <li>
                     <p><a href="performance-tuning.html#GUID-15C3024A-8425-4D18-A4A0-B673BE8F676E">关于优化SQL语句</a></p>
                  </li>
                  <li>
                     <p><a href="performance-tuning.html#GUID-AE542335-820C-4F3B-876D-74621D4C1DBD">关于语句缓存</a></p>
                  </li>
                  <li>
                     <p><a href="performance-tuning.html#GUID-6ABFCC28-2166-47F2-B188-D8D03B4158F0">关于使用索引</a></p>
                  </li>
                  <li>
                     <p><a href="performance-tuning.html#GUID-E9767A74-C760-42A4-9829-4CF99F09918C">关于利用行级锁定</a></p>
                  </li>
                  <li>
                     <p><a href="performance-tuning.html#GUID-A12D1A51-23B1-4B1F-A539-F89035B175F8">关于消除不必要的解析</a></p>
                  </li>
                  <li>
                     <p><a href="performance-tuning.html#GUID-2FD19C63-B523-4B93-9FB1-CDD376EA2423">关于使用连接池</a></p>
                  </li>
                  <li>
                     <p><a href="performance-tuning.html#GUID-BF9AFFD6-537A-4252-BBFB-3A60EEAC3E61" title="Traffic Director Mode中的Oracle Connection Manager是一个放置在支持的数据库客户端和数据库实例之间的代理。">关于在Traffic Director模式下使用Oracle Connection Manager</a></p>
                  </li>
               </ul>
            </div><a id="LNPCC4556"></a><div class="props_rev_3"><a id="GUID-202E5664-DE49-4AF2-84C4-46FD0E530382" name="GUID-202E5664-DE49-4AF2-84C4-46FD0E530382"></a><h3 id="LNPCC-GUID-202E5664-DE49-4AF2-84C4-46FD0E530382" class="sect3"><span class="enumeration_section">B.1</span>导致性能不佳的原因？
               </h3>
               <div>
                  <p>性能不佳的一个原因是高通信开销。服务器必须一次处理一个SQL语句。因此，每个语句都会导致对单个和更高开销的另一个调用。在网络环境中，必须通过网络发送SQL语句，从而增加网络流量。繁重的网络流量会显着降低您的应用程序速度<a id="d114141e104" class="indexterm-anchor"></a><a id="d114141e108" class="indexterm-anchor"></a> 
                  </p>
                  <p>性能不佳的另一个原因是效率低下的SQL语句。因为SQL非常灵活，所以可以使用两个不同的语句获得相同的结果，但是一个语句可能效率较低。例如，以下两个SELECT语句返回相同的行（每个部门的名称和编号至少有一名员工）：</p><pre class="oac_no_warn" dir="ltr">EXEC SQL SELECT dname，deptno FROM dept WHERE deptno IN（SELECT deptno FROM emp）; EXEC SQL SELECT dname，deptno FROM dept WHERE EXISTS（SELECT deptno FROM emp WHERE dept.deptno = emp.deptno）;</pre><p>但是，第一个语句较慢，因为它对DEPT表中的每个部门号执行耗时的EMP表全扫描。即使EMP中的DEPTNO列已编制索引，也不会使用索引，因为子查询缺少一个命名DEPTNO的WHERE子句。</p>
                  <p>性能不佳的第三个原因是不必要的解析和绑定。回想一下，在执行SQL语句之前，服务器必须解析并绑定它。解析意味着检查SQL语句以确保它遵循语法规则并引用有效的数据库对象。绑定意味着将SQL语句中的主机变量与其地址相关联，以便服务器可以读取或写入其值。</p>
                  <p>许多应用程序管理游标很差。这导致不必要的解析和绑定，这显着增加了处理开销。</p>
               </div>
            </div><a id="LNPCC4557"></a><div class="props_rev_3"><a id="GUID-AA4A3450-10AC-4D68-817B-383E0E19C521" name="GUID-AA4A3450-10AC-4D68-817B-383E0E19C521"></a><h3 id="LNPCC-GUID-AA4A3450-10AC-4D68-817B-383E0E19C521" class="sect3"><span class="enumeration_section">B.2</span>如何改进性能？
               </h3>
               <div>
                  <p>如果您对预编译程序的性能不满意，可以通过多种方法减少开销。</p>
                  <p>您可以大大减少通信开销，尤其是在网络环境中<a id="d114141e147" class="indexterm-anchor"></a> 
                  </p>
                  <ul style="list-style-type:disc">
                     <li>
                        <p>使用主机阵列</p>
                     </li>
                     <li>
                        <p>使用嵌入式PL / SQL</p>
                     </li>
                  </ul>
                  <p>您可以减少处理开销 - 有时可以显着降低</p>
                  <ul style="list-style-type:disc">
                     <li>
                        <p>优化SQL语句</p>
                     </li>
                     <li>
                        <p>使用索引</p>
                     </li>
                     <li>
                        <p>利用行级锁定</p>
                     </li>
                     <li>
                        <p>消除不必要的解析</p>
                     </li>
                     <li>
                        <p>避免不必要的重新分析</p>
                     </li>
                  </ul>
                  <p>以下部分将介绍减少开销的每种方法。</p>
               </div>
            </div><a id="LNPCC4558"></a><div class="props_rev_3"><a id="GUID-2989CC58-E238-41B7-B9A4-3401B2FAE8EE" name="GUID-2989CC58-E238-41B7-B9A4-3401B2FAE8EE"></a><h3 id="LNPCC-GUID-2989CC58-E238-41B7-B9A4-3401B2FAE8EE" class="sect3"><span class="enumeration_section">B.3</span>关于使用主机阵列</h3>
               <div>
                  <p>主机阵列可以提高性能，因为它们允许您使用单个SQL语句操作整个数据集合。例如，假设您要将300名员工的工资插入EMP表。如果没有数组，您的程序必须执行300个单独的INSERT  - 每个员工一个。对于数组，只需要一个INSERT。请考虑以下声明： <a id="d114141e204" class="indexterm-anchor"></a><a id="d114141e208" class="indexterm-anchor"></a> 
                  </p><pre class="oac_no_warn" dir="ltr">EXEC SQL INSERT INTO emp（sal）VALUES（：salary）;</pre><p>如果<span class="italic">salary</span>是一个简单的宿主变量，则服务器执行一次INSERT语句，将一行插入EMP表。在该行中，SAL列具有<span class="italic">salary</span>的值。要以这种方式插入300行，必须执行300次INSERT语句。
                  </p>
                  <p>但是，如果<span class="italic">salary</span>是大小为300的主机数组，则会立即将所有300行插入到EMP表中。在每一行中，SAL列都具有<span class="italic">salary</span>数组中元素的值。
                  </p>
               </div>
               <div>
                  <div class="relinfo">
                     <p><strong>相关话题</strong></p>
                     <ul>
                        <li><a href="host-arrays.html#GUID-6B57FBAE-0303-41B9-9056-5C20384442B7">主机阵列</a></li>
                     </ul>
                  </div>
               </div>
               
            </div><a id="LNPCC4560"></a><a id="LNPCC4559"></a><div class="props_rev_3"><a id="GUID-969E1F8A-3380-4B6F-8337-15EE0E68D858" name="GUID-969E1F8A-3380-4B6F-8337-15EE0E68D858"></a><h3 id="LNPCC-GUID-969E1F8A-3380-4B6F-8337-15EE0E68D858" class="sect3"><span class="enumeration_section">B.4</span>关于使用嵌入式PL / SQL</h3>
               <div>
                  <p><a href="performance-tuning.html#GUID-969E1F8A-3380-4B6F-8337-15EE0E68D858__CHEBHDFF">如图B-1</a>所示，如果您的应用程序是数据库密集型的，您可以使用控制结构将PL语句分组，然后将整个块发送到数据库服务器。这可以大大减少应用程序和数据库服务器之间的通信。<a id="d114141e267" class="indexterm-anchor"></a><a id="d114141e271" class="indexterm-anchor"></a></p>
                  <p>此外，您可以使用PL / SQL子程序来减少从应用程序到服务器的调用。例如，要执行十个单独的SQL语句，需要进行十次调用，但要执行包含十个SQL语句的子程序，只需要一次调用。</p>
                  <div class="figure" id="GUID-969E1F8A-3380-4B6F-8337-15EE0E68D858__CHEBHDFF">
                     <p class="titleinfigure">图B-1 PL / SQL提升性能</p><img src="img/lnpcc019.gif" width="499" alt="下面描述图B-1" title="下面描述图B-1" longdesc="img_text/lnpcc019.html"><br><a href="img_text/lnpcc019.html">“图B-1 PL / SQL提升性能”的描述</a></div>
                  <!-- class="figure" -->
                  <p>PL / SQL还可以与Oracle应用程序开发工具（如Oracle Forms）配合使用。通过为这些工具添加程序处理能力，PL / SQL提高了性能。使用PL / SQL，工具可以快速有效地进行任何计算，而无需调用数据库服务器。这样可以节省时间并减少网络流量。 <a id="d114141e284" class="indexterm-anchor"></a> 
                  </p>
               </div>
               <div>
                  <div class="relinfo">
                     <p><strong>相关话题</strong></p>
                     <ul>
                        <li><a href="embedded-PL-SQL.html#GUID-BCE83EB3-88D8-4EA1-853F-D5B66D426654">嵌入式PL / SQL</a></li>
                        <li><a href="../lnpls/index.html" target="_blank"><span><cite>Oracle数据库PL / SQL语言参考</cite></span></a></li>
                     </ul>
                  </div>
               </div>
            </div><a id="LNPCC4561"></a><div class="props_rev_3"><a id="GUID-15C3024A-8425-4D18-A4A0-B673BE8F676E" name="GUID-15C3024A-8425-4D18-A4A0-B673BE8F676E"></a><h3 id="LNPCC-GUID-15C3024A-8425-4D18-A4A0-B673BE8F676E" class="sect3"><span class="enumeration_section">B.5</span>关于优化SQL语句</h3>
               <div>
                  <p>对于每个SQL语句，Oracle优化器都会生成一个<span class="italic">执行计划</span> ，该<span class="italic">计划</span>是服务器执行该语句所需的一系列步骤。这些步骤由Oracle Application Developer's Guide  -  Fundamentals中给出的规则确定。遵循这些规则将帮助您编写最佳SQL语句。<a id="d114141e327" class="indexterm-anchor"></a><a id="d114141e331" class="indexterm-anchor"></a><a id="d114141e335" class="indexterm-anchor"></a><a id="d114141e337" class="indexterm-anchor"></a></p>
               </div><a id="LNPCC4562"></a><div class="props_rev_3"><a id="GUID-DF15DFCE-BA9E-4472-902E-53E16066E0C0" name="GUID-DF15DFCE-BA9E-4472-902E-53E16066E0C0"></a><h4 id="LNPCC-GUID-DF15DFCE-BA9E-4472-902E-53E16066E0C0" class="sect4"><span class="enumeration_section">B.5.1</span>优化器提示</h4>
                  <div>
                     <p>在某些情况下，您可以向服务器建议优化SQL语句的方法。这些建议称为<span class="italic">提示</span> ，可以影响优化程序的决策。 <a id="d114141e368" class="indexterm-anchor"></a> 
                     </p>
                     <p>提示不是指令;他们只是帮助优化者完成它的工作。一些提示限制了用于优化SQL语句的信息范围，而其他提示则提出了整体策略。</p>
                     <p>您可以使用提示来指定</p>
                     <ul style="list-style-type:disc">
                        <li>
                           <p>SQL语句的优化方法</p>
                        </li>
                        <li>
                           <p>每个引用表的访问路径</p>
                        </li>
                        <li>
                           <p>加入加入订单</p>
                        </li>
                        <li>
                           <p>用于连接表的方法</p>
                        </li>
                     </ul>
                     <p>因此，提示分为以下四类：</p>
                     <ul style="list-style-type:disc">
                        <li>
                           <p>优化方法</p>
                        </li>
                        <li>
                           <p>访问路径</p>
                        </li>
                        <li>
                           <p>加入订单</p>
                        </li>
                        <li>
                           <p>加入运营</p>
                        </li>
                     </ul>
                     <p>例如，两个优化方法提示COST和NOCOST分别调用基于成本的优化器和基于规则的优化器。</p>
                     <p>您可以通过在SELECT，UPDATE，INSERT或DELETE语句中的动词后立即将它们放在C样式的注释中来为优化器提供提示。例如，优化程序对以下语句使用基于成本的方法： <a id="d114141e407" class="indexterm-anchor"></a><a id="d114141e411" class="indexterm-anchor"></a> 
                     </p><pre class="oac_no_warn" dir="ltr">SELECT / * + COST * / ename，sal INTO ...
</pre><p>对于C ++代码，也可以识别// +形式的优化器提示。</p>
                  </div>
                  <div>
                     <div class="relinfo">
                        <p><strong>相关话题</strong></p>
                        <ul>
                           <li><a href="../adfns/editions.html#ADFNS-GUID-58DE05A0-5DEF-4791-8FA8-F04D11964906" target="_blank">使用基于版本的重新定义</a></li>
                        </ul>
                     </div>
                  </div>
               </div><a id="LNPCC4563"></a><div class="props_rev_3"><a id="GUID-110A35EF-F937-4B44-BC1B-846644B3B02D" name="GUID-110A35EF-F937-4B44-BC1B-846644B3B02D"></a><h4 id="LNPCC-GUID-110A35EF-F937-4B44-BC1B-846644B3B02D" class="sect4"><span class="enumeration_section">B.5.2</span>跟踪设施</h4>
                  <div>
                     <p>您可以使用SQL跟踪工具和EXPLAIN PLAN语句来标识可能会降低应用程序速度的SQL语句。 <a id="d114141e447" class="indexterm-anchor"></a><a id="d114141e451" class="indexterm-anchor"></a> 
                     </p>
                     <p>SQL跟踪工具为每个执行的SQL语句生成统计信息。从这些统计信息中，您可以确定哪些语句需要花费最多的时间来处理。然后，您可以将调整工作集中在这些语句上。 <a id="d114141e458" class="indexterm-anchor"></a> 
                     </p>
                     <p>EXPLAIN PLAN语句显示应用程序中每个SQL语句的执行计划。<span class="italic">执行计划</span>描述了执行SQL语句必须<span class="italic">执行</span>的数据库操作。您可以使用执行计划来识别低效的SQL语句。 <a id="d114141e468" class="indexterm-anchor"></a><a id="d114141e472" class="indexterm-anchor"></a> 
                     </p>
                  </div>
                  <div>
                     <div class="relinfo">
                        <p><strong>相关话题</strong></p>
                        <ul>
                           <li><a href="../adfns/performance-and-scalability.html#ADFNS-GUID-3BC2DA6F-0836-42EF-8155-C6FA27893360" target="_blank">性能工具</a></li>
                        </ul>
                     </div>
                  </div>
               </div>
            </div><a id="LNPCC4564"></a><div class="props_rev_3"><a id="GUID-AE542335-820C-4F3B-876D-74621D4C1DBD" name="GUID-AE542335-820C-4F3B-876D-74621D4C1DBD"></a><h3 id="LNPCC-GUID-AE542335-820C-4F3B-876D-74621D4C1DBD" class="sect3"><span class="enumeration_section">B.6</span>关于语句缓存</h3>
               <div>
                  <p>这一功能有助于提高依赖于动态SQL语句的所有预编译器应用程序的性能。新实现将消除在重用时解析动态语句的开销。预编译器应用程序用户可以使用新的命令行选项（对于语句高速缓存大小）来获得此性能改进，这将启用动态语句的语句高速缓存。通过启用新选项，将在会话创建时创建语句缓存。缓存仅适用于动态语句，静态语句的游标缓存与此功能共存。</p>
               </div>
            </div><a id="LNPCC4565"></a><div class="props_rev_3"><a id="GUID-6ABFCC28-2166-47F2-B188-D8D03B4158F0" name="GUID-6ABFCC28-2166-47F2-B188-D8D03B4158F0"></a><h3 id="LNPCC-GUID-6ABFCC28-2166-47F2-B188-D8D03B4158F0" class="sect3"><span class="enumeration_section">B.7</span>关于使用索引</h3>
               <div>
                  <p>使用ROWID， <span class="italic">索引</span>将表列中的每个不同值与包含该值的行相关联。使用CREATE INDEX语句创建索引。有关详细信息，请参见<a href="../sqlrf/CREATE-INDEX.html#SQLRF-GUID-1F89BBC0-825F-4215-AF71-7588E31D8BFE" target="_blank">CREATE INDEX</a> 。</p>
                  <p>您可以使用索引来提高返回少于表中行的15％的查询的性能。通过<span class="italic">完全扫描</span> ，即通过顺序读取所有行，可以更快地执行返回表中15％或更多行的查询。 <a id="d114141e551" class="indexterm-anchor"></a> 
                  </p>
                  <p>在WHERE子句中命名索引列的任何查询都可以使用索引。有关帮助您选择要编制索引的列的准则，请参阅“ <a href="../adfns/index.html" target="_blank"><span class="italic">Oracle数据库高级应用程序开发人员指南”</span></a> 。
                  </p>
               </div>
            </div><a id="LNPCC4566"></a><div class="props_rev_3"><a id="GUID-E9767A74-C760-42A4-9829-4CF99F09918C" name="GUID-E9767A74-C760-42A4-9829-4CF99F09918C"></a><h3 id="LNPCC-GUID-E9767A74-C760-42A4-9829-4CF99F09918C" class="sect3"><span class="enumeration_section">B.8</span>关于利用行级锁定</h3>
               <div>
                  <p>默认情况下，数据锁定在行级别而不是表级别。行级锁定允许多个用户同时访问同一表中的不同行。由此带来的性能提升非常显着。</p>
                  <p>您可以指定表级锁定，但会降低事务处理选项的有效性。 <a id="d114141e589" class="indexterm-anchor"></a><a id="d114141e593" class="indexterm-anchor"></a><a id="d114141e597" class="indexterm-anchor"></a> 
                  </p>
                  <p>进行在线事务处理的应用程序从行级锁定中获益最多。如果您的应用程序依赖于表级锁定，请对其进行修改以利用行级锁定。通常，避免显式表级锁定。</p>
               </div>
               <div>
                  <div class="relinfo">
                     <p><strong>相关话题</strong></p>
                     <ul>
                        <li><a href="database-concepts.html#GUID-A62517E8-BF42-4E4D-B3A1-BD318DFB42BD">使用LOCK TABLE</a></li>
                     </ul>
                  </div>
               </div>
               
            </div><a id="LNPCC4567"></a><div class="props_rev_3"><a id="GUID-A12D1A51-23B1-4B1F-A539-F89035B175F8" name="GUID-A12D1A51-23B1-4B1F-A539-F89035B175F8"></a><h3 id="LNPCC-GUID-A12D1A51-23B1-4B1F-A539-F89035B175F8" class="sect3"><span class="enumeration_section">B.9</span>关于消除不必要的解析</h3>
               <div>
                  <p>消除不必要的解析需要正确处理游标并选择性地使用以下游标管理选项： <a id="d114141e638" class="indexterm-anchor"></a> 
                  </p>
                  <ul style="list-style-type:disc">
                     <li>
                        <p>MAXOPENCURSORS</p>
                     </li>
                     <li>
                        <p>HOLD_CURSOR</p>
                     </li>
                     <li>
                        <p>RELEASE_CURSOR</p>
                     </li>
                  </ul>
                  <p>这些选项会影响隐式和显式游标，游标缓存和私有SQL区域。 <a id="d114141e655" class="indexterm-anchor"></a><a id="d114141e661" class="indexterm-anchor"></a><a id="d114141e667" class="indexterm-anchor"></a> 
                  </p>
               </div><a id="LNPCC4568"></a><div class="props_rev_3"><a id="GUID-9BF835AA-E44D-42C6-ADBC-3620EF610582" name="GUID-9BF835AA-E44D-42C6-ADBC-3620EF610582"></a><h4 id="LNPCC-GUID-9BF835AA-E44D-42C6-ADBC-3620EF610582" class="sect4"><span class="enumeration_section">B.9.1</span>关于处理显式游标</h4>
                  <div>
                     <p>回想一下，有两种类型的游标：隐式和显式。为所有数据定义和数据操作语句隐式声明游标。但是，对于返回多行的查询，必须显式声明游标（或使用主机数组）。您使用DECLARE CURSOR语句来声明显式游标。处理显式游标的打开和关闭的方式会影响性能。 <a id="d114141e698" class="indexterm-anchor"></a> 
                     </p>
                     <p>如果需要重新评估活动集，只需重新打开光标即可。OPEN将使用任何新的主机变量值。如果不先关闭光标，可以节省处理时间。</p>
                     <div class="infoboxnote" id="GUID-9BF835AA-E44D-42C6-ADBC-3620EF610582__GUID-462D3554-5DE9-44DE-BE0D-4C383156C35F">
                        <p class="notep1">注意：</p>
                        <p>为了使性能调整更容易，您可以重新打开已经打开的游标。但是，这是ANSI扩展。因此，当MODE = ANSI时，必须在重新打开之前关闭游标。</p>
                     </div>
                     <p>只有在想要释放通过打开光标获取的资源（内存和锁）时才关闭光标。例如，您的程序应该在退出之前关闭所有游标。</p>
                  </div><a id="LNPCC4569"></a><div class="props_rev_3"><a id="GUID-18762F0E-DE09-46BA-8F91-1517B3A7B066" name="GUID-18762F0E-DE09-46BA-8F91-1517B3A7B066"></a><h5 id="LNPCC-GUID-18762F0E-DE09-46BA-8F91-1517B3A7B066" class="sect5"><span class="enumeration_section">B.9.1.1</span>光标控制</h5>
                     <div>
                        <p>通常，有三种方法可以控制显式声明的游标：</p>
                        <ul style="list-style-type:disc">
                           <li>
                              <p>使用DECLARE，OPEN和CLOSE。</p>
                           </li>
                           <li>
                              <p>使用PREPARE，DECLARE，OPEN和CLOSE。</p>
                           </li>
                           <li>
                              <p>当MODE = ANSI时，COMMIT关闭光标。</p>
                           </li>
                        </ul>
                        <p>用第一种方法，注意不必要的解析。OPEN执行解析，但前提是解析后的语句不可用，因为游标是CLOSEd或从不打开。您的程序应该DECLARE游标，每次主机变量的值更改时重新启动它，并且只有在不再需要SQL语句时才关闭它。</p>
                        <p>使用第二种方式（对于动态SQL方法3和4），PREPARE执行解析，并且解析的语句可用，直到执行CLOSE。您的程序应该执行以下操作：</p>
                        <ul style="list-style-type:disc">
                           <li>
                              <p>预备SQL语句</p>
                           </li>
                           <li>
                              <p>DECLARE光标</p>
                           </li>
                           <li>
                              <p>每次主变量的值改变时再次打开游标</p>
                           </li>
                           <li>
                              <p>再次PREPARE SQL语句</p>
                           </li>
                           <li>
                              <p>如果SQL语句更改，请再次打开游标</p>
                           </li>
                           <li>
                              <p>仅在不再需要SQL语句时关闭游标。</p>
                           </li>
                        </ul>
                        <p>如果可能，避免将OPEN和CLOSE语句放在循环中;这是不必要的重新解析SQL语句的潜在原因。在下一个示例中，OPEN和CLOSE语句都在外部<span class="italic">while</span>循环内。当MODE = ANSI时，CLOSE语句必须如图所示定位，因为ANSI要求在重新启动之前将游标置为CLOSEd。
                        </p><pre class="oac_no_warn" dir="ltr">EXEC SQL DECLARE emp_cursor CURSOR FOR SELECT ename，sal from emp where sal&gt;：salary and sal &lt;=：salary + 1000;薪水= 0; while（salary &lt;5000）{EXEC SQL OPEN emp_cursor; while（SQLCODE == 0）{EXEC SQL FETCH emp_cursor INTO .......} salary + = 1000; EXEC SQL CLOSE emp_cursor; }</pre><p>但是，使用MODE = ORACLE时，可以在不打开游标的情况下执行CLOSE语句。通过将CLOSE语句放在外部<span class="italic">while</span>循环之外，可以避免在OPEN语句的每次迭代时进行可能的重新分析。
                        </p><pre class="oac_no_warn" dir="ltr">...while（salary &lt;5000）{EXEC SQL OPEN emp_cursor; while（sqlca.sqlcode == 0）{EXEC SQL FETCH emp_cursor INTO .......} salary + = 1000; } EXEC SQL CLOSE emp_cursor;</pre></div>
                  </div>
               </div><a id="LNPCC4570"></a><div class="props_rev_3"><a id="GUID-946F1EED-4C19-4F6F-8217-0C009730CD9A" name="GUID-946F1EED-4C19-4F6F-8217-0C009730CD9A"></a><h4 id="LNPCC-GUID-946F1EED-4C19-4F6F-8217-0C009730CD9A" class="sect4"><span class="enumeration_section">B.9.2</span>关于使用光标管理选项</h4>
                  <div>
                     <p>除非您更改其构成，否则只需解析一次SQL语句。例如，通过向其选择列表或WHERE子句添加列来更改查询的组成。HOLD_CURSOR，RELEASE_CURSOR和MAXOPENCURSORS选项使您可以控制服务器如何管理SQL语句的解析和重新分析。声明显式游标可以最大程度地控制解析。</p>
                  </div><a id="LNPCC4572"></a><a id="LNPCC4571"></a><div class="props_rev_3"><a id="GUID-ED9A6E00-A9D8-4F9E-9C6A-7EA13DD13570" name="GUID-ED9A6E00-A9D8-4F9E-9C6A-7EA13DD13570"></a><h5 id="LNPCC-GUID-ED9A6E00-A9D8-4F9E-9C6A-7EA13DD13570" class="sect5"><span class="enumeration_section">B.9.2.1</span> SQL区域和游标缓存</h5>
                     <div>
                        <p>执行数据操作语句时，其关联的游标将链接到Pro * C / C ++游标缓存中的条目。游标缓存是用于游标管理的不断更新的内存区域。游标缓存条目又链接到私有SQL区域。 <a id="d114141e830" class="indexterm-anchor"></a> 
                        </p>
                        <p>私有SQL区域是在运行时动态创建的工作区，包含主机变量的地址以及处理该语句所需的其他信息。显式游标允许您命名SQL语句，访问其私有SQL区域中的信息，并在某种程度上控制其处理。 <a id="d114141e837" class="indexterm-anchor"></a> 
                        </p>
                        <p><a href="performance-tuning.html#GUID-ED9A6E00-A9D8-4F9E-9C6A-7EA13DD13570__CHEGCFFE">图B-2</a>表示程序完成INSERT和DELETE后的游标缓存。</p>
                        <div class="figure" id="GUID-ED9A6E00-A9D8-4F9E-9C6A-7EA13DD13570__CHEGCFFE">
                           <p class="titleinfigure">图B-2使用游标缓存链接的游标</p><img src="img/pco81062.gif" alt="下面描述图B-2" title="下面描述图B-2" longdesc="img_text/pco81062.html"><br><a href="img_text/pco81062.html">“使用光标缓存链接的图B-2光标”的说明</a></div>
                        <!-- class="figure" -->
                     </div>
                  </div><a id="LNPCC4573"></a><div class="props_rev_3"><a id="GUID-2E1D8D3F-C59A-4E6B-A187-24C8556886E7" name="GUID-2E1D8D3F-C59A-4E6B-A187-24C8556886E7"></a><h5 id="LNPCC-GUID-2E1D8D3F-C59A-4E6B-A187-24C8556886E7" class="sect5"><span class="enumeration_section">B.9.2.2</span>资源使用</h5>
                     <div>
                        <p>每个用户会话的最大打开游标数由初始化参数OPEN_CURSORS设置。</p>
                        <p>MAXOPENCURSORS指定游标缓存的<span class="italic">初始</span>大小。如果需要新游标且没有空闲缓存条目，则服务器会尝试重用条目。它的成功取决于HOLD_CURSOR和RELEASE_CURSOR的值，对于显式游标，它取决于游标本身的状态。
                        </p>
                        <p>如果MAXOPENCURSORS的值小于实际需要的高速缓存条目数，则服务器使用标记为可重用的第一个高速缓存条目。例如，假设INSERT语句的高速缓存条目<span class="italic">E</span> （1）被标记为可重用，并且高速缓存条目的数量已经等于MAXOPENCURSORS。如果程序执行新语句，则可以将高速缓存条目<span class="italic">E</span> （1）及其私有SQL区域重新分配给新语句。要重新执行INSERT语句，服务器必须重新分析它并重新分配另一个缓存条目。
                        </p>
                        <p>如果服务器找不到要重用的缓存条目，则会分配一个额外的缓存条目。例如，如果MAXOPENCURSORS = 8并且所有八个条目都处于活动状态，则会创建第九个条目。如有必要，服务器将继续分配其他缓存条目，直到内存不足或达到OPEN_CURSORS设置的限制。这种动态分配增加了处理开销。</p>
                        <p>因此，为MAXOPENCURSORS指定一个较低的值可以节省内存，但会导致新的缓存条目的动态分配和解除分配。为MAXOPENCURSORS指定一个高值可确保快速执行但使用更多内存。 <a id="d114141e891" class="indexterm-anchor"></a> 
                        </p>
                     </div>
                  </div><a id="LNPCC4574"></a><div class="props_rev_3"><a id="GUID-3F741D64-7F2B-4C07-96D0-91DEED0D4AC2" name="GUID-3F741D64-7F2B-4C07-96D0-91DEED0D4AC2"></a><h5 id="LNPCC-GUID-3F741D64-7F2B-4C07-96D0-91DEED0D4AC2" class="sect5"><span class="enumeration_section">B.9.2.3</span>不经常执行</h5>
                     <div>
                        <p>有时， <span class="italic">不经常</span>执行的SQL语句与其私有SQL区域之间的链接应该是临时的。
                        </p>
                        <p>当HOLD_CURSOR = NO（缺省值）时，在服务器执行SQL语句并且游标关闭后，预编译器将游标和游标缓存之间的链接标记为可重用。只要另一个SQL语句需要它指向的游标缓存条目，就会重用该链接。这将释放分配给私有SQL区域的内存并释放解析锁。但是，因为PREPAREd游标必须保持活动状态，所以即使HOLD_CURSOR = NO，也会保持其链接。</p>
                        <p>当RELEASE_CURSOR = YES时，在服务器执行SQL语句并关闭游标后，将自动释放私有SQL区域并丢失已解析的语句。例如，如果MAXOPENCURSORS在您的站点设置为低以节省内存，则可能需要这样做。</p>
                        <p>如果数据操作语句在数据定义语句之前并且它们引用相同的表，则为数据操作语句指定RELEASE_CURSOR = YES。这避免了数据操作语句获得的解析锁与数据定义语句所需的排它锁之间的冲突。</p>
                        <p>当RELEASE_CURSOR = YES时，将立即删除私有SQL区域和高速缓存条目之间的链接，并释放私有SQL区域。即使指定HOLD_CURSOR = YES，服务器仍必须为私有SQL区域重新分配内存并在执行之前重新分析SQL语句，因为RELEASE_CURSOR = YES会覆盖HOLD_CURSOR = YES。</p>
                        <p>但是，当RELEASE_CURSOR = YES时，重新分析可能仍然不需要额外的处理，因为服务器在其<span class="italic">共享SQL缓存中缓存</span> SQL语句和PL / SQL块的已解析表示。即使其光标关闭，解析后的表示仍然可用，直到它从缓存中老化。
                        </p>
                     </div>
                  </div><a id="LNPCC4575"></a><div class="props_rev_3"><a id="GUID-7F3A3CA0-B0CE-4883-AE5F-CD473DEECCDA" name="GUID-7F3A3CA0-B0CE-4883-AE5F-CD473DEECCDA"></a><h5 id="LNPCC-GUID-7F3A3CA0-B0CE-4883-AE5F-CD473DEECCDA" class="sect5"><span class="enumeration_section">B.9.2.4</span>频繁执行</h5>
                     <div>
                        <p>应保持<span class="italic">频繁</span>执行的SQL语句与其私有SQL区域之间的链接，因为私有SQL区域包含执行该语句所需的所有信息。维护对此信息的访问使得后续执行语句的速度更快。
                        </p>
                        <p>当HOLD_CURSOR = YES时，在服务器执行SQL语句后，将保持游标和游标缓存之间的链接。因此，解析的语句和分配的内存仍然可用。这对于您希望保持活动状态的SQL语句非常有用，因为它可以避免不必要的重新分析。 <a id="d114141e968" class="indexterm-anchor"></a><a id="d114141e974" class="indexterm-anchor"></a> 
                        </p>
                        <p>当RELEASE_CURSOR = NO（缺省值）时，在服务器执行SQL语句之后，将保留高速缓存条目和专用SQL区域之间的链接，除非打开的游标数超过MAXOPENCURSORS的值，否则不会重复使用。这对于经常执行的SQL语句很有用，因为解析的语句和分配的内存仍然可用。 <a id="d114141e981" class="indexterm-anchor"></a><a id="d114141e985" class="indexterm-anchor"></a> 
                        </p>
                        <div class="infoboxnote" id="GUID-7F3A3CA0-B0CE-4883-AE5F-CD473DEECCDA__GUID-D8FD0E9D-6869-4DB2-A382-43B82A53ADBF">
                           <p class="notep1">注意：</p>
                           <p>对于Oracle8 <span class="italic">i</span>之前的Oracle版本，当RELEASE_CURSOR = NO且HOLD_CURSOR = YES时，在服务器执行SQL语句之后，其解析的表示仍然可用。但是对于更高版本的Oracle，当RELEASE_CURSOR = NO且HOLD_CURSOR = YES时，解析后的表示只有在它从共享SQL缓存中老化之后才可用。通常，这不是问题，但如果在重新分析SQL语句之前引用对象的定义发生更改，则可能会出现意外结果。
                           </p>
                        </div>
                     </div>
                  </div><a id="LNPCC4576"></a><div class="props_rev_3"><a id="GUID-989DD868-1723-48B9-B153-0233ED8BA776" name="GUID-989DD868-1723-48B9-B153-0233ED8BA776"></a><h5 id="LNPCC-GUID-989DD868-1723-48B9-B153-0233ED8BA776" class="sect5"><span class="enumeration_section">B.9.2.5</span>嵌入式PL / SQL注意事项</h5>
                     <div>
                        <p>出于游标管理的目的，嵌入式PL / SQL块被视为SQL语句。当执行嵌入式PL / SQL块时，父光标与整个块相关联，并且在嵌入式PL / SQL块的PGA中的高速缓存条目和私有SQL区域之间创建链接。请注意，嵌入块内的每个SQL语句也需要PGA中的私有SQL区域。这些SQL语句使用PL / SQL自行管理的子游标。子游标的处置是通过其关联的父游标确定的。也就是说，子游标使用的私有SQL区域在释放其父游标的私有SQL区域后被释放。</p>
                     </div>
                  </div><a id="LNPCC4578"></a><a id="LNPCC4577"></a><div class="props_rev_3"><a id="GUID-D181D93D-C6BF-41D8-A9A4-E31ABE9C9A3B" name="GUID-D181D93D-C6BF-41D8-A9A4-E31ABE9C9A3B"></a><h5 id="LNPCC-GUID-D181D93D-C6BF-41D8-A9A4-E31ABE9C9A3B" class="sect5"><span class="enumeration_section">B.9.2.6</span>参数交互</h5>
                     <div>
                        <p><a href="performance-tuning.html#GUID-969E1F8A-3380-4B6F-8337-15EE0E68D858__CHEBHDFF">图B-1</a>显示了HOLD_CURSOR和RELEASE_CURSOR如何交互。请注意，HOLD_CURSOR = NO会覆盖RELEASE_CURSOR = NO，而RELEASE_CURSOR = YES会覆盖HOLD_CURSOR = YES。</p>
                        <div class="tblformal" id="GUID-D181D93D-C6BF-41D8-A9A4-E31ABE9C9A3B__CHEDAEHH">
                           <p class="titleintable">表B-1 HOLD_CURSOR和RELEASE _CURSOR交互</p>
                           <table cellpadding="4" cellspacing="0" class="Formal" title="HOLD_CURSOR和RELEASE _CURSOR交互" width="100%" border="1" summary="HOLD_CURSOR and RELEASE _CURSOR Interactions" frame="hsides" rules="rows">
                              <thead>
                                 <tr align="left" valign="top">
                                    <th align="left" valign="bottom" width="36%" id="d114141e1058">HOLD_CURSOR</th>
                                    <th align="left" valign="bottom" width="32%" id="d114141e1061">RELEASE_CURSOR</th>
                                    <th align="left" valign="bottom" width="32%" id="d114141e1064">链接是......</th>
                                 </tr>
                              </thead>
                              <tbody>
                                 <tr align="left" valign="top">
                                    <td align="left" valign="top" width="36%" id="d114141e1069" headers="d114141e1058 ">
                                       <p>没有</p>
                                    </td>
                                    <td align="left" valign="top" width="32%" headers="d114141e1069 d114141e1061 ">
                                       <p>没有</p>
                                    </td>
                                    <td align="left" valign="top" width="32%" headers="d114141e1069 d114141e1064 ">
                                       <p>标记为可重复使用</p>
                                    </td>
                                 </tr>
                                 <tr align="left" valign="top">
                                    <td align="left" valign="top" width="36%" id="d114141e1079" headers="d114141e1058 ">
                                       <p>是</p>
                                    </td>
                                    <td align="left" valign="top" width="32%" headers="d114141e1079 d114141e1061 ">
                                       <p>没有</p>
                                    </td>
                                    <td align="left" valign="top" width="32%" headers="d114141e1079 d114141e1064 ">
                                       <p>保持</p>
                                    </td>
                                 </tr>
                                 <tr align="left" valign="top">
                                    <td align="left" valign="top" width="36%" id="d114141e1089" headers="d114141e1058 ">
                                       <p>没有</p>
                                    </td>
                                    <td align="left" valign="top" width="32%" headers="d114141e1089 d114141e1061 ">
                                       <p>是</p>
                                    </td>
                                    <td align="left" valign="top" width="32%" headers="d114141e1089 d114141e1064 ">
                                       <p>立即删除</p>
                                    </td>
                                 </tr>
                                 <tr align="left" valign="top">
                                    <td align="left" valign="top" width="36%" id="d114141e1099" headers="d114141e1058 ">
                                       <p>是</p>
                                    </td>
                                    <td align="left" valign="top" width="32%" headers="d114141e1099 d114141e1061 ">
                                       <p>是</p>
                                    </td>
                                    <td align="left" valign="top" width="32%" headers="d114141e1099 d114141e1064 ">
                                       <p>立即删除</p>
                                    </td>
                                 </tr>
                              </tbody>
                           </table>
                        </div>
                        <!-- class="inftblhruleinformal" -->
                     </div>
                  </div>
               </div>
            </div><a id="LNPCC4579"></a><div class="props_rev_3"><a id="GUID-ED50D9C4-2B22-43AB-AA63-3B6400FFCB7D" name="GUID-ED50D9C4-2B22-43AB-AA63-3B6400FFCB7D"></a><h3 id="LNPCC-GUID-ED50D9C4-2B22-43AB-AA63-3B6400FFCB7D" class="sect3"><span class="enumeration_section">B.10</span>关于避免不必要的重新分析</h3>
               <div>
                  <div class="section">
                     <p>避免不必要的重新分析涉及消除循环中SQL语句的执行阶段期间遇到的错误。在循环中执行嵌入式SQL语句时，SQL语句仅解析一次。但是，如果执行SQL语句导致错误，则通常会重新解析SQL语句。在这种情况下，将对遇到的所有错误进行重新分析，但以下情况除外：</p>
                  </div>
                  <!-- class="section" -->
                  <div class="section">
                     <ul style="list-style-type:disc">
                        <li>
                           <p>ORA-1403（未找到）</p>
                        </li>
                        <li>
                           <p>ORA-1405（截断）</p>
                        </li>
                        <li>
                           <p>ORA-1406（空值）</p>
                        </li>
                     </ul>
                     <p>通过消除所有其他错误，您可以避免不必要的重新分析。</p>
                  </div>
                  <!-- class="section" -->
               </div>
            </div><a id="LNPCC4580"></a><div class="props_rev_3"><a id="GUID-2FD19C63-B523-4B93-9FB1-CDD376EA2423" name="GUID-2FD19C63-B523-4B93-9FB1-CDD376EA2423"></a><h3 id="LNPCC-GUID-2FD19C63-B523-4B93-9FB1-CDD376EA2423" class="sect3"><span class="enumeration_section">B.11</span>关于使用连接池</h3>
               <div>
                  <div class="section">
                     <p>本节介绍使用连接池进行性能调整。如果应用程序是多线程的并且正在同一数据库上执行并发操作，则用户可以使用连接池功能来实现更好的性能。用户可以通过为连接池使用的参数选择适当的值来调整应用程序的性能，与现有应用程序性能相比，可以实现高达三倍的性能提升。</p>
                  </div>
                  <!-- class="section" -->
               </div>
               <div>
                  <div class="relinfo">
                     <p><strong>相关话题</strong></p>
                     <ul>
                        <li><a href="multithreaded-applications.html#GUID-76B52DE9-54B7-4F3C-9905-AADE6420BE84">多线程应用程序</a></li>
                        <li><a href="multithreaded-applications.html#GUID-617D04C1-EA48-44D0-B5E6-E8CB9C241B07">连接池</a></li>
                        <li><a href="../lnoci/index.html" target="_blank"><span><cite>Oracle调用接口程序员指南</cite></span></a></li>
                     </ul>
                  </div>
               </div>
            </div>
            <div class="sect2"><a id="GUID-BF9AFFD6-537A-4252-BBFB-3A60EEAC3E61" name="GUID-BF9AFFD6-537A-4252-BBFB-3A60EEAC3E61"></a><h3 id="LNPCC-GUID-BF9AFFD6-537A-4252-BBFB-3A60EEAC3E61" class="sect3"><span class="enumeration_section">B.12</span>关于在Traffic Director模式下使用Oracle Connection Manager</h3>
               <div>
                  <p>Traffic Director Mode中的Oracle Connection Manager是一个放置在支持的数据库客户端和数据库实例之间的代理。</p>
                  <div class="p">Oracle Database <span class="italic">11g</span>第2版（11.2）及更高版本中支持的客户端可以在Traffic Director模式下连接到Oracle Connection Manager。流量控制器模式中的Oracle连接管理器为计划内和计划外数据库服务器中断，连接多路复用支持和负载平衡提供了改进的高可用性（HA）。以下各节将更详细地介绍对Traffic Director模式中的Oracle Connection Manager的支持<ul style="list-style-type:disc">
                        <li>
                           <p><a href="performance-tuning.html#GUID-BF9AFFD6-537A-4252-BBFB-3A60EEAC3E61__MODESOFOPERATION-4FD4C8FE">运作模式</a></p>
                        </li>
                        <li>
                           <p><a href="performance-tuning.html#GUID-BF9AFFD6-537A-4252-BBFB-3A60EEAC3E61__KEYFEATURES-4FD4D08F">主要特点</a></p>
                        </li>
                     </ul>
                  </div>
                  <div class="section" id="GUID-BF9AFFD6-537A-4252-BBFB-3A60EEAC3E61__MODESOFOPERATION-4FD4C8FE">
                     <p class="subhead2" id="GUID-BF9AFFD6-537A-4252-BBFB-3A60EEAC3E61__GUID-749BC524-93BC-42F1-B765-970605875B7F">运作模式</p>
                     <p>流量控制器模式中的Oracle连接管理器支持以下操作模式：</p>
                     <ul style="list-style-type:disc">
                        <li>
                           <div class="p">在池连接模式下，流量控制器模式中的Oracle连接管理器支持使用以下数据库客户端版本的任何应用程序：<ul style="list-style-type:disc">
                                 <li>
                                    <p>OCI，OCCI和开源驱动程序（Oracle Database <span class="italic">11g第</span> 2版（11.2.0.4）及更高版本））</p>
                                 </li>
                                 <li>
                                    <p>JDBC（Oracle Database 12c <span class="italic">第</span> 1版（12.1）及更高版本）</p>
                                 </li>
                                 <li>
                                    <p>ODP.NET（Oracle Database 12 <span class="italic">c第</span> 2版（12.2）及更高版本）</p>
                                 </li>
                              </ul>
                           </div>
                           <p>此外，应用程序必须使用DRCP。也就是说，应用程序必须在连接字符串（或<code class="codeph">tnsnames.ora</code>别名）中启用DRCP。
                           </p>
                        </li>
                        <li>
                           <p>在非池化连接（或专用）模式下，流量控制器模式中的Oracle连接管理器支持使用数据库客户机版本Oracle Database <span class="italic">11g第</span> 2版（11.2.0.4）及更高版本的任何应用程序。在此模式下，某些功能（如连接多路复用）不可用。
                           </p>
                        </li>
                     </ul>
                  </div>
                  <!-- class="section" -->
                  <div class="section" id="GUID-BF9AFFD6-537A-4252-BBFB-3A60EEAC3E61__KEYFEATURES-4FD4D08F">
                     <p class="subhead2" id="GUID-BF9AFFD6-537A-4252-BBFB-3A60EEAC3E61__GUID-3A52B2C3-D63C-4ACB-8FED-1BAFC3801338">主要特点</p>
                     <div class="p">Traffic Director Mode中的Oracle Connection Manager提供以下支持：<ul style="list-style-type:disc">
                           <li>
                              <div class="p">透明的性能增强和连接多路复用，包括：<ul style="list-style-type:disc">
                                    <li>
                                       <p>对所有操作模式自动启用语句高速缓存，行预取和结果集高速缓存。</p>
                                    </li>
                                    <li>
                                       <p>使用代理驻留连接池（PRCP）的数据库会话多路复用（仅池化模式），其中PRCP是数据库驻留连接池（DRCP）的代理模式。应用程序在Traffic Director模式下的Oracle Connection Manager与数据库之间获得透明的连接时负载平衡和运行时负载平衡。</p>
                                    </li>
                                    <li>
                                       <p>对于Traffic Director模式实例中的多个Oracle Connection Manager，应用程序通过客户端连接时间负载平衡或负载均衡器（BIG-IP，NGINX等）获得更高的可扩展性</p>
                                    </li>
                                 </ul>
                              </div>
                           </li>
                           <li>
                              <div class="p">零应用程序停机时间<ul style="list-style-type:disc">
                                    <li>
                                       <div class="p">计划数据库维护或可插拔数据库（PDB）重定位<ul style="list-style-type:disc">
                                             <li>
                                                <p>合并模式</p>
                                                <p>流量控制器模式中的Oracle Connection Manager响应Oracle Notification Service（ONS）事件以计划中断和重定向工作。请求完成后，在流量控制器模式下，Oracle Connection Manager上的池中的连接将耗尽。Oracle Database <span class="italic">11g第</span> 2版（11.2.0.4）及更高版本支持服务重定位。
                                                </p>
                                                <p>对于PDB重定位，当PDB重新定位时，流量控制器模式中的Oracle连接管理器会响应带内通知，即使未配置ONS时也是如此（对于Oracle数据库版本18c，仅限版本18.1及更高版本的服务器）</p>
                                             </li>
                                             <li>
                                                <p>非汇集或专用模式</p>
                                                <div class="p">当客户端没有请求边界信息时，流量控制器模式中的Oracle连接管理器支持许多应用程序的计划中断（只要在请求/事务边界上只需要保留简单的会话状态和游标状态）。这种支持包括：<ul style="list-style-type:disc">
                                                      <li>
                                                         <p>在事务边界处停止服务/ PDB，或者利用Oracle数据库版本18c连续应用程序可用性来停止请求边界处的服务</p>
                                                      </li>
                                                      <li>
                                                         <p>流量控制器模式中的Oracle连接管理器利用透明应用程序故障转移（TAF）故障转移还原来重新连接和还原简单状态。</p>
                                                      </li>
                                                   </ul>
                                                </div>
                                             </li>
                                          </ul>
                                       </div>
                                    </li>
                                    <li>
                                       <p>针对大多数读取工作负载的计划外数据库中断</p>
                                    </li>
                                 </ul>
                              </div>
                           </li>
                           <li>
                              <div class="p">流量控制器模式中Oracle Connection Manager的高可用性，以避免单点故障。这得到以下支持：<ul style="list-style-type:disc">
                                    <li>
                                       <p>流量控制器模式中的多个Oracle连接管理器实例，使用连接字符串中的负载平衡器或客户端负载平衡/故障转移</p>
                                    </li>
                                    <li>
                                       <p>在Traffic Director模式实例中滚动升级Oracle Connection Manager</p>
                                    </li>
                                    <li>
                                       <p>针对计划中断，在流量控制器模式下从客户端到Oracle Connection Manager的现有连接的正常关闭</p>
                                    </li>
                                    <li>
                                       <p>带有Oracle数据库版本18c及更高版本客户端的带内通知</p>
                                    </li>
                                    <li>
                                       <p>对于较旧的客户端，通知将与当前请求的响应一起发送</p>
                                    </li>
                                 </ul>
                              </div>
                           </li>
                           <li>
                              <div class="p">为了安全性和隔离性，Traffic Director Mode中的Oracle Connection Manager提供：<ul style="list-style-type:disc">
                                    <li>
                                       <p>数据库代理支持传输控制协议/传输控制协议安全（TCP / TCPS）和协议转换</p>
                                    </li>
                                    <li>
                                       <p>防火墙基于IP地址，服务名称和安全套接字层/传输层安全性（SSL / TLS）钱包</p>
                                    </li>
                                    <li>
                                       <p>多租户环境中的租户隔离</p>
                                    </li>
                                    <li>
                                       <p>防止拒绝服务和模糊测试攻击</p>
                                    </li>
                                    <li>
                                       <p>跨Oracle数据库本地和Oracle Cloud安全地隧道传输数据库流量</p>
                                    </li>
                                 </ul>
                              </div>
                           </li>
                        </ul>
                     </div>
                  </div>
                  <!-- class="section" -->
                  <div class="section">
                     <div class="infoboxnotealso" id="GUID-BF9AFFD6-537A-4252-BBFB-3A60EEAC3E61__GUID-A2DD3A99-8792-4704-A482-B66B30AD1B85">
                        <p class="notep1">也可以看看：</p>
                        <ul style="list-style-type:disc">
                           <li>
                              <p>有关配置<code class="codeph">cman.ora</code>配置文件以在Traffic Director模式下设置Oracle Connection Manager的信息，请<code class="codeph">cman.ora</code> <a href="../netag/configuring-oracle-connection-manager.html#NETAG-GUID-3917FC5D-4B23-4752-85BA-39A88C4D13F8" target="_blank"><span><cite>“Oracle数据库网络服务管理员指南”</cite></span></a></p>
                           </li>
                           <li>
                              <p><a href="../netag/configuring-oracle-connection-manager.html#NETAG-GUID-58847B76-3836-41DB-9EB6-A81D5C397024" target="_blank"><span><cite>“Oracle数据库网络服务管理员指南”</cite></span></a> ，了解有关在Traffic Director模式代理身份验证中为Oracle Connection Manager配置数据库的信息</p>
                           </li>
                           <li>
                              <p><a href="../netag/configuring-oracle-connection-manager.html#NETAG-GUID-96FA23BA-F32B-4D47-9CBB-69D27E8D94F6" target="_blank"><span><cite>“Oracle数据库网络服务管理员指南”</cite></span></a> ，了解有关在流量控制器模式下为计划外停机事件配置Oracle Connection Manager的信息</p>
                           </li>
                           <li>
                              <p><a href="../netag/configuring-oracle-connection-manager.html#NETAG-GUID-E73658E7-BBF7-4C13-AAD5-70D32062AD8D" target="_blank"><span><cite>“Oracle数据库网络服务管理员指南”</cite></span></a> ，了解有关在Traffic Director模式下为计划的关闭事件配置Oracle Connection Manager的信息</p>
                           </li>
                           <li>
                              <p><a href="../netag/configuring-oracle-connection-manager.html#NETAG-GUID-15756B12-5ED5-4EDE-9D4B-6B890D5BE9AF" target="_blank"><span><cite>“Oracle数据库网络服务管理员指南”，</cite></span></a>以获取有关在流量控制器模式下配置Oracle Connection Manager使用的代理驻留连接池的信息</p>
                           </li>
                           <li>
                              <p><a href="../netag/configuring-oracle-connection-manager.html#NETAG-GUID-FC833F8F-CE5A-4C02-A962-244954158853" target="_blank"><span><cite>“Oracle数据库网络服务管理员指南”</cite></span></a> ，了解有关在流量控制器模式下使用Oracle Connection Manager的所有驱动程序不支持的功能的信息</p>
                           </li>
                           <li>
                              <p><a href="../netrf/index.html" target="_blank"><span><cite>Oracle Database Net Services参考</cite></span></a> ，以获取Oracle CMAN配置文件的概述</p>
                           </li>
                        </ul>
                     </div>
                  </div>
                  <!-- class="section" -->
               </div>
            </div>
         </div>
      </article>
   </body>
</html>