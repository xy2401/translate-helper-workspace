<html lang="en-us" dir="ltr" xml:lang="en-us">
   <head>
      <meta http-equiv="Content-Type" content="text/html; charset=utf-8"></meta>
      <meta name="viewport" content="width=device-width, initial-scale=1"></meta>
      <meta http-equiv="X-UA-Compatible" content="IE=edge"></meta>
      <meta name="abstract" content="There are many ways for applications to query and update XML data that is in Oracle Database, both XML schema-based and non-schema-based."></meta>
      <meta name="description" content="There are many ways for applications to query and update XML data that is in Oracle Database, both XML schema-based and non-schema-based."></meta>
      <title>查询和更新XML数据</title>
      <meta property="og:site_name" content="Oracle Help Center"></meta>
      <meta property="og:title" content="Developer&#39;s Guide "></meta>
      <meta property="og:description" content="There are many ways for applications to query and update XML data that is in Oracle Database, both XML schema-based and non-schema-based."></meta>
      <link rel="stylesheet" href="/sp_common/book-template/ohc-book-template/css/book.css"></link>
      <link rel="shortcut icon" href="/sp_common/book-template/ohc-common/img/favicon.ico"></link>
      <meta name="application-name" content="Developer&#39;s Guide"></meta>
      <meta name="generator" content="DITA Open Toolkit version 1.8.5 (Mode = doc)"></meta>
      <meta name="plugin" content="SP_docbuilder HTML plugin release 18.2.2"></meta>
      <link rel="alternate" href="xml-db-developers-guide.pdf" title="PDF File" type="application/pdf"></link>
      <meta name="robots" content="all"></meta>
      <link rel="schema.dcterms" href="http://purl.org/dc/terms/"></link>
      <meta name="dcterms.created" content="2019-03-30T12:32:42-07:00"></meta>
      
      <meta name="dcterms.dateCopyrighted" content="2002, 2019"></meta>
      <meta name="dcterms.category" content="database"></meta>
      <meta name="dcterms.identifier" content="E96222-03"></meta>
      
      <meta name="dcterms.product" content="en/database/oracle/oracle-database/19"></meta>
      
      <link rel="prev" href="xquery-and-XML-DB.html" title="Previous" type="text/html"></link>
      <link rel="next" href="indexes-for-XMLType-data.html" title="Next" type="text/html"></link>
      <script>
        document.write('<style type="text/css">');
        document.write('body > .noscript, body > .noscript ~ * { visibility: hidden; }');
        document.write('</style>');
     </script>
      <script src="/sp_common/book-template/requirejs/require.js" data-main="/sp_common/book-template/ohc-book-template/js/book-config"></script>
      <script>
            if (window.require === undefined) {
                document.write('<script data-main="sp_common/book-template/ohc-book-template/js/book-config" src="sp_common/book-template/requirejs/require.js"><\/script>');
                document.write('<link href="sp_common/book-template/ohc-book-template/css/book.css" rel="stylesheet"/>');
            }
        </script>
      <script type="application/json" id="ssot-metadata">{"primary":{"category":{"short_name":"database","element_name":"Database","display_in_url":true},"suite":{"short_name":"oracle","element_name":"Oracle","display_in_url":true},"product_group":{"short_name":"not-applicable","element_name":"Not applicable","display_in_url":false},"product":{"short_name":"oracle-database","element_name":"Oracle Database","display_in_url":true},"release":{"short_name":"19","element_name":"Release 19","display_in_url":true}}}</script>
      
    <meta name="dcterms.title" content="XML DB Developer&#39;s Guide"></meta>
    <meta name="dcterms.isVersionOf" content="ADXDB"></meta>
    <meta name="dcterms.release" content="Release 19"></meta>
  </head>
   <body dir="ltr">
      <div class="noscript alert alert-danger text-center" role="alert">
         <a href="xquery-and-XML-DB.html" class="pull-left"><span class="glyphicon glyphicon-chevron-left" aria-hidden="true"></span>上一页</a> <a href="indexes-for-XMLType-data.html" class="pull-right">下一页<span class="glyphicon glyphicon-chevron-right" aria-hidden="true"></span></a> <span class="fa fa-exclamation-triangle" aria-hidden="true"></span>必须启用JavaScript才能正确显示此内容</div>
      <article>
         <header>
            <ol class="breadcrumb" vocab="http://schema.org/" typeof="BreadcrumbList">
               <li property="itemListElement" typeof="ListItem"><a href="index.html" property="item" typeof="WebPage"><span property="name">开发人员指南</span></a></li>
               <li property="itemListElement" typeof="ListItem"><a href="manipulation-of-XML-in-XML-DB.html" property="item" typeof="WebPage"><span property="name">在Oracle XML DB中操作XML数据</span></a></li>
               <li class="active" property="itemListElement" typeof="ListItem">查询和更新XML数据</li>
            </ol>
            <a id="GUID-01C75289-804F-4BAA-AE7C-DFA73198581E" name="GUID-01C75289-804F-4BAA-AE7C-DFA73198581E"></a><a id="ADXDB0400"></a>
            
            <h2 id="ADXDB-GUID-01C75289-804F-4BAA-AE7C-DFA73198581E" class="sect2"><span class="enumeration_chapter">5</span>查询和更新XML数据</h2>
         </header>
         <div class="ind"><script type="text/javascript">window.name='query-and-update-XML'</script><script type="text/javascript">
    function footdisplay(footnum,footnote) {
    var msg = window.open('about:blank', 'NewWindow' + footnum,
        'directories=no,height=100,location=no,menubar=no,resizable=yes,' +
        'scrollbars=yes,status=no,toolbar=no,width=598');
    msg.document.open('text/html');
    msg.document.write('<!DOCTYPE html ');
    msg.document.write('PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" ');
    msg.document.write('"http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">'); 
    msg.document.write('<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en-us" lang="en-us" dir="ltr"><head><title>');
   
    msg.document.write('Footnote&nbsp; ' + footnum);
    msg.document.write('<\/title><meta http-equiv="Content-Type" ');
    msg.document.write('content="text/html; charset=utf-8" />');
    msg.document.write('<meta http-equiv="Content-Script-Type" ');
    msg.document.write('content="text/javascript" />');
    msg.document.write('<style type="text/css"> <![CDATA[ ');
    msg.document.write('h1 {text-align: center; font-size: 14pt;}');
    msg.document.write('fieldset {border: none;}');
    msg.document.write('form {text-align: center;}');
    msg.document.write(' ]]u003e </style>');
    msg.document.write('<\/head><body><div id="footnote"><h1>Footnote&nbsp; ' + footnum + '<\/h1><p>');
    msg.document.write(footnote);
    msg.document.write('<\/p><form action="" method="post"><fieldset>');
    msg.document.write('<input type="button" value="OK" ');
    msg.document.write('onclick="window.close();" />');
    msg.document.write('<\/fieldset><\/form><\/div><\/body><\/html>');
    msg.document.close();
    setTimeout(function() {
        var height = msg.document.getElementById('footnote').offsetHeight;
        msg.resizeTo(598, height + 100);
    }
    , 100);
    msg.focus();
}
            </script><noscript>
               <p>此页面上的脚本内容仅用于导航目的，不会以任何方式更改内容。</p>
            </noscript>
            <div>
               <p>应用程序有许多方法可以查询和更新Oracle数据库中的XML数据，包括基于XML模式和非基于模式的数据。</p>
            </div>
            <div>
               <ul class="ullinks">
                  <li class="ulchildlink"><a href="query-and-update-XML.html#GUID-4DF303DB-780C-4491-9252-234482A563A4">将XQuery与Oracle XML DB一起使用</a><br>XQuery是一种非常通用和富有表现力的语言，SQL / XML函数<code class="codeph">XMLQuery</code> ， <code class="codeph">XMLTable</code> ， <code class="codeph">XMLExists</code>和<code class="codeph">XMLCast</code>将表达和计算的强大功能与SQL的优势结合在一起。</li>
                  <li class="ulchildlink"><a href="query-and-update-XML.html#GUID-0FDD8ABE-F94B-42CB-B135-93BC67225737">使用SQL和PL / SQL查询XML数据</a><br>您可以通过各种方式从<code class="codeph">XMLType</code>列和表中查询XML数据。
                  </li>
                  <li class="ulchildlink"><a href="query-and-update-XML.html#GUID-4C3665D9-5502-4D05-A1AE-9E8B4D7E64C1">使用SQL * Plus XQUERY命令</a><br>您可以使用SQL * Plus <code class="codeph">XQUERY</code>命令评估XQuery表达式。
                  </li>
                  <li class="ulchildlink"><a href="query-and-update-XML.html#GUID-8F3B9C09-6877-4E43-A6E7-873BF0E74DAB">使用XQuery与XQJ访问数据库数据</a><br>XQuery API for Java（XQJ），也称为JSR-225，为Java程序使用XQuery访问XML数据提供了行业标准方法。它允许您根据XML数据源评估XQuery表达式，并将结果作为XML数据处理。
                  </li>
                  <li class="ulchildlink"><a href="query-and-update-XML.html#GUID-813C0A08-111D-4C4F-B76F-E0B41D6729F0">使用XQuery与PL / SQL，JDBC和ODP.NET访问数据库数据</a><br>您可以将XQuery与用于PL / SQL，JDBC和Oracle Data Provider for .NET（ODP.NET）的Oracle API一起使用。
                  </li>
                  <li class="ulchildlink"><a href="query-and-update-XML.html#GUID-6AE99020-C3C8-44EB-8E54-40188E1103F2">更新XML数据</a><br>有几种方法可以使用Oracle XML DB功能更新XML数据，无论是瞬态还是存储在数据库表中。
                  </li>
                  <li class="ulchildlink"><a href="query-and-update-XML.html#GUID-F72DC7CD-40A9-4F07-9350-B80D2AD1F4D0">XQuery的性能调优</a><br>涉及XQuery表达式的SQL查询通常可以通过一种或多种方式自动重写（优化）。此优化称为<strong class="term">XML查询重写</strong>或优化。发生这种情况时，实际上，XQuery表达式直接针对XML文档进行评估，而无需在内存中构建DOM。
                  </li>
               </ul>
               <div class="infoboxnotealso" id="GUID-01C75289-804F-4BAA-AE7C-DFA73198581E__GUID-F050775D-2720-43E1-933F-5FC53344E8C4">
                  <p class="notep1">也可以看看：</p>
                  <ul style="list-style-type:disc">
                     <li>
                        <p><a href="how-to-use-XML-DB.html#GUID-757B4470-851B-47B7-AB78-81F47ECE5398" title="An overview of the various ways of using Oracle XML DB is presented.">有关如何使用Oracle XML DB</a>进行<code class="codeph">XMLType</code>存储建议的<a href="how-to-use-XML-DB.html#GUID-757B4470-851B-47B7-AB78-81F47ECE5398" title="介绍了使用Oracle XML DB的各种方法的概述。">概述</a></p>
                     </li>
                     <li>
                        <p><a href="XML-Schema-and-query-basic.html#GUID-C09824C1-6B02-4556-A265-B1749DEE8DE1" title="XML Schema是用于描述XML文档的内容和结构的标准。您可以注册，更新和删除与Oracle XML DB一起使用的XML架构。您可以定义用于基于XML模式的数据的存储结构，并将XML模式数据类型映射到SQL数据类型。">XML模式存储和查询：基本</a>知识如何使用基于XML模式的<code class="codeph">XMLType</code>表和列</p>
                     </li>
                     <li>
                        <p>有关使用XQuery Update更新XML数据的信息，请参阅<a href="xquery-and-XML-DB.html#GUID-4F83A835-C94B-4D62-999B-111AB5E8A8F1" title="XQuery语言是您与Oracle XML DB中的XML数据交互的主要方式之一。对该语言的支持包括SQL * Plus commandXQUERY和SQL / XML函数XMLQuery，XMLTable，XMLExists和XMLCast。">XQuery和Oracle XML DB</a></p>
                     </li>
                  </ul>
               </div>
               <div class="familylinks">
                  <div class="parentlink">
                     <p><strong>父主题：</strong> <a href="manipulation-of-XML-in-XML-DB.html#GUID-87C758D5-5792-483D-8894-4C01FCD2A8A0" title="此处介绍了以下内容：XQuery，XMLType操作和XML数据索引。">在Oracle XML DB中处理XML数据</a></p>
                  </div>
               </div>
            </div>
            <a id="ADXDB5122"></a><a id="ADXDB5121"></a><div class="props_rev_3"><a id="GUID-4DF303DB-780C-4491-9252-234482A563A4" name="GUID-4DF303DB-780C-4491-9252-234482A563A4"></a><h3 id="ADXDB-GUID-4DF303DB-780C-4491-9252-234482A563A4" class="sect3"><span class="enumeration_section">5.1</span>将XQuery与Oracle XML DB结合使用</h3>
               <div>
                  <p>XQuery是一种非常通用和富有表现力的语言，SQL / XML函数<code class="codeph">XMLQuery</code> ， <code class="codeph">XMLTable</code> ， <code class="codeph">XMLExists</code>和<code class="codeph">XMLCast</code>将表达和计算的强大功能与SQL的优势结合在一起。</p>
                  <p>您通常以下列方式将XQuery与Oracle XML DB一起使用。这里的示例是为了反映这些不同的用途而组织的。</p>
                  <ul style="list-style-type:disc">
                     <li>
                        <p>在Oracle XML DB Repository中查询XML数据。</p>
                        <p>请参阅<a href="query-and-update-XML.html#GUID-767E262F-559F-4EBE-84C1-65683879E1D5" title="提供了在Oracle XML DB Repository中使用XQuery和XML数据的示例。您可以使用XQuery函数fn：doc和fn：collection分别查询存储库中的文件和文件夹资源。">使用XQuery在Oracle XML DB存储库中查询XML数据</a> 。
                        </p>
                     </li>
                     <li>
                        <p>查询关系表或视图，就好像它是XML数据一样。为此，您使用XQuery函数<code class="codeph">fn:collection</code> ，将URI作为参数传递给使用URI方案名称<code class="codeph">oradb</code>的URI以及数据的数据库位置。
                        </p>
                        <p>请参阅<a href="query-and-update-XML.html#GUID-E62C830B-F3FB-4381-9F74-BF5F2C417CD0" title="提供了使用XQuery查询关系表或查看数据的示例，就好像它是XML数据一样。这些示例使用XQuery函数fn：collection，将URI作为参数传递给URI，该URI使用URI方案名称oradb以及数据的数据库位置。">使用XQuery和URI方案oradb查询关系数据</a> 。
                        </p>
                     </li>
                     <li>
                        <p>查询<code class="codeph">XMLType</code>数据，可能使用函数<code class="codeph">XMLTable</code>将生成的XML分解为关系数据。
                        </p>
                        <p>请参阅<a href="query-and-update-XML.html#GUID-1165391D-BA6A-460F-BA44-66AA4A1F6595" title="提供了使用XQuery查询XMLType数据的示例。">使用XQuery查询XMLType数据</a> 。
                        </p>
                     </li>
                  </ul>
                  <p><a href="query-and-update-XML.html#GUID-4DF303DB-780C-4491-9252-234482A563A4__CBAFDFCH">示例5-1</a>创建了本章中某些其他示例中使用的Oracle XML DB存储库资源。
                  </p>
                  <div class="example" id="GUID-4DF303DB-780C-4491-9252-234482A563A4__CBAFDFCH">
                     <p class="titleinexample">示例5-1为示例创建资源</p><pre class="oac_no_warn" dir="ltr">DECLARE res BOOLEAN; empsxmlstring VARCHAR2（300）：='&lt;？xml版本=“1.0”？&gt; &lt;emps&gt; &lt;emp empno =“1”deptno =“10”ename =“John”salary =“21000”/&gt; &lt;emp empno =“2”deptno =“10”ename =“Jack”salary =“310000” /&gt; &lt;emp empno =“3”deptno =“20”ename =“Jill”salary =“100001”/&gt; &lt;/ emps&gt;'; empsxmlnsstring VARCHAR2（300）：='&lt;？xml版本=“1.0”？&gt; &lt;emps xmlns =“http://example.com”&gt; &lt;emp empno =“1”deptno =“10”ename =“John”salary =“21000”/&gt; &lt;emp empno =“2”deptno =“10 “ename =”Jack“salary =”310000“/&gt; &lt;emp empno =”3“deptno =”20“ename =”Jill“salary =”100001“/&gt; &lt;/ emps&gt;'; deptsxmlstring VARCHAR2（300）：='&lt;？xml版本=“1.0”？&gt; &lt;depts&gt; &lt;dept deptno =“10”dname =“Administration”/&gt; &lt;dept deptno =“20”dname =“Marketing”/&gt; &lt;dept deptno =“30”dname =“Purchasing”/&gt; &lt;/ depts&gt; “; BEGIN res：= DBMS_XDB_REPOS.createResource（'/ public / emps.xml'，empsxmlstring）; res：= DBMS_XDB_REPOS.createResource（'/ public / empsns.xml'，empsxmlnsstring）; res：= DBMS_XDB_REPOS.createResource（'/ public / depts.xml'，deptsxmlstring）;结束; /</pre></div>
                  <!-- class="example" -->
               </div>
               <div>
                  <ul class="ullinks">
                     <li class="ulchildlink"><a href="query-and-update-XML.html#GUID-675FAD6E-52CE-4685-B5CA-9B77ACC17422">XQuery序列可以包含任何XQuery类型的数据</a><br>XQuery是一种通用的<span class="italic">序列</span>操作语言。它的表达式和结果不一定是XML数据。XQuery序列可以包含任何XQuery类型的项，包括数字，字符串，布尔值，日期和各种类型的XML节点（ <code class="codeph">document-node()</code> ， <code class="codeph">element()</code> ， <code class="codeph">attribute()</code> ， <code class="codeph">text()</code> ， <code class="codeph">namespace()</code> ， 等等）。
                     </li>
                     <li class="ulchildlink"><a href="query-and-update-XML.html#GUID-767E262F-559F-4EBE-84C1-65683879E1D5">使用XQuery在Oracle XML DB存储库中查询XML数据</a><br>提供了在Oracle XML DB Repository中使用XQuery和XML数据的示例。您可以使用XQuery函数<code class="codeph">fn:doc</code>和<code class="codeph">fn:collection</code>分别查询存储库中的文件和文件夹资源。
                     </li>
                     <li class="ulchildlink"><a href="query-and-update-XML.html#GUID-E62C830B-F3FB-4381-9F74-BF5F2C417CD0">使用XQuery和URI方案查询关系数据oradb</a><br>提供了使用XQuery查询关系表或查看数据的示例，就好像它是XML数据一样。这些示例使用XQuery函数<code class="codeph">fn:collection</code> ，将URI作为参数传递给URI，该URI使用URI方案名称<code class="codeph">oradb</code>以及数据的数据库位置。
                     </li>
                     <li class="ulchildlink"><a href="query-and-update-XML.html#GUID-1165391D-BA6A-460F-BA44-66AA4A1F6595">使用XQuery查询XMLType数据</a><br>提供了使用XQuery查询<code class="codeph">XMLType</code>数据的示例。
                     </li>
                     <li class="ulchildlink"><a href="query-and-update-XML.html#GUID-1E1D2966-8995-4BBD-B039-2E6CEB7B275A">在XQuery中使用命名空间</a><br>您可以在XQuery表达式的prolog中使用XQuery <code class="codeph">declare namespace</code>声明来定义名称空间前缀。您可以使用<code class="codeph">declare</code> <span class="bold"><code class="codeph">default</code></span> <code class="codeph">namespace</code>将名称<code class="codeph">namespace</code>建立为表达式的默认名称空间。
                     </li>
                  </ul>
                  <div class="familylinks">
                     <div class="parentlink">
                        <p><strong>父主题：</strong> <a href="query-and-update-XML.html#GUID-01C75289-804F-4BAA-AE7C-DFA73198581E" title="应用程序有许多方法可以查询和更新Oracle数据库中的XML数据，包括基于XML模式和非基于模式的数据。">XML数据的查询和更新</a></p>
                     </div>
                  </div>
               </div>
               <a id="ADXDB5124"></a><a id="ADXDB5123"></a><div class="props_rev_3"><a id="GUID-675FAD6E-52CE-4685-B5CA-9B77ACC17422" name="GUID-675FAD6E-52CE-4685-B5CA-9B77ACC17422"></a><h4 id="ADXDB-GUID-675FAD6E-52CE-4685-B5CA-9B77ACC17422" class="sect4"><span class="enumeration_section">5.1.1</span> XQuery序列可以包含任何XQuery类型的数据</h4>
                  <div>
                     <p>XQuery是一种通用的<span class="italic">序列</span>操作语言。它的表达式和结果不一定是XML数据。XQuery序列可以包含任何XQuery类型的项，包括数字，字符串，布尔值，日期和各种类型的XML节点（ <code class="codeph">document-node()</code> ， <code class="codeph">element()</code> ， <code class="codeph">attribute()</code> ， <code class="codeph">text()</code> ， <code class="codeph">namespace()</code> ， 等等）。
                     </p>
                     <p> <a href="query-and-update-XML.html#GUID-675FAD6E-52CE-4685-B5CA-9B77ACC17422__CBAJAIAF">例5-2</a>提供了一个抽样。它将SQL / XML函数<code class="codeph">XMLQuery</code>应用于包含几种不同类型的项的XQuery序列：</p>
                     <ul style="list-style-type:disc">
                        <li>
                           <p>整数文字： <code class="codeph">1</code></p>
                        </li>
                        <li>
                           <p>算术表达式： <code class="codeph">2 + 3</code></p>
                        </li>
                        <li>
                           <p>字符串文字： <code class="codeph">"a"</code></p>
                        </li>
                        <li>
                           <p>整数序列： <code class="codeph">100 to 102</code></p>
                        </li>
                        <li>
                           <p>构造的XML元素节点： <code class="codeph">&lt;A&gt;33&lt;/A&gt;</code></p>
                        </li>
                     </ul>
                     <p><a href="query-and-update-XML.html#GUID-675FAD6E-52CE-4685-B5CA-9B77ACC17422__CBAJAIAF">例5-2</a>还显示了使用逗号运算符（ <span class="bold"><code class="codeph">,</code></span> ）和括号（ <span class="bold"><code class="codeph">(</code></span> ， <span class="bold"><code class="codeph">)</code></span> ）进行分组的序列构造。
                     </p>
                     <p>序列表达式<code class="codeph">100 to 102</code>评估序列<code class="codeph">(100, 101, 102)</code> ，因此这里<code class="codeph">XMLQuery</code>的参数是包含嵌套序列的序列。sequence参数自动展平，就像XQuery序列一样。实际上，论证是<code class="codeph">(1, 5, "a", 100, 101, 102, &lt;A&gt;33&lt;/A&gt;)</code> 。
                     </p>
                     <div class="example" id="GUID-675FAD6E-52CE-4685-B5CA-9B77ACC17422__CBAJAIAF">
                        <p class="titleinexample">示例5-2应用于不同类型项的序列的XMLQuery</p><pre class="pre codeblock"><code>SELECT XMLQuery（'（1,2 + 3，“a”，100到102，&lt;A&gt; 33 &lt;/A&gt;）'返回内容）AS DUAL输出;输出-------------------------- 1 5 a 100 101 102 &lt;A&gt; 33 &lt;/A&gt;选择1行。
</code></pre></div>
                     <!-- class="example" -->
                  </div>
                  <div>
                     <div class="familylinks">
                        <div class="parentlink">
                           <p><strong>父主题：</strong> <a href="query-and-update-XML.html#GUID-4DF303DB-780C-4491-9252-234482A563A4" title="XQuery是一种非常通用和富有表现力的语言，SQL / XML函数XMLQuery，XMLTable，XMLExists和XMLCast将表达和计算的强大功能与SQL的优势结合在一起。">将XQuery与Oracle XML DB一起使用</a></p>
                        </div>
                     </div>
                  </div>
                  
               </div><a id="ADXDB5126"></a><a id="ADXDB5127"></a><a id="ADXDB5125"></a><div class="props_rev_3"><a id="GUID-767E262F-559F-4EBE-84C1-65683879E1D5" name="GUID-767E262F-559F-4EBE-84C1-65683879E1D5"></a><h4 id="ADXDB-GUID-767E262F-559F-4EBE-84C1-65683879E1D5" class="sect4"><span class="enumeration_section">5.1.2</span>使用XQuery在Oracle XML DB存储库中查询XML数据</h4>
                  <div>
                     <p>提供了在Oracle XML DB Repository中使用XQuery和XML数据的示例。您可以使用XQuery函数<code class="codeph">fn:doc</code>和<code class="codeph">fn:collection</code>分别查询存储库中的文件和文件夹资源。
                     </p>
                     <div class="section">
                        <p>这里的示例使用XQuery函数<code class="codeph">fn:doc</code>来获取包含XML数据的存储库文件，然后使用<code class="codeph">for</code>和<code class="codeph">let</code> FLWOR-expression子句将XQuery变量绑定到该数据的某些部分。
                        </p>
                        <p><a href="query-and-update-XML.html#GUID-767E262F-559F-4EBE-84C1-65683879E1D5__CBAGIABD">示例5-3</a>在Oracle XML DB存储库中查询两个XML文档资源： <code class="codeph">/public/emps.xml</code>和<code class="codeph">/public/depts.xml</code> 。它说明了<code class="codeph">fn:doc</code>和每个可能的FLWOR表达式子句的使用。
                        </p>
                        <p><a href="query-and-update-XML.html#GUID-767E262F-559F-4EBE-84C1-65683879E1D5__CBAHEIJG">例5-4</a>也使用了每个FLWOR表达式子句。它显示了XQuery函数<code class="codeph">doc</code> ， <code class="codeph">count</code> ， <code class="codeph">avg</code>和<code class="codeph">integer</code> ，它们位于内置XQuery函数的命名空间中， <code class="codeph">http://www.w3.org/2003/11/xpath-functions</code> 。此命名空间绑定到前缀<code class="codeph">fn</code> 。
                        </p>
                     </div>
                     <!-- class="section" -->
                     <div class="example" id="GUID-767E262F-559F-4EBE-84C1-65683879E1D5__CBAGIABD">
                        <p class="titleinexample">示例5-3 FLOWR表达式使用for，let，order by，where和return</p><pre class="pre codeblock"><code>SELECT XMLQuery（'for $ e in doc（“/ public / emps.xml”）/ emps / emp let $ d：= doc（“/ public / depts.xml”）// dept [@deptno = $ e / @ deptno] / @ dname其中$ e / @ salary&gt; 100000订单$ e / @ empno返回&lt;emp ename =“{$ e / @ ename}”dept =“{$ d}”/&gt;'返回内容）来自DUAL ; XMLQUERY（'FOR $ EINDOC（“/ PUBLIC / EMPS.XML”）/ EMPS / EMPLET $ D：= DOC（“/ PUBLIC / DEPTS.XML”）--------------- -------------------------------------------------- --------------- &lt;emp ename =“Jack”dept =“Administration”&gt; &lt;/ emp&gt; &lt;emp ename =“Jill”dept =“Marketing”&gt; &lt;/ emp&gt; 1行选中。
</code></pre><p>在此示例中，各种FLWOR子句执行以下操作：</p>
                        <ul style="list-style-type:disc">
                           <li>
                              <p><span class="bold"><code class="codeph">for</code></span>迭代的<code class="codeph">emp</code>中的元素<code class="codeph">/public/emps.xml</code> ，变量绑定<code class="codeph">$e</code>到每个这样的元素的值，反过来。也就是说，它遍历一般员工列表，将<code class="codeph">$e</code>绑定到每个员工。
                              </p>
                           </li>
                           <li>
                              <p><span class="bold"><code class="codeph">let</code></span>结合变量<code class="codeph">$d</code> ，以包含所有的值的<span class="italic">序列</span> <code class="codeph">dname</code>那些属性<code class="codeph">dept</code>中的元素<code class="codeph">/public/emps.xml</code>其<code class="codeph">deptno</code>属性具有相同的值<code class="codeph">deptno</code>元件的属性<code class="codeph">$e</code> （这是一个连接操作） 。也就是说，它将<code class="codeph">$d</code>绑定到与员工<code class="codeph">$e</code>部门具有相同部门编号的所有部门的名称。（对于<code class="codeph">depts.xml</code>每个<code class="codeph">deptno</code>值， <code class="codeph">dname</code>值都是唯一的。）不同<code class="codeph">for</code> ， <code class="codeph">let</code>在价值观从未迭代;在此示例中， <code class="codeph">$d</code>仅绑定一次。
                              </p>
                           </li>
                           <li>
                              <p>一起， <code class="codeph">for</code>和<code class="codeph">let</code>产生一个元组流（ <code class="codeph">$e</code> ， <code class="codeph">$d</code> ），其中<code class="codeph">$e</code>代表一个雇员， <code class="codeph">$d</code>代表该雇员所属的所有部门的名称 - 在这种情况下，唯一的名称是员工的独特部门。
                              </p>
                           </li>
                           <li>
                              <p><span class="bold"><code class="codeph">where</code></span>过滤这个元组流，与员工其薪水大于100,000只保留元组。
                              </p>
                           </li>
                           <li>
                              <p>按雇员编号<code class="codeph">empno</code> （按升序排列，默认情况下）对筛选的元组流<span class="bold"><code class="codeph">order by</code></span>排序。
                              </p>
                           </li>
                           <li>
                              <p><span class="bold"><code class="codeph">return</code></span>构造<code class="codeph">emp</code>元素，每个元组一个元素。这些元素的属性<code class="codeph">ename</code>和<code class="codeph">dept</code>分别使用输入和<code class="codeph">$d</code>属性<code class="codeph">ename</code>构造。输出中的元素和属性名称<code class="codeph">emp</code>和<code class="codeph">ename</code>与输入文档<code class="codeph">emps.xml</code>的相同名称没有必要的连接。
                              </p>
                           </li>
                        </ul>
                     </div>
                     <!-- class="example" -->
                     <div class="example" id="GUID-767E262F-559F-4EBE-84C1-65683879E1D5__CBAHEIJG">
                        <p class="titleinexample">示例5-4使用内置函数的FLOWR表达式</p><pre class="pre codeblock"><code>SELECT XMLQuery（'fn：doc（“/ public / depts.xml”）/ depts / dept / @deptno中的$ d）$ e：= fn：doc（“/ public / emps.xml”）/ emps / emp [@deptno = $ d]其中fn：count（$ e）&gt; 1个fn命令：avg（$ e / @ salary）降序返回&lt;big-dept&gt; {$ d，&lt;headcount&gt; {fn：count（$ e） ）} &lt;/ headcount&gt;，&lt;avgsal&gt; {xs：integer（fn：avg（$ e / @ salary））} &lt;/ avgsal&gt;} &lt;/ big-dept&gt;'返回内容）来自DUAL; XMLQUERY（'FOR $ DINFN：DOC（“/ PUBLIC / DEPTS.XML”）/ DEPTS / DEPT / @ DEPTNOLET $ E：= FN：DOC（“/ P -------------- -------------------------------------------------- ---------------- &lt;big-dept deptno =“10”&gt; &lt;headcount&gt; 2 &lt;/ headcount&gt; &lt;avgsal&gt; 165500 &lt;/ avgsal&gt; &lt;/ big-dept&gt; 1行选择。
</code></pre><p>在此示例中，各种FLWOR子句执行以下操作：</p>
                        <ul style="list-style-type:disc">
                           <li>
                              <p><span class="bold"><code class="codeph">for</code></span>输入文档<code class="codeph">/public/depts.xml</code> <code class="codeph">deptno</code>属性<span class="bold"><code class="codeph">for</code></span>迭代， <code class="codeph">/public/depts.xml</code>将变量<code class="codeph">$d</code>绑定到每个这样的属性的值。
                              </p>
                           </li>
                           <li>
                              <p><span class="bold"><code class="codeph">let</code></span>将变量<code class="codeph">$e</code>绑定到由输入文档<code class="codeph">/public/emps.xml</code>的所有<code class="codeph">emp</code>元素组成的序列，其<code class="codeph">deptno</code>属性的值为<code class="codeph">$d</code> （这是一个连接操作）。
                              </p>
                           </li>
                           <li>
                              <p>一起， <code class="codeph">for</code>和<code class="codeph">let</code>产生一个元组流（ <code class="codeph">$d</code> ， <code class="codeph">$e</code> ），其中<code class="codeph">$d</code>代表一个部门号， <code class="codeph">$e</code>代表该部门的一组雇员。
                              </p>
                           </li>
                           <li>
                              <p><span class="bold"><code class="codeph">where</code></span>过滤这个元组流，与一个以上的员工只保留元组。
                              </p>
                           </li>
                           <li>
                              <p><span class="bold"><code class="codeph">order by</code></span>按平均工资降序对筛选的元组流进行排序。通过将XQuery函数<code class="codeph">avg</code> （在命名空间<code class="codeph">fn</code> ）应用于属性<code class="codeph">salary</code>的值来计算<code class="codeph">avg</code> ，该值附加到<code class="codeph">$e</code>的<code class="codeph">emp</code>元素。
                              </p>
                           </li>
                           <li>
                              <p><span class="bold"><code class="codeph">return</code></span>构造<code class="codeph">big-dept</code>元素，每个元组由<code class="codeph">order by</code> 。<code class="codeph">big-dept</code>的<code class="codeph">text()</code>节点包含部门号，绑定到<code class="codeph">$d</code> 。<code class="codeph">headcount</code>子元素包含由XQuery函数<code class="codeph">count</code>确定的绑定到<code class="codeph">$e</code>的雇员<code class="codeph">count</code> 。<code class="codeph">avgsal</code>子元素包含计算的平均工资。
                              </p>
                           </li>
                        </ul>
                     </div>
                     <!-- class="example" -->
                  </div>
                  <div>
                     <div class="relinfo">
                        <p><strong>相关话题</strong></p>
                        <ul>
                           <li><a href="xquery-and-XML-DB.html#GUID-0988D78A-DDB3-4DC2-9ED9-052B37952FE1" title="Oracle XML DB支持XQuery函数fn：doc，fn：collection和fn：doc-可用于Oracle XML DB Repository中的所有资源。">XQuery函数fn：doc，fn：collection和fn：doc-available</a></li>
                        </ul>
                     </div>
                     <div class="familylinks">
                        <div class="parentlink">
                           <p><strong>父主题：</strong> <a href="query-and-update-XML.html#GUID-4DF303DB-780C-4491-9252-234482A563A4" title="XQuery是一种非常通用和富有表现力的语言，SQL / XML函数XMLQuery，XMLTable，XMLExists和XMLCast将表达和计算的强大功能与SQL的优势结合在一起。">将XQuery与Oracle XML DB一起使用</a></p>
                        </div>
                     </div>
                  </div>
                  
               </div><a id="ADXDB5130"></a><a id="ADXDB5131"></a><a id="ADXDB5132"></a><a id="ADXDB5129"></a><div class="props_rev_3"><a id="GUID-E62C830B-F3FB-4381-9F74-BF5F2C417CD0" name="GUID-E62C830B-F3FB-4381-9F74-BF5F2C417CD0"></a><h4 id="ADXDB-GUID-E62C830B-F3FB-4381-9F74-BF5F2C417CD0" class="sect4"><span class="enumeration_section">5.1.3</span>使用XQuery和URI方案查询关系数据oradb</h4>
                  <div>
                     <p>提供了使用XQuery查询关系表或查看数据的示例，就好像它是XML数据一样。这些示例使用XQuery函数<code class="codeph">fn:collection</code> ，将URI作为参数传递给URI，该URI使用URI方案名称<code class="codeph">oradb</code>以及数据的数据库位置。
                     </p>
                     <div class="section">
                        <p><a href="query-and-update-XML.html#GUID-E62C830B-F3FB-4381-9F74-BF5F2C417CD0__CBAFCFCF">示例5-5</a>使用FLWOR表达式中的Oracle XQuery函数<code class="codeph">fn:collection</code>来查询两个关系表， <code class="codeph">regions</code>和<code class="codeph">countries</code> <code class="codeph">regions</code> 。两个表都属于示例数据库模式<code class="codeph">HR</code> 。该示例还将标量SQL值<code class="codeph">Asia</code>传递给XQuery变量<code class="codeph">$regionname</code> 。可以计算任何SQL表达式以生成使用<code class="codeph">PASSING</code>传递给XQuery的值。在这种情况下，该值来自SQL * Plus变量<code class="codeph">REGION</code> 。必须将值转换为期望的标量SQL数据类型，在本例中为<code class="codeph">VARCHAR2(40)</code> 。
                        </p>
                        <p>在<a href="query-and-update-XML.html#GUID-E62C830B-F3FB-4381-9F74-BF5F2C417CD0__CBAFCFCF">例5-5中</a> ，各种FLWOR子句执行以下操作：</p>
                     </div>
                     <!-- class="section" -->
                     <div class="section">
                        <ul style="list-style-type:disc">
                           <li>
                              <p><span class="bold"><code class="codeph">for</code></span>迭代调用<code class="codeph">fn:collection</code>返回的XML元素序列。在第一次调用中，每个元素对应一行关系表<code class="codeph">hr.regions</code>并绑定到变量<code class="codeph">$i</code> 。类似地，在第二次调用<code class="codeph">fn:collection</code> ， <code class="codeph">$j</code>绑定到表<code class="codeph">hr.countries</code>连续行。由于<code class="codeph">regions</code>和<code class="codeph">countries</code> <code class="codeph">regions</code>不是<code class="codeph">XMLType</code>表，因此与每个表中的行对应的顶级元素是<code class="codeph">ROW</code> （包装元素）。对行元素的迭代是无序的。
                              </p>
                           </li>
                           <li>
                              <p><span class="bold"><code class="codeph">where</code></span>过滤两个表中的行，只保留那些对于每个表的<code class="codeph">region_id</code>相同的行对（它在<code class="codeph">region_id</code>上执行连接）并且其<code class="codeph">region_name</code>是<code class="codeph">Asia</code> 。
                              </p>
                           </li>
                           <li>
                              <p><span class="bold"><code class="codeph">return</code></span>将表<code class="codeph">hr.countries</code>的筛选行返回为包含XML片段的XML文档，其中<code class="codeph">ROW</code>作为其顶级元素。
                              </p>
                           </li>
                        </ul>
                        <p><a href="query-and-update-XML.html#GUID-E62C830B-F3FB-4381-9F74-BF5F2C417CD0__CBAJHHJD">例5-6</a>在嵌套的FLWOR表达式中使用<code class="codeph">fn:collection</code>来查询关系数据。
                        </p>
                        <p>在<a href="query-and-update-XML.html#GUID-E62C830B-F3FB-4381-9F74-BF5F2C417CD0__CBAJHHJD">例5-6中</a> ，各种FLWOR子句执行以下操作：</p>
                        <ul style="list-style-type:disc">
                           <li>
                              <p>外部<span class="bold"><code class="codeph">for</code></span>迭代由<code class="codeph">fn:collection</code>返回的XML元素序列：每个元素对应一行关系表<code class="codeph">oe.warehouses</code>并绑定到变量<code class="codeph">$i</code> 。由于<code class="codeph">warehouses</code>不是<code class="codeph">XMLType</code>表，因此对应于行的顶级元素是<code class="codeph">ROW</code> 。行元素的迭代是无序的。
                              </p>
                           </li>
                           <li>
                              <p>内<span class="bold"><code class="codeph">for</code></span>迭代，类似地，在由返回的XML元素的序列<code class="codeph">fn:collection</code> ：每个元素对应于关系表的一个行<code class="codeph">hr.locations</code>并绑定到变量<code class="codeph">$j</code> 。
                              </p>
                           </li>
                           <li>
                              <p><span class="bold"><code class="codeph">where</code></span>过滤元组（ <code class="codeph">$i</code> ， <code class="codeph">$j</code> ），只保留那些其<code class="codeph">location_id</code>子元素与<code class="codeph">$i</code>和<code class="codeph">$j</code>相同的元素（它在<code class="codeph">location_id</code>上执行连接）。
                              </p>
                           </li>
                           <li>
                              <p>内部<span class="bold"><code class="codeph">return</code></span>构造一个元素<code class="codeph">STREET_ADDRESS</code> ， <code class="codeph">CITY</code>和<code class="codeph">STATE_PROVINCE</code>的XQuery序列，所有这些元素都是locations-table <code class="codeph">ROW</code>元素<code class="codeph">$j</code>元素。也就是说，它们是同名的locations-table列的值。
                              </p>
                           </li>
                           <li>
                              <p>外部<span class="bold"><code class="codeph">return</code></span>将内部<code class="codeph">return</code>的结果包装在<code class="codeph">Location</code>元素中，并将其包装在<code class="codeph">Warehouse</code>元素中。它为<code class="codeph">Warehouse</code>元素提供了一个<code class="codeph">id</code>属性，其值来自表<code class="codeph">warehouses</code>的<code class="codeph">warehouse_id</code>列。
                              </p>
                           </li>
                        </ul>
                        <p><a href="query-and-update-XML.html#GUID-E62C830B-F3FB-4381-9F74-BF5F2C417CD0__CBAJEGFH">例5-7</a>使用SQL / XML函数<code class="codeph">XMLTable</code>来分解XQuery查询的结果以生成虚拟关系数据。此示例中使用的XQuery表达式与<a href="query-and-update-XML.html#GUID-E62C830B-F3FB-4381-9F74-BF5F2C417CD0__CBAJHHJD">示例5-6中</a>使用的表达式相同;评估XQuery表达式的结果是一系列<code class="codeph">Warehouse</code>元素。函数<code class="codeph">XMLTable</code>生成一个虚拟关系表，其行是<code class="codeph">Warehouse</code>元素。更准确地说，在此示例中，每个虚拟表行的伪列<code class="codeph">COLUMN_VALUE</code>的值是具有单个<code class="codeph">Warehouse</code>元素的XML片段（ <code class="codeph">XMLType</code>类型）。
                        </p>
                     </div>
                     <!-- class="section" -->
                     <div class="section">
                        <div class="infoboxnotealso" id="GUID-E62C830B-F3FB-4381-9F74-BF5F2C417CD0__GUID-DAAECF5E-2366-4075-A3A6-30F85CC1A141">
                           <p class="notep1">也可以看看：</p>
                           <ul style="list-style-type:disc">
                              <li>
                                 <p><a href="query-and-update-XML.html#GUID-34E9F91A-1213-4142-B06F-91B11FD189B1__CBAIJAAD">例5-41</a> <a href="query-and-update-XML.html#GUID-E62C830B-F3FB-4381-9F74-BF5F2C417CD0__CBAJHHJD">为例5-6</a>的执行计划</p>
                              </li>
                              <li>
                                 <p><a href="query-and-update-XML.html#GUID-34E9F91A-1213-4142-B06F-91B11FD189B1__CBAJFIBF">实施例5-42</a>用于执行计划<a href="query-and-update-XML.html#GUID-E62C830B-F3FB-4381-9F74-BF5F2C417CD0__CBAJEGFH">示例5-7</a></p>
                              </li>
                           </ul>
                        </div>
                     </div>
                     <!-- class="section" -->
                     <div class="example" id="GUID-E62C830B-F3FB-4381-9F74-BF5F2C417CD0__CBAFCFCF">
                        <p class="titleinexample">示例5-5使用XMLQuery将关系数据作为XML查询</p><pre class="pre codeblock"><code>DEFINE REGION ='Asia'ELES XMLQuery（' <span class="bold">fn：collection中的</span> $ i <span class="bold">（“oradb：/ HR / REGIONS”）</span> ， <span class="bold">fn：collection中的</span> $ j <span class="bold">（“oradb：/ HR / COUNTRIES”）</span>其中$ i / ROW / REGION_ID = $ j / ROW / REGION_ID和$ i / ROW / REGION_NAME = $ regionname返回$ j'PASSING CAST（'＆REGION'AS VARCHAR2（40））AS“regionname”RETURNING CONTENT）AS asian_countries FROM DUAL;</code></pre><p>这产生以下结果。（为清楚起见，此处显示的结果非常清晰。）</p><pre class="pre codeblock"><code>ASIAN_COUNTRIES ----------------------------------------- &lt;ROW&gt; &lt;COUNTRY_ID&gt; AU &lt; / COUNTRY_ID&gt; &lt;COUNTRY_NAME&gt;澳大利亚&lt;/ COUNTRY_NAME&gt; &lt;REGION_ID&gt; 3 &lt;/ REGION_ID&gt; &lt;/ ROW&gt; &lt;ROW&gt; &lt;COUNTRY_ID&gt; CN &lt;/ COUNTRY_ID&gt; &lt;COUNTRY_NAME&gt;中国&lt;/ COUNTRY_NAME&gt; &lt;REGION_ID&gt; 3 &lt;/ REGION_ID&gt; &lt;/ ROW&gt; &lt;ROW&gt; &lt;COUNTRY_ID&gt; HK &lt;/ COUNTRY_ID&gt; &lt;COUNTRY_NAME&gt; HongKong &lt;/ COUNTRY_NAME&gt; &lt;REGION_ID&gt; 3 &lt;/ REGION_ID&gt; &lt;/ ROW&gt; &lt;ROW&gt; &lt;COUNTRY_ID&gt; IN &lt;/ COUNTRY_ID&gt; &lt;COUNTRY_NAME&gt;印度&lt;/ COUNTRY_NAME&gt; &lt;REGION_ID&gt; 3 &lt;/ REGION_ID&gt; &lt;/ ROW&gt; &lt;ROW&gt; &lt;COUNTRY_ID&gt; JP &lt;/ COUNTRY_ID&gt; &lt;COUNTRY_NAME&gt;日本&lt;/ COUNTRY_NAME&gt; &lt;REGION_ID&gt; 3 &lt;/ REGION_ID&gt; &lt;/ ROW&gt; &lt;ROW&gt; &lt;COUNTRY_ID&gt; SG &lt;/ COUNTRY_ID&gt; &lt;COUNTRY_NAME&gt;新加坡&lt;/ COUNTRY_NAME&gt; &lt;REGION_ID&gt; 3 &lt;/ REGION_ID&gt; &lt;/ ROW&gt;选择了1行。
</code></pre></div>
                     <!-- class="example" -->
                     <div class="example" id="GUID-E62C830B-F3FB-4381-9F74-BF5F2C417CD0__CBAJHHJD">
                        <p class="titleinexample">示例5-6使用嵌套的FLWOR表达式将关系数据作为XML查询</p><pre class="pre codeblock"><code>CONNECT hr输入密码： <span class="italic">密码</span>已连接。在OCE / CONNECT的位置上选择输入密码： <span class="italic">密码</span>已连接。SELECT XMLQuery（'for <span class="bold">fn：collection中的</span> $ i <span class="bold">（“oradb：/ OE / WAREHOUSES”）/ ROW</span>返回&lt;Warehouse id =“{$ i / WAREHOUSE_ID}”&gt; &lt;Location&gt; {for $ j in <span class="bold">fn：collection（“ oradb：/ HR / LOCATIONS“）/ ROW</span>其中$ j / LOCATION_ID eq $ i / LOCATION_ID返回（$ j / STREET_ADDRESS，$ j / CITY，$ j / STATE_PROVINCE）} &lt;/ Location&gt; &lt;/ Warehouse&gt;'RETURNING CONTENT）来自双重;</code></pre><p>此查询是使用嵌套FLWOR表达式的示例。它访问示例数据库模式<code class="codeph">oe</code>关系表<code class="codeph">warehouses</code>和关系表<code class="codeph">locations</code> （位于示例数据库模式<code class="codeph">HR</code> 。要以用户<code class="codeph">oe</code>身份运行此示例，必须首先以用户<code class="codeph">hr</code>身份连接并授予用户<code class="codeph">oe</code>权限以对表<code class="codeph">locations</code>执行<code class="codeph">SELECT</code>操作。
                        </p>
                        <p>这产生以下结果。（为清楚起见，此处显示的结果非常清晰。）</p><pre class="pre codeblock"><code>XMLQUERY（'FOR $ IINFN：COLLECTION（“ORADB：/ OE / WAREHOUSES”）/ ROWRETURN &lt;WAREHOUSEID =“{$ ------------------------ -------------------------------------------------- ------ &lt;仓库id =“1”&gt; &lt;位置&gt; &lt;STREET_ADDRESS&gt; 2014 Jabberwocky Rd &lt;/ STREET_ADDRESS&gt; &lt;CITY&gt; Southlake &lt;/ CITY&gt; &lt;STATE_PROVINCE&gt; Texas &lt;/ STATE_PROVINCE&gt; &lt;/ Location&gt; &lt;/ Warehouse &gt; &lt;仓库ID =“2”&gt; &lt;位置&gt; &lt;STREET_ADDRESS&gt; 2011室内装饰大道&lt;/ STREET_ADDRESS&gt; &lt;CITY&gt;南旧金山&lt;/ CITY&gt; &lt;STATE_PROVINCE&gt;加利福尼亚州&lt;/ STATE_PROVINCE&gt; &lt;/ Location&gt; &lt;/ Warehouse&gt; &lt;仓库id =“3”&gt; &lt;Location&gt; &lt;STREET_ADDRESS&gt; 2007 Zagora St &lt;/ STREET_ADDRESS&gt; &lt;CITY&gt;南不伦瑞克&lt;/ CITY&gt; &lt;STATE_PROVINCE&gt;新泽西州&lt;/ STATE_PROVINCE&gt; &lt;/ Location&gt; &lt;/ Warehouse&gt; &lt;Warehouse id =“ 4“&gt; &lt;位置&gt; &lt;STREET_ADDRESS&gt; 2004 Charade Rd &lt;/ STREET_ADDRESS&gt; &lt;CITY&gt;西雅图&lt;/ CITY&gt; &lt;STATE_PROVINCE&gt;华盛顿&lt;/ STATE_PROVINCE&gt; &lt;/ Location&gt; &lt;/ Warehouse&gt; &lt;Warehouse id =”5“&gt; &lt;Location &gt; &lt;STREET_ADDRESS&gt; 147 Spadina Ave &lt;/ STREET_ADDRESS&gt; &lt;CITY&gt;多伦多&lt;/ CITY&gt; &lt;STATE_PROVINCE&gt; Ontario &lt;/ STATE_PROVINC E&gt; &lt;/ Location&gt; &lt;/ Warehouse&gt; &lt;Warehouse id =“6”&gt; &lt;Location&gt; &lt;STREET_ADDRESS&gt; 12-98 Victoria Street &lt;/ STREET_ADDRESS&gt; &lt;CITY&gt; Sydney &lt;/ CITY&gt; &lt;STATE_PROVINCE&gt;新南威尔士&lt;/ STATE_PROVINCE &gt; &lt;/ Location&gt; &lt;/ Warehouse&gt; &lt;Warehouse id =“7”&gt; &lt;Location&gt; &lt;STREET_ADDRESS&gt; Mariano Escobedo 9991 &lt;/ STREET_ADDRESS&gt; &lt;CITY&gt;墨西哥城&lt;/ CITY&gt; &lt;STATE_PROVINCE&gt; Distrito Federal，&lt;/ STATE_PROVINCE&gt; &lt; / Location&gt; &lt;/ Warehouse&gt; &lt;Warehouse id =“8”&gt; &lt;Location&gt; &lt;STREET_ADDRESS&gt; 40-5-12 Laogianggen &lt;/ STREET_ADDRESS&gt; &lt;CITY&gt; Beijing &lt;/ CITY&gt; &lt;/ Location&gt; &lt;/ Warehouse&gt; &lt;Warehouse id =“9”&gt; &lt;位置&gt; &lt;STREET_ADDRESS&gt; 1298 Vileparle（E）&lt;/ STREET_ADDRESS&gt; &lt;CITY&gt; Bombay &lt;/ CITY&gt; &lt;STATE_PROVINCE&gt; Maharashtra &lt;/ STATE_PROVINCE&gt; &lt;/ Location&gt; &lt;/ Warehouse&gt;选择1行。
</code></pre></div>
                     <!-- class="example" -->
                     <div class="example" id="GUID-E62C830B-F3FB-4381-9F74-BF5F2C417CD0__CBAJEGFH">
                        <p class="titleinexample">示例5-7使用XMLTable将关系数据作为XML查询</p><pre class="pre codeblock"><code>SELECT * FROM XMLTable（'for fn：collection中的$ i（“oradb：/ OE / WAREHOUSES”）/ ROW返回&lt;Warehouse id =“{$ i / WAREHOUSE_ID}”&gt; &lt;Location&gt; {for f in fn：collection （“oradb：/ HR / LOCATIONS”）/ ROW，其中$ j / LOCATION_ID eq $ i / LOCATION_ID返回（$ j / STREET_ADDRESS，$ j / CITY，$ j / STATE_PROVINCE）} &lt;/ Location&gt; &lt;/ Warehouse&gt;'） ;</code></pre><p>这产生与<a href="query-and-update-XML.html#GUID-E62C830B-F3FB-4381-9F74-BF5F2C417CD0__CBAJHHJD">示例5-6</a>相同的结果，除了每个<code class="codeph">Warehouse</code>元素作为单独的行输出，而不是在一行中一起输出所有<code class="codeph">Warehouse</code>元素。
                        </p><pre class="pre codeblock"><code>COLUMN_VALUE ------------------------------------------------- ------- &lt;仓库ID =“1”&gt; &lt;位置&gt; &lt;STREET_ADDRESS&gt; 2014 Jabberwocky Rd &lt;/ STREET_ADDRESS&gt; &lt;CITY&gt; Southlake &lt;/ CITY&gt; &lt;STATE_PROVINCE&gt; Texas &lt;/ STATE_PROVINCE&gt; &lt;/ Location&gt; &lt;/仓库&gt; &lt;仓库ID =“2”&gt; &lt;位置&gt; &lt;STREET_ADDRESS&gt; 2011室内装饰大道&lt;/ STREET_ADDRESS&gt; &lt;CITY&gt;南旧金山&lt;/ CITY&gt; &lt;STATE_PROVINCE&gt;加利福尼亚州&lt;/ STATE_PROVINCE&gt; &lt;/ Location&gt; &lt;/ Warehouse&gt; <span class="bold">。 。 。</span>
 
<span class="bold">选择了9行。</span></code></pre></div>
                     <!-- class="example" -->
                  </div>
                  <div>
                     <div class="familylinks">
                        <div class="parentlink">
                           <p><strong>父主题：</strong> <a href="query-and-update-XML.html#GUID-4DF303DB-780C-4491-9252-234482A563A4" title="XQuery是一种非常通用和富有表现力的语言，SQL / XML函数XMLQuery，XMLTable，XMLExists和XMLCast将表达和计算的强大功能与SQL的优势结合在一起。">将XQuery与Oracle XML DB一起使用</a></p>
                        </div>
                     </div>
                  </div>
                  
               </div><a id="ADXDB5134"></a><a id="ADXDB5135"></a><a id="ADXDB5136"></a><a id="ADXDB5137"></a><a id="ADXDB6227"></a><a id="ADXDB6228"></a><a id="ADXDB5138"></a><a id="ADXDB5133"></a><div class="props_rev_3"><a id="GUID-1165391D-BA6A-460F-BA44-66AA4A1F6595" name="GUID-1165391D-BA6A-460F-BA44-66AA4A1F6595"></a><h4 id="ADXDB-GUID-1165391D-BA6A-460F-BA44-66AA4A1F6595" class="sect4"><span class="enumeration_section">5.1.4</span>使用XQuery查询XMLType数据</h4>
                  <div>
                     <p>提供了使用XQuery查询<code class="codeph">XMLType</code>数据的示例。
                     </p>
                     <div class="section">
                        <p><a href="query-and-update-XML.html#GUID-1165391D-BA6A-460F-BA44-66AA4A1F6595__CBADDAEJ">例5-8中</a>的查询使用函数<code class="codeph">XMLQuery</code>和<code class="codeph">PASSING</code>子句将<code class="codeph">XMLType</code>列（ <code class="codeph">warehouse_spec</code> ）作为<span class="italic">上下文</span>项传递给XQuery。它为面积大于80,000的每个仓库构建一个<code class="codeph">Details</code>元素： <code class="codeph">/Warehouse/Area &gt; 80000</code> 。
                        </p>
                        <p>在<a href="query-and-update-XML.html#GUID-1165391D-BA6A-460F-BA44-66AA4A1F6595__CBADDAEJ">示例5-8中</a> ，函数<code class="codeph">XMLQuery</code>应用于表<code class="codeph">warehouses</code>中每行的<code class="codeph">warehouse_spec</code>列。各种FLWOR条款执行以下操作：</p>
                     </div>
                     <!-- class="section" -->
                     <div class="section">
                        <ul style="list-style-type:disc">
                           <li>
                              <p><span class="bold"><code class="codeph">for</code></span>在迭代<code class="codeph">Warehouse</code>列的每一行中的元素<code class="codeph">warehouse_spec</code> （传递的上下文项）：每一个这样的元件被绑定到变量<code class="codeph">$i</code> ，反过来。迭代是无序的。
                              </p>
                           </li>
                           <li>
                              <p><span class="bold"><code class="codeph">where</code></span>过滤<code class="codeph">Warehouse</code>的元素，只保留那些<code class="codeph">Area</code>的孩子有一个更大的超过80,000价值。
                              </p>
                           </li>
                           <li>
                              <p><span class="bold"><code class="codeph">return</code></span>构造一个XQuery序列的<code class="codeph">Details</code>元素，每个元素都包含一个<code class="codeph">Docks</code>和一个<code class="codeph">Rail</code>子元素。构造的<code class="codeph">Docks</code>元素的<code class="codeph">num</code>属性设置为<code class="codeph">Warehouse</code>的<code class="codeph">Docks</code>子元素的<code class="codeph">text()</code>值。<code class="codeph">Rail</code>的<code class="codeph">text()</code>内容设置为<code class="codeph">true</code>或<code class="codeph">false</code> ，具体取决于元素<code class="codeph">Warehouse</code>的<code class="codeph">RailAccess</code>属性的值。
                              </p>
                           </li>
                        </ul>
                        <p><a href="query-and-update-XML.html#GUID-1165391D-BA6A-460F-BA44-66AA4A1F6595__CBADDAEJ">例5-8中</a>的<code class="codeph">SELECT</code>语句适用于表<code class="codeph">warehouses</code>每一行。<code class="codeph">XMLQuery</code>表达式返回与XQuery表达式不匹配的行的<span class="italic">空序列</span> 。只有新泽西州和西雅图的仓库满足XQuery查询，因此它们是唯一返回<code class="codeph">&lt;Details&gt;...&lt;/Details&gt;</code>仓库。
                        </p>
                        <p><a href="query-and-update-XML.html#GUID-1165391D-BA6A-460F-BA44-66AA4A1F6595__CBAHBFGE">例5-9</a>使用SQL / XML函数<code class="codeph">XMLTable</code>查询<code class="codeph">XMLType</code>表<code class="codeph">oe.purchaseorder</code> ，该表包含基于XML Schema的数据。它使用<code class="codeph">PASSING</code>子句将<code class="codeph">purchaseorder</code>表作为<code class="codeph">XMLTable</code>的XQuery-expression参数的上下文项提供。生成的虚拟表的伪列<code class="codeph">COLUMN_VALUE</code>包含构造元素<code class="codeph">A10po</code> ，其中包含<code class="codeph">CostCenter</code>元素值为<code class="codeph">A10</code>且其<code class="codeph">User</code>元素值为<code class="codeph">SMCCAIN</code>那些采购订单的<code class="codeph">Reference</code>信息。该查询执行虚拟表和数据库表<code class="codeph">purchaseorder</code>订单之间的连接。
                        </p>
                        <p>的<code class="codeph">PASSING</code>功能的子句<code class="codeph">XMLTable</code>经过<code class="codeph">OBJECT_VALUE</code>的<code class="codeph">XMLType</code>表<code class="codeph">purchaseorder</code> ，以作为XPath的上下文。因此， <code class="codeph">XMLTable</code>表达式<span class="italic">取决于</span> <code class="codeph">purchaseorder</code>表。因此，table <code class="codeph">purchaseorder</code>必须出现<span class="italic">在</span> <code class="codeph">FROM</code>列表中的<code class="codeph">XMLTable</code>表达式<span class="italic">之前</span> 。这是涉及数据依赖性的任何情况的一般要求。
                        </p>
                        <div class="infoboxnote" id="GUID-1165391D-BA6A-460F-BA44-66AA4A1F6595__GUID-67B1E71C-5740-4DFE-B645-C765A674E3BA">
                           <p class="notep1">注意：</p>
                           <p>每当<code class="codeph">PASSING</code>子句引用查询中的<code class="codeph">XMLType</code>表的列时，该表<span class="italic"><span class="bold">必须出现在</span></span>查询<code class="codeph">FROM</code>列表中的<code class="codeph">XMLTable</code>表达式<span class="italic"><span class="bold">之前</span></span> 。这是因为<code class="codeph">XMLTable</code>表达式<span class="italic">依赖</span>于<code class="codeph">XMLType</code>表 - 需要<span class="italic">左侧</span> （相关）连接，以确保访问的<code class="codeph">XMLType</code>表行与<code class="codeph">XMLTable</code>生成的行之间的一对多（1：N）关系。
                           </p>
                        </div>
                        <p><a href="query-and-update-XML.html#GUID-1165391D-BA6A-460F-BA44-66AA4A1F6595__CBAJIBCD">实施例5-10</a>的效果类似于<a href="query-and-update-XML.html#GUID-1165391D-BA6A-460F-BA44-66AA4A1F6595__CBAHBFGE">实施例5-9</a> 。它使用<code class="codeph">XMLQuery</code>而不是<code class="codeph">XMLTable</code>来查询<code class="codeph">oe.purchaseorder</code> 。这两个示例在处理XQuery表达式返回的空序列方面有所不同。在<a href="query-and-update-XML.html#GUID-1165391D-BA6A-460F-BA44-66AA4A1F6595__CBAHBFGE">示例5-9中</a> ，这些空序列未与<code class="codeph">purchaseorder</code>表连接，因此整个SQL查询结果集只有十行。在<a href="query-and-update-XML.html#GUID-1165391D-BA6A-460F-BA44-66AA4A1F6595__CBAJIBCD">示例5-10中</a> ，这些空序列是SQL查询的整个结果集的一部分，其中包含132行，每个行对应于表<code class="codeph">purchaseorder</code>每一行。除了十行之外的所有行都是空的，并在输出中显示为空行。为了节省空间，这些空行已被删除。
                        </p>
                        <div class="infoboxnotealso" id="GUID-1165391D-BA6A-460F-BA44-66AA4A1F6595__GUID-4BE2171D-BB96-4644-8766-32DD119281D8">
                           <p class="notep1">也可以看看：</p>
                           <p><a href="query-and-update-XML.html#GUID-B34F476B-5961-4C4B-9076-454C79D7B583__CBAFEHBC">示例5-43</a>用于<a href="query-and-update-XML.html#GUID-1165391D-BA6A-460F-BA44-66AA4A1F6595__CBAJIBCD">示例5-10</a>的执行计划</p>
                        </div>
                        <p><a href="query-and-update-XML.html#GUID-1165391D-BA6A-460F-BA44-66AA4A1F6595__CBAJEEFD">例5-11</a>使用<code class="codeph">XMLTable</code>子句<code class="codeph">PASSING</code>和<code class="codeph">COLUMNS</code> 。 XQuery表达式迭代顶级<code class="codeph">PurchaseOrder</code>元素，为成本中心<code class="codeph">A10</code>每个采购订单构建<code class="codeph">PO</code>元素。然后将生成的<code class="codeph">PO</code>元素传递给<code class="codeph">XMLTable</code>进行处理。
                        </p>
                        <p>在<a href="query-and-update-XML.html#GUID-1165391D-BA6A-460F-BA44-66AA4A1F6595__CBAJEEFD">例5-11中</a> ，来自<code class="codeph">PurchaseOrder</code>子<a href="query-and-update-XML.html#GUID-1165391D-BA6A-460F-BA44-66AA4A1F6595__CBAJEEFD">节点的</a>数据用于构造<code class="codeph">PO</code>的子<code class="codeph">PO</code> ，它们是<code class="codeph">Ref</code> ， <code class="codeph">Type</code>和<code class="codeph">Name</code> 。的内容<code class="codeph">Type</code>是从内容采取<code class="codeph">/PurchaseOrder/SpecialInstructions</code> ，但类<code class="codeph">SpecialInstructions</code>针对不同划分<code class="codeph">Type</code> 。
                        </p>
                        <p>函数<code class="codeph">XMLTable</code>打破了XQuery评估的结果，将其作为虚拟表的三个<code class="codeph">VARCHAR2</code>列返回： <code class="codeph">poref</code> ， <code class="codeph">priority</code>和<code class="codeph">contact</code> 。<code class="codeph">DEFAULT</code>子句用于提供<code class="codeph">Regular</code>的默认<code class="codeph">priority</code> 。
                        </p>
                        <p><a href="query-and-update-XML.html#GUID-1165391D-BA6A-460F-BA44-66AA4A1F6595__CBAJEEFD">示例5-11</a>不使用<code class="codeph">RETURNING SEQUENCE BY REF</code>子句，这意味着返回然后由<code class="codeph">COLUMNS</code>子句使用的XQuery序列是按<span class="italic">值</span>传递的，而不是通过引用传递的。也就是说，返回目标节点的副本，而不是对实际节点的引用。
                        </p>
                        <p>当返回的序列按值传递时， <code class="codeph">COLUMNS</code>子句中指定的列不能引用该返回副本中不存在的任何数据。特别是，它们不能引用源数据中目标节点<span class="italic">之前</span>的数据。
                        </p>
                        <p>为了能够从<code class="codeph">COLUMNS</code>子句中的列规范引用源数据的任意部分，您需要使用<code class="codeph">RETURNING SEQUENCE BY REF</code>子句，这会导致XQuery表达式产生的序列通过<span class="italic">引用</span>返回。
                        </p>
                        <p><a href="query-and-update-XML.html#GUID-1165391D-BA6A-460F-BA44-66AA4A1F6595__BABIHBJA">示例5-12</a>显示了使用<code class="codeph">RETURNING SEQUENCE BY REF</code>子句，它允许列<code class="codeph">reference</code> XQuery表达式所针对的节点之外的节点。因为<code class="codeph">LineItem</code>节点的序列是通过引用返回的，所以代码可以访问完整的节点树，因此它可以向上导航，然后返回到节点<code class="codeph">Reference</code> 。
                        </p>
                        <p>子句<code class="codeph">RETURNING SEQUENCE BY REF</code>允许您指定通过引用返回评估用于生成<code class="codeph">XMLTable</code>行的顶级XQuery表达式的结果。对于在<code class="codeph">COLUMNS</code>子句中评估<code class="codeph">PATH</code>表达式的结果，可以使用相同的选项。要指定通过引用返回此类结果，请使用<code class="codeph">XMLType (SEQUENCE) BY REF</code>作为列数据类型。
                        </p>
                        <p><a href="query-and-update-XML.html#GUID-1165391D-BA6A-460F-BA44-66AA4A1F6595__BABIDCFE">例5-13</a>说明了这一点。它将两个<code class="codeph">XMLTable</code>表<code class="codeph">t1</code>和<code class="codeph">t2</code>链接在一起，通过引用从源文档返回XML数据：</p>
                        <ul style="list-style-type:disc">
                           <li>
                              <p>对于顶级表的列<code class="codeph">reference</code> ， <code class="codeph">t1</code> ，因为它对应于元素<code class="codeph">LineItem</code>之外的节点（如<a href="query-and-update-XML.html#GUID-1165391D-BA6A-460F-BA44-66AA4A1F6595__BABIHBJA">示例5-12中所示</a> ）</p>
                           </li>
                           <li>
                              <p>对于表<code class="codeph">t1</code>列<code class="codeph">part</code> ，因为它被传递给表<code class="codeph">t2</code> ，其列<code class="codeph">item</code>以节点<code class="codeph">Part</code>之外的数据为目标</p>
                           </li>
                        </ul>
                        <p>在表<code class="codeph">t1</code> ，用于列<code class="codeph">part</code>的类型是<code class="codeph">XMLType (SEQUENCE) BY REF</code> ，因此<code class="codeph">part</code>数据是对其<code class="codeph">PATH</code>表达式<code class="codeph">LineItem/Part</code>针对的源数据的引用。这是必需的，因为表<code class="codeph">t2</code>列<code class="codeph">item</code>的<code class="codeph">PATH</code>表达式定位元素<code class="codeph">Part</code> ， <code class="codeph">LineItem</code>的父<code class="codeph">item</code>属性<code class="codeph">ItemNumber</code> 。如果不指定该<code class="codeph">part</code>是引用，它将只是<code class="codeph">Part</code>元素的副本，因此使用<code class="codeph">PATH</code>表达式<code class="codeph">../@ItemNumber</code>会引发错误。
                        </p>
                        <p><a href="query-and-update-XML.html#GUID-1165391D-BA6A-460F-BA44-66AA4A1F6595__CBACIIDC">示例5-14</a>使用SQL / XML函数<code class="codeph">XMLTable</code>将<code class="codeph">XMLType</code>集合元素<code class="codeph">LineItem</code>的XML数据分解为虚拟表的单独列。
                        </p>
                        <div class="infoboxnotealso" id="GUID-1165391D-BA6A-460F-BA44-66AA4A1F6595__GUID-B8F2C036-D950-40E0-AEAE-5813F0F7A079">
                           <p class="notep1">也可以看看：</p>
                           <ul style="list-style-type:disc">
                              <li>
                                 <p><a href="query-and-update-XML.html#GUID-B34F476B-5961-4C4B-9076-454C79D7B583__CBABFDJG">示例5-44</a> <a href="query-and-update-XML.html#GUID-1165391D-BA6A-460F-BA44-66AA4A1F6595__CBACIIDC">示例5-14</a>的执行计划</p>
                              </li>
                              <li>
                                 <p><a href="relational-views-over-XML-data.html#GUID-E550E7D4-0D19-47CA-B86F-76825EE54CE1" title="要将XMLType表的多个级别的数据作为关系视图中的单个行公开，请将SQL / XML函数XMLTable应用于每个级别。只要XMLType表中的文档与视图中的行之间存在一对多（1：N）关系，就使用此技术。">通过XML创建关系视图：将XML节点映射到列</a> ，以获取将<code class="codeph">XMLTable</code>应用于多个文档级别的示例（多级链接）</p>
                              </li>
                           </ul>
                        </div>
                     </div>
                     <!-- class="section" -->
                     <div class="example" id="GUID-1165391D-BA6A-460F-BA44-66AA4A1F6595__CBADDAEJ">
                        <p class="titleinexample">示例5-8使用XMLQuery PASSING子句查询XMLType列</p><pre class="pre codeblock"><code>SELECT仓库名称，XMLQuery（'for $ i in / Warehouse，其中$ i / Area&gt; 80000返回&lt;Details&gt; &lt;Docks num =“{$ i / Docks}”/&gt; &lt;Rail&gt; {if（$ i / RailAccess =“Y “）然后”true“否则”false“} &lt;/ Rail&gt; &lt;/ Details&gt;'PASSING warehouse_spec RETURNING CONTENT）big_warehouses from oe.warehouses;</code></pre><p>这会产生以下输出：</p><pre class="pre codeblock"><code>WAREHOUSE_NAME -------------- BIG_WAREHOUSES --------------德克萨斯州Southlake旧金山新泽西州&lt;详情&gt; &lt;Docks num =“”&gt; &lt;/ Docks &gt; &lt;Rail&gt; false &lt;/ Rail&gt; &lt;/ Details&gt;西雅图，华盛顿&lt;详情&gt; &lt;码数num =“3”&gt; &lt;/ Docks&gt; &lt;Rail&gt; true &lt;/ Rail&gt; &lt;/ Details&gt;多伦多悉尼墨西哥城北京孟买9选中的行。
</code></pre></div>
                     <!-- class="example" -->
                     <div class="example" id="GUID-1165391D-BA6A-460F-BA44-66AA4A1F6595__CBAHBFGE">
                        <p class="titleinexample">示例5-9将XMLTABLE与基于XML模式的数据一起使用</p><pre class="pre codeblock"><code>SELECT xtab。COLUMN_VALUE来自purchaseorder，XMLTable（'$ i in / PurchaseOrder，其中$ i / CostCenter eq“A10”和$ i / User eq“SMCCAIN”返回&lt;A10po pono =“{$ i / Reference}”/&gt;'PASSING OBJECT_VALUE） xtab文件; COLUMN_VALUE ------------------------------------------------- -  &lt;A10po pono =“SMCCAIN-20021009123336151PDT”&gt; &lt;/ A10po&gt; &lt;A10po pono =“SMCCAIN-20021009123336341PDT”&gt; &lt;/ A10po&gt; &lt;A10po pono =“SMCCAIN-20021009123337173PDT”&gt; &lt;/ A10po&gt; &lt;A10po pono =“SMCCAIN -2001009123335681PDT“&gt; &lt;/ A10po&gt; &lt;A10po pono =”SMCCAIN-20021009123335470PDT“&gt; &lt;/ A10po&gt; &lt;A10po pono =”SMCCAIN-20021009123336972PDT“&gt; &lt;/ A10po&gt; &lt;A10po pono =”SMCCAIN-20021009123336842PDT“&gt; &lt;/ A10po&gt; &lt;A10po pono =“SMCCAIN-20021009123336512PDT”&gt; &lt;/ A10po&gt; &lt;A10po pono =“SMCCAIN-2002100912333894PDT”&gt; &lt;/ A10po&gt; &lt;A10po pono =“SMCCAIN-20021009123337403PDT”&gt; &lt;/ A10po&gt;选择10行。
</code></pre></div>
                     <!-- class="example" -->
                     <div class="example" id="GUID-1165391D-BA6A-460F-BA44-66AA4A1F6595__CBAJIBCD">
                        <p class="titleinexample">示例5-10将XMLQUERY与基于XML模式的数据一起使用</p><pre class="pre codeblock"><code>SELECT XMLQuery（'for $ i in / PurchaseOrder，其中$ i / CostCenter eq“A10”和$ i / User eq“SMCCAIN”返回&lt;A10po pono =“{$ i / Reference}”/&gt;'PASSING OBJECT_VALUE RETURNING CONTENT）FROM采购订单; XMLQUERY（'FOR $ IIN / PURCHASEORDERWHERE $ I / COSTCENTEREQ“A10”和$ I / USEREQ“SMCCAIN”RET -------------------------- -------------------------------------------------- ---- &lt;A10po pono =“SMCCAIN-20021009123336151PDT”&gt; &lt;/ A10po&gt; &lt;A10po pono =“SMCCAIN-20021009123336341PDT”&gt; &lt;/ A10po&gt; &lt;A10po pono =“SMCCAIN-20021009123337173PDT”&gt; &lt;/ A10po&gt; &lt;A10po pono = “SMCCAIN-20021009123335681PDT”&gt; &lt;/ A10po&gt; &lt;A10po pono =“SMCCAIN-20021009123335470PDT”&gt; &lt;/ A10po&gt; &lt;A10po pono =“SMCCAIN-20021009123336972PDT”&gt; &lt;/ A10po&gt; &lt;A10po pono =“SMCCAIN-20021009123336842PDT”&gt; &lt;/ A10po&gt; &lt;A10po pono =“SMCCAIN-20021009123336512PDT”&gt; &lt;/ A10po&gt; &lt;A10po pono =“SMCCAIN-2002100912333894PDT”&gt; &lt;/ A10po&gt; &lt;A10po pono =“SMCCAIN-20021009123337403PDT”&gt; &lt;/ A10po&gt; <span class="bold">选择132行。</span></code></pre></div>
                     <!-- class="example" -->
                     <div class="example" id="GUID-1165391D-BA6A-460F-BA44-66AA4A1F6595__CBAJEEFD">
                        <p class="titleinexample">示例5-11将XMLTABLE与PASSING和COLUMNS子句一起使用</p><pre class="pre codeblock"><code>SELECT xtab.poref，xtab.priority，xtab.contact FROM purchaseorder，XMLTable（'for $ i in / PurchaseOrder let $ spl：= $ i / SpecialInstructions其中$ i / CostCenter eq“A10”返回&lt;PO&gt; &lt;Ref&gt; { $ i / Reference} &lt;/ Ref&gt; {if（$ spl eq“Next Day Air”或$ spl eq“Expedite”）然后&lt;Type&gt; Fastest &lt;/ Type&gt; else if（$ spl eq“Air Mail”）then &lt;类型&gt;快速&lt;/类型&gt; <span class="bold">否则（）}</span> &lt;名称&gt; {$ I /请求者} &lt;/名称&gt; &lt;/ PO&gt; ' <span class="bold">逝水</span> OBJECT_VALUE <span class="bold">COLUMNS</span> poref VARCHAR2（20）PATH '编号'，优先VARCHAR2（8）PATH'型<span class="bold">“DEFAULT</span> '常规'，联系VARCHAR2（20）PATH '姓名'）xtab中; POREF PRIORITY CONTACT -------------------- -------- ------------------- -  SKING-20021009123336最快Steven A. King SMCCAIN-200210091233常规Samuel B. McCain SMCCAIN-200210091233最快Samuel B. McCain JCHEN-20021009123337最快John Z. Chen JCHEN-20021009123337常规John Z. Chen SKING-20021009123337常规Steven A. King SMCCAIN -200210091233常规Samuel B. McCain JCHEN-20021009123338常规John Z. Chen SMCCAIN-200210091233常规Samuel B. McCain SKING-20021009123335常规Steven X. King SMCCAIN-200210091233常规Samuel B. McCain SKING-20021009123336常规Steven A. King SMCCAIN-200210091233快速塞缪尔B.麦凯恩SKING-20021009123336最快史蒂文A.金SKING-20021009123336最快史蒂文A.金SMCCAIN-200210091233常规塞缪尔B.麦凯恩JCHEN-20021009123335常规约翰Z.陈SKING-20021009123336常规史蒂文A.金JCHEN-20021009123336常规约翰Z. Chen SKING-20021009123336常规Steven A. King SMCCAIN-200210091233常规Samuel B. McCain SKING-20021009123337常规Steven A. King SKING-20021009123338最快Steven A. King SMCCAIN-200210091233常规Samuel B. McCain JCHEN-20021009123337常规John Z. Chen JCHEN-20021009123337常规John Z. Chen JCHEN-20021009123337常规John Z. Chen SKING- 20021009123337常规Steven A. King JCHEN-20021009123337常规John Z. Chen SKING-20021009123337常规Steven A. King SKING-20021009123337常规Steven A. King SMCCAIN-200210091233快速Samuel B. McCain 32行入选。
</code></pre></div>
                     <!-- class="example" -->
                     <div class="example" id="GUID-1165391D-BA6A-460F-BA44-66AA4A1F6595__BABIHBJA">
                        <p class="titleinexample">示例5-12使用XMLTABLE和REF的RETURNING SEQUENCE</p><pre class="pre codeblock"><code>选择t。* FROM purchaseorder，XMLTable（'/ / PurchaseOrder / LineItems / LineItem'通过<span class="bold">REF</span> COLUMNS传递OBJECT_VALUE RETURNING <span class="bold">SEQUENCE</span>参考VARCHAR2（30）PATH' <span class="bold">../ ../ reference</span> '，item VARCHAR2（4）PATH' @ ItemNumber'，description VARCHAR2（45）PATH'Description'）t WHERE item = 5;参考项目描述------------------------------ ---- ------------- ----------------------- AMCEWEN-20021009123336171PDT 5 Coup De Torchon（清洁板岩）AMCEWEN-20021009123336271PDT 5难以忍受的轻盈感PTUCKER-20021009123336191PDT 5 The Scarlet Empress PTUCKER-20021009123336291PDT 5难以忍受的轻盈SBELL-20021009123336231PDT 5黑水仙SBELL-20021009123336331PDT 5钓鱼约翰1 -3 SKING-20021009123336321PDT 5红鞋SMCCAIN-20021009123336151PDT 5工资恐惧SMCCAIN-20021009123336341PDT 5最危险的游戏VJONES-20021009123336301PDT 5 Le Trou选择了10行。
</code></pre></div>
                     <!-- class="example" -->
                     <div class="example" id="GUID-1165391D-BA6A-460F-BA44-66AA4A1F6595__BABIDCFE">
                        <p class="titleinexample">示例5-13使用链接的XMLTABLE和Access by Reference</p><pre class="pre codeblock"><code>SELECT t1.reference，t2.id，t2.item FROM purchaseorder，XMLTable（'/ / PurchaseOrder / LineItems'PASSING OBJECT_VALUE RETURNING <span class="bold">SEQUENCE BY REF</span> COLUMNS part <span class="bold">XMLType（SEQUENCE）BY REF</span> PATH'RineItem / Part'，reference VARCHAR2（30）PATH ” ../ reference'）t1，XMLTable（'。'通过t1.part返回<span class="bold">由REF</span> COLUMNS返回的<span class="bold">序列</span> id VARCHAR2（12）路径'@Id'，项目NUMBER PATH'../ @ ItemNumber'）t2;</code></pre></div>
                     <!-- class="example" -->
                     <div class="example" id="GUID-1165391D-BA6A-460F-BA44-66AA4A1F6595__CBACIIDC">
                        <p class="titleinexample">示例5-14使用XMLTABLE将XML集合元素分解为关系数据</p><pre class="pre codeblock"><code>SELECT lines.lineitem，lines.description，lines.partid，lines.unitprice，lines.quantity FROM purchaseorder，XMLTable（'for $ i in / PurchaseOrder / LineItems / LineItem，其中$ i / @ ItemNumber&gt; = 8和$ i / Part / @ UnitPrice&gt; 50和$ i / Part / @ Quantity&gt; 2返回$ i'PASSING OBJECT_VALUE COLUMNS lineitem NUMBER PATH' @ ItemNumber'，description VARCHAR2（30）PATH'Description'，partid NUMBER PATH'Part / @ Id'， unitprice NUMBER PATH'Part / @ UnitPrice'，数量NUMBER PATH'Part / @ Quantity'）行;线条描述PARTID UNITPRICE QUANTITY -------- ------------------------------ ------- ------ --------- -------- 11 Orphic Trilogy 37429148327 80 3 22 Dreyer Box Set 37429158425 80 4 11 Dreyer Box Set 37429158425 80 3 16 Dreyer Box Set 37429158425 80 3 8 Dreyer Box Set 37429158425 80 3 12巴西37429138526 60 3 18爱森斯坦：声音年份37429149126 80 4 24 Dreyer Box Set 37429158425 80 3 14 Dreyer Box Set 37429158425 80 4 10巴西37429138526 60 3 17爱森斯坦：声音年份37429149126 80 3 16 Orphic Trilogy 37429148327 80 4 13 Orphic Trilogy 37429148327 80 4 10 Brazil 37429138526 60 4 12 Eisenstein：The Sound Years 37429149126 80 3 12 Dreyer Box Set 37429158425 80 4 13 Dreyer Box Set 37429158425 80 4 17行选择。</code></pre></div>
                     <!-- class="example" -->
                  </div>
                  <div>
                     <div class="familylinks">
                        <div class="parentlink">
                           <p><strong>父主题：</strong> <a href="query-and-update-XML.html#GUID-4DF303DB-780C-4491-9252-234482A563A4" title="XQuery是一种非常通用和富有表现力的语言，SQL / XML函数XMLQuery，XMLTable，XMLExists和XMLCast将表达和计算的强大功能与SQL的优势结合在一起。">将XQuery与Oracle XML DB一起使用</a></p>
                        </div>
                     </div>
                  </div>
                  
               </div><a id="ADXDB5140"></a><a id="ADXDB5141"></a><a id="ADXDB5139"></a><div class="props_rev_3"><a id="GUID-1E1D2966-8995-4BBD-B039-2E6CEB7B275A" name="GUID-1E1D2966-8995-4BBD-B039-2E6CEB7B275A"></a><h4 id="ADXDB-GUID-1E1D2966-8995-4BBD-B039-2E6CEB7B275A" class="sect4"><span class="enumeration_section">5.1.5</span>在XQuery中使用命名空间</h4>
                  <div>
                     <p>您可以在XQuery表达式的prolog中使用XQuery <code class="codeph">declare namespace</code>声明来定义名称空间前缀。您可以使用<code class="codeph">declare</code> <span class="bold"><code class="codeph">default</code></span> <code class="codeph">namespace</code>将名称<code class="codeph">namespace</code>建立为表达式的默认名称空间。
                     </p>
                     <div class="section">
                        <div class="infoboxnote" id="GUID-1E1D2966-8995-4BBD-B039-2E6CEB7B275A__GUID-776A969C-F7C4-4DC5-9DAA-B39E2E3218A1">
                           <p class="notep1">注意：</p>
                           <p>如果使用SQL * Plus，请注意以下缺陷：如果命名空间声明末尾的分号（ <code class="codeph">;</code> ）终止一行，则SQL * Plus会将其解释为SQL终止符。为避免这种情况，您可以执行以下操作之一：</p>
                           <ul style="list-style-type:disc">
                              <li>
                                 <p>将分号后面的文本放在同一行上。</p>
                              </li>
                              <li>
                                 <p>在分号后面的同一行放置注释，例如<span class="bold"><code class="codeph">(: :)</code></span> 。
                                 </p>
                              </li>
                              <li>
                                 <p>使用SQL * Plus命令<code class="codeph">SET SQLTERMINATOR</code>关闭对SQL终止符的识别。</p>
                              </li>
                           </ul>
                        </div>
                        <p><a href="query-and-update-XML.html#GUID-1E1D2966-8995-4BBD-B039-2E6CEB7B275A__BABIDFEC">例5-15</a>说明了在XQuery表达式中使用名称空间声明。
                        </p>
                        <p>XQuery名称空间声明在其XQuery表达式之外没有任何影响。要声明在XQuery表达式之外的<code class="codeph">XMLTable</code>表达式中使用的名称空间前缀，请使用<code class="codeph">XMLNAMESPACES</code>子句。该子句还涵盖了<code class="codeph">XMLTable</code>的XQuery表达式参数，无需在XQuery prolog中单独声明。
                        </p>
                        <p>在<a href="query-and-update-XML.html#GUID-1E1D2966-8995-4BBD-B039-2E6CEB7B275A__CBABFGAJ">示例5-16中</a> ， <code class="codeph">XMLNAMESPACES</code>用于定义名称空间<code class="codeph">http://example.com</code>的前缀<code class="codeph">e</code> 。此命名空间用于<code class="codeph">COLUMNS</code>子句和<code class="codeph">XMLTable</code>表达式的XQuery表达式。
                        </p>
                     </div>
                     <!-- class="section" -->
                     <div class="example" id="GUID-1E1D2966-8995-4BBD-B039-2E6CEB7B275A__BABIDFEC">
                        <p class="titleinexample">示例5-15将XMLQUERY与命名空间声明一起使用</p><pre class="pre codeblock"><code>SELECT XMLQuery（'declare namespace e =“http://example.com” <span class="bold">;</span>错误：ORA-01756：在doc（“/ public / empsns.xml”）/ e：emps / e中$ i的引用字符串没有正确终止：emp SP2-0734：未知命令开头“for $ i in ...” - 其余行被忽略。...

<span class="bold">- 这样做 - 不要用“;”结束这一行。</span>SELECT XMLQuery（'declare namespace e =“http://example.com” <span class="bold">;对于</span> doc中的$ i（“/ public / empsns.xml”）/ e：emps / e：emp let $ d：= doc（“/ public / depts.xml“）// dept [@ deptno = $ i / @ deptno] / @ dname其中$ i / @ salary&gt; 100000 order by $ i / @ empno return &lt;emp ename =”{$ i / @ ename来自DUAL的“dept =”{$ d}“/&gt;'返回内容）; XMLQUERY（'DECLARENAMESPACEE =“HTTP://EXAMPLE.COM”; FOR $ IINDOC（“/ PUBLIC / EMPSNS.XML”----------------------- -------------------------------------------------- ------- &lt;emp ename =“Jack”dept =“”&gt; &lt;/ emp&gt; &lt;emp ename =“Jill”dept =“”&gt; &lt;/ emp&gt; <span class="bold">- 这也有效 - 在之后添加评论“;”。</span>SELECT XMLQuery（'declare namespace e =“http://example.com”; <span class="bold">（：:)</span> for $ i in doc（“/ public / empsns.xml”）/ e：emps / e：emp let $ d：= doc（“/ public / depts.xml”）// dept [@ deptno = $ i / @ deptno] / @ dname其中$ i / @ salary&gt; 100000 order by $ i / @ empno return &lt;emp ename =“{$ i / @ ename}“dept =”{$ d}“/&gt;'返回内容）来自DUAL; XMLQUERY（'DECLARENAMESPACEE =“HTTP://EXAMPLE.COM”;（：:) FOR $ IINDOC（“/ PUBLIC / EMPSNS。--------------------- -------------------------------------------------- --------- &lt;emp ename =“Jack”dept =“”&gt; &lt;/ emp&gt; &lt;emp ename =“Jill”dept =“”&gt; &lt;/ emp&gt;选择1行。

<span class="bold">- 这也有效 - 告诉SQL * Plus忽略“;”。</span>

<span class="bold">SET SQLTERMINATOR OFF</span> SELECT XMLQuery（'declare namespace e =“http://example.com” <span class="bold">;</span> for doc中的$ i（“/ public / empsns.xml”）/ e：emps / e：emp let $ d：= doc （“/public/depts.xml")//dept[@deptno=$i/@deptno]/@dname其中$ i / @ salary&gt; 100000 order by $ i / @ empno return &lt;emp ename =”{$ i / @ ename}“dept =”{$ d}“/&gt;'返回内容）来自DUAL <span class="bold">/</span> XMLQUERY（'DECLARENAMESPACEE =”HTTP://EXAMPLE.COM“; FOR $ IINDOC（”/ PUBLIC / EMPSNS.XML“ - -------------------------------------------------- ----------------------------- &lt;emp ename =“Jack”dept =“”&gt; &lt;/ emp&gt; &lt;emp ename =“吉尔“dept =”“&gt; &lt;/ emp&gt;</code></pre></div>
                     <!-- class="example" -->
                     <div class="example" id="GUID-1E1D2966-8995-4BBD-B039-2E6CEB7B275A__CBABFGAJ">
                        <p class="titleinexample">示例5-16将XMLTABLE与XMLNAMESPACES子句一起使用</p><pre class="pre codeblock"><code>SELECT * FROM XMLTable（ <span class="bold">XMLNAMESPACES（'http://example.com'AS“e”），</span> 'for $ i in doc（“/ public / empsns.xml”）return $ i / <span class="bold">e：</span> emps / <span class="bold">e：</span> emp' COLUMNS名称VARCHAR2（6）PATH'@ ename'，id NUMBER PATH'@ empno'）;</code></pre><p>这会产生以下结果：</p><pre class="oac_no_warn" dir="ltr">姓名ID ------ ---------- John 1 Jack 2 Jill 3 3行被选中。
</pre><p>在<code class="codeph">COLUMNS</code>子句中存在限定名<code class="codeph">e:ename</code>和<code class="codeph">e:empno</code> ，这需要使用<code class="codeph">XMLNAMESPACES</code>子句。否则，prolog名称空间声明（ <code class="codeph">declare namespace e = "http://example.com"</code> ）就足以满足XQuery表达式本身的要求。
                        </p>
                        <p>因为在整个<code class="codeph">XMLTable</code>表达式中使用了相同的命名空间，所以可以使用默认命名空间： <code class="codeph">XMLNAMESPACES (DEFAULT 'http://example.com')</code> ： <code class="codeph">XMLNAMESPACES (DEFAULT 'http://example.com')</code> 。然后可以在没有明确前缀的情况下编写限定名称<code class="codeph">$i/e:emps/e:emp</code> ： <code class="codeph">$i/emps/emp</code> 。
                        </p>
                     </div>
                     <!-- class="example" -->
                  </div>
                  <div>
                     <div class="familylinks">
                        <div class="parentlink">
                           <p><strong>父主题：</strong> <a href="query-and-update-XML.html#GUID-4DF303DB-780C-4491-9252-234482A563A4" title="XQuery是一种非常通用和富有表现力的语言，SQL / XML函数XMLQuery，XMLTable，XMLExists和XMLCast将表达和计算的强大功能与SQL的优势结合在一起。">将XQuery与Oracle XML DB一起使用</a></p>
                        </div>
                     </div>
                  </div>
                  
               </div>
            </div><a id="ADXDB4260"></a><a id="ADXDB4261"></a><a id="ADXDB4262"></a><a id="ADXDB4263"></a><a id="ADXDB4265"></a><a id="ADXDB4266"></a><a id="ADXDB4230"></a><div class="props_rev_3"><a id="GUID-0FDD8ABE-F94B-42CB-B135-93BC67225737" name="GUID-0FDD8ABE-F94B-42CB-B135-93BC67225737"></a><h3 id="ADXDB-GUID-0FDD8ABE-F94B-42CB-B135-93BC67225737" class="sect3"><span class="enumeration_section">5.2</span>使用SQL和PL / SQL查询XML数据</h3>
               <div>
                  <p>您可以通过各种方式从<code class="codeph">XMLType</code>列和表中查询XML数据。
                  </p>
                  <div class="section">
                     <ul style="list-style-type:disc">
                        <li>
                           <p>使用SQL，PL / SQL或Java选择<code class="codeph">XMLType</code>数据。
                           </p>
                        </li>
                        <li>
                           <p>使用XML / XML函数（如<code class="codeph">XMLQuery</code>查询<code class="codeph">XMLType</code>数据。请参阅<a href="query-and-update-XML.html#GUID-1165391D-BA6A-460F-BA44-66AA4A1F6595" title="提供了使用XQuery查询XMLType数据的示例。">使用XQuery查询XMLType数据</a> 。
                           </p>
                        </li>
                        <li>
                           <p>使用XQuery Full Text执行全文搜索。请参阅<a href="xquery-and-XML-DB.html#GUID-B87B6721-11A8-4E6F-A693-97DC4AAE2048" title="Oracle XML DB supports XQuery Full Text for XMLType data that is stored as binary XML. Oracle Text technology provides the full-text indexing and search that is the basis of this support.">支持</a> <a href="indexes-for-XMLType-data.html#GUID-FE16BE28-035C-49EE-9683-6ED37876C3FC" title="You can create indexes on your XML data, to focus on particular parts of it that you query often and thus improve performance. There are various ways that you can index XMLType data, whether it is XML schema-based or non-schema-based, and regardless of the XMLType storage model you use.">XMLType数据的</a> <a href="xquery-and-XML-DB.html#GUID-B87B6721-11A8-4E6F-A693-97DC4AAE2048" title="Oracle XML DB支持存储为二进制XML的XMLType数据的XQuery Full Text。 Oracle Text技术提供全文索引和搜索，这是此支持的基础。">XQuery全文</a>和<a href="indexes-for-XMLType-data.html#GUID-FE16BE28-035C-49EE-9683-6ED37876C3FC" title="您可以在XML数据上创建索引，专注于经常查询的特定部分，从而提高性能。您可以通过多种方式索引XMLType数据，无论是基于XML模式还是非基于模式，无论您使用何种XMLType存储模型。">索引</a> 。
                           </p>
                        </li>
                     </ul>
                     <p>本节中的示例说明了使用SQL和PL / SQL查询XML数据的不同方法。<a href="query-and-update-XML.html#GUID-0FDD8ABE-F94B-42CB-B135-93BC67225737__I1024901">例5-17</a>在表<code class="codeph">purchaseorder</code>插入两行，然后使用SQL / XML函数<code class="codeph">XMLCast</code> ， <code class="codeph">XMLQuery</code>和<code class="codeph">XMLExists</code>查询这些行中的数据。
                     </p>
                     <p><a href="query-and-update-XML.html#GUID-0FDD8ABE-F94B-42CB-B135-93BC67225737__CHDBHJFD">例5-18</a>使用PL / SQL游标来查询XML数据。它使用本地<code class="codeph">XMLType</code>实例来存储瞬态数据。
                     </p>
                     <p><a href="query-and-update-XML.html#GUID-0FDD8ABE-F94B-42CB-B135-93BC67225737__CHDEDHCC">例5-19</a>和<a href="query-and-update-XML.html#GUID-0FDD8ABE-F94B-42CB-B135-93BC67225737__CHDDJAAD">例5-20</a>都使用SQL / XML函数<code class="codeph">XMLTable</code>从XML采购订单文档中提取数据。然后，他们将该数据插入关系表。<a href="query-and-update-XML.html#GUID-0FDD8ABE-F94B-42CB-B135-93BC67225737__CHDEDHCC">例5-19</a>使用SQL; <a href="query-and-update-XML.html#GUID-0FDD8ABE-F94B-42CB-B135-93BC67225737__CHDDJAAD">例5-20</a>使用PL / SQL。</p>
                     <p><a href="query-and-update-XML.html#GUID-0FDD8ABE-F94B-42CB-B135-93BC67225737__CHDDJAAD">示例5-20</a>定义并使用PL / SQL过程从XML采购订单文档中提取数据并将其插入关系表。
                     </p>
                     <p><a href="query-and-update-XML.html#GUID-0FDD8ABE-F94B-42CB-B135-93BC67225737__CHDEFAIG">示例5-21</a>列出了其发货地址包含字符串“ <code class="codeph">Shores</code> ”的采购订单，以及名称中包含字符串“ <code class="codeph">ll</code> ”（双L）的客户请求的采购订单。这些采购订单按客户分组并计算。该示例使用XQuery Full Text执行全文搜索。
                     </p>
                     <p><a href="query-and-update-XML.html#GUID-0FDD8ABE-F94B-42CB-B135-93BC67225737__I1025061">例5-22</a>提取由XPath表达式标识的文档片段。<code class="codeph">XMLQuery</code>返回的<code class="codeph">XMLType</code>实例可以是一组节点，一个单一节点或一个文本值。<a href="query-and-update-XML.html#GUID-0FDD8ABE-F94B-42CB-B135-93BC67225737__I1025061">例5-22</a>使用<code class="codeph">XMLType</code>方法<code class="codeph">isFragment()</code>来确定结果是否是片段。
                     </p>
                     <div class="infoboxnote" id="GUID-0FDD8ABE-F94B-42CB-B135-93BC67225737__GUID-F430338E-0753-41CD-8C45-42213EE7E814">
                        <p class="notep1">注意：</p>
                        <p>您无法将片段插入<code class="codeph">XMLType</code>列。您可以使用SQL / XML函数<code class="codeph">XMLQuery</code>将片段转换为格式良好的文档。
                        </p>
                     </div>
                  </div>
                  <!-- class="section" -->
                  <div class="example" id="GUID-0FDD8ABE-F94B-42CB-B135-93BC67225737__I1024901">
                     <p class="titleinexample">示例5-17查询XMLTYPE数据</p><pre class="pre codeblock"><code>INSERT INTO purchaseorder VALUES（XMLType（bfilename（'XMLDIR'，'SMCCAIN-2002091213000000PDT.xml'），nls_charset_id（'AL32UTF8'）））; INSERT INTO purchaseorder VALUES（XMLType（bfilename（'XMLDIR'，'VJONES-20020916140000000PDT.xml'），nls_charset_id（'AL32UTF8'）））; SELECT XMLCast（XMLQuery（'$ p / PurchaseOrder / Reference'PASSING po。OBJECT_VALUE为“p”返回内容）AS VARCHAR2（30））引用，XMLCast（XMLQuery（'$ p / PurchaseOrder / * // User'PASSING po。OBJECT_VALUE作为“p”返回内容）AS VARCHAR2（30））userid，例如XMLExists（'$ p / PurchaseOrder / Reject / Date'PASSING po。OBJECT_VALUE为“p”）然后'拒绝'ELSE'接受'结束'状态“，XMLCast（XMLQuery（'$ p // Date'PASSING po。OBJECT_VALUE作为“p”返回内容）AS VARCHAR2（12））status_date FROM purchaseorder po WHERE XMLExists（'$ p // Date'PASSING po。OBJECT_VALUE AS“p”）XMLCast的订购（XMLQuery（'$ p // Date'PASSING po。OBJECT_VALUE为“p”返回内容）AS VARCHAR2（12））;</code></pre><pre class="pre codeblock"><code>参考用户ID状态STATUS_DATE -------------------------------- -------- ------ -  ------------ VJONES-20020916140000000PDT SVOLLMAN接受2002-10-11 SMCCAIN-2002091213000000PDT SKING拒绝2002-10-12 2行被选中。
</code></pre></div>
                  <!-- class="example" -->
                  <div class="example" id="GUID-0FDD8ABE-F94B-42CB-B135-93BC67225737__CHDBHJFD">
                     <p class="titleinexample">示例5-18使用PL / SQL游标查询瞬态XMLTYPE数据</p><pre class="pre codeblock"><code>DECLARE xNode XMLType; vText VARCHAR2（256）; vReference VARCHAR2（32）; CURSOR getPurchaseOrder（引用IN VARCHAR2）是SELECT OBJECT_VALUE XML FROM purchaseorder WHERE XMLExists（'$ p / PurchaseOrder [Reference = $ r]'PASSING OBJECT_VALUE AS“p”，引用AS“r”）; BEGIN vReference：='EABEL-20021009123335791PDT'; FOR c IN getPurchaseOrder（vReference）LOOP xNode：= c。XML.extract（ '//请求程序'）; SELECT XMLSerialize（CONTENT XMLQuery（'// text（）'PASSING xNode RETURNING CONTENT））INTO vText FROM DUAL; DBMS_OUTPUT.put_line（'参考请求者'|| vReference ||'是'|| vText）;结束循环; v参考：='PTUCKER-20021009123335430PDT'; FOR c IN getPurchaseOrder（vReference）LOOP xNode：= c。XML.extract（ '//的LineItem [@ ItemNumber = “1”] /说明'）; SELECT XMLSerialize（CONTENT XMLQuery（'// text（）'PASSING xNode RETURNING CONTENT））INTO vText FROM DUAL; DBMS_OUTPUT.put_line（'参考'|| vReference ||'的LineItem [1]的描述是'|| vText）;结束循环;结束; /参考申请人EABEL-20021009123335791PDT是Ellen S. Abel参考文献PTUCKER-20021009123335430PDT的LineItem [1]的描述是在Hanging Rock PL / SQL程序成功完成的Picnic。
</code></pre></div>
                  <!-- class="example" -->
                  <div class="example" id="GUID-0FDD8ABE-F94B-42CB-B135-93BC67225737__CHDEDHCC">
                     <p class="titleinexample">示例5-19使用SQL提取XML数据并将其插入关系表</p><pre class="pre codeblock"><code>CREATE TABLE purchaseorder_table（引用VARCHAR2（28）PRIMARY KEY，请求者VARCHAR2（48），操作XMLType，userid VARCHAR2（32），costcenter VARCHAR2（3），shiptoname VARCHAR2（48），地址VARCHAR2（512），phone VARCHAR2（32） ，由VARCHAR2（32）拒绝，daterejected DATE，comments VARCHAR2（2048），specialinstructions VARCHAR2（2048））; CREATE TABLE purchaseorder_lineitem（引用，FOREIGN KEY（“REFERENCE”）REFERENCES“PURCHASEORDER_TABLE”（“REFERENCE”）DELETE CASCADE，lineno NUMBER（10），PRIMARY KEY（“REFERENCE”，“LINENO”），upc VARCHAR2（14）， description VARCHAR2（128），数量NUMBER（10），单位价格NUMBER（12,2））;</code></pre><pre class="pre codeblock"><code>INSERT INTO purchaseorder_table（引用，请求者，操作，用户ID，costcenter，shiptoname，地址，电话，被拒绝，daterejected，评论，specialinstructions）SELECT t.reference，t.requestor，t.actions，t.userid，t.costcenter，t .shiptoname，t.address，t.phone，t.rejectedby，t.daterejected，t.comments，t.specialinstructions FROM purchaseorder p，XMLTable（'/ PurchaseOrder'PASSING p。OBJECT_VALUE COLUMNS引用VARCHAR2（28）路径'引用'，请求者VARCHAR2（48）路径'请求者'，动作XMLType路径'动作'，用户ID VARCHAR2（32）路径'用户'，costcenter VARCHAR2（3）路径'CostCenter'，shiptoname VARCHAR2（48）路径'ShippingInstructions / name'，地址VARCHAR2（512）路径'ShippingInstructions / address'，电话VARCHAR2（32）路径'ShippingInstructions / telephone'，被VARCHAR2拒绝（32）PATH'拒绝/用户'，日期拒绝DATE PATH '拒绝/日期'，注释VARCHAR2（2048）路径'拒绝/评论'，specialinstructions VARCHAR2（2048）路径'SpecialInstructions'）t WHERE t.reference ='EABEL-20021009123336251PDT'; INSERT INTO purchaseorder_lineitem（reference，lineno，upc，description，quantity，unitprice）SELECT t.reference，li.lineno，li.upc，li.description，li.quantity，li.unitprice FROM purchaseorder p，XMLTable（'/ PurchaseOrder'通过p。OBJECT_VALUE COLUMNS引用VARCHAR2（28）PATH'引用'，lineitem XMLType PATH'RineItems / LineItem'）t，XMLTable（'LineItem'PASSING t.lineitem COLUMNS lineno NUMBER（10）PATH' @ ItemNumber'，upc VARCHAR2（14）PATH 'Part / @ Id'，description VARCHAR2（128）PATH'描述'，数量NUMBER（10）PATH'Part / @ Quantity'，unitprice NUMBER（12,2）PATH'Part / @ UnitPrice'）li WHERE t.reference ='EABEL-20021009123336251PDT';</code></pre><pre class="pre codeblock"><code>SELECT reference，userid，shiptoname，specialinstructions FROM purchaseorder_table; REFERENCE USERID SHIPTONAME SPECIALINSTRUCTIONS -------------------------------- -------- ------ ------------------------------------------ -------- ----------- EABEL-20021009123336251PDT EABEL Ellen S. Abel Counter to Counter SELECT reference，lineno，upc，description，quantity FROM purchaseorder_lineitem;参考LINENO UPC描述QUANTITY -------------------------------- ---------- --- ----------- ---------------------------------- ----- ----- EABEL-20021009123336251PDT 1 37429125526武士2：一石寺决斗3 EABEL-20021009123336251PDT 2 37429128220红鞋4 EABEL-20021009123336251PDT 3 715515009058一夜难忘1</code></pre></div>
                  <!-- class="example" -->
                  <div class="example" id="GUID-0FDD8ABE-F94B-42CB-B135-93BC67225737__CHDDJAAD">
                     <p class="titleinexample">示例5-20使用PL / SQL提取XML数据并将其插入表中</p><pre class="pre codeblock"><code>CREATE OR REPLACE PROCEDURE insertPurchaseOrder（purchaseorder XMLType）AS reference VARCHAR2（28）; BEGIN INSERT INTO purchaseorder_table（引用，请求者，操作，用户ID，costcenter，shiptoname，地址，电话，被拒绝，daterejected，评论，specialinstructions）SELECT * FROM XMLTable（'$ p / PurchaseOrder'PASSING purchaseorder AS“p”COLUMNS reference VARCHAR2（ 28）路径'引用'，请求者VARCHAR2（48）路径'请求者'，动作XMLType路径'动作'，用户ID VARCHAR2（32）路径'用户'，costcenter VARCHAR2（3）路径'CostCenter'，shiptoname VARCHAR2（48）路径'ShippingInstructions / name'，地址VARCHAR2（512）路径'ShippingInstructions / address'，电话VARCHAR2（32）路径'ShippingInstructions /电话'，被VARCHAR2拒绝（32）路径'拒绝/用户'，日期拒绝DATE PATH'拒绝/日期' ，comments VARCHAR2（2048）PATH'Reject / Comments'，specialinstructions VARCHAR2（2048）PATH'SpecialInstructions'）; INSERT INTO purchaseorder_lineitem（reference，lineno，upc，description，quantity，unitprice）SELECT t.reference，li.lineno，li.upc，li.description，li.quantity，li.unitprice FROM XMLTable（'$ p / PurchaseOrder'PASSING purchaseorder AS“p”COLUMNS引用VARCHAR2（28）PATH'Reference'，lineitem XMLType PATH'LineItems / LineItem'）t，XMLTable（'LineItem'PASSING t.lineitem COLUMNS lineno NUMBER（10）PATH' @ ItemNumber'，upc VARCHAR2 （14）路径'部分/ @ Id'，描述VARCHAR2（128）路径'描述'，数量NUMBER（10）路径'部分/ @数量'，单位价格NUMBER（12,2）路径'部分/ @ UnitPrice'）li ;结束;</code></pre><pre class="oac_no_warn" dir="ltr">CALL insertPurchaseOrder（XMLType（bfilename（'XMLDIR'，'purchaseOrder.xml'），nls_charset_id（'AL32UTF8'）））;</pre><pre class="oac_no_warn" dir="ltr">SELECT reference，userid，shiptoname，specialinstructions FROM purchaseorder_table; REFERENCE USERID SHIPTONAME SPECIALINSTRUCTIONS -------------------------------- -------- ------ ------------------------------------------ -------- ----------- SBELL-2002100912333601PDT SBELL Sarah J. Bell Air Mail SELECT参考，lineno，upc，描述，数量来自purchaseorder_lineitem;参考LINENO UPC描述数量------------------------- ------ ------------  - -------------------------------- -------- SBELL-2002100912333601PDT 1 715515009058一个难忘的夜晚2 SBELL-2002100912333601PDT 2 37429140222难以忍受的轻盈2 SBELL-2002100912333601PDT 3 715515011020姐妹4</pre></div>
                  <!-- class="example" -->
                  <div class="example" id="GUID-0FDD8ABE-F94B-42CB-B135-93BC67225737__CHDEFAIG">
                     <p class="titleinexample">示例5-21使用SQL / XML函数搜索XML数据</p><pre class="pre codeblock"><code>SELECT <span class="bold">XMLCast</span> （ <span class="bold">XMLQuery</span> （'$ p / PurchaseOrder / <span class="bold">Requestor'PASSING</span> po。OBJECT_VALUE为“p”返回内容）AS VARCHAR2（128））name，count（*）FROM purchaseorder po WHERE <span class="bold">XMLExists</span> （'declare namespace ora =“http://xmlns.oracle.com/xdb”;（：:) $ p / PurchaseOrder / ShippingInstructions [address / text（）包含文本“ <span class="bold">Shores</span> ”]'PASSING po。OBJECT_VALUE AS“p”）和<span class="bold">XMLCast</span> （ <span class="bold">XMLQuery</span> （'$ p / PurchaseOrder / <span class="bold">Requestor</span> / text（）'PASSING po。OBJECT_VALUE作为“p”返回内容）AS VARCHAR2（128）） <span class="bold">LIKE'％ll％'</span> GROUP BY <span class="bold">XMLCast</span> （ <span class="bold">XMLQuery</span> （'$ p / PurchaseOrder / <span class="bold">Requestor'PASSING</span> po。OBJECT_VALUE为“p”返回内容）AS VARCHAR2（128））; NAME COUNT（*）-------------------- ---------- Allan D. McEwen 9 Ellen S. Abel 4 Sarah J. Bell 13威廉姆史密斯7</code></pre></div>
                  <!-- class="example" -->
                  <div class="example" id="GUID-0FDD8ABE-F94B-42CB-B135-93BC67225737__I1025061">
                     <p class="titleinexample">示例5-22使用XMLQUERY提取片段</p><pre class="pre codeblock"><code>SELECT XMLCast（XMLQuery（'$ p / PurchaseOrder / Reference'PASSING po。OBJECT_VALUE作为“p”返回内容）作为VARCHAR2（30））引用，count（*）FROM purchaseorder po，XMLTable（'$ p // LineItem [Part / @ Id =“37429148327”]'PASSING OBJECT_VALUE AS“p”）在哪里<span class="bold">XMLQuery</span> （'$ p / PurchaseOrder / LineItems / LineItem [Part / @ Id =“37429148327”]'PASSING po。OBJECT_VALUE为“p”返回内容）。 <span class="bold">isFragment</span> （）= 1 GROUP BY XMLCast（XMLQuery（'$ p / PurchaseOrder / Reference'PASSING po。OBJECT_VALUE作为“p”返回内容）作为VARCHAR2（30））按XMLCast排序（XMLQuery（'$ p / PurchaseOrder / Reference'PASSING po。OBJECT_VALUE为“p”返回内容）AS VARCHAR2（30））; REFERENCE COUNT（*）-------------------------------- ---------- TFOX-20021009123337784PDT 3</code></pre></div>
                  <!-- class="example" -->
               </div>
               <div>
                  <div class="familylinks">
                     <div class="parentlink">
                        <p><strong>父主题：</strong> <a href="query-and-update-XML.html#GUID-01C75289-804F-4BAA-AE7C-DFA73198581E" title="应用程序有许多方法可以查询和更新Oracle数据库中的XML数据，包括基于XML模式和非基于模式的数据。">XML数据的查询和更新</a></p>
                     </div>
                  </div>
               </div>
               
            </div><a id="ADXDB5154"></a><a id="ADXDB5153"></a><div class="props_rev_3"><a id="GUID-4C3665D9-5502-4D05-A1AE-9E8B4D7E64C1" name="GUID-4C3665D9-5502-4D05-A1AE-9E8B4D7E64C1"></a><h3 id="ADXDB-GUID-4C3665D9-5502-4D05-A1AE-9E8B4D7E64C1" class="sect3"><span class="enumeration_section">5.3</span>使用SQL * Plus XQUERY命令</h3>
               <div>
                  <p>您可以使用SQL * Plus <code class="codeph">XQUERY</code>命令评估XQuery表达式。
                  </p>
                  <div class="section">
                     <p><a href="query-and-update-XML.html#GUID-4C3665D9-5502-4D05-A1AE-9E8B4D7E64C1__CBACBEFC">例5-23</a>显示了如何直接在SQL * Plus命令行中输入XQuery表达式，方法是在表达式前加上SQL * Plus命令<span class="bold"><code class="codeph">XQUERY</code></span>然后在行上<span class="bold"><code class="codeph">XQUERY</code></span>使用斜杠（ <code class="codeph">/</code> ）。Oracle数据库处理使用此命令提交的XQuery表达式，与处理SQL / XML函数<code class="codeph">XMLQuery</code>和<code class="codeph">XMLTable</code> XQuery表达式的方式相同。执行是相同的，具有相同的优化。
                     </p>
                     <p>还有一些SQL * Plus <code class="codeph">SET</code>命令可用于特定于XQuery的设置。使用<code class="codeph">SHOW XQUERY</code>查看当前设置。
                     </p>
                  </div>
                  <!-- class="section" -->
                  <div class="section">
                     <ul style="list-style-type:disc">
                        <li>
                           <p><span class="bold"><code class="codeph">SET XQUERY BASEURI</code></span> -设置基本URI <code class="codeph">XQUERY</code> 。 XQuery表达式中的URI与此URI相关。</p>
                        </li>
                        <li>
                           <p><span class="bold"><code class="codeph">SET XQUERY CONTEXT</code></span> - 为后续<code class="codeph">XQUERY</code>评估指定上下文项。
                           </p>
                        </li>
                     </ul>
                     <div class="infoboxnotealso" id="GUID-4C3665D9-5502-4D05-A1AE-9E8B4D7E64C1__GUID-886F1BBC-1BA1-490C-836B-581BC383A1A8">
                        <p class="notep1">也可以看看：</p>
                        <p><a href="../sqpug/WHENEVER-SQLERROR.html#SQPUG135" target="_blank"><span><cite>SQL * Plus用户指南和参考</cite></span></a></p>
                     </div>
                  </div>
                  <!-- class="section" -->
                  <div class="example" id="GUID-4C3665D9-5502-4D05-A1AE-9E8B4D7E64C1__CBACBEFC">
                     <p class="titleinexample">示例5-23使用SQL * Plus XQUERY命令</p><pre class="oac_no_warn" dir="ltr">SQL&gt; XQUERY for $ i in fn：collection（“oradb：/ HR / DEPARTMENTS”）2其中$ i / ROW / DEPARTMENT_ID &lt;50 3返回$ i 4 /结果序列------------ -------------------------------------------------- ------------------ &lt;ROW&gt; &lt;DEPARTMENT_ID&gt; 10 &lt;/ DEPARTMENT_ID&gt; &lt;DEPARTMENT_NAME&gt;管理&lt;/ DEPARTMEN T_NAME&gt; &lt;MANAGER_ID&gt; 200 &lt;/ MANAGER_ID&gt; &lt;LOCATION_ID&gt; 1700 &lt;/ LOCATION_ID&gt; &lt;/ ROW&gt; &lt;ROW&gt; &lt;DEPARTMENT_ID&gt; 20 &lt;/ DEPARTMENT_ID&gt; &lt;DEPARTMENT_NAME&gt;营销&lt;/ DEPARTMENT_NAM E&gt; &lt;MANAGER_ID&gt; 201 &lt;/ MANAGER_ID&gt; &lt;LOCATION_ID&gt; 1800 &lt;/ LOCATION_ID&gt; &lt;/ ROW&gt; &lt;ROW &gt; &lt;DEPARTMENT_ID&gt; 30 &lt;/ DEPARTMENT_ID&gt; &lt;DEPARTMENT_NAME&gt;采购&lt;/ DEPARTMENT_NA ME&gt; &lt;MANAGER_ID&gt; 114 &lt;/ MANAGER_ID&gt; &lt;LOCATION_ID&gt; 1700 &lt;/ LOCATION_ID&gt; &lt;/ ROW&gt; &lt;ROW&gt; &lt;DEPARTMENT_ID&gt; 40 &lt;/ DEPARTMENT_ID&gt; &lt; DEPARTMENT_NAME&gt;人力资源&lt;/ DEPARTME NT_NAME&gt; &lt;MANAGER_ID&gt; 203 &lt;/ MANAGER_ID&gt; &lt;LOCATION_ID&gt; 2400 &lt;/ LOCATION_ID&gt; &lt;/ ROW&gt;</pre></div>
                  <!-- class="example" -->
               </div>
               <div>
                  <div class="familylinks">
                     <div class="parentlink">
                        <p><strong>父主题：</strong> <a href="query-and-update-XML.html#GUID-01C75289-804F-4BAA-AE7C-DFA73198581E" title="应用程序有许多方法可以查询和更新Oracle数据库中的XML数据，包括基于XML模式和非基于模式的数据。">XML数据的查询和更新</a></p>
                     </div>
                  </div>
               </div>
               
            </div><a id="ADXDB6016"></a><div class="props_rev_3"><a id="GUID-8F3B9C09-6877-4E43-A6E7-873BF0E74DAB" name="GUID-8F3B9C09-6877-4E43-A6E7-873BF0E74DAB"></a><h3 id="ADXDB-GUID-8F3B9C09-6877-4E43-A6E7-873BF0E74DAB" class="sect3"><span class="enumeration_section">5.4</span>使用XQuery与XQJ访问数据库数据</h3>
               <div>
                  <p>XQuery API for Java（XQJ），也称为JSR-225，为Java程序使用XQuery访问XML数据提供了行业标准方法。它允许您根据XML数据源评估XQuery表达式，并将结果作为XML数据处理。</p>
                  <div class="section">
                     <p>Oracle提供了两个用于评估XQuery表达式的XQuery引擎：一个用于Oracle XML DB，用于数据库中的XML数据，另一个用于Oracle XML Developer's Kit，用于数据库外部的XML数据。</p>
                     <p>同样，Oracle提供了两个用于访问这两个XQuery引擎的中间层XQJ实现。这两个实现都是Oracle XML Developer's Kit（XDK）的一部分。无论数据是驻留在数据库中还是其他位置，您都可以使用XDK通过XQJ访问XML数据。</p>
                     <p>特别是，您可以使用XDK和XQJ访问Oracle XML DB中的XML数据。此功能的典型用例是从本地Java程序访问存储在远程数据库中的数据。</p>
                  </div>
                  <!-- class="section" -->
               </div>
               <div>
                  <div class="infoboxnotealso" id="GUID-8F3B9C09-6877-4E43-A6E7-873BF0E74DAB__GUID-31B86D68-5B0B-4C83-91B1-D6F21E373783">
                     <p class="notep1">也可以看看：</p>
                     <ul style="list-style-type:disc">
                        <li>
                           <p><a href="https://www.oracle.com/pls/topic/lookup?ctx=en/database/oracle/oracle-database/19/adxdb&amp;id=jcp_org_jsr225" target="_blank">XQuery API for Java（XQJ）1.0规范，2009年3月</a></p>
                           <p>这个规范是非常具体和有用的，可以理解的例子。</p>
                        </li>
                        <li>
                           <p><a href="../adxdk/using-xquery-processor-for-Java.html#ADXDK99930" target="_blank"><span><cite>Oracle XML Developer's Kit程序员指南</cite></span></a> ，提供有关将XQJ与Oracle XML Developer's Kit一起使用的完整信息</p>
                        </li>
                        <li>
                           <p><a href="../adxdk/using-xquery-API-for-Java-to-access-XML-DB.html#ADXDK136" target="_blank"><span><cite>Oracle XML Developer's Kit程序员指南</cite></span></a> ，提供有关使用XQJ和XDK访问数据库中的XML数据的信息，包括示例</p>
                        </li>
                     </ul>
                  </div>
                  <div class="familylinks">
                     <div class="parentlink">
                        <p><strong>父主题：</strong> <a href="query-and-update-XML.html#GUID-01C75289-804F-4BAA-AE7C-DFA73198581E" title="应用程序有许多方法可以查询和更新Oracle数据库中的XML数据，包括基于XML模式和非基于模式的数据。">XML数据的查询和更新</a></p>
                     </div>
                  </div>
               </div>
               
            </div><a id="ADXDB5156"></a><a id="ADXDB5157"></a><a id="ADXDB5158"></a><a id="ADXDB5155"></a><div class="props_rev_3"><a id="GUID-813C0A08-111D-4C4F-B76F-E0B41D6729F0" name="GUID-813C0A08-111D-4C4F-B76F-E0B41D6729F0"></a><h3 id="ADXDB-GUID-813C0A08-111D-4C4F-B76F-E0B41D6729F0" class="sect3"><span class="enumeration_section">5.5</span>使用XQuery与PL / SQL，JDBC和ODP.NET访问数据库数据</h3>
               <div>
                  <p>您可以将XQuery与用于PL / SQL，JDBC和Oracle Data Provider for .NET（ODP.NET）的Oracle API一起使用。</p>
                  <div class="section">
                     <p><a href="query-and-update-XML.html#GUID-813C0A08-111D-4C4F-B76F-E0B41D6729F0__BABJFFAC">例5-24</a>显示了如何将XQuery与PL / SQL一起使用，特别是如何使用<code class="codeph">XMLQuery</code> <code class="codeph">PASSING</code>子句将<span class="italic">动态变量</span>绑定到XQuery表达式。绑定变量<code class="codeph">:1</code>和<code class="codeph">:2</code>分别绑定到PL / SQL绑定参数<code class="codeph">nbitems</code>和<code class="codeph">partid</code> 。然后将它们分别作为XQuery变量<code class="codeph">itemno</code>和<code class="codeph">id</code>传递给XQuery。
                     </p>
                     <p><a href="query-and-update-XML.html#GUID-813C0A08-111D-4C4F-B76F-E0B41D6729F0__BABEJFCH">例5-25</a>显示了如何将XQuery与JDBC结合使用，使用SQL / XML函数<code class="codeph">XMLTable</code>的<code class="codeph">PASSING</code>子句按位置绑定变量。
                     </p>
                     <p><a href="query-and-update-XML.html#GUID-813C0A08-111D-4C4F-B76F-E0B41D6729F0__BABBCACI">例5-26</a>显示了如何将XQuery与ODP.NET和C＃语言一起使用。C＃输入参数<code class="codeph">:nbitems</code>和<code class="codeph">:partid</code>分别作为XQuery变量<code class="codeph">itemno</code>和<code class="codeph">id</code>传递给XQuery。
                     </p>
                  </div>
                  <!-- class="section" -->
                  <div class="section"></div>
                  <!-- class="section" -->
                  <div class="example" id="GUID-813C0A08-111D-4C4F-B76F-E0B41D6729F0__BABJFFAC">
                     <p class="titleinexample">示例5-24将XQuery与PL / SQL一起使用</p><pre class="oac_no_warn" dir="ltr">DECLARE sql_stmt VARCHAR2（2000）; - 执行<span class="bold">nbitems的</span>动态SQL语句NUMBER：= 3; - 物品数量<span class="bold">partid</span> VARCHAR2（20）：='715515009058'; - 部件ID结果XMLType; doc DBMS_XMLDOM.DOMDocument; ndoc DBMS_XMLDOM.DOMNode; buf VARCHAR2（20000）; BEGIN sql_stmt：='SELECT XMLQuery（'for fn：collection中的$'（“oradb：/ OE / PURCHASEORDER”）'||'where count（$ i / PurchaseOrder / LineItems / LineItem）= <span class="bold">$ itemno</span> '||'和$ i / PurchaseOrder / LineItems / LineItem / Part / @ Id = <span class="bold">$ id</span> '||'返回$ i / PurchaseOrder / LineItems'''||' <span class="bold">PASSING</span> <span class="bold">：1</span> AS“ <span class="bold">itemno</span> ”， <span class="bold">：2</span> AS“ <span class="bold">id</span> ”'| |'返回内容）来自DUAL'; EXECUTE IMMEDIATE sql_stmt INTO结果使用<span class="bold">nbitems</span> ， <span class="bold">partid</span> ; doc：= DBMS_XMLDOM.newDOMDocument（result）; ndoc：= DBMS_XMLDOM.makeNode（doc）; DBMS_XMLDOM.writeToBuffer（ndoc，buf）; DBMS_OUTPUT.PUT_LINE（BUF）;结束; /</pre><p>这会产生以下输出：</p><pre class="oac_no_warn" dir="ltr">&lt;LineItems&gt; &lt;LineItem ItemNumber =“1”&gt; &lt;Description&gt; Samurai 2：在Ichijoji Temple决斗&lt;/ Description&gt; &lt;Part Id =“37429125526”UnitPrice =“29.95”Quantity =“3”/&gt; &lt;/ LineItem&gt; &lt;LineItem ItemNumber =“2”&gt; &lt;描述&gt;红鞋&lt;/ Description&gt; &lt;Part Id =“37429128220”UnitPrice =“39.95”Quantity =“4”/&gt; &lt;/ LineItem&gt; &lt;LineItem ItemNumber =“3”&gt; &lt;Description&gt;要记住的夜晚&lt;/ Description&gt; &lt;Part Id =“715515009058”UnitPrice =“39.95”Quantity =“1”/&gt; &lt;/ LineItem&gt; &lt;/ LineItems&gt; &lt;LineItems&gt; &lt;LineItem ItemNumber =“1”&gt; &lt;Description&gt; A要记住的夜晚&lt;/ Description&gt; &lt;Part Id =“715515009058”UnitPrice =“39.95”Quantity =“2”/&gt; &lt;/ LineItem&gt; &lt;LineItem ItemNumber =“2”&gt; &lt;Description&gt;难以承受的轻盈&lt;/ Description&gt; &lt;Part Id =“37429140222”UnitPrice =“29.95”Quantity =“2”/&gt; &lt;/ LineItem&gt; &lt;LineItem ItemNumber =“3”&gt; &lt;Description&gt; Sisters &lt;/ Description&gt; &lt;Part Id =“715515011020”UnitPrice =“29.95 “Quantity =”4“/&gt; &lt;/ LineItem&gt; &lt;/ LineItems&gt; PL / SQL过程已成功完成。
</pre></div>
                  <!-- class="example" -->
                  <div class="example" id="GUID-813C0A08-111D-4C4F-B76F-E0B41D6729F0__BABEJFCH">
                     <p class="titleinexample">示例5-25将XQuery与JDBC配合使用</p><pre class="oac_no_warn" dir="ltr">import java.sql。*; import oracle.sql。*; import oracle.jdbc。*; import oracle.xdb。XMLType的; import java.util。*; public class QueryBindByPos {public static void main（String [] args）throws Exception，SQLException {System.out.println（“***使用绑定变量***的XQuery JDBC访问”）; DriverManager.registerDriver（new oracle.jdbc.driver。一个OracleDriver（））; OracleConnection conn =（OracleConnection）DriverManager.getConnection（“jdbc：oracle：oci8：@localhost：1521：ora11gR1”，“oe”，“oe”）; String xqString =“SELECT COLUMN_VALUE”+“FROM XMLTable（'for fn：collection中的$ i（\”oradb：/ OE / PURCHASEORDER \“）”+“其中$ i / PurchaseOrder / Reference = <span class="bold">$ ref</span> ”+“返回$ i / PurchaseOrder / LineItems'“+”PASSING <span class="bold">？</span> AS \“ <span class="bold">ref</span> \”）“; OraclePreparedStatement stmt =（OraclePreparedStatement）conn.prepareStatement（xqString）; String refString =”EABEL-20021009123336251PDT“; //设置过滤器值stmt.setString（1，refString）; //绑定string ResultSet rs = stmt.executeQuery（）; while（rs.next（））{SQLXML sqlXml = rs.getSQLXML（1）; System.out.println（“LineItem Description：”+ sqlXml.getString（））; sqlXml。 free（）;} rs.close（）; stmt.close（）;}}</pre><p>这会产生以下输出：</p><pre class="oac_no_warn" dir="ltr">***带有绑定变量的数据库XQuery的JDBC访问*** LineItem描述：Samurai 2：在Ichijoji Temple LineItem的决斗描述：The Red Shoes LineItem描述：一个难忘的夜晚</pre></div>
                  <!-- class="example" -->
                  <div class="example" id="GUID-813C0A08-111D-4C4F-B76F-E0B41D6729F0__BABBCACI">
                     <p class="titleinexample">示例5-26在ODP.NET和C＃中使用XQuery</p><pre class="oac_no_warn" dir="ltr">使用系统;使用系统。数据;使用系统。文本;使用系统。IO;使用系统。XML;使用Oracle。数据访问。客户;使用Oracle。数据访问。类型; namespace XQuery {/// &lt;summary&gt; ///演示如何绑定XQuery调用的变量/// &lt;/ summary&gt; class XQuery {/// &lt;summary&gt; ///应用程序的主要入口点。/// &lt;/ summary&gt; static void Main（string [] args）{int rows = 0; StreamReader sr = null; //创建连接string constr =“User Id = oe; Password = ***********; Data Source = ora11gr2”; //替换为真实密码。OracleConnection con = new OracleConnection（constr）; CON。打开（）; //创建命令OracleCommand cmd = new OracleCommand（“”，con）; //设置要查询的XML命令类型。CMD。CommandType = CommandType。文本; //使用XQuery表达式创建SQL查询。StringBuilder blr = new StringBuilder（）; BLR。追加（“SELECT COLUMN_VALUE FROM XMLTable”）; BLR。追加（“（'对于$ i in fn：collection（\”oradb：/ OE / PURCHASEORDER \“）”）; blr。追加（“where count（$ i / PurchaseOrder / LineItems / LineItem）= <span class="bold">$ itemno</span> ”）; BLR。追加（“和$ i / PurchaseOrder / LineItems / LineItem / Part / @ Id = <span class="bold">$ id</span> ”）; BLR。追加（“return $ i / PurchaseOrder / LineItems \'”）; BLR。追加（“ <span class="bold">PASSING：nbitems</span> AS \” <span class="bold">itemno</span> \“ <span class="bold">，：partid</span> AS \” <span class="bold">id</span> \“）”）; CMD。CommandText = blr。的ToString（）; CMD。参数。添加（“ <span class="bold">：nbitems</span> ”，OracleDbType。Int16,3，ParameterDirection。输入）; CMD。参数。添加（“ <span class="bold">：partid</span> ”，OracleDbType。Varchar2，“715515009058”，ParameterDirection。输入）; //将XML文档作为XmlReader获取。OracleDataReader dr = cmd。的ExecuteReader（）;博士。读（）; //获取XMLType列作为OracleXmlType OracleXmlType xml = dr。GetOracleXmlType（0）; //在OracleXmlType对象控制台中打印XML数据。的WriteLine（XML。值）; XML。处置（）; // 清理。CMD。处置（）; CON。关（）; CON。处置（）; }}}</pre><p>这会产生以下输出：</p><pre class="oac_no_warn" dir="ltr">&lt;LineItems&gt; &lt;LineItem ItemNumber =“1”&gt; &lt;Description&gt; Samurai 2：在Ichijoji Temple决斗&lt;/ Description&gt; &lt;Part Id =“37429125526”UnitPrice =“29.95”Quantity =“3”/&gt; &lt;/ LineItem&gt; &lt;LineItem ItemNumber =“2”&gt; &lt;描述&gt;红鞋&lt;/ Description&gt; &lt;Part Id =“37429128220”UnitPrice =“39.95”Quantity =“4”/&gt; &lt;/ LineItem&gt; &lt;LineItem ItemNumber =“3”&gt; &lt;Description&gt;一个难忘的夜晚&lt;/ Description&gt; &lt;Part Id =“715515009058”UnitPrice =“39.95”Quantity =“1”/&gt; &lt;/ LineItem&gt; &lt;/ LineItems&gt;</pre></div>
                  <!-- class="example" -->
               </div>
               <div>
                  <div class="relinfo">
                     <p><strong>相关话题</strong></p>
                     <ul>
                        <li><a href="PLSQL-APIs-for-XMLType.html#GUID-2D5B2D47-9CFF-49D0-9BD8-114BBE48A289" title="有几个PL / SQL包为XMLType提供API。">XMLType的PL / SQL API</a></li>
                        <li><a href="Java-DOM-API-for-XMLType.html#GUID-4C510052-8A31-4917-8567-0E2825927C54" title="XMLType的Java DOM API允许您使用DOM操作XMLType实例。您可以使用它来操作Java中的XML数据，包括通过Java数据库连接（JDBC）获取它。">用于XMLType的Java DOM API</a></li>
                        <li><a href="XML-DB-and-ODP-for-dot-NET.html#GUID-30B4F0FD-C2E3-4F9A-94C2-3C04CC697F2F" title="Oracle Data Provider for Microsoft .NET（ODP.NET）是Oracle数据库的数据提供程序的实现。它使用Oracle本机API，可以从任何.NET应用程序快速可靠地访问Oracle数据和功能。">Oracle XML DB和Oracle Data Provider for .NET</a></li>
                     </ul>
                  </div>
                  <div class="familylinks">
                     <div class="parentlink">
                        <p><strong>父主题：</strong> <a href="query-and-update-XML.html#GUID-01C75289-804F-4BAA-AE7C-DFA73198581E" title="应用程序有许多方法可以查询和更新Oracle数据库中的XML数据，包括基于XML模式和非基于模式的数据。">XML数据的查询和更新</a></p>
                     </div>
                  </div>
               </div>
               
            </div><a id="ADXDB0440"></a><div class="props_rev_3"><a id="GUID-6AE99020-C3C8-44EB-8E54-40188E1103F2" name="GUID-6AE99020-C3C8-44EB-8E54-40188E1103F2"></a><h3 id="ADXDB-GUID-6AE99020-C3C8-44EB-8E54-40188E1103F2" class="sect3"><span class="enumeration_section">5.6</span>更新XML数据</h3>
               <div>
                  <p>有几种方法可以使用Oracle XML DB功能更新XML数据，无论是瞬态还是存储在数据库表中。</p>
               </div>
               <div>
                  <ul class="ullinks">
                     <li class="ulchildlink"><a href="query-and-update-XML.html#GUID-5874AE0D-FC05-4156-80CB-F4474AD74F18">更新整个XML文档</a><br>要更新整个XML文档，请使用SQL <code class="codeph">UPDATE</code>语句。
                     </li>
                     <li class="ulchildlink"><a href="query-and-update-XML.html#GUID-9DE1EAEA-60A6-47AF-B4CC-28AB2BC5C998">替换XML节点</a><br>您可以将XQuery Update与SQL <code class="codeph">UPDATE</code>语句一起使用来更新现有XML文档，而不是创建新文档。整个文档都会更新，而不仅仅是所选文档的一部分。
                     </li>
                     <li class="ulchildlink"><a href="query-and-update-XML.html#GUID-3C9D2384-DBD4-45CE-AD76-630A14A0992F">插入子XML节点</a><br>您可以使用XQuery Update在父XML元素下插入新子项（单个属性或同一类型的一个或多个元素）。作为插入目标的XML文档可以是基于模式的，也可以是非基于模式的。
                     </li>
                     <li class="ulchildlink"><a href="query-and-update-XML.html#GUID-63312C36-9A69-4ACD-BC9D-EC433A0C2D53">删除XML节点</a><br>一个示例使用XQuery Update删除XML节点。
                     </li>
                     <li class="ulchildlink"><a href="query-and-update-XML.html#GUID-59A36DE7-3BB3-4F42-8441-0D0489097A92">创建修改后的XML数据的XML视图</a><br>您可以使用XQuery Update创建XML数据的新视图。
                     </li>
                  </ul>
                  <div class="familylinks">
                     <div class="parentlink">
                        <p><strong>父主题：</strong> <a href="query-and-update-XML.html#GUID-01C75289-804F-4BAA-AE7C-DFA73198581E" title="应用程序有许多方法可以查询和更新Oracle数据库中的XML数据，包括基于XML模式和非基于模式的数据。">XML数据的查询和更新</a></p>
                     </div>
                  </div>
               </div>
               <a id="ADXDB4268"></a><a id="ADXDB4267"></a><div class="props_rev_3"><a id="GUID-5874AE0D-FC05-4156-80CB-F4474AD74F18" name="GUID-5874AE0D-FC05-4156-80CB-F4474AD74F18"></a><h4 id="ADXDB-GUID-5874AE0D-FC05-4156-80CB-F4474AD74F18" class="sect4"><span class="enumeration_section">5.6.1</span>更新整个XML文档</h4>
                  <div>
                     <p>要更新整个XML文档，请使用SQL <code class="codeph">UPDATE</code>语句。
                     </p>
                     <div class="section">
                        <p><code class="codeph">UPDATE</code>语句<code class="codeph">SET</code>子句的右侧必须是<code class="codeph">XMLType</code>实例。可以通过以下任何方式创建：</p>
                     </div>
                     <!-- class="section" -->
                     <div class="section">
                        <ul style="list-style-type:disc">
                           <li>
                              <p>使用返回XML实例的SQL函数或XML构造函数。</p>
                           </li>
                           <li>
                              <p>使用PL / SQL DOM API for <code class="codeph">XMLType</code>更改和绑定现有XML实例。
                              </p>
                           </li>
                           <li>
                              <p>使用更改和绑定现有XML实例的Java DOM API。</p>
                           </li>
                        </ul>
                        <p>存储为二进制XML的非基于模式的文档的更新可以以分段方式进行。</p>
                        <p><a href="query-and-update-XML.html#GUID-5874AE0D-FC05-4156-80CB-F4474AD74F18__CHDCHHJB">示例5-27</a>使用SQL <code class="codeph">UPDATE</code>语句更新<code class="codeph">XMLType</code>实例。
                        </p>
                     </div>
                     <!-- class="section" -->
                     <div class="example" id="GUID-5874AE0D-FC05-4156-80CB-F4474AD74F18__CHDCHHJB">
                        <p class="titleinexample">示例5-27使用SQL UPDATE更新XMLType数据</p><pre class="pre codeblock"><code>SELECT t.reference，li.lineno，li.description FROM purchaseorder po，XMLTable（'$ p / PurchaseOrder'PASSING po。OBJECT_VALUE AS“p”COLUMNS引用VARCHAR2（28）PATH'Reference'，lineitem XMLType PATH'RineItems / LineItem'）t，XMLTable（'$ l / LineItem'PASSING t.lineitem AS“l”COLUMNS lineno NUMBER（10）PATH '@ItemNumber'，description VARCHAR2（128）PATH'Description'）li WHERE t.reference ='DAUSTIN-20021009123335811PDT'AND ROWNUM &lt;6;参考LINENO描述-------------------------------- ------- -------- --------- DAUSTIN-20021009123335811PDT 1晚Cabiria DAUSTIN-20021009123335811PDT 2 For All Mankind DAUSTIN-20021009123335811PDT 3 Dead Ringers DAUSTIN-20021009123335811PDT 4心灵与心灵DAUSTIN-20021009123335811PDT 5 Rushmore UPDATE purchaseorder po SET po。OBJECT_VALUE = XMLType（bfilename（'XMLDIR'，'NEW-DAUSTIN-20021009123335811PDT.xml'），nls_charset_id（'AL32UTF8'））WHERE XMLExists（'$ p / PurchaseOrder [Reference =“DAUSTIN-20021009123335811PDT”]'PASSING po。OBJECT_VALUE AS“p”）; SELECT t.reference，li.lineno，li.description FROM purchaseorder po，XMLTable（'$ p / PurchaseOrder'PASSING po。OBJECT_VALUE AS“p”COLUMNS引用VARCHAR2（28）PATH'Reference'，lineitem XMLType PATH'RineItems / LineItem'）t，XMLTable（'$ l / LineItem'PASSING t.lineitem AS“l”COLUMNS lineno NUMBER（10）PATH '@ItemNumber'，description VARCHAR2（128）PATH'Description'）li WHERE t.reference ='DAUSTIN-20021009123335811PDT';参考LINENO描述-------------------------------- ------- -------- ------------------------ DAUSTIN-20021009123335811PDT 1死林格DAUSTIN-20021009123335811PDT 2 Getrud DAUSTIN-20021009123335811PDT 3品牌杀戮</code></pre></div>
                     <!-- class="example" -->
                  </div>
                  <div>
                     <div class="familylinks">
                        <div class="parentlink">
                           <p><strong>父主题：</strong> <a href="query-and-update-XML.html#GUID-6AE99020-C3C8-44EB-8E54-40188E1103F2" title="有几种方法可以使用Oracle XML DB功能更新XML数据，无论是瞬态还是存储在数据库表中。">更新XML数据</a></p>
                        </div>
                     </div>
                  </div>
                  
               </div><a id="ADXDB4273"></a><a id="ADXDB4274"></a><a id="ADXDB4275"></a><a id="ADXDB4145"></a><a id="ADXDB4146"></a><a id="ADXDB6043"></a><div class="props_rev_3"><a id="GUID-9DE1EAEA-60A6-47AF-B4CC-28AB2BC5C998" name="GUID-9DE1EAEA-60A6-47AF-B4CC-28AB2BC5C998"></a><h4 id="ADXDB-GUID-9DE1EAEA-60A6-47AF-B4CC-28AB2BC5C998" class="sect4"><span class="enumeration_section">5.6.2</span>替换XML节点</h4>
                  <div>
                     <p>您可以将XQuery Update与SQL <code class="codeph">UPDATE</code>语句一起使用来更新现有XML文档，而不是创建新文档。整个文档都会更新，而不仅仅是所选文档的一部分。
                     </p>
                     <div class="section">
                        <p>在<a href="query-and-update-XML.html#GUID-9DE1EAEA-60A6-47AF-B4CC-28AB2BC5C998__CHDEBGDD">例5-28中，</a>我们将SQL字符串文字<span class="bold"><code class="codeph">'SKING'</code></span>作为变量（ <code class="codeph">$p2</code> ）传递给XQuery表达式。在这个简单的例子中，由于值是一个字符串文字，我们可以简单地使用<code class="codeph">replace value of node $j with</code> <span class="bold"><code class="codeph">"SKING"</code></span> 。也就是说，你可以在这里使用文字XQuery字符串，而不是将文字字符串从SQL传递给XQuery。在实际示例中，您通常会传递一个仅在运行时可用的值; <a href="query-and-update-XML.html#GUID-9DE1EAEA-60A6-47AF-B4CC-28AB2BC5C998__CHDEBGDD">例5-28</a>显示了如何做到这一点。其他例子也是如此。
                        </p>
                        <p><a href="query-and-update-XML.html#GUID-9DE1EAEA-60A6-47AF-B4CC-28AB2BC5C998__CHDIIHCI">例5-29</a>更新了多个文本节点和属性节点。
                        </p>
                        <p><a href="query-and-update-XML.html#GUID-9DE1EAEA-60A6-47AF-B4CC-28AB2BC5C998__CHDEJIJD">示例5-30</a>更新集合中的选定节点。
                        </p>
                        <p><a href="query-and-update-XML.html#GUID-9DE1EAEA-60A6-47AF-B4CC-28AB2BC5C998__BJFCFABB">例5-31</a>说明了使用XQuery Update替换值操作更新集合中<span class="italic">多次出现</span>的<span class="italic">节点</span>的常见错误。<code class="codeph">UPDATE</code>语句将<code class="codeph">Description</code>元素的文本节点的值设置为<code class="codeph">The Wizard of Oz</code> ，其中文本节点的当前值为<code class="codeph">Sisters</code> 。该语句在<code class="codeph">WHERE</code>子句中包含一个<code class="codeph">XMLExists</code>表达式，用于标识要更新的节点集。
                        </p>
                        <p><a href="query-and-update-XML.html#GUID-9DE1EAEA-60A6-47AF-B4CC-28AB2BC5C998__BJFCFABB">示例5-31</a>不是仅更新目标节点，而是更新属于<code class="codeph">Description</code>元素的<span class="italic">所有</span>文本节点的值。这不是预期的。
                        </p>
                        <p><span class="italic">一个</span> <span class="italic"><code class="codeph">WHERE</code></span> <span class="italic">子句只能用来识别哪些</span> <span class="italic"><span class="bold">文件</span></span> <span class="italic">必须进行更新，而不是</span> <span class="italic">一个文档中</span> <span class="italic"><span class="bold">的</span></span> <span class="italic">哪些</span> <span class="italic"><span class="bold">节点</span></span> <span class="italic">必须进行更新</span> 。
                        </p>
                        <p>选择文档后，传递给XQuery Update的<span class="italic">XQuery表达式</span>确定必须更新文档中的哪些<span class="italic">节点</span> 。在这种情况下，XQuery表达式标识所有三个<code class="codeph">Description</code>节点，因此更新了所有三个关联的文本节点。
                        </p>
                        <p>要正确更新在集合中多次出现的节点，请使用通过XQuery Update的XQuery表达式来标识要更新的XML文档中的哪些节点。通过在XQuery表达式中引入适当的谓词，可以限制文档中的哪些节点更新。<a href="query-and-update-XML.html#GUID-9DE1EAEA-60A6-47AF-B4CC-28AB2BC5C998__BABEJGHA">例5-32</a>说明了更新集合中一个节点的正确方法。
                        </p>
                     </div>
                     <!-- class="section" -->
                     <div class="example" id="GUID-9DE1EAEA-60A6-47AF-B4CC-28AB2BC5C998__CHDEBGDD">
                        <p class="titleinexample">示例5-28使用SQL UPDATE和XQuery Update更新XMLTYPE数据</p><pre class="pre codeblock"><code>SELECT XMLQuery（'$ p / PurchaseOrder / Actions / Action [1]'PASSING po。OBJECT_VALUE作为“p”返回内容）行动来自purchaseorder po WHERE XMLExists（'$ p / PurchaseOrder [Reference =“SBELL-2002100912333601PDT”]'PASSING po。OBJECT_VALUE AS“p”）; ACTION -------------------------------- &lt;Action&gt; &lt;User&gt; <code class="codeph">SVOLLMAN</code> &lt;/ User&gt; &lt;/ Action&gt; UPDATE purchaseorder po SET po。OBJECT_VALUE = XMLQuery（'copy $ i：= $ p1 modify（for $ j in $ i / PurchaseOrder / Actions / Action [1] / <span class="bold">User</span> return $ <span class="bold">node</span> $ j <span class="bold">with</span> $ p2）return $ i'PASSING po。OBJECT_VALUE为“p1”， <span class="bold">'SKING'为</span> “p2” <span class="bold">返回</span>内容）XMLExists（'$ p / PurchaseOrder [Reference =“SBELL-2002100912333601PDT”]'PASSING po。OBJECT_VALUE AS“p”）; SELECT XMLQuery（'$ p / PurchaseOrder / Actions / Action [1]'PASSING po。OBJECT_VALUE作为“p”返回内容）行动来自purchaseorder po WHERE XMLExists（'$ p / PurchaseOrder [Reference =“SBELL-2002100912333601PDT”]'PASSING po。OBJECT_VALUE AS“p”）; ACTION --------------------------------- &lt;Action&gt; &lt;User&gt; <span class="bold">SKING</span> &lt;/ User&gt; &lt;/ Action&gt;</code></pre></div>
                     <!-- class="example" -->
                     <div class="example" id="GUID-9DE1EAEA-60A6-47AF-B4CC-28AB2BC5C998__CHDIIHCI">
                        <p class="titleinexample">示例5-29更新多个文本节点和属性节点</p><pre class="pre codeblock"><code>SELECT XMLCast（XMLQuery（'$ p / PurchaseOrder / Requestor'PASSING po。OBJECT_VALUE AS“p”返回内容）AS VARCHAR2（30））name，XMLQuery（'$ p / PurchaseOrder / LineItems'PASSING po。OBJECT_VALUE作为“p”返回内容）lineitems来自purchaseorder po WHERE XMLExists（'$ p / PurchaseOrder [Reference =“SBELL-2002100912333601PDT”]'PASSING po。OBJECT_VALUE AS“p”）; NAME LINEITEMS ---------------- -------------------------------- ---------------------------------------- <span class="bold">Sarah J. Bell</span> &lt;LineItems&gt; &lt;LineItem ItemNumber =“1”&gt; &lt;描述&gt; <span class="bold">要记住的夜晚</span> &lt;/ Description&gt; &lt;Part Id =“ <span class="bold">715515009058</span> ”UnitPrice =“39.95”Quantity =“2”/&gt; &lt;/ LineItem&gt; &lt;LineItem ItemNumber =“2”&gt; &lt;Description&gt;难以承受的轻盈&lt;/ Description&gt; &lt;Part Id =“37429140222”UnitPrice =“29.95”Quantity =“2”/&gt; &lt;/ LineItem&gt; <span class="bold">&lt;LineItem ItemNumber =“3”&gt;</span> <span class="bold">&lt;Description&gt; Sisters &lt;/ Description&gt;</span> <span class="bold">&lt;Part Id =“715515011020”UnitPrice =“29.95”Quantity =“4”/&gt;</span> <span class="bold">&lt;/ LineItem&gt;</span> &lt;/ LineItems&gt; UPDATE purchaseorder SET OBJECT_VALUE = XMLQuery（'copy $ i：= $ p1 modify（（$ j in $ i / PurchaseOrder / <span class="bold">Requestor</span>返回用$ p2替换节点$ j的值，（对于$ i中的$ j / PurchaseOrder / LineItems / LineItem [1] / <span class="bold">Part / @Id</span>返回节点$ j的替换值$ p3），（对于$ j in $ i / PurchaseOrder / LineItems / LineItem [1] / <span class="bold">Description</span>返回节点$ j的值替换为$ p4），（对于$ i in $ i / PurchaseOrder / LineItems / <span class="bold">LineItem [3]</span>返回rep花边节点$ j与$ p5））返回$ i'PASSING OBJECT_VALUE AS“p1”， <span class="bold">'Stephen G.</span> <span class="bold">King'AS</span> “p2”， <span class="bold">'786936150421'AS</span> “p3”， <span class="bold">'The</span> <span class="bold">Rock'AS</span> “p4”，XMLType（ <span class="bold">'&lt;LineItem ItemNumber =“99”&gt;</span> <span class="bold">&lt;Description&gt; Dead Ringers &lt;/ Description&gt;</span> <span class="bold">&lt;Part Id =“715515009249”UnitPrice =“39.95”Quantity =“2”/&gt;</span> <span class="bold">&lt;/ LineItem&gt;'</span> ）AS“p5”返回内容）在哪里XMLExists（'$ p / PurchaseOrder [Reference =“SBELL-2002100912333601PDT”]'PASSING OBJECT_VALUE AS“p”）; SELECT XMLCast（XMLQuery（'$ p / PurchaseOrder / Requestor'PASSING po。OBJECT_VALUE AS“p”返回内容）AS VARCHAR2（30））name，XMLQuery（'$ p / PurchaseOrder / LineItems'PASSING po。OBJECT_VALUE作为“p”返回内容）lineitems来自purchaseorder po WHERE XMLExists（'$ p / PurchaseOrder [Reference =“SBELL-2002100912333601PDT”]'PASSING po。OBJECT_VALUE AS“p”）; NAME LINEITEMS ---------------- -------------------------------- ---------------------------------- <span class="bold">Stephen G. King</span> &lt;LineItems&gt; &lt;LineItem ItemNumber =“1”&gt; &lt;描述&gt; <span class="bold">摇滚</span> &lt;/ Description&gt; &lt;Part Id = <span class="bold">“786936150421”</span> UnitPrice =“39.95”Quantity =“2”/&gt; &lt;/ LineItem&gt; &lt;LineItem ItemNumber =“2”&gt; &lt;Description&gt;难以忍受的轻盈&lt;/ Description &gt; &lt;Part Id =“37429140222”UnitPrice =“29.95”Quantity =“2”/&gt; &lt;/ LineItem&gt; <span class="bold">&lt;LineItem ItemNumber =“99”&gt;</span> <span class="bold">&lt;Description&gt; Dead Ringers &lt;/ Description&gt;</span> <span class="bold">&lt;Part Id =“715515009249”UnitPrice = “39.95”Quantity =“2”/&gt;</span> <span class="bold">&lt;/ LineItem&gt;</span> &lt;/ LineItems&gt;</code></pre></div>
                     <!-- class="example" -->
                     <div class="example" id="GUID-9DE1EAEA-60A6-47AF-B4CC-28AB2BC5C998__CHDEJIJD">
                        <p class="titleinexample">示例5-30更新集合中的选定节点</p><pre class="pre codeblock"><code>SELECT XMLCast（XMLQuery（'$ p / PurchaseOrder / Requestor'PASSING po。OBJECT_VALUE AS“p”返回内容）AS VARCHAR2（30））name，XMLQuery（'$ p / PurchaseOrder / LineItems'PASSING po。OBJECT_VALUE作为“p”返回内容）lineitems来自purchaseorder po WHERE XMLExists（'$ p / PurchaseOrder [Reference =“SBELL-2002100912333601PDT”]'PASSING po。OBJECT_VALUE AS“p”）; NAME LINEITEMS ---------------- -------------------------------- -------------------------------- <span class="bold">Sarah J. Bell</span> &lt;LineItems&gt; &lt;LineItem ItemNumber =“1”&gt; &lt;Description&gt;要记住的夜晚&lt;/ Description&gt; &lt;Part Id =“715515009058”UnitPrice =“39.95”Quantity =“ <span class="bold">2</span> ”/&gt; &lt;/ LineItem&gt; <span class="bold">&lt;LineItem ItemNumber =“2”&gt;</span> <span class="bold">&lt;Description&gt;</span> <span class="bold">难以承受的</span> <span class="bold">轻盈&lt;/ Description &gt;</span> <span class="bold">&lt;Part Id =“37429140222”UnitPrice =“29.95”Quantity =“2”/&gt;</span> <span class="bold">&lt;/ LineItem&gt;</span> &lt;LineItem ItemNumber =“3”&gt; &lt;Description&gt; Sisters &lt;/ Description&gt; &lt;Part Id =“715515011020”UnitPrice =“ 29.95“Quantity =”4“/&gt; &lt;/ LineItem&gt; &lt;/ LineItems&gt; UPDATE purchaseorder SET OBJECT_VALUE = XMLQuery（'copy $ i：= $ p1 modify（（$ j in $ i / PurchaseOrder / <span class="bold">Requestor</span> return value of node $ j with $ p2），（$ $ in $ i / PurchaseOrder / LineItems / LineItem / <span class="bold">Part [@ Id =“715515009058”] / @ Quantit</span> y返回节点$ j的替换值$ p3），（$ j在$ i / PurchaseOrder / LineItems / LineItem中[描述/文本（）=“ <span class="bold">难以承受的存在轻盈</span> ”]将$ j替换为节点$ j））返回$ i'P将OBJECT_VALUE分配为“p1”， <span class="bold">'Stephen G.</span> King'AS“p2”， <span class="bold">25</span> AS“p3”，XMLType（ <span class="bold">'&lt;LineItem ItemNumber =“99”&gt;</span> <span class="bold">&lt;Part Id =“786936150421”Quantity =“5”UnitPrice =“ 29.95“/&gt;</span> <span class="bold">&lt;描述&gt; Rock &lt;/ Description&gt;</span> <span class="bold">&lt;/ LineItem&gt;'</span> ）AS”p4“返回内容）XMLExists（'$ p / PurchaseOrder [Reference =”SBELL-2002100912333601PDT“]'PASSING OBJECT_VALUE AS”p“ ）; SELECT XMLCast（XMLQuery（'$ p / PurchaseOrder / Requestor'PASSING po。OBJECT_VALUE AS“p”返回内容）AS VARCHAR2（30））name，XMLQuery（'$ p / PurchaseOrder / LineItems'PASSING po。OBJECT_VALUE作为“p”返回内容）lineitems来自purchaseorder po WHERE XMLExists（'$ p / PurchaseOrder [Reference =“SBELL-2002100912333601PDT”]'PASSING po。OBJECT_VALUE AS“p”）; NAME LINEITEMS ---------------- -------------------------------- ----------------------------- <span class="bold">Stephen G. King</span> &lt;LineItems&gt; &lt;LineItem ItemNumber =“1”&gt; &lt;Description&gt; A Night to记住&lt;/ Description&gt; &lt;Part Id =“715515009058”UnitPrice =“39.95”Quantity =“ <span class="bold">25</span> ”/&gt; &lt;/ LineItem&gt; <span class="bold">&lt;LineItem ItemNumber =“99”&gt;</span> <span class="bold">&lt;Part Id =“786936150421”Quantity =“5”UnitPrice = “29.95”/&gt;</span> <span class="bold">&lt;描述&gt;岩石&lt;/ Description&gt;</span> &lt;/ LineItem&gt; &lt;LineItem ItemNumber =“3”&gt; &lt;描述&gt;姐妹&lt;/ Description&gt; &lt;Part Id =“715515011020”UnitPrice =“29.95”Quantity =“4 “/&gt; &lt;/ LineItem&gt; &lt;/ LineItems&gt;</code></pre></div>
                     <!-- class="example" -->
                     <div class="example" id="GUID-9DE1EAEA-60A6-47AF-B4CC-28AB2BC5C998__BJFCFABB">
                        <p class="titleinexample">示例5-31错误地更新集合中多次出现的节点</p><pre class="pre codeblock"><code>SELECT XMLCast（des。COLUMN_VALUE AS VARCHAR2（256））FROM purchaseorder，XMLTable（'$ p / PurchaseOrder / LineItems / LineItem / Description'PASSING OBJECT_VALUE AS“p”）des WHERE XMLExists（'$ p / PurchaseOrder [Reference =“SBELL-2002100912333601PDT”]'将OBJECT_VALUE传递为“p”）; XMLCAST（DES.COLUMN_VALUEASVARCHAR2（256））----------------------------------------夫人消失了姐妹的无法忍受的轻盈3行选择。UPDATE定单SET OBJECT_VALUE =的XMLQuery（ '复制$ I：= $ P1修改（在$ I / PurchaseOrder的/了LineItem / LineItem的/说明返回附加$ J <span class="bold"><span class="bold">替换</span></span> $ P2 <span class="bold">节点</span> $ j <span class="bold">的值</span> ）返回$ I'逝水OBJECT_VALUE AS“ p1“， <span class="bold">'绿野仙踪'</span> AS”p2“返回内容”XMLExists（'$ p / PurchaseOrder / LineItems / LineItem [Description =“Sisters”]'PASSING OBJECT_VALUE as“p”）和XMLExists（'$ p / PurchaseOrder [Reference =“SBELL-2002100912333601PDT”]'PASSING OBJECT_VALUE AS“p”）; 1行更新。SELECT XMLCast（des。COLUMN_VALUE AS VARCHAR2（256））FROM purchaseorder，XMLTable（'$ p / PurchaseOrder / LineItems / LineItem / Description'PASSING OBJECT_VALUE AS“p”）des WHERE XMLExists（'$ p / PurchaseOrder [Reference =“SBELL-2002100912333601PDT”]'将OBJECT_VALUE传递为“p”）; XMLCAST（DES.COLUMN_VALUEASVARCHAR2（256））---------------------------------------- <span class="bold">的</span> <span class="bold">盎司</span> <span class="bold">盎司<span class="bold"><span class="bold">绿野仙踪</span></span>向导</span> <span class="bold">的向导中</span>选择3行。
</code></pre></div>
                     <!-- class="example" -->
                     <div class="example" id="GUID-9DE1EAEA-60A6-47AF-B4CC-28AB2BC5C998__BABEJGHA">
                        <p class="titleinexample">示例5-32正确更新集合中多次出现的节点</p><pre class="pre codeblock"><code>SELECT XMLCast（des。COLUMN_VALUE AS VARCHAR2（256））FROM purchaseorder，XMLTable（'$ p / PurchaseOrder / LineItems / LineItem / Description'PASSING OBJECT_VALUE AS“p”）des WHERE XMLExists（'$ p / PurchaseOrder [Reference =“SBELL-2002100912333601PDT”]'将OBJECT_VALUE传递为“p”）; XMLCAST（DES.COLUMN_VALUEASVARCHAR2（256））---------------------------------------- A难以忘怀的夜晚成为姐妹的难以忍受的轻盈3行。UPDATE定单SET OBJECT_VALUE =的XMLQuery（'复制$ I：= $ P1修改（对于在$ I /的PurchaseOrder /了LineItem /的LineItem /描述$ <span class="bold">f] [文本（）= “姐妹”]</span>返回<span class="bold"><span class="bold">替换</span></span> $ P2 <span class="bold">节点</span> $ j <span class="bold">的值</span> ）返回$ i'通过OBJECT_VALUE作为“p1”， <span class="bold">“绿野仙踪”</span> AS“p2”返回内容）XMLExists（'$ p / PurchaseOrder [Reference =“SBELL-2002100912333601PDT”]'PASSING OBJECT_VALUE AS“p”） ; 1行更新。SELECT XMLCast（des。COLUMN_VALUE AS VARCHAR2（256））FROM purchaseorder，XMLTable（'$ p / PurchaseOrder / LineItems / LineItem / Description'PASSING OBJECT_VALUE AS“p”）des WHERE XMLExists（'$ p / PurchaseOrder [Reference =“SBELL-2002100912333601PDT”]'将OBJECT_VALUE传递为“p”）; XMLCAST（DES.COLUMN_VALUEASVARCHAR2（256））---------------------------------------- A难以忘怀的夜晚<span class="bold">成为奥兹精灵的</span>难以忍受的轻盈3行选择。
</code></pre></div>
                     <!-- class="example" -->
                  </div>
                  <div>
                     <ul class="ullinks">
                        <li class="ulchildlink"><a href="query-and-update-XML.html#GUID-A3B5055C-EDD6-42B6-BD90-C98E2F780B9A">将XML数据更新为NULL值</a><br>某些注意事项适用于将XML数据更新为<code class="codeph">NULL</code>值。
                        </li>
                     </ul>
                     <div class="familylinks">
                        <div class="parentlink">
                           <p><strong>父主题：</strong> <a href="query-and-update-XML.html#GUID-6AE99020-C3C8-44EB-8E54-40188E1103F2" title="有几种方法可以使用Oracle XML DB功能更新XML数据，无论是瞬态还是存储在数据库表中。">更新XML数据</a></p>
                        </div>
                     </div>
                  </div>
                  <a id="ADXDB4277"></a><a id="ADXDB4278"></a><a id="ADXDB4276"></a><div class="props_rev_3"><a id="GUID-A3B5055C-EDD6-42B6-BD90-C98E2F780B9A" name="GUID-A3B5055C-EDD6-42B6-BD90-C98E2F780B9A"></a><h5 id="ADXDB-GUID-A3B5055C-EDD6-42B6-BD90-C98E2F780B9A" class="sect5"><span class="enumeration_section">5.6.2.1将</span> XML数据更新为NULL值</h5>
                     <div>
                        <p>某些注意事项适用于将XML数据更新为<code class="codeph">NULL</code>值。
                        </p>
                        <div class="section"></div>
                        <!-- class="section" -->
                        <div class="section">
                           <ul style="list-style-type:disc">
                              <li>
                                 <p>如果将XML <span class="italic">元素</span>更新为<code class="codeph">NULL</code> ，则会删除元素的属性和子元素，并且元素变为空。保留元素的类型和名称空间属性。参见<a href="query-and-update-XML.html#GUID-A3B5055C-EDD6-42B6-BD90-C98E2F780B9A__CHDBBEHI">例5-33</a> 。
                                 </p>
                              </li>
                              <li>
                                 <p>如果将<span class="italic">属性</span>值更新为<code class="codeph">NULL</code> ，则该值将显示为空字符串。参见<a href="query-and-update-XML.html#GUID-A3B5055C-EDD6-42B6-BD90-C98E2F780B9A__CHDBBEHI">例5-33</a> 。
                                 </p>
                              </li>
                              <li>
                                 <p>如果将元素的<span class="italic">文本</span>节点更新为<code class="codeph">NULL</code> ，则会删除元素的内容（文本）。元素本身仍然存在，但它是空的。 <code class="codeph"></code> 参见<a href="query-and-update-XML.html#GUID-A3B5055C-EDD6-42B6-BD90-C98E2F780B9A__CHDDEBBJ">例5-34</a> 。
                                 </p>
                              </li>
                           </ul>
                           <p><a href="query-and-update-XML.html#GUID-A3B5055C-EDD6-42B6-BD90-C98E2F780B9A__CHDBBEHI">例5-33</a>将以下所有内容更新为<code class="codeph">NULL</code> ：</p>
                           <ul style="list-style-type:disc">
                              <li>
                                 <p><code class="codeph">LineItem</code>元素的<code class="codeph">Description</code>元素和<code class="codeph">Quantity</code>属性，其<code class="codeph">Part</code>元素具有属性<code class="codeph">Id</code>值715515009058。
                                 </p>
                              </li>
                              <li>
                                 <p><code class="codeph">LineItem</code>元素，其<code class="codeph">Description</code>元素具有内容（文本）“存在的难以忍受的轻盈”。
                                 </p>
                              </li>
                           </ul>
                           <p><a href="query-and-update-XML.html#GUID-A3B5055C-EDD6-42B6-BD90-C98E2F780B9A__CHDBBEHI">例5-33</a>显示了两种不同但等效的方法来删除节点的值。对于元素<code class="codeph">Description</code>和属性<code class="codeph">Quantity</code> ，文字XQuery空序列<span class="bold"><code class="codeph">()</code></span>直接替换现有值。对于元素<code class="codeph">LineItem</code> ，将SQL <span class="bold"><code class="codeph">NULL</code></span>传递到XQuery表达式以提供空节点值。由于使用的值是文字的，因此不将它从SQL传递给XQuery更简单。但在实际示例中，您通常会传递仅在运行时可用的值。<a href="query-and-update-XML.html#GUID-A3B5055C-EDD6-42B6-BD90-C98E2F780B9A__CHDBBEHI">例5-33</a>显示了如何为空XQuery序列执行此操作：传递SQL <code class="codeph">NULL</code>值。
                           </p>
                           <p><a href="query-and-update-XML.html#GUID-A3B5055C-EDD6-42B6-BD90-C98E2F780B9A__CHDDEBBJ">例5-34</a>将<code class="codeph">Description</code>属性值为“ <code class="codeph">A Night to Remember</code> ”的<code class="codeph">Part</code>元素的文本节点更新为<code class="codeph">NULL</code> 。此示例的XML数据对应于不同的，修订的采购订单XML架构 - 请参阅<a href="XML-Schema-evolution.html#GUID-AD87A5C3-D0E8-4109-A6B2-F3F673D42FFD" title="显示了采购订单XML架构的演进版本。它用于说明使用基于副本的XML模式演变的示例中。">基于副本的演变的场景</a> 。在该XML模式中， <code class="codeph">Description</code>是<code class="codeph">Part</code>元素的属性，而不是兄弟元素。
                           </p>
                           <div class="infoboxnotealso" id="GUID-A3B5055C-EDD6-42B6-BD90-C98E2F780B9A__GUID-8E4A339C-64A2-497B-81AB-67E432BB6E91">
                              <p class="notep1">也可以看看：</p>
                              <p><a href="how-to-use-XML-DB.html#GUID-96D5EAC3-463F-48C0-BF3C-D051E0B174E8__CHDBGCBG">例3-26</a></p>
                           </div>
                        </div>
                        <!-- class="section" -->
                        <div class="example" id="GUID-A3B5055C-EDD6-42B6-BD90-C98E2F780B9A__CHDBBEHI">
                           <p class="titleinexample">示例5-33 NULL更新 - 元素和属性</p><pre class="oac_no_warn" dir="ltr">SELECT XMLCast（XMLQuery（'$ p / PurchaseOrder / Requestor'PASSING po。OBJECT_VALUE AS“p”返回内容）AS VARCHAR2（30））name，XMLQuery（'$ p / PurchaseOrder / LineItems'PASSING po。OBJECT_VALUE作为“p”返回内容）lineitems来自purchaseorder po WHERE XMLExists（'$ p / PurchaseOrder [Reference =“SBELL-2002100912333601PDT”]'PASSING po。OBJECT_VALUE AS“p”）; NAME LINEITEMS ---------------- -------------------------------- ----------------------------------- Sarah J. Bell &lt;LineItems&gt; &lt;LineItem ItemNumber =“1”&gt; &lt;描述&gt; <span class="bold">要记住的夜晚</span> &lt;/ Description&gt; &lt;Part Id =“715515009058”UnitPrice =“39.95”Quantity =“ <span class="bold">2</span> ”/&gt; &lt;/ LineItem&gt; <span class="bold">&lt;LineItem ItemNumber =“2”&gt;</span> <span class="bold">&lt;描述&gt;存在的难以承受的轻盈&lt;/ Description&gt;</span> <span class="bold">&lt;Part Id =“37429140222”UnitPrice =“29.95”Quantity =“2”/&gt;</span> <span class="bold">&lt;/ LineItem&gt;</span> &lt;LineItem ItemNumber =“3”&gt; &lt;Description&gt; Sisters &lt;/ Description&gt; &lt;Part Id =“715515011020” UnitPrice =“29.95”Quantity =“4”/&gt; &lt;/ LineItem&gt; &lt;/ LineItems&gt; UPDATE purchaseorder SET OBJECT_VALUE = XMLQuery（'copy $ i：= $ p1 modify（（$ i in $ i / PurchaseOrder / LineItems / LineItem [Part / @ Id =“715515009058”] / <span class="bold">描述</span>返回节点$ j的值替换为<span class="bold">（）</span> ），（对于$ i中的$ i / PurchaseOrder / LineItems / LineItem / Part [@ Id =“715515009058”] / <span class="bold">@Quantity</span>使用<span class="bold">（）</span> ）返回节点$ j的值替换，（对于$ i / PurchaseOrder / LineItems / LineItem中的$ j [描述/文本（）=“Bei难以忍受的亮度ng“]使用$ p2返回节点$ j））返回$ i'PASSING OBJECT_VALUE AS”p1“， <span class="bold">NULL</span> AS”p2“返回内容）XMLExists（'$ p / PurchaseOrder [Reference =”SBELL-2002100912333601PDT“]'将OBJECT_VALUE传递为“p”）; SELECT XMLCast（XMLQuery（'$ p / PurchaseOrder / Requestor'PASSING po。OBJECT_VALUE AS“p”返回内容）AS VARCHAR2（30））name，XMLQuery（'$ p / PurchaseOrder / LineItems'PASSING po。OBJECT_VALUE作为“p”返回内容）lineitems来自purchaseorder po WHERE XMLExists（'$ p / PurchaseOrder [Reference =“SBELL-2002100912333601PDT”]'PASSING po。OBJECT_VALUE AS“p”）; NAME LINEITEMS ---------------- -------------------------------- -------------------------------- Sarah J. Bell &lt;LineItems&gt; &lt;LineItem ItemNumber =“1”&gt; <span class="bold">&lt;Description / &gt;</span> &lt;Part Id =“715515009058”UnitPrice =“39.95” <span class="bold">Quantity =“”</span> /&gt; &lt;/ LineItem&gt; <span class="bold">&lt;LineItem /&gt;</span> &lt;LineItem ItemNumber =“3”&gt; &lt;Description&gt; Sisters &lt;/ Description&gt; &lt;Part Id =“715515011020” UnitPrice =“29.95”Quantity =“4”/&gt; &lt;/ LineItem&gt; &lt;/ LineItems&gt;</pre></div>
                        <!-- class="example" -->
                        <div class="example" id="GUID-A3B5055C-EDD6-42B6-BD90-C98E2F780B9A__CHDDEBBJ">
                           <p class="titleinexample">示例5-34 NULL更新 - 文本节点</p><pre class="oac_no_warn" dir="ltr">SELECT XMLCast（XMLQuery（'$ p / PurchaseOrder / LineItems / LineItem / Part [@ Description =“A Night to Remember”]'PASSING po。OBJECT_VALUE作为“p”返回内容）作为VARCHAR2（128））部分来自购买订单po WHERE XMLExists（'$ p / PurchaseOrder [@ Reference =“SBELL-2003030912333601PDT”]'PASSING po。OBJECT_VALUE AS“p”）; PART ---- &lt;部分描述=“难以忘怀的夜晚”UnitCost =“39.95”&gt; <span class="bold">715515009058</span> &lt;/ Part&gt;更新购买订单SET OBJECT_VALUE = XMLQuery（'copy $ i：= $ p1 modify（for $ j in $ i / PurchaseOrder / LineItems / LineItem / Part [@ Description =“A Night to Remember”]返回节点$ j的替换值$ p2）返回$ i PASSING OBJECT_VALUE AS“p1”， <span class="bold">NULL</span> AS“p2”返回内容）XMLExists（ '$ p / PurchaseOrder [@ Reference =“SBELL-2003030912333601PDT”]'PASSING OBJECT_VALUE AS“p”）; SELECT XMLCast（XMLQuery（'$ p / PurchaseOrder / LineItems / LineItem / Part [@ Description =“A Night to Remember”]'PASSING po。OBJECT_VALUE作为“p”返回内容）作为VARCHAR2（128））部分来自购买订单po WHERE XMLExists（'$ p / PurchaseOrder [@ Reference =“SBELL-2003030912333601PDT”]'PASSING po。OBJECT_VALUE AS“p”）; PART ---- &lt;部分描述=“难忘的夜晚”UnitCost =“39.95”/&gt;</pre></div>
                        <!-- class="example" -->
                     </div>
                     <div>
                        <div class="familylinks">
                           <div class="parentlink">
                              <p><strong>父主题：</strong> <a href="query-and-update-XML.html#GUID-9DE1EAEA-60A6-47AF-B4CC-28AB2BC5C998" title="您可以将XQuery Update与SQL UPDATE语句一起使用来更新现有XML文档，而不是创建新文档。整个文档都会更新，而不仅仅是所选文档的一部分。">替换XML节点</a></p>
                           </div>
                        </div>
                     </div>
                     
                  </div>
               </div><a id="ADXDB4291"></a><a id="ADXDB4292"></a><a id="ADXDB5807"></a><a id="ADXDB4304"></a><a id="ADXDB4289"></a><div class="props_rev_3"><a id="GUID-3C9D2384-DBD4-45CE-AD76-630A14A0992F" name="GUID-3C9D2384-DBD4-45CE-AD76-630A14A0992F"></a><h4 id="ADXDB-GUID-3C9D2384-DBD4-45CE-AD76-630A14A0992F" class="sect4"><span class="enumeration_section">5.6.3</span>插入子XML节点</h4>
                  <div>
                     <p>您可以使用XQuery Update在父XML元素下插入新子项（单个属性或同一类型的一个或多个元素）。作为插入目标的XML文档可以是基于模式的，也可以是非基于模式的。</p>
                     <div class="section">
                        <p><a href="query-and-update-XML.html#GUID-3C9D2384-DBD4-45CE-AD76-630A14A0992F__CHDEDCBF">例5-35</a>插入一个新的<code class="codeph">LineItem</code>元素作为元素<code class="codeph">LineItems</code>的子元素。它使用Oracle XQuery pragma <code class="codeph">ora:child-element-name</code>将插入的子元素的名称指定为<code class="codeph">LineItem</code> 。
                        </p>
                        <p>如果要更新的XML数据是基于XML模式的并且它引用了命名空间，那么要插入的数据也必须引用相同的命名空间。否则，会引发错误，因为插入的数据不符合XML架构。</p>
                        <div class="infoboxnote" id="GUID-3C9D2384-DBD4-45CE-AD76-630A14A0992F__GUID-E650BD6D-426F-456E-B830-7B9DBC0580A3">
                           <p class="notep1">注意：</p>
                           <p>请注意，如果尝试将更新的数据存储回基于XML架构的列或表，则使用XQuery Update更新基于XML架构的数据会导致出错。要防止这种情况，请使用XQuery pragma <code class="codeph">ora:transform_keep_schema</code> 。请参阅<a href="xquery-and-XML-DB.html#GUID-09066C46-8272-461A-ADE7-2F1B0FCDA948" title="W3C XQuery规范允许实现提供实现定义的扩展表达式。XQuery扩展表达式是一个XQuery表达式，它包含在大括号（{，}）中，并以实现定义的pragma为前缀。Oracle实现提供了几个这样的编译指示。">Oracle XQuery Extension-Expression Pragmas</a> 。
                           </p>
                        </div>
                        <p><a href="query-and-update-XML.html#GUID-3C9D2384-DBD4-45CE-AD76-630A14A0992F__CHDGAHJB">示例5-36</a>与<a href="query-and-update-XML.html#GUID-3C9D2384-DBD4-45CE-AD76-630A14A0992F__CHDEDCBF">示例5-35</a>相同，只是要插入的<code class="codeph">LineItem</code>元素引用命名空间。这假设相关的XML模式需要此元素的命名空间。
                        </p>
                        <p><a href="query-and-update-XML.html#GUID-3C9D2384-DBD4-45CE-AD76-630A14A0992F__CACJGGJE">例5-37</a>在第一个<code class="codeph">LineItem</code>元素之前插入一个<code class="codeph">LineItem</code>元素。
                        </p>
                        <p><a href="query-and-update-XML.html#GUID-3C9D2384-DBD4-45CE-AD76-630A14A0992F__CACDEIDH">例5-38</a>将<code class="codeph">Date</code>元素作为<code class="codeph">Action</code>元素的最后一个子元素插入。
                        </p>
                     </div>
                     <!-- class="section" -->
                     <div class="example" id="GUID-3C9D2384-DBD4-45CE-AD76-630A14A0992F__CHDEDCBF">
                        <p class="titleinexample">示例5-35将元素插入集合</p><pre class="oac_no_warn" dir="ltr">SELECT XMLQuery（'$ p / PurchaseOrder / LineItems / LineItem [@ ItemNumber = 222]'PASSING po。OBJECT_VALUE作为“p”返回内容）来自purchaseorder po WHERE XMLExists（'$ p / PurchaseOrder [Reference =“AMCEWEN-20021009123336171PDT”]'PASSING po。OBJECT_VALUE AS“p”）; XMLQUERY（'$ P / PURCHASEORDER / LINEITEMS / LINEITEM [@ ITEMNUMBER = 222]'-------------------------------- -------------------------------选择1行。UPDATE purchaseorder SET OBJECT_VALUE = XMLQuery（'copy $ i：= $ p1 modify（$ i / PurchaseOrder / LineItems return $ <span class="bold">（＃ora：child-element-name LineItem＃）</span> { <span class="bold">将节点</span> $ p2 <span class="bold">插入</span> $ j}）返回$ i'PASSING OBJECT_VALUE为“p1”，XMLType（ <span class="bold">'&lt;LineItem ItemNumber =“222”&gt;</span> <span class="bold">&lt;描述&gt;他们来的更难&lt;/ Description&gt;</span> <span class="bold">&lt;Part Id =“953562951413”UnitPrice =“22.95”Quantity =“1” /&gt;</span> <span class="bold">&lt;/ LineItem&gt;'</span> ）AS“p2”返回内容）XMLExists（'$ p / PurchaseOrder [Reference =“AMCEWEN-20021009123336171PDT”]'PASSING OBJECT_VALUE AS“p”）; SELECT XMLQuery（'$ p / PurchaseOrder / LineItems / LineItem [@ ItemNumber = 222]'PASSING po。OBJECT_VALUE作为“p”返回内容）来自purchaseorder po WHERE XMLExists（'$ p / PurchaseOrder [Reference =“AMCEWEN-20021009123336171PDT”]'PASSING po。OBJECT_VALUE AS“p”）; XMLQUERY（'$ P / PURCHASEORDER / LINEITEMS / LINEITEM [@ ITEMNUMBER = 222]'-------------------------------- ------------------------------- <span class="bold">&lt;LineItem ItemNumber =“222”&gt;</span> <span class="bold">&lt;描述&gt;他们来的更难&lt;/ Description&gt;</span> <span class="bold">&lt;Part Id =“953562951413”UnitPrice =“22.95”Quantity =“1”/&gt;</span> <span class="bold">&lt;/ LineItem&gt;</span>选择了1行。
</pre></div>
                     <!-- class="example" -->
                     <div class="example" id="GUID-3C9D2384-DBD4-45CE-AD76-630A14A0992F__CHDGAHJB">
                        <p class="titleinexample">示例5-36插入使用命名空间的元素</p><pre class="oac_no_warn" dir="ltr">更新购买订单SET OBJECT_VALUE = XMLQuery（' <span class="bold">declare namespace e =“films.xsd”</span> ;（：:) copy $ i：= $ p1 modify（for $ j in $ i / PurchaseOrder / LineItems return（#ora：child-element- name <span class="bold">e：</span> LineItem＃）{将节点$ p2插入$ j}}返回$ i'PASSING OBJECT_VALUE AS“p1”，XMLType（'&lt; <span class="bold">e：</span> LineItem ItemNumber =“222”&gt; &lt;Description&gt;更难他们来&lt;/ Description &gt; &lt;Part Id =“953562951413”UnitPrice =“22.95”Quantity =“1”/&gt; &lt;/ <span class="bold">e：</span> LineItem&gt;'）AS“p2”返回内容）XMLExists（'$ p / PurchaseOrder [Reference =“AMCEWEN-20021009123336171PDT “]'将OBJECT_VALUE传递为”p“）;</pre></div>
                     <!-- class="example" -->
                     <div class="example" id="GUID-3C9D2384-DBD4-45CE-AD76-630A14A0992F__CACJGGJE">
                        <p class="titleinexample">示例5-37在元素之前插入元素</p><pre class="oac_no_warn" dir="ltr">SELECT XMLQuery（'$ p / PurchaseOrder / LineItems / LineItem [1]'PASSING po。OBJECT_VALUE作为“p”返回内容）来自purchaseorder po WHERE XMLExists（'$ p / PurchaseOrder [Reference =“AMCEWEN-20021009123336171PDT”]'PASSING po。OBJECT_VALUE AS“p”）; XMLQUERY（'$ P / PURCHASEORDER / LINEITEMS / LINEITEM [1]'PASSINGPO.OBJECT_ -------------------------------- ---------------------------------- &lt;LineItem ItemNumber =“1”&gt; &lt;Description&gt; Salesman &lt;/ Description&gt; &lt;Part Id =“37429158920”UnitPrice =“39.95”Quantity =“2”/&gt; &lt;/ LineItem&gt; UPDATE purchaseorder SET OBJECT_VALUE = XMLQuery（'copy $ i：= $ p1 modify（for $ j in $ i / PurchaseOrder / LineItems） / LineItem [1] <span class="bold">在</span> $ j <span class="bold">之前</span>返回<span class="bold">插入节点</span> $ p2）返回$ i'PASSING OBJECT_VALUE AS“p1”，XMLType（ <span class="bold">'&lt;LineItem ItemNumber =“314”&gt;</span> <span class="bold">&lt;Description&gt; Brazil &lt;/ Description&gt;</span> <span class="bold">&lt;Part Id =“314159265359 “UnitPrice =”69.95“</span> <span class="bold">Quantity =”2“/&gt;</span> <span class="bold">&lt;/ LineItem&gt;'</span> ）AS”p2“返回内容）XMLExists（'$ p / PurchaseOrder [Reference =”AMCEWEN-20021009123336171PDT“]'PASSING OBJECT_VALUE AS”p“ ）; SELECT XMLQuery（'$ p / PurchaseOrder / LineItems / LineItem [ <span class="bold">position（）&lt;= 2</span> ]'PASSING po。OBJECT_VALUE作为“p”返回内容）来自purchaseorder po WHERE XMLExists（'$ p / PurchaseOrder [Reference =“AMCEWEN-20021009123336171PDT”]'PASSING po。OBJECT_VALUE AS“p”）; XMLQUERY（'$ P / PURCHASEORDER / LINEITEMS / LINEITEM [POSITION（）&lt;= 2]'PASSINGPO.OBJECT_ --------------------------- -------------------------------------------------- - <span class="bold">&lt;LineItem ItemNumber =“314”&gt;</span> <span class="bold">&lt;Description&gt; Brazil &lt;/ Description&gt;</span> <span class="bold">&lt;Part Id =“314159265359”UnitPrice =“69.95”Quantity =“2”/&gt;</span> <span class="bold">&lt;/ LineItem&gt;</span> &lt;LineItem ItemNumber =“1”&gt; &lt;Description &gt;推销员&lt;/ Description&gt; &lt;Part Id =“37429158920”UnitPrice =“39.95”Quantity =“2”/&gt; &lt;/ LineItem&gt;</pre></div>
                     <!-- class="example" -->
                     <div class="example" id="GUID-3C9D2384-DBD4-45CE-AD76-630A14A0992F__CACDEIDH">
                        <p class="titleinexample">示例5-38插入元素作为最后一个子元素</p><pre class="oac_no_warn" dir="ltr">SELECT XMLQuery（'$ p / PurchaseOrder / Actions / Action [1]'PASSING po。OBJECT_VALUE作为“p”返回内容）来自purchaseorder po WHERE XMLExists（'$ p / PurchaseOrder [Reference =“AMCEWEN-20021009123336171PDT”]'PASSING po。OBJECT_VALUE AS“p”）; XMLQUERY（'$ P / PURCHASEORDER / ACTIONS / ACTION [1]'PASSINGPO.OBJECT_VALUE -------------------------------- ----------------------------------- &lt;Action&gt; &lt;User&gt; KPARTNER &lt;/ User&gt; &lt;/ Action&gt;更新购买订单SET OBJECT_VALUE = XMLQuery（'copy $ i：= $ p1 modify（$ i / PurchaseOrder / Actions / Action [1]返回<span class="bold">插入节点</span> $ p2 <span class="bold">作为最后一个到</span> $ j）返回$ i'PASSING OBJECT_VALUE AS “p1”，XMLType（ <span class="bold">'&lt;Date&gt; 2002-11-04 &lt;/ Date&gt;'</span> ）AS“p2”返回内容）XMLExists（'$ p / PurchaseOrder [Reference =“AMCEWEN-20021009123336171PDT”]'PASSING OBJECT_VALUE AS“ p“）; SELECT XMLQuery（'$ p / PurchaseOrder / Actions / Action [1]'PASSING po。OBJECT_VALUE作为“p”返回内容）来自purchaseorder po WHERE XMLExists（'$ p / PurchaseOrder [Reference =“AMCEWEN-20021009123336171PDT”]'PASSING po。OBJECT_VALUE AS“p”）; XMLQUERY（'$ P / PURCHASEORDER / ACTIONS / ACTION [1]'PASSINGPO.OBJECT_VALUE -------------------------------- ----------------------------------- &lt;Action&gt; &lt;User&gt; KPARTNER &lt;/ User&gt; <span class="bold">&lt;Date&gt; 2002 -11-04 &lt;/ Date&gt;</span> &lt;/ Action&gt;</pre></div>
                     <!-- class="example" -->
                  </div>
                  <div>
                     <div class="familylinks">
                        <div class="parentlink">
                           <p><strong>父主题：</strong> <a href="query-and-update-XML.html#GUID-6AE99020-C3C8-44EB-8E54-40188E1103F2" title="有几种方法可以使用Oracle XML DB功能更新XML数据，无论是瞬态还是存储在数据库表中。">更新XML数据</a></p>
                        </div>
                     </div>
                  </div>
                  
               </div><a id="ADXDB4307"></a><a id="ADXDB6086"></a><div class="props_rev_3"><a id="GUID-63312C36-9A69-4ACD-BC9D-EC433A0C2D53" name="GUID-63312C36-9A69-4ACD-BC9D-EC433A0C2D53"></a><h4 id="ADXDB-GUID-63312C36-9A69-4ACD-BC9D-EC433A0C2D53" class="sect4"><span class="enumeration_section">5.6.4</span>删除XML节点</h4>
                  <div>
                     <p>一个示例使用XQuery Update删除XML节点。</p>
                     <div class="section">
                        <p><a href="query-and-update-XML.html#GUID-63312C36-9A69-4ACD-BC9D-EC433A0C2D53__CACHEAHD">例5-39</a>删除<code class="codeph">ItemNumber</code>属性值为<code class="codeph">222</code>的<code class="codeph">LineItem</code>元素。
                        </p>
                     </div>
                     <!-- class="section" -->
                     <div class="example" id="GUID-63312C36-9A69-4ACD-BC9D-EC433A0C2D53__CACHEAHD">
                        <p class="titleinexample">示例5-39删除元素</p><pre class="pre codeblock"><code>SELECT XMLQuery（'$ p / PurchaseOrder / LineItems / LineItem [@ ItemNumber = 222]'PASSING po。OBJECT_VALUE作为“p”返回内容）来自purchaseorder po WHERE XMLExists（'$ p / PurchaseOrder [Reference =“AMCEWEN-20021009123336171PDT”]'PASSING po。OBJECT_VALUE AS“p”）; XMLQUERY（'$ P / PURCHASEORDER / LINEITEMS / LINEITEM [@ ITEMNUMBER = 222]'PASSINGPO ------------------------------- ----------------------------------------- &lt;LineItem ItemNumber =“222”&gt; &lt;描述&gt;他们来的更难&lt;/ Description&gt; &lt;Part Id =“953562951413”UnitPrice =“22.95”Quantity =“1”/&gt; &lt;/ LineItem&gt; UPDATE purchaseorder SET OBJECT_VALUE = XMLQuery（'copy $ i：= $ p modify <span class="bold">delete nodes</span> $ i / PurchaseOrder / LineItems / LineItem [@ ItemNumber =“222”]返回$ i'PASSING OBJECT_VALUE为“p”返回内容）XMLExists（'$ p / PurchaseOrder [Reference =“AMCEWEN-20021009123336171PDT”]'PASSING OBJECT_VALUE AS“p”）; SELECT XMLQuery（'$ p / PurchaseOrder / LineItems / LineItem [@ ItemNumber = 222]'PASSING po。OBJECT_VALUE作为“p”返回内容）来自purchaseorder po WHERE XMLExists（'$ p / PurchaseOrder [Reference =“AMCEWEN-20021009123336171PDT”]'PASSING po。OBJECT_VALUE AS“p”）; XMLQUERY（'$ P / PURCHASEORDER / LINEITEMS / LINEITEM [@ ITEMNUMBER = 222]'PASSINGPO ------------------------------- -----------------------------------------选择1行。
</code></pre></div>
                     <!-- class="example" -->
                  </div>
                  <div>
                     <div class="familylinks">
                        <div class="parentlink">
                           <p><strong>父主题：</strong> <a href="query-and-update-XML.html#GUID-6AE99020-C3C8-44EB-8E54-40188E1103F2" title="有几种方法可以使用Oracle XML DB功能更新XML数据，无论是瞬态还是存储在数据库表中。">更新XML数据</a></p>
                        </div>
                     </div>
                  </div>
                  
               </div><a id="ADXDB4288"></a><a id="ADXDB4287"></a><div class="props_rev_3"><a id="GUID-59A36DE7-3BB3-4F42-8441-0D0489097A92" name="GUID-59A36DE7-3BB3-4F42-8441-0D0489097A92"></a><h4 id="ADXDB-GUID-59A36DE7-3BB3-4F42-8441-0D0489097A92" class="sect4"><span class="enumeration_section">5.6.5</span>创建修改后的XML数据的XML视图</h4>
                  <div>
                     <p>您可以使用XQuery Update创建XML数据的新视图。</p>
                     <div class="section">
                        <p><a href="query-and-update-XML.html#GUID-59A36DE7-3BB3-4F42-8441-0D0489097A92__CHDFBHBF">例5-40</a>创建了table <code class="codeph">purchaseorder</code>的视图。
                        </p>
                     </div>
                     <!-- class="section" -->
                     <div class="example" id="GUID-59A36DE7-3BB3-4F42-8441-0D0489097A92__CHDFBHBF">
                        <p class="titleinexample">示例5-40使用更新的XML数据创建视图</p><pre class="pre codeblock"><code>创建或替换视图purchaseorder_summary OF XMLType AS SELECT XMLQuery（'copy $ i：= $ p1 modify（（$ i in $ i / PurchaseOrder / Actions返回节点$ j的替换值与<span class="bold">（）</span> ），（$ $ in $ i / PurchaseOrder / ShippingInstructions返回节点$ j的替换值<span class="bold">（）</span> ），（对于$ i中的$ j / PurchaseOrder / LineItems返回节点$ j的替换值与<span class="bold">（）</span> ））返回$ i'PASSING OBJECT_VALUE AS“p1”退货内容来自purchaseorder p; SELECT OBJECT_VALUE FROM purchaseorder_summary WHERE XMLExists（'$ p / PurchaseOrder [Reference =“DAUSTIN-20021009123335811PDT”]'PASSING OBJECT_VALUE AS“p”）; OBJECT_VALUE ------------------------------------------------- -------------------------- &lt;PurchaseOrder xmlns：xsi =“http://www.w3.org/2001/XMLSchema-instance”xsi ：noNamespaceSchemaLocation =“http：// localhost：8080 / source / schemas / poSource / xsd / purchaseOrder.xsd”&gt; &lt;参考&gt; DAUSTIN-20021009123335811PDT &lt;/ Reference&gt; <span class="bold">&lt;Actions /&gt;</span> &lt;Reject /&gt; &lt;Requestor&gt; David L. Austin &lt;/ Requestor&gt; &lt;User&gt; DAUSTIN &lt;/ User&gt; &lt;CostCenter&gt; S30 &lt;/ CostCenter&gt; <span class="bold">&lt;ShippingInstructions /&gt;</span> &lt;SpecialInstructions&gt; Courier &lt;/ SpecialInstructions&gt; <span class="bold">&lt;LineItems /&gt;</span> &lt;/ PurchaseOrder&gt;</code></pre></div>
                     <!-- class="example" -->
                  </div>
                  <div>
                     <div class="familylinks">
                        <div class="parentlink">
                           <p><strong>父主题：</strong> <a href="query-and-update-XML.html#GUID-6AE99020-C3C8-44EB-8E54-40188E1103F2" title="有几种方法可以使用Oracle XML DB功能更新XML数据，无论是瞬态还是存储在数据库表中。">更新XML数据</a></p>
                        </div>
                     </div>
                  </div>
                  
               </div>
            </div><a id="ADXDB5142"></a><div class="props_rev_3"><a id="GUID-F72DC7CD-40A9-4F07-9350-B80D2AD1F4D0" name="GUID-F72DC7CD-40A9-4F07-9350-B80D2AD1F4D0"></a><h3 id="ADXDB-GUID-F72DC7CD-40A9-4F07-9350-B80D2AD1F4D0" class="sect3"><span class="enumeration_section">5.7</span> XQuery的性能调优</h3>
               <div>
                  <p>涉及XQuery表达式的SQL查询通常可以通过一种或多种方式自动重写（优化）。此优化称为<strong class="term">XML查询重写</strong>或优化。发生这种情况时，实际上，XQuery表达式直接针对XML文档进行评估，而无需在内存中构建DOM。
                  </p>
                  <p>XPath表达式是XQuery表达式的适当子集。<strong class="term">XPath重写</strong>是XML查询重写的一个子集，涉及重写涉及XPath表达式的查询。
                  </p>
                  <p>XPath重写包括以下所有内容：</p>
                  <ul style="list-style-type:disc">
                     <li>
                        <p>存储为二进制XML的<code class="codeph">XMLType</code>数据的单遍流式传输 - 在一次数据扫描中评估一组XPath表达式。
                        </p>
                     </li>
                     <li>
                        <p><code class="codeph">XMLIndex</code>优化 - 使用XPath表达式的SQL语句被重写为等效的SQL语句，该语句不使用它，而是引用关系<code class="codeph">XMLIndex</code>表。重写的SQL语句还可以使用基础<code class="codeph">XMLIndex</code>表上的任何B树索引。
                        </p>
                     </li>
                     <li>
                        <p>对象关系和<code class="codeph">XMLType</code>视图存储的<code class="codeph">XMLType</code>数据的优化 - 使用XPath表达式的SQL语句被重写为不使用它但是引用<code class="codeph">XMLType</code>数据下面的对象关系或关系数据结构的等效SQL语句。重写的SQL语句还可以使用底层数据结构上的任何B树索引。这可以针对查询和更新操作进行。
                        </p>
                     </li>
                  </ul>
                  <p>正如查询调优可以提高SQL性能一样，它可以提高XQuery的性能。您可以通过选择适当的XML存储模型和索引来调整XQuery性能。</p>
                  <p>与数据库查询一样，您可以通过检查查询的执行计划来确定是否需要调优。如果计划不是最佳，请参阅以下文档以获取特定的调整信息：</p>
                  <ul style="list-style-type:disc">
                     <li>
                        <p>对于对象关系存储： <a href="XPath-rewrite-for-object-relational-storage.html#GUID-35551023-CCAC-477B-8BBF-CD0E0B44C962" title="For XMLType data stored object-relationally, queries involving XPath expression arguments to various SQL functions can often be automatically rewritten to queries against the underlying SQL tables, which are highly optimized.">用于对象</a>关系存储的<a href="XPath-rewrite-for-object-relational-storage.html#GUID-35551023-CCAC-477B-8BBF-CD0E0B44C962" title="对于以对象方式存储的XMLType数据，涉及各种SQL函数的XPath表达式参数的查询通常可以自动重写为针对高度优化的基础SQL表的查询。">XPath重写</a></p>
                     </li>
                     <li>
                        <p>对于二进制XML存储： <a href="indexes-for-XMLType-data.html#GUID-FE16BE28-035C-49EE-9683-6ED37876C3FC" title="您可以在XML数据上创建索引，专注于经常查询的特定部分，从而提高性能。您可以通过多种方式索引XMLType数据，无论是基于XML模式还是非基于模式，无论您使用何种XMLType存储模型。">XMLType数据的索引</a></p>
                     </li>
                  </ul>
                  <p>此外，请注意以下表达式的处理成本很高，因此在处理大量数据时可能会增加性能开销：</p>
                  <ul style="list-style-type:disc">
                     <li>
                        <p>使用以下轴的XQuery表达式（改为使用forward和descendent）：</p>
                        <ul style="list-style-type:disc">
                           <li>
                              <p><code class="codeph">祖先</code></p>
                           </li>
                           <li>
                              <p><code class="codeph">祖先或自身</code></p>
                           </li>
                           <li>
                              <p><code class="codeph">后代或自身</code></p>
                           </li>
                           <li>
                              <p><code class="codeph">以下</code></p>
                           </li>
                           <li>
                              <p><code class="codeph">以下同胞</code></p>
                           </li>
                           <li>
                              <p><code class="codeph">命名空间</code></p>
                           </li>
                           <li>
                              <p><code class="codeph">亲</code></p>
                           </li>
                           <li>
                              <p><code class="codeph">前</code></p>
                           </li>
                           <li>
                              <p><code class="codeph">前同辈</code></p>
                           </li>
                        </ul>
                     </li>
                     <li>
                        <p>涉及节点标识的XQuery表达式（例如，使用顺序比较运算符<code class="codeph">&lt;&lt;</code>和<code class="codeph">&gt;&gt;</code> ）</p>
                     </li>
                  </ul>
                  <p>本节中的主题介绍了<a href="xquery-and-XML-DB.html#GUID-4F83A835-C94B-4D62-999B-111AB5E8A8F1" title="XQuery语言是您与Oracle XML DB中的XML数据交互的主要方式之一。对该语言的支持包括SQL * Plus commandXQUERY和SQL / XML函数XMLQuery，XMLTable，XMLExists和XMLCast。">XQuery和Oracle XML DB中</a>显示的一些示例的执行计划，以指示它们的执行方式。
                  </p>
               </div>
               <div>
                  <ul class="ullinks">
                     <li class="ulchildlink"><a href="query-and-update-XML.html#GUID-A77387EF-BDEF-4013-9E24-BDEA2F9D08FE">基于规则和基于成本的XQuery优化</a><br>对于使用XQuery表达式的查询，可能存在几种竞争优化可能性，具体取决于各种因素，例如<code class="codeph">XMLType</code>存储模型和使用的索引。
                     </li>
                     <li class="ulchildlink"><a href="query-and-update-XML.html#GUID-34E9F91A-1213-4142-B06F-91B11FD189B1">关系数据的XQuery优化</a><br>使用SQL / XML函数可以优化<code class="codeph">XMLQuery</code>和<code class="codeph">XMLTable</code>不是关系数据。包括使用XQuery表达式的示例，这些表达式使用<code class="codeph">fn:collection</code>和URI scheme <code class="codeph">oradb</code>来动态创建动态创建的XML数据。
                     </li>
                     <li class="ulchildlink"><a href="query-and-update-XML.html#GUID-B34F476B-5961-4C4B-9076-454C79D7B583">基于XML模式的XMLType数据的XQuery优化</a><br>使用SQL / XML函数可以优化<code class="codeph">XMLQuery</code>和<code class="codeph">XMLTable</code>基于XML Schema的数据。包含的示例使用XQuery表达式，这些表达式以对象关系存储的基于XML模式的<code class="codeph">XMLType</code>表为目标。
                     </li>
                     <li class="ulchildlink"><a href="query-and-update-XML.html#GUID-F6E94E06-C4A3-4956-868C-E33BD34D3116">XQuery优化的诊断：XMLOptimizationCheck</a><br>您可以检查SQL代码的执行计划，以确定是否发生XQuery优化或计划是否是次优的。
                     </li>
                     <li class="ulchildlink"><a href="query-and-update-XML.html#GUID-FC694A3C-A80C-4D44-BA9B-6C0596991273">fn：doc和fn：存储库数据集合的性能改进</a><br>通过将它们链接到包含要查询的存储库数据的实际数据库表，可以提高<code class="codeph">fn:doc</code>和<code class="codeph">fn:collection</code>查询在Oracle XML DB存储库上的性能。
                     </li>
                  </ul>
                  <div class="relinfo">
                     <p><strong>相关话题</strong></p>
                     <ul>
                        <li><a href="xquery-and-XML-DB.html#GUID-2D63B8EA-DC49-409F-B5DF-34A679AB2A99" title="Oracle XML DB对XQuery语言的支持包括SQL支持和对XQuery函数和运算符的支持。">Oracle XML DB支持XQuery</a></li>
                     </ul>
                  </div>
                  <div class="familylinks">
                     <div class="parentlink">
                        <p><strong>父主题：</strong> <a href="query-and-update-XML.html#GUID-01C75289-804F-4BAA-AE7C-DFA73198581E" title="应用程序有许多方法可以查询和更新Oracle数据库中的XML数据，包括基于XML模式和非基于模式的数据。">XML数据的查询和更新</a></p>
                     </div>
                  </div>
               </div>
               <a id="ADXDB5143"></a><div class="props_rev_3"><a id="GUID-A77387EF-BDEF-4013-9E24-BDEA2F9D08FE" name="GUID-A77387EF-BDEF-4013-9E24-BDEA2F9D08FE"></a><h4 id="ADXDB-GUID-A77387EF-BDEF-4013-9E24-BDEA2F9D08FE" class="sect4"><span class="enumeration_section">5.7.1</span>基于规则和基于成本的XQuery优化</h4>
                  <div>
                     <p>对于使用XQuery表达式的查询，可能存在几种竞争优化可能性，具体取决于各种因素，例如<code class="codeph">XMLType</code>存储模型和使用的索引。
                     </p>
                     <p>默认情况下，Oracle XML DB遵循一组优先级规则，以确定应对任何给定查询和上下文使用哪种可能的优化。此行为称为<strong class="term">基于规则的</strong> XML查询重写。
                     </p>
                     <p>或者，Oracle XML DB可以使用<strong class="term">基于成本的</strong> XML查询重写。在此模式下，Oracle XML DB会估计给定查询的各种XML优化可能性的性能，并选择预期最高性能的组合。
                     </p>
                     <p>您可以使用优化程序提示<code class="codeph">/*+ COST_XML_QUERY_REWRITE */</code>对给定的SQL语句执行基于成本的优化。
                     </p>
                  </div>
                  <div>
                     <div class="familylinks">
                        <div class="parentlink">
                           <p><strong>父主题：</strong> <a href="query-and-update-XML.html#GUID-F72DC7CD-40A9-4F07-9350-B80D2AD1F4D0" title="涉及XQuery表达式的SQL查询通常可以通过一种或多种方式自动重写（优化）。此优化称为XML查询重写或优化。发生这种情况时，实际上，XQuery表达式直接针对XML文档进行评估，而无需在内存中构建DOM。">XQuery的性能调优</a></p>
                        </div>
                     </div>
                  </div>
                  
               </div><a id="ADXDB5145"></a><a id="ADXDB5146"></a><a id="ADXDB5144"></a><div class="props_rev_3"><a id="GUID-34E9F91A-1213-4142-B06F-91B11FD189B1" name="GUID-34E9F91A-1213-4142-B06F-91B11FD189B1"></a><h4 id="ADXDB-GUID-34E9F91A-1213-4142-B06F-91B11FD189B1" class="sect4"><span class="enumeration_section">5.7.2</span>关系数据的XQuery优化</h4>
                  <div>
                     <p>使用SQL / XML函数可以优化<code class="codeph">XMLQuery</code>和<code class="codeph">XMLTable</code>不是关系数据。包括使用XQuery表达式的示例，这些表达式使用<code class="codeph">fn:collection</code>和URI scheme <code class="codeph">oradb</code>来动态创建动态创建的XML数据。
                     </p>
                     <p><a href="query-and-update-XML.html#GUID-34E9F91A-1213-4142-B06F-91B11FD189B1__CBAIJAAD">例5-41</a>显示了<code class="codeph">XMLQuery</code>对作为XML访问的关系数据的优化。 <a href="query-and-update-XML.html#GUID-34E9F91A-1213-4142-B06F-91B11FD189B1__CBAJFIBF">例5-42</a>显示了在相同上下文中<code class="codeph">XMLTable</code>的优化。
                     </p>
                     <div class="example" id="GUID-34E9F91A-1213-4142-B06F-91B11FD189B1__CBAIJAAD">
                        <p class="titleinexample">例5-41关于关系数据的XMLQuery优化</p>
                        <p>这里再次是<a href="query-and-update-XML.html#GUID-E62C830B-F3FB-4381-9F74-BF5F2C417CD0__CBAJHHJD">示例5-6</a>的查询及其执行计划，其显示查询已被优化。
                        </p><pre class="oac_no_warn" dir="ltr">SELECT XMLQuery（'for fn：collection中的$ i（“oradb：/ OE / WAREHOUSES”）/ ROW返回&lt;Warehouse id =“{$ i / WAREHOUSE_ID}”&gt; &lt;Location&gt; {for $ j in fn：collection（“ oradb：/ HR / LOCATIONS“）/ ROW其中$ j / LOCATION_ID eq $ i / LOCATION_ID返回（$ j / STREET_ADDRESS，$ j / CITY，$ j / STATE_PROVINCE）} &lt;/ Location&gt; &lt;/ Warehouse&gt;'RETURNING CONTENT）来自双重;</pre><pre class="oac_no_warn" dir="ltr">PLAN_TABLE_OUTPUT ------------------------------------------------- -------------------------------------------计划哈希值：3341889589  - -------------------------------------------------- --------------------------------------- | Id |操作|名称|行|字节|成本（％CPU）|时间| -------------------------------------------------- ----------------------------------------- | 0 |选择声明| | 1 | | 2（0）| 00:00:01 | | 1 | SORT AGGREGATE | | 1 | 41 | | | | 2 | <span class="bold">按INDEX ROWID表的访问权限</span> | <span class="bold">地点</span> | 1 | 41 | 1（0）| 00:00:01 | | * 3 | <span class="bold">INDEX UNIQUE SCAN</span> | <span class="bold">LOC_ID_PK</span> | 1 | | 0（0）| 00:00:01 | | 4 | SORT AGGREGATE | | 1 | 6 | | | | 5 |表访问完全| WAREHOUSES | 9 | 54 | 2（0）| 00:00:01 | | 6 |快速双| | 1 | | 2（0）| 00:00:01 | -------------------------------------------------- -----------------------------------------谓词信息（由操作ID标识）： -------------------------------------------------- -  3  - 访问（“LOCATION_ID”=：B1）选择了18行。</pre></div>
                     <!-- class="example" -->
                     <div class="example" id="GUID-34E9F91A-1213-4142-B06F-91B11FD189B1__CBAJFIBF">
                        <p class="titleinexample">例5-42关于关系数据的XMLTable优化</p>
                        <p>这里再次是<a href="query-and-update-XML.html#GUID-E62C830B-F3FB-4381-9F74-BF5F2C417CD0__CBAJEGFH">示例5-7</a>的查询及其执行计划，其显示查询已被优化。
                        </p><pre class="oac_no_warn" dir="ltr">SELECT * FROM XMLTable（'for fn：collection中的$ i（“oradb：/ OE / WAREHOUSES”）/ ROW返回&lt;Warehouse id =“{$ i / WAREHOUSE_ID}”&gt; &lt;Location&gt; {for f in fn：collection （“oradb：/ HR / LOCATIONS”）/ ROW，其中$ j / LOCATION_ID eq $ i / LOCATION_ID返回（$ j / STREET_ADDRESS，$ j / CITY，$ j / STATE_PROVINCE）} &lt;/ Location&gt; &lt;/ Warehouse&gt;'） ;</pre><pre class="oac_no_warn" dir="ltr">PLAN_TABLE_OUTPUT ------------------------------------------------- ------------------------------------------计划哈希值：1021775546 --- -------------------------------------------------- -------------------------------------- | Id |操作|名称|行|字节|成本（％CPU）|时间| -------------------------------------------------- ----------------------------------------- | 0 |选择声明| | 9 | 54 | 2（0）| 00:00:01 | | 1 | SORT AGGREGATE | | 1 | 41 | | | | 2 | <span class="bold">按INDEX ROWID表的访问权限</span> | <span class="bold">地点</span> | 1 | 41 | 1（0）| 00:00:01 | | * 3 | <span class="bold">INDEX UNIQUE SCAN</span> | <span class="bold">LOC_ID_PK</span> | 1 | | 0（0）| 00:00:01 | | 4 |表访问完全| WAREHOUSES | 9 | 54 | 2（0）| 00:00:01 | -------------------------------------------------- -----------------------------------------谓词信息（由操作ID标识）： -------------------------------------------------- -  3  - 访问（“LOCATION_ID”=：B1）选择16行。</pre></div>
                     <!-- class="example" -->
                  </div>
                  <div>
                     <div class="familylinks">
                        <div class="parentlink">
                           <p><strong>父主题：</strong> <a href="query-and-update-XML.html#GUID-F72DC7CD-40A9-4F07-9350-B80D2AD1F4D0" title="涉及XQuery表达式的SQL查询通常可以通过一种或多种方式自动重写（优化）。此优化称为XML查询重写或优化。发生这种情况时，实际上，XQuery表达式直接针对XML文档进行评估，而无需在内存中构建DOM。">XQuery的性能调优</a></p>
                        </div>
                     </div>
                  </div>
                  
               </div><a id="ADXDB5148"></a><a id="ADXDB5149"></a><a id="ADXDB5147"></a><div class="props_rev_3"><a id="GUID-B34F476B-5961-4C4B-9076-454C79D7B583" name="GUID-B34F476B-5961-4C4B-9076-454C79D7B583"></a><h4 id="ADXDB-GUID-B34F476B-5961-4C4B-9076-454C79D7B583" class="sect4"><span class="enumeration_section">5.7.3</span>基于XML模式的XMLType数据的XQuery优化</h4>
                  <div>
                     <p>使用SQL / XML函数可以优化<code class="codeph">XMLQuery</code>和<code class="codeph">XMLTable</code>基于XML Schema的数据。包含的示例使用XQuery表达式，这些表达式以对象关系存储的基于XML模式的<code class="codeph">XMLType</code>表为目标。
                     </p>
                     <p><a href="query-and-update-XML.html#GUID-B34F476B-5961-4C4B-9076-454C79D7B583__CBAFEHBC">例5-43</a>显示了基于XML模式的<code class="codeph">XMLType</code>表的<code class="codeph">XMLQuery</code>优化。<a href="query-and-update-XML.html#GUID-B34F476B-5961-4C4B-9076-454C79D7B583__CBABFDJG">例5-44</a>显示了在同一上下文中<code class="codeph">XMLTable</code>的优化。
                     </p>
                     <div class="example" id="GUID-B34F476B-5961-4C4B-9076-454C79D7B583__CBAFEHBC">
                        <p class="titleinexample">例5-43使用基于模式的XMLType数据优化XMLQuery</p>
                        <p>这里再次是<a href="query-and-update-XML.html#GUID-1165391D-BA6A-460F-BA44-66AA4A1F6595__CBAJIBCD">示例5-10</a>的查询及其执行计划，其显示查询已被优化。
                        </p><pre class="oac_no_warn" dir="ltr">SELECT XMLQuery（'for $ i in / PurchaseOrder，其中$ i / CostCenter eq“ <span class="bold">A10</span> ”和$ i / User eq“ <span class="bold">SMCCAIN</span> ”返回&lt;A10po pono =“{$ i / Reference}”/&gt;'PASSING OBJECT_VALUE RETURNING CONTENT）FROM采购订单;</pre><pre class="oac_no_warn" dir="ltr">PLAN_TABLE_OUTPUT ------------------------------------------------- ------------------------------------计划哈希值：3611789148 --------- -------------------------------------------------- -------------------------- | Id |操作|名称|行|字节|成本（％CPU）|时间| -------------------------------------------------- ----------------------------------- | 0 |选择声明| | 1 | 530 | 5（0）| 00:00:01 | | 1 | SORT AGGREGATE | | 1 | | | | | * 2 |过滤器| | | | | | | 3 |快速双| | 1 | | 2（0）| 00:00:01 | | * 4 |表访问完全|购买| 1 | 530 | 5（0）| 00:00:01 | -------------------------------------------------- -----------------------------------谓词信息（由操作ID标识）：------ --------------------------------------------- 2  -  filter（： B1 =' <span class="bold">SMCCAIN</span> '并且：B2 =' <span class="bold">A10</span> '）4  - 过滤器（SYS_CHECKACL（“ACLOID”，“OWNERID”，xmltype（'&lt;privilege xmlns =“http://xmlns.oracle.com/xdb/acl.xsd “xmlns：xsi =”http://www.w3.org/2001/XMLSchema-instance“xsi：schemaLocation =”http://xmlns.oracle.com/xdb/acl.xsd http://xmlns.oracle。 com / xdb / acl.xsd DAV：http：//xmlns.oracle.com/xdb/dav.xsd“&gt; &lt;read-properties /&gt; &lt;read-contents /&gt; &lt;/ privilege&gt;'））= 1）22行选择。</pre></div>
                     <!-- class="example" -->
                     <div class="example" id="GUID-B34F476B-5961-4C4B-9076-454C79D7B583__CBABFDJG">
                        <p class="titleinexample">例5-44使用基于模式的XMLType数据优化XMLTable</p>
                        <p>这里再次是<a href="query-and-update-XML.html#GUID-1165391D-BA6A-460F-BA44-66AA4A1F6595__CBACIIDC">示例5-14</a>的查询及其执行计划，该计划显示查询已经过优化。XQuery结果永远不会实现。相反，XML集合元素<code class="codeph">LineItem</code>的基础存储列用于生成整个结果集。
                        </p><pre class="oac_no_warn" dir="ltr">SELECT lines.lineitem，lines.description，lines.partid，lines.unitprice，lines.quantity FROM purchaseorder，XMLTable（'for $ i in / PurchaseOrder / LineItems / LineItem，其中$ i / @ ItemNumber&gt; = 8和$ i / Part / @ UnitPrice&gt; 50和$ i / Part / @ Quantity&gt; 2返回$ i'PASSING OBJECT_VALUE COLUMNS lineitem NUMBER PATH' @ ItemNumber'，description VARCHAR2（30）PATH'Description'，partid NUMBER PATH'Part / @ Id'， unitprice NUMBER PATH'Part / @ UnitPrice'，数量NUMBER PATH'Part / @ Quantity'）行;</pre><pre class="oac_no_warn" dir="ltr">-------------------------------------------------- --------------------------------------------- | Id |操作|名称|行|字节|成本（％CPU）|时间| -------------------------------------------------- --------------------------------------------- | 0 |选择声明| | 4 | 384 | 7（0）| 00:00:01 | | 1 | NESTED LOOPS | | | | | | | 2 | NESTED LOOPS | | 4 | 384 | 7（0）| 00:00:01 | | * 3 | <span class="bold">表访问完全</span> |购买| 1 | 37 | 5（0）| 00:00:01 | | * 4 | <span class="bold">INDEX RANGE SCAN</span> | SYS_C005478 | 17 | | 1（0）| 00:00:01 | | * 5 |按INDEX ROWID表的访问权限| LINEITEM_TABLE | 3 | 177 | 2（0）| 00:00:01 | -------------------------------------------------- ---------------------------------------------谓词信息（由操作ID）：---------------------------------------------- ----- 3  - 过滤器（SYS_CHECKACL（“ACLOID”，“OWNERID”，xmltype（'&lt;privilege xmlns =“http://xmlns.oracle.com/xdb/acl.xsd”xmlns：xsi =“http： //www.w3.org/2001/XMLSchema-instance“xsi：schemaLocation =”http://xmlns.oracle.com/xdb/acl.xsd http://xmlns.oracle.com/xdb/acl.xsd DAV ：http：//xmlns.oracle.com/xdb/dav.xsd“&gt; &lt;read-prop erties /&gt; &lt;read-contents /&gt; &lt;/ privilege&gt;'））= 1）4  -  access（”NESTED_TABLE_ID“=” PURCHASEORDER“。”SYS_NC0003400035 $“）5  - 过滤器（”SYS_NC00013 $“&gt; 50 AND”SYS_NC00012 $“&gt; 2和”ITEMNUMBER“&gt; = 8 AND”SYS_NC_TYPEID $“非NULL）选择25行。</pre><p>此示例完全遍历表<code class="codeph">oe.purchaseorder</code> 。将为每个采购订单文档评估<code class="codeph">XMLTable</code>表达式。使<code class="codeph">XMLTable</code>表达式（而不是<code class="codeph">purchaseorder</code>表）驱动SQL查询执行更有效。
                        </p>
                        <p>虽然XQuery表达式已经重写为关系表达式，但您可以通过在底层关系数据上创建<span class="italic">索引</span>来改进此优化 - 您可以像优化纯SQL查询一样优化此查询。Oracle XML DB中的XQuery始终如此：您使用的优化技术与您在SQL中使用的优化技术相同。</p>
                        <p>collection元素<code class="codeph">LineItem</code>的<code class="codeph">UnitPrice</code>属性是一个合适的索引目标。管理XML模式指定有序集合表（OCT）用于存储<code class="codeph">LineItem</code>元素。
                        </p>
                        <p>但是，当XML采购订单文档被分解为基于XML模式的数据时，Oracle XML DB会生成此OCT的名称。您可以手动创建具有相同属性和相同数据但具有用户友好名称的OCT的新<code class="codeph">purchaseorder</code>订单表（在不同的数据库模式中），而不是使用示例数据库模式<code class="codeph">HR</code>表<code class="codeph">purchaseorder</code>订单。
                        </p>
                        <p>假设已完成此操作，以下语句将创建适当的索引：</p><pre class="oac_no_warn" dir="ltr">CREATE INDEX unitprice_index ON lineitem_table（“PART”。“UNITPRICE”）;</pre><p>在定义了此索引的情况下， <a href="query-and-update-XML.html#GUID-1165391D-BA6A-460F-BA44-66AA4A1F6595__CBACIIDC">示例5-14</a>的查询将生成以下执行计划，该计划显示<code class="codeph">XMLTable</code>表达式已驱动整体评估。
                        </p><pre class="oac_no_warn" dir="ltr">PLAN_TABLE_OUTPUT ------------------------------------------------- ---------------------------------------计划哈希值：1578014525 ------ -------------------------------------------------- -------------------------------- | Id |操作|名称|行|字节|成本（％CPU）|时间| -------------------------------------------------- -------------------------------------- | 0 |选择声明| | 3 | 624 | 8（0）| 00:00:01 | | 1 | NESTED LOOPS | | 3 | 624 | 8（0）| 00:00:01 | | * 2 | <span class="bold">INDEX UNIQUE SCAN</span> | SYS_IOT_TOP_49323 | 3 | 564 | 5（0）| 00:00:01 | | * 3 | <span class="bold">INDEX RANGE SCAN</span> | <span class="bold">UNITPRICE_INDEX</span> | 20 | | 2（0）| 00:00:01 | | * 4 | <span class="bold">INDEX UNIQUE SCAN</span> | SYS_C004411 | 1 | | 0（0）| 00:00:01 | -------------------------------------------------- --------------------------------------谓词信息（由操作ID识别）：--- ------------------------------------------------ 2  - 访问（“SYS_NC00013 $”&gt; 50）过滤器（“ITEMNUMBER”&gt; = 8 AND“SYS_NC00012 $”&gt; 2）3  - 访问（“SYS_NC00013 $”&gt; 50）4  - 访问（“NESTED_TABLE_ID”=“PURCHASEORDER”。“SYS_NC0003400035 $“）注意-----  - 用于此语句的动态采样选择了23行。</pre></div>
                     <!-- class="example" -->
                  </div>
                  <div>
                     <div class="familylinks">
                        <div class="parentlink">
                           <p><strong>父主题：</strong> <a href="query-and-update-XML.html#GUID-F72DC7CD-40A9-4F07-9350-B80D2AD1F4D0" title="涉及XQuery表达式的SQL查询通常可以通过一种或多种方式自动重写（优化）。此优化称为XML查询重写或优化。发生这种情况时，实际上，XQuery表达式直接针对XML文档进行评估，而无需在内存中构建DOM。">XQuery的性能调优</a></p>
                        </div>
                     </div>
                  </div>
                  
               </div><a id="ADXDB4583"></a><div class="props_rev_3"><a id="GUID-F6E94E06-C4A3-4956-868C-E33BD34D3116" name="GUID-F6E94E06-C4A3-4956-868C-E33BD34D3116"></a><h4 id="ADXDB-GUID-F6E94E06-C4A3-4956-868C-E33BD34D3116" class="sect4"><span class="enumeration_section">5.7.4</span> XQuery优化的诊断：XMLOptimizationCheck</h4>
                  <div>
                     <p>您可以检查SQL代码的执行计划，以确定是否发生XQuery优化或计划是否是次优的。</p>
                     <p>在后一种情况下，在计划之后立即出现如下注释：</p><pre class="pre codeblock"><code>检测到未优化的XML构造（启用XMLOptimizationCheck以获取更多信息）</code></pre><p>您还可以将执行计划输出与您在使用优化程序提示<code class="codeph">NO_XML_QUERY_REWRITE</code>后看到的计划输出进行<code class="codeph">NO_XML_QUERY_REWRITE</code> ，这将关闭XQuery优化。
                     </p>
                     <p>此外，您可以将SQL * Plus <code class="codeph">SET</code>命令与系统变量<code class="codeph">XMLOptimizationCheck</code>以打开SQL的<strong class="term">XML可诊断性模式</strong> ：</p><pre class="pre codeblock"><code>SET XMLOptimizationCheck ON</code></pre><p>启用此模式后，将自动检查执行计划以进行XQuery优化，如果计划不是最佳，则会引发错误，并将诊断信息写入跟踪文件，指示不重写哪些运算符。</p>
                     <p><code class="codeph">XMLOptimizationCheck</code>的主要优点是它会立即引起您的注意。出于这个原因，您可能会发现最好始终打开它。然后，如果由于某种原因应用程序更改或数据库更改阻止重写SQL操作，则会停止执行而不会在不知道原因的情况下对性能产生负面影响。
                     </p>
                     <div class="infoboxnote" id="GUID-F6E94E06-C4A3-4956-868C-E33BD34D3116__GUID-F2D48C04-512C-4372-91CB-7E860A4FF04B">
                        <p class="notep1">注意：</p>
                        <ul style="list-style-type:disc">
                           <li>
                              <p>在Oracle Database 11g第2版（11.2.0.2）之前， <code class="codeph">XMLOptimizationCheck</code>不可用。较旧版本的用户直接操作事件19201以获取XQuery优化信息。
                              </p>
                           </li>
                           <li>
                              <p>OCI用户可以使用<code class="codeph">OCIStmtExecute</code>或事件19201。只有该事件可供Java用户使用。
                              </p>
                           </li>
                        </ul>
                     </div>
                  </div>
                  <div>
                     <div class="infoboxnotealso" id="GUID-F6E94E06-C4A3-4956-868C-E33BD34D3116__GUID-FF1CE6A3-1D65-4A09-81DD-DF6C24754779">
                        <p class="notep1">也可以看看：</p>
                        <p><a href="indexes-for-XMLType-data.html#GUID-572DB598-0A31-4143-889B-98D883211FC6" title="您可以使用优化程序提示关闭XMLIndex的使用：/ * + NO_XML_QUERY_REWRITE * /或优化程序提示/ * + NO_XMLINDEX_REWRITE * /。">关闭使用XMLIndex</a>获取有关优化程序提示<code class="codeph">NO_XML_QUERY_REWRITE</code></p>
                     </div>
                     <div class="familylinks">
                        <div class="parentlink">
                           <p><strong>父主题：</strong> <a href="query-and-update-XML.html#GUID-F72DC7CD-40A9-4F07-9350-B80D2AD1F4D0" title="涉及XQuery表达式的SQL查询通常可以通过一种或多种方式自动重写（优化）。此优化称为XML查询重写或优化。发生这种情况时，实际上，XQuery表达式直接针对XML文档进行评估，而无需在内存中构建DOM。">XQuery的性能调优</a></p>
                        </div>
                     </div>
                  </div>
                  
               </div><a id="ADXDB5809"></a><div class="props_rev_3"><a id="GUID-FC694A3C-A80C-4D44-BA9B-6C0596991273" name="GUID-FC694A3C-A80C-4D44-BA9B-6C0596991273"></a><h4 id="ADXDB-GUID-FC694A3C-A80C-4D44-BA9B-6C0596991273" class="sect4"><span class="enumeration_section">5.7.5</span> fn：doc和fn：存储库数据集合的性能改进</h4>
                  <div>
                     <p>通过将它们链接到包含要查询的存储库数据的实际数据库表，可以提高<code class="codeph">fn:doc</code>和<code class="codeph">fn:collection</code>查询在Oracle XML DB存储库上的性能。
                     </p>
                     <p>在Oracle XML DB中，您可以使用XQuery函数<code class="codeph">fn:doc</code>和<code class="codeph">fn:collection</code>来引用Oracle XML DB Repository中的文档和集合。
                     </p>
                     <p>当存储库XML数据以对象关系或二进制XML存储时，使用<code class="codeph">fn:doc</code>和<code class="codeph">fn:collection</code>查询将在功能上进行评估;也就是说，它们未经过优化以直接访问底层存储表。要提高此类查询的性能，必须将它们链接到包含要查询的存储库数据的实际数据库表。您可以通过以下任一方式执行此操作：</p>
                     <ul style="list-style-type:disc">
                        <li>
                           <p>使用保存数据的<code class="codeph">XMLType</code>表加入视图<code class="codeph">RESOURCE_VIEW</code> ，然后分别使用Oracle SQL函数<code class="codeph">equals_path</code>和<code class="codeph">under_path</code>而不是XQuery函数<code class="codeph">fn:doc</code>和<code class="codeph">fn:collection</code> 。这些SQL函数以高效的方式引用存储库资源。
                           </p>
                        </li>
                        <li>
                           <p>使用Oracle XQuery扩展表达式pragma <code class="codeph">ora:defaultTable</code> 。
                           </p>
                        </li>
                     </ul>
                     <p>两种方法都具有相同的效果。Oracle建议您使用<code class="codeph">ora:defaultTable</code> pragma，因为它允许您继续使用XQuery标准函数<code class="codeph">fn:doc</code>和<code class="codeph">fn:collection</code> ，它简化了代码。
                     </p>
                     <p>这两种方法在本节的示例中说明。</p>
                  </div>
                  <div>
                     <ul class="ullinks">
                        <li class="ulchildlink"><a href="query-and-update-XML.html#GUID-FA9E3BBC-AEB2-4F11-A721-B8C304F78DC5">使用EQUALS_PATH和UNDER_PATH而不是fn：doc和fn：collection</a><br>使用Oracle SQL函数<code class="codeph">equals_path</code>和<code class="codeph">under_path</code>而不是XQuery函数<code class="codeph">fn:doc</code>和<code class="codeph">fn:collection</code>可以提高性能。
                        </li>
                        <li class="ulchildlink"><a href="query-and-update-XML.html#GUID-749BD49D-46E2-4B15-8B9E-1097D6952047">使用Oracle XQuery Pragma ora：defaultTable</a><br>您可以使用Oracle XQuery扩展表达式pragma <code class="codeph">ora:defaultTable</code>来提高查询存储库数据的性能。
                        </li>
                     </ul>
                     <div class="familylinks">
                        <div class="parentlink">
                           <p><strong>父主题：</strong> <a href="query-and-update-XML.html#GUID-F72DC7CD-40A9-4F07-9350-B80D2AD1F4D0" title="涉及XQuery表达式的SQL查询通常可以通过一种或多种方式自动重写（优化）。此优化称为XML查询重写或优化。发生这种情况时，实际上，XQuery表达式直接针对XML文档进行评估，而无需在内存中构建DOM。">XQuery的性能调优</a></p>
                        </div>
                     </div>
                  </div>
                  <a id="ADXDB5810"></a><a id="ADXDB5811"></a><a id="ADXDB5998"></a><div class="props_rev_3"><a id="GUID-FA9E3BBC-AEB2-4F11-A721-B8C304F78DC5" name="GUID-FA9E3BBC-AEB2-4F11-A721-B8C304F78DC5"></a><h5 id="ADXDB-GUID-FA9E3BBC-AEB2-4F11-A721-B8C304F78DC5" class="sect5"><span class="enumeration_section">5.7.5.1</span>使用EQUALS_PATH和UNDER_PATH而不是fn：doc和fn：collection</h5>
                     <div>
                        <p>使用Oracle SQL函数<code class="codeph">equals_path</code>和<code class="codeph">under_path</code>而不是XQuery函数<code class="codeph">fn:doc</code>和<code class="codeph">fn:collection</code>可以提高性能。
                        </p>
                        <p>SQL函数<code class="codeph">equals_path</code>引用位于指定存储库路径的资源，SQL函数<code class="codeph">under_path</code>引用位于指定存储库路径下的资源。<a href="query-and-update-XML.html#GUID-FA9E3BBC-AEB2-4F11-A721-B8C304F78DC5__BABIDGGE">例5-45</a>和<a href="query-and-update-XML.html#GUID-FA9E3BBC-AEB2-4F11-A721-B8C304F78DC5__BABBIGDC">例5-46</a>说明了函数<code class="codeph">fn:doc</code>和<code class="codeph">equals_path</code> ;函数<code class="codeph">fn:collection</code>和<code class="codeph">under_path</code>被类似地处理。
                        </p>
                        <div class="example" id="GUID-FA9E3BBC-AEB2-4F11-A721-B8C304F78DC5__BABIDGGE">
                           <p class="titleinexample">示例5-45使用fn：doc的未优化存储库查询</p><pre class="pre codeblock"><code>SELECT XMLQuery（'let $ val：= fn：doc（“/ home / OE / PurchaseOrders / 2002 / Sep / VJONES-20021009123337583PDT.xml”）/ PurchaseOrder / LineItems / LineItem [@ItemNumber = 19] return $ val'RETURNING CONTENT ）FROM DUAL;</code></pre></div>
                        <!-- class="example" -->
                        <div class="example" id="GUID-FA9E3BBC-AEB2-4F11-A721-B8C304F78DC5__BABBIGDC">
                           <p class="titleinexample">例5-46使用EQUALS_PATH优化存储库查询</p><pre class="pre codeblock"><code>SELECT XMLQuery（'let $ val：= $ DOC / PurchaseOrder / LineItems / LineItem [@ItemNumber = 19]返回$ val'PASSING OBJECT_VALUE作为“DOC”返回内容）来自RESOURCE_VIEW rv，purchaseorder p WHERE ref（p）= XMLCast（ XMLQuery（'declare default element namespace“http://xmlns.oracle.com/xdb/XDBResource.xsd”;（：:) fn：data <a id="fn_1" name="fn_1" href="#fn_1" xquery="" function="" fn:data="" is="" used="" here="" to="" atomize="" its="" argument,="" in="" this="" case="" returning="" the="" xmlref="" node's="" typed="" atomic="" value=")" ="" onclick="footdisplay(1, "><sup>Foot 1</sup></a> （/ Resource / XMLRef）'PASSING rv.RES RETURNING CONTENT）AS REF XMLType）AND equals_path（rv.RES，'/ home / OE /PurchaseOrders/2002 / Scan / VJONES-20021009123337583PDT.xml'）= 1;</code></pre></div>
                        <!-- class="example" -->
                     </div>
                     <div>
                        <div class="familylinks">
                           <div class="parentlink">
                              <p><strong>父主题：</strong> <a href="query-and-update-XML.html#GUID-FC694A3C-A80C-4D44-BA9B-6C0596991273" title="通过将它们链接到包含要查询的存储库数据的实际数据库表，可以提高fn：doc和fn：集合查询在Oracle XML DB存储库中的性能。">对存储库数据的fn：doc和fn：collection的性能改进</a></p>
                           </div>
                        </div>
                     </div>
                     
                  </div><a id="ADXDB6000"></a><a id="ADXDB5999"></a><div class="props_rev_3"><a id="GUID-749BD49D-46E2-4B15-8B9E-1097D6952047" name="GUID-749BD49D-46E2-4B15-8B9E-1097D6952047"></a><h5 id="ADXDB-GUID-749BD49D-46E2-4B15-8B9E-1097D6952047" class="sect5"><span class="enumeration_section">5.7.5.2</span>使用Oracle XQuery Pragma ora：defaultTable</h5>
                     <div>
                        <p>您可以使用Oracle XQuery扩展表达式pragma <code class="codeph">ora:defaultTable</code>来提高查询存储库数据的性能。
                        </p>
                        <div class="section">
                           <p>Oracle XQuery扩展表达式pragma <code class="codeph">ora:defaultTable</code>允许您指定用于存储查询的存储库数据的默认表。重写该查询以自动加入默认表以查看<code class="codeph">RESOURCE_VIEW</code>并分别使用Oracle SQL函数<code class="codeph">equals_path</code>和<code class="codeph">under_path</code>而不是XQuery函数<code class="codeph">fn:doc</code>和<code class="codeph">fn:collection</code> 。因此，效果与手动编码查询以使用显式连接和<code class="codeph">equals_path</code>或<code class="codeph">under_path</code> 。<a href="query-and-update-XML.html#GUID-749BD49D-46E2-4B15-8B9E-1097D6952047__BABFGFEJ">例5-47</a>说明了这一点;查询将自动重写为<a href="query-and-update-XML.html#GUID-FA9E3BBC-AEB2-4F11-A721-B8C304F78DC5__BABBIGDC">示例5-46中显示的内容</a> 。
                           </p>
                           <p>为了清楚范围，Oracle建议您将pragma <code class="codeph">ora:defaultTable</code>直接应用于相关文档或集合表达式<code class="codeph">fn:doc</code>或<code class="codeph">fn:collection</code> ，而不是更大的表达式。
                           </p>
                        </div>
                        <!-- class="section" -->
                        <div class="example" id="GUID-749BD49D-46E2-4B15-8B9E-1097D6952047__BABFGFEJ">
                           <p class="titleinexample">示例5-47使用Oracle XQuery Pragma ora的存储库查询：defaultTable</p><pre class="pre codeblock"><code>SELECT XMLQuery（'for $ doc in <span class="bold">（#ora：defaultTable PURCHASEORDER＃）</span> {fn：doc（“/ home / OE / PurchaseOrders / 2002 / Sep / VJONES-20021009123337583PDT.xml”）} let $ val：= $ doc / PurchaseOrder / LineItems / LineItem [@ItemNumber = 19]返回$ val}'返回内容）来自DUAL;</code></pre></div>
                        <!-- class="example" -->
                     </div>
                     <div>
                        <div class="familylinks">
                           <div class="parentlink">
                              <p><strong>父主题：</strong> <a href="query-and-update-XML.html#GUID-FC694A3C-A80C-4D44-BA9B-6C0596991273" title="通过将它们链接到包含要查询的存储库数据的实际数据库表，可以提高fn：doc和fn：集合查询在Oracle XML DB存储库中的性能。">对存储库数据的fn：doc和fn：collection的性能改进</a></p>
                           </div>
                        </div>
                     </div>
                     
                  </div>
               </div>
            </div>
            <hr><br><p style="text-decoration:underline">脚注图例</p>脚注1：<p>XQuery函数<code class="codeph">fn:data</code>用于雾化其参数，在这种情况下返回<code class="codeph">XMLRef</code>节点的类型化原子值。
            </p><br></div>
      </article>
   </body>
</html>