<html lang="en-us" dir="ltr" xml:lang="en-us">
   <head>
      <meta http-equiv="Content-Type" content="text/html; charset=utf-8"></meta>
      <meta name="viewport" content="width=device-width, initial-scale=1"></meta>
      <meta http-equiv="X-UA-Compatible" content="IE=edge"></meta>
      <title>创建自己的DBFS存储</title>
      <meta property="og:site_name" content="Oracle Help Center"></meta>
      <meta property="og:title" content="Database SecureFiles and Large Objects Developer&#39;s Guide"></meta>
      <meta property="og:description" content=""></meta>
      <link rel="stylesheet" href="/sp_common/book-template/ohc-book-template/css/book.css"></link>
      <link rel="shortcut icon" href="/sp_common/book-template/ohc-common/img/favicon.ico"></link>
      <meta name="application-name" content="Database SecureFiles and Large Objects Developer&#39;s Guide"></meta>
      <meta name="generator" content="DITA Open Toolkit version 1.8.5 (Mode = doc)"></meta>
      <meta name="plugin" content="SP_docbuilder HTML plugin release 18.2.2"></meta>
      <link rel="alternate" href="securefiles-and-large-objects-developers-guide.pdf" title="PDF File" type="application/pdf"></link>
      <meta name="robots" content="all"></meta>
      <link rel="schema.dcterms" href="http://purl.org/dc/terms/"></link>
      <meta name="dcterms.created" content="2019-02-12T02:58:18-08:00"></meta>
      
      <meta name="dcterms.dateCopyrighted" content="1996, 2019"></meta>
      <meta name="dcterms.category" content="database"></meta>
      <meta name="dcterms.identifier" content="E96333-01"></meta>
      
      <meta name="dcterms.product" content="en/database/oracle/oracle-database/19"></meta>
      
      <link rel="prev" href="DBFS-content-API.html" title="Previous" type="text/html"></link>
      <link rel="next" href="using-DBFS.html" title="Next" type="text/html"></link>
      <script>
        document.write('<style type="text/css">');
        document.write('body > .noscript, body > .noscript ~ * { visibility: hidden; }');
        document.write('</style>');
     </script>
      <script src="/sp_common/book-template/requirejs/require.js" data-main="/sp_common/book-template/ohc-book-template/js/book-config"></script>
      <script>
            if (window.require === undefined) {
                document.write('<script data-main="sp_common/book-template/ohc-book-template/js/book-config" src="sp_common/book-template/requirejs/require.js"><\/script>');
                document.write('<link href="sp_common/book-template/ohc-book-template/css/book.css" rel="stylesheet"/>');
            }
        </script>
      <script type="application/json" id="ssot-metadata">{"primary":{"category":{"short_name":"database","element_name":"Database","display_in_url":true},"suite":{"short_name":"oracle","element_name":"Oracle","display_in_url":true},"product_group":{"short_name":"not-applicable","element_name":"Not applicable","display_in_url":false},"product":{"short_name":"oracle-database","element_name":"Oracle Database","display_in_url":true},"release":{"short_name":"19","element_name":"Release 19","display_in_url":true}}}</script>
      
    <meta name="dcterms.title" content="SecureFiles and Large Objects Developer&#39;s Guide"></meta>
    <meta name="dcterms.isVersionOf" content="ADLOB"></meta>
    <meta name="dcterms.release" content="Release 19"></meta>
  </head>
   <body dir="ltr">
      <div class="noscript alert alert-danger text-center" role="alert">
         <a href="DBFS-content-API.html" class="pull-left"><span class="glyphicon glyphicon-chevron-left" aria-hidden="true"></span>上一页</a> <a href="using-DBFS.html" class="pull-right">下一页<span class="glyphicon glyphicon-chevron-right" aria-hidden="true"></span></a> <span class="fa fa-exclamation-triangle" aria-hidden="true"></span>必须启用JavaScript才能正确显示此内容</div>
      <article>
         <header>
            <ol class="breadcrumb" vocab="http://schema.org/" typeof="BreadcrumbList">
               <li property="itemListElement" typeof="ListItem"><a href="index.html" property="item" typeof="WebPage"><span property="name">Database SecureFiles和Large Objects Developer's Guide</span></a></li>
               <li property="itemListElement" typeof="ListItem"><a href="database-file-system.html" property="item" typeof="WebPage"><span property="name">数据库文件系统（DBFS）</span></a></li>
               <li class="active" property="itemListElement" typeof="ListItem">创建自己的DBFS存储</li>
            </ol>
            <a id="GUID-01819696-9FE0-41AB-9388-A0ECA1F72E52" name="GUID-01819696-9FE0-41AB-9388-A0ECA1F72E52"></a><a id="ADLOB0079"></a>
            
            <h2 id="ADLOB-GUID-01819696-9FE0-41AB-9388-A0ECA1F72E52" class="sect2"><span class="enumeration_chapter">24</span>创建自己的DBFS存储</h2>
         </header>
         <div class="ind">
            <div>
               <p>您可以使用DBFS内容SPI（ <code class="codeph">DBMS_DBFS_CONTENT_SPI)</code>创建自己的DBFS存储。
               </p>
               <p>话题：</p>
               <ul style="list-style-type:disc">
                  <li>
                     <p><a href="creating-your-own-DBFS-store.html#GUID-15A25729-A83D-4B0B-8858-E9DEDA9C4554" title="要自定义DBFS存储，必须实现DBFS内容SPI（DBMS_DBFS_CONTENT_SPI）。它是现有存储（如DBFS SecureFiles存储和DFFS分层存储）以及您创建的任何用户定义的DBFS存储的基础。">DBFS存储库创建和使用概述</a></p>
                  </li>
                  <li>
                     <p> <a href="creating-your-own-DBFS-store.html#GUID-5EA68AD7-404E-47CC-86DE-EDB2EBA68119" title="DBFS内容SPI（存储提供程序接口）仅是规范，没有包体。">DBFS内容存储提供程序接口（DBFS内容SPI）</a></p>
                  </li>
                  <li>
                     <p><a href="creating-your-own-DBFS-store.html#GUID-FC7FD421-751A-4D8C-927C-A046AFDFD492" title="您可以将此示例存储提供程序用于DBFS，TaBleFileSystem存储提供程序（" tbf="),=" ="">创建自定义提供程序</a></p>
                  </li>
               </ul>
            </div><a id="ADLOB46227"></a><a id="ADLOB46210"></a><div class="props_rev_3"><a id="GUID-15A25729-A83D-4B0B-8858-E9DEDA9C4554" name="GUID-15A25729-A83D-4B0B-8858-E9DEDA9C4554"></a><h3 id="ADLOB-GUID-15A25729-A83D-4B0B-8858-E9DEDA9C4554" class="sect3">DBFS存储库创建和使用概述</h3>
               <div>
                  <p>要自定义DBFS存储，必须实现DBFS内容SPI（ <code class="codeph">DBMS_DBFS_CONTENT_SPI)</code> 。它是现有存储（如DBFS SecureFiles存储和DFFS分层存储）以及您创建的任何用户定义的DBFS存储的基础。
                  </p>
                  <p>客户端应用程序（如PL / SQL接口）调用DBFS Content API中的函数和过程。然后，DBFS Content API调用DBFS内容SPI中的相应子程序来创建存储并执行其他相关功能。</p>
                  <p>创建DBFS存储后，您将以与SecureFiles存储相同的方式运行它。</p>
                  <div class="infoboxnotealso" id="GUID-15A25729-A83D-4B0B-8858-E9DEDA9C4554__DBFSCONTENTAPI.DBFSSECUREFILESSTORE-DFF8111B">
                     <p class="notep1">也可以看看：</p>
                     <ul style="list-style-type:disc">
                        <li>
                           <p><a href="DBFS-content-API.html#GUID-630BE6DB-0178-4EE4-8D7D-824BA886F68E" title="您可以使应用程序在多个不同的编程环境中使用数据库文件系统（DBFS）。">DBFS内容API</a></p>
                        </li>
                        <li>
                           <p><a href="DBFS-securefiles-store.html#GUID-F71C0B85-F08D-4CD0-9EB3-AB84C9B355AE" title="有一些设置和使用DBFS SecureFiles Store的过程。">DBFS SecureFiles商店</a></p>
                        </li>
                     </ul>
                  </div>
                  <div class="figure" id="GUID-15A25729-A83D-4B0B-8858-E9DEDA9C4554__GUID-EAF65659-C9F9-4198-B8A1-D1AD3748F171">
                     <p class="titleinfigure">图24-1数据库文件系统（DBFS）</p><img src="img/adlob201.gif" width="496" alt="下面是图24-1的描述" title="下面是图24-1的描述" longdesc="img_text/adlob201.html"><br><a href="img_text/adlob201.html">“图24-1数据库文件系统（DBFS）”的说明</a></div>
                  <!-- class="figure" -->
               </div>
            </div><a id="ADLOB46102"></a><div class="props_rev_3"><a id="GUID-5EA68AD7-404E-47CC-86DE-EDB2EBA68119" name="GUID-5EA68AD7-404E-47CC-86DE-EDB2EBA68119"></a><h3 id="ADLOB-GUID-5EA68AD7-404E-47CC-86DE-EDB2EBA68119" class="sect3">DBFS内容存储提供程序接口（DBFS内容SPI）</h3>
               <div>
                  <p>DBFS内容SPI（存储提供程序接口）仅是规范，没有包体。</p>
                  <p>您必须实现包体才能响应来自DBFS Content API的调用。换句话说，DBFS内容SPI是必需程序规范的集合，您必须使用指示的方法签名和语义来实现这些规范。</p>
                  <p>您可以根据需要向DBFS Content SPI包体添加其他功能和过程。您的实现可能实现其他方法并公开其他接口，但DBFS Content API将不使用这些接口。</p>
                  <p>DBFS内容SPI引用DBFS内容API（包<code class="codeph">DBMS_DBFS_CONTENT</code> ）定义的各种元素，例如常量，类型和异常。
                  </p>
                  <p>请注意，所有路径名引用都必须是存储限定的，即，在调用任何Provider SPI方法之前，DBFS Content API已将规范化并将安装点和完整绝对路径名的概念规范化并转换为存储限定路径名。 。</p>
                  <p>由于DBFS Content API和Provider SPI是一对多可插拔体系结构，因此DBFS Content API使用动态SQL来调用Provider SPI中的方法;如果您的Provider SPI实现不遵循本文档中的Provider SPI规范，这可能会导致运行时错误。</p>
                  <p>没有明确的初始或最终方法来指示DBFS Content API何时插入并拔出特定的提供者SPI。提供者SPI必须能够在任何SPI入口点自动初始化自己。</p>
                  <div class="infoboxnotealso" id="GUID-5EA68AD7-404E-47CC-86DE-EDB2EBA68119__GUID-A8FF224C-9DCD-4126-8B7D-2C448D560D61">
                     <p class="notep1">也可以看看：</p>
                     <p> </p>
                     <ul style="list-style-type:disc">
                        <li>
                           <p><a href="../arpls/DBMS_DBFS_CONTENT_SPI.html#ARPLS72231" target="_blank"><span class="italic">Oracle Database PL / SQL包和类型参考</span></a> ，了解<code class="codeph">DBMS_DBFS_CONTENT_SPI</code>包的语法</p>
                        </li>
                        <li>
                           <p>有关更多信息，请参阅文件<code class="codeph">$ORACLE_HOME/rdbms/admin/dbmscapi.sql</code></p>
                        </li>
                     </ul>
                  </div>
               </div>
            </div><a id="ADLOB46211"></a><div class="sect2"><a id="GUID-FC7FD421-751A-4D8C-927C-A046AFDFD492" name="GUID-FC7FD421-751A-4D8C-927C-A046AFDFD492"></a><h3 id="ADLOB-GUID-FC7FD421-751A-4D8C-927C-A046AFDFD492" class="sect3">创建自定义提供程序</h3>
               <div>
                  <p>您可以将此示例存储提供程序用于DBFS，TaBleFileSystem存储提供程序（“tbfs”），作为自定义提供程序的框架或作为学习工具，以熟悉DBFS及其SPI。</p>
                  <p>此DBFS示例存储提供程序将包含<code class="codeph">BLOB</code>列的关系表公开为平面非分层文件系统，即命名文件的集合。
                  </p>
                  <p>要使用此示例，假定您已安装Oracle Database 12 <span class="italic">c</span>并熟悉DBFS概念，并已安装并使用<code class="codeph">dbfs_client</code>和<code class="codeph">FUSE</code>来装入和访问由标准SFS存储提供程序支持的文件系统。
                  </p>
                  <p>TaBleFileSystem存储提供程序（“tbfs”）并非旨在功能丰富甚至完整，但它确实提供了足够的演示，说明DBFS用户可以编写自己的自定义提供程序，通过它们公开其表格。 <code class="codeph">dbfs_client</code>到传统的文件系统程序。
                  </p>
                  <p>话题：</p>
                  <ul style="list-style-type:disc">
                     <li>
                        <p><a href="creating-your-own-DBFS-store.html#GUID-FC31EEE0-061F-49CC-A02B-687086E5D10C" title="这些是DBFS，TaBleFileSystem Store Provider的示例商店提供程序的机制（" tbf=")." ="">机械学</a></p>
                     </li>
                     <li>
                        <p><a href="creating-your-own-DBFS-store.html#GUID-E2E72747-14A0-4334-A3AE-AC4EEDE9FD45" title="TBFS.SQL脚本是顶级驱动程序脚本。">TBFS.SQL</a></p>
                     </li>
                     <li>
                        <p><a href="creating-your-own-DBFS-store.html#GUID-2ADF05F4-1FB5-4B18-9B4B-06B344B806E9" title="TBL.SQL脚本创建测试用户，表空间，支持文件系统的表等等。">TBL.SQL</a></p>
                     </li>
                     <li>
                        <p><a href="creating-your-own-DBFS-store.html#GUID-6EBE7625-C688-4346-A4C6-891772A8D821" title="spec.sql脚本提供tbfs的SPI规范。">spec.sql</a></p>
                     </li>
                     <li>
                        <p><a href="creating-your-own-DBFS-store.html#GUID-BEE83BB9-C2FE-448B-AF91-5AC9392E13C8" title="body.sql脚本提供了tbfs的SPI实现。">body.sql</a></p>
                     </li>
                     <li>
                        <p><a href="creating-your-own-DBFS-store.html#GUID-33C05C50-B474-47F8-AE49-242837A24D3F" title="capi.sql脚本注册并安装DBFS。">capi.sql</a></p>
                     </li>
                  </ul>
               </div><a id="ADLOB46228"></a><div class="props_rev_3"><a id="GUID-FC31EEE0-061F-49CC-A02B-687086E5D10C" name="GUID-FC31EEE0-061F-49CC-A02B-687086E5D10C"></a><h4 id="ADLOB-GUID-FC31EEE0-061F-49CC-A02B-687086E5D10C" class="sect4">机械学</h4>
                  <div>
                     <p>这些是DBFS，TaBleFileSystem存储提供程序（“tbfs”）的示例存储提供程序的机制。</p>
                     <p>话题：</p>
                     <ul style="list-style-type:disc">
                        <li>
                           <p><a href="creating-your-own-DBFS-store.html#GUID-B9323C55-9154-4519-B925-A8B7A6DC2D8B" title="您将需要某些文件来安装和设置DBFS TaBleFileSystem Store Provider（" tbf=")." ="">安装和设置</a></p>
                        </li>
                        <li>
                           <p><a href="creating-your-own-DBFS-store.html#GUID-99EBB22D-9D7A-419E-9C97-5A53A3079308" title="一旦DBFS的示例商店提供商，TaBleFileSystem商店提供商（" tbf=")=" ="">TBFS使用</a></p>
                        </li>
                        <li>
                           <p><a href="creating-your-own-DBFS-store.html#GUID-034FE169-7B56-452F-92E7-2A7CC9236E7B" title="TBFS很简单，因为它的主要目的是作为教学和学习的例子。">TBFS内部</a></p>
                        </li>
                     </ul>
                  </div><a id="ADLOB46229"></a><div class="props_rev_3"><a id="GUID-B9323C55-9154-4519-B925-A8B7A6DC2D8B" name="GUID-B9323C55-9154-4519-B925-A8B7A6DC2D8B"></a><h5 id="ADLOB-GUID-B9323C55-9154-4519-B925-A8B7A6DC2D8B" class="sect5">安装和设置</h5>
                     <div>
                        <p>您将需要某些文件来安装和设置DBFS TaBleFileSystem Store Provider（“tbfs”）。</p>
                        <p>TBFS由以下SQL文件组成：</p>
                        <p><code class="codeph">tbfs.sql</code>顶级驱动程序脚本</p>
                        <p><code class="codeph">tbl.sql</code>脚本创建测试用户，表空间，支持文件系统的表，等等。
                        </p>
                        <p><code class="codeph">spec.sql</code>是<code class="codeph">spec.sql</code>的SPI规范</p>
                        <p><code class="codeph">body.sql</code>是<code class="codeph">body.sql</code>的SPI实现</p>
                        <p><code class="codeph">capi.sql</code> DBFS寄存器/挂载脚本</p>
                        <p>要安装TBFS，只需在包含所有上述文件的目录中以<code class="codeph">SYSDBA</code>身份运行<code class="codeph">tbfs.sql</code> 。 <code class="codeph">tbfs.sql</code>将以正确的顺序加载其他SQL文件。
                        </p>
                        <p>忽略任何名称冲突，应加载所有SQL文件而不会出现任何编译错误。所有SQL文件也应加载而不会出现任何运行时错误，具体取决于“plsql_warnings”init.ora参数的值，您可能会看到各种无害的警告。</p>
                        <p>如果存在任何名称冲突（表空间名称TBFS，数据文件名称“tbfs.f”，用户名TBFS，包名称TBFS），则必须一致地更改各种SQL文件中的相应引用。</p>
                     </div>
                  </div><a id="ADLOB46230"></a><div class="props_rev_3"><a id="GUID-99EBB22D-9D7A-419E-9C97-5A53A3079308" name="GUID-99EBB22D-9D7A-419E-9C97-5A53A3079308"></a><h5 id="ADLOB-GUID-99EBB22D-9D7A-419E-9C97-5A53A3079308" class="sect5">TBFS使用</h5>
                     <div>
                        <p>一旦安装了DBFS的示例存储提供程序，即TaBleFileSystem存储提供程序（“tbfs”），就可以通过几种不同的方式添加或删除文件，并可以对TBFS进行其他更改。</p>
                        <p>作为用户<code class="codeph">dbfs_client</code>连接的dbfs_client将看到由RDBMS表（TBFS.TBFST）支持的简单，非分层的文件系统。
                        </p>
                        <p>可以通过SQL（即通过基础表上的DML），Unix实用程序（由<code class="codeph">dbfs_client</code> ）或通过PL / SQL（使用DBFS API）在此文件系统中添加或删除文件。
                        </p>
                        <p>通过任何访问方法对文件系统所做的更改将以事务一致的方式（即在提交/回滚边界）对所有其他访问方法可见。</p>
                     </div>
                  </div><a id="ADLOB46231"></a><div class="props_rev_3"><a id="GUID-034FE169-7B56-452F-92E7-2A7CC9236E7B" name="GUID-034FE169-7B56-452F-92E7-2A7CC9236E7B"></a><h5 id="ADLOB-GUID-034FE169-7B56-452F-92E7-2A7CC9236E7B" class="sect5">TBFS内部</h5>
                     <div>
                        <p>TBFS很简单，因为它的主要目的是作为教学和学习的例子。</p>
                        <p>但是，该实现显示了一条强大的，生产质量的自定义SPI的路径，可以插入到DBFS中，并将现有的关系数据公开为Unix文件系统。</p>
                        <p>TBFS进行了各种简化以保持简洁（但是，这些不应被视为DBFS或SPI的不可侵犯的限制）：</p>
                        <ul style="list-style-type:disc">
                           <li>
                              <p>TBFS SPI包仅处理具有硬编码名称的单个表（TBFS.TBFST）。可以使用动态SQL和其他配置信息使单个SPI包支持多个表，每个表作为单独的文件系统（甚至将多个表中的数据统一到单个文件系统中）。</p>
                           </li>
                           <li>
                              <p>TBFS不支持文件系统层次结构;它强加了一个平面命名空间：一个由虚拟“/”根目录下的简单项名称标识的文件集合。实现目录层次结构要复杂得多，因为它要求商店提供商以一致的方式管理父/子关系。</p>
                              <p>此外，现有的关系数据（TBFS试图作为文件系统公开的数据类型）通常不具有形成自然目录/文件层次结构的行间关系。</p>
                           </li>
                           <li>
                              <p>由于TBFS仅支持平面命名空间，因此SPI中的大多数方法<code class="codeph">dbms_dbfs_content.unsupported_operation</code>实现，并且方法体引发了<code class="codeph">dbms_dbfs_content.unsupported_operation</code>异常。此异常也是您编写自定义SPI的良好起点。您可以从<code class="codeph">DBMS_DBFS_CONTENT_SPI</code>包中克隆的简单SPI骨架开始，将所有方法体默认为引发此异常的体，然后逐步填充更实际的实现。
                              </p>
                           </li>
                           <li>
                              <p>TBFS底层的表接近于最简单的结构（键/名称列和LOB列）。这意味着必须动态生成DBFS和<code class="codeph">dbfs_client</code>使用或期望的各种属性（TBFS实现显示了如何对<code class="codeph">std:guid</code>属性执行此操作）。
                              </p>
                              <p>其他属性（例如Unix风格的时间戳）根本没有实现。这仍然允许实现令人惊讶的功能文件系统，但是当您编写自己的自定义SPI时，您可以通过扩展其基础表的结构以根据需要包含其他列，或者通过使用来轻松地合并对其他DBFS属性的支持。现有表中的现有列，以提供这些DBFS属性的值。</p>
                           </li>
                           <li>
                              <p>TBFS没有实现重命名/移动方法;添加对此的支持（ <code class="codeph">renamePath</code>方法中的合适的<code class="codeph">UPDATE</code>语句）留给用户练习。
                              </p>
                           </li>
                           <li>
                              <p>TBFS示例在多个位置使用字符串“tbfs”（表空间，数据文件，用户，包甚至文件系统名称）。“tbfs”的所有这些用法属于不同的名称空间 - 标识哪个名称空间对应于字符串的特定出现。这些示例中的“tbfs”也是一个很好的学习练习，可以确保DBFS概念在您的脑海中清晰可见。</p>
                           </li>
                        </ul>
                     </div>
                  </div>
               </div><a id="ADLOB46232"></a><div class="props_rev_3"><a id="GUID-E2E72747-14A0-4334-A3AE-AC4EEDE9FD45" name="GUID-E2E72747-14A0-4334-A3AE-AC4EEDE9FD45"></a><h4 id="ADLOB-GUID-E2E72747-14A0-4334-A3AE-AC4EEDE9FD45" class="sect4">TBFS.SQL</h4>
                  <div>
                     <p>TBFS.SQL脚本是顶级驱动程序脚本。</p>
                     <p>TBFS.SQL脚本：</p><pre class="oac_no_warn" dir="ltr">设置回声; @tbl @spec @body @capi quit;</pre></div>
               </div><a id="ADLOB46233"></a><div class="props_rev_3"><a id="GUID-2ADF05F4-1FB5-4B18-9B4B-06B344B806E9" name="GUID-2ADF05F4-1FB5-4B18-9B4B-06B344B806E9"></a><h4 id="ADLOB-GUID-2ADF05F4-1FB5-4B18-9B4B-06B344B806E9" class="sect4">TBL.SQL</h4>
                  <div>
                     <p>TBL.SQL脚本创建测试用户，表空间，支持文件系统的表等等。</p>
                     <p>TBL.SQL脚本：</p><pre class="oac_no_warn" dir="ltr">connect / as sysdba create tablespace tbfs datafile'tbfs.f'size 100m在extent管理本地段空间管理auto上重用autoextend;创建由tbfs标识的用户tbfs; alter user tbfs default tablespace tbfs; grant connect，resource，dbfs_role to tbfs; connect tbfs / tbfs; drop table tbfst;清洗回收箱; create table tbfst（key varchar2（256）primary key check（instr（key，'/'）= 0），data blob）tablespace tbfs lob（data）store as securefile（tablespace tbfs）;将tbfst上的select赋予dbfs_role;将tbfst上的insert插入dbfs_role;将tbfst上的delete授予dbfs_role;将tbfst上的更新授予dbfs_role;</pre></div>
               </div><a id="ADLOB46234"></a><div class="props_rev_3"><a id="GUID-6EBE7625-C688-4346-A4C6-891772A8D821" name="GUID-6EBE7625-C688-4346-A4C6-891772A8D821"></a><h4 id="ADLOB-GUID-6EBE7625-C688-4346-A4C6-891772A8D821" class="sect4">spec.sql</h4>
                  <div>
                     <p><code class="codeph">spec.sql</code>脚本提供<code class="codeph">spec.sql</code>的SPI规范。
                     </p>
                     <p><code class="codeph">spec.sql</code>脚本：</p><pre class="oac_no_warn" dir="ltr">connect / as sysdba;创建或替换包tbfs authid current_user为/ * *查找存储功能（请参阅dbms_dbfs_content.feature_XXX）。查找*商店ID。* *商店ID标识特定于提供商的商店，跨*注册和安装，但独立于商店*内容的更改。* *即对商店表的更改应反映在*商店ID中，但重新初始化相同的商店表应该*保留商店ID。 * *提供商还应根据标准* &lt;abc&gt;命名约定（对于&lt;major&gt;，&lt;minor&gt;和&lt;patch&gt; *）返回“版本”（特定于*提供程序包或单个存储）组件）。* * / function getFeatures（varchar2中的store_name）返回整数;函数getStoreId（varchar2中的store_name）返回数字; function getVersion（varchar2中的store_name）返回varchar2; / * *查找路径名（store_name，std_guid）或（store_mount，* std_guid）元组。* *如果在底层商店中找到基础“std_guid”，则*此函数返回商店限定的路径名。* *如果“std_guid”未知，则返回“null”值。客户*应该在适当的时候处理这个问题。* * / function getPathByStoreId（varchar2中的store_name，整数中的guid）return varchar2; / * * DBFS SPI：空间使用情况。* *客户端可以通过*“spaceUsage（）”方法查询文件系统空间使用情况统计信息。提供商应该为他们的商店支持这种*方法（并尽最大努力确定空间使用量 - 尤其是如果商店包含多个*表/索引/ lobs等）。* *“blksize”是保存*存储的自然表空间块大小 - 如果使用具有不同块大小的多个表空间，则任何有效的块大小都是可接受的。* *“tbytes”是存储的总大小（以字节为单位），“fbytes”是*存储的空闲/未使用大小（以字节为单位）。这些值是在构成商店的所有段上计算的。* *“nfile”，“ndir”，“nlink”和“nref”计算*商店中*当前可用文件，目录，链接和引用的数量。* *由于数据库对象是可动态增长的，因此估算“自由”空间和“已用”空间之间的划分并不容易。* * / procedure spaceUsage（varchar2中的store_name，整数的blksize，整数的整数输出，整数的整数输出，整数的nfile输出，整数的nlink输出，整数的nlink输出，nref输出整数）; / * * DBFS SPI：关于路径名的说明。* * SPI中使用的所有路径名都是存储限定的，即表单的2元组*（store_name，pathname）（其中路径名在商店名称空间内以*为根）。* * *支持基于contentID的访问的商店/提供商（请参阅*“feature_content_id”）也支持*不基于路径名的寻址形式。项目由显式商店*名称，“空”路径名以及可能指定为*参数的contentID或通过“opt_content_id”属性标识。* *并非所有操作都支持基于contentID的访问，*应用程序应仅依赖于最简单的创建/删除*功能。* * / / * * DBFS SPI：创建操作* * SPI必须允许DBFS API创建目录，文件，链接，*和引用元素（受商店功能支持）。* * *所有创建方法都需要有效的路径名（请参阅下面的基于contentID的访问的特殊豁免），并且可以*可选地指定在创建时与路径名*相关联的属性。客户端也可以在创建完成后获取* item属性（以便*自动生成的属性（例如“std_creation_time”）*可立即供客户端使用（获取的确切属性集*由各种控制） *“prop_flags”中的“prop_xxx”位掩码。* * *链接和引用需要一个额外的路径名来将*与主路径名相关联。* *文件路径名可以选择指定用于*最初填充基础文件内容的BLOB值（提供的BLOB *可以是任何有效的lob：临时或永久）。在创建时，*底层lob返回给客户端（如果在“prop_flags”中指定了“prop_data”）。* *非目录路径名要求首先创建其父目录。可以递归地*创建目录路径名本身（即，可以在一次调用中创建通向目录*的路径名层次结构）。* * *尝试创建已存在的路径是一个错误;一个*异常是“软删除”的路径名（请参阅下面的*删除操作）---在这些情况下，*隐式清除软删除的项目，并尝试创建新项目。* * *支持基于contentID的访问的商店/提供商接受*显式商店名称和“空”路径来创建新元素。*为此元素生成的contentID可通过*“opt_content_id”属性获得（基于contentID的创建自动*暗示“prop_flags”中的“prop_opt”）。* *新创建的元素也可能具有内部生成的* pathname（如果不支持“feature_lazy_path”），并且此路径*可通过“std_canonical_path”属性获得。* *只有文件元素是基于contentID的访问的候选者。* * / procedure createFile（varchar2中的store_name，varchar2中的路径，nocopy中的属性dbms_dbfs_content_properties_t，nocopy blob中的内容，整数中的prop_flags，dbms_dbfs_content_context_t中的ctx）; procedure createLink（varchar2中的store_name，varchar2中的srcPath，varchar2中的dstPath，nocopy中的属性dbms_dbfs_content_properties_t，整数中的prop_flags，dbms_dbfs_content_context_t中的ctx）; procedure createReference（varchar2中的store_name，varchar2中的srcPath，varchar2中的dstPath，nocopy中的属性dbms_dbfs_content_properties_t，整数中的prop_flags，dbms_dbfs_content_context_t中的ctx）; procedure createDirectory（varchar2中的store_name，varchar2中的路径，out nocopy中的属性dbms_dbfs_content_properties_t，整数中的prop_flags，整数中的recurse，dbms_dbfs_content_context_t中的ctx）; / * * DBFS SPI：删除操作* * SPI必须允许DBFS API删除目录，文件，链接，*和引用元素（受商店功能支持）。* * *默认情况下，删除是“永久性的”（在事务提交时删除*成功删除的项目），但商店可能*也支持“软删除”功能。如果客户请求，商店会保留*软删除的商品（但通常不会在正常商品或搜索中显示）。* *软删除的项目可以“恢复”或明确清除。* * *可以递归删除目录路径名（即，可以在一次调用中删除目录下的路径名*层次结构）。*非递归删除只能在空*目录上执行。递归软删除将软删除应用于*所有要删除的项目。* * *可以通过restore和purge *方法恢复或清除单个路径名（或*目录下的所有软删除路径名）。* * *支持过滤的提供商可以使用提供商“过滤器”来识别要删除的项目的子集---这对于*批量操作（deleteDirectory，restoreAll，purgeAll）最有意义，但是所有*与删除相关的操作接受“过滤器”参数。* * *支持基于contentID的访问的商店/提供商也可以*允许通过指定其contentID来删除文件项。 * * / procedure deleteFile（varchar2中的store_name，varchar2中的路径，varchar2中的filter，整数中的soft_delete，dbms_dbfs_content_context_t中的ctx）; procedure deleteContent（varchar2中的store_name，raw中的contentID，varchar2中的filter，整数中的soft_delete，dbms_dbfs_content_context_t中的ctx）; procedure deleteDirectory（varchar2中的store_name，varchar2中的路径，varchar2中的filter，整数中的soft_delete，整数中的recurse，dbms_dbfs_content_context_t中的ctx）; procedure restorePath（varchar2中的store_name，varchar2中的路径，varchar2中的filter，dbms_dbfs_content_context_t中的ctx）; procedure purgePath（varchar2中的store_name，varchar2中的路径，varchar2中的filter，dbms_dbfs_content_context_t中的ctx）; procedure restoreAll（varchar2中的store_name，varchar2中的路径，varchar2中的filter，dbms_dbfs_content_context_t中的ctx）; procedure purgeAll（varchar2中的store_name，varchar2中的路径，varchar2中的filter，dbms_dbfs_content_context_t中的ctx）; / * * DBFS SPI：路径获取/放置操作。* *可以访问现有路径项（用于查询或更新），并通过简单的get / put方法进行修改。* *所有路径名允许*读取/修改其元数据（即属性）。完成调用后，客户端也可以请求*（通过“prop_flags”）获取特定属性。* *文件路径名允许*读取/修改其数据（即内容）。在完成调用后，客户端可以请求*（通过“prop_flags”中的“prop_data”位标记）可用于继续数据访问的新BLOB定位符*。* *文件也可以在不使用BLOB定位器的情况下读取/写入，*显式指定逻辑偏移量/缓冲量和*适当大小的缓冲区。* * *更新访问必须指定“forUpdate”标志。如果指定“deref”标志，则可以通过商店*（取决于功能支持）隐式地和内部地引用对链接*路径名的访问 - 但是，这是危险的，因为符号链接*不总是可解析的。* * *读取方法（即“getPath”，其中“forUpdate”为“false”*也接受有效的“asof”时间戳参数，该参数可由商店用于实现“截至”样式闪回查询。变异*版本的“getPath”和“putPath”方法不支持as-of操作模式。* * *“getPathNowait”表示“forUpdate”，如果实现（请参阅*“feature_nowait”），则允许提供程序返回异常*（ORA-54）而不是等待行锁。* * / procedure getPath（varchar2中的store_name，varchar2中的路径，nocopy中的属性dbms_dbfs_content_properties_t，nocopy blob，item_type out整数，prop_flags整数，forUpdate整数，deref整数，ctx，dbms_dbfs_content_context_t）;过程getPathNowait（varchar2中的store_name，varchar2中的路径，out nocopy中的属性dbms_dbfs_content_properties_t，nocopy blob的内容，item_type out整数，整数的prop_flags，整数的deref，dbms_dbfs_content_context_t中的ctx）; procedure getPath（varchar2中的store_name，varchar2中的路径，out nocopy中的属性dbms_dbfs_content_properties_t，输出数量，偏移量，缓冲输出nocopy raw，prop_flags输入整数，ctx输入dbms_dbfs_content_context_t）;过程getPath（varchar2中的store_name，varchar2中的路径，nocopy中的属性dbms_dbfs_content_properties_t，输出数量，数量偏移量，缓冲输出nocopy dbms_dbfs_content_raw_t，prop_flags输入整数，ctx输入dbms_dbfs_content_context_t）; procedure putPath（varchar2中的store_name，varchar2中的路径，nocopy中的属性dbms_dbfs_content_properties_t，nocopy blob中的内容，item_type out整数，整数中的prop_flags，dbms_dbfs_content_context_t中的ctx）; procedure putPath（varchar2中的store_name，varchar2中的路径，nocopy中的属性dbms_dbfs_content_properties_t，数量的数量，数量的偏移量，raw中的缓冲区，整数中的prop_flags，dbms_dbfs_content_context_t中的ctx）; procedure putPath（varchar2中的store_name，varchar2中的路径，nocopy中的属性dbms_dbfs_content_properties_t，写出的数字，数量的偏移量，dbms_dbfs_content_raw_t中的缓冲区，整数中的prop_flags，dbms_dbfs_content_context_t中的ctx）; / * * DBFS SPI：重命名/移动操作。* *可以重命名或移动路径名，可能跨目录*层次结构和挂载点，但在同一存储中。* * *以前可通过“oldPath”访问的非目录路径名*被重命名为随后可通过“newPath”访问的单个项目; *假设“newPath”尚不存在。* *如果“newPath”存在且不是目录，则重命名隐式*会在重命名“oldPath”之前删除现有项目。如果“newPath”*存在且是目录，则“oldPath”将移动到target *目录中。* * *以前可通过“oldPath”访问的目录路径名*通过将目录及其所有子项移动到*“newPath”（如果它尚不存在）或作为*“newPath”的子项（如果它存在且是一个目录）。* * *支持基于contentID的访问和lazy * pathname绑定的商店/提供商也支持*将现有“contentID”与新“路径”相关联的“setPath”方法。* * / procedure renamePath（varchar2中的store_name，varchar2中的oldPath，varchar2中的newPath，nocopy中的属性dbms_dbfs_content_properties_t，dbms_dbfs_content_context_t中的ctx）; procedure setPath（varchar2中的store_name，raw中的contentID，varchar2中的path，out nocopy中的属性dbms_dbfs_content_properties_t，dbms_dbfs_content_context_t中的ctx）; / * * DBFS SPI：目录导航和搜索。* * DBFS API可以列出或搜索目录*路径名的内容，可选地递归到子目录中，可选*查看软删除的项目，可选地使用闪回“截至”a *提供的时间戳，并可选择过滤项目进/出在*商店内基于列表/搜索谓词。* * /函数列表（varchar2中的store_name，varchar2中的路径，varchar2中的过滤器，整数中的recurse，dbms_dbfs_content_context_t中的ctx）返回dbms_dbfs_content_list_items_t pipelined;函数搜索（varchar2中的store_name，varchar2中的路径，varchar2中的过滤器，整数中的recurse，dbms_dbfs_content_context_t中的ctx）返回dbms_dbfs_content_list_items_t pipelined; / * * DBFS SPI：锁定操作。* * DBFS API的客户端可以将用户级锁应用于任何有效的*路径名（受商店功能支持），将lock *与用户数据相关联，然后解锁这些路径名。* *锁定项目的状态可通过各种可选*属性获得（请参阅上面的“opt_lock *”）。* * *商店负责（假设它支持*用户定义的锁定检查）以确保以一致的方式执行锁定/解锁操作*。* * / procedure lockPath（varchar2中的store_name，varchar2中的路径，整数中的lock_type，varchar2中的lock_data，dbms_dbfs_content_context_t中的ctx）; procedure unlockPath（varchar2中的store_name，varchar2中的路径，dbms_dbfs_content_context_t中的ctx）; / * * DBFS SPI：访问检查。* *检查给定的路径名（store_name，path，pathtype）是否可以通过“principal”操作（参见各种*“dbms_dbfs_content.op_xxx”操作码）。* *这是DBFS API的便利功能; *支持访问控制的商店仍在内部执行这些检查以确保安全性。* * / function checkAccess（varchar2中的store_name，varchar2中的路径，整数中的pathtype，varchar2中的操作，varchar2中的principal）返回整数;结束; /显示错误;为sys.tbfs创建或替换公共同义词tbfs;将tbfs上的执行权限授予dbfs_role;</pre></div>
               </div><a id="ADLOB46235"></a><div class="props_rev_3"><a id="GUID-BEE83BB9-C2FE-448B-AF91-5AC9392E13C8" name="GUID-BEE83BB9-C2FE-448B-AF91-5AC9392E13C8"></a><h4 id="ADLOB-GUID-BEE83BB9-C2FE-448B-AF91-5AC9392E13C8" class="sect4">body.sql</h4>
                  <div>
                     <p><code class="codeph">body.sql</code>脚本提供了<code class="codeph">body.sql</code>的SPI实现。
                     </p>
                     <p><code class="codeph">body.sql</code>脚本：</p><pre class="oac_no_warn" dir="ltr">connect / as sysdba;将包体tbfs创建或替换为/ * * Lookup存储功能（请参阅dbms_dbfs_content.feature_XXX）。查找*商店ID。* *商店ID标识特定于提供商的商店，跨*注册和安装，但独立于商店*内容的更改。* *即对商店表的更改应反映在*商店ID中，但重新初始化相同的商店表应该*保留商店ID。 * *提供商还应根据标准* &lt;abc&gt;命名约定（对于&lt;major&gt;，&lt;minor&gt;和&lt;patch&gt; *）返回“版本”（特定于*提供程序包或单个存储）组件）。* * / function getFeatures（varchar2中的store_name）返回整数是start return dbms_dbfs_content.feature_locator;结束;函数getStoreId（varchar2中的store_name）返回的数字是start return 1;结束;函数getVersion（varchar2中的store_name）返回varchar2开始返回'1.0.0';结束; / * *查找路径名（store_name，std_guid）或（store_mount，* std_guid）元组。* *如果在底层商店中找到基础“std_guid”，则*此函数返回商店限定的路径名。* *如果“std_guid”未知，则返回“null”值。客户*应该在适当的时候处理这个问题。* * / function getPathByStoreId（store_name在varchar2中，guid在整数中）return varchar2 is begin raise dbms_dbfs_content.unsupported_operation;结束; / * * DBFS SPI：空间使用情况。* *客户端可以通过*“spaceUsage（）”方法查询文件系统空间使用情况统计信息。提供商应该为他们的商店支持这种*方法（并尽最大努力确定空间使用量 - 尤其是如果商店包含多个*表/索引/ lobs等）。* *“blksize”是保存*存储的自然表空间块大小 - 如果使用具有不同块大小的多个表空间，则任何有效的块大小都是可接受的。* *“tbytes”是存储的总大小（以字节为单位），“fbytes”是*存储的空闲/未使用大小（以字节为单位）。这些值是在构成商店的所有段上计算的。* *“nfile”，“ndir”，“nlink”和“nref”计算*商店中*当前可用文件，目录，链接和引用的数量。* *由于数据库对象是可动态增长的，因此估算“自由”空间和“已用”空间之间的划分并不容易。* * / procedure spaceUsage（varchar2中的store_name，整数输出，整数输出，整数输出，整数输出nfile，nd输出整数，nlink输出整数，nref输出整数）是nblks数;从tbfs.tbfst开始从nfile中选择count（*）; ndir：= 0; nlink：= 0; nref：= 0;从user_segments中选择sum（bytes）到tbytes;从user_segments中选择sum（blocks）到nblks; blksize：= tbytes / nblks; fbytes：= 0; / *根据需要改变* / end; / * * DBFS SPI：关于路径名的说明。* * SPI中使用的所有路径名都是存储限定的，即表单的2元组*（store_name，pathname）（其中路径名在商店名称空间内以*为根）。* * *支持基于contentID的访问的商店/提供商（请参阅*“feature_content_id”）也支持*不基于路径名的寻址形式。项目由显式商店*名称，“空”路径名以及可能指定为*参数的contentID或通过“opt_content_id”属性标识。* *并非所有操作都支持基于contentID的访问，*应用程序应仅依赖于最简单的创建/删除*功能。* * / / * * DBFS SPI：创建操作* * SPI必须允许DBFS API创建目录，文件，链接，*和引用元素（受商店功能支持）。* * *所有创建方法都需要有效的路径名（请参阅下面的基于contentID的访问的特殊豁免），并且可以*可选地指定在创建时与路径名*相关联的属性。客户端也可以在创建完成后获取* item属性（以便*自动生成的属性（例如“std_creation_time”）*可立即供客户端使用（获取的确切属性集*由各种控制） *“prop_flags”中的“prop_xxx”位掩码。* * *链接和引用需要一个额外的路径名来将*与主路径名相关联。* *文件路径名可以选择指定用于*最初填充基础文件内容的BLOB值（提供的BLOB *可以是任何有效的lob：临时或永久）。在创建时，*底层lob返回给客户端（如果在“prop_flags”中指定了“prop_data”）。* *非目录路径名要求首先创建其父目录。可以递归地*创建目录路径名本身（即，可以在一次调用中创建通向目录*的路径名层次结构）。* * *尝试创建已存在的路径是一个错误;一个*异常是“软删除”的路径名（请参阅下面的*删除操作）---在这些情况下，*隐式清除软删除的项目，并尝试创建新项目。* * *支持基于contentID的访问的商店/提供商接受*显式商店名称和“空”路径来创建新元素。*为此元素生成的contentID可通过*“opt_content_id”属性获得（基于contentID的创建自动*暗示“prop_flags”中的“prop_opt”）。* *新创建的元素也可能具有内部生成的* pathname（如果不支持“feature_lazy_path”），并且此路径*可通过“std_canonical_path”属性获得。* *只有文件元素是基于contentID的访问的候选者。* * / procedure createFile（varchar2中的store_name，varchar2中的路径，nocopy中的属性dbms_dbfs_content_properties_t，nocopy blob中的内容，整数中的prop_flags，dbms_dbfs_content_context_t中的ctx）是guid编号; start if（path ='/'）然后引发dbms_dbfs_content.invalid_path;万一;如果content为null则则content：= empty_blob（）;万一;开始插入tbfs.tbfst值（substr（path，2），content）将数据返回到内容中; dup_val_on_index然后引发dbms_dbfs_content.path_exists;结束;从双重选择ora_hash（path）到guid; properties：= dbms_dbfs_content_properties_t（dbms_dbfs_content_property_t（'std：length'，to_char（dbms_lob.getlength（content）），dbms_types。TYPECODE_NUMBER），dbms_dbfs_content_property_t（'std：guid'，to_char（guid），dbms_types。TYPECODE_NUMBER））;结束;过程createLink（varchar2中的store_name，varchar2中的srcPath，varchar2中的dstPath，nocopy中的属性dbms_dbfs_content_properties_t，整数中的prop_flags，dbms_dbfs_content_context_t中的ctx）start raise dbms_dbfs_content.unsupported_operation;结束;过程createReference（varchar2中的store_name，varchar2中的srcPath，varchar2中的dstPath，out nocopy中的属性dbms_dbfs_content_properties_t，整数中的prop_flags，dbms_dbfs_content_context_t中的ctx）start raise dbms_dbfs_content.unsupported_operation;结束;过程createDirectory（varchar2中的store_name，varchar2中的路径，out nocopy中的属性dbms_dbfs_content_properties_t，整数中的prop_flags，整数中的递归，dbms_dbfs_content_context_t中的ctx）start raise dbms_dbfs_content.unsupported_operation;结束; / * * DBFS SPI：删除操作* * SPI必须允许DBFS API删除目录，文件，链接，*和引用元素（受商店功能支持）。* * *默认情况下，删除是“永久性的”（在事务提交时删除*成功删除的项目），但商店可能*也支持“软删除”功能。如果客户请求，商店会保留*软删除的商品（但通常不会在正常商品或搜索中显示）。* *软删除的项目可以“恢复”或明确清除。* * *可以递归删除目录路径名（即，可以在一次调用中删除目录下的路径名*层次结构）。*非递归删除只能在空*目录上执行。递归软删除将软删除应用于*所有要删除的项目。* * *可以通过restore和purge *方法恢复或清除单个路径名（或*目录下的所有软删除路径名）。* * *支持过滤的提供商可以使用提供商“过滤器”来识别要删除的项目的子集---这对于*批量操作（deleteDirectory，restoreAll，purgeAll）最有意义，但是所有*与删除相关的操作接受“过滤器”参数。* * *支持基于contentID的访问的商店/提供商也可以*允许通过指定其contentID来删除文件项。 * * / procedure deleteFile（varchar2中的store_name，varchar2中的路径，varchar2中的过滤器，整数中的soft_delete，dbms_dbfs_content_context_t中的ctx）是if（path ='/'）然后引发dbms_dbfs_content.invalid_path;万一; if（（soft_delete &lt;&gt; 0）或（filter不为null））然后引发dbms_dbfs_content.unsupported_operation;万一;从tbfs.tbfst中删除其中（'/'|| t.key）= path;如果sql％rowcount &lt;&gt; 1则引发dbms_dbfs_content.invalid_path;万一;结束;过程deleteContent（varchar2中的store_name，raw中的contentID，varchar2中的filter，整数中的soft_delete，dbms_dbfs_content_context_t中的ctx）开始引发dbms_dbfs_content.unsupported_operation;结束;过程deleteDirectory（varchar2中的store_name，varchar2中的路径，varchar2中的过滤器，整数中的soft_delete，整数中的recurse，dbms_dbfs_content_context_t中的ctx）开始引发dbms_dbfs_content.unsupported_operation;结束;过程restorePath（varchar2中的store_name，varchar2中的路径，varchar2中的过滤器，dbms_dbfs_content_context_t中的ctx）开始引发dbms_dbfs_content.unsupported_operation;结束;过程purgePath（varchar2中的store_name，varchar2中的路径，varchar2中的过滤器，dbms_dbfs_content_context_t中的ctx）开始引发dbms_dbfs_content.unsupported_operation;结束;过程restoreAll（varchar2中的store_name，varchar2中的路径，varchar2中的过滤器，dbms_dbfs_content_context_t中的ctx）开始引发dbms_dbfs_content.unsupported_operation;结束;过程purgeAll（varchar2中的store_name，varchar2中的路径，varchar2中的过滤器，dbms_dbfs_content_context_t中的ctx）开始引发dbms_dbfs_content.unsupported_operation;结束; / * * DBFS SPI：路径获取/放置操作。* *可以访问现有路径项（用于查询或更新），并通过简单的get / put方法进行修改。* *所有路径名允许*读取/修改其元数据（即属性）。完成调用后，客户端也可以请求*（通过“prop_flags”）获取特定属性。* *文件路径名允许*读取/修改其数据（即内容）。在完成调用后，客户端可以请求*（通过“prop_flags”中的“prop_data”位标记）可用于继续数据访问的新BLOB定位符*。* *文件也可以在不使用BLOB定位器的情况下读取/写入，*显式指定逻辑偏移量/缓冲量和*适当大小的缓冲区。* * *更新访问必须指定“forUpdate”标志。如果指定“deref”标志，则可以通过商店*（取决于功能支持）隐式地和内部地引用对链接*路径名的访问 - 但是，这是危险的，因为符号链接*不总是可解析的。* * *读取方法（即“getPath”，其中“forUpdate”为“false”*也接受有效的“asof”时间戳参数，该参数可由商店用于实现“截至”样式闪回查询。变异*版本的“getPath”和“putPath”方法不支持as-of操作模式。* * *“getPathNowait”表示“forUpdate”，如果实现（请参阅*“feature_nowait”），则允许提供程序返回异常*（ORA-54）而不是等待行锁。* * / procedure getPath（varchar2中的store_name，varchar2中的路径，nocopy中的属性dbms_dbfs_content_properties_t，内容输出nocopy blob，item_type输出整数，prop_flags输入整数，forUpdate输入整数，deref输入整数，ctx输入dbms_dbfs_content_context_t）是guid数字; start if（deref &lt;&gt; 0）然后引发dbms_dbfs_content.unsupported_operation;万一;从双重选择ora_hash（path）到guid; if（path ='/'）然后if（forUpdate &lt;&gt; 0）然后引发dbms_dbfs_content.unsupported_operation;万一; content：= null; item_type：= dbms_dbfs_content.type_directory; properties：= dbms_dbfs_content_properties_t（dbms_dbfs_content_property_t（'std：guid'，to_char（guid），dbms_types。TYPECODE_NUMBER））;返回;万一; start if（forUpdate &lt;&gt; 0）然后从tbfs.tbfst中选择t.data到其中的内容，其中（'/'|| t.key）=更新路径;否则从tbfs.tbfst中选择t.data到其中的内容（'/'|| t.key）= path;万一;当no_data_found然后引发dbms_dbfs_content.invalid_path;结束; item_type：= dbms_dbfs_content.type_file; properties：= dbms_dbfs_content_properties_t（dbms_dbfs_content_property_t（'std：length'，to_char（dbms_lob.getlength（content）），dbms_types。TYPECODE_NUMBER），dbms_dbfs_content_property_t（'std：guid'，to_char（guid），dbms_types。TYPECODE_NUMBER））;结束;过程getPathNowait（varchar2中的store_name，varchar2中的路径，nocopy中的属性dbms_dbfs_content_properties_t，内容输出nocopy blob，item_type out整数，prop_flags整数，deref整数，ctx in dbms_dbfs_content_context_t）start raise dbms_dbfs_content.unsupported_operation;结束;过程getPath（varchar2中的store_name，varchar2中的路径，nocopy中的属性dbms_dbfs_content_properties_t，输出数量，数量偏移量，nocopy raw缓冲区，整数中prop_flags，dbms_dbfs_content_context_t中为ctx）是内容blob;导号; start if（path ='/'）然后引发dbms_dbfs_content.unsupported_operation;万一;开始从tbfs.tbfst中选择t.data为内容，其中（'/'|| t.key）= path;当no_data_found然后引发dbms_dbfs_content.invalid_path;结束;从双重选择ora_hash（path）到guid; dbms_lob.read（content，amount，offset，buffer）; properties：= dbms_dbfs_content_properties_t（dbms_dbfs_content_property_t（'std：length'，to_char（dbms_lob.getlength（content）），dbms_types。TYPECODE_NUMBER），dbms_dbfs_content_property_t（'std：guid'，to_char（guid），dbms_types。TYPECODE_NUMBER））;结束;过程getPath（varchar2中的store_name，varchar2中的路径，nocopy中的属性dbms_dbfs_content_properties_t，输出数量的数量，数量的偏移量，缓冲区nocopy dbms_dbfs_content_raw_t，整数的prop_flags，dbms_dbfs_content_context_t中的ctx）start raise dbms_dbfs_content.unsupported_operation;结束;过程putPath（varchar2中的store_name，varchar2中的路径，nocopy中的属性dbms_dbfs_content_properties_t，nocopy blob中的内容，item_type out整数，整数中的prop_flags，dbms_dbfs_content_context_t中的ctx）是guid编号; start if（path ='/'）然后引发dbms_dbfs_content.unsupported_operation;万一;如果content为null则则content：= empty_blob（）;万一; update tbfs.tbfst t set t.data = content where（'/'|| t.key）=将t.data返回到内容的路径;如果sql％rowcount &lt;&gt; 1则引发dbms_dbfs_content.invalid_path;万一;从双重选择ora_hash（path）到guid; item_type：= dbms_dbfs_content.type_file; properties：= dbms_dbfs_content_properties_t（dbms_dbfs_content_property_t（'std：length'，to_char（dbms_lob.getlength（content）），dbms_types。TYPECODE_NUMBER），dbms_dbfs_content_property_t（'std：guid'，to_char（guid），dbms_types。TYPECODE_NUMBER））;结束; procedure putPath（varchar2中的store_name，varchar2中的路径，nocopy中的属性dbms_dbfs_content_properties_t，数量的数量，数量的偏移量，raw中的缓冲区，整数中的prop_flags，dbms_dbfs_content_context_t中的ctx）是内容blob;导号; start if（path ='/'）然后引发dbms_dbfs_content.unsupported_operation;万一;开始从tbfs.tbfst中选择t.data为内容，其中（'/'|| t.key）=更新路径;当no_data_found然后引发dbms_dbfs_content.invalid_path;结束;从双重选择ora_hash（path）到guid; dbms_lob.write（content，amount，offset，buffer）; properties：= dbms_dbfs_content_properties_t（dbms_dbfs_content_property_t（'std：length'，to_char（dbms_lob.getlength（content）），dbms_types。TYPECODE_NUMBER），dbms_dbfs_content_property_t（'std：guid'，to_char（guid），dbms_types。TYPECODE_NUMBER））;结束;过程putPath（varchar2中的store_name，varchar2中的路径，nocopy中的属性dbms_dbfs_content_properties_t，写出的数字，数量上的偏移量，dbms_dbfs_content_raw_t中的缓冲区，整数中的prop_flags，dbms_dbfs_content_context_t中的ctx）start raise dbms_dbfs_content.unsupported_operation;结束; / * * DBFS SPI：重命名/移动操作。* *可以重命名或移动路径名，可能跨目录*层次结构和挂载点，但在同一存储中。* * *以前可通过“oldPath”访问的非目录路径名*被重命名为随后可通过“newPath”访问的单个项目; *假设“newPath”尚不存在。* *如果“newPath”存在且不是目录，则重命名隐式*会在重命名“oldPath”之前删除现有项目。如果“newPath”*存在且是目录，则“oldPath”将移动到target *目录中。* * *以前可通过“oldPath”访问的目录路径名*通过将目录及其所有子项移动到*“newPath”（如果它尚不存在）或作为*“newPath”的子项（如果它存在且是一个目录）。* * *支持基于contentID的访问和lazy * pathname绑定的商店/提供商也支持*将现有“contentID”与新“路径”相关联的“setPath”方法。* * / procedure renamePath（varchar2中的store_name，varchar2中的oldPath，varchar2中的newPath，nocopy中的属性dbms_dbfs_content_properties_t，dbms_dbfs_content_context_t中的ctx）开始引发dbms_dbfs_content.unsupported_operation;结束;过程setPath（varchar2中的store_name，raw中的contentID，varchar2中的路径，nocopy中的属性dbms_dbfs_content_properties_t，dbms_dbfs_content_context_t中的ctx）开始引发dbms_dbfs_content.unsupported_operation;结束; / * * DBFS SPI：目录导航和搜索。* * DBFS API可以列出或搜索目录*路径名的内容，可选地递归到子目录中，可选*查看软删除的项目，可选地使用闪回“截至”a *提供的时间戳，并可选择过滤项目进/出在*商店内基于列表/搜索谓词。* * /函数列表（varchar2中的store_name，varchar2中的路径，varchar2中的过滤器，整数中的递归，dbms_dbfs_content_context_t中的ctx）返回dbms_dbfs_content_list_items_t pipelined是为rws in（select * from tbfs.tbfst）循环管道行开始的（dbms_dbfs_content_list_item_t（'/ '|| rws.key，rws.key，dbms_dbfs_content.type_file））;结束循环;结束;函数搜索（varchar2中的store_name，varchar2中的路径，varchar2中的过滤器，整数中的递归，dbms_dbfs_content_context_t中的ctx）返回dbms_dbfs_content_list_items_t pipelined is begin raise dbms_dbfs_content.unsupported_operation;结束; / * * DBFS SPI：锁定操作。* * DBFS API的客户端可以将用户级锁应用于任何有效的*路径名（受商店功能支持），将lock *与用户数据相关联，然后解锁这些路径名。* *锁定项目的状态可通过各种可选*属性获得（请参阅上面的“opt_lock *”）。* * *商店负责（假设它支持*用户定义的锁定检查）以确保以一致的方式执行锁定/解锁操作*。* * / procedure lockPath（varchar2中的store_name，varchar2中的path，整数中的lock_type，varchar2中的lock_data，dbms_dbfs_content_context_t中的ctx）开始引发dbms_dbfs_content.unsupported_operation;结束;过程unlockPath（varchar2中的store_name，varchar2中的路径，dbms_dbfs_content_context_t中的ctx）开始引发dbms_dbfs_content.unsupported_operation;结束; / * * DBFS SPI：访问检查。* *检查给定的路径名（store_name，path，pathtype）是否可以通过“principal”操作（参见各种*“dbms_dbfs_content.op_xxx”操作码）。* *这是DBFS API的便利功能; *支持访问控制的商店仍在内部执行这些检查以确保安全性。* * / function checkAccess（varchar2中的store_name，varchar2中的路径，整数中的pathtype，varchar2中的操作，varchar2中的principal）返回整数，start return 1;结束;结束; /显示错误;</pre></div>
               </div><a id="ADLOB46236"></a><div class="props_rev_3"><a id="GUID-33C05C50-B474-47F8-AE49-242837A24D3F" name="GUID-33C05C50-B474-47F8-AE49-242837A24D3F"></a><h4 id="ADLOB-GUID-33C05C50-B474-47F8-AE49-242837A24D3F" class="sect4">capi.sql</h4>
                  <div>
                     <p><code class="codeph">capi.sql</code>脚本注册并安装DBFS。</p>
                     <p><code class="codeph">capi.sql</code>脚本：</p><pre class="oac_no_warn" dir="ltr">connect tbfs / tbfs; exec dbms_dbfs_content.registerStore（'MY_TBFS'，'table'，'TBFS'）; exec dbms_dbfs_content.mountStore（'MY_TBFS'，singleton =&gt; true）;承诺;</pre></div>
               </div>
            </div>
         </div>
      </article>
   </body>
</html>