<html lang="en-us" dir="ltr" xml:lang="en-us">
   <head>
      <meta http-equiv="Content-Type" content="text/html; charset=utf-8"></meta>
      <meta name="viewport" content="width=device-width, initial-scale=1"></meta>
      <meta http-equiv="X-UA-Compatible" content="IE=edge"></meta>
      <meta name="abstract" content="The C DOM API for XMLType lets you operate on XMLType instances using a DOM in C."></meta>
      <meta name="description" content="The C DOM API for XMLType lets you operate on XMLType instances using a DOM in C."></meta>
      <title>用于XMLType的C DOM API</title>
      <meta property="og:site_name" content="Oracle Help Center"></meta>
      <meta property="og:title" content="Developer&#39;s Guide "></meta>
      <meta property="og:description" content="The C DOM API for XMLType lets you operate on XMLType instances using a DOM in C."></meta>
      <link rel="stylesheet" href="/sp_common/book-template/ohc-book-template/css/book.css"></link>
      <link rel="shortcut icon" href="/sp_common/book-template/ohc-common/img/favicon.ico"></link>
      <meta name="application-name" content="Developer&#39;s Guide"></meta>
      <meta name="generator" content="DITA Open Toolkit version 1.8.5 (Mode = doc)"></meta>
      <meta name="plugin" content="SP_docbuilder HTML plugin release 18.2.2"></meta>
      <link rel="alternate" href="xml-db-developers-guide.pdf" title="PDF File" type="application/pdf"></link>
      <meta name="robots" content="all"></meta>
      <link rel="schema.dcterms" href="http://purl.org/dc/terms/"></link>
      <meta name="dcterms.created" content="2019-03-30T12:32:42-07:00"></meta>
      
      <meta name="dcterms.dateCopyrighted" content="2002, 2019"></meta>
      <meta name="dcterms.category" content="database"></meta>
      <meta name="dcterms.identifier" content="E96222-03"></meta>
      
      <meta name="dcterms.product" content="en/database/oracle/oracle-database/19"></meta>
      
      <link rel="prev" href="Java-DOM-API-for-XMLType.html" title="Previous" type="text/html"></link>
      <link rel="next" href="XML-DB-and-ODP-for-dot-NET.html" title="Next" type="text/html"></link>
      <script>
        document.write('<style type="text/css">');
        document.write('body > .noscript, body > .noscript ~ * { visibility: hidden; }');
        document.write('</style>');
     </script>
      <script src="/sp_common/book-template/requirejs/require.js" data-main="/sp_common/book-template/ohc-book-template/js/book-config"></script>
      <script>
            if (window.require === undefined) {
                document.write('<script data-main="sp_common/book-template/ohc-book-template/js/book-config" src="sp_common/book-template/requirejs/require.js"><\/script>');
                document.write('<link href="sp_common/book-template/ohc-book-template/css/book.css" rel="stylesheet"/>');
            }
        </script>
      <script type="application/json" id="ssot-metadata">{"primary":{"category":{"short_name":"database","element_name":"Database","display_in_url":true},"suite":{"short_name":"oracle","element_name":"Oracle","display_in_url":true},"product_group":{"short_name":"not-applicable","element_name":"Not applicable","display_in_url":false},"product":{"short_name":"oracle-database","element_name":"Oracle Database","display_in_url":true},"release":{"short_name":"19","element_name":"Release 19","display_in_url":true}}}</script>
      
    <meta name="dcterms.title" content="XML DB Developer&#39;s Guide"></meta>
    <meta name="dcterms.isVersionOf" content="ADXDB"></meta>
    <meta name="dcterms.release" content="Release 19"></meta>
  </head>
   <body dir="ltr">
      <div class="noscript alert alert-danger text-center" role="alert">
         <a href="Java-DOM-API-for-XMLType.html" class="pull-left"><span class="glyphicon glyphicon-chevron-left" aria-hidden="true"></span>上一页</a> <a href="XML-DB-and-ODP-for-dot-NET.html" class="pull-right">下一页<span class="glyphicon glyphicon-chevron-right" aria-hidden="true"></span></a> <span class="fa fa-exclamation-triangle" aria-hidden="true"></span>必须启用JavaScript才能正确显示此内容</div>
      <article>
         <header>
            <ol class="breadcrumb" vocab="http://schema.org/" typeof="BreadcrumbList">
               <li property="itemListElement" typeof="ListItem"><a href="index.html" property="item" typeof="WebPage"><span property="name">开发人员指南</span></a></li>
               <li property="itemListElement" typeof="ListItem"><a href="XMLType-APIs.html" property="item" typeof="WebPage"><span property="name">XMLType API</span></a></li>
               <li class="active" property="itemListElement" typeof="ListItem">用于XMLType的C DOM API</li>
            </ol>
            <a id="GUID-3530DFDE-0125-4A95-9DCA-29BA804F1BA9" name="GUID-3530DFDE-0125-4A95-9DCA-29BA804F1BA9"></a><a id="ADXDB1400"></a>
            
            <h2 id="ADXDB-GUID-3530DFDE-0125-4A95-9DCA-29BA804F1BA9" class="sect2"><span class="enumeration_chapter">14</span> C XML API for XMLType</h2>
         </header>
         <div class="ind">
            <div>
               <p><code class="codeph">XMLType</code>的C DOM API允许您使用C中的DOM操作<code class="codeph">XMLType</code>实例。</p>
            </div>
            <div>
               <ul class="ullinks">
                  <li class="ulchildlink"><a href="C-API-for-XMLType.html#GUID-C5C310E6-7CDD-45B7-9CD0-CC3FE74B6659">XMLType的C DOM API概述</a><br><code class="codeph">XMLType</code>的C DOM API是一个DOM API，用于Oracle XML Developer's Kit（XDK）和Oracle XML DB。您可以将它用于数据库内部或外部的XML数据。
                  </li>
                  <li class="ulchildlink"><a href="C-API-for-XMLType.html#GUID-DF6B7D2F-95D9-4B1A-827E-DD456E275E7B">使用OCI访问数据库中存储的XMLType数据</a><br>Oracle XML DB支持使用抽象数据类型<code class="codeph">XMLType</code>存储和操作XML实例。可以使用Oracle调用接口（OCI）和C DOM API for XML在客户端访问和操作这些XML实例。</li>
                  <li class="ulchildlink"><a href="C-API-for-XMLType.html#GUID-5E94BF15-CCE2-48BC-A692-6BEE4FC106A9">在客户端上创建XMLType实例</a><br>您可以使用C DOM API方法<code class="codeph">XMLCreateDocument()</code>和<code class="codeph">XmlLoadDom()</code>在客户端构造新的<code class="codeph">XMLType</code>实例。
                  </li>
                  <li class="ulchildlink"><a href="C-API-for-XMLType.html#GUID-10FA0209-10E6-49CC-B783-4340B221CB35">C DOM API函数的XML上下文参数</a><br><span class="italic">XML上下文</span>是所有C DOM API函数的必需参数。此不透明上下文封装有关数据编码，错误消息语言等的信息。对于Oracle XML Developer的Kit应用程序和Oracle XML DB，上下文的内容是不同的。</li>
                  <li class="ulchildlink"><a href="C-API-for-XMLType.html#GUID-8B2A5513-A30A-4F2E-ACA0-90BB9E533E8D">初始化和终止XML上下文</a><br>一个示例说明了一个C程序，它使用C DOM API构造XML文档并将其保存到Oracle数据库。
                  </li>
                  <li class="ulchildlink"><a href="C-API-for-XMLType.html#GUID-556A53A1-7522-4786-AAB8-157326B7DFEA">使用带有二进制XML的C API for XML</a><br>您可以使用C API for XML来读取或写入从Oracle XML DB编码为二进制XML的XML数据。这样做涉及通常的读写程序。
                  </li>
                  <li class="ulchildlink"><a href="C-API-for-XMLType.html#GUID-060FFEF3-A3C5-48EB-B008-D6496B5749A3">使用Oracle XML Developer的Kit Pull Parser和Oracle XML DB</a><br>您可以将Oracle XML Developer's Kit pull解析器与Oracle XML DB中的<code class="codeph">XMLType</code>实例一起使用。使用此解析器时，解析是按需完成的，因此您的应用程序将驱动解析过程。
                  </li>
                  <li class="ulchildlink"><a href="C-API-for-XMLType.html#GUID-687495C3-551B-4786-8A5F-F594985553E2">C中常见的XMLType操作</a><br>通用XML操作由C API for XML提供。</li>
               </ul>
               <div class="familylinks">
                  <div class="parentlink">
                     <p><strong>父主题：</strong> <a href="XMLType-APIs.html#GUID-6209297F-DBE4-4F31-85F1-4083BF5BDE01" title="您可以使用Oracle XML DB XMLType PL / SQL，Java，C API和Oracle Data Provider for .NET（ODP.NET）来访问和操作XML数据。">XMLType API</a></p>
                  </div>
               </div>
            </div>
            <a id="ADXDB4962"></a><div class="props_rev_3"><a id="GUID-C5C310E6-7CDD-45B7-9CD0-CC3FE74B6659" name="GUID-C5C310E6-7CDD-45B7-9CD0-CC3FE74B6659"></a><h3 id="ADXDB-GUID-C5C310E6-7CDD-45B7-9CD0-CC3FE74B6659" class="sect3"><span class="enumeration_section">14.1</span> XMLType的C DOM API概述</h3>
               <div>
                  <p><code class="codeph">XMLType</code>的C DOM API是一个DOM API，用于Oracle XML Developer's Kit（XDK）和Oracle XML DB。您可以将它用于数据库内部或外部的XML数据。
                  </p>
                  <p>DOM指的是符合万维网联盟（W3C）DOM 2.0建议书。</p>
                  <p><code class="codeph">XMLType</code>的C DOM API还包括可在XDK中用于传统存储XML数据的性能改进扩展，或者在Oracle XML DB中用作存储为表中的<code class="codeph">XMLType</code>列的扩展。
                  </p>
                  <div class="infoboxnote" id="GUID-C5C310E6-7CDD-45B7-9CD0-CC3FE74B6659__GUID-E7791695-608B-422C-A5B0-19D1A7FBD346">
                     <p class="notep1">注意：</p>
                     <p>支持Oracle Database 10g第1版之前版本的C DOM函数仅用于向后兼容。</p>
                  </div>
                  <p>对于C DOM API <code class="codeph">XMLType</code>上实现<code class="codeph">XMLType</code>在Oracle XML DB。在W3C DOM建议书中，术语“文档”用于广义上（URI，文件系统，内存缓冲区，标准输入和输出）。<code class="codeph">XMLType</code>的C DOM API是一个组合编程接口，包含Oracle XML Developer Kit和Oracle XML DB应用程序所需的所有功能。它提供了XSLT和XML Schema实现。虽然严格遵循DOM 2.0建议书，但从面向对象的DOM 2.0建议书到平面C命名空间的映射需要进行一些命名更改。例如，方法<code class="codeph">getName()</code>被重命名为<code class="codeph">getAttrName()</code> 。
                  </p>
                  <p><code class="codeph">XMLType</code>的C DOM API取代了旧的Oracle API。特别是， <code class="codeph">oraxml</code>接口（顶级，DOM，SAX和XSLT）和<code class="codeph">oraxsd.h</code> （Schema）接口将在以后的版本中弃用。
                  </p>
                  <p>可用于操作XML数据的C和C ++应用程序编程接口（API）的参考文档是<a href="../caxml/index.html" target="_blank"><span><cite>Oracle Database XML C API Reference</cite></span></a>和<a href="../cpxml/index.html" target="_blank"><span><cite>Oracle Database XML C ++ API Reference</cite></span></a> 。
                  </p>
               </div>
               <div>
                  <div class="infoboxnotealso" id="GUID-C5C310E6-7CDD-45B7-9CD0-CC3FE74B6659__GUID-BD28138B-325E-4844-B502-5D74CE997DDB">
                     <p class="notep1">也可以看看：</p>
                     <ul style="list-style-type:disc">
                        <li>
                           <p>有关XML的PL / SQL API的信息，请参阅<span class="italic">Oracle Database PL / SQL包和类型参考</span></p>
                        </li>
                        <li>
                           <p>有关适用于<a href="../jaxml/index.html" target="_blank"><span><cite>XML的Java API</cite></span></a>的信息，请参阅<a href="../jaxml/index.html" target="_blank"><span><cite>Oracle数据库XML Java API参考</cite></span></a></p>
                        </li>
                     </ul>
                  </div>
                  <div class="familylinks">
                     <div class="parentlink">
                        <p><strong>父主题：</strong> <a href="C-API-for-XMLType.html#GUID-3530DFDE-0125-4A95-9DCA-29BA804F1BA9" title="XMLType的C DOM API允许您使用C中的DOM操作XMLType实例。">XMLType的C DOM API</a></p>
                     </div>
                  </div>
               </div>
               
            </div><a id="ADXDB4964"></a><div class="props_rev_3"><a id="GUID-DF6B7D2F-95D9-4B1A-827E-DD456E275E7B" name="GUID-DF6B7D2F-95D9-4B1A-827E-DD456E275E7B"></a><h3 id="ADXDB-GUID-DF6B7D2F-95D9-4B1A-827E-DD456E275E7B" class="sect3"><span class="enumeration_section">14.2</span>使用OCI访问数据库中存储的XMLType数据</h3>
               <div>
                  <p>Oracle XML DB支持使用抽象数据类型<code class="codeph">XMLType</code>存储和操作XML实例。可以使用Oracle调用接口（OCI）和C DOM API for XML在客户端访问和操作这些XML实例。</p>
                  <p>您可以使用C DOM结构<code class="codeph">xmldocnode</code>绑定和定义<code class="codeph">XMLType</code>值。此结构可用于在OCI语句中绑定，定义和操作XML值。您可以使用OCI语句从服务器中选择XML数据，然后可以将其与C DOM API函数一起使用。同样，值可以直接绑定回SQL语句。
                  </p>
                  <p>应用程序的主要流程包括初始化常用的OCI句柄，例如服务器句柄和语句句柄，然后初始化XML上下文参数。然后，您可以对数据库中的XML实例进行操作，也可以在客户端创建新实例。初始化的XML上下文可以与所有C DOM函数一起使用。</p>
                  <div class="section"></div>
                  <!-- class="section" -->
               </div>
               <div>
                  <div class="relinfo">
                     <p><strong>相关话题</strong></p>
                     <ul>
                        <li><a href="C-API-for-XMLType.html#GUID-10FA0209-10E6-49CC-B783-4340B221CB35" title="XML上下文是所有C DOM API函数的必需参数。此不透明上下文封装有关数据编码，错误消息语言等的信息。对于Oracle XML Developer的Kit应用程序和Oracle XML DB，上下文的内容是不同的。">C DOM API函数的XML上下文参数</a></li>
                     </ul>
                  </div>
                  <div class="familylinks">
                     <div class="parentlink">
                        <p><strong>父主题：</strong> <a href="C-API-for-XMLType.html#GUID-3530DFDE-0125-4A95-9DCA-29BA804F1BA9" title="XMLType的C DOM API允许您使用C中的DOM操作XMLType实例。">XMLType的C DOM API</a></p>
                     </div>
                  </div>
               </div>
               
            </div><a id="ADXDB4965"></a><div class="props_rev_3"><a id="GUID-5E94BF15-CCE2-48BC-A692-6BEE4FC106A9" name="GUID-5E94BF15-CCE2-48BC-A692-6BEE4FC106A9"></a><h3 id="ADXDB-GUID-5E94BF15-CCE2-48BC-A692-6BEE4FC106A9" class="sect3"><span class="enumeration_section">14.3</span>在客户端上创建XMLType实例</h3>
               <div>
                  <p>您可以使用C DOM API方法<code class="codeph">XMLCreateDocument()</code>和<code class="codeph">XmlLoadDom()</code>在客户端构造新的<code class="codeph">XMLType</code>实例。
                  </p>
                  <div class="section">
                     <p>您可以使用<code class="codeph">XMLCreateDocument()</code>构造空的<code class="codeph">XMLType</code>实例。这类似于将<code class="codeph">OCIObjectNew()</code>用于其他类型。
                     </p>
                     <p>您使用<code class="codeph">XmlLoadDom()</code>构造一个非空的<code class="codeph">XMLType</code>实例，如下所示：</p>
                  </div>
                  <!-- class="section" -->
                  <ol>
                     <li><span>像<a href="C-API-for-XMLType.html#GUID-8B2A5513-A30A-4F2E-ACA0-90BB9E533E8D__CHDGCGGE">例14-1中</a>那样初始化<code class="codeph">xmlctx</code> 。</span></li>
                     <li><span>从用户缓冲区，本地文件或URI构造XML数据。返回值a（ <code class="codeph">xmldocnode*</code> ）可以在其他常见C API中使用。</span></li>
                     <li><span>如果需要，可以将（ <code class="codeph">xmldocnode *</code> ）转换为（ <code class="codeph">void*</code> ）并直接将其作为绑定值提供。</span></li>
                  </ol>
               </div>
               <div>
                  <div class="familylinks">
                     <div class="parentlink">
                        <p><strong>父主题：</strong> <a href="C-API-for-XMLType.html#GUID-3530DFDE-0125-4A95-9DCA-29BA804F1BA9" title="XMLType的C DOM API允许您使用C中的DOM操作XMLType实例。">XMLType的C DOM API</a></p>
                     </div>
                  </div>
               </div>
               
            </div><a id="ADXDB4966"></a><div class="props_rev_3"><a id="GUID-10FA0209-10E6-49CC-B783-4340B221CB35" name="GUID-10FA0209-10E6-49CC-B783-4340B221CB35"></a><h3 id="ADXDB-GUID-10FA0209-10E6-49CC-B783-4340B221CB35" class="sect3"><span class="enumeration_section">14.4</span> C DOM API函数的XML上下文参数</h3>
               <div>
                  <p><span class="italic">XML上下文</span>是所有C DOM API函数的必需参数。此不透明上下文封装有关数据编码，错误消息语言等的信息。对于Oracle XML Developer的Kit应用程序和Oracle XML DB，上下文的内容是不同的。</p>
                  <div class="section">
                     <p>对于Oracle XML DB，OCI分别用于<code class="codeph">OCIXmlDbInitXmlCtx()</code>和<code class="codeph">OCIXmlDbFreeXmlCtx()</code> ，初始化和终止XML上下文。
                     </p>
                  </div>
                  <!-- class="section" -->
               </div>
               <div>
                  <ul class="ullinks">
                     <li class="ulchildlink"><a href="C-API-for-XMLType.html#GUID-71C33EF4-ED8C-4C61-8BDA-C1177F2CAA30">OCIXmlDbInitXmlCtx（）语法</a><br>OCI函数<code class="codeph">OCIXmlDbInitXmlCtx()</code>初始化XML上下文。
                     </li>
                     <li class="ulchildlink"><a href="C-API-for-XMLType.html#GUID-22790786-C29D-4D86-8108-46586E41CF1C">OCIXmlDbFreeXmlCtx（）语法</a><br>OCI函数<code class="codeph">OCIXmlDbFreeXmlCtx()</code>终止XML上下文。
                     </li>
                  </ul>
                  <div class="familylinks">
                     <div class="parentlink">
                        <p><strong>父主题：</strong> <a href="C-API-for-XMLType.html#GUID-3530DFDE-0125-4A95-9DCA-29BA804F1BA9" title="XMLType的C DOM API允许您使用C中的DOM操作XMLType实例。">XMLType的C DOM API</a></p>
                     </div>
                  </div>
               </div>
               <a id="ADXDB4968"></a><a id="ADXDB4967"></a><div class="props_rev_3"><a id="GUID-71C33EF4-ED8C-4C61-8BDA-C1177F2CAA30" name="GUID-71C33EF4-ED8C-4C61-8BDA-C1177F2CAA30"></a><h4 id="ADXDB-GUID-71C33EF4-ED8C-4C61-8BDA-C1177F2CAA30" class="sect4"><span class="enumeration_section">14.4.1</span> OCIXmlDbInitXmlCtx（）语法</h4>
                  <div>
                     <p>OCI函数<code class="codeph">OCIXmlDbInitXmlCtx()</code>初始化XML上下文。
                     </p>
                     <div class="section">
                        <p><code class="codeph">OCIXmlDbInitXmlCtx()</code>的语法如下：</p><pre class="pre codeblock"><code>xmlctx * OCIXmlDbInitXMlCtx（OCIEnv * envhp，OCISvcHp * svchp，OCIError * errhp，ocixmldbparam * params，ub4 num_params）;</code></pre><p>参数说明如<a href="C-API-for-XMLType.html#GUID-71C33EF4-ED8C-4C61-8BDA-C1177F2CAA30__BGGHEDDH" title="该表描述了OCIXmlDBlInitXmlCtx参数。">表14-1所示</a> 。
                        </p>
                     </div>
                     <!-- class="section" -->
                     <div class="tblformal" id="GUID-71C33EF4-ED8C-4C61-8BDA-C1177F2CAA30__BGGHEDDH">
                        <p class="titleintable">表14-1 OCIXmlDbInitXMlCtx（）参数</p>
                        <table cellpadding="4" cellspacing="0" class="Formal" title="OCIXmlDbInitXMlCtx（）参数" width="100%" border="1" summary="This table describes the OCIXmlDBlInitXmlCtx parameters." frame="hsides" rules="rows">
                           <thead>
                              <tr align="left" valign="top">
                                 <th align="left" valign="bottom" width="23%" id="d76905e526">参数</th>
                                 <th align="left" valign="bottom" width="77%" id="d76905e529">描述</th>
                              </tr>
                           </thead>
                           <tbody>
                              <tr align="left" valign="top">
                                 <td align="left" valign="top" width="23%" id="d76905e534" headers="d76905e526 ">
                                    <p><code class="codeph">envhp（IN）</code></p>
                                 </td>
                                 <td align="left" valign="top" width="77%" headers="d76905e534 d76905e529 ">
                                    <p>OCI环境处理。</p>
                                 </td>
                              </tr>
                              <tr align="left" valign="top">
                                 <td align="left" valign="top" width="23%" id="d76905e542" headers="d76905e526 ">
                                    <p><code class="codeph">svchp（IN）</code></p>
                                 </td>
                                 <td align="left" valign="top" width="77%" headers="d76905e542 d76905e529 ">
                                    <p>OCI服务处理。</p>
                                 </td>
                              </tr>
                              <tr align="left" valign="top">
                                 <td align="left" valign="top" width="23%" id="d76905e550" headers="d76905e526 ">
                                    <p><code class="codeph">errhp（IN）</code></p>
                                 </td>
                                 <td align="left" valign="top" width="77%" headers="d76905e550 d76905e529 ">
                                    <p>OCI错误句柄。</p>
                                 </td>
                              </tr>
                              <tr align="left" valign="top">
                                 <td align="left" valign="top" width="23%" id="d76905e558" headers="d76905e526 ">
                                    <p><code class="codeph">参数（IN）</code></p>
                                 </td>
                                 <td align="left" valign="top" width="77%" headers="d76905e558 d76905e529 ">
                                    <p>一组可选值：</p>
                                    <ul style="list-style-type:disc">
                                       <li>
                                          <p>OCI持续时间。默认值为<code class="codeph">OCI_DURATION_SESSION</code> 。</p>
                                       </li>
                                       <li>
                                          <p>错误处理程序，这是一个用户注册的回调：</p><pre class="pre codeblock"><code>void（* err_handler）（sword errcode，（CONST OraText *）errmsg）;</code></pre></li>
                                    </ul>
                                 </td>
                              </tr>
                              <tr align="left" valign="top">
                                 <td align="left" valign="top" width="23%" id="d76905e578" headers="d76905e526 ">
                                    <p><code class="codeph">num_params（IN）</code></p>
                                 </td>
                                 <td align="left" valign="top" width="77%" headers="d76905e578 d76905e529 ">
                                    <p>从<code class="codeph">params</code>读取的参数数量。
                                    </p>
                                 </td>
                              </tr>
                           </tbody>
                        </table>
                     </div>
                     <!-- class="inftblhruleinformal" -->
                  </div>
                  <div>
                     <div class="familylinks">
                        <div class="parentlink">
                           <p><strong>父主题：</strong> <a href="C-API-for-XMLType.html#GUID-10FA0209-10E6-49CC-B783-4340B221CB35" title="XML上下文是所有C DOM API函数的必需参数。此不透明上下文封装有关数据编码，错误消息语言等的信息。对于Oracle XML Developer的Kit应用程序和Oracle XML DB，上下文的内容是不同的。">C DOM API函数的XML上下文参数</a></p>
                        </div>
                     </div>
                  </div>
                  
               </div><a id="ADXDB4969"></a><div class="props_rev_3"><a id="GUID-22790786-C29D-4D86-8108-46586E41CF1C" name="GUID-22790786-C29D-4D86-8108-46586E41CF1C"></a><h4 id="ADXDB-GUID-22790786-C29D-4D86-8108-46586E41CF1C" class="sect4"><span class="enumeration_section">14.4.2</span> OCIXmlDbFreeXmlCtx（）语法</h4>
                  <div>
                     <p>OCI函数<code class="codeph">OCIXmlDbFreeXmlCtx()</code>终止XML上下文。
                     </p>
                     <div class="section">
                        <p><code class="codeph">OCIXmlDbFreeXmlCtx()</code>的语法如下，其中参数<code class="codeph">xctx (IN)</code>是要终止的XML上下文：</p><pre class="pre codeblock"><code>void OCIXmlDbFreeXmlCtx（xmlctx * xctx）;</code></pre></div>
                     <!-- class="section" -->
                  </div>
                  <div>
                     <div class="familylinks">
                        <div class="parentlink">
                           <p><strong>父主题：</strong> <a href="C-API-for-XMLType.html#GUID-10FA0209-10E6-49CC-B783-4340B221CB35" title="XML上下文是所有C DOM API函数的必需参数。此不透明上下文封装有关数据编码，错误消息语言等的信息。对于Oracle XML Developer的Kit应用程序和Oracle XML DB，上下文的内容是不同的。">C DOM API函数的XML上下文参数</a></p>
                        </div>
                     </div>
                  </div>
                  
               </div>
            </div><a id="ADXDB4971"></a><a id="ADXDB4970"></a><div class="props_rev_3"><a id="GUID-8B2A5513-A30A-4F2E-ACA0-90BB9E533E8D" name="GUID-8B2A5513-A30A-4F2E-ACA0-90BB9E533E8D"></a><h3 id="ADXDB-GUID-8B2A5513-A30A-4F2E-ACA0-90BB9E533E8D" class="sect3"><span class="enumeration_section">14.5</span>初始化和终止XML上下文</h3>
               <div>
                  <p>一个示例说明了一个C程序，它使用C DOM API构造XML文档并将其保存到Oracle数据库。</p>
                  <div class="section">
                     <p><a href="C-API-for-XMLType.html#GUID-8B2A5513-A30A-4F2E-ACA0-90BB9E533E8D__CHDGCGGE">例14-1</a>显示了这一点。构造的文档存储在表<code class="codeph">my_table</code> 。OCI函数<code class="codeph">OCIXmlDbInitXmlCtx()</code>和<code class="codeph">OCIXmlDbFreeXmlCtx()</code>分别用于初始化和终止XML上下文。这些函数在头文件<code class="codeph">ocixmldb.h</code>中定义。
                     </p>
                     <p>该代码使用辅助函数<code class="codeph">exec_bind_xml</code> ， <code class="codeph">init_oci_handles</code>和<code class="codeph">free_oci_handles</code> ，这些函数未在此处列出。此示例的完整列表（包括帮助程序函数）可在<a href="oracle-supplied-XML-schemas-and-examples.html#GUID-8FCAD86A-3BF9-4B20-A9EE-8FC46C95C3CE" title="此处提供了完整列表，包括Oracle XML DB提供的XML模式，采购订单XML模式和各种示例中使用的XSLT样式表，以及用于将XML内容加载到Oracle XML DB并初始化和终止的XML语言（OCI）示例。 XML上下文。">Oracle提供的XML架构和示例</a> ， <a href="oracle-supplied-XML-schemas-and-examples.html#GUID-8CA90A5B-999C-49B6-A2FD-41427C332F17" title="示例显示如何使用OCI函数OCIXmlDbInitXmlCtx（）和OCIXmlDbFreeXmlCtx（）来初始化和终止XML上下文。它使用C DOM API构造XML文档并将其保存到数据库中。">初始化和终止XML上下文（OCI）中找到</a> 。
                     </p>
                     <p><a href="C-API-for-XMLType.html#GUID-8B2A5513-A30A-4F2E-ACA0-90BB9E533E8D__CHDGCGGE">例14-1中</a>的C代码假定首先执行了以下SQL代码以在数据库模式<code class="codeph">capiuser</code>创建表<code class="codeph">my_table</code> ：</p><pre class="pre codeblock"><code>CONNECT CAPIUSER输入密码： <span class="italic">密码</span>已连接。CREATE TABLE my_table OF XMLType;</code></pre><p><a href="C-API-for-XMLType.html#GUID-687495C3-551B-4786-8A5F-F594985553E2__CHDBIHJI">示例14-4</a>查询表<code class="codeph">my_table</code>以显示<a href="C-API-for-XMLType.html#GUID-8B2A5513-A30A-4F2E-ACA0-90BB9E533E8D__CHDGCGGE">示例14-1</a>插入的数据。
                     </p>
                  </div>
                  <!-- class="section" -->
                  <div class="example" id="GUID-8B2A5513-A30A-4F2E-ACA0-90BB9E533E8D__CHDGCGGE">
                     <p class="titleinexample">例14-1使用OCIXMLDBINITXMLCTX（）和OCIXMLDBFREEXMLCTX（）</p><pre class="pre codeblock"><code>#ifndef S_ORACLE #endif #ifndef ORATYPES_ORACLE #include &lt;oratypes.h&gt; #endif #ifndef XML_ORACLE #include &lt;xml.h&gt; #endif #ifndef OCIXML_ORACLE #include &lt;ocixml.h&gt; #endif #ifndef OCI_ORACLE #include &lt;oci.h &gt; #endif #include &lt;string.h&gt; typedef struct test_ctx {OCIEnv * envhp; OCIError * errhp; OCISvcCtx * svchp; OCIStmt * stmthp; OCIServer * srvhp; OCIDuration dur; OCISession * sesshp; oratext * username; oratext *密码; } test_ctx; / * Helper函数1：执行绑定xml数据的sql语句* / static sword <span class="bold">exec_bind_xml</span> （OCISvcCtx * svchp，OCIError * errhp，OCIStmt * stmthp，void * xml，OCIType * xmltdo，OraText * sqlstmt）; / * Helper函数2：初始化OCI句柄并连接* / static sword <span class="bold">init_oci_handles</span> （test_ctx * ctx）; / *助手功能3：免费OCI句柄和断开* /静态<span class="bold">剑free_oci_handles</span> （test_ctx * ctx）; void <span class="bold">main</span> （）{test_ctx temp_ctx; test_ctx * ctx =＆temp_ctx; OCIType * xmltdo =（OCIType *）0; xmldocnode * doc =（xmldocnode *）0; ocixmldbparam params [1]; xmlnode * quux，* foo，* foo_data，* top; xmlerr错误;剑状态= 0; xmlctx * xctx; oratext ins_stmt [] =“插入my_table值（：1）”; oratext tlpxml_test_sch [] =“ <span class="bold">&lt;TOP /&gt;</span> ”; ctx-&gt; username =（oratext *）“capiuser”; ctx-&gt; password =（oratext *）“***********”; / *替换为真实密码* / / *初始化envhp，svchp，errhp，dur，stmthp * / init_oci_handles（ctx）; / *获取xml上下文* / params [0] .name_ocixmldbparam = XCTXINIT_OCIDUR; params [0] .value_ocixmldbparam =＆ctx-&gt; dur; xctx = <span class="bold">OCIXmlDbInitXmlCtx</span> （ctx-&gt; envhp，ctx-&gt; svchp，ctx-&gt; errhp，params，1）; / *开始处理 - 首先，检查这个DOM是否支持XML 1.0 * / printf（“\ n \ n支持XML 1.0？：％s \ n”， <span class="bold">XmlHasFeature</span> （xctx，（oratext *）“xml”，（oratext *）“ 1.0“）？“是”：“否”）; / *解析文档* / if（！（doc = <span class="bold">XmlLoadDom</span> （xctx，＆err，“buffer”，tlpxml_test_sch，“buffer_length”，sizeof（tlpxml_test_sch）-1，“validate”，TRUE，NULL）））{printf（“Parse failed，code％d \ n”，err ）; } else {/ *获取文档元素* / top =（xmlnode *） <span class="bold">XmlDomGetDocElem</span> （xctx，doc）; / *打印出顶部元素* / printf（“\ n \ nOriginal top element is：\ n”）; <span class="bold">XmlSaveDom</span> （xctx，＆err，top，“stdio”，stdout，NULL）; / *打印出文件。这些变化反映在这里* / printf（“\ n \ nOriginal document is：\ n”）; <span class="bold">XmlSaveDom</span> （xctx，＆err，（xmlnode *）doc，“stdio”，stdout，NULL）; / *创建一些元素并将它们添加到文档中* / quux =（xmlnode *） <span class="bold">XmlDomCreateElem</span> （xctx，doc，（oratext *）“ <span class="bold">QUUX</span> ”）; foo =（xmlnode *） <span class="bold">XmlDomCreateElem</span> （xctx，doc，（oratext *）“ <span class="bold">FOO</span> ”）; foo_data =（xmlnode *） <span class="bold">XmlDomCreateText</span> （xctx，doc，（oratext *）“ <span class="bold">data</span> ”）; foo_data = <span class="bold">XmlDomAppendChild</span> （xctx，（xmlnode *）foo，（xmlnode *）foo_data）; foo = <span class="bold">XmlDomAppendChild</span> （xctx，quux，foo）; quux = <span class="bold">XmlDomAppendChild</span> （xctx，top，quux）; / *打印出顶部元素* / printf（“\ n \ n现在顶部元素是：\ n”）; <span class="bold">XmlSaveDom</span> （xctx，＆err，top，“stdio”，stdout，NULL）; / *打印出文件。这些变化反映在这里* / printf（“\ n \ n现在文件是：\ n”）; <span class="bold">XmlSaveDom</span> （xctx，＆err，（xmlnode *）doc，“stdio”，stdout，NULL）; / *将文档插入my_table * / status = OCITypeByName（ctx-&gt; envhp，ctx-&gt; errhp，ctx-&gt; svchp，（const text *）“SYS”，（ub4）strlen（（char *）“SYS”） ，（const text *）“XMLTYPE”，（ub4）strlen（（char *）“XMLTYPE”），（CONST text *）0，（ub4）0，OCI_DURATION_SESSION，OCI_TYPEGET_HEADER，（OCIType **）＆xmltdo）; if（status == OCI_SUCCESS）{exec_bind_xml（ctx-&gt; svchp，ctx-&gt; errhp，ctx-&gt; stmthp，（void *）doc，xmltdo，ins_stmt）; / * Free xml ctx * / <span class="bold">OCIXmlDbFreeXmlCtx</span> （xctx）; / *免费envhp，svchp，errhp，stmthp * / free_oci_handles（ctx）; }</code></pre><p>编译和运行此C程序的输出如下：</p><pre class="oac_no_warn" dir="ltr">支持XML 1.0？ ：YES原始顶部元素是：&lt;TOP /&gt;原始文档是：&lt;TOP /&gt;现在顶部元素是：&lt;TOP&gt; &lt;QUUX&gt; &lt;FOO&gt;数据&lt;/ FOO&gt; &lt;/ QUUX&gt; &lt;/ TOP&gt;现在文档是：&lt;TOP&gt; &lt;QUUX&gt; &lt;FOO&gt;数据&lt;/ FOO&gt; &lt;/ QUUX&gt; &lt;/ TOP&gt;</pre><p>这是在<code class="codeph">my_table</code>中查询构造文档的结果：</p><pre class="oac_no_warn" dir="ltr">SELECT * FROM my_table; SYS_NC_ROWINFO $ --------------- &lt;TOP&gt; &lt;QUUX&gt; &lt;FOO&gt;数据&lt;/ FOO&gt; &lt;/ QUUX&gt; &lt;/ TOP&gt;选择1行。
</pre></div>
                  <!-- class="example" -->
               </div>
               <div>
                  <div class="familylinks">
                     <div class="parentlink">
                        <p><strong>父主题：</strong> <a href="C-API-for-XMLType.html#GUID-3530DFDE-0125-4A95-9DCA-29BA804F1BA9" title="XMLType的C DOM API允许您使用C中的DOM操作XMLType实例。">XMLType的C DOM API</a></p>
                     </div>
                  </div>
               </div>
               
            </div><a id="ADXDB4977"></a><a id="ADXDB4976"></a><div class="props_rev_3"><a id="GUID-556A53A1-7522-4786-AAB8-157326B7DFEA" name="GUID-556A53A1-7522-4786-AAB8-157326B7DFEA"></a><h3 id="ADXDB-GUID-556A53A1-7522-4786-AAB8-157326B7DFEA" class="sect3"><span class="enumeration_section">14.6</span>使用带有二进制XML的C API for XML</h3>
               <div>
                  <p>您可以使用C API for XML来读取或写入从Oracle XML DB编码为二进制XML的XML数据。这样做涉及通常的读写程序。</p>
                  <div class="section">
                     <p>二进制XML是一种紧凑的XML Schema感知XML数据编码。您可以将二进制XML用作数据库中<code class="codeph">XMLType</code>数据的存储模型，但也可以将其用于位于数据库外部的XML数据。
                     </p>
                     <p>二进制XML数据是XML Schema感知的，它可以根据您的需要使用各种编码方案。为了操作二进制XML数据，您必须同时拥有关于相关XML模式和编码的数据和元数据。</p>
                     <p>对于存储在数据库中的<code class="codeph">XMLType</code>数据，此元数据也存储在数据库中。但是，根据数据库和数据的设置方式，元数据可能与应用的数据不在同一服务器上。如果是这种情况，那么，在您从数据库读取或写入二进制XML数据之前，必须执行以下步骤：</p>
                     <ol>
                        <li>
                           <p>为元数据创建上下文实例。</p>
                        </li>
                        <li>
                           <p>将此上下文与用于访问数据库中的二进制XML数据的数据连接相关联。数据连接可以是专用连接（ <code class="codeph">OCISvcCtx</code> ）或连接池（ <code class="codeph">OCICPool</code> ）。
                           </p>
                        </li>
                     </ol>
                     <p>然后，当您的应用程序需要对数据连接上的二进制XML数据进行编码或解码时，它会自动获取所需的元数据。如<a href="C-API-for-XMLType.html#GUID-556A53A1-7522-4786-AAB8-157326B7DFEA__CHDEHEHF">例14-2所示</a> ，整个行动顺序如下：</p>
                     <ol>
                        <li>
                           <p>为环境（ <code class="codeph">OCIEnv</code> ），连接（ <code class="codeph">OCISvcCtx</code> ）和错误上下文（ <code class="codeph">OCIError</code> ）创建通常的OCI句柄。
                           </p>
                        </li>
                        <li>
                           <p>根据需要创建一个或多个元数据上下文。元数据上下文有时被称为元数据存储库， <code class="codeph">OCIBinXMLReposCtx</code>是OCI上下文数据结构。您可以使用<code class="codeph">OCIBinXMLCreateReposCtxFromConn</code>从专用连接和<code class="codeph">OCIBinXMLCreateReposCtxFromCPool</code>创建元数据上下文，以从连接池创建上下文。
                           </p>
                        </li>
                        <li>
                           <p>将元数据上下文与二进制XML数据连接相关联。您可以使用<code class="codeph">OCIBinXmlSetReposCtxForConn</code>执行此操作。
                           </p>
                        </li>
                        <li>
                           <p>（可选）如果XML数据源自数据库之外，请使用<code class="codeph">setPicklePreference</code>指定从现在开始要以二进制XML格式发送到数据库的XML数据。这适用于DOM文档（ <code class="codeph">xmldomdoc</code> ）。如果未指定二进制XML，则数据将存储为文本（ <code class="codeph">CLOB</code> ）。
                           </p>
                        </li>
                        <li>
                           <p>使用OCI库从数据库读取和写入XML数据。只要需要对二进制XML文档进行编码或解码，就会使用元数据上下文自动获取必要的元数据。使用C DOM API for XML在客户端级别对XML数据进行操作。</p>
                        </li>
                     </ol>
                  </div>
                  <!-- class="section" -->
                  <div class="section">
                     <div class="infoboxnotealso" id="GUID-556A53A1-7522-4786-AAB8-157326B7DFEA__GUID-485AD655-204D-4965-8517-F4D163801F48">
                        <p class="notep1">也可以看看：</p>
                        <p><a href="../adxdk/using-binary-XML-with-C.html#ADXDK1810" target="_blank"><span><cite>Oracle XML Developer's Kit程序员指南</cite></span></a></p>
                     </div>
                  </div>
                  <!-- class="section" -->
                  <div class="example" id="GUID-556A53A1-7522-4786-AAB8-157326B7DFEA__CHDEHEHF">
                     <p class="titleinexample">示例14-2使用带有二进制XML的XML的C API</p><pre class="oac_no_warn" dir="ltr"><span class="bold">。 。 。</span>/ *私有类型和常量* / #define SCHEMA（OraText *）“SYS”#define TYPE（OraText *）“XMLTYPE”#define USER（OraText *）“oe”#define USER_LEN（ub2）（strlen（（char *） ）USER））＃define PWD（OraText *）“oe”#define PWD_LEN（ub2）（strlen（（char *）PWD））＃define NUM_PARAMS 1 static void checkerr（OCIError * errhp，sword status）; static sword create_env（OraText * user，ub2 user_len，OraText * pwd，ub2 pwd_len，OCIEnv ** envhp，OCISvcCtx ** svchp，OCIError ** errhp）; static sword run_example（OCIEnv * envhp，OCISvcCtx * svchp，OCIError * errhp，OCIDuration dur）; static void cleanup（OCIEnv * envhp，OCISvcCtx * svchp，OCIError * errhp）; int <span class="bold">main</span> （int argc，char * argv []）{OCIEnv * envhp; <span class="bold">OCISvcCtx</span> * svchp; OCIError * errhp; printf（“***启动二进制XML示例程序\ n”）; if（create_env（USER，USER_LEN，PWD，PWD_LEN，＆envhp，＆svchp，＆errhp））{printf（“FAILED：create_env（）\ n”）;清理（envhp，svchp，errhp）;返回OCI_ERROR; } if（run_example（envhp，svchp，errhp，OCI_DURATION_SESSION））{printf（“FAILED：run_example（）\ n”）;清理（envhp，svchp，errhp）;返回OCI_ERROR;清理（envhp，svchp，errhp）; printf（“***完成二进制XML示例\ n”）;返回OCI_SUCCESS; } static sword <span class="bold">create_env</span> （OraText * user，ub2 user_len，OraText * pwd，ub2 pwd_len，OCIEnv ** envhp，OCISvcCtx ** svchp，OCIError ** errhp）{sword status; OCIServer * srvhp; OCISession * usrp; OCICPool * poolhp; OraText * poolname; ub4 poolnamelen; OraText * database =（OraText *）“”; <span class="bold">OCIBinXmlReposCtx</span> * rctx; / *创建并初始化环境。分配错误句柄。* / <span class="bold">。 。 。</span>if（（status = OCIConnectionPoolCreate（（dvoid *）* envhp，（dvoid *）* errhp，（dvoid *）poolhp，＆poolname，（sb4 *）＆poolnamelen，（OraText *）0，（sb4）0,1,10， 1，（OraText *）USER，（sb4）USER_LEN，（OraText *）PWD，（sb4）PWD_LEN，OCI_DEFAULT））！= OCI_SUCCESS）{printf（“OCIConnectionPoolCreate  -  Fail％d \ n”，status）;返回OCI_ERROR; } status = OCILogon2（（OCIEnv *）* envhp，* errhp，svchp，（OraText *）USER，（ub4）USER_LEN，（const oratext *）PWD，（ub4）PWD_LEN，（const oratext *）poolname，poolnamelen，OCI_CPOOL ）; if（status）{printf（“OCILogon2  -  Fail％d \ n”，status）;返回OCI_ERROR; } <span class="bold">OCIBinXmlCreateReposCtxFromCPool</span> （* envhp，poolhp，* errhp，＆rctx）; <span class="bold">OCIBinXmlSetReposCtxForConn</span> （* svchp，rctx）;返回OCI_SUCCESS; } static sword <span class="bold">run_example</span> （OCIEnv * envhp，OCISvcCtx * svchp，OCIError * errhp，OCIDuration dur）{OCIType * xmltdo =（OCIType *）0; OCIStmt * stmthp; OCIDefine * defnp; xmldocnode * xmldoc =（xmldocnode *）0; ub4 xmlsize = 0; text * selstmt =（text *）“SELECT doc FROM po_binxmltab”;剑的地位; struct xmlctx * xctx =（xmlctx *）0; ocixmldbparam params [NUM_PARAMS]; xmlerr xerr =（xmlerr）0; / *获取XMLType的类型定义。分配语句句柄。准备SELECT语句。为XMLType定义变量。执行语句。* / <span class="bold">。 。 。</span>/ *构造xmlctx以使用XML C API * / params [0] .name_ocixmldbparam = XCTXINIT_OCIDUR; params [0] .value_ocixmldbparam =＆dur; xctx = OCIXmlDbInitXmlCtx（envhp，svchp，errhp，params，NUM_PARAMS）; / *将结果打印到本地字符串* / XmlSaveDom（xctx，＆xerr，（xmlnode *）xmldoc，“stdio”，stdout，NULL）; / *免费实例* / <span class="bold">。 。 。</span>}</pre></div>
                  <!-- class="example" -->
               </div>
               <div>
                  <div class="relinfo">
                     <p><strong>相关话题</strong></p>
                     <ul>
                        <li><a href="intro-to-XML-DB.html#GUID-B8507F44-B010-4384-94E6-101131DD7D88" title="XMLType是一种抽象数据类型，它提供了不同的存储模型，以最好地适应您的数据及其使用。作为抽象数据类型，您的应用程序和数据库查询可以获得灵活性：所有XMLType操作都可以使用相同的接口。">XMLType存储模型</a></li>
                     </ul>
                  </div>
                  <div class="familylinks">
                     <div class="parentlink">
                        <p><strong>父主题：</strong> <a href="C-API-for-XMLType.html#GUID-3530DFDE-0125-4A95-9DCA-29BA804F1BA9" title="XMLType的C DOM API允许您使用C中的DOM操作XMLType实例。">XMLType的C DOM API</a></p>
                     </div>
                  </div>
               </div>
               
            </div><a id="ADXDB4979"></a><a id="ADXDB4978"></a><div class="props_rev_3"><a id="GUID-060FFEF3-A3C5-48EB-B008-D6496B5749A3" name="GUID-060FFEF3-A3C5-48EB-B008-D6496B5749A3"></a><h3 id="ADXDB-GUID-060FFEF3-A3C5-48EB-B008-D6496B5749A3" class="sect3"><span class="enumeration_section">14.7</span>使用Oracle XML Developer's Kit将Parser与Oracle XML DB一起使用</h3>
               <div>
                  <p>您可以将Oracle XML Developer's Kit pull解析器与Oracle XML DB中的<code class="codeph">XMLType</code>实例一起使用。使用此解析器时，解析是按需完成的，因此您的应用程序将驱动解析过程。
                  </p>
                  <div class="section">
                     <p>您的应用程序通过一系列事件访问XML文档，包括开始标记，结束标记和注释，就像在Simple API for XML（SAX）解析中一样。但是，与SAX解析的情况不同，解析事件由回调处理，在解析中，应用程序调用方法仅在需要时请求（拉）事件。这使应用程序可以更好地控制XML处理。特别是，使用pull解析器的过滤比使用SAX解析器更灵活。</p>
                     <p>您还可以使用Oracle XML Developer的Kit pull解析器来执行基于流的XML Schema验证。</p>
                     <p><a href="C-API-for-XMLType.html#GUID-060FFEF3-A3C5-48EB-B008-D6496B5749A3__CHDIFDBE">例14-3</a>显示了如何将Oracle XML DB pull解析器与<code class="codeph">XMLType</code>实例一起使用。要使用pull解析器，还需要UNIX和Linux系统上的静态库<code class="codeph">libxml10.a</code>或Microsoft Windows系统上的<code class="codeph">oraxml10.dll</code> 。您还需要头文件<code class="codeph">xmlev.h</code> 。
                     </p>
                     <div class="infoboxnotealso" id="GUID-060FFEF3-A3C5-48EB-B008-D6496B5749A3__GUID-D9D74E5C-F57E-4528-9592-2731705A0CAB">
                        <p class="notep1">也可以看看：</p>
                        <ul style="list-style-type:disc">
                           <li>
                              <p><a href="../adxdk/using-XML-parser-for-C.html#ADXDK1410" target="_blank"><span><cite>Oracle XML Developer's Kit程序员指南</cite></span></a> ，了解有关Oracle XML Developer's Kit pull解析器的信息</p>
                           </li>
                           <li>
                              <p><a href="../adxdk/using-XML-schema-processor-for-C.html#ADXDK1600" target="_blank"><span><cite>Oracle XML Developer's Kit程序员指南</cite></span></a> ，了解有关使用pull解析器进行基于流的验证的信息</p>
                           </li>
                        </ul>
                     </div>
                  </div>
                  <!-- class="section" -->
                  <div class="example" id="GUID-060FFEF3-A3C5-48EB-B008-D6496B5749A3__CHDIFDBE">
                     <p class="titleinexample">示例14-3使用Oracle XML DB Pull Parser</p><pre class="oac_no_warn" dir="ltr">#define MAXBUFLEN 64 * 1024 void main（）{test_ctx temp_ctx; test_ctx * ctx =＆temp_ctx; OCIType * xmltdo =（OCIType *）0; ocixmldbparam params [1];剑状态= 0; xmlctx * xctx; OCIDefine * defnp =（OCIDefine *）0; oratext sel_stmt [] =“ <span class="bold">SELECT XMLSerialize（DOCUMENT x。OBURECT_VALUE AS CLOB）来自PURCHASEORDER x其中rownum = 1</span> “; OCILobLocator * cob; ub4 amtp，nbytes; ub1 bufp [MAXBUFLEN]; ctx-&gt; username =（oratext *）”oe“; ctx-&gt; password =（oratext *） “*************”; / *替换为真实密码* / <span class="bold">/ *初始化envhp，svchp，errhp，dur，stmthp * /</span> init_oci_handles（ctx）; <span class="bold">/ *获取xml上下文* /</span> params [0] .name_ocixmldbparam = XCTXINIT_OCIDUR; params [0] .value_ocixmldbparam =＆ctx-&gt; dur; xctx = OCIXmlDbInitXmlCtx（ctx-&gt; envhp，ctx-&gt; svchp，ctx-&gt; errhp，params，1）; <span class="bold">/ *开始处理* /</span> printf（“\ n \ n <span class="bold">支持XML 1.0？：</span> ％s \ n”，XmlHasFeature（xctx，（oratext *）“xml”，（oratext *）“1.0”）？“是”：“否”）; <span class="bold">/ *分配lob描述符* /</span> status = OCIDescriptorAlloc（（dvoid *）ctx-&gt; envhp，（dvoid **）＆clob，（ub4）OCI_DTYPE_LOB，（size_t）0，（dvoid **）0）; if（status）{printf（“OCIDescriptorAlloc Failed \ n”）;转到错误; } status = OCIStmtPrepare（ctx-&gt; stmthp，ctx-&gt; errhp，（CONST OraText *）sel_stmt，（ub4）strlen（（char *）sel_stmt），（ub4）OCI_NTV_SYNTAX，（ub4）OCI_DEFAULT）; if（status）{printf（“OCIStmtPrepare Failed \ n”）;转到错误; } status = OCIDefineByPos（ctx-&gt; stmthp，＆defnp，ctx-&gt; errhp，（ub4）1，（dvoid *）＆clob，（sb4）-1，（ub2）SQLT_CLOB，（dvoid *）0，（ub2 *）0 ，（ub2 *）0，（ub4）OCI_DEFAULT）; if（status）{printf（“OCIDefineByPos Failed \ n”）;转到错误; } status = OCIStmtExecute（ctx-&gt; svchp，ctx-&gt; stmthp，ctx-&gt; errhp，（ub4）1，（ub4）0，（CONST OCISnapshot *）0，（OCISnapshot *）0，（ub4）OCI_DEFAULT）; if（status）{printf（“OCIStmtExecute Failed \ n”）;转到错误; } / *将读取的值读入缓冲区* / amtp = nbytes = MAXBUFLEN-1; status = OCILobRead（ctx-&gt; svchp，ctx-&gt; errhp，clob，＆amtp，（ub4）1，（dvoid *）bufp，（ub4）nbytes，（dvoid *）0，（sb4（*）（dvoid *，CONST） dvoid *，ub4，ub1））0，（ub2）0，（ub1）SQLCS_IMPLICIT）; if（status）{printf（“OCILobRead Failed \ n”）;转到错误; } bufp [amtp] ='\ 0'; if（amtp&gt; 0）{printf（“\ n <span class="bold">=&gt;</span> ％s的<span class="bold">查询结果</span> ：\ n％s \ n”，sel_stmt，bufp）; <span class="bold">/ ********** PULL PARSING ****************** /</span> status = pp_parse（xctx，bufp，amtp）; if（status）printf（“Pull Parsing failed \ n”）; } error： <span class="bold">/ * Free XML</span> Ctx <span class="bold">* /</span> OCIXmlDbFreeXmlCtx（xctx）; <span class="bold">/ *免费envhp，svchp，errhp，stmthp * /</span> free_oci_handles（ctx）; } #define ERRBUFLEN 256 sb4 pp_parse（xctx，buf，amt）xmlctx * xctx; oratext * buf; ub4 amt; {xmlevctx * evctx; xmlerr xerr = XMLERR_OK; oratext消息[ERRBUFLEN]; oratext * emsg = message; xmlerr ecode; boolean done，inattr = FALSE; xmlevtype事件; <span class="bold">/ *创建XML事件上下文 - 拉解析器上下文* /</span> evctx = XmlEvCreatePPCtx（xctx，＆xerr，“expand_entities”，FALSE，“validate”，TRUE，“attr_events”，TRUE，“raw_buffer_len”，1024，NULL）;如果（！evctx）{printf（“FAILED：XmlEvCreatePPCtx：％d \ n”，xerr）;返回OCI_ERROR; <span class="bold">/ *从输入缓冲区加载文档* /</span> xerr = XmlEvLoadPPDoc（xctx，evctx，“buffer”，buf，amt，“utf-8”）; if（xerr）{printf（“FAILED：XmlEvLoadPPDoc：％d \ n”，xerr）;返回OCI_ERROR; <span class="bold">/ *处理事件直到END_DOCUMENT事件或错误* /</span> done = FALSE;而（！完成）{event = XmlEvNext（evctx）; switch（event）{case XML_EVENT_START_ELEMENT：printf（“ <span class="bold">START ELEMENT：</span> ％s \ n”，XmlEvGetName0（evctx））;打破; case XML_EVENT_END_ELEMENT：printf（“ <span class="bold">END ELEMENT：</span> ％s \ n”，XmlEvGetName0（evctx））;打破; case XML_EVENT_START_DOCUMENT：printf（“ <span class="bold">START DOCUMENT</span> \ n”）;打破; case XML_EVENT_END_DOCUMENT：printf（“ <span class="bold">END DOCUMENT</span> \ n”）; done = TRUE;打破; case XML_EVENT_START_ATTR：printf（“ <span class="bold">START ATTRIBUTE：</span> ％s \ n”，XmlEvGetAttrName0（evctx，0））; inattr = TRUE;打破; case XML_EVENT_END_ATTR：printf（“ <span class="bold">END</span> ATTRTRUTE：％s \ n”，XmlEvGetAttrName0（evctx，0））; inattr = FALSE;打破; case XML_EVENT_CHARACTERS：if（inattr）printf（“ <span class="bold">ATTR VALUE：</span> ％s \ n”，XmlEvGetText0（evctx））; else printf（“ <span class="bold">TEXT：</span> ％s \ n”，XmlEvGetText0（evctx））;打破; case XML_EVENT_ERROR：case XML_EVENT_FATAL_ERROR：done = TRUE; ecode = XmlEvGetError（evctx，＆emsg）; printf（“ERROR：％d：％s \ n”，ecode，emsg）;打破; <span class="bold">/ *销毁事件上下文* /</span> XmlEvDestroyPPCtx（xctx，evctx）;返回OCI_SUCCESS; }</pre><p>编译和运行此C程序的输出如下：</p><pre class="oac_no_warn" dir="ltr"><span class="bold">=&gt;</span> XMLSerialize的<span class="bold">查询结果</span> （文档x。OBURECT_VALUE as CLOB）来自PURCHASEORDER x，其中rownum = 1：</pre><pre class="oac_no_warn" dir="ltr">&lt;PurchaseOrder xmlns：xsi =“http://www.w3.org/2001/XMLSchema-instance”xsi：noNamespaceSchemaLocation =“http：// localhost：8080 / source / schemas / poSource / xsd / purchaseOrder.xsd”&gt; &lt;参考&gt; AMCEWEN-20021009123336171PDT &lt;/ Reference&gt; &lt;Actions&gt; &lt;Action&gt; &lt;User&gt; KPARTNER &lt;/ User&gt; &lt;/ Action&gt; &lt;/ Actions&gt; &lt;Reject /&gt; &lt;Requestor&gt; Allan D. McEwen &lt;/ Requestor&gt; &lt;User&gt; AMCEWEN &lt;/ User&gt; &lt;CostCenter&gt; S30 &lt;/ CostCenter&gt; &lt;ShippingInstructions&gt; &lt;name&gt; Allan D. McEwen &lt;/ name&gt; &lt;地址&gt; Oracle Plaza Twin Dolphin Drive Redwood Shores CA 94065 USA &lt;/ address&gt; &lt;telephone&gt; 650 506 7700 &lt; / telephone&gt; &lt;/ ShippingInstructions&gt; &lt;SpecialInstructions&gt; Ground &lt;/ SpecialInstructions&gt; &lt;LineItems&gt; &lt;LineItem ItemNumber =“1”&gt; &lt;Description&gt; Salesman &lt;/ Description&gt; &lt;Part Id =“37429158920”UnitPrice =“39.95”Quantity =“2 “/&gt; &lt;/ LineItem&gt; <span class="bold">。 。 。</span>&lt;/ LineItems&gt; &lt;/ PurchaseOrder&gt; START DOCUMENT START ELEMENT：PurchaseOrder START ATTRIBUTE：xmlns：xsi ATTR VALUE：http：//www.w3.org/2001/XMLSchema-instance END ATTRIBUTE：xmlns：xsi START ATTRIBUTE：xsi：noNamespaceSchemaLocation ATTR VALUE：http：// localhost：8080 / source / schemas / poSource / xsd / purchaseOrder.xsd END ATTRIBUTE：xsi：noNamespaceSchemaLocation START ELEMENT：参考文本：AMCEWEN-20021009123336171PDT END ELEMENT：参考START ELEMENT：Actions START ELEMENT：Action START元素：用户文本：KPARTNER结束元素：用户结束元素：操作结束元素：操作开始元素：拒绝结束元素：拒绝开始元素：请求者文本：Allan D. McEwen结束元素：请求者开始元素：用户文本：AMCEWEN END ELEMENT：用户启动元素：成本中心文本：S30结束元素：成本中心开始元素：ShippingInstructions开始元素：名称文字：Allan D. McEwen END ELEMENT：名称START ELEMENT：地址文本：Oracle Plaza Twin Dolphin Drive Redwood Shores CA 94065 USA END ELEMENT：addr ess START ELEMENT：电话文字：650 506 7700 END ELEMENT：电话END ELEMENT：ShippingInstructions START ELEMENT：SpecialInstructions文字：地面结束元素：SpecialInstructions START ELEMENT：LineItems START ELEMENT：LineItem START ATTRIBUTE：ItemNumber ATTR VALUE：1 END ATTRIBUTE：ItemNumber START元素：描述文本：推销员END ELEMENT：描述START元素：部分开始属性：Id ATTR VALUE：37429158920 END属性：Id开始属性：UnitPrice ATTR VALUE：39.95 END属性：UnitPrice START属性：数量ATTR值：2结束属性：数量结束元素：部分结束元素：LineItem <span class="bold">。 。 。</span>END ELEMENT：LineItems END ELEMENT：PurchaseOrder END DOCUMENT</pre></div>
                  <!-- class="example" -->
               </div>
               <div>
                  <div class="familylinks">
                     <div class="parentlink">
                        <p><strong>父主题：</strong> <a href="C-API-for-XMLType.html#GUID-3530DFDE-0125-4A95-9DCA-29BA804F1BA9" title="XMLType的C DOM API允许您使用C中的DOM操作XMLType实例。">XMLType的C DOM API</a></p>
                     </div>
                  </div>
               </div>
               
            </div><a id="ADXDB4981"></a><a id="ADXDB4982"></a><a id="ADXDB4980"></a><div class="props_rev_3"><a id="GUID-687495C3-551B-4786-8A5F-F594985553E2" name="GUID-687495C3-551B-4786-8A5F-F594985553E2"></a><h3 id="ADXDB-GUID-687495C3-551B-4786-8A5F-F594985553E2" class="sect3"><span class="enumeration_section">14.8</span> C中的常见XMLType操作</h3>
               <div>
                  <p>通用XML操作由C API for XML提供。</p>
                  <p><a href="C-API-for-XMLType.html#GUID-687495C3-551B-4786-8A5F-F594985553E2__BABGGACF" title="该表描述了XML的XMLType函数的C API。">表14-2</a>提供了与常见XML操作等效的<code class="codeph">XMLType</code>功能。
                  </p>
                  <div class="tblformal" id="GUID-687495C3-551B-4786-8A5F-F594985553E2__BABGGACF">
                     <p class="titleintable">表14-2 C中的常见XMLType操作</p>
                     <table cellpadding="4" cellspacing="0" class="Formal" title="C中常见的XMLType操作" width="100%" border="1" summary="This table describes the C API for XML’s XMLType functions." frame="hsides" rules="rows">
                        <thead>
                           <tr align="left" valign="top">
                              <th align="left" valign="bottom" width="44%" id="d76905e1245">描述</th>
                              <th align="left" valign="bottom" width="56%" id="d76905e1248">C API XMLType函数</th>
                           </tr>
                        </thead>
                        <tbody>
                           <tr align="left" valign="top">
                              <td align="left" valign="top" width="44%" id="d76905e1253" headers="d76905e1245 ">
                                 <p>创建空<code class="codeph">XMLType</code>实例</p>
                              </td>
                              <td align="left" valign="top" width="56%" headers="d76905e1253 d76905e1248 ">
                                 <p><code class="codeph">XmlCreateDocument（）</code></p>
                              </td>
                           </tr>
                           <tr align="left" valign="top">
                              <td align="left" valign="top" width="44%" id="d76905e1264" headers="d76905e1245 ">
                                 <p>从源缓冲区创建</p>
                              </td>
                              <td align="left" valign="top" width="56%" headers="d76905e1264 d76905e1248 ">
                                 <p><code class="codeph">XmlLoadDom（）</code></p>
                              </td>
                           </tr>
                           <tr align="left" valign="top">
                              <td align="left" valign="top" width="44%" id="d76905e1272" headers="d76905e1245 ">
                                 <p>提取XPath表达式</p>
                              </td>
                              <td align="left" valign="top" width="56%" headers="d76905e1272 d76905e1248 ">
                                 <p><code class="codeph">XmlXPathEvalexpr()</code>和系列</p>
                              </td>
                           </tr>
                           <tr align="left" valign="top">
                              <td align="left" valign="top" width="44%" id="d76905e1281" headers="d76905e1245 ">
                                 <p>使用XSLT样式表进行转换</p>
                              </td>
                              <td align="left" valign="top" width="56%" headers="d76905e1281 d76905e1248 ">
                                 <p><code class="codeph">XmlXslProcess()</code>和系列</p>
                              </td>
                           </tr>
                           <tr align="left" valign="top">
                              <td align="left" valign="top" width="44%" id="d76905e1290" headers="d76905e1245 ">
                                 <p>检查是否存在XPath</p>
                              </td>
                              <td align="left" valign="top" width="56%" headers="d76905e1290 d76905e1248 ">
                                 <p><code class="codeph">XmlXPathEvalexpr()</code>和系列</p>
                              </td>
                           </tr>
                           <tr align="left" valign="top">
                              <td align="left" valign="top" width="44%" id="d76905e1299" headers="d76905e1245 ">
                                 <p>是基于文档架构吗？</p>
                              </td>
                              <td align="left" valign="top" width="56%" headers="d76905e1299 d76905e1248 ">
                                 <p><code class="codeph">XmlDomIsSchemaBased（）</code></p>
                              </td>
                           </tr>
                           <tr align="left" valign="top">
                              <td align="left" valign="top" width="44%" id="d76905e1307" headers="d76905e1245 ">
                                 <p>获取架构信息</p>
                              </td>
                              <td align="left" valign="top" width="56%" headers="d76905e1307 d76905e1248 ">
                                 <p><code class="codeph">XmlDomGetSchema（）</code></p>
                              </td>
                           </tr>
                           <tr align="left" valign="top">
                              <td align="left" valign="top" width="44%" id="d76905e1315" headers="d76905e1245 ">
                                 <p>获取文档命名空间</p>
                              </td>
                              <td align="left" valign="top" width="56%" headers="d76905e1315 d76905e1248 ">
                                 <p><code class="codeph">XmlDomGetNodeURI（）</code></p>
                              </td>
                           </tr>
                           <tr align="left" valign="top">
                              <td align="left" valign="top" width="44%" id="d76905e1323" headers="d76905e1245 ">
                                 <p>使用架构验证</p>
                              </td>
                              <td align="left" valign="top" width="56%" headers="d76905e1323 d76905e1248 ">
                                 <p><code class="codeph">XmlSchemaValidate（）</code></p>
                              </td>
                           </tr>
                           <tr align="left" valign="top">
                              <td align="left" valign="top" width="44%" id="d76905e1331" headers="d76905e1245 ">
                                 <p>从<code class="codeph">XMLType</code>获取DOM</p>
                              </td>
                              <td align="left" valign="top" width="56%" headers="d76905e1331 d76905e1248 ">
                                 <p>Cast <code class="codeph">(void *)</code> to <code class="codeph">(xmldocnode *)</code></p>
                              </td>
                           </tr>
                           <tr align="left" valign="top">
                              <td align="left" valign="top" width="44%" id="d76905e1345" headers="d76905e1245 ">
                                 <p>从DOM获取XMLType</p>
                              </td>
                              <td align="left" valign="top" width="56%" headers="d76905e1345 d76905e1248 ">
                                 <p>将<code class="codeph">(xmldocnode *)</code>为<code class="codeph">(void *)</code></p>
                              </td>
                           </tr>
                        </tbody>
                     </table>
                  </div>
                  <!-- class="inftblhruleinformal" -->
                  <div class="infoboxnotealso" id="GUID-687495C3-551B-4786-8A5F-F594985553E2__GUID-4CBD907D-4B95-4991-825E-B520D0F83A24">
                     <p class="notep1">也可以看看：</p>
                     <p><a href="../adxdk/using-XML-parser-for-C.html#ADXDK1400" target="_blank"><span><cite>Oracle XML Developer's Kit程序员指南</cite></span></a> “用于C的XML解析器”</p>
                  </div>
                  <p><a href="C-API-for-XMLType.html#GUID-687495C3-551B-4786-8A5F-F594985553E2__CHDBIHJI">示例14-4</a>显示了如何使用DOM来确定已订购特定部件的实例数。有问题的部分有<code class="codeph">Id</code> <code class="codeph">37429158722</code> 。有关辅助函数<code class="codeph">exec_bind_xml</code> ， <code class="codeph">free_oci_handles</code>和<code class="codeph">init_oci_handles</code>的定义，请参阅<a href="oracle-supplied-XML-schemas-and-examples.html#GUID-8FCAD86A-3BF9-4B20-A9EE-8FC46C95C3CE" title="此处提供了完整列表，包括Oracle XML DB提供的XML模式，采购订单XML模式和各种示例中使用的XSLT样式表，以及用于将XML内容加载到Oracle XML DB并初始化和终止的XML语言（OCI）示例。 XML上下文。">Oracle提供的XML模式和示例</a> ， <a href="oracle-supplied-XML-schemas-and-examples.html#GUID-8CA90A5B-999C-49B6-A2FD-41427C332F17__BABGHJFA">示例A-6</a> 。
                  </p>
                  <div class="example" id="GUID-687495C3-551B-4786-8A5F-F594985553E2__CHDBIHJI">
                     <p class="titleinexample">示例14-4使用DOM计算有序零件</p><pre class="oac_no_warn" dir="ltr">#ifndef S_ORACLE #endif #ifndef ORATYPES_ORACLE #include &lt;oratypes.h&gt; #endif #ifndef XML_ORACLE #include &lt;xml.h&gt; #endif #ifndef OCIXML_ORACLE #include &lt;ocixml.h&gt; #endif #ifndef OCI_ORACLE #include &lt;oci.h &gt; #endif #include &lt;string.h&gt; typedef struct test_ctx {OCIEnv * envhp; OCIError * errhp; OCISvcCtx * svchp; OCIStmt * stmthp; OCIServer * srvhp; OCIDuration dur; OCISession * sesshp; oratext * username; oratext *密码; } test_ctx; / * Helper函数1：执行绑定xml数据的sql语句* / static sword <span class="bold">exec_bind_xml</span> （OCISvcCtx * svchp，OCIError * errhp，OCIStmt * stmthp，void * xml，OCIType * xmltdo，OraText * sqlstmt）; / * Helper函数2：初始化OCI句柄并连接* / static sword <span class="bold">init_oci_handles</span> （test_ctx * ctx）; / *助手功能3：免费OCI句柄和断开* /静态剑<span class="bold">free_oci_handles</span> （test_ctx * ctx）; void <span class="bold">main</span> （）{test_ctx temp_ctx; test_ctx * ctx =＆temp_ctx; OCIType * xmltdo =（OCIType *）0; xmldocnode * doc =（xmldocnode *）0; ocixmldbparam params [1]; xmlnode * quux，* foo，* foo_data，* top; xmlerr错误;剑状态= 0; xmlctx * xctx; ub4 xmlsize = 0; OCIDefine * defnp =（OCIDefine *）0; oratext sel_stmt [] =“SELECT SYS_NC_ROWINFO $ FROM PURCHASEORDER”; xmlnodelist * litems =（xmlnodelist *）0; xmlnode * item =（xmlnode *）item; xmlnode * part; xmlnamedmap * attrs; xmlnode * id; xmlnode * qty; oratext * idval; oratext * qtyval; ub4 total_qty; int i; int numdocs; ctx-&gt; username =（oratext *）“oe”; ctx-&gt; password =（oratext *）“***********”; / *替换为真实密码* / / *初始化envhp，svchp，errhp，dur，stmthp * / init_oci_handles（ctx）; / *获取xml上下文* / params [0] .name_ocixmldbparam = XCTXINIT_OCIDUR; params [0] .value_ocixmldbparam =＆ctx-&gt; dur; xctx = OCIXmlDbInitXmlCtx（ctx-&gt; envhp，ctx-&gt; svchp，ctx-&gt; errhp，params，1）; / *开始处理* / printf（“\ n \ n <span class="bold">支持XML 1.0？：</span> ％s \ n”，XmlHasFeature（xctx，（oratext *）“xml”，（oratext *）“1.0”）？“是”：“否”）; / *使用select语句从数据库中获取文件* / status = OCITypeByName（ctx-&gt; envhp，ctx-&gt; errhp，ctx-&gt; svchp，（const text *）“SYS”，（ub4）strlen（（char *） ）“SYS”），（const text *）“XMLTYPE”，（ub4）strlen（（char *）“XMLTYPE”），（CONST text *）0，（ub4）0，OCI_DURATION_SESSION，OCI_TYPEGET_HEADER，（OCIType **） ＆xmltdo）; status = OCIStmtPrepare（ctx-&gt; stmthp，ctx-&gt; errhp，（CONST OraText *）sel_stmt，（ub4）strlen（（char *）sel_stmt），（ub4）OCI_NTV_SYNTAX，（ub4）OCI_DEFAULT）; status = OCIDefineByPos（ctx-&gt; stmthp，＆defnp，ctx-&gt; errhp，（ub4）1，（dvoid *）0，（sb4）0，SQLT_NTY，（dvoid *）0，（ub2 *）0，（ub2 *） 0，（ub4）OCI_DEFAULT）; status = OCIDefineObject（defnp，ctx-&gt; errhp，（OCIType *）xmltdo，（dvoid **）＆doc，＆xmlsize，（dvoid **）0，（ub4 *）0）; status = OCIStmtExecute（ctx-&gt; svchp，ctx-&gt; stmthp，ctx-&gt; errhp，（ub4）0，（ub4）0，（CONST OCISnapshot *）0，（OCISnapshot *）0，（ub4）OCI_DEFAULT）; / *初始化变量* / total_qty = 0; numdocs = 0; / *遍历所有文档* / while（（status = OCIStmtFetch2（ctx-&gt; stmthp，ctx-&gt; errhp，（ub4）1，（ub4）OCI_FETCH_NEXT，（ub4）1，（ub4）OCI_DEFAULT））== 0 ）{numdocs ++; / *获取所有LineItem元素* / litems = XmlDomGetDocElemsByTag（xctx，doc，（oratext *）“LineItem”）; i = 0; / *遍历所有LineItems * / while（item = XmlDomGetNodeListItem（xctx，litems，i））{/ *获取部分* / part = XmlDomGetLastChild（xctx，item）; / *获取属性* / attrs = XmlDomGetAttrs（xctx，（xmlelemnode *）part）; / *获取id属性及其值* / id = XmlDomGetNamedItem（xctx，attrs，（oratext *）“Id”）; idval = XmlDomGetNodeValue（xctx，id）; / *只保留部分ID为37429158722 * / if（idval &amp;&amp;（strlen（（char *）idval）== 11）&amp;&amp;！strncmp（（char *）idval，（char *）“37429158722”，11））{/ *获取数量属性及其值。* / qty = XmlDomGetNamedItem（xctx，attrs，（oratext *）“Quantity”）; qtyval = XmlDomGetNodeValue（xctx，qty）; / *将数量添加到total_qty * / total_qty + = atoi（（char *）qtyval）; } i ++; XmlFreeDocument（xctx，doc）; doc =（xmldocnode *）0; } printf（“ <span class="bold">部件37429158722 =</span> ％d \ n” <span class="bold">所需的总数量</span> ，total_qty）; printf（“ <span class="bold">表PURCHASEORDER =</span> ％d \ n”中<span class="bold">的文档数</span> ，numdocs）; / * Free Xml Ctx * / OCIXmlDbFreeXmlCtx（xctx）; / *免费envhp，svchp，errhp，stmthp * / free_oci_handles（ctx）; }</pre><p>编译和运行此C程序的输出如下：</p><pre class="oac_no_warn" dir="ltr">支持XML 1.0？ ：是零件37429158722所需的总数量= 42表格中的文件数量PURCHASEORDER = 132</pre></div>
                  <!-- class="example" -->
               </div>
               <div>
                  <div class="familylinks">
                     <div class="parentlink">
                        <p><strong>父主题：</strong> <a href="C-API-for-XMLType.html#GUID-3530DFDE-0125-4A95-9DCA-29BA804F1BA9" title="XMLType的C DOM API允许您使用C中的DOM操作XMLType实例。">XMLType的C DOM API</a></p>
                     </div>
                  </div>
               </div>
               
            </div>
         </div>
      </article>
   </body>
</html>