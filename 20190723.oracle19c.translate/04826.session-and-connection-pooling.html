<html lang="en-us" dir="ltr" xml:lang="en-us">
   <head>
      <meta http-equiv="Content-Type" content="text/html; charset=utf-8"></meta>
      <meta name="viewport" content="width=device-width, initial-scale=1"></meta>
      <meta http-equiv="X-UA-Compatible" content="IE=edge"></meta>
      <meta name="abstract" content="This chapter describes OCI session pooling and connection pooling features."></meta>
      <meta name="description" content="This chapter describes OCI session pooling and connection pooling features."></meta>
      <title>OCI中的会话池和连接池</title>
      <meta property="og:site_name" content="Oracle Help Center"></meta>
      <meta property="og:title" content="Programmer&#39;s Guide"></meta>
      <meta property="og:description" content="This chapter describes OCI session pooling and connection pooling features."></meta>
      <link rel="stylesheet" href="/sp_common/book-template/ohc-book-template/css/book.css"></link>
      <link rel="shortcut icon" href="/sp_common/book-template/ohc-common/img/favicon.ico"></link>
      <meta name="application-name" content="Programmer&#39;s Guide"></meta>
      <meta name="generator" content="DITA Open Toolkit version 1.8.5 (Mode = doc)"></meta>
      <meta name="plugin" content="SP_docbuilder HTML plugin release 18.2.2"></meta>
      <link rel="alternate" href="oracle-call-interface-programmers-guide.pdf" title="PDF File" type="application/pdf"></link>
      <meta name="robots" content="all"></meta>
      <link rel="schema.dcterms" href="http://purl.org/dc/terms/"></link>
      <meta name="dcterms.created" content="2019-01-14T08:46:00-08:00"></meta>
      
      <meta name="dcterms.dateCopyrighted" content="1996, 2019"></meta>
      <meta name="dcterms.category" content="database"></meta>
      <meta name="dcterms.identifier" content="E96204-01"></meta>
      
      <meta name="dcterms.product" content="en/database/oracle/oracle-database/19"></meta>
      
      <link rel="prev" href="managing-scalable-platforms.html" title="Previous" type="text/html"></link>
      <link rel="next" href="high-availability-in-oci.html" title="Next" type="text/html"></link>
      <script>
        document.write('<style type="text/css">');
        document.write('body > .noscript, body > .noscript ~ * { visibility: hidden; }');
        document.write('</style>');
     </script>
      <script src="/sp_common/book-template/requirejs/require.js" data-main="/sp_common/book-template/ohc-book-template/js/book-config"></script>
      <script>
            if (window.require === undefined) {
                document.write('<script data-main="sp_common/book-template/ohc-book-template/js/book-config" src="sp_common/book-template/requirejs/require.js"><\/script>');
                document.write('<link href="sp_common/book-template/ohc-book-template/css/book.css" rel="stylesheet"/>');
            }
        </script>
      <script type="application/json" id="ssot-metadata">{"primary":{"category":{"short_name":"database","element_name":"Database","display_in_url":true},"suite":{"short_name":"oracle","element_name":"Oracle","display_in_url":true},"product_group":{"short_name":"not-applicable","element_name":"Not applicable","display_in_url":false},"product":{"short_name":"oracle-database","element_name":"Oracle Database","display_in_url":true},"release":{"short_name":"19","element_name":"Release 19","display_in_url":true}}}</script>
      
    <meta name="dcterms.title" content="Oracle Call Interface Programmer&#39;s Guide"></meta>
    <meta name="dcterms.isVersionOf" content="LNOCI"></meta>
    <meta name="dcterms.release" content="Release 19"></meta>
  </head>
   <body dir="ltr">
      <div class="noscript alert alert-danger text-center" role="alert">
         <a href="managing-scalable-platforms.html" class="pull-left"><span class="glyphicon glyphicon-chevron-left" aria-hidden="true"></span>上一页</a> <a href="high-availability-in-oci.html" class="pull-right">下一页<span class="glyphicon glyphicon-chevron-right" aria-hidden="true"></span></a> <span class="fa fa-exclamation-triangle" aria-hidden="true"></span>必须启用JavaScript才能正确显示此内容</div>
      <article>
         <header>
            <ol class="breadcrumb" vocab="http://schema.org/" typeof="BreadcrumbList">
               <li property="itemListElement" typeof="ListItem"><a href="index.html" property="item" typeof="WebPage"><span property="name">程序员指南</span></a></li>
               <li class="active" property="itemListElement" typeof="ListItem">OCI中的会话池和连接池</li>
            </ol>
            <a id="GUID-FD512A09-1A33-424B-AD4D-728956AFDBD8" name="GUID-FD512A09-1A33-424B-AD4D-728956AFDBD8"></a><a id="LNOCI090"></a>
            
            <h2 id="LNOCI-GUID-FD512A09-1A33-424B-AD4D-728956AFDBD8" class="sect2">OCI中的<span class="enumeration_chapter">11个</span>会话池和连接池</h2>
         </header>
         <div class="ind">
            <div>
               <p>本章介绍OCI会话池和连接池功能。</p>
               <p>本章包含以下主题：</p>
               <ul style="list-style-type:disc">
                  <li>
                     <p><a href="session-and-connection-pooling.html#GUID-F9662FFB-EAEF-495C-96FC-49C6D1D9625C" title="会话池意味着应用程序创建并维护一组无状态会话到数据库。">OCI中的会话池</a></p>
                  </li>
                  <li>
                     <p><a href="session-and-connection-pooling.html#GUID-1E260CD3-2EF7-49FF-97FC-041C2EF60381" title="数据库驻留连接池（DRCP）在数据库服务器中为典型的Web应用程序使用方案提供连接池，其中应用程序获取数据库连接，对其进行相对较短的持续时间，然后释放它。">数据库驻留连接池</a></p>
                  </li>
                  <li>
                     <p><a href="session-and-connection-pooling.html#GUID-BF9AFFD6-537A-4252-BBFB-3A60EEAC3E61" title="Traffic Director Mode中的Oracle Connection Manager是一个放置在支持的数据库客户端和数据库实例之间的代理。">关于在Traffic Director模式下使用Oracle Connection Manager</a></p>
                  </li>
                  <li>
                     <p><a href="session-and-connection-pooling.html#GUID-1C9A6E8F-EF5A-478D-B65E-CE39D4F00683" title="连接池是指通过多个会话使用可重用物理连接的组（池）来平衡负载。">OCI中的连接池</a></p>
                  </li>
                  <li>
                     <p><a href="session-and-connection-pooling.html#GUID-8DD97D4D-C7AA-4EF7-9B55-8DC58BDC2726" title="表示使用它们的环境。">何时使用连接池，会话池或两者都不使用</a></p>
                  </li>
               </ul>
            </div><a id="LNOCI16617"></a><div class="props_rev_3"><a id="GUID-F9662FFB-EAEF-495C-96FC-49C6D1D9625C" name="GUID-F9662FFB-EAEF-495C-96FC-49C6D1D9625C"></a><h3 id="LNOCI-GUID-F9662FFB-EAEF-495C-96FC-49C6D1D9625C" class="sect3"><span class="enumeration_section">11.1</span> OCI中的会话池</h3>
               <div>
                  <p><span class="italic">会话池</span>意味着应用程序创建并维护一组无状态会话到数据库。
                  </p>
                  <p>这些会话根据请求提供给瘦客户端。如果没有可用的会话，则可以创建新会话。当客户端完成会话后，客户端会将其释放到池中。因此，池中的会话数可以动态增加。</p>
                  <p>池中的某些会话可能会标记某些属性。例如，用户可以请求默认会话，在其上设置某些属性，标记或标记它，并将其返回到池中。该用户或某个其他用户可能需要具有相同属性的会话，因此请求具有相同标记的会话。池中可能有多个具有相同标记的会话。可以更改或重置会话上的标记。</p>
                  <p>也可以通过OCI中的会话池创建和维护代理会话。</p>
                  <p>没有可用会话且池已达到其最大大小时应用程序的行为取决于某些属性。可能会创建新会话或返回错误，或者线程可能只是阻塞并等待会话变为空闲。</p>
                  <p>会话池的主要好处是性能。建立与数据库的连接是一项非常耗时的活动，尤其是在数据库是远程数据库时。因此，代替客户花费时间连接到服务器，验证其凭据，然后接收有效会话，它可以从池中选择一个。</p>
                  <div class="p">本节包括以下主题：<ul style="list-style-type:disc">
                        <li>
                           <p><a href="session-and-connection-pooling.html#GUID-7D5BBEC4-38CF-4C63-B616-12231EF0DCAE" title="描述会话池可以执行的任务。">OCI会话池的功能</a></p>
                        </li>
                        <li>
                           <p><a href="session-and-connection-pooling.html#GUID-DD2C2456-5F22-4BA0-AFE6-30CCF29A3688" title="会话池可以是同构的，也可以是异构的。">同构和异构会话池</a></p>
                        </li>
                        <li>
                           <p><a href="session-and-connection-pooling.html#GUID-F7609D96-EB0F-487D-B825-E0138B16E2E9" title="标签为用户提供了一种自定义池中会话的方法。">关于在会话池中使用标记</a></p>
                        </li>
                        <li>
                           <p><a href="session-and-connection-pooling.html#GUID-35D322F2-E576-416B-A399-3A733F5487A1" title="会话池的句柄类型是什么。">会话池的OCI句柄</a></p>
                        </li>
                        <li>
                           <p><a href="session-and-connection-pooling.html#GUID-9DD6C967-B3F8-4D26-B7F8-7730AABA7E8E" title="显示编写使用用户名和密码的简单会话池应用程序的步骤。">使用OCI会话池</a></p>
                        </li>
                        <li>
                           <p><a href="session-and-connection-pooling.html#GUID-CE43701B-ACB2-4F3A-B7CA-332CBD01DCCE" title="描述OCI调用会话池的用法。">OCI呼吁会话池</a></p>
                        </li>
                        <li>
                           <p><a href="session-and-connection-pooling.html#GUID-72D13726-61B8-4CAB-9120-4E33714688AE" title="在哪里可以找到经过测试的完整程序中的会话池示例。">OCI会话池的示例</a></p>
                        </li>
                     </ul>
                  </div>
                  <div class="infoboxnotealso" id="GUID-F9662FFB-EAEF-495C-96FC-49C6D1D9625C__GUID-18175688-A109-44F2-BE5D-B323818A1A7F">
                     <p class="notep1">也可以看看：</p>
                     <p> <a href="session-and-connection-pooling.html#GUID-F7609D96-EB0F-487D-B825-E0138B16E2E9" title="标签为用户提供了一种自定义池中会话的方法。">关于在会话池中使用标记</a></p>
                  </div>
               </div><a id="LNOCI16618"></a><div class="props_rev_3"><a id="GUID-7D5BBEC4-38CF-4C63-B616-12231EF0DCAE" name="GUID-7D5BBEC4-38CF-4C63-B616-12231EF0DCAE"></a><h4 id="LNOCI-GUID-7D5BBEC4-38CF-4C63-B616-12231EF0DCAE" class="sect4"><span class="enumeration_section">11.1.1</span> OCI会话池的功能</h4>
                  <div>
                     <p>描述会话池可以执行的任务。</p>
                     <p>会话池可以执行以下任务：</p>
                     <ul style="list-style-type:disc">
                        <li>
                           <p>透明地创建，维护和管理无状态会话池。</p>
                        </li>
                        <li>
                           <p>为应用程序提供一个接口，以创建池并指定池中的最小，增量和最大会话数。</p>
                        </li>
                        <li>
                           <p>为用户提供接口，以获取和释放池的默认或标记会话。标记会话是具有某些客户端定义属性的会话。</p>
                        </li>
                        <li>
                           <p>允许应用程序动态更改最小和最大会话数。</p>
                        </li>
                        <li>
                           <p>通过关闭已经空闲很长时间的会话，并在需要时创建会话，提供始终保持最佳打开会话数的机制。</p>
                        </li>
                        <li>
                           <p>允许使用身份验证进行会话池。</p>
                        </li>
                     </ul>
                  </div>
               </div><a id="LNOCI16619"></a><div class="props_rev_3"><a id="GUID-DD2C2456-5F22-4BA0-AFE6-30CCF29A3688" name="GUID-DD2C2456-5F22-4BA0-AFE6-30CCF29A3688"></a><h4 id="LNOCI-GUID-DD2C2456-5F22-4BA0-AFE6-30CCF29A3688" class="sect4"><span class="enumeration_section">11.1.2</span>同构和异构会话池</h4>
                  <div>
                     <p>会话池可以是同构的，也可以是异构的。</p>
                     <p><span class="italic">同构</span>会话池意味着池中的会话具有相同的身份验证（它们具有相同的用户名，密码和权限）。<span class="italic">异构</span>会话池意味着您必须提供身份验证信息，因为会话可以具有不同的安全属性和权限。
                     </p>
                  </div>
               </div><a id="LNOCI16620"></a><div class="props_rev_3"><a id="GUID-F7609D96-EB0F-487D-B825-E0138B16E2E9" name="GUID-F7609D96-EB0F-487D-B825-E0138B16E2E9"></a><h4 id="LNOCI-GUID-F7609D96-EB0F-487D-B825-E0138B16E2E9" class="sect4"><span class="enumeration_section">11.1.3</span>关于在会话池中使用标记</h4>
                  <div>
                     <p>标签为用户提供了一种自定义池中会话的方法。</p>
                     <p>客户端可以从池中获取默认或未标记的会话，在会话上设置某些属性（例如NLS设置），并将会话返回到池，并在<code class="codeph">OCISessionRelease(</code> ）调用中使用适当的标记对其进行标记。
                     </p>
                     <p>原始用户或其他一些用户可以请求具有相同标记的会话以具有相同属性的会话，并且可以通过在<code class="codeph">OCISessionGet()</code>调用中提供相同的标记来实现。
                     </p>
                     <p>本节包括以下主题： <a href="session-and-connection-pooling.html#GUID-DFA21225-E83C-4177-A79A-B8BA29DC662C" title="从12c Release 2（12.2）开始，标签可以具有多个属性。这被称为多属性标记。">多属性标记</a> 。
                     </p>
                     <div class="infoboxnotealso" id="GUID-F7609D96-EB0F-487D-B825-E0138B16E2E9__GUID-673EB9A5-3100-4CC7-9FEB-5CFB14516BBB">
                        <p class="notep1">也可以看看：</p>
                        <ul style="list-style-type:disc">
                           <li>
                              <p><a href="connect-authorize-and-initialize-functions.html#GUID-DAAECC99-A432-48B5-AC33-0868C2FE762D" title="释放使用OCISessionGet（）检索的会话。">OCISessionRelease（）</a></p>
                           </li>
                           <li>
                              <p><a href="connect-authorize-and-initialize-functions.html#GUID-890DFBC4-718B-4339-A0EA-6226A25B8241" title="获取一个会话。">OCISessionGet（）</a></p>
                           </li>
                        </ul>
                     </div>
                  </div>
                  <div class="sect4"><a id="GUID-DFA21225-E83C-4177-A79A-B8BA29DC662C" name="GUID-DFA21225-E83C-4177-A79A-B8BA29DC662C"></a><h5 id="LNOCI-GUID-DFA21225-E83C-4177-A79A-B8BA29DC662C" class="sect5"><span class="enumeration_section">11.1.3.1</span>多属性标签</h5>
                     <div>
                        <p>从12 <span class="italic">c</span> Release 2（12.2）开始，标签可以具有多个属性。这被称为多属性标记。
                        </p>
                        <p>多属性标记由一个或多个由分号分隔的&lt;property-name&gt; = &lt;property-value&gt;对组成，其中&lt;property-name&gt; = &lt;property-value&gt;都是字符串。</p>
                        <p>在<code class="codeph">OCISessionGet()</code>调用期间，在<code class="codeph">taginfo</code>参数中，首先出现的属性名称被赋予查找匹配的最高属性，并且最后出现的属性名称被赋予最低优先级。因此，字符串中属性的排序对于确定池中的匹配会话非常重要。下面的限制列表下面的示例说明了这一点。
                        </p>
                        <p>此功能也适用于DRCP。</p>
                        <div class="p">以下限制适用于可在多属性标记中传递的属性名称和属性值：<ul style="list-style-type:disc">
                              <li>
                                 <p>属性名称和属性值都区分大小写。</p>
                              </li>
                              <li>
                                 <p>属性名称只能在标记中出现一次。如果多次指定相同的属性名称，则会引发错误。</p>
                              </li>
                              <li>
                                 <p>应为属性名称和值指定非空字符串。</p>
                              </li>
                              <li>
                                 <p>属性名称前后的前导和尾随空格以及属性值前后的前导和尾随空格将被截断。例如，“PDB = PDB1”被视为“PDB = PDB1”。</p>
                              </li>
                              <li>
                                 <p>属性名称和属性值中不应有空格。例如，由于NLS和LANGUAGE之间的空格，NLS &lt;space&gt; LANGUAGE = French将导致错误。</p>
                              </li>
                           </ul>
                        </div>
                        <p>为了解释多个属性的概念，假设要在CDB环境中部署的应用程序要求尽可能满足来自同一可插拔数据库（例如，pdb1）的会话的会话获取请求。接下来，它还要求会话属于同一种语言（例如，FRENCH），但为pdb1的会话提供更高的优先级。然后，应用程序可以提供如下的多属性标记：</p><pre class="pre codeblock"><code>char * props =“PDB = pdb1; LANGUAGE = FRENCH”</code></pre><p>现在，假设池中有两个会话，其属性如下所示：</p><pre class="pre codeblock"><code>第1节=&gt;“PDB = pdb1; LANGUAGE = CHINESE”</code></pre><pre class="pre codeblock"><code>第2节=&gt;“PDB = pdb2; LANGUAGE = FRENCH”</code></pre><p>在这种情况下，会话获取请求（ <code class="codeph">OCISessionGet()</code> ）返回会话1，因为<code class="codeph">PDB</code>属性通过置于<code class="codeph">LANGUAGE</code>属性之前隐式地具有更高的优先级。
                        </p>
                        <div class="infoboxnotealso" id="GUID-DFA21225-E83C-4177-A79A-B8BA29DC662C__GUID-53C1441D-B992-4770-B865-97A57A42FAC5">
                           <p class="notep1">也可以看看：</p>
                           <p><a href="connect-authorize-and-initialize-functions.html#GUID-890DFBC4-718B-4339-A0EA-6226A25B8241" title="获取一个会话。">OCISessionGet（）</a>用于进一步讨论标记会话</p>
                        </div>
                        <p>本节包括以下主题： <a href="session-and-connection-pooling.html#GUID-B853A020-752F-494A-8D88-D0396EF57177" title="使用多属性标记时，可以在服务器上提供基于PL / SQL的会话状态修复回调。">会话状态修复的PL / SQL回调</a> 。
                        </p>
                     </div>
                     <div class="sect5"><a id="GUID-B853A020-752F-494A-8D88-D0396EF57177" name="GUID-B853A020-752F-494A-8D88-D0396EF57177"></a><h6 id="LNOCI-GUID-B853A020-752F-494A-8D88-D0396EF57177" class="sect6"><span class="enumeration_section">11.1.3.1.1</span>会话状态修复的PL / SQL回调</h6>
                        <div>
                           <p>使用多属性标记时，可以在服务器上提供基于PL / SQL的会话状态修复回调。</p>
                           <p>此应用程序提供的回调将从池中检出的会话转换为应用程序请求的所需状态，如多属性标记所示。此回调可以使用或不使用数据库驻留连接池（DRCP）。</p>
                           <p>使用此回调可以提高应用程序的性能，因为修复逻辑是针对服务器上的会话状态运行的。因此，此功能消除了应用程序往返于修复逻辑的数据库往返。回调由使用<code class="codeph">OCISessionGet()</code>连接的用户提供。对于不使用OCISessionPool或使用自定义池的应用程序，传递给<code class="codeph">OCISessionGet()</code>的身份验证句柄上的回调必须作为属性<code class="codeph">OCI_ATTR_FIXUP_CALLBACK</code>提供。对于使用OCISessionPool的应用程序，必须在身份验证句柄上设置此属性，该句柄必须在会话池句柄上设置为属性<code class="codeph">OCI_ATTR_SPOOL_AUTH</code> 。</p>
                           <div class="example" id="GUID-B853A020-752F-494A-8D88-D0396EF57177__GUID-077AD33B-4206-4107-A9B3-24753058756D">
                              <p class="titleinexample">例11-1 PL / SQL修复回调示例</p>
                              
                              <p>以下PL / SQL修复回调示例代码段处理其<code class="codeph">key=value</code>属性可以直接在ALTER SESSION语句中使用的标记，例如<code class="codeph">TIME_ZONE=UTC;NLS_DATE_FORMAT=DD-MM-YYYY</code> ：</p>
                              <pre class="pre codeblock"><code>创建或替换包myPackage AS TYPE property_t是VARCHAR2的表（64）INDEX BY VARCHAR2（64）; PROCEDURE buildTab（标签IN VARCHAR2，propertyTab OUT property_t）; PROCEDURE myPlsqlCallback（requestedTag IN VARCHAR2，actualTag IN VARCHAR2）;结束; / CREATE OR REPLACE PACKAGE BODY myPackage AS  - 解析标签PROCEDURE buildTab中的“property = value”对（标签IN VARCHAR2，propertyTab OUT property_t）IS属性VARCHAR2（64）; propertyName VARCHAR2（64）; propertyValue VARCHAR2（64）; propertyEndPos NUMBER：= 1; propertyStartPos NUMBER：= 1; propertyNameEndPos NUMBER：= 1; begin WHILE（LENGTH（tag）&gt; propertyEndPos）LOOP propertyEndPos：= INSTR（tag，';'，propertyStartPos）; IF（propertyEndPos = 0）THEN propertyEndPos：= LENGTH（tag）+ 1;万一; propertyNameEndPos：= INSTR（tag，'='，propertyStartPos）; propertyName：= SUBSTR（tag，propertyStartPos，propertyNameEndPos  -  propertyStartPos）; propertyValue：= SUBSTR（tag，propertyNameEndPos + 1，propertyEndPos  -  propertyNameEndPos  -  1）; propertyTab（propertyName）：= propertyValue; propertyStartPos：= propertyEndPos + 1;结束循环;结束; PROCEDURE myPlsqlCallback（requestedTag IN VARCHAR2，actualTag IN VARCHAR2）IS reqPropTab property_t; actPropTab property_t; propertyName VARCHAR2（64）; BEGIN buildTab（requestedTag，reqPropTab）; buildTab（actualTag，actPropTab）; - 迭代请求的属性以设置状态 - 当前未设置 - 当前设置，或未设置为所需值propertyName：= reqPropTab。第一; WHILE（propertyName IS NOT NULL）LOOP IF（（不是actPropTab.exists（propertyName））或（actPropTab（propertyName）！= reqPropTab（propertyName）））然后执行立即'更改会话集'|| propertyName || '='''|| reqPropTab（propertyName）|| '' '';万一; propertyName：= reqPropTab。NEXT（propertyName的）;结束循环; - 可以迭代其他实际道具，将任何额外的道具重置为默认状态END;结束myPackage; /</code></pre></div>
                           <!-- class="example" -->
                           <div class="section">
                              <div class="infoboxnotealso" id="GUID-B853A020-752F-494A-8D88-D0396EF57177__GUID-D50AFE1B-9616-4198-A857-0ADF890AB1BA">
                                 <p class="notep1">也可以看看：</p>
                                 <ul style="list-style-type:disc">
                                    <li>
                                       <p><a href="handle-and-descriptor-attributes.html#GUID-0193473A-20FE-4727-850E-41269F94BAD4" title="列出并描述身份验证信息句柄属性。">身份验证信息句柄属性</a>有关<code class="codeph">OCI_ATTR_FIXUP_CALLBACK</code>更多信息</p>
                                    </li>
                                    <li>
                                       <p><a href="handle-and-descriptor-attributes.html#GUID-34071823-66D0-4C54-BFBB-6323BDEF8015" title="列出并描述会话池句柄属性。">会话池句柄属性</a>有关<code class="codeph">OCI_ATTR_SPOOL_AUTH</code>更多信息</p>
                                    </li>
                                 </ul>
                              </div>
                           </div>
                           <!-- class="section" -->
                        </div>
                     </div>
                  </div>
               </div><a id="LNOCI16621"></a><div class="props_rev_3"><a id="GUID-35D322F2-E576-416B-A399-3A733F5487A1" name="GUID-35D322F2-E576-416B-A399-3A733F5487A1"></a><h4 id="LNOCI-GUID-35D322F2-E576-416B-A399-3A733F5487A1" class="sect4"><span class="enumeration_section">11.1.4</span>会话池的OCI句柄</h4>
                  <div>
                     <p>会话池的句柄类型是什么。</p>
                     <div class="p">以下句柄类型用于会话池：<ul style="list-style-type:disc">
                           <li>
                              <p><a href="session-and-connection-pooling.html#GUID-3EB716F7-7810-4E29-9F92-F5A76B88E662" title="这是会话池句柄。">OCISPool</a></p>
                           </li>
                           <li>
                              <p><a href="session-and-connection-pooling.html#GUID-0F8EA0EC-2018-476F-9353-208266BD822A" title="这是身份验证信息句柄。">OCIAuthInfo</a></p>
                           </li>
                        </ul>
                     </div>
                  </div><a id="LNOCI16622"></a><div class="props_rev_3"><a id="GUID-3EB716F7-7810-4E29-9F92-F5A76B88E662" name="GUID-3EB716F7-7810-4E29-9F92-F5A76B88E662"></a><h5 id="LNOCI-GUID-3EB716F7-7810-4E29-9F92-F5A76B88E662" class="sect5"><span class="enumeration_section">11.1.4.1</span> OCISPool</h5>
                     <div>
                        <p>这是会话池句柄。</p>
                        <p>它是使用<code class="codeph">OCIHandleAlloc()</code>分配的。它必须传递给<code class="codeph">OCISessionPoolCreate()</code>和<code class="codeph">OCISessionPoolDestroy()</code> 。它具有属性类型<code class="codeph">OCI_HTYPE_SPOOL</code> 。</p>
                        <p><code class="codeph">OCIHandleAlloc()</code>调用的示例如下：</p><pre class="oac_no_warn" dir="ltr">OCISPool * spoolhp; OCIHandleAlloc（（void *）envhp，（void **）＆spoolhp，OCI_HTYPE_SPOOL，（size_t）0，（void **）0））;</pre><p>对于环境句柄，可以创建多个会话池。</p>
                        <div class="infoboxnotealso" id="GUID-3EB716F7-7810-4E29-9F92-F5A76B88E662__GUID-2E5705C8-EAB6-457F-BAD7-222FDD9C22BC">
                           <p class="notep1">也可以看看：</p>
                           <ul style="list-style-type:disc">
                              <li>
                                 <p><a href="handle-and-descriptor-functions.html#GUID-C5BF55F7-A110-4CB5-9663-5056590F12B5" title="返回指向已分配和初始化句柄的指针。">OCIHandleAlloc（）</a></p>
                              </li>
                              <li>
                                 <p><a href="connect-authorize-and-initialize-functions.html#GUID-1E929CFB-9D96-4E8E-9F24-904AD539E555" title="初始化会话池以与OCI会话池和数据库驻留连接池（DRCP）一起使用。">OCISessionPoolCreate（）</a></p>
                              </li>
                              <li>
                                 <p><a href="connect-authorize-and-initialize-functions.html#GUID-2797C90C-C7AC-47FB-B1C2-CE41B743FB5C" title="销毁会话池。">OCISessionPoolDestroy（）</a></p>
                              </li>
                           </ul>
                        </div>
                     </div>
                  </div><a id="LNOCI16623"></a><div class="props_rev_3"><a id="GUID-0F8EA0EC-2018-476F-9353-208266BD822A" name="GUID-0F8EA0EC-2018-476F-9353-208266BD822A"></a><h5 id="LNOCI-GUID-0F8EA0EC-2018-476F-9353-208266BD822A" class="sect5"><span class="enumeration_section">11.1.4.2</span> OCIAuthInfo</h5>
                     <div>
                        <p>这是身份验证信息句柄。</p>
                        <p>它是使用<code class="codeph">OCIHandleAlloc()</code>分配的。它被传递给<code class="codeph">OCISessionGet()</code> 。它支持用户会话句柄支持的所有属性。身份验证信息句柄具有属性类型<code class="codeph">OCI_HTYPE_AUTHINFO</code> （请参阅<a href="oci-programming-basics.html#GUID-5F13B2EC-E29C-4710-8AD7-E97E6C28085E__G466063" title="该表有3列。第1列是句柄类型描述，第2列是C数据类型，第3列是句柄类型常量。">表4-1</a> ）。
                        </p>
                        <p><code class="codeph">OCIHandleAlloc()</code>调用的示例如下：</p><pre class="oac_no_warn" dir="ltr">OCIAuthInfo * authp; OCIHandleAlloc（（void *）envhp，（void **）＆authp，OCI_HTYPE_AUTHINFO，（size_t）0，（void **）0））;</pre><div class="infoboxnotealso" id="GUID-0F8EA0EC-2018-476F-9353-208266BD822A__GUID-8F595AFE-3EDF-42F7-B84A-55B314C4FFD3">
                           <p class="notep1">也可以看看：</p>
                           <ul style="list-style-type:disc">
                              <li>
                                 <p><a href="handle-and-descriptor-functions.html#GUID-C5BF55F7-A110-4CB5-9663-5056590F12B5" title="返回指向已分配和初始化句柄的指针。">OCIHandleAlloc（）</a></p>
                              </li>
                              <li>
                                 <p><a href="handle-and-descriptor-attributes.html#GUID-FB263210-118E-4DB3-A840-1769EF0CB977" title="Lists and describes user session handle attributes.">用户会话句柄</a>属于身份验证信息句柄的<a href="handle-and-descriptor-attributes.html#GUID-FB263210-118E-4DB3-A840-1769EF0CB977" title="列出并描述用户会话句柄属性。">属性</a>的属性</p>
                              </li>
                              <li>
                                 <p><a href="handle-and-descriptor-attributes.html#GUID-34071823-66D0-4C54-BFBB-6323BDEF8015" title="列出并描述会话池句柄属性。">会话池句柄属性</a>有关会话池属性的更多信息</p>
                              </li>
                              <li>
                                 <p><a href="connect-authorize-and-initialize-functions.html#GUID-8EDDA0CC-6755-49D8-89D0-81713E10B156" title="Lists and describes connect, authorize, and initialize functions.">连接，授权和初始化函数，</a>以获取有关会话池中使用的<a href="connect-authorize-and-initialize-functions.html#GUID-8EDDA0CC-6755-49D8-89D0-81713E10B156" title="列出并描述连接，授权和初始化功能。">函数</a>的完整信息</p>
                              </li>
                              <li>
                                 <p>有关可以与此调用一起使用的会话句柄属性的详细信息，请参阅<span class="q">“ <a href="connect-authorize-and-initialize-functions.html#GUID-890DFBC4-718B-4339-A0EA-6226A25B8241" title="获取一个会话。">OCISessionGet（）</a> ”</span></p>
                              </li>
                           </ul>
                        </div>
                     </div>
                  </div>
               </div><a id="LNOCI16624"></a><div class="props_rev_3"><a id="GUID-9DD6C967-B3F8-4D26-B7F8-7730AABA7E8E" name="GUID-9DD6C967-B3F8-4D26-B7F8-7730AABA7E8E"></a><h4 id="LNOCI-GUID-9DD6C967-B3F8-4D26-B7F8-7730AABA7E8E" class="sect4"><span class="enumeration_section">11.1.5</span>使用OCI会话池</h4>
                  <div>
                     <p>显示编写使用用户名和密码的简单会话池应用程序的步骤。</p>
                     <div class="section">
                        <p>编写使用用户名和密码的简单会话池应用程序的步骤如下：</p>
                        <ol>
                           <li>
                              <p>使用<code class="codeph">OCIHandleAlloc()</code>为<code class="codeph">OCISPool</code>句柄分配会话池句柄。可以为环境句柄创建多个会话池。
                              </p>
                           </li>
                           <li>
                              <p>使用<code class="codeph">OCISessionPoolCreate()</code>创建会话池， <code class="codeph">mode</code>设置为<code class="codeph">OCI_DEFAULT</code> （对于新的会话池）。有关其他模式的讨论，请参阅该功能。
                              </p>
                           </li>
                           <li>
                              <p>每个线程循环。使用执行以下操作的函数创建线程：</p>
                              <ol type="a">
                                 <li>
                                    <p>使用<code class="codeph">OCIHandleAlloc()</code>分配类型为<code class="codeph">OCIAuthInfo</code>的身份验证信息句柄</p>
                                 </li>
                                 <li>
                                    <p>使用<code class="codeph">OCIAttrSet()</code>在身份验证信息句柄中设置用户名和密码</p>
                                 </li>
                                 <li>
                                    <p>使用<code class="codeph">OCISessionGet()</code>并将<code class="codeph">mode</code>设置为<code class="codeph">OCI_SESSGET_SPOOL</code>获取池化会话</p>
                                 </li>
                                 <li>
                                    <p>执行交易</p>
                                 </li>
                                 <li>
                                    <p>分配手柄</p>
                                 </li>
                                 <li>
                                    <p>准备声明</p>
                                    <div class="infoboxnote" id="GUID-9DD6C967-B3F8-4D26-B7F8-7730AABA7E8E__GUID-05DB4D0E-C365-4A1E-AA5D-C0F873C13754">
                                       <p class="notep1">注意：</p>
                                       <p>使用从OCI会话池获取的服务上下文时，您需要使用<code class="codeph">OCISessionGet()</code> （或<code class="codeph">OCILogon2()</code> ）返回的服务上下文，而不是在这些调用之外创建其他服务上下文。
                                       </p>
                                       <p>使用带有服务上下文的<code class="codeph">OCIStmtPrepare2()</code>获得的任何语句句柄应该随后仅与相同的服务上下文一起使用，并且永远不会与不同的服务上下文一起使用。
                                       </p>
                                    </div>
                                 </li>
                                 <li>
                                    <p>执行声明</p>
                                 </li>
                                 <li>
                                    <p>提交或回滚交易</p>
                                 </li>
                                 <li>
                                    <p>使用<code class="codeph">OCISessionRelease()</code>释放会话（注销<code class="codeph">OCISessionRelease()</code></p>
                                 </li>
                                 <li>
                                    <p>使用<code class="codeph">OCIHandleFree()</code>释放身份验证信息句柄</p>
                                 </li>
                                 <li>
                                    <p>结束每个线程的循环</p>
                                 </li>
                              </ol>
                           </li>
                           <li>
                              <p>使用<code class="codeph">OCISessionPoolDestroy()</code>销毁会话池。
                              </p>
                           </li>
                        </ol>
                        <div class="infoboxnotealso" id="GUID-9DD6C967-B3F8-4D26-B7F8-7730AABA7E8E__GUID-BA450341-4516-4E24-A3C7-BB24B48886F9">
                           <p class="notep1">也可以看看：</p>
                           <ul style="list-style-type:disc">
                              <li>
                                 <p><a href="connect-authorize-and-initialize-functions.html#GUID-1E929CFB-9D96-4E8E-9F24-904AD539E555" title="初始化会话池以与OCI会话池和数据库驻留连接池（DRCP）一起使用。">OCISessionPoolCreate（）</a></p>
                              </li>
                              <li>
                                 <p><a href="handle-and-descriptor-functions.html#GUID-C5BF55F7-A110-4CB5-9663-5056590F12B5" title="返回指向已分配和初始化句柄的指针。">OCIHandleAlloc（）</a></p>
                              </li>
                              <li>
                                 <p><a href="handle-and-descriptor-functions.html#GUID-3741D7BD-7652-4D7A-8813-AC2AEA8D3B03" title="设置句柄或描述符的属性值。">OCIAttrSet（）</a></p>
                              </li>
                              <li>
                                 <p><a href="connect-authorize-and-initialize-functions.html#GUID-890DFBC4-718B-4339-A0EA-6226A25B8241" title="获取一个会话。">OCISessionGet（）</a></p>
                              </li>
                              <li>
                                 <p><a href="connect-authorize-and-initialize-functions.html#GUID-425D4B32-257C-480E-B69C-7112BE9482E6" title="获取一个会话。">OCILogon2（）</a></p>
                              </li>
                              <li>
                                 <p><a href="statement-functions.html#GUID-E6C1DC67-D464-4D2A-9F19-737423D31779" title="准备SQL或PL / SQL语句以便执行。">OCIStmtPrepare2（）</a></p>
                              </li>
                              <li>
                                 <p><a href="connect-authorize-and-initialize-functions.html#GUID-DAAECC99-A432-48B5-AC33-0868C2FE762D" title="释放使用OCISessionGet（）检索的会话。">OCISessionRelease（）</a></p>
                              </li>
                              <li>
                                 <p><a href="handle-and-descriptor-functions.html#GUID-E87E9F91-D3DC-4F35-BE7C-F1EFBFEEBA0A" title="显式释放句柄">OCIHandleFree（）</a></p>
                              </li>
                              <li>
                                 <p><a href="connect-authorize-and-initialize-functions.html#GUID-2797C90C-C7AC-47FB-B1C2-CE41B743FB5C" title="销毁会话池。">OCISessionPoolDestroy（）</a></p>
                              </li>
                           </ul>
                        </div>
                     </div>
                     <!-- class="section" -->
                  </div>
               </div><a id="LNOCI16625"></a><div class="props_rev_3"><a id="GUID-CE43701B-ACB2-4F3A-B7CA-332CBD01DCCE" name="GUID-CE43701B-ACB2-4F3A-B7CA-332CBD01DCCE"></a><h4 id="LNOCI-GUID-CE43701B-ACB2-4F3A-B7CA-332CBD01DCCE" class="sect4"><span class="enumeration_section">11.1.6</span> OCI呼叫会话池</h4>
                  <div>
                     <p>描述OCI调用会话池的用法。</p>
                     <p>OCI提供会话池调用以执行以下任务：</p>
                     <ul style="list-style-type:disc">
                        <li>
                           <p><a href="session-and-connection-pooling.html#GUID-C09AF9F9-34EB-4D1D-849E-9B962463C7A7" title="连接池要求OCIHandleAlloc（）分配池句柄OCI_HTYPE_CPOOL。">分配池句柄</a></p>
                        </li>
                        <li>
                           <p><a href="session-and-connection-pooling.html#GUID-4298BCA2-0EE0-4B77-B9CB-88845562F44C" title="函数OCIConnectionPoolCreate（）初始化连接池句柄。">创建连接池</a></p>
                        </li>
                        <li>
                           <p><a href="session-and-connection-pooling.html#GUID-1DB08E60-053F-4D7B-A56D-FE42FE9463B5" title="应用程序可以使用多个接口之一。">登录数据库</a></p>
                        </li>
                        <li>
                           <p><a href="session-and-connection-pooling.html#GUID-73DFAAA9-4EB2-44ED-9DEC-2B803B990AE2" title="选择适当的调用以在连接池模式下从数据库注销。">从数据库注销</a></p>
                        </li>
                        <li>
                           <p><a href="session-and-connection-pooling.html#GUID-CB0DC00D-C935-41BC-AF4B-29C3288B743B" title="OCIConnectionPoolDestroy（）会破坏它。">销毁连接池</a></p>
                        </li>
                        <li>
                           <p><a href="session-and-connection-pooling.html#GUID-676CFBC3-69CC-447B-B0A5-B58BE827291E" title="使用OCIHandleFree（）释放池句柄。">免费使用泳池手柄</a></p>
                        </li>
                     </ul>
                  </div><a id="LNOCI16626"></a><div class="props_rev_3"><a id="GUID-1F691FCF-3986-43D7-AA27-82117745B105" name="GUID-1F691FCF-3986-43D7-AA27-82117745B105"></a><h5 id="LNOCI-GUID-1F691FCF-3986-43D7-AA27-82117745B105" class="sect5"><span class="enumeration_section">11.1.6.1</span>分配池句柄</h5>
                     <div>
                        <p>会话池要求通过调用<code class="codeph">OCIHandleAlloc()</code>来分配池句柄<code class="codeph">OCI_HTYPE_SPOOL</code> 。
                        </p>
                        <p>可以为给定的环境句柄创建多个池。对于单个会话池，这是一个分配示例：</p><pre class="oac_no_warn" dir="ltr">OCISPool * poolhp; OCIHandleAlloc（（void *）envhp，（void **）＆poolhp，OCI_HTYPE_SPOOL，（size_t）0，（void **）0））;</pre><div class="infoboxnotealso" id="GUID-1F691FCF-3986-43D7-AA27-82117745B105__GUID-F7541843-6EA7-4CB1-A88B-C9B4AF328810">
                           <p class="notep1">也可以看看：</p>
                           <p><a href="handle-and-descriptor-functions.html#GUID-C5BF55F7-A110-4CB5-9663-5056590F12B5" title="返回指向已分配和初始化句柄的指针。">OCIHandleAlloc（）</a></p>
                        </div>
                     </div>
                  </div><a id="LNOCI16627"></a><div class="props_rev_3"><a id="GUID-15516E6A-868C-4C7E-8272-92C270C160A4" name="GUID-15516E6A-868C-4C7E-8272-92C270C160A4"></a><h5 id="LNOCI-GUID-15516E6A-868C-4C7E-8272-92C270C160A4" class="sect5"><span class="enumeration_section">11.1.6.2</span>创建池会话</h5>
                     <div>
                        <p>您可以使用<code class="codeph">OCISessionPoolCreate()</code>函数来创建会话池。
                        </p>
                        <p>以下是如何使用此调用的示例：</p><pre class="oac_no_warn" dir="ltr">OCISessionPoolCreate（envhp，errhp，poolhp，（OraText **）＆poolName，（ub4 *）＆poolNameLen，database，（ub4）strlen（（const signed char *）database），sessMin，sessMax，sessIncr，（OraText *）appusername，（ ub4）strlen（（const signed char *）appusername），（OraText *）apppassword，（ub4）strlen（（const signed char *）apppassword），OCI_DEFAULT）;</pre><div class="infoboxnotealso" id="GUID-15516E6A-868C-4C7E-8272-92C270C160A4__GUID-72E883EB-155C-42CF-9305-E6E3C721F1E6">
                           <p class="notep1">也可以看看：</p>
                           <p><a href="connect-authorize-and-initialize-functions.html#GUID-1E929CFB-9D96-4E8E-9F24-904AD539E555" title="初始化会话池以与OCI会话池和数据库驻留连接池（DRCP）一起使用。">OCISessionPoolCreate（）</a></p>
                        </div>
                     </div>
                  </div><a id="LNOCI16628"></a><div class="props_rev_3"><a id="GUID-7894AB6A-0CCD-4F22-9B84-5B40B2FC636C" name="GUID-7894AB6A-0CCD-4F22-9B84-5B40B2FC636C"></a><h5 id="LNOCI-GUID-7894AB6A-0CCD-4F22-9B84-5B40B2FC636C" class="sect5"><span class="enumeration_section">11.1.6.3</span>登录数据库</h5>
                     <div>
                        <p>您可以使用这些调用以会话池模式登录数据库。</p>
                        <ul style="list-style-type:disc">
                           <li>
                              <p><code class="codeph">OCILogon2（）</code></p>
                              <p>这是最简单的电话。但是，它不会为用户提供使用标记的选项。以下是如何使用<code class="codeph">OCILogon2()</code>以会话池模式登录数据库的示例：</p><pre class="oac_no_warn" dir="ltr">for（i = 0; i &lt;MAXTHREADS; ++ i）{OCILogon2（envhp，errhp，＆svchp [i]，“hr”，2，“hr”，2，poolName，poolNameLen，OCI_LOGON2_SPOOL））; }</pre></li>
                           <li>
                              <p><code class="codeph">OCISessionGet（）</code></p>
                              <p>这是建议的使用呼叫。它为用户提供了使用标记来标记池中会话的选项，这使得检索特定会话变得更加容易。下面是使用<code class="codeph">OCISessionGet()</code>的示例。它取自<code class="codeph">demo</code>目录中的<code class="codeph">cdemosp.c</code> 。
                              </p><pre class="oac_no_warn" dir="ltr">OCISessionGet（envhp，errhp，＆svchp，authInfop，（OraText *）数据库，strlen（数据库），tag，strlen（tag），＆retTag，＆retTagLen，＆found，OCI_SESSGET_SPOOL）;</pre><p>使用从OCI会话池获取的服务上下文时，您需要使用<code class="codeph">OCISessionGet()</code> （或<code class="codeph">OCILogon2()</code> ）返回的服务上下文，而不是在这些调用之外创建其他服务上下文。
                              </p>
                              <p>使用带有服务上下文的<code class="codeph">OCIStmtPrepare2()</code>获得的任何语句句柄应该随后仅与相同的服务上下文一起使用，并且永远不会与不同的服务上下文一起使用。
                              </p>
                           </li>
                        </ul>
                        <div class="infoboxnotealso" id="GUID-7894AB6A-0CCD-4F22-9B84-5B40B2FC636C__GUID-154E065D-9EC6-4EF6-A9BD-5B11B67C5A8B">
                           <p class="notep1">也可以看看：</p>
                           <ul style="list-style-type:disc">
                              <li>
                                 <p><a href="connect-authorize-and-initialize-functions.html#GUID-425D4B32-257C-480E-B69C-7112BE9482E6" title="获取一个会话。">OCILogon2（）</a></p>
                              </li>
                              <li>
                                 <p><a href="connect-authorize-and-initialize-functions.html#GUID-890DFBC4-718B-4339-A0EA-6226A25B8241" title="获取一个会话。">OCISessionGet（）</a></p>
                              </li>
                              <li>
                                 <p><a href="statement-functions.html#GUID-E6C1DC67-D464-4D2A-9F19-737423D31779" title="准备SQL或PL / SQL语句以便执行。">OCIStmtPrepare2（）</a></p>
                              </li>
                           </ul>
                        </div>
                     </div>
                  </div><a id="LNOCI16629"></a><div class="props_rev_3"><a id="GUID-618B7C74-0045-4170-B50E-163BB364AF04" name="GUID-618B7C74-0045-4170-B50E-163BB364AF04"></a><h5 id="LNOCI-GUID-618B7C74-0045-4170-B50E-163BB364AF04" class="sect5"><span class="enumeration_section">11.1.6.4</span>从数据库注销</h5>
                     <div>
                        <p>表示根据登录调用以会话池模式从数据库注销的两种方法。</p>
                        <p>从以下调用中，选择与登录调用对应的调用，并使用它以会话池模式从数据库注销。</p>
                        <ul style="list-style-type:disc">
                           <li>
                              <p><code class="codeph">OCILogoff（）</code></p>
                              <p>如果使用<code class="codeph">OCILogon2()</code>建立连接，则必须调用<code class="codeph">OCILogoff()</code>进行注销。
                              </p>
                           </li>
                           <li>
                              <p><code class="codeph">OCISessionRelease（）</code></p>
                              <p>如果您使用<code class="codeph">OCISessionGet()</code>建立连接，则必须调用<code class="codeph">OCISessionRelease()</code>进行注销。待处理的交易会自动提交。
                              </p>
                           </li>
                        </ul>
                        <div class="infoboxnotealso" id="GUID-618B7C74-0045-4170-B50E-163BB364AF04__GUID-68D3E9C1-3D30-4022-B84C-7889F33A4782">
                           <p class="notep1">也可以看看：</p>
                           <ul style="list-style-type:disc">
                              <li>
                                 <p><a href="connect-authorize-and-initialize-functions.html#GUID-567DA731-ABC9-4348-B29C-7B2C6C1D7C36" title="释放使用OCILogon2（）或OCILogon（）检索的会话。">OCILogoff（）</a></p>
                              </li>
                              <li>
                                 <p><a href="connect-authorize-and-initialize-functions.html#GUID-425D4B32-257C-480E-B69C-7112BE9482E6" title="获取一个会话。">OCILogon2（）</a></p>
                              </li>
                              <li>
                                 <p><a href="connect-authorize-and-initialize-functions.html#GUID-DAAECC99-A432-48B5-AC33-0868C2FE762D" title="释放使用OCISessionGet（）检索的会话。">OCISessionRelease（）</a></p>
                              </li>
                              <li>
                                 <p><a href="connect-authorize-and-initialize-functions.html#GUID-890DFBC4-718B-4339-A0EA-6226A25B8241" title="获取一个会话。">OCISessionGet（）</a></p>
                              </li>
                           </ul>
                        </div>
                     </div>
                  </div><a id="LNOCI16630"></a><div class="props_rev_3"><a id="GUID-4E12F09A-D461-4B10-AD8D-48C2E492D6BB" name="GUID-4E12F09A-D461-4B10-AD8D-48C2E492D6BB"></a><h5 id="LNOCI-GUID-4E12F09A-D461-4B10-AD8D-48C2E492D6BB" class="sect5"><span class="enumeration_section">11.1.6.5</span>销毁会话池</h5>
                     <div>
                        <p>调用<code class="codeph">OCISessionPoolDestroy()</code>来销毁会话池。
                        </p>
                        <p>这在以下示例中显示：</p><pre class="oac_no_warn" dir="ltr">OCISessionPoolDestroy（poolhp，errhp，OCI_DEFAULT）;</pre><div class="infoboxnotealso" id="GUID-4E12F09A-D461-4B10-AD8D-48C2E492D6BB__GUID-98BE1EB0-6D0F-4752-A3BE-06A64D1F2089">
                           <p class="notep1">也可以看看：</p>
                           <p><a href="connect-authorize-and-initialize-functions.html#GUID-2797C90C-C7AC-47FB-B1C2-CE41B743FB5C" title="销毁会话池。">OCISessionPoolDestroy（）</a></p>
                        </div>
                     </div>
                  </div><a id="LNOCI16631"></a><div class="props_rev_3"><a id="GUID-B28BBFF7-2965-4D2C-B554-9AAE174DB461" name="GUID-B28BBFF7-2965-4D2C-B554-9AAE174DB461"></a><h5 id="LNOCI-GUID-B28BBFF7-2965-4D2C-B554-9AAE174DB461" class="sect5"><span class="enumeration_section">11.1.6.6</span>释放池手柄</h5>
                     <div>
                        <p>调用<code class="codeph">OCIHandleFree()</code>以释放会话池句柄。
                        </p>
                        <p>这在以下示例中显示：</p><pre class="oac_no_warn" dir="ltr">OCIHandleFree（（void *）poolhp，OCI_HTYPE_SPOOL）;</pre><div class="infoboxnote" id="GUID-B28BBFF7-2965-4D2C-B554-9AAE174DB461__GUID-CD59014D-9D14-4EFE-B690-E4AC53CAC232">
                           <p class="notep1">注意：</p>
                           <p>开发人员：建议您在将连接释放回池之前提交或回滚任何打开的事务。如果不这样做，Oracle Database会在释放连接时自动提交任何打开的事务。</p>
                           <p>如果在使用会话池时检测到实例故障，OCI会尝试清除该实例的会话。</p>
                        </div>
                        <div class="infoboxnotealso" id="GUID-B28BBFF7-2965-4D2C-B554-9AAE174DB461__GUID-B61E2625-FE1C-4B9A-B4FA-E8366591BF17">
                           <p class="notep1">也可以看看：</p>
                           <p><a href="handle-and-descriptor-functions.html#GUID-E87E9F91-D3DC-4F35-BE7C-F1EFBFEEBA0A" title="显式释放句柄">OCIHandleFree（）</a></p>
                        </div>
                     </div>
                  </div>
               </div><a id="LNOCI16632"></a><div class="props_rev_3"><a id="GUID-72D13726-61B8-4CAB-9120-4E33714688AE" name="GUID-72D13726-61B8-4CAB-9120-4E33714688AE"></a><h4 id="LNOCI-GUID-72D13726-61B8-4CAB-9120-4E33714688AE" class="sect4"><span class="enumeration_section">11.1.7</span> OCI会话池示例</h4>
                  <div>
                     <p>在哪里可以找到经过测试的完整程序中的会话池示例。</p>
                     <p>有关已测试完整程序中的会话池的示例，请参阅目录<code class="codeph">demo</code> <code class="codeph">cdemosp.c</code> 。
                     </p>
                  </div>
               </div>
            </div><a id="LNOCI9110"></a><div class="props_rev_3"><a id="GUID-1E260CD3-2EF7-49FF-97FC-041C2EF60381" name="GUID-1E260CD3-2EF7-49FF-97FC-041C2EF60381"></a><h3 id="LNOCI-GUID-1E260CD3-2EF7-49FF-97FC-041C2EF60381" class="sect3"><span class="enumeration_section">11.2</span>数据库驻留连接池</h3>
               <div>
                  <p>数据库驻留连接池（DRCP）在数据库服务器中为典型的Web应用程序使用方案提供连接池，其中应用程序获取数据库连接，对其进行相对较短的持续时间，然后释放它。</p>
                  <p>DRCP池服务器进程，每个进程相当于专用服务器进程和数据库会话的组合。（此后，这些“专用”服务器进程称为<span class="italic">池化服务器</span> 。）
                  </p>
                  <p>DRCP补充了在中间层进程中共享线程之间的连接的中间层连接池。此外，DRCP还允许在同一中间层主机上甚至跨中间层主机的中间层进程之间共享数据库连接。这样可以显着减少支持大量客户端连接所需的关键数据库资源，从而减少数据库层内存占用并提高中间层和数据库层的可伸缩性。拥有一个随时可用的服务器池可以降低创建和拆除客户端连接的成本。</p>
                  <p>DRCP尤其适用于具有无法进行中间层连接池的多进程单线程应用程序服务器（如PHP / Apache）的体系结构。使用DRCP，数据库可以扩展到数万个并发连接。</p>
                  <div class="infoboxnotealso" id="GUID-1E260CD3-2EF7-49FF-97FC-041C2EF60381__GUID-7437CBB6-FBC4-4A2D-96A8-B55881510B27">
                     <p class="notep1">也可以看看：</p>
                     <p>有关DRCP的完整信息，请参见<a href="../adfns/performance-and-scalability.html#ADFNS228" target="_blank"><span><cite>“Oracle数据库开发指南</cite></span></a></p>
                  </div>
               </div>
            </div>
            <div class="sect2"><a id="GUID-BF9AFFD6-537A-4252-BBFB-3A60EEAC3E61" name="GUID-BF9AFFD6-537A-4252-BBFB-3A60EEAC3E61"></a><h3 id="LNOCI-GUID-BF9AFFD6-537A-4252-BBFB-3A60EEAC3E61" class="sect3"><span class="enumeration_section">11.3</span>关于在Traffic Director模式下使用Oracle Connection Manager</h3>
               <div>
                  <p>Traffic Director Mode中的Oracle Connection Manager是一个放置在支持的数据库客户端和数据库实例之间的代理。</p>
                  <div class="p">Oracle Database <span class="italic">11g</span>第2版（11.2）及更高版本中支持的客户端可以在Traffic Director模式下连接到Oracle Connection Manager。流量控制器模式中的Oracle连接管理器为计划内和计划外数据库服务器中断，连接多路复用支持和负载平衡提供了改进的高可用性（HA）。以下各节将更详细地介绍对Traffic Director模式中的Oracle Connection Manager的支持<ul style="list-style-type:disc">
                        <li>
                           <p><a href="session-and-connection-pooling.html#GUID-BF9AFFD6-537A-4252-BBFB-3A60EEAC3E61__MODESOFOPERATION-4FD4C8FE">运作模式</a></p>
                        </li>
                        <li>
                           <p><a href="session-and-connection-pooling.html#GUID-BF9AFFD6-537A-4252-BBFB-3A60EEAC3E61__KEYFEATURES-4FD4D08F">主要特点</a></p>
                        </li>
                     </ul>
                  </div>
                  <div class="section" id="GUID-BF9AFFD6-537A-4252-BBFB-3A60EEAC3E61__MODESOFOPERATION-4FD4C8FE">
                     <p class="subhead2" id="GUID-BF9AFFD6-537A-4252-BBFB-3A60EEAC3E61__GUID-749BC524-93BC-42F1-B765-970605875B7F">运作模式</p>
                     <p>流量控制器模式中的Oracle连接管理器支持以下操作模式：</p>
                     <ul style="list-style-type:disc">
                        <li>
                           <div class="p">在池连接模式下，流量控制器模式中的Oracle连接管理器支持使用以下数据库客户端版本的任何应用程序：<ul style="list-style-type:disc">
                                 <li>
                                    <p>OCI，OCCI和开源驱动程序（Oracle Database <span class="italic">11g第</span> 2版（11.2.0.4）及更高版本））</p>
                                 </li>
                                 <li>
                                    <p>JDBC（Oracle Database 12c <span class="italic">第</span> 1版（12.1）及更高版本）</p>
                                 </li>
                                 <li>
                                    <p>ODP.NET（Oracle Database 12 <span class="italic">c第</span> 2版（12.2）及更高版本）</p>
                                 </li>
                              </ul>
                           </div>
                           <p>此外，应用程序必须使用DRCP。也就是说，应用程序必须在连接字符串（或<code class="codeph">tnsnames.ora</code>别名）中启用DRCP。
                           </p>
                        </li>
                        <li>
                           <p>在非池化连接（或专用）模式下，流量控制器模式中的Oracle连接管理器支持使用数据库客户机版本Oracle Database <span class="italic">11g第</span> 2版（11.2.0.4）及更高版本的任何应用程序。在此模式下，某些功能（如连接多路复用）不可用。
                           </p>
                        </li>
                     </ul>
                  </div>
                  <!-- class="section" -->
                  <div class="section" id="GUID-BF9AFFD6-537A-4252-BBFB-3A60EEAC3E61__KEYFEATURES-4FD4D08F">
                     <p class="subhead2" id="GUID-BF9AFFD6-537A-4252-BBFB-3A60EEAC3E61__GUID-3A52B2C3-D63C-4ACB-8FED-1BAFC3801338">主要特点</p>
                     <div class="p">Traffic Director Mode中的Oracle Connection Manager提供以下支持：<ul style="list-style-type:disc">
                           <li>
                              <div class="p">透明的性能增强和连接多路复用，包括：<ul style="list-style-type:disc">
                                    <li>
                                       <p>对所有操作模式自动启用语句高速缓存，行预取和结果集高速缓存。</p>
                                    </li>
                                    <li>
                                       <p>使用代理驻留连接池（PRCP）的数据库会话多路复用（仅池化模式），其中PRCP是数据库驻留连接池（DRCP）的代理模式。应用程序在Traffic Director模式下的Oracle Connection Manager与数据库之间获得透明的连接时负载平衡和运行时负载平衡。</p>
                                    </li>
                                    <li>
                                       <p>对于Traffic Director模式实例中的多个Oracle Connection Manager，应用程序通过客户端连接时间负载平衡或负载均衡器（BIG-IP，NGINX等）获得更高的可扩展性</p>
                                    </li>
                                 </ul>
                              </div>
                           </li>
                           <li>
                              <div class="p">零应用程序停机时间<ul style="list-style-type:disc">
                                    <li>
                                       <div class="p">计划数据库维护或可插拔数据库（PDB）重定位<ul style="list-style-type:disc">
                                             <li>
                                                <p>合并模式</p>
                                                <p>流量控制器模式中的Oracle Connection Manager响应Oracle Notification Service（ONS）事件以计划中断和重定向工作。请求完成后，在流量控制器模式下，Oracle Connection Manager上的池中的连接将耗尽。Oracle Database <span class="italic">11g第</span> 2版（11.2.0.4）及更高版本支持服务重定位。
                                                </p>
                                                <p>对于PDB重定位，当PDB重新定位时，流量控制器模式中的Oracle连接管理器会响应带内通知，即使未配置ONS时也是如此（对于Oracle数据库版本18c，仅限版本18.1及更高版本的服务器）</p>
                                             </li>
                                             <li>
                                                <p>非汇集或专用模式</p>
                                                <div class="p">当客户端没有请求边界信息时，流量控制器模式中的Oracle连接管理器支持许多应用程序的计划中断（只要在请求/事务边界上只需要保留简单的会话状态和游标状态）。这种支持包括：<ul style="list-style-type:disc">
                                                      <li>
                                                         <p>在事务边界处停止服务/ PDB，或者利用Oracle数据库版本18c连续应用程序可用性来停止请求边界处的服务</p>
                                                      </li>
                                                      <li>
                                                         <p>流量控制器模式中的Oracle连接管理器利用透明应用程序故障转移（TAF）故障转移还原来重新连接和还原简单状态。</p>
                                                      </li>
                                                   </ul>
                                                </div>
                                             </li>
                                          </ul>
                                       </div>
                                    </li>
                                    <li>
                                       <p>针对大多数读取工作负载的计划外数据库中断</p>
                                    </li>
                                 </ul>
                              </div>
                           </li>
                           <li>
                              <div class="p">流量控制器模式中Oracle Connection Manager的高可用性，以避免单点故障。这得到以下支持：<ul style="list-style-type:disc">
                                    <li>
                                       <p>流量控制器模式中的多个Oracle连接管理器实例，使用连接字符串中的负载平衡器或客户端负载平衡/故障转移</p>
                                    </li>
                                    <li>
                                       <p>在Traffic Director模式实例中滚动升级Oracle Connection Manager</p>
                                    </li>
                                    <li>
                                       <p>针对计划中断，在流量控制器模式下从客户端到Oracle Connection Manager的现有连接的正常关闭</p>
                                    </li>
                                    <li>
                                       <p>带有Oracle数据库版本18c及更高版本客户端的带内通知</p>
                                    </li>
                                    <li>
                                       <p>对于较旧的客户端，通知将与当前请求的响应一起发送</p>
                                    </li>
                                 </ul>
                              </div>
                           </li>
                           <li>
                              <div class="p">为了安全性和隔离性，Traffic Director Mode中的Oracle Connection Manager提供：<ul style="list-style-type:disc">
                                    <li>
                                       <p>数据库代理支持传输控制协议/传输控制协议安全（TCP / TCPS）和协议转换</p>
                                    </li>
                                    <li>
                                       <p>防火墙基于IP地址，服务名称和安全套接字层/传输层安全性（SSL / TLS）钱包</p>
                                    </li>
                                    <li>
                                       <p>多租户环境中的租户隔离</p>
                                    </li>
                                    <li>
                                       <p>防止拒绝服务和模糊测试攻击</p>
                                    </li>
                                    <li>
                                       <p>跨Oracle数据库本地和Oracle Cloud安全地隧道传输数据库流量</p>
                                    </li>
                                 </ul>
                              </div>
                           </li>
                        </ul>
                     </div>
                  </div>
                  <!-- class="section" -->
                  <div class="section">
                     <div class="infoboxnotealso" id="GUID-BF9AFFD6-537A-4252-BBFB-3A60EEAC3E61__GUID-A2DD3A99-8792-4704-A482-B66B30AD1B85">
                        <p class="notep1">也可以看看：</p>
                        <ul style="list-style-type:disc">
                           <li>
                              <p>有关配置<code class="codeph">cman.ora</code>配置文件以在Traffic Director模式下设置Oracle Connection Manager的信息，请<code class="codeph">cman.ora</code> <a href="../netag/configuring-oracle-connection-manager.html#NETAG-GUID-3917FC5D-4B23-4752-85BA-39A88C4D13F8" target="_blank"><span><cite>“Oracle数据库网络服务管理员指南”</cite></span></a></p>
                           </li>
                           <li>
                              <p><a href="../netag/configuring-oracle-connection-manager.html#NETAG-GUID-58847B76-3836-41DB-9EB6-A81D5C397024" target="_blank"><span><cite>“Oracle数据库网络服务管理员指南”</cite></span></a> ，了解有关在Traffic Director模式代理身份验证中为Oracle Connection Manager配置数据库的信息</p>
                           </li>
                           <li>
                              <p><a href="../netag/configuring-oracle-connection-manager.html#NETAG-GUID-96FA23BA-F32B-4D47-9CBB-69D27E8D94F6" target="_blank"><span><cite>“Oracle数据库网络服务管理员指南”</cite></span></a> ，了解有关在流量控制器模式下为计划外停机事件配置Oracle Connection Manager的信息</p>
                           </li>
                           <li>
                              <p><a href="../netag/configuring-oracle-connection-manager.html#NETAG-GUID-E73658E7-BBF7-4C13-AAD5-70D32062AD8D" target="_blank"><span><cite>“Oracle数据库网络服务管理员指南”</cite></span></a> ，了解有关在Traffic Director模式下为计划的关闭事件配置Oracle Connection Manager的信息</p>
                           </li>
                           <li>
                              <p><a href="../netag/configuring-oracle-connection-manager.html#NETAG-GUID-15756B12-5ED5-4EDE-9D4B-6B890D5BE9AF" target="_blank"><span><cite>“Oracle数据库网络服务管理员指南”，</cite></span></a>以获取有关在流量控制器模式下配置Oracle Connection Manager使用的代理驻留连接池的信息</p>
                           </li>
                           <li>
                              <p><a href="https://www.oracle.com/pls/topic/lookup?ctx=en/database/oracle/oracle-database/19/lnoci&amp;id=NETAG-GUID-FC833F8F-CE5A-4C02-A962-244954158853" target="_blank"><span><cite>“Oracle数据库网络服务管理员指南”</cite></span></a> ，了解有关在流量控制器模式下使用Oracle Connection Manager的所有驱动程序不支持的功能的信息</p>
                           </li>
                           <li>
                              <p><a href="../netrf/index.html" target="_blank"><span><cite>Oracle Database Net Services参考</cite></span></a> ，以获取Oracle CMAN配置文件的概述</p>
                           </li>
                        </ul>
                     </div>
                  </div>
                  <!-- class="section" -->
               </div>
            </div><a id="LNOCI16602"></a><div class="props_rev_3"><a id="GUID-1C9A6E8F-EF5A-478D-B65E-CE39D4F00683" name="GUID-1C9A6E8F-EF5A-478D-B65E-CE39D4F00683"></a><h3 id="LNOCI-GUID-1C9A6E8F-EF5A-478D-B65E-CE39D4F00683" class="sect3"><span class="enumeration_section">11.4</span> OCI中的连接池</h3>
               <div>
                  <p>连接池是指通过多个会话使用可重用物理连接的组（池）来平衡负载。</p>
                  <p>该池由OCI管理，而不是应用程序。可以使用连接池的应用程序包括Web应用程序服务器和电子邮件服务器的中间层应用程序。</p>
                  <p>此功能的一个用途是在连接到后端Oracle数据库的Web应用程序服务器中。假设Web应用程序服务器从数据库服务器获取数据的多个并发请求。应用程序可以在应用程序初始化期间在每个环境中创建池（或一组池）。</p>
                  <div class="p">本节包括以下主题：<ul style="list-style-type:disc">
                        <li>
                           <p><a href="session-and-connection-pooling.html#GUID-C7AB12E8-E640-41F0-9C28-E68F7E683694" title="middletier上的连接池类似于共享服务器在后端提供的内容。无状态会话可跨中间线程连续重复使用。您可以将多个连接池的高级概念用于不同的数据库连接。为连接池启用了事务应用程序故障转移（TAF）。">OCI连接池概念</a></p>
                        </li>
                        <li>
                           <p><a href="session-and-connection-pooling.html#GUID-322FF18E-48AE-4B94-8477-E91127F6BA86" title="列出在应用程序中使用连接池必须遵循的步骤。">使用OCI调用连接池</a></p>
                        </li>
                        <li>
                           <p><a href="session-and-connection-pooling.html#GUID-AE06BCB1-7333-458E-90F0-0761496EC5E1" title="哪里可以找到经过测试的完整程序中的连接池示例。">OCI连接池的示例</a></p>
                        </li>
                     </ul>
                  </div>
               </div><a id="LNOCI16603"></a><div class="props_rev_3"><a id="GUID-C7AB12E8-E640-41F0-9C28-E68F7E683694" name="GUID-C7AB12E8-E640-41F0-9C28-E68F7E683694"></a><h4 id="LNOCI-GUID-C7AB12E8-E640-41F0-9C28-E68F7E683694" class="sect4"><span class="enumeration_section">11.4.1</span> OCI连接池概念</h4>
                  <div>
                     <p>Oracle数据库具有多种事务监视功能，例如数据库会话和连接的细粒度管理。通过将数据库会话（用户句柄）的概念与连接（服务器句柄）分开来完成数据库会话的细粒度管理。通过使用OCI调用进行会话切换和会话迁移，应用程序服务器或事务监视器可以通过较少的物理连接复用多个会话，从而通过池化连接和后端Oracle服务器进程实现高度可伸缩性。</p>
                     <p>连接池本身通常配置有共享的物理连接池，转换为包含相同数量的专用服务器进程的后端服务器池。</p>
                     <p>物理连接数小于应用程序使用的数据库会话数。使用连接池还可以减少物理连接和后端服务器进程的数量。因此可以多路复用更多的数据库会话。</p>
                     <div class="p">本节包括以下主题：<ul style="list-style-type:disc">
                           <li>
                              <p><a href="session-and-connection-pooling.html#GUID-3C6F8FF3-195D-4DCB-B684-8102004F4686" title="middletier上的连接池类似于共享服务器在后端提供的内容。">与共享服务器的异同</a></p>
                           </li>
                           <li>
                              <p><a href="session-and-connection-pooling.html#GUID-11F389B2-7D7A-4188-96AC-438C25139C4D" title="无状态会话可跨中间线程连续重复使用。">无国籍会议与有状态会议</a></p>
                           </li>
                           <li>
                              <p><a href="session-and-connection-pooling.html#GUID-46A224F5-1BF9-4AE0-BCF1-5222CB913B09" title="您可以将多个连接池的高级概念用于不同的数据库连接。">多个连接池</a></p>
                           </li>
                           <li>
                              <p><a href="session-and-connection-pooling.html#GUID-55F39E75-40EB-464B-AEFB-75FF8ABD0169" title="为连接池启用了事务应用程序故障转移（TAF）。">透明应用程序故障转移</a></p>
                           </li>
                        </ul>
                     </div>
                  </div><a id="LNOCI16604"></a><div class="props_rev_3"><a id="GUID-3C6F8FF3-195D-4DCB-B684-8102004F4686" name="GUID-3C6F8FF3-195D-4DCB-B684-8102004F4686"></a><h5 id="LNOCI-GUID-3C6F8FF3-195D-4DCB-B684-8102004F4686" class="sect5"><span class="enumeration_section">11.4.1.1</span>与共享服务器的异同</h5>
                     <div>
                        <p>middletier上的连接池类似于共享服务器在后端提供的内容。</p>
                        <p>通过管理中间层上的会话多路复用逻辑，连接池使专用服务器实例的行为类似于共享服务器实例。</p>
                        <p>中间层上的连接池控制专用服务器进程的池化，包括到专用服务器进程的传入连接。连接池和共享服务器之间的主要区别在于，在后一种情况下，从客户端的连接通常是数据库实例中的调度程序。调度程序负责将客户机请求定向到适当的共享服务器。但是，连接池的物理连接直接从后端服务器池中的中间件到专用服务器进程建立。</p>
                        <p>仅当中间层是多线程时，连接池才有用。每个线程都可以维护与数据库的会话。与数据库的实际连接由连接池维护，这些连接（包括专用数据库服务器进程池）在中间层的所有线程之间共享。</p>
                     </div>
                  </div><a id="LNOCI16605"></a><div class="props_rev_3"><a id="GUID-11F389B2-7D7A-4188-96AC-438C25139C4D" name="GUID-11F389B2-7D7A-4188-96AC-438C25139C4D"></a><h5 id="LNOCI-GUID-11F389B2-7D7A-4188-96AC-438C25139C4D" class="sect5"><span class="enumeration_section">11.4.1.2</span>无状态会话与有状态会话</h5>
                     <div>
                        <p>无状态会话可跨中间线程连续重复使用。</p>
                        <p>在线程完成代表三层用户处理数据库请求之后，可以代表完全不同的三层用户重复使用相同的数据库会话来完成不同的请求。</p>
                        <p>但是，对数据库的有状态会话不能跨中间线程进行串行重用，因为它们可能具有与特定三层用户相关联的某些特定状态。此类状态的示例可以包括打开事务，来自语句的获取状态或PL / SQL包状态。只要状态存在，会话就不能为不同的请求重用。</p>
                        <div class="infoboxnote" id="GUID-11F389B2-7D7A-4188-96AC-438C25139C4D__GUID-8121CD53-9389-40B3-B6A7-F42107562E4B">
                           <p class="notep1">注意：</p>
                           <p>无状态会话也可能具有打开事务，打开语句获取状态等。但是，这种状态持续的时间相对较短（仅在处理中间层线程的特定三层请求期间），允许会话为不同的三层用户连续重用（当此状态为清理干净）。</p>
                           <p>无状态会话通常与语句缓存一起使用。</p>
                        </div>
                        <p>连接池提供的是无状态连接和有状态会话。</p>
                        <div class="infoboxnotealso" id="GUID-11F389B2-7D7A-4188-96AC-438C25139C4D__GUID-D99ECBE5-A379-48FF-B7AF-F87298C255F4">
                           <p class="notep1">也可以看看：</p>
                           <p>如果您必须使用无状态会话，则<a href="session-and-connection-pooling.html#GUID-F9662FFB-EAEF-495C-96FC-49C6D1D9625C" title="会话池意味着应用程序创建并维护一组无状态会话到数据库。">在OCI中进行会话池</a></p>
                        </div>
                     </div>
                  </div><a id="LNOCI16607"></a><a id="LNOCI16606"></a><div class="props_rev_3"><a id="GUID-46A224F5-1BF9-4AE0-BCF1-5222CB913B09" name="GUID-46A224F5-1BF9-4AE0-BCF1-5222CB913B09"></a><h5 id="LNOCI-GUID-46A224F5-1BF9-4AE0-BCF1-5222CB913B09" class="sect5"><span class="enumeration_section">11.4.1.3</span>多个连接池</h5>
                     <div>
                        <p>您可以将多个连接池的高级概念用于不同的数据库连接。</p>
                        <p>当为用户分配不同的优先级时，也可以使用多个连接池。可以使用连接池实现不同的服务级别保证。</p>
                        <p><a href="session-and-connection-pooling.html#GUID-46A224F5-1BF9-4AE0-BCF1-5222CB913B09__CHDHJEDC">图11-1</a>说明了OCI连接池。
                        </p>
                        <div class="figure" id="GUID-46A224F5-1BF9-4AE0-BCF1-5222CB913B09__CHDHJEDC">
                           <p class="titleinfigure">图11-1 OCI连接池</p><img src="img/lnoci043.gif" alt="下面是图11-1的描述" title="下面是图11-1的描述" longdesc="img_text/lnoci043.html"><br><a href="img_text/lnoci043.html">“图11-1 OCI连接池”的描述</a></div>
                        <!-- class="figure" -->
                     </div>
                  </div><a id="LNOCI16608"></a><div class="props_rev_3"><a id="GUID-55F39E75-40EB-464B-AEFB-75FF8ABD0169" name="GUID-55F39E75-40EB-464B-AEFB-75FF8ABD0169"></a><h5 id="LNOCI-GUID-55F39E75-40EB-464B-AEFB-75FF8ABD0169" class="sect5"><span class="enumeration_section">11.4.1.4</span>透明应用程序故障转移</h5>
                     <div>
                        <p>为连接池启用了事务应用程序故障转移（TAF）。</p>
                        <p>TAF的概念同样适用于连接池中的连接，除了不应在连接字符串中使用<code class="codeph">BACKUP</code>和<code class="codeph">PRECONNECT</code>子句，并且不能使用连接池和TAF。</p>
                        <p>当连接池中的连接进行故障转移时，它会使用主连接字符串本身进行连接。在实例失败后，会话将池用于数据库往返时会进行故障转移。侦听器配置为将连接路由到良好实例（如果可用），这与基于服务的连接字符串一样。</p>
                        <div class="infoboxnotealso" id="GUID-55F39E75-40EB-464B-AEFB-75FF8ABD0169__GUID-07806C44-89C5-4548-BED3-26D6214EBCDC">
                           <p class="notep1">也可以看看：</p>
                           <p><a href="../netag/enabling-advanced-features.html#NETAG0131" target="_blank"><span class="italic">“Oracle数据库网络服务管理员指南”</span></a> ，有关配置透明应用程序故障转移的章节</p>
                        </div>
                     </div>
                  </div>
               </div><a id="LNOCI091"></a><div class="props_rev_3"><a id="GUID-322FF18E-48AE-4B94-8477-E91127F6BA86" name="GUID-322FF18E-48AE-4B94-8477-E91127F6BA86"></a><h4 id="LNOCI-GUID-322FF18E-48AE-4B94-8477-E91127F6BA86" class="sect4"><span class="enumeration_section">11.4.2</span>使用OCI调用连接池</h4>
                  <div>
                     <p>列出在应用程序中使用连接池必须遵循的步骤。</p>
                     <div class="section">
                        <p>要在应用程序中使用连接池，您必须：</p>
                     </div>
                     <!-- class="section" -->
                     <ol>
                        <li><span><a href="session-and-connection-pooling.html#GUID-C09AF9F9-34EB-4D1D-849E-9B962463C7A7" title="连接池要求OCIHandleAlloc（）分配池句柄OCI_HTYPE_CPOOL。">分配池句柄</a></span></li>
                        <li><span><a href="session-and-connection-pooling.html#GUID-4298BCA2-0EE0-4B77-B9CB-88845562F44C" title="函数OCIConnectionPoolCreate（）初始化连接池句柄。">创建连接池</a></span></li>
                        <li><span><a href="session-and-connection-pooling.html#GUID-1DB08E60-053F-4D7B-A56D-FE42FE9463B5" title="应用程序可以使用多个接口之一。">登录数据库</a></span></li>
                        <li><span><a href="session-and-connection-pooling.html#GUID-497689F0-20A0-4CEF-91DC-594DBACED921" title="使用OCI_CPOOL模式（连接池），后端数据库中的会话内存（UGA）来自SGA。">处理连接池中的SGA限制</a></span></li>
                        <li><span><a href="session-and-connection-pooling.html#GUID-73DFAAA9-4EB2-44ED-9DEC-2B803B990AE2" title="选择适当的调用以在连接池模式下从数据库注销。">从数据库注销</a></span></li>
                        <li><span><a href="session-and-connection-pooling.html#GUID-CB0DC00D-C935-41BC-AF4B-29C3288B743B" title="OCIConnectionPoolDestroy（）会破坏它。">销毁连接池</a></span></li>
                        <li><span><a href="session-and-connection-pooling.html#GUID-676CFBC3-69CC-447B-B0A5-B58BE827291E" title="使用OCIHandleFree（）释放池句柄。">免费使用泳池手柄</a></span></li>
                     </ol>
                  </div><a id="LNOCI16609"></a><div class="props_rev_3"><a id="GUID-C09AF9F9-34EB-4D1D-849E-9B962463C7A7" name="GUID-C09AF9F9-34EB-4D1D-849E-9B962463C7A7"></a><h5 id="LNOCI-GUID-C09AF9F9-34EB-4D1D-849E-9B962463C7A7" class="sect5"><span class="enumeration_section">11.4.2.1</span>分配池句柄</h5>
                     <div>
                        <p>连接池要求<code class="codeph">OCIHandleAlloc()</code>分配池句柄<code class="codeph">OCI_HTYPE_CPOOL</code> 。
                        </p>
                        <div class="section">
                           <p>可以为给定的环境句柄创建多个池。</p>
                           <p>对于单个连接池，这是一个分配示例：</p><pre class="oac_no_warn" dir="ltr">OCICPool * poolhp; OCIHandleAlloc（（void *）envhp，（void **）＆poolhp，OCI_HTYPE_CPOOL，（size_t）0，（void **）0））;</pre><div class="infoboxnotealso" id="GUID-C09AF9F9-34EB-4D1D-849E-9B962463C7A7__GUID-D75099C1-D242-40F9-A937-82E507605152">
                              <p class="notep1">也可以看看：</p>
                              <p><a href="handle-and-descriptor-functions.html#GUID-C5BF55F7-A110-4CB5-9663-5056590F12B5" title="返回指向已分配和初始化句柄的指针。">OCIHandleAlloc（）</a></p>
                           </div>
                        </div>
                        <!-- class="section" -->
                     </div>
                  </div><a id="LNOCI16610"></a><div class="props_rev_3"><a id="GUID-4298BCA2-0EE0-4B77-B9CB-88845562F44C" name="GUID-4298BCA2-0EE0-4B77-B9CB-88845562F44C"></a><h5 id="LNOCI-GUID-4298BCA2-0EE0-4B77-B9CB-88845562F44C" class="sect5"><span class="enumeration_section">11.4.2.2</span>创建连接池</h5>
                     <div>
                        <p>函数<code class="codeph">OCIConnectionPoolCreate()</code>初始化连接池句柄。
                        </p>
                        <div class="section">
                           <p>它有这些<code class="codeph">IN</code>参数：</p>
                        </div>
                        <!-- class="section" -->
                        <div class="section">
                           <ul style="list-style-type:disc">
                              <li>
                                 <p><code class="codeph">connMin</code> ，创建池时要打开的最小连接数。
                                 </p>
                              </li>
                              <li>
                                 <p><code class="codeph">connIncr</code> ，当所有连接都忙且呼叫需要连接时要打开的增量连接数。仅当打开的连接总数小于可在该池中打开的最大连接数时，才使用此增量。
                                 </p>
                              </li>
                              <li>
                                 <p><code class="codeph">connMax</code> ，可以在池中打开的最大连接数。当池中打开最大连接数并且所有连接都忙时，如果呼叫需要连接，则等待直到达到连接。但是，如果为池设置了<code class="codeph">OCI_ATTR_CONN_NOWAIT</code>属性，则会返回错误。
                                 </p>
                              </li>
                              <li>
                                 <p><code class="codeph">poolUsername</code>和<code class="codeph">poolPassword</code> ，允许用户会话在池中的连接之间透明地迁移。
                                 </p>
                              </li>
                              <li>
                                 <p>此外，可以设置属性<code class="codeph">OCI_ATTR_CONN_TIMEOUT</code>以使池中的连接超时。空闲时间超过此时间的连接会定期终止，以保持最佳打开连接数。如果未设置此属性，则连接永远不会超时。
                                 </p>
                              </li>
                           </ul>
                           <div class="infoboxnote" id="GUID-4298BCA2-0EE0-4B77-B9CB-88845562F44C__GUID-2A07D24D-88CC-4CC3-828D-1AFB8A3865BD">
                              <p class="notep1">注意：</p>
                              <p>只有在网络往返时才会发生池的收缩。如果没有操作，则连接保持活动状态。</p>
                           </div>
                           <p>由于可以动态配置所有上述属性，因此应用程序可以读取当前负载（打开的连接数和繁忙连接数）并适当调整这些属性。</p>
                           <p>如果要动态更改池属性（ <code class="codeph">connMax</code> ， <code class="codeph">connMin</code> <span class="italic">，</span> <code class="codeph">connIncr</code> ），则必须在<code class="codeph">mode</code>设置为<code class="codeph">OCI_CPOOL_REINITIALIZE</code> <code class="codeph">mode</code>调用<code class="codeph">OCIConnectionPoolCreate()</code> 。</p>
                           <p>OUT参数<code class="codeph">poolName</code>和<code class="codeph">poolNameLen</code>包含要在后续<code class="codeph">OCIServerAttach()</code>和<code class="codeph">OCILogon2()</code>调用中使用的值，以代替数据库名称和数据库名称长度参数。
                           </p>
                           <p>应用程序可以创建的池数没有限制。中间层应用程序可以创建多个池以连接到同一服务器或不同的服务器，以根据应用程序的特定需求平衡负载。</p>
                           <p>以下是此调用的示例：</p><pre class="oac_no_warn" dir="ltr">OCIConnectionPoolCreate（（OCIEnv *）envhp，（OCIError *）errhp，（OCICPool *）poolhp，＆poolName，＆poolNameLen，（text *）database，strlen（database），（ub4）connMin，（ub4）connMax，（ub4）connIncr， （text *）poolUsername，strlen（poolUserLen），（text *）poolPassword，strlen（poolPassLen），OCI_DEFAULT））;</pre><div class="infoboxnotealso" id="GUID-4298BCA2-0EE0-4B77-B9CB-88845562F44C__GUID-6F1CEDE0-8FF2-4DA5-B83C-4266DF3E2336">
                              <p class="notep1">也可以看看：</p>
                              <ul style="list-style-type:disc">
                                 <li>
                                    <p><a href="connect-authorize-and-initialize-functions.html#GUID-7E5A69F2-0268-4655-845D-A7662902FAA2" title="初始化连接池。">OCIConnectionPoolCreate（）</a></p>
                                 </li>
                                 <li>
                                    <p><a href="handle-and-descriptor-attributes.html#GUID-400B741C-E4AA-4155-8279-09FD80A6B38F__CACFEFEB">OCI_ATTR_CONN_TIMEOUT</a></p>
                                 </li>
                                 <li>
                                    <p><a href="connect-authorize-and-initialize-functions.html#GUID-B6291228-DA2F-4CE9-870A-F94243141757" title="为OCI操作创建数据源的访问路径。">OCIServerAttach（）</a></p>
                                 </li>
                                 <li>
                                    <p><a href="connect-authorize-and-initialize-functions.html#GUID-425D4B32-257C-480E-B69C-7112BE9482E6" title="获取一个会话。">OCILogon2（）</a></p>
                                 </li>
                              </ul>
                           </div>
                        </div>
                        <!-- class="section" -->
                     </div>
                  </div><a id="LNOCI16611"></a><div class="props_rev_3"><a id="GUID-1DB08E60-053F-4D7B-A56D-FE42FE9463B5" name="GUID-1DB08E60-053F-4D7B-A56D-FE42FE9463B5"></a><h5 id="LNOCI-GUID-1DB08E60-053F-4D7B-A56D-FE42FE9463B5" class="sect5"><span class="enumeration_section">11.4.2.3</span>登录数据库</h5>
                     <div>
                        <p>应用程序可以使用多个接口之一。</p>
                        <div class="section">
                           <p>应用程序必须使用以下某个接口登录每个线程的数据库。</p>
                        </div>
                        <!-- class="section" -->
                        <div class="section">
                           <ul style="list-style-type:disc">
                              <li>
                                 <p><code class="codeph">OCILogon2（）</code></p>
                                 <p>这是最简单的界面。当您需要简单的连接池连接并且不需要更改会话句柄的任何属性时，请使用此接口。此接口还可用于建立与数据库的代理连接。</p>
                                 <p>以下是使用<code class="codeph">OCILogon2()</code>的示例：</p><pre class="oac_no_warn" dir="ltr">for（i = 0; i &lt;MAXTHREADS; ++ i）{OCILogon2（envhp，errhp，＆svchp [i]，“hr”，2，“hr”，2，poolName，poolNameLen，OCI_LOGON2_CPOOL））; }</pre><p>要使用此接口获取代理连接，请将password参数设置为<code class="codeph">NULL</code> 。</p>
                              </li>
                              <li>
                                 <p><code class="codeph">OCISessionGet（）</code></p>
                                 <p>这是推荐的界面。它为用户提供了使用外部身份验证方法的附加选项，例如证书，可分辨名称等。<code class="codeph">OCISessionGet()</code>是建议的统一函数调用来检索会话。
                                 </p>
                                 <p>以下是使用<code class="codeph">OCISessionGet()</code>的示例：</p><pre class="oac_no_warn" dir="ltr">for（i = 0; i &lt;MAXTHREADS; ++ i）{OCISessionGet（envhp，errhp，＆svchp，authp，（OraText *）poolName，strlen（poolName），NULL，0，NULL，NULL，NULL，OCI_SESSGET_CPOOL）}</pre></li>
                              <li>
                                 <p><code class="codeph">OCIServerAttach()</code>和<code class="codeph">OCISessionBegin()</code></p>
                                 <p>如果应用程序必须在用户会话句柄和服务器句柄上设置任何特殊属性，则可以使用其他接口。对于这样的要求，应用程序必须分配所有句柄（连接池句柄，服务器句柄，会话句柄和服务上下文句柄）。你会按照这个顺序：</p>
                                 <ol>
                                    <li>
                                       <p>创建连接池。</p>
                                       <p>连接池通过物理连接透明地复用虚拟服务器句柄，从而无需用户这样做。用户感觉到会话具有专用（虚拟）连接。由于多路复用对用户透明地完成，因此用户不得尝试通过虚拟服务器句柄本身多路复用会话。会话迁移和会话切换的概念（需要在用户级别进行显式多路复用）对于连接池是不存在的，不应使用。</p>
                                    </li>
                                    <li>
                                       <p>调用<code class="codeph">OCIServerAttach()</code>时将模式设置为<code class="codeph">OCI_CPOOL</code> 。</p>
                                       <p>在OCI程序中，用户应创建（模式设置为<code class="codeph">OCI_CPOOL</code> <code class="codeph">OCIServerAttach()</code> ），这是使用连接池创建的每个会话的唯一虚拟服务器句柄。虚拟服务器句柄和会话之间应该存在一对一的映射。
                                       </p>
                                    </li>
                                    <li>
                                       <p>在模式设置为<code class="codeph">OCI_DEFAULT</code>下调用<code class="codeph">OCISessionBegin()</code> 。</p>
                                       <p>可以使用<code class="codeph">OCISessionBegin()</code>将凭据设置为<code class="codeph">OCI_CRED_RDBMS</code> ， <code class="codeph">OCI_CRED_EXT</code>或<code class="codeph">OCI_CRED_PROXY</code> 。如果凭据设置为<code class="codeph">OCI_CRED_EXT</code> ，则不需要在会话句柄上设置用户名和密码。如果凭据设置为<code class="codeph">OCI_CRED_PROXY</code> ，则只能在会话句柄上设置用户名。 （不必创建显式主会话， <code class="codeph">OCI_ATTR_MIGSESSION</code>需要设置<code class="codeph">OCI_ATTR_MIGSESSION</code> ）。
                                       </p>
                                       <p>当虚拟服务器句柄指向连接池（ <code class="codeph">OCIServerAttach()</code>调用<code class="codeph">mode</code>设置为<code class="codeph">OCI_CPOOL</code> ），用户不应在对<code class="codeph">OCISessionBegin()</code>的调用中设置<code class="codeph">OCI_MIGRATE</code>标志。Oracle仅支持出于兼容性原因而支持传递<code class="codeph">OCI_MIGRATE</code>标志。不要使用<code class="codeph">OCI_MIGRATE</code>标志，因为用户在使用连接池时获得的感知是具有其自己的专用（虚拟）连接的会话，这些连接被透明地复用到真实连接上。
                                       </p>
                                    </li>
                                 </ol>
                              </li>
                           </ul>
                           <div class="infoboxnotealso" id="GUID-1DB08E60-053F-4D7B-A56D-FE42FE9463B5__GUID-45CD8766-90C4-48CD-96DB-11F5C568887E">
                              <p class="notep1">也可以看看：</p>
                              <ul style="list-style-type:disc">
                                 <li>
                                    <p><a href="connect-authorize-and-initialize-functions.html#GUID-425D4B32-257C-480E-B69C-7112BE9482E6" title="获取一个会话。">OCILogon2（）</a></p>
                                 </li>
                                 <li>
                                    <p><a href="connect-authorize-and-initialize-functions.html#GUID-890DFBC4-718B-4339-A0EA-6226A25B8241" title="获取一个会话。">OCISessionGet（）</a></p>
                                 </li>
                                 <li>
                                    <p><a href="connect-authorize-and-initialize-functions.html#GUID-B6291228-DA2F-4CE9-870A-F94243141757" title="为OCI操作创建数据源的访问路径。">OCIServerAttach（）</a></p>
                                 </li>
                                 <li>
                                    <p><a href="connect-authorize-and-initialize-functions.html#GUID-31B1FDB3-056E-4AF9-9B89-8DA6AA156947" title="创建用户会话并开始给定服务器的用户会话。">OCISessionBegin（）</a></p>
                                 </li>
                              </ul>
                           </div>
                        </div>
                        <!-- class="section" -->
                     </div>
                  </div><a id="LNOCI16612"></a><div class="props_rev_3"><a id="GUID-497689F0-20A0-4CEF-91DC-594DBACED921" name="GUID-497689F0-20A0-4CEF-91DC-594DBACED921"></a><h5 id="LNOCI-GUID-497689F0-20A0-4CEF-91DC-594DBACED921" class="sect5"><span class="enumeration_section">11.4.2.4</span>处理连接<span class="enumeration_section">池中的</span> SGA限制</h5>
                     <div>
                        <p>使用<code class="codeph">OCI_CPOOL</code>模式（连接池），后端数据库中的会话内存（UGA）来自SGA。</p>
                        <p>如果您的应用程序消耗的会话内存多于SGA可容纳的会话内存，则可能需要对后端数据库进行一些SGA调整以获得更大的SGA。后端数据库的内存调整要求类似于在共享服务器后端配置LARGE POOL，但实例仍处于专用模式。</p>
                        <p>如果您仍然遇到SGA限制，则必须考虑：</p>
                        <ul style="list-style-type:disc">
                           <li>
                              <p>通过减少每个会话的开放语句来减少会话内存消耗</p>
                           </li>
                           <li>
                              <p>通过在中间层上汇集会话来减少后端中的会话数</p>
                           </li>
                           <li>
                              <p>否则，关闭连接池</p>
                           </li>
                        </ul>
                        <p>应用程序必须避免在后端使用专用数据库链接和连接池。</p>
                        <p>如果后端是专用服务器，则无法进行有效的连接池，因为使用专用数据库链接的会话与物理连接相关联，导致其他会话无法使用相同的连接。如果您的应用程序使用专用数据库链接，并且您没有看到会话之间有效共享后端进程，则必须考虑使用共享数据库链接。</p>
                        <div class="infoboxnotealso" id="GUID-497689F0-20A0-4CEF-91DC-594DBACED921__GUID-914FE48C-1B62-4CFB-B15B-BDC83FB1761A">
                           <p class="notep1">也可以看看：</p>
                           <ul style="list-style-type:disc">
                              <li>
                                 <p><a href="../tgdba/tuning-shared-pool-and-large-pool.html#TGDBA558" target="_blank"><span><cite>“Oracle数据库性能调整指南”</cite></span></a> ，有关配置共享服务器的部分</p>
                              </li>
                              <li>
                                 <p><a href="../admin/distributed-database-concepts.html#ADMIN12083" target="_blank"><span><cite>“Oracle数据库管理员指南”</cite></span></a> ，有关共享数据库链接的部分，以获取有关分布式数据库的更多信</p>
                              </li>
                           </ul>
                        </div>
                     </div>
                  </div><a id="LNOCI16613"></a><div class="props_rev_3"><a id="GUID-73DFAAA9-4EB2-44ED-9DEC-2B803B990AE2" name="GUID-73DFAAA9-4EB2-44ED-9DEC-2B803B990AE2"></a><h5 id="LNOCI-GUID-73DFAAA9-4EB2-44ED-9DEC-2B803B990AE2" class="sect5"><span class="enumeration_section">11.4.2.5</span>从数据库注销</h5>
                     <div>
                        <p>选择适当的调用以在连接池模式下从数据库注销。</p>
                        <p>从以下调用中，选择与登录调用对应的调用，并使用它在连接池模式下从数据库注销。</p>
                        <ul style="list-style-type:disc">
                           <li>
                              <p><code class="codeph">OCILogoff()</code> ：</p>
                              <p>如果使用<code class="codeph">OCILogon2()</code>进行连接， <code class="codeph">OCILogoff()</code>必须使用<code class="codeph">OCILogoff()</code>注销。
                              </p>
                           </li>
                           <li>
                              <p><code class="codeph">OCISessionRelease（）</code></p>
                              <p>如果调用OCISessionGet（）来建立连接，则必须调用<code class="codeph">OCISessionRelease()</code>才能注销。
                              </p>
                           </li>
                           <li>
                              <p><code class="codeph">OCISessionEnd()</code>和<code class="codeph">OCIServerDetach()</code></p>
                              <p>如果<code class="codeph">OCIServerAttach()</code>和<code class="codeph">OCISessionBegin()</code>来建立连接并启动会话，则必须调用<code class="codeph">OCISessionEnd()</code>来结束会话，并且必须调用<code class="codeph">OCIServerDetach()</code>来释放连接。
                              </p>
                           </li>
                        </ul>
                        <div class="infoboxnotealso" id="GUID-73DFAAA9-4EB2-44ED-9DEC-2B803B990AE2__GUID-F9190CE5-BE4A-420B-A4C9-ABC5488B1E0D">
                           <p class="notep1">也可以看看：</p>
                           <ul style="list-style-type:disc">
                              <li>
                                 <p><a href="connect-authorize-and-initialize-functions.html#GUID-567DA731-ABC9-4348-B29C-7B2C6C1D7C36" title="释放使用OCILogon2（）或OCILogon（）检索的会话。">OCILogoff（）</a></p>
                              </li>
                              <li>
                                 <p><a href="connect-authorize-and-initialize-functions.html#GUID-425D4B32-257C-480E-B69C-7112BE9482E6" title="获取一个会话。">OCILogon2（）</a></p>
                              </li>
                              <li>
                                 <p><a href="connect-authorize-and-initialize-functions.html#GUID-DAAECC99-A432-48B5-AC33-0868C2FE762D" title="释放使用OCISessionGet（）检索的会话。">OCISessionRelease（）</a></p>
                              </li>
                              <li>
                                 <p><a href="connect-authorize-and-initialize-functions.html#GUID-2AE88BDC-2C44-4958-B26A-434B0407F06F" title="终止由OCISessionBegin（）创建的用户会话上下文。">OCISessionEnd（）</a></p>
                              </li>
                              <li>
                                 <p><a href="connect-authorize-and-initialize-functions.html#GUID-402B540A-05FF-464B-B9C8-B2E7B4ABD564" title="删除OCI操作的数据源访问路径。">OCIServerDetach（）</a></p>
                              </li>
                              <li>
                                 <p><a href="connect-authorize-and-initialize-functions.html#GUID-B6291228-DA2F-4CE9-870A-F94243141757" title="为OCI操作创建数据源的访问路径。">OCIServerAttach（）</a></p>
                              </li>
                              <li>
                                 <p><a href="connect-authorize-and-initialize-functions.html#GUID-31B1FDB3-056E-4AF9-9B89-8DA6AA156947" title="创建用户会话并开始给定服务器的用户会话。">OCISessionBegin（）</a></p>
                              </li>
                           </ul>
                        </div>
                     </div>
                  </div><a id="LNOCI16614"></a><div class="props_rev_3"><a id="GUID-CB0DC00D-C935-41BC-AF4B-29C3288B743B" name="GUID-CB0DC00D-C935-41BC-AF4B-29C3288B743B"></a><h5 id="LNOCI-GUID-CB0DC00D-C935-41BC-AF4B-29C3288B743B" class="sect5"><span class="enumeration_section">11.4.2.6</span>销毁连接池</h5>
                     <div>
                        <p><code class="codeph">OCIConnectionPoolDestroy()</code>会破坏它。
                        </p>
                        <p>使用<code class="codeph">OCIConnectionPoolDestroy()</code>来销毁连接池。
                        </p>
                        <div class="infoboxnotealso" id="GUID-CB0DC00D-C935-41BC-AF4B-29C3288B743B__GUID-7C1B4CEB-BC12-4EEE-BB78-52F94ED6B44A">
                           <p class="notep1">也可以看看：</p>
                           <p><a href="connect-authorize-and-initialize-functions.html#GUID-46720C8F-0A9F-4300-B6C4-4E47875A95C2" title="销毁连接池。">OCIConnectionPoolDestroy（）</a></p>
                        </div>
                     </div>
                  </div><a id="LNOCI16615"></a><div class="props_rev_3"><a id="GUID-676CFBC3-69CC-447B-B0A5-B58BE827291E" name="GUID-676CFBC3-69CC-447B-B0A5-B58BE827291E"></a><h5 id="LNOCI-GUID-676CFBC3-69CC-447B-B0A5-B58BE827291E" class="sect5"><span class="enumeration_section">11.4.2.7</span>释放池把手</h5>
                     <div>
                        <p>使用<code class="codeph">OCIHandleFree()</code>释放池句柄。
                        </p>
                        <p>最后三个动作在此代码片段中说明：</p><pre class="oac_no_warn" dir="ltr">for（i = 0; i &lt;MAXTHREADS; ++ i）{checkerr（errhp，OCILogoff（（void *）svchp [i]，errhp））; } checkerr（errhp，OCIConnectionPoolDestroy（poolhp，errhp，OCI_DEFAULT））; checkerr（errhp，OCIHandleFree（（void *）poolhp，OCI_HTYPE_CPOOL））;</pre><div class="infoboxnotealso" id="GUID-676CFBC3-69CC-447B-B0A5-B58BE827291E__GUID-1B38A80D-B03C-4570-B418-705A28CBB173">
                           <p class="notep1">也可以看看：</p>
                           <ul style="list-style-type:disc">
                              <li>
                                 <p><a href="handle-and-descriptor-functions.html#GUID-E87E9F91-D3DC-4F35-BE7C-F1EFBFEEBA0A" title="显式释放句柄">OCIHandleFree（）</a></p>
                              </li>
                              <li>
                                 <p><a href="handle-and-descriptor-attributes.html#GUID-400B741C-E4AA-4155-8279-09FD80A6B38F" title="列出并描述连接池句柄属性。">连接池句柄属性</a></p>
                              </li>
                              <li>
                                 <p><a href="connect-authorize-and-initialize-functions.html#GUID-7E5A69F2-0268-4655-845D-A7662902FAA2" title="初始化连接池。">OCIConnectionPoolCreate（）</a> ， <a href="connect-authorize-and-initialize-functions.html#GUID-425D4B32-257C-480E-B69C-7112BE9482E6" title="获取一个会话。">OCILogon2（）</a>和<a href="connect-authorize-and-initialize-functions.html#GUID-46720C8F-0A9F-4300-B6C4-4E47875A95C2" title="销毁连接池。">OCIConnectionPoolDestroy（）</a></p>
                              </li>
                           </ul>
                        </div>
                     </div>
                  </div>
               </div><a id="LNOCI16616"></a><div class="props_rev_3"><a id="GUID-AE06BCB1-7333-458E-90F0-0761496EC5E1" name="GUID-AE06BCB1-7333-458E-90F0-0761496EC5E1"></a><h4 id="LNOCI-GUID-AE06BCB1-7333-458E-90F0-0761496EC5E1" class="sect4"><span class="enumeration_section">11.4.3</span> OCI连接池示例</h4>
                  <div>
                     <p>哪里可以找到经过测试的完整程序中的连接池示例。</p>
                     <p>可以在目录<code class="codeph">demo</code>中的<code class="codeph">cdemocp.c and cdemocpproxy.c</code>中找到已测试的完整程序中的连接池<code class="codeph">demo</code> 。
                     </p>
                  </div>
               </div>
            </div><a id="LNOCI16652"></a><div class="props_rev_3"><a id="GUID-8DD97D4D-C7AA-4EF7-9B55-8DC58BDC2726" name="GUID-8DD97D4D-C7AA-4EF7-9B55-8DC58BDC2726"></a><h3 id="LNOCI-GUID-8DD97D4D-C7AA-4EF7-9B55-8DC58BDC2726" class="sect3"><span class="enumeration_section">11.5</span>何时使用连接池，会话池或两者都不使用</h3>
               <div>
                  <p>表示使用它们的环境。</p>
                  <p>如果中间层线程无法重用数据库会话（即，它们是有状态的），并且后端服务器进程的数量可能导致数据库出现扩展问题，请使用OCI连接池。</p>
                  <p>如果数据库会话可由中间层线程重用（即，它们是无状态的），并且后端服务器进程的数量可能导致数据库上的扩展问题，请使用OCI会话池。</p>
                  <p>如果中间层线程无法重用数据库会话（即，它们是有状态的），并且后端服务器进程的数量永远不会大到可能导致数据库上的任何扩展问题，则无需使用任何池机制。</p>
                  <div class="infoboxnote" id="GUID-8DD97D4D-C7AA-4EF7-9B55-8DC58BDC2726__GUID-D3E22093-F8E4-4683-B214-360F978C66BD">
                     <p class="notep1">注意：</p>
                     <p>使用非池化会话或连接会导致每个中间层用户请求拆除并重新创建数据库会话/连接。这可能会导致数据库端出现严重的扩展问题，并导致执行请求的延迟时间过长。因此，Oracle强烈建议您根据数据库会话是有状态还是无状态来采用中间层应用程序的池策略之一。</p>
                  </div>
                  <p>在连接池中，池元素是连接，在会话池中，池元素是会话。</p>
                  <p>与任何池一样，池化资源被应用程序线程锁定一段时间，直到线程在数据库上完成其作业并释放资源为止。在其使用期间，该资源对其他线程不可用。因此，应用程序开发人员必须意识到任何类型的池都可以在相对较短的任务中有效地工作。但是，如果应用程序正在执行长时间运行的事务，它可能会长时间拒绝其他共享者的池化资源，从而导致饥饿。因此，池应该与短任务一起使用，并且池的大小应该足够大以维持所需的事务并发性。</p>
                  <p>请注意有关连接池和会话池的以下附加信息：</p>
                  <ul style="list-style-type:disc">
                     <li>
                        <p>OCI连接池</p>
                        <p>汇集了与数据库的连接。会话由用户创建和销毁。每次调用数据库都会从池中获取适当的可用连接。</p>
                        <p>该应用程序通过与数据库的较少物理连接来复用多个会话。用户可以调整池配置以实现所需的并发性。</p>
                        <p>应用程序会话的生命周期与缓存的池化连接的生命周期无关。</p>
                     </li>
                     <li>
                        <p>OCI会话池</p>
                        <p>OCI汇集了会话和连接。应用程序从池中获取会话并将会话释放回池中。</p>
                     </li>
                  </ul>
                  <div class="p">本节包括以下主题：<ul style="list-style-type:disc">
                        <li>
                           <p><a href="session-and-connection-pooling.html#GUID-A408F97E-C451-4D8C-BA8C-4F48DDA0EF26" title="有许多方法可以创建具有不同功能的会话。">会话创建功能</a></p>
                        </li>
                        <li>
                           <p><a href="session-and-connection-pooling.html#GUID-D952EB18-A7DE-4CF6-816D-E5E728AACE5E" title="如何选择要使用的类型od会话。">关于在不同类型的OCI会话之间进行选择</a></p>
                        </li>
                     </ul>
                  </div>
               </div><a id="LNOCI16653"></a><div class="props_rev_3"><a id="GUID-A408F97E-C451-4D8C-BA8C-4F48DDA0EF26" name="GUID-A408F97E-C451-4D8C-BA8C-4F48DDA0EF26"></a><h4 id="LNOCI-GUID-A408F97E-C451-4D8C-BA8C-4F48DDA0EF26" class="sect4"><span class="enumeration_section">11.5.1</span>会话创建功能</h4>
                  <div>
                     <p>有许多方法可以创建具有不同功能的会话。</p>
                     <p>OCI为会话创建提供以下功能：</p>
                     <ul style="list-style-type:disc">
                        <li>
                           <p><code class="codeph">OCILogin</code></p>
                           <p>OCILogon（）是获取OCI会话的最简单方法。优点是易于获得OCI服务上下文。缺点是您无法执行任何高级OCI操作，例如会话迁移，代理身份验证或使用连接池或会话池。</p>
                        </li>
                        <li>
                           <p><code class="codeph">OCILogon2（）</code></p>
                           <p>OCILogon2（）包括的功能<code class="codeph">OCILogon()</code>得到一个会话。此会话可以是具有新基础连接的新会话，也可以是通过现有连接池的虚拟连接启动的会话，也可以是现有会话池中的启动。调用函数的<code class="codeph">mode</code>参数值决定了它的行为。
                           </p>
                           <p>用户无法修改OCI返回的服务上下文的属性（ <code class="codeph">OCI_ATTR_</code> <code class="codeph">STMTCACHESIZE</code>除外）。</p>
                        </li>
                        <li>
                           <p><code class="codeph">OCISessionBegin（）</code></p>
                           <p>OCISessionBegin（）支持OCI会话的所有各种选项，例如代理身份验证，从连接池或会话池获取会话，外部凭据和可迁移会话。这是最低级别的调用，必须显式分配所有句柄并设置所有属性。必须在此调用之前调用<code class="codeph">OCIServerAttach()</code> 。
                           </p>
                        </li>
                        <li>
                           <p><code class="codeph">OCISessionGet（）</code></p>
                           <p>OCISessionGet（）现在是获取会话的推荐方法。此会话可以是具有新基础连接的新会话，也可以是通过现有连接池的虚拟连接启动的会话，也可以是现有会话池中的启动。调用函数的<code class="codeph">mode</code>参数值决定了它的行为。这类似于<code class="codeph">OCILogon2()</code>但您还可以指定用于从池中获取特定会话的标记。
                           </p>
                        </li>
                     </ul>
                     <div class="infoboxnotealso" id="GUID-A408F97E-C451-4D8C-BA8C-4F48DDA0EF26__GUID-C1757A87-6308-46A3-9658-BB5578DE80C4">
                        <p class="notep1">也可以看看：</p>
                        <ul style="list-style-type:disc">
                           <li>
                              <p><a href="connect-authorize-and-initialize-functions.html#GUID-F4592576-BE9D-4583-83AD-5D56D2E592E6" title="创建一个简单的登录会话。">OCILogon（）</a></p>
                           </li>
                           <li>
                              <p><a href="oci-programming-basics.html#GUID-A4B693E9-7554-4721-A7F7-0B5B15589DEE" title="应用程序必须调用OCIEnvNlsCreate（）来初始化OCI环境句柄。现有应用程序可能使用了OCIEnvCreate（）。">应用程序初始化，连接和会话创建</a></p>
                           </li>
                           <li>
                              <p><a href="connect-authorize-and-initialize-functions.html#GUID-425D4B32-257C-480E-B69C-7112BE9482E6" title="获取一个会话。">OCILogon2（）</a></p>
                           </li>
                           <li>
                              <p><a href="connect-authorize-and-initialize-functions.html#GUID-31B1FDB3-056E-4AF9-9B89-8DA6AA156947" title="创建用户会话并开始给定服务器的用户会话。">OCISessionBegin（）</a></p>
                           </li>
                           <li>
                              <p><a href="connect-authorize-and-initialize-functions.html#GUID-890DFBC4-718B-4339-A0EA-6226A25B8241" title="获取一个会话。">OCISessionGet（）</a></p>
                           </li>
                        </ul>
                     </div>
                  </div>
               </div><a id="LNOCI16654"></a><div class="props_rev_3"><a id="GUID-D952EB18-A7DE-4CF6-816D-E5E728AACE5E" name="GUID-D952EB18-A7DE-4CF6-816D-E5E728AACE5E"></a><h4 id="LNOCI-GUID-D952EB18-A7DE-4CF6-816D-E5E728AACE5E" class="sect4"><span class="enumeration_section">11.5.2</span>关于在不同类型的OCI会话之间进行选择</h4>
                  <div>
                     <p>如何选择要使用的类型od会话。</p>
                     <p>OCI包括以下类型的会话：</p>
                     <ul style="list-style-type:disc">
                        <li>
                           <p>基本的OCI会议</p>
                           <p>基本OCI会话通过在专用OCI服务器句柄上使用用户名和密码来工作。这是无池机制。有关何时使用它的信息，请参见何时使用连接池，会话池或两者。</p>
                           <p>如果通过外部凭据获取身份验证，则不需要用户名或密码。</p>
                        </li>
                        <li>
                           <p>会话池会话</p>
                           <p>会话池会话来自会话池缓存。某些会话可能会被标记。这些是无国籍会议。每个<code class="codeph">OCISessionGet()</code>和<code class="codeph">OCISessionRelease()</code>调用都从会话缓存中获取并释放会话。这样可以避免服务器创建和销毁会话。
                           </p>
                           <p>请参见何时使用连接池，会话池或连接池会话与会话池会话与非池会话之间的连接池和会话池。</p>
                        </li>
                        <li>
                           <p>连接池会话</p>
                           <p>使用来自OCI连接池的<code class="codeph">OCISessionGet()</code>和<code class="codeph">OCISessionBegin()</code>调用创建连接池会话。没有会话缓存，因为这些是有状态会话。每次调用都会创建一个新会话，用户负责终止这些会话。
                           </p>
                           <p>会话可在连接池的服务器句柄之间自动迁移。每个会话可以具有用户名和密码，也可以是代理会话。请参见何时使用连接池，会话池或连接池会话与会话池会话与非池会话之间的连接池和会话池。</p>
                        </li>
                        <li>
                           <p>会话共享服务器句柄</p>
                           <p>您可以通过几个物理连接复用多个OCI会话。应用程序通过为这些多个会话提供相同的服务器句柄来手动执行此操作。最好通过使用OCI连接池API将会话多路复用细节留给OCI。</p>
                        </li>
                        <li>
                           <p>代理会话</p>
                           <p>如果必须保护客户端的密码不受中间层的影响，则代理会话非常有用。代理会话也可以是OCI连接池或OCI会话池的一部分。</p>
                        </li>
                        <li>
                           <p>可迁移的会议</p>
                        </li>
                     </ul>
                     <p>由于事务句柄是可迁移的，因此应用程序不需要使用可迁移会话，而是使用OCI连接池。</p>
                     <div class="infoboxnotealso" id="GUID-D952EB18-A7DE-4CF6-816D-E5E728AACE5E__GUID-76245F52-3F50-4D26-B3EF-6EC042C1CE38">
                        <p class="notep1">也可以看看：</p>
                        <ul style="list-style-type:disc">
                           <li>
                              <p><a href="connect-authorize-and-initialize-functions.html#GUID-890DFBC4-718B-4339-A0EA-6226A25B8241" title="获取一个会话。">OCISessionGet（）</a></p>
                           </li>
                           <li>
                              <p><a href="connect-authorize-and-initialize-functions.html#GUID-DAAECC99-A432-48B5-AC33-0868C2FE762D" title="释放使用OCISessionGet（）检索的会话。">OCISessionRelease（）</a></p>
                           </li>
                           <li>
                              <p><a href="connect-authorize-and-initialize-functions.html#GUID-31B1FDB3-056E-4AF9-9B89-8DA6AA156947" title="创建用户会话并开始给定服务器的用户会话。">OCISessionBegin（）</a></p>
                           </li>
                           <li>
                              <p>有关代理会话的更多信息，请参阅<a href="managing-scalable-platforms.html#GUID-A5830D58-3079-45DD-BE3A-81C41991DA70" title="中间层应用程序接收来自浏览器客户端的请求。">OCI中的中间层应用程序</a></p>
                           </li>
                           <li>
                              <p><a href="managing-scalable-platforms.html#GUID-69A0AE8C-3F8D-4EDD-A817-730F17B3DF3E" title="通过在几个服务器连接上复用用户会话来主动平衡用户负载的事务服务器必须将这些连接组合到服务器组中。">OCI会话管理</a></p>
                           </li>
                        </ul>
                     </div>
                  </div>
               </div>
            </div>
         </div>
      </article>
   </body>
</html>