<html lang="en-us" dir="ltr" xml:lang="en-us">
   <head>
      <meta http-equiv="Content-Type" content="text/html; charset=utf-8"></meta>
      <meta name="viewport" content="width=device-width, initial-scale=1"></meta>
      <meta http-equiv="X-UA-Compatible" content="IE=edge"></meta>
      <meta name="abstract" content="A join group is a user-created dictionary object that lists one or more columns that can be meaningfully joined."></meta>
      <meta name="description" content="A join group is a user-created dictionary object that lists one or more columns that can be meaningfully joined."></meta>
      <title>使用连接组优化连接</title>
      <meta property="og:site_name" content="Oracle Help Center"></meta>
      <meta property="og:title" content="Database In-Memory Guide"></meta>
      <meta property="og:description" content="A join group is a user-created dictionary object that lists one or more columns that can be meaningfully joined."></meta>
      <link rel="stylesheet" href="/sp_common/book-template/ohc-book-template/css/book.css"></link>
      <link rel="shortcut icon" href="/sp_common/book-template/ohc-common/img/favicon.ico"></link>
      <meta name="application-name" content="Database In-Memory Guide"></meta>
      <meta name="generator" content="DITA Open Toolkit version 1.8.5 (Mode = doc)"></meta>
      <meta name="plugin" content="SP_docbuilder HTML plugin release 18.2.2"></meta>
      <link rel="alternate" href="database-memory-guide.pdf" title="PDF File" type="application/pdf"></link>
      <meta name="robots" content="all"></meta>
      <link rel="schema.dcterms" href="http://purl.org/dc/terms/"></link>
      <meta name="dcterms.created" content="2019-04-22T09:02:38-07:00"></meta>
      <meta name="dcterms.title" content="Database In-Memory Guide"></meta>
      <meta name="dcterms.dateCopyrighted" content="2016, 2019"></meta>
      <meta name="dcterms.category" content="database"></meta>
      <meta name="dcterms.identifier" content="E96137-02"></meta>
      
      <meta name="dcterms.product" content="en/database/oracle/oracle-database/19"></meta>
      
      <link rel="prev" href="optimizing-in-memory-expressions.html" title="Previous" type="text/html"></link>
      <link rel="next" href="optimizing-in-memory-aggregation.html" title="Next" type="text/html"></link>
      <script>
        document.write('<style type="text/css">');
        document.write('body > .noscript, body > .noscript ~ * { visibility: hidden; }');
        document.write('</style>');
     </script>
      <script src="/sp_common/book-template/requirejs/require.js" data-main="/sp_common/book-template/ohc-book-template/js/book-config"></script>
      <script>
            if (window.require === undefined) {
                document.write('<script data-main="sp_common/book-template/ohc-book-template/js/book-config" src="sp_common/book-template/requirejs/require.js"><\/script>');
                document.write('<link href="sp_common/book-template/ohc-book-template/css/book.css" rel="stylesheet"/>');
            }
        </script>
      <script type="application/json" id="ssot-metadata">{"primary":{"category":{"short_name":"database","element_name":"Database","display_in_url":true},"suite":{"short_name":"oracle","element_name":"Oracle","display_in_url":true},"product_group":{"short_name":"not-applicable","element_name":"Not applicable","display_in_url":false},"product":{"short_name":"oracle-database","element_name":"Oracle Database","display_in_url":true},"release":{"short_name":"19","element_name":"Release 19","display_in_url":true}}}</script>
      
    <meta name="dcterms.isVersionOf" content="INMEM"></meta>
    <meta name="dcterms.release" content="Release 19"></meta>
  </head>
   <body dir="ltr">
      <div class="noscript alert alert-danger text-center" role="alert">
         <a href="optimizing-in-memory-expressions.html" class="pull-left"><span class="glyphicon glyphicon-chevron-left" aria-hidden="true"></span>上一页</a> <a href="optimizing-in-memory-aggregation.html" class="pull-right">下一页<span class="glyphicon glyphicon-chevron-right" aria-hidden="true"></span></a> <span class="fa fa-exclamation-triangle" aria-hidden="true"></span>必须启用JavaScript才能正确显示此内容</div>
      <article>
         <header>
            <ol class="breadcrumb" vocab="http://schema.org/" typeof="BreadcrumbList">
               <li property="itemListElement" typeof="ListItem"><a href="index.html" property="item" typeof="WebPage"><span property="name">数据库内存指南</span></a></li>
               <li property="itemListElement" typeof="ListItem"><a href="advanced-optimizations-for-in-memory-queries.html" property="item" typeof="WebPage"><span property="name">优化内存中查询</span></a></li>
               <li class="active" property="itemListElement" typeof="ListItem">使用连接组优化连接</li>
            </ol>
            <a id="GUID-3E5491C4-B345-4A8E-8B1B-8DC150C8A797" name="GUID-3E5491C4-B345-4A8E-8B1B-8DC150C8A797"></a>
            
            <h2 id="INMEM-GUID-3E5491C4-B345-4A8E-8B1B-8DC150C8A797" class="sect2"><span class="enumeration_chapter">8</span>使用加入组优化联接</h2>
         </header>
         <div class="ind">
            <div>
               <p><strong class="term">连接组</strong>是用户创建的字典对象，它列出了一个或多个可以有意义连接的列。
               </p>
               <p>本章包含以下主题：</p>
            </div>
            <div>
               <ul class="ullinks">
                  <li class="ulchildlink"><a href="optimizing-queries-with-join-groups.html#GUID-5FC74CA4-FD3E-4A17-A40D-9EE4EC61F355">关于内存中的连接</a><br>联接是数据仓库工作负载不可或缺的一部分。当正在连接的表存储在内存中时，IM列存储增强了连接的性能。
                  </li>
                  <li class="ulchildlink"><a href="optimizing-queries-with-join-groups.html#GUID-DC6B8DF7-C959-443F-B7D9-06ECA84BCD55">关于加入群组</a><br>启用IM列存储后，数据库可以使用连接组来优化IM列存储中填充的表的连接。
                  </li>
                  <li class="ulchildlink"><a href="optimizing-queries-with-join-groups.html#GUID-5322DCBB-EC1A-435F-A552-C71A8879DE5B">加入群组的目的</a><br>在某些查询中，连接组消除了解压缩和散列列值的性能开销。
                  </li>
                  <li class="ulchildlink"><a href="optimizing-queries-with-join-groups.html#GUID-7972FD49-0418-4196-9069-A4F44D16A9F1">加入群组的工作原理</a><br>在连接组中，数据库使用相同的公共字典压缩连接组中的所有列。
                  </li>
                  <li class="ulchildlink"><a href="optimizing-queries-with-join-groups.html#GUID-B09C155D-FE48-408F-AD69-5EAD85372E64">散列连接使用常用字典编码时</a><br>加入连接组中的列通常会看到性能优势。
                  </li>
                  <li class="ulchildlink"><a href="optimizing-queries-with-join-groups.html#GUID-67D6F161-BEAD-495F-94C1-86D47B8A8E74">创建加入组</a><br>使用<code class="codeph">CREATE INMEMORY JOIN GROUP</code>语句定义连接组。
                  </li>
                  <li class="ulchildlink"><a href="optimizing-queries-with-join-groups.html#GUID-5E6B9757-ADA2-408D-8FA4-274D36AE22E1">监控加入组使用情况</a><br>要确定查询是否使用连接组，可以使用图形SQL监视器报告（推荐）或使用<code class="codeph">DBMS_SQLTUNE.REPORT_SQL_MONITOR_XML</code>函数的SQL查询。
                  </li>
               </ul>
               <div class="familylinks">
                  <div class="parentlink">
                     <p><strong>父主题：</strong> <a href="advanced-optimizations-for-in-memory-queries.html#GUID-33034151-7BD7-4186-B336-C693FBB27634" title="本部分介绍如何使用内存表达式，连接组和内存中聚合来优化查询。它还解释了IM列存储如何重新填充已修改的数据。">优化内存中查询</a></p>
                  </div>
               </div>
            </div>
            
            <div class="props_rev_3"><a id="GUID-5FC74CA4-FD3E-4A17-A40D-9EE4EC61F355" name="GUID-5FC74CA4-FD3E-4A17-A40D-9EE4EC61F355"></a><h3 id="INMEM-GUID-5FC74CA4-FD3E-4A17-A40D-9EE4EC61F355" class="sect3"><span class="enumeration_section">8.1</span>关于内存中连接</h3>
               <div>
                  <p>联接是数据仓库工作负载不可或缺的一部分。当正在连接的表存储在内存中时，IM列存储增强了连接的性能。</p>
                  <p>由于更快的扫描和连接处理，使用Bloom过滤器的复杂多表连接和简单连接可从IM列存储中受益。在数据仓库环境中，最常用的连接涉及事实表和一个或多个维度表。</p>
                  <p>在IM列存储中填充表时，以下联接运行得更快：</p>
                  <ul style="list-style-type:disc">
                     <li>
                        <p>适合使用Bloom过滤器的连接</p>
                     </li>
                     <li>
                        <p>使用一个事实表连接多个小维度表</p>
                     </li>
                     <li>
                        <p>两个具有主键 - 外键关系的表之间的连接</p>
                     </li>
                  </ul>
               </div>
               <div>
                  <div class="familylinks">
                     <div class="parentlink">
                        <p><strong>父主题：</strong> <a href="optimizing-queries-with-join-groups.html#GUID-3E5491C4-B345-4A8E-8B1B-8DC150C8A797" title="连接组是用户创建的字典对象，它列出了一个或多个可以有意义连接的列。">使用连接组优化连接</a></p>
                     </div>
                  </div>
               </div>
               
            </div>
            <div class="sect2"><a id="GUID-DC6B8DF7-C959-443F-B7D9-06ECA84BCD55" name="GUID-DC6B8DF7-C959-443F-B7D9-06ECA84BCD55"></a><h3 id="INMEM-GUID-DC6B8DF7-C959-443F-B7D9-06ECA84BCD55" class="sect3"><span class="enumeration_section">8.2</span>关于加入组</h3>
               <div>
                  <p>启用IM列存储后，数据库可以使用连接组来优化IM列存储中填充的表的连接。</p>
                  <p>连接组是一组列，在这些列上经常连接一组表。列集包含一列或多列，最多255列。表集包括一个或多个内部表。不支持外部表。</p>
                  <p>连接组中的列可以位于相同或不同的表中。例如，如果<code class="codeph">sales</code>和<code class="codeph">times</code>表经常在<code class="codeph">time_id</code>列上加入，那么您可以为<code class="codeph">(times(time_id), sales(time_id))</code>创建一个连接组。如果<code class="codeph">employees</code>表经常在<code class="codeph">employee_id</code>列上加入自身，那么加入组可以是<code class="codeph">(employees(employee_id))</code> 。
                  </p>
                  <div class="infoboxnote" id="GUID-DC6B8DF7-C959-443F-B7D9-06ECA84BCD55__GUID-A998E38C-24D3-4007-A36F-4F8A9E30BF3D">
                     <p class="notep1">注意：</p>
                     <p>同一列不能是多个连接组的成员。</p>
                  </div>
                  <p>创建连接组时，数据库将使连接组中引用的表的当前In-Memory内容无效。随后的<a href="glossary.html#GUID-9168517C-C8A2-4433-946A-037631B840E2"><span class="xrefglossterm">重新填充</span></a>使数据库使用<a href="glossary.html#GUID-D04AB5B8-A58B-4494-A54F-09CEBC113460"><span class="xrefglossterm">公共字典</span></a>重新编码表的IMCU。因此，Oracle建议您首先创建连接组，然后填充表。
                  </p>
                  <p>使用<code class="codeph">CREATE INMEMORY JOIN GROUP</code>语句创建连接组。要向连接组添加列或从连接组中删除列，请使用<code class="codeph">ALTER INMEMORY JOIN GROUP</code>语句。使用<code class="codeph">DROP INMEMORY JOIN GROUP</code>语句删除连接组。
                  </p>
                  <div class="infoboxnote" id="GUID-DC6B8DF7-C959-443F-B7D9-06ECA84BCD55__GUID-1126C22A-11D9-4682-96EB-3EC4AF8CB094">
                     <p class="notep1">注意：</p>
                     <p>在<span>Oracle Active Data Guard中</span> ，备用数据库忽略连接组定义。备用数据库不使用通用词典，并执行查询，就像连接组不存在一样。
                     </p>
                  </div>
                  <div class="example" id="GUID-DC6B8DF7-C959-443F-B7D9-06ECA84BCD55__GUID-B3380351-7EC3-44A4-B197-53787C717631">
                     <p class="titleinexample">示例8-1创建加入组</p>
                     <p>此示例创建名为<code class="codeph">deptid_jg</code>的连接组，其中包含<code class="codeph">hr.employees</code>和<code class="codeph">hr.departments</code>表中的<code class="codeph">department_id</code>列。
                     </p><pre class="pre codeblock"><code>CREATE INMEMORY JOIN GROUP deptid_jg（hr.employees（department_id），hr.departments（department_id））;</code></pre></div>
                  <!-- class="example" -->
               </div>
               <div>
                  <div class="familylinks">
                     <div class="parentlink">
                        <p><strong>父主题：</strong> <a href="optimizing-queries-with-join-groups.html#GUID-3E5491C4-B345-4A8E-8B1B-8DC150C8A797" title="连接组是用户创建的字典对象，它列出了一个或多个可以有意义连接的列。">使用连接组优化连接</a></p>
                     </div>
                  </div>
               </div>
               
            </div>
            <div class="sect2"><a id="GUID-5322DCBB-EC1A-435F-A552-C71A8879DE5B" name="GUID-5322DCBB-EC1A-435F-A552-C71A8879DE5B"></a><h3 id="INMEM-GUID-5322DCBB-EC1A-435F-A552-C71A8879DE5B" class="sect3"><span class="enumeration_section">8.3</span>加入群组的目的</h3>
               <div>
                  <p>在某些查询中，连接组消除了解压缩和散列列值的性能开销。</p>
                  <p>如果没有连接组，如果优化器使用散列连接但不能使用Bloom过滤器，或者Bloom过滤器不能有效地过滤行，则数据库必须解压缩IMCU并使用昂贵的散列连接。为了说明问题，假设星型模式具有<code class="codeph">sales</code>事实表和<code class="codeph">vehicles</code>维度表。以下查询连接这些表，但不过滤输出，这意味着数据库无法使用Bloom过滤器：</p><pre class="pre codeblock"><code>SELECT v.year，v.name，s.sales_price FROM vehicles v，sales s WHERE v.name = s.name;</code></pre><p>下图说明了数据库如何连接两个数据集。</p>
                  <div class="figure" id="GUID-5322DCBB-EC1A-435F-A552-C71A8879DE5B__GUID-F6A22D09-F119-45D9-BBDE-1E9E34631E75">
                     <p class="titleinfigure">图8-1没有加入组的哈希加入</p><img src="img/inmem_3v_004.png" alt="下面是图8-1的描述" title="下面是图8-1的描述" longdesc="img_text/inmem_3v_004.html"><br><a href="img_text/inmem_3v_004.html">“图8-1没有加入组的哈希加入”的描述</a></div>
                  <!-- class="figure" -->
                  <p>数据库执行散列连接，如下所示：</p>
                  <ol>
                     <li>
                        <p>扫描<code class="codeph">vehicles</code>表，解压缩满足谓词的行（在这种情况下，所有行都满足谓词，因为不存在过滤器），并将行发送到散列连接</p>
                     </li>
                     <li>
                        <p>根据解压缩的行在PGA中构建哈希表</p>
                     </li>
                     <li>
                        <p>扫描<code class="codeph">sales</code>表并应用任何过滤器（在这种情况下，查询不指定过滤器）</p>
                     </li>
                     <li>
                        <p>处理匹配来自IMCU的行，然后将行发送到连接</p>
                        <p>当散列连接可以使用探测端的行集（在本例中为<code class="codeph">sales</code>表）时，表扫描发送的行集采用压缩形式。根据是否利用本地字典或连接组从构建端查找匹配的行，散列连接将解压缩行或使其保持未压缩状态。
                        </p>
                     </li>
                     <li>
                        <p>使用连接列探测哈希表，在这种情况下，连接列是车辆名称</p>
                     </li>
                  </ol>
                  <p>如果<code class="codeph">v.name</code>和<code class="codeph">s.name</code>列上存在连接组，则数据库可以使前面的步骤更有效，从而消除了解压缩和过滤开销。加入组的好处是：</p>
                  <ul style="list-style-type:disc">
                     <li>
                        <p>数据库对压缩数据进行操作。</p>
                     </li>
                     <li>
                        <p>数据库避免对连接键进行散列并探测散列表，这需要比较探测行和散列行的连接键。</p>
                        <p>当存在连接组时，数据库将每个连接列值的代码存储在<a href="glossary.html#GUID-D04AB5B8-A58B-4494-A54F-09CEBC113460"><span class="xrefglossterm">公共字典中</span></a> 。数据库使用字典代码构建连接组数组。每个数组元素都指向存储在散列区域中的构建方行（通常是PGA内存）。在探测期间，每个探测行都有一个与连接键关联的代码。数据库使用此代码搜索数组以确定数组元素中是否存在指针。如果指针存在，则存在匹配;否则，没有匹配。
                        </p>
                     </li>
                     <li>
                        <p>字典代码密集且具有固定长度，这使得它们节省空间。</p>
                     </li>
                     <li>
                        <p>当无法使用Bloom过滤器时，有时可以使用连接组优化查询。</p>
                     </li>
                  </ul>
               </div>
               <div>
                  <div class="familylinks">
                     <div class="parentlink">
                        <p><strong>父主题：</strong> <a href="optimizing-queries-with-join-groups.html#GUID-3E5491C4-B345-4A8E-8B1B-8DC150C8A797" title="连接组是用户创建的字典对象，它列出了一个或多个可以有意义连接的列。">使用连接组优化连接</a></p>
                     </div>
                  </div>
               </div>
               
            </div>
            <div class="sect2"><a id="GUID-7972FD49-0418-4196-9069-A4F44D16A9F1" name="GUID-7972FD49-0418-4196-9069-A4F44D16A9F1"></a><h3 id="INMEM-GUID-7972FD49-0418-4196-9069-A4F44D16A9F1" class="sect3"><span class="enumeration_section">8.4</span>加入组如何工作</h3>
               <div>
                  <p>在连接组中，数据库使用相同的公共字典压缩连接组中的所有列。</p>
                  <p>本节包含以下主题：</p>
               </div>
               <div>
                  <ul class="ullinks">
                     <li class="ulchildlink"><a href="optimizing-queries-with-join-groups.html#GUID-88A573DD-99D3-48D7-8310-B46F70184793">加入组如何使用公共字典</a><br><strong class="term">公共字典</strong>是表级特定于实例的字典代码集。
                     </li>
                     <li class="ulchildlink"><a href="optimizing-queries-with-join-groups.html#GUID-94A4125F-E7DA-4462-8F8D-65AB8CB2BB63">加入组如何优化扫描</a><br>关键优化是加入公共字典代码而不是列值，从而避免使用哈希表进行连接。
                     </li>
                  </ul>
                  <div class="familylinks">
                     <div class="parentlink">
                        <p><strong>父主题：</strong> <a href="optimizing-queries-with-join-groups.html#GUID-3E5491C4-B345-4A8E-8B1B-8DC150C8A797" title="连接组是用户创建的字典对象，它列出了一个或多个可以有意义连接的列。">使用连接组优化连接</a></p>
                     </div>
                  </div>
               </div>
               
               <div class="sect3"><a id="GUID-88A573DD-99D3-48D7-8310-B46F70184793" name="GUID-88A573DD-99D3-48D7-8310-B46F70184793"></a><h4 id="INMEM-GUID-88A573DD-99D3-48D7-8310-B46F70184793" class="sect4"><span class="enumeration_section">8.4.1</span>加入组如何使用公共字典</h4>
                  <div>
                     <p><strong class="term">公共字典</strong>是表级特定于实例的字典代码集。
                     </p>
                     <p>当在基础列上定义连接组时，数据库会自动在IM列存储中创建公共字典。公共字典使连接列能够共享相同的字典代码。</p>
                     <p>常用字典具有以下优点：</p>
                     <ul style="list-style-type:disc">
                        <li>
                           <p>使用来自公共字典的代码对本地字典中的值进行编码，该代码提供压缩并提高IMCU的缓存效率</p>
                        </li>
                        <li>
                           <p>允许联接使用字典代码来构造和探测散列连接期间使用的数据结构</p>
                        </li>
                        <li>
                           <p>使优化器能够获取基数，列值分布等统计信息</p>
                        </li>
                     </ul>
                     <p>下图说明了与<code class="codeph">sales.name</code>和<code class="codeph">vehicles.name</code>列上创建的连接组对应的常用字典。
                     </p>
                     <div class="figure" id="GUID-88A573DD-99D3-48D7-8310-B46F70184793__GUID-EDFD9FE8-3916-46BF-9F9D-227869F4B166">
                        <p class="titleinfigure">图8-2加入组的通用字典</p><img src="img/inmem_pb_001a.png" alt="下面是图8-2的描述" title="下面是图8-2的描述" longdesc="img_text/inmem_pb_001a.html"><br><a href="img_text/inmem_pb_001a.html">“图8-2加入组的通用字典”的说明</a></div>
                     <!-- class="figure" -->
                     <p>当数据库使用公共字典时，每个CU的本地字典不存储原始值： <code class="codeph">AUDI</code> ， <code class="codeph">BMW</code> ， <code class="codeph">CADILLAC</code> ， <code class="codeph">FORD</code>等。相反，本地字典存储<span class="italic">对</span>存储在公共字典中的值的<span class="italic">引用</span> 。例如， <span class="italic">本地</span>词典可能存储<code class="codeph">Audi</code>的值<code class="codeph">101</code>和<code class="codeph">BMW</code> <code class="codeph">220</code> 。 <span class="italic">常用</span>字典可能存储<code class="codeph">Audi</code>值<code class="codeph">0</code>和<code class="codeph">BMW</code> <code class="codeph">1</code>值。本地字典中的<code class="codeph">101</code> （AUDI）是指向公共字典中的<code class="codeph">0</code> （AUDI）的指针。
                     </p>
                  </div>
                  <div>
                     <div class="familylinks">
                        <div class="parentlink">
                           <p><strong>父主题：</strong> <a href="optimizing-queries-with-join-groups.html#GUID-7972FD49-0418-4196-9069-A4F44D16A9F1" title="在连接组中，数据库使用相同的公共字典压缩连接组中的所有列。">加入组如何工作</a></p>
                        </div>
                     </div>
                  </div>
                  
               </div>
               <div class="sect3"><a id="GUID-94A4125F-E7DA-4462-8F8D-65AB8CB2BB63" name="GUID-94A4125F-E7DA-4462-8F8D-65AB8CB2BB63"></a><h4 id="INMEM-GUID-94A4125F-E7DA-4462-8F8D-65AB8CB2BB63" class="sect4"><span class="enumeration_section">8.4.2</span>加入组如何优化扫描</h4>
                  <div>
                     <p>关键优化是加入公共字典代码而不是列值，从而避免使用哈希表进行连接。</p>
                     <p>请考虑以下查询，该查询使用连接组在<code class="codeph">name</code>列上加入<code class="codeph">vehicles</code>和<code class="codeph">sales</code> ：</p><pre class="pre codeblock"><code>SELECT v.year，v.name，s.sales_price FROM vehicles v，sales s WHERE v.name = s.name AND v.name IN（'Audi'，'BMW'，'Porsche'，'VW'）;</code></pre><p>下图说明了连接如何从在连接组上创建的公共字典中获益。</p>
                     <div class="figure" id="GUID-94A4125F-E7DA-4462-8F8D-65AB8CB2BB63__GUID-F6A22D09-F119-45D9-BBDE-1E9E34631E75">
                        <p class="titleinfigure">图8-3使用Join Group加入Hash</p><img src="img/inmem_3v_005.png" alt="下面是图8-3的描述" title="下面是图8-3的描述" longdesc="img_text/inmem_3v_005.html"><br><a href="img_text/inmem_3v_005.html">“图8-3使用加入组加入哈希”的说明</a></div>
                     <!-- class="figure" -->
                     <div class="figure" id="GUID-94A4125F-E7DA-4462-8F8D-65AB8CB2BB63__GUID-62904BC2-650D-4E6C-A559-4182D2B7E5DE"></div>
                     <!-- class="figure" -->
                     <p>如上图所示，数据库对压缩数据执行散列连接，如下所示：</p>
                     <ol>
                        <li>
                           <p>扫描<code class="codeph">vehicles</code>表，并将字典代码（不是原始列值）发送到散列连接： <code class="codeph">0</code> （奥迪）， <code class="codeph">1</code> （宝马）， <code class="codeph">2</code> （凯迪拉克），等等</p>
                        </li>
                        <li>
                           <p>在PGA中构建一系列不同的常用字典代码</p>
                        </li>
                        <li>
                           <p>扫描<code class="codeph">sales</code>表并应用任何过滤器（在这种情况下，过滤器仅适用于德国汽车）</p>
                        </li>
                        <li>
                           <p>以压缩格式将匹配行发送到联接</p>
                        </li>
                        <li>
                           <p>在数组中查找相应的值而不是探测哈希表，从而避免在连接键列上计算哈希函数的需要</p>
                        </li>
                     </ol>
                     <p>在此示例中， <code class="codeph">vehicles</code>表仅有七行。<code class="codeph">vehicles.name</code>列具有以下值：</p><pre class="pre codeblock"><code>奥迪宝马凯迪拉克福特保时捷特斯拉大众</code></pre><p>公共字典为每个不同的值分配字典代码。从概念上讲，常用字典如下所示：</p><pre class="pre codeblock"><code>奥迪0宝马1凯迪拉克2福特3保时捷4特斯拉5大众6</code></pre><p>数据库扫描<code class="codeph">vehicles.name</code> ，从第一个IMCU中的第一个字典代码开始，到最后一个IMCU中的最后一个代码结束。它为与过滤器匹配的每一行（仅限德国汽车）存储<code class="codeph">1</code>对于与过滤器不匹配的每行存储<code class="codeph">0</code> 。从概念上讲，数组可能如下所示：</p><pre class="pre codeblock"><code>array [0]：1 array [1]：1 array [2]：0 array [3]：0 array [4]：1 array [5]：0 array [6]：1</code></pre><p>数据库现在扫描<code class="codeph">sales</code>事实表。为简化示例，假设<code class="codeph">sales</code>表只有6行。数据库按如下方式扫描行（每个值的公共字典代码显示在括号中）：</p><pre class="pre codeblock"><code>凯迪拉克（2）凯迪拉克（2）宝马（1）福特（3）奥迪（0）特斯拉（5）</code></pre><p>然后数据库通过<code class="codeph">vehicles.name</code>数组继续查找匹配项。如果行匹配，则数据库将匹配的行及其关联的公共字典代码发送，并从<code class="codeph">vehicles.name</code>和<code class="codeph">sales.name</code> IMCU中检索相应的列值：</p><pre class="pre codeblock"><code>2  - &gt; array [2]为0，所以没有join 2  - &gt; array [2]为0，所以没有join 1  - &gt; array [1]是1，所以join 3  - &gt; array [3]是0，所以没有join 0  - &gt; array [0]为1，所以join 5  - &gt; array [5]为0，所以没有连接</code></pre></div>
                  <div>
                     <div class="familylinks">
                        <div class="parentlink">
                           <p><strong>父主题：</strong> <a href="optimizing-queries-with-join-groups.html#GUID-7972FD49-0418-4196-9069-A4F44D16A9F1" title="在连接组中，数据库使用相同的公共字典压缩连接组中的所有列。">加入组如何工作</a></p>
                        </div>
                     </div>
                  </div>
                  
               </div>
            </div>
            <div class="sect2"><a id="GUID-B09C155D-FE48-408F-AD69-5EAD85372E64" name="GUID-B09C155D-FE48-408F-AD69-5EAD85372E64"></a><h3 id="INMEM-GUID-B09C155D-FE48-408F-AD69-5EAD85372E64" class="sect3"><span class="enumeration_section">8.5</span>当散列连接使用常用字典编码时</h3>
               <div>
                  <p>加入连接组中的列通常会看到性能优势。</p>
                  <p>在创建连接组时，数据库执行以下操作：</p>
                  <ul style="list-style-type:disc">
                     <li>
                        <p>缓存连接键列的字典值的哈希值</p>
                     </li>
                     <li>
                        <p>缓存连接键列的<code class="codeph">NUMBER</code>数据的二进制表示</p>
                     </li>
                     <li>
                        <p>使用相同的通用字典对列进行编码</p>
                     </li>
                  </ul>
                  <p>连接组中的列的连接<span class="italic">始终</span>使用前两个优化来提高性能。例如，如果优化程序选择散列连接，则查询使用缓存的散列值来探测bloom过滤器。如果查询使用IM聚合连接，则查询使用缓存的二进制数来索引关键向量。
                  </p>
                  <p>散列连接可以使用也可以不使用字典编码。当字典编码出现在散列连接的至少一列中时，查询可以通过以下方式利用编码：</p>
                  <ul style="list-style-type:disc">
                     <li>
                        <p>加入群组感知哈希联接</p>
                        <p>散列连接中的两个列在运行时期间携带公共字典编码数据。执行计划必须证明并行哈希联接计划，而不从哈希<span class="italic">双方</span>参与任何分配加入，或串行哈希联接计划。
                        </p>
                     </li>
                     <li>
                        <p>编码感知的散列连接</p>
                        <p>散列连接中的一个事实表列在运行时期间携带字典编码数据。执行计划必须显示并行散列连接，而不显示散列连接右侧的任何分布，或者显示串行散列连接计划。在某些情况下，如果公共字典具有良好的压缩率，并且并行散列连接计划无法利用加入组感知的散列连接（例如，在并行广播 - 无计划中），则查询可以使用编码 - 公共字典的识别散列连接。</p>
                     </li>
                  </ul>
                  <p>在SQL监视器报告中，以下字段显示字典用法：已<code class="codeph">Columnar Encodings Observed</code> ，以及<code class="codeph">Columnar Encodings Leveraged</code> 。统计数据是累积的。在并行散列连接中，这些字段汇总了从执行行源所涉及的所有从属进程收集的统计信息。在IMCU中的本地字典的上下文中，统计信息显示从右子行源观察到的编码ID的数量以及由连接利用的编码的数量。如果单个进程上的散列连接利用公共字典，则<code class="codeph">Columnar Encodings Leveraged</code>显示在连接中利用的编码数。<code class="codeph"></code></p>
                  <p>下表显示了<code class="codeph">Columnar Encodings Observed</code>和<code class="codeph">Columnar Encodings Leveraged</code>的可能值，以及这些组合的含义。
                  </p>
                  <div class="tblformal" id="GUID-B09C155D-FE48-408F-AD69-5EAD85372E64__GUID-33F19E11-C1EB-4FB3-8E8C-35C2A70FA52D">
                     <p class="titleintable">表8-1 SQL监视器报告中的联接组使用情况</p>
                     <table cellpadding="4" cellspacing="0" class="Formal" title="在SQL监视器报告中加入组使用" border="1" summary="This table describes when a hash join uses dictionary encodings" frame="hsides" rules="rows">
                        <thead>
                           <tr align="left" valign="top">
                              <th align="left" valign="bottom" id="d24838e1395">观察到柱状编码</th>
                              <th align="left" valign="bottom" id="d24838e1397">柱状编码杠杆</th>
                              <th align="left" valign="bottom" id="d24838e1399">编码感知哈希加入使用？</th>
                              <th align="left" valign="bottom" id="d24838e1401">加入Group-Aware Hash Join使用？</th>
                           </tr>
                        </thead>
                        <tbody>
                           <tr align="left" valign="top">
                              <td align="left" valign="top" id="d24838e1405" headers="d24838e1395 ">
                                 <p>不存在</p>
                              </td>
                              <td align="left" valign="top" headers="d24838e1405 d24838e1397 ">
                                 <p>不存在</p>
                              </td>
                              <td align="left" valign="top" headers="d24838e1405 d24838e1399 ">
                                 <p>没有</p>
                              </td>
                              <td align="left" valign="top" headers="d24838e1405 d24838e1401 ">
                                 <p>没有</p>
                              </td>
                           </tr>
                           <tr align="left" valign="top">
                              <td align="left" valign="top" id="d24838e1418" headers="d24838e1395 ">
                                 <p>正值</p>
                              </td>
                              <td align="left" valign="top" headers="d24838e1418 d24838e1397 ">
                                 <p>不存在</p>
                              </td>
                              <td align="left" valign="top" headers="d24838e1418 d24838e1399 ">
                                 <p>没有</p>
                              </td>
                              <td align="left" valign="top" headers="d24838e1418 d24838e1401 ">
                                 <p>没有</p>
                              </td>
                           </tr>
                           <tr align="left" valign="top">
                              <td align="left" valign="top" id="d24838e1431" headers="d24838e1395 ">
                                 <p>正值</p>
                              </td>
                              <td align="left" valign="top" headers="d24838e1431 d24838e1397 ">
                                 <p>正值</p>
                              </td>
                              <td align="left" valign="top" headers="d24838e1431 d24838e1399 ">
                                 <p>是</p>
                              </td>
                              <td align="left" valign="top" headers="d24838e1431 d24838e1401 ">
                                 <p>没有</p>
                              </td>
                           </tr>
                           <tr align="left" valign="top">
                              <td align="left" valign="top" id="d24838e1444" headers="d24838e1395 ">
                                 <p>不存在</p>
                              </td>
                              <td align="left" valign="top" headers="d24838e1444 d24838e1397 ">
                                 <p>正值</p>
                              </td>
                              <td align="left" valign="top" headers="d24838e1444 d24838e1399 ">
                                 <p>没有</p>
                              </td>
                              <td align="left" valign="top" headers="d24838e1444 d24838e1401 ">
                                 <p>是</p>
                              </td>
                           </tr>
                        </tbody>
                     </table>
                  </div>
                  <!-- class="inftblhruleinformal" -->
                  <p>例如，如果报告显示<code class="codeph">Columnar Encodings Leveraged</code>字段为<code class="codeph">4</code> （例如，因为并行度为4）但是<code class="codeph">Columnar Encodings Observed</code>字段不存在，则查询利用连接组进行散列连接。如果<code class="codeph">Columnar Encodings Observed</code>字段为<code class="codeph">4</code>但<code class="codeph">Columnar Encodings Leveraged</code>字段不存在，则存在字典编码，但查询未使用它们。
                  </p>
                  <p>各种因素可以防止查询引入编码感知的散列连接。因素包括：</p>
                  <ul style="list-style-type:disc">
                     <li>
                        <p>公共字典的压缩比是次优的。</p>
                     </li>
                     <li>
                        <p>该查询观察到从表扫描传递的太多行集而没有公共字典。</p>
                     </li>
                     <li>
                        <p>构建端行长度太大。</p>
                     </li>
                     <li>
                        <p>构建端行不能适合PGA内存。</p>
                     </li>
                     <li>
                        <p>构建方具有重复的连接键。</p>
                     </li>
                  </ul>
               </div>
               <div>
                  <div class="infoboxnotealso" id="GUID-B09C155D-FE48-408F-AD69-5EAD85372E64__GUID-7FFF20F7-9A99-40A3-968F-284A2B25FBEC">
                     <p class="notep1">也可以看看：</p>
                     <p><span class="q">“ <a href="optimizing-queries-with-join-groups.html#GUID-5E6B9757-ADA2-408D-8FA4-274D36AE22E1" title="要确定查询是否使用连接组，可以使用图形SQL监视器报告（推荐）或使用DBMS_SQLTUNE.REPORT_SQL_MONITOR_XML函数的SQL查询。">监控加入组使用情况</a> ”</span></p>
                  </div>
                  <div class="familylinks">
                     <div class="parentlink">
                        <p><strong>父主题：</strong> <a href="optimizing-queries-with-join-groups.html#GUID-3E5491C4-B345-4A8E-8B1B-8DC150C8A797" title="连接组是用户创建的字典对象，它列出了一个或多个可以有意义连接的列。">使用连接组优化连接</a></p>
                     </div>
                  </div>
               </div>
               
            </div>
            <div class="sect2"><a id="GUID-67D6F161-BEAD-495F-94C1-86D47B8A8E74" name="GUID-67D6F161-BEAD-495F-94C1-86D47B8A8E74"></a><h3 id="INMEM-GUID-67D6F161-BEAD-495F-94C1-86D47B8A8E74" class="sect3"><span class="enumeration_section">8.6</span>创建加入组</h3>
               <div>
                  <p>使用<code class="codeph">CREATE INMEMORY JOIN GROUP</code>语句定义连接组。
                  </p>
                  <div class="section">
                     <p>连接组的候选者是经常在连接谓词中配对的列。典型示例包括连接事实和维度表的列，或将表连接到自身的列。</p>
                     <p><code class="codeph">CREATE INMEMORY JOIN GROUP</code>语句立即定义连接组，这意味着其元数据在数据字典中可见。数据库不会立即构建公共字典。相反，数据库在下次在IM列存储中填充或重新填充连接组中引用的表时构建公共字典。
                     </p>
                  </div>
                  <!-- class="section" -->
                  <div class="section">
                     <p class="subhead2" id="GUID-67D6F161-BEAD-495F-94C1-86D47B8A8E74__GUID-FD391BEF-F6C8-4F48-8C1F-CC77A158B6EE">方针</p>
                     <p>创建，修改或删除连接组通常会使连接组中引用的所有基础表无效。因此，Oracle建议您<span class="italic">在</span>最初填充表<span class="italic">之前</span>创建连接组。
                     </p>
                  </div>
                  <!-- class="section" -->
                  <div class="section">
                     <p class="subhead2" id="GUID-67D6F161-BEAD-495F-94C1-86D47B8A8E74__GUID-F9BF7619-09C1-4475-9F73-83AA019B4083">要创建连接组：</p>
                     <ol>
                        <li>
                           <p>在SQL * Plus或SQL Developer中，以具有必要权限的用户身份登录数据库。</p>
                        </li>
                        <li>
                           <p>使用以下格式的语句创建连接组：</p><pre class="pre codeblock"><code>CREATE INMEMORY JOIN GROUP <span class="italic">join_group_name</span> （ <span class="italic">table1</span> （ <span class="italic">col1</span> ）， <span class="italic">table2</span> （ <span class="italic">col2</span> ））;</code></pre><p>例如，以下语句创建名为<code class="codeph">sales_products_jg</code>的连接组：</p><pre class="pre codeblock"><code>CREATE INMEMORY JOIN GROUP sales_products_jg（sales（prod_id），products（prod_id））;</code></pre></li>
                        <li>
                           <p>（可选）通过查询数据字典查看连接组定义（包括样本输出）：</p><pre class="pre codeblock"><code>COL JOINGROUP_NAME FORMAT a18 COL TABLE_NAME FORMAT a8 COL COLUMN_NAME FORMAT a7 SELECT JOINGROUP_NAME，TABLE_NAME，COLUMN_NAME，GD_ADDRESS FROM DBA_JOINGROUPS; JOINGROUP_NAME TABLE_NA COLUMN_ GD_ADDRESS ------------------ -------- ------- ------------- --- SALES_PRODUCTS_JG SALES PROD_ID 00000000A142AE50 SALES_PRODUCTS_JG PRODUCTS PROD_ID 00000000A142AE50</code></pre></li>
                        <li>
                           <p>填充连接组中引用的表，如果当前填充它们，则重新填充它们。</p>
                        </li>
                     </ol>
                  </div>
                  <!-- class="section" -->
                  <div class="example" id="GUID-67D6F161-BEAD-495F-94C1-86D47B8A8E74__GUID-433C0743-8571-4517-AB19-5F33402BCDAA">
                     <p class="titleinexample">示例8-2使用加入组优化查询</p>
                     <p>在此示例中，您以<code class="codeph">SYSTEM</code>身份登录到数据库，然后在<code class="codeph">sales</code>和<code class="codeph">products</code>的<code class="codeph">prod_id</code>列上创建一个连接组， <code class="codeph">prod_id</code>列尚未填充到IM列存储中：</p><pre class="pre codeblock"><code>CREATE INMEMORY JOIN GROUP sh.sales_products_jg（sh.sales（prod_id），sh.products（prod_id））;</code></pre><p>您为IM列存储中的填充启用了<code class="codeph">sh.sales</code>和<code class="codeph">sh.products</code>表：</p><pre class="pre codeblock"><code>ALTER TABLE sh.sales INMEMORY; ALTER TABLE sh.products INMEMORY;</code></pre><p>以下查询表明尚未在IM列存储中填充表（包括示例输出）：</p><pre class="pre codeblock"><code>COL所有者格式a3 COL姓名格式a10 COL状态格式a20选择所有者，SEGMENT_NAME名称，来自V $ IM_SEGMENTS的POPULATE_STATUS状态;没有选择任何行</code></pre><p>查询两个表以在IM列存储中填充它们：</p><pre class="pre codeblock"><code>SELECT / * + FULL（s）NO_PARALLEL（s）* / COUNT（*）FROM sh.sales s; SELECT / * + FULL（p）NO_PARALLEL（p）* / COUNT（*）FROM sh.products p;</code></pre><p>以下查询表明现在在IM列存储中填充了表（包括样本输出）：</p><pre class="pre codeblock"><code>COL所有者格式a3 COL名称格式a10 COL分区格式a13 COL状态格式a20选择所有者，SEGMENT_NAME NAME，PARTITION_NAME PARTITION，POPULATE_STATUS状态，BYTES_NOT_POPULATED自V $ IM_SEGMENTS;自己的名字分区状态BYTES_NOT_POPULATED --- ---------- ------------- ------------------- -  ------------------- SH SALES SALES_Q3_1998已完成0 SH SALES SALES_Q4_2001已完成0 SH SALES SALES_Q4_1999已完成0 SH产品已完成0 SH SALES SALES_Q1_2001已完成0 SH SALES SALES_Q1_1999已完成0 SH SALES SALES_Q2_2000竣工0 SH SALES SALES_Q2_1998竣工0 SH SALES SALES_Q3_2001竣工0 SH SALES SALES_Q3_1999竣工0 SH SALES SALES_Q4_2000竣工0 SH SALES SALES_Q4_1998竣工0 SH SALES SALES_Q1_2000竣工0 SH SALES SALES_Q1_1998竣工0 SH SALES SALES_Q2_2001竣工0 SH SALES SALES_Q2_1999竣工0 SH SALES SALES_Q3_2000已完成0</code></pre><p>查询<code class="codeph">DBA_JOINGROUPS</code>以获取有关连接组的信息（包括样本输出）：</p><pre class="pre codeblock"><code>COL JOINGROUP_NAME FORMAT a18 COL TABLE_NAME FORMAT a8 COL COLUMN_NAME FORMAT a7 SELECT JOINGROUP_NAME，TABLE_NAME，COLUMN_NAME，GD_ADDRESS FROM DBA_JOINGROUPS; JOINGROUP_NAME TABLE_NA COLUMN_ GD_ADDRESS ------------------ -------- ------- ------------- --- SALES_PRODUCTS_JG SALES PROD_ID 00000000A142AE50 SALES_PRODUCTS_JG PRODUCTS PROD_ID 00000000A142AE50</code></pre><p>前面的输出显示连接组<code class="codeph">sales_products_jg</code>连接在同一个公共字典地址上。
                     </p>
                  </div>
                  <!-- class="example" -->
               </div>
               <div>
                  <div class="infoboxnotealso" id="GUID-67D6F161-BEAD-495F-94C1-86D47B8A8E74__GUID-7612DCEE-ACBA-4551-8203-B86FFE6734BF">
                     <p class="notep1">也可以看看：</p>
                     <ul style="list-style-type:disc">
                        <li>
                           <p><a href="../sqlrf/CREATE-INMEMORY-JOIN-GROUP.html#SQLRF-GUID-87CA7034-4F80-4D46-8EE1-5CC865C2D676" target="_blank"><span><cite>Oracle Database SQL语言参考</cite></span></a>了解<code class="codeph">CREATE INMEMORY JOIN GROUP</code>语句</p>
                        </li>
                        <li>
                           <p><a href="../refrn/DBA_JOINGROUPS.html#GUID-285814BC-3BE0-47DA-8832-779229D5A93A" target="_blank"><span><cite>Oracle Database Reference</cite></span></a>了解<code class="codeph">DBA_JOINGROUPS</code>视图</p>
                        </li>
                     </ul>
                  </div>
                  <div class="familylinks">
                     <div class="parentlink">
                        <p><strong>父主题：</strong> <a href="optimizing-queries-with-join-groups.html#GUID-3E5491C4-B345-4A8E-8B1B-8DC150C8A797" title="连接组是用户创建的字典对象，它列出了一个或多个可以有意义连接的列。">使用连接组优化连接</a></p>
                     </div>
                  </div>
               </div>
               
            </div>
            <div class="sect2"><a id="GUID-5E6B9757-ADA2-408D-8FA4-274D36AE22E1" name="GUID-5E6B9757-ADA2-408D-8FA4-274D36AE22E1"></a><h3 id="INMEM-GUID-5E6B9757-ADA2-408D-8FA4-274D36AE22E1" class="sect3"><span class="enumeration_section">8.7</span>监控加入组使用情况</h3>
               <div>
                  <p>要确定查询是否使用连接组，可以使用图形SQL监视器报告（推荐）或使用<code class="codeph">DBMS_SQLTUNE.REPORT_SQL_MONITOR_XML</code>函数的SQL查询。
                  </p>
                  <div class="section">
                     <p><span class="q">“ <a href="optimizing-queries-with-join-groups.html#GUID-B09C155D-FE48-408F-AD69-5EAD85372E64" title="加入连接组中的列通常会看到性能优势。">当Hash Join使用常用字典编码时</a> ”</span>解释了如何解释SQL Monitor输出。
                     </p>
                  </div>
                  <!-- class="section" -->
                  <div class="section">
                     <p class="subhead2" id="GUID-5E6B9757-ADA2-408D-8FA4-274D36AE22E1__GUID-6F09B066-9BAC-4AAA-92CB-4B7D7D240221">先决条件</p>
                     <p>要监视连接组，您必须满足以下先决条件：</p>
                     <ul style="list-style-type:disc">
                        <li>
                           <p>必须存在连接组。</p>
                        </li>
                        <li>
                           <p>必须<span class="italic">在</span>创建连接组<span class="italic">后</span>填充连接组引用的列。
                           </p>
                        </li>
                        <li>
                           <p>您必须执行可能使用连接组的连接查询。</p>
                        </li>
                     </ul>
                  </div>
                  <!-- class="section" -->
                  <div class="section">
                     <p class="subhead2" id="GUID-5E6B9757-ADA2-408D-8FA4-274D36AE22E1__GUID-6D62F80B-334C-4684-99D9-028A3CD859BD">监控加入组使用情况：</p>
                     <ol>
                        <li>
                           <p>以具有必要权限的用户身份登录数据库。</p>
                        </li>
                        <li>
                           <p>创建一个SQL * Plus变量来存储SQL ID，如下所示：</p><pre class="pre codeblock"><code>VAR b_sqlid VARCHAR2（13）</code></pre></li>
                        <li>
                           <p>执行连接到连接组中的列的查询。</p>
                        </li>
                        <li>
                           <p>使用以下技术：</p>
                           <ul style="list-style-type:disc">
                              <li>
                                 <p>图形SQL监视器报告</p>
                                 <p>SQL Monitor报告在Enterprise Manager中可用。在SQL * Plus中，您可以使用<code class="codeph">DBMS_SQL_MONITOR.REPORT_SQL_MONITOR</code>生成SQL监视器报告，如下所示：</p><pre class="pre codeblock"><code>SET TRIMSPOOL ON SET TRIM ON SET PAGES 0 SET LINESIZE 1000 SET LONG 1000000 SET LONGCHUNKSIZE 1000000 SPOOL /tmp/long_sql.htm SELECT DBMS_SQL_MONITOR.REPORT_SQL_MONITOR（sql_id =&gt;： <span class="bold">b_sqlid</span> ，report_level =&gt;'ALL'，TYPE =&gt;'active'）来自双重; SPOOL OFF</code></pre><p>在浏览器中访问报表，然后单击散列联接上的双筒望远镜图标以查看联接组统计信息。</p>
                              </li>
                              <li>
                                 <p>命令行查询</p>
                                 <p>在查询中使用<code class="codeph">DBMS_SQLTUNE.REPORT_SQL_MONITOR_XML</code>函数，如以下示例所示：</p><pre class="pre codeblock"><code>SELECT encoding_hj.rowsource_id row_source_id，CASE WHEN encoding_hj.encodings_observed IS NULL AND encoding_hj.encodings_leveraged IS NOT NULL那么'加入组被利用'|| encoding_hj.encodings_leveraged || “进程”ELSE'加入组未被利用'END columnar_encoding_usage_info FROM（SELECT DBMS_SQLTUNE.REPORT_SQL_MONITOR_XML（session_id =&gt;  -  1，sql_id =&gt;： <span class="bold">b_sqlid</span> ）。EXTRACT（q'＃// operation [@ name ='HASH JOIN'和@ parent_id]＃'）xmldata FROM DUAL）hj_operation_data，XMLTABLE（'/ operation'PASSING hj_operation_data.xmldata COLUMNS“ROWSOURCE_ID”NUMBER PATH' @ id'， “ENCODINGS_LEVERAGED”NUMBER PATH'rwsstats / stat [@ id =“9”]'，“ENCODINGS_OBSERVED”NUMBER PATH'rwsstats / stat [@ id =“10”]'）encoding_hj;</code></pre></li>
                           </ul>
                        </li>
                     </ol>
                     <p>以下部分演示了获取连接组使用信息的两种技术：</p>
                  </div>
                  <!-- class="section" -->
               </div>
               <div>
                  <ul class="ullinks">
                     <li class="ulchildlink"><a href="optimizing-queries-with-join-groups.html#GUID-A1CEDB0F-5ADF-42B1-82F7-EB3D895E20DC">使用SQL监视器报告监视连接组：示例</a><br>您的目标是使用图形SQL监视器报告来确定查询是否利用了连接组。
                     </li>
                     <li class="ulchildlink"><a href="optimizing-queries-with-join-groups.html#GUID-8F56486B-B706-4A5B-96CA-FD7C46D1CEB1">从命令行监视加入组：示例</a><br>您的目标是使用命令行工具来确定查询是否利用了连接组。
                     </li>
                  </ul>
                  <div class="familylinks">
                     <div class="parentlink">
                        <p><strong>父主题：</strong> <a href="optimizing-queries-with-join-groups.html#GUID-3E5491C4-B345-4A8E-8B1B-8DC150C8A797" title="连接组是用户创建的字典对象，它列出了一个或多个可以有意义连接的列。">使用连接组优化连接</a></p>
                     </div>
                  </div>
               </div>
               
               <div class="sect3"><a id="GUID-A1CEDB0F-5ADF-42B1-82F7-EB3D895E20DC" name="GUID-A1CEDB0F-5ADF-42B1-82F7-EB3D895E20DC"></a><h4 id="INMEM-GUID-A1CEDB0F-5ADF-42B1-82F7-EB3D895E20DC" class="sect4"><span class="enumeration_section">8.7.1</span>使用SQL监视器报告监视连接组：示例</h4>
                  <div>
                     <p>您的目标是使用图形SQL监视器报告来确定查询是否利用了连接组。</p>
                     <div class="section">
                        <p>在此示例中，您在<code class="codeph">sh.products</code>和<code class="codeph">sh.sales</code>表的<code class="codeph">prod_id</code>列上创建连接组，然后在此列上连接这些表。您授予<code class="codeph">sh</code>帐户管理权限。
                        </p>
                     </div>
                     <!-- class="section" -->
                     <div class="example" id="GUID-A1CEDB0F-5ADF-42B1-82F7-EB3D895E20DC__MONITORINGAJOINGROUP-4943C700">
                        <p class="titleinexample">示例8-3使用SQL监视器报告监视加入组</p>
                        <ol>
                           <li>
                              <p>在SQL * Plus中，以用户<code class="codeph">sh</code>身份登录数据库。
                              </p>
                           </li>
                           <li>
                              <p>创建一个SQL * Plus变量来存储SQL ID，如下所示：</p><pre class="pre codeblock"><code>VAR b_sqlid VARCHAR2（13）</code></pre></li>
                           <li>
                              <p>将<code class="codeph">INMEMORY</code>属性应用于<code class="codeph">sh.products</code>和<code class="codeph">sh.sales</code>表，如下所示：</p><pre class="pre codeblock"><code>ALTER TABLE销售没有INMEMORY; ALTER TABLE产品无INMEMORY; ALTER TABLE销售INMEMORY MEMCOMPRESS FOR QUERY; ALTER TABLE产品INMEMORY MEMCOMPRESS FOR QUERY;</code></pre></li>
                           <li>
                              <p>在<code class="codeph">prod_id</code>上创建一个连接组：</p><pre class="pre codeblock"><code>CREATE INMEMORY JOIN GROUP jgrp_products_sales（products（prod_id），sales（prod_id））;</code></pre></li>
                           <li>
                              <p>扫描表以在IM列存储中填充它们：</p><pre class="pre codeblock"><code>SELECT / * + FULL（s）* / COUNT（*）FROM sales s; SELECT / * + FULL（p）* / COUNT（*）FROM products p;</code></pre></li>
                           <li>
                              <p>执行加入<code class="codeph">prod_id</code>列的<code class="codeph">prod_id</code> ，然后聚合产品销售：</p><pre class="pre codeblock"><code>SELECT / * + USE_HASH（销售）LEADING（产品销售）MONITOR * / products.prod_id，products.prod_category_id，SUM（sales.amount_sold）FROM产品，销售WHERE products.prod_id = sales.prod_id GROUP BY products.prod_category_id，产品。 PROD_ID;</code></pre></li>
                           <li>
                              <p>使用<code class="codeph">DBMS_SQLTUNE.REPORT_SQL_MONITOR</code>生成基于HTML的SQL监视器报告。</p>
                              <p>例如，使用以下内容创建SQL脚本，并在SQL * Plus中运行它：</p><pre class="pre codeblock"><code>SET TRIMSPOOL ON SET TRIM ON SET PAGES 0 SET LINESIZE 1000 SET LONG 1000000 SET LONGCHUNKSIZE 1000000 SPOOL /tmp/jg_report.htm SELECT DBMS_SQL_MONITOR.REPORT_SQL_MONITOR（sql_id =&gt;：b_sqlid，report_level =&gt;'ALL'，TYPE =&gt;'active'）来自双重; SPOOL OFF</code></pre></li>
                           <li>
                              <p>在浏览器中打开HTML报告。</p>
                              <p>以下示例报告显示了联接的执行计划。散列连接中的双筒望远镜打开一个窗口，显示其他统计信息。</p>
                              <div class="figure" id="GUID-A1CEDB0F-5ADF-42B1-82F7-EB3D895E20DC__GUID-288CAD91-6046-4B7C-AAAE-D3ED916DA306">
                                 <p class="titleinfigure">图8-4受监控的SQL执行详细信息页面</p><img src="img/sql_monitor_jg.png" alt="下面是图8-4的描述" title="下面是图8-4的描述" longdesc="img_text/sql_monitor_jg.html"><br><a href="img_text/sql_monitor_jg.html">“图8-4受监控的SQL执行详细信息页面”的说明</a></div>
                              <!-- class="figure" -->
                           </li>
                           <li>
                              <p>单击双筒望远镜图标以打开显示加入组统计信息的窗口。</p>
                              <p>以下示例窗口显示统计信息：</p>
                              <div class="figure" id="GUID-A1CEDB0F-5ADF-42B1-82F7-EB3D895E20DC__GUID-8613B645-AD08-40AC-A381-67982FA82335"><img src="img/other_plan_line_stats.png" alt="other_plan_line_stats.png的描述如下" title="other_plan_line_stats.png的描述如下" longdesc="img_text/other_plan_line_stats.html"><br><a href="img_text/other_plan_line_stats.html">插图说明other_plan_line_stats.png</a></div>
                              <!-- class="figure" -->
                              <p>由于<code class="codeph">Columnar Encodings Leveraged</code>是一个正值，并且不存在<code class="codeph">Columnar Encodings Observed</code> ，因此使用了连接组。
                              </p>
                           </li>
                           <li>
                              <p>（可选）在示例后清理：</p><pre class="pre codeblock"><code>DROP INMEMORY JOIN GROUP jgrp_products_sales; ALTER TABLE销售没有INMEMORY; ALTER TABLE产品无INMEMORY;</code></pre></li>
                        </ol>
                     </div>
                     <!-- class="example" -->
                  </div>
                  <div>
                     <div class="infoboxnotealso" id="GUID-A1CEDB0F-5ADF-42B1-82F7-EB3D895E20DC__GUID-D82CCE85-3ABB-4DE9-A617-6CC4E6A592F1">
                        <p class="notep1">也可以看看：</p>
                        <ul style="list-style-type:disc">
                           <li>
                              <p><span class="q">“ <a href="optimizing-queries-with-join-groups.html#GUID-B09C155D-FE48-408F-AD69-5EAD85372E64" title="加入连接组中的列通常会看到性能优势。">当哈希联接使用常用字典编码时</a> ”</span></p>
                           </li>
                           <li>
                              <p><a href="../arpls/DBMS_SQLTUNE.html#GUID-DA3BD815-42EE-4CF4-8C59-9C40332D66C5" target="_blank"><span><cite>Oracle Database PL / SQL包和类型参考</cite></span></a> ，了解<code class="codeph">DBMS_SQLTUNE.REPORT_SQL_MONITOR_XML</code>函数</p>
                           </li>
                           <li>
                              <p><a href="../refrn/V-SESSION.html#GUID-28E2DC75-E157-4C0A-94AB-117C205789B9" target="_blank"><span><cite>Oracle Database Reference</cite></span></a>了解<code class="codeph">V$SESSION</code>视图</p>
                           </li>
                        </ul>
                     </div>
                     <div class="familylinks">
                        <div class="parentlink">
                           <p><strong>父主题：</strong> <a href="optimizing-queries-with-join-groups.html#GUID-5E6B9757-ADA2-408D-8FA4-274D36AE22E1" title="要确定查询是否使用连接组，可以使用图形SQL监视器报告（推荐）或使用DBMS_SQLTUNE.REPORT_SQL_MONITOR_XML函数的SQL查询。">监控加入组使用情况</a></p>
                        </div>
                     </div>
                  </div>
                  
               </div>
               <div class="sect3"><a id="GUID-8F56486B-B706-4A5B-96CA-FD7C46D1CEB1" name="GUID-8F56486B-B706-4A5B-96CA-FD7C46D1CEB1"></a><h4 id="INMEM-GUID-8F56486B-B706-4A5B-96CA-FD7C46D1CEB1" class="sect4"><span class="enumeration_section">8.7.2</span>从命令行监控加入组：示例</h4>
                  <div>
                     <p>您的目标是使用命令行工具来确定查询是否利用了连接组。</p>
                     <div class="section">
                        <p>在此示例中，您在<code class="codeph">sh.products</code>和<code class="codeph">sh.sales</code>表的<code class="codeph">prod_id</code>列上创建连接组，然后在此列上连接这些表。您授予<code class="codeph">sh</code>帐户管理权限。
                        </p>
                     </div>
                     <!-- class="section" -->
                     <div class="example" id="GUID-8F56486B-B706-4A5B-96CA-FD7C46D1CEB1__MONITORINGAJOINGROUP-4943C700">
                        <p class="titleinexample">示例8-4从命令行监视加入组</p>
                        <ol>
                           <li>
                              <p>以<code class="codeph">sh</code>登录数据库。
                              </p>
                           </li>
                           <li>
                              <p>创建一个SQL * Plus变量来存储SQL ID，如下所示：</p><pre class="pre codeblock"><code>VAR b_sqlid VARCHAR2（13）</code></pre></li>
                           <li>
                              <p>将<code class="codeph">INMEMORY</code>属性应用于<code class="codeph">sh.products</code>和<code class="codeph">sh.sales</code>表，如下所示：</p><pre class="pre codeblock"><code>ALTER TABLE销售没有INMEMORY; ALTER TABLE产品无INMEMORY; ALTER TABLE销售INMEMORY MEMCOMPRESS FOR QUERY; ALTER TABLE产品INMEMORY MEMCOMPRESS FOR QUERY;</code></pre></li>
                           <li>
                              <p>在<code class="codeph">prod_id</code>上创建一个连接组：</p><pre class="pre codeblock"><code>CREATE INMEMORY JOIN GROUP jgrp_products_sales（products（prod_id），sales（prod_id））;</code></pre></li>
                           <li>
                              <p>扫描表以在IM列存储中填充它们：</p><pre class="pre codeblock"><code>SELECT / * + FULL（s）* / COUNT（*）FROM sales s; SELECT / * + FULL（p）* / COUNT（*）FROM products p;</code></pre></li>
                           <li>
                              <p>执行加入<code class="codeph">prod_id</code>列的<code class="codeph">prod_id</code> ，然后聚合产品销售：</p><pre class="pre codeblock"><code>SELECT / * + USE_HASH（销售）LEADING（产品销售）MONITOR * / products.prod_id，products.prod_category_id，SUM（sales.amount_sold）FROM产品，销售WHERE products.prod_id = sales.prod_id GROUP BY products.prod_category_id，产品。 PROD_ID;</code></pre></li>
                           <li>
                              <p>获取上述聚合查询的SQL ID：</p><pre class="pre codeblock"><code>BEGIN SELECT PREV_SQL_ID INTO：b_sqlid FROM V $ SESSION WHERE SID = USERENV（'SID'）;结束;</code></pre></li>
                           <li>
                              <p>使用<code class="codeph">DBMS_SQLTUNE.REPORT_SQL_MONITOR_XML</code>确定数据库是否使用了连接组。
                              </p>
                              <p>例如，执行以下查询：</p><pre class="pre codeblock"><code>COL row_source_id FORMAT 999 COL columnar_encoding_usage_info FORMAT A40 SELECT encoding_hj.rowsource_id row_source_id，CASE WHEN encoding_hj.encodings_observed IS NULL AND encoding_hj.encodings_leveraged IS NOT NULL那么'加入组被利用'|| encoding_hj.encodings_leveraged || “进程”ELSE'加入组未被利用'END columnar_encoding_usage_info FROM（SELECT DBMS_SQLTUNE.REPORT_SQL_MONITOR_XML（session_id =&gt;  -  1，sql_id =&gt;：b_sqlid）。EXTRACT（q'＃// operation [@ name ='HASH JOIN'和@ parent_id]＃'）xmldata FROM DUAL）hj_operation_data，XMLTABLE（'/ operation'PASSING hj_operation_data.xmldata COLUMNS“ROWSOURCE_ID”NUMBER PATH' @ id'， “ENCODINGS_LEVERAGED”NUMBER PATH'rwsstats / stat [@ id =“9”]'，“ENCODINGS_OBSERVED”NUMBER PATH'rwsstats / stat [@ id =“10”]'）encoding_hj;</code></pre><p>以下示例输出显示在查询中利用了连接组：</p><pre class="pre codeblock"><code>ROW_SOURCE_ID COLUMNAR_ENCODING_USAGE_INFO ------------- ----------------------------------- ----- 2加入组被用于1个进程</code></pre></li>
                           <li>
                              <p>（可选）在示例后清理：</p><pre class="pre codeblock"><code>DROP INMEMORY JOIN GROUP jgrp_products_sales; ALTER TABLE销售没有INMEMORY; ALTER TABLE产品无INMEMORY;</code></pre></li>
                        </ol>
                     </div>
                     <!-- class="example" -->
                  </div>
                  <div>
                     <div class="infoboxnotealso" id="GUID-8F56486B-B706-4A5B-96CA-FD7C46D1CEB1__GUID-D82CCE85-3ABB-4DE9-A617-6CC4E6A592F1">
                        <p class="notep1">也可以看看：</p>
                        <ul style="list-style-type:disc">
                           <li>
                              <p><span class="q">“ <a href="optimizing-queries-with-join-groups.html#GUID-B09C155D-FE48-408F-AD69-5EAD85372E64" title="加入连接组中的列通常会看到性能优势。">当哈希联接使用常用字典编码时</a> ”</span></p>
                           </li>
                           <li>
                              <p><a href="../arpls/DBMS_SQLTUNE.html#GUID-DA3BD815-42EE-4CF4-8C59-9C40332D66C5" target="_blank"><span><cite>Oracle Database PL / SQL包和类型参考</cite></span></a> ，了解<code class="codeph">DBMS_SQLTUNE.REPORT_SQL_MONITOR_XML</code>函数</p>
                           </li>
                           <li>
                              <p><a href="https://www.oracle.com/pls/topic/lookup?ctx=en/database/oracle/oracle-database/19/inmem&amp;id=GUID-28E2DC75-E157-4C0A-94AB-117C205789B9" target="_blank"><span><cite>Oracle Database Reference</cite></span></a>了解<code class="codeph">V$SESSION</code>视图</p>
                           </li>
                        </ul>
                     </div>
                     <div class="familylinks">
                        <div class="parentlink">
                           <p><strong>父主题：</strong> <a href="optimizing-queries-with-join-groups.html#GUID-5E6B9757-ADA2-408D-8FA4-274D36AE22E1" title="要确定查询是否使用连接组，可以使用图形SQL监视器报告（推荐）或使用DBMS_SQLTUNE.REPORT_SQL_MONITOR_XML函数的SQL查询。">监控加入组使用情况</a></p>
                        </div>
                     </div>
                  </div>
                  
               </div>
            </div>
         </div>
      </article>
   </body>
</html>