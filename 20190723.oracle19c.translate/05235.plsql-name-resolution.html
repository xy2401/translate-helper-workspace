<html lang="en-us" dir="ltr" xml:lang="en-us">
   <head>
      <meta http-equiv="Content-Type" content="text/html; charset=utf-8"></meta>
      <meta name="viewport" content="width=device-width, initial-scale=1"></meta>
      <meta http-equiv="X-UA-Compatible" content="IE=edge"></meta>
      <title>PL / SQL名称解析</title>
      <meta property="og:site_name" content="Oracle Help Center"></meta>
      <meta property="og:title" content="Database PL/SQL Language Reference "></meta>
      <meta property="og:description" content=""></meta>
      <link rel="stylesheet" href="/sp_common/book-template/ohc-book-template/css/book.css"></link>
      <link rel="shortcut icon" href="/sp_common/book-template/ohc-common/img/favicon.ico"></link>
      <meta name="application-name" content="Database PL/SQL Language Reference"></meta>
      <meta name="generator" content="DITA Open Toolkit version 1.8.5 (Mode = doc)"></meta>
      <meta name="plugin" content="SP_docbuilder HTML plugin release 18.2.2"></meta>
      <link rel="alternate" href="database-pl-sql-language-reference.pdf" title="PDF File" type="application/pdf"></link>
      <meta name="robots" content="all"></meta>
      <link rel="schema.dcterms" href="http://purl.org/dc/terms/"></link>
      <meta name="dcterms.created" content="2019-01-13T20:26:20-08:00"></meta>
      
      <meta name="dcterms.dateCopyrighted" content="1996, 2019"></meta>
      <meta name="dcterms.category" content="database"></meta>
      <meta name="dcterms.identifier" content="E96448-02"></meta>
      
      <meta name="dcterms.product" content="en/database/oracle/oracle-database/19"></meta>
      
      <link rel="prev" href="plsql-source-text-wrapping.html" title="Previous" type="text/html"></link>
      <link rel="next" href="plsql-program-limits.html" title="Next" type="text/html"></link>
      <script>
        document.write('<style type="text/css">');
        document.write('body > .noscript, body > .noscript ~ * { visibility: hidden; }');
        document.write('</style>');
     </script>
      <script src="/sp_common/book-template/requirejs/require.js" data-main="/sp_common/book-template/ohc-book-template/js/book-config"></script>
      <script>
            if (window.require === undefined) {
                document.write('<script data-main="sp_common/book-template/ohc-book-template/js/book-config" src="sp_common/book-template/requirejs/require.js"><\/script>');
                document.write('<link href="sp_common/book-template/ohc-book-template/css/book.css" rel="stylesheet"/>');
            }
        </script>
      <script type="application/json" id="ssot-metadata">{"primary":{"category":{"short_name":"database","element_name":"Database","display_in_url":true},"suite":{"short_name":"oracle","element_name":"Oracle","display_in_url":true},"product_group":{"short_name":"not-applicable","element_name":"Not applicable","display_in_url":false},"product":{"short_name":"oracle-database","element_name":"Oracle Database","display_in_url":true},"release":{"short_name":"19","element_name":"Release 19","display_in_url":true}}}</script>
      
    <meta name="dcterms.title" content="Database PL/SQL Language Reference"></meta>
    <meta name="dcterms.isVersionOf" content="LNPLS"></meta>
    <meta name="dcterms.release" content="Release 19"></meta>
  </head>
   <body dir="ltr">
      <div class="noscript alert alert-danger text-center" role="alert">
         <a href="plsql-source-text-wrapping.html" class="pull-left"><span class="glyphicon glyphicon-chevron-left" aria-hidden="true"></span>上一页</a> <a href="plsql-program-limits.html" class="pull-right">下一页<span class="glyphicon glyphicon-chevron-right" aria-hidden="true"></span></a> <span class="fa fa-exclamation-triangle" aria-hidden="true"></span>必须启用JavaScript才能正确显示此内容</div>
      <article>
         <header>
            <ol class="breadcrumb" vocab="http://schema.org/" typeof="BreadcrumbList">
               <li property="itemListElement" typeof="ListItem"><a href="index.html" property="item" typeof="WebPage"><span property="name">数据库PL / SQL语言参考</span></a></li>
               <li class="active" property="itemListElement" typeof="ListItem">PL / SQL名称解析</li>
            </ol>
            <a id="GUID-7A77C7A5-F6BE-49F4-A398-EDD8646CE2C9" name="GUID-7A77C7A5-F6BE-49F4-A398-EDD8646CE2C9"></a><a id="LNPLS2153"></a><a id="LNPLS017"></a>
            
            <h2 id="LNPLS-GUID-7A77C7A5-F6BE-49F4-A398-EDD8646CE2C9" class="sect2"><span class="enumeration_chapter">B</span> PL / SQL名称解析</h2>
         </header>
         <div class="ind">
            <div>
               <p>本附录解释了PL / SQL <span class="bold">名称解析</span> ;也就是说，PL / SQL编译器如何解决对标识符的模糊引用。
               </p>
               <p>如果更改其编译单元中的标识符（即，如果添加，重命名或删除标识符），则明确的标识符引用可能会变得不明确。</p>
               <div class="infoboxnote" id="GUID-7A77C7A5-F6BE-49F4-A398-EDD8646CE2C9__GUID-4C7ADE5B-AE64-4AB1-9FDB-BA2D0D0D02C4">
                  <p class="notep1">注意：</p>
                  <p>存储的PL / SQL单元的<code class="codeph">AUTHID</code>属性会影响单元在运行时发出的SQL语句的名称解析。有关更多信息，请参阅<span class="q">“ <a href="plsql-subprograms.html#GUID-41D23DE7-3C07-41CF-962B-F92B696594B5" title="如果在DR单元（定义者权限单元）中包含已连接的用户数据库链接，则必须向将运行DR单元的用户授予INHERIT REMOTE PRIVILEGES权限。">Invoker的权利和定义者权利（AUTHID属性）</a> ”</span> 。
                  </p>
               </div>
               <div class="section">
                  <p class="subhead1" id="GUID-7A77C7A5-F6BE-49F4-A398-EDD8646CE2C9__GUID-98C0062E-3F48-4B4C-950B-393A234A5A4C">话题</p>
               </div>
               <!-- class="section" -->
               <div class="section">
                  <ul style="list-style-type:disc">
                     <li>
                        <p><a href="plsql-name-resolution.html#GUID-688FB948-E8F0-4294-B2DF-4C281BCD366C">限定名称和点表示法</a></p>
                     </li>
                     <li>
                        <p><a href="plsql-name-resolution.html#GUID-A551A39D-7DF8-4525-BE0F-1F46FE04ED09">列名优先</a></p>
                     </li>
                     <li>
                        <p><a href="plsql-name-resolution.html#GUID-848E544F-7C7A-41F6-BFDC-BBEC58DC6F24">PL / SQL和SQL名称解析规则之间的差异</a></p>
                     </li>
                     <li>
                        <p><a href="plsql-name-resolution.html#GUID-0D18B5E5-A6F7-45B7-A1FA-F7D930C6999C">静态SQL语句中的名称解析</a></p>
                     </li>
                     <li>
                        <p><a href="plsql-name-resolution.html#GUID-6471F04B-7872-4D88-B72D-8B46448B29EB">什么是捕获？</a></p>
                     </li>
                     <li>
                        <p><a href="plsql-name-resolution.html#GUID-5B50488D-CF48-4A77-BD75-96D62EDF4BBE">避免SELECT和DML语句中的内部捕获</a></p>
                     </li>
                  </ul>
               </div>
               <!-- class="section" -->
            </div><a id="LNPLS1751"></a><a id="LNPLS01702"></a><div class="props_rev_3"><a id="GUID-688FB948-E8F0-4294-B2DF-4C281BCD366C" name="GUID-688FB948-E8F0-4294-B2DF-4C281BCD366C"></a><h3 id="LNPLS-GUID-688FB948-E8F0-4294-B2DF-4C281BCD366C" class="sect3"><span class="enumeration_section">B.1</span>合格名称和点表示法</h3>
               <div>
                  <p>当一个命名项属于另一个命名项时，您可以（有时必须）使用点表示法限定具有“父”项名称的“子”项的名称。例如：</p>
                  <div class="tblformal" id="GUID-688FB948-E8F0-4294-B2DF-4C281BCD366C__GUID-A7F64158-28E0-4F59-9755-3252BF6B9969">
                     <table cellpadding="4" cellspacing="0" class="Formal" title="" width="100%" border="1" summary="This table lists the &quot;child&quot; identifiers that you must qualify, their &quot;parents,&quot; and the syntax of their qualified names." frame="hsides" rules="rows">
                        <thead>
                           <tr align="left" valign="top">
                              <th align="left" valign="bottom" width="31%" id="d161356e232">引用时......</th>
                              <th align="left" valign="bottom" width="31%" id="d161356e235">你必须用...来限定它的名字</th>
                              <th align="left" valign="bottom" width="37%" id="d161356e238">使用这种语法......</th>
                           </tr>
                        </thead>
                        <tbody>
                           <tr align="left" valign="top">
                              <td align="left" valign="top" width="31%" id="d161356e243" headers="d161356e232 ">
                                 <p>记录的领域</p>
                              </td>
                              <td align="left" valign="top" width="31%" headers="d161356e243 d161356e235 ">
                                 <p>记录的名称</p>
                              </td>
                              <td align="left" valign="top" width="37%" headers="d161356e243 d161356e238 ">
                                 <p><span class="italic"><code class="codeph">record_name.field_name</code></span></p>
                              </td>
                           </tr>
                           <tr align="left" valign="top">
                              <td align="left" valign="top" width="31%" id="d161356e255" headers="d161356e232 ">
                                 <p>收集方法</p>
                              </td>
                              <td align="left" valign="top" width="31%" headers="d161356e255 d161356e235 ">
                                 <p>集合的名称</p>
                              </td>
                              <td align="left" valign="top" width="37%" headers="d161356e255 d161356e238 ">
                                 <p><span class="italic"><code class="codeph">collection_name.method</code></span></p>
                              </td>
                           </tr>
                           <tr align="left" valign="top">
                              <td align="left" valign="top" width="31%" id="d161356e267" headers="d161356e232 ">
                                 <p>伪列<code class="codeph">CURRVAL</code></p>
                              </td>
                              <td align="left" valign="top" width="31%" headers="d161356e267 d161356e235 ">
                                 <p>序列的名称</p>
                              </td>
                              <td align="left" valign="top" width="37%" headers="d161356e267 d161356e238 ">
                                 <p><span class="italic"><code class="codeph">sequence_name</code></span> <code class="codeph">.CURRVAL</code></p>
                              </td>
                           </tr>
                           <tr align="left" valign="top">
                              <td align="left" valign="top" width="31%" id="d161356e283" headers="d161356e232 ">
                                 <p>伪<code class="codeph">NEXTVAL</code></p>
                              </td>
                              <td align="left" valign="top" width="31%" headers="d161356e283 d161356e235 ">
                                 <p>序列的名称</p>
                              </td>
                              <td align="left" valign="top" width="37%" headers="d161356e283 d161356e238 ">
                                 <p><span class="italic"><code class="codeph">sequence_name</code></span> <code class="codeph">.NEXTVAL</code></p>
                              </td>
                           </tr>
                        </tbody>
                     </table>
                  </div>
                  <!-- class="inftblhruleinformal" -->
                  <p>如果在命名的PL / SQL单元中声明了标识符，则可以使用以下语法限定其简单名称（其声明中的名称）和单元名称（块，子程序或包）：</p><pre class="oac_no_warn" dir="ltr"><span class="italic">unit_name.simple_identifier_name</span>
</pre><p>如果标识符不可见，则<span class="italic">必须</span>限定其名称（请参阅<span class="q">“ <a href="plsql-language-fundamentals.html#GUID-2FC17012-FC99-4614-90DD-ADC99F2EDBE9" title="标识符的范围是PL / SQL单元的区域，您可以从中引用标识符。标识符的可见性是PL / SQL单元的区域，您可以从中引用标识符而不限定它。标识符是声明它的PL / SQL单元的本地标识符。如果该单元具有子单元，则标识符对它们是全局的。">标识符的范围和可见性</a> ”</span> ）。
                  </p>
                  <p>如果标识符属于另一个模式，则必须使用以下语法将其名称限定为模式的名称：</p><pre class="oac_no_warn" dir="ltr"><span class="italic">schema_name.package_name</span>
</pre><p>可以使用多个名称限定简单名称，如<a href="plsql-name-resolution.html#GUID-688FB948-E8F0-4294-B2DF-4C281BCD366C__CHDBCGDB">示例B-1</a>所示。
                  </p>
                  <p>可能含糊不清的限定名称的一些示例是：</p>
                  <ul style="list-style-type:disc">
                     <li>
                        <p>函数返回值的字段或属性，例如：</p><pre class="oac_no_warn" dir="ltr"><span class="italic">func_name</span> （）。 <span class="italic">field_name</span> <span class="italic">func_name</span> （）。 <span class="italic">ATTRIBUTE_NAME</span>
</pre></li>
                     <li>
                        <p>架构对象由另一个架构拥有，例如：</p><pre class="oac_no_warn" dir="ltr"><span class="italic">schema_name.table_name</span> <span class="italic">schema_name.procedure_name</span> （） <span class="italic">schema_name.type_name.member_name</span> （）</pre></li>
                     <li>
                        <p>另一个用户拥有的包对象，例如：</p><pre class="oac_no_warn" dir="ltr"><span class="italic">schema_name.package_name.procedure_name</span> （） <span class="italic">schema_name.package_name.record_name.field_name</span>
</pre></li>
                     <li>
                        <p>记录包含ADT，例如：</p><pre class="oac_no_warn" dir="ltr"><span class="italic">record_name.field_name.attribute_name</span> <span class="italic">record_name.field_name.member_name</span> （）</pre></li>
                  </ul>
                  <div class="example" id="GUID-688FB948-E8F0-4294-B2DF-4C281BCD366C__CHDBCGDB">
                     <p class="titleinexample">示例B-1合格名称</p><pre class="oac_no_warn" dir="ltr">创建或替换包装pkg1 AUTHID DEFINER作为数字;类型t1是记录（一个数字）; v1 t1;类型t2是PLS_INTEGER的t1索引表; v2 t2;功能f1（p1 NUMBER）返回t1;功能f2（q1 NUMBER）返回t2;结束pkg1; /创建或替换包装体pkg1作为功能f1（p1编号）返回t1是否为数字;开始n：= m; - 不合格的变量名n：= <span class="bold">pkg1.m</span> ; - 由包名n：= <span class="bold">pkg1.f1.p1</span>限定的变量名称; - 由函数名限定的参数名称， - 由包名n：= <span class="bold">v1.a限定</span> ; - 变量名称后跟组件名称n：= <span class="bold">pkg1.v1.a</span> ; - 由包名称限定的变量名称 - 后跟组件名称n：= <span class="bold">v2（10）.a</span> ; - 索引名称后跟组件名称n：= <span class="bold">f1（10）.a</span> ; - 函数调用后跟组件名称n：= <span class="bold">f2（10）（10）.a</span> ; - 函数调用后跟索引名称 - 后跟组件名称n：= <span class="bold">hr.pkg1.f2（10）（10）.a</span> ; - 模式名称，包名称， - 函数调用，索引，组件名称v1.a：= p1;返回v1; END f1;功能f2（q1编号）返回t2 IS v_t1 t1; v_t2 t2; BEGIN v_t1.a：= q1; v_t2（1）：= v_t1;返回v_t2; END f2;结束pkg1; /</pre></div>
                  <!-- class="example" -->
               </div>
            </div><a id="LNPLS233"></a><a id="LNPLS2155"></a><a id="LNPLS2156"></a><a id="LNPLS234"></a><a id="LNPLS2154"></a><div class="props_rev_3"><a id="GUID-A551A39D-7DF8-4525-BE0F-1F46FE04ED09" name="GUID-A551A39D-7DF8-4525-BE0F-1F46FE04ED09"></a><h3 id="LNPLS-GUID-A551A39D-7DF8-4525-BE0F-1F46FE04ED09" class="sect3"><span class="enumeration_section">B.2</span>列名优先</h3>
               <div>
                  <p>如果SQL语句引用既属于列又属于局部变量或形式参数的名称，则列名优先。</p>
                  <div class="infoboxnote" id="GUID-A551A39D-7DF8-4525-BE0F-1F46FE04ED09__GUID-1E80CFA1-7C13-4ADC-AF53-73136D5294CC">
                     <p class="notep1">警告：</p>
                     <p>将变量或参数名称解释为列名称时，可能会无意中删除，更改或插入数据。</p>
                  </div>
                  <p>在<a href="plsql-name-resolution.html#GUID-A551A39D-7DF8-4525-BE0F-1F46FE04ED09__CBJCHFHC">示例B-2中</a> ，名称<code class="codeph">last_name</code>属于局部变量和列（名称不区分大小写）。因此，在<code class="codeph">WHERE</code>子句中，对<code class="codeph">last_name</code>两个引用都将解析为该列，并且所有行都将被删除。
                  </p>
                  <p><a href="plsql-name-resolution.html#GUID-A551A39D-7DF8-4525-BE0F-1F46FE04ED09__BABJJEBG">例B-3</a>通过给变量赋予不同的名称来解决<a href="plsql-name-resolution.html#GUID-A551A39D-7DF8-4525-BE0F-1F46FE04ED09__CBJCHFHC">例B-2中</a>的问题。
                  </p>
                  <p><a href="plsql-name-resolution.html#GUID-A551A39D-7DF8-4525-BE0F-1F46FE04ED09__BABGGJJG">示例B-4</a>通过标记块并使用块名称限定变量名来解决<a href="plsql-name-resolution.html#GUID-A551A39D-7DF8-4525-BE0F-1F46FE04ED09__CBJCHFHC">示例B-2中</a>的问题。
                  </p>
                  <p>在<a href="plsql-name-resolution.html#GUID-A551A39D-7DF8-4525-BE0F-1F46FE04ED09__BEIFDBJD">示例B-5中</a> ，函数<code class="codeph">dept_name</code>具有形式参数和局部变量，其名称是表<code class="codeph">DEPARTMENTS</code>的列的名称。参数和变量名称使用函数名称限定，以区别于列名称。
                  </p>
                  <div class="example" id="GUID-A551A39D-7DF8-4525-BE0F-1F46FE04ED09__CBJCHFHC">
                     <p class="titleinexample">示例B-2变量名称解释为列名会导致意外结果</p><pre class="oac_no_warn" dir="ltr">DROP TABLE员工2; CREATE TABLE employees2 AS SELECT <span class="bold">LAST_NAME</span> FROM employees; DECLARE <span class="bold">last_name</span> VARCHAR2（10）：='King'; BEGIN DELETE FROM employees2 WHERE <span class="bold">LAST_NAME = last_name</span> ; DBMS_OUTPUT.PUT_LINE（'已删除'|| SQL％ROWCOUNT ||'行。“）;结束; /</pre><p>结果：</p><pre class="oac_no_warn" dir="ltr"><span class="bold">删除了107行。</span>
</pre></div>
                  <!-- class="example" -->
                  <div class="example" id="GUID-A551A39D-7DF8-4525-BE0F-1F46FE04ED09__BABJJEBG">
                     <p class="titleinexample">示例B-3具有不同变量名的固定<span><a href="plsql-name-resolution.html#GUID-A551A39D-7DF8-4525-BE0F-1F46FE04ED09__CBJCHFHC">示例B-2</a></span></p><pre class="oac_no_warn" dir="ltr">DECLARE v_last_name VARCHAR2（10）：='King'; BEGIN DELETE FROM employees2 WHERE <span class="bold">LAST_NAME = v_last_name</span> ; DBMS_OUTPUT.PUT_LINE（'已删除'|| SQL％ROWCOUNT ||'行。“）;结束; /</pre><p>结果：</p><pre class="oac_no_warn" dir="ltr"><span class="bold">删除了2行。</span>
</pre></div>
                  <!-- class="example" -->
                  <div class="example" id="GUID-A551A39D-7DF8-4525-BE0F-1F46FE04ED09__BABGGJJG">
                     <p class="titleinexample">实施例B-4用块标签固定<span><a href="plsql-name-resolution.html#GUID-A551A39D-7DF8-4525-BE0F-1F46FE04ED09__CBJCHFHC">实施例B-2</a></span></p><pre class="oac_no_warn" dir="ltr"><span class="bold">&lt;&lt; main &gt;&gt;</span> DECLARE last_name VARCHAR2（10）：='King'; BEGIN DELETE FROM employees2 WHERE <span class="bold">last_name = main.last_name</span> ; DBMS_OUTPUT.PUT_LINE（'已删除'|| SQL％ROWCOUNT ||'行。“）;结束; /</pre><p>结果：</p><pre class="oac_no_warn" dir="ltr"><span class="bold">删除了2行。</span>
</pre></div>
                  <!-- class="example" -->
                  <div class="example" id="GUID-A551A39D-7DF8-4525-BE0F-1F46FE04ED09__BEIFDBJD">
                     <p class="titleinexample">示例B-5名称解析的子程序名称</p><pre class="oac_no_warn" dir="ltr">DECLARE FUNCTION <span class="bold">dept_name</span> （ <span class="bold">department_id</span> IN NUMBER）RETURN departments.department_name％TYPE IS <span class="bold">department_name</span> departments.department_name％TYPE; BEGIN SELECT <span class="bold">department_name</span> INTO <span class="bold">dept_name.department_name</span> - <span class="bold">^ column</span> <span class="bold">^ local variable</span> FROM departments WHERE <span class="bold">department_id</span> = <span class="bold">dept_name.department_id</span> ; - <span class="bold">^ column</span> <span class="bold">^形式参数</span> RETURN department_name; END dept_name; BEGIN FOR项目IN（SELECT department_id FROM departments ORDER BY department_name）LOOP DBMS_OUTPUT.PUT_LINE（'Department：'|| dept_name（item.department_id））;结束循环;结束; /</pre><p>结果：</p><pre class="oac_no_warn" dir="ltr">部门：会计部门：行政部门：福利部门：建设部门：合同部门：控制和信贷部门：企业税务部门：执行部门：财务部门：政府销售部门：人力资源部门：IT部门：IT服务台部门：IT支持部门：制造部门：营销部门：NOC部门：运营部门：薪资部门：公共关系部门：采购部门：招聘部门：零售部门：销售部门：股东服务部门：航运部门：财务部门</pre></div>
                  <!-- class="example" -->
               </div>
            </div><a id="LNPLS01703"></a><div class="props_rev_3"><a id="GUID-848E544F-7C7A-41F6-BFDC-BBEC58DC6F24" name="GUID-848E544F-7C7A-41F6-BFDC-BBEC58DC6F24"></a><h3 id="LNPLS-GUID-848E544F-7C7A-41F6-BFDC-BBEC58DC6F24" class="sect3"><span class="enumeration_section">B.3</span> PL / SQL和SQL名称解析规则之间的差异</h3>
               <div>
                  <p>PL / SQL和SQL名称解析规则非常相似。然而：</p>
                  <ul style="list-style-type:disc">
                     <li>
                        <p>PL / SQL规则比SQL规则更不宽容。</p>
                        <p>由于大多数SQL规则都是上下文相关的，因此它们认为比PL / SQL规则更合法。</p>
                     </li>
                     <li>
                        <p>PL / SQL和SQL以不同方式解析限定名称。</p>
                        <p>例如，在解析表名<code class="codeph">HR</code> 。 <code class="codeph">JOBS</code> ：</p>
                        <ul style="list-style-type:disc">
                           <li>
                              <p>PL / SQL首先搜索当前模式中名为<code class="codeph">HR</code>包，类型，表和视图，然后搜索公共同义词，最后搜索<code class="codeph">HR</code>模式中名为<code class="codeph">JOBS</code>对象。
                              </p>
                           </li>
                           <li>
                              <p>SQL首先搜索<code class="codeph">HR</code>模式中名为<code class="codeph">JOBS</code>对象，然后搜索当前模式中名为<code class="codeph">HR</code>包，类型，表和视图。
                              </p>
                           </li>
                        </ul>
                     </li>
                  </ul>
                  <p>为避免PL / SQL和SQL名称解析规则之间的差异导致的问题，请遵循<span class="q">“ <a href="plsql-name-resolution.html#GUID-5B50488D-CF48-4A77-BD75-96D62EDF4BBE">避免SELECT和DML语句中的内部捕获</a> ”中</span>的建议。
                  </p>
                  <div class="infoboxnote" id="GUID-848E544F-7C7A-41F6-BFDC-BBEC58DC6F24__GUID-54DDFB5F-01BE-4A69-A676-5B5DDBF79504">
                     <p class="notep1">注意：</p>
                     <p>当PL / SQL编译器处理静态SQL语句时，它会将该语句发送到SQL子系统，该子系统使用SQL规则来解析语句中的名称。有关详细信息，请参阅<span class="q">“ <a href="plsql-name-resolution.html#GUID-0D18B5E5-A6F7-45B7-A1FA-F7D930C6999C">静态SQL语句中的名称解析</a> ”</span> 。
                     </p>
                  </div>
               </div>
            </div><a id="LNPLS99882"></a><div class="props_rev_3"><a id="GUID-0D18B5E5-A6F7-45B7-A1FA-F7D930C6999C" name="GUID-0D18B5E5-A6F7-45B7-A1FA-F7D930C6999C"></a><h3 id="LNPLS-GUID-0D18B5E5-A6F7-45B7-A1FA-F7D930C6999C" class="sect3"><span class="enumeration_section">B.4</span>静态SQL语句中名称的解析</h3>
               <div>
                  <p>静态SQL在<a href="static-sql.html#GUID-A2E4086F-94DC-4CC7-9E4B-30285BEC3313" title="静态SQL是一种PL / SQL功能，它允许直接在PL / SQL语句中使用SQL语法。">PL / SQL静态SQL中</a>描述。</p>
                  <p>当PL / SQL编译器找到静态SQL语句时：</p>
                  <ol>
                     <li id="GUID-0D18B5E5-A6F7-45B7-A1FA-F7D930C6999C__BABBAFCJ">
                        <p>如果该语句是<code class="codeph">SELECT</code>语句，则PL / SQL编译器将删除<code class="codeph">INTO</code>子句。
                        </p>
                     </li>
                     <li>
                        <p>PL / SQL编译器将语句发送到SQL子系统。</p>
                     </li>
                     <li>
                        <p>SQL子系统检查语句的语法。</p>
                        <p>如果语法不正确，PL / SQL单元的编译将失败。如果语法正确，SQL子系统将确定表的名称并尝试解析SQL语句范围内的其他名称。</p>
                     </li>
                     <li id="GUID-0D18B5E5-A6F7-45B7-A1FA-F7D930C6999C__BABIBAGB">
                        <p>如果SQL子系统无法解析SQL语句范围内的名称，则会将名称发送回PL / SQL编译器。该名称称为<span class="bold">转义标识符</span> 。
                        </p>
                     </li>
                     <li>
                        <p>PL / SQL编译器尝试解析转义的标识符。</p>
                        <p>首先，编译器尝试解析PL / SQL单元范围内的标识符。如果失败，编译器将尝试解析模式范围内的标识符。如果失败，则PL / SQL单元的编译失败。</p>
                     </li>
                     <li>
                        <p>如果PL / SQL单元的编译成功，PL / SQL编译器将生成与静态SQL语句等效的常规SQL语句的文本，并将该文本与生成的计算机代码一起存储。</p>
                     </li>
                     <li>
                        <p>在运行时，PL / SQL运行时系统调用解析，绑定和运行常规SQL语句的例程。</p>
                        <p>绑定变量是转义标识符（请参阅步骤<a href="plsql-name-resolution.html#GUID-0D18B5E5-A6F7-45B7-A1FA-F7D930C6999C__BABIBAGB">4</a> ）。
                        </p>
                     </li>
                     <li>
                        <p>如果语句是<code class="codeph">SELECT</code>语句，则PL / SQL运行时系统将结果存储在PL / SQL编译器在步骤<a href="plsql-name-resolution.html#GUID-0D18B5E5-A6F7-45B7-A1FA-F7D930C6999C__BABBAFCJ">1中</a>删除的<code class="codeph">INTO</code>子句中指定的PL / SQL目标中。
                        </p>
                     </li>
                  </ol>
                  <div class="infoboxnote" id="GUID-0D18B5E5-A6F7-45B7-A1FA-F7D930C6999C__GUID-0C4C36EC-E128-4EB3-8EF7-EAAECC3FE9FE">
                     <p class="notep1">注意：</p>
                     <p>可以按任何顺序评估绑定变量。如果程序确定评估顺序，那么在程序执行此操作时，其行为是不确定的。</p>
                  </div>
               </div>
            </div><a id="LNPLS2157"></a><a id="LNPLS01704"></a><div class="props_rev_3"><a id="GUID-6471F04B-7872-4D88-B72D-8B46448B29EB" name="GUID-6471F04B-7872-4D88-B72D-8B46448B29EB"></a><h3 id="LNPLS-GUID-6471F04B-7872-4D88-B72D-8B46448B29EB" class="sect3"><span class="enumeration_section">B.5</span>什么是捕获？
               </h3>
               <div>
                  <p>当声明或定义阻止编译器正确解析另一个作用域中的引用时，声明或定义将被<span class="bold">捕获</span>引用。捕获通常是迁移或模式演变的结果。
                  </p>
                  <div class="section">
                     <p class="subhead2" id="GUID-6471F04B-7872-4D88-B72D-8B46448B29EB__GUID-7A5A946F-8F74-43DB-91BF-BDA21D8C913E">话题</p>
                  </div>
                  <!-- class="section" -->
                  <div class="section">
                     <ul style="list-style-type:disc">
                        <li>
                           <p><a href="plsql-name-resolution.html#GUID-12F09346-24A6-43AF-8EBC-49A7CF4F231A">外部捕获</a></p>
                        </li>
                        <li>
                           <p><a href="plsql-name-resolution.html#GUID-4CACC18F-04DA-48C1-9EB9-7574E782EAF5">相同范围捕获</a></p>
                        </li>
                        <li>
                           <p><a href="plsql-name-resolution.html#GUID-2FB522D5-7042-4E37-BB52-44344839D876">内在捕获</a></p>
                        </li>
                     </ul>
                     <div class="infoboxnote" id="GUID-6471F04B-7872-4D88-B72D-8B46448B29EB__GUID-53DDA835-28B7-48CC-AD17-7D8F6A8FCBB6">
                        <p class="notep1">注意：</p>
                        <p>相同范围和内部捕获仅在SQL范围内发生。</p>
                     </div>
                  </div>
                  <!-- class="section" -->
               </div><a id="LNPLS1754"></a><div class="props_rev_3"><a id="GUID-12F09346-24A6-43AF-8EBC-49A7CF4F231A" name="GUID-12F09346-24A6-43AF-8EBC-49A7CF4F231A"></a><h4 id="LNPLS-GUID-12F09346-24A6-43AF-8EBC-49A7CF4F231A" class="sect4"><span class="enumeration_section">B.5.1</span>外部捕获</h4>
                  <div>
                     <p>当内部作用域中已解析为内部作用域中的项目的名称现在解析为外部作用域中的项目时，会发生<span class="bold">外部捕获</span> 。PL / SQL和SQL都旨在防止外部捕获;你不必小心避免它。
                     </p>
                  </div>
               </div><a id="LNPLS1753"></a><div class="props_rev_3"><a id="GUID-4CACC18F-04DA-48C1-9EB9-7574E782EAF5" name="GUID-4CACC18F-04DA-48C1-9EB9-7574E782EAF5"></a><h4 id="LNPLS-GUID-4CACC18F-04DA-48C1-9EB9-7574E782EAF5" class="sect4"><span class="enumeration_section">B.5.2</span>相同范围捕获</h4>
                  <div>
                     <p>将列添加到连接中使用的两个表之一时，会发生<span class="bold">相同范围捕获</span> ，并且新列与另一个表中的列具有相同的名称。当只有一个表具有该名称的列时，该名称可能出现在未加入限定的连接中。现在，为了避免相同范围的捕获，您必须使用适当的表名限定列名，列名出现在连接中的任何位置。
                     </p>
                  </div>
               </div><a id="LNPLS2158"></a><a id="LNPLS1752"></a><div class="props_rev_3"><a id="GUID-2FB522D5-7042-4E37-BB52-44344839D876" name="GUID-2FB522D5-7042-4E37-BB52-44344839D876"></a><h4 id="LNPLS-GUID-2FB522D5-7042-4E37-BB52-44344839D876" class="sect4"><span class="enumeration_section">B.5.3</span>内部捕获</h4>
                  <div>
                     <p>当内部作用域中已解析为外部作用域中的项目的名称现在解析为内部作用域中的项目或无法解析时，会发生<span class="bold">内部捕获</span> 。在第一种情况下，结果可能会改变。在第二种情况下，发生错误。
                     </p>
                     <p>在<a href="plsql-name-resolution.html#GUID-2FB522D5-7042-4E37-BB52-44344839D876__BABGHDAJ">示例B-6中</a> ，新列捕获对具有相同名称的旧列的引用。在将新列<code class="codeph">col2</code>添加到表<code class="codeph">tab2</code> ， <code class="codeph">col2</code>解析为<code class="codeph">tab1.col2</code> ;之后，它解析为<code class="codeph">tab2.col2</code> 。
                     </p>
                     <p>要避免内部捕获，请遵循<span class="q">“ <a href="plsql-name-resolution.html#GUID-5B50488D-CF48-4A77-BD75-96D62EDF4BBE">避免SELECT和DML语句中的内部捕获</a> ”中</span>的规则。
                     </p>
                     <div class="example" id="GUID-2FB522D5-7042-4E37-BB52-44344839D876__BABGHDAJ">
                        <p class="titleinexample">例B-6列参考的内部捕获</p>
                        <p>表<code class="codeph">tab1</code>有一个名为<code class="codeph">col2</code>的列，但表<code class="codeph">tab2</code>没有：</p><pre class="oac_no_warn" dir="ltr">DROP TABLE tab1; CREATE TABLE <span class="bold">tab1</span> （col1 NUMBER， <span class="bold">col2</span> NUMBER）; INSERT INTO tab1（col1，col2）VALUES（100,10）; DROP TABLE tab2; CREATE TABLE <span class="bold">tab2</span> （col1 NUMBER）; INSERT INTO tab2（col1）VALUES（100）;</pre><p>因此，在内部<code class="codeph">SELECT</code>语句中，对<code class="codeph">col2</code>的引用解析为列<code class="codeph">tab1.col2</code> ：</p><pre class="oac_no_warn" dir="ltr">创建或替换过程proc AUTHID DEFINER as CURSOR c1 IS SELECT * FROM tab1 WHERE EXISTS（ <span class="bold">SELECT * FROM tab2 WHERE col2 = 10</span> ）;开始打开c1;关闭c1;结束; /</pre><p>将名为<code class="codeph">col2</code>的列添加到表<code class="codeph">tab2</code> ：</p><pre class="oac_no_warn" dir="ltr">ALTER TABLE tab2 ADD（col2 NUMBER）;</pre><p>现在程序<code class="codeph">proc</code>无效。在下次调用时，数据库会自动重新编译它，内部<code class="codeph">SELECT</code>语句中对<code class="codeph">col2</code>的引用将解析为列<code class="codeph">tab2.col2</code> 。
                        </p>
                     </div>
                     <!-- class="example" -->
                  </div>
               </div>
            </div><a id="LNPLS2160"></a><a id="LNPLS2159"></a><a id="LNPLS01705"></a><div class="props_rev_3"><a id="GUID-5B50488D-CF48-4A77-BD75-96D62EDF4BBE" name="GUID-5B50488D-CF48-4A77-BD75-96D62EDF4BBE"></a><h3 id="LNPLS-GUID-5B50488D-CF48-4A77-BD75-96D62EDF4BBE" class="sect3"><span class="enumeration_section">B.6</span>避免SELECT和DML语句中的内部捕获</h3>
               <div>
                  <div class="section">
                     <p>遵循以下建议，避免在<code class="codeph">SELECT</code> ， <code class="codeph">SELECT</code> <code class="codeph">INTO</code>和DML语句中内部捕获引用：</p>
                  </div>
                  <!-- class="section" -->
                  <div class="section">
                     <ul style="list-style-type:disc">
                        <li>
                           <p>为语句中的每个表指定唯一别名。</p>
                        </li>
                        <li>
                           <p>不要指定一个表别名，该别名是拥有该语句中引用的项的模式的名称。</p>
                        </li>
                        <li>
                           <p>使用适当的表别名限定语句中的每个列引用。</p>
                        </li>
                     </ul>
                     <p>在<a href="plsql-name-resolution.html#GUID-5B50488D-CF48-4A77-BD75-96D62EDF4BBE__BABGIFBD">示例B-7中</a> ，模式<code class="codeph">hr</code>拥有表<code class="codeph">tab1</code>和<code class="codeph">tab2</code> 。表<code class="codeph">tab1</code>有一个名为<code class="codeph">tab2</code>的列，其抽象数据类型（ADT）具有属性<code class="codeph">a</code> 。表<code class="codeph">tab2</code>没有名为<code class="codeph">a</code>的列。根据建议，查询为表<code class="codeph">tab1</code>和引用表<code class="codeph">tab2</code>指定别名<code class="codeph">hr</code> 。因此，在查询中，引用<code class="codeph">hr.tab2.a</code>解析为表<code class="codeph">tab1</code> ，列<code class="codeph">tab2</code> ，属性<code class="codeph">a</code> 。然后，该示例将列<code class="codeph">a</code>添加到表<code class="codeph">tab2</code> 。现在查询中的引用<code class="codeph">hr.tab2.a</code>解析为模式<code class="codeph">hr</code> ，表<code class="codeph">tab2</code> ，列<code class="codeph">a</code> 。表<code class="codeph">tab2</code>列<code class="codeph">a</code>捕获表<code class="codeph">tab1</code>列<code class="codeph">tab2</code>中属性<code class="codeph">a</code>的引用。
                     </p>
                  </div>
                  <!-- class="section" -->
                  <div class="section">
                     <p class="subhead2" id="GUID-5B50488D-CF48-4A77-BD75-96D62EDF4BBE__GUID-F416694B-02C8-4610-9422-FF0074F4FCDA">话题</p>
                  </div>
                  <!-- class="section" -->
                  <div class="section">
                     <ul style="list-style-type:disc">
                        <li>
                           <p><a href="plsql-name-resolution.html#GUID-4E9FC578-F161-454E-BE4B-DE2AC43277CE">属性和方法的限定参考</a></p>
                        </li>
                        <li>
                           <p><a href="plsql-name-resolution.html#GUID-E052D320-D7F7-45EF-A577-3401776C478F">对行表达式的限定引用</a></p>
                        </li>
                     </ul>
                  </div>
                  <!-- class="section" -->
                  <div class="example" id="GUID-5B50488D-CF48-4A77-BD75-96D62EDF4BBE__BABGIFBD">
                     <p class="titleinexample">例B-7属性参考的内部捕获</p><pre class="oac_no_warn" dir="ltr">创建或替换<span class="bold">类型type1</span> AS OBJECT（ <span class="bold">一个</span>数字）; / DROP TABLE tab1; CREATE <span class="bold">TABLE tab1（tab2 type1）</span> ; INSERT INTO tab1（tab2）VALUES（type1（10））; DROP TABLE tab2; CREATE <span class="bold">TABLE tab2（x NUMBER）</span> ; INSERT INTO tab2（x）VALUES（10）; <span class="bold">/ * Alias tab1与模式名称同名，</span> <span class="bold">这里用于说明目的的不良做法。</span>
   <span class="bold">注意第二个SELECT语句中缺少别名。* /</span> SELECT * FROM tab1 <span class="bold">hr</span> WHERE EXISTS（SELECT * FROM <span class="bold">hr.tab2</span> WHERE x = <span class="bold">hr.tab2.a</span> ）;</pre><p>结果：</p><pre class="oac_no_warn" dir="ltr">TAB2（A）--------------- TYPE1（10）选择1行。
</pre><p>将一个名为<code class="codeph">a</code>的列添加到表<code class="codeph">tab2</code> （属于schema <code class="codeph">hr</code> ）：</p><pre class="oac_no_warn" dir="ltr">ALTER TABLE tab2 ADD（一个数字）;</pre><p>现在，当查询运行时， <code class="codeph">hr.tab2.a</code>解析为schema <code class="codeph">hr</code> ，table <code class="codeph">tab2</code> ， <code class="codeph">a</code>列。要避免此内部捕获，请将建议应用于查询：</p><pre class="oac_no_warn" dir="ltr">SELECT * FROM <span class="bold">hr。</span> TAB1 <span class="bold">P1</span> WHERE EXISTS（SELECT * FROM hr.tab2 <span class="bold">P2</span>其中<span class="bold">P2</span> X = <span class="bold">P1 <span class="bold">tab2.a）;</span></span></pre></div>
                  <!-- class="example" -->
               </div><a id="LNPLS2161"></a><a id="LNPLS1755"></a><div class="props_rev_3"><a id="GUID-4E9FC578-F161-454E-BE4B-DE2AC43277CE" name="GUID-4E9FC578-F161-454E-BE4B-DE2AC43277CE"></a><h4 id="LNPLS-GUID-4E9FC578-F161-454E-BE4B-DE2AC43277CE" class="sect4"><span class="enumeration_section">B.6.1</span>对属性和方法的<span class="enumeration_section">限定</span>参考</h4>
                  <div>
                     <div class="section">
                        <p>要引用表元素的属性或方法，必须为表提供别名，并使用别名限定对属性或方法的引用。</p>
                        <p>在<a href="plsql-name-resolution.html#GUID-4E9FC578-F161-454E-BE4B-DE2AC43277CE__BABFBEBJ">例B-8中</a> ，表<code class="codeph">tbl1</code>具有数据类型为<code class="codeph">t1</code>列<code class="codeph">col1</code> ，具有属性<code class="codeph">x</code>的ADT。该示例显示了对<code class="codeph">tbl1.col1.x</code>几个正确和不正确的引用。
                        </p>
                     </div>
                     <!-- class="section" -->
                     <div class="example" id="GUID-4E9FC578-F161-454E-BE4B-DE2AC43277CE__BABFBEBJ">
                        <p class="titleinexample">示例B-8限定ADT属性参考</p><pre class="oac_no_warn" dir="ltr">创建或替换类型t1作为对象（x NUMBER）; / DROP TABLE tb1; CREATE TABLE tb1（col1 t1）;</pre><p>以下<code class="codeph">INSERT</code>语句中的引用不需要别名，因为它们没有列列表：</p><pre class="oac_no_warn" dir="ltr">开始插入tb1值（t1（10））;插入tb1值（t1（20））;插入tb1值（t1（30））;结束; /</pre><p>以下对属性<code class="codeph">x</code>引用导致错误ORA-00904：</p><pre class="oac_no_warn" dir="ltr">UPDATE tb1 SET <span class="bold">col1.x</span> = 10 WHERE <span class="bold">col1.x</span> = 20; UPDATE tb1 SET <span class="bold">tb1.col1.x</span> = 10 WHERE <span class="bold">tb1.col1.x</span> = 20; UPDATE hr.tb1 SET <span class="bold">hr.tb1.col1.x</span> = 10 WHERE <span class="bold">hr.tb1.col1.x</span> = 20; DELETE FROM tb1 WHERE <span class="bold">tb1.col1.x</span> = 10;</pre><p>以下对具有表别名的属性<code class="codeph">x</code>引用是正确的：</p><pre class="oac_no_warn" dir="ltr">UPDATE hr.tb1 <span class="bold">t</span> SET <span class="bold">t.col1.x</span> = 10 WHERE <span class="bold">t.col1.x</span> = 20;否定数字; BEGIN SELECT <span class="bold">t.col1.x</span> INTO y FROM tb1 <span class="bold">t</span> WHERE <span class="bold">t.col1.x</span> = 30;结束; / DELETE FROM tb1 <span class="bold">t</span> WHERE <span class="bold">t.col1.x</span> = 10;</pre></div>
                     <!-- class="example" -->
                  </div>
               </div><a id="LNPLS2162"></a><a id="LNPLS1756"></a><div class="props_rev_3"><a id="GUID-E052D320-D7F7-45EF-A577-3401776C478F" name="GUID-E052D320-D7F7-45EF-A577-3401776C478F"></a><h4 id="LNPLS-GUID-E052D320-D7F7-45EF-A577-3401776C478F" class="sect4"><span class="enumeration_section">B.6.2</span>对行表达式的<span class="enumeration_section">限定</span>引用</h4>
                  <div>
                     <div class="section">
                        <p>行表达式必须解析为对表别名的引用。行表达式可以出现在<code class="codeph">UPDATE</code>语句的<code class="codeph">SET</code>子句中，也可以是SQL函数<code class="codeph">REF</code>或<code class="codeph">VALUE</code>的参数。</p>
                        <p>在<a href="plsql-name-resolution.html#GUID-E052D320-D7F7-45EF-A577-3401776C478F__BABICCCJ">例B-9中</a> ，表<code class="codeph">ot1</code>是数据类型为<code class="codeph">t1</code>的元素的独立嵌套表，属性为<code class="codeph">x</code>的ADT。该示例显示了对行表达式的几个正确和不正确的引用。
                        </p>
                     </div>
                     <!-- class="section" -->
                     <div class="example" id="GUID-E052D320-D7F7-45EF-A577-3401776C478F__BABICCCJ">
                        <p class="titleinexample">示例B-9对行表达式的限定引用</p><pre class="oac_no_warn" dir="ltr">创建或替换类型t1作为对象（x编号）; / DROP TABLE ot1;创建表ot1 OF t1;开始插入ot1 VALUES（t1（10））;插入ot1 VALUES（20）;插入ot1 VALUES（30）;结束; /</pre><p>以下引用导致错误ORA-00904：</p><pre class="oac_no_warn" dir="ltr">UPDATE ot1 SET VALUE（ <span class="bold">ot1.x</span> ）= t1（20）WHERE VALUE（ <span class="bold">ot1.x</span> ）= t1（10）; DELETE FROM ot1 WHERE VALUE（ <span class="bold">ot1</span> ）=（t1（10））;</pre><p>以下带有表别名的引用是正确的：</p><pre class="oac_no_warn" dir="ltr">UPDATE ot1 <span class="bold">o</span> SET <span class="bold">o</span> =（t1（20））WHERE <span class="bold">ox</span> = 10; DECLARE n_ref REF t1; BEGIN SELECT REF（ <span class="bold">o</span> ）INTO n_ref FROM ot1 <span class="bold">o</span> WHERE VALUE（ <span class="bold">o</span> ）= t1（30）;结束; / DECLARE n t1; BEGIN SELECT VALUE（ <span class="bold">o</span> ）INTO n FROM ot1 <span class="bold">o</span> WHERE VALUE（ <span class="bold">o</span> ）= t1（30）;结束; / DECLARE n NUMBER; BEGIN SELECT <span class="bold">ox</span> INTO n FROM ot1 <span class="bold">o</span> WHERE <span class="bold">ox</span> = 30;结束; / DELETE FROM ot1 <span class="bold">o</span> WHERE VALUE（ <span class="bold">o</span> ）=（t1（20））;</pre></div>
                     <!-- class="example" -->
                  </div>
               </div>
            </div>
         </div>
      </article>
   </body>
</html>