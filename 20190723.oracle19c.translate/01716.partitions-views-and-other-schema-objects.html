<html lang="en-us" dir="ltr" xml:lang="en-us">
   <head>
      <meta http-equiv="Content-Type" content="text/html; charset=utf-8"></meta>
      <meta name="viewport" content="width=device-width, initial-scale=1"></meta>
      <meta http-equiv="X-UA-Compatible" content="IE=edge"></meta>
      <meta name="abstract" content="Although tables and indexes are the most important and commonly used schema objects, the database supports many other types of schema objects, the most common of which are discussed in this chapter."></meta>
      <meta name="description" content="Although tables and indexes are the most important and commonly used schema objects, the database supports many other types of schema objects, the most common of which are discussed in this chapter."></meta>
      <title>分区，视图和其他架构对象</title>
      <meta property="og:site_name" content="Oracle Help Center"></meta>
      <meta property="og:title" content="Database Concepts"></meta>
      <meta property="og:description" content="Although tables and indexes are the most important and commonly used schema objects, the database supports many other types of schema objects, the most common of which are discussed in this chapter."></meta>
      <link rel="stylesheet" href="/sp_common/book-template/ohc-book-template/css/book.css"></link>
      <link rel="shortcut icon" href="/sp_common/book-template/ohc-common/img/favicon.ico"></link>
      <meta name="application-name" content="Database Concepts"></meta>
      <meta name="generator" content="DITA Open Toolkit version 1.8.5 (Mode = doc)"></meta>
      <meta name="plugin" content="SP_docbuilder HTML plugin release 18.2.2"></meta>
      <link rel="alternate" href="database-concepts.pdf" title="PDF File" type="application/pdf"></link>
      <meta name="robots" content="all"></meta>
      <link rel="schema.dcterms" href="http://purl.org/dc/terms/"></link>
      <meta name="dcterms.created" content="2019-01-09T07:47:16-08:00"></meta>
      <meta name="dcterms.title" content="Database Concepts"></meta>
      <meta name="dcterms.dateCopyrighted" content="1993, 2019"></meta>
      <meta name="dcterms.category" content="database"></meta>
      <meta name="dcterms.identifier" content="E96138-01"></meta>
      
      <meta name="dcterms.product" content="en/database/oracle/oracle-database/19"></meta>
      
      <link rel="prev" href="indexes-and-index-organized-tables.html" title="Previous" type="text/html"></link>
      <link rel="next" href="data-integrity.html" title="Next" type="text/html"></link>
      <script>
        document.write('<style type="text/css">');
        document.write('body > .noscript, body > .noscript ~ * { visibility: hidden; }');
        document.write('</style>');
     </script>
      <script src="/sp_common/book-template/requirejs/require.js" data-main="/sp_common/book-template/ohc-book-template/js/book-config"></script>
      <script>
            if (window.require === undefined) {
                document.write('<script data-main="sp_common/book-template/ohc-book-template/js/book-config" src="sp_common/book-template/requirejs/require.js"><\/script>');
                document.write('<link href="sp_common/book-template/ohc-book-template/css/book.css" rel="stylesheet"/>');
            }
        </script>
      <script type="application/json" id="ssot-metadata">{"primary":{"category":{"short_name":"database","element_name":"Database","display_in_url":true},"suite":{"short_name":"oracle","element_name":"Oracle","display_in_url":true},"product_group":{"short_name":"not-applicable","element_name":"Not applicable","display_in_url":false},"product":{"short_name":"oracle-database","element_name":"Oracle Database","display_in_url":true},"release":{"short_name":"19","element_name":"Release 19","display_in_url":true}}}</script>
      
    <meta name="dcterms.isVersionOf" content="CNCPT"></meta>
    <meta name="dcterms.release" content="Release 19"></meta>
  </head>
   <body dir="ltr">
      <div class="noscript alert alert-danger text-center" role="alert">
         <a href="indexes-and-index-organized-tables.html" class="pull-left"><span class="glyphicon glyphicon-chevron-left" aria-hidden="true"></span>上一页</a> <a href="data-integrity.html" class="pull-right">下一页<span class="glyphicon glyphicon-chevron-right" aria-hidden="true"></span></a> <span class="fa fa-exclamation-triangle" aria-hidden="true"></span>必须启用JavaScript才能正确显示此内容</div>
      <article>
         <header>
            <ol class="breadcrumb" vocab="http://schema.org/" typeof="BreadcrumbList">
               <li property="itemListElement" typeof="ListItem"><a href="index.html" property="item" typeof="WebPage"><span property="name">数据库概念</span></a></li>
               <li property="itemListElement" typeof="ListItem"><a href="oracle-relational-structures.html" property="item" typeof="WebPage"><span property="name">Oracle关系数据结构</span></a></li>
               <li class="active" property="itemListElement" typeof="ListItem">分区，视图和其他架构对象</li>
            </ol>
            <a id="GUID-3E154566-50D6-48C1-BAE5-57EF20266B43" name="GUID-3E154566-50D6-48C1-BAE5-57EF20266B43"></a><a id="CNCPT88858"></a>
            
            <h2 id="CNCPT-GUID-3E154566-50D6-48C1-BAE5-57EF20266B43" class="sect2"><span class="enumeration_chapter">4</span>分区，视图和其他模式对象</h2>
         </header>
         <div class="ind">
            <div>
               <p>虽然表和索引是最重要和最常用的模式对象，但数据库支持许多其他类型的模式对象，本章将讨论最常见的模式对象。</p>
               <p>本章包含以下部分：</p>
               <ul style="list-style-type:disc">
                  <li>
                     <p><a href="partitions-views-and-other-schema-objects.html#GUID-91498562-1809-4E67-B7AD-9718ED60DEFF" title="在Oracle数据库中，分区使您能够将非常大的表和索引分解为更小且更易于管理的分区。每个分区都是一个独立的对象，它有自己的名称和可选的自己的存储特性。">分区概述</a></p>
                  </li>
                  <li>
                     <p><a href="partitions-views-and-other-schema-objects.html#GUID-4C8C435A-4CB0-4094-A77C-5AD4737BBB16" title="在Oracle数据库中，分片使您可以将大型表拆分为更易于管理的部分，称为分片，可以存储在多个数据库中。">分片表概述</a></p>
                  </li>
                  <li>
                     <p><a href="partitions-views-and-other-schema-objects.html#GUID-15E7AEDB-9A3F-4B31-AD2D-66253CC822E5" title="视图是一个或多个表的逻辑表示。实质上，视图是存储的查询。">视图概述</a></p>
                  </li>
                  <li>
                     <p><a href="partitions-views-and-other-schema-objects.html#GUID-2822B62B-CAF3-4DCE-B4D6-5E677FB8A829" title="物化视图是已存储的查询结果或" name="" materialize="=" ="">物化视图概述</a></p>
                  </li>
                  <li>
                     <p><a href="partitions-views-and-other-schema-objects.html#GUID-29E19A46-D91F-4EEB-BD0C-E65A89F2F59B" title="序列是一个架构对象，多个用户可以从中生成唯一的整数。序列生成器提供高度可伸缩且性能良好的方法，以生成数字数据类型的代理键。">序列概述</a></p>
                  </li>
                  <li>
                     <p><a href="partitions-views-and-other-schema-objects.html#GUID-84D64C39-D8E8-4706-B4E3-519FE2CEE4C2" title="典型的数据仓库有两个重要组件：维度和事实。">尺寸概述</a></p>
                  </li>
                  <li>
                     <p><a href="partitions-views-and-other-schema-objects.html#GUID-4977D7F8-B766-4F4A-8FF6-B8496DED3DF2" title="同义词是架构对象的别名。例如，您可以为表或视图，序列，PL / SQL程序单元，用户定义的对象类型或其他同义词创建同义词。因为同义词只是一个别名，所以除了数据字典中的定义之外，它不需要存储。">同义词概述</a></p>
                  </li>
               </ul>
            </div><a id="CNCPT112"></a><div class="props_rev_3"><a id="GUID-91498562-1809-4E67-B7AD-9718ED60DEFF" name="GUID-91498562-1809-4E67-B7AD-9718ED60DEFF"></a><h3 id="CNCPT-GUID-91498562-1809-4E67-B7AD-9718ED60DEFF" class="sect3">分区概述</h3>
               <div>
                  <p>在Oracle数据库中， <span class="bold">分区</span>使您能够将非常大的表和索引分解为更小且更易于管理的<span class="bold">分区</span> 。每个分区都是一个独立的对象，它有自己的名称和可选的自己的存储特性。
                  </p>
                  <p>对于说明分区的类比，假设HR经理有一个包含员工文件夹的大框。每个文件夹列出员工的雇用日期。通常会针对特定月份雇用的员工进行查询。满足此类请求的一种方法是创建雇员雇用日期的索引，该索引指定分散在整个框中的文件夹的位置。相比之下，分区策略使用许多较小的盒子，每个盒子包含在给定月份雇用的员工的文件夹。</p>
                  <p>使用较小的盒子有几个优点。当被要求为6月份雇用的员工检索文件夹时，人力资源经理可以检索6月份的框。此外，如果任何小盒子暂时损坏，其他小盒子仍然可用。移动办公室也变得更容易，因为经理可以移动几个小盒子而不是移动一个重箱子。</p>
                  <p>从应用程序的角度来看，只存在一个模式对象。SQL语句不需要修改即可访问分区表。分区对许多不同类型的数据库应用程序很有用，特别是那些管理大量数据的应用程序。好处包括：</p>
                  <ul style="list-style-type:disc">
                     <li>
                        <p>提高可用性</p>
                        <p>分区的不可用性不会导致对象不可用。查询<a href="glossary.html#GUID-54114749-0A81-41D7-8E16-7B76D93CEE2B"><span class="xrefglossterm">优化器会</span></a>自动从<a href="glossary.html#GUID-78BCF1CD-1865-4AEB-8F14-AFA4FF1981BF"><span class="xrefglossterm">查询计划中</span></a>删除未引用的分区，以便在分区不可用时查询不受影响。
                        </p>
                     </li>
                     <li>
                        <p>更轻松地管理模式对象</p>
                        <p>分区对象具有可以集体或单独管理的片段。<a href="glossary.html#GUID-64F19D78-A73F-44A5-AA2E-60EBC800CB22"><span class="xrefglossterm">DDL</span></a>语句可以操作分区而不是整个表或索引。因此，您可以分解资源密集型任务，例如重建索引或表。例如，您可以一次移动一个表分区。如果出现问题，则只需重做分区移动，而不是表移动。此外，删除分区可避免执行大量<code class="codeph">DELETE</code>语句。
                        </p>
                     </li>
                     <li>
                        <p>减少<a href="glossary.html#GUID-709E943F-FF0E-4AA6-979A-C4CB2A7B0C29"><span class="xrefglossterm">OLTP</span></a>系统中共享资源的争用</p>
                        <p>在某些OLTP系统中，分区可以减少对共享资源的争用。例如，DML分布在许多段而不是一个段上。</p>
                     </li>
                     <li>
                        <p>增强了数据仓库中的查询性能</p>
                        <p>在<a href="glossary.html#GUID-0881E18F-D245-4980-8272-64964B64E3CC"><span class="xrefglossterm">数据仓库中</span></a> ，分区可以加快即席查询的处理速度。例如，包含一百万行的销售表可以按季度进行分区。
                        </p>
                     </li>
                  </ul>
                  <div class="infoboxnotealso" id="GUID-91498562-1809-4E67-B7AD-9718ED60DEFF__GUID-1B96F7A7-B650-46B5-81B1-85980E541F0C">
                     <p class="notep1">也可以看看：</p>
                     <p><a href="../vldbg/partition-intro.html#VLDBG00101" target="_blank"><span><cite>“Oracle数据库VLDB和分区指南”</cite></span></a> ，介绍分区</p>
                  </div>
               </div><a id="CNCPT88859"></a><div class="props_rev_3"><a id="GUID-E3C5EDAA-01F2-4077-915E-133045C43095" name="GUID-E3C5EDAA-01F2-4077-915E-133045C43095"></a><h4 id="CNCPT-GUID-E3C5EDAA-01F2-4077-915E-133045C43095" class="sect4">分区特征</h4>
                  <div>
                     <p>表或索引的每个分区必须具有相同的逻辑属性，例如列名，数据类型和约束。</p>
                     <p>例如，表中的所有分区共享相同的列和约束定义。但是，每个分区可以具有单独的物理属性，例如它所属的表空间。</p>
                  </div><a id="CNCPT1512"></a><div class="props_rev_3"><a id="GUID-B854D440-23E4-4374-8EC8-AE6D0BBC390D" name="GUID-B854D440-23E4-4374-8EC8-AE6D0BBC390D"></a><h5 id="CNCPT-GUID-B854D440-23E4-4374-8EC8-AE6D0BBC390D" class="sect5">分区键</h5>
                     <div>
                        <p><span class="bold">分区键</span>是一组一列或多列，用于确定分区表中每行应该到达的分区。每行明确地分配给单个分区。
                        </p>
                        <p>在<code class="codeph">sales</code>表中，您可以将<code class="codeph">time_id</code>列指定为范围分区的键。数据库根据此列中的日期是否落在指定范围内，将行分配给分区。Oracle数据库使用分区键自动将插入，更新和删除操作定向到相应的分区。
                        </p>
                     </div>
                  </div><a id="CNCPT1911"></a><div class="props_rev_3"><a id="GUID-D3245D07-22AF-4F96-8F87-E70CF7A67914" name="GUID-D3245D07-22AF-4F96-8F87-E70CF7A67914"></a><h5 id="CNCPT-GUID-D3245D07-22AF-4F96-8F87-E70CF7A67914" class="sect5">分区策略</h5>
                     <div>
                        <p>Oracle Partitioning提供了几种分区策略，用于控制数据库如何将数据放入分区。基本策略是范围，列表和散列分区。</p>
                        <p><a href="glossary.html#GUID-33A45DE7-008D-4724-9BCC-9CEA6ED95337"><span class="xrefglossterm">单级分区</span></a>仅使用一种数据分发方法，例如，仅列出分区或仅进行范围分区。在<a href="glossary.html#GUID-2CBB2535-77AE-43F7-97C9-5AB9543A4742"><span class="xrefglossterm">复合分区中</span></a> ，通过一种数据分配方法对表进行分区，然后使用第二种数据分配方法将每个分区进一步划分为子分区。例如，您可以为<code class="codeph">channel_id</code>使用列表分区，为<code class="codeph">time_id</code>使用范围子分区。
                        </p>
                        <div class="example" id="GUID-D3245D07-22AF-4F96-8F87-E70CF7A67914__BABCHIID">
                           <p class="titleinexample">示例4-1分区表的样本行集</p>
                           <p>此分区示例假定您要使用以下行填充分区表<code class="codeph">sales</code> ：</p><pre class="pre codeblock"><code>PROD_ID CUST_ID TIME_ID CHANNEL_ID PROMO_ID QUANTITY_SOLD AMOUNT_SOLD ---------- ---------- --------- ---------- ---- ------ ------------- ----------- 116 11393 05-JUN-99 2 999 1 12.18 40 100530 30-NOV-98 9 33 1 44.99 118 133 06-JUN-01 2 999 1 17.12 133 9450 01-DEC-00 2 999 1 31.28 36 4523 27-JAN-99 3 999 1 53.89 125 9417 04-FEB-98 3 999 1 16.86 30 170 23- FEB-01 2 999 1 8.8 24 11899 26-JUN-99 4 999 1 43.04 35 2606 17-FEB-00 3 999 1 54.94 45 9491 28-AUG-98 4 350 1 47.45</code></pre></div>
                        <!-- class="example" -->
                     </div><a id="CNCPT89159"></a><a id="CNCPT89158"></a><a id="CNCPT88860"></a><a id="CNCPT88862"></a><div class="props_rev_3"><a id="GUID-BF8A8838-DA69-4872-A42A-0C64FA3BD967" name="GUID-BF8A8838-DA69-4872-A42A-0C64FA3BD967"></a><h6 id="CNCPT-GUID-BF8A8838-DA69-4872-A42A-0C64FA3BD967" class="sect6">范围分区</h6>
                        <div>
                           <p>在<span class="bold">范围分区中</span> ，数据库根据分区键的值范围将行映射到分区。范围分区是最常见的分区类型，通常与日期一起使用。
                           </p>
                           <p>假设您创建<code class="codeph">time_range_sales</code>使用下面的SQL语句为分区表，与<code class="codeph">time_id</code>列作为分区键：</p><pre class="oac_no_warn" dir="ltr">CREATE TABLE time_range_sales（prod_id NUMBER（6），cust_id NUMBER， <span class="bold">time_id</span> DATE，channel_id CHAR（1），promo_id NUMBER（6），quantity_sold NUMBER（3），amount_sold NUMBER（10,2））PARTITION BY RANGE（ <span class="bold">time_id</span> ）（PARTITION SALES_1998价值低于（截止日期（'01 -JAN-1999'，'DD-MON-YYYY'）），PARTITION SALES_1999价值不到（截至_（01 -JAN-2000'，'DD-MON-YYYY'）） ，PARTITION SALES_2000价值低于（截止日期（'01 -JAN-2001'，'DD-MON-YYYY'）），PARTITION SALES_2001价值低于（MAXVALUE））;</pre><p>然后，使用<a href="partitions-views-and-other-schema-objects.html#GUID-D3245D07-22AF-4F96-8F87-E70CF7A67914__BABCHIID">示例4-1中</a>的行加载<code class="codeph">time_range_sales</code> 。代码显示了四个分区中的行分布。数据库根据<code class="codeph">PARTITION BY RANGE</code>子句中指定的规则，根据<code class="codeph">time_id</code>值为每行选择分区。范围分区键值确定指定分区的非包含性上限。
                           </p>
                        </div>
                     </div>
                     <div class="sect5"><a id="GUID-385857B7-3AEF-48DD-A965-3CBD2A18E5C3" name="GUID-385857B7-3AEF-48DD-A965-3CBD2A18E5C3"></a><h6 id="CNCPT-GUID-385857B7-3AEF-48DD-A965-3CBD2A18E5C3" class="sect6">区间分区</h6>
                        <div>
                           <p><strong class="term">区间分区</strong>是范围分区的扩展。
                           </p>
                           <p>如果插入的数据超出现有范围分区，则Oracle数据库会自动创建指定时间间隔的分区。例如，您可以创建一个销售历史记录表，用于在单独的分区中存储每个月的数据。</p>
                           <p>间隔分区使您可以避免显式创建范围分区。您可以对范围分区的每个表使用间隔分区，并对新分区使用固定间隔。除非您创建具有不同间隔的范围分区，或者除非始终设置特定分区属性，否则请考虑使用间隔分区。</p>
                           <p>按间隔分区时，必须至少指定一个范围分区。范围分区键值确定范围分区的高值，称为<a href="glossary.html#GUID-B22E1450-CB82-4771-ACF3-0243C4748951"><span class="xrefglossterm">转换点</span></a> 。数据库会自动为值超出转换点的数据创建间隔分区。每个间隔分区的下边界是前一个范围或间隔分区的包含上边界。因此，在<a href="partitions-views-and-other-schema-objects.html#GUID-385857B7-3AEF-48DD-A965-3CBD2A18E5C3__GUID-20408ADA-536A-4812-A4D2-14008BE09D3A">示例4-2中</a> ，值<code class="codeph">01-JAN-2011</code>在分区<code class="codeph">p2</code> 。
                           </p>
                           <p>数据库为转换点之外的数据创建间隔分区。<a href="glossary.html#GUID-553D825F-C025-4BA5-80F3-86BBC6047B03"><span class="xrefglossterm">间隔分区</span></a>通过指示数据库创建指定范围或间隔的<a href="glossary.html#GUID-553D825F-C025-4BA5-80F3-86BBC6047B03"><span class="xrefglossterm">分区来</span></a>扩展范围分区。当插入表中的数据超过所有现有范围分区时，数据库会自动创建分区。在<a href="partitions-views-and-other-schema-objects.html#GUID-385857B7-3AEF-48DD-A965-3CBD2A18E5C3__GUID-20408ADA-536A-4812-A4D2-14008BE09D3A">示例4-2中</a> ， <code class="codeph">p3</code>分区包含分区键<code class="codeph">time_id</code>值大于或等于<code class="codeph">01-JAN-2013</code> 。
                           </p>
                           <div class="example" id="GUID-385857B7-3AEF-48DD-A965-3CBD2A18E5C3__GUID-20408ADA-536A-4812-A4D2-14008BE09D3A">
                              <p class="titleinexample">例4-2间隔分区</p>
                              <p>假设您创建了一个包含四个宽度不同的分区的销售表。您指定在2013年1月1日的转换点之上，数据库应该以一个月的间隔创建分区。分区<code class="codeph">p3</code>上限表示转变点。分区<code class="codeph">p3</code>和它下面的所有分区都在范围部分中，而它上面的所有分区都属于区间部分。
                              </p><pre class="pre codeblock"><code>CREATE TABLE interval_sales（prod_id NUMBER（6），cust_id NUMBER，time_id DATE，channel_id CHAR（1），promo_id NUMBER（6），quantity_sold NUMBER（3），amount_sold NUMBER（10,2））PARTITION BY RANGE（time_id）INTERVAL（ NUMTOYMINTERVAL（1，'月'））（分区p0值小于（7月1日（'1-1-2010'，'DD-MM-YYYY'）），分区p1值小于（2011年1月1日） '，'DD-MM-YYYY'）），分区p2值少于（截止日期（'1-7-2012'，'DD-MM-YYYY'）），分区p3值少于（7月1日（'1-1） -2013'，'DD-MM-YYYY'）））;</code></pre><p>您插入了2014年10月10日的销售：</p><pre class="pre codeblock"><code>SQL&gt; INSERT INTO interval_sales VALUES（39,7602，'10 -OCT-14'，9，null，1,11.79）;已创建1行。
</code></pre><p><code class="codeph">USER_TAB_PARTITIONS</code>的查询显示数据库为10月10日的销售创建了一个新分区，因为销售日期晚于转换点：</p><pre class="pre codeblock"><code>SQL&gt; COL PNAME FORMAT a9 SQL&gt; COL HIGH_VALUE FORMAT a40 SQL&gt; SELECT PARTITION_NAME AS PNAME，HIGH_VALUE 2来自USER_TAB_PARTITIONS，其中TABLE_NAME ='INTERVAL_SALES'; PNAME HIGH_VALUE --------- --------------------------------------- -  P0至DATE（'2007-01-01 00:00:00'，'SYYYY-M M-DD HH24：MI：SS'，'NLS_CALENDAR = GREGORIA P1至_DATE（'2008-01-01 00:00:00' ，'SYYYY-M M-DD HH24：MI：SS'，'NLS_CALENDAR = GREGORIA P2至_DATE（'2009-07-01 00:00:00'，'SYYYY-M M-DD HH24：MI：SS'，' NLS_CALENDAR = GREGORIA P3 TO_DATE（'2010-01-01 00:00:00'，'SYYYY-M M-DD HH24：MI：SS'，'NLS_CALENDAR = GREGORIA SYS_P1598 TO_DATE（'2014-11-01 00:00： 00'，'SYYYY-M M-DD HH24：MI：SS'，'NLS_CALENDAR = GREGORIA</code></pre><div class="infoboxnotealso" id="GUID-385857B7-3AEF-48DD-A965-3CBD2A18E5C3__GUID-7364EE52-2AAC-416C-A74A-853597F5E979">
                                 <p class="notep1">也可以看看：</p>
                                 <p><a href="../vldbg/partition-concepts.html#VLDBG-GUID-C121EA1B-2725-4464-B2C9-EEDE0C3C95AB" target="_blank"><span><cite>Oracle Database VLDB和分区指南</cite></span></a>了解有关间隔分区的更多信息</p>
                              </div>
                           </div>
                           <!-- class="example" -->
                        </div>
                     </div><a id="CNCPT89161"></a><a id="CNCPT89160"></a><a id="CNCPT88863"></a><div class="props_rev_3"><a id="GUID-B8381DAE-3187-4137-9A07-065A3F40E881" name="GUID-B8381DAE-3187-4137-9A07-065A3F40E881"></a><h6 id="CNCPT-GUID-B8381DAE-3187-4137-9A07-065A3F40E881" class="sect6">列表分区</h6>
                        <div>
                           <p>在<strong class="term">列表分区中</strong> ，数据库使用离散值列表作为每个分区的分区键。分区键由一列或多列组成。
                           </p>
                           <p>您可以使用列表分区来控制各个行如何映射到特定分区。通过使用列表，您可以在不方便地订购用于识别它们的密钥时对相关数据集进行分组和组织。</p>
                           <div class="example" id="GUID-B8381DAE-3187-4137-9A07-065A3F40E881__GUID-51254A5F-3F1A-458C-B616-A799C865B973">
                              <p class="titleinexample">示例4-3列表分区</p>
                              <p>假设您使用以下语句将<code class="codeph">list_sales</code>创建为列表分区表，其中<code class="codeph">channel_id</code>列是分区键：</p><pre class="pre codeblock"><code>CREATE TABLE list_sales（prod_id NUMBER（6），cust_id NUMBER，time_id DATE， <span class="bold">channel_id</span> CHAR（1），promo_id NUMBER（6），quantity_sold NUMBER（3），amount_sold NUMBER（10,2））PARTITION BY LIST（ <span class="bold">channel_id</span> ）（PARTITION even_channels VALUES（'2'，'4'），PARTITION odd_channels VALUES（'3'，'9'））;</code></pre><p>然后，使用<a href="partitions-views-and-other-schema-objects.html#GUID-D3245D07-22AF-4F96-8F87-E70CF7A67914__BABCHIID">例4-1中</a>的行加载表。该代码显示了两个分区中的行分布。数据库根据<code class="codeph">PARTITION BY LIST</code>子句中指定的规则，根据<code class="codeph">channel_id</code>值为每行选择分区。<code class="codeph">channel_id</code>值为2或4的行存储在<code class="codeph">EVEN_CHANNELS</code>分区中，而<code class="codeph">channel_id</code>值为3或9的行存储在<code class="codeph">ODD_CHANNELS</code>分区中。
                              </p>
                           </div>
                           <!-- class="example" -->
                        </div>
                     </div><a id="CNCPT89163"></a><a id="CNCPT89162"></a><a id="CNCPT88864"></a><div class="props_rev_3"><a id="GUID-4BF963D2-948F-45C5-B015-B5E329A513D0" name="GUID-4BF963D2-948F-45C5-B015-B5E329A513D0"></a><h6 id="CNCPT-GUID-4BF963D2-948F-45C5-B015-B5E329A513D0" class="sect6">哈希分区</h6>
                        <div>
                           <p>在<span class="bold">散列分区中</span> ，数据库根据数据库应用于用户指定的分区键的散列算法将行映射到分区。
                           </p>
                           <p>行的目标由数据库应用于行的内部<a href="glossary.html#GUID-DDDDC4BC-ADB8-40D7-9733-60CED8E4A83E"><span class="xrefglossterm">哈希函数</span></a>确定。当分区数为2的幂时，散列算法会在所有分区上创建大致均匀的行分布。
                           </p>
                           <p>散列分区对于划分大表以提高可管理性非常有用。而不是一个大表来管理，你有几个较小的部分。丢失单个散列分区不会影响剩余的分区，可以单独恢复。散列分区在具有高更新争用的<a href="glossary.html#GUID-709E943F-FF0E-4AA6-979A-C4CB2A7B0C29"><span class="xrefglossterm">OLTP</span></a>系统中也很有用。例如，一个段被分成几个部分，每个部分都被更新，而不是经历争用的单个部分。
                           </p>
                           <p>假设您使用以下语句创建分区的<code class="codeph">hash_sales</code>表，并将<code class="codeph">prod_id</code>列作为分区键：</p><pre class="pre codeblock"><code>CREATE TABLE hash_sales（ <span class="bold">prod_id</span> NUMBER（6），cust_id NUMBER，time_id DATE，channel_id CHAR（1），promo_id NUMBER（6），quantity_sold NUMBER（3），amount_sold NUMBER（10,2））PARASHTION BY HASH（ <span class="bold">prod_id</span> ）PARTITIONS 2 ;</code></pre><p>然后，使用<a href="partitions-views-and-other-schema-objects.html#GUID-D3245D07-22AF-4F96-8F87-E70CF7A67914__BABCHIID">例4-1中</a>的行加载表。该代码显示了两个分区中可能的行分布。这些分区的名称是系统生成的。
                           </p>
                           <p>在插入行时，数据库会尝试在分区之间随机均匀地分布它们。您无法指定放置行的分区。数据库应用哈希函数，其结果确定哪个分区包含该行。</p>
                           <div class="infoboxnotealso" id="GUID-4BF963D2-948F-45C5-B015-B5E329A513D0__GUID-1CA60423-2800-4131-A8EC-68CB612BA4CF">
                              <p class="notep1">也可以看看：</p>
                              <ul style="list-style-type:disc">
                                 <li>
                                    <p><a href="../vldbg/partition-admin.html#VLDBG003" target="_blank"><span><cite>Oracle Database VLDB和分区指南</cite></span></a> ，了解如何创建分区</p>
                                 </li>
                                 <li>
                                    <p>用于<code class="codeph">CREATE TABLE ... <a href="../sqlrf/CREATE-TABLE.html#SQLRF54655" target="_blank"><span><cite>Oracle数据库SQL语言参考</cite></span></a> <code class="codeph">CREATE TABLE ...PARTITION BY</code>例子</p>
                                 </li>
                              </ul>
                           </div>
                        </div>
                     </div>
                     <div class="sect5"><a id="GUID-DAE08807-4819-47C9-8105-3BE3F5FFA75A" name="GUID-DAE08807-4819-47C9-8105-3BE3F5FFA75A"></a><h6 id="CNCPT-GUID-DAE08807-4819-47C9-8105-3BE3F5FFA75A" class="sect6">参考分区</h6>
                        <div>
                           <p>在<span class="bold">引用分区中</span> ，子表的分区策略仅通过与父表的外键关系来定义。对于父表中的每个分区，子表中只存在一个对应的分区。父表将父记录存储在特定分区中，子表将子记录存储在相应的分区中。
                           </p>
                           <p>例如， <code class="codeph">orders</code>表是<code class="codeph">line_items</code>表的父<code class="codeph">line_items</code> ，其中主键和外键在<code class="codeph">order_id</code>定义。表格按引用分区。例如，如果数据库存储在分区订购233 <code class="codeph">Q3_2015</code>的<code class="codeph">orders</code> ，那么数据库中存储的所有行项目在分区顺序233 <code class="codeph">Q3_2015</code>的<code class="codeph">line_items</code> 。如果将分区<code class="codeph">Q4_2015</code>添加到<code class="codeph">orders</code> ，则数据库会自动将<code class="codeph">Q4_2015</code>添加到<code class="codeph">line_items</code> 。
                           </p>
                           <p>引用分区的优点是：</p>
                           <ul style="list-style-type:disc">
                              <li>
                                 <p>通过对父表和子表使用相同的分区策略，可以避免重复所有分区键列。该策略减少了非规范化的手动开销，并节省了空间。</p>
                              </li>
                              <li>
                                 <p>父表上的维护操作自动发生在子表上。例如，将分区添加到主表时，数据库会自动将此添加内容传播到其后代。</p>
                              </li>
                              <li>
                                 <p>数据库自动使用父表和子表中分区的分区连接，从而提高性能。</p>
                              </li>
                           </ul>
                           <p>您可以将引用分区与所有基本分区策略一起使用，包括间隔分区。您还可以将引用分区表创建为复合分区表。</p>
                           <div class="example" id="GUID-DAE08807-4819-47C9-8105-3BE3F5FFA75A__GUID-48EA96F9-0B6B-414E-9BF3-DF2541442AFF">
                              <p class="titleinexample">示例4-4创建参考分区表</p>
                              <p>此示例创建一个在<code class="codeph">order_date</code>上进行范围分区的父表订单。使用四个分区<code class="codeph">Q1_2015</code> ， <code class="codeph">Q2_2015</code> ， <code class="codeph">Q3_2015</code>和<code class="codeph">Q4_2015</code>创建<code class="codeph">order_items</code>分区子表<code class="codeph">order_items</code> ，其中每个分区包含与相应父分区中的订单相对应的<code class="codeph">order_items</code>行。
                              </p><pre class="pre codeblock"><code>CREATE TABLE订单（order_id NUMBER（12），order_date DATE，order_mode VARCHAR2（8），customer_id NUMBER（6），order_status NUMBER（2），order_total NUMBER（8,2），sales_rep_id NUMBER（6），promotion_id NUMBER（6） ，CONSTRAINT orders_pk PRIMARY KEY（order_id））按范围划分（order_date）（PARTITION Q1_2015价值低于（截止日期（'01-APR-2015'，'DD-MON-YYYY'）），分区Q2_2015价值低于（截至4月） '01 -JUL-2015'，'DD-MON-YYYY'）），分段Q3_2015价值不到（截止日期（'01 -OCT-2015'，'DD-MON-YYYY'）），分区Q4_2015价值低于（ TO_DATE（'01 -JAN-2006'，'DD-MON-YYYY'）））; CREATE TABLE order_items（order_id NUMBER（12）NOT NULL，line_item_id NUMBER（3）NOT NULL，product_id NUMBER（6）NOT NULL，unit_price NUMBER（8,2），Quantity NUMBER（8），CONSTRAINT order_items_fk FOREIGN KEY（order_id）REFERENCES orders（order_id））PARTITION BY REFERENCE（order_items_fk）;</code></pre><div class="infoboxnotealso" id="GUID-DAE08807-4819-47C9-8105-3BE3F5FFA75A__GUID-446DA81B-AA00-4F92-9EE3-125F955D5CD4">
                                 <p class="notep1">也可以看看：</p>
                                 <p><a href="../vldbg/partition-concepts.html#VLDBG-GUID-54D18B18-6838-4115-9389-E1FB0D20A8CA" target="_blank"><span><cite>Oracle Database VLDB和分区指南</cite></span></a> ，了解参考分区的概述</p>
                              </div>
                           </div>
                           <!-- class="example" -->
                        </div>
                     </div>
                     <div class="sect5"><a id="GUID-26968EBD-4717-47CF-BCE6-48FFCCC23B79" name="GUID-26968EBD-4717-47CF-BCE6-48FFCCC23B79"></a><h6 id="CNCPT-GUID-26968EBD-4717-47CF-BCE6-48FFCCC23B79" class="sect6">复合分区</h6>
                        <div>
                           <p>在<span class="bold">复合分区中</span> ，表由一种数据分配方法分区，然后使用第二种数据分配方法将每个分区进一步细分为子分区。因此，复合分区结合了基本数据分配方法。给定分区的所有子分区都代表数据的逻辑子集。
                           </p>
                           <p>复合分区具有以下几个优点：</p>
                           <ul style="list-style-type:disc">
                              <li>
                                 <p>根据SQL语句，一维或二维上的分区修剪可以提高性能。</p>
                              </li>
                              <li>
                                 <p>查询可能能够在任一维度上使用完全或部分分区连接。</p>
                              </li>
                              <li>
                                 <p>您可以执行单个表的并行备份和恢复。</p>
                              </li>
                              <li>
                                 <p>分区数大于单级分区，这可能有利于并行执行。</p>
                              </li>
                              <li>
                                 <p>如果许多语句可以从分区修剪或分区连接中受益，则可以实现滚动窗口以支持历史数据，并仍在另一个维度上进行分区。</p>
                              </li>
                              <li>
                                 <p>您可以根据分区键的标识以不同方式存储数据。例如，您可能决定以只读的压缩格式存储特定产品类型的数据，并保持其他产品类型数据不压缩。</p>
                              </li>
                           </ul>
                           <p>范围，列表和散列分区符合复合分区表的子分区策略。下图提供了范围哈希和范围列表复合分区的图形视图。</p>
                           <div class="figure" id="GUID-26968EBD-4717-47CF-BCE6-48FFCCC23B79__COMPOSITERANGE-LISTPARTITIONING-EC1E52A1">
                              <p class="titleinfigure">图4-1复合范围列表分区</p><img src="img/vldbg009.gif" alt="下面是图4-1的描述" title="下面是图4-1的描述" longdesc="img_text/vldbg009.html"><br><a href="img_text/vldbg009.html">“图4-1复合范围列表分区”的说明</a></div>
                           <!-- class="figure" -->
                           <p>数据库将复合分区表中的每个子分区存储为单独的<a href="glossary.html#GUID-EC12AA68-8C89-43B3-B1F9-3AABF7CAEB9F"><span class="xrefglossterm">段</span></a> 。因此，子分区属性可能与表的属性或子分区所属的分区不同。
                           </p>
                           <div class="infoboxnotealso" id="GUID-26968EBD-4717-47CF-BCE6-48FFCCC23B79__ORACLEDATABASEVLDBANDPARTITIONINGGU-EC1E5EA6">
                              <p class="notep1">也可以看看：</p>
                              <p><a href="../vldbg/partition-concepts.html#GUID-BE424ACC-F746-4CA8-973C-F578CF98FF10" target="_blank"><span><cite>Oracle Database VLDB和分区指南</cite></span></a> ，了解有关复合分区的更多信息</p>
                           </div>
                        </div>
                     </div>
                  </div>
               </div><a id="CNCPT1136"></a><div class="props_rev_3"><a id="GUID-BCC6F209-3AF4-4517-A3AB-DFE5E4543649" name="GUID-BCC6F209-3AF4-4517-A3AB-DFE5E4543649"></a><h4 id="CNCPT-GUID-BCC6F209-3AF4-4517-A3AB-DFE5E4543649" class="sect4">分区表</h4>
                  <div>
                     <p><strong class="term">分区表</strong>由一个或多个分区组成，这些分区是单独管理的，可以独立于其他分区运行。
                     </p>
                     <p>表是分区的或非分区的。即使分区表只包含一个分区，该表也不同于未分区的表，该表不能添加分区。</p>
                     <div class="infoboxnotealso" id="GUID-BCC6F209-3AF4-4517-A3AB-DFE5E4543649__GUID-D2A5C288-F202-4118-81B2-037FE495D585">
                        <p class="notep1">也可以看看：</p>
                        <p>分区表的示例的<span class="q">“ <a href="partitions-views-and-other-schema-objects.html#GUID-E3C5EDAA-01F2-4077-915E-133045C43095" title="表或索引的每个分区必须具有相同的逻辑属性，例如列名，数据类型和约束。">分区特征</a> ”</span></p>
                        <p><span class="q">“ <a href="indexes-and-index-organized-tables.html#GUID-DAEC075B-C16D-4A57-898C-70EBCB364F0C" title="An index-organized table is a table stored in a variation of a B-tree index structure. In contrast, a heap-organized table inserts rows where they fit.">索引组织表概述</a> ”</span> ，了解<span class="q"><a href="indexes-and-index-organized-tables.html#GUID-DAEC075B-C16D-4A57-898C-70EBCB364F0C" title="索引组织表是存储在B树索引结构的变体中的表。相反，堆组织表在适合的位置插入行。">索引组织表</a></span>的目的和特征，这些表还可以从提供改进的可管理性，可用性和性能的分区中受益。
                        </p>
                     </div>
                  </div>
                  <div class="sect4"><a id="GUID-FAE17524-37EC-4A0E-AB29-8E893DE59F57" name="GUID-FAE17524-37EC-4A0E-AB29-8E893DE59F57"></a><h5 id="CNCPT-GUID-FAE17524-37EC-4A0E-AB29-8E893DE59F57" class="sect5">分区表的段</h5>
                     <div>
                        <p>分区表由一个或多个表分区段组成。</p>
                        <p>如果创建名为<code class="codeph">hash_products</code>的分区表，则不会为此表分配任何表<a href="glossary.html#GUID-EC12AA68-8C89-43B3-B1F9-3AABF7CAEB9F"><span class="xrefglossterm">段</span></a> 。相反，数据库将每个表分区的数据存储在其自己的分区段中。每个表分区段包含一部分表数据。
                        </p>
                        <p>对<a href="glossary.html#GUID-1B18B978-29DD-4961-BD39-86838CB5F7D0"><span class="xrefglossterm">外部表</span></a>进行分区时，所有分区都驻留在数据库之外。在混合分区表中，一些分区存储在段中，而其他分区存储在外部。例如， <code class="codeph">sales</code>表的某些分区可能存储在数据文件中，而其他分区则存储在电子表格中。
                        </p>
                        <div class="infoboxnotealso" id="GUID-FAE17524-37EC-4A0E-AB29-8E893DE59F57__GUID-D2A5C288-F202-4118-81B2-037FE495D585">
                           <p class="notep1">也可以看看：</p>
                           <ul style="list-style-type:disc">
                              <li>
                                 <p><span class="q">“ <a href="tables-and-table-clusters.html#GUID-97FC9DFF-A6CF-46CD-9F6F-D88A37C0E79C" title="外部表访问外部源中的数据，就好像此数据位于数据库中的表中一样。">外部表概述</a> ”</span></p>
                              </li>
                              <li>
                                 <p><span class="q">“ <a href="logical-storage-structures.html#GUID-7DA83E64-9FF1-45A7-A9AC-D4997DDE0866" title="段是一组扩展区，包含表空间中逻辑存储结构的所有数据。">细分概述</a> ”</span></p>了解对象和细分之间的关系</li>
                           </ul>
                        </div>
                     </div>
                  </div>
                  <div class="sect4"><a id="GUID-90503C7A-3F7D-4656-A9AC-43B473C35E76" name="GUID-90503C7A-3F7D-4656-A9AC-43B473C35E76"></a><h5 id="CNCPT-GUID-90503C7A-3F7D-4656-A9AC-43B473C35E76" class="sect5">分区表的压缩</h5>
                     <div>
                        <p>堆组织表的一些或所有分区可以以压缩格式存储。</p>
                        <p>压缩可节省空间并可加快查询执行速度。因此，压缩在数据仓库等环境中非常有用，在这些环境中，插入和更新操作的数量较少，并且在OLTP环境中也是如此。</p>
                        <p>您可以为<a href="glossary.html#GUID-9C21768F-A722-47F1-B54C-5563BDA38074"><span class="xrefglossterm">表</span></a>空间，表或表分区声明<a href="glossary.html#GUID-9C21768F-A722-47F1-B54C-5563BDA38074"><span class="xrefglossterm">表压缩</span></a>的属性。如果在表空间级别声明，则默认情况下会压缩在表空间中创建的表。您可以更改表的压缩属性，在这种情况下，更改仅适用于进入该表的新数据。因此，单个表或分区可能包含压缩和未压缩块，这可确保数据大小不会因压缩而增加。如果压缩可能会增加块的大小，则数据库不会将其应用于块。
                        </p>
                        <div class="infoboxnotealso" id="GUID-90503C7A-3F7D-4656-A9AC-43B473C35E76__GUID-D2A5C288-F202-4118-81B2-037FE495D585">
                           <p class="notep1">也可以看看：</p>
                           <ul style="list-style-type:disc">
                              <li>
                                 <p><span class="q">“ <a href="tables-and-table-clusters.html#GUID-54EE5325-0894-4869-B3AD-8912D9B4A329" title="数据库可以使用表压缩来减少表所需的存储量。">表压缩</a> ”</span>了解表压缩的类型，包括基本，高级行和混合列压缩</p>
                              </li>
                              <li>
                                 <p><a href="../dwhsg/data-warehouse-optimizations-techniques.html#DWHSG8913" target="_blank"><span><cite>Oracle数据库数据仓库指南</cite></span></a> ，了解数据仓库中的表压缩</p>
                              </li>
                           </ul>
                        </div>
                     </div>
                  </div>
               </div><a id="CNCPT312"></a><div class="props_rev_3"><a id="GUID-2B43D5F9-04CE-4602-9D95-DDA367CE25F7" name="GUID-2B43D5F9-04CE-4602-9D95-DDA367CE25F7"></a><h4 id="CNCPT-GUID-2B43D5F9-04CE-4602-9D95-DDA367CE25F7" class="sect4">分区索引</h4>
                  <div>
                     <p><strong class="term">分区索引</strong>是一种索引，与分区表一样，已被分为更小且更易于管理的部分。
                     </p>
                     <p>全局索引的分区与创建它们的表无关，而本地索引则自动链接到表的分区方法。与分区表一样，分区索引可提高可管理性，可用性，性能和可伸缩性。</p>
                     <p>下图显示了索引分区选项。</p>
                     <div class="figure" id="GUID-2B43D5F9-04CE-4602-9D95-DDA367CE25F7__GUID-949D2696-9990-4E05-986A-4442C882B558">
                        <p class="titleinfigure">图4-2索引分区选项</p><img src="img/cncpt301.gif" alt="下面是图4-2的描述" title="下面是图4-2的描述" longdesc="img_text/cncpt301.html"><br><a href="img_text/cncpt301.html">“图4-2索引分区选项”的说明</a></div>
                     <!-- class="figure" -->
                     <div class="infoboxnotealso" id="GUID-2B43D5F9-04CE-4602-9D95-DDA367CE25F7__GUID-E9A650C9-525A-457B-B035-81EA4712229C">
                        <p class="notep1">也可以看看：</p>
                        <ul style="list-style-type:disc">
                           <li>
                              <p><span class="q">“ <a href="indexes-and-index-organized-tables.html#GUID-DE7A95BC-6E4A-47EA-9FC5-B85B54F8CF41" title="索引是与表或表集群相关联的可选结构，有时可以加速数据访问。">索引简介</a> ”</span> ，了解唯一索引和非唯一索引之间的区别，以及不同的索引类型</p>
                           </li>
                           <li>
                              <p>有关分区索引以及如何确定使用哪种类型的详细信息<a href="../vldbg/partition-concepts.html#VLDBG00203" target="_blank"><span><cite>，请参见“Oracle数据库VLDB和分区指南”</cite></span></a></p>
                           </li>
                        </ul>
                     </div>
                  </div><a id="CNCPT88867"></a><a id="CNCPT88866"></a><a id="CNCPT1520"></a><div class="props_rev_3"><a id="GUID-4A4464E1-500F-4BB6-85E4-7D2E637A47FF" name="GUID-4A4464E1-500F-4BB6-85E4-7D2E637A47FF"></a><h5 id="CNCPT-GUID-4A4464E1-500F-4BB6-85E4-7D2E637A47FF" class="sect5">本地分区索引</h5>
                     <div>
                        <p>在<span class="bold">本地分区索引中</span> ，索引在相同的列上进行分区，具有相同数量的分区和与其表相同的分区范围。
                        </p>
                        <p>每个索引分区只与基础表的一个分区相关联，因此索引分区中的所有键仅指存储在单个表分区中的行。通过这种方式，数据库自动将索引分区与其关联的表分区同步，使每个表索引对独立。</p>
                        <p>本地分区索引在数据仓库环境中很常见。本地索引具有以下优点：</p>
                        <ul style="list-style-type:disc">
                           <li>
                              <p>可用性增加，因为在分区中使数据无效或不可用的操作仅影响此分区。</p>
                           </li>
                           <li>
                              <p>分区维护得以简化。移动表分区时，或者当数据超出分区时，只能重建或维护关联的本地索引分区。在全局索引中，必须重建或维护所有索引分区。</p>
                           </li>
                           <li>
                              <p>如果发生分区的时间点恢复，则可以将索引恢复到恢复时间（请参阅<span class="q">“ <a href="concepts-for-database-administrators.html#GUID-7F5703F9-CAE5-4736-895B-B45A51974A7C" title="数据文件恢复修复丢失或损坏的当前数据文件或控制文件。它还可以恢复在没有OFFLINE NORMAL选项的情况下表空间脱机时丢失的更改。">数据文件恢复</a> ”</span> ）。整个索引不需要重建。
                              </p>
                           </li>
                        </ul>
                        <p><a href="partitions-views-and-other-schema-objects.html#GUID-4BF963D2-948F-45C5-B015-B5E329A513D0" title="在散列分区中，数据库根据数据库应用于用户指定的分区键的散列算法将行映射到分区。">Hash Partitioning</a>中的示例显示了分区<code class="codeph">hash_sales</code>表的创建语句，使用<code class="codeph">prod_id</code>列作为分区键。以下示例在<code class="codeph">hash_sales</code>表的<code class="codeph">time_id</code>列上创建本地分区索引：</p><pre class="pre codeblock"><code>CREATE INDEX hash_sales_idx ON hash_sales（time_id）LOCAL;</code></pre><p>在<a href="partitions-views-and-other-schema-objects.html#GUID-4A4464E1-500F-4BB6-85E4-7D2E637A47FF__CFAIJFJI">图4-3中</a> ， <code class="codeph">hash_products</code>表有两个分区，因此<code class="codeph">hash_sales_idx</code>有两个分区。每个索引分区都与不同的表分区相关联。索引分区<code class="codeph">SYS_P38</code>索引表分区<code class="codeph">SYS_P33</code>行，而索引分区<code class="codeph">SYS_P39</code>索引表分区<code class="codeph">SYS_P34</code>行。
                        </p>
                        <div class="figure" id="GUID-4A4464E1-500F-4BB6-85E4-7D2E637A47FF__CFAIJFJI">
                           <p class="titleinfigure">图4-3本地索引分区</p><img src="img/cncpt302.gif" alt="下面是图4-3的描述" title="下面是图4-3的描述" longdesc="img_text/cncpt302.html"><br><a href="img_text/cncpt302.html">“图4-3本地索引分区”的说明</a></div>
                        <!-- class="figure" -->
                        <p>您无法将分区显式添加到本地索引。相反，只有在将分区添加到基础表时，才会将新分区添加到本地索引。同样，您无法从本地索引显式删除分区。相反，仅当从基础表中删除分区时，才会删除本地索引分区。</p>
                        <p>与其他索引一样，您可以在分区表上创建<a href="glossary.html#GUID-20C91FE3-E7A0-44AC-8AC1-9C4301877B65"><span class="xrefglossterm">位图索引</span></a> 。唯一的限制是位图索引必须是分区表的本地索引 - 它们不能是全局索引。仅在非分区表上支持全局位图索引。
                        </p>
                     </div><a id="CNCPT88868"></a><div class="props_rev_3"><a id="GUID-C83926F0-9AEA-4437-942C-9A80394DB63F" name="GUID-C83926F0-9AEA-4437-942C-9A80394DB63F"></a><h6 id="CNCPT-GUID-C83926F0-9AEA-4437-942C-9A80394DB63F" class="sect6">本地前缀和非前缀索引</h6>
                        <div>
                           <p>本地分区索引可以是前缀或非前缀的。</p>
                           <p>索引子类型定义如下：</p>
                           <ul style="list-style-type:disc">
                              <li>
                                 <p>本地前缀索引</p>
                                 <p>在这种情况下，分区键位于索引定义的前沿。在<a href="partitions-views-and-other-schema-objects.html#GUID-BF8A8838-DA69-4872-A42A-0C64FA3BD967" title="在范围分区中，数据库根据分区键的值范围将行映射到分区。范围分区是最常见的分区类型，通常与日期一起使用。">Range Partitioning中</a>的<code class="codeph">time_range_sales</code>示例中，表在<code class="codeph">time_id</code>上按范围分区。此表上的本地前缀索引将<code class="codeph">time_id</code>作为其列表中的第一列。
                                 </p>
                              </li>
                              <li>
                                 <p>本地非前缀索引</p>
                                 <p>在这种情况下，分区键不在索引列列表的前沿，并且根本不需要在列表中。在<a href="partitions-views-and-other-schema-objects.html#GUID-4A4464E1-500F-4BB6-85E4-7D2E637A47FF" title="在本地分区索引中，索引在相同的列上进行分区，具有相同数量的分区和与其表相同的分区范围。">本地分区索引中</a>的<code class="codeph">hash_sales_idx</code>示例中，索引是本地非前缀的，因为分区键<code class="codeph">product_id</code>不在前沿。
                                 </p>
                              </li>
                           </ul>
                           <p>两种类型的索引都可以利用<a href="glossary.html#GUID-17D46EB4-6C99-419E-86D7-91C4370BE8BF"><span class="xrefglossterm">分区消除</span></a> （也称为<span class="italic">分区修剪</span> ），当优化器通过排除考虑的分区来加速数据访问时，会发生<a href="glossary.html#GUID-17D46EB4-6C99-419E-86D7-91C4370BE8BF"><span class="xrefglossterm">分区消除</span></a> 。<a href="glossary.html#GUID-CCF91C9F-A98A-498F-A84B-58A0FA16CD6E"><span class="xrefglossterm">查询</span></a>是否可以消除分区取决于查询<a href="glossary.html#GUID-891CF9E9-78CD-470C-9C4A-D65A101B2C38"><span class="xrefglossterm">谓词</span></a> 。使用本地前缀索引的查询始终允许索引分区消除，而使用本地非前缀索引的查询可能不允许。
                           </p>
                           <div class="infoboxnotealso" id="GUID-C83926F0-9AEA-4437-942C-9A80394DB63F__GUID-691674B7-CCA0-4CE4-A78C-7EFEC8993E2B">
                              <p class="notep1">也可以看看：</p>
                              <p><a href="../vldbg/index-partitioning.html#VLDBG1251" target="_blank"><span><cite>Oracle Database VLDB和分区指南</cite></span></a> ，了解如何使用前缀和非前缀索引</p>
                           </div>
                        </div>
                     </div><a id="CNCPT88869"></a><div class="props_rev_3"><a id="GUID-AEB50D3B-D69F-4AD4-A054-2B559C152277" name="GUID-AEB50D3B-D69F-4AD4-A054-2B559C152277"></a><h6 id="CNCPT-GUID-AEB50D3B-D69F-4AD4-A054-2B559C152277" class="sect6">本地分区索引存储</h6>
                        <div>
                           <p>与表分区一样，本地索引分区存储在其自己的段中。每个段包含总索引数据的一部分。因此，由四个分区组成的本地索引不存储在单个索引段中，而是存储在四个单独的段中。</p>
                           <div class="infoboxnotealso" id="GUID-AEB50D3B-D69F-4AD4-A054-2B559C152277__GUID-A58D2412-6CA0-4982-8145-2A2B837F95D5">
                              <p class="notep1">也可以看看：</p>
                              <p><code class="codeph">CREATE INDEX ... <a href="../sqlrf/CREATE-INDEX.html#SQLRF54053" target="_blank"><span class="italic">Oracle数据库SQL语言参考</span></a> <code class="codeph">CREATE INDEX ...LOCAL</code>例子</p>
                           </div>
                        </div>
                     </div>
                  </div><a id="CNCPT88870"></a><a id="CNCPT89164"></a><a id="CNCPT1521"></a><div class="props_rev_3"><a id="GUID-A4544386-B1BF-418E-8B32-CFB069FF55DB" name="GUID-A4544386-B1BF-418E-8B32-CFB069FF55DB"></a><h5 id="CNCPT-GUID-A4544386-B1BF-418E-8B32-CFB069FF55DB" class="sect5">全局分区索引</h5>
                     <div>
                        <p><span class="bold">全局分区索引</span>是B树索引，它独立于创建它的基础表进行分区。单个索引分区可以指向任何或所有表分区，而在本地分区索引中，索引分区和表分区之间存在一对一奇偶校验。
                        </p>
                        <p>通常，全局索引对OLTP应用程序很有用，因为快速访问，数据完整性和可用性非常重要。在OLTP系统中，表可以由一个键分区，例如<code class="codeph">employees.department_id</code>列，但是应用程序可能需要使用许多不同的键访问数据，例如， <code class="codeph">employee_id</code>或<code class="codeph">job_id</code> 。全局索引在此方案中很有用。
                        </p>
                        <p>举例来说，假设您在<span class="q">“ <a href="partitions-views-and-other-schema-objects.html#GUID-BF8A8838-DA69-4872-A42A-0C64FA3BD967" title="在范围分区中，数据库根据分区键的值范围将行映射到分区。范围分区是最常见的分区类型，通常与日期一起使用。">Range Partitioning</a> ”中</span>的<code class="codeph">time_range_sales</code>表上创建了一个全局分区索引。在此表中，1998年的销售行存储在一个分区中，1999年的销售行存储在另一个分区中，依此类推。以下示例创建一个在<code class="codeph">channel_id</code>列上按范围分区的全局索引：</p><pre class="pre codeblock"><code>CREATE INDEX time_channel_sales_idx ON time_range_sales（ <span class="bold">channel_id</span> ）GLOBAL PARTITION BY RANGE（ <span class="bold">channel_id</span> ）（PARTITION p1值小于（3），PARTITION p2值小于（4），PARTITION p3 VALUE小于（MAXVALUE））;</code></pre><p><a href="partitions-views-and-other-schema-objects.html#GUID-A4544386-B1BF-418E-8B32-CFB069FF55DB__CFAEBFFA">如图4-4</a>所示，全局索引分区可以包含指向多个表分区的条目。索引分区<code class="codeph">p1</code>指向<code class="codeph">channel_id</code>为2的行，索引分区<code class="codeph">p2</code>指向<code class="codeph">channel_id</code>为3的行，索引分区<code class="codeph">p3</code>指向<code class="codeph">channel_id</code>为4或9的行。
                        </p>
                        <div class="figure" id="GUID-A4544386-B1BF-418E-8B32-CFB069FF55DB__CFAEBFFA">
                           <p class="titleinfigure">图4-4全局分区索引</p><img src="img/cncpt300.gif" alt="下面是图4-4的描述" title="下面是图4-4的描述" longdesc="img_text/cncpt300.html"><br><a href="img_text/cncpt300.html">“图4-4全局分区索引”的描述</a></div>
                        <!-- class="figure" -->
                        <div class="infoboxnotealso" id="GUID-A4544386-B1BF-418E-8B32-CFB069FF55DB__GUID-5B2F1E5D-76C6-40AB-AD1C-556AE76689C5">
                           <p class="notep1">也可以看看：</p>
                           <ul style="list-style-type:disc">
                              <li>
                                 <p><a href="../vldbg/index-partitioning.html#VLDBG1256" target="_blank"><span><cite>Oracle Database VLDB和分区指南</cite></span></a> ，了解如何管理全局分区索引</p>
                              </li>
                              <li>
                                 <p><a href="../sqlrf/CREATE-INDEX.html#SQLRF54012" target="_blank"><span><cite>Oracle Database SQL语言参考</cite></span></a> ，了解<code class="codeph">CREATE INDEX</code>的<code class="codeph">GLOBAL PARTITION</code>子句</p>
                              </li>
                           </ul>
                        </div>
                     </div>
                  </div>
               </div><a id="CNCPT89215"></a><a id="CNCPT89298"></a><div class="props_rev_3"><a id="GUID-D3223210-7B9A-4DB0-A213-F819E0DAF316" name="GUID-D3223210-7B9A-4DB0-A213-F819E0DAF316"></a><h4 id="CNCPT-GUID-D3223210-7B9A-4DB0-A213-F819E0DAF316" class="sect4">分区表的部分索引</h4>
                  <div>
                     <p><strong class="term">部分索引</strong>是与关联的分区表的索引属性相关联的索引。
                     </p>
                     <p>通过关联，您可以指定索引哪些表分区。部分索引具有以下优点：</p>
                     <ul style="list-style-type:disc">
                        <li>
                           <p>未编制索引的表分区可避免消耗不必要的索引存储空间。</p>
                        </li>
                        <li>
                           <p>负载和查询的性能可以提高。</p>
                           <p>在<span>Oracle Database 12c</span>之前，交换分区操作需要对关联的全局索引进行物理更新，以使其保持可用状态。从<span>Oracle Database 12c开始</span> ，如果分区维护操作中涉及的分区不是部分全局索引的一部分，则索引仍然可用，而无需任何全局索引维护。
                           </p>
                        </li>
                        <li>
                           <p>如果在创建索引时仅索引某些表分区，并且稍后索引其他分区，则可以减少索引创建所需的排序空间。</p>
                        </li>
                     </ul>
                     <p>您可以为表的各个分区打开或关闭索引。对于已关闭索引的所有表分区，部分本地索引没有可用的索引分区。无论是否已分区，全局索引都会排除已关闭索引的所有分区中的数据。数据库不支持强制执行唯一约束的索引的部分索引。</p>
                     <p><a href="partitions-views-and-other-schema-objects.html#GUID-D3223210-7B9A-4DB0-A213-F819E0DAF316__CHDGFHDC">图4-5</a>显示了与<a href="partitions-views-and-other-schema-objects.html#GUID-A4544386-B1BF-418E-8B32-CFB069FF55DB__CFAEBFFA">图4-4</a>相同的全局索引，但全局索引是部分索引。表分区<code class="codeph">SALES_1998</code>和<code class="codeph">SALES_2000</code>将索引属性设置为<code class="codeph">OFF</code> ，因此部分全局索引不会为它们编制索引。
                     </p>
                     <div class="figure" id="GUID-D3223210-7B9A-4DB0-A213-F819E0DAF316__CHDGFHDC">
                        <p class="titleinfigure">图4-5部分全局分区索引</p><img src="img/cncpt342.png" alt="下面是图4-5的描述" title="下面是图4-5的描述" longdesc="img_text/cncpt342.html"><br><a href="img_text/cncpt342.html">“图4-5部分全局分区索引”的描述</a></div>
                     <!-- class="figure" -->
                  </div>
               </div>
            </div>
            <div class="sect2"><a id="GUID-4C8C435A-4CB0-4094-A77C-5AD4737BBB16" name="GUID-4C8C435A-4CB0-4094-A77C-5AD4737BBB16"></a><h3 id="CNCPT-GUID-4C8C435A-4CB0-4094-A77C-5AD4737BBB16" class="sect3">分片表概述</h3>
               <div>
                  <p>在Oracle数据库中，分片使您可以将大型表拆分为更易于管理的部分，称为分片，可以存储在多个数据库中。</p>
                  <p>每个<span>数据库都托管在具有自己的本地资源（CPU，内存，闪存或磁盘）的专用服务器上。</span> <span>在这种配置中的每个数据库称为<strong class="term">碎片</strong> 。</span> <span>所有分片一起组成一个逻辑数据库，称为分片<strong class="term">数据库（SDB）</strong> 。</span></p>
                  <p><span>水平分区涉及跨分片拆分数据库表，以便每个分片包含具有相同列但行的不同子集的表。以这种方式分割的表也称为分片<span class="italic">表</span> 。</span></p>
                  <p>下图显示了跨三个分片水平分区的表。</p>
                  <div class="figure" id="GUID-4C8C435A-4CB0-4094-A77C-5AD4737BBB16__GUID-4242B296-023B-4842-981C-DFE75CA2E713">
                     <p class="titleinfigure">图4-6跨越碎片的表格的水平分区</p><img id="GUID-4C8C435A-4CB0-4094-A77C-5AD4737BBB16__IMAGE_CJZ_5VC_KGB" src="img/admin_3v_134a.png" alt="下面是图4-6的描述" title="下面是图4-6的描述" longdesc="img_text/admin_3v_134a.html"><br><a href="img_text/admin_3v_134a.html">“图4-6跨越碎片的水平分区”的描述</a></div>
                  <!-- class="figure" -->
                  <p>分片基于无共享硬件基础架构，它消除了单点故障，因为分片不共享物理资源，如CPU，内存或存储设备。碎片在软件方面也松散耦合;他们不运行集群件。</p>
                  <p>碎片通常托管在专用服务器上。这些服务器可以是商用硬件或工程系统。分片可以在单实例或Oracle RAC数据库上运行。它们可以放置在本地，云端，或混合本地和云配置中。</p>
                  <p>从数据库管理员的角度来看，SDB由多个可以集体或单独管理的数据库组成。但是，从应用程序的角度来看，SDB看起来像一个单独的数据库：这些分片中的分片数量和数据分布对数据库应用程序是完全透明的。</p>
                  <p>分片适用于适用于分片数据库体系结构的自定义OLTP应用程序。使用分片的应用程序必须具有明确定义的数据模型和数据分布策略（一致的散列，范围，列表或复合），主要使用分片键访问数据。分片键的示例包括<code class="codeph">customer_id</code> ， <code class="codeph">account_no</code>或<code class="codeph">country_id</code> 。
                  </p>
                  <div class="infoboxnotealso" id="GUID-4C8C435A-4CB0-4094-A77C-5AD4737BBB16__GUID-37255C2A-55CF-45E9-B526-079589A1CC27">
                     <p class="notep1">也可以看看：</p>
                     <p><a href="../shard/sharding-overview.html#SHARD-GUID-0F39B1FB-DCF9-4C8A-A2EA-88705B90C5BF" target="_blank"><span><cite>使用Oracle Sharding</cite></span></a></p>
                  </div>
               </div>
               <div class="sect3"><a id="GUID-1DBC6C7F-4E0C-47E5-8870-05F829D6C3B3" name="GUID-1DBC6C7F-4E0C-47E5-8870-05F829D6C3B3"></a><h4 id="CNCPT-GUID-1DBC6C7F-4E0C-47E5-8870-05F829D6C3B3" class="sect4">Sharded Tables</h4>
                  <div>
                     <p>分片表是一个表，在多个数据库之间划分为更小且更易于管理的部分，称为分片。</p>
                     <p>分片的主要好处包括：</p>
                     <ul id="GUID-1DBC6C7F-4E0C-47E5-8870-05F829D6C3B3__UL_VLV_C1D_KGB" style="list-style-type:disc">
                        <li>
                           <p><span class="bold">线性可扩展性</span> 。分片消除了性能瓶颈，并且可以通过添加分片来线性扩展性能和容量。
                           </p>
                        </li>
                        <li>
                           <p> <span class="bold">故障遏制</span> 。Sharding是一种无共享硬件基础架构，可消除单点故障，例如共享磁盘，SAN和集群件，并提供强大的故障隔离 - 一个分片的故障或速度降低不会影响其他分片的性能或可用性。
                           </p>
                        </li>
                        <li>
                           <p><span class="bold">数据的地理分布</span> 。当数据必须位于特定的管辖区域时，分片可以将特定数据存储在靠近其消费者的位置并满足法规要求。
                           </p>
                        </li>
                        <li>
                           <p><span class="bold">滚动升级</span> 。一次在一个分片上应用配置更改不会影响其他分片，并允许管理员首先测试一小部分数据的更改。
                           </p>
                        </li>
                        <li>
                           <p><span class="bold">云部署的简单性</span> 。分片非常适合在云中部署。可以根据需要调整碎片的大小以适应可用的任何云基础设施并且仍然实现所需的服务级别。Oracle Sharding支持内部部署，云和混合部署模型。
                           </p>
                        </li>
                     </ul>
                     <div class="section">
                        <p class="subhead3" id="GUID-1DBC6C7F-4E0C-47E5-8870-05F829D6C3B3__GUID-FEA6F86B-09E1-4DF5-A5DE-B980A45DFBB9">碎片架构</p>
                        <p>应用程序将数据库池视为单个逻辑数据库。通过向池中添加数据库（分片），应用程序可以在任何平台上弹性地将数据，事务和用户扩展到任何级别。Oracle数据库支持最多可扩展1000个分片。</p>
                        <p>下图说明了Oracle Sharding的主要体系结构组件：</p>
                        <ul id="GUID-1DBC6C7F-4E0C-47E5-8870-05F829D6C3B3__UL_NDW_M1D_KGB" style="list-style-type:disc">
                           <li>
                              <p>分片数据库（SDB） - 单个逻辑Oracle数据库，在不共享硬件或软件的物理Oracle数据库（分片）池中水平分区</p>
                           </li>
                           <li>
                              <p>碎片 - 托管分片数据库子集的独立物理Oracle数据库</p>
                           </li>
                           <li>
                              <p>全局服务 - 提供对SDB中数据的访问的数据库服务</p>
                           </li>
                           <li>
                              <p>分片目录 - 支持自动分片部署，分片数据库集中管理和多分片查询的Oracle数据库</p>
                           </li>
                           <li>
                              <p>Shard director  - 网络侦听器，支持基于分片键的高性能连接路由</p>
                           </li>
                           <li>
                              <p>连接池 - 在运行时，通过跨池连接路由数据库请求来充当分片导向器</p>
                           </li>
                           <li>
                              <p>管理界面 -  GDSCTL（命令行实用程序）和Oracle企业管理器（GUI）</p>
                           </li>
                        </ul>
                        <div class="figure" id="GUID-1DBC6C7F-4E0C-47E5-8870-05F829D6C3B3__GUID-65F25F7E-0A7B-4DC2-8B45-21DE4055DFA2">
                           <p class="titleinfigure">图4-7 Oracle Sharding架构</p><img id="GUID-1DBC6C7F-4E0C-47E5-8870-05F829D6C3B3__IMAGE_ODW_M1D_KGB" src="img/admin_3v_143d.png" alt="下面是图4-7的描述" title="下面是图4-7的描述" longdesc="img_text/admin_3v_143d.html"><br><a href="img_text/admin_3v_143d.html">“图4-7 Oracle Sharding架构”的说明</a></div>
                        <!-- class="figure" -->
                     </div>
                     <!-- class="section" -->
                     <div class="section">
                        <p class="subhead3" id="GUID-1DBC6C7F-4E0C-47E5-8870-05F829D6C3B3__GUID-628DEA40-7CAF-4662-9BD5-799AB25D68BA">分片和分区</p>
                        <p>Oracle Sharding本质上是分布式分区，因为它通过支持跨分片的表分区分发来扩展分区。</p>
                        <p>基于分片键，分区在表空间级别的分片中分布。密钥的示例包括客户ID，帐号和国家ID。分片键支持以下数据类型：</p>
                        <ul id="GUID-1DBC6C7F-4E0C-47E5-8870-05F829D6C3B3__UL_OHB_5ZC_KGB" style="list-style-type:disc">
                           <li>
                              <p><code class="codeph">数</code></p>
                           </li>
                           <li>
                              <p><code class="codeph">整数</code></p>
                           </li>
                           <li>
                              <p><code class="codeph">SMALLINT</code></p>
                           </li>
                           <li>
                              <p><code class="codeph">生的</code></p>
                           </li>
                           <li>
                              <p><code class="codeph">（N）VARCHAR</code></p>
                           </li>
                           <li>
                              <p><code class="codeph">（N）VARCHAR2</code></p>
                           </li>
                           <li>
                              <p><code class="codeph">（N）CHAR</code></p>
                           </li>
                           <li>
                              <p><code class="codeph">日期</code></p>
                           </li>
                           <li>
                              <p><code class="codeph">TIMESTAMP</code></p>
                           </li>
                        </ul>
                        <p>分片表的每个分区都驻留在一个单独的表空间中，每个表空间都与一个特定的分片相关联。根据分片方法，可以自动建立关联或由管理员定义关联。</p>
                        <p>即使分片表的分区驻留在多个分片中，对于应用程序，该表的外观和行为与单个数据库中的分区表完全相同。应用程序发出的SQL语句永远不必引用分片或依赖于分片数量及其配置。</p>
                        <p></p>
                     </div>
                     <!-- class="section" -->
                     <div class="example" id="GUID-1DBC6C7F-4E0C-47E5-8870-05F829D6C3B3__GUID-FA524CC9-8238-40D6-AA6A-BAFC7E5A93C1">
                        <p class="titleinexample">例4-5 Sharded Table</p>
                        <p>熟悉的表分区SQL语法指定了如何跨分片对行进行分区。例如，以下SQL语句创建一个分片表，根据分片键<code class="codeph">cust_id</code>在分片上水平分区表：</p><pre class="pre codeblock"><code>CREATE SHARDED TABLE客户（cust_id NUMBER NOT NULL，名称VARCHAR2（50），地址VARCHAR2（250），区域VARCHAR2（20），类VARCHAR2（3），注册DATE CONSTRAINT cust_pk PRIMARY KEY（cust_id））PARTITION BY CONSISTENT HASH（cust_id ）PARTITIONS AUTO TABLESPACE SET ts1;</code></pre><p>上表由一致哈希分区，哈希是一种在可伸缩分布式系统中常用的特殊类型的哈希分区。此技术自动跨分片传播表空间，以提供均匀的数据和工作负载分布。请注意，不支持分片表上的全局索引，但支持本地索引。</p>
                     </div>
                     <!-- class="example" -->
                     <div class="section">
                        <p class="subhead3" id="GUID-1DBC6C7F-4E0C-47E5-8870-05F829D6C3B3__GUID-49480A54-1E79-4E26-983D-3566D39B7EB5">表空间集</p>
                        <p>Oracle Sharding创建和管理表空间作为一个称为<strong class="term">表空间集</strong>的单元。<code class="codeph">PARTITIONS AUTO</code>子句指定应自动确定分区数。这种类型的散列在分片之间迁移数据方面提供了更大的灵活性和效率，这对于弹性可伸缩性非常重要。
                        </p>
                        <p>表空间是SDB中数据分布的逻辑单元。跨分片的分区分布是通过在驻留在不同分片上的表空间中自动创建分区来实现的。为了最小化多分片连接的数量，相关表的相应分区始终存储在同一分片中。分片表的每个分区都存储在单独的表空间中。</p>
                        <div class="infoboxnote" id="GUID-1DBC6C7F-4E0C-47E5-8870-05F829D6C3B3__GUID-A6E8D269-524F-453D-8E43-2730AEAF190B">
                           <p class="notep1">注意：</p>
                           <p>表空间集仅支持Oracle托管文件。</p>
                           <p>不能独立于整个表空间集删除或更改单个表空间。</p>
                           <p><code class="codeph">TABLESPACE SET</code>不能与用户定义的分片方法一起使用。
                           </p>
                        </div>
                     </div>
                     <!-- class="section" -->
                  </div>
                  <div>
                     <div class="relinfo">
                        <p><strong>相关话题</strong></p>
                        <ul>
                           <li><a href="introduction-to-oracle-database.html#GUID-8F1E6C26-A65A-4D62-B236-BFE3DA6CD43F" title="Oracle Sharding是一种基于跨多个Oracle数据库的数据水平分区的数据库扩展技术。应用程序将数据库池视为单个逻辑数据库。">分片架构</a></li>
                           <li><a href="../shard/sharding-overview.html#SHARD-GUID-0F39B1FB-DCF9-4C8A-A2EA-88705B90C5BF" target="_blank"><span><cite>使用Oracle Sharding</cite></span></a></li>
                        </ul>
                     </div>
                  </div>
                  
               </div>
            </div><a id="CNCPT88871"></a><a id="CNCPT311"></a><div class="props_rev_3"><a id="GUID-15E7AEDB-9A3F-4B31-AD2D-66253CC822E5" name="GUID-15E7AEDB-9A3F-4B31-AD2D-66253CC822E5"></a><h3 id="CNCPT-GUID-15E7AEDB-9A3F-4B31-AD2D-66253CC822E5" class="sect3">视图概述</h3>
               <div>
                  <p><span class="bold">视图</span>是一个或多个表的逻辑表示。实质上，视图是存储的查询。
                  </p>
                  <p>视图从其所基于的表中派生其数据，称为<span class="italic">基表</span> 。基表可以是表或其他视图。对视图执行的所有操作实际上都会影响基表。您可以在大多数使用表的地方使用视图。
                  </p>
                  <div class="infoboxnote" id="GUID-15E7AEDB-9A3F-4B31-AD2D-66253CC822E5__GUID-7E33B4D0-E237-4051-A508-011502739BC5">
                     <p class="notep1">注意：</p>
                     <p>物化视图使用标准视图中的不同数据结构。</p>
                  </div>
                  <p>通过视图，您可以为不同类型的用户定制数据表示。视图通常用于：</p>
                  <ul style="list-style-type:disc">
                     <li>
                        <p>通过限制对表的一组预定行或列的访问来提供额外级别的表安全性</p>
                        <p>例如， <a href="partitions-views-and-other-schema-objects.html#GUID-15E7AEDB-9A3F-4B31-AD2D-66253CC822E5__I5739">图4-8</a>显示了<code class="codeph">staff</code>视图如何不显示基表<code class="codeph">employees</code>的<code class="codeph">salary</code>或<code class="codeph">commission_pct</code>列。
                        </p>
                     </li>
                     <li>
                        <p>隐藏数据复杂性</p>
                        <p>例如，可以使用连接定义单个视图， <a href="glossary.html#GUID-71A4D429-D0A6-4979-AACA-EDE5F4BCFC8B"><span class="xrefglossterm">连接</span></a>是多个表中相关列或行的集合。但是，该视图隐藏了这一信息实际上源自几个表的事实。查询还可能使用表信息执行大量计算。因此，用户可以在不知道如何执行连接或计算的情况下查询视图。
                        </p>
                     </li>
                     <li>
                        <p>以与基表不同的视角呈现数据</p>
                        <p>例如，可以重命名视图的列，而不会影响视图所基于的表。</p>
                     </li>
                     <li>
                        <p>将应用程序与基表定义的更改隔离开来</p>
                        <p>例如，如果视图的定义查询引用四列表的三列，并且第五列添加到表中，则视图的定义不受影响，并且使用该视图的所有应用程序都不受影响。</p>
                     </li>
                  </ul>
                  <p>有关视图使用的示例，请考虑<code class="codeph">hr.employees</code>表，该表具有多个列和多个行。要允许用户仅查看其中五列或仅查看特定行，您可以按如下方式创建视图：</p><pre class="pre codeblock"><code>CREATE VIEW人员AS SELECT employee_id，last_name，job_id，manager_id，department_id FROM employees;</code></pre><p>与所有子查询一样，定义视图的查询不能包含<code class="codeph">FOR UPDATE</code>子句。下图说明了名为<code class="codeph">staff</code>的视图。请注意，该视图仅显示基表中的五个列。
                  </p>
                  <div class="figure" id="GUID-15E7AEDB-9A3F-4B31-AD2D-66253CC822E5__I5739">
                     <p class="titleinfigure">图4-8视图</p><img src="img/cncpt045.gif" alt="下面是图4-8的描述" title="下面是图4-8的描述" longdesc="img_text/cncpt045.html"><br><a href="img_text/cncpt045.html">“图4-8视图”的说明</a></div>
                  <!-- class="figure" -->
                  <div class="infoboxnotealso" id="GUID-15E7AEDB-9A3F-4B31-AD2D-66253CC822E5__GUID-E83635A7-C789-413E-954F-8BE44F222B84">
                     <p class="notep1">也可以看看：</p>
                     <ul style="list-style-type:disc">
                        <li>
                           <p><span class="q">“ <a href="partitions-views-and-other-schema-objects.html#GUID-2822B62B-CAF3-4DCE-B4D6-5E677FB8A829" title="物化视图是已存储的查询结果或" name="" materialize="=" ="">物化视图概述</a> ”</span></p>
                        </li>
                        <li>
                           <p><a href="../admin/managing-views-sequences-and-synonyms.html#ADMIN11774" target="_blank"><span><cite>Oracle数据库管理员指南</cite></span></a> ，了解如何管理视图</p>
                        </li>
                        <li>
                           <p>用于<code class="codeph">CREATE VIEW</code>语法和语义的<a href="../sqlrf/CREATE-VIEW.html#SQLRF01504" target="_blank"><span><cite>Oracle数据库SQL语言参考</cite></span></a></p>
                        </li>
                     </ul>
                  </div>
               </div><a id="CNCPT1145"></a><div class="props_rev_3"><a id="GUID-B79EF730-11A8-4620-A0BE-7609F9B4E586" name="GUID-B79EF730-11A8-4620-A0BE-7609F9B4E586"></a><h4 id="CNCPT-GUID-B79EF730-11A8-4620-A0BE-7609F9B4E586" class="sect4">观点的特征</h4>
                  <div>
                     <p>与表不同，视图不是分配存储空间，视图也不包含数据。相反，视图由查询定义，该查询从视图引用的基表中提取或派生数据。因为视图基于其他对象，所以除了用于定义数据字典中的视图的查询的存储之外，它不需要存储。</p>
                     <p>视图依赖于其引用的对象，这些对象由数据库自动处理。例如，如果删除并重新创建视图的基表，则数据库将确定新基表是否为视图定义所接受。</p>
                  </div><a id="CNCPT88872"></a><div class="props_rev_3"><a id="GUID-322500BA-F86A-4C80-834F-7AD46C921817" name="GUID-322500BA-F86A-4C80-834F-7AD46C921817"></a><h5 id="CNCPT-GUID-322500BA-F86A-4C80-834F-7AD46C921817" class="sect5">视图中的数据操作</h5>
                     <div>
                        <p>因为视图是从表中派生的，所以它们有许多相似之处。用户可以查询视图，并且通过一些限制，他们可以在视图上执行DML。对视图执行的操作会影响视图的某个基表中的数据，并受基本表的完整性约束和触发器的影响。</p>
                        <p>以下示例创建<code class="codeph">hr.employees</code>表的视图：</p><pre class="oac_no_warn" dir="ltr">CREATE VIEW staff_dept_10 AS SELECT employee_id，last_name，job_id，manager_id，department_id FROM employees WHERE department_id = 10 WITH CHECK OPTION CONSTRAINT staff_dept_10_cnst;</pre><p>定义查询仅引用部门10的行。<code class="codeph">CHECK OPTION</code>使用约束创建视图，以便针对视图发出的<code class="codeph">INSERT</code>和<code class="codeph">UPDATE</code>语句不会导致视图无法选择的行。因此，可以插入部门10中的雇员的行，但不插入部门30的行。
                        </p>
                        <div class="infoboxnotealso" id="GUID-322500BA-F86A-4C80-834F-7AD46C921817__GUID-F5A74FC6-EDB3-48B9-9564-172C45D76F62">
                           <p class="notep1">也可以看看：</p>
                           <p><a href="../sqlrf/SELECT.html#SQLRF55299" target="_blank"><span class="italic">Oracle Database SQL语言参考</span></a> ，了解<code class="codeph">CREATE VIEW</code>语句中的子查询限制</p>
                        </div>
                     </div>
                  </div><a id="CNCPT1147"></a><div class="props_rev_3"><a id="GUID-BC33130E-746F-4F8E-9C50-828FF4DCDA8A" name="GUID-BC33130E-746F-4F8E-9C50-828FF4DCDA8A"></a><h5 id="CNCPT-GUID-BC33130E-746F-4F8E-9C50-828FF4DCDA8A" class="sect5">如何在视图中访问数据</h5>
                     <div>
                        <p>Oracle数据库将视图定义存储在数据字典中，作为定义视图的查询的文本。</p>
                        <p>在SQL语句中引用视图时，Oracle数据库将执行以下任务：</p>
                        <ol>
                           <li>
                              <p>将查询（如果可能）与具有定义视图和任何基础视图的查询的视图合并</p>
                              <p>Oracle数据库优化合并查询，就像您在不引用视图的情况下发出查询一样。因此，Oracle数据库可以在任何引用的基表列上使用索引，无论这些列是在视图定义中引用还是在针对视图的用户查询中引用。</p>
                              <p>有时，Oracle数据库无法将视图定义与用户查询合并。在这种情况下，Oracle数据库可能不会使用引用列上的所有索引。</p>
                           </li>
                           <li>
                              <p>解析<a href="glossary.html#GUID-E0BE3164-B0A9-4ED8-AD19-2048ADFFC9BB"><span class="xrefglossterm">共享SQL区域中</span></a>的合并语句</p>
                              <p><span class="italic">仅</span>当没有现有共享SQL区域包含类似语句时，Oracle数据库<span class="italic">才会</span>解析引用新共享SQL区域中的视图的语句。因此，视图提供了与共享SQL相关的减少内存使用的好处。</p>
                           </li>
                           <li>
                              <p>执行SQL语句</p>
                           </li>
                        </ol>
                        <p>以下示例说明了查询视图时的数据访问。假设您根据<code class="codeph">employees</code>和<code class="codeph">departments</code>表创建<code class="codeph">employees_view</code> ：</p><pre class="pre codeblock"><code>CREATE VIEW employees_view AS SELECT employee_id，last_name，salary，location_id FROM employees JOIN departments USING（department_id）WHERE department_id = 10;</code></pre><p>用户执行以下<code class="codeph">employees_view</code>查询：</p><pre class="pre codeblock"><code>SELECT last_name FROM employees_view WHERE employee_id = 200;</code></pre><p>Oracle数据库合并视图和用户查询以构造以下查询，然后执行该查询以检索数据：</p><pre class="pre codeblock"><code>SELECT last_name FROM employees，departments WHERE employees.department_id = departments.department_id AND departments.department_id = 10 AND employees.employee_id = 200;</code></pre><div class="infoboxnotealso" id="GUID-BC33130E-746F-4F8E-9C50-828FF4DCDA8A__GUID-FA88DF34-4E10-4C30-B024-91266535E864">
                           <p class="notep1">也可以看看：</p>
                           <ul style="list-style-type:disc">
                              <li>
                                 <p><span class="q">“ <a href="memory-architecture.html#GUID-0DBEB809-0660-4A04-ADF6-CABE4F6DF0B8" title="数据库表示它在共享SQL区域和私有SQL区域中运行的每个SQL语句。">共享SQL区域</a> ”</span></p>
                              </li>
                              <li>
                                 <p><span class="q">“ <a href="sql.html#GUID-3F42B1AA-530A-4144-8179-F0074832AF81" title="要了解Oracle数据库如何处理SQL语句，有必要了解数据库中称为优化器的部分（也称为查询优化器或基于成本的优化器）。所有SQL语句都使用优化器来确定访问指定数据的最有效方法。">优化器概述</a> ”</span></p>
                              </li>
                              <li>
                                 <p><a href="../tgsql/query-optimizer-concepts.html#TGSQL193" target="_blank"><span><cite>Oracle数据库SQL调优指南</cite></span></a> ，了解查询优化</p>
                              </li>
                           </ul>
                        </div>
                     </div>
                  </div>
               </div><a id="CNCPT88873"></a><a id="CNCPT1151"></a><div class="props_rev_3"><a id="GUID-8C983FA8-0E9B-4D2B-B819-28FD7F45F1FA" name="GUID-8C983FA8-0E9B-4D2B-B819-28FD7F45F1FA"></a><h4 id="CNCPT-GUID-8C983FA8-0E9B-4D2B-B819-28FD7F45F1FA" class="sect4">可更新的加入视图</h4>
                  <div>
                     <p><strong class="term">连接视图</strong>的<code class="codeph">FROM</code>子句中有多个表或视图。
                     </p>
                     <p>在以下示例中， <code class="codeph">staff_dept_10_30</code>视图连接<code class="codeph">employees</code>和<code class="codeph">departments</code>表，仅包括部门10或30中的员工：</p><pre class="pre codeblock"><code>CREATE VIEW staff_dept_10_30 AS SELECT employee_id，last_name，job_id，e.department_id FROM employees e，departments d WHERE e.department_id IN（10,30）AND e.department_id = d.department_id;</code></pre><p><a href="glossary.html#GUID-F510D35A-83C5-4974-B6F0-5E4073F73DE1"><span class="xrefglossterm">可更新的连接视图</span></a> （也称为<span class="italic">可修改的连接视图</span> ）涉及两个或多个基表或视图，并允许DML操作。可更新视图在<code class="codeph">SELECT</code>语句的顶级<code class="codeph">FROM</code>子句中包含多个表，并且不受<code class="codeph">WITH READ ONLY</code>子句的限制。
                     </p>
                     <p>为了具有固有的可更新性，视图必须满足几个标准。例如，一般规则是连接视图上的<code class="codeph">INSERT</code> ， <code class="codeph">UPDATE</code>或<code class="codeph">DELETE</code>操作一次只能修改一个基表。以下<code class="codeph">USER_UPDATABLE_COLUMNS</code>数据字典视图查询显示<code class="codeph">staff_dept_10_30</code>视图是可更新的：</p><pre class="pre codeblock"><code>SQL&gt; SELECT TABLE_NAME，COLUMN_NAME，UPDATABLE 2 FROM USER_UPDATABLE_COLUMNS 3 WHERE TABLE_NAME ='STAFF_DEPT_10_30'; TABLE_NAME COLUMN_NAME UPD ------------------------------ ----------------- ------------- --- STAFF_DEPT_10_30 EMPLOYEE_ID YES STAFF_DEPT_10_30 LAST_NAME YES STAFF_DEPT_10_30 JOB_ID YES STAFF_DEPT_10_30 DEPARTMENT_ID YES</code></pre><p>连接视图的所有可更新列都必须映射到<a href="glossary.html#GUID-481043B7-88C3-4492-8949-68ECE8077702"><span class="xrefglossterm">密钥保留表的</span></a>列，该表是基础表的每一行在查询输出中最多出现一次的表。在<code class="codeph">staff_dept_10_30</code>视图中， <code class="codeph">department_id</code>是<code class="codeph">departments</code>表的主键，因此<code class="codeph">employees</code>表中的每一行在结果集中最多出现一次，从而使<code class="codeph">employees</code>表保持键。<code class="codeph">departments</code>表不是密钥保留的，因为它的每一行都可能在结果集中出现多次。
                     </p>
                     <div class="infoboxnotealso" id="GUID-8C983FA8-0E9B-4D2B-B819-28FD7F45F1FA__GUID-871DBA67-313B-456B-B688-763137512B0F">
                        <p class="notep1">也可以看看：</p>
                        <p><a href="../admin/managing-views-sequences-and-synonyms.html#ADMIN11782" target="_blank"><span><cite>Oracle数据库管理员指南</cite></span></a> ，了解如何更新连接视图</p>
                     </div>
                  </div>
               </div><a id="CNCPT1152"></a><div class="props_rev_3"><a id="GUID-15BCE53C-7A32-40B9-923F-151DABF4647F" name="GUID-15BCE53C-7A32-40B9-923F-151DABF4647F"></a><h4 id="CNCPT-GUID-15BCE53C-7A32-40B9-923F-151DABF4647F" class="sect4">对象视图</h4>
                  <div>
                     <p>正如视图是虚拟表一样， <span class="bold">对象视图</span>是虚拟对象表。视图中的每一行都是一个对象，它是<span class="bold">对象类型的</span>一个实例。对象类型是用户定义的数据类型。
                     </p>
                     <p>您可以检索，更新，插入和删除关系数据，就像它存储为对象类型一样。您还可以使用作为对象数据类型的列定义视图，例如对象， <code class="codeph">REF</code>和集合（嵌套表和<code class="codeph">VARRAY</code> ）。
                     </p>
                     <p>与关系视图一样，对象视图只能呈现数据库管理员希望用户看到的数据。例如，对象视图可以显示有关IT程序员的数据，但可以省略有关工资的敏感数据。以下示例基于此对象创建<code class="codeph">employee_type</code>对象，然后创建视图<code class="codeph">it_prog_view</code> ：</p><pre class="oac_no_warn" dir="ltr">CREATE TYPE employee_type AS OBJECT（employee_id NUMBER（6），last_name VARCHAR2（25），job_id VARCHAR2（10））; / CREATE VIEW it_prog_view employee_type WITH OBJECT IDENTIFIER（employee_id）AS SELECT e.employee_id，e.last_name，e.job_id FROM employees e WHERE job_id ='IT_PROG';</pre><p>对象视图在原型设计或转换到面向对象的应用程序时非常有用，因为视图中的数据可以从关系表中获取并访问，就像将表定义为对象表一样。您可以运行面向对象的应用程序，而无需将现有表转换为不同的物理结构。</p>
                     <div class="infoboxnotealso" id="GUID-15BCE53C-7A32-40B9-923F-151DABF4647F__GUID-27CDE188-60BC-4A5D-A834-04C427FD4DE2">
                        <p class="notep1">也可以看看：</p>
                        <ul style="list-style-type:disc">
                           <li>
                              <p><a href="../adobj/key-features-object-relational-model.html#ADOBJ7026" target="_blank"><span class="italic">Oracle数据库对象关系开发人员指南</span></a> ，了解对象类型和对象视图</p>
                           </li>
                           <li>
                              <p><a href="../sqlrf/CREATE-TYPE.html#SQLRF01506" target="_blank"><span class="italic">Oracle Database SQL语言参考</span></a>了解<code class="codeph">CREATE TYPE</code>语句</p>
                           </li>
                        </ul>
                     </div>
                  </div>
               </div>
            </div><a id="CNCPT88874"></a><a id="CNCPT411"></a><div class="props_rev_3"><a id="GUID-2822B62B-CAF3-4DCE-B4D6-5E677FB8A829" name="GUID-2822B62B-CAF3-4DCE-B4D6-5E677FB8A829"></a><h3 id="CNCPT-GUID-2822B62B-CAF3-4DCE-B4D6-5E677FB8A829" class="sect3">物化视图概述</h3>
               <div>
                  <p><strong class="term">物化视图</strong>是预先作为模式对象存储或“物化”的查询结果。查询的<code class="codeph">FROM</code>子句可以命名表，视图或物化视图。
                  </p>
                  <p>物化视图通常用作<a href="glossary.html#GUID-A011519D-7113-462D-B9A5-9BAC31E50B8D"><span class="xrefglossterm">复制中</span></a>的<a href="glossary.html#GUID-9C63F1D2-89B7-4AAF-B10F-325A82078B76"><span class="xrefglossterm">主表</span></a>和数据仓库中的<a href="glossary.html#GUID-B6DD258C-FFA5-4CDC-B5FB-98B3B9F20F99"><span class="xrefglossterm">事实表</span></a> 。物化视图汇总，计算，复制和分发数据。它们适用于各种计算环境，例如：</p>
                  <ul style="list-style-type:disc">
                     <li>
                        <p>在数据仓库中，物化视图可以计算和存储从总和函数（例如总和和平均值）生成的数据。</p>
                        <p><a href="glossary.html#GUID-6952CA8E-DB69-4C4B-887F-9624565B1835"><span class="xrefglossterm">摘要</span></a>是一种聚合视图，它通过预先计算连接和聚合操作并将结果存储在表中来缩短查询时间。物化视图等同于摘要。您还可以使用物化视图来计算有或没有聚合的连接。
                        </p>
                     </li>
                     <li>
                        <p>在使用XStream和Oracle GoldenGate实现的物化视图复制中，视图包含单个时间点的表的完整或部分副本。物化视图在分布式站点复制数据并同步在多个站点执行的更新。当数据库不总是连接到网络时，这种复制形式适用于现场销售等环境。</p>
                     </li>
                     <li>
                        <p>在移动计算环境中，物化视图可以将数据子集从中央服务器下载到移动客户端，定期刷新中央服务器并将客户端更新传播到中央服务器。</p>
                     </li>
                  </ul>
                  <p>在复制环境中，实例化视图与不同数据库中的表共享数据，称为<a href="glossary.html#GUID-DC13C5A2-6D35-4169-B546-C8B8AC393163"><span class="xrefglossterm">主数据库</span></a> 。与主站点上的物化视图关联的表是主表。<a href="partitions-views-and-other-schema-objects.html#GUID-2822B62B-CAF3-4DCE-B4D6-5E677FB8A829__CFACFDIG">图4-9</a>说明了基于另一个数据库中的主表的一个数据库中的物化视图。主表的更新将复制到物化视图数据库。
                  </p>
                  <div class="figure" id="GUID-2822B62B-CAF3-4DCE-B4D6-5E677FB8A829__CFACFDIG">
                     <p class="titleinfigure">图4-9物化视图</p><img src="img/cncpt260.gif" alt="下面是图4-9的描述" title="下面是图4-9的描述" longdesc="img_text/cncpt260.html"><br><a href="img_text/cncpt260.html">“图4-9物化视图”的说明</a></div>
                  <!-- class="figure" -->
                  <div class="infoboxnotealso" id="GUID-2822B62B-CAF3-4DCE-B4D6-5E677FB8A829__GUID-00B3BCAB-1185-4782-820B-AF1B8E4E9BD9">
                     <p class="notep1">也可以看看：</p>
                     <ul style="list-style-type:disc">
                        <li>
                           <p><span class="q">“ <a href="topics-for-database-administrators-and-developers.html#GUID-1E03C284-42EE-4542-AB79-A966AD7BEA47" title="任何集成的核心是企业中的应用程序之间的数据共享。">信息共享</a> ”</span> ，了解使用XStream和Oracle GoldenGate进行复制</p>
                        </li>
                        <li>
                           <p> <span class="q">“ <a href="topics-for-database-administrators-and-developers.html#GUID-8B11C762-AF20-4B7A-A95B-D5423FE7B646" title="在简单的数据仓库体系结构中，最终用户直接访问从多个源系统传输到数据仓库的数据。">数据仓库架构（基础）</a> ”</span>以了解有关摘要的更多信息</p>
                        </li>
                        <li>
                           <p><a href="../xstrm/introduction-to-xstream.html#GUID-5939CB6C-8BA9-4594-8F96-B0453D246722" target="_blank"><span><cite>Oracle Database XStream指南</cite></span></a> ，介绍XStream</p>
                        </li>
                        <li>
                           <p><a href="http://www.oracle.com/technetwork/middleware/goldengate/documentation/index.html" target="_blank"><code class="codeph">http://www.oracle.com/technetwork/middleware/goldengate/documentation/index.html</code></a>了解有关Oracle GoldenGate的更多信息</p>
                        </li>
                        <li>
                           <p><a href="../sqlrf/CREATE-MATERIALIZED-VIEW.html#SQLRF01302" target="_blank"><span><cite>Oracle Database SQL语言参考</cite></span></a> ，了解<code class="codeph">CREATE MATERIALIZED VIEW</code>语句</p>
                        </li>
                     </ul>
                  </div>
               </div><a id="CNCPT88875"></a><div class="props_rev_3"><a id="GUID-5CED40C1-4BE2-44E0-8CC0-F5644D56E193" name="GUID-5CED40C1-4BE2-44E0-8CC0-F5644D56E193"></a><h4 id="CNCPT-GUID-5CED40C1-4BE2-44E0-8CC0-F5644D56E193" class="sect4">物化观点的特征</h4>
                  <div>
                     <p>物化视图共享索引和非物化视图的一些特征。</p>
                     <p>物化视图在以下方面与索引类似：</p>
                     <ul style="list-style-type:disc">
                        <li>
                           <p>它们包含实际数据并占用存储空间。</p>
                        </li>
                        <li>
                           <p>当主表中的数据发生更改时，可以刷新它们。</p>
                        </li>
                        <li>
                           <p>当用于查询重写操作时，它们可以提高SQL执行的性能。</p>
                        </li>
                        <li>
                           <p>它们的存在对SQL应用程序和用户是透明的。</p>
                        </li>
                     </ul>
                     <p>物化视图类似于非物化视图，因为它表示其他表和视图中的数据。与索引不同，用户可以使用<code class="codeph">SELECT</code>语句直接查询实体化视图。根据所需的刷新类型，还可以使用DML语句更新视图。
                     </p>
                     <p>以下示例基于<code class="codeph">sh</code>示例模式中的三个主表创建并填充实例化聚合视图：</p><pre class="oac_no_warn" dir="ltr">CREATE MATERIALIZED VIEW sales_mv AS SELECT t.calendar_year，p.prod_id，SUM（s.amount_sold）AS sum_sales FROM times t，products p，sales s WHERE t.time_id = s.time_id AND p.prod_id = s.prod_id GROUP BY t .calendar_year，p.prod_id;</pre><p>以下示例删除表<code class="codeph">sales</code> ，这是<code class="codeph">sales_mv</code>的主表，然后查询<code class="codeph">sales_mv</code> 。查询选择数据，因为行与主表中的数据分开存储（物化）。
                     </p><pre class="oac_no_warn" dir="ltr">SQL&gt; DROP TABLE销售;表丢了。SQL&gt; SELECT * FROM sales_mv WHERE ROWNUM &lt;4; CALENDAR_YEAR PROD_ID SUM_SALES ------------- ---------- ---------- 1998 13 936197.53 1998 26 567533.83 1998 27 107968.24</pre><p>可以对物化视图进行分区。您可以在分区表上定义实例化视图，并在实例化视图上定义一个或多个索引。</p>
                     <div class="infoboxnotealso" id="GUID-5CED40C1-4BE2-44E0-8CC0-F5644D56E193__GUID-37CC358F-64EF-4BCF-ADAD-AFB8DFA770ED">
                        <p class="notep1">也可以看看：</p>
                        <p><a href="https://www.oracle.com/pls/topic/lookup?ctx=en/database/oracle/oracle-database/19/cncpt&amp;id=DWHSG008" target="_blank"><span class="italic">Oracle数据库数据仓库指南</span></a> ，了解如何在数据仓库中使用物化视图</p>
                     </div>
                  </div>
               </div><a id="CNCPT1155"></a><div class="props_rev_3"><a id="GUID-824BEF3A-193B-4A72-894A-105F0AEAD607" name="GUID-824BEF3A-193B-4A72-894A-105F0AEAD607"></a><h4 id="CNCPT-GUID-824BEF3A-193B-4A72-894A-105F0AEAD607" class="sect4">物化视图的刷新方法</h4>
                  <div>
                     <p>数据库通过在更改基表后刷新数据来维护物化视图中的数据。刷新方法可以是增量或完全刷新。</p>
                  </div><a id="CNCPT89392"></a><div class="props_rev_3"><a id="GUID-1975D1E6-EE50-4F4B-881B-C18A42A7DED3" name="GUID-1975D1E6-EE50-4F4B-881B-C18A42A7DED3"></a><h5 id="CNCPT-GUID-1975D1E6-EE50-4F4B-881B-C18A42A7DED3" class="sect5">完全刷新</h5>
                     <div>
                        <p><span class="bold">完整刷新将</span>执行定义实例化视图的查询。最初创建实例化视图时会发生完全刷新，除非实体化视图引用预构建表，或者将表定义为<code class="codeph">BUILD DEFERRED</code> 。</p>
                        <p>完全刷新可能很慢，尤其是在数据库必须读取和处理大量数据的情况下。您可以在创建物化视图后随时执行完整刷新。</p>
                     </div>
                  </div><a id="CNCPT89393"></a><div class="props_rev_3"><a id="GUID-956728C1-A1F7-4C4D-9BD5-685F2DD4086F" name="GUID-956728C1-A1F7-4C4D-9BD5-685F2DD4086F"></a><h5 id="CNCPT-GUID-956728C1-A1F7-4C4D-9BD5-685F2DD4086F" class="sect5">增量刷新</h5>
                     <div>
                        <p><span class="bold">增量刷新</span> （也称为<span class="italic">快速刷新</span> ）仅处理对现有数据的更改。此方法无需从头开始重建实体化视图。仅处理更改可能会导致非常快的刷新时间。
                        </p>
                        <p></p>
                        <p>您可以按需或定期刷新物化视图。或者，您可以在与基表相同的数据库中配置实例化视图，以便在事务提交对基表的更改时进行刷新。</p>
                        <p>快速刷新有以下两种形式：</p>
                        <ul style="list-style-type:disc">
                           <li>
                              <p>基于日志的刷新</p>
                              <p>在这种类型的刷新中，物化视图日志或直接加载器日志会记录对基表的更改。物化视图日志是一种模式对象，它记录对基表的更改，以便可以递增地刷新在基表上定义的物化视图。每个物化视图日志都与单个基表相关联。</p>
                           </li>
                           <li>
                              <p>分区更改跟踪（PCT）刷新</p>
                              <p>PCT刷新仅在基表分区时有效。PCT刷新会删除受影响的物化视图分区或受影响的数据部分中的所有数据，然后重新计算它们。数据库使用修改后的基表分区来标识视图中受影响的分区或数据部分。在基表上发生分区维护操作时，PCT刷新是唯一可用的增量刷新方法。</p>
                           </li>
                        </ul>
                     </div>
                  </div><a id="CNCPT89394"></a><div class="props_rev_3"><a id="GUID-FDEDF537-BB75-4668-968C-E0987C88F4BC" name="GUID-FDEDF537-BB75-4668-968C-E0987C88F4BC"></a><h5 id="CNCPT-GUID-FDEDF537-BB75-4668-968C-E0987C88F4BC" class="sect5">就地和不合适的刷新</h5>
                     <div>
                        <p>对于完整和增量方法，数据库可以就地刷新实例化视图，直接在视图上刷新语句，或者不合适。</p>
                        <p>异地刷新会创建一个或多个外部表，对它们执行刷新语句，然后使用外部表切换实例化视图或受影响的分区。此技术在刷新期间实现了高可用性，尤其是在刷新语句需要很长时间才能完成时。</p>
                        <p>Oracle Database 12c引入了同步刷新，这是一种异地刷新。同步刷新不会修改基表的内容，而是使用同步刷新包中的API，通过同时将这些更改应用于基表和物化视图来确保一致性。此方法使一组表和在其上定义的物化视图始终同步。在数据仓库中，同步刷新方法非常适合，原因如下：</p>
                        <ul style="list-style-type:disc">
                           <li>
                              <p>增量数据的加载受到严格控制，并定期发生。</p>
                           </li>
                           <li>
                              <p>表及其物化视图通常以相同的方式分区，或者它们的分区通过功能依赖关联。</p>
                           </li>
                        </ul>
                        <div class="infoboxnotealso" id="GUID-FDEDF537-BB75-4668-968C-E0987C88F4BC__GUID-8B615BF7-7A10-4E97-8B09-04CBBD4659EE">
                           <p class="notep1">也可以看看：</p>
                           <p><a href="../dwhsg/refreshing-materialized-views.html#DWHSG03003" target="_blank"><span><cite>Oracle数据库数据仓库指南</cite></span></a> ，了解如何刷新物化视图</p>
                        </div>
                     </div>
                  </div>
               </div><a id="CNCPT88877"></a><a id="CNCPT88876"></a><div class="props_rev_3"><a id="GUID-C2F8D519-A8E9-4793-A053-36B4C4060B62" name="GUID-C2F8D519-A8E9-4793-A053-36B4C4060B62"></a><h4 id="CNCPT-GUID-C2F8D519-A8E9-4793-A053-36B4C4060B62" class="sect4">查询重写</h4>
                  <div>
                     <p>称为<span class="bold">查询重写</span>的优化技术将根据主表写入的用户请求转换为包含物化视图的语义等效请求。
                     </p>
                     <p>当基表包含大量数据时，计算聚合或连接是昂贵且耗时的。由于物化视图包含预先计算的聚合和连接，因此查询重写可以使用物化视图快速回答查询。</p>
                     <p><a href="glossary.html#GUID-648CCA52-2DB0-405D-9737-B7CB9B8E7CBC"><span class="xrefglossterm">查询转换器</span></a>透明地重写请求以使用物化视图，不需要用户干预，也不需要引用SQL语句中的物化视图。由于查询重写是透明的，因此可以添加或删除实例化视图，而不会使应用程序代码中的SQL无效。
                     </p>
                     <p>通常，重写查询以使用实体化视图而不是详细信息表可以缩短响应时间。下图显示了为原始和重写查询生成<a href="glossary.html#GUID-2DF33B85-94BB-44F3-93B7-06916FB18361"><span class="xrefglossterm">执行计划</span></a>并选择成本最低计划的数据库。
                     </p>
                     <div class="figure" id="GUID-C2F8D519-A8E9-4793-A053-36B4C4060B62__CFABICCA">
                        <p class="titleinfigure">图4-10查询重写</p><img src="img/cncpt334.gif" alt="下面是图4-10的描述" title="下面是图4-10的描述" longdesc="img_text/cncpt334.html"><br><a href="img_text/cncpt334.html">“图4-10查询重写”的说明</a></div>
                     <!-- class="figure" -->
                     <div class="infoboxnotealso" id="GUID-C2F8D519-A8E9-4793-A053-36B4C4060B62__GUID-9D58C628-DD88-43B6-889E-1631F9CD099F">
                        <p class="notep1">也可以看看：</p>
                        <ul style="list-style-type:disc">
                           <li>
                              <p><span class="q">“ <a href="sql.html#GUID-3F42B1AA-530A-4144-8179-F0074832AF81" title="要了解Oracle数据库如何处理SQL语句，有必要了解数据库中称为优化器的部分（也称为查询优化器或基于成本的优化器）。所有SQL语句都使用优化器来确定访问指定数据的最有效方法。">优化器概述</a> ”</span></p>了解有关查询转换的更多信息</li>
                           <li>
                              <p><a href="../dwhsg/index.html" target="_blank"><span><cite>Oracle数据库数据仓库指南</cite></span></a> ，了解如何使用查询重写</p>
                           </li>
                        </ul>
                     </div>
                  </div>
               </div>
            </div><a id="CNCPT611"></a><div class="props_rev_3"><a id="GUID-29E19A46-D91F-4EEB-BD0C-E65A89F2F59B" name="GUID-29E19A46-D91F-4EEB-BD0C-E65A89F2F59B"></a><h3 id="CNCPT-GUID-29E19A46-D91F-4EEB-BD0C-E65A89F2F59B" class="sect3">序列概述</h3>
               <div>
                  <p><span class="bold">序列</span>是一个架构对象，多个用户可以从中生成唯一的整数。序列生成器提供高度可伸缩且性能良好的方法，以生成数字数据类型的代理键。
                  </p>
               </div><a id="CNCPT88878"></a><div class="props_rev_3"><a id="GUID-F485DFE7-DA07-4943-9844-C97D31064EED" name="GUID-F485DFE7-DA07-4943-9844-C97D31064EED"></a><h4 id="CNCPT-GUID-F485DFE7-DA07-4943-9844-C97D31064EED" class="sect4">序列特征</h4>
                  <div>
                     <p>序列定义指示序列的一般信息，包括其名称以及序列是上升还是下降。</p>
                     <p>序列定义还表明：</p>
                     <ul style="list-style-type:disc">
                        <li>
                           <p>数字之间的间隔</p>
                        </li>
                        <li>
                           <p>数据库是否应该在内存中缓存生成的序列号集</p>
                        </li>
                        <li>
                           <p>当达到限制时序列是否应循环</p>
                        </li>
                     </ul>
                     <p>以下示例在示例模式<code class="codeph">oe</code>创建序列<code class="codeph">customers_seq</code> 。当行添加到<code class="codeph">customers</code>表时，应用程序可以使用此序列来提供客户ID号。
                     </p><pre class="pre codeblock"><code>创建序列customers_seq以1个NOCACHE NOCYCLE开始增加1000个;</code></pre><p>对<code class="codeph">customers_seq.nextval</code>的第一次引用返回<code class="codeph">1000</code> 。第二个返回<code class="codeph">1001</code> 。每个后续引用返回的值1大于先前的引用。
                     </p>
                     <div class="infoboxnotealso" id="GUID-F485DFE7-DA07-4943-9844-C97D31064EED__GUID-26613A8B-F33C-470A-822E-E5BE33328734">
                        <p class="notep1">也可以看看：</p>
                        <ul style="list-style-type:disc">
                           <li>
                              <p><a href="../tdddg/creating-managing-schema-objects.html#TDDDG34000" target="_blank"><span><cite>Oracle数据库2天开发人员指南</cite></span></a> ，了解如何创建序列的教程</p>
                           </li>
                           <li>
                              <p><a href="../admin/managing-views-sequences-and-synonyms.html#ADMIN11796" target="_blank"><span><cite>Oracle数据库管理员指南</cite></span></a> ，了解如何在SQL语句中引用序列</p>
                           </li>
                           <li>
                              <p>用于<code class="codeph">CREATE SEQUENCE</code>语法和语义的<a href="../sqlrf/CREATE-SEQUENCE.html#SQLRF01314" target="_blank"><span><cite>Oracle数据库SQL语言参考</cite></span></a></p>
                           </li>
                        </ul>
                     </div>
                  </div>
               </div><a id="CNCPT88879"></a><div class="props_rev_3"><a id="GUID-0CB837DF-53A2-45C4-BF04-B6BF48FD1E65" name="GUID-0CB837DF-53A2-45C4-BF04-B6BF48FD1E65"></a><h4 id="CNCPT-GUID-0CB837DF-53A2-45C4-BF04-B6BF48FD1E65" class="sect4">并发访问序列</h4>
                  <div>
                     <p>相同的序列生成器可以为多个表生成数字。</p>
                     <p>生成器可以自动创建主键，并跨多个行或表协调键。例如，序列可以为<code class="codeph">orders</code>表和<code class="codeph">customers</code>表生成主键。
                     </p>
                     <p>序列生成器在多用户环境中非常有用，可以生成唯一的数字，而不会产生磁盘I / O或事务锁定的开销。例如，两个用户同时在<code class="codeph">orders</code>表中插入新行。通过使用序列为<code class="codeph">order_id</code>列生成唯一编号，用户都不必等待另一个输入下一个可用订单编号。序列自动为每个用户生成正确的值。
                     </p>
                     <p>引用序列的每个用户都可以访问他或她当前的序列号，这是<a href="glossary.html#GUID-0F44C072-9841-4E2E-B846-FB16A2E54139"><span class="xrefglossterm">会话中</span></a>生成的最后一个序列。用户可以发出语句以生成新的序列号或使用会话最后生成的当前号码。在会话中的语句生成序列号后，它仅对此会话可用。如果生成并在最终回滚的事务中使用它们，则可以跳过单个序列号。
                     </p>
                     <div class="infoboxnotewarn" id="GUID-0CB837DF-53A2-45C4-BF04-B6BF48FD1E65__GUID-99A0F55F-E395-4BCA-A175-3A03407A1CAC">
                        <p class="notep1">警告：</p>
                        <p>如果您的应用程序需要无间隙的数字集，那么您就无法使用Oracle序列。您必须使用自己开发的代码序列化数据库中的活动。</p>
                     </div>
                     <div class="infoboxnotealso" id="GUID-0CB837DF-53A2-45C4-BF04-B6BF48FD1E65__GUID-5AB1218F-539E-494A-A189-1F337C191888">
                        <p class="notep1">也可以看看：</p>
                        <p><span class="q">“ <a href="data-concurrency-and-consistency.html#GUID-E8CBA9C5-58E3-460F-A82A-850E0152E95C" title="本章介绍Oracle数据库如何在多用户数据库环境中维护一致的数据。">数据并发和一致性</a> ”，</span>以了解会话如何同时访问数据</p>
                     </div>
                  </div>
               </div>
            </div><a id="CNCPT511"></a><div class="props_rev_3"><a id="GUID-84D64C39-D8E8-4706-B4E3-519FE2CEE4C2" name="GUID-84D64C39-D8E8-4706-B4E3-519FE2CEE4C2"></a><h3 id="CNCPT-GUID-84D64C39-D8E8-4706-B4E3-519FE2CEE4C2" class="sect3">尺寸概述</h3>
               <div>
                  <p>典型的数据仓库有两个重要组件：维度和事实。</p>
                  <p><span class="bold">维度</span>是用于指定业务问题的任何类别，例如，时间，地理位置，产品，部门和分销渠道。<span class="bold">事实</span>是与特定维度值集合相关联的事件或实体，例如，销售单位或利润。
                  </p>
                  <p>多维请求的示例包括以下内容：</p>
                  <ul style="list-style-type:disc">
                     <li>
                        <p>显示所有产品的总销售额，在2013年和2014年的地理位置（从州到国家/地区）的聚合级别不断提高。</p>
                     </li>
                     <li>
                        <p>对我们的运营进行跨表格分析，显示2013年和2014年南美洲地区的开支。包括所有可能的小计。</p>
                     </li>
                     <li>
                        <p>根据2014年汽车产品销售收入列出亚洲十大销售代表，并对其佣金进行排名。</p>
                     </li>
                  </ul>
                  <p>许多多维问题需要汇总数据和数据集比较，通常跨时间，地理或预算。</p>
                  <p>创建维度允许更广泛地使用查询重写功能。通过透明地重写查询以使用实体化视图，数据库可以提高查询性能。</p>
                  <div class="infoboxnotealso" id="GUID-84D64C39-D8E8-4706-B4E3-519FE2CEE4C2__GUID-AAC63A16-C1F3-424D-9D09-5AF520FD0414">
                     <p class="notep1">也可以看看：</p>
                     <p><span class="q">“ <a href="topics-for-database-administrators-and-developers.html#GUID-E1451108-464E-4B5F-B173-11212278E308" title="数据仓库是一个关系数据库，专为查询和分析而设计，而不是用于事务处理。">数据仓库和商业智能概述</a> ”</span> ，了解数据仓库和OLTP数据库之间的差异</p>
                  </div>
               </div><a id="CNCPT88880"></a><div class="props_rev_3"><a id="GUID-1BC1749B-03D7-4596-A5F1-ACEEC71A9B1C" name="GUID-1BC1749B-03D7-4596-A5F1-ACEEC71A9B1C"></a><h4 id="CNCPT-GUID-1BC1749B-03D7-4596-A5F1-ACEEC71A9B1C" class="sect4">维度的层次结构</h4>
                  <div>
                     <p><strong class="term">维度表</strong>是一种逻辑结构，用于定义列对或列集之间的分层（父/子）关系。
                     </p>
                     <p>例如，维度可以指示一行中的<code class="codeph">city</code>列表示<code class="codeph">state</code>列的值，而<code class="codeph">state</code>列表示<code class="codeph">country</code>列的值。
                     </p>
                     <p>在客户层面，客户可以前往城市，州，国家，次区域和地区。数据分析通常从维度层次结构中的较高级别开始，如果情况需要进行此类分析，则逐渐向下钻取。</p>
                     <p>子级别的每个值都与父级别的一个且仅一个值相关联。层次关系是从层次结构的一个级别到层次结构中的下一个级别的功能依赖性。</p>
                     <p>维度没有分配给它的数据存储。维度信息存储在维度表中，而事实信息存储在事实表中。</p>
                     <div class="infoboxnotealso" id="GUID-1BC1749B-03D7-4596-A5F1-ACEEC71A9B1C__GUID-C26CCE50-EDA0-4E1C-B691-6B6E232A5E83">
                        <p class="notep1">也可以看看：</p>
                        <ul style="list-style-type:disc">
                           <li>
                              <p><a href="../dwhsg/index.html" target="_blank"><span><cite>Oracle数据库数据仓库指南</cite></span></a> ，了解维度</p>
                           </li>
                           <li>
                              <p><a href="../olaug/creating-dimensions-and-cubes.html#OLAUG300" target="_blank"><span><cite>Oracle OLAP用户指南</cite></span></a> ，了解如何创建维度</p>
                           </li>
                        </ul>
                     </div>
                  </div>
               </div><a id="CNCPT88881"></a><div class="props_rev_3"><a id="GUID-62DD0306-D019-4B21-AA81-17670CB44DDA" name="GUID-62DD0306-D019-4B21-AA81-17670CB44DDA"></a><h4 id="CNCPT-GUID-62DD0306-D019-4B21-AA81-17670CB44DDA" class="sect4">创建维度</h4>
                  <div>
                     <p>您可以使用<code class="codeph">CREATE DIMENSION</code> SQL语句创建维度。
                     </p>
                     <p>该声明规定：</p>
                     <ul style="list-style-type:disc">
                        <li>
                           <p>多个<code class="codeph">LEVEL</code>子句，每个子句标识维度中的列或列集</p>
                        </li>
                        <li>
                           <p>一个或多个<code class="codeph">HIERARCHY</code>子句，用于指定相邻级别之间的父/子关系</p>
                        </li>
                        <li>
                           <p>可选的<code class="codeph">ATTRIBUTE</code>子句，每个子句标识与单个级别关联的其他列或列集</p>
                        </li>
                     </ul>
                     <p>以下语句用于在示例模式<code class="codeph">sh</code>创建<code class="codeph">customers_dim</code>维度：</p><pre class="pre codeblock"><code>CREATE DIMENSION customers_dim LEVEL客户IS（customers.cust_id）LEVEL city IS（customers.cust_city）LEVEL状态IS（customers.cust_state_province）LEVEL国家IS（countries.country_id）LEVEL子区域IS（countries.country_subregion）LEVEL区域IS（countries.country_region） ）HIERARCHY geog_rollup（客户CHILD OF城市儿童国家儿童国家儿童国家儿童地区儿童地区加入关键字（customers.country_id）参考国家）ATTRIBUTE客户决定（cust_first_name，cust_last_name，cust_gender，cust_marital_status，cust_year_of_birth，cust_income_level，cust_credit_limit）属性国家DETERMINES（countries.country_name）;</code></pre><p>维度中的列可以来自同一个表（非规范化）或来自多个表（完全或部分规范化）。例如，规范化时间维度可以包括日期表，月份表和年份表，其中连接条件将每个日期行连接到月份行，每个月份行连接到年份行。在完全非规范化的时间维度中，日期，月份和年份列位于同一个表中。无论是规范化还是非规范化，都必须在<code class="codeph">CREATE DIMENSION</code>语句中指定列之间的层次关系。
                     </p>
                     <div class="infoboxnotealso" id="GUID-62DD0306-D019-4B21-AA81-17670CB44DDA__GUID-E30202F0-1006-4254-A07F-12A9A49BC9AE">
                        <p class="notep1">也可以看看：</p>
                        <p>用于<code class="codeph">CREATE DIMENSION</code>语法和语义的<a href="../sqlrf/CREATE-DIMENSION.html#SQLRF01206" target="_blank"><span><cite>Oracle数据库SQL语言参考</cite></span></a></p>
                     </div>
                  </div>
               </div>
            </div><a id="CNCPT88882"></a><a id="CNCPT88883"></a><a id="CNCPT711"></a><div class="props_rev_3"><a id="GUID-4977D7F8-B766-4F4A-8FF6-B8496DED3DF2" name="GUID-4977D7F8-B766-4F4A-8FF6-B8496DED3DF2"></a><h3 id="CNCPT-GUID-4977D7F8-B766-4F4A-8FF6-B8496DED3DF2" class="sect3">同义词概述</h3>
               <div>
                  <p><span class="bold">同义词</span>是架构对象的别名。例如，您可以为表或视图，序列，PL / SQL程序单元，用户定义的对象类型或其他同义词创建同义词。因为同义词只是一个别名，所以除了数据字典中的定义之外，它不需要存储。
                  </p>
                  <p>同义词可以简化数据库用户的SQL语句。同义词对于隐藏底层模式对象的标识和位置也很有用。如果必须重命名或移动基础对象，则只能重新定义同义词。基于同义词的应用程序继续工作而无需修改。</p>
                  <p>您可以创建私人和公共同义词。私有同义词位于特定用户的架构中，该用户可以控制其他人的可用性。公共同义词由名为<code class="codeph">PUBLIC</code>的用户组拥有，并且每个数据库用户都可以访问。
                  </p>
                  <div class="example" id="GUID-4977D7F8-B766-4F4A-8FF6-B8496DED3DF2__GUID-B139ADF2-8005-4FA1-B503-052F39700285">
                     <p class="titleinexample">例4-6公共同义词</p>
                     <p>假设数据库管理员为<code class="codeph">hr.employees</code>表创建名为<code class="codeph">people</code>的公共同义词。然后，用户连接到<code class="codeph">oe</code>架构并计算同义词引用的表中的行数。
                     </p><pre class="oac_no_warn" dir="ltr">SQL&gt; CREATE PUBLIC SYNONYM人员为hr.employees;同义词已创建。SQL&gt; CONNECT oe输入密码： <span class="italic">密码</span>已连接。SQL&gt; SELECT COUNT（*）FROM people; COUNT（*）---------- 107</pre><p>谨慎使用公共同义词，因为它们使数据库整合更加困难。如以下示例所示，如果另一个管理员尝试创建公共同义词<code class="codeph">people</code> ，则创建失败，因为数据库中只能存在一个公共同义词<code class="codeph">people</code> 。过度使用公共同义词会导致应用程序之间的命
                     </p><pre class="oac_no_warn" dir="ltr">SQL&gt; CREATE PUBLIC SYNONYM人员为oe.customers;在第1行创建PUBLIC SYNONYM人员oe.customers * ERROR：ORA-00955：现有对象已使用名称SQL&gt; SELECT OWNER，SYNONYM_NAME，TABLE_OWNER，TABLE_NAME 2 FROM DBA_SYNONYMS 3 WHERE SYNONYM_NAME ='PEOPLE'; OWNER SYNONYM_NAME TABLE_OWNER TABLE_NAME ---------- ------------ ----------- ----------公众人力资源雇员</pre><p>同义词本身不可保证。当您在同义词上授予对象权限时，您实际上是在对基础对象授予权限。同义词仅作为<code class="codeph">GRANT</code>语句中对象的别名。
                     </p>
                     <div class="infoboxnotealso" id="GUID-4977D7F8-B766-4F4A-8FF6-B8496DED3DF2__GUID-02F272D0-B29B-49AA-8A14-09A1BE53EC9E">
                        <p class="notep1">也可以看看：</p>
                        <ul style="list-style-type:disc">
                           <li>
                              <p><a href="../admin/managing-views-sequences-and-synonyms.html#ADMIN11805" target="_blank"><span class="italic">Oracle数据库管理员指南</span></a> ，了解如何管理同义词</p>
                           </li>
                           <li>
                              <p>用于<code class="codeph">CREATE SYNONYM</code>语法和语义的<a href="../sqlrf/CREATE-SYNONYM.html#SQLRF01401" target="_blank"><span class="italic">Oracle数据库SQL语言参考</span></a></p>
                           </li>
                        </ul>
                     </div>
                  </div>
                  <!-- class="example" -->
               </div>
            </div>
         </div>
      </article>
   </body>
</html>