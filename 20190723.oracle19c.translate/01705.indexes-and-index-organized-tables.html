<html lang="en-us" dir="ltr" xml:lang="en-us">
   <head>
      <meta http-equiv="Content-Type" content="text/html; charset=utf-8"></meta>
      <meta name="viewport" content="width=device-width, initial-scale=1"></meta>
      <meta http-equiv="X-UA-Compatible" content="IE=edge"></meta>
      <meta name="abstract" content="Indexes are schema objects that can speed access to table rows. Index-organized tables are tables stored in an index structure."></meta>
      <meta name="description" content="Indexes are schema objects that can speed access to table rows. Index-organized tables are tables stored in an index structure."></meta>
      <title>索引和索引组织表</title>
      <meta property="og:site_name" content="Oracle Help Center"></meta>
      <meta property="og:title" content="Database Concepts"></meta>
      <meta property="og:description" content="Indexes are schema objects that can speed access to table rows. Index-organized tables are tables stored in an index structure."></meta>
      <link rel="stylesheet" href="/sp_common/book-template/ohc-book-template/css/book.css"></link>
      <link rel="shortcut icon" href="/sp_common/book-template/ohc-common/img/favicon.ico"></link>
      <meta name="application-name" content="Database Concepts"></meta>
      <meta name="generator" content="DITA Open Toolkit version 1.8.5 (Mode = doc)"></meta>
      <meta name="plugin" content="SP_docbuilder HTML plugin release 18.2.2"></meta>
      <link rel="alternate" href="database-concepts.pdf" title="PDF File" type="application/pdf"></link>
      <meta name="robots" content="all"></meta>
      <link rel="schema.dcterms" href="http://purl.org/dc/terms/"></link>
      <meta name="dcterms.created" content="2019-01-09T07:47:16-08:00"></meta>
      <meta name="dcterms.title" content="Database Concepts"></meta>
      <meta name="dcterms.dateCopyrighted" content="1993, 2019"></meta>
      <meta name="dcterms.category" content="database"></meta>
      <meta name="dcterms.identifier" content="E96138-01"></meta>
      
      <meta name="dcterms.product" content="en/database/oracle/oracle-database/19"></meta>
      
      <link rel="prev" href="tables-and-table-clusters.html" title="Previous" type="text/html"></link>
      <link rel="next" href="partitions-views-and-other-schema-objects.html" title="Next" type="text/html"></link>
      <script>
        document.write('<style type="text/css">');
        document.write('body > .noscript, body > .noscript ~ * { visibility: hidden; }');
        document.write('</style>');
     </script>
      <script src="/sp_common/book-template/requirejs/require.js" data-main="/sp_common/book-template/ohc-book-template/js/book-config"></script>
      <script>
            if (window.require === undefined) {
                document.write('<script data-main="sp_common/book-template/ohc-book-template/js/book-config" src="sp_common/book-template/requirejs/require.js"><\/script>');
                document.write('<link href="sp_common/book-template/ohc-book-template/css/book.css" rel="stylesheet"/>');
            }
        </script>
      <script type="application/json" id="ssot-metadata">{"primary":{"category":{"short_name":"database","element_name":"Database","display_in_url":true},"suite":{"short_name":"oracle","element_name":"Oracle","display_in_url":true},"product_group":{"short_name":"not-applicable","element_name":"Not applicable","display_in_url":false},"product":{"short_name":"oracle-database","element_name":"Oracle Database","display_in_url":true},"release":{"short_name":"19","element_name":"Release 19","display_in_url":true}}}</script>
      
    <meta name="dcterms.isVersionOf" content="CNCPT"></meta>
    <meta name="dcterms.release" content="Release 19"></meta>
  </head>
   <body dir="ltr">
      <div class="noscript alert alert-danger text-center" role="alert">
         <a href="tables-and-table-clusters.html" class="pull-left"><span class="glyphicon glyphicon-chevron-left" aria-hidden="true"></span>上一页</a> <a href="partitions-views-and-other-schema-objects.html" class="pull-right">下一页<span class="glyphicon glyphicon-chevron-right" aria-hidden="true"></span></a> <span class="fa fa-exclamation-triangle" aria-hidden="true"></span>必须启用JavaScript才能正确显示此内容</div>
      <article>
         <header>
            <ol class="breadcrumb" vocab="http://schema.org/" typeof="BreadcrumbList">
               <li property="itemListElement" typeof="ListItem"><a href="index.html" property="item" typeof="WebPage"><span property="name">数据库概念</span></a></li>
               <li property="itemListElement" typeof="ListItem"><a href="oracle-relational-structures.html" property="item" typeof="WebPage"><span property="name">Oracle关系数据结构</span></a></li>
               <li class="active" property="itemListElement" typeof="ListItem">索引和索引组织表</li>
            </ol>
            <a id="GUID-797E49E6-2DCE-4FD4-8E4A-6E761F1383D1" name="GUID-797E49E6-2DCE-4FD4-8E4A-6E761F1383D1"></a><a id="CNCPT721"></a>
            
            <h2 id="CNCPT-GUID-797E49E6-2DCE-4FD4-8E4A-6E761F1383D1" class="sect2"><span class="enumeration_chapter">3个</span>索引和索引组织表</h2>
         </header>
         <div class="ind">
            <div>
               <p>索引是可以加快对表行的访问的模式对象。索引组织表是存储在索引结构中的表。</p>
               <p>本章包含以下部分：</p>
               <ul style="list-style-type:disc">
                  <li>
                     <p><a href="indexes-and-index-organized-tables.html#GUID-DE7A95BC-6E4A-47EA-9FC5-B85B54F8CF41" title="索引是与表或表集群相关联的可选结构，有时可以加速数据访问。">索引简介</a></p>
                  </li>
                  <li>
                     <p><a href="indexes-and-index-organized-tables.html#GUID-FC93A85B-C237-4249-AD1E-FF54576ED050" title="B树是平衡树的缩写，是最常见的数据库索引类型。B树索引是分成范围的有序值列表。通过将键与行或行范围相关联，B树为各种查询提供了出色的检索性能，包括完全匹配和范围搜索。">B树索引概述</a></p>
                  </li>
                  <li>
                     <p><a href="indexes-and-index-organized-tables.html#GUID-B15C4817-7748-456D-9740-8B9628AF9F47" title="在位图索引中，数据库存储每个索引键的位图。在传统的B树索引中，一个索引条目指向单个行。在位图索引中，每个索引键存储指向多行的指针。">位图索引概述</a></p>
                  </li>
                  <li>
                     <p><a href="indexes-and-index-organized-tables.html#GUID-9AD7651D-0F0D-4FC6-A984-5845F0224EE6" title="基于函数的索引计算涉及一列或多列的函数或表达式的值，并将其存储在索引中。基于函数的索引可以是B树或位图索引。">基于函数的索引概述</a></p>
                  </li>
                  <li>
                     <p><a href="indexes-and-index-organized-tables.html#GUID-9586EB86-4B84-4A43-A66D-958776FE558B" title="应用程序域索引是特定于应用程序的自定义索引。">应用程序域索引概述</a></p>
                  </li>
                  <li>
                     <p><a href="indexes-and-index-organized-tables.html#GUID-DAEC075B-C16D-4A57-898C-70EBCB364F0C" title="索引组织表是存储在B树索引结构的变体中的表。相反，堆组织表在适合的位置插入行。">索引组织表概述</a></p>
                  </li>
               </ul>
            </div><a id="CNCPT811"></a><div class="props_rev_3"><a id="GUID-DE7A95BC-6E4A-47EA-9FC5-B85B54F8CF41" name="GUID-DE7A95BC-6E4A-47EA-9FC5-B85B54F8CF41"></a><h3 id="CNCPT-GUID-DE7A95BC-6E4A-47EA-9FC5-B85B54F8CF41" class="sect3">索引简介</h3>
               <div>
                  <p><strong class="term">索引</strong>是与表或<strong class="term">表集群</strong>相关联的可选结构，有时可以加速数据访问。
                  </p>
                  <p>索引是在逻辑上和物理上独立于与之关联的对象中的数据的模式对象。因此，您可以删除或创建索引，而不会对索引表产生实际影响。</p>
                  <div class="infoboxnote" id="GUID-DE7A95BC-6E4A-47EA-9FC5-B85B54F8CF41__GUID-5B11D472-55A2-4B54-85FF-BA64D9BBC4B1">
                     <p class="notep1">注意：</p>
                     <p>如果删除索引，则应用程序仍然有效。但是，访问先前索引的数据可能会更慢。</p>
                  </div>
                  <p>换句话说，假设人力资源经理有一个纸板箱架子。包含员工信息的文件夹随机插入框中。员工Whalen（ID 200）的文件夹是从方框1底部开始的10个文件夹，而King（ID 100）的文件夹位于方框3的底部。要查找文件夹，管理器会从下到上查看框1中的每个文件夹，然后从一个框移动到另一个框，直到找到该文件夹。为了加快访问速度，管理员可以创建一个索引，按顺序列出每个员工ID及其文件夹位置：</p><pre class="pre codeblock"><code>ID 100：方框3，位置1（下方）ID 101：方框7，位置8 ID 200：方框1，位置10。。。
</code></pre><p>同样，经理可以为员工姓氏，部门ID等创建单独的索引。</p>
                  <p>本节包含以下主题：</p>
                  <ul style="list-style-type:disc">
                     <li>
                        <p><a href="indexes-and-index-organized-tables.html#GUID-A444A178-67BE-45E2-8D2F-A64B95E1D31F" title="缺少或存在索引不需要更改任何SQL语句的措辞。">索引的优缺点</a></p>
                     </li>
                     <li>
                        <p><a href="indexes-and-index-organized-tables.html#GUID-D0C53854-D92E-49D0-822A-39F3E7573752" title="索引可用（默认）或不可用，可见（默认）或不可见。">索引可用性和可见性</a></p>
                     </li>
                     <li>
                        <p><a href="indexes-and-index-organized-tables.html#GUID-104A7F88-1BFE-4FF6-A5AD-4439C0E7F929" title="键是一组列或表达式，您可以在其上构建索引。">键和列</a></p>
                     </li>
                     <li>
                        <p><a href="indexes-and-index-organized-tables.html#GUID-ABE1DE2A-59CC-4ADE-86A5-426B16459464" title="复合索引（也称为连锁索引）是表中多列的索引。">综合指数</a></p>
                     </li>
                     <li>
                        <p><a href="indexes-and-index-organized-tables.html#GUID-F6EFE752-18FA-4BCE-BDE0-F2C386361187" title="索引可以是唯一的也可以是非唯一的。唯一索引保证表中没有两行在键列中具有重复值。">独特和非独特的索引</a></p>
                     </li>
                     <li>
                        <p><a href="indexes-and-index-organized-tables.html#GUID-ACA0308E-5F01-4236-81D3-D0CDE5CB6695" title="Oracle数据库提供了多种索引方案，可提供互补的性能功能。">索引的类型</a></p>
                     </li>
                     <li>
                        <p><a href="indexes-and-index-organized-tables.html#GUID-1DA0A7D9-1EAB-40B8-B882-75B8EC9498D7" title="数据库在创建后自动维护和使用索引。">数据库如何维护索引</a></p>
                     </li>
                     <li>
                        <p><a href="indexes-and-index-organized-tables.html#GUID-832C2B66-912B-4E1C-B4B5-AA40F49E4970" title="Oracle数据库将索引数据存储在索引段中。 。">索引存储</a></p>
                     </li>
                  </ul>
               </div><a id="CNCPT1895"></a><div class="props_rev_3"><a id="GUID-A444A178-67BE-45E2-8D2F-A64B95E1D31F" name="GUID-A444A178-67BE-45E2-8D2F-A64B95E1D31F"></a><h4 id="CNCPT-GUID-A444A178-67BE-45E2-8D2F-A64B95E1D31F" class="sect4">索引的优缺点</h4>
                  <div>
                     <p>缺少或存在索引不需要更改任何SQL语句的措辞。</p>
                     <p>索引是指单行数据的快速访问路径。它只影响执行速度。给定已编制索引的数据值，索引将直接指向包含该值的行的位置。</p>
                     <p>当索引存在于表的一个或多个列上时，数据库在某些情况下可以从表中检索一小组随机分布的行。索引是减少磁盘I / O的众多方法之一。如果堆组织表没有索引，则数据库必须执行<a href="glossary.html#GUID-BF9B54D6-892E-4C3B-8536-38958ACC069D"><span class="xrefglossterm">全表扫描</span></a>才能查找值。例如，未索引的<code class="codeph">hr.departments</code>表中的位置<code class="codeph">2700</code>的<a href="glossary.html#GUID-CCF91C9F-A98A-498F-A84B-58A0FA16CD6E"><span class="xrefglossterm">查询</span></a>要求数据库搜索每个块中的每一行。随着数据量的增加，这种方法不能很好地扩展。
                     </p>
                     <p>索引的缺点包括：</p>
                     <ul style="list-style-type:disc">
                        <li>
                           <p>手动创建索引通常需要深入了解数据模型，应用程序和数据分布。</p>
                        </li>
                        <li>
                           <p>随着数据的变化，您必须重新审视先前有关索引的决策。索引可能会停止使用，或者可能需要新索引。</p>
                        </li>
                        <li>
                           <p>索引占用磁盘空间。</p>
                        </li>
                        <li>
                           <p>当索引数据发生DML时，数据库必须更新索引，这会产生性能开销。</p>
                        </li>
                     </ul>
                     <div class="infoboxnote" id="GUID-A444A178-67BE-45E2-8D2F-A64B95E1D31F__GUID-FE2EC877-3240-49B1-A5DF-A5EFA4B1631C">
                        <p class="notep1">注意：</p>
                        <p>从<span>Oracle Database 19c开始</span> ，Oracle数据库可以持续监控应用程序工作负载，自动创建和管理索引。自动索引实现为以固定间隔运行的数据库任务。
                        </p>
                     </div>
                     <p>考虑在以下情况下创建索引：</p>
                     <ul style="list-style-type:disc">
                        <li>
                           <p>经常查询索引列，并返回表中总行数的一小部分。</p>
                        </li>
                        <li>
                           <p>索引的一列或多列上存在参照<a href="glossary.html#GUID-67F8FE8C-EBA5-4796-820A-8919982A1411"><span class="xrefglossterm">完整性约束</span></a> 。索引是一种避免全表<a href="glossary.html#GUID-6D016291-A487-4F88-BE0B-ACF8FA2AE72C"><span class="xrefglossterm">锁定的方法</span></a> ，如果更新父表<a href="glossary.html#GUID-8640EFA5-276C-4812-A078-1F21F55F4200"><span class="xrefglossterm">主键</span></a> ，合并到父表或从父表中删除，则需要使用该表。
                           </p>
                        </li>
                        <li>
                           <p>将在表上放置唯一键约束，并且您希望手动指定索引和所有索引选项。</p>
                        </li>
                     </ul>
                     <div class="infoboxnotealso" id="GUID-A444A178-67BE-45E2-8D2F-A64B95E1D31F__GUID-4133FC4B-FC3D-479C-BA87-17F52A3A8233">
                        <p class="notep1">也可以看看：</p>
                        <ul style="list-style-type:disc">
                           <li>
                              <p><a href="../admin/managing-indexes.html#GUID-E4149397-FF37-4367-A12F-675433715904" target="_blank"><span><cite>Oracle数据库管理员指南</cite></span></a> ，了解有关自动索引的更多信息</p>
                           </li>
                           <li>
                              <p><a href="../dblic/Licensing-Information.html#DBLIC-GUID-0F9EB85D-4610-4EDF-89C2-4916A0E7AC87" target="_blank"><span><cite>“Oracle数据库许可信息用户手册”</cite></span></a> ，了解不同版本和服务支持哪些功能的详细信息</p>
                           </li>
                        </ul>
                     </div>
                  </div>
               </div><a id="CNCPT94781"></a><div class="props_rev_3"><a id="GUID-D0C53854-D92E-49D0-822A-39F3E7573752" name="GUID-D0C53854-D92E-49D0-822A-39F3E7573752"></a><h4 id="CNCPT-GUID-D0C53854-D92E-49D0-822A-39F3E7573752" class="sect4">索引可用性和可见性</h4>
                  <div>
                     <p>索引可用（默认）或不可用，可见（默认）或不可见。</p>
                     <p>这些属性定义如下：</p>
                     <ul style="list-style-type:disc">
                        <li>
                           <p>可用性</p>
                           <p>DML操作不维护<a href="glossary.html#GUID-54114749-0A81-41D7-8E16-7B76D93CEE2B"><span class="xrefglossterm">优化</span></a>程序忽略的<a href="glossary.html#GUID-5EEB4F35-818F-4478-8BE3-F70CF22CD11F"><span class="xrefglossterm">不可用索引</span></a> 。不可用的索引可以改善批量加载的性能。您可以使索引无法使用，然后重建它，而不是删除索引并稍后重新创建它。不可用的索引和索引分区不占用空间。当使可用索引不可用时，数据库将删除其索引<a href="glossary.html#GUID-EC12AA68-8C89-43B3-B1F9-3AABF7CAEB9F"><span class="xrefglossterm">段</span></a> 。
                           </p>
                        </li>
                        <li>
                           <p>能见度</p>
                           <p><a href="glossary.html#GUID-B60609DA-2397-4715-B7E2-75AEC3FAD0BF"><span class="xrefglossterm">不可见索引</span></a>由DML操作维护，但优化程序默认不使用。使索引不可见是使其无法使用或丢弃的替代方法。不可见索引对于在删除索引或临时使用索引之前测试索引的删除特别有用，而不会影响整个应用程序。
                           </p>
                        </li>
                     </ul>
                     <div class="infoboxnotealso" id="GUID-D0C53854-D92E-49D0-822A-39F3E7573752__GUID-D0718D07-2617-4BC6-8A80-CD5EB89B5ADE">
                        <p class="notep1">也可以看看：</p>
                        <p><span class="q">“ <a href="sql.html#GUID-3F42B1AA-530A-4144-8179-F0074832AF81" title="要了解Oracle数据库如何处理SQL语句，有必要了解数据库中称为优化器的部分（也称为查询优化器或基于成本的优化器）。所有SQL语句都使用优化器来确定访问指定数据的最有效方法。">优化器概述</a> ”</span>了解优化器如何选择执行计划</p>
                     </div>
                  </div>
               </div><a id="CNCPT1159"></a><div class="props_rev_3"><a id="GUID-104A7F88-1BFE-4FF6-A5AD-4439C0E7F929" name="GUID-104A7F88-1BFE-4FF6-A5AD-4439C0E7F929"></a><h4 id="CNCPT-GUID-104A7F88-1BFE-4FF6-A5AD-4439C0E7F929" class="sect4">键和列</h4>
                  <div>
                     <p><span class="bold">键</span>是一组列或表达式，您可以在其上构建索引。
                     </p>
                     <p>虽然这些术语经常互换使用，但索引和键是不同的。索引是存储在用户使用SQL语句管理的数据库中的结构。键是严格的逻辑概念。</p>
                     <p>以下语句在示例表<code class="codeph">oe.orders</code>的<code class="codeph">customer_id</code>列上创建索引：</p><pre class="pre codeblock"><code>订单上的CREATE INDEX ord_customer_ix（customer_id）;</code></pre><p>在前面的语句中， <code class="codeph">customer_id</code>列是索引键。索引本身名为<code class="codeph">ord_customer_ix</code> 。
                     </p>
                     <div class="infoboxnote" id="GUID-104A7F88-1BFE-4FF6-A5AD-4439C0E7F929__GUID-0EC2E430-7F35-4D7A-AD24-89992309D384">
                        <p class="notep1">注意：</p>
                        <p>主键和唯一键自动具有索引，但您可能希望<a href="glossary.html#GUID-EEE8A67D-6B0E-468E-9554-48FEE552BC9A"><span class="xrefglossterm">在外键</span></a>上创建索引。
                        </p>
                     </div>
                     <div class="infoboxnotealso" id="GUID-104A7F88-1BFE-4FF6-A5AD-4439C0E7F929__GUID-AC6D0D78-B3F4-4653-8258-C19669D57D49">
                        <p class="notep1">也可以看看：</p>
                        <ul style="list-style-type:disc">
                           <li>
                              <p><span class="q">“ <a href="data-integrity.html#GUID-6A89FF39-AD42-4399-BD1B-E51ECEE50B4E" title="本章介绍完整性约束如何实施与数据库关联的业务规则，并防止将无效信息输入表中。">数据完整性</a> ”</span></p>
                           </li>
                           <li>
                              <p><a href="../sqlrf/CREATE-INDEX.html#SQLRF01209" target="_blank"><span><cite>Oracle数据库SQL语言参考</cite></span></a> <code class="codeph">CREATE INDEX</code>语法和语义</p>
                           </li>
                        </ul>
                     </div>
                  </div>
               </div><a id="CNCPT88833"></a><div class="props_rev_3"><a id="GUID-ABE1DE2A-59CC-4ADE-86A5-426B16459464" name="GUID-ABE1DE2A-59CC-4ADE-86A5-426B16459464"></a><h4 id="CNCPT-GUID-ABE1DE2A-59CC-4ADE-86A5-426B16459464" class="sect4">综合指数</h4>
                  <div>
                     <p><strong class="term">复合索引</strong> （也称为<strong class="term">连锁索引</strong> ）是表中多列的索引。
                     </p>
                     <p>将列放在复合索引中，其顺序对于将检索数据的查询最有意义。表中的列不必相邻。</p>
                     <p>复合索引可以加速检索<code class="codeph">SELECT</code>语句的数据，其中<code class="codeph">WHERE</code>子句引用复合索引中列的全部或前导部分。因此，定义中使用的列的顺序很重要。通常，最常访问的列首先出现。
                     </p>
                     <p>例如，假设应用程序经常查询<code class="codeph">employees</code>表中的<code class="codeph">last_name</code> ， <code class="codeph">job_id</code>和<code class="codeph">salary</code>列。还假设<code class="codeph">last_name</code>具有高<a href="glossary.html#GUID-5CD22620-6D7A-40DC-BA09-EE3B5339C7F8"><span class="xrefglossterm">基数</span></a> ，这意味着与表行数相比，不同值的数量很大。您使用以下列顺序创建索引：</p><pre class="pre codeblock"><code>CREATE INDEX employees_ix ON employees（last_name，job_id，salary）;</code></pre><p>访问所有三列，仅访问<code class="codeph">last_name</code>列或仅访问<code class="codeph">last_name</code>和<code class="codeph">job_id</code>列的查询使用此索引。在此示例中，不访问<code class="codeph">last_name</code>列的查询不使用索引。
                     </p>
                     <div class="infoboxnote" id="GUID-ABE1DE2A-59CC-4ADE-86A5-426B16459464__GUID-F7C85618-6D07-4F9D-8E4F-1FCFD5DBD318">
                        <p class="notep1">注意：</p>
                        <p>在某些情况下，例如当前导列具有非常低的基数时，数据库可能会使用此索引的跳过扫描（请参阅<span class="q">“ <a href="indexes-and-index-organized-tables.html#GUID-BB75CC6E-90E5-457F-A4A0-0ABBEB755181" title="索引跳过扫描使用复合索引的逻辑子索引。数据库" skip="=" ="">索引跳过扫描</a> ”</span> ）。
                        </p>
                     </div>
                     <p>当满足以下任何条件时，多个索引可以存在于具有相同列顺序的同一个表上：</p>
                     <ul style="list-style-type:disc">
                        <li>
                           <p>索引是不同类型的。</p>
                           <p>例如，您可以在同一列上创建位图和B树索引。</p>
                        </li>
                        <li>
                           <p>索引使用不同的分区方案。</p>
                           <p>例如，您可以创建本地分区的索引和全局分区的索引。</p>
                        </li>
                        <li>
                           <p>索引具有不同的唯一性属性。</p>
                           <p>例如，您可以在同一组列上创建唯一索引和非唯一索引。</p>
                        </li>
                     </ul>
                     <p>例如，对于具有相同顺序的相同表列，可以存在非分区索引，全局分区索引和本地分区索引。在任何时候，只能看到一个具有相同顺序列数的索引。</p>
                     <p>此功能使您可以迁移应用程序，而无需删除现有索引并使用不同属性重新创建它。此外，当索引键不断增加时，此功能在OLTP数据库中很有用，从而导致数据库将新条目插入到同一组索引块中。为了缓解这种“热点”，您可以将索引从非分区索引演变为全局分区索引。</p>
                     <p>如果同一列列上的索引在类型或分区方案上没有差异，则这些索引必须使用不同的列排列。例如，以下SQL语句指定有效的列排列：</p><pre class="pre codeblock"><code>CREATE INDEX employee_idx1 ON雇员（last_name，job_id）; CREATE INDEX employee_idx2 ON雇员（job_id，last_name）;</code></pre><div class="infoboxnotealso" id="GUID-ABE1DE2A-59CC-4ADE-86A5-426B16459464__GUID-E5E3CAEE-6846-46F9-A6D1-EBF514AE079A">
                        <p class="notep1">也可以看看：</p>
                        <p>有关使用复合索引的详细信息，请<a href="../tgsql/index.html" target="_blank"><span><cite>参见“Oracle数据库SQL调优指南”</cite></span></a></p>
                     </div>
                  </div>
               </div><a id="CNCPT1157"></a><div class="props_rev_3"><a id="GUID-F6EFE752-18FA-4BCE-BDE0-F2C386361187" name="GUID-F6EFE752-18FA-4BCE-BDE0-F2C386361187"></a><h4 id="CNCPT-GUID-F6EFE752-18FA-4BCE-BDE0-F2C386361187" class="sect4">独特和非独特的索引</h4>
                  <div>
                     <p>索引可以是唯一的也可以是非唯一的。唯一索引保证表中没有两行在键列中具有重复值。</p>
                     <p>例如，您的应用程序可能要求没有两名员工拥有相同的员工ID。在唯一索引中，每个数据值都存在一个<a href="glossary.html#GUID-647822F1-EFF1-4E26-BE22-D54081BE1C7B"><span class="xrefglossterm">rowid</span></a> 。叶块中的数据仅按键排序。
                     </p>
                     <p>非唯一索引允许索引列或列中的重复值。例如， <code class="codeph">employees</code>表的<code class="codeph">first_name</code>列可能包含多个<code class="codeph">Mike</code>值。对于非唯一索引，rowid按排序顺序包含在键中，因此非唯一索引按索引键和rowid（升序）排序。
                     </p>
                     <p>除了位图索引或群集键列值为null之外，Oracle数据库不会索引所有键列为<a href="glossary.html#GUID-8854502F-2B8F-4ABC-98FA-BBFC3695A964"><span class="xrefglossterm">空的</span></a>表行。
                     </p>
                  </div>
               </div><a id="CNCPT88834"></a><div class="props_rev_3"><a id="GUID-ACA0308E-5F01-4236-81D3-D0CDE5CB6695" name="GUID-ACA0308E-5F01-4236-81D3-D0CDE5CB6695"></a><h4 id="CNCPT-GUID-ACA0308E-5F01-4236-81D3-D0CDE5CB6695" class="sect4">索引的类型</h4>
                  <div>
                     <p>Oracle数据库提供了多种索引方案，可提供互补的性能功能。</p>
                     <p>B树索引是标准索引类型。它们非常适用于高度选择性的索引（少数行对应于每个索引条目）和主键索引。用作连接索引， <a href="glossary.html#GUID-8D6D0C64-6AC8-4B22-A9AF-1B62F61AE10B"><span class="xrefglossterm">B树索引</span></a>可以检索由索引列排序的数据。B树索引具有下表中显示的子类型。
                     </p>
                     <div class="tblformal" id="GUID-ACA0308E-5F01-4236-81D3-D0CDE5CB6695__GUID-20287EDF-5CC5-4332-BE66-5E8B40787E99">
                        <p class="titleintable">表3-1 B树索引子类型</p>
                        <table cellpadding="4" cellspacing="0" class="Formal" title="B树索引子类型" border="1" summary="This table describes different subtypes of B-tree indexes" frame="hsides" rules="rows">
                           <thead>
                              <tr align="left" valign="top">
                                 <th align="left" valign="bottom" width="20%" id="d20689e2724">B树索引子类型</th>
                                 <th align="left" valign="bottom" width="20%" id="d20689e2726">描述</th>
                                 <th align="left" valign="bottom" width="20%" id="d20689e2728">了解更多</th>
                              </tr>
                           </thead>
                           <tbody>
                              <tr align="left" valign="top">
                                 <td align="left" valign="top" width="20%" id="d20689e2732" headers="d20689e2724 ">
                                    <p>索引组织表</p>
                                 </td>
                                 <td align="left" valign="top" width="20%" headers="d20689e2732 d20689e2726 ">
                                    <p>索引组织表与堆组织不同，因为数据本身就是索引。</p>
                                 </td>
                                 <td align="left" valign="top" width="20%" headers="d20689e2732 d20689e2728 ">
                                    <p><span class="q">“ <a href="indexes-and-index-organized-tables.html#GUID-DAEC075B-C16D-4A57-898C-70EBCB364F0C" title="索引组织表是存储在B树索引结构的变体中的表。相反，堆组织表在适合的位置插入行。">索引组织表概述</a> ”</span></p>
                                 </td>
                              </tr>
                              <tr align="left" valign="top">
                                 <td align="left" valign="top" width="20%" id="d20689e2753" headers="d20689e2724 ">
                                    <p>反向键索引</p>
                                 </td>
                                 <td align="left" valign="top" width="20%" headers="d20689e2753 d20689e2726 ">
                                    <p>在这种类型的索引中，索引键的字节被反转，例如，103被存储为301。字节的反转将插入扩展到许多块的索引中。</p>
                                 </td>
                                 <td align="left" valign="top" width="20%" headers="d20689e2753 d20689e2728 ">
                                    <p><span class="q">“ <a href="indexes-and-index-organized-tables.html#GUID-2646BDA9-F776-4C98-9487-C7EBC2EECF0B" title="反向键索引是一种B树索引，它在保持列顺序的同时物理地反转每个索引键的字节。">反向键索引</a> ”</span></p>
                                 </td>
                              </tr>
                              <tr align="left" valign="top">
                                 <td align="left" valign="top" width="20%" id="d20689e2771" headers="d20689e2724 ">
                                    <p>降序索引</p>
                                 </td>
                                 <td align="left" valign="top" width="20%" headers="d20689e2771 d20689e2726 ">
                                    <p>此类型的索引按降序存储特定列或列的数据。</p>
                                 </td>
                                 <td align="left" valign="top" width="20%" headers="d20689e2771 d20689e2728 ">
                                    <p><span class="q">“ <a href="indexes-and-index-organized-tables.html#GUID-8C2EA2EC-18E5-4E4A-BF74-D1DE86D7F24A" title="在升序索引中，Oracle数据库按升序存储数据。默认情况下，字符数据按值中每个字节中包含的二进制值排序，数字数据从最小到最大，从最早到最新值。">上升和下降指数</a> ”</span></p>
                                 </td>
                              </tr>
                              <tr align="left" valign="top">
                                 <td align="left" valign="top" width="20%" id="d20689e2789" headers="d20689e2724 ">
                                    <p>B树集群索引</p>
                                 </td>
                                 <td align="left" valign="top" width="20%" headers="d20689e2789 d20689e2726 ">
                                    <p>此类型的索引按降序存储特定列或列的数据。</p>
                                 </td>
                                 <td align="left" valign="top" width="20%" headers="d20689e2789 d20689e2728 ">
                                    <p><span class="q">“ <a href="indexes-and-index-organized-tables.html#GUID-8C2EA2EC-18E5-4E4A-BF74-D1DE86D7F24A" title="在升序索引中，Oracle数据库按升序存储数据。默认情况下，字符数据按值中每个字节中包含的二进制值排序，数字数据从最小到最大，从最早到最新值。">上升和下降指数</a> ”</span></p>
                                 </td>
                              </tr>
                           </tbody>
                        </table>
                     </div>
                     <!-- class="inftblhruleinformal" -->
                     <p>下表显示了不使用B树结构的索引类型。</p>
                     <div class="tblformal" id="GUID-ACA0308E-5F01-4236-81D3-D0CDE5CB6695__GUID-FB2DFC62-FBF0-4A52-B73F-ADF6D4681001">
                        <p class="titleintable">表3-2不使用B树结构的索引</p>
                        <table cellpadding="4" cellspacing="0" class="Formal" title="索引不使用B树结构" border="1" summary="This table describes indexes that do not use a B-tree structure." frame="hsides" rules="rows">
                           <thead>
                              <tr align="left" valign="top">
                                 <th align="left" valign="bottom" id="d20689e2819">类型</th>
                                 <th align="left" valign="bottom" id="d20689e2821">描述</th>
                                 <th align="left" valign="bottom" id="d20689e2823">了解更多</th>
                              </tr>
                           </thead>
                           <tbody>
                              <tr align="left" valign="top">
                                 <td align="left" valign="top" id="d20689e2827" headers="d20689e2819 ">
                                    <p>位图和位图连接索引</p>
                                 </td>
                                 <td align="left" valign="top" headers="d20689e2827 d20689e2821 ">
                                    <p>在位图索引中，索引条目使用位图指向多行。相反，B树索引条目指向单行。位图连接索引是两个或多个表的连接的位图索引。</p>
                                 </td>
                                 <td align="left" valign="top" headers="d20689e2827 d20689e2823 ">
                                    <p><span class="q">“ <a href="indexes-and-index-organized-tables.html#GUID-B15C4817-7748-456D-9740-8B9628AF9F47" title="在位图索引中，数据库存储每个索引键的位图。在传统的B树索引中，一个索引条目指向单个行。在位图索引中，每个索引键存储指向多行的指针。">位图索引概述</a> ”</span></p>
                                 </td>
                              </tr>
                              <tr align="left" valign="top">
                                 <td align="left" valign="top" id="d20689e2845" headers="d20689e2819 ">
                                    <p>基于函数的索引</p>
                                 </td>
                                 <td align="left" valign="top" headers="d20689e2845 d20689e2821 ">
                                    <p>这种类型的索引包括由函数转换的列，例如<code class="codeph">UPPER</code>函数，或包含在表达式中的列。B树或位图索引可以基于功能。
                                    </p>
                                 </td>
                                 <td align="left" valign="top" headers="d20689e2845 d20689e2823 ">
                                    <p><span class="q">“ <a href="indexes-and-index-organized-tables.html#GUID-9AD7651D-0F0D-4FC6-A984-5845F0224EE6" title="基于函数的索引计算涉及一列或多列的函数或表达式的值，并将其存储在索引中。基于函数的索引可以是B树或位图索引。">基于功能的索引概述</a> ”</span></p>
                                 </td>
                              </tr>
                              <tr align="left" valign="top">
                                 <td align="left" valign="top" id="d20689e2866" headers="d20689e2819 ">
                                    <p>应用程序域索引</p>
                                 </td>
                                 <td align="left" valign="top" headers="d20689e2866 d20689e2821 ">
                                    <p>用户为特定于应用程序的域中的数据创建此类索引。物理索引不需要使用传统的索引结构，可以作为表存储在Oracle数据库中，也可以作为文件存储在外部。</p>
                                 </td>
                                 <td align="left" valign="top" headers="d20689e2866 d20689e2823 ">
                                    <p><span class="q">“ <a href="indexes-and-index-organized-tables.html#GUID-9586EB86-4B84-4A43-A66D-958776FE558B" title="应用程序域索引是特定于应用程序的自定义索引。">应用程序域索引概述</a> ”</span></p>
                                 </td>
                              </tr>
                           </tbody>
                        </table>
                     </div>
                     <!-- class="inftblhruleinformal" -->
                     <div class="infoboxnotealso" id="GUID-ACA0308E-5F01-4236-81D3-D0CDE5CB6695__GUID-F10A32F9-14B5-43E8-A4BE-AF168C4F402E">
                        <p class="notep1">也可以看看：</p>
                        <ul style="list-style-type:disc">
                           <li>
                              <p><a href="../admin/managing-indexes.html#ADMIN016" target="_blank"><span><cite>Oracle数据库管理员指南</cite></span></a> ，了解如何管理索引</p>
                           </li>
                           <li>
                              <p><a href="../tgsql/index.html" target="_blank"><span><cite>Oracle数据库SQL调优指南</cite></span></a> ，了解不同的索引类型</p>
                           </li>
                        </ul>
                     </div>
                  </div>
               </div><a id="CNCPT94782"></a><div class="props_rev_3"><a id="GUID-1DA0A7D9-1EAB-40B8-B882-75B8EC9498D7" name="GUID-1DA0A7D9-1EAB-40B8-B882-75B8EC9498D7"></a><h4 id="CNCPT-GUID-1DA0A7D9-1EAB-40B8-B882-75B8EC9498D7" class="sect4">数据库如何维护索引</h4>
                  <div>
                     <div><span>数据库在创建后自动维护和使用索引。</span></div>
                     <p>索引会自动将数据更改反映到其基础表。更改示例包括添加，更新和删除行。无需用户操作。</p>
                     <p>即使插入行，索引数据的检索性能也几乎保持不变。但是，表上存在许多索引会降低<a href="glossary.html#GUID-B5F2F112-1B33-41B5-B63D-9DC8F99A369D"><span class="xrefglossterm">DML</span></a>性能，因为数据库还必须更新索引。
                     </p>
                     <div class="infoboxnotealso" id="GUID-1DA0A7D9-1EAB-40B8-B882-75B8EC9498D7__GUID-E8F4A339-C508-4A8D-BD02-A45AD6F4CB60">
                        <p class="notep1">也可以看看：</p>
                        <ul style="list-style-type:disc">
                           <li>
                              <p><a href="../admin/managing-indexes.html#GUID-E4149397-FF37-4367-A12F-675433715904" target="_blank"><span><cite>Oracle数据库管理员指南</cite></span></a> ，了解有关自动索引的更多信息</p>
                           </li>
                           <li>
                              <p><a href="../dblic/Licensing-Information.html#DBLIC-GUID-0F9EB85D-4610-4EDF-89C2-4916A0E7AC87" target="_blank"><span><cite>“Oracle数据库许可信息用户手册”</cite></span></a> ，了解不同版本和服务支持哪些功能的详细信息</p>
                           </li>
                        </ul>
                     </div>
                  </div>
               </div><a id="CNCPT1168"></a><div class="props_rev_3"><a id="GUID-832C2B66-912B-4E1C-B4B5-AA40F49E4970" name="GUID-832C2B66-912B-4E1C-B4B5-AA40F49E4970"></a><h4 id="CNCPT-GUID-832C2B66-912B-4E1C-B4B5-AA40F49E4970" class="sect4">索引存储</h4>
                  <div>
                     <p>Oracle数据库将索引数据存储在索引段中。 。</p>
                     <p>数据块中可用于索引数据的空间是数据块大小减去块开销，条目开销，rowid和每个索引值的一个长度字节</p>
                     <p>该<a href="glossary.html#GUID-AA66891C-71B2-4D55-8F64-0E427AE24E88"><span class="xrefglossterm">表</span></a>的索引段的或者是所有者的默认表空间或者在具体指定表空间<code class="codeph">CREATE INDEX</code>语句。为了便于管理，您可以将索引存储在其表的单独表空间中。例如，您可以选择不备份仅包含可以重建的索引的表空间，从而减少备份所需的时间和存储空间。
                     </p>
                     <div class="infoboxnotealso" id="GUID-832C2B66-912B-4E1C-B4B5-AA40F49E4970__GUID-96EFABC4-25FE-4359-9C2D-1E4E87D93BD6">
                        <p class="notep1">也可以看看：</p>
                        <p><span class="q">“ <a href="logical-storage-structures.html#GUID-82531CDF-407E-4D70-AFD0-8E8929B72783" title="索引块是一种特殊类型的数据块，它以不同于表块的方式管理空间。Oracle数据库使用索引块来管理索引中的逻辑存储空间。">索引块概述</a> ”</span> ，了解索引块（根，分支和叶）的类型，以及索引条目如何存储在块中</p>
                     </div>
                  </div>
               </div>
            </div><a id="CNCPT88835"></a><a id="CNCPT1170"></a><div class="props_rev_3"><a id="GUID-FC93A85B-C237-4249-AD1E-FF54576ED050" name="GUID-FC93A85B-C237-4249-AD1E-FF54576ED050"></a><h3 id="CNCPT-GUID-FC93A85B-C237-4249-AD1E-FF54576ED050" class="sect3">B树索引概述</h3>
               <div>
                  <p>B树是<span class="italic">平衡树的</span>缩写，是最常见的数据库索引类型。<span class="bold">B树索引</span>是分成范围的有序值列表。通过将键与行或行范围相关联，B树为各种查询提供了出色的检索性能，包括完全匹配和范围搜索。
                  </p>
                  <p>下图说明了B树索引的结构。该示例显示了<code class="codeph">department_id</code>列的索引，该列是<code class="codeph">employees</code>表中的外键列。
                  </p>
                  <div class="figure" id="GUID-FC93A85B-C237-4249-AD1E-FF54576ED050__I5765">
                     <p class="titleinfigure">图3-1 B树索引的内部结构</p><img src="img/cncpt244.gif" alt="下面是图3-1的描述" title="下面是图3-1的描述" longdesc="img_text/cncpt244.html"><br><a href="img_text/cncpt244.html">“图3-1 B树索引的内部结构”的描述</a></div>
                  <!-- class="figure" -->
                  <p>本节包含以下主题：</p>
                  <ul style="list-style-type:disc">
                     <li>
                        <p><a href="indexes-and-index-organized-tables.html#GUID-89A9F85F-BE0E-4596-AEC3-CAF0D821B1CA" title="B树索引具有两种类型的块：用于搜索的分支块和用于存储键值的叶块。B树索引的上层分支块包含指向较低级索引块的索引数据。">分支块和叶块</a></p>
                     </li>
                     <li>
                        <p><a href="indexes-and-index-organized-tables.html#GUID-D54BD14D-0065-4B61-B2F6-5567913B16CD" title="在索引扫描中，数据库使用语句指定的索引列值通过遍历索引来检索行。如果数据库扫描索引中的值，则它将在n个I / O中找到该值，其中n是B树索引的高度。这是Oracle数据库索引背后的基本原则。">指数扫描</a></p>
                     </li>
                     <li>
                        <p><a href="indexes-and-index-organized-tables.html#GUID-2646BDA9-F776-4C98-9487-C7EBC2EECF0B" title="反向键索引是一种B树索引，它在保持列顺序的同时物理地反转每个索引键的字节。">反向键索引</a></p>
                     </li>
                     <li>
                        <p><a href="indexes-and-index-organized-tables.html#GUID-8C2EA2EC-18E5-4E4A-BF74-D1DE86D7F24A" title="在升序索引中，Oracle数据库按升序存储数据。默认情况下，字符数据按值中每个字节中包含的二进制值排序，数字数据从最小到最大，从最早到最新值。">升序和降序指数</a></p>
                     </li>
                     <li>
                        <p><a href="indexes-and-index-organized-tables.html#GUID-33AEA2E3-1355-4224-BB39-890A71784062" title="为了减少索引中的空间，Oracle数据库可以使用不同的压缩算法。">索引压缩</a></p>
                     </li>
                  </ul>
               </div><a id="CNCPT88836"></a><div class="props_rev_3"><a id="GUID-89A9F85F-BE0E-4596-AEC3-CAF0D821B1CA" name="GUID-89A9F85F-BE0E-4596-AEC3-CAF0D821B1CA"></a><h4 id="CNCPT-GUID-89A9F85F-BE0E-4596-AEC3-CAF0D821B1CA" class="sect4">分支块和叶块</h4>
                  <div>
                     <p>B树索引具有两种类型的块：用于搜索的<span class="bold">分支块</span>和用于存储键值的<span class="bold">叶块</span> 。B树索引的上层分支块包含指向较低级索引块的索引数据。
                     </p>
                     <p>在<a href="indexes-and-index-organized-tables.html#GUID-FC93A85B-C237-4249-AD1E-FF54576ED050__I5765">图3-1中</a> ，根分支块有一个条目<code class="codeph">0-40</code> ，它指向下一个分支级别中最左边的块。该分支块包含诸如<code class="codeph">0-10</code>和<code class="codeph">11-19</code>条目。这些条目中的每一个都指向包含落在该范围内的键值的叶块。
                     </p>
                     <p>B树索引是平衡的，因为所有叶块自动保持在相同的深度。因此，从索引中的任何位置检索任何记录所花费的时间大致相同。索引的高度是从根块到叶块所需的块数。分支级别是高度减1。在<a href="indexes-and-index-organized-tables.html#GUID-FC93A85B-C237-4249-AD1E-FF54576ED050__I5765">图3-1中</a> ，索引的高度为3，分支级别为2。
                     </p>
                     <p>分支块存储在两个密钥之间进行分支决策所需的最小密钥前缀。该技术使数据库能够在每个分支块上容纳尽可能多的数据。分支块包含指向包含密钥的子块的指针。键和指针的数量受块大小的限制。</p>
                     <p>叶块包含每个索引数据值和用于定位实际行的相应rowid。每个条目按（键，rowid）排序。在叶块中，键和rowid链接到其左右兄弟条目。叶块本身也是双重联系的。在<a href="indexes-and-index-organized-tables.html#GUID-FC93A85B-C237-4249-AD1E-FF54576ED050__I5765">图3-1中</a> ，最左边的叶块（ <code class="codeph">0-10</code> ）链接到第二叶块（ <code class="codeph">11-19</code> ）。
                     </p>
                     <div class="infoboxnote" id="GUID-89A9F85F-BE0E-4596-AEC3-CAF0D821B1CA__GUID-9ED9997A-EFAE-40A3-8893-53E5E30EC07A">
                        <p class="notep1">注意：</p>
                        <p>具有字符数据的列中的索引基于数据库字符集中字符的二进制值。</p>
                     </div>
                  </div>
               </div><a id="CNCPT88837"></a><div class="props_rev_3"><a id="GUID-D54BD14D-0065-4B61-B2F6-5567913B16CD" name="GUID-D54BD14D-0065-4B61-B2F6-5567913B16CD"></a><h4 id="CNCPT-GUID-D54BD14D-0065-4B61-B2F6-5567913B16CD" class="sect4">指数扫描</h4>
                  <div>
                     <p>在<span class="bold">索引扫描中</span> ，数据库使用语句指定的索引列值通过遍历索引来检索行。如果数据库扫描索引中的值，则它将在<span class="italic">n个</span> I / O中找到该值，其中<span class="italic">n</span>是B树索引的高度。这是Oracle数据库索引背后的基本原则。
                     </p>
                     <p>如果SQL语句仅访问索引列，则数据库直接从索引而不是从表中读取值。如果语句除了索引列之外还访问非索引列，则数据库使用rowid查找表中的行。通常，数据库通过交替读取索引块然后是表块来检索表数据。</p>
                     <div class="infoboxnotealso" id="GUID-D54BD14D-0065-4B61-B2F6-5567913B16CD__GUID-1C97560E-F717-433A-9CB6-031474B6AC4B">
                        <p class="notep1">也可以看看：</p>
                        <p>有关索引扫描的详细信息，请<a href="../tgsql/optimizer-access-paths.html#TGSQL234" target="_blank"><span class="italic">参见“Oracle数据库SQL调优指南”</span></a></p>
                     </div>
                  </div><a id="CNCPT88838"></a><div class="props_rev_3"><a id="GUID-F8439C86-0C6A-4FA8-85C5-1D49AE590180" name="GUID-F8439C86-0C6A-4FA8-85C5-1D49AE590180"></a><h5 id="CNCPT-GUID-F8439C86-0C6A-4FA8-85C5-1D49AE590180" class="sect5">全索引扫描</h5>
                     <div>
                        <p>在<span class="bold">完整索引扫描中</span> ，数据库按顺序读取整个索引。如果SQL语句中的<span class="bold">谓词</span> （ <code class="codeph">WHERE</code>子句）引用索引中的列，并且在某些情况下未指定谓词，则可以使用完整索引扫描。完整扫描可以消除排序，因为数据是按索引键排序的。
                        </p>
                        <div class="example" id="GUID-F8439C86-0C6A-4FA8-85C5-1D49AE590180__GUID-85A598E5-2460-4080-8823-2FC085079DE2">
                           <p class="titleinexample">例3-1全索引扫描</p>
                           <p>假设应用程序运行以下查询：</p><pre class="oac_no_warn" dir="ltr">SELECT department_id，last_name，salary FROM employees WHERE salary&gt; 5000 ORDER BY department_id，last_name;</pre><p>在此示例中， <code class="codeph">department_id</code> ， <code class="codeph">last_name</code>和<code class="codeph">salary</code>是索引中的复合键。Oracle数据库执行索引的完整扫描，按排序顺序读取（按部门ID和姓氏排序）并过滤工资属性。通过这种方式，数据库扫描一组小于<code class="codeph">employees</code>表的数据，该表包含的列数多于查询中包含的列数，并避免对数据进行排序。
                           </p>
                           <p>完整扫描可以读取索引条目，如下所示：</p><pre class="oac_no_warn" dir="ltr">50，Atkinson，2800，rowid 60，Austin，4800，rowid 70，Baer，10000，rowid 80，Abel，11000，rowid 80，Ande，6400，rowid 110，Austin，7200，rowid。。。</pre></div>
                        <!-- class="example" -->
                     </div>
                  </div><a id="CNCPT88839"></a><div class="props_rev_3"><a id="GUID-2C8A7262-DEBE-4932-8EFB-64E61AD041C1" name="GUID-2C8A7262-DEBE-4932-8EFB-64E61AD041C1"></a><h5 id="CNCPT-GUID-2C8A7262-DEBE-4932-8EFB-64E61AD041C1" class="sect5">快速全索引扫描</h5>
                     <div>
                        <p><span class="bold">快速完整索引扫描</span>是一种完整索引扫描，其中数据库访问索引本身的数据而不访问该表，并且数据库不按特定顺序读取索引块。
                        </p>
                        <p>当满足以下两个条件时，快速全索引扫描是<a href="glossary.html#GUID-BF9B54D6-892E-4C3B-8536-38958ACC069D"><span class="xrefglossterm">全表扫描</span></a>的替代方法：</p>
                        <ul style="list-style-type:disc">
                           <li>
                              <p>索引必须包含查询所需的所有列。</p>
                           </li>
                           <li>
                              <p>包含所有空值的行不得出现在查询结果集中。为了保证这个结果，索引中至少有一列必须具有：</p>
                              <ul style="list-style-type:disc">
                                 <li>
                                    <p><code class="codeph">NOT NULL</code>约束</p>
                                 </li>
                                 <li>
                                    <p>应用于列的谓词，用于防止在查询结果集中考虑空值</p>
                                 </li>
                              </ul>
                           </li>
                        </ul>
                        <div class="example" id="GUID-2C8A7262-DEBE-4932-8EFB-64E61AD041C1__GUID-912E57FB-14C7-4243-81D1-94E9D906B7BF">
                           <p class="titleinexample">例3-2快速全索引扫描</p>
                           <p>假设应用程序发出以下查询，该查询不包含<code class="codeph">ORDER BY</code>子句：</p><pre class="oac_no_warn" dir="ltr">SELECT last_name，salary FROM employees;</pre><p><code class="codeph">last_name</code>列具有非null约束。如果姓氏和工资是索引中的复合键，则快速完整索引扫描可以读取索引条目以获取所请求的信息：</p><pre class="oac_no_warn" dir="ltr">Baida，2900，rowid Atkinson，2800，rowid Zlotkey，10500，rowid Austin，7200，rowid Baer，10000，rowid Austin，4800，rowid。。。</pre></div>
                        <!-- class="example" -->
                     </div>
                  </div><a id="CNCPT88840"></a><div class="props_rev_3"><a id="GUID-E1BD4FBF-8A6D-4EF8-8892-7B1CBFA9D5C6" name="GUID-E1BD4FBF-8A6D-4EF8-8892-7B1CBFA9D5C6"></a><h5 id="CNCPT-GUID-E1BD4FBF-8A6D-4EF8-8892-7B1CBFA9D5C6" class="sect5">索引范围扫描</h5>
                     <div>
                        <p><span class="bold">索引范围扫描</span>是<span class="bold">索引</span>的有序扫描，其中索引的一个或多个前导列在条件中指定，并且索引关键字可以是0,1或更多值。
                        </p>
                        <p><a href="glossary.html#GUID-B5AA8627-E7DC-487B-8D4B-2DE3F1497A83"><span class="xrefglossterm">条件</span></a>指定一个或多个表达式和逻辑（布尔）运算符的组合。它返回值<code class="codeph">TRUE</code> ， <code class="codeph">FALSE</code>或<code class="codeph">UNKNOWN</code> 。</p>
                        <p>数据库通常使用索引范围扫描来访问选择性数据。<a href="glossary.html#GUID-AA830B4F-E5E8-4CCC-A960-0FA0E2F8DE12"><span class="xrefglossterm">选择性</span></a>是查询选择的表中行的百分比，0表示没有行，1表示所有行。选择性与查询<a href="glossary.html#GUID-891CF9E9-78CD-470C-9C4A-D65A101B2C38"><span class="xrefglossterm">谓词相关联</span></a> ，例如<code class="codeph">WHERE last_name LIKE 'A%'</code>或谓词组合。当值接近1时，谓词变得更具选择性，而当值接近1时，谓词变得更具选择性（或更不具有选择性）。
                        </p>
                        <p>例如，用户查询姓氏以<code class="codeph">A</code>开头的员工。假设<code class="codeph">last_name</code>列已编制索引，条目如下：</p><pre class="pre codeblock"><code>Abel，rowid Ande，rowid Atkinson，rowid Austin，rowid Austin，rowid Baer，rowid。。。
</code></pre><p>数据库可以使用范围扫描，因为在谓词中指定了<code class="codeph">last_name</code>列，并且每个索引键都可以使用倍数rowid。例如，两名员工被命名为Austin，因此两个rowid与关键<code class="codeph">Austin</code>相关联。
                        </p>
                        <p>索引范围扫描可以在两侧进行限制，如查询ID为10到40之间的部门，或仅限于一侧，如查询ID超过40。要扫描索引，数据库会在叶块中向后或向前移动。例如，对10到40之间的ID的扫描将定位包含10或更大的最低键值的第一个索引叶块。然后扫描水平地通过叶节点的链接列表，直到它找到大于40的值。</p>
                     </div>
                  </div><a id="CNCPT88841"></a><div class="props_rev_3"><a id="GUID-4675513E-A498-455B-A610-B70823E32A30" name="GUID-4675513E-A498-455B-A610-B70823E32A30"></a><h5 id="CNCPT-GUID-4675513E-A498-455B-A610-B70823E32A30" class="sect5">索引唯一扫描</h5>
                     <div>
                        <p>与索引范围扫描相反， <span class="bold">索引唯一扫描</span>必须具有与索引键关联的0或1 rowid。
                        </p>
                        <p>当谓词使用相等运算符引用<code class="codeph">UNIQUE</code>索引的键中的所有列时，数据库将执行唯一扫描。索引唯一扫描一找到第一条记录就会停止处理，因为没有第二条记录是可能的。
                        </p>
                        <p>举例来说，假设用户运行以下查询：</p><pre class="pre codeblock"><code>SELECT * FROM employees WHERE employee_id = 5;</code></pre><p>假设<code class="codeph">employee_id</code>列是主键，并使用以下条目索引：</p><pre class="pre codeblock"><code>1，rowid 2，rowid 4，rowid 5，rowid 6，rowid。。。
</code></pre><p>在这种情况下，数据库可以使用索引唯一扫描来查找ID为5的员工的rowid。</p>
                     </div>
                  </div><a id="CNCPT88843"></a><a id="CNCPT88842"></a><div class="props_rev_3"><a id="GUID-BB75CC6E-90E5-457F-A4A0-0ABBEB755181" name="GUID-BB75CC6E-90E5-457F-A4A0-0ABBEB755181"></a><h5 id="CNCPT-GUID-BB75CC6E-90E5-457F-A4A0-0ABBEB755181" class="sect5">索引跳过扫描</h5>
                     <div>
                        <p><span class="bold">索引跳过扫描</span>使用复合索引的逻辑子索引。数据库“跳过”单个索引，就好像它正在搜索单独的索引一样。
                        </p>
                        <p>如果复合索引的前导列中有很少的不同值，并且索引的非引导键中有许多不同的值，则跳过扫描是有益的。当在查询谓词中未指定复合索引的前导列时，数据库可以选择索引跳过扫描。</p>
                        <div class="example" id="GUID-BB75CC6E-90E5-457F-A4A0-0ABBEB755181__CBBIFEAH">
                           <p class="titleinexample">例3-3复合索引的跳过扫描</p>
                           <p>假设您在<code class="codeph">sh.customers</code>表中为客户运行以下查询：</p><pre class="oac_no_warn" dir="ltr">SELECT * FROM sh.customers WHERE cust_email ='Abbey@company.example.com';</pre><p><code class="codeph">customers</code>表有一个<code class="codeph">cust_gender</code>列，其值为<code class="codeph">M</code>或<code class="codeph">F</code>假设列上存在复合索引（ <code class="codeph">cust_gender</code> ， <code class="codeph">cust_email</code> ）。以下示例显示了一部分索引条目：</p><pre class="oac_no_warn" dir="ltr">F，Wolf @ company.example.com，rowid F，Wolsey @ company.example.com，rowid F，Wood @ company.example.com，rowid F，Woodman @ company.example.com，rowid F，Yang @ company。 example.com，rowid F，Zimmerman @ company.example.com，rowid M，Abbassi @ company.example.com，rowid M，Abbey @ company.example.com，rowid</pre><p>即使未在<code class="codeph">WHERE</code>子句中指定<code class="codeph">cust_gender</code> ，数据库也可以使用此索引的跳过扫描。
                           </p>
                           <p>在跳过扫描中，逻辑子索引的数量由前导列中的不同值的数量确定。在前面的示例中，前导列有两个可能的值。数据库在逻辑上将索引拆分为一个带有密钥<code class="codeph">F</code>的子索引和一个带有密钥<code class="codeph">M</code>的第二个子索引。</p>
                           <p>当搜索电子邮件为<code class="codeph">Abbey@company.example.com</code>的客户的记录时，数据库首先使用值<code class="codeph">F</code>搜索子索引，然后使用值<code class="codeph">M</code>搜索子索引。从概念上讲，数据库按如下方式处理查询：</p><pre class="oac_no_warn" dir="ltr">SELECT * FROM sh.customers WHERE cust_gender ='F'AND cust_email ='Abbey@company.example.com'UNION ALL SELECT * FROM sh.customers WHERE cust_gender ='M'AND cust_email ='Abbey@company.example.com' ;</pre><div class="infoboxnotealso" id="GUID-BB75CC6E-90E5-457F-A4A0-0ABBEB755181__GUID-C060F5C4-0A5C-49BC-901B-3DFFD209F527">
                              <p class="notep1">也可以看看：</p>
                              <p><a href="../tgsql/optimizer-access-paths.html#TGSQL238" target="_blank"><span class="italic">Oracle Database SQL Tuning Guide</span></a>以了解有关跳过扫描的更多信息</p>
                           </div>
                        </div>
                        <!-- class="example" -->
                     </div>
                  </div><a id="CNCPT89181"></a><a id="CNCPT89182"></a><a id="CNCPT89180"></a><div class="props_rev_3"><a id="GUID-9F572458-50AF-4B7C-BC84-807FB815AC39" name="GUID-9F572458-50AF-4B7C-BC84-807FB815AC39"></a><h5 id="CNCPT-GUID-9F572458-50AF-4B7C-BC84-807FB815AC39" class="sect5">指数聚类因子</h5>
                     <div>
                        <p><span class="bold">索引聚类因子</span>测量与索引值（例如员工姓氏）相关的行顺序。随着顺序度的增加，聚类因子减少。
                        </p>
                        <p>聚类因子可用作粗略测量使用索引读取整个表所需的I / O数量：</p>
                        <ul style="list-style-type:disc">
                           <li>
                              <p>如果聚类因子很高，则Oracle数据库在大索引范围扫描期间执行相对较多的I / O.索引条目指向随机表块，因此数据库可能必须反复读取和重读相同的块以检索索引指向的数据。</p>
                           </li>
                           <li>
                              <p>如果聚类因子较低，则Oracle数据库在大索引范围扫描期间执行相对较少的I / O.范围中的索引键倾向于指向相同的数据块，因此数据库不必一遍又一遍地读取和重读相同的块。</p>
                           </li>
                        </ul>
                        <p>聚类因子与索引扫描相关，因为它可以显示：</p>
                        <ul style="list-style-type:disc">
                           <li>
                              <p>数据库是否将使用索引进行大范围扫描</p>
                           </li>
                           <li>
                              <p>与索引键相关的表组织程度</p>
                           </li>
                           <li>
                              <p>如果必须按索引键排序行，是否应考虑使用索引组织表，分区或表簇</p>
                           </li>
                        </ul>
                        <div class="example" id="GUID-9F572458-50AF-4B7C-BC84-807FB815AC39__CHDGAIIF">
                           <p class="titleinexample">例3-4聚类因子</p>
                           <p>假设<code class="codeph">employees</code>表适合两个数据块。<a href="indexes-and-index-organized-tables.html#GUID-9F572458-50AF-4B7C-BC84-807FB815AC39__CHDEIDBA" title="该表比较了两个数据块的内容。">表3-3</a>描述了两个数据块中的行（省略号表示未显示的数据）。
                           </p>
                           <div class="tblformal" id="GUID-9F572458-50AF-4B7C-BC84-807FB815AC39__CHDEIDBA">
                              <p class="titleintable">表3-3员工表中两个数据块的内容</p>
                              <table cellpadding="4" cellspacing="0" class="Formal" title="员工表中两个数据块的内容" width="100%" border="1" summary="This table compares the contents of two data blocks. " frame="hsides" rules="rows">
                                 <thead>
                                    <tr align="left" valign="top">
                                       <th align="left" valign="bottom" width="50%" id="d20689e6411">数据块1</th>
                                       <th align="left" valign="bottom" width="50%" id="d20689e6414">数据块2</th>
                                    </tr>
                                 </thead>
                                 <tbody>
                                    <tr align="left" valign="top">
                                       <td align="left" valign="top" width="50%" id="d20689e6419" headers="d20689e6411 "><pre class="pre codeblock"><code>100 Steven <span class="bold">King</span> SKING ......156 Janette <span class="bold">King</span> JKING ......115 Alexander <span class="bold">Khoo</span> AKHOO ......。。。116 Shelli <span class="bold">百达</span> SBAIDA ...204 Hermann <span class="bold">Baer</span> HBAER ......105 David <span class="bold">Austin</span> DAUSTIN ......130 Mozhe <span class="bold">Atkinson</span> MATKINSO ......166 Sundar <span class="bold">Ande</span> SANDE ......174 Ellen <span class="bold">Abel</span> EABEL ......</code></pre></td>
                                       <td align="left" valign="top" width="50%" headers="d20689e6419 d20689e6414 "><pre class="pre codeblock"><code>149 Eleni <span class="bold">Zlotkey</span> EZLOTKEY ......200 Jennifer <span class="bold">Whalen</span> JWHALEN ......。。。137 Renske <span class="bold">Ladwig</span> RLADWIG ......173 Sundita <span class="bold">Kumar</span> SKUMAR ...101 Neena <span class="bold">Kochar</span> NKOCHHAR ......</code></pre></td>
                                    </tr>
                                 </tbody>
                              </table>
                           </div>
                           <!-- class="inftblhruleinformal" -->
                           <p>行以姓氏的顺序存储在块中（以粗体显示）。例如，数据块1中的底行描述了Abel，下一行描述了Ande，依此类推，直到Steven King的块1的顶行。第2块中的底行描述了Kochar，下一行描述了Kumar，依此类推，直到Zlotkey块的最后一行。</p>
                           <p>假设姓氏列上存在索引。每个名称条目对应一个rowid。从概念上讲，索引条目如下所示：</p><pre class="pre codeblock"><code>Abel，block1row1 Ande，block1row2 Atkinson，block1row3 Austin，block1row4 Baer，block1row5。。。</code></pre><p>假设员工ID列上存在单独的索引。从概念上讲，索引条目可能如下所示，员工ID分布在两个块中的几乎随机位置：</p><pre class="pre codeblock"><code>100，block1row50 101，block2row1 102，block1row9 103，block2row19 104，block2row39 105，block1row4。。。</code></pre><p>以下语句在<code class="codeph">ALL_INDEXES</code>视图中查询这两个索引的聚类因子：</p><pre class="pre codeblock"><code>SQL&gt; SELECT INDEX_NAME，CLUSTERING_FACTOR 2 FROM ALL_INDEXES 3 WHERE INDEX_NAME IN（'EMP_NAME_IX'，'EMP_EMP_ID_PK'）; INDEX_NAME CLUSTERING_FACTOR -------------------- ----------------- EMP_EMP_ID_PK 19 EMP_NAME_IX 2</code></pre><p><code class="codeph">EMP_NAME_IX</code>的聚类因子较低，这意味着单个叶块中的相邻索引条目倾向于指向相同数据块中的行。<code class="codeph">EMP_EMP_ID_PK</code>的聚类因子很高，这意味着同一叶子块中的相邻索引条目不太可能指向相同数据块中的行。
                           </p>
                           <div class="infoboxnotealso" id="GUID-9F572458-50AF-4B7C-BC84-807FB815AC39__GUID-EED6A7AD-249F-44EC-B1F2-FF8F20CBD617">
                              <p class="notep1">也可以看看：</p>
                              <p><a href="../refrn/ALL_INDEXES.html#REFRN20088" target="_blank"><span><cite>Oracle Database Reference</cite></span></a>了解<code class="codeph">ALL_INDEXES</code></p>
                           </div>
                        </div>
                        <!-- class="example" -->
                     </div>
                  </div>
               </div><a id="CNCPT1181"></a><div class="props_rev_3"><a id="GUID-2646BDA9-F776-4C98-9487-C7EBC2EECF0B" name="GUID-2646BDA9-F776-4C98-9487-C7EBC2EECF0B"></a><h4 id="CNCPT-GUID-2646BDA9-F776-4C98-9487-C7EBC2EECF0B" class="sect4">反向键索引</h4>
                  <div>
                     <p><span class="bold">反向键索引</span>是一种B树索引，它在保持列顺序的同时物理地反转每个索引键的字节。
                     </p>
                     <p>例如，如果索引键是<code class="codeph">20</code> ，并且如果在十六进制中<code class="codeph">C1,15</code>键存储的两个字节在标准B树索引中是<code class="codeph">C1,15</code> ，则反向键索引将字节存储为<code class="codeph">15,C1</code> 。
                     </p>
                     <p>反转键解决了B树索引右侧的叶块争用问题。在Oracle Real Application Clusters（Oracle RAC）数据库中，此问题尤为严重，其中多个实例会反复修改同一个块。例如，在<code class="codeph">orders</code>表中， <code class="codeph">orders</code>的主键是顺序的。集群中的一个实例添加了20个订单，而另一个实例添加了21个，每个实例将其密钥写入索引右侧的同一个叶块。
                     </p>
                     <p>在反向键索引中，字节顺序的反转在索引中的所有叶键上分配插入。例如，在标准密钥索引中相邻的诸如20和21之类的密钥现在相隔很远地存储在单独的块中。因此，用于插入顺序键的I / O更均匀地分布。</p>
                     <p>由于索引中的数据在存储时未按列键排序，因此反向键排列在某些情况下无法运行索引范围扫描查询。例如，如果用户发出的订单ID大于20的查询，则数据库无法以包含此ID的块开头，而是水平遍历叶块。</p>
                  </div>
               </div><a id="CNCPT88844"></a><div class="props_rev_3"><a id="GUID-8C2EA2EC-18E5-4E4A-BF74-D1DE86D7F24A" name="GUID-8C2EA2EC-18E5-4E4A-BF74-D1DE86D7F24A"></a><h4 id="CNCPT-GUID-8C2EA2EC-18E5-4E4A-BF74-D1DE86D7F24A" class="sect4">升序和降序指数</h4>
                  <div>
                     <p>在<span class="bold">升序索引中</span> ，Oracle数据库按升序存储数据。默认情况下，字符数据按值中每个字节中包含的二进制值排序，数字数据从最小到最大，从最早到最新值。
                     </p>
                     <p>有关升序索引的示例，请考虑以下SQL语句：</p><pre class="pre codeblock"><code>CREATE INDEX emp_deptid_ix ON hr.employees（department_id）;</code></pre><p>Oracle数据库对<code class="codeph">department_id</code>列上的<code class="codeph">hr.employees</code>表进行排序。它使用<code class="codeph">department_id</code>和相应的rowid值以升序加载升序索引，从<code class="codeph">0</code>开始。当它使用索引时，Oracle数据库会搜索已排序的<code class="codeph">department_id</code>值，并使用关联的rowid来查找具有所请求的<code class="codeph">department_id</code>值的行。
                     </p>
                     <p>通过在<code class="codeph">CREATE INDEX</code>语句中指定<code class="codeph">DESC</code>关键字，可以创建<a href="glossary.html#GUID-77ADFA8C-BBA8-4E2D-B122-2D490FC35CFE"><span class="xrefglossterm">降序索引</span></a> 。在这种情况下，索引按降序存储指定列的数据。如果<code class="codeph">employees.department_id</code>列<a href="indexes-and-index-organized-tables.html#GUID-9F572458-50AF-4B7C-BC84-807FB815AC39__CHDEIDBA" title="该表比较了两个数据块的内容。">中表3-3中</a>的索引是降序，则包含<code class="codeph">250</code>的叶子阻塞将位于树的左侧，而阻塞位于右侧的<code class="codeph">0</code> 。通过降序索引的默认搜索是从最高值到最低值。
                     </p>
                     <p>当查询对某些列进行升序排序而其他列按降序排序时，降序索引非常有用。例如，假设您在<code class="codeph">last_name</code>和<code class="codeph">department_id</code>列上创建了一个复合索引，如下所示：</p><pre class="pre codeblock"><code>CREATE INDEX emp_name_dpt_ix ON hr.employees（last_name ASC，department_id DESC）;</code></pre><p>如果用户按升序（A到Z）查询<code class="codeph">hr.employees</code>以查找姓氏，按降序（从高到低）查询部门ID，则数据库可以使用此索引检索数据并避免对其进行排序的额外步骤。
                     </p>
                     <div class="infoboxnotealso" id="GUID-8C2EA2EC-18E5-4E4A-BF74-D1DE86D7F24A__GUID-161534A7-C2BD-4842-842D-5364A8438D78">
                        <p class="notep1">也可以看看：</p>
                        <ul style="list-style-type:disc">
                           <li>
                              <p><a href="../tgsql/optimizer-access-paths.html#TGSQL236" target="_blank"><span><cite>Oracle数据库SQL调优指南</cite></span></a> ，了解有关升序和降序索引搜索的更多信息</p>
                           </li>
                           <li>
                              <p><a href="../sqlrf/CREATE-INDEX.html#SQLRF53994" target="_blank"><span><cite>Oracle Database SQL语言参考，</cite></span></a>用于描述<code class="codeph">CREATE INDEX</code>的<code class="codeph">ASC</code>和<code class="codeph">DESC</code>选项</p>
                           </li>
                        </ul>
                     </div>
                  </div>
               </div><a id="CNCPT94783"></a><div class="props_rev_3"><a id="GUID-33AEA2E3-1355-4224-BB39-890A71784062" name="GUID-33AEA2E3-1355-4224-BB39-890A71784062"></a><h4 id="CNCPT-GUID-33AEA2E3-1355-4224-BB39-890A71784062" class="sect4">索引压缩</h4>
                  <div>
                     <p>为了减少索引中的空间，Oracle数据库可以使用不同的压缩算法。</p>
                     <p></p>
                  </div><a id="CNCPT88845"></a><a id="CNCPT1177"></a><div class="props_rev_3"><a id="GUID-AB399E45-4415-4B41-B38D-7D8AA2A2F11B" name="GUID-AB399E45-4415-4B41-B38D-7D8AA2A2F11B"></a><h5 id="CNCPT-GUID-AB399E45-4415-4B41-B38D-7D8AA2A2F11B" class="sect5">前缀压缩</h5>
                     <div>
                        <p>Oracle数据库可以使用<span class="bold">前缀压缩</span> （也称为<span class="bold">密钥压缩</span> ）来压缩B树索引或索引组织表中的部分主键列值。前缀压缩可以大大减少索引占用的空间。
                        </p>
                        <p>未压缩的索引条目有一个。使用前缀压缩的索引条目有两个部分：前缀条目，即分组部分，以及后缀条目，它是唯一或几乎唯一的部分。数据库通过在索引块中的后缀条目之间共享前缀条目来实现压缩。</p>
                        <div class="infoboxnote" id="GUID-AB399E45-4415-4B41-B38D-7D8AA2A2F11B__GUID-CEB8FC84-6C4D-4C87-9080-328F6B9BBCA7">
                           <p class="notep1">注意：</p>
                           <p>如果未将键定义为具有唯一片段，则数据库通过将rowid附加到分组片段来提供一个。</p>
                        </div>
                        <p>默认情况下，唯一索引的前缀由排除最后一列的所有键列组成，而非唯一索引的前缀由所有键列组成。假设您在<code class="codeph">oe.orders</code>表的两列上创建复合唯一索引，如下所示：</p><pre class="oac_no_warn" dir="ltr">创建UNIQUE INDEX orders_mod_stat_ix ON订单（order_mode，order_status）;</pre><p>在前面的示例中，索引键可能<code class="codeph">online,0</code> 。rowid存储在条目的密钥数据部分中，并且不是密钥本身的一部分。
                        </p>
                        <div class="infoboxnote" id="GUID-AB399E45-4415-4B41-B38D-7D8AA2A2F11B__GUID-A718E5A1-E1F7-4E2C-BAEB-3D1AEB50F56A">
                           <p class="notep1">注意：</p>
                           <p>如果在单个列上创建唯一索引，则Oracle数据库无法使用前缀密钥压缩，因为不存在公共前缀。</p>
                        </div>
                        <p>或者，假设您在相同的列上创建非唯一索引：</p><pre class="oac_no_warn" dir="ltr">CREATE INDEX orders_mod_stat_ix ON订单（order_mode，order_status）;</pre><p>还假设<code class="codeph">order_mode</code>和<code class="codeph">order_status</code>列中出现重复值。索引块可以具有以下示例中所示的条目：</p><pre class="oac_no_warn" dir="ltr">在线，0，AAAPvCAAFAAAAFaAAa在线，0，AAAPvCAAFAAAAFaAAg在线，0，AAAPvCAAFAAAAFaAAl在线，2，AAAPvCAAFAAAAFaAAm在线，3，AAAPvCAAFAAAAFaAAq在线，3，AAAPvCAAFAAAAFaAAt</pre><p>在前面的示例中，键前缀将包含<code class="codeph">order_mode</code>和<code class="codeph">order_status</code>值的串联，如<code class="codeph">online,0</code> 。后缀包含rowid，如<code class="codeph">AAAPvCAAFAAAAFaAAa</code> 。rowid使整个索引条目唯一，因为rowid本身在数据库中是唯一的。
                        </p>
                        <p>如果前面示例中的索引是使用默认前缀压缩（由<code class="codeph">COMPRESS</code>关键字指定）创建的，则将<code class="codeph">COMPRESS</code>重复的密钥前缀，如<code class="codeph">online</code> ， <code class="codeph">0</code>和<code class="codeph">online</code> ， <code class="codeph">3</code> 。从概念上讲，数据库实现压缩如下：</p><pre class="oac_no_warn" dir="ltr">在线，0 AAAPvCAAFAAAAFaAAa AAAPvCAAFAAAAFaAAg AAAPvCAAFAAAAFaAAl在线，2 AAAPvCAAFAAAAFaAAm在线，3 AAAPvCAAFAAAAFaAAq AAAPvCAAFAAAAFaAAt</pre><p>后缀条目（rowid）构成索引行的压缩版本。每个后缀条目引用一个前缀条目，该条目存储在与后缀相同的索引块中。</p>
                        <p>或者，您可以在创建使用前缀压缩的索引时指定前缀长度。例如，如果指定了<code class="codeph">COMPRESS 1</code> ，则前缀为<code class="codeph">order_mode</code> ，后缀为<code class="codeph">order_status,rowid</code> 。对于索引块示例中的值，索引会将<code class="codeph">online</code>前缀的重复出现分解出来，可以在概念上表示如下：</p><pre class="oac_no_warn" dir="ltr">在线0，AAAPvCAAFAAAAFaAAa 0，AAAPvCAAFAAAAFaAAg 0，AAAPvCAAFAAAAFaAAl 2，AAAPvCAAFAAAAFaAAm 3，AAAPvCAAFAAAAFaAAq 3，AAAPvCAAFAAAAaAa</pre><p>索引最多每个叶块存储一次特定前缀。仅压缩B树索引的叶块中的键。在分支块中，可以截断密钥后缀，但不压缩密钥。</p>
                        <div class="infoboxnotealso" id="GUID-AB399E45-4415-4B41-B38D-7D8AA2A2F11B__GUID-40F35D81-661B-4287-8E5E-90883711EE65">
                           <p class="notep1">也可以看看：</p>
                           <ul style="list-style-type:disc">
                              <li>
                                 <p><a href="../admin/managing-tables.html#ADMIN11692" target="_blank"><span class="italic">Oracle数据库管理员指南</span></a> ，了解如何使用压缩索引</p>
                              </li>
                              <li>
                                 <p><a href="../vldbg/partition-create-tables-indexes.html#VLDBG1111" target="_blank"><span class="italic">Oracle Database VLDB和分区指南</span></a> ，了解如何对分区索引使用前缀压缩</p>
                              </li>
                              <li>
                                 <p>有关<code class="codeph">CREATE INDEX</code>的<span class="italic"><code class="codeph">key_compression</code></span>子句的描述，请<a href="../sqlrf/CREATE-INDEX.html#SQLRF53999" target="_blank"><span class="italic">参见“Oracle数据库SQL语言参考</span></a> ”</p>
                              </li>
                           </ul>
                        </div>
                     </div>
                  </div><a id="CNCPT94784"></a><div class="props_rev_3"><a id="GUID-0D732C46-AB22-4C46-8631-7B0F65FA41F9" name="GUID-0D732C46-AB22-4C46-8631-7B0F65FA41F9"></a><h5 id="CNCPT-GUID-0D732C46-AB22-4C46-8631-7B0F65FA41F9" class="sect5">高级索引压缩</h5>
                     <div>
                        <p>从<span>Oracle Database 12c</span>第1版（12.1.0.2）开始， <strong class="term">高级索引压缩</strong>改进了堆组织表上受支持索引的传统前缀压缩。
                        </p>
                        <div class="section">
                           <p class="subhead3" id="GUID-0D732C46-AB22-4C46-8631-7B0F65FA41F9__GUID-8C17A677-7937-43BF-880E-E3239D2A2B4F">高级索引压缩的好处</p>
                           <p>前缀压缩对支持的索引类型，压缩率和易用性有限制。与前缀压缩不同，前缀压缩对每个块使用固定的重复密钥消除，高级索引压缩使用基于每个块的自适应重复密钥消除。高级索引压缩的主要优点是：</p>
                           <ul style="list-style-type:disc">
                              <li>
                                 <p>数据库使用许多内部算法（如列内级别前缀，重复键消除和rowid压缩）自动为每个块选择最佳压缩。与前缀压缩不同，高级索引压缩不要求用户知道数据特征。</p>
                              </li>
                              <li>
                                 <p>高级压缩适用于非唯一索引<span class="italic">和</span>唯一索引。前缀压缩在某些非唯一索引上运行良好，但在前导列没有多次重复的索引上比率较低。
                                 </p>
                              </li>
                              <li>
                                 <p>压缩索引的使用方式与未压缩索引相同。该索引支持相同的访问路径：唯一键查找，范围扫描和快速完整扫描。</p>
                              </li>
                              <li>
                                 <p>索引可以从父表继承高级压缩或包含表空间。</p>
                              </li>
                           </ul>
                        </div>
                        <!-- class="section" -->
                        <div class="section">
                           <p class="subhead3" id="GUID-0D732C46-AB22-4C46-8631-7B0F65FA41F9__GUID-26B21460-8ABD-43AA-851C-67F00CE2103B">高级索引压缩的工作原理</p>
                           <p>高级索引压缩在块级别工作，为每个块提供最佳压缩。该数据库使用以下技术：</p>
                           <ul style="list-style-type:disc">
                              <li>
                                 <p>在创建索引期间，当叶块变满时，数据库会自动将块压缩到最佳级别。</p>
                              </li>
                              <li>
                                 <p>当由于DML重组索引块时，如果数据库可以为传入索引条目创建足够的空间，则不会发生块拆分。但是，在没有高级索引压缩的DML期间，当块变满时总是会发生索引块拆分。</p>
                              </li>
                           </ul>
                        </div>
                        <!-- class="section" -->
                        <div class="section">
                           <p class="subhead3" id="GUID-0D732C46-AB22-4C46-8631-7B0F65FA41F9__GUID-C1FEDC9A-D53D-4505-BB22-3A502DD3EAF3">高级索引压缩HIGH</p>
                           <p>在<span>Oracle Database 12c</span>第2版（12.2）之前的版本中，高级索引压缩的唯一形式是低压缩（ <code class="codeph">COMPRESS ADVANCED LOW</code> ）。现在您还可以指定高压缩（ <code class="codeph">COMPRESS ADVANCED HIGH</code> ），这是默认值。使用<code class="codeph">HIGH</code>选项进行高级索引压缩具有以下优势：</p>
                           <ul style="list-style-type:disc">
                              <li>
                                 <p>在大多数情况下，压缩率更高，同时还提高了访问索引的查询的性能</p>
                              </li>
                              <li>
                                 <p>采用比先进低版本更复杂的压缩算法</p>
                              </li>
                              <li>
                                 <p>以压缩单位存储数据，这是一种特殊的磁盘格式</p>
                              </li>
                           </ul>
                           <div class="infoboxnote" id="GUID-0D732C46-AB22-4C46-8631-7B0F65FA41F9__GUID-212E76F8-8EE5-4DAE-9353-BF8629DC222B">
                              <p class="notep1">注意：</p>
                              <p>应用<code class="codeph">HIGH</code>压缩时，所有块都有压缩。应用<code class="codeph">LOW</code>压缩时，数据库可能会保留一些未压缩的块。您可以使用统计信息来确定未压缩的块数。
                              </p>
                           </div>
                        </div>
                        <!-- class="section" -->
                        <div class="example" id="GUID-0D732C46-AB22-4C46-8631-7B0F65FA41F9__GUID-4CE04A3B-514A-4EB1-99E5-2CCEC4D5B6C7">
                           <p class="titleinexample">示例3-5使用高级高压缩创建索引</p>
                           <p>此示例为<code class="codeph">hr.employees</code>表上的索引启用高级索引压缩：</p><pre class="pre codeblock"><code>CREATE INDEX hr.emp_mndp_ix ON hr.employees（manager_id，department_id）COMPRESS ADVANCED;</code></pre><p>以下查询显示压缩类型：</p><pre class="pre codeblock"><code>SELECT DBPRESSION FROM DBA_INDEXES WHERE INDEX_NAME ='EMP_MNDP_IX';压缩-------------高级</code></pre><div class="infoboxnotealso" id="GUID-0D732C46-AB22-4C46-8631-7B0F65FA41F9__GUID-099AB742-E00B-481D-97D2-EEF0784CD65E">
                              <p class="notep1">也可以看看：</p>
                              <ul style="list-style-type:disc">
                                 <li>
                                    <p><a href="../admin/managing-indexes.html#ADMIN14308" target="_blank"><span><cite>Oracle数据库管理员指南</cite></span></a> ，了解如何启用高级索引压缩</p>
                                 </li>
                                 <li>
                                    <p>有关<code class="codeph">CREATE INDEX</code>的<span class="italic"><code class="codeph">key_compression</code></span>子句的描述，请<a href="../sqlrf/CREATE-INDEX.html#SQLRF53999" target="_blank"><span><cite>参见“Oracle数据库SQL语言参考</cite></span></a> ”</p>
                                 </li>
                                 <li>
                                    <p><a href="../refrn/ALL_INDEXES.html#GUID-E39825BA-70AC-45D8-AF30-C7FF561373B6" target="_blank"><span><cite>Oracle Database Reference</cite></span></a>了解<code class="codeph">ALL_INDEXES</code></p>
                                 </li>
                              </ul>
                           </div>
                        </div>
                        <!-- class="example" -->
                     </div>
                  </div>
               </div>
            </div><a id="CNCPT1182"></a><div class="props_rev_3"><a id="GUID-B15C4817-7748-456D-9740-8B9628AF9F47" name="GUID-B15C4817-7748-456D-9740-8B9628AF9F47"></a><h3 id="CNCPT-GUID-B15C4817-7748-456D-9740-8B9628AF9F47" class="sect3">位图索引概述</h3>
               <div>
                  <p>在位<span class="bold">图索引中</span> ，数据库存储每个索引键的位图。在传统的B树索引中，一个索引条目指向单个行。在位图索引中，每个索引键存储指向多行的指针。
                  </p>
                  <p>位图索引主要用于数据仓库或环境，其中查询以临时方式引用许多列。可能需要位图索引的情况包括：</p>
                  <ul style="list-style-type:disc">
                     <li>
                        <p>索引列具有低<a href="glossary.html#GUID-5CD22620-6D7A-40DC-BA09-EE3B5339C7F8"><span class="xrefglossterm">基数</span></a> ，即，与表行数相比，不同值的数量较小。
                        </p>
                     </li>
                     <li>
                        <p>索引表是只读的，或者不受DML语句的重大修改。</p>
                     </li>
                  </ul>
                  <p>对于数据仓库示例， <code class="codeph">sh.customers</code>表具有<code class="codeph">cust_gender</code>列，其中只有两个可能的值： <code class="codeph">M</code>和<code class="codeph">F</code>假设对特定性别的客户数量的查询是常见的。在这种情况下， <code class="codeph">customers.cust_gender</code>列将成为位图索引的候选者。
                  </p>
                  <p>位图中的每个位对应于可能的rowid。如果该位置位，则具有相应rowid的行包含键值。映射函数将位位置转换为实际的rowid，因此位图索引提供与B树索引相同的功能，尽管它使用不同的内部表示。</p>
                  <p>如果更新单行中的索引列，则数据库将锁定索引键条目（例如， <code class="codeph">M</code>或<code class="codeph">F</code> ），而不是映射到更新行的单个位。由于键指向许多行，因此索引数据上的DML通常会锁定所有这些行。因此，位图索引不适用于许多<a href="glossary.html#GUID-709E943F-FF0E-4AA6-979A-C4CB2A7B0C29"><span class="xrefglossterm">OLTP</span></a>应用程序。
                  </p>
                  <div class="infoboxnotealso" id="GUID-B15C4817-7748-456D-9740-8B9628AF9F47__GUID-057CB997-4E44-484C-891D-C9F0476DE020">
                     <p class="notep1">也可以看看：</p>
                     <ul style="list-style-type:disc">
                        <li>
                           <p><a href="../tgsql/index.html" target="_blank"><span class="italic">Oracle数据库SQL调优指南</span></a> ，了解如何使用位图索引提高性能</p>
                        </li>
                        <li>
                           <p><a href="../dwhsg/data-warehouse-optimizations-techniques.html#DWHSG8130" target="_blank"><span class="italic">Oracle数据库数据仓库指南</span></a> ，了解如何在数据仓库中使用位图索引</p>
                        </li>
                     </ul>
                  </div>
               </div><a id="CNCPT88848"></a><a id="CNCPT88849"></a><a id="CNCPT88847"></a><a id="CNCPT88846"></a><div class="props_rev_3"><a id="GUID-4D0B3A22-51F7-4F6E-8F95-B6AD7F9A2729" name="GUID-4D0B3A22-51F7-4F6E-8F95-B6AD7F9A2729"></a><h4 id="CNCPT-GUID-4D0B3A22-51F7-4F6E-8F95-B6AD7F9A2729" class="sect4">示例：单个表上的位图索引</h4>
                  <div>
                     <p>在此示例中， <code class="codeph">sh.customers</code>表的某些列是位图索引的候选列。
                     </p>
                     <div class="section">
                        <p>请考虑以下查询：</p><pre class="pre codeblock"><code>SQL&gt; SELECT cust_id，cust_last_name，cust_marital_status，cust_gender 2 FROM sh.customers 3 WHERE ROWNUM &lt;8 ORDER BY cust_id; CUST_ID CUST_LAST_ CUST_MAR C ---------- ---------- --------  -  1 Kessel M 2 Koch F 3 Emmerson M 4 Hardy M 5 Gowen M 6 Charles选择单F 7 Ingram单F 7行。
</code></pre><p><code class="codeph">cust_marital_status</code>和<code class="codeph">cust_gender</code>列的基数较低，而<code class="codeph">cust_id</code>和<code class="codeph">cust_last_name</code>则没有。因此，位图索引可能适用于<code class="codeph">cust_marital_status</code>和<code class="codeph">cust_gender</code> 。位图索引可能对其他列没有用。相反，这些列上的唯一B树索引可能提供最有效的表示和检索。
                        </p>
                        <p><a href="indexes-and-index-organized-tables.html#GUID-4D0B3A22-51F7-4F6E-8F95-B6AD7F9A2729__CBBGCGFC" title="此表说明了前面示例中显示的cust_gender列输出的位图索引。它由两个独立的位图组成，每个位图对应一个性别。">表3-4</a>说明了前面示例中显示的<code class="codeph">cust_gender</code>列输出的位图索引。它由两个独立的位图组成，每个位图对应一个性别。
                        </p>
                        <div class="tblformal" id="GUID-4D0B3A22-51F7-4F6E-8F95-B6AD7F9A2729__CBBGCGFC">
                           <p class="titleintable">表3-4一列的示例位图</p>
                           <table cellpadding="4" cellspacing="0" class="Formal" title="一列的示例位图" width="100%" border="1" summary="This table illustrates the bitmap index for the cust_gender column output shown in the preceding example. It consists of two separate bitmaps, one for each gender. " frame="hsides" rules="rows">
                              <thead>
                                 <tr align="left" valign="top">
                                    <th align="left" valign="bottom" width="16%" id="d20689e8978">值</th>
                                    <th align="left" valign="bottom" width="12%" id="d20689e8981">第1行</th>
                                    <th align="left" valign="bottom" width="12%" id="d20689e8984">第2行</th>
                                    <th align="left" valign="bottom" width="12%" id="d20689e8987">第3行</th>
                                    <th align="left" valign="bottom" width="12%" id="d20689e8990">第4行</th>
                                    <th align="left" valign="bottom" width="12%" id="d20689e8993">第5行</th>
                                    <th align="left" valign="bottom" width="12%" id="d20689e8996">第6行</th>
                                    <th align="left" valign="bottom" width="12%" id="d20689e8999">第7行</th>
                                 </tr>
                              </thead>
                              <tbody>
                                 <tr align="left" valign="top">
                                    <td align="left" valign="top" width="16%" id="d20689e9004" headers="d20689e8978 ">
                                       <p><code class="codeph">中号</code></p>
                                    </td>
                                    <td align="left" valign="top" width="12%" headers="d20689e9004 d20689e8981 ">
                                       <p>1</p>
                                    </td>
                                    <td align="left" valign="top" width="12%" headers="d20689e9004 d20689e8984 ">
                                       <p>0</p>
                                    </td>
                                    <td align="left" valign="top" width="12%" headers="d20689e9004 d20689e8987 ">
                                       <p>1</p>
                                    </td>
                                    <td align="left" valign="top" width="12%" headers="d20689e9004 d20689e8990 ">
                                       <p>1</p>
                                    </td>
                                    <td align="left" valign="top" width="12%" headers="d20689e9004 d20689e8993 ">
                                       <p>1</p>
                                    </td>
                                    <td align="left" valign="top" width="12%" headers="d20689e9004 d20689e8996 ">
                                       <p>0</p>
                                    </td>
                                    <td align="left" valign="top" width="12%" headers="d20689e9004 d20689e8999 ">
                                       <p>0</p>
                                    </td>
                                 </tr>
                                 <tr align="left" valign="top">
                                    <td align="left" valign="top" width="16%" id="d20689e9030" headers="d20689e8978 ">
                                       <p><code class="codeph">F</code></p>
                                    </td>
                                    <td align="left" valign="top" width="12%" headers="d20689e9030 d20689e8981 ">
                                       <p>0</p>
                                    </td>
                                    <td align="left" valign="top" width="12%" headers="d20689e9030 d20689e8984 ">
                                       <p>1</p>
                                    </td>
                                    <td align="left" valign="top" width="12%" headers="d20689e9030 d20689e8987 ">
                                       <p>0</p>
                                    </td>
                                    <td align="left" valign="top" width="12%" headers="d20689e9030 d20689e8990 ">
                                       <p>0</p>
                                    </td>
                                    <td align="left" valign="top" width="12%" headers="d20689e9030 d20689e8993 ">
                                       <p>0</p>
                                    </td>
                                    <td align="left" valign="top" width="12%" headers="d20689e9030 d20689e8996 ">
                                       <p>1</p>
                                    </td>
                                    <td align="left" valign="top" width="12%" headers="d20689e9030 d20689e8999 ">
                                       <p>1</p>
                                    </td>
                                 </tr>
                              </tbody>
                           </table>
                        </div>
                        <!-- class="inftblhruleinformal" -->
                        <p>映射函数将位图中的每个位转换为<code class="codeph">customers</code>表的rowid。每个位值取决于表中相应行的值。例如， <code class="codeph">M</code>值的位图包含<code class="codeph">1</code>作为其第一位，因为在<code class="codeph">customers</code>表的第一行中性别为<code class="codeph">M</code>位图<code class="codeph">cust_gender='M'</code>对于行2,6和7中的位具有<code class="codeph">0</code> ，因为这些行不包含<code class="codeph">M</code>作为它们的值。
                        </p>
                        <div class="infoboxnote" id="GUID-4D0B3A22-51F7-4F6E-8F95-B6AD7F9A2729__GUID-5191B3F6-6882-40D9-A54D-F61697A4C391">
                           <p class="notep1">注意：</p>
                           <p>与B树索引不同，位图索引可以包括完全由空值组成的键。索引空值对于某些SQL语句很有用，例如具有聚合函数<code class="codeph">COUNT</code>查询。</p>
                        </div>
                        <p>调查客户人口趋势的分析师可能会问：“我们有多少女性客户单身或离婚？“此问题对应于以下SQL查询：</p><pre class="pre codeblock"><code>SELECT COUNT（*）FROM customers WHERE cust_gender ='F'AND cust_marital_status IN（'single'，'divorced'）;</code></pre><p>位图索引可以通过计算结果位图中的<code class="codeph">1</code>值的数量来有效地处理此查询，如<a href="indexes-and-index-organized-tables.html#GUID-4D0B3A22-51F7-4F6E-8F95-B6AD7F9A2729__CBBGEJDG" title="位图索引的示例位图">表3-5所示</a> 。为了识别满足条件的客户，Oracle数据库可以使用生成的位图来访问该表。
                        </p>
                        <div class="tblformal" id="GUID-4D0B3A22-51F7-4F6E-8F95-B6AD7F9A2729__CBBGEJDG">
                           <p class="titleintable">表3-5两列的示例位图</p>
                           <table cellpadding="4" cellspacing="0" class="Formal" title="两列的示例位图" width="100%" border="1" summary="Sample bitmap for bitmap index" frame="hsides" rules="rows">
                              <thead>
                                 <tr align="left" valign="top">
                                    <th align="left" valign="bottom" width="14%" id="d20689e9118">值</th>
                                    <th align="left" valign="bottom" width="12%" id="d20689e9121">第1行</th>
                                    <th align="left" valign="bottom" width="12%" id="d20689e9124">第2行</th>
                                    <th align="left" valign="bottom" width="12%" id="d20689e9127">第3行</th>
                                    <th align="left" valign="bottom" width="12%" id="d20689e9130">第4行</th>
                                    <th align="left" valign="bottom" width="12%" id="d20689e9133">第5行</th>
                                    <th align="left" valign="bottom" width="12%" id="d20689e9136">第6行</th>
                                    <th align="left" valign="bottom" width="12%" id="d20689e9139">第7行</th>
                                 </tr>
                              </thead>
                              <tbody>
                                 <tr align="left" valign="top">
                                    <td align="left" valign="top" width="14%" id="d20689e9144" headers="d20689e9118 ">
                                       <p><code class="codeph">中号</code></p>
                                    </td>
                                    <td align="left" valign="top" width="12%" headers="d20689e9144 d20689e9121 ">
                                       <p>1</p>
                                    </td>
                                    <td align="left" valign="top" width="12%" headers="d20689e9144 d20689e9124 ">
                                       <p>0</p>
                                    </td>
                                    <td align="left" valign="top" width="12%" headers="d20689e9144 d20689e9127 ">
                                       <p>1</p>
                                    </td>
                                    <td align="left" valign="top" width="12%" headers="d20689e9144 d20689e9130 ">
                                       <p>1</p>
                                    </td>
                                    <td align="left" valign="top" width="12%" headers="d20689e9144 d20689e9133 ">
                                       <p>1</p>
                                    </td>
                                    <td align="left" valign="top" width="12%" headers="d20689e9144 d20689e9136 ">
                                       <p>0</p>
                                    </td>
                                    <td align="left" valign="top" width="12%" headers="d20689e9144 d20689e9139 ">
                                       <p>0</p>
                                    </td>
                                 </tr>
                                 <tr align="left" valign="top">
                                    <td align="left" valign="top" width="14%" id="d20689e9170" headers="d20689e9118 ">
                                       <p><code class="codeph">F</code></p>
                                    </td>
                                    <td align="left" valign="top" width="12%" headers="d20689e9170 d20689e9121 ">
                                       <p>0</p>
                                    </td>
                                    <td align="left" valign="top" width="12%" headers="d20689e9170 d20689e9124 ">
                                       <p>1</p>
                                    </td>
                                    <td align="left" valign="top" width="12%" headers="d20689e9170 d20689e9127 ">
                                       <p>0</p>
                                    </td>
                                    <td align="left" valign="top" width="12%" headers="d20689e9170 d20689e9130 ">
                                       <p>0</p>
                                    </td>
                                    <td align="left" valign="top" width="12%" headers="d20689e9170 d20689e9133 ">
                                       <p>0</p>
                                    </td>
                                    <td align="left" valign="top" width="12%" headers="d20689e9170 d20689e9136 ">
                                       <p>1</p>
                                    </td>
                                    <td align="left" valign="top" width="12%" headers="d20689e9170 d20689e9139 ">
                                       <p>1</p>
                                    </td>
                                 </tr>
                                 <tr align="left" valign="top">
                                    <td align="left" valign="top" width="14%" id="d20689e9196" headers="d20689e9118 ">
                                       <p><code class="codeph">单</code></p>
                                    </td>
                                    <td align="left" valign="top" width="12%" headers="d20689e9196 d20689e9121 ">
                                       <p>0</p>
                                    </td>
                                    <td align="left" valign="top" width="12%" headers="d20689e9196 d20689e9124 ">
                                       <p>0</p>
                                    </td>
                                    <td align="left" valign="top" width="12%" headers="d20689e9196 d20689e9127 ">
                                       <p>0</p>
                                    </td>
                                    <td align="left" valign="top" width="12%" headers="d20689e9196 d20689e9130 ">
                                       <p>0</p>
                                    </td>
                                    <td align="left" valign="top" width="12%" headers="d20689e9196 d20689e9133 ">
                                       <p>0</p>
                                    </td>
                                    <td align="left" valign="top" width="12%" headers="d20689e9196 d20689e9136 ">
                                       <p>1</p>
                                    </td>
                                    <td align="left" valign="top" width="12%" headers="d20689e9196 d20689e9139 ">
                                       <p>1</p>
                                    </td>
                                 </tr>
                                 <tr align="left" valign="top">
                                    <td align="left" valign="top" width="14%" id="d20689e9222" headers="d20689e9118 ">
                                       <p><code class="codeph">离婚</code></p>
                                    </td>
                                    <td align="left" valign="top" width="12%" headers="d20689e9222 d20689e9121 ">
                                       <p>0</p>
                                    </td>
                                    <td align="left" valign="top" width="12%" headers="d20689e9222 d20689e9124 ">
                                       <p>0</p>
                                    </td>
                                    <td align="left" valign="top" width="12%" headers="d20689e9222 d20689e9127 ">
                                       <p>0</p>
                                    </td>
                                    <td align="left" valign="top" width="12%" headers="d20689e9222 d20689e9130 ">
                                       <p>0</p>
                                    </td>
                                    <td align="left" valign="top" width="12%" headers="d20689e9222 d20689e9133 ">
                                       <p>0</p>
                                    </td>
                                    <td align="left" valign="top" width="12%" headers="d20689e9222 d20689e9136 ">
                                       <p>0</p>
                                    </td>
                                    <td align="left" valign="top" width="12%" headers="d20689e9222 d20689e9139 ">
                                       <p>0</p>
                                    </td>
                                 </tr>
                                 <tr align="left" valign="top">
                                    <td align="left" valign="top" width="14%" id="d20689e9248" headers="d20689e9118 ">
                                       <p><code class="codeph">single</code>或<code class="codeph">divorced</code> ，和<code class="codeph">F</code></p>
                                    </td>
                                    <td align="left" valign="top" width="12%" headers="d20689e9248 d20689e9121 ">
                                       <p>0</p>
                                    </td>
                                    <td align="left" valign="top" width="12%" headers="d20689e9248 d20689e9124 ">
                                       <p>0</p>
                                    </td>
                                    <td align="left" valign="top" width="12%" headers="d20689e9248 d20689e9127 ">
                                       <p>0</p>
                                    </td>
                                    <td align="left" valign="top" width="12%" headers="d20689e9248 d20689e9130 ">
                                       <p>0</p>
                                    </td>
                                    <td align="left" valign="top" width="12%" headers="d20689e9248 d20689e9133 ">
                                       <p>0</p>
                                    </td>
                                    <td align="left" valign="top" width="12%" headers="d20689e9248 d20689e9136 ">
                                       <p>1</p>
                                    </td>
                                    <td align="left" valign="top" width="12%" headers="d20689e9248 d20689e9139 ">
                                       <p>1</p>
                                    </td>
                                 </tr>
                              </tbody>
                           </table>
                        </div>
                        <!-- class="inftblhruleinformal" -->
                        <p>位图索引有效地合并了与<code class="codeph">WHERE</code>子句中的多个条件相对应的索引。满足某些条件但不是所有条件的行在访问表本身之前被过滤掉。这种技术通常可以显着改善响应时间。
                        </p>
                     </div>
                     <!-- class="section" -->
                  </div>
               </div><a id="CNCPT88850"></a><a id="CNCPT89157"></a><a id="CNCPT1188"></a><div class="props_rev_3"><a id="GUID-3286EBA4-0D5B-423D-815B-997A3E4B4B6C" name="GUID-3286EBA4-0D5B-423D-815B-997A3E4B4B6C"></a><h4 id="CNCPT-GUID-3286EBA4-0D5B-423D-815B-997A3E4B4B6C" class="sect4">位图加入索引</h4>
                  <div>
                     <p><span class="bold">位图连接索引</span>是两个或多个表的<span class="bold">连接</span>的位图索引。
                     </p>
                     <p>对于表列中的每个值，索引都会在索引表中存储相应行的rowid。相反，在单个表上创建标准位图索引。</p>
                     <p>位图连接索引是通过预先执行限制来减少必须连接的数据量的有效方法。有关位图连接索引有用的示例，假设用户经常查询具有特定作业类型的员工数。典型查询可能如下所示：</p><pre class="pre codeblock"><code>SELECT COUNT（*）FROM employees，jobs WHERE employees.job_id = jobs.job_id AND jobs.job_title ='Accountant';</code></pre><p>上述查询通常使用<code class="codeph">jobs.job_title</code>上的索引来检索<code class="codeph">Accountant</code>的行，然后检查作业ID，并使用<code class="codeph">employees.job_id</code>上的索引来查找匹配的行。要从索引本身而不是从表的扫描中检索数据，您可以创建位图连接索引，如下所示：</p><pre class="pre codeblock"><code>CREATE BITMAP INDEX employees_bm_idx ON employees（jobs.job_title）FROM employees，jobs WHERE employees.job_id = jobs.job_id;</code></pre><p>如下图所示，索引键是<code class="codeph">jobs.job_title</code> ，索引表是<code class="codeph">employees</code> 。
                     </p>
                     <div class="figure" id="GUID-3286EBA4-0D5B-423D-815B-997A3E4B4B6C__CBBDIJFJ">
                        <p class="titleinfigure">图3-2位图连接索引</p><img src="img/cncpt239.gif" alt="下面是图3-2的描述" title="下面是图3-2的描述" longdesc="img_text/cncpt239.html"><br><a href="img_text/cncpt239.html">“图3-2位图连接索引”的说明</a></div>
                     <!-- class="figure" -->
                     <p>从概念上讲， <code class="codeph">employees_bm_idx</code>是以下查询中显示的SQL查询中的<code class="codeph">jobs.title</code>列的索引（包括示例输出）。索引中的<code class="codeph">job_title</code>键指向<code class="codeph">employees</code>表中的行。对会计师数量的查询可以使用索引来避免访问<code class="codeph">employees</code>和<code class="codeph">jobs</code>表，因为索引本身包含所请求的信息。
                     </p><pre class="pre codeblock"><code>SELECT jobs.job_title AS“jobs.job_title”，employees.rowid AS“employees.rowid”FROM employees，jobs WHERE employees.job_id = jobs.job_id ORDER BY job_title; jobs.job_title employees.rowid ----------------------------------- --------- ---------会计师AAAQNKAAFAAAABSAAL会计师AAAQNKAAFAAAABSAAN会计师AAAQNKAAFAAAABSAAM会计师AAAQNKAAFAAAABSAAJ会计师AAAQNKAAFAAAABSAAK会计经理AAAQNKAAFAAAABTAAH行政助理AAAQNKAAFAAAABTAAC行政副总裁AAAQNKAAFAAAABSAAC行政副总裁AAAQNKAAFAAAABSAAB。。。
</code></pre><p>在数据仓库中， <a href="glossary.html#GUID-6DF529B9-611D-4C00-BAF8-614E86BCB39E"><span class="xrefglossterm">连接条件</span></a>是维度表的主键列与事实表中的外键列之间的<a href="glossary.html#GUID-2DD43111-489E-4F08-9949-AD0C21858DCB"><span class="xrefglossterm">等值连接</span></a> （它使用等于运算符）。位图连接索引有时在存储方面比物化连接视图更有效，这是提前实现连接的替代方法。
                     </p>
                     <div class="infoboxnotealso" id="GUID-3286EBA4-0D5B-423D-815B-997A3E4B4B6C__GUID-4833E0A3-8614-4682-8DE5-BAA464EC3FBB">
                        <p class="notep1">也可以看看：</p>
                        <p>有关位图连接索引的详细信息，请<a href="../dwhsg/data-warehouse-optimizations-techniques.html#DWHSG9047" target="_blank"><span><cite>参见“Oracle数据库数据仓库指南”</cite></span></a></p>
                     </div>
                  </div>
               </div><a id="CNCPT88851"></a><div class="props_rev_3"><a id="GUID-AB4829E0-C1B7-4554-9ECB-7CCB7A992FE9" name="GUID-AB4829E0-C1B7-4554-9ECB-7CCB7A992FE9"></a><h4 id="CNCPT-GUID-AB4829E0-C1B7-4554-9ECB-7CCB7A992FE9" class="sect4">位图存储结构</h4>
                  <div>
                     <p>Oracle数据库使用B树索引结构来存储每个索引键的位图。</p>
                     <p>例如，如果<code class="codeph">jobs.job_title</code>是位图索引的键列，则一个B树存储索引数据。叶块存储各个位图。
                     </p>
                     <div class="example" id="GUID-AB4829E0-C1B7-4554-9ECB-7CCB7A992FE9__GUID-A03E8FE5-7204-488F-8DC6-8536D2A21AE3">
                        <p class="titleinexample">示例3-6位图存储示例</p>
                        <p>假设<code class="codeph">jobs.job_title</code>列具有唯一值<code class="codeph">Shipping Clerk</code> ， <code class="codeph">Stock Clerk</code>和其他几个。此索引的位图索引条目具有以下组件：</p>
                        <ul style="list-style-type:disc">
                           <li>
                              <p>作业标题为索引键</p>
                           </li>
                           <li>
                              <p>一系列rowid的低rowid和高rowid</p>
                           </li>
                           <li>
                              <p>范围中特定rowid的位图</p>
                           </li>
                        </ul>
                        <p>从概念上讲，此索引中的索引叶块可以包含如下条目：</p><pre class="pre codeblock"><code>船务文员，AAAPzRAAFAAAABSABQ，AAAPzRAAFAAAABSABZ，0010000100船务文员，AAAPzRAAFAAAABSABa，AAAPzRAAFAAAABSABh，010010股票办事员，AAAPzRAAFAAAABSAAa，AAAPzRAAFAAAABSAAc，1001001100股票办事员，AAAPzRAAFAAAABSAAd，AAAPzRAAFAAAABSAAt，0101001001股票办事员，AAAPzRAAFAAAABSAAu，AAAPzRAAFAAAABSABz，100001。。。
</code></pre><p>相同的作业标题出现在多个条目中，因为rowid范围不同。</p>
                        <p>会话将一名员工的工作ID从<code class="codeph">Shipping Clerk</code>为<code class="codeph">Stock Clerk</code> 。在这种情况下，会话需要对旧值（ <code class="codeph">Shipping Clerk</code> ）和新值（ <code class="codeph">Stock Clerk</code> ）的索引键条目进行独占访问。Oracle数据库会锁定这两个条目指向的行 - 但不会锁定<code class="codeph">Accountant</code>指向的行或任何其他键 - 直到<code class="codeph">UPDATE</code>提交。
                        </p>
                        <p>位图索引的数据存储在一个段中。Oracle数据库将每个位图存储在一个或多个部分中。每个部分占据单个数据块的一部分。</p>
                        <div class="infoboxnotealso" id="GUID-AB4829E0-C1B7-4554-9ECB-7CCB7A992FE9__GUID-B222837E-5C0E-43A6-A20E-DEF98D490AA7">
                           <p class="notep1">也可以看看：</p>
                           <p><span class="q">“ <a href="logical-storage-structures.html#GUID-EFB292CB-87EA-42AA-808C-BD85E540BACC" title="数据库中的单个数据段存储一个用户对象的数据。">用户细分</a> ”</span>解释了不同类型的细分以及细分细分的创建方式</p>
                        </div>
                     </div>
                     <!-- class="example" -->
                  </div>
               </div>
            </div><a id="CNCPT1161"></a><div class="props_rev_3"><a id="GUID-9AD7651D-0F0D-4FC6-A984-5845F0224EE6" name="GUID-9AD7651D-0F0D-4FC6-A984-5845F0224EE6"></a><h3 id="CNCPT-GUID-9AD7651D-0F0D-4FC6-A984-5845F0224EE6" class="sect3">基于函数的索引概述</h3>
               <div>
                  <p><span class="bold">基于函数的索引</span>计算涉及一列或多列的函数或表达式的值，并将其存储在索引中。基于函数的索引可以是B树或位图索引。
                  </p>
                  <p>索引函数可以是算术表达式或包含SQL函数，用户定义的PL / SQL函数，包函数或C标注的表达式。例如，函数可以将值添加到两列中。</p>
                  <div class="infoboxnotealso" id="GUID-9AD7651D-0F0D-4FC6-A984-5845F0224EE6__GUID-D2E28556-0B8E-4A14-8792-D5D589290717">
                     <p class="notep1">也可以看看：</p>
                     <ul style="list-style-type:disc">
                        <li>
                           <p><a href="../admin/managing-indexes.html#ADMIN11730" target="_blank"><span class="italic">Oracle数据库管理员指南</span></a> ，了解如何创建基于函数的索引</p>
                        </li>
                        <li>
                           <p>有关使用基于函数的索引的详细信息，请<a href="../tgsql/index.html" target="_blank"><span class="italic">参见“Oracle数据库SQL调优指南”</span></a></p>
                        </li>
                        <li>
                           <p><a href="../sqlrf/CREATE-INDEX.html#SQLRF53993" target="_blank"><span class="italic">Oracle数据库SQL语言参考</span></a> ，用于基于函数的索引的限制和使用说明</p>
                        </li>
                     </ul>
                  </div>
               </div><a id="CNCPT88852"></a><a id="CNCPT1162"></a><div class="props_rev_3"><a id="GUID-9B3F9FB8-6A17-442B-A294-06CD8096CC10" name="GUID-9B3F9FB8-6A17-442B-A294-06CD8096CC10"></a><h4 id="CNCPT-GUID-9B3F9FB8-6A17-442B-A294-06CD8096CC10" class="sect4">基于函数的索引的使用</h4>
                  <div>
                     <p>基于函数的索引可以有效地评估包含<code class="codeph">WHERE</code>子句中的函数的语句。当函数包含在查询中时，数据库仅使用基于函数的索引。但是，当数据库处理<code class="codeph">INSERT</code>和<code class="codeph">UPDATE</code>语句时，它仍然必须评估处理语句的函数。
                     </p>
                     <div class="example" id="GUID-9B3F9FB8-6A17-442B-A294-06CD8096CC10__GUID-66A7BA6D-17B4-4F72-A490-81D10C4A58D6">
                        <p class="titleinexample">例3-7基于算术表达式的索引</p>
                        <p>例如，假设您创建以下基于函数的索引：</p><pre class="oac_no_warn" dir="ltr">CREATE INDEX emp_total_sal_idx ON员工（12 * salary * commission_pct，salary，commission_pct）;</pre><p>在处理诸如以下的查询（包括部分样本输出）时，数据库可以使用前面的索引：</p><pre class="oac_no_warn" dir="ltr">SELECT employee_id，last_name，first_name，12 * salary * commission_pct AS“ANNUAL SAL”来自员工WHERE（12 * salary * commission_pct）&lt;30000 ORDER BY“ANN SAL”DESC; EMPLOYEE_ID LAST_NAME FIRST_NAME年度SAL ----------- ------------------------- --------- ----------- ---------- 159 Smith Lindsey 28800 151 Bernstein David 28500 152 Hall Peter 27000 160 Doran Louise 27000 175 Hutton Alyssa 26400 149 Zlotkey Eleni 25200 169 Bloom Harrison 24000</pre></div>
                     <!-- class="example" -->
                     <div class="example" id="GUID-9B3F9FB8-6A17-442B-A294-06CD8096CC10__GUID-B70EEB84-D9A8-4683-97C7-7BF726E6DD5A">
                        <p class="titleinexample">例3-8基于UPPER函数的索引</p>
                        <p>在SQL函数<code class="codeph">UPPER(</code> <span class="italic"><code class="codeph">column_name</code></span> <code class="codeph">)</code>或<code class="codeph">LOWER(</code> <span class="italic"><code class="codeph">column_name</code></span> <code class="codeph">)</code>上定义的基于函数的索引有助于不区分大小写的搜索。例如，假设<code class="codeph">employees</code>中的<code class="codeph">first_name</code>列包含大小写混合字符。您在<code class="codeph">hr.employees</code>表上创建以下基于函数的索引：</p><pre class="oac_no_warn" dir="ltr">CREATE INDEX emp_fname_uppercase_idx ON雇员（UPPER（first_name））;</pre><p><code class="codeph">emp_fname_uppercase_idx</code>索引可以促进查询，例如：</p><pre class="oac_no_warn" dir="ltr">SELECT * FROM employees WHERE UPPER（first_name）='AUDREY';</pre></div>
                     <!-- class="example" -->
                     <div class="example" id="GUID-9B3F9FB8-6A17-442B-A294-06CD8096CC10__GUID-DB850AB8-07E0-4764-92D2-3D556E646E8B">
                        <p class="titleinexample">示例3-9索引表中的特定行</p>
                        <p>基于函数的索引对于仅索引表中的特定行也很有用。例如， <code class="codeph">cust_valid</code>在列<code class="codeph">sh.customers</code>表具有要么<code class="codeph">I</code>或<code class="codeph">A</code>作为值。要仅索引<code class="codeph">A</code>行，您可以编写一个函数，该函数为<code class="codeph">A</code>行以外的任何行返回空值。您可以按如下方式创建索引：</p><pre class="oac_no_warn" dir="ltr">CREATE INDEX cust_valid_idx ON客户（CASE cust_valid WHEN'A'THEN'A'END）;</pre><div class="infoboxnotealso" id="GUID-9B3F9FB8-6A17-442B-A294-06CD8096CC10__GUID-55C7CC87-08AC-48F3-BA1E-01469D9B59AD">
                           <p class="notep1">也可以看看：</p>
                           <ul style="list-style-type:disc">
                              <li>
                                 <p>有关语言索引的信息，请参见<a href="../nlspg/linguistic-sorting-and-matching.html#NLSPG294" target="_blank"><span class="italic">“Oracle数据库全球化支持指南”</span></a></p>
                              </li>
                              <li>
                                 <p><a href="../sqlrf/About-SQL-Functions.html#SQLRF51173" target="_blank"><span class="italic">Oracle数据库SQL语言参考，</span></a>以了解有关SQL函数的更多信息</p>
                              </li>
                           </ul>
                        </div>
                     </div>
                     <!-- class="example" -->
                  </div>
               </div><a id="CNCPT1163"></a><div class="props_rev_3"><a id="GUID-851F9DC0-F91B-474E-9CB4-E48F81588147" name="GUID-851F9DC0-F91B-474E-9CB4-E48F81588147"></a><h4 id="CNCPT-GUID-851F9DC0-F91B-474E-9CB4-E48F81588147" class="sect4">基于函数的索引优化</h4>
                  <div>
                     <p>对于在<code class="codeph">WHERE</code>子句中具有表达式的<code class="codeph">WHERE</code> ，优化程序可以对基于函数的索引使用索引范围扫描。
                     </p>
                     <p>当谓词具有高选择性时，即当它选择相对较少的行时，范围扫描<a href="glossary.html#GUID-56F7FB03-3499-4D51-8D23-F86C45194F09"><span class="xrefglossterm">访问路径</span></a>尤其有用。在<a href="indexes-and-index-organized-tables.html#GUID-9B3F9FB8-6A17-442B-A294-06CD8096CC10__GUID-66A7BA6D-17B4-4F72-A490-81D10C4A58D6">示例3-7中</a> ，如果索引构建在表达式<code class="codeph">12*salary*commission_pct</code> ，则<a href="glossary.html#GUID-54114749-0A81-41D7-8E16-7B76D93CEE2B"><span class="xrefglossterm">优化程序</span></a>可以使用索引范围扫描。
                     </p>
                     <p><a href="glossary.html#GUID-E95FC6AD-C932-4DE2-9D7B-B98D1168E7DA"><span class="xrefglossterm">虚拟列</span></a>对于加速对从表达式派生的数据的访问也很有用。例如，您可以将虚拟列<code class="codeph">annual_sal</code>定义为<code class="codeph">12*salary*commission_pct</code>并在<code class="codeph">annual_sal</code>上创建基于函数的索引。
                     </p>
                     <p>优化器通过在SQL语句中解析表达式，然后比较语句的表达式树和基于函数的索引来执行表达式匹配。此比较不区分大小写并忽略空格。</p>
                     <div class="infoboxnotealso" id="GUID-851F9DC0-F91B-474E-9CB4-E48F81588147__GUID-A02B5DF8-7746-4A7C-A9E4-F827E25AB901">
                        <p class="notep1">也可以看看：</p>
                        <ul style="list-style-type:disc">
                           <li>
                              <p><span class="q">“ <a href="sql.html#GUID-3F42B1AA-530A-4144-8179-F0074832AF81" title="要了解Oracle数据库如何处理SQL语句，有必要了解数据库中称为优化器的部分（也称为查询优化器或基于成本的优化器）。所有SQL语句都使用优化器来确定访问指定数据的最有效方法。">优化器概述</a> ”</span></p>
                           </li>
                           <li>
                              <p><a href="../tgsql/gathering-optimizer-statistics.html#TGSQL389" target="_blank"><span><cite>Oracle数据库SQL调优指南</cite></span></a> ，了解有关收集统计信息的更多信息</p>
                           </li>
                           <li>
                              <p><a href="../admin/index.html" target="_blank"><span><cite>Oracle数据库管理员指南</cite></span></a> ，了解如何向表中添加虚拟列</p>
                           </li>
                        </ul>
                     </div>
                  </div>
               </div>
            </div><a id="CNCPT607"></a><div class="props_rev_3"><a id="GUID-9586EB86-4B84-4A43-A66D-958776FE558B" name="GUID-9586EB86-4B84-4A43-A66D-958776FE558B"></a><h3 id="CNCPT-GUID-9586EB86-4B84-4A43-A66D-958776FE558B" class="sect3">应用程序域索引概述</h3>
               <div>
                  <p><span class="bold">应用程序域索引</span>是特定于应用程序的自定义索引。
                  </p>
                  <p>广泛的索引可以：</p>
                  <ul style="list-style-type:disc">
                     <li>
                        <p>在自定义的复杂数据类型（如文档，空间数据，图像和视频剪辑）上容纳索引（请参阅<span class="q">“ <a href="concepts-for-database-developers.html#GUID-B39E395E-99FF-4FF1-AC65-E581BD53EFA9" title="非结构化数据是不会分解为较小逻辑结构的数据。">非结构化数据</a> ”</span> ）</p>
                     </li>
                     <li>
                        <p>利用专门的索引技术</p>
                     </li>
                  </ul>
                  <p>您可以将特定于应用程序的索引管理例程封装为indextype架构对象，然后在表列或对象类型的属性上定义域索引。可扩展索引可以有效地处理特定于应用程序的运算符。</p>
                  <p>称为<span class="italic">盒式磁带</span>的应用程序软件控制域索引的结构和内容。数据库与应用程序交互以构建，维护和搜索域索引。索引结构本身可以作为索引组织表存储在数据库中，也可以作为文件存储在外部。
                  </p>
                  <div class="infoboxnotealso" id="GUID-9586EB86-4B84-4A43-A66D-958776FE558B__GUID-F972C008-870C-4F2F-9BFB-D1F8D482D4A3">
                     <p class="notep1">也可以看看：</p>
                     <p><a href="../addci/introduction-to-data-cartridges.html#ADDCI110" target="_blank"><span class="italic">“Oracle数据库数据盒带开发人员指南”</span></a> ，了解有关在Oracle数据库可扩展性体系结构中使用数据盒带的信息</p>
                  </div>
               </div>
            </div><a id="CNCPT911"></a><div class="props_rev_3"><a id="GUID-DAEC075B-C16D-4A57-898C-70EBCB364F0C" name="GUID-DAEC075B-C16D-4A57-898C-70EBCB364F0C"></a><h3 id="CNCPT-GUID-DAEC075B-C16D-4A57-898C-70EBCB364F0C" class="sect3">索引组织表概述</h3>
               <div>
                  <p><span class="bold">索引组织表</span>是存储在B树索引结构的变体中的表。相反， <span class="bold">堆组织表</span>在适合的位置插入行。
                  </p>
                  <p>在索引组织表中，行存储在表的主键上定义的索引中。B树中的每个索引条目还存储非键列值。因此，索引是数据，数据是索引。应用程序使用SQL语句操作索引组织表，就像堆组织表一样。</p>
                  <p>对于索引组织表的类比，假设人力资源经理有一个纸箱的书柜。每个方框都标有数字-1,2,3,4等，但这些方框不按顺序排列在货架上。相反，每个框都包含指向序列中下一个框的搁架位置的指针。</p>
                  <p>包含员工记录的文件夹存储在每个框中。文件夹按员工ID排序。员工King的ID为100，这是最低的ID，因此他的文件夹位于第1栏的底部。员工101的文件夹位于100的顶部，102位于101的顶部，依此类推，直到框1已满。序列中的下一个文件夹位于方框2的底部。</p>
                  <p>在这个类比中，按员工ID排序文件夹可以有效地搜索文件夹而无需维护单独的索引。假设用户请求雇员107,120和122的记录。管理员可以按顺序搜索文件夹，并检索找到的每个文件夹，而不是一步搜索索引并在单独的步骤中检索文件夹。</p>
                  <p>索引组织表通过主键或密钥的有效前缀提供对表行的更快访问。叶块中行的非键列的存在避免了额外的数据块I / O.例如，员工100的工资存储在索引行本身中。此外，由于行以主键顺序存储，因此主键或前缀的范围访问涉及最小的块I / O.另一个好处是避免了单独的主键索引的空间开销。</p>
                  <p>当必须将相关数据存储在一起或者数据必须以特定顺序物理存储时，索引组织表非常有用。此类表的典型用途是用于信息检索，空间数据和<a href="glossary.html#GUID-A6734D1E-A45B-4BE3-ABF8-F6201A40F6B3"><span class="xrefglossterm">OLAP</span></a>应用程序。
                  </p>
                  <div class="infoboxnotealso" id="GUID-DAEC075B-C16D-4A57-898C-70EBCB364F0C__GUID-3C453C0E-ED98-4335-8E9D-E76C9AE05A35">
                     <p class="notep1">也可以看看：</p>
                     <ul style="list-style-type:disc">
                        <li>
                           <p><span class="q">“ <a href="concepts-for-database-developers.html#GUID-F3C48565-B360-40F2-A201-239D614139B5" title="Oracle Spatial and Graph（空间和图形）包括用于空间数据和分析以及物理，逻辑，网络以及社交和语义图形应用程序的高级功能。">Oracle Spatial and Graph概述</a> ”</span></p>
                        </li>
                        <li>
                           <p><span class="q">“ <a href="topics-for-database-administrators-and-developers.html#GUID-8905A5A6-1546-47E8-A7D7-C83E9D7F4903" title="Oracle在线分析处理（OLAP）在跨多个维度分析数据时提供本机多维存储和快速响应时间。OLAP使分析人员能够在交互式会话期间快速获取复杂迭代查询的答案。">OLAP</a> ”</span></p>
                        </li>
                        <li>
                           <p><a href="../admin/managing-tables.html#ADMIN01506" target="_blank"><span><cite>Oracle数据库管理员指南</cite></span></a> ，了解如何管理索引组织表</p>
                        </li>
                        <li>
                           <p><a href="../tgsql/index.html" target="_blank"><span><cite>Oracle数据库SQL调优指南</cite></span></a> ，了解如何使用索引组织表来提高性能</p>
                        </li>
                        <li>
                           <p>用于<code class="codeph">CREATE TABLE ... <a href="../sqlrf/CREATE-TABLE.html#SQLRF54492" target="_blank"><span><cite>Oracle数据库SQL语言参考</cite></span></a> <code class="codeph">CREATE TABLE ...ORGANIZATION INDEX</code>语法和语义</p>
                        </li>
                     </ul>
                  </div>
               </div><a id="CNCPT88854"></a><a id="CNCPT88855"></a><a id="CNCPT88853"></a><div class="props_rev_3"><a id="GUID-279309E0-3D53-47C5-8FA8-249BD835C88A" name="GUID-279309E0-3D53-47C5-8FA8-249BD835C88A"></a><h4 id="CNCPT-GUID-279309E0-3D53-47C5-8FA8-249BD835C88A" class="sect4">索引组织表特征</h4>
                  <div>
                     <p>数据库系统通过操纵B树索引结构对索引组织表执行所有操作。</p>
                     <p>下表总结了索引组织表和堆组织表之间的差异。</p>
                     <div class="tblformal" id="GUID-279309E0-3D53-47C5-8FA8-249BD835C88A__G37535">
                        <p class="titleintable">表3-6堆组织表与索引组织表的比较</p>
                        <table cellpadding="4" cellspacing="0" class="Formal" title="堆积表与指数组织表的比较" width="100%" border="1" summary="This table compares index-organized tables with ordinary tables." frame="hsides" rules="rows">
                           <thead>
                              <tr align="left" valign="top">
                                 <th align="left" valign="bottom" width="50%" id="d20689e11999">堆组织表</th>
                                 <th align="left" valign="bottom" width="50%" id="d20689e12002">索引组织表</th>
                              </tr>
                           </thead>
                           <tbody>
                              <tr align="left" valign="top">
                                 <td align="left" valign="top" width="50%" id="d20689e12007" headers="d20689e11999 ">
                                    <p>rowid唯一标识一行。可以可选地定义主键约束。</p>
                                 </td>
                                 <td align="left" valign="top" width="50%" headers="d20689e12007 d20689e12002 ">
                                    <p>主键唯一标识一行。必须定义主键约束。</p>
                                 </td>
                              </tr>
                              <tr align="left" valign="top">
                                 <td align="left" valign="top" width="50%" id="d20689e12014" headers="d20689e11999 ">
                                    <p><code class="codeph">ROWID</code> <a href="glossary.html#GUID-175D4923-5C7E-4FF0-A69B-C4D8F3D93A3D"><span class="xrefglossterm">伪列中的</span></a>物理rowid允许构建二级索引。
                                    </p>
                                 </td>
                                 <td align="left" valign="top" width="50%" headers="d20689e12014 d20689e12002 ">
                                    <p><code class="codeph">ROWID</code>伪列中的逻辑rowid允许构建二级索引。
                                    </p>
                                 </td>
                              </tr>
                              <tr align="left" valign="top">
                                 <td align="left" valign="top" width="50%" id="d20689e12030" headers="d20689e11999 ">
                                    <p>rowid可以直接访问各行。</p>
                                 </td>
                                 <td align="left" valign="top" width="50%" headers="d20689e12030 d20689e12002 ">
                                    <p>可以通过主键间接地实现对各行的访问。</p>
                                 </td>
                              </tr>
                              <tr align="left" valign="top">
                                 <td align="left" valign="top" width="50%" id="d20689e12037" headers="d20689e11999 ">
                                    <p>顺序<a href="glossary.html#GUID-BF9B54D6-892E-4C3B-8536-38958ACC069D"><span class="xrefglossterm">全表扫描</span></a>以某种顺序返回所有行。
                                    </p>
                                 </td>
                                 <td align="left" valign="top" width="50%" headers="d20689e12037 d20689e12002 ">
                                    <p>完整索引扫描或快速完整索引扫描以某种顺序返回所有行。</p>
                                 </td>
                              </tr>
                              <tr align="left" valign="top">
                                 <td align="left" valign="top" width="50%" id="d20689e12047" headers="d20689e11999 ">
                                    <p>可以与其他表一起存储在<a href="glossary.html#GUID-1C56177E-6BEE-4FE7-B45E-38298CDB946D"><span class="xrefglossterm">表集群中</span></a> 。
                                    </p>
                                 </td>
                                 <td align="left" valign="top" width="50%" headers="d20689e12047 d20689e12002 ">
                                    <p>无法存储在表群集中。</p>
                                 </td>
                              </tr>
                              <tr align="left" valign="top">
                                 <td align="left" valign="top" width="50%" id="d20689e12057" headers="d20689e11999 ">
                                    <p>可以包含<code class="codeph">LONG</code>数据类型的列和<a href="glossary.html#GUID-A85748CE-C4D4-43ED-BD49-29AFC4AD3A02"><span class="xrefglossterm">LOB</span></a>数据类型的列。
                                    </p>
                                 </td>
                                 <td align="left" valign="top" width="50%" headers="d20689e12057 d20689e12002 ">
                                    <p>可以包含LOB列但不包含<code class="codeph">LONG</code>列。
                                    </p>
                                 </td>
                              </tr>
                              <tr align="left" valign="top">
                                 <td align="left" valign="top" width="50%" id="d20689e12073" headers="d20689e11999 ">
                                    <p>可以包含虚拟列（仅支持关系堆表）。</p>
                                 </td>
                                 <td align="left" valign="top" width="50%" headers="d20689e12073 d20689e12002 ">
                                    <p>不能包含虚拟列。</p>
                                 </td>
                              </tr>
                           </tbody>
                        </table>
                     </div>
                     <!-- class="inftblhruleinformal" -->
                     <p><a href="indexes-and-index-organized-tables.html#GUID-279309E0-3D53-47C5-8FA8-249BD835C88A__CHDJGJHG">图3-3</a>说明了索引组织的<code class="codeph">departments</code>表的结构。叶块包含表的行，按主键顺序排列。例如，第一个叶块中的第一个值显示部门ID为<code class="codeph">20</code> ， <code class="codeph">Marketing</code>部门名称，经理ID为<code class="codeph">201</code> ，位置ID为<code class="codeph">1800</code> 。
                     </p>
                     <div class="figure" id="GUID-279309E0-3D53-47C5-8FA8-249BD835C88A__CHDJGJHG">
                        <p class="titleinfigure">图3-3索引组织表</p><img src="img/cncpt272.gif" alt="下面是图3-3的描述" title="下面是图3-3的描述" longdesc="img_text/cncpt272.html"><br><a href="img_text/cncpt272.html">“图3-3索引组织表”的说明</a></div>
                     <!-- class="figure" -->
                     <div class="example" id="GUID-279309E0-3D53-47C5-8FA8-249BD835C88A__GUID-C167D691-2FEF-4C6A-9607-353330F31869">
                        <p class="titleinexample">例3-10索引组织表的扫描</p>
                        <p>索引组织表将所有数据存储在同一结构中，而不需要存储rowid。<a href="indexes-and-index-organized-tables.html#GUID-279309E0-3D53-47C5-8FA8-249BD835C88A__CHDJGJHG">如图3-3</a>所示，索引组织表中的叶块1可能包含如下条目，按主键排序：</p><pre class="pre codeblock"><code>20，营销，201,1800 30，采购，114,1700</code></pre><p>索引组织表中的叶块2可能包含如下条目：</p><pre class="pre codeblock"><code>50，运输，121,1500 60，IT，103,1400</code></pre><p>以主键顺序扫描索引组织的表行按以下顺序读取块：</p>
                        <ol>
                           <li>
                              <p>第1座</p>
                           </li>
                           <li>
                              <p>第2块</p>
                           </li>
                        </ol>
                     </div>
                     <!-- class="example" -->
                     <div class="example" id="GUID-279309E0-3D53-47C5-8FA8-249BD835C88A__GUID-A6077072-BF54-48FC-B3FF-5A2679A2A120">
                        <p class="titleinexample">实施例3-11堆积组织表的扫描</p>
                        <p>为了将堆组织表中的数据访问与索引组织表进行对比，假设堆组织<code class="codeph">departments</code>表段的块1包含如下行：</p><pre class="pre codeblock"><code>50，Shipping，121,1500 20，Marketing，201,1800</code></pre><p>块2包含同一个表的行，如下所示：</p><pre class="pre codeblock"><code>30，采购，114,1700 60，IT，103,1400</code></pre><p>此堆组织表的B树索引叶块包含以下条目，其中第一个值是主键，第二个值是rowid：</p><pre class="pre codeblock"><code>20，AAAPeXAAFAAAAAYAAD 30，AAAPeXAAFAAAAAAAAA 50，AAAPeXAAFAAAAAyAAC 60，AAAPeXAAFAAAAAAAAAB</code></pre><p>以主键顺序扫描表行按以下顺序读取表段块：</p>
                        <ol>
                           <li>
                              <p>第1座</p>
                           </li>
                           <li>
                              <p>第2块</p>
                           </li>
                           <li>
                              <p>第1座</p>
                           </li>
                           <li>
                              <p>第2块</p>
                           </li>
                        </ol>
                        <p>因此，该示例中的块I / O的数量是索引组织示例中的数量的两倍。</p>
                        <div class="infoboxnotealso" id="GUID-279309E0-3D53-47C5-8FA8-249BD835C88A__GUID-8E876764-17B1-4861-871E-470A331296A3">
                           <p class="notep1">也可以看看：</p>
                           <ul style="list-style-type:disc">
                              <li>
                                 <p><span class="q">“ <a href="tables-and-table-clusters.html#GUID-4C718D65-D7AF-4596-9A31-C11938047224" title="默认情况下，表被组织为堆，这意味着数据库将行放在最适合的位置而不是用户指定的顺序。因此，堆组织表是无序的行集合。">表组织</a> ”</span></p>了解有关堆组织表的更多信息</li>
                              <li>
                                 <p><span class="q">“ <a href="logical-storage-structures.html#GUID-52FE1A8C-74EA-4B81-B1AC-69FD34252659" title="Oracle数据库为数据库中的所有数据分配逻辑空间。">逻辑存储结构简介</a> ”</span></p>了解有关段和数据块之间关系的更多信息</li>
                           </ul>
                        </div>
                     </div>
                     <!-- class="example" -->
                  </div>
               </div><a id="CNCPT1190"></a><div class="props_rev_3"><a id="GUID-6AB23645-4BE6-4958-A9C3-0B05077C23D6" name="GUID-6AB23645-4BE6-4958-A9C3-0B05077C23D6"></a><h4 id="CNCPT-GUID-6AB23645-4BE6-4958-A9C3-0B05077C23D6" class="sect4">具有行溢出区域的索引组织表</h4>
                  <div>
                     <p>创建索引组织表时，可以将单独的段指定为行溢出区域。</p>
                     <p>在索引组织表中，B树索引条目可能很大，因为它们包含整行，因此包含条目的单独段很有用。相反，B树条目通常很小，因为它们由key和rowid组成。</p>
                     <p>如果指定了行溢出区域，则数据库可以将索引组织表中的行划分为以下部分：</p>
                     <ul style="list-style-type:disc">
                        <li>
                           <p>索引条目</p>
                           <p>此部分包含所有主键列的列值，指向行的溢出部分的物理rowid，以及可选的一些非键列。该部分存储在索引段中。</p>
                        </li>
                        <li>
                           <p>溢出部分</p>
                           <p>此部分包含其余非键列的列值。该部分存储在溢出存储区段中。</p>
                        </li>
                     </ul>
                     <div class="infoboxnotealso" id="GUID-6AB23645-4BE6-4958-A9C3-0B05077C23D6__GUID-EA3976D6-59E6-4AA7-BFE4-2B84744E2806">
                        <p class="notep1">也可以看看：</p>
                        <ul style="list-style-type:disc">
                           <li>
                              <p><a href="../admin/managing-tables.html#ADMIN11685" target="_blank"><span><cite>Oracle数据库管理员指南</cite></span></a> ，了解如何使用<code class="codeph">CREATE TABLE</code>的<code class="codeph">OVERFLOW</code>子句设置行溢出区域</p>
                           </li>
                           <li>
                              <p>用于<code class="codeph">CREATE TABLE ... <a href="../sqlrf/CREATE-TABLE.html#SQLRF54499" target="_blank"><span><cite>Oracle数据库SQL语言参考</cite></span></a> <code class="codeph">CREATE TABLE ...OVERFLOW</code>语法和语义</p>
                           </li>
                        </ul>
                     </div>
                  </div>
               </div><a id="CNCPT912"></a><div class="props_rev_3"><a id="GUID-1A9D370B-12F0-4161-875E-3121C8DEF2AD" name="GUID-1A9D370B-12F0-4161-875E-3121C8DEF2AD"></a><h4 id="CNCPT-GUID-1A9D370B-12F0-4161-875E-3121C8DEF2AD" class="sect4">索引组织表的二级索引</h4>
                  <div>
                     <p><span class="bold">辅助索引</span>是索引组织表的索引。
                     </p>
                     <p>从某种意义上说，二级索引是索引的索引。它是一个独立的模式对象，与索引组织表分开存储。</p>
                     <p>Oracle数据库使用称为逻辑rowid的行标识符作为索引组织表。<a href="glossary.html#GUID-92AE2643-9DA4-4364-942F-81F006759302"><span class="xrefglossterm">逻辑rowid</span></a>是表主键的base64编码表示。逻辑rowid长度取决于主键长度。
                     </p>
                     <p>由于插入，索引叶块中的行可以在块内或块之间移动。索引组织表中的行不会像堆组织的行那样进行迁移。由于索引组织表中的行不具有永久物理地址，因此数据库使用基于主键的逻辑rowid。</p>
                     <p>例如，假设<code class="codeph">departments</code>表是索引组织的。<code class="codeph">location_id</code>列存储每个部门的ID。该表按如下方式存储行，最后一个值作为位置ID：</p><pre class="pre codeblock"><code>10，行政管理，200,1700 20，市场营销，201,1800 30，采购，114,1700 40，人力资源，203,2400</code></pre><p><code class="codeph">location_id</code>列上的辅助索引可能具有如下索引条目，其中逗号后面的值是逻辑rowid：</p><pre class="pre codeblock"><code>1700，* BAFAJqoCwR / + 1700，* BAFAJqoCwQv + 1800，* BAFAJqoCwRX + 2400，* BAFAJqoCwSn +</code></pre><p>辅助索引使用既不是主键也不是主键前缀的列，可以快速有效地访问索引组织表。例如，查询ID大于1700的部门名称可以使用辅助索引来加速数据访问。</p>
                     <div class="infoboxnotealso" id="GUID-1A9D370B-12F0-4161-875E-3121C8DEF2AD__GUID-DF695A0D-E1BD-49B2-89B5-E99B2391D4A1">
                        <p class="notep1">也可以看看：</p>
                        <ul style="list-style-type:disc">
                           <li>
                              <p><span class="q">“ <a href="tables-and-table-clusters.html#GUID-0258C4C2-2BF2-445F-B1E1-F282A57A6859" title="存储在数据库中的每一行都有一个地址。Oracle数据库使用ROWID数据类型来存储数据库中每一行的地址（rowid）。">Rowid数据类型</a> ”</span>了解有关使用rowid和<code class="codeph">ROWID</code>伪列的更多信息</p>
                           </li>
                           <li>
                              <p> <span class="q">“ <a href="logical-storage-structures.html#GUID-49D4E586-57BF-4310-9EE9-2DD54108E651" title="Oracle数据库使用链接和迁移来管理太大而无法放入单个块的行。">链式和迁移行</a> ”</span></p>了解行迁移的原因，以及迁移增加I / O数量的原因</li>
                           <li>
                              <p><a href="../admin/managing-tables.html#ADMIN11696" target="_blank"><span><cite>Oracle数据库管理员指南</cite></span></a> ，了解如何在索引组织表上创建二级索引</p>
                           </li>
                           <li>
                              <p><a href="../vldbg/partition-admin.html#VLDBG003" target="_blank"><span><cite>Oracle Database VLDB和分区指南</cite></span></a> ，了解如何在索引组织的表分区上创建二级索引</p>
                           </li>
                        </ul>
                     </div>
                  </div><a id="CNCPT88856"></a><div class="props_rev_3"><a id="GUID-59126A72-B986-4EF7-9BF2-963F454853A1" name="GUID-59126A72-B986-4EF7-9BF2-963F454853A1"></a><h5 id="CNCPT-GUID-59126A72-B986-4EF7-9BF2-963F454853A1" class="sect5">逻辑Rowid和物理猜测</h5>
                     <div>
                        <p>辅助索引使用逻辑rowid来查找表行。</p>
                        <p>逻辑rowid包括<strong class="term">物理猜测</strong> ，它是索引条目首次生成时的物理rowid。Oracle数据库可以使用物理猜测直接探测索引组织表的叶块，绕过主键搜索。当行的物理位置发生更改时，即使逻辑rowid包含过时的物理猜测，逻辑rowid仍然有效。
                        </p>
                        <p>对于堆组织表，辅助索引的访问涉及对辅助索引的扫描以及用于获取包含该行的数据块的附加I / O.对于索引组织表，根据物理猜测的用途和准确性，二级索引的访问会有所不同：</p>
                        <ul style="list-style-type:disc">
                           <li>
                              <p>如果没有物理猜测，访问涉及两个索引扫描：扫描二级索引，然后扫描主键索引。</p>
                           </li>
                           <li>
                              <p>通过物理猜测，访问取决于其准确性：</p>
                              <ul style="list-style-type:disc">
                                 <li>
                                    <p>通过准确的物理猜测，访问涉及辅助索引扫描和附加I / O以获取包含该行的数据块。</p>
                                 </li>
                                 <li>
                                    <p>由于物理猜测不准确，访问涉及二级索引扫描和I / O以获取错误的数据块（如猜测所示），然后按主键值对索引组织表进行索引唯一扫描。</p>
                                 </li>
                              </ul>
                           </li>
                        </ul>
                     </div>
                  </div><a id="CNCPT89183"></a><a id="CNCPT88857"></a><div class="props_rev_3"><a id="GUID-A7B3A7AE-9A90-4033-8C56-852DF141AC7F" name="GUID-A7B3A7AE-9A90-4033-8C56-852DF141AC7F"></a><h5 id="CNCPT-GUID-A7B3A7AE-9A90-4033-8C56-852DF141AC7F" class="sect5">索引组织表上的位图索引</h5>
                     <div>
                        <p>索引组织表上的辅助索引可以是<span class="bold">位图索引</span> 。位图索引存储每个索引键的位图。
                        </p>
                        <p>当索引组织表上存在位图索引时，所有位图索引都使用堆组织映射表。映射表存储索引组织表的逻辑rowid。每个映射表行为相应的索引组织表行存储一个逻辑rowid。</p>
                        <p>数据库使用搜索关键字访问位图索引。如果数据库找到密钥，则位图条目将转换为物理rowid。对于堆组织表，数据库使用物理rowid来访问基表。使用索引组织表，数据库使用物理rowid访问映射表，映射表又生成数据库用于访问索引组织表的逻辑rowid。下图说明了<code class="codeph">departments_iot</code>表的查询的索引访问。
                        </p>
                        <div class="figure" id="GUID-A7B3A7AE-9A90-4033-8C56-852DF141AC7F__CIHHIFGD">
                           <p class="titleinfigure">图3-4索引组织表的位图索引</p><img src="img/cncpt330.gif" alt="下面是图3-4的描述" title="下面是图3-4的描述" longdesc="img_text/cncpt330.html"><br><a href="img_text/cncpt330.html">“图3-4索引组织表位图索引”的说明</a></div>
                        <!-- class="figure" -->
                        <div class="infoboxnote" id="GUID-A7B3A7AE-9A90-4033-8C56-852DF141AC7F__GUID-7EAC029C-AA29-4805-BDD5-170622A71572">
                           <p class="notep1">注意：</p>
                           <p>索引组织表中的行的移动不会使构建在该索引组织表上的位图索引不可用。</p>
                        </div>
                        <div class="infoboxnotealso" id="GUID-A7B3A7AE-9A90-4033-8C56-852DF141AC7F__GUID-38D6F037-9DE4-421B-9BF9-CB288D15FB6C">
                           <p class="notep1">也可以看看：</p>
                           <p><span class="q">“ <a href="tables-and-table-clusters.html#GUID-83BDB6CC-8CE1-44FE-9BCB-B018AC316FFC" title="rowid实际上是一行的10字节物理地址。">Roweds of Row Pieces</a> ”</span>来了解物理和逻辑rowid之间的差异</p>
                        </div>
                     </div>
                  </div>
               </div>
            </div>
         </div>
      </article>
   </body>
</html>