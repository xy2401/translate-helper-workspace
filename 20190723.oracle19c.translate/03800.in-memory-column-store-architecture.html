<html lang="en-us" dir="ltr" xml:lang="en-us">
   <head>
      <meta http-equiv="Content-Type" content="text/html; charset=utf-8"></meta>
      <meta name="viewport" content="width=device-width, initial-scale=1"></meta>
      <meta http-equiv="X-UA-Compatible" content="IE=edge"></meta>
      <meta name="abstract" content="The In-Memory Column Store (IM column store) stores tables and partitions in memory using a columnar format optimized for rapid scans. Oracle Database uses a sophisticated architecture to manage data in columnar and row formats simultaneously."></meta>
      <meta name="description" content="The In-Memory Column Store (IM column store) stores tables and partitions in memory using a columnar format optimized for rapid scans. Oracle Database uses a sophisticated architecture to manage data in columnar and row formats simultaneously."></meta>
      <title>内存列存储架构</title>
      <meta property="og:site_name" content="Oracle Help Center"></meta>
      <meta property="og:title" content="Database In-Memory Guide"></meta>
      <meta property="og:description" content="The In-Memory Column Store (IM column store) stores tables and partitions in memory using a columnar format optimized for rapid scans. Oracle Database uses a sophisticated architecture to manage data in columnar and row formats simultaneously."></meta>
      <link rel="stylesheet" href="/sp_common/book-template/ohc-book-template/css/book.css"></link>
      <link rel="shortcut icon" href="/sp_common/book-template/ohc-common/img/favicon.ico"></link>
      <meta name="application-name" content="Database In-Memory Guide"></meta>
      <meta name="generator" content="DITA Open Toolkit version 1.8.5 (Mode = doc)"></meta>
      <meta name="plugin" content="SP_docbuilder HTML plugin release 18.2.2"></meta>
      <link rel="alternate" href="database-memory-guide.pdf" title="PDF File" type="application/pdf"></link>
      <meta name="robots" content="all"></meta>
      <link rel="schema.dcterms" href="http://purl.org/dc/terms/"></link>
      <meta name="dcterms.created" content="2019-04-22T09:02:38-07:00"></meta>
      <meta name="dcterms.title" content="Database In-Memory Guide"></meta>
      <meta name="dcterms.dateCopyrighted" content="2016, 2019"></meta>
      <meta name="dcterms.category" content="database"></meta>
      <meta name="dcterms.identifier" content="E96137-02"></meta>
      
      <meta name="dcterms.product" content="en/database/oracle/oracle-database/19"></meta>
      
      <link rel="prev" href="intro-to-in-memory-column-store.html" title="Previous" type="text/html"></link>
      <link rel="next" href="configuring-the-im-column-store.html" title="Next" type="text/html"></link>
      <script>
        document.write('<style type="text/css">');
        document.write('body > .noscript, body > .noscript ~ * { visibility: hidden; }');
        document.write('</style>');
     </script>
      <script src="/sp_common/book-template/requirejs/require.js" data-main="/sp_common/book-template/ohc-book-template/js/book-config"></script>
      <script>
            if (window.require === undefined) {
                document.write('<script data-main="sp_common/book-template/ohc-book-template/js/book-config" src="sp_common/book-template/requirejs/require.js"><\/script>');
                document.write('<link href="sp_common/book-template/ohc-book-template/css/book.css" rel="stylesheet"/>');
            }
        </script>
      <script type="application/json" id="ssot-metadata">{"primary":{"category":{"short_name":"database","element_name":"Database","display_in_url":true},"suite":{"short_name":"oracle","element_name":"Oracle","display_in_url":true},"product_group":{"short_name":"not-applicable","element_name":"Not applicable","display_in_url":false},"product":{"short_name":"oracle-database","element_name":"Oracle Database","display_in_url":true},"release":{"short_name":"19","element_name":"Release 19","display_in_url":true}}}</script>
      
    <meta name="dcterms.isVersionOf" content="INMEM"></meta>
    <meta name="dcterms.release" content="Release 19"></meta>
  </head>
   <body dir="ltr">
      <div class="noscript alert alert-danger text-center" role="alert">
         <a href="intro-to-in-memory-column-store.html" class="pull-left"><span class="glyphicon glyphicon-chevron-left" aria-hidden="true"></span>上一页</a> <a href="configuring-the-im-column-store.html" class="pull-right">下一页<span class="glyphicon glyphicon-chevron-right" aria-hidden="true"></span></a> <span class="fa fa-exclamation-triangle" aria-hidden="true"></span>必须启用JavaScript才能正确显示此内容</div>
      <article>
         <header>
            <ol class="breadcrumb" vocab="http://schema.org/" typeof="BreadcrumbList">
               <li property="itemListElement" typeof="ListItem"><a href="index.html" property="item" typeof="WebPage"><span property="name">数据库内存指南</span></a></li>
               <li property="itemListElement" typeof="ListItem"><a href="concepts-for-the-im-column-store.html" property="item" typeof="WebPage"><span property="name">Oracle数据库内存概念</span></a></li>
               <li class="active" property="itemListElement" typeof="ListItem">内存列存储架构</li>
            </ol>
            <a id="GUID-EEA265EE-8FBA-4457-8C3F-315B9EEA2224" name="GUID-EEA265EE-8FBA-4457-8C3F-315B9EEA2224"></a>
            
            <h2 id="INMEM-GUID-EEA265EE-8FBA-4457-8C3F-315B9EEA2224" class="sect2"><span class="enumeration_chapter">2</span>内存中列存储架构</h2>
         </header>
         <div class="ind">
            <div>
               <p><span class="bold">内存中列存储</span> （IM列存储）使用针对快速扫描优化的<span class="bold">柱形格式</span>将表和分区存储在内存中。Oracle数据库使用复杂的体系结构同时管理柱形和行格式的数据。
               </p>
               <p>本章包含以下主题：</p>
            </div>
            <div>
               <ul class="ullinks">
                  <li class="ulchildlink"><a href="in-memory-column-store-architecture.html#GUID-FF2499C5-C582-496A-B547-CFE49C84185E">双格式：列和行</a><br>启用IM列存储时，SGA在不同位置管理数据：内存区域和数据库缓冲区高速缓存。
                  </li>
                  <li class="ulchildlink"><a href="in-memory-column-store-architecture.html#GUID-D61E56A9-B152-49D1-9956-BE9E882E3DE1">内存存储单元</a><br>IM列存储以优化的存储单元管理数据和元数据，而不是传统的Oracle数据块。
                  </li>
                  <li class="ulchildlink"><a href="in-memory-column-store-architecture.html#GUID-BF90E4D7-DA7B-4B2B-A0BB-AE88E0C39757">表达式统计存储（ESS）</a><br><strong class="term">表达式统计信息存储（ESS）</strong>是由优化程序维护的存储库，用于存储有关表达式评估的统计信息。ESS驻留在SGA中并保留在磁盘上。
                  </li>
                  <li class="ulchildlink"><a href="in-memory-column-store-architecture.html#GUID-15B0EEBC-31F6-4192-957A-56D79B7E63E2">内存中流程架构</a><br>为了响应查询和DML，服务器进程扫描列数据并更新SMU元数据。后台进程将行数据从磁盘填充到IM列存储中。
                  </li>
                  <li class="ulchildlink"><a href="in-memory-column-store-architecture.html#GUID-8DCA5CC5-69F6-4F26-AE94-49810F742310">CPU架构：SIMD矢量处理</a><br>对于在IM列存储中填充的数据，数据库使用SIMD（单指令，多数据）向量处理。
                  </li>
               </ul>
               <div class="familylinks">
                  <div class="parentlink">
                     <p><strong>父主题：</strong> <a href="concepts-for-the-im-column-store.html#GUID-5A72B48A-8427-41AE-9220-E46042BC90C4" title="本部分介绍Oracle数据库内存（Database In-Memory）功能集，并说明内存中列存储（IM列存储）的基本体系结构。">Oracle数据库内存中概念</a></p>
                  </div>
               </div>
            </div>
            
            <div class="props_rev_3"><a id="GUID-FF2499C5-C582-496A-B547-CFE49C84185E" name="GUID-FF2499C5-C582-496A-B547-CFE49C84185E"></a><h3 id="INMEM-GUID-FF2499C5-C582-496A-B547-CFE49C84185E" class="sect3"><span class="enumeration_section">2.1</span>双格式：列和行</h3>
               <div>
                  <p>启用IM列存储时，SGA在不同位置管理数据：内存区域和数据库缓冲区高速缓存。</p>
                  <p>IM列存储以列式格式对数据进行编码：每列是单独的结构。这些列是连续存储的，可以优化它们以进行分析查询。数据库缓冲区高速缓存可以修改也在IM列存储中填充的对象。但是，缓冲区缓存以传统的行格式存储数据。数据块连续存储行，为事务优化它们。</p>
                  <p>下图说明了基于行的存储和列式存储之间的区别。</p>
                  <div class="figure" id="GUID-FF2499C5-C582-496A-B547-CFE49C84185E__GUID-D12E234B-F0E5-49BD-B891-ED7A9F4643B2">
                     <p class="titleinfigure">图2-1基于列和行的存储</p><img src="img/inmem_3v_012.png" alt="下面描述图2-1" title="下面描述图2-1" longdesc="img_text/inmem_3v_012.html"><br><a href="img_text/inmem_3v_012.html">“图2-1柱状和行存储”的描述</a></div>
                  <!-- class="figure" -->
                  <p>本节创建以下主题：</p>
               </div>
               <div>
                  <ul class="ullinks">
                     <li class="ulchildlink"><a href="in-memory-column-store-architecture.html#GUID-2D072622-139C-4617-88ED-F07D530B8E1E">内存区域中的列数据</a><br><strong class="term">内存区域</strong>是一个可选的SGA组件，包含IM列存储。
                     </li>
                     <li class="ulchildlink"><a href="in-memory-column-store-architecture.html#GUID-93893C03-EEBD-46E5-8C08-7E120EB643A6">数据库缓冲区高速缓存中的行数据</a><br>无论是启用还是禁用IM列存储，数据库缓冲区高速缓存都以相同的方式存储和处理数据块。缓冲区I / O和缓冲池的功能相同。
                     </li>
                  </ul>
                  <div class="familylinks">
                     <div class="parentlink">
                        <p><strong>父主题：</strong> <a href="in-memory-column-store-architecture.html#GUID-EEA265EE-8FBA-4457-8C3F-315B9EEA2224" title="内存中列存储（IM列存储）使用针对快速扫描优化的柱形格式将表和分区存储在内存中。Oracle数据库使用复杂的体系结构同时管理柱形和行格式的数据。">内存中列存储架构</a></p>
                     </div>
                  </div>
               </div>
               
               <div class="sect3"><a id="GUID-2D072622-139C-4617-88ED-F07D530B8E1E" name="GUID-2D072622-139C-4617-88ED-F07D530B8E1E"></a><h4 id="INMEM-GUID-2D072622-139C-4617-88ED-F07D530B8E1E" class="sect4"><span class="enumeration_section">2.1.1</span>内存区域中的列数据</h4>
                  <div>
                     <p><strong class="term">内存区域</strong>是一个可选的SGA组件，包含IM列存储。
                     </p>
                     <p>本节包含以下主题：</p>
                  </div>
                  <div>
                     <ul class="ullinks">
                        <li class="ulchildlink"><a href="in-memory-column-store-architecture.html#GUID-C5D36B41-A8C7-4A09-A9B1-55748922EC09">内存区域的大小</a><br>内存区域由<code class="codeph">INMEMORY_SIZE</code>初始化参数控制。默认情况下，内存区域的大小为0，这意味着禁用了IM列存储。
                        </li>
                        <li class="ulchildlink"><a href="in-memory-column-store-architecture.html#GUID-74B9B6CD-CF94-4883-ABF0-8EFCE4E69BC8">内存区域中的内存池</a><br>内存区域分为子列，用于列数据和元数据。
                        </li>
                     </ul>
                     <div class="familylinks">
                        <div class="parentlink">
                           <p><strong>父主题：</strong> <a href="in-memory-column-store-architecture.html#GUID-FF2499C5-C582-496A-B547-CFE49C84185E" title="启用IM列存储时，SGA在不同位置管理数据：内存区域和数据库缓冲区高速缓存。">双格式：列和行</a></p>
                        </div>
                     </div>
                  </div>
                  
                  <div class="sect4"><a id="GUID-C5D36B41-A8C7-4A09-A9B1-55748922EC09" name="GUID-C5D36B41-A8C7-4A09-A9B1-55748922EC09"></a><h5 id="INMEM-GUID-C5D36B41-A8C7-4A09-A9B1-55748922EC09" class="sect5"><span class="enumeration_section">2.1.1.1</span>内存区域的大小</h5>
                     <div>
                        <p>内存区域由<code class="codeph">INMEMORY_SIZE</code>初始化参数控制。默认情况下，内存区域的大小为0，这意味着禁用了IM列存储。
                        </p>
                        <p>要启用IM列存储，请将内存区域设置为至少100 MB。尺寸以<code class="codeph">V$SGA</code> 。</p>
                        <div class="section">
                           <p class="subhead3" id="GUID-C5D36B41-A8C7-4A09-A9B1-55748922EC09__GUID-4C7789E3-082A-4CC4-8C94-D930183EC920">内存区域和SGA_TARGET</p>
                           <p>从<code class="codeph">SGA_TARGET</code>初始化参数设置中减去内存区域。例如，如果将<code class="codeph">SGA_TARGET</code>设置为10 GB，并且将<code class="codeph">INMEMORY_SIZE</code>设置为4 GB，则将<code class="codeph">SGA_TARGET</code>设置的40％分配给内存区域。下图说明了这种关系。
                           </p>
                           <div class="figure" id="GUID-C5D36B41-A8C7-4A09-A9B1-55748922EC09__GUID-E78F7C9F-2719-49C1-BC10-B8C2BF0C58ED">
                              <p class="titleinfigure">图2-2 INMEMORY_SIZE和SGA_TARGET</p><img id="GUID-C5D36B41-A8C7-4A09-A9B1-55748922EC09__IMAGE_OPT_ZLQ_JHB" src="img/inmem_3v_017.png" alt="下面是图2-2的描述" title="下面是图2-2的描述" longdesc="img_text/inmem_3v_017.html"><br><a href="img_text/inmem_3v_017.html">“图2-2 INMEMORY_SIZE和SGA_TARGET”的描述</a></div>
                           <!-- class="figure" -->
                           <p>与SGA的其他组件（包括缓冲区高速缓存和共享池）不同，内存区域大小不受自动内存管理控制。当缓冲区高速缓存或共享池需要更多内存时，数据库不会自动缩小内存区域，或者当空间不足时增加内存区域。</p>
                        </div>
                        <!-- class="section" -->
                        <div class="section">
                           <p class="subhead3" id="GUID-C5D36B41-A8C7-4A09-A9B1-55748922EC09__GUID-2CB4368C-52C6-4DD3-9836-E08424919F3C">动态调整内存区域的大小</p>
                           <p>从<span>Oracle Database 12c</span>第2版（12.2）开始，您可以使用<code class="codeph">ALTER SYSTEM</code>语句动态增加<code class="codeph">INMEMORY_SIZE</code> 。满足以下条件时，数据库会分配增加的内存：</p>
                           <ul id="GUID-C5D36B41-A8C7-4A09-A9B1-55748922EC09__UL_CKG_FMQ_JHB" style="list-style-type:disc">
                              <li>
                                 <p>SGA提供可用内存。</p>
                              </li>
                              <li>
                                 <p><code class="codeph">INMEMORY_SIZE</code>的新大小至少比当前设置大128 MB。
                                 </p>
                                 <div class="infoboxnote" id="GUID-C5D36B41-A8C7-4A09-A9B1-55748922EC09__GUID-A27A9DCE-E50E-454B-A0A7-3D9D016A6BEE">
                                    <p class="notep1">注意：</p>
                                    <p>您不能使用<code class="codeph">ALTER SYSTEM</code>来减少<code class="codeph">INMEMORY_SIZE</code> 。</p>
                                 </div>
                              </li>
                           </ul>
                           <p><code class="codeph">V$INMEMORY_AREA</code>和<code class="codeph">V$SGA</code>视图立即反映了这一变化。
                           </p>
                        </div>
                        <!-- class="section" -->
                        <div class="section">
                           <p class="subhead3" id="GUID-C5D36B41-A8C7-4A09-A9B1-55748922EC09__GUID-D2F123B0-1704-4709-877A-BB17A38711D1">多租户环境中的内存区域</p>
                           <p>在CDB中，IM列存储的大小由CDB根目录中的<code class="codeph">INMEMORY_SIZE</code>参数设置。默认情况下，IM列存储在PDB之间共享。因此，PDB可以通过消耗可用内存来“饿死”其他PDB。
                           </p>
                           <p>在PDB中，您可以使用<code class="codeph">ALTER SYSTEM SET INMEMORY_SIZE</code>限制内存消耗。例如，在CDB级别，您可以将<code class="codeph">INMEMORY_SIZE</code>设置为<code class="codeph">20G</code> ，然后按如下方式配置PDB：</p>
                           <ul id="GUID-C5D36B41-A8C7-4A09-A9B1-55748922EC09__UL_VYM_TNQ_JHB" style="list-style-type:disc">
                              <li>
                                 <p>在<code class="codeph">hrpdb</code> ，将<code class="codeph">INMEMORY_SIZE</code>设置为<code class="codeph">0</code></p>
                              </li>
                              <li>
                                 <p>在<code class="codeph">salespdb</code> ，将<code class="codeph">INMEMORY_SIZE</code>设置为<code class="codeph">10G</code></p>
                              </li>
                              <li>
                                 <p>在<code class="codeph">oepdb</code> ，将<code class="codeph">INMEMORY_SIZE</code>设置为<code class="codeph">11G</code></p>
                              </li>
                           </ul>
                           <p>在前面的示例中，PDB级别的<code class="codeph">INMEMORY_SIZE</code>设置<code class="codeph">INMEMORY_SIZE</code>达到<code class="codeph">21G</code> ，即使CDB级别的<code class="codeph">INMEMORY_SIZE</code>仅为<code class="codeph">20G</code> 。超额订阅可确保在关闭或拔出PDB时不会浪费IM列存储中的宝贵空间。
                           </p>
                        </div>
                        <!-- class="section" -->
                     </div>
                     <div>
                        <div class="infoboxnotealso" id="GUID-C5D36B41-A8C7-4A09-A9B1-55748922EC09__GUID-BC78427F-E4C3-45C8-B96F-2B4F4D40F157">
                           <p class="notep1">也可以看看：</p>
                           <ul id="GUID-C5D36B41-A8C7-4A09-A9B1-55748922EC09__UL_AKZ_GMQ_JHB" style="list-style-type:disc">
                              <li>
                                 <p><span class="q">“动态<a href="enabling-the-im-column-store.html#GUID-48581A2D-1650-410D-8E02-1D8250CCDBED" title="如果IM列存储需要更多内存，则可以动态增加其大小。">增加IM列存储的大小</a> ”</span></p>
                              </li>
                              <li>
                                 <p><a href="../admin/managing-memory.html#GUID-8F54391B-D42A-4FDA-9D12-E1F81FD113EA" target="_blank"><span><cite>Oracle数据库管理员指南</cite></span></a> ，了解有关自动内存管理的更多信息</p>
                              </li>
                              <li>
                                 <p><span><cite>Oracle Database Reference</cite></span>了解<a href="../refrn/INMEMORY_SIZE.html#GUID-B5BEB6BF-5308-485F-920D-CBB584DDDE8F" target="_blank"><code class="codeph">INMEMORY_SIZE</code></a> ， <a href="../refrn/V-INMEMORY_AREA.html#GUID-EDC517A6-FF55-4294-B348-032A3FC498EB" target="_blank"><code class="codeph">V$INMEMORY_AREA</code></a>和<a href="../refrn/V-SGA.html#GUID-4E216A4C-5C7E-43F6-8E2C-CDE442A1CEEC" target="_blank"><code class="codeph">V$SGA</code></a></p>
                              </li>
                           </ul>
                        </div>
                        <div class="familylinks">
                           <div class="parentlink">
                              <p><strong>父主题：</strong> <a href="in-memory-column-store-architecture.html#GUID-2D072622-139C-4617-88ED-F07D530B8E1E" title="内存区域是一个可选的SGA组件，包含IM列存储。">内存区域中的列数据</a></p>
                           </div>
                        </div>
                     </div>
                     
                  </div>
                  <div class="sect4"><a id="GUID-74B9B6CD-CF94-4883-ABF0-8EFCE4E69BC8" name="GUID-74B9B6CD-CF94-4883-ABF0-8EFCE4E69BC8"></a><h5 id="INMEM-GUID-74B9B6CD-CF94-4883-ABF0-8EFCE4E69BC8" class="sect5"><span class="enumeration_section">2.1.1.2</span>内存区域中的内存池</h5>
                     <div>
                        <p>内存区域分为子列，用于列数据和元数据。</p>
                        <p>内存区域细分为以下子池：</p>
                        <ul style="list-style-type:disc">
                           <li>
                              <p><a href="glossary.html#GUID-3259010C-D7F2-4AA8-95CB-ED1E3908EA0D"><span class="xrefglossterm">柱状数据池</span></a></p>
                              <p>该子池存储包含柱状数据的IMCU。<code class="codeph">V$INMEMORY_AREA.POOL</code>列将此子<code class="codeph">1MB POOL</code>标识为<code class="codeph">1MB POOL</code> ，如<a href="in-memory-column-store-architecture.html#GUID-74B9B6CD-CF94-4883-ABF0-8EFCE4E69BC8__GUID-4B237F25-BD87-4A64-8A99-C35091631C85">示例2-1</a>所示。
                              </p>
                           </li>
                           <li>
                              <p><a href="glossary.html#GUID-464A0659-4527-4730-A1A8-9D94B0A3B1DE"><span class="xrefglossterm">元数据池</span></a></p>
                              <p>此子池存储有关驻留在IM列存储中的对象的元数据。<code class="codeph">V$INMEMORY_AREA.POOL</code>列将此子<code class="codeph">64KB POOL</code>标识为<code class="codeph">64KB POOL</code> ，如<a href="in-memory-column-store-architecture.html#GUID-74B9B6CD-CF94-4883-ABF0-8EFCE4E69BC8__GUID-4B237F25-BD87-4A64-8A99-C35091631C85">例2-1</a>所示。
                              </p>
                           </li>
                        </ul>
                        <div class="figure" id="GUID-74B9B6CD-CF94-4883-ABF0-8EFCE4E69BC8__GUID-713DCAE4-82DD-4C0D-901F-52F9985B2257">
                           <p class="titleinfigure">图2-3内存区域中的子池</p><img src="img/cncpt_vm_380.png" alt="下面是图2-3的描述" title="下面是图2-3的描述" longdesc="img_text/cncpt_vm_380.html"><br><a href="img_text/cncpt_vm_380.html">“图2-3内存区域中的子池”的描述</a></div>
                        <!-- class="figure" -->
                        <p>数据库使用内部启发式确定两个子池的相对大小。数据库将内存区域中的大部分空间分配给列式数据池（1 MB池）。</p>
                        <div class="infoboxnote" id="GUID-74B9B6CD-CF94-4883-ABF0-8EFCE4E69BC8__GUID-E350FF1C-FFB6-4C12-80C0-15BDF108517C">
                           <p class="notep1">注意：</p>
                           <p>Oracle数据库自动确定子池大小。您无法更改空间分配。</p>
                        </div>
                        <div class="example" id="GUID-74B9B6CD-CF94-4883-ABF0-8EFCE4E69BC8__GUID-4B237F25-BD87-4A64-8A99-C35091631C85">
                           <p class="titleinexample">示例2-1 V $ INMEMORY_AREA视图</p>
                           <p>此示例查询<code class="codeph">V$INMEMORY_AREA</code>视图以确定每个子池中的可用内存量（包括样本输出）：</p><pre class="pre codeblock"><code>COL POOL FORMAT a9 COL POPULATE_STATUS格式a15 SSELECT POOL，TRUNC（ALLOC_BYTES /（1024 * 1024 * 1024），2）“ALLOC_GB”，TRUNC（USED_BYTES /（1024 * 1024 * 1024），2）“USED_GB”，POPULATE_STATUS FROM V $ INMEMORY_AREA; POOL ALLOC_GB USED_GB POPULATE_STATUS --------- ---------- ---------- --------------- 1MB POOL 7.99 0完成64KB POOL 1.98 0完成</code></pre><p>内存区域的当前大小在<code class="codeph">V$SGA</code>可见：</p><pre class="pre codeblock"><code>SELECT NAME，VALUE /（1024 * 1024 * 1024）“SIZE_IN_GB”FROM V $ SGA WHERE NAME LIKE'％Mem％'; NAME SIZE_IN_GB -------------------- ---------- In-Memory Area 10</code></pre><p>在此示例中，分配给子池的内存为9.97 GB，而内存区域的大小为10 GB。数据库使用一小部分内存用于内部管理结构。</p>
                        </div>
                        <!-- class="example" -->
                     </div>
                     <div>
                        <div class="infoboxnotealso" id="GUID-74B9B6CD-CF94-4883-ABF0-8EFCE4E69BC8__GUID-BC78427F-E4C3-45C8-B96F-2B4F4D40F157">
                           <p class="notep1">也可以看看：</p><a href="../refrn/V-INMEMORY_AREA.html#GUID-EDC517A6-FF55-4294-B348-032A3FC498EB" target="_blank"><span><cite>Oracle Database Reference</cite></span></a>了解<code class="codeph">V$INMEMORY_AREA</code></div>
                        <div class="familylinks">
                           <div class="parentlink">
                              <p><strong>父主题：</strong> <a href="in-memory-column-store-architecture.html#GUID-2D072622-139C-4617-88ED-F07D530B8E1E" title="内存区域是一个可选的SGA组件，包含IM列存储。">内存区域中的列数据</a></p>
                           </div>
                        </div>
                     </div>
                     
                  </div>
               </div>
               <div class="props_rev_3"><a id="GUID-93893C03-EEBD-46E5-8C08-7E120EB643A6" name="GUID-93893C03-EEBD-46E5-8C08-7E120EB643A6"></a><h4 id="INMEM-GUID-93893C03-EEBD-46E5-8C08-7E120EB643A6" class="sect4"><span class="enumeration_section">2.1.2</span>数据库缓冲区高速缓存中的行数据</h4>
                  <div>
                     <p>无论是启用还是禁用IM列存储，数据库缓冲区高速缓存都以相同的方式存储和处理数据块。缓冲区I / O和缓冲池的功能相同。</p>
                     <p>IM列存储使数据能够以传统的行格式（缓冲区缓存）和列式格式同时填充在SGA中。数据库透明地将OLTP查询（例如主键查找）发送到缓冲区高速缓存，并将分析和报告查询发送到IM列存储。在获取数据时，Oracle数据库还可以从同一查询中的两个内存区域读取数据。</p>
                     <div class="infoboxnote" id="GUID-93893C03-EEBD-46E5-8C08-7E120EB643A6__GUID-8B772890-5222-4FCC-848B-C376707C3906">
                        <p class="notep1">注意：</p>
                        <p>在执行计划中，操作<code class="codeph">TABLE ACCESS IN MEMORY FULL</code>指示在IM列存储中访问一些或所有数据。
                        </p>
                     </div>
                     <p>双格式架构不会使内存要求增加一倍。缓冲区缓存经过优化，运行时的大小远小于数据库的大小。</p>
                     <p>下图显示了一个示例IM列存储。数据库以传统的行格式将<code class="codeph">sh.sales</code>表存储在磁盘上。SGA以列式格式将数据存储在IM列存储中，并以行格式存储在数据库缓冲区高速缓存中。
                     </p>
                     <div class="figure" id="GUID-93893C03-EEBD-46E5-8C08-7E120EB643A6__BGBEFJBH">
                        <p class="titleinfigure">图2-4 IM列存储</p><img src="img/cncpt_vm_379.png" width="540" alt="下面是图2-4的描述" title="下面是图2-4的描述" longdesc="img_text/cncpt_vm_379.html"><br><a href="img_text/cncpt_vm_379.html">“图2-4 IM列存储”的描述</a></div>
                     <!-- class="figure" -->
                     <p>IM列存储支持永久堆组织表的每个磁盘数据格式。列式格式不会影响存储在数据文件或缓冲区缓存中的数据格式，也不会影响撤消数据和联机重做日志记录。</p>
                     <p>通过更新缓冲区缓存，联机重做日志和撤消表空间，数据库以相同的方式处理DML修改，无论是否启用了IM列存储。但是，数据库使用内部机制来跟踪更改并确保IM列存储与数据库的其余部分保持一致。例如，如果在IM列存储中填充了<code class="codeph">sales</code>表，并且如果应用程序更新了<code class="codeph">sales</code>的行，则数据库会自动保持IM列存储中的<code class="codeph">sales</code>表的副本在事务上保持一致。访问IM列存储的查询始终返回访问缓冲区高速缓存的查询的相同结果。
                     </p>
                  </div>
                  <div>
                     <div class="infoboxnotealso" id="GUID-93893C03-EEBD-46E5-8C08-7E120EB643A6__GUID-39A46614-F669-4EF9-B92D-82CC4B56AC94">
                        <p class="notep1">也可以看看：</p>
                        <p><a href="https://www.oracle.com/pls/topic/lookup?ctx=en/database/oracle/oracle-database/19/inmem&amp;id=GUID-4FF66585-E469-4631-9225-29D75594CD14" target="_blank"><span><cite>Oracle Database Concepts</cite></span></a>了解有关数据库缓冲区缓存的更多信息</p>
                     </div>
                     <div class="familylinks">
                        <div class="parentlink">
                           <p><strong>父主题：</strong> <a href="in-memory-column-store-architecture.html#GUID-FF2499C5-C582-496A-B547-CFE49C84185E" title="启用IM列存储时，SGA在不同位置管理数据：内存区域和数据库缓冲区高速缓存。">双格式：列和行</a></p>
                        </div>
                     </div>
                  </div>
                  
               </div>
            </div>
            <div class="sect2"><a id="GUID-D61E56A9-B152-49D1-9956-BE9E882E3DE1" name="GUID-D61E56A9-B152-49D1-9956-BE9E882E3DE1"></a><h3 id="INMEM-GUID-D61E56A9-B152-49D1-9956-BE9E882E3DE1" class="sect3"><span class="enumeration_section">2.2</span>内存存储单元</h3>
               <div>
                  <p>IM列存储以优化的存储单元管理数据和元数据，而不是传统的Oracle数据块。</p>
                  <p>Oracle数据库维护内存区域中的存储单元。下图概述了内存区域以及与之交互的数据库进程。其余章节描述了各种内存组件。</p>
                  <div class="figure" id="GUID-D61E56A9-B152-49D1-9956-BE9E882E3DE1__GUID-FDB37040-B670-4D1E-96D0-9357E9117F95">
                     <p class="titleinfigure">图2-5 IM列存储：内存和进程体系结构</p><img src="img/inmem_3v_013.png" alt="下面是图2-5的描述" title="下面是图2-5的描述" longdesc="img_text/inmem_3v_013.html"><br><a href="img_text/inmem_3v_013.html">“图2-5 IM列存储：存储器和进程架构”的描述</a></div>
                  <!-- class="figure" -->
                  <p>本节包含以下主题：</p>
               </div>
               <div>
                  <ul class="ullinks">
                     <li class="ulchildlink"><a href="in-memory-column-store-architecture.html#GUID-50A30EC3-1CD1-4BFC-9BD1-9AC55D0B4AAE">内存中压缩单元（IMCU）</a><br><strong class="term">内存中压缩单元（IMCU）</strong>是一个压缩的只读存储单元，包含一列或多列的数据。
                     </li>
                     <li class="ulchildlink"><a href="in-memory-column-store-architecture.html#GUID-850DDEFB-6B9F-461B-AAF0-DB6DAFAFCBA2">快照元数据单元（SMU）</a><br>快照元数据单元（SMU）包含关联的IMCU的元数据和事务信息。</li>
                     <li class="ulchildlink"><a href="in-memory-column-store-architecture.html#GUID-E1A74436-E719-4FC3-A141-41B160792E51">内存表达单元（IMEU）</a><br><span class="bold">内存中表达单元</span> （IMEU）是物化<span class="bold">内存表达式</span> （IM表达式）和用户定义虚拟列的存储容器。
                     </li>
                  </ul>
                  <div class="familylinks">
                     <div class="parentlink">
                        <p><strong>父主题：</strong> <a href="in-memory-column-store-architecture.html#GUID-EEA265EE-8FBA-4457-8C3F-315B9EEA2224" title="内存中列存储（IM列存储）使用针对快速扫描优化的柱形格式将表和分区存储在内存中。Oracle数据库使用复杂的体系结构同时管理柱形和行格式的数据。">内存中列存储架构</a></p>
                     </div>
                  </div>
               </div>
               
               <div class="props_rev_3"><a id="GUID-50A30EC3-1CD1-4BFC-9BD1-9AC55D0B4AAE" name="GUID-50A30EC3-1CD1-4BFC-9BD1-9AC55D0B4AAE"></a><h4 id="INMEM-GUID-50A30EC3-1CD1-4BFC-9BD1-9AC55D0B4AAE" class="sect4"><span class="enumeration_section">2.2.1</span>内存中压缩单元（IMCU）</h4>
                  <div>
                     <p><strong class="term">内存中压缩单元（IMCU）</strong>是一个压缩的只读存储单元，包含一列或多列的数据。
                     </p>
                     <p>IMCU类似于表空间范围。IMCU有两部分：一组列压缩单元（CU），以及包含元数据（如<a href="glossary.html#GUID-B9859425-36BD-40B7-9F9D-FA52CD215B69"><span class="xrefglossterm">IM存储索引</span></a> ）的标头。
                     </p>
                     <p>本节包含以下主题：</p>
                  </div>
                  <div>
                     <ul class="ullinks">
                        <li class="ulchildlink"><a href="in-memory-column-store-architecture.html#GUID-5DFDC353-CE50-4E26-9DFD-E6046A1582A8">IMCU和模式对象</a><br>IM列存储将一个对象（表，分区，物化视图）的数据存储在一组IMCU中。IMCU存储一个且仅一个对象的列数据。
                        </li>
                        <li class="ulchildlink"><a href="in-memory-column-store-architecture.html#GUID-DD7106DB-0BCE-4251-B808-8341507FDFC7">列压缩单元（CU）</a><br><span class="bold">列压缩单元（CU）</span>是IMCU中单个列的连续存储。每个IMCU都有一个或多个CU。
                        </li>
                        <li class="ulchildlink"><a href="in-memory-column-store-architecture.html#GUID-A38FF2B6-506E-412A-9FE5-1CE709556379">内存存储索引</a><br>每个IMCU标头都会自动为其CU创建和管理<span class="bold">内存存储索引</span> （IM存储索引）。IM存储索引存储IMCU中所有列的最小值和最大值。</li>
                     </ul>
                     <div class="familylinks">
                        <div class="parentlink">
                           <p><strong>父主题：</strong> <a href="in-memory-column-store-architecture.html#GUID-D61E56A9-B152-49D1-9956-BE9E882E3DE1" title="IM列存储以优化的存储单元管理数据和元数据，而不是传统的Oracle数据块。">内存存储单元</a></p>
                        </div>
                     </div>
                  </div>
                  
                  <div class="sect4"><a id="GUID-5DFDC353-CE50-4E26-9DFD-E6046A1582A8" name="GUID-5DFDC353-CE50-4E26-9DFD-E6046A1582A8"></a><h5 id="INMEM-GUID-5DFDC353-CE50-4E26-9DFD-E6046A1582A8" class="sect5"><span class="enumeration_section">2.2.1.1</span> IMCU和模式对象</h5>
                     <div>
                        <p>IM列存储将一个对象（表，分区，物化视图）的数据存储在一组IMCU中。IMCU存储一个且仅一个对象的列数据。</p>
                        <p>本节包含以下主题：</p>
                     </div>
                     <div>
                        <ul class="ullinks">
                           <li class="ulchildlink"><a href="in-memory-column-store-architecture.html#GUID-EF783480-CF7A-40B9-8824-11AD3EDFEF41">IMCU和INMEMORY列</a><br>对于指定为<code class="codeph">INMEMORY</code>的对象， <code class="codeph">INMEMORY</code>子句中列出的每个列都包含在每个IMCU中。</li>
                           <li class="ulchildlink"><a href="in-memory-column-store-architecture.html#GUID-E652C13F-FD52-49D2-B968-3B1A03F7F1ED">内存中压缩</a><br>IM列存储使用针对访问速度优化的特殊压缩格式，而不是存储减少。列式格式使查询能够直接针对压缩列执行。
                           </li>
                           <li class="ulchildlink"><a href="in-memory-column-store-architecture.html#GUID-C1CAECB5-87F3-49E4-9F90-488A6834764F">IMCU和行</a><br>每个IMCU包含表段中行的子集的所有列值（包括空值）。行的子集称为<span class="italic">粒度</span> 。
                           </li>
                        </ul>
                        <div class="familylinks">
                           <div class="parentlink">
                              <p><strong>父主题：</strong> <a href="in-memory-column-store-architecture.html#GUID-50A30EC3-1CD1-4BFC-9BD1-9AC55D0B4AAE" title="内存中压缩单元（IMCU）是一个压缩的只读存储单元，包含一列或多列的数据。">内存中压缩单元（IMCU）</a></p>
                           </div>
                        </div>
                     </div>
                     
                     <div class="sect5"><a id="GUID-EF783480-CF7A-40B9-8824-11AD3EDFEF41" name="GUID-EF783480-CF7A-40B9-8824-11AD3EDFEF41"></a><h6 id="INMEM-GUID-EF783480-CF7A-40B9-8824-11AD3EDFEF41" class="sect6"><span class="enumeration_section">2.2.1.1.1</span> IMCU和INMEMORY列</h6>
                        <div>
                           <p>对于指定为<code class="codeph">INMEMORY</code>的对象， <code class="codeph">INMEMORY</code>子句中列出的每个列都包含在每个IMCU中。</p>
                           <p>例如， <code class="codeph">sh.sales</code>表有7列。以下DDL语句将表指定为<code class="codeph">INMEMORY</code> ，这意味着每个<code class="codeph">sales</code> IMCU都包含这7列的列数据：</p><pre class="pre codeblock"><code>ALTER TABLE sh.sales INMEMORY MEMCOMPRESS for QUERY LOW;</code></pre><div class="section">
                              <p class="subhead3" id="GUID-EF783480-CF7A-40B9-8824-11AD3EDFEF41__GUID-6A346F9B-6E35-4064-8211-D0E68DFF685D">INMEMORY对象中没有INMEMORY列</p>
                              <p>您可以指定<code class="codeph">INMEMORY</code>表中的某些列但不是所有列都具有<code class="codeph">INMEMORY</code>属性。例如， <code class="codeph">sh.customers</code>表有23列。以下DDL语句指定<code class="codeph">sh.customers</code>中的15个列具有<code class="codeph">NO INMEMORY</code>属性，这意味着表中的其他8列具有<code class="codeph">INMEMORY</code>属性：</p><pre class="pre codeblock"><code>ALTER TABLE sh.customers INMEMORY MEMCOMPRESS for QUERY LOW NO INMEMORY（cust_gender，cust_year_of_birth，cust_marital_status，cust_postal_code，cust_city，cust_state_province，cust_main_phone_number，cust_income_level，cust_credit_limit，cust_email，cust_total，cust_total_id，cust_eff_from，cust_eff_to，cust_valid）;</code></pre><p>以下查询显示<code class="codeph">sh.customers</code>列的压缩级别，指示哪些<code class="codeph">NO INMEMORY</code> ：</p><pre class="pre codeblock"><code>SET LINESIZE 200 COL TABLE_NAME FORMAT a25 COL SEG_COL_ID FORMAT 999 COL COLUMN_NAME FORMAT a25 COL INMEMORY_COMPRESSION FORMAT a11 SELECT SEGMENT_COLUMN_ID AS“SEG_COL_ID”，COLUMN_NAME，INMEMORY_COMPRESSION FROM V $ IM_COLUMN_LEVEL WHERE TABLE_NAME ='CUSTOMERS'ORDER by SEG_COL_ID; SEG_COL_ID COLUMN_NAME INMEMORY_CO ---------- ------------------------- ----------- 1 CUST_ID DEFAULT 2 CUST_FIRST_NAME DEFAULT 3 CUST_LAST_NAME DEFAULT 4 CUST_GENDER NO INMEMORY 5 CUST_YEAR_OF_BIRTH NO INMEMORY 6 CUST_MARITAL_STATUS NO INMEMORY 7 CUST_STREET_ADDRESS DEFAULT 8 CUST_POSTAL_CODE NO INMEMORY 9 CUST_CITY NO INMEMORY 10 CUST_CITY_ID DEFAULT 11 cust_state_province两个NO INMEMORY 12 CUST_STATE_PROVINCE_ID DEFAULT 13 COUNTRY_ID DEFAULT 14 CUST_MAIN_PHONE_NUMBER NO INMEMORY 15 CUST_INCOME_LEVEL没有INMEMORY 16 CUST_CREDIT_LIMIT NO INMEMORY 17 CUST_EMAIL NO INMEMORY 18 CUST_TOTAL NO INMEMORY 19 CUST_TOTAL_ID NO INMEMORY 20 CUST_SRC_ID DEFAULT 21 CUST_EFF_FROM NO INMEMORY 22 CUST_EFF_TO NO INMEMORY 23 CUST_VALID NO INMEMORY</code></pre><p>下图显示了IM列存储中填充的<code class="codeph">sh</code>模式中的三个表： <code class="codeph">customers</code> ， <code class="codeph">products</code>和<code class="codeph">sales</code> 。在此示例中，每个表都具有指定<code class="codeph">INMEMORY</code>的不同列<code class="codeph">INMEMORY</code> 。每个表的<code class="codeph">INMEMORY</code>仅包含<code class="codeph">INMEMORY</code>列的数据。
                              </p>
                              <div class="figure" id="GUID-EF783480-CF7A-40B9-8824-11AD3EDFEF41__BGBJCAIB">
                                 <p class="titleinfigure">图2-6列和IMCU</p><img id="GUID-EF783480-CF7A-40B9-8824-11AD3EDFEF41__IMAGE_W4T_MS4_LHB" src="img/cncpt_vm_378.png" alt="下面是图2-6的描述" title="下面是图2-6的描述" longdesc="img_text/cncpt_vm_378.html"><br><a href="img_text/cncpt_vm_378.html">“图2-6列和IMCU”的说明</a></div>
                              <!-- class="figure" -->
                           </div>
                           <!-- class="section" -->
                           <div class="section">
                              <p class="subhead3" id="GUID-EF783480-CF7A-40B9-8824-11AD3EDFEF41__GUID-1B5444AC-CD3B-4782-A673-BD5564033FC8">引用NO INMEMORY列的查询</p>
                              <p>当查询引用<code class="codeph">NO INMEMORY</code>列时，表扫描将从行存储中检索数据，而不是从IM列存储中的IMCU检索数据。即使查询中引用的所有其他列都填充了<code class="codeph">INMEMORY</code>列，也会发生行存储访问。
                              </p>
                              <p>例如，假设<code class="codeph">customers</code>表填充到IM列存储中。<code class="codeph">cust_id</code>和<code class="codeph">cust_last_name</code>列指定为<code class="codeph">INMEMORY</code> ，但<code class="codeph">cust_postal_code</code>列指定为<code class="codeph">NO INMEMORY</code> 。您发出以下查询：</p><pre class="pre codeblock"><code>SELECT cust_id，cust_last_name，cust_postal_code FROM customers WHERE cust_id &lt;5001 ORDER BY cust_id;</code></pre><p>在这种情况下，即使<code class="codeph">cust_postal_code</code>是查询中引用的唯一<code class="codeph">NO INMEMORY</code>列，数据库也会访问行存储而不是IM列存储。以下查询在谓词中具有<code class="codeph">cust_postal_code</code>但不包含<code class="codeph">SELECT</code>列表，还必须访问行存储：</p><pre class="pre codeblock"><code>SELECT cust_id，cust_last_name FROM customers WHERE cust_postal_code = 77501 ORDER BY cust_id;</code></pre></div>
                           <!-- class="section" -->
                        </div>
                        <div>
                           <div class="infoboxnotealso" id="GUID-EF783480-CF7A-40B9-8824-11AD3EDFEF41__GUID-78C230E9-D084-4D55-81E8-BF318D242D71">
                              <p class="notep1">也可以看看：</p>
                              <ul id="GUID-EF783480-CF7A-40B9-8824-11AD3EDFEF41__UL_ACJ_2V4_LHB" style="list-style-type:disc">
                                 <li>
                                    <p><span class="q">“ <a href="populating-objects-in-memory.html#GUID-C0BC34D3-2BD8-41A5-B2F0-9AB109C1B617" title="对于内部表，内存中的虚拟列（IM虚拟列）和非虚拟列都符合IM填充的条件。对于外部表，只有非虚拟列才符合条件。">关于启用INMEMORY列</a> ”</span></p>
                                 </li>
                                 <li>
                                    <p><a href="https://blogs.oracle.com/in-memory/what-happens-if-a-column-is-not-populated" target="_blank">https://blogs.oracle.com/in-memory/what-happens-if-a-column-is-not-populated</a>用于访问未在IM列存储中填充的列的博客条目</p>
                                 </li>
                                 <li>
                                    <p><a href="../sqlrf/ALTER-TABLE.html#GUID-552E7373-BF93-477D-9DA3-B2C9386F2877" target="_blank"><span><cite>Oracle Database SQL语言参考</cite></span></a> ，了解<code class="codeph">ALTER TABLE</code>语句</p>
                                 </li>
                              </ul>
                           </div>
                           <div class="familylinks">
                              <div class="parentlink">
                                 <p><strong>父主题：</strong> <a href="in-memory-column-store-architecture.html#GUID-5DFDC353-CE50-4E26-9DFD-E6046A1582A8" title="IM列存储将一个对象（表，分区，物化视图）的数据存储在一组IMCU中。IMCU存储一个且仅一个对象的列数据。">IMCU和模式对象</a></p>
                              </div>
                           </div>
                        </div>
                        
                     </div>
                     <div class="props_rev_3"><a id="GUID-E652C13F-FD52-49D2-B968-3B1A03F7F1ED" name="GUID-E652C13F-FD52-49D2-B968-3B1A03F7F1ED"></a><h6 id="INMEM-GUID-E652C13F-FD52-49D2-B968-3B1A03F7F1ED" class="sect6"><span class="enumeration_section">2.2.1.1.2</span>内存中压缩</h6>
                        <div>
                           <p>IM列存储使用针对访问速度优化的特殊压缩格式，而不是存储减少。列式格式使查询能够直接针对压缩列执行。</p>
                           <p>压缩使扫描和过滤操作能够处理更少量的数据，从而优化查询性能。Oracle数据库仅在结果集需要时解压缩数据。</p>
                           <p>IM列存储中应用的压缩与混合列压缩密切相关。两种技术都处理列向量。主要区别在于IM列存储的列向量针对SIMD向量处理进行了优化，而混合列压缩的列向量针对磁盘存储进行了优化。</p>
                           <p>当您为IM列存储启用填充对象时，可以在<code class="codeph">INMEMORY</code>子句中指定压缩类型： <code class="codeph">FOR DML</code> ， <code class="codeph">FOR QUERY</code> （ <code class="codeph">LOW</code>或<code class="codeph">HIGH</code> ）， <code class="codeph">FOR CAPACITY</code> （ <code class="codeph">LOW</code>或<code class="codeph">HIGH</code> ）或<code class="codeph">NONE</code> 。</p>
                        </div>
                        <div>
                           <div class="infoboxnotealso" id="GUID-E652C13F-FD52-49D2-B968-3B1A03F7F1ED__GUID-78432B01-CDB7-4B10-BE07-E5090D01273C">
                              <p class="notep1">也可以看看：</p>
                              <ul style="list-style-type:disc">
                                 <li>
                                    <p><span class="q">“ <a href="populating-objects-in-memory.html#GUID-B50145A4-3A97-48DD-8AA3-7E239E926261" title="使用DDL语句中的INMEMORY子句指定哪些对象有资格进入IM列存储。您可以启用表空间，表（内部和外部），分区和物化视图。">对记忆中人口的控制</a> ”</span></p>
                                 </li>
                                 <li>
                                    <p><a href="../cncpt/tables-and-table-clusters.html#GUID-901A054B-B47F-4ADF-A57B-2074EBB85341" target="_blank"><span><cite>Oracle Database Concepts</cite></span></a>了解有关混合列压缩的更多信息</p>
                                 </li>
                              </ul>
                           </div>
                           <div class="familylinks">
                              <div class="parentlink">
                                 <p><strong>父主题：</strong> <a href="in-memory-column-store-architecture.html#GUID-5DFDC353-CE50-4E26-9DFD-E6046A1582A8" title="IM列存储将一个对象（表，分区，物化视图）的数据存储在一组IMCU中。IMCU存储一个且仅一个对象的列数据。">IMCU和模式对象</a></p>
                              </div>
                           </div>
                        </div>
                        
                     </div>
                     <div class="sect5"><a id="GUID-C1CAECB5-87F3-49E4-9F90-488A6834764F" name="GUID-C1CAECB5-87F3-49E4-9F90-488A6834764F"></a><h6 id="INMEM-GUID-C1CAECB5-87F3-49E4-9F90-488A6834764F" class="sect6"><span class="enumeration_section">2.2.1.1.3</span> IMCU和行</h6>
                        <div>
                           <p>每个IMCU包含表段中行的子集的所有列值（包括空值）。行的子集称为<span class="italic">粒度</span> 。
                           </p>
                           <p>给定段的所有IMCU包含大致相同的行数。Oracle数据库根据数据类型，数据格式和压缩类型自动确定粒度的大小。较高的压缩级别会导致IMCU中的行数增加。</p>
                           <p>IMCU和一组数据库块之间存在一对多映射。如<a href="in-memory-column-store-architecture.html#GUID-C1CAECB5-87F3-49E4-9F90-488A6834764F__GUID-C6CBB52C-9E9C-42BB-9C91-1BD37B73254D">例2-2所示</a> ，每个IMCU存储不同块集的列值。
                           </p>
                           <p>IMCU中的列未排序。Oracle数据库按照从磁盘读取的顺序填充它们。</p>
                           <p>IMCU中的行数决定了IMCU消耗的空间量。如果目标行数导致IMCU增长超过1 MB池中可用的连续1 MB扩展区的数量，则IMCU会创建其他扩展区（块）以保留其余列CU。IMCU始终以1 MB为增量分配空间。</p>
                           <div class="example" id="GUID-C1CAECB5-87F3-49E4-9F90-488A6834764F__GUID-C6CBB52C-9E9C-42BB-9C91-1BD37B73254D">
                              <p class="titleinexample">例2-2 IMCU和行子集</p>
                              <p>在此简化示例中，只有<code class="codeph">customers</code>表的以下4列具有<code class="codeph">INMEMORY</code>属性： <code class="codeph">cust_id</code> ， <code class="codeph">cust_first_name</code> ， <code class="codeph">cust_last_name</code>和<code class="codeph">cust_gender</code> 。表中仅存在5行，存储在2个数据块中。从概念上讲，第一个数据块按如下方式存储其行：</p><pre class="pre codeblock"><code>82，麦德兰，李，F; 37004，ABEL Embrey，M; 1714，哈代，温和，男</code></pre><p>第二个数据块按如下方式存储行：</p><pre class="pre codeblock"><code>100439，乌玛，坎贝尔，F; 3047，露西亚，尼，F</code></pre><p>假设IMCU 1存储第一数据块的数据。在这种情况下，此数据块存储中3行的<code class="codeph">cust_id</code>列值将“垂直”存储在CU中，如下所示：</p><pre class="pre codeblock"><code>82 37004 1714</code></pre><p>IMCU 2存储来自第二数据块的数据。这两行的<code class="codeph">cust_id</code>列值存储在CU中，如下所示：</p><pre class="pre codeblock"><code>100439 3047</code></pre><p>由于<code class="codeph">cust_id</code>值是数据块中每行的第一个值，因此<code class="codeph">cust_id</code>列位于IMCU中的第一个位置。列始终占据相同的位置，因此Oracle数据库可以通过读取段的IMCU来重建行。
                              </p>
                           </div>
                           <!-- class="example" -->
                        </div>
                        <div>
                           <div class="relinfo">
                              <p><strong>相关话题</strong></p>
                              <ul>
                                 <li><a href="populating-objects-in-memory.html#GUID-B50145A4-3A97-48DD-8AA3-7E239E926261" title="使用DDL语句中的INMEMORY子句指定哪些对象有资格进入IM列存储。您可以启用表空间，表（内部和外部），分区和物化视图。">对记忆内人口的控制</a></li>
                              </ul>
                           </div>
                           <div class="familylinks">
                              <div class="parentlink">
                                 <p><strong>父主题：</strong> <a href="in-memory-column-store-architecture.html#GUID-5DFDC353-CE50-4E26-9DFD-E6046A1582A8" title="IM列存储将一个对象（表，分区，物化视图）的数据存储在一组IMCU中。IMCU存储一个且仅一个对象的列数据。">IMCU和模式对象</a></p>
                              </div>
                           </div>
                        </div>
                        
                     </div>
                  </div>
                  <div class="sect4"><a id="GUID-DD7106DB-0BCE-4251-B808-8341507FDFC7" name="GUID-DD7106DB-0BCE-4251-B808-8341507FDFC7"></a><h5 id="INMEM-GUID-DD7106DB-0BCE-4251-B808-8341507FDFC7" class="sect5"><span class="enumeration_section">2.2.1.2</span>列压缩单元（CU）</h5>
                     <div>
                        <p><span class="bold">列压缩单元（CU）</span>是IMCU中单个列的连续存储。每个IMCU都有一个或多个CU。
                        </p>
                        <p>本节包含以下主题：</p>
                     </div>
                     <div>
                        <ul class="ullinks">
                           <li class="ulchildlink"><a href="in-memory-column-store-architecture.html#GUID-DDF4E628-0A07-42F3-8B8E-2B166F6A824E">CU的结构</a><br>CU被分为主体和头部。
                           </li>
                           <li class="ulchildlink"><a href="in-memory-column-store-architecture.html#GUID-729DBF0D-7DE4-4B1A-886E-8BE5F6017DAB">本地词典</a><br>在CU中，本地字典具有不同值的列表及其对应的字典代码。
                           </li>
                        </ul>
                        <div class="familylinks">
                           <div class="parentlink">
                              <p><strong>父主题：</strong> <a href="in-memory-column-store-architecture.html#GUID-50A30EC3-1CD1-4BFC-9BD1-9AC55D0B4AAE" title="内存中压缩单元（IMCU）是一个压缩的只读存储单元，包含一列或多列的数据。">内存中压缩单元（IMCU）</a></p>
                           </div>
                        </div>
                     </div>
                     
                     <div class="sect5"><a id="GUID-DDF4E628-0A07-42F3-8B8E-2B166F6A824E" name="GUID-DDF4E628-0A07-42F3-8B8E-2B166F6A824E"></a><h6 id="INMEM-GUID-DDF4E628-0A07-42F3-8B8E-2B166F6A824E" class="sect6"><span class="enumeration_section">2.2.1.2.1</span> CU的结构</h6>
                        <div>
                           <p>CU被分为主体和头部。</p>
                           <p>每个CU的主体存储IMCU中包含的行范围的列值。标头包含关于存储在CU主体中的值的元数据，例如，CU内的最小值和最大值。它还可以包含<a href="glossary.html#GUID-10ECFDBB-1835-4634-B1E6-5E156614B6DE"><span class="xrefglossterm">本地字典</span></a> ，该<a href="glossary.html#GUID-10ECFDBB-1835-4634-B1E6-5E156614B6DE"><span class="xrefglossterm">字典</span></a>是该列中不同值的排序列表及其对应的字典代码。
                           </p>
                           <p>下图显示了具有4个CU的IMCU，用于<code class="codeph">sales</code>表： <code class="codeph">prod_id</code> ， <code class="codeph">cust_id</code> ， <code class="codeph">time_id</code>和<code class="codeph">channel_id</code> 。每个CU存储IMCU中包括的行范围的列值。</p>
                           <div class="figure" id="GUID-DDF4E628-0A07-42F3-8B8E-2B166F6A824E__GUID-ACC3BC93-A2D6-44CF-BCF7-F5996EED03A8">
                              <p class="titleinfigure">图2-7 IMCU中的CU</p><img src="img/inmem_3v_007.png" alt="下面是图2-7的描述" title="下面是图2-7的描述" longdesc="img_text/inmem_3v_007.html"><br><a href="img_text/inmem_3v_007.html">“图2-7 IMCU中的CU”的描述</a></div>
                           <!-- class="figure" -->
                           <p>CU以rowid顺序存储值。因此，数据库可以通过将行“拼接”在一起来回答查询。例如，应用程序发出以下查询：</p><pre class="pre codeblock"><code>SELECT cust_id，time_id，channel_id FROM sales WHERE prod_id = 5;</code></pre><p>数据库首先扫描<code class="codeph">prod_id</code>列以查找值为<code class="codeph">5</code>条目。假设数据库在<code class="codeph">prod_id</code>列中的位置2中找到<code class="codeph">5</code> 。数据库现在必须找到该行的相应<code class="codeph">cust_id</code> ， <code class="codeph">time_id</code>和<code class="codeph">channel_id</code> 。由于CU以rowid顺序存储数据，因此数据库可以在这些列中的位置2中找到相应的<code class="codeph">cust_id</code> ， <code class="codeph">time_id</code>和<code class="codeph">channel_id</code>值。因此，要回答查询，数据库必须从<code class="codeph">cust_id</code> ， <code class="codeph">time_id</code>和<code class="codeph">channel_id</code>列中的位置2提取值，然后将该行重新拼接在一起以将其返回给最终用户。
                           </p>
                        </div>
                        <div>
                           <div class="familylinks">
                              <div class="parentlink">
                                 <p><strong>父主题：</strong> <a href="in-memory-column-store-architecture.html#GUID-DD7106DB-0BCE-4251-B808-8341507FDFC7" title="列压缩单元（CU）是IMCU中单个列的连续存储。每个IMCU都有一个或多个CU。">列压缩单元（CU）</a></p>
                              </div>
                           </div>
                        </div>
                        
                     </div>
                     <div class="sect5"><a id="GUID-729DBF0D-7DE4-4B1A-886E-8BE5F6017DAB" name="GUID-729DBF0D-7DE4-4B1A-886E-8BE5F6017DAB"></a><h6 id="INMEM-GUID-729DBF0D-7DE4-4B1A-886E-8BE5F6017DAB" class="sect6"><span class="enumeration_section">2.2.1.2.2</span>本地词典</h6>
                        <div>
                           <p>在CU中，本地字典具有不同值的列表及其对应的字典代码。</p>
                           <p>本地字典存储列中包含的符号。下图说明了CU如何在<code class="codeph">vehicles</code>表中存储<code class="codeph">name</code>列。
                           </p>
                           <div class="figure" id="GUID-729DBF0D-7DE4-4B1A-886E-8BE5F6017DAB__GUID-D5FF2EE9-ED35-4F2C-858F-356CDBD2429D">
                              <p class="titleinfigure">图2-8本地字典</p><img src="img/inmem_3v_006.png" alt="下面是图2-8的描述" title="下面是图2-8的描述" longdesc="img_text/inmem_3v_006.html"><br><a href="img_text/inmem_3v_006.html">“图2-8本地词典”的描述</a></div>
                           <!-- class="figure" -->
                           <p>在上图中，CU仅包含7行。此CU中的每个不同值（例如<code class="codeph">Cadillac</code>或<code class="codeph">Audi</code> ）都会分配不同的字典代码，例如<code class="codeph">Cadillac</code> <code class="codeph">2</code>和<code class="codeph">Audi</code> <code class="codeph">0</code> 。CU存储字典代码而不是原始值。
                           </p>
                           <div class="infoboxnote" id="GUID-729DBF0D-7DE4-4B1A-886E-8BE5F6017DAB__GUID-BA81A5E1-BFA7-4247-891F-E3DD21F980C3">
                              <p class="notep1">注意：</p>
                              <p>当数据库使用<a href="glossary.html#GUID-D04AB5B8-A58B-4494-A54F-09CEBC113460"><span class="xrefglossterm">公共字典</span></a>作为<a href="glossary.html#GUID-0DCA9B69-43D8-4940-9CC0-8753061F27CA"><span class="xrefglossterm">连接组时</span></a> ，本地字典包含<span class="italic">对</span>公共字典的<span class="italic">引用</span>而不是<span class="italic">符号</span> 。例如，而不是存储值<code class="codeph">Audi</code> ， <code class="codeph">BWM</code>和<code class="codeph">Cadillac</code>为<code class="codeph">vehicles.name</code>柱，本地字典中存储的字典编码，例如<code class="codeph">101</code> ， <code class="codeph">220</code> ，和<code class="codeph">66</code> 。
                              </p>
                           </div>
                           <p>CU标头包含列的最小值和最大值。在此示例中，最小值为<code class="codeph">Audi</code> ，最大值为<code class="codeph">Cadillac</code> 。本地词典存储了不同值的列表： <code class="codeph">Audi</code> ， <code class="codeph">BMW</code>和<code class="codeph">Cadillac</code> 。它们相应的字典码（ <code class="codeph">0</code> ， <code class="codeph">1</code> ，和<code class="codeph">2</code> ）是隐含的。每个IMCU中CU的本地字典独立于其他IMCU中的本地字典。
                           </p>
                           <p>如果查询过滤奥迪汽车，则数据库仅扫描此IMCU的<code class="codeph">0</code>代码。
                           </p>
                        </div>
                        <div>
                           <div class="relinfo">
                              <p><strong>相关话题</strong></p>
                              <ul>
                                 <li><a href="optimizing-queries-with-join-groups.html#GUID-88A573DD-99D3-48D7-8310-B46F70184793" title="公共字典是表级特定于实例的字典代码集。">加入组如何使用公共字典</a></li>
                              </ul>
                           </div>
                           <div class="infoboxnotealso" id="GUID-729DBF0D-7DE4-4B1A-886E-8BE5F6017DAB__GUID-8A82B6DF-69A5-47DF-AA1A-3825D2F78035">
                              <p class="notep1">也可以看看：</p>
                              <p><span class="q">“ <a href="optimizing-queries-with-join-groups.html#GUID-88A573DD-99D3-48D7-8310-B46F70184793" title="公共字典是表级特定于实例的字典代码集。">加入组如何使用通用词典</a> ”</span></p>
                           </div>
                           <div class="familylinks">
                              <div class="parentlink">
                                 <p><strong>父主题：</strong> <a href="in-memory-column-store-architecture.html#GUID-DD7106DB-0BCE-4251-B808-8341507FDFC7" title="列压缩单元（CU）是IMCU中单个列的连续存储。每个IMCU都有一个或多个CU。">列压缩单元（CU）</a></p>
                              </div>
                           </div>
                        </div>
                        
                     </div>
                  </div>
                  <div class="sect4"><a id="GUID-A38FF2B6-506E-412A-9FE5-1CE709556379" name="GUID-A38FF2B6-506E-412A-9FE5-1CE709556379"></a><h5 id="INMEM-GUID-A38FF2B6-506E-412A-9FE5-1CE709556379" class="sect5"><span class="enumeration_section">2.2.1.3</span>内存存储索引</h5>
                     <div>
                        <p>每个IMCU标头都会自动为其CU创建和管理<span class="bold">内存存储索引</span> （IM存储索引）。IM存储索引存储IMCU中所有列的最小值和最大值。</p>
                        <p>例如， <code class="codeph">sales</code>填充在IM列存储中。该表的每个IMCU都包含所有列。<code class="codeph">sales.prod_id</code>列存储在每个IMCU内的单独CU中。 IMCU标头具有每个<code class="codeph">prod_id</code> CU（以及每个其他CU）的最小值和最大值。
                        </p>
                        <p>为了消除不必要的扫描，数据库可以基于SQL过滤器谓词执行<a href="glossary.html#GUID-824EDD0E-2FF3-411E-A2B2-C7B542EADFDC"><span class="xrefglossterm">IMCU修剪</span></a> 。数据库仅扫描满足查询谓词的IMCU，如下图中的<code class="codeph">WHERE prod_id &gt; 14 AND prod_id &lt; 29</code>示例所示。
                        </p>
                        <div class="figure" id="GUID-A38FF2B6-506E-412A-9FE5-1CE709556379__BGBGBJJB">
                           <p class="titleinfigure">图2-9柱状数据的存储索引</p><img src="img/inmem_3v_016.png" alt="下面是图2-9的描述" title="下面是图2-9的描述" longdesc="img_text/inmem_3v_016.html"><br><a href="img_text/inmem_3v_016.html">“图2-9柱状数据存储索引”的说明</a></div>
                        <!-- class="figure" -->
                     </div>
                     <div>
                        <div class="familylinks">
                           <div class="parentlink">
                              <p><strong>父主题：</strong> <a href="in-memory-column-store-architecture.html#GUID-50A30EC3-1CD1-4BFC-9BD1-9AC55D0B4AAE" title="内存中压缩单元（IMCU）是一个压缩的只读存储单元，包含一列或多列的数据。">内存中压缩单元（IMCU）</a></p>
                           </div>
                        </div>
                     </div>
                     
                  </div>
               </div>
               <div class="sect3"><a id="GUID-850DDEFB-6B9F-461B-AAF0-DB6DAFAFCBA2" name="GUID-850DDEFB-6B9F-461B-AAF0-DB6DAFAFCBA2"></a><h4 id="INMEM-GUID-850DDEFB-6B9F-461B-AAF0-DB6DAFAFCBA2" class="sect4"><span class="enumeration_section">2.2.2</span>快照元数据单元（SMU）</h4>
                  <div>
                     <p>快照元数据单元（SMU）包含关联的IMCU的元数据和事务信息。</p>
                     <p>本节包含以下主题：</p>
                  </div>
                  <div>
                     <ul class="ullinks">
                        <li class="ulchildlink"><a href="in-memory-column-store-architecture.html#GUID-344E6053-2B12-4E8D-B37C-7B74D8F02DCF">IMCU和SMU</a><br>内存区域的柱状池存储实际数据：IMCU和IMEU。内存区域中的元数据池存储SMU。
                        </li>
                        <li class="ulchildlink"><a href="in-memory-column-store-architecture.html#GUID-2CA38EA0-26A0-44E7-97AD-A4156964BDC1">交易日记</a><br>每个SMU都包含一个<span class="bold">事务日志</span> 。数据库使用事务日志来保持IMCU的事务一致性。
                        </li>
                     </ul>
                     <div class="familylinks">
                        <div class="parentlink">
                           <p><strong>父主题：</strong> <a href="in-memory-column-store-architecture.html#GUID-D61E56A9-B152-49D1-9956-BE9E882E3DE1" title="IM列存储以优化的存储单元管理数据和元数据，而不是传统的Oracle数据块。">内存存储单元</a></p>
                        </div>
                     </div>
                  </div>
                  
                  <div class="sect4"><a id="GUID-344E6053-2B12-4E8D-B37C-7B74D8F02DCF" name="GUID-344E6053-2B12-4E8D-B37C-7B74D8F02DCF"></a><h5 id="INMEM-GUID-344E6053-2B12-4E8D-B37C-7B74D8F02DCF" class="sect5"><span class="enumeration_section">2.2.2.1</span> IMCU和SMU</h5>
                     <div>
                        <p>内存区域的柱状池存储实际数据：IMCU和IMEU。内存区域中的元数据池存储SMU。</p>
                        <div class="figure" id="GUID-344E6053-2B12-4E8D-B37C-7B74D8F02DCF__GUID-AC063DFD-ADC3-42BF-A971-A86F7C4812DF">
                           <p class="titleinfigure">图2-10 IMCU和SMU</p>
                           <p>此图显示数据池中的IMCU和元数据池中的SMU。</p><img src="img/inmem_3v_014.png" alt="下面是图2-10的描述" title="下面是图2-10的描述" longdesc="img_text/inmem_3v_014.html"><br><a href="img_text/inmem_3v_014.html">“图2-10 IMCU和SMU”的描述</a></div>
                        <!-- class="figure" -->
                        <p>每个IMCU都映射到一个单独的SMU。因此，如果列式数据池包含100个IMCU，则元数据池包含100个SMU。SMU为其关联的IMCU存储多种类型的元数据，包括：</p>
                        <ul style="list-style-type:disc">
                           <li>
                              <p>对象编号</p>
                           </li>
                           <li>
                              <p>列号</p>
                           </li>
                           <li>
                              <p>映射行的信息</p>
                           </li>
                        </ul>
                     </div>
                     <div>
                        <div class="familylinks">
                           <div class="parentlink">
                              <p><strong>父主题：</strong> <a href="in-memory-column-store-architecture.html#GUID-850DDEFB-6B9F-461B-AAF0-DB6DAFAFCBA2" title="快照元数据单元（SMU）包含关联的IMCU的元数据和事务信息。">快照元数据单元（SMU）</a></p>
                           </div>
                        </div>
                     </div>
                     
                  </div>
                  <div class="sect4"><a id="GUID-2CA38EA0-26A0-44E7-97AD-A4156964BDC1" name="GUID-2CA38EA0-26A0-44E7-97AD-A4156964BDC1"></a><h5 id="INMEM-GUID-2CA38EA0-26A0-44E7-97AD-A4156964BDC1" class="sect5"><span class="enumeration_section">2.2.2.2</span>交易日志</h5>
                     <div>
                        <p>每个SMU都包含一个<span class="bold">事务日志</span> 。数据库使用事务日志来保持IMCU的事务一致性。
                        </p>
                        <p>数据库使用缓冲区缓存来处理DML，就像未启用IM列存储一样。例如， <code class="codeph">UPDATE</code>语句可能会修改IMCU中的行。在这种情况下，数据库将修改后的行的rowid添加到事务日志中，并将其标记为DML语句的SCN。如果查询需要访问该行的新版本，则数据库将从数据库缓冲区高速缓存中获取该行。
                        </p>
                        <div class="figure" id="GUID-2CA38EA0-26A0-44E7-97AD-A4156964BDC1__GUID-FA73343D-ED4F-4C7A-80B2-57DC5D14651C">
                           <p class="titleinfigure">图2-11交易日记帐</p><img src="img/inmem_3v_020.png" alt="下面是图2-11的描述" title="下面是图2-11的描述" longdesc="img_text/inmem_3v_020.html"><br><a href="img_text/inmem_3v_020.html">“图2-11交易日记”的描述</a></div>
                        <!-- class="figure" -->
                        <p>数据库通过合并列，事务日志和缓冲区高速缓存的内容来实现读取一致性。在<a href="glossary.html#GUID-9168517C-C8A2-4433-946A-037631B840E2"><span class="xrefglossterm">重新填充</span></a>期间刷新IMCU时，查询可以直接从IMCU访问最新的行。</p>
                     </div>
                     <div>
                        <div class="infoboxnotealso" id="GUID-2CA38EA0-26A0-44E7-97AD-A4156964BDC1__GUID-78FCBDF5-0498-4504-A82C-1ED36BAA1A05">
                           <p class="notep1">也可以看看：</p>
                           <p><span class="q">“ <a href="repopulation-and-dml.html#GUID-85AB84D5-1308-430A-BED2-281F3E9515B2" title="IM列存储定期刷新已修改的对象。您可以使用初始化参数和DBMS_INMEMORY包来控制此行为。">优化IM列存储的重新填充</a> ”</span> ，深入讨论IM列存储如何维护事务一致性</p>
                        </div>
                        <div class="familylinks">
                           <div class="parentlink">
                              <p><strong>父主题：</strong> <a href="in-memory-column-store-architecture.html#GUID-850DDEFB-6B9F-461B-AAF0-DB6DAFAFCBA2" title="快照元数据单元（SMU）包含关联的IMCU的元数据和事务信息。">快照元数据单元（SMU）</a></p>
                           </div>
                        </div>
                     </div>
                     
                  </div>
               </div>
               <div class="sect3"><a id="GUID-E1A74436-E719-4FC3-A141-41B160792E51" name="GUID-E1A74436-E719-4FC3-A141-41B160792E51"></a><h4 id="INMEM-GUID-E1A74436-E719-4FC3-A141-41B160792E51" class="sect4"><span class="enumeration_section">2.2.3</span>内存表达单元（IMEU）</h4>
                  <div>
                     <p><span class="bold">内存中表达单元</span> （IMEU）是物化<span class="bold">内存表达式</span> （IM表达式）和用户定义虚拟列的存储容器。
                     </p>
                     <p>数据库处理物化表达式就像IMCU中的其他列一样。从概念上讲，IMEU是其父IMCU的逻辑扩展。就像IMCU可以包含多个列一样，IMEU可以包含多个虚拟列。</p>
                     <p>每个IMEU映射到一个IMCU，映射到同一行集。IMEU包含其相关IMCU中包含的数据的表达式结果。填充IMCU时，也会填充关联的IMEU。</p>
                     <p>典型的IM表达式涉及一个或多个列，可能具有常量，并且与表中的行具有一对一映射。例如， <code class="codeph">employees</code>表的IMCU包含<code class="codeph">weekly_salary</code>列的行1-1000。对于存储在此IMCU中的行，IMEU计算自动检测到的IM表达式<code class="codeph">weekly_salary*52</code> ，以及用户定义的虚拟列<code class="codeph">quarterly_salary</code>定义为<code class="codeph">weekly_salary*12</code> 。IMCU中的第3行向下映射到IMEU中的第3行。</p>
                     <p>IMEU是特定段的IMCU的逻辑扩展。默认情况下，IMEU从基本段继承<code class="codeph">INMEMORY</code>子句属性，包括Oracle Real Application Clusters（Oracle RAC）属性，如<code class="codeph">DISTRIBUTE</code>和<code class="codeph">DUPLICATE</code> 。您可以有选择地启用或禁用虚拟列以存储在IMEU中。您还可以为不同的列指定压缩级别。
                     </p>
                  </div>
                  <div>
                     <div class="relinfo">
                        <p><strong>相关话题</strong></p>
                        <ul>
                           <li><a href="populating-objects-in-memory.html#GUID-C0BC34D3-2BD8-41A5-B2F0-9AB109C1B617" title="对于内部表，内存中的虚拟列（IM虚拟列）和非虚拟列都符合IM填充的条件。对于外部表，只有非虚拟列才符合条件。">关于启用INMEMORY列</a></li>
                           <li><a href="views-related-to-im-column-store.html#GUID-2EBF8D9B-FA9E-4D67-8934-5908E6018D4E" title="本主题描述与内存中列存储（IM列存储）相关的数据字典和动态性能视图。">内存中的视图</a></li>
                        </ul>
                     </div>
                     <div class="familylinks">
                        <div class="parentlink">
                           <p><strong>父主题：</strong> <a href="in-memory-column-store-architecture.html#GUID-D61E56A9-B152-49D1-9956-BE9E882E3DE1" title="IM列存储以优化的存储单元管理数据和元数据，而不是传统的Oracle数据块。">内存存储单元</a></p>
                        </div>
                     </div>
                  </div>
                  
               </div>
            </div>
            <div class="sect2"><a id="GUID-BF90E4D7-DA7B-4B2B-A0BB-AE88E0C39757" name="GUID-BF90E4D7-DA7B-4B2B-A0BB-AE88E0C39757"></a><h3 id="INMEM-GUID-BF90E4D7-DA7B-4B2B-A0BB-AE88E0C39757" class="sect3"><span class="enumeration_section">2.3</span>表达统计存储（ESS）</h3>
               <div>
                  <p><strong class="term">表达式统计信息存储（ESS）</strong>是由优化程序维护的存储库，用于存储有关表达式评估的统计信息。ESS驻留在SGA中并保留在磁盘上。
                  </p>
                  <p>启用IM列存储后，数据库会利用ESS实现其内存中表达式（IM表达式）功能。但是，ESS独立于IM列存储。ESS是数据库的永久组件，无法禁用。</p>
                  <p>数据库使用ESS来确定表达式是否“热”（经常访问），因此是IM表达式的候选者。在查询的硬分析期间，ESS在<code class="codeph">SELECT</code>列表， <code class="codeph">WHERE</code>子句， <code class="codeph">GROUP BY</code>子句等中查找活动表达式。
                  </p>
                  <p>对于每个段，ESS维护表达式统计信息，如下所示：</p>
                  <ul style="list-style-type:disc">
                     <li>
                        <p>执行频率</p>
                     </li>
                     <li>
                        <p>评估成本</p>
                     </li>
                     <li>
                        <p>时间戳评估</p>
                     </li>
                  </ul>
                  <p>优化程序根据成本和评估次数为每个表达式分配加权分数。值是近似值而不是精确值。更活跃的表达有更高的分数。ESS维护最常访问的表达式的内部列表。</p>
                  <p>使用<code class="codeph">DBMS_INMEMORY_ADMIN</code>包控制IM表达式的行为。例如， <code class="codeph">IME_CAPTURE_EXPRESSIONS</code>过程会提示数据库识别并逐渐填充数据库中最热门的表达式。<code class="codeph">IME_POPULATE_EXPRESSIONS</code>过程强制数据库立即填充表达式。
                  </p>
                  <p>ESS信息存储在数据字典中，并在<code class="codeph">DBA_EXPRESSION_STATISTICS</code>视图中公开。此视图显示优化程序在ESS中收集的元数据。 IM表达式在<code class="codeph">DBA_IM_EXPRESSIONS</code>视图中以系统生成的虚拟列（以字符串<code class="codeph">SYS_IME</code>为前缀） <code class="codeph">DBA_IM_EXPRESSIONS</code> 。
                  </p>
               </div>
               <div>
                  <div class="infoboxnotealso" id="GUID-BF90E4D7-DA7B-4B2B-A0BB-AE88E0C39757__GUID-32526C6F-6AA1-4856-A80B-A2B1ED9DB9CA">
                     <p class="notep1">也可以看看：</p>
                     <ul style="list-style-type:disc">
                        <li>
                           <p><span class="q">“ <a href="optimizing-in-memory-expressions.html#GUID-1B849DAF-277E-4B09-8275-367592115B06" title="默认情况下，DBMS_INMEMORY_ADMIN.IME_CAPTURE_EXPRESSIONS过程标识并填充“热”表达式，称为内存中表达式（IM表达式）。">关于IM表达</a> ”</span></p>
                        </li>
                        <li>
                           <p><a href="../tgsql/query-optimizer-concepts.html#GUID-44EB8261-A7B1-4402-94ED-5152EE1C5D08" target="_blank"><span><cite>Oracle数据库SQL调优指南</cite></span></a> ，了解有关ESS的更多信息</p>
                        </li>
                        <li>
                           <p><a href="../refrn/DBA_EXPRESSION_STATISTICS.html#GUID-9617514D-FFED-4B5D-B8C7-FB08FCB9CC91" target="_blank"><span><cite>Oracle Database Reference</cite></span></a>了解有关<code class="codeph">DBA_EXPRESSION_STATISTICS</code>视图的更多信息</p>
                        </li>
                        <li>
                           <p><a href="https://www.oracle.com/pls/topic/lookup?ctx=en/database/oracle/oracle-database/19/inmem&amp;id=GUID-398720DF-7D8D-4418-B395-5F7C5FC85BC5" target="_blank"><span><cite>Oracle Database PL / SQL包和类型参考，</cite></span></a>以了解有关<code class="codeph">DBMS_INMEMORY_ADMIN</code>包的更多信息</p>
                        </li>
                     </ul>
                  </div>
                  <div class="familylinks">
                     <div class="parentlink">
                        <p><strong>父主题：</strong> <a href="in-memory-column-store-architecture.html#GUID-EEA265EE-8FBA-4457-8C3F-315B9EEA2224" title="内存中列存储（IM列存储）使用针对快速扫描优化的柱形格式将表和分区存储在内存中。Oracle数据库使用复杂的体系结构同时管理柱形和行格式的数据。">内存中列存储架构</a></p>
                     </div>
                  </div>
               </div>
               
            </div>
            <div class="sect2"><a id="GUID-15B0EEBC-31F6-4192-957A-56D79B7E63E2" name="GUID-15B0EEBC-31F6-4192-957A-56D79B7E63E2"></a><h3 id="INMEM-GUID-15B0EEBC-31F6-4192-957A-56D79B7E63E2" class="sect3"><span class="enumeration_section">2.4</span>内存中过程体系结构</h3>
               <div>
                  <p>为了响应查询和DML，服务器进程扫描列数据并更新SMU元数据。后台进程将行数据从磁盘填充到IM列存储中。</p>
                  <p>本节包含以下主题：</p>
               </div>
               <div>
                  <ul class="ullinks">
                     <li class="ulchildlink"><a href="in-memory-column-store-architecture.html#GUID-6ABDC0F5-0932-43D1-97F5-E827A102F23E">内存协调器进程（IMCO）</a><br>内存中协调器进程（IMCO）管理IM列存储的许多任务。其主要任务是启动背景人口和重新填充柱状数据。
                     </li>
                     <li class="ulchildlink"><a href="in-memory-column-store-architecture.html#GUID-C91A11F9-CFB7-4919-A8D7-8572ED1CAEF3">空间管理工作者流程（Wnnn）</a><br>空间管理工作者流程（W <span class="italic">nnn</span> ）代表IMCO填充或重新填充数据。</li>
                     <li class="ulchildlink"><a href="in-memory-column-store-architecture.html#GUID-68EA52F3-D62F-474D-99FB-729A6AE43D70">内存中动态扫描</a><br><strong class="term">内存中动态扫描（IM动态扫描）</strong>使用轻量级线程来并行化内存中的表扫描。
                     </li>
                  </ul>
                  <div class="familylinks">
                     <div class="parentlink">
                        <p><strong>父主题：</strong> <a href="in-memory-column-store-architecture.html#GUID-EEA265EE-8FBA-4457-8C3F-315B9EEA2224" title="内存中列存储（IM列存储）使用针对快速扫描优化的柱形格式将表和分区存储在内存中。Oracle数据库使用复杂的体系结构同时管理柱形和行格式的数据。">内存中列存储架构</a></p>
                     </div>
                  </div>
               </div>
               
               <div class="sect3"><a id="GUID-6ABDC0F5-0932-43D1-97F5-E827A102F23E" name="GUID-6ABDC0F5-0932-43D1-97F5-E827A102F23E"></a><h4 id="INMEM-GUID-6ABDC0F5-0932-43D1-97F5-E827A102F23E" class="sect4"><span class="enumeration_section">2.4.1</span>内存协调器进程（IMCO）</h4>
                  <div>
                     <p>内存中协调器进程（IMCO）管理IM列存储的许多任务。其主要任务是启动背景人口和重新填充柱状数据。</p>
                     <p>Population是一种流式传输机制，将行数据转换为柱状格式，然后压缩它。IMCO自动启动除<code class="codeph">NONE</code>以外的任何优先级的<code class="codeph">INMEMORY</code>对象的<code class="codeph">INMEMORY</code> 。当访问优先级为<code class="codeph">NONE</code>对象时，IMCO使用空间管理工作进程（W <span class="italic">nnn</span> ）进程填充它们。
                     </p>
                     <p>IMCO后台进程还会在IM列存储对象满足过期阈值时启动<a href="glossary.html#GUID-6F8CD872-FBA2-4519-8204-66D3E45FA1C9"><span class="xrefglossterm">基于阈值的重新填充</span></a> 。IMCO可能会对IM列存储中任何具有陈旧条目但不满足<a href="glossary.html#GUID-78ED27B2-6946-4302-BDD2-3F8A4F0DA42C"><span class="xrefglossterm">过期阈值的</span></a> IMCU进行<a href="glossary.html#GUID-34CC73ED-D322-4628-AC54-3F51065E8BCE"><span class="xrefglossterm">涓流重新填充</span></a> 。
                     </p>
                     <p>涓流重新填充在后台自动发生。步骤如下：</p>
                     <ol>
                        <li>
                           <p>IMCO醒来。</p>
                        </li>
                        <li>
                           <p>IMCO确定是否需要执行人口任务，包括IMCU中是否存在任何陈旧条目。</p>
                        </li>
                        <li>
                           <p>如果IMCO发现过时的条目，那么它会触发空间管理工作进程在IMCU中重新填充这些条目。</p>
                        </li>
                        <li>
                           <p>IMCO睡了两分钟，然后返回到步骤1。</p>
                        </li>
                     </ol>
                  </div>
                  <div>
                     <div class="infoboxnotealso" id="GUID-6ABDC0F5-0932-43D1-97F5-E827A102F23E__GUID-8B8A0400-F744-4034-99A4-6EAACB984D69">
                        <p class="notep1">也可以看看：</p>
                        <ul style="list-style-type:disc">
                           <li>
                              <p><span class="q">“ <a href="repopulation-and-dml.html#GUID-85AB84D5-1308-430A-BED2-281F3E9515B2" title="IM列存储定期刷新已修改的对象。您可以使用初始化参数和DBMS_INMEMORY包来控制此行为。">优化IM列存储的重新填充</a> ”</span></p>
                           </li>
                           <li>
                              <p><a href="https://www.oracle.com/pls/topic/lookup?ctx=en/database/oracle/oracle-database/19/inmem&amp;id=GUID-86184690-5531-405F-AA05-BB935F57B76D" target="_blank"><span><cite>Oracle Database Reference</cite></span></a>了解有关后台进程的更多信息</p>
                           </li>
                        </ul>
                     </div>
                     <div class="familylinks">
                        <div class="parentlink">
                           <p><strong>父主题：</strong> <a href="in-memory-column-store-architecture.html#GUID-15B0EEBC-31F6-4192-957A-56D79B7E63E2" title="为了响应查询和DML，服务器进程扫描列数据并更新SMU元数据。后台进程将行数据从磁盘填充到IM列存储中。">内存中过程体系结构</a></p>
                        </div>
                     </div>
                  </div>
                  
               </div>
               <div class="sect3"><a id="GUID-C91A11F9-CFB7-4919-A8D7-8572ED1CAEF3" name="GUID-C91A11F9-CFB7-4919-A8D7-8572ED1CAEF3"></a><h4 id="INMEM-GUID-C91A11F9-CFB7-4919-A8D7-8572ED1CAEF3" class="sect4"><span class="enumeration_section">2.4.2</span>空间管理工作者流程（Wnnn）</h4>
                  <div>
                     <p>空间管理工作者流程（W <span class="italic">nnn</span> ）代表IMCO填充或重新填充数据。</p>
                     <p>在人口中，W <span class="italic">nnn</span>进程负责创建IMCU，SMU和IMEU。创建IMEU时，工作进程执行以下任务：</p>
                     <ul style="list-style-type:disc">
                        <li>
                           <p>确定人口的虚拟列</p>
                        </li>
                        <li>
                           <p>创建虚拟列值</p>
                        </li>
                        <li>
                           <p>计算每行的值，将数据转换为列式格式并压缩它</p>
                        </li>
                        <li>
                           <p>使用空间图层注册对象</p>
                        </li>
                        <li>
                           <p>将IMEU与其对应的IMCU相关联</p>
                        </li>
                     </ul>
                     <div class="infoboxnote" id="GUID-C91A11F9-CFB7-4919-A8D7-8572ED1CAEF3__GUID-683499D3-4356-4C9E-AC8E-CA92059FB61A">
                        <p class="notep1">注意：</p>
                        <p>在IMEU创建期间，父IMCU仍可用于查询。</p>
                     </div>
                     <p>在重新填充期间，W <span class="italic">nnn</span>进程基于现有的IMCU和事务日志创建新版本的IMCU，同时暂时保留旧版本。这种机制称为<a href="glossary.html#GUID-D54C930C-1B27-40FC-9B15-25670A707365"><span class="xrefglossterm">双缓冲</span></a> 。
                     </p>
                     <p>数据库可以快速将IM表达式移入和移出IM列存储。例如，如果在没有IMEU的情况下创建IMCU，则数据库可以在以后添加IMEU而不强制IMCU经历完整的重新填充机制。</p>
                     <p><code class="codeph">INMEMORY_MAX_POPULATE_SERVERS</code>初始化参数控制可以为填充启动的最大工作进程数。<code class="codeph">INMEMORY_TRICKLE_REPOPULATE_PERCENT</code>初始化参数控制工作进程可执行涓流重新填充的最大时间百分比。
                     </p>
                  </div>
                  <div>
                     <div class="infoboxnotealso" id="GUID-C91A11F9-CFB7-4919-A8D7-8572ED1CAEF3__GUID-7CC05002-BC25-4942-8AEC-B6319D935B81">
                        <p class="notep1">也可以看看：</p>
                        <ul style="list-style-type:disc">
                           <li>
                              <p><span class="q">“ <a href="populating-objects-in-memory.html#GUID-BFD476E7-C70D-4906-8B10-D33BC1E768C0" title="当数据库从磁盘读取现有行格式数据，将其转换为列格式，然后将其存储在IM列存储中时，会发生内存中的填充（填充）。">关于记忆中的人口</a> ”</span></p>
                           </li>
                           <li>
                              <p><span class="q">“ <a href="repopulation-and-dml.html#GUID-857EFBD6-6D03-4543-9FAB-F66B5C16D0C7" title="重大修改后自动刷新柱状数据称为重新填充。">关于IM列存储的重新填充</a> ”</span></p>
                           </li>
                           <li>
                              <p><span class="q">“ <a href="init-parameters-for-im-column-store.html#GUID-A67ABCAC-C6B9-499E-8AE0-BD7922B239BE" title="几个初始化参数控制IM列存储的行为。">内存中初始化参数</a> ”</span></p>
                           </li>
                           <li>
                              <p><a href="https://www.oracle.com/pls/topic/lookup?ctx=en/database/oracle/oracle-database/19/inmem&amp;id=GUID-86184690-5531-405F-AA05-BB935F57B76D" target="_blank"><span><cite>Oracle Database Reference</cite></span></a>了解有关后台进程的更多信息</p>
                           </li>
                        </ul>
                     </div>
                     <div class="familylinks">
                        <div class="parentlink">
                           <p><strong>父主题：</strong> <a href="in-memory-column-store-architecture.html#GUID-15B0EEBC-31F6-4192-957A-56D79B7E63E2" title="为了响应查询和DML，服务器进程扫描列数据并更新SMU元数据。后台进程将行数据从磁盘填充到IM列存储中。">内存中过程体系结构</a></p>
                        </div>
                     </div>
                  </div>
                  
               </div>
               <div class="sect3"><a id="GUID-68EA52F3-D62F-474D-99FB-729A6AE43D70" name="GUID-68EA52F3-D62F-474D-99FB-729A6AE43D70"></a><h4 id="INMEM-GUID-68EA52F3-D62F-474D-99FB-729A6AE43D70" class="sect4"><span class="enumeration_section">2.4.3</span>内存中动态扫描</h4>
                  <div>
                     <p><strong class="term">内存中动态扫描（IM动态扫描）</strong>使用轻量级线程来并行化内存中的表扫描。
                     </p>
                     <p>本节包含以下主题：</p>
                  </div>
                  <div>
                     <ul class="ullinks">
                        <li class="ulchildlink"><a href="in-memory-column-store-architecture.html#GUID-F2F87876-E138-43D1-ADD6-D9A5D5903C59">IM动态扫描的目的</a><br>当其他CPU可用时，IM动态扫描会加速CPU绑定的内存中表扫描。
                        </li>
                        <li class="ulchildlink"><a href="in-memory-column-store-architecture.html#GUID-CB4A29B8-46EA-417C-B9CC-6F65295A69E9">IM动态扫描如何工作</a><br>IM Dynamic Scans通过并行读取IMCU获得最佳性能。
                        </li>
                        <li class="ulchildlink"><a href="in-memory-column-store-architecture.html#GUID-C5D44481-13B9-4C6F-BD6E-B6E75A901BA5">IM动态扫描的界面</a><br>IM动态扫描是透明的，这意味着它们不需要更改应用程序，并且由资源管理器自动控制。
                        </li>
                     </ul>
                     <div class="familylinks">
                        <div class="parentlink">
                           <p><strong>父主题：</strong> <a href="in-memory-column-store-architecture.html#GUID-15B0EEBC-31F6-4192-957A-56D79B7E63E2" title="为了响应查询和DML，服务器进程扫描列数据并更新SMU元数据。后台进程将行数据从磁盘填充到IM列存储中。">内存中过程体系结构</a></p>
                        </div>
                     </div>
                  </div>
                  
                  <div class="sect4"><a id="GUID-F2F87876-E138-43D1-ADD6-D9A5D5903C59" name="GUID-F2F87876-E138-43D1-ADD6-D9A5D5903C59"></a><h5 id="INMEM-GUID-F2F87876-E138-43D1-ADD6-D9A5D5903C59" class="sect5"><span class="enumeration_section">2.4.3.1</span> IM动态扫描的目的</h5>
                     <div>
                        <p>当其他CPU可用时，IM动态扫描会加速CPU绑定的内存中表扫描。</p>
                        <p>IM动态扫描自动使用空闲CPU资源并行扫描IMCU并最大化CPU使用率。当CPU资源可用时，应用程序可以自动获得更快的分析查询结果。由于扫描是动态的，因此可以在不影响现有工作负载的情况下使用过多的CPU带宽。</p>
                        <p>IM动态扫描比传统的Oracle并行执行更灵活，尽管两者并不相互排斥。动态扫描在进程中使用多个轻量级执行线程。通常，动态扫描的性能开销很低。</p>
                     </div>
                     <div>
                        <div class="infoboxnotealso" id="GUID-F2F87876-E138-43D1-ADD6-D9A5D5903C59__GUID-0A9319C3-8D43-45CD-AB5D-9913517D9337">
                           <p class="notep1">也可以看看：</p>
                           <p><a href="https://www.oracle.com/pls/topic/lookup?ctx=en/database/oracle/oracle-database/19/inmem&amp;id=ADMIN-GUID-2BEF5482-CF97-4A85-BD90-9195E41E74EF" target="_blank"><span><cite>Oracle数据库管理员指南</cite></span></a> ，了解有关Resource Manager的更多信息</p>
                        </div>
                        <div class="familylinks">
                           <div class="parentlink">
                              <p><strong>父主题：</strong> <a href="in-memory-column-store-architecture.html#GUID-68EA52F3-D62F-474D-99FB-729A6AE43D70" title="内存中动态扫描（IM动态扫描）使用轻量级线程来并行化内存中的表扫描。">内存中动态扫描</a></p>
                           </div>
                        </div>
                     </div>
                     
                  </div>
                  <div class="sect4"><a id="GUID-CB4A29B8-46EA-417C-B9CC-6F65295A69E9" name="GUID-CB4A29B8-46EA-417C-B9CC-6F65295A69E9"></a><h5 id="INMEM-GUID-CB4A29B8-46EA-417C-B9CC-6F65295A69E9" class="sect5"><span class="enumeration_section">2.4.3.2</span> IM动态扫描的工作原理</h5>
                     <div>
                        <p>IM Dynamic Scans通过并行读取IMCU获得最佳性能。</p>
                        <p>本节包含以下主题：</p>
                     </div>
                     <div>
                        <ul class="ullinks">
                           <li class="ulchildlink"><a href="in-memory-column-store-architecture.html#GUID-4DDD1A53-D634-4201-B46F-626DAE16A447">关于轻量级线程</a><br><strong class="term">轻量级线程</strong>是一个执行实体，有助于并行化全表扫描。它是“轻量级的”，因为它不会导致Oracle进程的更高内存开销。
                           </li>
                           <li class="ulchildlink"><a href="in-memory-column-store-architecture.html#GUID-9DD695DF-A4A9-408C-A7FE-9AC001B0590A">当数据库考虑IM动态扫描时</a><br>启用CPU资源计划（例如， <code class="codeph">RESOURCE_MANAGER_PLAN=DEFAULT_PLAN</code> ）并且数据库的CPU利用率较低时，将启用轻量级线程。
                           </li>
                           <li class="ulchildlink"><a href="in-memory-column-store-architecture.html#GUID-0D557669-B378-4514-A0D3-FBE054AA9F57">IM动态扫描如何工作</a><br>资源管理器分配轻量级线程以并行化IMCU的扫描。
                           </li>
                        </ul>
                        <div class="familylinks">
                           <div class="parentlink">
                              <p><strong>父主题：</strong> <a href="in-memory-column-store-architecture.html#GUID-68EA52F3-D62F-474D-99FB-729A6AE43D70" title="内存中动态扫描（IM动态扫描）使用轻量级线程来并行化内存中的表扫描。">内存中动态扫描</a></p>
                           </div>
                        </div>
                     </div>
                     
                     <div class="sect5"><a id="GUID-4DDD1A53-D634-4201-B46F-626DAE16A447" name="GUID-4DDD1A53-D634-4201-B46F-626DAE16A447"></a><h6 id="INMEM-GUID-4DDD1A53-D634-4201-B46F-626DAE16A447" class="sect6"><span class="enumeration_section">2.4.3.2.1</span>关于轻量级线程</h6>
                        <div>
                           <p><strong class="term">轻量级线程</strong>是一个执行实体，有助于并行化全表扫描。它是“轻量级的”，因为它不会导致Oracle进程的更高内存开销。
                           </p>
                           <div class="infoboxnote" id="GUID-4DDD1A53-D634-4201-B46F-626DAE16A447__GUID-0FBCF10B-88C4-4A6F-9A7D-935799771F09">
                              <p class="notep1">注意：</p>
                              <p>IM动态扫描使用的轻量级线程与多线程Oracle数据库模型中的常规线程不同。</p>
                           </div>
                           <p>轻量级线程共享父前台或PQ进程的资源，称为<a href="glossary.html#GUID-9938DE9E-21B0-4A21-B69B-A80CA6295B44"><span class="xrefglossterm">表扫描进程</span></a> ，用于协调一组IMCU的扫描。线程保持自己独立的执行流程。数据库可以通过确定线程优先级并异步执行它们来并行化扫描。
                           </p>
                           <p>对于符合条件的查询，该进程会分配一个线程池。资源管理器根据数据库主机中的CPU计数和系统上的当前负载自动确定池中的线程数。除非空闲时间达到内部阈值，否则线程池仍可用于后续查询的会话，此时数据库将终止线程。</p>
                           <p>线程之间的通信仅在进程内发生。因此，在数据库实例级别不会发生争用。</p>
                        </div>
                        <div>
                           <div class="infoboxnotealso" id="GUID-4DDD1A53-D634-4201-B46F-626DAE16A447__GUID-1F61E3C4-2B57-49E0-BCBD-98D05866076A">
                              <p class="notep1">也可以看看：</p>
                              <p><a href="https://www.oracle.com/pls/topic/lookup?ctx=en/database/oracle/oracle-database/19/inmem&amp;id=CNCPT-GUID-4B460E97-18A0-4F5A-A62F-9608FFD43664" target="_blank"><span><cite>Oracle Database Concepts</cite></span></a>了解多线程Oracle数据库模型</p>
                           </div>
                           <div class="familylinks">
                              <div class="parentlink">
                                 <p><strong>父主题：</strong> <a href="in-memory-column-store-architecture.html#GUID-CB4A29B8-46EA-417C-B9CC-6F65295A69E9" title="IM Dynamic Scans通过并行读取IMCU获得最佳性能。">IM动态扫描的工作原理</a></p>
                              </div>
                           </div>
                        </div>
                        
                     </div>
                     <div class="sect5"><a id="GUID-9DD695DF-A4A9-408C-A7FE-9AC001B0590A" name="GUID-9DD695DF-A4A9-408C-A7FE-9AC001B0590A"></a><h6 id="INMEM-GUID-9DD695DF-A4A9-408C-A7FE-9AC001B0590A" class="sect6"><span class="enumeration_section">2.4.3.2.2</span>当数据库考虑IM动态扫描时</h6>
                        <div>
                           <p>启用CPU资源计划（例如， <code class="codeph">RESOURCE_MANAGER_PLAN=DEFAULT_PLAN</code> ）并且数据库的CPU利用率较低时，将启用轻量级线程。
                           </p>
                           <p>如果启用了轻量级线程，则当应用程序查询当前在IM列存储中填充的对象时，数据库会考虑IM动态扫描。通常，当具有以下特征时，串行或并行查询是IM动态扫描的候选者：</p>
                           <ul style="list-style-type:disc">
                              <li>
                                 <p>访问大量IMCU或列</p>
                              </li>
                              <li>
                                 <p>消耗表中的所有行</p>
                              </li>
                              <li>
                                 <p>是CPU密集型的</p>
                              </li>
                           </ul>
                           <p>IM动态扫描需要Oracle数据库资源管理器（资源管理器），它在<code class="codeph">INMEMORY_SIZE</code>大于<code class="codeph">0</code>时自动启用。资源管理器决定何时以及如何使用轻量级线程。轻量级线程是数据库中优先级最低的操作，因为它们利用未使用的资源。
                           </p>
                        </div>
                        <div>
                           <div class="familylinks">
                              <div class="parentlink">
                                 <p><strong>父主题：</strong> <a href="in-memory-column-store-architecture.html#GUID-CB4A29B8-46EA-417C-B9CC-6F65295A69E9" title="IM Dynamic Scans通过并行读取IMCU获得最佳性能。">IM动态扫描的工作原理</a></p>
                              </div>
                           </div>
                        </div>
                        
                     </div>
                     <div class="sect5"><a id="GUID-0D557669-B378-4514-A0D3-FBE054AA9F57" name="GUID-0D557669-B378-4514-A0D3-FBE054AA9F57"></a><h6 id="INMEM-GUID-0D557669-B378-4514-A0D3-FBE054AA9F57" class="sect6"><span class="enumeration_section">2.4.3.2.3</span> IM动态扫描的工作原理</h6>
                        <div>
                           <p>资源管理器分配轻量级线程以并行化IMCU的扫描。</p>
                           <p>当数据库确定查询可以从IM动态扫描中受益时，它通常按如下方式进行：</p>
                           <ol>
                              <li>
                                 <p>表扫描过程产生一个轻量级线程池。</p>
                              </li>
                              <li>
                                 <p>表扫描过程为每个必须扫描的IMCU创建单独的任务，然后将每个任务添加到任务队列。</p>
                              </li>
                              <li>
                                 <p>资源管理器确定可以参与表扫描的线程数。</p>
                              </li>
                              <li>
                                 <p>活动线程从任务队列中获取任务，表扫描过程消耗完成任务的结果。</p>
                              </li>
                           </ol>
                           <p>根据数据库负载，资源管理器会在查询运行时不断调整活动轻量级线程的数量。如果CPU资源不可用，则表扫描进程在<span class="italic">不</span>使用轻量级线程的<span class="italic">情况下</span>执行扫描。
                           </p>
                           <p>下图说明了<code class="codeph">sales</code>表中12个IMCU的IM动态扫描。
                           </p>
                           <div class="figure" id="GUID-0D557669-B378-4514-A0D3-FBE054AA9F57__GUID-398D201A-1CD8-4400-B08E-C200FDDD7B85">
                              <p class="titleinfigure">图2-12 IM动态扫描</p><img src="img/inmem_pb_001b.png" alt="下面是图2-12的描述" title="下面是图2-12的描述" longdesc="img_text/inmem_pb_001b.html"><br><a href="img_text/inmem_pb_001b.html">“图2-12 IM动态扫描”的说明</a></div>
                           <!-- class="figure" -->
                           <p>在上图中，数据库主机有8个CPU核心。基于内部算法，资源管理器分配4个线程来协助表扫描过程。在这种情况下，4个CPU核心保持空闲状态，以供其他并发数据库操作使用。</p>
                        </div>
                        <div>
                           <div class="familylinks">
                              <div class="parentlink">
                                 <p><strong>父主题：</strong> <a href="in-memory-column-store-architecture.html#GUID-CB4A29B8-46EA-417C-B9CC-6F65295A69E9" title="IM Dynamic Scans通过并行读取IMCU获得最佳性能。">IM动态扫描的工作原理</a></p>
                              </div>
                           </div>
                        </div>
                        
                     </div>
                  </div>
                  <div class="sect4"><a id="GUID-C5D44481-13B9-4C6F-BD6E-B6E75A901BA5" name="GUID-C5D44481-13B9-4C6F-BD6E-B6E75A901BA5"></a><h5 id="INMEM-GUID-C5D44481-13B9-4C6F-BD6E-B6E75A901BA5" class="sect5"><span class="enumeration_section">2.4.3.3</span> IM动态扫描的接口</h5>
                     <div>
                        <p>IM动态扫描是透明的，这意味着它们不需要更改应用程序，并且由资源管理器自动控制。</p>
                        <div class="section">
                           <p>IM动态扫描需要资源管理器，当<code class="codeph">INMEMORY_SIZE</code>大于<code class="codeph">0</code>时，资源管理器会自动启用。不需要特定的资源计划。
                           </p>
                           <p>几个新的会话统计信息跟踪IM动态扫描的使用情况。每个线程将跟踪数据写入单独的跟踪文件。</p>
                           <p>执行计划不变。下图显示了一个示例执行计划。</p><pre class="pre codeblock"><code>SQL&gt; SELECT MAX（l_quantity）maximum_order FROM lineitem; LARGEST_ORDER ------------- 50 Elapsed：00：00：03.41执行计划-------------------------- --------------------------------计划哈希值：1885658499 ------------- -------------------------------------------------- --------------------------------------- | Id |操作|名称|行|字节|成本（％CPU）|时间| Pstart时| Pstop | -------------------------------------------------- -------------------------------------------------- -  | 0 |选择声明| | 1 | 3 | 116K（4）| 00:00:05 | | | | 1 | SORT AGGREGATE | | 1 | 3 | | | | | | 2 | PARTITION RANGE ALL | | 600M | 1716M | 116K（4）| 00:00:05 | 1 | 84 | | 3 |表访问INMEMORY FULL | LINEITEM | 600M | 1716M | 116K（4）| 00:00:05 | 1 | 84 | -------------------------------------------------- -------------------------------------------------- -  NAME VALUE ---------------------------------------------- --------- IM扫描CU查询报文低1147 IM扫描字节内存5.1790E + 10 IM扫描字节未压缩7.6722E + 10 IM扫描CU列访问1147 IM扫描行600037902 IM扫描行投影29 IM扫描（动态）行600037902 IM扫描（动态）多线程扫描1线程1146处理的IM扫描（动态）任务</code></pre><p>考虑一下计划的特点：</p>
                           <ol>
                              <li>
                                 <p>执行计划没有变化。</p>
                                 <p>请注意，该计划未在步骤3中提及IM动态扫描。但是，单击SQL监视器报告中的双目图标将显示“线程上的动态扫描任务”。</p>
                              </li>
                              <li>
                                 <p><code class="codeph">IM scan (dynamic) multi-threaded scans</code>非零，这意味着数据库使用IM动态扫描。
                                 </p>
                              </li>
                              <li>
                                 <p><code class="codeph">IM scan CUs memcompress for query low</code>表示<code class="codeph">lineitem</code>表中存在1147个IMCU。
                                 </p>
                              </li>
                              <li>
                                 <p><code class="codeph">IM scan (dynamic) tasks processed by thread</code>表示并行处理了多少个IMCU。
                                 </p>
                                 <p>该数字为1146，小于<code class="codeph">IM scan CUs memcompress for query low</code>的总数1147。数据库分析了没有并行化的第一个IMCU，以确定并行化是否值得。因为答案是肯定的，所以数据库继续并行扫描剩余的1146个IMCU。
                                 </p>
                              </li>
                              <li>
                                 <p><code class="codeph">IM scan (dynamic) rows</code>和<code class="codeph">IM scan rows are equal</code> ，这意味着线程检索了查询的所有行。
                                 </p>
                              </li>
                           </ol>
                        </div>
                        <!-- class="section" -->
                     </div>
                     <div>
                        <div class="infoboxnotealso" id="GUID-C5D44481-13B9-4C6F-BD6E-B6E75A901BA5__GUID-CDAA9B98-FEB7-406D-BDD7-F1F76628FB03">
                           <p class="notep1">也可以看看：</p>
                           <ul style="list-style-type:disc">
                              <li>
                                 <p><a href="https://www.oracle.com/pls/topic/lookup?ctx=en/database/oracle/oracle-database/19/inmem&amp;id=ADMIN-GUID-E8FABE8D-A781-49BB-B623-98F096DED239" target="_blank"><span><cite>Oracle数据库管理员指南</cite></span></a> ，了解有关资源管理器的更多信息</p>
                              </li>
                              <li>
                                 <p>有关内存中统计信息描述的<a href="../refrn/statistics-descriptions-2.html#REFRN-GUID-2FBC1B7E-9123-41DD-8178-96176260A639" target="_blank"><span><cite>Oracle数据库参考</cite></span></a></p>
                              </li>
                           </ul>
                        </div>
                        <div class="familylinks">
                           <div class="parentlink">
                              <p><strong>父主题：</strong> <a href="in-memory-column-store-architecture.html#GUID-68EA52F3-D62F-474D-99FB-729A6AE43D70" title="内存中动态扫描（IM动态扫描）使用轻量级线程来并行化内存中的表扫描。">内存中动态扫描</a></p>
                           </div>
                        </div>
                     </div>
                     
                  </div>
               </div>
            </div>
            <div class="sect2"><a id="GUID-8DCA5CC5-69F6-4F26-AE94-49810F742310" name="GUID-8DCA5CC5-69F6-4F26-AE94-49810F742310"></a><h3 id="INMEM-GUID-8DCA5CC5-69F6-4F26-AE94-49810F742310" class="sect3"><span class="enumeration_section">2.5</span> CPU架构：SIMD矢量处理</h3>
               <div>
                  <p>对于在IM列存储中填充的数据，数据库使用SIMD（单指令，多数据）向量处理。</p>
                  <p>IM列存储最大化CPU可以加载到向量寄存器并进行评估的列条目数。数据库不是一次评估列中的每个条目，而是评估单个CPU指令中的一组列值。SIMD矢量处理使数据库能够每秒扫描数十亿行。</p>
                  <p>例如，应用程序发出查询以查找<code class="codeph">sales</code>表中使用<code class="codeph">promo_id</code>值<code class="codeph">9999</code>的订单总数。<code class="codeph">sales</code>表位于IM列存储中。查询首先只扫描<code class="codeph">sales.promo_id</code>列，如下图所示：</p>
                  <div class="figure" id="GUID-8DCA5CC5-69F6-4F26-AE94-49810F742310__GUID-20F920D6-E978-476E-A578-32B4C05F50B0">
                     <p class="titleinfigure">图2-13 SIMD矢量处理</p><img src="img/cncpt_vm_382.png" alt="下面是图2-13的描述" title="下面是图2-13的描述" longdesc="img_text/cncpt_vm_382.html"><br><a href="img_text/cncpt_vm_382.html">“图2-13 SIMD矢量处理”的描述</a></div>
                  <!-- class="figure" -->
                  <p>CPU按如下方式评估数据：</p>
                  <ol>
                     <li>
                        <p>将<code class="codeph">promo_id</code>列中的前8个值（数量因数据类型和压缩模式而异） <code class="codeph">promo_id</code>到SIMD寄存器中，然后在单个指令中将它们与值<code class="codeph">9999</code>进行比较</p>
                     </li>
                     <li>
                        <p>丢弃条目。</p>
                     </li>
                     <li>
                        <p>将另外8个值加载到SIMD寄存器中，然后以这种方式继续，直到它评估了所有条目。</p>
                     </li>
                  </ol>
                  <p>本节包含以下主题：</p>
               </div>
               <div>
                  <ul class="ullinks">
                     <li class="ulchildlink"><a href="in-memory-column-store-architecture.html#GUID-3F150041-3EBC-4EC7-AE95-4B17CD5960EA">SIMD和Oracle LOB</a><br><span>Oracle Database 18c</span>为涉及特定LOB列上的SQL运算符的查询提供SIMD向量支持。
                     </li>
                     <li class="ulchildlink"><a href="in-memory-column-store-architecture.html#GUID-C7D70CB1-8BD8-4252-89ED-59C88F7C9534">SIMD和Oracle数字</a><br><span>对于使用<code class="codeph">QUERY LOW</code>压缩的表格， <code class="codeph">NUMBER</code>列使用优化格式进行编码，以便在硬件中进行本机计算。</span></li>
                     <li class="ulchildlink"><a href="in-memory-column-store-architecture.html#GUID-A48C2F4B-52E7-4BB7-8649-D315C78413C4">SIMD和Exadata智能闪存缓存</a><br>除了以混合列压缩格式存储数据外，Exadata智能闪存缓存还可以以纯列式格式存储数据。
                     </li>
                  </ul>
                  <div class="familylinks">
                     <div class="parentlink">
                        <p><strong>父主题：</strong> <a href="in-memory-column-store-architecture.html#GUID-EEA265EE-8FBA-4457-8C3F-315B9EEA2224" title="内存中列存储（IM列存储）使用针对快速扫描优化的柱形格式将表和分区存储在内存中。Oracle数据库使用复杂的体系结构同时管理柱形和行格式的数据。">内存中列存储架构</a></p>
                     </div>
                  </div>
               </div>
               
               <div class="sect3"><a id="GUID-3F150041-3EBC-4EC7-AE95-4B17CD5960EA" name="GUID-3F150041-3EBC-4EC7-AE95-4B17CD5960EA"></a><h4 id="INMEM-GUID-3F150041-3EBC-4EC7-AE95-4B17CD5960EA" class="sect4"><span class="enumeration_section">2.5.1</span> SIMD和Oracle LOB</h4>
                  <div>
                     <p><span>Oracle Database 18c</span>为涉及特定LOB列上的SQL运算符的查询提供SIMD向量支持。
                     </p>
                     <p>支持的性质取决于LOB的类型：</p>
                     <ul style="list-style-type:disc">
                        <li>
                           <p>内联LOB</p>
                           <p>IM列存储为IMCU内的LOB（小于4 KB的LOB）提供连续存储。通过消除从数据库缓冲区高速缓存组装LOB数据的开销，列式存储可以加快查询处理速度。</p>
                        </li>
                        <li>
                           <p>外线LOB</p>
                           <p>在这种情况下，IM列存储仅存储LOB定位符，即40个字节。外部列不受柱状优化的影响。</p>
                        </li>
                     </ul>
                     <p>前面的规则有一个例外。IMEU可以为定义为LOB数据类型的JSON列分配最多32 KB的连续存储。IMEU以<a href="glossary.html#GUID-96C1EFE2-69DD-4E78-97DA-25253A51E3A5"><span class="xrefglossterm">OSON</span></a>格式存储这些列，使用SIMD处理可以提供更快的查询性能。
                     </p>
                  </div>
                  <div>
                     <div class="infoboxnotealso" id="GUID-3F150041-3EBC-4EC7-AE95-4B17CD5960EA__GUID-30A42379-36EF-42C3-95D6-B12116C71695">
                        <p class="notep1">也可以看看：</p>
                        <p><a href="../adlob/introduction-to-large-objects.html#ADLOB-GUID-1A2B0023-9EE8-48AF-AA76-171D1FC5C241" target="_blank"><span><cite>Oracle Database SecureFiles和Large Objects Developer's Guide</cite></span></a> ，了解有关LOB的更多信息</p>
                     </div>
                     <div class="familylinks">
                        <div class="parentlink">
                           <p><strong>父主题：</strong> <a href="in-memory-column-store-architecture.html#GUID-8DCA5CC5-69F6-4F26-AE94-49810F742310" title="对于在IM列存储中填充的数据，数据库使用SIMD（单指令，多数据）向量处理。">CPU架构：SIMD矢量处理</a></p>
                        </div>
                     </div>
                  </div>
                  
               </div>
               <div class="sect3"><a id="GUID-C7D70CB1-8BD8-4252-89ED-59C88F7C9534" name="GUID-C7D70CB1-8BD8-4252-89ED-59C88F7C9534"></a><h4 id="INMEM-GUID-C7D70CB1-8BD8-4252-89ED-59C88F7C9534" class="sect4"><span class="enumeration_section">2.5.2</span> SIMD和Oracle编号</h4>
                  <div>
                     <p><span>对于使用<code class="codeph">QUERY LOW</code>压缩的表格， <code class="codeph">NUMBER</code>列使用优化格式进行编码，以便在硬件中进行本机计算。</span></p>
                     <p><span>SIMD矢量处理使简单聚合， <code class="codeph">GROUP BY</code>聚合和算术运算能够显着受益。性能改进取决于聚合在算术计算上花费的时间量。一些聚合可能会受益高达9倍。</span></p>
                  </div>
                  <div>
                     <div class="infoboxnotealso" id="GUID-C7D70CB1-8BD8-4252-89ED-59C88F7C9534__GUID-09CA3951-DE7D-427A-9CE2-8D357B64F8E5">
                        <p class="notep1">也可以看看：</p>
                        <ul style="list-style-type:disc">
                           <li>
                              <p><span class="q">“ <a href="optimizing-in-memory-aggregation.html#GUID-4321558D-853B-41A0-9098-4A45204F21BD" title="内存优化算法使用优化的NUMBER格式，使用SIMD硬件进行快速计算。">优化内存中算术</a> ”</span></p>
                           </li>
                           <li>
                              <p><a href="../sqlrf/Data-Types.html#SQLRF-GUID-9401BC04-81C4-4CD5-99E7-C5E25C83F608" target="_blank"><span><cite>Oracle数据库SQL语言参考</cite></span></a></p>
                           </li>
                        </ul>
                     </div>
                     <div class="familylinks">
                        <div class="parentlink">
                           <p><strong>父主题：</strong> <a href="in-memory-column-store-architecture.html#GUID-8DCA5CC5-69F6-4F26-AE94-49810F742310" title="对于在IM列存储中填充的数据，数据库使用SIMD（单指令，多数据）向量处理。">CPU架构：SIMD矢量处理</a></p>
                        </div>
                     </div>
                  </div>
                  
               </div>
               <div class="sect3"><a id="GUID-A48C2F4B-52E7-4BB7-8649-D315C78413C4" name="GUID-A48C2F4B-52E7-4BB7-8649-D315C78413C4"></a><h4 id="INMEM-GUID-A48C2F4B-52E7-4BB7-8649-D315C78413C4" class="sect4"><span class="enumeration_section">2.5.3</span> SIMD和Exadata智能闪存缓存</h4>
                  <div>
                     <p>除了以混合列压缩格式存储数据外，Exadata智能闪存缓存还可以以纯列式格式存储数据。</p>
                     <p>Exadata Smart Scan支持SIMD谓词。优点是内存中性能从DRAM存储扩展到二级存储。</p>
                     <p>默认情况下，Exadata智能闪存缓存使用<code class="codeph">MEMCOMPRESS FOR CAPACITY LOW</code>级别压缩数据。若要更改压缩级别或完全禁用列式格式，请使用<code class="codeph">ALTER TABLE ...NO CELLMEMORY</code>声明。
                     </p>
                  </div>
                  <div>
                     <div class="infoboxnotealso" id="GUID-A48C2F4B-52E7-4BB7-8649-D315C78413C4__GUID-ECB949A8-37D3-4DF0-923D-C433D823C8FC">
                        <p class="notep1">也可以看看：</p>
                        <ul style="list-style-type:disc">
                           <li>
                              <p><span class="q">“ <a href="intro-to-in-memory-column-store.html#GUID-3C7A9421-141C-43F8-9CFC-D0D516E19D3B" title="并非所有标记为INMEMORY的对象都可以同时适合DRAM内存。如果使用Oracle Exadata存储服务器软件，则Exadata智能闪存缓存可用作补充内存。">Exadata Flash Cache的内存支持</a> ”</span></p>
                           </li>
                           <li>
                              <p><a href="https://www.oracle.com/pls/topic/lookup?ctx=en/database/oracle/oracle-database/19/inmem&amp;id=DBMSO-GUID-D3F05A21-F1A8-48D0-AC3C-88AF3D725DCD" target="_blank"><span id="GUID-A48C2F4B-52E7-4BB7-8649-D315C78413C4__DBMSO"><cite>Oracle数据库云服务器系统概述</cite></span></a></p>
                           </li>
                        </ul>
                     </div>
                     <div class="familylinks">
                        <div class="parentlink">
                           <p><strong>父主题：</strong> <a href="in-memory-column-store-architecture.html#GUID-8DCA5CC5-69F6-4F26-AE94-49810F742310" title="对于在IM列存储中填充的数据，数据库使用SIMD（单指令，多数据）向量处理。">CPU架构：SIMD矢量处理</a></p>
                        </div>
                     </div>
                  </div>
                  
               </div>
            </div>
         </div>
      </article>
   </body>
</html>