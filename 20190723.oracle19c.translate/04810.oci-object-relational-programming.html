<html lang="en-us" dir="ltr" xml:lang="en-us">
   <head>
      <meta http-equiv="Content-Type" content="text/html; charset=utf-8"></meta>
      <meta name="viewport" content="width=device-width, initial-scale=1"></meta>
      <meta http-equiv="X-UA-Compatible" content="IE=edge"></meta>
      <meta name="abstract" content="This chapter introduces the OCI facility for working with objects in an Oracle database. It also discusses the object navigational function calls of OCI."></meta>
      <meta name="description" content="This chapter introduces the OCI facility for working with objects in an Oracle database. It also discusses the object navigational function calls of OCI."></meta>
      <title>OCI对象关系编程</title>
      <meta property="og:site_name" content="Oracle Help Center"></meta>
      <meta property="og:title" content="Programmer&#39;s Guide"></meta>
      <meta property="og:description" content="This chapter introduces the OCI facility for working with objects in an Oracle database. It also discusses the object navigational function calls of OCI."></meta>
      <link rel="stylesheet" href="/sp_common/book-template/ohc-book-template/css/book.css"></link>
      <link rel="shortcut icon" href="/sp_common/book-template/ohc-common/img/favicon.ico"></link>
      <meta name="application-name" content="Programmer&#39;s Guide"></meta>
      <meta name="generator" content="DITA Open Toolkit version 1.8.5 (Mode = doc)"></meta>
      <meta name="plugin" content="SP_docbuilder HTML plugin release 18.2.2"></meta>
      <link rel="alternate" href="oracle-call-interface-programmers-guide.pdf" title="PDF File" type="application/pdf"></link>
      <meta name="robots" content="all"></meta>
      <link rel="schema.dcterms" href="http://purl.org/dc/terms/"></link>
      <meta name="dcterms.created" content="2019-01-14T08:46:00-08:00"></meta>
      
      <meta name="dcterms.dateCopyrighted" content="1996, 2019"></meta>
      <meta name="dcterms.category" content="database"></meta>
      <meta name="dcterms.identifier" content="E96204-01"></meta>
      
      <meta name="dcterms.product" content="en/database/oracle/oracle-database/19"></meta>
      
      <link rel="prev" href="oci-interface-for-using-shards.html" title="Previous" type="text/html"></link>
      <link rel="next" href="object-relational-data-types-in-oci.html" title="Next" type="text/html"></link>
      <script>
        document.write('<style type="text/css">');
        document.write('body > .noscript, body > .noscript ~ * { visibility: hidden; }');
        document.write('</style>');
     </script>
      <script src="/sp_common/book-template/requirejs/require.js" data-main="/sp_common/book-template/ohc-book-template/js/book-config"></script>
      <script>
            if (window.require === undefined) {
                document.write('<script data-main="sp_common/book-template/ohc-book-template/js/book-config" src="sp_common/book-template/requirejs/require.js"><\/script>');
                document.write('<link href="sp_common/book-template/ohc-book-template/css/book.css" rel="stylesheet"/>');
            }
        </script>
      <script type="application/json" id="ssot-metadata">{"primary":{"category":{"short_name":"database","element_name":"Database","display_in_url":true},"suite":{"short_name":"oracle","element_name":"Oracle","display_in_url":true},"product_group":{"short_name":"not-applicable","element_name":"Not applicable","display_in_url":false},"product":{"short_name":"oracle-database","element_name":"Oracle Database","display_in_url":true},"release":{"short_name":"19","element_name":"Release 19","display_in_url":true}}}</script>
      
    <meta name="dcterms.title" content="Oracle Call Interface Programmer&#39;s Guide"></meta>
    <meta name="dcterms.isVersionOf" content="LNOCI"></meta>
    <meta name="dcterms.release" content="Release 19"></meta>
  </head>
   <body dir="ltr">
      <div class="noscript alert alert-danger text-center" role="alert">
         <a href="oci-interface-for-using-shards.html" class="pull-left"><span class="glyphicon glyphicon-chevron-left" aria-hidden="true"></span>上一页</a> <a href="object-relational-data-types-in-oci.html" class="pull-right">下一页<span class="glyphicon glyphicon-chevron-right" aria-hidden="true"></span></a> <span class="fa fa-exclamation-triangle" aria-hidden="true"></span>必须启用JavaScript才能正确显示此内容</div>
      <article>
         <header>
            <ol class="breadcrumb" vocab="http://schema.org/" typeof="BreadcrumbList">
               <li property="itemListElement" typeof="ListItem"><a href="index.html" property="item" typeof="WebPage"><span property="name">程序员指南</span></a></li>
               <li class="active" property="itemListElement" typeof="ListItem">OCI对象关系编程</li>
            </ol>
            <a id="GUID-8A9E9784-9D10-40B1-ADE9-4CE9325255E5" name="GUID-8A9E9784-9D10-40B1-ADE9-4CE9325255E5"></a><a id="LNOCI100"></a>
            
            <h2 id="LNOCI-GUID-8A9E9784-9D10-40B1-ADE9-4CE9325255E5" class="sect2"><span class="enumeration_chapter">19</span> OCI对象关系编程</h2>
         </header>
         <div class="ind">
            <div>
               <p>本章介绍用于在Oracle数据库中处理对象的OCI工具。它还讨论了OCI的对象导航函数调用。</p>
               <p>本章包含以下主题：</p>
               <ul style="list-style-type:disc">
                  <li>
                     <p><a href="oci-object-relational-programming.html#GUID-EE003A8F-A19B-499C-A8FE-4BB4B37EC44D" title="OCI允许应用程序访问Oracle数据库中的任何数据类型，包括标量值，集合和任何对象类型的实例。">OCI对象概述</a></p>
                  </li>
                  <li>
                     <p><a href="oci-object-relational-programming.html#GUID-3F376D7F-56D2-4C5B-97FE-1E94E2A57519" title="管理关系OCI应用程序的许多编程原则对于对象关系应用程序是相同的。">关于在OCI中使用对象</a></p>
                  </li>
                  <li>
                     <p><a href="oci-object-relational-programming.html#GUID-E7064985-9564-42EA-B4F7-1604088BF15F" title="本节讨论开发基本OCI对象应用程序所涉及的步骤。">关于开发OCI对象应用程序</a></p>
                  </li>
                  <li>
                     <p><a href="oci-object-relational-programming.html#GUID-CDE560AC-9FE0-4393-9EDC-0648DB38C5C9" title="对象的类型继承与C ++和Java中的继承有许多相似之处。">关于类型继承</a></p>
                  </li>
                  <li>
                     <p><a href="oci-object-relational-programming.html#GUID-34071CB4-805F-4DFE-B2F3-2E51A5B312F9" title="支持添加，删除和修改类型属性。这个概念被称为类型演化。">关于Type Evolution</a></p>
                  </li>
               </ul>
            </div><a id="LNOCI16776"></a><div class="props_rev_3"><a id="GUID-EE003A8F-A19B-499C-A8FE-4BB4B37EC44D" name="GUID-EE003A8F-A19B-499C-A8FE-4BB4B37EC44D"></a><h3 id="LNOCI-GUID-EE003A8F-A19B-499C-A8FE-4BB4B37EC44D" class="sect3"><span class="enumeration_section">19.1</span> OCI对象概述</h3>
               <div>
                  <p>OCI允许应用程序访问Oracle数据库中的任何数据类型，包括标量值，集合和任何对象类型的实例。</p>
                  <p>这包括以下所有内容：</p>
                  <ul style="list-style-type:disc">
                     <li>
                        <p>对象</p>
                     </li>
                     <li>
                        <p>可变长度数组（ <code class="codeph">varray</code> s）</p>
                     </li>
                     <li>
                        <p>嵌套表（multisets）</p>
                     </li>
                     <li>
                        <p>参考文献（ <code class="codeph">REF</code> s）</p>
                     </li>
                     <li>
                        <p>的LOB</p>
                     </li>
                  </ul>
                  <div class="infoboxnote" id="GUID-EE003A8F-A19B-499C-A8FE-4BB4B37EC44D__GUID-B829CBCB-74C9-498F-8C86-FB607CD0175C">
                     <p class="notep1">注意：</p>
                     <p>从Oracle Database 12 <code class="codeph">c</code>第2版（12.2）开始，线性快照大小从24字节更改为34字节，需要重建集合映像表单。当较旧的客户端或服务器访问涉及对集合的任何访问的版本12.2或更高版本的数据库时，必须在发送或接收较旧的客户端或服务器时转换包含线性快照的集合映像表单。此转换会导致性能下降。Oracle建议您使用12.2版本的客户端或服务器来避免此转换。
                     </p>
                  </div>
                  <p>要充分利用Oracle数据库对象功能，大多数应用程序必须做的不仅仅是访问对象。检索到对象后，应用程序必须通过该对象的引用导航到其他对象。OCI提供了执行此操作的功能。通过OCI对象<span class="italic">导航调用</span> ，应用程序可以对对象执行以下任何功能：</p>
                  <ul style="list-style-type:disc">
                     <li>
                        <p>创建，访问，锁定，删除，复制和刷新对象</p>
                     </li>
                     <li>
                        <p>获取对象及其元对象的引用</p>
                     </li>
                     <li>
                        <p>动态获取和设置对象属性的值</p>
                     </li>
                  </ul>
                  <p>OCI还提供访问存储在Oracle数据库中的类型信息的功能。<code class="codeph">OCIDescribeAny()</code>函数使应用程序能够访问与存储在数据库中的类型相关的大多数信息，包括有关方法，属性和类型元数据的信息。
                  </p>
                  <p>与Oracle数据库对象交互的应用程序需要一种以宿主语言格式表示这些对象的方法。Oracle数据库提供了一个名为Object Type Translator（OTT）的实用程序，它可以将数据库中的类型定义转换为C struct声明。声明存储在可以包含在OCI应用程序中的头文件中。</p>
                  <p>当类型定义以C表示时，属性类型将映射到特殊C变量类型。OCI包括一组<span class="italic">数据类型映射和操作函数</span> ，使应用程序能够操作这些数据类型，从而操纵对象的属性。
                  </p>
                  <p>对象的术语偶尔会变得混乱。在本章的其余部分中，术语<span class="italic">对象</span>和<span class="italic">实例</span>都指的是存储在数据库中或存在于对象缓存中的对象。
                  </p>
                  <div class="infoboxnotealso" id="GUID-EE003A8F-A19B-499C-A8FE-4BB4B37EC44D__GUID-01839063-6032-4A03-9792-7DF17CABAEFB">
                     <p class="notep1">也可以看看：</p>
                     <ul style="list-style-type:disc">
                        <li>
                           <p><a href="oci-object-relational-programming.html#GUID-E7064985-9564-42EA-B4F7-1604088BF15F" title="本节讨论开发基本OCI对象应用程序所涉及的步骤。">关于开发OCI对象应用程序</a>以获取有关OCI导航调用的更多详细信息</p>
                        </li>
                        <li>
                           <p><a href="describing-schema-metadata.html#GUID-CED0D15A-D873-43F7-A5B2-51FC0662C250" title="执行模式对象及其子模式对象的显式描述。OCIDescribeAny（）调用限制返回到基本信息的信息，并停止扩展节点（如果它等于另一个描述操作）。执行描述操作时应注意什么。OCI_ATTR_TYPECODE属性返回表示使用CREATE TYPE语句创建新类型时用户提供的类型的类型代码。要描述类型对象，必须在对象模式下初始化OCI进程。可以使用带有OCIStmtExecute（）的隐式描述和带有OCIDescribeAny（）的显式描述来返回列属性OCI_ATTR_PRECISION。类型方法的OCI_ATTR_LIST_ARGUMENTS属性表示方法的第二级参数。本节介绍属于不同参数的属性和句柄。列出并描述表或视图的参数的类型特定属性。列出并描述参数用于过程或函数时的特定于类型的属性。列出并描述参数用于包时的属性。列出并描述参数用于类型时的属性。列出并描述参数用于类型属性时的属性。当参数用于类型的方法时，列出并记录属性。列出并描述参数用于集合类型时的属性。列出并描述参数用于同义词时的属性。列出并描述参数用于序列时的属性。列出并描述参数用于表或视图列时的属性。列出并描述参数用于过程或函数的参数时的属性。当参数用于列，参数和子程序列表或包记录类型的字段时，列出并描述属性。列出并描述参数用于模式类型时的属性。列出并描述参数用于数据库类型时的属性。列出并描述参数用于规则时的属性。列出并描述参数用于规则集时的属性。列出并描述参数用于评估上下文时的属性。列出并描述参数用于表别名时的属性。列出并描述参数用于变量时的属性。列出并描述参数用于名称 - 值对时的属性。查询和列信息支持字符长度语义。如果使用字符长度语义创建数据库列，则隐式描述信息包含字符长度，字节长度和指示如何创建数据库列的标志。表的显式描述有三个属性：OCI_ATTR_DATA_SIZE，OCI_ATTR_CHAR_SIZE和OCI_ATTR_CHAR_USED.Character-length语义取决于服务器或客户端的发布。最好在服务器和客户端都是Oracle9i或更高版本时进行描述。否则，将导致兼容性问题。以下示例演示了如何使用OCIDescribeAny（）来描述不同类型的架构对象。说明使用显式描述来检索表的列数据类型。描述类型方法（也分为函数和过程）所需的步骤与常规PL / SQL函数和过程相同。说明在命名对象类型上使用显式描述。说明在命名集合类型上使用显式描述。显示一个循环，用于在查询执行后检索与查询对应的列名和数据类型。说明使用不可见列属性并检查每列以确定它是否为不可见列。">描述模式元数据</a>以讨论<code class="codeph">OCIDescribeAny()</code></p>
                        </li>
                        <li>
                           <p><a href="object-relational-data-types-in-oci.html#GUID-C62AEE74-0CC5-4FAB-A91F-997F71C49C2C" title="This chapter describes the purpose and structure of each of the data types that can be manipulated by the OCI data type mapping and manipulation functions.">OCI</a>中的<a href="object-relational-data-types-in-oci.html#GUID-C62AEE74-0CC5-4FAB-A91F-997F71C49C2C" title="本章描述了可由OCI数据类型映射和操作函数操作的每种数据类型的用途和结构。">对象关系数据类型，</a>用于更详细地讨论函数</p>
                        </li>
                        <li>
                           <p><a href="bind-define-describe-functions.html#GUID-AE9F73FB-DCC1-401E-8151-A8A89059163A" title="描述现有的模式和子模式对象。">OCIDescribeAny（）</a></p>
                        </li>
                     </ul>
                  </div>
               </div>
            </div><a id="LNOCI16777"></a><div class="props_rev_3"><a id="GUID-3F376D7F-56D2-4C5B-97FE-1E94E2A57519" name="GUID-3F376D7F-56D2-4C5B-97FE-1E94E2A57519"></a><h3 id="LNOCI-GUID-3F376D7F-56D2-4C5B-97FE-1E94E2A57519" class="sect3"><span class="enumeration_section">19.2</span>关于在OCI中使用对象</h3>
               <div>
                  <p>管理关系OCI应用程序的许多编程原则对于对象关系应用程序是相同的。</p>
                  <p>对象关系应用程序使用标准OCI调用来建立数据库连接并处理SQL语句。不同之处在于发出的SQL语句检索对象引用，然后可以使用OCI对象函数对其进行操作。对象也可以直接作为值实例进行操作（不使用其对象引用）。</p>
                  <div class="p">本节包括以下主题：<ul style="list-style-type:disc">
                        <li>
                           <p><a href="oci-object-relational-programming.html#GUID-E607333E-D9E4-4F7C-BF31-4AAB18B37A7B" title="使用对象的OCI应用程序的基本结构与关系OCI应用程序的基本结构基本相同。">基本对象程序结构</a></p>
                        </li>
                        <li>
                           <p><a href="oci-object-relational-programming.html#GUID-8E954104-DBBB-46F7-823B-B29C1E83EFE9" title="Oracle类型的实例根据其生命周期分为持久对象和瞬态对象。">持久对象，瞬态对象和值</a></p>
                        </li>
                     </ul>
                  </div>
               </div><a id="LNOCI16778"></a><div class="props_rev_3"><a id="GUID-E607333E-D9E4-4F7C-BF31-4AAB18B37A7B" name="GUID-E607333E-D9E4-4F7C-BF31-4AAB18B37A7B"></a><h4 id="LNOCI-GUID-E607333E-D9E4-4F7C-BF31-4AAB18B37A7B" class="sect4"><span class="enumeration_section">19.2.1</span>基本对象程序结构</h4>
                  <div>
                     <p>使用对象的OCI应用程序的基本结构与关系OCI应用程序的基本结构基本相同。</p>
                     <p>这个范例在这里被复制，包含基本对象功能的额外信息。</p>
                     <ol>
                        <li>
                           <p>初始化OCI编程环境。您<span class="italic">必须</span>在对象模式下初始化环境。
                           </p>
                           <p>您的应用程序必须在头文件中包含数据库对象的C结构表示。这些结构可以由程序员创建，或者更容易，它们可以由对象类型转换器（OTT）生成。</p>
                        </li>
                        <li>
                           <p>分配必要的句柄，并建立与服务器的连接。</p>
                        </li>
                        <li>
                           <p>准备SQL语句以便执行。这是本地（客户端）步骤，可能包括绑定占位符和定义输出变量。在对象关系应用程序中，此SQL语句应该向对象返回引用（ <code class="codeph">REF</code> ）。
                           </p>
                           <div class="infoboxnote" id="GUID-E607333E-D9E4-4F7C-BF31-4AAB18B37A7B__GUID-C23B5AA6-26A2-4FCA-B0F6-A3F1357C59EB">
                              <p class="notep1">注意：</p>
                              <p>也可以获取整个对象，而不仅仅是引用（ <code class="codeph">REF</code> ）。如果选择可引用对象，而不是固定它，则按<span class="italic">值</span>获取该对象。您还可以选择不可引用的对象。
                              </p>
                           </div>
                        </li>
                        <li>
                           <p>将准备好的语句与数据库服务器关联，然后执行该语句。</p>
                        </li>
                        <li>
                           <p>获取返回的结果。</p>
                           <p>在对象关系应用程序中，此步骤需要检索<code class="codeph">REF</code> ，然后固定它引用的对象。固定对象后，您的应用程序可以执行以下部分或全部操作：</p>
                           <ul style="list-style-type:disc">
                              <li>
                                 <p>操纵对象的属性并将其标记为<span class="italic">脏</span> （已修改）</p>
                              </li>
                              <li>
                                 <p>跟随<code class="codeph">REF</code>到另一个对象或一系列对象</p>
                              </li>
                              <li>
                                 <p>访问类型和属性信息</p>
                              </li>
                              <li>
                                 <p>导航复杂的对象检索图</p>
                              </li>
                              <li>
                                 <p>将修改后的对象刷新到服务器</p>
                              </li>
                           </ul>
                        </li>
                        <li>
                           <p>提交交易。此步骤隐式将所有已修改的对象刷新到服务器并提交更改。</p>
                        </li>
                        <li>
                           <p>免费语句和句柄不能重复使用，或者再次重新执行预准备语句。</p>
                        </li>
                     </ol>
                     <p>本章的其余部分将更详细地讨论这些步骤。</p>
                     <div class="infoboxnotealso" id="GUID-E607333E-D9E4-4F7C-BF31-4AAB18B37A7B__GUID-34B68EB6-49B1-435B-A0CE-CAAB00060433">
                        <p class="notep1">也可以看看：</p>
                        <ul style="list-style-type:disc">
                           <li>
                              <p><a href="oci-programming-basics.html#GUID-15C10430-3EBA-44B4-9518-BB097972A0F2" title="OCI应用程序的一般目标是代表多个用户进行操作。">OCI程序设计概述</a></p>
                           </li>
                           <li>
                              <p><a href="oci-object-relational-programming.html#GUID-7B0B6CF5-AD69-4FCB-9E96-CA6469601077" title="应用程序必须获取嵌入的对象实例。">获取嵌入对象</a>描述了获取整个对象</p>
                           </li>
                           <li>
                              <p><a href="oci-programming-basics.html#GUID-4CFB8AF7-EF05-4E0F-847F-2D0710E552C5" title="本章介绍了使用OCI进行编程所涉及的概念和过程。">OCI编程基础知识</a> ，了解有关使用OCI连接服务器，处理SQL语句以及在<a href="database-access-c-api.html#GUID-322BCDA4-1A70-4BD1-85F1-FAACC4C772F5" title="本章开始描述Oracle Database Access C API，特别是C的OCI关系函数。">Oracle Database Access C API中</a>分配句柄和OCI关系函数的描述的信息</p>
                           </li>
                           <li>
                              <p><a href="oci-object-relational-programming.html#GUID-E54EFD72-BB77-4F4E-ABEB-34159AE84545" title="在OCI应用程序可以使用对象类型之前，这些类型必须存在于数据库中。">关于在C应用程序中表示对象</a>以获取有关OTT的信息以及<a href="using-object-type-translator-in-oci.html#GUID-3D22CA8E-BE01-492F-BA85-DDD0CD3F4890" title="本章讨论了对象类型转换器（OTT），它用于将数据库对象类型和命名集合类型映射到C结构，以便在OCI应用程序中使用。">将对象类型转换器与OCI一起使用</a></p>
                           </li>
                        </ul>
                     </div>
                  </div>
               </div><a id="LNOCI16779"></a><div class="props_rev_3"><a id="GUID-8E954104-DBBB-46F7-823B-B29C1E83EFE9" name="GUID-8E954104-DBBB-46F7-823B-B29C1E83EFE9"></a><h4 id="LNOCI-GUID-8E954104-DBBB-46F7-823B-B29C1E83EFE9" class="sect4"><span class="enumeration_section">19.2.2</span>持久对象，瞬态对象和值</h4>
                  <div>
                     <p>Oracle类型的实例根据其生命周期分为<span class="italic">持久对象</span>和<span class="italic">瞬态对象</span> 。
                     </p>
                     <p>持久对象的实例可以进一步划分为<span class="italic">独立对象</span>和<span class="italic">嵌入对象，</span>这取决于它们是否可通过对象标识符引用。
                     </p>
                     <div class="infoboxnote" id="GUID-8E954104-DBBB-46F7-823B-B29C1E83EFE9__GUID-2AE9A336-885F-4744-9242-35FCBED51C87">
                        <p class="notep1">注意：</p>
                        <p>术语<span class="italic">对象</span>和<span class="italic">实例</span>在本手册中可互换使用。
                        </p>
                     </div>
                     <div class="p">本节包括以下主题：<ul style="list-style-type:disc">
                           <li>
                              <p><a href="oci-object-relational-programming.html#GUID-0C2B61C1-67AD-4B6B-8936-96FD21BA46EE" title="持久对象是存储在Oracle数据库中的对象。">持久对象</a></p>
                           </li>
                           <li>
                              <p><a href="oci-object-relational-programming.html#GUID-767FA104-F113-4B6A-AC27-568895A0D649" title="临时对象是一个临时实例，其生命周期不超过应用程序的生命周期，并且无法存储或刷新到服务器。">瞬态物体</a></p>
                           </li>
                           <li>
                              <p><a href="oci-object-relational-programming.html#GUID-AFA10D2A-9584-49C2-9530-29B41D376AFC" title="值被称为标量值或嵌入或不可引用对象。">值</a></p>
                           </li>
                        </ul>
                        <div class="infoboxnotealso" id="GUID-8E954104-DBBB-46F7-823B-B29C1E83EFE9__GUID-B2DDFA11-4285-402D-859F-9CD25C6CA702">
                           <p class="notep1">也可以看看：</p>
                           <p>有关对象的更多信息，请参见<a href="../adobj/introduction-to-oracle-objects.html#ADOBJ001" target="_blank"><span><cite>“Oracle数据库对象关系开发人员指南”</cite></span></a></p>
                        </div>
                     </div>
                  </div><a id="LNOCI72700"></a><a id="LNOCI72701"></a><a id="LNOCI16780"></a><div class="props_rev_3"><a id="GUID-0C2B61C1-67AD-4B6B-8936-96FD21BA46EE" name="GUID-0C2B61C1-67AD-4B6B-8936-96FD21BA46EE"></a><h5 id="LNOCI-GUID-0C2B61C1-67AD-4B6B-8936-96FD21BA46EE" class="sect5"><span class="enumeration_section">19.2.2.1</span>持久对象</h5>
                     <div>
                        <p>持久对象是存储在Oracle数据库中的对象。</p>
                        <p>它可以被提取到对象缓存中并由OCI应用程序修改。持久对象的生命周期可能超过访问它的应用程序的生命周期。一旦创建它，它将保留在数据库中，直到它被明确删除。有两种类型的持久对象：</p>
                        <ul style="list-style-type:disc">
                           <li>
                              <p>独立实例存储在对象表的行中，每个实例都有唯一的对象标识符。OCI应用程序可以将<code class="codeph">REF</code>检索到独立实例，固定对象，并从固定对象导航到其他相关对象。独立对象也可以称为可<span class="italic">引用对象</span> 。
                              </p>
                              <p>也可以选择可引用对象，在这种情况下，您可以<span class="italic">按值</span>获取对象<span class="italic">，</span>而不是获取其<code class="codeph">REF</code> 。</p>
                           </li>
                           <li>
                              <p>嵌入式实例不会作为行存储在对象表中。它们嵌入在其他结构中。嵌入对象的示例是作为另一个对象的属性的对象，或者存在于数据库表的对象列中的实例。嵌入式实例没有对象标识符，OCI应用程序无法将<code class="codeph">REF</code>为嵌入式实例。
                              </p>
                              <p>嵌入对象也可以称为不可引用<span class="italic">对象</span>或<span class="italic">值实例</span> 。您有时可能会将它们称为<span class="italic">值</span> ，这些值不会与标量数据值混淆。上下文应该明确含义。
                              </p>
                           </li>
                        </ul>
                        <p><a href="oci-object-relational-programming.html#GUID-0C2B61C1-67AD-4B6B-8936-96FD21BA46EE__BGBDBIFJ">例19-1</a>和<a href="oci-object-relational-programming.html#GUID-0C2B61C1-67AD-4B6B-8936-96FD21BA46EE__BGBGEACI">例19-2</a>显示了演示这两种类型的持久对象之间差异的SQL示例。
                        </p>
                        <p>存储在对象表<code class="codeph">person_tab</code>中的对象是独立实例。它们具有对象标识符并且是可引用的。它们可以固定在OCI应用程序中。
                        </p>
                        <p>存储在<code class="codeph">department</code>表的<code class="codeph">manager</code>列中的对象是嵌入对象。它们没有对象标识符，并且它们不可引用;这意味着它们不能固定在OCI应用程序中，也不需要取消固定。它们始终<span class="italic">按值</span>检索到对象缓存中。
                        </p>
                        <div class="example" id="GUID-0C2B61C1-67AD-4B6B-8936-96FD21BA46EE__BGBDBIFJ">
                           <p class="titleinexample">例19-1独立对象的SQL定义</p><pre class="oac_no_warn" dir="ltr">CREATE TYPE person_t AS OBJECT（名称varchar2（30），年龄数（3））; CREATE TABLE person_tab OF person_t;</pre></div>
                        <!-- class="example" -->
                        <div class="example" id="GUID-0C2B61C1-67AD-4B6B-8936-96FD21BA46EE__BGBGEACI">
                           <p class="titleinexample">例19-2嵌入对象的SQL定义</p><pre class="oac_no_warn" dir="ltr">CREATE TABLE部门（deptno number，deptname varchar2（30），manager person_t）;</pre></div>
                        <!-- class="example" -->
                     </div>
                  </div><a id="LNOCI16783"></a><div class="props_rev_3"><a id="GUID-767FA104-F113-4B6A-AC27-568895A0D649" name="GUID-767FA104-F113-4B6A-AC27-568895A0D649"></a><h5 id="LNOCI-GUID-767FA104-F113-4B6A-AC27-568895A0D649" class="sect5"><span class="enumeration_section">19.2.2.2</span>瞬态物体</h5>
                     <div>
                        <p>临时对象是一个临时实例，其生命周期不超过应用程序的生命周期，并且无法存储或刷新到服务器。</p>
                        <p>应用程序可以随时删除瞬态对象。</p>
                        <p>应用程序通常使用<code class="codeph">OCIObjectNew()</code>函数创建瞬态对象来存储临时值以进行计算。瞬态对象无法转换为持久对象。他们的角色在实例化时是固定的。
                        </p>
                        <div class="infoboxnotealso" id="GUID-767FA104-F113-4B6A-AC27-568895A0D649__GUID-59F0082B-158D-4087-87C9-26F936691375">
                           <p class="notep1">也可以看看：</p>
                           <ul style="list-style-type:disc">
                              <li>
                                 <p><a href="oci-object-relational-programming.html#GUID-86418D8C-FA67-4B14-A5BC-7A075C6B4206" title="OCI应用程序可以使用OCIObjectNew（）创建任何对象。">关于创建对象</a>以获取有关使用<code class="codeph">OCIObjectNew()</code>更多信息</p>
                              </li>
                              <li>
                                 <p><a href="oci-miscellaneous-object-functions.html#GUID-2EFD6F01-A02F-4C5B-B20F-1EF841249056" title="创建独立实例。">OCIObjectNew（）</a></p>
                              </li>
                           </ul>
                           <p></p>
                        </div>
                     </div>
                  </div><a id="LNOCI16784"></a><div class="props_rev_3"><a id="GUID-AFA10D2A-9584-49C2-9530-29B41D376AFC" name="GUID-AFA10D2A-9584-49C2-9530-29B41D376AFC"></a><h5 id="LNOCI-GUID-AFA10D2A-9584-49C2-9530-29B41D376AFC" class="sect5"><span class="enumeration_section">19.2.2.3</span>值</h5>
                     <div>
                        <p>值被称为标量值或嵌入或不可引用对象。</p>
                        <p>在本手册的上下文中， <span class="italic">值</span>指的是：</p>
                        <ul style="list-style-type:disc">
                           <li>
                              <p>存储在数据库表的非对象列中的标量值。OCI应用程序可以通过发出SQL语句从数据库中获取值。</p>
                           </li>
                           <li>
                              <p>嵌入式或非可引用对象。</p>
                           </li>
                        </ul>
                        <p>上下文应该清楚表明意图是什么意思。</p>
                        <div class="infoboxnote" id="GUID-AFA10D2A-9584-49C2-9530-29B41D376AFC__GUID-31789B3E-965F-4A8C-BD0A-026859C97CF4">
                           <p class="notep1">注意：</p>
                           <p>可以将可引用对象选择到对象缓存中，而不是固定它，在这种情况下，您可以<span class="italic">按值</span>获取对象而不是获取其<code class="codeph">REF</code> 。</p>
                        </div>
                     </div>
                  </div>
               </div>
            </div><a id="LNOCI16786"></a><a id="LNOCI16785"></a><div class="props_rev_3"><a id="GUID-E7064985-9564-42EA-B4F7-1604088BF15F" name="GUID-E7064985-9564-42EA-B4F7-1604088BF15F"></a><h3 id="LNOCI-GUID-E7064985-9564-42EA-B4F7-1604088BF15F" class="sect3"><span class="enumeration_section">19.3</span>关于开发OCI对象应用程序</h3>
               <div>
                  <p>本节讨论开发基本OCI对象应用程序所涉及的步骤。</p>
                  <p><a href="oci-object-relational-programming.html#GUID-E7064985-9564-42EA-B4F7-1604088BF15F__BGBCJDIH">图19-1</a>显示了应用程序如何使用对象的简单程序逻辑流程。为简单起见，省略了一些必需的步骤。以下各节将讨论此图中的每个步骤。
                  </p>
                  <div class="figure" id="GUID-E7064985-9564-42EA-B4F7-1604088BF15F__BGBCJDIH">
                     <p class="titleinfigure">图19-1基本对象操作流程</p><img src="img/lnoci035.gif" alt="下面是图19-1的描述" title="下面是图19-1的描述" longdesc="img_text/lnoci035.html"><br><a href="img_text/lnoci035.html">“图19-1基本对象操作流程”的描述</a></div>
                  <!-- class="figure" -->
                  <div class="p">本节包括以下主题：<ul style="list-style-type:disc">
                        <li>
                           <p><a href="oci-object-relational-programming.html#GUID-E54EFD72-BB77-4F4E-ABEB-34159AE84545" title="在OCI应用程序可以使用对象类型之前，这些类型必须存在于数据库中。">关于在C应用程序中表示对象</a></p>
                        </li>
                        <li>
                           <p><a href="oci-object-relational-programming.html#GUID-C89832E1-97A6-431F-ADC6-9CBF6B1EBA4E" title="如果您的OCI应用程序要访问和操作对象，则必须为OCIEnvCreate（）调用的mode参数指定OCI_OBJECT值，这是任何OCI应用程序中的第一个OCI调用。为mode指定此值指示OCI库您的应用程序正在使用对象。">关于初始化环境和对象缓存</a></p>
                        </li>
                        <li>
                           <p><a href="oci-object-relational-programming.html#GUID-18CD42FA-2308-414F-B4FA-6AE34421A346" title="一旦OCI环境被正确初始化，应用程序就可以连接到服务器。">关于建立数据库连接</a></p>
                        </li>
                        <li>
                           <p><a href="oci-object-relational-programming.html#GUID-2214E88A-97CD-4DF8-B1FD-31EB50D01402" title="要使用对象，应用程序必须首先从服务器检索一个或多个对象。">从服务器检索对象引用</a></p>
                        </li>
                        <li>
                           <p><a href="oci-object-relational-programming.html#GUID-B9E5DDBD-19CD-4AE0-B1D3-3B85ADEAAAB1" title="固定对象会将对象实例加载到对象缓存中，并允许您访问和修改实例的属性，并在必要时跟踪该对象对其他对象的引用。">固定一个对象</a></p>
                        </li>
                        <li>
                           <p><a href="oci-object-relational-programming.html#GUID-BA775817-78E4-4C49-A3C2-C867C50509B2" title="固定对象后，OCI应用程序可以修改其属性。">操纵对象属性</a></p>
                        </li>
                        <li>
                           <p><a href="oci-object-relational-programming.html#GUID-2F9466DE-9186-495E-92EE-B7FBAA65D6B9" title="应用程序必须采取特定步骤，以确保通过标记对象进行更改然后刷新对象将写入数据库。">关于标记对象和刷新更改</a></p>
                        </li>
                        <li>
                           <p><a href="oci-object-relational-programming.html#GUID-7B0B6CF5-AD69-4FCB-9E96-CA6469601077" title="应用程序必须获取嵌入的对象实例。">获取嵌入的对象</a></p>
                        </li>
                        <li>
                           <p><a href="oci-object-relational-programming.html#GUID-3B272F98-B2B9-4D63-9081-0F15A81747CC" title="对象的元属性用作标志，可以向应用程序或对象缓存提供有关对象状态的信息。">对象元属性</a></p>
                        </li>
                        <li>
                           <p><a href="oci-object-relational-programming.html#GUID-03683C87-7758-421A-BC51-C54A5A7679F2" title="复杂对象包括其根对象及其逻辑相关对象集，每个对象基于给定深度级别被预取。">复杂对象检索</a></p>
                        </li>
                        <li>
                           <p><a href="oci-object-relational-programming.html#GUID-22733B74-F52F-4E54-8E5E-5C27FD03F5DC" title="应用程序在获取根对象时指定复杂对象。">COR预取</a></p>
                        </li>
                        <li>
                           <p><a href="oci-object-relational-programming.html#GUID-05972451-AAD6-4929-848B-DE406B82AA0F" title="如果应用程序必须操作对象图（通过对象引用相互关联），那么使用OCI接口而不是SQL接口访问对象会更有效。">OCI与对象的SQL访问</a></p>
                        </li>
                        <li>
                           <p><a href="oci-object-relational-programming.html#GUID-86097867-CFAA-428C-AE6D-B08E45220DDD" title="对象缓存中的每个对象都有一个与之关联的引脚数。">引脚数和取消固定</a></p>
                        </li>
                        <li>
                           <p><a href="oci-object-relational-programming.html#GUID-D0FD9D2E-DAE1-4468-B90A-DE19B03CB0F3" title="如果数据库表的行中的列没有值，则该列称为NULL，或者包含NULL。">NULL指示符结构</a></p>
                        </li>
                        <li>
                           <p><a href="oci-object-relational-programming.html#GUID-86418D8C-FA67-4B14-A5BC-7A075C6B4206" title="OCI应用程序可以使用OCIObjectNew（）创建任何对象。">关于创建对象</a></p>
                        </li>
                        <li>
                           <p><a href="oci-object-relational-programming.html#GUID-0C40C7DE-5268-4445-A7CB-93489FA326D4" title="使用OCIObjectFree（）释放由OCIObjectNew（）分配的内存。">关于释放和复制对象</a></p>
                        </li>
                        <li>
                           <p><a href="oci-object-relational-programming.html#GUID-438ED438-C738-4035-96A1-B2E902C308F2" title="OCI的对象扩展为应用程序提供了使用指针或引用访问对象内容的灵活性。">对象引用和类型引用</a></p>
                        </li>
                        <li>
                           <p><a href="oci-object-relational-programming.html#GUID-8173B469-7AE8-426B-AD60-A2937B417F7C" title="应用程序可以使用OCIObjectNew（）调用来创建基于对象视图的对象，或者使用基于主键的对象标识符（OID）创建对象表。">基于具有基于主键的OID的对象视图和对象表创建对象</a></p>
                        </li>
                        <li>
                           <p><a href="oci-object-relational-programming.html#GUID-3F14366D-D427-4393-A354-4EC7D6E8712F" title="就像任何其他OCI应用程序一样。">对象应用程序中的错误处理</a></p>
                        </li>
                     </ul>
                  </div>
                  <div class="infoboxnotealso" id="GUID-E7064985-9564-42EA-B4F7-1604088BF15F__GUID-434FB76B-DA29-4767-9D4F-23795DB3CD71">
                     <p class="notep1">也可以看看：</p>
                     <p><a href="oci-object-relational-programming.html#GUID-E607333E-D9E4-4F7C-BF31-4AAB18B37A7B" title="使用对象的OCI应用程序的基本结构与关系OCI应用程序的基本结构基本相同。">基本对象程序结构</a></p>
                  </div>
               </div><a id="LNOCI16787"></a><div class="props_rev_3"><a id="GUID-E54EFD72-BB77-4F4E-ABEB-34159AE84545" name="GUID-E54EFD72-BB77-4F4E-ABEB-34159AE84545"></a><h4 id="LNOCI-GUID-E54EFD72-BB77-4F4E-ABEB-34159AE84545" class="sect4"><span class="enumeration_section">19.3.1</span>关于在C应用程序中表示对象</h4>
                  <div>
                     <p>在OCI应用程序可以使用对象类型之前，这些类型必须存在于数据库中。</p>
                     <p>通常，您使用SQL DDL语句创建类型，例如<code class="codeph">CREATE</code> <code class="codeph">TYPE</code> 。</p>
                     <p>当Oracle数据库处理类型定义DDL命令时，它将类型定义存储在数据字典中作为<span class="italic">类型描述符对象</span> （TDO）。
                     </p>
                     <p>当您的应用程序从数据库中检索对象类型的实例时，它必须具有对象的客户端表示。在C程序中，对象类型的表示是结构。在OCI对象应用程序中，您还可以包括与每个对象类型结构相对应的<code class="codeph">NULL</code>指示符结构。
                     </p>
                     <p>Oracle数据库提供了一个名为Object Type Translator（OTT）的实用程序，它为您生成数据库对象类型的C结构表示。例如，假设您的数据库中的类型声明如下：</p><pre class="oac_no_warn" dir="ltr">CREATE TYPE emp_t AS OBJECT（名称VARCHAR2（30），empno NUMBER，deptno NUMBER，hiredate DATE，salary NUMBER）;</pre><p>OTT生成以下C结构和相应的<code class="codeph">NULL</code>指示符结构：</p><pre class="oac_no_warn" dir="ltr">struct emp_t {OCIString * name; OCINumber empno; OCINumber deptno; OCIDate雇用; OCINumber薪水; }; typedef struct emp_t emp_t struct emp_t_ind {OCIInd _atomic; OCIInd名称; OCIInd empno; OCIInd deptno; OCIInd雇用; OCIInd工资; }; typedef struct emp_t_ind emp_t_ind;</pre><p>结构声明中使用的变量类型是OCI对象调用使用的特殊类型。OCI函数的子集操纵这些类型的数据。这些功能将在本章后面提到。</p>
                     <p>这些结构声明自动写入头文件，其名称由OTT输入参数确定。您可以将此头文件包含在应用程序的代码文件中，以提供对对象的访问。</p>
                     <div class="infoboxnotealso" id="GUID-E54EFD72-BB77-4F4E-ABEB-34159AE84545__GUID-4EDBF7A0-E171-492F-97FB-A099DE070625">
                        <p class="notep1">也可以看看：</p>
                        <ul style="list-style-type:disc">
                           <li>
                              <p><a href="object-advanced-topics-in-oci.html#GUID-702B4236-3993-46E0-BCB6-1A2FC7E056C1" title="对象缓存是客户端内存缓冲区，为对象提供查找和内存管理支持。">对象缓存和内存管理</a> ，适用于希望使用对象缓存生成的默认结构之外的对象表示的应用程序编程人员</p>
                           </li>
                           <li>
                              <p><a href="oci-object-relational-programming.html#GUID-D0FD9D2E-DAE1-4468-B90A-DE19B03CB0F3" title="如果数据库表的行中的列没有值，则该列称为NULL，或者包含NULL。">NULL指示符结构</a></p>
                           </li>
                           <li>
                              <p><a href="using-object-type-translator-in-oci.html#GUID-3D22CA8E-BE01-492F-BA85-DDD0CD3F4890" title="本章讨论了对象类型转换器（OTT），它用于将数据库对象类型和命名集合类型映射到C结构，以便在OCI应用程序中使用。">将对象类型转换器与OCI一起使用</a>以获取有关OTT的更多信息</p>
                           </li>
                           <li>
                              <p><a href="object-relational-data-types-in-oci.html#GUID-C62AEE74-0CC5-4FAB-A91F-997F71C49C2C" title="本章描述了可由OCI数据类型映射和操作函数操作的每种数据类型的用途和结构。">OCI中的对象关系数据类型，以</a>获取有关操作OCI对象调用所使用的结构声明中使用的这些变量类型的数据的OCI函数子集的更多详细信息</p>
                           </li>
                        </ul>
                     </div>
                  </div>
               </div><a id="LNOCI16788"></a><div class="props_rev_3"><a id="GUID-C89832E1-97A6-431F-ADC6-9CBF6B1EBA4E" name="GUID-C89832E1-97A6-431F-ADC6-9CBF6B1EBA4E"></a><h4 id="LNOCI-GUID-C89832E1-97A6-431F-ADC6-9CBF6B1EBA4E" class="sect4"><span class="enumeration_section">19.3.2</span>关于初始化环境和对象缓存</h4>
                  <div>
                     <p>如果您的OCI应用程序要访问和操作对象，则必须为<code class="codeph">OCI_OBJECT</code> <code class="codeph">OCIEnvCreate()</code>调用的<code class="codeph">mode</code>参数指定<code class="codeph">OCI_OBJECT</code>值，这是任何OCI应用程序中的第一个OCI调用。为<code class="codeph">mode</code>指定此值指示OCI库您的应用程序正在使用对象。
                     </p>
                     <p>此通知具有以下重要影响：</p>
                     <ul style="list-style-type:disc">
                        <li>
                           <p>它建立了<span class="italic">对象运行时环境</span> 。
                           </p>
                        </li>
                        <li>
                           <p>它设置<span class="italic">对象缓存</span> 。
                           </p>
                        </li>
                     </ul>
                     <p>当对象加载到缓存中时，按需分配对象缓存的内存。</p>
                     <p>如果<code class="codeph">OCIEnvNlsCreate()</code> <code class="codeph">OCIEnvCreate()</code>或<code class="codeph">OCIEnvCreate()</code>的<span class="italic">mode</span>参数未设置为<code class="codeph">OCI_OBJECT</code> ，则任何使用对象相关函数的尝试都会导致错误。
                     </p>
                     <p>客户端对象缓存在程序的进程空间中分配。此缓存是已从服务器检索并可供应用程序使用的对象的内存。</p>
                     <div class="infoboxnote" id="GUID-C89832E1-97A6-431F-ADC6-9CBF6B1EBA4E__GUID-98CFFA1B-0673-4A63-8138-CB628CFA851F">
                        <p class="notep1">注意：</p>
                        <p>如果在对象模式下初始化OCI环境，则应用程序会为对象缓存分配内存，无论应用程序是否实际使用对象调用。</p>
                     </div>
                     <div class="infoboxnotealso" id="GUID-C89832E1-97A6-431F-ADC6-9CBF6B1EBA4E__GUID-952A55EB-2353-4D65-9357-F6834C1682F7">
                        <p class="notep1">也可以看看：</p>
                        <ul style="list-style-type:disc">
                           <li>
                              <p><a href="object-advanced-topics-in-oci.html#GUID-B2FBDC75-64BD-4E7E-A713-5095A827EA9C" title="This chapter introduces the OCI facility for working with objects in an Oracle Database.">OCI</a>中的<a href="object-advanced-topics-in-oci.html#GUID-B2FBDC75-64BD-4E7E-A713-5095A827EA9C" title="本章介绍用于在Oracle数据库中处理对象的OCI工具。">对象高级主题，</a>用于详细说明对象缓存</p>
                           </li>
                           <li>
                              <p><a href="connect-authorize-and-initialize-functions.html#GUID-16BDA1F1-7DAF-41CA-9EE1-C9A4CB467244" title="创建并初始化OCI函数的环境句柄。">OCIEnvCreate（）</a></p>
                           </li>
                           <li>
                              <p><a href="connect-authorize-and-initialize-functions.html#GUID-0B6911A9-4B46-476C-BC5E-B87581666CD9" title="创建并初始化OCI函数的环境句柄。">OCIEnvNlsCreate（）</a></p>
                           </li>
                        </ul>
                        <p></p>
                     </div>
                  </div>
               </div><a id="LNOCI16789"></a><div class="props_rev_3"><a id="GUID-18CD42FA-2308-414F-B4FA-6AE34421A346" name="GUID-18CD42FA-2308-414F-B4FA-6AE34421A346"></a><h4 id="LNOCI-GUID-18CD42FA-2308-414F-B4FA-6AE34421A346" class="sect4"><span class="enumeration_section">19.3.3</span>关于建立数据库连接</h4>
                  <div>
                     <p>一旦OCI环境被正确初始化，应用程序就可以连接到服务器。</p>
                     <p>这是通过标准OCI连接调用完成的。使用这些调用时，不必另外考虑因为此应用程序正在访问对象。</p>
                     <p>每个OCI环境只分配一个对象缓存。通过环境中的不同连接检索或创建的所有对象使用相同的物理对象缓存。每个连接都有自己的逻辑对象缓存。</p>
                     <div class="infoboxnotealso" id="GUID-18CD42FA-2308-414F-B4FA-6AE34421A346__GUID-FC5A0329-545E-4D40-975B-75024032D31F">
                        <p class="notep1">也可以看看：</p>
                        <p><a href="oci-programming-basics.html#GUID-BD1CD486-6EA8-4C23-828F-DD1115317E5B" title="以下部分详细描述了开发OCI应用程序的每个步骤。">OCI编程步骤</a>有关正确初始化OCI环境的更多信息</p>
                     </div>
                  </div>
               </div><a id="LNOCI16790"></a><div class="props_rev_3"><a id="GUID-2214E88A-97CD-4DF8-B1FD-31EB50D01402" name="GUID-2214E88A-97CD-4DF8-B1FD-31EB50D01402"></a><h4 id="LNOCI-GUID-2214E88A-97CD-4DF8-B1FD-31EB50D01402" class="sect4"><span class="enumeration_section">19.3.4</span>从服务器检索对象引用</h4>
                  <div>
                     <p>要使用对象，应用程序必须首先从服务器检索一个或多个对象。</p>
                     <div class="section">
                        <p>您可以通过发出一个将<code class="codeph">REF</code>返回给一个或多个对象的SQL语句来实现此目的。
                        </p>
                        <div class="infoboxnote" id="GUID-2214E88A-97CD-4DF8-B1FD-31EB50D01402__GUID-0A56A030-5510-4EA8-B196-7461F13BB239">
                           <p class="notep1">注意：</p>
                           <p>SQL语句也可以从数据库中获取嵌入对象而不是<code class="codeph">REF</code> 。
                           </p>
                        </div>
                        <p>在以下示例中，应用程序声明一个文本块，该文本块存储一个SQL语句，该语句旨在从数据库中的employees（ <code class="codeph">emp_tab</code> ）对象表中检索<code class="codeph">REF</code>到单个employee对象，当给定一个特定的员工编号作为运行时输入变量（ <code class="codeph">:emp_num</code> ）：</p><pre class="oac_no_warn" dir="ltr">text * selemp =（text *）“SELECT REF（e）FROM emp_tab e WHERE empno =：emp_num”;</pre><p>您的应用程序应按照与处理任何关系SQL语句相同的方式准备和处理此语句：</p>
                     </div>
                     <!-- class="section" -->
                     <ol>
                        <li class="stepexpand"><span>使用<code class="codeph">OCIStmtPrepare2()</code>准备应用程序请求。</span></li>
                        <li class="stepexpand"><span>使用一个或多个适当的绑定调用绑定主机输入变量。</span></li>
                        <li class="stepexpand"><span>声明并准备输出变量以接收员工对象引用。在这里，您将使用员工对象引用：</span><div><pre class="oac_no_warn" dir="ltr">OCIRef * emp1_ref =（OCIRef *）0; / *对员工对象的引用* /</pre><p>定义输出变量时，将define调用的<span class="italic">dty</span>数据类型参数设置为SQLT_REF，即<code class="codeph">REF</code>的数据类型常量。</p>
                           </div>
                        </li>
                        <li class="stepexpand"><span>使用<code class="codeph">OCUStmtExecute()</code>执行语句。</span></li>
                        <li class="stepexpand"><span>使用<code class="codeph">OCIStmtFetch2()</code>将生成的<code class="codeph">REF</code>提取到<code class="codeph">emp1_ref</code> 。</span></li>
                     </ol>
                     <div class="section">
                        <p>此时，您可以使用对象引用来访问和操作数据库中的一个或多个对象。</p>
                        <div class="infoboxnotealso" id="GUID-2214E88A-97CD-4DF8-B1FD-31EB50D01402__GUID-13109BA7-9FEB-47F4-818E-5029AAF5C282">
                           <p class="notep1">也可以看看：</p>
                           <ul style="list-style-type:disc">
                              <li>
                                 <p><a href="oci-object-relational-programming.html#GUID-7B0B6CF5-AD69-4FCB-9E96-CA6469601077" title="An application must fetch embedded object instances.">获取嵌入式对象</a>以<a href="oci-object-relational-programming.html#GUID-7B0B6CF5-AD69-4FCB-9E96-CA6469601077" title="应用程序必须获取嵌入的对象实例。">获取</a>更多信息</p>
                              </li>
                              <li>
                                 <p><a href="oci-programming-basics.html#GUID-4CFB8AF7-EF05-4E0F-847F-2D0710E552C5" title="本章介绍了使用OCI进行编程所涉及的概念和过程。">OCI编程基础</a></p>
                              </li>
                              <li>
                                 <p><a href="oci-programming-basics.html#GUID-BD1CD486-6EA8-4C23-828F-DD1115317E5B" title="以下部分详细描述了开发OCI应用程序的每个步骤。">OCI编程步骤</a> ，了解有关准备和执行SQL语句的一般信息</p>
                              </li>
                              <li>
                                 <p><a href="binding-and-defining-in-oci.html#GUID-EE9AD90D-8CFD-4380-9D5E-819555EB3A8E" title="更高级的绑定操作包括多步骤绑定，以及命名数据类型和REF的绑定。">OCI中的高级绑定操作和OCI中的</a> <a href="binding-and-defining-in-oci.html#GUID-237FC150-290A-42B8-99CB-2C6AFA5B9F9E" title="本节介绍高级定义操作，包括命名数据类型和REF的多步定义和定义。">高级定义操作，</a>用于有关绑定和定义<code class="codeph">REF</code>变量的特定信息</p>
                              </li>
                              <li>
                                 <p>Oracle安装中包含的演示程序，用于显示<code class="codeph">REF</code>检索和固定的代码示例。有关其他信息，请参阅<a href="oci-demo-programs.html#GUID-75E18629-0C54-4495-A747-AFB346034F26" title="列出示例程序，其中包含示例代码，用于演示OCI句柄的分配和使用。">OCI演示程序</a> 。
                                 </p>
                              </li>
                              <li>
                                 <p><a href="statement-functions.html#GUID-E6C1DC67-D464-4D2A-9F19-737423D31779" title="准备SQL或PL / SQL语句以便执行。">OCIStmtPrepare2（）</a></p>
                              </li>
                              <li>
                                 <p><a href="oci-object-relational-programming.html#GUID-E54EFD72-BB77-4F4E-ABEB-34159AE84545" title="在OCI应用程序可以使用对象类型之前，这些类型必须存在于数据库中。">关于在C应用程序中表示对象</a>关于使用步骤3中提到的员工对象引用声明</p>
                              </li>
                              <li>
                                 <p><a href="statement-functions.html#GUID-98B26708-3E02-45C0-8258-5D5544F32BE9" title="将应用程序请求与服务器关联。">OCIStmtExecute（）</a></p>
                              </li>
                              <li>
                                 <p><a href="statement-functions.html#GUID-DF585B90-58BA-45FC-B7CE-6F7F987C03B9" title="从（可滚动）结果集中获取一行。">OCIStmtFetch2（）</a></p>
                              </li>
                           </ul>
                        </div>
                     </div>
                     <!-- class="section" -->
                  </div>
               </div><a id="LNOCI72702"></a><a id="LNOCI16791"></a><div class="props_rev_3"><a id="GUID-B9E5DDBD-19CD-4AE0-B1D3-3B85ADEAAAB1" name="GUID-B9E5DDBD-19CD-4AE0-B1D3-3B85ADEAAAB1"></a><h4 id="LNOCI-GUID-B9E5DDBD-19CD-4AE0-B1D3-3B85ADEAAAB1" class="sect4"><span class="enumeration_section">19.3.5</span>固定对象</h4>
                  <div>
                     <p>固定对象会将对象实例加载到对象缓存中，并允许您访问和修改实例的属性，并在必要时跟踪该对象对其他对象的引用。</p>
                     <div class="section">
                        <p>完成获取步骤后，您的应用程序将具有对象的<code class="codeph">REF</code>或指针。目前无法使用实际对象。在操作对象之前，必须将其<span class="italic">固定</span> 。您的应用程序还控制何时将修改后的对象写回服务器。
                        </p>
                        <div class="infoboxnote" id="GUID-B9E5DDBD-19CD-4AE0-B1D3-3B85ADEAAAB1__GUID-7CDAF232-6676-423E-AEBD-5250FC6640B4">
                           <p class="notep1">注意：</p>
                           <p>本节介绍一次涉及单个对象的简单引脚操作。有关通过复杂对象检索检索多个对象的信息，请参阅<a href="oci-object-relational-programming.html#GUID-03683C87-7758-421A-BC51-C54A5A7679F2" title="复杂对象包括其根对象及其逻辑相关对象集，每个对象基于给定深度级别被预取。">复杂对象检索</a> 。
                           </p>
                        </div>
                        <p>应用程序通过调用函数<code class="codeph">OCIObjectPin()</code> 。此功能的参数允许您指定对象的<span class="italic">引脚选项，引脚持续时间</span>和<span class="italic">锁定选项</span> 。
                        </p>
                        <p><a href="oci-object-relational-programming.html#GUID-B9E5DDBD-19CD-4AE0-B1D3-3B85ADEAAAB1__BGBDEJIB">示例19-3</a>显示了示例代码，该代码说明了在上一节“ <a href="oci-object-relational-programming.html#GUID-2214E88A-97CD-4DF8-B1FD-31EB50D01402" title="要使用对象，应用程序必须首先从服务器检索一个或多个对象。">从服务器检索对象引用”中</a>检索到的应用程序的员工引用的引脚操作。
                        </p>
                        <p>在此示例中， <code class="codeph">process_error()</code>表示错误处理函数。如果对<code class="codeph">OCIObjectPin()</code>的调用返回除<code class="codeph">OCI_SUCCESS</code>任何<code class="codeph">OCI_SUCCESS</code> ，则调用错误处理函数。<code class="codeph">OCIObjectPin()</code>函数的参数如下：</p>
                     </div>
                     <!-- class="section" -->
                     <div class="section">
                        <ul style="list-style-type:disc">
                           <li>
                              <p><code class="codeph">env</code>是OCI环境句柄。
                              </p>
                           </li>
                           <li>
                              <p><code class="codeph">err</code>是OCI错误句柄。
                              </p>
                           </li>
                           <li>
                              <p><code class="codeph">emp1_ref</code>是通过SQL检索的引用。</p>
                           </li>
                           <li>
                              <p><code class="codeph">(OCIComplexObject *) 0</code>表示此引脚操作未使用复杂对象检索。
                              </p>
                           </li>
                           <li>
                              <p><code class="codeph">OCI_PIN_ANY</code>是引脚选项。
                              </p>
                           </li>
                           <li>
                              <p><code class="codeph">OCI_DURATION_TRANS</code>是引脚持续时间。
                              </p>
                           </li>
                           <li>
                              <p><code class="codeph">OCI_LOCK_X</code>是锁定选项。
                              </p>
                           </li>
                           <li>
                              <p><code class="codeph">emp1</code>是一个out参数，它返回一个指向固定对象的指针。
                              </p>
                           </li>
                        </ul>
                        <p>现在该对象已被固定，OCI应用程序可以修改该对象。在这个简单的示例中，该对象不包含对其他对象的引用。</p>
                        <p>本节包括以下主题： <a href="oci-object-relational-programming.html#GUID-1764A2BB-D228-4253-B953-57AEE9A53B30" title="给定一组引用，OCI应用程序可以通过调用OCIObjectArrayPin（）来固定一个对象数组。">数组引脚</a> 。
                        </p>
                     </div>
                     <!-- class="section" -->
                     <div class="example" id="GUID-B9E5DDBD-19CD-4AE0-B1D3-3B85ADEAAAB1__BGBDEJIB">
                        <p class="titleinexample">示例19-3固定对象</p><pre class="oac_no_warn" dir="ltr">if（OCIObjectPin（env，err，emp1_ref，（OCIComplexObject *）0，OCI_PIN_ANY，OCI_DURATION_TRANS，OCI_LOCK_X和emp1）！= OCI_SUCCESS）process_error（错误）;</pre></div>
                     <!-- class="example" -->
                     <div class="section">
                        <div class="infoboxnotealso" id="GUID-B9E5DDBD-19CD-4AE0-B1D3-3B85ADEAAAB1__GUID-61D72747-64B9-4769-B6BB-86C4163FEAD0">
                           <p class="notep1">也可以看看：</p>
                           <ul style="list-style-type:disc">
                              <li>
                                 <p><a href="object-advanced-topics-in-oci.html#GUID-2BF8105C-419E-4560-B241-BFCC1CCB719D" title="如果应用程序检索具有属于另一个对象的REF属性的对象，则应用程序可以使用OCI调用遍历对象图并访问引用的实例。">简单对象导航，</a>用于从一个实例导航到另一个实例的示例</p>
                              </li>
                              <li>
                                 <p><a href="oci-pin-unpin-and-free-functions.html#GUID-89F29585-2F16-4FA3-B1E0-BDD83707CA62" title="引脚可引用对象。">OCIObjectPin（）</a></p>
                              </li>
                              <li>
                                 <p><a href="object-advanced-topics-in-oci.html#GUID-99819CA5-F2A7-4BFE-A9E4-5BD76C573CB2">关于固定对象复制</a>以获取有关引脚选项<code class="codeph">OCI_PIN_ANY</code>更多信息</p>
                              </li>
                              <li>
                                 <p><a href="object-advanced-topics-in-oci.html#GUID-639E852E-0AA3-414F-A5A3-598C8F2047E1" title="为了保持内存中的可用空间，对象缓存尝试尽可能重用对象的内存。当对象的生命周期（分配持续时间）到期或对象的引脚持续时间到期时，对象缓存会重用对象的内存。">对象持续时间</a>有关引脚持续时间<code class="codeph">OCI_DURATION_TRANS</code>更多信息</p>
                              </li>
                              <li>
                                 <p><a href="object-advanced-topics-in-oci.html#GUID-16790CA7-71A9-4D8F-86DE-49E122AC156A" title="程序可以选择调用OCIObjectLock（）来锁定对象以进行更新。">关于锁定对象以进行更新</a>以获取有关锁定选项<code class="codeph">OCI_LOCK_X</code>更多信息</p>
                              </li>
                           </ul>
                           <p></p>
                        </div>
                     </div>
                     <!-- class="section" -->
                  </div><a id="LNOCI16792"></a><div class="props_rev_3"><a id="GUID-1764A2BB-D228-4253-B953-57AEE9A53B30" name="GUID-1764A2BB-D228-4253-B953-57AEE9A53B30"></a><h5 id="LNOCI-GUID-1764A2BB-D228-4253-B953-57AEE9A53B30" class="sect5"><span class="enumeration_section">19.3.5.1</span>阵列引脚</h5>
                     <div>
                        <p>给定一组引用，OCI应用程序可以通过调用<code class="codeph">OCIObjectArrayPin()</code>来固定一个对象数组。
                        </p>
                        <p>引用可以指向不同类型的对象。此功能提供从一个网络往返中的不同表中获取不同类型的对象的功能。</p>
                        <div class="infoboxnotealso" id="GUID-1764A2BB-D228-4253-B953-57AEE9A53B30__GUID-EB786286-52DA-4A22-B54C-01875CB687DD">
                           <p class="notep1">也可以看看：</p>
                           <p><a href="oci-pin-unpin-and-free-functions.html#GUID-2629C6C3-5299-4E92-BA58-804809CFF8B9" title="引入一系列引用。">OCIObjectArrayPin（）</a></p>
                        </div>
                     </div>
                  </div>
               </div><a id="LNOCI72703"></a><a id="LNOCI16793"></a><div class="props_rev_3"><a id="GUID-BA775817-78E4-4C49-A3C2-C867C50509B2" name="GUID-BA775817-78E4-4C49-A3C2-C867C50509B2"></a><h4 id="LNOCI-GUID-BA775817-78E4-4C49-A3C2-C867C50509B2" class="sect4"><span class="enumeration_section">19.3.6</span>操作对象属性</h4>
                  <div>
                     <p>固定对象后，OCI应用程序可以修改其属性。</p>
                     <div class="section">
                        <p>OCI提供了一组用于处理对象类型结构的数据类型的函数，称为OCI <span class="italic">数据类型映射和操作函数</span> 。
                        </p>
                        <div class="infoboxnote" id="GUID-BA775817-78E4-4C49-A3C2-C867C50509B2__GUID-A3D3502E-F269-4EA9-9587-B0F22B4173D3">
                           <p class="notep1">注意：</p>
                           <p>对固定在对象缓存中的对象所做的更改仅影响那些对象副本（实例）， <span class="italic">而不影响</span>数据库中的原始对象。对于应用程序对数据库所做的更改，必须将这些更改刷新或提交给服务器。
                           </p>
                        </div>
                        <p>例如，假设上一节中的员工对象已固定，以便可以增加员工的工资。还假设在该公司，对于在公司工作不到180天的员工按比例分摊年薪。</p>
                        <p>对于此示例，您必须访问员工的雇用日期，并检查它是否在当前日期之前的180天或更多。根据该计算，员工的工资增加5000美元（超过180天）或3000美元（少于180天）。<a href="oci-object-relational-programming.html#GUID-BA775817-78E4-4C49-A3C2-C867C50509B2__BGBBCFBA">例19-4中</a>的示例代码演示了此过程。
                        </p>
                        <p>请注意，数据类型映射和操作函数适用于一组特定的数据类型;在计算中使用它们之前，必须将其他类型（如<code class="codeph">int</code> ）转换为适当的OCI类型。
                        </p>
                        <p><a href="oci-object-relational-programming.html#GUID-BA775817-78E4-4C49-A3C2-C867C50509B2__BGBBCFBA">例19-4</a>指出在将值作为参数传递给OCI数据类型映射和操作函数之前，必须如何将值转换为OCI数据类型（例如， <code class="codeph">OCIDate</code> ， <code class="codeph">OCINumber</code> ）。
                        </p>
                     </div>
                     <!-- class="section" -->
                     <div class="example" id="GUID-BA775817-78E4-4C49-A3C2-C867C50509B2__BGBBCFBA">
                        <p class="titleinexample">示例19-4在OCI中操作对象属性</p><pre class="oac_no_warn" dir="ltr">/ *假设已将sysdate提取到sys_date中，这是一个字符串。* / / * emp1和emp1_ref与前面部分相同。* / / *错误是OCI错误句柄。* / / *注意：此示例中不包含错误处理代码。* / sb4 num_days; / *今天和hiredate之间的天数* / OCIDate curr_date; / *保存计算的当前日期* / int raise; / *在计算前保留员工的加薪金额* / OCINumber raise_num; / *持有员工加薪计算* / OCINumber new_sal; / *将员工的新工资* / / *转换日期字符串保存为OCIDate * / OCIDateFromText（错误，（text *）sys_date，（ub4）strlen（sys_date），（text *）NULL，（ub1）0，（text *）NULL，（ub4）0，＆curr_date）; / *获取雇用日期和今天之间的天数* / OCIDateDaysBetween（错误，＆curr_date，＆emp1-&gt; hiredate，＆num_days）; / *根据hiredate * / if（num_days&gt; 180）raise = 5000后的天数计算加薪; else raise = 3000; / *将上升值转换为OCINumber * / OCINumberFromInt（错误，（void *）＆raise，（uword）sizeof（raise），OCI_NUMBER_SIGNED和raise_num）; / *将加薪金额加到工资* / OCINumberAdd（错误，＆raise_num，＆emp1-&gt;薪水，＆new_sal）; OCINumberAssign（错误，＆new_sal，＆emp1-&gt;薪水）;</pre></div>
                     <!-- class="example" -->
                     <div class="section">
                        <div class="infoboxnotealso" id="GUID-BA775817-78E4-4C49-A3C2-C867C50509B2__GUID-B19B68AA-2040-4B22-B6D0-4E36458D8E9F">
                           <p class="notep1">也可以看看：</p>
                           <ul style="list-style-type:disc">
                              <li>
                                 <p><a href="oci-object-relational-programming.html#GUID-2F9466DE-9186-495E-92EE-B7FBAA65D6B9" title="应用程序必须采取特定步骤，以确保通过标记对象进行更改然后刷新对象将写入数据库。">关于标记对象和</a>刷新更改有关刷新更改或将更改提交到服务器的更多信息</p>
                              </li>
                              <li>
                                 <p><a href="object-relational-data-types-in-oci.html#GUID-C62AEE74-0CC5-4FAB-A91F-997F71C49C2C" title="本章描述了可由OCI数据类型映射和操作函数操作的每种数据类型的用途和结构。">OCI中的对象关系数据类型，</a>用于有关OCI数据类型以及数据类型映射和操作函数的更多信息</p>
                              </li>
                           </ul>
                        </div>
                     </div>
                     <!-- class="section" -->
                  </div>
               </div><a id="LNOCI16794"></a><div class="props_rev_3"><a id="GUID-2F9466DE-9186-495E-92EE-B7FBAA65D6B9" name="GUID-2F9466DE-9186-495E-92EE-B7FBAA65D6B9"></a><h4 id="LNOCI-GUID-2F9466DE-9186-495E-92EE-B7FBAA65D6B9" class="sect4"><span class="enumeration_section">19.3.7</span>关于标记对象和<span class="enumeration_section">刷新</span>更改</h4>
                  <div>
                     <p>应用程序必须采取特定步骤，以确保通过标记对象进行更改然后刷新对象将写入数据库。</p>
                     <p>在<a href="oci-object-relational-programming.html#GUID-BA775817-78E4-4C49-A3C2-C867C50509B2__BGBBCFBA">例19-4中</a> ，改变了对象实例的属性。但是，此时，该更改仅存在于客户端对象缓存中。应用程序必须采取特定步骤以确保将更改写入数据库。
                     </p>
                     <p>第一步是指示对象已被修改。这是通过<code class="codeph">OCIObjectMarkUpdate()</code>函数完成的。此函数将对象标记为<span class="italic">脏</span> （已修改）。
                     </p>
                     <p>必须将已设置脏标志的对象刷新到服务器，以便将更改记录在数据库中。您可以通过三种方式执行此操作：</p>
                     <ul style="list-style-type:disc">
                        <li>
                           <p>通过调用<code class="codeph">OCIObjectFlush()</code>刷新单个脏对象。
                           </p>
                        </li>
                        <li>
                           <p>使用<code class="codeph">OCICacheFlush()</code>刷新整个缓存。在这种情况下，OCI遍历由缓存维护的脏列表，并将脏对象刷新到服务器。
                           </p>
                        </li>
                        <li>
                           <p>调用<code class="codeph">OCICacheFlush()</code>来提交事务。这样做还会遍历脏列表并将脏对象刷新到服务器。
                           </p>
                        </li>
                     </ul>
                     <p>刷新操作仅适用于缓存中的持久对象。瞬态对象永远不会刷新到服务器。</p>
                     <p>将对象刷新到服务器可以激活数据库中的触发器。实际上，在某些情况下，应用程序可能希望显式刷新对象，以便在服务器端触发触发器。</p>
                     <div class="infoboxnotealso" id="GUID-2F9466DE-9186-495E-92EE-B7FBAA65D6B9__GUID-2F6917DF-F6D6-434C-A5DC-3872C06FB4CD">
                        <p class="notep1">也可以看看：</p>
                        <ul style="list-style-type:disc">
                           <li>
                              <p>有关<code class="codeph">OCITransCommit()</code>更多信息， <a href="managing-scalable-platforms.html#GUID-3E96017A-64D3-4A29-B617-C9879610B5F2" title="OCI有一组API调用来支持本地和全局事务的操作。">OCI支持交易</a></p>
                           </li>
                           <li>
                              <p><a href="oci-object-relational-programming.html#GUID-86418D8C-FA67-4B14-A5BC-7A075C6B4206" title="OCI应用程序可以使用OCIObjectNew（）创建任何对象。">关于创建对象</a>以获取有关瞬态和持久对象的信息</p>
                           </li>
                           <li>
                              <p><a href="oci-object-relational-programming.html#GUID-3B272F98-B2B9-4D63-9081-0F15A81747CC" title="对象的元属性用作标志，可以向应用程序或对象缓存提供有关对象状态的信息。">对象元属性，</a>用于查看和检查对象元属性（如<span class="italic">脏）的信息</span> 
                              </p>
                           </li>
                           <li>
                              <p><a href="oci-mark-or-unmark-object-cache-functions.html#GUID-6EEEC8CC-3041-4718-ADE7-20C6D8C661ED" title="将持久对象标记为已更新（脏）。">OCIObjectMarkUpdate（）</a></p>
                           </li>
                           <li>
                              <p><a href="oci-flush-or-refresh-functions.html#GUID-03A4BAE9-3484-4D04-8A11-5EC410FEB301" title="将修改后的持久对象刷新到服务器。">OCIObjectFlush（）</a></p>
                           </li>
                           <li>
                              <p><a href="oci-flush-or-refresh-functions.html#GUID-782180CB-D33E-42E0-AB4C-96ECDF651C1E" title="将已修改的持久对象刷新到服务器。">OCICacheFlush（）</a></p>
                           </li>
                           <li>
                              <p><a href="transaction-functions.html#GUID-DDAE3122-8769-4A30-8D78-EB2A3CCF77D4" title="提交与指定服务上下文关联的事务。">OCICacheFlush（）</a></p>
                           </li>
                        </ul>
                     </div>
                  </div>
               </div><a id="LNOCI16795"></a><div class="props_rev_3"><a id="GUID-7B0B6CF5-AD69-4FCB-9E96-CA6469601077" name="GUID-7B0B6CF5-AD69-4FCB-9E96-CA6469601077"></a><h4 id="LNOCI-GUID-7B0B6CF5-AD69-4FCB-9E96-CA6469601077" class="sect4"><span class="enumeration_section">19.3.8</span>获取嵌入的对象</h4>
                  <div>
                     <p>应用程序必须获取嵌入的对象实例。</p>
                     <div class="section">
                        <p>如果您的应用程序必须获取嵌入对象实例 - 存储在常规表的列中的对象而不是对象表 - 您不能使用<a href="oci-object-relational-programming.html#GUID-2214E88A-97CD-4DF8-B1FD-31EB50D01402" title="要使用对象，应用程序必须首先从服务器检索一个或多个对象。">从服务器检索对象引用中</a>描述的<code class="codeph">REF</code>检索机制。嵌入式实例没有对象标识符，因此无法为它们获取<code class="codeph">REF</code> ;它们不能作为对象导航的基础。但是，存在许多情况，其中应用程序必须获取嵌入的实例。
                        </p>
                        <p>例如，假设已创建<code class="codeph">address</code>类型。
                        </p><pre class="oac_no_warn" dir="ltr">CREATE TYPE地址AS OBJECT（street1 varchar2（50），street2 varchar2（50），city varchar2（30），state char（2），zip number（5））;</pre><p>然后，您可以将该类型用作另一个表中列的数据类型：</p><pre class="oac_no_warn" dir="ltr">CREATE TABLE客户端（名称varchar2（40），addr地址）;</pre><p>然后，您的OCI应用程序可以发出以下SQL语句：</p><pre class="oac_no_warn" dir="ltr">SELECT addr FROM clients WHERE name ='BEAR BYTE DATA MANAGEMENT'</pre><p>此语句将从<code class="codeph">clients</code>表返回一个嵌入的<code class="codeph">address</code>对象。然后，应用程序可以使用此对象的属性中的值进行其他处理。
                        </p>
                        <p>您的应用程序应该以与处理任何关系SQL语句相同的方式准备和处理此语句，如<a href="oci-programming-basics.html#GUID-4CFB8AF7-EF05-4E0F-847F-2D0710E552C5" title="本章介绍了使用OCI进行编程所涉及的概念和过程。">OCI编程基础知识中所述</a> ：</p>
                     </div>
                     <!-- class="section" -->
                     <div class="section">
                        <ul style="list-style-type:disc">
                           <li>
                              <p>使用<code class="codeph">OCIStmtPrepare2()</code>准备应用程序请求。
                              </p>
                           </li>
                           <li>
                              <p>使用一个或多个适当的绑定调用绑定输入变量。</p>
                           </li>
                           <li>
                              <p>定义输出变量以接收<code class="codeph">address</code>实例。您使用由OTT生成的对象类型的C结构表示，如<a href="oci-object-relational-programming.html#GUID-E54EFD72-BB77-4F4E-ABEB-34159AE84545" title="在OCI应用程序可以使用对象类型之前，这些类型必须存在于数据库中。">关于在C应用程序中表示对象中</a>所述。
                              </p><pre class="oac_no_warn" dir="ltr">addr1 *地址; / *地址结构类型的变量* /</pre><p>定义输出变量时，将define调用的<code class="codeph">dty</code>数据类型参数设置为SQLT_NTY，即命名数据类型的数据类型常量。
                              </p>
                           </li>
                           <li>
                              <p>使用<code class="codeph">OCIStmtExecute()</code>执行语句。
                              </p>
                           </li>
                           <li>
                              <p>使用<code class="codeph">OCIStmtFetch2()</code>将生成的实例提取到<code class="codeph">addr1</code> 。
                              </p>
                           </li>
                        </ul>
                        <p>执行此操作后，您可以访问实例的属性，如<a href="oci-object-relational-programming.html#GUID-BA775817-78E4-4C49-A3C2-C867C50509B2" title="固定对象后，OCI应用程序可以修改其属性。">操作对象属性中所述</a> ，或将实例作为另一个SQL语句的输入参数传递。
                        </p>
                        <div class="infoboxnote" id="GUID-7B0B6CF5-AD69-4FCB-9E96-CA6469601077__GUID-D996BB9F-3EF5-4EB2-BA09-1A5D41144C9B">
                           <p class="notep1">注意：</p>
                           <p>只有通过执行SQL <code class="codeph">UPDATE</code>语句，才能使对嵌入式实例所做的更改保持<code class="codeph">UPDATE</code> 。
                           </p>
                        </div>
                        <div class="infoboxnotealso" id="GUID-7B0B6CF5-AD69-4FCB-9E96-CA6469601077__GUID-0FD6578D-0D43-410B-A115-675B369C65EC">
                           <p class="notep1">也可以看看：</p>
                           <ul style="list-style-type:disc">
                              <li>
                                 <p><a href="oci-programming-basics.html#GUID-BD1CD486-6EA8-4C23-828F-DD1115317E5B" title="以下部分详细描述了开发OCI应用程序的每个步骤。">OCI编程步骤</a> ，以获取有关准备和执行SQL语句的更多信息</p>
                              </li>
                              <li>
                                 <p><a href="statement-functions.html#GUID-E6C1DC67-D464-4D2A-9F19-737423D31779" title="准备SQL或PL / SQL语句以便执行。">OCIStmtPrepare2（）</a></p>
                              </li>
                              <li>
                                 <p><a href="statement-functions.html#GUID-98B26708-3E02-45C0-8258-5D5544F32BE9" title="将应用程序请求与服务器关联。">OCIStmtExecute（）</a></p>
                              </li>
                              <li>
                                 <p><a href="statement-functions.html#GUID-DF585B90-58BA-45FC-B7CE-6F7F987C03B9" title="从（可滚动）结果集中获取一行。">OCIStmtFetch2（）</a></p>
                              </li>
                           </ul>
                           <p></p>
                        </div>
                     </div>
                     <!-- class="section" -->
                  </div>
               </div><a id="LNOCI16796"></a><div class="props_rev_3"><a id="GUID-3B272F98-B2B9-4D63-9081-0F15A81747CC" name="GUID-3B272F98-B2B9-4D63-9081-0F15A81747CC"></a><h4 id="LNOCI-GUID-3B272F98-B2B9-4D63-9081-0F15A81747CC" class="sect4"><span class="enumeration_section">19.3.9</span>对象元属性</h4>
                  <div>
                     <p>对象的<span class="italic">元属性</span>用作标志，可以向应用程序或对象缓存提供有关对象状态的信息。
                     </p>
                     <p>例如，对象的一个元属性指示它是否已刷新到服务器。对象元属性可以帮助应用程序控制实例的行为。</p>
                     <p>持久和瞬态对象实例具有不同的元属性集。持久对象的元属性进一步细分为<span class="italic">持久元属性</span>和<span class="italic">瞬态元属性</span> 。仅当实例在内存中时才存在瞬态元属性。持久元属性也适用于存储在服务器中的对象。
                     </p>
                     <div class="p">本节包括以下主题：<ul style="list-style-type:disc">
                           <li>
                              <p><a href="oci-object-relational-programming.html#GUID-67E39885-2DEC-422A-907F-5E63AE84530A" title="列出并描述独立持久对象的元属性。">持久对象元属性</a></p>
                           </li>
                           <li>
                              <p><a href="oci-object-relational-programming.html#GUID-B5732CDF-2D02-404E-A1A0-CF8A082AFE71" title="列出并描述称为set和check函数的其他属性函数。">附加属性功能</a></p>
                           </li>
                           <li>
                              <p><a href="oci-object-relational-programming.html#GUID-2220F791-09A6-46EB-AF24-4D65F53E04FB" title="列出并描述瞬态对象元属性。">瞬态对象元属性</a></p>
                           </li>
                        </ul>
                     </div>
                  </div><a id="LNOCI16798"></a><a id="LNOCI16797"></a><div class="props_rev_3"><a id="GUID-67E39885-2DEC-422A-907F-5E63AE84530A" name="GUID-67E39885-2DEC-422A-907F-5E63AE84530A"></a><h5 id="LNOCI-GUID-67E39885-2DEC-422A-907F-5E63AE84530A" class="sect5"><span class="enumeration_section">19.3.9.1</span>持久对象元属性</h5>
                     <div>
                        <p>列出并描述<span class="italic">独立</span>持久对象的元属性。
                        </p>
                        <p><a href="oci-object-relational-programming.html#GUID-67E39885-2DEC-422A-907F-5E63AE84530A__BGBHDIIB" title="该表有2列。第1列是元属性的名称，第2列是其含义。">表19-1</a>显示了<span class="italic">独立</span>持久对象的元属性。
                        </p>
                        <div class="tblformal" id="GUID-67E39885-2DEC-422A-907F-5E63AE84530A__BGBHDIIB">
                           <p class="titleintable">表19-1持久对象的元属性</p>
                           <table cellpadding="4" cellspacing="0" class="Formal" title="持久对象的元属性" width="100%" border="1" summary="This table has 2 columns. Column 1 is the name of the meta-attribute and column 2 is its meaning." frame="hsides" rules="rows">
                              <thead>
                                 <tr align="left" valign="top">
                                    <th align="left" valign="bottom" width="37%" id="d136732e5495">元属性</th>
                                    <th align="left" valign="bottom" width="63%" id="d136732e5498">含义</th>
                                 </tr>
                              </thead>
                              <tbody>
                                 <tr align="left" valign="top">
                                    <td align="left" valign="top" width="37%" id="d136732e5503" headers="d136732e5495 ">
                                       <p>存在</p>
                                    </td>
                                    <td align="left" valign="top" width="63%" headers="d136732e5503 d136732e5498 ">
                                       <p>对象存在吗？</p>
                                    </td>
                                 </tr>
                                 <tr align="left" valign="top">
                                    <td align="left" valign="top" width="37%" id="d136732e5510" headers="d136732e5495 ">
                                       <p>无效</p>
                                    </td>
                                    <td align="left" valign="top" width="63%" headers="d136732e5510 d136732e5498 ">
                                       <p>实例的空信息</p>
                                    </td>
                                 </tr>
                                 <tr align="left" valign="top">
                                    <td align="left" valign="top" width="37%" id="d136732e5517" headers="d136732e5495 ">
                                       <p>锁定</p>
                                    </td>
                                    <td align="left" valign="top" width="63%" headers="d136732e5517 d136732e5498 ">
                                       <p>物体被锁定了吗？</p>
                                    </td>
                                 </tr>
                                 <tr align="left" valign="top">
                                    <td align="left" valign="top" width="37%" id="d136732e5524" headers="d136732e5495 ">
                                       <p>脏</p>
                                    </td>
                                    <td align="left" valign="top" width="63%" headers="d136732e5524 d136732e5498 ">
                                       <p>物体是否被标记为<span class="italic">脏污？</span></p>
                                    </td>
                                 </tr>
                                 <tr align="left" valign="top">
                                    <td align="left" valign="top" width="37%" id="d136732e5533" headers="d136732e5495 ">
                                       <p>固定</p>
                                    </td>
                                    <td align="left" valign="top" width="63%" headers="d136732e5533 d136732e5498 ">
                                       <p>物体是固定的吗？</p>
                                    </td>
                                 </tr>
                                 <tr align="left" valign="top">
                                    <td align="left" valign="top" width="37%" id="d136732e5540" headers="d136732e5495 ">
                                       <p>分配期限</p>
                                    </td>
                                    <td align="left" valign="top" width="63%" headers="d136732e5540 d136732e5498 ">
                                       <p>参见<a href="object-advanced-topics-in-oci.html#GUID-639E852E-0AA3-414F-A5A3-598C8F2047E1" title="为了保持内存中的可用空间，对象缓存尝试尽可能重用对象的内存。当对象的生命周期（分配持续时间）到期或对象的引脚持续时间到期时，对象缓存会重用对象的内存。">对象持续时间</a>
                                       </p>
                                    </td>
                                 </tr>
                                 <tr align="left" valign="top">
                                    <td align="left" valign="top" width="37%" id="d136732e5559" headers="d136732e5495 ">
                                       <p>针脚持续时间</p>
                                    </td>
                                    <td align="left" valign="top" width="63%" headers="d136732e5559 d136732e5498 ">
                                       <p>参见<a href="object-advanced-topics-in-oci.html#GUID-639E852E-0AA3-414F-A5A3-598C8F2047E1" title="为了保持内存中的可用空间，对象缓存尝试尽可能重用对象的内存。当对象的生命周期（分配持续时间）到期或对象的引脚持续时间到期时，对象缓存会重用对象的内存。">对象持续时间</a>
                                       </p>
                                    </td>
                                 </tr>
                              </tbody>
                           </table>
                        </div>
                        <!-- class="inftblhruleinformal" -->
                        <div class="infoboxnote" id="GUID-67E39885-2DEC-422A-907F-5E63AE84530A__GUID-BEE015E3-3C0F-4309-A1D4-553195035D42">
                           <p class="notep1">注意：</p>
                           <p>嵌入式持久对象仅具有<span class="italic">无效</span>和<span class="italic">分配持续时间</span>属性，这些属性是瞬态的。
                           </p>
                        </div>
                        <p>OCI提供<code class="codeph">OCIObjectGetProperty()</code>函数，该函数允许应用程序检查对象的各种属性的状态。该函数的语法是：</p><pre class="oac_no_warn" dir="ltr">sword OCIObjectGetProperty（OCIEnv * envh，OCIError * errh，const void * obj，OCIObjectPropId propertyId，void * property，ub4 * size）;</pre><p><code class="codeph">propertyId</code>和<code class="codeph">property</code>参数用于检索有关各种属性或属性的信息。
                        </p>
                        <p>随后是不同的属性ID和相应的<code class="codeph">property</code>参数类型。
                        </p>
                        <dl>
                           <dt class="dlterm"><a name="GUID-67E39885-2DEC-422A-907F-5E63AE84530A__GUID-82B2C405-1B02-4CA8-8554-6C4CAAE12387"><!-- --></a> OCI_OBJECTPROP_LIFETIME</dt>
                           <dd>
                              <div class="p">这标识给定对象是持久对象还是临时对象或值实例。<code class="codeph">property</code>参数必须是指向<code class="codeph">OCIObjectLifetime</code>类型变量的指针。可能的值包括：<ul style="list-style-type:disc">
                                    <li>
                                       <p><code class="codeph">OCI_OBJECT_PERSISTENT</code></p>
                                    </li>
                                    <li>
                                       <p><code class="codeph">OCI_OBJECT_TRANSIENT</code></p>
                                    </li>
                                    <li>
                                       <p><code class="codeph">OCI_OBJECT_VALUE</code></p>
                                    </li>
                                 </ul>
                              </div>
                           </dd>
                        </dl>
                        <dl>
                           <dt class="dlterm"><a name="GUID-67E39885-2DEC-422A-907F-5E63AE84530A__GUID-F54A22B9-7244-4EAE-869F-2C83AC318681"><!-- --></a> OCI_OBJECTPROP_SCHEMA</dt>
                           <dd>
                              <p>这将返回对象所在表的模式名称。如果给定对象指向瞬态实例或值，则返回错误。如果输入缓冲区不足以容纳模式名称，则返回错误;错误消息传达所需的大小。成功后，返回的模式名称的大小（以字节为单位）将按<code class="codeph">size</code>返回。<code class="codeph">property</code>参数必须是<code class="codeph">text</code>类型的数组，并且<code class="codeph">size</code>应该被调用者设置为数组的大小（以字节为单位）。
                              </p>
                           </dd>
                           <dt class="dlterm"><a name="GUID-67E39885-2DEC-422A-907F-5E63AE84530A__GUID-59536B48-2AEB-4D19-9188-149D72410A93"><!-- --></a> OCI_OBJECTPROP_TABLE</dt>
                           <dd>
                              <p>这将返回对象所在的表名。如果给定对象指向瞬态实例或值，则返回错误。如果输入缓冲区不足以容纳表名，则返回错误;错误消息传达所需的大小。成功后，返回的表名称的大小（以字节为单位）将按<code class="codeph">size</code>返回。<code class="codeph">property</code>参数必须是<code class="codeph">text</code>类型的数组， <code class="codeph">size</code>应该由调用者设置为数组的大小（以字节为单位）。
                              </p>
                           </dd>
                           <dt class="dlterm"><a name="GUID-67E39885-2DEC-422A-907F-5E63AE84530A__GUID-300BB0A0-1316-4A1C-81FC-00D957E75CFC"><!-- --></a> OCI_OBJECTPROP_PIN_DURATION</dt>
                           <dd>
                              <div class="p">这将返回对象的引脚持续时间。如果给定对象指向值实例，则返回错误。<code class="codeph">property</code>参数必须是指向<code class="codeph">OCIDuration</code>类型变量的指针。有效值包括：<ul style="list-style-type:disc">
                                    <li>
                                       <p><code class="codeph">OCI_DURATION_SESSION</code></p>
                                    </li>
                                    <li>
                                       <p><code class="codeph">OCI_DURATION_TRANS</code></p>
                                    </li>
                                 </ul>
                              </div>
                           </dd>
                        </dl>
                        <dl>
                           <dt class="dlterm"><a name="GUID-67E39885-2DEC-422A-907F-5E63AE84530A__GUID-740B04AD-DF41-4B2A-87EF-982DD864DA69"><!-- --></a> OCI_OBJECTPROP_ALLOC_DURATION</dt>
                           <dd>
                              <div class="p">这将返回对象的分配持续时间。<code class="codeph">property</code>参数必须是指向<code class="codeph">OCIDuration</code>类型变量的指针。有效值包括：<ul style="list-style-type:disc">
                                    <li>
                                       <p><code class="codeph">OCI_DURATION_SESSION</code></p>
                                    </li>
                                    <li>
                                       <p><code class="codeph">OCI_DURATION_TRANS</code></p>
                                    </li>
                                 </ul>
                              </div>
                           </dd>
                        </dl>
                        <dl>
                           <dt class="dlterm"><a name="GUID-67E39885-2DEC-422A-907F-5E63AE84530A__GUID-EFFF44D2-396C-4FB6-A09A-0BFF4A28B8AA"><!-- --></a> OCI_OBJECTPROP_LOCK</dt>
                           <dd>
                              <p>这将返回对象的锁定状态。可能的锁定状态由<code class="codeph">OCILockOpt</code>指示。如果给定对象指向瞬态或值实例，则返回错误。<code class="codeph">property</code>参数必须是指向<code class="codeph">OCILockOpt</code>类型的变量的指针。也可以通过调用<code class="codeph">OCIObjectIsLocked()</code>来检索对象的锁定状态。
                              </p>
                           </dd>
                           <dt class="dlterm"><a name="GUID-67E39885-2DEC-422A-907F-5E63AE84530A__GUID-00CC3DE9-EA01-44C4-B058-EA5D53FED614"><!-- --></a> OCI_OBJECTPROP_MARKSTATUS</dt>
                           <dd>
                              <div class="p">这将返回脏状态并指示对象是新对象，更新对象还是已删除对象。如果给定对象指向瞬态或值实例，则返回错误。<code class="codeph">property</code>参数必须是<code class="codeph">OCIObjectMarkStatus</code>类型。有效值包括：<ul style="list-style-type:disc">
                                    <li>
                                       <p><code class="codeph">OCI_OBJECT_NEW</code></p>
                                    </li>
                                    <li>
                                       <p><code class="codeph">OCI_OBJECT_DELETED</code></p>
                                    </li>
                                    <li>
                                       <p><code class="codeph">OCI_OBJECT_UPDATED</code></p>
                                    </li>
                                 </ul>
                              </div>
                              <p>以下宏可用于测试对象标记状态：</p>
                              <ul style="list-style-type:disc">
                                 <li>
                                    <p><code class="codeph">OCI_OBJECT_IS_UPDATED</code> （旗帜）</p>
                                 </li>
                                 <li>
                                    <p><code class="codeph">OCI_OBJECT_IS_DELETED</code> （flag）</p>
                                 </li>
                                 <li>
                                    <p><code class="codeph">OCI_OBJECT_IS_NEW</code> （旗帜）</p>
                                 </li>
                                 <li>
                                    <p><code class="codeph">OCI_OBJECT_IS_DIRTY</code> （flag）</p>
                                 </li>
                              </ul>
                           </dd>
                        </dl>
                        <dl>
                           <dt class="dlterm"><a name="GUID-67E39885-2DEC-422A-907F-5E63AE84530A__GUID-54632ACD-8547-4FE6-94B9-05BD7ADA01C7"><!-- --></a> OCI_OBJECTPROP_VIEW</dt>
                           <dd>
                              <p>这标识指定的对象是否是对象视图。如果返回的属性值为<code class="codeph">TRUE</code> ，则该对象是视图;否则，它不是。如果给定对象指向瞬态或值实例，则返回错误。<code class="codeph">property</code>参数必须是<code class="codeph">boolean</code>类型。
                              </p>
                              <p>正如视图是虚拟表一样，对象视图是虚拟对象表。视图中的每一行都是一个对象：您可以调用其方法，使用点表示法访问其属性，并创建指向它的<code class="codeph">REF</code> 。
                              </p>
                           </dd>
                        </dl>
                        <div class="infoboxnotealso" id="GUID-67E39885-2DEC-422A-907F-5E63AE84530A__GUID-3D338694-4385-48CD-8F34-0F5F684DC0B1">
                           <p class="notep1">也可以看看：</p>
                           <ul style="list-style-type:disc">
                              <li>
                                 <p><a href="oci-get-object-status-functions.html#GUID-B65AA4FB-E4FF-4062-927E-4C62900D59C1" title="检索对象的给定属性。">OCIObjectGetProperty（）</a></p>
                              </li>
                              <li>
                                 <p><a href="object-advanced-topics-in-oci.html#GUID-639E852E-0AA3-414F-A5A3-598C8F2047E1" title="To maintain free space in memory, the object cache attempts to reuse objects&#39; memory whenever possible. The object cache reuses an object&#39;s memory when the object&#39;s lifetime (allocation duration) expires or when the object&#39;s pin duration expires.">对象持续时间</a>有关持续<a href="object-advanced-topics-in-oci.html#GUID-639E852E-0AA3-414F-A5A3-598C8F2047E1" title="为了保持内存中的可用空间，对象缓存尝试尽可能重用对象的内存。当对象的生命周期（分配持续时间）到期或对象的引脚持续时间到期时，对象缓存会重用对象的内存。">时间</a>的更多信息</p>
                              </li>
                              <li>
                                 <p><a href="oci-get-object-status-functions.html#GUID-AC738B41-AA00-40D4-9824-F63BADA321FB" title="获取对象的锁定状态。">OCIObjectIsLocked（）</a></p>
                              </li>
                           </ul>
                        </div>
                     </div>
                  </div><a id="LNOCI16800"></a><a id="LNOCI16799"></a><div class="props_rev_3"><a id="GUID-B5732CDF-2D02-404E-A1A0-CF8A082AFE71" name="GUID-B5732CDF-2D02-404E-A1A0-CF8A082AFE71"></a><h5 id="LNOCI-GUID-B5732CDF-2D02-404E-A1A0-CF8A082AFE71" class="sect5"><span class="enumeration_section">19.3.9.2</span>附加属性函数</h5>
                     <div>
                        <p>列出并描述称为set和check函数的其他属性函数。</p>
                        <p>OCI还提供允许应用程序直接或间接设置或检查其中某些属性的函数，如<a href="oci-object-relational-programming.html#GUID-B5732CDF-2D02-404E-A1A0-CF8A082AFE71__BGBDCDFB" title="该表有3列。第1列是元属性名称，第2列是设置属性的OCI函数的名称，第3列是检查属性设置的OCI函数的名称。">表19-2</a>所示。
                        </p>
                        <div class="tblformal" id="GUID-B5732CDF-2D02-404E-A1A0-CF8A082AFE71__BGBDCDFB">
                           <p class="titleintable">表19-2设置和检查功能</p>
                           <table cellpadding="4" cellspacing="0" class="Formal" title="设置和检查功能" width="100%" border="1" summary="This table has 3 columns. Column 1 is the meta-attribute name, columne 2 is name of the OCI function that sets the attribute, and column 3 is the name of the OCI function that checks the attribute setting." frame="hsides" rules="rows">
                              <thead>
                                 <tr align="left" valign="top">
                                    <th align="left" valign="bottom" width="29%" id="d136732e6038">元属性</th>
                                    <th align="left" valign="bottom" width="35%" id="d136732e6041">设置为</th>
                                    <th align="left" valign="bottom" width="35%" id="d136732e6044">检查</th>
                                 </tr>
                              </thead>
                              <tbody>
                                 <tr align="left" valign="top">
                                    <td align="left" valign="top" width="29%" id="d136732e6049" headers="d136732e6038 ">
                                       <p>无效</p>
                                    </td>
                                    <td align="left" valign="top" width="35%" headers="d136732e6049 d136732e6041 ">
                                       <p>&lt;无&gt;</p>
                                    </td>
                                    <td align="left" valign="top" width="35%" headers="d136732e6049 d136732e6044 ">
                                       <p><a href="oci-miscellaneous-object-functions.html#GUID-22B229C0-369E-453E-A8D6-C7F7DBB1E80C" title="检索独立实例的NULL指示符结构。">OCIObjectGetInd（）</a></p>
                                    </td>
                                 </tr>
                                 <tr align="left" valign="top">
                                    <td align="left" valign="top" width="29%" id="d136732e6067" headers="d136732e6038 ">
                                       <p>存在</p>
                                    </td>
                                    <td align="left" valign="top" width="35%" headers="d136732e6067 d136732e6041 ">
                                       <p>&lt;无&gt;</p>
                                    </td>
                                    <td align="left" valign="top" width="35%" headers="d136732e6067 d136732e6044 ">
                                       <p><a href="oci-get-object-status-functions.html#GUID-AF9CFD0F-14C4-4D24-94BF-5D68E9C41E01" title="返回独立实例的存在元属性。">OCIObjectExists（）</a></p>
                                    </td>
                                 </tr>
                                 <tr align="left" valign="top">
                                    <td align="left" valign="top" width="29%" id="d136732e6082" headers="d136732e6038 ">
                                       <p>锁定</p>
                                    </td>
                                    <td align="left" valign="top" width="35%" headers="d136732e6082 d136732e6041 ">
                                       <p><a href="oci-miscellaneous-object-functions.html#GUID-FF85B1EA-695C-49A6-99AC-6E1A7F616FC0" title="锁定服务器上的持久对象。">OCIObjectLock（）</a></p>
                                    </td>
                                    <td align="left" valign="top" width="35%" headers="d136732e6082 d136732e6044 ">
                                       <p><a href="oci-get-object-status-functions.html#GUID-AC738B41-AA00-40D4-9824-F63BADA321FB" title="获取对象的锁定状态。">OCIObjectIsLocked（）</a></p>
                                    </td>
                                 </tr>
                                 <tr align="left" valign="top">
                                    <td align="left" valign="top" width="29%" id="d136732e6102" headers="d136732e6038 ">
                                       <p>脏</p>
                                    </td>
                                    <td align="left" valign="top" width="35%" headers="d136732e6102 d136732e6041 ">
                                       <p><a href="oci-mark-or-unmark-object-cache-functions.html#GUID-6EEEC8CC-3041-4718-ADE7-20C6D8C661ED" title="将持久对象标记为已更新（脏）。">OCIObjectMarkUpdate（）</a></p>
                                    </td>
                                    <td align="left" valign="top" width="35%" headers="d136732e6102 d136732e6044 ">
                                       <p><a href="oci-get-object-status-functions.html#GUID-9B96A7DF-BE19-4131-8B95-11063C060012" title="检查对象是否标记为脏。">OCIObjectIsDirty（）</a></p>
                                    </td>
                                 </tr>
                              </tbody>
                           </table>
                        </div>
                        <!-- class="inftblhruleinformal" -->
                     </div>
                  </div><a id="LNOCI16802"></a><a id="LNOCI16801"></a><div class="props_rev_3"><a id="GUID-2220F791-09A6-46EB-AF24-4D65F53E04FB" name="GUID-2220F791-09A6-46EB-AF24-4D65F53E04FB"></a><h5 id="LNOCI-GUID-2220F791-09A6-46EB-AF24-4D65F53E04FB" class="sect5"><span class="enumeration_section">19.3.9.3</span>瞬态对象元属性</h5>
                     <div>
                        <p>列出并描述瞬态对象元属性。</p>
                        <p>瞬态对象没有持久属性。<a href="oci-object-relational-programming.html#GUID-2220F791-09A6-46EB-AF24-4D65F53E04FB__BGBHIGGG" title="该表有2列。第1列是瞬态元属性名称，第2列是其含义。">表19-3</a>显示了以下瞬态属性。
                        </p>
                        <div class="tblformal" id="GUID-2220F791-09A6-46EB-AF24-4D65F53E04FB__BGBHIGGG">
                           <p class="titleintable">表19-3瞬态元属性</p>
                           <table cellpadding="4" cellspacing="0" class="Formal" title="瞬态元属性" width="100%" border="1" summary="This table has 2 columns. Column 1 is the transient meta-attribute name and column 2 is its meaning." frame="hsides" rules="rows">
                              <thead>
                                 <tr align="left" valign="top">
                                    <th align="left" valign="bottom" width="38%" id="d136732e6334">瞬态元属性</th>
                                    <th align="left" valign="bottom" width="62%" id="d136732e6337">含义</th>
                                 </tr>
                              </thead>
                              <tbody>
                                 <tr align="left" valign="top">
                                    <td align="left" valign="top" width="38%" id="d136732e6342" headers="d136732e6334 ">
                                       <p>存在</p>
                                    </td>
                                    <td align="left" valign="top" width="62%" headers="d136732e6342 d136732e6337 ">
                                       <p>对象存在吗？</p>
                                    </td>
                                 </tr>
                                 <tr align="left" valign="top">
                                    <td align="left" valign="top" width="38%" id="d136732e6349" headers="d136732e6334 ">
                                       <p>固定</p>
                                    </td>
                                    <td align="left" valign="top" width="62%" headers="d136732e6349 d136732e6337 ">
                                       <p>应用程序是否正在访问该对象？</p>
                                    </td>
                                 </tr>
                                 <tr align="left" valign="top">
                                    <td align="left" valign="top" width="38%" id="d136732e6356" headers="d136732e6334 ">
                                       <p>脏</p>
                                    </td>
                                    <td align="left" valign="top" width="62%" headers="d136732e6356 d136732e6337 ">
                                       <p>物体是否被标记为<span class="italic">脏污</span> ？
                                       </p>
                                    </td>
                                 </tr>
                                 <tr align="left" valign="top">
                                    <td align="left" valign="top" width="38%" id="d136732e6366" headers="d136732e6334 ">
                                       <p>无效</p>
                                    </td>
                                    <td align="left" valign="top" width="62%" headers="d136732e6366 d136732e6337 ">
                                       <p>实例的空信息。</p>
                                    </td>
                                 </tr>
                                 <tr align="left" valign="top">
                                    <td align="left" valign="top" width="38%" id="d136732e6373" headers="d136732e6334 ">
                                       <p>分配期限</p>
                                    </td>
                                    <td align="left" valign="top" width="62%" headers="d136732e6373 d136732e6337 ">
                                       <p>参见<a href="object-advanced-topics-in-oci.html#GUID-639E852E-0AA3-414F-A5A3-598C8F2047E1" title="为了保持内存中的可用空间，对象缓存尝试尽可能重用对象的内存。当对象的生命周期（分配持续时间）到期或对象的引脚持续时间到期时，对象缓存会重用对象的内存。">对象持续时间</a>
                                       </p>
                                    </td>
                                 </tr>
                                 <tr align="left" valign="top">
                                    <td align="left" valign="top" width="38%" id="d136732e6393" headers="d136732e6334 ">
                                       <p>针脚持续时间</p>
                                    </td>
                                    <td align="left" valign="top" width="62%" headers="d136732e6393 d136732e6337 ">
                                       <p>参见<a href="object-advanced-topics-in-oci.html#GUID-639E852E-0AA3-414F-A5A3-598C8F2047E1" title="为了保持内存中的可用空间，对象缓存尝试尽可能重用对象的内存。当对象的生命周期（分配持续时间）到期或对象的引脚持续时间到期时，对象缓存会重用对象的内存。">对象持续时间</a>
                                       </p>
                                    </td>
                                 </tr>
                              </tbody>
                           </table>
                        </div>
                        <!-- class="inftblhruleinformal" -->
                     </div>
                  </div>
               </div><a id="LNOCI16803"></a><div class="props_rev_3"><a id="GUID-03683C87-7758-421A-BC51-C54A5A7679F2" name="GUID-03683C87-7758-421A-BC51-C54A5A7679F2"></a><h4 id="LNOCI-GUID-03683C87-7758-421A-BC51-C54A5A7679F2" class="sect4"><span class="enumeration_section">19.3.10</span>复杂对象检索</h4>
                  <div>
                     <p>复杂对象包括其根对象及其逻辑相关对象集，每个对象基于给定深度级别被预取。</p>
                     <p>在<a href="oci-object-relational-programming.html#GUID-B9E5DDBD-19CD-4AE0-B1D3-3B85ADEAAAB1__BGBDEJIB">例19-3</a>和<a href="oci-object-relational-programming.html#GUID-BA775817-78E4-4C49-A3C2-C867C50509B2__BGBBCFBA">例19-4中</a> ，一次只获取或固定一个实例。在这些情况下，每个引脚操作都涉及单独的服务器往返以检索对象。
                     </p>
                     <p>面向对象的应用程序通常将其问题建模为一组形成对象图形的相互关联的对象。应用程序通过从一些初始对象开始处理这些对象，然后使用这些初始对象中的引用来遍历其余对象。在客户端/服务器设置中，这些遍历中的每一个都可能导致昂贵的网络往返以获取对象。</p>
                     <p>使用<span class="italic">复杂的对象检索（COR）</span>可以提高对象的应用程序性能。这是一种预取机制，其中应用程序指定在单个操作中检索一组链接对象的条件。
                     </p>
                     <div class="infoboxnote" id="GUID-03683C87-7758-421A-BC51-C54A5A7679F2__GUID-E26BA445-AB6A-470E-8E2A-4D4941C73A2C">
                        <p class="notep1">注意：</p>
                        <p>如后所述，这并不意味着这些预取的对象都被固定。它们被提取到对象缓存中，以便后续的引脚调用是本地操作。</p>
                     </div>
                     <p><span class="italic">复杂对象</span>是一组逻辑上相关的对象，包括根对象和一组对象，每个对象都基于给定的深度级别被预取。显式提取或固定<span class="italic">根对象</span> 。<span class="italic">深度级别</span>是必须从根对象遍历到复杂对象中的给定预取对象的最短引用数。
                     </p>
                     <p>应用程序通过描述其内容和边界来指定复杂对象。复制对象的获取受到环境的<span class="italic">预取限制的限制</span> ，即对象缓存中可用于预取对象的内存量。
                     </p>
                     <div class="infoboxnote" id="GUID-03683C87-7758-421A-BC51-C54A5A7679F2__GUID-D5E96829-DA7D-4D78-83F5-297E3403E015">
                        <p class="notep1">注意：</p>
                        <p>COR的使用不会增加功能，但会提高性能。它的使用是可选的。</p>
                     </div>
                     <p>请考虑以下类型声明：</p><pre class="oac_no_warn" dir="ltr">CREATE TYPE客户（...）; CREATE TYPE line_item（...）; CREATE TYPE line_item_varray为REF line_item的VARRAY（100）; CREATE TYPE purchase_order AS OBJECT（po_number NUMBER，cust REF customer，related_orders REF purchase_order，line_items line_item_varray）;</pre><p><code class="codeph">purchase_order</code>类型包含<code class="codeph">po_number</code>的标量值，行项目的<code class="codeph">VARRAY</code>和两个引用。第一个是<code class="codeph">customer</code>类型，第二个是<code class="codeph">purchase_order</code>类型，表示此类型可以实现为链接列表。
                     </p>
                     <p>在获取复杂对象时，应用程序必须指定以下内容：</p>
                     <ul style="list-style-type:disc">
                        <li>
                           <p>对所需根对象的<code class="codeph">REF</code> 。
                           </p>
                        </li>
                        <li>
                           <p>一对或多对类型和深度信息，用于指定复杂对象的边界。类型信息指示COR应遵循哪些<code class="codeph">REF</code>属性，深度级别指示应遵循这些链接的深度级别。
                           </p>
                        </li>
                     </ul>
                     <p>在上一个采购订单对象中，应用程序必须指定以下内容：</p>
                     <ul style="list-style-type:disc">
                        <li>
                           <p>根采购订单对象的<code class="codeph">REF</code></p>
                        </li>
                        <li>
                           <p>一个或多个对的类型和深度信息<code class="codeph">cust</code> ， <code class="codeph">related_orders</code> ，或<code class="codeph">line_items</code></p>
                        </li>
                     </ul>
                     <p>获取采购订单的应用程序很可能需要访问该订单的客户信息。使用简单导航，这将需要两次服务器访问来检索这两个对象。通过复杂的对象检索，当应用程序固定采购订单时，可以预取客户。在这种情况下，复杂对象将由采购订单对象及其引用的客户对象组成。</p>
                     <p>在前面的示例中，应用程序将指定<code class="codeph">purchase_order</code> <code class="codeph">REF</code> ，并指示应将<code class="codeph">cust</code> <code class="codeph">REF</code>属性跟随深度级别1，如下所示：</p>
                     <ul style="list-style-type:disc">
                        <li>
                           <p><code class="codeph">REF（PO对象）</code></p>
                        </li>
                        <li>
                           <p>{ <code class="codeph">(customer, 1</code> ）}</p>
                        </li>
                     </ul>
                     <p>对于预取<code class="codeph">purchase_order</code>对象及其包含的对象图中的所有对象的应用程序，应用程序将指定<code class="codeph">cust</code>和<code class="codeph">related_orders</code>都应遵循可能的最大深度级别。
                     </p>
                     <ul style="list-style-type:disc">
                        <li>
                           <p><code class="codeph">REF（PO对象）</code></p>
                        </li>
                        <li>
                           <p>{ <code class="codeph">(customer, UB4MAXVAL), (purchase_order, UB4MAXVAL)</code> }</p>
                        </li>
                     </ul>
                     <p>（在此示例中， <code class="codeph">UB4MAXVAL</code>指定应预取通过根对象的引用可到达的指定类型的所有对象。）
                     </p>
                     <p>对于获取PO和所有关联行项目的应用程序，它将指定：</p>
                     <ul style="list-style-type:disc">
                        <li>
                           <p><code class="codeph">REF（PO对象）</code></p>
                        </li>
                        <li>
                           <p>{ <code class="codeph">(line_item, 1)</code> }</p>
                        </li>
                     </ul>
                     <p>应用程序还可以通过将level参数设置为所需的深度，通过<code class="codeph">REF</code> （传递闭包）获取从根对象可到达的所有对象。对于前两个示例，应用程序还可以分别指定<code class="codeph">(PO object REF, UB4MAXVAL)</code>和<code class="codeph">(PO object REF, 1)</code>以预取所需对象。虽然这样做会导致许多无关的提取，但指定起来非常简单，并且只需要一个服务器往返。
                     </p>
                     <div class="p">本节包括以下主题：<ul style="list-style-type:disc">
                           <li>
                              <p><a href="oci-object-relational-programming.html#GUID-1E31DD56-FAF9-497F-97EB-2CAF7025E4CB" title="在指定和获取复杂对象之后，复杂对象中包含的对象的后续提取不会产生网络往返的成本，因为这些对象已经被预取并且在对象高速缓存中。">关于预取对象</a></p>
                           </li>
                           <li>
                              <p><a href="oci-object-relational-programming.html#GUID-069E4CBB-7F2A-4077-A50F-299E301A9EFB" title="复杂对象检索（COR）允许应用程序在获取根对象时预取复杂对象。">关于在OCI中实现复杂对象检索</a></p>
                           </li>
                        </ul>
                     </div>
                  </div><a id="LNOCI16804"></a><div class="props_rev_3"><a id="GUID-1E31DD56-FAF9-497F-97EB-2CAF7025E4CB" name="GUID-1E31DD56-FAF9-497F-97EB-2CAF7025E4CB"></a><h5 id="LNOCI-GUID-1E31DD56-FAF9-497F-97EB-2CAF7025E4CB" class="sect5"><span class="enumeration_section">19.3.10.1</span>关于预取对象</h5>
                     <div>
                        <p>在指定和获取复杂对象之后，复杂对象中包含的对象的后续提取不会产生网络往返的成本，因为这些对象已经被预取并且在对象高速缓存中。</p>
                        <p>考虑到过多的对象预取可能会导致对象缓存泛滥。反过来，这种泛滥可能会强制应用程序固定的其他对象，从而导致性能下降而不是性能提升。</p>
                        <div class="infoboxnote" id="GUID-1E31DD56-FAF9-497F-97EB-2CAF7025E4CB__GUID-1418E9CD-C21B-4D0C-9555-5A7D24401D63">
                           <p class="notep1">注意：</p>
                           <p>如果缓存中没有足够的内存来容纳所有预取对象，则可能无法预取某些对象。当稍后访问这些对象时，应用程序会发生网络往返。</p>
                        </div>
                        <p>所有预取对象都需要<code class="codeph">READ</code>或<code class="codeph">SELECT</code>权限。不预取应用程序没有<code class="codeph">READ</code>或<code class="codeph">SELECT</code>权限的复杂对象中的对象。
                        </p>
                     </div>
                  </div><a id="LNOCI16805"></a><div class="props_rev_3"><a id="GUID-069E4CBB-7F2A-4077-A50F-299E301A9EFB" name="GUID-069E4CBB-7F2A-4077-A50F-299E301A9EFB"></a><h5 id="LNOCI-GUID-069E4CBB-7F2A-4077-A50F-299E301A9EFB" class="sect5"><span class="enumeration_section">19.3.10.2</span>关于在OCI中实现复杂对象检索</h5>
                     <div>
                        <p>复杂对象检索（COR）允许应用程序在获取根对象时预取复杂对象。</p>
                        <p>复杂对象规范被传递给用于简单对象的相同<code class="codeph">OCIObjectPin()</code>函数。
                        </p>
                        <p>应用程序使用<span class="italic">复杂对象检索句柄</span>指定复杂对象检索的参数。此句柄的类型为<code class="codeph">OCIComplexObject</code>并以与其他OCI句柄相同的方式分配。
                        </p>
                        <p>复杂对象检索句柄包含<span class="italic">复杂对象检索描述符</span>的列表。描述符的类型为<code class="codeph">OCIComplexObjectComp</code> ，并以与其他OCI描述符相同的方式分配。
                        </p>
                        <p>每个COR描述符包含<code class="codeph">REF</code>类型和深度级别。类型<code class="codeph">REF</code>指定构造复杂对象时要遵循的引用类型。深度级别表示应遵循特定类型的引用的距离。指定整数值，或为最大可能深度级别指定常量<code class="codeph">UB4MAXVAL</code> 。
                        </p>
                        <p>应用程序还可以在COR句柄中指定深度级别，而无需为类型和深度参数创建COR描述符。在这种情况下，所有<code class="codeph">REF</code>都遵循COR句柄中指定的深度。COR句柄还可用于指定是否应根据需要单独获取集合属性（线外），而不是与包含对象（内联）一起获取它的默认情况。
                        </p>
                        <p>该应用程序使用<code class="codeph">OCIAttrSet()</code>来设置COR句柄的属性。属性是：</p>
                        <p><code class="codeph">OCI_ATTR_COMPLEXOBJECT_LEVEL</code> - 深度级别</p>
                        <p><code class="codeph">OCI_ATTR_COMPLEXOBJECT_COLL_OUTOFLINE</code> - 在对象类型外获取集合属性</p>
                        <p>应用程序使用<code class="codeph">OCIDescriptorAlloc()</code>分配COR描述符，然后可以设置以下属性：</p>
                        <p><code class="codeph">OCI_ATTR_COMPLEXOBJECTCOMP_TYPE</code> - 类型<code class="codeph">REF</code></p>
                        <p><code class="codeph">OCI_ATTR_COMPLEXOBJECTCOMP_TYPE_LEVEL</code> - 前一类型引用的深度级别</p>
                        <p>一旦设置了这些属性，应用程序就会调用<code class="codeph">OCIParamSet()</code>将描述符放入复杂的对象检索句柄中。句柄具有<code class="codeph">OCI_ATTR_PARAM_COUNT</code>属性，该属性指定句柄上的描述符数。可以使用<code class="codeph">OCIAttrGet()</code>读取此属性。
                        </p>
                        <p>一旦填充了句柄，就可以将其传递给<code class="codeph">OCIObjectPin()</code>调用以固定根对象并预取复杂对象的其余部分。
                        </p>
                        <p>复杂对象检索句柄和描述符必须在不再需要时显式释放。</p>
                        <div class="infoboxnotealso" id="GUID-069E4CBB-7F2A-4077-A50F-299E301A9EFB__GUID-B02B8396-0AFE-4EF3-8129-1663F84503DE">
                           <p class="notep1">也可以看看：</p>
                           <ul style="list-style-type:disc">
                              <li>
                                 <p><a href="oci-programming-basics.html#GUID-5F13B2EC-E29C-4710-8AD7-E97E6C28085E" title="几乎每个OCI调用都在其参数列表中包含一个或多个句柄。">手柄</a></p>
                              </li>
                              <li>
                                 <p><a href="oci-programming-basics.html#GUID-82F35CC7-A79D-42CE-BF90-DE63FCBAAB7C" title="OCI描述符和定位符是不透明的数据结构，用于维护特定于数据的信息。">OCI描述符</a></p>
                              </li>
                              <li>
                                 <p><a href="oci-pin-unpin-and-free-functions.html#GUID-89F29585-2F16-4FA3-B1E0-BDD83707CA62" title="引脚可引用对象。">OCIObjectPin（）</a></p>
                              </li>
                              <li>
                                 <p><a href="handle-and-descriptor-functions.html#GUID-3741D7BD-7652-4D7A-8813-AC2AEA8D3B03" title="设置句柄或描述符的属性值。">OCIAttrSet（）</a></p>
                              </li>
                              <li>
                                 <p><a href="handle-and-descriptor-functions.html#GUID-E9EF2766-E078-49A7-B1D1-738E4BA4814F" title="分配存储以保存描述符或LOB定位符。">OCIDescriptorAlloc（）</a></p>
                              </li>
                              <li>
                                 <p><a href="handle-and-descriptor-functions.html#GUID-280CF9E5-3537-4785-9AFA-4E63DE29A266" title="将复杂对象检索（COR）描述符设置为COR句柄。">OCIParamSet（）</a></p>
                              </li>
                              <li>
                                 <p><a href="handle-and-descriptor-functions.html#GUID-FA199A99-4D7A-42C2-BB0A-C20047B95DF9" title="获取句柄属性的值。">OCIAttrGet（）</a></p>
                              </li>
                              <li>
                                 <p><a href="oci-pin-unpin-and-free-functions.html#GUID-89F29585-2F16-4FA3-B1E0-BDD83707CA62" title="引脚可引用对象。">OCIObjectPin（）</a></p>
                              </li>
                           </ul>
                        </div>
                     </div>
                  </div>
               </div><a id="LNOCI16806"></a><div class="props_rev_3"><a id="GUID-22733B74-F52F-4E54-8E5E-5C27FD03F5DC" name="GUID-22733B74-F52F-4E54-8E5E-5C27FD03F5DC"></a><h4 id="LNOCI-GUID-22733B74-F52F-4E54-8E5E-5C27FD03F5DC" class="sect4"><span class="enumeration_section">19.3.11</span> COR预取</h4>
                  <div>
                     <p>应用程序在获取根对象时指定复杂对象。</p>
                     <p>通过对以给定根对象为根的对象的图的广度优先遍历来获得预取对象。当预取了所有必需对象时，或者当所有预取对象的总大小超过<span class="italic">预取限制</span>时，遍历停止。
                     </p>
                     <div class="p">本节包括以下主题：<ul style="list-style-type:disc">
                           <li>
                              <p><a href="oci-object-relational-programming.html#GUID-546FD7C5-FD56-4853-9E2F-298E53D1D801" title="用于获取复杂对象的接口是OCI引脚接口。">COR接口</a></p>
                           </li>
                           <li>
                              <p><a href="oci-object-relational-programming.html#GUID-56AC45D1-2FD1-4D97-9C0B-EFCA7DFF5A4C" title="显示如何修改应用程序以使用复杂的对象检索。">COR的例子</a></p>
                           </li>
                        </ul>
                     </div>
                  </div><a id="LNOCI16807"></a><div class="props_rev_3"><a id="GUID-546FD7C5-FD56-4853-9E2F-298E53D1D801" name="GUID-546FD7C5-FD56-4853-9E2F-298E53D1D801"></a><h5 id="LNOCI-GUID-546FD7C5-FD56-4853-9E2F-298E53D1D801" class="sect5"><span class="enumeration_section">19.3.11.1</span> COR接口</h5>
                     <div>
                        <p>用于获取复杂对象的接口是OCI引脚接口。</p>
                        <p>该应用程序可以通过一个初始化COR句柄<code class="codeph">OCIObjectPin()</code>或把手的阵列，以<code class="codeph">OCIObjectArrayPin()</code>来获取根对象和在COR句柄指定的预取对象。
                        </p><pre class="oac_no_warn" dir="ltr">sword OCIObjectPin（OCIEnv * env，OCIError * err，OCIRef * object_ref，OCIComplexObject * corhdl，OCIPinOpt pin_option，OCIDuration pin_duration，OCILockOpt lock_option，void ** object）; sword OCIObjectArrayPin（OCIEnv * env，OCIError * err，OCIRef ** ref_array，ub4 array_size，OCIComplexObject ** cor_array，ub4 cor_array_size，OCIPinOpt pin_option，OCIDuration pin_duration，OCILockOpt lock，void ** obj_array，ub4 * pos）;</pre><p>使用COR时请注意以下几点：</p>
                        <ul style="list-style-type:disc">
                           <li>
                              <p>空COR句柄参数默认仅固定根对象。</p>
                           </li>
                           <li>
                              <p>具有根对象类型和深度级别0的COR句柄仅获取根对象，因此等效于空COR句柄。</p>
                           </li>
                           <li>
                              <p>锁定选项仅适用于根对象。</p>
                              <div class="infoboxnote" id="GUID-546FD7C5-FD56-4853-9E2F-298E53D1D801__GUID-34CB8804-797A-444A-B851-2900A5162455">
                                 <p class="notep1">注意：</p>
                                 <p>要为预取对象指定锁定选项，应用程序可以访问复杂对象中的所有对象，创建<code class="codeph">REF</code>数组，并使用数组接口（ <code class="codeph">OCIObjectArrayPin()</code> ）在另一个往返中锁定整个复杂对象。
                                 </p>
                              </div>
                           </li>
                        </ul>
                        <div class="infoboxnotealso" id="GUID-546FD7C5-FD56-4853-9E2F-298E53D1D801__GUID-FF8F661A-C2C1-47BB-8DB8-2CFFCB048F71">
                           <p class="notep1">也可以看看：</p>
                           <ul style="list-style-type:disc">
                              <li>
                                 <p><a href="oci-pin-unpin-and-free-functions.html#GUID-89F29585-2F16-4FA3-B1E0-BDD83707CA62" title="引脚可引用对象。">OCIObjectPin（）</a></p>
                              </li>
                              <li>
                                 <p><a href="oci-pin-unpin-and-free-functions.html#GUID-2629C6C3-5299-4E92-BA58-804809CFF8B9" title="引入一系列引用。">OCIObjectArrayPin（）</a></p>
                              </li>
                              <li>
                                 <p><a href="oci-pin-unpin-and-free-functions.html#GUID-2629C6C3-5299-4E92-BA58-804809CFF8B9" title="引入一系列引用。">OCIObjectArrayPin（）</a></p>
                              </li>
                           </ul>
                        </div>
                     </div>
                  </div><a id="LNOCI72704"></a><a id="LNOCI16808"></a><div class="props_rev_3"><a id="GUID-56AC45D1-2FD1-4D97-9C0B-EFCA7DFF5A4C" name="GUID-56AC45D1-2FD1-4D97-9C0B-EFCA7DFF5A4C"></a><h5 id="LNOCI-GUID-56AC45D1-2FD1-4D97-9C0B-EFCA7DFF5A4C" class="sect5"><span class="enumeration_section">19.3.11.2</span> COR的例子</h5>
                     <div>
                        <p>显示如何修改应用程序以使用复杂的对象检索。</p>
                        <div class="section">
                           <p><a href="oci-object-relational-programming.html#GUID-56AC45D1-2FD1-4D97-9C0B-EFCA7DFF5A4C__BGBGCEHH">例19-5</a>说明了如何修改应用程序以使用复杂的对象检索。
                           </p>
                           <p>考虑一个显示采购订单的应用程序以及与之关联的行项目。粗体代码实现了这一点。其余代码使用复杂的对象检索进行预取，从而增强了应用程序的性能。</p>
                        </div>
                        <!-- class="section" -->
                        <div class="example" id="GUID-56AC45D1-2FD1-4D97-9C0B-EFCA7DFF5A4C__BGBGCEHH">
                           <p class="titleinexample">示例19-5在OCI中使用复杂对象检索</p><pre class="oac_no_warn" dir="ltr"><span class="bold">OCIEnv * envhp;</span> <span class="bold">OCIError * errhp;</span> <span class="bold">OCIRef ** liref;</span> <span class="bold">OCIRef * poref;</span> <span class="bold">OCIIter * itr;</span> <span class="bold">布尔eoc;</span> <span class="bold">purchase_order * po =（purchase_order *）0;</span> <span class="bold">line_item * li =（line_item *）0;</span> <span class="bold">OCISvcCtx * svchp;</span> <span class="bold">OCIComplexObject * corhp;</span> <span class="bold">OCIComplexObjectComp * cordp;</span> <span class="bold">OCIType * litdo;</span> <span class="bold">ub4 level = 0;</span> / *获取COR句柄* / OCIHandleAlloc（（void *）envhp，（void **）＆corhp，（ub4）OCI_HTYPE_COMPLEXOBJECT，0，（void **）0）; / *获取类型为line_item的COR描述符* / OCIDescriptorAlloc（（void *）envhp，（void **）＆cordp，（ub4）OCI_DTYPE_COMPLEXOBJECTCOMP，0，（void **）0）; / *获取在COR描述符中设置的line_item类型* / OCITypeByName（envhp，errhp，svchp，（const text *）0，（ub4）0，（const text *）“LINE_ITEM”，（ub4）strlen（（const char） *）“LINE_ITEM”），（text *）0，（ub4）0，OCI_DURATION_SESSION，OCI_TYPEGET_HEADER，＆litdo）; / *在COR描述符中设置line_item类型* / OCIAttrSet（（void *）cordp，（ub4）OCI_DTYPE_COMPLEXOBJECTCOMP，（void *）litdo，（ub4）sizeof（void *），（ub4）OCI_ATTR_COMPLEXOBJECTCOMP_TYPE，（OCIError *）errhp）; level = 1; / *设置COR描述符中的line_item_varray的深度级别* / OCIAttrSet（（void *）cordp，（ub4）OCI_DTYPE_COMPLEXOBJECTCOMP，（void *）＆level，（ub4）sizeof（ub4），（ub4）OCI_ATTR_COMPLEXOBJECTCOMP_TYPE_LEVEL，（OCIError *）errhp） ; / *将COR描述符放在COR句柄* / OCIParamSet中（corhp，OCI_HTYPE_COMPLEXOBJECT，errhp，cordp，OCI_DTYPE_COMPLEXOBJECTCOMP，1）; <span class="bold">/ *固定采购订单* /</span> <span class="bold">OCIObjectPin（envhp，errhp，poref，corhp，OCI_PIN_LATEST，</span> <span class="bold">OCI_DURATION_SESSION，OCI_LOCK_NONE，（void **）＆po）;</span> / * free COR描述符和COR句柄* / OCIDescriptorFree（（void *）cordp，（ub4）OCI_DTYPE_COMPLEXOBJECTCOMP）; OCIHandleFree（（void *）corhp，（ub4）OCI_HTYPE_COMPLEXOBJECT）; <span class="bold">/ *迭代并打印此采购订单的订单项* /</span> <span class="bold">OCIIterCreate（envhp，errhp，po-&gt; line_items，＆itr）;</span> <span class="bold">/ *获取第一行项目* /</span> <span class="bold">OCIIterNext（envhp，errhp，itr，（void **）＆liref，（void **）0，＆eoc）;</span> <span class="bold">而（！eoc）/ *不是收集结束* /</span> <span class="bold">{</span> / * pin line item * / OCIObjectPin（envhp，errhp，* liref，（void *）0，OCI_PIN_RECENT，OCI_DURATION_SESSION，OCI_LOCK_NONE，（void **）＆li））; <span class="bold">display_line_item（LI）;</span> <span class="bold">/ *获取下一行项目* /</span> <span class="bold">OCIIterNext（envhp，errhp，itr，（void **）＆liref，（void **）0，＆eoc）;</span> <span class="bold">}</span>
</pre></div>
                        <!-- class="example" -->
                     </div>
                  </div>
               </div><a id="LNOCI16809"></a><div class="props_rev_3"><a id="GUID-05972451-AAD6-4929-848B-DE406B82AA0F" name="GUID-05972451-AAD6-4929-848B-DE406B82AA0F"></a><h4 id="LNOCI-GUID-05972451-AAD6-4929-848B-DE406B82AA0F" class="sect4"><span class="enumeration_section">19.3.12</span> OCI与对象的SQL访问</h4>
                  <div>
                     <p>如果应用程序必须操作对象图（通过对象引用相互关联），那么使用OCI接口而不是SQL接口访问对象会更有效。</p>
                     <p>使用SQL接口检索对象图可能需要执行多个<code class="codeph">SELECT</code>语句，这需要多次网络往返。使用OCI提供的复杂对象检索功能，应用程序可以在一个<code class="codeph">OCIObjectPin()</code>调用中检索对象图。
                     </p>
                     <p>考虑更新情况，其中应用程序检索对象图，并根据用户交互对其进行修改，然后希望在数据库中保持修改。使用SQL接口，应用程序必须执行多个<code class="codeph">UPDATE</code>语句来更新对象图。如果修改涉及创建新对象和删除现有对象，则还需要执行相应的<code class="codeph">INSERT</code>和<code class="codeph">DELETE</code>语句。此外，应用程序必须进行更多的簿记，例如跟踪表名，因为执行<code class="codeph">INSERT</code> ， <code class="codeph">UPDATE</code>和<code class="codeph">DELETE</code>语句需要此信息。
                     </p>
                     <p>使用<code class="codeph">OCICacheFlush()</code>函数，应用程序可以在单个操作中刷新所有修改（插入，删除和更新对象）。OCI完成所有簿记，因此在应用程序中需要较少的编码。为了操纵对象图，OCI不仅有效，而且还提供易于使用的界面。
                     </p>
                     <p>考虑一种不同的情况，其中应用程序必须在给定其<code class="codeph">REF</code>时获取对象。在OCI中，这是通过使用<code class="codeph">OCIObjectPin()</code>调用固定对象来实现的。在SQL接口中，这可以通过在<code class="codeph">SELECT</code>语句中取消引用<code class="codeph">REF</code>来实现（例如， <code class="codeph">SELECT DEREF(ref) from tbl;</code> ）。考虑在事务中多次取消引用相同<code class="codeph">REF</code> （对同一对象的引用）的情况。通过使用<code class="codeph">OCI_PIN_RECENT</code>选项调用<code class="codeph">OCIObjectPin()</code> ，对于事务，仅从服务器获取对象一次，并且同一<code class="codeph">REF</code>上的重复引脚返回指向高速缓存中的固定对象的指针。在SQL接口中，每次执行<code class="codeph">SELECT</code> <code class="codeph">DEREF...</code>语句都会导致从服务器获取对象。这将导致多次往返服务器和同一对象的多个副本。
                     </p>
                     <p>最后，考虑应用程序必须获取不可引用对象的情况，如下例所示：</p><pre class="oac_no_warn" dir="ltr">CREATE TABLE部门（deptno number，deptname varchar2（30），manager employee_t）;</pre><p>存储在<code class="codeph">manager</code>列中的<code class="codeph">employee_t</code>实例是不可引用的。您只能使用SQL接口来获取<code class="codeph">manager</code>列实例。但是，如果<code class="codeph">employee_t</code>具有任何<code class="codeph">REF</code>属性，则可以使用OCI调用来导航<code class="codeph">REF</code> 。</p>
                     <div class="infoboxnotealso" id="GUID-05972451-AAD6-4929-848B-DE406B82AA0F__GUID-BC35DF40-1BCF-45EA-92B0-3D0A7FB6FEF2">
                        <p class="notep1">也可以看看：</p>
                        <ul style="list-style-type:disc">
                           <li>
                              <p><a href="oci-pin-unpin-and-free-functions.html#GUID-89F29585-2F16-4FA3-B1E0-BDD83707CA62" title="引脚可引用对象。">OCIObjectPin（）</a></p>
                           </li>
                           <li>
                              <p><a href="oci-flush-or-refresh-functions.html#GUID-782180CB-D33E-42E0-AB4C-96ECDF651C1E" title="将已修改的持久对象刷新到服务器。">OCICacheFlush（）</a></p>
                           </li>
                        </ul>
                     </div>
                  </div>
               </div><a id="LNOCI16810"></a><div class="props_rev_3"><a id="GUID-86097867-CFAA-428C-AE6D-B08E45220DDD" name="GUID-86097867-CFAA-428C-AE6D-B08E45220DDD"></a><h4 id="LNOCI-GUID-86097867-CFAA-428C-AE6D-B08E45220DDD" class="sect4"><span class="enumeration_section">19.3.13</span>引脚数和取消固定</h4>
                  <div>
                     <p>对象缓存中的每个对象都有一个与之关联的<span class="italic">引脚数</span> 。
                     </p>
                     <p>引脚数指示同时访问对象的代码模块的数量。当对象第一次固定到缓存中时，引脚数设置为1。使用复杂对象检索预取的对象进入对象缓存，引脚数为零。</p>
                     <p>可以固定固定物体。这样做会使引脚数增加1。当一个进程使用完一个对象，它应该<span class="italic">取消固定</span>它，使用<code class="codeph">OCIObjectUnpin()</code>此调用将引脚数递减1。
                     </p>
                     <p>当对象的引脚数达到零时，如果需要，该对象有资格从缓存中老化，从而释放对象占用的内存空间。</p>
                     <p>通过调用<code class="codeph">OCIObjectPinCountReset()</code>可以显式地将对象的引脚数设置为零。
                     </p>
                     <p>应用程序可以通过调用<code class="codeph">OCICacheUnpin()</code>来<code class="codeph">OCICacheUnpin()</code>与特定连接相关的缓存中的所有对象。
                     </p>
                     <div class="infoboxnotealso" id="GUID-86097867-CFAA-428C-AE6D-B08E45220DDD__GUID-5903EAC4-A058-471B-AFDF-9BB06637860C">
                        <p class="notep1">也可以看看：</p>
                        <ul style="list-style-type:disc">
                           <li>
                              <p><a href="object-advanced-topics-in-oci.html#GUID-51E18790-5949-4D5B-9708-7749CA7B8E22" title="释放对象副本会将其从对象缓存中删除并释放其内存。">关于释放对象副本</a>以获取有关从高速缓存中删除具有零引脚数的对象以及从高速缓存中老化的对象的条件的更多信息</p>
                           </li>
                           <li>
                              <p><a href="oci-object-relational-programming.html#GUID-2F9466DE-9186-495E-92EE-B7FBAA65D6B9" title="The application must take specific steps to ensure that changes to objects by marking them and then flushing them are written in the database.">关于标记对象和</a>刷新<a href="oci-object-relational-programming.html#GUID-2F9466DE-9186-495E-92EE-B7FBAA65D6B9" title="应用程序必须采取特定步骤，以确保通过标记对象进行更改然后刷新对象将写入数据库。">更改</a>以获取有关显式刷新对象或整个缓存的信息</p>
                           </li>
                           <li>
                              <p><a href="oci-pin-unpin-and-free-functions.html#GUID-109DD260-8094-489C-A85C-AB27277E6D9B" title="取消一个对象。">OCIObjectUnpin（）</a></p>
                           </li>
                           <li>
                              <p><a href="oci-pin-unpin-and-free-functions.html#GUID-5D8C7FE3-8088-4A1C-8C36-19D0982FCAC3" title="完全取消对象，将其引脚数设置为零。">OCIObjectPinCountReset（）</a></p>
                           </li>
                           <li>
                              <p><a href="oci-pin-unpin-and-free-functions.html#GUID-B7E9C0B8-7888-456E-A8F1-1151354C37BF" title="取消持久对象。">OCICacheUnpin（）</a></p>
                           </li>
                        </ul>
                     </div>
                  </div>
               </div><a id="LNOCI72705"></a><a id="LNOCI16811"></a><div class="props_rev_3"><a id="GUID-D0FD9D2E-DAE1-4468-B90A-DE19B03CB0F3" name="GUID-D0FD9D2E-DAE1-4468-B90A-DE19B03CB0F3"></a><h4 id="LNOCI-GUID-D0FD9D2E-DAE1-4468-B90A-DE19B03CB0F3" class="sect4"><span class="enumeration_section">19.3.14</span> NULL指示符结构</h4>
                  <div>
                     <p>如果数据库表的行中的列没有值，则该列称为<code class="codeph">NULL</code> ，或者包含<code class="codeph">NULL</code> 。</p>
                     <p>两种不同类型的<code class="codeph">NULL</code>可以应用于对象：</p>
                     <ul style="list-style-type:disc">
                        <li>
                           <p>对象的任何属性都可以具有<code class="codeph">NULL</code>值。这表示该对象的该属性的值未知。
                           </p>
                        </li>
                        <li>
                           <p>对象实例可以是<span class="italic">原子空的</span> ，这意味着整个对象的值是未知的。
                           </p>
                        </li>
                     </ul>
                     <p>原子无效与不存在不同。原子<code class="codeph">NULL</code>实例仍然存在;它的价值尚不清楚。它可以被认为是没有数据的现有对象。
                     </p>
                     <p>在OCI中处理对象时，应用程序可以为应用程序使用的每种对象类型定义<span class="italic">NULL指示符结构</span> 。在大多数情况下，这样做只需要包含OTT生成的<code class="codeph">NULL</code>指示符结构以及结构声明。当包含OTT输出头文件时， <code class="codeph">NULL</code>指示器结构可供您的应用程序使用。
                     </p>
                     <p>对于每种类型， <code class="codeph">NULL</code>指示符结构包括一个原子<code class="codeph">NULL</code>指示符（其类型为<code class="codeph">OCIInd</code> ），以及该实例的每个属性的<code class="codeph">NULL</code>指示符。如果类型具有object属性，则<code class="codeph">NULL</code>指示符结构包括该属性的<code class="codeph">NULL</code>指示符结构。<a href="oci-object-relational-programming.html#GUID-D0FD9D2E-DAE1-4468-B90A-DE19B03CB0F3__BGBHFCEC">例19-6</a>显示了具有相应<code class="codeph">NULL</code>指示符结构的类型的C表示。
                     </p>
                     <div class="infoboxnote" id="GUID-D0FD9D2E-DAE1-4468-B90A-DE19B03CB0F3__GUID-DF1D2A98-7BA1-424D-A4E8-8D1FCCF35DEF">
                        <p class="notep1">注意：</p>
                        <p><code class="codeph">person_ind</code>的<code class="codeph">dependentsAge</code>字段指示整个varray（ <code class="codeph">person</code> <code class="codeph">dependentsAge</code>字段）是否为原子<code class="codeph">NULL</code> 。可以通过调用<code class="codeph">OCICollGetElem()</code>的<code class="codeph">elemind</code>参数来检索<code class="codeph">dependentsAge</code>的各个元素的<code class="codeph">NULL</code>信息。类似地， <code class="codeph">prevAddr</code>的字段<code class="codeph">person_ind</code>表示整个嵌套表（是否<code class="codeph">prevAddr</code>的场<code class="codeph">person</code> ）是原子<code class="codeph">NULL</code>或没有。可以通过调用<code class="codeph">OCICollGetElem()</code>的<code class="codeph">elemind</code>参数来检索<code class="codeph">prevAddr</code>的各个元素的<code class="codeph">NULL</code>信息。
                        </p>
                     </div>
                     <p>对于对象类型实例， <code class="codeph">NULL</code>指示符结构的第一个字段是原子<code class="codeph">NULL</code>指示符，其余字段是属性<code class="codeph">NULL</code>指示符，其布局类似于对象类型实例的属性的布局。
                     </p>
                     <p>检查原子<code class="codeph">NULL</code>指示符的值允许应用程序测试实例是否为原子<code class="codeph">NULL</code> 。检查任何其他允许应用程序测试该属性的<code class="codeph">NULL</code>状态，如以下代码示例所示：</p><pre class="oac_no_warn" dir="ltr">person_ind * my_person_ind if（my_person_ind  - &gt; _atomic == OCI_IND_NULL）printf（“instance is atomically NULL \ n”）; else if（my_person_ind  - &gt; fname == OCI_IND_NULL）printf（“fname属性为NULL \ n”）;</pre><p>在前面的示例中，将原子<code class="codeph">NULL</code>指示符或属性<code class="codeph">NULL</code>指示符之一的值与预定义值<code class="codeph">OCI_IND_NULL</code>进行比较，以测试它是否为<code class="codeph">NULL</code> 。以下预定义值可用于此类比较：</p>
                     <ul style="list-style-type:disc">
                        <li>
                           <p><code class="codeph">OCI_IND_NOTNULL</code> ，表示该值不为<code class="codeph">NULL</code></p>
                        </li>
                        <li>
                           <p><code class="codeph">OCI_IND_NULL</code> ，表示该值为<code class="codeph">NULL</code></p>
                        </li>
                        <li>
                           <p><code class="codeph">OCI_IND_BADNULL</code>表示封闭对象（或父对象）为<code class="codeph">NULL</code> 。这由PL / SQL使用，也可以称为INVALID_NULL。例如，如果类型实例为<code class="codeph">NULL</code> ，则其属性为INVALID_NULL。
                           </p>
                        </li>
                     </ul>
                     <p>使用函数<code class="codeph">OCIObjectGetInd()</code>来检索对象的<code class="codeph">NULL</code>指示符结构。
                     </p>
                     <p>如果更新其C结构中的属性，则还必须为该属性设置<code class="codeph">NULL</code>指示符：</p><pre class="oac_no_warn" dir="ltr">obj-&gt; attr1 = string1; OCIObjectGetInd（envhp，errhp，obj，＆ind）; ind-&gt; attr1 = OCI_IND_NOTNULL;</pre><div class="example" id="GUID-D0FD9D2E-DAE1-4468-B90A-DE19B03CB0F3__BGBHFCEC">
                        <p class="titleinexample">例19-6具有相应NULL指示结构的类型的C表示</p><pre class="oac_no_warn" dir="ltr">struct address {OCINumber no; OCIString * street; OCIString * state; OCIString * zip; }; typedef结构地址; struct address_ind {OCIInd _atomic; OCIInd no; OCIInd街; OCIInd州; OCIInd拉链; }; typedef struct address_ind address_ind; struct person {OCIString * fname; OCIString * lname; OCINumber年龄; OCIDate生日; OCIArray * dependentsAge; OCITable * prevAddr; OCIRaw * comment1; OCILobLocator * comment2;地址addr; OCIRef *配偶; }; typedef struct person person; struct person_ind {OCIInd _atomic; OCIInd fname; OCIInd lname; OCIInd年龄; OCIInd生日; OCIInd dependentsAge; OCIInd prevAddr; OCIInd评论1; OCIInd评论2; address_ind addr; OCIInd配偶; }; typedef struct person_ind person_ind;</pre></div>
                     <!-- class="example" -->
                     <div class="section">
                        <div class="infoboxnotealso" id="GUID-D0FD9D2E-DAE1-4468-B90A-DE19B03CB0F3__GUID-1AE2825E-B003-4634-B30B-3FC75EDF2DE7">
                           <p class="notep1">也可以看看：</p>
                           <ul style="list-style-type:disc">
                              <li>
                                 <p><a href="using-object-type-translator-in-oci.html#GUID-3D22CA8E-BE01-492F-BA85-DDD0CD3F4890" title="本章讨论了对象类型转换器（OTT），它用于将数据库对象类型和命名集合类型映射到C结构，以便在OCI应用程序中使用。">将对象类型转换器与OCI一起使用</a> ，以获取有关OTT生成的<code class="codeph">NULL</code>指示符结构的更多信息</p>
                              </li>
                              <li>
                                 <p><a href="oci-collection-and-iterator-functions.html#GUID-B28B3D65-EB7B-44BD-ADBA-DAC0C21DE90F" title="获取指向给定索引处元素的指针。">OCICollGetElem（）</a></p>
                              </li>
                              <li>
                                 <p><a href="oci-miscellaneous-object-functions.html#GUID-22B229C0-369E-453E-A8D6-C7F7DBB1E80C" title="检索独立实例的NULL指示符结构。">OCIObjectGetInd（）</a></p>
                              </li>
                           </ul>
                        </div>
                     </div>
                     <!-- class="section" -->
                  </div>
               </div><a id="LNOCI16812"></a><div class="props_rev_3"><a id="GUID-86418D8C-FA67-4B14-A5BC-7A075C6B4206" name="GUID-86418D8C-FA67-4B14-A5BC-7A075C6B4206"></a><h4 id="LNOCI-GUID-86418D8C-FA67-4B14-A5BC-7A075C6B4206" class="sect4"><span class="enumeration_section">19.3.15</span>关于创建对象</h4>
                  <div>
                     <p>OCI应用程序可以使用<code class="codeph">OCIObjectNew()</code>创建任何对象。
                     </p>
                     <p>要创建持久对象，应用程序必须指定新对象所在的对象表。可以通过调用<code class="codeph">OCIObjectPinTable()</code>来检索此值，并将其传递给<code class="codeph">table</code>参数。要创建临时对象，应用程序必须仅传递类型描述符对象（通过调用<code class="codeph">OCIDescribeAny()</code>检索）以获取正在创建的对象类型。
                     </p>
                     <p><code class="codeph">OCIObjectNew()</code>还可以通过传递<code class="codeph">typecode</code>参数的相应值来创建标量实例（例如， <code class="codeph">REF</code> ，LOB，字符串，原始，数字和日期）和集合（例如，varray和嵌套表）。
                     </p>
                     <p>本节包括以下主题： <a href="oci-object-relational-programming.html#GUID-B67C9341-734A-4B7F-98CA-50638FD9AC81" title="默认情况下，新创建的对象的所有属性都具有NULL值。">新对象的属性值</a> 。
                     </p>
                     <div class="infoboxnotealso" id="GUID-86418D8C-FA67-4B14-A5BC-7A075C6B4206__GUID-BB94F7BB-857F-4EAF-AA20-F603D3842B50">
                        <p class="notep1">也可以看看：</p>
                        <ul style="list-style-type:disc">
                           <li>
                              <p><a href="oci-miscellaneous-object-functions.html#GUID-2EFD6F01-A02F-4C5B-B20F-1EF841249056" title="创建独立实例。">OCIObjectNew（）</a></p>
                           </li>
                           <li>
                              <p><a href="oci-pin-unpin-and-free-functions.html#GUID-B08E296D-7D4F-4D8C-A0CF-16786E9993E8" title="将表对象固定指定的持续时间。">OCIObjectPinTable（）</a></p>
                           </li>
                           <li>
                              <p><a href="bind-define-describe-functions.html#GUID-AE9F73FB-DCC1-401E-8151-A8A89059163A" title="描述现有的模式和子模式对象。">OCIDescribeAny（）</a></p>
                           </li>
                        </ul>
                     </div>
                  </div><a id="LNOCI16814"></a><a id="LNOCI16813"></a><div class="props_rev_3"><a id="GUID-B67C9341-734A-4B7F-98CA-50638FD9AC81" name="GUID-B67C9341-734A-4B7F-98CA-50638FD9AC81"></a><h5 id="LNOCI-GUID-B67C9341-734A-4B7F-98CA-50638FD9AC81" class="sect5"><span class="enumeration_section">19.3.15.1</span>新对象的属性值</h5>
                     <div>
                        <p>默认情况下，新创建的对象的所有属性都具有<code class="codeph">NULL</code>值。
                        </p>
                        <div class="section">
                           <p>初始化属性数据后，用户必须将每个属性的相应<code class="codeph">NULL</code>状态更改为非<code class="codeph">NULL</code> 。</p>
                           <p>创建对象时，可以将属性设置为非<code class="codeph">NULL</code>值。这是通过使用<code class="codeph">OCIAttrSet()</code>将环境句柄的<code class="codeph">OCI_ATTR_OBJECT_NEWNOTNULL</code>属性设置为<code class="codeph">TRUE</code>来<code class="codeph">OCIAttrSet()</code> 。稍后可以通过将属性设置为<code class="codeph">FALSE</code>来关闭此模式。</p>
                           <p>如果<code class="codeph">OCI_ATTR_OBJECT_NEWNOTNULL</code>设置为<code class="codeph">TRUE</code> ，则<code class="codeph">OCIObjectNew()</code>创建非<code class="codeph">NULL</code>对象。对象的属性具有<a href="oci-object-relational-programming.html#GUID-B67C9341-734A-4B7F-98CA-50638FD9AC81__G475191" title="该表有2列。第1列是属性类型，第2列是对应的非NULL默认值。">表19-4中</a>描述的默认值，相应的<code class="codeph">NULL</code>指示符设置为<code class="codeph">NOT NULL</code> 。</p>
                        </div>
                        <!-- class="section" -->
                        <div class="tblformal" id="GUID-B67C9341-734A-4B7F-98CA-50638FD9AC81__G475191">
                           <p class="titleintable">表19-4新对象的属性值</p>
                           <table cellpadding="4" cellspacing="0" class="Formal" title="新对象的属性值" width="100%" border="1" summary="This table has 2 columns. Column 1 is the attribute type and column 2 is its corresponding non-NULL default value of the object." frame="hsides" rules="rows">
                              <thead>
                                 <tr align="left" valign="top">
                                    <th align="left" valign="bottom" width="31%" id="d136732e9636">属性类型</th>
                                    <th align="left" valign="bottom" width="69%" id="d136732e9639">默认值</th>
                                 </tr>
                              </thead>
                              <tbody>
                                 <tr align="left" valign="top">
                                    <td align="left" valign="top" width="31%" id="d136732e9644" headers="d136732e9636 "><pre class="oac_no_warn" dir="ltr">REF</pre></td>
                                    <td align="left" valign="top" width="69%" headers="d136732e9644 d136732e9639 ">
                                       <p>如果对象具有<code class="codeph">REF</code>属性，则用户必须在刷新对象之前将其设置为有效的<code class="codeph">REF</code> ，否则将返回错误</p>
                                    </td>
                                 </tr>
                                 <tr align="left" valign="top">
                                    <td align="left" valign="top" width="31%" id="d136732e9657" headers="d136732e9636 "><pre class="oac_no_warn" dir="ltr">日期</pre></td>
                                    <td align="left" valign="top" width="69%" headers="d136732e9657 d136732e9639 ">
                                       <p>Oracle数据库允许的最早可能日期，即公元前1月1日至4月4日午夜（相当于朱利安第1天）</p>
                                    </td>
                                 </tr>
                                 <tr align="left" valign="top">
                                    <td align="left" valign="top" width="31%" id="d136732e9664" headers="d136732e9636 "><pre class="oac_no_warn" dir="ltr">ANSI日期</pre></td>
                                    <td align="left" valign="top" width="69%" headers="d136732e9664 d136732e9639 ">
                                       <p>Oracle数据库允许的最早可能日期，01-JAN-4712 BCE（相当于Julian第1天）</p>
                                    </td>
                                 </tr>
                                 <tr align="left" valign="top">
                                    <td align="left" valign="top" width="31%" id="d136732e9671" headers="d136732e9636 "><pre class="oac_no_warn" dir="ltr">TIMESTAMP</pre></td>
                                    <td align="left" valign="top" width="69%" headers="d136732e9671 d136732e9639 ">
                                       <p>Oracle数据库允许的最早可能日期和时间，即公元前01年1月至4月17日午夜（相当于朱利安第1天）</p>
                                    </td>
                                 </tr>
                                 <tr align="left" valign="top">
                                    <td align="left" valign="top" width="31%" id="d136732e9678" headers="d136732e9636 "><pre class="oac_no_warn" dir="ltr">TIMESTAMP与时区</pre></td>
                                    <td align="left" valign="top" width="69%" headers="d136732e9678 d136732e9639 ">
                                       <p>Oracle数据库允许的最早可能日期和时间，即UTC（0：0）时区的午夜，01-JAN-4712 BCE（相当于Julian第1天）</p>
                                    </td>
                                 </tr>
                                 <tr align="left" valign="top">
                                    <td align="left" valign="top" width="31%" id="d136732e9685" headers="d136732e9636 "><pre class="oac_no_warn" dir="ltr">TIMESTAMP与当地时区</pre></td>
                                    <td align="left" valign="top" width="69%" headers="d136732e9685 d136732e9639 ">
                                       <p>Oracle数据库允许的最早可能日期和时间，即UTC（0：0）时区的午夜，01-JAN-4712 BCE（相当于Julian第1天）</p>
                                    </td>
                                 </tr>
                                 <tr align="left" valign="top">
                                    <td align="left" valign="top" width="31%" id="d136732e9692" headers="d136732e9636 "><pre class="oac_no_warn" dir="ltr">间隔年至月</pre></td>
                                    <td align="left" valign="top" width="69%" headers="d136732e9692 d136732e9639 ">
                                       <p><code class="codeph">间隔'0-0'年到月</code></p>
                                    </td>
                                 </tr>
                                 <tr align="left" valign="top">
                                    <td align="left" valign="top" width="31%" id="d136732e9700" headers="d136732e9636 "><pre class="oac_no_warn" dir="ltr">间隔第二天</pre></td>
                                    <td align="left" valign="top" width="69%" headers="d136732e9700 d136732e9639 ">
                                       <p><code class="codeph">INTERVAL'0 0：0：0'第二天到第二天</code></p>
                                    </td>
                                 </tr>
                                 <tr align="left" valign="top">
                                    <td align="left" valign="top" width="31%" id="d136732e9708" headers="d136732e9636 "><pre class="oac_no_warn" dir="ltr">浮动</pre></td>
                                    <td align="left" valign="top" width="69%" headers="d136732e9708 d136732e9639 ">
                                       <p>0</p>
                                    </td>
                                 </tr>
                                 <tr align="left" valign="top">
                                    <td align="left" valign="top" width="31%" id="d136732e9715" headers="d136732e9636 "><pre class="oac_no_warn" dir="ltr">数</pre></td>
                                    <td align="left" valign="top" width="69%" headers="d136732e9715 d136732e9639 ">
                                       <p>0</p>
                                    </td>
                                 </tr>
                                 <tr align="left" valign="top">
                                    <td align="left" valign="top" width="31%" id="d136732e9722" headers="d136732e9636 "><pre class="oac_no_warn" dir="ltr">DECIMAL</pre></td>
                                    <td align="left" valign="top" width="69%" headers="d136732e9722 d136732e9639 ">
                                       <p>0</p>
                                    </td>
                                 </tr>
                                 <tr align="left" valign="top">
                                    <td align="left" valign="top" width="31%" id="d136732e9730" headers="d136732e9636 "><pre class="oac_no_warn" dir="ltr">生的</pre></td>
                                    <td align="left" valign="top" width="69%" headers="d136732e9730 d136732e9639 ">
                                       <p>长度设置为0的原始数据。注意： <code class="codeph">RAW</code>属性的默认值与<code class="codeph">NULL RAW</code>属性的默认值相同。
                                       </p>
                                    </td>
                                 </tr>
                                 <tr align="left" valign="top">
                                    <td align="left" valign="top" width="31%" id="d136732e9743" headers="d136732e9636 "><pre class="oac_no_warn" dir="ltr">VARCHAR2，NVARCHAR2</pre></td>
                                    <td align="left" valign="top" width="69%" headers="d136732e9743 d136732e9639 ">
                                       <p><code class="codeph">OCIString</code> ，长度为0，第一个char设置为<code class="codeph">NULL</code> 。默认值与<code class="codeph">NULL</code>字符串属性的默认值相同。
                                       </p>
                                    </td>
                                 </tr>
                                 <tr align="left" valign="top">
                                    <td align="left" valign="top" width="31%" id="d136732e9758" headers="d136732e9636 "><pre class="oac_no_warn" dir="ltr">CHAR，NCHAR</pre></td>
                                    <td align="left" valign="top" width="69%" headers="d136732e9758 d136732e9639 ">
                                       <p><code class="codeph">OCIString</code> ，长度为0，第一个char设置为<code class="codeph">NULL</code> 。默认值与空字符串属性的默认值相同。
                                       </p>
                                    </td>
                                 </tr>
                                 <tr align="left" valign="top">
                                    <td align="left" valign="top" width="31%" id="d136732e9770" headers="d136732e9636 "><pre class="oac_no_warn" dir="ltr">VARCHAR</pre></td>
                                    <td align="left" valign="top" width="69%" headers="d136732e9770 d136732e9639 ">
                                       <p><code class="codeph">OCIString</code> ，长度为0，第一个char设置为<code class="codeph">NULL</code> 。默认值与空字符串属性的默认值相同。
                                       </p>
                                    </td>
                                 </tr>
                                 <tr align="left" valign="top">
                                    <td align="left" valign="top" width="31%" id="d136732e9782" headers="d136732e9636 "><pre class="oac_no_warn" dir="ltr">VARRAY</pre></td>
                                    <td align="left" valign="top" width="69%" headers="d136732e9782 d136732e9639 ">
                                       <p>0元素的集合</p>
                                    </td>
                                 </tr>
                                 <tr align="left" valign="top">
                                    <td align="left" valign="top" width="31%" id="d136732e9789" headers="d136732e9636 "><pre class="oac_no_warn" dir="ltr">嵌套表</pre></td>
                                    <td align="left" valign="top" width="69%" headers="d136732e9789 d136732e9639 ">
                                       <p>表有0个元素</p>
                                    </td>
                                 </tr>
                                 <tr align="left" valign="top">
                                    <td align="left" valign="top" width="31%" id="d136732e9796" headers="d136732e9636 "><pre class="oac_no_warn" dir="ltr">CLOB，NCLOB</pre></td>
                                    <td align="left" valign="top" width="69%" headers="d136732e9796 d136732e9639 ">
                                       <p>空<code class="codeph">CLOB</code></p>
                                    </td>
                                 </tr>
                                 <tr align="left" valign="top">
                                    <td align="left" valign="top" width="31%" id="d136732e9805" headers="d136732e9636 "><pre class="oac_no_warn" dir="ltr">BLOB</pre></td>
                                    <td align="left" valign="top" width="69%" headers="d136732e9805 d136732e9639 ">
                                       <p>空<code class="codeph">BLOB</code></p>
                                    </td>
                                 </tr>
                                 <tr align="left" valign="top">
                                    <td align="left" valign="top" width="31%" id="d136732e9814" headers="d136732e9636 "><pre class="oac_no_warn" dir="ltr">BFILE</pre></td>
                                    <td align="left" valign="top" width="69%" headers="d136732e9814 d136732e9639 ">
                                       <p>用户必须通过设置目录对象和文件名将<code class="codeph">BFILE</code>初始化为有效值。
                                       </p>
                                    </td>
                                 </tr>
                              </tbody>
                           </table>
                        </div>
                        <!-- class="inftblhruleinformal" -->
                        <div class="section">
                           <p class="subhead3" id="GUID-B67C9341-734A-4B7F-98CA-50638FD9AC81__GUID-AA0E4378-8BEE-4F9E-845F-CC60949218DA"></p>
                           <div class="infoboxnotealso" id="GUID-B67C9341-734A-4B7F-98CA-50638FD9AC81__GUID-A44593EA-2FB1-4202-B492-990F6AB964E1">
                              <p class="notep1">也可以看看：</p>
                              <ul style="list-style-type:disc">
                                 <li>
                                    <p><a href="handle-and-descriptor-functions.html#GUID-3741D7BD-7652-4D7A-8813-AC2AEA8D3B03" title="设置句柄或描述符的属性值。">OCIAttrSet（）</a></p>
                                 </li>
                                 <li>
                                    <p><a href="oci-miscellaneous-object-functions.html#GUID-2EFD6F01-A02F-4C5B-B20F-1EF841249056" title="创建独立实例。">OCIObjectNew（）</a></p>
                                 </li>
                              </ul>
                           </div>
                        </div>
                        <!-- class="section" -->
                     </div>
                  </div>
               </div><a id="LNOCI16815"></a><div class="props_rev_3"><a id="GUID-0C40C7DE-5268-4445-A7CB-93489FA326D4" name="GUID-0C40C7DE-5268-4445-A7CB-93489FA326D4"></a><h4 id="LNOCI-GUID-0C40C7DE-5268-4445-A7CB-93489FA326D4" class="sect4"><span class="enumeration_section">19.3.16</span>关于释放和复制对象</h4>
                  <div>
                     <p>使用<code class="codeph">OCIObjectFree()</code>释放由<code class="codeph">OCIObjectNew()</code>分配的内存。
                     </p>
                     <p>对象实例可以具有指向附加内存（辅助内存块）的指针的属性。</p>
                     <p>释放对象会释放为该对象分配的所有内存，包括关联的NULL指示符结构和任何辅助内存块。您既不必显式释放辅助内存块，也不必重新分配指针。这样做可能会导致内存泄漏和内存损坏。此过程在其生存期到期之前删除瞬态但不是持久性对象。应用程序应使用<code class="codeph">OCIObjectMarkDelete()</code>来删除持久对象。
                     </p>
                     <p>应用程序可以使用<code class="codeph">OCIObjectCopy()</code>将一个实例复制到同一类型的另一个实例。
                     </p>
                     <div class="infoboxnotealso" id="GUID-0C40C7DE-5268-4445-A7CB-93489FA326D4__GUID-356BC7F6-2300-4F35-9A0A-9C91493870AC">
                        <p class="notep1">也可以看看：</p>
                        <ul style="list-style-type:disc">
                           <li>
                              <p><a href="object-advanced-topics-in-oci.html#GUID-C4F12ECA-651F-4620-8761-C8EAA9F09BF5" title="存储器中的实例由实例的顶级存储器块，空指示器结构的顶级存储器以及可选的一些辅助存储器块组成。">实例的内存布局</a></p>
                           </li>
                           <li>
                              <p><a href="oci-navigational-and-type-functions.html#GUID-9F30DB5F-33CB-4CE6-8EFE-732B29E26727" title="本章介绍用于浏览从Oracle数据库检索的对象的OCI导航功能。">OCI导航和类型功能</a></p>
                           </li>
                           <li>
                              <p><a href="oci-miscellaneous-object-functions.html#GUID-2EFD6F01-A02F-4C5B-B20F-1EF841249056" title="创建独立实例。">OCIObjectNew（）</a></p>
                           </li>
                           <li>
                              <p><a href="oci-pin-unpin-and-free-functions.html#GUID-0814B033-C25C-4B4C-8968-4C0B86C2E744" title="释放和取消对象实例。">OCIObjectFree（）</a></p>
                           </li>
                           <li>
                              <p><a href="oci-mark-or-unmark-object-cache-functions.html#GUID-46497858-8E6C-4920-857C-83FFC8B0F7C1" title="在给定指向实例的指针时，将独立实例标记为已删除。">OCIObjectMarkDelete（）</a></p>
                           </li>
                           <li>
                              <p><a href="oci-miscellaneous-object-functions.html#GUID-73C98F89-47E5-4B82-B869-731F30F011B0" title="将源实例复制到目标。">OCIObjectCopy（）</a></p>
                           </li>
                        </ul>
                        <p></p>
                     </div>
                  </div>
               </div><a id="LNOCI16816"></a><div class="props_rev_3"><a id="GUID-438ED438-C738-4035-96A1-B2E902C308F2" name="GUID-438ED438-C738-4035-96A1-B2E902C308F2"></a><h4 id="LNOCI-GUID-438ED438-C738-4035-96A1-B2E902C308F2" class="sect4"><span class="enumeration_section">19.3.17</span>对象引用和类型引用</h4>
                  <div>
                     <p>OCI的对象扩展为应用程序提供了使用指针或引用访问对象内容的灵活性。</p>
                     <p>OCI提供函数<code class="codeph">OCIObjectGetObjectRef()</code>以在给定对象的指针时返回对对象的引用。
                     </p>
                     <p>对于也想访问对象类型信息的应用程序，OCI提供函数<code class="codeph">OCIObjectGetProperty()</code>以在给定指向对象的指针时返回对对象的类型描述符对象（TDO）的引用。
                     </p>
                     <p>当创建基于具有系统生成的对象标识符（OID）的对象表的持久对象时，可以通过使用<code class="codeph">OCIObjectGetObjectRef()</code>立即获得对该对象的引用。但是，当持久对象基于对象视图或基于主键的OID的对象表时，必须首先设置属于主键的所有属性，然后才能获得引用。
                     </p>
                     <div class="infoboxnotealso" id="GUID-438ED438-C738-4035-96A1-B2E902C308F2__GUID-C18DC557-A126-471A-8A9D-0EECFE84472B">
                        <p class="notep1">也可以看看：</p>
                        <ul style="list-style-type:disc">
                           <li>
                              <p><a href="oci-miscellaneous-object-functions.html#GUID-487BE97C-C3CE-49C6-9E8D-62BFCE7980F5" title="返回对给定持久对象的引用。">OCIObjectGetObjectRef（）</a></p>
                           </li>
                           <li>
                              <p><a href="oci-get-object-status-functions.html#GUID-B65AA4FB-E4FF-4062-927E-4C62900D59C1" title="检索对象的给定属性。">OCIObjectGetProperty（）</a></p>
                           </li>
                           <li>
                              <p><a href="oci-miscellaneous-object-functions.html#GUID-487BE97C-C3CE-49C6-9E8D-62BFCE7980F5" title="返回对给定持久对象的引用。">OCIObjectGetObjectRef（）</a></p>
                           </li>
                        </ul>
                     </div>
                  </div>
               </div><a id="LNOCI72706"></a><a id="LNOCI16817"></a><div class="props_rev_3"><a id="GUID-8173B469-7AE8-426B-AD60-A2937B417F7C" name="GUID-8173B469-7AE8-426B-AD60-A2937B417F7C"></a><h4 id="LNOCI-GUID-8173B469-7AE8-426B-AD60-A2937B417F7C" class="sect4"><span class="enumeration_section">19.3.18使用</span>基于主键的OID创建基于对象视图和对象表的对象</h4>
                  <div>
                     <p>应用程序可以使用<code class="codeph">OCIObjectNew()</code>调用来创建基于对象视图的对象，或者使用基于主键的对象标识符（OID）创建对象表。
                     </p>
                     <div class="section">
                        <p>由于此类视图和表的对象标识符基于属性值，因此应用程序必须使用<code class="codeph">OCIObjectSetAttr()</code>来设置属于主键的所有属性。一旦设置了属性值，应用程序就可以通过调用<code class="codeph">OCIObjectGetObjectRef()</code>根据属性值获取对象引用。
                        </p>
                        <p>此过程包括以下步骤：</p>
                     </div>
                     <!-- class="section" -->
                     <ol>
                        <li><span>固定新对象所基于的对象视图或对象表。</span></li>
                        <li><span>使用<code class="codeph">OCIObjectNew()</code>创建一个新对象，将句柄传递给通过步骤1中的引脚操作获得的表或视图。</span></li>
                        <li><span>使用<code class="codeph">OCIObjectSetAttr()</code>填充对象属性的必要值。这些必须包括构成对象表或对象视图的用户定义的对象标识符的那些属性。</span></li>
                        <li><span>使用<code class="codeph">OCIObjectNew()</code>分配对象引用，将句柄传递给通过步骤1中的引脚操作获得的表或视图。</span></li>
                        <li><span>如有必要，使用<code class="codeph">OCIObjectGetObjectRef()</code>获取对象的基于主键的引用。如果需要，请返回步骤2以创建更多对象。</span></li>
                        <li><span>将新创建的对象刷新到服务器。</span></li>
                     </ol>
                     <div class="example" id="GUID-8173B469-7AE8-426B-AD60-A2937B417F7C__BGBFGJII">
                        <p class="titleinexample">示例19-7为对象视图创建新对象</p><pre class="oac_no_warn" dir="ltr">void object_view_new（）{void * table; OCIRef * pkref; void * object; OCIType * emptdo; .../ *设置服务上下文，错误句柄等等。* / .../ *固定对象视图* / OCIObjectPinTable（envp，errorp，svctx，“HR”，strlen（“HR”），“EMP_VIEW”，strlen（“EMP_VIEW”），（void *）0，OCI_DURATION_SESSION，（void ** ）＆table）; / *创建一个新的对象实例* / OCIObjectNew（envp，errorp，svctx，OCI_TYPECODE_OBJECT，（OCIType *）emptdo，table，OCI_DURATION_SESSION，FALSE，＆object）; / *填充“object”* / OCIObjectSetAttr（...）的属性; .../ *分配对象引用* / OCIObjectNew（envp，errorp，svctx，OCI_TYPECODE_REF，（OCIType *）0，（void *）0，OCI_DURATION_SESSION，TRUE，＆pkref）; / *使用OCIObjectGetObjectRef * / OCIObjectGetObjectRef（envp，errorp，object，pkref）获取引用; .../ *将新对象刷新到服务器* / ...} / *结束函数* /</pre></div>
                     <!-- class="example" -->
                     <div class="section">
                        <p><a href="oci-object-relational-programming.html#GUID-8173B469-7AE8-426B-AD60-A2937B417F7C__BGBFGJII">示例19-7</a>显示了如何实现此过程以在<code class="codeph">HR</code>模式中为<code class="codeph">emp_view</code>对象视图创建新对象。
                        </p>
                        <div class="infoboxnotealso" id="GUID-8173B469-7AE8-426B-AD60-A2937B417F7C__GUID-80F4A320-95E3-4E70-94E0-8531B78510F4">
                           <p class="notep1">也可以看看：</p>
                           <ul style="list-style-type:disc">
                              <li>
                                 <p><a href="oci-miscellaneous-object-functions.html#GUID-2EFD6F01-A02F-4C5B-B20F-1EF841249056" title="创建独立实例。">OCIObjectNew（）</a></p>
                              </li>
                              <li>
                                 <p><a href="oci-miscellaneous-object-functions.html#GUID-D1353EB4-5619-45F4-A787-1559D70AEA91" title="设置对象属性。">OCIObjectSetAttr（）</a></p>
                              </li>
                              <li>
                                 <p><a href="oci-miscellaneous-object-functions.html#GUID-487BE97C-C3CE-49C6-9E8D-62BFCE7980F5" title="返回对给定持久对象的引用。">OCIObjectGetObjectRef（）</a></p>
                              </li>
                           </ul>
                        </div>
                     </div>
                     <!-- class="section" -->
                  </div>
               </div><a id="LNOCI16818"></a><div class="props_rev_3"><a id="GUID-3F14366D-D427-4393-A354-4EC7D6E8712F" name="GUID-3F14366D-D427-4393-A354-4EC7D6E8712F"></a><h4 id="LNOCI-GUID-3F14366D-D427-4393-A354-4EC7D6E8712F" class="sect4"><span class="enumeration_section">19.3.19</span>对象应用程序中的错误处理</h4>
                  <div>
                     <p>就像任何其他OCI应用程序一样。</p>
                     <p>无论应用程序是否使用对象，OCI应用程序中的错误处理都是相同的。</p>
                     <div class="infoboxnotealso" id="GUID-3F14366D-D427-4393-A354-4EC7D6E8712F__GUID-154EE2B2-23A0-45A8-A74A-A9B75781EAFE">
                        <p class="notep1">也可以看看：</p>
                        <p>有关函数返回码和错误消息的详细信息，请参阅<a href="oci-programming-basics.html#GUID-39339E95-A79E-43BD-B57E-4DB536CB3475" title="OCI函数调用具有一组返回码。">OCI中的错误处理</a></p>
                     </div>
                  </div>
               </div>
            </div><a id="LNOCI16819"></a><div class="props_rev_3"><a id="GUID-CDE560AC-9FE0-4393-9EDC-0648DB38C5C9" name="GUID-CDE560AC-9FE0-4393-9EDC-0648DB38C5C9"></a><h3 id="LNOCI-GUID-CDE560AC-9FE0-4393-9EDC-0648DB38C5C9" class="sect3"><span class="enumeration_section">19.4</span>关于类型继承</h3>
               <div>
                  <p>对象的类型继承与C ++和Java中的继承有许多相似之处。</p>
                  <p>您可以将对象类型创建为现有对象类型的<span class="italic">子</span>类型。据说子类型继承了<span class="italic">超类型的</span>所有属性和方法（成员函数和过程），这是原始类型。仅支持单继承;一个对象不能有多个超类型。子类型可以向其继承的属性和方法添加新属性和方法。它还可以覆盖（重新定义其任何继承方法的实现）。据说子类型<span class="italic">扩展</span> （即继承）其超类型。
                  </p>
                  <p>例如，类型<code class="codeph">Person_t</code>可以具有子类型<code class="codeph">Student_t</code>和子类型<code class="codeph">Employee_t</code> 。反过来， <code class="codeph">Student_t</code>可以有自己的子类型<code class="codeph">PartTimeStudent_t</code> 。类型声明必须具有<code class="codeph">NOT</code> <code class="codeph">FINAL</code>标志，以便它可以具有子类型。默认值为<code class="codeph">FINAL</code> ，表示该类型不具有子类型。
                  </p>
                  <p>本章到目前为止讨论的所有类型都是<code class="codeph">FINAL</code> 。在Oracle Database 9.0之前开发的应用程序中的所有类型都是<code class="codeph">FINAL</code> 。 <code class="codeph">FINAL</code>的类型可以更改为<code class="codeph">NOT</code> <code class="codeph">FINAL</code> 。没有子类型的<code class="codeph">NOT</code> <code class="codeph">FINAL</code>类型可以更改为<code class="codeph">FINAL</code> 。对于我们的示例， <code class="codeph">Person_t</code>被声明为<code class="codeph">NOT</code> <code class="codeph">FINAL</code> ：</p><pre class="oac_no_warn" dir="ltr">CREATE TYPE Person_t AS OBJECT（ssn NUMBER，name VARCHAR2（30），address VARCHAR2（100））NOT FINAL;</pre><p>子类型继承其超类型中声明的所有属性和方法。它还可以声明新的属性和方法，这些属性和方法必须具有与超类型不同的名称。关键字<code class="codeph">UNDER</code>标识超类型，如下所示：</p><pre class="oac_no_warn" dir="ltr">CREATE TYPE Student_t UNDER Person_t（deptid NUMBER，major VARCHAR2（30））NOT FINAL;</pre><p>新声明的属性<code class="codeph">deptid</code>和<code class="codeph">major</code>属于子类型<code class="codeph">Student_t</code> 。子类型<code class="codeph">Employee_t</code>被声明为，例如：</p><pre class="oac_no_warn" dir="ltr">CREATE TYPE Employee_t UNDER Person_t（empid NUMBER，mgr VARCHAR2（30））;</pre><p>有关此示例的OTT生成的结果结构，请参阅<a href="using-object-type-translator-in-oci.html#GUID-4009C803-B151-4836-AF6F-741E9F072466" title="为了支持对象的类型继承，OTT通过使用特殊名称声明封装结构中的继承属性来生成表示对象子类型的C结构" _supe=",=" ="">OTT支持类型继承</a> 。
                  </p>
                  <p>此子类型<code class="codeph">Student_t</code>可以有自己的子类型，例如<code class="codeph">PartTimeStudent_t</code> ：</p><pre class="oac_no_warn" dir="ltr">创建类型PartTimeStudent_t UNDER Student_t（numhours NUMBER）;</pre><div class="p">本节包括以下主题：<ul style="list-style-type:disc">
                        <li>
                           <p><a href="oci-object-relational-programming.html#GUID-B6C504E2-F569-40BC-85DB-E2B67290E947" title="对象类型属性和集合元素类型是可替换的。">可替代性</a></p>
                        </li>
                        <li>
                           <p><a href="oci-object-relational-programming.html#GUID-0BB558F8-6417-478F-A70C-AFC67A6F000E" title="可以将类型声明为NOT INSTANTIABLE，这意味着该类型没有构造函数（默认或用户定义）。">不可行的类型和方法</a></p>
                        </li>
                        <li>
                           <p><a href="oci-object-relational-programming.html#GUID-F3822F4A-1873-4242-82F6-2A7554D07E64" title="列出支持类型继承的调用。">OCI支持类型继承</a></p>
                        </li>
                        <li>
                           <p><a href="oci-object-relational-programming.html#GUID-35D41A85-9417-4813-8DD6-544868C89D0B" title="对象类型转换器（OTT）通过首先声明被封装的结构中的继承属性来支持对象的类型继承" _supe=",=" ="">OTT支持类型继承</a></p>
                        </li>
                     </ul>
                  </div>
                  <div class="infoboxnotealso" id="GUID-CDE560AC-9FE0-4393-9EDC-0648DB38C5C9__GUID-644C72BB-56F1-49C2-9CAD-B61DE1E643AA">
                     <p class="notep1">也可以看看：</p>
                     <p><a href="../adobj/inheritance-in-sql-object-types.html#ADOBJ00205" target="_blank"><span><cite>Oracle数据库对象关系开发人员指南，</cite></span></a>用于更完整地讨论类型继承</p>
                  </div>
               </div><a id="LNOCI16820"></a><div class="props_rev_3"><a id="GUID-B6C504E2-F569-40BC-85DB-E2B67290E947" name="GUID-B6C504E2-F569-40BC-85DB-E2B67290E947"></a><h4 id="LNOCI-GUID-B6C504E2-F569-40BC-85DB-E2B67290E947" class="sect4"><span class="enumeration_section">19.4.1</span>可替代性</h4>
                  <div>
                     <p>对象类型属性和集合元素类型是可替换的。</p>
                     <p><a href="../adobj/glossary.html#ADOBJ7633" target="_blank"><span class="italic">多态性</span></a>的好处部分源于财产的<span class="italic">可替代性</span> 。可替代性允许最初为超类型编写的代码使用某些子类型的值，而不需要事先知道子类型的任何特定知识。子类型值对周围的代码起作用，就像超类型的值一样，即使它可能在其特化方法中使用不同的机制。
                     </p>
                     <p>实例可替代性是指在根据超类型声明的上下文中使用子类型的对象值的能力。<code class="codeph">REF</code>可替代性是指将<code class="codeph">REF</code>用于根据<code class="codeph">REF</code>对超类型声明的上下文中的子类型的能力。
                     </p>
                     <p><code class="codeph">REF</code>类型属性是可替换的;也就是说，定义为<code class="codeph">REF</code> T的属性可以将<code class="codeph">REF</code>保存到T的实例或其任何子类型。
                     </p>
                     <p>对象类型属性是可替换的;定义为（对象）类型T的属性可以包含T或其任何子类型的实例。</p>
                     <p>集合元素类型是可替代的;如果定义T类型的元素集合，它可以保存T类型及其任何子类型的实例。以下是对象属性可替换性的示例：</p><pre class="oac_no_warn" dir="ltr">CREATE TYPE Book_t AS OBJECT（标题VARCHAR2（30），作者Person_t / * substitutable * /）;</pre><p>因此， <code class="codeph">Book_t</code>实例可以通过指定一个标题字符串和一个创建<code class="codeph">Person_t</code> （或任何亚型<code class="codeph">Person_t</code> ）实例：</p><pre class="oac_no_warn" dir="ltr">Book_t（'我的Oracle体验'，Employee_t（12345，'Joe'，'SF'，1111，NULL））</pre></div>
               </div><a id="LNOCI16821"></a><div class="props_rev_3"><a id="GUID-0BB558F8-6417-478F-A70C-AFC67A6F000E" name="GUID-0BB558F8-6417-478F-A70C-AFC67A6F000E"></a><h4 id="LNOCI-GUID-0BB558F8-6417-478F-A70C-AFC67A6F000E" class="sect4"><span class="enumeration_section">19.4.2</span>不可用的类型和方法</h4>
                  <div>
                     <p>可以将类型声明为<code class="codeph">NOT</code> <code class="codeph">INSTANTIABLE</code> ，这意味着该类型没有构造函数（默认或用户定义）。
                     </p>
                     <p>因此，不可能构造这种类型的实例。典型的用法是为这种类型定义可实例化的子类型。以下是此属性的使用方式：</p><pre class="oac_no_warn" dir="ltr">CREATE TYPE Address_t AS OBJECT（...）不可能不是最终的; CREATE TYPE USAddress_t UNDER Address_t（...）; CREATE TYPE IntlAddress_t UNDER Address_t（...）;</pre><p>一个类型的方法可以被声明为<code class="codeph">NOT</code> <code class="codeph">INSTANTIABLE</code> 。将方法声明为<code class="codeph">NOT</code> <code class="codeph">INSTANTIABLE</code>意味着该类型未提供该方法的实现。此外，必须将包含任何<code class="codeph">NOT</code> <code class="codeph">INSTANTIABLE</code>方法的类型声明为<code class="codeph">NOT</code> <code class="codeph">INSTANTIABLE</code> 。例如：</p><pre class="oac_no_warn" dir="ltr">创建类型T作为对象（x数字，不是不可用的成员函数func1（）返回数字）不可能不是最终的;</pre><p><code class="codeph">NOT</code> <code class="codeph">INSTANTIABLE</code>类型的子类型可以覆盖超类型的任何<code class="codeph">NOT</code> <code class="codeph">INSTANTIABLE</code>方法并提供具体实现。如果剩余任何<code class="codeph">NOT</code> <code class="codeph">INSTANTIABLE</code>方法，则子类型也必须声明为<code class="codeph">NOT</code> <code class="codeph">INSTANTIABLE</code> 。</p>
                     <p>可以在可实例化的超类型下定义<code class="codeph">NOT</code> <code class="codeph">INSTANTIABLE</code>子类型。将<code class="codeph">NOT</code> <code class="codeph">INSTANTIABLE</code>类型声明为<code class="codeph">FINAL</code>是没有用的，是不允许的。
                     </p>
                  </div>
               </div><a id="LNOCI16822"></a><div class="props_rev_3"><a id="GUID-F3822F4A-1873-4242-82F6-2A7554D07E64" name="GUID-F3822F4A-1873-4242-82F6-2A7554D07E64"></a><h4 id="LNOCI-GUID-F3822F4A-1873-4242-82F6-2A7554D07E64" class="sect4"><span class="enumeration_section">19.4.3</span> OCI对类型继承的支持</h4>
                  <div>
                     <p>列出支持类型继承的调用。</p>
                     <div class="p">以下调用支持类型继承：<ul style="list-style-type:disc">
                           <li>
                              <p><a href="oci-object-relational-programming.html#GUID-526C7873-DC33-481B-99D8-38B32F1CC8EA" title="OCIDescribeAny（）函数提供特定于继承类型的信息。">OCIDescribeAny（）</a></p>
                           </li>
                           <li>
                              <p><a href="oci-object-relational-programming.html#GUID-5247AD1D-22A0-4677-B078-3ECD8ACF4C1C" title="OCI绑定函数支持REF，实例和集合元素可替代性（子类型实例可以在需要超类型的地方传递）。">绑定和定义函数</a></p>
                           </li>
                           <li>
                              <p><a href="oci-object-relational-programming.html#GUID-1E9EB858-DE41-4A8D-8A6B-AAF243716B8E" title="OCIObjectGetTypeRef（）函数返回输入对象的最特定类型的TDO的REF。">OCIObjectGetTypeRef（）</a></p>
                           </li>
                           <li>
                              <p><a href="oci-object-relational-programming.html#GUID-303EC2E8-F01C-46A1-A331-EAFDF0F03C50" title="OCIObjectCopy（）函数将源实例的内容复制到目标实例。">OCIObjectCopy（）</a></p>
                           </li>
                           <li>
                              <p><a href="oci-object-relational-programming.html#GUID-AC5360EB-7E3A-460F-988B-45B70260EE7C" title="input元素可以是声明类型的子类型的实例。">OCICollAssignElem（）</a></p>
                           </li>
                           <li>
                              <p><a href="oci-object-relational-programming.html#GUID-D26E3FFD-7C2F-4CC5-BEB5-3502CEE1FA4C" title="input元素可以是声明类型的子类型的实例。">OCICollAppend（）</a></p>
                           </li>
                           <li>
                              <p><a href="oci-object-relational-programming.html#GUID-DE1ECBD6-306A-451A-8FF7-CDAEA6489938" title="返回的collection元素可以是声明类型的子类型的实例。">OCICollGetElem（）</a></p>
                           </li>
                        </ul>
                     </div>
                  </div><a id="LNOCI16823"></a><div class="props_rev_3"><a id="GUID-526C7873-DC33-481B-99D8-38B32F1CC8EA" name="GUID-526C7873-DC33-481B-99D8-38B32F1CC8EA"></a><h5 id="LNOCI-GUID-526C7873-DC33-481B-99D8-38B32F1CC8EA" class="sect5"><span class="enumeration_section">19.4.3.1</span> OCIDescribeAny（）</h5>
                     <div>
                        <p><code class="codeph">OCIDescribeAny()</code>函数提供特定于继承类型的信息。
                        </p>
                        <p>已为继承类型的属性添加了其他属性。例如，您可以获取类型的超类型。</p>
                        <div class="infoboxnotealso" id="GUID-526C7873-DC33-481B-99D8-38B32F1CC8EA__GUID-26924988-0B03-4E7F-BA3E-DDC42303962D">
                           <p class="notep1">也可以看看：</p>
                           <ul style="list-style-type:disc">
                              <li>
                                 <p><a href="describing-schema-metadata.html#GUID-6607CBC1-27BB-425D-A54C-0DDD098D1684__G453808" title="该表有3列。第1列是属性名称，第2列是其描述，第3列是相应的属性数据类型。">表8-7</a>和<a href="describing-schema-metadata.html#GUID-9D9DBD87-CFE9-415F-A2DD-85B0B01F65EE__G454036" title="该表有3列。第1列是属性名称，第2列是其描述，第3列是相应的属性数据类型。">表8-9</a>了解<code class="codeph">OCIDescribeAny()</code>可用于描述现有模式和子模式对象的属性</p>
                              </li>
                              <li>
                                 <p><a href="bind-define-describe-functions.html#GUID-AE9F73FB-DCC1-401E-8151-A8A89059163A" title="描述现有的模式和子模式对象。">OCIDescribeAny（）</a></p>
                              </li>
                           </ul>
                        </div>
                     </div>
                  </div><a id="LNOCI16824"></a><div class="props_rev_3"><a id="GUID-5247AD1D-22A0-4677-B078-3ECD8ACF4C1C" name="GUID-5247AD1D-22A0-4677-B078-3ECD8ACF4C1C"></a><h5 id="LNOCI-GUID-5247AD1D-22A0-4677-B078-3ECD8ACF4C1C" class="sect5"><span class="enumeration_section">19.4.3.2</span>绑定和定义函数</h5>
                     <div>
                        <p>OCI绑定函数支持<code class="codeph">REF</code> ，实例和集合元素可替代性（子类型实例可以在需要超类型的地方传递）。
                        </p>
                        <p>OCI绑定接口没有任何更改，因为所有类型检查和转换都在服务器端完成。</p>
                        <p>OCI定义函数也支持可替代性（子类型实例可以被提取到声明为保存超类型的定义变量中）。但是，这可能需要系统调整内存大小以保存子类型实例。</p>
                        <div class="infoboxnote" id="GUID-5247AD1D-22A0-4677-B078-3ECD8ACF4C1C__GUID-C4B560AE-62C0-4033-90D7-C7DE56BE8164">
                           <p class="notep1">注意：</p>
                           <p>在这种情况下，客户端程序必须使用从对象缓存中分配的对象（因此可以调整大小）。</p>
                        </div>
                        <p>如果值可能是多态的，则客户端不应使用结构（在堆栈上分配）作为define变量。</p>
                        <div class="infoboxnotealso" id="GUID-5247AD1D-22A0-4677-B078-3ECD8ACF4C1C__GUID-46BB6E07-87C2-42A4-AF15-686CB7C01194">
                           <p class="notep1">也可以看看：</p>
                           <p><a href="object-relational-data-types-in-oci.html#GUID-C62AEE74-0CC5-4FAB-A91F-997F71C49C2C" title="本章描述了可由OCI数据类型映射和操作函数操作的每种数据类型的用途和结构。">OCI中的对象关系数据类型，</a>用于绑定和定义进程的详细信息</p>
                        </div>
                     </div>
                  </div><a id="LNOCI16825"></a><div class="props_rev_3"><a id="GUID-1E9EB858-DE41-4A8D-8A6B-AAF243716B8E" name="GUID-1E9EB858-DE41-4A8D-8A6B-AAF243716B8E"></a><h5 id="LNOCI-GUID-1E9EB858-DE41-4A8D-8A6B-AAF243716B8E" class="sect5"><span class="enumeration_section">19.4.3.3</span> OCIObjectGetTypeRef（）</h5>
                     <div>
                        <p><code class="codeph">OCIObjectGetTypeRef()</code>函数返回输入对象的最特定类型的TDO的<code class="codeph">REF</code> 。
                        </p>
                        <p>如果用户没有最特定类型的权限，则此操作将返回错误。</p>
                        <div class="infoboxnotealso" id="GUID-1E9EB858-DE41-4A8D-8A6B-AAF243716B8E__GUID-F6E77A7C-C370-4FEA-8AA2-E39CD2D6591D">
                           <p class="notep1">也可以看看：</p>
                           <p><a href="oci-miscellaneous-object-functions.html#GUID-9C83F766-C8A3-48A0-A7D5-2BF4037C2B32" title="返回对独立实例的类型描述符对象（TDO）的引用。">OCIObjectGetTypeRef（）</a></p>
                        </div>
                     </div>
                  </div><a id="LNOCI16826"></a><div class="props_rev_3"><a id="GUID-303EC2E8-F01C-46A1-A331-EAFDF0F03C50" name="GUID-303EC2E8-F01C-46A1-A331-EAFDF0F03C50"></a><h5 id="LNOCI-GUID-303EC2E8-F01C-46A1-A331-EAFDF0F03C50" class="sect5"><span class="enumeration_section">19.4.3.4</span> OCIObjectCopy（）</h5>
                     <div>
                        <p><code class="codeph">OCIObjectCopy()</code>函数将源实例的内容复制到目标实例。
                        </p>
                        <p>源实例和目标实例必须属于同一类型。无法在超类型和子类型之间进行复制。</p>
                        <p>类似地， <code class="codeph">tdo</code>参数必须描述与源和目标对象相同的对象类型，并且不得引用源和目标对象的子类型或超类型。
                        </p>
                        <div class="infoboxnotealso" id="GUID-303EC2E8-F01C-46A1-A331-EAFDF0F03C50__GUID-7769C6D3-AD4F-469D-B3E9-868F57BD9B05">
                           <p class="notep1">也可以看看：</p>
                           <p><a href="oci-miscellaneous-object-functions.html#GUID-73C98F89-47E5-4B82-B869-731F30F011B0" title="将源实例复制到目标。">OCIObjectCopy（）</a></p>
                        </div>
                     </div>
                  </div><a id="LNOCI16827"></a><div class="props_rev_3"><a id="GUID-AC5360EB-7E3A-460F-988B-45B70260EE7C" name="GUID-AC5360EB-7E3A-460F-988B-45B70260EE7C"></a><h5 id="LNOCI-GUID-AC5360EB-7E3A-460F-988B-45B70260EE7C" class="sect5"><span class="enumeration_section">19.4.3.5</span> OCICollAssignElem（）</h5>
                     <div>
                        <p>input元素可以是声明类型的子类型的实例。</p>
                        <p>如果集合的类型为<code class="codeph">Person_t</code> ，则可以使用<code class="codeph">OCICollAssignElem()</code>函数将<code class="codeph">Employee_t</code>实例指定为集合的元素。
                        </p>
                        <div class="infoboxnotealso" id="GUID-AC5360EB-7E3A-460F-988B-45B70260EE7C__GUID-3745B2EB-BF16-4A2A-AC73-A486AA778EDA">
                           <p class="notep1">也可以看看：</p>
                           <p><a href="oci-collection-and-iterator-functions.html#GUID-BDA5C09D-9470-4204-9A56-3070F64D8E91" title="将给定元素值elem分配给coll [index]处的元素。">OCICollAssignElem（）</a></p>
                        </div>
                     </div>
                  </div><a id="LNOCI16828"></a><div class="props_rev_3"><a id="GUID-D26E3FFD-7C2F-4CC5-BEB5-3502CEE1FA4C" name="GUID-D26E3FFD-7C2F-4CC5-BEB5-3502CEE1FA4C"></a><h5 id="LNOCI-GUID-D26E3FFD-7C2F-4CC5-BEB5-3502CEE1FA4C" class="sect5"><span class="enumeration_section">19.4.3.6</span> OCICollAppend（）</h5>
                     <div>
                        <p>input元素可以是声明类型的子类型的实例。</p>
                        <p>如果集合的类型为<code class="codeph">Person_t</code> ，则可以使用<code class="codeph">OCICollAppend()</code>函数将<code class="codeph">Employee_t</code>实例附加到集合中。
                        </p>
                        <div class="infoboxnotealso" id="GUID-D26E3FFD-7C2F-4CC5-BEB5-3502CEE1FA4C__GUID-6244EC9C-276B-4C81-AD44-B73560D61B4A">
                           <p class="notep1">也可以看看：</p>
                           <p><a href="oci-collection-and-iterator-functions.html#GUID-1F50303F-38EB-4CF5-A333-A75E01255585" title="将元素追加到集合的末尾。">OCICollAppend（）</a></p>
                        </div>
                     </div>
                  </div><a id="LNOCI16829"></a><div class="props_rev_3"><a id="GUID-DE1ECBD6-306A-451A-8FF7-CDAEA6489938" name="GUID-DE1ECBD6-306A-451A-8FF7-CDAEA6489938"></a><h5 id="LNOCI-GUID-DE1ECBD6-306A-451A-8FF7-CDAEA6489938" class="sect5"><span class="enumeration_section">19.4.3.7</span> OCICollGetElem（）</h5>
                     <div>
                        <p>返回的collection元素可以是声明类型的子类型的实例。</p>
                        <p>如果集合的类型为<code class="codeph">Person_t</code> ，则可以使用<code class="codeph">OCICollGetElem()</code>函数获取指向此集合中元素（如<code class="codeph">Employee_t</code>实例<code class="codeph">OCICollGetElem()</code>的指针。
                        </p>
                        <div class="infoboxnotealso" id="GUID-DE1ECBD6-306A-451A-8FF7-CDAEA6489938__GUID-0E57D71F-D875-460C-8D8D-B69B0C5CF8D4">
                           <p class="notep1">也可以看看：</p>
                           <p><a href="oci-collection-and-iterator-functions.html#GUID-B28B3D65-EB7B-44BD-ADBA-DAC0C21DE90F" title="获取指向给定索引处元素的指针。">OCICollGetElem（）</a></p>
                        </div>
                     </div>
                  </div>
               </div><a id="LNOCI16830"></a><div class="props_rev_3"><a id="GUID-35D41A85-9417-4813-8DD6-544868C89D0B" name="GUID-35D41A85-9417-4813-8DD6-544868C89D0B"></a><h4 id="LNOCI-GUID-35D41A85-9417-4813-8DD6-544868C89D0B" class="sect4"><span class="enumeration_section">19.4.4</span>类型继承的OTT支持</h4>
                  <div>
                     <p>对象类型转换器（OTT）通过首先声明一个名为“_super”的封装结构中的继承属性，然后声明新声明的属性来支持对象的类型继承。</p>
                     <p>这样做是因为C不支持类型继承。</p>
                     <div class="infoboxnotealso" id="GUID-35D41A85-9417-4813-8DD6-544868C89D0B__GUID-5623E1AC-0CA2-40A3-9BA1-34F3319041D8">
                        <p class="notep1">也可以看看：</p>
                        <p><a href="using-object-type-translator-in-oci.html#GUID-4009C803-B151-4836-AF6F-741E9F072466" title="为了支持对象的类型继承，OTT通过使用特殊名称声明封装结构中的继承属性来生成表示对象子类型的C结构" _supe=",=" ="">OTT支持类型继承</a>的示例和讨论</p>
                     </div>
                  </div>
               </div>
            </div><a id="LNOCI16831"></a><div class="props_rev_3"><a id="GUID-34071CB4-805F-4DFE-B2F3-2E51A5B312F9" name="GUID-34071CB4-805F-4DFE-B2F3-2E51A5B312F9"></a><h3 id="LNOCI-GUID-34071CB4-805F-4DFE-B2F3-2E51A5B312F9" class="sect3"><span class="enumeration_section">19.5</span>关于类型进化</h3>
               <div>
                  <p>支持添加，删除和修改类型属性。这个概念被称为<span class="italic">类型演化</span> 。
                  </p>
                  <p>它在<a href="../adobj/type-evolution.html#ADOBJ00603" target="_blank"><span><cite>Oracle数据库对象关系开发人员指南中进行了讨论</cite></span></a> 。
                  </p>
                  <p>如果输入对象的类型是<code class="codeph">OCI_OTYPE_NAME</code> ，则<code class="codeph">OCIDescribeAny()</code>返回有关所请求类型的最新版本的信息，并且所描述的对象的类型是<code class="codeph">OCI_PTYPE_TYPE</code> ，即，如果输入到<code class="codeph">OCIDescribeAny()</code>的名称是类型名称。
                  </p>
                  <div class="infoboxnotealso" id="GUID-34071CB4-805F-4DFE-B2F3-2E51A5B312F9__GUID-D241C4E8-B81C-4EA4-A30D-2EC36C9A9ECA">
                     <p class="notep1">也可以看看：</p>
                     <ul style="list-style-type:disc">
                        <li>
                           <p><a href="oci-type-information-accessor-functions.html#GUID-16B5008B-C3EC-43C8-921B-6D93E76B4176" title="给定一组名称时获取一个TDO数组。">OCITypeArrayByName（）</a>和<span class="bold"> </span> <a href="oci-type-information-accessor-functions.html#GUID-3534AABC-E347-4BC7-B220-0CAECDC9ECE7" title="获取现有TDO的最新版本。">OCITypeByName（）</a> 。要访问类型信息，请使用这些函数和<code class="codeph">OCIDescribeAny()</code></p>
                        </li>
                        <li>
                           <p><a href="object-advanced-topics-in-oci.html#GUID-35CBBA0E-CAC9-4BA3-99F7-77D613141661" title="当基于类型名称请求类型信息时，OCI返回与该类型的最新版本相对应的类型描述符对象（TDO）。">键入Evolution和Object Cache</a> ，以讨论类型演化对对象缓存的影响</p>
                        </li>
                        <li>
                           <p><a href="bind-define-describe-functions.html#GUID-AE9F73FB-DCC1-401E-8151-A8A89059163A" title="描述现有的模式和子模式对象。">OCIDescribeAny（）</a></p>
                        </li>
                     </ul>
                  </div>
               </div>
            </div>
         </div>
      </article>
   </body>
</html>