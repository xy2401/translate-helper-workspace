<html lang="en-us" dir="ltr" xml:lang="en-us">
   <head>
      <meta http-equiv="Content-Type" content="text/html; charset=utf-8"></meta>
      <meta name="viewport" content="width=device-width, initial-scale=1"></meta>
      <meta http-equiv="X-UA-Compatible" content="IE=edge"></meta>
      <meta name="abstract" content="For XMLType data stored object-relationally, queries involving XPath expression arguments to various SQL functions can often be automatically rewritten to queries against the underlying SQL tables, which are highly optimized."></meta>
      <meta name="description" content="For XMLType data stored object-relationally, queries involving XPath expression arguments to various SQL functions can often be automatically rewritten to queries against the underlying SQL tables, which are highly optimized."></meta>
      <title>用于对象关系存储的XPath重写</title>
      <meta property="og:site_name" content="Oracle Help Center"></meta>
      <meta property="og:title" content="Developer&#39;s Guide "></meta>
      <meta property="og:description" content="For XMLType data stored object-relationally, queries involving XPath expression arguments to various SQL functions can often be automatically rewritten to queries against the underlying SQL tables, which are highly optimized."></meta>
      <link rel="stylesheet" href="/sp_common/book-template/ohc-book-template/css/book.css"></link>
      <link rel="shortcut icon" href="/sp_common/book-template/ohc-common/img/favicon.ico"></link>
      <meta name="application-name" content="Developer&#39;s Guide"></meta>
      <meta name="generator" content="DITA Open Toolkit version 1.8.5 (Mode = doc)"></meta>
      <meta name="plugin" content="SP_docbuilder HTML plugin release 18.2.2"></meta>
      <link rel="alternate" href="xml-db-developers-guide.pdf" title="PDF File" type="application/pdf"></link>
      <meta name="robots" content="all"></meta>
      <link rel="schema.dcterms" href="http://purl.org/dc/terms/"></link>
      <meta name="dcterms.created" content="2019-03-30T12:32:42-07:00"></meta>
      
      <meta name="dcterms.dateCopyrighted" content="2002, 2019"></meta>
      <meta name="dcterms.category" content="database"></meta>
      <meta name="dcterms.identifier" content="E96222-03"></meta>
      
      <meta name="dcterms.product" content="en/database/oracle/oracle-database/19"></meta>
      
      <link rel="prev" href="XML-Schema-and-query-object-relational-storage.html" title="Previous" type="text/html"></link>
      <link rel="next" href="XML-Schema-evolution.html" title="Next" type="text/html"></link>
      <script>
        document.write('<style type="text/css">');
        document.write('body > .noscript, body > .noscript ~ * { visibility: hidden; }');
        document.write('</style>');
     </script>
      <script src="/sp_common/book-template/requirejs/require.js" data-main="/sp_common/book-template/ohc-book-template/js/book-config"></script>
      <script>
            if (window.require === undefined) {
                document.write('<script data-main="sp_common/book-template/ohc-book-template/js/book-config" src="sp_common/book-template/requirejs/require.js"><\/script>');
                document.write('<link href="sp_common/book-template/ohc-book-template/css/book.css" rel="stylesheet"/>');
            }
        </script>
      <script type="application/json" id="ssot-metadata">{"primary":{"category":{"short_name":"database","element_name":"Database","display_in_url":true},"suite":{"short_name":"oracle","element_name":"Oracle","display_in_url":true},"product_group":{"short_name":"not-applicable","element_name":"Not applicable","display_in_url":false},"product":{"short_name":"oracle-database","element_name":"Oracle Database","display_in_url":true},"release":{"short_name":"19","element_name":"Release 19","display_in_url":true}}}</script>
      
    <meta name="dcterms.title" content="XML DB Developer&#39;s Guide"></meta>
    <meta name="dcterms.isVersionOf" content="ADXDB"></meta>
    <meta name="dcterms.release" content="Release 19"></meta>
  </head>
   <body dir="ltr">
      <div class="noscript alert alert-danger text-center" role="alert">
         <a href="XML-Schema-and-query-object-relational-storage.html" class="pull-left"><span class="glyphicon glyphicon-chevron-left" aria-hidden="true"></span>上一页</a> <a href="XML-Schema-evolution.html" class="pull-right">下一页<span class="glyphicon glyphicon-chevron-right" aria-hidden="true"></span></a> <span class="fa fa-exclamation-triangle" aria-hidden="true"></span>必须启用JavaScript才能正确显示此内容</div>
      <article>
         <header>
            <ol class="breadcrumb" vocab="http://schema.org/" typeof="BreadcrumbList">
               <li property="itemListElement" typeof="ListItem"><a href="index.html" property="item" typeof="WebPage"><span property="name">开发人员指南</span></a></li>
               <li property="itemListElement" typeof="ListItem"><a href="XML-Schema-and-object-relational-XMLType.html" property="item" typeof="WebPage"><span property="name">XML Schema和Object-Relational XMLType</span></a></li>
               <li class="active" property="itemListElement" typeof="ListItem">用于对象关系存储的XPath重写</li>
            </ol>
            <a id="GUID-35551023-CCAC-477B-8BBF-CD0E0B44C962" name="GUID-35551023-CCAC-477B-8BBF-CD0E0B44C962"></a><a id="ADXDB0670"></a>
            
            <h2 id="ADXDB-GUID-35551023-CCAC-477B-8BBF-CD0E0B44C962" class="sect2"><span class="enumeration_chapter">19</span> XPath重写对象关系存储</h2>
         </header>
         <div class="ind"><script type="text/javascript">window.name='XPath-rewrite-for-object-relational-storage'</script><script type="text/javascript">
    function footdisplay(footnum,footnote) {
    var msg = window.open('about:blank', 'NewWindow' + footnum,
        'directories=no,height=100,location=no,menubar=no,resizable=yes,' +
        'scrollbars=yes,status=no,toolbar=no,width=598');
    msg.document.open('text/html');
    msg.document.write('<!DOCTYPE html ');
    msg.document.write('PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" ');
    msg.document.write('"http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">'); 
    msg.document.write('<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en-us" lang="en-us" dir="ltr"><head><title>');
   
    msg.document.write('Footnote&nbsp; ' + footnum);
    msg.document.write('<\/title><meta http-equiv="Content-Type" ');
    msg.document.write('content="text/html; charset=utf-8" />');
    msg.document.write('<meta http-equiv="Content-Script-Type" ');
    msg.document.write('content="text/javascript" />');
    msg.document.write('<style type="text/css"> <![CDATA[ ');
    msg.document.write('h1 {text-align: center; font-size: 14pt;}');
    msg.document.write('fieldset {border: none;}');
    msg.document.write('form {text-align: center;}');
    msg.document.write(' ]]u003e </style>');
    msg.document.write('<\/head><body><div id="footnote"><h1>Footnote&nbsp; ' + footnum + '<\/h1><p>');
    msg.document.write(footnote);
    msg.document.write('<\/p><form action="" method="post"><fieldset>');
    msg.document.write('<input type="button" value="OK" ');
    msg.document.write('onclick="window.close();" />');
    msg.document.write('<\/fieldset><\/form><\/div><\/body><\/html>');
    msg.document.close();
    setTimeout(function() {
        var height = msg.document.getElementById('footnote').offsetHeight;
        msg.resizeTo(598, height + 100);
    }
    , 100);
    msg.focus();
}
            </script><noscript>
               <p>此页面上的脚本内容仅用于导航目的，不会以任何方式更改内容。</p>
            </noscript>
            <div>
               <p>对于以对象方式存储的<code class="codeph">XMLType</code>数据，涉及各种SQL函数的XPath表达式参数的查询通常可以自动重写为针对高度优化的基础SQL表的查询。
               </p>
               <div class="section"></div>
               <!-- class="section" -->
            </div>
            <div>
               <ul class="ullinks">
                  <li class="ulchildlink"><a href="XPath-rewrite-for-object-relational-storage.html#GUID-A2539B25-DD36-4F4C-8726-0B5FBD7A767B">对象关系存储的XPath重写概述</a><br>Oracle XML DB通常可以优化使用XPath表达式的查询 - 例如，涉及SQL函数的查询，例如<code class="codeph">XMLQuery</code> ， <code class="codeph">XMLTable</code>和<code class="codeph">XMLExists</code> ，它们将XPath（XQuery）表达式作为参数。实际上，XPath表达式是针对XML文档进行评估的，而无需在内存中构建XML文档。
                  </li>
                  <li class="ulchildlink"><a href="XPath-rewrite-for-object-relational-storage.html#GUID-1C2FC3C9-7926-4635-85A4-6AC28D503CDA">重写的常见XPath表达式</a><br>描述了在XPath重写期间重写的最常见的XPath表达式。
                  </li>
                  <li class="ulchildlink"><a href="XPath-rewrite-for-object-relational-storage.html#GUID-C9B5CA3D-32EC-4617-B654-21307B11CC39">XPath重写外联表</a><br>涉及存储在线外的元素的XPath表达式可以自动重写。重写的查询涉及与外联表的连接。
                  </li>
                  <li class="ulchildlink"><a href="XPath-rewrite-for-object-relational-storage.html#GUID-3B3A1D6C-38AF-4381-9F47-5E26AE84F157">使用执行计划分析和优化XPath查询的准则</a><br>提供了使用执行计划来分析查询执行的指南，以便（a）确定是否发生XPath重写，以及（b）通过使用二级索引来优化查询执行。这些准则仅适用于以对象关系存储的<code class="codeph">XMLType</code>数据。
                  </li>
               </ul>
               <div class="relinfo">
                  <p><strong>相关话题</strong></p>
                  <ul>
                     <li><a href="query-and-update-XML.html#GUID-F72DC7CD-40A9-4F07-9350-B80D2AD1F4D0" title="涉及XQuery表达式的SQL查询通常可以通过一种或多种方式自动重写（优化）。此优化称为XML查询重写或优化。发生这种情况时，实际上，XQuery表达式直接针对XML文档进行评估，而无需在内存中构建DOM。">XQuery的性能调优</a></li>
                  </ul>
               </div>
               <div class="familylinks">
                  <div class="parentlink">
                     <p><strong>父主题：</strong> <a href="XML-Schema-and-object-relational-XMLType.html#GUID-817F95DE-D604-41DC-BCDE-76CDE30F9176" title="涵盖了XML Schema的使用和XMLType数据的对象关系存储。">XML模式和对象关系XMLType</a></p>
                  </div>
               </div>
            </div>
            <a id="ADXDB5845"></a><a id="ADXDB4549"></a><div class="props_rev_3"><a id="GUID-A2539B25-DD36-4F4C-8726-0B5FBD7A767B" name="GUID-A2539B25-DD36-4F4C-8726-0B5FBD7A767B"></a><h3 id="ADXDB-GUID-A2539B25-DD36-4F4C-8726-0B5FBD7A767B" class="sect3"><span class="enumeration_section">19.1</span>对象关系存储的XPath重写概述</h3>
               <div>
                  <p>Oracle XML DB通常可以优化使用XPath表达式的查询 - 例如，涉及SQL函数的查询，例如<code class="codeph">XMLQuery</code> ， <code class="codeph">XMLTable</code>和<code class="codeph">XMLExists</code> ，它们将XPath（XQuery）表达式作为参数。实际上，XPath表达式是针对XML文档进行评估的，而无需在内存中构建XML文档。
                  </p>
                  <p>此优化称为<strong class="term">XPath重写</strong> 。它是XML查询优化的适当子集，它还涉及XQuery表达式的优化，例如FLWOR表达式，它们不是XPath表达式。XPath重写还允许优化器在查询评估中使用列（如果存在于列上）。
                  </p>
                  <p>可以由Oracle XML DB重写的XPath表达式是Oracle XML DB支持的那些表达式的适当子集。只要您可以在不丢失功能的情况下执行此操作，请使用可以重写的XPath表达式。</p>
                  <p>XPath重写可以在这些上下文（或其组合）中发生：</p>
                  <ul style="list-style-type:disc">
                     <li>
                        <p>当<code class="codeph">XMLType</code>数据存储在对象关系列或表中时，或者在关系数据上构建<code class="codeph">XMLType</code>视图时。
                        </p>
                     </li>
                     <li>
                        <p>使用<code class="codeph">XMLIndex</code>索引时。
                        </p>
                     </li>
                  </ul>
                  <p>第一种情况是重写使用对象关系XML数据或<code class="codeph">XMLType</code>视图的查询，这里将介绍。<code class="codeph">XMLType</code>视图可以是基于XML模式的，也可以不是。<code class="codeph">XMLType</code>数据的对象关系存储始终基于XML模式。本章中的示例与基于XML模式的表有关。
                  </p>
                  <p>当对象关系XML数据可以进行XPath重写时，数据库优化器可以基于传统的关系代数推导出执行计划。这反过来意味着Oracle XML DB可以利用数据库的所有功能，并确保包含XQuery和XPath表达式的SQL语句以高性能和高效的方式执行。这种重写几乎没有开销，因此Oracle XML DB以接近关系的速度执行基于XQuery和基于XPath的查询。</p>
                  <p>在某些情况下，XPath重写是不可能的。当没有与XPath表达式等效的SQL时，通常会发生这种情况。在这种情况下，Oracle XML DB会对XPath表达式执行功能评估，这通常成本更高，尤其是在要处理的文档数量很大的情况下。</p>
                  <p><a href="XPath-rewrite-for-object-relational-storage.html#GUID-A2539B25-DD36-4F4C-8726-0B5FBD7A767B__CACIBIIG">例19-1</a>说明了使用XPath表达式的简单查询的XPath重写。
                  </p>
                  <div class="example" id="GUID-A2539B25-DD36-4F4C-8726-0B5FBD7A767B__CACIBIIG">
                     <p class="titleinexample">例19-1 XPath重写</p><pre class="pre codeblock"><code>选择po。OBJECT_VALUE来自purchaseorder po WHERE XMLCast（XMLQuery（'$ p / PurchaseOrder / Requestor'PASSING po。OBJECT_VALUE作为“p”返回内容）AS VARCHAR2（128））='Sarah J. Bell';</code></pre><p>此处的<code class="codeph">XMLCast(XMLQuery...))</code>表达式将重写为存储采购订单的请求者信息的基础关系列。查询将重写为以下内容： <a id="fn_1" name="fn_1" href="#fn_1" this="" example="" uses="" sample="" database="" schema="" oe="" and="" its="" table="" purchaseorder.="" the="" xml="" for="" is="" annotated="" with="" attribute="" sqlname="" to="" specify="" sql="" object="" names="" such="" as="" requestor — see="" a-2.="" without="" annotations,="" would="" use="" p.="xmldata\" .="requestor\" ,="" not="" p.="xmldata\" .=".requestor\" =")" ="" onclick="footdisplay(1, "><sup>Foot 1</sup></a> 
                     </p><pre class="pre codeblock"><code>SELECT OBJECT_VALUE FROM purchaseorder p WHERE CAST（p。“XMLDATA”。“REQUESTOR”AS VARCHAR2（128））='Sarah J. Bell';</code></pre></div>
                  <!-- class="example" -->
               </div>
               <div>
                  <div class="relinfo">
                     <p><strong>相关话题</strong></p>
                     <ul>
                        <li><a href="relational-views-over-XML-data.html#GUID-420496CE-D62F-4EBE-A76E-861B932AE1E6" title="XML数据的关系数据库视图提供对XML内容的传统关系访问。">XML数据的关系视图</a></li>
                        <li><a href="XMLType-views.html#GUID-9F0A7B1F-269B-411F-AD8B-8F1CB2E2A671" title="您可以在关系数据和对象关系数据上创建XMLType视图。">XMLType视图</a></li>
                        <li><a href="indexes-for-XMLType-data.html#GUID-BF638421-9D6E-4D72-8371-79D084A04BCA" title="通过在与XML节点对应的基础数据库列上创建B树索引，可以有效地索引以对象关系存储的XMLType数据。">索引XMLType数据存储对象 - 关系</a></li>
                        <li><a href="indexes-for-XMLType-data.html#GUID-6E6A5BA7-9B84-4E3D-B556-B3B286D26B46">的XMLIndex</a></li>
                        <li><a href="XML-Schema-and-query-object-relational-storage.html#GUID-B1B67DF3-8E3A-4383-B67F-D14EF98BFBE9" title="对于以对象方式存储的XMLType数据，需要仔细规划，以优化性能。对关系数据也有类似的考虑：实体关系模型，索引，数据类型，表分区等。要启用XPath重写并获得最佳性能，可以使用XML模式注释实现许多此类设计选择。">对象关系存储的XML模式注释指南</a></li>
                     </ul>
                  </div>
                  <div class="familylinks">
                     <div class="parentlink">
                        <p><strong>父主题：</strong> <a href="XPath-rewrite-for-object-relational-storage.html#GUID-35551023-CCAC-477B-8BBF-CD0E0B44C962" title="对于以对象方式存储的XMLType数据，涉及各种SQL函数的XPath表达式参数的查询通常可以自动重写为针对高度优化的基础SQL表的查询。">对象关系存储的XPath重写</a></p>
                     </div>
                  </div>
               </div>
               
            </div><a id="ADXDB4558"></a><a id="ADXDB5847"></a><div class="props_rev_3"><a id="GUID-1C2FC3C9-7926-4635-85A4-6AC28D503CDA" name="GUID-1C2FC3C9-7926-4635-85A4-6AC28D503CDA"></a><h3 id="ADXDB-GUID-1C2FC3C9-7926-4635-85A4-6AC28D503CDA" class="sect3"><span class="enumeration_section">19.2</span>重写的常见XPath表达式</h3>
               <div>
                  <p>描述了在XPath重写期间重写的最常见的XPath表达式。</p>
                  <p><a href="XPath-rewrite-for-object-relational-storage.html#GUID-1C2FC3C9-7926-4635-85A4-6AC28D503CDA__G1048508" title="此表描述了支持的用于转换为基础SQL查询的XPath表达式。它有两列。">表19-1</a>给出了说明</p>
                  <div class="tblformalwide" id="GUID-1C2FC3C9-7926-4635-85A4-6AC28D503CDA__G1048508">
                     <p class="titleintable">表19-1重写为基础SQL构造的XPath表达式示例</p>
                     <table cellpadding="4" cellspacing="0" class="FormalWide" title="已重写为基础SQL构造的XPath表达式示例" width="100%" border="1" summary="This table describes supported XPath expressions for translation to underlying SQL queries. It has two columns." frame="hsides" rules="rows">
                        <thead>
                           <tr align="left" valign="top">
                              <th align="left" valign="bottom" width="53%" id="d101315e334">用于翻译的XPath表达式</th>
                              <th align="left" valign="bottom" width="47%" id="d101315e337">描述</th>
                           </tr>
                        </thead>
                        <tbody>
                           <tr align="left" valign="top">
                              <td align="left" valign="top" width="53%" id="d101315e342" headers="d101315e334 ">
                                 <p>简单的XPath表达式（仅包含<code class="codeph">child</code>轴和<code class="codeph">attribute</code>轴的表达式）：</p>
                                 <p><code class="codeph">含/ PurchaseOrder / @参考</code></p>
                                 <p><code class="codeph">含/ PurchaseOrder /请求者</code></p>
                              </td>
                              <td align="left" valign="top" width="47%" headers="d101315e342 d101315e337 ">
                                 <p>仅涉及对象类型属性的遍历，其中属性是简单标量或对象类型本身。</p>
                              </td>
                           </tr>
                           <tr align="left" valign="top">
                              <td align="left" valign="top" width="53%" id="d101315e361" headers="d101315e334 ">
                                 <p>集合遍历表达式：</p>
                                 <p><code class="codeph">含/ PurchaseOrder /了LineItem / LineItem的/零件/ @标识</code></p>
                              </td>
                              <td align="left" valign="top" width="47%" headers="d101315e361 d101315e337 ">
                                 <p>涉及遍历集合表达式。支持的唯一轴是子轴和属性轴。如果在<code class="codeph">CREATE INDEX</code>操作期间使用SQL函数，则不支持集合遍历。
                                 </p>
                              </td>
                           </tr>
                           <tr align="left" valign="top">
                              <td align="left" valign="top" width="53%" id="d101315e374" headers="d101315e334 ">
                                 <p>谓词：</p>
                                 <p><code class="codeph">[Requestor =“Sarah J. Bell”]</code></p>
                              </td>
                              <td align="left" valign="top" width="47%" headers="d101315e374 d101315e337 ">
                                 <p>XPath中的谓词被重写为SQL谓词。</p>
                              </td>
                           </tr>
                           <tr align="left" valign="top">
                              <td align="left" valign="top" width="53%" id="d101315e384" headers="d101315e334 ">
                                 <p>列表索引（位置谓词）：</p>
                                 <p><code class="codeph">的LineItem [1]</code></p>
                              </td>
                              <td align="left" valign="top" width="47%" headers="d101315e384 d101315e337 ">
                                 <p>重写索引以访问集合中的第n个项目。</p>
                              </td>
                           </tr>
                           <tr align="left" valign="top">
                              <td align="left" valign="top" width="53%" id="d101315e394" headers="d101315e334 ">
                                 <p>通配符遍历：</p>
                                 <p><code class="codeph">含/ PurchaseOrder / * /零件/ @标识</code></p>
                              </td>
                              <td align="left" valign="top" width="47%" headers="d101315e394 d101315e337 ">
                                 <p>如果通配符可以转换为一个或多个简单的XPath表达式，那么它将被重写。</p>
                              </td>
                           </tr>
                           <tr align="left" valign="top">
                              <td align="left" valign="top" width="53%" id="d101315e404" headers="d101315e334 ">
                                 <p>后代轴（仅基于XML模式的数据），没有递归：</p>
                                 <p><code class="codeph">/ // PurchaseOrder的零件/ @标识</code></p>
                              </td>
                              <td align="left" valign="top" width="47%" headers="d101315e404 d101315e337 ">
                                 <p>与通配符表达式类似。如果可以将<code class="codeph">descendant</code>轴映射到一个或多个简单的XPath表达式，则会重写<code class="codeph">descendant</code>轴。
                                 </p>
                              </td>
                           </tr>
                           <tr align="left" valign="top">
                              <td align="left" valign="top" width="53%" id="d101315e417" headers="d101315e334 ">
                                 <p>后代轴（仅基于XML模式的数据），带<span class="italic">递归</span> ：</p>
                                 <p><code class="codeph">/ // PurchaseOrder的零件/ @标识</code></p>
                              </td>
                              <td align="left" valign="top" width="47%" headers="d101315e417 d101315e337 ">
                                 <p>如果这两个条件成立，则重写<code class="codeph">descendant</code>轴：</p>
                                 <ul style="list-style-type:disc">
                                    <li>
                                       <p>此XPath表达式扩展的所有简单XPath表达式都映射到同一个外联表。</p>
                                    </li>
                                    <li>
                                       <p>此XPath表达式未展开的任何简单XPath表达式都不会映射到该外联表。</p>
                                    </li>
                                 </ul>
                              </td>
                           </tr>
                           <tr align="left" valign="top">
                              <td align="left" valign="top" width="53%" id="d101315e440" headers="d101315e334 ">
                                 <p>XPath函数</p>
                              </td>
                              <td align="left" valign="top" width="47%" headers="d101315e440 d101315e337 ">
                                 <p>一些XPath函数被重写。这些函数包括<code class="codeph">not</code> ， <code class="codeph">floor</code> ， <code class="codeph">ceiling</code> ， <code class="codeph">substring</code>和<code class="codeph">string-length</code> 。
                                 </p>
                              </td>
                           </tr>
                        </tbody>
                     </table>
                  </div>
                  <!-- class="inftblhruleinformal" -->
               </div>
               <div>
                  <div class="infoboxnotealso" id="GUID-1C2FC3C9-7926-4635-85A4-6AC28D503CDA__GUID-E01FC34D-DFBF-4402-989E-D955E5779BDC">
                     <p class="notep1">也可以看看：</p>
                     <p>有关重写XQuery表达式的信息，请参阅<a href="query-and-update-XML.html#GUID-F72DC7CD-40A9-4F07-9350-B80D2AD1F4D0" title="涉及XQuery表达式的SQL查询通常可以通过一种或多种方式自动重写（优化）。此优化称为XML查询重写或优化。发生这种情况时，实际上，XQuery表达式直接针对XML文档进行评估，而无需在内存中构建DOM。">XQuery的性能调优</a></p>
                  </div>
                  <div class="familylinks">
                     <div class="parentlink">
                        <p><strong>父主题：</strong> <a href="XPath-rewrite-for-object-relational-storage.html#GUID-35551023-CCAC-477B-8BBF-CD0E0B44C962" title="对于以对象方式存储的XMLType数据，涉及各种SQL函数的XPath表达式参数的查询通常可以自动重写为针对高度优化的基础SQL表的查询。">对象关系存储的XPath重写</a></p>
                     </div>
                  </div>
               </div>
               
            </div><a id="ADXDB4623"></a><a id="ADXDB4624"></a><a id="ADXDB4622"></a><div class="props_rev_3"><a id="GUID-C9B5CA3D-32EC-4617-B654-21307B11CC39" name="GUID-C9B5CA3D-32EC-4617-B654-21307B11CC39"></a><h3 id="ADXDB-GUID-C9B5CA3D-32EC-4617-B654-21307B11CC39" class="sect3"><span class="enumeration_section">19.3</span> XPath重写外联表</h3>
               <div>
                  <p>涉及存储在线外的元素的XPath表达式可以自动重写。重写的查询涉及与外联表的连接。</p>
                  <p> <a href="XPath-rewrite-for-object-relational-storage.html#GUID-C9B5CA3D-32EC-4617-B654-21307B11CC39__CHDCJJHJ">例19-2</a>显示了这样的查询。XQuery表达式被重写为查询表<code class="codeph">addr_tab</code>的SQL <code class="codeph">EXISTS</code>子查询，使用<code class="codeph">emp_tab</code>中的对象标识符列将其与表<code class="codeph">emp_tab</code> <code class="codeph">addr_tab</code> 。优化程序使用表<code class="codeph">emp_tab</code>和<code class="codeph">addr_tab</code>全表扫描。如果<code class="codeph">addr_tab</code>有许多条目，那么您可以尝试通过在城市上创建索引来提高此查询的效率，如<a href="XPath-rewrite-for-object-relational-storage.html#GUID-C9B5CA3D-32EC-4617-B654-21307B11CC39__CHDEICJC">例19-3</a>所示。与<a href="XPath-rewrite-for-object-relational-storage.html#GUID-C9B5CA3D-32EC-4617-B654-21307B11CC39__CHDCJJHJ">例19-2</a>中相同查询的解释计划片段显示城市索引已被选中。
                  </p>
                  <div class="infoboxnote" id="GUID-C9B5CA3D-32EC-4617-B654-21307B11CC39__GUID-444E1A87-2020-492C-8FA1-BEC20B312818">
                     <p class="notep1">注意：</p>
                     <p>在对象关系存储的<code class="codeph">XMLType</code>表上收集优化程序的统计信息时，Oracle建议您收集XML模式定义的<span class="italic">所有</span>表的统计信息，即<code class="codeph">USER_XML_TABLES</code>所有表。您可以使用过程<code class="codeph">DBMS_STATS.gather_schema_stats</code>执行此操作，或在每个此类表上使用<code class="codeph">DBMS_STATS.gather_table_stats</code> 。这将通知优化器有关用于存储<code class="codeph">XMLType</code>数据的所有从属表。
                     </p>
                  </div>
                  <div class="example" id="GUID-C9B5CA3D-32EC-4617-B654-21307B11CC39__CHDCJJHJ">
                     <p class="titleinexample">例19-2外线表的XPath重写</p><pre class="pre codeblock"><code>SELECT XMLCast（XMLQuery（'declare namespace x =“http://www.oracle.com/emp.xsd”;（：:) / x：Employee / Name'PASSING OBJECT_VALUE RETURNING CONTENT）AS VARCHAR2（20））FROM emp_tab WHERE XMLExists（'declare namespace x =“http://www.oracle.com/emp.xsd”;（：:) / x：Employee / Addr [City =“San Francisco”]'PASSING OBJECT_VALUE）; XMLCAST（XMLQUERY（...-------------------- Abe Bee Eve Fong George Hu Iris Jones Karl Luomo Marina Namur Omar Pinano Quincy Roberts 8行入选。
</code></pre></div>
                  <!-- class="example" -->
                  <div class="example" id="GUID-C9B5CA3D-32EC-4617-B654-21307B11CC39__CHDEICJC">
                     <p class="titleinexample">例19-3使用带有外表的索引</p><pre class="pre codeblock"><code>CREATE INDEX addr_city_idx ON addr_tab（extractValue（OBJECT_VALUE，'/ Addr / City'））;</code></pre><pre class="pre codeblock"><code>| 2 |按INDEX ROWID表的访问权限| ADDR_TAB | 1 | 2012 | 1（0）| 00:00:01 | | * 3 | INDEX RANGE SCAN | <span class="bold">ADDR_CITY_IDX</span> | 1 | | 1（0）| 00:00:01 | | 4 |表访问完全| EMP_TAB | 16 | 32464 | 2（0）| 00:00:01 |</code></pre></div>
                  <!-- class="example" -->
               </div>
               <div>
                  <div class="familylinks">
                     <div class="parentlink">
                        <p><strong>父主题：</strong> <a href="XPath-rewrite-for-object-relational-storage.html#GUID-35551023-CCAC-477B-8BBF-CD0E0B44C962" title="对于以对象方式存储的XMLType数据，涉及各种SQL函数的XPath表达式参数的查询通常可以自动重写为针对高度优化的基础SQL表的查询。">对象关系存储的XPath重写</a></p>
                     </div>
                  </div>
               </div>
               
            </div><a id="ADXDB4566"></a><div class="props_rev_3"><a id="GUID-3B3A1D6C-38AF-4381-9F47-5E26AE84F157" name="GUID-3B3A1D6C-38AF-4381-9F47-5E26AE84F157"></a><h3 id="ADXDB-GUID-3B3A1D6C-38AF-4381-9F47-5E26AE84F157" class="sect3"><span class="enumeration_section">19.4</span>使用执行计划分析和优化XPath查询的指南</h3>
               <div>
                  <p>提供了使用执行计划来分析查询执行的指南，以便（a）确定是否发生XPath重写，以及（b）通过使用二级索引来优化查询执行。这些准则仅适用于以对象关系存储的<code class="codeph">XMLType</code>数据。
                  </p>
                  <p>同时使用这些指南，将所有适用的考虑在内。</p>
                  <p>对象关系存储的XPath重写意味着选择由XPath表达式定义的XML片段的查询将被重写为基础对象关系表和列上的SQL <code class="codeph">SELECT</code>语句。这些基础表可以包括外联表。
                  </p>
                  <p>您可以使用PL / SQL过程<code class="codeph">DBMS_XMLSTORAGE_MANAGE.XPath2TabColMapping</code>来查找与给定XPath表达式对应的基础表和列的名称。
                  </p>
                  <div class="section"></div>
                  <!-- class="section" -->
               </div>
               <div>
                  <ul class="ullinks">
                     <li class="ulchildlink"><a href="XPath-rewrite-for-object-relational-storage.html#GUID-B1658194-2F19-47C0-B82D-10761D68E299">指南：在执行计划中查找基础表与XML函数</a><br>重写的查询的执行计划是指作为查询的<code class="codeph">XMLType</code>数据的基础的对象关系表和列的名称。如果这些名称是从XML元素或属性名称派生的，或者如果使用XML Schema批注<code class="codeph">xdb:defaultTable</code>则这些名称对您有意义。
                     </li>
                     <li class="ulchildlink"><a href="XPath-rewrite-for-object-relational-storage.html#GUID-4B3F942D-A767-4870-BB69-18EC4E815A10">准则：命名对象关系表，以便在执行计划中识别它们</a><br>在设计XML模式时，请使用注释<code class="codeph">xdb:defaultTable</code>来命名与在性能很重要的查询中选择的元素对应的基础表。这使您可以在执行计划中轻松识别它们，通过它们是否存在来指示查询是否已被重写。
                     </li>
                     <li class="ulchildlink"><a href="XPath-rewrite-for-object-relational-storage.html#GUID-2A9AEEC5-6CD1-4A17-A3A7-08E86E547C2F">准则：在谓词所针对的列上创建索引</a><br>通过创建应用于谓词所针对的列的索引，有时可以提高重写的查询的性能，使其包含SQL谓词。
                     </li>
                     <li class="ulchildlink"><a href="XPath-rewrite-for-object-relational-storage.html#GUID-B10DA5D9-25C5-4F0B-AD4D-2CB93D5114D4">指南：在有序集合表上创建索引</a><br>如果集合存储为有序集合表（OCT）或<code class="codeph">XMLType</code>实例，则可以直接访问集合的成员。每个成员都成为一个表行，因此您可以使用SQL直接访问它。您通常可以通过索引此类集合成员来提高性能。
                     </li>
                     <li class="ulchildlink"><a href="XPath-rewrite-for-object-relational-storage.html#GUID-7F6CF536-9DDC-42C8-AB0D-115A5300C616">准则：使用XMLOptimizationCheck确定不重写查询的原因</a><br>如果尚未优化查询，则可以使用系统变量<code class="codeph">XMLOptimizationCheck</code>来尝试确定原因。
                     </li>
                  </ul>
                  <div class="relinfo">
                     <p><strong>相关话题</strong></p>
                     <ul>
                        <li><a href="XPath-rewrite-for-object-relational-storage.html#GUID-C9B5CA3D-32EC-4617-B654-21307B11CC39" title="涉及存储在线外的元素的XPath表达式可以自动重写。重写的查询涉及与外联表的连接。">XPath重写外联表</a></li>
                     </ul>
                  </div>
                  <div class="infoboxnotealso" id="GUID-3B3A1D6C-38AF-4381-9F47-5E26AE84F157__GUID-BC313CFB-D881-41CF-8B2E-E21C34E6FC24">
                     <p class="notep1">也可以看看：</p>
                     <p>有关过程<code class="codeph">XPath2TabColMapping</code>信息，请<code class="codeph">XPath2TabColMapping</code> <a href="../arpls/DBMS_XMLSTORAGE_MANAGE.html#ARPLS74503" target="_blank"><span><cite>Oracle Database PL / SQL包和类型参考</cite></span></a></p>
                  </div>
                  <div class="familylinks">
                     <div class="parentlink">
                        <p><strong>父主题：</strong> <a href="XPath-rewrite-for-object-relational-storage.html#GUID-35551023-CCAC-477B-8BBF-CD0E0B44C962" title="对于以对象方式存储的XMLType数据，涉及各种SQL函数的XPath表达式参数的查询通常可以自动重写为针对高度优化的基础SQL表的查询。">对象关系存储的XPath重写</a></p>
                     </div>
                  </div>
               </div>
               <a id="ADXDB5849"></a><a id="ADXDB5848"></a><div class="props_rev_3"><a id="GUID-B1658194-2F19-47C0-B82D-10761D68E299" name="GUID-B1658194-2F19-47C0-B82D-10761D68E299"></a><h4 id="ADXDB-GUID-B1658194-2F19-47C0-B82D-10761D68E299" class="sect4"><span class="enumeration_section">19.4.1</span>指南：在执行计划中查找基础表与XML函数</h4>
                  <div>
                     <p>重写的查询的执行计划是指作为查询的<code class="codeph">XMLType</code>数据的基础的对象关系表和列的名称。如果这些名称是从XML元素或属性名称派生的，或者如果使用XML Schema批注<code class="codeph">xdb:defaultTable</code>则这些名称对您有意义。
                     </p>
                     <p>否则，这些名称是系统生成的，没有明显的意义。特别是，它们不反映相应的XML元素或属性名称。</p>
                     <p>此外，一些系统生成的列通常是隐藏的。如果使用SQL <code class="codeph">describe</code>命令，则看不到它们。然而，他们出现在执行计划中。
                     </p>
                     <p>尚未重写的查询计划仅显示基表名称，它通常引用用户级XML函数，例如<code class="codeph">XMLExists</code> 。查找此差异以确定是否已优化查询。执行计划中显示的XML函数名称实际上是内部名称（例如， <code class="codeph">XMLEXISTS2</code> ），有时与用户级名称略有不同。
                     </p>
                     <p><a href="XPath-rewrite-for-object-relational-storage.html#GUID-B1658194-2F19-47C0-B82D-10761D68E299__CACDIECD">例19-4</a>显示了Oracle XML DB无法执行XPath重写时生成的执行计划输出的类型。这里的计划是针对使用SQL / XML函数<code class="codeph">XMLExists</code>的查询。相应的内部函数<code class="codeph">XMLExists2</code>出现在计划输出中，表示不重写查询。
                     </p>
                     <p>在这种情况下，Oracle XML DB根据查询<code class="codeph">WHERE</code>子句中指定的任何其他条件构造预过滤的结果集。然后，它过滤此潜在结果集中的行，以确定哪些行属于结果集。通过<span class="italic">在每个文档上构建DOM</span>并使用DOM API定义的方法执行<strong class="term">功能评估</strong>来确定每个文档是否是结果集的成员来执行过滤。
                     </p>
                     <div class="example" id="GUID-B1658194-2F19-47C0-B82D-10761D68E299__CACDIECD">
                        <p class="titleinexample">示例19-4不发生XPath重写时生成的执行计划</p><pre class="pre codeblock"><code>谓词信息（由操作ID标识）：----------------------------------------- ---------- 1  - 过滤器（ <span class="bold">XMLEXISTS2</span> （'$ p / PurchaseOrder [User =“SBELL”]'按值输入SYS_MAKEXML（'61687B202644E297E040578C8A175C1D'，4215，“PO”。“XMLEXTRA”，“PO “。”X MLDATA“）AS”p“）= 1）</code></pre></div>
                     <!-- class="example" -->
                  </div>
                  <div>
                     <div class="familylinks">
                        <div class="parentlink">
                           <p><strong>父主题：</strong> <a href="XPath-rewrite-for-object-relational-storage.html#GUID-3B3A1D6C-38AF-4381-9F47-5E26AE84F157" title="提供了使用执行计划来分析查询执行的指南，以便（a）确定是否发生XPath重写，以及（b）通过使用二级索引来优化查询执行。这些准则仅适用于以对象关系存储的XMLType数据。">使用执行计划分析和优化XPath查询的准则</a></p>
                        </div>
                     </div>
                  </div>
                  
               </div><a id="ADXDB5850"></a><div class="props_rev_3"><a id="GUID-4B3F942D-A767-4870-BB69-18EC4E815A10" name="GUID-4B3F942D-A767-4870-BB69-18EC4E815A10"></a><h4 id="ADXDB-GUID-4B3F942D-A767-4870-BB69-18EC4E815A10" class="sect4"><span class="enumeration_section">19.4.2</span>指南：命名对象关系表，以便在执行计划中识别它们</h4>
                  <div>
                     <p>在设计XML模式时，请使用注释<code class="codeph">xdb:defaultTable</code>来命名与在性能很重要的查询中选择的元素对应的基础表。这使您可以在执行计划中轻松识别它们，通过它们是否存在来指示查询是否已被重写。
                     </p>
                     <p>对于集合表，没有相应的XML模式注释。要为集合表提供用户友好的名称，必须首先注册XML模式。然后，您可以使用PL / SQL过程<code class="codeph">DBMS_XMLSTORAGE_MANAGE.renameCollectionTable</code>重命名在注册期间创建的表，这些表具有系统生成的名称。
                     </p>
                  </div>
                  <div>
                     <div class="infoboxnotealso" id="GUID-4B3F942D-A767-4870-BB69-18EC4E815A10__GUID-66967FDC-3985-42C6-A815-AF34F1030F49">
                        <p class="notep1">也可以看看：</p>
                        <p><a href="../arpls/DBMS_XMLSTORAGE_MANAGE.html#ARPLS74498" target="_blank"><span><cite>Oracle Database PL / SQL包和类型参考</cite></span></a>有关过程<code class="codeph">renameCollectionTable</code>信息</p>
                     </div>
                     <div class="familylinks">
                        <div class="parentlink">
                           <p><strong>父主题：</strong> <a href="XPath-rewrite-for-object-relational-storage.html#GUID-3B3A1D6C-38AF-4381-9F47-5E26AE84F157" title="提供了使用执行计划来分析查询执行的指南，以便（a）确定是否发生XPath重写，以及（b）通过使用二级索引来优化查询执行。这些准则仅适用于以对象关系存储的XMLType数据。">使用执行计划分析和优化XPath查询的准则</a></p>
                        </div>
                     </div>
                  </div>
                  
               </div><a id="ADXDB5852"></a><a id="ADXDB6120"></a><a id="ADXDB5854"></a><a id="ADXDB5855"></a><a id="ADXDB5856"></a><a id="ADXDB5857"></a><a id="ADXDB5851"></a><div class="props_rev_3"><a id="GUID-2A9AEEC5-6CD1-4A17-A3A7-08E86E547C2F" name="GUID-2A9AEEC5-6CD1-4A17-A3A7-08E86E547C2F"></a><h4 id="ADXDB-GUID-2A9AEEC5-6CD1-4A17-A3A7-08E86E547C2F" class="sect4"><span class="enumeration_section">19.4.3</span>指南：在谓词所针对的列上创建索引</h4>
                  <div>
                     <p>通过创建应用于谓词所针对的列的索引，有时可以提高重写的查询的性能，使其包含SQL谓词。</p>
                     <p>由XPath重写产生的查询有时包括SQL谓词（ <code class="codeph">WHERE</code>子句）。即使原始查询不使用XPath谓词，也会发生这种情况，即使原始查询没有SQL <code class="codeph">WHERE</code>子句也可能发生这种情况。
                     </p>
                     <p>发生这种情况时，有时可以通过在SQL谓词所针对的列上创建索引，或者通过在该列的函数应用程序上创建索引来提高性能。</p>
                     <p><a href="XPath-rewrite-for-object-relational-storage.html#GUID-A2539B25-DD36-4F4C-8726-0B5FBD7A767B__CACIBIIG">例19-1</a>说明了包含<code class="codeph">WHERE</code>子句的查询的XPath重写。<a href="XPath-rewrite-for-object-relational-storage.html#GUID-2A9AEEC5-6CD1-4A17-A3A7-08E86E547C2F__CACIIDHJ">例19-5</a>显示了来自此查询的执行计划的谓词信息。
                     </p>
                     <p>该谓语信息表明，表达<code class="codeph">XMLCast(XMLQuery...))</code>被改写为SQL函数的应用<code class="codeph">cast</code>到存储采购订单，请求信息的基础关系列<code class="codeph">SYS_NC0021$</code> 。此列名称是系统生成的。执行计划是指该系统生成的名称，尽管该理事XML架构使用注释事实<code class="codeph">SQLName</code>来命名此列<code class="codeph">REQUESTOR</code> 。</p>
                     <p>由于这两个名称（用户定义和系统生成）引用同一列，因此可以使用任一名称在此列上创建B树索引。或者，您可以使用<code class="codeph">extractValue</code>快捷方式创建索引，方法是指定以采购订单请求者数据为目标的XPath表达式。
                     </p>
                     <p>您可以使用过程<code class="codeph">DBMS_XMLSTORAGE_MANAGE.XPath2TabColMapping</code>获取与给定XPath表达式对应的基础表和列的名称。<a href="XPath-rewrite-for-object-relational-storage.html#GUID-2A9AEEC5-6CD1-4A17-A3A7-08E86E547C2F__CHDCHCCB">例19-6</a>说明了<a href="XPath-rewrite-for-object-relational-storage.html#GUID-A2539B25-DD36-4F4C-8726-0B5FBD7A767B__CACIBIIG">例19-1</a>的<code class="codeph">WHERE</code>子句中使用的XPath表达式<code class="codeph">/PurchaseOrder/Requestor</code> <a href="XPath-rewrite-for-object-relational-storage.html#GUID-A2539B25-DD36-4F4C-8726-0B5FBD7A767B__CACIBIIG">Requestor</a> 。
                     </p>
                     <p>如果提供包含通配符或后代轴的XPath表达式，则可能会选择多个表和列。在这种情况下，过程<code class="codeph">XPath2TabColMapping</code>返回多个<code class="codeph">&lt;Mapping&gt;</code>元素，每个表 - 列对一个元素。
                     </p>
                     <p>然后，您可以在<code class="codeph">CREATE INDEX</code>语句中使用以这种方式检索的表和列名来创建与XPath表达式对应的索引。<a href="XPath-rewrite-for-object-relational-storage.html#GUID-2A9AEEC5-6CD1-4A17-A3A7-08E86E547C2F__CACDBHCJ">例19-7</a>显示了在谓词目标列上创建B树索引的三种等效方法。
                     </p>
                     <p>但是，对于此特定查询，使用与重写查询中的函数表达式匹配的函数表达式创建基于函数的索引是有意义的。<a href="XPath-rewrite-for-object-relational-storage.html#GUID-2A9AEEC5-6CD1-4A17-A3A7-08E86E547C2F__CACCAJDI">例19-8</a>说明了这一点。
                     </p>
                     <p><a href="XPath-rewrite-for-object-relational-storage.html#GUID-2A9AEEC5-6CD1-4A17-A3A7-08E86E547C2F__CACJEJBH">例19-9</a>显示了一个执行计划，表明索引已被选中。
                     </p>
                     <p>在这个查询中的特定情况下，原来的功能性表达适用<code class="codeph">XMLCast</code>到<code class="codeph">XMLQuery</code>靶向单元素， <code class="codeph">Requestor</code> 。这是一种特殊情况，您可以在<code class="codeph">CREATE INDEX</code>语句中直接使用这样的函数表达式。重写该语句以创建基础标量数据的索引。<a href="XPath-rewrite-for-object-relational-storage.html#GUID-2A9AEEC5-6CD1-4A17-A3A7-08E86E547C2F__CACCGFBB">因此，示例19-10</a>以XPath表达式为目标，与<a href="XPath-rewrite-for-object-relational-storage.html#GUID-2A9AEEC5-6CD1-4A17-A3A7-08E86E547C2F__CACCAJDI">示例19-8</a>具有相同的效果， <a href="XPath-rewrite-for-object-relational-storage.html#GUID-2A9AEEC5-6CD1-4A17-A3A7-08E86E547C2F__CACCAJDI">示例19-8</a>以相应的对象关系列为目标。
                     </p>
                     <div class="infoboxnotealso" id="GUID-2A9AEEC5-6CD1-4A17-A3A7-08E86E547C2F__GUID-A276AAA7-4C93-432E-BE1F-C0B7478210D8">
                        <p class="notep1">也可以看看：</p>
                        <ul style="list-style-type:disc">
                           <li>
                              <p><a href="indexes-for-XMLType-data.html#GUID-A01AC88E-C63B-40FC-9E6E-8BB1E65A459E" title="示例数据库模式OE中的表purchaseorder是以对象关系存储的。每个采购订单文档都有一个Reference元素;这个元素是一个单身人士。因此，您可以使用快捷方式在基础对象关系数据上创建索引。">索引非重复文本节点或属性值</a>以获取有关使用应用于<code class="codeph">XMLQuery</code>的<code class="codeph">XMLCast</code>快捷方式和<code class="codeph">extractValue</code>快捷方式索引单例数据的信息</p>
                           </li>
                           <li>
                              <p>有关过程<code class="codeph">XPath2TabColMapping</code>信息，请<code class="codeph">XPath2TabColMapping</code> <a href="../arpls/DBMS_XMLSTORAGE_MANAGE.html#ARPLS74503" target="_blank"><span><cite>Oracle Database PL / SQL包和类型参考</cite></span></a></p>
                           </li>
                        </ul>
                     </div>
                     <div class="example" id="GUID-2A9AEEC5-6CD1-4A17-A3A7-08E86E547C2F__CACIIDHJ">
                        <p class="titleinexample">示例19-5分析执行计划以确定要索引的列</p><pre class="oac_no_warn" dir="ltr">谓词信息（由操作ID标识）：----------------------------------------- ---------- 1  - 过滤器（ <span class="bold">CAST</span> （“PURCHASEORDER”。“ <span class="bold">SYS_NC00021 $</span> ”AS VARCHAR2（128））='Sarah J. Bell'和SYS_CHECKACL（“ACLOID”，“OWNERID”，xmltype（ '&lt;privilege xmlns =“http://xmlns.oracle.com/xdb/acl.xsd”xmlns：xsi =“http://www.w3.org/2001/XMLSchema-instance”xsi：schemaLocation =“http： //xmlns.oracle.com/xdb/acl.xsd http://xmlns.oracle.com/xdb/acl.xsd DAV：http：//xmlns.oracle.com/xdb/dav.xsd“&gt; &lt;read-属性/&gt; &lt;读内容/&gt; &lt;/特权&gt;'））= 1）</pre></div>
                     <!-- class="example" -->
                     <div class="example" id="GUID-2A9AEEC5-6CD1-4A17-A3A7-08E86E547C2F__CHDCHCCB">
                        <p class="titleinexample">示例19-6使用DBMS_XMLSTORAGE_MANAGE.XPATH2TABCOLMAPPING</p><pre class="oac_no_warn" dir="ltr">SELECT DBMS_XMLSTORAGE_MANAGE.XPath2TabColMapping（USER，'PURCHASEORDER'，''，'/ PurchaseOrder / Requestor'，''）FROM DUAL; DBMS_XMLSTORAGE_MANAGE.XPath2TabColMapping（US --------------------------------------------- &lt;Result&gt; &lt;Mapping TableName =“PURCHASEORDER”ColumnName =“SYS_NC00021 $”/&gt; &lt;/ Result&gt;</pre></div>
                     <!-- class="example" -->
                     <div class="example" id="GUID-2A9AEEC5-6CD1-4A17-A3A7-08E86E547C2F__CACDBHCJ">
                        <p class="titleinexample">示例19-7在谓词的目标列上创建索引</p><pre class="oac_no_warn" dir="ltr">CREATE INDEX requestor_index ON purchaseorder（“SYS_NC00021 $”）; CREATE INDEX requestor_index ON purchaseorder（“XMLDATA”。“REQUESTOR”）; CREATE INDEX requestor_index ON purchaseorder（extractvalue（OBJECT_VALUE，'/ PurchaseOrder / Requestor'））;</pre></div>
                     <!-- class="example" -->
                     <div class="example" id="GUID-2A9AEEC5-6CD1-4A17-A3A7-08E86E547C2F__CACCAJDI">
                        <p class="titleinexample">示例19-8为谓词列出的列创建基于函数的索引</p><pre class="oac_no_warn" dir="ltr">CREATE INDEX requestor_index ON purchaseorder（ <span class="bold">cast</span> （“XMLDATA”。“ <span class="bold">REQUESTOR</span> ”AS VARCHAR2（128）））;</pre></div>
                     <!-- class="example" -->
                     <div class="example" id="GUID-2A9AEEC5-6CD1-4A17-A3A7-08E86E547C2F__CACJEJBH">
                        <p class="titleinexample">示例19-9显示索引被提取的执行计划</p><pre class="oac_no_warn" dir="ltr">-------------------------------------------------- --------------------------------------------- | Id |操作|名称|行|字节|成本（％CPU）|时间| -------------------------------------------------- --------------------------------------------- | 0 |选择声明| | 1 | 524 | 2（0）| 00:00:01 | | * 1 |按INDEX ROWID表的访问权限|购买| 1 | 524 | 2（0）| 00:00:01 | | * 2 | INDEX RANGE SCAN | <span class="bold">REQUESTOR_INDEX</span> | 1 | | 1（0）| 00:00:01 | -------------------------------------------------- ---------------------------------------------谓词信息（由操作ID）：---------------------------------------------- ----- 1  - 过滤器（SYS_CHECKACL（“ACLOID”，“OWNERID”，xmltype（'&lt;privilege xmlns =“http://xmlns.oracle.com/xdb/acl.xsd”xmlns：xsi =“http： //www.w3.org/2001/XMLSchema-instance“xsi：schemaLocation =”http://xmlns.oracle.com/xdb/acl.xsd http://xmlns.oracle.com/xdb/acl.xsd DAV ：http：//xmlns.oracle.com/xdb/dav.xsd“&gt; &lt;read-properties /&gt; &lt;read-contents /&gt; &lt;/ privilege&gt;'））= 1）2  - 访问（CAST（”SYS_NC00021 $“） AS VARCHAR2（128））='莎拉J.贝尔'）</pre></div>
                     <!-- class="example" -->
                     <div class="example" id="GUID-2A9AEEC5-6CD1-4A17-A3A7-08E86E547C2F__CACCGFBB">
                        <p class="titleinexample">示例19-10为谓词列出的列创建基于函数的索引</p><pre class="oac_no_warn" dir="ltr">CREATE INDEX requestor_index ON purchaseorder po（XMLCast（XMLQuery（'$ p / PurchaseOrder / Requestor'PASSING po。OBJECT_VALUE为“p”返回内容）AS VARCHAR2（128）））;</pre></div>
                     <!-- class="example" -->
                  </div>
                  <div>
                     <div class="familylinks">
                        <div class="parentlink">
                           <p><strong>父主题：</strong> <a href="XPath-rewrite-for-object-relational-storage.html#GUID-3B3A1D6C-38AF-4381-9F47-5E26AE84F157" title="提供了使用执行计划来分析查询执行的指南，以便（a）确定是否发生XPath重写，以及（b）通过使用二级索引来优化查询执行。这些准则仅适用于以对象关系存储的XMLType数据。">使用执行计划分析和优化XPath查询的准则</a></p>
                        </div>
                     </div>
                  </div>
                  
               </div><a id="ADXDB5859"></a><a id="ADXDB5860"></a><a id="ADXDB5858"></a><div class="props_rev_3"><a id="GUID-B10DA5D9-25C5-4F0B-AD4D-2CB93D5114D4" name="GUID-B10DA5D9-25C5-4F0B-AD4D-2CB93D5114D4"></a><h4 id="ADXDB-GUID-B10DA5D9-25C5-4F0B-AD4D-2CB93D5114D4" class="sect4"><span class="enumeration_section">19.4.4</span>指南：在有序集合表上创建索引</h4>
                  <div>
                     <p>如果集合存储为有序集合表（OCT）或<code class="codeph">XMLType</code>实例，则可以直接访问集合的成员。每个成员都成为一个表行，因此您可以使用SQL直接访问它。您通常可以通过索引此类集合成员来提高性能。
                     </p>
                     <p>您可以通过在（a）与集合XML元素或其属性对应的对象属性和（b）伪列<code class="codeph">NESTED_TABLE_ID</code>上创建<span class="italic">复合</span>索引来完成此<code class="codeph">NESTED_TABLE_ID</code> 。</p>
                     <p><a href="XPath-rewrite-for-object-relational-storage.html#GUID-B10DA5D9-25C5-4F0B-AD4D-2CB93D5114D4__CACHICDI">例19-11</a>显示了查询的执行计划，以查找包含部件号717951002372（具有值属性值<code class="codeph">717951002372</code>的<code class="codeph">Id</code>属性的<code class="codeph">Part</code>元素）的订单的文档中的<code class="codeph">Reference</code>元素。<code class="codeph">LineItem</code>元素的集合作为行存储在有序集合表<code class="codeph">lineitem_table</code> 。
                     </p>
                     <div class="infoboxnote" id="GUID-B10DA5D9-25C5-4F0B-AD4D-2CB93D5114D4__GUID-44E812FA-5D62-41BD-B1F9-19C6CFBBB8E2">
                        <p class="notep1">注意：</p>
                        <p><a href="XPath-rewrite-for-object-relational-storage.html#GUID-B10DA5D9-25C5-4F0B-AD4D-2CB93D5114D4__CACHICDI">示例19-11</a>不使用示例数据库模式<code class="codeph">OE</code>的<code class="codeph">purchaseorder</code>表。它使用<code class="codeph">purchaseorder</code>表，该表使用名为<code class="codeph">lineitem_table</code>的有序集合表（OCT）作为集合元素<code class="codeph">LineItem</code> 。
                        </p>
                     </div>
                     <p>执行计划显示有序集合表<code class="codeph">lineitem_table</code>的完整扫描。如果在<code class="codeph">purchaseorder</code>表中只有几百个文档，这是可以接受的，但如果表中有数千或数百万个文档，那将是不可接受的。
                     </p>
                     <p>为了提高此类查询的性能，您可以创建一个索引，在给定属性<code class="codeph">Id</code>的值的情况下，该索引提供对伪列<code class="codeph">NESTED_TABLE_ID</code>直接访问。遗憾的是，Oracle XML DB不允许直接使用XPath表达式创建集合上的索引。要创建索引，您必须了解用于管理<code class="codeph">LineItem</code>元素的SQL对象的结构。根据此信息，您可以使用传统的对象关系SQL创建所需的索引。</p>
                     <p>在这种情况下，元素<code class="codeph">LineItem</code>存储为对象类型<code class="codeph">lineitem_t</code>的实例。元素<code class="codeph">Part</code>存储为SQL数据类型<code class="codeph">part_t</code>的实例。XML属性<code class="codeph">Id</code>映射到对象属性<code class="codeph">part_number</code> 。根据此信息，您可以在属性<code class="codeph">part_number</code>和伪列<code class="codeph">NESTED_TABLE_ID</code>上创建<span class="italic">复合索引</span> ，如<a href="XPath-rewrite-for-object-relational-storage.html#GUID-B10DA5D9-25C5-4F0B-AD4D-2CB93D5114D4__CACDIGJF">例19-12</a>所示。此索引提供对具有引用所需部分的<code class="codeph">LineItem</code>元素的那些采购订单文档的直接访问。
                     </p>
                     <div class="example" id="GUID-B10DA5D9-25C5-4F0B-AD4D-2CB93D5114D4__CACHICDI">
                        <p class="titleinexample">例19-11选择集合元素的执行计划</p><pre class="pre codeblock"><code>SELECT XMLCast（XMLQuery（'$ p / PurchaseOrder / Reference'PASSING OBJECT_VALUE AS“p”RETURNING CONTENT）AS VARCHAR2（4000））“Reference”FROM purchaseorder WHERE XMLExists（'$ p / PurchaseOrder / LineItems / LineItem / Part [@Id =“717951002372”]'传递OBJECT_VALUE为“p”）;</code></pre><pre class="pre codeblock"><code>-------------------------------------------------- -------------------------------------------------- --- | Id |操作|名称|行|字节|成本（％CPU）|时间| -------------------------------------------------- -------------------------------------------------- --- | 0 |选择声明| | 21 | 2352 | 20（10）| 00:00:01 | | * 1 | HASH JOIN RIGHT SEMI | | 21 | 2352 | 20（10）| 00:00:01 | | 2 |加入过滤器创建| ：BF0000 | 22 | 880 | 14（8）| 00:00:01 | | * 3 | <span class="bold">表访问完全</span> | <span class="bold">LINEITEM_TABLE</span> | 22 | 880 | 14（8）| 00:00:01 | | 4 |加入过滤器使用| ：BF0000 | 132 | 9504 | 5（0）| 00:00:01 | | * 5 |表访问完全|购买| 132 | 9504 | 5（0）| 00:00:01 | -------------------------------------------------- -------------------------------------------------- ---谓词信息（由操作ID标识）：-------------------------------------- ------------- 1  -  access（“NESTED_TABLE_ID”=“PURCHASEORDER”。“SYS_NC0003400035 $”）3  - 过滤器（“SYS_NC00011 $”='717951002372'）5  - 过滤器（SYS_OP_BLOOM_FILTER（： BF0000， “PURCHASEORDER”， “SYS_NC0003400035 $”））</code></pre></div>
                     <!-- class="example" -->
                     <div class="example" id="GUID-B10DA5D9-25C5-4F0B-AD4D-2CB93D5114D4__CACDIGJF">
                        <p class="titleinexample">示例19-12创建直接访问有序集合表的索引</p><pre class="pre codeblock"><code>CREATE INDEX lineitem_part_index ON lineitem_table l（l.part.part_number，l。<span class="bold">NESTED_TABLE_ID</span> ）;</code></pre></div>
                     <!-- class="example" -->
                  </div>
                  <div>
                     <div class="familylinks">
                        <div class="parentlink">
                           <p><strong>父主题：</strong> <a href="XPath-rewrite-for-object-relational-storage.html#GUID-3B3A1D6C-38AF-4381-9F47-5E26AE84F157" title="提供了使用执行计划来分析查询执行的指南，以便（a）确定是否发生XPath重写，以及（b）通过使用二级索引来优化查询执行。这些准则仅适用于以对象关系存储的XMLType数据。">使用执行计划分析和优化XPath查询的准则</a></p>
                        </div>
                     </div>
                  </div>
                  
               </div><a id="ADXDB5861"></a><div class="props_rev_3"><a id="GUID-7F6CF536-9DDC-42C8-AB0D-115A5300C616" name="GUID-7F6CF536-9DDC-42C8-AB0D-115A5300C616"></a><h4 id="ADXDB-GUID-7F6CF536-9DDC-42C8-AB0D-115A5300C616" class="sect4"><span class="enumeration_section">19.4.5</span>指南：使用XMLOptimizationCheck确定不重写查询的原因</h4>
                  <div>
                     <p>如果尚未优化查询，则可以使用系统变量<code class="codeph">XMLOptimizationCheck</code>来尝试确定原因。
                     </p>
                     <div class="section"></div>
                     <!-- class="section" -->
                  </div>
                  <div>
                     <div class="relinfo">
                        <p><strong>相关话题</strong></p>
                        <ul>
                           <li><a href="query-and-update-XML.html#GUID-F6E94E06-C4A3-4956-868C-E33BD34D3116" title="您可以检查SQL代码的执行计划，以确定是否发生XQuery优化或计划是否是次优的。">XQuery优化的诊断：XMLOptimizationCheck</a></li>
                        </ul>
                     </div>
                     <div class="familylinks">
                        <div class="parentlink">
                           <p><strong>父主题：</strong> <a href="XPath-rewrite-for-object-relational-storage.html#GUID-3B3A1D6C-38AF-4381-9F47-5E26AE84F157" title="提供了使用执行计划来分析查询执行的指南，以便（a）确定是否发生XPath重写，以及（b）通过使用二级索引来优化查询执行。这些准则仅适用于以对象关系存储的XMLType数据。">使用执行计划分析和优化XPath查询的准则</a></p>
                        </div>
                     </div>
                  </div>
                  
               </div>
            </div>
            <hr><br><p style="text-decoration:underline">脚注图例</p>脚注1：<p>此示例使用示例数据库模式<code class="codeph">OE</code>及其表<code class="codeph">purchaseorder</code> 。此表的XML模式使用属性<code class="codeph">SQLName</code>进行批注，以指定SQL对象属性名称，例如<code class="codeph">REQUESTOR</code> - 请参见<a href="oracle-supplied-XML-schemas-and-examples.html#GUID-1CB2213C-C6E8-4BC4-86A3-EFDE51AEBEFD__BABDAGBF">示例A-2</a> 。没有这样的注释，这个例子将使用<code class="codeph">p."XMLDATA"."</code> <span class="bold"><code class="codeph">Requestor</code></span> <code class="codeph">"</code> ，而不是<code class="codeph">p."XMLDATA"."</code><span class="bold"><code class="codeph">REQUESTOR</code></span> <code class="codeph">"</code> 。
            </p><br></div>
      </article>
   </body>
</html>