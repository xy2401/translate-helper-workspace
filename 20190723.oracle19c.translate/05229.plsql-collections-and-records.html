<html lang="en-us" dir="ltr" xml:lang="en-us">
   <head>
      <meta http-equiv="Content-Type" content="text/html; charset=utf-8"></meta>
      <meta name="viewport" content="width=device-width, initial-scale=1"></meta>
      <meta http-equiv="X-UA-Compatible" content="IE=edge"></meta>
      <meta name="abstract" content="PL/SQL lets you define two kinds of composite data types: collection and record."></meta>
      <meta name="description" content="PL/SQL lets you define two kinds of composite data types: collection and record."></meta>
      <title>PL / SQL集合和记录</title>
      <meta property="og:site_name" content="Oracle Help Center"></meta>
      <meta property="og:title" content="Database PL/SQL Language Reference "></meta>
      <meta property="og:description" content="PL/SQL lets you define two kinds of composite data types: collection and record."></meta>
      <link rel="stylesheet" href="/sp_common/book-template/ohc-book-template/css/book.css"></link>
      <link rel="shortcut icon" href="/sp_common/book-template/ohc-common/img/favicon.ico"></link>
      <meta name="application-name" content="Database PL/SQL Language Reference"></meta>
      <meta name="generator" content="DITA Open Toolkit version 1.8.5 (Mode = doc)"></meta>
      <meta name="plugin" content="SP_docbuilder HTML plugin release 18.2.2"></meta>
      <link rel="alternate" href="database-pl-sql-language-reference.pdf" title="PDF File" type="application/pdf"></link>
      <meta name="robots" content="all"></meta>
      <link rel="schema.dcterms" href="http://purl.org/dc/terms/"></link>
      <meta name="dcterms.created" content="2019-01-13T20:26:20-08:00"></meta>
      
      <meta name="dcterms.dateCopyrighted" content="1996, 2019"></meta>
      <meta name="dcterms.category" content="database"></meta>
      <meta name="dcterms.identifier" content="E96448-02"></meta>
      
      <meta name="dcterms.product" content="en/database/oracle/oracle-database/19"></meta>
      
      <link rel="prev" href="plsql-control-statements.html" title="Previous" type="text/html"></link>
      <link rel="next" href="static-sql.html" title="Next" type="text/html"></link>
      <script>
        document.write('<style type="text/css">');
        document.write('body > .noscript, body > .noscript ~ * { visibility: hidden; }');
        document.write('</style>');
     </script>
      <script src="/sp_common/book-template/requirejs/require.js" data-main="/sp_common/book-template/ohc-book-template/js/book-config"></script>
      <script>
            if (window.require === undefined) {
                document.write('<script data-main="sp_common/book-template/ohc-book-template/js/book-config" src="sp_common/book-template/requirejs/require.js"><\/script>');
                document.write('<link href="sp_common/book-template/ohc-book-template/css/book.css" rel="stylesheet"/>');
            }
        </script>
      <script type="application/json" id="ssot-metadata">{"primary":{"category":{"short_name":"database","element_name":"Database","display_in_url":true},"suite":{"short_name":"oracle","element_name":"Oracle","display_in_url":true},"product_group":{"short_name":"not-applicable","element_name":"Not applicable","display_in_url":false},"product":{"short_name":"oracle-database","element_name":"Oracle Database","display_in_url":true},"release":{"short_name":"19","element_name":"Release 19","display_in_url":true}}}</script>
      
    <meta name="dcterms.title" content="Database PL/SQL Language Reference"></meta>
    <meta name="dcterms.isVersionOf" content="LNPLS"></meta>
    <meta name="dcterms.release" content="Release 19"></meta>
  </head>
   <body dir="ltr">
      <div class="noscript alert alert-danger text-center" role="alert">
         <a href="plsql-control-statements.html" class="pull-left"><span class="glyphicon glyphicon-chevron-left" aria-hidden="true"></span>上一页</a> <a href="static-sql.html" class="pull-right">下一页<span class="glyphicon glyphicon-chevron-right" aria-hidden="true"></span></a> <span class="fa fa-exclamation-triangle" aria-hidden="true"></span>必须启用JavaScript才能正确显示此内容</div>
      <article>
         <header>
            <ol class="breadcrumb" vocab="http://schema.org/" typeof="BreadcrumbList">
               <li property="itemListElement" typeof="ListItem"><a href="index.html" property="item" typeof="WebPage"><span property="name">数据库PL / SQL语言参考</span></a></li>
               <li class="active" property="itemListElement" typeof="ListItem">PL / SQL集合和记录</li>
            </ol>
            <a id="GUID-7115C8B6-62F9-496D-BEC3-F7441DFE148A" name="GUID-7115C8B6-62F9-496D-BEC3-F7441DFE148A"></a><a id="LNPLS345"></a><a id="LNPLS349"></a><a id="LNPLS005"></a>
            
            <h2 id="LNPLS-GUID-7115C8B6-62F9-496D-BEC3-F7441DFE148A" class="sect2"><span class="enumeration_chapter">5个</span> PL / SQL集合和记录</h2>
         </header>
         <div class="ind">
            <div>
               <p>PL / SQL允许您定义两种复合数据类型：集合和记录。</p>
               <p><span class="bold">复合数据类型</span>存储具有内部组件的值。您可以将整个复合变量作为参数传递给子程序，并且可以单独访问复合变量的内部组件。内部组件可以是标量或复合。您可以在任何可以使用标量变量的地方使用标量组件。您可以在任何可以使用相同类型的复合变量的地方使用复合组件。
               </p>
               <div class="infoboxnote" id="GUID-7115C8B6-62F9-496D-BEC3-F7441DFE148A__GUID-6EF2AA46-838A-412C-BEA8-34DE2B62FDFF">
                  <p class="notep1">注意：</p>
                  <p>如果将复合变量作为参数传递给远程子程序，则必须创建冗余环回<code class="codeph">DATABASE</code> <code class="codeph">LINK</code> ，以便在远程子程序编译时，验证源的类型检查器使用与用户定义相同的定义调用者使用的复合变量类型。
                  </p>
               </div>
               <p>在<span class="bold">集合中</span> ，内部组件始终具有相同的数据类型，并且称为<span class="bold">元素</span> 。您可以通过其唯一索引访问集合变量的每个元素，使用以下语法： <span class="italic"><code class="codeph">variable_name</code></span> <code class="codeph">(</code> <span class="italic"><code class="codeph">index</code></span> <code class="codeph">)</code> 。要创建集合变量，您可以定义集合类型，然后创建该类型的变量或使用<code class="codeph">%TYPE</code> 。</p>
               <p>在<span class="bold">记录中</span> ，内部组件可以具有不同的数据类型，并且称为<span class="bold">字段</span> 。您可以使用以下语法访问记录变量的每个字段： <span class="italic"><code class="codeph">variable_name.field_name</code></span> 。要创建记录变量，您可以定义<code class="codeph">RECORD</code>类型，然后创建该类型的变量或使用<code class="codeph">%ROWTYPE</code>或<code class="codeph">%TYPE</code> 。</p>
               <p>您可以创建记录集合以及包含集合的记录。</p>
               <div class="section" id="GUID-7115C8B6-62F9-496D-BEC3-F7441DFE148A__CHDFGHJF">
                  <p class="subhead1" id="GUID-7115C8B6-62F9-496D-BEC3-F7441DFE148A__GUID-C5C293B5-12FC-47CE-89B1-76A8ED729702">收集主题</p>
               </div>
               <!-- class="section" -->
               <ul style="list-style-type:disc">
                  <li>
                     <p><a href="plsql-collections-and-records.html#GUID-7E9034D5-0D33-43A1-9012-918350FE148C" title="PL / SQL有三种集合类型 - 关联数组，VARRAY（可变大小数组）和嵌套表。">集合类型</a></p>
                  </li>
                  <li>
                     <p><a href="plsql-collections-and-records.html#GUID-8060F01F-B53B-48D4-9239-7EA8461C2170" title="关联数组（以前称为PL / SQL表或索引表）是一组键值对。每个键都是唯一索引，用于通过语法variable_name（index）定位关联值。">关联数组</a></p>
                  </li>
                  <li>
                     <p><a href="plsql-collections-and-records.html#GUID-E932FC04-C7AD-4562-9555-8BA05446C0B8" title="varray（可变大小数组）是一个数组，其元素数可以从零（空）到声明的最大大小变化。">Varrays（可变大小的数组）</a></p>
                  </li>
                  <li>
                     <p><a href="plsql-collections-and-records.html#GUID-5ADB7EE2-71F6-4172-ACD8-FFDCF2787A37" title="在数据库中，嵌套表是一种列类型，它以无特定顺序存储未指定数量的行。">嵌套表</a></p>
                  </li>
                  <li>
                     <p><a href="plsql-collections-and-records.html#GUID-92967CC1-481E-472A-BB4C-90C60F75296D" title="集合构造函数（构造函数）是系统定义的函数，其名称与集合类型相同，后者返回该类型的集合。">集合构造函数</a></p>
                  </li>
                  <li>
                     <p><a href="plsql-collections-and-records.html#GUID-4B379569-4068-4DB1-9D69-E706F4AC5758" title="通过提供以需要值的紧凑形式声明和定义复杂值的能力，合格的表达式可提高程序清晰度和开发人员的工作效率。">合格的表达概述</a></p>
                  </li>
                  <li>
                     <p><a href="plsql-collections-and-records.html#GUID-7836EEC3-2642-4CF8-AA50-81034855119D" title="仅当集合具有相同的数据类型时，才可以将集合分配给集合变量。具有相同的元素类型是不够的。对于varray或嵌套表变量，可以指定值NULL或相同数据类型的null集合。赋值使变量为null。对于嵌套表变量，可以分配SQL MULTISET操作或SQL SET函数调用的结果。">将值分配给集合变量</a></p>
                  </li>
                  <li>
                     <p><a href="plsql-collections-and-records.html#GUID-2E00BF7F-0285-41F1-8075-AC859F622A3F" title="虽然集合只有一个维度，但您可以使用其元素为集合的集合对多维集合进行建模。">多维集合</a></p>
                  </li>
                  <li>
                     <p><a href="plsql-collections-and-records.html#GUID-68EC8EF3-E351-4917-8C7A-5103CDB2C01B" title="要确定一个集合变量是否小于另一个集合变量（例如），您必须在该上下文中定义小于均值的值，并编写一个返回TRUE或FALSE的函数。">收集比较</a></p>
                  </li>
                  <li>
                     <p><a href="plsql-collections-and-records.html#GUID-0452FBDC-D9C1-486E-B432-49AF84743A9F" title="集合方法是PL / SQL子程序 - 返回有关集合的信息的函数或对集合进行操作的过程。集合方法使集合更易于使用，并且您的应用程序更易于维护。">收集方法</a></p>
                  </li>
                  <li>
                     <p><a href="plsql-collections-and-records.html#GUID-7C84EBD2-D0A5-4126-8EB7-FF9243EE5B47" title="包规范中定义的集合类型与相同定义的本地或独立集合类型不兼容。">包装规格中定义的收集类型</a></p>
                  </li>
               </ul>
               <div class="infoboxnotealso" id="GUID-7115C8B6-62F9-496D-BEC3-F7441DFE148A__GUID-B0D95F51-E52C-495B-A702-92017F35FB1A">
                  <p class="notep1">也可以看看：</p>
                  <ul style="list-style-type:disc">
                     <li>
                        <p> 有关<code class="codeph">CREATE</code> <code class="codeph">DATABASE</code> <code class="codeph">LINK</code>语句的信息，请<a href="../sqlrf/CREATE-DATABASE-LINK.html#SQLRF01205" target="_blank"><span class="italic">参见Oracle数据库SQL语言参考</span></a></p>
                     </li>
                     <li>
                        <p><span class="q">“ <a href="static-sql.html#GUID-65ADB424-2C2D-49ED-9E98-99A3A68BA248">查询集合</a> ”</span></p>
                     </li>
                     <li>
                        <p>有关将查询结果检索到集合中的信息，请参阅<span class="q">“ <a href="plsql-optimization-and-tuning.html#GUID-19F50644-C88E-49AF-B31C-3EE4B4432714" title="BULK COLLECT子句是批量SQL的一个特性，它将结果从SQL返回到PL / SQL，而不是一次返回一个。">BULK COLLECT Clause</a> ”</span></p>
                     </li>
                     <li>
                        <p><span class="q">“ <a href="collection-variable.html#GUID-89A1863C-65A1-40CF-9392-86E9FDC21BE9" title="集合变量是一个复合变量，其内部组件（称为元素）具有相同的数据类型。">集合变量声明</a> ”，</span>用于集合类型定义和集合变量声明的语法和语义</p>
                     </li>
                  </ul>
               </div>
               <div class="section" id="GUID-7115C8B6-62F9-496D-BEC3-F7441DFE148A__CHDHCIAF">
                  <p class="subhead1" id="GUID-7115C8B6-62F9-496D-BEC3-F7441DFE148A__GUID-E79D4FEA-9D41-4CDB-ABCF-8EAAE6D5B204">记录主题</p>
               </div>
               <!-- class="section" -->
               <ul style="list-style-type:disc">
                  <li>
                     <p><a href="plsql-collections-and-records.html#GUID-75875E26-FC7B-4513-A5E2-EDA26F1D67B1" title="对于RECORD类型的记录变量，除非在定义类型时为其指定不同的初始值，否则每个字段的初始值均为NULL。声明记录常量时，必须创建一个用其初始值填充记录的函数，然后在常量声明中调用该函数。％ROWTYPE属性允许您声明一个记录变量，该变量表示数据库表或视图的完整行或部分行。">记录变量</a></p>
                  </li>
                  <li>
                     <p><a href="plsql-collections-and-records.html#GUID-794AD0D6-2D97-4C4A-B7DA-6126025EF2A5" title="记录变量表示记录变量或复合变量的记录组件。">将值分配给记录变量</a></p>
                  </li>
                  <li>
                     <p><a href="plsql-collections-and-records.html#GUID-DFDE40BD-4B61-4C8A-B9CE-3FE01E21F658" title="无法针对无效，平等或不平等进行本地测试。">记录比较</a></p>
                  </li>
                  <li>
                     <p><a href="plsql-collections-and-records.html#GUID-AC5CEFCB-87AA-41FD-AE16-FFE66606E6B1" title="SQL INSERT语句的PL / SQL扩展允许您将记录插入表中。">将记录插入表中</a></p>
                  </li>
                  <li>
                     <p><a href="plsql-collections-and-records.html#GUID-11D63245-591D-4CBF-BFBA-8F3C0AE0E968" title="SQL UPDATE语句的PL / SQL扩展允许您使用记录更新一个或多个表行。">使用记录更新行</a></p>
                  </li>
                  <li>
                     <p><a href="plsql-collections-and-records.html#GUID-EC8E43E9-8356-4256-857A-D8109F2CF324">记录插入和更新的限制</a></p>
                  </li>
               </ul>
               <div class="infoboxnote" id="GUID-7115C8B6-62F9-496D-BEC3-F7441DFE148A__GUID-0D9E1838-C09A-4C67-835C-6FFB729B07E0">
                  <p class="notep1">注意：</p>
                  <p>可以按任何顺序评估显式列出的复合数据结构（例如集合构造函数或记录初始值设定项）的组件。如果程序确定评估顺序，那么在程序执行此操作时，其行为是不确定的。</p>
               </div>
            </div><a id="LNPLS350"></a><a id="LNPLS351"></a><a id="LNPLS352"></a><a id="LNPLS353"></a><a id="LNPLS354"></a><a id="LNPLS355"></a><a id="LNPLS356"></a><a id="LNPLS00501"></a><div class="props_rev_3"><a id="GUID-7E9034D5-0D33-43A1-9012-918350FE148C" name="GUID-7E9034D5-0D33-43A1-9012-918350FE148C"></a><h3 id="LNPLS-GUID-7E9034D5-0D33-43A1-9012-918350FE148C" class="sect3"><span class="enumeration_section">5.1</span>集合类型</h3>
               <div>
                  <p>PL / SQL有三种集合类型 - 关联数组， <code class="codeph">VARRAY</code> （可变大小数组）和嵌套表。
                  </p>
                  <p><a href="plsql-collections-and-records.html#GUID-7E9034D5-0D33-43A1-9012-918350FE148C__CIHHDDGF" title="总结了三种PL / SQL集合的异同。">表5-1</a>总结了它们的相似之处和不同之处。
                  </p>
                  <div class="tblformalwide" id="GUID-7E9034D5-0D33-43A1-9012-918350FE148C__CIHHDDGF">
                     <p class="titleintable">表5-1 PL / SQL集合类型</p>
                     <table cellpadding="4" cellspacing="0" class="FormalWide" title="PL / SQL集合类型" width="100%" border="1" summary="Summarizes the similarities and differences of the three types of PL/SQL collections." frame="hsides" rules="rows">
                        <thead>
                           <tr align="left" valign="top">
                              <th align="left" valign="bottom" width="19%" id="d36567e637">收集类型</th>
                              <th align="left" valign="bottom" width="12%" id="d36567e639">元素数量</th>
                              <th align="left" valign="bottom" width="11%" id="d36567e641">索引类型</th>
                              <th align="left" valign="bottom" width="13%" id="d36567e643">密集或稀疏</th>
                              <th align="left" valign="bottom" width="13%" id="d36567e645">未初始化状态</th>
                              <th align="left" valign="bottom" width="16%" id="d36567e647">在哪里定义</th>
                              <th align="left" valign="bottom" width="15%" id="d36567e649">可以是ADT属性数据类型</th>
                           </tr>
                        </thead>
                        <tbody>
                           <tr align="left" valign="top">
                              <td align="left" valign="top" width="19%" id="d36567e653" headers="d36567e637 ">
                                 <p>关联数组（或索引表）</p>
                              </td>
                              <td align="left" valign="top" width="12%" headers="d36567e653 d36567e639 ">
                                 <p>不明</p>
                              </td>
                              <td align="left" valign="top" width="11%" headers="d36567e653 d36567e641 ">
                                 <p>字符串或<code class="codeph">PLS_INTEGER</code></p>
                              </td>
                              <td align="left" valign="top" width="13%" headers="d36567e653 d36567e643 ">
                                 <p>或</p>
                              </td>
                              <td align="left" valign="top" width="13%" headers="d36567e653 d36567e645 ">
                                 <p>空</p>
                              </td>
                              <td align="left" valign="top" width="16%" headers="d36567e653 d36567e647 ">
                                 <p>在PL / SQL块或包中</p>
                              </td>
                              <td align="left" valign="top" width="15%" headers="d36567e653 d36567e649 ">
                                 <p>没有</p>
                              </td>
                           </tr>
                           <tr align="left" valign="top">
                              <td align="left" valign="top" width="19%" id="d36567e677" headers="d36567e637 ">
                                 <p><code class="codeph">VARRAY</code> （可变大小数组）</p>
                              </td>
                              <td align="left" valign="top" width="12%" headers="d36567e677 d36567e639 ">
                                 <p>规定</p>
                              </td>
                              <td align="left" valign="top" width="11%" headers="d36567e677 d36567e641 ">
                                 <p>整数</p>
                              </td>
                              <td align="left" valign="top" width="13%" headers="d36567e677 d36567e643 ">
                                 <p>总是密集的</p>
                              </td>
                              <td align="left" valign="top" width="13%" headers="d36567e677 d36567e645 ">
                                 <p>空值</p>
                              </td>
                              <td align="left" valign="top" width="16%" headers="d36567e677 d36567e647 ">
                                 <p>在PL / SQL块或包中或在模式级别</p>
                              </td>
                              <td align="left" valign="top" width="15%" headers="d36567e677 d36567e649 ">
                                 <p>仅在架构级别定义时</p>
                              </td>
                           </tr>
                           <tr align="left" valign="top">
                              <td align="left" valign="top" width="19%" id="d36567e701" headers="d36567e637 ">
                                 <p>嵌套表</p>
                              </td>
                              <td align="left" valign="top" width="12%" headers="d36567e701 d36567e639 ">
                                 <p>不明</p>
                              </td>
                              <td align="left" valign="top" width="11%" headers="d36567e701 d36567e641 ">
                                 <p>整数</p>
                              </td>
                              <td align="left" valign="top" width="13%" headers="d36567e701 d36567e643 ">
                                 <p>开始密集，可以变得稀疏</p>
                              </td>
                              <td align="left" valign="top" width="13%" headers="d36567e701 d36567e645 ">
                                 <p>空值</p>
                              </td>
                              <td align="left" valign="top" width="16%" headers="d36567e701 d36567e647 ">
                                 <p>在PL / SQL块或包中或在模式级别</p>
                              </td>
                              <td align="left" valign="top" width="15%" headers="d36567e701 d36567e649 ">
                                 <p>仅在架构级别定义时</p>
                              </td>
                           </tr>
                        </tbody>
                     </table>
                  </div>
                  <!-- class="inftblhruleinformal" -->
                  <div class="section" id="GUID-7E9034D5-0D33-43A1-9012-918350FE148C__CIHHHHAG">
                     <p class="subhead2" id="GUID-7E9034D5-0D33-43A1-9012-918350FE148C__GUID-FA1CC9EA-4573-4AB9-BFA8-39C442A077D0">元素数量</p>
                  </div>
                  <!-- class="section" -->
                  <div class="section">
                     <p>如果指定了元素数，则它是集合中元素的最大数量。如果未指定元素数，则集合中的最大元素数是索引类型的上限。</p>
                  </div>
                  <!-- class="section" -->
                  <div class="section" id="GUID-7E9034D5-0D33-43A1-9012-918350FE148C__CIHDHIFD">
                     <p class="subhead2" id="GUID-7E9034D5-0D33-43A1-9012-918350FE148C__GUID-6567234A-2303-4C7B-8233-85EAFC00754A">密集或稀疏</p>
                  </div>
                  <!-- class="section" -->
                  <div class="section">
                     <p><span class="bold">密集集合</span>在元素之间没有间隙 - 第一个元素和最后一个元素之间的每个元素都被定义并且具有值（除非元素具有<code class="codeph">NOT</code> <code class="codeph">NULL</code>约束，否则该值可以为<code class="codeph">NULL</code> ）。<span class="bold">稀疏集合</span>在元素之间存在间隙。
                     </p>
                  </div>
                  <!-- class="section" -->
                  <div class="section" id="GUID-7E9034D5-0D33-43A1-9012-918350FE148C__CIHCDDDG">
                     <p class="subhead2" id="GUID-7E9034D5-0D33-43A1-9012-918350FE148C__GUID-991E22B8-56BA-4D34-8FB7-E37AAFD20BD8">未初始化状态</p>
                  </div>
                  <!-- class="section" -->
                  <div class="section">
                     <p>存在<span class="bold">空集合</span>但没有元素。要将元素添加到空集合，请调用<code class="codeph">EXTEND</code>方法（在<span class="q">“ <a href="plsql-collections-and-records.html#GUID-03F74821-BC33-4544-9304-5FBBE6EFE450" title="EXTEND是一个向varray或嵌套表的末尾添加元素的过程。">EXTEND集合方法</a> ”中</span>描述）。
                     </p>
                     <p><span class="bold">null集合</span> （也称为<span class="bold">原子空集合</span> ）不存在。要将空集合更改为现有集合，必须通过将其设置为空或为其指定非<code class="codeph">NULL</code>值来初始化它（有关详细信息，请参阅<span class="q">“ <a href="plsql-collections-and-records.html#GUID-92967CC1-481E-472A-BB4C-90C60F75296D" title="集合构造函数（构造函数）是系统定义的函数，其名称与集合类型相同，后者返回该类型的集合。">集合构造函数</a> ”</span>和<span class="q">“ <a href="plsql-collections-and-records.html#GUID-7836EEC3-2642-4CF8-AA50-81034855119D" title="仅当集合具有相同的数据类型时，才可以将集合分配给集合变量。具有相同的元素类型是不够的。对于varray或嵌套表变量，可以指定值NULL或相同数据类型的null集合。赋值使变量为null。对于嵌套表变量，可以分配SQL MULTISET操作或SQL SET函数调用的结果。">将值分配给集合变量</a> ”</span> ）。您不能使用<code class="codeph">EXTEND</code>方法初始化<code class="codeph">EXTEND</code> 。
                     </p>
                  </div>
                  <!-- class="section" -->
                  <div class="section" id="GUID-7E9034D5-0D33-43A1-9012-918350FE148C__CIHFCEAE">
                     <p class="subhead2" id="GUID-7E9034D5-0D33-43A1-9012-918350FE148C__GUID-8C030ED1-3103-4655-8317-E1A53D236312">在哪里定义</p>
                  </div>
                  <!-- class="section" -->
                  <div class="section">
                     <p>PL / SQL块中定义的集合类型是<span class="bold">本地类型</span> 。它仅在块中可用，并且仅当块位于独立程序包或程序包子程序中时才存储在数据库中。（独立和包子程序在<span class="q">“ <a href="plsql-subprograms.html#GUID-E03F512B-1A30-43B4-8DCA-64DA68AE7CE4">嵌套，包和独立子程序</a> ”中有说明</span> 。）
                     </p>
                     <p>包规范中定义的集合类型是<span class="bold">公共项</span> 。您可以通过使用包名称（ <span class="italic"><code class="codeph">package_name.type_name</code></span> ）对其进行限定来从包外引用它。它将存储在数据库中，直到您删除包。（包在<a href="plsql-packages.html#GUID-C285EC5A-BE50-4192-A88E-48C0778B34E0" title="本章介绍如何将相关的PL / SQL代码和数据捆绑到一个包中，其内容可供许多应用程序使用。">PL / SQL包</a>中解释。）
                     </p>
                     <p>在架构级别定义的集合类型是<span class="bold">独立类型</span> 。您可以使用<span class="q">“ <a href="CREATE-TYPE-statement.html#GUID-389D603D-FBD0-452A-8414-240BBBC57034" title="CREATE TYPE语句指定类型的名称及其属性，方法和其他属性。">CREATE TYPE语句</a> ”</span>创建它。它存储在数据库中，直到您使用<span class="q">“ <a href="DROP-TYPE-statement.html#GUID-EDB83D12-26B5-42D1-9DB6-BD8AAB6490EC" title="DROP TYPE语句删除ADT，VARRAY类型或嵌套表类型的规范和正文。">DROP TYPE语句</a> ”</span>删除它。
                     </p>
                     <div class="infoboxnote" id="GUID-7E9034D5-0D33-43A1-9012-918350FE148C__GUID-B496A4B0-5BE4-4189-A0AD-41B60A82018A">
                        <p class="notep1">注意：</p>
                        <p>包规范中定义的集合类型与相同定义的本地或独立集合类型不兼容（请参阅<a href="plsql-collections-and-records.html#GUID-7C84EBD2-D0A5-4126-8EB7-FF9243EE5B47__CHDIHDIJ">示例5-33</a>和<a href="plsql-collections-and-records.html#GUID-7C84EBD2-D0A5-4126-8EB7-FF9243EE5B47__CIHBGBBH">示例5-34</a> ）。
                        </p>
                     </div>
                  </div>
                  <!-- class="section" -->
                  <div class="section" id="GUID-7E9034D5-0D33-43A1-9012-918350FE148C__CIHDDDIG">
                     <p class="subhead2" id="GUID-7E9034D5-0D33-43A1-9012-918350FE148C__GUID-D78F61C6-A94E-48C8-9E33-4BE5EC2D710E">可以是ADT属性数据类型</p>
                  </div>
                  <!-- class="section" -->
                  <div class="section">
                     <p>要成为ADT属性数据类型，集合类型必须是独立集合类型。有关其他限制，请参阅<span class="bold"><a href="CREATE-TYPE-statement.html#GUID-389D603D-FBD0-452A-8414-240BBBC57034__BABEHDBJ">数据类型的限制</a></span> 。
                     </p>
                  </div>
                  <!-- class="section" -->
                  <div class="section">
                     <p class="subhead2" id="GUID-7E9034D5-0D33-43A1-9012-918350FE148C__GUID-4B5B2EFD-9428-4AA1-94EC-3278D595D08C">将非PL / SQL复合类型转换为PL / SQL复合类型</p>
                  </div>
                  <!-- class="section" -->
                  <div class="section">
                     <p>如果您有使用其他语言的代码或业务逻辑，通常可以转换数组并将该语言的类型直接设置为PL / SQL集合类型。例如：</p>
                     <div class="tblformal" id="GUID-7E9034D5-0D33-43A1-9012-918350FE148C__GUID-40D3ACE9-7926-4D89-BD10-2A576AC86A6C">
                        <table cellpadding="4" cellspacing="0" class="Formal" title="" width="100%" border="1" summary="This table gives five examples of non-PL/SQL composite types and their equivalent PL/SQL composite types." frame="hsides" rules="rows">
                           <thead>
                              <tr align="left" valign="top">
                                 <th align="left" valign="bottom" width="36%" id="d36567e903">非PL / SQL复合类型</th>
                                 <th align="left" valign="bottom" width="64%" id="d36567e905">等效PL / SQL复合类型</th>
                              </tr>
                           </thead>
                           <tbody>
                              <tr align="left" valign="top">
                                 <td align="left" valign="top" width="36%" id="d36567e909" headers="d36567e903 ">
                                    <p>哈希表</p>
                                 </td>
                                 <td align="left" valign="top" width="64%" headers="d36567e909 d36567e905 ">
                                    <p>关联数组</p>
                                 </td>
                              </tr>
                              <tr align="left" valign="top">
                                 <td align="left" valign="top" width="36%" id="d36567e916" headers="d36567e903 ">
                                    <p>无序的表</p>
                                 </td>
                                 <td align="left" valign="top" width="64%" headers="d36567e916 d36567e905 ">
                                    <p>关联数组</p>
                                 </td>
                              </tr>
                              <tr align="left" valign="top">
                                 <td align="left" valign="top" width="36%" id="d36567e923" headers="d36567e903 ">
                                    <p>组</p>
                                 </td>
                                 <td align="left" valign="top" width="64%" headers="d36567e923 d36567e905 ">
                                    <p>嵌套表</p>
                                 </td>
                              </tr>
                              <tr align="left" valign="top">
                                 <td align="left" valign="top" width="36%" id="d36567e930" headers="d36567e903 ">
                                    <p>袋</p>
                                 </td>
                                 <td align="left" valign="top" width="64%" headers="d36567e930 d36567e905 ">
                                    <p>嵌套表</p>
                                 </td>
                              </tr>
                              <tr align="left" valign="top">
                                 <td align="left" valign="top" width="36%" id="d36567e937" headers="d36567e903 ">
                                    <p>排列</p>
                                 </td>
                                 <td align="left" valign="top" width="64%" headers="d36567e937 d36567e905 ">
                                    <p><code class="codeph">VARRAY</code></p>
                                 </td>
                              </tr>
                           </tbody>
                        </table>
                     </div>
                     <!-- class="inftblhruleinformal" -->
                     <div class="infoboxnotealso" id="GUID-7E9034D5-0D33-43A1-9012-918350FE148C__GUID-6AEE21F7-4CEB-4628-9515-2AA6D78C4601">
                        <p class="notep1">也可以看看：</p>
                        <p>有关<code class="codeph">CAST</code>函数的信息，请参阅<a href="../sqlrf/CAST.html#SQLRF00613" target="_blank"><span class="italic">Oracle数据库SQL语言参考</span></a> ，该函数将一种SQL数据类型或集合类型值转换为另一种SQL数据类型或集合类型值。
                        </p>
                     </div>
                  </div>
                  <!-- class="section" -->
               </div>
            </div><a id="LNPLS357"></a><a id="LNPLS440"></a><a id="LNPLS461"></a><a id="LNPLS99969"></a><div class="props_rev_3"><a id="GUID-8060F01F-B53B-48D4-9239-7EA8461C2170" name="GUID-8060F01F-B53B-48D4-9239-7EA8461C2170"></a><h3 id="LNPLS-GUID-8060F01F-B53B-48D4-9239-7EA8461C2170" class="sect3"><span class="enumeration_section">5.2</span>关联数组</h3>
               <div>
                  <p><span class="bold">关联数组</span> （以前称为<span class="bold">PL / SQL表</span>或<span class="bold">索引表</span> ）是一组键值对。每个键都是唯一索引，用于通过语法<span class="italic"><code class="codeph">variable_name</code></span> <code class="codeph">(</code> <span class="italic"><code class="codeph">index</code></span> <code class="codeph">)</code>定位关联值。
                  </p>
                  <p><span class="italic"><code class="codeph">index</code></span>的数据类型可以是字符串类型（ <code class="codeph">VARCHAR2</code> ， <code class="codeph">VARCHAR</code> ， <code class="codeph">STRING</code>或<code class="codeph">LONG</code> ）或<code class="codeph">PLS_INTEGER</code> 。索引按排序顺序存储，而不是创建顺序。对于字符串类型，排序顺序由初始化参数<code class="codeph">NLS_SORT</code>和<code class="codeph">NLS_COMP</code> 。</p>
                  <p>像数据库表一样，是一个关联数组：</p>
                  <ul style="list-style-type:disc">
                     <li>
                        <p>在填充之前是空的（但不是null）</p>
                     </li>
                     <li>
                        <p>可以容纳未指定数量的元素，您可以在不知道其位置的情况下访问这些元素</p>
                     </li>
                  </ul>
                  <p>与数据库表不同，是一个关联数组：</p>
                  <ul style="list-style-type:disc">
                     <li>
                        <p>不需要磁盘空间或网络操作</p>
                     </li>
                     <li>
                        <p>无法使用DML语句进行操作</p>
                     </li>
                  </ul>
                  <div class="section">
                     <p class="subhead2" id="GUID-8060F01F-B53B-48D4-9239-7EA8461C2170__GUID-11274861-BA7F-423C-90CE-2AC9A495B41D">话题</p>
                  </div>
                  <!-- class="section" -->
                  <div class="section">
                     <ul style="list-style-type:disc">
                        <li>
                           <p><a href="plsql-collections-and-records.html#GUID-8A3DD42E-72A1-4807-8650-E92F5FD89763" title="声明关联数组常量时，必须创建一个函数，用其初始值填充关联数组，然后在常量声明中调用该函数。">声明关联数组常量</a></p>
                        </li>
                        <li>
                           <p><a href="plsql-collections-and-records.html#GUID-8453D24B-DBF3-4127-AD42-88D49F3DBC26" title="国家语言支持（NLS）参数（如NLS_SORT，NLS_COMP和NLS_DATE_FORMAT）会影响由字符串索引的关联数组。">NLS参数值影响由String索引的关联数组</a></p>
                        </li>
                        <li>
                           <p><a href="plsql-collections-and-records.html#GUID-157A4309-1BAF-419D-8B7F-3CB4AA9921DF">关联数组的适当用途</a></p>
                        </li>
                     </ul>
                     <div class="infoboxnotealso" id="GUID-8060F01F-B53B-48D4-9239-7EA8461C2170__GUID-A68FDBE6-7DCC-4851-AF57-C794CAB47DCE">
                        <p class="notep1">也可以看看：</p>
                        <ul style="list-style-type:disc">
                           <li>
                              <p><a href="plsql-collections-and-records.html#GUID-7E9034D5-0D33-43A1-9012-918350FE148C__CIHHDDGF" title="总结了三种PL / SQL集合的异同。">表5-1</a>了解关联数组特征的摘要</p>
                           </li>
                           <li>
                              <p><span class="q">“ <a href="collection-variable.html#GUID-89A1863C-65A1-40CF-9392-86E9FDC21BE9__CJABHAHJ">assoc_array_type_def :: =</a> ”</span>表示关联数组类型定义的语法</p>
                           </li>
                        </ul>
                     </div>
                  </div>
                  <!-- class="section" -->
                  <div class="example" id="GUID-8060F01F-B53B-48D4-9239-7EA8461C2170__BABHGFHJ">
                     <p class="titleinexample">例5-1由字符串索引的关联数组</p>
                     <p>此示例定义了一种由string索引的关联数组类型，声明了该类型的变量，使用三个元素填充变量，更改一个元素的值，并打印值（按排序顺序，而不是创建顺序）。（ <code class="codeph">FIRST</code>和<code class="codeph">NEXT</code>是收集方法，在<span class="q">“ <a href="plsql-collections-and-records.html#GUID-0452FBDC-D9C1-486E-B432-49AF84743A9F" title="集合方法是PL / SQL子程序 - 返回有关集合的信息的函数或对集合进行操作的过程。集合方法使集合更易于使用，并且您的应用程序更易于维护。">收集方法</a> ”中</span>描述。）
                     </p>
                     <div class="infoboxnote" id="GUID-8060F01F-B53B-48D4-9239-7EA8461C2170__GUID-0C29D90D-C33F-48C2-BB9D-F36CD3C16912">
                        <p class="notep1">实时SQL：</p>
                        <p>您可以在Oracle Live SQL上<a href="https://livesql.oracle.com/apex/livesql/docs/lnpls/plsql-collections-and-records/composites1.html" target="_blank">以字符串索引的关联数组</a>查看和运行此示例</p>
                     </div><pre class="oac_no_warn" dir="ltr">DECLARE  - 由字符串索引的关联数组：TYPE population IS TABLE OF NUMBER  - 关联数组类型INDEX BY VARCHAR2（64）; - 由字符串city_population人口索引; - 关联数组变量i VARCHAR2（64）; - 标量变量BEGIN  - 将元素（键值对）添加到关联数组：city_population（'Smallville'）：= 2000; city_population（'Midland'）：= 750000; city_population（'Megalopolis'）：= 1000000; - 更改与关键'Smallville'相关的值：city_population（'Smallville'）：= 2001; - 打印关联数组：i：= city_population。第一; - 获取数组的第一个元素WHILE I IS NOT NOT NULL LOOP DBMS_Output。PUT_LINE（''|| ||'的人口是'|| city_population（i））; i：= city_population。NEXT（ⅰ）; - 获取数组END LOOP的下一个元素;结束; /</pre><p>结果：</p><pre class="oac_no_warn" dir="ltr">特大城市的人口是100万米德兰的人口是75万。超人口的人口是2001年</pre></div>
                  <!-- class="example" -->
                  <div class="example" id="GUID-8060F01F-B53B-48D4-9239-7EA8461C2170__BEIEBJJI">
                     <p class="titleinexample">示例5-2函数返回由PLS_INTEGER索引的关联数组</p>
                     <p>此示例定义了一种由<code class="codeph">PLS_INTEGER</code>索引的关联数组类型以及一个返回该类型的关联数组的函数。
                     </p>
                     <div class="infoboxnote" id="GUID-8060F01F-B53B-48D4-9239-7EA8461C2170__GUID-C0815BC3-A861-4AC9-A667-DA0C20C3BA6C">
                        <p class="notep1">实时SQL：</p>
                        <p>您可以在<a href="https://livesql.oracle.com/apex/livesql/docs/lnpls/plsql-collections-and-records/composites16.html" target="_blank">函数返回关联数组的</a> Oracle Live SQL上查看和运行此示例，该<a href="https://livesql.oracle.com/apex/livesql/docs/lnpls/plsql-collections-and-records/composites16.html" target="_blank">关联数组由PLS_INTEGER索引</a></p>
                     </div><pre class="oac_no_warn" dir="ltr">DECLARE <span class="bold">TYPE sum_multiples是PLS_INTEGER的PLST_INTEGER索引表;</span> n PLS_INTEGER：= 5; - 显示sn的总和的倍数PLS_INTEGER：= 10; - 总和的倍数m PLS_INTEGER：= 3; - 多个<span class="bold">FUNCTION get_sum_multiples（</span>多个IN PLS_INTEGER，num IN PLS_INTEGER <span class="bold">）RETURN sum_multiples</span> IS s sum_multiples;开始为i IN 1..num LOOP s（i）：=倍*（（i *（i + 1））/ 2）; -  END LOOP的倍数之和;返回; END get_sum_multiples; BEGIN DBMS_OUTPUT.PUT_LINE（''||| TO_CHAR（m）||'的倍数'|'| TO_CHAR（m）||'的倍数是'|| TO_CHAR（get_sum_multiples（m，sn）（n）））;结束; /</pre><p>结果：</p><pre class="oac_no_warn" dir="ltr">3的前5个倍数之和为45</pre></div>
                  <!-- class="example" -->
               </div><a id="LNPLS358"></a><a id="LNPLS99857"></a><div class="props_rev_3"><a id="GUID-8A3DD42E-72A1-4807-8650-E92F5FD89763" name="GUID-8A3DD42E-72A1-4807-8650-E92F5FD89763"></a><h4 id="LNPLS-GUID-8A3DD42E-72A1-4807-8650-E92F5FD89763" class="sect4"><span class="enumeration_section">5.2.1</span>声明关联数组常量</h4>
                  <div>
                     <p>声明关联数组常量时，必须创建一个函数，用其初始值填充关联数组，然后在常量声明中调用该函数。</p>
                     <div class="section">
                        <p>有关构造函数的信息，请参阅<span class="q">“ <a href="plsql-collections-and-records.html#GUID-92967CC1-481E-472A-BB4C-90C60F75296D" title="集合构造函数（构造函数）是系统定义的函数，其名称与集合类型相同，后者返回该类型的集合。">集合构造函数</a> ”</span> 。
                        </p>
                     </div>
                     <!-- class="section" -->
                     <div class="example" id="GUID-8A3DD42E-72A1-4807-8650-E92F5FD89763__BABIBCCB">
                        <p class="titleinexample">例5-3声明关联数组常量</p>
                        <p>在此示例中，该函数对关联数组执行构造函数对varray或嵌套表的操作。</p>
                        <div class="infoboxnote" id="GUID-8A3DD42E-72A1-4807-8650-E92F5FD89763__GUID-2B3FA43D-9805-4E4E-8850-E796A810D4CE">
                           <p class="notep1">实时SQL：</p>
                           <p>您可以在<a href="https://livesql.oracle.com/apex/livesql/docs/lnpls/plsql-collections-and-records/composites89.html" target="_blank">声明关联数组常量的</a> Oracle Live SQL上查看和运行此示例</p>
                        </div><pre class="oac_no_warn" dir="ltr">创建或替换包My_Types AUTHID CURRENT_USER是类型My_AA是VARCHAR2的表（20）INDEX BY PLS_INTEGER;功能Init_My_AA返回My_AA;结束My_Types; /创建或替换包装物体My_Types是<span class="bold">功能Init_My_AA返回My_AA IS</span> <span class="bold">Ret My_AA;</span> <span class="bold">BEGIN</span> <span class="bold">Ret（-10）：=' - '';</span> <span class="bold">Ret（0）：='零';</span> <span class="bold">Ret（1）：='one';</span> <span class="bold">Ret（2）：='two';</span> <span class="bold">Ret（3）：='三';</span> <span class="bold">Ret（4）：='四';</span> <span class="bold">Ret（9）：='九';</span> <span class="bold">RETURN Ret;</span> <span class="bold">END Init_My_AA;</span>结束My_Types; / DECLARE <span class="bold">v CONSTANT My_Types。My_AA：= My_Types。Init_My_AA（）;</span> BEGIN DECLARE Idx PLS_INTEGER：= v.FIRST（）;在Idx IS NOT NULL LOOP DBMS_OUTPUT.PUT_LINE（TO_CHAR（Idx，'999'）|| LPAD（v（Idx），7））; Idx：= v.NEXT（Idx）;结束循环;结束;结束; /</pre><p>结果：</p><pre class="oac_no_warn" dir="ltr">-10 -ten 0 zero 1 one 2 two 3 3 4 4 9九PL / SQL程序顺利完成。</pre></div>
                     <!-- class="example" -->
                  </div>
               </div><a id="LNPLS359"></a><a id="LNPLS99931"></a><div class="props_rev_3"><a id="GUID-8453D24B-DBF3-4127-AD42-88D49F3DBC26" name="GUID-8453D24B-DBF3-4127-AD42-88D49F3DBC26"></a><h4 id="LNPLS-GUID-8453D24B-DBF3-4127-AD42-88D49F3DBC26" class="sect4"><span class="enumeration_section">5.2.2</span> NLS参数值影响由String索引的关联数组</h4>
                  <div>
                     <p>国家语言支持（NLS）参数（如<code class="codeph">NLS_SORT</code> ， <code class="codeph">NLS_COMP</code>和<code class="codeph">NLS_DATE_FORMAT</code>会影响由字符串索引的关联数组。
                     </p>
                     <div class="section">
                        <p class="subhead3" id="GUID-8453D24B-DBF3-4127-AD42-88D49F3DBC26__GUID-651D1D98-7173-4FA6-9FD3-FD5CF7884C20">话题</p>
                     </div>
                     <!-- class="section" -->
                     <div class="section">
                        <ul style="list-style-type:disc">
                           <li>
                              <p><a href="plsql-collections-and-records.html#GUID-7B7C16A9-7252-430B-83D6-71A2B7B56500" title="初始化参数NLS_SORT和NLS_COMP确定关联数组的字符串索引的存储顺序。">填充关联数组后更改NLS参数值</a></p>
                           </li>
                           <li>
                              <p><a href="plsql-collections-and-records.html#GUID-3D25039B-4ACD-492A-B913-1548FA2FE624" title="在由string索引的关联数组的声明中，字符串类型必须是VARCHAR2或其子类型之一。">除VARCHAR2之外的数据类型的索引</a></p>
                           </li>
                           <li>
                              <p><a href="plsql-collections-and-records.html#GUID-897FB965-310B-4C34-BDC5-A272E0618324">将关联数组传递给远程数据库</a></p>
                           </li>
                        </ul>
                        <div class="infoboxnotealso" id="GUID-8453D24B-DBF3-4127-AD42-88D49F3DBC26__GUID-F60389E0-55A8-4899-845E-EF26AAD91B07">
                           <p class="notep1">也可以看看：</p>
                           <p>有关语言排序参数的信息，请参见<a href="../nlspg/setting-up-globalization-support-environment.html#NLSPG229" target="_blank"><span class="italic">“Oracle数据库全球化支持指南”</span></a></p>
                        </div>
                     </div>
                     <!-- class="section" -->
                  </div><a id="LNPLS360"></a><div class="props_rev_3"><a id="GUID-7B7C16A9-7252-430B-83D6-71A2B7B56500" name="GUID-7B7C16A9-7252-430B-83D6-71A2B7B56500"></a><h5 id="LNPLS-GUID-7B7C16A9-7252-430B-83D6-71A2B7B56500" class="sect5"><span class="enumeration_section">5.2.2.1填充</span>关联数组后更改NLS参数值</h5>
                     <div>
                        <p>初始化参数<code class="codeph">NLS_SORT</code>和<code class="codeph">NLS_COMP</code>确定关联数组的字符串索引的存储顺序。
                        </p>
                        <div class="section">
                           <p>如果在填充由string索引的关联数组后更改任一参数的值，则收集方法<code class="codeph">FIRST</code> ， <code class="codeph">LAST</code> ， <code class="codeph">NEXT</code>和<code class="codeph">PRIOR</code>可能会返回意外值或引发异常。如果必须在会话期间更改这些参数值，请在操作由string索引的关联数组之前恢复其原始值。
                           </p>
                           <div class="infoboxnotealso" id="GUID-7B7C16A9-7252-430B-83D6-71A2B7B56500__GUID-64241E6E-7963-443D-AD8A-CF40081FD266">
                              <p class="notep1">也可以看看：</p>有关<code class="codeph">FIRST</code> ， <code class="codeph">LAST</code> ， <code class="codeph">NEXT</code>和<code class="codeph">PRIOR</code>更多信息的<a href="plsql-collections-and-records.html#GUID-0452FBDC-D9C1-486E-B432-49AF84743A9F" title="集合方法是PL / SQL子程序 - 返回有关集合的信息的函数或对集合进行操作的过程。集合方法使集合更易于使用，并且您的应用程序更易于维护。">收集方法</a></div>
                        </div>
                        <!-- class="section" -->
                     </div>
                  </div><a id="LNPLS361"></a><div class="props_rev_3"><a id="GUID-3D25039B-4ACD-492A-B913-1548FA2FE624" name="GUID-3D25039B-4ACD-492A-B913-1548FA2FE624"></a><h5 id="LNPLS-GUID-3D25039B-4ACD-492A-B913-1548FA2FE624" class="sect5"><span class="enumeration_section">5.2.2.2</span> VARCHAR2以外的数据类型的索引</h5>
                     <div>
                        <p>在由string索引的关联数组的声明中，字符串类型必须是<code class="codeph">VARCHAR2</code>或其子类型之一。
                        </p>
                        <p>但是，您可以使用<code class="codeph">TO_CHAR</code>函数可以转换为<code class="codeph">VARCHAR2</code>的任何数据类型的索引填充关联数组。
                        </p>
                        <p>如果索引具有<code class="codeph">VARCHAR2</code>及其子类型以外的数据类型，请确保在初始化参数的值发生更改时这些索引保持一致且唯一。例如：</p>
                        <ul style="list-style-type:disc">
                           <li>
                              <p>不要使用<code class="codeph">TO_CHAR(SYSDATE)</code>作为索引。
                              </p>
                              <p>如果<code class="codeph">NLS_DATE_FORMAT</code>的值发生更改，则<code class="codeph">(TO_CHAR(SYSDATE))</code>的值也可能会更改。
                              </p>
                           </li>
                           <li>
                              <p>不要使用可能转换为相同<code class="codeph">VARCHAR2</code>值的不同<code class="codeph">NVARCHAR2</code>索引。
                              </p>
                           </li>
                           <li>
                              <p>不要使用仅在大小写，重音字符或标点字符不同的<code class="codeph">CHAR</code>或<code class="codeph">VARCHAR2</code>索引。
                              </p>
                              <p>如果<code class="codeph">NLS_SORT</code>的值以<code class="codeph">_CI</code> （不区分大小写的比较）或<code class="codeph">_AI</code> （重音和不区分大小写的比较）结束，则仅在大小写，重音字符或标点符号字符不同的索引可能会转换为相同的值。
                              </p>
                           </li>
                        </ul>
                        <div class="infoboxnotealso" id="GUID-3D25039B-4ACD-492A-B913-1548FA2FE624__GUID-8CCB8EE5-678F-4CC3-A7DA-AD1B031124D5">
                           <p class="notep1">也可以看看：</p>有关<code class="codeph">TO_CHAR</code>更多信息，请<a href="../sqlrf/TO_CHAR-character.html#SQLRF06128" target="_blank"><span class="italic">参见Oracle数据库SQL语言参考</span></a></div>
                     </div>
                  </div><a id="LNPLS362"></a><div class="props_rev_3"><a id="GUID-897FB965-310B-4C34-BDC5-A272E0618324" name="GUID-897FB965-310B-4C34-BDC5-A272E0618324"></a><h5 id="LNPLS-GUID-897FB965-310B-4C34-BDC5-A272E0618324" class="sect5"><span class="enumeration_section">5.2.2.3将</span>关联数组传递给远程数据库</h5>
                     <div>
                        <div class="section">
                           <p>如果将关联数组作为参数传递给远程数据库，并且本地和远程数据库具有不同的<code class="codeph">NLS_SORT</code>或<code class="codeph">NLS_COMP</code>值，则：</p>
                        </div>
                        <!-- class="section" -->
                        <div class="section">
                           <ul style="list-style-type:disc">
                              <li>
                                 <p>收集方法<code class="codeph">FIRST</code> ， <code class="codeph">LAST</code> ， <code class="codeph">NEXT</code>或<code class="codeph">PRIOR</code> （在<span class="q">“ <a href="plsql-collections-and-records.html#GUID-0452FBDC-D9C1-486E-B432-49AF84743A9F" title="集合方法是PL / SQL子程序 - 返回有关集合的信息的函数或对集合进行操作的过程。集合方法使集合更易于使用，并且您的应用程序更易于维护。">收集方法</a> ”中</span>描述）可能会返回意外值或引发异常。
                                 </p>
                              </li>
                              <li>
                                 <p>本地数据库上唯一的索引在远程数据库上可能不是唯一的，从而引发预定义的异常<code class="codeph">VALUE_ERROR</code> 。</p>
                              </li>
                           </ul>
                        </div>
                        <!-- class="section" -->
                     </div>
                  </div>
               </div><a id="LNPLS99930"></a><div class="props_rev_3"><a id="GUID-157A4309-1BAF-419D-8B7F-3CB4AA9921DF" name="GUID-157A4309-1BAF-419D-8B7F-3CB4AA9921DF"></a><h4 id="LNPLS-GUID-157A4309-1BAF-419D-8B7F-3CB4AA9921DF" class="sect4"><span class="enumeration_section">5.2.3</span>关联数组的适当用途</h4>
                  <div>
                     <p>关联数组适用于：</p>
                     <ul style="list-style-type:disc">
                        <li>
                           <p>一个相对较小的查找表，每次调用子程序或初始化声明它的包时都可以在内存中构造</p>
                        </li>
                        <li>
                           <p>将集合传入和传出数据库服务器</p>
                           <p>声明关联数组类型的正式子程序参数。使用Oracle调用接口（OCI）或Oracle预编译器，将主机阵列绑定到相应的实际参数。PL / SQL自动在主机数组和由<code class="codeph">PLS_INTEGER</code>索引的关联数组之间进行转换。</p>
                           <div class="infoboxnote" id="GUID-157A4309-1BAF-419D-8B7F-3CB4AA9921DF__GUID-1E9C9625-EDDE-417E-8952-00976CE0D5F8">
                              <p class="notep1">注意：</p>
                              <p>您无法绑定由<code class="codeph">VARCHAR</code>索引的关联数组。</p>
                           </div>
                           <div class="infoboxnote" id="GUID-157A4309-1BAF-419D-8B7F-3CB4AA9921DF__GUID-7C2C33A5-9B95-4EB8-A50C-4131EE3F2F93">
                              <p class="notep1">注意：</p>
                              <p>您无法在架构级别声明关联数组类型。因此，要将关联数组变量作为参数传递给独立子程序，必须在包规范中声明该变量的类型。这样做使得类型可用于被调用的子程序（声明该类型的形式参数）和调用子程序或匿名块（声明并传递该类型的变量）。见<a href="plsql-packages.html#GUID-1E1FB4FA-CD97-443C-AE37-6D5C146E2B80__BABDFGED">例10-2</a> 。
                              </p>
                           </div>
                           <div class="infobox-tip" id="GUID-157A4309-1BAF-419D-8B7F-3CB4AA9921DF__GUID-7A878904-CEF4-47DD-BCC4-0EFE3C2C913A">
                              <p class="notep1">小费：</p>
                              <p>将集合传入和传出数据库服务器的最有效方法是使用带有<code class="codeph">FORALL</code>语句或<code class="codeph">BULK</code> <code class="codeph">COLLECT</code>子句的关联数组。有关详细信息，请参阅<span class="q">“ <a href="plsql-optimization-and-tuning.html#GUID-6D4A1425-64DD-4723-8AAE-87B0A51A2854" title="FORALL语句是批量SQL的一个特性，它将批处理中的DML语句从PL / SQL发送到SQL，而不是一次发送一个。">FORALL语句</a> ”</span>和<span class="q">“ <a href="plsql-optimization-and-tuning.html#GUID-19F50644-C88E-49AF-B31C-3EE4B4432714" title="BULK COLLECT子句是批量SQL的一个特性，它将结果从SQL返回到PL / SQL，而不是一次返回一个。">BULK COLLECT子句</a> ”</span> 。
                              </p>
                           </div>
                        </li>
                     </ul>
                     <p>关联数组用于临时数据存储。要使关联数组在数据库会话的生命周期内保持不变，请在包规范中声明它并将其填充到包体中。</p>
                  </div>
               </div>
            </div><a id="LNPLS363"></a><a id="LNPLS365"></a><a id="LNPLS364"></a><a id="LNPLS443"></a><div class="props_rev_3"><a id="GUID-E932FC04-C7AD-4562-9555-8BA05446C0B8" name="GUID-E932FC04-C7AD-4562-9555-8BA05446C0B8"></a><h3 id="LNPLS-GUID-E932FC04-C7AD-4562-9555-8BA05446C0B8" class="sect3"><span class="enumeration_section">5.3</span> Varrays（可变大小的阵列）</h3>
               <div>
                  <p><span class="bold">varray（可变大小数组）</span>是一个数组，其元素数可以从零（空）到声明的最大大小变化。
                  </p>
                  <p>要访问varray变量的元素，请使用语法<span class="italic"><code class="codeph">variable_name</code></span> <code class="codeph">(</code> <span class="italic"><code class="codeph">index</code></span> <code class="codeph">)</code> 。<span class="italic"><code class="codeph">index</code></span>的下限是1;上限是当前的元素数。添加或删除元素时，上限会发生更改，但不能超过最大大小。从数据库存储和检索varray时，其索引和元素顺序保持稳定。
                  </p>
                  <p><a href="plsql-collections-and-records.html#GUID-E932FC04-C7AD-4562-9555-8BA05446C0B8__CIHGHIBH">图5-1</a>显示了一个名为<code class="codeph">Grades</code>的varray变量，其最大大小为10，包含七个元素。<code class="codeph">Grades</code> （ <span class="italic"><code class="codeph">n</code></span> ）引用了第<span class="italic">n</span>个的元素<code class="codeph">Grades</code> 。<code class="codeph">Grades</code>的上限为7，不能超过10。
                  </p>
                  <div class="figure" id="GUID-E932FC04-C7AD-4562-9555-8BA05446C0B8__CIHGHIBH">
                     <p class="titleinfigure">图5-1具有7个元素的最大尺寸10的变量</p><img src="img/lnpls017.gif" alt="下面是图5-1的描述" title="下面是图5-1的描述" longdesc="img_text/lnpls017.html"><br><a href="img_text/lnpls017.html">“图5-1具有7个元素的最大尺寸10的变体”的描述</a></div>
                  <!-- class="figure" -->
                  <p>数据库将varray变量存储为单个对象。如果varray变量小于4 KB，它将驻留在作为列的表的内部;否则，它驻留在表外但在同一个表空间中。</p>
                  <p>未初始化的varray变量是null集合。您必须通过将其设置为空或通过为其指定非<code class="codeph">NULL</code>值来初始化它。有关详细信息，请参阅<span class="q">“ <a href="plsql-collections-and-records.html#GUID-92967CC1-481E-472A-BB4C-90C60F75296D" title="集合构造函数（构造函数）是系统定义的函数，其名称与集合类型相同，后者返回该类型的集合。">集合构造函数</a> ”</span>和<span class="q">“ <a href="plsql-collections-and-records.html#GUID-7836EEC3-2642-4CF8-AA50-81034855119D" title="仅当集合具有相同的数据类型时，才可以将集合分配给集合变量。具有相同的元素类型是不够的。对于varray或嵌套表变量，可以指定值NULL或相同数据类型的null集合。赋值使变量为null。对于嵌套表变量，可以分配SQL MULTISET操作或SQL SET函数调用的结果。">将值分配给集合变量</a> ”</span> 。
                  </p>
                  <div class="section">
                     <p class="subhead2" id="GUID-E932FC04-C7AD-4562-9555-8BA05446C0B8__GUID-067DA39B-B0BA-4C84-AF93-1934AE23036F">话题</p>
                  </div>
                  <!-- class="section" -->
                  <div class="section">
                     <ul style="list-style-type:disc">
                        <li>
                           <p><a href="plsql-collections-and-records.html#GUID-45577352-2701-472B-88FA-CF2AC8B09153">适用于Varrays的用途</a></p>
                        </li>
                     </ul>
                     <div class="infoboxnotealso" id="GUID-E932FC04-C7AD-4562-9555-8BA05446C0B8__GUID-3125AF89-4B88-408A-A64B-3EAE1EB7C406">
                        <p class="notep1">也可以看看：</p>
                        <ul style="list-style-type:disc">
                           <li>
                              <p><a href="plsql-collections-and-records.html#GUID-7E9034D5-0D33-43A1-9012-918350FE148C__CIHHDDGF" title="总结了三种PL / SQL集合的异同。">表5-1</a>了解varray特性的摘要</p>
                           </li>
                           <li>
                              <p><span class="q">“ <a href="collection-variable.html#GUID-89A1863C-65A1-40CF-9392-86E9FDC21BE9__CJAEAJJA">varray_type_def :: =</a> ”</span>表示<code class="codeph">VARRAY</code>类型定义的语法</p>
                           </li>
                           <li>
                              <p>有关创建独立<code class="codeph">VARRAY</code>类型的信息，请<code class="codeph">VARRAY</code> <span class="q">“ <a href="CREATE-TYPE-statement.html#GUID-389D603D-FBD0-452A-8414-240BBBC57034" title="CREATE TYPE语句指定类型的名称及其属性，方法和其他属性。">CREATE TYPE语句</a> ”</span></p>
                           </li>
                           <li>
                              <p>有关varrays的更多信息，请参见<a href="../sqlrf/Data-Types.html#SQLRF51007" target="_blank"><span class="italic">Oracle数据库SQL语言参考</span></a></p>
                           </li>
                        </ul>
                     </div>
                  </div>
                  <!-- class="section" -->
                  <div class="example" id="GUID-E932FC04-C7AD-4562-9555-8BA05446C0B8__CIHFJAAD">
                     <p class="titleinexample">例5-4 Varray（可变大小数组）</p>
                     <p>此示例定义本地<code class="codeph">VARRAY</code>类型，声明该类型的变量（使用构造函数初始化它），并定义打印varray的过程。该示例调用该过程三次：在初始化变量之后，在单独更改两个元素的值之后，并在使用构造函数之后更改所有元素的值。（有关打印可能为null或为空的varray的过程<a href="plsql-collections-and-records.html#GUID-482AC3AD-F1E4-41D7-BCE3-494820E68089__CIHHAEGC">示例</a> ，请参阅<a href="plsql-collections-and-records.html#GUID-482AC3AD-F1E4-41D7-BCE3-494820E68089__CIHHAEGC">示例5-26</a> 。）
                     </p>
                     <div class="infoboxnote" id="GUID-E932FC04-C7AD-4562-9555-8BA05446C0B8__GUID-C7D9FA81-C8E7-4071-A007-0DEAD0186D27">
                        <p class="notep1">实时SQL：</p>
                        <p>您可以在<a href="https://livesql.oracle.com/apex/livesql/docs/lnpls/plsql-collections-and-records/composites57.html" target="_blank">Varray（可变大小数组）的</a> Oracle Live SQL上查看和运行此示例</p>
                     </div><pre class="oac_no_warn" dir="ltr">DECLARE TYPE四种IS VARRAY（4）OF VARCHAR2（15）; -  VARRAY类型 - 使用构造函数初始化的varray变量：team Foursome：= Foursome（'John'，'Mary'，'Alberto'，'Juanita'）;程序print_team（标题VARCHAR2）是BEGIN DBMS_OUTPUT.PUT_LINE（标题）; FOR i IN 1..4 LOOP DBMS_OUTPUT.PUT_LINE（i ||'。'|| team（i））;结束循环; DBMS_OUTPUT.PUT_LINE（ '---'）;结束;打印print_team（'2001团队：'）; team（3）：='Pierre'; - 更改两个元素团队的值（4）：='Yvonne'; print_team（'2005 Team：'）; - 调用构造函数为varray变量赋值：team：= Foursome（'Arun'，'Amitha'，'Allan'，'Mae'）; print_team（'2009 Team：'）;结束; /</pre><p>结果：</p><pre class="oac_no_warn" dir="ltr">2001年队：1。约翰2。玛丽3。阿尔贝托4。Juanita --- 2005队伍：1。约翰2。玛丽3。皮埃尔4。Yvonne --- 2009队：1。阿伦2。阿米塔3。艾伦4。Mae ---</pre></div>
                  <!-- class="example" -->
               </div><a id="LNPLS99929"></a><div class="props_rev_3"><a id="GUID-45577352-2701-472B-88FA-CF2AC8B09153" name="GUID-45577352-2701-472B-88FA-CF2AC8B09153"></a><h4 id="LNPLS-GUID-45577352-2701-472B-88FA-CF2AC8B09153" class="sect4"><span class="enumeration_section">5.3.1</span>变量的适当用途</h4>
                  <div>
                     <p>在以下情况下，varray是合适的：</p>
                     <ul style="list-style-type:disc">
                        <li>
                           <p>您知道元素的最大数量。</p>
                        </li>
                        <li>
                           <p>您通常按顺序访问元素。</p>
                        </li>
                     </ul>
                     <p>因为您必须同时存储或检索所有元素，所以对于大量元素，varray可能是不切实际的。</p>
                  </div>
               </div>
            </div><a id="LNPLS368"></a><a id="LNPLS366"></a><a id="LNPLS367"></a><a id="LNPLS99981"></a><div class="props_rev_3"><a id="GUID-5ADB7EE2-71F6-4172-ACD8-FFDCF2787A37" name="GUID-5ADB7EE2-71F6-4172-ACD8-FFDCF2787A37"></a><h3 id="LNPLS-GUID-5ADB7EE2-71F6-4172-ACD8-FFDCF2787A37" class="sect3"><span class="enumeration_section">5.4</span>嵌套表</h3>
               <div>
                  <p>在数据库中， <span class="bold">嵌套表</span>是一种列类型，它以无特定顺序存储未指定数量的行。
                  </p>
                  <p>从数据库中检索嵌套表值到PL / SQL嵌套表变量时，PL / SQL为行提供连续索引，从1开始。使用这些索引，您可以访问嵌套表变量的各个行。语法是<span class="italic"><code class="codeph">variable_name</code></span> <code class="codeph">(</code> <span class="italic"><code class="codeph">index</code></span> <code class="codeph">)</code> 。当您从数据库中存储和检索嵌套表时，嵌套表的索引和行顺序可能不会保持稳定。
                  </p>
                  <p>当您添加或删除元素时，嵌套表变量占用的内存量可以动态增加或减少。</p>
                  <p>未初始化的嵌套表变量是空集合。您必须通过将其设置为空或通过为其指定非<code class="codeph">NULL</code>值来初始化它。有关详细信息，请参阅<span class="q">“ <a href="plsql-collections-and-records.html#GUID-92967CC1-481E-472A-BB4C-90C60F75296D" title="集合构造函数（构造函数）是系统定义的函数，其名称与集合类型相同，后者返回该类型的集合。">集合构造函数</a> ”</span>和<span class="q">“ <a href="plsql-collections-and-records.html#GUID-7836EEC3-2642-4CF8-AA50-81034855119D" title="仅当集合具有相同的数据类型时，才可以将集合分配给集合变量。具有相同的元素类型是不够的。对于varray或嵌套表变量，可以指定值NULL或相同数据类型的null集合。赋值使变量为null。对于嵌套表变量，可以分配SQL MULTISET操作或SQL SET函数调用的结果。">将值分配给集合变量</a> ”</span> 。
                  </p>
                  <div class="infoboxnote" id="GUID-5ADB7EE2-71F6-4172-ACD8-FFDCF2787A37__GUID-ACFCAB54-5BD4-45FC-A1CA-9D09EA721CEC">
                     <p class="notep1">注意：</p>
                     <p><a href="plsql-collections-and-records.html#GUID-E43509F6-5044-4B17-9516-2EB4BDDD5173__CIHJFHJE">例5-19</a> ， <a href="plsql-collections-and-records.html#GUID-6AF582B1-9C50-4858-AE6C-B14DD051ACD1__BABHDBGC">例5-21</a>和<a href="plsql-collections-and-records.html#GUID-03F74821-BC33-4544-9304-5FBBE6EFE450__BABBGAIB">例5-22</a>重用<code class="codeph">nt_type</code>和<code class="codeph">print_nt</code> 。
                     </p>
                  </div>
                  <div class="section">
                     <p class="subhead2" id="GUID-5ADB7EE2-71F6-4172-ACD8-FFDCF2787A37__GUID-A9B1623A-8C9B-47F6-BB6B-B0012AC42E80">话题</p>
                  </div>
                  <!-- class="section" -->
                  <div class="section">
                     <ul style="list-style-type:disc">
                        <li>
                           <p><a href="plsql-collections-and-records.html#GUID-B8683EF9-B9E5-4DE4-92F3-42C4000B0EF9">嵌套表和数组之间的重要区别</a></p>
                        </li>
                        <li>
                           <p><a href="plsql-collections-and-records.html#GUID-70EC41EA-4ED2-42FE-A03D-6CED02C3A393">适用于嵌套表的用法</a></p>
                        </li>
                     </ul>
                     <div class="infoboxnotealso" id="GUID-5ADB7EE2-71F6-4172-ACD8-FFDCF2787A37__GUID-088AABC4-65DC-4124-B7AA-0ACF3737F3A2">
                        <p class="notep1">也可以看看：</p>
                        <ul style="list-style-type:disc">
                           <li>
                              <p><a href="plsql-collections-and-records.html#GUID-7E9034D5-0D33-43A1-9012-918350FE148C__CIHHDDGF" title="总结了三种PL / SQL集合的异同。">表5-1</a>了解嵌套表特性的摘要</p>
                           </li>
                           <li>
                              <p><span class="q">“ <a href="collection-variable.html#GUID-89A1863C-65A1-40CF-9392-86E9FDC21BE9__CJAFJBHF">nested_table_type_def :: =</a> ”</span>表示嵌套表类型定义的语法</p>
                           </li>
                           <li>
                              <p><span class="q">“ <a href="CREATE-TYPE-statement.html#GUID-389D603D-FBD0-452A-8414-240BBBC57034" title="CREATE TYPE语句指定类型的名称及其属性，方法和其他属性。">CREATE TYPE语句</a> ”，</span>以获取有关创建独立嵌套表类型的信息</p>
                           </li>
                           <li>
                              <p><span class="q">“ <a href="plsql-triggers.html#GUID-9F06D45C-7C60-434E-A597-114A0C445671" title="An INSTEAD OF DML trigger is a DML trigger created on a noneditioning view, or on a nested table column of a noneditioning view. The database fires the INSTEAD OF trigger instead of running the triggering DML statement.">INSTEAD OF DML Triggers</a> ”，</span>以获取有关更新嵌套表视图列的<span class="q"><a href="plsql-triggers.html#GUID-9F06D45C-7C60-434E-A597-114A0C445671" title="INSTEAD OF DML触发器是在非编辑视图或非编辑视图的嵌套表列上创建的DML触发器。数据库触发INSTEAD OF触发器而不是运行触发DML语句。">触发器</a></span>的信息</p>
                           </li>
                           <li>
                              <p>有关嵌套表的更多信息，请<a href="../sqlrf/Data-Types.html#SQLRF51008" target="_blank"><span class="italic">参见Oracle数据库SQL语言参考</span></a></p>
                           </li>
                        </ul>
                     </div>
                  </div>
                  <!-- class="section" -->
                  <div class="example" id="GUID-5ADB7EE2-71F6-4172-ACD8-FFDCF2787A37__CIHCICAE">
                     <p class="titleinexample">示例5-5本地类型的嵌套表</p>
                     <p>此示例定义本地嵌套表类型，声明该类型的变量（使用构造函数初始化它），并定义打印嵌套表的过程。（该过程使用<code class="codeph">FIRST</code>和<code class="codeph">LAST</code>的收集方法，在<span class="q">“ <a href="plsql-collections-and-records.html#GUID-0452FBDC-D9C1-486E-B432-49AF84743A9F" title="集合方法是PL / SQL子程序 - 返回有关集合的信息的函数或对集合进行操作的过程。集合方法使集合更易于使用，并且您的应用程序更易于维护。">收集方法</a> ”中</span>描述。）该示例调用该过程三次：在初始化变量之后，在更改一个元素的值之后，以及在使用构造函数之后更改所有元素的值。在第二个构造函数调用之后，嵌套表只有两个元素。引用元素3会引发错误ORA-06533。
                     </p>
                     <div class="infoboxnote" id="GUID-5ADB7EE2-71F6-4172-ACD8-FFDCF2787A37__GUID-4BED2D46-827C-4279-9627-A1D7C710097B">
                        <p class="notep1">实时SQL：</p>
                        <p>您可以在<a href="https://livesql.oracle.com/apex/livesql/docs/lnpls/plsql-collections-and-records/composites56.html" target="_blank">嵌套的本地类型表</a>上的Oracle Live SQL上查看和运行此示例</p>
                     </div><pre class="oac_no_warn" dir="ltr">DECLARE TYPE Roster是VARCHAR2的表（15）; - 嵌套表类型 - 用构造函数初始化的嵌套表变量：names Roster：= Roster（'D Caruso'，'J Hamil'，'D Piro'，'R Singh'）; PROCEDURE print_names（标题VARCHAR2）是BEGIN DBMS_OUTPUT.PUT_LINE（标题）;我的名字。第一..名字。最后的循环 - 用于从头到尾的元素DBMS_OUTPUT.PUT_LINE（names（i））;结束循环; DBMS_OUTPUT.PUT_LINE（ '---'）;结束; BEGIN print_names（'初始值：'）;名字（3）：='P Perez'; - 更改一个元素print_names的值（'当前值：'）;名字：=名册（'A Jansen'，'B Gupta'）; - 更改整个表print_names（'当前值：'）;结束; /</pre><p>结果：</p><pre class="oac_no_warn" dir="ltr">初始值：D Caruso J Hamil D Piro R Singh ---当前价值观：D Caruso J Hamil P Perez R Singh ---当前价值观：A Jansen B Gupta</pre></div>
                  <!-- class="example" -->
                  <div class="example" id="GUID-5ADB7EE2-71F6-4172-ACD8-FFDCF2787A37__CIHDEIIG">
                     <p class="titleinexample">示例5-6独立类型的嵌套表</p>
                     <p>此示例定义了一个独立的嵌套表类型， <code class="codeph">nt_type</code>和一个独立的过程来打印该类型的变量<code class="codeph">print_nt</code> 。匿名块声明一个类型为<code class="codeph">nt_type</code>的变量，使用构造函数将其初始化为空，并调用<code class="codeph">print_nt</code>两次：初始化变量后使用构造函数更改所有元素的值。
                     </p>
                     <div class="infoboxnote" id="GUID-5ADB7EE2-71F6-4172-ACD8-FFDCF2787A37__GUID-412F7CC0-0E25-4222-AA95-D67063B8BE2F">
                        <p class="notep1">实时SQL：</p>
                        <p>您可以在<a href="https://livesql.oracle.com/apex/livesql/docs/lnpls/plsql-collections-and-records/composites86.html" target="_blank">独立类型的嵌套表</a>上的Oracle Live SQL上查看和运行此示例</p>
                     </div><pre class="oac_no_warn" dir="ltr">创建或替换类型nt_type是数字表; / CREATE OR REPLACE PROCEDURE print_nt（nt nt_type）AUTHID DEFINER是我的号码;开始我：= nt。第一;如果我是空的那么DBMS_OUTPUT.PUT_LINE（'nt为空'）; ELSE WHILE I NOT NOT NULL LOOP DBMS_OUTPUT.PUT（'nt。（'|| i ||'）='）; DBMS_OUTPUT.PUT_LINE（NVL（TO_CHAR（nt（i）），'NULL'））;我：= nt。NEXT（ⅰ）;结束循环;万一; DBMS_OUTPUT.PUT_LINE（ '---'）; END print_nt; / DECLARE nt nt_type：= nt_type（）; - 嵌套表变量初始化为空BEGIN print_nt（nt）; nt：= nt_type（90,9,29,58）; print_nt（NT）;结束; /</pre><p>结果：</p><pre class="oac_no_warn" dir="ltr">nt是空的 -  nt。（1）= 90 nt。（2）= 9 nt。（3）= 29 nt。（4）= 58 ---</pre></div>
                  <!-- class="example" -->
               </div><a id="LNPLS369"></a><a id="LNPLS99928"></a><div class="props_rev_3"><a id="GUID-B8683EF9-B9E5-4DE4-92F3-42C4000B0EF9" name="GUID-B8683EF9-B9E5-4DE4-92F3-42C4000B0EF9"></a><h4 id="LNPLS-GUID-B8683EF9-B9E5-4DE4-92F3-42C4000B0EF9" class="sect4"><span class="enumeration_section">5.4.1</span>嵌套表和数组之间的重要区别</h4>
                  <div>
                     <p>从概念上讲，嵌套表就像具有任意数量元素的一维数组。但是，嵌套表在这些重要方面与数组不同：</p>
                     <ul style="list-style-type:disc">
                        <li>
                           <p>数组具有声明的元素数，但嵌套表不具有。嵌套表的大小可以动态增加。</p>
                        </li>
                        <li>
                           <p>数组总是密集的。嵌套数组最初是密集的，但它可能变得稀疏，因为您可以从中删除元素。</p>
                        </li>
                     </ul>
                     <p><a href="plsql-collections-and-records.html#GUID-B8683EF9-B9E5-4DE4-92F3-42C4000B0EF9__CIHBBFBJ">图5-2</a>显示了嵌套表和数组之间的重要区别。
                     </p>
                     <div class="figure" id="GUID-B8683EF9-B9E5-4DE4-92F3-42C4000B0EF9__CIHBBFBJ">
                        <p class="titleinfigure">图5-2阵列和嵌套表</p><img src="img/lnpls016.gif" alt="下面是图5-2的描述" title="下面是图5-2的描述" longdesc="img_text/lnpls016.html"><br><a href="img_text/lnpls016.html">“图5-2阵列和嵌套表”的描述</a></div>
                     <!-- class="figure" -->
                  </div>
               </div><a id="LNPLS99927"></a><div class="props_rev_3"><a id="GUID-70EC41EA-4ED2-42FE-A03D-6CED02C3A393" name="GUID-70EC41EA-4ED2-42FE-A03D-6CED02C3A393"></a><h4 id="LNPLS-GUID-70EC41EA-4ED2-42FE-A03D-6CED02C3A393" class="sect4"><span class="enumeration_section">5.4.2</span>嵌套表的适当用法</h4>
                  <div>
                     <p>在以下情况下，嵌套表是合适的：</p>
                     <ul style="list-style-type:disc">
                        <li>
                           <p>未设置元素数。</p>
                        </li>
                        <li>
                           <p>索引值不是连续的。</p>
                        </li>
                        <li>
                           <p>您必须同时删除或更新某些元素，但不能删除所有元素。</p>
                           <p>嵌套表数据存储在单独的存储表中，即系统生成的数据库表。访问嵌套表时，数据库将嵌套表与其存储表连接。这使得嵌套表适用于仅影响集合的某些元素的查询和更新。</p>
                        </li>
                        <li>
                           <p>您将创建一个单独的查找表，主表的每一行都有多个条目，并通过连接查询访问它。</p>
                        </li>
                     </ul>
                  </div>
               </div>
            </div><a id="LNPLS370"></a><a id="LNPLS00504"></a><div class="props_rev_3"><a id="GUID-92967CC1-481E-472A-BB4C-90C60F75296D" name="GUID-92967CC1-481E-472A-BB4C-90C60F75296D"></a><h3 id="LNPLS-GUID-92967CC1-481E-472A-BB4C-90C60F75296D" class="sect3"><span class="enumeration_section">5.5</span>收集构造函数</h3>
               <div>
                  <p><span class="bold">集合构造函数（构造函数）</span>是系统定义的函数，其名称与集合类型相同，后者返回该类型的集合。
                  </p>
                  <div class="infoboxnote" id="GUID-92967CC1-481E-472A-BB4C-90C60F75296D__GUID-410640AA-4FCD-4CC4-AD84-19709A900724">
                     <p class="notep1">注意：</p>
                     <p>本主题仅适用于varrays和嵌套表。在本主题中， <span class="italic">集合</span>表示<span class="italic">varray或嵌套表</span> 。关联数组使用限定表达式和聚合（请参阅<a href="plsql-collections-and-records.html#GUID-4B379569-4068-4DB1-9D69-E706F4AC5758" title="通过提供以需要值的紧凑形式声明和定义复杂值的能力，合格的表达式可提高程序清晰度和开发人员的工作效率。">限定表达式概述</a> ）。
                     </p>
                  </div>
                  <p>构造函数调用的语法是：</p><pre class="oac_no_warn" dir="ltr"><span class="italic">collection_type</span> （[ <span class="italic">value</span> [， <span class="italic">value</span> ] ...]）</pre><p>如果参数列表为空，则构造函数返回空集合。否则，构造函数返回包含指定值的集合。有关语义的详细信息，请参阅<span class="q">“ <a href="expression.html#GUID-D4700B45-F2C8-443E-AEE7-2BD20FFD45B8__CHDGAFDC">collection_constructor</a> ”</span> 。
                  </p>
                  <p>您可以将返回的集合分配给变量声明和块的可执行部分中的集合变量（相同类型）。</p>
                  <div class="example" id="GUID-92967CC1-481E-472A-BB4C-90C60F75296D__CIHCBBJJ">
                     <p class="titleinexample">示例5-7将Collection（Varray）变量初始化为Empty</p>
                     <p>此示例调用构造函数两次：将varray变量<code class="codeph">team</code>初始化为其声明中的空，并在块的可执行部分中为其赋予新值。<code class="codeph">print_team</code>过程显示<code class="codeph">team</code>的初始值和最终值。要确定<code class="codeph">team</code>何时为空， <code class="codeph">print_team</code>使用<span class="q">“ <a href="plsql-collections-and-records.html#GUID-0452FBDC-D9C1-486E-B432-49AF84743A9F" title="集合方法是PL / SQL子程序 - 返回有关集合的信息的函数或对集合进行操作的过程。集合方法使集合更易于使用，并且您的应用程序更易于维护。">收集方法</a> ”中</span>描述的收集方法<code class="codeph">COUNT</code> 。（有关打印可能为null的varray的过程<a href="plsql-collections-and-records.html#GUID-482AC3AD-F1E4-41D7-BCE3-494820E68089__CIHHAEGC">示例</a> ，请参阅<a href="plsql-collections-and-records.html#GUID-482AC3AD-F1E4-41D7-BCE3-494820E68089__CIHHAEGC">示例5-26</a> 。）
                     </p>
                     <div class="infoboxnote" id="GUID-92967CC1-481E-472A-BB4C-90C60F75296D__GUID-D21F87EC-07AF-4B95-8234-80C89992617E">
                        <p class="notep1">实时SQL：</p>
                        <p>您可以在<a href="https://livesql.oracle.com/apex/livesql/docs/lnpls/plsql-collections-and-records/composites58.html" target="_blank">初始化集合（Varray）变量为空时</a>在Oracle Live SQL上查看和运行此示例</p>
                     </div><pre class="oac_no_warn" dir="ltr">DECLARE TYPE四种IS VARRAY（4）OF VARCHAR2（15）; <span class="bold">团队四人：=四人（）; - 初始化为空</span> PROCEDURE print_team（标题VARCHAR2）IS BEGIN DBMS_OUTPUT.PUT_LINE（标题）; IF团队。COUNT = 0那么DBMS_OUTPUT.PUT_LINE（'空'）; ELSE for i IN 1..4 LOOP DBMS_OUTPUT.PUT_LINE（i ||'。'|| team（i））;结束循环;万一; DBMS_OUTPUT.PUT_LINE（ '---'）;结束;打印print_team（'团队：'）; <span class="bold">团队：=四人（'John'，'Mary'，'Alberto'，'Juanita'）;</span> print_team（ '小组：'）;结束; /</pre><p>结果：</p><pre class="oac_no_warn" dir="ltr">球队：空洞---球队：1。约翰2。玛丽3。阿尔贝托4。胡安妮塔---</pre></div>
                  <!-- class="example" -->
               </div>
            </div>
            <div class="sect2"><a id="GUID-4B379569-4068-4DB1-9D69-E706F4AC5758" name="GUID-4B379569-4068-4DB1-9D69-E706F4AC5758"></a><h3 id="LNPLS-GUID-4B379569-4068-4DB1-9D69-E706F4AC5758" class="sect3"><span class="enumeration_section">5.6</span>合格的表达概述</h3>
               <div>
                  <p>通过提供以需要值的紧凑形式声明和定义复杂值的能力，合格的表达式可提高程序清晰度和开发人员的工作效率。</p>
                  <p>限定表达式组合表达式元素以创建<code class="codeph">RECORD</code>类型或关联数组类型的值。
                  </p>
                  <p>限定表达式使用显式类型指示来提供限定项的类型。这种明确的指示称为类型<code class="codeph">typemark</code> 。
                  </p>
                  <p>限定表达式的语法是：</p>
                  <p>qualified_expression :: = typemark（aggregate）</p>
                  <p>aggregate :: = [positional_choice_list] [explicit_choice_list]</p>
                  <p>positional_choice_list :: =（expr）+</p>
                  <p>explicit_choice_list :: = named_choice_list | indexed_choice_list</p>
                  <p>named_choice_list :: = identifier =&gt; expr [，] +</p>
                  <p>indexed_choice_list :: = expr =&gt; expr [，] +</p>
                  <p>有关语法和语义的更多信息，请参阅<a href="expression.html#GUID-D4700B45-F2C8-443E-AEE7-2BD20FFD45B8__QUALIFIED_EXPRESSION-DEA96F0B">qualified_expression :: =</a> 。
                  </p>
                  <div class="example" id="GUID-4B379569-4068-4DB1-9D69-E706F4AC5758__GUID-58479C46-5F2B-4E22-B019-264CAB176060">
                     <p class="titleinexample">示例5-8使用限定表达式将值分配给RECORD类型变量</p>
                     <p>此示例显示RECORD类型变量的声明，初始化和定义。类型rec_t在包pkg中定义并部分初始化。变量v_rec1使用该类型声明，并使用位置表示法分配初始值。变量v_rec2也使用该类型声明，并使用指定的关联语法分配初始值。为变量v_rec3分配NULL值。过程print_rec显示局部变量v_rec1的值，后跟过程参数pi_rec变量值。如果没有参数传递给过程，它将显示过程定义中设置的初始值。</p>
                     <div class="infoboxnote" id="GUID-4B379569-4068-4DB1-9D69-E706F4AC5758__GUID-1778B36C-92F1-4CD3-A222-1BDB18A14B7B">
                        <p class="notep1">实时SQL：</p>
                        <p>您可以在<a href="https://livesql.oracle.com/apex/livesql/docs/lnpls/plsql-collections-and-records/rec-agg.html" target="_blank">18c</a>上在Oracle Live SQL上查看和运行此示例， <a href="https://livesql.oracle.com/apex/livesql/docs/lnpls/plsql-collections-and-records/rec-agg.html" target="_blank">使用限定表达式将值分配给RECORD类型变量</a></p>
                     </div><pre class="pre codeblock"><code>CREATE PACKAGE pkg IS TYPE rec_t IS RECORD（年份PLS_INTEGER：= 2，名称为VARCHAR2（100））;结束;</code></pre><pre class="pre codeblock"><code>DECLARE v_rec1 pkg.rec_t：= pkg.rec_t（1847，'ONE MAIGHT STOUR SEVEN'）; v_rec2 pkg.rec_t：= pkg.rec_t（year =&gt; 1，name =&gt;'ONE'）; v_rec3 pkg.rec_t：= pkg.rec_t（NULL，NULL）; PROCEDURE print_rec（pi_rec pkg.rec_t：= pkg.rec_t（1847 + 1，'a'||'b'））IS v_rec1 pkg.rec_t：= pkg.rec_t（2847，'TWO EIGHT FOUR SEVEN'）; BEGIN DBMS_OUTPUT.PUT_LINE（NVL（v_rec1.year，0）||''|| NVL（v_rec1.name，'N / A'））; DBMS_OUTPUT.PUT_LINE（NVL（pi_rec.year，0）||''|| NVL（pi_rec.name，'N / A'））;结束; BEGIN print_rec（v_rec1）; print_rec（v_rec2）; print_rec（v_rec3）; print_rec（）;结束;</code></pre><pre class="oac_no_warn" dir="ltr">2847两个八个七个1847一个八个七个2847两个八个七个1个2847两个八个七个0 N / A 2847两个八个七个1848个ab</pre></div>
                  <!-- class="example" -->
                  <div class="example" id="GUID-4B379569-4068-4DB1-9D69-E706F4AC5758__GUID-F10234B0-5F8D-4698-9506-DBEDAAF53F4D">
                     <p class="titleinexample">示例5-9使用限定表达式将值分配给关联数组类型变量</p>
                     <p>此示例使用函数显示<code class="codeph">BOOLEAN</code>表的值。</p>
                     <div class="infoboxnote" id="GUID-4B379569-4068-4DB1-9D69-E706F4AC5758__GUID-F9B12424-EC25-4208-829E-63CC4F09A2E4">
                        <p class="notep1">实时SQL：</p>
                        <p>您可以在<a href="https://livesql.oracle.com/apex/livesql/docs/lnpls/plsql-collections-and-records/aa-agg.html" target="_blank">18c</a>上在Oracle Live SQL上查看和运行此示例， <a href="https://livesql.oracle.com/apex/livesql/docs/lnpls/plsql-collections-and-records/aa-agg.html" target="_blank">使用限定表达式将值分配给RECORD类型变量</a></p>
                     </div><pre class="pre codeblock"><code>CREATE FUNCTION print_bool（v IN BOOLEAN）RETURN VARCHAR2 IS v_rtn VARCHAR2（10）; BEGIN CASE v WHEN TRUE，然后v_rtn：='TRUE';如果错了那么v_rtn：='FALSE'; ELSE v_rtn：='NULL';结束案例;返回v_rtn; END print_bool;</code></pre><p>使用索引键 - 值对初始化变量v_aa1。</p><pre class="pre codeblock"><code>DECLARE TYPE t_aa是PLS_INTEGER的BOOLEAN索引表; v_aa1 t_aa：= t_aa（1 =&gt; FALSE，2 =&gt; TRUE，3 =&gt; NULL）; BEGIN DBMS_OUTPUT.PUT_LINE（print_bool（v_aa1（1）））; DBMS_OUTPUT.PUT_LINE（print_bool（v_aa1（2）））; DBMS_OUTPUT.PUT_LINE（print_bool（v_aa1（3）））;结束;</code></pre><pre class="oac_no_warn" dir="ltr">FALSE TRUE NULL</pre></div>
                  <!-- class="example" -->
               </div>
            </div><a id="LNPLS371"></a><a id="LNPLS00505"></a><div class="props_rev_3"><a id="GUID-7836EEC3-2642-4CF8-AA50-81034855119D" name="GUID-7836EEC3-2642-4CF8-AA50-81034855119D"></a><h3 id="LNPLS-GUID-7836EEC3-2642-4CF8-AA50-81034855119D" class="sect3"><span class="enumeration_section">5.7</span>为集合变量赋值</h3>
               <div>
                  <div class="section">
                     <p>您可以通过以下方式为集合变量赋值：</p>
                  </div>
                  <!-- class="section" -->
                  <div class="section">
                     <ul style="list-style-type:disc">
                        <li>
                           <p>调用构造函数以创建集合并将其分配给集合变量。</p>
                        </li>
                        <li>
                           <p>使用赋值语句为其分配另一个现有集合变量的值。</p>
                        </li>
                        <li>
                           <p>将其作为<code class="codeph">OUT</code>或<code class="codeph">IN</code> <code class="codeph">OUT</code>参数传递给子程序，然后在子程序中指定值。
                           </p>
                        </li>
                        <li>
                           <p>使用限定表达式将值分配给关联数组（请参阅<a href="plsql-collections-and-records.html#GUID-4B379569-4068-4DB1-9D69-E706F4AC5758__GUID-F10234B0-5F8D-4698-9506-DBEDAAF53F4D">示例5-9</a> ）。
                           </p>
                        </li>
                     </ul>
                     <p>要为集合变量的标量元素赋值，请将该元素引用为<span class="italic"><code class="codeph">collection_variable_name</code></span> <code class="codeph">(</code> <span class="italic"><code class="codeph">index</code></span> <code class="codeph">)</code>并为其赋值。
                     </p>
                  </div>
                  <!-- class="section" -->
                  <div class="section">
                     <p class="subhead2" id="GUID-7836EEC3-2642-4CF8-AA50-81034855119D__GUID-1E0C787B-9E70-4A2A-80DA-3AF7D4ED8B29">话题</p>
                  </div>
                  <!-- class="section" -->
                  <div class="section">
                     <ul style="list-style-type:disc">
                        <li>
                           <p><a href="plsql-collections-and-records.html#GUID-030BFD2C-BCB4-481D-961A-1DCF310814D0" title="仅当集合具有相同的数据类型时，才可以将集合分配给集合变量。具有相同的元素类型是不够的。">数据类型兼容性</a></p>
                        </li>
                        <li>
                           <p><a href="plsql-collections-and-records.html#GUID-C2176FE3-EA3F-439B-9924-E4793B5DBB6D" title="对于varray或嵌套表变量，可以指定值NULL或相同数据类型的null集合。赋值使变量为null。">将空值分配给Varray或嵌套表变量</a></p>
                        </li>
                        <li>
                           <p><a href="plsql-collections-and-records.html#GUID-E939651F-5E2B-4A83-9035-4FA5498B78AA" title="对于嵌套表变量，可以分配SQL MULTISET操作或SQL SET函数调用的结果。">将设置操作结果分配给嵌套表变量</a></p>
                        </li>
                     </ul>
                     <div class="infoboxnotealso" id="GUID-7836EEC3-2642-4CF8-AA50-81034855119D__GUID-15BBFAEB-BBCC-4581-9A80-ED2CA38DE31F">
                        <p class="notep1">也可以看看：</p>
                        <ul style="list-style-type:disc">
                           <li>
                              <p><span class="q">“ <a href="plsql-collections-and-records.html#GUID-92967CC1-481E-472A-BB4C-90C60F75296D" title="集合构造函数（构造函数）是系统定义的函数，其名称与集合类型相同，后者返回该类型的集合。">收藏建筑师</a> ”</span></p>
                           </li>
                           <li>
                              <p><span class="q">“ <a href="assignment-statement.html#GUID-4C3BEFDF-3FFA-4E9D-96D0-4C5E13E08643" title="赋值语句将数据项的值设置为有效值。">Assignment Statement</a> ”</span>语法图</p>
                           </li>
                           <li>
                              <p><span class="q">“ <a href="plsql-language-fundamentals.html#GUID-356CB656-68ED-4869-8C67-FE93A78AEC9A">将值分配给变量</a> ”</span>以获取有关如何将值分配给集合变量的标量元素的说明</p>
                           </li>
                           <li>
                              <p><span class="q">“ <a href="plsql-optimization-and-tuning.html#GUID-19F50644-C88E-49AF-B31C-3EE4B4432714" title="BULK COLLECT子句是批量SQL的一个特性，它将结果从SQL返回到PL / SQL，而不是一次返回一个。">BULK COLLECT Clause</a> ”</span></p>
                           </li>
                        </ul>
                     </div>
                  </div>
                  <!-- class="section" -->
               </div><a id="LNPLS462"></a><a id="LNPLS99918"></a><div class="props_rev_3"><a id="GUID-030BFD2C-BCB4-481D-961A-1DCF310814D0" name="GUID-030BFD2C-BCB4-481D-961A-1DCF310814D0"></a><h4 id="LNPLS-GUID-030BFD2C-BCB4-481D-961A-1DCF310814D0" class="sect4"><span class="enumeration_section">5.7.1</span>数据类型兼容性</h4>
                  <div>
                     <p>仅当集合具有相同的数据类型时，才可以将集合分配给集合变量。具有相同的元素类型是不够的。</p>
                     <div class="example" id="GUID-030BFD2C-BCB4-481D-961A-1DCF310814D0__BABHBDJJ">
                        <p class="titleinexample">示例5-10收集分配的数据类型兼容性</p>
                        <p>在此示例中， <code class="codeph">VARRAY</code>类型<code class="codeph">triplet</code>和<code class="codeph">trio</code>具有相同的元素类型<code class="codeph">VARCHAR(15)</code> 。集合变量<code class="codeph">group1</code>和<code class="codeph">group2</code>具有相同的数据类型<code class="codeph">triplet</code> ，但集合变量<code class="codeph">group3</code>具有数据类型<code class="codeph">trio</code> 。<code class="codeph">group1</code>到<code class="codeph">group2</code>的分配成功，但<code class="codeph">group1</code>到<code class="codeph">group3</code>的分配失败。
                        </p>
                        <div class="infoboxnote" id="GUID-030BFD2C-BCB4-481D-961A-1DCF310814D0__GUID-085C20D7-9BCF-4553-BD1E-2F215249C3FA">
                           <p class="notep1">实时SQL：</p>
                           <p>您可以在Oracle Live SQL上<a href="https://livesql.oracle.com/apex/livesql/docs/lnpls/plsql-collections-and-records/composites59err.html" target="_blank">以收集分配的数据类型兼容性</a>查看和运行此示例</p>
                        </div><pre class="oac_no_warn" dir="ltr">DECLARE TYPE三元组IS VARRAY（3）OF VARCHAR2（15）; TYPE trio IS VARRAY（3）OF VARCHAR2（15）; group1 triplet：= triplet（'Jones'，'Wong'，'Marceau'）; <span class="bold">group2 triplet;</span> <span class="bold">group3 trio;</span> BEGIN group2：= group1; - 成功<span class="bold">group3：= group1; - 失败</span> END; /</pre><p>结果：</p><pre class="oac_no_warn" dir="ltr">ORA-06550：第10行，第13列：PLS-00382：表达式类型错误</pre></div>
                     <!-- class="example" -->
                  </div>
               </div><a id="LNPLS463"></a><a id="LNPLS99917"></a><div class="props_rev_3"><a id="GUID-C2176FE3-EA3F-439B-9924-E4793B5DBB6D" name="GUID-C2176FE3-EA3F-439B-9924-E4793B5DBB6D"></a><h4 id="LNPLS-GUID-C2176FE3-EA3F-439B-9924-E4793B5DBB6D" class="sect4"><span class="enumeration_section">5.7.2</span>将Null值分配给Varray或嵌套表变量</h4>
                  <div>
                     <p>对于varray或嵌套表变量，可以指定值<code class="codeph">NULL</code>或相同数据类型的null集合。赋值使变量为null。
                     </p>
                     <div class="section">
                        <p><a href="plsql-collections-and-records.html#GUID-C2176FE3-EA3F-439B-9924-E4793B5DBB6D__ASSIGNINGNULLVALUETONESTEDTABLEVARI-9A2B377F">例5-11</a>将嵌套表变量<code class="codeph">dept_names</code>初始化为非空值;为它分配一个空集合，使其为null;并将其重新初始化为不同的非空值。
                        </p>
                     </div>
                     <!-- class="section" -->
                     <div class="example" id="GUID-C2176FE3-EA3F-439B-9924-E4793B5DBB6D__ASSIGNINGNULLVALUETONESTEDTABLEVARI-9A2B377F">
                        <p class="titleinexample">示例5-11将Null值分配给嵌套表变量</p>
                        <div class="infoboxnote" id="GUID-C2176FE3-EA3F-439B-9924-E4793B5DBB6D__GUID-25768810-059A-4A3B-8D3A-E5A33A0329EA">
                           <p class="notep1">实时SQL：</p>
                           <p>您可以在<a href="https://livesql.oracle.com/apex/livesql/docs/lnpls/plsql-collections-and-records/composites18.html" target="_blank">将Null Value分配给嵌套表变量时</a>在Oracle Live SQL上查看和运行此示例</p>
                        </div><pre class="oac_no_warn" dir="ltr">DECLARE TYPE dnames_tab是VARCHAR2的表（30）; dept_names dnames_tab：= dnames_tab（'Shipping'，'Sales'，'Finance'，'Payroll'）; - 初始化为非空值empty_set dnames_tab; - 未初始化，因此为空PROCEDURE print_dept_names_status IS BEGIN如果dept_names为空，那么DBMS_OUTPUT.PUT_LINE（'dept_names为null。“）; ELSE DBMS_OUTPUT.PUT_LINE（'dept_names不为空。“）;万一; END print_dept_names_status; BEGIN print_dept_names_status; <span class="bold">dept_names：= empty_set; - 将空集合分配给dept_names。</span>print_dept_names_status; dept_names：= dnames_tab（'Shipping'，'Sales'，'Finance'，'Payroll'）; - 重新初始化dept_names print_dept_names_status;结束; /</pre><p>结果：</p><pre class="oac_no_warn" dir="ltr">dept_names不为空。
<span class="bold">dept_names为null。</span>dept_names不为空。</pre></div>
                     <!-- class="example" -->
                  </div>
               </div><a id="LNPLS464"></a><a id="LNPLS99916"></a><div class="props_rev_3"><a id="GUID-E939651F-5E2B-4A83-9035-4FA5498B78AA" name="GUID-E939651F-5E2B-4A83-9035-4FA5498B78AA"></a><h4 id="LNPLS-GUID-E939651F-5E2B-4A83-9035-4FA5498B78AA" class="sect4"><span class="enumeration_section">5.7.3</span>将设置操作结果分配给嵌套表变量</h4>
                  <div>
                     <p>对于嵌套表变量，可以分配SQL <code class="codeph">MULTISET</code>操作或SQL <code class="codeph">SET</code>函数调用的结果。
                     </p>
                     <div class="section">
                        <p>SQL <code class="codeph">MULTISET</code>运算符将两个嵌套表组合到一个嵌套表中。两个嵌套表的元素必须具有可比较的数据类型。有关<code class="codeph">MULTISET</code>运算符的信息，请参阅<a href="../sqlrf/Multiset-Operators.html#SQLRF0032" target="_blank"><span class="italic">Oracle数据库SQL语言参考</span></a> 。
                        </p>
                        <p>SQL <code class="codeph">SET</code>函数采用嵌套的表参数，并返回一个相同数据类型的嵌套表，其元素是不同的（该函数消除了重复的元素）。有关<code class="codeph">SET</code>函数的信息，请参见<a href="../sqlrf/SET.html#SQLRF06308" target="_blank"><span class="italic">Oracle数据库SQL语言参考</span></a> 。
                        </p>
                     </div>
                     <!-- class="section" -->
                     <div class="example" id="GUID-E939651F-5E2B-4A83-9035-4FA5498B78AA__BABFIDIG">
                        <p class="titleinexample">示例5-12将设置操作结果分配给嵌套表变量</p>
                        <p>这个例子中的几个的结果分配<code class="codeph">MULTISET</code>运算和一次<code class="codeph">SET</code>嵌套表变量的函数调用<code class="codeph">answer</code> ，使用的程序<code class="codeph">print_nested_table</code>打印<code class="codeph">answer</code>每个分配之后。该过程使用<code class="codeph">FIRST</code>和<code class="codeph">LAST</code>的收集方法，如<span class="q">“ <a href="plsql-collections-and-records.html#GUID-0452FBDC-D9C1-486E-B432-49AF84743A9F" title="集合方法是PL / SQL子程序 - 返回有关集合的信息的函数或对集合进行操作的过程。集合方法使集合更易于使用，并且您的应用程序更易于维护。">收集方法</a> ”中所述</span> 。
                        </p>
                        <div class="infoboxnote" id="GUID-E939651F-5E2B-4A83-9035-4FA5498B78AA__GUID-41AE5027-02C6-4C63-8184-EE095362230C">
                           <p class="notep1">实时SQL：</p>
                           <p>您可以在<a href="https://livesql.oracle.com/apex/livesql/docs/lnpls/plsql-collections-and-records/composites19.html" target="_blank">将</a>实例化<a href="https://livesql.oracle.com/apex/livesql/docs/lnpls/plsql-collections-and-records/composites19.html" target="_blank">操作结果分配给嵌套表变量时</a>在Oracle Live SQL上查看和运行此示例</p>
                        </div><pre class="oac_no_warn" dir="ltr">DECLARE TYPE nested_typ是一个数字表; nt1 nested_typ：= nested_typ（1,2,3）; nt2 nested_typ：= nested_typ（3,2,1）; nt3 nested_typ：= nested_typ（2,3,1,3）; nt4 nested_typ：= nested_typ（1,2,4）;回答nested_typ; PROCEDURE print_nested_table（nt nested_typ）IS输出VARCHAR2（128）; BEGIN如果没有，那么DBMS_OUTPUT.PUT_LINE（'结果：空集'）; ELSIF nt。COUNT = 0那么DBMS_OUTPUT.PUT_LINE（'结果：空集'）;因为我没有。FIRST .. nt。最后的循环 - 对于从头到尾的元素输出：=输出|| nt（i）|| '';结束循环; DBMS_OUTPUT.PUT_LINE（'结果：'||输出）;万一; END print_nested_table; BEGIN <span class="bold">回答：= nt1 MULTISET UNION nt4;</span> print_nested_table（回答）; <span class="bold">回答：= nt1 MULTISET UNION nt3;</span> print_nested_table（回答）; <span class="bold">回答：= nt1 MULTISET UNION DISTINCT nt3;</span> print_nested_table（回答）; <span class="bold">回答：= nt2 MULTISET INTERSECT nt3;</span> print_nested_table（回答）; <span class="bold">回答：= nt2 MULTISET INTERSECT DISTINCT nt3;</span> print_nested_table（回答）; <span class="bold">回答：= SET（nt3）;</span> print_nested_table（回答）; <span class="bold">回答：= nt3 MULTISET EXCEPT nt2;</span> print_nested_table（回答）; <span class="bold">回答：= nt3 MULTISET除了DISTINCT nt2;</span> print_nested_table（回答）;结束; /</pre><p>结果：</p><pre class="oac_no_warn" dir="ltr">结果：1 2 3 1 2 4结果：1 2 3 2 3 1 3结果：1 2 3结果：3 2 1结果：3 2 1结果：2 3 1结果：3结果：空集</pre></div>
                     <!-- class="example" -->
                  </div>
               </div>
            </div><a id="LNPLS470"></a><a id="LNPLS471"></a><a id="LNPLS472"></a><a id="LNPLS00507"></a><div class="props_rev_3"><a id="GUID-2E00BF7F-0285-41F1-8075-AC859F622A3F" name="GUID-2E00BF7F-0285-41F1-8075-AC859F622A3F"></a><h3 id="LNPLS-GUID-2E00BF7F-0285-41F1-8075-AC859F622A3F" class="sect3"><span class="enumeration_section">5.8</span>多维集合</h3>
               <div>
                  <p>虽然集合只有一个维度，但您可以使用其元素为集合的集合对多维集合进行建模。</p>
                  <div class="example" id="GUID-2E00BF7F-0285-41F1-8075-AC859F622A3F__BABHFDCF">
                     <p class="titleinexample">例5-13二维Varray（Varrays of Varrays）</p>
                     <p>在这个例子中， <code class="codeph">nva</code>是一个二维varray  - 一个整数变量的varray。
                     </p>
                     <div class="infoboxnote" id="GUID-2E00BF7F-0285-41F1-8075-AC859F622A3F__GUID-39EFB002-C4C5-46D6-8EF2-1C0FA92C8BAA">
                        <p class="notep1">实时SQL：</p>
                        <p>您可以在Oracle Live SQL上以<a href="https://livesql.oracle.com/apex/livesql/docs/lnpls/plsql-collections-and-records/composites25.html" target="_blank">二维Varray（Varray of Varrays）</a>查看和运行此示例</p>
                     </div><pre class="oac_no_warn" dir="ltr">DECLARE TYPE t1是INTEGER的VARRAY（10）; - 整数va t1的varray：= t1（2,3,5）; TYT nt1是VAR的TAY（10）; - 整数nva nt1的varray：= nt1（va，t1（53,5,73），t1（2,4），va）;我是INTEGER; va1 t1;开始i：= nva（2）（3）; DBMS_OUTPUT.PUT_LINE（'i ='|| i）; NVA。延伸; nva（5）：= t1（56,32）; - 替换内部varray元素nva（4）：= t1（45,43,67,43345）; - 替换内部整数元素nva（4）（4）：= 1; - 用1 nva（4）替换43345。延伸; - 将元素添加到第4个varray元素nva（4）（5）：= 89; - 存储整数89那里END; /</pre><p>结果：</p><pre class="oac_no_warn" dir="ltr">我= 73</pre></div>
                  <!-- class="example" -->
                  <div class="example" id="GUID-2E00BF7F-0285-41F1-8075-AC859F622A3F__BABBHGFG">
                     <p class="titleinexample">示例5-14嵌套表和整数变量的嵌套表</p>
                     <p>在此示例中， <code class="codeph">ntb1</code>是嵌套的字符串表的嵌套表，ntb2是整数<code class="codeph">ntb2</code>的嵌套表。
                     </p>
                     <div class="infoboxnote" id="GUID-2E00BF7F-0285-41F1-8075-AC859F622A3F__GUID-82E6A5EF-43E6-4DA8-90C3-DBF30B97028E">
                        <p class="notep1">实时SQL：</p>
                        <p>您可以在<a href="https://livesql.oracle.com/apex/livesql/docs/lnpls/plsql-collections-and-records/composites26.html" target="_blank">嵌套表嵌套表和整数</a>变量上的Oracle Live SQL上查看和运行此示例</p>
                     </div><pre class="oac_no_warn" dir="ltr">DECLARE TYPE tb1是VARCHAR2的表（20）; - 嵌套的字符串表vtb1 tb1：= tb1（'one'，'three'）; TYT ntb1是表tb1; - 嵌套的字符串表的嵌套表vntb1 ntb1：= ntb1（vtb1）; TYPE tv1 IS VARRAY（10）OF INTEGER; - 整数的varray类型ntb2是tv1的表; - 整数varrays的嵌套表vntb2 ntb2：= ntb2（tv1（3,5），tv1（5,7,3））;开始vntb1。延伸; vntb1（2）：= vntb1（1）; vntb1。DELETE（1）; - 删除vntb1 vntb1（2）的第一个元素。DELETE（1）; - 从嵌套表END中的第二个表中删除第一个字符串; /</pre></div>
                  <!-- class="example" -->
                  <div class="example" id="GUID-2E00BF7F-0285-41F1-8075-AC859F622A3F__BABIBDDG">
                     <p class="titleinexample">例5-15关联数组和字符串变量的嵌套表</p>
                     <p>在此示例中， <code class="codeph">aa1</code>是关联数组的关联数组， <code class="codeph">ntb2</code>是字符串<code class="codeph">ntb2</code>的嵌套表。
                     </p>
                     <div class="infoboxnote" id="GUID-2E00BF7F-0285-41F1-8075-AC859F622A3F__GUID-73F8EB37-5293-4C8B-83B8-FAB13E1C496F">
                        <p class="notep1">实时SQL：</p>
                        <p>您可以在Oracle Live SQL上的<a href="https://livesql.oracle.com/apex/livesql/docs/lnpls/plsql-collections-and-records/composites27.html" target="_blank">Nested Tables of Associative Arrays和Varrays of Strings</a>上查看和运行此示例</p>
                     </div><pre class="oac_no_warn" dir="ltr">DECLARE TYPE tb1是PLS_INTEGER的INTEGER INDEX表; - 关联数组v4 tb1; v5 tb1; TYPE aa1是PLS_INTEGER的tb1索引表; -  v2 aa1的关联数组; - 关联数组TYPE va1 VARROAR（10）OF VARCHAR2（20）; -  varray of strings v1 va1：= va1（'hello'，'world'）; TYPE ntb2是PLS_INTEGER的va1索引表; - 关联变量数组v3 ntb2; BEGIN v4（1）：= 34; -  populate associative array v4（2）：= 46456; v4（456）：= 343; v2（23）：= v4; - 填充关联数组的关联数组v3（34）：= va1（33,456,656,343）; - 填充关联数组varrays v2（35）：= v5; - 将空关联数组分配给v2（35）v2（35）（2）：= 78;结束; /</pre></div>
                  <!-- class="example" -->
               </div>
            </div><a id="LNPLS372"></a><a id="LNPLS00506"></a><div class="props_rev_3"><a id="GUID-68EC8EF3-E351-4917-8C7A-5103CDB2C01B" name="GUID-68EC8EF3-E351-4917-8C7A-5103CDB2C01B"></a><h3 id="LNPLS-GUID-68EC8EF3-E351-4917-8C7A-5103CDB2C01B" class="sect3"><span class="enumeration_section">5.9</span>收集比较</h3>
               <div>
                  <p>要确定一个集合变量是否小于另一个集合变量（例如），您必须在该上下文中定义小于均值的值，并编写一个返回<code class="codeph">TRUE</code>或<code class="codeph">FALSE</code>的函数。</p>
                  <p>您无法将关联数组变量与值<code class="codeph">NULL</code>或彼此进行比较。
                  </p>
                  <p>除了<a href="plsql-collections-and-records.html#GUID-B2837845-3175-444E-81A5-7D0D5BFC7F20" title="当且仅当它们具有相同的元素集（以任何顺序）时，两个嵌套的表变量是相等的。">比较嵌套表中的等式和不等式之外</a> ，您无法将两个集合变量与关系运算符进行本机比较。此限制也适用于隐式比较。例如，集合变量不能出现在<code class="codeph">DISTINCT</code> ， <code class="codeph">GROUP</code> <code class="codeph">BY</code>或<code class="codeph">ORDER</code> <code class="codeph">BY</code>子句中。
                  </p>
                  <div class="section">
                     <p class="subhead2" id="GUID-68EC8EF3-E351-4917-8C7A-5103CDB2C01B__GUID-43275A96-3606-4520-92F5-234E43D120C0">话题</p>
                  </div>
                  <!-- class="section" -->
                  <div class="section">
                     <ul style="list-style-type:disc">
                        <li>
                           <p><a href="plsql-collections-and-records.html#GUID-71CB53BF-9FE6-493D-9D66-451AAAB091FC" title="与NULL值比较时，使用IS [NOT] NULL运算符。">将Varray和嵌套表变量比较为NULL</a></p>
                        </li>
                        <li>
                           <p><a href="plsql-collections-and-records.html#GUID-B2837845-3175-444E-81A5-7D0D5BFC7F20" title="当且仅当它们具有相同的元素集（以任何顺序）时，两个嵌套的表变量是相等的。">比较嵌套表的平等和不等式</a></p>
                        </li>
                        <li>
                           <p><a href="plsql-collections-and-records.html#GUID-C8C96B4E-09BE-476F-A95C-D2D0B1589CB8" title="您可以使用SQL multiset条件比较嵌套表变量并测试它们的一些属性。">将嵌套表与SQL Multiset条件进行比较</a></p>
                        </li>
                     </ul>
                     <div class="infoboxnotealso" id="GUID-68EC8EF3-E351-4917-8C7A-5103CDB2C01B__GUID-A6339B04-4122-4670-B998-0CC3DC833967">
                        <p class="notep1">也可以看看：</p>
                        <ul style="list-style-type:disc">
                           <li>
                              <p><a href="plsql-language-fundamentals.html#GUID-2EB964C8-9B36-4009-A45F-B340F44EE2A2__CIHCCCBB" title="此表列出了关系运算符并给出了它们的含义。">表2-5</a> 
                              </p>
                           </li>
                           <li>
                              <p>有关编写函数的信息的<a href="plsql-subprograms.html#GUID-13BEBBEC-02D4-48E8-A059-DFEAC4751A3B" title="当PL / SQL函数具有RESULT_CACHE选项时，其结果将缓存在共享全局区域（SGA）中，因此连接到同一实例的会话可以在可用时重用这些结果。PL / SQL函数结果缓存与结果缓存共享其管理和可管理性基础结构。如果在DR单元（定义者权限单元）中包含已连接的用户数据库链接，则必须向将运行DR单元的用户授予INHERIT REMOTE PRIVILEGES权限。">PL / SQL子程序</a></p>
                           </li>
                        </ul>
                     </div>
                  </div>
                  <!-- class="section" -->
               </div><a id="LNPLS373"></a><a id="LNPLS99915"></a><div class="props_rev_3"><a id="GUID-71CB53BF-9FE6-493D-9D66-451AAAB091FC" name="GUID-71CB53BF-9FE6-493D-9D66-451AAAB091FC"></a><h4 id="LNPLS-GUID-71CB53BF-9FE6-493D-9D66-451AAAB091FC" class="sect4"><span class="enumeration_section">5.9.1</span>将Varray和嵌套表变量比较为NULL</h4>
                  <div>
                     <p>与NULL值比较时，使用<code class="codeph">IS[NOT] NULL</code>运算符。
                     </p>
                     <div class="section">
                        <p>您可以使用<span class="q">“ <a href="plsql-language-fundamentals.html#GUID-D02FA4D0-0074-4227-9624-F01E3D219BAB" title="如果操作数为NULL，则IS NULL运算符返回BOOLEAN值TRUE，如果不为NULL，则返回FALSE。 IS NOT NULL运算符则相反。">IS [NOT] NULL运算符</a> ”</span>将varray和嵌套表变量与<code class="codeph">NULL</code>值进行比较，但不能将关系运算符等于（ <code class="codeph">=</code> ）且不等于（ <code class="codeph">&lt;&gt;</code> <code class="codeph">!=</code> ， <code class="codeph">~=</code>或<code class="codeph">^=</code> ）。
                        </p>
                     </div>
                     <!-- class="section" -->
                     <div class="example" id="GUID-71CB53BF-9FE6-493D-9D66-451AAAB091FC__CIHCGJIC">
                        <p class="titleinexample">示例5-16将Varray和嵌套表变量与NULL进行比较</p>
                        <p>此示例正确地将varray变量和嵌套表变量与<code class="codeph">NULL</code>进行比较。
                        </p>
                        <div class="infoboxnote" id="GUID-71CB53BF-9FE6-493D-9D66-451AAAB091FC__GUID-80CFA1AD-739B-4317-A746-AB388C707678">
                           <p class="notep1">实时SQL：</p>
                           <p>您可以在<a href="https://livesql.oracle.com/apex/livesql/docs/lnpls/plsql-collections-and-records/tdlnplscomposites60.html" target="_blank">比较Varray和嵌套表变量的</a> Oracle Live SQL上查看并运行此示例<a href="https://livesql.oracle.com/apex/livesql/docs/lnpls/plsql-collections-and-records/tdlnplscomposites60.html" target="_blank">为NULL</a></p>
                        </div><pre class="oac_no_warn" dir="ltr">DECLARE TYPE四种IS VARRAY（4）OF VARCHAR2（15）; -  VARRAY型团队四人组; -  varray变量TYPE Roster IS TABLE OF VARCHAR2（15）; - 嵌套表类型名称Roster：= Roster（'Adams'，'Patel'）; - 嵌套表变量BEGIN <span class="bold">IF team IS NULL，然后</span> DBMS_OUTPUT.PUT_LINE（'team IS NULL'）; ELSE DBMS_OUTPUT.PUT_LINE（'team IS NOT NULL'）;万一; <span class="bold">IF名称不是NULL，而</span> DBMS_OUTPUT.PUT_LINE（'names IS NOT NULL'）; ELSE DBMS_OUTPUT.PUT_LINE（'names IS NULL'）;万一;结束; /</pre><p>结果：</p><pre class="oac_no_warn" dir="ltr">团队IS NULL名称IS NOT NULL</pre></div>
                     <!-- class="example" -->
                  </div>
               </div><a id="LNPLS468"></a><a id="LNPLS99914"></a><div class="props_rev_3"><a id="GUID-B2837845-3175-444E-81A5-7D0D5BFC7F20" name="GUID-B2837845-3175-444E-81A5-7D0D5BFC7F20"></a><h4 id="LNPLS-GUID-B2837845-3175-444E-81A5-7D0D5BFC7F20" class="sect4"><span class="enumeration_section">5.9.2</span>比较嵌套表的等式和不等式</h4>
                  <div>
                     <p>当且仅当它们具有相同的元素集（以任何顺序）时，两个嵌套的表变量是相等的。</p>
                     <div class="section">
                        <p>如果两个嵌套表变量具有相同的嵌套表类型，并且嵌套表类型没有记录类型的元素，则可以将两个变量的相等或不等式与关系运算符equ（ <code class="codeph">=</code> ）并且不等于（ <code class="codeph">&lt;&gt;</code> <code class="codeph">!=</code> ， <code class="codeph">~=</code> ， <code class="codeph">^=</code> ）。
                        </p>
                        <div class="infoboxnotealso" id="GUID-B2837845-3175-444E-81A5-7D0D5BFC7F20__GUID-85F1649A-C788-45AB-8A5E-312B0F1859AD">
                           <p class="notep1">也可以看看：</p>
                           <p><span class="q">“ <a href="plsql-collections-and-records.html#GUID-DFDE40BD-4B61-4C8A-B9CE-3FE01E21F658" title="无法针对无效，平等或不平等进行本地测试。">记录比较</a> ”</span></p>
                        </div>
                     </div>
                     <!-- class="section" -->
                     <div class="example" id="GUID-B2837845-3175-444E-81A5-7D0D5BFC7F20__BABCBFHA">
                        <p class="titleinexample">示例5-17比较嵌套表的等式和不等式</p>
                        <p>此示例将嵌套表变量与相关运算符进行相等性和不等式的比较。</p>
                        <div class="infoboxnote" id="GUID-B2837845-3175-444E-81A5-7D0D5BFC7F20__GUID-E9F9AC23-0889-4B50-BDBD-5BF909917E4C">
                           <p class="notep1">实时SQL：</p>
                           <p>您可以在<a href="https://livesql.oracle.com/apex/livesql/docs/lnpls/plsql-collections-and-records/lnplscomposites95.html" target="_blank">比较嵌套表中的等效和不等的</a> Oracle Live SQL上查看和运行此示例</p>
                        </div><pre class="oac_no_warn" dir="ltr">DECLARE TYPE dnames_tab是<span class="bold">VARCHAR2的</span>表<span class="bold">（30）</span> ; <span class="bold">- 元素类型不是记录类型</span> dept_names1 dnames_tab：= dnames_tab（'Shipping'，'Sales'，'Finance'，'Payroll'）; dept_names2 dnames_tab：= dnames_tab（'Sales'，'Finance'，'Shipping'，'Payroll'）; dept_names3 dnames_tab：= dnames_tab（'Sales'，'Finance'，'Payroll'）; BEGIN <span class="bold">IF dept_names1 = dept_names2那么</span> DBMS_OUTPUT.PUT_LINE（'dept_names1 = dept_names2'）;万一; <span class="bold">如果dept_names2！= dept_names3那么</span> DBMS_OUTPUT.PUT_LINE（'dept_names2！= dept_names3'）;万一;结束; /</pre><p>结果：</p><pre class="oac_no_warn" dir="ltr"><span class="bold">dept_names1 = dept_names2</span> <span class="bold">dept_names2！= dept_names3</span></pre></div>
                     <!-- class="example" -->
                  </div>
               </div><a id="LNPLS469"></a><a id="LNPLS99913"></a><div class="props_rev_3"><a id="GUID-C8C96B4E-09BE-476F-A95C-D2D0B1589CB8" name="GUID-C8C96B4E-09BE-476F-A95C-D2D0B1589CB8"></a><h4 id="LNPLS-GUID-C8C96B4E-09BE-476F-A95C-D2D0B1589CB8" class="sect4"><span class="enumeration_section">5.9.3</span>将嵌套表与SQL Multiset条件进行比较</h4>
                  <div>
                     <p>您可以使用SQL multiset条件比较嵌套表变量并测试它们的一些属性。</p>
                     <div class="section">
                        <div class="infoboxnotealso" id="GUID-C8C96B4E-09BE-476F-A95C-D2D0B1589CB8__GUID-EEA8688E-5515-4365-B5FF-EBB0D0923F87">
                           <p class="notep1">也可以看看：</p>
                           <ul style="list-style-type:disc">
                              <li>
                                 <p>有关多集条件的详细信息，请<a href="../sqlrf/Multiset-Conditions.html#SQLRF52128" target="_blank"><span class="italic">参见Oracle数据库SQL语言参考</span></a></p>
                              </li>
                              <li>
                                 <p>有关<code class="codeph">CARDINALITY</code>语法的详细信息，请<a href="../sqlrf/CARDINALITY.html#SQLRF06305" target="_blank"><span class="italic">参见Oracle数据库SQL语言参考</span></a></p>
                              </li>
                              <li>
                                 <p>有关<code class="codeph">SET</code>语法的详细信息，请<a href="https://www.oracle.com/pls/topic/lookup?ctx=en/database/oracle/oracle-database/19/lnpls&amp;id=SQLRF06308" target="_blank"><span class="italic">参见Oracle Database SQL语言参考</span></a></p>
                              </li>
                           </ul>
                        </div>
                     </div>
                     <!-- class="section" -->
                     <div class="example" id="GUID-C8C96B4E-09BE-476F-A95C-D2D0B1589CB8__BABCDABC">
                        <p class="titleinexample">示例5-18将嵌套表与SQL Multiset条件进行比较</p>
                        <p>此示例使用SQL多集条件和两个采用嵌套表变量参数<code class="codeph">CARDINALITY</code>和<code class="codeph">SET</code> SQL函数。
                        </p>
                        <div class="infoboxnote" id="GUID-C8C96B4E-09BE-476F-A95C-D2D0B1589CB8__GUID-FEC0F6A2-0678-408C-9036-8530378EEEF4">
                           <p class="notep1">实时SQL：</p>
                           <p>您可以在<a href="https://livesql.oracle.com/apex/livesql/docs/lnpls/plsql-collections-and-records/tdlnplscomposites24.html" target="_blank">使用SQL Multiset条件比较嵌套表时</a>在Oracle Live SQL上查看和运行此示例</p>
                        </div><pre class="oac_no_warn" dir="ltr">DECLARE TYPE nested_typ是一个数字表; nt1 nested_typ：= nested_typ（1,2,3）; nt2 nested_typ：= nested_typ（3,2,1）; nt3 nested_typ：= nested_typ（2,3,1,3）; nt4 nested_typ：= nested_typ（1,2,4）; PROCEDURE作证（真相BOOLEAN：= NULL，数量NUMBER：= NULL）如果真相不是空，则DBMS_OUTPUT.PUT_LINE（CASE真值为真，那么'真如'假'那么'假'结束）;万一;如果数量不是NULL那么DBMS_OUTPUT.PUT_LINE（数量）;万一;结束; BEGIN作证（真相=&gt;（ <span class="bold">nt1 IN（nt2，nt3，nt4）</span> ））; - 条件证明（真相=&gt;（ <span class="bold">nt1子模式nt3</span> ））; - 条件证明（真相=&gt;（ <span class="bold">nt1不是nt4的子模式</span> ））; - 条件证明（真相=&gt;（ <span class="bold">4名成员nt1</span> ））; - 条件证明（真相=&gt;（ <span class="bold">nt3 IS A SET</span> ））; - 条件证明（真相=&gt;（ <span class="bold">nt3不是一套</span> ））; - 条件证明（真相=&gt;（ <span class="bold">nt1 IS EMPTY</span> ））; - 条件证明（数量=&gt;（ <span class="bold">CARDINALITY（nt3）</span> ））; - 功能证明（数量=&gt;（ <span class="bold">CARDINALITY（SET（nt3））</span> ））; -  2个功能END; /</pre><p>结果：</p><pre class="oac_no_warn" dir="ltr">真如真真假真真假4 3</pre></div>
                     <!-- class="example" -->
                  </div>
               </div>
            </div><a id="LNPLS375"></a><a id="LNPLS376"></a><a id="LNPLS00508"></a><div class="props_rev_3"><a id="GUID-0452FBDC-D9C1-486E-B432-49AF84743A9F" name="GUID-0452FBDC-D9C1-486E-B432-49AF84743A9F"></a><h3 id="LNPLS-GUID-0452FBDC-D9C1-486E-B432-49AF84743A9F" class="sect3"><span class="enumeration_section">5.10</span>收集方法</h3>
               <div>
                  <p>集合方法是PL / SQL子程序 - 返回有关集合的信息的函数或对集合进行操作的过程。集合方法使集合更易于使用，并且您的应用程序更易于维护。</p>
                  <p><a href="plsql-collections-and-records.html#GUID-0452FBDC-D9C1-486E-B432-49AF84743A9F__CHDDJGFA" title="此表总结了收集方法。第一列按字母顺序列出其名称。第二列列出了它们的类型（功能或过程）。第三列简要介绍了它们。">表5-2</a>总结了收集方法。
                  </p>
                  <div class="infoboxnote" id="GUID-0452FBDC-D9C1-486E-B432-49AF84743A9F__GUID-90978ED7-FEC6-4C44-8D56-3AD02168AD6D">
                     <p class="notep1">注意：</p>
                     <p>对于null集合， <code class="codeph">EXISTS</code>是唯一不会引发预定义异常<code class="codeph">COLLECTION_IS_NULL</code>集合方法。</p>
                  </div>
                  <div class="tblformal" id="GUID-0452FBDC-D9C1-486E-B432-49AF84743A9F__CHDDJGFA">
                     <p class="titleintable">表5-2收集方法</p>
                     <table cellpadding="4" cellspacing="0" class="Formal" title="收集方法" width="100%" border="1" summary="This table summarizes the collection methods. The first column lists their names, in alphabetical order. The second column lists their types (function or procedure). The third column gives brief descriptions of them." frame="hsides" rules="rows">
                        <thead>
                           <tr align="left" valign="top">
                              <th align="left" valign="bottom" width="14%" id="d36567e4886">方法</th>
                              <th align="left" valign="bottom" width="14%" id="d36567e4889">类型</th>
                              <th align="left" valign="bottom" width="72%" id="d36567e4892">描述</th>
                           </tr>
                        </thead>
                        <tbody>
                           <tr align="left" valign="top">
                              <td align="left" valign="top" width="14%" id="d36567e4897" headers="d36567e4886 ">
                                 <p><code class="codeph">删除</code></p>
                              </td>
                              <td align="left" valign="top" width="14%" headers="d36567e4897 d36567e4889 ">
                                 <p>程序</p>
                              </td>
                              <td align="left" valign="top" width="72%" headers="d36567e4897 d36567e4892 ">
                                 <p>从集合中删除元素。</p>
                              </td>
                           </tr>
                           <tr align="left" valign="top">
                              <td align="left" valign="top" width="14%" id="d36567e4908" headers="d36567e4886 ">
                                 <p><code class="codeph">修剪</code></p>
                              </td>
                              <td align="left" valign="top" width="14%" headers="d36567e4908 d36567e4889 ">
                                 <p>程序</p>
                              </td>
                              <td align="left" valign="top" width="72%" headers="d36567e4908 d36567e4892 ">
                                 <p>从varray或嵌套表的末尾删除元素。</p>
                              </td>
                           </tr>
                           <tr align="left" valign="top">
                              <td align="left" valign="top" width="14%" id="d36567e4919" headers="d36567e4886 ">
                                 <p><code class="codeph">延伸</code></p>
                              </td>
                              <td align="left" valign="top" width="14%" headers="d36567e4919 d36567e4889 ">
                                 <p>程序</p>
                              </td>
                              <td align="left" valign="top" width="72%" headers="d36567e4919 d36567e4892 ">
                                 <p>将元素添加到varray或嵌套表的末尾。</p>
                              </td>
                           </tr>
                           <tr align="left" valign="top">
                              <td align="left" valign="top" width="14%" id="d36567e4930" headers="d36567e4886 ">
                                 <p><code class="codeph">EXISTS</code></p>
                              </td>
                              <td align="left" valign="top" width="14%" headers="d36567e4930 d36567e4889 ">
                                 <p>功能</p>
                              </td>
                              <td align="left" valign="top" width="72%" headers="d36567e4930 d36567e4892 ">
                                 <p>当且仅当varray或嵌套表的指定元素存在时，返回<code class="codeph">TRUE</code> 。
                                 </p>
                              </td>
                           </tr>
                           <tr align="left" valign="top">
                              <td align="left" valign="top" width="14%" id="d36567e4944" headers="d36567e4886 ">
                                 <p><code class="codeph">第一</code></p>
                              </td>
                              <td align="left" valign="top" width="14%" headers="d36567e4944 d36567e4889 ">
                                 <p>功能</p>
                              </td>
                              <td align="left" valign="top" width="72%" headers="d36567e4944 d36567e4892 ">
                                 <p>返回集合中的第一个索引。</p>
                              </td>
                           </tr>
                           <tr align="left" valign="top">
                              <td align="left" valign="top" width="14%" id="d36567e4955" headers="d36567e4886 ">
                                 <p><code class="codeph">持续</code></p>
                              </td>
                              <td align="left" valign="top" width="14%" headers="d36567e4955 d36567e4889 ">
                                 <p>功能</p>
                              </td>
                              <td align="left" valign="top" width="72%" headers="d36567e4955 d36567e4892 ">
                                 <p>返回集合中的最后一个索引</p>
                              </td>
                           </tr>
                           <tr align="left" valign="top">
                              <td align="left" valign="top" width="14%" id="d36567e4966" headers="d36567e4886 ">
                                 <p><code class="codeph">计数</code></p>
                              </td>
                              <td align="left" valign="top" width="14%" headers="d36567e4966 d36567e4889 ">
                                 <p>功能</p>
                              </td>
                              <td align="left" valign="top" width="72%" headers="d36567e4966 d36567e4892 ">
                                 <p>返回集合中元素的数量。</p>
                              </td>
                           </tr>
                           <tr align="left" valign="top">
                              <td align="left" valign="top" width="14%" id="d36567e4977" headers="d36567e4886 ">
                                 <p><code class="codeph">限制</code></p>
                              </td>
                              <td align="left" valign="top" width="14%" headers="d36567e4977 d36567e4889 ">
                                 <p>功能</p>
                              </td>
                              <td align="left" valign="top" width="72%" headers="d36567e4977 d36567e4892 ">
                                 <p>返回集合可以拥有的最大元素数。</p>
                              </td>
                           </tr>
                           <tr align="left" valign="top">
                              <td align="left" valign="top" width="14%" id="d36567e4988" headers="d36567e4886 ">
                                 <p><code class="codeph">PRIOR</code></p>
                              </td>
                              <td align="left" valign="top" width="14%" headers="d36567e4988 d36567e4889 ">
                                 <p>功能</p>
                              </td>
                              <td align="left" valign="top" width="72%" headers="d36567e4988 d36567e4892 ">
                                 <p>返回指定索引之前的索引。</p>
                              </td>
                           </tr>
                           <tr align="left" valign="top">
                              <td align="left" valign="top" width="14%" id="d36567e4999" headers="d36567e4886 ">
                                 <p><code class="codeph">下一个</code></p>
                              </td>
                              <td align="left" valign="top" width="14%" headers="d36567e4999 d36567e4889 ">
                                 <p>功能</p>
                              </td>
                              <td align="left" valign="top" width="72%" headers="d36567e4999 d36567e4892 ">
                                 <p>返回成功指定索引的索引。</p>
                              </td>
                           </tr>
                        </tbody>
                     </table>
                  </div>
                  <!-- class="inftblhruleinformal" -->
                  <p>集合方法调用的基本语法是：</p><pre class="oac_no_warn" dir="ltr"><span class="italic">collection_name</span> 。 <span class="italic">方法</span>
</pre><p>有关语法的详细信息，请参阅<span class="q">“ <a href="collection-method.html#GUID-7AF1A3C4-D04B-4F91-9D7B-C92C75E3A300" title="集合方法是PL / SQL子程序，它返回有关集合的信息或对集合进行操作。">集合方法调用</a> ”</span> 。
                  </p>
                  <p>除了在SQL语句中之外，集合方法调用可以出现在其类型（函数或过程）的PL / SQL子程序的调用可以出现的任何地方。（有关PL / SQL子程序的一般信息，请参阅<a href="plsql-subprograms.html#GUID-13BEBBEC-02D4-48E8-A059-DFEAC4751A3B" title="当PL / SQL函数具有RESULT_CACHE选项时，其结果将缓存在共享全局区域（SGA）中，因此连接到同一实例的会话可以在可用时重用这些结果。PL / SQL函数结果缓存与结果缓存共享其管理和可管理性基础结构。如果在DR单元（定义者权限单元）中包含已连接的用户数据库链接，则必须向将运行DR单元的用户授予INHERIT REMOTE PRIVILEGES权限。">PL / SQL子程序</a> 。）
                  </p>
                  <p>在子程序中，集合参数假定与其绑定的参数的属性。您可以将收集方法应用于此类参数。对于varray参数，无论参数模式如何， <code class="codeph">LIMIT</code>的值始终从参数类型定义派生。
                  </p>
                  <div class="section">
                     <p class="subhead2" id="GUID-0452FBDC-D9C1-486E-B432-49AF84743A9F__GUID-ED00CAC3-45C7-437E-98AC-11A5290FBF6B">话题</p>
                  </div>
                  <!-- class="section" -->
                  <div class="section">
                     <ul style="list-style-type:disc">
                        <li>
                           <p><a href="plsql-collections-and-records.html#GUID-E43509F6-5044-4B17-9516-2EB4BDDD5173" title="DELETE是一个从集合中删除元素的过程。">DELETE收集方法</a></p>
                        </li>
                        <li>
                           <p><a href="plsql-collections-and-records.html#GUID-6AF582B1-9C50-4858-AE6C-B14DD051ACD1" title="TRIM是一个从varray或嵌套表的末尾删除元素的过程。">TRIM收集方法</a></p>
                        </li>
                        <li>
                           <p><a href="plsql-collections-and-records.html#GUID-03F74821-BC33-4544-9304-5FBBE6EFE450" title="EXTEND是一个向varray或嵌套表的末尾添加元素的过程。">EXTEND收集方法</a></p>
                        </li>
                        <li>
                           <p><a href="plsql-collections-and-records.html#GUID-31E27176-042B-4BA8-8FBC-14CCEDC33095" title="EXISTS是一个函数，它告诉您是否存在varray或嵌套表的指定元素。">EXISTS收集方法</a></p>
                        </li>
                        <li>
                           <p><a href="plsql-collections-and-records.html#GUID-33E18BC6-C0A8-456B-A47C-A4504240D962" title="第一和最后是功能。">第一和最后的收集方法</a></p>
                        </li>
                        <li>
                           <p><a href="plsql-collections-and-records.html#GUID-5700158F-FF45-4964-89B3-1EF614BA3B7D" title="COUNT是一个返回集合中元素数量的函数（忽略已删除的元素，即使DELETE为它们保留了占位符）。">COUNT收集方法</a></p>
                        </li>
                        <li>
                           <p><a href="plsql-collections-and-records.html#GUID-1E0E1010-FFC5-4F4A-AD87-58BE9CE8146D" title="LIMIT是一个函数，它返回集合可以拥有的最大元素数。如果集合没有最大元素数，LIMIT将返回NULL。只有varray具有最大尺寸。">LIMIT收集方法</a></p>
                        </li>
                        <li>
                           <p><a href="plsql-collections-and-records.html#GUID-FB1216B3-2DC3-48D6-BCEC-243F995BFB09" title="PRIOR和NEXT是允许您在集合中前后移动的函数（忽略已删除的元素，即使DELETE为它们保留了占位符）。这些方法对于遍历稀疏集合很有用。">PRIOR和NEXT收集方法</a></p>
                        </li>
                     </ul>
                  </div>
                  <!-- class="section" -->
               </div><a id="LNPLS377"></a><a id="LNPLS378"></a><a id="LNPLS99961"></a><div class="props_rev_3"><a id="GUID-E43509F6-5044-4B17-9516-2EB4BDDD5173" name="GUID-E43509F6-5044-4B17-9516-2EB4BDDD5173"></a><h4 id="LNPLS-GUID-E43509F6-5044-4B17-9516-2EB4BDDD5173" class="sect4"><span class="enumeration_section">5.10.1</span>删除收集方法</h4>
                  <div>
                     <p><code class="codeph">DELETE</code>是一个从集合中删除元素的过程。
                     </p>
                     <p>此方法具有以下形式：</p>
                     <ul style="list-style-type:disc">
                        <li>
                           <p><code class="codeph">DELETE</code>删除任何类型集合中的所有元素。
                           </p>
                           <p>此操作立即释放分配给已删除元素的内存。</p>
                        </li>
                        <li>
                           <p>从关联数组或嵌套表（但不是varray）：</p>
                           <ul style="list-style-type:disc">
                              <li>
                                 <p><code class="codeph">DELETE(</code> <span class="italic"><code class="codeph">n</code></span> <code class="codeph">)</code>删除索引为<span class="italic">n</span>的元素（如果该元素存在）;否则，它什么都不做。
                                 </p>
                              </li>
                              <li>
                                 <p><code class="codeph">DELETE(</code> <span class="italic"><code class="codeph">m,n</code></span> <code class="codeph">)</code>中删除其索引的范围是<span class="italic">米</span>所有元素.. <span class="italic">N，</span>如果<span class="italic">m</span>和<span class="italic">n</span>存在，且<span class="italic">m</span> &lt;= <span class="italic">N;</span>否则，它什么都不做。
                                 </p>
                              </li>
                           </ul>
                           <p>对于这两种形式的<code class="codeph">DELETE</code> ，PL / SQL为已删除的元素保留占位符。因此，已删除的元素包含在集合的内部大小中，您可以通过为其分配有效值来还原已删除的元素。
                           </p>
                        </li>
                     </ul>
                     <div class="example" id="GUID-E43509F6-5044-4B17-9516-2EB4BDDD5173__CIHJFHJE">
                        <p class="titleinexample">示例5-19具有嵌套表的DELETE方法</p>
                        <p>这个例子声明了一个嵌套的表变量，用六个元素初始化它;删除然后恢复第二个元素;删除一系列元素，然后恢复其中一个元素;然后删除所有元素。恢复的元素占用与相应的已删除元素相同的内存。<code class="codeph">print_nt</code>在初始化之后和每次<code class="codeph">DELETE</code>操作之后打印嵌套表变量。类型<code class="codeph">nt_type</code>和过程<code class="codeph">print_nt</code>在<a href="plsql-collections-and-records.html#GUID-5ADB7EE2-71F6-4172-ACD8-FFDCF2787A37__CIHDEIIG">例5-6</a>中定义。
                        </p><pre class="oac_no_warn" dir="ltr">DECLARE nt nt_type：= nt_type（11,22,33,44,55,66）; BEGIN print_nt（nt）; <span class="bold">NT。DELETE（2）; - 删除第二个元素</span> print_nt（nt）; <span class="bold">nt（2）：= 2222; - 恢复第二个元素</span> print_nt（nt）; <span class="bold">NT。删除（2,4）; - 删除元素范围</span> print_nt（nt）; <span class="bold">nt（3）：= 3333; - 恢复第三个元素</span> print_nt（nt）; <span class="bold">NT。删除; - 删除所有元素</span> print_nt（nt）;结束; /</pre><p>结果：</p><pre class="oac_no_warn" dir="ltr">NT（1）= 11 nt。（2）= 22 nt。（3）= 33 nt。（4）= 44 nt。（5）= 55 nt。（6）= 66 --- nt。（1）= 11 nt。（3）= 33 nt。（4）= 44 nt。（5）= 55 nt。（6）= 66 --- nt。（1）= 11 nt。（2）= 2222 nt。（3）= 33 nt。（4）= 44 nt。（5）= 55 nt。（6）= 66 --- nt。（1）= 11 nt。（5）= 55 nt。（6）= 66 --- nt。（1）= 11 nt。（3）= 3333 nt。（5）= 55 nt。（6）= 66 --- nt是空的---</pre></div>
                     <!-- class="example" -->
                     <div class="example" id="GUID-E43509F6-5044-4B17-9516-2EB4BDDD5173__CIHHFHFJ">
                        <p class="titleinexample">示例5-20带字符串索引的关联数组的DELETE方法</p>
                        <p>此示例填充由string索引的关联数组，并删除所有元素，从而释放分配给它们的内存。接下来，该示例替换已删除的元素 - 即添加与已删除元素具有相同索引的新元素。新的替换元素与相应的已删除元素不占用相同的内存。最后，该示例删除一个元素，然后删除一系列元素。<code class="codeph">print_aa_str</code>过程显示了操作的效果。
                        </p><pre class="oac_no_warn" dir="ltr">DECLARE TYPE aa_type_str是VARCHAR2的整数索引表（10）; aa_str aa_type_str;程序print_aa_str IS i VARCHAR2（10）;开始我：= aa_str。第一;如果我是空的那么DBMS_OUTPUT.PUT_LINE（'aa_str为空'）; ELSE WHILE I NOT NOT NULL LOOP DBMS_OUTPUT.PUT（'aa_str。（'|| i ||'）='）; DBMS_OUTPUT.PUT_LINE（NVL（TO_CHAR（aa_str（i）），'NULL'））; i：= aa_str。NEXT（ⅰ）;结束循环;万一; DBMS_OUTPUT.PUT_LINE（ '---'）; END print_aa_str; BEGIN aa_str（'M'）：= 13; aa_str（'Z'）：= 26; aa_str（'C'）：= 3; print_aa_str; <span class="bold">aa_str。删除; - 删除所有元素</span> print_aa_str; <span class="bold">aa_str（'M'）：= 13; - 用相同的值替换已删除的元素</span> <span class="bold">aa_str（'Z'）：= 260; - 用新值</span> <span class="bold">aa_str（'C'）</span> <span class="bold">替换已删除的元素</span> <span class="bold">：= 30; - 用新值</span> aa_str（'W'） <span class="bold">替换已删除的元素</span> ：= 23; - 添加新元素aa_str（'J'）：= 10; - 添加新元素aa_str（'N'）：= 14; - 添加新元素aa_str（'P'）：= 16; - 添加新元素aa_str（'W'）：= 23; - 添加新元素aa_str（'J'）：= 10; - 添加新元素print_aa_str; <span class="bold">aa_str。DELETE（ 'C'）; - 删除一个元素</span> print_aa_str; <span class="bold">aa_str。DELETE（ 'N'， 'W'）; - 删除元素范围</span> print_aa_str; <span class="bold">aa_str。DELETE（ 'Z'， 'M'）; - 什么都没有</span> print_aa_str;结束; /</pre><p>结果：</p><pre class="oac_no_warn" dir="ltr">aa_str。（C）= 3 aa_str。（M）= 13 aa_str。（Z）= 26 --- aa_str为空--- aa_str。（C）= 30 aa_str。（J）= 10 aa_str。（M）= 13 aa_str。（N）= 14 aa_str。（P）= 16 aa_str。（W）= 23 aa_str。（Z）= 260 --- aa_str。（J）= 10 aa_str。（M）= 13 aa_str。（N）= 14 aa_str。（P）= 16 aa_str。（W）= 23 aa_str。（Z）= 260 --- aa_str。（J）= 10 aa_str。（M）= 13 aa_str。（Z）= 260 --- aa_str。（J）= 10 aa_str。（M）= 13 aa_str。（Z）= 260 ---</pre></div>
                     <!-- class="example" -->
                  </div>
               </div><a id="LNPLS480"></a><a id="LNPLS99962"></a><div class="props_rev_3"><a id="GUID-6AF582B1-9C50-4858-AE6C-B14DD051ACD1" name="GUID-6AF582B1-9C50-4858-AE6C-B14DD051ACD1"></a><h4 id="LNPLS-GUID-6AF582B1-9C50-4858-AE6C-B14DD051ACD1" class="sect4"><span class="enumeration_section">5.10.2</span> TRIM收集方法</h4>
                  <div>
                     <p><code class="codeph">TRIM</code>是一个从varray或嵌套表的末尾删除元素的过程。
                     </p>
                     <p>此方法具有以下形式：</p>
                     <ul style="list-style-type:disc">
                        <li>
                           <p>如果集合至少有一个元素， <code class="codeph">TRIM</code>会从集合的末尾删除一个元素;否则，它会引发预定义的异常<code class="codeph">SUBSCRIPT_BEYOND_COUNT</code> 。</p>
                        </li>
                        <li>
                           <p>如果末尾至少有<span class="italic">n个</span>元素，则<code class="codeph">TRIM(</code> <span class="italic"><code class="codeph">n</code></span> <code class="codeph">)</code>从集合的末尾删除<span class="italic">n</span> <span class="italic">个</span>元素;否则，它会引发预定义的异常<code class="codeph">SUBSCRIPT_BEYOND_COUNT</code> 。</p>
                        </li>
                     </ul>
                     <p><code class="codeph">TRIM</code>根据集合的内部大小进行操作。也就是说，如果<code class="codeph">DELETE</code>删除元素但为其保留占位符，则<code class="codeph">TRIM</code>认为该元素存在。因此， <code class="codeph">TRIM</code>可以删除已删除的元素。
                     </p>
                     <p>PL / SQL不保留修剪元素的占位符。因此，修剪后的元素不包含在集合的内部大小中，并且您无法通过为其指定有效值来恢复修剪后的元素。</p>
                     <div class="infoboxnote" id="GUID-6AF582B1-9C50-4858-AE6C-B14DD051ACD1__GUID-A04D945B-4A9F-413F-8B52-A8AA6EC8522B">
                        <p class="notep1">警告：</p>
                        <p>不要依赖<code class="codeph">TRIM</code>和<code class="codeph">DELETE</code>之间的交互。处理嵌套表，如固定大小的数组（并仅使用<code class="codeph">DELETE</code> ）或堆栈（并仅使用<code class="codeph">TRIM</code>和<code class="codeph">EXTEND</code> ）。
                        </p>
                     </div>
                     <div class="example" id="GUID-6AF582B1-9C50-4858-AE6C-B14DD051ACD1__BABHDBGC">
                        <p class="titleinexample">示例5-21具有嵌套表的TRIM方法</p>
                        <p>这个例子声明了一个嵌套的表变量，用六个元素初始化它;修剪最后一个元素;删除第四个元素;然后修剪最后两个元素 - 其中一个是删除的第四个元素。<code class="codeph">print_nt</code>在初始化之后和<code class="codeph">TRIM</code>和<code class="codeph">DELETE</code>操作之后打印嵌套表变量。类型<code class="codeph">nt_type</code>和过程<code class="codeph">print_nt</code>在<a href="plsql-collections-and-records.html#GUID-5ADB7EE2-71F6-4172-ACD8-FFDCF2787A37__CIHDEIIG">例5-6</a>中定义。
                        </p><pre class="oac_no_warn" dir="ltr">DECLARE nt nt_type：= nt_type（11,22,33,44,55,66）; BEGIN print_nt（nt）; <span class="bold">NT。修剪; - 修剪最后一个元素</span> print_nt（nt）; <span class="bold">NT。DELETE（4）; - 删除第四个元素</span> print_nt（nt）; <span class="bold">NT。TRIM（2）; - 修剪最后两个元素</span> print_nt（nt）;结束; /</pre><p>结果：</p><pre class="oac_no_warn" dir="ltr">NT（1）= 11 nt。（2）= 22 nt。（3）= 33 nt。（4）= 44 nt。（5）= 55 nt。（6）= 66 --- nt。（1）= 11 nt。（2）= 22 nt。（3）= 33 nt。（4）= 44 nt。（5）= 55 --- nt。（1）= 11 nt。（2）= 22 nt。（3）= 33 nt。（5）= 55 --- nt。（1）= 11 nt。（2）= 22 nt。（3）= 33 ---</pre></div>
                     <!-- class="example" -->
                  </div>
               </div><a id="LNPLS479"></a><a id="LNPLS99963"></a><div class="props_rev_3"><a id="GUID-03F74821-BC33-4544-9304-5FBBE6EFE450" name="GUID-03F74821-BC33-4544-9304-5FBBE6EFE450"></a><h4 id="LNPLS-GUID-03F74821-BC33-4544-9304-5FBBE6EFE450" class="sect4"><span class="enumeration_section">5.10.3</span> EXTEND收集方法</h4>
                  <div>
                     <p><code class="codeph">EXTEND</code>是一个向varray或嵌套表的末尾添加元素的过程。
                     </p>
                     <p>该集合可以为空，但不为空。（要使集合为空或将元素添加到空集合，请使用构造函数。有关更多信息，请参阅<span class="q">“ <a href="plsql-collections-and-records.html#GUID-92967CC1-481E-472A-BB4C-90C60F75296D" title="集合构造函数（构造函数）是系统定义的函数，其名称与集合类型相同，后者返回该类型的集合。">集合构造函数</a> ”</span> 。）
                     </p>
                     <p><code class="codeph">EXTEND</code>方法有以下形式：</p>
                     <ul style="list-style-type:disc">
                        <li>
                           <p><code class="codeph">EXTEND</code>将一个null元素附加到集合中。
                           </p>
                        </li>
                        <li>
                           <p><code class="codeph">EXTEND(</code> <span class="italic"><code class="codeph">n</code></span> <code class="codeph">)</code>将<span class="italic">n个</span> null元素追加到集合中。
                           </p>
                        </li>
                        <li>
                           <p><code class="codeph">EXTEND(</code> <span class="italic"><code class="codeph">n</code></span> ， <span class="italic"><code class="codeph">i</code></span> <code class="codeph">)</code>将第<span class="italic">i</span>个元素的<span class="italic">n个</span>副本附加到集合中。
                           </p>
                           <div class="infoboxnote" id="GUID-03F74821-BC33-4544-9304-5FBBE6EFE450__GUID-3C462AE3-0B51-43F2-9969-BF9D747ACA66">
                              <p class="notep1">注意：</p>
                              <p><code class="codeph">EXTEND(</code> <span class="italic"><code class="codeph">n</code></span> ， <span class="italic"><code class="codeph">i</code></span> <code class="codeph">)</code>是唯一可用于其元素具有<code class="codeph">NOT</code> <code class="codeph">NULL</code>约束的集合的形式。
                              </p>
                           </div>
                        </li>
                     </ul>
                     <p><code class="codeph">EXTEND</code>根据集合的内部大小进行操作。也就是说，如果<code class="codeph">DELETE</code>删除元素但为其保留占位符，则<code class="codeph">EXTEND</code>认为该元素存在。
                     </p>
                     <div class="example" id="GUID-03F74821-BC33-4544-9304-5FBBE6EFE450__BABBGAIB">
                        <p class="titleinexample">示例5-22具有嵌套表的EXTEND方法</p>
                        <p>这个例子声明了一个嵌套的表变量，用三个元素初始化它;附加第一个元素的两个副本;删除第五个（最后一个）元素;然后附加一个null元素。因为<code class="codeph">EXTEND</code>认为删除的第五个元素存在，所以附加的null元素是第六个元素。<code class="codeph">print_nt</code>在初始化之后和<code class="codeph">EXTEND</code>和<code class="codeph">DELETE</code>操作之后打印嵌套表变量。类型<code class="codeph">nt_type</code>和过程<code class="codeph">print_nt</code>在<a href="plsql-collections-and-records.html#GUID-5ADB7EE2-71F6-4172-ACD8-FFDCF2787A37__CIHDEIIG">例5-6</a>中定义。
                        </p><pre class="oac_no_warn" dir="ltr">DECLARE nt nt_type：= nt_type（11,22,33）; BEGIN print_nt（nt）; <span class="bold">NT。EXTEND（2,1）; - 附加第一个元素</span> print_nt（nt）的两个副本</span> ; <span class="bold">NT。（5）DELETE; - 删除第五个元素</span> print_nt（nt）; <span class="bold">NT。延伸; - 追加一个空元素</span> print_nt（nt）;结束; /</pre><p>结果：</p><pre class="oac_no_warn" dir="ltr">NT（1）= 11 nt。（2）= 22 nt。（3）= 33 --- nt。（1）= 11 nt。（2）= 22 nt。（3）= 33 nt。（4）= 11 nt。（5）= 11 --- nt。（1）= 11 nt。（2）= 22 nt。（3）= 33 nt。（4）= 11 --- nt。（1）= 11 nt。（2）= 22 nt。（3）= 33 nt。（4）= 11 <span class="bold">nt。（6）= NULL</span> ---</pre></div>
                     <!-- class="example" -->
                  </div>
               </div><a id="LNPLS473"></a><a id="LNPLS99968"></a><div class="props_rev_3"><a id="GUID-31E27176-042B-4BA8-8FBC-14CCEDC33095" name="GUID-31E27176-042B-4BA8-8FBC-14CCEDC33095"></a><h4 id="LNPLS-GUID-31E27176-042B-4BA8-8FBC-14CCEDC33095" class="sect4"><span class="enumeration_section">5.10.4</span> EXISTS收集方法</h4>
                  <div>
                     <p><code class="codeph">EXISTS</code>是一个函数，它告诉您是否存在varray或嵌套表的指定元素。
                     </p>
                     <p>如果集合的第<span class="italic">n</span>个元素存在，则<code class="codeph">EXISTS(</code> <span class="italic"><code class="codeph">n</code></span> <code class="codeph">)</code>返回<code class="codeph">TRUE</code>否则返回<code class="codeph">FALSE</code> 。如果<span class="italic">n</span>超出范围，则<code class="codeph">EXISTS</code>返回<code class="codeph">FALSE</code>而不是引发预定义的异常<code class="codeph">SUBSCRIPT_OUTSIDE_LIMIT</code> 。</p>
                     <p>对于已删除的元素， <code class="codeph">EXISTS(</code> <span class="italic"><code class="codeph">n</code></span> <code class="codeph">)</code>返回<code class="codeph">FALSE</code> ，即使<code class="codeph">DELETE</code>为其保留了占位符。
                     </p>
                     <div class="example" id="GUID-31E27176-042B-4BA8-8FBC-14CCEDC33095__BABEDEGG">
                        <p class="titleinexample">示例5-23使用嵌套表的EXISTS方法</p>
                        <p>此示例使用四个元素初始化嵌套表，删除第二个元素，并打印元素1到6的值或状态。</p><pre class="oac_no_warn" dir="ltr">DECLARE TYPE NumList IS TABLE of INTEGER; n NumList：= NumList（1,3,5,7）; <span class="bold">BEGINñ。DELETE（2）; - 删除第二个元素</span> FOR i IN 1..6 LOOP IF <span class="bold">n。EXISTS（i）</span>那么DBMS_OUTPUT.PUT_LINE（'n（'|| i ||'）='|| n（i））; ELSE DBMS_OUTPUT.PUT_LINE（'n（'|| i ||'）不存在'）;万一;结束循环;结束; /</pre><p>结果：</p><pre class="oac_no_warn" dir="ltr">n（1）= 1 n（2）不存在n（3）= 5 n（4）= 7 n（5）不存在n（6）不存在</pre></div>
                     <!-- class="example" -->
                  </div>
               </div><a id="LNPLS380"></a><a id="LNPLS99965"></a><div class="props_rev_3"><a id="GUID-33E18BC6-C0A8-456B-A47C-A4504240D962" name="GUID-33E18BC6-C0A8-456B-A47C-A4504240D962"></a><h4 id="LNPLS-GUID-33E18BC6-C0A8-456B-A47C-A4504240D962" class="sect4"><span class="enumeration_section">5.10.5</span>第一和最后的收集方法</h4>
                  <div>
                     <p><code class="codeph">FIRST</code>和<code class="codeph">LAST</code>是功能。
                     </p>
                     <p>如果集合至少有一个元素， <code class="codeph">FIRST</code>和<code class="codeph">LAST</code>返回第一个和最后一个元素的索引（忽略已删除的元素，即使<code class="codeph">DELETE</code>为它们保留了占位符）。如果集合只有一个元素，则<code class="codeph">FIRST</code>和<code class="codeph">LAST</code>返回相同的索引。如果集合为空，则<code class="codeph">FIRST</code>和<code class="codeph">LAST</code>返回<code class="codeph">NULL</code> 。</p>
                     <div class="section">
                        <p class="subhead3" id="GUID-33E18BC6-C0A8-456B-A47C-A4504240D962__GUID-03128B1D-FCCA-4D20-8731-DA8F083D2938">话题</p>
                     </div>
                     <!-- class="section" -->
                     <div class="section">
                        <ul style="list-style-type:disc">
                           <li>
                              <p><a href="plsql-collections-and-records.html#GUID-196DF6BC-1D81-4E87-92D7-CFB36BC302C8" title="对于由PLS_INTEGER索引的关联数组，第一个和最后一个元素分别是具有最小和最大索引的元素。对于由string索引的关联数组，第一个和最后一个元素分别是具有最低和最高键值的元素。">关联数组的第一种和最后一种方法</a></p>
                           </li>
                           <li>
                              <p><a href="plsql-collections-and-records.html#GUID-482AC3AD-F1E4-41D7-BCE3-494820E68089" title="对于非空的varray，FIRST始终返回1。对于每个varray，LAST总是等于COUNT。">Varray的第一种和最后一种方法</a></p>
                           </li>
                           <li>
                              <p><a href="plsql-collections-and-records.html#GUID-2F37AF8D-E7C7-4939-AE47-6EC1D88413F2" title="对于嵌套表，除非从中间删除元素，否则LAST等于COUNT，在这种情况下，LAST大于COUNT。">嵌套表的第一个和最后一个方法</a></p>
                           </li>
                        </ul>
                     </div>
                     <!-- class="section" -->
                  </div><a id="LNPLS382"></a><a id="LNPLS383"></a><a id="LNPLS381"></a><div class="props_rev_3"><a id="GUID-196DF6BC-1D81-4E87-92D7-CFB36BC302C8" name="GUID-196DF6BC-1D81-4E87-92D7-CFB36BC302C8"></a><h5 id="LNPLS-GUID-196DF6BC-1D81-4E87-92D7-CFB36BC302C8" class="sect5"><span class="enumeration_section">5.10.5.1</span>关联数组的第一种和最后一种方法</h5>
                     <div>
                        <p>对于由<code class="codeph">PLS_INTEGER</code>索引的关联数组，第一个和最后一个元素分别是具有最小和最大索引的元素。对于由string索引的关联数组，第一个和最后一个元素分别是具有最低和最高键值的元素。
                        </p>
                        <p>键值按排序顺序排列（有关详细信息，请参阅<span class="q">“ <a href="plsql-collections-and-records.html#GUID-8453D24B-DBF3-4127-AD42-88D49F3DBC26" title="国家语言支持（NLS）参数（如NLS_SORT，NLS_COMP和NLS_DATE_FORMAT）会影响由字符串索引的关联数组。">NLS参数值影响由字符串索引的关联数组</a> ”</span> ）。
                        </p>
                        <div class="example" id="GUID-196DF6BC-1D81-4E87-92D7-CFB36BC302C8__CIHCAHDE">
                           <p class="titleinexample">示例5-24由PLS_INTEGER索引的关联数组的第一个和最后一个值</p>
                           <p>此示例显示由<code class="codeph">PLS_INTEGER</code>索引的关联数组的<code class="codeph">FIRST</code>和<code class="codeph">LAST</code>值，删除第一个和最后一个元素，并再次显示<code class="codeph">FIRST</code>和<code class="codeph">LAST</code>的值。
                           </p><pre class="oac_no_warn" dir="ltr">DECLARE TYPE aa_type_int是PLS_INTEGER的INTEGER INDEX表; aa_int aa_type_int;程序print_first_and_last IS BEGIN DBMS_OUTPUT.PUT_LINE（'FIRST ='|| <span class="bold">aa_int。第一</span> ）; DBMS_OUTPUT.PUT_LINE（'LAST ='|| <span class="bold">aa_int。最后</span> ）; END print_first_and_last; BEGIN aa_int（1）：= 3; aa_int（2）：= 6; aa_int（3）：= 9; aa_int（4）：= 12; DBMS_OUTPUT.PUT_LINE（'删除之前：'）; print_first_and_last; <span class="bold">aa_int。DELETE（1）;</span> <span class="bold">aa_int。DELETE（4）;</span> DBMS_OUTPUT.PUT_LINE（'删除后：'）; print_first_and_last;结束; /</pre><p>结果：</p><pre class="oac_no_warn" dir="ltr">删除前：FIRST = 1 LAST = 4删除后：FIRST = 2 LAST = 3</pre></div>
                        <!-- class="example" -->
                        <div class="example" id="GUID-196DF6BC-1D81-4E87-92D7-CFB36BC302C8__CIHFDDDJ">
                           <p class="titleinexample">示例5-25由String索引的关联数组的FIRST和LAST值</p>
                           <p>此示例显示由string索引的关联数组的<code class="codeph">FIRST</code>和<code class="codeph">LAST</code>值，删除第一个和最后一个元素，并再次显示<code class="codeph">FIRST</code>和<code class="codeph">LAST</code>的值。
                           </p><pre class="oac_no_warn" dir="ltr">DECLARE TYPE aa_type_str是VARCHAR2的整数索引表（10）; aa_str aa_type_str;程序print_first_and_last是BEGIN DBMS_OUTPUT.PUT_LINE（'FIRST ='|| <span class="bold">aa_str。第一</span> ）; DBMS_OUTPUT.PUT_LINE（'LAST ='|| <span class="bold">aa_str。最后</span> ）; END print_first_and_last; BEGIN aa_str（'Z'）：= 26; aa_str（'A'）：= 1; aa_str（'K'）：= 11; aa_str（'R'）：= 18; DBMS_OUTPUT.PUT_LINE（'删除之前：'）; print_first_and_last; <span class="bold">aa_str。DELETE（ 'A'）;</span> <span class="bold">aa_str。DELETE（ 'Z'）;</span> DBMS_OUTPUT.PUT_LINE（'删除后：'）; print_first_and_last;结束; /</pre><p>结果：</p><pre class="oac_no_warn" dir="ltr">删除前：FIRST = A LAST = Z删除后：FIRST = K LAST = R.</pre></div>
                        <!-- class="example" -->
                     </div>
                  </div><a id="LNPLS385"></a><a id="LNPLS384"></a><div class="props_rev_3"><a id="GUID-482AC3AD-F1E4-41D7-BCE3-494820E68089" name="GUID-482AC3AD-F1E4-41D7-BCE3-494820E68089"></a><h5 id="LNPLS-GUID-482AC3AD-F1E4-41D7-BCE3-494820E68089" class="sect5"><span class="enumeration_section">5.10.5.2</span> Varray的第一种和最后一种方法</h5>
                     <div>
                        <p>对于非空的varray， <code class="codeph">FIRST</code>始终返回1。对于每个varray， <code class="codeph">LAST</code>总是等于<code class="codeph">COUNT</code> 。</p>
                        <div class="example" id="GUID-482AC3AD-F1E4-41D7-BCE3-494820E68089__CIHHAEGC">
                           <p class="titleinexample">示例5-26在FOR LOOP中使用FIRST和LAST打印Varray</p>
                           <p>这个例子打印VARRAY <code class="codeph">team</code>使用<code class="codeph">FOR</code> <code class="codeph">LOOP</code>与边界声明<code class="codeph">team</code> 。<code class="codeph">FIRST</code>和<code class="codeph">team</code> 。<code class="codeph">LAST</code> 。因为varray总是密集的，所以循环内的<code class="codeph">team(i)</code>总是存在。
                           </p><pre class="oac_no_warn" dir="ltr">DECLARE TYPE team_type VAR VARARAY（4）OF VARCHAR2（15）; team team_type;程序print_team（标题VARCHAR2）是BEGIN DBMS_OUTPUT.PUT_LINE（标题）; IF团队是否为空DBMS_OUTPUT.PUT_LINE（'不存在'）; ELSIF <span class="bold">团队。第一个</span>是NULL，然后DBMS_OUTPUT.PUT_LINE（'没有成员'）; ELSE for i in <span class="bold">team。FIRST</span> .. <span class="bold">团队。最后的</span>循环DBMS_OUTPUT.PUT_LINE（i ||'。'|| team（i））;结束循环;万一; DBMS_OUTPUT.PUT_LINE（ '---'）;结束;打印print_team（'团队状态：'）; team：= team_type（）; - 团队资金，但没有人参与其中。print_team（'团队状态：'）; team：= team_type（'John'，'Mary'）; - 将2名成员加入团队。print_team（'初始团队：'）; team：= team_type（'Arun'，'Amitha'，'Allan'，'Mae'）; - 改变团队。print_team（'新团队：'）;结束; /</pre><p>结果：</p><pre class="oac_no_warn" dir="ltr">团队状态：不存在---团队状态：没有成员---初始团队：1。约翰2。玛丽---新团队：1。阿伦2。阿米塔3。艾伦4。Mae ---</pre></div>
                        <!-- class="example" -->
                        <div class="section">
                           <p class="subhead3" id="GUID-482AC3AD-F1E4-41D7-BCE3-494820E68089__GUID-322E1290-DD11-4D23-A92F-A4DE43AAD2AA">相关主题</p>
                           <ul style="list-style-type:disc">
                              <li>
                                 <p><a href="plsql-collections-and-records.html#GUID-972E0AC6-A5B2-40DF-BED4-8031E13C6758__CIHIHFGI">例5-28</a></p>
                              </li>
                           </ul>
                        </div>
                        <!-- class="section" -->
                     </div>
                  </div><a id="LNPLS397"></a><a id="LNPLS396"></a><div class="props_rev_3"><a id="GUID-2F37AF8D-E7C7-4939-AE47-6EC1D88413F2" name="GUID-2F37AF8D-E7C7-4939-AE47-6EC1D88413F2"></a><h5 id="LNPLS-GUID-2F37AF8D-E7C7-4939-AE47-6EC1D88413F2" class="sect5"><span class="enumeration_section">5.10.5.3</span>嵌套表的第一种和最后一种方法</h5>
                     <div>
                        <p>对于嵌套表，除非从中间删除元素，否则<code class="codeph">LAST</code>等于<code class="codeph">COUNT</code> ，在这种情况下， <code class="codeph">LAST</code>大于<code class="codeph">COUNT</code> 。</p>
                        <div class="example" id="GUID-2F37AF8D-E7C7-4939-AE47-6EC1D88413F2__CIHGFDJA">
                           <p class="titleinexample">示例5-27在FOR LOOP中使用FIRST和LAST打印嵌套表</p>
                           <p>这个例子打印嵌套表<code class="codeph">team</code>使用<code class="codeph">FOR</code> <code class="codeph">LOOP</code>与边界声明<code class="codeph">team</code> 。<code class="codeph">FIRST</code>和<code class="codeph">team</code> 。<code class="codeph">LAST</code> 。因为嵌套表可以是稀疏的，所以<code class="codeph">FOR</code> <code class="codeph">LOOP</code>语句仅在<code class="codeph">team</code>打印<code class="codeph">team(i)</code> 。<code class="codeph">EXISTS(i)</code>是<code class="codeph">TRUE</code> 。</p><pre class="oac_no_warn" dir="ltr">DECLARE TYPE team_type IS TABLE OF VARCHAR2（15）; team team_type;程序print_team（标题VARCHAR2）是BEGIN DBMS_OUTPUT.PUT_LINE（标题）; IF团队是否为空DBMS_OUTPUT.PUT_LINE（'不存在'）; ELSIF <span class="bold">团队。第一个</span>是NULL，然后DBMS_OUTPUT.PUT_LINE（'没有成员'）; ELSE for i in <span class="bold">team。FIRST</span> .. <span class="bold">团队。最后的</span>循环DBMS_OUTPUT.PUT（i ||'。“）; IF <span class="bold">团队。EXISTS（i）</span>那么DBMS_OUTPUT.PUT_LINE（团队（i））; ELSE DBMS_OUTPUT.PUT_LINE（'（被聘用）'）;万一;结束循环;万一; DBMS_OUTPUT.PUT_LINE（ '---'）;结束;打印print_team（'团队状态：'）; team：= team_type（）; - 团队资金，但没有人参与其中。print_team（'团队状态：'）; team：= team_type（'Arun'，'Amitha'，'Allan'，'Mae'）; - 添加成员。print_team（'初始团队：'）;球队。DELETE（2,3）; - 删除第2和第3个成员。print_team（'当前团队：'）;结束; /</pre><p>结果：</p><pre class="oac_no_warn" dir="ltr">团队状态：不存在---团队状态：没有成员---初始团队：1。阿伦2。阿米塔3。艾伦4。Mae ---现任队伍：1。Arun 2.（被录用）3。（被录用）4。Mae ---</pre></div>
                        <!-- class="example" -->
                        <div class="section">
                           <p class="subhead3" id="GUID-2F37AF8D-E7C7-4939-AE47-6EC1D88413F2__GUID-C577544A-DF6B-402D-A619-51E8736A8660">相关主题</p>
                           <ul style="list-style-type:disc">
                              <li>
                                 <p> <a href="plsql-collections-and-records.html#GUID-DD0E1FE1-ADF2-4ED4-A0C2-B8837ADDCD89__BABHFIGG">例5-29</a></p>
                              </li>
                           </ul>
                        </div>
                        <!-- class="section" -->
                     </div>
                  </div>
               </div><a id="LNPLS398"></a><a id="LNPLS99967"></a><div class="props_rev_3"><a id="GUID-5700158F-FF45-4964-89B3-1EF614BA3B7D" name="GUID-5700158F-FF45-4964-89B3-1EF614BA3B7D"></a><h4 id="LNPLS-GUID-5700158F-FF45-4964-89B3-1EF614BA3B7D" class="sect4"><span class="enumeration_section">5.10.6</span> COUNT个收集方法</h4>
                  <div>
                     <p><code class="codeph">COUNT</code>是一个返回集合中元素数量的函数（忽略已删除的元素，即使<code class="codeph">DELETE</code>为它们保留了占位符）。
                     </p>
                     <div class="section">
                        <p class="subhead3" id="GUID-5700158F-FF45-4964-89B3-1EF614BA3B7D__GUID-9D5925D4-977E-4259-92B7-8423CCBB32B9">话题</p>
                     </div>
                     <!-- class="section" -->
                     <div class="section">
                        <ul style="list-style-type:disc">
                           <li>
                              <p><a href="plsql-collections-and-records.html#GUID-972E0AC6-A5B2-40DF-BED4-8031E13C6758" title="对于varray，COUNT总是等于LAST。如果增加或减少varray的大小（使用EXTEND或TRIM方法），则COUNT的值会更改。">Varray的COUNT方法</a></p>
                           </li>
                           <li>
                              <p><a href="plsql-collections-and-records.html#GUID-DD0E1FE1-ADF2-4ED4-A0C2-B8837ADDCD89" title="对于嵌套表，COUNT等于LAST，除非您从嵌套表的中间删除元素，在这种情况下COUNT小于LAST。">嵌套表的COUNT方法</a></p>
                           </li>
                        </ul>
                     </div>
                     <!-- class="section" -->
                  </div><a id="LNPLS403"></a><a id="LNPLS401"></a><div class="props_rev_3"><a id="GUID-972E0AC6-A5B2-40DF-BED4-8031E13C6758" name="GUID-972E0AC6-A5B2-40DF-BED4-8031E13C6758"></a><h5 id="LNPLS-GUID-972E0AC6-A5B2-40DF-BED4-8031E13C6758" class="sect5"><span class="enumeration_section">5.10.6.1</span> Varray的COUNT方法</h5>
                     <div>
                        <p>对于varray， <code class="codeph">COUNT</code>总是等于<code class="codeph">LAST</code> 。如果增加或减少varray的大小（使用<code class="codeph">EXTEND</code>或<code class="codeph">TRIM</code>方法），则<code class="codeph">COUNT</code>的值会更改。
                        </p>
                        <div class="example" id="GUID-972E0AC6-A5B2-40DF-BED4-8031E13C6758__CIHIHFGI">
                           <p class="titleinexample">示例5-28 Varray的COUNT和LAST值</p>
                           <p>此示例显示在使用四个元素初始化后，在<code class="codeph">EXTEND(3)</code>之后和<code class="codeph">TRIM(5)</code>之后的varray的<code class="codeph">COUNT</code>和<code class="codeph">LAST</code>值。
                           </p><pre class="oac_no_warn" dir="ltr">DECLARE TYPE NumList IS VARRAY（10）OF INTEGER; n NumList：= NumList（1,3,5,7）;程序print_count_and_last IS BEGIN DBMS_OUTPUT.PUT（'n。COUNT ='|| <span class="bold">ñ。COUNT</span> || '，'）; DBMS_OUTPUT.PUT_LINE（'N。最后='|| <span class="bold">ñ。最后</span> ）; END print_count_and_last; BEGIN print_count_and_last; <span class="bold">ñ。（3）延伸;</span> print_count_and_last; <span class="bold">ñ。（5）TRIM;</span> print_count_and_last;结束; /</pre><p>结果：</p><pre class="oac_no_warn" dir="ltr">ñ。COUNT = 4，n。最后= 4 n。COUNT = 7，n。最后= 7 n。COUNT = 2，n。最后= 2</pre></div>
                        <!-- class="example" -->
                     </div>
                  </div><a id="LNPLS474"></a><a id="LNPLS405"></a><div class="props_rev_3"><a id="GUID-DD0E1FE1-ADF2-4ED4-A0C2-B8837ADDCD89" name="GUID-DD0E1FE1-ADF2-4ED4-A0C2-B8837ADDCD89"></a><h5 id="LNPLS-GUID-DD0E1FE1-ADF2-4ED4-A0C2-B8837ADDCD89" class="sect5"><span class="enumeration_section">5.10.6.2</span>嵌套表的COUNT方法</h5>
                     <div>
                        <p>对于嵌套表， <code class="codeph">COUNT</code>等于<code class="codeph">LAST</code>除非您从嵌套表的中间删除元素，在这种情况下<code class="codeph">COUNT</code>小于<code class="codeph">LAST</code> 。</p>
                        <div class="example" id="GUID-DD0E1FE1-ADF2-4ED4-A0C2-B8837ADDCD89__BABHFIGG">
                           <p class="titleinexample">示例5-29嵌套表的COUNT和LAST值</p>
                           <p>此示例显示了在使用四个元素进行初始化之后嵌套表的<code class="codeph">COUNT</code>和<code class="codeph">LAST</code>值，删除第三个元素之后，以及在末尾添加两个null元素之后的值。最后，该示例打印元素1到8的状态。
                           </p><pre class="oac_no_warn" dir="ltr">DECLARE TYPE NumList IS TABLE of INTEGER; n NumList：= NumList（1,3,5,7）;程序print_count_and_last IS BEGIN DBMS_OUTPUT.PUT（'n。COUNT ='|| <span class="bold">ñ。COUNT</span> || '，'）; DBMS_OUTPUT.PUT_LINE（'N。最后='|| <span class="bold">ñ。最后</span> ）; END print_count_and_last; BEGIN print_count_and_last; <span class="bold">ñ。DELETE（3）;</span> - 删除第三个元素print_count_and_last; <span class="bold">ñ。（2）延伸;</span> - 添加两个null元素以结束print_count_and_last; FOR i IN 1..8 LOOP IF <span class="bold">n。EXISTS（i）</span>那么如果n（i）不是NULL，那么DBMS_OUTPUT.PUT_LINE（'n（'|| i ||'）='|| n（i））; ELSE DBMS_OUTPUT.PUT_LINE（'n（'|| i ||'）= NULL'）;万一; ELSE DBMS_OUTPUT.PUT_LINE（'n（'|| i ||'）不存在'）;万一;结束循环;结束; /</pre><p>结果：</p><pre class="oac_no_warn" dir="ltr">ñ。COUNT = 4，n。最后= 4 n。COUNT = 3，n。最后= 4 n。COUNT = 5，n。最后= 6 n（1）= 1 n（2）= 3 n（3）不存在n（4）= 7 n（5）= NULL n（6）= NULL n（7）不存在n（8） ） 不存在</pre></div>
                        <!-- class="example" -->
                     </div>
                  </div>
               </div><a id="LNPLS475"></a><a id="LNPLS99966"></a><div class="props_rev_3"><a id="GUID-1E0E1010-FFC5-4F4A-AD87-58BE9CE8146D" name="GUID-1E0E1010-FFC5-4F4A-AD87-58BE9CE8146D"></a><h4 id="LNPLS-GUID-1E0E1010-FFC5-4F4A-AD87-58BE9CE8146D" class="sect4"><span class="enumeration_section">5.10.7</span>限制收集方法</h4>
                  <div>
                     <p><code class="codeph">LIMIT</code>是一个函数，它返回集合可以拥有的最大元素数。如果集合没有最大元素数， <code class="codeph">LIMIT</code>将返回<code class="codeph">NULL</code> 。只有varray具有最大尺寸。
                     </p>
                     <div class="example" id="GUID-1E0E1010-FFC5-4F4A-AD87-58BE9CE8146D__BABFCAGJ">
                        <p class="titleinexample">示例5-30不同集合类型的LIMIT和COUNT值</p>
                        <p>此示例为具有四个元素的关联数组打印<code class="codeph">LIMIT</code>和<code class="codeph">COUNT</code>的值，具有两个元素的varray和具有三个元素的嵌套表。
                        </p><pre class="oac_no_warn" dir="ltr">DECLARE TYPE aa_type是PLS_INTEGER的INTEGER INDEX表; aa aa_type; - 关联数组TYPE va_type IS VARRAY（4）OF INTEGER; va va_type：= va_type（2,4）; -  varray TYPE nt_type IS TABLE of INTEGER; nt nt_type：= nt_type（1,3,5）; - 嵌套表BEGIN aa（1）：= 3; AA（2）：= 6; AA（3）：= 9; aa（4）：= 12; DBMS_OUTPUT.PUT（'AA。COUNT ='）; DBMS_OUTPUT.PUT_LINE（NVL（TO_CHAR（ <span class="bold">aa。COUNT</span> ），'NULL'））; DBMS_OUTPUT.PUT（'AA。LIMIT ='）; DBMS_OUTPUT.PUT_LINE（NVL（TO_CHAR（ <span class="bold">aa。LIMIT</span> ），'NULL'））; DBMS_OUTPUT.PUT（“VA。COUNT ='）; DBMS_OUTPUT.PUT_LINE（NVL（TO_CHAR（ <span class="bold">va。COUNT</span> ），'NULL'））; DBMS_OUTPUT.PUT（“VA。LIMIT ='）; DBMS_OUTPUT.PUT_LINE（NVL（TO_CHAR（ <span class="bold">va。LIMIT</span> ），'NULL'））; DBMS_OUTPUT.PUT（'NT。COUNT ='）; DBMS_OUTPUT.PUT_LINE（NVL（TO_CHAR（ <span class="bold">nt。COUNT</span> ），'NULL'））; DBMS_OUTPUT.PUT（'NT。LIMIT ='）; DBMS_OUTPUT.PUT_LINE（NVL（TO_CHAR（ <span class="bold">nt。LIMIT</span> ），'NULL'））;结束; /</pre><p>结果：</p><pre class="oac_no_warn" dir="ltr">AA。COUNT = 4 aa。LIMIT = NULL va。COUNT = 2 va。LIMIT = 4 nt。COUNT = 3 nt。LIMIT = NULL</pre></div>
                     <!-- class="example" -->
                  </div>
               </div><a id="LNPLS407"></a><a id="LNPLS478"></a><a id="LNPLS99964"></a><div class="props_rev_3"><a id="GUID-FB1216B3-2DC3-48D6-BCEC-243F995BFB09" name="GUID-FB1216B3-2DC3-48D6-BCEC-243F995BFB09"></a><h4 id="LNPLS-GUID-FB1216B3-2DC3-48D6-BCEC-243F995BFB09" class="sect4"><span class="enumeration_section">5.10.8</span> PRIOR和NEXT收集方法</h4>
                  <div>
                     <p><code class="codeph">PRIOR</code>和<code class="codeph">NEXT</code>是允许您在集合中前后移动的函数（忽略已删除的元素，即使<code class="codeph">DELETE</code>为它们保留了占位符）。这些方法对于遍历稀疏集合很有用。
                     </p>
                     <p>鉴于一个指数：</p>
                     <ul style="list-style-type:disc">
                        <li>
                           <p><code class="codeph">PRIOR</code>返回集合的前一个现有元素的索引（如果存在）。否则， <code class="codeph">PRIOR</code>返回<code class="codeph">NULL</code> 。</p>
                           <p>对于任何集合<code class="codeph">c</code> ， <code class="codeph">c.PRIOR（C。FIRST)</code>返回<code class="codeph">NULL</code> 。</p>
                        </li>
                        <li>
                           <p><code class="codeph">NEXT</code>返回集合的后续现有元素的索引（如果存在）。否则， <code class="codeph">NEXT</code>返回<code class="codeph">NULL</code> 。</p>
                           <p>对于任何集合<code class="codeph">c</code> ， <code class="codeph">c.NEXT（C。LAST)</code>返回<code class="codeph">NULL</code> 。</p>
                        </li>
                     </ul>
                     <p>给定的索引不需要存在。但是，如果集合<code class="codeph">c</code>是varray，并且索引超过<code class="codeph">c.LIMIT</code> ，然后：</p>
                     <ul style="list-style-type:disc">
                        <li>
                           <p><code class="codeph">C。PRIOR(</code> <span class="italic"><code class="codeph">index</code></span> <code class="codeph">)</code>返回<code class="codeph">c.LAST</code> 。</p>
                        </li>
                        <li>
                           <p><code class="codeph">C。NEXT(</code> <span class="italic"><code class="codeph">index</code></span> <code class="codeph">)</code>返回<code class="codeph">NULL</code> 。</p>
                        </li>
                     </ul>
                     <p>例如：</p><pre class="oac_no_warn" dir="ltr">DECLARE TYPE Arr_Type IS VARRAY（10）OF NUMBER; v_Numbers Arr_Type：= Arr_Type（）; BEGIN v_Numbers。（4）延伸; v_Numbers（1）：= 10; v_Numbers（2）：= 20; v_Numbers（3）：= 30; v_Numbers（4）：= 40; DBMS_OUTPUT.PUT_LINE（NVL（v_Numbers.prior（3400）， -  1））; DBMS_OUTPUT.PUT_LINE（NVL（v_Numbers.next（3400）， -  1））;结束; /</pre><p>结果：</p><pre class="oac_no_warn" dir="ltr">4 -1</pre><p>对于由string索引的关联数组，先前和下一个索引由键值确定，键值按排序顺序排列（有关更多信息，请参阅<span class="q">“ <a href="plsql-collections-and-records.html#GUID-8453D24B-DBF3-4127-AD42-88D49F3DBC26" title="国家语言支持（NLS）参数（如NLS_SORT，NLS_COMP和NLS_DATE_FORMAT）会影响由字符串索引的关联数组。">NLS参数值影响由字符串索引的关联数组</a> ”</span> ）。<a href="plsql-collections-and-records.html#GUID-8060F01F-B53B-48D4-9239-7EA8461C2170__BABHGFHJ">例5-1</a>使用<code class="codeph">FIRST</code> ， <code class="codeph">NEXT</code>和<code class="codeph">WHILE</code> <code class="codeph">LOOP</code>语句来打印关联数组的元素。
                     </p>
                     <div class="example" id="GUID-FB1216B3-2DC3-48D6-BCEC-243F995BFB09__CIHHHICG">
                        <p class="titleinexample">例5-31 PRIOR和NEXT方法</p>
                        <p>此示例使用六个元素初始化嵌套表，删除第四个元素，然后显示元素1到7的<code class="codeph">PRIOR</code>和<code class="codeph">NEXT</code>的值。元素4和7不存在。元素2存在，尽管它的值为null。
                        </p><pre class="oac_no_warn" dir="ltr">DECLARE TYPE nt_type是数字表; nt nt_type：= nt_type（18，NULL，36,45,54,63）; BEGIN <span class="bold">nt。DELETE（4）;</span> DBMS_OUTPUT.PUT_LINE（'nt（4）已删除。“）; FOR i IN 1..7 LOOP DBMS_OUTPUT.PUT（'nt。PRIOR（'|| i ||'）='）; DBMS_OUTPUT.PUT_LINE（NVL（TO_CHAR（ <span class="bold">nt。PRIOR（i）</span> ），'NULL'））; DBMS_OUTPUT.PUT（'NT。NEXT（'|| i ||'）='）; DBMS_OUTPUT.PUT_LINE（NVL（TO_CHAR（ <span class="bold">nt。NEXT（i）</span> ），'NULL'））;结束循环;结束; /</pre><p>结果：</p><pre class="oac_no_warn" dir="ltr">nt（4）已删除。NT。PRIOR（1）= NULL nt。NEXT（1）= 2 nt。PRIOR（2）= 1 nt。NEXT（2）= 3 nt。先前（3）= 2 nt。NEXT（3）= 5 nt。PRIOR（4）= 3 nt。NEXT（4）= 5 nt。先前（5）= 3 nt。NEXT（5）= 6 nt。先前（6）= 5 nt。NEXT（6）= NULL nt。PRIOR（7）= 6 nt。NEXT（7）= NULL</pre></div>
                     <!-- class="example" -->
                     <div class="example" id="GUID-FB1216B3-2DC3-48D6-BCEC-243F995BFB09__BEIBJDBF">
                        <p class="titleinexample">例5-32稀疏嵌套表的打印元素</p>
                        <p>此示例使用<code class="codeph">FIRST</code>和<code class="codeph">NEXT</code>以及从最后到第一个使用<code class="codeph">LAST</code>和<code class="codeph">PRIOR</code>打印稀疏嵌套表的元素。</p><pre class="oac_no_warn" dir="ltr">DECLARE TYPE NumList是数字表; n NumList：= NumList（1,2，NULL，NULL，5，NULL，7,8,9，NULL）; idx INTEGER; BEGIN DBMS_OUTPUT.PUT_LINE（'First to last：'）; idx：= <span class="bold">n。第一</span> ; WHILE idx IS NOT NULL LOOP DBMS_OUTPUT.PUT（'n（'|| idx ||'）='）; DBMS_OUTPUT.PUT_LINE（NVL（TO_CHAR（n（idx）），'NULL'））; idx：= <span class="bold">n。下一个（idx）</span> ;结束循环; DBMS_OUTPUT.PUT_LINE（ '--------------'）; DBMS_OUTPUT.PUT_LINE（'Last to first：'）; idx：= <span class="bold">n。最后</span> ; WHILE idx IS NOT NULL LOOP DBMS_OUTPUT.PUT（'n（'|| idx ||'）='）; DBMS_OUTPUT.PUT_LINE（NVL（TO_CHAR（n（idx）），'NULL'））; idx：= <span class="bold">n。PRIOR（idx）</span> ;结束循环;结束; /</pre><p>结果：</p><pre class="oac_no_warn" dir="ltr">从头到尾：n（1）= 1 n（2）= 2 n（3）= NULL n（4）= NULL n（5）= 5 n（6）= NULL n（7）= 7 n（8） = 8 n（9）= 9 n（10）= NULL -------------- Last to first：n（10）= NULL n（9）= 9 n（8）= 8 n（7）= 7 n（6）= NULL n（5）= 5 n（4）= NULL n（3）= NULL n（2）= 2 n（1）= 1</pre></div>
                     <!-- class="example" -->
                  </div>
               </div>
            </div><a id="LNPLS486"></a><a id="LNPLS408"></a><a id="LNPLS00511"></a><div class="props_rev_3"><a id="GUID-7C84EBD2-D0A5-4126-8EB7-FF9243EE5B47" name="GUID-7C84EBD2-D0A5-4126-8EB7-FF9243EE5B47"></a><h3 id="LNPLS-GUID-7C84EBD2-D0A5-4126-8EB7-FF9243EE5B47" class="sect3"><span class="enumeration_section">5.11</span>包装规格中定义的收集类型</h3>
               <div>
                  <p>包规范中定义的集合类型与相同定义的本地或独立集合类型不兼容。</p>
                  <div class="infoboxnote" id="GUID-7C84EBD2-D0A5-4126-8EB7-FF9243EE5B47__GUID-93F5F845-5596-4777-9650-D42E713F92E3">
                     <p class="notep1">注意：</p>
                     <p>本主题中的示例定义了包和过程，分别在<a href="plsql-packages.html#GUID-C285EC5A-BE50-4192-A88E-48C0778B34E0" title="本章介绍如何将相关的PL / SQL代码和数据捆绑到一个包中，其内容可供许多应用程序使用。">PL / SQL包</a>和<a href="plsql-subprograms.html#GUID-13BEBBEC-02D4-48E8-A059-DFEAC4751A3B" title="当PL / SQL函数具有RESULT_CACHE选项时，其结果将缓存在共享全局区域（SGA）中，因此连接到同一实例的会话可以在可用时重用这些结果。PL / SQL函数结果缓存与结果缓存共享其管理和可管理性基础结构。如果在DR单元（定义者权限单元）中包含已连接的用户数据库链接，则必须向将运行DR单元的用户授予INHERIT REMOTE PRIVILEGES权限。">PL / SQL子程序中</a>进行了说明。
                     </p>
                  </div>
                  <div class="example" id="GUID-7C84EBD2-D0A5-4126-8EB7-FF9243EE5B47__CHDIHDIJ">
                     <p class="titleinexample">例5-33相同定义的包和本地收集类型</p>
                     <p>在此示例中，包规范和匿名块以相同方式定义集合类型<code class="codeph">NumList</code> 。该包定义了一个过程<code class="codeph">print_numlist</code> ，它具有<code class="codeph">NumList</code>参数。匿名块声明了<code class="codeph">pkg.类型的变量<code class="codeph">n1</code> <code class="codeph">pkg.NumList</code> （在包中定义）和<code class="codeph">NumList</code>类型的变量<code class="codeph">n2</code> （在块中定义）。匿名块可以将<code class="codeph">n1</code>传递给<code class="codeph">print_numlist</code> ，但它不能将<code class="codeph">n2</code>传递给<code class="codeph">print_numlist</code> 。
                     </p>
                     <div class="infoboxnote" id="GUID-7C84EBD2-D0A5-4126-8EB7-FF9243EE5B47__GUID-052A4211-A3C9-40BC-BC7C-8EA1A5AA4F6C">
                        <p class="notep1">实时SQL：</p>
                        <p>您可以在<a href="https://livesql.oracle.com/apex/livesql/docs/lnpls/plsql-collections-and-records/tdlnplscomposites40err.html" target="_blank">相同定义的程序包和本地集合类型的</a> Oracle Live SQL上查看和运行此示例</p>
                     </div><pre class="oac_no_warn" dir="ltr">创建或替换包装pkg AS <span class="bold">TYPE NumList是数字表;</span> PROCEDURE print_numlist（nums NumList）;结束pkg; /创建或替换包装体pkg作为程序print_numlist（nums NumList）是我开始的。FIRST..nums。最后的循环DBMS_OUTPUT.PUT_LINE（nums（i））;结束循环;结束;结束pkg; / DECLARE <span class="bold">TYPE NumList是数字表; - 本地类型与包装类型</span> n1 pkg <span class="bold">相同</span> 。NumList：= pkg。NumList（2,4）; - 包类型n2 NumList：= NumList（6,8）; - 本地类型BEGIN pkg.print_numlist（n1）; - 成功<span class="bold">pkg.print_numlist（n2）; - 失败</span> END; /</pre><p>结果：</p><pre class="oac_no_warn" dir="ltr">pkg.print_numlist（N 2）; - 失败*第7行的错误：ORA-06550：第7行，第3列：PLS-00306：调用'PRINT_NUMLIST'ORA-06550时参数的数量或类型错误：第7行，第3列：PL / SQL：语句忽视</pre></div>
                  <!-- class="example" -->
                  <div class="example" id="GUID-7C84EBD2-D0A5-4126-8EB7-FF9243EE5B47__CIHBGBBH">
                     <p class="titleinexample">示例5-34相同定义的包和独立收集类型</p>
                     <p>此示例定义独立集合类型<code class="codeph">NumList</code> ，它与<a href="plsql-collections-and-records.html#GUID-7C84EBD2-D0A5-4126-8EB7-FF9243EE5B47__CHDIHDIJ">示例5-33</a>中的包规范中定义的集合类型<code class="codeph">NumList</code>相同。匿名块声明了<code class="codeph">pkg.类型的变量<code class="codeph">n1</code> <code class="codeph">pkg.NumList</code> （在包中定义）和独立类型<code class="codeph">NumList</code>的变量<code class="codeph">n2</code> 。匿名块可以将<code class="codeph">n1</code>传递给<code class="codeph">print_numlist</code> ，但它不能将<code class="codeph">n2</code>传递给<code class="codeph">print_numlist</code> 。
                     </p>
                     <div class="infoboxnote" id="GUID-7C84EBD2-D0A5-4126-8EB7-FF9243EE5B47__GUID-EA1DDCDE-E9A0-4B6E-9DF4-76BC998BBB60">
                        <p class="notep1">实时SQL：</p>
                        <p>您可以在<a href="https://livesql.oracle.com/apex/livesql/docs/lnpls/plsql-collections-and-records/tdlnplscomposites74err.html" target="_blank">相同定义的包和独立收集类型的</a> Oracle Live SQL上查看和运行此示例</p>
                     </div><pre class="oac_no_warn" dir="ltr"><span class="bold">创建或替换类型NumList IS TABLE OF OF NUMBER;</span> <span class="bold">- 与包装类型相同的独立收集类型</span> / DECLARE n1 pkg。NumList：= pkg。NumList（2,4）; - 包类型n2 NumList：= NumList（6,8）; - 独立类型BEGIN pkg.print_numlist（n1）; - 成功<span class="bold">pkg.print_numlist（n2）; - 失败</span> END; /</pre><p>结果：</p><pre class="oac_no_warn" dir="ltr">pkg.print_numlist（N 2）; - 失败*第7行的错误：ORA-06550：第7行，第3列：PLS-00306：调用'PRINT_NUMLIST'ORA-06550时参数的数量或类型错误：第7行，第3列：PL / SQL：语句忽视</pre></div>
                  <!-- class="example" -->
               </div>
            </div><a id="LNPLS417"></a><a id="LNPLS00509"></a><div class="props_rev_3"><a id="GUID-75875E26-FC7B-4513-A5E2-EDA26F1D67B1" name="GUID-75875E26-FC7B-4513-A5E2-EDA26F1D67B1"></a><h3 id="LNPLS-GUID-75875E26-FC7B-4513-A5E2-EDA26F1D67B1" class="sect3"><span class="enumeration_section">5.12</span>记录变量</h3>
               <div>
                  <p>您可以通过以下任何方式创建记录变量：</p>
                  <ul style="list-style-type:disc">
                     <li>
                        <p>定义<code class="codeph">RECORD</code>类型，然后声明该类型的变量。
                        </p>
                     </li>
                     <li>
                        <p>使用<code class="codeph">%ROWTYPE</code>声明一个记录变量，该变量表示数据库表或视图的完整行或部分行。
                        </p>
                     </li>
                     <li>
                        <p>使用<code class="codeph">%TYPE</code>声明与先前声明的记录变量相同类型的记录变量。
                        </p>
                     </li>
                  </ul>
                  <p>有关语法和语义，请参阅<span class="q">“ <a href="record-variable-declaration.html#GUID-704FC014-561E-422C-9636-EDCA3B996AAD" title="记录变量是一个复合变量，其内部组件（称为字段）可以具有不同的数据类型。记录变量的值及其字段的值可以更改。">记录变量声明</a> ”</span> 。
                  </p>
                  <div class="section">
                     <p class="subhead2" id="GUID-75875E26-FC7B-4513-A5E2-EDA26F1D67B1__GUID-10EB7748-AC4F-4461-89A6-CBFBCA49620D">话题</p>
                  </div>
                  <!-- class="section" -->
                  <div class="section">
                     <ul style="list-style-type:disc">
                        <li>
                           <p><a href="plsql-collections-and-records.html#GUID-AD93581B-6F16-4E84-9C05-30B251755782" title="对于RECORD类型的记录变量，除非在定义类型时为其指定不同的初始值，否则每个字段的初始值均为NULL。">记录变量的初始值</a></p>
                        </li>
                        <li>
                           <p><a href="plsql-collections-and-records.html#GUID-BB893086-90BC-4831-81E2-41B9C1AE68A8" title="声明记录常量时，必须创建一个用其初始值填充记录的函数，然后在常量声明中调用该函数。">声明记录常量</a></p>
                        </li>
                        <li>
                           <p><a href="plsql-collections-and-records.html#GUID-7DC81088-1265-4C46-A04D-E3AD10BCC04F">记录类型</a></p>
                        </li>
                        <li>
                           <p><a href="plsql-collections-and-records.html#GUID-EBF66B92-8A94-4E3A-A837-253D5DA79D5F" title="％ROWTYPE属性允许您声明一个记录变量，该变量表示数据库表或视图的完整行或部分行。">使用％ROWTYPE属性声明项目</a></p>
                        </li>
                     </ul>
                  </div>
                  <!-- class="section" -->
               </div><a id="LNPLS419"></a><div class="props_rev_3"><a id="GUID-AD93581B-6F16-4E84-9C05-30B251755782" name="GUID-AD93581B-6F16-4E84-9C05-30B251755782"></a><h4 id="LNPLS-GUID-AD93581B-6F16-4E84-9C05-30B251755782" class="sect4"><span class="enumeration_section">5.12.1</span>记录变量的初始值</h4>
                  <div>
                     <p>对于<code class="codeph">RECORD</code>类型的记录变量，除非在定义类型时为其指定不同的初始值，否则每个字段的初始值均为<code class="codeph">NULL</code> 。
                     </p>
                     <p>对于使用<code class="codeph">%ROWTYPE</code>或<code class="codeph">%TYPE</code>声明的记录变量，每个字段的初始值为<code class="codeph">NULL</code> 。变量不会继承引用项的初始值。
                     </p>
                  </div>
               </div><a id="LNPLS426"></a><a id="LNPLS99856"></a><div class="props_rev_3"><a id="GUID-BB893086-90BC-4831-81E2-41B9C1AE68A8" name="GUID-BB893086-90BC-4831-81E2-41B9C1AE68A8"></a><h4 id="LNPLS-GUID-BB893086-90BC-4831-81E2-41B9C1AE68A8" class="sect4"><span class="enumeration_section">5.12.2</span>声明记录常量</h4>
                  <div>
                     <p>声明记录常量时，必须创建一个用其初始值填充记录的函数，然后在常量声明中调用该函数。</p>
                     <div class="example" id="GUID-BB893086-90BC-4831-81E2-41B9C1AE68A8__BABCGFCE">
                        <p class="titleinexample">例5-35声明记录常量</p>
                        <p>此示例创建一个函数，该函数使用其初始值填充记录，然后在常量声明中调用该函数。</p>
                        <div class="infoboxnote" id="GUID-BB893086-90BC-4831-81E2-41B9C1AE68A8__GUID-F0637744-DA65-44DD-B8E5-226D68F8FE7C">
                           <p class="notep1">实时SQL：</p>
                           <p>您可以在<a href="https://livesql.oracle.com/apex/livesql/docs/lnpls/plsql-collections-and-records/tdlnplscomposites90.html" target="_blank">声明记录常量的</a> Oracle Live SQL上查看和运行此示例</p>
                        </div><pre class="oac_no_warn" dir="ltr">创建或替换包装My_Types AUTHID CURRENT_USER是类型My_Rec是记录（一个数字，一个数字）;功能Init_My_Rec返回My_Rec;结束My_Types; / CREATE OR REPLACE PACKAGE BODY My_Types IS <span class="bold">FUNCTION Init_My_Rec RETURN My_Rec IS</span> <span class="bold">Rec My_Rec;</span> <span class="bold">BEGIN</span> <span class="bold">Rec.a：= 0;</span> <span class="bold">Rec.b：= 1;</span> <span class="bold">返回Rec;</span> <span class="bold">END Init_My_Rec;</span>结束My_Types; / DECLARE <span class="bold">r CONSTANT My_Types。My_Rec：= My_Types。Init_My_Rec（）;</span> BEGIN DBMS_OUTPUT.PUT_LINE（'ra ='|| ra）; DBMS_OUTPUT.PUT_LINE（'rb ='|| rb）;结束; /</pre><p>结果：</p><pre class="oac_no_warn" dir="ltr">ra = 0 rb = 1 PL / SQL过程成功完成。</pre></div>
                     <!-- class="example" -->
                  </div>
               </div><a id="LNPLS427"></a><a id="LNPLS433"></a><a id="LNPLS439"></a><a id="LNPLS441"></a><a id="LNPLS99971"></a><div class="props_rev_3"><a id="GUID-7DC81088-1265-4C46-A04D-E3AD10BCC04F" name="GUID-7DC81088-1265-4C46-A04D-E3AD10BCC04F"></a><h4 id="LNPLS-GUID-7DC81088-1265-4C46-A04D-E3AD10BCC04F" class="sect4"><span class="enumeration_section">5.12.3</span>记录类型</h4>
                  <div>
                     <p>PL / SQL块中定义的<code class="codeph">RECORD</code>类型是<span class="bold">本地类型</span> 。它仅在块中可用，并且仅当块位于独立程序包或程序包子程序中时才存储在数据库中。
                     </p>
                     <p>包规范中定义的<code class="codeph">RECORD</code>类型是<span class="bold">公共项</span> 。您可以通过使用包名称（ <span class="italic"><code class="codeph">package_name.type_name</code></span> ）对其进行限定来从包外引用它。它将存储在数据库中，直到您使用<code class="codeph">DROP</code> <code class="codeph">PACKAGE</code>语句<code class="codeph">DROP</code> <code class="codeph">PACKAGE</code> 。
                     </p>
                     <p>您无法在架构级别创建<code class="codeph">RECORD</code>类型。因此， <code class="codeph">RECORD</code>类型不能是ADT属性数据类型。
                     </p>
                     <p>要定义<code class="codeph">RECORD</code>类型，请指定其名称并定义其字段。要定义字段，请指定其名称和数据类型。默认情况下，字段的初始值为<code class="codeph">NULL</code> 。您可以为字段指定<code class="codeph">NOT</code> <code class="codeph">NULL</code>约束，在这种情况下，还必须指定非<code class="codeph">NULL</code>初始值。如果没有<code class="codeph">NOT</code> <code class="codeph">NULL</code>约束，则非<code class="codeph">NULL</code>初始值是可选的。
                     </p>
                     <p>甲<code class="codeph">RECORD</code>在包规范中定义的类型是不兼容的与相同定义的局部<code class="codeph">RECORD</code>类型。
                     </p>
                     <div class="infoboxnotealso" id="GUID-7DC81088-1265-4C46-A04D-E3AD10BCC04F__GUID-06DEDBF8-F8E5-43D2-96FA-EAE7D433F380">
                        <p class="notep1">也可以看看：</p>
                        <ul style="list-style-type:disc">
                           <li>
                              <p><a href="plsql-packages.html#GUID-C285EC5A-BE50-4192-A88E-48C0778B34E0" title="本章介绍如何将相关的PL / SQL代码和数据捆绑到一个包中，其内容可供许多应用程序使用。">PL / SQL包</a></p>
                           </li>
                           <li>
                              <p><a href="plsql-subprograms.html#GUID-13BEBBEC-02D4-48E8-A059-DFEAC4751A3B" title="当PL / SQL函数具有RESULT_CACHE选项时，其结果将缓存在共享全局区域（SGA）中，因此连接到同一实例的会话可以在可用时重用这些结果。PL / SQL函数结果缓存与结果缓存共享其管理和可管理性基础结构。如果在DR单元（定义者权限单元）中包含已连接的用户数据库链接，则必须向将运行DR单元的用户授予INHERIT REMOTE PRIVILEGES权限。">PL / SQL子程序</a></p>
                           </li>
                           <li>
                              <p><a href="plsql-subprograms.html#GUID-E03F512B-1A30-43B4-8DCA-64DA68AE7CE4">嵌套，包和独立子程序</a></p>
                           </li>
                           <li>
                              <p><a href="plsql-collections-and-records.html#GUID-7DC81088-1265-4C46-A04D-E3AD10BCC04F__CIHFBIAF">例5-39</a> ， <span class="q">“”</span></p>
                           </li>
                        </ul>
                     </div>
                     <div class="example" id="GUID-7DC81088-1265-4C46-A04D-E3AD10BCC04F__CIHHBIDA">
                        <p class="titleinexample">例5-36 RECORD类型定义和变量声明</p>
                        <p>此示例定义名为<code class="codeph">DeptRecTyp</code>的<code class="codeph">RECORD</code>类型，指定每个字段的初始值。然后它声明一个名为<code class="codeph">dept_rec</code>类型的变量并打印其字段。
                        </p>
                        <div class="infoboxnote" id="GUID-7DC81088-1265-4C46-A04D-E3AD10BCC04F__GUID-7B368681-6234-47FB-81F9-3CEC4C078E1A">
                           <p class="notep1">实时SQL：</p>
                           <p>您可以在<a href="https://livesql.oracle.com/apex/livesql/docs/lnpls/plsql-collections-and-records/tdlnplscomposites76.html" target="_blank">RECORD类型定义和变量声明的</a> Oracle Live SQL上查看和运行此示例</p>
                        </div><pre class="oac_no_warn" dir="ltr">DECLARE TYPE DeptRecTyp是RECORD（dept_id NUMBER（4）NOT NULL：= 10，dept_name VARCHAR2（30）NOT NULL：='Administration'，mgr_id NUMBER（6）：= 200，loc_id NUMBER（4）：= 1700）; dept_rec DeptRecTyp; BEGIN DBMS_OUTPUT.PUT_LINE（'dept_id：'|| dept_rec.dept_id）; DBMS_OUTPUT.PUT_LINE（'dept_name：'|| dept_rec.dept_name）; DBMS_OUTPUT.PUT_LINE（'mgr_id：'|| dept_rec.mgr_id）; DBMS_OUTPUT.PUT_LINE（'loc_id：'|| dept_rec.loc_id）;结束; /</pre><p>结果：</p><pre class="oac_no_warn" dir="ltr">dept_id：10 dept_name：管理mgr_id：200 loc_id：1700</pre></div>
                     <!-- class="example" -->
                     <div class="example" id="GUID-7DC81088-1265-4C46-A04D-E3AD10BCC04F__CIHEGIFD">
                        <p class="titleinexample">例5-37包含RECORD字段的记录类型（嵌套记录）</p>
                        <p>此示例定义了两个<code class="codeph">RECORD</code>类型， <code class="codeph">name_rec</code>和<code class="codeph">contact</code> 。类型<code class="codeph">contact</code>具有<code class="codeph">name_rec</code>类型的<code class="codeph">name_rec</code> 。
                        </p>
                        <div class="infoboxnote" id="GUID-7DC81088-1265-4C46-A04D-E3AD10BCC04F__GUID-A4286E0A-9DD8-4E7C-9A1B-66906484BCDA">
                           <p class="notep1">实时SQL：</p>
                           <p>您可以在<a href="https://livesql.oracle.com/apex/livesql/docs/lnpls/plsql-collections-and-records/tdlnplscomposites77.html" target="_blank">带有RECORD字段的RECORD类型的</a> Oracle Live SQL上查看和运行此示例<a href="https://livesql.oracle.com/apex/livesql/docs/lnpls/plsql-collections-and-records/tdlnplscomposites77.html" target="_blank">（嵌套记录）</a></p>
                        </div><pre class="oac_no_warn" dir="ltr">DECLARE <span class="bold">TYPE name_rec是RECORD</span> （first employees.first_name％TYPE，last employees.last_name％TYPE）; <span class="bold">TYPE联系人IS RECORD</span> （ <span class="bold">姓名name_rec， - 嵌套记录</span>电话employees.phone_number％TYPE）;朋友联系; BEGIN friend.name.first：='John'; friend.name.last：='史密斯'; friend.phone：='1-650-555-1234'; DBMS_OUTPUT.PUT_LINE（friend.name.first ||''|| friend.name.last ||'，'|| friend.phone）;结束; /</pre><p>结果：</p><pre class="oac_no_warn" dir="ltr">约翰史密斯，1-650-555-1234</pre></div>
                     <!-- class="example" -->
                     <div class="example" id="GUID-7DC81088-1265-4C46-A04D-E3AD10BCC04F__CIHDJFDB">
                        <p class="titleinexample">例5-38具有Varray字段的RECORD类型</p>
                        <p>这定义了<code class="codeph">VARRAY</code>类型， <code class="codeph">full_name</code>和<code class="codeph">RECORD</code>类型<code class="codeph">contact</code> 。类型<code class="codeph">contact</code>具有类型为<code class="codeph">full_name</code>的字段。
                        </p>
                        <div class="infoboxnote" id="GUID-7DC81088-1265-4C46-A04D-E3AD10BCC04F__GUID-23794D86-103A-4A5E-96E4-350C1451D3CF">
                           <p class="notep1">实时SQL：</p>
                           <p>您可以在<a href="https://livesql.oracle.com/apex/livesql/docs/lnpls/plsql-collections-and-records/tdlnplscomposites78.html" target="_blank">带有Varray Field的RECORD Type</a>上的Oracle Live SQL上查看和运行此示例</p>
                        </div><pre class="oac_no_warn" dir="ltr">DECLARE <span class="bold">TYPE full_name IS VARRAY（2）OF VARCHAR2（20）;</span> <span class="bold">TYPE contact IS RECORD</span> （ <span class="bold">name full_name</span> ：= full_name（'John'，'Smith'）， <span class="bold">-  varray field telephone</span> employees.phone_number％TYPE）;朋友联系; BEGIN friend.phone：='1-650-555-1234'; DBMS_OUTPUT.PUT_LINE（friend.name（1）||''|| friend.name（2）||'，'|| friend.phone）;结束; /</pre><p>结果：</p><pre class="oac_no_warn" dir="ltr">约翰史密斯，1-650-555-1234</pre></div>
                     <!-- class="example" -->
                     <div class="example" id="GUID-7DC81088-1265-4C46-A04D-E3AD10BCC04F__CIHFBIAF">
                        <p class="titleinexample">例5-39相同定义的包和本地记录类型</p>
                        <p>在此示例中，包<code class="codeph">pkg</code>和匿名块以相同方式定义<code class="codeph">RECORD</code>类型<code class="codeph">rec_type</code> 。该包定义了一个过程<code class="codeph">print_rec_type</code> ，它具有<code class="codeph">rec_type</code>参数。匿名块声明包类型的变量<code class="codeph">r1</code> （ <code class="codeph">pkg.rec_type</code> ）和本地类型的变量<code class="codeph">r2</code> （ <code class="codeph">rec_type</code> ）。匿名块可以将<code class="codeph">r1</code>传递给<code class="codeph">print_rec_type</code> ，但它不能将<code class="codeph">r2</code>传递给<code class="codeph">print_rec_type</code> 。
                        </p>
                        <div class="infoboxnote" id="GUID-7DC81088-1265-4C46-A04D-E3AD10BCC04F__GUID-5A99E590-8A58-4B7B-AB10-86A3638FA58C">
                           <p class="notep1">实时SQL：</p>
                           <p>您可以在Oracle Live SQL上以<a href="https://livesql.oracle.com/apex/livesql/docs/lnpls/plsql-collections-and-records/tdlnplscomposites75err.html" target="_blank">相同定义的包和本地记录类型</a>查看和运行此示例</p>
                        </div><pre class="oac_no_warn" dir="ltr">创建或替换包pkg AS <span class="bold">TYPE rec_type IS RECORD（ - 包RECORD类型</span> <span class="bold">f1 INTEGER，</span> <span class="bold">f2 VARCHAR2（4）</span> <span class="bold">）;</span> PROCEDURE print_rec_type（rec rec_type）;结束pkg; /创建或替换程序包pkg AS PROCEDURE print_rec_type（rec rec_type）IS BEGIN DBMS_OUTPUT.PUT_LINE（rec.f1）; DBMS_OUTPUT.PUT_LINE（rec.f2）;结束;结束pkg; / DECLARE <span class="bold">TYPE rec_type IS RECORD（ - 本地RECORD类型</span> <span class="bold">f1 INTEGER，</span> <span class="bold">f2 VARCHAR2（4）</span> <span class="bold">）;</span> r1 pkg.rec_type; - 包类型r2 rec_type; - 本地类型BEGIN r1.f1：= 10; r1.f2：='abcd'; r2.f1：= 25; r2.f2：='wxyz'; pkg.print_rec_type（R1）; - 成功<span class="bold">pkg.print_rec_type（r2）; - 失败</span> END; /</pre><p>结果：</p><pre class="oac_no_warn" dir="ltr">pkg.print_rec_type（R2）; - 失败*第14行的错误：ORA-06550：第14行，第3列：PLS-00306：调用'PRINT_REC_TYPE'时参数的数量或类型错误</pre></div>
                     <!-- class="example" -->
                  </div>
               </div><a id="LNPLS442"></a><a id="LNPLS99912"></a><div class="props_rev_3"><a id="GUID-EBF66B92-8A94-4E3A-A837-253D5DA79D5F" name="GUID-EBF66B92-8A94-4E3A-A837-253D5DA79D5F"></a><h4 id="LNPLS-GUID-EBF66B92-8A94-4E3A-A837-253D5DA79D5F" class="sect4"><span class="enumeration_section">5.12.4</span>使用％ROWTYPE属性声明项目</h4>
                  <div>
                     <p><code class="codeph">%ROWTYPE</code>属性允许您声明一个记录变量，该变量表示数据库表或视图的完整行或部分行。
                     </p>
                     <p>有关语法和语义的详细信息，请参阅<a href="ROWTYPE-attribute.html#GUID-4E0B9FE2-909D-444A-9B4A-E0243B7FCB99" title="％ROWTYPE属性允许您声明一条记录，该记录表示数据库表或视图的完整行或部分行。">％ROWTYPE属性</a> 。
                     </p>
                     <div class="section">
                        <p class="subhead3" id="GUID-EBF66B92-8A94-4E3A-A837-253D5DA79D5F__GUID-1FF4F104-DD04-4BF3-997B-0BD372CB8DDA">话题</p>
                     </div>
                     <!-- class="section" -->
                     <div class="section">
                        <ul style="list-style-type:disc">
                           <li>
                              <p><a href="plsql-collections-and-records.html#GUID-9D20CCCC-E34B-473B-8499-4787D17C1980">声明始终表示完整行的记录变量</a></p>
                           </li>
                           <li>
                              <p><a href="plsql-collections-and-records.html#GUID-064DACC4-4F40-43CA-9518-09F0BE5923EB">声明可以表示部分行的记录变量</a></p>
                           </li>
                           <li>
                              <p><a href="plsql-collections-and-records.html#GUID-FE47FF68-8720-48EF-9091-88476E31C589">％ROWTYPE属性和虚拟列</a></p>
                           </li>
                           <li>
                              <p><a href="plsql-collections-and-records.html#GUID-058B062C-C429-422B-AD64-B2CFF63075FC">％ROWTYPE属性和不可见列</a></p>
                           </li>
                        </ul>
                     </div>
                     <!-- class="section" -->
                  </div><a id="LNPLS445"></a><a id="LNPLS219"></a><a id="LNPLS444"></a><div class="props_rev_3"><a id="GUID-9D20CCCC-E34B-473B-8499-4787D17C1980" name="GUID-9D20CCCC-E34B-473B-8499-4787D17C1980"></a><h5 id="LNPLS-GUID-9D20CCCC-E34B-473B-8499-4787D17C1980" class="sect5"><span class="enumeration_section">5.12.4.1</span>声明始终表示完整行的记录变量</h5>
                     <div>
                        <p>要声明始终表示数据库表或视图的完整行的记录变量，请使用以下语法：</p><pre class="oac_no_warn" dir="ltr"><span class="italic">variable_name</span> <span class="italic">table_or_view_name</span> ％ROWTYPE;</pre><p>对于表或视图的每一列，记录都有一个具有相同名称和数据类型的字段。</p>
                        <div class="infoboxnotealso" id="GUID-9D20CCCC-E34B-473B-8499-4787D17C1980__GUID-62B73CAF-71C4-48D0-95BA-E9459947F14F">
                           <p class="notep1">也可以看看：</p>
                           <p>有关<code class="codeph">%ROWTYPE</code>详细信息，请参阅<span class="q">“ <a href="ROWTYPE-attribute.html#GUID-4E0B9FE2-909D-444A-9B4A-E0243B7FCB99" title="％ROWTYPE属性允许您声明一条记录，该记录表示数据库表或视图的完整行或部分行。">％ROWTYPE属性</a> ”</span></p>
                        </div>
                        <div class="example" id="GUID-9D20CCCC-E34B-473B-8499-4787D17C1980__CIHJDGEJ">
                           <p class="titleinexample">示例5-40％ROWTYPE变量表示完整数据库表行</p>
                           <p>此示例声明一个记录变量，该变量表示表<code class="codeph">departments</code>的一行，为其字段分配值并打印它们。将此示例与<a href="plsql-collections-and-records.html#GUID-7DC81088-1265-4C46-A04D-E3AD10BCC04F__CIHHBIDA">示例5-36</a>进行比较。
                           </p>
                           <div class="infoboxnote" id="GUID-9D20CCCC-E34B-473B-8499-4787D17C1980__GUID-F617EC90-7E08-44FD-ACFA-987A3F0A2214">
                              <p class="notep1">实时SQL：</p>
                              <p>您可以在<a href="https://livesql.oracle.com/apex/livesql/docs/lnpls/plsql-collections-and-records/tdlnplscomposites80.html" target="_blank">％ROWTYPE变量表示完整数据库表行的</a> Oracle Live SQL上查看和运行此示例</p>
                           </div><pre class="oac_no_warn" dir="ltr">DECLARE <span class="bold">dept_rec departments％ROWTYPE;</span> BEGIN  - 为字段赋值：dept_rec.department_id：= 10; dept_rec.department_name：='管理'; dept_rec.manager_id：= 200; dept_rec.location_id：= 1700; - 打印字段：DBMS_OUTPUT.PUT_LINE（'dept_id：'|| dept_rec.department_id）; DBMS_OUTPUT.PUT_LINE（'dept_name：'|| dept_rec.department_name）; DBMS_OUTPUT.PUT_LINE（'mgr_id：'|| dept_rec.manager_id）; DBMS_OUTPUT.PUT_LINE（'loc_id：'|| dept_rec.location_id）;结束; /</pre><p>结果：</p><pre class="oac_no_warn" dir="ltr">dept_id：10 dept_name：管理mgr_id：200 loc_id：1700</pre></div>
                        <!-- class="example" -->
                        <div class="example" id="GUID-9D20CCCC-E34B-473B-8499-4787D17C1980__BEIBGEFH">
                           <p class="titleinexample">示例5-41％ROWTYPE变量不会继承初始值或约束</p>
                           <p>此示例创建一个包含两列的表，每列都有一个初始值和一个<code class="codeph">NOT</code> <code class="codeph">NULL</code>约束。然后它声明一个记录变量，它表示一行表并打印其字段，表明它们没有继承初始值或<code class="codeph">NOT</code> <code class="codeph">NULL</code>约束。
                           </p>
                           <div class="infoboxnote" id="GUID-9D20CCCC-E34B-473B-8499-4787D17C1980__GUID-58CE7EE5-5FE0-40DB-9FEC-A5226B37865B">
                              <p class="notep1">实时SQL：</p>
                              <p>您可以在Oracle Live SQL上查看并运行此示例， <a href="https://livesql.oracle.com/apex/livesql/docs/lnpls/plsql-collections-and-records/tdlnplscomposites79.html" target="_blank">％ROWTYPE变量不会继承初始值或约束</a></p>
                           </div><pre class="oac_no_warn" dir="ltr">DROP TABLE t1; CREATE TABLE t1（c1 INTEGER <span class="bold">DEFAULT 0 NOT NULL</span> ，c2 INTEGER <span class="bold">DEFAULT 1 NOT NULL</span> ）; DECLARE <span class="bold">t1_row t1％ROWTYPE;</span> BEGIN DBMS_OUTPUT.PUT（'t1.c1 ='）; DBMS_OUTPUT.PUT_LINE（NVL（TO_CHAR（t1_row.c1），'NULL'））; DBMS_OUTPUT.PUT（'t1.c2 ='）;打印（t1_row.c2）; DBMS_OUTPUT.PUT_LINE（NVL（TO_CHAR（t1_row.c2），'NULL'））;结束; /</pre><p>结果：</p><pre class="oac_no_warn" dir="ltr"><span class="bold">t1.c1 = NULL</span> <span class="bold">t1.c2 = NULL</span></pre></div>
                        <!-- class="example" -->
                     </div>
                  </div><a id="LNPLS220"></a><a id="LNPLS221"></a><a id="LNPLS446"></a><div class="props_rev_3"><a id="GUID-064DACC4-4F40-43CA-9518-09F0BE5923EB" name="GUID-064DACC4-4F40-43CA-9518-09F0BE5923EB"></a><h5 id="LNPLS-GUID-064DACC4-4F40-43CA-9518-09F0BE5923EB" class="sect5"><span class="enumeration_section">5.12.4.2</span>声明可以表示部分行的记录变量</h5>
                     <div>
                        <div class="section">
                           <p>要声明可以表示数据库表或视图的部分行的记录变量，请使用以下语法：</p><pre class="oac_no_warn" dir="ltr"><span class="italic">variable_name</span> <span class="italic">cursor</span> ％ROWTYPE;</pre><p>游标与查询相关联。对于查询选择的每个列，记录变量必须具有相应的类型兼容字段。如果查询选择表或视图的每一列，则该变量表示一个完整的行;否则，变量表示部分行。游标必须是显式游标或强游标变量。</p>
                           <div class="infoboxnotealso" id="GUID-064DACC4-4F40-43CA-9518-09F0BE5923EB__GUID-516FA222-71B5-4F4B-B6E1-14419BA783F5">
                              <p class="notep1">也可以看看：</p>
                              <ul style="list-style-type:disc">
                                 <li>
                                    <p><span class="q">“ <a href="FETCH-statement.html#GUID-75BC6E63-841A-4103-9B96-8AC97F5C28BB" title="FETCH语句从多行查询的结果集中检索数据行 - 一次一行，一次几行，或一次所有行 - 并将数据存储在变量，记录或集合中。">FETCH语句</a> ”</span>用于完整语法</p>
                                 </li>
                                 <li>
                                    <p>有关游标的信息，请参阅<span class="q">“ <a href="static-sql.html#GUID-F1FE15F9-5C96-4C4E-B240-B7363D25A8F1" title="游标是指向私有SQL区域的指针，该区域存储有关处理特定SELECT或DML语句的信息。">游标概述</a> ”</span></p>
                                 </li>
                                 <li>
                                    <p>有关显式游标的信息的<span class="q">“ <a href="static-sql.html#GUID-89E0242F-42AC-4B21-9DF1-ACD6F4FC03B9">显式游标</a> ”</span></p>
                                 </li>
                                 <li>
                                    <p>有关游标变量的信息，请参见<span class="q">“ <a href="static-sql.html#GUID-4A6E054A-4002-418D-A1CA-DE849CD7E6D5" title="要创建游标变量，请声明预定义类型SYS_REFCURSOR的变量或定义REF CURSOR类型，然后声明该类型的变量。打开游标变量后，可以使用FETCH语句获取查询结果集的行。您可以为PL / SQL游标变量分配另一个PL / SQL游标变量或主机游标变量的值。与游标变量关联的查询可以引用其范围中的任何变量。您可以使用游标变量作为子程序参数，这使得它可以在子程序之间传递查询结果。您可以将游标变量用作主变量，这使得在PL / SQL存储的子程序及其客户端之间传递查询结果非常有用。">游标变量</a> ”</span></p>
                                 </li>
                                 <li>
                                    <p>有关连接的信息，请<a href="../sqlrf/Joins.html#SQLRF30046" target="_blank"><span class="italic">参见Oracle数据库SQL语言参考</span></a></p>
                                 </li>
                              </ul>
                           </div>
                        </div>
                        <!-- class="section" -->
                        <div class="example" id="GUID-064DACC4-4F40-43CA-9518-09F0BE5923EB__CBJCGDHB">
                           <p class="titleinexample">示例5-42％ROWTYPE变量表示部分数据库表行</p>
                           <p>此示例定义一个显式游标，其查询仅从示例模式<code class="codeph">HR</code>的<code class="codeph">employees</code>表中选择列<code class="codeph">first_name</code> ， <code class="codeph">last_name</code>和<code class="codeph">phone_number</code> 。然后，该示例声明一个记录变量，该变量具有光标选择的每个列的字段。该变量代表一部分<code class="codeph">employees</code> 。将此示例与<a href="plsql-collections-and-records.html#GUID-7DC81088-1265-4C46-A04D-E3AD10BCC04F__CIHEGIFD">示例5-37</a>进行比较。
                           </p>
                           <div class="infoboxnote" id="GUID-064DACC4-4F40-43CA-9518-09F0BE5923EB__GUID-74DD35A4-972D-447C-B920-46A4050397B3">
                              <p class="notep1">实时SQL：</p>
                              <p>您可以在<a href="https://livesql.oracle.com/apex/livesql/docs/lnpls/plsql-collections-and-records/tdlnplscomposites81.html" target="_blank">％ROWTYPE变量表示部分数据库表行的</a> Oracle Live SQL上查看和运行此示例</p>
                           </div><pre class="oac_no_warn" dir="ltr">DECLARE CURSOR c IS SELECT first_name，last_name，phone_number FROM employees; <span class="bold">朋友c％ROWTYPE;</span> BEGIN friend.first_name：='John'; friend.last_name：='史密斯'; friend.phone_number：='1-650-555-1234'; DBMS_OUTPUT.PUT_LINE（friend.first_name ||''|| friend.last_name ||'，'|| friend.phone_number）;结束; /</pre><p>结果：</p><pre class="oac_no_warn" dir="ltr">约翰史密斯，1-650-555-1234</pre></div>
                        <!-- class="example" -->
                        <div class="example" id="GUID-064DACC4-4F40-43CA-9518-09F0BE5923EB__CIHIFJHG">
                           <p class="titleinexample">示例5-43％ROWTYPE变量表示Join Row</p>
                           <p>此示例定义一个显式游标，其查询是一个连接，然后声明一个记录变量，该变量具有光标选择的每个列的字段。</p>
                           <div class="infoboxnote" id="GUID-064DACC4-4F40-43CA-9518-09F0BE5923EB__GUID-C0B244F8-2E16-4FEF-BEC3-31F95C4E18A5">
                              <p class="notep1">实时SQL：</p>
                              <p>您可以在<a href="https://livesql.oracle.com/apex/livesql/docs/lnpls/plsql-collections-and-records/tdlnplscomposites82.html" target="_blank">％ROWTYPE变量表示连接行的</a> Oracle Live SQL上查看和运行此示例</p>
                           </div><pre class="oac_no_warn" dir="ltr">DECLARE CURSOR c2 IS SELECT employee_id，email，employees.manager_id，location_id FROM employees，departments WHERE employees.department_id = departments.department_id; <span class="bold">join_rec c2％ROWTYPE;</span> - 包括两个表中的列BEGIN NULL;结束; /</pre></div>
                        <!-- class="example" -->
                     </div>
                  </div>
                  <div class="props_rev_3"><a id="GUID-FE47FF68-8720-48EF-9091-88476E31C589" name="GUID-FE47FF68-8720-48EF-9091-88476E31C589"></a><h5 id="LNPLS-GUID-FE47FF68-8720-48EF-9091-88476E31C589" class="sect5"><span class="enumeration_section">5.12.4.3</span> ％ROWTYPE属性和虚拟列</h5>
                     <div>
                        <p>如果使用<code class="codeph">%ROWTYPE</code>属性定义表示具有虚拟列的表的完整行的记录变量，则无法将该记录插入表中。相反，您必须将各个记录字段插入表中，不包括虚拟列。
                        </p>
                        <div class="example" id="GUID-FE47FF68-8720-48EF-9091-88476E31C589__BABBCHAI">
                           <p class="titleinexample">示例5-44将％ROWTYPE记录插入表中（错误）</p>
                           <p>此示例创建一个记录变量，该变量表示具有虚拟列的表的完整行，填充记录，并将记录插入表中，从而导致ORA-54013。</p><pre class="oac_no_warn" dir="ltr">DROP TABLE plch_departure; CREATE TABLE plch_departure（目的地VARCHAR2（100），departure_time DATE，延迟NUMBER（10）， <span class="bold">预期GENERATED ALWAYS AS（departure_time + delay /</span> 24/60/60 <span class="bold">）</span> ）; DECLARE <span class="bold">dep_rec plch_departure％ROWTYPE;</span> BEGIN dep_rec.destination：='X'; dep_rec.departure_time：= SYSDATE; dep_rec.delay：= 1500; <span class="bold">INSERT INTO plch_departure VALUES dep_rec;</span>结束; /</pre><p>结果：</p><pre class="oac_no_warn" dir="ltr">第1行的DECLARE * ERROR： <span class="bold">ORA-54013：虚拟列</span> ORA-06512 <span class="bold">上禁止INSERT操作</span> ：第8行</pre></div>
                        <!-- class="example" -->
                        <div class="example" id="GUID-FE47FF68-8720-48EF-9091-88476E31C589__BABGHFEI">
                           <p class="titleinexample">示例5-45将％ROWTYPE记录插入表（右）</p>
                           <p>这解决了<a href="plsql-collections-and-records.html#GUID-FE47FF68-8720-48EF-9091-88476E31C589__BABBCHAI">示例5-44中</a>的问题，方法是将单个记录字段插入表中，不包括虚拟列。
                           </p><pre class="oac_no_warn" dir="ltr">DECLARE dep_rec plch_departure％rowtype; BEGIN dep_rec.destination：='X'; dep_rec.departure_time：= SYSDATE; dep_rec.delay：= 1500; <span class="bold">INSERT INTO plch_departure（destination，departure_time，delay）</span> <span class="bold">VALUES（dep_rec.destination，dep_rec.departure_time，dep_rec.delay）;</span>结束; /</pre><p>结果：</p><pre class="oac_no_warn" dir="ltr">PL / SQL过程成功完成。</pre></div>
                        <!-- class="example" -->
                     </div>
                  </div><a id="LNPLS447"></a><a id="LNPLS99854"></a><div class="props_rev_3"><a id="GUID-058B062C-C429-422B-AD64-B2CFF63075FC" name="GUID-058B062C-C429-422B-AD64-B2CFF63075FC"></a><h5 id="LNPLS-GUID-058B062C-C429-422B-AD64-B2CFF63075FC" class="sect5"><span class="enumeration_section">5.12.4.4</span> ％ROWTYPE属性和不可见列</h5>
                     <div>
                        <p>假设您使用<code class="codeph">%ROWTYPE</code>属性来定义记录变量，该变量表示具有不可见列的表的行，然后使不可见列可见。
                        </p>
                        <p>如果使用光标定义记录变量，如<span class="q">“ <a href="plsql-collections-and-records.html#GUID-064DACC4-4F40-43CA-9518-09F0BE5923EB">声明可以表示部分行的记录变量</a> ”</span> ，则使不可见列可见不会更改记录变量的结构。
                        </p>
                        <p>但是，如果您在<span class="q">“ <a href="plsql-collections-and-records.html#GUID-9D20CCCC-E34B-473B-8499-4787D17C1980">声明始终表示完整行的记录变量</a> ”中</span>定义记录变量并使用<code class="codeph">SELECT</code> <code class="codeph">*</code> <code class="codeph">INTO</code>语句为记录分配值，则使不可见列可见会改变记录的结构 - 请参阅<a href="plsql-collections-and-records.html#GUID-058B062C-C429-422B-AD64-B2CFF63075FC__BABJBIGE">例5-46</a> 。
                        </p>
                        <div class="infoboxnotealso" id="GUID-058B062C-C429-422B-AD64-B2CFF63075FC__GUID-43D186FB-DFB2-4369-AEFC-728C6F69FF10">
                           <p class="notep1">也可以看看：</p>
                           <p>有关不可见列的一般信息，请<a href="../sqlrf/CREATE-TABLE.html#SQLRF55897" target="_blank"><span class="italic">参见Oracle数据库SQL语言参考</span></a></p>
                        </div>
                        <div class="example" id="GUID-058B062C-C429-422B-AD64-B2CFF63075FC__BABJBIGE">
                           <p class="titleinexample">示例5-46％使不可见列可见影响的ROWTYPE</p><pre class="oac_no_warn" dir="ltr">CREATE <span class="bold">TABLE t</span> （INT，b INT， <span class="bold">c INT INVISIBLE</span> ）;插入t（a，b， <span class="bold">c</span> ）值（ <span class="bold">1,2,3</span> ）;承诺; DECLARE <span class="bold">t_rec t％ROWTYPE; -  t_rec有字段a和b，但不是c</span> BEGIN <span class="bold">SELECT * INTO t_rec FROM t</span> WHERE ROWNUM &lt;2; <span class="bold">-  t_rec（a）= 1，t_rec（b）= 2</span> DBMS_OUTPUT.PUT_LINE（'c ='|| <span class="bold">t_rec.c</span> ）;结束; /</pre><p>结果：</p><pre class="oac_no_warn" dir="ltr">DBMS_OUTPUT.PUT_LINE（'c ='|| t_rec.c）; *第5行的错误：ORA-06550：第5行，第40列： <span class="bold">PLS-00302：必须声明组件“C”</span> ORA-06550：第5行，第3列：PL / SQL：语句被忽略</pre><p>使隐形列可见：</p><pre class="oac_no_warn" dir="ltr">ALTER TABLE t MODIFY（ <span class="bold">c VISIBLE</span> ）;</pre><p>结果：</p><pre class="oac_no_warn" dir="ltr">表改变了。
 </pre><p>重复前面的匿名块：</p><pre class="oac_no_warn" dir="ltr">DECLARE <span class="bold">t_rec t％ROWTYPE; -  t_rec有字段a，b和c</span> BEGIN <span class="bold">SELECT * INTO t_rec</span> FROM t WHERE ROWNUM &lt;2; <span class="bold">-  t_rec（a）= 1，t_rec（b）= 2，</span> <span class="bold">-  t_rec（c）= 3</span> DBMS_OUTPUT.PUT_LINE（'c ='|| <span class="bold">t_rec.c</span> ）;结束; /</pre><p>结果：</p><pre class="oac_no_warn" dir="ltr"><span class="bold">c = 3</span> PL / SQL过程成功完成。</pre></div>
                        <!-- class="example" -->
                     </div>
                  </div>
               </div>
            </div><a id="LNPLS448"></a><a id="LNPLS00510"></a><div class="props_rev_3"><a id="GUID-794AD0D6-2D97-4C4A-B7DA-6126025EF2A5" name="GUID-794AD0D6-2D97-4C4A-B7DA-6126025EF2A5"></a><h3 id="LNPLS-GUID-794AD0D6-2D97-4C4A-B7DA-6126025EF2A5" class="sect3"><span class="enumeration_section">5.13</span>为记录变量分配值</h3>
               <div>
                  <p><span class="italic">记录变量</span>表示记录变量或复合变量的记录组件。
                  </p>
                  <div class="section">
                     <p>对于任何记录变量，您可以单独为每个字段分配值。</p>
                     <p>您可以使用限定表达式分配值（请参阅<a href="plsql-collections-and-records.html#GUID-4B379569-4068-4DB1-9D69-E706F4AC5758__GUID-58479C46-5F2B-4E22-B019-264CAB176060">示例5-8</a> ）。
                     </p>
                     <p>在某些情况下，您可以将一个记录变量的值分配给另一个记录变量。</p>
                     <p>如果记录变量表示数据库表或视图的完整行或部分行，则可以将表示的行分配给记录变量。</p>
                  </div>
                  <!-- class="section" -->
                  <div class="section">
                     <p class="subhead2" id="GUID-794AD0D6-2D97-4C4A-B7DA-6126025EF2A5__GUID-22896095-EE87-4CC8-ABE1-A9BBC8655763">话题</p>
                  </div>
                  <!-- class="section" -->
                  <div class="section">
                     <ul style="list-style-type:disc">
                        <li>
                           <p><a href="plsql-collections-and-records.html#GUID-E6D99438-0B7F-4468-B9AD-97CFC47BDD73">将一个记录变量分配给另一个</a></p>
                        </li>
                        <li>
                           <p><a href="plsql-collections-and-records.html#GUID-59D7C4DF-4CE0-4E82-81FA-CBE17282E1EF" title="如果记录变量表示数据库表或视图的完整行或部分行，则可以将表示的行分配给记录变量。">分配全行或部分行来记录变量</a></p>
                        </li>
                        <li>
                           <p><a href="plsql-collections-and-records.html#GUID-6AB78084-231F-4BCA-A905-DB2069E4B885" title="将值NULL分配给记录变量会将值NULL分配给其每个字段。">为记录变量分配NULL</a></p>
                        </li>
                     </ul>
                  </div>
                  <!-- class="section" -->
               </div><a id="LNPLS449"></a><a id="LNPLS450"></a><a id="LNPLS492"></a><a id="LNPLS99910"></a><div class="props_rev_3"><a id="GUID-E6D99438-0B7F-4468-B9AD-97CFC47BDD73" name="GUID-E6D99438-0B7F-4468-B9AD-97CFC47BDD73"></a><h4 id="LNPLS-GUID-E6D99438-0B7F-4468-B9AD-97CFC47BDD73" class="sect4"><span class="enumeration_section">5.13.1</span>将一个记录变量分配给另一个</h4>
                  <div>
                     <div class="section">
                        <p>只有在这些情况下，您才能将一个记录变量的值分配给另一个记录变量：</p>
                     </div>
                     <!-- class="section" -->
                     <div class="section">
                        <ul style="list-style-type:disc">
                           <li>
                              <p>这两个变量具有相同的<code class="codeph">RECORD</code>类型。
                              </p>
                           </li>
                           <li>
                              <p>目标变量用<code class="codeph">RECORD</code>类型声明，源变量用<code class="codeph">%ROWTYPE</code>声明，它们的字段在数量和顺序上匹配，相应的字段具有相同的数据类型。
                              </p>
                           </li>
                        </ul>
                        <p>对于复合变量的记录组件，复合变量的类型不需要匹配。</p>
                     </div>
                     <!-- class="section" -->
                     <div class="example" id="GUID-E6D99438-0B7F-4468-B9AD-97CFC47BDD73__CIHDEIBG">
                        <p class="titleinexample">例5-47将记录分配给同一记录类型的另一个记录</p>
                        <p>在此示例中，name1和name2具有相同的RECORD类型，因此您可以将name1的值分配给name2。</p><pre class="oac_no_warn" dir="ltr">DECLARE TYPE name_rec IS RECORD（first employees.first_name％TYPE DEFAULT'John'，last employees.last_name％TYPE DEFAULT'Doe'）; <span class="bold">name1 name_rec;</span> <span class="bold">name2 name_rec;</span> BEGIN name1.first：='Jane'; name1.last：='史密斯'; DBMS_OUTPUT.PUT_LINE（'name1：'|| name1.first ||''|| name1.last）; <span class="bold">name2：= name1;</span> DBMS_OUTPUT.PUT_LINE（'name2：'|| name2.first ||''|| name2.last）;结束; /</pre><p>结果：</p><pre class="oac_no_warn" dir="ltr">name1：Jane Smith name2：Jane Smith</pre></div>
                     <!-- class="example" -->
                     <div class="example" id="GUID-E6D99438-0B7F-4468-B9AD-97CFC47BDD73__CIHDGDHE">
                        <p class="titleinexample">示例5-48将％ROWTYPE记录分配给RECORD类型记录</p>
                        <p>在此示例中，目标变量使用<code class="codeph">RECORD</code>类型声明，源变量使用<code class="codeph">%ROWTYPE</code>声明，其字段在数量和顺序上匹配，并且相应的字段具有相同的数据类型。
                        </p><pre class="oac_no_warn" dir="ltr">DECLARE TYPE name_rec IS RECORD（first <span class="bold">employees.first_name％</span> TYPE DEFAULT'John'，last <span class="bold">employees.last_name％</span> TYPE DEFAULT'Doe'）; CURSOR c IS SELECT <span class="bold">first_name</span> ， <span class="bold">last_name</span> FROM <span class="bold">employees</span> ; <span class="bold">target name_rec;</span> <span class="bold">来源c％ROWTYPE;</span> BEGIN source.first_name：='简'; source.last_name：='史密斯'; DBMS_OUTPUT.PUT_LINE（'source：'|| source.first_name ||''|| source.last_name）; <span class="bold">target：= source;</span> DBMS_OUTPUT.PUT_LINE（'target：'|| target.first ||''|| target.last）;结束; /</pre><p>结果：</p><pre class="oac_no_warn" dir="ltr">来源：简史密斯目标：简史密斯</pre></div>
                     <!-- class="example" -->
                     <div class="example" id="GUID-E6D99438-0B7F-4468-B9AD-97CFC47BDD73__BEIDCCBE">
                        <p class="titleinexample">示例5-49将嵌套记录分配给同一记录类型的另一个记录</p>
                        <p>此示例将一个嵌套记录的值分配给另一个嵌套记录。嵌套记录具有相同的<code class="codeph">RECORD</code>类型，但它们嵌套的记录不具有相同的<code class="codeph">RECORD</code>类型。
                        </p><pre class="oac_no_warn" dir="ltr">DECLARE TYPE name_rec是RECORD（first employees.first_name％TYPE，last employees.last_name％TYPE）; TYPE <span class="bold">phone_rec</span>是RECORD（名称<span class="bold">name_rec</span> ， - 嵌套记录电话employees.phone_number％TYPE）; TYPE <span class="bold">email_rec</span>是RECORD（名称<span class="bold">name_rec</span> ， - 嵌套记录电子邮件employees.email％TYPE）; <span class="bold">phone_contact phone_rec;</span> <span class="bold">email_contact email_rec;</span> BEGIN phone_contact.name.first：='John'; phone_contact.name.last：='史密斯'; phone_contact.phone：='1-650-555-1234'; <span class="bold">email_contact.name：= phone_contact.name;</span> email_contact.email：=（email_contact.name.first ||'。'|| email_contact.name.last || '@'|| 'example.com'）; DBMS_OUTPUT.PUT_LINE（email_contact.email）;结束; /</pre><p>结果：</p><pre class="oac_no_warn" dir="ltr">约翰。Smith@example.com</pre></div>
                     <!-- class="example" -->
                  </div>
               </div><a id="LNPLS451"></a><a id="LNPLS99909"></a><div class="props_rev_3"><a id="GUID-59D7C4DF-4CE0-4E82-81FA-CBE17282E1EF" name="GUID-59D7C4DF-4CE0-4E82-81FA-CBE17282E1EF"></a><h4 id="LNPLS-GUID-59D7C4DF-4CE0-4E82-81FA-CBE17282E1EF" class="sect4"><span class="enumeration_section">5.13.2</span>分配全行或部分行以记录变量</h4>
                  <div>
                     <p>如果记录变量表示数据库表或视图的完整行或部分行，则可以将表示的行分配给记录变量。</p>
                     <div class="section">
                        <p class="subhead3" id="GUID-59D7C4DF-4CE0-4E82-81FA-CBE17282E1EF__GUID-60438386-D759-4631-8C24-1EB34EFA22D0">话题</p>
                     </div>
                     <!-- class="section" -->
                     <div class="section">
                        <ul style="list-style-type:disc">
                           <li>
                              <p><a href="plsql-collections-and-records.html#GUID-785E5E7E-7FCD-4291-8F62-389814A261EC">使用SELECT INTO将行分配给记录变量</a></p>
                           </li>
                           <li>
                              <p><a href="plsql-collections-and-records.html#GUID-CC1DA893-4087-4DA4-8B13-052AB76DAC4F">使用FETCH将行分配给记录变量</a></p>
                           </li>
                           <li>
                              <p><a href="plsql-collections-and-records.html#GUID-95EA1F91-8196-4F77-8EA3-36CAD9B43855" title="SQL语句INSERT，UPDATE和DELETE具有可选的RETURNING INTO子句，该子句可以返回PL / SQL记录变量中受影响的行。">使用SQL语句返回PL / SQL记录变量中的行</a></p>
                           </li>
                        </ul>
                     </div>
                     <!-- class="section" -->
                  </div><a id="LNPLS495"></a><a id="LNPLS99906"></a><div class="props_rev_3"><a id="GUID-785E5E7E-7FCD-4291-8F62-389814A261EC" name="GUID-785E5E7E-7FCD-4291-8F62-389814A261EC"></a><h5 id="LNPLS-GUID-785E5E7E-7FCD-4291-8F62-389814A261EC" class="sect5"><span class="enumeration_section">5.13.2.1</span>使用SELECT INTO将行分配给记录变量</h5>
                     <div>
                        <div class="section">
                           <p>简单的<code class="codeph">SELECT</code> <code class="codeph">INTO</code>语句的语法是：</p><pre class="oac_no_warn" dir="ltr">SELECT <span class="italic">select_list</span> INTO <span class="italic">record_variable_name</span> FROM <span class="italic">table_or_view_name</span> ;</pre><p>对于<span class="italic"><code class="codeph">select_list</code></span>每一列，记录变量必须具有相应的类型兼容字段。<span class="italic"><code class="codeph">select_list</code></span>中的<span class="italic"><code class="codeph">select_list</code></span>必须与记录字段的顺序相同。
                           </p>
                           <div class="infoboxnotealso" id="GUID-785E5E7E-7FCD-4291-8F62-389814A261EC__GUID-B9EA5C16-A4FF-485D-920E-252A62E1CDE8">
                              <p class="notep1">也可以看看：</p>
                              <p><span class="q">“ <a href="SELECT-INTO-statement.html#GUID-6E14E04D-4344-45F3-BE80-979DD26C7A90" title="SELECT INTO语句从一个或多个数据库表中检索值（如SQL SELECT语句所做的那样）并将它们存储在变量中（SQL SELECT语句不这样做）。">SELECT INTO Statement</a> ”</span>获取完整语法</p>
                           </div>
                        </div>
                        <!-- class="section" -->
                        <div class="example" id="GUID-785E5E7E-7FCD-4291-8F62-389814A261EC__CIHBFCAE">
                           <p class="titleinexample">示例5-50 SELECT INTO将值分配给记录变量</p>
                           <p>在此示例中，记录变量<code class="codeph">rec1</code>表示<code class="codeph">employees</code>表的部分行 - 列<code class="codeph">last_name</code>和<code class="codeph">employee_id</code> 。该<code class="codeph">SELECT</code> <code class="codeph">INTO</code>语句从选择<code class="codeph">employees</code>的量，行<code class="codeph">job_id</code>是<code class="codeph">'AD_PRES'</code>和分配列的值<code class="codeph">last_name</code>和<code class="codeph">employee_id</code>该行中给的相应字段<code class="codeph">rec1</code> 。
                           </p><pre class="oac_no_warn" dir="ltr">DECLARE TYPE RecordTyp IS RECORD（last employees.last_name％TYPE，id employees.employee_id％TYPE）; rec1 RecordTyp; BEGIN <span class="bold">SELECT last_name，employee_id INTO rec1</span> <span class="bold">FROM employees</span> <span class="bold">WHERE job_id ='AD_PRES';</span> DBMS_OUTPUT.PUT_LINE（'Employee＃'|| rec1.id ||'='|| rec1.last）;结束; /</pre><p>结果：</p><pre class="oac_no_warn" dir="ltr">员工＃100 =国王</pre></div>
                        <!-- class="example" -->
                     </div>
                  </div><a id="LNPLS490"></a><a id="LNPLS99905"></a><div class="props_rev_3"><a id="GUID-CC1DA893-4087-4DA4-8B13-052AB76DAC4F" name="GUID-CC1DA893-4087-4DA4-8B13-052AB76DAC4F"></a><h5 id="LNPLS-GUID-CC1DA893-4087-4DA4-8B13-052AB76DAC4F" class="sect5"><span class="enumeration_section">5.13.2.2</span>使用FETCH将行分配给记录变量</h5>
                     <div>
                        <div class="section">
                           <p>简单<code class="codeph">FETCH</code>语句的语法是：</p><pre class="oac_no_warn" dir="ltr">FETCH <span class="italic">游标</span> INTO <span class="italic">record_variable_name</span> ;</pre><p>游标与查询相关联。对于查询选择的每个列，记录变量必须具有相应的类型兼容字段。游标必须是显式游标或强游标变量。</p>
                           <div class="infoboxnotealso" id="GUID-CC1DA893-4087-4DA4-8B13-052AB76DAC4F__GUID-5EE013A6-0700-48CE-81CF-EF69997A0E48">
                              <p class="notep1">也可以看看：</p>
                              <ul style="list-style-type:disc">
                                 <li>
                                    <p><span class="q">“ <a href="FETCH-statement.html#GUID-75BC6E63-841A-4103-9B96-8AC97F5C28BB" title="FETCH语句从多行查询的结果集中检索数据行 - 一次一行，一次几行，或一次所有行 - 并将数据存储在变量，记录或集合中。">FETCH语句</a> ”</span>用于完整语法</p>
                                 </li>
                                 <li>
                                    <p>有关所有游标的信息，请参阅<span class="q">“ <a href="static-sql.html#GUID-F1FE15F9-5C96-4C4E-B240-B7363D25A8F1" title="游标是指向私有SQL区域的指针，该区域存储有关处理特定SELECT或DML语句的信息。">游标概述</a> ”</span></p>
                                 </li>
                                 <li>
                                    <p>有关显式游标的信息的<span class="q">“ <a href="static-sql.html#GUID-89E0242F-42AC-4B21-9DF1-ACD6F4FC03B9">显式游标</a> ”</span></p>
                                 </li>
                                 <li>
                                    <p>有关游标变量的信息，请参见<span class="q">“ <a href="static-sql.html#GUID-4A6E054A-4002-418D-A1CA-DE849CD7E6D5" title="要创建游标变量，请声明预定义类型SYS_REFCURSOR的变量或定义REF CURSOR类型，然后声明该类型的变量。打开游标变量后，可以使用FETCH语句获取查询结果集的行。您可以为PL / SQL游标变量分配另一个PL / SQL游标变量或主机游标变量的值。与游标变量关联的查询可以引用其范围中的任何变量。您可以使用游标变量作为子程序参数，这使得它可以在子程序之间传递查询结果。您可以将游标变量用作主变量，这使得在PL / SQL存储的子程序及其客户端之间传递查询结果非常有用。">游标变量</a> ”</span></p>
                                 </li>
                              </ul>
                           </div>
                        </div>
                        <!-- class="section" -->
                        <div class="example" id="GUID-CC1DA893-4087-4DA4-8B13-052AB76DAC4F__BEIDDADJ">
                           <p class="titleinexample">例5-51 FETCH分配值以记录函数返回</p>
                           <p>在此示例中， <code class="codeph">RECORD</code>类型<code class="codeph">EmpRecTyp</code>每个变量表示<code class="codeph">employees</code>表的部分行 - <code class="codeph">employee_id</code>和<code class="codeph">salary</code>列。游标和函数都返回<code class="codeph">EmpRecTyp</code>类型的值。在函数中， <code class="codeph">FETCH</code>语句将<code class="codeph">employee_id</code>和<code class="codeph">salary</code>列的值分配给<code class="codeph">EmpRecTyp</code>类型的局部变量的相应字段。
                           </p><pre class="oac_no_warn" dir="ltr">DECLARE TYPE EmpRecTyp IS RECORD（emp_id employees.employee_id％TYPE，salary employees.salary％TYPE）; CURSOR desc_salary RETURN EmpRecTyp IS SELECT employee_id，salary FROM employees ORDER BY salary DESC; highest_paid_emp EmpRecTyp; next_highest_paid_emp EmpRecTyp;功能nth_highest_salary（n INTEGER）返回EmpRecTyp IS emp_rec EmpRecTyp; BEGIN OPEN desc_salary; FOR i IN 1..n LOOP <span class="bold">FETCH desc_salary INTO emp_rec;</span>结束循环;关闭desc_salary; RETURN emp_rec; END nth_highest_salary; BEGIN highest_paid_emp：= nth_highest_salary（1）; next_highest_paid_emp：= nth_highest_salary（2）; DBMS_OUTPUT.PUT_LINE（'最高付费：＃'|| highest_paid_emp.emp_id ||'，$'|| highest_paid_emp.salary）; DBMS_OUTPUT.PUT_LINE（'下一个最高付费：＃'|| next_highest_paid_emp.emp_id ||'，$'|| next_highest_paid_emp.salary）;结束; /</pre><p>结果：</p><pre class="oac_no_warn" dir="ltr">最高支付：＃100，$ 24000下一个最高支付：＃101，$ 17000</pre></div>
                        <!-- class="example" -->
                     </div>
                  </div><a id="LNPLS501"></a><a id="LNPLS99953"></a><div class="props_rev_3"><a id="GUID-95EA1F91-8196-4F77-8EA3-36CAD9B43855" name="GUID-95EA1F91-8196-4F77-8EA3-36CAD9B43855"></a><h5 id="LNPLS-GUID-95EA1F91-8196-4F77-8EA3-36CAD9B43855" class="sect5"><span class="enumeration_section">5.13.2.3</span>使用SQL语句返回PL / SQL记录变量中的行</h5>
                     <div>
                        <p>SQL语句<code class="codeph">INSERT</code> ， <code class="codeph">UPDATE</code>和<code class="codeph">DELETE</code>具有可选的<code class="codeph">RETURNING</code> <code class="codeph">INTO</code>子句，该子句可以返回PL / SQL记录变量中受影响的行。
                        </p>
                        <div class="section">
                           <p>有关此子句的信息，请参阅<span class="q">“返回到<a href="RETURNING-INTO-clause.html#GUID-38F735B9-1100-45AF-AE71-18FB74A899BE" title="RETURNING INTO子句指定用于存储子句所属语句返回的值的变量。">子句</a> ”</span> 。
                           </p>
                        </div>
                        <!-- class="section" -->
                        <div class="example" id="GUID-95EA1F91-8196-4F77-8EA3-36CAD9B43855__BABHDGIG">
                           <p class="titleinexample">示例5-52 UPDATE语句将值分配给记录变量</p>
                           <p>在此示例中， <code class="codeph">UPDATE</code>语句更新员工的薪水，并在记录变量中返回员工的姓名和新薪水。
                           </p><pre class="oac_no_warn" dir="ltr">DECLARE TYPE EmpRec IS RECORD（last_name employees.last_name％TYPE，salary employees.salary％TYPE）; <span class="bold">emp_info EmpRec;</span> old_salary employees.salary％TYPE; BEGIN SELECT工资INTO old_salary FROM employees WHERE employee_id = 100; <span class="bold">UPDATE员工</span> <span class="bold">SET薪水=工资* 1.1</span> <span class="bold">WHERE employee_id = 100</span> <span class="bold">RETURNING last_name，salary INTO emp_info;</span> DBMS_OUTPUT.PUT_LINE（'|| emp_info.last_name ||'的薪水从'|| old_salary ||'提升到'|| emp_info.salary）;结束; /</pre><p>结果：</p><pre class="oac_no_warn" dir="ltr">国王的薪水从24000增加到26400</pre></div>
                        <!-- class="example" -->
                     </div>
                  </div>
               </div><a id="LNPLS1530"></a><a id="LNPLS1414"></a><div class="props_rev_3"><a id="GUID-6AB78084-231F-4BCA-A905-DB2069E4B885" name="GUID-6AB78084-231F-4BCA-A905-DB2069E4B885"></a><h4 id="LNPLS-GUID-6AB78084-231F-4BCA-A905-DB2069E4B885" class="sect4"><span class="enumeration_section">5.13.3</span>为记录变量分配NULL</h4>
                  <div>
                     <p>将值<code class="codeph">NULL</code>分配给记录变量会将值<code class="codeph">NULL</code>分配给其每个字段。
                     </p>
                     <div class="section">
                        <p>这个赋值是递归的;也就是说，如果一个字段是一个记录，那么它的字段也被赋值为<code class="codeph">NULL</code> 。</p>
                     </div>
                     <!-- class="section" -->
                     <div class="example" id="GUID-6AB78084-231F-4BCA-A905-DB2069E4B885__BABIFHFJ">
                        <p class="titleinexample">示例5-53为记录变量分配NULL</p>
                        <p>此示例在为其分配<code class="codeph">NULL</code>之前和之后打印记录变量的字段（其中一个是记录）。
                        </p><pre class="oac_no_warn" dir="ltr">DECLARE TYPE age_rec是记录（年INTEGER DEFAULT 35，月INTEGER DEFAULT 6）; TYPE name_rec是RECORD（第一个employees.first_name％TYPE DEFAULT'John'，last employees.last_name％TYPE DEFAULT'Doe'，age age_rec）; name name_rec; PROCEDURE print_name AS BEGIN DBMS_OUTPUT.PUT（NVL（name.first，'NULL'）||''）; DBMS_OUTPUT.PUT（NVL（name.last，'NULL'）||'，'）; DBMS_OUTPUT.PUT（NVL（TO_CHAR（name.age.years），'NULL'）||'yrs'）; DBMS_OUTPUT.PUT_LINE（NVL（TO_CHAR（name.age.months），'NULL'）||'mos'）;结束; BEGIN print_name; <span class="bold">name：= NULL;</span> print_name;结束; /</pre><p>结果：</p><pre class="oac_no_warn" dir="ltr">John Doe，35岁6 mos NULL NULL，NULL yrs NULL mos</pre></div>
                     <!-- class="example" -->
                  </div>
               </div>
            </div><a id="LNPLS496"></a><div class="props_rev_3"><a id="GUID-DFDE40BD-4B61-4C8A-B9CE-3FE01E21F658" name="GUID-DFDE40BD-4B61-4C8A-B9CE-3FE01E21F658"></a><h3 id="LNPLS-GUID-DFDE40BD-4B61-4C8A-B9CE-3FE01E21F658" class="sect3"><span class="enumeration_section">5.14</span>记录比较</h3>
               <div>
                  <p>无法针对无效，平等或不平等进行本地测试。</p>
                  <p>这些<code class="codeph">BOOLEAN</code>表达式是非法的：</p>
                  <ul style="list-style-type:disc">
                     <li>
                        <p><code class="codeph">My_Record是NULL</code></p>
                     </li>
                     <li>
                        <p><code class="codeph">My_Record_1 = My_Record_2</code></p>
                     </li>
                     <li>
                        <p><code class="codeph">My_Record_1&gt; My_Record_2</code></p>
                     </li>
                  </ul>
                  <p>您必须编写自己的函数来实现此类测试。有关编写函数的信息，请参阅<a href="plsql-subprograms.html#GUID-13BEBBEC-02D4-48E8-A059-DFEAC4751A3B" title="当PL / SQL函数具有RESULT_CACHE选项时，其结果将缓存在共享全局区域（SGA）中，因此连接到同一实例的会话可以在可用时重用这些结果。PL / SQL函数结果缓存与结果缓存共享其管理和可管理性基础结构。如果在DR单元（定义者权限单元）中包含已连接的用户数据库链接，则必须向将运行DR单元的用户授予INHERIT REMOTE PRIVILEGES权限。">PL / SQL子程序</a> 。
                  </p>
               </div>
            </div><a id="LNPLS452"></a><a id="LNPLS497"></a><div class="props_rev_3"><a id="GUID-AC5CEFCB-87AA-41FD-AE16-FFE66606E6B1" name="GUID-AC5CEFCB-87AA-41FD-AE16-FFE66606E6B1"></a><h3 id="LNPLS-GUID-AC5CEFCB-87AA-41FD-AE16-FFE66606E6B1" class="sect3"><span class="enumeration_section">5.15</span>将记录插入表中</h3>
               <div>
                  <p>SQL <code class="codeph">INSERT</code>语句的PL / SQL扩展允许您将记录插入表中。
                  </p>
                  <div class="section">
                     <p>记录必须代表表格的一行。有关更多信息，请参阅<span class="q">“ <a href="INSERT-statement-extension.html#GUID-D81224C4-06DE-4635-A850-41D29D4A8E1B" title="SQL INSERT语句的PL / SQL扩展允许您在single_table_insert的values_clause中指定记录名，而不是在insert_into_clause中指定列列表">INSERT语句扩展</a> ”</span> 。有关在表中插入记录的限制，请参阅<span class="q">“ <a href="plsql-collections-and-records.html#GUID-EC8E43E9-8356-4256-857A-D8109F2CF324">对记录插入和更新的限制</a> ”</span> 。
                     </p>
                     <p>要有效地将记录集合插入表中，请将<code class="codeph">INSERT</code>语句放在<code class="codeph">FORALL</code>语句中。有关<code class="codeph">FORALL</code>语句的信息，请参阅<span class="q">“ <a href="plsql-optimization-and-tuning.html#GUID-6D4A1425-64DD-4723-8AAE-87B0A51A2854" title="FORALL语句是批量SQL的一个特性，它将批处理中的DML语句从PL / SQL发送到SQL，而不是一次发送一个。">FORALL语句</a> ”</span> 。
                     </p>
                  </div>
                  <!-- class="section" -->
                  <div class="example" id="GUID-AC5CEFCB-87AA-41FD-AE16-FFE66606E6B1__CHDBEBEB">
                     <p class="titleinexample">示例5-54通过插入默认值记录来初始化表</p>
                     <p>此示例创建表<code class="codeph">schedule</code>并通过将默认值放入记录并将记录插入表中的每周来初始化它。（ <code class="codeph">COLUMN</code>格式化命令来自SQL * Plus。）
                     </p><pre class="oac_no_warn" dir="ltr">DROP TABLE计划; CREATE TABLE调度（周NUMBER，Mon VARCHAR2（10），Tue VARCHAR2（10），Wed VARCHAR2（10），Thu VARCHAR2（10），Fri VARCHAR2（10），Sat VARCHAR2（10），Sun VARCHAR2（10））; DECLARE default_week schedule％ROWTYPE;我号码; BEGIN default_week。星期一：='0800-1700'; default_week。星期二：='0800-1700'; default_week。周三：='0800-1700'; default_week。周四：='0800-1700'; default_week。周五：='0800-1700'; default_week。周六：='休息日'; default_week。太阳：='休息日'; FOR i IN 1..6 LOOP default_week.week：= i; <span class="bold">INSERT INTO安排VALUES default_week;</span>结束循环;结束; / COLUMN周格式99专栏星期一格式A9列周二格式A9栏周三格式A9栏周四格式A9栏周五格式A9栏周六格式A9栏太阳格式A9选择*从时间表;</pre><p>结果：</p><pre class="oac_no_warn" dir="ltr">星期三太阳了！ -  --------- --------- --------- ---------  - ------- --------- --------- 1 0800-1700 0800-1700 0800-1700 0800-1700 0800-1700 Day Off Day Off 2 0800-1700 0800 -1700 0800-1700 0800-1700 0800-1700休息日关闭3 0800-1700 0800-1700 0800-1700 0800-1700 0800-1700休息日关闭4 0800-1700 0800-1700 0800-1700 0800-1700 0800- 1700休息日休息日5 0800-1700 0800-1700 0800-1700 0800-1700 0800-1700休息日休息日6 0800-1700 0800-1700 0800-1700 0800-1700 0800-1700休息日休息日</pre></div>
                  <!-- class="example" -->
               </div>
            </div><a id="LNPLS500"></a><a id="LNPLS499"></a><div class="props_rev_3"><a id="GUID-11D63245-591D-4CBF-BFBA-8F3C0AE0E968" name="GUID-11D63245-591D-4CBF-BFBA-8F3C0AE0E968"></a><h3 id="LNPLS-GUID-11D63245-591D-4CBF-BFBA-8F3C0AE0E968" class="sect3"><span class="enumeration_section">5.16</span>使用记录更新行</h3>
               <div>
                  <p>SQL <code class="codeph">UPDATE</code>语句的PL / SQL扩展允许您使用记录更新一个或多个表行。
                  </p>
                  <div class="section">
                     <p>记录必须代表表格的一行。有关更多信息，请参阅<span class="q">“ <a href="UPDATE-statement-extensions.html#GUID-8FA29ACC-5E0F-4BE1-BC33-2B882C87E36D">UPDATE语句扩展</a> ”</span> 。
                     </p>
                     <p>有关使用记录更新表行的<span class="q"><a href="plsql-collections-and-records.html#GUID-EC8E43E9-8356-4256-857A-D8109F2CF324">限制</a></span> ，请参阅<span class="q">“ <a href="plsql-collections-and-records.html#GUID-EC8E43E9-8356-4256-857A-D8109F2CF324">对记录插入和更新的限制</a> ”</span> 。
                     </p>
                     <p>要使用记录集合有效地更新一组行，请将<code class="codeph">UPDATE</code>语句放在<code class="codeph">FORALL</code>语句中。有关<code class="codeph">FORALL</code>语句的信息，请参阅<span class="q">“ <a href="plsql-optimization-and-tuning.html#GUID-6D4A1425-64DD-4723-8AAE-87B0A51A2854" title="FORALL语句是批量SQL的一个特性，它将批处理中的DML语句从PL / SQL发送到SQL，而不是一次发送一个。">FORALL语句</a> ”</span> 。
                     </p>
                  </div>
                  <!-- class="section" -->
                  <div class="example" id="GUID-11D63245-591D-4CBF-BFBA-8F3C0AE0E968__BABDGCDI">
                     <p class="titleinexample">示例5-55使用记录更新行</p>
                     <p>此示例通过将新值放入记录并使用该记录更新表的前三行来更新表<code class="codeph">schedule</code>的前三周（在<a href="plsql-collections-and-records.html#GUID-AC5CEFCB-87AA-41FD-AE16-FFE66606E6B1__CHDBEBEB">示例5-54中</a>定义）。
                     </p><pre class="oac_no_warn" dir="ltr">DECLARE default_week schedule％ROWTYPE; BEGIN default_week。星期一：='休息日'; default_week。星期二：='0900-1800'; default_week。周三：='0900-1800'; default_week。周四：='0900-1800'; default_week。周五：='0900-1800'; default_week。周六：='0900-1800'; default_week。太阳：='休息日'; FOR i IN 1..3 LOOP default_week.week：= i; UPDATE schedule SET ROW = default_week WHERE week = i;结束循环;结束; / SELECT * FROM schedule;</pre><p>结果：</p><pre class="oac_no_warn" dir="ltr">星期三太阳了！ -  --------- --------- --------- ---------  - ------- --------- --------- 1天休息0900-1800 0900-1800 0900-1800 0900-1800 0900-1800休息日2天休息0900- 1800 0900-1800 0900-1800 0900-1800 0900-1800休息日3天休息0900-1800 0900-1800 0900-1800 0900-1800 0900-1800休息日4 0800-1700 0800-1700 0800-1700 0800-1700 0800- 1700休息日休息日5 0800-1700 0800-1700 0800-1700 0800-1700 0800-1700休息日休息日6 0800-1700 0800-1700 0800-1700 0800-1700 0800-1700休息日休息日</pre></div>
                  <!-- class="example" -->
               </div>
            </div><a id="LNPLS502"></a><div class="props_rev_3"><a id="GUID-EC8E43E9-8356-4256-857A-D8109F2CF324" name="GUID-EC8E43E9-8356-4256-857A-D8109F2CF324"></a><h3 id="LNPLS-GUID-EC8E43E9-8356-4256-857A-D8109F2CF324" class="sect3"><span class="enumeration_section">5.17</span>记录插入和更新的限制</h3>
               <div>
                  <p>这些限制适用于记录插入和更新：</p>
                  <ul style="list-style-type:disc">
                     <li>
                        <p>仅在以下位置允许记录变量：</p>
                        <ul style="list-style-type:disc">
                           <li>
                              <p>在<code class="codeph">UPDATE</code>语句中的<code class="codeph">SET</code>子句的右侧</p>
                           </li>
                           <li>
                              <p>在<code class="codeph">INSERT</code>语句的<code class="codeph">VALUES</code>子句中</p>
                           </li>
                           <li>
                              <p>在<code class="codeph">RETURNING</code>子句的<code class="codeph">INTO</code>子条款中</p>
                           </li>
                        </ul>
                        <p><code class="codeph">SELECT</code>列表， <code class="codeph">WHERE</code>子句， <code class="codeph">GROUP</code> <code class="codeph">BY</code>子句或<code class="codeph">ORDER</code> <code class="codeph">BY</code>子句中不允许记录变量。
                        </p>
                     </li>
                     <li>
                        <p>关键字<code class="codeph">ROW</code>仅允许在<code class="codeph">SET</code>子句的左侧。此外，您不能将<code class="codeph">ROW</code>与子查询一起使用。
                        </p>
                     </li>
                     <li>
                        <p>在<code class="codeph">UPDATE</code>语句中，如果使用<code class="codeph">ROW</code> ，则只允许一个<code class="codeph">SET</code>子句。
                        </p>
                     </li>
                     <li>
                        <p>如果<code class="codeph">INSERT</code>语句的<code class="codeph">VALUES</code>子句包含记录变量，则子句中不允许使用其他变量或值。
                        </p>
                     </li>
                     <li>
                        <p>如果<code class="codeph">RETURNING</code>子句的<code class="codeph">INTO</code>子条款包含记录变量，则子条款中不允许使用其他变量或值。
                        </p>
                     </li>
                     <li>
                        <p>这些不受支持：</p>
                        <ul style="list-style-type:disc">
                           <li>
                              <p>嵌套的<code class="codeph">RECORD</code>类型</p>
                           </li>
                           <li>
                              <p>返回<code class="codeph">RECORD</code>类型的函数</p>
                           </li>
                           <li>
                              <p>使用<code class="codeph">EXECUTE</code> <code class="codeph">IMMEDIATE</code>语句记录插入和更新。
                              </p>
                           </li>
                        </ul>
                     </li>
                  </ul>
               </div>
            </div>
         </div>
      </article>
   </body>
</html>