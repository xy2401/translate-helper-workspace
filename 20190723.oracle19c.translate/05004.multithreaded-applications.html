<html lang="en-us" dir="ltr" xml:lang="en-us">
   <head>
      <meta http-equiv="Content-Type" content="text/html; charset=utf-8"></meta>
      <meta name="viewport" content="width=device-width, initial-scale=1"></meta>
      <meta http-equiv="X-UA-Compatible" content="IE=edge"></meta>
      <title>多线程应用程序</title>
      <meta property="og:site_name" content="Oracle Help Center"></meta>
      <meta property="og:title" content="Programmer&#39;s Guide"></meta>
      <meta property="og:description" content=""></meta>
      <link rel="stylesheet" href="/sp_common/book-template/ohc-book-template/css/book.css"></link>
      <link rel="shortcut icon" href="/sp_common/book-template/ohc-common/img/favicon.ico"></link>
      <meta name="application-name" content="Programmer&#39;s Guide"></meta>
      <meta name="generator" content="DITA Open Toolkit version 1.8.5 (Mode = doc)"></meta>
      <meta name="plugin" content="SP_docbuilder HTML plugin release 18.2.2"></meta>
      <link rel="alternate" href="c-c-programmers-guide.pdf" title="PDF File" type="application/pdf"></link>
      <meta name="robots" content="all"></meta>
      <link rel="schema.dcterms" href="http://purl.org/dc/terms/"></link>
      <meta name="dcterms.created" content="2019-01-11T03:52:01-08:00"></meta>
      
      <meta name="dcterms.dateCopyrighted" content="1996, 2019"></meta>
      <meta name="dcterms.category" content="database"></meta>
      <meta name="dcterms.identifier" content="E96467-01"></meta>
      
      <meta name="dcterms.product" content="en/database/oracle/oracle-database/19"></meta>
      
      <link rel="prev" href="precompiler-options.html" title="Previous" type="text/html"></link>
      <link rel="next" href="applications.html" title="Next" type="text/html"></link>
      <script>
        document.write('<style type="text/css">');
        document.write('body > .noscript, body > .noscript ~ * { visibility: hidden; }');
        document.write('</style>');
     </script>
      <script src="/sp_common/book-template/requirejs/require.js" data-main="/sp_common/book-template/ohc-book-template/js/book-config"></script>
      <script>
            if (window.require === undefined) {
                document.write('<script data-main="sp_common/book-template/ohc-book-template/js/book-config" src="sp_common/book-template/requirejs/require.js"><\/script>');
                document.write('<link href="sp_common/book-template/ohc-book-template/css/book.css" rel="stylesheet"/>');
            }
        </script>
      <script type="application/json" id="ssot-metadata">{"primary":{"category":{"short_name":"database","element_name":"Database","display_in_url":true},"suite":{"short_name":"oracle","element_name":"Oracle","display_in_url":true},"product_group":{"short_name":"not-applicable","element_name":"Not applicable","display_in_url":false},"product":{"short_name":"oracle-database","element_name":"Oracle Database","display_in_url":true},"release":{"short_name":"19","element_name":"Release 19","display_in_url":true}}}</script>
      
    <meta name="dcterms.title" content="Pro*C/C++ Programmer&#39;s Guide"></meta>
    <meta name="dcterms.isVersionOf" content="LNPCC"></meta>
    <meta name="dcterms.release" content="Release 19"></meta>
  </head>
   <body dir="ltr">
      <div class="noscript alert alert-danger text-center" role="alert">
         <a href="precompiler-options.html" class="pull-left"><span class="glyphicon glyphicon-chevron-left" aria-hidden="true"></span>上一页</a> <a href="applications.html" class="pull-right">下一页<span class="glyphicon glyphicon-chevron-right" aria-hidden="true"></span></a> <span class="fa fa-exclamation-triangle" aria-hidden="true"></span>必须启用JavaScript才能正确显示此内容</div>
      <article>
         <header>
            <ol class="breadcrumb" vocab="http://schema.org/" typeof="BreadcrumbList">
               <li property="itemListElement" typeof="ListItem"><a href="index.html" property="item" typeof="WebPage"><span property="name">程序员指南</span></a></li>
               <li property="itemListElement" typeof="ListItem"><a href="introduction-and-concepts.html" property="item" typeof="WebPage"><span property="name">介绍和概念</span></a></li>
               <li class="active" property="itemListElement" typeof="ListItem">多线程应用程序</li>
            </ol>
            <a id="GUID-76B52DE9-54B7-4F3C-9905-AADE6420BE84" name="GUID-76B52DE9-54B7-4F3C-9905-AADE6420BE84"></a><a id="LNPCC3942"></a>
            
            <h2 id="LNPCC-GUID-76B52DE9-54B7-4F3C-9905-AADE6420BE84" class="sect2"><span class="enumeration_chapter">11</span>多线程应用程序</h2>
         </header>
         <div class="ind">
            <div>
               <p>如果您的开发平台不支持线程，请忽略本章。本章包含以下主题：</p>
               <ul style="list-style-type:disc">
                  <li>
                     <p><a href="multithreaded-applications.html#GUID-2999998F-4A39-4755-BE90-9FA85D849B89">什么是线程？</a></p>
                  </li>
                  <li>
                     <p><a href="multithreaded-applications.html#GUID-7AF05404-AC22-4D5C-B0AA-E1183E5CB454">Pro * C / C ++中的运行时上下文</a></p>
                  </li>
                  <li>
                     <p><a href="multithreaded-applications.html#GUID-928D94A1-E24A-468E-9DD0-5C3DFF322A6D">运行时上下文使用模型</a></p>
                  </li>
                  <li>
                     <p><a href="multithreaded-applications.html#GUID-26030E8D-B89D-4ED7-BF0E-A9EF46AC99E7">多线程应用程序的用户界面功能</a></p>
                  </li>
                  <li>
                     <p><a href="multithreaded-applications.html#GUID-ED68DC7B-67E9-4C8A-981B-90525EC9AF11">多线程示例</a></p>
                  </li>
                  <li>
                     <p><a href="multithreaded-applications.html#GUID-617D04C1-EA48-44D0-B5E6-E8CB9C241B07">连接池</a></p>
                     <div class="infoboxnote" id="GUID-76B52DE9-54B7-4F3C-9905-AADE6420BE84__GUID-987F10D7-8FD9-43D7-9463-0A2AACA8D869">
                        <p class="notep1">注意：</p>
                        <p>将XA与Pro * C / C ++预编译器一起使用时，必须使用XA提供的多线程。使用EXEC SQL ENABLE THREADS语句使用Pro * C / C ++提供的多线程将导致错误。</p>
                     </div>
                  </li>
               </ul>
            </div><a id="LNPCC3943"></a><div class="props_rev_3"><a id="GUID-2999998F-4A39-4755-BE90-9FA85D849B89" name="GUID-2999998F-4A39-4755-BE90-9FA85D849B89"></a><h3 id="LNPCC-GUID-2999998F-4A39-4755-BE90-9FA85D849B89" class="sect3"><span class="enumeration_section">11.1</span>什么是线程？
               </h3>
               <div>
                  <p>多线程应用程序在共享地址空间中执行多个线程。线程是在进程内执行的“轻量级”子进程。它们共享代码和数据段，但有自己的程序计数器，机器寄存器和堆栈。全局变量和静态变量对于所有线程都是通用的，并且通常需要互斥机制来管理来自应用程序内多个线程的这些变量的访问。 <span class="bold"> </span>互斥锁是确保保持数据完整性的同步机制。
                  </p>
                  <p>有关互斥锁的进一步讨论，请参阅有关多线程的文本。有关多线程应用程序的更多详细信息，请参阅线程函数的文档。</p>
                  <p>Pro * C / C ++支持使用以下方法开发多线程Oracle Server应用程序（在支持多线程应用程序的平台上）：</p>
                  <ul style="list-style-type:disc">
                     <li>
                        <p>用于生成线程安全代码的命令行选项</p>
                     </li>
                     <li>
                        <p>嵌入式SQL语句和指令，支持多线程</p>
                     </li>
                     <li>
                        <p>线程安全的SQLLIB和其他客户端Oracle库</p>
                        <div class="infoboxnote" id="GUID-2999998F-4A39-4755-BE90-9FA85D849B89__GUID-16CB15C1-B15D-420C-83ED-80249C472000">
                           <p class="notep1">注意：</p>
                           <p>虽然您的平台可能支持特定的线程包，但请参阅特定于平台的Oracle文档以确定Oracle是否支持它。</p>
                        </div>
                     </li>
                  </ul>
                  <p>本章的主题讨论如何使用前面的功能来开发多线程Pro * C / C ++应用程序：</p>
                  <ul style="list-style-type:disc">
                     <li>
                        <p>多线程应用程序的运行时上下文</p>
                     </li>
                     <li>
                        <p>两个使用运行时上下文的模型</p>
                     </li>
                     <li>
                        <p>多线程应用程序的用户界面功能</p>
                     </li>
                     <li>
                        <p>使用Pro * C / C ++编写多线程应用程序的编程注意事项</p>
                     </li>
                     <li>
                        <p>一个示例多线程Pro * C / C ++应用程序</p>
                     </li>
                  </ul>
               </div>
            </div><a id="LNPCC3945"></a><a id="LNPCC3944"></a><div class="props_rev_3"><a id="GUID-7AF05404-AC22-4D5C-B0AA-E1183E5CB454" name="GUID-7AF05404-AC22-4D5C-B0AA-E1183E5CB454"></a><h3 id="LNPCC-GUID-7AF05404-AC22-4D5C-B0AA-E1183E5CB454" class="sect3"><span class="enumeration_section">11.2</span> Pro * C / C ++中的运行时上下文</h3>
               <div>
                  <p>为了松散地耦合线程和连接，Pro * C / C ++引入了运行时上下文的概念。运行时上下文包括以下资源及其当前状态：</p>
                  <ul style="list-style-type:disc">
                     <li>
                        <p>与一个或多个Oracle服务器的零个或多个连接</p>
                     </li>
                     <li>
                        <p>用于服务器连接的零个或多个游标</p>
                     </li>
                     <li>
                        <p>内联选项，例如MODE，HOLD_CURSOR，RELEASE_CURSOR和SELECT_ERROR</p>
                     </li>
                  </ul>
                  <p>Pro * C / C ++不是简单地支持线程和连接之间的松散耦合，而是提供了将线程与运行时上下文松散耦合的能力。Pro * C / C ++允许您的应用程序定义运行时上下文的句柄，并将该句柄从一个线程传递到另一个线程。</p>
                  <p>例如，交互式应用程序生成一个线程T1，以执行查询并将前10行返回给应用程序。然后T1终止。在获得必要的用户输入之后，产生另一个线程T2（或者使用现有线程），并且T1的运行时上下文被传递给T2，因此它可以通过处理相同的光标来获取接下来的10行。<a href="multithreaded-applications.html#GUID-7AF05404-AC22-4D5C-B0AA-E1183E5CB454__I999536">见图11-1</a> 。
                  </p>
                  <div class="figure" id="GUID-7AF05404-AC22-4D5C-B0AA-E1183E5CB454__I999536">
                     <p class="titleinfigure">图11-1松散耦合连接和线程</p><img src="img/pc_81021.gif" alt="下面是图11-1的描述" title="下面是图11-1的描述" longdesc="img_text/pc_81021.html"><br><a href="img_text/pc_81021.html">“图11-1松耦合连接和螺纹”的描述</a></div>
                  <!-- class="figure" -->
               </div>
            </div><a id="LNPCC3946"></a><div class="props_rev_3"><a id="GUID-928D94A1-E24A-468E-9DD0-5C3DFF322A6D" name="GUID-928D94A1-E24A-468E-9DD0-5C3DFF322A6D"></a><h3 id="LNPCC-GUID-928D94A1-E24A-468E-9DD0-5C3DFF322A6D" class="sect3"><span class="enumeration_section">11.3</span>运行时上下文使用模型</h3>
               <div>
                  <p>这里显示了在多线程Pro * C / C ++应用程序中使用运行时上下文的两种可能模型：</p>
                  <ul style="list-style-type:disc">
                     <li>
                        <p>多个线程共享单个运行时上下文</p>
                     </li>
                     <li>
                        <p>多个线程使用单独的运行时上下文</p>
                     </li>
                  </ul>
                  <p>无论您使用的运行时环境的模型，你<span class="italic">不能</span> <span class="italic">在同一时间</span>共享多个线程之间的运行时环境。如果两个或多个线程同时尝试使用相同的运行时上下文，则会发生运行时错误。
                  </p>
               </div><a id="LNPCC3948"></a><a id="LNPCC3947"></a><div class="props_rev_3"><a id="GUID-4F3DEE2C-2C2D-489D-B579-6232FD53D370" name="GUID-4F3DEE2C-2C2D-489D-B579-6232FD53D370"></a><h4 id="LNPCC-GUID-4F3DEE2C-2C2D-489D-B579-6232FD53D370" class="sect4"><span class="enumeration_section">11.3.1</span>共享单个运行时上下文的多个线程</h4>
                  <div>
                     <p><a href="multithreaded-applications.html#GUID-4F3DEE2C-2C2D-489D-B579-6232FD53D370__I997987">图11-2</a>显示了在多线程环境中运行的应用程序。各种线程共享一个运行时上下文来处理一个或多个SQL语句。同样，多个线程不能同时共享运行时上下文。<a href="multithreaded-applications.html#GUID-4F3DEE2C-2C2D-489D-B579-6232FD53D370__I997987">图11-2中</a>的互斥锁说明了如何防止并发使用。
                     </p>
                     <div class="figure" id="GUID-4F3DEE2C-2C2D-489D-B579-6232FD53D370__I997987">
                        <p class="titleinfigure">图11-2线程间的上下文共享</p><img src="img/pc_81023.gif" alt="下面是图11-2的描述" title="下面是图11-2的描述" longdesc="img_text/pc_81023.html"><br><a href="img_text/pc_81023.html">“图11-2线程间的上下文共享”的说明</a></div>
                     <!-- class="figure" -->
                  </div>
               </div><a id="LNPCC3950"></a><a id="LNPCC3949"></a><div class="props_rev_3"><a id="GUID-663040E5-EC31-4BA6-974C-4F2CDFCB7BA3" name="GUID-663040E5-EC31-4BA6-974C-4F2CDFCB7BA3"></a><h4 id="LNPCC-GUID-663040E5-EC31-4BA6-974C-4F2CDFCB7BA3" class="sect4"><span class="enumeration_section">11.3.2</span>多个线程共享多个运行时上下文</h4>
                  <div>
                     <p><a href="multithreaded-applications.html#GUID-663040E5-EC31-4BA6-974C-4F2CDFCB7BA3__I997998">图11-3</a>显示了使用多个运行时上下文执行多个线程的应用程序。在这种情况下，应用程序不需要互斥锁，因为每个线程都有一个专用的运行时上下文。
                     </p>
                     <div class="figure" id="GUID-663040E5-EC31-4BA6-974C-4F2CDFCB7BA3__I997998">
                        <p class="titleinfigure">图11-3线程间无上下文共享</p><img src="img/pc_81022.gif" alt="下面是图11-3的描述" title="下面是图11-3的描述" longdesc="img_text/pc_81022.html"><br><a href="img_text/pc_81022.html">“图11-3线程间没有上下文共享”的描述</a></div>
                     <!-- class="figure" -->
                  </div>
               </div>
            </div><a id="LNPCC3951"></a><div class="props_rev_3"><a id="GUID-26030E8D-B89D-4ED7-BF0E-A9EF46AC99E7" name="GUID-26030E8D-B89D-4ED7-BF0E-A9EF46AC99E7"></a><h3 id="LNPCC-GUID-26030E8D-B89D-4ED7-BF0E-A9EF46AC99E7" class="sect3"><span class="enumeration_section">11.4</span>多线程应用程序的用户界面功能</h3>
               <div>
                  <p>Pro * C / C ++预编译器提供以下用户界面功能以支持多线程应用程序：</p>
                  <ul style="list-style-type:disc">
                     <li>
                        <p>命令行选项，THREADS = YES | NO</p>
                     </li>
                     <li>
                        <p>嵌入式SQL语句和指令</p>
                     </li>
                     <li>
                        <p>线程安全的SQLLIB公共函数</p>
                     </li>
                  </ul>
               </div><a id="LNPCC3952"></a><div class="props_rev_3"><a id="GUID-6CEB5A08-DA41-4C52-9745-5401D0268AB0" name="GUID-6CEB5A08-DA41-4C52-9745-5401D0268AB0"></a><h4 id="LNPCC-GUID-6CEB5A08-DA41-4C52-9745-5401D0268AB0" class="sect4"><span class="enumeration_section">11.4.1</span>螺纹选项</h4>
                  <div>
                     <p>如果在命令行中指定了THREADS = YES，则Pro * C / C ++预编译器会确保生成的代码是线程安全的，前提是您遵循这些准则。指定THREADS = YES后，Pro * C / C ++将验证所有SQL语句是否在用户定义的运行时上下文范围内执行。如果您的程序不符合此要求，则会返回预编译器错误。</p>
                  </div>
                  <div>
                     <div class="relinfo">
                        <p><strong>相关话题</strong></p>
                        <ul>
                           <li><a href="multithreaded-applications.html#GUID-656F2729-900A-4319-8D8A-D37C6FC7D538">编程注意事项</a></li>
                        </ul>
                     </div>
                  </div>
                  
               </div><a id="LNPCC3953"></a><div class="props_rev_3"><a id="GUID-C403BBA8-68C3-4293-AE0D-7AAAE0F099DB" name="GUID-C403BBA8-68C3-4293-AE0D-7AAAE0F099DB"></a><h4 id="LNPCC-GUID-C403BBA8-68C3-4293-AE0D-7AAAE0F099DB" class="sect4"><span class="enumeration_section">11.4.2</span>嵌入式SQL语句和指令</h4>
                  <div>
                     <div class="section">
                        <p>以下嵌入式SQL语句和指令支持运行时上下文和线程的定义和用法：</p>
                        <ul style="list-style-type:disc">
                           <li>
                              <p>EXEC SQL ENABLE THREADS;</p>
                           </li>
                           <li>
                              <p>EXEC SQL语境分配： <span class="italic">context_var</span> ;</p>
                           </li>
                           <li>
                              <p>EXEC SQL语境使用{： <span class="italic">context_var</span> |默认};</p>
                           </li>
                           <li>
                              <p>EXEC SQL语境免费： <span class="italic">context_var</span> ;</p>
                           </li>
                        </ul>
                        <p>对于这些EXEC SQL语句， <span class="italic">context_var</span>是运行时上下文的句柄，必须声明类型为<span class="bold">sql_context</span> ，如下所示：</p><pre class="oac_no_warn" dir="ltr">sql_context &lt;context_variable&gt;;</pre><p>使用DEFAULT意味着默认（全局）运行时上下文将用于所有嵌入式SQL语句，这些语句在词法上遵循，直到另一个CONTEXT USE语句覆盖它。</p>
                     </div>
                     <!-- class="section" -->
                  </div><a id="LNPCC3954"></a><div class="props_rev_3"><a id="GUID-B8F99814-11DA-4C1C-A834-7C1AAA592D2E" name="GUID-B8F99814-11DA-4C1C-A834-7C1AAA592D2E"></a><h5 id="LNPCC-GUID-B8F99814-11DA-4C1C-A834-7C1AAA592D2E" class="sect5"><span class="enumeration_section">11.4.2.1</span> EXEC SQL ENABLE THREADS</h5>
                     <div>
                        <div class="section">
                           <p>此可执行SQL语句初始化支持多个线程的进程。这必须是多线程应用程序中的第一个可执行SQL语句。</p>
                           <div class="infoboxnote" id="GUID-B8F99814-11DA-4C1C-A834-7C1AAA592D2E__GUID-7C2A5208-C6DD-456E-A38C-8EB6BF0B7186">
                              <p class="notep1">注意：</p>
                              <p>将XA与Pro * C / C ++预编译器一起使用时，必须使用XA提供的多线程。使用EXEC SQL ENABLE THREADS语句使用Pro * C提供的多线程将导致错误。</p>
                           </div>
                        </div>
                        <!-- class="section" -->
                     </div>
                     <div>
                        <div class="relinfo">
                           <p><strong>相关话题</strong></p>
                           <ul>
                              <li><a href="embedded-SQL-statements-and-directives.html#GUID-2642F5BD-2FD8-405D-AA16-709A8492EE82">ENABLE THREADS（可执行嵌入式SQL扩展）</a></li>
                           </ul>
                        </div>
                     </div>
                     
                  </div><a id="LNPCC3955"></a><div class="props_rev_3"><a id="GUID-2FF99F73-B08A-4C85-BF1B-B7272F378DE5" name="GUID-2FF99F73-B08A-4C85-BF1B-B7272F378DE5"></a><h5 id="LNPCC-GUID-2FF99F73-B08A-4C85-BF1B-B7272F378DE5" class="sect5"><span class="enumeration_section">11.4.2.2</span> EXEC SQL上下文分配</h5>
                     <div>
                        <div class="section">
                           <p>此可执行SQL语句为指定的运行时上下文分配和初始化内存;必须将run-context变量声明为sql_context类型。</p>
                        </div>
                        <!-- class="section" -->
                     </div>
                     <div>
                        <div class="relinfo">
                           <p><strong>相关话题</strong></p>
                           <ul>
                              <li><a href="embedded-SQL-statements-and-directives.html#GUID-A41631CC-DE29-43D7-9CDB-BBFA22305DAA">CONTEXT ALLOCATE（可执行的嵌入式SQL扩展）</a></li>
                           </ul>
                        </div>
                     </div>
                     
                  </div><a id="LNPCC3956"></a><div class="props_rev_3"><a id="GUID-87367EFE-A9A8-4692-97A3-A956D5E234D6" name="GUID-87367EFE-A9A8-4692-97A3-A956D5E234D6"></a><h5 id="LNPCC-GUID-87367EFE-A9A8-4692-97A3-A956D5E234D6" class="sect5"><span class="enumeration_section">11.4.2.3</span> EXEC SQL上下文使用</h5>
                     <div>
                        <div class="section">
                           <p><a id="d70695e384" class="indexterm-anchor"></a><a id="d70695e386" class="indexterm-anchor"></a><a id="d70695e390" class="indexterm-anchor"></a><a id="d70695e392" class="indexterm-anchor"></a><a id="d70695e396" class="indexterm-anchor"></a>该指令指示预编译器将指定的运行时上下文用于后续可执行SQL语句。必须使用EXEC SQL CONTEXT ALLOCATE语句预先分配指定的运行时上下文。
                           </p>
                           <p>EXEC SQL CONTEXT USE指令与EXEC SQL WHENEVER指令的工作方式类似，它会影响在给定源文件中位于其后的所有可执行SQL语句，而不考虑标准C范围规则。在以下示例中， <code class="codeph">function2()</code>的UPDATE语句使用全局运行时上下文<span class="italic">ctx1</span> ：</p><pre class="oac_no_warn" dir="ltr">sql_context ctx1; / *声明全局上下文ctx1 * / function1（）{sql_context：ctx1; / *声明本地上下文ctx1 * / EXEC SQL语境分配：ctx1; EXEC SQL语境使用：ctx1; EXEC SQL INSERT INTO ... / *本地ctx1用于此stmt * / ...} function2（）{EXEC SQL UPDATE ... / * global ctx1用于此stmt * /}</pre><p>要在使用本地上下文后使用全局上下文，请将此代码添加到function1（）：</p><pre class="oac_no_warn" dir="ltr">function1（）{sql_context：ctx1; / *声明本地上下文ctx1 * / EXEC SQL语境分配：ctx1; EXEC SQL语境使用：ctx1; EXEC SQL INSERT INTO ... / *本地ctx1用于此stmt * / EXEC SQL语境使用默认值; EXEC SQL INSERT INTO ... / *全局ctx1用于此stmt * / ...}</pre><p>在下一个示例中，没有全局运行时上下文。预编译器引用UPDATE语句的生成代码中的<span class="italic">ctx1</span>运行时上下文。但是， <code class="codeph">function2()</code>域中没有上下文变量，因此在编译时会生成错误。
                           </p><pre class="oac_no_warn" dir="ltr">function1（）{sql_context ctx1; / *本地上下文变量声明* / EXEC SQL语境分配：ctx1; EXEC SQL语境使用：ctx1;用于此语句的EXEC SQL INSERT INTO ... / * ctx1 * / ...} function2（）{EXEC SQL UPDATE .../ *错误！范围内没有上下文变量* /}</pre></div>
                        <!-- class="section" -->
                     </div>
                     <div>
                        <div class="relinfo">
                           <p><strong>相关话题</strong></p>
                           <ul>
                              <li><a href="embedded-SQL-statements-and-directives.html#GUID-CEEE04CB-1726-4DFD-B097-0489DC93C188">上下文对象选项GET（可执行的嵌入式SQL扩展）</a></li>
                              <li><a href="embedded-SQL-statements-and-directives.html#GUID-A41631CC-DE29-43D7-9CDB-BBFA22305DAA">CONTEXT ALLOCATE（可执行的嵌入式SQL扩展）</a></li>
                           </ul>
                        </div>
                     </div>
                     
                  </div><a id="LNPCC3957"></a><div class="props_rev_3"><a id="GUID-4C6D78C5-6DBA-446D-B2CE-F73BB832FA25" name="GUID-4C6D78C5-6DBA-446D-B2CE-F73BB832FA25"></a><h5 id="LNPCC-GUID-4C6D78C5-6DBA-446D-B2CE-F73BB832FA25" class="sect5"><span class="enumeration_section">11.4.2.4</span> EXEC SQL语境免费</h5>
                     <div>
                        <div class="section">
                           <p>此可执行SQL语句释放与指定运行时上下文关联的内存，并在主程序变量中放置空指针。</p>
                        </div>
                        <!-- class="section" -->
                     </div>
                     <div>
                        <div class="relinfo">
                           <p><strong>相关话题</strong></p>
                           <ul>
                              <li><a href="embedded-SQL-statements-and-directives.html#GUID-70685080-1E78-44DB-A1BF-2ABEE6F373FB">CONTEXT FREE（可执行嵌入式SQL扩展）</a></li>
                           </ul>
                        </div>
                     </div>
                     
                  </div>
               </div><a id="LNPCC3958"></a><div class="props_rev_3"><a id="GUID-CC122C8C-09B5-49D0-8E78-FFD26D07E711" name="GUID-CC122C8C-09B5-49D0-8E78-FFD26D07E711"></a><h4 id="LNPCC-GUID-CC122C8C-09B5-49D0-8E78-FFD26D07E711" class="sect4"><span class="enumeration_section">11.4.3</span>上下文使用示例</h4>
                  <div>
                     <div class="section">
                        <p>以下代码片段显示了如何对两种典型的编程模型使用嵌入式SQL语句和预编译器指令;他们使用<span class="italic">thread_create（）</span>来创建线程。
                        </p>
                        <p>第一个示例显示了使用多个运行时上下文的多个线程：</p><pre class="oac_no_warn" dir="ltr">main（）{sql_context ctx1，ctx2; / *声明运行时上下文* / EXEC SQL ENABLE THREADS; EXEC SQL语境分配：ctx1; EXEC SQL语境分配：ctx2; .../ * spawn thread，执行function1（在线程中）传递ctx1 * / thread_create（...，function1，ctx1）; / * spawn thread，执行function2（在线程中）传递ctx2 * / thread_create（...，function2，ctx2）; ...EXEC SQL语境免费：ctx1; EXEC SQL语境免费：ctx2; ...void function1（sql_context ctx）{EXEC SQL CONTEXT USE：ctx; / *在运行时上下文ctx1上执行可执行的SQL语句！* / ...void function2（sql_context ctx）{EXEC SQL CONTEXT USE：ctx; / *在运行时上下文ctx2上执行可执行的SQL语句！* / ...}</pre><p>下一个示例显示如何使用共享公共运行时上下文的多个线程。因为在<code class="codeph">function1()</code>和<code class="codeph">function2()</code>执行的SQL语句可能同时执行，所以必须在每个<span class="italic">可执行的</span> EXEC SQL语句周围放置互斥锁，以确保对数据进行连续，因此安全的操作。
                        </p><pre class="oac_no_warn" dir="ltr">main（）{sql_context ctx; / *声明运行时上下文* / EXEC SQL语境分配：ctx; .../ * spawn thread，执行function1（在线程中）传递ctx * / thread_create（...，function1，ctx）; / * spawn thread，执行function2（在线程中）传递ctx * / thread_create（...，function2，ctx）; ...void function1（sql_context ctx）{EXEC SQL CONTEXT USE：ctx; / *在运行时上下文ctx上执行SQL语句。* / ...void function2（sql_context ctx）{EXEC SQL CONTEXT USE：ctx; / *在运行时上下文ctx上执行SQL语句。* / ...}</pre></div>
                     <!-- class="section" -->
                  </div>
               </div><a id="LNPCC3959"></a><div class="props_rev_3"><a id="GUID-656F2729-900A-4319-8D8A-D37C6FC7D538" name="GUID-656F2729-900A-4319-8D8A-D37C6FC7D538"></a><h4 id="LNPCC-GUID-656F2729-900A-4319-8D8A-D37C6FC7D538" class="sect4"><span class="enumeration_section">11.4.4</span>编程注意事项</h4>
                  <div>
                     <p>虽然Oracle确保SQLLIB代码是线程安全的，但您有责任确保Pro * C / C ++源代码能够与线程一起正常工作;例如，仔细考虑使用静态和全局变量。</p>
                     <p>此外，多线程应用程序需要有关以下内容的设计决策：</p>
                     <ul style="list-style-type:disc">
                        <li>
                           <p>将SQLCA声明为线程安全结构，通常是一个自动变量，每个运行时上下文一个</p>
                        </li>
                        <li>
                           <p>声明SQLDA是一个线程安全的结构，就像SQLCA一样，通常是一个自动变量，每个运行时上下文都有一个</p>
                        </li>
                        <li>
                           <p>以线程安全的方式声明主机变量，换句话说，仔细考虑使用静态和全局主机变量。</p>
                        </li>
                        <li>
                           <p>避免在多个线程中同时使用运行时上下文</p>
                        </li>
                        <li>
                           <p>是否使用默认数据库连接或使用AT子句显式定义它们</p>
                        </li>
                     </ul>
                     <p>此外，在给定时间，在运行时上下文中，只有一个可执行的嵌入式SQL语句（例如，EXEC SQL UPDATE）可能是未完成的。</p>
                     <p>预编译应用程序的现有要求也适用。例如，对给定游标的所有引用必须出现在同一源文件中。</p>
                  </div>
               </div>
            </div><a id="LNPCC3960"></a><div class="props_rev_3"><a id="GUID-ED68DC7B-67E9-4C8A-981B-90525EC9AF11" name="GUID-ED68DC7B-67E9-4C8A-981B-90525EC9AF11"></a><h3 id="LNPCC-GUID-ED68DC7B-67E9-4C8A-981B-90525EC9AF11" class="sect3"><span class="enumeration_section">11.5</span>多线程示例</h3>
               <div>
                  <div class="section">
                     <p>以下程序是编写多线程嵌入式SQL应用程序的一种方法。该程序创建与线程一样多的会话。每个线程执行零个或多个事务，这些事务在称为“记录”的瞬态结构中指定。</p>
                     <div class="infoboxnote" id="GUID-ED68DC7B-67E9-4C8A-981B-90525EC9AF11__GUID-E7B83E67-7DC5-4BE4-BB87-747E0CB20721">
                        <p class="notep1">注意：</p>
                        <p>该程序专为运行Solaris的Sun工作站开发。 <span class="bold"> </span>DCE或Solaris线程包可用于此程序。有关线程包的可用性，请参阅特定于平台的文档。
                        </p>
                     </div><pre class="oac_no_warn" dir="ltr">/ * *名称：Thread_example1.pc * *描述：该程序说明了如何在*与预编译器的结合中使用线程。该程序创建与线程一样多的*会话。每个线程执行零个或多个事务，这些事务在称为“记录”的瞬态*结构中指定。*要求：*该程序要求表'ACCOUNTS'在架构* scott / tiger中。ACCOUNTS的描述是：* SQL&gt; desc accounts * Name Null？输入* ------------------------------- ------- ------ * ACCOUNT NUMBER（ 36）*平衡编号（36,2）* *为了正确执行，表格应填入账户* 10001至10008。* * * / #include &lt;stdio.h&gt; #include &lt;stdlib.h&gt; #include &lt;string.h&gt; #include &lt;sqlca.h&gt; #define _EXC_OS_ _EXC__UNIX #define _CMA_OS_ _CMA__UNIX #ifdef DCE_THREADS #include &lt;pthread.h&gt; #else #include &lt;thread.h&gt; #endif / *函数原型* / void err_report（）; #ifdef DCE_THREADS void do_transaction（）; #else void * do_transaction（）; #endif void get_transaction（）; void logon（）; void logoff（）; #define CONNINFO“scott / tiger”#define THREADS 3 struct parameters {sql_context * ctx; int thread_id; }; typedef struct参数; struct record_log {char action; unsigned int from_account; unsigned int to_account;浮动金额; }; typedef struct record_log record_log; record_log records [] = {{'M'，10001,10002,12.50}，{'M'，10001,10003,25.00}，{'M'，10001,10003,123.00}，{'M'，10001,10003 ，125.00}，{'M'，10002,10006,12.23}，{'M'，10007,10008,225.23}，{'M'，10002,10008,0.70}，{'M'，10001,10003,11.30 }，{'M'，10003,10002,47.50}，{'M'，10002,10006,125.00}，{'M'，10007,10008,225.00}，{'M'，10002,10008,0.70}， {'M'，10001,10003,11.00}，{'M'，10003,10002,47.50}，{'M'，10002,10006,125.00}，{'M'，10007,10008,225.00}，{' M'，10002,10008,0.70}，{'M'，10001,10003,11.00}，{'M'，10003,10002,47.50}，{'M'，10008,10001,1034.54}}; static unsigned int trx_nr = 0; #ifdef DCE_THREADS pthread_mutex_t互斥; #else mutex_t mutex; ＃万一 /*********************************************** ********************** *主要************************** ****************************************** / main（）{sql_context ctx [ THREADS]; #ifdef DCE_THREADS pthread_t thread_id [THREADS]; pthread_addr_t状态; #else thread_t thread_id [THREADS]; int状态; #endif parameters params [THREADS]; int i; EXEC SQL ENABLE THREADS;执行SQL WHENEVER SQLERROR DO err_report（sqlca）; / *通过连接THREADS次* /为（i = 0; i &lt;THREADS; i ++）{printf（“Start Session％d ....”，i）创建THREADS会话; EXEC SQL语境分配：ctx [i];登录（CTX [I]，CONNINFO）; / *为事务检索创建互斥锁* / #ifdef DCE_THREADS if（pthread_mutex_init（＆mutex，pthread_mutexattr_default））＃else if（mutex_init（＆mutex，USYNC_THREAD，NULL））＃endif {printf（“无法初始化互斥锁\ n”） ;出口（1）; } / *产生线程* / for（i = 0; i &lt;THREADS; i ++）{params [i] .ctx = ctx [i]; PARAMS [I] .thread_id = I; printf（“Thread％d ...”，i）; #ifdef DCE_THREADS if（pthread_create（＆thread_id [i]，pthread_attr_default，（pthread_startroutine_t）do_transaction，（pthread_addr_t）＆params [i]））＃else if（status = thr_create（NULL，0，do_transaction，＆params [i]，0，＆thread_id [i]））＃endif printf（“Cant create thread％d \ n”，i）; else printf（“Created \ n”）; } / *注销会话....* / for（i = 0; i &lt;THREADS; i ++）{/ *等待线程结束* / printf（“Thread％d ....”，i）; #ifdef DCE_THREADS if（pthread_join（thread_id [i]，＆status））printf（“等待线程％终止时出错\ n”，i）; else printf（“stopped \ n”）; printf（“Detach thread ...”）; if（pthread_detach（＆thread_id [i]））printf（“错误分离线程！\ n“）;否则printf（”独立！\ n“）; #else if（thr_join（thread_id [i]，NULL，NULL））printf（”错误等待线程终止\ n“）; #endif printf（”Stop Session％d ....“， i）;注销（ctx [i]）; EXEC SQL语境免费：ctx [i];} / *销毁互斥锁 / #ifdef DCE_THREADS if（pthread_mutex_destroy（＆mutex））#else if（mutex_destroy（＆mutex））#endif { printf（“无法销毁互斥锁\ n”）;退出（1）;}} / ***************************** **************************************** *功能：do_transaction * *说明：此功能从* records数组中执行一个事务。记录数组由* get_transaction函数“管理”。* * ************************************************ ******************** / #ifdef DCE_THREADS void do_transaction（params）#else void * do_transaction（params）#endif parameters * params; {struct sqlca sqlca; record_log * trx; sql_context ctx = params-&gt; ctx; / *完成所有交易？* / while（trx_nr &lt;（sizeof（records）/ sizeof（record_log）））{get_transaction（＆trx）;执行SQL WHENEVER SQLERROR DO err_report（sqlca）; EXEC SQL语境使用：ctx; printf（“Thread％d执行事务\ n”，params-&gt; thread_id）; switch（trx-&gt; action）{case'M'：EXEC SQL UPDATE ACCOUNTS SET BALANCE = BALANCE +：trx-&gt; amount WHERE ACCOUNT =：trx-&gt; to_account; EXEC SQL UPDATE帐户设置平衡=平衡 - ：trx-&gt;金额WHERE ACCOUNT =：trx-&gt; from_account;打破;默认值：break; EXEC SQL COMMIT; / *********************************************** ****************** *功能：err_report * *描述：此例程打印出最近的错误* *************** ******************* / void err_report（sqlca）struct sqlca sqlca; {if（sqlca.sqlcode &lt;0）printf（“\ n％。* s \ n \ n”，sqlca.sqlerrm.sqlerrml，sqlca.sqlerrm.sqlerrmc）;出口（1）; / ************************************************ ***************** *功能：登录* *说明：以USERNAME / PASSWORD * ***************登录数据库************************************************** / void logon（ctx，connect_info）sql_context ctx; char * connect_info; {EXEC SQL WHENEVER SQLERROR DO err_report（sqlca）; EXEC SQL语境使用：ctx; EXEC SQL CONNECT：connect_info;的printf（“连接！\ n“）;} / ******************************************* *********************** *功能：logoff * *描述：此例程注销数据库* ************ ************************************************** **** / void logoff（ctx）sql_context ctx; {EXEC SQL WHENEVER SQLERROR DO err_report（sqlca）; EXEC SQL上下文使用：ctx; EXEC SQL COMMIT WORK RELEASE; printf（“已注销！\ n“）;} / ******************************************* *********************** *函数：get_transaction * *描述：此例程返回要处理的下一个事务* ********** ************************************************** ****** / void get_transaction（trx）record_log ** trx; {#ifdef DCE_THREADS if（pthread_mutex_lock（＆mutex））#else if（mutex_lock（＆mutex））#endif printf（“无法锁定互斥锁\ n” ）; * trx =＆records [trx_nr]; trx_nr ++; #ifdef DCE_THREADS if（pthread_mutex_unlock（＆mutex））#else if（mutex_unlock（＆mutex））#endif printf（“无法解锁互斥锁\ n”）;}</pre></div>
                  <!-- class="section" -->
               </div>
            </div><a id="LNPCC3962"></a><a id="LNPCC3961"></a><div class="props_rev_3"><a id="GUID-617D04C1-EA48-44D0-B5E6-E8CB9C241B07" name="GUID-617D04C1-EA48-44D0-B5E6-E8CB9C241B07"></a><h3 id="LNPCC-GUID-617D04C1-EA48-44D0-B5E6-E8CB9C241B07" class="sect3"><span class="enumeration_section">11.6</span>连接池</h3>
               <div>
                  <p>连接池是一组到数据库的物理连接，可以由多个连接重用。连接池功能的目标是通过避免每个连接使用专用连接来提高性能并减少资源使用。</p>
                  <p><a href="multithreaded-applications.html#GUID-617D04C1-EA48-44D0-B5E6-E8CB9C241B07__I1005251">图11-4</a>说明了连接池功能的功能。在此示例中，应用程序的四个线程使用连接池与数据库交互。连接池有两个物理连接。连接池句柄由四个使用不同运行时上下文的线程使用。
                  </p>
                  <div class="figure" id="GUID-617D04C1-EA48-44D0-B5E6-E8CB9C241B07__I1005251">
                     <p class="titleinfigure">图11-4连接池</p><img src="img/connection_pooling.gif" alt="连接池" title="连接池"></div>
                  <!-- class="figure" --><pre class="oac_no_warn" dir="ltr">thread1（）{EXEC SQL CONTEXT ALLOCATE：ctx1; EXEC SQL语境使用：ctxl; EXEC SQL CONNECT：uid AT：TC1 USING：db_string; ...} thread2（）{EXEC SQL CONTEXT ALLOCATE：ctx2; EXEC SQL CONNECT：uid AT：TC2使用：db_string; ...} thread3（）{EXEC SQL CONTEXT ALLOCATE：ctx3; EXEC SQL CONNECT：uid AT：TC3 USING：db_string; EXEC SQL AT：TC3 SELECT count（*）into：count FROM emp; ...} thread4（）{EXEC SQL CONTEXT ALLOCATE：ctx4; EXEC SQL CONNECT：uid AT：TC4使用：db_string; ...}</pre><p>在该示例中，四个命名连接TC1，TC2，TC3和TC4分别是由线程T1，T2，T3和T4创建的虚拟连接。来自不同运行时上下文的命名连接TC1，TC2，TC3和TC4共享相同的连接池，并共享连接池中可用的物理数据库连接。两个物理连接C1和C2提供四个命名连接并连接到同一个数据库。</p>
                  <p>当接收到来自线程T1的第一个连接请求TC1时，SQLLIB创建一个连接池，其中一个物理连接C1到数据库。当来自线程T2的另一个连接请求TC2被发送到同一数据库时，C1向数据库提供TC2请求（如果它是空闲的）。否则，创建新的物理连接C2以服务该请求。如果来自名为TC3的线程T3的另一个连接请求进入，则TC3要么等待指定的时间，要么返回错误消息，如果物理连接C1和C2都忙。</p>
                  <p>当线程T2需要使用TC2命名连接选择数据时，它获取任何空闲物理连接C1或C2。在提供请求后，所选连接将再次在连接池中可用，以便另一个命名或虚拟连接可以使用相同的物理连接。</p>
               </div><a id="LNPCC3963"></a><div class="props_rev_3"><a id="GUID-C18807FF-E7DE-40F5-881B-4E2D956AF011" name="GUID-C18807FF-E7DE-40F5-881B-4E2D956AF011"></a><h4 id="LNPCC-GUID-C18807FF-E7DE-40F5-881B-4E2D956AF011" class="sect4"><span class="enumeration_section">11.6.1</span>关于使用连接池功能</h4>
                  <div>
                     <p>本节包括以下主题：</p>
                     <ul style="list-style-type:disc">
                        <li>
                           <p><a href="multithreaded-applications.html#GUID-CEEB543A-D85F-4716-850E-0D159A3A78E1">如何启用连接池</a></p>
                        </li>
                        <li>
                           <p><a href="multithreaded-applications.html#GUID-656DF4D2-B963-4E32-9EFB-8F5093FEC6A3">连接池的命令行选项</a></p>
                        </li>
                        <li>
                           <p><a href="multithreaded-applications.html#GUID-BD0208BF-3330-4546-A06A-A19E91346F71">例</a></p>
                        </li>
                        <li>
                           <p><a href="multithreaded-applications.html#GUID-5CB36ADC-ADC1-48D2-BFDC-6301235A7E14">性能调优</a></p>
                        </li>
                     </ul>
                  </div><a id="LNPCC3964"></a><div class="props_rev_3"><a id="GUID-CEEB543A-D85F-4716-850E-0D159A3A78E1" name="GUID-CEEB543A-D85F-4716-850E-0D159A3A78E1"></a><h5 id="LNPCC-GUID-CEEB543A-D85F-4716-850E-0D159A3A78E1" class="sect5"><span class="enumeration_section">11.6.1.1</span>如何启用连接池</h5>
                     <div>
                        <p>要在预编译应用程序时启用连接池，用户必须设置命令行选项<code class="codeph">CPOOL=YES</code> 。基于<code class="codeph">CPOOL=YES/NO</code> ，启用或禁用连接池功能。
                        </p>
                        <div class="infoboxnote" id="GUID-CEEB543A-D85F-4716-850E-0D159A3A78E1__GUID-151D3AAE-FE8D-4EA1-8834-07058F8941E4">
                           <p class="notep1">注意：</p>
                           <p></p>
                           <ul style="list-style-type:disc">
                              <li>
                                 <p>默认情况下， <code class="codeph">CPOOL</code>设置为<code class="codeph">NO</code> ，因此禁用连接池功能。无法内联启用或禁用此功能。
                                 </p>
                              </li>
                              <li>
                                 <p>即使<code class="codeph">CPOOL</code>设置为<code class="codeph">YES</code> ，也不会使用外部操作系统身份验证创建连接池。</p>
                              </li>
                           </ul>
                        </div>
                     </div>
                  </div><a id="LNPCC3966"></a><a id="LNPCC3965"></a><div class="props_rev_3"><a id="GUID-656DF4D2-B963-4E32-9EFB-8F5093FEC6A3" name="GUID-656DF4D2-B963-4E32-9EFB-8F5093FEC6A3"></a><h5 id="LNPCC-GUID-656DF4D2-B963-4E32-9EFB-8F5093FEC6A3" class="sect5"><span class="enumeration_section">11.6.1.2</span>连接池的命令行选项</h5>
                     <div>
                        <div class="section">
                           <p><a href="multithreaded-applications.html#GUID-656DF4D2-B963-4E32-9EFB-8F5093FEC6A3__g1014720" title="连接池的命令行选项">表11-1</a>列出了连接池的命令行选项：</p>
                        </div>
                        <!-- class="section" -->
                        <div class="tblformalwide" id="GUID-656DF4D2-B963-4E32-9EFB-8F5093FEC6A3__g1014720">
                           <p class="titleintable">表11-1连接池的命令行选项</p>
                           <table cellpadding="4" cellspacing="0" class="FormalWide" title="连接池的命令行选项" width="100%" border="1" summary="Command Line Options for Connection Pooling" frame="hsides" rules="rows">
                              <thead>
                                 <tr align="left" valign="top">
                                    <th align="left" valign="bottom" width="14%" id="d70695e708">选项</th>
                                    <th align="left" valign="bottom" width="11%" id="d70695e712">有效值</th>
                                    <th align="left" valign="bottom" width="12%" id="d70695e715">默认</th>
                                    <th align="left" valign="bottom" width="64%" id="d70695e718">备注</th>
                                 </tr>
                              </thead>
                              <tbody>
                                 <tr align="left" valign="top">
                                    <td align="left" valign="top" width="14%" id="d70695e723" headers="d70695e708 ">
                                       <p>CPOOL</p>
                                    </td>
                                    <td align="left" valign="top" width="11%" headers="d70695e723 d70695e712 ">
                                       <p>是/否</p>
                                    </td>
                                    <td align="left" valign="top" width="12%" headers="d70695e723 d70695e715 ">
                                       <p>没有</p>
                                    </td>
                                    <td align="left" valign="top" width="64%" headers="d70695e723 d70695e718 ">
                                       <p>基于此选项，预编译器会生成相应的代码，指示SQLLIB启用或禁用连接池功能。</p>
                                       <p><span class="bold">注意</span> ：如果此选项设置为NO，则预编译器将忽略其他连接池选项。
                                       </p>
                                    </td>
                                 </tr>
                                 <tr align="left" valign="top">
                                    <td align="left" valign="top" width="14%" id="d70695e740" headers="d70695e708 ">
                                       <p>CMAX</p>
                                    </td>
                                    <td align="left" valign="top" width="11%" headers="d70695e740 d70695e712 ">
                                       <p>有效值为1到65535。</p>
                                    </td>
                                    <td align="left" valign="top" width="12%" headers="d70695e740 d70695e715 ">
                                       <p>100</p>
                                    </td>
                                    <td align="left" valign="top" width="64%" headers="d70695e740 d70695e718 ">
                                       <p>指定可以为数据库打开的最大物理连接数。CMAX值必须至少为CMIN + CINCR。</p>
                                       <p><span class="bold">注意</span> ：达到此值后，将无法打开更多物理连接。
                                       </p>
                                       <p>在典型的应用程序中，运行100个并发数据库操作已经足够了。用户可以设置适当的值。</p>
                                    </td>
                                 </tr>
                                 <tr align="left" valign="top">
                                    <td align="left" valign="top" width="14%" id="d70695e759" headers="d70695e708 ">
                                       <p>CMIN</p>
                                    </td>
                                    <td align="left" valign="top" width="11%" headers="d70695e759 d70695e712 ">
                                       <p>有效值为1到（CMAX-CINCR）。</p>
                                    </td>
                                    <td align="left" valign="top" width="12%" headers="d70695e759 d70695e715 ">
                                       <p>2</p>
                                    </td>
                                    <td align="left" valign="top" width="64%" headers="d70695e759 d70695e718 ">
                                       <p>指定连接池中的最小物理连接数。最初，通过CMIN指定的所有物理连接都将打开到服务器。随后，仅在必要时打开物理连接。用户应将CMIN设置为应用程序要运行的计划或预期并发语句的总数，以获得最佳性能。默认值设置为2。</p>
                                    </td>
                                 </tr>
                                 <tr align="left" valign="top">
                                    <td align="left" valign="top" width="14%" id="d70695e772" headers="d70695e708 ">
                                       <p>CINCR</p>
                                    </td>
                                    <td align="left" valign="top" width="11%" headers="d70695e772 d70695e712 ">
                                       <p>有效值为1到（CMAX-CMIN）。</p>
                                    </td>
                                    <td align="left" valign="top" width="12%" headers="d70695e772 d70695e715 ">
                                       <p>1</p>
                                    </td>
                                    <td align="left" valign="top" width="64%" headers="d70695e772 d70695e718 ">
                                       <p>如果当前物理连接数小于CMAX，则允许应用程序设置要向数据库打开的物理连接的下一个增量。为避免创建不必要的额外连接，默认值设置为1。</p>
                                    </td>
                                 </tr>
                                 <tr align="left" valign="top">
                                    <td align="left" valign="top" width="14%" id="d70695e785" headers="d70695e708 ">
                                       <p>CTIMEOUT</p>
                                    </td>
                                    <td align="left" valign="top" width="11%" headers="d70695e785 d70695e712 ">
                                       <p>有效值为1到65535。</p>
                                    </td>
                                    <td align="left" valign="top" width="12%" headers="d70695e785 d70695e715 ">
                                       <p>0表示未设置;因此不会超时。</p>
                                    </td>
                                    <td align="left" valign="top" width="64%" headers="d70695e785 d70695e718 ">
                                       <p>空闲超过指定时间（以秒为单位）的物理连接将被终止，以保持最佳数量的开放物理连接。如果未设置此属性，则物理连接永远不会超时。因此，在连接池终止之前，物理连接不会关闭。</p>
                                       <p><span class="bold">注意</span> ：创建新的物理连接将花费往返服务器。
                                       </p>
                                    </td>
                                 </tr>
                                 <tr align="left" valign="top">
                                    <td align="left" valign="top" width="14%" id="d70695e802" headers="d70695e708 ">
                                       <p>CNOWAIT</p>
                                    </td>
                                    <td align="left" valign="top" width="11%" headers="d70695e802 d70695e712 ">
                                       <p>有效值为1到65535。</p>
                                    </td>
                                    <td align="left" valign="top" width="12%" headers="d70695e802 d70695e715 ">
                                       <p>0表示未设置;因此等待免费连接。</p>
                                    </td>
                                    <td align="left" valign="top" width="64%" headers="d70695e802 d70695e718 ">
                                       <p>此属性确定当池中的所有其他物理连接都忙时，应用程序是否必须重复尝试进行物理连接，并且物理连接的总数已达到其最大值。如果物理连接不可用且无法再打开物理连接，则在设置此属性时会引发错误。否则，呼叫将等待，直到获得另一个连接。默认情况下，不设置CNOWAIT，因此线程将等待，直到它可以获取空闲连接，而不是返回错误。</p>
                                    </td>
                                 </tr>
                              </tbody>
                           </table>
                        </div>
                        <!-- class="inftblhruleinformal" -->
                        <div class="section">
                           <p>典型的多线程应用程序会创建一个“n”个物理连接池。需要通过在预编译期间提供CMIN值来指定'n'值。在第一次连接调用时创建到数据库的最小物理连接数（CMIN）。对于新的传入请求，将执行从虚拟连接（命名连接）到物理连接的映射，如以下部分所述：</p>
                           <p><span class="bold">情况1：</span>如果物理连接可用（在已打开的连接中），则此连接将提供新请求。
                           </p>
                           <p><span class="bold">案例2：</span>如果所有物理连接都在使用，那么，</p>
                           <p><span class="bold">情况2a：</span>如果打开的连接数未达到最大限制（CMAX），则创建新的CINCR连接，并使用其中一个连接来提供请求。</p>
                           <p><span class="bold">情况2b：</span>如果未设置CNOWAIT，已打开的连接数已达到最大限制（CMAX），则请求将等待直至获取连接。否则，应用程序显示错误消息<span class="italic">ORA 24401：无法打开进一步的连接</span> 。
                           </p>
                        </div>
                        <!-- class="section" -->
                     </div>
                  </div><a id="LNPCC3967"></a><div class="props_rev_3"><a id="GUID-BD0208BF-3330-4546-A06A-A19E91346F71" name="GUID-BD0208BF-3330-4546-A06A-A19E91346F71"></a><h5 id="LNPCC-GUID-BD0208BF-3330-4546-A06A-A19E91346F71" class="sect5"><span class="enumeration_section">11.6.1.3</span>示例</h5>
                     <div>
                        <p>有关以下示例的说明，请参见图11-4。</p><pre class="oac_no_warn" dir="ltr">设CMIN为1，CMAX为2，CINCR为1。
</pre><p>请考虑以下情形。当第一个请求TC1进入时，SQLLIB使用一个物理连接C1创建连接池。当另一个请求TC2进入时，应用程序检查C1是否空闲。当C1用于服务第一个请求（情况1）时，创建新的物理连接C2以服务该请求（情况2a）。如果另一个请求TC3进入，并且如果C1和C2都忙，则TC3要么等待指定的时间，要么返回错误消息（情况2b）。</p>
                     </div>
                  </div><a id="LNPCC3968"></a><div class="props_rev_3"><a id="GUID-5CB36ADC-ADC1-48D2-BFDC-6301235A7E14" name="GUID-5CB36ADC-ADC1-48D2-BFDC-6301235A7E14"></a><h5 id="LNPCC-GUID-5CB36ADC-ADC1-48D2-BFDC-6301235A7E14" class="sect5"><span class="enumeration_section">11.6.1.4</span>性能调整</h5>
                     <div>
                        <p>用户可以根据应用程序设置连接池参数以获得更好的性能。<a href="multithreaded-applications.html#GUID-05D7D388-917D-4C44-BD83-7E2F0973B0ED__i1004633">图11-5中</a>的性能图通过更改Pro * C / C ++ <a href="multithreaded-applications.html#GUID-05D7D388-917D-4C44-BD83-7E2F0973B0ED">演示程序</a>的CMIN值来说明性能增益<a href="multithreaded-applications.html#GUID-05D7D388-917D-4C44-BD83-7E2F0973B0ED">：1</a> 。<a href="multithreaded-applications.html#GUID-5ED02E9A-8B04-4E48-9762-A90F424DF54B">演示程序：2</a>通过更改CMAX参数说明了性能增益。
                        </p>
                     </div>
                  </div>
               </div><a id="LNPCC3970"></a><a id="LNPCC3969"></a><div class="props_rev_3"><a id="GUID-05D7D388-917D-4C44-BD83-7E2F0973B0ED" name="GUID-05D7D388-917D-4C44-BD83-7E2F0973B0ED"></a><h4 id="LNPCC-GUID-05D7D388-917D-4C44-BD83-7E2F0973B0ED" class="sect4"><span class="enumeration_section">11.6.2</span>演示程序：1</h4>
                  <div>
                     <div class="section">
                        <p>预编译演示程序时使用以下连接池参数：1。</p><pre class="oac_no_warn" dir="ltr">CMAX = 40 CINCR = 3 CMIN = 1到40之间的变化值CPOOL = YES CTIMEOUT  - 不设置</pre><p>（表示物理连接永不超时）</p><pre class="oac_no_warn" dir="ltr">CNOWAIT  - 不要设置</pre><p>（表示线程等待直到获得空闲连接;有关详细信息，请参阅<a href="multithreaded-applications.html#GUID-656DF4D2-B963-4E32-9EFB-8F5093FEC6A3__g1014720" title="连接池的命令行选项">表11-1</a> ）</p>
                        <p>以下部分提供了此示例所需的其他命令行选项：</p><pre class="oac_no_warn" dir="ltr">线程=是的</pre><div class="infoboxnote" id="GUID-05D7D388-917D-4C44-BD83-7E2F0973B0ED__GUID-F1B1103B-F307-4444-A9A3-CA7746D86BC7">
                           <p class="notep1">注意：</p>
                           <p>在此示例中，有40个线程，并且对本地数据库执行数据库操作。</p>
                        </div>
                        <p>据观察，CPOOL = NO（没有连接池），应用程序所用的时间为6.1秒，而CPOOL = YES（连接池）时，应用程序所用的最短时间为1.3秒（当CMIN为2）。</p>
                        <p>在这两种情况下，数据库查询操作所用的时间应保持不变，因为连接池只会减少CONNECT语句所用的时间。当CPOOL = NO时，应用程序将创建40个专用连接。当CPOOL = YES且CMIN = 2时，它最初将创建2个连接，并且只有当2个线程同时访问连接时，它才会创建更多连接。否则所有线程将共享这2个连接。因此，应用程序可能会避免38个连接，从而避免38次往返服务器以建立这些连接。这是看到三倍性能增益的地方。</p>
                        <div class="infoboxnote" id="GUID-05D7D388-917D-4C44-BD83-7E2F0973B0ED__GUID-8E8AE62C-8BFF-450F-B6F1-CD14B7B5089B">
                           <p class="notep1">注意：</p>
                           <p>这些结果在Sparc Ultra60单CPU，256 MB RAM机器上运行，在Solaris 2.6操作系统上运行一个Oracle服务器;服务器和客户端在同一台机器上运行。</p>
                        </div>
                        <div class="figure" id="GUID-05D7D388-917D-4C44-BD83-7E2F0973B0ED__i1004633">
                           <p class="titleinfigure">图11-5性能图</p><img width="361" src="img/performance_graph.gif" alt="性能图" title="性能图"></div>
                        <!-- class="figure" -->
                        <p>CPOOL = YES曲线表示启用连接池时应用程序所用的时间。CPOOL = NO曲线表示禁用连接池时应用程序所用的时间。</p>
                     </div>
                     <!-- class="section" -->
                  </div><a id="LNPCC3971"></a><div class="props_rev_3"><a id="GUID-9BF6B274-37D7-4785-B40C-6F66DAD4E60C" name="GUID-9BF6B274-37D7-4785-B40C-6F66DAD4E60C"></a><h5 id="LNPCC-GUID-9BF6B274-37D7-4785-B40C-6F66DAD4E60C" class="sect5"><span class="enumeration_section">11.6.2.1</span>示例</h5>
                     <div>
                        <div class="section"><pre class="oac_no_warn" dir="ltr">/ * * cpdemo1.pc * *描述：*程序创建的会话数与线程数一样多。*每个线程连接到默认数据库并执行* SELECT语句5次。每个线程都有自己的运行时上下文。* * / #include &lt;stdio.h&gt; #include &lt;stdlib.h&gt; #include &lt;string.h&gt; #include &lt;sqlca.h&gt; #define _EXC_OS_ _EXC__UNIX #define _CMA_OS_ _CMA__UNIX #ifdef DCE_THREADS #include &lt;pthread.h&gt;＃否则#include &lt;pthread.h&gt; typedef void * pthread_addr_t; typedef void *（* pthread_startroutine_t）（void *）; #define pthread_attr_default（const pthread_attr_t *）NULL #endif / *函数原型* / void err_report（）; void do_transaction（）; void get_transaction（）; void logon（）; void logoff（）; #define CONNINFO“hr / hr”#define THREADS 40个struct parameters {sql_context * ctx; int thread_id; }; typedef struct参数; struct timeval tp1; struct timeval tp2; / *************************************** *主要******** ******************************* / main（）{sql_context ctx [THREADS]; pthread_t thread_id [THREADS]; pthread_addr_t状态;参数参数[THREADS]; int i; EXEC SQL ENABLE THREADS;执行SQL WHENEVER SQLERROR DO err_report（sqlca）; if（gettimeofday（＆tp1，（void *）NULL）== -1）{perror（“First：”）;出口（0）; } / *通过连接THREADS次* /为（i = 0; i &lt;THREADS; i ++）{printf（“Start Session％d ....”，i）创建THREADS会话; EXEC SQL语境分配：ctx [i];登录（CTX [I]，CONNINFO）; } / *产生线程* / for（i = 0; i &lt;THREADS; i ++）{params [i] .ctx = ctx [i]; PARAMS [I] .thread_id = I; if（pthread_create（＆thread_id [i]，pthread_attr_default，（pthread_startroutine_t）do_transaction，（pthread_addr_t）＆params [i]））printf（“Cant create thread％d \ n”，i）; else printf（“Created Thread％d \ n”，i）; } / *注销会话....* / for（i = 0; i &lt;THREADS; i ++）{/ *等待线程结束* / if（pthread_join（thread_id [i]，＆status））printf（“等待线程％终止时出错\ n” ， 一世）; else printf（“stopped \ n”）; if（i == THREADS-1）{logoff（ctx [i]）; EXEC SQL语境免费：ctx [i]; if（gettimeofday（＆tp2，（void *）NULL）== -1）{perror（“Second：”）;出口（0）; } printf（“\ n \ n为程序执行总时间=％f \ n \ n”，（浮点）（tp2.tv_sec  -  tp1.tv_sec）+（（float）（tp2.tv_usec  -  tp1.tv_usec） /1000000.0））; / ************************************************ *********************** *功能：do_transaction *描述：该函数执行SELECT 5次并调用COMMIT。 ************************************************** ********************* / void do_transaction（params）parameters * params; {struct sqlca sqlca; int src_count; sql_context ctx = params-&gt; ctx;执行SQL WHENEVER SQLERROR DO err_report（sqlca）; EXEC SQL语境使用：ctx; printf（“Thread％d执行事务\ n”，params-&gt; thread_id）; EXEC SQL COMMIT; EXEC SQL SELECT count（*）into：来自EMPLOYEES的src_count; EXEC SQL SELECT count（*）into：来自EMPLOYEES的src_count; EXEC SQL SELECT count（*）into：来自EMPLOYEES的src_count; EXEC SQL SELECT count（*）into：来自EMPLOYEES的src_count; EXEC SQL SELECT count（*）into：来自EMPLOYEES的src_count; / ************************************************ ************** *功能：err_report *描述：此例程打印出最近的错误********************* ***************************************** / void err_report（sqlca）struct sqlca sqlca ; {if（sqlca.sqlcode &lt;0）printf（“\ n％。* s \ n \ n”，sqlca.sqlerrm.sqlerrml，sqlca.sqlerrm.sqlerrmc）;出口（1）; / ************************************************ ************ *功能：登录*说明：以USERNAME / PASSWORD的身份登录数据库********************** ************************************** / void logon（ctx，connect_info）sql_context ctx; char * connect_info; {EXEC SQL WHENEVER SQLERROR DO err_report（sqlca）; EXEC SQL语境使用：ctx; EXEC SQL CONNECT：connect_info;的printf（“连接！\ n“）;} / ******************************************* ******** *功能：logoff *说明：此例程注销数据库***************************** ********************** / void logoff（ctx）sql_context ctx; {EXEC SQL WHENEVER SQLERROR DO err_report（sqlca）; EXEC SQL语境使用：ctx; EXEC SQL COMMIT WORK RELEASE; printf（“已注销！\ n“）;}</pre></div>
                        <!-- class="section" -->
                     </div>
                  </div>
               </div><a id="LNPCC3972"></a><div class="props_rev_3"><a id="GUID-5ED02E9A-8B04-4E48-9762-A90F424DF54B" name="GUID-5ED02E9A-8B04-4E48-9762-A90F424DF54B"></a><h4 id="LNPCC-GUID-5ED02E9A-8B04-4E48-9762-A90F424DF54B" class="sect4"><span class="enumeration_section">11.6.3</span>演示程序：2</h4>
                  <div>
                     <div class="section">
                        <p>在预编译演示程序时使用以下连接池参数：2。</p>
                        <p>CMAX = 5到40之间的变化值</p>
                        <p>CINCR = 3</p>
                        <p>CMIN = 1到40之间的变化值</p>
                        <p>CPOOL = YES</p>
                        <p>CTIMEOUT  - 不要设置</p>
                        <p>（表示物理连接永不超时）</p>
                        <p>CNOWAIT  - 不要设置</p>
                        <p>（表示线程等待直到获得空闲连接;有关详细信息，请参阅<a href="multithreaded-applications.html#GUID-656DF4D2-B963-4E32-9EFB-8F5093FEC6A3__g1014720" title="连接池的命令行选项">表11-1</a> ）</p>
                        <p>以下部分提供了此示例所需的其他命令行选项：</p>
                        <p><code class="codeph">线程=是的</code></p>
                        <p>下图说明了cpdemo2的性能图。</p>
                        <div class="infoboxnote" id="GUID-5ED02E9A-8B04-4E48-9762-A90F424DF54B__GUID-14716A6B-22B7-46DE-AD09-71F26274C1ED">
                           <p class="notep1">注意：</p>
                           <p>在此示例中，有40个线程，并且对本地数据库执行数据库操作。</p>
                        </div>
                        <p>在此示例中，当使用CPOOL = NO时，当程序运行速度快大约2.3倍时，观察到CMIN = 5和CMAX = 14时的最佳性能。这比“cpdemo1”更少，尽管在启用连接池的情况下运行速度更快。原因是“cpdemo1”只执行简单的SELECT语句，而“cpdemo2”执行UPDATE和SELECT语句。因此，“cpdemo1”比执行数据库操作花费更多时间创建连接。启用连接池后，将创建时间，因为创建的连接较少。因此整体性能提高。由于与执行数据库操作相比，“cpdemo2”花费的时间更少，因此总体性能提升较少。</p>
                        <p>在下图中，CPOOL = YES曲线表示启用连接池时应用程序所用的时间。CPOOL = NO曲线表示禁用连接池时应用程序所用的时间。演示程序“cpdemo2”创建了40个线程。使用CPOOL = NO选项，每个线程都会建立自己与服务器的专用连接。因此创建了40个连接。当使用CPOOL = YES和CMAX = 14构建时，相同的演示程序最多可创建14个连接。这些连接在40个线程中共享，因此可以节省至少26个连接，从而避免26次往返服务器。</p>
                        <p>以下两个图表分别显示了针对不同CMIN和CMAX值的性能。</p>
                     </div>
                     <!-- class="section" -->
                  </div><a id="LNPCC3974"></a><a id="LNPCC3973"></a><div class="props_rev_3"><a id="GUID-F5ED74C5-CE08-4179-A852-EE73F2971627" name="GUID-F5ED74C5-CE08-4179-A852-EE73F2971627"></a><h5 id="LNPCC-GUID-F5ED74C5-CE08-4179-A852-EE73F2971627" class="sect5"><span class="enumeration_section">11.6.3.1</span>案例1：通过改变CMIN</h5>
                     <div>
                        <div class="section">
                           <div class="figure" id="GUID-F5ED74C5-CE08-4179-A852-EE73F2971627__GUID-09D97AE0-B1B9-4DA5-9540-3C98B5FAE951">
                              <p class="titleinfigure">图11-6性能图案例1</p><img width="327" src="img/performgraph_case1.gif" alt="性能图案例1" title="性能图案例1"></div>
                           <!-- class="figure" -->
                           <p>使用CPOOL = NO执行应用程序大约需要7.5秒。如果CPOOL = YES，CMIN = 8且CMAX = 14，则执行时间减少到4.5秒。因此，性能提升约为1.7倍。性能上的差异是因为不同的数据库操作（SELECT vs UPDATE），它纯粹是服务器端活动，超出了作为客户端功能的连接池功能的范围。</p>
                        </div>
                        <!-- class="section" -->
                     </div>
                  </div><a id="LNPCC3976"></a><a id="LNPCC3975"></a><div class="props_rev_3"><a id="GUID-027F630E-1648-49D4-89FF-F8E1AD35C197" name="GUID-027F630E-1648-49D4-89FF-F8E1AD35C197"></a><h5 id="LNPCC-GUID-027F630E-1648-49D4-89FF-F8E1AD35C197" class="sect5"><span class="enumeration_section">11.6.3.2</span>案例2：通过改变CMAX</h5>
                     <div>
                        <div class="section">
                           <div class="figure" id="GUID-027F630E-1648-49D4-89FF-F8E1AD35C197__GUID-AC7A8744-91AA-4E33-BCEF-8FD5A27A1E86">
                              <p class="titleinfigure">图11-7性能图案例2</p><img width="393" src="img/performgraph_case2.gif" alt="性能图案例2" title="性能图案例2"></div>
                           <!-- class="figure" -->
                           <p>对于上图，演示程序运行时CMIN = 5且CINCR = 3。在CMAX = 14时观察到最佳性能。CPOOL = NO，执行大约需要7.4秒。使用CPOOL = YES时，当CMAX = 14时，执行时间减少到大约3.1秒，从而导致2.3倍的性能提升。</p>
                           <p>性能改进随CMAX而变化。因此，为了获得给定应用的最佳性能，用户应改变CMIN和CMAX，直到达到最佳性能。</p>
                        </div>
                        <!-- class="section" -->
                     </div>
                  </div><a id="LNPCC3977"></a><div class="props_rev_3"><a id="GUID-34406BD8-6552-43C3-A3A8-1DF4CE862B9F" name="GUID-34406BD8-6552-43C3-A3A8-1DF4CE862B9F"></a><h5 id="LNPCC-GUID-34406BD8-6552-43C3-A3A8-1DF4CE862B9F" class="sect5"><span class="enumeration_section">11.6.3.3</span>示例</h5>
                     <div>
                        <div class="section"><pre class="oac_no_warn" dir="ltr">/ * * cpdemo2.pc *用于显示使用cpool选项时的性能增量的程序*使用cpool = no运行此程序。记录程序执行所需的时间* *比较执行时间* *此程序还演示了正确调整的CMAX *参数对性能的影响* *使用以下参数值运行程序* * CMIN = 5 * CINCR = 2 * CMAX = 20 * * / #include &lt;stdio.h&gt; #include &lt;sqlca.h&gt; #ifdef DCE_THREADS #include &lt;pthread.h&gt; #else #include &lt;sys / time.h&gt; #include &lt;pthread。 h&gt; typedef void * pthread_addr_t; typedef void *（* pthread_startroutine_t）（void *）; #define pthread_attr_default（const pthread_attr_t *）NULL #endif #define CONNINFO“hr / hr”#define THREADS 40 / ***** prototypes ************** * / void selectFunction（） ; void updateFunction（）; void err_report（struct sqlca sqlca）; / * ************************* * / / *****参数函数selectFunction，updateFunction * / struct parameters {sql_context ctx; char connName [20]; char dbName [20]; int thread_id; }; typedef struct参数; / ******************************************* /参数参数[THREADS] ; struct timeval tp1; struct timeval tp2; int main（）{int i; pthread_t thread_id [THREADS]; pthread_addr_t状态; int thrNos [THREADS]; for（i = 0; i &lt;THREADS; i ++）thrNos [i] = i; EXEC SQL ENABLE THREADS; / *执行程序前的时间* / if（gettimeofday（＆tp1，（void *）NULL）== -1）{perror（“First：”）;出口（0）;执行SQL WHENEVER SQLERROR DO err_report（sqlca）; / *将THREADS次连接到数据库* / for（i = 0; i &lt;THREADS; i ++）{strcpy（params [i] .dbName，“”）; sprintf（params [i] .connName，“conn％d”，i）; params [i] .thread_id = i; / *登录数据库* / EXEC SQL语境分配：params [i] .ctx; EXEC SQL语境使用：params [i] .ctx; EXEC SQL CONNECT：CONNINFO AT：params [i] .connName USING：params [i] .dbName; } / *创建THREADS个线程数* / for（i = 0; i &lt;THREADS; i ++）{printf（“Creating thread％d \ n”，i）; if（i％2）{/ *如果线程id为奇数* / if（pthread_create（＆thread_id [i]，pthread_attr_default，（pthread_startroutine_t）selectFunction，（pthread_addr_t）＆params [i]）执行select操作）printf（“Cant创建线程％d \ n“，i）; } else {/ *否则执行更新操作* / if（pthread_create（＆thread_id [i]，pthread_attr_default，（pthread_startroutine_t）updateFunction，（pthread_addr_t）＆params [i]））printf（“Cant create thread％d \ n”，i ）; for（i = 0; i &lt;THREADS; i ++）{if（pthread_join（thread_id [i]，＆status））printf（“等待线程％终止时出错\ n”，i）; } if（gettimeofday（＆tp2，（void *）NULL）== -1）{perror（“Second：”）;出口（0）; } printf（“\ n \ n为程序执行总时间=％f \ n \ n”，（浮点）（tp2.tv_sec  -  tp1.tv_sec）+（（float）（tp2.tv_usec  -  tp1.tv_usec） /1000000.0））; / *释放上下文* / for（i = 0; i &lt;THREADS; i ++）{EXEC SQL CONTEXT USE：params [i] .ctx; EXEC SQL AT：params [i] .connName COMMIT WORK RELEASE; EXEC SQL语境免费：params [i] .ctx; } return 0; } void selectFunction（parameters * params）{struct sqlca sqlca; char empName [110] [21]; printf（“Thread％d selection .... \ n”，params-&gt; thread_id）; EXEC SQL语境使用：params-&gt; ctx; EXEC SQL AT：params-&gt; connName从EMPLOYEES中选择FIRST_NAME到empName; printf（“Thread％d selected .... \ n”，params-&gt; thread_id）;返回0; void updateFunction（parameters * params）{struct sqlca sqlca; printf（“Thread％d Updating ... \ n”，params-&gt; thread_id）; EXEC SQL语境使用：params-&gt; ctx; EXEC SQL AT：params-&gt; connName update EMPLOYEES设置SALARY = 4000，其中DEPARTMENT_ID = 10; / *提交更改* / EXEC SQL AT：params-&gt; connName COMMIT; printf（“Thread％d Updated ... \ n”，params-&gt; thread_id）;返回0; } / *********** Oracle错误*********** / void err_report（struct sqlca sqlca）{if（sqlca.sqlcode &lt;0）printf（“\ n％。 * S \ n \ n”个，sqlca.sqlerrm.sqlerrml，sqlca.sqlerrm.sqlerrmc里）;出口（0）; }</pre></div>
                        <!-- class="section" -->
                     </div>
                  </div>
               </div>
            </div>
         </div>
      </article>
   </body>
</html>