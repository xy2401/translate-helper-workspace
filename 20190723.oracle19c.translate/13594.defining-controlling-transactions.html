<html lang="en-us" dir="ltr" xml:lang="en-us">
   <head>
      <meta http-equiv="Content-Type" content="text/html; charset=utf-8"></meta>
      <meta name="viewport" content="width=device-width, initial-scale=1"></meta>
      <meta http-equiv="X-UA-Compatible" content="IE=edge"></meta>
      <title>定义和控制交易</title>
      <meta property="og:site_name" content="Oracle Help Center"></meta>
      <meta property="og:title" content="Programmer&#39;s Guide to the Oracle Precompilers"></meta>
      <meta property="og:description" content=""></meta>
      <link rel="stylesheet" href="/sp_common/book-template/ohc-book-template/css/book.css"></link>
      <link rel="shortcut icon" href="/sp_common/book-template/ohc-common/img/favicon.ico"></link>
      <meta name="application-name" content="Programmer&#39;s Guide to the Oracle Precompilers"></meta>
      <meta name="generator" content="DITA Open Toolkit version 1.8.5 (Mode = doc)"></meta>
      <meta name="plugin" content="SP_docbuilder HTML plugin release 18.2.2"></meta>
      <link rel="alternate" href="programmers-guide-oracle-precompilers.pdf" title="PDF File" type="application/pdf"></link>
      <meta name="robots" content="all"></meta>
      <link rel="schema.dcterms" href="http://purl.org/dc/terms/"></link>
      <meta name="dcterms.created" content="2019-01-11T01:36:30-08:00"></meta>
      <meta name="dcterms.title" content="Programmer&#39;s Guide to the Oracle Precompilers"></meta>
      <meta name="dcterms.dateCopyrighted" content="2008, 2019"></meta>
      <meta name="dcterms.category" content="database"></meta>
      <meta name="dcterms.identifier" content="E96474-01"></meta>
      
      <meta name="dcterms.product" content="en/database/oracle/oracle-database/19"></meta>
      
      <link rel="prev" href="running-Oracle-precompilers.html" title="Previous" type="text/html"></link>
      <link rel="next" href="error-handling-diagnostics.html" title="Next" type="text/html"></link>
      <script>
        document.write('<style type="text/css">');
        document.write('body > .noscript, body > .noscript ~ * { visibility: hidden; }');
        document.write('</style>');
     </script>
      <script src="/sp_common/book-template/requirejs/require.js" data-main="/sp_common/book-template/ohc-book-template/js/book-config"></script>
      <script>
            if (window.require === undefined) {
                document.write('<script data-main="sp_common/book-template/ohc-book-template/js/book-config" src="sp_common/book-template/requirejs/require.js"><\/script>');
                document.write('<link href="sp_common/book-template/ohc-book-template/css/book.css" rel="stylesheet"/>');
            }
        </script>
      <script type="application/json" id="ssot-metadata">{"primary":{"category":{"short_name":"database","element_name":"Database","display_in_url":true},"suite":{"short_name":"oracle","element_name":"Oracle","display_in_url":true},"product_group":{"short_name":"not-applicable","element_name":"Not applicable","display_in_url":false},"product":{"short_name":"oracle-database","element_name":"Oracle Database","display_in_url":true},"release":{"short_name":"19","element_name":"Release 19","display_in_url":true}}}</script>
      
    <meta name="dcterms.isVersionOf" content="ZZPRE"></meta>
    <meta name="dcterms.release" content="Release 19"></meta>
  </head>
   <body dir="ltr">
      <div class="noscript alert alert-danger text-center" role="alert">
         <a href="running-Oracle-precompilers.html" class="pull-left"><span class="glyphicon glyphicon-chevron-left" aria-hidden="true"></span>上一页</a> <a href="error-handling-diagnostics.html" class="pull-right">下一页<span class="glyphicon glyphicon-chevron-right" aria-hidden="true"></span></a> <span class="fa fa-exclamation-triangle" aria-hidden="true"></span>必须启用JavaScript才能正确显示此内容</div>
      <article>
         <header>
            <ol class="breadcrumb" vocab="http://schema.org/" typeof="BreadcrumbList">
               <li property="itemListElement" typeof="ListItem"><a href="index.html" property="item" typeof="WebPage"><span property="name">程序员指南Oracle预编译器</span></a></li>
               <li class="active" property="itemListElement" typeof="ListItem">定义和控制交易</li>
            </ol>
            <a id="GUID-9F96857F-8D09-457D-BF01-DF045E41AAE5" name="GUID-9F96857F-8D09-457D-BF01-DF045E41AAE5"></a><a id="ZZPRE734"></a>
            
            <h2 id="ZZPRE-GUID-9F96857F-8D09-457D-BF01-DF045E41AAE5" class="sect2"><span class="enumeration_chapter">7</span>定义和控制交易</h2>
         </header>
         <div class="ind">
            <div>
               <p>本章介绍如何执行事务处理。您将学习保护数据库一致性的基本技术，包括如何控制对Oracle数据的更改是永久更改还是撤消。讨论了以下主题：</p>
               <ul style="list-style-type:disc">
                  <li>
                     <p><a href="defining-controlling-transactions.html#GUID-05A686D3-99E3-4BDD-9706-EEE7A5C87BEA">你应该知道的一些术语</a></p>
                  </li>
                  <li>
                     <p><a href="defining-controlling-transactions.html#GUID-DA8414EA-887F-4A22-829F-5296ED333300">事务如何保护您的数据库</a></p>
                  </li>
                  <li>
                     <p><a href="defining-controlling-transactions.html#GUID-9F42A08A-98D3-4AA9-B6FE-33D6548030DE">如何开始和结束交易</a></p>
                  </li>
                  <li>
                     <p><a href="defining-controlling-transactions.html#GUID-A4B199D5-6F69-4A61-9F48-2373615AB5D7">关于使用COMMIT语句</a></p>
                  </li>
                  <li>
                     <p><a href="defining-controlling-transactions.html#GUID-73E5DA28-13FE-4DEF-895D-642B2270B09E">关于使用ROLLBACK语句</a></p>
                  </li>
                  <li>
                     <p><a href="defining-controlling-transactions.html#GUID-DCC1B0F8-5945-470B-BCBE-8C5290920249">关于使用SAVEPOINT语句</a></p>
                  </li>
                  <li>
                     <p><a href="defining-controlling-transactions.html#GUID-00483D9E-64FC-49DC-843C-CBE3DE022BC9">关于使用RELEASE选项</a></p>
                  </li>
                  <li>
                     <p><a href="defining-controlling-transactions.html#GUID-A0A8481A-8F5C-4D7D-B0C8-3D59D872F5F5">关于使用SET TRANSACTION语句</a></p>
                  </li>
                  <li>
                     <p><a href="defining-controlling-transactions.html#GUID-F1679173-0361-43D1-AE04-E5365ED03274">关于覆盖默认锁定</a></p>
                  </li>
                  <li>
                     <p><a href="defining-controlling-transactions.html#GUID-2A8B09E4-3D57-45D7-9C3A-CE12F125D190">关于提交提案</a></p>
                  </li>
                  <li>
                     <p><a href="defining-controlling-transactions.html#GUID-4AFFB553-0B03-4AA1-9FD8-68607D5460F1">关于处理分布式事务</a></p>
                  </li>
                  <li>
                     <p><a href="defining-controlling-transactions.html#GUID-B77BD445-CA57-4F27-BFB1-76FB7CC53D12">方针</a></p>
                  </li>
               </ul>
            </div><a id="ZZPRE735"></a><div class="props_rev_3"><a id="GUID-05A686D3-99E3-4BDD-9706-EEE7A5C87BEA" name="GUID-05A686D3-99E3-4BDD-9706-EEE7A5C87BEA"></a><h3 id="ZZPRE-GUID-05A686D3-99E3-4BDD-9706-EEE7A5C87BEA" class="sect3"><span class="enumeration_section">7.1</span>你应该知道的一些术语</h3>
               <div>
                  <p>在深入研究交易主题之前，您应该了解本节中定义的术语。</p>
                  <p>Oracle管理的作业或任务称为<span class="italic">会话</span> 。运行应用程序或Oracle Forms等工具并连接到Oracle时，将启动<span class="italic">用户会话</span> 。Oracle允许用户会话“同时”工作并共享计算机资源。为此，Oracle必须控制<a id="d49462e122" class="indexterm-anchor"></a> <span class="italic">并发</span> ，这意味着许多用户访问相同的数据。如果没有足够的并发控制，可能会丢失<span class="italic">数据完整性</span> <a id="d49462e129" class="indexterm-anchor"></a> 。也就是说，可能会错误地更改数据或结构。
                  </p>
                  <p><a id="d49462e133" class="indexterm-anchor"></a> Oracle使用<span class="italic">锁</span>来控制对数据的并发访问。锁可以为您提供数据库资源的临时所有权，例如表或数据行。因此，在您完成数据之前，其他用户无法更改数据。您永远不需要显式锁定资源，因为默认锁定机制可以保护Oracle数据和结构。但是，您可以在表或行上请求<span class="italic">数据锁定</span> ，以便覆盖默认锁定。你可以选择几个<a id="d49462e142" class="indexterm-anchor"></a>锁定<span class="italic">模式</span> ，如<span class="italic">行共享</span>和<span class="italic">独占</span> 。
                  </p>
                  <p><span class="italic">陷入僵局</span> <a id="d49462e160" class="indexterm-anchor"></a>当两个或多个用户尝试访问同一数据库对象时，可能会发生此问题。例如，如果每个用户尝试更新当前由另一个锁定的行，则更新同一个表的两个用户可能会等待。因为每个用户都在等待另一个用户持有的资源，所以在Oracle打破死锁之前都不能继续。Oracle向完成最少工作量的参与事务发出错误信号，并且“等待资源时检测到死锁”Oracle错误代码返回到SQLCA中的SQLCODE。</p>
                  <p>当一个用户查询表并同时由另一个用户更新时，Oracle会为查询生成表的数据的<span class="italic">读一致</span>视图。也就是说，在查询开始之后并且在查询开始时，查询读取的数据不会更改。随着更新活动的继续，Oracle会获取表数据的<span class="italic">快照</span>并记录<span class="italic">回滚段中的</span>更改。Oracle使用回滚段中的信息进行构建<a id="d49462e174" class="indexterm-anchor"></a>读取一致的查询结果，并在必要时撤消更改。
                  </p>
               </div>
            </div><a id="ZZPRE736"></a><div class="props_rev_3"><a id="GUID-DA8414EA-887F-4A22-829F-5296ED333300" name="GUID-DA8414EA-887F-4A22-829F-5296ED333300"></a><h3 id="ZZPRE-GUID-DA8414EA-887F-4A22-829F-5296ED333300" class="sect3"><span class="enumeration_section">7.2</span>交易如何保护您的数据库</h3>
               <div>
                  <p>Oracle以事务为导向;也就是说，它使用事务来确保数据的完整性。一个<a id="d49462e199" class="indexterm-anchor"></a> transaction是您为完成某项任务而定义的一系列一个或多个逻辑相关的SQL语句。Oracle将一系列SQL语句视为一个单元，以便语句带来的所有更改都被<span class="italic">提交</span> （永久）或<a id="d49462e205" class="indexterm-anchor"></a> <span class="italic">同时回滚</span> （撤消）。如果您的应用程序在事务中间失败，则数据库将自动恢复到其以前的（事务前）状态。
                  </p>
                  <p><a id="d49462e213" class="indexterm-anchor"></a>该<a id="d49462e216" class="indexterm-anchor"></a>后续部分将向您展示如何定义和控制事务。具体来说，你学习如何</p>
                  <ul style="list-style-type:disc">
                     <li>
                        <p>开始和结束交易</p>
                     </li>
                     <li>
                        <p>使用<code class="codeph">COMMIT</code>语句使事务永久化</p>
                     </li>
                     <li>
                        <p>将<code class="codeph">SAVEPOINT</code>语句与<code class="codeph">ROLLBACK</code> <code class="codeph">TO</code>语句一起使用以撤消部分事务</p>
                     </li>
                     <li>
                        <p>使用<code class="codeph">ROLLBACK</code>语句撤消整个事务</p>
                     </li>
                     <li>
                        <p>指定<code class="codeph">RELEASE</code>选项以释放资源并注销数据库</p>
                     </li>
                     <li>
                        <p>使用<code class="codeph">SET</code> <code class="codeph">TRANSACTION</code>语句设置只读事务</p>
                     </li>
                     <li>
                        <p>使用<code class="codeph">FOR</code> <code class="codeph">UPDATE</code>子句或<code class="codeph">LOCK</code> <code class="codeph">TABLE</code>语句覆盖默认锁定</p>
                     </li>
                  </ul>
                  <p>有关本章中讨论的SQL语句的详细信息，请参阅<a href="../sqlrf/Introduction-to-Oracle-SQL.html#SQLRF-GUID-049B7AE8-11E1-4110-B3E4-D117907D77AC" target="_blank"><span class="italic">Oracle数据库SQL语言参考</span></a> 。
                  </p>
               </div>
            </div><a id="ZZPRE737"></a><div class="props_rev_3"><a id="GUID-9F42A08A-98D3-4AA9-B6FE-33D6548030DE" name="GUID-9F42A08A-98D3-4AA9-B6FE-33D6548030DE"></a><h3 id="ZZPRE-GUID-9F42A08A-98D3-4AA9-B6FE-33D6548030DE" class="sect3"><span class="enumeration_section">7.3</span>如何开始和结束交易</h3>
               <div>
                  <p><a id="d49462e308" class="indexterm-anchor"></a><a id="d49462e310" class="indexterm-anchor"></a>您在程序中使用第一个可执行SQL语句（除<code class="codeph">CONNECT</code> ）开始事务。当一个事务结束时，下一个可执行SQL语句会自动开始另一个事务。因此，每个可执行语句都是事务的一部分。因为它们无法回滚而无需承诺， <a id="d49462e318" class="indexterm-anchor"></a>声明性SQL语句不被视为事务的一部分。
                  </p>
                  <p><a id="d49462e324" class="indexterm-anchor"></a>您可以通过以下方式之一结束交易：</p>
                  <ul style="list-style-type:disc">
                     <li>
                        <p><a id="d49462e332" class="indexterm-anchor"></a>使用或不使用<code class="codeph">RELEASE</code>选项对<code class="codeph">COMMIT</code>或<code class="codeph">ROLLBACK</code>语句进行编码。这<span class="italic">明确</span>地对数据库进行永久或撤消更改。
                        </p>
                     </li>
                     <li>
                        <p>编写发布的数据定义语句（例如， <code class="codeph">ALTER</code> ， <code class="codeph">CREATE</code>或<code class="codeph">GRANT</code> ） <a id="d49462e361" class="indexterm-anchor"></a>自动提交前<span class="italic">和</span>执行后。这<span class="italic">隐式</span>地对数据库进行了永久性更改。
                        </p>
                     </li>
                  </ul>
                  <p><a id="d49462e374" class="indexterm-anchor"></a>当系统出现故障或用户会话因软件问题，硬件问题或强制中断而意外停止时，事务也会结束。Oracle回滚了该事务。
                  </p>
                  <p><a id="d49462e378" class="indexterm-anchor"></a>如果程序在事务中失败，Oracle会检测到错误并回滚事务。如果操作系统出现故障，Oracle会将数据库还原到以前的（事务前）状态。
                  </p>
                  <p></p>
               </div>
            </div><a id="ZZPRE738"></a><div class="props_rev_3"><a id="GUID-A4B199D5-6F69-4A61-9F48-2373615AB5D7" name="GUID-A4B199D5-6F69-4A61-9F48-2373615AB5D7"></a><h3 id="ZZPRE-GUID-A4B199D5-6F69-4A61-9F48-2373615AB5D7" class="sect3"><span class="enumeration_section">7.4</span>关于使用COMMIT语句</h3>
               <div>
                  <p><a id="d49462e405" class="indexterm-anchor"></a>您使用<code class="codeph">COMMIT</code>语句永久更改数据库。在提交更改之前，其他用户无法访问更改的数据;他们认为是这样<a id="d49462e411" class="indexterm-anchor"></a>在您的交易开始之前。<code class="codeph">COMMIT</code>语句对主机变量的值或程序中的控制流没有影响。具体来说，是<code class="codeph">COMMIT</code>语句</p>
                  <ul style="list-style-type:disc">
                     <li>
                        <p><a id="d49462e425" class="indexterm-anchor"></a>在当前事务期间对数据库进行永久性所有更改</p>
                     </li>
                     <li>
                        <p>使这些更改对其他用户可见</p>
                     </li>
                     <li>
                        <p>删除所有保存点（请参阅<a href="defining-controlling-transactions.html#GUID-73E5DA28-13FE-4DEF-895D-642B2270B09E">关于使用ROLLBACK语句</a> ）</p>
                     </li>
                     <li>
                        <p>释放所有行和表锁，但不解析锁</p>
                     </li>
                     <li>
                        <p>关闭CURRENT OF子句中引用的游标，或者当<code class="codeph">MODE={ANSI13|ORACLE}</code> ，关闭<span class="italic">所有</span>显式游标</p>
                     </li>
                     <li>
                        <p>结束交易</p>
                     </li>
                  </ul>
                  <p>当<code class="codeph">MODE={ANSI13|ORACLE}</code> ， <code class="codeph">CURRENT OF</code>子句中未引用的显式游标在提交期间保持打开状态。这可以提高性能。有关示例，请参阅<span class="q">“ <a href="defining-controlling-transactions.html#GUID-2A8B09E4-3D57-45D7-9C3A-CE12F125D190">关于提交提交</a> ”</span> 。
                  </p>
                  <p>因为它们是正常处理的一部分， <code class="codeph">COMMIT</code>语句应该通过程序的主路径内联放置。在程序终止之前，它必须显式提交挂起的更改。否则，Oracle会回滚它们。在以下示例中，您提交事务并断开与Oracle的连接：</p><pre class="oac_no_warn" dir="ltr"><a id="d49462e474" class="indexterm-anchor"></a> EXEC SQL COMMIT WORK RELEASE;</pre><p>可选关键字WORK提供ANSI兼容性。该<a id="d49462e481" class="indexterm-anchor"></a><a id="d49462e485" class="indexterm-anchor"></a> RELEASE选项释放程序保存的所有Oracle资源（锁和游标）并注销数据库。
                  </p>
                  <p><a id="d49462e491" class="indexterm-anchor"></a>您不需要使用COMMIT语句跟随数据定义语句，因为数据定义语句在执行之前<span class="italic">和</span>之后发出自动提交。因此，无论它们是成功还是失败，都会提交先前的交易。
                  </p>
               </div>
            </div><a id="ZZPRE739"></a><div class="props_rev_3"><a id="GUID-73E5DA28-13FE-4DEF-895D-642B2270B09E" name="GUID-73E5DA28-13FE-4DEF-895D-642B2270B09E"></a><h3 id="ZZPRE-GUID-73E5DA28-13FE-4DEF-895D-642B2270B09E" class="sect3"><span class="enumeration_section">7.5</span>关于使用ROLLBACK语句</h3>
               <div>
                  <p><a id="d49462e524" class="indexterm-anchor"></a>您可以使用<code class="codeph">ROLLBACK</code>语句撤消对数据库所做的挂起更改。例如，如果您犯了一个错误，例如从表中删除错误的行，则可以使用<code class="codeph">ROLLBACK</code>恢复原始数据。该<a id="d49462e535" class="indexterm-anchor"></a> <code class="codeph">ROLLBACK</code>语句对主机变量的值或程序中的控制流没有影响。具体来说，就是<code class="codeph">ROLLBACK</code>语句</p>
                  <ul style="list-style-type:disc">
                     <li>
                        <p>撤消当前事务期间对数据库所做的所有更改</p>
                     </li>
                     <li>
                        <p>删除所有保存点</p>
                     </li>
                     <li>
                        <p>结束交易</p>
                     </li>
                     <li>
                        <p>释放所有行和表锁，但不解析锁</p>
                     </li>
                     <li>
                        <p>关闭CURRENT OF子句中引用的游标，或者当<code class="codeph">MODE={ANSI|ANSI14}</code>时关闭<span class="italic">所有</span>显式游标</p>
                     </li>
                  </ul>
                  <p>当<code class="codeph">MODE={ANSI13|ORACLE}</code> ， <code class="codeph">CURRENT OF</code>子句中未引用的显式游标在回滚期间保持打开状态。
                  </p>
                  <p><a id="d49462e576" class="indexterm-anchor"></a>因为它们是异常处理的一部分，所以<code class="codeph">ROLLBACK</code>语句应该放在错误处理例程中，离开程序的主路径。在下面的<a id="d49462e584" class="indexterm-anchor"></a>例如，您回滚事务并断开与Oracle的连接：</p><pre class="oac_no_warn" dir="ltr">EXEC SQL ROLLBACK工作版;</pre><p><a id="d49462e592" class="indexterm-anchor"></a>可选关键字<code class="codeph">WORK</code>提供ANSI兼容性。该<a id="d49462e600" class="indexterm-anchor"></a> <code class="codeph">RELEASE</code>选项释放程序保存的所有资源并从数据库中注销。
                  </p>
                  <p>如果<code class="codeph">WHENEVER</code> SQLERROR <code class="codeph">GOTO</code>语句分支到包含<code class="codeph">ROLLBACK</code>语句的错误处理例程，则如果回滚失败并且出现错误，则程序可能会进入无限循环。您可以通过在<code class="codeph">ROLLBACK</code>语句之前编写<code class="codeph">WHENEVER</code> SQLERROR <code class="codeph">CONTINUE</code>来避免这种情况。
                  </p>
                  <p><a id="d49462e629" class="indexterm-anchor"></a>例如，请考虑以下事项：</p><pre class="oac_no_warn" dir="ltr"><a id="d49462e635" class="indexterm-anchor"></a>执行SQL WHENEVER SQLERROR GOTO sql_error;对于每个新员工显示'员工编号？“;读取emp_number;显示'员工姓名？“;读取emp_name; EXEC SQL INSERT INTO EMP（EMPNO，ENAME）VALUES（：emp_number，：emp_name）; ENDFOR; ...sql_error：EXEC SQL WHENEVER SQLERROR CONTINUE; EXEC SQL ROLLBACK工作版;显示'处理错误';退出程序有错误;</pre><p><a id="d49462e641" class="indexterm-anchor"></a><a id="d49462e645" class="indexterm-anchor"></a>如果程序异常终止，Oracle会回滚事务。
                  </p>
               </div><a id="ZZPRE740"></a><div class="props_rev_3"><a id="GUID-95768D5C-6964-47D2-A033-A41810677953" name="GUID-95768D5C-6964-47D2-A033-A41810677953"></a><h4 id="ZZPRE-GUID-95768D5C-6964-47D2-A033-A41810677953" class="sect4"><span class="enumeration_section">7.5.1</span>语句级回滚</h4>
                  <div>
                     <p>在执行任何SQL语句之前，Oracle会标记一个隐式保存点（不适用于您）。然后，如果语句失败，Oracle会自动回滚它并将适用的错误代码返回到SQLCA中的SQLCODE。例如，如果INSERT语句通过尝试在唯一索引中插入重复值而导致错误，则回滚该语句。</p>
                     <p>只有失败的SQL语句启动的工作才会丢失;保留当前事务中该语句之前完成的工作。因此，如果数据定义语句失败，则不会撤消其前面的自动提交。</p>
                     <p>请注意，在执行SQL语句之前，Oracle必须对其进行解析，即检查它以确保它遵循语法规则并引用有效的数据库对象。执行SQL语句时检测到的错误会导致回滚，但在解析语句时检测到的错误则不会。</p>
                     <p><a id="d49462e685" class="indexterm-anchor"></a> Oracle还可以回滚单个SQL语句以打破死锁。<a id="d49462e690" class="indexterm-anchor"></a> Oracle向其中一个参与事务发出错误信号并回滚该事务中的当前语句。
                     </p>
                  </div>
               </div>
            </div><a id="ZZPRE741"></a><div class="props_rev_3"><a id="GUID-DCC1B0F8-5945-470B-BCBE-8C5290920249" name="GUID-DCC1B0F8-5945-470B-BCBE-8C5290920249"></a><h3 id="ZZPRE-GUID-DCC1B0F8-5945-470B-BCBE-8C5290920249" class="sect3"><span class="enumeration_section">7.6</span>关于使用SAVEPOINT语句</h3>
               <div>
                  <p><a id="d49462e721" class="indexterm-anchor"></a>您可以使用<code class="codeph">SAVEPOINT</code>语句标记和命名事务处理中的当前点。每个标记点称为<span class="italic">保存点</span> 。对于<a id="d49462e730" class="indexterm-anchor"></a>例如，以下语句标记名为<span class="italic">start_delete</span>的保存点：</p><pre class="oac_no_warn" dir="ltr">EXEC SQL SAVEPOINT start_delete;</pre><p><a id="d49462e741" class="indexterm-anchor"></a>保存点允许您划分长事务，使您可以更好地控制复杂的过程。例如，如果事务执行多个功能，则可以在每个功能之前标记保存点。然后，如果函数失败，您可以轻松地将Oracle数据恢复到以前的状态，恢复，然后重新执行该函数。
                  </p>
                  <p><a id="d49462e747" class="indexterm-anchor"></a><a id="d49462e749" class="indexterm-anchor"></a>要撤消部分事务，可以将保存点与<code class="codeph">ROLLBACK</code>语句及其一起使用<a id="d49462e757" class="indexterm-anchor"></a> T <code class="codeph">O SAVEPOINT</code>条款。<code class="codeph">TO SAVEPOINT</code>子句允许您回滚到当前事务中的中间语句，因此您不必撤消所有更改。具体来说，是<code class="codeph">ROLLBACK TO SAVEPOINT</code>语句</p>
                  <ul style="list-style-type:disc">
                     <li>
                        <p>取消自指定的保存点被标记以来对数据库所做的更改</p>
                     </li>
                     <li>
                        <p>删除指定保存点后标记的所有保存点</p>
                     </li>
                     <li>
                        <p>释放自标记指定保存点以来获取的所有行和表锁</p>
                     </li>
                  </ul>
                  <p>在该示例中，您访问表<code class="codeph">MAIL_LIST</code>以插入新列表，更新旧<a id="d49462e787" class="indexterm-anchor"></a>列表和删除（一些）非活动列表。删除后，检查SQLCA中的SQLERRD（3）以获取已删除的行数。如果数字意外大，则回滚到保存点<span class="italic">start_delete</span> ，仅撤消删除。
                  </p><pre class="oac_no_warn" dir="ltr">每个新客户显示'客户编号？“;读cust_number;显示'客户名称？“; read cust_name; EXEC SQL INSERT INTO MAIL_LIST（CUSTNO，CNAME，STAT）VALUES（：cust_number，：cust_name，'ACTIVE'）; ENDFOR;对于每个修订状态显示'客户编号？“;读cust_number;显示'新状态？“;阅读new_status; EXEC SQL UPDATE MAIL_LIST SET STAT =：new_status WHERE CUSTNO =：cust_number; ENDFOR; - 标记保存点EXEC SQL SAVEPOINT start_delete;执行SQL删除MAIL_LIST WHERE STAT ='INACTIVE'; IF sqlca.sqlerrd（3）&lt;25 THEN  - 检查删除的行数显示'删除的行数'，sqlca.sqlerrd（3）; ELSE显示'撤消删除'，sqlca.sqlerrd（3），'rows';执行SQL WHENEVER SQLERROR GOTO sql_error; EXEC SQL ROLLBACK TO SAVEPOINT start_delete;万一; EXEC SQL WHENEVER SQLERROR CONTINUE; EXEC SQL COMMIT WORK RELEASE;退出计划; sql_error：EXEC SQL WHENEVER SQLERROR CONTINUE; EXEC SQL ROLLBACK工作版;显示'处理错误';退出程序有错误;</pre><p><a id="d49462e798" class="indexterm-anchor"></a><a id="d49462e802" class="indexterm-anchor"></a>请注意，您无法在<code class="codeph">ROLLBACK TO SAVEPOINT</code>语句中指定<code class="codeph">RELEASE</code>选项。
                  </p>
                  <p><a id="d49462e814" class="indexterm-anchor"></a>回滚到保存点会删除在该保存点之后标记的所有保存点。但是，您回滚的保存点不会被删除。例如，如果标记五个保存点，则回滚到第三个保存点，仅删除第四个和第五个保存点。<code class="codeph">COMMIT</code>或<code class="codeph">ROLLBACK</code>语句将擦除所有保存点。
                  </p>
                  <p>默认情况下，每个用户会话中的活动保存点数限制为5。<span class="italic">活动</span>保存点是您自上次提交或回滚以来标记的保存点。您的数据库管理员（DBA）可以通过增加Oracle的值来提高限制<a id="d49462e828" class="indexterm-anchor"></a>初始化参数<code class="codeph">SAVEPOINTS</code> 。如果为两个保存点指定相同的名称，则会删除较早的保存点。
                  </p>
               </div>
            </div><a id="ZZPRE742"></a><div class="props_rev_3"><a id="GUID-00483D9E-64FC-49DC-843C-CBE3DE022BC9" name="GUID-00483D9E-64FC-49DC-843C-CBE3DE022BC9"></a><h3 id="ZZPRE-GUID-00483D9E-64FC-49DC-843C-CBE3DE022BC9" class="sect3"><span class="enumeration_section">7.7</span>关于使用RELEASE选项</h3>
               <div>
                  <p>如果程序异常终止，Oracle会自动回滚更改。当您的程序未显式提交或回滚工作并使用RELEASE选项与Oracle断开连接时，会发生异常终止。</p>
                  <p>当你的程序运行它时，正常终止，关闭打开的游标， <a id="d49462e862" class="indexterm-anchor"></a>显式提交或回滚工作，断开与Oracle的连接，并将控制权返回给用户。如果它执行的最后一个SQL语句是，您的程序将正常退出</p><pre class="oac_no_warn" dir="ltr">EXEC SQL COMMIT RELEASE;</pre><p>要么</p><pre class="oac_no_warn" dir="ltr">EXEC SQL ROLLBACK RELEASE;</pre><p><a id="d49462e872" class="indexterm-anchor"></a>否则，用户会话获取的锁和游标将在程序终止后保留，直到Oracle识别出用户会话不再处于活动状态。这可能导致多用户环境中的其他用户等待锁定资源所需的时间。
                  </p>
               </div>
            </div><a id="ZZPRE743"></a><div class="props_rev_3"><a id="GUID-A0A8481A-8F5C-4D7D-B0C8-3D59D872F5F5" name="GUID-A0A8481A-8F5C-4D7D-B0C8-3D59D872F5F5"></a><h3 id="ZZPRE-GUID-A0A8481A-8F5C-4D7D-B0C8-3D59D872F5F5" class="sect3"><span class="enumeration_section">7.8</span>关于使用SET TRANSACTION语句</h3>
               <div>
                  <p>使用<code class="codeph">SET TRANSACTION</code>语句开始只读或读/写事务，或将当前事务分配给指定的回滚段。<code class="codeph">COMMIT</code> ， <code class="codeph">ROLLBACK</code>或数据定义语句结束只读事务。
                  </p>
                  <p><a id="d49462e913" class="indexterm-anchor"></a>因为它们允许“可重复读取”，所以只读事务对于针对一个或多个表运行多个查询以及其他用户更新相同表时非常有用。<a id="d49462e916" class="indexterm-anchor"></a>在只读事务期间，所有查询都引用数据库的相同快照，从而提供多表，多查询，读取一致的视图。其他用户可以像往常一样继续查询或更新数据。一个<a id="d49462e919" class="indexterm-anchor"></a> <code class="codeph">SET TRANSACTION</code>语句的示例如下：</p><pre class="oac_no_warn" dir="ltr">EXEC SQL SET TRANSACTION READ ONLY;</pre><p><a id="d49462e930" class="indexterm-anchor"></a><a id="d49462e934" class="indexterm-anchor"></a> <code class="codeph">SET TRANSACTION</code>语句必须是只读事务中的第一个SQL语句，并且只能在事务中出现一次。该<a id="d49462e940" class="indexterm-anchor"></a> <code class="codeph">READ ONLY</code>参数是<a id="d49462e947" class="indexterm-anchor"></a>需要。它的使用不会影响其他交易。只读事务中只允许<code class="codeph">SELECT</code> （不带<code class="codeph">FOR</code> <code class="codeph">UPDATE</code> ）， <code class="codeph">LOCK TABLE</code> ， <code class="codeph">SET ROLE</code> ， <code class="codeph">ALTER SESSION</code> ， <code class="codeph">ALTER SYSTEM</code> ， <code class="codeph">COMMIT</code>和<code class="codeph">ROLLBACK</code>语句。
                  </p>
                  <p>在里面<a id="d49462e983" class="indexterm-anchor"></a>例如，作为商店经理，您可以使用只读事务生成摘要报告，以检查当天，过去一周和过去一个月的销售活动。在事务期间，该报告不受更新数据库的其他用户的影响。
                  </p><pre class="oac_no_warn" dir="ltr">EXEC SQL SET TRANSACTION READ ONLY; EXEC SQL SELECT SUM（SALEAMT）INTO：每日从SALES WHERE SALEDATE = SYSDATE; EXEC SQL SELECT SUM（SALEAMT）INTO：每周从SALES WHERE SALEDATE&gt; SYSDATE  -  7; EXEC SQL SELECT SUM（SALEAMT）INTO：每月从SALES WHERE SALEDATE&gt; SYSDATE  -  30; EXEC SQL COMMIT WORK; - 简单地结束交易，因为没有变化 - 制作永久格式和打印报告</pre></div>
            </div><a id="ZZPRE744"></a><div class="props_rev_3"><a id="GUID-F1679173-0361-43D1-AE04-E5365ED03274" name="GUID-F1679173-0361-43D1-AE04-E5365ED03274"></a><h3 id="ZZPRE-GUID-F1679173-0361-43D1-AE04-E5365ED03274" class="sect3"><span class="enumeration_section">7.9</span>关于覆盖默认锁定</h3>
               <div>
                  <p><a id="d49462e1012" class="indexterm-anchor"></a>默认情况下，Oracle <a id="d49462e1015" class="indexterm-anchor"></a>隐式（自动）为您锁定许多数据结构。但是，您可以在行或表上请求特定数据锁定，以便覆盖默认锁定。显式锁定允许您在事务期间共享或拒绝对表的访问，或确保多表和多查询读一致性。
                  </p>
                  <p>使用<code class="codeph">SELECT FOR UPDATE OF</code>语句，您可以显式锁定表的特定行，以确保在执行更新或删除之前它们不会更改。但是，Oracle会在更新或删除时自动获取行级锁。因此，仅当您要在更新或删除<span class="italic">之前</span>锁定行时， <span class="italic">才</span>使用<code class="codeph">FOR UPDATE OF</code>子句。
                  </p>
                  <p>您可以使用<code class="codeph">LOCK TABLE</code>语句显式锁定整个表。
                  </p>
               </div><a id="ZZPRE745"></a><div class="props_rev_3"><a id="GUID-984FD738-22DD-4171-AC4D-A12B3BAAB3BC" name="GUID-984FD738-22DD-4171-AC4D-A12B3BAAB3BC"></a><h4 id="ZZPRE-GUID-984FD738-22DD-4171-AC4D-A12B3BAAB3BC" class="sect4"><span class="enumeration_section">7.9.1</span>关于使用FOR更新条款</h4>
                  <div>
                     <p><a id="d49462e1057" class="indexterm-anchor"></a>当你<code class="codeph">DECLARE</code> <code class="codeph">UPDATE</code>或<code class="codeph">DELETE</code>语句的<code class="codeph">CURRENT</code> <code class="codeph">OF</code>子句中引用的游标时，使用FOR UPDATE OF子句获取<a id="d49462e1078" class="indexterm-anchor"></a>独家行锁。<code class="codeph">SELECT FOR UPDATE OF</code>标识将要更新或删除的行，然后锁定活动集中的每一行。（所有行都在打开时锁定，而不是在获取时。）例如，当您想要对行中的现有值进行更新时，这很有用。在更新之前，您必须确保其他用户不会更改该行。
                     </p>
                     <p><code class="codeph">FOR UPDATE OF</code>子句是可选的。例如，而不是</p><pre class="oac_no_warn" dir="ltr">EXEC SQL DECLARE emp_cursor CURSOR for SELECT ENAME，JOB，SAL from EMP，DEPTNO = 20 FOR SALDATE;</pre><p>你可以删除<code class="codeph">FOR UPDATE OF</code>子句并简单地编码</p><pre class="oac_no_warn" dir="ltr">EXEC SQL DECLARE emp_cursor CURSOR for SELECT ENAME，JOB，SAL from EMP WHERE DEPTNO = 20;</pre><p><code class="codeph">CURRENT OF</code>子句指示预编译器在必要时添加FOR UPDATE子句。您可以使用<code class="codeph">CURRENT OF</code>子句来引用从游标中获取的最新行。
                     </p>
                  </div>
               </div><a id="ZZPRE746"></a><div class="props_rev_3"><a id="GUID-D860488C-475A-411D-B28E-B31CBF961244" name="GUID-D860488C-475A-411D-B28E-B31CBF961244"></a><h4 id="ZZPRE-GUID-D860488C-475A-411D-B28E-B31CBF961244" class="sect4"><span class="enumeration_section">7.9.2</span>限制</h4>
                  <div>
                     <p>如果使用<code class="codeph">FOR UPDATE OF</code>子句，则无法引用多个表。还有，一个<a id="d49462e1133" class="indexterm-anchor"></a><a id="d49462e1137" class="indexterm-anchor"></a>显式<code class="codeph">FOR UPDATE OF</code>或隐式<code class="codeph">FOR UPDATE</code>获取独占行锁。提交或回滚时会释放行锁（除非您回滚到保存点）。如果在提交后尝试从<code class="codeph">FOR UPDATE</code>游标获取，Oracle会生成以下错误：</p><pre class="oac_no_warn" dir="ltr">ORA-01002：取消顺序</pre></div>
               </div><a id="ZZPRE747"></a><div class="props_rev_3"><a id="GUID-DA549A9A-0E41-4FFD-AF00-BF5373BE59CA" name="GUID-DA549A9A-0E41-4FFD-AF00-BF5373BE59CA"></a><h4 id="ZZPRE-GUID-DA549A9A-0E41-4FFD-AF00-BF5373BE59CA" class="sect4"><span class="enumeration_section">7.9.3</span>关于使用LOCK TABLE语句</h4>
                  <div>
                     <p><a id="d49462e1181" class="indexterm-anchor"></a>您<a id="d49462e1186" class="indexterm-anchor"></a><a id="d49462e1188" class="indexterm-anchor"></a>使用<code class="codeph">LOCK TABLE</code>语句以指定的锁定模式锁定一个或多个表。例如，该语句以<span class="italic">行共享</span>模式锁定EMP表。行共享锁允许并发访问表;它们阻止其他用户锁定整个表以供独占使用。
                     </p><pre class="oac_no_warn" dir="ltr">EXEC SQL LOCK表EMP在行分享模式NOWAIT;</pre><p>锁定模式确定可以在表格上放置哪些其他锁定。对于<a id="d49462e1203" class="indexterm-anchor"></a>例， <a id="d49462e1208" class="indexterm-anchor"></a>许多用户可以同时获取表上的行共享锁，但一次只能有一个用户获得<span class="italic">独占</span>锁。当一个用户对表具有独占锁时，其他用户不能插入，更新或删除该表中的行。有关锁定模式的详细信息，请参阅<a href="../adfns/sql-processing-for-application-developers.html#ADFNS-GUID-912124B7-0F39-47BD-863C-320ED61014E9" target="_blank">应用程序开发人员的SQL处理</a> 。
                     </p>
                     <p><a id="d49462e1221" class="indexterm-anchor"></a>可选关键字<a id="d49462e1226" class="indexterm-anchor"></a> NOWAIT <a id="d49462e1231" class="indexterm-anchor"></a>如果表已被其他用户锁定，则告诉Oracle不要等待表。控制立即返回到您的程序，因此它可以在再次尝试获取锁之前执行其他工作。（您可以在SQLCA中检查SQLCODE以查看表锁是否失败。）如果省略<code class="codeph">NOWAIT</code> ，Oracle会等到表可用为止;等待没有设定限制。
                     </p>
                     <p><a id="d49462e1240" class="indexterm-anchor"></a>表锁永远不会阻止其他用户查询表，并且查询永远不会获取表锁。因此，查询永远不会阻止另一个查询或更新，并且更新永远不会阻止查询。仅当两个不同的事务尝试更新同一行时，一个事务才会等待另一个事务完成。当事务发出提交或回滚时，将释放表锁。
                     </p>
                  </div>
               </div>
            </div><a id="ZZPRE748"></a><div class="props_rev_3"><a id="GUID-2A8B09E4-3D57-45D7-9C3A-CE12F125D190" name="GUID-2A8B09E4-3D57-45D7-9C3A-CE12F125D190"></a><h3 id="ZZPRE-GUID-2A8B09E4-3D57-45D7-9C3A-CE12F125D190" class="sect3"><span class="enumeration_section">7.10</span>关于提交提案</h3>
               <div>
                  <div class="section">
                     <p><a id="d49462e1267" class="indexterm-anchor"></a>如果要混合提交和提取，请不要使用<code class="codeph">CURRENT OF</code>子句。而是选择每行的rowid，然后使用该值在更新或删除期间标识当前行。请考虑以下示例：</p><pre class="oac_no_warn" dir="ltr">EXEC SQL DECLARE emp_cursor CURSOR FOR SELECT ENAME，SAL，ROWID from EMP WHERE JOB ='CLERK'; ...EXEC SQL OPEN emp_cursor; EXEC SQL WHENEVER未找到GOTO ......LOOP EXEC SQL FETCH emp_cursor INTO：emp_name，：salary，：row_id; ...EXEC SQL UPDATE EMP SET SAL =：new_salary WHERE ROWID =：row_id; EXEC SQL COMMIT; ENDLOOP;</pre><div class="infoboxnote" id="GUID-2A8B09E4-3D57-45D7-9C3A-CE12F125D190__GUID-C6CEFC06-C571-434E-A001-1865F339C9B6">
                        <p class="notep1">注意：</p>
                        <p>提取的行<span class="italic">未</span>锁定。因此，如果另一个用户在您读取之后但在更新或删除之前修改了一行，则可能会得到不一致的结果。
                        </p>
                     </div>
                  </div>
                  <!-- class="section" -->
               </div>
            </div><a id="ZZPRE749"></a><div class="props_rev_3"><a id="GUID-4AFFB553-0B03-4AA1-9FD8-68607D5460F1" name="GUID-4AFFB553-0B03-4AA1-9FD8-68607D5460F1"></a><h3 id="ZZPRE-GUID-4AFFB553-0B03-4AA1-9FD8-68607D5460F1" class="sect3"><span class="enumeration_section">7.11</span>关于处理分布式事务</h3>
               <div>
                  <p><span class="italic">分布式数据库</span>是包括不同节点处的多个物理数据库的单个逻辑数据库。<span class="italic">分布式语句</span>是使用数据库链接访问远程节点的任何SQL语句。<span class="italic">分布式事务</span>包括至少一个分布式语句，其更新分布式数据库的多个节点处的数据。如果更新仅影响一个节点，则事务是非分布式的。
                  </p>
                  <p><a id="d49462e1315" class="indexterm-anchor"></a>发出提交时，对受分布式事务影响的每个数据库的更改将永久保留。如果您发出回滚，则撤消所有更改。但是，如果网络或计算机在提交或回滚期间出现故障，则分布式事务的状态可能是未知的或<a id="d49462e1320" class="indexterm-anchor"></a> <span class="italic">有疑问</span> 。在这种情况下，如果您具有F <code class="codeph">ORCE TRANSACTION</code>系统特权，则可以使用<code class="codeph">FORCE</code>子句在本地数据库中手动提交或回滚事务。必须通过包含事务ID的带引号的文字来标识事务，该事务ID可以在数据字典视图<code class="codeph">DBA_2PC_PENDING</code> 。一些例子如下：</p><pre class="oac_no_warn" dir="ltr">EXEC SQL COMMIT FORCE '22 .31.83'; ...EXEC SQL ROLLBACK FORCE '25 .33.86';</pre><p><code class="codeph">FORCE</code>仅提交或回滚指定的事务，不会影响您当前的事务。请注意，您无法手动将不确定事务回滚到保存点。
                  </p>
                  <p><code class="codeph">COMMIT</code>语句中的<code class="codeph">COMMENT</code>子句允许您指定与分布式事务关联的注释。如果事务有疑问，Oracle会将<code class="codeph">COMMENT</code>指定的文本与事务ID一起存储在数据字典视图<code class="codeph">DBA_2PC_PENDING</code> 。文本必须是带引号的文字&lt;= 50个字符。一个例子如下：</p><pre class="oac_no_warn" dir="ltr">EXEC SQL COMMIT COMMENT'怀疑trans;通知订单输入';</pre><p>有关分布式事务的更多信息，请参阅<a href="../cncpt/transactions.html#CNCPT-GUID-B97790CB-DF82-442D-B9D5-50CCE6BF9FBD" target="_blank">事务</a> 。
                  </p>
               </div>
            </div><a id="ZZPRE750"></a><div class="props_rev_3"><a id="GUID-B77BD445-CA57-4F27-BFB1-76FB7CC53D12" name="GUID-B77BD445-CA57-4F27-BFB1-76FB7CC53D12"></a><h3 id="ZZPRE-GUID-B77BD445-CA57-4F27-BFB1-76FB7CC53D12" class="sect3"><span class="enumeration_section">7.12</span>指南</h3>
               <div>
                  <p><a id="d49462e1390" class="indexterm-anchor"></a>以下指南将帮助您避免一些常见问题。
                  </p>
               </div><a id="ZZPRE751"></a><div class="props_rev_3"><a id="GUID-BDF87E78-E39C-4292-AD73-A59E2F56E538" name="GUID-BDF87E78-E39C-4292-AD73-A59E2F56E538"></a><h4 id="ZZPRE-GUID-BDF87E78-E39C-4292-AD73-A59E2F56E538" class="sect4"><span class="enumeration_section">7.12.1</span>关于设计应用程序</h4>
                  <div>
                     <p>在设计应用程序时，在一个事务中将逻辑相关的操作组合在一起。精心设计的交易包括完成特定任务所需的所有步骤 - 不多也不少。</p>
                     <p>您引用的表中的数据必须保持一致状态。因此，事务中的SQL语句应以一致的方式更改数据。例如，两个银行账户之间的资金转移应包括一个账户的借方和另一个账户的贷方。两个更新应该成功还是一起失败。不相关的更新（例如新存款到一个帐户）不应包含在交易中。</p>
                  </div>
               </div><a id="ZZPRE752"></a><div class="props_rev_3"><a id="GUID-BA46F810-7058-493B-BE9A-AFBA9C8B7476" name="GUID-BA46F810-7058-493B-BE9A-AFBA9C8B7476"></a><h4 id="ZZPRE-GUID-BA46F810-7058-493B-BE9A-AFBA9C8B7476" class="sect4"><span class="enumeration_section">7.12.2</span>关于获取锁</h4>
                  <div>
                     <p><a id="d49462e1440" class="indexterm-anchor"></a>如果您的应用程序包含SQL锁定语句，请确保请求锁定的Oracle用户具有获取锁定所需的权限。您的DBA可以锁定任何表。其他用户可以锁定他们拥有的表或他们有权使用的表，例如<code class="codeph">ALTER</code> ， <code class="codeph">SELECT</code> ， <code class="codeph">INSERT</code> ， <code class="codeph">UPDATE</code>或<code class="codeph">DELETE</code> 。</p>
                  </div>
               </div><a id="ZZPRE753"></a><div class="props_rev_3"><a id="GUID-0535A0DD-7E99-4AFE-97DB-AC14EC4D6095" name="GUID-0535A0DD-7E99-4AFE-97DB-AC14EC4D6095"></a><h4 id="ZZPRE-GUID-0535A0DD-7E99-4AFE-97DB-AC14EC4D6095" class="sect4"><span class="enumeration_section">7.12.3</span>关于使用PL / SQL</h4>
                  <div>
                     <p><a id="d49462e1488" class="indexterm-anchor"></a>如果PL / SQL块是事务的一部分，则块内的提交和回滚会影响整个事务。在以下示例中，回滚撤消更新<span class="italic">和</span>插入所做的更改：</p><pre class="oac_no_warn" dir="ltr">EXEC SQL INSERT INTO EMP ...EXEC SQL EXECUTE BEGIN UPDATE emp ......DUP_VAL_ON_INDEX然后ROLLBACK的例外情况;结束; END-EXEC; ...
</pre></div>
               </div>
            </div>
         </div>
      </article>
   </body>
</html>