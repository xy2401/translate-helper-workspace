<html lang="en-us" dir="ltr" xml:lang="en-us">
   <head>
      <meta http-equiv="Content-Type" content="text/html; charset=utf-8"></meta>
      <meta name="viewport" content="width=device-width, initial-scale=1"></meta>
      <meta http-equiv="X-UA-Compatible" content="IE=edge"></meta>
      <meta name="abstract" content="The direct path loading functions are used to load data from external files into tables and partitions."></meta>
      <meta name="description" content="The direct path loading functions are used to load data from external files into tables and partitions."></meta>
      <title>直接路径加载接口</title>
      <meta property="og:site_name" content="Oracle Help Center"></meta>
      <meta property="og:title" content="Programmer&#39;s Guide"></meta>
      <meta property="og:description" content="The direct path loading functions are used to load data from external files into tables and partitions."></meta>
      <link rel="stylesheet" href="/sp_common/book-template/ohc-book-template/css/book.css"></link>
      <link rel="shortcut icon" href="/sp_common/book-template/ohc-common/img/favicon.ico"></link>
      <meta name="application-name" content="Programmer&#39;s Guide"></meta>
      <meta name="generator" content="DITA Open Toolkit version 1.8.5 (Mode = doc)"></meta>
      <meta name="plugin" content="SP_docbuilder HTML plugin release 18.2.2"></meta>
      <link rel="alternate" href="oracle-call-interface-programmers-guide.pdf" title="PDF File" type="application/pdf"></link>
      <meta name="robots" content="all"></meta>
      <link rel="schema.dcterms" href="http://purl.org/dc/terms/"></link>
      <meta name="dcterms.created" content="2019-01-14T08:46:00-08:00"></meta>
      
      <meta name="dcterms.dateCopyrighted" content="1996, 2019"></meta>
      <meta name="dcterms.category" content="database"></meta>
      <meta name="dcterms.identifier" content="E96204-01"></meta>
      
      <meta name="dcterms.product" content="en/database/oracle/oracle-database/19"></meta>
      
      <link rel="prev" href="object-relational-data-types-in-oci.html" title="Previous" type="text/html"></link>
      <link rel="next" href="object-advanced-topics-in-oci.html" title="Next" type="text/html"></link>
      <script>
        document.write('<style type="text/css">');
        document.write('body > .noscript, body > .noscript ~ * { visibility: hidden; }');
        document.write('</style>');
     </script>
      <script src="/sp_common/book-template/requirejs/require.js" data-main="/sp_common/book-template/ohc-book-template/js/book-config"></script>
      <script>
            if (window.require === undefined) {
                document.write('<script data-main="sp_common/book-template/ohc-book-template/js/book-config" src="sp_common/book-template/requirejs/require.js"><\/script>');
                document.write('<link href="sp_common/book-template/ohc-book-template/css/book.css" rel="stylesheet"/>');
            }
        </script>
      <script type="application/json" id="ssot-metadata">{"primary":{"category":{"short_name":"database","element_name":"Database","display_in_url":true},"suite":{"short_name":"oracle","element_name":"Oracle","display_in_url":true},"product_group":{"short_name":"not-applicable","element_name":"Not applicable","display_in_url":false},"product":{"short_name":"oracle-database","element_name":"Oracle Database","display_in_url":true},"release":{"short_name":"19","element_name":"Release 19","display_in_url":true}}}</script>
      
    <meta name="dcterms.title" content="Oracle Call Interface Programmer&#39;s Guide"></meta>
    <meta name="dcterms.isVersionOf" content="LNOCI"></meta>
    <meta name="dcterms.release" content="Release 19"></meta>
  </head>
   <body dir="ltr">
      <div class="noscript alert alert-danger text-center" role="alert">
         <a href="object-relational-data-types-in-oci.html" class="pull-left"><span class="glyphicon glyphicon-chevron-left" aria-hidden="true"></span>上一页</a> <a href="object-advanced-topics-in-oci.html" class="pull-right">下一页<span class="glyphicon glyphicon-chevron-right" aria-hidden="true"></span></a> <span class="fa fa-exclamation-triangle" aria-hidden="true"></span>必须启用JavaScript才能正确显示此内容</div>
      <article>
         <header>
            <ol class="breadcrumb" vocab="http://schema.org/" typeof="BreadcrumbList">
               <li property="itemListElement" typeof="ListItem"><a href="index.html" property="item" typeof="WebPage"><span property="name">程序员指南</span></a></li>
               <li class="active" property="itemListElement" typeof="ListItem">直接路径加载接口</li>
            </ol>
            <a id="GUID-596F5F9B-47A1-48DB-8702-FEED7BE038B9" name="GUID-596F5F9B-47A1-48DB-8702-FEED7BE038B9"></a><a id="LNOCI120"></a>
            
            <h2 id="LNOCI-GUID-596F5F9B-47A1-48DB-8702-FEED7BE038B9" class="sect2"><span class="enumeration_chapter">21</span>直接路径加载接口</h2>
         </header>
         <div class="ind">
            <div>
               <p>直接路径加载函数用于将外部文件中的数据加载到表和分区中。</p>
               <p></p>
               <p>本章包含以下主题：</p>
               <ul style="list-style-type:disc">
                  <li>
                     <p><a href="direct-path-load-interface.html#GUID-5636C859-A1CD-4229-9CDF-0D477238AA05" title="直接路径加载接口使OCI应用程序能够访问Oracle数据库的直接路径加载引擎，以执行SQL * Loader实用程序的功能。">直接路径加载概述</a></p>
                  </li>
                  <li>
                     <p><a href="direct-path-load-interface.html#GUID-DD759C3F-DE1C-4227-92F7-D744BC283590" title="本节讨论使用直接路径函数上下文来加载各种非标量类型。">对象类型的直接路径加载</a></p>
                  </li>
                  <li>
                     <p><a href="direct-path-load-interface.html#GUID-A2811AF9-FD71-49E7-9658-931C9C73B363" title="要支持一次加载并非全部适合内存的数据，请使用片段加载。">片段中的直接路径加载</a></p>
                  </li>
                  <li>
                     <p><a href="direct-path-load-interface.html#GUID-E66F9F47-5465-481F-8CBE-E2B00194E102" title="以下讨论给出了句柄和属性的补充细节。">对象类型的直接路径上下文句柄和属性</a></p>
                  </li>
               </ul>
            </div><a id="LNOCI16908"></a><a id="LNOCI16907"></a><div class="props_rev_3"><a id="GUID-5636C859-A1CD-4229-9CDF-0D477238AA05" name="GUID-5636C859-A1CD-4229-9CDF-0D477238AA05"></a><h3 id="LNOCI-GUID-5636C859-A1CD-4229-9CDF-0D477238AA05" class="sect3"><span class="enumeration_section">21.1</span>直接路径加载概述</h3>
               <div>
                  <p>直接路径加载接口使OCI应用程序能够访问Oracle数据库的直接路径加载引擎，以执行SQL * Loader实用程序的功能。</p>
                  <p>此功能提供了将外部文件中的数据加载到分区表的表或分区中的功能。</p>
                  <p><a href="direct-path-load-interface.html#GUID-5636C859-A1CD-4229-9CDF-0D477238AA05__CHDDEJBF">图21-1</a>介绍了本章的主题。在图示的客户端，数据通过输入缓冲区进入列数组。<code class="codeph">OCIDirPathColArrayToStream()</code>调用通过流格式将数据移动到服务器端。这些数据传递给使用块格式化程序将数据发送到数据库表的列数组。
                  </p>
                  <div class="figure" id="GUID-5636C859-A1CD-4229-9CDF-0D477238AA05__CHDDEJBF">
                     <p class="titleinfigure">图21-1直接路径加载</p><img src="img/lnoci040.gif" alt="下面是图21-1的描述" title="下面是图21-1的描述" longdesc="img_text/lnoci040.html"><br><a href="img_text/lnoci040.html">“图21-1直接路径加载”的描述</a></div>
                  <!-- class="figure" -->
                  <p>OCI直接路径加载接口可以通过加载包含多行数据的直接路径流来加载多行。</p>
                  <p>要使用直接路径API，客户端应用程序将执行以下步骤：</p>
                  <ol>
                     <li>
                        <p>初始化OCI。</p>
                     </li>
                     <li>
                        <p>分配直接路径上下文句柄并设置属性。</p>
                     </li>
                     <li>
                        <p>提供要加载的对象（表，分区或子分区）的名称。</p>
                     </li>
                     <li>
                        <p>描述对象列的外部数据类型。</p>
                     </li>
                     <li>
                        <p>准备直接路径接口。</p>
                     </li>
                     <li>
                        <p>分配一个或多个列数组。</p>
                     </li>
                     <li>
                        <p>分配一个或多个直接路径流。</p>
                     </li>
                     <li>
                        <p>在列数组中设置条目以指向每列的输入数据值。</p>
                     </li>
                     <li>
                        <p>将列数组转换为直接路径流格式。</p>
                     </li>
                     <li>
                        <p>加载直接路径流。</p>
                     </li>
                     <li>
                        <p>检索可能发生的任何错误。</p>
                     </li>
                     <li>
                        <p>调用直接路径修整功能。</p>
                     </li>
                     <li>
                        <p>免费句柄和数据结构。</p>
                     </li>
                     <li>
                        <p>断开与服务器的连接。</p>
                     </li>
                  </ol>
                  <p>根据要加载的数据，步骤8到11可以重复多次。</p>
                  <p>直接加载操作要求加载的对象被锁定以防止对象上的DML操作。请注意，查询是无锁的，并且在加载对象时是允许的。DML锁的模式以及获得的DML锁取决于<code class="codeph">OCI_ATTR_DIRPATH_PARALLEL</code>选项的规范，以及是否正在执行分区或子分区加载而不是整个表加载。
                  </p>
                  <ul style="list-style-type:disc">
                     <li>
                        <p>对于表加载，如果<code class="codeph">OCI_ATTR_DIRPATH_PARALLEL</code>选项设置为：</p>
                        <ul style="list-style-type:disc">
                           <li>
                              <p>FALSE，然后获取表DML X-Lock</p>
                           </li>
                           <li>
                              <p>是，然后获取表DML S-Lock</p>
                           </li>
                        </ul>
                     </li>
                     <li>
                        <p>对于分区加载，如果<code class="codeph">OCI_ATTR_DIRPATH_PARALLEL</code>选项设置为：</p>
                        <ul style="list-style-type:disc">
                           <li>
                              <p>FALSE，然后获取表DML SX-Lock和分区DML X-Lock</p>
                           </li>
                           <li>
                              <p>TRUE，然后获取表DML SS-Lock和分区DML S-Lock</p>
                           </li>
                        </ul>
                     </li>
                  </ul>
                  <div class="p">本节包括以下主题：<ul style="list-style-type:disc">
                        <li>
                           <p><a href="direct-path-load-interface.html#GUID-73F3D1BF-001E-4556-A7E5-17907873FCE8" title="列出在直接路径加载操作中对标量列有效的外部数据类型。">直接路径加载支持的数据类型</a></p>
                        </li>
                        <li>
                           <p><a href="direct-path-load-interface.html#GUID-87B6B60E-4EBA-4F25-A671-8E592998A781" title="直接路径加载对应于直接路径阵列插入操作。">直接路径句柄</a></p>
                        </li>
                        <li>
                           <p><a href="direct-path-load-interface.html#GUID-F4DD008E-B9C0-42B2-9E61-19CD1C022493" title="列出并描述直接路径加载接口使用的功能。">关于直接路径接口函数</a></p>
                        </li>
                        <li>
                           <p><a href="direct-path-load-interface.html#GUID-E6D0C66F-5918-42C9-BB87-BED0A415F326" title="列出直接路径加载接口的限制。">直接路径加载接口的限制和限制</a></p>
                        </li>
                        <li>
                           <p><a href="direct-path-load-interface.html#GUID-C8D48A95-575A-46A4-86A9-A77274D94C82" title="本节介绍标量列的直接路径加载示例。">标量列的直接路径加载示例</a></p>
                        </li>
                        <li>
                           <p><a href="direct-path-load-interface.html#GUID-E41A3E45-BE34-48B2-B8D0-49A04F86725D" title="在加载需要将数据类型转换存储在表中的Oracle日期和时间戳值时，日期缓存功能可提供更高的性能。">关于在OCI中直接路径加载日期时使用日期缓存</a></p>
                        </li>
                        <li>
                           <p><a href="direct-path-load-interface.html#GUID-F29B2906-60CB-480E-8EE0-6707BF4B5463" title="描述加载流数据时验证Oracle NUMBER和DATE数据的格式。">关于验证Oracle NUMBER和DATE数据的格式</a></p>
                        </li>
                     </ul>
                  </div>
                  <div class="infoboxnotealso" id="GUID-5636C859-A1CD-4229-9CDF-0D477238AA05__GUID-8C20C27F-4DF1-455A-8AFF-C54A23BB5AF5">
                     <p class="notep1">也可以看看：</p>
                     <ul style="list-style-type:disc">
                        <li>
                           <p><a href="handle-and-descriptor-attributes.html#GUID-07F0F31C-94FF-4E3B-B8E1-C2394CB94390" title="列出并描述直接路径上下文句柄（OCIDirPathCtx）属性。">直接路径上下文句柄（OCIDirPathCtx）属性</a></p>
                        </li>
                        <li>
                           <p><a href="direct-path-loading-functions.html#GUID-3A9445D3-EBE2-40DB-B303-F204CE065356" title="从列数组格式转换为直接路径流格式。">OCIDirPathColArrayToStream（）</a></p>
                        </li>
                     </ul>
                     <p> </p>
                  </div>
               </div><a id="LNOCI16909"></a><div class="props_rev_3"><a id="GUID-73F3D1BF-001E-4556-A7E5-17907873FCE8" name="GUID-73F3D1BF-001E-4556-A7E5-17907873FCE8"></a><h4 id="LNOCI-GUID-73F3D1BF-001E-4556-A7E5-17907873FCE8" class="sect4"><span class="enumeration_section">21.1.1</span>直接路径加载支持的数据类型</h4>
                  <div>
                     <p>列出在直接路径加载操作中对标量列有效的外部数据类型。</p>
                     <p><a id="d157615e762" class="indexterm-anchor"></a><a id="d157615e766" class="indexterm-anchor"></a>以下外部数据类型对直接路径加载操作中的标量列有效：</p>
                     <ul style="list-style-type:disc">
                        <li>
                           <p><code class="codeph">SQLT_CHR</code></p>
                        </li>
                        <li>
                           <p><code class="codeph">SQLT_DAT</code></p>
                        </li>
                        <li>
                           <p><code class="codeph">SQLT_INT</code></p>
                        </li>
                        <li>
                           <p><code class="codeph">SQLT_UIN</code></p>
                        </li>
                        <li>
                           <p><code class="codeph">SQLT_FLT</code></p>
                        </li>
                        <li>
                           <p><code class="codeph">SQLT_BIN</code></p>
                        </li>
                        <li>
                           <p><code class="codeph">SQLT_NUM</code></p>
                        </li>
                        <li>
                           <p><code class="codeph">SQLT_PDN</code></p>
                        </li>
                        <li>
                           <p><code class="codeph">SQLT_CLOB</code></p>
                        </li>
                        <li>
                           <p><code class="codeph">SQLT_BLOB</code></p>
                        </li>
                        <li>
                           <p><code class="codeph">SQLT_DATE</code></p>
                        </li>
                        <li>
                           <p><code class="codeph">SQLT_TIMESTAMP</code></p>
                        </li>
                        <li>
                           <p><code class="codeph">SQLT_TIMESTAMP_TZ</code></p>
                        </li>
                        <li>
                           <p><code class="codeph">SQLT_TIMESTAMP_LTZ</code></p>
                        </li>
                        <li>
                           <p><code class="codeph">SQLT_INTERVAL_YM</code></p>
                        </li>
                        <li>
                           <p><code class="codeph">SQLT_INTERVAL_DS</code></p>
                        </li>
                     </ul>
                     <p>支持以下外部对象数据类型：</p>
                     <ul style="list-style-type:disc">
                        <li>
                           <p><code class="codeph">SQLT_NTY</code> - 列对象（ <code class="codeph">FINAL</code>和<code class="codeph">NOT FINAL</code> ）和SQL字符串列</p>
                        </li>
                        <li>
                           <p><code class="codeph">SQLT_REF</code> - <code class="codeph">REF</code>列（ <code class="codeph">FINAL</code>和<code class="codeph">NOT FINAL</code> ）</p>
                        </li>
                     </ul>
                     <p>支持以下表类型：</p>
                     <ul style="list-style-type:disc">
                        <li>
                           <p>嵌套表</p>
                        </li>
                        <li>
                           <p>对象表（ <code class="codeph">FINAL</code>和<code class="codeph">NOT FINAL</code> ）</p>
                        </li>
                     </ul>
                     <div class="infoboxnotealso" id="GUID-73F3D1BF-001E-4556-A7E5-17907873FCE8__GUID-7F3D4E68-D21B-4AF9-976E-E7CD22CB6A5F">
                        <p class="notep1">也可以看看：</p>
                        <ul style="list-style-type:disc">
                           <li>
                              <p><a href="handle-and-descriptor-attributes.html#GUID-4F32F807-FA24-49D3-9ECB-B51212A12E26" title="列出并描述直接路径列参数属性。">关于访问列参数属性</a>以获取有关设置或检索列的数据类型的信息</p>
                           </li>
                           <li>
                              <p>有关数据类型的信息，请<a href="data-types.html#GUID-D69455D9-CE01-44CC-B5A9-E541C7774805__CEGIEEJI" title="该表有4列。第1列是外部Oracle数据库数据类型，第2列是数据类型代码，第3列是C的程序变量类型，第4列是OCI定义的常量。">参见表5-2</a></p>
                           </li>
                        </ul>
                     </div>
                  </div>
               </div><a id="LNOCI16910"></a><div class="props_rev_3"><a id="GUID-87B6B60E-4EBA-4F25-A671-8E592998A781" name="GUID-87B6B60E-4EBA-4F25-A671-8E592998A781"></a><h4 id="LNOCI-GUID-87B6B60E-4EBA-4F25-A671-8E592998A781" class="sect4"><span class="enumeration_section">21.1.2</span>直接路径句柄</h4>
                  <div>
                     <p>直接路径加载对应于直接路径阵列插入操作。</p>
                     <p>直接路径加载接口使用以下句柄来跟踪加载的对象和操作的数据的规范：</p>
                     <ul style="list-style-type:disc">
                        <li>
                           <p><a href="direct-path-load-interface.html#GUID-845C453B-42D4-44BB-9EB2-03A42F782427" title="必须为要加载的每个对象（分区表的表或分区）分配直接路径上下文句柄。">直接路径上下文</a></p>
                        </li>
                        <li>
                           <p><a href="direct-path-load-interface.html#GUID-D50053C8-AAB1-4040-90C0-750281F7B242" title="使用直接路径函数上下文句柄来描述命名类型和REF列：列对象，REF列和SQL字符串列。">OCI直接路径功能上下文</a></p>
                        </li>
                        <li>
                           <p><a href="direct-path-load-interface.html#GUID-B38DA3AB-4EDE-43B3-A434-99DAE0EAF62F" title="直接路径列数组句柄和直接路径功能列句柄用于向直接路径接口呈现行数组。">直接路径列阵列和直接路径功能列阵列</a></p>
                        </li>
                        <li>
                           <p><a href="direct-path-load-interface.html#GUID-B613D75C-020C-4C65-968D-E6EF90A5ADBC" title="直接路径流是Oracle表数据的线性表示。">直接路径流</a></p>
                           <div class="infoboxnotealso" id="GUID-87B6B60E-4EBA-4F25-A671-8E592998A781__GUID-CDB66B71-19B5-401A-9DC6-ED0EF9EF6E50">
                              <p class="notep1">也可以看看：</p>
                              <p><a href="handle-and-descriptor-attributes.html#GUID-0097B016-DAD2-4AFA-9D3C-37689FA75B41" title="列出并描述直接路径加载句柄属性。">直接路径加载句柄属性</a>以及后面的直接路径属性的所有描述</p>
                           </div>
                        </li>
                     </ul>
                  </div><a id="LNOCI72725"></a><a id="LNOCI16911"></a><div class="props_rev_3"><a id="GUID-845C453B-42D4-44BB-9EB2-03A42F782427" name="GUID-845C453B-42D4-44BB-9EB2-03A42F782427"></a><h5 id="LNOCI-GUID-845C453B-42D4-44BB-9EB2-03A42F782427" class="sect5"><span class="enumeration_section">21.1.2.1</span>直接路径上下文</h5>
                     <div>
                        <p>必须为要加载的每个对象（分区表的表或分区）分配直接路径上下文句柄。</p>
                        <p>因为<code class="codeph">OCIDirPathCtx</code>句柄是<code class="codeph">OCIDirPathFuncCtx</code> ， <code class="codeph">OCIDirPathColArray,</code>和<code class="codeph">OCIDirPathStream</code>句柄的父句柄，所以释放<code class="codeph">OCIDirPathCtx</code>句柄也会释放其子句柄（尽管为了良好的编码实践，在释放父句柄之前单独处理免费<code class="codeph">OCIDirPathCtx</code> ）。
                        </p>
                        <p>使用<code class="codeph">OCIHandleAlloc()</code>分配直接路径上下文。请注意，直接路径上下文的父句柄始终是环境句柄。使用<code class="codeph">OCIHandleFree()</code>释放直接路径上下文。在所有直接路径程序的前两行中包含头文件，如<a href="direct-path-load-interface.html#GUID-845C453B-42D4-44BB-9EB2-03A42F782427__CACIIBIB">例21-1</a>所示。
                        </p>
                        <div class="example" id="GUID-845C453B-42D4-44BB-9EB2-03A42F782427__CACIIBIB">
                           <p class="titleinexample">示例21-1直接路径程序必须包含头文件</p><pre class="oac_no_warn" dir="ltr">...#include &lt;cdemodp0.h&gt; #include &lt;cdemodp.h&gt; OCIEnv * envp; OCIDirPathCtx * dpctx;剑错误; error = OCIHandleAlloc（（void *）envp，（void **）＆dpctx，OCI_HTYPE_DIRPATH_CTX，（size_t）0，（void **）0）; ...error = OCIHandleFree（dpctx，OCI_HTYPE_DIRPATH_CTX）;</pre></div>
                        <!-- class="example" -->
                        <div class="section">
                           <div class="infoboxnotealso" id="GUID-845C453B-42D4-44BB-9EB2-03A42F782427__GUID-43DAEBA4-34CC-4ECF-ACC7-A1A7F1B37BF9">
                              <p class="notep1">也可以看看：</p>
                              <ul style="list-style-type:disc">
                                 <li>
                                    <p><a href="handle-and-descriptor-functions.html#GUID-C5BF55F7-A110-4CB5-9663-5056590F12B5" title="返回指向已分配和初始化句柄的指针。">OCIHandleAlloc（）</a></p>
                                 </li>
                                 <li>
                                    <p><a href="handle-and-descriptor-functions.html#GUID-E87E9F91-D3DC-4F35-BE7C-F1EFBFEEBA0A" title="显式释放句柄">OCIHandleFree（）</a></p>
                                 </li>
                              </ul>
                           </div>
                        </div>
                        <!-- class="section" -->
                     </div>
                  </div><a id="LNOCI72726"></a><a id="LNOCI16912"></a><div class="props_rev_3"><a id="GUID-D50053C8-AAB1-4040-90C0-750281F7B242" name="GUID-D50053C8-AAB1-4040-90C0-750281F7B242"></a><h5 id="LNOCI-GUID-D50053C8-AAB1-4040-90C0-750281F7B242" class="sect5"><span class="enumeration_section">21.1.2.2</span> OCI直接路径功能上下文</h5>
                     <div>
                        <p>使用直接路径函数上下文句柄来描述命名类型和<code class="codeph">REF</code>列：列对象，REF列和SQL字符串列。
                        </p>
                        <p><code class="codeph">OCIDirPathFuncCtx</code>类型的直接路径函数上下文句柄用于描述以下命名类型和<code class="codeph">REF</code>列：</p>
                        <ul style="list-style-type:disc">
                           <li>
                              <p>列对象。这里的函数上下文描述了对象类型，它将用作构造对象的默认构造函数，以及构造函数的对象属性。</p>
                           </li>
                           <li>
                              <p><code class="codeph">REF</code>专栏。这里的函数上下文描述了一个引用行对象的单个对象表（可选），以及标识每个行对象的<code class="codeph">REF</code>参数。
                              </p>
                           </li>
                           <li>
                              <p>SQL字符串列。这里的函数上下文描述了一个SQL字符串及其参数，用于计算要加载到列中的值。</p>
                           </li>
                        </ul>
                        <p>句柄类型<code class="codeph">OCI_HTYPE_DIRPATH_FN_CTX</code>被传递给<code class="codeph">OCIHandleAlloc()</code>以指示要分配函数上下文，如<a href="direct-path-load-interface.html#GUID-D50053C8-AAB1-4040-90C0-750281F7B242__CACGFJGC">例21-2</a>所示。
                        </p>
                        <p>请注意，直接路径函数上下文的父句柄始终是直接路径上下文句柄。使用<code class="codeph">OCIHandleFree()</code>释放直接路径函数上下文句柄：</p><pre class="oac_no_warn" dir="ltr">error = OCIHandleFree（dpfnctx，OCI_HTYPE_DIRPATH_FN_CTX）;</pre><div class="example" id="GUID-D50053C8-AAB1-4040-90C0-750281F7B242__CACGFJGC">
                           <p class="titleinexample">示例21-2传递句柄类型以分配函数上下文</p><pre class="oac_no_warn" dir="ltr">OCIDirPathCtx * dpctx; / * direct path context * / OCIDirPathFuncCtx * dpfnctx; / *直接路径函数上下文* /剑错误; error = OCIHandleAlloc（（void *）dpctx，（void **）＆dpfnctx，OCI_HTYPE_DIRPATH_FN_CTX，（size_t）0，（void **）0）;</pre></div>
                        <!-- class="example" -->
                        <div class="section">
                           <div class="infoboxnotealso" id="GUID-D50053C8-AAB1-4040-90C0-750281F7B242__GUID-372F46CA-57CB-4C8B-899D-BCFF4C689B5C">
                              <p class="notep1">也可以看看：</p>
                              <ul style="list-style-type:disc">
                                 <li>
                                    <p>有关支持的数据类型的更多信息，请<a href="../adobj/sql-and-object-types.html#ADOBJ7192" target="_blank"><span><cite>参见“Oracle数据库对象关系开发人员指南”</cite></span></a></p>
                                 </li>
                                 <li>
                                    <p><a href="handle-and-descriptor-functions.html#GUID-C5BF55F7-A110-4CB5-9663-5056590F12B5" title="返回指向已分配和初始化句柄的指针。">OCIHandleAlloc（）</a></p>
                                 </li>
                                 <li>
                                    <p><a href="handle-and-descriptor-functions.html#GUID-E87E9F91-D3DC-4F35-BE7C-F1EFBFEEBA0A" title="显式释放句柄">OCIHandleFree（）</a></p>
                                 </li>
                              </ul>
                           </div>
                        </div>
                        <!-- class="section" -->
                     </div>
                  </div><a id="LNOCI72727"></a><a id="LNOCI72728"></a><a id="LNOCI16913"></a><div class="props_rev_3"><a id="GUID-B38DA3AB-4EDE-43B3-A434-99DAE0EAF62F" name="GUID-B38DA3AB-4EDE-43B3-A434-99DAE0EAF62F"></a><h5 id="LNOCI-GUID-B38DA3AB-4EDE-43B3-A434-99DAE0EAF62F" class="sect5"><span class="enumeration_section">21.1.2.3</span>直接路径列阵列和直接路径功能列阵列</h5>
                     <div>
                        <p>直接路径列数组句柄和直接路径功能列句柄用于向直接路径接口呈现行数组。</p>
                        <p>行由三个数组表示：列值，列长度和列标志。列数组上使用的方法包括：分配数组句柄并设置或获取与数组条目对应的值。</p>
                        <p>两个句柄共享相同的数据结构<code class="codeph">OCIDirPathColArray</code> ，但这些列数组句柄在父句柄和句柄类型上有所不同。
                        </p>
                        <p>直接路径列数组句柄与<code class="codeph">OCIHandleAlloc()</code>一起分配。<a href="direct-path-load-interface.html#GUID-B38DA3AB-4EDE-43B3-A434-99DAE0EAF62F__CACBICAG">例21-3</a>中的代码片段显示了直接路径列数组句柄的显式分配。
                        </p>
                        <p>使用<code class="codeph">OCIHandleFree()</code>释放直接路径列数组句柄。
                        </p><pre class="oac_no_warn" dir="ltr">error = OCIHandleFree（dpca，OCI_HTYPE_DIRPATH_COLUMN_ARRAY）;</pre><p><a href="direct-path-load-interface.html#GUID-B38DA3AB-4EDE-43B3-A434-99DAE0EAF62F__CACEDGCI">例21-4</a>显示直接路径函数列数组句柄以几乎相同的方式分配。
                        </p>
                        <p>使用<code class="codeph">OCIHandleFree()</code>释放直接路径函数列数组：</p><pre class="oac_no_warn" dir="ltr">error = OCIHandleFree（dpfnca，OCI_HTYPE_DIRPATH_FN_COL_ARRAY）;</pre><p>释放<code class="codeph">OCIDirPathColArray</code>句柄还可以释放与句柄关联的列数组。
                        </p>
                        <div class="example" id="GUID-B38DA3AB-4EDE-43B3-A434-99DAE0EAF62F__CACBICAG">
                           <p class="titleinexample">例21-3直接路径列数组句柄的显式分配</p><pre class="oac_no_warn" dir="ltr">OCIDirPathCtx * dpctx; / * direct path context * / OCIDirPathColArray * dpca; / *直接路径列数组* /剑错误; error = OCIHandleAlloc（（void *）dpctx，（void **）＆dpca，OCI_HTYPE_DIRPATH_COLUMN_ARRAY，（size_t）0，（void **）0）;</pre></div>
                        <!-- class="example" -->
                        <div class="example" id="GUID-B38DA3AB-4EDE-43B3-A434-99DAE0EAF62F__CACEDGCI">
                           <p class="titleinexample">例21-4直接路径功能列数组句柄的显式分配</p><pre class="oac_no_warn" dir="ltr">OCIDirPathFuncCtx * dpfnctx; / *直接路径函数上下文* / OCIDirPathColArray * dpfnca; / *直接路径函数列数组* /剑错误; error = OCIHandleAlloc（（void *）dpfnctx，（void **）＆dpfnca，（ub4）OCI_HTYPE_DIRPATH_FN_COL_ARRAY，（size_t）0，（void **）0）;</pre></div>
                        <!-- class="example" -->
                        <div class="section">
                           <div class="infoboxnotealso" id="GUID-B38DA3AB-4EDE-43B3-A434-99DAE0EAF62F__GUID-130A01DA-4844-4A25-A97D-943CD724304F">
                              <p class="notep1">也可以看看：</p>
                              <p><a href="handle-and-descriptor-functions.html#GUID-C5BF55F7-A110-4CB5-9663-5056590F12B5" title="返回指向已分配和初始化句柄的指针。">OCIHandleAlloc（）</a></p>
                           </div>
                        </div>
                        <!-- class="section" -->
                     </div>
                  </div><a id="LNOCI72729"></a><a id="LNOCI16914"></a><div class="props_rev_3"><a id="GUID-B613D75C-020C-4C65-968D-E6EF90A5ADBC" name="GUID-B613D75C-020C-4C65-968D-E6EF90A5ADBC"></a><h5 id="LNOCI-GUID-B613D75C-020C-4C65-968D-E6EF90A5ADBC" class="sect5"><span class="enumeration_section">21.1.2.4</span>直接路径流</h5>
                     <div>
                        <p>直接路径流是Oracle表数据的线性表示。</p>
                        <p>直接路径流句柄由转换操作<code class="codeph">OCIDirPathColArrayToStream()</code>和加载操作<code class="codeph">OCIDirPathLoadStream()</code> 。
                        </p>
                        <p>客户端使用<code class="codeph">OCIHandleAlloc()</code>分配直接路径流句柄。<code class="codeph">OCIDirPathStream</code>句柄的结构可以被认为是形式（缓冲区，缓冲区长度）中的一对。
                        </p>
                        <p>转换操作始终附加到流的末尾。加载操作始终从流的开头开始。完全加载流后，必须通过调用<code class="codeph">OCIDirPathStreamReset()</code>重置流。
                        </p>
                        <p><a href="direct-path-load-interface.html#GUID-B613D75C-020C-4C65-968D-E6EF90A5ADBC__CACGGEEA">例21-5</a>显示了使用<code class="codeph">OCIHandleAlloc()</code>分配的直接路径流句柄。父句柄始终是<code class="codeph">OCIDirPathCtx</code>句柄。
                        </p>
                        <p>使用<code class="codeph">OCIHandleFree()</code>释放直接路径流句柄。
                        </p><pre class="oac_no_warn" dir="ltr">error = OCIHandleFree（dpstr，OCI_HTYPE_DIRPATH_STREAM）;</pre><p>释放<code class="codeph">OCIDirPathStream</code>句柄还释放与句柄关联的流缓冲区。
                        </p>
                        <div class="example" id="GUID-B613D75C-020C-4C65-968D-E6EF90A5ADBC__CACGGEEA">
                           <p class="titleinexample">例21-5分配直接路径流句柄</p><pre class="oac_no_warn" dir="ltr">OCIDirPathCtx * dpctx; / * direct path context * / OCIDirPathStream * dpstr; / *直接路径流* /剑错误; error = OCIHandleAlloc（（void *）dpctx，（void **）＆dpstr，OCI_HTYPE_DIRPATH_STREAM，（size_t）0，（void **）0）;</pre></div>
                        <!-- class="example" -->
                        <div class="section">
                           <div class="infoboxnotealso" id="GUID-B613D75C-020C-4C65-968D-E6EF90A5ADBC__GUID-D6F80708-5CBB-4A03-B638-989B7A86BBED">
                              <p class="notep1">也可以看看：</p>
                              <ul style="list-style-type:disc">
                                 <li>
                                    <p><a href="direct-path-loading-functions.html#GUID-3A9445D3-EBE2-40DB-B303-F204CE065356" title="从列数组格式转换为直接路径流格式。">OCIDirPathColArrayToStream（）</a></p>
                                 </li>
                                 <li>
                                    <p><a href="direct-path-loading-functions.html#GUID-309D9948-26C2-40F7-813D-ECDA2BF3D99C" title="加载转换为直接路径流格式的数据。">OCIDirPathLoadStream（）</a></p>
                                 </li>
                                 <li>
                                    <p><a href="handle-and-descriptor-functions.html#GUID-C5BF55F7-A110-4CB5-9663-5056590F12B5" title="返回指向已分配和初始化句柄的指针。">OCIHandleAlloc（）</a></p>
                                 </li>
                                 <li>
                                    <p><a href="direct-path-loading-functions.html#GUID-24744BD2-9B4B-411D-A9DB-CCAD82B335E3" title="重置直接路径流状态。">OCIDirPathStreamReset（）</a></p>
                                 </li>
                              </ul>
                           </div>
                        </div>
                        <!-- class="section" -->
                     </div>
                  </div>
               </div><a id="LNOCI16916"></a><a id="LNOCI16917"></a><a id="LNOCI16915"></a><div class="props_rev_3"><a id="GUID-F4DD008E-B9C0-42B2-9E61-19CD1C022493" name="GUID-F4DD008E-B9C0-42B2-9E61-19CD1C022493"></a><h4 id="LNOCI-GUID-F4DD008E-B9C0-42B2-9E61-19CD1C022493" class="sect4"><span class="enumeration_section">21.1.3</span>关于直接路径接口函数</h4>
                  <div>
                     <p>列出并描述直接路径加载接口使用的功能。</p>
                     <p>本节中列出的函数与直接路径加载接口一起使用。</p>
                     <p>直接路径上下文的操作由<a href="direct-path-load-interface.html#GUID-F4DD008E-B9C0-42B2-9E61-19CD1C022493__CACFGHAG" title="该表有2列。第1列是直接路径上下文函数名称，第2列描述其用途。">表21-1中</a>的函数执行。
                     </p>
                     <div class="tblformal" id="GUID-F4DD008E-B9C0-42B2-9E61-19CD1C022493__CACFGHAG">
                        <p class="titleintable">表21-1直接路径上下文功能</p>
                        <table cellpadding="4" cellspacing="0" class="Formal" title="直接路径上下文函数" width="100%" border="1" summary="This table has 2 columns. Column 1 is the direct path context function name and column 2 describes its purpose." frame="hsides" rules="rows">
                           <thead>
                              <tr align="left" valign="top">
                                 <th align="left" valign="bottom" width="34%" id="d157615e2377">功能</th>
                                 <th align="left" valign="bottom" width="66%" id="d157615e2380">目的</th>
                              </tr>
                           </thead>
                           <tbody>
                              <tr align="left" valign="top">
                                 <td align="left" valign="top" width="34%" id="d157615e2385" headers="d157615e2377 ">
                                    <p><a href="direct-path-loading-functions.html#GUID-18E9C795-0770-4793-A176-EF9C114ADD62" title="终止直接路径操作。">OCIDirPathAbort（）</a></p>
                                 </td>
                                 <td align="left" valign="top" width="66%" headers="d157615e2385 d157615e2380 ">
                                    <p>终止直接路径操作</p>
                                 </td>
                              </tr>
                              <tr align="left" valign="top">
                                 <td align="left" valign="top" width="34%" id="d157615e2397" headers="d157615e2377 ">
                                    <p><a href="direct-path-loading-functions.html#GUID-BAFCC070-7E97-4F77-8CF9-D78E05420FF2" title="根据请求的操作，执行数据保存点，或提交已加载的数据并完成直接路径加载操作。">OCIDirPathDataSave（）</a></p>
                                 </td>
                                 <td align="left" valign="top" width="66%" headers="d157615e2397 d157615e2380 ">
                                    <p>执行数据保存点</p>
                                 </td>
                              </tr>
                              <tr align="left" valign="top">
                                 <td align="left" valign="top" width="34%" id="d157615e2409" headers="d157615e2377 ">
                                    <p><a href="direct-path-loading-functions.html#GUID-EA1DCB4D-40FB-4B32-B001-14936A079C7E" title="完成直接路径加载操作。">OCIDirPathFinish（）</a></p>
                                 </td>
                                 <td align="left" valign="top" width="66%" headers="d157615e2409 d157615e2380 ">
                                    <p>提交加载的数据</p>
                                 </td>
                              </tr>
                              <tr align="left" valign="top">
                                 <td align="left" valign="top" width="34%" id="d157615e2421" headers="d157615e2377 ">
                                    <p><a href="direct-path-loading-functions.html#GUID-4F459030-42F8-49D0-8EC8-6D2D9E63BC40" title="从服务器刷新部分加载的行。不推荐使用此功能。">OCIDirPathFlushRow（）</a></p>
                                 </td>
                                 <td align="left" valign="top" width="66%" headers="d157615e2421 d157615e2380 ">
                                    <p>从服务器刷新部分加载的行。不推荐使用此功能。</p>
                                 </td>
                              </tr>
                              <tr align="left" valign="top">
                                 <td align="left" valign="top" width="34%" id="d157615e2433" headers="d157615e2377 ">
                                    <p><a href="direct-path-loading-functions.html#GUID-309D9948-26C2-40F7-813D-ECDA2BF3D99C" title="加载转换为直接路径流格式的数据。">OCIDirPathLoadStream（）</a></p>
                                 </td>
                                 <td align="left" valign="top" width="66%" headers="d157615e2433 d157615e2380 ">
                                    <p>加载已转换为直接路径流格式的数据</p>
                                 </td>
                              </tr>
                              <tr align="left" valign="top">
                                 <td align="left" valign="top" width="34%" id="d157615e2445" headers="d157615e2377 ">
                                    <p><a href="direct-path-loading-functions.html#GUID-8EE17BD0-02A9-4065-B501-CAF087BA4317">OCIDirPathPrepare（）</a></p>
                                 </td>
                                 <td align="left" valign="top" width="66%" headers="d157615e2445 d157615e2380 ">
                                    <p>准备直接路径接口以转换或加载行</p>
                                 </td>
                              </tr>
                           </tbody>
                        </table>
                     </div>
                     <!-- class="inftblhruleinformal" -->
                     <p>直接路径列阵列上的操作由<a href="direct-path-load-interface.html#GUID-F4DD008E-B9C0-42B2-9E61-19CD1C022493__G434329" title="该表有2列。第1列是直接路径列数组函数名称，第2列描述其用途。">表21-2中</a>的函数执行。
                     </p>
                     <div class="tblformal" id="GUID-F4DD008E-B9C0-42B2-9E61-19CD1C022493__G434329">
                        <p class="titleintable">表21-2直接路径列数组函数</p>
                        <table cellpadding="4" cellspacing="0" class="Formal" title="直接路径列数组函数" width="100%" border="1" summary="This table has 2 columns. Column 1 is the direct path column array function name and column 2 describes its purpose." frame="hsides" rules="rows">
                           <thead>
                              <tr align="left" valign="top">
                                 <th align="left" valign="bottom" width="44%" id="d157615e2470">功能</th>
                                 <th align="left" valign="bottom" width="56%" id="d157615e2473">目的</th>
                              </tr>
                           </thead>
                           <tbody>
                              <tr align="left" valign="top">
                                 <td align="left" valign="top" width="44%" id="d157615e2478" headers="d157615e2470 ">
                                    <p><a href="direct-path-loading-functions.html#GUID-12EE690E-3987-400E-B069-17D9F5ABEB7F">OCIDirPathColArrayEntryGet（）</a></p>
                                 </td>
                                 <td align="left" valign="top" width="56%" headers="d157615e2478 d157615e2473 ">
                                    <p>获取列数组中的指定条目</p>
                                 </td>
                              </tr>
                              <tr align="left" valign="top">
                                 <td align="left" valign="top" width="44%" id="d157615e2487" headers="d157615e2470 ">
                                    <p><a href="direct-path-loading-functions.html#GUID-4E4E74F4-3F15-4176-8229-C5783DC3811D" title="将列数组中的指定条目设置为提供的值。">OCIDirPathColArrayEntrySet（）</a></p>
                                 </td>
                                 <td align="left" valign="top" width="56%" headers="d157615e2487 d157615e2473 ">
                                    <p>将列数组中的指定条目设置为特定值</p>
                                 </td>
                              </tr>
                              <tr align="left" valign="top">
                                 <td align="left" valign="top" width="44%" id="d157615e2499" headers="d157615e2470 ">
                                    <p><a href="direct-path-loading-functions.html#GUID-CBFB73B8-2DDE-45A5-8C4F-EED73BFAA432" title="获取给定行号的列数组行指针。">OCIDirPathColArrayRowGet（）</a></p>
                                 </td>
                                 <td align="left" valign="top" width="56%" headers="d157615e2499 d157615e2473 ">
                                    <p>获取指定行号的基本行指针</p>
                                 </td>
                              </tr>
                              <tr align="left" valign="top">
                                 <td align="left" valign="top" width="44%" id="d157615e2511" headers="d157615e2470 ">
                                    <p><a href="direct-path-loading-functions.html#GUID-AFFEAFE6-CFC6-4D77-ABB3-5F7C005F2519" title="重置列数组状态。">OCIDirPathColArrayReset（）</a></p>
                                 </td>
                                 <td align="left" valign="top" width="56%" headers="d157615e2511 d157615e2473 ">
                                    <p>重置行数组状态</p>
                                 </td>
                              </tr>
                              <tr align="left" valign="top">
                                 <td align="left" valign="top" width="44%" id="d157615e2523" headers="d157615e2470 ">
                                    <p><a href="direct-path-loading-functions.html#GUID-3A9445D3-EBE2-40DB-B303-F204CE065356" title="从列数组格式转换为直接路径流格式。">OCIDirPathColArrayToStream（）</a></p>
                                 </td>
                                 <td align="left" valign="top" width="56%" headers="d157615e2523 d157615e2473 ">
                                    <p>从列数组格式转换为直接路径流格式</p>
                                 </td>
                              </tr>
                           </tbody>
                        </table>
                     </div>
                     <!-- class="inftblhruleinformal" -->
                     <p>直接路径流上的操作由重置直接流状态的函数<a href="direct-path-loading-functions.html#GUID-24744BD2-9B4B-411D-A9DB-CCAD82B335E3" title="重置直接路径流状态。">OCIDirPathStreamReset（）</a>执行。
                     </p>
                     <div class="infoboxnotealso" id="GUID-F4DD008E-B9C0-42B2-9E61-19CD1C022493__GUID-985EC478-FA83-4349-AF1F-1EDAEEB944E1">
                        <p class="notep1">也可以看看：</p>
                        <p><a href="direct-path-loading-functions.html#GUID-47DC91B9-305F-4649-AC1C-D01F09F3067C" title="列出并描述直接路径加载功能。">直接路径加载功能，</a>用于详细描述每个功能</p>
                     </div>
                  </div>
               </div><a id="LNOCI16918"></a><div class="props_rev_3"><a id="GUID-E6D0C66F-5918-42C9-BB87-BED0A415F326" name="GUID-E6D0C66F-5918-42C9-BB87-BED0A415F326"></a><h4 id="LNOCI-GUID-E6D0C66F-5918-42C9-BB87-BED0A415F326" class="sect4"><span class="enumeration_section">21.1.4</span>直接路径加载接口的限制和限制</h4>
                  <div>
                     <p>列出直接路径加载接口的限制。</p>
                     <p>直接路径加载接口具有以下限制，与SQL * Loader相同：</p>
                     <ul style="list-style-type:disc">
                        <li>
                           <p>不支持触发器。</p>
                        </li>
                        <li>
                           <p>不支持参照完整性约束。</p>
                        </li>
                        <li>
                           <p>不支持群集表。</p>
                        </li>
                        <li>
                           <p>不支持加载远程对象。</p>
                        </li>
                        <li>
                           <p>必须最后指定<code class="codeph">LONGs</code> 。
                           </p>
                        </li>
                        <li>
                           <p>不支持返回LOB，对象或集合的SQL字符串。</p>
                        </li>
                        <li>
                           <p>不支持加载<code class="codeph">VARRAY</code>列。
                           </p>
                        </li>
                        <li>
                           <p>所有分区列必须位于任何LOB之前。这是因为在开始写入LOB之前，您必须确定LOB进入的分区。</p>
                        </li>
                     </ul>
                  </div>
               </div><a id="LNOCI16919"></a><div class="props_rev_3"><a id="GUID-C8D48A95-575A-46A4-86A9-A77274D94C82" name="GUID-C8D48A95-575A-46A4-86A9-A77274D94C82"></a><h4 id="LNOCI-GUID-C8D48A95-575A-46A4-86A9-A77274D94C82" class="sect4"><span class="enumeration_section">21.1.5</span>标量列的直接路径加载示例</h4>
                  <div>
                     <p>本节介绍标量列的直接路径加载示例。</p>
                     <div class="p">以下主题对此进行了描述：<ul style="list-style-type:disc">
                           <li>
                              <p><a href="direct-path-load-interface.html#GUID-5D0D980B-F171-43E4-9092-DB08EC38F500" title="显示在直接路径加载中使用数据结构的示例。">直接路径加载示例中使用的数据结构</a></p>
                           </li>
                           <li>
                              <p><a href="direct-path-load-interface.html#GUID-044CA338-D429-4657-8D90-FC8C521D777E" title="显示示例代码，说明如何使用多个OCI直接路径接口。">标量列的直接路径加载示例概述</a></p>
                           </li>
                        </ul>
                     </div>
                  </div><a id="LNOCI72730"></a><a id="LNOCI72731"></a><a id="LNOCI16920"></a><div class="props_rev_3"><a id="GUID-5D0D980B-F171-43E4-9092-DB08EC38F500" name="GUID-5D0D980B-F171-43E4-9092-DB08EC38F500"></a><h5 id="LNOCI-GUID-5D0D980B-F171-43E4-9092-DB08EC38F500" class="sect5"><span class="enumeration_section">21.1.5.1</span>直接路径加载示例中使用的数据结构</h5>
                     <div>
                        <p>显示在直接路径加载中使用数据结构的示例。</p>
                        <p><a href="direct-path-load-interface.html#GUID-5D0D980B-F171-43E4-9092-DB08EC38F500__CACBDCEE">例21-6</a>显示了<a href="direct-path-load-interface.html#GUID-5D0D980B-F171-43E4-9092-DB08EC38F500__CACBEJCG">实施例21-7</a>至<a href="direct-path-load-interface.html#GUID-044CA338-D429-4657-8D90-FC8C521D777E__CACDGHIB">实施例21-17中</a>使用的数据结构。
                        </p>
                        <p><a href="direct-path-load-interface.html#GUID-5D0D980B-F171-43E4-9092-DB08EC38F500__CACBEJCG">例21-7</a>显示了<code class="codeph">demo</code>目录中的头文件<code class="codeph">cdemodp.h</code> ，它定义了几个结构。
                        </p>
                        <div class="example" id="GUID-5D0D980B-F171-43E4-9092-DB08EC38F500__CACBDCEE">
                           <p class="titleinexample">示例21-6直接路径加载示例中使用的数据结构</p><pre class="oac_no_warn" dir="ltr">/ *加载控制结构* / struct loadctl {ub4 nrow_ctl; / *列数组中的行数* / ub2 ncol_ctl; / *列数组中的列数* / OCIEnv * envhp_ctl; / * environment handle * / OCIServer * srvhp_ctl; / * server handle * / OCIError * errhp_ctl; / *错误句柄* / OCIError * errhp2_ctl; / *另一个错误句柄* / OCISvcCtx * svchp_ctl; / *服务上下文* / OCISession * authp_ctl; / * authentication context * / OCIParam * colLstDesc_ctl; / *列列表参数句柄* / OCIDirPathCtx * dpctx_ctl; / * direct path context * / OCIDirPathColArray * dpca_ctl; / *直接路径列数组句柄* / OCIDirPathColArray * dpobjca_ctl; / * dp列数组句柄为obj * / OCIDirPathColArray * dpnestedobjca_ctl; / * dp col数组hndl用于嵌套obj * / OCIDirPathStream * dpstr_ctl; / *直接路径流句柄* / ub1 * buf_ctl; / * pre-alloc'd缓冲区用于外部数据* / ub4 bufsz_ctl; / * buf_ctl的大小，以字节为单位* / ub4 bufoff_ctl; / *偏移到buf_ctl * / ub4 * otor_ctl; / *抵消Recnum映射* / ub1 * inbuf_ctl; / *缓冲区用于输入记录* / struct pctx pctx_ctl; / *部分字段上下文* / boolean loadobjcol_ctl; / *加载到obj col（s）？T / F * /};</pre></div>
                        <!-- class="example" -->
                        <div class="example" id="GUID-5D0D980B-F171-43E4-9092-DB08EC38F500__CACBEJCG">
                           <p class="titleinexample">示例21-7头文件cdemodp.h的内容</p><pre class="oac_no_warn" dir="ltr">#ifndef cdemodp_ORACLE #define cdemodp_ORACLE #include &lt;oratypes.h&gt; #ifndef externdef #definedetern＃endif / *外部列属性* / struct col {text * name_col; / *列名* / ub2 id_col; / *列加载ID * / ub2 exttyp_col; / *外部类型* / text * datemask_col; / * datemask，如果适用* / ub1 prec_col; / *精度，如果适用* / sb1 scale_col; / *比例，如果适用* / ub2 csid_col; / *字符集ID * / ub1 date_col; / *列是chrdate还是日期？1 =真。 0 = FALSE * / struct obj * obj_col; / *对象的描述，如果适用* / #define COL_OID 0x1 / * col是OID * / ub4 flag_col; }; / *输入字段描述符*对于此示例（和简单），*字段是严格位置的。* / struct fld {ub4 begpos_fld; / * 1-based起始位置* / ub4 endpos_fld; / * 1-based结束位置* / ub4 maxlen_fld; / *行外字段的最大长度* / ub4 flag_fld; #define FLD_INLINE 0x1 #define FLD_OUTOFLINE 0x2 #define FLD_STRIP_LEAD_BLANK 0x4 #define FLD_STRIP_TRAIL_BLANK 0x8}; struct obj {text * name_obj; / * type name * / ub2 ncol_obj; / * col_obj中的列数* / struct col * col_obj; / *列属性* / struct fld * fld_obj; / *字段描述符* / ub4 rowoff_obj; / *列数组中的当前行偏移量* / ub4 nrows_obj; / * col数组中的行数* / OCIDirPathFuncCtx * ctx_obj; / *此obj列的函数上下文* / OCIDirPathColArray * ca_obj; / *这个obj列的列数组* / ub4 flag_obj; / * obj * / #define类型OBJ_OBJ 0x1 / * obj col * / #define OBJ_OPQ 0x2 / * opaque / sql str col * / #define OBJ_REF 0x4 / * ref col * /}; struct tbl {text * owner_tbl; / * table owner * / text * name_tbl; / *表名* / text * subname_tbl; / * subname，如果适用* / ub2 ncol_tbl; / * col_tbl中的列数* / text * dfltdatemask_tbl; / *表级默认日期掩码* / struct col * col_tbl; / *列属性* / struct fld * fld_tbl; / *字段描述符* / ub1 parallel_tbl; / * parallel：1表示true * / ub1 nolog_tbl; / * no logging：1 for true * / ub4 xfrsz_tbl; / *传输缓冲区大小，以字节为单位* / text * objconstr_tbl; / * obj constr / type如果加载派生的obj * /}; struct sess / *直接路径加载会话的选项* / {text * username_sess; / * user * / text * password_sess; / *密码* / text * inst_sess; / *远程实例名称* / text * outfn_sess; / *输出文件名* / ub4 maxreclen_sess; / *输入记录的最大大小，以字节为单位* /}; #endif / * cdemodp_ORACLE * /</pre></div>
                        <!-- class="example" -->
                     </div>
                  </div><a id="LNOCI72733"></a><a id="LNOCI72735"></a><a id="LNOCI72737"></a><a id="LNOCI72739"></a><a id="LNOCI72741"></a><a id="LNOCI72743"></a><a id="LNOCI72745"></a><a id="LNOCI72747"></a><a id="LNOCI72749"></a><a id="LNOCI72732"></a><a id="LNOCI72734"></a><a id="LNOCI72736"></a><a id="LNOCI72738"></a><a id="LNOCI72740"></a><a id="LNOCI72742"></a><a id="LNOCI72744"></a><a id="LNOCI72746"></a><a id="LNOCI72748"></a><a id="LNOCI72750"></a><a id="LNOCI16921"></a><div class="props_rev_3"><a id="GUID-044CA338-D429-4657-8D90-FC8C521D777E" name="GUID-044CA338-D429-4657-8D90-FC8C521D777E"></a><h5 id="LNOCI-GUID-044CA338-D429-4657-8D90-FC8C521D777E" class="sect5"><span class="enumeration_section">21.1.5.2</span>标量列的直接路径加载示例概述</h5>
                     <div>
                        <p>显示示例代码，说明如何使用多个OCI直接路径接口。</p>
                        <div class="section">
                           <p><a href="direct-path-load-interface.html#GUID-044CA338-D429-4657-8D90-FC8C521D777E__CACHIHDD">例21-8</a>显示了示例代码，说明了几个OCI直接路径接口的使用。它不是一个完整的代码示例。
                           </p>
                           <p><span class="italic">init_load</span>函数使用<span class="italic">tblp</span>描述的表上的直接路径API执行直接路径加载。通过<span class="italic">CTLP</span>给出的<span class="italic">loadctl</span>结构具有适当初始化环境和服务上下文。已与服务器建立连接。
                           </p>
                           <p>此处还设置了其他属性，例如<code class="codeph">OCI_ATTR_SUB_NAME</code>和<code class="codeph">OCI_ATTR_SCHEMA_NAME</code> 。设置属性后，准备负载。
                           </p><pre class="oac_no_warn" dir="ltr">OCI_CHECK（ctlp-&gt; errhp_ctl，OCI_HTYPE_ERROR，ociret，ctlp，OCIDirPathPrepare（dpctx，ctlp-&gt; svchp_ctl，ctlp-&gt; errhp_ctl））;</pre></div>
                        <!-- class="section" -->
                        <div class="section">
                           <p class="subhead3" id="GUID-044CA338-D429-4657-8D90-FC8C521D777E__GUID-8DC7EC28-2E11-466A-8217-9B0E30ABDAB6">分配列数组和流句柄</p>
                        </div>
                        <!-- class="section" -->
                        <div class="section">
                           <p>请注意，直接路径上下文句柄是列数组和流句柄的父句柄，如<a href="direct-path-load-interface.html#GUID-044CA338-D429-4657-8D90-FC8C521D777E__CACIBGCE">例21-9</a>所示。另请注意，使用与直接路径上下文关联的环境句柄返回错误。
                           </p>
                        </div>
                        <!-- class="section" -->
                        <div class="section">
                           <p class="subhead3" id="GUID-044CA338-D429-4657-8D90-FC8C521D777E__GUID-2CD61E23-C0A0-43E6-A2DC-2781EC4306DC">获取行数和列数</p>
                        </div>
                        <!-- class="section" -->
                        <div class="section">
                           <p>获取刚刚分配的列数组中的行数和列数，如<a href="direct-path-load-interface.html#GUID-044CA338-D429-4657-8D90-FC8C521D777E__CACEDHIG">例21-10</a>所示。
                           </p>
                        </div>
                        <!-- class="section" -->
                        <div class="section">
                           <p class="subhead3" id="GUID-044CA338-D429-4657-8D90-FC8C521D777E__GUID-3CFC6981-54A6-41D9-8FAC-DDB4E62825B4">设置输入数据字段</p>
                        </div>
                        <!-- class="section" -->
                        <div class="section">
                           <p>将输入数据字段设置为其对应的数据列，如<a href="direct-path-load-interface.html#GUID-044CA338-D429-4657-8D90-FC8C521D777E__CACEEJGJ">例21-11</a>所示。
                           </p>
                        </div>
                        <!-- class="section" -->
                        <div class="section">
                           <p class="subhead3" id="GUID-044CA338-D429-4657-8D90-FC8C521D777E__GUID-F923A40D-83C5-49FA-AB64-AB88EC8E6267">重置列数组状态</p>
                        </div>
                        <!-- class="section" -->
                        <div class="section">
                           <p>重置列阵列状态，以防必须继续先前的转换或行需要更多数据，如<a href="direct-path-load-interface.html#GUID-044CA338-D429-4657-8D90-FC8C521D777E__CACGHJED">例21-12</a>所示。
                           </p>
                        </div>
                        <!-- class="section" -->
                        <div class="section">
                           <p class="subhead3" id="GUID-044CA338-D429-4657-8D90-FC8C521D777E__GUID-AB8ACC22-F40E-483C-91CF-6431021BDE31">重置流状态</p>
                        </div>
                        <!-- class="section" -->
                        <div class="section">
                           <p>重置流状态以启动新流，如<a href="direct-path-load-interface.html#GUID-044CA338-D429-4657-8D90-FC8C521D777E__CACJCJHC">例21-13</a>所示。否则，流中的数据将附加到现有数据。
                           </p>
                        </div>
                        <!-- class="section" -->
                        <div class="section">
                           <p class="subhead3" id="GUID-044CA338-D429-4657-8D90-FC8C521D777E__GUID-183E4C34-271A-4CF9-89F0-FB3E8ED79280">将列数组中的数据转换为流格式</p>
                        </div>
                        <!-- class="section" -->
                        <div class="section">
                           <p>输入数据后，将列数组中的数据转换为流格式并过滤掉任何不良记录，如<a href="direct-path-load-interface.html#GUID-044CA338-D429-4657-8D90-FC8C521D777E__CACIIBGH">例21-14</a>所示。
                           </p>
                        </div>
                        <!-- class="section" -->
                        <div class="section">
                           <p class="subhead3" id="GUID-044CA338-D429-4657-8D90-FC8C521D777E__GUID-283AAC48-D9FD-4161-9DB9-2D920C19FFCA">加载流</p>
                        </div>
                        <!-- class="section" -->
                        <div class="section">
                           <p>请注意，流中的位置在内部维护到流句柄，以及生成流的列数组的偏移量信息。完成到流格式的转换后，数据将附加到流中，如<a href="direct-path-load-interface.html#GUID-044CA338-D429-4657-8D90-FC8C521D777E__CACGJIHI">例21-15</a>所示。调用者有责任在适当时重置流。在出现错误时，如果最后一行发生错误，则位置将移至下一行或流的末尾。下一个<code class="codeph">OCIDirPathLoadStream()</code>调用在下一行开始，如果有的话。如果进行了<code class="codeph">OCIDirPathLoadStream()</code>调用并且已到达流的末尾，则返回<code class="codeph">OCI_NO_DATA</code> 。
                           </p>
                        </div>
                        <!-- class="section" -->
                        <div class="section">
                           <p class="subhead3" id="GUID-044CA338-D429-4657-8D90-FC8C521D777E__GUID-15AC1D1C-A79E-4D2E-BE68-3C070D8CF12E">完成直接路径加载</p>
                        </div>
                        <!-- class="section" -->
                        <div class="section">
                           <p>完成直接路径加载，如<a href="direct-path-load-interface.html#GUID-044CA338-D429-4657-8D90-FC8C521D777E__CACHAHGB">例21-16</a>所示。
                           </p>
                        </div>
                        <!-- class="section" -->
                        <div class="section">
                           <p class="subhead3" id="GUID-044CA338-D429-4657-8D90-FC8C521D777E__GUID-025A0866-CD8D-4682-9B30-E33818810932">释放直接路径句柄</p>
                        </div>
                        <!-- class="section" -->
                        <div class="section">
                           <p>释放所有分配的直接路径句柄，如<a href="direct-path-load-interface.html#GUID-044CA338-D429-4657-8D90-FC8C521D777E__CACDGHIB">例21-17</a>所示。请注意，在释放父直接路径上下文句柄之前，将释放直接路径列数组和流句柄。
                           </p>
                        </div>
                        <!-- class="section" -->
                        <div class="example" id="GUID-044CA338-D429-4657-8D90-FC8C521D777E__CACHIHDD">
                           <p class="titleinexample">例21-8 OCI直接路径接口的使用</p><pre class="oac_no_warn" dir="ltr">STATICF void init_load（ctlp，tblp）struct loadctl * ctlp; struct tbl * tblp; {struct col * colp; struct fld * fldp;剑ociret; / *从OCI调用返回代码* / OCIDirPathCtx * dpctx; / *直接路径上下文* / OCIParam * colDesc; / *列参数描述符* / ub1 parmtyp; ub1 * timestamp =（ub1 *）0; ub4尺寸; ub4我; ub4 pos; / *分配并初始化直接路径上下文* / / *有关OCI_CHECK * / OCI_CHECK的定义，请参阅cdemodp.c（ctlp-&gt; envhp_ctl，OCI_HTYPE_ENV，ociret，ctlp，OCIHandleAlloc（（void *）ctlp-&gt; envhp_ctl，（void **）＆ctlp-&gt; dpctx_ctl，（ub4）OCI_HTYPE_DIRPATH_CTX，（size_t）0，（void **）0））; dpctx = ctlp-&gt; dpctx_ctl; / *简写* / OCI_CHECK（ctlp-&gt; errhp_ctl，OCI_HTYPE_ERROR，ociret，ctlp，OCIAttrSet（（void *）dpctx，（ub4）OCI_HTYPE_DIRPATH_CTX，（void *）tblp-&gt; name_tbl，（ub4）strlen（（const char *） tblp-&gt; name_tbl），（ub4）OCI_ATTR_NAME，ctlp-&gt; errhp_ctl））;</pre></div>
                        <!-- class="example" -->
                        <div class="example" id="GUID-044CA338-D429-4657-8D90-FC8C521D777E__CACIBGCE">
                           <p class="titleinexample">示例21-9分配列数组和流句柄</p><pre class="oac_no_warn" dir="ltr">OCI_CHECK（ctlp-&gt; envhp_ctl，OCI_HTYPE_ENV，ociret，ctlp，OCIHandleAlloc（（void *）ctlp-&gt; dpctx_ctl，（void **）＆ctlp-&gt; dpca_ctl，（ub4）OCI_HTYPE_DIRPATH_COLUMN_ARRAY，（size_t）0，（void **）0 ））; OCI_CHECK（ctlp-&gt; envhp_ctl，OCI_HTYPE_ENV，ociret，ctlp，OCIHandleAlloc（（void *）ctlp-&gt; dpctx_ctl，（void **）＆ctlp-&gt; dpstr_ctl，（ub4）OCI_HTYPE_DIRPATH_STREAM，（size_t）0，（void **）0 ））;</pre></div>
                        <!-- class="example" -->
                        <div class="example" id="GUID-044CA338-D429-4657-8D90-FC8C521D777E__CACEDHIG">
                           <p class="titleinexample">示例21-10获取行数和列数</p><pre class="oac_no_warn" dir="ltr">OCI_CHECK（ctlp-&gt; errhp_ctl，OCI_HTYPE_ERROR，ociret，ctlp，OCIAttrGet（ctlp-&gt; dpca_ctl，（ub4）OCI_HTYPE_DIRPATH_COLUMN_ARRAY，＆ctlp-&gt; nrow_ctl，0，OCI_ATTR_NUM_ROWS，ctlp-&gt; errhp_ctl））; OCI_CHECK（ctlp-&gt; errhp_ctl，OCI_HTYPE_ERROR，ociret，ctlp，OCIAttrGet（ctlp-&gt; dpca_ctl，（ub4）OCI_HTYPE_DIRPATH_COLUMN_ARRAY，＆ctlp-&gt; ncol_ctl，0，OCI_ATTR_NUM_COLS，ctlp-&gt; errhp_ctl））;</pre></div>
                        <!-- class="example" -->
                        <div class="example" id="GUID-044CA338-D429-4657-8D90-FC8C521D777E__CACEEJGJ">
                           <p class="titleinexample">例21-11设置输入数据字段</p><pre class="oac_no_warn" dir="ltr">ub4 rowoff; / *列数组行偏移* / ub4 clen; / *列长* / ub1 cflg; / *列状态标志* / ub1 * cval; / *列字符值* / OCI_CHECK（ctlp-&gt; errhp_ctl，OCI_HTYPE_ERROR，ociret，ctlp，OCIDirPathColArrayEntrySet（ctlp-&gt; dpca_ctl，ctlp-&gt; errhp_ctl，rowoff，colp-&gt; id_col，cval，clen，cflg））;</pre></div>
                        <!-- class="example" -->
                        <div class="example" id="GUID-044CA338-D429-4657-8D90-FC8C521D777E__CACGHJED">
                           <p class="titleinexample">示例21-12重置列数组状态</p><pre class="oac_no_warn" dir="ltr">（void）OCIDirPathColArrayReset（ctlp-&gt; dpca_ctl，ctlp-&gt; errhp_ctl）;</pre></div>
                        <!-- class="example" -->
                        <div class="example" id="GUID-044CA338-D429-4657-8D90-FC8C521D777E__CACJCJHC">
                           <p class="titleinexample">例21-13重置流状态</p><pre class="oac_no_warn" dir="ltr">（void）OCIDirPathStreamReset（ctlp-&gt; dpstr_ctl，ctlp-&gt; errhp_ctl）;</pre></div>
                        <!-- class="example" -->
                        <div class="example" id="GUID-044CA338-D429-4657-8D90-FC8C521D777E__CACIIBGH">
                           <p class="titleinexample">示例21-14将数据转换为流格式</p><pre class="oac_no_warn" dir="ltr">ub4 rowcnt; / *列数组中的行数* / ub4 startoff; / *起始行偏移到列数组* / / *将数组转换为流，过滤掉不良记录* / ocierr = OCIDirPathColArrayToStream（ctlp-&gt; dpca_ctl，ctlp-&gt; dpctx_ctl，ctlp-&gt; dpstr_ctl，ctlp-&gt; errhp_ctl，rowcnt，startoff ）;</pre></div>
                        <!-- class="example" -->
                        <div class="example" id="GUID-044CA338-D429-4657-8D90-FC8C521D777E__CACGJIHI">
                           <p class="titleinexample">例21-15加载流</p><pre class="oac_no_warn" dir="ltr">/ *加载流* / ociret = OCIDirPathLoadStream（ctlp-&gt; dpctx_ctl，ctlp-&gt; dpstr_ctl，ctlp-&gt; errhp_ctl）;</pre></div>
                        <!-- class="example" -->
                        <div class="example" id="GUID-044CA338-D429-4657-8D90-FC8C521D777E__CACHAHGB">
                           <p class="titleinexample">例21-16完成直接路径加载操作</p><pre class="oac_no_warn" dir="ltr">/ *完成直接路径加载操作* / OCI_CHECK（ctlp-&gt; errhp_ctl，OCI_HTYPE_ERROR，ociret，ctlp，OCIDirPathFinish（ctlp-&gt; dpctx_ctl，ctlp-&gt; errhp_ctl））;</pre></div>
                        <!-- class="example" -->
                        <div class="example" id="GUID-044CA338-D429-4657-8D90-FC8C521D777E__CACDGHIB">
                           <p class="titleinexample">示例21-17释放直接路径句柄</p><pre class="oac_no_warn" dir="ltr">/ *释放加载的服务器数据结构* / ociret = OCIHandleFree（（void *）ctlp-&gt; dpca_ctl，OCI_HTYPE_DIRPATH_COLUMN_ARRAY）; ociret = OCIHandleFree（（void *）ctlp-&gt; dpstr_ctl，OCI_HTYPE_DIRPATH_STREAM）; ociret = OCIHandleFree（（void *）ctlp-&gt; dpctx_ctl，OCI_HTYPE_DIRPATH_CTX）;</pre></div>
                        <!-- class="example" -->
                        <div class="section">
                           <div class="infoboxnotealso" id="GUID-044CA338-D429-4657-8D90-FC8C521D777E__GUID-A7F10581-29B7-4619-B165-EB7CA1306934">
                              <p class="notep1">也可以看看：</p>
                              <p><a href="direct-path-loading-functions.html#GUID-309D9948-26C2-40F7-813D-ECDA2BF3D99C" title="加载转换为直接路径流格式的数据。">OCIDirPathLoadStream（）</a></p>
                           </div>
                        </div>
                        <!-- class="section" -->
                     </div>
                  </div>
               </div><a id="LNOCI16931"></a><div class="props_rev_3"><a id="GUID-E41A3E45-BE34-48B2-B8D0-49A04F86725D" name="GUID-E41A3E45-BE34-48B2-B8D0-49A04F86725D"></a><h4 id="LNOCI-GUID-E41A3E45-BE34-48B2-B8D0-49A04F86725D" class="sect4"><span class="enumeration_section">21.1.6</span>关于在OCI中直接路径加载日期时使用日期缓存</h4>
                  <div>
                     <p>在加载需要将数据类型转换存储在表中的Oracle日期和时间戳值时， <span class="italic">日期缓存</span>功能可提供更高的性能。
                     </p>
                     <p>有关在直接路径加载中使用此功能的更多信息，请参阅<a href="../sutil/oracle-sql-loader-conventional-and-direct-loads.html#SUTIL1327" target="_blank"><span><cite>Oracle数据库实用程序</cite></span></a> 。
                     </p>
                     <p>此功能专门用于直接路径加载，其中一次又一次地加载相同的输入日期或时间戳值。日期转换非常昂贵，并且占总加载时间的很大一部分，尤其是在加载多个日期列时。日期缓存功能可以通过减少在输入数据中出现许多重复日期值时完成的实际日期转换次数来显着提高性能。但是，日期缓存仅在将许多重复输入日期值加载到日期列时才会提高性能（本章中的单词<span class="italic">日期</span>适用于所有日期和时间戳数据类型）。
                     </p>
                     <p>默认情况下启用日期缓存。显式指定日期缓存大小时，默认情况下不会禁用日期缓存功能。要覆盖此行为，请将<code class="codeph">OCI_ATTR_DIRPATH_DCACHE_DISABLE</code>设置为1。否则，将继续搜索缓存以避免日期转换。但是，任何未命中（没有重复值的条目）都会使用昂贵的日期转换功能以常规方式进行转换，而无需使用日期缓存功能。
                     </p>
                     <p>查询属性<code class="codeph">OCI_ATTR_DIRPATH_DCACHE_NUM</code> ， <code class="codeph">OCI_ATTR_DIRPATH_DCACHE_MISSES</code>和<code class="codeph">OCI_ATTR_DIRPATH_DCACHE_HITS</code> ，然后调整缓存大小以供将来加载。
                     </p>
                     <p>您可以在没有未命中时降低高速缓存大小，并且高速缓存中的元素数小于高速缓存大小。如果存在许多高速缓存未命中和相对较少的命中（具有重复值的条目），则可以增加高速缓存大小。但是，过多的日期缓存未命中可能会导致应用程序运行速度慢于根本不使用日期缓存。请注意，过多地增加缓存大小会导致其他问题，例如分页或耗尽内存。如果增加高速缓存大小不会提高性能，则不应使用该功能。</p>
                     <p>通过将日期缓存大小设置为0，可以显式和完全禁用日期缓存功能。</p>
                     <div class="p">以下OCI直接路径上下文属性支持此功能：<ul style="list-style-type:disc">
                           <li>
                              <p><a href="direct-path-load-interface.html#GUID-F4343F83-F22E-4B69-B900-B1445CD0432D">OCI_ATTR_DIRPATH_DCACHE_SIZE</a></p>
                           </li>
                           <li>
                              <p><a href="direct-path-load-interface.html#GUID-44914454-D7F9-46EE-A837-8F42475C5AFA">OCI_ATTR_DIRPATH_DCACHE_NUM</a></p>
                           </li>
                           <li>
                              <p><a href="direct-path-load-interface.html#GUID-23944163-22A2-429B-B221-A5CB4C4AEF56">OCI_ATTR_DIRPATH_DCACHE_MISSES</a></p>
                           </li>
                           <li>
                              <p><a href="direct-path-load-interface.html#GUID-ADC5F56B-A558-489C-B6E0-8BBCEFFA16CE">OCI_ATTR_DIRPATH_DCACHE_HITS</a></p>
                           </li>
                           <li>
                              <p><a href="direct-path-load-interface.html#GUID-195C7996-803F-41A8-8EB2-D2012EEF2EBB" title="用于在超出大小时禁用数据高速缓存。">OCI_ATTR_DIRPATH_DCACHE_DISABLE</a></p>
                           </li>
                        </ul>
                     </div>
                  </div><a id="LNOCI16932"></a><div class="props_rev_3"><a id="GUID-F4343F83-F22E-4B69-B900-B1445CD0432D" name="GUID-F4343F83-F22E-4B69-B900-B1445CD0432D"></a><h5 id="LNOCI-GUID-F4343F83-F22E-4B69-B900-B1445CD0432D" class="sect5"><span class="enumeration_section">21.1.6.1</span> OCI_ATTR_DIRPATH_DCACHE_SIZE</h5>
                     <div>
                        <p>此属性（不等于0）设置表的日期高速缓存大小（以元素为单位）。例如，如果日期缓存大小设置为200，则最多可以在缓存中存储200个唯一日期或时间戳值。调用<a href="direct-path-loading-functions.html#GUID-8EE17BD0-02A9-4065-B501-CAF087BA4317">OCIDirPathPrepare（）后，</a>无法更改日期缓存大小。默认值为0，表示不为表创建日期缓存。仅当加载了一个或多个需要数据类型转换且属性值非零的日期或时间戳值时，才会为表创建日期缓存。
                        </p>
                     </div>
                  </div><a id="LNOCI16933"></a><div class="props_rev_3"><a id="GUID-44914454-D7F9-46EE-A837-8F42475C5AFA" name="GUID-44914454-D7F9-46EE-A837-8F42475C5AFA"></a><h5 id="LNOCI-GUID-44914454-D7F9-46EE-A837-8F42475C5AFA" class="sect5"><span class="enumeration_section">21.1.6.2</span> OCI_ATTR_DIRPATH_DCACHE_NUM</h5>
                     <div>
                        <p>此属性用于查询日期缓存中的当前条目数。</p>
                     </div>
                  </div><a id="LNOCI16934"></a><div class="props_rev_3"><a id="GUID-23944163-22A2-429B-B221-A5CB4C4AEF56" name="GUID-23944163-22A2-429B-B221-A5CB4C4AEF56"></a><h5 id="LNOCI-GUID-23944163-22A2-429B-B221-A5CB4C4AEF56" class="sect5"><span class="enumeration_section">21.1.6.3</span> OCI_ATTR_DIRPATH_DCACHE_MISSES</h5>
                     <div>
                        <p>此属性用于查询当前的日期缓存未命中数。如果未命中数很高，请考虑使用更大的日期缓存大小。如果增加日期高速缓存大小不会导致此数字显着减少，则可能不应使用日期高速缓存。由于散列和查找时间，日期缓存未命中是昂贵的。</p>
                     </div>
                  </div><a id="LNOCI16935"></a><div class="props_rev_3"><a id="GUID-ADC5F56B-A558-489C-B6E0-8BBCEFFA16CE" name="GUID-ADC5F56B-A558-489C-B6E0-8BBCEFFA16CE"></a><h5 id="LNOCI-GUID-ADC5F56B-A558-489C-B6E0-8BBCEFFA16CE" class="sect5"><span class="enumeration_section">21.1.6.4</span> OCI_ATTR_DIRPATH_DCACHE_HITS</h5>
                     <div>
                        <p>此属性用于查询日期缓存命中数。此数字应该相对较大，以查看使用日期缓存支持的任何好处。</p>
                     </div>
                  </div><a id="LNOCI16936"></a><div class="props_rev_3"><a id="GUID-195C7996-803F-41A8-8EB2-D2012EEF2EBB" name="GUID-195C7996-803F-41A8-8EB2-D2012EEF2EBB"></a><h5 id="LNOCI-GUID-195C7996-803F-41A8-8EB2-D2012EEF2EBB" class="sect5"><span class="enumeration_section">21.1.6.5</span> OCI_ATTR_DIRPATH_DCACHE_DISABLE</h5>
                     <div>
                        <p>用于在超出大小时禁用数据高速缓存。</p>
                        <p>将此属性设置为1表示如果超出大小，则应禁用日期缓存。请注意，在<code class="codeph">OCIDirPathPrepare()</code>之后，无法更改或设置此属性。
                        </p>
                        <p>默认（= 0）是在溢出时不禁用缓存。未禁用时，将搜索缓存以避免转换，但溢出输入日期值条目不会添加到日期缓存中，而是使用昂贵的日期转换功能进行转换。同样，过多的日期缓存未命中可能导致应用程序运行速度慢于根本不使用日期缓存。</p>
                        <p>还可以查询此属性以查看是否由于溢出而禁用了日期缓存。</p>
                        <div class="infoboxnotealso" id="GUID-195C7996-803F-41A8-8EB2-D2012EEF2EBB__GUID-73463EF8-DAC8-4C53-B52A-F37D06DDFB12">
                           <p class="notep1">也可以看看：</p>
                           <ul style="list-style-type:disc">
                              <li>
                                 <p><a href="handle-and-descriptor-attributes.html#GUID-07F0F31C-94FF-4E3B-B8E1-C2394CB94390" title="列出并描述直接路径上下文句柄（OCIDirPathCtx）属性。">直接路径上下文句柄（OCIDirPathCtx）属性</a></p>
                              </li>
                              <li>
                                 <p><a href="direct-path-loading-functions.html#GUID-8EE17BD0-02A9-4065-B501-CAF087BA4317">OCIDirPathPrepare（）</a></p>
                              </li>
                           </ul>
                           <p></p>
                        </div>
                     </div>
                  </div>
               </div>
               <div class="sect3"><a id="GUID-F29B2906-60CB-480E-8EE0-6707BF4B5463" name="GUID-F29B2906-60CB-480E-8EE0-6707BF4B5463"></a><h4 id="LNOCI-GUID-F29B2906-60CB-480E-8EE0-6707BF4B5463" class="sect4"><span class="enumeration_section">21.1.7</span>关于验证Oracle NUMBER和DATE数据的格式</h4>
                  <div>
                     <p>描述加载流数据时验证Oracle NUMBER和DATE数据的格式。</p>
                     <p>使用直接路径上下文句柄属性<code class="codeph">OCI_ATTR_DIRPATH_FLAGS</code>并设置<code class="codeph">OCI_DIRPATH_FLAGS_VLDT</code> 0x01标志，以便在服务器上解析流时验证Oracle <code class="codeph">NUMBER</code>和<code class="codeph">DATE</code>数据的格式。默认值是不设置此标志，因为它是一项昂贵的操作。当您怀疑<code class="codeph">OCIDirPath</code>存在问题时，可以使用它来生成日期和数字的无效内部表示。
                     </p>
                     <p>有关更多信息，请参阅<a href="handle-and-descriptor-attributes.html#GUID-07F0F31C-94FF-4E3B-B8E1-C2394CB94390" title="列出并描述直接路径上下文句柄（OCIDirPathCtx）属性。">直接路径上下文句柄（OCIDirPathCtx）属性</a> 。
                     </p>
                  </div>
               </div>
            </div><a id="LNOCI16937"></a><div class="props_rev_3"><a id="GUID-DD759C3F-DE1C-4227-92F7-D744BC283590" name="GUID-DD759C3F-DE1C-4227-92F7-D744BC283590"></a><h3 id="LNOCI-GUID-DD759C3F-DE1C-4227-92F7-D744BC283590" class="sect3"><span class="enumeration_section">21.2</span>对象类型的直接路径加载</h3>
               <div>
                  <p>本节讨论使用直接路径函数上下文来加载各种非标量类型。</p>
                  <p>非标量类型是：</p>
                  <ul style="list-style-type:disc">
                     <li>
                        <p>嵌套表</p>
                     </li>
                     <li>
                        <p>对象表（ <code class="codeph">FINAL</code>和<code class="codeph">NOT FINAL</code> ）</p>
                     </li>
                     <li>
                        <p>列对象（ <code class="codeph">FINAL</code>和<code class="codeph">NOT FINAL</code> ）</p>
                     </li>
                     <li>
                        <p><code class="codeph">REF</code>列（ <code class="codeph">FINAL</code>和<code class="codeph">NOT FINAL</code> ）</p>
                     </li>
                     <li>
                        <p>SQL字符串列</p>
                     </li>
                  </ul>
                  <div class="p">本节包括以下主题：<ul style="list-style-type:disc">
                        <li>
                           <p><a href="direct-path-load-interface.html#GUID-6C29873B-9E4B-48FB-88AA-5C8DC049FA3B" title="嵌套表存储在单独的表中。">嵌套表的直接路径加载</a></p>
                        </li>
                        <li>
                           <p><a href="direct-path-load-interface.html#GUID-F155292D-2DBE-4EC3-A2F1-4D567DFC1E4E" title="列对象是定义为对象的表列。">列对象的直接路径加载</a></p>
                        </li>
                        <li>
                           <p><a href="direct-path-load-interface.html#GUID-74AF095C-98B2-4E8D-AC7D-4C94260851FF" title="可以通过SQL字符串计算列值。SQL字符串可用于标量列类型。">SQL字符串列的直接路径加载</a></p>
                        </li>
                        <li>
                           <p><a href="direct-path-load-interface.html#GUID-2CE26A43-4193-4C8D-9C12-77A943811958" title="REF类型是对象表中行对象的指针或引用。">REF列的直接路径加载</a></p>
                        </li>
                        <li>
                           <p><a href="direct-path-load-interface.html#GUID-4001897C-6736-4B0B-BCB7-F0C3EB608A70" title="回想一下，SQL对象继承是基于形成类型层次结构的对象类型的族树。">NOT FINAL对象和REF列的直接路径加载</a></p>
                        </li>
                        <li>
                           <p><a href="direct-path-load-interface.html#GUID-8C639AF1-1A8B-4BAA-A02E-FF4F8B37BD38" title="对象表是一个表，其中每一行是一个对象（或行对象）。表中的每一列都是一个对象属性。">对象表的直接路径加载</a></p>
                        </li>
                        <li>
                           <p><a href="direct-path-load-interface.html#GUID-04BF14FF-1FF4-4F3A-BBB8-EA2500471DDF" title="NOT FINAL对象表支持继承，而FINAL对象表则不支持。">直接路径加载NOT FINAL对象表</a></p>
                        </li>
                     </ul>
                  </div>
                  <div class="infoboxnotealso" id="GUID-DD759C3F-DE1C-4227-92F7-D744BC283590__GUID-6F8B7C9D-A68C-4C7A-8658-5B4AE1D4B7E0">
                     <p class="notep1">也可以看看：</p>
                     <p><a href="oci-demo-programs.html#GUID-75E18629-0C54-4495-A747-AFB346034F26__CACCAHCE" title="该表有2列。第1列是OCI演示程序名称，第2列描述了所示的相应功能。">表B-1</a>列出了Oracle数据库安装中可用的演示直接路径加载的程序</p>
                  </div>
               </div><a id="LNOCI16938"></a><div class="props_rev_3"><a id="GUID-6C29873B-9E4B-48FB-88AA-5C8DC049FA3B" name="GUID-6C29873B-9E4B-48FB-88AA-5C8DC049FA3B"></a><h4 id="LNOCI-GUID-6C29873B-9E4B-48FB-88AA-5C8DC049FA3B" class="sect4"><span class="enumeration_section">21.2.1</span>嵌套表的直接路径加载</h4>
                  <div>
                     <p>嵌套表存储在单独的表中。</p>
                     <p>使用直接路径加载API，嵌套表与其父表分开加载，使用外键（称为<code class="codeph">SETID</code>将两个表链接在一起。
                     </p>
                     <div class="infoboxnote" id="GUID-6C29873B-9E4B-48FB-88AA-5C8DC049FA3B__GUID-D687F83E-46A6-4BA1-A0A8-C52EB32E2936">
                        <p class="notep1">注意：</p>
                        <ul style="list-style-type:disc">
                           <li>
                              <p>目前， <code class="codeph">SETID</code>必须由用户提供，而不是系统生成的。
                              </p>
                           </li>
                           <li>
                              <p>分别加载父表和子表时，可以在将行插入子表时创建孤立子项，但不会将相应的父行插入父表。也可以将父行插入父表而不将子行插入子表，以便父行具有缺少的子项。</p>
                           </li>
                        </ul>
                     </div>
                  </div><a id="LNOCI16939"></a><div class="props_rev_3"><a id="GUID-8FFC6108-F2CD-4D03-8B9C-CA41A3CC6C11" name="GUID-8FFC6108-F2CD-4D03-8B9C-CA41A3CC6C11"></a><h5 id="LNOCI-GUID-8FFC6108-F2CD-4D03-8B9C-CA41A3CC6C11" class="sect5"><span class="enumeration_section">21.2.1.1</span>描述嵌套表列及其嵌套表</h5>
                     <div>
                        <p>列出并描述使用嵌套表列加载父表，这是加载子嵌套表的单独操作。</p>
                        <div class="section">
                           <div class="infoboxnote" id="GUID-8FFC6108-F2CD-4D03-8B9C-CA41A3CC6C11__GUID-63DE114E-6418-4D9B-97DF-19F211EA6935">
                              <p class="notep1">注意：</p>
                              <p>与加载标量数据不同的步骤以斜体显示。</p>
                           </div>
                           <p>使用嵌套表列加载父表是加载子嵌套表的单独操作。</p>
                        </div>
                        <!-- class="section" -->
                        <div class="section">
                           <ul style="list-style-type:disc">
                              <li>
                                 <p><span class="italic">要使用嵌套表列加载父表：</span></p>
                                 <ol>
                                    <li>
                                       <p>像往常一样描述父表及其列，除了：</p>
                                    </li>
                                    <li>
                                       <p><span class="italic">在描述嵌套表列时，这是存储</span> <span class="italic">SETID</span> <span class="italic">的列</span> <span class="italic">。其外部数据类型是SQLT_CHR如果</span> <span class="italic">在数据文件</span> 中<span class="italic">的</span></span> <span class="italic">SETID</span> <span class="italic">s为在字符，如果SQLT_BIN二进制。</span></p>
                                    </li>
                                 </ol>
                              </li>
                              <li>
                                 <p><span class="italic">要加载嵌套表（子）：</span></p>
                                 <ol>
                                    <li>
                                       <p>像往常一样描述嵌套表及其列。</p>
                                    </li>
                                    <li>
                                       <p><span class="italic">该</span> <span class="italic">SETID</span> <span class="italic">列是必需的。</span></p>
                                       <ul style="list-style-type:disc">
                                          <li>
                                             <p><span class="italic">使用虚拟名称（例如“setid”）设置其OCI_ATTR_NAME，因为API不希望您知道其系统名称。</span></p>
                                          </li>
                                          <li>
                                             <p><span class="italic">使用OCI_ATTR_DIRPATH_SID设置column属性以指示这是</span> <span class="italic">SETID</span> <span class="italic">列：</span></p><pre class="oac_no_warn" dir="ltr">ub1 flg = 1;剑错误; error = OCIAttrSet（（void *）colDesc，OCI_DTYPE_PARAM，（void *）＆flg，（ub4）0，OCI_ATTR_DIRPATH_SID，ctlp-&gt; errhp_ctl）;</pre></li>
                                       </ul>
                                    </li>
                                 </ol>
                              </li>
                           </ul>
                           <p>本节包括以下主题： <a href="direct-path-load-interface.html#GUID-8FFC6108-F2CD-4D03-8B9C-CA41A3CC6C11" title="列出并描述使用嵌套表列加载父表，这是加载子嵌套表的单独操作。">描述嵌套表列及其嵌套表</a> 。
                           </p>
                        </div>
                        <!-- class="section" -->
                     </div>
                  </div>
               </div><a id="LNOCI16940"></a><div class="props_rev_3"><a id="GUID-F155292D-2DBE-4EC3-A2F1-4D567DFC1E4E" name="GUID-F155292D-2DBE-4EC3-A2F1-4D567DFC1E4E"></a><h4 id="LNOCI-GUID-F155292D-2DBE-4EC3-A2F1-4D567DFC1E4E" class="sect4"><span class="enumeration_section">21.2.2</span>列对象的直接路径加载</h4>
                  <div>
                     <p>列对象是定义为对象的表列。</p>
                     <p>目前，仅支持由所有组成属性组成的默认构造函数。</p>
                     <div class="p">本节包括以下主题：<ul style="list-style-type:disc">
                           <li>
                              <p><a href="direct-path-load-interface.html#GUID-01B4EA72-B9F5-4152-9251-01FADADEBB9D" title="要描述列对象及其对象属性，请使用直接路径函数上下文。">描述列对象</a></p>
                           </li>
                           <li>
                              <p><a href="direct-path-load-interface.html#GUID-9F981453-A689-40D5-AB33-C0ED743F56FC" title="直接路径加载列对象时，其对象属性的数据将加载到仅为该对象创建的单独列数组中。">为列对象分配数组列</a></p>
                           </li>
                           <li>
                              <p><a href="direct-path-load-interface.html#GUID-1B2F7386-6BEE-4FCD-99C9-E38AD3E00323" title="如果列是标量，则通过将其值的地址传递给OCIDirPathColArrayEntrySet（），在列数组中设置其值。">将列对象数据加载到列数组中</a></p>
                           </li>
                           <li>
                              <p><a href="direct-path-load-interface.html#GUID-C67EFBE6-677E-4E3C-8024-8412857C3BE0" title="OCI_DIRPATH_COL_ERROR值传递给OCIDirPathColArrayEntry（）以指示应忽略当前列数组行。">OCI_DIRPATH_COL_ERROR</a></p>
                           </li>
                        </ul>
                     </div>
                  </div><a id="LNOCI16941"></a><div class="props_rev_3"><a id="GUID-01B4EA72-B9F5-4152-9251-01FADADEBB9D" name="GUID-01B4EA72-B9F5-4152-9251-01FADADEBB9D"></a><h5 id="LNOCI-GUID-01B4EA72-B9F5-4152-9251-01FADADEBB9D" class="sect5"><span class="enumeration_section">21.2.2.1</span>描述列对象</h5>
                     <div>
                        <p>要描述列对象及其对象属性，请使用直接路径函数上下文。</p>
                        <div class="section">
                           <p>描述列对象需要设置其对象构造函数。描述对象属性类似于描述标量列的列表。</p>
                           <p>要描述列对象：</p>
                           <div class="infoboxnote" id="GUID-01B4EA72-B9F5-4152-9251-01FADADEBB9D__GUID-9074A4C4-66C1-48AA-8C15-85564BDA3245">
                              <p class="notep1">注意：</p>
                              <ul style="list-style-type:disc">
                                 <li>
                                    <p>支持嵌套列对象。</p>
                                 </li>
                                 <li>
                                    <p>此处显示的步骤与描述要为表加载的标量列列表的步骤类似。与加载标量数据不同的步骤以斜体显示。</p>
                                 </li>
                              </ul>
                           </div>
                           <ol>
                              <li>
                                 <p>使用<code class="codeph">OCI_DTYPE_PARAM</code>在列对象上分配参数句柄。此参数句柄用于设置列的外部属性。
                                 </p>
                              </li>
                              <li>
                                 <p>设置列名称及其他外部列属性（例如，最大数据大小，精度，比例）。</p>
                              </li>
                              <li>
                                 <p><span class="italic">使用OCI_ATTR_DATA_TYPE将外部类型设置为SQLT_NTY（命名类型）。</span></p>
                              </li>
                              <li>
                                 <p><span class="italic">分配直接路径函数上下文句柄。此上下文用于描述列的对象类型和属性：</span></p><pre class="oac_no_warn" dir="ltr">OCIDirPathFuncCtx * dpfnctx / *直接路径函数上下文* /;剑错误; error = OCIHandleAlloc（（void *）dpctx，（void **）＆dpfnctx，OCI_HTYPE_DIRPATH_FN_CTX，（size_t）0，（void **）0）;</pre></li>
                              <li>
                                 <p><span class="italic">在函数上下文中使用OCI_ATTR_NAME设置列的对象类型名称（例如，“Employee”）：</span></p><pre class="oac_no_warn" dir="ltr">OCIDirPathFuncCtx * dpfnctx; / * direct path function context * / text * obj_type; / *列对象的对象类型* /剑错误; error = OCIAttrSet（（void *）dpfnctx，OCI_HTYPE_DIRPATH_FN_CTX，（void *）obj_type，（ub4）strlen（（const char *）obj_type），OCI_ATTR_NAME，ctlp-&gt; errhp_ctl）;</pre></li>
                              <li>
                                 <p><span class="italic">将表达式类型OCI_ATTR_DIRPATH_EXPR_TYPE设置为OCI_DIRPATH_EXPR_OBJ_CONSTR。这表示使用OCI_ATTR_NAME设置的表达式用作默认对象构造函数：</span></p><pre class="oac_no_warn" dir="ltr">OCIDirPathFuncCtx * dpfnctx; / * direct path function context * / ub1 expr_type = OCI_DIRPATH_EXPR_OBJ_CONSTR;剑错误; error = OCIAttrSet（（void *）dpfnctx，OCI_HTYPE_DIRPATH_FN_CTX，（void *）＆expr_type，（ub4）0，OCI_ATTR_DIRPATH_EXPR_TYPE，ctlp-&gt; errhp_ctl）;</pre></li>
                              <li>
                                 <p><span class="italic">使用OCI_ATTR_NUM_COLS设置要为此列对象加载的列数或对象属性。</span></p>
                              </li>
                              <li>
                                 <p><span class="italic">获取函数上下文</span> <span class="italic"><code class="codeph">OCIDirPathFuncCtx</code></span> <span class="italic">的列或属性参数列表</span> <span class="italic">。</span></p>
                              </li>
                              <li>
                                 <p><span class="italic">对于每个对象属性：</span></p>
                                 <ol type="a">
                                    <li>
                                       <p>使用<code class="codeph">OCI_DTYPE_PARAM</code>获取对象属性的列描述符。</p>
                                    </li>
                                    <li>
                                       <p>使用<code class="codeph">OCI_ATTR_NAME</code>设置属性的列名称。</p>
                                    </li>
                                    <li>
                                       <p>使用<code class="codeph">OCI_ATTR_DATA_TYPE</code>设置外部列类型（要传递给直接路径API的数据类型）。</p>
                                    </li>
                                    <li>
                                       <p>设置任何其他外部列属性（最大数据大小，精度，比例等）。</p>
                                    </li>
                                    <li>
                                       <p><span class="italic">如果此属性列是列对象，则对其对象属性执行步骤3到10。</span></p>
                                    </li>
                                    <li>
                                       <p>释放列描述符的句柄。</p>
                                    </li>
                                 </ol>
                              </li>
                              <li>
                                 <p><span class="italic">使用</span> <span class="italic"><code class="codeph">OCIDirPathFuncCtx</code></span> <span class="italic">将在步骤4中创建</span> <span class="italic">的函数上下文</span> <span class="italic"><code class="codeph">OCIDirPathFuncCtx</code></span> <span class="italic">设置</span> <span class="italic">为父列对象的参数句柄。</span></p>
                              </li>
                           </ol>
                        </div>
                        <!-- class="section" -->
                     </div>
                  </div><a id="LNOCI72751"></a><a id="LNOCI16942"></a><div class="props_rev_3"><a id="GUID-9F981453-A689-40D5-AB33-C0ED743F56FC" name="GUID-9F981453-A689-40D5-AB33-C0ED743F56FC"></a><h5 id="LNOCI-GUID-9F981453-A689-40D5-AB33-C0ED743F56FC" class="sect5"><span class="enumeration_section">21.2.2.2</span>为列对象分配数组列</h5>
                     <div>
                        <p>直接路径加载列对象时，其对象属性的数据将加载到仅为该对象创建的单独列数组中。</p>
                        <div class="section">
                           <p>为每个列对象分配子列数组，无论它是否嵌套。子列数组中的每行对象属性都映射到父列数组中其父列对象的相应非NULL行。</p>
                           <p>使用列对象的直接路径函数上下文句柄和函数列数组值<code class="codeph">OCI_HTYPE_DIRPATH_FN_COL_ARRAY</code> 。</p>
                           <p><a href="direct-path-load-interface.html#GUID-9F981453-A689-40D5-AB33-C0ED743F56FC__CACJDIFA">例21-18</a>显示了如何为列对象分配子列数组。
                           </p>
                        </div>
                        <!-- class="section" -->
                        <div class="example" id="GUID-9F981453-A689-40D5-AB33-C0ED743F56FC__CACJDIFA">
                           <p class="titleinexample">示例21-18为列对象分配子列数组</p><pre class="oac_no_warn" dir="ltr">OCIDirPathFuncCtx * dpfnctx; / *直接路径函数上下文* / OCIDirPathColArray * dpfnca; / *直接路径函数列数组* /剑错误; error = OCIHandleAlloc（（void *）dpfnctx，（void **）＆dpfnca，OCI_HTYPE_DIRPATH_FN_COL_ARRAY，（size_t）0，（void **）0）;</pre></div>
                        <!-- class="example" -->
                     </div>
                  </div><a id="LNOCI16943"></a><div class="props_rev_3"><a id="GUID-1B2F7386-6BEE-4FCD-99C9-E38AD3E00323" name="GUID-1B2F7386-6BEE-4FCD-99C9-E38AD3E00323"></a><h5 id="LNOCI-GUID-1B2F7386-6BEE-4FCD-99C9-E38AD3E00323" class="sect5"><span class="enumeration_section">21.2.2.3将</span>列对象数据加载到列数组中</h5>
                     <div>
                        <p>如果列是标量，则通过将其值的地址传递给<code class="codeph">OCIDirPathColArrayEntrySet()</code> ，在列数组中设置其值。
                        </p>
                        <div class="section">
                           <p>如果列是对象，则传递其子列数组句柄的地址。子列数组包含对象属性的数据。</p>
                           <p>要将数据加载到列对象中：</p>
                           <div class="infoboxnote" id="GUID-1B2F7386-6BEE-4FCD-99C9-E38AD3E00323__GUID-6628C045-5BE1-4012-A066-262115E74566">
                              <p class="notep1">注意：</p>
                              <p>与加载标量数据不同的步骤以斜体显示。</p>
                           </div>
                           <p><span class="italic">（开始。）对于每个列对象：</span></p>
                           <ol>
                              <li>
                                 <p><span class="italic">如果列是非NULL：</span></p>
                                 <ol type="a">
                                    <li>
                                       <p><span class="italic">对于其每个对象属性列：</span></p>
                                       <p><span class="italic">如果object属性是嵌套的列对象，则转到（Start。）并递归执行整个过程。</span></p>
                                       <p><span class="italic">使用</span> <span class="italic">OCIDirPathColArrayEntrySet（）</span> <span class="italic">在子列数组中设置数据</span> <span class="italic">。</span></p>
                                    </li>
                                    <li>
                                       <p><span class="italic">通过将其子列数组句柄的地址传递给</span> <span class="italic"><code class="codeph">OCIDirPathColArrayEntrySet()</code></span> <span class="italic">，在列数组中设置列对象的数据</span> 。
                                       </p>
                                    </li>
                                 </ol>
                              </li>
                              <li>
                                 <p>否则，如果列为NULL：</p>
                                 <p>通过将数据的NULL地址（长度为0）和<code class="codeph">OCI_DIRPATH_COL_NULL</code>标志传递给<code class="codeph">OCIDirPathColArrayEntrySet()</code>来设置列对象在列数组中的数据。
                                 </p>
                              </li>
                           </ol>
                           <div class="infoboxnotealso" id="GUID-1B2F7386-6BEE-4FCD-99C9-E38AD3E00323__GUID-7DE5D35A-A055-45C0-B581-F630801246BA">
                              <p class="notep1">也可以看看：</p>
                              <p><a href="direct-path-loading-functions.html#GUID-4E4E74F4-3F15-4176-8229-C5783DC3811D" title="将列数组中的指定条目设置为提供的值。">OCIDirPathColArrayEntrySet（）</a></p>
                           </div>
                        </div>
                        <!-- class="section" -->
                     </div>
                  </div><a id="LNOCI16944"></a><div class="props_rev_3"><a id="GUID-C67EFBE6-677E-4E3C-8024-8412857C3BE0" name="GUID-C67EFBE6-677E-4E3C-8024-8412857C3BE0"></a><h5 id="LNOCI-GUID-C67EFBE6-677E-4E3C-8024-8412857C3BE0" class="sect5"><span class="enumeration_section">21.2.2.4</span> OCI_DIRPATH_COL_ERROR</h5>
                     <div>
                        <p><code class="codeph">OCI_DIRPATH_COL_ERROR</code>值传递给<code class="codeph">OCIDirPathColArrayEntry()</code>以指示应忽略当前列数组行。
                        </p>
                        <p>一个典型的使用这个值的是背出所有先前转换为一个行发生错误时，提供了用于部分列更多的数据（ <code class="codeph">OCI_NEED_DATA</code>从以前返回<code class="codeph">OCIDirPathColArrayToStream()</code>调用）。将删除放置在当前行的输出流缓冲区中的任何先前转换的数据。然后转换继续列数组中的下一行。清除的行在转换的行计数中计算。
                        </p>
                        <p>指定<code class="codeph">OCI_DIRPATH_COL_ERROR</code> ，将忽略当前行，以及从顶级列数组行开始引用的任何子列数组中的任何相应行。将所有引用的子列数组移动到下一行时，将忽略任何<code class="codeph">NULL</code>子列数组引用。
                        </p>
                        <div class="infoboxnotealso" id="GUID-C67EFBE6-677E-4E3C-8024-8412857C3BE0__GUID-0FFA4C13-883B-431E-84DB-EFDCBE2D003E">
                           <p class="notep1">也可以看看：</p>
                           <p><a href="direct-path-loading-functions.html#GUID-3A9445D3-EBE2-40DB-B303-F204CE065356" title="从列数组格式转换为直接路径流格式。">OCIDirPathColArrayToStream（）</a></p>
                        </div>
                     </div>
                  </div>
               </div><a id="LNOCI16945"></a><div class="props_rev_3"><a id="GUID-74AF095C-98B2-4E8D-AC7D-4C94260851FF" name="GUID-74AF095C-98B2-4E8D-AC7D-4C94260851FF"></a><h4 id="LNOCI-GUID-74AF095C-98B2-4E8D-AC7D-4C94260851FF" class="sect4"><span class="enumeration_section">21.2.3</span> SQL字符串列的直接路径加载</h4>
                  <div>
                     <p>可以通过SQL字符串计算列值。SQL字符串可用于标量列类型。</p>
                     <p>SQL字符串不能用于对象类型，但可以用于标量列类型的对象属性。它们不能用于嵌套表，序列和<code class="codeph">LONG</code> 。
                     </p>
                     <p>使用<code class="codeph">OCIDirPathFuncCtx</code>将SQL表达式表示为直接路径API。其<code class="codeph">OCI_ATTR_NAME</code>值是SQL字符串，其中包含表达式的命名绑定变量的参数列表。
                     </p>
                     <p>绑定变量名称空间仅限于列的SQL字符串。相同的绑定变量名称可用于多个列，但具有相同名称的任何参数仅适用于该列的SQL字符串。</p>
                     <p>如果列的SQL字符串包含对绑定变量的多个引用，并且为该名称指定了多个参数，则所有值必须相同;否则，结果是不确定的。这种情况实际上只需要一个参数，因为对特定SQL表达式中相同绑定变量名的所有引用都绑定到该单个参数。</p>
                     <p>SQL字符串示例是：</p><pre class="oac_no_warn" dir="ltr">substr（substr（：string，：offset，：length），：offset，：length）</pre><p>关于这个例子的注意事项是：</p>
                     <ul style="list-style-type:disc">
                        <li>
                           <p>SQL表达式可以嵌套。</p>
                        </li>
                        <li>
                           <p>可以在表达式中重复绑定变量名称。</p>
                        </li>
                     </ul>
                     <div class="p">本节包括以下主题：<ul style="list-style-type:disc">
                           <li>
                              <p><a href="direct-path-load-interface.html#GUID-AEA27B9F-BB45-4DF0-8123-6F7B14869F45" title="列出用于描述SQL字符串列的步骤。">描述SQL字符串列</a></p>
                           </li>
                           <li>
                              <p><a href="direct-path-load-interface.html#GUID-AEDE6422-320A-423D-8A99-4F8CDC74AA8A" title="当您直接路径加载SQL字符串列时，其参数的数据将加载到仅为该SQL字符串列创建的单独列数组中。">为SQL字符串列分配列数组</a></p>
                           </li>
                           <li>
                              <p><a href="direct-path-load-interface.html#GUID-033C2E65-7F4C-4128-8DAC-8219FC6C937E" title="如果列是标量，则通过将其值的地址传递给OCIDirPathColArrayEntrySet（），将在列数组中设置其值。">将SQL字符串数据加载到列数组中</a></p>
                           </li>
                        </ul>
                     </div>
                  </div><a id="LNOCI16946"></a><div class="props_rev_3"><a id="GUID-AEA27B9F-BB45-4DF0-8123-6F7B14869F45" name="GUID-AEA27B9F-BB45-4DF0-8123-6F7B14869F45"></a><h5 id="LNOCI-GUID-AEA27B9F-BB45-4DF0-8123-6F7B14869F45" class="sect5"><span class="enumeration_section">21.2.3.1</span>描述SQL字符串列</h5>
                     <div>
                        <p>列出用于描述SQL字符串列的步骤。</p>
                        <div class="section">
                           <div class="infoboxnote" id="GUID-AEA27B9F-BB45-4DF0-8123-6F7B14869F45__GUID-F72679A4-A6B2-4C88-9509-094FEF9C954A">
                              <p class="notep1">注意：</p>
                              <p>与加载标量数据不同的步骤以斜体显示。</p>
                           </div>
                           <ol>
                              <li>
                                 <p>使用<code class="codeph">OCI_DTYPE_PARAM</code>在SQL字符串列上分配参数句柄。此参数句柄用于设置列的外部属性。
                                 </p>
                              </li>
                              <li>
                                 <p>设置列名称及其他外部列属性（例如，最大数据大小，精度，比例）。</p>
                              </li>
                              <li>
                                 <p><span class="italic">使用OCI_ATTR_DATA_TYPE将SQL字符串列的外部类型设置为SQLT_NTY。</span></p>
                              </li>
                              <li>
                                 <p><span class="italic">分配直接路径函数上下文句柄。此上下文用于描述SQL字符串的参数。</span></p><pre class="oac_no_warn" dir="ltr">OCIDirPathFuncCtx * dpfnctx / *直接路径函数上下文* /;剑错误; error = OCIHandleAlloc（（void *）dpctx，（void **）＆dpfnctx，OCI_HTYPE_DIRPATH_FN_CTX，（size_t）0，（void **）0）;</pre></li>
                              <li>
                                 <p><span class="italic">在函数上下文中的OCI_ATTR_NAME中设置列的SQL字符串。</span></p><pre class="oac_no_warn" dir="ltr">OCIDirPathFuncCtx * dpfnctx; / * direct path function context * / text * sql_str; / *列的SQL字符串表达式* /剑错误; error = OCIAttrSet（（void *）dpfnctx，OCI_HTYPE_DIRPATH_FN_CTX，（void *）sql_str，（ub4）strlen（（const char *）sql_str），OCI_ATTR_NAME，ctlp-&gt; errhp_ctl）;</pre></li>
                              <li>
                                 <p><span class="italic">将表达式类型OCI_ATTR_DIRPATH_EXPR_TYPE设置为OCI_DIRPATH_EXPR_SQL。这表示使用OCI_ATTR_NAME设置的表达式用作从中派生值的SQL字符串。</span></p><pre class="oac_no_warn" dir="ltr">OCIDirPathFuncCtx * dpfnctx; / * direct path function context * / ub1 expr_type = OCI_DIRPATH_EXPR_SQL;剑错误; error = OCIAttrSet（（void *）dpfnctx，OCI_HTYPE_DIRPATH_FN_CTX，（void *）＆expr_type，（ub4）0，OCI_ATTR_DIRPATH_EXPR_TYPE，ctlp-&gt; errhp_ctl）;</pre></li>
                              <li>
                                 <p><span class="italic">使用OCI_ATTR_NUM_COLS设置要传递给SQL字符串的参数数。</span></p>
                              </li>
                              <li>
                                 <p><span class="italic">获取函数上下文的列或属性参数列表。</span></p>
                              </li>
                              <li>
                                 <p><span class="italic">对于每个SQL字符串参数：</span></p>
                                 <ol type="a">
                                    <li>
                                       <p>使用<code class="codeph">OCI_DTYPE_PARAM</code>获取对象属性的列描述符。</p>
                                    </li>
                                    <li>
                                       <p><span class="italic">定义SQL字符串参数的顺序无关紧要。该顺序不必与SQL字符串中使用的顺序匹配。</span></p>
                                    </li>
                                    <li>
                                       <p>使用<code class="codeph">OCI_ATTR_NAME</code>设置属性的列名称。</p>
                                    </li>
                                    <li>
                                       <p><span class="italic">使用SQL字符串参数的命名约定。</span></p>
                                    </li>
                                    <li>
                                       <p><span class="italic">参数名称必须与内容中SQL字符串中使用的绑定变量名称匹配，但不是大小写。例如，如果SQL字符串是“substr（：INPUT_STRING，3,5）”，那么如果将参数名称指定为“input_string”，则可以接受。</span></p>
                                    </li>
                                    <li>
                                       <p><span class="italic">如果在SQL字符串中多次使用参数，则只声明一次并将其计为一个参数是正确的。</span></p>
                                    </li>
                                    <li>
                                       <p>使用<code class="codeph">OCI_ATTR_DATA_TYPE</code>设置外部列类型（要传递给直接路径API的数据类型）。</p>
                                    </li>
                                    <li>
                                       <p>设置任何其他外部列属性（最大数据大小，精度，比例等）。</p>
                                    </li>
                                    <li>
                                       <p>释放列描述符的句柄。</p>
                                    </li>
                                 </ol>
                              </li>
                              <li>
                                 <p><span class="italic">使用</span> <span class="italic"><code class="codeph">OCIDirPathFuncCtx</code></span> <span class="italic">将在步骤4中创建</span> <span class="italic">的函数上下文</span> <span class="italic"><code class="codeph">OCIDirPathFuncCtx</code></span> <span class="italic">设置</span> <span class="italic">为父列对象的参数句柄。</span></p>
                              </li>
                           </ol>
                        </div>
                        <!-- class="section" -->
                     </div>
                  </div><a id="LNOCI72752"></a><a id="LNOCI16947"></a><div class="props_rev_3"><a id="GUID-AEDE6422-320A-423D-8A99-4F8CDC74AA8A" name="GUID-AEDE6422-320A-423D-8A99-4F8CDC74AA8A"></a><h5 id="LNOCI-GUID-AEDE6422-320A-423D-8A99-4F8CDC74AA8A" class="sect5"><span class="enumeration_section">21.2.3.2</span>为SQL字符串列分配列数组</h5>
                     <div>
                        <p>当您直接路径加载SQL字符串列时，其参数的数据将加载到仅为该SQL字符串列创建的单独列数组中。</p>
                        <div class="section">
                           <p>为每个SQL字符串列分配子列数组。子列数组中的每一行参数都映射到父列数组中其父SQL字符串列的相应非NULL行。</p>
                           <p><a href="direct-path-load-interface.html#GUID-AEDE6422-320A-423D-8A99-4F8CDC74AA8A__CACDIEEJ">例21-19</a>显示了如何为SQL字符串列分配子列数组。
                           </p>
                        </div>
                        <!-- class="section" -->
                        <div class="example" id="GUID-AEDE6422-320A-423D-8A99-4F8CDC74AA8A__CACDIEEJ">
                           <p class="titleinexample">示例21-19为SQL字符串列分配子列数组</p><pre class="oac_no_warn" dir="ltr">OCIDirPathFuncCtx * dpfnctx; / *直接路径函数上下文* / OCIDirPathColArray * dpfnca; / *直接路径函数列数组* /剑错误; error = OCIHandleAlloc（（void *）dpfnctx，（void **）＆dpfnca，OCI_HTYPE_DIRPATH_FN_COL_ARRAY，（size_t）0，（void **）0）;</pre></div>
                        <!-- class="example" -->
                     </div>
                  </div><a id="LNOCI16948"></a><div class="props_rev_3"><a id="GUID-033C2E65-7F4C-4128-8DAC-8219FC6C937E" name="GUID-033C2E65-7F4C-4128-8DAC-8219FC6C937E"></a><h5 id="LNOCI-GUID-033C2E65-7F4C-4128-8DAC-8219FC6C937E" class="sect5"><span class="enumeration_section">21.2.3.3</span>将SQL字符串数据加载到列数组中</h5>
                     <div>
                        <p>如果列是标量，则通过将其值的地址传递给<code class="codeph">OCIDirPathColArrayEntrySet()</code> ，将在列数组中设置其值。
                        </p>
                        <div class="section">
                           <p>如果列是SQL字符串类型，则将传递其子列数组句柄的地址。子列数组将包含SQL字符串的参数数据。</p>
                           <p>要将数据加载到SQL字符串列：</p>
                           <div class="infoboxnote" id="GUID-033C2E65-7F4C-4128-8DAC-8219FC6C937E__GUID-548C1F60-F6C9-41F0-9E7B-B379B514FB4D">
                              <p class="notep1">注意：</p>
                              <p>与加载标量数据不同的步骤以斜体显示。</p>
                           </div>
                           <p><span class="italic">对于每个SQL字符串列：</span></p>
                           <ol>
                              <li>
                                 <p><span class="italic">如果列是非NULL：</span></p>
                                 <ol type="a">
                                    <li>
                                       <p><span class="italic">对于其每个函数参数列：</span></p>
                                       <p><span class="italic">使用</span> <span class="italic">OCIDirPathColArrayEntrySet（）</span> <span class="italic">在子列数组中设置数据</span> <span class="italic">。</span></p>
                                    </li>
                                    <li>
                                       <p><span class="italic">通过将其子列数组句柄的地址传递给</span> <span class="italic">OCIDirPathColArrayEntrySet（），</span> <span class="italic">将SQL字符串列的数据设置为列数组</span> <span class="italic">。</span></p>
                                    </li>
                                 </ol>
                              </li>
                              <li>
                                 <p>否则，如果列为NULL：</p>
                                 <p>通过将数据的NULL地址（长度为0）和<code class="codeph">OCI_DIRPATH_COL_NULL</code>标志传递给<code class="codeph">OCIDirPathColArrayEntrySet()</code> ，将SQL字符串列数据设置为列数组。
                                 </p>
                              </li>
                           </ol>
                           <p>此过程类似于列对象的过程。</p>
                           <div class="infoboxnotealso" id="GUID-033C2E65-7F4C-4128-8DAC-8219FC6C937E__GUID-05CCBFDE-9ACB-4CDA-9725-4564B52D0EA8">
                              <p class="notep1">也可以看看：</p>
                              <ul style="list-style-type:disc">
                                 <li>
                                    <p><a href="direct-path-load-interface.html#GUID-C67EFBE6-677E-4E3C-8024-8412857C3BE0" title="OCI_DIRPATH_COL_ERROR值传递给OCIDirPathColArrayEntry（）以指示应忽略当前列数组行。">OCI_DIRPATH_COL_ERROR</a>有关将<code class="codeph">OCI_DIRPATH_COL_ERROR</code>值传递给<code class="codeph">OCIDirPathColArrayEntry()</code>更多信息，以指示发生错误时应忽略当前列数组行</p>
                                 </li>
                                 <li>
                                    <p><a href="direct-path-loading-functions.html#GUID-4E4E74F4-3F15-4176-8229-C5783DC3811D" title="将列数组中的指定条目设置为提供的值。">OCIDirPathColArrayEntrySet（）</a></p>
                                 </li>
                              </ul>
                              <p></p>
                           </div>
                        </div>
                        <!-- class="section" -->
                     </div>
                  </div>
               </div><a id="LNOCI16949"></a><div class="props_rev_3"><a id="GUID-2CE26A43-4193-4C8D-9C12-77A943811958" name="GUID-2CE26A43-4193-4C8D-9C12-77A943811958"></a><h4 id="LNOCI-GUID-2CE26A43-4193-4C8D-9C12-77A943811958" class="sect4"><span class="enumeration_section">21.2.4</span> REF列的直接路径加载</h4>
                  <div>
                     <p><code class="codeph">REF</code>类型是对象表中行对象的指针或引用。
                     </p>
                     <p></p>
                     <div class="p">本节包括以下主题：<ul style="list-style-type:disc">
                           <li>
                              <p><a href="direct-path-load-interface.html#GUID-02A4DC87-333F-4460-8B3A-70DB1E1E0FD9" title="描述REF列的参数类似于描述要为表加载的列的列表。">描述REF列</a></p>
                           </li>
                           <li>
                              <p><a href="direct-path-load-interface.html#GUID-09E1B9FB-28B9-4EC8-A02E-3723A2BE835C" title="显示如何为REF列分配子列数组。">为REF列分配列数组</a></p>
                           </li>
                           <li>
                              <p><a href="direct-path-load-interface.html#GUID-23DC0D22-8828-4B5F-A483-6BE3CA8689CE" title="如果列是标量，则通过将其值的地址传递给OCIDirPathColArrayEntrySet（），在列数组中设置其值。">将REF数据加载到列数组中</a></p>
                           </li>
                        </ul>
                     </div>
                  </div><a id="LNOCI16950"></a><div class="props_rev_3"><a id="GUID-02A4DC87-333F-4460-8B3A-70DB1E1E0FD9" name="GUID-02A4DC87-333F-4460-8B3A-70DB1E1E0FD9"></a><h5 id="LNOCI-GUID-02A4DC87-333F-4460-8B3A-70DB1E1E0FD9" class="sect5"><span class="enumeration_section">21.2.4.1</span>描述REF列</h5>
                     <div>
                        <p>描述<code class="codeph">REF</code>列的参数类似于描述要为表加载的列的列表。
                        </p>
                        <div class="section">
                           <p></p>
                           <div class="infoboxnote" id="GUID-02A4DC87-333F-4460-8B3A-70DB1E1E0FD9__GUID-A2BFD008-BDE1-4C5D-B319-21CBB93A5F78">
                              <p class="notep1">注意：</p>
                              <p><code class="codeph">REF</code>列可以是顶级表列，也可以嵌套为列对象的对象属性。
                              </p>
                              <p>与加载标量数据不同的步骤以斜体显示。</p>
                           </div>
                           <ol>
                              <li>
                                 <p>使用<code class="codeph">OCI_DTYPE_PARAM</code>在<code class="codeph">REF</code>列上获取参数句柄。此参数句柄用于设置列的外部属性。
                                 </p>
                              </li>
                              <li>
                                 <p>设置列名称及其他外部列属性（例如，最大数据大小，精度，比例）。</p>
                              </li>
                              <li>
                                 <p><span class="italic">使用OCI_ATTR_DATA_TYPE将REF列的外部类型设置为SQLT_REF。</span></p>
                              </li>
                              <li>
                                 <p><span class="italic">分配直接路径函数上下文句柄。此上下文用于描述REF列的参数。</span></p><pre class="oac_no_warn" dir="ltr">OCIDirPathFuncCtx * dpfnctx; / *直接路径函数上下文* /剑错误; error = OCIHandleAlloc（（void *）dpctx，（void **）＆dpfnctx，OCI_HTYPE_DIRPATH_FN_CTX，（size_t）0，（void **）0）;</pre></li>
                              <li>
                                 <p><span class="italic">可选：在函数上下文中的OCI_ATTR_NAME中设置REF列的表名。有关详细信息，请参阅下一步。</span></p><pre class="oac_no_warn" dir="ltr">OCIDirPathFuncCtx * dpfnctx; / * direct path function context * / text * ref_tbl; / *列的参考表* /剑错误; error = OCIAttrSet（（void *）dpfnctx，OCI_HTYPE_DIRPATH_FN_CTX，（void *）ref_tbl，（ub4）strlen（（const char *）ref_tbl），OCI_ATTR_NAME，ctlp-&gt; errhp_ctl）;</pre></li>
                              <li>
                                 <p><span class="italic">可选：将表达式类型OCI_ATTR_DIRPATH_EXPR_TYPE设置为OCI_DIRPATH_EXPR_REF_TBLNAME。仅在步骤5完成时设置此项。这表示使用OCI_ATTR_NAME设置的表达式将用作引用行对象的对象表。此参数是可选的。此参数的行为因REF类型而异。</span></p>
                                 <ul style="list-style-type:disc">
                                    <li>
                                       <p><span class="italic">无范围的REF列（无范围，基于系统OID）：</span></p>
                                       <p><span class="italic">如果未设置，则通过定义“unscoped”REF列，此REF列需要具有引用表名作为每个数据行的参数。</span></p>
                                       <p><span class="italic">如果设置，则此REF列只能在加载期间引用此指定对象表中的行对象。并且不允许REF列具有引用表名作为其参数。（直接路径API提供此参数作为将加载到未整理的REF列的用户的快捷方式，该列在整个加载期间引用相同的引用对象表。）</span></p>
                                    </li>
                                    <li>
                                       <p><span class="italic">Scoped REF列（范围，基于系统OID和基于主键）：</span></p>
                                       <p><span class="italic">如果未设置，则直接路径API使用架构中指定的引用表。</span></p>
                                       <p><span class="italic">如果设置，则引用表名称必须与此作用域REF列的架构中指定的对象表匹配。如果表名不匹配，则会发生错误。</span></p>
                                       <p><span class="italic">无论是否设置此参数，API对此引用表名称是否在数据行中都无关紧要。如果名称位于数据行中，则它必须与架构中指定的表名匹配。如果它不在数据行中，则API使用模式中指定的引用表。</span></p>
                                    </li>
                                 </ul>
                              </li>
                              <li>
                                 <p><span class="italic">设置用于引用具有OCI_ATTR_NUM_COLS的行对象的REF参数的数量。所需参数的数量因REF列类型而异。这个数字来自前面的第6步。</span></p>
                                 <ul style="list-style-type:disc">
                                    <li>
                                       <p><span class="italic">无范围REF列（无范围，基于系统OID的REF列）：</span></p>
                                       <p><span class="italic">一个如果使用OCI_DIRPATH_EXPR_REF_TBLNAME。参考表名称为None，OID值为1。</span></p>
                                       <p><span class="italic">如果未使用OCI_DIRPATH_EXPR_REF_TBLNAME，则为两个。一个用于引用表名，一个用于OID值。</span></p>
                                    </li>
                                    <li>
                                       <p><span class="italic">Scoped REF列（范围，基于系统OID和基于主键）：</span></p>
                                       <p><span class="italic">N或N + 1是可接受的，其中N是构成对象ID的列数，无论是否使用OCI_DIRPATH_EXPR_REF_TBLNAME。如果引用表名称不在数据行中，则Minimum为N.如果引用表名称在数据行中，则为N + 1。注意：如果REF是基于系统OID的，则N是1。如果REF是基于主键的，则N是组成主键的组件列的数量。如果引用表名称在数据行中，则向N添加一个。</span></p>
                                       <div class="infoboxnote" id="GUID-02A4DC87-333F-4460-8B3A-70DB1E1E0FD9__GUID-E130411A-8645-4B1C-AD27-B4C8018AFEAF">
                                          <p class="notep1">注意：</p>
                                          <p>为了简化错误消息，如果传入一些除N或N + 1以外的<code class="codeph">REF</code>参数，则错误消息表明它在期望N时发现了某某参数的数量。尽管消息中未说明N + 1 ，N + 1是可接受的（即使不需要引用表名称），也不会调用错误消息。
                                          </p>
                                       </div>
                                    </li>
                                 </ul>
                              </li>
                              <li>
                                 <p><span class="italic">获取函数上下文的列或属性参数列表。</span></p>
                              </li>
                              <li>
                                 <p><span class="italic">对于每个REF参数或属性：</span></p>
                                 <ol type="a">
                                    <li>
                                       <p>使用<code class="codeph">OCI_DTYPE_PARAM</code>获取<code class="codeph">REF</code>参数的列描述符。</p>
                                    </li>
                                    <li>
                                       <p>使用<code class="codeph">OCI_ATTR_NAME</code>设置属性的列名称。</p>
                                       <p><span class="italic">REF参数的顺序给定了问题。</span> <span class="italic">如果给出，则首先引用参考表名称。</span> <span class="italic">接下来是对象ID，无论是系统生成的还是基于主键的。</span></p>
                                       <p><span class="italic">REF参数有一个命名约定。</span> <span class="italic">由于引用表名称不是表列，因此可以对其列名使用任何虚拟名称，例如“ref-tbl”。</span> <span class="italic">对于系统生成的OID列，可以使用任何虚拟名称作为其列名，例如“sys-OID”。</span> <span class="italic">对于基于主键的对象ID，列出要加载的所有主键列。无需为OID创建虚拟名称。组件列名称（如果给出（请参阅后面的快捷方式说明））可以按任何顺序给出。</span></p>
                                       <p><span class="italic">不要为对象ID设置属性列名以使用快捷方式。</span></p>
                                       <p><span class="italic"><span class="bold">捷径。</span></span> <span class="italic"> 如果加载基于system-OID的REF列，请不要使用名称设置列名。API计算出来了。但您仍必须设置其他列属性，例如外部数据类型。</span></p>
                                       <p><span class="italic">如果加载主键REF列并且其主键由多列组成，则快捷方式不是设置其列名。但您仍必须设置其他列属性，例如外部数据类型。</span></p>
                                       <div class="infoboxnote" id="GUID-02A4DC87-333F-4460-8B3A-70DB1E1E0FD9__GUID-B3B92ADA-0821-4EE1-9B71-7AB5498B9A43">
                                          <p class="notep1">注意：</p>
                                          <p>如果组件列名称为NULL，则API代码确定在为主键定义它们的位置或顺序中的列名称。因此，在设置名称以外的列属性时，请确保以正确的顺序为组件列设置属性。</p>
                                       </div>
                                    </li>
                                    <li>
                                       <p>使用<code class="codeph">OCI_ATTR_DATA_TYPE</code>设置外部列类型（要传递给直接路径API的数据类型）。</p>
                                    </li>
                                    <li>
                                       <p>设置任何其他外部列属性（最大数据大小，精度，比例等）。</p>
                                    </li>
                                    <li>
                                       <p>释放列描述符的句柄。</p>
                                    </li>
                                    <li>
                                       <p><span class="italic">使用</span> <span class="italic"><code class="codeph">OCIDirPathFuncCtx</code></span> <span class="italic">设置</span> <span class="italic">在父列对象的参数句柄中在步骤4中创建</span> <span class="italic">的函数上下文</span> <span class="italic">OCIDirPathFuncCtx。</span></p>
                                    </li>
                                 </ol>
                              </li>
                           </ol>
                        </div>
                        <!-- class="section" -->
                     </div>
                  </div><a id="LNOCI72753"></a><a id="LNOCI16951"></a><div class="props_rev_3"><a id="GUID-09E1B9FB-28B9-4EC8-A02E-3723A2BE835C" name="GUID-09E1B9FB-28B9-4EC8-A02E-3723A2BE835C"></a><h5 id="LNOCI-GUID-09E1B9FB-28B9-4EC8-A02E-3723A2BE835C" class="sect5"><span class="enumeration_section">21.2.4.2</span>为REF列分配列数组</h5>
                     <div>
                        <p>显示如何为<code class="codeph">REF</code>列分配子列数组。
                        </p>
                        <div class="section">
                           <p><a href="direct-path-load-interface.html#GUID-09E1B9FB-28B9-4EC8-A02E-3723A2BE835C__CACJJCCB">例21-20</a>显示了如何为<code class="codeph">REF</code>列分配子列数组。
                           </p>
                        </div>
                        <!-- class="section" -->
                        <div class="example" id="GUID-09E1B9FB-28B9-4EC8-A02E-3723A2BE835C__CACJJCCB">
                           <p class="titleinexample">示例21-20为REF列分配子列数组</p><pre class="oac_no_warn" dir="ltr">OCIDirPathFuncCtx * dpfnctx; / *直接路径函数上下文* / OCIDirPathColArray * dpfnca; / *直接路径函数列数组* /剑错误; error = OCIHandleAlloc（（void *）dpfnctx，（void **）＆dpfnca，OCI_HTYPE_DIRPATH_FN_COL_ARRAY，（size_t）0，（void **）0）;</pre></div>
                        <!-- class="example" -->
                     </div>
                  </div><a id="LNOCI16952"></a><div class="props_rev_3"><a id="GUID-23DC0D22-8828-4B5F-A483-6BE3CA8689CE" name="GUID-23DC0D22-8828-4B5F-A483-6BE3CA8689CE"></a><h5 id="LNOCI-GUID-23DC0D22-8828-4B5F-A483-6BE3CA8689CE" class="sect5"><span class="enumeration_section">21.2.4.3</span>将REF数据加载到列数组中</h5>
                     <div>
                        <p>如果列是标量，则通过将其值的地址传递给<code class="codeph">OCIDirPathColArrayEntrySet()</code> ，在列数组中设置其值。
                        </p>
                        <div class="section">
                           <p>如果列是<code class="codeph">REF</code> ，则传递其子列数组句柄的地址。子列数组包含<code class="codeph">REF</code>参数的数据。
                           </p>
                           <p>要将数据加载到<code class="codeph">REF</code>列：</p>
                           <div class="infoboxnote" id="GUID-23DC0D22-8828-4B5F-A483-6BE3CA8689CE__GUID-62F14D2B-1169-4A52-B861-E82B38F446BD">
                              <p class="notep1">注意：</p>
                              <p>与加载标量数据不同的步骤以斜体显示。</p>
                           </div>
                           <p><span class="italic">对于每个REF列：</span></p>
                           <ol>
                              <li>
                                 <p><span class="italic">如果列是非NULL：</span></p>
                                 <ol type="a">
                                    <li>
                                       <p><span class="italic">对于每个REF参数列：</span></p>
                                       <p><span class="italic">使用</span> <span class="italic">OCIDirPathColArrayEntrySet（）</span> <span class="italic">在子列数组中设置其数据</span> <span class="italic">。</span></p>
                                    </li>
                                    <li>
                                       <p><span class="italic">通过将其子列数组句柄的地址传递给</span> <span class="italic">OCIDirPathColArrayEntrySet（），</span> <span class="italic">将REF列的数据设置为列数组</span> <span class="italic">。</span></p>
                                    </li>
                                 </ol>
                              </li>
                              <li>
                                 <p>否则，如果列为NULL：</p>
                                 <p>通过将数据的NULL地址（长度为0）和<code class="codeph">OCI_DIRPATH_COL_NULL</code>标志传递给<code class="codeph">OCIDirPathColArrayEntrySet()</code> ，将<code class="codeph">REF</code>列的数据设置为列数组。
                                 </p>
                                 <div class="infoboxnotealso" id="GUID-23DC0D22-8828-4B5F-A483-6BE3CA8689CE__GUID-19B41CED-4815-409D-ADBD-FA53FF897401">
                                    <p class="notep1">也可以看看：</p>
                                    <ul style="list-style-type:disc">
                                       <li>
                                          <p><a href="direct-path-load-interface.html#GUID-C67EFBE6-677E-4E3C-8024-8412857C3BE0" title="OCI_DIRPATH_COL_ERROR值传递给OCIDirPathColArrayEntry（）以指示应忽略当前列数组行。">OCI_DIRPATH_COL_ERROR</a></p>
                                       </li>
                                       <li>
                                          <p><a href="direct-path-loading-functions.html#GUID-4E4E74F4-3F15-4176-8229-C5783DC3811D" title="将列数组中的指定条目设置为提供的值。">OCIDirPathColArrayEntrySet（）</a></p>
                                       </li>
                                    </ul>
                                 </div>
                              </li>
                           </ol>
                        </div>
                        <!-- class="section" -->
                     </div>
                  </div>
               </div><a id="LNOCI16953"></a><div class="props_rev_3"><a id="GUID-4001897C-6736-4B0B-BCB7-F0C3EB608A70" name="GUID-4001897C-6736-4B0B-BCB7-F0C3EB608A70"></a><h4 id="LNOCI-GUID-4001897C-6736-4B0B-BCB7-F0C3EB608A70" class="sect4"><span class="enumeration_section">21.2.5</span> NOT FINAL对象和REF列的直接路径加载</h4>
                  <div>
                     <p>回想一下，SQL对象继承是基于形成类型层次结构的对象类型的族树。</p>
                     <p>类型层次结构由父对象类型（称为超类型）和一个或多个子对象类型级别（称为子类型）组成，这些子对象类型派生自父级。</p>
                     <div class="p">本节包括以下主题：<ul style="list-style-type:disc">
                           <li>
                              <p><a href="direct-path-load-interface.html#GUID-EAF14E36-0523-4C20-ACC1-BBA8097EB0E0" title="回想一下，对于可继承的对象类型，对象类型定义必须指定它是可继承的。">继承层次结构</a></p>
                           </li>
                           <li>
                              <p><a href="direct-path-load-interface.html#GUID-68DE4F77-4C16-4436-B1D6-CA4E471B1CE2" title="请注意，描述固定派生类型的NOT FINAL或可替换对象列和REF列的步骤与描述其FINAL对应项的步骤类似。">关于描述要加载的固定派生类型</a></p>
                           </li>
                           <li>
                              <p><a href="direct-path-load-interface.html#GUID-BE30BD66-BF95-4E29-9335-0249E3C3C41B" title="表示它与相同类型的FINAL列相同。">关于分配列数组</a></p>
                           </li>
                           <li>
                              <p><a href="direct-path-load-interface.html#GUID-4C7BA004-49EE-4E66-9829-C00335812363" title="表示它与相同类型的FINAL列相同。">关于将数据加载到列数组中</a></p>
                           </li>
                        </ul>
                     </div>
                  </div><a id="LNOCI72754"></a><a id="LNOCI16954"></a><div class="props_rev_3"><a id="GUID-EAF14E36-0523-4C20-ACC1-BBA8097EB0E0" name="GUID-EAF14E36-0523-4C20-ACC1-BBA8097EB0E0"></a><h5 id="LNOCI-GUID-EAF14E36-0523-4C20-ACC1-BBA8097EB0E0" class="sect5"><span class="enumeration_section">21.2.5.1</span>继承层次结构</h5>
                     <div>
                        <p>回想一下，对于可继承的对象类型，对象类型定义必须指定它是可继承的。</p>
                        <p><a href="direct-path-load-interface.html#GUID-EAF14E36-0523-4C20-ACC1-BBA8097EB0E0__CACEJFED">图21-2显示</a>了<code class="codeph">Person</code>类型的列的继承层次结构。<code class="codeph">Person</code>超类型位于层次结构的顶部，具有两个属性： <code class="codeph">Name</code> ， <code class="codeph">Address</code> 。<code class="codeph">Person</code>有两种子类型， <code class="codeph">Employee</code>和<code class="codeph">Student</code> 。<code class="codeph">Employee</code>子类型有两个属性： <code class="codeph">Manager</code> ， <code class="codeph">Deptid</code> 。<code class="codeph">Student</code>子类型有两个属性： <code class="codeph">Units</code> ， <code class="codeph">GPA</code> 。 <code class="codeph">ParttimeEmployee</code>是<code class="codeph">Employee</code>的子类型，显示在它下面。子类型<code class="codeph">ParttimeEmployee</code>有一个属性： <code class="codeph">Hours</code> 。这些是可以存储在<code class="codeph">Person</code>列中的类型。
                        </p>
                        <div class="figure" id="GUID-EAF14E36-0523-4C20-ACC1-BBA8097EB0E0__CACEJFED">
                           <p class="titleinfigure">图21-2类型Person列的继承层次结构</p><img src="img/lnoci046.gif" alt="下面是图21-2的描述" title="下面是图21-2的描述" longdesc="img_text/lnoci046.html"><br><a href="img_text/lnoci046.html">“图21-2类型人员列的继承层次结构”的说明</a></div>
                        <!-- class="figure" -->
                        <p>一旦指定，就可以从中派生出子类型。要指定可继承的对象，必须在其类型定义中指定关键字<code class="codeph">NOT FINAL</code> 。要指定不可继承的对象，必须在其类型定义中指定关键字FINAL。
                        </p>
                        <p>当您直接路径加载包含<code class="codeph">Person</code>类型列的表时，实际的类型集可以包括以下四种中的任何一种： <code class="codeph">NOT FINAL</code>类型<code class="codeph">Person</code>及其三个子类型： <code class="codeph">Student</code> ， <code class="codeph">Employee</code>和<code class="codeph">ParttimeEmployee</code> 。因为直接路径加载API仅支持在此加载期间将一个固定的派生类型加载到此<code class="codeph">NOT FINAL</code>列，所以直接路径加载API必须知道要加载这些类型中的哪一个，要加载的属性此类型，以及用于创建此类型的函数。
                        </p>
                        <p>因此，在描述和加载派生类型时，必须指定要加载的该类型的所有属性。可以将子类型视为此类型唯一的所有对象属性的展平表示形式，以及其祖先的所有属性。因此，要加载的这些属性列中的任何一个，都必须进行描述和计数。</p>
                        <p>例如，要加载<code class="codeph">ParttimeEmployee</code>所有列，必须描述并计算要加载的五个对象属性： <code class="codeph">Name</code> ， <code class="codeph">Address</code> ， <code class="codeph">Manager</code> ， <code class="codeph">Deptid</code>和<code class="codeph">Hours.</code></p>
                        <div class="infoboxnotealso" id="GUID-EAF14E36-0523-4C20-ACC1-BBA8097EB0E0__GUID-EFCE1B21-54B9-4E9E-976E-29B3CE03D922">
                           <p class="notep1">也可以看看：</p>
                           <p>有关定义<code class="codeph">FINAL</code>和<code class="codeph">NOT FINAL</code>类型的更多信息，请<code class="codeph">FINAL</code> <a href="../adobj/inheritance-in-sql-object-types.html#ADOBJ7103" target="_blank"><span><cite>“Oracle数据库对象关系开发人员指南”</cite></span></a> 。
                           </p>
                        </div>
                     </div>
                  </div><a id="LNOCI16955"></a><div class="props_rev_3"><a id="GUID-68DE4F77-4C16-4436-B1D6-CA4E471B1CE2" name="GUID-68DE4F77-4C16-4436-B1D6-CA4E471B1CE2"></a><h5 id="LNOCI-GUID-68DE4F77-4C16-4436-B1D6-CA4E471B1CE2" class="sect5"><span class="enumeration_section">21.2.5.2</span>关于描述要加载的固定派生类型</h5>
                     <div>
                        <p>请注意，描述固定派生类型的<code class="codeph">NOT FINAL</code>或可替换对象列和<code class="codeph">REF</code>列的步骤与描述其<code class="codeph">FINAL</code>对应项的步骤类似。
                        </p>
                        <p>这些部分描述了此类型的<code class="codeph">FINAL</code>列。因为派生类型（可以是一个超或子类型）是固定的负载的持续时间，用于说明客户端接口<code class="codeph">NOT FINAL</code>列是相同的用于描述<code class="codeph">FINAL</code>柱。
                        </p>
                        <p>子类型可以被认为是此类型所特有的所有对象属性的扁平表示以及其祖先的所有属性。因此，必须描述和计算要加载到的任何这些属性列。</p>
                        <div class="infoboxnotealso" id="GUID-68DE4F77-4C16-4436-B1D6-CA4E471B1CE2__GUID-539E9049-B579-456C-ACDB-97B83387014A">
                           <p class="notep1">也可以看看：</p>
                           <p><a href="direct-path-load-interface.html#GUID-F155292D-2DBE-4EC3-A2F1-4D567DFC1E4E" title="列对象是定义为对象的表列。">列对象的</a> <a href="direct-path-load-interface.html#GUID-2CE26A43-4193-4C8D-9C12-77A943811958" title="The REF type is a pointer, or reference, to a row object in an object table.">直接路径加载</a>或<a href="direct-path-load-interface.html#GUID-2CE26A43-4193-4C8D-9C12-77A943811958" title="REF类型是对象表中行对象的指针或引用。">REF列的直接路径加载，</a>以获取有关如何描述类型X的<code class="codeph">NOT FINAL</code>列的信息（其中X是对象或<code class="codeph">REF</code> ）</p>
                        </div>
                     </div>
                  </div><a id="LNOCI16956"></a><div class="props_rev_3"><a id="GUID-BE30BD66-BF95-4E29-9335-0249E3C3C41B" name="GUID-BE30BD66-BF95-4E29-9335-0249E3C3C41B"></a><h5 id="LNOCI-GUID-BE30BD66-BF95-4E29-9335-0249E3C3C41B" class="sect5"><span class="enumeration_section">21.2.5.3</span>关于分配列数组</h5>
                     <div>
                        <p>表示它与相同类型的<code class="codeph">FINAL</code>列相同。
                        </p>
                        <p>分配列数组与相同类型的<code class="codeph">FINAL</code>列相同。
                        </p>
                     </div>
                  </div><a id="LNOCI16957"></a><div class="props_rev_3"><a id="GUID-4C7BA004-49EE-4E66-9829-C00335812363" name="GUID-4C7BA004-49EE-4E66-9829-C00335812363"></a><h5 id="LNOCI-GUID-4C7BA004-49EE-4E66-9829-C00335812363" class="sect5"><span class="enumeration_section">21.2.5.4</span>关于将数据加载到列数组中</h5>
                     <div>
                        <p>表示它与相同类型的<code class="codeph">FINAL</code>列相同。
                        </p>
                        <p>将数据加载到列数组中与相同类型的<code class="codeph">FINAL</code>列相同。
                        </p>
                     </div>
                  </div>
               </div><a id="LNOCI72755"></a><a id="LNOCI72756"></a><a id="LNOCI72758"></a><a id="LNOCI72757"></a><a id="LNOCI16958"></a><div class="props_rev_3"><a id="GUID-8C639AF1-1A8B-4BAA-A02E-FF4F8B37BD38" name="GUID-8C639AF1-1A8B-4BAA-A02E-FF4F8B37BD38"></a><h4 id="LNOCI-GUID-8C639AF1-1A8B-4BAA-A02E-FF4F8B37BD38" class="sect4"><span class="enumeration_section">21.2.6</span>对象表的直接路径加载</h4>
                  <div>
                     <p>对象表是一个表，其中每一行是一个对象（或行对象）。表中的每一列都是一个对象属性。</p>
                     <div class="section">
                        <p class="subhead3" id="GUID-8C639AF1-1A8B-4BAA-A02E-FF4F8B37BD38__GUID-643C1F52-E1A7-4318-86CE-C650C3E53B91">描述对象表</p>
                     </div>
                     <!-- class="section" -->
                     <div class="section">
                        <p>描述对象表与描述非对象表非常相似。每个对象属性都是表中的一列。唯一的区别是您可能需要描述OID，它可以是系统生成的，用户生成的或基于主键的。</p>
                        <p>描述对象表：</p>
                        <div class="infoboxnote" id="GUID-8C639AF1-1A8B-4BAA-A02E-FF4F8B37BD38__GUID-750904BD-D018-4D13-BBE5-F7BB616F25F7">
                           <p class="notep1">注意：</p>
                           <p>与加载非对象表不同的步骤以斜体显示。</p>
                        </div>
                        <p><span class="italic">对于每个对象属性列：</span></p>
                        <p>描述必须描述的每个对象属性列，具体取决于其类型（例如， <code class="codeph">NUMBER</code> ， <code class="codeph">REF</code> ）：</p>
                        <p><span class="italic">对于对象表OID（Oracle Internet Directory）：</span></p>
                        <ol>
                           <li>
                              <p><span class="italic">如果对象ID是系统生成的：</span></p>
                              <p><span class="italic">没有什么额外的事情要做。系统为每个行对象生成OID。</span></p>
                           </li>
                           <li>
                              <p><span class="italic">如果对象ID是用户生成的：</span></p>
                              <ol type="a">
                                 <li>
                                    <p><span class="italic">使用虚拟名称表示OID的列名称（例如，“cust_oid”）。</span></p>
                                 </li>
                                 <li>
                                    <p><span class="italic">使用OCI_ATTR_DIRPATH_OID设置OID列属性。</span></p>
                                 </li>
                              </ol>
                           </li>
                           <li>
                              <p><span class="italic">如果对象ID是基于主键的：</span></p>
                              <ol type="a">
                                 <li>
                                    <p><span class="italic">加载构成OID的所有主键列。</span></p>
                                 </li>
                                 <li>
                                    <p><span class="italic">不要设置OCI_ATTR_DIRPATH_OID，因为没有创建具有虚拟名称的OID列。</span></p>
                                 </li>
                              </ol>
                           </li>
                        </ol>
                     </div>
                     <!-- class="section" -->
                     <div class="section">
                        <p class="subhead3" id="GUID-8C639AF1-1A8B-4BAA-A02E-FF4F8B37BD38__GUID-8A8FD2C0-4AC0-488E-9405-3FA647BABFFB">为对象表分配列数组</p>
                     </div>
                     <!-- class="section" -->
                     <div class="section">
                        <p><a href="direct-path-load-interface.html#GUID-8C639AF1-1A8B-4BAA-A02E-FF4F8B37BD38__CACDAFEE">例21-21</a>显示为对象表分配列数组与为非对象表分配列数组相同。
                        </p>
                     </div>
                     <!-- class="section" -->
                     <div class="section">
                        <p class="subhead3" id="GUID-8C639AF1-1A8B-4BAA-A02E-FF4F8B37BD38__GUID-45271DFF-E081-4452-B38F-FE8FCFFC9DB6">将数据加载到列数组中</p>
                     </div>
                     <!-- class="section" -->
                     <div class="section">
                        <p>将数据加载到列数组与将数据加载到非对象表中相同。</p>
                     </div>
                     <!-- class="section" -->
                     <div class="example" id="GUID-8C639AF1-1A8B-4BAA-A02E-FF4F8B37BD38__CACDAFEE">
                        <p class="titleinexample">示例21-21为对象表分配列数组</p><pre class="oac_no_warn" dir="ltr">OCIDirPathColArray * dpca; / *直接路径列数组* /剑错误; error = OCIHandleAlloc（（void *）dpctx，（void **）＆dpca，OCI_HTYPE_DIRPATH_COLUMN_ARRAY，（size_t）0，（void **）0）;</pre></div>
                     <!-- class="example" -->
                  </div>
               </div><a id="LNOCI72759"></a><a id="LNOCI72760"></a><a id="LNOCI16962"></a><div class="props_rev_3"><a id="GUID-04BF14FF-1FF4-4F3A-BBB8-EA2500471DDF" name="GUID-04BF14FF-1FF4-4F3A-BBB8-EA2500471DDF"></a><h4 id="LNOCI-GUID-04BF14FF-1FF4-4F3A-BBB8-EA2500471DDF" class="sect4"><span class="enumeration_section">21.2.7</span>直接路径加载NOT FINAL对象表</h4>
                  <div>
                     <p><code class="codeph">NOT FINAL</code>对象表支持继承，而<code class="codeph">FINAL</code>对象表则不支持。
                     </p>
                     <div class="section">
                        <p class="subhead3" id="GUID-04BF14FF-1FF4-4F3A-BBB8-EA2500471DDF__GUID-1396DAE7-AE1F-40AE-8525-BCFB7B4B672E">描述NOT FINAL对象表</p>
                     </div>
                     <!-- class="section" -->
                     <div class="section">
                        <p>描述固定派生类型的<code class="codeph">NOT FINAL</code>对象表与描述<code class="codeph">FINAL</code>对象表非常相似。
                        </p>
                        <p>要描述固定派生类型的<code class="codeph">NOT FINAL</code>对象表：</p>
                        <div class="infoboxnote" id="GUID-04BF14FF-1FF4-4F3A-BBB8-EA2500471DDF__GUID-95C4ACBF-922F-4845-9AC5-F57F374145DB">
                           <p class="notep1">注意：</p>
                           <p>与描述<code class="codeph">FINAL</code>对象表不同的步骤以斜体显示。
                           </p>
                        </div>
                        <ol>
                           <li>
                              <p><span class="italic">使用OCI_ATTR_DIRPATH_OBJ_CONSTR在直接路径上下文中设置对象表的对象类型。这表示在加载持续时间内加载到此表时，对象类型（无论是超类型还是派生类型）将用作默认对象构造函数。</span></p><pre class="oac_no_warn" dir="ltr">text * obj_type; / *要加载到此NOT FINAL * / / *对象表中的对象类型* /剑错误; error = OCIAttrSet（（void *）dpctx，OCI_HTYPE_DIRPATH_CTX，（void *）obj_type，（ub4）strlen（（const char *）obj_type），OCI_ATTR_DIRPATH_OBJ_CONSTR，ctlp-&gt; errhp_ctl）;</pre></li>
                           <li>
                              <p>根据其数据类型描述要加载的每个对象属性列。如果需要，请描述对象ID。这与描述<code class="codeph">FINAL</code>对象表相同。
                              </p>
                           </li>
                        </ol>
                     </div>
                     <!-- class="section" -->
                     <div class="section">
                        <p class="subhead3" id="GUID-04BF14FF-1FF4-4F3A-BBB8-EA2500471DDF__GUID-2FE84BC1-5B2B-4B7B-87D0-7016847EE362">为NOT FINAL对象表分配列数组</p>
                     </div>
                     <!-- class="section" -->
                     <div class="section">
                        <p>分配用于所述列阵列<code class="codeph">NOT FINAL</code>目标表是相同的用于<code class="codeph">FINAL</code>对象表。
                        </p>
                     </div>
                     <!-- class="section" -->
                  </div>
               </div>
            </div><a id="LNOCI16965"></a><div class="props_rev_3"><a id="GUID-A2811AF9-FD71-49E7-9658-931C9C73B363" name="GUID-A2811AF9-FD71-49E7-9658-931C9C73B363"></a><h3 id="LNOCI-GUID-A2811AF9-FD71-49E7-9658-931C9C73B363" class="sect3"><span class="enumeration_section">21.3</span>片段中的直接路径加载</h3>
               <div>
                  <p>要支持一次加载并非全部适合内存的数据，请使用片段加载。</p>
                  <div class="section">
                     <p>直接路径API支持递增地加载<code class="codeph">LONG</code>和LOB。这是通过以下步骤完成的：</p>
                  </div>
                  <!-- class="section" -->
                  <ol>
                     <li><span>使用<code class="codeph">OCIDirPathColArrayEntrySet()</code>将第一个部分设置为列数组，并传入<code class="codeph">OCI_DIRPATH_COL_PARTIAL</code>标志以指示尚未加载此列的所有数据。</span></li>
                     <li><span>将列数组转换为流。</span></li>
                     <li><span>加载流。</span></li>
                     <li><span>将下一段数据设置为列数组。如果未完成，请设置部分标志并返回步骤2。如果已完成，则设置<code class="codeph">OCI_DIRPATH_COL_COMPLETE</code>标志并继续下一列。</span></li>
                  </ol>
                  <div class="section">
                     <p>对于处理列对象的大型属性和SQL字符串类型的大型参数，此方法基本相同。</p>
                     <div class="infoboxnote" id="GUID-A2811AF9-FD71-49E7-9658-931C9C73B363__GUID-C8C0D3A0-3557-443B-8BCB-B39029A52375">
                        <p class="notep1">注意：</p>
                        <p>集合不会被加载成碎片。嵌套表单独加载，并像顶级表一样加载。嵌套表可以以递增方式加载，并且可以包含按片加载的列。因此，请勿为包含该集合的列设置<code class="codeph">OCI_DIRPATH_COL_PARTIAL</code>标志。
                        </p>
                        <p>本节包括以下主题： <a href="direct-path-load-interface.html#GUID-6A934E62-30AA-40CF-9469-61075AE9845E" title="对象从包含它们的父表加载到单独的列数组中。">在片中加载对象类型</a> 。
                        </p>
                     </div>
                  </div>
                  <!-- class="section" -->
                  <div class="section">
                     <div class="infoboxnotealso" id="GUID-A2811AF9-FD71-49E7-9658-931C9C73B363__GUID-0326ED44-459B-4B85-806F-3659D8A38961">
                        <p class="notep1">也可以看看：</p>
                        <ul style="list-style-type:disc">
                           <li>
                              <p><a href="direct-path-load-interface.html#GUID-C67EFBE6-677E-4E3C-8024-8412857C3BE0" title="OCI_DIRPATH_COL_ERROR值传递给OCIDirPathColArrayEntry（）以指示应忽略当前列数组行。">OCI_DIRPATH_COL_ERROR</a>有关将<code class="codeph">OCI_DIRPATH_COL_ERROR</code>值传递给<code class="codeph">OCIDirPathColArrayEntry()</code>更多信息，以指示发生错误时应忽略当前列数组行</p>
                           </li>
                           <li>
                              <p><a href="direct-path-loading-functions.html#GUID-4E4E74F4-3F15-4176-8229-C5783DC3811D" title="将列数组中的指定条目设置为提供的值。">OCIDirPathColArrayEntrySet（）</a></p>
                           </li>
                        </ul>
                     </div>
                  </div>
                  <!-- class="section" -->
               </div><a id="LNOCI16966"></a><div class="props_rev_3"><a id="GUID-6A934E62-30AA-40CF-9469-61075AE9845E" name="GUID-6A934E62-30AA-40CF-9469-61075AE9845E"></a><h4 id="LNOCI-GUID-6A934E62-30AA-40CF-9469-61075AE9845E" class="sect4"><span class="enumeration_section">21.3.1</span>在片段中加载对象类型</h4>
                  <div>
                     <p>对象从包含它们的父表加载到单独的列数组中。</p>
                     <div class="section">
                        <p>因此，当需要加载它们时，必须将子列数组中的元素设置为包括拼合元素在内的元素。</p>
                        <p>一般步骤是：</p>
                     </div>
                     <!-- class="section" -->
                     <ol>
                        <li><span>对于拼合元素，请设置<code class="codeph">OCI_DIRPATH_COL_PARTIAL</code>标志。</span></li>
                        <li><span>将子列数组句柄设置为父列数组，并使用<code class="codeph">OCI_DIRPATH_COL_PARTIAL</code>标志标记该条目。</span></li>
                        <li><span>将父列数组转换为流。这也会转换子列数组。</span></li>
                        <li><span>加载流。</span></li>
                        <li><span>返回步骤1并继续加载该元素的剩余数据，直到完成为止。</span></li>
                     </ol>
                     <div class="section">
                        <p>以下是关于加载件的一些规则：</p>
                        <ul style="list-style-type:disc">
                           <li>
                              <p>在任何级别一次只能有一个部分元素。一旦一个部分元素被标记为完成，那么该级别的另一个元素可以是部分元素。</p>
                           </li>
                           <li>
                              <p>如果一个元素是部分的并且它不是顶层的，那么它在收容层次结构中的所有祖先也必须被标记为部分。</p>
                           </li>
                           <li>
                              <p>如果存在多个嵌套级别，则必须达到可以将数据转换为流的级别。这是一个顶级表。</p>
                           </li>
                        </ul>
                        <div class="infoboxnotealso" id="GUID-6A934E62-30AA-40CF-9469-61075AE9845E__GUID-4E84B9BD-4967-4B0A-894D-8322955704D4">
                           <p class="notep1">也可以看看：</p>
                           <p><a href="direct-path-load-interface.html#GUID-C67EFBE6-677E-4E3C-8024-8412857C3BE0" title="OCI_DIRPATH_COL_ERROR值传递给OCIDirPathColArrayEntry（）以指示应忽略当前列数组行。">OCI_DIRPATH_COL_ERROR</a>有关将<code class="codeph">OCI_DIRPATH_COL_ERROR</code>值传递给<code class="codeph">OCIDirPathColArrayEntry()</code>更多信息，以指示发生错误时应忽略当前列数组行。
                           </p>
                        </div>
                     </div>
                     <!-- class="section" -->
                  </div>
               </div>
            </div><a id="LNOCI16967"></a><div class="props_rev_3"><a id="GUID-E66F9F47-5465-481F-8CBE-E2B00194E102" name="GUID-E66F9F47-5465-481F-8CBE-E2B00194E102"></a><h3 id="LNOCI-GUID-E66F9F47-5465-481F-8CBE-E2B00194E102" class="sect3"><span class="enumeration_section">21.4</span>对象类型的直接路径上下文句柄和属性</h3>
               <div>
                  <p>以下讨论给出了句柄和属性的补充细节。</p>
                  <div class="p">本节包括以下主题：<ul style="list-style-type:disc">
                        <li>
                           <p><a href="direct-path-load-interface.html#GUID-24206542-CD29-4FAE-826E-B8A31F8C5789" title="有一个直接路径上下文属性。">直接路径上下文属性</a></p>
                        </li>
                        <li>
                           <p><a href="direct-path-load-interface.html#GUID-2A9A675D-B914-4A61-B0A3-C0B455EA7E26" title="以下是函数上下文句柄的属性摘要。">直接路径函数上下文和属性</a></p>
                        </li>
                        <li>
                           <p><a href="direct-path-load-interface.html#GUID-49105A08-EFF7-4FEE-A457-FE6ABB29851E" title="描述对象，SQL字符串或REF列时，其列属性之一是函数上下文。">直接路径列参数属性</a></p>
                        </li>
                        <li>
                           <p><a href="direct-path-load-interface.html#GUID-56DA52A3-8A3B-496F-8267-D6EF4C5427B1" title="如果列是对象，SQL字符串或REF，则使用句柄类型OCI_HTYPE_DIRPATH_FN_COL_ARRAY。">非标量列的直接路径功能列数组句柄</a></p>
                        </li>
                     </ul>
                  </div>
                  <div class="infoboxnotealso" id="GUID-E66F9F47-5465-481F-8CBE-E2B00194E102__GUID-631DCF59-BDAA-4DDD-B279-28E3052BEBB0">
                     <p class="notep1">也可以看看：</p>
                     <p><a href="handle-and-descriptor-attributes.html#GUID-CB59C987-07E7-42D4-ADDF-96142CBD3D11" title="本附录描述了OCI句柄和描述符的属性。">句柄和描述符属性</a>用于讨论，提供句柄和属性的补充细节</p>
                  </div>
               </div><a id="LNOCI16968"></a><div class="props_rev_3"><a id="GUID-24206542-CD29-4FAE-826E-B8A31F8C5789" name="GUID-24206542-CD29-4FAE-826E-B8A31F8C5789"></a><h4 id="LNOCI-GUID-24206542-CD29-4FAE-826E-B8A31F8C5789" class="sect4"><span class="enumeration_section">21.4.1</span>直接路径上下文属性</h4>
                  <div>
                     <p>有一个直接路径上下文属性。</p>
                     <div class="infoboxnotealso" id="GUID-24206542-CD29-4FAE-826E-B8A31F8C5789__GUID-B4E49628-8A7E-4A56-AE30-6EBABB876752">
                        <p class="notep1">也可以看看：</p>
                        <p><a href="direct-path-load-interface.html#GUID-455EEEFF-312F-4B7D-A7EF-DE23FF69E5D0" title="指示要加载到NOT FINAL对象表中的对象类型。">OCI_ATTR_DIRPATH_OBJ_CONSTR</a>是唯一的直接路径上下文属性</p>
                     </div>
                  </div><a id="LNOCI16969"></a><div class="props_rev_3"><a id="GUID-455EEEFF-312F-4B7D-A7EF-DE23FF69E5D0" name="GUID-455EEEFF-312F-4B7D-A7EF-DE23FF69E5D0"></a><h5 id="LNOCI-GUID-455EEEFF-312F-4B7D-A7EF-DE23FF69E5D0" class="sect5"><span class="enumeration_section">21.4.1.1</span> OCI_ATTR_DIRPATH_OBJ_CONSTR</h5>
                     <div>
                        <p>指示要加载到<code class="codeph">NOT FINAL</code>对象表中的对象类型。
                        </p><pre class="oac_no_warn" dir="ltr">ttext * obj_type; / *要加载到此NOT FINAL * / / *对象表中的对象类型* /剑错误; error = OCIAttrSet（（void *）dpctx，OCI_HTYPE_DIRPATH_CTX，（void *）obj_type，（ub4）strlen（（const char *）obj_type），OCI_ATTR_DIRPATH_OBJ_CONSTR，ctlp-&gt; errhp_ctl）;</pre></div>
                  </div>
               </div><a id="LNOCI16970"></a><div class="props_rev_3"><a id="GUID-2A9A675D-B914-4A61-B0A3-C0B455EA7E26" name="GUID-2A9A675D-B914-4A61-B0A3-C0B455EA7E26"></a><h4 id="LNOCI-GUID-2A9A675D-B914-4A61-B0A3-C0B455EA7E26" class="sect4"><span class="enumeration_section">21.4.2</span>直接路径功能上下文和属性</h4>
                  <div>
                     <p>以下是函数上下文句柄的属性摘要。</p>
                     <div class="p">本节包括以下主题：<ul style="list-style-type:disc">
                           <li>
                              <p><a href="direct-path-load-interface.html#GUID-9092B214-63E1-4DD3-AF84-288A6DE85554" title="指示要加载到可替换对象表中的对象类型。">OCI_ATTR_DIRPATH_OBJ_CONSTR</a></p>
                           </li>
                           <li>
                              <p><a href="direct-path-load-interface.html#GUID-ED73E051-3467-4498-8659-01E595F6A272" title="创建函数上下文时，将OCI_ATTR_NAME设置为等于描述非标量列的表达式。">OCI_ATTR_NAME</a></p>
                           </li>
                           <li>
                              <p><a href="direct-path-load-interface.html#GUID-3D326302-0366-476F-A6E6-F94F872C7833" title="此属性用于指示OCI_ATTR_NAME中为非标量列的函数上下文指定的表达式的类型。">OCI_ATTR_DIRPATH_EXPR_TYPE</a></p>
                           </li>
                           <li>
                              <p><a href="direct-path-load-interface.html#GUID-39F85D35-2B27-4FF3-AE83-828E1090C5D3" title="当OCI_ATTR_DIRPATH_NO_INDEX_ERRORS为1时，索引在加载期间的任何时候都不会设置为不可用。">OCI_ATTR_DIRPATH_NO_INDEX_ERRORS</a></p>
                           </li>
                           <li>
                              <p><a href="direct-path-load-interface.html#GUID-286D5D9F-EC97-4013-8EC9-00F3588AD383" title="此属性描述要为非标量列加载或处理的属性或参数的数量。">OCI_ATTR_NUM_COLS</a></p>
                           </li>
                           <li>
                              <p><a href="direct-path-load-interface.html#GUID-3426FD61-9AF7-4F73-8C20-9AF46B98971F" title="当用于OCI_HTYPE_DIRPATH_FN_CTX（函数上下文）时，该属性仅可检索，并且不能由用户设置。">OCI_ATTR_NUM_ROWS</a></p>
                           </li>
                        </ul>
                     </div>
                     <div class="infoboxnotealso" id="GUID-2A9A675D-B914-4A61-B0A3-C0B455EA7E26__GUID-B448889C-6C02-4991-9096-7218488B7042">
                        <p class="notep1">也可以看看：</p>
                        <p><a href="handle-and-descriptor-attributes.html#GUID-07F0F31C-94FF-4E3B-B8E1-C2394CB94390" title="列出并描述直接路径上下文句柄（OCIDirPathCtx）属性。">直接路径上下文句柄（OCIDirPathCtx）属性</a></p>
                     </div>
                  </div><a id="LNOCI16971"></a><div class="props_rev_3"><a id="GUID-9092B214-63E1-4DD3-AF84-288A6DE85554" name="GUID-9092B214-63E1-4DD3-AF84-288A6DE85554"></a><h5 id="LNOCI-GUID-9092B214-63E1-4DD3-AF84-288A6DE85554" class="sect5"><span class="enumeration_section">21.4.2.1</span> OCI_ATTR_DIRPATH_OBJ_CONSTR</h5>
                     <div>
                        <p>指示要加载到可替换对象表中的对象类型。</p><pre class="oac_no_warn" dir="ltr">text * obj_type; / *存储对象类型名称* /剑错误; error = OCIAttrSet（（void *）dpctx，OCI_HTYPE_DIRPATH_CTX，（void *）obj_type，（ub4）strlen（（const char *）obj_type），OCI_ATTR_DIRPATH_OBJ_CONSTR，ctlp-&gt; errhp_ctl）;</pre></div>
                  </div><a id="LNOCI72761"></a><a id="LNOCI72762"></a><a id="LNOCI72763"></a><a id="LNOCI16972"></a><div class="props_rev_3"><a id="GUID-ED73E051-3467-4498-8659-01E595F6A272" name="GUID-ED73E051-3467-4498-8659-01E595F6A272"></a><h5 id="LNOCI-GUID-ED73E051-3467-4498-8659-01E595F6A272" class="sect5"><span class="enumeration_section">21.4.2.2</span> OCI_ATTR_NAME</h5>
                     <div>
                        <p>创建函数上下文时，将<code class="codeph">OCI_ATTR_NAME</code>设置<code class="codeph">OCI_ATTR_NAME</code>等于描述非标量列的表达式。
                        </p>
                        <p>然后设置OCI属性以指示表达式的类型。表达式类型取决于它是列对象， <code class="codeph">REF</code>列还是SQL字符串列。
                        </p>
                        <div class="section">
                           <p class="subhead3" id="GUID-ED73E051-3467-4498-8659-01E595F6A272__GUID-422E30D4-7EFD-4306-8AF7-1FAB0FA84AE0">列对象</p>
                        </div>
                        <!-- class="section" -->
                        <div class="section">
                           <p>此必需表达式是对象类型名称。对象类型用作默认对象构造函数。</p>
                           <p>将表达式类型<code class="codeph">OCI_ATTR_DIRPATH_EXPR_TYPE</code>设置为<code class="codeph">OCI_DIRPATH_EXPR_OBJ_CONSTR</code>以指示此表达式是对象类型名称。
                           </p>
                        </div>
                        <!-- class="section" -->
                        <div class="section">
                           <p class="subhead3" id="GUID-ED73E051-3467-4498-8659-01E595F6A272__GUID-DE495BF3-A85C-42FE-AB10-007BC8BE534C">REF专栏</p>
                        </div>
                        <!-- class="section" -->
                        <div class="section">
                           <p>此可选表达式是引用表名称。此表是<code class="codeph">REF</code>列引用行对象的对象表。
                           </p>
                           <p>将表达式类型<code class="codeph">OCI_ATTR_DIRPATH_EXPR_TYPE</code>设置为<code class="codeph">OCI_DIRPATH_EXPR_REF_TBLNAME</code>以指示此表达式是引用对象表。
                           </p>
                           <p>此参数的设置（未设置或未设置）的行为因每种<code class="codeph">REF</code>类型而异。
                           </p>
                           <ul style="list-style-type:disc">
                              <li>
                                 <p>无范围的<code class="codeph">REF</code>列（无范围，基于系统OID）：</p>
                                 <ul style="list-style-type:disc">
                                    <li>
                                       <p>如果未设置，则通过定义“unscoped” <code class="codeph">REF</code>列，此<code class="codeph">REF</code>列必须具有引用表名作为每个数据行的参数。
                                       </p>
                                    </li>
                                    <li>
                                       <p>如果设置，则此<code class="codeph">REF</code>列只能在加载期间引用此指定对象表中的行对象。不允许<code class="codeph">REF</code>列具有引用表名作为其参数。（直接路径API提供此参数作为将加载到未整理的<code class="codeph">REF</code>列的用户的快捷方式，该列在整个加载期间引用相同的引用对象表。）
                                       </p>
                                    </li>
                                 </ul>
                              </li>
                              <li>
                                 <p>Scoped <code class="codeph">REF</code>列（范围，基于系统OID和基于主键）：</p>
                                 <ul style="list-style-type:disc">
                                    <li>
                                       <p>如果未设置，则直接路径API使用架构中指定的引用表。</p>
                                    </li>
                                    <li>
                                       <p>如果设置，则引用表名称必须与此作用域<code class="codeph">REF</code>列的架构中指定的对象表匹配。如果表名不匹配，则会发生错误。
                                       </p>
                                    </li>
                                    <li>
                                       <p>无论是否设置此参数，API对此引用表名称是否在数据行中都无关紧要。如果名称位于数据行中，则它必须与架构中指定的表名匹配。如果它不在数据行中，则API使用模式中定义的引用表。</p>
                                    </li>
                                 </ul>
                              </li>
                           </ul>
                        </div>
                        <!-- class="section" -->
                        <div class="section">
                           <p class="subhead3" id="GUID-ED73E051-3467-4498-8659-01E595F6A272__GUID-E5CCBA4C-3239-4A5C-B0C9-8803D2BF27D1">SQL字符串列</p>
                        </div>
                        <!-- class="section" -->
                        <div class="section">
                           <p>此必需表达式包含一个SQL字符串，用于派生要存储在列中的值。</p>
                           <p>将表达式类型<code class="codeph">OCI_ATTR_DIRPATH_EXPR_TYPE</code>设置为<code class="codeph">OCI_DIRPATH_EXPR_SQL</code>以指示此表达式是SQL字符串。
                           </p>
                        </div>
                        <!-- class="section" -->
                     </div>
                  </div><a id="LNOCI72764"></a><a id="LNOCI16973"></a><div class="props_rev_3"><a id="GUID-3D326302-0366-476F-A6E6-F94F872C7833" name="GUID-3D326302-0366-476F-A6E6-F94F872C7833"></a><h5 id="LNOCI-GUID-3D326302-0366-476F-A6E6-F94F872C7833" class="sect5"><span class="enumeration_section">21.4.2.3</span> OCI_ATTR_DIRPATH_EXPR_TYPE</h5>
                     <div>
                        <p>此属性用于指示<code class="codeph">OCI_ATTR_NAME</code>中<code class="codeph">OCI_ATTR_NAME</code>标量列的函数上下文指定的表达式的类型。
                        </p>
                        <p>如果<code class="codeph">OCI_ATTR_NAME</code>设置，然后<code class="codeph">OCI_ATTR_DIRPATH_EXPR_TYPE</code>是必需的。
                        </p>
                        <p><code class="codeph">OCI_ATTR_DIRPATH_EXPR_TYPE</code>的可能值为：</p>
                        <ul style="list-style-type:disc">
                           <li>
                              <p><code class="codeph">OCI_DIRPATH_EXPR_OBJ_CONSTR</code></p>
                              <ul style="list-style-type:disc">
                                 <li>
                                    <p>指示表达式是对象类型名称，并将用作列对象的默认对象构造函数。</p>
                                 </li>
                                 <li>
                                    <p>列对象是必需的。</p>
                                 </li>
                              </ul>
                           </li>
                           <li>
                              <p><code class="codeph">OCI_DIRPATH_EXPR_REF_TBLNAME</code></p>
                              <ul style="list-style-type:disc">
                                 <li>
                                    <p>表示表达式是引用对象表名。此表是<code class="codeph">REF</code>列引用行对象的对象表。
                                    </p>
                                 </li>
                                 <li>
                                    <p><code class="codeph">REF</code>列是可选的。
                                    </p>
                                 </li>
                              </ul>
                           </li>
                           <li>
                              <p><code class="codeph">OCI_DIRPATH_EXPR_SQL</code></p>
                              <ul style="list-style-type:disc">
                                 <li>
                                    <p>指示表达式是一个SQL字符串，用于派生要存储在列中的值。</p>
                                 </li>
                                 <li>
                                    <p>SQL字符串列是必需的。</p>
                                 </li>
                              </ul>
                           </li>
                        </ul>
                        <p><a href="direct-path-load-interface.html#GUID-3D326302-0366-476F-A6E6-F94F872C7833__CACBHCFG">例21-22</a>显示了说明前面的规则和值的伪代码。
                        </p>
                        <div class="example" id="GUID-3D326302-0366-476F-A6E6-F94F872C7833__CACBHCFG">
                           <p class="titleinexample">示例21-22指定OCI_ATTR_DIRPATH_EXPR_TYPE属性的值</p><pre class="oac_no_warn" dir="ltr">OCIDirPathFuncCtx * dpfnctx;这个非标量列的/ *函数上下文* / ub1 expr_type; / *表达式* /剑错误; if（...）/ *（列类型是对象）* / expr_type = OCI_DIRPATH_EXPR_OBJ_CONSTR; ...if（...）/ *（列类型是REF &amp;&amp;函数上下文名称存在）* / expr_type = OCI_DIRPATH_EXPR_REF_TBLNAME; ...if（...）/ *（列类型是SQL字符串）* / expr_type = OCI_DIRPATH_EXPR_SQL; ...error = OCIAttrSet（（void *）（dpfnctx），OCI_HTYPE_DIRPATH_FN_CTX，（void *）＆expr_type，（ub4）0，OCI_ATTR_DIRPATH_EXPR_TYPE，ctlp-&gt; errhp_ctl）;</pre></div>
                        <!-- class="example" -->
                     </div>
                  </div><a id="LNOCI16974"></a><div class="props_rev_3"><a id="GUID-39F85D35-2B27-4FF3-AE83-828E1090C5D3" name="GUID-39F85D35-2B27-4FF3-AE83-828E1090C5D3"></a><h5 id="LNOCI-GUID-39F85D35-2B27-4FF3-AE83-828E1090C5D3" class="sect5"><span class="enumeration_section">21.4.2.4</span> OCI_ATTR_DIRPATH_NO_INDEX_ERRORS</h5>
                     <div>
                        <p>当<code class="codeph">OCI_ATTR_DIRPATH_NO_INDEX_ERRORS</code>为1时，索引在加载期间的任何时候都不会设置为不可用。
                        </p>
                        <p>如果检测到任何索引错误，则终止加载。也就是说，没有加载任何行，索引保持不变。默认值为0。</p>
                        <div class="infoboxnotealso" id="GUID-39F85D35-2B27-4FF3-AE83-828E1090C5D3__GUID-AFF01947-D645-49F2-8A7E-DA483AA3B98F">
                           <p class="notep1">也可以看看：</p>
                           <p><a href="handle-and-descriptor-attributes.html#GUID-07F0F31C-94FF-4E3B-B8E1-C2394CB94390__BAJGFDEH">OCI_ATTR_DIRPATH_NO_INDEX_ERRORS</a></p>
                        </div>
                     </div>
                  </div><a id="LNOCI72765"></a><a id="LNOCI72766"></a><a id="LNOCI72767"></a><a id="LNOCI16975"></a><div class="props_rev_3"><a id="GUID-286D5D9F-EC97-4013-8EC9-00F3588AD383" name="GUID-286D5D9F-EC97-4013-8EC9-00F3588AD383"></a><h5 id="LNOCI-GUID-286D5D9F-EC97-4013-8EC9-00F3588AD383" class="sect5"><span class="enumeration_section">21.4.2.5</span> OCI_ATTR_NUM_COLS</h5>
                     <div>
                        <p>此属性描述要为非标量列加载或处理的属性或参数的数量。</p>
                        <p>必须先设置此参数，然后才能检索列列表。表达式类型取决于它是列对象，SQL字符串列还是<code class="codeph">REF</code>列。
                        </p>
                        <div class="section">
                           <p class="subhead3" id="GUID-286D5D9F-EC97-4013-8EC9-00F3588AD383__GUID-A0BBA552-C99F-4D43-B098-C3F63446499E">列对象</p>
                        </div>
                        <!-- class="section" -->
                        <div class="section">
                           <p>要为此列对象加载的对象属性列的数量。</p>
                        </div>
                        <!-- class="section" -->
                        <div class="section">
                           <p class="subhead3" id="GUID-286D5D9F-EC97-4013-8EC9-00F3588AD383__GUID-4E16D677-80DF-46D8-85EA-B2F0766119D4">SQL字符串列</p>
                        </div>
                        <!-- class="section" -->
                        <div class="section">
                           <p>要传递给SQL字符串的参数数。</p>
                           <p>如果在函数中多次使用参数，则将其计为一个是正确的。</p>
                        </div>
                        <!-- class="section" -->
                        <div class="section">
                           <p class="subhead3" id="GUID-286D5D9F-EC97-4013-8EC9-00F3588AD383__GUID-F8112AE7-2BED-4F76-B8D7-CB26A61498AC">REF专栏</p>
                        </div>
                        <!-- class="section" -->
                        <div class="section">
                           <p>用于标识<code class="codeph">REF</code>列应指向的行对象的<code class="codeph">REF</code>参数的数量。
                           </p>
                           <p>所需的参数数量因<code class="codeph">REF</code>列类型而异：</p>
                           <ul style="list-style-type:disc">
                              <li>
                                 <p>无范围<code class="codeph">REF</code>列（无范围，基于系统OID的<code class="codeph">REF</code>列）：</p>
                                 <ul style="list-style-type:disc">
                                    <li>
                                       <p>如果使用<code class="codeph">OCI_DIRPATH_EXPR_REF_TBLNAME</code> 。参考表名称为None，OID值为1。（只有OID值在数据行中。）
                                       </p>
                                    </li>
                                    <li>
                                       <p>如果未使用<code class="codeph">OCI_DIRPATH_EXPR_REF_TBLNAME</code> 。一个用于引用表名，一个用于OID值。（引用表名称和OID值都在数据行中。）
                                       </p>
                                    </li>
                                 </ul>
                              </li>
                              <li>
                                 <p>Scoped <code class="codeph">REF</code>列（范围，基于系统OID和基于主键）：</p>
                                 <ul style="list-style-type:disc">
                                    <li>
                                       <p>N或N + 1是可接受的，其中N是构成对象ID的列数，无论是否使用<code class="codeph">OCI_DIRPATH_EXPR_REF_TBLNAME</code> 。如果引用表名称不在数据行中，则最小值为N.如果引用表名称在数据行中，请使用N + 1。
                                       </p>
                                    </li>
                                    <li>
                                       <p>如果<code class="codeph">REF</code>是基于系统OID的，则N为1。如果<code class="codeph">REF</code>是基于主键的，则N是组成主键的组件列的数量。如果引用表名称在数据行中，则将1添加到N.</p>
                                    </li>
                                 </ul>
                                 <div class="infoboxnote" id="GUID-286D5D9F-EC97-4013-8EC9-00F3588AD383__GUID-91896311-B279-47C4-B237-CBFEE3722195">
                                    <p class="notep1">注意：</p>
                                    <p>为了简化错误消息，如果传入一些除N或N + 1以外的<code class="codeph">REF</code>参数，则错误消息表明它在期望N时发现了某某参数的数量。尽管消息中未说明N + 1 ，N + 1是可接受的（即使不需要引用表名称），也不会调用错误消息。
                                    </p>
                                 </div>
                              </li>
                           </ul>
                        </div>
                        <!-- class="section" -->
                     </div>
                  </div><a id="LNOCI16976"></a><div class="props_rev_3"><a id="GUID-3426FD61-9AF7-4F73-8C20-9AF46B98971F" name="GUID-3426FD61-9AF7-4F73-8C20-9AF46B98971F"></a><h5 id="LNOCI-GUID-3426FD61-9AF7-4F73-8C20-9AF46B98971F" class="sect5"><span class="enumeration_section">21.4.2.6</span> OCI_ATTR_NUM_ROWS</h5>
                     <div>
                        <p>当用于<code class="codeph">OCI_HTYPE_DIRPATH_FN_CTX</code> （函数上下文）时，该属性仅可检索，并且不能由用户设置。
                        </p>
                        <p>您只能使用此属性<code class="codeph">OCIAttrGet()</code>而不是<code class="codeph">OCIAttrSet()</code>使用<code class="codeph">OCIAttrGet()</code>调用<code class="codeph">OCIAttrGet()</code> ，将返回到目前为止加载的行数。
                        </p>
                        <p>但是，当用于<code class="codeph">OCI_HTYPE_DIRPATH_CTX</code> （表级上下文）时，属性<code class="codeph">OCI_ATTR_NUM_ROWS</code>可以由用户设置和检索。
                        </p>
                        <p>使用<code class="codeph">OCI_ATTR_NUM_ROWS</code>和<code class="codeph">OCI_HTYPE_DIRPATH_CTX</code>调用<code class="codeph">OCIAttrSet()</code>可设置要为表级列阵列分配的行数。如果未设置，则直接路径API代码基于最大记录大小和传输缓冲区大小导出“合理”数字。要查看已分配的行数，请在<code class="codeph">OCI_HTYPE_DIRPATH_COLUMN_ARRAY</code>上使用<code class="codeph">OCI_ATTR_NUM_ROWS</code>调用<code class="codeph">OCIAttrGet()</code>作为表级列数组，并使用<code class="codeph">OCI_HTYPE_DIRPATH_FN_COL_ARRAY</code>调用函数列数组。
                        </p>
                        <p>使用<code class="codeph">OCI_ATTR_NUM_ROWS</code>和<code class="codeph">OCI_HTYPE_DIRPATH_CTX</code>调用<code class="codeph">OCIAttrGet()</code>将返回到目前为止加载的行数。
                        </p>
                        <p>用户无法为函数上下文设置此属性。不允许通过带有<code class="codeph">OCIAttrSet()</code> <code class="codeph">OCI_ATTR_NUM_ROWS</code>指定函数列数组中所需的行数，因为所有函数列数组的行数与表级列数组的行数相同。因此，只能为表级上下文设置此属性，而不能为函数上下文设置此属性。
                        </p>
                        <div class="infoboxnotealso" id="GUID-3426FD61-9AF7-4F73-8C20-9AF46B98971F__GUID-8BCFB637-3D5E-405D-BEAE-5D4842407789">
                           <p class="notep1">也可以看看：</p>
                           <ul style="list-style-type:disc">
                              <li>
                                 <p><a href="handle-and-descriptor-functions.html#GUID-FA199A99-4D7A-42C2-BB0A-C20047B95DF9" title="获取句柄属性的值。">OCIAttrGet（）</a></p>
                              </li>
                              <li>
                                 <p><a href="handle-and-descriptor-functions.html#GUID-3741D7BD-7652-4D7A-8813-AC2AEA8D3B03" title="设置句柄或描述符的属性值。">OCIAttrSet（）</a></p>
                              </li>
                           </ul>
                        </div>
                     </div>
                  </div>
               </div><a id="LNOCI72768"></a><a id="LNOCI16977"></a><div class="props_rev_3"><a id="GUID-49105A08-EFF7-4FEE-A457-FE6ABB29851E" name="GUID-49105A08-EFF7-4FEE-A457-FE6ABB29851E"></a><h4 id="LNOCI-GUID-49105A08-EFF7-4FEE-A457-FE6ABB29851E" class="sect4"><span class="enumeration_section">21.4.3</span>直接路径列参数属性</h4>
                  <div>
                     <p>描述对象，SQL字符串或<code class="codeph">REF</code>列时，其列属性之一是函数上下文。
                     </p>
                     <p>如果列是对象，则其函数上下文描述其对象类型和对象属性。如果列是SQL字符串，则其函数上下文描述要调用的表达式。如果列是REF，则其函数上下文描述引用表名称和行对象标识符。</p>
                     <p><a href="direct-path-load-interface.html#GUID-49105A08-EFF7-4FEE-A457-FE6ABB29851E__CACGEACB">实施例21-23</a>表明，当设置一个函数上下文作为列属性， <code class="codeph">OCI_ATTR_DIRPATH_FN_CTX</code>在使用<code class="codeph">OCIAttrSet()</code>调用。
                     </p>
                     <p>列参数上下文句柄的属性如下。</p>
                     <div class="example" id="GUID-49105A08-EFF7-4FEE-A457-FE6ABB29851E__CACGEACB">
                        <p class="titleinexample">示例21-23将函数上下文设置为列属性</p><pre class="oac_no_warn" dir="ltr">OCIDirPathFuncCtx * dpfnctx; / *直接路径函数上下文* /剑错误; error = OCIAttrSet（（void *）colDesc，OCI_DTYPE_PARAM，（void *）（dpfnctx），（ub4）0，OCI_ATTR_DIRPATH_FN_CTX，ctlp-&gt; errhp_ctl）;</pre></div>
                     <!-- class="example" -->
                     <div class="section">
                        <div class="p">本节包括以下主题：<ul style="list-style-type:disc">
                              <li>
                                 <p><a href="direct-path-load-interface.html#GUID-E24516A9-6CAB-4524-BEF1-D9A9B5A65CD1" title="以下段落中描述了加载嵌套表，对象表，SQL字符串列和REF列的命名约定。">OCI_ATTR_NAME</a></p>
                              </li>
                              <li>
                                 <p><a href="direct-path-load-interface.html#GUID-57923468-BE53-468B-96B9-7D6568632D74" title="表示列是嵌套表的SETID列。如果加载到嵌套表，则为必需。">OCI_ATTR_DIRPATH_SID</a></p>
                              </li>
                              <li>
                                 <p><a href="direct-path-load-interface.html#GUID-80ACA14B-1493-4A87-9ACE-D33975DCD68A" title="表示列是对象表的对象ID列。">OCI_ATTR_DIRPATH_OID</a></p>
                              </li>
                           </ul>
                           <div class="infoboxnotealso" id="GUID-49105A08-EFF7-4FEE-A457-FE6ABB29851E__GUID-766E3390-405D-4C8C-A7DB-CC2AEA65465B">
                              <p class="notep1">也可以看看：</p>
                              <ul style="list-style-type:disc">
                                 <li>
                                    <p><a href="handle-and-descriptor-attributes.html#GUID-CAC89BC1-BB9A-4E49-A473-81AE0538DD8D" title="描述如何使用直接路径列参数属性。">直接路径列参数属性</a></p>
                                 </li>
                                 <li>
                                    <p><a href="handle-and-descriptor-functions.html#GUID-3741D7BD-7652-4D7A-8813-AC2AEA8D3B03" title="设置句柄或描述符的属性值。">OCIAttrSet（）</a></p>
                                 </li>
                              </ul>
                              <p></p>
                           </div>
                        </div>
                     </div>
                     <!-- class="section" -->
                  </div><a id="LNOCI16978"></a><div class="props_rev_3"><a id="GUID-E24516A9-6CAB-4524-BEF1-D9A9B5A65CD1" name="GUID-E24516A9-6CAB-4524-BEF1-D9A9B5A65CD1"></a><h5 id="LNOCI-GUID-E24516A9-6CAB-4524-BEF1-D9A9B5A65CD1" class="sect5"><span class="enumeration_section">21.4.3.1</span> OCI_ATTR_NAME</h5>
                     <div>
                        <p>以下段落中描述了加载嵌套表，对象表，SQL字符串列和<code class="codeph">REF</code>列的命名约定。
                        </p>
                        <p>通常，如果要将数据加载到具有您不知道的系统名称的系统列的列中，则使用虚拟列名称（例如，对象表的系统生成的对象ID（ <code class="codeph">OID</code> ）列或嵌套表的<code class="codeph">SETID</code> （ <code class="codeph">SID</code> ）列）或者列是不具有数据库表列的参数（例如，SQL字符串和<code class="codeph">REF</code>参数）。
                        </p>
                        <p>如果列是数据库表列但使用了虚拟名称，则必须设置列属性，以便该函数可以识别该列，即使它不在数据库已知的名称下。</p>
                        <p>命名规则如下：</p>
                        <ul style="list-style-type:disc">
                           <li>
                              <p>子嵌套表的<code class="codeph">SETID</code> （ <code class="codeph">SID</code> ）列</p>
                              <p>SETID列是必需的。使用虚拟名称设置其<code class="codeph">OCI_ATTR_NAME</code> ，因为API不希望用户知道其系统名称。然后使用<code class="codeph">OCI_ATTR_DIRPATH_SID</code>设置column属性以指示这是一个<code class="codeph">SID</code>列。
                              </p>
                           </li>
                           <li>
                              <p>对象表的对象ID（ <code class="codeph">OID</code> ）列</p>
                              <p>在以下情况下需要对象ID：</p>
                              <ol>
                                 <li>
                                    <p>对象ID是系统生成的：</p>
                                    <p>使用虚拟名称作为其列名称（例如，“cust_oid”）。</p>
                                    <p>使用<code class="codeph">OCI_ATTR_DIRPATH_OID</code>设置其列属性。因此，如果您有多个具有虚拟名称的列，您就知道哪一列代表系统生成的<code class="codeph">OID</code> 。</p>
                                 </li>
                                 <li>
                                    <p>对象id是基于主键的：</p>
                                    <p>您不能使用虚拟名称作为其列名。因此，您不需要使用<code class="codeph">OCI_ATTR_DIRPATH_OID</code>设置其列属性。</p>
                                 </li>
                              </ol>
                           </li>
                           <li>
                              <p>SQL字符串参数</p>
                              <ol>
                                 <li>
                                    <p>使用<code class="codeph">OCI_ATTR_NAME</code>设置属性的列名称。</p>
                                 </li>
                                 <li>
                                    <p>给定的SQL字符串参数的顺序无关紧要。该顺序不必与SQL字符串中使用的顺序匹配。</p>
                                 </li>
                                 <li>
                                    <p>使用SQL字符串参数的命名约定。</p>
                                    <ul style="list-style-type:disc">
                                       <li>
                                          <p>参数名称必须与内容中SQL字符串中使用的绑定变量名称匹配，但不是大小写。例如，如果SQL字符串是<code class="codeph">substr(:INPUT_STRING, 3, 5)</code> ，那么您可以将参数名称指定为“input_string”。
                                          </p>
                                       </li>
                                       <li>
                                          <p>如果在SQL字符串中多次使用参数，则可以将其声明一次并将其计为仅一个参数。</p>
                                       </li>
                                    </ul>
                                 </li>
                              </ol>
                           </li>
                           <li>
                              <p><code class="codeph">REF</code>论点</p>
                              <ol>
                                 <li>
                                    <p>使用<code class="codeph">OCI_ATTR_NAME</code>设置属性的列名称。</p>
                                    <p><code class="codeph">REF</code>参数的顺序很重要。
                                    </p>
                                    <ul style="list-style-type:disc">
                                       <li>
                                          <p>如果给出，则首先引用参考表名称。</p>
                                       </li>
                                       <li>
                                          <p>接下来是对象ID，无论是系统生成的还是基于主键的。</p>
                                       </li>
                                    </ul>
                                 </li>
                                 <li>
                                    <p>使用<code class="codeph">REF</code>参数的命名约定。
                                    </p>
                                    <ul style="list-style-type:disc">
                                       <li>
                                          <p>对于引用表名称参数，请为其列名使用任何虚拟名称，例如“ref-tbl”。</p>
                                       </li>
                                       <li>
                                          <p>对于系统生成的OID参数，请为其列名使用任何虚拟名称，例如“sys-OID”。注意：由于此列用作参数而不是要加载的列，因此请勿使用<code class="codeph">OCI_ATTR_DIRPATH_OID</code>设置此列。</p>
                                       </li>
                                       <li>
                                          <p>对于基于主键的对象ID，列出要加载的所有主键列。无需为OID创建虚拟名称。组件列名称（如果给出（稍后参见快捷方式步骤））可以按任何顺序给出。</p>
                                       </li>
                                    </ul>
                                 </li>
                                 <li>
                                    <p>不要为对象ID设置属性列名以使用快捷方式。</p>
                                    <ul style="list-style-type:disc">
                                       <li>
                                          <p><span class="bold">捷径。</span> 如果加载基于system-OID的<code class="codeph">REF</code>列，请不要使用名称设置列名。API计算出来了。但您仍必须设置其他列属性，例如外部数据类型。
                                          </p>
                                       </li>
                                       <li>
                                          <p>如果加载主键<code class="codeph">REF</code>列并且其主键由多列组成，则快捷方式不是设置其列名。但是，您必须设置其他列属性，例如外部数据类型。
                                          </p>
                                          <div class="infoboxnote" id="GUID-E24516A9-6CAB-4524-BEF1-D9A9B5A65CD1__GUID-0B775A89-551A-4231-AB40-F993A6EBEE15">
                                             <p class="notep1">注意：</p>
                                             <p>如果组件列名称为NULL，则API代码确定在为主键定义它们的位置或顺序中的列名称。因此，在设置名称以外的列属性时，请确保以正确的顺序为组件列设置属性。</p>
                                          </div>
                                       </li>
                                    </ul>
                                 </li>
                              </ol>
                           </li>
                        </ul>
                     </div>
                  </div><a id="LNOCI16979"></a><div class="props_rev_3"><a id="GUID-57923468-BE53-468B-96B9-7D6568632D74" name="GUID-57923468-BE53-468B-96B9-7D6568632D74"></a><h5 id="LNOCI-GUID-57923468-BE53-468B-96B9-7D6568632D74" class="sect5"><span class="enumeration_section">21.4.3.2</span> OCI_ATTR_DIRPATH_SID</h5>
                     <div>
                        <p>表示列是嵌套表的<code class="codeph">SETID</code>列。如果加载到嵌套表，则为必需。
                        </p><pre class="oac_no_warn" dir="ltr">ub1 flg = 1;剑错误; error = OCIAttrSet（（void *）colDesc，OCI_DTYPE_PARAM，（void *）＆flg，（ub4）0，OCI_ATTR_DIRPATH_SID，ctlp-&gt; errhp_ctl）;</pre></div>
                  </div><a id="LNOCI16980"></a><div class="props_rev_3"><a id="GUID-80ACA14B-1493-4A87-9ACE-D33975DCD68A" name="GUID-80ACA14B-1493-4A87-9ACE-D33975DCD68A"></a><h5 id="LNOCI-GUID-80ACA14B-1493-4A87-9ACE-D33975DCD68A" class="sect5"><span class="enumeration_section">21.4.3.3</span> OCI_ATTR_DIRPATH_OID</h5>
                     <div>
                        <p>表示列是对象表的对象ID列。</p><pre class="oac_no_warn" dir="ltr">ub1 flg = 1;剑错误; error = OCIAttrSet（（void *）colDesc，OCI_DTYPE_PARAM，（void *）＆flg，（ub4）0，OCI_ATTR_DIRPATH_OID，ctlp-&gt; errhp_ctl）;</pre></div>
                  </div>
               </div><a id="LNOCI72769"></a><a id="LNOCI16981"></a><div class="props_rev_3"><a id="GUID-56DA52A3-8A3B-496F-8267-D6EF4C5427B1" name="GUID-56DA52A3-8A3B-496F-8267-D6EF4C5427B1"></a><h4 id="LNOCI-GUID-56DA52A3-8A3B-496F-8267-D6EF4C5427B1" class="sect4"><span class="enumeration_section">21.4.4非</span>标量列的直接路径功能列数组句柄</h4>
                  <div>
                     <p>如果列是对象，SQL字符串或<code class="codeph">REF</code> ，则使用句柄类型<code class="codeph">OCI_HTYPE_DIRPATH_FN_COL_ARRAY</code> 。</p>
                     <p>对于标量和非标量列，结构<code class="codeph">OCIDirPathColArray</code>是相同的。
                     </p>
                     <p><a href="direct-path-load-interface.html#GUID-56DA52A3-8A3B-496F-8267-D6EF4C5427B1__CACCHAJG">例21-24</a>显示了如何为函数上下文分配子列数组。
                     </p>
                     <div class="example" id="GUID-56DA52A3-8A3B-496F-8267-D6EF4C5427B1__CACCHAJG">
                        <p class="titleinexample">示例21-24为函数上下文分配子列数组</p><pre class="oac_no_warn" dir="ltr">OCIDirPathFuncCtx * dpfnctx; / *直接路径函数上下文* / OCIDirPathColArray * dpfnca; / *直接路径函数列数组* /剑错误; error = OCIHandleAlloc（（void *）dpfnctx，（void **）＆dpfnca，OCI_HTYPE_DIRPATH_FN_COL_ARRAY，（size_t）0，（void **）0）;</pre></div>
                     <!-- class="example" -->
                     <div class="section">
                        <p>本节包括以下主题： <a href="direct-path-load-interface.html#GUID-5101FEF3-48EE-4C5C-9870-1E8BAFE997CF" title="当用于OCI_HTYPE_DIRPATH_FN_COL_ARRAY（函数列数组）时，此属性仅可检索，并且不能由用户设置。">OCI_ATTR_NUM_ROWS属性</a> 。
                        </p>
                        <div class="infoboxnotealso" id="GUID-56DA52A3-8A3B-496F-8267-D6EF4C5427B1__GUID-26E46B88-AB9B-4EC6-8E3D-2CDECAE94EF3">
                           <p class="notep1">也可以看看：</p>
                           <p><a href="handle-and-descriptor-attributes.html#GUID-1AA176F1-DD77-4DB8-8619-6DBE84D05FA1" title="列出并描述直接路径函数列数组句柄（OCIDirPathColArray）属性。">直接路径函数列数组句柄（OCIDirPathColArray）属性</a></p>
                        </div>
                     </div>
                     <!-- class="section" -->
                  </div><a id="LNOCI16982"></a><div class="props_rev_3"><a id="GUID-5101FEF3-48EE-4C5C-9870-1E8BAFE997CF" name="GUID-5101FEF3-48EE-4C5C-9870-1E8BAFE997CF"></a><h5 id="LNOCI-GUID-5101FEF3-48EE-4C5C-9870-1E8BAFE997CF" class="sect5"><span class="enumeration_section">21.4.4.1</span> OCI_ATTR_NUM_ROWS属性</h5>
                     <div>
                        <p>当用于<code class="codeph">OCI_HTYPE_DIRPATH_FN_COL_ARRAY</code> （函数列数组）时，此属性仅可检索，并且不能由用户设置。
                        </p>
                        <p>使用函数<code class="codeph">OCIAttrGet()</code>调用<code class="codeph">OCI_ATTR_NUM_ROWS</code>属性时，将返回为函数列数组分配的行数。
                        </p>
                        <div class="infoboxnotealso" id="GUID-5101FEF3-48EE-4C5C-9870-1E8BAFE997CF__GUID-D9E511B1-D396-4621-9B27-432A556E2DCE">
                           <p class="notep1">也可以看看：</p>
                           <p><a href="handle-and-descriptor-functions.html#GUID-FA199A99-4D7A-42C2-BB0A-C20047B95DF9" title="获取句柄属性的值。">OCIAttrGet（）</a></p>
                        </div>
                     </div>
                  </div>
               </div>
            </div>
         </div>
      </article>
   </body>
</html>