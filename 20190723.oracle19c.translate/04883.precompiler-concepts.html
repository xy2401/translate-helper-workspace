<html lang="en-us" dir="ltr" xml:lang="en-us">
   <head>
      <meta http-equiv="Content-Type" content="text/html; charset=utf-8"></meta>
      <meta name="viewport" content="width=device-width, initial-scale=1"></meta>
      <meta http-equiv="X-UA-Compatible" content="IE=edge"></meta>
      <title>预编译器概念</title>
      <meta property="og:site_name" content="Oracle Help Center"></meta>
      <meta property="og:title" content="Programmer&#39;s Guide"></meta>
      <meta property="og:description" content=""></meta>
      <link rel="stylesheet" href="/sp_common/book-template/ohc-book-template/css/book.css"></link>
      <link rel="shortcut icon" href="/sp_common/book-template/ohc-common/img/favicon.ico"></link>
      <meta name="application-name" content="Programmer&#39;s Guide"></meta>
      <meta name="generator" content="DITA Open Toolkit version 1.8.5 (Mode = doc)"></meta>
      <meta name="plugin" content="SP_docbuilder HTML plugin release 18.2.2"></meta>
      <link rel="alternate" href="cobol-programmers-guide.pdf" title="PDF File" type="application/pdf"></link>
      <meta name="robots" content="all"></meta>
      <link rel="schema.dcterms" href="http://purl.org/dc/terms/"></link>
      <meta name="dcterms.created" content="2019-01-11T02:40:40-08:00"></meta>
      
      <meta name="dcterms.dateCopyrighted" content="1996, 2019"></meta>
      <meta name="dcterms.category" content="database"></meta>
      <meta name="dcterms.identifier" content="E96466-01"></meta>
      
      <meta name="dcterms.product" content="en/database/oracle/oracle-database/19"></meta>
      
      <link rel="prev" href="introduction.html" title="Previous" type="text/html"></link>
      <link rel="next" href="database-concepts.html" title="Next" type="text/html"></link>
      <script>
        document.write('<style type="text/css">');
        document.write('body > .noscript, body > .noscript ~ * { visibility: hidden; }');
        document.write('</style>');
     </script>
      <script src="/sp_common/book-template/requirejs/require.js" data-main="/sp_common/book-template/ohc-book-template/js/book-config"></script>
      <script>
            if (window.require === undefined) {
                document.write('<script data-main="sp_common/book-template/ohc-book-template/js/book-config" src="sp_common/book-template/requirejs/require.js"><\/script>');
                document.write('<link href="sp_common/book-template/ohc-book-template/css/book.css" rel="stylesheet"/>');
            }
        </script>
      <script type="application/json" id="ssot-metadata">{"primary":{"category":{"short_name":"database","element_name":"Database","display_in_url":true},"suite":{"short_name":"oracle","element_name":"Oracle","display_in_url":true},"product_group":{"short_name":"not-applicable","element_name":"Not applicable","display_in_url":false},"product":{"short_name":"oracle-database","element_name":"Oracle Database","display_in_url":true},"release":{"short_name":"19","element_name":"Release 19","display_in_url":true}}}</script>
      
    <meta name="dcterms.title" content="Pro*COBOL Programmer&#39;s Guide"></meta>
    <meta name="dcterms.isVersionOf" content="LNPCB"></meta>
    <meta name="dcterms.release" content="Release 19"></meta>
  </head>
   <body dir="ltr">
      <div class="noscript alert alert-danger text-center" role="alert">
         <a href="introduction.html" class="pull-left"><span class="glyphicon glyphicon-chevron-left" aria-hidden="true"></span>上一页</a> <a href="database-concepts.html" class="pull-right">下一页<span class="glyphicon glyphicon-chevron-right" aria-hidden="true"></span></a> <span class="fa fa-exclamation-triangle" aria-hidden="true"></span>必须启用JavaScript才能正确显示此内容</div>
      <article>
         <header>
            <ol class="breadcrumb" vocab="http://schema.org/" typeof="BreadcrumbList">
               <li property="itemListElement" typeof="ListItem"><a href="index.html" property="item" typeof="WebPage"><span property="name">程序员指南</span></a></li>
               <li property="itemListElement" typeof="ListItem"><a href="introduction-and-concepts.html" property="item" typeof="WebPage"><span property="name">介绍和概念</span></a></li>
               <li class="active" property="itemListElement" typeof="ListItem">预编译器概念</li>
            </ol>
            <a id="GUID-40982C2F-0B4A-4E5D-AEC0-A2D2CA68F61D" name="GUID-40982C2F-0B4A-4E5D-AEC0-A2D2CA68F61D"></a><a id="LNPCB002"></a>
            
            <h2 id="LNPCB-GUID-40982C2F-0B4A-4E5D-AEC0-A2D2CA68F61D" class="sect2"><span class="enumeration_chapter">2</span>预编译器概念</h2>
         </header>
         <div class="ind">
            <div>
               <p>本章介绍嵌入式SQL程序如何完成其工作。它介绍了重要单词的定义，基本概念的解释和关键规则。</p>
               <p>涉及的主题是：</p>
               <ul style="list-style-type:disc">
                  <li>
                     <p><a href="precompiler-concepts.html#GUID-C3A40993-6580-401F-AD24-CBFEEF283FF8">嵌入式SQL编程的关键概念</a></p>
                  </li>
                  <li>
                     <p><a href="precompiler-concepts.html#GUID-B4B12E18-2BD0-49A3-917C-0C9567236BC3">编程指南</a></p>
                  </li>
                  <li>
                     <p><a href="precompiler-concepts.html#GUID-C01E658A-1EAE-4497-82DB-347217694E78">申报部分</a></p>
                  </li>
                  <li>
                     <p><a href="precompiler-concepts.html#GUID-A0BFB23E-4234-409F-906A-3185E866F7BC">嵌套程序</a></p>
                  </li>
                  <li>
                     <p><a href="precompiler-concepts.html#GUID-945BCD1F-E820-4AF1-BCAD-1C09DEBA2BB0">条件预编译</a></p>
                  </li>
                  <li>
                     <p><a href="precompiler-concepts.html#GUID-5BBB2EA7-C46D-4D4F-B9BB-77668B2D9153">单独的预编译</a></p>
                  </li>
                  <li>
                     <p><a href="precompiler-concepts.html#GUID-E1191EB4-BD6B-4EB7-B20E-51C92F86AEDC">编译和链接</a></p>
                  </li>
                  <li>
                     <p><a href="precompiler-concepts.html#GUID-1BA76AA5-1C9E-45FA-88BE-B6A5BF0DA5BA">样本DEPT和EMP表</a></p>
                  </li>
                  <li>
                     <p><a href="precompiler-concepts.html#GUID-6BDE80F2-4970-4D3B-9AE5-CCA82ADE333D">样本EMP计划：SAMPLE1。PCO</a></p>
                  </li>
               </ul>
            </div><a id="LNPCB126"></a><div class="props_rev_3"><a id="GUID-C3A40993-6580-401F-AD24-CBFEEF283FF8" name="GUID-C3A40993-6580-401F-AD24-CBFEEF283FF8"></a><h3 id="LNPCB-GUID-C3A40993-6580-401F-AD24-CBFEEF283FF8" class="sect3"><span class="enumeration_section">2.1</span>嵌入式SQL编程的关键概念</h3>
               <div>
                  <p>本节为后面的章节构建了概念基础。<a id="d7799e94" class="indexterm-anchor"></a></p>
               </div><a id="LNPCB128"></a><a id="LNPCB127"></a><div class="props_rev_3"><a id="GUID-E7AE6605-2B20-49C4-90C6-173567C42869" name="GUID-E7AE6605-2B20-49C4-90C6-173567C42869"></a><h4 id="LNPCB-GUID-E7AE6605-2B20-49C4-90C6-173567C42869" class="sect4"><span class="enumeration_section">2.1.1</span>开发嵌入式SQL应用程序的步骤</h4>
                  <div>
                     <p>预编译会生成可以正常编译的源文件。虽然预编译为传统开发过程增加了一个步骤，但这一步非常值得，因为它可以让您编写非常灵活的应用程序。</p>
                     <p><a href="precompiler-concepts.html#GUID-E7AE6605-2B20-49C4-90C6-173567C42869__I6767">图2-1</a>引导您完成嵌入式SQL应用程序开发过程：</p>
                     <div class="figure" id="GUID-E7AE6605-2B20-49C4-90C6-173567C42869__I6767">
                        <p class="titleinfigure">图2-1应用程序开发过程</p><img src="img/pco81050.gif" alt="下面描述图2-1" title="下面描述图2-1" longdesc="img_text/pco81050.html"><br><a href="img_text/pco81050.html">“图2-1应用程序开发过程”的描述</a></div>
                     <!-- class="figure" -->
                  </div>
               </div><a id="LNPCB129"></a><div class="props_rev_3"><a id="GUID-1623C2A5-FBDE-4C41-99F3-221BBA802013" name="GUID-1623C2A5-FBDE-4C41-99F3-221BBA802013"></a><h4 id="LNPCB-GUID-1623C2A5-FBDE-4C41-99F3-221BBA802013" class="sect4"><span class="enumeration_section">2.1.2</span>嵌入式SQL语句</h4>
                  <div>
                     <p>术语<span class="italic">嵌入式SQL</span>是指放置在应用程序中的SQL语句。因为应用程序包含SQL语句，所以它被称为<span class="italic">宿主程序</span> ，其编写<span class="italic">语言</span>称为<span class="italic">宿主语言</span> 。例如，使用Pro * COBOL，您可以在COBOL主机程序中嵌入SQL语句。 <a id="d7799e168" class="indexterm-anchor"></a><a id="d7799e170" class="indexterm-anchor"></a> 
                     </p>
                     <p>要操作和查询Oracle数据，请使用INSERT，UPDATE，DELETE和SELECT语句。INSERT向数据库表添加数据行，UPDATE修改行，DELETE删除不需要的行，SELECT检索符合搜索条件的行。</p>
                     <p>只有SQL语句 - 而不是SQL * Plus语句 - 在应用程序中才有效。（SQL * Plus具有用于设置环境参数，编辑和报告格式的其他语句。）</p>
                  </div><a id="LNPCB131"></a><a id="LNPCB130"></a><div class="props_rev_3"><a id="GUID-316C1C40-749B-4185-BEE1-AB55C10A4331" name="GUID-316C1C40-749B-4185-BEE1-AB55C10A4331"></a><h5 id="LNPCB-GUID-316C1C40-749B-4185-BEE1-AB55C10A4331" class="sect5"><span class="enumeration_section">2.1.2.1</span>可执行语句与声明语句</h5>
                     <div>
                        <p>嵌入式SQL包括所有交互式SQL语句以及允许您在Oracle和宿主程序之间传输数据的其他语句。嵌入式SQL语句有两种类型： <span class="italic">可执行语句</span>和<span class="italic">指令</span> 。
                        </p>
                        <p>可执行SQL语句生成对数据库的调用。它们包括几乎所有查询，数据操作语言（DML），数据定义语言（DDL）和数据控制语言（DCL）语句。</p>
                        <p>另一方面， <span class="italic">指令</span>不会导致对SQLLIB的调用，也不会对Oracle数据进行操作。
                        </p>
                        <p><a id="d7799e215" class="indexterm-anchor"></a><a id="d7799e219" class="indexterm-anchor"></a>您可以使用指令声明Oracle对象，通信区域和SQL变量。它们可以放在可以放置COBOL声明的任何位置。 <a id="d7799e224" class="indexterm-anchor"></a> 
                        </p>
                        <p><a href="precompiler-concepts.html#GUID-316C1C40-749B-4185-BEE1-AB55C10A4331__G14502" title="该表列出了指令及其用途">表2-1</a>列出了嵌入式SQL语句的一些示例（不是完整列表。）
                        </p>
                        <div class="tblformal" id="GUID-316C1C40-749B-4185-BEE1-AB55C10A4331__G14502">
                           <p class="titleintable">表2-1嵌入式SQL语句 - 指令</p>
                           <table cellpadding="4" cellspacing="0" class="Formal" title="嵌入式SQL语句 - 指令" width="100%" border="1" summary="This table lists directives and their purposes" frame="hsides" rules="rows">
                              <thead>
                                 <tr align="left" valign="top">
                                    <th align="left" valign="bottom" width="31%" id="d7799e243">声明</th>
                                    <th align="left" valign="bottom" width="69%" id="d7799e247">目的</th>
                                 </tr>
                              </thead>
                              <tbody>
                                 <tr align="left" valign="top">
                                    <td align="left" valign="top" width="31%" id="d7799e253" headers="d7799e243 ">
                                       <p>ARRAYLEN *</p>
                                    </td>
                                    <td align="left" valign="top" width="69%" headers="d7799e253 d7799e247 ">
                                       <p>将主机表与PL / SQL一起使用</p>
                                    </td>
                                 </tr>
                                 <tr align="left" valign="top">
                                    <td align="left" valign="top" width="31%" id="d7799e260" headers="d7799e243 ">
                                       <p>开始声明部分*</p>
                                       <p>END DECLARE SECTION *</p>
                                    </td>
                                    <td align="left" valign="top" width="69%" headers="d7799e260 d7799e247 ">
                                       <p>声明宿主变量</p>
                                    </td>
                                 </tr>
                                 <tr align="left" valign="top">
                                    <td align="left" valign="top" width="31%" id="d7799e269" headers="d7799e243 ">
                                       <p>宣布*</p>
                                    </td>
                                    <td align="left" valign="top" width="69%" headers="d7799e269 d7799e247 ">
                                       <p>命名Oracle对象</p>
                                    </td>
                                 </tr>
                                 <tr align="left" valign="top">
                                    <td align="left" valign="top" width="31%" id="d7799e276" headers="d7799e243 ">
                                       <p>包括*</p>
                                    </td>
                                    <td align="left" valign="top" width="69%" headers="d7799e276 d7799e247 ">
                                       <p>复制文件</p>
                                    </td>
                                 </tr>
                                 <tr align="left" valign="top">
                                    <td align="left" valign="top" width="31%" id="d7799e283" headers="d7799e243 ">
                                       <p>VAR *</p>
                                    </td>
                                    <td align="left" valign="top" width="69%" headers="d7799e283 d7799e247 ">
                                       <p>对等价变量</p>
                                    </td>
                                 </tr>
                                 <tr align="left" valign="top">
                                    <td align="left" valign="top" width="31%" id="d7799e290" headers="d7799e243 ">
                                       <p>每当*</p>
                                    </td>
                                    <td align="left" valign="top" width="69%" headers="d7799e290 d7799e247 ">
                                       <p>处理运行时错误</p>
                                    </td>
                                 </tr>
                              </tbody>
                           </table>
                        </div>
                        <!-- class="inftblhruleinformal" -->
                        <div class="tblformal" id="GUID-316C1C40-749B-4185-BEE1-AB55C10A4331__EMBEDDEDSQLSTATEMENTSEXECUTABLESQL-040CB223">
                           <p class="titleintable">表2-2嵌入式SQL语句 - 可执行SQL</p>
                           <table cellpadding="4" cellspacing="0" class="Formal" title="嵌入式SQL语句 - 可执行SQL" width="100%" border="1" summary="This table lists executable SQL statements and their purposes" frame="hsides" rules="rows">
                              <thead>
                                 <tr align="left" valign="top">
                                    <th align="left" valign="bottom" width="20%" id="d7799e306">声明</th>
                                    <th align="left" valign="bottom" width="20%" id="d7799e309">目的</th>
                                 </tr>
                              </thead>
                              <tbody>
                                 <tr align="left" valign="top">
                                    <td align="left" valign="top" width="20%" id="d7799e314" headers="d7799e306 ">
                                       <p>分配*</p>
                                       <p>改变</p>
                                       <p>CONNECT *</p>
                                       <p>创建</p>
                                       <p>下降</p>
                                       <p>GRANT</p>
                                       <p>NOAUDIT</p>
                                       <p>改名</p>
                                       <p>撤消</p>
                                       <p>截短</p>
                                    </td>
                                    <td align="left" valign="top" width="20%" headers="d7799e314 d7799e309 ">
                                       <p>定义和控制Oracle数据</p>
                                    </td>
                                 </tr>
                                 <tr align="left" valign="top">
                                    <td align="left" valign="top" width="20%" id="d7799e339" headers="d7799e306 ">
                                       <p>关*</p>
                                       <p>删除</p>
                                       <p>解释计划</p>
                                       <p>取*</p>
                                       <p>插入</p>
                                       <p>锁表</p>
                                       <p>打开*</p>
                                       <p>选择</p>
                                       <p>UPDATE</p>
                                    </td>
                                    <td align="left" valign="top" width="20%" headers="d7799e339 d7799e309 ">
                                       <p>查询和操作Oracle数据</p>
                                    </td>
                                 </tr>
                                 <tr align="left" valign="top">
                                    <td align="left" valign="top" width="20%" id="d7799e362" headers="d7799e306 ">
                                       <p>承诺</p>
                                       <p>ROLLBACK</p>
                                       <p>SAVEPOINT</p>
                                       <p>设置交易</p>
                                    </td>
                                    <td align="left" valign="top" width="20%" headers="d7799e362 d7799e309 ">
                                       <p>处理交易</p>
                                    </td>
                                 </tr>
                                 <tr align="left" valign="top">
                                    <td align="left" valign="top" width="20%" id="d7799e375" headers="d7799e306 ">
                                       <p>描述*</p>
                                       <p>执行*</p>
                                       <p>准备*</p>
                                    </td>
                                    <td align="left" valign="top" width="20%" headers="d7799e375 d7799e309 ">
                                       <p>要使用动态SQL</p>
                                    </td>
                                 </tr>
                                 <tr align="left" valign="top">
                                    <td align="left" valign="top" width="20%" id="d7799e386" headers="d7799e306 ">
                                       <p>改变会话</p>
                                       <p>设置角色</p>
                                    </td>
                                    <td align="left" valign="top" width="20%" headers="d7799e386 d7799e309 ">
                                       <p>控制会话</p>
                                    </td>
                                 </tr>
                              </tbody>
                           </table>
                        </div>
                        <!-- class="inftblhruleinformal" -->
                        <p>*没有互动对手</p>
                        <div class="infoboxnotealso" id="GUID-316C1C40-749B-4185-BEE1-AB55C10A4331__GUID-285354C6-E895-4238-A0CC-563F33B25C43">
                           <p class="notep1">也可以看看：</p><a href="embedded-SQL-statements-and-precompiler-directives.html#GUID-F5251483-48EC-4B39-8E14-68F65480B16B">嵌入式SQL语句和预编译器指令</a>包含最重要的语句和指令的表示。
                        </div>
                     </div>
                  </div>
               </div><a id="LNPCB135"></a><div class="props_rev_3"><a id="GUID-6084A626-F5CE-4862-90CA-A7603E1E18CE" name="GUID-6084A626-F5CE-4862-90CA-A7603E1E18CE"></a><h4 id="LNPCB-GUID-6084A626-F5CE-4862-90CA-A7603E1E18CE" class="sect4"><span class="enumeration_section">2.1.3</span>嵌入式SQL语法</h4>
                  <div>
                     <p>在应用程序中，您可以自由地将SQL语句与主机语言语句混合，并在SQL语句中使用主机语言变量。将SQL语句构建到宿主程序中的唯一特殊要求是，您可以使用EXEC SQL开头，并以令牌END-EXEC结束它们。 Pro * COBOL将所有可执行的EXEC SQL语句转换为对运行时库SQLLIB的调用。 <a id="d7799e426" class="indexterm-anchor"></a><a id="d7799e430" class="indexterm-anchor"></a><a id="d7799e434" class="indexterm-anchor"></a><a id="d7799e436" class="indexterm-anchor"></a> 
                     </p>
                     <p>大多数嵌入式SQL语句与其交互式对应语句的区别仅在于添加了新子句或使用了程序变量。比较以下交互式和嵌入式ROLLBACK语句： <a id="d7799e441" class="indexterm-anchor"></a> 
                     </p><pre class="oac_no_warn" dir="ltr">ROLLBACK WORK; - 交互式*嵌入式EXEC SQL ROLLBACK WORK END-EXEC。</pre><p>句点或任何其他终止符可以遵循SQL语句。允许以下任一情况：</p><pre class="oac_no_warn" dir="ltr">执行SQL ...END-EXEC，EXEC SQL ......END-EXEC。</pre></div>
               </div><a id="LNPCB136"></a><div class="props_rev_3"><a id="GUID-D0456446-014D-4569-AD48-BCCB0E54169A" name="GUID-D0456446-014D-4569-AD48-BCCB0E54169A"></a><h4 id="LNPCB-GUID-D0456446-014D-4569-AD48-BCCB0E54169A" class="sect4"><span class="enumeration_section">2.1.4</span>静态与动态SQL语句</h4>
                  <div>
                     <p>大多数应用程序旨在处理<span class="italic">静态</span> SQL <span class="italic"> </span>报表和固定交易。在这种情况下，您知道运行时之前每个SQL语句和事务的组成。也就是说，您知道将发出哪些SQL命令，哪些数据库表可能会更改，哪些列将更新，等等。 <a id="d7799e482" class="indexterm-anchor"></a><a id="d7799e486" class="indexterm-anchor"></a> 
                     </p>
                     <p>但是，某些应用程序需要在运行时接受和处理任何有效的SQL语句。在这种情况下，您可能直到运行时才知道所涉及的所有SQL命令，数据库表和列。</p>
                     <p><span class="italic">动态</span> SQL是一种高级编程技术，它允许程序在运行时接受或构建SQL语句，并对数据类型转换进行显式控制。
                     </p>
                  </div>
                  <div>
                     <div class="relinfo">
                        <p><strong>相关话题</strong></p>
                        <ul>
                           <li><a href="embedded-SQL.html#GUID-D41B0E04-08A5-4BDF-82DF-B39841C0B7BC">嵌入式SQL</a></li>
                           <li><a href="Oracle-dynamic-SQL.html#GUID-C325218F-3DFF-4551-A5EB-483ADB24E324">Oracle动态SQL</a></li>
                           <li><a href="ANSI-dynamic-SQL.html#GUID-D6E9ACBE-EFF4-42F6-A855-B510004F4164">ANSI动态SQL</a></li>
                           <li><a href="Oracle-dynamic-SQL-method-4.html#GUID-C6256169-5928-466C-B7C7-960D20705EED">Oracle动态SQL：方法4</a></li>
                        </ul>
                     </div>
                  </div>
               </div><a id="LNPCB137"></a><div class="props_rev_3"><a id="GUID-743ED7AF-E1FB-4570-9309-448E462C511A" name="GUID-743ED7AF-E1FB-4570-9309-448E462C511A"></a><h4 id="LNPCB-GUID-743ED7AF-E1FB-4570-9309-448E462C511A" class="sect4"><span class="enumeration_section">2.1.5</span>嵌入式PL / SQL块</h4>
                  <div>
                     <p>Pro * COBOL将PL / SQL块视为单个嵌入式SQL语句，因此您可以将PL / SQL块放在可以放置SQL语句的应用程序中的任何位置。要在主机程序中嵌入PL / SQL，只需声明要与PL / SQL共享的变量，并将PL / SQL块与关键字EXEC SQL EXECUTE和END-EXEC括起来。<a id="d7799e538" class="indexterm-anchor"></a></p>
                     <p>从嵌入式PL / SQL块，您可以灵活，安全地操作Oracle数据，因为PL / SQL支持所有SQL数据操作和事务处理命令。</p>
                  </div>
                  <div>
                     <div class="relinfo">
                        <p><strong>相关话题</strong></p>
                        <ul>
                           <li><a href="embedded-PLSQL.html#GUID-7E17F1C4-BAF4-42A8-8D5C-9A5F3477C91F">嵌入式PL / SQL</a></li>
                        </ul>
                     </div>
                  </div>
               </div><a id="LNPCB138"></a><div class="props_rev_3"><a id="GUID-98A38C5B-AAA9-4A2C-898A-1547711EC35A" name="GUID-98A38C5B-AAA9-4A2C-898A-1547711EC35A"></a><h4 id="LNPCB-GUID-98A38C5B-AAA9-4A2C-898A-1547711EC35A" class="sect4"><span class="enumeration_section">2.1.6</span>主机变量和指标变量</h4>
                  <div>
                     <p><span class="italic">主变量</span>是以COBOL语言声明并与Oracle共享的标量或表变量或组项，这意味着您的程序和Oracle都可以引用其值。主机变量是Oracle与程序之间通信的关键。<a id="d7799e579" class="indexterm-anchor"></a></p>
                     <p>您使用<span class="italic">输入</span>主机变量将数据传递到数据库。您使用<span class="italic">输出</span>主机变量将数据和状态信息从数据库传递到您的程序。<a id="d7799e591" class="indexterm-anchor"></a></p>
                     <p>可以在可以使用表达式的任何地方使用主机变量。在SQL语句中，主机变量必须以冒号'：'为前缀，以将它们与数据库模式名称区分开来。 <a id="d7799e597" class="indexterm-anchor"></a><a id="d7799e601" class="indexterm-anchor"></a> 
                     </p>
                     <p>您可以将任何主机变量与可选的指示符变量相关联。<span class="italic">指示符变量</span>是一个整数变量，表示其主变量的值或条件。<span class="italic">NULL</span>是缺失的，未知的或不适用的值。您可以使用指示符变量将NULL分配给输入主变量，并检测输出变量中的NULL或输出字符主变量中的截断值。<a id="d7799e614" class="indexterm-anchor"></a></p>
                     <p>主变量<span class="italic">不能</span>是：</p>
                     <ul style="list-style-type:disc">
                        <li>
                           <p>在COBOL语句中以冒号为前缀</p>
                        </li>
                        <li>
                           <p>用于数据定义（DDL）语句，如ALTER和CREATE</p>
                        </li>
                     </ul>
                     <p>在SQL语句中，指示符变量必须以冒号为前缀并附加到其关联的主变量（为了提高可读性，可以在指示符变量前面加上可选的关键字INDICATOR）。</p>
                     <p>必须根据COBOL语言的规则声明SQL语句中使用的每个程序变量。正常的范围规则适用。COBOL变量名称可以是任意长度，但只有前30个字符对Pro * COBOL很重要<a id="d7799e634" class="indexterm-anchor"></a><a id="d7799e638" class="indexterm-anchor"></a><a id="d7799e642" class="indexterm-anchor"></a><a id="d7799e646" class="indexterm-anchor"></a><a id="d7799e650" class="indexterm-anchor"></a><a id="d7799e654" class="indexterm-anchor"></a> 。任何有效的COBOL标识符都可以用作主机变量标识符，包括以数字开头的标识符。
                     </p>
                     <p>主机变量的外部数据类型及其源或目标数据库列的内部数据类型不必相同，但它们必须兼容。</p>
                     <div class="infoboxnotealso" id="GUID-98A38C5B-AAA9-4A2C-898A-1547711EC35A__GUID-6EAF10E2-2520-4604-B436-CA97C82FDCD5">
                        <p class="notep1">也可以看看：</p><a href="datatypes-and-host-variables.html#GUID-E35BBCF1-FA1C-4DA4-A522-C17CF57E910F">数据类型转换</a>以获取Oracle在必要时自动<a href="datatypes-and-host-variables.html#GUID-E35BBCF1-FA1C-4DA4-A522-C17CF57E910F">转换</a>的兼容数据类型的列表。
                     </div>
                  </div>
               </div><a id="LNPCB139"></a><div class="props_rev_3"><a id="GUID-ABCF7484-1FBC-4DF1-8BEA-559C5482E6AE" name="GUID-ABCF7484-1FBC-4DF1-8BEA-559C5482E6AE"></a><h4 id="LNPCB-GUID-ABCF7484-1FBC-4DF1-8BEA-559C5482E6AE" class="sect4"><span class="enumeration_section">2.1.7</span> Oracle数据类型</h4>
                  <div>
                     <p>通常，主机程序将数据输入到数据库，数据库将数据输出到程序。Oracle将输入数据插入数据库表，并将输出数据选择到程序主机变量中。要存储数据项，Oracle必须知道其<span class="italic">数据类型</span> ，该<span class="italic">数据类型</span>指定存储格式和有效值范围。
                     </p>
                     <p>Oracle识别两种数据类型： <span class="italic">内部</span>和<span class="italic">外部</span> 。内部数据类型指定Oracle如何在数据库列中存储数据。Oracle还使用内部数据类型来表示数据库伪列，这些列返回特定数据项但不是表中的实际列。<a id="d7799e701" class="indexterm-anchor"></a><a id="d7799e705" class="indexterm-anchor"></a></p>
                     <p>外部数据类型指定数据在主机变量中的存储方式。当主机程序向Oracle输入数据时，它会在输入主机变量的外部数据类型与数据库列的内部数据类型之间进行任何转换。当Oracle将数据输出到主机程序时，如有必要，Oracle会在数据库列的内部数据类型和输出主机变量的外部数据类型之间进行转换。<a id="d7799e711" class="indexterm-anchor"></a></p>
                     <div class="infoboxnote" id="GUID-ABCF7484-1FBC-4DF1-8BEA-559C5482E6AE__GUID-BE943CDB-1BE9-4883-9364-B297DC64000B">
                        <p class="notep1">注意：</p>
                        <p>您可以使用动态SQL方法4或数据类型等效来覆盖默认数据类型转换。有关数据类型等效的信息，请参阅<span class="q">“ <a href="datatypes-and-host-variables.html#GUID-646C583F-AFD5-4F6D-8627-8BB344F8B721">对DATE字符串格式的显式控制</a> ”</span> 。
                        </p>
                     </div>
                  </div>
               </div><a id="LNPCB140"></a><div class="props_rev_3"><a id="GUID-9F0E8243-B2BE-4A69-BA56-5F5D1A68CBD1" name="GUID-9F0E8243-B2BE-4A69-BA56-5F5D1A68CBD1"></a><h4 id="LNPCB-GUID-9F0E8243-B2BE-4A69-BA56-5F5D1A68CBD1" class="sect4"><span class="enumeration_section">2.1.8</span>表</h4>
                  <div>
                     <p>Pro * COBOL允许您定义表主机变量（称为<span class="italic">主机表</span> ）并使用单个SQL语句对它们进行操作。使用SELECT，FETCH，DELETE，INSERT和UPDATE语句，您可以轻松查询和操作大量数据。<a id="d7799e750" class="indexterm-anchor"></a></p>
                     <div class="infoboxnotealso" id="GUID-9F0E8243-B2BE-4A69-BA56-5F5D1A68CBD1__GUID-37FC9185-3F74-4734-8ECD-ABD81F1842B8">
                        <p class="notep1">也可以看看：</p><a href="host-tables.html#GUID-B4A3765E-BBA7-4D71-860D-1058CD2D23C6">主机表，</a>用于完整讨论主机表。
                     </div>
                  </div>
               </div><a id="LNPCB141"></a><div class="props_rev_3"><a id="GUID-767065E6-7AD4-45F5-AE4C-7D5E50564303" name="GUID-767065E6-7AD4-45F5-AE4C-7D5E50564303"></a><h4 id="LNPCB-GUID-767065E6-7AD4-45F5-AE4C-7D5E50564303" class="sect4"><span class="enumeration_section">2.1.9</span>错误和警告</h4>
                  <div>
                     <div class="section">
                        <p>执行嵌入式SQL语句时，它会成功或失败，并可能导致错误或警告。您需要一种方法来处理这些结果。Pro * COBOL提供以下错误处理机制：<a id="d7799e785" class="indexterm-anchor"></a></p>
                        <ul style="list-style-type:disc">
                           <li>
                              <p>SQLCODE状态变量</p>
                           </li>
                           <li>
                              <p>SQLSTATE状态变量</p>
                           </li>
                           <li>
                              <p>SQL通信区（SQLCA）</p>
                           </li>
                           <li>
                              <p>WHENEVER声明</p>
                           </li>
                           <li>
                              <p>Oracle通信区域（ORACA）</p>
                           </li>
                        </ul>
                     </div>
                     <!-- class="section" -->
                  </div><a id="LNPCB142"></a><div class="props_rev_3"><a id="GUID-943C0AF2-1874-459B-A511-470B6D1B86E5" name="GUID-943C0AF2-1874-459B-A511-470B6D1B86E5"></a><h5 id="LNPCB-GUID-943C0AF2-1874-459B-A511-470B6D1B86E5" class="sect5"><span class="enumeration_section">2.1.9.1</span> SQLCODE / SQLSTATE状态变量</h5>
                     <div>
                        <p>执行SQL语句后，Oracle Server会将状态代码返回给名为SQLCODE或SQLSTATE的变量。状态代码指示SQL语句是成功执行还是导致错误或警告条件。</p>
                     </div>
                  </div><a id="LNPCB144"></a><a id="LNPCB143"></a><div class="props_rev_3"><a id="GUID-BFA36F8F-0F82-45E3-8558-1CA695A3DA7B" name="GUID-BFA36F8F-0F82-45E3-8558-1CA695A3DA7B"></a><h5 id="LNPCB-GUID-BFA36F8F-0F82-45E3-8558-1CA695A3DA7B" class="sect5"><span class="enumeration_section">2.1.9.2</span> SQLCA状态变量</h5>
                     <div>
                        <p>SQLCA是一种数据结构，它定义了Oracle用于将运行时状态信息传递给程序的程序变量。使用SQLCA，您可以根据Oracle对刚尝试的工作的反馈采取不同的操作。例如，您可以检查DELETE语句是否成功，如果是，则删除了多少行。 <a id="d7799e854" class="indexterm-anchor"></a> 
                        </p>
                        <p>SQLCA提供诊断检查和事件处理。在运行时，SQLCA保存Oracle传递给您的程序的状态信息。执行SQL语句后，Oracle会设置SQLCA变量以指示结果， <a href="precompiler-concepts.html#GUID-BFA36F8F-0F82-45E3-8558-1CA695A3DA7B__I6729">如图2-2所示</a> 。
                        </p>
                        <div class="figure" id="GUID-BFA36F8F-0F82-45E3-8558-1CA695A3DA7B__I6729">
                           <p class="titleinfigure">图2-2更新SQLCA</p><img src="img/pco81051.gif" alt="下面是图2-2的描述" title="下面是图2-2的描述" longdesc="img_text/pco81051.html"><br><a href="img_text/pco81051.html">“图2-2更新SQLCA”的说明</a></div>
                        <!-- class="figure" -->
                        <p>您可以检查INSERT，UPDATE或DELETE语句是否成功，如果成功，则影响了多少行。或者，如果语句失败，您可以获得有关所发生情况的更多信息。<a id="d7799e870" class="indexterm-anchor"></a><a id="d7799e872" class="indexterm-anchor"></a></p>
                        <p>当MODE = {ANSI13 | ORACLE}，您必须通过硬编码或使用INCLUDE语句将其复制到程序中来声明SQLCA。</p>
                        <div class="infoboxnotealso" id="GUID-BFA36F8F-0F82-45E3-8558-1CA695A3DA7B__GUID-A3BC2422-6F60-44C4-9604-CB4F1A1D1F61">
                           <p class="notep1">也可以看看：</p><span class="q">“ <a href="error-handling-and-diagnostics.html#GUID-07B14FDA-015C-4922-963E-6D4CBEDB9743">使用SQL通信区域</a> ”</span>获取有关如何声明和使用SQLCA的更多信息。</div>
                     </div>
                  </div><a id="LNPCB145"></a><div class="props_rev_3"><a id="GUID-603301A3-66B3-43DE-A23E-1F5F82024371" name="GUID-603301A3-66B3-43DE-A23E-1F5F82024371"></a><h5 id="LNPCB-GUID-603301A3-66B3-43DE-A23E-1F5F82024371" class="sect5"><span class="enumeration_section">2.1.9.3</span> WHENEVER声明</h5>
                     <div>
                        <p>使用WHENEVER语句，您可以指定Oracle检测到错误或警告条件时要自动执行的操作。这些操作包括继续下一个语句，调用子程序，分支到带标签的语句，执行段落或停止。 <a id="d7799e909" class="indexterm-anchor"></a> 
                        </p>
                     </div>
                  </div><a id="LNPCB146"></a><div class="props_rev_3"><a id="GUID-8A6BFBD2-BBC5-4040-9356-00A5F0765982" name="GUID-8A6BFBD2-BBC5-4040-9356-00A5F0765982"></a><h5 id="LNPCB-GUID-8A6BFBD2-BBC5-4040-9356-00A5F0765982" class="sect5"><span class="enumeration_section">2.1.9.4</span> ORACA</h5>
                     <div>
                        <div class="section">
                           <p>如果需要有关运行时错误的更多信息，而不是SQLCA提供的信息，则可以使用ORACA。 ORACA是一种处理Oracle通信的数据结构。它包含游标统计信息，有关当前SQL语句的信息，选项设置和系统统计信息。</p>
                        </div>
                        <!-- class="section" -->
                     </div>
                  </div><a id="LNPCB147"></a><div class="props_rev_3"><a id="GUID-7A159038-7A6F-4C11-8F21-31B702004524" name="GUID-7A159038-7A6F-4C11-8F21-31B702004524"></a><h5 id="LNPCB-GUID-7A159038-7A6F-4C11-8F21-31B702004524" class="sect5"><span class="enumeration_section">2.1.9.5</span>预编译器选项和错误处理</h5>
                     <div>
                        <div class="section">
                           <p>Oracle在状态变量SQLSTATE和SQLCODE中返回SQL语句的成功或失败。使用预编译器选项MODE = ORACLE，使用SQLCODE，通过包含SQLCA声明。如果MODE = ANSI，则必须声明SQLSTATE或SQLCODE，但不需要SQLCA。</p>
                        </div>
                        <!-- class="section" -->
                     </div>
                     <div>
                        <div class="relinfo">
                           <p><strong>相关话题</strong></p>
                           <ul>
                              <li><a href="error-handling-and-diagnostics.html#GUID-AE77299F-16B6-4896-817B-ACC5F7B68A2E">错误处理和诊断</a></li>
                           </ul>
                        </div>
                     </div>
                  </div>
               </div><a id="LNPCB148"></a><div class="props_rev_3"><a id="GUID-1AC4695C-44DD-4121-AB9C-8394014ACDD7" name="GUID-1AC4695C-44DD-4121-AB9C-8394014ACDD7"></a><h4 id="LNPCB-GUID-1AC4695C-44DD-4121-AB9C-8394014ACDD7" class="sect4"><span class="enumeration_section">2.1.10</span> SQL99语法支持</h4>
                  <div>
                     <p>SQL标准支持SQL应用程序在所有符合标准的软件产品中的可移植性。Oracle功能符合ANSI / ISO SQL99标准，包括符合ANSI标准的连接。Pro * Cobol支持Oracle数据库支持的所有SQL99功能，这意味着支持SELECT，INSERT，DELETE和UPDATE语句的SQL99语法以及DECLARE CURSOR语句中的游标主体。</p>
                  </div>
               </div>
            </div><a id="LNPCB149"></a><div class="props_rev_3"><a id="GUID-B4B12E18-2BD0-49A3-917C-0C9567236BC3" name="GUID-B4B12E18-2BD0-49A3-917C-0C9567236BC3"></a><h3 id="LNPCB-GUID-B4B12E18-2BD0-49A3-917C-0C9567236BC3" class="sect3"><span class="enumeration_section">2.2</span>编程指南</h3>
               <div>
                  <div class="section">
                     <p>本节介绍嵌入式SQL语法，编码约定以及Pro * COBOL特定的功能和限制。主题按字母顺序排列，以供快速参考。 <a id="d7799e1018" class="indexterm-anchor"></a><a id="d7799e1020" class="indexterm-anchor"></a> 
                     </p>
                  </div>
                  <!-- class="section" -->
               </div><a id="LNPCB150"></a><div class="props_rev_3"><a id="GUID-97346464-5A87-4195-8EDF-AA1734B48C74" name="GUID-97346464-5A87-4195-8EDF-AA1734B48C74"></a><h4 id="LNPCB-GUID-97346464-5A87-4195-8EDF-AA1734B48C74" class="sect4"><span class="enumeration_section">2.2.1</span>缩写</h4>
                  <div>
                     <div class="section">
                        <p>您可以使用标准COBOL缩写，例如PIC for PICTURE IS和COMP for USAGE IS COMPUTATIONAL。 <a id="d7799e1048" class="indexterm-anchor"></a><a id="d7799e1050" class="indexterm-anchor"></a><a id="d7799e1054" class="indexterm-anchor"></a> 
                        </p>
                     </div>
                     <!-- class="section" -->
                  </div>
               </div><a id="LNPCB151"></a><div class="props_rev_3"><a id="GUID-DC5C86E0-96BA-4664-98C8-6B8295CA36E8" name="GUID-DC5C86E0-96BA-4664-98C8-6B8295CA36E8"></a><h4 id="LNPCB-GUID-DC5C86E0-96BA-4664-98C8-6B8295CA36E8" class="sect4"><span class="enumeration_section">2.2.2</span>不<span class="enumeration_section">区分</span>大小写</h4>
                  <div>
                     <div class="section">
                        <p>Pro * COBOL预编译器选项和值以及所有EXEC SQL语句，内联命令和COBOL语句都不区分大小写。预编译器接受大写和小写令牌。<a id="d7799e1084" class="indexterm-anchor"></a></p>
                     </div>
                     <!-- class="section" -->
                  </div>
               </div><a id="LNPCB152"></a><div class="props_rev_3"><a id="GUID-2D8BF1E8-B4C9-43BA-AFDD-59627FEE1EA9" name="GUID-2D8BF1E8-B4C9-43BA-AFDD-59627FEE1EA9"></a><h4 id="LNPCB-GUID-2D8BF1E8-B4C9-43BA-AFDD-59627FEE1EA9" class="sect4"><span class="enumeration_section">2.2.3</span>支持的COBOL版本</h4>
                  <div>
                     <div class="section">
                        <p><a id="d7799e1116" class="indexterm-anchor"></a> Pro * COBOL支持为您的操作系统（通常为COBOL-85或COBOL-74）标准实施COBOL。某些平台可能同时支持COBOL实现。有关更多信息，请参阅Oracle系统特定的文档。
                        </p>
                     </div>
                     <!-- class="section" -->
                  </div>
               </div><a id="LNPCB153"></a><div class="props_rev_3"><a id="GUID-776F3ADD-4D66-466E-8471-31B8CBE695D1" name="GUID-776F3ADD-4D66-466E-8471-31B8CBE695D1"></a><h4 id="LNPCB-GUID-776F3ADD-4D66-466E-8471-31B8CBE695D1" class="sect4"><span class="enumeration_section">2.2.4</span>编码区域</h4>
                  <div>
                     <div class="section">
                        <p><a id="d7799e1143" class="indexterm-anchor"></a><a id="d7799e1147" class="indexterm-anchor"></a><a id="d7799e1151" class="indexterm-anchor"></a><a id="d7799e1155" class="indexterm-anchor"></a>预编译器选项FORMAT指定源代码的格式。如果指定FORMAT = ANSI（默认值），则尽可能符合ANSI标准。在此格式中，第1列到第6列可以包含可选的序列号，第7列（指示符区域）可以指示注释或连续行。
                        </p>
                        <p>分区标题，节标题，段落名称，FD和01语句从第8列到第11列（区域A）开始。其他语句（包括EXEC SQL和EXEC ORACLE语句）必须放在区域B（第12列到第72列）中。源代码格式的这些准则可以由编译器规则覆盖。</p>
                        <p>如果指定FORMAT = TERMINAL，则COBOL语句可以从第1列（最左侧的列）开始，或者第1列可以是指示符区域。此格式也受编译器规则的约束。</p>
                        <p>您可以指定FORMAT = VARIABLE以允许灵活B区域长度。</p>
                        <p>请参阅您自己平台的COBOL编译器文档，以确定COBOL语句的实际可接受格式。</p>
                        <div class="infoboxnote" id="GUID-776F3ADD-4D66-466E-8471-31B8CBE695D1__GUID-01FF5274-B5BE-47D2-B222-32614BCBE3A9">
                           <p class="notep1">注意：</p>
                           <p>在本手册中，COBOL代码示例使用FORMAT = TERMINAL设置。演示目录中的在线示例程序使用FORMAT = ANSI。 <a id="d7799e1171" class="indexterm-anchor"></a> 
                           </p>
                        </div>
                     </div>
                     <!-- class="section" -->
                  </div>
               </div><a id="LNPCB154"></a><div class="props_rev_3"><a id="GUID-06A84E6B-9D1B-49C5-B636-910502F57F87" name="GUID-06A84E6B-9D1B-49C5-B636-910502F57F87"></a><h4 id="LNPCB-GUID-06A84E6B-9D1B-49C5-B636-910502F57F87" class="sect4"><span class="enumeration_section">2.2.5</span>逗号</h4>
                  <div>
                     <div class="section">
                        <p>在SQL中，必须使用逗号分隔列表项，如以下示例所示：</p><pre class="oac_no_warn" dir="ltr">EXEC SQL SELECT ENAME，JOB，SAL INTO：EMP-NAME，：JOB-TITLE，：来自EMP的SALARY EMPNO =：EMP-NUMBER END-EXEC。</pre><p>在COBOL中，您可以使用逗号或空格分隔列表项。例如，以下两个语句是等效的：</p><pre class="oac_no_warn" dir="ltr">将AMT1，AMT2，AMT3添加到TOTAL-AMT。将AMT1 AMT2 AMT3添加到TOTAL-AMT。</pre></div>
                     <!-- class="section" -->
                  </div>
               </div><a id="LNPCB155"></a><div class="props_rev_3"><a id="GUID-EA15DD4C-58E9-4EC5-B731-776DEE876C60" name="GUID-EA15DD4C-58E9-4EC5-B731-776DEE876C60"></a><h4 id="LNPCB-GUID-EA15DD4C-58E9-4EC5-B731-776DEE876C60" class="sect4"><span class="enumeration_section">2.2.6</span>评论</h4>
                  <div>
                     <div class="section">
                        <p>您可以在SQL语句中放置COBOL注释行。COBOL注释行以指标区域中的星号（*）开头。</p>
                        <p>您还可以在行末尾的SQL语句中放置以“ -   - ”开头的ANSI SQL样式注释（但不能在SQL语句的最后一行之后）。</p>
                        <p>在这两个字符后面的其余部分继续COBOL注释：“*&gt;”。</p>
                        <p>您可以在SQL语句中放置C风格的注释（/ * ... * /）。</p>
                        <p>以下示例显示了所有四种注释样式：<a id="d7799e1247" class="indexterm-anchor"></a><a id="d7799e1251" class="indexterm-anchor"></a><a id="d7799e1255" class="indexterm-anchor"></a><a id="d7799e1259" class="indexterm-anchor"></a></p><pre class="oac_no_warn" dir="ltr">移动12到DEPT-NUMBER。 *&gt;这是软件开发小组。EXEC SQL SELECT ENAME，SAL *分配列值以输出主机变量INTO：EMP-NAME，：SALARY  - 输出主机变量/ *分配给输出主机变量的列值* / FROM EMP WHERE DEPTNO =：DEPT-NUMBER END-EXEC 。 - 非法评论</pre><p>在终止符END-EXEC之后，您不能嵌套注释或将它们放在SQL语句的最后一行。</p>
                     </div>
                     <!-- class="section" -->
                  </div>
               </div><a id="LNPCB156"></a><div class="props_rev_3"><a id="GUID-11119814-CA9F-49C9-BC5F-221F62EE38CA" name="GUID-11119814-CA9F-49C9-BC5F-221F62EE38CA"></a><h4 id="LNPCB-GUID-11119814-CA9F-49C9-BC5F-221F62EE38CA" class="sect4"><span class="enumeration_section">2.2.7</span>延续线</h4>
                  <div>
                     <div class="section">
                        <p>根据COBOL的规则，您可以将SQL语句从一行继续到下一行，如下例所示：<a id="d7799e1296" class="indexterm-anchor"></a></p><pre class="oac_no_warn" dir="ltr">EXEC SQL SELECT ENAME，SAL INTO：EMP-NAME，：来自EMP的SALARY DEPTNO =：DEPT-NUMBER END-EXEC。</pre><p>不需要延续指标。</p>
                        <p>要将字符串文字从一行继续到下一行，请通过第72列对文字进行编码。在下一行，在第7列中编码连字符（ - ），在第12列或更高版本中编写引号，然后在文字的其余部分编码。一个例子如下：<a id="d7799e1306" class="indexterm-anchor"></a><a id="d7799e1310" class="indexterm-anchor"></a><a id="d7799e1314" class="indexterm-anchor"></a></p><pre class="oac_no_warn" dir="ltr">工作储存部分。 ...EXEC SQL BEGIN DECLARE SECTION END-EXEC。 ...01 UPDATE-STATEMENT PIC X（80）VALUE“UPDATE EMP SET BON  - ”US = 500，其中DEPTNO = 20“。EXEC SQL END DECLARE SECTION END-EXEC。</pre></div>
                     <!-- class="section" -->
                  </div>
               </div><a id="LNPCB157"></a><div class="props_rev_3"><a id="GUID-0499C071-C2AD-4FD0-8CAA-C0D952E52F4E" name="GUID-0499C071-C2AD-4FD0-8CAA-C0D952E52F4E"></a><h4 id="LNPCB-GUID-0499C071-C2AD-4FD0-8CAA-C0D952E52F4E" class="sect4"><span class="enumeration_section">2.2.8</span>复制声明</h4>
                  <div>
                     <div class="section">
                        <p>Pro * COBOL不会解析复制语句。因此，COPY命令附带的文件不应包含Host变量的定义或包含嵌入的SQL语句。而是使用<span class="q">“ <a href="precompiler-concepts.html#GUID-807D6563-4B0B-42C9-9B5D-6C0EC4056473">使用INCLUDE语句</a> ”中</span>记录的INCLUDE预编译器语句。使用INCLUDE并使用DECLARE_SECTION = YES时要小心。组项目应放在声明部分的全部内部或全部。
                        </p>
                     </div>
                     <!-- class="section" -->
                  </div>
               </div><a id="LNPCB158"></a><div class="props_rev_3"><a id="GUID-E7244C75-5EAE-49BF-8FBD-ADE9E70BA1A2" name="GUID-E7244C75-5EAE-49BF-8FBD-ADE9E70BA1A2"></a><h4 id="LNPCB-GUID-E7244C75-5EAE-49BF-8FBD-ADE9E70BA1A2" class="sect4"><span class="enumeration_section">2.2.9</span>小数点是逗号</h4>
                  <div>
                     <div class="section">
                        <p>Pro * COBOL支持ENVIRONMENT DIVISION中的DECIMAL-POINT IS COMMA子句。如果源文件中出现DECIMAL-POINT IS COMMA子句，则逗号将被允许作为从VALUE子句中任何数字文字的小数部分开始的符号。</p>
                        <p>例如，允许以下内容：</p><pre class="oac_no_warn" dir="ltr">识别部门。 PROGRAM-ID。FOO环境部门。配置部分。 SPECIAL-名。 DECIMAL-POINT很难玩。 *&gt; &lt; -  ** DATA DIVISION。工作储存部分。 ...01 WDATA1 PIC S9V999 VALUE +，567。 *&gt; &lt;--- ** 01 WDATA2 PIC S9V999值 - ，234。 *&gt; &lt;--- ** ...</pre></div>
                     <!-- class="section" -->
                  </div>
               </div><a id="LNPCB159"></a><div class="props_rev_3"><a id="GUID-5DE2D7EE-D138-4B47-A332-D5F9653992CC" name="GUID-5DE2D7EE-D138-4B47-A332-D5F9653992CC"></a><h4 id="LNPCB-GUID-5DE2D7EE-D138-4B47-A332-D5F9653992CC" class="sect4"><span class="enumeration_section">2.2.10</span>分隔符</h4>
                  <div>
                     <div class="section">
                        <p>LITDELIM选项指定COBOL字符串常量和文字的分隔符。如果指定LITDELIM = APOST，则Pro * COBOL在生成COBOL代码时使用撇号。如果指定LITDELIM = QUOTE（默认值），则使用引号，如<a id="d7799e1405" class="indexterm-anchor"></a><a id="d7799e1409" class="indexterm-anchor"></a><a id="d7799e1411" class="indexterm-anchor"></a></p><pre class="oac_no_warn" dir="ltr">使用SQL-TMP0调用“SQLROL”。
</pre><p>在SQL语句中，必须使用引号来分隔包含特殊或小写字符的标识符，如</p><pre class="oac_no_warn" dir="ltr">EXEC SQL CREATE TABLE“Emp2”END-EXEC。</pre><p>但是，您必须使用撇号来分隔字符串常量，如</p><pre class="oac_no_warn" dir="ltr">来自EMP的EXEC SQL SELECT ENAME，其中JOB ='CLERK'END-EXEC。</pre><p>无论Pro * COBOL源文件中使用哪个分隔符，Pro * COBOL都会生成由LITDELIM值指定的分隔符。</p>
                     </div>
                     <!-- class="section" -->
                  </div>
               </div><a id="LNPCB160"></a><div class="props_rev_3"><a id="GUID-74C30E48-2B20-4D61-8556-9EB97C31E368" name="GUID-74C30E48-2B20-4D61-8556-9EB97C31E368"></a><h4 id="LNPCB-GUID-74C30E48-2B20-4D61-8556-9EB97C31E368" class="sect4"><span class="enumeration_section">2.2.11</span>可选的分区标题</h4>
                  <div>
                     <div class="section">
                        <p>以下分区标题是可选的：</p>
                        <ul style="list-style-type:disc">
                           <li>
                              <p>识别部门</p>
                           </li>
                           <li>
                              <p>环境部门</p>
                           </li>
                           <li>
                              <p>数据部门</p>
                           </li>
                        </ul>
                        <p>请注意，PROCEDURE DIVISION标头不是可选的。可以预编译以下源代码：</p><pre class="oac_no_warn" dir="ltr">* IDENTIFICATION DIVISION标头是可选的PROGRAM-ID。你好。 * ENVIRONMENT DIVISION标题是可选的CONFIGURATION SECTION。 * DATA DIVISION标题是可选的WORKING-STORAGE SECTION。程序部门。显示“你好世界！”。停止运行。</pre></div>
                     <!-- class="section" -->
                  </div>
               </div><a id="LNPCB161"></a><div class="props_rev_3"><a id="GUID-D84FC56A-6E8D-49B8-9E65-A250DE4F4765" name="GUID-D84FC56A-6E8D-49B8-9E65-A250DE4F4765"></a><h4 id="LNPCB-GUID-D84FC56A-6E8D-49B8-9E65-A250DE4F4765" class="sect4"><span class="enumeration_section">2.2.12</span>嵌入式SQL语法</h4>
                  <div>
                     <div class="section">
                        <p>要在Pro * COBOL程序中使用SQL语句，请在SQL语句前面加上EXEC SQL子句，并使用END-EXEC关键字结束语句。 <a id="d7799e1496" class="indexterm-anchor"></a><a id="d7799e1500" class="indexterm-anchor"></a><a id="d7799e1504" class="indexterm-anchor"></a><a id="d7799e1508" class="indexterm-anchor"></a> 
                        </p>
                        <div class="infoboxnotealso" id="GUID-D84FC56A-6E8D-49B8-9E65-A250DE4F4765__GUID-C6D923C0-7F18-4E98-8676-D31D4F149D45">
                           <p class="notep1">也可以看看：</p><a href="../sqlrf/index.html" target="_blank"><span class="italic">Oracle数据库SQL语言参考</span> 。</a>有关嵌入式SQL语法的更多信息。
                        </div>
                     </div>
                     <!-- class="section" -->
                  </div>
               </div><a id="LNPCB162"></a><div class="props_rev_3"><a id="GUID-7DA7195E-2162-4215-BE01-8601BEFF127D" name="GUID-7DA7195E-2162-4215-BE01-8601BEFF127D"></a><h4 id="LNPCB-GUID-7DA7195E-2162-4215-BE01-8601BEFF127D" class="sect4"><span class="enumeration_section">2.2.13</span>比喻常数</h4>
                  <div>
                     <div class="section">
                        <p>在SQL语句中不能使用诸如HIGH-VALUE，ZERO和SPACE之类的图形常量。例如，以下内容<span class="italic">无效</span> ：<a id="d7799e1546" class="indexterm-anchor"></a><a id="d7799e1550" class="indexterm-anchor"></a></p><pre class="oac_no_warn" dir="ltr">EXEC SQL DELETE FROM EMP WHERE COMM = ZERO END-EXEC。</pre><p>相反，请使用以下内容：</p><pre class="oac_no_warn" dir="ltr">EXEC SQL DELETE FROM EMP WHERE COMM = 0 END-EXEC。</pre></div>
                     <!-- class="section" -->
                  </div>
               </div><a id="LNPCB163"></a><div class="props_rev_3"><a id="GUID-AE3C8B21-AB62-454C-8749-17A31CE875F4" name="GUID-AE3C8B21-AB62-454C-8749-17A31CE875F4"></a><h4 id="LNPCB-GUID-AE3C8B21-AB62-454C-8749-17A31CE875F4" class="sect4"><span class="enumeration_section">2.2.14</span>文件长度</h4>
                  <div>
                     <div class="section">
                        <p>Pro * COBOL无法处理任意长的源文件。内部使用的一些变量限制了生成的文件的大小。允许的行数没有绝对限制，但源文件的以下方面是文件大小约束的影响因素：</p>
                        <ul style="list-style-type:disc">
                           <li>
                              <p>嵌入式SQL语句的复杂性（例如，绑定和定义变量的数量）</p>
                           </li>
                           <li>
                              <p>是否使用数据库名称（例如，使用AT子句连接到数据库）</p>
                           </li>
                           <li>
                              <p>嵌入式SQL语句的数量</p>
                           </li>
                        </ul>
                        <p>要防止与此限制相关的问题，请使用多个程序单元来充分减小源文件的大小。</p>
                     </div>
                     <!-- class="section" -->
                  </div>
               </div><a id="LNPCB164"></a><div class="props_rev_3"><a id="GUID-2A1A2FFF-D5B6-4F9D-8372-511762601432" name="GUID-2A1A2FFF-D5B6-4F9D-8372-511762601432"></a><h4 id="LNPCB-GUID-2A1A2FFF-D5B6-4F9D-8372-511762601432" class="sect4"><span class="enumeration_section">2.2.15</span>允许填充</h4>
                  <div>
                     <div class="section">
                        <p>主机变量声明中允许使用单词FILLER。单词FILLER用于指定无法明确引用的组的基本项。以下声明有效：</p><pre class="oac_no_warn" dir="ltr">01股票。 05 DIVIDEND PIC X（5）。05 FILLER PIC X. 05价格PIC X（6）。</pre></div>
                     <!-- class="section" -->
                  </div>
               </div><a id="LNPCB165"></a><div class="props_rev_3"><a id="GUID-DBE02C96-20C8-46E7-9C85-B3A4E6276865" name="GUID-DBE02C96-20C8-46E7-9C85-B3A4E6276865"></a><h4 id="LNPCB-GUID-DBE02C96-20C8-46E7-9C85-B3A4E6276865" class="sect4"><span class="enumeration_section">2.2.16</span>主机变量名称</h4>
                  <div>
                     <div class="section">
                        <p>任何有效的标准COBOL标识符都可以用作主机变量。变量名称可以是任意长度，但只有前30个字符才有意义。COBOL编译器识别的最大重要字符数为30。<a id="d7799e1654" class="indexterm-anchor"></a><a id="d7799e1658" class="indexterm-anchor"></a><a id="d7799e1662" class="indexterm-anchor"></a></p>
                        <p>为了便于移植，您可能希望将主机变量名称的长度限制为18个或更少的字符（SQL标准规定的长度）。</p>
                        <div class="infoboxnotealso" id="GUID-DBE02C96-20C8-46E7-9C85-B3A4E6276865__GUID-D5B758B4-E645-4A95-8259-92CE85A1BF2E">
                           <p class="notep1">也可以看看：</p><a href="reserved-words-keywords-and-namespaces.html#GUID-A408EC88-567F-4D54-8359-ABCFF421CDD7">保留字_关键字_和命名空间，</a>用于限制在应用程序中使用它们的单词列表。
                        </div>
                     </div>
                     <!-- class="section" -->
                  </div>
               </div><a id="LNPCB166"></a><div class="props_rev_3"><a id="GUID-167590B9-9985-4779-AFCF-B29D24D858BC" name="GUID-167590B9-9985-4779-AFCF-B29D24D858BC"></a><h4 id="LNPCB-GUID-167590B9-9985-4779-AFCF-B29D24D858BC" class="sect4"><span class="enumeration_section">2.2.17</span>连字符名称</h4>
                  <div>
                     <div class="section">
                        <p>您可以在静态SQL语句中使用带连字符的主机变量名称，但<span class="italic">不能</span>在动态SQL中使用。例如，以下用法<span class="italic">无效</span> ：<a id="d7799e1706" class="indexterm-anchor"></a><a id="d7799e1710" class="indexterm-anchor"></a></p><pre class="oac_no_warn" dir="ltr">将“从EMP中删除EMPNO = EMP-NUMBER”移到SQLSTMT。从SQLSTMT END-EXEC EXEC SQL PREPARE STMT1。</pre></div>
                     <!-- class="section" -->
                  </div>
               </div><a id="LNPCB167"></a><div class="props_rev_3"><a id="GUID-0B6A0DF7-A963-480F-B112-913658099FC7" name="GUID-0B6A0DF7-A963-480F-B112-913658099FC7"></a><h4 id="LNPCB-GUID-0B6A0DF7-A963-480F-B112-913658099FC7" class="sect4"><span class="enumeration_section">2.2.18</span>级别编号</h4>
                  <div>
                     <div class="section">
                        <p>声明主变量时，可以使用级别编号01到49和77。Pro * COBOL不允许将包含VARYING子句或伪类型变量的变量（这些数据类型以“SQL-”为前缀）声明为级别49或77。</p>
                     </div>
                     <!-- class="section" -->
                  </div>
               </div><a id="LNPCB168"></a><div class="props_rev_3"><a id="GUID-5F903960-5E5F-4739-8564-303E130B7518" name="GUID-5F903960-5E5F-4739-8564-303E130B7518"></a><h4 id="LNPCB-GUID-5F903960-5E5F-4739-8564-303E130B7518" class="sect4"><span class="enumeration_section">2.2.19</span> MAXLITERAL默认值</h4>
                  <div>
                     <div class="section">
                        <p>使用MAXLITERAL选项，您可以指定Pro * COBOL生成的字符串文字的最大长度，以便不超过编译器限制。对于Pro * COBOL，默认值为256，但您可能必须指定较低的值。在IBM专有的S370操作系统上，它是120。</p>
                     </div>
                     <!-- class="section" -->
                  </div>
               </div><a id="LNPCB169"></a><div class="props_rev_3"><a id="GUID-8907EFD0-95AB-4A63-9D30-35EEA9B6D784" name="GUID-8907EFD0-95AB-4A63-9D30-35EEA9B6D784"></a><h4 id="LNPCB-GUID-8907EFD0-95AB-4A63-9D30-35EEA9B6D784" class="sect4"><span class="enumeration_section">2.2.20</span>多字节数据类型</h4>
                  <div>
                     <div class="section">
                        <p>支持ANSI标准国家字符集数据类型来处理多字节字符数据。如果编译器支持PIC N或PIC G子句，则定义存储固定长度NCHAR字符串的变量。您可以使用由长度字段和字符串字段组成的COBOL组项来存储可变长度，多字节的国家字符集字符串。<a id="d7799e1792" class="indexterm-anchor"></a></p>
                        <p>环境变量NLS_NCHAR可用于指定客户端全球化支持国家字符集。</p>
                     </div>
                     <!-- class="section" -->
                  </div>
                  <div>
                     <div class="relinfo">
                        <p><strong>相关话题</strong></p>
                        <ul>
                           <li><a href="datatypes-and-host-variables.html#GUID-B7D9C340-75B1-4B84-B44E-F4CB1748262E">VARCHAR变量</a></li>
                        </ul>
                     </div>
                  </div>
               </div><a id="LNPCB170"></a><div class="props_rev_3"><a id="GUID-C4DCD14E-B24F-4FEC-93DA-FC63693C77ED" name="GUID-C4DCD14E-B24F-4FEC-93DA-FC63693C77ED"></a><h4 id="LNPCB-GUID-C4DCD14E-B24F-4FEC-93DA-FC63693C77ED" class="sect4"><span class="enumeration_section">2.2.21</span> SQL中的NULL</h4>
                  <div>
                     <div class="section">
                        <p>在SQL中，NULL表示缺失，未知或不适用的列值;它既不等于零也不等于空白。使用NVL函数将NULL转换为非NULL值，使用IS [NOT] NULL比较运算符搜索NULL，并使用指示符变量插入和测试NULL。<a id="d7799e1835" class="indexterm-anchor"></a><a id="d7799e1839" class="indexterm-anchor"></a><a id="d7799e1843" class="indexterm-anchor"></a></p>
                     </div>
                     <!-- class="section" -->
                  </div>
               </div><a id="LNPCB171"></a><div class="props_rev_3"><a id="GUID-4FD7119F-1980-40C6-BFDE-8CDA1E6FB965" name="GUID-4FD7119F-1980-40C6-BFDE-8CDA1E6FB965"></a><h4 id="LNPCB-GUID-4FD7119F-1980-40C6-BFDE-8CDA1E6FB965" class="sect4"><span class="enumeration_section">2.2.22</span>段落和章节名称</h4>
                  <div>
                     <div class="section">
                        <p>您可以将标准COBOL段落和节名称与SQL语句关联，如以下示例所示：<a id="d7799e1872" class="indexterm-anchor"></a><a id="d7799e1876" class="indexterm-anchor"></a></p><pre class="oac_no_warn" dir="ltr">LOAD-DATA。 EXEC SQL INSERT INTO EMP（EMPNO，ENAME，DEPTNO）值（：EMP-NUMBER，：EMP-NAME，：DEPT-NUMBER）END-EXEC。</pre><p>此外，您可以在WHENEVER中引用段落和部分名称...做什么或者什么时候......GOTO语句，如下一个例子所示：</p><pre class="oac_no_warn" dir="ltr">程序部门。主要。执行SQL WHENEVER SQLERROR执行SQL-ERROR END-EXEC。 ...SQL-ERROR部分。 ...</pre><p>您必须在区域A中开始所有段落名称。 <a id="d7799e1888" class="indexterm-anchor"></a><a id="d7799e1892" class="indexterm-anchor"></a> 
                        </p>
                     </div>
                     <!-- class="section" -->
                  </div>
               </div><a id="LNPCB172"></a><div class="props_rev_3"><a id="GUID-E22934D1-3B04-48E0-892E-87FA54396F3D" name="GUID-E22934D1-3B04-48E0-892E-87FA54396F3D"></a><h4 id="LNPCB-GUID-E22934D1-3B04-48E0-892E-87FA54396F3D" class="sect4"><span class="enumeration_section">2.2.23</span> REDEFINES条款</h4>
                  <div>
                     <div class="section">
                        <p>您可以使用COBOL REDEFINES子句重新定义组或基本项。例如，以下声明有效：<a id="d7799e1922" class="indexterm-anchor"></a></p><pre class="oac_no_warn" dir="ltr">EXEC SQL BEGIN DECLARE SECTION END-EXEC。 01 REC-ID PIC X（4）。01 REC-NUM重新定义REC-ID PIC S9（4）COMP。 EXEC SQL END DECLARE SECTION END-EXEC。</pre><p>和：<a id="d7799e1930" class="indexterm-anchor"></a><a id="d7799e1934" class="indexterm-anchor"></a></p><pre class="oac_no_warn" dir="ltr">EXEC SQL BEGIN DECLARE SECTION END-EXEC。 01股票。 05 DIVIDEND PIC X（5）。05 PRICE PIC X（6）。01 BOND REDEFINES股票。 05 COUPON-RATE PIC X（4）。05 PRICE PIC X（7）。EXEC SQL END DECLARE SECTION END-EXEC。</pre><p>如果单个INTO子句使用来自组项主机变量和重新定义的项目，则Pro * COBOL不会发出警告或错误。</p>
                     </div>
                     <!-- class="section" -->
                  </div>
               </div><a id="LNPCB174"></a><a id="LNPCB173"></a><div class="props_rev_3"><a id="GUID-63C7C12C-A978-448C-89F7-809A89B96F37" name="GUID-63C7C12C-A978-448C-89F7-809A89B96F37"></a><h4 id="LNPCB-GUID-63C7C12C-A978-448C-89F7-809A89B96F37" class="sect4"><span class="enumeration_section">2.2.24</span>关系运算符</h4>
                  <div>
                     <div class="section">
                        <p>COBOL关系运算符与它们的SQL等价物不同，如<a href="precompiler-concepts.html#GUID-63C7C12C-A978-448C-89F7-809A89B96F37__I13966">关系运算符中</a>所示。此外，COBOL允许使用单词而不是符号，而SQL则不然。
                        </p>
                     </div>
                     <!-- class="section" -->
                     <div class="tblformal" id="GUID-63C7C12C-A978-448C-89F7-809A89B96F37__GUID-B2BDCFB5-8771-4650-91BA-F541ED830079">
                        <p class="titleintable">表2-3 <span class="italic" id="GUID-63C7C12C-A978-448C-89F7-809A89B96F37__I13966"><span class="bold">关系运算符</span></span></p>
                        <table cellpadding="4" cellspacing="0" class="Formal" title="关系运算符" width="100%" border="1" summary="q" frame="hsides" rules="rows">
                           <thead>
                              <tr align="left" valign="top">
                                 <th align="left" valign="bottom" width="31%" id="d7799e1984">SQL运算符</th>
                                 <th align="left" valign="bottom" width="69%" id="d7799e1987">COBOL运营商</th>
                              </tr>
                           </thead>
                           <tbody>
                              <tr align="left" valign="top">
                                 <td align="left" valign="top" width="31%" id="d7799e1992" headers="d7799e1984 ">
                                    <p>=</p>
                                 </td>
                                 <td align="left" valign="top" width="69%" headers="d7799e1992 d7799e1987 ">
                                    <p>=，等于</p>
                                 </td>
                              </tr>
                              <tr align="left" valign="top">
                                 <td align="left" valign="top" width="31%" id="d7799e1999" headers="d7799e1984 ">
                                    <p>&lt;&gt; ,!=，^ =</p>
                                 </td>
                                 <td align="left" valign="top" width="69%" headers="d7799e1999 d7799e1987 ">
                                    <p>NOT =，不等于</p>
                                 </td>
                              </tr>
                              <tr align="left" valign="top">
                                 <td align="left" valign="top" width="31%" id="d7799e2006" headers="d7799e1984 ">
                                    <p>&gt;</p>
                                 </td>
                                 <td align="left" valign="top" width="69%" headers="d7799e2006 d7799e1987 ">
                                    <p>&gt;，大于</p>
                                 </td>
                              </tr>
                              <tr align="left" valign="top">
                                 <td align="left" valign="top" width="31%" id="d7799e2013" headers="d7799e1984 ">
                                    <p>&lt;</p>
                                 </td>
                                 <td align="left" valign="top" width="69%" headers="d7799e2013 d7799e1987 ">
                                    <p>&lt;，不过</p>
                                 </td>
                              </tr>
                              <tr align="left" valign="top">
                                 <td align="left" valign="top" width="31%" id="d7799e2020" headers="d7799e1984 ">
                                    <p>&gt; =</p>
                                 </td>
                                 <td align="left" valign="top" width="69%" headers="d7799e2020 d7799e1987 ">
                                    <p>&gt; =，大于或等于</p>
                                 </td>
                              </tr>
                              <tr align="left" valign="top">
                                 <td align="left" valign="top" width="31%" id="d7799e2027" headers="d7799e1984 ">
                                    <p>&lt;=</p>
                                 </td>
                                 <td align="left" valign="top" width="69%" headers="d7799e2027 d7799e1987 ">
                                    <p>&lt;=，少于或等于</p>
                                 </td>
                              </tr>
                           </tbody>
                        </table>
                     </div>
                     <!-- class="inftblhruleinformal" -->
                  </div>
               </div><a id="LNPCB175"></a><div class="props_rev_3"><a id="GUID-3CDA0540-50E8-4A06-B270-52EA056F5235" name="GUID-3CDA0540-50E8-4A06-B270-52EA056F5235"></a><h4 id="LNPCB-GUID-3CDA0540-50E8-4A06-B270-52EA056F5235" class="sect4"><span class="enumeration_section">2.2.25</span>句子终结者</h4>
                  <div>
                     <div class="section">
                        <p>COBOL <span class="italic">语句</span>包括一个或多个COBOL或SQL语句，或两者都包含，并以句点结束。在条件语句中，只有最后一个语句必须以句点结束，如下例所示。 <a id="d7799e2071" class="indexterm-anchor"></a><a id="d7799e2075" class="indexterm-anchor"></a> 
                        </p><pre class="oac_no_warn" dir="ltr">如果EMP-NUMBER =零移动错误有效数据执行GET-EMP-NUM直到有效数据= TRUE EXEC EXEC SQL从EMP删除EMPNO =：EMP-NUMBER END-EXEC ADD 1 DELETE-TOTAL。万一。</pre><p>SQL语句可以用逗号，句点或其他COBOL语句结束。</p>
                     </div>
                     <!-- class="section" -->
                  </div>
               </div>
            </div><a id="LNPCB176"></a><div class="props_rev_3"><a id="GUID-C01E658A-1EAE-4497-82DB-347217694E78" name="GUID-C01E658A-1EAE-4497-82DB-347217694E78"></a><h3 id="LNPCB-GUID-C01E658A-1EAE-4497-82DB-347217694E78" class="sect3"><span class="enumeration_section">2.3</span>申报部分</h3>
               <div>
                  <p>在数据库服务器和应用程序之间传递数据需要主机变量和错误处理。本节介绍如何满足这些要求。</p>
               </div><a id="LNPCB177"></a><div class="props_rev_3"><a id="GUID-FD2C19FC-BFF2-4643-9D8B-D6E7567D4161" name="GUID-FD2C19FC-BFF2-4643-9D8B-D6E7567D4161"></a><h4 id="LNPCB-GUID-FD2C19FC-BFF2-4643-9D8B-D6E7567D4161" class="sect4"><span class="enumeration_section">2.3.1</span>申报部分的内容</h4>
                  <div>
                     <div class="section">
                        <p>声明部分以声明开头<a id="d7799e2132" class="indexterm-anchor"></a><a id="d7799e2136" class="indexterm-anchor"></a><a id="d7799e2140" class="indexterm-anchor"></a> ：</p><pre class="oac_no_warn" dir="ltr">EXEC SQL BEGIN DECLARE SECTION END-EXEC。</pre><p>并以声明结束：</p><pre class="oac_no_warn" dir="ltr">EXEC SQL END DECLARE SECTION END-EXEC。</pre><p>在这两个语句之间只允许以下内容：<a id="d7799e2153" class="indexterm-anchor"></a><a id="d7799e2157" class="indexterm-anchor"></a></p>
                        <ul style="list-style-type:disc">
                           <li>
                              <p>主变量和指标变量声明</p>
                           </li>
                           <li>
                              <p>非主机COBOL变量</p>
                           </li>
                           <li>
                              <p>EXEC SQL DECLARE语句</p>
                           </li>
                           <li>
                              <p>EXEC SQL INCLUDE语句</p>
                           </li>
                           <li>
                              <p>EXEC SQL VAR语句</p>
                           </li>
                           <li>
                              <p>EXEC ORACLE声明</p>
                           </li>
                           <li>
                              <p>COBOL评论</p>
                           </li>
                        </ul>
                     </div>
                     <!-- class="section" -->
                  </div><a id="LNPCB178"></a><div class="props_rev_3"><a id="GUID-C72ABB28-EFD4-4D2D-9A86-9EAC44A4F4FB" name="GUID-C72ABB28-EFD4-4D2D-9A86-9EAC44A4F4FB"></a><h5 id="LNPCB-GUID-C72ABB28-EFD4-4D2D-9A86-9EAC44A4F4FB" class="sect5"><span class="enumeration_section">2.3.1.1</span>一个例子</h5>
                     <div>
                        <div class="section">
                           <p>在以下示例中，您将声明四个主机变量，以便稍后在程序中使用。 <a id="d7799e2208" class="indexterm-anchor"></a> 
                           </p><pre class="oac_no_warn" dir="ltr">工作储存部分。 ...EXEC SQL BEGIN DECLARE SECTION END-EXEC。 ...01 EMP-NUMBER PIC 9（4）COMP VALUE ZERO。 01 EMP-NAME PIC X（10）变化。 01 SALARY PIC S9（5）V99 COMP-3 VALUE ZERO。 01委员会PIC S9（5）V99 COMP-3 VALUE ZERO。 EXEC SQL END DECLARE SECTION END-EXEC。</pre></div>
                        <!-- class="section" -->
                     </div>
                  </div>
               </div><a id="LNPCB179"></a><div class="props_rev_3"><a id="GUID-F8F34F95-35BE-4A4C-9B0A-BF83786FDABE" name="GUID-F8F34F95-35BE-4A4C-9B0A-BF83786FDABE"></a><h4 id="LNPCB-GUID-F8F34F95-35BE-4A4C-9B0A-BF83786FDABE" class="sect4"><span class="enumeration_section">2.3.2</span>预编译器选项DECLARE_SECTION</h4>
                  <div>
                     <div class="section">
                        <p>声明部分是可选的。为了向后兼容8.0之前的版本，Pro * COBOL提供了一个命令行预编译器选项，用于显式控制是否只允许声明部分中的声明作为主机变量。这个选项是：</p>
                        <p>DECLARE_SECTION = {YES | NO}（默认为NO）</p>
                        <p>您必须在命令行或配置文件中使用DECLARE_SECTION选项。</p>
                        <p>当MODE = ORACLE和DECLARE_SECTION = YES时，只允许在Declare Section内声明的变量作为主变量。当MODE = ANSI时，DECLARE_SECTION隐式设置为YES。</p>
                        <p>如果DECLARE_SECTION设置为YES，那么必须声明Declare Section中SQL语句中使用的所有程序变量。如果DECLARE_SECTION设置为NO，则可以选择使用Declare Section。在这种情况下，主机变量和指示符变量的声明可以在Declare Section内部或外部进行。此可选行为是对8.0版和早期版本的更改。</p>
                        <p>每个预编译单元允许多个声明部分。此外，主程序可以包含几个独立预编译的单元。<a id="d7799e2256" class="indexterm-anchor"></a></p>
                        <div class="infoboxnotealso" id="GUID-F8F34F95-35BE-4A4C-9B0A-BF83786FDABE__GUID-5688F9A4-25D3-4F3F-B4FD-7FAD330A0259">
                           <p class="notep1">也可以看看：</p>
                           <ul style="list-style-type:disc">
                              <li>
                                 <p><span class="q">“ <a href="precompiler-options.html#GUID-B8F5D2F9-D077-4CC0-B8A5-0B4CB1D6425D">宏观和微观选项</a> ”</span>有关宏观和微观选项的更多信息。
                                 </p>
                              </li>
                              <li>
                                 <p><span class="q">“ <a href="precompiler-options.html#GUID-A4AB5DC2-8F05-47BD-8299-3A50DE9C6A5E">DECLARE_SECTION</a> ”</span>有关该选项的更多详细信息。
                                 </p>
                              </li>
                           </ul>
                        </div>
                     </div>
                     <!-- class="section" -->
                  </div>
               </div><a id="LNPCB180"></a><div class="props_rev_3"><a id="GUID-807D6563-4B0B-42C9-9B5D-6C0EC4056473" name="GUID-807D6563-4B0B-42C9-9B5D-6C0EC4056473"></a><h4 id="LNPCB-GUID-807D6563-4B0B-42C9-9B5D-6C0EC4056473" class="sect4"><span class="enumeration_section">2.3.3</span>使用INCLUDE语句</h4>
                  <div>
                     <p>INCLUDE语句允许您将文件复制到主机程序中，如以下示例所示：</p><pre class="oac_no_warn" dir="ltr">*复制SQL通信区域（SQLCA）EXEC SQL INCLUDE SQLCA END-EXEC。 *复制到Oracle通信区域（ORACA）EXEC SQL INCLUDE ORACA END-EXEC。</pre><p>您可以包含任何文件。预编译Pro * COBOL程序时，每个EXEC SQL INCLUDE语句都将替换为语句中指定的文件的副本。<a id="d7799e2305" class="indexterm-anchor"></a></p>
                  </div><a id="LNPCB181"></a><div class="props_rev_3"><a id="GUID-7A97367A-7480-44F6-9BB9-FF1E010BB27D" name="GUID-7A97367A-7480-44F6-9BB9-FF1E010BB27D"></a><h5 id="LNPCB-GUID-7A97367A-7480-44F6-9BB9-FF1E010BB27D" class="sect5"><span class="enumeration_section">2.3.3.1</span>文件名扩展名</h5>
                     <div>
                        <div class="section">
                           <p>如果您的系统使用文件扩展名但未指定文件扩展名，Pro * COBOL将采用源文件的默认扩展名（通常为COB）。有关更多信息，请参阅Oracle系统特定的文档。 <a id="d7799e2334" class="indexterm-anchor"></a> 
                           </p>
                        </div>
                        <!-- class="section" -->
                     </div>
                  </div><a id="LNPCB182"></a><div class="props_rev_3"><a id="GUID-29FE45D4-3676-45B1-8866-AE6F3A20AA12" name="GUID-29FE45D4-3676-45B1-8866-AE6F3A20AA12"></a><h5 id="LNPCB-GUID-29FE45D4-3676-45B1-8866-AE6F3A20AA12" class="sect5"><span class="enumeration_section">2.3.3.2</span>搜索路径</h5>
                     <div>
                        <p>如果系统使用目录，则可以使用INCLUDE选项为包含的文件设置搜索路径，如下所示：</p><pre class="oac_no_warn" dir="ltr">INCLUDE = <span class="italic">路径</span> 
</pre><p>其中<span class="italic">path</span>默认为当前目录。
                        </p>
                        <p>Pro * COBOL首先搜索当前目录，然后搜索INCLUDE选项指定的目录，最后搜索标准INCLUDE文件的目录。您无需为标准文件指定路径，例如SQLCA和ORACA。但是，非标准文件需要一个路径，除非它们存储在当前目录中。<a id="d7799e2375" class="indexterm-anchor"></a></p>
                        <p>您还可以在命令行上指定多个路径，如下所示：</p><pre class="oac_no_warn" dir="ltr">...INCLUDE = &lt;path1&gt; INCLUDE = &lt;path2&gt; ...
</pre><p>指定多个路径时，Pro * COBOL首先搜索当前目录，然后搜索<span class="italic">path1</span>目录，然后搜索<span class="italic">path2</span>目录，依此类推。最后搜索包含标准INCLUDE文件的目录。路径语法是特定于系统的。有关更多信息，请参阅Oracle系统特定的文档。
                        </p>
                        <p>请记住，即使您指定了搜索路径，Pro * COBOL也会首先在当前目录中搜索文件。如果要包含的文件位于另一个目录中，请确保当前目录或搜索路径中位于其前面的任何其他目录中没有相同名称的文件。如果您的操作系统区分大小写，请确保指定存储文件的相同大小/小写文件名。<a id="d7799e2393" class="indexterm-anchor"></a></p>
                     </div>
                  </div>
               </div>
            </div><a id="LNPCB183"></a><div class="props_rev_3"><a id="GUID-A0BFB23E-4234-409F-906A-3185E866F7BC" name="GUID-A0BFB23E-4234-409F-906A-3185E866F7BC"></a><h3 id="LNPCB-GUID-A0BFB23E-4234-409F-906A-3185E866F7BC" class="sect3"><span class="enumeration_section">2.4</span>嵌套程序</h3>
               <div>
                  <p>将程序嵌套在COBOL中意味着将一个程序放在另一个程序中。包含的程序可能会引用包含它们的程序的一些资源。高级程序和嵌套程序中的名称可以相同，并且描述不同的数据项而不会发生冲突，因为名称仅在程序中是已知的。但是，可以在嵌套程序中引用更高级别程序的“配置”部分中描述的名称。</p>
                  <p>有些编译器不支持GLOBAL子句。Pro * COBOL通过生成包含GLOBAL子句的代码来支持嵌套程序。要避免无条件地生成GLOBAL子句，请指定预编译器选项NESTED = NO。 NESTED（= YES或NO）默认为YES，可以在配置文件中使用，也可以在命令行中使用，但不能内联（EXEC ORACLE语句）。</p>
                  <p>更高级别的程序可以包含多个嵌套程序。同样，嵌套程序可以嵌套在它们中的程序。必须将嵌套程序直接放在嵌套程序的END PROGRAM标头之前。</p>
                  <p>您只能通过直接或间接嵌套的程序调用嵌套程序。如果希望任何程序（甚至是嵌套树结构的不同分支上的程序）调用嵌套程序，则可以在嵌套程序的PROGRAM-ID段落中编写COMMON子句。您只能为嵌套程序编写COMMON代码：</p><pre class="oac_no_warn" dir="ltr">PROGRAM-ID。 &lt;nested-program-name&gt; COMMON。</pre><p>您可以为文件定义和级别01数据项编码GLOBAL短语（任何从属项自动变为全局）。这使得它们可以在所有子程序中直接或间接地包含在它们中。您在更高级别的程序上编码GLOBAL。如果嵌套程序定义的名称与更高级别程序中声明的GLOBAL名称相同，则COBOL使用嵌套程序中的声明。如果数据项包含REDEFINES子句，则GLOBAL必须遵循它。</p><pre class="oac_no_warn" dir="ltr">FD文件名GLOBAL ...01 data-name1 GLOBAL ...01 data-name2 REDEFINES data-name3 GLOBAL ...</pre></div>
               <div>
                  <div class="relinfo">
                     <p><strong>相关话题</strong></p>
                     <ul>
                        <li><a href="precompiler-options.html#GUID-8FA5E1B2-2B76-4BBF-BA9B-CF31814BB2D0">嵌套</a></li>
                     </ul>
                  </div>
               </div><a id="LNPCB184"></a><div class="props_rev_3"><a id="GUID-1F3428EE-D50F-4399-AE8D-0AB6E887DDEB" name="GUID-1F3428EE-D50F-4399-AE8D-0AB6E887DDEB"></a><h4 id="LNPCB-GUID-1F3428EE-D50F-4399-AE8D-0AB6E887DDEB" class="sect4"><span class="enumeration_section">2.4.1</span>支持嵌套程序</h4>
                  <div>
                     <p>Pro * COBOL使您可以将嵌套SQL的嵌套程序存储在单个源文件中。所有01级别项目在包含程序中标记为全局，并且是包含程序级别的有效主变量，可用作包含程序直接或间接包含的任何程序中的有效主变量。请考虑以下示例：</p><pre class="oac_no_warn" dir="ltr">识别部门。 PROGRAM-ID。 MAINPROG。环境部门。数据部门。工作储存部分。 EXEC SQL BEGIN DECLARE SECTION END-EXEC。 01 REC1 GLOBAL。 05 VAR1 PIC X（10）。05 VAR2 PIC X（10）。01 VAR1 PIC X（10）GLOBAL。 EXEC SQL END DECLARE SECTION END-EXEC。程序部门。 ...&lt;主要程序声明&gt; ......识别部门。 PROGRAM-ID。 NESTEDPROG。环境部门。数据部门。工作储存部分。 01 VAR1 PIC S9（4）。程序部门。 ...EXEC SQL SELECT X，Y INTO：REC1 FROM ...END-EXEC。 EXEC SQL SELECT X INTO：VAR1 FROM ...END-EXEC。 EXEC SQL SELECT X INTO：REC1。VAR1 FROM ...END-EXEC。 ...结束计划NESTEDPROG。 END PROGRAM MAINPROG。</pre><p>主程序将主机变量REC1声明为全局，因此嵌套程序可以在第一个select语句中使用REC1，而不必声明它。由于VAR1被声明为全局变量并且也是嵌套程序中的局部变量，因此第二个select语句将使用声明为S9（4）的VAR1，从而覆盖全局声明。在第三个select语句中，使用声明为PIC X（10）的REC1的全局VAR1。</p>
                     <p>上一段描述了使用DECLARE_SECTION = NO时的结果。当DECLARE_SECTION = YES时，Pro * COBOL将无法识别主变量， <span class="italic">除非</span>它们在Declare Section中声明。如果使用DECLARE_SECTION = YES预编译前面的程序，则第二个select语句将导致不明确的主变量错误。第一个和第三个select语句的功能相同。
                     </p>
                     <p>注意：不支持递归嵌套程序</p>
                  </div><a id="LNPCB185"></a><div class="props_rev_3"><a id="GUID-40835174-7D42-4B75-96ED-DD6A041E0C88" name="GUID-40835174-7D42-4B75-96ED-DD6A041E0C88"></a><h5 id="LNPCB-GUID-40835174-7D42-4B75-96ED-DD6A041E0C88" class="sect5"><span class="enumeration_section">2.4.1.1</span>声明SQLCA</h5>
                     <div>
                        <p>有关为嵌套程序声明SQLCA的信息，所提供的SQLCA定义将被声明为全局，因此仅在更高级别的程序中需要声明SQLCA。每次执行新的SQL语句时，SQLCA都可以更改。如果要在嵌套程序中声明其他SQLCA区域，则始终可以修改提供的SQLCA以删除全局规范。这也适用于SQLDA和ORACA。</p>
                     </div>
                     <div>
                        <div class="relinfo">
                           <p><strong>相关话题</strong></p>
                           <ul>
                              <li><a href="precompiler-concepts.html#GUID-BFA36F8F-0F82-45E3-8558-1CA695A3DA7B">SQLCA状态变量</a></li>
                           </ul>
                        </div>
                     </div>
                  </div><a id="LNPCB186"></a><div class="props_rev_3"><a id="GUID-0F2385E0-D11F-470C-8CEF-A4AB50D33D33" name="GUID-0F2385E0-D11F-470C-8CEF-A4AB50D33D33"></a><h5 id="LNPCB-GUID-0F2385E0-D11F-470C-8CEF-A4AB50D33D33" class="sect5"><span class="enumeration_section">2.4.1.2</span>嵌套程序示例</h5>
                     <div>
                        <p>见SAMPLE13。PCO在演示目录中<a id="d7799e2532" class="indexterm-anchor"></a> 。
                        </p>
                     </div>
                  </div>
               </div>
            </div><a id="LNPCB187"></a><div class="props_rev_3"><a id="GUID-945BCD1F-E820-4AF1-BCAD-1C09DEBA2BB0" name="GUID-945BCD1F-E820-4AF1-BCAD-1C09DEBA2BB0"></a><h3 id="LNPCB-GUID-945BCD1F-E820-4AF1-BCAD-1C09DEBA2BB0" class="sect3"><span class="enumeration_section">2.5</span>条件预编译</h3>
               <div>
                  <p>条件预编译包括（或排除）主机程序中基于特定条件的代码段。例如，您可能希望在UNIX下进行预编译时包含一段代码，而在VMS下进行预编译时则需要包含另一部分代码。条件预编译允许您编写可在不同环境中运行的程序。<a id="d7799e2561" class="indexterm-anchor"></a><a id="d7799e2565" class="indexterm-anchor"></a></p>
                  <p>条件的条件部分由定义环境和要采取的操作的语句标记。您可以在这些部分中编写主机语言语句以及EXEC SQL语句。以下语句允许您对预编译执行条件控制：<a id="d7799e2569" class="indexterm-anchor"></a><a id="d7799e2571" class="indexterm-anchor"></a><a id="d7799e2573" class="indexterm-anchor"></a><a id="d7799e2575" class="indexterm-anchor"></a><a id="d7799e2577" class="indexterm-anchor"></a></p><pre class="oac_no_warn" dir="ltr">*  - 定义符号EXEC ORACLE DEFINE符号END-EXEC。 *  - 如果符号定义为EXEC ORACLE IFDEF符号END-EXEC。 *  - 如果未定义符号，则EXEC ORACLE IFNDEF符号END-EXEC。 *  - 否则EXEC ORACLE ELSE END-EXEC。 *  - 结束此控制块EXEC ORACLE ENDIF END-EXEC。</pre><p>必须使用<code class="codeph">END-EXEC</code>终止条件语句。</p>
                  <div class="infoboxnote" id="GUID-945BCD1F-E820-4AF1-BCAD-1C09DEBA2BB0__GUID-7BCA471F-CE66-466A-BB6B-5B253873EC90">
                     <p class="notep1">注意：</p>
                     <p>Pro * COBOL可能不支持编译器的条件编译功能。</p>
                  </div>
               </div><a id="LNPCB188"></a><div class="props_rev_3"><a id="GUID-E5A46D9E-7A69-4D12-8185-2E2E3A5474A9" name="GUID-E5A46D9E-7A69-4D12-8185-2E2E3A5474A9"></a><h4 id="LNPCB-GUID-E5A46D9E-7A69-4D12-8185-2E2E3A5474A9" class="sect4"><span class="enumeration_section">2.5.1</span>一个例子</h4>
                  <div>
                     <div class="section">
                        <p>在以下示例中，仅在定义符号<span class="italic">SITE2</span>时预编译SELECT语句：<a id="d7799e2617" class="indexterm-anchor"></a></p><pre class="oac_no_warn" dir="ltr">EXEC ORACLE IFDEF SITE2 END-EXEC。 EXEC SQL SELECT DNAME INTO：DEPT-NAME FROM DEPT，DEPTNO =：DEPT-NUMBER EXEC ORACLE ENDIF END-EXEC。</pre><p>条件块可以嵌套，如以下示例所示：</p><pre class="oac_no_warn" dir="ltr">EXEC ORACLE IFDEF OUTER END-EXEC。执行ORACLE IFDEF INNER END-EXEC。 ...EXEC ORACLE ENDIF END-EXEC。 EXEC ORACLE ENDIF END-EXEC。</pre><p>您可以通过将它放在IFDEF和ENDIF之间并且<span class="italic">不</span>定义符号来“注释掉”主机语言或嵌入式SQL代码。
                        </p>
                     </div>
                     <!-- class="section" -->
                  </div>
               </div><a id="LNPCB189"></a><div class="props_rev_3"><a id="GUID-1252DB09-4F2B-4717-8591-CA2BEA1C49B5" name="GUID-1252DB09-4F2B-4717-8591-CA2BEA1C49B5"></a><h4 id="LNPCB-GUID-1252DB09-4F2B-4717-8591-CA2BEA1C49B5" class="sect4"><span class="enumeration_section">2.5.2</span>定义符号</h4>
                  <div>
                     <div class="section">
                        <p>您可以通过两种方式定义符号。要么包括声明<a id="d7799e2657" class="indexterm-anchor"></a></p><pre class="oac_no_warn" dir="ltr">EXEC ORACLE DEFINE符号END-EXEC。</pre><p>在您的主机程序中或使用语法在命令行上定义符号</p><pre class="oac_no_warn" dir="ltr">...INAME =文件名...DEFINE =符号</pre><p><span class="italic">符号</span>不区分大小写。
                        </p>
                        <p>在系统上安装Pro * COBOL时，会为您预定义某些特定于端口的符号。例如，预定义的操作系统符号包括CMS，MVS，UNIX和VMS。</p>
                        <div class="infoboxnote" id="GUID-1252DB09-4F2B-4717-8591-CA2BEA1C49B5__GUID-A1F9FCF9-D2D5-4031-B1F1-71AF37E85CA6">
                           <p class="notep1">注意：</p>
                           <p>DEFINE SYMBOL名称以数字开头，或者包含破折号，在预编译期间会导致不可恢复的错误。您可以使用下划线，并且可以使用除DEFINE SYMBOL名称开头之外的数字。</p>
                        </div>
                     </div>
                     <!-- class="section" -->
                  </div>
               </div>
            </div><a id="LNPCB190"></a><div class="props_rev_3"><a id="GUID-5BBB2EA7-C46D-4D4F-B9BB-77668B2D9153" name="GUID-5BBB2EA7-C46D-4D4F-B9BB-77668B2D9153"></a><h3 id="LNPCB-GUID-5BBB2EA7-C46D-4D4F-B9BB-77668B2D9153" class="sect3"><span class="enumeration_section">2.6</span>单独的预编译</h3>
               <div>
                  <p>您可以单独预编译多个COBOL程序模块，然后将它们链接到一个可执行程序中。这支持模块化编程，当程序的功能组件由不同的程序员编写和调试时，这是必需的。各个程序模块不需要用同一种语言编写。<a id="d7799e2702" class="indexterm-anchor"></a></p>
               </div><a id="LNPCB191"></a><div class="props_rev_3"><a id="GUID-1812416E-8E90-45F4-A219-13175B8E66E5" name="GUID-1812416E-8E90-45F4-A219-13175B8E66E5"></a><h4 id="LNPCB-GUID-1812416E-8E90-45F4-A219-13175B8E66E5" class="sect4"><span class="enumeration_section">2.6.1</span>指南</h4>
                  <div>
                     <p>以下指南将帮助您避免一些常见问题。<a id="d7799e2730" class="indexterm-anchor"></a><a id="d7799e2734" class="indexterm-anchor"></a></p>
                  </div><a id="LNPCB192"></a><div class="props_rev_3"><a id="GUID-B8F861D7-F6A1-4112-BB9A-A795E43F7EA6" name="GUID-B8F861D7-F6A1-4112-BB9A-A795E43F7EA6"></a><h5 id="LNPCB-GUID-B8F861D7-F6A1-4112-BB9A-A795E43F7EA6" class="sect5"><span class="enumeration_section">2.6.1.1</span>引用游标</h5>
                     <div>
                        <p>游标名称是SQL标识符，其范围是预编译单元。因此，游标操作不能跨越预编译单元（文件）。也就是说，您不能在一个文件中声明游标并在另一个文件中打开或从中获取游标，因此在进行单独的预编译时，请确保对给定游标的所有定义和引用都在一个文件中。<a id="d7799e2762" class="indexterm-anchor"></a><a id="d7799e2766" class="indexterm-anchor"></a></p>
                     </div>
                  </div><a id="LNPCB193"></a><div class="props_rev_3"><a id="GUID-E63C977F-973B-4285-8D5C-82C6EA62F34B" name="GUID-E63C977F-973B-4285-8D5C-82C6EA62F34B"></a><h5 id="LNPCB-GUID-E63C977F-973B-4285-8D5C-82C6EA62F34B" class="sect5"><span class="enumeration_section">2.6.1.2</span>指定MAXOPENCURSORS</h5>
                     <div>
                        <div class="section">
                           <p>预编译连接到Oracle的程序模块时，请为MAXOPENCURSORS指定一个足以支持任何程序模块的值。如果将其用于其他程序模块，则忽略MAXOPENCURSORS。在运行时仅使用对连接有效的值。<a id="d7799e2795" class="indexterm-anchor"></a><a id="d7799e2799" class="indexterm-anchor"></a></p>
                        </div>
                        <!-- class="section" -->
                     </div>
                  </div><a id="LNPCB194"></a><div class="props_rev_3"><a id="GUID-9BB4F454-0D93-4721-B5EC-708373A1915D" name="GUID-9BB4F454-0D93-4721-B5EC-708373A1915D"></a><h5 id="LNPCB-GUID-9BB4F454-0D93-4721-B5EC-708373A1915D" class="sect5"><span class="enumeration_section">2.6.1.3</span>使用单个SQLCA</h5>
                     <div>
                        <div class="section">
                           <p><a id="d7799e2828" class="indexterm-anchor"></a><a id="d7799e2832" class="indexterm-anchor"></a>如果您只想为SQLCA使用一个内存区域，则执行此操作的过程取决于您使用的Pro * COBOL版本。
                           </p>
                        </div>
                        <!-- class="section" -->
                     </div><a id="LNPCB195"></a><div class="props_rev_3"><a id="GUID-F85437B3-C029-4711-8999-33530662242D" name="GUID-F85437B3-C029-4711-8999-33530662242D"></a><h6 id="LNPCB-GUID-F85437B3-C029-4711-8999-33530662242D" class="sect6"><span class="enumeration_section">2.6.1.3.1</span>版本1.8及更低版本</h6>
                        <div>
                           <div class="section">
                              <p>您必须在全球范围内声明SQLCA。您可以通过修改SQLCA.COB文件，更改行来完成此操作</p><pre class="oac_no_warn" dir="ltr">01 SQLCA。</pre><p>至</p><pre class="oac_no_warn" dir="ltr">01 SQLCA EXTERNAL。</pre><p>或者，您可以包含SQLCA的硬编码定义，从SQLCA.cob复制并进行上述更改。请注意，您仍需要在每个预编译单元中包含SQLCA的定义。</p>
                           </div>
                           <!-- class="section" -->
                        </div>
                     </div><a id="LNPCB196"></a><div class="props_rev_3"><a id="GUID-AC037535-1828-4372-9148-EFE2FBBA1501" name="GUID-AC037535-1828-4372-9148-EFE2FBBA1501"></a><h6 id="LNPCB-GUID-AC037535-1828-4372-9148-EFE2FBBA1501" class="sect6"><span class="enumeration_section">2.6.1.3.2</span>版本2及更高版本</h6>
                        <div>
                           <div class="section">
                              <p>在Pro * COBOL的更高版本中，不会从文件系统复制SQLCA。它由预编译器生成。如果您需要在这些版本中共享SQLCA结构，而不是此声明：</p><pre class="oac_no_warn" dir="ltr">EXEC SQL包含SQLCA END-EXEC</pre><p>你应该使用以下代码：</p><pre class="oac_no_warn" dir="ltr">EXEC SQL包含SQLCA.ANX END-EXEC</pre><p>这会导致预编译器生成SQLCA结构，并自动添加EXTERNAL关键字。</p>
                           </div>
                           <!-- class="section" -->
                        </div>
                     </div>
                  </div><a id="LNPCB197"></a><div class="props_rev_3"><a id="GUID-12E6B06A-96DB-4B89-894A-086D4E7A8462" name="GUID-12E6B06A-96DB-4B89-894A-086D4E7A8462"></a><h5 id="LNPCB-GUID-12E6B06A-96DB-4B89-894A-086D4E7A8462" class="sect5"><span class="enumeration_section">2.6.1.4</span>使用单个DATE_FORMAT</h5>
                     <div>
                        <p>您必须在每个程序模块中为DATE使用相同的格式字符串。</p>
                     </div>
                  </div>
               </div><a id="LNPCB198"></a><div class="props_rev_3"><a id="GUID-7A74C512-A874-46DE-957E-6D92E748B4E9" name="GUID-7A74C512-A874-46DE-957E-6D92E748B4E9"></a><h4 id="LNPCB-GUID-7A74C512-A874-46DE-957E-6D92E748B4E9" class="sect4"><span class="enumeration_section">2.6.2</span>限制</h4>
                  <div>
                     <p>对显式游标的所有引用必须位于同一程序文件中。您不能对在其他模块中声明的游标执行操作。有关游标的更多信息，请参见第4章。<a id="d7799e2951" class="indexterm-anchor"></a></p>
                     <p>此外，任何包含SQL语句的程序文件都必须具有本地SQL语句范围内的SQLCA。</p>
                  </div>
               </div>
            </div><a id="LNPCB199"></a><div class="props_rev_3"><a id="GUID-E1191EB4-BD6B-4EB7-B20E-51C92F86AEDC" name="GUID-E1191EB4-BD6B-4EB7-B20E-51C92F86AEDC"></a><h3 id="LNPCB-GUID-E1191EB4-BD6B-4EB7-B20E-51C92F86AEDC" class="sect3"><span class="enumeration_section">2.7</span>编译和链接</h3>
               <div>
                  <p>要获得可执行程序，必须编译Pro * COBOL生成的源文件，然后将生成的对象模块与SQLLIB和系统特定的Oracle库所需的任何模块相链接。 <a id="d7799e2981" class="indexterm-anchor"></a><a id="d7799e2983" class="indexterm-anchor"></a> 
                  </p>
                  <p>链接器解析对象模块中的符号引用。如果这些引用冲突，则链接失败。当您尝试将第三方软件链接到预编译程序时，可能会发生此类冲突。并非所有第三方软件都与Oracle兼容，因此您可能会遇到问题。请与Oracle支持服务部门联系，了解该软件是否受支持。</p>
                  <p>编译和链接是系统相关的。例如，在某些系统上，必须在编译宿主语言程序时关闭编译器优化。有关说明，请参阅特定于系统的Oracle手册。</p>
               </div>
            </div><a id="LNPCB200"></a><div class="props_rev_3"><a id="GUID-1BA76AA5-1C9E-45FA-88BE-B6A5BF0DA5BA" name="GUID-1BA76AA5-1C9E-45FA-88BE-B6A5BF0DA5BA"></a><h3 id="LNPCB-GUID-1BA76AA5-1C9E-45FA-88BE-B6A5BF0DA5BA" class="sect3"><span class="enumeration_section">2.8</span>样本DEPT和EMP表</h3>
               <div>
                  <p>本指南中的大多数完整程序示例使用两个示例数据库表：DEPT和EMP。如果它们不在您的演示目录中，请在运行示例程序之前创建它们。他们的定义如下：<a id="d7799e3014" class="indexterm-anchor"></a><a id="d7799e3018" class="indexterm-anchor"></a><a id="d7799e3022" class="indexterm-anchor"></a><a id="d7799e3024" class="indexterm-anchor"></a></p><pre class="oac_no_warn" dir="ltr">CREATE TABLE DEPT（DEPTNO NUMBER（2），DNAME VARCHAR2（14），LOC VARCHAR2（13））; CREATE TABLE EMP（EMPNO NUMBER（4）主键，ENAME VARCHAR2（10），JOB VARCHAR2（9），MGR NUMBER（4），HIREDATE DATE，SAL NUMBER（7,2），COMM COMMBER（7,2），DEPTNO 2号））;</pre></div><a id="LNPCB201"></a><div class="props_rev_3"><a id="GUID-8E8843F1-852C-40E9-8F96-C0BFDA8BABD2" name="GUID-8E8843F1-852C-40E9-8F96-C0BFDA8BABD2"></a><h4 id="LNPCB-GUID-8E8843F1-852C-40E9-8F96-C0BFDA8BABD2" class="sect4"><span class="enumeration_section">2.8.1</span>样本DEPT和EMP数据</h4>
                  <div>
                     <p>DEPT和EMP表分别包含以下数据行：</p><pre class="oac_no_warn" dir="ltr">DEPTNO DNAME LOC ------- ---------- --------- 10会计纽约20研究DALLAS 30销售芝加哥40运营波士顿EMPNO ENAME JOB MGR HIREDATE SAL COMM DEPTNO ----- ------- --------- ------ --------- ------ ------  - ----- 7369 SMITH CLERK 7902 17-DEC-80 800 20 7499 ALLEN SALESMAN 7698 20-FEB-81 1600 300 30 7521 WARD SALESMAN 7698 22-FEB-81 1250 500 30 7566 JONES MANAGER 7839 02-APR-81 2975 20 7654 MARTIN SALESMAN 7698 28-SEP-81 1250 1400 30 7698 BLAKE MANAGER 7839 01-MAY-81 2850 30 7782 CLARK MANAGER 7839 09-JUN-81 2450 10 7788 SCOTT ANALYST 7566 19-APR-87 3000 20 7839 KING PRESIDENT 17 -NOV-81 5000 10 7844 TURNER SALESMAN 7698 08-SEP-81 1500 30 7876 ADAMS CLERK 7788 23-MAY-87 1100 20 7900 JAMES CLERK 7698 03-DEC-81 950 30 7902 FORD ANALYST 7566 03-DEC-81 3000 20 7934 MILLER CLERK 7782 23-JAN-82 1300 10</pre></div>
               </div>
            </div><a id="LNPCB202"></a><div class="props_rev_3"><a id="GUID-6BDE80F2-4970-4D3B-9AE5-CCA82ADE333D" name="GUID-6BDE80F2-4970-4D3B-9AE5-CCA82ADE333D"></a><h3 id="LNPCB-GUID-6BDE80F2-4970-4D3B-9AE5-CCA82ADE333D" class="sect3"><span class="enumeration_section">2.9</span>样本EMP计划：SAMPLE1。PCO</h3>
               <div>
                  <p>熟悉嵌入式SQL的一个好方法是查看程序示例。该程序是SAMPLE1。PCO在<code class="codeph">demo</code>目录中。
                  </p>
                  <p>程序登录到数据库，提示用户输入员工编号，在数据库表EMP中查询员工姓名，工资和佣金。选定的结果存储在主机变量EMP-NAME，SALARY和COMMISSION中。该程序使用主机指示符变量COMM-IND来检测列COMMISSION中的NULL值。</p>
                  <p>然后段落DISPLAY-INFO显示结果。</p>
                  <p>错误7225844  - 以下替代EMP-NAME的替代EMP-NAME</p>
                  <p>COBOL变量USERNAME，PASSWD和EMP-NAME使用VARYING子句声明，这使您可以使用名为VARCHAR的可变长度字符串外部Oracle数据类型。</p>
                  <p>包含SQLCA通信区域以处理错误。如果发生错误，则执行段落SQL-ERROR。</p>
                  <p>除非您将预编译器选项DECLARE_SECTION设置为YES，或选项MODE设置为ANSI，否则使用的BEGIN DECLARE SECTION和END DECLARE SECTION语句是可选的。</p>
                  <p>WHENEVER语句用于处理错误。</p>
                  <p>当用户输入零员工编号时，程序结束<a id="d7799e3104" class="indexterm-anchor"></a> 。
                  </p>
                  <div class="infoboxnote" id="GUID-6BDE80F2-4970-4D3B-9AE5-CCA82ADE333D__GUID-C2DFA7D5-EA8F-4EAF-912C-7AE2EA4AA981">
                     <p class="notep1">注意：</p>
                     <p>为了简化演示此功能，此示例不执行已部署系统通常使用的密码管理技术。在生产环境中，请遵循Oracle数据库密码管理准则，并禁用任何示例帐户。有关密码管理指南和其他安全建议，请参阅<a href="../dbseg/managing-security-for-application-developers.html#DBSEG50053" target="_blank"><span class="italic">Oracle数据库安全指南</span></a> 。
                     </p>
                  </div><pre class="oac_no_warn" dir="ltr">*此程序登录到ORACLE，提示用户输入员工编号，*在数据库中查询员工的姓名，工资和佣金，然后*显示结果。当用户输入0时程序终止。* ID DIVISION。 PROGRAM-ID。 QUERY。环境部门。数据部门。工作储存部分。 EXEC SQL BEGIN DECLARE SECTION END-EXEC。 01 USERNAME PIC X（10）变化。 01 PASSWD PIC X（10）变化。 01 EMP-REC-VARS。 05 EMP-NAME PIC X（10）变化。 05 EMP-NUMBER PIC S9（4）COMP VALUE ZERO。 05 SALARY PIC S9（5）V99 COMP-3 VALUE ZERO。 05委员会PIC S9（5）V99 COMP-3 VALUE ZERO。 05 COMM-IND PIC S9（4）COMP VALUE ZERO。 EXEC SQL END DECLARE SECTION END-EXEC。 EXEC SQL包含SQLCA END-EXEC。 01 DISPLAY-VARIABLES。 05 D-EMP-NAME PIC X（10）。05 D-SALARY PIC Z（4）9.99。05 D-COMMISSION PIC Z（4）9.99。05 D-EMP-NUMBER PIC 9（4）。01 D-TOTAL-QUERIED PIC 9（4）VALUE ZERO。程序部门。 BEGIN-PGM。执行SQL WHENEVER SQLERROR执行SQL-ERROR END-EXEC。表演登录。查询循环。显示“”。显示“输入EMP编号（0退出）：”没有进展。接受D-EMP-NUMBER。将D-EMP-NUMBER移至EMP-NUMBER。 IF（EMP-NUMBER = 0）执行签名。向EMP-NAME-ARR移动空间。 EXEC SQL WHENEVER未找到GOTO NO-EMP END-EXEC。 EXEC SQL SELECT ENAME，SAL，NVL（COMM，0）INTO：EMP-NAME，：SALARY，：COMMISSION：COMM-IND from EMP WHERE EMPNO =：EMP-NUMBER END-EXEC。执行显示信息。添加1到D-TOTAL-QUERIED。转到QUERY-LOOP。 NO-EMP。显示“不是有效的员工人数 - 再试一次。”转到QUERY-LOOP。登录。将“SCOTT”移至USERNAME-ARR。移动5到USERNAME-LEN。将“TIGER”转移到PASSWD-ARR。移动5到PASSWD-LEN。 EXEC SQL CONNECT：USERNAME IDENTIFIED BY：PASSWD END-EXEC。显示“”。显示“连接到ORACLE作为用户：”，USERNAME-ARR。 DISPLAY-INFO。显示“”。展示“员工薪酬委员会”。显示“-------- ------ ----------”。将EMP-NAME-ARR移动到D-EMP-NAME。将薪酬转移到D-SALARY。如果COMM-IND = -1显示D-EMP-NAME，D-SALARY，“NULL”ELSE将委托转移到D-COMMISSION显示D-EMP-NAME，D-SALARY，“”，D-COMMISSION END-IF。登出。显示“”。显示“TULLAL NUMBER QUERIED WAS”，D-TOTAL-QUERIED，“。”。显示“”。显示“有一个好日子。”显示“”。EXEC SQL COMMIT WORK RELEASE END-EXEC。停止运行。 SQL-ERROR。执行SQL WHENEVER SQLERROR CONTINUE END-EXEC。显示“”。显示“ORACLE ERROR DETECTED：”。显示“”。显示SQLERRMC。 EXEC SQL ROLLBACK工作发布END-EXEC。停止运行。</pre></div>
               <div>
                  <div class="relinfo">
                     <p><strong>相关话题</strong></p>
                     <ul>
                        <li><a href="error-handling-and-diagnostics.html#GUID-07B14FDA-015C-4922-963E-6D4CBEDB9743">使用SQL通信区域</a></li>
                        <li><a href="precompiler-options.html#GUID-976DED3A-3840-48A5-B5A8-35FB91BF2A0D">模式</a></li>
                        <li><a href="error-handling-and-diagnostics.html#GUID-A947AF06-314B-46B3-9940-A3002EC04039">WHENEVER指令</a></li>
                     </ul>
                  </div>
               </div>
            </div>
         </div>
      </article>
   </body>
</html>