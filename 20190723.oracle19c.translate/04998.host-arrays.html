<html lang="en-us" dir="ltr" xml:lang="en-us">
   <head>
      <meta http-equiv="Content-Type" content="text/html; charset=utf-8"></meta>
      <meta name="viewport" content="width=device-width, initial-scale=1"></meta>
      <meta http-equiv="X-UA-Compatible" content="IE=edge"></meta>
      <title>主机阵列</title>
      <meta property="og:site_name" content="Oracle Help Center"></meta>
      <meta property="og:title" content="Programmer&#39;s Guide"></meta>
      <meta property="og:description" content=""></meta>
      <link rel="stylesheet" href="/sp_common/book-template/ohc-book-template/css/book.css"></link>
      <link rel="shortcut icon" href="/sp_common/book-template/ohc-common/img/favicon.ico"></link>
      <meta name="application-name" content="Programmer&#39;s Guide"></meta>
      <meta name="generator" content="DITA Open Toolkit version 1.8.5 (Mode = doc)"></meta>
      <meta name="plugin" content="SP_docbuilder HTML plugin release 18.2.2"></meta>
      <link rel="alternate" href="c-c-programmers-guide.pdf" title="PDF File" type="application/pdf"></link>
      <meta name="robots" content="all"></meta>
      <link rel="schema.dcterms" href="http://purl.org/dc/terms/"></link>
      <meta name="dcterms.created" content="2019-01-11T03:52:01-08:00"></meta>
      
      <meta name="dcterms.dateCopyrighted" content="1996, 2019"></meta>
      <meta name="dcterms.category" content="database"></meta>
      <meta name="dcterms.identifier" content="E96467-01"></meta>
      
      <meta name="dcterms.product" content="en/database/oracle/oracle-database/19"></meta>
      
      <link rel="prev" href="embedded-PL-SQL.html" title="Previous" type="text/html"></link>
      <link rel="next" href="handling-run-time-errors.html" title="Next" type="text/html"></link>
      <script>
        document.write('<style type="text/css">');
        document.write('body > .noscript, body > .noscript ~ * { visibility: hidden; }');
        document.write('</style>');
     </script>
      <script src="/sp_common/book-template/requirejs/require.js" data-main="/sp_common/book-template/ohc-book-template/js/book-config"></script>
      <script>
            if (window.require === undefined) {
                document.write('<script data-main="sp_common/book-template/ohc-book-template/js/book-config" src="sp_common/book-template/requirejs/require.js"><\/script>');
                document.write('<link href="sp_common/book-template/ohc-book-template/css/book.css" rel="stylesheet"/>');
            }
        </script>
      <script type="application/json" id="ssot-metadata">{"primary":{"category":{"short_name":"database","element_name":"Database","display_in_url":true},"suite":{"short_name":"oracle","element_name":"Oracle","display_in_url":true},"product_group":{"short_name":"not-applicable","element_name":"Not applicable","display_in_url":false},"product":{"short_name":"oracle-database","element_name":"Oracle Database","display_in_url":true},"release":{"short_name":"19","element_name":"Release 19","display_in_url":true}}}</script>
      
    <meta name="dcterms.title" content="Pro*C/C++ Programmer&#39;s Guide"></meta>
    <meta name="dcterms.isVersionOf" content="LNPCC"></meta>
    <meta name="dcterms.release" content="Release 19"></meta>
  </head>
   <body dir="ltr">
      <div class="noscript alert alert-danger text-center" role="alert">
         <a href="embedded-PL-SQL.html" class="pull-left"><span class="glyphicon glyphicon-chevron-left" aria-hidden="true"></span>上一页</a> <a href="handling-run-time-errors.html" class="pull-right">下一页<span class="glyphicon glyphicon-chevron-right" aria-hidden="true"></span></a> <span class="fa fa-exclamation-triangle" aria-hidden="true"></span>必须启用JavaScript才能正确显示此内容</div>
      <article>
         <header>
            <ol class="breadcrumb" vocab="http://schema.org/" typeof="BreadcrumbList">
               <li property="itemListElement" typeof="ListItem"><a href="index.html" property="item" typeof="WebPage"><span property="name">程序员指南</span></a></li>
               <li property="itemListElement" typeof="ListItem"><a href="introduction-and-concepts.html" property="item" typeof="WebPage"><span property="name">介绍和概念</span></a></li>
               <li class="active" property="itemListElement" typeof="ListItem">主机阵列</li>
            </ol>
            <a id="GUID-6B57FBAE-0303-41B9-9056-5C20384442B7" name="GUID-6B57FBAE-0303-41B9-9056-5C20384442B7"></a>
            
            <h2 id="LNPCC-GUID-6B57FBAE-0303-41B9-9056-5C20384442B7" class="sect2"><span class="enumeration_chapter">8个</span>主机阵列</h2>
         </header>
         <div class="ind">
            <div>
               <p><a id="d40176e6" class="indexterm-anchor"></a>本章介绍如何使用数组来简化编码并提高程序性能。您将学习如何使用数组操作Oracle数据，如何使用单个SQL语句操作数组的所有元素，以及如何限制处理的数组元素的数量。本章包含以下主题：</p>
               <ul style="list-style-type:disc">
                  <li>
                     <p><a href="host-arrays.html#GUID-686DE5C3-8BB0-4C69-9810-47D56F4919AF">为什么要使用数组？</a></p>
                  </li>
                  <li>
                     <p><a href="host-arrays.html#GUID-C0A64DDB-0282-46F6-ABAB-13047958B085">关于声明主机阵列</a></p>
                  </li>
                  <li>
                     <p><a href="host-arrays.html#GUID-D103007D-E544-4516-A1CB-826978F67C2B">关于在SQL语句中使用数组</a></p>
                  </li>
                  <li>
                     <p><a href="host-arrays.html#GUID-55DA6D6C-60A9-4F6B-ADF6-18C08B872147">关于选择数组</a></p>
                  </li>
                  <li>
                     <p><a href="host-arrays.html#GUID-2D0C9C7F-368A-4157-9F5C-8141072D9EB2">关于使用数组插入</a></p>
                  </li>
                  <li>
                     <p><a href="host-arrays.html#GUID-755F6669-A311-454A-A561-93FA79BF6BDD">关于使用数组更新</a></p>
                  </li>
                  <li>
                     <p><a href="host-arrays.html#GUID-DE60CE32-DF13-4969-A83D-C338C0A866BD">关于使用数组删除</a></p>
                  </li>
                  <li>
                     <p><a href="host-arrays.html#GUID-A5ABD676-CF67-4EFF-82A4-82D94A653DD0">关于使用FOR子句</a></p>
                  </li>
                  <li>
                     <p><a href="host-arrays.html#GUID-D831124D-EB14-4CF6-9EE6-D76AFA331FE3">关于使用WHERE子句</a></p>
                  </li>
                  <li>
                     <p><a href="host-arrays.html#GUID-861203A7-309A-4A33-A6B8-89B10B36E0C4">结构数组</a></p>
                  </li>
                  <li>
                     <p><a href="host-arrays.html#GUID-DBA71301-C6C4-47C0-BAB5-1B6B221AB46E">关于模仿当前的</a></p>
                  </li>
                  <li>
                     <p><a href="host-arrays.html#GUID-989279AF-E176-41C7-A2D0-84685367DA54">关于使用sqlca.sqlerrd [2]</a></p>
                  </li>
                  <li>
                     <p><a href="host-arrays.html#GUID-D71CE5C4-383A-4B6A-994A-2E3C321EA408">关于使用其他数组插入/选择语法</a></p>
                  </li>
                  <li>
                     <p><a href="host-arrays.html#GUID-DBC05FB2-D78C-4FF2-83F8-9D382F0F3786">关于使用隐式缓冲插入</a></p>
                  </li>
               </ul>
            </div><a id="LNPCC3434"></a><div class="props_rev_3"><a id="GUID-686DE5C3-8BB0-4C69-9810-47D56F4919AF" name="GUID-686DE5C3-8BB0-4C69-9810-47D56F4919AF"></a><h3 id="LNPCC-GUID-686DE5C3-8BB0-4C69-9810-47D56F4919AF" class="sect3"><span class="enumeration_section">8.1</span>为什么要使用数组？
               </h3>
               <div>
                  <p>阵列减少了编程时间并提高了性能。 <a id="d40176e94" class="indexterm-anchor"></a> 
                  </p>
                  <p>对于数组，您可以使用单个SQL语句操作整个数组。因此，Oracle通信开销显着降低，尤其是在网络环境中。运行时的主要部分用于客户端程序和服务器数据库之间的网络往返。数组减少往返次数。</p>
                  <p>例如，假设您要将有关300名员工的信息插入EMP表。如果没有数组，您的程序必须执行300个单独的INSERT  - 每个员工一个。对于数组，只需要完成一个INSERT。</p>
               </div>
            </div><a id="LNPCC3435"></a><div class="props_rev_3"><a id="GUID-C0A64DDB-0282-46F6-ABAB-13047958B085" name="GUID-C0A64DDB-0282-46F6-ABAB-13047958B085"></a><h3 id="LNPCC-GUID-C0A64DDB-0282-46F6-ABAB-13047958B085" class="sect3"><span class="enumeration_section">8.2</span>关于声明主机阵列</h3>
               <div>
                  <p>以下示例声明了三个主机阵列，每个阵列最多包含50个元素： <a id="d40176e114" class="indexterm-anchor"></a><a id="d40176e118" class="indexterm-anchor"></a><a id="d40176e122" class="indexterm-anchor"></a><a id="d40176e126" class="indexterm-anchor"></a> 
                  </p><pre class="oac_no_warn" dir="ltr">char emp_name [50] [10]; int emp_number [50];浮动工资[50];</pre><p>VARCHAR的数组也是允许的。以下声明是有效的宿主语言声明：<a id="d40176e135" class="indexterm-anchor"></a></p><pre class="oac_no_warn" dir="ltr">VARCHAR v_array [10] [30];</pre></div><a id="LNPCC3436"></a><div class="props_rev_3"><a id="GUID-FC842FBE-6DA7-4A0C-B99C-4BE958AEA531" name="GUID-FC842FBE-6DA7-4A0C-B99C-4BE958AEA531"></a><h4 id="LNPCC-GUID-FC842FBE-6DA7-4A0C-B99C-4BE958AEA531" class="sect4"><span class="enumeration_section">8.2.1</span>限制（声明主机阵列）</h4>
                  <div>
                     <p>除对象类型外，您不能声明指针的主机数组。<a id="d40176e152" class="indexterm-anchor"></a></p>
                     <p>除字符数组（字符串）外，可能在SQL语句中引用的主机数组仅限于一个维度。因此，以下示例中声明的二维数组<span class="italic">无效</span> ： <a id="d40176e161" class="indexterm-anchor"></a><a id="d40176e165" class="indexterm-anchor"></a> 
                     </p><pre class="oac_no_warn" dir="ltr">int hi_lo_scores [25] [25]; /* 不允许 */</pre></div>
               </div><a id="LNPCC3437"></a><div class="props_rev_3"><a id="GUID-115E5EFA-AEA2-4028-8FAB-F6A220F30E8A" name="GUID-115E5EFA-AEA2-4028-8FAB-F6A220F30E8A"></a><h4 id="LNPCC-GUID-115E5EFA-AEA2-4028-8FAB-F6A220F30E8A" class="sect4"><span class="enumeration_section">8.2.2</span>阵列的最大尺寸</h4>
                  <div>
                     <p>在一次获取中可访问的SQL语句中的最大数组元素数是32K（或者可能更大，具体取决于平台和可用内存）。如果您尝试访问超过最大值的数字，则会出现“参数超出范围”运行时错误。如果该语句是匿名PL / SQL块，则可访问的数组元素数限制为32512除以数据类型的大小。</p>
                  </div>
               </div>
            </div><a id="LNPCC3438"></a><div class="props_rev_3"><a id="GUID-D103007D-E544-4516-A1CB-826978F67C2B" name="GUID-D103007D-E544-4516-A1CB-826978F67C2B"></a><h3 id="LNPCC-GUID-D103007D-E544-4516-A1CB-826978F67C2B" class="sect3"><span class="enumeration_section">8.3</span>关于在SQL语句中使用数组</h3>
               <div>
                  <p>您可以在INSERT，UPDATE和DELETE语句中将主机数组用作输入变量，在SELECT和FETCH语句的INTO子句中使用输出变量。 <a id="d40176e195" class="indexterm-anchor"></a><a id="d40176e200" class="indexterm-anchor"></a> 
                  </p>
                  <p>用于主机阵列和简单主机变量的嵌入式SQL语法几乎相同。一个区别是可选的FOR子句，它允许您控制数组处理。此外，在SQL语句中混合主机数组和简单主机变量存在限制。</p>
                  <p>以下部分说明了在数据操作语句中使用主机数组。</p>
               </div><a id="LNPCC3439"></a><div class="props_rev_3"><a id="GUID-9F81B600-4AB8-4A67-9CC9-347BBA9B5E54" name="GUID-9F81B600-4AB8-4A67-9CC9-347BBA9B5E54"></a><h4 id="LNPCC-GUID-9F81B600-4AB8-4A67-9CC9-347BBA9B5E54" class="sect4"><span class="enumeration_section">8.3.1</span>关于引用主机阵列</h4>
                  <div>
                     <p>如果在单个SQL语句中使用多个主机数组，则它们的元素数应相同。否则，在预编译时发出“数组大小不匹配”警告消息。如果忽略此警告，预编译器将使用<span class="italic">最少</span>数量的元素进行SQL操作。 <a id="d40176e223" class="indexterm-anchor"></a> 
                     </p>
                     <p>在此示例中，只有25行<a id="d40176e230" class="indexterm-anchor"></a><a id="d40176e234" class="indexterm-anchor"></a>插入<a id="d40176e239" class="indexterm-anchor"></a> 
                     </p><pre class="oac_no_warn" dir="ltr">int emp_number [50]; char emp_name [50] [10]; int dept_number [25]; / *在这里填充主机数组。* / EXEC SQL INSERT INTO emp（empno，ename，deptno）VALUES（：emp_number，：emp_name，：dept_number）;</pre><p>可以在SQL语句中下标主机数组，并在循环中使用它们来INSERT或获取数据。例如，您可以使用循环插入数组中的每个第五个元素，例如：</p><pre class="oac_no_warn" dir="ltr">for（i = 0; i &lt;50; i + = 5）EXEC SQL INSERT INTO emp（empno，deptno）VALUES（：emp_number [i]，：dept_number [i]）;</pre><p>但是，如果需要处理的数组元素是连续的，则不应在循环中处理主机数组。只需在SQL语句中使用非脚本化数组名称即可。Oracle将包含元素编号为<span class="italic">n的</span>主机数组的SQL语句视为使用<span class="italic">n个</span>不同标量变量执行<span class="italic">n</span>次的相同语句。
                     </p>
                  </div>
               </div><a id="LNPCC3440"></a><div class="props_rev_3"><a id="GUID-16D5559F-DE3C-4F7B-8A65-42A5AE4008CF" name="GUID-16D5559F-DE3C-4F7B-8A65-42A5AE4008CF"></a><h4 id="LNPCC-GUID-16D5559F-DE3C-4F7B-8A65-42A5AE4008CF" class="sect4"><span class="enumeration_section">8.3.2</span>关于使用指标数组</h4>
                  <div>
                     <p>您可以使用指示符数组将NULL分配给输入主机数组，并检测输出主机数组中的NULL或截断值（仅限字符列）。以下示例显示如何使用指示符数组进行INSERT： <a id="d40176e276" class="indexterm-anchor"></a><a id="d40176e280" class="indexterm-anchor"></a> 
                     </p><pre class="oac_no_warn" dir="ltr">int emp_number [50]; int dept_number [50];浮动佣金[50];简短的comm_ind [50]; / * indicator array * / / *填充主机和指示器阵列。要在comm列中插入null，请将-1分配给指示符数组中的相应元素。* / EXEC SQL INSERT INTO emp（empno，deptno，comm）VALUES（：emp_number，：dept_number，：Commission INDICATOR：comm_ind）;</pre></div>
               </div><a id="LNPCC3441"></a><div class="props_rev_3"><a id="GUID-15264290-896F-4D4A-90DF-ABABECD6A337" name="GUID-15264290-896F-4D4A-90DF-ABABECD6A337"></a><h4 id="LNPCC-GUID-15264290-896F-4D4A-90DF-ABABECD6A337" class="sect4"><span class="enumeration_section">8.3.3</span> Oracle限制（针对主机阵列）</h4>
                  <div>
                     <p>混合主机阵列标主机变量中的值，SET，进入或WHERE子句是<span class="italic">不允许</span>的。如果任何主机变量是一个数组，则所有主变量都必须是数组。 <a id="d40176e302" class="indexterm-anchor"></a><a id="d40176e306" class="indexterm-anchor"></a> 
                     </p>
                     <p>你不能使用主机阵列<a id="d40176e313" class="indexterm-anchor"></a><a id="d40176e315" class="indexterm-anchor"></a> UPDATE或DELETE语句中的CURRENT OF子句。
                     </p>
                  </div>
               </div><a id="LNPCC3442"></a><div class="props_rev_3"><a id="GUID-BC49BCAA-B08F-44E2-A1BC-060F24582456" name="GUID-BC49BCAA-B08F-44E2-A1BC-060F24582456"></a><h4 id="LNPCC-GUID-BC49BCAA-B08F-44E2-A1BC-060F24582456" class="sect4"><span class="enumeration_section">8.3.4</span> ANSI限制和要求</h4>
                  <div>
                     <p>阵列接口是ANSI / ISO嵌入式SQL标准的Oracle扩展。但是，当您使用MODE = ANSI进行预编译时，仍然允许使用数组SELECT和FETCH。如果需要，可以使用FIPS flagger预编译器选项标记数组的使用。<a id="d40176e331" class="indexterm-anchor"></a></p>
                     <p>在执行数组SELECT和FETCH时，始终使用指示符数组。这样，您可以在关联的输出主机阵列中测试NULL。</p>
                     <p>如果<code class="codeph">DBMS=V7</code>或<code class="codeph">DBMS=v8</code>并且<code class="codeph">SELECT</code>或<code class="codeph">FETCH</code>将<code class="codeph">NULL</code>列值转换为与指标数组无关的主机数组，则Oracle停止处理，将<code class="codeph">sqlerrd[2]</code>为已处理的行数，并返回错误信息。当<code class="codeph">DBMS=V7</code>或<code class="codeph">DBMS=v8</code> ，Oracle不会将截断视为错误。
                     </p>
                     <p>此外，如果由于使用<code class="codeph">NULL</code>而导致<code class="codeph">SELECT</code>或<code class="codeph">FETCH</code>导致任何警告（如<code class="codeph">ORA-24347</code> ，并且如果任何列没有指示符数组，则Oracle将停止处理。
                     </p>
                     <div class="infoboxnote" id="GUID-BC49BCAA-B08F-44E2-A1BC-060F24582456__GUID-86603649-D6F9-4CDC-A732-433F7EE87304">
                        <p class="notep1">注意：</p>
                        <p></p>
                        <p>对<code class="codeph">SELECT</code>或<code class="codeph">FETCH</code>中的所有列使用指示符变量。如果所有列都没有指示符，则可以使用预编译器选项<code class="codeph">unsafe_null=yes</code>作为替代。
                        </p>
                     </div>
                  </div>
               </div>
            </div><a id="LNPCC3443"></a><div class="props_rev_3"><a id="GUID-55DA6D6C-60A9-4F6B-ADF6-18C08B872147" name="GUID-55DA6D6C-60A9-4F6B-ADF6-18C08B872147"></a><h3 id="LNPCC-GUID-55DA6D6C-60A9-4F6B-ADF6-18C08B872147" class="sect3"><span class="enumeration_section">8.4</span>关于选择数组</h3>
               <div>
                  <p>您可以在SELECT语句中将主机数组用作输出变量。如果您知道SELECT将返回的最大行数，则只需使用该数量的元素声明主机数组。在以下示例中，您可以直接选择三个主机阵列。知道SELECT将返回不超过50行，您声明数组有50个元素： <a id="d40176e402" class="indexterm-anchor"></a><a id="d40176e407" class="indexterm-anchor"></a> 
                  </p><pre class="oac_no_warn" dir="ltr">char emp_name [50] [20]; int emp_number [50];浮动工资[50]; EXEC SQL SELECT ENAME，EMPNO，SAL INTO：emp_name，：emp_number，：salary FROM EMP WHERE SAL&gt; 1000;</pre><p>在前面的示例中，SELECT语句最多返回50行。如果符合条件的行少于50个，或者您只想检索50行，则此方法就足够了。但是，如果有超过50个符合条件的行，则无法以这种方式检索所有行。如果重新执行SELECT语句，它只会再次返回前50行，即使更多符合条件。您必须声明一个更大的数组或声明一个游标以用于FETCH语句。</p>
                  <p>如果SELECT INTO语句返回的行数多于您声明的元素数，则Oracle会发出错误消息，除非您指定SELECT_ERROR = NO。</p>
                  <div class="infoboxnotealso" id="GUID-55DA6D6C-60A9-4F6B-ADF6-18C08B872147__GUID-88CD57E2-44B7-44BF-9C60-3BAF4FA0E274">
                     <p class="notep1">也可以看看：</p>
                     <p><span class="q">“ <a href="precompiler-options.html#GUID-FC726DCD-2AAE-4A4B-A293-C8C23382A9B5">预编译器选项</a> ”</span>有关SELECT_ERROR选项的更多信息。
                     </p>
                  </div>
               </div><a id="LNPCC3444"></a><div class="props_rev_3"><a id="GUID-997A0050-15EB-4D71-A957-AAB790331092" name="GUID-997A0050-15EB-4D71-A957-AAB790331092"></a><h4 id="LNPCC-GUID-997A0050-15EB-4D71-A957-AAB790331092" class="sect4"><span class="enumeration_section">8.4.1</span>光标提取</h4>
                  <div>
                     <p>如果您不知道SELECT将返回的最大行数，您可以声明并打开游标，然后在“批处理”中从中获取它。</p>
                     <p>循环内的批量提取可让您轻松检索大量行。每个FETCH返回当前活动集中的下一批行。在以下示例中，您将获取20行批处理： <a id="d40176e438" class="indexterm-anchor"></a><a id="d40176e442" class="indexterm-anchor"></a><a id="d40176e446" class="indexterm-anchor"></a><a id="d40176e450" class="indexterm-anchor"></a> 
                     </p><pre class="oac_no_warn" dir="ltr">int emp_number [20];浮动工资[20]; EXEC SQL DECLARE emp_cursor CURSOR FOR SELECT empno，sal FROM emp; EXEC SQL OPEN emp_cursor; EXEC SQL WHENEVER NOT FOUND会破坏; for（;;）{EXEC SQL FETCH emp_cursor INTO：emp_number，：salary; / *处理批次行* / ...} ...
</pre><p>不要忘记检查上次获取中实际返回的行数，并处理它们。</p>
                  </div>
                  <div>
                     <div class="relinfo">
                        <p><strong>相关话题</strong></p>
                        <ul>
                           <li><a href="host-arrays.html#GUID-3B7E72E4-6E4F-40BD-BA5E-A38345362B6D">提取的行数</a></li>
                        </ul>
                     </div>
                  </div>
                  
               </div><a id="LNPCC3445"></a><div class="props_rev_3"><a id="GUID-989279AF-E176-41C7-A2D0-84685367DA54" name="GUID-989279AF-E176-41C7-A2D0-84685367DA54"></a><h4 id="LNPCC-GUID-989279AF-E176-41C7-A2D0-84685367DA54" class="sect4"><span class="enumeration_section">8.4.2</span>关于使用sqlca.sqlerrd [2]</h4>
                  <div>
                     <p>对于INSERT，UPDATE，DELETE和SELECT INTO语句， <code class="codeph">sqlca.sqlerrd[2]</code>记录处理的行数。对于FETCH语句，它记录已处理的行的累积总和。 <a id="d40176e482" class="indexterm-anchor"></a> 
                     </p>
                     <p>当使用具有FETCH的主机数组时，要查找最近迭代返回的行数，请从其先前的值（存储在另一个变量中）中减去<code class="codeph">sqlca.sqlerrd[2]</code>的当前值。在以下示例中，您确定最近一次提取返回的行数：</p><pre class="oac_no_warn" dir="ltr">int emp_number [100]; char emp_name [100] [20]; int rows_to_fetch，rows_before，rows_this_time; EXEC SQL DECLARE emp_cursor CURSOR FOR SELECT empno，ename FROM emp WHERE deptno = 30; EXEC SQL OPEN emp_cursor; EXEC SQL WHENEVER NOT FOUND CONTINUE; / *初始化循环变量* / rows_to_fetch = 20; / *每个“批处理”中的行数* / rows_before = 0; / * sqlerrd的前一个值[2] * / rows_this_time = 20; while（rows_this_time == rows_to_fetch）{EXEC SQL FOR：rows_to_fetch FETCH emp_cursor INTO：emp_number，：emp_name; rows_this_time = sqlca.sqlerrd [2]  -  rows_before; rows_before = sqlca.sqlerrd [2]; } ...
</pre><p>当数组操作期间发生错误时， <code class="codeph">sqlca.sqlerrd[2]</code>也很有用。处理在导致错误的行停止，因此<code class="codeph">sqlerrd[2]</code>给出成功处理的行数。
                     </p>
                  </div>
               </div><a id="LNPCC3446"></a><div class="props_rev_3"><a id="GUID-3B7E72E4-6E4F-40BD-BA5E-A38345362B6D" name="GUID-3B7E72E4-6E4F-40BD-BA5E-A38345362B6D"></a><h4 id="LNPCC-GUID-3B7E72E4-6E4F-40BD-BA5E-A38345362B6D" class="sect4"><span class="enumeration_section">8.4.3</span>提取的行数</h4>
                  <div>
                     <p>每个FETCH最多返回数组中的总行数。在以下情况下返回的行数较少： <a id="d40176e513" class="indexterm-anchor"></a> 
                     </p>
                     <ul style="list-style-type:disc">
                        <li>
                           <p>达到活动集的结尾。“无数据发现”Oracle错误代码返回到SQLCA中的SQLCODE。例如，如果您获取多个元素数组100但仍返回20行，则会发生这种情况。</p>
                        </li>
                        <li>
                           <p>仍然需要获取完整批次的行。例如，如果您将70个行提取到20个数字元素的数组中，则会发生这种情况，因为在第三个FETCH之后，只剩下10行要提取。</p>
                        </li>
                        <li>
                           <p>处理行时检测到错误。FETCH失败，适用的Oracle错误代码返回给SQLCODE。</p>
                        </li>
                     </ul>
                     <p>返回的累计行数可以在SQLCA的<span class="italic">sqlerrd</span>的第三个元素中<span class="italic">找到</span> ，在本指南中称为<code class="codeph">sqlerrd[2]</code> 。这适用于每个打开的游标。在以下示例中，请注意如何单独维护每个游标的状态： <a id="d40176e536" class="indexterm-anchor"></a> 
                     </p><pre class="oac_no_warn" dir="ltr">EXEC SQL OPEN cursor1; EXEC SQL OPEN cursor2; EXEC SQL FETCH cursor1 INTO：array_of_20; / *现在在sqlerrd [2]中运行总计是20 * / EXEC SQL FETCH cursor2 INTO：array_of_30; / *现在在sqlerrd [2]中运行总计是30，而不是50 * / EXEC SQL FETCH cursor1 INTO：array_of_20; / *现在在sqlerrd [2]中运行总计是40（20 + 20）* / EXEC SQL FETCH cursor2 INTO：array_of_30; / *现在在sqlerrd [2]中运行总计为60（30 + 30）* /</pre></div>
               </div><a id="LNPCC3447"></a><div class="props_rev_3"><a id="GUID-91517D50-1ACB-4191-9198-05D0F8EE3111" name="GUID-91517D50-1ACB-4191-9198-05D0F8EE3111"></a><h4 id="LNPCC-GUID-91517D50-1ACB-4191-9198-05D0F8EE3111" class="sect4"><span class="enumeration_section">8.4.4可</span>滚动光标提取</h4>
                  <div>
                     <p>您还可以将主机数组与可滚动游标一起使用。使用可滚动游标， <code class="codeph">sqlca.sqlerrd[2]</code>表示处理的最大（绝对）行数。由于应用程序可以在可滚动模式下任意定位提取，因此不必是处理的总行数。
                     </p>
                     <p>在可滚动模式下使用具有FETCH语句的主机数组时，不能从其先前的值中减去<code class="codeph">sqlca.sqlerrd[2]</code>的当前值，以查找最近一次迭代返回的行数。应用程序通过执行FETCH LAST确定结果集中的总行数。 <code class="codeph">sqlca.sqlerrd[2]</code>的值提供结果集中的总行数。
                     </p>
                  </div>
                  <div>
                     <div class="relinfo">
                        <p><strong>相关话题</strong></p>
                        <ul>
                           <li><a href="host-arrays.html#GUID-F4032B0F-2816-4A08-8622-3C8E7725981D">示例程序：使用可滚动光标的主机阵列</a></li>
                        </ul>
                     </div>
                  </div>
                  
               </div><a id="LNPCC3448"></a><div class="props_rev_3"><a id="GUID-3C1174EC-48B7-4A24-9FA3-E837D432C069" name="GUID-3C1174EC-48B7-4A24-9FA3-E837D432C069"></a><h4 id="LNPCC-GUID-3C1174EC-48B7-4A24-9FA3-E837D432C069" class="sect4"><span class="enumeration_section">8.4.5</span>示例程序3：主机阵列</h4>
                  <div>
                     <div class="section">
                        <p>本节中的演示程序显示了在Pro * C / C ++中编写查询时如何使用主机数组。特别注意在SQLCA（ <code class="codeph">sqlca.sqlerrd[2]</code> ）中使用“行处理计数”。该程序可在您的<code class="codeph">demo</code>目录中的<code class="codeph">sample3.pc</code>文件中<code class="codeph">sample3.pc</code>获得。
                        </p><pre class="oac_no_warn" dir="ltr">/ * * sample3.pc * Host Arrays * *此程序连接到ORACLE，声明并打开游标，*使用数组批量获取，并使用* print_rows（）函数打印结果。* / #include &lt;stdio.h&gt; #include &lt;string.h&gt; #include &lt;sqlca.h&gt; #define NAME_LENGTH 20 #define ARRAY_LENGTH 5 / *另一种连接方式。* / char * username =“SCOTT”; char *密码=“TIGER”; / *声明主机结构标记。* / struct {int emp_number [ARRAY_LENGTH]; char emp_name [ARRAY_LENGTH] [NAME_LENGTH];浮动工资[ARRAY_LENGTH]; } emp_rec; / *声明该程序的功能。* / void print_rows（）; / *产生程序输出* / void sql_error（）; / *处理不可恢复的错误* / main（）{int num_ret; / *返回的行数* / / *连接到ORACLE。 * / EXEC SQL WHENEVER SQLERROR DO sql_error（“连接错误：”）; EXEC SQL CONNECT：用户名IDENTIFIED BY：密码; printf（“\ n以用户身份连接到ORACLE：％s \ n”，用户名）;执行SQL WHENEVER SQLERROR DO sql_error（“Oracle错误：”）; / *声明FETCH的游标。 * / EXEC SQL DECLARE c1 CURSOR FOR SELECT empno，ename，sal FROM emp; EXEC SQL OPEN c1; / *初始化行数。* / num_ret = 0; / *数组获取循环 - 当NOT FOUND变为true时结束。* / EXEC SQL WHENEVER NOT FOUND DO break; for（;;）{EXEC SQL FETCH c1 INTO：emp_rec; / *打印但返回了很多行。* / print_rows（sqlca.sqlerrd [2]  -  num_ret）; num_ret = sqlca.sqlerrd [2]; / *重置号码。* /} / *打印上次提取的剩余行（如果有）。* / if（（sqlca.sqlerrd [2]  -  num_ret）&gt; 0）print_rows（sqlca.sqlerrd [2]  -  num_ret）; EXEC SQL CLOSE c1; printf（“\ nAuu revoir。\ n \ n \ n”）; / *断开与数据库的连接。* / EXEC SQL COMMIT WORK RELEASE;出口（0）; } void print_rows（n）int n; {int i; printf（“\ nNumber Employee Salary”）; printf（“\ n ------ -------- ------ \ n”）; for（i = 0; i &lt;n; i ++）printf（“％ -  9d％-15.15s％9.2f \ n”，emp_rec.emp_number [i]，emp_rec.emp_name [i]，emp_rec.salary [i]） ; } void sql_error（msg）char * msg; {EXEC SQL WHENEVER SQLERROR CONTINUE; printf（“\ n％s”，msg）; printf（“\ n％.70s \ n”，sqlca.sqlerrm.sqlerrmc）; EXEC SQL ROLLBACK工作版;出口（1）; }</pre><div class="infoboxnotealso" id="GUID-3C1174EC-48B7-4A24-9FA3-E837D432C069__GUID-E15D2ED0-8789-4F65-9545-9C8E5B00E9DC">
                           <p class="notep1">也可以看看：</p>
                           <p>有关SQLCA的更多信息，请<span class="q">“ <a href="handling-run-time-errors.html#GUID-1ADFD2EB-B332-4362-9A85-F56FEDD4F72A">处理运行时错误</a> ”</span></p>
                        </div>
                     </div>
                     <!-- class="section" -->
                  </div>
               </div><a id="LNPCC3449"></a><div class="props_rev_3"><a id="GUID-F4032B0F-2816-4A08-8622-3C8E7725981D" name="GUID-F4032B0F-2816-4A08-8622-3C8E7725981D"></a><h4 id="LNPCC-GUID-F4032B0F-2816-4A08-8622-3C8E7725981D" class="sect4"><span class="enumeration_section">8.4.6</span>示例程序：使用可滚动光标的主机阵列</h4>
                  <div>
                     <div class="section">
                        <p>该程序描述了如何使用具有可滚动游标的主机阵列。该程序可在您的演示目录中的<code class="codeph">scdemo2.pc</code>文件中<code class="codeph">scdemo2.pc</code>获得。
                        </p>
                        <div class="infoboxnote" id="GUID-F4032B0F-2816-4A08-8622-3C8E7725981D__GUID-A676AAD6-7951-4AC5-A8FE-1EFCEBF1F3C4">
                           <p class="notep1">注意：</p>
                           <p>请注意，我们执行FETCH LAST来确定结果集中的行数。</p>
                        </div>
                     </div>
                     <!-- class="section" -->
                  </div><a id="LNPCC3450"></a><div class="props_rev_3"><a id="GUID-51BADED9-7080-4C2D-AA39-3177C01E34CA" name="GUID-51BADED9-7080-4C2D-AA39-3177C01E34CA"></a><h5 id="LNPCC-GUID-51BADED9-7080-4C2D-AA39-3177C01E34CA" class="sect5"><span class="enumeration_section">8.4.6.1</span> scdemo2.pc</h5>
                     <div><pre class="oac_no_warn" dir="ltr">/ * *一个示例程序，用于演示如何使用带有主机数组的可滚动*游标。* *此程序使用hr / hr架构。在执行此程序之前确保*该模式存在* / #include &lt;stdio.h&gt; #include &lt;string.h&gt; #include &lt;stdlib.h&gt; #include &lt;sqlca.h&gt; #define ARRAY_LENGTH 4 / * user and passwd * / char * username =“hr”; char * password =“hr”; / *声明主机结构标记。* / struct emp_rec_array {int emp_number; char emp_name [20];浮动工资; } emp_rec [ARRAY_LENGTH]; / *打印查询结果* / void print_rows（）{int i; for（i = 0; i &lt;ARRAY_LENGTH; i ++）printf（“％d％s％8.2f \ n”，emp_rec [i] .emp_number，emp_rec [i] .emp_name，emp_rec [i] .salary）; / * Oracle错误处理程序* / void sql_error（char * msg）{EXEC SQL WHENEVER SQLERROR CONTINUE; printf（“\ n％s”，msg）; printf（“\ n％.70s \ n”，sqlca.sqlerrm.sqlerrmc）; EXEC SQL ROLLBACK工作版;出口（EXIT_FAILURE）; } void main（）{int noOfRows; / *结果集中的行数* / / *错误处理程序* / EXEC SQL WHENEVER SQLERROR DO sql_error（“连接错误：”）; / *连接到数据库* / EXEC SQL CONNECT：username IDENTIFIED BY：password; / *错误句柄* / EXEC SQL WHENEVER SQLERROR DO sql_error（“Oracle error：”）; / *以可滚动模式声明游标* / EXEC SQL DECLARE c1 SCROLL CURSOR FOR SELECT employee_id，first_name，salary FROM employees; EXEC SQL OPEN c1;执行SQL WHENEVER SQLERROR DO sql_error（“获取错误：”）; / *这是一个虚拟提取，用于查找结果集中的行数* / EXEC SQL FETCH LAST c1 INTO：emp_rec; / *结果集中的行数由sqlca.sqlerrd [2] * / noOfRows = sqlca的值给出。 SQLERRD [2]; printf（“结果集中的总行数％d：\ n”，noOfRows）; / *获取第一个ARRAY_LENGTH行数* / EXEC SQL FETCH FIRST c1 INTO：emp_rec; printf（“******************** DEFAULT：\ n”）; print_rows（）; / *获取下一组ARRAY_LENGTH行* / EXEC SQL FETCH NEXT c1 INTO：emp_rec; printf（“******************** NEXT：\ n”）; print_rows（）; / *从第3行开始获取一组ARRAY_LENGTH行* / EXEC SQL FETCH ABSOLUTE 3 c1 INTO：emp_rec; printf（“******************** ABSOLUTE 3：\ n”）; print_rows（）; / *获取当前ARRAY_LENGTH行的行* / EXEC SQL FETCH CURRENT c1 INTO：emp_rec; printf（“******************** CURRENT：\ n”）; print_rows（）; / *从当前光标位置的第二个偏移量中获取一组ARRAY_LENGTH行* / EXEC SQL FETCH RELATIVE 2 c1 INTO：emp_rec; printf（“******************** RELATIVE 2：\ n”）; print_rows（）; / *再次获取第一个ARRAY_LENGTH行数* / EXEC SQL FETCH ABSOLUTE 0 c1 INTO：emp_rec; printf（“******************** ABSOLUTE 0：\ n”）; print_rows（）; / *关闭游标* / EXEC SQL CLOSE c1; / *断开与数据库的连接。* / EXEC SQL COMMIT WORK RELEASE;出口（EXIT_SUCCESS）; }</pre></div>
                  </div>
               </div><a id="LNPCC3452"></a><a id="LNPCC3451"></a><div class="props_rev_3"><a id="GUID-9490A1C8-DEEE-4719-B24E-7B8472C83763" name="GUID-9490A1C8-DEEE-4719-B24E-7B8472C83763"></a><h4 id="LNPCC-GUID-9490A1C8-DEEE-4719-B24E-7B8472C83763" class="sect4"><span class="enumeration_section">8.4.7</span>主机阵列限制</h4>
                  <div>
                     <p>SELECT语句的WHERE子句中使用主机数组是<span class="italic">不允许</span>的，除非子查询。有关示例，请参阅<span class="q">“ <a href="host-arrays.html#GUID-D831124D-EB14-4CF6-9EE6-D76AFA331FE3">关于使用WHERE子句</a> ”</span> 。
                     </p>
                     <p>此外，您不能在SELECT或FETCH语句的INTO子句中将简单主机变量与主机数组混合使用。如果任何主机变量是一个数组，则所有主变量都必须是数组。 <a id="d40176e662" class="indexterm-anchor"></a><a id="d40176e667" class="indexterm-anchor"></a> 
                     </p>
                     <p><a href="host-arrays.html#GUID-9490A1C8-DEEE-4719-B24E-7B8472C83763__g14498" title="SELECT INTO的有效数组">表8-1</a>显示了主机数组在SELECT INTO语句中的哪些用途有效：</p>
                     <div class="tblformal" id="GUID-9490A1C8-DEEE-4719-B24E-7B8472C83763__g14498">
                        <p class="titleintable">表8-1 SELECT INTO的有效主机数组</p>
                        <table cellpadding="4" cellspacing="0" class="Formal" title="SELECT INTO的有效主机数组" width="100%" border="1" summary="Valid Arrays for SELECT INTO" frame="hsides" rules="rows">
                           <thead>
                              <tr align="left" valign="top">
                                 <th align="left" valign="bottom" width="40%" id="d40176e689">INTO条款</th>
                                 <th align="left" valign="bottom" width="30%" id="d40176e692">条款</th>
                                 <th align="left" valign="bottom" width="30%" id="d40176e695">有效？</th>
                              </tr>
                           </thead>
                           <tbody>
                              <tr align="left" valign="top">
                                 <td align="left" valign="top" width="40%" id="d40176e700" headers="d40176e689 ">
                                    <p>排列</p>
                                 </td>
                                 <td align="left" valign="top" width="30%" headers="d40176e700 d40176e692 ">
                                    <p>排列</p>
                                 </td>
                                 <td align="left" valign="top" width="30%" headers="d40176e700 d40176e695 ">
                                    <p>没有</p>
                                 </td>
                              </tr>
                              <tr align="left" valign="top">
                                 <td align="left" valign="top" width="40%" id="d40176e710" headers="d40176e689 ">
                                    <p>纯量</p>
                                 </td>
                                 <td align="left" valign="top" width="30%" headers="d40176e710 d40176e692 ">
                                    <p>纯量</p>
                                 </td>
                                 <td align="left" valign="top" width="30%" headers="d40176e710 d40176e695 ">
                                    <p>是</p>
                                 </td>
                              </tr>
                              <tr align="left" valign="top">
                                 <td align="left" valign="top" width="40%" id="d40176e720" headers="d40176e689 ">
                                    <p>排列</p>
                                 </td>
                                 <td align="left" valign="top" width="30%" headers="d40176e720 d40176e692 ">
                                    <p>纯量</p>
                                 </td>
                                 <td align="left" valign="top" width="30%" headers="d40176e720 d40176e695 ">
                                    <p>是</p>
                                 </td>
                              </tr>
                              <tr align="left" valign="top">
                                 <td align="left" valign="top" width="40%" id="d40176e730" headers="d40176e689 ">
                                    <p>纯量</p>
                                 </td>
                                 <td align="left" valign="top" width="30%" headers="d40176e730 d40176e692 ">
                                    <p>排列</p>
                                 </td>
                                 <td align="left" valign="top" width="30%" headers="d40176e730 d40176e695 ">
                                    <p>没有</p>
                                 </td>
                              </tr>
                           </tbody>
                        </table>
                     </div>
                     <!-- class="inftblhruleinformal" -->
                  </div>
               </div><a id="LNPCC3453"></a><div class="props_rev_3"><a id="GUID-C191A98E-A963-42A1-9716-4CC6BF86BF4A" name="GUID-C191A98E-A963-42A1-9716-4CC6BF86BF4A"></a><h4 id="LNPCC-GUID-C191A98E-A963-42A1-9716-4CC6BF86BF4A" class="sect4"><span class="enumeration_section">8.4.8</span>关于获取NULL</h4>
                  <div>
                     <p>在执行数组SELECT和FETCH时，始终使用指示符数组。这样，您可以在关联的输出主机阵列中测试NULL。</p>
                     <p>当DBMS = V7或DBMS = v8时，如果SELECT或FETCH将NULL列值转换为与指标数组无关的主机数组，则Oracle停止处理，将<code class="codeph">sqlerrd[2]</code>为已处理的行数，并发出错误信息。
                     </p>
                     <p>此外，如果由于使用NULL而导致SELECT或FETCH导致任何警告（如<span class="italic">ORA-24347）</span> ，并且如果任何列没有指示符数组，则Oracle将停止处理。在SELECT或FETCH的所有列中使用指示符变量。如果所有列都没有指示符，则可以使用预编译器选项<code class="codeph">unsafe_null=yes</code>作为替代。
                     </p>
                  </div>
               </div><a id="LNPCC3454"></a><div class="props_rev_3"><a id="GUID-445825E9-169D-47EC-AE44-8A5A0395A2B0" name="GUID-445825E9-169D-47EC-AE44-8A5A0395A2B0"></a><h4 id="LNPCC-GUID-445825E9-169D-47EC-AE44-8A5A0395A2B0" class="sect4"><span class="enumeration_section">8.4.9</span>关于获取截断值</h4>
                  <div>
                     <p>当DBMS = V7时，截断会产生警告消息，但Oracle会继续处理。</p>
                     <p>同样，在执行数组SELECT和FETCH时，始终使用指示符数组。这样，如果Oracle将一个或多个截断的列值分配给输出主机数组，您可以在关联的指标数组中找到列值的原始长度。</p>
                  </div>
               </div>
            </div><a id="LNPCC3455"></a><div class="props_rev_3"><a id="GUID-2D0C9C7F-368A-4157-9F5C-8141072D9EB2" name="GUID-2D0C9C7F-368A-4157-9F5C-8141072D9EB2"></a><h3 id="LNPCC-GUID-2D0C9C7F-368A-4157-9F5C-8141072D9EB2" class="sect3"><span class="enumeration_section">8.5</span>关于使用数组插入</h3>
               <div>
                  <p>您可以在INSERT语句中将主机数组用作输入变量。只需确保程序在执行INSERT语句之前使用数据填充数组。</p>
                  <p>如果数组中的某些元素不相关，则可以使用FOR子句来控制插入的行数。 <a id="d40176e790" class="indexterm-anchor"></a><a id="d40176e794" class="indexterm-anchor"></a> 
                  </p>
                  <p>下面是使用主机数组插入的示例：</p><pre class="oac_no_warn" dir="ltr">char emp_name [50] [20]; int emp_number [50];浮动工资[50]; / *填充主机数组* / ...EXEC SQL INSERT INTO EMP（ENAME，EMPNO，SAL）VALUES（：emp_name，：emp_number，：salary）;</pre><p>插入的累计行数可以在行处理的计数<code class="codeph">sqlca.sqlerrd[2]</code> 。
                  </p>
                  <p>在以下示例中，INSERT一次完成一行。这比前一个示例效率低得多，因为必须为插入的每一行调用服务器。</p><pre class="oac_no_warn" dir="ltr">for（i = 0; i &lt;array_size; i ++）EXEC SQL INSERT INTO emp（ename，empno，sal）VALUES（：emp_name [i]，：emp_number [i]，：salary [i]）;</pre></div>
               <div>
                  <div class="relinfo">
                     <p><strong>相关话题</strong></p>
                     <ul>
                        <li><a href="host-arrays.html#GUID-A5ABD676-CF67-4EFF-82A4-82D94A653DD0">关于使用FOR子句</a></li>
                     </ul>
                  </div>
               </div>
               <a id="LNPCC3456"></a><div class="props_rev_3"><a id="GUID-A1DBD925-B34D-44DC-8BDE-6E5CEA7C7871" name="GUID-A1DBD925-B34D-44DC-8BDE-6E5CEA7C7871"></a><h4 id="LNPCC-GUID-A1DBD925-B34D-44DC-8BDE-6E5CEA7C7871" class="sect4"><span class="enumeration_section">8.5.1</span>关于使用数组插入限制</h4>
                  <div>
                     <p>您不能在INSERT语句的VALUES子句中使用指针数组;所有数组元素都必须是数据项。 <a id="d40176e832" class="indexterm-anchor"></a><a id="d40176e836" class="indexterm-anchor"></a> 
                     </p>
                     <p>混合INSERT语句的VALUES子句中的主机阵列标主机变量是<span class="italic">不允许</span>的。如果任何主机变量是一个数组，则所有主变量都必须是数组。
                     </p>
                  </div>
               </div>
            </div><a id="LNPCC3457"></a><div class="props_rev_3"><a id="GUID-755F6669-A311-454A-A561-93FA79BF6BDD" name="GUID-755F6669-A311-454A-A561-93FA79BF6BDD"></a><h3 id="LNPCC-GUID-755F6669-A311-454A-A561-93FA79BF6BDD" class="sect3"><span class="enumeration_section">8.6</span>关于使用数组更新</h3>
               <div>
                  <p>您还可以在UPDATE语句中将主机数组用作输入变量，如以下示例所示： <a id="d40176e858" class="indexterm-anchor"></a><a id="d40176e862" class="indexterm-anchor"></a> 
                  </p><pre class="oac_no_warn" dir="ltr">int emp_number [50];浮动工资[50]; / *填充主机数组* / EXEC SQL UPDATE emp SET sal =：salary WHERE EMPNO =：emp_number;</pre><p>更新的累积行数可以在<code class="codeph">sqlerrd[2]</code> 。这个数字<span class="italic">不</span>包括通过级联更新处理的行。
                  </p>
                  <p>如果数组中的某些元素不相关，则可以使用嵌入式SQL FOR子句来限制更新的行数。</p>
                  <p>最后一个示例显示了使用唯一键（EMP_NUMBER）的典型更新。每个数组元素只限一行进行更新。在以下示例中，每个数组元素限定多行：</p><pre class="oac_no_warn" dir="ltr">char job_title [10] [20];浮动佣金[10]; ...EXEC SQL UPDATE emp SET comm =：Commission WHERE job =：job_title;</pre></div><a id="LNPCC3459"></a><a id="LNPCC3458"></a><div class="props_rev_3"><a id="GUID-3FAAF107-D43F-4C9C-8365-6F4891CD3D30" name="GUID-3FAAF107-D43F-4C9C-8365-6F4891CD3D30"></a><h4 id="LNPCC-GUID-3FAAF107-D43F-4C9C-8365-6F4891CD3D30" class="sect4"><span class="enumeration_section">8.6.1</span>关于使用数组限制进行更新</h4>
                  <div>
                     <p>建议<span class="italic">不要</span>在UPDATE语句的SET或WHERE子句中将简单主机变量与主机数组混合。如果任何主机变量是一个数组，则所有主变量都应该是数组。 <a id="d40176e898" class="indexterm-anchor"></a><a id="d40176e902" class="indexterm-anchor"></a> 此外，如果在SET子句中使用主机数组，请在WHERE子句中使用相同数量的元素之一。
                     </p>
                     <p>您不能在UPDATE语句中将主机数组与CURRENT OF子句一起使用。</p>
                     <p><a href="host-arrays.html#GUID-3FAAF107-D43F-4C9C-8365-6F4891CD3D30__G14454" title="主机阵列在UPDATE中有效">表8-2</a>显示了主机数组在UPDATE语句中的有效使用情况：</p>
                     <div class="tblformal" id="GUID-3FAAF107-D43F-4C9C-8365-6F4891CD3D30__G14454">
                        <p class="titleintable">表8-2主机阵列在UPDATE中有效</p>
                        <table cellpadding="4" cellspacing="0" class="Formal" title="主机阵列在UPDATE中有效" width="100%" border="1" summary="Host Arrays Valid in an UPDATE" frame="hsides" rules="rows">
                           <thead>
                              <tr align="left" valign="top">
                                 <th align="left" valign="bottom" width="29%" id="d40176e926">SET子句</th>
                                 <th align="left" valign="bottom" width="40%" id="d40176e929">条款</th>
                                 <th align="left" valign="bottom" width="31%" id="d40176e932">有效？</th>
                              </tr>
                           </thead>
                           <tbody>
                              <tr align="left" valign="top">
                                 <td align="left" valign="top" width="29%" id="d40176e937" headers="d40176e926 ">
                                    <p>排列</p>
                                 </td>
                                 <td align="left" valign="top" width="40%" headers="d40176e937 d40176e929 ">
                                    <p>排列</p>
                                 </td>
                                 <td align="left" valign="top" width="31%" headers="d40176e937 d40176e932 ">
                                    <p>是</p>
                                 </td>
                              </tr>
                              <tr align="left" valign="top">
                                 <td align="left" valign="top" width="29%" id="d40176e947" headers="d40176e926 ">
                                    <p>纯量</p>
                                 </td>
                                 <td align="left" valign="top" width="40%" headers="d40176e947 d40176e929 ">
                                    <p>纯量</p>
                                 </td>
                                 <td align="left" valign="top" width="31%" headers="d40176e947 d40176e932 ">
                                    <p>是</p>
                                 </td>
                              </tr>
                              <tr align="left" valign="top">
                                 <td align="left" valign="top" width="29%" id="d40176e957" headers="d40176e926 ">
                                    <p>排列</p>
                                 </td>
                                 <td align="left" valign="top" width="40%" headers="d40176e957 d40176e929 ">
                                    <p>纯量</p>
                                 </td>
                                 <td align="left" valign="top" width="31%" headers="d40176e957 d40176e932 ">
                                    <p>没有</p>
                                 </td>
                              </tr>
                              <tr align="left" valign="top">
                                 <td align="left" valign="top" width="29%" id="d40176e967" headers="d40176e926 ">
                                    <p>纯量</p>
                                 </td>
                                 <td align="left" valign="top" width="40%" headers="d40176e967 d40176e929 ">
                                    <p>排列</p>
                                 </td>
                                 <td align="left" valign="top" width="31%" headers="d40176e967 d40176e932 ">
                                    <p>没有</p>
                                 </td>
                              </tr>
                           </tbody>
                        </table>
                     </div>
                     <!-- class="inftblhruleinformal" -->
                  </div>
                  <div>
                     <div class="relinfo">
                        <p><strong>相关话题</strong></p>
                        <ul>
                           <li><a href="host-arrays.html#GUID-DBA71301-C6C4-47C0-BAB5-1B6B221AB46E">关于模仿当前的</a></li>
                        </ul>
                     </div>
                  </div>
               </div>
            </div><a id="LNPCC3460"></a><div class="props_rev_3"><a id="GUID-DE60CE32-DF13-4969-A83D-C338C0A866BD" name="GUID-DE60CE32-DF13-4969-A83D-C338C0A866BD"></a><h3 id="LNPCC-GUID-DE60CE32-DF13-4969-A83D-C338C0A866BD" class="sect3"><span class="enumeration_section">8.7</span>关于使用数组删除</h3>
               <div>
                  <p>您还可以在DELETE语句中将主机数组用作输入变量。这就像在WHERE子句中使用主机数组的连续元素重复执行DELETE语句一样。因此，每次执行都可能从表中删除零个，一个或多个行。 <a id="d40176e992" class="indexterm-anchor"></a><a id="d40176e996" class="indexterm-anchor"></a> 
                  </p>
                  <p>下面是使用主机数组删除的示例：</p><pre class="oac_no_warn" dir="ltr">...int emp_number [50]; / *填充主机数组* / ...EXEC SQL DELETE FROM emp WHERE empno =：emp_number;</pre><p>删除的累计行数可以在<code class="codeph">sqlerrd[2]</code> 。数字<span class="italic">不</span>包括被删除级联处理的行。
                  </p>
                  <p>最后一个示例显示了使用唯一键（EMP_NUMBER）的典型删除。每个数组元素只限一行进行删除。在以下示例中，每个数组元素限定多行：</p><pre class="oac_no_warn" dir="ltr">...char job_title [10] [20]; / *填充主机数组* / ...EXEC SQL DELETE FROM emp WHERE job =：job_title; ...</pre></div><a id="LNPCC3461"></a><div class="props_rev_3"><a id="GUID-98A91B07-113F-4CB5-8788-741AD1216C9D" name="GUID-98A91B07-113F-4CB5-8788-741AD1216C9D"></a><h4 id="LNPCC-GUID-98A91B07-113F-4CB5-8788-741AD1216C9D" class="sect4"><span class="enumeration_section">8.7.1</span>关于使用数组限制进行删除</h4>
                  <div>
                     <p>混合DELETE语句的WHERE子句中的主机阵列简单的主机变量是<span class="italic">不允许</span>的。如果任何主机变量是一个数组，则所有主变量都必须是数组。 <a id="d40176e1031" class="indexterm-anchor"></a><a id="d40176e1035" class="indexterm-anchor"></a> 
                     </p>
                     <p>您不能在DELETE语句中将主机数组与CURRENT OF子句一起使用。</p>
                     <div class="infoboxnotealso" id="GUID-98A91B07-113F-4CB5-8788-741AD1216C9D__GUID-3D2555DA-0D5D-4350-A8AD-AD33E70815A5">
                        <p class="notep1">也可以看看：</p>
                        <p><span class="q">“ <a href="host-arrays.html#GUID-DBA71301-C6C4-47C0-BAB5-1B6B221AB46E">关于模仿CURRENT OF</a> ”</span>替代方案。
                        </p>
                     </div>
                  </div>
               </div>
            </div><a id="LNPCC3462"></a><div class="props_rev_3"><a id="GUID-A5ABD676-CF67-4EFF-82A4-82D94A653DD0" name="GUID-A5ABD676-CF67-4EFF-82A4-82D94A653DD0"></a><h3 id="LNPCC-GUID-A5ABD676-CF67-4EFF-82A4-82D94A653DD0" class="sect3"><span class="enumeration_section">8.8</span>关于使用FOR子句</h3>
               <div>
                  <p>您可以使用可选的嵌入式SQL FOR子句来设置由以下任何SQL语句处理的数组元素的数量：</p>
                  <ul style="list-style-type:disc">
                     <li>
                        <p>删除</p>
                     </li>
                     <li>
                        <p>执行</p>
                     </li>
                     <li>
                        <p>取</p>
                     </li>
                     <li>
                        <p>插入</p>
                     </li>
                     <li>
                        <p>打开</p>
                     </li>
                     <li>
                        <p>UPDATE</p>
                     </li>
                  </ul>
                  <p>FOR子句在UPDATE，INSERT和DELETE语句中特别有用。使用这些语句，您可能不想使用整个数组。FOR子句允许您将所使用的元素限制为所需的数字，如以下示例所示： <a id="d40176e1081" class="indexterm-anchor"></a><a id="d40176e1085" class="indexterm-anchor"></a><a id="d40176e1089" class="indexterm-anchor"></a><a id="d40176e1093" class="indexterm-anchor"></a> 
                  </p><pre class="oac_no_warn" dir="ltr">char emp_name [100] [20];浮动工资[100]; int rows_to_insert; / *填充主机数组* / rows_to_insert = 25; / *设置FOR子句变量* / EXEC SQL FOR：rows_to_insert / *只处理25行* / INSERT INTO \ temp（ename，sal）VALUES（：emp_name，：salary）;</pre><p>FOR子句可以使用整数主机变量来计算数组元素或整数文字。<span class="italic">不能</span>使用解析为整数的复杂C表达式。例如，以下使用整数表达式的语句是非法的： <a id="d40176e1105" class="indexterm-anchor"></a> 
                  </p><pre class="oac_no_warn" dir="ltr">EXEC SQL FOR：rows_to_insert + 5 / * illegal * / INSERT INTO emp（ename，empno，sal）VALUES（：emp_name，：emp_number，：salary）;</pre><p>FOR子句变量指定要处理的数组元素的数量。确保数字不超过最小的数组维度。在内部，该值被视为无符号数量。尝试通过使用已签名的主机变量传递负值将导致不可预测的行为。 <a id="d40176e1114" class="indexterm-anchor"></a> 
                  </p>
               </div><a id="LNPCC3463"></a><div class="props_rev_3"><a id="GUID-C2BA19D2-9E1E-40E3-9872-282E97B2F84E" name="GUID-C2BA19D2-9E1E-40E3-9872-282E97B2F84E"></a><h4 id="LNPCC-GUID-C2BA19D2-9E1E-40E3-9872-282E97B2F84E" class="sect4"><span class="enumeration_section">8.8.1</span> FOR条款限制</h4>
                  <div>
                     <p>两个限制使FOR子句语义清晰：您不能在SELECT语句中使用FOR子句或使用CURRENT OF子句。 <a id="d40176e1130" class="indexterm-anchor"></a><a id="d40176e1134" class="indexterm-anchor"></a> 
                     </p>
                  </div><a id="LNPCC3464"></a><div class="props_rev_3"><a id="GUID-7DAD881F-CBE7-4ED9-B281-15A57DFEF5FD" name="GUID-7DAD881F-CBE7-4ED9-B281-15A57DFEF5FD"></a><h5 id="LNPCC-GUID-7DAD881F-CBE7-4ED9-B281-15A57DFEF5FD" class="sect5"><span class="enumeration_section">8.8.1.1</span>在SELECT语句中</h5>
                     <div>
                        <p>如果在SELECT语句中使用FOR子句，则会收到错误消息。</p>
                        <p>SELECT语句中不允许使用FOR子句，因为它的含义不清楚。这是否意味着“执行此SELECT语句<span class="italic">n</span>次”？或者，它是否意味着“执行此SELECT语句一次，但返回<span class="italic">n</span>行”？前一种情况的问题是每次执行都可能返回多行。在后一种情况下，最好声明一个游标并在FETCH语句中使用FOR子句，如下所示：</p><pre class="oac_no_warn" dir="ltr">EXEC SQL FOR：限制FETCH emp_cursor INTO ...</pre></div>
                  </div><a id="LNPCC3465"></a><div class="props_rev_3"><a id="GUID-C7CC420A-49B0-4D2D-BAD6-655793C50864" name="GUID-C7CC420A-49B0-4D2D-BAD6-655793C50864"></a><h5 id="LNPCC-GUID-C7CC420A-49B0-4D2D-BAD6-655793C50864" class="sect5"><span class="enumeration_section">8.8.1.2</span>使用CURRENT OF子句</h5>
                     <div>
                        <p>您可以使用UPDATE或DELETE语句中的CURRENT OF子句来引用FETCH语句返回的最新行，如以下示例所示：</p><pre class="oac_no_warn" dir="ltr">EXEC SQL DECLARE emp_cursor CURSOR FOR SELECT ename，sal FROM emp WHERE empno =：emp_number; ...EXEC SQL OPEN emp_cursor; ...EXEC SQL FETCH emp_cursor INTO：emp_name，：salary; ...EXEC SQL UPDATE emp SET sal =：new_salary WHERE CURRENT OF emp_cursor;</pre><p>但是，您不能将FOR子句与CURRENT OF子句一起使用。以下语句无效，因为<span class="italic">limit</span>的唯一逻辑值为1（您只能更新或删除当前行一次）：</p><pre class="oac_no_warn" dir="ltr">EXEC SQL FOR：limit UPDATE emp SET sal =：new_salary WHERE CURRENT OF emp_cursor; ...EXEC SQL FOR：限制DELETE FROM emp WHERE CURRENT OF_ emprsor;</pre></div>
                  </div>
               </div>
            </div><a id="LNPCC3466"></a><div class="props_rev_3"><a id="GUID-D831124D-EB14-4CF6-9EE6-D76AFA331FE3" name="GUID-D831124D-EB14-4CF6-9EE6-D76AFA331FE3"></a><h3 id="LNPCC-GUID-D831124D-EB14-4CF6-9EE6-D76AFA331FE3" class="sect3"><span class="enumeration_section">8.9</span>关于使用WHERE子句</h3>
               <div>
                  <p>甲骨文对待包含元素的数量<span class="italic">n</span>的等执行相同的SQL语句主机阵列SQL语句<span class="italic">n，</span>其中<span class="italic">n个</span>不同的标量变量（各个数组元素）次。只有当这种处理方式不明确时，预编译器才会发出错误消息。 <a id="d40176e1201" class="indexterm-anchor"></a><a id="d40176e1205" class="indexterm-anchor"></a> 
                  </p>
                  <p>例如，假设声明</p><pre class="oac_no_warn" dir="ltr">int mgr_number [50]; char job_title [50] [20];</pre><p>如果声明，这将是模棱两可的</p><pre class="oac_no_warn" dir="ltr">EXEC SQL SELECT mgr INTO：mgr_number FROM emp WHERE job =：job_title;</pre><p>被视为虚构的陈述</p><pre class="oac_no_warn" dir="ltr">for（i = 0; i &lt;50; i ++）SELECT mgr INTO：mgr_number [i] FROM emp WHERE job =：job_title [i];</pre><p>因为多行可能符合WHERE子句搜索条件，但只有一个输出变量可用于接收数据。因此，会发出错误消息。</p>
                  <p>另一方面，如果声明如此，则不会含糊不清</p><pre class="oac_no_warn" dir="ltr">EXEC SQL UPDATE emp SET mgr =：mgr_number WHERE empno IN（SELECT empno FROM emp WHERE job =：job_title）;</pre><p>被视为虚构的陈述</p><pre class="oac_no_warn" dir="ltr">for（i = 0; i &lt;50; i ++）UPDATE emp SET mgr =：mgr_number [i] WHERE empno IN（SELECT empno FROM emp WHERE job =：job_title [i]）;</pre><p>因为每一行匹配<span class="italic">JOB_TITLE</span>的SET子句中<span class="italic">mgr_number</span> WHERE子句中，即使每个<span class="italic">JOB_TITLE</span>多行匹配。匹配每个<span class="italic">job_title的</span>所有行可以设置为相同的<span class="italic">mgr_number</span> 。因此，不会发出错误消息。
                  </p>
               </div>
            </div><a id="LNPCC3467"></a><div class="props_rev_3"><a id="GUID-861203A7-309A-4A33-A6B8-89B10B36E0C4" name="GUID-861203A7-309A-4A33-A6B8-89B10B36E0C4"></a><h3 id="LNPCC-GUID-861203A7-309A-4A33-A6B8-89B10B36E0C4" class="sect3"><span class="enumeration_section">8.10</span>结构数组</h3>
               <div>
                  <p>使用标量数组，您可以执行仅涉及单个列的多行操作。使用标量的结构允许用户执行涉及多个列的单行操作。</p>
                  <p>但是，为了执行涉及多列的多行操作，您以前需要单独分配几个并行的标量数组，或者在单个结构中封装。在许多情况下，更容易重新组织此数据结构作为单个结构数组。</p>
                  <p>Pro * C / C ++支持使用<span class="italic">结构数组，</span>这使得应用程序编程人员可以使用C结构数组执行多行，多列操作。通过此增强功能，Pro * C / C ++可以将简单的标量结构数组作为嵌入式SQL语句中的绑定变量处理，以便于处理用户数据。这使编程更加直观，并使用户可以更灵活地组织数据。
                  </p>
                  <p>除了支持结构数组作为绑定变量之外，Pro * C / C ++还支持与结构声明数组结合使用时的指示符结构数组。</p>
                  <div class="infoboxnote" id="GUID-861203A7-309A-4A33-A6B8-89B10B36E0C4__GUID-CC043255-DB83-4863-B7A7-E649FE177B4D">
                     <p class="notep1">注意：</p>
                     <p>将结构绑定到PL / SQL记录并将结构数组绑定到记录的PL / SQL表<span class="italic">不是</span>此新功能的一部分。结构数组也可能不在嵌入式PL / SQL块中使用。
                     </p>
                  </div>
                  <p>由于在执行涉及多列的多行操作时打算使用结构数组，因此通常预期它们将以下列方式使用。</p>
                  <ul style="list-style-type:disc">
                     <li>
                        <p>作为SELECT语句或FETCH语句中的输出绑定变量。</p>
                     </li>
                     <li>
                        <p>作为INSERT语句的VALUES子句中的输入绑定变量。</p>
                     </li>
                  </ul>
               </div>
               <div>
                  <div class="relinfo">
                     <p><strong>相关话题</strong></p>
                     <ul>
                        <li><a href="host-arrays.html#GUID-99B8AD7A-71BB-47B7-BBC3-9B83DB2592A3">对结构数组的限制</a></li>
                     </ul>
                  </div>
               </div>
               <a id="LNPCC3468"></a><div class="props_rev_3"><a id="GUID-64CB66FD-BA68-4A38-A524-A01D18810B2C" name="GUID-64CB66FD-BA68-4A38-A524-A01D18810B2C"></a><h4 id="LNPCC-GUID-64CB66FD-BA68-4A38-A524-A01D18810B2C" class="sect4"><span class="enumeration_section">8.10.1</span>结构用法数组</h4>
                  <div>
                     <p>结构数组的概念对C程序员来说并不陌生。但是，当它与并行数组的结构进行比较时，它确实为数据存储提供了概念上的差异。</p>
                     <p>在并行数组的结构中，各列的数据是连续存储的。另一方面，在结构数组中，列数据是<span class="italic"><span class="bold">交错的</span></span> ，因此数组中每列出现的列由结构中其他列所需的空格分隔。这个空间被称为<span class="italic"><span class="bold">步伐</span></span> 。
                     </p>
                  </div>
               </div><a id="LNPCC3469"></a><div class="props_rev_3"><a id="GUID-99B8AD7A-71BB-47B7-BBC3-9B83DB2592A3" name="GUID-99B8AD7A-71BB-47B7-BBC3-9B83DB2592A3"></a><h4 id="LNPCC-GUID-99B8AD7A-71BB-47B7-BBC3-9B83DB2592A3" class="sect4"><span class="enumeration_section">8.10.2</span>对结构阵列的限制</h4>
                  <div>
                     <p>以下限制适用于在Pro * C / C ++中使用结构数组：</p>
                     <ul style="list-style-type:disc">
                        <li>
                           <p>嵌入式PL / SQL块中不允许使用结构数组（与普通结构一样）。</p>
                        </li>
                        <li>
                           <p>禁止在WHERE或FROM子句中使用结构数组。</p>
                        </li>
                        <li>
                           <p>Oracle Dynamic SQL方法4不允许使用结构数组。ANSI动态SQL允许使用它们。</p>
                        </li>
                        <li>
                           <p>UPDATE语句的SET子句中不允许使用结构数组。</p>
                        </li>
                     </ul>
                     <p>声明结构数组的语法不会更改。但是，在使用结构数组时，需要记住一些事项。</p>
                  </div>
                  <div>
                     <div class="relinfo">
                        <p><strong>相关话题</strong></p>
                        <ul>
                           <li><a href="ANSI-dynamic-SQL.html#GUID-BF450DA3-B05F-403E-B5DF-C967A20524BF">ANSI动态SQL</a></li>
                        </ul>
                     </div>
                  </div>
                  
               </div><a id="LNPCC3470"></a><div class="props_rev_3"><a id="GUID-3F92A9DA-C1D7-4B19-BCF3-D5770879632A" name="GUID-3F92A9DA-C1D7-4B19-BCF3-D5770879632A"></a><h4 id="LNPCC-GUID-3F92A9DA-C1D7-4B19-BCF3-D5770879632A" class="sect4"><span class="enumeration_section">8.10.3</span>关于声明结构数组</h4>
                  <div>
                     <p>在声明将在Pro * C / C ++应用程序中使用的结构数组时，程序员必须牢记以下要点：</p>
                     <ul style="list-style-type:disc">
                        <li>
                           <p>结构必须具有结构标记。例如，在以下代码段中</p>
                        </li>
                     </ul><pre class="oac_no_warn" dir="ltr">struct person {char name [15];年龄;人[10];</pre><p><code class="codeph">person</code>变量是结构标记。这样预编译器就可以使用结构的名称来计算步幅的大小。
                     </p>
                     <ul style="list-style-type:disc">
                        <li>
                           <p>结构的成员不能是数组。此规则的唯一例外是字符类型，例如<span class="bold">char</span>或<span class="bold">VARCHAR，</span>因为在声明这些类型的变量时使用了数组语法。
                           </p>
                        </li>
                        <li>
                           <p><span class="bold">char</span>和<span class="bold">VARCHAR</span>成员可能不是二维的。
                           </p>
                        </li>
                        <li>
                           <p>嵌套结构不允许作为结构数组的成员。这不是新的限制，因为先前版本的Pro * C / C ++不支持嵌套结构。</p>
                        </li>
                        <li>
                           <p>结构的大小不得超过有符号4字节数量可能代表的最大值。这通常是2千兆字节。</p>
                        </li>
                     </ul>
                     <p>鉴于使用结构数组的这些限制，以下声明在Pro * C / C ++中是合法的</p><pre class="oac_no_warn" dir="ltr">结构部门{int deptno; char dname [15]; char loc [14]; } dept [4];</pre><p>而以下声明是非法的。</p><pre class="oac_no_warn" dir="ltr">struct {/ * struct缺少结构标记* / int empno [15]; / * struct members可能不是数组* / char ename [15] [10]; / *字符类型可能不是2维* / struct嵌套{int salary; / *结构数组中不允许使用嵌套结构* /} sal_struct;不好[15];</pre><p>同样重要的是要注意，您不能将数据类型等同应用于结构本身数组或结构中的任何单个字段。例如，假设<code class="codeph">empno</code>未在先前的非法结构中声明为数组，则以下内容是非法的：</p><pre class="oac_no_warn" dir="ltr">exec sql var bad [3] .empno是整数（4）;</pre><p>预编译器无法跟踪结构数组中的各个结构元素。另一方面，可以做以下事情以实现期望的效果。</p><pre class="oac_no_warn" dir="ltr">typedef int myint; exec sql类型myint是整数（4）; struct equiv {myint empno; / *现在合法地认为是整数（4）数据类型* / ...好的[15];</pre><p>这应该不足为奇，因为先前版本的Pro * C / C ++不支持等效单个数组项。例如，以下标量数组声明说明了什么是合法的，什么不合法。</p><pre class="oac_no_warn" dir="ltr">int empno [15]; exec sql var empno [3]是整数（4）; / *违法* / myint empno [15]; / * legal * /</pre><p>总之，您可能无法等同于任何单个数组项。</p>
                  </div>
               </div><a id="LNPCC3471"></a><div class="props_rev_3"><a id="GUID-D8D11569-BF8A-4158-8304-9CFC9CA54ED5" name="GUID-D8D11569-BF8A-4158-8304-9CFC9CA54ED5"></a><h4 id="LNPCC-GUID-D8D11569-BF8A-4158-8304-9CFC9CA54ED5" class="sect4"><span class="enumeration_section">8.10.4</span>变量指南</h4>
                  <div>
                     <p>结构体声明数组的指示符变量与普通结构声明的工作方式大致相同。结构声明的指示符数组必须遵守结构数组的规则，如下所示：</p>
                     <ul style="list-style-type:disc">
                        <li>
                           <p>指示符结构中的字段数必须小于或等于相应结构数组中的字段数。</p>
                        </li>
                        <li>
                           <p>字段的顺序必须与结构数组的相应成员的顺序匹配。</p>
                        </li>
                        <li>
                           <p>指标结构中所有元素的数据类型必须很<span class="bold">短</span> 。
                           </p>
                        </li>
                        <li>
                           <p>指标数组的大小必须至少与主机变量声明的大小相同。它可能更大，但可能不会更小。</p>
                        </li>
                     </ul>
                     <p>这些规则通常反映了在先前版本的Pro * C / C ++中实现的使用结构的规则。数组限制也与先前用于标量数组的限制相同。</p>
                     <p>根据这些规则，假设以下结构声明：</p><pre class="oac_no_warn" dir="ltr">结构部门{int deptno; char dname [15]; char loc [14]; } dept [4];</pre><p>以下是法律指标变量结构声明：</p><pre class="oac_no_warn" dir="ltr">struct department_ind {short deptno_ind;短dname_ind; short loc_ind; } dept_ind [4];</pre><p>而以下是非法的指标变量</p><pre class="oac_no_warn" dir="ltr">struct {/ *缺少指标结构标记* / int deptno_ind; / *指示符变量不是short * / short dname_ind [15]; / *数组元素禁止在指示符struct * / short loc_ind [14]; / *数组元素禁用指标struct * /} bad_ind [2]; / *指标数组大小小于主机数组* /</pre></div>
                  <div>
                     <div class="relinfo">
                        <p><strong>相关话题</strong></p>
                        <ul>
                           <li><a href="ANSI-dynamic-SQL.html#GUID-BF450DA3-B05F-403E-B5DF-C967A20524BF">ANSI动态SQL</a></li>
                        </ul>
                     </div>
                  </div>
                  
               </div><a id="LNPCC3472"></a><div class="props_rev_3"><a id="GUID-71BD1B05-AD40-4D68-8FCE-D3E4647E9815" name="GUID-71BD1B05-AD40-4D68-8FCE-D3E4647E9815"></a><h4 id="LNPCC-GUID-71BD1B05-AD40-4D68-8FCE-D3E4647E9815" class="sect4"><span class="enumeration_section">8.10.5</span>关于声明指向一组结构的指针</h4>
                  <div>
                     <p>在某些情况下，可能需要声明指向结构数组的指针。这允许将结构数组的指针传递给其他函数或直接在嵌入式SQL语句中使用。</p>
                     <div class="infoboxnote" id="GUID-71BD1B05-AD40-4D68-8FCE-D3E4647E9815__GUID-BC2A29C3-615F-4650-8B6B-78CAF7706140">
                        <p class="notep1">注意：</p>
                        <p>在预编译期间，无法知道由指向结构数组的指针引用的数组的长度。因此，当在任何嵌入式SQL语句中使用其类型是指向结构数组的指针的绑定变量时，必须使用显式FOR子句。</p>
                     </div>
                     <p>请记住，FOR子句可能不会在嵌入式SQL SELECT语句中使用。因此，要将数据检索到指向结构数组的指针，必须在FOR子句中使用显式游标和FETCH语句。</p>
                  </div>
               </div><a id="LNPCC3473"></a><div class="props_rev_3"><a id="GUID-18500D5D-0FEE-4739-8F3A-53DAF23B80F1" name="GUID-18500D5D-0FEE-4739-8F3A-53DAF23B80F1"></a><h4 id="LNPCC-GUID-18500D5D-0FEE-4739-8F3A-53DAF23B80F1" class="sect4"><span class="enumeration_section">8.10.6</span>示例</h4>
                  <div>
                     <p>以下示例演示了Pro * C / C ++中结构体数组的不同用法。</p>
                  </div><a id="LNPCC3474"></a><div class="props_rev_3"><a id="GUID-55129E5B-5D92-43DB-8ED6-380F6A5049AF" name="GUID-55129E5B-5D92-43DB-8ED6-380F6A5049AF"></a><h5 id="LNPCC-GUID-55129E5B-5D92-43DB-8ED6-380F6A5049AF" class="sect5"><span class="enumeration_section">8.10.6.1</span>示例1：Scalars结构的简单数组</h5>
                     <div>
                        <div class="section">
                           <p>鉴于以下结构声明，</p><pre class="oac_no_warn" dir="ltr">结构部门{int deptno; char dname [15]; char loc [14]; } my_dept [4];</pre><p>然后，用户可以将<code class="codeph">dept</code>数据选择到<code class="codeph">my_dept</code> ，如下所示：</p><pre class="oac_no_warn" dir="ltr">exec sql select * into：my_dept from dept;</pre><p>或者用户可以首先填充<code class="codeph">my_dept</code> ，然后将其批量插入到<code class="codeph">dept</code>表中：</p><pre class="oac_no_warn" dir="ltr">exec sql insert into dept values（：my_dept）;</pre><p>要使用指示符变量，可以声明结构的并行指示符数组。</p><pre class="oac_no_warn" dir="ltr">struct deptartment_ind {short deptno_ind;短dname_ind; short loc_ind; } my_dept_ind [4];</pre><p>然后使用相同的查询选择数据，但添加指示符变量除外：</p><pre class="oac_no_warn" dir="ltr">exec sql select * into：my_dept indicator：my_dept_ind from dept;</pre><p>同样，插入数据时也可以使用指标：</p><pre class="oac_no_warn" dir="ltr">exec sql insert into dept values（：my_dept indicator：my_dept_ind）;</pre></div>
                        <!-- class="section" -->
                     </div>
                  </div><a id="LNPCC3475"></a><div class="props_rev_3"><a id="GUID-43E99F57-5FC9-4CB1-966A-1235F6BCC9D9" name="GUID-43E99F57-5FC9-4CB1-966A-1235F6BCC9D9"></a><h5 id="LNPCC-GUID-43E99F57-5FC9-4CB1-966A-1235F6BCC9D9" class="sect5"><span class="enumeration_section">8.10.6.2</span>示例2：使用具有结构数组的混合标量数组</h5>
                     <div>
                        <div class="section">
                           <p>与Pro * C / C ++的早期版本一样，当使用多个数组批量处理用户数据时，数组的大小必须相同。如果不是，则选择最小的阵列大小，使阵列的其余部分不受影响。</p>
                           <p>鉴于以下声明，</p><pre class="oac_no_warn" dir="ltr">struct employee {int empno; char ename [11]; } emp [14]; float sal [14]; float comm [14];</pre><p>可以在一个简单查询中为所有列选择多行：</p><pre class="oac_no_warn" dir="ltr">exec sql select empno，ename，sal，comm into：emp，：sal，：comm from emp;</pre><p>我们还想知道佣金的列值是否为NULL。在给出以下声明的情况下，可以使用单个指标数组：</p><pre class="oac_no_warn" dir="ltr">简短的comm_ind [14]; ...exec sql select empno，ename，sal，comm into：emp，：sal，：comm indicator：comm_ind from emp;</pre><p>您不能声明封装查询中所有指示符信息的结构的单个指示符数组。因此：</p><pre class="oac_no_warn" dir="ltr">struct employee_ind {/ *非法使用的例子* / short empno_ind;简短的ename_ind;短sal_ind;简短的comm_ind; } illegal_ind [15]; exec sql select empno，ename，sal，comm into：emp，：sal，：comm indicator：illegal_ind from emp;</pre><p>是非法的（也是不受欢迎的）。早期的语句仅将指标数组与<code class="codeph">comm</code>列相关联，而不是整个SELECT ...INTO列表。
                           </p>
                           <p>假设结构数组和<code class="codeph">sal</code> ， <code class="codeph">comm</code>和<code class="codeph">comm_ind</code>数组填充了所需的数据，插入很简单：</p><pre class="oac_no_warn" dir="ltr">exec sql insert into emp（empno，ename，sal，comm）values（：emp，：sal，：comm indicator：comm_ind）;</pre></div>
                        <!-- class="section" -->
                     </div>
                  </div><a id="LNPCC3476"></a><div class="props_rev_3"><a id="GUID-84333DFB-2B03-4309-A7AD-FEE1CA9D0C99" name="GUID-84333DFB-2B03-4309-A7AD-FEE1CA9D0C99"></a><h5 id="LNPCC-GUID-84333DFB-2B03-4309-A7AD-FEE1CA9D0C99" class="sect5"><span class="enumeration_section">8.10.6.3</span>示例3：使用带有光标的多个结构数组</h5>
                     <div>
                        <p>对于此示例，我们进行以下声明：</p><pre class="oac_no_warn" dir="ltr">struct employee {int empno; char ename [11]; char job [10]; } emp [14];结构补偿{int sal; int comm;工资[14]; struct compensation_ind {short sal_ind;简短的comm_ind; } wage_ind [14];</pre><p>然后我们的程序可以使用这些结构数组，如下所示：</p><pre class="oac_no_warn" dir="ltr">exec sql声明c光标用于选择empno，ename，job，sal，comm来自emp; exec sql open c; exec sql什么都没找到做破坏; while（1）{exec sql fetch c into：emp，：wage indicator：wage_ind; ...处理获取返回的批处理行...} printf（“％d rows selected。\ n”，sqlca.sqlerrd [2]）; exec sql close c;</pre></div><a id="LNPCC3477"></a><div class="props_rev_3"><a id="GUID-9151E87D-704E-43E3-9C5D-2916FA41E9F1" name="GUID-9151E87D-704E-43E3-9C5D-2916FA41E9F1"></a><h6 id="LNPCC-GUID-9151E87D-704E-43E3-9C5D-2916FA41E9F1" class="sect6"><span class="enumeration_section">8.10.6.3.1</span>关于使用FOR子句</h6>
                        <div>
                           <p>或者，我们可以使用FOR子句来指示获取要检索的行数。回想一下，在使用SELECT语句时禁止使用FOR子句，而不是INSERT或FETCH语句。</p>
                           <p>我们在原始声明中添加以下内容</p><pre class="oac_no_warn" dir="ltr">int limit = 10;</pre><p>并相应地编码我们的例子。</p><pre class="oac_no_warn" dir="ltr">exec sql for：limit fetch c into：emp，：wage indicator：wage_ind;</pre></div>
                     </div>
                  </div><a id="LNPCC3478"></a><div class="props_rev_3"><a id="GUID-8925E236-45DE-4F20-AF5E-4B8C214DE152" name="GUID-8925E236-45DE-4F20-AF5E-4B8C214DE152"></a><h5 id="LNPCC-GUID-8925E236-45DE-4F20-AF5E-4B8C214DE152" class="sect5"><span class="enumeration_section">8.10.6.4</span>示例4：单个阵列和结构成员引用</h5>
                     <div>
                        <p>Pro * C / C ++的早期版本允许对结构数组中的单个结构进行数组引用。因此，以下内容是合法的，因为绑定表达式解析为一个简单的标量结构。</p><pre class="oac_no_warn" dir="ltr">exec sql select * into：dept [3] from emp;</pre><p>用户可以在结构数组中引用特定结构的单个标量成员，如以下示例所示。</p><pre class="oac_no_warn" dir="ltr">exec sql选择dname into：dept [3] .dname from dept where ...;</pre><p>当然，这要求查询是单行查询，因此只有一行被选择到此绑定表达式表示的变量中。</p>
                     </div>
                  </div><a id="LNPCC3479"></a><div class="props_rev_3"><a id="GUID-AA226E1A-9923-4AF3-9D05-C8FB28A5453E" name="GUID-AA226E1A-9923-4AF3-9D05-C8FB28A5453E"></a><h5 id="LNPCC-GUID-AA226E1A-9923-4AF3-9D05-C8FB28A5453E" class="sect5"><span class="enumeration_section">8.10.6.5</span>示例5：使用指标变量，特殊情况</h5>
                     <div>
                        <p>Pro * C / C ++的早期版本要求指标结构与其关联的绑定结构具有相同数量的字段。一般使用结构时，这种限制已经放宽。通过遵循前面提到的结构指示器数组的指导原则，可以构造以下示例。</p><pre class="oac_no_warn" dir="ltr">struct employee {float comm;漂浮int empno; char ename [10]; } emp [14]; struct employee_ind {short comm; } emp_ind [14]; exec sql select comm，sal，empno，ename into：emp indicator：emp_ind from emp;</pre><p>指标变量到绑定值的映射是一对一的。它们以第一个字段开始的关联顺序映射。</p>
                        <p>但请注意，如果任何其他字段的读取值为NULL且未提供指示符，则会引发以下错误：</p><pre class="oac_no_warn" dir="ltr">ORA-1405：获取的列值为NULL</pre><p>例如，如果<code class="codeph">sal</code>为空，那就是这种情况，因为没有<code class="codeph">sal</code>指示。
                        </p>
                        <p>假设我们更改结构数组如下，</p><pre class="oac_no_warn" dir="ltr">struct employee {int empno; char ename [10];漂浮浮动通讯; } [15];</pre><p>但仍然使用相同的结构指标数组。</p>
                        <p>因为指示符以关联顺序顺序映射，所以<code class="codeph">comm</code>指示符映射到<code class="codeph">empno</code>字段，而没有指示符的<code class="codeph">comm</code>绑定变量再次导致ORA-1405错误。
                        </p>
                        <p>为了避免ORA-1405在使用字段少于其关联绑定变量结构的指示符结构时，可以为空的属性首先出现并按顺序出现。</p>
                        <p>我们可以通过使用非数组结构轻松地将其更改为涉及多个列的单行提取，并期望它的工作方式就像指示器结构声明如下。</p><pre class="oac_no_warn" dir="ltr">struct employee_ind {short comm;短sal;简短的;短暂的; } emp_ind;</pre><p>因为Pro * C / C ++不再要求指标结构与其关联的值结构具有相同数量的字段，所以前面的示例现在在Pro * C / C ++中是合法的，而之前它不是。</p>
                        <p>我们的指标结构现在看起来像下面的简单结构。</p><pre class="oac_no_warn" dir="ltr">struct employee_ind {short comm; } emp_ind;</pre><p>使用非数组<code class="codeph">emp</code>和<code class="codeph">emp_ind</code>结构，我们能够执行如下的单行提取。
                        </p><pre class="oac_no_warn" dir="ltr">exec sql fetch comm，sal，empno，ename into：emp indicator：emp_ind from emp;</pre><p>再次注意在这种情况下<code class="codeph">comm</code>指示符如何映射到<code class="codeph">comm</code>绑定变量。
                        </p>
                     </div>
                  </div><a id="LNPCC3480"></a><div class="props_rev_3"><a id="GUID-3985C508-15E5-4574-A6F1-C06BE2D4BDF5" name="GUID-3985C508-15E5-4574-A6F1-C06BE2D4BDF5"></a><h5 id="LNPCC-GUID-3985C508-15E5-4574-A6F1-C06BE2D4BDF5" class="sect5"><span class="enumeration_section">8.10.6.6</span>示例6：使用指向结构数组的指针</h5>
                     <div>
                        <p>此示例演示如何使用指向结构数组的指针。</p>
                        <p>给出以下类型声明：</p><pre class="oac_no_warn" dir="ltr">typedef struct dept {int deptno; char dname [15]; char loc [14]; } dept;</pre><p>我们可以执行各种操作，操作指向该类型结构数组的指针。例如，我们可以将指向结构数组的指针传递给其他函数。</p><pre class="oac_no_warn" dir="ltr">void insert_data（d，n）dept * d; int n; {exec sql for：n insert into dept values（：d）; } void fetch_data（d，n）dept * d; int n; {exec sql声明c光标用于选择deptno，dname，loc来自dept; exec sql open c; exec sql for：n fetch c into：d; exec sql close c; }</pre><p>通过传递结构数组的地址来调用这些函数，如这些示例所示。</p><pre class="oac_no_warn" dir="ltr">部门[4]; dept * dptr =＆d [0]; const int n = 4; fetch_data（dptr，n）; insert_data（d，n）; / *我们将'＆d [0]'视为等于'd'* /</pre><p>或者我们可以直接在某些嵌入式SQL语句中使用这些指针到结构数组。</p><pre class="oac_no_warn" dir="ltr">exec sql for：n insert into dept values（：dptr）;</pre><p>要记住的最重要的事情是使用FOR子句。</p>
                     </div>
                  </div>
               </div>
            </div><a id="LNPCC3481"></a><div class="props_rev_3"><a id="GUID-DBA71301-C6C4-47C0-BAB5-1B6B221AB46E" name="GUID-DBA71301-C6C4-47C0-BAB5-1B6B221AB46E"></a><h3 id="LNPCC-GUID-DBA71301-C6C4-47C0-BAB5-1B6B221AB46E" class="sect3"><span class="enumeration_section">8.11</span>关于模仿CURRENT OF</h3>
               <div>
                  <p>您可以在DELETE或UPDATE语句中使用CURRENT OF <span class="italic">游标</span>子句来引用游标中的最新行FETCHed。但是，您不能将CURRENT OF与主机阵列一起使用。而是选择每行的ROWID，然后使用该值在更新或删除期间标识当前行。
                  </p>
                  <p>例如： <a id="d40176e1780" class="indexterm-anchor"></a><a id="d40176e1786" class="indexterm-anchor"></a> 
                  </p><pre class="oac_no_warn" dir="ltr">char emp_name [20] [10]; char job_title [20] [10]; char old_title [20] [10]; char row_id [20] [19]; ...EXEC SQL DECLARE emp_cursor CURSOR FOR SELECT ename，job，rowid FROM emp FOR UPDATE; ...EXEC SQL OPEN emp_cursor; EXEC SQL WHENEVER NOT FOUND会破坏; for（;;）{EXEC SQL FETCH emp_cursor INTO：emp_name，：job_title，：row_id; ...EXEC SQL DELETE FROM emp WHERE job =：old_title AND rowid =：row_id; EXEC SQL COMMIT WORK; }</pre><p></p>
               </div>
               <div>
                  <div class="relinfo">
                     <p><strong>相关话题</strong></p>
                     <ul>
                        <li><a href="embedded-SQL.html#GUID-CB61E704-AA77-4F5F-BF67-A3E4F58C63C6">条款的当前条款</a></li>
                     </ul>
                  </div>
               </div>
               
            </div><a id="LNPCC3484"></a><a id="LNPCC3485"></a><a id="LNPCC3486"></a><a id="LNPCC3482"></a><div class="props_rev_3"><a id="GUID-D71CE5C4-383A-4B6A-994A-2E3C321EA408" name="GUID-D71CE5C4-383A-4B6A-994A-2E3C321EA408"></a><h3 id="LNPCC-GUID-D71CE5C4-383A-4B6A-994A-2E3C321EA408" class="sect3"><span class="enumeration_section">8.12</span>关于使用附加阵列插入/选择语法</h3>
               <div>
                  <p>Oracle预编译器还支持主机表的DB2插入和获取语法。支持的附加阵列插入和获取语法分别在下图中示出。</p>
                  <div class="figure" id="GUID-D71CE5C4-383A-4B6A-994A-2E3C321EA408__GUID-0C4CB3AC-E244-4C9C-9433-9DE1F5DE5BB5">
                     <p class="titleinfigure">图8-1其他插入语法</p><img src="img/insert2.png" alt="下面是图8-1的描述" title="下面是图8-1的描述" longdesc="img_text/insert2.html"><br><a href="img_text/insert2.html">“图8-1附加插入语法”的说明</a></div>
                  <!-- class="figure" -->
                  <div class="figure" id="GUID-D71CE5C4-383A-4B6A-994A-2E3C321EA408__GUID-2085F504-60BB-4ED4-A488-C94E3329CBE9">
                     <p class="titleinfigure">图8-2其他提取语法</p><img src="img/fetch2.png" alt="下面是图8-2的描述" title="下面是图8-2的描述" longdesc="img_text/fetch2.html"><br><a href="img_text/fetch2.html">“图8-2附加提取语法”的说明</a></div>
                  <!-- class="figure" -->
                  <p>可选的ROWSET和ROWSET STARTING AT子句用于获取方向（FIRST，PRIOR，NEXT，LAST，CURRENT，RELATIVE和ABSOLUTE）。请考虑以下示例：</p>
                  <ul style="list-style-type:disc">
                     <li>
                        <p>第一行</p>
                     </li>
                     <li>
                        <p>先前的行</p>
                     </li>
                     <li>
                        <p>下一行</p>
                     </li>
                     <li>
                        <p>最后一行</p>
                     </li>
                     <li>
                        <p>当前行</p>
                     </li>
                     <li>
                        <p>ROWSET在RELATIVEn开始</p>
                     </li>
                     <li>
                        <p>在ABSOLUTEn开始的ROWSET</p>
                     </li>
                  </ul>
                  <p><a href="host-arrays.html#GUID-D71CE5C4-383A-4B6A-994A-2E3C321EA408__BABHDBHI" title="DB2与Oracle预编译器语法">表8-3</a>中显示了DB2数组插入/获取语法的示例以及它们与相应的Oracle预编译器语法的比较：</p>
                  <div class="tblformal" id="GUID-D71CE5C4-383A-4B6A-994A-2E3C321EA408__BABHDBHI">
                     <p class="titleintable">表8-3 DB2阵列语法与Oracle预编译器语法</p>
                     <table cellpadding="4" cellspacing="0" class="Formal" title="DB2阵列语法与Oracle预编译器语法" width="100%" border="1" summary="DB2 vs. Oracle Precompiler syntax" frame="hsides" rules="rows">
                        <thead>
                           <tr align="left" valign="top">
                              <th align="left" valign="bottom" width="47%" id="d40176e1869">DB2阵列语法</th>
                              <th align="left" valign="bottom" width="53%" id="d40176e1872">Oracle预编译器语法</th>
                           </tr>
                        </thead>
                        <tbody>
                           <tr align="left" valign="top">
                              <td align="left" valign="top" width="47%" id="d40176e1877" headers="d40176e1869 "><pre class="oac_no_warn" dir="ltr">EXEC SQL INSERT INTO dsn8810.act（actno，actkwd，actdesc）VALUES（：hva1，：hva2，：hva3）FOR：NUM_ROWS ROWS;</pre></td>
                              <td align="left" valign="top" width="53%" headers="d40176e1877 d40176e1872 "><pre class="oac_no_warn" dir="ltr">EXEC SQL FOR：num_rows INSERT INTO dsn8810.act（actno，actkwd，actdesc）VALUES（：hva1，：hva2，：hva3）;</pre></td>
                           </tr>
                           <tr align="left" valign="top">
                              <td align="left" valign="top" width="47%" id="d40176e1884" headers="d40176e1869 "><pre class="oac_no_warn" dir="ltr">EXEC SQL FETCH NEXT ROWSET from c1 FOR 20 ROWS INTO：hva_empno，：hva_lastname，：hva_salary;</pre></td>
                              <td align="left" valign="top" width="53%" headers="d40176e1884 d40176e1872 "><pre class="oac_no_warn" dir="ltr">EXEC SQL FOR：二十二个FETCH c1 INTO：hva_empno，：hva_lastname，：hva_salary;</pre></td>
                           </tr>
                        </tbody>
                     </table>
                  </div>
                  <!-- class="inftblhruleinformal" -->
                  <p>在DB2语法中，应在检索行数据集之前首先声明行集定位游标。要使游标能够获取行集，必须在DECLARE CURSOR语句中使用'WITH ROWSET POSITIONING'子句，这在Oracle预编译器语法中不是必需且相关的，如下表所示。</p>
                  <div class="tblformal" id="GUID-D71CE5C4-383A-4B6A-994A-2E3C321EA408__GUID-92D03384-5B5C-452F-A456-18FECA776FEC">
                     <table cellpadding="4" cellspacing="0" class="Formal" title="" width="100%" border="1" summary="table for difference between DB2 and Oracle precompiler syntax" frame="hsides" rules="rows">
                        <thead>
                           <tr align="left" valign="top">
                              <th align="left" valign="bottom" width="43%" id="d40176e1900">DB2阵列语法</th>
                              <th align="left" valign="bottom" width="57%" id="d40176e1903">Oracle预编译器语法</th>
                           </tr>
                        </thead>
                        <tbody>
                           <tr align="left" valign="top">
                              <td align="left" valign="top" width="43%" id="d40176e1908" headers="d40176e1900 "><pre class="oac_no_warn" dir="ltr">EXEC SQL DECLARE c1 CURSOR，带有ROWSET POSITIONING FOR SELECT empno，lastname，salary FROM dsn8810.emp;</pre></td>
                              <td align="left" valign="top" width="57%" headers="d40176e1908 d40176e1903 "><pre class="oac_no_warn" dir="ltr">EXEC SQL DECLARE c1 CURSOR FOR SELECT empno，lastname，salary FROM dsn8810.emp;</pre></td>
                           </tr>
                        </tbody>
                     </table>
                  </div>
                  <!-- class="inftblhruleinformal" -->
                  <p>可以使用预编译器选项<code class="codeph">db2_array</code>启用此DB2数组语法支持，该选项的默认选项为<code class="codeph">no</code> 。DB2数组语法支持不能与Oracle预编译器语法一起使用;只支持一种语法，一次只支持语法，Oracle预编译器或DB2语法。
                  </p>
                  <div class="example" id="GUID-D71CE5C4-383A-4B6A-994A-2E3C321EA408__GUID-CCF37220-D9B8-406F-A60C-999622BEEABF">
                     <p class="titleinexample">示例8-1使用DB2数组语法插入和获取行</p>
                     <p>此程序使用DB2数组插入语法将INSCNT行插入EMP表，然后使用DB2数组提取语法提取插入的行。</p><pre class="oac_no_warn" dir="ltr">/ * * db2arrdemo.pc * / #include &lt;stdio.h&gt; #include &lt;string.h&gt; #include &lt;stdlib.h&gt; #include &lt;sqlda.h&gt; #include &lt;sqlcpr.h&gt; #include &lt;sqlca.h&gt; / *一次性插入的行数* / #define INSCNT 100 / *一次性获取的行数* / #define FETCHCNT 20 / *定义用于将数据插入表中以及用于获取数据的主机结构来自表* / struct emprec {int empno; varchar ename [10]; varchar job [9]; int mgr; char hiredate [10];漂浮浮动通讯; int deptno; }; typedef struct emprec empdata; / *函数原型* / void sql_error（char *）; void insertdata（）; void fetchdata（）; void printempdata（empdata *）; void main（）{exec sql begin declare section; char * uid =“scott / tiger”; exec sql end declare section; exeler sql每当sqlerror执行sql_error（“ORACLE error  -  \ n”）; exec sql connect：uid; printf（“使用DB2数组插入语法将％d行插入EMP表。\ n”，INSCNT）; insertdata（）; printf（“\ n使用DB2数组获取语法获取数据。\ n”）; fetchdata（）; exec sql rollback工作版;出口（EXIT_SUCCESS）;使用DB2数组插入语法将数据插入表中* / void insertdata（）{int i，cnt; char * str; empdata emp_in [INSCNT]; / *存储临时字符串* / str =（char *）malloc（25 * sizeof（char））; / *填充数组元素以插入* / for（i = 0; i &lt;INSCNT; i ++）{emp_in [i] .empno = i + 1; sprintf（str，“EMP_％03d”，i + 1）; strcpy（emp_in [i] .ename.arr，str）; emp_in [i] .ename.len = strlen（emp_in [i] .ename.arr）; sprintf（str，“JOB_％03d”，i + 1）; strcpy（emp_in [i] .job.arr，str）; emp_in [i] .job.len = strlen（emp_in [i] .job.arr）; emp_in [i] .mgr = i + 1001; sprintf（str，“％02d-MAY-06”，（i％30）+1）; strcpy（emp_in [i] .hiredate，str）; emp_in [i] .sal =（i + 1）* 10; emp_in [i] .comm =（i + 1）* 0.1; emp_in [i] .deptno = 10; } free（str）; / *使用DB2数组插入语法插入数据* / exec sql insert into emp values（：emp_in）FOR：INSCNT rows; exec sql select count（*）into：cnt from emp where ename like'EMP_％'; printf（“成功插入emp表的行数：％d \ n”，cnt）; / *使用DB2数组获取语法从表中获取数据* / void fetchdata（）{empdata emp_out [FETCHCNT]; / *声明可滚动游标以获取数据* / exec sql声明c1使用行集定位滚动游标以选择empno，ename，job，mgr，hiredate，sal，comm，deptno来自emp，其中ename类似'EMP_％'命令由empno; exec sql open c1; exec sql什么都没找到做破坏; while（1）{/ *使用DB2数组获取语法获取数据* / exec sql从c1获取下一行集：FETCHCNT行：emp_out; printempdata（emp_out）;每当找不到exec sql sql_error（“ORACLE ERROR”）; exec sql close c1; } / *打印获取的员工数据* / void printempdata（empdata * emp_out）{int i; for（i = 0; i &lt;FETCHCNT; i ++）{emp_out [i] .ename.arr [emp_out [i] .ename.len] ='\ 0'; emp_out [i] .job.arr [emp_out [i] .job.len] ='\ 0'; printf（“Empno =％d，Ename =％s，Job =％s，Mgr =％d，Hiredate =％s，Sal =％6.2f，\ n”“Comm =％5.2f，Deptno =％d \ n “，emp_out [i] .empno，emp_out [i] .ename.arr，emp_out [i] .job.arr，emp_out [i] .mgr，emp_out [i] .hiredate，emp_out [i] .sal，emp_out [我] .comm，emp_out [i] .deptno）;错误处理函数。* / void sql_error（char * msg）{exec sql每当sqlerror继续; printf（“\ n％s \ n”，msg）; printf（“％。70s \ n”，sqlca.sqlerrm.sqlerrmc）; exec sql rollback release;出口（EXIT_FAILURE）; }</pre></div>
                  <!-- class="example" -->
               </div>
            </div><a id="LNPCC3488"></a><a id="LNPCC3487"></a><div class="props_rev_3"><a id="GUID-DBC05FB2-D78C-4FF2-83F8-9D382F0F3786" name="GUID-DBC05FB2-D78C-4FF2-83F8-9D382F0F3786"></a><h3 id="LNPCC-GUID-DBC05FB2-D78C-4FF2-83F8-9D382F0F3786" class="sect3"><span class="enumeration_section">8.13</span>关于使用隐式缓冲插入</h3>
               <div>
                  <p>为了提高性能，Pro * C / C ++应用程序开发人员可以在其嵌入式SQL语句中引用主机数组。这提供了一种通过单次往返数据库来执行SQL语句数组的方法。尽管阵列执行提供了显着的性能改进，但一些开发人员选择不使用此功能，因为它不是ANSI标准。例如，使用IBM的预编译器无法预编译在Oracle中利用数组执行编写的应用程序。</p>
                  <p>一种解决方法是使用缓冲的INSERT语句，这使您可以在保留ANSI标准嵌入式SQL语法的同时获得性能优势。</p>
                  <p>命令行选项“max_row_insert”控制在执行INSERT语句之前要缓冲的行数。默认情况下，它为零，并且禁用该功能。要启用此功能，请指定任何大于零的数字。</p>
                  <p>如果启用了插入缓冲，则预编译器运行时将标记相应的光标并：</p>
                  <ul style="list-style-type:disc">
                     <li>
                        <p>分配或重新分配额外的内存以保存绑定值（仅首先执行）。</p>
                     </li>
                     <li>
                        <p>将绑定值从程序主机变量复制到内部运行时绑定结构。</p>
                     </li>
                     <li>
                        <p>增加行缓冲计数。</p>
                     </li>
                     <li>
                        <p>如果MAX_INSERT_ROWS已被缓冲，则刷新缓冲的INSERT语句。</p>
                     </li>
                     <li>
                        <p>如果尚未命中MAX_INSERT_ROWS，则在将值复制到内部绑定缓冲区而不刷新后返回。</p>
                     </li>
                  </ul>
                  <p>如果执行新的嵌入式SQL语句并导致刷新缓冲的插入语句：</p>
                  <ul style="list-style-type:disc">
                     <li>
                        <p>冲洗缓冲区。</p>
                     </li>
                     <li>
                        <p>继续提示刷新的调用。</p>
                     </li>
                  </ul>
                  <p>通过标准预编译器错误机制（例如Pro * C中的sqlca）通知应用程序错误。</p>
                  <p>“implicit_svpt”选项控制是否在新批处理插入的开始之前采用隐式保存点。</p>
                  <ul style="list-style-type:disc">
                     <li>
                        <p>如果是，则在开始新批次行之前获取保存点。如果插入时发生错误，则执行隐式“回滚到保存点”。</p>
                     </li>
                     <li>
                        <p>如果不是，则不会采用隐式保存点。如果缓冲插入时发生错误，则会将其报告回应用程序，但不会执行回滚。缓冲区插入异步报告错误。在应用程序中执行INSERT语句时，不会报告插入行的错误。</p>
                        <ul style="list-style-type:disc">
                           <li>
                              <p>当执行除INSERT之外的第一个语句时，稍后将报告插入行的某些错误。这可能包括DELETE，UPDATE，INSERT（进入不同的表），COMMIT和ROLLBACK。任何关闭缓冲插入语句的语句都可以报告错误。在这种情况下，不会执行报告错误的语句。您需要首先处理错误并重新执行报告缓冲插入错误的语句。否则，您可以回滚事务并重新执行它。</p>
                              <p>例如，考虑使用COMMIT语句来关闭缓冲的插入循环。COMMIT可以报告错误，因为来自先前插入的重复键。在这种情况下，不执行提交。您应该首先处理错误，然后重新执行COMMIT。否则，您可以回滚事务并重新执行它。</p>
                           </li>
                           <li>
                              <p>插件本身会报告一些错误，并且可能反映先前插入的行的错误。在这种情况下，不会执行进一步的插入。您需要处理先前插入的行的错误并继续插入当前插入，这是一个漫长的过程。相反，您可以回滚并重新执行该事务。</p>
                              <p>例如，考虑内部缓冲区的限制为10行，应用程序在循环中插入15行。假设第8行有错误。第11行插入发生时报告错误，并且不再执行插入操作。</p>
                           </li>
                        </ul>
                     </li>
                  </ul>
                  <p>以下是缓冲插入期间可能遇到的一些错误：</p>
                  <ul style="list-style-type:disc">
                     <li>
                        <p>ORA-00001：索引中的重复键</p>
                     </li>
                     <li>
                        <p>ORA-01400：在插入期间缺少必需（非空）列或Null</p>
                     </li>
                     <li>
                        <p>ORA-01401：插入的值对于列太大</p>
                     </li>
                     <li>
                        <p>ORA-01438：大于指定精度的值允许此列</p>
                     </li>
                  </ul>
                  <div class="example" id="GUID-DBC05FB2-D78C-4FF2-83F8-9D382F0F3786__GUID-F968B692-F649-4EC6-B492-A813A14BFEBD">
                     <p class="titleinexample">示例8-2将缓冲行插入表中</p>
                     <p>该程序将LOOPCNT行数插入EMP表。在循环计数器= 5时，此程序尝试插入无效的empno。如果没有max_row_insert选项，程序将插入除无效行之外的所有行。当max_row_insert选项设置为LOOPCNT时，仅插入前四行。</p>
                     <p>使用max_row_insert选项，当删除错误语句时，程序执行与数组插入程序相同的方式。</p><pre class="oac_no_warn" dir="ltr">/ * * bufinsdemo.pc * / #include &lt;stdio.h&gt; #include &lt;string.h&gt; #include &lt;stdlib.h&gt; #include &lt;sqlda.h&gt; #include &lt;sqlcpr.h&gt; #include &lt;sqlca.h&gt; / *要插入表中的行数* / #define LOOPCNT 100 / *定义一个主机结构，用于将数据插入表中以及从表中获取数据* / struct emprec {int empno; varchar ename [10]; varchar job [9]; int mgr; char hiredate [10];漂浮浮动通讯; int deptno; }; typedef struct emprec buffinstyp; / *函数原型* / void sql_error（）; void insertdata（）; void fetchdata（）; void printempdata（buffinstyp）; void main（）{exec sql begin declare section; char * uid =“scott / tiger”; exec sql end declare section;每当sqlerror执行sql_error（）时exec sql; exec sql connect：uid; printf（“\ n将％d行插入EMP表。\ n”，LOOPCNT）; insertdata（）; printf（“\ n从EMP表中获取插入的数据。\ n”）; fetchdata（）; exec sql从emp删除，其中empno &lt;1000; exec sql commit work release;出口（EXIT_SUCCESS）; / *将数据插入表* / void insertdata（）{int i，cnt; char * str; buffinstyp emp_in; / *存储临时字符串* / str =（char *）malloc（25 * sizeof（char））; / * *当max_row_insert选项设置为LOOPCNT并且删除errorneous *语句时，所有行将在*一段中插入数据库，因此将实现最大性能增益。* / for（i = 1; i &lt;= LOOPCNT; i ++）{if（i！）= 5）emp_in.empno = i; else / *错误的陈述。在emp表中，empno被定义为数字（4）。* / emp_in.empno = 10000; sprintf（str，“EMP_％03d”，i）; strcpy（emp_in.ename.arr，str）; emp_in.ename.len = strlen（emp_in.ename.arr）; sprintf（str，“JOB_％03d”，i）; strcpy（emp_in.job.arr，str）; emp_in.job.len = strlen（emp_in.job.arr）; emp_in.mgr = i + 1001; sprintf（str，“％02d-MAY-06”，（i％30））; strcpy（emp_in.hiredate，str）; emp_in.sal =（i）* 10; emp_in.comm =（i）* 0.1; emp_in.deptno = 10; exec sql insert into emp values（：emp_in）; } free（str）; exec sql commit; exec sql select count（*）into：cnt from emp where ename like'EMP_％'; printf（“成功插入emp表的行数：％d \ n”，cnt）; / *从表中获取数据* / void fetchdata（）{buffinstyp emp_out; / *声明游标只获取插入的行* / exec sql声明c1游标用于选择empno，ename，job，mgr，hiredate，sal，comm，deptno来自emp，其中ename类似'EMP_％'命令由empno; exec sql open c1; exec sql什么都没找到做破坏; while（1）{/ *在每次调用时获取单行* / exec sql fetch c1 into：emp_out; printempdata（emp_out）;每当找不到exec sql sql_error（）; exec sql close c1; } / *打印获取的员工数据* / void printempdata（buffinstyp emp_out）{emp_out.ename.arr [emp_out.ename.len] ='\ 0'; emp_out.job.arr [emp_out.job.len] ='\ 0'; printf（“Empno =％d，Ename =％s，Job =％s，Mgr =％d，Hiredate =％s，Sal =％6.2f，\ n”“Comm =％5.2f，Deptno =％d \ n “，emp_out.empno，emp_out.ename.arr，emp_out.job.arr，emp_out.mgr，emp_out.hiredate，emp_out.sal，emp_out.comm，emp_out.deptno）; } / *错误处理函数。* / void sql_error（）{printf（“Error％s \ n”，sqlca.sqlerrm.sqlerrmc）; printf（“Rows Processed：％d \ n”，sqlca.sqlerrd [2]）; printf（“Rows Rolled Back：％d \ n”，sqlca.sqlerrd [0]）; }</pre></div>
                  <!-- class="example" -->
               </div>
            </div><a id="LNPCC3489"></a><div class="props_rev_3"><a id="GUID-A1C3ABC6-1446-4D0A-A4A7-045CDC6DAEF5" name="GUID-A1C3ABC6-1446-4D0A-A4A7-045CDC6DAEF5"></a><h3 id="LNPCC-GUID-A1C3ABC6-1446-4D0A-A4A7-045CDC6DAEF5" class="sect3"><span class="enumeration_section">8.14可</span>滚动游标</h3>
               <div>
                  <p>可滚动游标是Oracle执行SQL语句并存储在执行期间处理的信息的工作区。执行游标时，查询结果将放入一组称为结果集的行中。结果集可以按顺序或非顺序获取。非顺序结果集称为可滚动游标。可滚动游标使用户能够以前向，后向和随机方式访问数据库结果集的行。这使程序能够获取结果集中的任何行。</p>
               </div>
            </div>
         </div>
      </article>
   </body>
</html>