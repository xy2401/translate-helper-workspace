<html lang="en-us" dir="ltr" xml:lang="en-us">
   <head>
      <meta http-equiv="Content-Type" content="text/html; charset=utf-8"></meta>
      <meta name="viewport" content="width=device-width, initial-scale=1"></meta>
      <meta http-equiv="X-UA-Compatible" content="IE=edge"></meta>
      <title>公式，模型，聚合和分配</title>
      <meta property="og:site_name" content="Oracle Help Center"></meta>
      <meta property="og:title" content="DML Reference"></meta>
      <meta property="og:description" content=""></meta>
      <link rel="stylesheet" href="/sp_common/book-template/ohc-book-template/css/book.css"></link>
      <link rel="shortcut icon" href="/sp_common/book-template/ohc-common/img/favicon.ico"></link>
      <meta name="application-name" content="DML Reference"></meta>
      <meta name="generator" content="DITA Open Toolkit version 1.8.5 (Mode = doc)"></meta>
      <meta name="plugin" content="SP_docbuilder HTML plugin release 18.2.2"></meta>
      <link rel="alternate" href="olap-dml-reference.pdf" title="PDF File" type="application/pdf"></link>
      <meta name="robots" content="all"></meta>
      <link rel="schema.dcterms" href="http://purl.org/dc/terms/"></link>
      <meta name="dcterms.created" content="2019-01-10T13:59:56-08:00"></meta>
      
      <meta name="dcterms.dateCopyrighted" content="1994, 2019"></meta>
      <meta name="dcterms.category" content="database"></meta>
      <meta name="dcterms.identifier" content="E96403-01"></meta>
      
      <meta name="dcterms.product" content="en/database/oracle/oracle-database/19"></meta>
      
      <link rel="prev" href="data-types-operators-and-expressions.html" title="Previous" type="text/html"></link>
      <link rel="next" href="olap-dml-properties.html" title="Next" type="text/html"></link>
      <script>
        document.write('<style type="text/css">');
        document.write('body > .noscript, body > .noscript ~ * { visibility: hidden; }');
        document.write('</style>');
     </script>
      <script src="/sp_common/book-template/requirejs/require.js" data-main="/sp_common/book-template/ohc-book-template/js/book-config"></script>
      <script>
            if (window.require === undefined) {
                document.write('<script data-main="sp_common/book-template/ohc-book-template/js/book-config" src="sp_common/book-template/requirejs/require.js"><\/script>');
                document.write('<link href="sp_common/book-template/ohc-book-template/css/book.css" rel="stylesheet"/>');
            }
        </script>
      <script type="application/json" id="ssot-metadata">{"primary":{"category":{"short_name":"database","element_name":"Database","display_in_url":true},"suite":{"short_name":"oracle","element_name":"Oracle","display_in_url":true},"product_group":{"short_name":"not-applicable","element_name":"Not applicable","display_in_url":false},"product":{"short_name":"oracle-database","element_name":"Oracle Database","display_in_url":true},"release":{"short_name":"19","element_name":"Release 19","display_in_url":true}}}</script>
      
    <meta name="dcterms.title" content="OLAP DML Reference"></meta>
    <meta name="dcterms.isVersionOf" content="OLADM"></meta>
    <meta name="dcterms.release" content="Release 19"></meta>
  </head>
   <body dir="ltr">
      <div class="noscript alert alert-danger text-center" role="alert">
         <a href="data-types-operators-and-expressions.html" class="pull-left"><span class="glyphicon glyphicon-chevron-left" aria-hidden="true"></span>上一页</a> <a href="olap-dml-properties.html" class="pull-right">下一页<span class="glyphicon glyphicon-chevron-right" aria-hidden="true"></span></a> <span class="fa fa-exclamation-triangle" aria-hidden="true"></span>必须启用JavaScript才能正确显示此内容</div>
      <article>
         <header>
            <ol class="breadcrumb" vocab="http://schema.org/" typeof="BreadcrumbList">
               <li property="itemListElement" typeof="ListItem"><a href="index.html" property="item" typeof="WebPage"><span property="name">DML参考</span></a></li>
               <li class="active" property="itemListElement" typeof="ListItem">公式，模型，聚合和分配</li>
            </ol>
            <a id="GUID-D261BFC7-B50F-45BE-92D6-5800E2627C5B" name="GUID-D261BFC7-B50F-45BE-92D6-5800E2627C5B"></a><a id="OLADM226"></a><a id="olapdml_formulas_models_aggs_allocs"></a>
            
            <h2 id="OLADM-GUID-D261BFC7-B50F-45BE-92D6-5800E2627C5B" class="sect2"><span class="enumeration_chapter">3</span>公式，模型，聚合和分配</h2>
         </header>
         <div class="ind">
            <div>
               <p>计算对象是包含OLAP DML语句的OLAP DML对象，这些语句指定要执行的分析。计算对象包括：公式，模型，聚合规范，分配规范和程序。</p>
               <p>本章包含以下信息</p>
               <ul style="list-style-type:disc">
                  <li>
                     <p><a href="formulas-models-aggregations-and-allocations.html#GUID-5483B557-E17F-4DFD-A5BB-FC785EEFCB20">创建计算对象</a></p>
                  </li>
                  <li>
                     <p><a href="formulas-models-aggregations-and-allocations.html#GUID-FB490F75-B8F3-4A1B-8336-9CA08ADEA5BD">OLAP DML公式</a></p>
                  </li>
                  <li>
                     <p><a href="formulas-models-aggregations-and-allocations.html#GUID-6C0C9130-D5DF-4735-8E08-354388F325B5">OLAP DML模型对象</a></p>
                  </li>
                  <li>
                     <p><a href="formulas-models-aggregations-and-allocations.html#GUID-7B279B40-5469-4ED1-AA90-91A9CD3246D2">OLAP DML聚合对象</a></p>
                  </li>
                  <li>
                     <p><a href="formulas-models-aggregations-and-allocations.html#GUID-DF40EC68-A4C4-45A5-821E-49F136FF1323">OLAP DML分配对象</a></p>
                  </li>
               </ul>
               <p>有关创建OLAP DML程序的信息，请参阅<a href="olap-dml-programs.html#GUID-6CC5769C-7292-42CD-BF33-BBECF9456606">OLAP DML程序</a> 。
               </p>
            </div><a id="OLADM227"></a><a id="OLADM1101"></a><a id="olapdml_creating_calculation_objs"></a><div class="props_rev_3"><a id="GUID-5483B557-E17F-4DFD-A5BB-FC785EEFCB20" name="GUID-5483B557-E17F-4DFD-A5BB-FC785EEFCB20"></a><h3 id="OLADM-GUID-5483B557-E17F-4DFD-A5BB-FC785EEFCB20" class="sect3"><span class="enumeration_section">3.1</span>创建计算对象</h3>
               <div>
                  <p>创建计算规范对象的一般过程是以下两个步骤：</p>
                  <ol>
                     <li>
                        <p>使用适当的DEFINE语句定义计算对象。</p>
                     </li>
                     <li>
                        <p>将计算规范添加到对象定义。您可以通过以下方式将计算规范添加到计算对象的定义中：</p>
                        <ul style="list-style-type:disc">
                           <li>
                              <p>在OLAP工作表的命令行级别，输入文件中，或作为PL / SQL函数的参数。在这种情况下，请确保该对象是当前对象（如有必要，发出CONSIDER语句），然后发出包含该规范作为多行文本参数的相应语句。要将规范编码为多行文本，可以使用JOINLINES函数，其中JOINLINES的每个文本参数都是一个指定所需处理的语句，以及最终语句为<code class="codeph">END</code> 。</p>
                           </li>
                           <li>
                              <p>在OLAP工作表的编辑窗口中。在这种情况下，在OLAP工作表的命令行级别，发出带有相应关键字的EDIT语句。EDIT语句打开指定对象的编辑窗口。然后，您可以在“编辑窗口”中将每个语句键入单独的行。完成后保存规范并关闭编辑窗口。</p>
                           </li>
                        </ul>
                     </li>
                  </ol>
                  <p>下表概述了用于创建每种类型的计算规范的OLAP DML语句。</p>
                  <div class="tblformal" id="GUID-5483B557-E17F-4DFD-A5BB-FC785EEFCB20__CIHCJECB">
                     <p class="titleintable">表3-1定义计算对象的命令</p>
                     <table cellpadding="4" cellspacing="0" class="Formal" title="用于定义计算对象的命令" width="100%" border="1" summary="This table provides overview informationa bout the OLAP DML statements that you use to create calculation specifications. For each specification type, it identifies the DEFINE statement for that type, the OLAP DML command you can use to code the specification, and the statement that you can use in the OLAP Worksheet to open an Edit Window to code the specification." frame="hsides" rules="rows">
                        <thead>
                           <tr align="left" valign="top">
                              <th align="left" valign="bottom" width="17%" id="d30610e120">计算</th>
                              <th align="left" valign="bottom" width="24%" id="d30610e123">定义声明</th>
                              <th align="left" valign="bottom" width="28%" id="d30610e126">规范声明</th>
                              <th align="left" valign="bottom" width="30%" id="d30610e129">欲获得更多信息</th>
                           </tr>
                        </thead>
                        <tbody>
                           <tr align="left" valign="top">
                              <td align="left" valign="top" width="17%" id="d30610e134" headers="d30610e120 ">
                                 <p>式</p>
                              </td>
                              <td align="left" valign="top" width="24%" headers="d30610e134 d30610e123 ">
                                 <p>DEFINE FORMULA</p>
                              </td>
                              <td align="left" valign="top" width="28%" headers="d30610e134 d30610e126 ">
                                 <p>EQ</p>
                              </td>
                              <td align="left" valign="top" width="30%" headers="d30610e134 d30610e129 ">
                                 <p><span class="q">“ <a href="formulas-models-aggregations-and-allocations.html#GUID-FB490F75-B8F3-4A1B-8336-9CA08ADEA5BD">OLAP DML公式</a> ”</span></p>
                              </td>
                           </tr>
                           <tr align="left" valign="top">
                              <td align="left" valign="top" width="17%" id="d30610e149" headers="d30610e120 ">
                                 <p>模型</p>
                              </td>
                              <td align="left" valign="top" width="24%" headers="d30610e149 d30610e123 ">
                                 <p>定义模型</p>
                              </td>
                              <td align="left" valign="top" width="28%" headers="d30610e149 d30610e126 ">
                                 <p>模型</p>
                              </td>
                              <td align="left" valign="top" width="30%" headers="d30610e149 d30610e129 ">
                                 <p><span class="q">“ <a href="formulas-models-aggregations-and-allocations.html#GUID-6C0C9130-D5DF-4735-8E08-354388F325B5">OLAP DML模型对象</a> ”</span></p>
                              </td>
                           </tr>
                           <tr align="left" valign="top">
                              <td align="left" valign="top" width="17%" id="d30610e164" headers="d30610e120 ">
                                 <p>聚合</p>
                              </td>
                              <td align="left" valign="top" width="24%" headers="d30610e164 d30610e123 ">
                                 <p>DEFINE AGGMAP</p>
                              </td>
                              <td align="left" valign="top" width="28%" headers="d30610e164 d30610e126 ">
                                 <p>AGGMAP</p>
                              </td>
                              <td align="left" valign="top" width="30%" headers="d30610e164 d30610e129 ">
                                 <p><span class="q">“ <a href="formulas-models-aggregations-and-allocations.html#GUID-7B279B40-5469-4ED1-AA90-91A9CD3246D2">OLAP DML聚合对象</a> ”</span></p>
                              </td>
                           </tr>
                           <tr align="left" valign="top">
                              <td align="left" valign="top" width="17%" id="d30610e179" headers="d30610e120 ">
                                 <p>分配</p>
                              </td>
                              <td align="left" valign="top" width="24%" headers="d30610e179 d30610e123 ">
                                 <p>DEFINE AGGMAP</p>
                              </td>
                              <td align="left" valign="top" width="28%" headers="d30610e179 d30610e126 ">
                                 <p>ALLOCMAP</p>
                              </td>
                              <td align="left" valign="top" width="30%" headers="d30610e179 d30610e129 ">
                                 <p><span class="q">“ <a href="formulas-models-aggregations-and-allocations.html#GUID-DF40EC68-A4C4-45A5-821E-49F136FF1323">OLAP DML分配对象</a> ”</span></p>
                              </td>
                           </tr>
                           <tr align="left" valign="top">
                              <td align="left" valign="top" width="17%" id="d30610e194" headers="d30610e120 ">
                                 <p>程序</p>
                              </td>
                              <td align="left" valign="top" width="24%" headers="d30610e194 d30610e123 ">
                                 <p>定义计划</p>
                              </td>
                              <td align="left" valign="top" width="28%" headers="d30610e194 d30610e126 ">
                                 <p>程序</p>
                              </td>
                              <td align="left" valign="top" width="30%" headers="d30610e194 d30610e129 ">
                                 <p><a href="olap-dml-programs.html#GUID-6CC5769C-7292-42CD-BF33-BBECF9456606">OLAP DML程序</a></p>
                              </td>
                           </tr>
                        </tbody>
                     </table>
                  </div>
                  <!-- class="inftblhruleinformal" -->
               </div>
            </div><a id="OLADM228"></a><div class="props_rev_3"><a id="GUID-FB490F75-B8F3-4A1B-8336-9CA08ADEA5BD" name="GUID-FB490F75-B8F3-4A1B-8336-9CA08ADEA5BD"></a><h3 id="OLADM-GUID-FB490F75-B8F3-4A1B-8336-9CA08ADEA5BD" class="sect3"><span class="enumeration_section">3.2</span> OLAP DML公式</h3>
               <div>
                  <p>您可以在公式中保存表达式。通常，您可以定义易于使用的公式并节省存储空间。为表达式定义公式后，可以使用公式名称来表示表达式。Oracle OLAP不会将公式的数据存储在变量中;相反，它在每次请求数据时计算运行时的数据。</p>
                  <p>在创建公式之前，请确定在首次定义公式对象时是否要指定表达式，或者在定义公式对象后是否要指定公式的表达式：</p>
                  <ul style="list-style-type:disc">
                     <li>
                        <p>要在第一次定义公式对象时指定表达式：</p>
                        <ol>
                           <li>
                              <p>发出DEFINE FORMULA语句来定义公式对象。在定义中包含表达式。不要指定<code class="codeph">datatype</code>或<code class="codeph">dimensions</code>参数的值。
                              </p>
                           </li>
                           <li>
                              <p>（可选）发出COMPILE语句以编译公式。</p>
                           </li>
                           <li>
                              <p>如果希望公式成为分析工作区的永久部分，请使用UPDATE语句后跟COMMIT保存公式。</p>
                           </li>
                        </ol>
                     </li>
                     <li>
                        <p>在定义公式对象后指定公式的表达式：</p>
                        <ol>
                           <li>
                              <p>发出DEFINE FORMULA语句来定义公式对象。指定<code class="codeph">datatype</code>或<code class="codeph">dimensions</code>参数的值，但不指定表达式本身的值。
                              </p>
                           </li>
                           <li>
                              <p>发出CONSIDER语句以使公式成为当前定义，然后发出EQ语句以指定公式的表达式。</p>
                           </li>
                           <li>
                              <p>（可选）发出COMPILE语句以编译公式。</p>
                           </li>
                           <li>
                              <p>如果希望公式成为分析工作区的永久部分，请使用UPDATE语句后跟COMMIT保存公式。</p>
                           </li>
                        </ol>
                     </li>
                  </ul>
                  <p>例如，您可以定义计算美元销售额的公式，如下所示。</p><pre class="oac_no_warn" dir="ltr">DEFINE dollar.sales FORMULA单位*价格</pre><p>您可以使用<a href="olap-dml-commands-h-z.html#GUID-4DDB2468-396B-4540-A706-9A9B6BC3075F">TRACE</a>来帮助您调试论坛。
                  </p>
               </div>
            </div><a id="OLADM229"></a><a id="olapdml_model_objects"></a><div class="props_rev_3"><a id="GUID-6C0C9130-D5DF-4735-8E08-354388F325B5" name="GUID-6C0C9130-D5DF-4735-8E08-354388F325B5"></a><h3 id="OLADM-GUID-6C0C9130-D5DF-4735-8E08-354388F325B5" class="sect3"><span class="enumeration_section">3.3</span> OLAP DML模型对象</h3>
               <div>
                  <p>本主题提供有关创建和执行OLAP DML模型的信息。它包括以下子主题：</p>
                  <ul style="list-style-type:disc">
                     <li>
                        <p><a href="formulas-models-aggregations-and-allocations.html#GUID-C9F6356C-AC27-4FE3-9E8C-67A8A20D0013">什么是OLAP DML模型？</a></p>
                     </li>
                     <li>
                        <p><a href="formulas-models-aggregations-and-allocations.html#GUID-B00C966D-89EA-4EEB-8F83-3BE1C94F2357">创建模型</a></p>
                     </li>
                     <li>
                        <p><a href="formulas-models-aggregations-and-allocations.html#GUID-D45E995C-84D7-4B75-900F-D9A54DD087E7">编译模型</a></p>
                     </li>
                     <li>
                        <p><a href="formulas-models-aggregations-and-allocations.html#GUID-F20C02E1-E771-4DA9-AFD1-B6FB2BFB6E18">运行模型</a></p>
                     </li>
                     <li>
                        <p><a href="formulas-models-aggregations-and-allocations.html#GUID-C40C6E37-B5F7-488A-BF1B-8D87CDBB5EF4">调试模型</a></p>
                     </li>
                  </ul>
               </div><a id="OLADM230"></a><div class="props_rev_3"><a id="GUID-C9F6356C-AC27-4FE3-9E8C-67A8A20D0013" name="GUID-C9F6356C-AC27-4FE3-9E8C-67A8A20D0013"></a><h4 id="OLADM-GUID-C9F6356C-AC27-4FE3-9E8C-67A8A20D0013" class="sect4"><span class="enumeration_section">3.3.1</span>什么是OLAP DML模型？
                  </h4>
                  <div>
                     <p>OLAP DML <span class="bold">模型</span>是一组相互关联的方程式，可以将结果分配给变量或维度值。例如，在财务模型中，您可以为特定行项目分配值，例如<code class="codeph">gross.margin</code>或<code class="codeph">net.income</code> 。
                     </p><pre class="oac_no_warn" dir="ltr">gross.margin =收入 - 齿轮</pre><pre class="oac_no_warn" dir="ltr"></pre><p><a id="d30610e386" class="indexterm-anchor"></a><a id="d30610e388" class="indexterm-anchor"></a>当赋值语句将数据分配给维值或在其计算中引用维值时，它将被称为基于维度的方程。基于维度的等式不是指维度本身，而是仅指维度的值。因此，当模型包含任何基于维度的方程时，您必须在模型开头的<code class="codeph">DIMENSION</code>语句中指定每个维度的名称。
                     </p>
                     <p><a id="d30610e395" class="indexterm-anchor"></a><a id="d30610e399" class="indexterm-anchor"></a>当模型包含任何基于维度的方程式时，您必须在运行模型时提供<span class="bold">解决方案变量</span>的名称。解决方案变量既是数据源，也是模型方程的赋值目标。它保存基于维度的方程中使用的输入数据，并将计算结果存储在解决方案变量的指定值中。例如，当您基于<code class="codeph">line</code>维度运行财务模型时，您可以将<code class="codeph">actual</code>指定为解决方案变量。
                     </p>
                     <p>基于维度的方程式为财务建模提供了灵活性。因为在解决模型之前不需要指定建模变量，所以可以使用<code class="codeph">actual</code>变量， <code class="codeph">budget</code>变量或按<code class="codeph">line</code>标注的任何其他变量运行相同的模型。
                     </p>
                     <p>模型可能非常复杂。您可以：</p>
                     <ul style="list-style-type:disc">
                        <li>
                           <p>如<span class="q">“ <a href="formulas-models-aggregations-and-allocations.html#GUID-0F30A8D2-3777-4E82-885C-F5960142B2C6">嵌套模型</a> ”中</span>所述，在另一个模型中包含一个模型 
                           </p>
                        </li>
                        <li>
                           <p>使用<span class="q">“ <a href="formulas-models-aggregations-and-allocations.html#GUID-1C202CC3-C149-4A0B-8113-FBFF67A75C11">使用过去和未来时间</a></span>段的<span class="q"><a href="formulas-models-aggregations-and-allocations.html#GUID-1C202CC3-C149-4A0B-8113-FBFF67A75C11">数据</a> ”中</span>讨论的不同时间段的<span class="q"><a href="formulas-models-aggregations-and-allocations.html#GUID-1C202CC3-C149-4A0B-8113-FBFF67A75C11">数据</a></span></p>
                        </li>
                        <li>
                           <p>解决<span class="q">“ <a href="formulas-models-aggregations-and-allocations.html#GUID-475CF519-BB27-4BE8-BE84-F3D6571B969E">求解联立方程</a> ”中</span>讨论的<span class="q"><a href="formulas-models-aggregations-and-allocations.html#GUID-475CF519-BB27-4BE8-BE84-F3D6571B969E">联立方程</a></span></p>
                        </li>
                        <li>
                           <p>为<span class="q">“ <a href="formulas-models-aggregations-and-allocations.html#GUID-FDAE78C0-C834-4864-A1E5-E3A15299ADB2">为多个场景建模</a> ”中</span>所述为不同场景创建模型</p>
                        </li>
                     </ul>
                  </div>
               </div><a id="OLADM231"></a><div class="props_rev_3"><a id="GUID-B00C966D-89EA-4EEB-8F83-3BE1C94F2357" name="GUID-B00C966D-89EA-4EEB-8F83-3BE1C94F2357"></a><h4 id="OLADM-GUID-B00C966D-89EA-4EEB-8F83-3BE1C94F2357" class="sect4"><span class="enumeration_section">3.3.2</span>创建模型</h4>
                  <div>
                     <div class="section">
                        <p>要创建OLAP DML模型，请执行以下步骤：</p>
                     </div>
                     <!-- class="section" -->
                     <ol>
                        <li><span>发出<a href="olap-dml-commands-a-g.html#GUID-0C5B0D41-96CD-499B-AAF7-C6A7C8A2262D">DEFINE MODEL</a>命令来定义程序对象。</span></li>
                        <li><span>发出<a href="olap-dml-commands-h-z.html#GUID-C8ABFE88-27EF-435E-88F3-1BC2410F0D92">MODEL</a>命令，为<a href="olap-dml-commands-h-z.html#GUID-C8ABFE88-27EF-435E-88F3-1BC2410F0D92">模型</a>添加规范以指定要执行的处理。</span></li>
                        <li><span>按照<span class="q">“ <a href="formulas-models-aggregations-and-allocations.html#GUID-D45E995C-84D7-4B75-900F-D9A54DD087E7">编译模型</a> ”中的</span>描述<span class="q"><a href="formulas-models-aggregations-and-allocations.html#GUID-D45E995C-84D7-4B75-900F-D9A54DD087E7">编译模型</a></span> 。</span></li>
                        <li><span>（可选）如有必要，请更改<span class="q">“ <a href="olap-dml-options.html#GUID-8A17CF72-1597-4279-9E16-5A1E2C23725C__CHDEDGJG">型号选项</a> ”中</span>列出的<span class="q"><a href="olap-dml-options.html#GUID-8A17CF72-1597-4279-9E16-5A1E2C23725C__CHDEDGJG">型号选项</a></span>的设置。</span></li>
                        <li><span>按照<span class="q">“ <a href="formulas-models-aggregations-and-allocations.html#GUID-F20C02E1-E771-4DA9-AFD1-B6FB2BFB6E18">运行模型</a> ”中的</span>描述执行模型。</span></li>
                        <li><span>按照<span class="q">“ <a href="formulas-models-aggregations-and-allocations.html#GUID-C40C6E37-B5F7-488A-BF1B-8D87CDBB5EF4">调试模型</a> ”中的</span>描述<span class="q"><a href="formulas-models-aggregations-and-allocations.html#GUID-C40C6E37-B5F7-488A-BF1B-8D87CDBB5EF4">调试模型</a></span> 。</span></li>
                        <li><span>如果希望模型成为分析工作区的永久部分，请使用UPDATE命令然后执行COMMIT来保存模型。</span></li>
                     </ol>
                     <div class="section">
                        <p>有关创建模型的示例，请参见<a href="olap-dml-commands-h-z.html#GUID-C8ABFE88-27EF-435E-88F3-1BC2410F0D92__CHDBGACB">示例10-57</a> 。
                        </p>
                     </div>
                     <!-- class="section" -->
                  </div><a id="OLADM232"></a><div class="props_rev_3"><a id="GUID-0F30A8D2-3777-4E82-885C-F5960142B2C6" name="GUID-0F30A8D2-3777-4E82-885C-F5960142B2C6"></a><h5 id="OLADM-GUID-0F30A8D2-3777-4E82-885C-F5960142B2C6" class="sect5"><span class="enumeration_section">3.3.2.1</span>嵌套模型</h5>
                     <div>
                        <p>通过在<a href="olap-dml-commands-h-z.html#GUID-C8ABFE88-27EF-435E-88F3-1BC2410F0D92">MODEL</a>命令中使用<a href="olap-dml-commands-h-z.html#GUID-49E3CA55-BAF9-4CCA-BFA5-6D7F65A748AB">INCLUDE</a>语句，可以在另一个模型中<a href="olap-dml-commands-h-z.html#GUID-49E3CA55-BAF9-4CCA-BFA5-6D7F65A748AB">包含</a>一个<a href="olap-dml-commands-h-z.html#GUID-C8ABFE88-27EF-435E-88F3-1BC2410F0D92">模型</a> 。包含INCLUDE语句的MODEL命令称为<span class="bold">父模型</span> 。包含的模型称为<span class="bold">基本模型</span> 。您可以通过在基本模型中放置INCLUDE语句来嵌套模型。例如，模型<code class="codeph">myModel1</code>可以包含模型<code class="codeph">myModel2</code> ，模型<code class="codeph">myModel2</code>可以包含模型<code class="codeph">myModel3</code> 。嵌套模型形成层次结构。在此示例中， <code class="codeph">myModel1</code>位于层次结构的顶部， <code class="codeph">myModel3</code>位于根节点。
                        </p>
                        <p>当模型包含INCLUDE语句时，它不能包含任何DIMENSION语句。父模型从包含层次结构的根模型中的DIMENSION语句继承其维度（如果有）。在刚刚给出的示例中，模型<code class="codeph">myModel1</code>和<code class="codeph">myModel2</code>都从模型<code class="codeph">myModel3</code>的DIMENSION语句继承它们的维度。
                        </p>
                        <p>INCLUDE语句使您可以创建模块化模型。当某些方程对于多个模型是通用的时，您可以将这些方程放在单独的模型中，并根据需要将该模型包含在其他模型中。</p>
                        <p>INCLUDE语句还有助于假设分析。实验模型可以从基础模型中绘制方程，并选择性地用新方程替换它们。为了支持假设分析，您可以使用模型中的方程来掩盖先前的方程式。之前的等式可以来自相同的模型或来自包含的模型。模型的<a href="olap-dml-commands-h-z.html#GUID-161883C7-BD6D-428E-A124-2A9EEE272790">MODEL.COMPRPT</a>报告中不执行或显示屏蔽等式。
                        </p>
                     </div>
                  </div><a id="OLADM233"></a><div class="props_rev_3"><a id="GUID-AF2ACACA-69C2-4AD7-885C-8BABA04F9475" name="GUID-AF2ACACA-69C2-4AD7-885C-8BABA04F9475"></a><h5 id="OLADM-GUID-AF2ACACA-69C2-4AD7-885C-8BABA04F9475" class="sect5"><span class="enumeration_section">3.3.2.2</span>尺寸状态和模型方程</h5>
                     <div>
                        <p>当模型包含用于将数据分配给维值的赋值语句时，维度将临时限制为该值，执行计算并恢复维度的初始状态。</p>
                        <p>例如，模型可能具有以下语句。</p><pre class="oac_no_warn" dir="ltr">DIMENSION line gross.margin = revenue  -  cogs</pre><pre class="oac_no_warn" dir="ltr"></pre><p>如果在运行模型时将<code class="codeph">actual</code>指定为解决方案变量，则构造并执行以下代码。
                        </p><pre class="oac_no_warn" dir="ltr">PUSH线LIMIT线TO毛额。实际=实际（线路收入） - 实际（线齿轮）POP线</pre><pre class="oac_no_warn" dir="ltr"></pre><p>在模型中使用解决方案变量的事实导致这种幕后代码构造允许您使用简单的模型方程执行复杂的计算。例如，行项目数据可能存储在<code class="codeph">actual</code>变量中，该变量按<code class="codeph">line</code> 。但是，详细的行项目数据可能存储在名为<code class="codeph">detail.data</code>的变量中，其名称为<code class="codeph">detail.line</code> 。
                        </p>
                        <p>当分析工作空间包含<code class="codeph">line</code>和<code class="codeph">detail.line</code>之间的关系时，它指定了每个详细信息项所属的行项目，那么您可以编写模型方程式，例如以下方法。
                        </p><pre class="oac_no_warn" dir="ltr">收入=总计（detail.data行）费用=总计（detail.data行）</pre><p><code class="codeph">detail.line</code>和<code class="codeph">line</code>之间的关系自动用于将详细数据聚合到相应的行项目中。运行模型时构造的代码可确保为<code class="codeph">line</code>维的每个值分配适当的总数。例如，在计算<code class="codeph">revenue</code>项目的等式时， <code class="codeph">line</code>暂时仅限于<code class="codeph">revenue</code> ，而<code class="codeph">TOTAL</code>函数返回<code class="codeph">line</code>的<code class="codeph">revenue</code>值的详细项目总数。
                        </p>
                     </div>
                  </div><a id="OLADM234"></a><div class="props_rev_3"><a id="GUID-1C202CC3-C149-4A0B-8113-FBFF67A75C11" name="GUID-1C202CC3-C149-4A0B-8113-FBFF67A75C11"></a><h5 id="OLADM-GUID-1C202CC3-C149-4A0B-8113-FBFF67A75C11" class="sect5"><span class="enumeration_section">3.3.2.3</span>使用过去和未来时间段的数据</h5>
                     <div>
                        <p><a id="d30610e738" class="indexterm-anchor"></a><a id="d30610e740" class="indexterm-anchor"></a>多个OLAP DML功能使您可以轻松使用过去或未来时间段的数据。例如， <code class="codeph">LAG</code>函数返回指定的前一时间段的数据， <code class="codeph">LEAD</code>函数返回指定的未来时间段的数据。
                        </p>
                        <p>运行在计算中使用过去或未来数据的模型时，必须确保解决方案变量包含必要的过去或未来数据。例如，模型可能包含基地的估计值赋值语句<code class="codeph">revenue</code>就行项目当月<code class="codeph">revenue</code>前一个月行项目。
                        </p><pre class="oac_no_warn" dir="ltr">DIMENSION行月...收入= LAG（收入，1，月）* 1.05</pre><pre class="oac_no_warn" dir="ltr"></pre><p>当<code class="codeph">month</code>维度限制在<code class="codeph">Apr2004</code> <code class="codeph">month</code>到<code class="codeph">Apr2004</code>年<code class="codeph">Jun2004</code> <code class="codeph">month</code>运行模型时，您必须确保解决方案变量包含<code class="codeph">Mar96</code> <code class="codeph">revenue</code>数据。
                        </p>
                        <p>当模型包含<code class="codeph">LEAD</code>函数时，解决方案变量必须包含必要的未来数据。例如，当您想要计算2004年4月到6月的数据时，以及模型将来从一个月检索数据时，解决方案变量必须包含运行模型时2004年7月的数据。
                        </p>
                     </div>
                  </div><a id="OLADM235"></a><div class="props_rev_3"><a id="GUID-A5F3C3EB-53BD-46F7-B0F9-305D8CB12794" name="GUID-A5F3C3EB-53BD-46F7-B0F9-305D8CB12794"></a><h5 id="OLADM-GUID-A5F3C3EB-53BD-46F7-B0F9-305D8CB12794" class="sect5"><span class="enumeration_section">3.3.2.4</span>处理模型中的NA值</h5>
                     <div>
                        <p>Oracle OLAP在评估模型中的方程时会观察NASKIP2选项。NASKIP2控制在执行<code class="codeph">+</code> （加号）和<code class="codeph">-</code> （减号）操作时如何处理<code class="codeph">NA</code>值。当解决方案变量包含<code class="codeph">NA</code>值时，NASKIP2的设置很重要。
                        </p>
                        <p>计算的结果可以是<code class="codeph">NA</code>不仅当溶液变量包含<code class="codeph">NA</code>被用作输入值，而且当的联立方程的目标是<code class="codeph">NA</code> 。求解变量中的值用作同时块上第一次迭代中目标的初始值。因此，当溶液变量包含<code class="codeph">NA</code>作为一个目标的初始值， <code class="codeph">NA</code>结果可以在第一次迭代产生的，并且<code class="codeph">NA</code>结果可以通过随后的迭代中会延续下去。
                        </p>
                        <p>要避免为结果获取<code class="codeph">NA</code> ，可以确保解决方案变量不包含<code class="codeph">NA</code>值，或者可以在运行模型之前将NASKIP2设置为<code class="codeph">YES</code> 。
                        </p>
                     </div>
                  </div><a id="OLADM236"></a><div class="props_rev_3"><a id="GUID-475CF519-BB27-4BE8-BE84-F3D6571B969E" name="GUID-475CF519-BB27-4BE8-BE84-F3D6571B969E"></a><h5 id="OLADM-GUID-475CF519-BB27-4BE8-BE84-F3D6571B969E" class="sect5"><span class="enumeration_section">3.3.2.5</span>求解联立方程</h5>
                     <div>
                        <p><a id="d30610e885" class="indexterm-anchor"></a>迭代方法用于求解同时块中的方程。在每次迭代中，计算每个等式的值。将新值与上一次迭代的值进行比较。当比较落在指定的容差范围内时，则认为该等式已收敛到解。当比较超过指定限制时，则认为该等式已经发散。
                        </p>
                        <p>当块中的所有方程收敛时，则认为该块已解决。当任何方程在指定的迭代次数内发散或未能收敛时，则块（和模型）的解决方案失败并发生错误。</p>
                        <p>您可以使用<span class="q">“ <a href="olap-dml-options.html#GUID-8A17CF72-1597-4279-9E16-5A1E2C23725C__CHDEDGJG">模型选项</a> ”中</span>描述的OLAP DML选项控制联立方程的解。例如，使用这些选项，您可以指定要使用的解决方法方法，用于测试收敛和发散的因子，要执行的最大迭代次数以及赋值语句发散或收敛时要采取的操作。
                        </p>
                     </div>
                  </div><a id="OLADM237"></a><div class="props_rev_3"><a id="GUID-FDAE78C0-C834-4864-A1E5-E3A15299ADB2" name="GUID-FDAE78C0-C834-4864-A1E5-E3A15299ADB2"></a><h5 id="OLADM-GUID-FDAE78C0-C834-4864-A1E5-E3A15299ADB2" class="sect5"><span class="enumeration_section">3.3.2.6</span>多场景建模</h5>
                     <div>
                        <p><a id="d30610e926" class="indexterm-anchor"></a><a id="d30610e930" class="indexterm-anchor"></a><a id="d30610e932" class="indexterm-anchor"></a>您可能想要计算几组数字，而不是计算一个月和一个部门的单个数字，每个数字都基于不同的假设。
                        </p>
                        <p>您可以定义一个<span class="bold">场景</span>模型，根据不同的输入数据集计算和存储预测或预算数据。例如，您可能希望根据乐观，悲观和最佳猜测数据计算利润。
                        </p>
                        <p>要构建场景模型：</p>
                        <ol>
                           <li>
                              <p>定义方案维度。</p>
                           </li>
                           <li>
                              <p>定义由场景维度标注的解决方案变量。</p>
                           </li>
                           <li>
                              <p>将输入数据输入解决方案变量。</p>
                           </li>
                           <li>
                              <p>编写模型以根据输入数据计算结果。</p>
                           </li>
                        </ol>
                        <p>有关构建场景模型的示例，请参见<a href="olap-dml-commands-h-z.html#GUID-C8ABFE88-27EF-435E-88F3-1BC2410F0D92__CHDGFCII">示例10-58</a> 。
                        </p>
                     </div>
                  </div>
               </div><a id="OLADM238"></a><div class="props_rev_3"><a id="GUID-D45E995C-84D7-4B75-900F-D9A54DD087E7" name="GUID-D45E995C-84D7-4B75-900F-D9A54DD087E7"></a><h4 id="OLADM-GUID-D45E995C-84D7-4B75-900F-D9A54DD087E7" class="sect4"><span class="enumeration_section">3.3.3</span>编译模型</h4>
                  <div>
                     <p><a id="d30610e989" class="indexterm-anchor"></a><a id="d30610e993" class="indexterm-anchor"></a>在模型中完成语句编写后，可以使用<a href="olap-dml-commands-a-g.html#GUID-932941E8-A664-4E93-BFE5-4E60AFC02D19">COMPILE</a>命令编译模型。在编译期间，COMPILE会检查格式错误，因此您可以在运行模型之前使用COMPILE来帮助调试代码。如果在运行模型之前未使用COMPILE，则在解决模型之前会自动编译模型。您可以使用带有ISCOMPILED选项的OBJ功能来测试是否编译了模型。
                     </p><pre class="oac_no_warn" dir="ltr">SHOW OBJ（ISCOMPILED'myModel'）</pre><p>通过使用COMPILE语句或运行模型编译模型时，模型编译器会检查模型特有的问题。发生以下任何一种情况时收到错误消息：</p>
                     <ul style="list-style-type:disc">
                        <li>
                           <p>该模型包含除DIMENSION，INCLUDE和赋值（SET）语句之外的任何语句。</p>
                        </li>
                        <li>
                           <p>该模型包含DIMENSION语句和INCLUDE语句。</p>
                        </li>
                        <li>
                           <p>DIMENSION或INCLUDE语句放在模型中的第一个方程之后。</p>
                        </li>
                        <li>
                           <p>基于单个维度的等式中的维度值指的是两个或更多个不同的维度。</p>
                        </li>
                        <li>
                           <p>等式是指编译器无法将任何附加分析工作空间中的对象标识为的名称。发生此错误时，可能是因为方程式引用了维度的值，但您忽略了将维度包含在DIMENSION语句中。此外，当您编译包含另一个模型的模型而另一个模型无法编译时，可能会缺少DIMENSION语句。当根模型（包含模型的层次结构中的最内层模型）无法编译时，父模型不能从根模型继承任何DIMENSION命令。在这种情况下，当错误源实际位于根模型中时，编译器可能会报告父模型中的错误。有关其他信息，请参阅<a href="olap-dml-commands-h-z.html#GUID-49E3CA55-BAF9-4CCA-BFA5-6D7F65A748AB">INCLUDE</a> 。
                           </p>
                        </li>
                     </ul>
                  </div><a id="OLADM239"></a><div class="props_rev_3"><a id="GUID-3ECB52BD-0B0E-4F13-BD2A-68B7F5D8BA05" name="GUID-3ECB52BD-0B0E-4F13-BD2A-68B7F5D8BA05"></a><h5 id="OLADM-GUID-3ECB52BD-0B0E-4F13-BD2A-68B7F5D8BA05" class="sect5"><span class="enumeration_section">3.3.3.1</span>解析方程中的名称</h5>
                     <div>
                        <p>模型编译器检查等式中的每个名称以确定名称所引用的分析工作空间对象。因为您可以在模型方程中以相同的方式使用变量和维值（基于它进行计算或将结果分配给它），名称可能是变量的名称，也可能是列出的任何维度的值。 DIMENSION语句。</p>
                        <p>要解析每个名称引用，编译器将按照列出的顺序搜索显式或继承的DIMENSION语句中列出的维度，以确定名称是否与列出的维度的维度值匹配。一旦找到匹配，搜索就会结束。</p>
                        <p>因此，当两个或多个列出的维具有具有相同名称的维值时，编译器会假定该值属于DIMENSION语句中名为earliest的维。</p>
                        <p>同样，模型编译器可能会误解文字<code class="codeph">INTEGER</code>值所属的维度。例如，模型编译器假定文字值<code class="codeph">'200'</code>属于第一个维度，该维度包含位置200处的值或文字维度值200。
                        </p>
                        <p>为避免识别错误，您可以指定所需的尺寸，并将值括在括号和单引号中。请参见<span class="q">“ <a href="olap-dml-commands-h-z.html#GUID-F6BA1626-650A-46D0-9C01-B2757981AA27">SET</a> ”</span> 。
                        </p>
                        <p>当编译器发现名称不是DIMENSION语句中指定的任何维度的值时，它会假定该名称是分析工作区变量的名称。如果未在任何连接的分析工作区中定义具有该名称的变量，则会发生错误。</p>
                     </div>
                  </div><a id="OLADM240"></a><div class="props_rev_3"><a id="GUID-BC697ED2-8D0A-4166-9942-CDC71F390CAD" name="GUID-BC697ED2-8D0A-4166-9942-CDC71F390CAD"></a><h5 id="OLADM-GUID-BC697ED2-8D0A-4166-9942-CDC71F390CAD" class="sect5"><span class="enumeration_section">3.3.3.2</span>循环尺寸代码</h5>
                     <div>
                        <p>模型编译器确定语句循环的维度。当等式将结果分配给变量时，编译器构造循环变量的维度（或复合的基础）的代码。</p>
                        <p>运行包含基于维度的方程的模型时，您指定的解决方案变量的维度可以比DIMENSION语句中列出的维度多。</p>
                     </div>
                  </div><a id="OLADM241"></a><div class="props_rev_3"><a id="GUID-BD58A003-20D4-46BA-B315-E22AE7B50AD0" name="GUID-BD58A003-20D4-46BA-B315-E22AE7B50AD0"></a><h5 id="OLADM-GUID-BD58A003-20D4-46BA-B315-E22AE7B50AD0" class="sect5"><span class="enumeration_section">3.3.3.3</span>评估程序参数</h5>
                     <div>
                        <p>当您将模型维度的值指定为用户定义程序的参数时，编译器会识别此参数引入的依赖关系。</p>
                        <p>例如，等式可能使用名为<code class="codeph">weight</code>的程序来测试某些条件，然后根据这些条件对权重进行加权并返回<code class="codeph">Taxes</code>行项目。在此示例中，模型方程可能如下所示。
                        </p><pre class="oac_no_warn" dir="ltr">Net.Income = Opr。收入 - 重量（税）</pre><pre class="oac_no_warn" dir="ltr"></pre><p>编译器正确识别<code class="codeph">Net.Income</code>依赖于<code class="codeph">Opr.Income</code>和<code class="codeph">Taxes</code> 。但是，当权<code class="codeph">weight</code>程序引用未指定为程序参数的任何维值或变量时，编译器不会检测这些计算引入的任何隐藏依赖项。
                        </p>
                     </div>
                  </div><a id="OLADM1102"></a><a id="OLADM1103"></a><a id="OLADM1104"></a><a id="OLADM242"></a><div class="props_rev_3"><a id="GUID-EBC35120-9674-4BF4-BF2B-64A513147CA1" name="GUID-EBC35120-9674-4BF4-BF2B-64A513147CA1"></a><h5 id="OLADM-GUID-EBC35120-9674-4BF4-BF2B-64A513147CA1" class="sect5"><span class="enumeration_section">3.3.3.4</span>方程之间的相关性</h5>
                     <div>
                        <p>模型编译器分析模型中方程之间的依赖关系。当一个等式中等号右边的表达式指的是另一个等式的赋值目标时，存在依赖性。当方程间接依赖于自身作为方程之间的依赖性的结果时，方程之间存在循环依赖性。</p>
                        <p>模型编译器将模型构造成块并对块内的方程和块本身进行排序以反映依赖性。运行模型时，一次解决一个块。模型编译器可以生成三种类型的解决方案块：</p>
                        <ul style="list-style-type:disc">
                           <li>
                              <p><span class="bold">简单解决方案块 -</span>简单块包括彼此独立的方程式以及彼此依赖的非循环方程式。
                              </p>
                              <p>例如，当块包含求解值<code class="codeph">A</code> ， <code class="codeph">B</code>和<code class="codeph">C</code>等式时，非循环依赖性可以被示为<code class="codeph">A&gt;B&gt;C</code>箭头表示<code class="codeph">A</code>取决于<code class="codeph">B</code> ， <code class="codeph">B</code>取决于<code class="codeph">C</code></p>
                           </li>
                           <li>
                              <p><span class="bold">步骤解决方案块</span> - 步骤块包括具有循环依赖性的方程，该循环依赖性是单向维度依赖性。当当前维度值的数据取决于来自先前或后期维度值的数据时，发生维度依赖性。当数据仅取决于先前的值或仅取决于以后的值时，尺寸依赖性是单向的，但不是两者。有关单向尺寸依赖性的更多信息，请参阅<span class="q">“ <a href="formulas-models-aggregations-and-allocations.html#GUID-EBC35120-9674-4BF4-BF2B-64A513147CA1__CACGJAAJ">确保单向尺寸依赖性</a> ”</span> 。
                              </p>
                              <p>维度依赖通常发生在时间维度上。例如，行项目值通常取决于同一行项目的值或前一时间段中的不同行项目。当一个块包含求解方程的值<code class="codeph">A</code>和<code class="codeph">B</code> ，一<span class="italic">-</span>方式维相关性可以表示为<code class="codeph">A&gt;B&gt;LAG(A)</code>箭头表示<code class="codeph">A</code>取决于<code class="codeph">B</code> ， <code class="codeph">B</code>取决于前一时间段的<code class="codeph">A</code>值。
                              </p>
                           </li>
                           <li>
                              <p><span class="bold">同时解决方案块 - 同时</span>块包括具有不同于单向维度的循环依赖性的方程。循环依赖可以根本不涉及维度限定符，或者它可以是<span class="italic">双向维度</span>依赖性。有关双向尺寸依赖性的更多信息，请参阅<span class="q">“ <a href="formulas-models-aggregations-and-allocations.html#GUID-EBC35120-9674-4BF4-BF2B-64A513147CA1__BABDHHCC">模型编译器假设双向尺寸依赖性的结构</a> ”</span> 。
                              </p>
                              <p>当模型包含一组联立方程时，COMPILE会给出一条警告信息。在这种情况下，您可能需要在运行模型之前检查控制同步解决方案的选项的设置。 <span class="q">“ <a href="olap-dml-options.html#GUID-8A17CF72-1597-4279-9E16-5A1E2C23725C__CHDEDGJG">模型选项</a> ”</span>列出了这些选项。
                              </p>
                              <p>不依赖于任何维度限定符的循环依赖性的示例可以被示为<code class="codeph">A&gt;B&gt;C&gt;A</code>箭头表示<code class="codeph">A</code>取决于<code class="codeph">B</code> ， <code class="codeph">B</code>取决于<code class="codeph">C</code> ， <code class="codeph">C</code>取决于<code class="codeph">A</code></p>
                              <p>方式二维相关性可以表示为<span class="italic">-</span>这是一个两循环依赖性的一个例子<code class="codeph">A&gt;LEAD(B)&gt;LAG(A)</code>箭头表明， <code class="codeph">A</code>取决于的值<code class="codeph">B</code>从未来的周期，而<code class="codeph">B</code>取决于的值<code class="codeph">A</code>从先前时段。
                              </p>
                           </li>
                        </ul>
                        <div class="section">
                           <p class="subhead3" id="GUID-EBC35120-9674-4BF4-BF2B-64A513147CA1__GUID-BE813D6E-CB71-46AB-8D0B-918E1F5763F1">同时方程的阶</p>
                        </div>
                        <!-- class="section" -->
                        <div class="section">
                           <p>同时方程组的解对方程的阶数敏感。通常，依靠模型编译器来确定方程的最佳顺序。但是，在某些情况下，您可以通过按特定顺序放置方程式来鼓励收敛。</p>
                           <p>要强制编译器按照放置它们的顺序在每个块中保留联立方程式，请在编译模型之前将MODINPUTORDER选项设置为<code class="codeph">YES</code> 。（MODINPUTORDER对简单块或步骤块中的方程顺序没有影响。）
                           </p>
                        </div>
                        <!-- class="section" -->
                        <div class="section" id="GUID-EBC35120-9674-4BF4-BF2B-64A513147CA1__BABDHHCC">
                           <p class="subhead3" id="GUID-EBC35120-9674-4BF4-BF2B-64A513147CA1__GUID-D9B9A99E-2E70-4BC7-9AA2-0B01C4776C1A">模型编译器假设双向尺寸依赖的结构</p>
                        </div>
                        <!-- class="section" -->
                        <div class="section">
                           <p>当依赖通过任何下列结构的引入，该模型编译器假设两个<span class="italic">-</span>维方式依赖发生：</p>
                           <ul style="list-style-type:disc">
                              <li>
                                 <p>使用聚合函数（例如AVERAGE，TOTAL，ANY或COUNT）时，可能会出现双向维度依赖关系。</p><pre class="oac_no_warn" dir="ltr">OPR。收入=毛。保证金 - （TOTAL（营销+销售+ RD））营销= LAG（Opr。收入，1，月）</pre></li>
                           </ul><pre class="oac_no_warn" dir="ltr"></pre><ul style="list-style-type:disc">
                              <li>
                                 <p>当使用需要的时间的时间序列的功能，可能会发生双向维依赖性<span class="italic">-</span>周期参数，如CUMSUM，LAG或LEAD（除<span class="q">“</span>中说明的特定的功能和条件<span class="q"><a href="formulas-models-aggregations-and-allocations.html#GUID-EBC35120-9674-4BF4-BF2B-64A513147CA1__CACGJAAJ">确保单向维依赖性</a> ”</span> ）。
                                 </p>
                              </li>
                              <li>
                                 <p>当您使用财务功能（例如DEPRSL或NPV）时，也会发生双向维度依赖性。</p>
                                 <p>通过贷款或折旧函数引入的时间维度上的循环依赖可能会导致意外结果。贷款功能包括FINTSCHED，FPMTSCHED，VINTSCHED和VPMTSCHED。折旧函数包括DEPRDECL，DEPRDECLSW，DEPRSL和DEPRSOYD。</p>
                              </li>
                           </ul>
                        </div>
                        <!-- class="section" -->
                        <div class="section" id="GUID-EBC35120-9674-4BF4-BF2B-64A513147CA1__CACGJAAJ">
                           <p class="subhead3" id="GUID-EBC35120-9674-4BF4-BF2B-64A513147CA1__GUID-9C77BA62-900E-4047-AF19-5B2EFD194848">确保单向尺寸依赖性</p>
                        </div>
                        <!-- class="section" -->
                        <div class="section">
                           <p>当通过以下任何结构引入方程之间的相关性时，会发生单向尺寸依赖：</p>
                           <ul style="list-style-type:disc">
                              <li>
                                 <p>当您使用LAG或LEAD函数并且时间段数的参数被编码为显式数字（作为值或常量）或作为ABS的结果时，会发生单向维度依赖性。 （否则，有可能是两<span class="italic">-</span>路径依赖，同时涉及以前和未来的尺寸值，以及编译器假定同时解决方案是必需的）。以下示例说明了LAG的这种用法。</p><pre class="oac_no_warn" dir="ltr">OPR。收入=毛。保证金 - （营销+销售+ RD）营销= LAG（Opr。收入，1，月）</pre></li>
                              <li>
                                 <p>当使用MOVINGAVERAGE，MOVINGMAX，MOVINGMIN或MOVINGTOTAL函数时，当start和stop参数为非零数字时，以及start和top参数均为正数或两者均为负数时，会发生单向维度依赖性。否则，假设双向尺寸依赖性。</p><pre class="oac_no_warn" dir="ltr">OPR。收入=毛。保证金 - （营销+销售+ RD）营销= MOVINGAVERAGE（Opr。收入，-4，-1,1，月）</pre></li>
                           </ul>
                        </div>
                        <!-- class="section" -->
                     </div>
                  </div><a id="OLADM243"></a><div class="props_rev_3"><a id="GUID-5DC92B16-0D3F-46FC-B25F-46780147F282" name="GUID-5DC92B16-0D3F-46FC-B25F-46780147F282"></a><h5 id="OLADM-GUID-5DC92B16-0D3F-46FC-B25F-46780147F282" class="sect5"><span class="enumeration_section">3.3.3.5</span>获取分析结果</h5>
                     <div>
                        <p>编译模型后，您可以使用以下工具获取有关编译器执行的分析结果的信息：</p>
                        <ul style="list-style-type:disc">
                           <li>
                              <p>MODEL.COMPRPT程序生成一个报告，显示模型方程如何分组为块。对于步骤块和用于与横同时块<span class="italic">-</span>维依赖，报告列出参与依赖的尺寸。
                              </p>
                           </li>
                           <li>
                              <p>MODEL.DEPRT程序生成一个报告，列出每个模型方程所依赖的变量和维度值。当依赖关系是维度时，报告会给出维度的名称。</p>
                           </li>
                           <li>
                              <p>INFO功能使您可以获取有关模型结构的特定信息项。</p>
                           </li>
                        </ul>
                     </div>
                  </div><a id="OLADM244"></a><div class="props_rev_3"><a id="GUID-8639B30B-3779-4311-929B-D1192ECF858A" name="GUID-8639B30B-3779-4311-929B-D1192ECF858A"></a><h5 id="OLADM-GUID-8639B30B-3779-4311-929B-D1192ECF858A" class="sect5"><span class="enumeration_section">3.3.3.6</span>检查其他问题</h5>
                     <div>
                        <p>编译器不会分析模型方程中使用的任何程序或公式的内容。因此，您必须自己检查程序和公式，以确保它们<span class="italic">不</span>执行以下任何操作：</p>
                        <ul style="list-style-type:disc">
                           <li>
                              <p>请参阅模型中使用的任何变量的值。</p>
                           </li>
                           <li>
                              <p>请参阅解决方案变量。</p>
                           </li>
                           <li>
                              <p>限制模型中使用的任何尺寸。</p>
                           </li>
                           <li>
                              <p>调用其他模型。</p>
                           </li>
                        </ul>
                        <p>当模型或程序违反任何这些限制时，模型的结果可能不正确。</p>
                        <div class="infoboxnotealso" id="GUID-8639B30B-3779-4311-929B-D1192ECF858A__GUID-891A5561-3B6E-4212-BCEC-78DC812733BA">
                           <p class="notep1">也可以看看：</p>
                           <p><a href="olap-dml-options.html#GUID-791DCDDF-98ED-475D-86BD-E76375F9BC8D">MODTRACE</a> ， <a href="olap-dml-commands-h-z.html#GUID-4DDB2468-396B-4540-A706-9A9B6BC3075F">TRACE</a></p>
                        </div>
                     </div>
                  </div>
               </div><a id="OLADM245"></a><div class="props_rev_3"><a id="GUID-F20C02E1-E771-4DA9-AFD1-B6FB2BFB6E18" name="GUID-F20C02E1-E771-4DA9-AFD1-B6FB2BFB6E18"></a><h4 id="OLADM-GUID-F20C02E1-E771-4DA9-AFD1-B6FB2BFB6E18" class="sect4"><span class="enumeration_section">3.3.4</span>运行模型</h4>
                  <div>
                     <p><a id="d30610e1520" class="indexterm-anchor"></a>运行模型时，请记住以下几点：</p>
                     <ul style="list-style-type:disc">
                        <li>
                           <p>在运行模型之前，输入数据必须在解决方案变量中可用。</p>
                        </li>
                        <li>
                           <p>在运行包含联立方程组块的模型之前，您可能需要检查或修改控制同时块解决方案的某些OLAP DML选项的值。<span class="q">“ <a href="olap-dml-options.html#GUID-8A17CF72-1597-4279-9E16-5A1E2C23725C__CHDEDGJG">模型选项</a> ”</span>中简要介绍了这些选项。
                           </p>
                        </li>
                        <li>
                           <p>当您的模型包含任何基于维度的方程时，您必须提供一个数值解决方案变量，既可以作为数据源，也可以作为方程结果的分配目标。解决方案变量通常由模型方程所基于的所有维度以及您不基于方程的解决方案变量的其他维度确定尺寸。</p>
                        </li>
                        <li>
                           <p>运行模型时，将自动对解决方案变量的每个维度的当前状态列表中的值执行循环，而不是基于方程式。</p>
                        </li>
                        <li>
                           <p>当模型方程基于以前时间段的数据计算时，解决方案变量必须包含这些先前时期的数据。如果没有，或者当DAY，WEEK，MONTH，QUARTER或YEAR类型的维度的第一个值处于状态时，则计算结果为<code class="codeph">NA</code> 。</p>
                        </li>
                     </ul>
                  </div><a id="OLADM246"></a><div class="props_rev_3"><a id="GUID-A783D140-F7D5-4A46-800D-A09602FAFF1A" name="GUID-A783D140-F7D5-4A46-800D-A09602FAFF1A"></a><h5 id="OLADM-GUID-A783D140-F7D5-4A46-800D-A09602FAFF1A" class="sect5"><span class="enumeration_section">3.3.4.1</span>运行模型的语法</h5>
                     <div>
                        <p>要运行或解决模型，请使用以下语法。</p>
                        <p>     <span class="italic">model-name</span> [ <span class="italic">solution-variable</span> ] [NOWARN]</p>
                        <p>哪里：</p>
                        <ul style="list-style-type:disc">
                           <li>
                              <p><span class="italic"><tt>model-name</tt></span>是<span class="italic"><tt>模型的名称</tt></span> 。
                              </p>
                           </li>
                           <li>
                              <p><span class="italic"><tt>solution-variable</tt></span>是一个数值变量的名称，它在包含基于维度的方程的模型中充当数据的源和目标。解决方案变量通常由模型方程所基于的所有维度确定（如显式或包含的DIMENSION命令中所指定）。当模型包含任何基于维度的方程时，需要<span class="italic">求解变量</span>参数。当所有模型方程仅基于变量时，不需要求解变量，并且在提供此参数时会发生错误。有关<span class="q"><a href="formulas-models-aggregations-and-allocations.html#GUID-3D548C0A-9D33-417B-B0C5-DDC1A767310C">解决方案变量</a></span>维的更多信息，请参见<span class="q">“ <a href="formulas-models-aggregations-and-allocations.html#GUID-3D548C0A-9D33-417B-B0C5-DDC1A767310C">解决方案变量的</a></span>维”。
                              </p>
                           </li>
                           <li>
                              <p><tt>NOWARN</tt>是一个可选参数，指定当模型包含联立方程块时，您不希望被警告。
                              </p>
                           </li>
                        </ul>
                     </div>
                  </div><a id="OLADM1105"></a><a id="OLADM1106"></a><a id="OLADM247"></a><div class="props_rev_3"><a id="GUID-3D548C0A-9D33-417B-B0C5-DDC1A767310C" name="GUID-3D548C0A-9D33-417B-B0C5-DDC1A767310C"></a><h5 id="OLADM-GUID-3D548C0A-9D33-417B-B0C5-DDC1A767310C" class="sect5"><span class="enumeration_section">3.3.4.2</span>解决方案变量的维数</h5>
                     <div>
                        <p>在具有基于维数的方程的模型中，解决方案变量通常由模型方程所基于的维度确定尺寸。或者，当解决方案变量由复合材料标注尺寸时，模型方程可以基于复合材料的基础尺寸。模型方程所基于的维度列在显式或继承的DIMENSION语句中。</p>
                        <div class="section">
                           <p class="subhead3" id="GUID-3D548C0A-9D33-417B-B0C5-DDC1A767310C__GUID-1EAC12A2-97E4-4C7B-AC24-0F56A94E810C">解决方案变量的特例</p>
                        </div>
                        <!-- class="section" -->
                        <div class="section">
                           <p>可能会出现以下关于解决方案变量维度的特殊情况：</p>
                           <ul style="list-style-type:disc">
                              <li>
                                 <p>解决方案变量的维度可能未在DIMENSION命令中列出。Oracle OLAP会自动遍历额外维度状态中的值。例如，模型可能包含列出<code class="codeph">line</code>和<code class="codeph">month</code>维度的DIMENSION语句，但您可以指定按<code class="codeph">line</code> ， <code class="codeph">month</code>和<code class="codeph">division</code>标注的解决方案变量。运行模型时，Oracle OLAP会自动遍历<code class="codeph">division</code>维度。解决方案变量也可以通过具有一个或多个未在DIMENSION命令中列出的基本维度的复合来确定尺寸。请参阅<span class="q">“ <a href="formulas-models-aggregations-and-allocations.html#GUID-3D548C0A-9D33-417B-B0C5-DDC1A767310C__BABDAJJD">由复合体标注的解决方案变量</a> ”</span></p>
                              </li>
                              <li>
                                 <p>当解决方案变量具有DIMENSION命令中未列出的维度， <span class="italic">并且</span>当这些其他维度中的任何维度是步骤或同时块的维度时，将发生错误。
                                 </p>
                              </li>
                              <li>
                                 <p>无论解决方案变量是否按其标注尺寸，Oracle OLAP都会遍历DIMENSION命令中列出的所有维度的状态值。因此，当解决方案变量未按所有列出的维度标注时，Oracle OLAP会执行额外的，不必要的工作。在开始求解模型之前，Oracle OLAP会警告您这种情况。</p>
                              </li>
                              <li>
                                 <p>在模型方程中使用贷款，折旧或聚合函数时，在DIMENSION语句中包含DAY，WEEK，MONTH，QUARTER或YEAR类型的不需要的维度会导致错误的结果。出现不正确的结果是因为引用模型维度值的模型方程的任何组件的行为<span class="italic">就好像</span>该组件具有模型的所有维度。
                                 </p>
                              </li>
                           </ul>
                        </div>
                        <!-- class="section" -->
                        <div class="section" id="GUID-3D548C0A-9D33-417B-B0C5-DDC1A767310C__BABDAJJD">
                           <p class="subhead3" id="GUID-3D548C0A-9D33-417B-B0C5-DDC1A767310C__GUID-F40BE6E9-3C5B-4DFB-8D7E-67616832FB18">由Composite组成的解决方案变量</p>
                        </div>
                        <!-- class="section" -->
                        <div class="section">
                           <p>当解决方案变量在其维度列表中包含复合时，Oracle OLAP会尽可能地观察复合的稀疏性。在解决模型时，Oracle OLAP将其在复合上的循环限制为复合中存在的值。它会循环观察复合材料基本尺寸的当前状态。</p>
                           <p>但是，为了正确解决模型，Oracle OLAP必须将复合的以下基本维度视为常规维度：</p>
                           <ul style="list-style-type:disc">
                              <li>
                                 <p>DIMENSION语句中列出的基本维度。</p>
                              </li>
                              <li>
                                 <p>与使用SET创建的模型方程有关的基本维度（例如，将数据分配给由基本维度标注的变量的方程式）。</p>
                              </li>
                              <li>
                                 <p>基本维度，也是在等式的ACROSS短语中指定的不同合成的基本维度。（有关赋值语句和ACROSS短语的使用的更多信息，请参阅<a href="olap-dml-commands-h-z.html#GUID-F6BA1626-650A-46D0-9C01-B2757981AA27">SET</a> 。）
                                 </p>
                              </li>
                           </ul>
                           <p>当解决方案变量的复合的基本维度属于前三个类别中的任何一个时，Oracle OLAP会将该维度视为常规维度，并循环处于当前状态的所有值。</p>
                           <p>当解决方案变量的组合具有不属于特殊三个类别的其他基础维度时，Oracle OLAP会创建这些额外基础维度的临时组合。临时合成的值是原始合成中存在的组合。Oracle OLAP在解决模型时循环遍历临时组合。</p>
                        </div>
                        <!-- class="section" -->
                     </div>
                  </div>
               </div><a id="OLADM248"></a><div class="props_rev_3"><a id="GUID-C40C6E37-B5F7-488A-BF1B-8D87CDBB5EF4" name="GUID-C40C6E37-B5F7-488A-BF1B-8D87CDBB5EF4"></a><h4 id="OLADM-GUID-C40C6E37-B5F7-488A-BF1B-8D87CDBB5EF4" class="sect4"><span class="enumeration_section">3.3.5</span>调试模型</h4>
                  <div>
                     <p>该<a id="d30610e1747" class="indexterm-anchor"></a><a id="d30610e1751" class="indexterm-anchor"></a>以下工具可用于调试模型：</p>
                     <ul style="list-style-type:disc">
                        <li>
                           <p>要查看模型中方程的求解顺序，可以在运行模型之前将MODTRACE选项设置为<code class="codeph">YES</code> 。将MODTRACE设置为<code class="codeph">YES</code> ，可以使用DBGOUTFILE语句将调试信息发送到文件。DBGOUTFILE生成的文件将模型的每一行与其相应的输出交织在一起。
                           </p>
                        </li>
                        <li>
                           <p>您可以使用MODEL.COMPRPT，MODEL.DEPRT和MODEL.XEQRPT程序以及INFO函数来获取有关已编译模型的结构和已运行模型的解决方案状态的信息。</p>
                        </li>
                     </ul>
                  </div>
               </div>
            </div><a id="OLADM249"></a><a id="olapdml_aggregation_objects"></a><div class="props_rev_3"><a id="GUID-7B279B40-5469-4ED1-AA90-91A9CD3246D2" name="GUID-7B279B40-5469-4ED1-AA90-91A9CD3246D2"></a><h3 id="OLADM-GUID-7B279B40-5469-4ED1-AA90-91A9CD3246D2" class="sect3"><span class="enumeration_section">3.4</span> OLAP DML聚合对象</h3>
               <div>
                  <p>本主题提供有关使用OLAP DML聚合数据的信息。它包括以下子主题：</p>
                  <ul style="list-style-type:disc">
                     <li>
                        <p><a href="formulas-models-aggregations-and-allocations.html#GUID-FAC06374-8064-478B-B9F3-F3400075FDFD">什么是OLAP DML聚合？</a></p>
                     </li>
                     <li>
                        <p><a href="formulas-models-aggregations-and-allocations.html#GUID-DB0FCE99-E6CC-4BBD-8A60-FA30AF35E598">使用OLAP DML聚合数据</a></p>
                     </li>
                     <li>
                        <p><a href="formulas-models-aggregations-and-allocations.html#GUID-E346D50B-BF22-4A24-8B6A-649583C36508">编译聚合规范</a></p>
                     </li>
                     <li>
                        <p><a href="formulas-models-aggregations-and-allocations.html#GUID-8A57C56B-B39B-4C05-95D2-8DBA5D6FD2BD">执行聚合</a></p>
                     </li>
                     <li>
                        <p><a href="formulas-models-aggregations-and-allocations.html#GUID-F6238F27-CD6B-42FE-A164-6132A138F4AB">创建自定义聚合</a></p>
                     </li>
                  </ul>
               </div><a id="OLADM250"></a><div class="props_rev_3"><a id="GUID-FAC06374-8064-478B-B9F3-F3400075FDFD" name="GUID-FAC06374-8064-478B-B9F3-F3400075FDFD"></a><h4 id="OLADM-GUID-FAC06374-8064-478B-B9F3-F3400075FDFD" class="sect4"><span class="enumeration_section">3.4.1</span>什么是OLAP DML聚合？
                  </h4>
                  <div>
                     <p><a id="d30610e1850" class="indexterm-anchor"></a>从历史上看， <a id="d30610e1855" class="indexterm-anchor"></a>汇总数据是对详细数据进行求和以提供小计和总计。但是，使用OLAP DML aggmap对象，您可以指定更复杂的聚合计算：</p>
                     <ul style="list-style-type:disc">
                        <li>
                           <p>可以使用许多不同类型的方法（例如，第一，最后，平均或加权平均）来计算由分层维度标注的摘要数据。有关此类聚合的<a href="olap-dml-commands-a-g.html#GUID-E97AC985-28C6-457E-BD95-0A3F9A5D452A__CHDEHECG">示例</a> ，请参见<a href="olap-dml-commands-a-g.html#GUID-E97AC985-28C6-457E-BD95-0A3F9A5D452A__CHDEHECG">示例9-18</a> 。
                           </p>
                        </li>
                        <li>
                           <p>可以使用模型计算由非分层维度标注的摘要数据。使用模型计算摘要数据对于计算不具有分层结构的维度（例如行项目）的值非常有用。而是创建一个模型，以计算来自一个或多个其他行项目或工作空间对象的各个行项目的值。有关此类聚合的<a href="olap-dml-commands-a-g.html#GUID-E97AC985-28C6-457E-BD95-0A3F9A5D452A__CHDEEHBB">示例</a> ，请参见<a href="olap-dml-commands-a-g.html#GUID-E97AC985-28C6-457E-BD95-0A3F9A5D452A__CHDEEHBB">示例9-17</a> 。
                           </p>
                        </li>
                        <li>
                           <p>用于计算摘要数据的详细数据可以在包含摘要数据的变量中，也可以在一个或多个其他变量中。包含摘要数据的变量不必与包含详细信息数据的变量具有相同的维度。有关此类聚合的示例，请参见<a href="olap-dml-commands-a-g.html#GUID-E97AC985-28C6-457E-BD95-0A3F9A5D452A__CHDBHJHD">示例9-15</a>和<a href="olap-dml-commands-a-g.html#GUID-09FDB96F-9305-4F6B-92C7-311963C521D1__BCFIGIJJ">示例9-32</a> 。
                           </p>
                        </li>
                        <li>
                           <p>数据可以作为数据库维护过程聚合，以响应用户对汇总数据的请求，或者您可以组合这些方法。有关更多信息，请参阅<span class="q">“ <a href="formulas-models-aggregations-and-allocations.html#GUID-8A57C56B-B39B-4C05-95D2-8DBA5D6FD2BD">执行聚合</a> ”</span> 。
                           </p>
                        </li>
                        <li>
                           <p>响应于用户请求而聚合的数据可以在每次请求或存储或缓存在分析工作区中时计算，以供将来查询使用。</p>
                        </li>
                        <li>
                           <p>聚合的规范可以是永久的或临时的，如<span class="q">“ <a href="formulas-models-aggregations-and-allocations.html#GUID-F6238F27-CD6B-42FE-A164-6132A138F4AB">创建自定义聚合</a> ”中所述</span> 。
                           </p>
                        </li>
                     </ul>
                  </div>
               </div><a id="OLADM251"></a><div class="props_rev_3"><a id="GUID-DB0FCE99-E6CC-4BBD-8A60-FA30AF35E598" name="GUID-DB0FCE99-E6CC-4BBD-8A60-FA30AF35E598"></a><h4 id="OLADM-GUID-DB0FCE99-E6CC-4BBD-8A60-FA30AF35E598" class="sect4"><span class="enumeration_section">3.4.2</span>使用OLAP DML聚合数据</h4>
                  <div>
                     <div class="section">
                        <p>要使用OLAP DML聚合数据，请执行以下步骤：</p>
                        <ol>
                           <li>
                              <p>确定是要使用AGGREGATE命令将所有数据聚合为数据库维护过程，还是使用AGGREGATE函数或$ AGGMAP属性在运行时即时聚合，或者如果要组合这些方法并预先计算某些值并在运行时计算其他人。有关各种方法的讨论，请参阅<span class="q">“ <a href="formulas-models-aggregations-and-allocations.html#GUID-8A57C56B-B39B-4C05-95D2-8DBA5D6FD2BD">执行聚合</a> ”</span> 。
                              </p>
                           </li>
                           <li>
                              <p>发出DEFINE AGGMAP语句以将aggmap对象定义为AGGMAP类型。</p>
                           </li>
                           <li>
                              <p>按照<a href="olap-dml-commands-a-g.html#GUID-E97AC985-28C6-457E-BD95-0A3F9A5D452A">AGGMAP中的</a>描述编写聚合规范。</p>
                           </li>
                           <li>
                              <p>聚合分区变量时，运行PARTITIONCHECK以检查上一步中创建的聚合规范是否与变量的分区兼容。如果不是，则重写聚合规范或使用CHGDFN重新分区变量。</p>
                           </li>
                           <li>
                              <p>当使用AGGREGATE函数聚合部分或全部数据时：</p>
                              <ol type="a">
                                 <li>
                                    <p>按照<span class="q">“ <a href="formulas-models-aggregations-and-allocations.html#GUID-E346D50B-BF22-4A24-8B6A-649583C36508">编译聚合规范</a> ”中的</span>描述编译aggmap对象。
                                    </p>
                                 </li>
                                 <li>
                                    <p>添加触发属性，对象或事件。例如，添加一个具有AGGREGATE函数作为其表达式的公式，并将$ NATRIGGER属性添加到该变量，以触发执行该公式以响应对数据的运行时请求。</p>
                                 </li>
                              </ol>
                           </li>
                           <li>
                              <p>如果希望aggmap对象成为分析工作区的永久部分，请使用UPDATE语句后跟COMMIT保存aggmap对象。</p>
                           </li>
                           <li>
                              <p>对于要使用AGGREGATE命令计算的数据：</p>
                              <ol type="a">
                                 <li>
                                    <p>（可选）使用DBMS_CUBE_LOG.ENABLE过程记录聚合操作。</p>
                                 </li>
                                 <li>
                                    <p>使用AGGREGATE命令，然后使用UPDATE和COMMIT预先计算数据并将其存储在分析工作区中。</p>
                                 </li>
                              </ol>
                           </li>
                        </ol>
                     </div>
                     <!-- class="section" -->
                  </div>
               </div><a id="OLADM252"></a><div class="props_rev_3"><a id="GUID-E346D50B-BF22-4A24-8B6A-649583C36508" name="GUID-E346D50B-BF22-4A24-8B6A-649583C36508"></a><h4 id="OLADM-GUID-E346D50B-BF22-4A24-8B6A-649583C36508" class="sect4"><span class="enumeration_section">3.4.3</span>编译聚合规范</h4>
                  <div>
                     <p>编译<a id="d30610e2004" class="indexterm-anchor"></a> aggmap对象对于使用AGGREGATE函数在运行时执行的聚合很重要。除非已保存aggmap的编译版本，否则每个使用它的会话都会重新编译aggmap。
                     </p>
                     <p>您可以通过两种方式编译aggmap对象：</p>
                     <ul style="list-style-type:disc">
                        <li>
                           <p>发出COMPILE语句。<a id="d30610e2015" class="indexterm-anchor"></a><a id="d30610e2019" class="indexterm-anchor"></a><a id="d30610e2023" class="indexterm-anchor"></a><a id="d30610e2027" class="indexterm-anchor"></a></p>
                           <p>COMPILE语句是编译AGGREGATE函数使用的aggmap对象的唯一方法。在尝试使用aggmap生成数据之前，显式编译aggmap对于查找aggmap中的语法错误也很有用。以下语句编译<code class="codeph">sales.agg</code> aggmap。
                           </p><pre class="oac_no_warn" dir="ltr">编译gpct.aggmap</pre></li>
                        <li>
                           <p>使用AGGREGATE命令聚合数据时，请在语句中包含FUNCDATA短语。</p>
                           <p>在AGGREGATE命令中使用FUNCDATA短语时，Oracle OLAP会在聚合数据之前编译aggmap。例如，此语句编译并预先计算聚合数据。</p><pre class="oac_no_warn" dir="ltr">AGGREGATE销售使用gpct.aggmap FUNCDATA</pre><div class="infoboxnote" id="GUID-E346D50B-BF22-4A24-8B6A-649583C36508__GUID-0B2731CA-96BE-4D2B-94F9-8FDC96681F86">
                              <p class="notep1">注意：</p>
                              <p>当一些数据在运行中计算时，您必须<span class="italic">在</span>执行AGGREGATE命令<span class="italic">后</span>编译并保存aggmap。
                              </p>
                           </div>
                        </li>
                     </ul>
                  </div>
               </div><a id="OLADM253"></a><div class="props_rev_3"><a id="GUID-8A57C56B-B39B-4C05-95D2-8DBA5D6FD2BD" name="GUID-8A57C56B-B39B-4C05-95D2-8DBA5D6FD2BD"></a><h4 id="OLADM-GUID-8A57C56B-B39B-4C05-95D2-8DBA5D6FD2BD" class="sect4"><span class="enumeration_section">3.4.4</span>执行聚合</h4>
                  <div>
                     <p>OLAP DML提供了两种聚合数据的方法：</p>
                     <ul style="list-style-type:disc">
                        <li>
                           <p><a id="d30610e2084" class="indexterm-anchor"></a>作为使用AGGREGATE命令的数据维护过程。要使用此方法聚合聚合规范中的数据，请使用RELATION语句的PRECOMPUTE语句或PRECOMPUTE子句标识要以此方式聚合的数据。
                           </p>
                        </li>
                        <li>
                           <p><a id="d30610e2091" class="indexterm-anchor"></a><a id="d30610e2095" class="indexterm-anchor"></a>在需要的运行时使用AGGREGATE函数或向变量添加$ AGGMAP属性。
                           </p>
                        </li>
                     </ul>
                     <p>您可以选择合适的方法：按级别，单个成员，成员属性，时间范围，数据值或其他条件。您还可以组合这些方法并预先计算某些值并在运行时计算其他值。在这种情况下，通常使用与AGGREGATE命令和AGGREGATE函数相同的aggmap。但是，在某些情况下，您可能会使用不同的aggmaps。</p>
                     <p>为实现整体良好性能，您可以采取的一个步骤是平衡您在分析工作区中聚合和存储的数据量，以及您为动态计算指定的数据量。您可以在聚合规范中使用PRECOMPUTE语句或子句，要求Oracle OLAP使用称为的特殊功能<a id="d30610e2102" class="indexterm-anchor"></a> Aggregate Advisor使用AGGREGATE命令自动确定要聚合为数据维护过程的值，或者自己明确标识值。
                     </p>
                  </div>
               </div><a id="OLADM254"></a><div class="props_rev_3"><a id="GUID-F6238F27-CD6B-42FE-A164-6132A138F4AB" name="GUID-F6238F27-CD6B-42FE-A164-6132A138F4AB"></a><h4 id="OLADM-GUID-F6238F27-CD6B-42FE-A164-6132A138F4AB" class="sect4"><span class="enumeration_section">3.4.5</span>创建自定义聚合</h4>
                  <div>
                     <div class="section">
                        <p>大多数聚合的定义从一个会话持续到另一个会话。但是，您可能需要在运行时创建仅会话聚合以进行预测或假设分析，或者仅仅因为您希望以不可预见的方式查看数据。添加仅会话聚合有时称为创建自定义聚合。您可以通过以下方式创建非持久性聚合数据，而无需永久更改聚合规范：</p>
                        <ul style="list-style-type:disc">
                           <li>
                              <p>使用MAINTAIN ADD SESSION语句，定义临时维度成员，并将聚合规范包含在这些成员的定义中。聚合规范可以是模型或aggmap。有关使用此方法创建临时聚合的<a href="olap-dml-commands-h-z.html#GUID-D2B2C2E7-F012-45C8-9E1E-5F0AB1DE8FDA__CHDBDHJA">示例</a> ，请参见<a href="olap-dml-commands-h-z.html#GUID-D2B2C2E7-F012-45C8-9E1E-5F0AB1DE8FDA__CHDBDHJA">示例10-42</a> 。
                              </p>
                           </li>
                           <li>
                              <p>创建指定聚合的模型。使用AGGMAP ADD语句在运行时将模型添加到aggmap。在会话之后，Oracle OLAP会以这种方式自动删除您添加到aggmap的所有模型。有关详细信息，请参阅<a href="olap-dml-commands-a-g.html#GUID-A21B7B14-A983-4B8C-AED9-FCD2A8627B9C">AGGMAP ADD或REMOVE模型</a> 。
                              </p>
                           </li>
                        </ul>
                     </div>
                     <!-- class="section" -->
                  </div>
               </div>
            </div><a id="OLADM255"></a><a id="olapdml_allocation_objects"></a><div class="props_rev_3"><a id="GUID-DF40EC68-A4C4-45A5-821E-49F136FF1323" name="GUID-DF40EC68-A4C4-45A5-821E-49F136FF1323"></a><h3 id="OLADM-GUID-DF40EC68-A4C4-45A5-821E-49F136FF1323" class="sect3"><span class="enumeration_section">3.5</span> OLAP DML分配对象</h3>
               <div>
                  <p><a id="d30610e2178" class="indexterm-anchor"></a>分配数据<a id="d30610e2183" class="indexterm-anchor"></a>涉及从摘要数据创建较低级别的数据。本主题概述了如何使用OLAP DML语句分配数据。它包括以下子主题：</p>
                  <ul style="list-style-type:disc">
                     <li>
                        <p><a href="formulas-models-aggregations-and-allocations.html#GUID-CE7D7576-BC32-4B6B-ADD7-A2E3A463F291">使用OLAP DML分配数据简介</a> 
                        </p>
                     </li>
                     <li>
                        <p><a href="formulas-models-aggregations-and-allocations.html#GUID-7AE362EC-3DCE-425D-82AC-355E8361A1C8">Oracle OLAP中的分配功能</a> 
                        </p>
                     </li>
                     <li>
                        <p><a href="formulas-models-aggregations-and-allocations.html#GUID-BA7B4A64-E4BC-4C2B-B504-2A1C5E94680B">分配数据</a> 
                        </p>
                     </li>
                     <li>
                        <p><a href="formulas-models-aggregations-and-allocations.html#GUID-50F9C98F-01C1-42BE-BCA6-19D86673BC34">在分配数据时处理NA值</a> 
                        </p>
                     </li>
                  </ul>
               </div><a id="OLADM256"></a><div class="props_rev_3"><a id="GUID-CE7D7576-BC32-4B6B-ADD7-A2E3A463F291" name="GUID-CE7D7576-BC32-4B6B-ADD7-A2E3A463F291"></a><h4 id="OLADM-GUID-CE7D7576-BC32-4B6B-ADD7-A2E3A463F291" class="sect4"><span class="enumeration_section">3.5.1</span>使用OLAP DML分配数据简介</h4>
                  <div>
                     <p>您可以在ALLOCMAP类型的aggmap对象中指定数据分配。要实现分配，请为ALLOCMAP aggmap执行ALLOCATE命令。目标是由一个或多个分层维度标注的变量。源数据由层级维度中的较高级别的维值指定，而不是指定目标单元格的值。</p>
                     <p>ALLOCATE使用aggmap指定要在分配中使用的层次结构的维度和值，用于维度的操作方法以及分配的其他方面。</p>
                     <p>一些分配操作基于现有数据。包含该数据的对象是分配的基础对象。在这些操作中，ALLOCATE根据基础对象的值分配来自源的数据。</p>
                     <p>ALLOCATE的操作与AGGREGATE命令的操作相反。分配操作方法的范围从简单的分配，例如将源数据复制到目标变量的单元格，到非常复杂的分配，例如来自作为公式的源的数据的比例分布，其中分配的量基于另一个公式，多个变量作为目标，并使用aggmap指定不同维度的不同分配方法。</p>
                  </div>
               </div><a id="OLADM257"></a><div class="props_rev_3"><a id="GUID-7AE362EC-3DCE-425D-82AC-355E8361A1C8" name="GUID-7AE362EC-3DCE-425D-82AC-355E8361A1C8"></a><h4 id="OLADM-GUID-7AE362EC-3DCE-425D-82AC-355E8361A1C8" class="sect4"><span class="enumeration_section">3.5.2</span> Oracle OLAP中的分配功能</h4>
                  <div>
                     <p>Oracle OLAP分配系统非常灵活，具有许多功能，包括：</p>
                     <ul style="list-style-type:disc">
                        <li>
                           <p>源，基础和目标对象可以是同一个变量，也可以是不同的对象。</p>
                        </li>
                        <li>
                           <p>源和基础对象可以是公式，因此您可以对现有数据执行计算，并将结果用作分配的来源或基础。</p>
                        </li>
                        <li>
                           <p>您可以指定维度分配的操作方法。操作范围从简单到非常复杂。</p>
                        </li>
                        <li>
                           <p>您可以指定是将已分配的值添加到目标单元格还是替换目标单元格的现有值。</p>
                        </li>
                        <li>
                           <p>在将结果分配给目标单元格之前，您可以指定要添加或乘以分配值的数量。</p>
                        </li>
                        <li>
                           <p>您可以锁定维层次结构中的各个值，以便分配不会更改这些维值的目标单元格数据。锁定维值时，分配系统会对源数据进行规范化，从而在分配之前从源中减去锁定的数据。您可以选择不规范化源数据。</p>
                        </li>
                        <li>
                           <p>您可以为某些操作指定最小值，最大值，最大值或上限值。</p>
                        </li>
                        <li>
                           <p>您可以将分配的数据复制到第二个变量，以便您可以记录对作为多个分配目标的单元格的单独分配。</p>
                        </li>
                        <li>
                           <p>您可以在基础具有空值时指定处理分配的方式。</p>
                        </li>
                        <li>
                           <p>您可以在不同的ALLOCATE命令中使用相同的aggmap，以使用具有不同源，基础或目标对象的同一组维度层次结构值，操作和参数。</p>
                        </li>
                     </ul>
                  </div>
               </div><a id="OLADM258"></a><div class="props_rev_3"><a id="GUID-BA7B4A64-E4BC-4C2B-B504-2A1C5E94680B" name="GUID-BA7B4A64-E4BC-4C2B-B504-2A1C5E94680B"></a><h4 id="OLADM-GUID-BA7B4A64-E4BC-4C2B-B504-2A1C5E94680B" class="sect4"><span class="enumeration_section">3.5.3</span>分配数据</h4>
                  <div>
                     <div class="section">
                        <p>要使用aggmap对象分配数据，请按照指示的顺序使用以下OLAP DML语句：</p>
                     </div>
                     <!-- class="section" -->
                     <ol>
                        <li class="stepexpand"><span>发出DEFINE AGGMAP语句来定义aggmap对象。</span><div>
                              <div class="infoboxnote" id="GUID-BA7B4A64-E4BC-4C2B-B504-2A1C5E94680B__GUID-2FF16164-2825-40F7-987E-31F553CB0588">
                                 <p class="notep1">注意：</p>
                                 <p>使用OLAP工作表时，在命令行级别，紧接在DEFINE AGGMAP语句之后，通过编写ALLOCMAP语句来输入“空”分配规范。例如：</p><pre class="oac_no_warn" dir="ltr">定义myaggmap AGGMAP ALLOCMAP'END'</pre></div>
                           </div>
                        </li>
                        <li class="stepexpand"><span>向aggmap对象添加规范，指定要执行的分配。有关更多信息，请参阅<a href="olap-dml-commands-a-g.html#GUID-7B0A4AD5-1929-40D1-8DAB-5BF53C2F2B0C">ALLOCMAP</a> 。</span></li>
                        <li class="stepexpand"><span>如果希望aggmap对象成为分析工作区的永久部分，请使用UPDATE语句后跟COMMIT保存aggmap对象。</span></li>
                        <li class="stepexpand"><span>（可选）使用DBMS_CUBE_LOG.ENABLE过程记录分配操作。</span></li>
                        <li class="stepexpand"><span>（可选）通过将ALLOCERRLOGFORMAT和ALLOCERRLOGHEADER选项设置为非默认值来重新设计分配错误日志。</span></li>
                        <li class="stepexpand"><span>（可选）在一个或多个变量上设置$ ALLOCMAP属性，以指定aggmap是变量的默认分配规范。</span></li>
                        <li class="stepexpand"><span>（推荐，但可选）将变量限制为目标单元格（即，要将数据分配到的单元格）。</span></li>
                        <li class="stepexpand"><span>发出ALLOCATE语句来分配数据。</span></li>
                     </ol>
                  </div>
               </div><a id="OLADM259"></a><div class="props_rev_3"><a id="GUID-50F9C98F-01C1-42BE-BCA6-19D86673BC34" name="GUID-50F9C98F-01C1-42BE-BCA6-19D86673BC34"></a><h4 id="OLADM-GUID-50F9C98F-01C1-42BE-BCA6-19D86673BC34" class="sect4"><span class="enumeration_section">3.5.4</span>分配数据时处理NA值</h4>
                  <div>
                     <p>有时，您希望在将值分配给目标变量时覆盖现有数据，有时您希望在分配之前将分配值写入具有<code class="codeph">NA</code>基础的目标单元格。例如，在产品维度中创建产品时，预算变量中的新产品不存在任何依据。您希望为整个产品系列分配广告费用，包括新产品。
                     </p>
                     <p>您可以通过以下方式使用RELATION语句中的公式和分层运算符来处理<code class="codeph">NA</code>值：</p>
                     <ul style="list-style-type:disc">
                        <li>
                           <p>使用公式处理NA数据 - 处理<code class="codeph">NA</code>值的首选方法是构建仅描述所需目标单元格的基础。您可以通过从公式派生基础来优化基础值的选择。以下语句定义了一个公式，该公式将新产品的值等同于现有产品的两倍。您可以使用这样的公式作为为新产品分配广告费用的基础。
                           </p><pre class="oac_no_warn" dir="ltr">DEFINE formula_basis FORMULA DECIMAL &lt;产品&gt; EQ IF产品EQ'NEWPRODUCT' - 那么2 * product.budget（产品'EXISTINGPRODUCT'） -  ELSE product.budget</pre></li>
                        <li>
                           <p>使用分层运算符处理NA数据 - 要将数据分配给当前具有<code class="codeph">NA</code>值的目标单元格，请在分配规范的RELATION语句中使用分层运算符。分层运算符使用维度的层次结构而不是现有数据作为分配基础。使用分层运算符的一个危险是可能会密集填充您的详细级别数据，这可能会导致更大的分析工作区，并且需要更多时间来聚合数据。
                           </p>
                           <p>要继续为新产品分配广告成本的示例，您可以使用分层最后一个运算符HLAST来指定将成本分配给产品维层次结构中的新（并且可能是最后一个）产品。</p>
                        </li>
                     </ul>
                  </div>
               </div>
            </div>
         </div>
      </article>
   </body>
</html>