<html lang="en-us" dir="ltr" xml:lang="en-us">
   <head>
      <meta http-equiv="Content-Type" content="text/html; charset=utf-8"></meta>
      <meta name="viewport" content="width=device-width, initial-scale=1"></meta>
      <meta http-equiv="X-UA-Compatible" content="IE=edge"></meta>
      <title>类型进化</title>
      <meta property="og:site_name" content="Oracle Help Center"></meta>
      <meta property="og:title" content="Object-Relational Developer&#39;s Guide "></meta>
      <meta property="og:description" content=""></meta>
      <link rel="stylesheet" href="/sp_common/book-template/ohc-book-template/css/book.css"></link>
      <link rel="shortcut icon" href="/sp_common/book-template/ohc-common/img/favicon.ico"></link>
      <meta name="application-name" content="Object-Relational Developer&#39;s Guide"></meta>
      <meta name="generator" content="DITA Open Toolkit version 1.8.5 (Mode = doc)"></meta>
      <meta name="plugin" content="SP_docbuilder HTML plugin release 18.2.2"></meta>
      <link rel="alternate" href="object-relational-developers-guide.pdf" title="PDF File" type="application/pdf"></link>
      <meta name="robots" content="all"></meta>
      <link rel="schema.dcterms" href="http://purl.org/dc/terms/"></link>
      <meta name="dcterms.created" content="2019-01-11T02:05:10-08:00"></meta>
      
      <meta name="dcterms.dateCopyrighted" content="1996, 2019"></meta>
      <meta name="dcterms.category" content="database"></meta>
      <meta name="dcterms.identifier" content="E96436-01"></meta>
      
      <meta name="dcterms.product" content="en/database/oracle/oracle-database/19"></meta>
      
      <link rel="prev" href="creating-indexes-on-typeids-or-attributes.html" title="Previous" type="text/html"></link>
      <link rel="next" href="storing-XMLTypes-and-LOBs-in-an-ANYDATA-column.html" title="Next" type="text/html"></link>
      <script>
        document.write('<style type="text/css">');
        document.write('body > .noscript, body > .noscript ~ * { visibility: hidden; }');
        document.write('</style>');
     </script>
      <script src="/sp_common/book-template/requirejs/require.js" data-main="/sp_common/book-template/ohc-book-template/js/book-config"></script>
      <script>
            if (window.require === undefined) {
                document.write('<script data-main="sp_common/book-template/ohc-book-template/js/book-config" src="sp_common/book-template/requirejs/require.js"><\/script>');
                document.write('<link href="sp_common/book-template/ohc-book-template/css/book.css" rel="stylesheet"/>');
            }
        </script>
      <script type="application/json" id="ssot-metadata">{"primary":{"category":{"short_name":"database","element_name":"Database","display_in_url":true},"suite":{"short_name":"oracle","element_name":"Oracle","display_in_url":true},"product_group":{"short_name":"not-applicable","element_name":"Not applicable","display_in_url":false},"product":{"short_name":"oracle-database","element_name":"Oracle Database","display_in_url":true},"release":{"short_name":"19","element_name":"Release 19","display_in_url":true}}}</script>
      
    <meta name="dcterms.title" content="Object-Relational Developer&#39;s Guide"></meta>
    <meta name="dcterms.isVersionOf" content="ADOBJ"></meta>
    <meta name="dcterms.release" content="Release 19"></meta>
  </head>
   <body dir="ltr">
      <div class="noscript alert alert-danger text-center" role="alert">
         <a href="creating-indexes-on-typeids-or-attributes.html" class="pull-left"><span class="glyphicon glyphicon-chevron-left" aria-hidden="true"></span>上一页</a> <a href="storing-XMLTypes-and-LOBs-in-an-ANYDATA-column.html" class="pull-right">下一页<span class="glyphicon glyphicon-chevron-right" aria-hidden="true"></span></a> <span class="fa fa-exclamation-triangle" aria-hidden="true"></span>必须启用JavaScript才能正确显示此内容</div>
      <article>
         <header>
            <ol class="breadcrumb" vocab="http://schema.org/" typeof="BreadcrumbList">
               <li property="itemListElement" typeof="ListItem"><a href="index.html" property="item" typeof="WebPage"><span property="name">对象关系开发人员指南</span></a></li>
               <li property="itemListElement" typeof="ListItem"><a href="advanced-topics-for-oracle-objects.html" property="item" typeof="WebPage"><span property="name">Oracle Objects的高级主题</span></a></li>
               <li class="active" property="itemListElement" typeof="ListItem">类型进化</li>
            </ol>
            <a id="GUID-AD083363-701A-4CE4-8795-C55D7EBCCB47" name="GUID-AD083363-701A-4CE4-8795-C55D7EBCCB47"></a><a id="ADOBJ00603"></a>
            
            <h2 id="ADOBJ-GUID-AD083363-701A-4CE4-8795-C55D7EBCCB47" class="sect2"><span class="enumeration_section">8.3</span>类型进化</h2>
         </header>
         <div class="ind">
            <div>
               <p>类型演化是更改对象类型的过程。</p>
               <p>话题：</p>
               <ul style="list-style-type:disc">
                  <li>
                     <p><a href="type-evolution.html#GUID-DD8B0488-CA01-4A3B-8DB9-43BEF5352F41">关于Type Evolution</a></p>
                  </li>
                  <li>
                     <p><a href="type-evolution.html#GUID-30872941-6F8F-4E1D-80EE-F766130A9407">键入Evolution和Dependent Schema对象</a></p>
                  </li>
                  <li>
                     <p><a href="type-evolution.html#GUID-F81E640C-F0FC-48D6-8FB0-CA97E56FE32B">更新数据的选项</a></p>
                  </li>
                  <li>
                     <p><a href="type-evolution.html#GUID-12447517-9047-4DA3-8489-27C9AC2271A1">结构变化对类型的影响</a></p>
                  </li>
                  <li>
                     <p><a href="type-evolution.html#GUID-A996DB5F-B19B-4EC1-B537-3438F24562CE">通过添加和删除属性来更改类型</a></p>
                  </li>
                  <li>
                     <p><a href="type-evolution.html#GUID-B7C97F03-5476-4661-8113-CADDF5D1963D">通过添加嵌套表属性来更改类型</a></p>
                  </li>
                  <li>
                     <p><a href="type-evolution.html#GUID-0CFB36EF-6576-4FDB-9B66-294A8AFB3F9F">关于验证已更改的类型</a></p>
                  </li>
                  <li>
                     <p><a href="type-evolution.html#GUID-EBA7E55C-0D72-4CBA-908B-B4B7B55E306B">类型进化的ALTER TYPE语句</a></p>
                  </li>
                  <li>
                     <p><a href="type-evolution.html#GUID-A9527438-B790-4E35-A36F-3507F6C2A00A">类型Evolution的ALTER TABLE语句</a></p>
                  </li>
               </ul>
            </div>
            <div class="props_rev_3"><a id="GUID-DD8B0488-CA01-4A3B-8DB9-43BEF5352F41" name="GUID-DD8B0488-CA01-4A3B-8DB9-43BEF5352F41"></a><h3 id="ADOBJ-GUID-DD8B0488-CA01-4A3B-8DB9-43BEF5352F41" class="sect3"><span class="enumeration_section">8.3.1</span>关于类型演变</h3>
               <div>
                  <p>您可以进行以下更改以演变对象类型：</p>
                  <ul style="list-style-type:disc">
                     <li>
                        <p>添加和删除属性</p>
                     </li>
                     <li>
                        <p>添加和删除方法</p>
                     </li>
                     <li>
                        <p>修改数字属性以增加其长度，精度或比例</p>
                     </li>
                     <li>
                        <p>修改变长字符属性以增加其长度</p>
                     </li>
                     <li>
                        <p>更改类型的<code class="codeph">FINAL</code>和<code class="codeph">INSTANTIABLE</code>属性</p>
                     </li>
                     <li>
                        <p>修改<code class="codeph">VARRAY</code>的限制和大小</p>
                     </li>
                     <li>
                        <p>修改集合元素的长度，精度和比例</p>
                     </li>
                  </ul>
                  <p>对类型的更改会影响引用该类型的内容。例如，如果向类型添加新属性，则必须显示该类型列中的数据，以包含新属性。</p>
               </div>
            </div><a id="ADOBJ7657"></a><div class="props_rev_3"><a id="GUID-30872941-6F8F-4E1D-80EE-F766130A9407" name="GUID-30872941-6F8F-4E1D-80EE-F766130A9407"></a><h3 id="ADOBJ-GUID-30872941-6F8F-4E1D-80EE-F766130A9407" class="sect3"><span class="enumeration_section">8.3.2</span>类型演化和从属模式对象</h3>
               <div>
                  <p>类型的从属模式对象是直接或间接引用该类型的对象，并受到对其的更改的影响。</p>
                  <p>类型可以具有这些类型的依赖模式对象：表;类型或子类型;程序单元（PL / SQL块），例如过程，函数，包和触发器;索引类型;视图（包括对象视图）;基于功能的索引;和运营商。</p>
                  <p>对类型的更改如何影响从属模式对象取决于对象和更改的性质。</p>
                  <ul style="list-style-type:disc">
                     <li>
                        <p>修改类型时，依赖程序单元，视图，运算符和索引类型将标记为无效。下次引用其中一个无效模式对象时，将使用新类型定义重新验证它。如果对象成功重新编译，它将变为有效并可以再次使用。</p>
                     </li>
                     <li>
                        <p>可以删除或禁用基于依赖函数的索引，具体取决于类型更改，并且必须重建。</p>
                     </li>
                     <li>
                        <p>依赖表为添加到类型的每个属性添加了一个或多个内部列，具体取决于属性类型。使用<code class="codeph">NULL</code>值添加新属性。对于每个已删除的属性，将删除与该属性关联的列。对于每个已修改的属性，相关列的长度，精度或比例都会相应更改。
                        </p>
                     </li>
                  </ul>
                  <p>这些更改主要涉及更新表的元数据，并且可以快速执行。但是，这些表中的数据也必须更新为新类型版本的格式，如<span class="q">“ <a href="type-evolution.html#GUID-F81E640C-F0FC-48D6-8FB0-CA97E56FE32B">更新数据选项</a> ”中所述</span> 。
                  </p>
               </div>
            </div><a id="ADOBJ7658"></a><div class="props_rev_3"><a id="GUID-F81E640C-F0FC-48D6-8FB0-CA97E56FE32B" name="GUID-F81E640C-F0FC-48D6-8FB0-CA97E56FE32B"></a><h3 id="ADOBJ-GUID-F81E640C-F0FC-48D6-8FB0-CA97E56FE32B" class="sect3"><span class="enumeration_section">8.3.3</span>更新数据的选项</h3>
               <div>
                  <p>根据数据量的不同，更新可能非常耗时，因此<code class="codeph">ALTER TYPE</code>命令可以让您选择是立即转换所有相关表数据还是将其保留为旧格式，以便在更新时逐个转换业务过程。
                  </p>
                  <p><code class="codeph">ALTER TYPE</code>的<code class="codeph">CASCADE</code>选项将类型更改传播到依赖类型和表。<code class="codeph">CASCADE</code>本身具有以下选项，可让您选择是否将表数据转换为新类型格式作为传播的一部分：</p>
                  <ul style="list-style-type:disc">
                     <li>
                        <p><code class="codeph">INCLUDING TABLE DATA</code> ：转换数据（默认）</p>
                     </li>
                     <li>
                        <p><code class="codeph">NOT INCLUDING TABLE DATA</code> ：不转换数据</p>
                     </li>
                  </ul>
                  <p>默认情况下， <code class="codeph">CASCADE</code>选项会转换数据。在任何一种情况下，表数据总是以最新类型版本的格式返回。如果表数据以早期类型版本的格式存储，则数据库在返回之前将数据转换为最新版本的格式，即使实际存储数据的格式在数据被重写之前不会更改。 。
                  </p>
                  <p>您可以从系统视图<code class="codeph">USER_SOURCE</code>检索最新类型的定义。您可以在<code class="codeph">USER_TYPE_VERSIONS</code>视图中查看所有类型版本的定义。
                  </p>
                  <div class="infoboxnotealso" id="GUID-F81E640C-F0FC-48D6-8FB0-CA97E56FE32B__GUID-A362984E-F3F5-4CB1-9EEA-98411220671C">
                     <p class="notep1">也可以看看：</p>
                     <ul style="list-style-type:disc">
                        <li>
                           <p><span class="q">“ <a href="type-evolution.html#GUID-EBA7E55C-0D72-4CBA-908B-B4B7B55E306B">类型演变的ALTER TYPE声明</a> ”</span> 。
                           </p>
                        </li>
                        <li>
                           <p>有关类型规范和正文编译的详细信息，请参阅<a href="../lnpls/CREATE-TYPE-statement.html#LNPLS01375" target="_blank"><span><cite>Oracle数据库PL / SQL语言参考</cite></span></a></p>
                        </li>
                     </ul>
                  </div>
               </div>
            </div><a id="ADOBJ7398"></a><div class="props_rev_3"><a id="GUID-12447517-9047-4DA3-8489-27C9AC2271A1" name="GUID-12447517-9047-4DA3-8489-27C9AC2271A1"></a><h3 id="ADOBJ-GUID-12447517-9047-4DA3-8489-27C9AC2271A1" class="sect3"><span class="enumeration_section">8.3.4</span>结构变化对类型的影响</h3>
               <div>
                  <p>对类型的结构更改会影响相关数据，并且需要转换数据。对于仅限于类型的方法定义或行为（实现）的更改，情况并非如此。</p>
                  <p>对类型的这些可能的更改是结构性的：</p>
                  <ul style="list-style-type:disc">
                     <li>
                        <p>添加或删除属性</p>
                     </li>
                     <li>
                        <p>修改属性的长度，精度或比例</p>
                     </li>
                     <li>
                        <p>将类型的最终结果从<code class="codeph">FINAL</code>更改为<code class="codeph">NOT FINAL</code>或反之</p>
                     </li>
                  </ul>
                  <p>这些更改会导致更改类型及其所有依赖类型的新版本，并要求系统在转换为新版本的过程中添加，删除或修改从属表的内部列。</p>
                  <p>当您对具有依赖类型或表的类型进行任何此类更改时，传播更改的效果不仅限于元数据，还会影响数据存储安排并需要数据转换。</p>
                  <p>除转换数据外，您可能还需要进行其他更改。例如，如果将新属性添加到类型，并且类型体调用该类型的构造函数，则必须修改类型体中的每个构造函数以指定新属性的值。同样，如果添加了一个新方法，则必须替换类型体以添加新方法的实现。可以使用<code class="codeph">CREATE OR REPLACE TYPE BODY</code>语句修改类型主体。
                  </p>
               </div>
            </div><a id="ADOBJ7399"></a><a id="ADOBJ7659"></a><div class="props_rev_3"><a id="GUID-A996DB5F-B19B-4EC1-B537-3438F24562CE" name="GUID-A996DB5F-B19B-4EC1-B537-3438F24562CE"></a><h3 id="ADOBJ-GUID-A996DB5F-B19B-4EC1-B537-3438F24562CE" class="sect3"><span class="enumeration_section">8.3.5</span>通过添加和删除属性来更改类型</h3>
               <div>
                  <div class="section">
                     <p>您可以通过添加一个属性并删除另一个属性来对类型进行简单更改。</p>
                     <p><a href="type-evolution.html#GUID-A996DB5F-B19B-4EC1-B537-3438F24562CE__CJGFFICH">例8-5</a>对<code class="codeph">person_type</code>进行了这样的更改。<code class="codeph">CASCADE</code>关键字将类型更改传播到依赖类型和表，但短语<code class="codeph">NOT</code> <code class="codeph">INCLUDING</code> <code class="codeph">TABLE</code> <code class="codeph">DATA</code>阻止转换相关数据。
                     </p>
                  </div>
                  <!-- class="section" -->
                  <div class="example" id="GUID-A996DB5F-B19B-4EC1-B537-3438F24562CE__CJGFFICH">
                     <p class="titleinexample">示例8-5通过添加和删除属性来更改对象类型</p><pre class="oac_no_warn" dir="ltr">- 如果存在，则删除person_typ和person_obj_table CREATE TYPE person_typ AS OBJECT（idno NUMBER，name VARCHAR2（30），phone VARCHAR2（20））; / CREATE TABLE person_obj_table OF person_typ; INSERT INTO person_obj_table VALUES（person_typ（12，'Bob Jones'，'650-555-0130'））; SELECT值（p）FROM person_obj_table p;</pre></div>
                  <!-- class="example" -->
                  <div class="section"><pre class="pre codeblock"><code>VALUE（P）（IDNO，NAME，PHONE）--------------------------------------- ----- PERSON_TYP（12，'Bob Jones'，'650-555-0130'）</code></pre><p>您可以添加电子邮件属性并删除电话属性，如下所示：</p><pre class="oac_no_warn" dir="ltr">ALTER TYPE person_typ <span class="bold">ADD ATTRIBUTE</span> （电子邮件VARCHAR2（80））， <span class="bold">DROP ATTRIBUTE</span>电话<span class="bold">级联不包括表格数据</span> ;</pre><p>然后您可以断开连接并重新连接以适应类型更改：</p><pre class="oac_no_warn" dir="ltr">连接oe / oe; connect hr / &lt;password&gt;; ALTER SESSION SET PLSQL_WARNINGS ='enable：all'; - 表person_obj_table的数据尚未转换，但是 - 当检索数据时，Oracle会根据最新类型版本返回数据。new属性初始化为NULL。 SELECT值（p）FROM person_obj_table p;</pre><pre class="pre codeblock"><code>VALUE（P）（IDNO，NAME，EMAIL）--------------------------------- PERSON_TYP（12，'Bob琼斯'，NULL</code></pre><p>在<code class="codeph">SELECT</code>语句期间，即使列数据可能转换为最新类型版本，转换后的数据也不会写回列。如果经常检索表中的特定用户定义类型列，请考虑将该数据转换为最新类型版本以消除冗余数据转换。如果列包含<code class="codeph">VARRAY</code>属性，转换特别有用，这些属性通常比对象或嵌套表列需要更多时间进行转换。
                     </p>
                     <p>您可以通过发出<code class="codeph">UPDATE</code>语句将列设置为自身来转换数据列，如以下代码段所示，该代码段与先前的代码无关。
                     </p><pre class="oac_no_warn" dir="ltr">UPDATE dept_tab SET <span class="bold">emp_array_col</span> = <span class="bold">emp_array_col</span> ;</pre><p>您可以使用<code class="codeph">ALTER</code> <code class="codeph">TABLE</code>和<code class="codeph">UPGRADE</code> <code class="codeph">INCLUDING</code> <code class="codeph">DATA</code>转换表中的所有列。例如：</p><pre class="oac_no_warn" dir="ltr">ALTER TYPE person_typ ADD ATTRIBUTE（照片BLOB）级联不包括表格数据; <span class="bold">ALTER TABLE</span> person_obj_table <span class="bold">包括数据的升级</span> ;</pre><p><code class="codeph">ALTER</code> <code class="codeph">TABLE</code>行仅转换列出的表。<code class="codeph">CASCADE</code>选项可防止转换其他表或依赖项。
                     </p>
                  </div>
                  <!-- class="section" -->
               </div>
            </div><a id="ADOBJ7400"></a><div class="props_rev_3"><a id="GUID-B7C97F03-5476-4661-8113-CADDF5D1963D" name="GUID-B7C97F03-5476-4661-8113-CADDF5D1963D"></a><h3 id="ADOBJ-GUID-B7C97F03-5476-4661-8113-CADDF5D1963D" class="sect3"><span class="enumeration_section">8.3.6</span>通过添加嵌套表属性来更改类型</h3>
               <div>
                  <div class="section">
                     <p>您可以将嵌套表属性添加到嵌套表中包含的对象类型。</p>
                     <p>需要执行以下步骤才能将此复杂更改为类型。</p>
                     <p>这些步骤需要这个初始模式，然后由步骤1中的代码更改。</p>
                     <p><span class="bold">初始架构</span></p><pre class="oac_no_warn" dir="ltr">- 删除现有的person_typ，department_type，people_typ对象或表CREATE TYPE person_typ AS OBJECT（idno NUMBER，name VARCHAR2（30），phone VARCHAR2（20））; /  - 创建嵌套表类型CREATE TYPE people_typ AS TABLE OF person_typ; / CREATE TYPE department_typ AS OBJECT（manager person_typ，employee people_typ）; //嵌套表/ CREATE TABLE部门OF department_typ NESTED TABLE employee STORE AS employee_store_nt;</pre></div>
                  <!-- class="section" -->
                  <div class="section">
                     <p>步骤1中的代码示例首先创建一个新对象<code class="codeph">tasks_typ</code>和一个嵌套表类型来保存它<code class="codeph">tasks_nttab</code> 。
                     </p>
                     <p>以下步骤（步骤1中的代码示例和其他程序）都需要将嵌套表<code class="codeph">tasks</code>作为属性添加到对象类型<code class="codeph">person_typ</code> ，该对象类型已包含在嵌套表<code class="codeph">people_typ</code> 。
                     </p>
                  </div>
                  <!-- class="section" -->
                  <ol>
                     <li class="stepexpand"><span>。</span><div>
                           <p><span class="bold">通过添加嵌套表属性来更改对象类型</span></p><pre class="oac_no_warn" dir="ltr">- 需要Ex。8-6 CREATE TYPE tasks_typ AS OBJECT（优先级VARCHAR2（2），描述VARCHAR2（30））; / CREATE TYPE tasks_nttab AS TABLE OF tasks_typ; /  - 将更改传播到employee_store_nt  - 为新嵌套表指定存储名称<span class="bold">ALTER TABLE</span> employee_store_nt <span class="bold">UPGRADE</span> NESTED TABLE任务<span class="bold">STORE AS</span> tasks_nt;</pre></div>
                     </li>
                     <li class="stepexpand"><span>使用<code class="codeph">CREATE OR REPLACE TYPE BODY</code>为<code class="codeph">person_typ</code>更新相应的型体使其成为当前新的类型定义， <span class="italic">如果需要的话</span> 。</span></li>
                     <li class="stepexpand"><span>将从属表升级到最新类型版本并转换表中的数据。这将验证表并允许再次访问数据。</span><div><pre class="oac_no_warn" dir="ltr">ALTER TABLE部门升级包括数据;</pre></div>
                     </li>
                     <li class="stepexpand"><span>根据需要更改相关的PL / SQL程序单元以考虑类型的更改。</span></li>
                     <li class="stepexpand"><span>使用Oracle Type Translator（OTT）为应用程序生成新的头文件，具体取决于应用程序是用C还是Java编写的。</span><div>
                           <p>向超类型添加新属性也会增加其所有子类型中的属性数量，因为这些属性会继承新属性。继承的属性总是在声明的（本地定义的）属性之前，因此向超类型添加新属性会导致任何子类型的所有声明属性的序号位置递归递增1。</p>
                           <p>您必须更新已更改类型的映射以包含新属性。使用Oracle Type Translator（OTT）执行此操作。如果使用其他工具，则必须确保类型标头与服务器中的类型定义正确同步;否则，可能会导致不可预测的行为。</p>
                        </div>
                     </li>
                     <li class="stepexpand"><span>根据需要修改应用程序代码并重建应用程序。</span></li>
                  </ol>
               </div>
            </div><a id="ADOBJ7404"></a><a id="ADOBJ7405"></a><a id="ADOBJ7406"></a><a id="ADOBJ7407"></a><a id="ADOBJ7661"></a><a id="ADOBJ7403"></a><div class="props_rev_3"><a id="GUID-0CFB36EF-6576-4FDB-9B66-294A8AFB3F9F" name="GUID-0CFB36EF-6576-4FDB-9B66-294A8AFB3F9F"></a><h3 id="ADOBJ-GUID-0CFB36EF-6576-4FDB-9B66-294A8AFB3F9F" class="sect3"><span class="enumeration_section">8.3.7</span>关于验证已更改的类型</h3>
               <div>
                  <p>当系统执行<code class="codeph">ALTER TYPE</code>语句时，它首先在语法和语义上验证所请求的类型更改，以确保它是合法的。
                  </p>
                  <p>系统执行与<code class="codeph">CREATE TYPE</code>语句相同的验证以及一些额外的验证。如果目标类型的新规范或其任何依赖类型未通过类型验证，则<code class="codeph">ALTER TYPE</code>语句将中止。没有创建新类型版本，并且所有依赖对象保持不变。
                  </p>
                  <p>如果存在依赖表，则进一步检查可确保遵守与表和索引相关的限制。例如，它确保被删除的属性不用作分区键。同样，如果<code class="codeph">ALTER TYPE</code>语句未通过检查与表相关的限制，则中止类型更改，并且不会创建该类型的新版本。
                  </p>
                  <p>当单个<code class="codeph">ALTER TYPE</code>语句添加多个属性时，它将按指定的顺序完成。可以在同一<code class="codeph">ALTER TYPE</code>语句中指定多个类型更改，但在语句中不能多次指定属性名称或方法签名。例如，不允许在单个语句中添加和修改相同的属性。
                  </p>
                  <p>以下部分包含有关类型更改的其他说明，包括：</p>
                  <ul style="list-style-type:disc">
                     <li>
                        <p><a href="type-evolution.html#GUID-0CFB36EF-6576-4FDB-9B66-294A8AFB3F9F__CHDJEFBB">删除属性</a></p>
                     </li>
                     <li>
                        <p><a href="type-evolution.html#GUID-0CFB36EF-6576-4FDB-9B66-294A8AFB3F9F__CHDDFCEG">修改属性类型的长度，精度或比例</a></p>
                     </li>
                     <li>
                        <p><a href="type-evolution.html#GUID-0CFB36EF-6576-4FDB-9B66-294A8AFB3F9F__CHDIAAEH">删除方法</a></p>
                     </li>
                     <li>
                        <p><a href="type-evolution.html#GUID-0CFB36EF-6576-4FDB-9B66-294A8AFB3F9F__CHDEEHAF">修改INSTANTIABLE属性</a></p>
                     </li>
                  </ul>
                  <div class="section" id="GUID-0CFB36EF-6576-4FDB-9B66-294A8AFB3F9F__CHDJEFBB">
                     <p class="subhead2" id="GUID-0CFB36EF-6576-4FDB-9B66-294A8AFB3F9F__GUID-74229697-2252-48AF-990F-12F08D00C4AD">删除属性</p>
                  </div>
                  <!-- class="section" -->
                  <div class="section">
                     <ul style="list-style-type:disc">
                        <li>
                           <p>不允许从根类型中删除所有属性。相反，您必须删除该类型。因为子类型从其超类型继承了所有属性，所以从子类型中删除所有属性不会将其属性计数减少到零;因此，允许删除在子类型中本地声明的所有属性。</p>
                        </li>
                        <li>
                           <p>只能删除目标类型中本地声明的属性。您不能从子类型中删除继承的属性。而是从属于本地声明的类型中删除该属性。</p>
                        </li>
                        <li>
                           <p>不允许删除属于表中的表分区或子分区键的属性。</p>
                        </li>
                        <li>
                           <p>删除属性时，将删除与已删除属性对应的列。</p>
                        </li>
                        <li>
                           <p>删除属性时，将删除引用它的任何索引，统计信息，约束和参照完整性约束。</p>
                        </li>
                     </ul>
                  </div>
                  <!-- class="section" -->
                  <div class="section" id="GUID-0CFB36EF-6576-4FDB-9B66-294A8AFB3F9F__CHDDFCEG">
                     <p class="subhead2" id="GUID-0CFB36EF-6576-4FDB-9B66-294A8AFB3F9F__GUID-EB17057C-8CCF-4B51-8A02-943CE9C6B66D">修改属性类型的长度，精度或比例</p>
                  </div>
                  <!-- class="section" -->
                  <div class="section">
                     <ul style="list-style-type:disc">
                        <li>
                           <p>不允许扩展依赖表上基于函数的索引，聚簇键或域索引中引用的属性的长度。</p>
                        </li>
                        <li>
                           <p>不允许减小属性的长度，精度或比例。</p>
                        </li>
                     </ul>
                  </div>
                  <!-- class="section" -->
                  <div class="section" id="GUID-0CFB36EF-6576-4FDB-9B66-294A8AFB3F9F__CHDIAAEH">
                     <p class="subhead2" id="GUID-0CFB36EF-6576-4FDB-9B66-294A8AFB3F9F__GUID-51C36373-36DD-487F-97DF-833E4A99062D">删除方法</p>
                  </div>
                  <!-- class="section" -->
                  <div class="section">
                     <ul style="list-style-type:disc">
                        <li>
                           <p>您只能从定义（或重新定义）方法的类型中删除方法：您不能从子类型中删除继承的方法，也不能从超类型中删除重新定义的方法。</p>
                        </li>
                        <li>
                           <p>如果未重新定义方法，则使用<code class="codeph">CASCADE</code>选项删除方法会从目标类型和所有子类型中删除该方法。但是，如果在子类型中重新定义方法，则<code class="codeph">CASCADE</code>将失败并回滚。要使<code class="codeph">CASCADE</code>成功，必须先从定义它的子类型中删除每个重新定义的方法，然后从超类型中删除该方法。
                           </p>
                           <p>您可以查阅<code class="codeph">USER_DEPENDENCIES</code>表以查找依赖于给定类型的所有模式对象，包括类型。您还可以运行<code class="codeph">DBMS_UTILITY.GET_DEPENDENCY</code>实用程序来查找类型的依赖项。
                           </p>
                        </li>
                        <li>
                           <p>您可以使用<code class="codeph">INVALIDATE</code>选项删除已重新定义的方法，但仍必须手动删除子类型中的重新定义的版本。子类型将保持无效状态，直到它们被明确更改为删除重新定义的版本。在此之前，尝试重新编译子类型以进行重新验证将产生错误<code class="codeph">Method does not override</code> 。
                           </p>
                           <p>与<code class="codeph">CASCADE</code>不同， <code class="codeph">INVALIDATE</code>绕过所有类型和表检查，并简单地使取决于类型的所有模式对象无效。下次访问对象时会重新验证对象。此选项比使用<code class="codeph">CASCADE</code>更快，但您必须确保在重新验证相关类型和表时不会出现问题。表无效时无法访问表数据;如果无法验证表，则其数据仍然无法访问。
                           </p>
                        </li>
                     </ul>
                  </div>
                  <!-- class="section" -->
                  <div class="section" id="GUID-0CFB36EF-6576-4FDB-9B66-294A8AFB3F9F__CHDEEHAF">
                     <p class="subhead2" id="GUID-0CFB36EF-6576-4FDB-9B66-294A8AFB3F9F__GUID-02FE925A-44E3-4B8A-BF84-9E9A888DDC23">修改INSTANTIABLE属性</p>
                  </div>
                  <!-- class="section" -->
                  <div class="section">
                     <ul style="list-style-type:disc">
                        <li>
                           <p>仅当类型没有表依赖项时，才允许将对象类型从<code class="codeph">INSTANTIABLE</code>更改为<code class="codeph">NOT INSTANTIABLE</code> 。
                           </p>
                        </li>
                        <li>
                           <p>可以随时将对象类型从<code class="codeph">NOT INSTANTIABLE</code>更改为<code class="codeph">INSTANTIABLE</code> 。此更改不会影响表。
                           </p>
                        </li>
                     </ul>
                  </div>
                  <!-- class="section" -->
                  <div class="section">
                     <p class="subhead2" id="GUID-0CFB36EF-6576-4FDB-9B66-294A8AFB3F9F__GUID-015958F2-E005-4DC7-BC39-C9DE060D7F3E">修改FINAL属性</p>
                  </div>
                  <!-- class="section" -->
                  <div class="section">
                     <ul style="list-style-type:disc">
                        <li>
                           <p>仅当目标类型没有子类型时，才允许将对象类型从<code class="codeph">NOT FINAL</code>更改为<code class="codeph">FINAL</code> 。
                           </p>
                        </li>
                        <li>
                           <p>将对象类型从<code class="codeph">FINAL</code>更改为<code class="codeph">NOT FINAL</code>或反之时，必须使用<code class="codeph">CASCADE</code>立即转换依赖列和表中的数据。您不能使用<code class="codeph">CASCADE</code>选项<code class="codeph">NOT INCLUDING TABLE DATA</code>来推迟转换数据。
                           </p>
                           <ul style="list-style-type:disc">
                              <li>
                                 <p>从<code class="codeph">NOT FINAL</code>到<code class="codeph">FINAL</code> ，您必须使用<code class="codeph">CASCADE INCLUDING TABLE DATA</code> 。</p>
                              </li>
                              <li>
                                 <p>从<code class="codeph">FINAL</code>到<code class="codeph">NOT FINAL</code> ，您可以使用<code class="codeph">CASCADE INCLUDING TABLE DATA</code>或<code class="codeph">CASCADE CONVERT TO SUBSTITUTABLE</code> 。</p>
                                 <p>将类型从<code class="codeph">FINAL</code>更改为<code class="codeph">NOT</code> <code class="codeph">FINAL</code> ，请根据是否要将更改类型的新子类型插入现有列和表中来选择<code class="codeph">CASCADE</code>选项。
                                 </p>
                              </li>
                           </ul>
                           <p>默认情况下，将类型从<code class="codeph">FINAL</code>更改为<code class="codeph">NOT</code> <code class="codeph">FINAL</code>使您可以创建该类型的新的可替换表和列，但它不会自动使该类型的现有列（或对象表）可替换。事实上，正好相反情况：现有列和类型的表是标有<code class="codeph">NOT SUBSTITUTABLE</code> <code class="codeph">AT</code> <code class="codeph">ALL</code> <code class="codeph">LEVELS</code> 。如果这些列的任何嵌入属性是可替换的，则会生成错误。更改类型的新子类型不能插入这些预先存在的列和表中。
                           </p>
                           <p>要将对象类型更改为<code class="codeph">NOT</code> <code class="codeph">FINAL</code> ，以使现有的类和可替换类型的表（假设它们未标记为<code class="codeph">NOT</code> <code class="codeph">SUBSTITUTABLE</code> ），请使用<code class="codeph">CASCADE</code>选项<code class="codeph">CONVERT TO SUBSTITUTABLE</code> 。</p>
                           <p>以下示例显示<code class="codeph">CASCADE</code>与<code class="codeph">CONVERT TO SUBSTITUTABLE</code>选项的使用：</p><pre class="oac_no_warn" dir="ltr">CREATE TYPE形状AS OBJECT（名称VARCHAR2（30），区域NUMBER）FINAL; / ALTER TYPE形状NOT FINAL CASCADE <span class="bold">CONVERT TO SUVERTITUTABLE</span> ;</pre><p>此<code class="codeph">CASCADE</code>选项将每个现有列标记为<code class="codeph">SUBSTITUTABLE AT ALL LEVELS</code>并为列中存储的实例的TypeId添加新的隐藏列。然后，该列可以存储更改类型的子类型实例。
                           </p>
                        </li>
                     </ul>
                  </div>
                  <!-- class="section" -->
               </div>
            </div><a id="ADOBJ7411"></a><a id="ADOBJ7410"></a><div class="props_rev_3"><a id="GUID-EBA7E55C-0D72-4CBA-908B-B4B7B55E306B" name="GUID-EBA7E55C-0D72-4CBA-908B-B4B7B55E306B"></a><h3 id="ADOBJ-GUID-EBA7E55C-0D72-4CBA-908B-B4B7B55E306B" class="sect3"><span class="enumeration_section">8.3.8</span>类型演变的ALTER TYPE语句</h3>
               <div>
                  <div class="section">
                     <p><a href="type-evolution.html#GUID-EBA7E55C-0D72-4CBA-908B-B4B7B55E306B__G1011839" title="ALTER TYPE语句中用于更改类型属性或方法的选项">表8-1</a>列出了<code class="codeph">ALTER</code> <code class="codeph">TYPE</code>和<code class="codeph">ALTER</code> <code class="codeph">TYPE</code>中的一些重要选项<code class="codeph">...用于更改类型的属性或方法定义的CASCADE</code>语句。
                     </p>
                  </div>
                  <!-- class="section" -->
                  <div class="tblformal" id="GUID-EBA7E55C-0D72-4CBA-908B-B4B7B55E306B__G1011839">
                     <p class="titleintable">表8-1类型Evolution的ALTER TYPE选项</p>
                     <table cellpadding="4" cellspacing="0" class="Formal" title="ALTER TYPE类型Evolution的选项" width="100%" border="1" summary="options in the ALTER TYPE statement for altering type attributes or methods" frame="hsides" rules="rows">
                        <thead>
                           <tr align="left" valign="top">
                              <th align="left" valign="bottom" width="29%" id="d29876e1218">选项</th>
                              <th align="left" valign="bottom" width="71%" id="d29876e1221">描述</th>
                           </tr>
                        </thead>
                        <tbody>
                           <tr align="left" valign="top">
                              <td align="left" valign="top" width="29%" id="d29876e1226" headers="d29876e1218 ">
                                 <p><code class="codeph">级联</code></p>
                              </td>
                              <td align="left" valign="top" width="71%" headers="d29876e1226 d29876e1221 ">
                                 <p>将类型更改传播到依赖类型和表。如果在依赖类型或表中发现错误，则语句将中止，除非指定了<code class="codeph">FORCE</code>选项。
                                 </p>
                                 <p>如果指定了<code class="codeph">CASCADE</code>而没有其他选项，则暗示<code class="codeph">CASCADE</code>的<code class="codeph">INCLUDING TABLE DATA</code>选项，并且数据库将所有表数据转换为最新类型版本。
                                 </p>
                              </td>
                           </tr>
                           <tr align="left" valign="top">
                              <td align="left" valign="top" width="29%" id="d29876e1248" headers="d29876e1218 ">
                                 <p><code class="codeph">INCLUDING TABLE DATA</code> （ <code class="codeph">CASCADE</code>选项）</p>
                              </td>
                              <td align="left" valign="top" width="71%" headers="d29876e1248 d29876e1221 ">
                                 <p>将存储在所有用户定义列中的数据转换为列类型的最新版本。</p>
                                 <p>对于添加到列类型的每个新属性，将新属性添加到数据并初始化为<code class="codeph">NULL</code> 。对于从引用类型中删除的每个属性，将从表中删除相应的属性数据。包含表数据的所有表空间必须处于读写模式;否则，声明不会成功。
                                 </p>
                              </td>
                           </tr>
                           <tr align="left" valign="top">
                              <td align="left" valign="top" width="29%" id="d29876e1265" headers="d29876e1218 ">
                                 <p><code class="codeph">NOT INCLUDING TABLE DATA</code> （ <code class="codeph">CASCADE</code>选项）</p>
                              </td>
                              <td align="left" valign="top" width="71%" headers="d29876e1265 d29876e1221 ">
                                 <p>保留列数据，不更改类型版本。如果从表引用的类型中删除属性，则不会从表中删除已删除属性的相应列。但是，列的元数据标记为未使用。如果已删除的属性存储在外部（例如， <code class="codeph">VARRAY</code> ， <code class="codeph">LOB</code>或嵌套表属性），则不会删除外部数据。（之后可以使用<code class="codeph">ALTER TABLE DROP UNUSED COLUMNS</code>语句删除未使用的列。）
                                 </p>
                                 <p>当您有许多大型表时，如果您在一个事务中将它们全部转换，则此选项可能会用完回滚段。此选项使您可以稍后在单独的事务中转换每个从属表的数据（使用<code class="codeph">ALTER TABLE UPGRADE INCLUDING DATA</code>语句）。
                                 </p>
                                 <p>指定此选项可加快表升级，因为表数据保持旧版本格式。但是，从该表中选择数据需要将存储在列中的图像转换为最新类型的版本。这可能会影响后续<code class="codeph">SELECT</code>语句中的性能。
                                 </p>
                                 <p>由于此选项仅需要更新表元数据，因此不要求所有表空间都在读/写模式下联机，以使语句成功。</p>
                              </td>
                           </tr>
                           <tr align="left" valign="top">
                              <td align="left" valign="top" width="29%" id="d29876e1298" headers="d29876e1218 ">
                                 <p><code class="codeph">FORCE</code> （ <code class="codeph">CASCADE</code>选项）</p>
                              </td>
                              <td align="left" valign="top" width="71%" headers="d29876e1298 d29876e1221 ">
                                 <p>强制系统忽略依赖表和索引的错误。错误记录在指定的异常表中，以便以后可以查询它们。请谨慎使用此选项，因为如果发生某些表错误，相关表可能无法访问。</p>
                              </td>
                           </tr>
                           <tr align="left" valign="top">
                              <td align="left" valign="top" width="29%" id="d29876e1310" headers="d29876e1218 ">
                                 <p><code class="codeph">CONVERT TO SUBSTITUTABLE</code> （ <code class="codeph">CASCADE</code>选项）</p>
                              </td>
                              <td align="left" valign="top" width="71%" headers="d29876e1310 d29876e1221 ">
                                 <p>在将类型从<code class="codeph">FINAL</code>更改为<code class="codeph">NOT</code> <code class="codeph">FINAL</code> ：将存储在所有用户定义列中的数据转换为列类型的最新版本，然后将这些现有列和对象表标记为<code class="codeph">SUBSTITUTABLE AT ALL LEVELS</code>以便它们可以存储任何新创建的类型的子类型。
                                 </p>
                                 <p>如果在未指定此选项的情况下将类型更改为<code class="codeph">NOT FINAL</code> ，则此类型的现有列和表将标记为“ <code class="codeph">NOT SUBSTITUTABLE AT ALL LEVELS</code> ，并且此类型的新子类型不能存储在其中。您只能将这些子类型存储在更改类型后创建的列和表中。
                                 </p>
                              </td>
                           </tr>
                        </tbody>
                     </table>
                  </div>
                  <!-- class="inftblhruleinformal" -->
                  <div class="section">
                     <div class="infoboxnotealso" id="GUID-EBA7E55C-0D72-4CBA-908B-B4B7B55E306B__GUID-4219A46E-2ED7-4F51-A062-4063842C7B42">
                        <p class="notep1">也可以看看：</p>
                        <p>有关<code class="codeph">ALTER</code> <code class="codeph">TYPE</code>选项的更多信息，请<a href="../sqlrf/ALTER-TYPE.html#SQLRF01102" target="_blank"><span><cite>参见Oracle数据库SQL语言参考</cite></span></a></p>
                     </div>
                  </div>
                  <!-- class="section" -->
               </div>
            </div><a id="ADOBJ7413"></a><div class="props_rev_3"><a id="GUID-A9527438-B790-4E35-A36F-3507F6C2A00A" name="GUID-A9527438-B790-4E35-A36F-3507F6C2A00A"></a><h3 id="ADOBJ-GUID-A9527438-B790-4E35-A36F-3507F6C2A00A" class="sect3"><span class="enumeration_section">8.3.9</span>类型Evolution的ALTER TABLE语句</h3>
               <div>
                  <div class="section">
                     <p>您可以使用<code class="codeph">ALTER</code> <code class="codeph">TABLE</code>将表数据转换为引用类型的最新版本。有关示例，请参阅<span class="q">“ <a href="type-evolution.html#GUID-B7C97F03-5476-4661-8113-CADDF5D1963D">通过添加嵌套表属性来更改类型</a> ”</span> 。
                     </p>
                     <div class="infoboxnotealso" id="GUID-A9527438-B790-4E35-A36F-3507F6C2A00A__GUID-C11C811B-A5E4-4989-9725-DBA3248C9BBF">
                        <p class="notep1">也可以看看：</p>
                        <ul style="list-style-type:disc">
                           <li>
                              <p><a href="type-evolution.html#GUID-EBA7E55C-0D72-4CBA-908B-B4B7B55E306B__G1011839" title="ALTER TYPE语句中用于更改类型属性或方法的选项">表8-1</a>讨论了<code class="codeph">INCLUDING</code> <code class="codeph">DATA</code>选项。
                              </p>
                           </li>
                           <li>
                              <p>有关<code class="codeph">ALTER</code> <code class="codeph">TABLE</code>选项的信息，请<a href="../sqlrf/SQL-Statements-ALTER-SYNONYM-to-COMMENT.html#SQLRF010" target="_blank"><span><cite>参见Oracle数据库SQL语言参考</cite></span></a></p>
                           </li>
                        </ul>
                     </div>
                  </div>
                  <!-- class="section" -->
               </div>
            </div>
         </div>
      </article>
   </body>
</html>