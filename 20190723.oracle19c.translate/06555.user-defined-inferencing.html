<html lang="en-us" dir="ltr" xml:lang="en-us">
   <head>
      <meta http-equiv="Content-Type" content="text/html; charset=utf-8"></meta>
      <meta name="viewport" content="width=device-width, initial-scale=1"></meta>
      <meta http-equiv="X-UA-Compatible" content="IE=edge"></meta>
      <meta name="abstract" content="RDF Semantic Graph extension architectures enable the addition of user-defined capabilities."></meta>
      <meta name="description" content="RDF Semantic Graph extension architectures enable the addition of user-defined capabilities."></meta>
      <title>用户定义的推理和查询</title>
      <meta property="og:site_name" content="Oracle Help Center"></meta>
      <meta property="og:title" content="RDF Knowledge Graph Developer&#39;s Guide "></meta>
      <meta property="og:description" content="RDF Semantic Graph extension architectures enable the addition of user-defined capabilities."></meta>
      <link rel="stylesheet" href="/sp_common/book-template/ohc-book-template/css/book.css"></link>
      <link rel="shortcut icon" href="/sp_common/book-template/ohc-common/img/favicon.ico"></link>
      <meta name="application-name" content="RDF Knowledge Graph Developer&#39;s Guide"></meta>
      <meta name="generator" content="DITA Open Toolkit version 1.8.5 (Mode = doc)"></meta>
      <meta name="plugin" content="SP_docbuilder HTML plugin release 18.2.2"></meta>
      <link rel="alternate" href="spatial-and-graph-rdf-knowledge-graph-developers-guide.pdf" title="PDF File" type="application/pdf"></link>
      <meta name="robots" content="all"></meta>
      <link rel="schema.dcterms" href="http://purl.org/dc/terms/"></link>
      <meta name="dcterms.created" content="2019-01-10T10:56:26-08:00"></meta>
      
      <meta name="dcterms.dateCopyrighted" content="2005, 2019"></meta>
      <meta name="dcterms.category" content="database"></meta>
      <meta name="dcterms.identifier" content="E94798-01"></meta>
      
      <meta name="dcterms.product" content="en/database/oracle/oracle-database/19"></meta>
      
      <link rel="prev" href="rdf-suipport-for-apache-jena.html" title="Previous" type="text/html"></link>
      <link rel="next" href="rdf-views.html" title="Next" type="text/html"></link>
      <script>
        document.write('<style type="text/css">');
        document.write('body > .noscript, body > .noscript ~ * { visibility: hidden; }');
        document.write('</style>');
     </script>
      <script src="/sp_common/book-template/requirejs/require.js" data-main="/sp_common/book-template/ohc-book-template/js/book-config"></script>
      <script>
            if (window.require === undefined) {
                document.write('<script data-main="sp_common/book-template/ohc-book-template/js/book-config" src="sp_common/book-template/requirejs/require.js"><\/script>');
                document.write('<link href="sp_common/book-template/ohc-book-template/css/book.css" rel="stylesheet"/>');
            }
        </script>
      <script type="application/json" id="ssot-metadata">{"primary":{"category":{"short_name":"database","element_name":"Database","display_in_url":true},"suite":{"short_name":"oracle","element_name":"Oracle","display_in_url":true},"product_group":{"short_name":"not-applicable","element_name":"Not applicable","display_in_url":false},"product":{"short_name":"oracle-database","element_name":"Oracle Database","display_in_url":true},"release":{"short_name":"19","element_name":"Release 19","display_in_url":true}}}</script>
      
    <meta name="dcterms.title" content="Spatial and Graph RDF Knowledge Graph Developer&#39;s Guide"></meta>
    <meta name="dcterms.isVersionOf" content="RDFRM"></meta>
    <meta name="dcterms.release" content="Release 19"></meta>
  </head>
   <body dir="ltr">
      <div class="noscript alert alert-danger text-center" role="alert">
         <a href="rdf-suipport-for-apache-jena.html" class="pull-left"><span class="glyphicon glyphicon-chevron-left" aria-hidden="true"></span>上一页</a> <a href="rdf-views.html" class="pull-right">下一页<span class="glyphicon glyphicon-chevron-right" aria-hidden="true"></span></a> <span class="fa fa-exclamation-triangle" aria-hidden="true"></span>必须启用JavaScript才能正确显示此内容</div>
      <article>
         <header>
            <ol class="breadcrumb" vocab="http://schema.org/" typeof="BreadcrumbList">
               <li property="itemListElement" typeof="ListItem"><a href="index.html" property="item" typeof="WebPage"><span property="name">RDF知识图开发人员指南</span></a></li>
               <li property="itemListElement" typeof="ListItem"><a href="part-concept-usage.html" property="item" typeof="WebPage"><span property="name">概念和使用信息</span></a></li>
               <li class="active" property="itemListElement" typeof="ListItem">用户定义的推理和查询</li>
            </ol>
            <a id="GUID-D5AADFCB-AE87-4028-A7A7-5927D7E9984E" name="GUID-D5AADFCB-AE87-4028-A7A7-5927D7E9984E"></a>
            
            <h2 id="RDFRM-GUID-D5AADFCB-AE87-4028-A7A7-5927D7E9984E" class="sect2"><span class="enumeration_chapter">7</span>用户定义的推理和查询</h2>
         </header>
         <div class="ind">
            <div>
               <p>RDF Semantic Graph扩展体系结构支持添加用户定义的功能。</p>
               <p>从Oracle Database 12 <span class="italic">c</span>第1版（12.1）开始有效：</p>
               <ul style="list-style-type:disc">
                  <li>
                     <p>推理扩展体系结构使您可以将用户定义的推理添加到预先提供的推理支持。</p>
                  </li>
                  <li>
                     <p>查询扩展体系结构使您能够通过SEM_MATCH表函数和Apache Jena支持添加要在SPARQL查询中使用的用户定义函数和聚合。</p>
                  </li>
               </ul>
               <div class="infoboxnote" id="GUID-D5AADFCB-AE87-4028-A7A7-5927D7E9984E__GUID-5AB07393-28D9-4C76-9E14-9468F960BAF9">
                  <p class="notep1">注意：</p>
                  <p>本章中介绍的功能适用于高级用户。假设您熟悉<a href="rdf-semantic-graph-overview.html#GUID-F422BB9F-8473-4980-9D6C-848F708C10E0" title="Oracle Spatial and Graph对语义技术的支持主要包括资源描述框架（RDF）和Web Ontology Language（OWL）的子集。这些功能称为Oracle Spatial and Graph的RDF知识图功能。">RDF语义图概述</a>和<a href="owl-concepts.html#GUID-3EC5F30E-9175-4B7B-946C-3117BC30610A" title="您应该了解与支持Web Ontology Language（OWL）子集相关的关键概念。">OWL概念中</a>描述的主要概念和技术。
                  </p>
               </div>
            </div>
            <div>
               <ul class="ullinks">
                  <li class="ulchildlink"><a href="user-defined-inferencing.html#GUID-C0D74403-EE99-4E4A-9C44-F1C2B84B01DC">用户定义的推理</a><br>RDF语义图推理扩展体系结构使您能够将用户定义的推理添加到预先提供的推理支持。
                  </li>
                  <li class="ulchildlink"><a href="user-defined-inferencing.html#GUID-26520C46-3A90-40AB-8403-140A82AC73CC">用户定义的函数和聚合</a><br>RDF语义图查询扩展体系结构使您能够通过SEM_MATCH表函数和Apache Jena支持添加要在SPARQL查询中使用的用户定义函数和聚合。
                  </li>
               </ul>
               <div class="familylinks">
                  <div class="parentlink">
                     <p><strong>父主题：</strong> <a href="part-concept-usage.html#GUID-FC153F2D-D51D-4498-A6E1-30B80D540FD6">概念和使用信息</a></p>
                  </div>
               </div>
            </div>
            <a id="RDFRM519"></a><a id="RDFRM520"></a><div class="props_rev_3"><a id="GUID-C0D74403-EE99-4E4A-9C44-F1C2B84B01DC" name="GUID-C0D74403-EE99-4E4A-9C44-F1C2B84B01DC"></a><h3 id="RDFRM-GUID-C0D74403-EE99-4E4A-9C44-F1C2B84B01DC" class="sect3"><span class="enumeration_section">7.1</span>用户定义的推理</h3>
               <div>
                  <p>RDF语义图推理扩展体系结构使您能够将用户定义的推理添加到预先提供的推理支持。</p>
               </div>
               <div>
                  <ul class="ullinks">
                     <li class="ulchildlink"><a href="user-defined-inferencing.html#GUID-2BB9DDF4-36A8-4790-9C80-80AD75A0DCE6">用户定义的推理提供的问题解决和好处</a><br></li>
                     <li class="ulchildlink"><a href="user-defined-inferencing.html#GUID-757AB3B4-9A08-49A0-9F9E-6658DC0B7698">用户定义的推理的API支持</a><br></li>
                     <li class="ulchildlink"><a href="user-defined-inferencing.html#GUID-E2FE95D9-C6A8-4E22-9CAA-85B558E153E2">用户定义的推理扩展函数示例</a><br></li>
                  </ul>
                  <div class="familylinks">
                     <div class="parentlink">
                        <p><strong>父主题：</strong> <a href="user-defined-inferencing.html#GUID-D5AADFCB-AE87-4028-A7A7-5927D7E9984E" title="RDF Semantic Graph扩展体系结构支持添加用户定义的功能。">用户定义的推理和查询</a></p>
                     </div>
                  </div>
               </div>
               <a id="RDFRM521"></a><div class="props_rev_3"><a id="GUID-2BB9DDF4-36A8-4790-9C80-80AD75A0DCE6" name="GUID-2BB9DDF4-36A8-4790-9C80-80AD75A0DCE6"></a><h4 id="RDFRM-GUID-2BB9DDF4-36A8-4790-9C80-80AD75A0DCE6" class="sect4"><span class="enumeration_section">7.1.1</span>用户定义的推理提供的问题和效益</h4>
                  <div>
                     <p>在Oracle Database 12 <span class="italic">c</span>第1版（12.1）之前，Oracle数据库推理引擎为OWL 2 RL，RDFS，SKOS，SNOMED（核心EL）和用户定义的规则提供了本机支持，这些规则涵盖了广泛的应用程序和要求。但是，有一个限制是，作为规则扣除过程的一部分，不能创建<span class="bold">新的RDF资源</span> 。
                     </p>
                     <p>作为Oracle Database 12 <span class="italic">c</span>第1版（12.1）之前的功能和限制的示例，请考虑以下简单的推理规则：</p><pre class="oac_no_warn" dir="ltr">？C rdfs：subClassOf？D.？x rdf：输入？C 。 ==&gt;？x rdf：输入？d</pre><p>前面的规则说子类<code class="codeph">C</code>任何实例<code class="codeph">x</code>都是<code class="codeph">C</code>的超类<code class="codeph">D</code>的实例。规则的后续部分提到了两个变量<code class="codeph">?x</code>和<code class="codeph">?D</code>但是，这些变量必须已经存在于规则的前提中，这进一步意味着这些RDF资源必须已经存在于知识库中。换句话说，例如，可以推导出<code class="codeph">John</code>是一个<code class="codeph">Student</code>只有当你知道<code class="codeph">John</code> <span class="italic">存在</span>的<code class="codeph">GraduateStudent</code> ，如果一个公理指定了<code class="codeph">GraduateStudent</code>类是的子类<code class="codeph">Student</code>类。
                     </p>
                     <p>另一个限制的例子是，在Oracle Database <span class="italic">12c</span> Release 1（12.1）之前，推理函数不支持组合一个人的名字和姓氏，以在推理过程中产生一个全名作为<span class="italic">新的</span> RDF资源。具体而言，此要求可以作为规则捕获，如下所示：</p><pre class="oac_no_warn" dir="ltr">？x：firstName？fn？x：lastName？ln ==&gt;？x：fullName连接（？fn？LN）</pre><p>从Oracle Database 12 <span class="italic">c</span>第1版（12.1）开始，RDF语义图推理扩展体系结构打开推理过程，以便用户可以实现自己的推理扩展功能并将它们集成到本机推理过程中。这种架构：</p>
                     <ul style="list-style-type:disc">
                        <li>
                           <p>支持需要生成新RDF资源的规则。</p>
                           <p>示例可能包括字符串或其他字符串操作，数学计算和Web服务标注的串联。</p>
                        </li>
                        <li>
                           <p>允许使用自定义优化实现某些现有规则。</p>
                           <p>尽管本机OWL推理引擎对许多规则进行了优化，并且这些规则对于各种大规模本体有效地工作，但对于一些新的未经测试的本体，特定推理组件的定制优化可以更好地工作。在这种情况下，您可以在<a href="SEM_APIS-reference.html#GUID-BF52CEC0-1BD9-4908-9EF1-F001B0527257">SEM_APIS.CREATE_ENTAILMENT</a>调用中禁用特定的推理组件，并指定实现新优化的自定义推理扩展函数（使用<code class="codeph">inf_ext_user_func_name</code>参数）。
                           </p>
                        </li>
                        <li>
                           <p>允许使用复杂的推理功能扩展推理引擎。</p>
                           <p>示例可能包括将地理空间推理，时间间隔推理和文本分析功能集成到本机数据库推理过程中。</p>
                        </li>
                     </ul>
                  </div>
                  <div>
                     <div class="familylinks">
                        <div class="parentlink">
                           <p><strong>父主题：</strong> <a href="user-defined-inferencing.html#GUID-C0D74403-EE99-4E4A-9C44-F1C2B84B01DC" title="RDF语义图推理扩展体系结构使您能够将用户定义的推理添加到预先提供的推理支持。">用户定义的推理</a></p>
                        </div>
                     </div>
                  </div>
                  
               </div><a id="RDFRM522"></a><div class="props_rev_3"><a id="GUID-757AB3B4-9A08-49A0-9F9E-6658DC0B7698" name="GUID-757AB3B4-9A08-49A0-9F9E-6658DC0B7698"></a><h4 id="RDFRM-GUID-757AB3B4-9A08-49A0-9F9E-6658DC0B7698" class="sect4"><span class="enumeration_section">7.1.2</span>用户定义推理的API支持</h4>
                  <div>
                     <p>用户定义的推理的主要应用程序编程接口（API）是<a href="SEM_APIS-reference.html#GUID-BF52CEC0-1BD9-4908-9EF1-F001B0527257">SEM_APIS.CREATE_ENTAILMENT</a>过程，特别是最后一个参数：</p><pre class="oac_no_warn" dir="ltr">inf_ext_user_func_name IN VARCHAR2 DEFAULT NULL</pre><p><code class="codeph">inf_ext_user_func_name</code>参数（如果已指定）标识一个或多个用户定义的推理函数，这些函数实现您要使用的专用逻辑。
                     </p>
                  </div>
                  <div>
                     <ul class="ullinks">
                        <li class="ulchildlink"><a href="user-defined-inferencing.html#GUID-48E4608D-B19C-4502-B67D-39C3174A610A">用户定义的推理功能要求</a><br></li>
                     </ul>
                     <div class="familylinks">
                        <div class="parentlink">
                           <p><strong>父主题：</strong> <a href="user-defined-inferencing.html#GUID-C0D74403-EE99-4E4A-9C44-F1C2B84B01DC" title="RDF语义图推理扩展体系结构使您能够将用户定义的推理添加到预先提供的推理支持。">用户定义的推理</a></p>
                        </div>
                     </div>
                  </div>
                  <a id="RDFRM523"></a><div class="props_rev_3"><a id="GUID-48E4608D-B19C-4502-B67D-39C3174A610A" name="GUID-48E4608D-B19C-4502-B67D-39C3174A610A"></a><h5 id="RDFRM-GUID-48E4608D-B19C-4502-B67D-39C3174A610A" class="sect5"><span class="enumeration_section">7.1.2.1</span>用户定义的推理功能要求</h5>
                     <div>
                        <p>在对<a href="SEM_APIS-reference.html#GUID-BF52CEC0-1BD9-4908-9EF1-F001B0527257">SEM_APIS.CREATE_ENTAILMENT</a>过程的调用中， <code class="codeph">inf_ext_user_func_name</code>参数中指定的每个用户定义的推理函数必须：</p>
                        <ul style="list-style-type:disc">
                           <li>
                              <p>具有以下字符串开头的名称： <code class="codeph">SEM_INF_</code></p>
                           </li>
                           <li>
                              <p>使用定义者的权利创建，而不是使用者的权利。（有关定义者权利和调用者权利的解释，请参阅<a href="../dbseg/managing-security-for-definers-rights-and-invokers-rights.html#DBSEG659" target="_blank"><span class="italic">Oracle数据库安全指南</span></a> 。）
                              </p>
                           </li>
                        </ul>
                        <p>对于名为<code class="codeph">SEM_INF_EXAMPLE</code>的假设函数，用户定义的推理函数的格式必须如以下示例所示：</p><pre class="oac_no_warn" dir="ltr">创建或替换函数sem_inf_example（varchar2中的src_tab_view，varchar2中的resource_id_map_view，varchar2中的output_tab，varchar2中的action，number中的num_calls，数量中的tplInferredLastRound，varchar2中的选项default null，optimization_flag out number，diag_message out varchar2）return boolean as pragma autonomous_transaction;开始if（action = SDO_SEM_INFERENCE.INF_EXT_ACTION_START）然后<span class="italic">&lt;...准备工作...&gt;</span>结束if; if（action = SDO_SEM_INFERENCE.INF_EXT_ACTION_RUN）然后<span class="italic">&lt;...实际推理逻辑...&gt;</span> commit;万一; if（action = SDO_SEM_INFERENCE.INF_EXT_ACTION_END）然后<span class="italic">&lt;...清理...&gt;</span>结束if;返回true; - 成功结束; / grant在sem_inf_example上执行到MDSYS;</pre><p>在用户定义的函数格式中， <code class="codeph">optimization_flag</code>输出参数可以指定与数值相关联的一个或多个Oracle定义的名称。您可以指定以下一项或多项：</p>
                        <ul style="list-style-type:disc">
                           <li>
                              <p><code class="codeph">SDO_SEM_INFERENCE.INF_EXT_OPT_FLAG_NONE</code>表示推理引擎不应启用扩展功能的任何优化。（这是未设置<code class="codeph">optimization_flag</code>参数时推理引擎的默认行为。）
                              </p>
                           </li>
                           <li>
                              <p><code class="codeph">SDO_SEM_INFERENCE.INF_EXT_OPT_FLAG_ALL_IDS</code>表示扩展功能推断的所有三元组/四元组仅使用资源ID。换句话说， <code class="codeph">output_tab</code>表仅包含资源ID（列<code class="codeph">gid</code> ， <code class="codeph">sid</code> ， <code class="codeph">pid</code>和<code class="codeph">oid</code> ），并且不包含任何词法值（列<code class="codeph">g</code> ， <code class="codeph">s</code> ， <code class="codeph">p</code>和<code class="codeph">o</code>都为null）。启用此优化标志允许推理引擎跳过资源ID查找。
                              </p>
                           </li>
                           <li>
                              <p><code class="codeph">SDO_SEM_INFERENCE.INF_EXT_OPT_FLAG_NEWDATA_ONLY</code>表示扩展函数推断出的所有三元组/四元组都是新的，并且在<code class="codeph">src_tab_view</code>不存在。启用此优化标志允许推理引擎跳过检查<code class="codeph">output_tab</code>表和<code class="codeph">src_tab_view</code>之间的重复<code class="codeph">src_tab_view</code> 。请注意， <code class="codeph">src_tab_view</code>包含前几轮推理的三元组/四元组，包括从扩展函数推断的三元组/四元组。
                              </p>
                           </li>
                           <li>
                              <p><code class="codeph">SDO_SEM_INFERENCE.INF_EXT_OPT_FLAG_UNIQDATA_ONLY</code>表示扩展函数推断出的所有三元组/四元组都是唯一的，并且在<code class="codeph">output_tab</code>表中不存在。启用此优化标志允许推理引擎跳过检查<code class="codeph">output_tab</code>表中的重复项（例如，无需检查扩展函数两次推断的相同三次）。请注意，对于扩展函数， <code class="codeph">output_tab</code>表在每轮推理开始时都是空的，因此数据的唯一性必须仅适用于当前轮次的推理。
                              </p>
                           </li>
                           <li>
                              <p><code class="codeph">SDO_SEM_INFERENCE.INF_EXT_OPT_FLAG_IGNORE_NULL</code>指示如果主题，谓词或对象资源为空，则推理引擎应忽略推断的三元组或四元组。如果<code class="codeph">output_tab</code>表中的两个列都为null，则推理引擎<code class="codeph">output_tab</code>资源视为null（例如，如果<code class="codeph">s</code>和<code class="codeph">sid</code>列都为null，则subject为null）。启用此优化标志允许推理引擎跳过<code class="codeph">output_tab</code>表中的无效三元组/四元组。请注意，推理引擎将空图列（ <code class="codeph">g</code>和<code class="codeph">gid</code> ）解释为默认图。
                              </p>
                           </li>
                        </ul>
                        <p>要为<code class="codeph">optimization_flag</code>输出参数指定多个值，请使用加号（ <code class="codeph">+</code> ）来连接值。例如：</p><pre class="oac_no_warn" dir="ltr">optimization_flag：= SDO_SEM_INFERENCE.INF_EXT_OPT_FLAG_ALL_IDS + SDO_SEM_INFERENCE.INF_EXT_OPT_FLAG_NEWDATA_ONLY + SDO_SEM_INFERENCE.INF_EXT_OPT_FLAG_UNIQDATA_ONLY;</pre><p>有关使用<code class="codeph">optimization_flag</code>输出参数的更多信息，请参阅<a href="user-defined-inferencing.html#GUID-9130DB03-063F-4ECA-BC72-F841816D03A2">示例3：优化性能</a> 。
                        </p>
                     </div>
                     <div>
                        <div class="familylinks">
                           <div class="parentlink">
                              <p><strong>父主题：</strong> <a href="user-defined-inferencing.html#GUID-757AB3B4-9A08-49A0-9F9E-6658DC0B7698">用户定义的推理的API支持</a></p>
                           </div>
                        </div>
                     </div>
                     
                  </div>
               </div><a id="RDFRM524"></a><div class="props_rev_3"><a id="GUID-E2FE95D9-C6A8-4E22-9CAA-85B558E153E2" name="GUID-E2FE95D9-C6A8-4E22-9CAA-85B558E153E2"></a><h4 id="RDFRM-GUID-E2FE95D9-C6A8-4E22-9CAA-85B558E153E2" class="sect4"><span class="enumeration_section">7.1.3</span>用户定义的推理扩展函数示例</h4>
                  <div>
                     <p>以下示例演示了如何使用用户定义的推理扩展函数来创建蕴涵。</p>
                     <ul style="list-style-type:disc">
                        <li>
                           <p><a href="user-defined-inferencing.html#GUID-1415A86A-5A77-4270-A8E2-F7C877A139D6">示例1：添加静态三元组</a> ， <a href="user-defined-inferencing.html#GUID-CE4D14D6-3C48-47EA-92BB-CEC870316412">示例2：添加动态三元组</a> ，以及<a href="user-defined-inferencing.html#GUID-9130DB03-063F-4ECA-BC72-F841816D03A2">示例3：优化性能</a>涵盖了用户定义的推理扩展的基础知识。
                           </p>
                           <p><a href="user-defined-inferencing.html#GUID-1415A86A-5A77-4270-A8E2-F7C877A139D6">示例1：添加静态</a>三元组和<a href="user-defined-inferencing.html#GUID-CE4D14D6-3C48-47EA-92BB-CEC870316412">示例2：添加动态</a>三元组专注于添加新的推断三元组。
                           </p>
                           <p><a href="user-defined-inferencing.html#GUID-9130DB03-063F-4ECA-BC72-F841816D03A2">示例3：优化性能</a>侧重于优化性能。
                           </p>
                        </li>
                        <li>
                           <p><a href="user-defined-inferencing.html#GUID-71E6C43C-4329-49AA-A3B2-A158C0176ADF">示例4：时间推理（几个相关示例）</a>和<a href="user-defined-inferencing.html#GUID-44EBDF64-6718-4960-98EB-0D2C45F677A3">示例5：空间推理</a>演示了如何通过利用本机Oracle类型和运算符来有效地处理特殊数据类型。
                           </p>
                           <p><a href="user-defined-inferencing.html#GUID-71E6C43C-4329-49AA-A3B2-A158C0176ADF">示例4：时间推理（几个相关示例）</a>侧重于<code class="codeph">xsd:dateTime</code>数据类型。
                           </p>
                           <p><a href="user-defined-inferencing.html#GUID-44EBDF64-6718-4960-98EB-0D2C45F677A3">示例5：空间推理</a>侧重于地理空间数据类型。
                           </p>
                        </li>
                        <li>
                           <p><a href="user-defined-inferencing.html#GUID-537C3916-D0F0-4909-BC05-50353621C220">示例6：调用Web Service</a>会对Oracle Geocoder服务进行Web服务调用。
                           </p>
                        </li>
                     </ul>
                     <p>前三个示例假设模型<code class="codeph">EMPLOYEES</code>存在并包含以Tringe格式显示的以下语义数据：</p><pre class="oac_no_warn" dir="ltr">：John：firstName“John”; ：lastName“史密斯”。：玛丽：firstName“玛丽”; ：lastName“史密斯”; ：名字“玛丽史密斯”。：Alice：firstName“Alice”。：Bob：firstName“Bob”; ：lastName“Billow”。
</pre><p>有关创建用户定义的推理扩展函数的要求和指南，请参阅<a href="user-defined-inferencing.html#GUID-757AB3B4-9A08-49A0-9F9E-6658DC0B7698">用户定义的推理的API支持</a> 。
                     </p>
                  </div>
                  <div>
                     <ul class="ullinks">
                        <li class="ulchildlink"><a href="user-defined-inferencing.html#GUID-1415A86A-5A77-4270-A8E2-F7C877A139D6">示例1：添加静态三元组</a><br></li>
                        <li class="ulchildlink"><a href="user-defined-inferencing.html#GUID-CE4D14D6-3C48-47EA-92BB-CEC870316412">示例2：添加动态三元组</a><br></li>
                        <li class="ulchildlink"><a href="user-defined-inferencing.html#GUID-9130DB03-063F-4ECA-BC72-F841816D03A2">示例3：优化性能</a><br></li>
                        <li class="ulchildlink"><a href="user-defined-inferencing.html#GUID-71E6C43C-4329-49AA-A3B2-A158C0176ADF">例4：时间推理（几个相关例子）</a><br></li>
                        <li class="ulchildlink"><a href="user-defined-inferencing.html#GUID-44EBDF64-6718-4960-98EB-0D2C45F677A3">示例5：空间推理</a><br></li>
                        <li class="ulchildlink"><a href="user-defined-inferencing.html#GUID-537C3916-D0F0-4909-BC05-50353621C220">示例6：调用Web服务</a><br></li>
                     </ul>
                     <div class="familylinks">
                        <div class="parentlink">
                           <p><strong>父主题：</strong> <a href="user-defined-inferencing.html#GUID-C0D74403-EE99-4E4A-9C44-F1C2B84B01DC" title="RDF语义图推理扩展体系结构使您能够将用户定义的推理添加到预先提供的推理支持。">用户定义的推理</a></p>
                        </div>
                     </div>
                  </div>
                  <a id="RDFRM525"></a><div class="props_rev_3"><a id="GUID-1415A86A-5A77-4270-A8E2-F7C877A139D6" name="GUID-1415A86A-5A77-4270-A8E2-F7C877A139D6"></a><h5 id="RDFRM-GUID-1415A86A-5A77-4270-A8E2-F7C877A139D6" class="sect5"><span class="enumeration_section">7.1.3.1</span>示例1：添加静态<span class="enumeration_section">三元</span>组</h5>
                     <div>
                        <p>在用户定义的推理扩展函数中推断新数据的最基本方法是添加静态数据。静态数据不依赖于模型中的任何现有数据。这不是用户定义的推理扩展函数的常见情况，但它演示了将三元组添加到蕴涵中的基础知识。在准备阶段（即<code class="codeph">action='START'</code> ）更常见地插入静态数据以扩展现有本体。
                        </p>
                        <p>以下用户定义的推理扩展函数（ <code class="codeph">sem_inf_static</code> ）将三个静态三元组添加到一个蕴涵中：</p><pre class="oac_no_warn" dir="ltr">- 此用户定义的规则添加静态三元组创建或替换函数sem_inf_static（varchar2中的src_tab_view，varchar2中的resource_id_map_view，varchar2中的output_tab，varchar2中的action，number中的num_calls，数量中的tplInferredLastRound，varchar2中的选项default null，optimization_flag out number， diag_message out varchar2）return boolean as query varchar2（4000）; pragma autonomous_transaction; begin if（action ='RUN'）then  - 我们用来插入三元组查询的通用查询：='insert / * + parallel append * / into'|| output_tab || '（s，p，o）VALUES'|| '（：1，：2，：3）'; - 使用'&lt;http://example.org/S1&gt;'，'&lt;http://example.org/P2&gt;'，'“O1”'执行具有不同值的查询执行立即查询;使用'&lt;http://example.org/S2&gt;'，'&lt;http://example.org/P2&gt;'，'“2”^^ xsd：int'执行立即查询 - 使用'&lt;http://example.org/S2&gt;'，'&lt;http://example.org/P2&gt;'，'“2”^^ xsd：int'复制quad执行立即查询;使用'&lt;http://example.org/S3&gt;'，'&lt;http://example.org/P3&gt;'，'“3.0”^^ xsd：double'执行立即查询 - 提交我们的更改提交;万一; - 返回true表示成功返回true;结束sem_inf_static; /显示错误;</pre><p><code class="codeph">sem_inf_static</code>函数通过执行SQL插入查询来插入新数据，其中<code class="codeph">output_tab</code>作为插入的目标表。<code class="codeph">output_tab</code>表将仅包含当前调用期间<code class="codeph">sem_inf_static</code>函数添加的三元组（请参阅<code class="codeph">num_calls</code>参数）。推理引擎将始终至少调用用户定义的推理扩展函数三次，对于动作参数的每个可能值（ <code class="codeph">'START'</code> ， <code class="codeph">'RUN</code> <code class="codeph">'</code>和<code class="codeph">'END'</code> ）一次。由于<code class="codeph">sem_inf_static</code>不需要执行任何准备或清理，因此该功能仅在<code class="codeph">RUN</code>阶段添加数据。在<code class="codeph">RUN</code>阶段，可以多次调用扩展函数，具体取决于当前推理期间推断的数据。
                        </p>
                        <p>虽然<code class="codeph">sem_inf_static</code>函数不检查现有的三元组（以防止重复的三元组），但推理引擎不会在生成的蕴涵中生成重复的三元组。推理引擎将从<code class="codeph">output_tab</code>表（扩展函数插入的数据）和最终蕴涵（模型或模型和其他推断数据）中过滤掉重复项。设置适当的优化标志（使用<code class="codeph">optimization_flag</code>参数）将禁用此便捷功能并提高性能。（有关优化标志的更多信息，请参阅<a href="user-defined-inferencing.html#GUID-9130DB03-063F-4ECA-BC72-F841816D03A2">示例3：优化性能</a> 。）
                        </p>
                        <p>尽管<code class="codeph">output_tab</code>的表定义显示了图名的列，但在执行全局推理（ <a href="SEM_APIS-reference.html#GUID-BF52CEC0-1BD9-4908-9EF1-F001B0527257">SEM_APIS.CREATE_ENTAILMENT的</a>默认行为）和命名图全局推断（NGGI）时，推理引擎将忽略并覆盖由扩展函数添加的三元组上的所有图名。要在用户定义的扩展函数中为特定命名图添加三元组，请使用NGLI（命名图本地推理）。在NGLI期间，所有三元组必须属于命名图形（即， <code class="codeph">output_tab</code>的<code class="codeph">gid</code>和<code class="codeph">g</code>列不能都为null）。
                        </p>
                        <p>MDSYS用户必须对<code class="codeph">sem_inf_static</code>函数具有执行权限才能使用该函数进行推理。以下示例显示如何在<code class="codeph">sem_inf_static</code>函数上授予适当的权限，并使用该函数创建一个entails（以及OWLPRIME推理逻辑）：</p><pre class="oac_no_warn" dir="ltr">- 授予适当的权限授予sem_inf_static执行到mdsys; - 创建蕴涵开始sem_apis.create_entailment（'EMPLOYEES_INF'，sem_models（'EMPLOYEES'），sem_rulebases（'OWLPRIME'），传递=&gt; SEM_APIS.REACH_CLOSURE，inf_ext_user_func_name =&gt;'sem_inf_static'）;结束; /</pre><p>以下示例显示新包含的数据：</p><pre class="oac_no_warn" dir="ltr">- 格式化列格式a23;列p格式a23;列o格式a23;设置lineize 100; - 显示结果从表中选择s，p，o（SEM_MATCH（'选择？s？p？o哪里{？s？p？o}订购？s？p？o'，sem_models（'EMPLOYEES'），sem_rulebases（'OWLPRIME'），null，null，null，'INF_ONLY = T'））;</pre><p>前面的查询返回<code class="codeph">sem_inf_static</code>添加的三个唯一静态三元组，没有重复：</p><pre class="oac_no_warn" dir="ltr">SPO ---------------------- ---------------------- ----- ------------------ http://example.org/S1 http://example.org/P2 O1 http://example.org/S2 http：// example.org/P2 2 http://example.org/S3 http://example.org/P3 3E0</pre></div>
                     <div>
                        <div class="familylinks">
                           <div class="parentlink">
                              <p><strong>父主题：</strong> <a href="user-defined-inferencing.html#GUID-E2FE95D9-C6A8-4E22-9CAA-85B558E153E2">用户定义的推理扩展函数示例</a></p>
                           </div>
                        </div>
                     </div>
                     
                  </div><a id="RDFRM526"></a><div class="props_rev_3"><a id="GUID-CE4D14D6-3C48-47EA-92BB-CEC870316412" name="GUID-CE4D14D6-3C48-47EA-92BB-CEC870316412"></a><h5 id="RDFRM-GUID-CE4D14D6-3C48-47EA-92BB-CEC870316412" class="sect5"><span class="enumeration_section">7.1.3.2</span>示例2：添加动态三元组</h5>
                     <div>
                        <p>添加静态数据很有用，但通常在准备阶段（即<code class="codeph">action='START'</code> ）阶段完成。添加<span class="italic">动态</span>数据涉及查看模型中的现有数据并基于现有数据生成新数据。这是用户定义的推理扩展函数的最常见情况。
                        </p>
                        <p>以下用户定义的推理扩展功能（ <code class="codeph">sem_inf_dynamic</code> ）连接员工的名字和姓氏，以创建表示全名的新三元组。
                        </p><pre class="oac_no_warn" dir="ltr">- 此用户定义的规则添加静态三元组创建或替换函数sem_inf_dynamic（varchar2中的src_tab_view，varchar2中的resource_id_map_view，varchar2中的output_tab，varchar2中的action，number中的num_calls，数量中的tplInferredLastRound，varchar2中的选项default null，optimization_flag out number， diag_message out varchar2）将boolean返回为firstNamePropertyId数; lastNamePropertyId数字; fullNamePropertyId数字; sqlStmt varchar2（4000）; insertStmt varchar2（4000）; pragma autonomous_transaction; begin if（action ='RUN'）then  - 检索数据中已经存在的资源ID（如果资源不存在则抛出异常）。这些将改善我们的SQL查询的性能。firstNamePropertyId：= sdo_sem_inference.oracle_orardf_res2vid（'http://example.org/firstName'）; lastNamePropertyId：= sdo_sem_inference.oracle_orardf_res2vid（'http://example.org/lastName'）; fullNamePropertyId：= sdo_sem_inference.oracle_orardf_res2vid（'http://example.org/name'）; - 用于查找所有员工及其名字和姓氏的SQL查询sqlStmt：='select ids1.sid employeeId，values1.value_name firstName，values2.value_name lastName from'|| resource_id_map_view || 'values1，'|| resource_id_map_view || 'values2，'|| src_tab_view || 'ids1，'|| src_tab_view || 'ids2其中ids1.sid = ids2.sid AND ids1.pid ='|| to_char（firstNamePropertyId，'TM9'）|| 'AND ids2.pid ='|| to_char（lastNamePropertyId，'TM9'）|| 'AND ids1.oid = values1.value_id AND ids2.oid = values2.value_id / *下面确保我们有NEWDATA（没有重复的优化标志）* / AND不存在（从'|| src_tab_view ||'中选择1其中sid = ids1.sid AND pid ='|| to_char（fullNamePropertyId，'TM9'）||'）'; - 创建insert语句，将我们的sqlStmt中的名字和姓氏连接成一个新的三元组。insertStmt：='insert / * + parallel append * / into'|| output_tab || '（sid，pid，o）选择employeeId，'|| to_char（fullNamePropertyId，'TM9'）|| '，'''''|| firstName ||''''|| lastName ||'''''from（'|| sqlStmt ||'）'; - 执行insert语句execute immediate insertStmt; - 提交我们的更改提交; - 设置我们已经检查过的优化标志 - 模型中的重复项（src_tab_view）optimization_flag：= SDO_SEM_INFERENCE.INF_EXT_OPT_FLAG_NEWDATA_ONLY;万一; - 返回true表示成功返回true;结束sem_inf_dynamic; /显示错误;</pre><p><code class="codeph">sem_inf_dynamic</code>函数使用两个主要步骤插入新数据。首先，该函数构建一个SQL查询，该查询从现有数据中收集所有名字和姓氏。<code class="codeph">sqlStmt</code>变量存储此SQL查询。接下来，该函数根据收集的名字和姓氏插入新的三元组，以形成每个员工的全名。<code class="codeph">insertStmt</code>变量存储此SQL查询。请注意， <code class="codeph">insertStmt</code>查询包含<code class="codeph">sqlStmt</code>查询，因为它正在使用子查询执行INSERT。
                        </p>
                        <p><code class="codeph">sqlStmt</code>查询跨两个主视图执行连接：资源视图（ <code class="codeph">resource_id_map_view</code> ）和现有数据视图（ <code class="codeph">src_tab_view</code> ）。现有数据视图包含所有现有三元组，但使用数字ID而不是词法值存储这些三元组的值。由于<code class="codeph">sqlStmt</code>查询必须提取员工名字和姓氏的词汇值，因此它会与资源视图连接两次（一次用于名字，一次用于姓氏）。
                        </p>
                        <p><code class="codeph">sqlStmt</code>查询包含<code class="codeph">PARALLEL</code> SQL提示以帮助提高性能。在平衡硬件配置上并行执行可以显着提高性能。（有关详细信息，请参阅<a href="user-defined-inferencing.html#GUID-9130DB03-063F-4ECA-BC72-F841816D03A2">示例3：优化性能</a> 。）
                        </p>
                        <p><code class="codeph">insertStmt</code>查询还执行重复检查，以避免在现有数据视图（ <code class="codeph">src_tab_view</code> ）中已存在三元组时添加三元组。该函数表示已通过启用<code class="codeph">INF_EXT_OPT_FLAG_NEWDATA_ONLY</code>优化标志执行此检查。在扩展功能内部进行检查可以提高推理的整体性能。请注意，现有数据视图不包含<code class="codeph">sem_inf_dynamic</code>函数当前添加的新三元组，因此在<code class="codeph">output_tab</code>表中可能仍存在重复项。如果<code class="codeph">sem_inf_dynamic</code>函数另外在output_tab表中检查了重复项，那么它还可以启用<code class="codeph">INF_EXT_OPT_FLAG_UNIQUEDATA_ONLY</code>优化标志。
                        </p>
                        <p>两个SQL查询都使用RDF资源的数字ID来执行其连接和插入。使用ID而不是词汇值可以提高查询的性能。<code class="codeph">sem_inf_dynamic</code>函数通过查找计划使用的词法值的ID来利用此性能优势。在这种情况下，该函数会查找三个表示名字，姓氏和全名属性的URI。如果<code class="codeph">sem_inf_dynamic</code>函数将所有新三元组纯粹作为ID插入，则它可以启用<code class="codeph">INF_EXT_OPT_FLAG_ALL_IDS</code>优化标志。但是，对于此示例，新三元组每个都包含一个新的词汇值：员工的全名。
                        </p>
                        <p>要使用<code class="codeph">sem_inf_dynamic</code>函数创建一个蕴涵，请向MDSYS用户授予执行权限，然后将函数名称传递给<a href="SEM_APIS-reference.html#GUID-BF52CEC0-1BD9-4908-9EF1-F001B0527257">SEM_APIS.CREATE_ENTAILMENT</a>过程，如下所示：</p><pre class="oac_no_warn" dir="ltr">- 授予适当的权限授予sem_inf_dynamic执行到mdsys; - 创建蕴涵开始sem_apis.create_entailment（'EMPLOYEES_INF'，sem_models（'EMPLOYEES'），sem_rulebases（'OWLPRIME'），传递=&gt; SEM_APIS.REACH_CLOSURE，inf_ext_user_func_name =&gt;'sem_inf_dynamic'）;结束; /</pre><p>该蕴涵应包含<code class="codeph">sem_inf_dynamic</code>添加的以下两个新三元组：</p><pre class="oac_no_warn" dir="ltr">SPO ------------------------ ------------------------  - ---------------------- http://example.org/Bob http://example.org/name Bob Billow http://example.org/ John http://example.org/name John Smith</pre><p>请注意，前面示例中的<code class="codeph">sem_inf_dynamic</code>函数未推断Mary Smith的全名，因为Mary Smith已在现有数据中指定了其全名。
                        </p>
                     </div>
                     <div>
                        <div class="familylinks">
                           <div class="parentlink">
                              <p><strong>父主题：</strong> <a href="user-defined-inferencing.html#GUID-E2FE95D9-C6A8-4E22-9CAA-85B558E153E2">用户定义的推理扩展函数示例</a></p>
                           </div>
                        </div>
                     </div>
                     
                  </div><a id="RDFRM527"></a><div class="props_rev_3"><a id="GUID-9130DB03-063F-4ECA-BC72-F841816D03A2" name="GUID-9130DB03-063F-4ECA-BC72-F841816D03A2"></a><h5 id="RDFRM-GUID-9130DB03-063F-4ECA-BC72-F841816D03A2" class="sect5"><span class="enumeration_section">7.1.3.3</span>示例3：优化性能</h5>
                     <div>
                        <p>几种技术可以改善推理扩展功能的性能。一种这样的技术是在查询中使用资源的数字ID而不是它们的词汇值。通过仅使用资源ID，扩展函数避免了必须与资源视图（ <code class="codeph">resource_id_map_view</code> ）连接，这可以极大地提高查询性能。推理扩展功能可以通过使用同样的资源ID添加新的三元组的时候获得额外的性能优势<code class="codeph">output_tab</code>表（即，只用使用<code class="codeph">gid</code> ， <code class="codeph">sid</code> ， <code class="codeph">pid</code> ，和<code class="codeph">oid</code>的列<code class="codeph">output_tab</code>表）。
                        </p>
                        <p>以下用户定义的推理扩展函数（ <code class="codeph">sem_inf_related</code> ）为共享相同姓氏的员工推断出新属性<code class="codeph">:possibleRelative</code> 。用于查找此类员工的SQL查询仅使用资源ID（没有词法值，没有与资源视图的连接）。此外，此示例中的推理扩展功能仅使用资源ID插入新三元组，允许该函数启用<code class="codeph">INF_EXT_OPT_FLAG_ALL_IDS</code>优化标志。
                        </p><pre class="oac_no_warn" dir="ltr">- 此用户定义的规则添加静态三元组创建或替换函数sem_inf_related（varchar2中的src_tab_view，varchar2中的resource_id_map_view，varchar2中的output_tab，varchar2中的action，number中的num_calls，数量中的tplInferredLastRound，varchar2中的选项default null，optimization_flag out number， diag_message out varchar2）将boolean返回为lastNamePropertyId数; relatedPropertyId号码; sqlStmt varchar2（4000）; insertStmt varchar2（4000）; pragma autonomous_transaction; begin if（action ='RUN'）then  - 检索数据中已经存在的资源ID（如果资源不存在则抛出异常）。lastNamePropertyId：= sdo_sem_inference.oracle_orardf_res2vid（'http://example.org/lastName'）; - 资源的检索ID或生成新ID（如果资源不存在） - 尚不存在relatedPropertyId：= sdo_sem_inference.oracle_orardf_add_res（'http://example.org/possibleRelative'）; -  SQL查询以查找共享姓氏的所有员工sqlStmt：='select ids1.sid employeeId，ids2.sid relativeId from'|| src_tab_view || 'ids1，'|| src_tab_view || 'ids2其中ids1.pid ='|| to_char（lastNamePropertyId，'TM9'）|| 'AND ids2.pid ='|| to_char（lastNamePropertyId，'TM9'）|| 'AND ids1.oid = ids2.oid / *避免与自己相关的员工* / AND ids1.sid！= ids2.sid / *下面确保我们有NEWDATA（没有重复的优化标志）* / AND不存在（从'|| src_tab_view ||'中选择1，其中sid = ids1.sid AND pid ='|| to_char（relatedPropertyId， 'TM9'）||'和oid = ids2.sid）/ *下面确保我们有UNIQDATA（没有重复的优化标志）* / AND不存在（从'|| output_tab ||'中选择1，其中sid = ids1.sid AND pid ='|| to_char（relatedPropertyId，'TM9'）||'AND oid = ids2.sid）'; - 创建仅使用资源ID的insert语句insertStmt：='insert / * + parallel append * / into'|| output_tab || '（sid，pid，oid）选择employeeId，'|| to_char（relatedPropertyId，'TM9'）|| '，relativeId from（'|| sqlStmt ||'）'; - 执行insert语句execute immediate insertStmt; - 提交我们的更改提交; - 设置标志指示我们的新三元组 -  1）仅使用ID指定 -  2）与模型不产生重复（src_tab_view） -  3）在输出中不产生重复（output_tab）optimization_flag：= SDO_SEM_INFERENCE.INF_EXT_OPT_FLAG_ALL_IDS + SDO_SEM_INFERENCE.INF_EXT_OPT_FLAG_NEWDATA_ONLY + SDO_SEM_INFERENCE.INF_EXT_OPT_FLAG_UNIQDATA_ONLY;万一; - 返回true表示成功返回true;结束sem_inf_related; /显示错误;</pre><p><code class="codeph">sem_inf_related</code>函数与前面的示例有一些关键差异。首先， <code class="codeph">sem_inf_related</code>函数仅使用资源ID查询，并仅使用资源ID插入新的三元组。由于<code class="codeph">output_tab</code>表中所有添加的三元组仅使用资源ID，因此该函数可以启用<code class="codeph">INF_EXT_OPT_FLAG_ALL_IDS</code>优化标志。为获得最佳性能，函数应尝试使用资源ID而不是词法值。但是，有时这是不可能的，如<a href="user-defined-inferencing.html#GUID-CE4D14D6-3C48-47EA-92BB-CEC870316412">示例2：添加动态三元组</a> ，它连接词汇值以形成新的词汇值。请注意，在<a href="user-defined-inferencing.html#GUID-CE4D14D6-3C48-47EA-92BB-CEC870316412">示例2：添加动态三元组的情况下</a> ，通常最好与资源视图（ <code class="codeph">resource_id_map_view</code> ）连接，而不是在SQL查询中嵌入对<code class="codeph">oracle_orardf_res2vid</code>调用。这是由于为每个可能的匹配调用函数的开销，而不是与另一个表连接。
                        </p>
                        <p><code class="codeph">sem_inf_related</code>函数的另一个关键区别是使用<code class="codeph">oracle_orardf_add_res</code>函数（与<code class="codeph">oracle_orardf_res2vid</code>相比）。与<code class="codeph">res2vid</code>函数不同，如果资源尚不存在， <code class="codeph">add_res</code>函数将向资源视图（ <code class="codeph">resource_id_map_view</code> ）添加资源。如果将资源添加到资源视图不是问题，则推理扩展函数应使用<code class="codeph">add_res</code>函数。多次调用该函数不会在资源视图中生成重复的条目。
                        </p>
                        <p>最后一个主要区别是SQL查询中的附加<code class="codeph">NOT EXISTS</code>子句。第一个<code class="codeph">NOT EXISTS</code>子句避免添加任何三元组，这些三元组可能是模型中已有的三元组的重复，或者是由其他规则（ <code class="codeph">src_tab_view</code> ）推断的三元组。检查这些重复项允许<code class="codeph">sem_inf_related</code>启用<code class="codeph">INF_EXT_OPT_FLAG_NEWDATA_ONLY</code>优化标志。第二个<code class="codeph">NOT EXISTS</code>子句避免在当前推理轮次期间添加可能与<code class="codeph">sem_inf_related</code>函数已添加到<code class="codeph">sem_inf_related</code>表的三元组重复的三元组（请参阅<code class="codeph">num_calls</code>参数）。检查这些重复项允许<code class="codeph">sem_inf_related</code>启用<code class="codeph">INF_EXT_OPT_FLAG_UNIQDATA_ONLY</code>优化标志。
                        </p>
                        <p>与<code class="codeph">sem_inf_dynamic</code>示例一样， <code class="codeph">sem_inf_related</code>示例在其insert语句中使用<code class="codeph">PARALLEL</code> SQL查询提示。在平衡硬件配置上并行执行可以显着提高性能。对于数据密集型应用程序，良好的I / O子系统通常是整个系统性能的关键组件。
                        </p>
                        <p>要使用<code class="codeph">sem_inf_dynamic</code>函数创建一个蕴涵，请向MDSYS用户授予执行权限，然后将函数名称传递给<a href="SEM_APIS-reference.html#GUID-BF52CEC0-1BD9-4908-9EF1-F001B0527257">SEM_APIS.CREATE_ENTAILMENT</a>过程，如下所示：</p><pre class="oac_no_warn" dir="ltr">- 授予适当的权限，授予对mdsys的sem_inf_related执行权限; - 创建蕴涵开始sem_apis.create_entailment（'EMPLOYEES_INF'，sem_models（'EMPLOYEES'），sem_rulebases（'OWLPRIME'），传递=&gt; SEM_APIS.REACH_CLOSURE，inf_ext_user_func_name =&gt;'sem_inf_related'）;结束; /</pre><p>该蕴涵应包含由<code class="codeph">sem_inf_related</code>添加的以下两个新三元组：</p><pre class="oac_no_warn" dir="ltr">SPO ------------------------ ------------------------- ----------- ------------------------ http://example.org/John http：// example。 org / possibleRelative http://example.org/Mary http://example.org/Mary http://example.org/possibleRelative http://example.org/John</pre></div>
                     <div>
                        <div class="familylinks">
                           <div class="parentlink">
                              <p><strong>父主题：</strong> <a href="user-defined-inferencing.html#GUID-E2FE95D9-C6A8-4E22-9CAA-85B558E153E2">用户定义的推理扩展函数示例</a></p>
                           </div>
                        </div>
                     </div>
                     
                  </div><a id="RDFRM529"></a><a id="RDFRM530"></a><a id="RDFRM528"></a><div class="props_rev_3"><a id="GUID-71E6C43C-4329-49AA-A3B2-A158C0176ADF" name="GUID-71E6C43C-4329-49AA-A3B2-A158C0176ADF"></a><h5 id="RDFRM-GUID-71E6C43C-4329-49AA-A3B2-A158C0176ADF" class="sect5"><span class="enumeration_section">7.1.3.4</span>例4：时间推理（几个相关例子）</h5>
                     <div>
                        <p>用户定义的扩展函数使您能够更好地利用三元组中的某些数据类型（如<code class="codeph">xsd:dateTime</code> ）。例如，通过用户定义的扩展函数，可以基于两个<code class="codeph">xsd:dateTime</code>值之间的差异来推断三元组之间的关系。本节中的三个示例探讨了两种不同的时间推理规则以及如何将它们组合成一种蕴涵。示例假设模型<code class="codeph">EVENT</code>和<code class="codeph">EVENT_ONT</code>存在并包含以下语义数据：</p>
                        <div class="section">
                           <p class="subhead3" id="GUID-71E6C43C-4329-49AA-A3B2-A158C0176ADF__GUID-2E18C5A6-43FF-4576-94AB-4DD6330847CB">EVENT_ONT</p>
                        </div>
                        <!-- class="section" -->
                        <div class="section"><pre class="oac_no_warn" dir="ltr">@prefix owl：&lt;http://www.w3.org/2002/07/owl#&gt;。@prefix rdf：&lt;http://www.w3.org/1999/02/22-rdf-syntax-ns#&gt;。@prefix rdfs：&lt;http://www.w3.org/2000/01/rdf-schema#&gt;。@prefix xsd：&lt;http://www.w3.org/2001/XMLSchema#&gt;。@prefix：&lt;http://example.org/event/&gt;。＃我们模拟两种类型的事件：Meeting rdfs：subClassOf：Event。：Presentation rdfs：subClassOf：Event。＃events包含主题：topic rdfs：domain：Event。#stops有开始和结束时间：startTime rdfs：domain：Event; rdfs：range xsd：dateTime。：endTime rdfs：domain：Event; rdfs：range xsd：dateTime。#stors事件的持续时间（以分钟为单位）：lengthInMins rdfs：domain：Event; rdfs：range xsd：integer。＃overlaps属性标识冲突事件：重叠rdfs：domain：Event; rdf：type owl：SymmetricProperty。：noOverlap rdfs：domain：Event; rdf：type owl：SymmetricProperty。</pre></div>
                        <!-- class="section" -->
                        <div class="section">
                           <p class="subhead3" id="GUID-71E6C43C-4329-49AA-A3B2-A158C0176ADF__GUID-5476F5E9-CB5E-4ADA-ACEA-A6B5E4BA0111">EVENT_TBOX</p>
                        </div>
                        <!-- class="section" -->
                        <div class="section"><pre class="oac_no_warn" dir="ltr">@prefix rdf：&lt;http://www.w3.org/1999/02/22-rdf-syntax-ns#&gt;。@prefix xsd：&lt;http://www.w3.org/2001/XMLSchema#&gt;。@prefix：&lt;http://example.org/event/&gt;。：m1 rdf：type：Meeting; ：主题“Beta1发布”; ：startTime“2012-04-01T09：30：00-05：00”^^ xsd：dateTime; ：endTime“2012-04-01T11：00：00-05：00”^^ xsd：dateTime。：m2 rdf：类型：会议; ：主题“标准合规”; ：startTime“2012-04-01T12：30：00-05：00”^^ xsd：dateTime; ：endTime“2012-04-01T13：30：00-05：00”^^ xsd：dateTime。：p1 rdf：type：Presentation; ：主题“OWL Reasoners”; ：startTime“2012-04-01T11：00：00-05：00”^^ xsd：dateTime; ：endTime“2012-04-01T13：00：00-05：00”^^ xsd：dateTime。
</pre><p>示例如下。</p>
                        </div>
                        <!-- class="section" -->
                     </div>
                     <div>
                        <ul class="ullinks">
                           <li class="ulchildlink"><a href="user-defined-inferencing.html#GUID-3FAFE41D-4E5A-4E61-BAE1-8C238F126D2D">示例4a：持续时间规则</a><br></li>
                           <li class="ulchildlink"><a href="user-defined-inferencing.html#GUID-DFA3D154-24CA-4DC5-AF39-82D1FFBAD85B">例4b：重叠规则</a><br></li>
                           <li class="ulchildlink"><a href="user-defined-inferencing.html#GUID-23952501-FEBE-49CD-8579-BCB4D0908F56">例4c：持续时间和重叠规则</a><br></li>
                        </ul>
                        <div class="familylinks">
                           <div class="parentlink">
                              <p><strong>父主题：</strong> <a href="user-defined-inferencing.html#GUID-E2FE95D9-C6A8-4E22-9CAA-85B558E153E2">用户定义的推理扩展函数示例</a></p>
                           </div>
                        </div>
                     </div>
                     <a id="RDFRM531"></a><div class="props_rev_3"><a id="GUID-3FAFE41D-4E5A-4E61-BAE1-8C238F126D2D" name="GUID-3FAFE41D-4E5A-4E61-BAE1-8C238F126D2D"></a><h6 id="RDFRM-GUID-3FAFE41D-4E5A-4E61-BAE1-8C238F126D2D" class="sect6"><span class="enumeration_section">7.1.3.4.1</span>示例4a：持续时间规则</h6>
                        <div>
                           <p>在给定事件的开始和结束时间的情况下，以下用户定义的推理扩展函数（ <code class="codeph">sem_inf_durations</code> ）推断事件的持续时间（以分钟为<code class="codeph">sem_inf_durations</code> ）。例如，从上午9:30开始到上午11:00结束的事件持续时间为90分钟。以下扩展函数提取每个事件的开始和结束时间，将<code class="codeph">xsd:dateTime</code>值转换为Oracle时间戳，然后计算时间戳之间的差异。请注意，此扩展功能可以处理时区。
                           </p><pre class="oac_no_warn" dir="ltr">创建或替换函数sem_inf_durations（varchar2中的src_tab_view，varchar2中的resource_id_map_view，varchar2中的output_tab，varchar2中的action，number中的num_calls，数量中的tplInferredLastRound，varchar2中的选项default null，optimization_flag out number，diag_message out varchar2）return boolean as eventClassId number; rdfTypePropertyId数字; startTimePropertyId数字; endTimePropertyId数字; durationPropertyId数字; xsdTimeFormat varchar2（100）; sqlStmt varchar2（4000）; insertStmt varchar2（4000）; pragma autonomous_transaction; begin if（action ='RUN'）then  - 检索数据中已经存在的资源ID（如果资源不存在则抛出异常）。eventClassId：= sdo_sem_inference.oracle_orardf_res2vid（'http://example.org/event/Event'）; startTimePropertyId：= sdo_sem_inference.oracle_orardf_res2vid（'http://example.org/event/startTime'）; endTimePropertyId：= sdo_sem_inference.oracle_orardf_res2vid（'http://example.org/event/endTime'）; durationPropertyId：= sdo_sem_inference.oracle_orardf_res2vid（'http://example.org/event/lengthInMins'）; rdfTypePropertyId：= sdo_sem_inference.oracle_orardf_res2vid（'http://www.w3.org/1999/02/22-rdf-syntax-ns#type'）; - 设置我们将用于解析XSD次的TIMESTAMP格式xsdTimeFormat：='YYYY-MM-DD“T”HH24：MI：SSTZH：TZM'; - 我们用于提取事件ID和开始/结束时间的查询。sqlStmt：='select ids1.sid eventId，TO_TIMESTAMP_TZ（values1.value_name，''YYYY-MM-DD“T”HH24：MI：SSTZH：TZM''）startTime，TO_TIMESTAMP_TZ（values2.value_name，''YYYY-MM- DD“T”HH24：MI：SSTZH：TZM''）来自'||的endTime resource_id_map_view || 'values1，'|| resource_id_map_view || 'values2，'|| src_tab_view || 'ids1，'|| src_tab_view || 'ids2，'|| src_tab_view || 'ids3其中ids1.sid = ids3.sid AND ids3.pid ='|| to_char（rdfTypePropertyId，'TM9'）|| 'AND ids3.oid ='|| to_char（eventClassId，'TM9'）|| 'AND ids1.sid = ids2.sid AND ids1.pid ='|| to_char（startTimePropertyId，'TM9'）|| 'AND ids2.pid ='|| to_char（endTimePropertyId，'TM9'）|| 'AND ids1.oid = values1.value_id AND ids2.oid = values2.value_id / *确保我们有NEWDATA * / AND不存在（从'|| src_tab_view ||'中选择1，其中sid = ids3.sid AND pid ='| | to_char（durationPropertyId，'TM9'）||'）/ *确保我们有UNIQDATA * / AND不存在（从'|| output_tab ||'中选择1，其中sid = ids3.sid AND pid ='|| to_char（durationPropertyId ，'TM9'）||'）'; - 计算来自sqlStmt查询的两个Oracle时间戳之间的差异（以分钟为单位）。将分钟存储为 -  xsd：integer。insertStmt：='insert / * + parallel append * / into'|| output_tab || '（sid，pid，o）选择eventId，'|| to_char（durationPropertyId，'TM9'）|| '，''''''|| minutes ||''“^^ xsd：integer''from（select eventId，（extract（day from（endTime  -  startTime））* 24 * 60 + extract（小时来自（endTime  - startTime））* 60 +提取（分钟来自（endTime  -  startTime）））分钟来自（'|| sqlStmt ||'））'; - 执行查询execute immediate insertStmt; - 提交我们的更改提交;万一; - 我们已经在src_tab_view（NEWDATA）中检查了重复项，并在 -  output_tab（UNIQDATA）中检查了optimization_flag：= SDO_SEM_INFERENCE.INF_EXT_OPT_FLAG_NEWDATA_ONLY + SDO_SEM_INFERENCE.INF_EXT_OPT_FLAG_UNIQDATA_ONLY; - 返回true表示成功返回true; - 处理任何异常异常时，其他人然后diag_message：='发生错误：'|| SQLERRM;返回false;结束sem_inf_durations; /显示错误;</pre><p><code class="codeph">sem_inf_durations</code>函数利用内置的Oracle时态函数来计算事件持续时间。首先，该函数使用<code class="codeph">TO_TIMESTAMP_TZ</code>函数将<code class="codeph">xsd:dateTime</code>文字值转换为Oracle <code class="codeph">TIMESTAMP</code>对象。获取两个Oracle <code class="codeph">TIMESTAMP</code>对象之间的差异会生成一个表示时间间隔的<code class="codeph">INTERVAL</code>对象。使用<code class="codeph">EXTRACT</code>运算符， <code class="codeph">sem_inf_durations</code>函数通过从持续时间间隔中提取天数，小时数和分钟数来计算每个事件的持续时间（以分钟为单位）。
                           </p>
                           <p>因为<code class="codeph">sem_inf_durations</code>函数针对现有模型（ <code class="codeph">src_tab_view</code> ）中的数据和<code class="codeph">output_tab</code>表中的数据检查重复项，所以它可以启用<code class="codeph">INF_EXT_OPT_FLAG_NEWDATA_ONLY</code>和<code class="codeph">INF_EXT_OPT_FLAG_UNIQDATA_ONLY</code>优化标志。（有关优化标志的更多信息，请参阅<a href="user-defined-inferencing.html#GUID-9130DB03-063F-4ECA-BC72-F841816D03A2">示例3：优化性能</a> 。）
                           </p>
                           <p>请注意，与前面的示例不同， <code class="codeph">sem_inf_durations</code>包含异常处理程序。异常处理程序对于调试用户定义的推理扩展函数中的问题很有用。要生成有用的调试消息，请在扩展函数中捕获异常，设置<code class="codeph">diag_message</code>参数以反映错误，并返回<code class="codeph">FALSE</code>以指示在执行扩展函数期间发生错误。<code class="codeph">sem_inf_durations</code>函数捕获所有异常并将<code class="codeph">diag_message</code>值设置为异常消息。
                           </p>
                           <p>要使用<code class="codeph">sem_inf_durations</code>函数创建一个蕴涵，请向MDSYS用户授予执行权限，然后将函数名称传递给<a href="SEM_APIS-reference.html#GUID-BF52CEC0-1BD9-4908-9EF1-F001B0527257">SEM_APIS.CREATE_ENTAILMENT</a>过程，如下所示：</p><pre class="oac_no_warn" dir="ltr">- 授予适当的权限授予执行sem_inf_durations到mdsys; - 创建蕴涵开始sem_apis.create_entailment（'EVENT_INF'，sem_models（'EVENT'，'EVENT_ONT'），sem_rulebases（'OWLPRIME'），传递=&gt; SEM_APIS.REACH_CLOSURE，inf_ext_user_func_name =&gt;'sem_inf_durations'）;结束; /</pre><p>除了由OWLPRIME推断的三元组之外，蕴涵还应包含由<code class="codeph">sem_inf_durations</code>添加的以下三个新三元组：</p><pre class="oac_no_warn" dir="ltr">SPO ---------------------------- --------------------- ----------------- --------- http://example.org/event/m1 http://example.org/event/lengthInMins 90 http ：//example.org/event/m2 http://example.org/event/lengthInMins 60 http://example.org/event/p1 http://example.org/event/lengthInMins 120</pre></div>
                        <div>
                           <div class="familylinks">
                              <div class="parentlink">
                                 <p><strong>父主题：</strong> <a href="user-defined-inferencing.html#GUID-71E6C43C-4329-49AA-A3B2-A158C0176ADF">示例4：时间推理（几个相关示例）</a></p>
                              </div>
                           </div>
                        </div>
                        
                     </div><a id="RDFRM532"></a><div class="props_rev_3"><a id="GUID-DFA3D154-24CA-4DC5-AF39-82D1FFBAD85B" name="GUID-DFA3D154-24CA-4DC5-AF39-82D1FFBAD85B"></a><h6 id="RDFRM-GUID-DFA3D154-24CA-4DC5-AF39-82D1FFBAD85B" class="sect6"><span class="enumeration_section">7.1.3.4.2</span>例4b：重叠规则</h6>
                        <div>
                           <p>以下用户定义的推理扩展函数（ <code class="codeph">sem_inf_overlap</code> ）推断两个事件是否重叠。如果一个事件在另一个事件正在进行时开始，则两个事件重叠。该函数提取每对事件的开始和结束时间，将<code class="codeph">xsd:dateTime</code>值转换为Oracle时间戳，然后计算一个事件是否在另一个事件内开始。
                           </p><pre class="oac_no_warn" dir="ltr">创建或替换函数sem_inf_overlap（varchar2中的src_tab_view，varchar2中的resource_id_map_view，varchar2中的output_tab，varchar2中的action，number中的num_calls，数量中的tplInferredLastRound，varchar2中的选项default null，optimization_flag out number，diag_message out varchar2）return boolean as eventClassId number; rdfTypePropertyId数字; startTimePropertyId数字; endTimePropertyId数字; overlapsPropertyId数字; noOverlapPropertyId数字; xsdTimeFormat varchar2（100）; sqlStmt varchar2（4000）; insertStmt varchar2（4000）; pragma autonomous_transaction; begin if（action ='RUN'）then  - 检索数据中已经存在的资源ID（如果资源不存在则抛出异常）。eventClassId：= sdo_sem_inference.oracle_orardf_res2vid（'http://example.org/event/Event'）; startTimePropertyId：= sdo_sem_inference.oracle_orardf_res2vid（'http://example.org/event/startTime'）; endTimePropertyId：= sdo_sem_inference.oracle_orardf_res2vid（'http://example.org/event/endTime'）; overlapsPropertyId：= sdo_sem_inference.oracle_orardf_res2vid（'http://example.org/event/overlaps'）; noOverlapPropertyId：= sdo_sem_inference.oracle_orardf_res2vid（'http://example.org/event/noOverlap'）; rdfTypePropertyId：= sdo_sem_inference.oracle_orardf_res2vid（'http://www.w3.org/1999/02/22-rdf-syntax-ns#type'）; - 设置我们将用于解析XSD次的TIMESTAMP格式xsdTimeFormat：='YYYY-MM-DD“T”HH24：MI：SSTZH：TZM'; - 我们用于提取事件ID和开始/结束时间的查询。sqlStmt：='select idsA1.sid eventAId，idsB1.sid eventBId，TO_TIMESTAMP_TZ（valuesA1.value_name，''YYYY-MM-DD“T”HH24：MI：SSTZH：TZM''）startTimeA，TO_TIMESTAMP_TZ（valuesA2.value_name，' 'YYYY-MM-DD“T”HH24：MI：SSTZH：TZM''）endTimeA，TO_TIMESTAMP_TZ（valuesB1.value_name，''YYYY-MM-DD“T”HH24：MI：SSTZH：TZM''）startTimeB，TO_TIMESTAMP_TZ （valuesB2.value_name，''YYYY-MM-DD“T”HH24：MI：SSTZH：TZM''）来自'||的endTimeB resource_id_map_view || 'valuesA1，'|| resource_id_map_view || 'valuesA2，'|| resource_id_map_view || 'valuesB1，'|| resource_id_map_view || 'valuesB2，'|| src_tab_view || 'idsA1，'|| src_tab_view || 'idsA2，'|| src_tab_view || 'idsA3，'|| src_tab_view || 'idsB1，'|| src_tab_view || 'idsB2，'|| src_tab_view || 'idsB3其中idsA1.sid = idsA3.sid AND idsA3.pid ='|| to_char（rdfTypePropertyId，'TM9'）|| 'AND idsA3.oid ='|| to_char（eventClassId，'TM9'）|| 'AND idsB1.sid = idsB3.sid AND idsB3.pid ='|| to_char（rdfTypePropertyId，'TM9'）|| 'AND idsB3.oid ='|| to_char（eventClassId，'TM9'）|| '/ *仅执行一半检查，我们的TBOX本体将处理对称性* / AND idsA1.sid &lt;idsB1.sid / *获取事件A * / AND idsA1.sid = idsA2.sid和idsA1.pid的startTime和endTime值='|| to_char（startTimePropertyId，'TM9'）|| 'AND idsA2.pid ='|| to_char（endTimePropertyId，'TM9'）|| 'AND idsA1.oid = valuesA1.value_id AND idsA2.oid = valuesA2.value_id / *获取事件B的起始时间和结束时间的值*和AND idsB1.sid = idsB2.sid AND idsB1.pid ='|| to_char（startTimePropertyId，'TM9'）|| 'AND idsB2.pid ='|| to_char（endTimePropertyId，'TM9'）|| 'AND idsB1.oid = valuesB1.value_id AND idsB2.oid = valuesB2.value_id / *确保我们有NEWDATA * / AND不存在（从'|| src_tab_view ||'中选择1，其中sid = idsA1.sid AND oid = idsB1。 sid和pid in（'|| to_char（overlapsPropertyId，'TM9'）||'，'|| to_char（noOverlapPropertyId，'TM9'）||'））/ *确保我们有UNIQDATA * / AND不存在（选择1来自'|| output_tab ||'，其中sid = idsA1.sid AND oid = idsB1.sid AND pid in（'|| to_char（overlapsPropertyId，'TM9'）||'，'|| to_char（noOverlapPropertyId，'TM9'） ||'））'; - 比较两个事件时间insertStmt：='insert / * + parallel append * / into'|| output_tab || '（sid，pid，oid）选择eventAId，overlapStatusId，eventBId from（select eventAId，（case when when（startTimeA &lt;endTimeB和startTimeA&gt; startTimeB）然后'|| to_char（overlapsPropertyId，'TM9'）||'when（startTimeB &lt; endTimeA和startTimeB&gt; startTimeA）然后'|| to_char（overlapsPropertyId，'TM9'）||'else'|| to_char（noOverlapPropertyId，'TM9'）||'end）overlapStatusId，eventBId from（'|| sqlStmt ||' ））'; - 执行查询execute immediate insertStmt; - 提交我们的更改提交;万一; - 我们只在output_tab中使用ID值，我们检查 - 与NOT EXISTS子句重复。optimization_flag：= SDO_SEM_INFERENCE.INF_EXT_OPT_FLAG_ALL_IDS + SDO_SEM_INFERENCE.INF_EXT_OPT_FLAG_NEWDATA_ONLY + SDO_SEM_INFERENCE.INF_EXT_OPT_FLAG_UNIQDATA_ONLY; - 返回true表示成功返回true; - 处理任何异常异常时，其他人然后diag_message：='发生错误：'|| SQLERRM;返回false;结束sem_inf_overlap; /显示错误;</pre><p><code class="codeph">sem_inf_overlap</code>函数类似于<a href="user-defined-inferencing.html#GUID-DFA3D154-24CA-4DC5-AF39-82D1FFBAD85B">例4b中</a>的<code class="codeph">sem_inf_durations</code>函数<a href="user-defined-inferencing.html#GUID-DFA3D154-24CA-4DC5-AF39-82D1FFBAD85B">：重叠规则</a> 。两者之间的主要区别在于<code class="codeph">sem_inf_overlap</code>中的查询包含更多连接并启用INF_EXT_OPT_FLAG_ALL_IDS优化标志，因为它不需要生成新的词法值。（有关优化标志的更多信息，请参阅<a href="user-defined-inferencing.html#GUID-9130DB03-063F-4ECA-BC72-F841816D03A2">示例3：优化性能</a> 。）
                           </p>
                           <p>要使用<code class="codeph">sem_inf_overlap</code>函数创建蕴涵，请向MDSYS用户授予执行权限，然后将函数名称传递给<a href="SEM_APIS-reference.html#GUID-BF52CEC0-1BD9-4908-9EF1-F001B0527257">SEM_APIS.CREATE_ENTAILMENT</a>过程，如下所示：</p><pre class="oac_no_warn" dir="ltr">- 授予适当的权限授予对sem_inf_overlap执行到mdsys; - 创建蕴涵开始sem_apis.create_entailment（'EVENT_INF'，sem_models（'EVENT'，'EVENT_ONT'），sem_rulebases（'OWLPRIME'），传递=&gt; SEM_APIS.REACH_CLOSURE，inf_ext_user_func_name =&gt;'sem_inf_overlap'）;结束; /</pre><p>除了由OWLPRIME推断的三元组之外，蕴涵还应包含由<code class="codeph">sem_inf_overlap</code>添加的以下六个新三元组：</p><pre class="oac_no_warn" dir="ltr">SPO ---------------------------- --------------------- -------------- ---------------------------- http://example.org/ event / m1 http://example.org/event/noOverlap http://example.org/event/m2 http://example.org/event/m1 http://example.org/event/noOverlap http：/ /example.org/event/p1 http://example.org/event/m2 http://example.org/event/noOverlap http://example.org/event/m1 http://example.org/event / m2 http://example.org/event/overlaps http://example.org/event/p1 http://example.org/event/p1 http://example.org/event/noOverlap http：// example.org/event/m1 http://example.org/event/p1 http://example.org/event/overlaps http://example.org/event/m2</pre></div>
                        <div>
                           <div class="familylinks">
                              <div class="parentlink">
                                 <p><strong>父主题：</strong> <a href="user-defined-inferencing.html#GUID-71E6C43C-4329-49AA-A3B2-A158C0176ADF">示例4：时间推理（几个相关示例）</a></p>
                              </div>
                           </div>
                        </div>
                        
                     </div><a id="RDFRM533"></a><div class="props_rev_3"><a id="GUID-23952501-FEBE-49CD-8579-BCB4D0908F56" name="GUID-23952501-FEBE-49CD-8579-BCB4D0908F56"></a><h6 id="RDFRM-GUID-23952501-FEBE-49CD-8579-BCB4D0908F56" class="sect6"><span class="enumeration_section">7.1.3.4.3</span>例4c：持续时间和重叠规则</h6>
                        <div>
                           <p>本节中的示例使用<a href="user-defined-inferencing.html#GUID-3FAFE41D-4E5A-4E61-BAE1-8C238F126D2D">示例4a中</a>的扩展函数<a href="user-defined-inferencing.html#GUID-3FAFE41D-4E5A-4E61-BAE1-8C238F126D2D">：持续时间规则</a> （ <code class="codeph">sem_inf_durations</code> ）和<a href="user-defined-inferencing.html#GUID-DFA3D154-24CA-4DC5-AF39-82D1FFBAD85B">示例4b：重叠规则</a> （ <code class="codeph">sem_inf_overlap</code> ）一起生成单个蕴涵。对于此示例，扩展功能未经修改。
                           </p>
                           <p>为了创建使用多个扩展功能的蕴涵，用逗号分开传递给每个扩展功能<code class="codeph">inf_ext_user_func_name</code>的参数<a href="SEM_APIS-reference.html#GUID-BF52CEC0-1BD9-4908-9EF1-F001B0527257">SEM_APIS.CREATE_ENTAILMENT</a> 。以下示例假定已为MDSYS用户授予了扩展功能的相应权限。
                           </p><pre class="oac_no_warn" dir="ltr">- 使用多个用户定义的推理函数开始sem_apis.create_entailment（'EVENT_INF'，sem_models（'EVENT'，'EVENT_ONT'），sem_rulebases（'OWLPRIME'），传递=&gt; SEM_APIS.REACH_CLOSURE，inf_ext_user_func_name =&gt;'sem_inf_durations，sem_inf_overlap '）;结束; /</pre><p>除了由OWLPRIME推断的三元组外，蕴涵还应包含由<code class="codeph">sem_inf_durations</code>和<code class="codeph">sem_inf_overlap</code>添加的以下九个新三元组：</p><pre class="oac_no_warn" dir="ltr">SPO ---------------------------- --------------------- ----------------- ---------------------------- http：// example .org / event / m1 http://example.org/event/lengthInMins 90 http://example.org/event/m1 http://example.org/event/noOverlap http://example.org/event/ m2 http://example.org/event/m1 http://example.org/event/noOverlap http://example.org/event/p1 http://example.org/event/m2 http：// example .org / event / lengthInMins 60 http://example.org/event/m2 http://example.org/event/noOverlap http://example.org/event/m1 http://example.org/event/ m2 http://example.org/event/overlaps http://example.org/event/p1 http://example.org/event/p1 http://example.org/event/lengthInMins 120 http：// example.org/event/p1 http://example.org/event/noOverlap http://example.org/event/m1 http://example.org/event/p1 http://example.org/event/重叠http://example.org/event/m2</pre><p>请注意，扩展函数<code class="codeph">sem_inf_durations</code>和<code class="codeph">sem_inf_overlap</code>不需要使用相同的优化标志。可以使用具有矛盾优化标志的扩展函数（例如，使用<code class="codeph">INF_EXT_OPT_FLAG_ALL_IDS</code>一个函数和将所有新三元组插入作为词汇值的另一个函数）。
                           </p>
                        </div>
                        <div>
                           <div class="familylinks">
                              <div class="parentlink">
                                 <p><strong>父主题：</strong> <a href="user-defined-inferencing.html#GUID-71E6C43C-4329-49AA-A3B2-A158C0176ADF">示例4：时间推理（几个相关示例）</a></p>
                              </div>
                           </div>
                        </div>
                        
                     </div>
                  </div><a id="RDFRM534"></a><div class="props_rev_3"><a id="GUID-44EBDF64-6718-4960-98EB-0D2C45F677A3" name="GUID-44EBDF64-6718-4960-98EB-0D2C45F677A3"></a><h5 id="RDFRM-GUID-44EBDF64-6718-4960-98EB-0D2C45F677A3" class="sect5"><span class="enumeration_section">7.1.3.5</span>示例5：空间推理</h5>
                     <div>
                        <p>用户定义的推理扩展函数还可以利用地理空间数据类型（如WKT（众所周知的文本））来执行空间推理。例如，利用用户定义的扩展函数，可以推断几何实体（例如州和城市）之间的“包含”关系。</p>
                        <p>本节中的示例演示了如何推断几何（美国州）是否包含点（美国城市）。此示例假定RDF网络已具有空间索引（在第1.6.6.2节中描述）。此示例还假设模型<code class="codeph">STATES</code>存在并包含以下语义数据：</p><pre class="oac_no_warn" dir="ltr">@prefix orageo：&lt;http://xmlns.oracle.com/rdf/geo/&gt;。@prefix rdf：&lt;http://www.w3.org/1999/02/22-rdf-syntax-ns#&gt;。@prefix rdfs：&lt;http://www.w3.org/2000/01/rdf-schema#&gt;。@prefix：&lt;http://example.org/geo/&gt;。：Colorado rdf：type：State; ：边界“多边形（（ -  109.0448 37.0004，-102.0424 36.9949，-102.0534 41.0006，-109.0489 40.9996，-109.0448 37.0004））”^^ orageo：WKTLiteral。：犹他州rdf：类型：州; ：边界“多边形（（ -  114.0491 36.9982，-109.0462 37.0026，-109.0503 40.9986，-111.0471 41.0006，-111.0498 41.9993，-114.0395 41.9901，-114.0491 36.9982））”^^ orageo：WKTLiteral。：Wyoming rdf：type：State; ：边界“多边形（（ -  104.0556 41.0037，-104.0584 44.9949，-111.0539 44.9998，-111.0457 40.9986，-104.0556 41.0037））”^^ orageo：WKTLiteral：StateCapital rdfs：subClassOf：City; ：Denver rdf：type：StateCapital; ：位置“点（-104.984722 39.739167）”^^ orageo：WKTLiteral。：SaltLake rdf：type：StateCaptial; ：位置“点（-111.883333 40.75）”^^ orageo：WKTLiteral。：Cheyenne rdf：type：StateCapital; ：location“Point（-104.801944 41.145556）”^^ orageo：WKTLiteral。
</pre><p>以下用户定义的推理扩展函数（ <code class="codeph">sem_inf_capitals</code> ）使用WKT几何搜索每个州内的大城市。如果函数找到首都，则推断城市是包含它的州的首都。
                        </p><pre class="oac_no_warn" dir="ltr">创建或替换函数sem_inf_capitals（varchar2中的src_tab_view，varchar2中的resource_id_map_view，varchar2中的output_tab，varchar2中的action，number中的num_calls，数量中的tplInferredLastRound，varchar2中的选项default null，optimization_flag out number，diag_message out varchar2）return boolean as stateClassId number; capitalClassId数; boundaryPropertyId数字; locationPropertyId数字; rdfTypePropertyId数字; capitalPropertyId数字; defaultSRID号码：= 8307; xsdTimeFormat varchar2（100）; sqlStmt varchar2（4000）; insertStmt varchar2（4000）; pragma autonomous_transaction; begin if（action ='RUN'）then  - 检索数据中已经存在的资源ID（如果资源不存在则抛出异常）。stateClassId：= sdo_sem_inference.oracle_orardf_res2vid（'http://example.org/geo/State'）; capitalClassId：= sdo_sem_inference.oracle_orardf_res2vid（'http://example.org/geo/StateCapital'）; boundaryPropertyId：= sdo_sem_inference.oracle_orardf_res2vid（'http://example.org/geo/boundary'）; locationPropertyId：= sdo_sem_inference.oracle_orardf_res2vid（'http://example.org/geo/location'）; rdfTypePropertyId：= sdo_sem_inference.oracle_orardf_res2vid（'http://www.w3.org/1999/02/22-rdf-syntax-ns#type'）; - 资源的retreive ID或如果资源确实生成新ID  - 尚不存在capitalPropertyId：= sdo_sem_inference.oracle_orardf_add_res（'http://example.org/geo/capital'）; - 查询我们用于提取状态边界内包含的大写城市sqlStmt：='select idsA1.sid stateId，idsB1.sid cityId from'|| resource_id_map_view || 'valuesA，'|| resource_id_map_view || 'valuesB，'|| src_tab_view || 'idsA1，'|| src_tab_view || 'idsA2，'|| src_tab_view || 'idsB1，'|| src_tab_view || 'idsB2其中idsA1.pid ='|| to_char（rdfTypePropertyId，'TM9'）|| 'AND idsA1.oid ='|| to_char（stateClassId，'TM9'）|| 'AND idsB1.pid ='|| to_char（rdfTypePropertyId，'TM9'）|| 'AND idsB1.oid ='|| to_char（capitalClassId，'TM9'）|| '/ *抓取几何词汇值* / AND idsA2.sid = idsA1.sid AND idsA2.pid ='|| TO_CHAR（boundaryPropertyId， 'TM9'）|| 'AND idsA2.oid = valuesA.value_id AND idsB2.sid = idsB1.sid AND idsB2.pid ='|| TO_CHAR（locationPropertyId， 'TM9'）|| 'AND idsB2.oid = valuesB.value_id / *比较几何以查看city是否包含州* / AND SDO_RELATE（SDO_RDF.getV $ GeometryVal（valuesA.value_type，valuesA.vname_prefix，valuesA.vname_suffix，valuesA.literal_type，valuesA。 language_type，valuesA.long_value，'|| to_char（defaultSRID，'TM9'）||'），SDO_RDF.getV $ GeometryVal（valuesB.value_type，valuesB.vname_prefix，valuesB.vname_suffix，valuesB.literal_type，valuesB.language_type，valuesB。 long_value，'|| to_char（defaultSRID，'TM9'）||'），''mask = CONTAINS''）=''TRUE''/ *确保我们有NEWDATA并且只检查未分配给州* *的大写字母不存在（从'|| src_tab_view ||'中选择1，其中pid ='|| to_char（capitalPropertyId，'TM9'）||'AND（sid = idsA1.sid OR oid = idsB1.sid））/ *确保我们有UNIQDATA并且仅检查未分配给状态的大写* / AND不存在（从'|| output_tab ||'中选择1，其中pid ='|| to_char（capitalPropertyId，'TM9'）||'AND（sid = idsA1.sid或oid = idsB1.sid））'; - 仅使用ID insertStmt：='insert / * + parallel append * / into'||插入新的三元组output_tab || '（sid，pid，oid）选择stateId，'|| to_char（capitalPropertyId，'TM9'）|| '，cityId from（'|| sqlStmt ||'）'; - 执行查询execute immediate insertStmt; - 提交我们的更改提交;万一; - 我们只在output_tab中使用ID值，我们检查 - 与NOT EXISTS子句重复。optimization_flag：= SDO_SEM_INFERENCE.INF_EXT_OPT_FLAG_ALL_IDS + SDO_SEM_INFERENCE.INF_EXT_OPT_FLAG_NEWDATA_ONLY + SDO_SEM_INFERENCE.INF_EXT_OPT_FLAG_UNIQDATA_ONLY; - 返回true表示成功返回true; - 处理任何异常异常时，其他人然后diag_message：='发生错误：'|| SQLERRM;返回false;结束sem_inf_capitals; /显示错误;</pre><p><code class="codeph">sem_inf_capitals</code>函数类似于<a href="user-defined-inferencing.html#GUID-3FAFE41D-4E5A-4E61-BAE1-8C238F126D2D">示例4a：Duration Rule中</a>的<code class="codeph">sem_inf_durations</code>函数，因为两个函数都必须将某些三元组的词汇值转换为Oracle类型以利用本机Oracle运算符。对于<code class="codeph">sem_inf_capitals</code> ，该函数使用<code class="codeph">SDO_RDF.getV$GeometryVal</code>函数将编码多边形和点的WKT词法值转换为Oracle Spatial and Graph SDO_GEOMETRY类型。<code class="codeph">getV$GeometryVal</code>函数需要主要由资源视图（ <code class="codeph">resource_id_map_view</code> ）提供的参数和一个附加参数，即空间参考系统（SRID）的ID。<code class="codeph">getV$GeometryVal</code>函数将几何转换为SRID指定的空间参照系。 <code class="codeph">sem_inf_capitals</code>函数使用默认的Oracle Spatial和Graph参考系统，WGS84经度 - 纬度，由SRID值8307指定。（有关空间参考系统的RDF语义图支持的更多信息，请参阅<a href="rdf-semantic-graph-overview.html#GUID-3986DFD4-F23A-4379-A859-9EA1F1582D43">空间支持</a> 。）
                        </p>
                        <p>在使用<code class="codeph">getV$GeometryVal</code>函数将WKT值转换为SDO_GEOMETRY类型之后， <code class="codeph">sem_inf_capitals</code>函数将状态几何与城市几何进行比较，以查看状态是否包含城市。<code class="codeph">SDO_RELATE</code>运算符执行此比较，并在状态包含城市时返回文字值<code class="codeph">'TRUE'</code> 。<code class="codeph">SDO_RELATE</code>运算符可以执行各种不同类型的比较。（有关<code class="codeph">SDO_RELATE</code>和其他空间运算符的更多信息，请参阅<a href="../spatl/spatial-operators-reference.html#SPATL110" target="_blank"><span class="italic">Oracle Spatial and Graph Developer's Guide</span></a> 。）
                        </p>
                        <p>要使用<code class="codeph">sem_inf_capitals</code>函数创建一个蕴涵，请向MDSYS用户授予执行权限，然后将函数名称传递给<a href="SEM_APIS-reference.html#GUID-BF52CEC0-1BD9-4908-9EF1-F001B0527257">SEM_APIS.CREATE_ENTAILMENT</a>过程，如下所示：</p><pre class="oac_no_warn" dir="ltr">- 授予适当的权限授予对sem_inf_capitals执行的权限给mdsys; - 创建蕴涵开始sem_apis.create_entailment（'STATES_INF'，sem_models（'STATES'），sem_rulebases（'OWLPRIME'），传递=&gt; SEM_APIS.REACH_CLOSURE，inf_ext_user_func_name =&gt;'sem_inf_capitals'）;结束; /</pre><p>除了由OWLPRIME推断的三元组外，蕴涵还应包含由<code class="codeph">sem_inf_capitals</code>添加的以下三个新三元组：</p><pre class="oac_no_warn" dir="ltr">SPO -------------------------------- ----------------- -------------- -------------------------------- http：// example.org/geo/Colorado http://example.org/geo/capital http://example.org/geo/Denver http://example.org/geo/Utah http://example.org/geo/资本http://example.org/geo/SaltLake http://example.org/geo/Wyoming http://example.org/geo/capital http://example.org/geo/Cheyenne</pre></div>
                     <div>
                        <div class="familylinks">
                           <div class="parentlink">
                              <p><strong>父主题：</strong> <a href="user-defined-inferencing.html#GUID-E2FE95D9-C6A8-4E22-9CAA-85B558E153E2">用户定义的推理扩展函数示例</a></p>
                           </div>
                        </div>
                     </div>
                     
                  </div><a id="RDFRM535"></a><div class="props_rev_3"><a id="GUID-537C3916-D0F0-4909-BC05-50353621C220" name="GUID-537C3916-D0F0-4909-BC05-50353621C220"></a><h5 id="RDFRM-GUID-537C3916-D0F0-4909-BC05-50353621C220" class="sect5"><span class="enumeration_section">7.1.3.6</span>示例6：调用Web服务</h5>
                     <div>
                        <p>此部分包含用户定义的推理扩展功能（ <code class="codeph">sem_inf_geocoding</code> ）和相关的帮助程序（ <code class="codeph">geocoding</code> ），使您可以对Oracle Geocoder服务进行Web服务调用。用户定义的推理扩展函数使用谓词<code class="codeph">&lt;urn:streetAddress&gt;</code>查找三元组的对象值，在<code class="codeph">http://maps.oracle.com/geocoder/gcserver</code>上向Oracle公共Geocoder服务端点发出标注，并插入经度和纬度信息作为两个单独的三元组。
                        </p>
                        <p>例如，假设语义模型包含以下断言：</p><pre class="oac_no_warn" dir="ltr">&lt;urn：NEDC&gt; &lt;urn：streetAddress&gt;“1 Oracle Dr.，Nashua，NH”</pre><p>在这种情况下，使用<code class="codeph">sem_inf_geocoding</code>的推理调用将产生以下新断言：</p><pre class="oac_no_warn" dir="ltr">&lt;urn：NEDC&gt; &lt;http://www.w3.org/2003/01/geo/wgs84_pos#long&gt;“ -  71.46421”&lt;urn：NEDC&gt; &lt;http://www.w3.org/2003/01/ geo / wgs84_pos＃lat&gt;“42.75836”&lt;urn：NEDC&gt; &lt;http://www.opengis.net/geosparql#asWKT&gt;“POINT（-71.46421 42.75836）”^^ &lt;http://www.opengis.net/ geosparql＃wktLiteral&gt; &lt;urn：NEDC&gt; &lt;http://xmlns.oracle.com/rdf/geo/asWKT&gt;“POINT（-71.46421 42.75836）”^^ &lt;http://xmlns.oracle.com/rdf/geo / WKTLiteral&gt;</pre><p><code class="codeph">sem_inf_geocoding</code>函数定义如下：</p><pre class="oac_no_warn" dir="ltr">创建或替换函数sem_inf_geocoding（varchar2中的src_tab_view，varchar2中的resource_id_map_view，varchar2中的output_tab，varchar2中的action，number中的num_calls，数量中的tplInferredLastRound，varchar2中的选项default null，optimization_flag out number，diag_message out varchar2）return boolean as pragma autonomous_transaction; iCount整数; n号码; nLat号码; nWKT号码; nOWKT号码; nStreetAddr号码; sidTab dbms_sql.number_table; oidTab dbms_sql.number_table; vcRequestBody varchar2（32767）; vcStmt varchar2（32767）; vcStreeAddr varchar2（3000）; type cur_type是ref cursor; cursorFind cur_type; vcLong varchar2（100）; vcLat varchar2（100）;开始if（action ='START'）然后nLat：= sdo_sem_inference.oracle_orardf_add_res（'http://www.w3.org/2003/01/geo/wgs84_pos#lat'）; nLong：= sdo_sem_inference.oracle_orardf_add_res（'http://www.w3.org/2003/01/geo/wgs84_pos#long'）; nWKT：= sdo_sem_inference.oracle_orardf_add_res（'http://www.opengis.net/geosparql#asWKT'）; nOWKT：= sdo_sem_inference.oracle_orardf_add_res（'http://xmlns.oracle.com/rdf/geo/asWKT'）;万一; if（action ='RUN'）则nStreetAddr：= sdo_sem_inference.oracle_orardf_res2vid（'&lt;urn：streetAddress&gt;'）; nLat：= sdo_sem_inference.oracle_orardf_res2vid（'http://www.w3.org/2003/01/geo/wgs84_pos#lat'）; nLong：= sdo_sem_inference.oracle_orardf_res2vid（'http://www.w3.org/2003/01/geo/wgs84_pos#long'）; nWKT：= sdo_sem_inference.oracle_orardf_res2vid（'http://www.opengis.net/geosparql#asWKT'）; nOWKT：= sdo_sem_inference.oracle_orardf_res2vid（'http://xmlns.oracle.com/rdf/geo/asWKT'）; vcStmt：='select / * + parallel * / distinct s1.sid as s_id，s1.oid as o_id from'|| src_tab_view || 's1，其中s1.pid =：1且不存在（从'|| src_tab_view ||'x中选择1，其中x.sid = s1.sid和x.pid =：2）';使用nStreetAddr打开cursorFind for vcStmt，nLong; loop fetch cursorFind bulk collection into sidTab，oidTab limit 10000; for in in 1..sidTab.count loop vcStreeAddr：= sdo_sem_inference.oracle_orardf_vid2lit（oidTab（i））; -  dbms_output.put_line（'现在处理街道地址'|| vcStreeAddr）;地理编码（vcStreeAddr，vcLong，vcLat）;立即执行'insert into'|| output_tab || '（sid，pid，oid，gid，s，p，o，g）值（：1，：2，null，null，null，null，：3，null）'使用sidTab（i），nLong，'“ '|| || vcLong'“';立即执行'insert into'|| output_tab || '（sid，pid，oid，gid，s，p，o，g）值（：1，：2，null，null，null，null，：3，null）'使用sidTab（i），nLat，'“ '|| || vcLat'“';立即执行'insert into'|| output_tab || '（sid，pid，oid，gid，s，p，o，g）值（：1，：2，null，null，null，null，：3，null）'使用sidTab（i），nWKT，'“ POINT（'|| vcLong ||''|| vcLat ||'）“^^ &lt;http://www.opengis.net/geosparql#wktLiteral&gt;';立即执行'insert into'|| output_tab || '（sid，pid，oid，gid，s，p，o，g）值（：1，：2，null，null，null，null，：3，null）'使用sidTab（i），nOWKT，'“ POINT（'|| vcLong ||''|| vcLat ||'）“^^ &lt;http://xmlns.oracle.com/rdf/geo/WKTLiteral&gt;';结束循环;当cursorFind％notfound时退出;结束循环;承诺;万一;返回true;结束; / grant在sem_inf_geocoding上执行到mdsys;</pre><p><code class="codeph">sem_inf_geocoding</code>函数使用以下名为<code class="codeph">geocoding</code>帮助程序，该程序与Geocoder Web服务端点进行实际的HTTP通信。请注意，连接到Web服务器需要适当的权限。
                        </p><pre class="oac_no_warn" dir="ltr">创建或替换过程地理编码（addr varchar2，vcLong out varchar2，vcLat out varchar2）as httpReq utl_http.req; httpResp utl_http.resp; vcRequestBody varchar2（32767）; vcBuffer varchar2（32767）; idxLat整数; idxLatEnd整数; begin vcRequestBody：= utl_url.escape（'xml_request = &lt;？xml version =“1.0”standalone =“yes”？&gt; &lt;geocode_request vendor =“elocation”&gt; &lt;address_list&gt; &lt;input_location id =“27010”&gt; &lt;input_address match_mode =“relax_street_type”&gt; &lt;unformatted country =“US”&gt; &lt;address_line value =“'|| addr ||'”/ &gt; &lt;/ unformatted&gt; &lt;/ input_address&gt; &lt;/ input_location&gt; &lt;/ address_list&gt; &lt;/ geocode_request&gt;'）; dbms_output.put_line（'request'|| vcRequestBody）; -  utl_http.set_proxy（'&lt;your_proxy_here_if_necessary&gt;'，null）; httpReq：= utl_http.begin_request（'http://maps.oracle.com/geocoder/gcserver'，'POST'）; utl_http.set_header（httpReq，'Content-Type'，'application / x-www-form-urlencoded'）; utl_http.set_header（httpReq，'Content-Length'，lengthb（vcRequestBody））; utl_http.write_text（httpReq，vcRequestBody）; httpResp：= utl_http.get_response（httpReq）; utl_http.read_text（httpResp，vcBuffer，32767）; utl_http.end_response（httpResp）; -  dbms_output.put_line（'response'|| vcBuffer）; - 这里我们用XML做一些简单的字符串解析。 - 使用XML函数更健壮。idxLat：= instr（vcBuffer，'longitude =“'）; idxLatEnd：= instr（vcBuffer，'”'，idxLat + 12）; vcLong：= substr（vcBuffer，idxLat + 11，idxLatEnd  -  idxLat  -  11）; dbms_output.put_line（'long ='|| vcLong）; idxLat：= instr（vcBuffer，'latitude =“'）; idxLatEnd：= instr（vcBuffer，'”'，idxLat + 11）; vcLat：= substr（vcBuffer，idxLat + 10，idxLatEnd  -  idxLat  -  10）; dbms_output.put_line（'lat ='|| vcLat）;其他人然后dbms_output.put_line（'geocoding：error'|| dbms_utility.format_error_backtrace ||''|| dbms_utility.format_error_stack）;结束; /</pre></div>
                     <div>
                        <div class="familylinks">
                           <div class="parentlink">
                              <p><strong>父主题：</strong> <a href="user-defined-inferencing.html#GUID-E2FE95D9-C6A8-4E22-9CAA-85B558E153E2">用户定义的推理扩展函数示例</a></p>
                           </div>
                        </div>
                     </div>
                     
                  </div>
               </div>
            </div><a id="RDFRM536"></a><div class="props_rev_3"><a id="GUID-26520C46-3A90-40AB-8403-140A82AC73CC" name="GUID-26520C46-3A90-40AB-8403-140A82AC73CC"></a><h3 id="RDFRM-GUID-26520C46-3A90-40AB-8403-140A82AC73CC" class="sect3"><span class="enumeration_section">7.2</span>用户定义的函数和聚合</h3>
               <div>
                  <p>RDF语义图查询扩展体系结构使您能够通过SEM_MATCH表函数和Apache Jena支持添加要在SPARQL查询中使用的用户定义函数和聚合。</p>
                  <p>SPARQL 1.1标准提供了几个主要用于过滤和分类查询获取的数据的函数。但是，您可能需要标准不支持的专用功能。</p>
                  <p>一些简单示例包括查找属于特定类型的值，或获取具有大于特定阈值的平方和值的值。虽然这可以通过组合函数来完成，但是具有处理计算的单个函数可能是有用的，这也允许更简单和更短的查询。</p>
                  <p>RDF语义图查询扩展允许您包含自己的查询函数和聚合。该架构允许：</p>
                  <ul style="list-style-type:disc">
                     <li>
                        <p>自定义查询函数可以像内置的SPARQL查询函数一样使用，如<a href="user-defined-inferencing.html#GUID-7DE220CA-29F0-42FE-A8AB-C13C1998F74F">API对用户定义函数的支持中所述</a></p>
                     </li>
                     <li>
                        <p>可以像内置SPARQL聚合一样使用的自定义聚合，如<a href="user-defined-inferencing.html#GUID-C4701D88-D700-4F89-A28A-BE777BFC31BE">用户定义聚合的API支持中所述</a></p>
                     </li>
                  </ul>
               </div>
               <div>
                  <ul class="ullinks">
                     <li class="ulchildlink"><a href="user-defined-inferencing.html#GUID-120431A3-D767-4068-B1E8-0BFC1C505200">用户定义的函数和聚合的数据类型</a><br></li>
                     <li class="ulchildlink"><a href="user-defined-inferencing.html#GUID-7DE220CA-29F0-42FE-A8AB-C13C1998F74F">用户定义函数的API支持</a><br></li>
                     <li class="ulchildlink"><a href="user-defined-inferencing.html#GUID-C4701D88-D700-4F89-A28A-BE777BFC31BE">用户定义聚合的API支持</a><br></li>
                  </ul>
                  <div class="familylinks">
                     <div class="parentlink">
                        <p><strong>父主题：</strong> <a href="user-defined-inferencing.html#GUID-D5AADFCB-AE87-4028-A7A7-5927D7E9984E" title="RDF Semantic Graph扩展体系结构支持添加用户定义的功能。">用户定义的推理和查询</a></p>
                     </div>
                  </div>
               </div>
               <a id="RDFRM413"></a><div class="props_rev_3"><a id="GUID-120431A3-D767-4068-B1E8-0BFC1C505200" name="GUID-120431A3-D767-4068-B1E8-0BFC1C505200"></a><h4 id="RDFRM-GUID-120431A3-D767-4068-B1E8-0BFC1C505200" class="sect4"><span class="enumeration_section">7.2.1</span>用户定义函数和聚合的数据类型</h4>
                  <div>
                     <p>SDO_RDF_TERM对象类型用于在创建用户定义的函数和聚合时表示RDF术语。</p>
                     <p>SDO_RDF_TERM具有以下属性，这些属性对应于MDSYS.RDF_VALUE $表中的列（有关这些属性的说明，请参阅<a href="rdf-semantic-graph-overview.html#GUID-F7D6E792-CFF4-4183-AECE-3CF4A3332D9E">语句</a>中的<a href="rdf-semantic-graph-overview.html#GUID-F7D6E792-CFF4-4183-AECE-3CF4A3332D9E__CHDBFGII" title="RDF_VALUE $表列">表1-4</a> ）。CTX1属性保留供将来使用，并且在MDSYS.RDF_VALUE $中没有相应的列。
                     </p><pre class="oac_no_warn" dir="ltr">SDO_RDF_TERM（VALUE_TYPE VARCHAR2（10），VALUE_NAME VARCHAR2（4000），VNAME_PREFIX VARCHAR2（4000），VNAME_SUFFIX VARCHAR2（512），LITERAL_TYPE VARCHAR2（1000），LANGUAGE_TYPE VARCHAR2（80），LONG_VALUE CLOB，CTX1 VARCHAR2（4000））</pre><p>以下构造函数可用于创建SDO_RDF_TERM对象。第一个构造函数从单个词汇RDF术语字符串填充每个属性。第二个和第三个构造函数接收单个属性值作为输入。只有第一个RDF术语字符串构造函数为VNAME_PREFIX和VNAME_SUFFIX设置值。其他构造函数将这些值初始化为null。</p><pre class="oac_no_warn" dir="ltr">SDO_RDF_TERM（rdf_term_str VARCHAR2）返回自我; SDO_RDF_TERM（value_type VARCHAR2，value_name VARCHAR2，literal_type VARCHAR2，language_type VARCHAR2，long_value CLOB）RETURN SELF; SDO_RDF_TERM（value_type VARCHAR2，value_name VARCHAR2，literal_type VARCHAR2，language_type VARCHAR2，long_value CLOB，ctx1 VARCHAR2）RETURN SELF;</pre><p><a id="d56111e2035" class="indexterm-anchor"></a> SDO_RDF_TERM_LIST类型用于保存SDO_RDF_TERM对象列表，并定义为<code class="codeph">VARRAY(32767) of SDO_RDF_TERM</code> 。</p>
                  </div>
                  <div>
                     <div class="familylinks">
                        <div class="parentlink">
                           <p><strong>父主题：</strong> <a href="user-defined-inferencing.html#GUID-26520C46-3A90-40AB-8403-140A82AC73CC" title="RDF语义图查询扩展体系结构使您能够通过SEM_MATCH表函数和Apache Jena支持添加要在SPARQL查询中使用的用户定义函数和聚合。">用户定义的函数和聚合</a></p>
                        </div>
                     </div>
                  </div>
                  
               </div><a id="RDFRM537"></a><div class="props_rev_3"><a id="GUID-7DE220CA-29F0-42FE-A8AB-C13C1998F74F" name="GUID-7DE220CA-29F0-42FE-A8AB-C13C1998F74F"></a><h4 id="RDFRM-GUID-7DE220CA-29F0-42FE-A8AB-C13C1998F74F" class="sect4"><span class="enumeration_section">7.2.2</span>用户定义函数的API支持</h4>
                  <div>
                     <p>通过实现具有特定签名的PL / SQL函数来创建用户定义的函数，并使用特定的URI以SPARQL查询模式调用该函数。</p>
                     <p>在每次成功的推理扩展函数调用之后，执行提交以保持在推理扩展函数调用中所做的更改。如果通过指定<code class="codeph">pragma autonomous_transaction</code>将推理扩展函数定义为自治，则它应该在其实现逻辑的末尾提交或回滚。注意，在创建蕴涵时（每轮一次），推理引擎可以多次调用扩展函数。一次通话的提交和回滚不会影响其他通话。
                     </p>
                  </div>
                  <div>
                     <ul class="ullinks">
                        <li class="ulchildlink"><a href="user-defined-inferencing.html#GUID-0FD72275-EF1D-4E4A-A204-D3EAA3E25C73">PL / SQL函数实现</a><br></li>
                        <li class="ulchildlink"><a href="user-defined-inferencing.html#GUID-11A4BB0A-F723-4D1A-8FD5-BCC2CF6F2AFF">从SPARQL查询模式调用用户定义的函数</a><br></li>
                        <li class="ulchildlink"><a href="user-defined-inferencing.html#GUID-87FC6170-3247-4926-B981-EC2672904845">用户定义的函数示例</a><br></li>
                     </ul>
                     <div class="familylinks">
                        <div class="parentlink">
                           <p><strong>父主题：</strong> <a href="user-defined-inferencing.html#GUID-26520C46-3A90-40AB-8403-140A82AC73CC" title="RDF语义图查询扩展体系结构使您能够通过SEM_MATCH表函数和Apache Jena支持添加要在SPARQL查询中使用的用户定义函数和聚合。">用户定义的函数和聚合</a></p>
                        </div>
                     </div>
                  </div>
                  <a id="RDFRM538"></a><div class="props_rev_3"><a id="GUID-0FD72275-EF1D-4E4A-A204-D3EAA3E25C73" name="GUID-0FD72275-EF1D-4E4A-A204-D3EAA3E25C73"></a><h5 id="RDFRM-GUID-0FD72275-EF1D-4E4A-A204-D3EAA3E25C73" class="sect5"><span class="enumeration_section">7.2.2.1</span> PL / SQL函数实现</h5>
                     <div>
                        <p>每个用户定义的函数必须由具有以下格式的签名的PL / SQL函数实现：</p><pre class="oac_no_warn" dir="ltr">功能<span class="italic">user_function_name</span> （参数IN SDO_RDF_TERM_LIST）返回SDO_RDF_TERM</pre><p>此签名支持任意数量的RDF术语参数，这些参数使用单个SDO_RDF_TERM_LIST对象传入，并返回单个RDF术语作为输出，表示为单个SDO_RDF_TERM对象。不执行对这些参数的类型检查或其他验证。您应该根据功能目标采取措施验证数据。</p>
                        <p>请注意，PL / SQL支持对用其他编程语言（如C和Java）编写的函数的调用，因此实现用户定义查询函数的PL / SQL函数只能用作用其他编程语言编写的函数的包装器。</p>
                     </div>
                     <div>
                        <div class="familylinks">
                           <div class="parentlink">
                              <p><strong>父主题：</strong> <a href="user-defined-inferencing.html#GUID-7DE220CA-29F0-42FE-A8AB-C13C1998F74F">用户定义函数的API支持</a></p>
                           </div>
                        </div>
                     </div>
                     
                  </div><a id="RDFRM539"></a><div class="props_rev_3"><a id="GUID-11A4BB0A-F723-4D1A-8FD5-BCC2CF6F2AFF" name="GUID-11A4BB0A-F723-4D1A-8FD5-BCC2CF6F2AFF"></a><h5 id="RDFRM-GUID-11A4BB0A-F723-4D1A-8FD5-BCC2CF6F2AFF" class="sect5"><span class="enumeration_section">7.2.2.2</span>从SPARQL查询模式调用用户定义的函数</h5>
                     <div>
                        <p>在PL / SQL中实现用户定义的函数之后，可以使用从前缀<code class="codeph">&lt;http://xmlns.oracle.com/rdf/extensions/&gt;</code>后跟<span class="italic"><code class="codeph">schema.package_name.function_name</code></span>构造的函数URI从SPARQL查询模式调用它<span class="italic"><code class="codeph">schema.package_name.function_name</code></span>如果相应的PL / SQL函数是PL / SQL包的一部分，则为<span class="italic"><code class="codeph">schema.package_name.function_name</code></span>如果该函数不是PL / SQL包的一部分，则为<span class="italic"><code class="codeph">schema.function_name</code></span> 。以下是两个示例函数URI：</p><pre class="oac_no_warn" dir="ltr">&lt;http://xmlns.oracle.com/rdf/extensions/my_schema.my_package.my_function&gt;（arg_1，...，arg_n）&lt;http://xmlns.oracle.com/rdf/extensions/my_schema.my_function&gt;（arg_1， ...，arg_n）</pre></div>
                     <div>
                        <div class="familylinks">
                           <div class="parentlink">
                              <p><strong>父主题：</strong> <a href="user-defined-inferencing.html#GUID-7DE220CA-29F0-42FE-A8AB-C13C1998F74F">用户定义函数的API支持</a></p>
                           </div>
                        </div>
                     </div>
                     
                  </div><a id="RDFRM541"></a><a id="RDFRM542"></a><a id="RDFRM543"></a><a id="RDFRM544"></a><a id="RDFRM540"></a><div class="props_rev_3"><a id="GUID-87FC6170-3247-4926-B981-EC2672904845" name="GUID-87FC6170-3247-4926-B981-EC2672904845"></a><h5 id="RDFRM-GUID-87FC6170-3247-4926-B981-EC2672904845" class="sect5"><span class="enumeration_section">7.2.2.3</span>用户定义的函数示例</h5>
                     <div>
                        <p>本节介绍用户定义函数的实现示例，以及在FILTER子句，SELECT表达式和BIND操作中使用该函数的示例。</p>
                        <p>对于这些示例，假设此处以N-triple格式呈现的以下数据存在于名为<code class="codeph">MYMODEL</code>的模型中：</p><pre class="oac_no_warn" dir="ltr">&lt;a&gt; &lt;p&gt;“1.0”^^ xsd：double。&lt;b&gt; &lt;p&gt;“1.5”^^ xsd：float。&lt;c&gt; &lt;p&gt;“3”^^ xsd：decimal。&lt;d&gt; &lt;p&gt;“4”^^ xsd：string。
</pre><div class="example" id="GUID-87FC6170-3247-4926-B981-EC2672904845__CHDJEJBI">
                           <p class="titleinexample">例7-1计算两个平方和的用户定义函数</p>
                           <p><a href="user-defined-inferencing.html#GUID-87FC6170-3247-4926-B981-EC2672904845__CHDJEJBI">例7-1</a>显示了一个简单函数的实现，它接收两个值并计算每个值的平方和。
                           </p><pre class="oac_no_warn" dir="ltr">创建或替换函数sum_squares（参数IN MDSYS.SDO_RDF_TERM_LIST）返回MDSYS.SDO_RDF_TERM AS retTerm SDO_RDF_TERM; sqr1 NUMBER; sqr2 NUMBER; addVal NUMBER; val1 SDO_RDF_TERM; val2 SDO_RDF_TERM; BEGIN  - 将返回值设置为null。retTerm：= SDO_RDF_TERM（NULL，NULL，NULL，NULL，NULL）; - 从前两个参数中获取数据。val1：= params（1）; val2：= params（2）; - 将存储在sdo_rdf_term中的值转换为数字。- 如果发生任何异常，则返回null值。BEGIN sqr1：= TO_NUMBER（val1.value_name）; sqr2：= TO_NUMBER（val2.value_name）;当其他人返回retTerm时除外;结束; - 计算两个值的平方和。addVal：=（sqr1 * sqr1）+（sqr2 * sqr2）; - 将返回值设置为所需的rdf术语类型。retTerm：= SDO_RDF_TERM（'LIT'，to_char（addVal），'http：//www.w3.org/2001/XMLSchema#integer'，''，NULL）; - 返回新值。返回retmerm;结束; /显示错误;</pre><p>请注意， <a href="user-defined-inferencing.html#GUID-87FC6170-3247-4926-B981-EC2672904845__CHDJEJBI">示例7-1</a>中的<code class="codeph">sum_squares</code>函数不验证接收值的数据类型。它仅用作演示，并依赖于TO_NUMBER来获取存储在SDO_RDF_TERM的VALUE_NAME字段中的数值。</p>
                        </div>
                        <!-- class="example" -->
                        <div class="example" id="GUID-87FC6170-3247-4926-B981-EC2672904845__CHDBDIAE">
                           <p class="titleinexample">例7-2 FILTER子句中使用的用户定义函数</p>
                           <p><a href="user-defined-inferencing.html#GUID-87FC6170-3247-4926-B981-EC2672904845__CHDBDIAE">例7-2</a>显示了FILTER子句中使用的<code class="codeph">sum_squares</code>函数（来自<a href="user-defined-inferencing.html#GUID-87FC6170-3247-4926-B981-EC2672904845__CHDJEJBI">例7-1</a> ）。
                           </p><pre class="oac_no_warn" dir="ltr">SELECT s，o FROM table（sem_match（'SELECT？'s？在哪里{？s？p？o <span class="bold">FILTER（&lt;http://xmlns.oracle.com/rdf/extensions/schema.sum_squares&gt;（？o，？o）&gt; 2）}'</span> ，sem_models（'MYMODEL'），null，null，null，null， ''））;</pre><p><a href="user-defined-inferencing.html#GUID-87FC6170-3247-4926-B981-EC2672904845__CHDBDIAE">例7-2中</a>的查询返回以下结果：</p><pre class="oac_no_warn" dir="ltr">所以-------------------- -------------------- b 1.5 c 3 d 4</pre></div>
                        <!-- class="example" -->
                        <div class="example" id="GUID-87FC6170-3247-4926-B981-EC2672904845__CHDECBEC">
                           <p class="titleinexample">例7-3 SELECT表达式中使用的用户定义函数</p>
                           <p><a href="user-defined-inferencing.html#GUID-87FC6170-3247-4926-B981-EC2672904845__CHDECBEC">例7-3</a>显示了SELECT子句中表达式中使用的<code class="codeph">sum_squares</code>函数（来自<a href="user-defined-inferencing.html#GUID-87FC6170-3247-4926-B981-EC2672904845__CHDJEJBI">例7-1</a> ）。
                           </p><pre class="oac_no_warn" dir="ltr">SELECT s，o，sqr_sum FROM table（sem_match（'SELECT？'s？o <span class="bold">（&lt;http://xmlns.oracle.com/rdf/extensions/schema.sum_squares&gt;（？o，？o）AS</span> <span class="bold">？sqr_sum）</span> WHERE {？s？p？o}'，sem_models（'MYMODEL'），null，null，null，null，''））;</pre><p><a href="user-defined-inferencing.html#GUID-87FC6170-3247-4926-B981-EC2672904845__CHDECBEC">例7-3中</a>的查询返回以下结果：</p><pre class="oac_no_warn" dir="ltr">所以sqr_sum -------------------- -------------------- -------- ------------ a 1 2 b 1.5 4.5 c 3 18 d 4 32</pre></div>
                        <!-- class="example" -->
                        <div class="example" id="GUID-87FC6170-3247-4926-B981-EC2672904845__CHDHIJBD">
                           <p class="titleinexample">例7-4 BIND操作中使用的用户定义函数</p>
                           <p><a href="user-defined-inferencing.html#GUID-87FC6170-3247-4926-B981-EC2672904845__CHDHIJBD">例7-4</a>显示了BIND操作中使用的<code class="codeph">sum_squares</code>函数（来自<a href="user-defined-inferencing.html#GUID-87FC6170-3247-4926-B981-EC2672904845__CHDJEJBI">例7-1</a> ）。
                           </p><pre class="oac_no_warn" dir="ltr">SELECT s，o，sqr_sum FROM table（sem_match（'SELECT？'s？o？sqr_sum WHERE {？s？p？o。
 <span class="bold">BIND（&lt;http://xmlns.oracle.com/rdf/extensions/schema.sum_squares&gt;（？o，？o）AS</span> <span class="bold">？sqr_sum）}'</span> ，sem_models（'MYMODEL'），null，null，null，null，''））;</pre><p><a href="user-defined-inferencing.html#GUID-87FC6170-3247-4926-B981-EC2672904845__CHDHIJBD">例7-4中</a>的查询返回以下结果：</p><pre class="oac_no_warn" dir="ltr">所以sqr_sum -------------------- -------------------- -------- ------------ a 1 2 b 1.5 4.5 c 3 18 d 4 32</pre></div>
                        <!-- class="example" -->
                     </div>
                     <div>
                        <div class="familylinks">
                           <div class="parentlink">
                              <p><strong>父主题：</strong> <a href="user-defined-inferencing.html#GUID-7DE220CA-29F0-42FE-A8AB-C13C1998F74F">用户定义函数的API支持</a></p>
                           </div>
                        </div>
                     </div>
                     
                  </div>
               </div><a id="RDFRM545"></a><div class="props_rev_3"><a id="GUID-C4701D88-D700-4F89-A28A-BE777BFC31BE" name="GUID-C4701D88-D700-4F89-A28A-BE777BFC31BE"></a><h4 id="RDFRM-GUID-C4701D88-D700-4F89-A28A-BE777BFC31BE" class="sect4"><span class="enumeration_section">7.2.3</span>用户定义聚合的API支持</h4>
                  <div>
                     <p>用户定义的聚合是通过定义实现一组接口方法的PL / SQL对象类型来实现的。创建用户定义的聚合后，将使用特定的URI来调用它。</p>
                  </div>
                  <div>
                     <ul class="ullinks">
                        <li class="ulchildlink"><a href="user-defined-inferencing.html#GUID-842124C0-686B-447A-9B69-63DB8F13D8AE">ODCIAggregate接口</a><br></li>
                        <li class="ulchildlink"><a href="user-defined-inferencing.html#GUID-9AF96B10-4D81-4CB8-8FB4-D4FAB29D553A">调用用户定义的聚合</a><br></li>
                        <li class="ulchildlink"><a href="user-defined-inferencing.html#GUID-FEBC65D8-A766-4B4B-B894-5FFF47C7D24A">用户定义的聚合示例</a><br></li>
                     </ul>
                     <div class="familylinks">
                        <div class="parentlink">
                           <p><strong>父主题：</strong> <a href="user-defined-inferencing.html#GUID-26520C46-3A90-40AB-8403-140A82AC73CC" title="RDF语义图查询扩展体系结构使您能够通过SEM_MATCH表函数和Apache Jena支持添加要在SPARQL查询中使用的用户定义函数和聚合。">用户定义的函数和聚合</a></p>
                        </div>
                     </div>
                  </div>
                  <a id="RDFRM546"></a><div class="props_rev_3"><a id="GUID-842124C0-686B-447A-9B69-63DB8F13D8AE" name="GUID-842124C0-686B-447A-9B69-63DB8F13D8AE"></a><h5 id="RDFRM-GUID-842124C0-686B-447A-9B69-63DB8F13D8AE" class="sect5"><span class="enumeration_section">7.2.3.1</span> ODCIAggregate接口</h5>
                     <div>
                        <p>用户定义的聚合使用<code class="codeph">ODCIAggregate</code> PL / SQL接口。有关此接口的更多详细信息，请参阅<a href="../addci/using-user-defined-aggregate-functions.html#ADDCI2120" target="_blank"><span class="italic">Oracle Database Dataridge Developer's Guide中</span></a>有关用户定义的聚合函数的章节。
                        </p>
                        <p><code class="codeph">ODCIAggregate</code>接口由PL / SQL对象类型实现，该类型实现了四个主要功能：</p>
                        <ul style="list-style-type:disc">
                           <li>
                              <p><code class="codeph">ODCIAggregateInitialize</code></p>
                           </li>
                           <li>
                              <p><code class="codeph">ODCIAggregateIterate</code></p>
                           </li>
                           <li>
                              <p><code class="codeph">ODCIAggregateMerge</code></p>
                           </li>
                           <li>
                              <p><code class="codeph">ODCIAggregateTerminate</code></p>
                           </li>
                        </ul>
                        <p>与用户定义的函数一样（在用户定义函数的<a href="user-defined-inferencing.html#GUID-7DE220CA-29F0-42FE-A8AB-C13C1998F74F">API支持中</a>描述），用户定义的聚合接收任意数量的RDF术语参数，这些参数作为SDO_RDF_TERM_LIST对象传入，并返回单个RDF术语值，即表示为SDO_RDF_TERM对象。
                        </p>
                        <p>此方案导致PL / SQL <code class="codeph">ODCIAggregate</code>接口函数的以下签名（ <span class="italic">my_aggregate_obj_type</span>表示实际的对象类型名称）：</p><pre class="oac_no_warn" dir="ltr">静态函数ODCIAggregateInitialize（sctx IN OUT <span class="italic">my_aggregate_obj_type）RETURN</span> NUMBER成员函数ODCIAggregateIterate（自IN OUT <span class="italic">my_aggregate_obj_type，</span>值IN MDSYS.SDO_RDF_TERM_LIST）RETURN NUMBER成员函数ODCIAggregateMerge（自IN OUT <span class="italic">my_aggregate_obj_type，ctx2</span> IN <span class="italic">my_aggregate_obj_type）RETURN</span> NUMBER成员函数ODCIAggregateTerminate（自IN <span class="italic">my_aggregate_obj_type</span> ，return_value OUT MDSYS.SDO_RDF_TERM，标记IN NUMBER）返回编号</pre></div>
                     <div>
                        <div class="familylinks">
                           <div class="parentlink">
                              <p><strong>父主题：</strong> <a href="user-defined-inferencing.html#GUID-C4701D88-D700-4F89-A28A-BE777BFC31BE">用户定义聚合的API支持</a></p>
                           </div>
                        </div>
                     </div>
                     
                  </div><a id="RDFRM547"></a><div class="props_rev_3"><a id="GUID-9AF96B10-4D81-4CB8-8FB4-D4FAB29D553A" name="GUID-9AF96B10-4D81-4CB8-8FB4-D4FAB29D553A"></a><h5 id="RDFRM-GUID-9AF96B10-4D81-4CB8-8FB4-D4FAB29D553A" class="sect5"><span class="enumeration_section">7.2.3.2</span>调用用户定义的聚合</h5>
                     <div>
                        <p>在PL / SQL中实现用户定义的聚合之后，可以通过引用从前缀<code class="codeph">&lt;http://xmlns.oracle.com/rdf/aggExtensions/&gt;</code>后跟<span class="italic"><code class="codeph">schema_name.aggregate_name</code></span>构造的聚合URI从SPARQL查询调用它。 <span class="italic"><code class="codeph">schema_name.aggregate_name</code></span> 。以下是聚合URI的示例：</p><pre class="oac_no_warn" dir="ltr">&lt;http://xmlns.oracle.com/rdf/aggExtensions/schema.my_aggregate&gt;（arg_1，...，arg_n）</pre><p>DISTINCT修饰符可与用户定义的聚合一起使用，如以下示例所示：</p><pre class="oac_no_warn" dir="ltr">&lt;http://xmlns.oracle.com/rdf/aggExtensions/schema.my_aggregate&gt;（DISTINCT arg_1）</pre><p>在这种情况下，只将不同的参数值传递给聚合。但请注意，DISTINCT修饰符只能与具有一个参数的聚合一起使用。</p>
                     </div>
                     <div>
                        <div class="familylinks">
                           <div class="parentlink">
                              <p><strong>父主题：</strong> <a href="user-defined-inferencing.html#GUID-C4701D88-D700-4F89-A28A-BE777BFC31BE">用户定义聚合的API支持</a></p>
                           </div>
                        </div>
                     </div>
                     
                  </div><a id="RDFRM549"></a><a id="RDFRM553"></a><a id="RDFRM554"></a><a id="RDFRM548"></a><div class="props_rev_3"><a id="GUID-FEBC65D8-A766-4B4B-B894-5FFF47C7D24A" name="GUID-FEBC65D8-A766-4B4B-B894-5FFF47C7D24A"></a><h5 id="RDFRM-GUID-FEBC65D8-A766-4B4B-B894-5FFF47C7D24A" class="sect5"><span class="enumeration_section">7.2.3.3</span>用户定义的聚合示例</h5>
                     <div>
                        <p>本节介绍实现和使用用户定义聚合的示例。对于这些示例，假设此处以N-triple格式呈现的以下数据存在于名为<code class="codeph">MYMODEL</code>的模型中：</p><pre class="oac_no_warn" dir="ltr">&lt;a&gt; &lt;p&gt;“1.0”^^ xsd：double。&lt;b&gt; &lt;p&gt;“1.5”^^ xsd：float。&lt;c&gt; &lt;p&gt;“3”^^ xsd：decimal。&lt;c&gt; &lt;p&gt;“4”^^ xsd：decimal。&lt;d&gt; &lt;p&gt;“4”^^ xsd：string。
</pre><div class="example" id="GUID-FEBC65D8-A766-4B4B-B894-5FFF47C7D24A__CHDCJHHJ">
                           <p class="titleinexample">示例7-5用户定义的聚合实现</p>
                           <p><a href="user-defined-inferencing.html#GUID-FEBC65D8-A766-4B4B-B894-5FFF47C7D24A__CHDCJHHJ">例7-5</a>显示了一个简单的用户定义聚合（ <code class="codeph">countSameType</code> ）的实现。这个聚合有两个参数：第一个是任何RDF术语，第二个是常量数据类型URI。聚合计算来自第一个参数位置的RDF项的数量等于第二个参数的数据类型。
                           </p><pre class="oac_no_warn" dir="ltr">- 聚合类型创建CREATE OR REPLACE TYPE countSameType authid current_user AS OBJECT（count NUMBER， - 用于存储相同类型术语数的变量。- 聚合的强制函数STATIC FUNCTION ODCIAggregateInitialize（sctx IN OUT countSameType）返回编号，成员函数ODCIAggregateIterate（自IN输出countSameType，值IN MDSYS.SDO_RDF_TERM_LIST）返回编号，成员函数ODCIAggregateMerge（自IN输出countSameType，ctx2 IN countSameType）返回NUMBER，MEMBER FUNCTION ODCIAggregateTerminate（自我IN countSameType，return_value OUT MDSYS.SDO_RDF_TERM，标记IN NUMBER）返回数字）; /显示错误; - 用户定义聚合的接口函数CREATE OR REPLACE FUNCTION countSameAs（输入MDSYS.SDO_RDF_TERM_LIST）使用countSameType返回MDSYS.SDO_RDF_TERM PARALLEL_ENABLE AGGREGATE; /显示错误; - 用户定义的聚合体CREATE OR REPLACE TYPE BODY countSameType IS静态函数ODCIAggregateInitialize（sctx IN OUT countSameType）返回数字是BEGIN sctx：= countSameType（0）; - 聚合初始化RETURN ODCIConst。成功;结束;成员函数ODCIAggregateIterate（自IN OUT countSameType，值IN MDSYS.SDO_RDF_TERM_LIST）RETURN NUMBER IS BEGIN  - 如果第一个参数具有文字类型，则递增计数 -  URI等于第二个参数IF的值（value（1）.literal_type = value（2）.value_name）那么self.count：= self.count + 1;万一;返回ODCIConst。成功;结束;成员函数ODCIAggregateMerge（自IN OUT countSameType，ctx2 IN countSameType）返回NUMBER IS BEGIN  - 合并并行线程的总计数。self.count：= self.count + ctx2.count;返回ODCIConst。成功;结束;成员函数ODCIAggregateTerminate（自我IN countSameType，return_value OUT MDSYS.SDO_RDF_TERM，标记IN NUMBER）返回NUMBER是BEGIN  - 设置返回值return_value：= MDSYS.SDO_RDF_TERM（'LIT'，to_char（self.count），'http：/ /www.w3.org/2001/XMLSchema#decimal',NULL,NULL）;返回ODCIConst。成功;结束;结束; /显示错误;</pre></div>
                        <!-- class="example" -->
                        <div class="example" id="GUID-FEBC65D8-A766-4B4B-B894-5FFF47C7D24A__CHDIAJJI">
                           <p class="titleinexample">示例7-6在没有GROUP BY子句的情况下使用的用户定义聚合</p>
                           <p><a href="user-defined-inferencing.html#GUID-FEBC65D8-A766-4B4B-B894-5FFF47C7D24A__CHDIAJJI">例7-6</a>显示了在整个查询结果组中使用的<code class="codeph">countSameType</code>聚合（来自<a href="user-defined-inferencing.html#GUID-FEBC65D8-A766-4B4B-B894-5FFF47C7D24A__CHDCJHHJ">例7-5</a> ）。
                           </p><pre class="oac_no_warn" dir="ltr">FROM o from table（sem_match（'SELECT（ <span class="bold">&lt;http://xmlns.oracle.com/rdf/aggExtensions/schema.countSameType&gt;（？o，xsd：decimal）</span> AS？o）在哪里{？s？p？o}'，sem_models（'MYMODEL'），null，null，null，null，''））;</pre><p><a href="user-defined-inferencing.html#GUID-FEBC65D8-A766-4B4B-B894-5FFF47C7D24A__CHDIAJJI">例7-6中</a>的查询返回以下结果：</p><pre class="oac_no_warn" dir="ltr">o -------------------- 2</pre></div>
                        <!-- class="example" -->
                        <div class="example" id="GUID-FEBC65D8-A766-4B4B-B894-5FFF47C7D24A__CHDHFBHJ">
                           <p class="titleinexample">示例7-7与GROUP BY子句一起使用的用户定义聚合</p>
                           <p><a href="user-defined-inferencing.html#GUID-FEBC65D8-A766-4B4B-B894-5FFF47C7D24A__CHDHFBHJ">例7-7</a>显示了在GROUP BY子句形成的<code class="codeph">countSameType</code>中使用的<code class="codeph">countSameType</code>聚合（来自<a href="user-defined-inferencing.html#GUID-FEBC65D8-A766-4B4B-B894-5FFF47C7D24A__CHDCJHHJ">例7-5</a> ）。
                           </p><pre class="oac_no_warn" dir="ltr">从表中选择s，o（sem_match（'SELECT？s（ <span class="bold">&lt;http://xmlns.oracle.com/rdf/aggExtensions/schema.countSameType&gt;（？o，xsd：decimal）</span> AS？o）在哪里{？s？p？o} <span class="bold">GROUP BY？s'</span> ，sem_models（'MYMODEL'），null，null，null，null，''））;</pre><p><a href="user-defined-inferencing.html#GUID-FEBC65D8-A766-4B4B-B894-5FFF47C7D24A__CHDHFBHJ">例7-7中</a>的查询返回以下结果：</p><pre class="oac_no_warn" dir="ltr">所以-------------------- -------------------- a 0 b 0 c 2 d 0</pre></div>
                        <!-- class="example" -->
                     </div>
                     <div>
                        <div class="familylinks">
                           <div class="parentlink">
                              <p><strong>父主题：</strong> <a href="user-defined-inferencing.html#GUID-C4701D88-D700-4F89-A28A-BE777BFC31BE">用户定义聚合的API支持</a></p>
                           </div>
                        </div>
                     </div>
                     
                  </div>
               </div>
            </div>
         </div>
      </article>
   </body>
</html>