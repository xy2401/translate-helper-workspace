<html lang="en-us" dir="ltr" xml:lang="en-us">
   <head>
      <meta http-equiv="Content-Type" content="text/html; charset=utf-8"></meta>
      <meta name="viewport" content="width=device-width, initial-scale=1"></meta>
      <meta http-equiv="X-UA-Compatible" content="IE=edge"></meta>
      <title>数据仓库中的加载和转换</title>
      <meta property="og:site_name" content="Oracle Help Center"></meta>
      <meta property="og:title" content="Data Warehousing Guide"></meta>
      <meta property="og:description" content=""></meta>
      <link rel="stylesheet" href="/sp_common/book-template/ohc-book-template/css/book.css"></link>
      <link rel="shortcut icon" href="/sp_common/book-template/ohc-common/img/favicon.ico"></link>
      <meta name="application-name" content="Data Warehousing Guide"></meta>
      <meta name="generator" content="DITA Open Toolkit version 1.8.5 (Mode = doc)"></meta>
      <meta name="plugin" content="SP_docbuilder HTML plugin release 18.2.2"></meta>
      <link rel="alternate" href="database-data-warehousing-guide.pdf" title="PDF File" type="application/pdf"></link>
      <meta name="robots" content="all"></meta>
      <link rel="schema.dcterms" href="http://purl.org/dc/terms/"></link>
      <meta name="dcterms.created" content="2019-01-09T00:20:13-08:00"></meta>
      
      <meta name="dcterms.dateCopyrighted" content="2001, 2019"></meta>
      <meta name="dcterms.category" content="database"></meta>
      <meta name="dcterms.identifier" content="E96243-01"></meta>
      
      <meta name="dcterms.product" content="en/database/oracle/oracle-database/19"></meta>
      
      <link rel="prev" href="transportation-data-warehouses.html" title="Previous" type="text/html"></link>
      <link rel="next" href="part-relational-analytics.html" title="Next" type="text/html"></link>
      <script>
        document.write('<style type="text/css">');
        document.write('body > .noscript, body > .noscript ~ * { visibility: hidden; }');
        document.write('</style>');
     </script>
      <script src="/sp_common/book-template/requirejs/require.js" data-main="/sp_common/book-template/ohc-book-template/js/book-config"></script>
      <script>
            if (window.require === undefined) {
                document.write('<script data-main="sp_common/book-template/ohc-book-template/js/book-config" src="sp_common/book-template/requirejs/require.js"><\/script>');
                document.write('<link href="sp_common/book-template/ohc-book-template/css/book.css" rel="stylesheet"/>');
            }
        </script>
      <script type="application/json" id="ssot-metadata">{"primary":{"category":{"short_name":"database","element_name":"Database","display_in_url":true},"suite":{"short_name":"oracle","element_name":"Oracle","display_in_url":true},"product_group":{"short_name":"not-applicable","element_name":"Not applicable","display_in_url":false},"product":{"short_name":"oracle-database","element_name":"Oracle Database","display_in_url":true},"release":{"short_name":"19","element_name":"Release 19","display_in_url":true}}}</script>
      
    <meta name="dcterms.title" content="Database Data Warehousing Guide"></meta>
    <meta name="dcterms.isVersionOf" content="DWHSG"></meta>
    <meta name="dcterms.release" content="Release 19"></meta>
  </head>
   <body dir="ltr">
      <div class="noscript alert alert-danger text-center" role="alert">
         <a href="transportation-data-warehouses.html" class="pull-left"><span class="glyphicon glyphicon-chevron-left" aria-hidden="true"></span>上一页</a> <a href="part-relational-analytics.html" class="pull-right">下一页<span class="glyphicon glyphicon-chevron-right" aria-hidden="true"></span></a> <span class="fa fa-exclamation-triangle" aria-hidden="true"></span>必须启用JavaScript才能正确显示此内容</div>
      <article>
         <header>
            <ol class="breadcrumb" vocab="http://schema.org/" typeof="BreadcrumbList">
               <li property="itemListElement" typeof="ListItem"><a href="index.html" property="item" typeof="WebPage"><span property="name">数据仓库指南</span></a></li>
               <li property="itemListElement" typeof="ListItem"><a href="part-etl.html" property="item" typeof="WebPage"><span property="name">数据移动/ ETL</span></a></li>
               <li class="active" property="itemListElement" typeof="ListItem">数据仓库中的加载和转换</li>
            </ol>
            <a id="GUID-5B2CC8B6-8503-4B41-A75E-79A4925FCE4B" name="GUID-5B2CC8B6-8503-4B41-A75E-79A4925FCE4B"></a>
            
            <h2 id="DWHSG-GUID-5B2CC8B6-8503-4B41-A75E-79A4925FCE4B" class="sect2"><span class="enumeration_chapter">18</span>数据仓库的加载和转换</h2>
         </header>
         <div class="ind">
            <div>
               <p>本章帮助您创建和管理数据仓库，并讨论：</p>
               <ul style="list-style-type:disc">
                  <li>
                     <p><a href="loading-transformation-date-warehouses.html#GUID-D3F12AE4-CF2B-4F67-B027-C3CD7B86E9F1" title="您可以使用EXECUTE_UPDATE过程优化表的批量更新。由于更新未记录在重做日志中，因此性能得到优化。由于ETL可能变得复杂并且性能较差，因此Oracle数据库提供了一个用户界面，使您可以监视和报告作为ETL计划一部分的数据库操作。">数据仓库中的加载和转换概述</a></p>
                  </li>
                  <li>
                     <p><a href="loading-transformation-date-warehouses.html#GUID-6DECC3F7-758E-45E3-88EE-F2B740AB7C13">数据仓库的加载机制</a></p>
                  </li>
                  <li>
                     <p><a href="loading-transformation-date-warehouses.html#GUID-D8DA5FB4-7F4C-42C5-828D-9150A5699186">数据仓库中的转换机制</a></p>
                  </li>
                  <li>
                     <p><a href="loading-transformation-date-warehouses.html#GUID-DAD3F208-A1CB-4491-8D61-D4640B51286A" title="在数据转换过程中使用的外部数据有时可能不准确，从而导致数据转换错误。某些SQL函数可用于处理数据转换错误。">错误记录和处理机制</a></p>
                  </li>
                  <li>
                     <p><a href="loading-transformation-date-warehouses.html#GUID-DD11528E-EE2A-4640-B8F1-75E6D3EB08F6">加载和转换方案</a></p>
                  </li>
               </ul>
            </div><a id="DWHSG8304"></a><div class="props_rev_3"><a id="GUID-D3F12AE4-CF2B-4F67-B027-C3CD7B86E9F1" name="GUID-D3F12AE4-CF2B-4F67-B027-C3CD7B86E9F1"></a><h3 id="DWHSG-GUID-D3F12AE4-CF2B-4F67-B027-C3CD7B86E9F1" class="sect3"><span class="enumeration_section">18.1</span>数据仓库中的加载和转换概述</h3>
               <div>
                  <p><a id="d63021e75" class="indexterm-anchor"></a>数据转换通常是最复杂的，就处理时间而言，是提取，转换和加载（ETL）过程中成本最高的部分。它们的范围从简单的数据转换到极其复杂的数据清理技术。许多（如果不是全部）数据转换可以在Oracle数据库中发生，尽管转换通常也在数据库外部实现（例如，在平面文件上）。
                  </p>
                  <p>本章介绍了在Oracle数据库中实现可伸缩和高效数据转换的技术。本章中的示例相对简单。现实世界的数据转换通常要复杂得多。但是，本章介绍的转换技术可满足大多数实际数据转换要求，通常比其他方法具有更高的可扩展性和更少的编程。</p>
                  <p>本章并未试图说明在数据仓库中遇到的所有典型转换，而是为了演示可用于实现这些转换的基础技术类型，并提供如何选择最佳技术的指导。</p>
               </div><a id="DWHSG8305"></a><div class="props_rev_3"><a id="GUID-1B38D45D-1860-44D6-98A4-9B089C4759A5" name="GUID-1B38D45D-1860-44D6-98A4-9B089C4759A5"></a><h4 id="DWHSG-GUID-1B38D45D-1860-44D6-98A4-9B089C4759A5" class="sect4"><span class="enumeration_section">18.1.1</span>数据仓库：转换流程</h4>
                  <div>
                     <p>从体系结构的角度来看，您可以通过以下方式转换数据：</p>
                     <ul style="list-style-type:disc">
                        <li>
                           <p><a href="loading-transformation-date-warehouses.html#GUID-AF6D2F31-0BAE-421E-A812-62D38C3645B8">数据仓库中的多级数据转换</a></p>
                        </li>
                        <li>
                           <p><a href="loading-transformation-date-warehouses.html#GUID-FA110310-B713-4165-8F48-EC5E869E1F8F">数据仓库中的流水线数据转换</a></p>
                        </li>
                        <li>
                           <p><a href="loading-transformation-date-warehouses.html#GUID-48A039BC-D1EC-4E6A-9552-E3DFDA33D4E4">数据仓库中的暂存区域</a></p>
                        </li>
                     </ul>
                  </div><a id="DWHSG8307"></a><a id="DWHSG8306"></a><div class="props_rev_3"><a id="GUID-AF6D2F31-0BAE-421E-A812-62D38C3645B8" name="GUID-AF6D2F31-0BAE-421E-A812-62D38C3645B8"></a><h5 id="DWHSG-GUID-AF6D2F31-0BAE-421E-A812-62D38C3645B8" class="sect5"><span class="enumeration_section">18.1.1.1</span>数据仓库中的多级数据转换</h5>
                     <div>
                        <p>数据<a id="d63021e143" class="indexterm-anchor"></a>大多数数据仓库的转换逻辑包含多个步骤。例如，在转换要插入到销售表中的新记录时，可能存在单独的逻辑转换步骤来验证每个维度密钥。
                        </p>
                        <p><a href="loading-transformation-date-warehouses.html#GUID-AF6D2F31-0BAE-421E-A812-62D38C3645B8__BABCAHAJ">图18-1</a>提供了查看转换逻辑的图形方式。
                        </p>
                        <div class="figure" id="GUID-AF6D2F31-0BAE-421E-A812-62D38C3645B8__BABCAHAJ">
                           <p class="titleinfigure">图18-1多级数据转换</p><img src="img/dwhsg025.gif" alt="下面是图18-1的描述" title="下面是图18-1的描述" longdesc="img_text/dwhsg025.html"><br><a href="img_text/dwhsg025.html">“图18-1多级数据转换”的描述</a></div>
                        <!-- class="figure" -->
                        <p>使用Oracle数据库作为转换引擎时，常见的策略是将每个转换实现为单独的SQL操作，并创建单独的临时临时表（ <a href="loading-transformation-date-warehouses.html#GUID-AF6D2F31-0BAE-421E-A812-62D38C3645B8__BABCAHAJ">如图18-1中</a>的表<code class="codeph">new_sales_step1</code>和<code class="codeph">new_sales_step2</code> ）以存储增量结果每一步。此加载 - 转换策略还为整个转换过程提供了一种自然的检查点方案，使得流程更容易监控和重新启动。然而，多级管理的缺点是空间和时间要求增加。
                        </p>
                        <p>也可以将许多简单的逻辑转换组合成单个SQL语句或单个PL / SQL过程。这样做可以提供比独立执行每个步骤更好的性能，但是它也可能在修改，添加或删除单个转换以及从失败的转换中恢复时带来困难。</p>
                     </div>
                  </div><a id="DWHSG8309"></a><a id="DWHSG8308"></a><div class="props_rev_3"><a id="GUID-FA110310-B713-4165-8F48-EC5E869E1F8F" name="GUID-FA110310-B713-4165-8F48-EC5E869E1F8F"></a><h5 id="DWHSG-GUID-FA110310-B713-4165-8F48-EC5E869E1F8F" class="sect5"><span class="enumeration_section">18.1.1.2</span>数据仓库中的流水线数据转换</h5>
                     <div>
                        <p>ETL流程可以显着改变，数据库成为ETL解决方案不可或缺的一部分<a id="d63021e191" class="indexterm-anchor"></a> 。
                        </p>
                        <p>新功能使一些先前必要的处理步骤过时，而其他一些可以被重新构建以增强数据流和数据转换以变得更具可扩展性和非中断性。任务从串行转换然后加载过程（大部分任务在数据库之外完成）或加载然后转换过程转变为增强的转换同时加载。</p>
                        <p>Oracle提供了各种新功能来解决ETL方案中的所有相关问题和任务。重要的是要了解数据库提供工具包功能，而不是试图解决一个通用的解决方案。底层数据库必须为特定客户需求启用最合适的ETL流程，而不是从技术角度决定或约束它。<a href="loading-transformation-date-warehouses.html#GUID-FA110310-B713-4165-8F48-EC5E869E1F8F__I1007647">图18-2</a>说明了新功能，将在后面的章节中讨论。
                        </p>
                        <div class="figure" id="GUID-FA110310-B713-4165-8F48-EC5E869E1F8F__I1007647">
                           <p class="titleinfigure">图18-2流水线数据转换</p><img src="img/dwhsg107.gif" alt="下面是图18-2的描述" title="下面是图18-2的描述" longdesc="img_text/dwhsg107.html"><br><a href="img_text/dwhsg107.html">“图18-2流水线数据转换”的描述</a></div>
                        <!-- class="figure" -->
                     </div>
                  </div><a id="DWHSG8953"></a><div class="props_rev_3"><a id="GUID-48A039BC-D1EC-4E6A-9552-E3DFDA33D4E4" name="GUID-48A039BC-D1EC-4E6A-9552-E3DFDA33D4E4"></a><h5 id="DWHSG-GUID-48A039BC-D1EC-4E6A-9552-E3DFDA33D4E4" class="sect5"><span class="enumeration_section">18.1.1.3</span>数据仓库中的临时区域</h5>
                     <div>
                        <p>负载的总体速度取决于从暂存区域读取原始数据并将其写入数据库中的目标表的速度。强烈建议您将原始数据放在尽可能多的物理磁盘上，以确保在加载过程中读取原始数据不是瓶颈。</p>
                        <p>在数据库文件系统（DBFS）中，存储数据的绝佳位置。DBFS创建一个可安装的文件系统，可用于以SecureFiles LOB的形式访问存储在数据库中的文件。DBFS与NFS类似，它提供了一个看起来像本地文件系统的共享网络文件系统。Oracle建议您在与数据仓库不同的数据库中创建DBFS，并使用<code class="codeph">DIRECT_IO</code>选项挂载文件系统，以避免在将原始数据文件移入和移出文件系统时争用系统页面缓存。有关设置DBFS的更多信息，请参阅<a href="../adlob/introducing-database-file-system.html#ADLOB-GUID-B7A83817-F0D6-4A09-AE98-DFC966783109" target="_blank"><span><cite>Oracle Database SecureFiles和Large Objects Developer's Guide</cite></span></a> 。
                        </p>
                     </div>
                  </div>
               </div>
               <div class="sect3"><a id="GUID-44B2D063-DAC4-4CFC-A776-FF501AAEDEE7" name="GUID-44B2D063-DAC4-4CFC-A776-FF501AAEDEE7"></a><h4 id="DWHSG-GUID-44B2D063-DAC4-4CFC-A776-FF501AAEDEE7" class="sect4"><span class="enumeration_section">18.1.2</span>关于批量更新和联机表重新定义</h4>
                  <div>
                     <p>您可以使用<code class="codeph">EXECUTE_UPDATE</code>过程优化表的批量更新。由于更新未记录在重做日志中，因此性能得到优化。
                     </p>
                     <p></p>
                     <p><code class="codeph">DBMS_REDEFINITION.EXECUTE_UPDATE</code>过程允许您以直接插入模式运行<code class="codeph">UPDATE</code>语句。由于在此操作期间未记录重做，因此无法使用介质恢复来恢复重新定义和数据更新。为了保持可恢复性，建议在重新定义开始之前执行数据库或表空间备份。
                     </p>
                     <div class="infoboxnotealso" id="GUID-44B2D063-DAC4-4CFC-A776-FF501AAEDEE7__GUID-70324A39-FCDF-4E13-BECE-682BCC0A7421">
                        <p class="notep1">也可以看看：</p>
                        <p><a href="../admin/managing-tables.html#ADMIN-GUID-43794F5A-1B13-4E97-B4DD-31AEB9633E9A" target="_blank"><span><cite>Oracle数据库管理员指南</cite></span></a></p>
                     </div>
                  </div>
               </div>
               <div class="sect3"><a id="GUID-D66210E5-9F35-45C8-B310-FC4D764B4FEC" name="GUID-D66210E5-9F35-45C8-B310-FC4D764B4FEC"></a><h4 id="DWHSG-GUID-D66210E5-9F35-45C8-B310-FC4D764B4FEC" class="sect4"><span class="enumeration_section">18.1.3</span>监控ETL操作概述</h4>
                  <div>
                     <p>由于ETL可能变得复杂并且性能较差，因此Oracle数据库提供了一个用户界面，使您可以监视和报告作为ETL计划一部分的数据库操作。</p>
                     <p></p>
                     <p>数据库操作是用户定义的逻辑对象，其包含一组相关的数据库任务，例如由最终用户或应用程序代码定义的ETL处理作业。每个数据库操作由其名称和执行ID唯一标识，并且可以多次执行。</p>
                     <p>数据库操作监视对于对次优执行作业进行故障排除非常有用，并有助于确定在任何给定步骤中消耗的资源的位置和数量。它使您能够跟踪相关信息，识别性能瓶颈，并减少调整数据库性能问题的时间。从Oracle Database 12 <span class="italic">c</span>第2版（12.2）开始，您可以通过在<code class="codeph">DBMS_SQL_MONITOR.BEGIN_OPERATION</code>函数中指定其会话ID和序列号，在任意会话上开始数据库操作。
                     </p>
                     <div class="infoboxnotealso" id="GUID-D66210E5-9F35-45C8-B310-FC4D764B4FEC__GUID-B74F4813-535B-4F44-BD16-88C9C9499433">
                        <p class="notep1">也可以看看：</p>
                        <p><a href="../tgsql/monitoring-database-operations.html#TGSQL-GUID-007E5BAE-B07D-4BD1-9485-DE8D260BF862" target="_blank"><span><cite>Oracle数据库SQL调优指南</cite></span></a></p>
                     </div>
                  </div>
               </div>
            </div><a id="DWHSG8310"></a><div class="props_rev_3"><a id="GUID-6DECC3F7-758E-45E3-88EE-F2B740AB7C13" name="GUID-6DECC3F7-758E-45E3-88EE-F2B740AB7C13"></a><h3 id="DWHSG-GUID-6DECC3F7-758E-45E3-88EE-F2B740AB7C13" class="sect3"><span class="enumeration_section">18.2</span>数据仓库的加载机制</h3>
               <div>
                  <p>您可以使用以下机制来加载数据仓库：</p>
                  <ul style="list-style-type:disc">
                     <li>
                        <p><a href="loading-transformation-date-warehouses.html#GUID-075B9E66-3C42-4164-BF70-B144C0BEC4F0">使用SQL * Loader加载数据仓库</a></p>
                     </li>
                     <li>
                        <p><a href="loading-transformation-date-warehouses.html#GUID-0C48B004-54C8-48A3-BBF8-6C69BB19F15E">使用外部表加载数据仓库</a></p>
                     </li>
                     <li>
                        <p><a href="loading-transformation-date-warehouses.html#GUID-16CA33C9-77A1-494A-8170-F4703D2C0447">使用OCI和Direct-Path API加载数据仓库</a></p>
                     </li>
                     <li>
                        <p><a href="loading-transformation-date-warehouses.html#GUID-5904B997-7D60-4553-82CA-91709E040F5A">使用导出/导入加载数据仓库</a></p>
                     </li>
                  </ul>
               </div><a id="DWHSG8311"></a><div class="props_rev_3"><a id="GUID-075B9E66-3C42-4164-BF70-B144C0BEC4F0" name="GUID-075B9E66-3C42-4164-BF70-B144C0BEC4F0"></a><h4 id="DWHSG-GUID-075B9E66-3C42-4164-BF70-B144C0BEC4F0" class="sect4"><span class="enumeration_section">18.2.1</span>使用SQL * Loader加载数据仓库</h4>
                  <div>
                     <div class="section">
                        <p><a id="d63021e396" class="indexterm-anchor"></a>在数据库中发生任何数据转换之前，必须可以访问数据库的原始数据。一种方法是将其加载到数据库中。<a href="transportation-data-warehouses.html#GUID-3CC5E89C-A354-4F58-BC2A-D9DF439357E5">数据仓库中的运输</a> ，讨论了将数据传输到Oracle数据仓库的几种技术。也许最常用的传输数据的技术是通过平面文件。
                        </p>
                        <p>SQL * Loader用于将数据从平面文件移动到Oracle数据仓库中。在此数据加载期间，SQL * Loader也可用于实现基本数据转换。使用直接路径SQL * Loader时，可以在数据加载期间自动解决基本数据操作，例如数据类型转换和简单<code class="codeph">NULL</code>处理。出于性能原因，大多数数据仓库都使用直接路径加载。
                        </p>
                        <p>传统路径加载器提供了比直接路径加载器更广泛的数据转换功能：SQL函数可以在加载这些值时应用于任何列。这为数据加载期间的转换提供了丰富的功能。但是，传统路径加载器比直接路径加载器慢。由于这些原因，传统路径加载器应主要用于加载和转换少量数据。</p>
                        <p>数据仓库可以使用直接路径模式来运行批量更新，以避免维护重做数据的开销。您可以在联机表重新定义期间在表上运行批量更新。</p>
                        <p>以下是一个SQL * Loader控制文件的简单示例，用于将数据从外部文件<code class="codeph">sh_sales.dat</code>加载到<code class="codeph">sh</code>示例模式的<code class="codeph">sales</code>表中。外部平面文件<code class="codeph">sh_sales.dat</code>由销售交易数据组成，每日汇总。并非此外部文件的所有列都已加载到<code class="codeph">sales</code> 。此外部文件还用作加载<code class="codeph">sh</code>示例模式的第二个事实表的源，这是使用外部表完成的：</p>
                        <p>以下显示加载<code class="codeph">sales</code>表的控制文件（ <code class="codeph">sh_sales.ctl</code> ）：</p><pre class="oac_no_warn" dir="ltr">LOAD DATA INFILE sh_sales.dat APPEND INTO TABLE sales FIELDS TERMINATED BY“|” （PROD_ID，CUST_ID，TIME_ID，CHANNEL_ID，PROMO_ID，QUANTITY_SOLD，AMOUNT_SOLD）</pre><p>可以使用以下命令加载它：</p><pre class="oac_no_warn" dir="ltr">$ sqlldr control = sh_sales.ctl direct = true用户名：密码：</pre><p>对于SQL * Loader Express模式，您不使用控制文件。相反，它使用表列定义来确定输入数据类型。</p>
                        <div class="infoboxnotealso" id="GUID-075B9E66-3C42-4164-BF70-B144C0BEC4F0__GUID-9803962C-26EA-41CC-B137-F26225C73761">
                           <p class="notep1">也可以看看：</p>
                           <ul style="list-style-type:disc">
                              <li>
                                 <p><a href="../sutil/oracle-sql-loader-commands.html#SUTIL-GUID-CD662CD8-DAA7-4A30-BC84-546E4C40DB31" target="_blank"><span><cite>Oracle数据库实用程序</cite></span></a>以获取更多信息</p>
                              </li>
                              <li>
                                 <p>有关使用<code class="codeph">DBMS_REDEFINITION</code>包进行批量更新的信息，请<code class="codeph">DBMS_REDEFINITION</code> <a href="../admin/managing-tables.html#ADMIN-GUID-43794F5A-1B13-4E97-B4DD-31AEB9633E9A" target="_blank"><span><cite>“Oracle数据库管理员指南”</cite></span></a></p>
                              </li>
                           </ul>
                        </div>
                     </div>
                     <!-- class="section" -->
                  </div>
               </div><a id="DWHSG8312"></a><div class="props_rev_3"><a id="GUID-0C48B004-54C8-48A3-BBF8-6C69BB19F15E" name="GUID-0C48B004-54C8-48A3-BBF8-6C69BB19F15E"></a><h4 id="DWHSG-GUID-0C48B004-54C8-48A3-BBF8-6C69BB19F15E" class="sect4"><span class="enumeration_section">18.2.2</span>使用外部表加载数据仓库</h4>
                  <div>
                     <div class="section">
                        <p>另一个处理外部数据源的方法是使用外部表。Oracle的外部表功能使您可以将外部数据用作可以直接和并行查询和连接的虚拟表，而无需首先在数据库中加载外部数据。然后，您可以使用SQL，PL / SQL和Java来访问外部数据。
                        </p>
                        <p></p>
                        <p>外部表格可以使转换阶段的加载阶段流水线化。转换过程可以与加载过程合并，而不会中断数据流。不再需要在数据库中对数据进行分级以在数据库内进行进一步处理，例如比较或转换。例如，传统加载的转换功能可以用于直接路径<code class="codeph">INSERT</code> <code class="codeph">AS</code> <code class="codeph">SELECT</code>语句以及来自外部表的<code class="codeph">SELECT</code> 。Oracle数据库<span class="italic">12c</span>中开始，数据库自动收集的统计信息表作为批量负荷运转（CTAS和IAS）类似于如何创建索引时收集统计的一部分。通过在数据加载期间收集统计信息，您可以避免其他扫描操作，并在数据可供用户使用后立即提供必要的统计信息。
                        </p>
                        <p>外部表和常规表之间的主要区别在于外部组织的表是只读的。没有DML操作（ <code class="codeph">UPDATE</code> / <code class="codeph">INSERT</code> / <code class="codeph">DELETE</code> ）是可能的，并且不能在它们上创建索引。
                        </p>
                        <p>外部表大多符合现有的SQL * Loader功能，并在大多数情况下提供卓越的功能。外部表对于必须与现有数据库对象连接完整外部源或必须以复杂方式转换数据的环境特别有用。例如，与SQL * Loader不同，您可以应用任意SQL转换并使用直接路径插入方法。此外，您可以指定要执行的程序（例如<code class="codeph">zcat</code> ）来处理文件（例如压缩数据文件）并使Oracle数据库能够使用输出（例如未压缩的数据文件），这意味着您可以加载大量的压缩数据，而不先将其解压缩到磁盘上。
                        </p>
                        <p>您可以创建名为<code class="codeph">sales_transactions_ext</code>的外部表，表示完整销售事务数据的结构，在外部文件<code class="codeph">sh_sales.gz</code> 。产品部门对产品和时间的成本分析特别感兴趣。因此，您在<code class="codeph">sh</code>模式中创建了一个名为<code class="codeph">cost</code>的事实表。操作源数据与<code class="codeph">sales</code>事实表相同。但是，由于您没有调查所提供的每个维度信息，因此<code class="codeph">cost</code>事实表中的数据具有比<code class="codeph">sales</code>事实表中更粗略的粒度，例如，汇总了所有不同的分销渠道。
                        </p>
                        <p>由于抑制了某些维度，您无法在不应用前面提到的详细信息汇总的情况下将数据加载到<code class="codeph">cost</code>事实表中。
                        </p>
                        <p>外部表框架提供了解决此问题的解决方案。与SQL * Loader不同，您必须在应用聚合之前加载数据，您可以在单个SQL DML语句中组合加载和转换，如下所示。在插入目标表之前，您不必临时暂存数据。</p>
                        <p>对象目录必须已存在，并指向包含<code class="codeph">sh_sales.gz</code>文件的目录以及包含错误和日志文件的目录。
                        </p><pre class="oac_no_warn" dir="ltr">CREATE TABLE sales_transactions_ext（PROD_ID NUMBER，CUST_ID NUMBER，TIME_ID DATE，CHANNEL_ID NUMBER，PROMO_ID NUMBER，QUANTITY_SOLD NUMBER，AMOUNT_SOLD NUMBER（10,2），UNIT_COST NUMBER（10,2），UNIT_PRICE NUMBER（10,2））ORGANIZATION external（TYPE oracle_loader DEFAULT DIRECTORY data_file_dir访问参数（记录由NEWLINE CHARACTERSET删除US7ASCII预处理程序执行：'zcat'BADFILE log_file_dir：'sh_sales.bad_xt'logFILE log_file_dir：'sh_sales.log_xt'FIELDS TERMINATED BY“|”LDRTRIM（PROD_ID，CUST_ID，TIME_ID DATE（ 10）“YYYY-MM-DD”，CHANNEL_ID，PROMO_ID，QUANTITY_SOLD，AMOUNT_SOLD，UNIT_COST，UNIT_PRICE））location（'sh_sales.gz'））REJECT LIMIT UNLIMITED;</pre><p>现在可以在数据库中使用外部表，仅访问外部数据的某些列，对数据进行分组，并将其插入到<code class="codeph">costs</code>事实表中：</p><pre class="oac_no_warn" dir="ltr">INSERT / * + APPEND * / INTO COSTS（TIME_ID，PROD_ID，UNIT_COST，UNIT_PRICE）SELECT TIME_ID，PROD_ID，AVG（UNIT_COST），AVG（amount_sold / quantity_sold）FROM sales_transactions_ext GROUP BY time_id，prod_id;</pre><div class="infoboxnotealso" id="GUID-0C48B004-54C8-48A3-BBF8-6C69BB19F15E__GUID-0B77661A-7303-4873-B184-AAB8294FC45E">
                           <p class="notep1">也可以看看：</p>
                           <ul style="list-style-type:disc">
                              <li>
                                 <p>有关外部表语法的完整说明，请<a href="../sqlrf/ALTER-TABLE.html#SQLRF53428" target="_blank"><span class="italic">参见Oracle数据库SQL语言参考</span></a></p>
                              </li>
                              <li>
                                 <p><a href="../sutil/oracle-sql-loader-concepts.html#SUTIL995" target="_blank"><span class="italic">Oracle数据库实用程序</span></a>的用例</p>
                              </li>
                           </ul>
                        </div>
                     </div>
                     <!-- class="section" -->
                  </div>
               </div><a id="DWHSG8313"></a><div class="props_rev_3"><a id="GUID-16CA33C9-77A1-494A-8170-F4703D2C0447" name="GUID-16CA33C9-77A1-494A-8170-F4703D2C0447"></a><h4 id="DWHSG-GUID-16CA33C9-77A1-494A-8170-F4703D2C0447" class="sect4"><span class="enumeration_section">18.2.3</span>使用OCI和Direct-Path API加载数据仓库</h4>
                  <div>
                     <p>当转换和计算在数据库外部完成并且不需要平面文件暂存时，经常使用OCI和直接路径API。</p>
                  </div>
               </div><a id="DWHSG8314"></a><div class="props_rev_3"><a id="GUID-5904B997-7D60-4553-82CA-91709E040F5A" name="GUID-5904B997-7D60-4553-82CA-91709E040F5A"></a><h4 id="DWHSG-GUID-5904B997-7D60-4553-82CA-91709E040F5A" class="sect4"><span class="enumeration_section">18.2.4</span>使用导出/导入加载数据仓库</h4>
                  <div>
                     <p>将数据按原样插入目标系统时，将使用导出和导入。没有复杂的提取是可能的。有关详细信息，请参阅<a href="extraction-data-warehouses.html#GUID-7C9793D3-10E7-40BB-80FF-627C7160D044">数据仓库中的提取</a> 。
                     </p>
                  </div>
               </div>
            </div><a id="DWHSG8315"></a><div class="props_rev_3"><a id="GUID-D8DA5FB4-7F4C-42C5-828D-9150A5699186" name="GUID-D8DA5FB4-7F4C-42C5-828D-9150A5699186"></a><h3 id="DWHSG-GUID-D8DA5FB4-7F4C-42C5-828D-9150A5699186" class="sect3"><span class="enumeration_section">18.3</span>数据仓库中的转换机制</h3>
               <div>
                  <p>您可以使用以下选项来转换数据库中的数据：</p>
                  <ul style="list-style-type:disc">
                     <li>
                        <p><a href="loading-transformation-date-warehouses.html#GUID-E1BA12C1-5CE7-405C-8BC7-745ADE615E90">使用SQL转换数据</a></p>
                     </li>
                     <li>
                        <p><a href="loading-transformation-date-warehouses.html#GUID-11660715-44A7-4687-8E4B-2C18B8339A1D">使用PL / SQL转换数据</a></p>
                     </li>
                     <li>
                        <p><a href="loading-transformation-date-warehouses.html#GUID-98157B1C-86EC-4888-9760-DB0164D2A832">使用表函数转换数据</a></p>
                     </li>
                  </ul>
               </div><a id="DWHSG8316"></a><div class="props_rev_3"><a id="GUID-E1BA12C1-5CE7-405C-8BC7-745ADE615E90" name="GUID-E1BA12C1-5CE7-405C-8BC7-745ADE615E90"></a><h4 id="DWHSG-GUID-E1BA12C1-5CE7-405C-8BC7-745ADE615E90" class="sect4"><span class="enumeration_section">18.3.1</span>使用SQL转换数据</h4>
                  <div>
                     <div class="section">
                        <p><a id="d63021e713" class="indexterm-anchor"></a>将数据加载到数据库后，可以使用SQL操作执行数据转换。实现SQL数据转换有四种基本技术：</p>
                     </div>
                     <!-- class="section" -->
                     <div class="section">
                        <ul style="list-style-type:disc">
                           <li>
                              <p><a href="loading-transformation-date-warehouses.html#GUID-DB1E72E7-5ED6-4BA6-A133-DAD16932E5A0">创建表...AS SELECT和INSERT / * + APPEND * / AS SELECT</a></p>
                           </li>
                           <li>
                              <p><a href="loading-transformation-date-warehouses.html#GUID-7463003E-2689-4469-8ED9-77BBA5BC2A00">使用UPDATE转换数据</a></p>
                           </li>
                           <li>
                              <p><a href="loading-transformation-date-warehouses.html#GUID-033C3049-7936-46C2-881C-14BA409D294B">使用MERGE转换数据</a></p>
                           </li>
                           <li>
                              <p><a href="loading-transformation-date-warehouses.html#GUID-573C71FA-9CC7-41F1-B27A-AC5668A02854">使用多重INSERT转换数据</a></p>
                           </li>
                        </ul>
                     </div>
                     <!-- class="section" -->
                  </div><a id="DWHSG8317"></a><div class="props_rev_3"><a id="GUID-DB1E72E7-5ED6-4BA6-A133-DAD16932E5A0" name="GUID-DB1E72E7-5ED6-4BA6-A133-DAD16932E5A0"></a><h5 id="DWHSG-GUID-DB1E72E7-5ED6-4BA6-A133-DAD16932E5A0" class="sect5"><span class="enumeration_section">18.3.1.1</span>创建表...AS SELECT和INSERT / * + APPEND * / AS SELECT</h5>
                     <div>
                        <div class="section">
                           <p><code class="codeph">CREATE</code> <code class="codeph">TABLE</code> ......<code class="codeph">AS</code> <code class="codeph">SELECT</code>语句（CTAS）是一种用于处理大量数据的强大工具。如以下示例所示，许多数据转换可以在标准SQL中表示，CTAS提供了一种有效执行SQL查询并将该查询的结果存储在新数据库表中的机制。<code class="codeph">INSERT</code> / * + <code class="codeph">APPEND</code> * / ...<code class="codeph">AS</code> <code class="codeph">SELECT</code>语句提供与现有数据库表相同的功能。
                           </p>
                           <p>在数据仓库环境中，CTAS通常使用<code class="codeph">NOLOGGING</code>模式并行运行以获得最佳性能。
                           </p>
                           <p>一种简单而常见的数据转换类型是数据替换。在数据替换转换中，修改单个列的部分或全部值。例如，我们的<code class="codeph">sales</code>表有一个<code class="codeph">channel_id</code>列。此栏显示特定销售交易是由公司自己的销售团队（直接销售）还是由分销商（间接销售）制作。
                           </p>
                           <p>您可以从数据仓库的多个源系统接收数据。假设其中一个源系统仅处理直接销售，因此源系统不知道间接销售渠道。当数据仓库最初从此系统接收销售数据时，所有销售记录都具有<code class="codeph">sales.channel_id</code>字段的<code class="codeph">NULL</code>值。必须将这些<code class="codeph">NULL</code>值设置为正确的键值。例如，您可以使用SQL函数有效地执行此操作，作为插入目标sales表语句的一部分。源表<code class="codeph">sales_activity_direct</code>的结构如下：</p><pre class="oac_no_warn" dir="ltr">DESC sales_activity_direct名称是否为空？输入------------ ----- ---------------- SALES_DATE DATE PRODUCT_ID NUMBER CUSTOMER_ID NUMBER PROMOTION_ID个数量AMONUNT NUMBER QUANTITY NUMBER</pre><p>以下SQL语句将<code class="codeph">sales_activity_direct</code>数据插入到示例模式的<code class="codeph">sales</code>表中，使用SQL函数将销售日期值截断为午夜时间并指定固定通道ID为3。
                           </p><pre class="oac_no_warn" dir="ltr">INSERT / * + APPEND NOLOGGING PARALLEL * / INTO销售SELECT product_id，customer_id，TRUNC（sales_date），3，promotion_id，数量，金额FROM sales_activity_direct;</pre></div>
                        <!-- class="section" -->
                     </div>
                  </div><a id="DWHSG8318"></a><div class="props_rev_3"><a id="GUID-7463003E-2689-4469-8ED9-77BBA5BC2A00" name="GUID-7463003E-2689-4469-8ED9-77BBA5BC2A00"></a><h5 id="DWHSG-GUID-7463003E-2689-4469-8ED9-77BBA5BC2A00" class="sect5"><span class="enumeration_section">18.3.1.2</span>使用UPDATE转换数据</h5>
                     <div>
                        <div class="section">
                           <p>实现数据替换的另一种技术是使用<code class="codeph">UPDATE</code>语句来修改<code class="codeph">sales.channel_id</code>列。<code class="codeph">UPDATE</code>提供正确的结果。但是，如果数据替换转换要求修改很大比例的行（或所有行），则使用CTAS语句比使用<code class="codeph">UPDATE</code>更有效。</p>
                        </div>
                        <!-- class="section" -->
                     </div>
                  </div><a id="DWHSG8321"></a><a id="DWHSG8319"></a><div class="props_rev_3"><a id="GUID-033C3049-7936-46C2-881C-14BA409D294B" name="GUID-033C3049-7936-46C2-881C-14BA409D294B"></a><h5 id="DWHSG-GUID-033C3049-7936-46C2-881C-14BA409D294B" class="sect5"><span class="enumeration_section">18.3.1.3</span>使用MERGE转换数据</h5>
                     <div>
                        <div class="section">
                           <p>Oracle数据库的合并功能通过引入SQL关键字<code class="codeph">MERGE</code>扩展SQL，以便能够有条件地将行更新或插入到表或单行表视图中。条件在<code class="codeph">ON</code>子句中指定。除了纯批量加载之外，这是数据仓库同步中最常见的操作之一。
                           </p>
                        </div>
                        <!-- class="section" -->
                        <div class="example" id="GUID-033C3049-7936-46C2-881C-14BA409D294B__i1006454">
                           <p class="titleinexample">示例18-1使用SQL合并操作</p>
                           <p>以下示例讨论了合并的各种实现。它假定维度表产品的新数据传播到数据仓库，并且必须插入或更新。表<code class="codeph">products_delta</code>具有相同的结构<code class="codeph">products</code> 。
                           </p><pre class="oac_no_warn" dir="ltr">MERGE INTO产品t使用products_delta s ON（t.prod_id = s.prod_id）当匹配时更新设置t.prod_list_price = s.prod_list_price，t.prod_min_price = s.prod_min_price什么时候不匹配然后插入（prod_id，prod_name，prod_desc，prod_subcategory ，prod_subcategory_desc，prod_category，prod_category_desc，prod_status，prod_list_price，prod_min_price）VALUES（s.prod_id，s.prod_name，s.prod_desc，s.prod_subcategory，s.prod_subcategory_desc，s.prod_category，s.prod_category_desc，s.prod_status，s.prod_list_price ，s.prod_min_price）;</pre></div>
                        <!-- class="example" -->
                     </div>
                  </div><a id="DWHSG8323"></a><a id="DWHSG8324"></a><a id="DWHSG8325"></a><a id="DWHSG8326"></a><a id="DWHSG8322"></a><div class="props_rev_3"><a id="GUID-573C71FA-9CC7-41F1-B27A-AC5668A02854" name="GUID-573C71FA-9CC7-41F1-B27A-AC5668A02854"></a><h5 id="DWHSG-GUID-573C71FA-9CC7-41F1-B27A-AC5668A02854" class="sect5"><span class="enumeration_section">18.3.1.4</span>使用<span class="enumeration_section">多重</span> INSERT转换数据</h5>
                     <div>
                        <div class="section">
                           <p>很多时候，外部数据源必须基于逻辑属性进行隔离，以便插入到不同的目标对象中。在数据仓库环境中，将相同的源数据扇出到多个目标对象中也很常见。多表插入为这些类型的转换提供了新的SQL语句，其中数据最终可以在几个或一个目标中结束，具体取决于业务转换规则。这种插入可以根据业务规则有条件地进行，也可以无条件地进行。</p>
                           <p>它提供<code class="codeph">INSERT</code>的好处......<code class="codeph">SELECT</code>多个表作为目标时的<code class="codeph">SELECT</code>语句。在这样做时，它避免了两个明显替代方案的缺点。您必须处理<span class="italic">n个</span>独立的<code class="codeph">INSERT</code> ... <code class="codeph">SELECT</code>语句，因此处理相同的源数据<span class="italic">n</span>次并增加转换工作量<span class="italic">n</span>次。或者，您必须选择一个程序方法，每行确定如何处理插入。此解决方案无法直接访问SQL中可用的高速访问路径。</p>
                           <p>与现有的<code class="codeph">INSERT</code> ......<code class="codeph">SELECT</code>语句，新语句可以并行化并与直接加载机制一起使用，以提高性能。
                           </p>
                        </div>
                        <!-- class="section" -->
                        <div class="example" id="GUID-573C71FA-9CC7-41F1-B27A-AC5668A02854__GUID-35298AB6-DA03-4C43-9C91-F786FDB70E61">
                           <p class="titleinexample">例18-2无条件插入</p>
                           <p>以下语句每天汇总存储在<code class="codeph">sales_activity_direct</code>的交易销售信息，并插入当天的<code class="codeph">sales</code>和<code class="codeph">costs</code>事实表。
                           </p><pre class="oac_no_warn" dir="ltr">INSERT ALL INTO销售价值（product_id，customer_id，today，3，promotion_id，quantity_per_day，amount_per_day）INTO成本VALUES（product_id，today，promotion_id，3，product_cost，product_price）SELECT TRUNC（s.sales_date）AS今天，s.product_id， s.customer_id，s.promotion_id，SUM（s.amount）AS amount_per_day，SUM（s.quantity）quantity_per_day，p.prod_min_price * 0.8 AS product_cost，p.prod_list_price AS product_price FROM sales_activity_direct s，products p WHERE s.product_id = p .prod_id AND TRUNC（sales_date）= TRUNC（SYSDATE）GROUP BY TRUNC（sales_date），s.product_id，s.customer_id，s.promotion_id，p.prod_min_price * 0.8，p.prod_list_price;</pre></div>
                        <!-- class="example" -->
                        <div class="example" id="GUID-573C71FA-9CC7-41F1-B27A-AC5668A02854__GUID-83B9F592-5612-4A97-B8AC-5B6FB5DE0D17">
                           <p class="titleinexample">例18-3条件ALL插入</p>
                           <p>以下语句在具有有效促销的所有销售交易的<code class="codeph">sales</code>和<code class="codeph">costs</code>表中插入一行，并将有关客户的多个相同订单的信息存储在单独的表<code class="codeph">cum_sales_activity</code> 。对于某些销售交易，可能会插入两行，而对其他销售交易则不会。
                           </p><pre class="oac_no_warn" dir="ltr">INSERT ALLENENENDEN_IN（SELECT promo_id FROM promotion）THEN INTO sales VALUES（product_id，customer_id，today，3，promotion_id，quantity_per_day，amount_per_day）INTO成本VALUES（product_id，today，promotion_id，3，product_cost，product_price）当num_of_orders&gt; 1时然后INTO cum_sales_activity VALUES（今天，product_id，customer_id，promotion_id，quantity_per_day，amount_per_day，num_of_orders）今天选择TRUNC（s.sales_date）AS，s.product_id，s.customer_id，s.promotion_id，SUM（s.amount）AS amount_per_day， SUM（s.quantity）quantity_per_day，COUNT（*）num_of_orders，p.prod_min_price * 0.8 AS product_cost，p.prod_list_price AS product_price FROM sales_activity_direct s，products p WHERE s.product_id = p.prod_id AND TRUNC（sales_date）= TRUNC（SYSDATE ）GROUP BY TRUNC（sales_date），s.product_id，s.customer_id，s.promotion_id，p.prod_min_price * 0.8，p.prod_list_price;</pre></div>
                        <!-- class="example" -->
                        <div class="example" id="GUID-573C71FA-9CC7-41F1-B27A-AC5668A02854__GUID-348DCBDD-BB6A-4F54-893D-ECE3E180D1E5">
                           <p class="titleinexample">例18-4条件FIRST插入</p>
                           <p>以下声明根据产品订单的总数量和重量插入到适当的货运清单中。高价值订单例外，也是快递发送的，除非它们的权重分类太高。在这个简单的例子中，所有不正确的订单都表示为没有数量的订单，存储在一个单独的表中。它假定存在适当的表<code class="codeph">large_freight_shipping</code> ， <code class="codeph">express_shipping</code> ， <code class="codeph">default_shipping</code>和<code class="codeph">incorrect_sales_order</code> 。
                           </p><pre class="oac_no_warn" dir="ltr">INSERT FIRST WHEN（sum_quantity_sold&gt; 10 AND prod_weight_class &lt;5）AND sum_quantity_sold&gt; = 1）OR（sum_quantity_sold&gt; 5 AND prod_weight_class&gt; 5）THEN INTO large_freight_shipping VALUES（time_id，cust_id，prod_id，prod_weight_class，sum_quantity_sold）当sum_amount_sold&gt; 1000 AND sum_quantity_sold&gt; = 1那么INTO express_shipping VALUES（time_id，cust_id，prod_id，prod_weight_class，sum_amount_sold，sum_quantity_sold）WHEN（sum_quantity_sold&gt; = 1）那么INTO default_shipping VALUES（time_id，cust_id，prod_id，sum_quantity_sold）ELSE INTO incorrect_sales_order VALUES（time_id，cust_id，prod_id） SELECT s.time_id，s.cust_id，s.prod_id，p.prod_weight_class，SUM（amount_sold）AS sum_amount_sold，SUM（quantity_sold）AS sum_quantity_sold FROM sales s，products p WHERE s.prod_id = p.prod_id AND s.time_id = TRUNC （SYSDATE）GROUP BY s.time_id，s.cust_id，s.prod_id，p.prod_weight_class;</pre></div>
                        <!-- class="example" -->
                        <div class="example" id="GUID-573C71FA-9CC7-41F1-B27A-AC5668A02854__GUID-6B1707BA-287E-4409-B935-CCBE18BB8EE9">
                           <p class="titleinexample">例18-5混合条件和无条件插入</p>
                           <p>以下示例将新客户插入到<code class="codeph">customers</code>表中，并将<code class="codeph">cust_credit_limit</code>高于4500的所有新客户存储在另一个单独的表中以进行进一步的促销。
                           </p><pre class="oac_no_warn" dir="ltr">首先插入cust_credit_limit&gt; = 4500然后INTO客户INTO customers_special VALUES（cust_id，cust_credit_limit）ELSE INTO客户SELECT * FROM customers_new;</pre><div class="infoboxnotealso" id="GUID-573C71FA-9CC7-41F1-B27A-AC5668A02854__GUID-EC09222A-5C7B-42BC-BBF5-8479F656F857">
                              <p class="notep1">也可以看看：</p>
                              <p><a href="refreshing-materialized-views.html#GUID-64068234-BDB0-4C12-AE70-75571046A586" title="每次在任何物化视图的基表上执行DML操作时，都会自动刷新使用ON STATEMENT刷新模式的物化视图。Oracle数据库对使用近似查询定义的物化视图执行快速刷新。在使用DBMS_REDEFINITION包在线重新定义表时，可以执行依赖于正在重新定义的表的快速可刷新实体化视图的增量刷新。您可以使用完整，快速或PCT刷新方法刷新基于混合分区表的实例化视图。">刷新物化视图</a>以获取有关<code class="codeph">MERGE</code>操作的更多信息</p>
                           </div>
                        </div>
                        <!-- class="example" -->
                     </div>
                  </div>
               </div><a id="DWHSG8327"></a><div class="props_rev_3"><a id="GUID-11660715-44A7-4687-8E4B-2C18B8339A1D" name="GUID-11660715-44A7-4687-8E4B-2C18B8339A1D"></a><h4 id="DWHSG-GUID-11660715-44A7-4687-8E4B-2C18B8339A1D" class="sect4"><span class="enumeration_section">18.3.2</span>使用PL / SQL转换数据</h4>
                  <div>
                     <p>在数据仓库环境中，您可以使用PL / SQL等过程语言在Oracle数据库中实现复杂的转换。CTAS在整个表上运行并强调并行性，而PL / SQL提供了基于行的接近，并且可以容纳非常复杂的转换规则。例如，PL / SQL过程可以打开多个游标并从多个源表读取数据，使用复杂的业务规则组合这些数据，最后将转换后的数据插入到一个或多个目标表中。使用标准SQL语句表达相同的操作序列是困难的或不可能的。</p>
                     <p>使用过程语言，可以封装复杂ETL处理中的特定转换（或转换步骤的数量），从中间转移区域读取数据并生成新的表对象作为输出。先前生成的转换输入表和后续转换将使用由此特定转换生成的表。或者，可以无缝地集成完整ETL过程中的这些封装的转换步骤，从而在彼此之间流动行集，而无需中间分级。您可以使用表函数来实现此类行为。</p>
                  </div>
               </div><a id="DWHSG8328"></a><div class="props_rev_3"><a id="GUID-98157B1C-86EC-4888-9760-DB0164D2A832" name="GUID-98157B1C-86EC-4888-9760-DB0164D2A832"></a><h4 id="DWHSG-GUID-98157B1C-86EC-4888-9760-DB0164D2A832" class="sect4"><span class="enumeration_section">18.3.3</span>使用表函数转换数据</h4>
                  <div>
                     <p>表函数提供对PL / SQL，C或Java中实现的转换的流水线和并行执行的支持。 <span class="bold"> </span>可以在不需要使用中间登台表的情况下完成前面提到的场景，中间登台表通过各种转换步骤中断数据流。有关表函数的详细信息，请参阅<span class="q">“ <a href="loading-transformation-date-warehouses.html#GUID-53CA1DE7-F323-46AA-8803-C76E1642486B">什么是表函数？</a>“</span> 。
                     </p>
                  </div><a id="DWHSG8330"></a><a id="DWHSG8331"></a><a id="DWHSG8332"></a><a id="DWHSG8329"></a><div class="props_rev_3"><a id="GUID-53CA1DE7-F323-46AA-8803-C76E1642486B" name="GUID-53CA1DE7-F323-46AA-8803-C76E1642486B"></a><h5 id="DWHSG-GUID-53CA1DE7-F323-46AA-8803-C76E1642486B" class="sect5"><span class="enumeration_section">18.3.3.1</span>什么是表函数？
                     </h5>
                     <div>
                        <p>表函数定义为可以生成一组行作为输出的函数。此外，表函数可以将一组行作为输入。在Oracle9 <span class="italic">i</span>之前，PL / SQL函数：</p>
                        <ul style="list-style-type:disc">
                           <li>
                              <p>无法将游标作为输入。</p>
                           </li>
                           <li>
                              <p>无法并行化或流水线化。</p>
                           </li>
                        </ul>
                        <p>现在，功能不限于这些方式。表函数允许以下内容扩展数据库功能</p>
                        <ul style="list-style-type:disc">
                           <li>
                              <p>从函数返回多行。</p>
                           </li>
                           <li>
                              <p>SQL子查询（选择多行）的结果直接传递给函数。</p>
                           </li>
                           <li>
                              <p>函数将游标作为输入。</p>
                           </li>
                           <li>
                              <p>功能可以并行化。</p>
                           </li>
                           <li>
                              <p>一旦创建结果集，就会逐步返回结果集以进行进一步处理。这称为增量流水线</p>
                           </li>
                        </ul>
                        <p>表函数可以使用本机PL / SQL接口在PL / SQL中定义，也可以使用Oracle数据盒式接口（ODCI）在Java或C中定义。</p>
                        <div class="infoboxnotealso" id="GUID-53CA1DE7-F323-46AA-8803-C76E1642486B__GUID-012AFC1F-DF1D-428F-8B0A-D5C4EAFDFCD1">
                           <p class="notep1">也可以看看：</p>
                           <ul style="list-style-type:disc">
                              <li>
                                 <p>有关详细信息，请<a href="../lnpls/plsql-optimization-and-tuning.html#LNPLS01210" target="_blank"><span class="italic">参见Oracle Database PL / SQL语言参考</span></a></p>
                              </li>
                              <li>
                                 <p><a href="../addci/using-pipelined-and-parallel-table-functions.html#ADDCI2140" target="_blank"><span class="italic">Oracle Database Data Cartridge开发人员指南</span></a>以获取更多信息</p>
                              </li>
                           </ul>
                        </div>
                        <p><a href="loading-transformation-date-warehouses.html#GUID-53CA1DE7-F323-46AA-8803-C76E1642486B__I1006638">图18-3</a>说明了一个典型的聚合，在这种聚合中，您输入一组行并输出一组行，在这种情况下，执行<code class="codeph">SUM</code>操作后。
                        </p>
                        <div class="figure" id="GUID-53CA1DE7-F323-46AA-8803-C76E1642486B__I1006638">
                           <p class="titleinfigure">图18-3表功能示例</p><img src="img/dwhsg084.gif" alt="下面是图18-3的描述" title="下面是图18-3的描述" longdesc="img_text/dwhsg084.html"><br><a href="img_text/dwhsg084.html">“图18-3表函数示例”的说明</a></div>
                        <!-- class="figure" -->
                        <p>此操作的伪代码类似于：</p><pre class="oac_no_warn" dir="ltr">INSERT INTO SELECT SELECT * FROM（“表函数”（SELECT * FROM In））;</pre><p>该表函数采用的结果<code class="codeph">SELECT</code>上<code class="codeph">In</code>作为输入，并以不同的格式作为用于直接插入到输出端提供一组记录<code class="codeph">Out</code> 。
                        </p>
                        <p>此外，表函数可以扇出原子事务范围内的数据。这可以用于许多场合，例如高效的日志记录机制或用于其他独立转换的扇出。在这种情况下，需要一个临时表。</p>
                        <div class="figure" id="GUID-53CA1DE7-F323-46AA-8803-C76E1642486B__GUID-999253ED-2787-4948-B9B0-40D96C6CD5A8">
                           <p class="titleinfigure">图18-4使用扇出的流水线并行转换</p><img src="img/dwhsg079.gif" alt="下面是图18-4的描述" title="下面是图18-4的描述" longdesc="img_text/dwhsg079.html"><br><a href="img_text/dwhsg079.html">“图18-4带扇出的流水线并行转换”的描述</a></div>
                        <!-- class="figure" -->
                        <p>这个伪代码类似于：</p><pre class="oac_no_warn" dir="ltr">INSERT INTO目标SELECT * FROM（tf2（SELECT * FROM（tf1（SELECT * FROM source））））;</pre><p>这将插入到<code class="codeph">target</code>并作为<code class="codeph">tf1</code>一部分插入到原子事务范围内的<code class="codeph">Stage</code> <code class="codeph">Table</code> <code class="codeph">1</code>中。
                        </p><pre class="oac_no_warn" dir="ltr">INSERT INTO目标SELECT * FROM tf3（SELT * FROM stage_table1）;</pre><div class="infoboxnotealso" id="GUID-53CA1DE7-F323-46AA-8803-C76E1642486B__GUID-926150FA-ADB1-46D0-94A5-0EA5D04FA3B6">
                           <p class="notep1">也可以看看：</p>
                           <ul style="list-style-type:disc">
                              <li>
                                 <p>有关表函数的详细信息，请<a href="../lnpls/plsql-optimization-and-tuning.html#LNPLS01210" target="_blank"><span class="italic">参见Oracle Database PL / SQL语言参考</span></a></p>
                              </li>
                              <li>
                                 <p><a href="../addci/using-pipelined-and-parallel-table-functions.html#ADDCI2140" target="_blank"><span class="italic">Oracle数据库数据盒开发人员指南</span></a> ，了解有关以PL / SQL以外的语言实现的表函数的详细信息</p>
                              </li>
                           </ul>
                        </div>
                        <div class="section">
                           <p class="subhead3" id="GUID-53CA1DE7-F323-46AA-8803-C76E1642486B__GUID-0C215ACE-E2B1-4B2D-9B06-98365261B1CD">运行表函数示例之前要创建的对象</p>
                           <p>以下示例演示了表函数的基础知识，而不使用在这些函数中实现的复杂业务规则。它们仅用于演示目的，并且都在PL / SQL中实现。</p>
                           <p>表函数返回记录集，可以将游标作为输入。除了<code class="codeph">sh</code>示例模式，你必须使用实例之前设置以下数据库对象：</p><pre class="oac_no_warn" dir="ltr">CREATE TYPE product_t AS OBJECT（prod_id NUMBER（6），prod_name VARCHAR2（50），prod_desc VARCHAR2（4000），prod_subcategory VARCHAR2（50），prod_subcategory_desc VARCHAR2（2000），prod_category VARCHAR2（50），prod_category_desc VARCHAR2（2000），prod_weight_class NUMBER （2），prod_unit_of_measure VARCHAR2（20），prod_pack_size VARCHAR2（30），supplier_id NUMBER（6），prod_status VARCHAR2（20），prod_list_price NUMBER（8,2），prod_min_price NUMBER（8,2））; / CREATE TYPE product_t_table AS TABLE OF product_t; / COMMIT;创建或替换包cursor_PKG AS TYPE product_t_rec是RECORD（prod_id NUMBER（6），prod_name VARCHAR2（50），prod_desc VARCHAR2（4000），prod_subcategory VARCHAR2（50），prod_subcategory_desc VARCHAR2（2000），prod_category VARCHAR2（50），prod_category_desc VARCHAR2（ 2000），prod_weight_class NUMBER（2），prod_unit_of_measure VARCHAR2（20），prod_pack_size VARCHAR2（30），supplier_id NUMBER（6），prod_status VARCHAR2（20），prod_list_price NUMBER（8,2），prod_min_price NUMBER（8,2））; TYPE product_t_rectab IS TABLE of product_t_rec; TYPE strong_refcur_t是REF CURSOR RETURN product_t_rec; TYPE refcur_t是REF CURSOR;结束; / REM人工帮助表，以后使用CREATE TABLE obsolete_products_errors（prod_id NUMBER，msg VARCHAR2（2000））;</pre></div>
                        <!-- class="section" -->
                        <div class="example" id="GUID-53CA1DE7-F323-46AA-8803-C76E1642486B__CACFHAGG">
                           <p class="titleinexample">例18-6表函数示例：基本示例</p>
                           <p>此示例演示了一个简单的过滤;它显示了除<code class="codeph">prod_category</code> Electronics之外的所有过时产品。table函数将结果集作为一组记录返回，并使用弱类型的<code class="codeph">REF</code> <code class="codeph">CURSOR</code>作为输入。
                           </p><pre class="oac_no_warn" dir="ltr">创建或替换功能obsolete_products（cur cursor_pkg.refcur_t）RETURN product_t_table IS prod_id NUMBER（6）; prod_name VARCHAR2（50）; prod_desc VARCHAR2（4000）; prod_subcategory VARCHAR2（50）; prod_subcategory_desc VARCHAR2（2000）; prod_category VARCHAR2（50）; prod_category_desc VARCHAR2（2000）; prod_weight_class NUMBER（2）; prod_unit_of_measure VARCHAR2（20）; prod_pack_size VARCHAR2（30）; supplier_id NUMBER（6）; prod_status VARCHAR2（20）; prod_list_price NUMBER（8,2）; prod_min_price NUMBER（8,2）;销售数量：= 0; objset product_t_table：= product_t_table（）;我号码：= 0; BEGIN LOOP  - 从游标变量FETCH获取INTO prod_id，prod_name，prod_desc，prod_subcategory，prod_subcategory_desc，prod_category，prod_category_desc，prod_weight_class，prod_unit_of_measure，prod_pack_size，supplier_id，prod_status，prod_list_price，prod_min_price;当cur％NOTFOUND时退出; - 获取最后一行时退出 - 类别电子产品并不意味着过时，如果prod_status ='过时'和prod_category将被抑制！='电子'然后 - 附加到集合i：= i + 1; objset.extend; objset（i）：= product_t（prod_id，prod_name，prod_desc，prod_subcategory，prod_subcategory_desc，prod_category，prod_category_desc，prod_weight_class，prod_unit_of_measure，prod_pack_size，supplier_id，prod_status，prod_list_price，prod_min_price）;万一;结束循环;关闭cur;返回objset;结束; /</pre><p>您可以在SQL语句中使用表函数来显示结果。在这里，您可以为输出使用其他SQL功能：</p><pre class="oac_no_warn" dir="ltr">SELECT DISTINCT UPPER（prod_category），prod_status FROM TABLE（obsolete_products（CURSOR（SELECT prod_id，prod_name，prod_desc，prod_subcategory，prod_subcategory_desc，prod_category，prod_category_desc，prod_weight_class，prod_unit_of_measure，prod_pack_size，supplier_id，prod_status，prod_list_price，prod_min_price FROM products）））;</pre></div>
                        <!-- class="example" -->
                        <div class="example" id="GUID-53CA1DE7-F323-46AA-8803-C76E1642486B__GUID-32FB1B25-A469-4EF9-8A7F-6529447A8379">
                           <p class="titleinexample">例18-7表函数示例：使用REF CURSOR进行过滤</p>
                           <p>此示例实现与<a href="loading-transformation-date-warehouses.html#GUID-53CA1DE7-F323-46AA-8803-C76E1642486B__CACFHAGG">示例18-6</a>相同的过滤。两者之间的主要区别是：</p>
                           <ul style="list-style-type:disc">
                              <li>
                                 <p>此示例使用强类型<code class="codeph">REF</code> <code class="codeph">CURSOR</code>作为输入，并且可以基于强类型游标的对象进行并行化，如以下示例之一所示。
                                 </p>
                              </li>
                              <li>
                                 <p>表函数在创建记录后立即以递增方式返回结果集。</p>
                              </li>
                           </ul><pre class="oac_no_warn" dir="ltr">创建或替换功能obsolete_products_pipe（cur cursor_pkg.strong_refcur_t）RETURN product_t_table PIPELINED PARALLEL_ENABLE（PARTITION cur BY ANY）是prod_id NUMBER（6）; prod_name VARCHAR2（50）; prod_desc VARCHAR2（4000）; prod_subcategory VARCHAR2（50）; prod_subcategory_desc VARCHAR2（2000）; prod_category VARCHAR2（50）; prod_category_desc VARCHAR2（2000）; prod_weight_class NUMBER（2）; prod_unit_of_measure VARCHAR2（20）; prod_pack_size VARCHAR2（30）; supplier_id NUMBER（6）; prod_status VARCHAR2（20）; prod_list_price NUMBER（8,2）; prod_min_price NUMBER（8,2）;销售数量：= 0; BEGIN LOOP  - 从游标变量FETCH获取INTO prod_id，prod_name，prod_desc，prod_subcategory，prod_subcategory_desc，prod_category，prod_category_desc，prod_weight_class，prod_unit_of_measure，prod_pack_size，supplier_id，prod_status，prod_list_price，prod_min_price;当cur％NOTFOUND时退出; - 获取最后一行时退出如果prod_status ='过时'和prod_category！='电子'然后管道（product_t（prod_id，prod_name，prod_desc，prod_subcategory，prod_subcategory_desc，prod_category，prod_category_desc，prod_weight_class，prod_unit_of_measure，prod_pack_size，supplier_id，prod_status，prod_list_price，prod_min_price））;万一;结束循环;关闭cur;返回;结束; /</pre><p>您可以使用表函数，如下所示：</p><pre class="oac_no_warn" dir="ltr">SELECT DISTINCT prod_category，DECODE（prod_status，'过时'，'NO LONGER AVAILABLE'，'N / A'）FROM TABLE（obsolete_products_pipe（CURSOR（SELECT prod_id，prod_name，prod_desc，prod_subcategory，prod_subcategory_desc，prod_category，prod_category_desc，prod_weight_class，prod_unit_of_measure， prod_pack_size，supplier_id，prod_status，prod_list_price，prod_min_price FROM products）））;</pre><p>您现在可以更改输入表产品的并行度，并再次发出相同的语句：</p><pre class="oac_no_warn" dir="ltr">ALTER TABLE产品PARALLEL 4;</pre><p>会话统计信息显示该语句已并行化：</p><pre class="oac_no_warn" dir="ltr">SELECT * FROM V $ PQ_SESSTAT WHERE statistic ='Queries parallelized'; STATISTIC LAST_QUERY SESSION_TOTAL -------------------- ---------- -------------查询并行化1 3选择了1行。
</pre></div>
                        <!-- class="example" -->
                        <div class="example" id="GUID-53CA1DE7-F323-46AA-8803-C76E1642486B__GUID-F06815AD-5A85-4D00-9517-623F1DE58B40">
                           <p class="titleinexample">示例18-8表函数示例：将结果展示到持久表中</p>
                           <p>表函数还能够将结果扇出到持久表结构中。在此示例中，该函数会过滤除特定<code class="codeph">prod_category</code> （默认为Electronics）之外的所有过时产品，这些产品已设置为因错误而<code class="codeph">obsolete</code>的状态。表函数的结果集包含所有其他过时的产品类别。检测到的错误<code class="codeph">prod_id</code> ID存储在单独的表结构<code class="codeph">obsolete_products_error</code> 。请注意，如果表函数是自治事务的一部分，则必须在每个<code class="codeph">PIPE</code> <code class="codeph">ROW</code>语句之前执行<code class="codeph">COMMIT</code>或<code class="codeph">ROLLBACK</code> ，以避免调用子程序中的错误。其结果集包含所有其他过时的产品类别。它还演示了如何将正常变量与表函数结合使用：</p><pre class="oac_no_warn" dir="ltr">创建或替换功能obsolete_products_dml（cur cursor_pkg.strong_refcur_t，prod_cat varchar2 DEFAULT'Electronics'）RETURN product_t_table PIPELINED PARALLEL_ENABLE（PARTITION cur BY ANY）是PRAGMA AUTONOMOUS_TRANSACTION; prod_id NUMBER（6）; prod_name VARCHAR2（50）; prod_desc VARCHAR2（4000）; prod_subcategory VARCHAR2（50）; prod_subcategory_desc VARCHAR2（2000）; prod_category VARCHAR2（50）; prod_category_desc VARCHAR2（2000）; prod_weight_class NUMBER（2）; prod_unit_of_measure VARCHAR2（20）; prod_pack_size VARCHAR2（30）; supplier_id NUMBER（6）; prod_status VARCHAR2（20）; prod_list_price NUMBER（8,2）; prod_min_price NUMBER（8,2）;销售数量：= 0; BEGIN LOOP  - 从游标变量FETCH获取INTO prod_id，prod_name，prod_desc，prod_subcategory，prod_subcategory_desc，prod_category，prod_category_desc，prod_weight_class，prod_unit_of_measure，prod_pack_size，supplier_id，prod_status，prod_list_price，prod_min_price;当cur％NOTFOUND时退出; - 当获取最后一行时退出如果prod_status ='过时'那么如果prod_category = prod_cat那么INSERT INTO obsolete_products_errors VALUES（prod_id，'correction：category'|| UPPER（prod_cat）||'仍然可用'）;承诺; ELSE PIPE ROW（product_t（prod_id，prod_name，prod_desc，prod_subcategory，prod_subcategory_desc，prod_category，prod_category_desc，prod_weight_class，prod_unit_of_measure，prod_pack_size，supplier_id，prod_status，prod_list_price，prod_min_price））;万一;万一;结束循环;关闭cur;返回;结束; /</pre><p>以下查询显示除<code class="codeph">prod_category</code> Electronics之外的所有过时产品组，错误地将其设置为<code class="codeph">obsolete</code>状态：</p><pre class="oac_no_warn" dir="ltr">SELECT DISTINCT prod_category，prod_status FROM TABLE（obsolete_products_dml（CURSOR（SELECT prod_id，prod_name，prod_desc，prod_subcategory，prod_subcategory_desc，prod_category，prod_category_desc，prod_weight_class，prod_unit_of_measure，prod_pack_size，supplier_id，prod_status，prod_list_price，prod_min_price FROM products）））;</pre><p>正如您所看到的， <code class="codeph">prod_category</code> Electronics的一些产品被意外淘汰：</p><pre class="oac_no_warn" dir="ltr">SELECT DISTINCT msg FROM obsolete_products_errors;</pre><p>利用第二个输入变量，您可以指定与电子设备不同的产品组：</p><pre class="oac_no_warn" dir="ltr">SELECT DISTINCT prod_category，prod_status FROM TABLE（obsolete_products_dml（CURSOR（SELECT prod_id，prod_name，prod_desc，prod_subcategory，prod_subcategory_desc，prod_category，prod_category_desc，prod_weight_class，prod_unit_of_measure，prod_pack_size，supplier_id，prod_status，prod_list_price，prod_min_price FROM products），'Photo'））;</pre><p>因为表函数可以像普通表一样使用，所以它们可以嵌套，如下所示：</p><pre class="oac_no_warn" dir="ltr">SELECT DISTINCT prod_category，prod_status FROM TABLE（obsolete_products_dml（CURSOR（SELECT * FROM TABLE（obsolete_products_pipe（CURSOR（SELECT PROD_ID，PROD_NAME，prod_desc，prod_subcategory，prod_subcategory_desc，prod_category，prod_category_desc，prod_weight_class，prod_unit_of_measure，prod_pack_size，supplier_id，prod_status，prod_list_price，prod_min_price FROM产品））））））;</pre><p>Oracle数据库ETL的最大优势是其工具包功能，您可以将后面讨论的任何功能组合在一起，以改进和加速您的ETL处理。例如，您可以将外部表作为输入，将其与现有表连接，并将其用作并行化表函数的输入，以处理复杂的业务逻辑。此表函数可用作<code class="codeph">MERGE</code>操作的输入源，从而流式传输数据仓库的新信息，通过完整的ETL过程在单个语句中的平面文件中提供。
                           </p>
                        </div>
                        <!-- class="example" -->
                     </div>
                  </div>
               </div>
            </div><a id="DWHSG8333"></a><div class="props_rev_3"><a id="GUID-DAD3F208-A1CB-4491-8D61-D4640B51286A" name="GUID-DAD3F208-A1CB-4491-8D61-D4640B51286A"></a><h3 id="DWHSG-GUID-DAD3F208-A1CB-4491-8D61-D4640B51286A" class="sect3"><span class="enumeration_section">18.4</span>错误记录和处理机制</h3>
               <div>
                  <p>在加载和转换数据时，特别是在处理来自各种来源（包括外部数据）的数据时，非干净的数据非常常见。如果此脏数据导致您中止长时间运行的加载或转换操作，则会浪费大量时间和资源。
                  </p>
                  <p>以下主题讨论了错误的两个主要原因以及如何解决它们：</p>
                  <ul style="list-style-type:disc">
                     <li>
                        <p><a href="loading-transformation-date-warehouses.html#GUID-3AAAC9DA-2009-474A-B85A-7C7999C80F89">业务规则违规</a></p>
                     </li>
                     <li>
                        <p><a href="loading-transformation-date-warehouses.html#GUID-92563272-9748-4A5F-882E-7A645BF69859" title="在数据转换过程中使用的外部数据有时可能不准确，从而导致数据转换错误。某些SQL函数可用于处理数据转换错误。">数据规则违规（数据错误）</a></p>
                     </li>
                  </ul>
               </div><a id="DWHSG8334"></a><div class="props_rev_3"><a id="GUID-3AAAC9DA-2009-474A-B85A-7C7999C80F89" name="GUID-3AAAC9DA-2009-474A-B85A-7C7999C80F89"></a><h4 id="DWHSG-GUID-3AAAC9DA-2009-474A-B85A-7C7999C80F89" class="sect4"><span class="enumeration_section">18.4.1</span>违反业务规则</h4>
                  <div>
                     <p>逻辑上不干净的数据违反了在任何数据消耗之前已知的业务规则。大多数情况下，处理这些错误将被纳入加载或转换过程。但是，在所有记录的错误标识变得过于昂贵并且业务规则可以作为数据规则违规强制执行的情况下，例如，测试数百列以查看它们是否<code class="codeph">NOT</code> <code class="codeph">NULL</code> ，程序员通常会选择处理甚至已知可能的逻辑错误情况更普遍。<span class="q">“ <a href="loading-transformation-date-warehouses.html#GUID-E99E3CAC-83BC-448E-9CF3-D45432BE34A0">数据错误方案</a> ”中</span>显示了此示例。
                     </p>
                     <p>合并逻辑规则可以像在数据输入流上应用过滤条件一样简单，也可以像将脏数据输入不同的转换工作流一样复杂。一些例子如下：</p>
                     <ul style="list-style-type:disc">
                        <li>
                           <p>使用SQL过滤逻辑数据错误。在处理之前过滤掉不符合某些条件的数据。</p>
                        </li>
                        <li>
                           <p>识别和分离逻辑数据错误。在简单的情况下，这可以使用SQL来完成，如<a href="loading-transformation-date-warehouses.html#GUID-033C3049-7936-46C2-881C-14BA409D294B__i1006454">例18-1</a>所示，或者在过程方法中的更复杂的情况下，如<a href="loading-transformation-date-warehouses.html#GUID-53CA1DE7-F323-46AA-8803-C76E1642486B__CACFHAGG">例18-6</a>所示。
                           </p>
                        </li>
                     </ul>
                  </div>
               </div><a id="DWHSG8335"></a><div class="props_rev_3"><a id="GUID-92563272-9748-4A5F-882E-7A645BF69859" name="GUID-92563272-9748-4A5F-882E-7A645BF69859"></a><h4 id="DWHSG-GUID-92563272-9748-4A5F-882E-7A645BF69859" class="sect4"><span class="enumeration_section">18.4.2</span>数据规则违规（数据错误）</h4>
                  <div>
                     <p>与逻辑错误不同，加载或转换过程通常不会预期数据规则违规。未从操作处理的此类意外数据规则违规（也称为数据错误）会导致操作失败。数据规则违规是数据库内发生的错误情况，导致语句失败。例如，数据类型转换错误或约束违规。</p>
                     <p></p>
                     <p>过去，SQL没有提供在行级别处理数据错误的方法，作为批量处理的一部分。处理数据库内部数据错误的唯一方法是使用PL / SQL。但是，现在，您可以在DML操作继续时将数据错误记录到特殊错误表中。您还可以使用SQL函数处理数据转换错误。</p>
                     <p>以下部分简要讨论了各种异常处理策略：</p>
                     <ul style="list-style-type:disc">
                        <li>
                           <p><a href="loading-transformation-date-warehouses.html#GUID-F26DFED8-0A21-4546-8E74-CD3741DFFFC0" title="在数据转换过程中使用的外部数据有时可能不准确，从而导致数据转换错误。某些SQL函数可用于处理数据转换错误。">使用SQL处理数据错误</a></p>
                        </li>
                        <li>
                           <p><a href="loading-transformation-date-warehouses.html#GUID-9AC08819-AA89-4FCE-8F87-0DA0E6932C29">处理PL / SQL中的数据错误</a></p>
                        </li>
                        <li>
                           <p><a href="loading-transformation-date-warehouses.html#GUID-F8F527F2-A7D7-4262-A1F0-D1E84FC3DD54">使用错误记录表处理数据错误</a></p>
                        </li>
                     </ul>
                  </div>
                  <div class="sect4"><a id="GUID-F26DFED8-0A21-4546-8E74-CD3741DFFFC0" name="GUID-F26DFED8-0A21-4546-8E74-CD3741DFFFC0"></a><h5 id="DWHSG-GUID-F26DFED8-0A21-4546-8E74-CD3741DFFFC0" class="sect5"><span class="enumeration_section">18.4.2.1</span>使用SQL处理数据错误</h5>
                     <div>
                        <p>在数据转换过程中使用的外部数据有时可能不准确，从而导致数据转换错误。某些SQL函数可用于处理数据转换错误。</p>
                        <div class="p">
                           <p></p>
                           <p>必须将<code class="codeph">COMPATIBLE</code>参数设置为12.2才能使用处理数据转换错误的SQL函数。
                           </p>
                           <p>以下策略可用于处理SQL函数的数据转换错误：</p>
                        </div>
                        <!-- class="section" -->
                        <ul>
                           <li class="stepexpand"><span>显式过滤有效或无效数据</span><div>
                                 <p><code class="codeph">VALIDATE_CONVERSION</code>函数标识无法转换为所需数据类型的问题数据。如果给定表达式可以转换为指定的数据类型，则返回1，否则返回0。
                                 </p>
                              </div>
                           </li>
                           <li class="stepexpand"><span>SQL数据类型转换函数中的错误处理</span><div>
                                 <p>发生数据类型转换错误时， <code class="codeph">CAST</code> ， <code class="codeph">TO_NUMBER</code> ， <code class="codeph">TO_BINARY_FLOAT</code> ， <code class="codeph">TO_BINARY_DOUBLE</code> ， <code class="codeph">TO_DATE</code> ， <code class="codeph">TO_TIMESTAMP</code> ， <code class="codeph">TO_TIMESTAMP_TZ</code> ， <code class="codeph">TO_DSINTERVAL</code>和<code class="codeph">TO_YMINTERVAL</code>函数可以返回用户指定的值，而不是错误。这减少了ETL过程中的故障。
                                 </p>
                                 <p>仅在转换表达式时发生错误时才返回用户指定的值，而不是在计算表达式时。<code class="codeph">CAST</code>函数还允许格式字符串和NLS参数字符串作为某些数据类型的参数。
                                 </p>
                              </div>
                           </li>
                        </ul>
                        <div class="example" id="GUID-F26DFED8-0A21-4546-8E74-CD3741DFFFC0__GUID-C01B88B1-1D36-42E1-9488-C49C89888DE9">
                           <p class="titleinexample">示例18-9使用VALIDATE_CONVERSION和CAST处理数据转换错误</p>
                           <p>假设数据从<code class="codeph">TMP_PRODUCTS</code>表加载到<code class="codeph">PRODUCTS</code>表中。两个表中列的数量和名称相同，但<code class="codeph">prod_id</code>列的数据类型不同。<code class="codeph">PRODUCTS</code>表中的<code class="codeph">prod_id</code>列的数据类型为<code class="codeph">NUMBER</code> 。虽然<code class="codeph">TMP_PRODUCTS</code>表中<code class="codeph">prod_id</code>列中的数据是数字，但其数据类型为<code class="codeph">VARCHAR2</code> 。而将数据加载到<code class="codeph">PRODUCTS</code>表中，可以处理的数据类型转换错误<code class="codeph">prod_id</code>由任一柱过滤出含不正确的行<code class="codeph">prod_id</code>值或分配用于一个默认值<code class="codeph">prod_id</code>不能被转换为值<code class="codeph">NUMBER</code> 。</p>
                           <p>以下命令将<code class="codeph">TMP_PRODUCTS</code>表中的数据加载到<code class="codeph">PRODUCTS</code>表中。只插入<code class="codeph">tmp_products.prod_id</code>可以成功转换为数值的行。
                           </p><pre class="pre codeblock"><code>INSERT INTO PRODUCTS（SELECT prod_id，prod_name，prod_desc，prod_category_id，prod_category_name，prod_category_desc，prod_list_price FROM tmp_products WHERE VALIDATE_CONVERSION（prod_id AS NUMBER）= 1）;</code></pre><p>您可以使用<code class="codeph">CAST</code>函数来处理导致数据类型转换错误的<code class="codeph">prod_id</code>值。以下<code class="codeph">INSERT</code>命令将<code class="codeph">TMP_PRODUCTS</code>表中的数据加载到<code class="codeph">PRODUCTS</code>表中。与<code class="codeph">prod_id</code>使用的<code class="codeph">CAST</code>函数可确保在发生数据类型转换错误时将默认值0分配给<code class="codeph">prod_id</code> 。这可确保加载操作不会因数据类型转换错误而失败。
                           </p><pre class="pre codeblock"><code>INSERT INTO PRODUCTS（SELECT CAST（prod_id AS NUMBER DEFAULT 0 ON CONVERSION ERROR），prod_name，prod_desc，prod_category_id，prod_category_name，prod_category_desc，prod_list_price FROM tmp_products）;</code></pre><div class="infoboxnotealso" id="GUID-F26DFED8-0A21-4546-8E74-CD3741DFFFC0__GUID-DA74FAC3-7E9C-486C-B23C-CB395515DAC7">
                              <p class="notep1">也可以看看：</p>
                              <p>有关<code class="codeph">CAST</code>和<code class="codeph">VALIDATE_CONVERSION</code>函数及其支持的数据类型的详细信息，请<a href="../sqlrf/Functions.html#SQLRF-GUID-D079EFD3-C683-441F-977E-2C9503089982" target="_blank"><span><cite>参见Oracle数据库SQL语言参考</cite></span></a></p>
                           </div>
                        </div>
                        <!-- class="example" -->
                     </div>
                  </div><a id="DWHSG8336"></a><div class="props_rev_3"><a id="GUID-9AC08819-AA89-4FCE-8F87-0DA0E6932C29" name="GUID-9AC08819-AA89-4FCE-8F87-0DA0E6932C29"></a><h5 id="DWHSG-GUID-9AC08819-AA89-4FCE-8F87-0DA0E6932C29" class="sect5"><span class="enumeration_section">18.4.2.2</span>处理PL / SQL中的数据错误</h5>
                     <div>
                        <div class="section">
                           <p>以下语句是使用PL / SQL如何完成错误处理的示例。请注意，您必须使用过程记录级别处理来捕获任何错误。此语句大致相当于<span class="q">“ <a href="loading-transformation-date-warehouses.html#GUID-F8F527F2-A7D7-4262-A1F0-D1E84FC3DD54">使用错误记录表处理数据错误</a> ”中</span>讨论的语句。
                           </p><pre class="oac_no_warn" dir="ltr">DECLARE errm编号默认为0; BEGIN FOR crec IN（SELECT product_id，customer_id，TRUNC（sales_date）sd，promotion_id，quantity，amount FROM sales_activity_direct）loop BEGIN INSERT INTO sales VALUES（crec.product_id，crec.customer_id，crec.sd，3，crec.promotion_id，crec .quantity，crec.amount）;异常当其他人然后错误：= sqlerrm; INSERT INTO sales_activity_error VALUES（errm，crec.product_id，crec.customer_id，crec.sd，crec.promotion_id，crec.quantity，crec.amount）;结束; END循环;结束; /</pre></div>
                        <!-- class="section" -->
                     </div>
                  </div><a id="DWHSG8337"></a><div class="props_rev_3"><a id="GUID-F8F527F2-A7D7-4262-A1F0-D1E84FC3DD54" name="GUID-F8F527F2-A7D7-4262-A1F0-D1E84FC3DD54"></a><h5 id="DWHSG-GUID-F8F527F2-A7D7-4262-A1F0-D1E84FC3DD54" class="sect5"><span class="enumeration_section">18.4.2.3</span>使用错误记录表处理数据错误</h5>
                     <div>
                        <div class="section">
                           <p>DML错误<a id="d63021e1771" class="indexterm-anchor"></a>日志记录通过允许您指定错误日志记录表的名称来扩展现有DML功能，Oracle数据库应记录DML操作期间遇到的错误。这使您可以在出现任何错误的情况下完成DML操作，并在以后对错误的行采取纠正措施。
                           </p>
                           <p>此DML错误记录表由若干强制控制列和一组用户定义的列组成，这些列表示DML操作的目标表的全部或部分列，使用能够存储潜在错误的数据类型。目标栏。例如，您需要在错误记录表中使用<code class="codeph">VARCHAR2</code>数据类型来存储目标表中<code class="codeph">NUMBER</code>列的<code class="codeph">TO_NUM</code>数据类型转换错误。您<a id="d63021e1787" class="indexterm-anchor"></a>应该使用<code class="codeph">DBMS_ERRLOG</code>包来创建DML错误记录表。有关此程序包和日志记录表结构的详细信息，请参阅<a href="../arpls/DBMS_ERRLOG.html#ARPLS680" target="_blank"><span class="italic">Oracle Database PL / SQL程序包和类型参考</span></a> 。
                           </p>
                           <p>DML目标表和错误日志记录表之间的列名称映射确定为DML操作记录除控制列之外的哪些列。</p>
                           <p>以下语句说明了如何<span class="q"><a href="loading-transformation-date-warehouses.html#GUID-E1BA12C1-5CE7-405C-8BC7-745ADE615E90">使用</a></span> DML错误日志记录增强<span class="q">“ <a href="loading-transformation-date-warehouses.html#GUID-E1BA12C1-5CE7-405C-8BC7-745ADE615E90">使用SQL转换数据</a> ”中</span>的示例：</p><pre class="oac_no_warn" dir="ltr">INSERT / * + APPEND PARALLEL * / INTO销售SELECT product_id，customer_id，TRUNC（sales_date），3，promotion_id，数量，金额FROM sales_activity_direct LOG ERRORS INTO sales_activity_errors（'load_20040802'）REJECT LIMIT UNLIMITED</pre><p>所有数据错误都记录在表<code class="codeph">sales_activity_errors</code> ，由可选标记<code class="codeph">load_20040802</code> 。即使存在数据错误， <code class="codeph">INSERT</code>语句也会成功。请注意，在使用此语句之前，必须创建DML错误日志记录表。
                           </p>
                           <p>如果指定了<code class="codeph">REJECT</code> <code class="codeph">LIMIT</code> <code class="codeph">X</code> ，则该语句将失败并显示错误消息<code class="codeph">error X=1</code> 。对于不同的拒绝限制，错误消息可能不同。在失败语句的情况下，仅回滚DML语句，而不是插入DML错误记录表。错误记录表将包含X + 1行。
                           </p>
                           <p>DML错误日志记录表可以与执行用户位于不同的模式中，但在这种情况下必须完全指定表名。可选地，可以省略DML错误记录表的名称;然后Oracle假定由生成的表的默认名称<a id="d63021e1839" class="indexterm-anchor"></a><a id="d63021e1841" class="indexterm-anchor"></a> <code class="codeph">DBMS_ERRLOG</code>包。
                           </p>
                           <p>Oracle数据库在DML操作期间记录以下错误：</p>
                        </div>
                        <!-- class="section" -->
                        <div class="section">
                           <ul style="list-style-type:disc">
                              <li>
                                 <p>列值太大。</p>
                              </li>
                              <li>
                                 <p>约束违规（ <code class="codeph">NOT</code> <code class="codeph">NULL</code> ，唯一，引用和检查约束）。
                                 </p>
                              </li>
                              <li>
                                 <p>触发器执行期间引发的错误。</p>
                              </li>
                              <li>
                                 <p>子查询中的列与表的相应列之间的类型转换导致的错误。</p>
                              </li>
                              <li>
                                 <p>分区映射错误。</p>
                              </li>
                           </ul>
                           <p>以下条件导致语句失败并回滚而不调用错误日志记录功能：</p>
                           <ul style="list-style-type:disc">
                              <li>
                                 <p>违反延迟约束。</p>
                              </li>
                              <li>
                                 <p>空间错误。</p>
                              </li>
                              <li>
                                 <p>任何引发唯一约束或索引冲突的直接路径<code class="codeph">INSERT</code>操作（ <code class="codeph">INSERT</code>或<code class="codeph">MERGE</code> ）。
                                 </p>
                              </li>
                              <li>
                                 <p>任何引发唯一约束或索引违例的<code class="codeph">UPDATE</code>操作（ <code class="codeph">UPDATE</code>或<code class="codeph">MERGE</code> ）。
                                 </p>
                              </li>
                           </ul>
                           <p>此外，您无法在<code class="codeph">LONG</code> ， <code class="codeph">LOB</code>或对象类型列的错误记录表中跟踪错误。有关使用错误日志记录时的限制的详细信息，请参阅<a href="../sqlrf/INSERT.html#SQLRF55101" target="_blank"><span class="italic">Oracle数据库SQL语言参考</span></a>
                           </p>
                           <p>DML错误日志记录可以应用于任何类型的DML操作。以下部分将讨论几个示例。</p>
                           <p>请注意，SQL * Loader作为外部装入实用程序也提供了记录数据错误的功能，但缺少数据库内部集成ETL处理的优势。</p>
                        </div>
                        <!-- class="section" -->
                     </div>
                  </div>
               </div>
            </div><a id="DWHSG8338"></a><div class="props_rev_3"><a id="GUID-DD11528E-EE2A-4640-B8F1-75E6D3EB08F6" name="GUID-DD11528E-EE2A-4640-B8F1-75E6D3EB08F6"></a><h3 id="DWHSG-GUID-DD11528E-EE2A-4640-B8F1-75E6D3EB08F6" class="sect3"><span class="enumeration_section">18.5</span>加载和转换场景</h3>
               <div>
                  <p>以下部分提供了典型加载和转换任务的示例：</p>
                  <ul style="list-style-type:disc">
                     <li>
                        <p><a href="loading-transformation-date-warehouses.html#GUID-8AFBA8C7-D42C-4860-942D-BF5DB229B378">关键查找场景</a></p>
                     </li>
                     <li>
                        <p><a href="loading-transformation-date-warehouses.html#GUID-F03860DA-EE32-46EF-A670-D6E7DE037669">业务规则违规方案</a></p>
                     </li>
                     <li>
                        <p><a href="loading-transformation-date-warehouses.html#GUID-E99E3CAC-83BC-448E-9CF3-D45432BE34A0">数据错误方案</a></p>
                     </li>
                     <li>
                        <p><a href="loading-transformation-date-warehouses.html#GUID-BE3DFCBF-6BDF-421D-BA6D-F37EB98D6ECD">透视场景</a></p>
                     </li>
                  </ul>
               </div><a id="DWHSG8339"></a><div class="props_rev_3"><a id="GUID-8AFBA8C7-D42C-4860-942D-BF5DB229B378" name="GUID-8AFBA8C7-D42C-4860-942D-BF5DB229B378"></a><h4 id="DWHSG-GUID-8AFBA8C7-D42C-4860-942D-BF5DB229B378" class="sect4"><span class="enumeration_section">18.5.1</span>关键查找场景</h4>
                  <div>
                     <p><a id="d63021e1993" class="indexterm-anchor"></a>典型的转换是密钥查找。例如，假设销售交易数据已加载到零售数据仓库中。虽然数据仓库的<code class="codeph">sales</code>表包含<code class="codeph">product_id</code>列，但从源系统提取的销售交易数据包含统一价格代码（UPC）而不是产品ID。因此，在将新的销售交易数据插入<code class="codeph">sales</code>表之前，有必要将UPC代码转换为产品ID。
                     </p>
                     <p>为了执行此转换，查找表必须将<code class="codeph">product_id</code>值与UPC代码相关联。此表可能是<code class="codeph">product</code>维度表，也可能是数据仓库中专门为支持此转换而创建的另一个表。对于此示例，您假设有一个名为<code class="codeph">product</code>的表，其中包含<code class="codeph">product_id</code>和<code class="codeph">upc_code</code>列。
                     </p>
                     <p>可以使用以下CTAS语句实现此数据替换转换：</p><pre class="oac_no_warn" dir="ltr">CREATE TABLE temp_sales_step2 NOLOGGING PARALLEL AS SELECT sales_transaction_id，product.product_id sales_product_id，sales_customer_id，sales_time_id，sales_channel_id，sales_quantity_sold，sales_dollar_amount FROM temp_sales_step1，product WHERE temp_sales_step1.upc_code = product.upc_code;</pre><p>此CTAS语句将每个有效的UPC代码转换为有效的<code class="codeph">product_id</code>值。如果ETL过程保证每个UPC代码都有效，那么仅此语句可能足以实现整个转换。
                     </p>
                  </div>
               </div><a id="DWHSG8340"></a><div class="props_rev_3"><a id="GUID-F03860DA-EE32-46EF-A670-D6E7DE037669" name="GUID-F03860DA-EE32-46EF-A670-D6E7DE037669"></a><h4 id="DWHSG-GUID-F03860DA-EE32-46EF-A670-D6E7DE037669" class="sect4"><span class="enumeration_section">18.5.2</span>业务规则违规情形</h4>
                  <div>
                     <p>在前面的示例中，如果还必须处理没有有效UPC代码的新销售数据（逻辑数据错误），则可以使用其他CTAS语句来标识无效行：</p><pre class="oac_no_warn" dir="ltr">CREATE TABLE temp_sales_step1_invalid NOLOGGING PARALLEL PARALLEL as SELECT * from temp_sales_step1 s WHERE NOT EXISTS（SELECT 1 FROM product p WHERE p.upc_code = s.upc_code）;</pre><p>此无效数据现在存储在单独的表<code class="codeph">temp_sales_step1_invalid</code> ，并且可以由ETL过程单独处理。
                     </p>
                     <p>处理无效数据的另一种方法是修改原始CTAS以使用外连接，如以下语句中所示：</p><pre class="oac_no_warn" dir="ltr">CREATE TABLE temp_sales_step2 NOLOGGING PARALLEL AS SELECT sales_transaction_id，product.product_id sales_product_id，sales_customer_id，sales_time_id，sales_channel_id，sales_quantity_sold，sales_dollar_amount FROM temp_sales_step1，product WHERE temp_sales_step1.upc_code = product.upc_code（+）;</pre><p>使用此外部联接，最初包含无效UPC代码的销售事务将被赋予<code class="codeph">product_id</code>为<code class="codeph">NULL</code> 。这些交易可以在以后处理。或者，您可以使用多表插入，将<code class="codeph">product_id</code>为<code class="codeph">NULL</code>的值分隔到一个单独的表中;当预期错误计数与总数据量相比相对较小时，这可能是一种有益的方法。您不必触摸大目标表，只需要一个小目标表进行后续处理。
                     </p><pre class="oac_no_warn" dir="ltr">INSERT / * + APPEND PARALLEL * / FIRST WHEN sales_product_id IS NOT NULL然后进入temp_sales_step2 VALUES（sales_transaction_id，sales_product_id，sales_customer_id，sales_time_id，sales_channel_id，sales_quantity_sold，sales_dollar_amount）ELSE INTO temp_sales_step1_invalid VALUES（sales_transaction_id，sales_product_id，sales_customer_id，sales_time_id，sales_channel_id，sales_quantity_sold， sales_dollar_amount）SELECT sales_transaction_id，product.product_id sales_product_id，sales_customer_id，sales_time_id，sales_channel_id，sales_quantity_sold，sales_dollar_amount FROM temp_sales_step1，product WHERE temp_sales_step1.upc_code = product.upc_code（+）;</pre><p>请注意，对于此解决方案，空表<code class="codeph">temp_sales_step2</code>和<code class="codeph">temp_sales_step1_invalid</code>必须已存在。
                     </p>
                     <p>存在处理无效UPC码的其他方法。某些数据仓库可能选择将空值<code class="codeph">product_id</code>值插入其<code class="codeph">sales</code>表中，而其他数据仓库可能不允许将整个批次中的任何新数据插入到<code class="codeph">sales</code>表中，直到所有无效的UPC代码都被解决。正确的方法取决于数据仓库的业务需求。无论具体要求如何，异常处理都可以通过与转换相同的基本SQL技术来解决。
                     </p>
                  </div>
               </div><a id="DWHSG8341"></a><div class="props_rev_3"><a id="GUID-E99E3CAC-83BC-448E-9CF3-D45432BE34A0" name="GUID-E99E3CAC-83BC-448E-9CF3-D45432BE34A0"></a><h4 id="DWHSG-GUID-E99E3CAC-83BC-448E-9CF3-D45432BE34A0" class="sect4"><span class="enumeration_section">18.5.3</span>数据错误场景</h4>
                  <div>
                     <p>如果数据质量未知，则可以增强<a href="loading-transformation-date-warehouses.html#GUID-F03860DA-EE32-46EF-A670-D6E7DE037669">业务规则违规方案中</a>讨论的示例以处理意外的数据错误，例如，数据类型转换错误，如下所示：</p><pre class="oac_no_warn" dir="ltr">INSERT / * + APPEND PARALLEL * / FIRST当sales_product_id不为空时tempSales_step2 VALUES（sales_transaction_id，sales_product_id，sales_customer_id，sales_time_id，sales_channel_id，sales_quantity_sold，sales_dollar_amount）LOG ERRORS INTO sales_step2_errors（'load_20040804'）REJECT LIMIT UNLIMITED ELSE INTO temp_sales_step1_invalid VALUES（ sales_transaction_id，sales_product_id，sales_customer_id，sales_time_id，sales_channel_id，sales_quantity_sold，sales_dollar_amount）LOG误差引入sales_step2_errors（ 'load_20040804'）REJECT LIMIT UNLIMITED SELECT sales_transaction_id，PRODUCT.PRODUCT_ID sales_product_id，sales_customer_id，sales_time_id，sales_channel_id，sales_quantity_sold，sales_dollar_amount FROM temp_sales_step1，产品WHERE temp_sales_step1。 upc_code = product.upc_code（+）;</pre><p>此语句跟踪表<code class="codeph">temp_sales_step1_invalid</code>中没有有效产品UPC代码的逻辑数据错误以及名为<code class="codeph">sales_step2_errors</code>的DML错误记录表中的所有其他可能错误。请注意，错误记录表可用于多个DML操作。
                     </p>
                     <p>此方法的替代方法是强制使用<code class="codeph">NOT</code> <code class="codeph">NULL</code>约束在数据库级别上拥有有效UPC代码的业务规则。使用外部联接，所有没有有效UPC代码的订单都将映射到<code class="codeph">NULL</code>值，然后将其视为数据错误。此DML错误日志记录功能用于在以下语句中跟踪这些错误：</p><pre class="oac_no_warn" dir="ltr">INSERT / * + APPEND PARALLEL * / INTO temp_sales_step2 VALUES（sales_transaction_id，sales_product_id，sales_customer_id，sales_time_id，sales_channel_id，sales_quantity_sold，sales_dollar_amount）SELECT sales_transaction_id，PRODUCT.PRODUCT_ID sales_product_id，sales_customer_id，sales_time_id，sales_channel_id，sales_quantity_sold，sales_dollar_amount FROM temp_sales_step1，产品WHERE temp_sales_step1。 upc_code = product.upc_code（+）LOG ERRORS INTO sales_step2_errors（'load_20040804'）REJECT LIMIT UNLIMITED;</pre><p>错误记录表包含导致DML操作失败的所有记录。您可以使用其内容来分析和更正任何错误。无论DML操作本身是否成功，都会为任何DML操作保留错误记录表中的内容。让我们假设以下SQL语句失败，因为达到了拒绝限制：</p><pre class="oac_no_warn" dir="ltr">SQL&gt; INSERT / * + APPEND NOLOGGING PARALLEL * / INTO sales_overall 2 SELECT * FROM sales_activity_direct 3 LOG ERRORS INTO err $ _sales_overall（'load_test2'）4 REJECT LIMIT 10; SELECT * FROM sales_activity_direct * ERROR在第2行：ORA-01722：无效的数字</pre><p>该<a id="d63021e2155" class="indexterm-anchor"></a>错误记录表的名称<code class="codeph">err$_sales_overall</code>是使用<code class="codeph">DBMS_ERRLOG</code>包派生的缺省值。有关更多信息，请参见<a href="../arpls/DBMS_ERRLOG.html#ARPLS680" target="_blank"><span class="italic">Oracle Database PL / SQL包和类型参考</span></a> 。
                     </p>
                     <p>Oracle引发的错误消息发生在达到错误限制之后的第一个错误消息。下一个错误（编号11）是引发错误的错误。显示的错误消息基于超出限制的错误，因此，例如，第九个错误可能与第十一个错误不同。</p>
                     <p>目标表<code class="codeph">sales_overall</code>将不显示正在输入的任何记录（假设该表之前为空），但错误记录表将包含11行（ <code class="codeph">REJECT</code> <code class="codeph">LIMIT</code> <code class="codeph">+</code> <code class="codeph">1</code> ）</p><pre class="oac_no_warn" dir="ltr">SQL&gt; SELECT COUNT（*）FROM sales_overall; COUNT（*）---------- 0 SQL&gt; SELECT COUNT（*）FROM err $ _sales_overall; COUNT（*）---------- 11</pre><p>DML错误记录表由几个固定控制列组成，这些列对于每个错误记录表都是必需的。除Oracle错误号外，Oracle还强制存储错误消息。在许多情况下，错误消息提供了额外的信息来分析和解决数据错误的根本原因。DML错误记录表的以下SQL输出显示了这种差异。请注意，第二个输出包含因<code class="codeph">NOT</code> <code class="codeph">NULL</code>违规而被拒绝的行的附加信息。
                     </p><pre class="oac_no_warn" dir="ltr">SQL&gt; SELECT DISTINCT ora_err_number $ FROM err $ _sales_overall; ORA_ERR_NUMBER $ --------------- 1400 1722 1830 1847 SQL&gt; SELECT DISTINCT ora_err_number $，ora_err_mesg $ FROM err $ _sales_overall; ORA_ERR_NUMBER $ ORA_ERR_MESG $ 1400 ORA-01400：无法插入NULL（“SH”。“SALES_OVERALL”。“CUST_ID”）1400 ORA-01400：无法插入NULL（“SH”。“SALES_OVERALL”。“PROD_ID”）1722 ORA -01722：无效数字1830 ORA-01830：日期格式图片在转换整个输入字符串之前结束1847 ORA-01847：月中的日期必须介于1和月的最后一天之间</pre><div class="infoboxnotealso" id="GUID-E99E3CAC-83BC-448E-9CF3-D45432BE34A0__GUID-061305F1-B55F-4522-9BF0-72BE286359F1">
                        <p class="notep1">也可以看看：</p>
                        <p>有关控制列的详细说明，请参见<a href="../admin/managing-tables.html#ADMIN10261" target="_blank"><span class="italic">“Oracle数据库管理员指南”</span></a> 。
                        </p>
                     </div>
                  </div>
               </div><a id="DWHSG8343"></a><a id="DWHSG8342"></a><div class="props_rev_3"><a id="GUID-BE3DFCBF-6BDF-421D-BA6D-F37EB98D6ECD" name="GUID-BE3DFCBF-6BDF-421D-BA6D-F37EB98D6ECD"></a><h4 id="DWHSG-GUID-BE3DFCBF-6BDF-421D-BA6D-F37EB98D6ECD" class="sect4"><span class="enumeration_section">18.5.4</span>透视场景</h4>
                  <div>
                     <p><a id="d63021e2232" class="indexterm-anchor"></a>数据仓库可以<a id="d63021e2235" class="indexterm-anchor"></a>接收来自许多不同来源的数据。这些源系统中的一些可能不是关系数据库，并且可以以与数据仓库非常不同的格式存储数据。例如，假设您从具有以下形式的非关系数据库中收到一组销售记录：</p><pre class="oac_no_warn" dir="ltr">product_id，customer_id，weekly_start_date，sales_sun，sales_mon，sales_tue，sales_wed，sales_thu，sales_fri，sales_sat</pre><p>输入表如下所示：</p><pre class="oac_no_warn" dir="ltr">SELECT * FROM sales_input_table;</pre><pre class="oac_no_warn" dir="ltr">PRODUCT_ID CUSTOMER_ID WEEKLY_ST SALES_SUN SALES_MON SALES_TUE SALES_WED SALES_THU SALES_FRI SALES_SAT ---------- ----------- --------- ---------- ---------- ---------- -------------------- ---------- ---------- 111 222 01-OCT-00 100 200 300 400 500 600 700 222 333 08-OCT-00 200 300 400 500 600 700 800 333 444 15-OCT-00 300 400 500 600 700 800 900</pre><p>在数据仓库中，您希望将记录以更典型的关系形式存储在<code class="codeph">sh</code>示例模式的事实表<code class="codeph">sales</code>中：</p><pre class="oac_no_warn" dir="ltr">prod_id，cust_id，time_id，amount_sold</pre><div class="infoboxnote" id="GUID-BE3DFCBF-6BDF-421D-BA6D-F37EB98D6ECD__GUID-C310F522-8844-48A7-83E8-A1EB97C34BD3">
                        <p class="notep1">注意：</p>
                        <p>出于此示例的目的，已禁用<code class="codeph">sales</code>表上的许多约束，因为为简洁起见，该示例忽略了许多表列。
                        </p>
                     </div>
                     <p>因此，您需要构建转换，以便输入流中的每条记录必须转换为数据仓库<code class="codeph">sales</code>表的七条记录。此操作通常称为<a href="glossary.html#GUID-CE6745C6-610E-4EEA-BD47-534C9CBF44A9"><span class="xrefglossterm">透视</span></a> ，Oracle数据库提供了几种方法。
                     </p>
                     <p>上一个示例的结果将类似于以下内容：</p><pre class="oac_no_warn" dir="ltr">SELECT prod_id，cust_id，time_id，amount_sold FROM sales; PROD_ID CUST_ID TIME_ID AMOUNT_SOLD ---------- ---------- --------- ----------- 111 222 01-OCT- 00 100 111 222 02-OCT-00 200 111 222 03-OCT-00 300 111 222 04-OCT-00 400 111 222 05-OCT-00 500 111 222 06-OCT-00 600 111 222 07-OCT-00 700 222 333 08-OCT-00 200 222 333 09-OCT-00 300 222 333 10-OCT-00 400 222 333 11-OCT-00 500 222 333 12-OCT-00 600 222 333 13-OCT-00 700 222 333 14-OCT-00 800 333 444 15-OCT-00 300 333 444 16-OCT-00 400 333 444 17-OCT-00 500 333 444 18-OCT-00 600 333 444 19-OCT-00 700 333 444 20- OCT-00 800 333 444 21-OCT-00 900</pre><div class="example" id="GUID-BE3DFCBF-6BDF-421D-BA6D-F37EB98D6ECD__GUID-82E18458-E50D-4335-AD42-F5E03B458225">
                        <p class="titleinexample">例18-10透视示例</p>
                        <p>以下示例使用多表格插入语法将一些数据从具有不同结构的输入表插入到演示表<code class="codeph">sh.sales</code> 。多表<code class="codeph">INSERT</code>语句如下所示：</p><pre class="oac_no_warn" dir="ltr">INSERT ALL INTO sales（prod_id，cust_id，time_id，amount_sold）VALUES（product_id，customer_id，weekly_start_date，sales_sun）INTO sales（prod_id，cust_id，time_id，amount_sold）VALUES（product_id，customer_id，weekly_start_date + 1，sales_mon）INTO sales（prod_id） ，cust_id，time_id，amount_sold）VALUES（product_id，customer_id，weekly_start_date + 2，sales_tue）INTO销售（prod_id，cust_id，time_id，amount_sold）VALUES（product_id，customer_id，weekly_start_date + 3，sales_wed）INTO销售（prod_id，cust_id，time_id） ，amount_sold）VALUES（product_id，customer_id，weekly_start_date + 4，sales_thu）INTO销售（prod_id，cust_id，time_id，amount_sold）VALUES（product_id，customer_id，weekly_start_date + 5，sales_fri）INTO销售（prod_id，cust_id，time_id，amount_sold）VALUES （product_id，customer_id，weekly_start_date + 6，sales_sat）SELECT product_id，customer_id，weekly_start_date，sales_sun，sales_mon，sales_tue，sales_wed，sales_thu，sales_fri，sales_sat FROM sales_input_table;</pre><p>此语句仅扫描源表一次，然后插入每天的相应数据。</p>
                     </div>
                     <!-- class="example" -->
                     <div class="infoboxnotealso" id="GUID-BE3DFCBF-6BDF-421D-BA6D-F37EB98D6ECD__GUID-52555A81-C1EA-47A4-942E-9ACE219CBAED">
                        <p class="notep1">也可以看看：</p>
                        <ul style="list-style-type:disc">
                           <li>
                              <p><span class="q">“ <a href="sql-analysis-reporting-data-warehouses.html#GUID-05BB22CD-0F53-4C90-AE84-CE3F88DBD591">透视操作</a> ”</span>有关旋转的更多信息</p>
                           </li>
                           <li>
                              <p>用于<code class="codeph">pivot_clause</code>语法的<a href="../sqlrf/SELECT.html#SQLRF01702" target="_blank"><span class="italic">Oracle数据库SQL语言参考</span></a></p>
                           </li>
                        </ul>
                     </div>
                  </div>
               </div>
            </div>
         </div>
      </article>
   </body>
</html>