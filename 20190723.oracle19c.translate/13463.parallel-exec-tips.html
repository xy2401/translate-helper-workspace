<html lang="en-us" dir="ltr" xml:lang="en-us">
   <head>
      <meta http-equiv="Content-Type" content="text/html; charset=utf-8"></meta>
      <meta name="viewport" content="width=device-width, initial-scale=1"></meta>
      <meta http-equiv="X-UA-Compatible" content="IE=edge"></meta>
      <meta name="abstract" content="Various ideas for improving performance in a parallel execution environment are discussed under this section."></meta>
      <meta name="description" content="Various ideas for improving performance in a parallel execution environment are discussed under this section."></meta>
      <title>调整并行执行的提示</title>
      <meta property="og:site_name" content="Oracle Help Center"></meta>
      <meta property="og:title" content="VLDB and Partitioning Guide"></meta>
      <meta property="og:description" content="Various ideas for improving performance in a parallel execution environment are discussed under this section."></meta>
      <link rel="stylesheet" href="/sp_common/book-template/ohc-book-template/css/book.css"></link>
      <link rel="shortcut icon" href="/sp_common/book-template/ohc-common/img/favicon.ico"></link>
      <meta name="application-name" content="VLDB and Partitioning Guide"></meta>
      <meta name="generator" content="DITA Open Toolkit version 1.8.5 (Mode = doc)"></meta>
      <meta name="plugin" content="SP_docbuilder HTML plugin release 18.2.2"></meta>
      <link rel="alternate" href="vldb-and-partitioning-guide.pdf" title="PDF File" type="application/pdf"></link>
      <meta name="robots" content="all"></meta>
      <link rel="schema.dcterms" href="http://purl.org/dc/terms/"></link>
      <meta name="dcterms.created" content="2019-04-23T18:05:22-07:00"></meta>
      <meta name="dcterms.title" content="VLDB and Partitioning Guide"></meta>
      <meta name="dcterms.dateCopyrighted" content="2008, 2019"></meta>
      <meta name="dcterms.category" content="database"></meta>
      <meta name="dcterms.identifier" content="E96199-03"></meta>
      
      <meta name="dcterms.product" content="en/database/oracle/oracle-database/19"></meta>
      
      <link rel="prev" href="monitor-parallel-performance.html" title="Previous" type="text/html"></link>
      <link rel="next" href="vldb-backup.html" title="Next" type="text/html"></link>
      <script>
        document.write('<style type="text/css">');
        document.write('body > .noscript, body > .noscript ~ * { visibility: hidden; }');
        document.write('</style>');
     </script>
      <script src="/sp_common/book-template/requirejs/require.js" data-main="/sp_common/book-template/ohc-book-template/js/book-config"></script>
      <script>
            if (window.require === undefined) {
                document.write('<script data-main="sp_common/book-template/ohc-book-template/js/book-config" src="sp_common/book-template/requirejs/require.js"><\/script>');
                document.write('<link href="sp_common/book-template/ohc-book-template/css/book.css" rel="stylesheet"/>');
            }
        </script>
      <script type="application/json" id="ssot-metadata">{"primary":{"category":{"short_name":"database","element_name":"Database","display_in_url":true},"suite":{"short_name":"oracle","element_name":"Oracle","display_in_url":true},"product_group":{"short_name":"not-applicable","element_name":"Not applicable","display_in_url":false},"product":{"short_name":"oracle-database","element_name":"Oracle Database","display_in_url":true},"release":{"short_name":"19","element_name":"Release 19","display_in_url":true}}}</script>
      
    <meta name="dcterms.isVersionOf" content="VLDBG"></meta>
    <meta name="dcterms.release" content="Release 19"></meta>
  </head>
   <body dir="ltr">
      <div class="noscript alert alert-danger text-center" role="alert">
         <a href="monitor-parallel-performance.html" class="pull-left"><span class="glyphicon glyphicon-chevron-left" aria-hidden="true"></span>上一页</a> <a href="vldb-backup.html" class="pull-right">下一页<span class="glyphicon glyphicon-chevron-right" aria-hidden="true"></span></a> <span class="fa fa-exclamation-triangle" aria-hidden="true"></span>必须启用JavaScript才能正确显示此内容</div>
      <article>
         <header>
            <ol class="breadcrumb" vocab="http://schema.org/" typeof="BreadcrumbList">
               <li property="itemListElement" typeof="ListItem"><a href="index.html" property="item" typeof="WebPage"><span property="name">VLDB和分区指南</span></a></li>
               <li property="itemListElement" typeof="ListItem"><a href="using-parallel.html" property="item" typeof="WebPage"><span property="name">使用并行执行</span></a></li>
               <li class="active" property="itemListElement" typeof="ListItem">调整并行执行的提示</li>
            </ol>
            <a id="GUID-4EE9408B-C03A-4842-9F24-C24EA2A3E704" name="GUID-4EE9408B-C03A-4842-9F24-C24EA2A3E704"></a><a id="VLDBG1525"></a>
            
            <h2 id="VLDBG-GUID-4EE9408B-C03A-4842-9F24-C24EA2A3E704" class="sect2">调整并行执行的提示</h2>
         </header>
         <div class="ind">
            <div>
               <p>本节讨论了在并行执行环境中提高性能的各种想法。</p>
               <p>本节包含以下主题：</p>
               <ul style="list-style-type:disc">
                  <li>
                     <p><a href="parallel-exec-tips.html#GUID-FB1C39E9-CA3E-4AC6-9B01-4B3D99BDC79B" title="实施良好的并行执行策略对于确保高性能非常重要。">实施并行执行策略</a></p>
                  </li>
                  <li>
                     <p><a href="parallel-exec-tips.html#GUID-7A6185D1-AEF3-48C3-A704-8E3D7D3A4AFD" title="要优化检索大型结果集的查询的并行执行性能，请并行创建和填充表。">通过并行创建和填充表来优化性能</a></p>
                  </li>
                  <li>
                     <p><a href="parallel-exec-tips.html#GUID-F9F7C98A-9EA2-42D8-8AA5-46454C64E901" title="使用EXPLAIN PLAN语句查看并行查询的执行计划。">使用EXPLAIN PLAN显示并行操作计划</a></p>
                  </li>
                  <li>
                     <p><a href="parallel-exec-tips.html#GUID-6181F1F5-CCD0-4F95-B831-1045C5F8EC2D" title="本主题介绍了使用并行DML操作时的其他注意事项。">并行DML的其他注意事项</a></p>
                  </li>
                  <li>
                     <p><a href="parallel-exec-tips.html#GUID-5A52793F-15AE-4C86-B8A4-4D7965575BB0" title="您可以通过并行创建索引来优化性能。">通过并行创建索引来优化性能</a></p>
                  </li>
                  <li>
                     <p><a href="parallel-exec-tips.html#GUID-08A08783-C243-4872-AFFA-56B603F1F0F5" title="本主题介绍了并行DML功能的提示。">并行DML技巧</a></p>
                  </li>
                  <li>
                     <p><a href="parallel-exec-tips.html#GUID-35FF4DC9-F6FC-4634-832B-55ABBA531434" title="并行DML与可更新的连接视图工具相结合，为刷新数据仓库系统的表提供了有效的解决方案。">并行增量数据加载</a></p>
                  </li>
               </ul>
            </div>
            <div class="sect2"><a id="GUID-FB1C39E9-CA3E-4AC6-9B01-4B3D99BDC79B" name="GUID-FB1C39E9-CA3E-4AC6-9B01-4B3D99BDC79B"></a><h3 id="VLDBG-GUID-FB1C39E9-CA3E-4AC6-9B01-4B3D99BDC79B" class="sect3">实施并行执行策略</h3>
               <div>
                  <p>实施良好的并行执行策略对于确保高性能非常重要。</p>
                  <p>关于良好战略的建议包括：</p>
                  <ul style="list-style-type:disc">
                     <li>
                        <p>实施简单的设置以了解系统中发生的情况。</p>
                     </li>
                     <li>
                        <p>使用资源管理器为使用者组指定最大并行度（DOP），以便为每个组分配特定数量的处理资源，而不会使系统崩溃。使用并行执行来控制系统时，需要资源管理策略，并确保SQL语句能够并行执行。</p>
                     </li>
                     <li>
                        <p>根据您希望为并行执行提供的系统资源量来制定策略。调整参数<code class="codeph">PARALLEL_MAX_SERVERS</code>和<code class="codeph">PARALLEL_SERVERS_TARGET</code>的值以限制在系统中运行的并行执行（PX）服务器的数量。
                        </p>
                     </li>
                     <li>
                        <p>考虑采用ELT（提取，加载和转换）策略而不是ETL（提取，转换和加载）策略。</p>
                     </li>
                     <li>
                        <p>使用具有并行SQL语句的外部表（例如CTAS或IAS）可以加快数据加载速度</p>
                     </li>
                  </ul>
               </div>
            </div><a id="VLDBG1526"></a><div class="props_rev_3"><a id="GUID-7A6185D1-AEF3-48C3-A704-8E3D7D3A4AFD" name="GUID-7A6185D1-AEF3-48C3-A704-8E3D7D3A4AFD"></a><h3 id="VLDBG-GUID-7A6185D1-AEF3-48C3-A704-8E3D7D3A4AFD" class="sect3">通过并行创建和填充表来优化性能</h3>
               <div>
                  <p>要优化检索大型结果集的查询的并行执行性能，请并行创建和填充表。</p>
                  <p>Oracle数据库无法并行地将结果返回给用户进程。如果查询返回大量行，则查询的执行可能确实更快。但是，用户进程只能串行接收行。要优化检索大型结果集的查询的并行执行性能，请使用<code class="codeph">PARALLEL</code> <code class="codeph">CREATE</code> <code class="codeph">TABLE</code> <code class="codeph">AS</code> <code class="codeph">SELECT</code>或直接路径<code class="codeph">INSERT</code>将结果集存储在数据库中。稍后，用户可以连续查看结果集。
                  </p>
                  <p>并行执行<code class="codeph">SELECT</code>不会影响<code class="codeph">CREATE</code>语句。但是，如果并行执行<code class="codeph">CREATE</code>语句，优化程序也会尝试使<code class="codeph">SELECT</code>并行运行。
                  </p>
                  <p>与<code class="codeph">NOLOGGING</code>选项结合使用时， <code class="codeph">CREATE</code> <code class="codeph">TABLE</code> <code class="codeph">AS</code> <code class="codeph">SELECT</code>的并行版本提供了非常有效的中间表工具，例如：</p><pre class="oac_no_warn" dir="ltr">CREATE TABLE摘要PARALLEL NOLOGGING AS SELECT dim_1，dim_2 ...，SUM（meas_1）FROM facts GROUP BY dim_1，dim_2;</pre><p>这些表也可以通过并行<code class="codeph">INSERT</code>递增加载。您可以使用以下技术利用中间表：</p>
                  <ul style="list-style-type:disc">
                     <li>
                        <p>公共子查询可以计算一次并且可以多次引用。这可以允许一些针对星型模式的查询（特别是没有选择性<code class="codeph">WHERE</code> -clause谓词的查询）更好地并行化。使用星形转换技术的选择性<code class="codeph">WHERE</code> -clause谓词的星型查询可以自动有效地并行化，而无需对SQL进行任何修改。</p>
                     </li>
                     <li>
                        <p>将复杂查询分解为更简单的步骤，以提供应用程序级检查点或重新启动。例如，一个TB级数据库上的复杂多表连接可能会运行数十个小时。此查询期间的失败意味着从头开始。使用<code class="codeph">CREATE</code> <code class="codeph">TABLE</code> <code class="codeph">AS</code> <code class="codeph">SELECT</code>或<code class="codeph">PARALLEL</code> <code class="codeph">INSERT</code> <code class="codeph">AS</code> <code class="codeph">SELECT</code> ，您可以将查询重写为一系列简单的查询，每个查询运行几个小时。如果发生系统故障，可以从上一个完成的步骤重新启动查询。
                        </p>
                     </li>
                     <li>
                        <p>通过创建一个省略原始表中不需要的行的新表，然后删除原始表，有效地实现手动并行删除操作。或者，您可以使用方便的并行删除功能，该功能直接删除原始表中的行。</p>
                     </li>
                     <li>
                        <p>创建汇总表以进行有效的多维深入分析。例如，摘要表可能存储按月，品牌，地区和销售人员分组的收入总和。</p>
                     </li>
                     <li>
                        <p>通过将旧表复制到新表来重新组织表，消除链接行，压缩可用空间等。这比导出/导入快得多，比重新加载更容易。</p>
                     </li>
                  </ul>
                  <p>请务必使用<code class="codeph">DBMS_STATS</code>包来收集有关新创建的表的优化程序统计信息。要避免I / O瓶颈，请指定至少与CPU一样多的物理磁盘条带化的表空间。为避免分配空间中的碎片，表空间中的文件数应为CPU数量的倍数。
                  </p>
                  <div class="infoboxnotealso" id="GUID-7A6185D1-AEF3-48C3-A704-8E3D7D3A4AFD__GUID-6EB35B78-5A56-484A-AA1E-69F743C4A8B6">
                     <p class="notep1">也可以看看：</p>
                     <p><a href="../dwhsg/data-warehouse-optimizations-techniques.html#DWHSG9062" target="_blank"><span><cite>Oracle数据库数据仓库指南</cite></span></a> ，了解有关数据仓库中并行执行的信息</p>
                  </div>
               </div>
            </div><a id="VLDBG1527"></a><div class="props_rev_3"><a id="GUID-F9F7C98A-9EA2-42D8-8AA5-46454C64E901" name="GUID-F9F7C98A-9EA2-42D8-8AA5-46454C64E901"></a><h3 id="VLDBG-GUID-F9F7C98A-9EA2-42D8-8AA5-46454C64E901" class="sect3">使用EXPLAIN PLAN显示并行操作计划</h3>
               <div>
                  <p>使用<code class="codeph">EXPLAIN</code> <code class="codeph">PLAN</code>语句查看并行查询的执行计划。
                  </p>
                  <p><code class="codeph">EXPLAIN</code> <code class="codeph">PLAN</code>输出显示<code class="codeph">COST</code> ， <code class="codeph">BYTES</code>和<code class="codeph">CARDINALITY</code>列中的优化程序信息。您还可以使用<code class="codeph">utlxplp.sql</code>脚本向<code class="codeph">EXPLAIN</code> <code class="codeph">PLAN</code>输出显示所有相关的并行信息。
                  </p>
                  <p>有几种方法可以优化join语句的并行执行。您可以更改系统配置，调整参数，如本章前面所述，或使用提示，例如<code class="codeph">DISTRIBUTION</code>提示。
                  </p>
                  <p>使用<code class="codeph">EXPLAIN</code> <code class="codeph">PLAN</code>时的关键点是：</p>
                  <ul style="list-style-type:disc">
                     <li>
                        <p>验证优化程序选择性估计。如果优化器认为查询只生成了一行，则倾向于使用嵌套循环。这可能表示未分析表或优化程序对同一表上多个谓词的相关性进行了错误估计。可能需要扩展统计信息或提示来为优化程序提供正确的选择性或强制优化程序使用其他连接方法。</p>
                     </li>
                     <li>
                        <p>在低基数连接键上使用散列连接。如果连接键具有很少的不同值，则散列连接可能不是最佳的。如果不同值的数量小于并行度（DOP），则某些并行查询服务器可能无法处理特定查询。</p>
                     </li>
                     <li>
                        <p>考虑数据偏差。如果连接键涉及过多的数据倾斜，则散列连接可能需要一些并行查询服务器才能比其他服务器工作更多。如果优化器没有选择它，请考虑使用提示来生成<code class="codeph">BROADCAST</code>分发方法。仅当<code class="codeph">OPTIMIZER_FEATURES_ENABLE</code>设置为9.0.2或更高版本时， <code class="codeph">OPTIMIZER_FEATURES_ENABLE</code>程序才会考虑<code class="codeph">BROADCAST</code>分发方法。有关更多信息，请参阅<a href="monitor-parallel-performance.html#GUID-81418734-F146-4477-8EC2-145F9A6CEA83" title="您可以使用V $ PQ_TQSTAT动态性能视图监视并行执行性能。">V $ PQ_TQSTAT</a> 。
                        </p>
                     </li>
                  </ul>
               </div><a id="VLDBG1528"></a><div class="props_rev_3"><a id="GUID-3553836E-38CD-4D1C-B624-A310F5A269D7" name="GUID-3553836E-38CD-4D1C-B624-A310F5A269D7"></a><h4 id="VLDBG-GUID-3553836E-38CD-4D1C-B624-A310F5A269D7" class="sect4">示例：使用EXPLAIN PLAN显示并行操作</h4>
                  <div>
                     <p>您可以使用EXPLAIN PLAN显示并行操作。</p>
                     <div class="section">
                        <p>以下示例说明了优化程序打算如何执行并行查询：</p><pre class="oac_no_warn" dir="ltr">解释SELECT / * + PARALLEL * / cust_first_name，cust_last_name FROM customers c，sales s WHERE c.cust_id = s.cust_id; -------------------------------------------------- -------- | Id |操作|名称| -------------------------------------------------- -------- | 0 |选择声明| | | 1 | PX COORDINATOR | | | 2 | PX SEND QC（RANDOM）| ：TQ10000 | | 3 | NESTED LOOPS | | | 4 | PX BLOCK ITERATOR | | | 5 |表访问完全|客户| | 6 | PARTITION RANGE ALL | | | 7 | BITMAP转换为ROWIDS | | | 8 | BITMAP INDEX单一价值| SALES_CUST_BIX | -------------------------------------------------- --------注意-----  - 自动DOP：计算并行度为2</pre></div>
                     <!-- class="section" -->
                  </div>
               </div>
            </div><a id="VLDBG1529"></a><div class="props_rev_3"><a id="GUID-6181F1F5-CCD0-4F95-B831-1045C5F8EC2D" name="GUID-6181F1F5-CCD0-4F95-B831-1045C5F8EC2D"></a><h3 id="VLDBG-GUID-6181F1F5-CCD0-4F95-B831-1045C5F8EC2D" class="sect3">并行DML的其他注意事项</h3>
               <div>
                  <p>本主题介绍了使用并行DML操作时的其他注意事项。</p>
                  <p>如果要使用数据仓库上的并行插入，更新或删除操作来刷新数据仓库数据库，则在设计物理数据库时还需要考虑其他问题。这些注意事项不会影响并行执行操作。这些问题是：</p>
                  <ul style="list-style-type:disc">
                     <li>
                        <p><a href="parallel-exec-tips.html#GUID-6035BB6E-D223-4087-AB01-6AA4003B7777" title="本主题中标识了并行DML和直接路径操作的限制。">并行DML和直接路径限制</a></p>
                     </li>
                     <li>
                        <p><a href="parallel-exec-tips.html#GUID-FEE610A3-F12C-47F6-9571-ADBB08096B06" title="基于所使用的Oracle数据库的软件级别，并行度有一定的限制。">对并行度的限制</a></p>
                     </li>
                     <li>
                        <p><a href="parallel-exec-tips.html#GUID-1FE0C03C-C70A-4109-B574-51A8ADC7DE86" title="在某些情况下，您应该增加INITRANS的值。">何时增加INITRANS</a></p>
                     </li>
                     <li>
                        <p><a href="parallel-exec-tips.html#GUID-17D58575-D0F4-4031-AF07-F67B1769C336" title="字典管理的表空间中的段的可用事务空闲列表的可用数量存在限制。">对段的可用交易免费列表数量的限制</a></p>
                     </li>
                     <li>
                        <p><a href="parallel-exec-tips.html#GUID-8628A98F-CA94-4D52-B3B8-DE3CF8AB2E91" title="归档大量重做日志需要多个归档进程。">用于大量重做日志的多个存档器</a></p>
                     </li>
                     <li>
                        <p><a href="parallel-exec-tips.html#GUID-E042C446-AFFF-4343-9F22-39081EAD0E34" title="在某些情况下，您应该增加数据库编写器进程的数量。">数据库编写器进程（DBWn）工作负载</a></p>
                     </li>
                     <li>
                        <p><a href="parallel-exec-tips.html#GUID-05CE9FD6-3A3E-4441-B2D2-57040F7CA815" title="在设置[NO] LOGGING子句时了解注意事项。">[NO]记录条款</a></p>
                     </li>
                  </ul>
               </div><a id="VLDBG1530"></a><div class="props_rev_3"><a id="GUID-6035BB6E-D223-4087-AB01-6AA4003B7777" name="GUID-6035BB6E-D223-4087-AB01-6AA4003B7777"></a><h4 id="VLDBG-GUID-6035BB6E-D223-4087-AB01-6AA4003B7777" class="sect4">并行DML和直接路径限制</h4>
                  <div>
                     <p>本主题中标识了并行DML和直接路径操作的限制。</p>
                     <p>如果违反了并行限制，则仅简单地执行操作。如果违反直接路径<code class="codeph">INSERT</code>限制，则忽略<code class="codeph">APPEND</code>提示并执行传统的插入操作。没有返回错误消息。
                     </p>
                  </div>
               </div><a id="VLDBG1531"></a><div class="props_rev_3"><a id="GUID-FEE610A3-F12C-47F6-9571-ADBB08096B06" name="GUID-FEE610A3-F12C-47F6-9571-ADBB08096B06"></a><h4 id="VLDBG-GUID-FEE610A3-F12C-47F6-9571-ADBB08096B06" class="sect4">对并行度的限制</h4>
                  <div>
                     <p>基于所使用的Oracle数据库的软件级别，并行度有一定的限制。</p>
                     <p>对于没有并行DML <code class="codeph">itl</code>不变属性的表（在Oracle9 <span class="italic">i</span> Release 2（9.2）之前创建的表或使用<code class="codeph">COMPATIBLE</code>初始化参数设置为小于<code class="codeph">9.2</code>创建的表），并行度（DOP）等于该数分区或子分区。这意味着，如果表未分区，则查询将以串行方式运行。要确定哪些表没有此属性，请发出以下语句：</p><pre class="oac_no_warn" dir="ltr">SELECT u.name，o.name FROM obj $ o，tab $ t，user $ u WHERE o.obj＃= t.obj＃AND o.owner＃= u.user＃AND bitand（t.property，536870912）！= 536870912;</pre><div class="infoboxnotealso" id="GUID-FEE610A3-F12C-47F6-9571-ADBB08096B06__GUID-24D9B1D2-2859-4249-9877-C1793D8F8AD3">
                        <p class="notep1">也可以看看：</p>
                        <p>有关感兴趣的事务列表（ITL）的信息，也可以称为<a href="../cncpt/data-concurrency-and-consistency.html#CNCPT88965" target="_blank"><span><cite>Oracle数据库概念</cite></span></a> ，也称为事务表</p>
                     </div>
                  </div>
               </div><a id="VLDBG1532"></a><div class="props_rev_3"><a id="GUID-1FE0C03C-C70A-4109-B574-51A8ADC7DE86" name="GUID-1FE0C03C-C70A-4109-B574-51A8ADC7DE86"></a><h4 id="VLDBG-GUID-1FE0C03C-C70A-4109-B574-51A8ADC7DE86" class="sect4">何时增加INITRANS</h4>
                  <div>
                     <p>在某些情况下，您应该增加<code class="codeph">INITRANS</code>的值。
                     </p>
                     <p>如果您有全局索引，则全局索引段和全局索引块由同一并行DML语句的服务器进程共享。即使不对同一行执行操作，服务器进程也可以共享相同的索引块。每个服务器事务在对块进行更改之前，在索引块头中需要一个事务条目。</p>
                     <p>在这种情况下，使用<code class="codeph">CREATE</code> <code class="codeph">INDEX</code>或<code class="codeph">ALTER</code> <code class="codeph">INDEX</code>语句时，应将<code class="codeph">INITRANS</code> （每个数据块中分配的初始事务数）设置为较大的值，例如针对此索引的最大DOP。
                     </p>
                  </div>
               </div><a id="VLDBG1533"></a><div class="props_rev_3"><a id="GUID-17D58575-D0F4-4031-AF07-F67B1769C336" name="GUID-17D58575-D0F4-4031-AF07-F67B1769C336"></a><h4 id="VLDBG-GUID-17D58575-D0F4-4031-AF07-F67B1769C336" class="sect4">对段的可用交易免费列表数量的限制</h4>
                  <div>
                     <p>字典管理的表空间中的段的可用事务空闲列表的可用数量存在限制。</p>
                     <p>创建段后，进程和事务空闲列表的数量是固定的，不能更改。如果在段标题中指定了大量进程空闲列表，则可能会发现这限制了可用的事务空闲列表的数量。下次通过减少进程空闲列表的数量重新创建段头时，可以减轻此限制;这为段头中的事务空闲列表留下了更多空间。</p>
                     <p>对于<code class="codeph">UPDATE</code>和<code class="codeph">DELETE</code>操作，每个服务器进程可以要求其自己的事务空闲列表。因此，并行DML DOP有效地受到表上可用的最小数量的事务空闲列表以及DML语句必须维护的任何全局索引的限制。例如，如果表有25个事务空闲列表，并且该表有两个全局索引，一个有50个事务空闲列表，另一个有30个事务空闲列表，则DOP限制为25。如果该表有40个交易免费清单，则DOP将限制为30。
                     </p>
                     <p><code class="codeph">STORAGE</code>子句的<code class="codeph">FREELISTS</code>参数用于设置进程空闲列表的数量。默认情况下，不会创建任何进程空闲列表。
                     </p>
                     <p>默认的事务空闲列表数取决于块大小。例如，如果未明确设置进程空闲列表的数量，则默认情况下，4 KB块具有大约80个事务空闲列表。交易免费清单的最小数量为25。</p>
                  </div>
               </div><a id="VLDBG1534"></a><div class="props_rev_3"><a id="GUID-8628A98F-CA94-4D52-B3B8-DE3CF8AB2E91" name="GUID-8628A98F-CA94-4D52-B3B8-DE3CF8AB2E91"></a><h4 id="VLDBG-GUID-8628A98F-CA94-4D52-B3B8-DE3CF8AB2E91" class="sect4">用于大量重做日志的多个存档器</h4>
                  <div>
                     <p>归档大量重做日志需要多个归档进程。</p>
                     <p>并行DDL和并行DML操作可以生成大量重做日志。用于存档这些重做日志的单个<code class="codeph">ARCH</code>进程可能无法跟上。要避免此问题，您可以手动或使用作业队列生成多个归档进程。
                     </p>
                  </div>
               </div><a id="VLDBG1535"></a><div class="props_rev_3"><a id="GUID-E042C446-AFFF-4343-9F22-39081EAD0E34" name="GUID-E042C446-AFFF-4343-9F22-39081EAD0E34"></a><h4 id="VLDBG-GUID-E042C446-AFFF-4343-9F22-39081EAD0E34" class="sect4">数据库编写器进程（DBWn）工作负载</h4>
                  <div>
                     <p>在某些情况下，您应该增加数据库编写器进程的数量。</p>
                     <p>并行DML操作在短时间间隔内在缓冲区高速缓存中使用大量数据，索引和撤消块。例如，假设您在查询<code class="codeph">V$SYSTEM_EVENT</code>视图后看到大量<code class="codeph">free_buffer_waits</code> ，如以下语法所示：</p><pre class="oac_no_warn" dir="ltr">从V $ SYSTEM_EVENT中选择TOTAL_WAITS，其中EVENT ='FREE BUFFER WAITS';</pre><p>在这种情况下，您应该考虑增加DBW <span class="italic">n</span>进程。如果没有等待空闲缓冲区，则查询不会返回任何行。
                     </p>
                  </div>
               </div><a id="VLDBG1536"></a><div class="props_rev_3"><a id="GUID-05CE9FD6-3A3E-4441-B2D2-57040F7CA815" name="GUID-05CE9FD6-3A3E-4441-B2D2-57040F7CA815"></a><h4 id="VLDBG-GUID-05CE9FD6-3A3E-4441-B2D2-57040F7CA815" class="sect4">[NO]记录条款</h4>
                  <div>
                     <p>在设置<code class="codeph">[NO]LOGGING</code>子句时了解注意事项。
                     </p>
                     <div class="section">
                        <p><code class="codeph">[NO]LOGGING</code>子句适用于表，分区，表空间和索引。如果使用<code class="codeph">NOLOGGING</code>子句，实际上不会为某些操作（例如直接路径<code class="codeph">INSERT</code> ）生成日志。<code class="codeph">NOLOGGING</code>属性未在<code class="codeph">INSERT</code>语句级别指定，而是在对表，分区，索引或表空间使用<code class="codeph">ALTER</code>或<code class="codeph">CREATE</code>语句时指定。
                        </p>
                        <p>当表或索引设置了<code class="codeph">NOLOGGING</code> ，并行或串行直接路径<code class="codeph">INSERT</code>操作都不会生成重做日志。使用<code class="codeph">NOLOGGING</code>选项集运行的进程运行得更快，因为不会生成重做。但是，对表，分区或索引执行<code class="codeph">NOLOGGING</code>操作后，如果在执行备份之前发生介质故障，则所有已修改的表，分区和索引可能已损坏。
                        </p>
                        <p>如果使用<code class="codeph">NOLOGGING</code>子句，则直接路径<code class="codeph">INSERT</code>操作（字典更新除外）从不生成重做日志。<code class="codeph">NOLOGGING</code>属性不会影响撤消，只会影响重做。确切地说， <code class="codeph">NOLOGGING</code>允许直接路径<code class="codeph">INSERT</code>操作生成可忽略的重做量（范围无效重做，而不是完整图像重做）。
                        </p>
                        <p>为了向后兼容，仍然支持<code class="codeph">[UN]RECOVERABLE</code>作为<code class="codeph">CREATE</code> <code class="codeph">TABLE</code>语句的备用关键字。但是，在将来的版本中可能不支持此备用关键字。
                        </p>
                        <p>在表空间级别，logging子句指定在表空间中创建的所有表，索引和分区的缺省日志记录属性。当现有的表空间的日志记录属性由改变<code class="codeph">ALTER</code> <code class="codeph">TABLESPACE</code>语句，那么所有表，索引和后创建的分区<code class="codeph">ALTER</code>声明中有新的日志记录属性;现有的不会更改其日志记录属性。表空间级别日志记录属性可以由表，索引或分区级别的规范覆盖。
                        </p>
                        <p>默认日志记录属性是<code class="codeph">LOGGING</code> 。但是，如果您已将数据库置于<code class="codeph">NOARCHIVELOG</code>模式，通过发出<code class="codeph">ALTER</code> <code class="codeph">DATABASE</code> <code class="codeph">NOARCHIVELOG</code> ，则无论指定的日志记录属性如何，所有可以在不进行日志记录的情况下执行的操作都不会生成日志。
                        </p>
                     </div>
                     <!-- class="section" -->
                  </div>
               </div>
            </div><a id="VLDBG1537"></a><div class="props_rev_3"><a id="GUID-5A52793F-15AE-4C86-B8A4-4D7965575BB0" name="GUID-5A52793F-15AE-4C86-B8A4-4D7965575BB0"></a><h3 id="VLDBG-GUID-5A52793F-15AE-4C86-B8A4-4D7965575BB0" class="sect3">通过并行创建索引来优化性能</h3>
               <div>
                  <p>您可以通过并行创建索引来优化性能。</p>
                  <p>多个进程可以同时工作以创建索引。通过划分在多个服务器进程之间创建索引所需的工作，Oracle数据库可以比单个服务器进程串行创建索引更快地创建索引。</p>
                  <p>并行索引创建的工作方式与使用<code class="codeph">ORDER</code> <code class="codeph">BY</code>子句的表扫描的工作方式大致相同。该表是随机采样的，并且找到一组索引键，它们将索引等分为与DOP相同的块数。第一组查询过程扫描表，提取key-rowid对，并基于密钥将每对发送到第二组查询过程中的进程。第二组中的每个进程对键进行排序并以通常的方式构建索引。在构建所有索引片之后，并行执行协调器简单地连接片段（它们被排序）以形成最终索引。
                  </p>
                  <p>并行本地索引创建使用单个服务器集。为集合中的每个服务器进程分配一个要扫描的表分区，并为其构建索引分区。因为给定DOP使用了一半的服务器进程，所以可以使用更高的DOP运行并行本地索引创建。但是，DOP被限制为小于或等于要创建的索引分区的数量。要避免此限制，可以使用<code class="codeph">DBMS_PCLXUTIL</code>程序包。
                  </p>
                  <p>您可以选择指定在创建索引期间不应执行重做和撤消日志记录。这可以显着提高性能，但暂时使索引无法恢复。备份新索引后恢复可恢复性。如果您的应用程序可以容忍索引恢复需要重新创建的窗口，那么您应该考虑使用<code class="codeph">NOLOGGING</code>子句。
                  </p>
                  <p><code class="codeph">CREATE</code> <code class="codeph">INDEX</code>语句中的<code class="codeph">PARALLEL</code>子句是指定DOP以创建索引的唯一方法。如果未在<code class="codeph">CREATE</code> <code class="codeph">INDEX</code>语句的parallel子句中指定DOP，则将CPU数用作DOP。如果没有<code class="codeph">PARALLEL</code>子句，则连续完成索引创建。
                  </p>
                  <p>并行创建索引时， <code class="codeph">STORAGE</code>子句指的是查询服务器进程创建的每个子索引的存储。因此，在创建索引期间，使用<code class="codeph">INITIAL</code>值5 MB和DOP 12创建的索引将占用至少60 MB的存储空间，因为每个进程的启动范围为5 MB。当查询协调器进程组合已排序的子索引时，可能会修剪某些扩展区，并且生成的索引可能小于请求的60 MB。</p>
                  <p>在表上添加或启用<code class="codeph">UNIQUE</code>或<code class="codeph">PRIMARY</code> <code class="codeph">KEY</code>约束时，无法并行自动创建所需的索引。而是使用<code class="codeph">CREATE</code> <code class="codeph">INDEX</code>语句和适当的<code class="codeph">PARALLEL</code>子句手动在所需列上<code class="codeph">CREATE</code> <code class="codeph">INDEX</code> ，然后添加或启用约束。然后，Oracle Database在启用或添加约束时使用现有索引。
                  </p>
                  <p>如果所有约束都处于<code class="codeph">ENABLE</code> <code class="codeph">NOVALIDATE</code>状态，则可以同时并行地启用对同一表的多个约束。在以下示例中， <code class="codeph">ALTER</code> <code class="codeph">TABLE</code> <code class="codeph">ENABLE</code> <code class="codeph">CONSTRAINT</code>语句执行并行检查约束的表扫描：</p><pre class="oac_no_warn" dir="ltr">创建表a（a1 NUMBER CONSTRAINT ach CHECK（a1&gt; 0）ENABLE NOVALIDATE）PARALLEL;插入值（1）;承诺; ALTER TABLE a ENABLE CONSTRAINT ach;</pre></div>
            </div><a id="VLDBG1538"></a><div class="props_rev_3"><a id="GUID-08A08783-C243-4872-AFFA-56B603F1F0F5" name="GUID-08A08783-C243-4872-AFFA-56B603F1F0F5"></a><h3 id="VLDBG-GUID-08A08783-C243-4872-AFFA-56B603F1F0F5" class="sect3">并行DML技巧</h3>
               <div>
                  <p>本主题介绍了并行DML功能的提示。</p>
                  <p>涵盖的主题包括：</p>
                  <ul style="list-style-type:disc">
                     <li>
                        <p><a href="parallel-exec-tips.html#GUID-2B327BD6-3191-493A-AE5B-EB08325A664C" title="本主题中讨论了使用SQL INSERT语句时的并行DML。">并行DML技巧1：INSERT</a></p>
                     </li>
                     <li>
                        <p><a href="parallel-exec-tips.html#GUID-7E8095F3-9650-405C-B158-B5B4932093C5" title="本主题讨论了使用Direct-Path INSERT操作时的并行DML。">并行DML技巧2：直接路径INSERT</a></p>
                     </li>
                     <li>
                        <p><a href="parallel-exec-tips.html#GUID-2627DC19-7EBE-4C45-A758-711BDB5E37EC" title="本主题中讨论了使用插入，合并，更新和删除操作时的并行DML。">并行DML技巧3：并行化INSERT，MERGE，UPDATE和DELETE</a></p>
                     </li>
                  </ul>
                  <div class="infoboxnotealso" id="GUID-08A08783-C243-4872-AFFA-56B603F1F0F5__GUID-8816EC5E-1A97-402F-93F4-0C11DB254A02">
                     <p class="notep1">也可以看看：</p>
                     <p></p>
                     <ul style="list-style-type:disc">
                        <li>
                           <p><a href="../admin/managing-tables.html#ADMIN01509" target="_blank"><span><cite>“Oracle数据库管理员指南”</cite></span></a> ，了解有关使用直接路径插入提高负载性能的信息</p>
                        </li>
                        <li>
                           <p>有关<code class="codeph">INSERT</code>语句的信息，请<a href="https://www.oracle.com/pls/topic/lookup?ctx=en/database/oracle/oracle-database/19/vldbg&amp;id=SQLRF01604" target="_blank"><span><cite>参见Oracle数据库SQL语言参考</cite></span></a></p>
                        </li>
                     </ul>
                  </div>
               </div><a id="VLDBG1540"></a><a id="VLDBG1539"></a><div class="props_rev_3"><a id="GUID-2B327BD6-3191-493A-AE5B-EB08325A664C" name="GUID-2B327BD6-3191-493A-AE5B-EB08325A664C"></a><h4 id="VLDBG-GUID-2B327BD6-3191-493A-AE5B-EB08325A664C" class="sect4">并行DML技巧1：INSERT</h4>
                  <div>
                     <p>本主题中讨论了使用SQL <code class="codeph">INSERT</code>语句时的并行DML。
                     </p>
                     <p>使用<code class="codeph">INSERT</code>语句可用的功能可以总结如<a href="parallel-exec-tips.html#GUID-2B327BD6-3191-493A-AE5B-EB08325A664C__BEIIHGDC" title="INSERT功能摘要">表8-5</a>所示：</p>
                     <div class="tblformalwide" id="GUID-2B327BD6-3191-493A-AE5B-EB08325A664C__BEIIHGDC">
                        <p class="titleintable">表8-5 INSERT功能摘要</p>
                        <table cellpadding="4" cellspacing="0" class="FormalWide" title="INSERT功能摘要" width="100%" border="1" summary="Summary of INSERT Features" frame="hsides" rules="rows">
                           <thead>
                              <tr align="left" valign="top">
                                 <th align="left" valign="bottom" width="16%" id="d63248e1938">插入类型</th>
                                 <th align="left" valign="bottom" width="43%" id="d63248e1941">平行</th>
                                 <th align="left" valign="bottom" width="18%" id="d63248e1944">串行</th>
                                 <th align="left" valign="bottom" width="23%" id="d63248e1947">NOLOGGING</th>
                              </tr>
                           </thead>
                           <tbody>
                              <tr align="left" valign="top">
                                 <td align="left" valign="top" width="16%" id="d63248e1952" headers="d63248e1938 ">
                                    <p>常规</p>
                                 </td>
                                 <td align="left" valign="top" width="43%" headers="d63248e1952 d63248e1941 ">
                                    <p>没有</p>
                                    <p>有关使用<code class="codeph">NOAPPEND</code>提示并启用并行DML以执行并行常规插入的信息，请参阅本节中的文本。
                                    </p>
                                 </td>
                                 <td align="left" valign="top" width="18%" headers="d63248e1952 d63248e1944 ">
                                    <p>是</p>
                                 </td>
                                 <td align="left" valign="top" width="23%" headers="d63248e1952 d63248e1947 ">
                                    <p>没有</p>
                                 </td>
                              </tr>
                              <tr align="left" valign="top">
                                 <td align="left" valign="top" width="16%" id="d63248e1970" headers="d63248e1938 ">
                                    <p>直接路径</p>
                                    <p><code class="codeph">插入</code></p>
                                    <p>（ <code class="codeph">APPEND</code> ）</p>
                                 </td>
                                 <td align="left" valign="top" width="43%" headers="d63248e1970 d63248e1941 ">
                                    <p>是的，但要求</p>
                                    <p><code class="codeph">ALTER</code> <code class="codeph">SESSION</code> <code class="codeph">ENABLE</code> <code class="codeph">PARALLEL</code> <code class="codeph">DML</code>或<code class="codeph">ENABLE_PARALLEL_DML</code> SQL提示启用<code class="codeph">PARALLEL</code> <code class="codeph">DML</code>模式</p>
                                    <p>以及以下之一：</p>
                                    <ul style="list-style-type:disc">
                                       <li>
                                          <p>表<code class="codeph">PARALLEL</code>属性或<code class="codeph">PARALLEL</code>提示以显式设置并行性</p>
                                       </li>
                                       <li>
                                          <p><code class="codeph">APPEND</code>提示明确设置模式</p>
                                       </li>
                                    </ul>
                                    <p>或者以下</p>
                                    <p><code class="codeph">ALTER</code> <code class="codeph">SESSION</code> <code class="codeph">FORCE</code> <code class="codeph">PARALLEL</code> <code class="codeph">DML</code>强制<code class="codeph">PARALLEL</code> <code class="codeph">DML</code>模式</p>
                                 </td>
                                 <td align="left" valign="top" width="18%" headers="d63248e1970 d63248e1944 ">
                                    <p>是的，但需要：</p>
                                    <p><code class="codeph">APPEND</code>提示</p>
                                 </td>
                                 <td align="left" valign="top" width="23%" headers="d63248e1970 d63248e1947 ">
                                    <p>是的，但需要：</p>
                                    <p>为分区或表设置的<code class="codeph">NOLOGGING</code>属性</p>
                                 </td>
                              </tr>
                           </tbody>
                        </table>
                     </div>
                     <!-- class="inftblhruleinformal" -->
                     <p>如果启用了并行DML并且为数据字典中的表设置了<code class="codeph">PARALLEL</code>提示或<code class="codeph">PARALLEL</code>属性，则插入操作是并行和附加的，除非适用限制。如果缺少<code class="codeph">PARALLEL</code>提示或<code class="codeph">PARALLEL</code>属性，则会以串行方式执行插入操作。当且仅当并行DML被启用或强制时，自动DOP才会并行化SQL语句的DML部分。
                     </p>
                     <p>如果启用了并行DML，则可以使用<code class="codeph">NOAPPEND</code>提示执行并行传统插入操作。例如，您可以使用<code class="codeph">/*+</code> <code class="codeph">noappend</code> <code class="codeph">parallel</code> <code class="codeph">*/</code>与SQL <code class="codeph">INSERT</code>语句来执行并行传统插入。
                     </p><pre class="oac_no_warn" dir="ltr">SQL&gt; INSERT / * + NOAPPEND PARALLEL * / INTO sales_hist SELECT * FROM sales;</pre><p>并行传统插入操作的优点是能够执行在线操作而不受直接路径<code class="codeph">INSERT</code>的限制。并行传统插入操作的缺点是该过程可能比直接路径<code class="codeph">INSERT</code>慢。</p>
                  </div>
               </div><a id="VLDBG1541"></a><div class="props_rev_3"><a id="GUID-7E8095F3-9650-405C-B158-B5B4932093C5" name="GUID-7E8095F3-9650-405C-B158-B5B4932093C5"></a><h4 id="VLDBG-GUID-7E8095F3-9650-405C-B158-B5B4932093C5" class="sect4">并行DML技巧2：直接路径INSERT</h4>
                  <div>
                     <p>本主题讨论了使用Direct-Path <code class="codeph">INSERT</code>操作时的并行DML。
                     </p>
                     <p>追加模式是并行插入操作期间的默认模式。数据始终插入到新块中，该块分配给表。使用<code class="codeph">APPEND</code>提示是可选的。您应该使用追加模式来提高<code class="codeph">INSERT</code>操作的速度，但不能在必须优化空间利用率时使用。您可以使用<code class="codeph">NOAPPEND</code>覆盖追加模式。
                     </p>
                     <p><code class="codeph">APPEND</code>提示适用于串行和并行插入操作。如果使用此提示，串行插入也会更快。但是， <code class="codeph">APPEND</code>提示确实需要更多空间和锁定开销。
                     </p>
                     <p>您可以使用带有<code class="codeph">APPEND</code> <code class="codeph">NOLOGGING</code>来使流程更快。<code class="codeph">NOLOGGING</code>表示不为操作生成重做日志。<code class="codeph">NOLOGGING</code>永远不是默认的;当您想要优化性能时使用它。当表或分区需要恢复时，通常不应使用它。如果需要恢复，请确保在操作后立即执行备份。使用<code class="codeph">ALTER</code> <code class="codeph">TABLE</code> <code class="codeph">[NO]LOGGING</code>语句设置适当的值。
                     </p>
                  </div>
               </div><a id="VLDBG1542"></a><div class="props_rev_3"><a id="GUID-2627DC19-7EBE-4C45-A758-711BDB5E37EC" name="GUID-2627DC19-7EBE-4C45-A758-711BDB5E37EC"></a><h4 id="VLDBG-GUID-2627DC19-7EBE-4C45-A758-711BDB5E37EC" class="sect4">并行DML技巧3：并行化INSERT，MERGE，UPDATE和DELETE</h4>
                  <div>
                     <p>本主题中讨论了使用插入，合并，更新和删除操作时的并行DML。</p>
                     <p>当表或分区在数据字典中具有<code class="codeph">PARALLEL</code>属性时，该属性设置用于确定<code class="codeph">INSERT</code> ， <code class="codeph">UPDATE</code>和<code class="codeph">DELETE</code>语句和查询的并行性。语句中表的显式<code class="codeph">PARALLEL</code>提示会覆盖数据字典中<code class="codeph">PARALLEL</code>属性的效果。
                     </p>
                     <p>您可以使用<code class="codeph">NO_PARALLEL</code>提示覆盖数据字典中表的<code class="codeph">PARALLEL</code>属性。通常，提示优先于属性。
                     </p>
                     <p>如果在<code class="codeph">PARALLEL</code> <code class="codeph">DML</code>模式下使用<code class="codeph">ALTER</code> <code class="codeph">SESSION</code> <code class="codeph">ENABLE</code> <code class="codeph">PARALLEL</code> <code class="codeph">DML</code>语句<code class="codeph">ENABLE</code>了<code class="codeph">SESSION</code>或者在<code class="codeph">PARALLEL</code> <code class="codeph">DML</code>模式下使用<code class="codeph">ENABLE_PARALLEL_DML</code>提示启用了特定的SQL语句，则会考虑DML操作进行并行化。该模式不会影响查询或DML语句的查询部分的并行化。
                     </p>
                  </div><a id="VLDBG1544"></a><a id="VLDBG1543"></a><div class="props_rev_3"><a id="GUID-A4227A4C-209A-40B9-9A68-A57803E66C04" name="GUID-A4227A4C-209A-40B9-9A68-A57803E66C04"></a><h5 id="VLDBG-GUID-A4227A4C-209A-40B9-9A68-A57803E66C04" class="sect5">并行化INSERT SELECT</h5>
                     <div>
                        <p>在<code class="codeph">INSERT</code> ......<code class="codeph">SELECT</code>语句，除了<code class="codeph">SELECT</code>关键字之后的提示外，还可以在<code class="codeph">INSERT</code>关键字后指定<code class="codeph">PARALLEL</code>提示。
                        </p>
                        <div class="section">
                           <p><code class="codeph">INSERT</code>关键字后的<code class="codeph">PARALLEL</code>提示仅适用于<code class="codeph">INSERT</code>操作， <code class="codeph">SELECT</code>关键字后的<code class="codeph">PARALLEL</code>提示仅适用于<code class="codeph">SELECT</code>操作。因此， <code class="codeph">INSERT</code>和<code class="codeph">SELECT</code>操作的并行性彼此独立。如果一个操作不能并行执行，则对其他操作是否可以并行执行没有影响。
                           </p>
                           <p>如果用户明确为并行DML启用了会话，并且所讨论的表在数据字典条目中设置了<code class="codeph">PARALLEL</code>属性，则并行化插入操作的能力会导致现有行为发生更改。在这种情况下，具有并行化的select操作的现有<code class="codeph">INSERT</code> <code class="codeph">SELECT</code>语句也可以使其insert操作并行化。
                           </p>
                           <p>如果查询多个表，则可以指定多个<code class="codeph">SELECT</code> <code class="codeph">PARALLEL</code>提示和多个<code class="codeph">PARALLEL</code>属性。
                           </p>
                           <p><a href="parallel-exec-tips.html#GUID-A4227A4C-209A-40B9-9A68-A57803E66C04__BEIIGDGI">例8-5</a>显示了在收购<code class="codeph">ACME</code>之后聘用的新员工的增加。</p>
                        </div>
                        <!-- class="section" -->
                        <div class="example" id="GUID-A4227A4C-209A-40B9-9A68-A57803E66C04__BEIIGDGI">
                           <p class="titleinexample">示例8-5并行化INSERT SELECT</p><pre class="oac_no_warn" dir="ltr">INSERT / * + PARALLEL（员工）* / INTO员工SELECT / * + PARALLEL（ACME_EMP）* / *来自ACME_EMP;</pre><p>此示例中不需要<code class="codeph">APPEND</code>关键字，因为它由<code class="codeph">PARALLEL</code>提示隐含。
                           </p>
                        </div>
                        <!-- class="example" -->
                     </div>
                  </div><a id="VLDBG1546"></a><a id="VLDBG1547"></a><a id="VLDBG1545"></a><div class="props_rev_3"><a id="GUID-49D5134E-7A04-4B87-A338-C4007D09D712" name="GUID-49D5134E-7A04-4B87-A338-C4007D09D712"></a><h5 id="VLDBG-GUID-49D5134E-7A04-4B87-A338-C4007D09D712" class="sect5">并行化UPDATE和DELETE</h5>
                     <div>
                        <p><code class="codeph">PARALLEL</code>提示（紧跟在<code class="codeph">UPDATE</code>或<code class="codeph">DELETE</code>关键字之后）不仅适用于基础扫描操作，还适用于<code class="codeph">UPDATE</code>或<code class="codeph">DELETE</code>操作。
                        </p>
                        <div class="section">
                           <p>或者，您可以在要修改的表的定义中指定的<code class="codeph">PARALLEL</code>子句中指定<code class="codeph">UPDATE</code>或<code class="codeph">DELETE</code>并行度。
                           </p>
                           <p>如果已为会话或事务显式启用了并行DML，那么将其查询操作并行化的<code class="codeph">UPDATE</code>或<code class="codeph">DELETE</code>语句也可以并行化其<code class="codeph">UPDATE</code>或<code class="codeph">DELETE</code>操作。语句中的任何子查询或可更新视图都可以有自己独立的<code class="codeph">PARALLEL</code>提示或子句，但这些并行指令不会影响并行化更新或删除的决定。如果这些操作不能并行执行，则不会影响是否可以并行执行<code class="codeph">UPDATE</code>或<code class="codeph">DELETE</code>部分。
                           </p>
                           <p><a href="parallel-exec-tips.html#GUID-49D5134E-7A04-4B87-A338-C4007D09D712__BEIGDEHC">例8-6</a>显示了更新操作，为达拉斯的所有职员提供10％的加薪。
                           </p>
                        </div>
                        <!-- class="section" -->
                        <div class="example" id="GUID-49D5134E-7A04-4B87-A338-C4007D09D712__BEIGDEHC">
                           <p class="titleinexample">例8-6并行化UPDATE和DELETE</p><pre class="oac_no_warn" dir="ltr">UPDATE / * + PARALLEL（员工）* /员工SET薪水=薪水* 1.1 WHERE job_id ='CLERK'和department_id IN（SELECT department_id FROM DEPARTMENTS WHERE location_id ='DALLAS'）;</pre><p><code class="codeph">PARALLEL</code>提示应用于<code class="codeph">UPDATE</code>操作和扫描。
                           </p>
                           <p><a href="parallel-exec-tips.html#GUID-49D5134E-7A04-4B87-A338-C4007D09D712__BEIJIGHJ">例8-7</a>显示了<code class="codeph">39</code>类所有产品的删除，因为该业务线最近被分拆成一个单独的公司。
                           </p>
                        </div>
                        <!-- class="example" -->
                        <div class="example" id="GUID-49D5134E-7A04-4B87-A338-C4007D09D712__BEIJIGHJ">
                           <p class="titleinexample">例8-7并行化UPDATE和DELETE</p><pre class="oac_no_warn" dir="ltr">DELETE / * + PARALLEL（PRODUCTS）* / FROM PRODUCTS where category_id = 39;</pre><p>同样，并行性应用于表<code class="codeph">employees</code>的扫描和<code class="codeph">UPDATE</code>操作。
                           </p>
                        </div>
                        <!-- class="example" -->
                     </div>
                  </div>
               </div>
            </div><a id="VLDBG1548"></a><div class="props_rev_3"><a id="GUID-35FF4DC9-F6FC-4634-832B-55ABBA531434" name="GUID-35FF4DC9-F6FC-4634-832B-55ABBA531434"></a><h3 id="VLDBG-GUID-35FF4DC9-F6FC-4634-832B-55ABBA531434" class="sect3">并行增量数据加载</h3>
               <div>
                  <p>并行DML与可更新的连接视图工具相结合，为刷新数据仓库系统的表提供了有效的解决方案。</p>
                  <p>刷新表是使用从OLTP生产系统生成的差异数据更新它们。</p>
                  <p>在以下示例中，假设刷新名为<code class="codeph">customers</code>的表，该表具有列<code class="codeph">c_key</code> ， <code class="codeph">c_name</code>和<code class="codeph">c_addr</code> 。差异数据包含自上次刷新数据仓库以来已更新的新行或行。在此示例中，更新的数据通过ASCII文件从生产系统发送到数据仓库系统。在开始刷新过程之前，必须将这些文件加载到名为<code class="codeph">diff_customer</code>的临时表中。您可以将SQL * Loader与并行和直接选项一起使用，以有效地执行此任务。您也可以在并行加载时使用<code class="codeph">APPEND</code>提示。
                  </p>
                  <p>加载<code class="codeph">diff_customer</code>后，可以启动刷新过程。它可以分两个阶段执行，也可以并行合并，如下所示：</p>
                  <ul style="list-style-type:disc">
                     <li>
                        <p><a href="parallel-exec-tips.html#GUID-E2B7261E-1DC4-4029-A018-B1B8C509FD84" title="本主题讨论如何优化并行更新表的性能。">优化并行更新表的性能</a></p>
                     </li>
                     <li>
                        <p><a href="parallel-exec-tips.html#GUID-D1AFE9E1-D98C-4A5C-AE3E-75C9ADFE60D4" title="本主题讨论如何有效地将新行并行插入表中。">有效地将新行并行插入表中</a></p>
                     </li>
                     <li>
                        <p><a href="parallel-exec-tips.html#GUID-7F00E66F-A941-4299-8D61-36AE5D9CC846" title="本主题讨论了如何通过并行合并来优化性能。">并行合并优化性能</a></p>
                     </li>
                  </ul>
               </div><a id="VLDBG1549"></a><div class="props_rev_3"><a id="GUID-E2B7261E-1DC4-4029-A018-B1B8C509FD84" name="GUID-E2B7261E-1DC4-4029-A018-B1B8C509FD84"></a><h4 id="VLDBG-GUID-E2B7261E-1DC4-4029-A018-B1B8C509FD84" class="sect4">优化并行更新表的性能</h4>
                  <div>
                     <p>本主题讨论如何优化并行更新表的性能。</p>
                     <p>以下语句是使用子查询的更新的简单SQL实现：</p><pre class="oac_no_warn" dir="ltr">UPDATE客户SET（c_name，c_addr）=（SELECT c_name，c_addr FROM diff_customer WHERE diff_customer.c_key = customer.c_key）WHERE c_key IN（SELECT c_key FROM diff_customer）;</pre><p>不幸的是，此语句中的两个子查询会影响性能。</p>
                     <p>另一种方法是使用可更新的连接视图重写此查询。要重写查询，必须首先向<code class="codeph">diff_customer</code>表添加主键约束，以确保修改后的列映射到密钥保留表：</p><pre class="oac_no_warn" dir="ltr">CREATE UNIQUE INDEX diff_pkey_ind ON diff_customer（c_key）PARALLEL NOLOGGING; ALTER TABLE diff_customer ADD PRIMARY KEY（c_key）;</pre><p>然后，您可以使用以下SQL语句更新<code class="codeph">customers</code>表：</p><pre class="oac_no_warn" dir="ltr">UPDATE / * + PARALLEL（cust_joinview）* /（SELECT / * + PARALLEL（customers）PARALLEL（diff_customer）* / CUSTOMER.c_name AS c_name CUSTOMER.c_addr AS c_addr，diff_customer.c_name AS c_newname，diff_customer.c_addr AS c_newaddr FROM diff_customer WHERE customers.c_key = diff_customer.c_key）cust_joinview SET c_name = c_newname，c_addr = c_newaddr;</pre><p>为连接视图<code class="codeph">cust_joinview</code>提供的基础扫描是并行完成的。然后，您可以并行化更新以进一步提高性能，但前提是<code class="codeph">customers</code>表已分区。
                     </p>
                  </div>
               </div><a id="VLDBG1550"></a><div class="props_rev_3"><a id="GUID-D1AFE9E1-D98C-4A5C-AE3E-75C9ADFE60D4" name="GUID-D1AFE9E1-D98C-4A5C-AE3E-75C9ADFE60D4"></a><h4 id="VLDBG-GUID-D1AFE9E1-D98C-4A5C-AE3E-75C9ADFE60D4" class="sect4">有效地将新行并行插入表中</h4>
                  <div>
                     <p>本主题讨论如何有效地将新行并行插入表中。</p>
                     <p>刷新过程的最后一个阶段包括将<code class="codeph">diff_customer</code>临时表中的新行插入到<code class="codeph">customers</code>表中。与更新案例不同，您无法避免在<code class="codeph">INSERT</code>语句中使用子查询：</p><pre class="oac_no_warn" dir="ltr">INSERT / * + PARALLEL（客户）* / INTO客户SELECT * FROM diff_customer s）;</pre><p>但是，您可以使用<code class="codeph">HASH_AJ</code>提示保证子查询转换为反散列连接。这样做使您可以使用并行<code class="codeph">INSERT</code>地执行前面的语句。即使表未分区，并行<code class="codeph">INSERT</code>也适用。
                     </p>
                  </div>
               </div><a id="VLDBG1551"></a><div class="props_rev_3"><a id="GUID-7F00E66F-A941-4299-8D61-36AE5D9CC846" name="GUID-7F00E66F-A941-4299-8D61-36AE5D9CC846"></a><h4 id="VLDBG-GUID-7F00E66F-A941-4299-8D61-36AE5D9CC846" class="sect4">并行合并优化性能</h4>
                  <div>
                     <p>本主题讨论了如何通过并行合并来优化性能。</p>
                     <p>您可以将更新和插入操作组合到一个语句中，通常称为<span class="bold">合并</span> ，如以下示例所示。
                     </p><pre class="oac_no_warn" dir="ltr">MERGE INTO客户使用diff_customer ON（diff_customer.c_key = customer.c_key）匹配然后更新设置（c_name，c_addr）=（SELECT c_name，c_addr FROM diff_customer WHERE diff_customer.c_key = customers.c_key）当不匹配时插入值（diff_customer） .c_key，diff_customer.c_data）;</pre><p>上一个示例中的SQL语句实现了与<a href="parallel-exec-tips.html#GUID-E2B7261E-1DC4-4029-A018-B1B8C509FD84" title="How to optimize performance for updating a table in parallel is discussed in this topic.">优化并行更新表</a>并<a href="parallel-exec-tips.html#GUID-D1AFE9E1-D98C-4A5C-AE3E-75C9ADFE60D4" title="How to efficiently insert new rows into a table in parallel is discussed in this topic.">高效地将新行</a> <a href="parallel-exec-tips.html#GUID-E2B7261E-1DC4-4029-A018-B1B8C509FD84" title="How to optimize performance for updating a table in parallel is discussed in this topic.">并行</a> <a href="parallel-exec-tips.html#GUID-D1AFE9E1-D98C-4A5C-AE3E-75C9ADFE60D4" title="本主题讨论如何有效地将新行并行插入表中。">插入</a> <a href="parallel-exec-tips.html#GUID-E2B7261E-1DC4-4029-A018-B1B8C509FD84" title="本主题讨论如何优化并行更新表的性能。">表中的性能中的</a>所有语句相同的结果。
                     </p>
                  </div>
               </div>
            </div>
         </div>
      </article>
   </body>
</html>