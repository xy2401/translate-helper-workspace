<html lang="en-us" dir="ltr" xml:lang="en-us">
   <head>
      <meta http-equiv="Content-Type" content="text/html; charset=utf-8"></meta>
      <meta name="viewport" content="width=device-width, initial-scale=1"></meta>
      <meta http-equiv="X-UA-Compatible" content="IE=edge"></meta>
      <meta name="abstract" content="This chapter explains how Oracle Database maintains consistent data in a multiuser database environment."></meta>
      <meta name="description" content="This chapter explains how Oracle Database maintains consistent data in a multiuser database environment."></meta>
      <title>数据并发性和一致性</title>
      <meta property="og:site_name" content="Oracle Help Center"></meta>
      <meta property="og:title" content="Database Concepts"></meta>
      <meta property="og:description" content="This chapter explains how Oracle Database maintains consistent data in a multiuser database environment."></meta>
      <link rel="stylesheet" href="/sp_common/book-template/ohc-book-template/css/book.css"></link>
      <link rel="shortcut icon" href="/sp_common/book-template/ohc-common/img/favicon.ico"></link>
      <meta name="application-name" content="Database Concepts"></meta>
      <meta name="generator" content="DITA Open Toolkit version 1.8.5 (Mode = doc)"></meta>
      <meta name="plugin" content="SP_docbuilder HTML plugin release 18.2.2"></meta>
      <link rel="alternate" href="database-concepts.pdf" title="PDF File" type="application/pdf"></link>
      <meta name="robots" content="all"></meta>
      <link rel="schema.dcterms" href="http://purl.org/dc/terms/"></link>
      <meta name="dcterms.created" content="2019-01-09T07:47:16-08:00"></meta>
      <meta name="dcterms.title" content="Database Concepts"></meta>
      <meta name="dcterms.dateCopyrighted" content="1993, 2019"></meta>
      <meta name="dcterms.category" content="database"></meta>
      <meta name="dcterms.identifier" content="E96138-01"></meta>
      
      <meta name="dcterms.product" content="en/database/oracle/oracle-database/19"></meta>
      
      <link rel="prev" href="oracle-transaction-management.html" title="Previous" type="text/html"></link>
      <link rel="next" href="transactions.html" title="Next" type="text/html"></link>
      <script>
        document.write('<style type="text/css">');
        document.write('body > .noscript, body > .noscript ~ * { visibility: hidden; }');
        document.write('</style>');
     </script>
      <script src="/sp_common/book-template/requirejs/require.js" data-main="/sp_common/book-template/ohc-book-template/js/book-config"></script>
      <script>
            if (window.require === undefined) {
                document.write('<script data-main="sp_common/book-template/ohc-book-template/js/book-config" src="sp_common/book-template/requirejs/require.js"><\/script>');
                document.write('<link href="sp_common/book-template/ohc-book-template/css/book.css" rel="stylesheet"/>');
            }
        </script>
      <script type="application/json" id="ssot-metadata">{"primary":{"category":{"short_name":"database","element_name":"Database","display_in_url":true},"suite":{"short_name":"oracle","element_name":"Oracle","display_in_url":true},"product_group":{"short_name":"not-applicable","element_name":"Not applicable","display_in_url":false},"product":{"short_name":"oracle-database","element_name":"Oracle Database","display_in_url":true},"release":{"short_name":"19","element_name":"Release 19","display_in_url":true}}}</script>
      
    <meta name="dcterms.isVersionOf" content="CNCPT"></meta>
    <meta name="dcterms.release" content="Release 19"></meta>
  </head>
   <body dir="ltr">
      <div class="noscript alert alert-danger text-center" role="alert">
         <a href="oracle-transaction-management.html" class="pull-left"><span class="glyphicon glyphicon-chevron-left" aria-hidden="true"></span>上一页</a> <a href="transactions.html" class="pull-right">下一页<span class="glyphicon glyphicon-chevron-right" aria-hidden="true"></span></a> <span class="fa fa-exclamation-triangle" aria-hidden="true"></span>必须启用JavaScript才能正确显示此内容</div>
      <article>
         <header>
            <ol class="breadcrumb" vocab="http://schema.org/" typeof="BreadcrumbList">
               <li property="itemListElement" typeof="ListItem"><a href="index.html" property="item" typeof="WebPage"><span property="name">数据库概念</span></a></li>
               <li property="itemListElement" typeof="ListItem"><a href="oracle-transaction-management.html" property="item" typeof="WebPage"><span property="name">Oracle事务管理</span></a></li>
               <li class="active" property="itemListElement" typeof="ListItem">数据并发性和一致性</li>
            </ol>
            <a id="GUID-E8CBA9C5-58E3-460F-A82A-850E0152E95C" name="GUID-E8CBA9C5-58E3-460F-A82A-850E0152E95C"></a><a id="CNCPT020"></a>
            
            <h2 id="CNCPT-GUID-E8CBA9C5-58E3-460F-A82A-850E0152E95C" class="sect2"><span class="enumeration_chapter">9</span>数据并发和一致性</h2>
         </header>
         <div class="ind"><script type="text/javascript">window.name='data-concurrency-and-consistency'</script><script type="text/javascript">
    function footdisplay(footnum,footnote) {
    var msg = window.open('about:blank', 'NewWindow' + footnum,
        'directories=no,height=100,location=no,menubar=no,resizable=yes,' +
        'scrollbars=yes,status=no,toolbar=no,width=598');
    msg.document.open('text/html');
    msg.document.write('<!DOCTYPE html ');
    msg.document.write('PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" ');
    msg.document.write('"http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">'); 
    msg.document.write('<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en-us" lang="en-us" dir="ltr"><head><title>');
   
    msg.document.write('Footnote&nbsp; ' + footnum);
    msg.document.write('<\/title><meta http-equiv="Content-Type" ');
    msg.document.write('content="text/html; charset=utf-8" />');
    msg.document.write('<meta http-equiv="Content-Script-Type" ');
    msg.document.write('content="text/javascript" />');
    msg.document.write('<style type="text/css"> <![CDATA[ ');
    msg.document.write('h1 {text-align: center; font-size: 14pt;}');
    msg.document.write('fieldset {border: none;}');
    msg.document.write('form {text-align: center;}');
    msg.document.write(' ]]u003e </style>');
    msg.document.write('<\/head><body><div id="footnote"><h1>Footnote&nbsp; ' + footnum + '<\/h1><p>');
    msg.document.write(footnote);
    msg.document.write('<\/p><form action="" method="post"><fieldset>');
    msg.document.write('<input type="button" value="OK" ');
    msg.document.write('onclick="window.close();" />');
    msg.document.write('<\/fieldset><\/form><\/div><\/body><\/html>');
    msg.document.close();
    setTimeout(function() {
        var height = msg.document.getElementById('footnote').offsetHeight;
        msg.resizeTo(598, height + 100);
    }
    , 100);
    msg.focus();
}
            </script><noscript>
               <p>此页面上的脚本内容仅用于导航目的，不会以任何方式更改内容。</p>
            </noscript>
            <div>
               <p>本章介绍Oracle数据库如何在多用户数据库环境中维护一致的数据。</p>
               <p>本章包含以下部分：</p>
               <ul style="list-style-type:disc">
                  <li>
                     <p><a href="data-concurrency-and-consistency.html#GUID-7AD41DFA-04E5-4738-B744-C4407170411C" title="在单用户数据库中，用户可以修改数据，而无需考虑同时修改相同数据的其他用户。但是，在多用户数据库中，多个并发事务中的语句可能会更新相同的数据。同时执行的事务必须产生有意义且一致的结果">数据并发和一致性简介</a></p>
                  </li>
                  <li>
                     <p><a href="data-concurrency-and-consistency.html#GUID-2A0FDFF0-5F72-4476-BFD2-060A20EA1685" title="事务隔离级别的ANSI标准是根据每个隔离级别允许或阻止的现象来定义的。">Oracle数据库事务隔离级别概述</a></p>
                  </li>
                  <li>
                     <p><a href="data-concurrency-and-consistency.html#GUID-AD0CEE83-2F33-4906-94E1-3D1022924C63" title="锁是一种防止破坏性交互的机制。">Oracle数据库锁定机制概述</a></p>
                  </li>
                  <li>
                     <p><a href="data-concurrency-and-consistency.html#GUID-E926E638-0161-4389-887B-4A31A529478A" title="Oracle数据库代表事务自动锁定资源，以防止其他事务执行需要独占访问同一资源的事务。">自动锁概述</a></p>
                  </li>
                  <li>
                     <p><a href="data-concurrency-and-consistency.html#GUID-A4E54CD6-7232-489D-86A4-412EAF8A8DB7" title="您可以手动覆盖Oracle数据库的默认锁定机制。">手动数据锁概述</a></p>
                  </li>
                  <li>
                     <p><a href="data-concurrency-and-consistency.html#GUID-D63FD030-44CD-4FD7-970A-C98C8CC4AC42" title="使用Oracle数据库锁管理服务，您可以为特定应用程序定义自己的锁。">用户定义的锁概述</a></p>
                  </li>
               </ul>
            </div><a id="CNCPT121"></a><div class="props_rev_3"><a id="GUID-7AD41DFA-04E5-4738-B744-C4407170411C" name="GUID-7AD41DFA-04E5-4738-B744-C4407170411C"></a><h3 id="CNCPT-GUID-7AD41DFA-04E5-4738-B744-C4407170411C" class="sect3">数据并发和一致性简介</h3>
               <div>
                  <p>在单用户数据库中，用户可以修改数据，而无需考虑同时修改相同数据的其他用户。但是，在多用户数据库中，多个并发事务中的语句可能会更新相同的数据。同时执行的事务必须产生有意义且一致的结果</p>
                  <p>多用户数据库必须提供以下内容：</p>
                  <ul style="list-style-type:disc">
                     <li>
                        <p>确保用户可以同时访问数据（ <a href="glossary.html#GUID-D7E696DB-944C-4798-B70D-5C2381FE971F"><span class="xrefglossterm">数据并发</span></a> ）</p>
                     </li>
                     <li>
                        <p>确保每个用户看到一致的数据视图（ <a href="glossary.html#GUID-B016467E-5663-4AC8-B54D-181CA1B8198E"><span class="xrefglossterm">数据一致性</span></a> ），包括用户自己的事务和其他用户的已提交事务所做的可见更改</p>
                     </li>
                  </ul>
                  <p>为了描述事务并发运行时的一致事务行为，数据库研究人员定义了一个称为可<a href="glossary.html#GUID-41BC7551-23D4-4778-8109-B886FBFC85EE"><span class="xrefglossterm">序列化</span></a>的事务隔离模型。可序列化事务在一个环境中运行，使其看起来好像没有其他用户在修改数据库中的数据。
                  </p>
                  <p>虽然通常需要事务之间的这种程度的隔离，但是以可序列化模式运行许多应用程序会严重损害应用程序吞吐量并发运行事务的完全隔离可能意味着一个事务无法执行插入另一个事务查询的表。简而言之，现实世界的考虑通常需要在完美的事务隔离和性能之间进行折衷。</p>
                  <p>Oracle数据库通过使用<a href="glossary.html#GUID-FCCF7DC5-C860-4F1C-8811-03AE76597104"><span class="xrefglossterm">多版本一致性模型</span></a>和各种类型的锁和事务来维护数据一致性。通过这种方式，数据库可以向多个并发用户呈现数据视图，每个视图与某个时间点保持一致。由于不同版本的数据块可以同时存在，因此事务可以读取在<a href="glossary.html#GUID-CCF91C9F-A98A-498F-A84B-58A0FA16CD6E"><span class="xrefglossterm">查询</span></a>所需的时间点提交的数据版本，并返回与单个时间点一致的结果。
                  </p>
                  <div class="infoboxnotealso" id="GUID-7AD41DFA-04E5-4738-B744-C4407170411C__GUID-04EA95D3-71F5-46E0-986D-DBCE9CA4E0C3">
                     <p class="notep1">也可以看看：</p>
                     <p><span class="q">“ <a href="data-integrity.html#GUID-6A89FF39-AD42-4399-BD1B-E51ECEE50B4E" title="本章介绍完整性约束如何实施与数据库关联的业务规则，并防止将无效信息输入表中。">数据完整性</a> ”</span>和<span class="q">“ <a href="transactions.html#GUID-B97790CB-DF82-442D-B9D5-50CCE6BF9FBD" title="本章定义了一个事务，并描述了数据库如何处理事务。">交易</a> ”</span></p>
                  </div>
               </div><a id="CNCPT221"></a><div class="props_rev_3"><a id="GUID-4BD4DFD6-DAEA-41B2-BB56-7135568F0548" name="GUID-4BD4DFD6-DAEA-41B2-BB56-7135568F0548"></a><h4 id="CNCPT-GUID-4BD4DFD6-DAEA-41B2-BB56-7135568F0548" class="sect4">多元化阅读一致性</h4>
                  <div>
                     <p>在Oracle数据库中，多版本化是同时实现多个版本数据的能力。Oracle数据库维护多版本读取一致性。</p>
                     <p>Oracle数据库的查询具有以下特征：</p>
                     <ul style="list-style-type:disc">
                        <li>
                           <p>读一致查询</p>
                           <p>查询返回的数据将在单个时间点提交并保持一致。</p>
                           <div class="infoboxnote" id="GUID-4BD4DFD6-DAEA-41B2-BB56-7135568F0548__GUID-476AB5BA-55AF-4682-B949-3182CC4CCC98">
                              <p class="notep1">注意：</p>
                              <p>Oracle数据库<span class="italic">从</span>不允许<a href="glossary.html#GUID-E3E574ED-BCBE-4217-8206-D2BD6F075A39"><span class="xrefglossterm">脏读</span></a> ，当事务在另一个事务中读取未提交的数据时会发生这种读。
                              </p>
                           </div>
                           <p>为了说明脏读的问题，假设一个事务更新列值而不提交。第二个事务读取更新的脏（未提交）值。第一个会话回滚事务，以便列具有旧值，但第二个事务使用更新的值继续，从而破坏数据库。脏读取会破坏<a href="glossary.html#GUID-9DE527B3-8901-4F4C-A18F-D2C2C307AFE1"><span class="xrefglossterm">数据完整性</span></a> ，违反外键并忽略唯一约束。
                           </p>
                        </li>
                        <li>
                           <p>非阻止查询</p>
                           <p>数据的读者和编写者不会互相阻塞。</p>
                        </li>
                     </ul>
                     <div class="infoboxnotealso" id="GUID-4BD4DFD6-DAEA-41B2-BB56-7135568F0548__GUID-D0A79A62-5035-498C-9CB1-8F49A9395C5E">
                        <p class="notep1">也可以看看：</p>
                        <p><span class="q">“ <a href="data-concurrency-and-consistency.html#GUID-1D60EFCC-03F4-4A04-B099-1B4DE5D02C47" title="数据库维护几种不同类型的锁，具体取决于获取锁的操作。">锁定行为摘要</a> ”</span></p>
                     </div>
                  </div><a id="CNCPT88960"></a><div class="props_rev_3"><a id="GUID-6A252EAE-7900-47DC-BD6A-D5376A6B7608" name="GUID-6A252EAE-7900-47DC-BD6A-D5376A6B7608"></a><h5 id="CNCPT-GUID-6A252EAE-7900-47DC-BD6A-D5376A6B7608" class="sect5">语句级读一致性</h5>
                     <div>
                        <p>Oracle数据库始终强制执行<span class="bold">语句级读取一致性</span> ，这可确保单个查询返回的数据在单个时间点提交并保持一致。
                        </p>
                        <p>单个SQL语句一致的时间点取决于事务隔离级别和查询的性质：</p>
                        <ul style="list-style-type:disc">
                           <li>
                              <p>在读提交的隔离级别中，此点是<span class="italic">语句</span>打开的时间。例如，如果<code class="codeph">SELECT</code>语句在SCN 1000处打开，则此语句与SCN 1000一致。
                              </p>
                           </li>
                           <li>
                              <p>在可序列化或只读事务中，此点是<span class="italic">事务</span>开始的时间。例如，如果事务从SCN 1000开始，并且在此事务中发生多个<code class="codeph">SELECT</code>语句，则每个语句与SCN 1000一致。
                              </p>
                           </li>
                           <li>
                              <p>在闪回查询操作中（ <code class="codeph">SELECT ...AS OF</code> ）， <code class="codeph">SELECT</code>语句显式指定时间点。例如，您可以查询上周四下午2点出现的表格</p>
                           </li>
                        </ul>
                        <div class="infoboxnotealso" id="GUID-6A252EAE-7900-47DC-BD6A-D5376A6B7608__GUID-572BF8E7-44A0-4A46-94F7-1949ED34113A">
                           <p class="notep1">也可以看看：</p>
                           <p><a href="../adfns/flashback.html#ADFNS01003" target="_blank"><span><cite>Oracle数据库开发指南</cite></span></a> ，了解闪回查询</p>
                        </div>
                     </div>
                  </div><a id="CNCPT88961"></a><div class="props_rev_3"><a id="GUID-D081389D-C338-4E74-BF64-6524795EF764" name="GUID-D081389D-C338-4E74-BF64-6524795EF764"></a><h5 id="CNCPT-GUID-D081389D-C338-4E74-BF64-6524795EF764" class="sect5">事务级读取一致性</h5>
                     <div>
                        <p>Oracle数据库还可以为事务中的所有查询提供读取一致性，称为<span class="bold">事务级读取一致性</span> 。
                        </p>
                        <p>在这种情况下，事务中的每个语句都会看到来自<span class="italic">同一</span>时间点的数据。这是交易开始的时间。
                        </p>
                        <p>可序列化事务所做的查询会查看事务本身所做的更改。例如，更新<code class="codeph">employees</code>然后查询<code class="codeph">employees</code>的事务将看到更新。事务级读取一致性会产生可重复读取，并且不会将查询公开给幻像读取。
                        </p>
                     </div>
                  </div><a id="CNCPT88962"></a><div class="props_rev_3"><a id="GUID-8DC0D1D1-C2B1-4237-9B77-27889B6467C1" name="GUID-8DC0D1D1-C2B1-4237-9B77-27889B6467C1"></a><h5 id="CNCPT-GUID-8DC0D1D1-C2B1-4237-9B77-27889B6467C1" class="sect5">读取一致性和撤消段</h5>
                     <div>
                        <p>要管理多版本读取一致性模型，数据库必须在同时查询和更新表时创建一组读取一致的数据。</p>
                        <p>Oracle数据库通过<a href="glossary.html#GUID-297B963A-989C-4720-B061-A2352FF72892"><span class="xrefglossterm">撤消数据</span></a>实现读取一致性。
                        </p>
                        <p>每当用户修改数据时，Oracle数据库都会创建撤消条目，并将其写入撤消段。还原段包含已由未提交或最近提交的事务更改的旧数据值。因此，数据库中可以存在所有在不同时间点的相同数据的多个版本。数据库可以使用不同时间点的数据快照来提供数据的读取一致视图并启用非阻塞查询。</p>
                        <p>在单实例和Oracle Real Application Clusters（Oracle RAC）环境中保证读取一致性。Oracle RAC使用称为缓存融合的缓存到缓存块传输机制将数据块的读取一致映像从一个数据库实例传输到另一个数据库实例。</p>
                        <div class="infoboxnotealso" id="GUID-8DC0D1D1-C2B1-4237-9B77-27889B6467C1__GUID-A287E0E2-AD8E-4457-A388-BC9D5C15379B">
                           <p class="notep1">也可以看看：</p>
                           <ul style="list-style-type:disc">
                              <li>
                                 <p><span class="q">“ <a href="logical-storage-structures.html#GUID-6E206D3A-E0E7-4B23-9C41-516FB35BC3FE" title="Oracle数据库维护事务操作的记录，统称为撤消数据。">撤消细分</a> ”</span></p>了解撤消存储</li>
                              <li>
                                 <p><span class="q">“ <a href="concepts-for-database-developers.html#GUID-3C50EAB8-FC39-4BB3-B680-4EACCE49E866" title="An internal LOB stores data in the database itself rather than in external files.">内部LOB</a> ”</span>用于了解<span class="q"><a href="concepts-for-database-developers.html#GUID-3C50EAB8-FC39-4BB3-B680-4EACCE49E866" title="内部LOB将数据存储在数据库本身而不是外部文件中。">LOB的</a></span>读取一致性机制</p>
                              </li>
                           </ul>
                        </div>
                     </div><a id="CNCPT88964"></a><a id="CNCPT88963"></a><div class="props_rev_3"><a id="GUID-00A3688F-1219-423C-A5ED-4B8F25BEEAFB" name="GUID-00A3688F-1219-423C-A5ED-4B8F25BEEAFB"></a><h6 id="CNCPT-GUID-00A3688F-1219-423C-A5ED-4B8F25BEEAFB" class="sect6">读一致性：示例</h6>
                        <div>
                           <p>此示例显示了一个查询，该查询使用撤消数据在读提交的隔离级别中提供语句级读取一致性。</p>
                           <div class="figure" id="GUID-00A3688F-1219-423C-A5ED-4B8F25BEEAFB__BABFDBAJ">
                              <p class="titleinfigure">图9-1读取提交的隔离级别中的读取一致性</p><img src="img/cncpt069.gif" alt="下面是图9-1的描述" title="下面是图9-1的描述" longdesc="img_text/cncpt069.html"><br><a href="img_text/cncpt069.html">“图9-1读取提交的隔离级别中的读取一致性”的说明</a></div>
                           <!-- class="figure" -->
                           <p>当数据库代表查询检索数据块时，数据库确保每个块中的数据在查询开始时反映块的内容。数据库根据需要回滚对块的更改，以将块重建到查询开始处理的时间点。</p>
                           <p>数据库使用称为<a href="glossary.html#GUID-4B14A746-A8B3-4123-A02A-3FC1C293042C"><span class="xrefglossterm">SCN</span></a>的内部排序机制来保证事务的顺序。当<code class="codeph">SELECT</code>语句进入执行阶段时，数据库确定在查询开始执行时记录的SCN。在<a href="data-concurrency-and-consistency.html#GUID-00A3688F-1219-423C-A5ED-4B8F25BEEAFB__BABFDBAJ">图9-1中</a> ，此SCN为10023。该查询仅查看与SCN 10023相关的已提交数据。
                           </p>
                           <p>在<a href="data-concurrency-and-consistency.html#GUID-00A3688F-1219-423C-A5ED-4B8F25BEEAFB__BABFDBAJ">图9-1中</a> ，10023 <span class="italic">之后</span>具有SCN的块指示已更改的数据，如具有SCN 10024的两个块所示。<code class="codeph">SELECT</code>语句需要与已提交更改一致的块版本。数据库将当前数据块复制到新缓冲区，并应用撤消数据来重建先前版本的块。这些重建的数据块称为<span class="italic">一致读取（CR）克隆</span> 。
                           </p>
                           <p>在<a href="data-concurrency-and-consistency.html#GUID-00A3688F-1219-423C-A5ED-4B8F25BEEAFB__BABFDBAJ">图9-1中</a> ，数据库创建了两个CR克隆：一个块与SCN 10006一致，另一个块与SCN 10021一致。数据库返回查询的重建数据。通过这种方式，Oracle数据库可以防止脏读。
                           </p>
                           <div class="infoboxnotealso" id="GUID-00A3688F-1219-423C-A5ED-4B8F25BEEAFB__GUID-8AB73DDC-0DF5-4859-B0F9-4CCB5B60CB05">
                              <p class="notep1">也可以看看：</p>
                              <p><span class="q">“ <a href="memory-architecture.html#GUID-4FF66585-E469-4631-9225-29D75594CD14" title="数据库缓冲区高速缓存（也称为缓冲区高速缓存）是存储从数据文件读取的数据块副本的存储区。">数据库缓冲区高速缓存</a> ”</span>和<span class="q">“ <a href="transactions.html#GUID-A2615547-94D2-4346-B156-64C534C5E9E4" title="系统更改编号（SCN）是Oracle数据库使用的逻辑内部时间戳。">系统更改号（SCN）</a> ”</span></p>
                           </div>
                        </div>
                     </div><a id="CNCPT88965"></a><div class="props_rev_3"><a id="GUID-3DA63BF3-5C19-4DBC-8E6B-980771AEA2FB" name="GUID-3DA63BF3-5C19-4DBC-8E6B-980771AEA2FB"></a><h6 id="CNCPT-GUID-3DA63BF3-5C19-4DBC-8E6B-980771AEA2FB" class="sect6">阅读一致性和感兴趣的交易列表</h6>
                        <div>
                           <p>每个段<strong class="term">块的块头</strong>包含<strong class="term">感兴趣的事务列表（ITL）</strong> 。
                           </p>
                           <p>数据库使用ITL来确定在数据库开始修改块时是否未提交事务。</p>
                           <p>ITL中的条目描述了哪些事务已锁定行以及块中的哪些行包含已提交和未提交的更改。ITL指向还原段中的事务表，该段提供有关对数据库所做更改的时间的信息。</p>
                           <p>在某种意义上，块头包含影响块中每行的最近事务历史。<code class="codeph">CREATE TABLE</code>和<code class="codeph">ALTER TABLE</code>语句的<code class="codeph">INITRANS</code>参数控制保留的事务历史记录的数量。
                           </p>
                           <div class="infoboxnotealso" id="GUID-3DA63BF3-5C19-4DBC-8E6B-980771AEA2FB__GUID-F07A610E-B6D9-4290-908A-BC6AB71E180F">
                              <p class="notep1">也可以看看：</p>
                              <p><a href="../sqlrf/CREATE-TABLE.html#SQLRF54481" target="_blank"><span><cite>Oracle Database SQL语言参考</cite></span></a> ，了解<code class="codeph">INITRANS</code>参数</p>
                           </div>
                        </div>
                     </div>
                  </div>
                  <div class="sect4"><a id="GUID-ED6AFF56-F998-4E80-9D6B-105B2610ECAC" name="GUID-ED6AFF56-F998-4E80-9D6B-105B2610ECAC"></a><h5 id="CNCPT-GUID-ED6AFF56-F998-4E80-9D6B-105B2610ECAC" class="sect5">读取一致性和延迟插入</h5>
                     <div>
                        <p>称为<strong class="term">延迟插入的</strong>特殊类型的插入不使用标准读取一致性机制。
                        </p>
                        <p>延迟插入使用<code class="codeph">MEMOPTIMIZE_WRITE</code>提示插入指定为<code class="codeph">MEMOPTIMIZE FOR WRITE</code>的表中。数据库将这些插入缓冲在大型池中而不是缓冲区高速缓存中。数据库不会使用重做和撤消来跟踪更改。相反，当空间管理协调器（SMCO）将缓冲区写入磁盘时，数据库会自动提交更改。无法回滚更改。
                        </p>
                        <p><span>延迟插入物</span>与传统插入物的重要区别在于：</p>
                        <ul style="list-style-type:disc">
                           <li>
                              <p>驻留在大型池中的数据（应用程序假定已提交）可能会丢失。例如，即使应用程序报告保存了更改，数据库实例也可能在将更改保存到磁盘之前失败。</p>
                           </li>
                           <li>
                              <p>不允许直接从内存中读取数据。在后台进程将其写入磁盘之前，编写器无法读取自己的更改。在写入磁盘之前，没有读者可以看到已提交的更改。</p>
                           </li>
                        </ul>
                        <p>必须避免数据丢失的客户端应用程序应在写入大型池后保留本地数据副本。客户端可以使用<code class="codeph">DBMS_MEMOPTIMIZE</code>包来跟踪写入内存的持久性，以及<code class="codeph">DBMS_MEMOPTIMIZE_ADMIN</code>包以强制数据库写入磁盘。
                        </p>
                        <div class="infoboxnotealso" id="GUID-ED6AFF56-F998-4E80-9D6B-105B2610ECAC__GUID-A30B8D85-7074-48C1-ACBB-A81D4E03FEA1">
                           <p class="notep1">也可以看看：</p>
                           <ul style="list-style-type:disc">
                              <li>
                                 <p><span class="q">“ <a href="memory-architecture.html#GUID-07D4439A-8E4E-4FBC-A403-1B0F0B9E0058" title="对于称为延迟插入的特殊类型的插入，数据库从大型池中分配缓冲区。">延迟插入的大型缓冲区</a> ”</span></p>
                              </li>
                              <li>
                                 <p><a href="../sqlrf/COMMENT.html#SQLRF-GUID-65F447C4-6914-4823-9691-F15D52DB74D7" target="_blank"><span><cite>Oracle数据库SQL语言参考，</cite></span></a>以了解有关<code class="codeph">MEMOPTIMIZE FOR WRITE</code>提示的更多信息</p>
                              </li>
                           </ul>
                        </div>
                     </div>
                  </div>
               </div><a id="CNCPT1313"></a><div class="props_rev_3"><a id="GUID-AD960556-7F7B-4242-8B91-6DA22AABA27D" name="GUID-AD960556-7F7B-4242-8B91-6DA22AABA27D"></a><h4 id="CNCPT-GUID-AD960556-7F7B-4242-8B91-6DA22AABA27D" class="sect4">锁定机制</h4>
                  <div>
                     <p>通常，多用户数据库使用某种形式的数据锁定来解决与数据并发性，一致性和完整性相关的问题。</p>
                     <p><a href="glossary.html#GUID-6D016291-A487-4F88-BE0B-ACF8FA2AE72C"><span class="xrefglossterm">锁</span></a>是一种防止访问同一资源的事务之间的破坏性交互的机制。
                     </p>
                     <div class="infoboxnotealso" id="GUID-AD960556-7F7B-4242-8B91-6DA22AABA27D__GUID-7E89FC48-E10C-4B49-89CE-B029123DE541">
                        <p class="notep1">也可以看看：</p>
                        <p><span class="q">“ <a href="data-concurrency-and-consistency.html#GUID-AD0CEE83-2F33-4906-94E1-3D1022924C63" title="锁是一种防止破坏性交互的机制。">Oracle数据库锁定机制概述</a> ”</span></p>
                     </div>
                  </div>
               </div><a id="CNCPT88966"></a><a id="CNCPT1312"></a><div class="props_rev_3"><a id="GUID-7F2C6927-5482-4144-B43B-5E90EF4E055B" name="GUID-7F2C6927-5482-4144-B43B-5E90EF4E055B"></a><h4 id="CNCPT-GUID-7F2C6927-5482-4144-B43B-5E90EF4E055B" class="sect4">ANSI / ISO事务隔离级别</h4>
                  <div>
                     <p>ANSI标准和ISO / IEC都采用的SQL标准定义了四个级别的事务隔离。这些级别对事务处理吞吐量具有不同程度的影响。</p>
                     <div class="section">
                        <p>这些隔离级别是根据在同时执行的事务之间必须防止的现象来定义的。可预防的现象是：</p>
                        <ul style="list-style-type:disc">
                           <li>
                              <p>脏读</p>
                              <p>事务读取已由另一个尚未提交的事务写入的数据。</p>
                           </li>
                           <li>
                              <p>不可重复（模糊）读取</p>
                              <p>事务重新读取先前读取的数据，并发现另一个已提交的事务已修改或删除了数据。例如，用户查询一行，然后查询同一行，只发现数据已更改。</p>
                           </li>
                           <li>
                              <p>幻影读</p>
                              <p>事务重新运行一个查询，返回满足搜索条件的一组行，并发现另一个已提交的事务已插入满足条件的其他行。</p>
                              <p>例如，事务查询员工数量。五分钟后，它执行相同的查询，但现在该数字增加了一个，因为另一个用户为新雇员插入了一条记录。更多数据满足查询标准，但与模糊读取不同，先前读取的数据不变。</p>
                           </li>
                        </ul>
                        <p>SQL标准根据允许在特定隔离级别运行的事务经历的现象来定义四个级别的隔离。<a href="data-concurrency-and-consistency.html#GUID-7F2C6927-5482-4144-B43B-5E90EF4E055B__G35628" title="该表显示了隔离级别的可预防现象。">表9-1</a>显示了级别。
                        </p>
                        <div class="tblformal" id="GUID-7F2C6927-5482-4144-B43B-5E90EF4E055B__G35628">
                           <p class="titleintable">表9-1隔离级别的可预防读取现象</p>
                           <table cellpadding="4" cellspacing="0" class="Formal" title="隔离级别的可预防读取现象" width="100%" border="1" summary="This table shows Preventable Phenomena by Isolation Level. " frame="hsides" rules="rows">
                              <thead>
                                 <tr align="left" valign="top">
                                    <th align="left" valign="bottom" id="d44938e3480">隔离级别</th>
                                    <th align="left" valign="bottom" id="d44938e3484">脏读</th>
                                    <th align="left" valign="bottom" id="d44938e3487">不可重复阅读</th>
                                    <th align="left" valign="bottom" id="d44938e3490">幻影阅读</th>
                                 </tr>
                              </thead>
                              <tbody>
                                 <tr align="left" valign="top">
                                    <td align="left" valign="top" id="d44938e3495" headers="d44938e3480 ">
                                       <p>读取未提交</p>
                                    </td>
                                    <td align="left" valign="top" headers="d44938e3495 d44938e3484 ">
                                       <p>可能</p>
                                    </td>
                                    <td align="left" valign="top" headers="d44938e3495 d44938e3487 ">
                                       <p>可能</p>
                                    </td>
                                    <td align="left" valign="top" headers="d44938e3495 d44938e3490 ">
                                       <p>可能</p>
                                    </td>
                                 </tr>
                                 <tr align="left" valign="top">
                                    <td align="left" valign="top" id="d44938e3508" headers="d44938e3480 ">
                                       <p>读取已提交</p>
                                    </td>
                                    <td align="left" valign="top" headers="d44938e3508 d44938e3484 ">
                                       <p>不可能</p>
                                    </td>
                                    <td align="left" valign="top" headers="d44938e3508 d44938e3487 ">
                                       <p>可能</p>
                                    </td>
                                    <td align="left" valign="top" headers="d44938e3508 d44938e3490 ">
                                       <p>可能</p>
                                    </td>
                                 </tr>
                                 <tr align="left" valign="top">
                                    <td align="left" valign="top" id="d44938e3521" headers="d44938e3480 ">
                                       <p>可重复阅读</p>
                                    </td>
                                    <td align="left" valign="top" headers="d44938e3521 d44938e3484 ">
                                       <p>不可能</p>
                                    </td>
                                    <td align="left" valign="top" headers="d44938e3521 d44938e3487 ">
                                       <p>不可能</p>
                                    </td>
                                    <td align="left" valign="top" headers="d44938e3521 d44938e3490 ">
                                       <p>可能</p>
                                    </td>
                                 </tr>
                                 <tr align="left" valign="top">
                                    <td align="left" valign="top" id="d44938e3534" headers="d44938e3480 ">
                                       <p>序列化</p>
                                    </td>
                                    <td align="left" valign="top" headers="d44938e3534 d44938e3484 ">
                                       <p>不可能</p>
                                    </td>
                                    <td align="left" valign="top" headers="d44938e3534 d44938e3487 ">
                                       <p>不可能</p>
                                    </td>
                                    <td align="left" valign="top" headers="d44938e3534 d44938e3490 ">
                                       <p>不可能</p>
                                    </td>
                                 </tr>
                              </tbody>
                           </table>
                        </div>
                        <!-- class="inftblhruleinformal" -->
                        <p>Oracle数据库提供读取提交（默认）和可序列化隔离级别。此外，数据库提供只读模式。</p>
                        <div class="infoboxnotealso" id="GUID-7F2C6927-5482-4144-B43B-5E90EF4E055B__GUID-B38BF468-DDE1-4E76-9404-96583005DBEB">
                           <p class="notep1">也可以看看：</p>
                           <ul style="list-style-type:disc">
                              <li>
                                 <p><span class="q">“ <a href="data-concurrency-and-consistency.html#GUID-2A0FDFF0-5F72-4476-BFD2-060A20EA1685" title="事务隔离级别的ANSI标准是根据每个隔离级别允许或阻止的现象来定义的。">Oracle数据库事务隔离级别概述</a> ”</span> ，了解读取已提交，可序列化和只读隔离级别</p>
                              </li>
                              <li>
                                 <p><a href="../sqlrf/Oracle-and-Standard-SQL.html#SQLRF019" target="_blank"><span><cite>Oracle数据库SQL语言参考，</cite></span></a>用于讨论Oracle数据库与SQL标准的一致性</p>
                              </li>
                           </ul>
                        </div>
                     </div>
                     <!-- class="section" -->
                  </div>
               </div>
            </div><a id="CNCPT621"></a><div class="props_rev_3"><a id="GUID-2A0FDFF0-5F72-4476-BFD2-060A20EA1685" name="GUID-2A0FDFF0-5F72-4476-BFD2-060A20EA1685"></a><h3 id="CNCPT-GUID-2A0FDFF0-5F72-4476-BFD2-060A20EA1685" class="sect3">Oracle数据库事务隔离级别概述</h3>
               <div>
                  <p>事务隔离级别的ANSI标准是根据每个隔离级别允许或阻止的现象来定义的。</p>
                  <p>Oracle数据库提供事务隔离级别：</p>
                  <ul style="list-style-type:disc">
                     <li>
                        <p><a href="data-concurrency-and-consistency.html#GUID-DB571DA8-864F-4FE9-93B9-3EC2DD0604FE" title="在读提交的隔离级别中，事务执行的每个查询仅查看在查询之前提交的数据 - 而不是事务开始。">读取提交的隔离级别</a></p>
                     </li>
                     <li>
                        <p><a href="data-concurrency-and-consistency.html#GUID-8DA9A191-4CA3-4B1A-995F-4B17471C2738" title="在可序列化隔离级别中，事务只能看到在事务而非查询开始时提交的更改以及事务本身所做的更改。">可序列化的隔离级别</a></p>
                     </li>
                     <li>
                        <p><a href="data-concurrency-and-consistency.html#GUID-371C3622-540E-490C-BD83-F12CE4CF39C6" title="只读隔离级别与可序列化隔离级别类似，但只读事务不允许在事务中修改数据，除非用户是SYS。">只读隔离级别</a></p>
                     </li>
                  </ul>
                  <div class="infoboxnotealso" id="GUID-2A0FDFF0-5F72-4476-BFD2-060A20EA1685__GUID-2FD80AC4-7635-4CB6-9F8E-CFB02E1CE54C">
                     <p class="notep1">也可以看看：</p>
                     <ul style="list-style-type:disc">
                        <li>
                           <p><a href="../adfns/sql-processing-for-application-developers.html#ADFNS99999" target="_blank"><span><cite>Oracle数据库开发指南</cite></span></a>了解有关事务隔离级别的更多信息</p>
                        </li>
                        <li>
                           <p><a href="../sqlrf/SET-TRANSACTION.html#SQLRF55422" target="_blank"><span><cite>Oracle数据库SQL语言参考</cite></span></a>和<a href="../lnpls/static-sql.html#LNPLS00608" target="_blank"><span><cite>Oracle数据库PL / SQL语言参考</cite></span></a> ，了解<code class="codeph">SET TRANSACTION ISOLATION LEVEL</code></p>
                        </li>
                     </ul>
                  </div>
               </div><a id="CNCPT1319"></a><div class="props_rev_3"><a id="GUID-DB571DA8-864F-4FE9-93B9-3EC2DD0604FE" name="GUID-DB571DA8-864F-4FE9-93B9-3EC2DD0604FE"></a><h4 id="CNCPT-GUID-DB571DA8-864F-4FE9-93B9-3EC2DD0604FE" class="sect4">读取提交的隔离级别</h4>
                  <div>
                     <p>在<span class="bold">读提交的隔离级别中</span> ，事务执行的每个查询仅查看在查询之前提交的数据 - 而不是事务开始。
                     </p>
                     <p>此隔离级别是默认值。它适用于很少有交易可能发生冲突的数据库环境。</p>
                     <p>读取已提交事务中的查询可避免读取在查询正在进行时提交的数据。例如，如果查询是对百万行表的扫描的一半，并且如果另一个事务将更新提交到行950,000，则查询在读取行950,000时不会看到此更改。但是，由于数据库不会阻止其他事务修改查询读取的数据，因此其他事务可能会<span class="italic">在</span>查询执行<span class="italic">之间</span>更改数据。因此，两次运行相同查询的事务可能会遇到模糊读取和幻像。
                     </p>
                  </div><a id="CNCPT050"></a><div class="props_rev_3"><a id="GUID-432C4EDC-F7F2-467C-B85F-4E82D3D58A2F" name="GUID-432C4EDC-F7F2-467C-B85F-4E82D3D58A2F"></a><h5 id="CNCPT-GUID-432C4EDC-F7F2-467C-B85F-4E82D3D58A2F" class="sect5">在Read Committed Isolation Level中读取一致性</h5>
                     <div>
                        <p>数据库为每个查询提供一致的结果集，保证数据的一致性，用户无需采取任何操作。</p>
                        <p><a href="glossary.html#GUID-E802CBDA-5F3B-40CF-9749-612F0E0E4A35"><span class="xrefglossterm">隐式查询</span></a> （例如<code class="codeph">UPDATE</code>语句中<code class="codeph">WHERE</code>子句隐含的查询）可保证一组一致的结果。但是，隐式查询中的每个语句都不会看到DML语句本身所做的更改，而是会看到更改之前存在的数据。
                        </p>
                        <p>如果<code class="codeph">SELECT</code>列表包含PL / SQL函数，则数据库在语句级别为PL / SQL函数代码中的SQL运行应用语句级读取一致性，而不是在父SQL级别。例如，函数可以访问其数据由另一个用户更改和提交的表。对于函数中每次执行<code class="codeph">SELECT</code> ，都会建立一个新的读一致性快照。
                        </p>
                        <div class="infoboxnotealso" id="GUID-432C4EDC-F7F2-467C-B85F-4E82D3D58A2F__GUID-64857734-72D0-49BA-AC0B-CE3C7DC8B6C8">
                           <p class="notep1">也可以看看：</p>
                           <p><span class="q">“ <a href="sql.html#GUID-65D6723C-88E2-44E3-85D1-A719BB5F075E" title="子查询是嵌套在另一个SQL语句中的SELECT语句。当您必须执行多个查询来解决单个问题时，子查询很有用。">子查询</a> ”</span></p>
                        </div>
                     </div>
                  </div><a id="CNCPT89216"></a><a id="CNCPT051"></a><div class="props_rev_3"><a id="GUID-8A15F1B2-3F64-49E7-929D-4768B2DB7DD7" name="GUID-8A15F1B2-3F64-49E7-929D-4768B2DB7DD7"></a><h5 id="CNCPT-GUID-8A15F1B2-3F64-49E7-929D-4768B2DB7DD7" class="sect5">读取提交事务中的冲突写入</h5>
                     <div>
                        <p>在读取已提交事务中，当事务尝试更改由未提交的并发事务更新的行时，会发生<span class="bold">冲突写入</span> 。
                        </p>
                        <p>阻止行修改的事务有时称为<span class="italic">阻塞事务</span> 。读提交的事务等待阻塞事务结束并释放其行锁。
                        </p>
                        <p>选项如下：</p>
                        <ul style="list-style-type:disc">
                           <li>
                              <p>如果阻塞事务回滚，则等待事务继续更改先前锁定的行，就好像另一个事务从未存在一样。</p>
                           </li>
                           <li>
                              <p>如果阻塞事务提交并释放其锁，则等待事务将继续其对新更改的行的预期更新。</p>
                           </li>
                        </ul>
                        <p>下表显示了事务1（可序列化或已提交读取）如何与读取已提交事务2交互。它显示了一种称为<a href="glossary.html#GUID-F9DA6F63-B518-44C5-B98B-2425680EB498"><span class="xrefglossterm">丢失更新</span></a>的经典情况。<span class="italic">即使事务1已提交</span> ，事务1进行的更新也不在表中。设计处理丢失更新的策略是应用程序开发的重要部分。
                        </p>
                        <div class="tblformalwide" id="GUID-8A15F1B2-3F64-49E7-929D-4768B2DB7DD7__CHDBBCEI">
                           <p class="titleintable">表9-2 READ COMMITTED事务中的冲突写入和丢失的更新</p>
                           <table cellpadding="4" cellspacing="0" class="FormalWide" title="READ COMMITTED事务中的冲突写入和丢失的更新" width="100%" border="1" summary="This table describes the conflicting writes and lost updates in a READ COMMITTED transaction, when a serializable or read committed transaction interacts with a read committed transaction." frame="hsides" rules="rows">
                              <thead>
                                 <tr align="left" valign="top">
                                    <th align="left" valign="bottom" width="34%" id="d44938e4810">第1节</th>
                                    <th align="left" valign="bottom" width="35%" id="d44938e4813">第二节</th>
                                    <th align="left" valign="bottom" width="31%" id="d44938e4816">说明</th>
                                 </tr>
                              </thead>
                              <tbody>
                                 <tr align="left" valign="top">
                                    <td align="left" valign="top" width="34%" id="d44938e4821" headers="d44938e4810 "><pre class="oac_no_warn" dir="ltr">SQL&gt; SELECT last_name，salary FROM employees WHERE last_name IN（'Banda'，'Greene'，'Hintz'）; LAST_NAME SALARY ------------- ---------- Banda 6200 Greene 9500</pre></td>
                                    <td align="left" valign="top" width="35%" headers="d44938e4821 d44938e4813 ">没有动作。</td>
                                    <td align="left" valign="top" width="31%" headers="d44938e4821 d44938e4816 ">
                                       <p>第1节查询Banda，Greene和Hintz的工资。没有找到名为Hintz的员工。</p>
                                    </td>
                                 </tr>
                                 <tr align="left" valign="top">
                                    <td align="left" valign="top" width="34%" id="d44938e4830" headers="d44938e4810 "><pre class="oac_no_warn" dir="ltr">SQL&gt; UPDATE employees SET salary = 7000 WHERE last_name ='Banda';</pre></td>
                                    <td align="left" valign="top" width="35%" headers="d44938e4830 d44938e4813 ">没有动作。</td>
                                    <td align="left" valign="top" width="31%" headers="d44938e4830 d44938e4816 ">
                                       <p>会话1通过更新班达工资开始交易。事务1的默认隔离级别为<code class="codeph">READ COMMITTED</code> 。</p>
                                    </td>
                                 </tr>
                                 <tr align="left" valign="top">
                                    <td align="left" valign="top" width="34%" id="d44938e4842" headers="d44938e4810 ">没有动作。</td>
                                    <td align="left" valign="top" width="35%" headers="d44938e4842 d44938e4813 "><pre class="oac_no_warn" dir="ltr">SQL&gt; SET TRANSACTION ISOLATION LEVEL READ COMMITTED;</pre></td>
                                    <td align="left" valign="top" width="31%" headers="d44938e4842 d44938e4816 ">
                                       <p>会话2开始事务2并将隔离级别显式设置为<code class="codeph">READ COMMITTED</code> 。</p>
                                    </td>
                                 </tr>
                                 <tr align="left" valign="top">
                                    <td align="left" valign="top" width="34%" id="d44938e4854" headers="d44938e4810 ">没有动作。</td>
                                    <td align="left" valign="top" width="35%" headers="d44938e4854 d44938e4813 "><pre class="oac_no_warn" dir="ltr">SQL&gt; SELECT last_name，salary FROM employees WHERE last_name IN（'Banda'，'Greene'，'Hintz'）; LAST_NAME SALARY ------------- ---------- Banda 6200 Greene 9500</pre></td>
                                    <td align="left" valign="top" width="31%" headers="d44938e4854 d44938e4816 ">
                                       <p>交易2查询Banda，Greene和Hintz的工资。Oracle数据库使用读一致性来显示事务1进行的未提交更新之前Banda的工资。</p>
                                    </td>
                                 </tr>
                                 <tr align="left" valign="top">
                                    <td align="left" valign="top" width="34%" id="d44938e4863" headers="d44938e4810 ">没有动作。</td>
                                    <td align="left" valign="top" width="35%" headers="d44938e4863 d44938e4813 "><pre class="oac_no_warn" dir="ltr">SQL&gt; UPDATE employees SET salary = 9900 WHERE last_name ='Greene';</pre></td>
                                    <td align="left" valign="top" width="31%" headers="d44938e4863 d44938e4816 ">
                                       <p>事务2成功更新Greene的工资，因为事务1仅锁定了Banda行。</p>
                                    </td>
                                 </tr>
                                 <tr align="left" valign="top">
                                    <td align="left" valign="top" width="34%" id="d44938e4872" headers="d44938e4810 "><pre class="oac_no_warn" dir="ltr">SQL&gt; INSERT INTO employees（employee_id，last_name，email，hire_date，job_id）VALUES（210，'Hintz'，'JHINTZ'，SYSDATE，'SH_CLERK'）;</pre></td>
                                    <td align="left" valign="top" width="35%" headers="d44938e4872 d44938e4813 ">没有动作。</td>
                                    <td align="left" valign="top" width="31%" headers="d44938e4872 d44938e4816 ">
                                       <p>事务1为员工Hintz插入一行，但不提交。</p>
                                    </td>
                                 </tr>
                                 <tr align="left" valign="top">
                                    <td align="left" valign="top" width="34%" id="d44938e4881" headers="d44938e4810 ">没有动作。</td>
                                    <td align="left" valign="top" width="35%" headers="d44938e4881 d44938e4813 "><pre class="oac_no_warn" dir="ltr">SQL&gt; SELECT last_name，salary FROM employees WHERE last_name IN（'Banda'，'Greene'，'Hintz'）; LAST_NAME SALARY ------------- ---------- Banda 6200 Greene 9900</pre></td>
                                    <td align="left" valign="top" width="31%" headers="d44938e4881 d44938e4816 ">
                                       <p>交易2查询员工Banda，Greene和Hintz的工资。</p>
                                       <p>交易2看到了自己对Greene工资的更新。事务2没有看到对Banda工资的未提交更新或事务1对Hintz的插入。</p>
                                    </td>
                                 </tr>
                                 <tr align="left" valign="top">
                                    <td align="left" valign="top" width="34%" id="d44938e4892" headers="d44938e4810 ">没有动作。</td>
                                    <td align="left" valign="top" width="35%" headers="d44938e4892 d44938e4813 "><pre class="oac_no_warn" dir="ltr">SQL&gt; UPDATE employees SET salary = 6300 WHERE last_name ='Banda'; - 提示不返回</pre></td>
                                    <td align="left" valign="top" width="31%" headers="d44938e4892 d44938e4816 ">
                                       <p>事务2尝试更新当前由事务1锁定的Banda行，从而产生冲突写入。交易2等到交易1结束。</p>
                                    </td>
                                 </tr>
                                 <tr align="left" valign="top">
                                    <td align="left" valign="top" width="34%" id="d44938e4901" headers="d44938e4810 "><pre class="oac_no_warn" dir="ltr">SQL&gt; COMMIT;</pre></td>
                                    <td align="left" valign="top" width="35%" headers="d44938e4901 d44938e4813 ">没有动作。</td>
                                    <td align="left" valign="top" width="31%" headers="d44938e4901 d44938e4816 ">
                                       <p>事务1提交其工作，结束事务。</p>
                                    </td>
                                 </tr>
                                 <tr align="left" valign="top">
                                    <td align="left" valign="top" width="34%" id="d44938e4910" headers="d44938e4810 ">没有动作。</td>
                                    <td align="left" valign="top" width="35%" headers="d44938e4910 d44938e4813 "><pre class="oac_no_warn" dir="ltr">1行更新。SQL&gt;</pre></td>
                                    <td align="left" valign="top" width="31%" headers="d44938e4910 d44938e4816 ">
                                       <p>Banda行的锁定现已释放，因此事务2继续更新Banda的工资。</p>
                                    </td>
                                 </tr>
                                 <tr align="left" valign="top">
                                    <td align="left" valign="top" width="34%" id="d44938e4919" headers="d44938e4810 ">没有动作。</td>
                                    <td align="left" valign="top" width="35%" headers="d44938e4919 d44938e4813 "><pre class="oac_no_warn" dir="ltr">SQL&gt; SELECT last_name，salary FROM employees WHERE last_name IN（'Banda'，'Greene'，'Hintz'）; LAST_NAME SALARY ------------- ---------- Banda 6300 Greene 9900 Hintz</pre></td>
                                    <td align="left" valign="top" width="31%" headers="d44938e4919 d44938e4816 ">
                                       <p>交易2查询员工Banda，Greene和Hintz的工资。事务1提交的Hintz插入现在对事务2可见。交易2看到了自己对班达工资的更新。</p>
                                    </td>
                                 </tr>
                                 <tr align="left" valign="top">
                                    <td align="left" valign="top" width="34%" id="d44938e4929" headers="d44938e4810 ">没有动作。</td>
                                    <td align="left" valign="top" width="35%" headers="d44938e4929 d44938e4813 "><pre class="oac_no_warn" dir="ltr">承诺;</pre></td>
                                    <td align="left" valign="top" width="31%" headers="d44938e4929 d44938e4816 ">
                                       <p>交易2提交其工作，结束交易。</p>
                                    </td>
                                 </tr>
                                 <tr align="left" valign="top">
                                    <td align="left" valign="top" width="34%" id="d44938e4938" headers="d44938e4810 "><pre class="oac_no_warn" dir="ltr">SQL&gt; SELECT last_name，salary FROM employees WHERE last_name IN（'Banda'，'Greene'，'Hintz'）; LAST_NAME SALARY ------------- ---------- Banda 6300 Greene 9900 Hintz</pre></td>
                                    <td align="left" valign="top" width="35%" headers="d44938e4938 d44938e4813 ">没有动作。</td>
                                    <td align="left" valign="top" width="31%" headers="d44938e4938 d44938e4816 ">
                                       <p>会话1查询Banda，Greene和Hintz的行。Banda的薪水是6300，这是交易2的更新。交易1对班达的薪水更新为7000，现在“丢失了”。</p>
                                    </td>
                                 </tr>
                              </tbody>
                           </table>
                        </div>
                        <!-- class="inftblhruleinformal" -->
                        <div class="infoboxnotealso" id="GUID-8A15F1B2-3F64-49E7-929D-4768B2DB7DD7__GUID-921181FD-EBF1-49C3-983F-B81356D32405">
                           <p class="notep1">也可以看看：</p>
                           <ul style="list-style-type:disc">
                              <li>
                                 <p> <span class="q">“ <a href="data-concurrency-and-consistency.html#GUID-E6FB4581-CD65-4C18-AFDD-ACB3243238D3" title="在单用户数据库中，不需要锁定，因为只有一个用户正在修改信息。但是，当多个用户访问和修改数据时，数据库必须提供一种防止同时修改相同数据的方法。">使用锁定</a> ”</span>了解丢失的更新</p>
                              </li>
                              <li>
                                 <p><span class="q">“ <a href="data-concurrency-and-consistency.html#GUID-92D38952-A7A0-486F-9547-BDB6E624F125" title="行锁（也称为TX锁）是对单行表的锁定。事务获取由INSERT，UPDATE，DELETE，MERGE或SELECT修改的每一行的行锁...FOR UPDATE语句。行锁定存在，直到事务提交或回滚。">行锁定（TX）</a> ”</span>以了解数据库获取行锁的时间和原因</p>
                              </li>
                           </ul>
                        </div>
                     </div>
                  </div>
               </div><a id="CNCPT88968"></a><a id="CNCPT1320"></a><div class="props_rev_3"><a id="GUID-8DA9A191-4CA3-4B1A-995F-4B17471C2738" name="GUID-8DA9A191-4CA3-4B1A-995F-4B17471C2738"></a><h4 id="CNCPT-GUID-8DA9A191-4CA3-4B1A-995F-4B17471C2738" class="sect4">可序列化的隔离级别</h4>
                  <div>
                     <p>在可<strong class="term">序列化隔离级别中</strong> ，事务只能看到在事务而非查询开始时提交的更改以及事务本身所做的更改。
                     </p>
                     <p>可序列化事务在一个环境中运行，使其看起来好像没有其他用户在修改数据库中的数据。可序列化隔离适用于以下环境：</p>
                     <ul style="list-style-type:disc">
                        <li>
                           <p>使用大型数据库和短事务只更新几行</p>
                        </li>
                        <li>
                           <p>两个并发事务修改相同行的可能性相对较低</p>
                        </li>
                        <li>
                           <p>相对长时间运行的交易主要是只读的</p>
                        </li>
                     </ul>
                     <p>在可序列化隔离中，通常在语句级别获得的读取一致性扩展到整个事务。重读时，事务读取的任何行都保证相同。任何查询都保证在事务持续时间内返回相同的结果，因此查询看不到其他事务所做的更改，无论它运行了多长时间。可序列化事务不会遇到脏读，模糊读取或幻像读取。</p>
                     <p>Oracle数据库允许可序列化事务仅在可序列化事务开始时<span class="italic">已经</span>提交其他事务所做的行更改时修改行。当可序列化事务尝试更新或删除由可序列化事务开始<span class="italic">后</span>提交的其他事务更改的数据时，数据库会生成错误：</p><pre class="pre codeblock"><code>ORA-08177：无法序列化此事务的访问权限</code></pre><p>当可序列化事务因<code class="codeph">ORA-08177</code>错误而失败时，应用程序可以执行多项操作，包括以下操作：</p>
                     <ul style="list-style-type:disc">
                        <li>
                           <p>将执行的工作提交到那一点</p>
                        </li>
                        <li>
                           <p>执行其他（但不同的）语句，可能是在回滚到事务中先前建立的<a href="glossary.html#GUID-ED9601F2-D0A2-4FE5-83A8-8F7F9E9E0D18"><span class="xrefglossterm">保存点</span></a>之后</p>
                        </li>
                        <li>
                           <p>回滚整个交易</p>
                        </li>
                     </ul>
                     <p>下表显示了可序列化事务如何与其他事务交互。如果可序列化事务在可序列化事务开始后没有尝试更改由另一个事务提交的行，则避免了序列化访问问题。</p>
                     <div class="tblformalwide" id="GUID-8DA9A191-4CA3-4B1A-995F-4B17471C2738__BABDGDII">
                        <p class="titleintable">表9-3可序列化事务</p>
                        <table cellpadding="4" cellspacing="0" class="FormalWide" title="可序列化的交易" width="100%" border="1" summary="This table shows how a serializable transaction interacts with other transactions. " frame="hsides" rules="rows">
                           <thead>
                              <tr align="left" valign="top">
                                 <th align="left" valign="bottom" width="35%" id="d44938e5336">第1节</th>
                                 <th align="left" valign="bottom" width="35%" id="d44938e5339">第二节</th>
                                 <th align="left" valign="bottom" width="30%" id="d44938e5342">说明</th>
                              </tr>
                           </thead>
                           <tbody>
                              <tr align="left" valign="top">
                                 <td align="left" valign="top" width="35%" id="d44938e5347" headers="d44938e5336 "><pre class="pre codeblock"><code>SQL&gt; SELECT last_name，salary FROM employees WHERE last_name IN（'Banda'，'Greene'，'Hintz'）; LAST_NAME SALARY ------------- ---------- Banda 6200 Greene 9500</code></pre></td>
                                 <td align="left" valign="top" width="35%" headers="d44938e5347 d44938e5339 ">
                                    <p>没有动作。</p>
                                 </td>
                                 <td align="left" valign="top" width="30%" headers="d44938e5347 d44938e5342 ">
                                    <p>第1节查询Banda，Greene和Hintz的工资。没有找到名为Hintz的员工。</p>
                                 </td>
                              </tr>
                              <tr align="left" valign="top">
                                 <td align="left" valign="top" width="35%" id="d44938e5357" headers="d44938e5336 "><pre class="pre codeblock"><code>SQL&gt; UPDATE employees SET salary = 7000 WHERE last_name ='Banda';</code></pre></td>
                                 <td align="left" valign="top" width="35%" headers="d44938e5357 d44938e5339 ">
                                    <p>没有动作。</p>
                                 </td>
                                 <td align="left" valign="top" width="30%" headers="d44938e5357 d44938e5342 ">
                                    <p>会话1通过更新班达工资开始交易1。默认隔离级别为<code class="codeph">READ COMMITTED</code> 。</p>
                                 </td>
                              </tr>
                              <tr align="left" valign="top">
                                 <td align="left" valign="top" width="35%" id="d44938e5370" headers="d44938e5336 ">
                                    <p>没有动作。</p>
                                 </td>
                                 <td align="left" valign="top" width="35%" headers="d44938e5370 d44938e5339 "><pre class="pre codeblock"><code>SQL&gt; SET TRANSACTION ISOLATION LEVEL SERIALIZABLE;</code></pre></td>
                                 <td align="left" valign="top" width="30%" headers="d44938e5370 d44938e5342 ">
                                    <p>会话2开始事务2并将其设置为<code class="codeph">SERIALIZABLE</code>隔离级别。
                                    </p>
                                 </td>
                              </tr>
                              <tr align="left" valign="top">
                                 <td align="left" valign="top" width="35%" id="d44938e5383" headers="d44938e5336 ">
                                    <p>没有动作。</p>
                                 </td>
                                 <td align="left" valign="top" width="35%" headers="d44938e5383 d44938e5339 "><pre class="pre codeblock"><code>SQL&gt; SELECT last_name，salary FROM employees WHERE last_name IN（'Banda'，'Greene'，'Hintz'）; LAST_NAME SALARY ------------ ---------- Banda 6200 Greene 9500</code></pre></td>
                                 <td align="left" valign="top" width="30%" headers="d44938e5383 d44938e5342 ">
                                    <p>交易2查询Banda，Greene和Hintz的工资。Oracle数据库使用读一致性来显示事务1 <span class="italic">进行</span>的未提交更新<span class="italic">之前</span> Banda的工资。
                                    </p>
                                 </td>
                              </tr>
                              <tr align="left" valign="top">
                                 <td align="left" valign="top" width="35%" id="d44938e5396" headers="d44938e5336 ">
                                    <p>没有动作。</p>
                                 </td>
                                 <td align="left" valign="top" width="35%" headers="d44938e5396 d44938e5339 "><pre class="pre codeblock"><code>SQL&gt; UPDATE employees SET salary = 9900 WHERE last_name ='Greene';</code></pre></td>
                                 <td align="left" valign="top" width="30%" headers="d44938e5396 d44938e5342 ">
                                    <p>事务2成功更新Greene薪水，因为只有Banda行被锁定。</p>
                                 </td>
                              </tr>
                              <tr align="left" valign="top">
                                 <td align="left" valign="top" width="35%" id="d44938e5406" headers="d44938e5336 "><pre class="pre codeblock"><code>SQL&gt; INSERT INTO employees（employee_id，last_name，email，hire_date，job_id）VALUES（210，'Hintz'，'JHINTZ'，SYSDATE，'SH_CLERK'）;</code></pre></td>
                                 <td align="left" valign="top" width="35%" headers="d44938e5406 d44938e5339 ">
                                    <p>没有动作。</p>
                                 </td>
                                 <td align="left" valign="top" width="30%" headers="d44938e5406 d44938e5342 ">
                                    <p>事务1为员工Hintz插入一行。</p>
                                 </td>
                              </tr>
                              <tr align="left" valign="top">
                                 <td align="left" valign="top" width="35%" id="d44938e5416" headers="d44938e5336 "><pre class="pre codeblock"><code>SQL&gt; COMMIT;</code></pre></td>
                                 <td align="left" valign="top" width="35%" headers="d44938e5416 d44938e5339 ">
                                    <p>没有动作。</p>
                                 </td>
                                 <td align="left" valign="top" width="30%" headers="d44938e5416 d44938e5342 ">
                                    <p>事务1提交其工作，结束事务。</p>
                                 </td>
                              </tr>
                              <tr align="left" valign="top">
                                 <td align="left" valign="top" width="35%" id="d44938e5426" headers="d44938e5336 "><pre class="pre codeblock"><code>SQL&gt; SELECT last_name，salary FROM employees WHERE last_name IN（'Banda'，'Greene'，'Hintz'）; LAST_NAME SALARY ------------- ---------- Banda 7000 Greene 9500 Hintz</code></pre></td>
                                 <td align="left" valign="top" width="35%" headers="d44938e5426 d44938e5339 "><pre class="pre codeblock"><code>SQL&gt; SELECT last_name，salary FROM employees WHERE last_name IN（'Banda'，'Greene'，'Hintz'）; LAST_NAME SALARY ------------- --------- Banda 6200 Greene 9900</code></pre></td>
                                 <td align="left" valign="top" width="30%" headers="d44938e5426 d44938e5342 ">
                                    <p>第1节查询员工Banda，Greene和Hintz的工资，并查看交易1所做的更改。会话1未看到事务2所做的未提交的Greene更新。</p>
                                    <p>交易2查询员工Banda，Greene和Hintz的工资。Oracle数据库读取一致性确保事务1 <span class="italic">不会</span>显示事务1提交的Hintz插入和Banda更新。交易2看到自己对Greene工资的更新。
                                    </p>
                                 </td>
                              </tr>
                              <tr align="left" valign="top">
                                 <td align="left" valign="top" width="35%" id="d44938e5441" headers="d44938e5336 ">
                                    <p>没有动作。</p>
                                 </td>
                                 <td align="left" valign="top" width="35%" headers="d44938e5441 d44938e5339 "><pre class="pre codeblock"><code>承诺;</code></pre></td>
                                 <td align="left" valign="top" width="30%" headers="d44938e5441 d44938e5342 ">
                                    <p>交易2提交其工作，结束交易。</p>
                                 </td>
                              </tr>
                              <tr align="left" valign="top">
                                 <td align="left" valign="top" width="35%" id="d44938e5451" headers="d44938e5336 "><pre class="pre codeblock"><code>SQL&gt; SELECT last_name，salary FROM employees WHERE last_name IN（'Banda'，'Greene'，'Hintz'）; LAST_NAME SALARY ------------- ---------- Banda 7000 Greene 9900 Hintz</code></pre></td>
                                 <td align="left" valign="top" width="35%" headers="d44938e5451 d44938e5339 "><pre class="pre codeblock"><code>SQL&gt; SELECT last_name，salary FROM employees WHERE last_name IN（'Banda'，'Greene'，'Hintz'）; LAST_NAME SALARY ------------- --------- Banda 7000 Greene 9900 Hintz</code></pre></td>
                                 <td align="left" valign="top" width="30%" headers="d44938e5451 d44938e5342 ">
                                    <p>两个会话都查询Banda，Greene和Hintz的工资。每个会话都会看到事务1和事务2所做的所有已提交的更改。</p>
                                 </td>
                              </tr>
                              <tr align="left" valign="top">
                                 <td align="left" valign="top" width="35%" id="d44938e5461" headers="d44938e5336 "><pre class="pre codeblock"><code>SQL&gt; UPDATE employees SET salary = 7100 WHERE last_name ='Hintz';</code></pre></td>
                                 <td align="left" valign="top" width="35%" headers="d44938e5461 d44938e5339 ">
                                    <p>没有动作。</p>
                                 </td>
                                 <td align="left" valign="top" width="30%" headers="d44938e5461 d44938e5342 ">
                                    <p>会话1通过更新Hintz薪水开始交易3。事务3的默认隔离级别为<code class="codeph">READ COMMITTED</code> 。</p>
                                 </td>
                              </tr>
                              <tr align="left" valign="top">
                                 <td align="left" valign="top" width="35%" id="d44938e5475" headers="d44938e5336 ">
                                    <p>没有动作。</p>
                                 </td>
                                 <td align="left" valign="top" width="35%" headers="d44938e5475 d44938e5339 "><pre class="pre codeblock"><code>SQL&gt; SET TRANSACTION ISOLATION LEVEL SERIALIZABLE;</code></pre></td>
                                 <td align="left" valign="top" width="30%" headers="d44938e5475 d44938e5342 ">
                                    <p>会话2开始事务4并将其设置为<code class="codeph">SERIALIZABLE</code>隔离级别。
                                    </p>
                                 </td>
                              </tr>
                              <tr align="left" valign="top">
                                 <td align="left" valign="top" width="35%" id="d44938e5488" headers="d44938e5336 ">
                                    <p>没有动作。</p>
                                 </td>
                                 <td align="left" valign="top" width="35%" headers="d44938e5488 d44938e5339 "><pre class="pre codeblock"><code>SQL&gt; UPDATE employees SET salary = 7200 WHERE last_name ='Hintz'; - 提示不返回</code></pre></td>
                                 <td align="left" valign="top" width="30%" headers="d44938e5488 d44938e5342 ">
                                    <p>事务4尝试更新Hintz的工资，但被阻止，因为事务3锁定了Hintz行。事务4在事务3后面排队。</p>
                                 </td>
                              </tr>
                              <tr align="left" valign="top">
                                 <td align="left" valign="top" width="35%" id="d44938e5498" headers="d44938e5336 "><pre class="pre codeblock"><code>SQL&gt; COMMIT;</code></pre></td>
                                 <td align="left" valign="top" width="35%" headers="d44938e5498 d44938e5339 ">
                                    <p>没有动作。</p>
                                 </td>
                                 <td align="left" valign="top" width="30%" headers="d44938e5498 d44938e5342 ">
                                    <p>交易3提交更新Hintz工资，结束交易。</p>
                                 </td>
                              </tr>
                              <tr align="left" valign="top">
                                 <td align="left" valign="top" width="35%" id="d44938e5508" headers="d44938e5336 ">
                                    <p>没有动作。</p>
                                 </td>
                                 <td align="left" valign="top" width="35%" headers="d44938e5508 d44938e5339 "><pre class="pre codeblock"><code>UPDATE员工SET薪水= 7200 WHERE last_name ='Hintz'*第1行的错误：ORA-08177：无法序列化此交易的访问权限</code></pre></td>
                                 <td align="left" valign="top" width="30%" headers="d44938e5508 d44938e5342 ">
                                    <p>结束事务3的提交导致事务4中的Hintz更新失败，并出现<code class="codeph">ORA-08177</code>错误。发生问题错误是因为事务3 <span class="italic">在</span>事务4开始<span class="italic">后</span>提交了Hintz更新。
                                    </p>
                                 </td>
                              </tr>
                              <tr align="left" valign="top">
                                 <td align="left" valign="top" width="35%" id="d44938e5524" headers="d44938e5336 ">
                                    <p>没有动作。</p>
                                 </td>
                                 <td align="left" valign="top" width="35%" headers="d44938e5524 d44938e5339 "><pre class="pre codeblock"><code>SQL&gt; ROLLBACK;</code></pre></td>
                                 <td align="left" valign="top" width="30%" headers="d44938e5524 d44938e5342 ">
                                    <p>会话2回滚事务4，结束事务。</p>
                                 </td>
                              </tr>
                              <tr align="left" valign="top">
                                 <td align="left" valign="top" width="35%" id="d44938e5534" headers="d44938e5336 ">
                                    <p>没有动作。</p>
                                 </td>
                                 <td align="left" valign="top" width="35%" headers="d44938e5534 d44938e5339 "><pre class="pre codeblock"><code>SQL&gt; SET TRANSACTION ISOLATION LEVEL SERIALIZABLE;</code></pre></td>
                                 <td align="left" valign="top" width="30%" headers="d44938e5534 d44938e5342 ">
                                    <p>会话2开始事务5并将其设置为<code class="codeph">SERIALIZABLE</code>隔离级别。
                                    </p>
                                 </td>
                              </tr>
                              <tr align="left" valign="top">
                                 <td align="left" valign="top" width="35%" id="d44938e5547" headers="d44938e5336 ">
                                    <p>没有动作。</p>
                                 </td>
                                 <td align="left" valign="top" width="35%" headers="d44938e5547 d44938e5339 "><pre class="pre codeblock"><code>SQL&gt; SELECT last_name，salary FROM employees WHERE last_name IN（'Banda'，'Greene'，'Hintz'）; LAST_NAME SALARY ------------- ---------- Banda 7000 Greene 9500 Hintz 7100</code></pre></td>
                                 <td align="left" valign="top" width="30%" headers="d44938e5547 d44938e5342 ">
                                    <p>交易5查询Banda，Greene和Hintz的工资。事务3提交的Hintz工资更新是可见的。</p>
                                 </td>
                              </tr>
                              <tr align="left" valign="top">
                                 <td align="left" valign="top" width="35%" id="d44938e5557" headers="d44938e5336 ">
                                    <p>没有动作。</p>
                                 </td>
                                 <td align="left" valign="top" width="35%" headers="d44938e5557 d44938e5339 "><pre class="pre codeblock"><code>SQL&gt; UPDATE employees SET salary = 7200 WHERE last_name ='Hintz'; 1行更新。</code></pre></td>
                                 <td align="left" valign="top" width="30%" headers="d44938e5557 d44938e5342 ">
                                    <p>事务5将Hintz薪水更新为不同的值。因为事务5在事务5开始<span class="italic">之前</span>提交了Hintz更新，所以避免了序列化访问问题。
                                    </p>
                                    <p><span class="bold">注意：</span>如果事务5开始后更新并提交了Hintz行，则会再次发生序列化访问问题。
                                    </p>
                                 </td>
                              </tr>
                              <tr align="left" valign="top">
                                 <td align="left" valign="top" width="35%" id="d44938e5574" headers="d44938e5336 ">
                                    <p>没有动作。</p>
                                 </td>
                                 <td align="left" valign="top" width="35%" headers="d44938e5574 d44938e5339 "><pre class="pre codeblock"><code>SQL&gt; COMMIT;</code></pre></td>
                                 <td align="left" valign="top" width="30%" headers="d44938e5574 d44938e5342 ">
                                    <p>会话2提交更新没有任何问题，结束了事务。</p>
                                 </td>
                              </tr>
                           </tbody>
                        </table>
                     </div>
                     <!-- class="inftblhruleinformal" -->
                     <div class="infoboxnotealso" id="GUID-8DA9A191-4CA3-4B1A-995F-4B17471C2738__GUID-8C5FA6EE-CE0D-4917-8792-222222C31B6D">
                        <p class="notep1">也可以看看：</p>
                        <ul style="list-style-type:disc">
                           <li>
                              <p><span class="q">“ <a href="data-concurrency-and-consistency.html#GUID-92D38952-A7A0-486F-9547-BDB6E624F125" title="行锁（也称为TX锁）是对单行表的锁定。事务获取由INSERT，UPDATE，DELETE，MERGE或SELECT修改的每一行的行锁...FOR UPDATE语句。行锁定存在，直到事务提交或回滚。">行锁（TX）</a> ”</span></p>
                           </li>
                           <li>
                              <p><span class="q">“ <a href="transactions.html#GUID-5BB15405-8A03-47DE-8A20-63E1B83E1361" title="事务控制是对DML语句所做的更改以及将DML语句分组到事务中的管理。">交易控制概述</a> ”</span></p>
                           </li>
                        </ul>
                     </div>
                  </div>
               </div><a id="CNCPT88969"></a><div class="props_rev_3"><a id="GUID-371C3622-540E-490C-BD83-F12CE4CF39C6" name="GUID-371C3622-540E-490C-BD83-F12CE4CF39C6"></a><h4 id="CNCPT-GUID-371C3622-540E-490C-BD83-F12CE4CF39C6" class="sect4">只读隔离级别</h4>
                  <div>
                     <p><strong class="term">只读隔离级别</strong>与可序列化隔离级别类似，但只读事务不允许在事务中修改数据，除非用户是<code class="codeph">SYS</code> 。</p>
                     <p>只读事务不受<code class="codeph">ORA-08177</code>错误的影响。只读事务对于生成内容必须与事务开始时间一致的报告非常有用。
                     </p>
                     <p>Oracle数据库通过根据需要从还原段重建数据来实现读取一致性。由于还原段以循环方式使用，因此数据库可以覆盖撤消数据。长时间运行的报告存在这样的风险：读取一致性所需的撤消数据可能已被其他事务重用，从而导致<code class="codeph">snapshot too old</code>错误。设置<a href="glossary.html#GUID-F02E3C0D-EFBF-4FAA-84B8-1BCF0BD2166A"><span class="xrefglossterm">撤消保留期</span></a> ，这是数据库在覆盖之前尝试保留旧撤消数据的最短时间，可以适当地避免此问题。
                     </p>
                     <div class="infoboxnotealso" id="GUID-371C3622-540E-490C-BD83-F12CE4CF39C6__GUID-76CDCF0B-15A2-4FF2-BDBB-1CB41220EB12">
                        <p class="notep1">也可以看看：</p>
                        <ul style="list-style-type:disc">
                           <li>
                              <p><span class="q">“ <a href="logical-storage-structures.html#GUID-6E206D3A-E0E7-4B23-9C41-516FB35BC3FE" title="Oracle数据库维护事务操作的记录，统称为撤消数据。">撤消细分</a> ”</span></p>
                           </li>
                           <li>
                              <p><a href="../admin/managing-undo.html#ADMIN11465" target="_blank"><span><cite>Oracle数据库管理员指南</cite></span></a> ，了解如何设置撤消保留期</p>
                           </li>
                        </ul>
                     </div>
                  </div>
               </div>
            </div><a id="CNCPT1331"></a><div class="props_rev_3"><a id="GUID-AD0CEE83-2F33-4906-94E1-3D1022924C63" name="GUID-AD0CEE83-2F33-4906-94E1-3D1022924C63"></a><h3 id="CNCPT-GUID-AD0CEE83-2F33-4906-94E1-3D1022924C63" class="sect3">Oracle数据库锁定机制概述</h3>
               <div>
                  <p><span class="bold">锁</span>是一种防止破坏性交互的机制。
                  </p>
                  <p>当访问共享数据的事务之间错误地更新数据或错误地更改底层数据结构时，交互是破坏性的。锁在维护数据库并发性和一致性方面起着至关重要的作用。</p>
               </div><a id="CNCPT88970"></a><div class="props_rev_3"><a id="GUID-1D60EFCC-03F4-4A04-B099-1B4DE5D02C47" name="GUID-1D60EFCC-03F4-4A04-B099-1B4DE5D02C47"></a><h4 id="CNCPT-GUID-1D60EFCC-03F4-4A04-B099-1B4DE5D02C47" class="sect4">锁定行为概述</h4>
                  <div>
                     <p>数据库维护几种不同类型的锁，具体取决于获取锁的操作。</p>
                     <p>通常，数据库使用两种类型的锁：独占锁和共享锁。在诸如行或表之类的资源上只能获得一个独占锁，但是可以在单个资源上获得许多共享锁。</p>
                     <p>锁定会影响读者和作者的互动。读者是资源的查询，而编写者是修改资源的语句。以下规则总结了Oracle数据库对读者和编写者的锁定行为：</p>
                     <ul style="list-style-type:disc">
                        <li>
                           <p>只有在编写者修改时才会锁定行。</p>
                           <p>当语句更新一行时，事务仅获取此行的锁定。通过在行级别锁定表数据，数据库可最大限度地减少对相同数据的争用。在正常情况下， <a id="fn_1" name="fn_1" href="#fn_1" data="" when="" processing="" a="" distributed="" two-phase="" commit,="" the="" database="" may="" briefly="" prevent="" read="" access="" in="" special="" circumstances.="" specifically,="" if="" query="" starts="" between="" prepare="" and="" commit="" phases="" attempts="" to="" before="" then="" escalate="" lock="" from="" row-level="" block-level="" guarantee="" consistency=")" ="" ="" onclick="footdisplay(1, "><sup>脚1</sup></a>数据库不会将行锁升级到块或表级。
                           </p>
                        </li>
                        <li>
                           <p>行的编写器阻塞同一行的并发编写器。</p>
                           <p>如果一个事务正在修改行，则行锁会阻止另一个事务同时修改同一行。</p>
                        </li>
                        <li>
                           <p>读者永远不会阻止作家。</p>
                           <p>因为一行的读者不能锁定它，所以编写者可以修改该行。唯一的例外是<code class="codeph">SELECT ...FOR UPDATE</code>语句，它是一种特殊类型的<code class="codeph">SELECT</code>语句， <span class="italic">可以</span>锁定它正在读取的行。
                           </p>
                        </li>
                        <li>
                           <p>作家永远不会阻止读者。</p>
                           <p>当编写器更改行时，数据库使用撤消数据为读者提供行的一致视图。</p>
                           <div class="infoboxnote" id="GUID-1D60EFCC-03F4-4A04-B099-1B4DE5D02C47__GUID-F42BEFC3-4611-4FAB-BDEE-582D4CAB4D00">
                              <p class="notep1">注意：</p>
                              <p>在非常特殊的待处理分布式事务中，数据的读者可能必须等待相同数据块的编写者。</p>
                           </div>
                        </li>
                     </ul>
                     <div class="infoboxnotealso" id="GUID-1D60EFCC-03F4-4A04-B099-1B4DE5D02C47__GUID-B31D6133-FA94-44D1-9F26-041CD83B84D9">
                        <p class="notep1">也可以看看：</p>
                        <ul style="list-style-type:disc">
                           <li>
                              <p><a href="../sqlrf/SELECT.html#SQLRF55370" target="_blank"><span><cite>Oracle数据库SQL语言参考</cite></span></a> ，了解<code class="codeph">SELECT ...更新</code></p>
                           </li>
                           <li>
                              <p><a href="../admin/distributed-transactions-concepts.html#ADMIN12233" target="_blank"><span><cite>Oracle数据库管理员指南</cite></span></a> ，了解与不确定的分布式事务相关的等待</p>
                           </li>
                        </ul>
                     </div>
                  </div>
               </div><a id="CNCPT88971"></a><a id="CNCPT1332"></a><div class="props_rev_3"><a id="GUID-E6FB4581-CD65-4C18-AFDD-ACB3243238D3" name="GUID-E6FB4581-CD65-4C18-AFDD-ACB3243238D3"></a><h4 id="CNCPT-GUID-E6FB4581-CD65-4C18-AFDD-ACB3243238D3" class="sect4">使用锁</h4>
                  <div>
                     <p>在单用户数据库中，不需要锁定，因为只有一个用户正在修改信息。但是，当多个用户访问和修改数据时，数据库必须提供一种防止同时修改相同数据的方法。</p>
                     <p>锁实现以下重要数据库要求：</p>
                     <ul style="list-style-type:disc">
                        <li>
                           <p>一致性</p>
                           <p>在用户完成之前，其他会话不得更改会话正在查看或更改的数据。</p>
                        </li>
                        <li>
                           <p>廉正</p>
                           <p>数据和结构必须以正确的顺序反映对它们所做的所有更改。</p>
                        </li>
                     </ul>
                     <p>Oracle数据库通过其锁定机制在事务之间提供数据并发性，一致性和完整性。锁定自动发生，无需用户操作。</p>
                     <p>锁的需要可以通过单行的并发更新来说明。在以下示例中，一个简单的基于Web的应用程序向最终用户提供员工电子邮件和电话号码。应用程序使用<code class="codeph">UPDATE</code>语句（如下所示）来修改数据：</p><pre class="pre codeblock"><code>UPDATE员工SET email = ?, phone_number =？WHERE employee_id =？和电子邮件=？AND phone_number =？
</code></pre><p>在前面的<code class="codeph">UPDATE</code>语句中， <code class="codeph">WHERE</code>子句中的电子邮件和电话号码值是指定员工的原始未修改值。此更新确保应用程序上次读取后未修改应用程序修改的行并将其显示给用户。通过这种方式，应用程序可以避免丢失更新问题，其中一个用户覆盖另一个用户所做的更改，有效地丢失了第二个用户的更新（ <a href="data-concurrency-and-consistency.html#GUID-8A15F1B2-3F64-49E7-929D-4768B2DB7DD7__CHDBBCEI" title="此表描述了当可序列化或读取已提交事务与读取已提交事务交互时，READ COMMITTED事务中的冲突写入和丢失更新。">表9-2</a>显示了更新丢失的示例）。
                     </p>
                     <p><a href="data-concurrency-and-consistency.html#GUID-E6FB4581-CD65-4C18-AFDD-ACB3243238D3__GUID-6F6A0A32-87B1-4F60-A3A4-C5EDBB157F82" title="此表显示两个会话尝试在大致相同的时间修改employees表中的同一行时的事件序列。">表9-4</a>显示了两个会话在大致相同的时间尝试修改<code class="codeph">employees</code>表中的同一行时的事件序列。
                     </p>
                     <div class="tblformalwide" id="GUID-E6FB4581-CD65-4C18-AFDD-ACB3243238D3__GUID-6F6A0A32-87B1-4F60-A3A4-C5EDBB157F82">
                        <p class="titleintable">表9-4行锁定示例</p>
                        <table cellpadding="4" cellspacing="0" class="FormalWide" title="行锁定示例" width="100%" border="1" summary="This table shows the sequence of events when two sessions attempt to modify the same row in the employees table at roughly the same time. " frame="hsides" rules="rows">
                           <thead>
                              <tr align="left" valign="top">
                                 <th align="left" valign="bottom" width="20%" id="d44938e6885">Ť</th>
                                 <th align="left" valign="bottom" width="20%" id="d44938e6887">第1节</th>
                                 <th align="left" valign="bottom" width="20%" id="d44938e6889">第二节</th>
                                 <th align="left" valign="bottom" width="20%" id="d44938e6891">描述</th>
                              </tr>
                           </thead>
                           <tbody>
                              <tr align="left" valign="top">
                                 <td align="left" valign="top" width="20%" id="d44938e6895" headers="d44938e6885 ">
                                    <p>T0</p>
                                 </td>
                                 <td align="left" valign="top" width="20%" headers="d44938e6895 d44938e6887 "><pre class="pre codeblock"><code>选择employee_id作为ID，email，phone_number FROM hr.employees WHERE last_name ='Himuro';</code></pre><pre class="pre codeblock"><code>ID EMAIL PHONE_NUMBER --- ------- ------------ 118 GHIMURO 515.127.4565</code></pre></td>
                                 <td align="left" valign="top" width="20%" headers="d44938e6895 d44938e6889 "> </td>
                                 <td align="left" valign="top" width="20%" headers="d44938e6895 d44938e6891 ">
                                    <p>在会话1中， <code class="codeph">hr1</code>用户向<code class="codeph">hr.employees</code>查询Himuro记录并显示employee_id（ <code class="codeph">118</code> ），电子邮件（ <code class="codeph">GHIMURO</code> ）和电话号码（ <code class="codeph">515.127.4565</code> ）属性。
                                    </p>
                                 </td>
                              </tr>
                              <tr align="left" valign="top">
                                 <td align="left" valign="top" width="20%" id="d44938e6923" headers="d44938e6885 ">
                                    <p>T1</p>
                                 </td>
                                 <td align="left" valign="top" width="20%" headers="d44938e6923 d44938e6887 "> </td>
                                 <td align="left" valign="top" width="20%" headers="d44938e6923 d44938e6889 "><pre class="pre codeblock"><code>选择employee_id作为ID，email，phone_number FROM hr.employees WHERE last_name ='Himuro';</code></pre><pre class="pre codeblock"><code>ID EMAIL PHONE_NUMBER --- ------- ------------ 118 GHIMURO 515.127.4565</code></pre></td>
                                 <td align="left" valign="top" width="20%" headers="d44938e6923 d44938e6891 ">
                                    <p>在会话2， <code class="codeph">hr2</code>用户查询<code class="codeph">hr.employees</code>为冰室记录并显示EMPLOYEE_ID（ <code class="codeph">118</code> ），电子邮件（ <code class="codeph">GHIMURO</code> ）和电话号码（ <code class="codeph">515.127.4565</code> ）属性。
                                    </p>
                                 </td>
                              </tr>
                              <tr align="left" valign="top">
                                 <td align="left" valign="top" width="20%" id="d44938e6951" headers="d44938e6885 ">
                                    <p>T2</p>
                                 </td>
                                 <td align="left" valign="top" width="20%" headers="d44938e6951 d44938e6887 "><pre class="pre codeblock"><code>更新hr.employees SET phone_number ='515.555.1234'WHERER employee_id = 118 AND email ='GHIMURO'AND phone_number ='515.127.4565'; 1行更新。</code></pre></td>
                                 <td align="left" valign="top" width="20%" headers="d44938e6951 d44938e6889 "> </td>
                                 <td align="left" valign="top" width="20%" headers="d44938e6951 d44938e6891 ">
                                    <p>在会话1中， <code class="codeph">hr1</code>用户将行中的电话号码更新为<code class="codeph">515.555.1234</code> ，从而获取<code class="codeph">GHIMURO</code>行的锁定。
                                    </p>
                                 </td>
                              </tr>
                              <tr align="left" valign="top">
                                 <td align="left" valign="top" width="20%" id="d44938e6971" headers="d44938e6885 ">
                                    <p>T3</p>
                                 </td>
                                 <td align="left" valign="top" width="20%" headers="d44938e6971 d44938e6887 "> </td>
                                 <td align="left" valign="top" width="20%" headers="d44938e6971 d44938e6889 "><pre class="pre codeblock"><code>更新hr.employees SET phone_number ='515.555.1235'WHERER employee_id = 118 AND email ='GHIMURO'AND phone_number ='515.127.4565'; -  SQL * Plus不显示 - 行更新消息或 - 返回提示。</code></pre></td>
                                 <td align="left" valign="top" width="20%" headers="d44938e6971 d44938e6891 ">
                                    <p>在会话2中， <code class="codeph">hr2</code>用户尝试更新同一行，但由于<code class="codeph">hr1</code>当前正在处理该行而被阻止。
                                    </p>
                                    <p><code class="codeph">hr2</code>尝试更新几乎与<code class="codeph">hr1</code>更新同时发生。
                                    </p>
                                 </td>
                              </tr>
                              <tr align="left" valign="top">
                                 <td align="left" valign="top" width="20%" id="d44938e6996" headers="d44938e6885 ">
                                    <p>T4</p>
                                 </td>
                                 <td align="left" valign="top" width="20%" headers="d44938e6996 d44938e6887 "><pre class="pre codeblock"><code>承诺;提交完成。</code></pre></td>
                                 <td align="left" valign="top" width="20%" headers="d44938e6996 d44938e6889 "> </td>
                                 <td align="left" valign="top" width="20%" headers="d44938e6996 d44938e6891 ">
                                    <p>在会话1中， <code class="codeph">hr1</code>用户提交事务。
                                    </p>
                                    <p>提交使Himuro的更改永久化并解除阻塞会话2，该会话一直在等待。</p>
                                 </td>
                              </tr>
                              <tr align="left" valign="top">
                                 <td align="left" valign="top" width="20%" id="d44938e7012" headers="d44938e6885 ">
                                    <p>T5</p>
                                 </td>
                                 <td align="left" valign="top" width="20%" headers="d44938e7012 d44938e6887 "> </td>
                                 <td align="left" valign="top" width="20%" headers="d44938e7012 d44938e6889 "><pre class="pre codeblock"><code>0行已更新。</code></pre></td>
                                 <td align="left" valign="top" width="20%" headers="d44938e7012 d44938e6891 ">
                                    <p>在会话2中， <code class="codeph">hr2</code>用户发现<code class="codeph">GHIMURO</code>行已被修改，使其不再与其谓词匹配。
                                    </p>
                                    <p>由于谓词不匹配，因此会话2不会更新任何记录。</p>
                                 </td>
                              </tr>
                              <tr align="left" valign="top">
                                 <td align="left" valign="top" width="20%" id="d44938e7031" headers="d44938e6885 ">
                                    <p>T6</p>
                                 </td>
                                 <td align="left" valign="top" width="20%" headers="d44938e7031 d44938e6887 "><pre class="pre codeblock"><code>更新hr.employees SET phone_number ='515.555.1235'WHERER employee_id = 118 AND email ='GHIMURO'和phone_number ='515.555.1234'; 1行更新。</code></pre></td>
                                 <td align="left" valign="top" width="20%" headers="d44938e7031 d44938e6889 "> </td>
                                 <td align="left" valign="top" width="20%" headers="d44938e7031 d44938e6891 ">
                                    <p>在会话1中， <code class="codeph">hr1</code>用户意识到它使用错误的电话号码更新了<code class="codeph">GHIMURO</code>行。用户启动新事务并将行中的电话号码更新为<code class="codeph">515.555.1235</code> ，这将锁定<code class="codeph">GHIMURO</code>行。
                                    </p>
                                 </td>
                              </tr>
                              <tr align="left" valign="top">
                                 <td align="left" valign="top" width="20%" id="d44938e7054" headers="d44938e6885 ">
                                    <p>T7</p>
                                 </td>
                                 <td align="left" valign="top" width="20%" headers="d44938e7054 d44938e6887 "> </td>
                                 <td align="left" valign="top" width="20%" headers="d44938e7054 d44938e6889 "><pre class="pre codeblock"><code>选择employee_id作为ID，email，phone_number FROM hr.employees WHERE last_name ='Himuro';</code></pre><pre class="pre codeblock"><code>ID EMAIL PHONE_NUMBER --- ------- ------------ 118 GHIMURO 515.555.1234</code></pre></td>
                                 <td align="left" valign="top" width="20%" headers="d44938e7054 d44938e6891 ">
                                    <p>在第二节中， <code class="codeph">hr2</code>用户查询<code class="codeph">hr.employees</code>的冰室备案。该记录显示会话1在t4时提交的电话号码更新。Oracle数据库读取一致性可确保会话2不会在t6处看到未提交的更改。
                                    </p>
                                 </td>
                              </tr>
                              <tr align="left" valign="top">
                                 <td align="left" valign="top" width="20%" id="d44938e7073" headers="d44938e6885 ">
                                    <p>T8</p>
                                 </td>
                                 <td align="left" valign="top" width="20%" headers="d44938e7073 d44938e6887 "> </td>
                                 <td align="left" valign="top" width="20%" headers="d44938e7073 d44938e6889 "><pre class="pre codeblock"><code>更新hr.employees SET phone_number ='515.555.1235 WHERE employee_id = 118 AND email ='GHIMURO'和phone_number ='515.555.1234'; -  SQL * Plus不显示 - 行更新消息或 - 返回提示。</code></pre></td>
                                 <td align="left" valign="top" width="20%" headers="d44938e7073 d44938e6891 ">
                                    <p>在会话2中， <code class="codeph">hr2</code>用户尝试更新同一行，但由于<code class="codeph">hr1</code>当前正在处理该行而被阻止。
                                    </p>
                                 </td>
                              </tr>
                              <tr align="left" valign="top">
                                 <td align="left" valign="top" width="20%" id="d44938e7090" headers="d44938e6885 ">
                                    <p>T9</p>
                                 </td>
                                 <td align="left" valign="top" width="20%" headers="d44938e7090 d44938e6887 "><pre class="pre codeblock"><code>ROLLBACK;回滚完成。</code></pre></td>
                                 <td align="left" valign="top" width="20%" headers="d44938e7090 d44938e6889 "> </td>
                                 <td align="left" valign="top" width="20%" headers="d44938e7090 d44938e6891 ">
                                    <p>在会话1中， <code class="codeph">hr1</code>用户回滚事务，结束它。
                                    </p>
                                 </td>
                              </tr>
                              <tr align="left" valign="top">
                                 <td align="left" valign="top" width="20%" id="d44938e7104" headers="d44938e6885 ">
                                    <p>T10</p>
                                 </td>
                                 <td align="left" valign="top" width="20%" headers="d44938e7104 d44938e6887 "> </td>
                                 <td align="left" valign="top" width="20%" headers="d44938e7104 d44938e6889 "><pre class="pre codeblock"><code>1行更新。</code></pre></td>
                                 <td align="left" valign="top" width="20%" headers="d44938e7104 d44938e6891 ">
                                    <p>在会话2中，电话号码的更新成功，因为会话1更新已回滚。<code class="codeph">GHIMURO</code>行与其谓词匹配，因此更新成功。
                                    </p>
                                 </td>
                              </tr>
                              <tr align="left" valign="top">
                                 <td align="left" valign="top" width="20%" id="d44938e7119" headers="d44938e6885 ">
                                    <p>T11</p>
                                 </td>
                                 <td align="left" valign="top" width="20%" headers="d44938e7119 d44938e6887 "> </td>
                                 <td align="left" valign="top" width="20%" headers="d44938e7119 d44938e6889 "><pre class="pre codeblock"><code>承诺;提交完成。</code></pre></td>
                                 <td align="left" valign="top" width="20%" headers="d44938e7119 d44938e6891 ">
                                    <p>会话2提交更新，结束事务。</p>
                                 </td>
                              </tr>
                           </tbody>
                        </table>
                     </div>
                     <!-- class="inftblhruleinformal" -->
                     <p>执行SQL语句时，Oracle数据库会自动获取必要的锁。例如，在数据库允许会话修改数据之前，会话必须首先锁定数据。锁为会话提供对数据的独占控制，以便在释放锁之前，其他任何事务都不能修改锁定的数据。</p>
                     <p>由于Oracle数据库的锁定机制与事务控制密切相关，因此应用程序设计人员只需要正确定义事务，Oracle Database就会自动管理锁定。用户永远不需要显式锁定任何资源，尽管Oracle数据库还允许用户手动锁定数据。</p>
                     <p>以下部分介绍了解Oracle数据库如何实现数据并发的重要概念。</p>
                     <div class="infoboxnotealso" id="GUID-E6FB4581-CD65-4C18-AFDD-ACB3243238D3__GUID-C8158A34-356C-486D-B831-28D7AB7374E4">
                        <p class="notep1">也可以看看：</p>
                        <p><a href="../arpls/OWA_OPT_LOCK.html#ARPLS393" target="_blank"><span><cite>Oracle Database PL / SQL包和类型参考</cite></span></a> ，了解<code class="codeph">OWA_OPT_LOCK</code>包，其中包含可帮助防止丢失更新的子程序</p>
                     </div>
                  </div>
               </div><a id="CNCPT1333"></a><div class="props_rev_3"><a id="GUID-2309ED19-A551-46DA-9E58-D957A22F9D6C" name="GUID-2309ED19-A551-46DA-9E58-D957A22F9D6C"></a><h4 id="CNCPT-GUID-2309ED19-A551-46DA-9E58-D957A22F9D6C" class="sect4">锁定模式</h4>
                  <div>
                     <p>Oracle数据库自动使用最低适用的限制级别来提供最高程度的数据并发性，同时还提供故障安全数据完整性。</p>
                     <p>级别限制越少，其他用户访问的数据越多。相反，级别越严格，其他交易在他们可以获得的锁类型中就越有限。</p>
                     <p>Oracle数据库在多用户数据库中使用两种锁定模式：</p>
                     <ul style="list-style-type:disc">
                        <li>
                           <p>独家锁定模式</p>
                           <p>此模式可防止共享关联资源。事务在修改数据时获得<a href="glossary.html#GUID-745FDB36-B218-4F25-BCB1-61D696DB8814"><span class="xrefglossterm">独占锁</span></a> 。独占锁定资源的第一个事务是唯一可以在释放独占锁之前更改资源的事务。
                           </p>
                        </li>
                        <li>
                           <p>共享锁定模式</p>
                           <p>此模式允许共享关联的资源，具体取决于所涉及的操作。读取数据的多个用户可以共享数据，每个用户都持有<a href="glossary.html#GUID-A0909390-32EF-4122-B892-659E0F04C709"><span class="xrefglossterm">共享锁，</span></a>以防止需要独占锁的编写者进行并发访问。多个事务可以获取同一资源上的共享锁。
                           </p>
                        </li>
                     </ul>
                     <p>假设一个事务使用<code class="codeph">SELECT ...FOR UPDATE</code>语句选择单个表行。该事务获取独占行锁和行共享表锁。行锁允许其他会话修改锁定行<span class="italic">以外</span>的任何行，而表锁可防止会话更改表的结构。因此，数据库允许执行尽可能多的语句。
                     </p>
                  </div>
               </div><a id="CNCPT88972"></a><div class="props_rev_3"><a id="GUID-FCE31DFC-474C-4145-9561-29344C02BB3E" name="GUID-FCE31DFC-474C-4145-9561-29344C02BB3E"></a><h4 id="CNCPT-GUID-FCE31DFC-474C-4145-9561-29344C02BB3E" class="sect4">锁定转换和升级</h4>
                  <div>
                     <p>Oracle数据库根据需要执行<span class="bold">锁定转换</span> 。
                     </p>
                     <p>在锁转换中，数据库自动将限制性较低的表锁转换为较高限制性的表锁。例如，假设一个事务发出一个<code class="codeph">SELECT ...FOR UPDATE</code>的雇员，后来更新被锁定的行。在这种情况下，数据库会自动将行共享表锁转换为行独占表锁。事务为事务中插入，更新或删除的所有行保留独占行锁。由于行锁是以最高限制性获取的，因此不需要或执行锁转换。
                     </p>
                     <p>锁转换与<a href="glossary.html#GUID-2A2BBC47-0538-40B6-8BB3-E60DAE25F32F"><span class="xrefglossterm">锁升级</span></a>不同， <a href="glossary.html#GUID-2A2BBC47-0538-40B6-8BB3-E60DAE25F32F"><span class="xrefglossterm">锁升级</span></a>是在一个粒度级别（例如，行）保持多个锁并且数据库将锁提升到更高级别的粒度（例如，表）时发生的。如果会话锁定表中的许多行，则某些数据库会自动将行锁升级为单个表。锁的数量减少，但锁定的限制性增加。
                     </p>
                     <p><span class="italic">Oracle数据库永远不会升级锁。</span> 锁定升级大大增加了死锁的可能性。假设系统正在尝试代表事务1升级锁，但由于事务2持有的锁而无法升级。如果事务2还需要锁定升级相同数据才能继续，则会创建死锁。
                     </p>
                  </div>
               </div><a id="CNCPT1334"></a><div class="props_rev_3"><a id="GUID-DB33AD91-8A4E-44CE-A6B2-654909143E5F" name="GUID-DB33AD91-8A4E-44CE-A6B2-654909143E5F"></a><h4 id="CNCPT-GUID-DB33AD91-8A4E-44CE-A6B2-654909143E5F" class="sect4">锁定持续时间</h4>
                  <div>
                     <p>当某些事件发生时，Oracle数据库会自动释放锁，以便事务不再需要该资源。</p>
                     <p>通常，数据库保存在事务期间由事务内的语句获取的锁。这些锁可防止破坏性干扰，例如脏读，丢失更新以及并发事务中的破坏性<a href="glossary.html#GUID-64F19D78-A73F-44A5-AA2E-60EBC800CB22"><span class="xrefglossterm">DDL</span></a> 。
                     </p>
                     <div class="infoboxnote" id="GUID-DB33AD91-8A4E-44CE-A6B2-654909143E5F__GUID-2D4C2BE1-A849-419D-97EA-B9CC7CD48417">
                        <p class="notep1">注意：</p>
                        <p>由于未编制索引的外键而在子表上执行的表锁在语句的持续时间内保留，而不是事务。此外， <code class="codeph">DBMS_LOCK</code>包允许随意释放和分配用户定义的锁，甚至可以在事务边界上保留。
                        </p>
                     </div>
                     <p>Oracle数据库在提交或回滚时释放事务中语句获取的所有锁。Oracle数据库还会在回滚到保存<a href="glossary.html#GUID-ED9601F2-D0A2-4FE5-83A8-8F7F9E9E0D18"><span class="xrefglossterm">点</span></a>时释放<a href="glossary.html#GUID-ED9601F2-D0A2-4FE5-83A8-8F7F9E9E0D18"><span class="xrefglossterm">保存点</span></a>后获取的锁。但是，只有不等待先前锁定资源的事务才能获取现有资源上的锁。等待事务继续等待，直到原始事务提交或完全回滚。
                     </p>
                     <div class="infoboxnotealso" id="GUID-DB33AD91-8A4E-44CE-A6B2-654909143E5F__GUID-B58118DD-8FDC-4C9A-A209-77AE87141FFA">
                        <p class="notep1">也可以看看：</p>
                        <ul style="list-style-type:disc">
                           <li>
                              <p><span class="q">“ <a href="transactions.html#GUID-07517D95-D5F9-4851-B737-B076336CED13__CHDGIIFB" title="此表显示了一个展示回滚到保存点的扩展示例。">表10-3</a> ”</span>显示了事务等待行为</p>
                           </li>
                           <li>
                              <p><span class="q">“ <a href="data-concurrency-and-consistency.html#GUID-D63FD030-44CD-4FD7-970A-C98C8CC4AC42" title="使用Oracle数据库锁管理服务，您可以为特定应用程序定义自己的锁。">用户定义锁概述</a> ”</span>以了解有关<code class="codeph">DBMS_LOCK</code>更多信息</p>
                           </li>
                        </ul>
                     </div>
                  </div>
               </div><a id="CNCPT88973"></a><a id="CNCPT1336"></a><div class="props_rev_3"><a id="GUID-C1971E9B-849A-4634-9575-4F8FAD697750" name="GUID-C1971E9B-849A-4634-9575-4F8FAD697750"></a><h4 id="CNCPT-GUID-C1971E9B-849A-4634-9575-4F8FAD697750" class="sect4">锁和死锁</h4>
                  <div>
                     <p><strong class="term">死锁</strong>是指两个或更多用户正在等待彼此锁定的数据的情况。死锁会阻止某些事务继续工作。
                     </p>
                     <p>Oracle数据库自动检测死锁并通过回滚死锁中涉及的一个语句来解决它们，从而释放一组冲突的行锁。数据库将相应的消息返回到进行<a href="glossary.html#GUID-187EACC0-1FDD-498A-BEAD-892AC03B50D0"><span class="xrefglossterm">语句级回滚</span></a>的事务。回滚的语句属于检测死锁的事务。通常，显式事务应该显式回滚，但它可以在等待后重试回滚语句。
                     </p>
                     <p><a href="data-concurrency-and-consistency.html#GUID-C1971E9B-849A-4634-9575-4F8FAD697750__BABICGEE" title="此表说明了Oracle数据库如何处理两个死锁事务。">表9-5</a>说明了死锁中的两个事务。
                     </p>
                     <div class="tblformalwide" id="GUID-C1971E9B-849A-4634-9575-4F8FAD697750__BABICGEE">
                        <p class="titleintable">表9-5死锁事务</p>
                        <table cellpadding="4" cellspacing="0" class="FormalWide" title="死锁交易" width="100%" border="1" summary="This table illustrates how Oracle Database handles two deadlocked transactions. " frame="hsides" rules="rows">
                           <thead>
                              <tr align="left" valign="top">
                                 <th align="left" valign="bottom" id="d44938e8381">Ť</th>
                                 <th align="left" valign="bottom" id="d44938e8384">第1节</th>
                                 <th align="left" valign="bottom" id="d44938e8387">第二节</th>
                                 <th align="left" valign="bottom" id="d44938e8390">说明</th>
                              </tr>
                           </thead>
                           <tbody>
                              <tr align="left" valign="top">
                                 <td align="left" valign="top" id="d44938e8395" headers="d44938e8381 ">
                                    <p>T0</p>
                                 </td>
                                 <td align="left" valign="top" headers="d44938e8395 d44938e8384 "><pre class="pre codeblock"><code>SQL&gt; UPDATE employees SET salary = salary * 1.1 WHERE employee_id = 100; 1行更新。</code></pre></td>
                                 <td align="left" valign="top" headers="d44938e8395 d44938e8387 "><pre class="pre codeblock"><code>SQL&gt; UPDATE employees SET salary = salary * 1.1 WHERE employee_id = 200; 1行更新。</code></pre></td>
                                 <td align="left" valign="top" headers="d44938e8395 d44938e8390 ">
                                    <p>会话1启动事务1并更新员工100的工资。会话2启动事务2并更新员工200的工资。没有问题，因为每个事务仅锁定它尝试更新的行。</p>
                                 </td>
                              </tr>
                              <tr align="left" valign="top">
                                 <td align="left" valign="top" id="d44938e8408" headers="d44938e8381 ">
                                    <p>T1</p>
                                 </td>
                                 <td align="left" valign="top" headers="d44938e8408 d44938e8384 "><pre class="pre codeblock"><code>SQL&gt; UPDATE employees SET salary = salary * 1.1 WHERE employee_id = 200; - 提示不返回</code></pre></td>
                                 <td align="left" valign="top" headers="d44938e8408 d44938e8387 "><pre class="pre codeblock"><code>SQL&gt; UPDATE employees SET salary = salary * 1.1 WHERE employee_id = 100; - 提示不返回</code></pre></td>
                                 <td align="left" valign="top" headers="d44938e8408 d44938e8390 ">
                                    <p>事务1尝试更新当前由事务2锁定的员工200行。事务2尝试更新当前由事务1锁定的员工100行。</p>
                                    <p>导致死锁，因为事务都不能获得继续或终止所需的资源。无论每个事务等待多长时间，都会保持冲突的锁定。</p>
                                 </td>
                              </tr>
                              <tr align="left" valign="top">
                                 <td align="left" valign="top" id="d44938e8423" headers="d44938e8381 ">
                                    <p>T2</p>
                                 </td>
                                 <td align="left" valign="top" headers="d44938e8423 d44938e8384 "><pre class="pre codeblock"><code>UPDATE employees *第1行的错误：ORA-00060：在等待资源SQL时检测到死锁&gt;</code></pre></td>
                                 <td align="left" valign="top" headers="d44938e8423 d44938e8387 "> </td>
                                 <td align="left" valign="top" headers="d44938e8423 d44938e8390 ">
                                    <p>事务1表示死锁并回滚在t1发出的<code class="codeph">UPDATE</code>语句。但是，在t0进行的更新不会回滚。会话1中返回提示。
                                    </p>
                                    <p><span class="bold">注意：</span>死锁中只有一个会话实际上会出现死锁错误，但任一会话都可能出错。
                                    </p>
                                 </td>
                              </tr>
                              <tr align="left" valign="top">
                                 <td align="left" valign="top" id="d44938e8441" headers="d44938e8381 ">
                                    <p>T3</p>
                                 </td>
                                 <td align="left" valign="top" headers="d44938e8441 d44938e8384 "><pre class="pre codeblock"><code>SQL&gt; COMMIT;提交完成。</code></pre></td>
                                 <td align="left" valign="top" headers="d44938e8441 d44938e8387 "> </td>
                                 <td align="left" valign="top" headers="d44938e8441 d44938e8390 ">
                                    <p>会话1提交在t0进行的更新，结束事务1。未提交在t1尝试失败的更新。</p>
                                 </td>
                              </tr>
                              <tr align="left" valign="top">
                                 <td align="left" valign="top" id="d44938e8452" headers="d44938e8381 ">
                                    <p>T4</p>
                                 </td>
                                 <td align="left" valign="top" headers="d44938e8452 d44938e8384 "> </td>
                                 <td align="left" valign="top" headers="d44938e8452 d44938e8387 "><pre class="pre codeblock"><code>1行更新。SQL&gt;</code></pre></td>
                                 <td align="left" valign="top" headers="d44938e8452 d44938e8390 ">
                                    <p>执行事务2中t1的更新，该事务被事务1阻止。提示返回。</p>
                                 </td>
                              </tr>
                              <tr align="left" valign="top">
                                 <td align="left" valign="top" id="d44938e8463" headers="d44938e8381 ">
                                    <p>T5</p>
                                 </td>
                                 <td align="left" valign="top" headers="d44938e8463 d44938e8384 "> </td>
                                 <td align="left" valign="top" headers="d44938e8463 d44938e8387 "><pre class="pre codeblock"><code>SQL&gt; COMMIT;提交完成。</code></pre></td>
                                 <td align="left" valign="top" headers="d44938e8463 d44938e8390 ">
                                    <p>会话2提交在t0和t1进行的更新，结束事务2。</p>
                                 </td>
                              </tr>
                           </tbody>
                        </table>
                     </div>
                     <!-- class="inftblhruleinformal" -->
                     <p>当事务显式覆盖Oracle数据库的默认锁定时，通常会发生死锁。由于Oracle数据库不会升级锁并且不对查询使用读锁，但确实使用行级（而不是页级）锁定，因此很少发生死锁。</p>
                     <div class="infoboxnotealso" id="GUID-C1971E9B-849A-4634-9575-4F8FAD697750__GUID-28BD423C-5E44-44E2-AA84-ECC36C4B2D1B">
                        <p class="notep1">也可以看看：</p>
                        <ul style="list-style-type:disc">
                           <li>
                              <p><span class="q">“ <a href="data-concurrency-and-consistency.html#GUID-A4E54CD6-7232-489D-86A4-412EAF8A8DB7" title="您可以手动覆盖Oracle数据库的默认锁定机制。">手动数据锁概述</a> ”</span></p>
                           </li>
                           <li>
                              <p><a href="../adfns/sql-processing-for-application-developers.html#ADFNS00203" target="_blank"><span><cite>Oracle数据库开发指南</cite></span></a> ，了解如何在显式锁定表时处理死锁</p>
                           </li>
                        </ul>
                     </div>
                  </div>
               </div>
            </div><a id="CNCPT1339"></a><div class="props_rev_3"><a id="GUID-E926E638-0161-4389-887B-4A31A529478A" name="GUID-E926E638-0161-4389-887B-4A31A529478A"></a><h3 id="CNCPT-GUID-E926E638-0161-4389-887B-4A31A529478A" class="sect3">自动锁概述</h3>
               <div>
                  <p>Oracle数据库代表事务自动锁定资源，以防止其他事务执行需要独占访问同一资源的事务。</p>
                  <p>数据库根据资源和正在执行的操作自动获取不同级别的限制性的不同类型的锁。</p>
                  <div class="infoboxnote" id="GUID-E926E638-0161-4389-887B-4A31A529478A__GUID-234DEE05-05D8-47C5-929E-49A2C855FA3F">
                     <p class="notep1">注意：</p>
                     <p>执行简单读取时，数据库永远不会锁定行。</p>
                  </div>
                  <p>Oracle数据库锁分为下表中显示的类别。</p>
                  <div class="tblformal" id="GUID-E926E638-0161-4389-887B-4A31A529478A__GUID-8097ADA6-419F-4E1F-BFEA-C7E2AD8BF1FE">
                     <p class="titleintable">表9-6锁定类别</p>
                     <table cellpadding="4" cellspacing="0" class="Formal" title="锁定类别" width="100%" border="1" summary="The table shows Oracle Database lock categories." frame="hsides" rules="rows">
                        <thead>
                           <tr align="left" valign="top">
                              <th align="left" valign="bottom" width="23%" id="d44938e8791">锁</th>
                              <th align="left" valign="bottom" width="45%" id="d44938e8794">描述</th>
                              <th align="left" valign="bottom" width="33%" id="d44938e8797">了解更多</th>
                           </tr>
                        </thead>
                        <tbody>
                           <tr align="left" valign="top">
                              <td align="left" valign="top" width="23%" id="d44938e8802" headers="d44938e8791 ">
                                 <p>DML锁定</p>
                              </td>
                              <td align="left" valign="top" width="45%" headers="d44938e8802 d44938e8794 ">
                                 <p>保护数据。例如，表锁锁定整个表，而行锁锁定选定的行。</p>
                              </td>
                              <td align="left" valign="top" width="33%" headers="d44938e8802 d44938e8797 ">
                                 <p><span class="q">“ <a href="data-concurrency-and-consistency.html#GUID-6D4F7A79-A5F1-470A-ADEF-8888565DE84F" title="DML锁定（也称为数据锁定）可确保多个用户同时访问的数据的完整性。">DML锁定</a> ”</span></p>
                              </td>
                           </tr>
                           <tr align="left" valign="top">
                              <td align="left" valign="top" width="23%" id="d44938e8823" headers="d44938e8791 ">
                                 <p>DDL锁定</p>
                              </td>
                              <td align="left" valign="top" width="45%" headers="d44938e8823 d44938e8794 ">
                                 <p>保护架构对象的结构 - 例如，表和视图的字典定义。</p>
                              </td>
                              <td align="left" valign="top" width="33%" headers="d44938e8823 d44938e8797 ">
                                 <p> <span class="q">“ <a href="data-concurrency-and-consistency.html#GUID-5015CC53-4059-4CD6-B892-F211E8BDE2F9" title="当正在进行的DDL操作作用于或引用该对象时，数据字典（DDL）锁保护模式对象的定义。">DDL锁定</a> ”</span></p>
                              </td>
                           </tr>
                           <tr align="left" valign="top">
                              <td align="left" valign="top" width="23%" id="d44938e8842" headers="d44938e8791 ">
                                 <p>系统锁定</p>
                              </td>
                              <td align="left" valign="top" width="45%" headers="d44938e8842 d44938e8794 ">
                                 <p>保护内部数据库结构，例如数据文件。闩锁，互锁和内部锁是完全自动的。</p>
                              </td>
                              <td align="left" valign="top" width="33%" headers="d44938e8842 d44938e8797 ">
                                 <p><span class="q">“ <a href="data-concurrency-and-consistency.html#GUID-19E6C804-8D75-4D05-ACD2-11915687307A" title="Oracle数据库使用各种类型的系统锁来保护内部数据库和内存结构。用户无法访问这些机制，因为用户无法控制其发生或持续时间。">系统锁定</a> ”</span></p>
                              </td>
                           </tr>
                        </tbody>
                     </table>
                  </div>
                  <!-- class="inftblhruleinformal" -->
               </div><a id="CNCPT1340"></a><div class="props_rev_3"><a id="GUID-6D4F7A79-A5F1-470A-ADEF-8888565DE84F" name="GUID-6D4F7A79-A5F1-470A-ADEF-8888565DE84F"></a><h4 id="CNCPT-GUID-6D4F7A79-A5F1-470A-ADEF-8888565DE84F" class="sect4">DML锁定</h4>
                  <div>
                     <p><span class="bold">DML锁定</span> （也称为<span class="italic">数据锁定</span> ）可确保多个用户同时访问的数据的完整性。
                     </p>
                     <p>例如，DML锁定可防止两个客户购买在线书商提供的书籍的最后一个副本。DML锁可防止同时冲突的DML或DDL操作的破坏性干扰。</p>
                     <p>DML语句自动获取以下类型的锁：</p>
                     <ul style="list-style-type:disc">
                        <li>
                           <p><a href="data-concurrency-and-consistency.html#GUID-92D38952-A7A0-486F-9547-BDB6E624F125" title="行锁（也称为TX锁）是对单行表的锁定。事务获取由INSERT，UPDATE，DELETE，MERGE或SELECT修改的每一行的行锁...FOR UPDATE语句。行锁定存在，直到事务提交或回滚。">行锁（TX）</a></p>
                        </li>
                        <li>
                           <p><a href="data-concurrency-and-consistency.html#GUID-B6B075B7-DE83-45EF-8A9E-1C1F71F72598" title="当通过INSERT，UPDATE，DELETE，MERGE，SELECT和FOR UPDATE子句或LOCK TABLE语句修改表时，事务获取表锁（也称为TM锁）。">表锁（TM）</a></p>
                        </li>
                     </ul>
                     <p>在以下部分中，每种类型的锁定或锁定模式后括号中的首字母缩写词是Oracle Enterprise Manager（企业管理器）的锁定监视器中使用的缩写。企业管理器可能会为任何表锁定显示TM，而不是指示表锁定的模式（例如RS或SRX）。</p>
                     <div class="infoboxnotealso" id="GUID-6D4F7A79-A5F1-470A-ADEF-8888565DE84F__GUID-112F720A-8A89-459B-ACC6-1DD58809018A">
                        <p class="notep1">也可以看看：</p>
                        <p><span class="q">“ <a href="concepts-for-database-administrators.html#GUID-BE08A8FA-501A-418E-AD32-3E42AE762026" title="Oracle Enterprise Manager（企业管理器）是一个基于Web的系统管理工具，可以管理Oracle数据库，Exadata数据库计算机，融合中间件，Oracle应用程序，服务器，存储以及非Oracle硬件和软件。">Oracle企业管理器</a> ”</span></p>
                     </div>
                  </div><a id="CNCPT88974"></a><a id="CNCPT1341"></a><div class="props_rev_3"><a id="GUID-92D38952-A7A0-486F-9547-BDB6E624F125" name="GUID-92D38952-A7A0-486F-9547-BDB6E624F125"></a><h5 id="CNCPT-GUID-92D38952-A7A0-486F-9547-BDB6E624F125" class="sect5">行锁（TX）</h5>
                     <div>
                        <p><span class="bold">行锁</span> （也称为<span class="italic">TX锁</span> ）是对单行表的锁定。事务获取由<code class="codeph">INSERT</code> ， <code class="codeph">UPDATE</code> ， <code class="codeph">DELETE</code> ， <code class="codeph">MERGE</code>或<code class="codeph">SELECT</code>修改的每一行的行锁<code class="codeph">...FOR</code> <code class="codeph">UPDATE</code>语句。行锁定存在，直到事务提交或回滚。
                        </p>
                        <p>行锁主要用作排队机制，以防止两个事务修改同一行。数据库始终以独占模式锁定已修改的行，以便其他事务无法修改该行，直到持有锁的事务提交或回滚为止。行锁定可提供最精细的粒度锁定，因此可提供最佳的并发性和吞吐量。</p>
                        <div class="infoboxnote" id="GUID-92D38952-A7A0-486F-9547-BDB6E624F125__GUID-F52FBD3B-821F-415B-B2E2-D7C45EB3456D">
                           <p class="notep1">注意：</p>
                           <p>如果事务因数据库<a href="glossary.html#GUID-A3F6C6D9-6351-4886-BA47-5BD688AECA4B"><span class="xrefglossterm">实例故障而</span></a>终止，则块级恢复会在恢复整个事务之前使行可用。
                           </p>
                        </div>
                        <p>如果事务获得行的锁定，则事务还会获取包含该行的表的锁定。表锁可防止冲突的DDL操作，这些操作将覆盖当前事务中的数据更改。<a href="data-concurrency-and-consistency.html#GUID-92D38952-A7A0-486F-9547-BDB6E624F125__BABJHGCE">图9-2</a>说明了表中第三行的更新。Oracle数据库自动在更新的行上放置一个独占锁，并在表上放置一个子外置锁。
                        </p>
                        <div class="figure" id="GUID-92D38952-A7A0-486F-9547-BDB6E624F125__BABJHGCE">
                           <p class="titleinfigure">图9-2行和表锁</p><img src="img/cncpt265.gif" width="592" alt="下面是图9-2的描述" title="下面是图9-2的描述" longdesc="img_text/cncpt265.html"><br><a href="img_text/cncpt265.html">“图9-2行和表锁”的说明</a></div>
                        <!-- class="figure" -->
                     </div><a id="CNCPT88976"></a><a id="CNCPT88975"></a><div class="props_rev_3"><a id="GUID-6665D14A-D186-4BA8-A277-A3B8237FA57B" name="GUID-6665D14A-D186-4BA8-A277-A3B8237FA57B"></a><h6 id="CNCPT-GUID-6665D14A-D186-4BA8-A277-A3B8237FA57B" class="sect6">行锁和并发</h6>
                        <div>
                           <p>此方案说明了Oracle数据库如何使用行锁进行并发。</p>
                           <p>三个会话同时查询相同的行。会话1和2继续对不同的行进行未提交的更新，而会话3不进行更新。每个会话都会看到自己未提交的更新，但不会看到任何其他会话的未提交更新。</p>
                           <div class="tblformalwide" id="GUID-6665D14A-D186-4BA8-A277-A3B8237FA57B__BABGHCDD">
                              <p class="titleintable">表9-7数据并发示例</p>
                              <table cellpadding="4" cellspacing="0" class="FormalWide" title="数据并发示例" width="100%" border="1" summary="This table shows an example of three concurrent transactions and how Oracle Database uses row locks for concurrency." frame="hsides" rules="rows">
                                 <thead>
                                    <tr align="left" valign="top">
                                       <th align="left" valign="bottom" width="4%" id="d44938e9849">Ť</th>
                                       <th align="left" valign="bottom" width="25%" id="d44938e9852">第1节</th>
                                       <th align="left" valign="bottom" width="25%" id="d44938e9855">第二节</th>
                                       <th align="left" valign="bottom" width="24%" id="d44938e9858">第3节</th>
                                       <th align="left" valign="bottom" width="22%" id="d44938e9861">说明</th>
                                    </tr>
                                 </thead>
                                 <tbody>
                                    <tr align="left" valign="top">
                                       <td align="left" valign="top" width="4%" id="d44938e9866" headers="d44938e9849 ">
                                          <p>T0</p>
                                       </td>
                                       <td align="left" valign="top" width="25%" headers="d44938e9866 d44938e9852 "><pre class="pre codeblock"><code>SELECT employee_id，salary FROM employees WHERE employee_id IN（100,101）;</code></pre><pre class="pre codeblock"><code>EMPLOYEE_ID SALARY ----------- ------ 100 512 101 600</code></pre></td>
                                       <td align="left" valign="top" width="25%" headers="d44938e9866 d44938e9855 "><pre class="pre codeblock"><code>SELECT employee_id，salary FROM employees WHERE employee_id IN（100,101）;</code></pre><pre class="pre codeblock"><code>EMPLOYEE_ID SALARY ----------- ------ 100 512 101 600</code></pre></td>
                                       <td align="left" valign="top" width="24%" headers="d44938e9866 d44938e9858 "><pre class="pre codeblock"><code>SELECT employee_id，salary FROM employees WHERE employee_id IN（100,101）;</code></pre><pre class="pre codeblock"><code>EMPLOYEE_ID SALARY ----------- ------ 100 512 101 600</code></pre></td>
                                       <td align="left" valign="top" width="22%" headers="d44938e9866 d44938e9861 ">
                                          <p>三个不同的会话同时查询员工100和101的ID和薪水。每个查询返回的结果都是相同的。</p>
                                       </td>
                                    </tr>
                                    <tr align="left" valign="top">
                                       <td align="left" valign="top" width="4%" id="d44938e9888" headers="d44938e9849 ">
                                          <p>T1</p>
                                       </td>
                                       <td align="left" valign="top" width="25%" headers="d44938e9888 d44938e9852 "><pre class="pre codeblock"><code>UPDATE hr.employees SET salary = salary + 100 WHERE employee_id = 100;</code></pre></td>
                                       <td align="left" valign="top" width="25%" headers="d44938e9888 d44938e9855 "> </td>
                                       <td align="left" valign="top" width="24%" headers="d44938e9888 d44938e9858 "> </td>
                                       <td align="left" valign="top" width="22%" headers="d44938e9888 d44938e9861 ">
                                          <p>会话1更新员工100的薪水，但不提交。在更新中，编写器仅为更新的行获取行级锁定，从而阻止其他编写者修改此行。</p>
                                       </td>
                                    </tr>
                                    <tr align="left" valign="top">
                                       <td align="left" valign="top" width="4%" id="d44938e9900" headers="d44938e9849 ">
                                          <p>T2</p>
                                       </td>
                                       <td align="left" valign="top" width="25%" headers="d44938e9900 d44938e9852 "><pre class="pre codeblock"><code>SELECT employee_id，salary FROM employees WHERE employee_id IN（100,101）;</code></pre><pre class="pre codeblock"><code>EMPLOYEE_ID SALARY ----------- ------ 100 <span class="bold">612</span> 101 600</code></pre></td>
                                       <td align="left" valign="top" width="25%" headers="d44938e9900 d44938e9855 "><pre class="pre codeblock"><code>SELECT employee_id，salary FROM employees WHERE employee_id IN（100,101）;</code></pre><pre class="pre codeblock"><code>EMPLOYEE_ID SALARY ----------- ------ 100 512 101 600</code></pre></td>
                                       <td align="left" valign="top" width="24%" headers="d44938e9900 d44938e9858 "><pre class="pre codeblock"><code>SELECT employee_id，salary FROM employees WHERE employee_id IN（100,101）;</code></pre><pre class="pre codeblock"><code>EMPLOYEE_ID SALARY ----------- ------ 100 512 101 600</code></pre></td>
                                       <td align="left" valign="top" width="22%" headers="d44938e9900 d44938e9861 ">
                                          <p>每个会话同时发出原始查询。第1节显示了t1更新产生的612的工资。会话2和3中的读者立即返回行，不等待会话1结束其事务。数据库使用多版本读取一致性来显示在会话1中更新之前存在的工资。</p>
                                       </td>
                                    </tr>
                                    <tr align="left" valign="top">
                                       <td align="left" valign="top" width="4%" id="d44938e9925" headers="d44938e9849 ">
                                          <p>T3</p>
                                       </td>
                                       <td align="left" valign="top" width="25%" headers="d44938e9925 d44938e9852 "> </td>
                                       <td align="left" valign="top" width="25%" headers="d44938e9925 d44938e9855 "><pre class="pre codeblock"><code>UPDATE hr.employee SET salary = salary + 100 WHERE employee_id = 101;</code></pre></td>
                                       <td align="left" valign="top" width="24%" headers="d44938e9925 d44938e9858 "> </td>
                                       <td align="left" valign="top" width="22%" headers="d44938e9925 d44938e9861 ">
                                          <p>会话2更新员工101的薪水，但不提交交易。在更新中，writer仅为更新的行获取行级锁定，从而阻止其他编写者修改此行。</p>
                                       </td>
                                    </tr>
                                    <tr align="left" valign="top">
                                       <td align="left" valign="top" width="4%" id="d44938e9937" headers="d44938e9849 ">
                                          <p>T4</p>
                                       </td>
                                       <td align="left" valign="top" width="25%" headers="d44938e9937 d44938e9852 "><pre class="pre codeblock"><code>SELECT employee_id，salary FROM employees WHERE employee_id IN（100,101）;</code></pre><pre class="pre codeblock"><code>EMPLOYEE_ID SALARY ----------- ------ 100 <span class="bold">612</span> 101 600</code></pre></td>
                                       <td align="left" valign="top" width="25%" headers="d44938e9937 d44938e9855 "><pre class="pre codeblock"><code>SELECT employee_id，salary FROM employees WHERE employee_id IN（100,101）;</code></pre><pre class="pre codeblock"><code>EMPLOYEE_ID SALARY ----------- ------ 100 512 101 <span class="bold">700</span></code></pre></td>
                                       <td align="left" valign="top" width="24%" headers="d44938e9937 d44938e9858 "><pre class="pre codeblock"><code>SELECT employee_id，salary FROM employees WHERE employee_id IN（100,101）;</code></pre><pre class="pre codeblock"><code>EMPLOYEE_ID SALARY ----------- ------ 100 512 101 600</code></pre></td>
                                       <td align="left" valign="top" width="22%" headers="d44938e9937 d44938e9861 ">
                                          <p>每个会话同时发出原始查询。会话1显示了由t1更新产生的612的工资，但没有显示在会话2中产生的员工101的工资更新。会话2中的读者显示了在会话2中进行的工资更新，但没有显示在会话1中进行的工资更新。会话3中的读者使用读取一致性来显示会话1和2修改之前的工资。</p>
                                       </td>
                                    </tr>
                                 </tbody>
                              </table>
                           </div>
                           <!-- class="inftblhruleinformal" -->
                           <div class="infoboxnotealso" id="GUID-6665D14A-D186-4BA8-A277-A3B8237FA57B__GUID-1A5A9D57-3A1F-40A4-AB2B-239DF75B977B">
                              <p class="notep1">也可以看看：</p>
                              <ul style="list-style-type:disc">
                                 <li>
                                    <p><a href="../sqlrf/Automatic-Locks-in-DML-Operations.html#SQLRF55505" target="_blank"><span><cite>Oracle数据库SQL语言参考</cite></span></a></p>
                                 </li>
                                 <li>
                                    <p><a href="../refrn/V-LOCK.html#REFRN30121" target="_blank"><span><cite>Oracle数据库参考</cite></span></a>了解<code class="codeph">V$LOCK</code></p>
                                 </li>
                              </ul>
                           </div>
                        </div>
                     </div><a id="CNCPT88977"></a><div class="props_rev_3"><a id="GUID-B6E414BE-B880-40F6-B353-F996208B8D0A" name="GUID-B6E414BE-B880-40F6-B353-F996208B8D0A"></a><h6 id="CNCPT-GUID-B6E414BE-B880-40F6-B353-F996208B8D0A" class="sect6">存储行锁</h6>
                        <div>
                           <p>与使用锁管理器维护内存中的锁列表的某些数据库不同，Oracle数据库将锁信息存储在包含锁定行的数据块中。</p>
                           <p>数据库使用排队机制来获取行锁。如果事务需要锁定未锁定的行，则事务会在数据块中设置锁定。此事务修改的每一行都指向存储在<a href="glossary.html#GUID-78394D5D-A1F6-4978-8F13-028185F514B5"><span class="xrefglossterm">块头</span></a>中的事务ID的副本。
                           </p>
                           <p>当事务结束时，事务ID保留在块头中。如果其他事务要修改行，则它使用事务ID来确定锁是否处于活动状态。如果锁定处于活动状态，则会话会在锁定释放时要求通知。否则，事务获取锁。</p>
                           <div class="infoboxnotealso" id="GUID-B6E414BE-B880-40F6-B353-F996208B8D0A__GUID-5D29B64C-C0AD-4667-A0D0-07BA32EA741B">
                              <p class="notep1">也可以看看：</p>
                              <ul style="list-style-type:disc">
                                 <li>
                                    <p><span class="q">“ <a href="logical-storage-structures.html#GUID-1AED5140-E820-436C-BEB7-2A985524911E" title="Oracle数据库在称为数据块（也称为Oracle块或页面）的单元中管理数据库的数据文件中的逻辑存储空间。数据块是数据库I / O的最小单位。">数据块概述</a> ”</span>以了解有关数据块头的更多信息</p>
                                 </li>
                                 <li>
                                    <p><a href="../refrn/V-TRANSACTION.html#REFRN30291" target="_blank"><span><cite>Oracle Database Reference</cite></span></a>了解<code class="codeph">V$TRANSACTION</code></p>
                                 </li>
                              </ul>
                           </div>
                        </div>
                     </div>
                  </div><a id="CNCPT1342"></a><div class="props_rev_3"><a id="GUID-B6B075B7-DE83-45EF-8A9E-1C1F71F72598" name="GUID-B6B075B7-DE83-45EF-8A9E-1C1F71F72598"></a><h5 id="CNCPT-GUID-B6B075B7-DE83-45EF-8A9E-1C1F71F72598" class="sect5">表锁（TM）</h5>
                     <div>
                        <p>当通过<code class="codeph">INSERT</code> ， <code class="codeph">UPDATE</code> ， <code class="codeph">DELETE</code> ， <code class="codeph">MERGE</code> ， <code class="codeph">SELECT</code>和<code class="codeph">FOR UPDATE</code>子句或<code class="codeph">LOCK TABLE</code>语句修改表时，事务获取<strong class="term">表锁</strong> （也称为<span class="italic">TM锁）</span> 。
                        </p>
                        <p>DML操作需要表锁来代表事务保留对表的DML访问，并防止与事务冲突的DDL操作。</p>
                        <p>表锁可以采用以下任何一种模式进行保存：</p>
                        <ul style="list-style-type:disc">
                           <li>
                              <p>行共享（RS）</p>
                              <p>此锁定（也称为子<span class="italic">共享表锁定（SS））</span>指示持有<span class="italic">表锁定</span>的事务已锁定表中的行并打算更新它们。行共享锁是表锁的最少限制模式，为表提供最高程度的并发性。
                              </p>
                           </li>
                           <li>
                              <p>行专用表锁（RX）</p>
                              <p>此锁也称为<span class="italic">子查询表锁（SX）</span> ，通常表示持有锁的事务已更新表行或发出<code class="codeph">SELECT ...FOR UPDATE</code> 。 SX锁允许其他事务在同一个表中同时查询，插入，更新，删除或锁定行。因此，SX锁允许多个事务为同一个表获取同时的SX和子共享表锁。
                              </p>
                           </li>
                           <li>
                              <p>分享桌锁（S）</p>
                              <p>事务持有的共享表锁允许其他事务查询表（不使用<code class="codeph">SELECT ...FOR UPDATE</code> ），但仅当单个事务持有共享表锁时才允许更新。由于多个事务可能同时持有共享表锁，因此保持此锁定不足以确保事务可以修改表。
                              </p>
                           </li>
                           <li>
                              <p>分享行独家表锁（SRX）</p>
                              <p>此锁定（也称为<span class="italic">共享 - 子系统表锁定（SSX））</span>比共享表锁定更具限制性。一次只有一个事务可以获取给定表上的SSX锁。事务持有的SSX锁允许其他事务查询表（ <code class="codeph">SELECT ...除外）FOR UPDATE</code> ）但不更新表。
                              </p>
                           </li>
                           <li>
                              <p>独家桌锁（X）</p>
                              <p>此锁是最严格的，禁止其他事务执行任何类型的DML语句或在表上放置任何类型的锁。</p>
                           </li>
                        </ul>
                        <div class="infoboxnotealso" id="GUID-B6B075B7-DE83-45EF-8A9E-1C1F71F72598__GUID-F5FBFF40-0F2B-49AA-9985-CB597EAABA2B">
                           <p class="notep1">也可以看看：</p>
                           <ul style="list-style-type:disc">
                              <li>
                                 <p><a href="../sqlrf/Automatic-Locks-in-DML-Operations.html#SQLRF55504" target="_blank"><span><cite>Oracle数据库SQL语言参考</cite></span></a></p>
                              </li>
                              <li>
                                 <p><a href="../adfns/sql-processing-for-application-developers.html#ADFNS007" target="_blank"><span><cite>Oracle数据库开发指南</cite></span></a> ，了解有关表锁的更多信息</p>
                              </li>
                           </ul>
                        </div>
                     </div>
                  </div><a id="CNCPT88978"></a><div class="props_rev_3"><a id="GUID-261F98F8-F7B4-49A9-9BE8-11F2B1F4609B" name="GUID-261F98F8-F7B4-49A9-9BE8-11F2B1F4609B"></a><h5 id="CNCPT-GUID-261F98F8-F7B4-49A9-9BE8-11F2B1F4609B" class="sect5">锁和外键</h5>
                     <div>
                        <p>Oracle数据库最大化了与依赖外键相关的父键的并发控制。</p>
                        <p>锁定行为取决于是否对外键列进行索引。如果未对外键进行索引，则子表可能会更频繁地被锁定，将发生死锁，并且会降低并发性。因此，外键几乎总是要编入索引。唯一的例外是永远不会更新或删除匹配的唯一键或主键。</p>
                     </div><a id="CNCPT88980"></a><a id="CNCPT88979"></a><div class="props_rev_3"><a id="GUID-0D5DA0E0-28DF-498A-B2E5-B9207AC2BAE6" name="GUID-0D5DA0E0-28DF-498A-B2E5-B9207AC2BAE6"></a><h6 id="CNCPT-GUID-0D5DA0E0-28DF-498A-B2E5-B9207AC2BAE6" class="sect6">锁和未编入索引的外键</h6>
                        <div>
                           <p>当子表的外键列上不存在索引时，数据库获取子表上的完整表锁，并且会话修改父表中的主键（例如，删除行或修改主键属性）或将行合并到父表中。</p>
                           <p>当满足以下两个条件时，数据库将获取子表上的完整表锁：</p>
                           <ul style="list-style-type:disc">
                              <li>
                                 <p>子表的外键列上不存在索引。</p>
                              </li>
                              <li>
                                 <p>会话修改父表中的主键（例如，删除行或修改主键属性）或将行合并到父表中。</p>
                              </li>
                           </ul>
                           <div class="infoboxnote" id="GUID-0D5DA0E0-28DF-498A-B2E5-B9207AC2BAE6__GUID-1E54032D-4575-4551-8907-84BC1CE91D54">
                              <p class="notep1">注意：</p>
                              <p>插入父表<span class="italic">不会</span>获取阻止子表上的DML的阻塞表锁。对于插入，数据库获取子表上的锁定以防止结构更改，但不会修改现有或新添加的行。
                              </p>
                           </div>
                           <p>假设<code class="codeph">hr.departments</code>表是<code class="codeph">hr.departments</code>的父<code class="codeph">hr.employees</code> ，其中包含未编入索引的外键<code class="codeph">employees.department_id</code> 。下图显示了在<code class="codeph">departments</code>表中修改department 60的主键属性的会话。
                           </p>
                           <div class="figure" id="GUID-0D5DA0E0-28DF-498A-B2E5-B9207AC2BAE6__I8589">
                              <p class="titleinfigure">图9-3使用未编制索引的外键锁定机制</p><img src="img/cncpt308.gif" alt="下面是图9-3的描述" title="下面是图9-3的描述" longdesc="img_text/cncpt308.html"><br><a href="img_text/cncpt308.html">“图9-3使用未编入索引的外键锁定机制”的描述</a></div>
                           <!-- class="figure" -->
                           <p>在<a href="data-concurrency-and-consistency.html#GUID-0D5DA0E0-28DF-498A-B2E5-B9207AC2BAE6__I8589">图9-3中</a> ，数据库在部门60的主键修改期间获取<code class="codeph">employees</code>的完整表锁。此锁定允许其他会话查询但不更新<code class="codeph">employees</code>表。例如，会话无法更新员工电话号码。在<code class="codeph">departments</code>表上的主键修改完成后， <code class="codeph">employees</code>的表锁定立即释放。如果<code class="codeph">departments</code>多行经过主键修改，则会获取<code class="codeph">employees</code>的表锁定，并为<code class="codeph">departments</code>修改的每一行释放一次。
                           </p>
                           <div class="infoboxnote" id="GUID-0D5DA0E0-28DF-498A-B2E5-B9207AC2BAE6__GUID-40030039-4823-4676-85A5-BC3CCAA39E46">
                              <p class="notep1">注意：</p>
                              <p>子表上的DML不会获取父表上的表锁。</p>
                           </div>
                        </div>
                     </div><a id="CNCPT88982"></a><a id="CNCPT88981"></a><div class="props_rev_3"><a id="GUID-02E89C3B-91C8-4ACD-A43B-55C1DC970D16" name="GUID-02E89C3B-91C8-4ACD-A43B-55C1DC970D16"></a><h6 id="CNCPT-GUID-02E89C3B-91C8-4ACD-A43B-55C1DC970D16" class="sect6">锁定和索引外键</h6>
                        <div>
                           <p>当子表的外键<span class="italic">列</span>索引的数据库<span class="italic">不</span>获取子表上全表锁，会话修改父表的主键（例如，删除行或修改主键属性）或将行合并到父表中。
                           </p>
                           <p>父表上的锁可防止事务获取独占表锁，但在主键修改期间不会阻止父表<span class="italic">或</span>子表上的DML。如果在子表上进行更新时在父表上发生主键修改，则最好使用这种情况。
                           </p>
                           <p><a href="data-concurrency-and-consistency.html#GUID-02E89C3B-91C8-4ACD-A43B-55C1DC970D16__I8605">图9-4</a>显示了具有索引<code class="codeph">department_id</code>列的子表<code class="codeph">employees</code> 。事务从<code class="codeph">departments</code>删除部门280。此删除不会导致数据库获取<code class="codeph">employees</code>表上的完整表锁，如<span class="q">“ <a href="data-concurrency-and-consistency.html#GUID-0D5DA0E0-28DF-498A-B2E5-B9207AC2BAE6" title="当子表的外键列上不存在索引时，数据库获取子表上的完整表锁，并且会话修改父表中的主键（例如，删除行或修改主键属性）或将行合并到父表中。">锁定和未编制索引的外键</a> ”</span>中所述的方案中所示。
                           </p>
                           <div class="figure" id="GUID-02E89C3B-91C8-4ACD-A43B-55C1DC970D16__I8605">
                              <p class="titleinfigure">图9-4带索引外键的锁定机制</p><img src="img/cncpt309.gif" alt="下面是图9-4的描述" title="下面是图9-4的描述" longdesc="img_text/cncpt309.html"><br><a href="img_text/cncpt309.html">“图9-4带索引外键的锁定机制”的描述</a></div>
                           <!-- class="figure" -->
                           <p>如果子表指定<code class="codeph">ON DELETE CASCADE</code> ，则从父表中删除可能会导致从子表中删除。例如，删除部门280可以导致删除部门中<code class="codeph">employees</code>的员工记录。在这种情况下，等待和锁定规则与从父表中删除行后删除子表中的行相同。
                           </p>
                           <div class="infoboxnotealso" id="GUID-02E89C3B-91C8-4ACD-A43B-55C1DC970D16__GUID-9A8B9BB5-747D-4BE2-B935-2BF4C531C38A">
                              <p class="notep1">也可以看看：</p>
                              <ul style="list-style-type:disc">
                                 <li>
                                    <p><span class="q">“ <a href="data-integrity.html#GUID-7CD73D16-EA1A-4AA8-AA7D-4288557395B8" title="只要两个表包含一个或多个公共列，Oracle数据库就可以通过外键约束（也称为引用完整性约束）强制实现两个表之间的关系。">外键约束</a> ”</span></p>
                                 </li>
                                 <li>
                                    <p><span class="q">“ <a href="indexes-and-index-organized-tables.html#GUID-DE7A95BC-6E4A-47EA-9FC5-B85B54F8CF41" title="索引是与表或表集群相关联的可选结构，有时可以加速数据访问。">索引简介</a> ”</span></p>
                                 </li>
                              </ul>
                           </div>
                        </div>
                     </div>
                  </div>
               </div><a id="CNCPT1351"></a><div class="props_rev_3"><a id="GUID-5015CC53-4059-4CD6-B892-F211E8BDE2F9" name="GUID-5015CC53-4059-4CD6-B892-F211E8BDE2F9"></a><h4 id="CNCPT-GUID-5015CC53-4059-4CD6-B892-F211E8BDE2F9" class="sect4">DDL锁定</h4>
                  <div>
                     <p>当正在进行的DDL操作作用于或引用该对象时， <span class="bold">数据字典（DDL）锁</span>保护模式对象的定义。
                     </p>
                     <p>在DDL操作期间，仅锁定已修改或引用的各个模式对象。数据库永远不会锁定整个数据字典。</p>
                     <p>Oracle数据库代表需要它的任何DDL事务自动获取DDL锁。用户无法显式请求DDL锁定。例如，如果用户创建<a href="glossary.html#GUID-21B42148-517A-4B25-B1E1-DBC165DE7A43"><span class="xrefglossterm">存储过程</span></a> ，则Oracle数据库会自动为过程定义中引用的所有模式对象获取DDL锁。DDL锁可防止在过程编译完成之前更改或删除这些对象。
                     </p>
                  </div><a id="CNCPT1352"></a><div class="props_rev_3"><a id="GUID-54A9C57E-C8E5-43B5-B2E8-830ED84D6BE9" name="GUID-54A9C57E-C8E5-43B5-B2E8-830ED84D6BE9"></a><h5 id="CNCPT-GUID-54A9C57E-C8E5-43B5-B2E8-830ED84D6BE9" class="sect5">独家DDL锁</h5>
                     <div>
                        <p>独占DDL锁可防止其他会话获得DDL或DML锁。</p>
                        <p>大多数DDL操作都需要对资源进行独占DDL锁定，以防止对可能修改或引用同一模式对象的其他DDL操作造成破坏性干扰。例如，当<code class="codeph">ALTER TABLE</code>向其添加列时，不允许<code class="codeph">DROP TABLE</code>删除表，反之亦然。
                        </p>
                        <p>独占DDL锁定在DDL语句执行和自动提交期间持续存在。在获取专用DDL锁定期间，如果另一个操作在架构对象上保留了另一个DDL锁定，则获取将等待，直到释放旧的DDL锁定然后继续。</p>
                        <div class="infoboxnotealso" id="GUID-54A9C57E-C8E5-43B5-B2E8-830ED84D6BE9__GUID-9A73B116-8316-4DBB-8F05-E5D180D537DE">
                           <p class="notep1">也可以看看：</p>
                           <p><span class="q">“ <a href="data-concurrency-and-consistency.html#GUID-C6696CA2-D3B8-4CE0-AAB1-CFF040431B6E" title="资源的共享DDL锁可防止对冲突的DDL操作的破坏性干扰，但允许类似DDL操作的数据并发。">共享DDL锁</a> ”</span>描述了不需要专用锁来防止破坏性干扰的情况</p>
                        </div>
                     </div>
                  </div><a id="CNCPT1353"></a><div class="props_rev_3"><a id="GUID-C6696CA2-D3B8-4CE0-AAB1-CFF040431B6E" name="GUID-C6696CA2-D3B8-4CE0-AAB1-CFF040431B6E"></a><h5 id="CNCPT-GUID-C6696CA2-D3B8-4CE0-AAB1-CFF040431B6E" class="sect5">分享DDL锁</h5>
                     <div>
                        <p>资源的共享DDL锁可防止对冲突的DDL操作的破坏性干扰，但允许类似DDL操作的数据并发。</p>
                        <p>例如，运行<code class="codeph">CREATE</code> <code class="codeph">PROCEDURE</code>语句时，包含的事务将获取所有引用表的共享DDL锁。其他事务可以同时创建引用相同表并在同一个表上获取并发共享DDL锁的过程，但是没有事务可以在任何引用的表上获取独占DDL锁。
                        </p>
                        <p>共享DDL锁定持续DDL语句执行和自动提交的持续时间。因此，保证共享DDL锁的事务在引用期间引用的模式对象的定义保持不变。</p>
                     </div>
                  </div><a id="CNCPT1354"></a><div class="props_rev_3"><a id="GUID-D5EC0CEE-1E41-48FB-A303-B4D5C301872D" name="GUID-D5EC0CEE-1E41-48FB-A303-B4D5C301872D"></a><h5 id="CNCPT-GUID-D5EC0CEE-1E41-48FB-A303-B4D5C301872D" class="sect5">易碎的解锁</h5>
                     <div>
                        <p>对于它引用的每个模式对象，SQL语句或PL / SQL程序单元都会保存<span class="bold">解析锁</span> 。
                        </p>
                        <p>获取解析锁，以便在更改或删除引用的对象时，可以使关联的<a href="glossary.html#GUID-E0BE3164-B0A9-4ED8-AD19-2048ADFFC9BB"><span class="xrefglossterm">共享SQL区</span></a>无效。解析锁被称为<span class="italic">可破解解析锁，</span>因为它不会禁止任何DDL操作，并且可以被破坏以允许冲突的DDL操作。
                        </p>
                        <p>在SQL语句执行的分析阶段，在<a href="glossary.html#GUID-64AFFF3A-C836-44F9-A25C-86CE4B9B16A8"><span class="xrefglossterm">共享池中</span></a>获取解析锁。只要该语句的共享SQL区域保留在共享池中，就会保持锁定。
                        </p>
                        <div class="infoboxnotealso" id="GUID-D5EC0CEE-1E41-48FB-A303-B4D5C301872D__GUID-C740B851-7C7E-4274-B3B3-707B5B231D07">
                           <p class="notep1">也可以看看：</p>
                           <p><span class="q">“ <a href="memory-architecture.html#GUID-1CB2BA23-4386-46DA-9146-5FE0E4599AC6" title="共享池缓存各种类型的程序数据。">共享池</a> ”</span></p>
                        </div>
                     </div>
                  </div>
               </div><a id="CNCPT1357"></a><div class="props_rev_3"><a id="GUID-19E6C804-8D75-4D05-ACD2-11915687307A" name="GUID-19E6C804-8D75-4D05-ACD2-11915687307A"></a><h4 id="CNCPT-GUID-19E6C804-8D75-4D05-ACD2-11915687307A" class="sect4">系统锁定</h4>
                  <div>
                     <p>Oracle数据库使用各种类型的系统锁来保护内部数据库和内存结构。用户无法访问这些机制，因为用户无法控制其发生或持续时间。</p>
                  </div><a id="CNCPT1358"></a><div class="props_rev_3"><a id="GUID-95BC1F61-F13B-4F04-94AC-30138287F7C7" name="GUID-95BC1F61-F13B-4F04-94AC-30138287F7C7"></a><h5 id="CNCPT-GUID-95BC1F61-F13B-4F04-94AC-30138287F7C7" class="sect5">插销</h5>
                     <div>
                        <p><span class="bold">锁存器</span>是一种简单的低级序列化机制，可协调对共享数据结构，对象和文件的多用户访问。
                        </p>
                        <p>当多个进程访问时，锁存器可保护共享内存资源免受损坏。具体来说，锁存器保护数据结构免受以下情况的影响：</p>
                        <ul style="list-style-type:disc">
                           <li>
                              <p>多个会话同时修改</p>
                           </li>
                           <li>
                              <p>被另一个会话修改时被一个会话读取</p>
                           </li>
                           <li>
                              <p>访问时释放内存（老化）</p>
                           </li>
                        </ul>
                        <p>通常，单个锁存器保护SGA中的多个对象。例如，后台进程（如DBW和LGWR）从<a href="glossary.html#GUID-64AFFF3A-C836-44F9-A25C-86CE4B9B16A8"><span class="xrefglossterm">共享池</span></a>分配内存以创建数据结构。要分配此内存，这些进程使用共享池锁存器来序列化访问，以防止两个进程同时尝试检查或修改共享池。在分配内存之后，其他进程可能需要访问共享池区域，例如<a href="glossary.html#GUID-FEEB5344-9D82-4727-911A-7F14CDC76D73"><span class="xrefglossterm">库高速缓存</span></a> ，这是解析所需的。在这种情况下，进程仅锁存库高速缓存，而不是整个共享池。
                        </p>
                        <p>与诸如行锁之类的入队锁存器不同，锁存器不允许会话排队。当锁存器变得可用时，请求锁存器的第一个会话获得对它的独占访问。当进程在循环中重复请求<a href="glossary.html#GUID-90863FC3-7B0A-48D1-ACEC-139690358B4F"><span class="xrefglossterm">锁存器</span></a>时发生<a href="glossary.html#GUID-90863FC3-7B0A-48D1-ACEC-139690358B4F"><span class="xrefglossterm">锁存器旋转</span></a>现象，而当更新锁存器请求之前进程释放CPU时发生<a href="glossary.html#GUID-4B25EC28-1C69-4810-BA53-52D9E88401BC"><span class="xrefglossterm">锁存器休眠</span></a> 。</p>
                        <p>通常，Oracle进程在操作或查看数据结构时会在极短的时间内获取锁存器。例如，在处理单个员工的工资更新时，数据库可以获取并释放数千个锁存器。锁存器的实现取决于操作系统，尤其是关于进程是否以及等待锁存器的时间长短。</p>
                        <p>锁存的增加意味着并发性的降低。例如，过多的<a href="glossary.html#GUID-1BFB2AF7-BC88-4A93-B9AA-C75CA62C5824"><span class="xrefglossterm">硬分析</span></a>操作会导致库高速缓存锁存器的争用。<code class="codeph">V$LATCH</code>视图包含每个锁存器的详细锁存器使用情况统计信息，包括每个锁存器被请求和等待的次数。
                        </p>
                        <div class="infoboxnotealso" id="GUID-95BC1F61-F13B-4F04-94AC-30138287F7C7__GUID-8C916B68-97F0-4401-84EC-E4A86D8F4A08">
                           <p class="notep1">也可以看看：</p>
                           <ul style="list-style-type:disc">
                              <li>
                                 <p><span class="q">“ <a href="sql.html#GUID-B3F2B5B8-B679-4A7C-B1E8-286F36319FCB" title="SQL处理的第一个阶段是SQL解析。此阶段涉及将SQL语句的各个部分分离为可由其他例程处理的数据结构。">SQL解析</a> ”</span></p>
                              </li>
                              <li>
                                 <p><a href="../refrn/V-LATCH.html#REFRN30108" target="_blank"><span><cite>Oracle Database Reference</cite></span></a>了解<code class="codeph">V$LATCH</code></p>
                              </li>
                              <li>
                                 <p><a href="../tgdba/instance-tuning-using-performance-views.html#GUID-03F070F3-81DF-4649-820C-DAD28AEF0871" target="_blank"><span><cite>Oracle数据库性能调优指南</cite></span></a> ，了解等待事件统计信息</p>
                              </li>
                           </ul>
                        </div>
                     </div>
                  </div><a id="CNCPT88983"></a><div class="props_rev_3"><a id="GUID-4AC3AA12-E84E-4A73-B66F-9799D4980B1D" name="GUID-4AC3AA12-E84E-4A73-B66F-9799D4980B1D"></a><h5 id="CNCPT-GUID-4AC3AA12-E84E-4A73-B66F-9799D4980B1D" class="sect5">互斥</h5>
                     <div>
                        <p><span class="bold">互斥对象（mutex）</span>是一种低级机制，可防止内存中的对象在并发进程访问时老化或被破坏。互斥锁类似于锁存器，但是锁存器通常保护一组对象，互斥锁保护单个对象。
                        </p>
                        <p>互斥体提供了几个好处：</p>
                        <ul style="list-style-type:disc">
                           <li>
                              <p>互斥锁可以减少争用的可能性。</p>
                              <p>因为锁存器保护多个对象，所以当进程试图同时访问任何这些对象时，它可能成为瓶颈。通过序列化对单个对象而不是组的访问，互斥锁可提高可用性。</p>
                           </li>
                           <li>
                              <p>互斥锁比锁存器消耗更少的内存。</p>
                           </li>
                           <li>
                              <p>在共享模式下，互斥锁允许多个会话进行并发引用。</p>
                           </li>
                        </ul>
                     </div>
                  </div><a id="CNCPT1360"></a><a id="CNCPT1361"></a><a id="CNCPT1362"></a><a id="CNCPT1359"></a><div class="props_rev_3"><a id="GUID-58E2545B-A3F8-48C7-B23B-4E2EEF1BF18A" name="GUID-58E2545B-A3F8-48C7-B23B-4E2EEF1BF18A"></a><h5 id="CNCPT-GUID-58E2545B-A3F8-48C7-B23B-4E2EEF1BF18A" class="sect5">内部锁定</h5>
                     <div>
                        <p>内部锁是比锁存器和互斥锁更高级，更复杂的机制，并且用于各种目的。</p>
                        <p>数据库使用以下类型的内部锁：</p>
                        <ul style="list-style-type:disc">
                           <li>
                              <p>字典缓存锁</p>
                              <p>这些锁的持续时间非常短，并且在修改或使用条目时保留在字典高速缓存中的条目上。它们保证被解析的语句不会看到不一致的对象定义。字典缓存锁可以是共享的或独占的。解析完成后释放共享锁，而DDL操作完成时释放独占锁。</p>
                           </li>
                           <li>
                              <p>文件和日志管理锁</p>
                              <p>这些锁保护各种文件。例如，内部锁保护<a href="glossary.html#GUID-DF498605-D186-451B-87AA-73DF396AD599"><span class="xrefglossterm">控制文件，</span></a>以便一次只有一个进程可以更改它。另一个锁用于协调在线重做日志文件的使用和存档。锁定数据文件以确保多个实例以共享模式挂载数据库，或者一个实例以独占模式挂载它。因为文件和日志锁指示文件的状态，所以这些锁必须保持很长时间。
                              </p>
                           </li>
                           <li>
                              <p>表空间和还原段锁</p>
                              <p>这些锁保护表空间和撤消段。例如，访问数据库的所有实例必须就表空间是联机还是脱机达成一致。撤消段被锁定，以便只有一个数据库实例可以写入段。</p>
                           </li>
                        </ul>
                        <div class="infoboxnotealso" id="GUID-58E2545B-A3F8-48C7-B23B-4E2EEF1BF18A__GUID-A080A898-A32B-4FB4-8C7B-F841DCB7B398">
                           <p class="notep1">也可以看看：</p>
                           <p><span class="q">“ <a href="memory-architecture.html#GUID-66430838-7862-4389-96B5-795B99A72473" title="数据字典是数据库表和视图的集合，包含有关数据库，其结构和用户的参考信息。">数据字典缓存</a> ”</span></p>
                        </div>
                     </div>
                  </div>
               </div>
            </div><a id="CNCPT1363"></a><div class="props_rev_3"><a id="GUID-A4E54CD6-7232-489D-86A4-412EAF8A8DB7" name="GUID-A4E54CD6-7232-489D-86A4-412EAF8A8DB7"></a><h3 id="CNCPT-GUID-A4E54CD6-7232-489D-86A4-412EAF8A8DB7" class="sect3">手动数据锁概述</h3>
               <div>
                  <p>您可以手动覆盖Oracle数据库的默认锁定机制。</p>
                  <p>Oracle数据库自动执行锁定以确保数据并发性，数据完整性和语句级读取一致性。但是，覆盖默认锁定在以下情况下很有用：</p>
                  <ul style="list-style-type:disc">
                     <li>
                        <p>应用程序需要事务级读取一致性或可重复读取。</p>
                        <p>在这种情况下，查询必须在事务持续时间内生成一致的数据，而不是反映其他事务的更改。您可以通过使用显式锁定，只读事务，可序列化事务或通过覆盖默认锁定来实现事务级读取一致性。</p>
                     </li>
                     <li>
                        <p>应用程序要求事务具有对资源的独占访问权限，以便事务不必等待其他事务完成。</p>
                     </li>
                  </ul>
                  <p>您可以在会话或事务级别覆盖Oracle数据库自动锁定。在会话级别，会话可以使用<code class="codeph">ALTER SESSION</code>语句设置所需的事务隔离级别。在事务级别，包含以下SQL语句的事务将覆盖Oracle数据库的默认锁定：</p>
                  <ul style="list-style-type:disc">
                     <li>
                        <p><code class="codeph">SET TRANSACTION ISOLATION LEVEL</code>语句</p>
                     </li>
                     <li>
                        <p><code class="codeph">LOCK TABLE</code>语句（锁定表或与视图一起使用时，锁定基表）</p>
                     </li>
                     <li>
                        <p><code class="codeph">SELECT ...FOR UPDATE</code>语句</p>
                     </li>
                  </ul>
                  <p>在事务结束或回滚到保存点后释放前面语句获取的锁。</p>
                  <p>如果在任何级别覆盖Oracle数据库缺省锁定，则数据库管理员或应用程序开发人员应确保覆盖锁定过程正确运行。锁定过程必须满足以下条件：保证数据完整性，数据并发性是可接受的，并且死锁不可能或者被适当处理。</p>
                  <div class="infoboxnotealso" id="GUID-A4E54CD6-7232-489D-86A4-412EAF8A8DB7__GUID-DE1C2664-1E6D-4692-8277-F0125ED503AD">
                     <p class="notep1">也可以看看：</p>
                     <ul style="list-style-type:disc">
                        <li>
                           <p> 有关<code class="codeph">LOCK TABLE</code>和<code class="codeph">SELECT</code>描述，请<a href="../sqlrf/LOCK-TABLE.html#SQLRF01605" target="_blank"><span><cite>参见Oracle数据库SQL语言参考</cite></span></a></p>
                        </li>
                        <li>
                           <p><a href="../adfns/sql-processing-for-application-developers.html#ADFNS00203" target="_blank"><span><cite>Oracle数据库开发指南</cite></span></a> ，了解如何手动锁定表</p>
                        </li>
                     </ul>
                  </div>
               </div>
            </div><a id="CNCPT1364"></a><div class="props_rev_3"><a id="GUID-D63FD030-44CD-4FD7-970A-C98C8CC4AC42" name="GUID-D63FD030-44CD-4FD7-970A-C98C8CC4AC42"></a><h3 id="CNCPT-GUID-D63FD030-44CD-4FD7-970A-C98C8CC4AC42" class="sect3">用户定义的锁概述</h3>
               <div>
                  <p>使用Oracle数据库锁管理服务，您可以为特定应用程序定义自己的锁。</p>
                  <p>例如，您可以创建一个锁来序列化对文件系统上的消息日志的访问。由于保留的用户锁与Oracle数据库锁相同，因此它具有所有Oracle数据库锁功能，包括死锁检测。用户锁永远不会与Oracle数据库锁冲突，因为它们使用前缀<code class="codeph">UL</code>标识。</p>
                  <p>Oracle Database Lock Management服务可通过<code class="codeph">DBMS_LOCK</code>包中的过程获得。您可以在PL / SQL块中包含以下语句：</p>
                  <ul style="list-style-type:disc">
                     <li>
                        <p>请求特定类型的锁</p>
                     </li>
                     <li>
                        <p>为锁提供一个唯一的名称，可以在同一个或另一个实例中的另一个过程中识别</p>
                     </li>
                     <li>
                        <p>更改锁定类型</p>
                     </li>
                     <li>
                        <p>解锁</p>
                     </li>
                  </ul>
                  <div class="infoboxnotealso" id="GUID-D63FD030-44CD-4FD7-970A-C98C8CC4AC42__GUID-3B45BFA6-2C0A-4270-8C64-86559F5F335A">
                     <p class="notep1">也可以看看：</p>
                     <ul style="list-style-type:disc">
                        <li>
                           <p>有关Oracle数据库锁管理服务的更多信息，请参见<a href="../adfns/sql-processing-for-application-developers.html#ADFNS1002" target="_blank"><span><cite>Oracle数据库开发指南</cite></span></a></p>
                        </li>
                        <li>
                           <p>有关<code class="codeph">DBMS_LOCK</code>信息，请<code class="codeph">DBMS_LOCK</code> <a href="../arpls/DBMS_LOCK.html#ARPLS021" target="_blank"><span><cite>Oracle Database PL / SQL包和类型参考</cite></span></a></p>
                        </li>
                     </ul>
                  </div>
               </div>
            </div>
            <hr><br><p style="text-decoration:underline">脚注图例</p>脚注1：<p>处理分布式两阶段提交时，数据库可能会在特殊情况下短暂阻止读取访问。具体来说，如果查询在准备阶段和提交阶段之间开始并尝试在提交之前读取数据，则数据库可能会将锁从行级升级到块级以保证读取一致性。</p><br></div>
      </article>
   </body>
</html>