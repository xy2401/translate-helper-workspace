<html lang="en-us" dir="ltr" xml:lang="en-us">
   <head>
      <meta http-equiv="Content-Type" content="text/html; charset=utf-8"></meta>
      <meta name="viewport" content="width=device-width, initial-scale=1"></meta>
      <meta http-equiv="X-UA-Compatible" content="IE=edge"></meta>
      <title>数据仓库优化和技术</title>
      <meta property="og:site_name" content="Oracle Help Center"></meta>
      <meta property="og:title" content="Data Warehousing Guide"></meta>
      <meta property="og:description" content=""></meta>
      <link rel="stylesheet" href="/sp_common/book-template/ohc-book-template/css/book.css"></link>
      <link rel="shortcut icon" href="/sp_common/book-template/ohc-common/img/favicon.ico"></link>
      <meta name="application-name" content="Data Warehousing Guide"></meta>
      <meta name="generator" content="DITA Open Toolkit version 1.8.5 (Mode = doc)"></meta>
      <meta name="plugin" content="SP_docbuilder HTML plugin release 18.2.2"></meta>
      <link rel="alternate" href="database-data-warehousing-guide.pdf" title="PDF File" type="application/pdf"></link>
      <meta name="robots" content="all"></meta>
      <link rel="schema.dcterms" href="http://purl.org/dc/terms/"></link>
      <meta name="dcterms.created" content="2019-01-09T00:20:13-08:00"></meta>
      
      <meta name="dcterms.dateCopyrighted" content="2001, 2019"></meta>
      <meta name="dcterms.category" content="database"></meta>
      <meta name="dcterms.identifier" content="E96243-01"></meta>
      
      <meta name="dcterms.product" content="en/database/oracle/oracle-database/19"></meta>
      
      <link rel="prev" href="data-warehouse-physical-design.html" title="Previous" type="text/html"></link>
      <link rel="next" href="part-optimizing-dw.html" title="Next" type="text/html"></link>
      <script>
        document.write('<style type="text/css">');
        document.write('body > .noscript, body > .noscript ~ * { visibility: hidden; }');
        document.write('</style>');
     </script>
      <script src="/sp_common/book-template/requirejs/require.js" data-main="/sp_common/book-template/ohc-book-template/js/book-config"></script>
      <script>
            if (window.require === undefined) {
                document.write('<script data-main="sp_common/book-template/ohc-book-template/js/book-config" src="sp_common/book-template/requirejs/require.js"><\/script>');
                document.write('<link href="sp_common/book-template/ohc-book-template/css/book.css" rel="stylesheet"/>');
            }
        </script>
      <script type="application/json" id="ssot-metadata">{"primary":{"category":{"short_name":"database","element_name":"Database","display_in_url":true},"suite":{"short_name":"oracle","element_name":"Oracle","display_in_url":true},"product_group":{"short_name":"not-applicable","element_name":"Not applicable","display_in_url":false},"product":{"short_name":"oracle-database","element_name":"Oracle Database","display_in_url":true},"release":{"short_name":"19","element_name":"Release 19","display_in_url":true}}}</script>
      
    <meta name="dcterms.title" content="Database Data Warehousing Guide"></meta>
    <meta name="dcterms.isVersionOf" content="DWHSG"></meta>
    <meta name="dcterms.release" content="Release 19"></meta>
  </head>
   <body dir="ltr">
      <div class="noscript alert alert-danger text-center" role="alert">
         <a href="data-warehouse-physical-design.html" class="pull-left"><span class="glyphicon glyphicon-chevron-left" aria-hidden="true"></span>上一页</a> <a href="part-optimizing-dw.html" class="pull-right">下一页<span class="glyphicon glyphicon-chevron-right" aria-hidden="true"></span></a> <span class="fa fa-exclamation-triangle" aria-hidden="true"></span>必须启用JavaScript才能正确显示此内容</div>
      <article>
         <header>
            <ol class="breadcrumb" vocab="http://schema.org/" typeof="BreadcrumbList">
               <li property="itemListElement" typeof="ListItem"><a href="index.html" property="item" typeof="WebPage"><span property="name">数据仓库指南</span></a></li>
               <li property="itemListElement" typeof="ListItem"><a href="part-dw-fundamentals.html" property="item" typeof="WebPage"><span property="name">数据仓库 - 基础知识</span></a></li>
               <li class="active" property="itemListElement" typeof="ListItem">数据仓库优化和技术</li>
            </ol>
            <a id="GUID-79C29A60-3477-448D-835D-2940D060D050" name="GUID-79C29A60-3477-448D-835D-2940D060D050"></a>
            
            <h2 id="DWHSG-GUID-79C29A60-3477-448D-835D-2940D060D050" class="sect2"><span class="enumeration_chapter">4</span>数据仓库优化和技术</h2>
         </header>
         <div class="ind">
            <div>
               <p>以下主题提供有关数据仓库中模式的信息：</p>
               <ul style="list-style-type:disc">
                  <li>
                     <p><a href="data-warehouse-optimizations-techniques.html#GUID-E4C8F817-8CD9-437B-819F-2917B7F48304">在数据仓库中使用索引</a></p>
                  </li>
                  <li>
                     <p><a href="data-warehouse-optimizations-techniques.html#GUID-3A627575-6C0D-4D86-8B86-2A85B02A5EC7">在数据仓库中使用完整性约束</a></p>
                  </li>
                  <li>
                     <p><a href="data-warehouse-optimizations-techniques.html#GUID-2207CC57-A4D8-4ED1-8676-151EFD7E3528">关于数据仓库中的并行执行</a></p>
                  </li>
                  <li>
                     <p><a href="data-warehouse-optimizations-techniques.html#GUID-11CD602C-2C37-4771-97A6-CFFEABB4259D">关于优化数据仓库中的存储要求</a></p>
                  </li>
                  <li>
                     <p><a href="data-warehouse-optimizations-techniques.html#GUID-3AF4B9BF-F429-4AAF-983A-6F722484D0E2">优化星形查询和3NF模式</a></p>
                  </li>
                  <li>
                     <p><a href="data-warehouse-optimizations-techniques.html#GUID-F7E7DEA6-B225-43E6-97ED-CB3DBE86CD54" title="近似查询处理使用SQL函数为可接受近似值的探索性查询提供实时响应。包含返回近似结果的SQL函数的查询称为近似查询。">关于近似查询处理</a></p>
                  </li>
                  <li>
                     <p><a href="data-warehouse-optimizations-techniques.html#GUID-07B31A40-6AD9-4843-B5B3-D2424ACE39D5">关于近似前N个查询处理</a></p>
                  </li>
               </ul>
            </div><a id="DWHSG8130"></a><div class="props_rev_3"><a id="GUID-E4C8F817-8CD9-437B-819F-2917B7F48304" name="GUID-E4C8F817-8CD9-437B-819F-2917B7F48304"></a><h3 id="DWHSG-GUID-E4C8F817-8CD9-437B-819F-2917B7F48304" class="sect3"><span class="enumeration_section">4.1</span>在数据仓库中使用索引</h3>
               <div>
                  <p>索引可以更快地检索存储在数据仓库中的数据。本节讨论在数据仓库中使用索引的以下方面：</p>
                  <ul style="list-style-type:disc">
                     <li>
                        <p><a href="data-warehouse-optimizations-techniques.html#GUID-76BAA645-A219-4FF5-AFD4-B6FA8C1473FB">关于在数据仓库中使用位图索引</a></p>
                     </li>
                     <li>
                        <p><a href="data-warehouse-optimizations-techniques.html#GUID-2A46AFA2-5EA7-4C0D-A507-598C8AA69D65">数据仓库应用程序索引的好处</a></p>
                     </li>
                     <li>
                        <p><a href="data-warehouse-optimizations-techniques.html#GUID-7BD561A9-6B28-43A6-A5E0-B9AF196CF251">关于基数和位图索引</a></p>
                     </li>
                     <li>
                        <p><a href="data-warehouse-optimizations-techniques.html#GUID-017284C6-3D68-4469-BEB6-E3C6FB886A0C">如何确定使用位图索引的候选者</a></p>
                     </li>
                     <li>
                        <p><a href="data-warehouse-optimizations-techniques.html#GUID-2BB63651-2ED9-41B3-838D-592CC1D6766F">在数据仓库中使用位图连接索引</a></p>
                     </li>
                     <li>
                        <p><a href="data-warehouse-optimizations-techniques.html#GUID-DB336AF1-3550-4B89-AC53-9BDEE89327CA">在数据仓库中使用B树索引</a></p>
                     </li>
                     <li>
                        <p><a href="data-warehouse-optimizations-techniques.html#GUID-31319B88-136B-4E29-92FC-0AD5B0B3CEE0">使用索引压缩</a></p>
                     </li>
                     <li>
                        <p><a href="data-warehouse-optimizations-techniques.html#GUID-BEC3FACE-B5B1-4904-9BC9-9CA060BB9C76">在本地索引和全局索引之间进行选择</a></p>
                     </li>
                  </ul>
               </div><a id="DWHSG9041"></a><div class="props_rev_3"><a id="GUID-76BAA645-A219-4FF5-AFD4-B6FA8C1473FB" name="GUID-76BAA645-A219-4FF5-AFD4-B6FA8C1473FB"></a><h4 id="DWHSG-GUID-76BAA645-A219-4FF5-AFD4-B6FA8C1473FB" class="sect4"><span class="enumeration_section">4.1.1</span>关于在数据仓库中使用位图索引</h4>
                  <div>
                     <p><a id="d9998e140" class="indexterm-anchor"></a>位图索引广泛用于数据仓库环境。环境通常具有大量数据和即席查询，但是并发DML事务的级别较低。对于此类应用程序，位图索引提供：</p>
                     <ul style="list-style-type:disc">
                        <li>
                           <p>缩短大型即席查询的响应时间。</p>
                        </li>
                        <li>
                           <p>与其他索引技术相比，降低了存储要求。</p>
                        </li>
                        <li>
                           <p>即使在CPU数量相对较少或内存较少的硬件上，性能也会大幅提升。</p>
                        </li>
                     </ul>
                     <p>使用传统B树索引对大型表进行完全索引在磁盘空间方面可能非常昂贵，因为索引可能比表中的数据大几倍。位图索引通常只是表中索引数据大小的一小部分。</p>
                     <p>索引提供指向表中包含给定键值的行的指针。常规索引存储与具有该键值的行对应的每个键的rowid列表。在位图索引中，每个键值的位图替换rowid列表。</p>
                     <p>位图中的每个位对应一个可能的rowid，如果该位置位，则表示具有相应rowid的行包含键值。映射函数将位位置转换为实际的rowid，以便位图索引提供与常规索引相同的功能。位图索引以压缩方式存储位图。如果不同键值的数量很小，则位图索引压缩得更好，与B树索引相比节省空间的好处变得更好。</p>
                     <p>位图索引对于<code class="codeph">WHERE</code>子句中包含多个条件的查询最有效。满足某些条件但不是所有条件的行在访问表本身之前被过滤掉。这通常可以显着改善响应时间。如果您不确定要创建哪些索引，SQL Access Advisor可以生成有关要创建的内容的建议。由于位图索引的位图可以快速组合，因此通常最好使用单列位图索引。
                     </p>
                     <p>创建位图索引时，应使用<code class="codeph">NOLOGGING</code>和<code class="codeph">COMPUTE</code> <code class="codeph">STATISTICS</code> 。此外，您应该记住，位图索引通常比维护更容易破坏和重新创建。
                     </p>
                  </div><a id="DWHSG8138"></a><a id="DWHSG9045"></a><div class="props_rev_3"><a id="GUID-1D0A6F59-1C6C-4221-BE3B-0352C6F0F07D" name="GUID-1D0A6F59-1C6C-4221-BE3B-0352C6F0F07D"></a><h5 id="DWHSG-GUID-1D0A6F59-1C6C-4221-BE3B-0352C6F0F07D" class="sect5"><span class="enumeration_section">4.1.1.1</span>关于位图索引和空值</h5>
                     <div>
                        <p>与大多数其他类型的索引不同， <a id="d9998e198" class="indexterm-anchor"></a><a id="d9998e202" class="indexterm-anchor"></a><a id="d9998e206" class="indexterm-anchor"></a>位图索引包括具有<code class="codeph">NULL</code>值的行。对某些类型的索引可以使用空值索引<a id="d9998e214" class="indexterm-anchor"></a> SQL语句，例如具有聚合函数<code class="codeph">COUNT</code>查询。</p>
                        <div class="example" id="GUID-1D0A6F59-1C6C-4221-BE3B-0352C6F0F07D__GUID-30AE74AE-E706-4AF7-86C2-3821C42D0EC3">
                           <p class="titleinexample">例4-1位图索引</p><pre class="oac_no_warn" dir="ltr">SELECT COUNT（*）FROM customers WHERE cust_marital_status IS NULL;</pre><p>此查询在<code class="codeph">cust_marital_status</code>上使用位图索引。请注意，此查询将无法使用B树索引，因为B树索引不存储<code class="codeph">NULL</code>值。
                           </p><pre class="oac_no_warn" dir="ltr">SELECT COUNT（*）FROM customers;</pre><p>任何位图索引都可用于此查询，因为所有表行都已编制索引，包括那些具有<code class="codeph">NULL</code>数据的表。如果未对空值建立索引，则优化程序将只能对具有<code class="codeph">NOT NULL</code>约束的列使用索引。
                           </p>
                        </div>
                        <!-- class="example" -->
                     </div>
                  </div><a id="DWHSG9046"></a><div class="props_rev_3"><a id="GUID-BB615445-CF86-434E-9B16-5A8F0624A184" name="GUID-BB615445-CF86-434E-9B16-5A8F0624A184"></a><h5 id="DWHSG-GUID-BB615445-CF86-434E-9B16-5A8F0624A184" class="sect5"><span class="enumeration_section">4.1.1.2</span>关于分区表的位图索引</h5>
                     <div>
                        <p><a id="d9998e266" class="indexterm-anchor"></a><a id="d9998e270" class="indexterm-anchor"></a><a id="d9998e272" class="indexterm-anchor"></a><a id="d9998e276" class="indexterm-anchor"></a><a id="d9998e280" class="indexterm-anchor"></a>您可以在分区表上创建位图索引，但它们必须是分区表的本地索引 - 它们不能是全局索引。分区表只能具有全局B树索引，分区或非分区。
                        </p>
                        <div class="infoboxnotealso" id="GUID-BB615445-CF86-434E-9B16-5A8F0624A184__GUID-545DD362-4E47-4487-B5F3-08C21FE1A88A">
                           <p class="notep1">也可以看看：</p>
                           <ul style="list-style-type:disc">
                              <li>
                                 <p><a href="../sqlrf/CREATE-INDEX.html#SQLRF53981" target="_blank"><span><cite>Oracle数据库SQL语言参考</cite></span></a></p>
                              </li>
                              <li>
                                 <p><a href="../vldbg/partition-concepts.html#VLDBG1082" target="_blank"><span><cite>Oracle数据库VLDB和分区指南</cite></span></a></p>
                              </li>
                           </ul>
                        </div>
                     </div>
                  </div>
               </div><a id="DWHSG9042"></a><div class="props_rev_3"><a id="GUID-2A46AFA2-5EA7-4C0D-A507-598C8AA69D65" name="GUID-2A46AFA2-5EA7-4C0D-A507-598C8AA69D65"></a><h4 id="DWHSG-GUID-2A46AFA2-5EA7-4C0D-A507-598C8AA69D65" class="sect4"><span class="enumeration_section">4.1.2</span>数据仓库应用程序索引的优点</h4>
                  <div>
                     <p><a id="d9998e322" class="indexterm-anchor"></a><a id="d9998e326" class="indexterm-anchor"></a>位图索引主要用于数据仓库应用程序，用户在这些应用程序中查询数据而不是更新数据。它们不适用于具有大量并发事务修改数据的OLTP应用程序。
                     </p>
                     <p>索引对高基数列更有用。</p>
                     <div class="infoboxnotealso" id="GUID-2A46AFA2-5EA7-4C0D-A507-598C8AA69D65__GUID-97DE73BF-6FE3-4094-B595-C93C3F51863A">
                        <p class="notep1">也可以看看：</p>
                        <p><a href="data-warehouse-optimizations-techniques.html#GUID-7BD561A9-6B28-43A6-A5E0-B9AF196CF251">关于基数和位图索引</a></p>
                     </div>
                     <p><a id="d9998e339" class="indexterm-anchor"></a><a id="d9998e341" class="indexterm-anchor"></a><a id="d9998e345" class="indexterm-anchor"></a><a id="d9998e349" class="indexterm-anchor"></a><a id="d9998e353" class="indexterm-anchor"></a>并行查询和并行DML使用位图索引。位图索引还支持并行创建索引和连接索引。
                     </p>
                  </div>
               </div><a id="DWHSG8134"></a><a id="DWHSG8135"></a><a id="DWHSG9043"></a><div class="props_rev_3"><a id="GUID-7BD561A9-6B28-43A6-A5E0-B9AF196CF251" name="GUID-7BD561A9-6B28-43A6-A5E0-B9AF196CF251"></a><h4 id="DWHSG-GUID-7BD561A9-6B28-43A6-A5E0-B9AF196CF251" class="sect4"><span class="enumeration_section">4.1.3</span>关于基数和位图索引</h4>
                  <div>
                     <p>对于其中不同值的数量与表中的行数的比率较小的列，使用位图索引的优点最大。该比率被称为<a href="glossary.html#GUID-50473CD3-62C8-476E-8E04-CC2A6AEEA7EE"><span class="xrefglossterm">基数度</span></a> 。性别列只有两个不同的值（男性和女性），对于位图索引是最佳的。但是，数据仓库管理员还会在具有较高基数的列上构建位图索引。
                     </p>
                     <p>例如，在具有一百万行的表上，具有10,000个不同值的列是位图索引的候选者。此列上的位图索引可以胜过B树索引，尤其是当此列经常与其他索引列一起查询时。实际上，在典型的数据仓库环境中，可以考虑任何非唯一列的位图索引。</p>
                     <p>B树索引对于高基数数据最有效：即，对于具有许多可能值的数据，例如<code class="codeph">customer_name</code>或<code class="codeph">phone_number</code> 。在数据仓库中，B树索引应仅用于具有非常高基数的唯一列或其他列（即，几乎唯一的列）。数据仓库中的大多数索引应该是位图索引。
                     </p>
                     <p>在即席查询和类似情况下，位图索引可以显着提高查询性能。通过在将结果位图转换为rowid之前直接在位图上执行相应的布尔运算，可以快速解析查询的<code class="codeph">WHERE</code>子句中的<code class="codeph">AND</code>和<code class="codeph">OR</code>条件。如果生成的行数很小，则可以快速回答查询，而无需借助全表扫描。
                     </p>
                     <p>以下查询输出显示公司<code class="codeph">customers</code>表的一部分。
                     </p><pre class="oac_no_warn" dir="ltr">SELECT cust_id，cust_gender，cust_marital_status，cust_income_level FROM customers; CUST_ID C CUST_MARITAL_STATUS CUST_INCOME_LEVEL ----------  -  -------------------- --------------- ------ ......70 FD：70,000  -  89,999 80 F结婚H：150,000  -  169,999 90 M单H：150,000  -  169,999 100 FI：170,000  -  189,999 110 F结婚C：50,000  -  69,999 120 M单F：110,000  -  129,999 130 MJ：190,000  -  249,999 140 M结婚G：130,000  -  149,999 ......
</pre><p>因为<code class="codeph">cust_gender</code> ， <code class="codeph">cust_marital_status</code>和<code class="codeph">cust_income_level</code>都是低基数列（婚姻状态只有三个可能的值，两个可能的性别值，12个收入级别），位图索引是这些列的理想选择。不要在<code class="codeph">cust_id</code>上创建位图索引，因为这是一个唯一的列。相反，此列上的唯一B树索引提供最有效的表示和检索。
                     </p>
                     <p><a href="data-warehouse-optimizations-techniques.html#GUID-7BD561A9-6B28-43A6-A5E0-B9AF196CF251__G1007545" title="此表说明了一个示例位图索引">表4-1</a>说明了此示例中<code class="codeph">cust_gender</code>列的位图索引。它由两个独立的位图组成，一个用于性别。
                     </p>
                     <div class="tblformal" id="GUID-7BD561A9-6B28-43A6-A5E0-B9AF196CF251__G1007545">
                        <p class="titleintable">表4-1位图索引示例</p>
                        <table cellpadding="4" cellspacing="0" class="Formal" title="示例位图索引" width="100%" border="1" summary="This table illustrates a sample bitmap index" frame="hsides" rules="rows">
                           <thead>
                              <tr align="left" valign="top">
                                 <th align="left" valign="bottom" width="27%" id="d9998e468">CUST_ID</th>
                                 <th align="left" valign="bottom" width="27%" id="d9998e471">性别= 'M'</th>
                                 <th align="left" valign="bottom" width="47%" id="d9998e474">性别= 'F'</th>
                              </tr>
                           </thead>
                           <tbody>
                              <tr align="left" valign="top">
                                 <td align="left" valign="top" width="27%" id="d9998e479" headers="d9998e468 ">
                                    <p><code class="codeph">cust_id 70</code></p>
                                 </td>
                                 <td align="left" valign="top" width="27%" headers="d9998e479 d9998e471 ">
                                    <p>0</p>
                                 </td>
                                 <td align="left" valign="top" width="47%" headers="d9998e479 d9998e474 ">
                                    <p>1</p>
                                 </td>
                              </tr>
                              <tr align="left" valign="top">
                                 <td align="left" valign="top" width="27%" id="d9998e490" headers="d9998e468 ">
                                    <p><code class="codeph">cust_id 80</code></p>
                                 </td>
                                 <td align="left" valign="top" width="27%" headers="d9998e490 d9998e471 ">
                                    <p>0</p>
                                 </td>
                                 <td align="left" valign="top" width="47%" headers="d9998e490 d9998e474 ">
                                    <p>1</p>
                                 </td>
                              </tr>
                              <tr align="left" valign="top">
                                 <td align="left" valign="top" width="27%" id="d9998e501" headers="d9998e468 ">
                                    <p><code class="codeph">cust_id 90</code></p>
                                 </td>
                                 <td align="left" valign="top" width="27%" headers="d9998e501 d9998e471 ">
                                    <p>1</p>
                                 </td>
                                 <td align="left" valign="top" width="47%" headers="d9998e501 d9998e474 ">
                                    <p>0</p>
                                 </td>
                              </tr>
                              <tr align="left" valign="top">
                                 <td align="left" valign="top" width="27%" id="d9998e512" headers="d9998e468 ">
                                    <p><code class="codeph">cust_id 100</code></p>
                                 </td>
                                 <td align="left" valign="top" width="27%" headers="d9998e512 d9998e471 ">
                                    <p>0</p>
                                 </td>
                                 <td align="left" valign="top" width="47%" headers="d9998e512 d9998e474 ">
                                    <p>1</p>
                                 </td>
                              </tr>
                              <tr align="left" valign="top">
                                 <td align="left" valign="top" width="27%" id="d9998e523" headers="d9998e468 ">
                                    <p><code class="codeph">cust_id 110</code></p>
                                 </td>
                                 <td align="left" valign="top" width="27%" headers="d9998e523 d9998e471 ">
                                    <p>0</p>
                                 </td>
                                 <td align="left" valign="top" width="47%" headers="d9998e523 d9998e474 ">
                                    <p>1</p>
                                 </td>
                              </tr>
                              <tr align="left" valign="top">
                                 <td align="left" valign="top" width="27%" id="d9998e534" headers="d9998e468 ">
                                    <p><code class="codeph">cust_id 120</code></p>
                                 </td>
                                 <td align="left" valign="top" width="27%" headers="d9998e534 d9998e471 ">
                                    <p>1</p>
                                 </td>
                                 <td align="left" valign="top" width="47%" headers="d9998e534 d9998e474 ">
                                    <p>0</p>
                                 </td>
                              </tr>
                              <tr align="left" valign="top">
                                 <td align="left" valign="top" width="27%" id="d9998e545" headers="d9998e468 ">
                                    <p><code class="codeph">cust_id 130</code></p>
                                 </td>
                                 <td align="left" valign="top" width="27%" headers="d9998e545 d9998e471 ">
                                    <p>1</p>
                                 </td>
                                 <td align="left" valign="top" width="47%" headers="d9998e545 d9998e474 ">
                                    <p>0</p>
                                 </td>
                              </tr>
                              <tr align="left" valign="top">
                                 <td align="left" valign="top" width="27%" id="d9998e556" headers="d9998e468 ">
                                    <p><code class="codeph">cust_id 140</code></p>
                                 </td>
                                 <td align="left" valign="top" width="27%" headers="d9998e556 d9998e471 ">
                                    <p>1</p>
                                 </td>
                                 <td align="left" valign="top" width="47%" headers="d9998e556 d9998e474 ">
                                    <p>0</p>
                                 </td>
                              </tr>
                           </tbody>
                        </table>
                     </div>
                     <!-- class="inftblhruleinformal" -->
                     <p>位图中的每个条目（或位）对应于<code class="codeph">customers</code>表的单个行。每个位的值取决于表中相应行的值。例如，位图<code class="codeph">cust_gender='F'</code>包含一个作为其第一位，因为在<code class="codeph">customers</code>表的第一行中性别为<code class="codeph">F</code>位图<code class="codeph">cust_gender='F'</code>的第三位为零，因为第三行的性别不是<code class="codeph">F</code></p>
                     <p>调查公司客户人口趋势的分析师可能会问：“我们的已婚客户中有多少人的收入水平为G或H？“这对应于以下查询：</p><pre class="oac_no_warn" dir="ltr">SELECT COUNT（*）FROM customers WHERE cust_marital_status ='married'AND_income_level IN（'H：150,000  -  169,999'，'G：130,000  -  149,999'）;</pre><p>位图索引可以通过仅计算<a href="data-warehouse-optimizations-techniques.html#GUID-7BD561A9-6B28-43A6-A5E0-B9AF196CF251__I1006355">图4-1</a>中<a href="data-warehouse-optimizations-techniques.html#GUID-7BD561A9-6B28-43A6-A5E0-B9AF196CF251__I1006355">所示</a>的位图中的<a href="data-warehouse-optimizations-techniques.html#GUID-7BD561A9-6B28-43A6-A5E0-B9AF196CF251__I1006355">1</a>的数量来有效地处理此查询。通过使用位图<code class="codeph">OR</code>合并操作可以找到结果集，而无需转换为rowid。要标识满足条件的其他特定客户属性，请使用生成的位图在位图到rowid转换后访问表。
                     </p>
                     <div class="figure" id="GUID-7BD561A9-6B28-43A6-A5E0-B9AF196CF251__I1006355">
                        <p class="titleinfigure">图4-1使用位图索引执行查询</p><img src="img/dwhsg093.gif" alt="下面是图4-1的描述" title="下面是图4-1的描述" longdesc="img_text/dwhsg093.html"><br><a href="img_text/dwhsg093.html">“图4-1使用位图索引执行查询”的描述</a></div>
                     <!-- class="figure" -->
                  </div>
               </div><a id="DWHSG9044"></a><div class="props_rev_3"><a id="GUID-017284C6-3D68-4469-BEB6-E3C6FB886A0C" name="GUID-017284C6-3D68-4469-BEB6-E3C6FB886A0C"></a><h4 id="DWHSG-GUID-017284C6-3D68-4469-BEB6-E3C6FB886A0C" class="sect4"><span class="enumeration_section">4.1.4</span>如何确定使用位图索引的候选者</h4>
                  <div>
                     <p>当单独查询事实表，索引列上有谓词，或者事实表与两个或多个维表连接，并且事实表中的外键列上有索引时，位图索引应该有用，并且维度表列上的谓词。</p>
                     <p>当满足以下条件时，事实表列是位图索引的候选者：</p>
                     <ul style="list-style-type:disc">
                        <li>
                           <p>索引列中的每个不同值都有100行或更多行。满足此限制时，位图索引将比常规索引小得多，并且您将能够比常规索引更快地创建索引。一个例子是数十亿行表中的一百万个不同的值。</p>
                        </li>
                     </ul>
                     <p>以下任何一种都是真的：</p>
                     <ul style="list-style-type:disc">
                        <li>
                           <p>索引列将在查询中受到限制（在<code class="codeph">WHERE</code>子句中引用）。
                           </p>
                        </li>
                     </ul>
                     <p>要么</p>
                     <ul style="list-style-type:disc">
                        <li>
                           <p>索引列是维度表的外键。在这种情况下，这样的指数将更有可能使星变换。</p>
                        </li>
                     </ul>
                  </div>
               </div><a id="DWHSG9047"></a><div class="props_rev_3"><a id="GUID-2BB63651-2ED9-41B3-838D-592CC1D6766F" name="GUID-2BB63651-2ED9-41B3-838D-592CC1D6766F"></a><h4 id="DWHSG-GUID-2BB63651-2ED9-41B3-838D-592CC1D6766F" class="sect4"><span class="enumeration_section">4.1.5</span>在数据仓库中使用位图连接索引</h4>
                  <div>
                     <p>此外<a id="d9998e669" class="indexterm-anchor"></a><a id="d9998e671" class="indexterm-anchor"></a>对于单个表上的位图索引，您可以创建位图连接索引，该索引是两个或多个表的连接的位图索引。在位图连接索引中，要为来自连接表的值构建要编制索引的表的位图。在数据仓库环境中，连接条件是维度表的主键列或事实表中的外键列之间的等内连接。
                     </p>
                     <p>位图连接索引可以将性能提高一个数量级。通过存储连接的结果，可以使用位图连接索引完全避免SQL语句的连接。此外，因为与连接列上的常规位图索引相比，位图连接索引最有可能具有更少数量的不同值，所以位图压缩得更好，与连接上的常规位图索引相比，空间消耗更少柱。</p>
                     <p>位图连接索引在存储方面比物化连接视图更有效，这是预先实现连接的替代方法。这是因为物化连接视图不压缩事实表的rowid。</p>
                     <p>B树和位图索引具有不同的最大列限制。</p>
                     <div class="infoboxnotealso" id="GUID-2BB63651-2ED9-41B3-838D-592CC1D6766F__GUID-ED545731-5592-42C8-A1D5-C0DCFE8F9AA5">
                        <p class="notep1">也可以看看：</p>
                        <ul style="list-style-type:disc">
                           <li>
                              <p><a href="data-warehouse-optimizations-techniques.html#GUID-ED40E4BD-23B9-44F9-9616-86E4C883D94A">数据仓库中位图连接索引的四种连接模型</a></p>
                           </li>
                           <li>
                              <p><a href="data-warehouse-optimizations-techniques.html#GUID-DE86EDE6-3D64-49C0-8909-A787140E3B9F">位图加入索引限制和要求</a></p>
                           </li>
                           <li>
                              <p>有关这些限制的详细信息，请<a href="../sqlrf/CREATE-INDEX.html#SQLRF54037" target="_blank"><span><cite>参见Oracle Database SQL语言参考</cite></span></a></p>
                           </li>
                        </ul>
                     </div>
                  </div><a id="DWHSG8143"></a><a id="DWHSG8144"></a><a id="DWHSG8145"></a><a id="DWHSG8146"></a><a id="DWHSG9048"></a><div class="props_rev_3"><a id="GUID-ED40E4BD-23B9-44F9-9616-86E4C883D94A" name="GUID-ED40E4BD-23B9-44F9-9616-86E4C883D94A"></a><h5 id="DWHSG-GUID-ED40E4BD-23B9-44F9-9616-86E4C883D94A" class="sect5"><span class="enumeration_section">4.1.5.1</span>数据仓库中位图连接索引的四种连接模型</h5>
                     <div>
                        <p>位图连接索引的最常见用法是在星型模型环境中，其中大型表在由一个或多个较小表连接的列上编制索引。大表称为事实表，较小的表称为维表。以下部分描述了位图连接索引支持的四种不同连接模型。</p>
                        <p>以下示例显示位图连接索引，其中一个维度表列连接一个事实表。与<a href="data-warehouse-optimizations-techniques.html#GUID-7BD561A9-6B28-43A6-A5E0-B9AF196CF251">关于基数和位图索引</a>的示例不同，其中构建了<code class="codeph">customers</code>表上<code class="codeph">cust_gender</code>列的位图索引，现在，您可以为已加入列<code class="codeph">customers(cust_gender)</code>的事实表<code class="codeph">sales</code>创建位图连接索引。表<code class="codeph">sales</code>仅存储<code class="codeph">cust_id</code>值：</p><pre class="oac_no_warn" dir="ltr">SELECT time_id，cust_id，amount_sold FROM sales; TIME_ID CUST_ID AMOUNT_SOLD --------- ---------- ----------- 01-JAN-98 29700 2291 01-JAN-98 3380 114 01-JAN -98 67830 553 01-JAN-98 179330 0 01-JAN-98 127520 195 01-JAN-98 33030 280 ...
</pre><p>要创建这样的位图连接索引，必须将列<code class="codeph">customers(cust_gender)</code>与表<code class="codeph">sales</code>联合起来。连接条件被指定为位图连接索引的<code class="codeph">CREATE</code>语句的一部分，如下所示：</p><pre class="oac_no_warn" dir="ltr">CREATE BITMAP INDEX sales_cust_gender_bjix ON sales（customers.cust_gender）FROM sales，customers WHERE sales.cust_id = customers.cust_id LOCAL NOLOGGING COMPUTE STATISTICS;</pre><p>以下查询显示用于创建存储在位图连接索引中的位图的连接结果：</p><pre class="oac_no_warn" dir="ltr">SELECT sales.time_id，customers.cust_gender，sales.amount_sold FROM sales，customers WHERE sales.cust_id = customers.cust_id; TIME_ID C AMOUNT_SOLD ---------  -  ----------- 01-JAN-98 M 2291 01-JAN-98 F 114 01-JAN-98 M 553 01-JAN-98 M 0 01-JAN-98 M 195 01-JAN-98 M 280 01-JAN-98 M 32 ...
</pre><p><a href="data-warehouse-optimizations-techniques.html#GUID-ED40E4BD-23B9-44F9-9616-86E4C883D94A__G1007505" title="示例位图连接索引">表4-2</a>说明了此示例中位图连接索引的位图表示。
                        </p>
                        <div class="tblformal" id="GUID-ED40E4BD-23B9-44F9-9616-86E4C883D94A__G1007505">
                           <p class="titleintable">表4-2位图连接索引示例</p>
                           <table cellpadding="4" cellspacing="0" class="Formal" title="示例位图连接索引" width="100%" border="1" summary="Sample Bitmap Join Index" frame="hsides" rules="rows">
                              <thead>
                                 <tr align="left" valign="top">
                                    <th align="left" valign="bottom" width="32%" id="d9998e789">销售记录</th>
                                    <th align="left" valign="bottom" width="31%" id="d9998e792">cust_gender = 'M'</th>
                                    <th align="left" valign="bottom" width="38%" id="d9998e795">cust_gender = 'F'</th>
                                 </tr>
                              </thead>
                              <tbody>
                                 <tr align="left" valign="top">
                                    <td align="left" valign="top" width="32%" id="d9998e800" headers="d9998e789 ">
                                       <p>销售记录1</p>
                                    </td>
                                    <td align="left" valign="top" width="31%" headers="d9998e800 d9998e792 ">
                                       <p>1</p>
                                    </td>
                                    <td align="left" valign="top" width="38%" headers="d9998e800 d9998e795 ">
                                       <p>0</p>
                                    </td>
                                 </tr>
                                 <tr align="left" valign="top">
                                    <td align="left" valign="top" width="32%" id="d9998e810" headers="d9998e789 ">
                                       <p>销售记录2</p>
                                    </td>
                                    <td align="left" valign="top" width="31%" headers="d9998e810 d9998e792 ">
                                       <p>0</p>
                                    </td>
                                    <td align="left" valign="top" width="38%" headers="d9998e810 d9998e795 ">
                                       <p>1</p>
                                    </td>
                                 </tr>
                                 <tr align="left" valign="top">
                                    <td align="left" valign="top" width="32%" id="d9998e820" headers="d9998e789 ">
                                       <p>销售记录3</p>
                                    </td>
                                    <td align="left" valign="top" width="31%" headers="d9998e820 d9998e792 ">
                                       <p>1</p>
                                    </td>
                                    <td align="left" valign="top" width="38%" headers="d9998e820 d9998e795 ">
                                       <p>0</p>
                                    </td>
                                 </tr>
                                 <tr align="left" valign="top">
                                    <td align="left" valign="top" width="32%" id="d9998e830" headers="d9998e789 ">
                                       <p>销售记录4</p>
                                    </td>
                                    <td align="left" valign="top" width="31%" headers="d9998e830 d9998e792 ">
                                       <p>1</p>
                                    </td>
                                    <td align="left" valign="top" width="38%" headers="d9998e830 d9998e795 ">
                                       <p>0</p>
                                    </td>
                                 </tr>
                                 <tr align="left" valign="top">
                                    <td align="left" valign="top" width="32%" id="d9998e840" headers="d9998e789 ">
                                       <p>销售记录5</p>
                                    </td>
                                    <td align="left" valign="top" width="31%" headers="d9998e840 d9998e792 ">
                                       <p>1</p>
                                    </td>
                                    <td align="left" valign="top" width="38%" headers="d9998e840 d9998e795 ">
                                       <p>0</p>
                                    </td>
                                 </tr>
                                 <tr align="left" valign="top">
                                    <td align="left" valign="top" width="32%" id="d9998e850" headers="d9998e789 ">
                                       <p>销售记录6</p>
                                    </td>
                                    <td align="left" valign="top" width="31%" headers="d9998e850 d9998e792 ">
                                       <p>1</p>
                                    </td>
                                    <td align="left" valign="top" width="38%" headers="d9998e850 d9998e795 ">
                                       <p>0</p>
                                    </td>
                                 </tr>
                                 <tr align="left" valign="top">
                                    <td align="left" valign="top" width="32%" id="d9998e860" headers="d9998e789 ">
                                       <p>销售记录7</p>
                                    </td>
                                    <td align="left" valign="top" width="31%" headers="d9998e860 d9998e792 ">
                                       <p>1</p>
                                    </td>
                                    <td align="left" valign="top" width="38%" headers="d9998e860 d9998e795 ">
                                       <p>0</p>
                                    </td>
                                 </tr>
                              </tbody>
                           </table>
                        </div>
                        <!-- class="inftblhruleinformal" -->
                        <p>您可以使用多个列或多个表创建其他位图连接索引，如这些示例所示。</p>
                        <div class="example" id="GUID-ED40E4BD-23B9-44F9-9616-86E4C883D94A__GUID-63280F75-D92E-4253-96CD-76C4ACA943E0">
                           <p class="titleinexample">示例4-2位图连接索引：多维列加入一个事实表</p>
                           <p>您可以在单个维度表中的多个列上创建位图连接索引，如以下示例所示，该示例使用来自<code class="codeph">sh</code>模式的<code class="codeph">customers(cust_gender, cust_marital_status)</code> ：</p><pre class="oac_no_warn" dir="ltr">CREATE BITMAP INDEX sales_cust_gender_ms_bjix ON sales（customers.cust_gender，customers.cust_marital_status）FROM sales，customers WHERE sales.cust_id = customers.cust_id LOCAL NOLOGGING COMPUTE STATISTICS;</pre></div>
                        <!-- class="example" -->
                        <div class="example" id="GUID-ED40E4BD-23B9-44F9-9616-86E4C883D94A__GUID-032899A1-681D-4FEE-91E4-995D5AC2B7A2">
                           <p class="titleinexample">示例4-3位图连接索引：多维表加入一个事实表</p>
                           <p>您可以在多个维度表上创建位图连接索引，如下所示，它使用<code class="codeph">customers(gender)</code>和<code class="codeph">products(category)</code> ：</p><pre class="oac_no_warn" dir="ltr">CREATE BITMAP INDEX sales_c_gender_p_cat_bjix ON sales（customers.cust_gender，products.prod_category）FROM sales，customers，products WHERE sales.cust_id = customers.cust_id AND sales.prod_id = products.prod_id LOCAL NOLOGGING COMPUTE STATISTICS;</pre></div>
                        <!-- class="example" -->
                        <div class="example" id="GUID-ED40E4BD-23B9-44F9-9616-86E4C883D94A__GUID-8D898CC8-DE27-4121-887C-766A09C66264">
                           <p class="titleinexample">示例4-4位图连接索引：雪花模式</p>
                           <p>您可以在多个表上创建位图连接索引，其中索引列通过使用另一个表连接到索引表。例如，您可以在<code class="codeph">countries.country_name</code>上构建索引，即使<code class="codeph">countries</code>表未直接连接到<code class="codeph">sales</code>表。而是将<code class="codeph">countries</code>表连接到<code class="codeph">customers</code>表，该表连接到<code class="codeph">sales</code>表。这种类型的模式通常称为<a href="glossary.html#GUID-D7A24E71-C96A-48CB-A4A8-C1D33FD2678A"><span class="xrefglossterm">雪花模式</span></a> 。
                           </p><pre class="oac_no_warn" dir="ltr">CREATE BITMAP INDEX sales_co_country_name_bjix ON sales（countries.country_name）FROM sales，customers，countries WHERE sales.cust_id = customers.cust_id AND customers.country_id = countries.country_id LOCAL NOLOGGING COMPUTE STATISTICS;</pre></div>
                        <!-- class="example" -->
                     </div>
                  </div><a id="DWHSG9049"></a><div class="props_rev_3"><a id="GUID-DE86EDE6-3D64-49C0-8909-A787140E3B9F" name="GUID-DE86EDE6-3D64-49C0-8909-A787140E3B9F"></a><h5 id="DWHSG-GUID-DE86EDE6-3D64-49C0-8909-A787140E3B9F" class="sect5"><span class="enumeration_section">4.1.5.2</span>位图连接索引限制和要求</h5>
                     <div>
                        <div class="section">
                           <p>必须存储连接结果，因此，位图连接索引具有以下限制：</p>
                           <ul style="list-style-type:disc">
                              <li>
                                 <p>并行DML仅在事实表上受支持。其中一个参与维度表上的并行DML会将索引标记为不可用。</p>
                              </li>
                              <li>
                                 <p>使用位图连接索引时，只有一个表可以由不同的事务同时更新。</p>
                              </li>
                              <li>
                                 <p>任何表都不能在连接中出现两次。</p>
                              </li>
                              <li>
                                 <p>您无法在临时表上创建位图连接索引。</p>
                              </li>
                              <li>
                                 <p>索引中的列必须都是维表的列。</p>
                              </li>
                              <li>
                                 <p>维度表连接列必须是主键列或具有唯一约束。</p>
                              </li>
                              <li>
                                 <p>参与与事实表的连接的维度表列必须是主键列或唯一约束。</p>
                              </li>
                              <li>
                                 <p>如果维度表具有复合主键，则主键中的每个列都必须是连接的一部分。</p>
                              </li>
                              <li>
                                 <p>创建常规位图索引的限制也适用于位图连接索引。例如，您无法使用<code class="codeph">UNIQUE</code>属性创建位图索引。有关其他限制，请参阅<a href="../sqlrf/CREATE-INDEX.html#SQLRF01209" target="_blank"><span><cite>Oracle数据库SQL语言参考</cite></span></a> 。
                                 </p>
                              </li>
                           </ul>
                        </div>
                        <!-- class="section" -->
                     </div>
                  </div>
               </div><a id="DWHSG9050"></a><div class="props_rev_3"><a id="GUID-DB336AF1-3550-4B89-AC53-9BDEE89327CA" name="GUID-DB336AF1-3550-4B89-AC53-9BDEE89327CA"></a><h4 id="DWHSG-GUID-DB336AF1-3550-4B89-AC53-9BDEE89327CA" class="sect4"><span class="enumeration_section">4.1.6</span>在数据仓库中使用B树索引</h4>
                  <div>
                     <p><a id="d9998e1010" class="indexterm-anchor"></a><a id="d9998e1012" class="indexterm-anchor"></a> B树索引的组织方式类似于颠倒的树。索引的底层保存实际数据值和指向相应行的指针，就像书中的索引具有与每个索引条目相关联的页码一样。
                     </p>
                     <p>通常，当您知道典型查询引用索引列并检索几行时，请使用B树索引。在这些查询中，通过查看索引来查找行会更快。但是，使用书籍索引类比，如果您打算查看书中的每个主题，您可能不希望查看主题的索引，然后查找页面。阅读本书的每一章可能会更快。同样，如果要检索表中的大多数行，查找索引以查找表行可能没有意义。相反，您可能想要读取或扫描表格。</p>
                     <p>B树索引最常用于数据仓库中以强制使用唯一键。在许多情况下，甚至可能不需要在数据仓库中索引这些列，因为唯一性是作为前面的ETL处理的一部分强制执行的，并且因为典型的数据仓库查询可能无法更好地使用这些索引。B树索引在使用第三范式模式的环境中更常见。通常，在大多数数据仓库环境中，位图索引应该比B树索引更常见。</p>
                     <p>B树和位图索引具有不同的最大列限制。有关这些限制，请参见<a href="../sqlrf/CREATE-INDEX.html#SQLRF54037" target="_blank"><span><cite>Oracle数据库SQL语言参考</cite></span></a> 。
                     </p>
                  </div>
               </div><a id="DWHSG9051"></a><div class="props_rev_3"><a id="GUID-31319B88-136B-4E29-92FC-0AD5B0B3CEE0" name="GUID-31319B88-136B-4E29-92FC-0AD5B0B3CEE0"></a><h4 id="DWHSG-GUID-31319B88-136B-4E29-92FC-0AD5B0B3CEE0" class="sect4"><span class="enumeration_section">4.1.7</span>使用索引压缩</h4>
                  <div>
                     <p>位图索引始终以专利的压缩方式存储，无需任何用户干预。但是，B树索引可以专门以压缩方式存储，以节省大量空间，在每个索引块中存储更多密钥，这也可以减少I / O和更好的性能。</p>
                     <p>密钥压缩使您可以压缩B树索引，从而减少重复值的存储开销。在非唯一索引的情况下，所有索引列可以以压缩格式存储，而在唯一索引的情况下，必须以未压缩的方式存储至少一个索引列。除了密钥压缩之外，OLTP索引压缩可以提供更高程度的压缩，但是比数据仓库环境更适合OLTP应用程序。</p>
                     <p>通常，索引中的键具有两个部分，分组部分和唯一部分。如果未将键定义为具有唯一片段，则Oracle数据库会以分组片段的形式提供一个rowid形式。密钥压缩是一种断开分组并存储它的方法，因此可以由多个独特的部分共享。要压缩的所选列的基数决定了可以实现的压缩比。因此，例如，如果由五列组成的唯一索引主要通过最后两列提供唯一性，则最佳选择要压缩存储的三个前导列。如果您选择压缩四列，重复性几乎消失，压缩率会更差。</p>
                     <p>虽然密钥压缩会降低索引的存储要求，但它可能会增加在索引扫描期间重建密钥列值所需的CPU时间。它还会产生一些额外的存储开销，因为每个前缀条目都有与之关联的四个字节的开销。</p>
                     <div class="infoboxnotealso" id="GUID-31319B88-136B-4E29-92FC-0AD5B0B3CEE0__GUID-FE68F4F0-4601-446E-BD17-9437FEA7D705">
                        <p class="notep1">也可以看看：</p>
                        <ul style="list-style-type:disc">
                           <li>
                              <p><a href="../admin/managing-tables.html#ADMIN11692" target="_blank"><span><cite>“Oracle数据库管理员指南”</cite></span></a> ，了解有关密钥压缩的更多信息</p>
                           </li>
                           <li>
                              <p>有关OLTP索引压缩的详细信息，请参见<a href="../admin/managing-indexes.html#ADMIN11731" target="_blank"><span><cite>“Oracle数据库管理员指南”</cite></span></a></p>
                           </li>
                        </ul>
                     </div>
                  </div>
               </div><a id="DWHSG9052"></a><div class="props_rev_3"><a id="GUID-BEC3FACE-B5B1-4904-9BC9-9CA060BB9C76" name="GUID-BEC3FACE-B5B1-4904-9BC9-9CA060BB9C76"></a><h4 id="DWHSG-GUID-BEC3FACE-B5B1-4904-9BC9-9CA060BB9C76" class="sect4"><span class="enumeration_section">4.1.8</span>在本地索引和全局索引之间进行选择</h4>
                  <div>
                     <p>分区表上的B树索引可以是全局的也可以是本地的。对于Oracle8 <span class="italic">i</span>和早期版本，Oracle建议不要在数据仓库环境中使用全局索引，因为分区DDL语句（例如， <code class="codeph">ALTER</code> <code class="codeph">TABLE</code> ...<code class="codeph">DROP</code> <code class="codeph">PARTITION</code> ）会使整个索引无效，重建索引的成本很高。可以在没有Oracle的情况下维护全局索引，在DDL之后将其标记为不可用，这使得全局索引对数据仓库环境有效。
                     </p>
                     <p>但是，本地索引将比全局索引更常见。当存在本地索引无法满足的特定要求时（例如，非分区键上的唯一索引或性能要求），应使用全局索引。</p>
                     <p>分区表上的位图索引始终是本地的。</p>
                  </div>
               </div>
            </div><a id="DWHSG8151"></a><div class="props_rev_3"><a id="GUID-3A627575-6C0D-4D86-8B86-2A85B02A5EC7" name="GUID-3A627575-6C0D-4D86-8B86-2A85B02A5EC7"></a><h3 id="DWHSG-GUID-3A627575-6C0D-4D86-8B86-2A85B02A5EC7" class="sect3"><span class="enumeration_section">4.2</span>在数据仓库中使用完整性约束</h3>
               <div>
                  <p><a id="d9998e1137" class="indexterm-anchor"></a><a id="d9998e1139" class="indexterm-anchor"></a>完整性约束提供了一种机制，可确保数据符合数据库管理员指定的准则。
                  </p>
                  <p>最常见的约束类型包括：</p>
                  <ul style="list-style-type:disc">
                     <li>
                        <p><code class="codeph">UNIQUE</code>约束</p>
                        <p>确保给定列是唯一的</p>
                     </li>
                     <li>
                        <p><code class="codeph">NOT</code> <code class="codeph">NULL</code>约束</p>
                        <p>确保不允许空值</p>
                     </li>
                     <li>
                        <p><code class="codeph">FOREIGN</code> <code class="codeph">KEY</code>约束</p>
                        <p>确保两个密钥共享主键到外键关系</p>
                     </li>
                  </ul>
                  <p>约束可以在数据仓库中用于这些目的：</p>
                  <ul style="list-style-type:disc">
                     <li>
                        <p>数据清洁度</p>
                        <p>约束验证数据仓库中的数据符合基本级别的数据一致性和正确性，从而防止引入脏数据。</p>
                     </li>
                     <li>
                        <p>查询优化</p>
                        <p>Oracle数据库在优化SQL查询时使用约束。虽然约束在查询优化的许多方面都很有用，但约束对于物化视图的查询重写尤为重要。</p>
                     </li>
                  </ul>
                  <p>与许多关系数据库环境中的数据不同，数据仓库中的数据通常在提取，转换和加载期间的受控环境中添加或修改（ <a id="d9998e1187" class="indexterm-anchor"></a> ETL）过程。多个用户通常不会像在OLTP系统中那样直接更新数据仓库。
                  </p>
                  <div class="infoboxnotealso" id="GUID-3A627575-6C0D-4D86-8B86-2A85B02A5EC7__GUID-BB811190-5A41-46F3-8579-E8FD22EEA027">
                     <p class="notep1">也可以看看：</p>
                     <ul style="list-style-type:disc">
                        <li>
                           <p><a href="etl-overview.html#GUID-50E33D2C-6F47-4449-8E49-90E4D7974A08">数据移动/ ETL概述</a></p>
                        </li>
                     </ul>
                  </div>
                  <p>本节包含以下主题：</p>
                  <ul style="list-style-type:disc">
                     <li>
                        <p><a href="data-warehouse-optimizations-techniques.html#GUID-FD72032A-105D-4E3E-9B08-7C0AB2095208">约束国概述</a></p>
                     </li>
                     <li>
                        <p><a href="data-warehouse-optimizations-techniques.html#GUID-906B8374-0CD7-4BF5-AA0F-925AD1D53E87">典型的数据仓库完整性约束</a></p>
                     </li>
                  </ul>
               </div><a id="DWHSG9053"></a><div class="props_rev_3"><a id="GUID-FD72032A-105D-4E3E-9B08-7C0AB2095208" name="GUID-FD72032A-105D-4E3E-9B08-7C0AB2095208"></a><h4 id="DWHSG-GUID-FD72032A-105D-4E3E-9B08-7C0AB2095208" class="sect4"><span class="enumeration_section">4.2.1</span>约束国概述</h4>
                  <div>
                     <p>要了解如何在数据仓库中使用约束，您应该首先了解约束的基本目的。
                     </p>
                     <p>其中一些目的是：</p>
                     <ul style="list-style-type:disc">
                        <li>
                           <p>强制</p>
                           <p>为了使用约束来强制执行，约束必须处于<code class="codeph">ENABLE</code>状态。启用的约束可确保对给定表（或多个表）的所有数据修改都满足约束条件。产生违反约束的数据的数据修改操作因约束违规错误而失败。
                           </p>
                        </li>
                        <li>
                           <p>验证</p>
                           <p>要使用约束进行验证，约束必须处于<code class="codeph">VALIDATE</code>状态。如果验证约束，则当前驻留在表中的所有数据都满足约束。
                           </p>
                           <p>请注意，验证与强制执行无关。虽然操作系统中的典型约束都已启用和验证，但是任何约束都可以被验证但不能启用，反之亦然（启用但未验证）。后两种情况对数据仓库很有用。</p>
                        </li>
                        <li>
                           <p>信仰</p>
                           <p>在某些情况下，您将知道给定约束的条件为真，因此您无需验证或强制执行约束。但是，您可能希望无论如何都存在约束以改进查询优化和性能。以这种方式使用约束时，它被称为置信约束或<code class="codeph">RELY</code>约束，约束必须处于<code class="codeph">RELY</code>状态。<code class="codeph">RELY</code>状态为您提供了一种机制，用于告知Oracle某个给定的约束被认为是真的。
                           </p>
                           <p>请注意， <code class="codeph">RELY</code>状态仅影响尚未验证的约束。
                           </p>
                        </li>
                     </ul>
                  </div>
               </div><a id="DWHSG9054"></a><div class="props_rev_3"><a id="GUID-906B8374-0CD7-4BF5-AA0F-925AD1D53E87" name="GUID-906B8374-0CD7-4BF5-AA0F-925AD1D53E87"></a><h4 id="DWHSG-GUID-906B8374-0CD7-4BF5-AA0F-925AD1D53E87" class="sect4"><span class="enumeration_section">4.2.2</span>典型数据仓库完整性约束</h4>
                  <div>
                     <p>本节假定您熟悉约束的典型用法。也就是说，启用和验证的约束。对于数据仓库，许多用户已经发现这样的约束可能构建和维护成本过高。讨论的主题是：</p>
                     <ul style="list-style-type:disc">
                        <li>
                           <p><a href="data-warehouse-optimizations-techniques.html#GUID-87A7A37B-8BE9-4B05-B6C6-373C843E3D7D">数据仓库中的UNIQUE约束</a></p>
                        </li>
                        <li>
                           <p><a href="data-warehouse-optimizations-techniques.html#GUID-791D9619-3AE8-4E2A-920A-4FF4A8F90643">数据仓库中的FOREIGN KEY约束</a></p>
                        </li>
                        <li>
                           <p><a href="data-warehouse-optimizations-techniques.html#GUID-5D3BD56C-E637-4F6D-940D-3D69E8A06A31">RELY数据仓库中的约束</a></p>
                        </li>
                        <li>
                           <p><a href="data-warehouse-optimizations-techniques.html#GUID-60854384-F566-4193-8457-AFF0598A2A52">数据仓库中的NOT NULL约束</a></p>
                        </li>
                        <li>
                           <p><a href="data-warehouse-optimizations-techniques.html#GUID-40C66E78-C107-4CB1-90BE-02A9ADCFF2B3">数据仓库中的完整性约束和并行性</a></p>
                        </li>
                        <li>
                           <p><a href="data-warehouse-optimizations-techniques.html#GUID-C98E4A18-20EE-4C95-A18E-3811BB714D01">数据仓库中的完整性约束和分区</a></p>
                        </li>
                        <li>
                           <p><a href="data-warehouse-optimizations-techniques.html#GUID-72719F57-92C2-4628-9E4E-0CA939C949A6">查看数据仓库中的约束</a></p>
                        </li>
                     </ul>
                  </div><a id="DWHSG9055"></a><div class="props_rev_3"><a id="GUID-87A7A37B-8BE9-4B05-B6C6-373C843E3D7D" name="GUID-87A7A37B-8BE9-4B05-B6C6-373C843E3D7D"></a><h5 id="DWHSG-GUID-87A7A37B-8BE9-4B05-B6C6-373C843E3D7D" class="sect5"><span class="enumeration_section">4.2.2.1</span>数据仓库中的UNIQUE约束</h5>
                     <div>
                        <p><a id="d9998e1358" class="indexterm-anchor"></a><a id="d9998e1362" class="indexterm-anchor"></a>通常使用<code class="codeph">UNIQUE</code>索引强制执行<code class="codeph">UNIQUE</code>约束。但是，在其表可能非常大的数据仓库中，创建唯一索引在处理时间和磁盘空间方面都会很昂贵。
                        </p>
                        <p>假设数据仓库包含表<code class="codeph">sales</code> ，其中包括<code class="codeph">sales_id</code>列。 <code class="codeph">sales_id</code>唯一标识单个销售事务，数据仓库管理员必须确保此列在数据仓库中是唯一的。
                        </p>
                        <p>创建约束的一种方法如下：</p><pre class="oac_no_warn" dir="ltr">ALTER TABLE sales ADD CONSTRAINT sales_uk UNIQUE（prod_id，cust_id，promo_id，channel_id，time_id）;</pre><p>默认情况下，此约束已启用并经过验证。Oracle隐式在<code class="codeph">sales_id</code>上创建唯一索引以支持此约束。但是，由于以下三个原因，此索引在数据仓库中可能存在问题：</p>
                        <ul style="list-style-type:disc">
                           <li>
                              <p>唯一索引可能非常大，因为<code class="codeph">sales</code>表可以轻松拥有数百万甚至数十亿行。
                              </p>
                           </li>
                           <li>
                              <p>唯一索引很少用于查询执行。大多数数据仓库查询没有唯一键的谓词，因此创建此索引可能无法提高性能。</p>
                           </li>
                           <li>
                              <p>如果<code class="codeph">sales</code>按照<code class="codeph">sales_id</code>以外的列进行分区，则唯一索引必须是全局的。这可能会对<code class="codeph">sales</code>表上的所有维护操作产生不利影响。
                              </p>
                           </li>
                        </ul>
                        <p>唯一约束需要唯一索引，以确保<code class="codeph">sales</code>表中修改的每个行都满足<code class="codeph">UNIQUE</code>约束。
                        </p>
                        <p>对于数据仓库表，以下语句中说明了唯一约束的备用机制：</p><pre class="oac_no_warn" dir="ltr">ALTER TABLE sales ADD CONSTRAINT sales_uk UNIQUE（prod_id，cust_id，promo_id，channel_id，time_id）DISABLE VALIDATE;</pre><p>此语句创建唯一约束，但是，由于禁用了约束，因此不需要唯一索引。这种方法对于许多数据仓库环境可能是有利的，因为约束现在确保了唯一性而没有唯一索引的成本。</p>
                        <p>但是，数据仓库管理员需要权衡使用<code class="codeph">DISABLE</code> <code class="codeph">VALIDATE</code>约束。由于禁用了此约束，因此不允许针对<code class="codeph">sales</code>表修改唯一列的DML语句。您可以使用以下两种策略之一在存在约束时修改此表：</p>
                        <ul style="list-style-type:disc">
                           <li>
                              <p>使用DDL向此表添加数据（例如交换分区）。请参阅<a href="refreshing-materialized-views.html#GUID-64068234-BDB0-4C12-AE70-75571046A586" title="每次在任何物化视图的基表上执行DML操作时，都会自动刷新使用ON STATEMENT刷新模式的物化视图。Oracle数据库对使用近似查询定义的物化视图执行快速刷新。在使用DBMS_REDEFINITION包在线重新定义表时，可以执行依赖于正在重新定义的表的快速可刷新实体化视图的增量刷新。您可以使用完整，快速或PCT刷新方法刷新基于混合分区表的实例化视图。">刷新实体化视图中</a>的示例。
                              </p>
                           </li>
                           <li>
                              <p>在修改此表之前，请删除约束。然后，进行所有必要的数据修改。最后，重新创建禁用的约束。重新创建约束比重新创建启用的约束更有效。但是，此方法不保证在删除约束时添加到<code class="codeph">sales</code>表的数据是唯一的。
                              </p>
                           </li>
                        </ul>
                     </div>
                  </div><a id="DWHSG9056"></a><div class="props_rev_3"><a id="GUID-791D9619-3AE8-4E2A-920A-4FF4A8F90643" name="GUID-791D9619-3AE8-4E2A-920A-4FF4A8F90643"></a><h5 id="DWHSG-GUID-791D9619-3AE8-4E2A-920A-4FF4A8F90643" class="sect5"><span class="enumeration_section">4.2.2.2</span>数据仓库中的外键约束</h5>
                     <div>
                        <p><a id="d9998e1485" class="indexterm-anchor"></a><a id="d9998e1489" class="indexterm-anchor"></a>在星型模式数据仓库中， <code class="codeph">FOREIGN</code> <code class="codeph">KEY</code>约束验证事实表和维度表之间的关系。示例约束可能是：</p><pre class="oac_no_warn" dir="ltr">ALTER TABLE sales ADD CONSTRAINT sales_time_fk FOREIGN KEY（time_id）REFERENCES times（time_id）ENABLE VALIDATE;</pre><p>但是，在某些情况下，您可以选择为<code class="codeph">FOREIGN</code> <code class="codeph">KEY</code>约束使用不同的状态，特别是<code class="codeph">ENABLE NOVALIDATE</code>状态。在以下任一情况下，数据仓库管理员可能会使用<code class="codeph">ENABLE NOVALIDATE</code>约束：</p>
                        <ul style="list-style-type:disc">
                           <li>
                              <p>这些表包含当前违反约束的数据，但数据仓库管理员希望为将来的实施创建约束。</p>
                           </li>
                           <li>
                              <p>立即需要强制约束。</p>
                           </li>
                        </ul>
                        <p>假设数据仓库每天将新数据加载到事实表中，但仅在周末刷新维度表。在一周内，维度表和事实表实际上可能违反<code class="codeph">FOREIGN</code> <code class="codeph">KEY</code>约束。但是，数据仓库管理员可能希望保持此约束的强制执行，以防止可能影响ETL过程之外的<code class="codeph">FOREIGN</code> <code class="codeph">KEY</code>约束的任何更改。因此，您可以在执行ETL过程后每晚创建<code class="codeph">FOREIGN</code> <code class="codeph">KEY</code>约束，如下所示：</p><pre class="oac_no_warn" dir="ltr">ALTER TABLE sales ADD CONSTRAINT sales_time_fk FOREIGN KEY（time_id）REFERENCES times（time_id）ENABLE NOVALIDATE;</pre><p>即使限制被认为是真的， <code class="codeph">ENABLE</code> <code class="codeph">NOVALIDATE</code>也可以快速创建强制约束。假设ETL过程验证<code class="codeph">FOREIGN</code> <code class="codeph">KEY</code>约束是否为真。而不具备数据库重新验证该<code class="codeph">FOREIGN</code> <code class="codeph">KEY</code>约束，这需要时间和数据库资源，数据仓库管理员可以改为创建一个<code class="codeph">FOREIGN</code> <code class="codeph">KEY</code>使用约束<code class="codeph">ENABLE</code> <code class="codeph">NOVALIDATE</code> 。</p>
                     </div>
                  </div><a id="DWHSG9057"></a><div class="props_rev_3"><a id="GUID-5D3BD56C-E637-4F6D-940D-3D69E8A06A31" name="GUID-5D3BD56C-E637-4F6D-940D-3D69E8A06A31"></a><h5 id="DWHSG-GUID-5D3BD56C-E637-4F6D-940D-3D69E8A06A31" class="sect5"><span class="enumeration_section">4.2.2.3</span>数据仓库中的RELY约束</h5>
                     <div>
                        <p><a id="d9998e1600" class="indexterm-anchor"></a><a id="d9998e1602" class="indexterm-anchor"></a> ETL过程通常验证某些约束是否正确。例如，它可以验证进入事实表的数据中的所有外键。这意味着您可以信任它来提供干净的数据，而不是在数据仓库中实现约束。您创建<code class="codeph">RELY</code>约束，如下所示：</p><pre class="oac_no_warn" dir="ltr">ALTER TABLE sales ADD CONSTRAINT sales_time_fk FOREIGN KEY（time_id）REFERENCES times（time_id）RELY DISABLE NOVALIDATE;</pre><p>此语句假定主键处于<code class="codeph">RELY</code>状态。<code class="codeph">RELY</code>约束，即使它们不用于数据验证，也可以：</p>
                        <ul style="list-style-type:disc">
                           <li>
                              <p>为物化视图启用更复杂的查询重写。有关更多详细信息，请参阅<a href="basic-query-rewrite-materialized-views.html#GUID-DB76286B-8557-446B-A6CC-BC987C378076" title="查询经过多次检查以确定它是否是查询重写的候选者。如果查询未通过任何检查，则查询将应用于详细信息表而不是物化视图。在响应时间和处理能力方面，无法重写可能代价高昂。查询重写行为由某些数据库初始化参数控制。查询重写提供了三个级别的重写完整性，这些级别由初始化参数QUERY_REWRITE_INTEGRITY控制。此示例说明了使用实例化视图重写查询的强大功能。">物化视图的基本查询重写</a> 。
                              </p>
                           </li>
                           <li>
                              <p>启用其他数据仓库工具，以直接从Oracle数据字典中检索有关约束的信息。</p>
                           </li>
                        </ul>
                        <p>创建<code class="codeph">RELY</code>约束很便宜，并且在DML或加载期间不会产生任何开销。由于未验证约束，因此无需进行数据处理即可创建约束。
                        </p>
                     </div>
                  </div><a id="DWHSG9058"></a><div class="props_rev_3"><a id="GUID-60854384-F566-4193-8457-AFF0598A2A52" name="GUID-60854384-F566-4193-8457-AFF0598A2A52"></a><h5 id="DWHSG-GUID-60854384-F566-4193-8457-AFF0598A2A52" class="sect5"><span class="enumeration_section">4.2.2.4</span>数据仓库中的NOT NULL约束</h5>
                     <div>
                        <p>使用查询重写时，应考虑是否需要<code class="codeph">NOT</code> <code class="codeph">NULL</code>约束。您需要使用它们的主要情况是加入返回查询重写。
                        </p>
                        <div class="infoboxnotealso" id="GUID-60854384-F566-4193-8457-AFF0598A2A52__GUID-EC0FE4BA-D960-4A0E-B8B4-F5BAB9B44DCA">
                           <p class="notep1">也可以看看：</p>
                           <ul style="list-style-type:disc">
                              <li>
                                 <p><a href="advanced-query-rewrite-materialized-views.html#GUID-0906CA6B-7EE3-42E1-A598-C6541BCD9B36" title="查询重写认为混合分区表中的外部分区具有UNKNOWN新鲜度。因此，当查询从一个或多个外部分区请求数据时，它只能在TRUSTED或STALE_TOLERATED完整性模式下重写。如果可以使用物化视图回答这些查询，则会自动重写包含返回近似结果的SQL函数的查询以使用匹配的物化视图。可以重写对整数列包含COUNT（DISTINCT）操作的查询，以使用包含基于位图的函数的实体化视图。">物化视图的高级查询重写，</a>以获取有关使用查询重写时<code class="codeph">NOT</code> <code class="codeph">NULL</code>约束的更多信息</p>
                              </li>
                           </ul>
                        </div>
                     </div>
                  </div><a id="DWHSG9059"></a><div class="props_rev_3"><a id="GUID-40C66E78-C107-4CB1-90BE-02A9ADCFF2B3" name="GUID-40C66E78-C107-4CB1-90BE-02A9ADCFF2B3"></a><h5 id="DWHSG-GUID-40C66E78-C107-4CB1-90BE-02A9ADCFF2B3" class="sect5"><span class="enumeration_section">4.2.2.5</span>数据仓库中的完整性约束和并行性</h5>
                     <div>
                        <p>可以并行验证所有约束。在验证非常大的表上的约束时，通常需要并行性来满足性能目标。给定约束操作的并行度由基础表的默认并行度确定。</p>
                     </div>
                  </div><a id="DWHSG9060"></a><div class="props_rev_3"><a id="GUID-C98E4A18-20EE-4C95-A18E-3811BB714D01" name="GUID-C98E4A18-20EE-4C95-A18E-3811BB714D01"></a><h5 id="DWHSG-GUID-C98E4A18-20EE-4C95-A18E-3811BB714D01" class="sect5"><span class="enumeration_section">4.2.2.6</span>数据仓库中的完整性约束和分区</h5>
                     <div>
                        <p><a id="d9998e1740" class="indexterm-anchor"></a>在对数据进行分区之前，可以创建和维护约束。后面的章节讨论了数据仓库分区的重要性。分区可以改善约束管理，就像管理许多其他操作一样。例如， <a href="refreshing-materialized-views.html#GUID-64068234-BDB0-4C12-AE70-75571046A586" title="每次在任何物化视图的基表上执行DML操作时，都会自动刷新使用ON STATEMENT刷新模式的物化视图。Oracle数据库对使用近似查询定义的物化视图执行快速刷新。在使用DBMS_REDEFINITION包在线重新定义表时，可以执行依赖于正在重新定义的表的快速可刷新实体化视图的增量刷新。您可以使用完整，快速或PCT刷新方法刷新基于混合分区表的实例化视图。">Refreshing Materialized Views</a>提供了在单独的临时表上创建<code class="codeph">UNIQUE</code>和<code class="codeph">FOREIGN</code> <code class="codeph">KEY</code>约束的方案，并且这些约束在<a id="d9998e1767" class="indexterm-anchor"></a> <code class="codeph">EXCHANGE</code> <code class="codeph">PARTITION</code>声明。
                        </p>
                        <p></p>
                        <p>对于外部表，只能在<code class="codeph">DISABLE</code>模式下定义<code class="codeph">RELY</code>约束。这适用于主键，唯一键和外键约束。
                        </p>
                     </div>
                  </div><a id="DWHSG9061"></a><div class="props_rev_3"><a id="GUID-72719F57-92C2-4628-9E4E-0CA939C949A6" name="GUID-72719F57-92C2-4628-9E4E-0CA939C949A6"></a><h5 id="DWHSG-GUID-72719F57-92C2-4628-9E4E-0CA939C949A6" class="sect5"><span class="enumeration_section">4.2.2.7</span>查看数据仓库中的约束</h5>
                     <div>
                        <p>您可以<a id="d9998e1808" class="indexterm-anchor"></a><a id="d9998e1810" class="indexterm-anchor"></a>创建视图约束。视图支持的唯一约束类型是<code class="codeph">RELY</code>约束。
                        </p>
                        <p>当查询通常访问视图而不是基表时，这种类型的约束很有用，因此数据库管理员需要定义视图而不是表之间的数据关系。</p>
                        <div class="infoboxnotealso" id="GUID-72719F57-92C2-4628-9E4E-0CA939C949A6__GUID-8575DCC0-A6B9-4290-997E-35D4BF1852CE">
                           <p class="notep1">也可以看看：</p>
                           <ul style="list-style-type:disc">
                              <li>
                                 <p><a href="basic-materialized-views.html#GUID-A7AE8E5D-68A5-4519-81EB-252EAAF0ADFF" title="如果物化视图仅包含连接，则每个表的ROWID列（以及在FROM列表中多次出现的表的每个实例）必须存在于实例化视图的SELECT列表中。可以使用CREATE MATERIALIZED VIEW语句或使用Enterprise Manager创建实例化视图。使用CREATE MATERIALIZED VIEW语句创建基于混合分区表的物化视图。基于近似查询的物化视图使用SQL函数，该函数在其定义查询中返回近似函数。基于COUNT（DISTINCT）函数的物化视图可以通过对整数列使用基于位图的操作来提供增强的性能。">基本物化观点</a></p>
                              </li>
                              <li>
                                 <p><a href="basic-query-rewrite-materialized-views.html#GUID-DB76286B-8557-446B-A6CC-BC987C378076" title="查询经过多次检查以确定它是否是查询重写的候选者。如果查询未通过任何检查，则查询将应用于详细信息表而不是物化视图。在响应时间和处理能力方面，无法重写可能代价高昂。查询重写行为由某些数据库初始化参数控制。查询重写提供了三个级别的重写完整性，这些级别由初始化参数QUERY_REWRITE_INTEGRITY控制。此示例说明了使用实例化视图重写查询的强大功能。">物化视图的基本查询重写</a></p>
                              </li>
                           </ul>
                        </div>
                     </div>
                  </div>
               </div>
            </div><a id="DWHSG9062"></a><div class="props_rev_3"><a id="GUID-2207CC57-A4D8-4ED1-8676-151EFD7E3528" name="GUID-2207CC57-A4D8-4ED1-8676-151EFD7E3528"></a><h3 id="DWHSG-GUID-2207CC57-A4D8-4ED1-8676-151EFD7E3528" class="sect3"><span class="enumeration_section">4.3</span>关于数据仓库中的并行执行</h3>
               <div>
                  <p>今天的数据库，无论是数据仓库，运营数据存储还是OLTP系统，都包含大量信息。但是，由于涉及大量数据，及时查找和提供正确的信息可能是一项挑战。
                  </p>
                  <p>并行执行是解决这一挑战的能力。使用并行执行（也称为并行），可以在几分钟内处理数TB的数据，而不是数小时或数天，只需使用多个进程即可完成单个任务。这大大缩短了通常与决策支持系统（DSS）和数据仓库相关联的大型数据库上数据密集型操作的响应时间。您还可以在OLTP系统上实现并行执行以进行批处理或模式维护操作（如索引创建）。并行性是分解任务的想法，因此，不是一个进程在查询中完成所有工作，而是许多进程同时完成部分工作。这方面的一个例子是，当四个流程组合起来计算一年的总销售额时，每个流程处理一年中的四分之一，而不是单独处理所有四个季度的流程。性能的提高可能非常显着。</p>
                  <p>并行执行改进了以下处理：</p>
                  <ul style="list-style-type:disc">
                     <li>
                        <p>查询需要大型表扫描，联接或分区索引扫描</p>
                     </li>
                     <li>
                        <p>创建大型索引</p>
                     </li>
                     <li>
                        <p>创建大表（包括物化视图）</p>
                     </li>
                     <li>
                        <p>批量插入，更新，合并和删除</p>
                     </li>
                  </ul>
                  <p>您还可以使用并行执行来访问Oracle数据库中的对象类型。例如，您可以使用并行执行来访问大对象（LOB）。</p>
                  <p>大型数据仓库应始终使用并行执行来实现良好的性能。OLTP应用程序中的特定操作（例如批处理操作）也可以从并行执行中获益。</p>
                  <p>本节包含以下主题：</p>
                  <ul style="list-style-type:disc">
                     <li>
                        <p><a href="data-warehouse-optimizations-techniques.html#GUID-86C93668-2C9B-4538-9F75-B0FC4072B238">为什么要使用并行执行？</a></p>
                     </li>
                     <li>
                        <p><a href="data-warehouse-optimizations-techniques.html#GUID-CB273100-91D8-49DA-9B3A-614A8CF5E33C">自动并行度和语句排队</a></p>
                     </li>
                     <li>
                        <p><a href="data-warehouse-optimizations-techniques.html#GUID-31B144E1-8F0A-4DFB-AC2E-5A27EAF2A6FD">关于数据仓库中的内存中并行执行</a></p>
                     </li>
                  </ul>
               </div><a id="DWHSG9063"></a><div class="props_rev_3"><a id="GUID-86C93668-2C9B-4538-9F75-B0FC4072B238" name="GUID-86C93668-2C9B-4538-9F75-B0FC4072B238"></a><h4 id="DWHSG-GUID-86C93668-2C9B-4538-9F75-B0FC4072B238" class="sect4"><span class="enumeration_section">4.3.1</span>为什么使用并行执行？
                  </h4>
                  <div>
                     <p>想象一下，你的任务是计算街道上的汽车数量。有两种方法可以做到这一点。一，你可以自己走过街道并计算汽车的数量，或者你可以招募一个朋友，然后你们两个可以从街道的两端开始，计算汽车，直到你们相遇并添加两者的结果计算完成任务。</p>
                     <p>假设你的朋友和你的朋友一样快，你就可以完成计算街道上所有汽车的任务，大约是你自己完成工作时的一半。如果是这种情况，那么您的操作将线性扩展。也就是说，资源数量的两倍使总处理时间减半。</p>
                     <p>数据库与计数车的例子没有太大区别。如果分配两倍的资源数量并且处理时间是原始资源量的一半，则操作将线性扩展。线性缩放是并行处理的最终目标，既可用于计算汽车，也可用于从数据库查询中提供答案。</p>
                     <div class="infoboxnotealso" id="GUID-86C93668-2C9B-4538-9F75-B0FC4072B238__GUID-1DFA9FCB-C7FD-4AD5-8EFD-C7EF4D4EE4A2">
                        <p class="notep1">也可以看看：</p>
                        <ul style="list-style-type:disc">
                           <li>
                              <p>有关使用并行执行的更多信息<a href="../vldbg/using-parallel.html#VLDBG010" target="_blank"><span><cite>，请参见“Oracle数据库VLDB和分区指南”</cite></span></a></p>
                           </li>
                        </ul>
                     </div>
                     <p>以下主题提供了有关并行执行有用的方案的指导：</p>
                     <ul style="list-style-type:disc">
                        <li>
                           <p><a href="data-warehouse-optimizations-techniques.html#GUID-C70CA94F-C5C0-4B49-9EF9-E96F37AE125B">何时实施并行执行</a></p>
                        </li>
                        <li>
                           <p><a href="data-warehouse-optimizations-techniques.html#GUID-AC9BB244-D331-4F8E-B7E7-A1D79E7EA673">何时不实施并行执行</a></p>
                        </li>
                     </ul>
                  </div><a id="DWHSG9064"></a><div class="props_rev_3"><a id="GUID-C70CA94F-C5C0-4B49-9EF9-E96F37AE125B" name="GUID-C70CA94F-C5C0-4B49-9EF9-E96F37AE125B"></a><h5 id="DWHSG-GUID-C70CA94F-C5C0-4B49-9EF9-E96F37AE125B" class="sect5"><span class="enumeration_section">4.3.1.1</span>何时实施并行执行</h5>
                     <div>
                        <p>并行执行有益于具有以下所有特征的系统：</p>
                        <ul style="list-style-type:disc">
                           <li>
                              <p>对称多处理器（SMP），集群或大规模并行系统</p>
                           </li>
                           <li>
                              <p>足够的I / O带宽</p>
                           </li>
                           <li>
                              <p>未充分利用或间歇使用的CPU（例如，CPU使用率通常低于30％的系统）</p>
                           </li>
                           <li>
                              <p>足够的内存来支持额外的内存密集型进程，例如排序，散列和I / O缓冲区</p>
                           </li>
                        </ul>
                        <p>如果您的系统缺少任何这些特性，并行执行可能不会显着提高性能。事实上，并行执行可能会降低过度使用系统或I / O带宽较小的系统的系统性能。</p>
                        <p>在DSS和数据仓库环境中可以看到并行执行的好处。OLTP系统还可以在批处理期间和模式维护操作（如创建索引）期间从并行执行中受益。访问或操作小型记录集甚至单个记录的平均简单DML或<code class="codeph">SELECT</code>语句，表征OLTP应用程序，并不会看到并行执行的任何好处。
                        </p>
                     </div>
                  </div><a id="DWHSG9065"></a><div class="props_rev_3"><a id="GUID-AC9BB244-D331-4F8E-B7E7-A1D79E7EA673" name="GUID-AC9BB244-D331-4F8E-B7E7-A1D79E7EA673"></a><h5 id="DWHSG-GUID-AC9BB244-D331-4F8E-B7E7-A1D79E7EA673" class="sect5"><span class="enumeration_section">4.3.1.2</span>何时不实现并行执行</h5>
                     <div>
                        <p>并行执行通常不适用于：</p>
                        <ul style="list-style-type:disc">
                           <li>
                              <p>典型查询或事务非常短（几秒或更短）的环境。这包括大多数在线交易系统。并行执行在这些环境中没有用，因为协调并行执行服务器会产生相关成本;对于短期交易，这种协调的成本可能超过并行性的好处。</p>
                           </li>
                           <li>
                              <p>即使并行执行，也会大量使用CPU，内存或I / O资源的环境。并行执行旨在利用额外的可用硬件资源;如果没有这样的资源，那么并行执行不会产生任何好处，实际上可能对性能有害。</p>
                           </li>
                        </ul>
                     </div>
                  </div>
               </div><a id="DWHSG9067"></a><a id="DWHSG9066"></a><div class="props_rev_3"><a id="GUID-CB273100-91D8-49DA-9B3A-614A8CF5E33C" name="GUID-CB273100-91D8-49DA-9B3A-614A8CF5E33C"></a><h4 id="DWHSG-GUID-CB273100-91D8-49DA-9B3A-614A8CF5E33C" class="sect4"><span class="enumeration_section">4.3.2</span>自动并行度和语句排队</h4>
                  <div>
                     <p>顾名思义，自动并行度是Oracle数据库根据执行成本（CPU，I / O的资源消耗）确定运行语句（DML，DDL和查询）的并行度（DOP）的地方。和记忆 - 由优化器决定。这意味着数据库会解析查询，计算成本，然后确定要运行的DOP。最便宜的计划可能是连续运行，这也是一种选择。<a href="data-warehouse-optimizations-techniques.html#GUID-CB273100-91D8-49DA-9B3A-614A8CF5E33C__CIHGFIID">图4-2</a>说明了这一决策过程。
                     </p>
                     <div class="figure" id="GUID-CB273100-91D8-49DA-9B3A-614A8CF5E33C__CIHGFIID">
                        <p class="titleinfigure">图4-2优化器计算：串行还是并行？</p><img src="img/dwhsg132.gif" alt="下面是图4-2的描述" title="下面是图4-2的描述" longdesc="img_text/dwhsg132.html"><br><a href="img_text/dwhsg132.html">“图4-2优化器计算：串行还是并行？“</a></div>
                     <!-- class="figure" -->
                     <p>如果您选择使用自动DOP，您可能会看到更多并行运行的语句，特别是如果阈值相对较低，其中low是相对于系统而不是绝对量词。</p>
                     <p>由于与自动DOP并行运行的更多语句的这种预期行为，管理可用并行进程的利用率变得更加重要。这意味着系统必须知道何时运行语句并验证所请求的并行进程数是否可用。请求的进程数是该语句的DOP。</p>
                     <p>此工作负载管理问题的答案是使用数据库资源管理器进行并行语句排队。并行语句排队在其请求的DOP可用时运行语句。例如，当一个语句请求DOP为64时，如果当前只有32个进程可以自由地协助该客户，则它将不会运行，因此该语句将被放入队列中。</p>
                     <p>使用数据库资源管理器，您可以通过使用者组将语句分类为工作负载。然后可以为每个消费者群体提供适当的优先级和适当级别的并行流程。每个使用者组也有自己的队列，以根据系统负载对并行语句进行排队。</p>
                     <div class="infoboxnotealso" id="GUID-CB273100-91D8-49DA-9B3A-614A8CF5E33C__GUID-A9E604BC-5D37-44C8-8133-5ABF3D5ADFEF">
                        <p class="notep1">也可以看看：</p>
                        <ul style="list-style-type:disc">
                           <li>
                              <p>有关使用并行执行的自动DOP的详细信息<a href="../vldbg/degree-parallel.html#VLDBG0103" target="_blank"><span><cite>，请参见“Oracle数据库VLDB和分区指南”</cite></span></a></p>
                           </li>
                           <li>
                              <p><a href="../admin/managing-resources-with-oracle-database-resource-manager.html#ADMIN027" target="_blank"><span><cite>“Oracle数据库管理员指南”</cite></span></a> ，了解有关使用数据库资源管理器的更多信息</p>
                           </li>
                        </ul>
                     </div>
                  </div>
               </div><a id="DWHSG9068"></a><div class="props_rev_3"><a id="GUID-31B144E1-8F0A-4DFB-AC2E-5A27EAF2A6FD" name="GUID-31B144E1-8F0A-4DFB-AC2E-5A27EAF2A6FD"></a><h4 id="DWHSG-GUID-31B144E1-8F0A-4DFB-AC2E-5A27EAF2A6FD" class="sect4"><span class="enumeration_section">4.3.3</span>关于数据仓库中的内存中并行执行</h4>
                  <div>
                     <p>传统上，并行处理绕过大多数操作的数据库缓冲区高速缓存，直接从磁盘（通过直接路径I / O）读取数据到并行执行服务器的私有工作空间。只有小于<code class="codeph">DB_CACHE_SIZE</code>约2％的对象才会缓存在实例的数据库缓冲区缓存中，并且大多数并行访问的对象都大于此限制。这种行为意味着并行处理很少利用可用内存而不是私有处理。然而，在过去十年中，硬件系统已经发生了巨大变化;典型数据库服务器上的内存容量现在是两位或三位千兆字节范围。这与Oracle的压缩技术和Oracle数据库利用Oracle Real Application Clusters环境的聚合数据库缓冲区缓存的功能一起，可以缓存TB级别的对象。
                     </p>
                     <p>内存中并行执行利用了这个大型聚合数据库缓冲区缓存。让并行执行服务器使用缓冲区高速缓存访问对象，可以对大量数据进行完全并行的内存处理，从而提高数量级的性能。</p>
                     <p>对于内存中并行执行，当并行发出SQL语句时，将执行检查以确定语句访问的对象是否应缓存在系统的聚合缓冲区高速缓存中。在此上下文中，对象可以是表，索引，或者在分区对象的情况下，可以是一个或多个分区。</p>
                     <div class="infoboxnotealso" id="GUID-31B144E1-8F0A-4DFB-AC2E-5A27EAF2A6FD__GUID-AA11E37F-5091-4A34-BA3F-2A8BC114B20C">
                        <p class="notep1">也可以看看：</p>
                        <ul style="list-style-type:disc">
                           <li>
                              <p>有关使用内存中并行执行的更多信息，请参见<a href="../vldbg/inmemory-parallel-exec.html#VLDBG13912" target="_blank"><span><cite>“Oracle数据库VLDB和分区指南”</cite></span></a></p>
                           </li>
                        </ul>
                     </div>
                  </div>
               </div>
            </div><a id="DWHSG8912"></a><div class="props_rev_3"><a id="GUID-11CD602C-2C37-4771-97A6-CFFEABB4259D" name="GUID-11CD602C-2C37-4771-97A6-CFFEABB4259D"></a><h3 id="DWHSG-GUID-11CD602C-2C37-4771-97A6-CFFEABB4259D" class="sect3"><span class="enumeration_section">4.4</span>关于优化数据仓库中的存储要求</h3>
               <div>
                  <p>您可以<a id="d9998e2171" class="indexterm-anchor"></a>通过压缩数据来减少存储需求，这可以通过消除数据库块中的重复值来实现。 <span class="q">“ <a href="data-warehouse-optimizations-techniques.html#GUID-60520E82-64E3-45D1-95D3-8628CE7B99CE">使用数据压缩来改善数据仓库中的存储</a> ”</span>介绍了如何使用压缩数据。
                  </p>
                  <p>可以压缩的数据库对象包括表和物化视图。对于分区表，您可以压缩部分或全部分区。可以为表空间，表或表的分区声明压缩属性。如果在表空间级别声明，则默认情况下会压缩在该表空间中创建的所有表。您可以更改表（或分区或表空间）的压缩属性，并且更改仅适用于进入该表的新数据。因此，单个表或分区可能包含一些压缩块和一些常规块。这可以保证数据大小不会因压缩而增加。在压缩可能增加块大小的情况下，它不会应用于该块。</p>
               </div><a id="DWHSG8914"></a><a id="DWHSG8913"></a><div class="props_rev_3"><a id="GUID-60520E82-64E3-45D1-95D3-8628CE7B99CE" name="GUID-60520E82-64E3-45D1-95D3-8628CE7B99CE"></a><h4 id="DWHSG-GUID-60520E82-64E3-45D1-95D3-8628CE7B99CE" class="sect4"><span class="enumeration_section">4.4.1</span>使用数据压缩改善数据仓库中的存储</h4>
                  <div>
                     <div class="section">
                        <p>您可以编译多个分区或完整的分区堆组织表。您可以通过将完整的分区表定义为压缩或通过在每个分区级别定义它来执行此操作。没有特定声明的分区从表定义继承该属性，或者，如果在表级别上没有指定任何内容，则从表空间定义继承该属性。
                        </p>
                        <p>关于是否应该压缩分区的决定基于与非分区表相同的规则。由于范围和复合分区能够将逻辑上的数据分离到不同的分区，因此分区表是压缩主要是只读的部分数据（分区）的理想选择。例如，在所有滚动窗口操作中作为老化数据老化之前的一种中间阶段是有益的。通过数据压缩，您可以在线保留更多旧数据，从而最大限度地减少额外存储使用的负担。</p>
                        <p>您还可以稍后更改任何现有的未压缩表分区，添加新的压缩和未压缩分区，或者将压缩属性更改为需要数据移动的任何分区维护操作的一部分，例如<a id="d9998e2214" class="indexterm-anchor"></a> <code class="codeph">MERGE</code> <code class="codeph">PARTITION</code> ， <a id="d9998e2222" class="indexterm-anchor"></a> <code class="codeph">SPLIT</code> <code class="codeph">PARTITION</code> ，或<a id="d9998e2231" class="indexterm-anchor"></a> <code class="codeph">MOVE</code> <code class="codeph">PARTITION</code> 。分区可以包含数据，也可以为空。
                        </p>
                        <p>部分或完全压缩的分区表的访问和维护与完全未压缩的分区表的访问和维护相同。适用于完全未压缩的分区表的所有规则对部分或完全压缩的分区表也有效。</p>
                     </div>
                     <!-- class="section" -->
                     <div class="section">
                        <p class="subhead3" id="GUID-60520E82-64E3-45D1-95D3-8628CE7B99CE__GUID-2E855E8D-8E3D-4ECC-98A3-F1EF1ED784FB">要使用数据压缩：</p>
                     </div>
                     <!-- class="section" -->
                     <div class="section">
                        <p>以下示例创建一个<a id="d9998e2247" class="indexterm-anchor"></a>范围分区表，其中包含一个压缩分区<code class="codeph">costs_old</code> 。表和所有其他分区的compression属性继承自表空间级别。
                        </p><pre class="oac_no_warn" dir="ltr">CREATE TABLE costs_demo（prod_id NUMBER（6），time_id DATE，unit_cost NUMBER（10,2），unit_price NUMBER（10,2））PARTITION BY RANGE（time_id）（PARTITION costs_old VALUES少于（TO_DATE（'01 -JAN-2003） '，'DD-MON-YYYY'））COMPRESS，PARTITION costs_q1_2003价值不到（截止日期（'01-APR-2003'，'DD-MON-YYYY'）），PARTITION costs_q2_2003价值不到（截止到4月1日） JUN-2003'，'DD-MON-YYYY'）），PARTITION cost_recent VALUES少于（MAXVALUE））;</pre></div>
                     <!-- class="section" -->
                  </div>
               </div>
            </div><a id="DWHSG8591"></a><div class="props_rev_3"><a id="GUID-3AF4B9BF-F429-4AAF-983A-6F722484D0E2" name="GUID-3AF4B9BF-F429-4AAF-983A-6F722484D0E2"></a><h3 id="DWHSG-GUID-3AF4B9BF-F429-4AAF-983A-6F722484D0E2" class="sect3"><span class="enumeration_section">4.5</span>优化星形查询和3NF模式</h3>
               <div>
                  <div class="section">
                     <p>Oracle数据仓库可以很好地处理星型模式和第三种常规表单模式。本节介绍了在两种模式中优化性能的重要技术。有关星形和3NF模式的概念背景，请参阅<span class="q">“ <a href="data-warehouse-logical-design.html#GUID-FD474327-4F5C-4D7E-AC7B-91739F229822">关于第三范式模式</a> ”</span> 。和<span class="q">“ <a href="data-warehouse-logical-design.html#GUID-FB038EDB-47AB-4FF1-9826-E342BED572CF">关于星际图式</a> ”</span> 。
                     </p>
                     <p>使用星型查询时应考虑以下事项：</p>
                  </div>
                  <!-- class="section" -->
                  <div class="section">
                     <ul style="list-style-type:disc">
                        <li>
                           <p><a href="data-warehouse-optimizations-techniques.html#GUID-095A1BEC-E373-49B2-A3CF-E059D42B6E7A">优化星形查询</a></p>
                        </li>
                        <li>
                           <p><a href="data-warehouse-optimizations-techniques.html#GUID-56922781-3FDD-4E42-96BD-8CF5E199C951">使用星际转换</a></p>
                        </li>
                        <li>
                           <p><a href="data-warehouse-optimizations-techniques.html#GUID-FA933363-8297-405F-BCE7-48EDA4AB8393">优化第三范式模式</a></p>
                        </li>
                        <li>
                           <p><a href="data-warehouse-optimizations-techniques.html#GUID-355E68D9-2987-4AD5-9620-E37897A1635D">使用VECTOR GROUP BY Aggregation优化星查询</a></p>
                        </li>
                     </ul>
                  </div>
                  <!-- class="section" -->
               </div><a id="DWHSG9069"></a><div class="props_rev_3"><a id="GUID-095A1BEC-E373-49B2-A3CF-E059D42B6E7A" name="GUID-095A1BEC-E373-49B2-A3CF-E059D42B6E7A"></a><h4 id="DWHSG-GUID-095A1BEC-E373-49B2-A3CF-E059D42B6E7A" class="sect4"><span class="enumeration_section">4.5.1</span>优化星查询</h4>
                  <div>
                     <div class="section">
                        <p>星型查询是事实表和多个维度表之间的连接。使用主键到外键连接将每个维度表连接到事实表，但维度表不会相互连接。优化程序识别星型查询并为它们生成有效的执行计划。 <span class="q">“ <a href="data-warehouse-optimizations-techniques.html#GUID-8B14F89D-6DB8-43C2-AC26-E1D9B7217DA0">Tuning Star Queries</a> ”</span>描述了如何提高星型查询的性能。
                        </p>
                     </div>
                     <!-- class="section" -->
                  </div><a id="DWHSG9070"></a><div class="props_rev_3"><a id="GUID-8B14F89D-6DB8-43C2-AC26-E1D9B7217DA0" name="GUID-8B14F89D-6DB8-43C2-AC26-E1D9B7217DA0"></a><h5 id="DWHSG-GUID-8B14F89D-6DB8-43C2-AC26-E1D9B7217DA0" class="sect5"><span class="enumeration_section">4.5.1.1</span>调整星形查询</h5>
                     <div>
                        <div class="section">
                           <p>要为星型查询获得最佳性能，请务必遵循一些基本准则：</p>
                        </div>
                        <!-- class="section" -->
                        <div class="section">
                           <ul style="list-style-type:disc">
                              <li>
                                 <p>应在事实表或表的每个外键列上构建位图索引。</p>
                              </li>
                              <li>
                                 <p>初始化参数<code class="codeph">STAR_TRANSFORMATION_ENABLED</code>应设置为<code class="codeph">TRUE</code> 。这为星型查询启用了重要的优化器功能。默认情况下，它设置为<code class="codeph">FALSE</code>以实现向后兼容性。
                                 </p>
                              </li>
                           </ul>
                           <p>当数据仓库满足这些条件时，在数据仓库中运行的大多数星型查询都使用称为星形转换的查询执行策略。星型转换为星型查询提供了非常高效的查询性能。</p>
                        </div>
                        <!-- class="section" -->
                     </div>
                  </div>
               </div><a id="DWHSG8593"></a><div class="props_rev_3"><a id="GUID-56922781-3FDD-4E42-96BD-8CF5E199C951" name="GUID-56922781-3FDD-4E42-96BD-8CF5E199C951"></a><h4 id="DWHSG-GUID-56922781-3FDD-4E42-96BD-8CF5E199C951" class="sect4"><span class="enumeration_section">4.5.2</span>使用星形转换</h4>
                  <div>
                     <div class="section">
                        <p>星型转换是一种强大的优化技术，它依赖于隐式重写（或转换）原始星型查询的SQL。最终用户永远不需要知道有关星形转换的任何细节。Oracle数据库的查询优化器会在适当的位置自动选择星形转换。</p>
                        <p><a id="d9998e2406" class="indexterm-anchor"></a><a id="d9998e2410" class="indexterm-anchor"></a>星型转换是一种旨在有效执行星型查询的查询转换。Oracle数据库使用两个基本阶段处理星型查询。第一阶段从事实表格（结果集）中精确检索必要的行。由于此检索使用位图索引，因此非常有效。第二阶段将此结果集连接到维度表。最终用户查询的一个例子是：“过去三个季度西部和西南部销售区的商店杂货部门的销售额和利润是多少？“这是一个简单的明星查询。
                        </p>
                        <p>本节包含以下主题：</p>
                     </div>
                     <!-- class="section" -->
                     <div class="section">
                        <ul style="list-style-type:disc">
                           <li>
                              <p><a href="data-warehouse-optimizations-techniques.html#GUID-85C05B21-5BB3-4214-B5D6-E65647CE00AD">使用位图索引进行星形转换</a></p>
                           </li>
                           <li>
                              <p><a href="data-warehouse-optimizations-techniques.html#GUID-C1F74A25-D794-4AA0-BDE2-BE84EFE70092">具有位图索引的星形转换的执行计划</a></p>
                           </li>
                           <li>
                              <p><a href="data-warehouse-optimizations-techniques.html#GUID-461A7350-5783-4E7E-9AE0-ED226D4AD864">使用位图连接索引进行星形转换</a></p>
                           </li>
                           <li>
                              <p><a href="data-warehouse-optimizations-techniques.html#GUID-5C4861DE-EA35-4193-8D06-2B1A38CAF75E">使用位图连接索引进行星形转换的执行计划</a></p>
                           </li>
                           <li>
                              <p><a href="data-warehouse-optimizations-techniques.html#GUID-8CD0D8CE-CFD8-45B0-9D25-AC8804D5063D">Oracle如何选择使用星变换</a></p>
                           </li>
                           <li>
                              <p><a href="data-warehouse-optimizations-techniques.html#GUID-7F4319EA-6A11-4F0F-90DF-E4EF3E50EBE2">星变换限制</a></p>
                           </li>
                        </ul>
                     </div>
                     <!-- class="section" -->
                  </div><a id="DWHSG8594"></a><div class="props_rev_3"><a id="GUID-85C05B21-5BB3-4214-B5D6-E65647CE00AD" name="GUID-85C05B21-5BB3-4214-B5D6-E65647CE00AD"></a><h5 id="DWHSG-GUID-85C05B21-5BB3-4214-B5D6-E65647CE00AD" class="sect5"><span class="enumeration_section">4.5.2.1</span>使用位图索引进行星形转换</h5>
                     <div>
                        <div class="section">
                           <p>星型转换的先决条件是在事实表的每个连接列上都有一个单列位图索引。这些连接列包括所有外键列。</p>
                           <p>例如， <code class="codeph">sh</code>示例模式的<code class="codeph">sales</code>表在<code class="codeph">time_id</code> ， <code class="codeph">channel_id</code> ， <code class="codeph">cust_id</code> ， <code class="codeph">prod_id</code>和<code class="codeph">promo_id</code>列上具有位图索引。
                           </p>
                           <p>请考虑以下星标查询：</p><pre class="oac_no_warn" dir="ltr">SELECT ch.channel_class，c.cust_city，t.calendar_quarter_desc，SUM（s.amount_sold）sales_amount FROM sales s，times t，customers c，channels ch WHERE s.time_id = t.time_id AND s.cust_id = c.cust_id AND s .channel_id = ch.channel_id AND c.cust_state_province ='CA'和ch.channel_desc in（'Internet'，'Catalog'）AND t.calendar_quarter_desc IN（'1999-Q1'，'1999-Q2'）GROUP BY ch。 channel_class，c.cust_city，t.calendar_quarter_desc;</pre><p>此查询分两个阶段处理。在第一阶段，Oracle数据库使用事实表的外键列上的位图索引来识别和检索事实表中的必要行。也就是说，Oracle数据库使用以下查询从事实表中检索结果集：</p><pre class="oac_no_warn" dir="ltr">选择 ...FROM sales WHERE time_id IN（SELECT time_id FROM times WHERE calendar_quarter_desc IN（'1999-Q1'，'1999-Q2'））AND cust_id IN（SELECT cust_id FROM customers WHERE cust_state_province ='CA'）AND channel_id IN（SELECT channel_id FROM channels WHERE channel_desc IN（'Internet'，'Catalog'））;</pre><p>这是算法的转换步骤，因为原始星型查询已转换为此子查询表示。这种访问事实表的方法利用了位图索引的优势。直观地，位图索引在关系数据库中提供基于集合的处理方案。Oracle已经实现了非常快速的方法来执行集合操作，例如<code class="codeph">AND</code> （基于标准集的术语中的交集）， <code class="codeph">OR</code> （基于集合的联合）， <code class="codeph">MINUS</code>和<code class="codeph">COUNT</code> 。</p>
                           <p>在此星型查询中， <code class="codeph">time_id</code>上的位图索引用于标识事实表中与<code class="codeph">1999-Q1</code> <code class="codeph">sales</code>相对应的所有行的集合。该集合表示为位图（1和0的字符串，表示事实表的哪些行是该集合的成员）。
                           </p>
                           <p>对于与<code class="codeph">1999-Q2</code>的销售相对应的事实表行，检索类似的位图。位图<code class="codeph">OR</code>操作用于将这组<code class="codeph">Q1</code>销售与<code class="codeph">Q2</code>销售组合。
                           </p>
                           <p>将对<code class="codeph">customer</code>维度和<code class="codeph">product</code>维度执行其他设置操作。此时在星型查询处理中，有三个位图。每个位图对应一个单独的维度表，每个位图表示满足该单个维度约束的事实表的行集。
                           </p>
                           <p>使用位图<code class="codeph">AND</code>操作将这三个位图组合成单个位图。此最终位图表示事实表中满足维度表上所有约束的行集。这是结果集，是评估查询所需的事实表中的确切行集。请注意，事实表中的实际数据均未被访问。所有这些操作都仅依赖于位图索引和维度表。由于位图索引的压缩数据表示，基于位图集的操作非常有效。
                           </p>
                           <p>识别结果集后，位图用于访问sales表中的实际数据。仅从事实表中检索最终用户查询所需的那些行。此时，Oracle数据库已使用位图索引将所有维度表有效地连接到事实表。此技术提供了出色的性能，因为Oracle数据库通过一个逻辑连接操作将所有维度表连接到事实表，而不是将每个维度表独立地连接到事实表。</p>
                           <p>此查询的第二阶段是将事实表（结果集）中的这些行连接到维度表。Oracle使用最有效的方法来访问和连接维度表。许多维度非常小，表扫描通常是这些维度表的最有效的访问方法。对于大型维度表，表扫描可能不是最有效的访问方法。在前面的示例中， <code class="codeph">product.department</code>上的位图索引可用于快速识别杂货部门中的所有这些产品。Oracle数据库的优化器根据优化程序对每个维度表的大小和数据分布的了解，自动确定哪种访问方法最适合给定维度表。
                           </p>
                           <p>每个维度表的特定连接方法（以及索引方法）同样由优化器智能确定。散列连接通常是连接维度表的最有效算法。一旦所有维度表都已加入，最终答案将返回给用户。从一个表中仅检索匹配行然后连接到另一个表的查询技术通常称为半连接。</p>
                        </div>
                        <!-- class="section" -->
                     </div>
                  </div><a id="DWHSG8595"></a><div class="props_rev_3"><a id="GUID-C1F74A25-D794-4AA0-BDE2-BE84EFE70092" name="GUID-C1F74A25-D794-4AA0-BDE2-BE84EFE70092"></a><h5 id="DWHSG-GUID-C1F74A25-D794-4AA0-BDE2-BE84EFE70092" class="sect5"><span class="enumeration_section">4.5.2.2</span>带位图索引的星变换的执行计划</h5>
                     <div>
                        <p><a id="d9998e2588" class="indexterm-anchor"></a><a id="d9998e2592" class="indexterm-anchor"></a><a id="d9998e2596" class="indexterm-anchor"></a>以下典型执行计划可能来自<span class="q">“ <a href="data-warehouse-optimizations-techniques.html#GUID-85C05B21-5BB3-4214-B5D6-E65647CE00AD">使用位图索引进行星形转换</a> ”</span> ：</p><pre class="oac_no_warn" dir="ltr">选择语句排序组通过哈希联接表访问完整渠道哈希联接表访问完整客户哈希联接表访问全时分区范围ITERATOR表访问本地索引ROWID SALES BITMAP转换为ROWIDS BITMAP和BITMAP MERGE BITMAP关键迭代缓冲区排序表访问全部客户BITMAP INDEX RANGE SCAN SALES_CUST_BIX BITMAP MERGE BITMAP关键迭代缓冲区排序表访问全部通道BITMAP索引范围扫描SALES_CHANNEL_BIX BITMAP MERGE BITMAP关键迭代缓冲区排序表访问全时位数BITMAP INDEX RANGE SCAN SALES_TIME_BIX</pre><p>在该计划中，通过基于三个合并位图的位图<code class="codeph">AND</code>的位图访问路径来访问事实表。这三个位图是由<code class="codeph">BITMAP</code> <code class="codeph">MERGE</code>行源生成的，它从位于其下的行源树中提供位图。每个这样的行源树都包含一个<code class="codeph">BITMAP</code> <code class="codeph">KEY</code> <code class="codeph">ITERATION</code>行源，它从子查询行源树中获取值，在本例中，这是一个完整的表访问。对于每个这样的值， <code class="codeph">BITMAP</code> <code class="codeph">KEY</code> <code class="codeph">ITERATION</code>行源从位图索引中检索位图。在使用此访问路径检索相关事实表行之后，它们将与维度表和临时表联接以生成查询的答案。
                        </p>
                     </div>
                  </div><a id="DWHSG8596"></a><div class="props_rev_3"><a id="GUID-461A7350-5783-4E7E-9AE0-ED226D4AD864" name="GUID-461A7350-5783-4E7E-9AE0-ED226D4AD864"></a><h5 id="DWHSG-GUID-461A7350-5783-4E7E-9AE0-ED226D4AD864" class="sect5"><span class="enumeration_section">4.5.2.3</span>使用位图连接索引进行星形转换</h5>
                     <div>
                        <p>除了位图索引之外，您还可以在星形转换期间使用位图连接索引。假设您有以下附加索引结构：</p><pre class="oac_no_warn" dir="ltr">CREATE BITMAP INDEX sales_c_state_bjix ON sales（customers.cust_state_province）FROM sales，customers WHERE sales.cust_id = customers.cust_id LOCAL NOLOGGING COMPUTE STATISTICS;</pre><p>使用位图连接索引处理相同的星型查询与前面的示例类似。唯一的区别是Oracle利用连接索引而不是单表位图索引来访问星型查询的第一阶段中的客户数据。</p>
                     </div>
                  </div><a id="DWHSG8597"></a><div class="props_rev_3"><a id="GUID-5C4861DE-EA35-4193-8D06-2B1A38CAF75E" name="GUID-5C4861DE-EA35-4193-8D06-2B1A38CAF75E"></a><h5 id="DWHSG-GUID-5C4861DE-EA35-4193-8D06-2B1A38CAF75E" class="sect5"><span class="enumeration_section">4.5.2.4</span>使用位图连接索引进行星形转换的执行计划</h5>
                     <div>
                        <p>以下典型执行计划可能来自<span class="q">“ <a href="data-warehouse-optimizations-techniques.html#GUID-5C4861DE-EA35-4193-8D06-2B1A38CAF75E">使用位图连接索引进行星形转换的执行计划</a> ”</span> ：</p><pre class="oac_no_warn" dir="ltr">通过HASH JOIN TABLE访问全部渠道HASH JOIN TABLE访问全部客户HASH JOIN TABLE访问全部客户HASH JOIN TABLE访问全时分区范围所有表访问按地方索引ROWID销售BITMAP转换为ROWIDS BITMAP和BITMAP索引单值SALES_C_STATE_BJIX BITMAP MERGE BITMAP关键迭代缓冲区排序表访问全部通道BITMAP索引范围扫描销售_CHANNEL_BIX BITMAP MERGE BITMAP关键迭代缓冲区排序表访问全部时间位数指数范围扫描销售_TIME_BIX</pre><p>与前一个计划相比，此计划之间的区别在于<code class="codeph">customer</code>维度的位图索引扫描的内部部分没有子选择。这是因为可以使用位图连接索引<code class="codeph">sales_c_state_bjix</code>来满足<code class="codeph">customer.cust_state_province</code>上的连接谓词信息。
                        </p>
                     </div>
                  </div><a id="DWHSG8598"></a><div class="props_rev_3"><a id="GUID-8CD0D8CE-CFD8-45B0-9D25-AC8804D5063D" name="GUID-8CD0D8CE-CFD8-45B0-9D25-AC8804D5063D"></a><h5 id="DWHSG-GUID-8CD0D8CE-CFD8-45B0-9D25-AC8804D5063D" class="sect5"><span class="enumeration_section">4.5.2.5</span> Oracle如何选择使用星形转换</h5>
                     <div>
                        <p>优化器生成并保存无需转换即可生成的最佳计划。如果启用了转换，则优化程序会尝试将其应用于查询，并在适用的情况下使用转换后的查询生成最佳计划。基于两个版本查询的最佳计划之间的成本估算的比较，优化器然后决定是否对转换或未转换版本使用最佳计划。</p>
                        <p>如果查询需要访问事实表中的大部分行，则最好使用全表扫描而不使用转换。但是，如果维度表上的约束谓词具有足够的选择性，只能检索事实表的一小部分，那么基于转换的计划可能会更优越。</p>
                        <p>请注意，只有在根据许多条件确定维度表合理时，优化程序才会为维度表生成子查询。无法保证将为所有维度表生成子查询。优化器还可以基于表和查询的属性来决定转换不值得应用于特定查询。在这种情况下，将使用最佳常规计划。</p>
                     </div>
                  </div><a id="DWHSG8599"></a><div class="props_rev_3"><a id="GUID-7F4319EA-6A11-4F0F-90DF-E4EF3E50EBE2" name="GUID-7F4319EA-6A11-4F0F-90DF-E4EF3E50EBE2"></a><h5 id="DWHSG-GUID-7F4319EA-6A11-4F0F-90DF-E4EF3E50EBE2" class="sect5"><span class="enumeration_section">4.5.2.6</span>星变换限制</h5>
                     <div>
                        <div class="section">
                           <p><a id="d9998e2754" class="indexterm-anchor"></a>具有以下任何特征的表不支持星形转换：</p>
                           <ul style="list-style-type:disc">
                              <li>
                                 <p>具有与位图访问路径不兼容的表提示的查询</p>
                              </li>
                              <li>
                                 <p>位图索引太少的表。事实表列上必须有一个位图索引，以便优化器为其生成子查询。</p>
                              </li>
                              <li>
                                 <p>远程事实表。但是，在生成的子查询中允许使用远程维度表。</p>
                              </li>
                              <li>
                                 <p>反连表</p>
                              </li>
                              <li>
                                 <p>已在子查询中用作维表的表</p>
                              </li>
                              <li>
                                 <p>实际上是未合并视图的表，它们不是视图分区</p>
                              </li>
                              <li>
                                 <p>事实表是未合并视图的表</p>
                              </li>
                              <li>
                                 <p>将分区视图用作事实表的表</p>
                              </li>
                           </ul>
                           <p>在以下情况下，优化器可能不会选择星形转换：</p>
                           <ul style="list-style-type:disc">
                              <li>
                                 <p>具有良好单表访问路径的表</p>
                              </li>
                              <li>
                                 <p>表格太小，无法进行转换</p>
                              </li>
                           </ul>
                           <p>此外，在以下条件下，星形转换不会使用临时表：</p>
                           <ul style="list-style-type:disc">
                              <li>
                                 <p>数据库处于只读模式</p>
                              </li>
                              <li>
                                 <p>星型查询是处于可序列化模式的事务的一部分</p>
                              </li>
                           </ul>
                        </div>
                        <!-- class="section" -->
                     </div>
                  </div>
               </div><a id="DWHSG9071"></a><div class="props_rev_3"><a id="GUID-FA933363-8297-405F-BCE7-48EDA4AB8393" name="GUID-FA933363-8297-405F-BCE7-48EDA4AB8393"></a><h4 id="DWHSG-GUID-FA933363-8297-405F-BCE7-48EDA4AB8393" class="sect4"><span class="enumeration_section">4.5.3</span>优化第三范式模式</h4>
                  <div>
                     <p>优化第三范式（3NF）架构需要以下内容：</p>
                     <ul style="list-style-type:disc">
                        <li>
                           <p>功率</p>
                           <p>电源意味着必须平衡硬件配置。许多数据仓库操作都基于大型表扫描和其他IO密集型操作，这些操作执行大量随机IO。为了实现最佳性能，必须端到端地调整硬件配置的大小以维持这种吞吐量水平。这种类型的硬件配置称为平衡系统。在平衡系统中，所有组件（从CPU到磁盘）都经过精心协作，以保证最大可能的IO吞吐量。</p>
                        </li>
                        <li>
                           <p>分区</p>
                           <p>应使用复合分区（range-hash或list-hash）对较大的表进行分区。这有三个原因：</p>
                           <ul style="list-style-type:disc">
                              <li>
                                 <p>更容易管理数TB的数据</p>
                              </li>
                              <li>
                                 <p>更快地访问必要的数据</p>
                              </li>
                              <li>
                                 <p>高效且高性能的表连接</p>
                              </li>
                           </ul>
                           <p>请参阅<a href="data-warehouse-optimizations-techniques.html#GUID-26000567-78DB-4E77-B07E-A51804A976E2">3NF架构：分区</a> 。
                           </p>
                        </li>
                        <li>
                           <p>并行执行</p>
                           <p>并行执行使数据库任务可以并行化或分成更小的工作单元，从而允许多个进程同时工作。通过使用并行性，可以在几分钟或更短的时间内扫描和处理数TB的数据，而不是数小时或数天。</p>
                           <p>请参阅<a href="data-warehouse-optimizations-techniques.html#GUID-C4E08017-3A33-448A-9662-5421F9B2F272">3NF架构：并行查询执行</a> 。
                           </p>
                        </li>
                     </ul>
                  </div><a id="DWHSG9072"></a><div class="props_rev_3"><a id="GUID-26000567-78DB-4E77-B07E-A51804A976E2" name="GUID-26000567-78DB-4E77-B07E-A51804A976E2"></a><h5 id="DWHSG-GUID-26000567-78DB-4E77-B07E-A51804A976E2" class="sect5"><span class="enumeration_section">4.5.3.1</span> 3NF模式：分区</h5>
                     <div>
                        <p>分区允许将表，索引或索引组织表细分为更小的部分。每个数据库对象都称为分区。每个分区都有自己的名称，并且可以选择具有自己的存储特性。从数据库管理员的角度来看，分区对象具有多个可以集体或单独管理的部分。</p>
                        <p>这为管理员提供了管理分区对象的极大灵活性。但是，从应用程序的角度来看，分区表与非分区表相同;使用SQL DML命令访问分区表时不需要进行任何修改。通过提高可管理性，可用性和性能，分区可以为各种应用程序带来巨大的好处。</p>
                     </div><a id="DWHSG9073"></a><div class="props_rev_3"><a id="GUID-EBB30A06-BA15-482F-A8BD-4E78DFED4220" name="GUID-EBB30A06-BA15-482F-A8BD-4E78DFED4220"></a><h6 id="DWHSG-GUID-EBB30A06-BA15-482F-A8BD-4E78DFED4220" class="sect6"><span class="enumeration_section">4.5.3.1.1</span>可管理性分区</h6>
                        <div>
                           <p>范围分区将有助于提高大量数据的可管理性和可用性。考虑两年的销售数据或100太字节（TB）存储在表格中的情况。在每天结束时，需要将新批量数据加载到表中，并且需要删除最早的数据。如果Sales表的范围按天划分，则可以使用分区交换负载加载新数据。这是一个亚秒级操作，对最终用户查询应该影响很小或没有影响。要删除最早的数据，只需发出以下命令：</p><pre class="oac_no_warn" dir="ltr">SH @ DBM1&gt; ALTER TABLE SALES DROP PARTITION Sales_Q4_2009;</pre></div>
                     </div><a id="DWHSG9075"></a><a id="DWHSG9074"></a><div class="props_rev_3"><a id="GUID-12FA4D3D-126C-4841-91C9-89A67D293B87" name="GUID-12FA4D3D-126C-4841-91C9-89A67D293B87"></a><h6 id="DWHSG-GUID-12FA4D3D-126C-4841-91C9-89A67D293B87" class="sect6"><span class="enumeration_section">4.5.3.1.2</span>分区以便更轻松地访问数据</h6>
                        <div>
                           <p>范围分区还有助于确保仅扫描回答查询所需的数据。假设业务用户主要每周访问销售数据，例如每周总销售额，然后按日划分该表，将确保以最有效的方式访问数据，因为只需要扫描4个分区回答业务用户查询而不是整个表。避免扫描不相关分区的能力称为分区修剪。</p>
                           <div class="figure" id="GUID-12FA4D3D-126C-4841-91C9-89A67D293B87__GUID-6C98ADA9-FF3A-4C13-9A9F-133B5D5F4DAF">
                              <p class="titleinfigure">图4-3分区修剪</p><img src="img/dwhsg152.png" alt="下面是图4-3的描述" title="下面是图4-3的描述" longdesc="img_text/dwhsg152.html"><br><a href="img_text/dwhsg152.html">“图4-3分区修剪”的说明</a></div>
                           <!-- class="figure" -->
                           <p></p>
                           <p>从Oracle Database 12 <span class="italic">c</span>第2版（12.2）开始，您可以为外部表定义分区。外部表是不驻留在数据库中的表，可以是提供访问驱动程序的任何格式。分区外部表的文件可以存储在文件系统，Apache Hive存储或Hadoop分布式文件系统（HDFS）中。
                           </p>
                           <p>对外部表进行分区可提高查询性能并简化数据维护。它还使外部表能够利用存储在数据库中的分区表可用的性能优化，例如分区修剪和分区连接。分区外部表支持除数据库中的表支持的大多数分区技术（散列分区除外）。但是，Oracle数据库无法保证分区的外部存储文件包含满足分区条件的数据。</p>
                           <div class="infoboxnotealso" id="GUID-12FA4D3D-126C-4841-91C9-89A67D293B87__GUID-DD503BD2-E672-45C3-AE4B-C066EE3748AE">
                              <p class="notep1">也可以看看：</p>
                              <p>有关分区外部表的详细信息，请参见<a href="../admin/managing-tables.html#ADMIN-GUID-2A801016-0399-4925-AD1B-A02683E81B59" target="_blank"><span><cite>“Oracle数据库管理员指南”</cite></span></a></p>
                           </div>
                        </div>
                     </div><a id="DWHSG9077"></a><a id="DWHSG9078"></a><a id="DWHSG9076"></a><div class="props_rev_3"><a id="GUID-EE8606E5-1E0E-470C-9390-552502699E40" name="GUID-EE8606E5-1E0E-470C-9390-552502699E40"></a><h6 id="DWHSG-GUID-EE8606E5-1E0E-470C-9390-552502699E40" class="sect6"><span class="enumeration_section">4.5.3.1.3</span>加入性能的分区</h6>
                        <div>
                           <div class="section">
                              <p>出于性能原因，主要使用通过散列进行的子分区。Oracle使用线性散列算法来创建子分区。为了确保数据在散列分区之间均匀分布，强烈建议散列分区的数量是2的幂（例如，2,4,8等）。每个散列分区的大小至少应为16MB。任何较小的并且它们将不具有并行查询的有效扫描速率。</p>
                              <p>散列分区的主要性能优点之一是分区智能连接。分区连接通过最小化并行执行连接时并行执行服务器之间交换的数据量来减少查询响应时间。这显着缩短了响应时间并改善了CPU和内存资源的使用。在集群数据仓库中，通过限制互连（IPC）上的数据流量，这显着缩短了响应时间，这是实现大规模连接操作的良好可扩展性的关键。分区连接可以是完整的或部分的，具体取决于要连接的表的分区方案。</p>
                              <p>完全分区连接将两个大表之间的连接分成多个较小的连接。每个较小的连接在一对分区上执行连接，每个分区对应一个连接的表。为了使优化器选择完全的分区连接方法，两个表必须在其连接键上进行等分。也就是说，它们必须使用相同的分区方法在同一列上进行分区。并行执行完全分区连接类似于其串行执行，除了不是一次加入一个分区对，多个分区对由多个并行查询服务器并行连接。并行连接的分区数由并行度（DOP）确定。</p>
                              <div class="figure" id="GUID-EE8606E5-1E0E-470C-9390-552502699E40__CIHCHHBJ">
                                 <p class="titleinfigure">图4-4完全分区 - 明智的加入</p><img src="img/dwhsg153.png" alt="下面是图4-4的描述" title="下面是图4-4的描述" longdesc="img_text/dwhsg153.html"><br><a href="img_text/dwhsg153.html">“图4-4完全分区 - 明智加入”的描述</a></div>
                              <!-- class="figure" -->
                              <p><a href="data-warehouse-optimizations-techniques.html#GUID-EE8606E5-1E0E-470C-9390-552502699E40__CIHCHHBJ">图4-4</a>说明了两个表<code class="codeph">Sales</code>和<code class="codeph">Customers</code>之间的完全分区连接的并行执行。两个表具有相同的并行度和相同数量的分区。它们在日期字段上进行范围分区，并在<code class="codeph">cust_id</code>字段上通过哈希进行子分区。如图所示，每个分区对都从数据库中读取并直接连接。不需要数据重新分配，从而最大限度地减少IPC通信，尤其是跨节点。下面的<a href="data-warehouse-optimizations-techniques.html#GUID-EE8606E5-1E0E-470C-9390-552502699E40__CIHJCJFA">图4-5</a>显示了您将为此连接看到的执行计划。
                              </p>
                              <p>为确保在并行执行分区连接时获得最佳性能，每个表中的分区数应大于用于连接的并行度。如果有多个分区而不是并行服务器，则每个并行服务器将被赋予一对要加入的分区，当并行服务器完成该连接时，它将请求另一对分区加入。重复此过程，直到处理完所有对。此方法可以动态平衡负载（例如，128个并行度为32的分区）。</p>
                              <p>如果您要加入的其中一个表被分区，会发生什么？在这种情况下，优化器可以选择部分分区连接。与完全分区连接不同，如果在连接键上只分区了一个表，则可以应用部分分区连接。因此，部分分区连接比完全分区连接更常见。为了执行部分分区连接，Oracle根据分区表的分区策略动态地重新分区另一个表。重新分区另一个表后，执行类似于完全分区连接。重新分发操作涉及在并行执行服务器之间交换行。此操作会导致Oracle RAC环境中的互连流量，因为数据需要跨节点边界重新分区。</p>
                              <div class="figure" id="GUID-EE8606E5-1E0E-470C-9390-552502699E40__CIHJCJFA">
                                 <p class="titleinfigure">图4-5部分分区 - 明智的加入</p><img src="img/dwhsg154.png" alt="下面是图4-5的描述" title="下面是图4-5的描述" longdesc="img_text/dwhsg154.html"><br><a href="img_text/dwhsg154.html">“图4-5部分分区 - 明智加入”的描述</a></div>
                              <!-- class="figure" -->
                              <p><a href="data-warehouse-optimizations-techniques.html#GUID-EE8606E5-1E0E-470C-9390-552502699E40__CIHJCJFA">图4-5</a>说明了部分分区连接。它使用与<a href="data-warehouse-optimizations-techniques.html#GUID-EE8606E5-1E0E-470C-9390-552502699E40__CIHCHHBJ">图4-4中</a>相同的示例，但customer表未分区。在执行连接操作之前，customers表中的行将在连接键上动态重新分配。
                              </p>
                           </div>
                           <!-- class="section" -->
                        </div>
                     </div>
                  </div><a id="DWHSG9079"></a><div class="props_rev_3"><a id="GUID-C4E08017-3A33-448A-9662-5421F9B2F272" name="GUID-C4E08017-3A33-448A-9662-5421F9B2F272"></a><h5 id="DWHSG-GUID-C4E08017-3A33-448A-9662-5421F9B2F272" class="sect5"><span class="enumeration_section">4.5.3.2</span> 3NF模式：并行查询执行</h5>
                     <div>
                        <p>3NF模式可以通过多种方式利用并行性，但这里的重点是并行性的一个方面，这对于3NF特别重要：大型查询的SQL并行执行。Oracle数据库中的SQL并行执行基于协调器（通常称为查询协调器或QC）和并行服务器的原理。QC是启动并行SQL语句的会话，并行服务器是并行执行工作的各个会话。QC将工作分配给并行服务器，并且可能必须执行最小的后勤工作 - 不能并行执行的工作部分。例如，具有<code class="codeph">SUM()</code>操作的并行查询需要添加由每个并行服务器计算的各个子总计。
                        </p>
                        <p>QC很容易在<a href="data-warehouse-optimizations-techniques.html#GUID-EE8606E5-1E0E-470C-9390-552502699E40__CIHJCJFA">图4-5</a>中的并行执行中识别为PX COORDINATOR。充当并行SQL操作的QC的过程是实际的用户会话过程本身。并行服务器取自全局可用的并行服务器进程池，并分配给给定的操作。并行服务器执行QC下方的并行计划中显示的所有工作。</p>
                        <p>默认情况下，Oracle数据库配置为支持开箱即用的并行执行，并由两个初始化参数<code class="codeph">parallel_max_servers</code>和<code class="codeph">parallel_min_servers</code> 。虽然并行执行提供了一个非常强大且可扩展的框架来加速SQL操作，但您不应忘记使用一些常识规则;虽然并行执行可能会为您带来额外的增量性能提升，但它需要更多资源，并且可能还会对同一系统上的其他用户或操作产生副作用。不应为并行执行启用小表/索引（最多数千条记录;最多10个数据块）。只有小型表的操作不会从并行执行中获益很多，但是它们将使用您希望可用于访问大型表的操作的并行服务器。还要记住，一旦操作以某种程度的并行性（DOP）开始，就无法在执行期间减少其DOP。
                        </p>
                        <p>确定对象的适当DOP的一般经验法则是：</p>
                        <ul style="list-style-type:disc">
                           <li>
                              <p>小于200 MB的对象不应使用任何并行性</p>
                           </li>
                           <li>
                              <p>200 MB到5GB之间的对象应使用4的DOP</p>
                           </li>
                           <li>
                              <p>超过5GB的对象使用32的DOP</p>
                           </li>
                        </ul>
                        <p>毋庸置疑，最佳设置可能因系统而异 - 无论是在大小范围内还是在DOP上 - 并且高度依赖于您的目标工作负载，业务要求和硬件配置。<a href="data-warehouse-optimizations-techniques.html#GUID-76DC6364-A588-48BC-B651-101081E5ECB6">是否在Oracle RAC</a>中<a href="data-warehouse-optimizations-techniques.html#GUID-76DC6364-A588-48BC-B651-101081E5ECB6">使用跨实例并行执行</a>描述了Oracle RAC环境中的并行执行。
                        </p>
                     </div><a id="DWHSG9080"></a><div class="props_rev_3"><a id="GUID-76DC6364-A588-48BC-B651-101081E5ECB6" name="GUID-76DC6364-A588-48BC-B651-101081E5ECB6"></a><h6 id="DWHSG-GUID-76DC6364-A588-48BC-B651-101081E5ECB6" class="sect6"><span class="enumeration_section">4.5.3.2.1</span>是否在Oracle RAC中使用跨实例并行执行</h6>
                        <div>
                           <p>默认情况下，Oracle数据库支持节点间并行执行（并行执行涉及多个节点的单个语句）。如前所述，Oracle RAC环境中的互连必须适当调整大小，因为节点间并行执行可能会导致大量互连流量。如果与从服务器到存储子系统的I / O带宽相比使用相对较弱的互连，则最好将并行执行限制为单个节点或有限数量的节点。节点间并行执行不会随着尺寸过小的互连而扩展。从Oracle Database <span class="italic">11g</span>开始，建议使用Oracle RAC服务来控制群集上的并行执行。
                           </p>
                        </div>
                     </div>
                  </div>
               </div><a id="DWHSG9334"></a><div class="props_rev_3"><a id="GUID-355E68D9-2987-4AD5-9620-E37897A1635D" name="GUID-355E68D9-2987-4AD5-9620-E37897A1635D"></a><h4 id="DWHSG-GUID-355E68D9-2987-4AD5-9620-E37897A1635D" class="sect4"><span class="enumeration_section">4.5.4</span>使用VECTOR GROUP BY Aggregation优化星查询</h4>
                  <div>
                     <p><code class="codeph">VECTOR GROUP BY</code>聚合<a id="d9998e3122" class="indexterm-anchor"></a>优化聚合数据的查询，并将一个或多个相对较小的表连接到较大的表。SQL优化器可以根据成本估算选择此转换。在数据仓库的上下文中，通常会选择<code class="codeph">VECTOR GROUP BY</code>用于从内存中列表中选择数据的星型查询。
                     </p>
                     <p><code class="codeph">VECTOR GROUP BY</code>聚合类似于布隆过滤器，因为它将小表和大表之间的连接条件转换为较大表上的过滤器。<code class="codeph">VECTOR GROUP BY</code>聚合通过在事实表的扫描期间聚合数据而不是作为扫描之后的单独步骤来进一步增强查询性能。
                     </p>
                     <div class="infoboxnotealso" id="GUID-355E68D9-2987-4AD5-9620-E37897A1635D__GUID-DA6FB3A0-4AE1-4859-A9C2-CD788E106993">
                        <p class="notep1">也可以看看：</p>
                        <ul style="list-style-type:disc">
                           <li>
                              <p><a href="sql-aggregation-data-warehouses.html#GUID-82F7AE38-4527-44C4-A140-234BFC9AFFD1">使用内存中聚合</a></p>
                           </li>
                           <li>
                              <p>有关详细<code class="codeph">VECTOR GROUP BY</code>场景的<a href="../inmem/optimizing-in-memory-aggregation.html#INMEM-GUID-2C4FA6C6-3DA8-4CEA-9EF0-294396D15077" target="_blank"><span><cite>Oracle Database In-Memory指南</cite></span></a></p>
                           </li>
                        </ul>
                     </div>
                  </div>
               </div>
            </div>
            <div class="sect2"><a id="GUID-F7E7DEA6-B225-43E6-97ED-CB3DBE86CD54" name="GUID-F7E7DEA6-B225-43E6-97ED-CB3DBE86CD54"></a><h3 id="DWHSG-GUID-F7E7DEA6-B225-43E6-97ED-CB3DBE86CD54" class="sect3"><span class="enumeration_section">4.6</span>关于近似查询处理</h3>
               <div>
                  <p>近似查询处理使用SQL函数为可接受近似值的探索性查询提供实时响应。包含返回近似结果的SQL函数的查询称为近似查询。</p>
                  <p></p>
                  <p>商业智能（BI）应用程序广泛使用聚合函数（包括分析函数）来提供常见业务查询的答案。对于某些类型的查询，当数据集非常大时，提供精确答案可能会占用大量资源。例如，计算网站上的唯一客户会话数或在州内的每个邮政编码中确定中位数房价。在某些情况下，这些类型的查询可能不需要确切的答案，因为您对近似趋势或模式更感兴趣，然后可用于推动进一步分析。近似查询处理主要用于数据发现应用程序，以便快速回答探索性查询。用户通常希望在大量数据中找到有趣的数据点，然后向下钻取以发现更多详细信息。对于探索性查询，快速响应比精确值更重要。</p>
                  <p>Oracle提供了一组SQL函数，使您可以获得近似结果，而与精确结果的偏差可以忽略不计。还有其他近似函数支持基于物化视图的汇总聚合策略。提供近似结果的函数如下：</p>
                  <ul style="list-style-type:disc">
                     <li>
                        <p><code class="codeph">APPROX_COUNT_DISTINCT</code></p>
                     </li>
                     <li>
                        <p><code class="codeph">APPROX_COUNT_DISTINCT_DETAIL</code></p>
                     </li>
                     <li>
                        <p><code class="codeph">APPROX_COUNT_DISTINCT_AGG</code></p>
                     </li>
                     <li>
                        <p><code class="codeph">TO_APPROX_COUNT_DISTINCT</code></p>
                     </li>
                     <li>
                        <p><code class="codeph">APPROX_MEDIAN</code></p>
                     </li>
                     <li>
                        <p><code class="codeph">APPROX_PERCENTILE</code></p>
                     </li>
                     <li>
                        <p><code class="codeph">APPROX_PERCENTILE_DETAIL</code></p>
                     </li>
                     <li>
                        <p><code class="codeph">APPROX_PERCENTILE_AGG</code></p>
                     </li>
                     <li>
                        <p><code class="codeph">TO_APPROX_PERCENTILE</code></p>
                     </li>
                     <li>
                        <p><code class="codeph">APPROX_COUNT</code></p>
                     </li>
                     <li>
                        <p><code class="codeph">APPROX_RANK</code></p>
                     </li>
                     <li>
                        <p><code class="codeph">APPROX_SUM</code></p>
                     </li>
                  </ul>
                  <p>无需对现有代码进行任何更改即可使用近似查询处理。设置适当的初始化参数时，Oracle数据库会使用返回近似结果的相应SQL函数替换查询中的确切函数。</p>
                  <div class="infoboxnotealso" id="GUID-F7E7DEA6-B225-43E6-97ED-CB3DBE86CD54__GUID-29CF7C87-35F8-4432-BB2F-46B05FAC078A">
                     <p class="notep1">也可以看看：</p>
                     <ul style="list-style-type:disc">
                        <li>
                           <p><a href="data-warehouse-optimizations-techniques.html#GUID-1D8D7119-8571-428D-B1E8-3F31AD2B0DA6" title="可以使用返回近似结果的相应SQL函数运行包含精确函数的查询，而无需修改查询。这使您可以使用返回近似结果的相应SQL函数，在不进行修改的情况下运行现有应用程序。">使用返回近似值的SQL函数运行包含精确函数的查询</a></p>
                        </li>
                        <li>
                           <p><a href="basic-materialized-views.html#GUID-42B64F99-7391-48B8-B37D-1B486DC29645" title="基于近似查询的物化视图使用SQL函数，该函数在其定义查询中返回近似函数。">基于近似查询创建物化视图</a></p>
                        </li>
                        <li>
                           <p><a href="advanced-query-rewrite-materialized-views.html#GUID-41A13A98-E51A-435A-973E-05CC083F2CFC" title="如果可以使用物化视图回答这些查询，则会自动重写包含返回近似结果的SQL函数的查询以使用匹配的物化视图。">基于近似查询的查询重写和物化视图</a></p>
                        </li>
                        <li>
                           <p>有关SQL函数的信息，请<a href="../sqlrf/index.html" target="_blank"><span><cite>参见Oracle数据库SQL语言参考</cite></span></a></p>
                        </li>
                     </ul>
                  </div>
               </div>
               <div class="sect3"><a id="GUID-1D8D7119-8571-428D-B1E8-3F31AD2B0DA6" name="GUID-1D8D7119-8571-428D-B1E8-3F31AD2B0DA6"></a><h4 id="DWHSG-GUID-1D8D7119-8571-428D-B1E8-3F31AD2B0DA6" class="sect4"><span class="enumeration_section">4.6.1</span>使用返回近似值的SQL函数运行包含精确函数的查询</h4>
                  <div>
                     <p>可以使用返回近似结果的相应SQL函数运行包含精确函数的查询，而无需修改查询。这使您可以使用返回近似结果的相应SQL函数，在不进行修改的情况下运行现有应用程序。</p>
                     <div class="section">
                        <p></p>
                        <p>Oracle数据库提供以下初始化参数，以指示必须使用在运行时返回近似结果的相应SQL函数替换确切的函数： <code class="codeph">approx_for_aggregation</code> ， <code class="codeph">approx_for_count_distinct</code>和<code class="codeph">approx_for_percentile</code> 。您可以在运行时使用返回近似结果的相应函数替换所有精确函数。如果需要对必须用相应的近似版本替换的函数列表进行更细粒度的控制，则可以指定在运行时必须替换的函数类型。例如，如果查询包含<code class="codeph">COUNT(DISTINCT)</code> ，则将<code class="codeph">approx_for_aggregation</code>设置为<code class="codeph">TRUE</code>导致使用<code class="codeph">APPROX_COUNT_DISTINCT</code>而不是<code class="codeph">COUNT(DISTINCT)</code>运行此查询。
                        </p>
                     </div>
                     <!-- class="section" -->
                     <ul>
                        <li class="stepexpand"><span>要使用返回近似结果的相应SQL函数而不是指定的SQL函数来运行所有查询：</span><div>
                              <p>为当前会话或整个数据库设置<code class="codeph">approx_for_aggregation</code>初始化参数为<code class="codeph">TRUE</code> 。此参数用作伞形参数，用于启用返回近似结果的函数。设置此项等同于设置<code class="codeph">APPROX_COUNT_DISTINCT</code>和<code class="codeph">APPROX_FOR_PERCENTILE</code>参数。
                              </p>
                              <p>以下命令将<code class="codeph">approx_for_aggregation</code>设置为true以用于当前会话：</p><pre class="pre codeblock"><code>alter session set approx_for_aggregation = TRUE;</code></pre></div>
                        </li>
                        <li class="stepexpand"><span>要使用<code class="codeph">APPROX_COUNT_DISTINCT</code>函数仅替换查询中的<code class="codeph">COUNT(DISTINCT)</code>函数：</span><div>
                              <p>为当前会话或整个数据库设置<code class="codeph">approx_for_count_distinct</code>初始化参数为<code class="codeph">TRUE</code> 。
                              </p>
                           </div>
                        </li>
                        <li class="stepexpand"><span>要使用返回近似结果的相应函数替换百分位函数：</span><div>
                              <p>将<code class="codeph">approx_for_percentile</code>设置为当前会话或整个数据库的<code class="codeph">PERCENTILE_CONT</code> ， <code class="codeph">PERCENTILE_DISC</code>或<code class="codeph">ALL</code> （替换所有百分位函数）。此参数的默认值为<code class="codeph">NONE</code> 。</p>
                           </div>
                           <div>
                              <div class="infoboxnotealso" id="GUID-1D8D7119-8571-428D-B1E8-3F31AD2B0DA6__GUID-E2296781-EA00-44B8-8EB4-B038FB4DC064">
                                 <p class="notep1">也可以看看：</p>
                                 <ul style="list-style-type:disc">
                                    <li>
                                       <p><a href="../refrn/APPROX_FOR_AGGREGATION.html#REFRN-GUID-46853DF9-7688-46C7-A5BA-308B9B2DAF67" target="_blank"><span><cite>Oracle数据库参考中的</cite></span></a> <code class="codeph">APROX_FOR_AGGREGATION</code></p>
                                    </li>
                                    <li>
                                       <p><a href="../refrn/APPROX_FOR_COUNT_DISTINCT.html#REFRN-GUID-D2A8A53F-113A-4E6F-AC2E-37139460EF8D" target="_blank"><span><cite>Oracle数据库参考中的</cite></span></a> <code class="codeph">APPROX_FOR_COUNT_DISTINCT</code></p>
                                    </li>
                                    <li>
                                       <p><a href="../refrn/APPROX_FOR_PERCENTILE.html#REFRN-GUID-3872A78C-9B3F-457C-AD28-4E86F71AE74D" target="_blank"><span><cite>Oracle数据库参考中的</cite></span></a> <code class="codeph">APPROX_FOR_PERCENTILE</code></p>
                                    </li>
                                 </ul>
                              </div>
                           </div>
                        </li>
                     </ul>
                  </div>
               </div>
            </div>
            <div class="sect2"><a id="GUID-07B31A40-6AD9-4843-B5B3-D2424ACE39D5" name="GUID-07B31A40-6AD9-4843-B5B3-D2424ACE39D5"></a><h3 id="DWHSG-GUID-07B31A40-6AD9-4843-B5B3-D2424ACE39D5" class="sect3"><span class="enumeration_section">4.7</span>关于近似前N个查询处理</h3>
               <div>
                  <p>从Oracle Database Release 18c开始，为了比传统查询更快地获得前N个查询结果， <code class="codeph">APPROX_COUNT</code>和<code class="codeph">APPROX_SUM</code> SQL函数可以与<code class="codeph">APPROX_RANK</code>一起使用。</p>
                  <div class="section">
                     <p class="subhead2" id="GUID-07B31A40-6AD9-4843-B5B3-D2424ACE39D5__GUID-4F8C6467-8460-4F01-9B4D-4D122E9136EF">APPROX_COUNT</p>
                     <p><a id="d9998e3460" class="indexterm-anchor"></a><a id="d9998e3462" class="indexterm-anchor"></a> <code class="codeph">APPROX_COUNT</code>返回表达式的近似计数。如果提供<code class="codeph">MAX_ERROR</code>作为第二个参数，则该函数返回实际和近似计数之间的最大误差。
                     </p>
                     <p>此函数必须与<code class="codeph">HAVING</code>子句中的相应<code class="codeph">APPROX_RANK</code>函数一起使用。如果查询使用<code class="codeph">APPROX_COUNT</code> ， <code class="codeph">APPROX_SUM</code>或<code class="codeph">APPROX_RANK</code> ，则查询不得使用任何其他聚合函数。
                     </p>
                     <div class="infoboxnotealso" id="GUID-07B31A40-6AD9-4843-B5B3-D2424ACE39D5__GUID-631AACEC-06DE-43A4-B869-074F7905EB3C">
                        <p class="notep1">也可以看看：</p>
                        <ul style="list-style-type:disc">
                           <li>
                              <p><a href="../sqlrf/APPROX_COUNT.html#SQLRF-GUID-7D07E04A-3F9A-425E-BADE-EDA9C6162E9C" target="_blank"><span><cite>Oracle数据库SQL语言参考</cite></span></a></p>
                           </li>
                           <li>
                              <p><a href="sql-analysis-reporting-data-warehouses.html#GUID-9C786E96-2DA7-4430-BD9A-77C4C65854CF">APPROX_RANK函数</a></p>
                           </li>
                        </ul>
                     </div>
                  </div>
                  <!-- class="section" -->
                  <div class="section">
                     <p class="subhead2" id="GUID-07B31A40-6AD9-4843-B5B3-D2424ACE39D5__GUID-BC5DECCA-4A4A-4513-BC53-F7AD294C5B12">APPROX_SUM</p>
                     <p><a id="d9998e3506" class="indexterm-anchor"></a><a id="d9998e3508" class="indexterm-anchor"></a> <code class="codeph">APPROX_SUM</code>返回表达式的近似和。如果提供<code class="codeph">MAX_ERROR</code>作为第二个参数，则该函数返回实际和近似总和之间的最大误差。
                     </p>
                     <p>此函数必须与<code class="codeph">HAVING</code>子句中的相应<code class="codeph">APPROX_RANK</code>函数一起使用。如果查询使用<code class="codeph">APPROX_COUNT</code> ， <code class="codeph">APPROX_SUM</code>或<code class="codeph">APPROX_RANK</code> ，则查询不得使用任何其他聚合函数。
                     </p>
                     <div class="infoboxnote" id="GUID-07B31A40-6AD9-4843-B5B3-D2424ACE39D5__GUID-48810CC6-C7A7-493C-97F4-503A2081980A">
                        <p class="notep1">注意：</p>
                        <p>当输入为负数时， <code class="codeph">APPROX_SUM</code>返回错误。
                        </p>
                     </div>
                     <div class="infoboxnotealso" id="GUID-07B31A40-6AD9-4843-B5B3-D2424ACE39D5__GUID-BB736BF5-7609-428C-970A-5ED1650BCBEE">
                        <p class="notep1">也可以看看：</p>
                        <ul style="list-style-type:disc">
                           <li>
                              <p><a href="../sqlrf/APPROX_SUM.html#SQLRF-GUID-AC2A72A7-24E5-4FB8-B012-BD35CB560D6B" target="_blank"><span><cite>Oracle数据库SQL语言参考</cite></span></a></p>
                           </li>
                           <li>
                              <p><a href="sql-analysis-reporting-data-warehouses.html#GUID-9C786E96-2DA7-4430-BD9A-77C4C65854CF">APPROX_RANK函数</a></p>
                           </li>
                        </ul>
                     </div>
                  </div>
                  <!-- class="section" -->
               </div>
            </div>
         </div>
      </article>
   </body>
</html>