<html lang="en-us" dir="ltr" xml:lang="en-us">
   <head>
      <meta http-equiv="Content-Type" content="text/html; charset=utf-8"></meta>
      <meta name="viewport" content="width=device-width, initial-scale=1"></meta>
      <meta http-equiv="X-UA-Compatible" content="IE=edge"></meta>
      <title>使用LOB和BFILE</title>
      <meta property="og:site_name" content="Oracle Help Center"></meta>
      <meta property="og:title" content="JDBC Developer&#39;s Guide"></meta>
      <meta property="og:description" content=""></meta>
      <link rel="stylesheet" href="/sp_common/book-template/ohc-book-template/css/book.css"></link>
      <link rel="shortcut icon" href="/sp_common/book-template/ohc-common/img/favicon.ico"></link>
      <meta name="application-name" content="JDBC Developer&#39;s Guide"></meta>
      <meta name="generator" content="DITA Open Toolkit version 1.8.5 (Mode = doc)"></meta>
      <meta name="plugin" content="SP_docbuilder HTML plugin release 18.2.2"></meta>
      <link rel="alternate" href="jdbc-developers-guide.pdf" title="PDF File" type="application/pdf"></link>
      <meta name="robots" content="all"></meta>
      <link rel="schema.dcterms" href="http://purl.org/dc/terms/"></link>
      <meta name="dcterms.created" content="2019-02-13T13:20:37-08:00"></meta>
      <meta name="dcterms.title" content="JDBC Developer&#39;s Guide"></meta>
      <meta name="dcterms.dateCopyrighted" content="1999, 2019"></meta>
      <meta name="dcterms.category" content="database"></meta>
      <meta name="dcterms.identifier" content="E96471-02"></meta>
      
      <meta name="dcterms.product" content="en/database/oracle/oracle-database/19"></meta>
      
      <link rel="prev" href="Oracle-object-types.html" title="Previous" type="text/html"></link>
      <link rel="next" href="Oracle-object-references.html" title="Next" type="text/html"></link>
      <script>
        document.write('<style type="text/css">');
        document.write('body > .noscript, body > .noscript ~ * { visibility: hidden; }');
        document.write('</style>');
     </script>
      <script src="/sp_common/book-template/requirejs/require.js" data-main="/sp_common/book-template/ohc-book-template/js/book-config"></script>
      <script>
            if (window.require === undefined) {
                document.write('<script data-main="sp_common/book-template/ohc-book-template/js/book-config" src="sp_common/book-template/requirejs/require.js"><\/script>');
                document.write('<link href="sp_common/book-template/ohc-book-template/css/book.css" rel="stylesheet"/>');
            }
        </script>
      <script type="application/json" id="ssot-metadata">{"primary":{"category":{"short_name":"database","element_name":"Database","display_in_url":true},"suite":{"short_name":"oracle","element_name":"Oracle","display_in_url":true},"product_group":{"short_name":"not-applicable","element_name":"Not applicable","display_in_url":false},"product":{"short_name":"oracle-database","element_name":"Oracle Database","display_in_url":true},"release":{"short_name":"19","element_name":"Release 19","display_in_url":true}}}</script>
      
    <meta name="dcterms.isVersionOf" content="JJDBC"></meta>
    <meta name="dcterms.release" content="Release 19"></meta>
  </head>
   <body dir="ltr">
      <div class="noscript alert alert-danger text-center" role="alert">
         <a href="Oracle-object-types.html" class="pull-left"><span class="glyphicon glyphicon-chevron-left" aria-hidden="true"></span>上一页</a> <a href="Oracle-object-references.html" class="pull-right">下一页<span class="glyphicon glyphicon-chevron-right" aria-hidden="true"></span></a> <span class="fa fa-exclamation-triangle" aria-hidden="true"></span>必须启用JavaScript才能正确显示此内容</div>
      <article>
         <header>
            <ol class="breadcrumb" vocab="http://schema.org/" typeof="BreadcrumbList">
               <li property="itemListElement" typeof="ListItem"><a href="index.html" property="item" typeof="WebPage"><span property="name">JDBC开发人员指南</span></a></li>
               <li property="itemListElement" typeof="ListItem"><a href="data-access-and-manipulation.html" property="item" typeof="WebPage"><span property="name">数据访问和操作</span></a></li>
               <li class="active" property="itemListElement" typeof="ListItem">使用LOB和BFILE</li>
            </ol>
            <a id="GUID-401E10DB-16B5-41C9-965E-E5F286F01E4C" name="GUID-401E10DB-16B5-41C9-965E-E5F286F01E4C"></a><a id="JJDBC15000"></a>
            
            <h2 id="JJDBC-GUID-401E10DB-16B5-41C9-965E-E5F286F01E4C" class="sect2"><span class="enumeration_chapter">14</span>使用LOB和BFILE</h2>
         </header>
         <div class="ind">
            <div>
               <p>本章介绍如何使用Java数据库连接（JDBC）使用数据接口或定位器接口访问和操作大对象（LOB）。</p>
               <p>在以前的版本中，Oracle JDBC驱动程序需要对标准JDBC类型进行Oracle扩展才能在Oracle数据库中执行许多操作。JDBC 3.0降低了使用Oracle扩展的要求，而JDBC 4.0几乎消除了这一限制。有关Oracle扩展的详细信息，请参阅Javasoft Javadoc以<code class="codeph">java.sql</code>和<code class="codeph">javax.sql</code>包，以及Oracle JDBC Javadoc。
               </p>
               <p>本章包含以下部分：</p>
               <ul style="list-style-type:disc">
                  <li>
                     <p><a href="LOBs-and-BFiles.html#GUID-F022FAE8-0EF3-47F1-9ADB-AA2E2EBBB5C0">LOB数据类型</a></p>
                  </li>
                  <li>
                     <p><a href="LOBs-and-BFiles.html#GUID-865A776C-AFE1-493D-84AD-E0911F18CA4C">Oracle SecureFiles</a></p>
                  </li>
                  <li>
                     <p><a href="LOBs-and-BFiles.html#GUID-B88A9B7F-FFDD-4B9F-9B6D-ED9C70B7545F">LOB的数据接口</a></p>
                  </li>
                  <li>
                     <p><a href="LOBs-and-BFiles.html#GUID-6164F905-6CDB-43A0-A80A-780DB358F686">LOB定位器接口</a></p>
                  </li>
                  <li>
                     <p><a href="LOBs-and-BFiles.html#GUID-8302600F-2799-445E-AFB0-BA8DE15DC71E">关于使用临时LOB</a></p>
                  </li>
                  <li>
                     <p><a href="LOBs-and-BFiles.html#GUID-60B921CA-6907-4910-B71C-CF0CA3B99E80">关于使用Open和Close方法打开持久LOB</a></p>
                  </li>
                  <li>
                     <p><a href="LOBs-and-BFiles.html#GUID-F06154EF-1D48-4CF4-A991-3839776A442F">关于使用BFILE</a></p>
                  </li>
               </ul>
               <div class="infoboxnote" id="GUID-401E10DB-16B5-41C9-965E-E5F286F01E4C__GUID-05303C09-B14B-4B96-BE65-BD0CB16FAF16">
                  <p class="notep1">注意：</p>
                  <ul style="list-style-type:disc">
                     <li>
                        <p>在Oracle Database <span class="italic">12c</span>第1版（12.1）中，Oracle JDBC驱动程序支持JDBC 4.0 <code class="codeph">java.sql.NClob</code>接口。
                        </p>
                     </li>
                     <li>
                        <p>在Oracle Database <span class="italic">10g中</span> ，Oracle JDBC驱动程序支持JDBC 3.0 <code class="codeph">java.sql.Clob</code>和<code class="codeph">java.sql.Blob</code>接口。在<code class="codeph">oracle.sql.进行的某些Oracle扩展<code class="codeph">oracle.sql.CLOB</code>和<code class="codeph">oracle.sql.早期Oracle数据库发行版中的BLOB</code>不再是必需的，不推荐使用。您应该将应用程序移植到标准JDBC 3.0接口。
                        </p>
                     </li>
                     <li>
                        <p>在Oracle Database <span class="italic">10g</span>之前，LOB的最大大小为2 <sup>32</sup>字节。自Oracle Database <span class="italic">10g</span>以来，此限制已被删除，并且最大大小限制为可用物理存储的大小。Java LOB应用程序编程接口（API）没有改变。
                        </p>
                     </li>
                  </ul>
               </div>
            </div><a id="JJDBC28530"></a><div class="props_rev_3"><a id="GUID-F022FAE8-0EF3-47F1-9ADB-AA2E2EBBB5C0" name="GUID-F022FAE8-0EF3-47F1-9ADB-AA2E2EBBB5C0"></a><h3 id="JJDBC-GUID-F022FAE8-0EF3-47F1-9ADB-AA2E2EBBB5C0" class="sect3"><span class="enumeration_section">14.1</span> LOB数据类型</h3>
               <div>
                  <div class="section">
                     <p>在Oracle Database <span class="italic">10g</span>之前，LOB的最大大小为2 ^ 32字节。自Oracle Database <span class="italic">10g</span>以来，此限制已被删除，并且最大大小限制为可用物理存储的大小。
                     </p>
                     <p>Oracle数据库支持以下四种LOB数据类型：</p>
                     <ul style="list-style-type:disc">
                        <li>
                           <p>二进制大对象（BLOB）</p>
                           <p>此数据类型用于非结构化二进制数据。</p>
                        </li>
                        <li>
                           <p>字符大对象（CLOB）</p>
                           <p>此数据类型用于字符数据。</p>
                        </li>
                        <li>
                           <p>国字大物（NCLOB）</p>
                           <p>此数据类型用于国家字符数据。</p>
                        </li>
                        <li>
                           <p>BFILE</p>
                           <p>此数据类型用于存储在数据库表空间之外的操作系统文件中的大型二进制数据对象。</p>
                        </li>
                     </ul>
                     <p>BLOB，CLOB和NCLOB持久存储在数据库表空间中，对这些数据类型执行的所有操作都在事务控制之下。</p>
                     <p>BFILE是Oracle专有数据类型，它提供对位于三级存储设备（如硬盘，网络安装文件系统，CD-ROM，PhotoCD和DVD）上的数据库表空间外部的数据的只读访问。BFILE数据不受事务控制，不由数据库备份存储。</p>
                     <p>PL / SQL语言支持LOB数据类型，JDBC接口允许将IN参数传递给PL / SQL过程或函数，以及检索OUT参数或返回。PL / SQL对包括LOB在内的所有数据类型使用值语义，但仅对BFILE使用引用语义。</p>
                  </div>
                  <!-- class="section" -->
               </div>
            </div><a id="JJDBC28532"></a><a id="JJDBC28533"></a><a id="JJDBC28531"></a><div class="props_rev_3"><a id="GUID-865A776C-AFE1-493D-84AD-E0911F18CA4C" name="GUID-865A776C-AFE1-493D-84AD-E0911F18CA4C"></a><h3 id="JJDBC-GUID-865A776C-AFE1-493D-84AD-E0911F18CA4C" class="sect3"><span class="enumeration_section">14.2</span> Oracle SecureFiles</h3>
               <div>
                  <div class="section">
                     <p>Oracle Database <span class="italic">11g</span>第1版（11.1）引入了Oracle SecureFiles，这是一个全新的LOB存储。
                     </p>
                     <p>以下功能可通过现有API透明地将JDBC SecureFiles用于JDBC程序：</p>
                     <ul style="list-style-type:disc">
                        <li>
                           <p>SecureFile压缩使用户能够压缩数据以节省磁盘空间。</p>
                        </li>
                        <li>
                           <p>SecureFile加密引入了一种新的加密工具，允许随机读取和写入加密数据。</p>
                        </li>
                        <li>
                           <p>重复数据删除使Oracle数据库能够自动检测重复的LOB数据，并通过仅存储一个数据副本来节省空间。</p>
                        </li>
                        <li>
                           <p>LOB数据路径优化包括存储层上方的逻辑高速缓存和新的高速缓存模式。</p>
                        </li>
                        <li>
                           <p>高性能空间管理。</p>
                        </li>
                     </ul>
                     <p><code class="codeph">setLobOptions</code>和<code class="codeph">getLobOptions</code> API在PL / SQL包和类型参考中描述，可以通过可调用语句从JDBC访问。
                     </p>
                     <p>以下Oracle SecureFiles功能通过对现有API的更新在数据库中实现：</p>
                     <ul style="list-style-type:disc">
                        <li>
                           <p><a href="LOBs-and-BFiles.html#GUID-865A776C-AFE1-493D-84AD-E0911F18CA4C__CHDGFDFC">isSecureFile方法</a></p>
                        </li>
                        <li>
                           <p><a href="LOBs-and-BFiles.html#GUID-865A776C-AFE1-493D-84AD-E0911F18CA4C__CHDFEBJD">Oracle SecureFiles的零拷贝I / O.</a></p>
                        </li>
                     </ul>
                  </div>
                  <!-- class="section" -->
                  <div class="section" id="GUID-865A776C-AFE1-493D-84AD-E0911F18CA4C__CHDGFDFC">
                     <p class="subhead2" id="GUID-865A776C-AFE1-493D-84AD-E0911F18CA4C__GUID-101B81B4-E66A-452A-BE93-A562D573004F">isSecureFile方法</p>
                  </div>
                  <!-- class="section" -->
                  <div class="section">
                     <p>您可以检查<code class="codeph">BLOB</code>或<code class="codeph">CLOB</code>数据是否使用Oracle SecureFile存储。要实现此目的，请使用<code class="codeph">oracle.jdbc.的以下方法<code class="codeph">oracle.jdbc.OracleBlob</code>或<code class="codeph">oracle.jdbc.OracleClob</code>类：</p><pre class="oac_no_warn" dir="ltr">public boolean isSecureFile（）抛出SQLException</pre><p>如果此方法返回<code class="codeph">true</code> ，则表示您的数据使用SecureFile存储。
                     </p>
                  </div>
                  <!-- class="section" -->
                  <div class="section" id="GUID-865A776C-AFE1-493D-84AD-E0911F18CA4C__CHDFEBJD">
                     <p class="subhead2" id="GUID-865A776C-AFE1-493D-84AD-E0911F18CA4C__GUID-5D7BDA54-2DBA-4D5E-9715-6580D70B35DA">Oracle SecureFiles的零拷贝I / O.</p>
                  </div>
                  <!-- class="section" -->
                  <div class="section">
                     <p>随着Oracle Database 12 <span class="italic">c</span>第2版（12.2）JDBC驱动程序的发布，Oracle SecureFiles操作的性能得到极大提高，因为Oracle Net Services现在使用零拷贝I / O框架来实现更好的缓冲区管理。
                     </p>
                     <p>Oracle Database <span class="italic">11g</span>第2版引入了一个新的连接属性<code class="codeph">oracle.net.useZeroCopyIO</code> 。此属性可用于启用或禁用零拷贝I / O协议。此连接属性定义为以下常量： <code class="codeph">OracleConnection.CONNECTION_PROPERTY_THIN_NET_USE_ZERO_COPY_IO</code> 。如果要禁用零拷贝I / O框架，请将此连接属性的值设置为<code class="codeph">false</code> 。默认情况下，此连接属性的值为<code class="codeph">true</code> 。
                     </p>
                  </div>
                  <!-- class="section" -->
               </div>
            </div><a id="JJDBC28534"></a><div class="props_rev_3"><a id="GUID-B88A9B7F-FFDD-4B9F-9B6D-ED9C70B7545F" name="GUID-B88A9B7F-FFDD-4B9F-9B6D-ED9C70B7545F"></a><h3 id="JJDBC-GUID-B88A9B7F-FFDD-4B9F-9B6D-ED9C70B7545F" class="sect3"><span class="enumeration_section">14.3</span> LOB的数据接口</h3>
               <div>
                  <div class="section">
                     <p>本节介绍以下主题：</p>
                     <ul style="list-style-type:disc">
                        <li>
                           <p><a href="LOBs-and-BFiles.html#GUID-9D0B59D6-0267-4B42-A742-B964E6737CFE">精简机制</a></p>
                        </li>
                        <li>
                           <p><a href="LOBs-and-BFiles.html#GUID-8FD40D53-8D64-4187-9F6F-FF78242188AD">输入</a></p>
                        </li>
                        <li>
                           <p><a href="LOBs-and-BFiles.html#GUID-68B496D6-B82A-4D98-83A8-D5E01D5FF4A8">产量</a></p>
                        </li>
                        <li>
                           <p><a href="LOBs-and-BFiles.html#GUID-4AA41511-A68C-435B-BDFA-A27F8BFD1DD5">CallableSatement和IN OUT参数</a></p>
                        </li>
                        <li>
                           <p><a href="LOBs-and-BFiles.html#GUID-214CA60C-AB44-4406-A72F-6AF138D7DA55">大小限制</a></p>
                        </li>
                     </ul>
                  </div>
                  <!-- class="section" -->
               </div><a id="JJDBC28535"></a><div class="props_rev_3"><a id="GUID-9D0B59D6-0267-4B42-A742-B964E6737CFE" name="GUID-9D0B59D6-0267-4B42-A742-B964E6737CFE"></a><h4 id="JJDBC-GUID-9D0B59D6-0267-4B42-A742-B964E6737CFE" class="sect4"><span class="enumeration_section">14.3.1</span>简化机制</h4>
                  <div>
                     <div class="section">
                        <p>Oracle Database <span class="italic">12c</span>第1版（12.1）JDBC驱动程序提供了一种简化的机制，用于编写和读取整个LOB内容。这被称为数据接口。数据接口使用标准JDBC方法（如<code class="codeph">getString</code>和<code class="codeph">setBytes</code>来读取和写入LOB数据。在许多情况下，编码更简单，速度更快。与标准<code class="codeph">java.sql.不同<code class="codeph">java.sql.Blob</code> ， <code class="codeph">java.sql.Clob</code>和<code class="codeph">java.sql.NClob</code>接口，它不提供随机访问功能，也就是说，它不使用LOB定位器，并且不能访问2147483648元素之外的数据。
                        </p>
                     </div>
                     <!-- class="section" -->
                  </div>
               </div><a id="JJDBC28537"></a><a id="JJDBC28536"></a><div class="props_rev_3"><a id="GUID-8FD40D53-8D64-4187-9F6F-FF78242188AD" name="GUID-8FD40D53-8D64-4187-9F6F-FF78242188AD"></a><h4 id="JJDBC-GUID-8FD40D53-8D64-4187-9F6F-FF78242188AD" class="sect4"><span class="enumeration_section">14.3.2</span>输入</h4>
                  <div>
                     <div class="section">
                        <p>在Oracle数据库12 <span class="italic">c</span>解除1（12.2），所述<code class="codeph">setBytes</code> ， <code class="codeph">setBinaryStream</code> ， <code class="codeph">setString</code> ， <code class="codeph">setCharacterStream</code> ，和<code class="codeph">setAsciiStream</code>的方法<code class="codeph">PreparedStatement</code>延伸以增强与工作能力<code class="codeph">BLOB</code> ， <code class="codeph">CLOB</code>和<code class="codeph">NCLOB</code>目标列。如果已知数据的长度，那么为了获得更好的性能，请使用接受数据长度作为参数的setBinaryStream或setCharacterStream方法的版本。
                        </p>
                        <div class="infoboxnote" id="GUID-8FD40D53-8D64-4187-9F6F-FF78242188AD__GUID-104B9DA9-5EC9-4D79-9646-35B6C593DF5F">
                           <p class="notep1">注意：</p>
                           <p>此增强功能不会影响<code class="codeph">BFILE</code>数据，因为它是只读的。
                           </p>
                        </div>
                        <p>对于JDBC Oracle调用接口（OCI）和Thin驱动程序，对<code class="codeph">byte</code>数组或<code class="codeph">String</code>的大小没有限制，并且对流函数指定的长度没有限制，除了Java语言强加的限制。
                        </p>
                        <div class="infoboxnote" id="GUID-8FD40D53-8D64-4187-9F6F-FF78242188AD__GUID-E59461EB-6A39-4855-BBFB-DFFAFA480538">
                           <p class="notep1">注意：</p>
                           <p>在Java中，数组大小仅限于正Java <code class="codeph">int</code>或2147483648元素。
                           </p>
                        </div>
                        <p>对于服务器端内部驱动程序，当前对SQL语句的操作（例如<code class="codeph">INSERT</code>语句）存在32767字节的限制。此限制不适用于PL / SQL语句。<code class="codeph">INSERT</code>语句有一个简单的解决方法，它以下列方式包装在PL / SQL块中：</p><pre class="oac_no_warn" dir="ltr">BEGIN INSERT id，c INTO clob_tab VALUES（？，？）;结束;</pre><p>您必须牢记以下自动切换大数据的输入模式：</p>
                        <ul style="list-style-type:disc">
                           <li>
                              <p>有三种输入模式如下：</p>
                              <ul style="list-style-type:disc">
                                 <li>
                                    <p>直接绑定</p>
                                    <p>这种结合的大小有限但效率最高。它将所有输入列的数据内联到发送到服务器的数据块中。所有数据（包括批次的多次执行）都在单个网络操作中发送。</p>
                                 </li>
                                 <li>
                                    <p>流绑定</p>
                                    <p>此绑定将数据放在最后。它将批量大小限制为一个，可能需要多次往返才能完成。</p>
                                 </li>
                                 <li>
                                    <p>LOB绑定</p>
                                    <p>此绑定创建临时LOB，将数据复制到LOB，并绑定LOB定位器。临时LOB在执行后自动释放。创建临时LOB然后写入LOB的操作需要多次往返。定位器的输入可以是批处理的。</p>
                                 </li>
                              </ul>
                           </li>
                           <li>
                              <p>对于SQL语句：</p>
                              <ul style="list-style-type:disc">
                                 <li>
                                    <p><code class="codeph">setBytes</code>和<code class="codeph">setBinaryStream</code>方法对小于32767字节的数据使用直接绑定。
                                    </p>
                                 </li>
                                 <li>
                                    <p><code class="codeph">setBytes</code>和<code class="codeph">setBinaryStream</code>方法对大于32767字节的数据使用流绑定。
                                    </p>
                                 </li>
                                 <li>
                                    <p>在JDBC 4.0公司推出的新形式<code class="codeph">setAsciiStream</code> ， <code class="codeph">setBinaryStream</code>和<code class="codeph">setCharacterStream</code>方法。方法将长参数作为长度的形式使用LOB绑定，长度大于2147483648。未指定长度的表单始终使用LOB绑定。
                                    </p>
                                 </li>
                                 <li>
                                    <p>该<code class="codeph">setString</code> ， <code class="codeph">setCharacterStream</code> ，并<code class="codeph">setAsciiStream</code>方法，使用直接用于超过32767个字符，更小的数据绑定。
                                    </p>
                                 </li>
                                 <li>
                                    <p>的<code class="codeph">setString</code> ， <code class="codeph">setCharacterStream</code> ，并<code class="codeph">setAsciiStream</code>方法使用流超过32766个字符更大的数据绑定。
                                    </p>
                                 </li>
                                 <li>
                                    <p><code class="codeph">setCharacterStream</code>方法的新形式（长度为<code class="codeph">long</code>参数）在JDBC 4.0中使用长度大于2147483647的LOB绑定。未指定长度的表单始终使用LOB绑定。
                                    </p>
                                 </li>
                              </ul>
                           </li>
                           <li>
                              <p>PL / SQL语句</p>
                              <ul style="list-style-type:disc">
                                 <li>
                                    <p><code class="codeph">setBytes</code>和<code class="codeph">setBinary</code>流方法对小于32767字节的数据使用直接绑定。
                                    </p>
                                    <div class="infoboxnote" id="GUID-8FD40D53-8D64-4187-9F6F-FF78242188AD__GUID-96DE1EC2-1E5A-4CC8-ACCB-F8D8ABE0DD5E">
                                       <p class="notep1">注意：</p>
                                       <p>如果基础数据库是Oracle数据库版本10.x，则此数据大小限制为32512字节，但您使用的是Oracle Database 12 <span class="italic">c</span>第1版（12.1）JDBC驱动程序。
                                       </p>
                                    </div>
                                 </li>
                                 <li>
                                    <p><code class="codeph">setBytes</code>和<code class="codeph">setBinaryStream</code>方法对大于32766字节的数据使用LOB绑定。
                                    </p>
                                 </li>
                                 <li>
                                    <p>该<code class="codeph">setString</code> ， <code class="codeph">setCharacterStream</code> ，并<code class="codeph">setAsciiStream</code>方法，使用直接用于比数据库中的字符集32767个字节较小的数据绑定。
                                    </p>
                                    <div class="infoboxnote" id="GUID-8FD40D53-8D64-4187-9F6F-FF78242188AD__GUID-8086F663-CA32-4C13-B94B-0B2EFAFF50FE">
                                       <p class="notep1">注意：</p>
                                       <p>如果基础数据库是Oracle数据库版本10.x，则此数据大小限制为32512字节，但您使用的是Oracle Database 12 <span class="italic">c</span>第1版（12.1）JDBC驱动程序。
                                       </p>
                                    </div>
                                 </li>
                                 <li>
                                    <p>的<code class="codeph">setString</code> ， <code class="codeph">setCharacterStream</code> ，并<code class="codeph">setAsciiStream</code>方法使用LOB为比数据库中的字符集32766个字节的数据绑定。
                                    </p>
                                 </li>
                              </ul>
                           </li>
                        </ul>
                        <p>大数据输入模式的自动切换对某些程序有影响。以前，对于大于32766个字符的<code class="codeph">String</code>值，尝试使用<code class="codeph">setString</code>方法时，您常常会收到<code class="codeph">ORA-17157</code>错误。现在，根据目标参数的类型，在执行语句或操作可能成功时可能会发生错误。
                        </p>
                        <p>另一个影响是自动切换可能导致额外的服务器端解析以适应参数类型的变化。如果数据大小高于和低于重复执行语句的限制，则会导致性能影响。切换到流模式也会影响批处理。</p>
                     </div>
                     <!-- class="section" -->
                     <div class="section">
                        <p class="subhead3" id="GUID-8FD40D53-8D64-4187-9F6F-FF78242188AD__GUID-AE879C59-9128-4530-831C-83BD41B9A55E">强制转换为LOB</p>
                     </div>
                     <!-- class="section" -->
                     <div class="section">
                        <p><code class="codeph">setBytesForBlob</code>和<code class="codeph">setStringForClob</code>方法，存在于<code class="codeph">oracle.jdbc.OraclePreparedStatement</code>接口，对任何数据大小使用LOB绑定。
                        </p>
                        <p>不再使用或不需要Oracle Database <span class="italic">10g</span>第1版的<code class="codeph">SetBigStringTryClob</code>连接属性。
                        </p>
                     </div>
                     <!-- class="section" -->
                  </div>
               </div><a id="JJDBC28538"></a><div class="props_rev_3"><a id="GUID-68B496D6-B82A-4D98-83A8-D5E01D5FF4A8" name="GUID-68B496D6-B82A-4D98-83A8-D5E01D5FF4A8"></a><h4 id="JJDBC-GUID-68B496D6-B82A-4D98-83A8-D5E01D5FF4A8" class="sect4"><span class="enumeration_section">14.3.3</span>输出</h4>
                  <div>
                     <div class="section">
                        <p><code class="codeph">ResultSet</code>和<code class="codeph">CallableStatement</code>的<code class="codeph">getBytes</code> ， <code class="codeph">getBinaryStream</code> ， <code class="codeph">getString</code> ， <code class="codeph">getCharacterStream</code>和<code class="codeph">getAsciiStream</code>方法被扩展为使用<code class="codeph">BLOB</code> ， <code class="codeph">CLOB</code>和<code class="codeph">BFILE</code>列或<code class="codeph">OUT</code>参数。这些方法适用于任何长度小于2147483648的<code class="codeph">LOB</code> 。
                        </p>
                        <div class="infoboxnote" id="GUID-68B496D6-B82A-4D98-83A8-D5E01D5FF4A8__GUID-C282EA45-1FA3-4796-BB23-5105D1F0AEF6">
                           <p class="notep1">注意：</p>
                           <p><code class="codeph">getString</code>和<code class="codeph">getNString</code>方法不能用于检索BLOB列值。
                           </p>
                        </div>
                        <p>数据接口通过访问驱动程序内的<code class="codeph">LOB</code>定位符来运行，并且对应用程序编程是透明的。它适用于任何受支持的数据库版本，即Oracle Database 10.1.x及更高版本。对于Oracle Database <span class="italic">11g</span>第1版或更高版本，可以使用LOB预取来减少或消除所需的任何其他数据库往返。
                        </p>
                        <p>您可以使用<code class="codeph">defineColumnType</code>方法读取<code class="codeph">BFILE</code>数据并读取和写入<code class="codeph">BLOB</code>或<code class="codeph">CLOB</code>数据。要阅读，请使用<code class="codeph">defineColumnType(nn,</code> <code class="codeph">Types.LONGVARBINARY)</code>或<code class="codeph">defineColumnType(nn,Types.列上的LONGVARCHAR)</code>方法。这会在数据上生成直接流，就像它是<code class="codeph">LONG RAW</code>或<code class="codeph">LONG</code>列一样。此技术仅限于Oracle Database <span class="italic">10g第</span> 1版（10.1）及更高版本。
                        </p>
                     </div>
                     <!-- class="section" -->
                  </div>
                  <div>
                     <div class="relinfo">
                        <p><strong>相关话题</strong></p>
                        <ul>
                           <li><a href="globalization-support.html#GUID-DB3BCB15-C62F-47B1-B527-5F2DF28E5CFB">JDK 6中国家字符集类型数据的新方法</a></li>
                           <li><a href="LOBs-and-BFiles.html#GUID-6164F905-6CDB-43A0-A80A-780DB358F686">LOB定位器接口</a></li>
                        </ul>
                     </div>
                  </div>
                  
               </div><a id="JJDBC28539"></a><div class="props_rev_3"><a id="GUID-4AA41511-A68C-435B-BDFA-A27F8BFD1DD5" name="GUID-4AA41511-A68C-435B-BDFA-A27F8BFD1DD5"></a><h4 id="JJDBC-GUID-4AA41511-A68C-435B-BDFA-A27F8BFD1DD5" class="sect4"><span class="enumeration_section">14.3.4</span> CallableSatement和IN OUT参数</h4>
                  <div>
                     <div class="section">
                        <p>作为PL / SQL要求，用作IN OUT参数的输入和输出的Java类型必须相同。由本章中描述的扩展完成的类型的自动切换可能会导致此问题。</p>
                        <p>请考虑您具有存储过程的<code class="codeph">IN</code> <code class="codeph">OUT</code> <code class="codeph">CLOB</code>参数，并且您希望使用<code class="codeph">setString</code>方法来设置此参数的值。对于任何<code class="codeph">IN</code>和<code class="codeph">OUT</code>参数，绑定必须是相同类型。除非您确定数据大小，否则自动切换输入模式将导致问题。例如，如果已知输入和输出数据都不会大于32766字节，则可以使用<code class="codeph">setString</code>方法作为输入参数，并将<code class="codeph">OUT</code>参数注册为<code class="codeph">Types.VARCHAR</code>并使用<code class="codeph">getString</code>方法作为输出参数。
                        </p>
                        <p>更好的解决方案是将存储过程更改为具有单独的<code class="codeph">IN</code>和<code class="codeph">OUT</code>参数。也就是说，如果你有：</p><pre class="oac_no_warn" dir="ltr">CREATE PROCEDURE clob_proc（c IN OUT CLOB）;</pre><p>然后，将其更改为：</p><pre class="oac_no_warn" dir="ltr">CREATE PROCEDURE clob_proc（c_in IN CLOB，c_out OUT CLOB）;</pre><p>另一种解决方法是使用容器块来进行调用。<code class="codeph">clob_proc</code>过程可以用Java String包装以用于<code class="codeph">prepareCall</code>语句，如下所示：</p><pre class="oac_no_warn" dir="ltr">“DECLARE c_temp; BEGIN c_temp：=？; clob_proc（c_temp）; ？ ：= c_temp;结束;”</pre><p>在任何一种情况下，您都可以对第一个参数使用<code class="codeph">setString</code>方法，对<code class="codeph">Types.使用<code class="codeph">registerOutParameter</code>方法<code class="codeph">Types.CLOB</code>就秒了。
                        </p>
                     </div>
                     <!-- class="section" -->
                  </div>
               </div><a id="JJDBC28540"></a><div class="props_rev_3"><a id="GUID-214CA60C-AB44-4406-A72F-6AF138D7DA55" name="GUID-214CA60C-AB44-4406-A72F-6AF138D7DA55"></a><h4 id="JJDBC-GUID-214CA60C-AB44-4406-A72F-6AF138D7DA55" class="sect4"><span class="enumeration_section">14.3.5</span>大小限制</h4>
                  <div>
                     <div class="section">
                        <p>请注意由于创建非常大的<code class="codeph">byte</code>数组或<code class="codeph">String</code>而对Java内存管理系统的性能产生的影响。阅读Java虚拟机（JVM）供应商提供的有关非常大的数据元素对内存管理的影响的信息，并考虑使用流接口。
                        </p>
                     </div>
                     <!-- class="section" -->
                  </div>
               </div>
            </div><a id="JJDBC28542"></a><a id="JJDBC28543"></a><a id="JJDBC28541"></a><div class="props_rev_3"><a id="GUID-6164F905-6CDB-43A0-A80A-780DB358F686" name="GUID-6164F905-6CDB-43A0-A80A-780DB358F686"></a><h3 id="JJDBC-GUID-6164F905-6CDB-43A0-A80A-780DB358F686" class="sect3"><span class="enumeration_section">14.4</span> LOB定位器接口</h3>
               <div>
                  <div class="section">
                     <p>定位器是小型数据结构，包含可用于访问LOB实际数据的信息。在数据库表中，定位器直接存储在表中，而数据可以在表中或单独的存储中。对大型LOB使用单独的表空间是很常见的。</p>
                     <p>在JDBC 4.0中，应使用接口<code class="codeph">java.sql.读取或写入LOB <code class="codeph">java.sql.Blob</code> ， <code class="codeph">java.sql.Clob</code>和<code class="codeph">java.sql.NClob</code> 。它们提供对LOB中数据的随机访问。</p>
                     <p>Oracle实现类<code class="codeph">oracle.sql.BLOB</code> ， <code class="codeph">oracle.sql.CLOB</code>和<code class="codeph">oracle.sql.NCLOB</code>存储定位器并使用它访问数据。<code class="codeph">oracle.sql.BLOB</code>和<code class="codeph">oracle.sql.CLOB</code>类实现<code class="codeph">java.sql.Blob</code>和<code class="codeph">java.sql.Clob</code>接口分别。在<code class="codeph">ojdbc6.jar</code> ， <code class="codeph">oracle.sql.NCLOB</code>实现了<code class="codeph">java.sql.NClob</code> ，但是在<code class="codeph">ojdbc5.jar</code> ，它实现了<code class="codeph">java.sql.Clob</code>界面。
                     </p>
                     <div class="infoboxnote" id="GUID-6164F905-6CDB-43A0-A80A-780DB358F686__GUID-D12E3666-BF70-463E-BCAA-05A71C520E66">
                        <p class="notep1">注意：</p>
                        <p>从Oracle Database 12 <span class="italic">c</span>第1版（12.1）开始， <code class="codeph">oracle.sql.BLOB</code>和<code class="codeph">oracle.sql.不推荐使用CLOB</code>类，并将其替换为<code class="codeph">oracle.jdbc.OracleBlob</code>和<code class="codeph">oracle.jdbc.OracleClob</code>接口。Oracle建议您尽可能使用<code class="codeph">java.sql</code>包中提供的方法，以<code class="codeph">java.sql</code> Oracle特定扩展的<code class="codeph">oracle.jdbc</code>包中提供的标准兼容性和方法。有关这些接口的更多信息，请参阅MoS Note 1364193.1。
                        </p>
                     </div>
                     <p>在Oracle Database <span class="italic">12c</span>第1版（12.1）中，Oracle JDBC驱动程序支持JDBC 4.0 <code class="codeph">java.sql.<code class="codeph">ojdbc6.jar</code>和<code class="codeph">ojdbc7.jar</code> NClob</code>接口，分别使用JDK 6（必须与JRE 6一起使用）和JDK 7（必须与JRE 7一起使用）进行编译。
                     </p>
                     <p>相比之下， <code class="codeph">oracle.sql.BFILE</code>是Oracle扩展，没有相应的<code class="codeph">java.sql</code>接口。
                     </p>
                     <div class="infoboxnotealso" id="GUID-6164F905-6CDB-43A0-A80A-780DB358F686__GUID-B28FEF43-3F12-400D-8013-EB1EC58A5BAE">
                        <p class="notep1">也可以看看：</p>
                        <p>有关更多详细信息，请参阅JDBC Javadoc。</p>
                     </div>
                  </div>
                  <!-- class="section" -->
                  <div class="section" id="GUID-6164F905-6CDB-43A0-A80A-780DB358F686__CHDGDGBA">
                     <p class="subhead2" id="GUID-6164F905-6CDB-43A0-A80A-780DB358F686__GUID-9F391CBB-272D-4E99-B87B-3877FE1D6675">LOB预取</p>
                  </div>
                  <!-- class="section" -->
                  <div class="section">
                     <p>对于Oracle Database 12 <span class="italic">c</span>第1版（12.1）JDBC驱动程序，通过在常规提取操作期间预取元数据（如LOB长度和块大小）以及LOB数据的开头以及定位符来减少往返次数。 。如果在结果集中选择LOB列，则在获取定位符时会向客户端预取部分或全部数据。它通过推迟所有先前操作直到从定位器获取来保存第一次往返以检索数据。
                     </p>
                     <div class="infoboxnote" id="GUID-6164F905-6CDB-43A0-A80A-780DB358F686__GUID-BBBD4F19-4B7F-45DC-94CF-66A93DFF1FD6">
                        <p class="notep1">注意：</p>
                        <p>LOB预取与LOB数据的大小成反比，也就是说，预取的好处对于小LOB更多，对于更大LOB则更少。</p>
                     </div>
                     <p>对于BLOB和CLOB的字符，预取大小以字节为单位指定。可以通过设置连接属性<code class="codeph">oracle.jdbc.defaultLobPrefetchSize</code>来指定它。可以通过以下两种方式覆盖此属性的值：</p>
                     <ul style="list-style-type:disc">
                        <li>
                           <p>在语句级别：通过使用<code class="codeph">oracle.jdbc.OracleStatement.setLobPrefetchSize(int)</code>方法</p>
                        </li>
                        <li>
                           <p>在列级别：使用以长度作为参数的<code class="codeph">defineColumnType</code>方法的形式</p>
                        </li>
                     </ul>
                     <p>默认预取大小为4000。</p>
                     <div class="infoboxnote" id="GUID-6164F905-6CDB-43A0-A80A-780DB358F686__GUID-0E4B658C-B6E9-4F5C-9DB2-4A37803FDB78">
                        <p class="notep1">注意：</p>
                        <p>在设置大型LOB预取大小并结合大行预取大小和大量LOB列时，请注意可能的内存消耗。</p>
                     </div>
                     <div class="infoboxnotealso" id="GUID-6164F905-6CDB-43A0-A80A-780DB358F686__GUID-62FF3225-98B9-4A1D-AA5F-6D08C3C0EB1A">
                        <p class="notep1">也可以看看：</p>
                        <p>有关更多详细信息，请参阅JDBC Javadoc</p>
                     </div>
                  </div>
                  <!-- class="section" -->
                  <div class="section">
                     <p class="subhead2" id="GUID-6164F905-6CDB-43A0-A80A-780DB358F686__GUID-AB6ADC36-B093-47F1-B5D6-F6BE1B4F620D">JDBC 4.0中的新LOB API</p>
                  </div>
                  <!-- class="section" -->
                  <div class="section">
                     <p>Oracle Database <span class="italic">11g</span>第1版引入了<code class="codeph">java.sql.NClob</code>接口。Oracle驱动程序实现了<code class="codeph">oracle.sql.NCLOB</code>和<code class="codeph">java.sql.<code class="codeph">ojdbc6.jar</code>和<code class="codeph">ojdbc7.jar</code> NCLOB</code>接口。
                     </p>
                     <p>Oracle驱动程序在<code class="codeph">java.sql.实现新的工厂方法<code class="codeph">createBlob</code> ， <code class="codeph">createClob</code>和<code class="codeph">createNClob</code> <code class="codeph">java.sql.用于创建临时LOB的Connection</code>接口。
                     </p>
                     <p>从JDK 6开始， <code class="codeph">java.sql.Blob</code> ， <code class="codeph">java.sql.Clob</code>和<code class="codeph">java.sql.NClob</code>接口有一个<code class="codeph">free</code>释放LOB并释放相关资源的新方法。如果是临时LOB，Oracle驱动程序使用此方法释放LOB。</p>
                  </div>
                  <!-- class="section" -->
               </div>
            </div><a id="JJDBC28544"></a><div class="props_rev_3"><a id="GUID-8302600F-2799-445E-AFB0-BA8DE15DC71E" name="GUID-8302600F-2799-445E-AFB0-BA8DE15DC71E"></a><h3 id="JJDBC-GUID-8302600F-2799-445E-AFB0-BA8DE15DC71E" class="sect3"><span class="enumeration_section">14.5</span>关于使用临时LOB</h3>
               <div>
                  <div class="section">
                     <p>您可以使用临时LOB来存储瞬态数据。数据存储在临时表空间而不是常规表空间中。在不再需要它们之后，您应该释放临时LOB。如果不这样做，那么LOB在临时表空间中占用的空间将不会被回收。</p>
                     <p>您可以将临时LOB插入表中。执行此操作时，将创建并存储LOB的永久副本。</p>
                     <div class="infoboxnote" id="GUID-8302600F-2799-445E-AFB0-BA8DE15DC71E__GUID-8CA81244-95F2-4CCC-8A82-FD1E5F9700C9">
                        <p class="notep1">注意：</p>
                        <p>在某些情况下，插入临时LOB可能更为可取。例如，当LOB数据相对较小并且复制数据的开销小于数据库往返检索空定位符的成本时。请记住，数据最初存储在服务器上的临时表空间中，然后移动到永久存储中。</p>
                     </div>
                     <p>使用<code class="codeph">static</code>方法<code class="codeph">createTemporary</code>创建临时LOB，在<code class="codeph">oracle.sql.定义<code class="codeph">oracle.sql.BLOB</code>和<code class="codeph">oracle.sql.CLOB</code>类。您使用<code class="codeph">freeTemporary</code>方法释放临时LOB。
                     </p>
                     <p>您还可以使用JDBC 4.0中提供的连接工厂方法创建临时LOB / CLOB或NCLOB。</p>
                     <p>您可以通过调用<code class="codeph">isTemporary</code>方法来测试LOB是否是临时的。如果通过调用<code class="codeph">createTemporary</code>方法创建LOB，则<code class="codeph">isTemporary</code>方法返回<code class="codeph">true</code> ，否则返回<code class="codeph">false</code> 。
                     </p>
                     <p>您可以通过调用<code class="codeph">freeTemporary</code>方法释放临时LOB。在结束会话或致电之前释放任何临时LOB。
                     </p>
                     <div class="infoboxnote" id="GUID-8302600F-2799-445E-AFB0-BA8DE15DC71E__GUID-968C6FA7-3E47-47C0-95C9-444E1A97EE0E">
                        <p class="notep1">注意：</p>
                        <ul style="list-style-type:disc">
                           <li>
                              <p>如果您没有释放临时LOB，那么它将使该数据库中的LOB使用的存储不可用。经常无法释放临时LOB将导致填充具有不可用LOB存储的临时表空间。</p>
                           </li>
                           <li>
                              <p>当从获取数据<code class="codeph">ReultSet</code>与是临时的LOB的列，使用<code class="codeph">getClob</code>或<code class="codeph">getBlob</code>方法代替<code class="codeph">getString</code>或<code class="codeph">getBytes</code> 。
                              </p>
                           </li>
                           <li>
                              <p>JDBC 4.0方法<code class="codeph">free</code> ，存在于<code class="codeph">java.sql.Blob</code> ， <code class="codeph">java.sql.Clob</code>和<code class="codeph">java.sql.NClob</code>接口取代了<code class="codeph">freeTemporary</code>方法。
                              </p>
                           </li>
                        </ul>
                     </div>
                  </div>
                  <!-- class="section" -->
               </div>
               <div>
                  <div class="relinfo">
                     <p><strong>相关话题</strong></p>
                     <ul>
                        <li><a href="JDBC-standards-support.html#GUID-12AE5875-3CFC-48EA-949B-539B7A56FF82">LOB创作</a></li>
                     </ul>
                  </div>
               </div>
               
            </div><a id="JJDBC28547"></a><div class="props_rev_3"><a id="GUID-60B921CA-6907-4910-B71C-CF0CA3B99E80" name="GUID-60B921CA-6907-4910-B71C-CF0CA3B99E80"></a><h3 id="JJDBC-GUID-60B921CA-6907-4910-B71C-CF0CA3B99E80" class="sect3"><span class="enumeration_section">14.6</span>关于使用Open和Close方法打开持久LOB</h3>
               <div>
                  <div class="section">
                     <p>本节讨论如何打开和关闭LOB。使用<code class="codeph">oracle.sql.的以下方法提供此功能的JDBC实现<code class="codeph">oracle.sql.BLOB</code>和<code class="codeph">oracle.sql.CLOB</code>接口：</p>
                     <ul style="list-style-type:disc">
                        <li>
                           <p><code class="codeph">void open（int模式）</code></p>
                        </li>
                        <li>
                           <p><code class="codeph">void close（）</code></p>
                        </li>
                        <li>
                           <p><code class="codeph">boolean isOpen（）</code></p>
                        </li>
                     </ul>
                     <div class="infoboxnote" id="GUID-60B921CA-6907-4910-B71C-CF0CA3B99E80__GUID-3F8966D0-3864-4AF2-AC88-8D5E4DA90067">
                        <p class="notep1">注意：</p>
                        <ul style="list-style-type:disc">
                           <li>
                              <p>从Oracle Database 12 <span class="italic">c</span>第1版（12.1）开始， <code class="codeph">oracle.sql.BLOB</code>和<code class="codeph">oracle.sql.不推荐使用CLOB</code>类，并将其替换为<code class="codeph">oracle.jdbc.OracleBlob</code>和<code class="codeph">oracle.jdbc.OracleClob</code>接口。Oracle建议您尽可能使用<code class="codeph">java.sql</code>包中提供的方法，以<code class="codeph">java.sql</code> Oracle特定扩展的<code class="codeph">oracle.jdbc</code>包中提供的标准兼容性和方法。有关这些接口的更多信息，请参阅MoS Note 1364193.1。
                              </p>
                           </li>
                           <li>
                              <p>您无需打开和关闭LOB。出于性能原因，您可以选择打开和关闭它们。</p>
                           </li>
                        </ul>
                     </div>
                     <p>如果不在<code class="codeph">Open/Close</code>调用操作中包装LOB操作，则对LOB的每次修改都将隐式打开和关闭LOB，从而触发域索引上的任何触发器。请注意，在这种情况下，只要进行LOB修改，LOB上的任何域索引都将更新。因此，域LOB索引始终有效，并且可以在同一事务中的任何时间使用。
                     </p>
                     <p>如果将LOB操作包装在<code class="codeph">Open/Close</code>调用操作中，则不会为每个LOB修改触发触发器。相反，域索引上的触发器将在<code class="codeph">Close</code>调用时触发。例如，您可以设计应用程序，以便在调用<code class="codeph">close</code>方法之前不会更新域索引。但是，这意味着LOB上的任何域索引在<code class="codeph">Open/Close</code>调用之间都无效。
                     </p>
                     <p>您通过调用<code class="codeph">open</code>或<code class="codeph">open(int)</code>方法打开LOB。然后，您可以在没有与该LOB触发相关联的任何触发器的情况下读取和写入LOB。完成访问LOB后，通过调用<code class="codeph">close</code>方法关闭LOB。当您关闭LOB时，将触发与LOB关联的任何触发器。
                     </p>
                     <p>您可以通过调用<code class="codeph">isOpen</code>方法来检查LOB是打开还是关闭。如果通过调用<code class="codeph">open(int)</code>方法打开LOB，则参数的值必须是<code class="codeph">MODE_READONLY</code>或<code class="codeph">MODE_READWRITE</code> ，如<code class="codeph">oracle.sql.所定义<code class="codeph">oracle.sql.BLOB</code>和<code class="codeph">oracle.sql.CLOB</code>类。如果使用<code class="codeph">MODE_READONLY</code>打开LOB，则任何写入LOB的尝试都将导致SQL异常。
                     </p>
                     <div class="infoboxnote" id="GUID-60B921CA-6907-4910-B71C-CF0CA3B99E80__GUID-EA650665-1AED-4310-9B8A-7606F45ABE31">
                        <p class="notep1">注意：</p>
                        <ul style="list-style-type:disc">
                           <li>
                              <p>如果在关闭事务打开的所有LOB之前提交事务，则会发生错误。打开LOB的开放性被丢弃，但事务已成功提交。因此，提交了对事务中的LOB和非LOB数据所做的所有更改，但域索引的触发器不是固定的。</p>
                           </li>
                           <li>
                              <p><code class="codeph">open</code>和<code class="codeph">close</code>方法仅适用于持久性LOB。<code class="codeph">close</code>方法与用于临时LOB的<code class="codeph">free</code>或<code class="codeph">freeTemporary</code>方法不同。<code class="codeph">free</code>和<code class="codeph">freeTemporary</code>方法释放存储并使LOB无法使用。另一方面， <code class="codeph">close</code>方法向数据库指示对LOB的修改已完成，并且应触发触发器并更新索引。在调用<code class="codeph">close</code>方法后，LOB仍然可用。
                              </p>
                           </li>
                        </ul>
                     </div>
                  </div>
                  <!-- class="section" -->
               </div>
            </div><a id="JJDBC28550"></a><a id="JJDBC28551"></a><a id="JJDBC28549"></a><div class="props_rev_3"><a id="GUID-F06154EF-1D48-4CF4-A991-3839776A442F" name="GUID-F06154EF-1D48-4CF4-A991-3839776A442F"></a><h3 id="JJDBC-GUID-F06154EF-1D48-4CF4-A991-3839776A442F" class="sect3"><span class="enumeration_section">14.7</span>关于使用BFILE</h3>
               <div>
                  <div class="section">
                     <p>本节介绍如何使用文件定位器从BFILE读取数据。本节包括以下主题：</p>
                     <ul style="list-style-type:disc">
                        <li>
                           <p><a href="LOBs-and-BFiles.html#GUID-F06154EF-1D48-4CF4-A991-3839776A442F__CHDDGECF">检索BFILE定位器</a></p>
                        </li>
                        <li>
                           <p><a href="LOBs-and-BFiles.html#GUID-F06154EF-1D48-4CF4-A991-3839776A442F__CHDGDGEI">写信给BFILES</a></p>
                        </li>
                     </ul>
                  </div>
                  <!-- class="section" -->
                  <div class="section" id="GUID-F06154EF-1D48-4CF4-A991-3839776A442F__CHDDGECF">
                     <p class="subhead2" id="GUID-F06154EF-1D48-4CF4-A991-3839776A442F__GUID-09910F40-94F2-4ACE-A4C7-27FAB7C08092">检索BFILE定位器</p>
                  </div>
                  <!-- class="section" -->
                  <div class="section">
                     <p>BFILE数据类型和<code class="codeph">oracle.sql.BFILE</code>类是Oracle专有的。因此，它们没有标准接口。您必须对此类数据使用Oracle扩展。
                     </p>
                     <p>如果您具有包含BFILE定位符的标准JDBC结果集或可调用语句对象，则可以使用标准结果集<code class="codeph">getObject</code>方法访问定位器。此方法返回<code class="codeph">oracle.sql.BFILE</code>对象。
                     </p>
                     <p>您还可以通过铸造结果集中访问定位器<code class="codeph">OracleResultSet</code>或您的调用语句来<code class="codeph">OracleCallableStatement</code>和使用<code class="codeph">getOracleObject</code>或<code class="codeph">getBFILE</code>方法。
                     </p>
                     <div class="infoboxnote" id="GUID-F06154EF-1D48-4CF4-A991-3839776A442F__GUID-27E01761-E7E3-4EB1-9EB7-C3909B6AE7D6">
                        <p class="notep1">注意：</p>
                        <p>如果您使用的是<code class="codeph">getObject</code>或<code class="codeph">getOracleObject</code>方法，请记住根据需要<code class="codeph">getOracleObject</code>输出。
                        </p>
                     </div>
                     <p>一旦有了定位器，就可以通过<code class="codeph">oracle.sql.的API访问BFILE数据<code class="codeph">oracle.sql.BFILE</code> 。这些API类似于<code class="codeph">java.sql.的read方法<code class="codeph">java.sql.BLOB</code>界面。
                     </p>
                  </div>
                  <!-- class="section" -->
                  <div class="section" id="GUID-F06154EF-1D48-4CF4-A991-3839776A442F__CHDGDGEI">
                     <p class="subhead2" id="GUID-F06154EF-1D48-4CF4-A991-3839776A442F__GUID-58B84213-759D-43A1-A1CE-BA1555FFAC70">写信给BFILES</p>
                  </div>
                  <!-- class="section" -->
                  <div class="section">
                     <p>您不能将数据写入BFILE的内容，但您可以使用<code class="codeph">oracle.sql.的实例<code class="codeph">oracle.sql.BFILE</code>作为SQL语句或PL / SQL过程的输入。您可以通过执行以下操作之一来实现此目的：</p>
                     <ul style="list-style-type:disc">
                        <li>
                           <p>使用标准的<code class="codeph">setObject</code>方法。
                           </p>
                        </li>
                        <li>
                           <p>铸声明<code class="codeph">OraclePreparedStatement</code>或<code class="codeph">OracleCallableStatement</code> ，并使用<code class="codeph">setOracleObject</code>或<code class="codeph">setBFILE</code>方法。这些方法采用参数索引和<code class="codeph">oracle.sql.BFILE</code>对象作为输入。
                           </p>
                           <div class="infoboxnote" id="GUID-F06154EF-1D48-4CF4-A991-3839776A442F__GUID-1ABCC48A-6D8B-4C81-BAEE-7CA5421A367A">
                              <p class="notep1">注意：</p>
                              <ul style="list-style-type:disc">
                                 <li>
                                    <p>BFILE没有标准的<code class="codeph">java.sql</code>接口。
                                    </p>
                                 </li>
                                 <li>
                                    <p>使用<code class="codeph">getBFILE</code>的方法<code class="codeph">OracleResultSet</code>和<code class="codeph">OracleCallableStatement</code>接口来检索<code class="codeph">oracle.sql.BFILE</code>对象。该<code class="codeph">setBFILE</code>的方法<code class="codeph">OraclePreparedStatement</code>和<code class="codeph">OracleCallableStatement</code>接口接受<code class="codeph">oracle.sql.BFILE</code>对象作为参数。使用这些方法写入BFILE。</p>
                                 </li>
                                 <li>
                                    <p>Oracle建议您使用<code class="codeph">getBFILE</code> ， <code class="codeph">setBFILE</code>和<code class="codeph">updateBFILE</code>方法，而不是<code class="codeph">getBfile</code> ， <code class="codeph">setBfile</code>和<code class="codeph">updateBfile</code>方法。例如，使用<code class="codeph">setBFILE</code>方法而不是<code class="codeph">setBfile</code>方法。
                                    </p>
                                 </li>
                              </ul>
                           </div>
                        </li>
                     </ul>
                     <p>BFILE是只读的。数据主体驻留在操作系统（OS）文件系统中，只能使用OS工具和命令编写。您可以通过从JDBC执行适当的SQL语句或使用任何其他方式执行SQL来为现有外部文件创建BFILE。但是，您无法创建BFILE将由SQL或JDBC引用的OS文件。这些只能由可以访问服务器文件系统的进程在外部创建。</p>
                     <div class="infoboxnote" id="GUID-F06154EF-1D48-4CF4-A991-3839776A442F__GUID-9EF0AD2C-8963-43D9-9008-0F352BB6AAF8">
                        <p class="notep1">注意：</p>
                        <p>本章中的代码示例（在本指南的早期版本中）已被删除，以支持对可在OTN上下载的示例代码的引用。</p>
                     </div>
                  </div>
                  <!-- class="section" -->
               </div>
            </div>
         </div>
      </article>
   </body>
</html>