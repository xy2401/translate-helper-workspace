<html lang="en-us" dir="ltr" xml:lang="en-us">
   <head>
      <meta http-equiv="Content-Type" content="text/html; charset=utf-8"></meta>
      <meta name="viewport" content="width=device-width, initial-scale=1"></meta>
      <meta http-equiv="X-UA-Compatible" content="IE=edge"></meta>
      <meta name="abstract" content="This chapter explains how to bundle related PL/SQL code and data into a package, whose contents are available to many applications."></meta>
      <meta name="description" content="This chapter explains how to bundle related PL/SQL code and data into a package, whose contents are available to many applications."></meta>
      <title>PL / SQL包</title>
      <meta property="og:site_name" content="Oracle Help Center"></meta>
      <meta property="og:title" content="Database PL/SQL Language Reference "></meta>
      <meta property="og:description" content="This chapter explains how to bundle related PL/SQL code and data into a package, whose contents are available to many applications."></meta>
      <link rel="stylesheet" href="/sp_common/book-template/ohc-book-template/css/book.css"></link>
      <link rel="shortcut icon" href="/sp_common/book-template/ohc-common/img/favicon.ico"></link>
      <meta name="application-name" content="Database PL/SQL Language Reference"></meta>
      <meta name="generator" content="DITA Open Toolkit version 1.8.5 (Mode = doc)"></meta>
      <meta name="plugin" content="SP_docbuilder HTML plugin release 18.2.2"></meta>
      <link rel="alternate" href="database-pl-sql-language-reference.pdf" title="PDF File" type="application/pdf"></link>
      <meta name="robots" content="all"></meta>
      <link rel="schema.dcterms" href="http://purl.org/dc/terms/"></link>
      <meta name="dcterms.created" content="2019-01-13T20:26:20-08:00"></meta>
      
      <meta name="dcterms.dateCopyrighted" content="1996, 2019"></meta>
      <meta name="dcterms.category" content="database"></meta>
      <meta name="dcterms.identifier" content="E96448-02"></meta>
      
      <meta name="dcterms.product" content="en/database/oracle/oracle-database/19"></meta>
      
      <link rel="prev" href="plsql-triggers.html" title="Previous" type="text/html"></link>
      <link rel="next" href="plsql-error-handling.html" title="Next" type="text/html"></link>
      <script>
        document.write('<style type="text/css">');
        document.write('body > .noscript, body > .noscript ~ * { visibility: hidden; }');
        document.write('</style>');
     </script>
      <script src="/sp_common/book-template/requirejs/require.js" data-main="/sp_common/book-template/ohc-book-template/js/book-config"></script>
      <script>
            if (window.require === undefined) {
                document.write('<script data-main="sp_common/book-template/ohc-book-template/js/book-config" src="sp_common/book-template/requirejs/require.js"><\/script>');
                document.write('<link href="sp_common/book-template/ohc-book-template/css/book.css" rel="stylesheet"/>');
            }
        </script>
      <script type="application/json" id="ssot-metadata">{"primary":{"category":{"short_name":"database","element_name":"Database","display_in_url":true},"suite":{"short_name":"oracle","element_name":"Oracle","display_in_url":true},"product_group":{"short_name":"not-applicable","element_name":"Not applicable","display_in_url":false},"product":{"short_name":"oracle-database","element_name":"Oracle Database","display_in_url":true},"release":{"short_name":"19","element_name":"Release 19","display_in_url":true}}}</script>
      
    <meta name="dcterms.title" content="Database PL/SQL Language Reference"></meta>
    <meta name="dcterms.isVersionOf" content="LNPLS"></meta>
    <meta name="dcterms.release" content="Release 19"></meta>
  </head>
   <body dir="ltr">
      <div class="noscript alert alert-danger text-center" role="alert">
         <a href="plsql-triggers.html" class="pull-left"><span class="glyphicon glyphicon-chevron-left" aria-hidden="true"></span>上一页</a> <a href="plsql-error-handling.html" class="pull-right">下一页<span class="glyphicon glyphicon-chevron-right" aria-hidden="true"></span></a> <span class="fa fa-exclamation-triangle" aria-hidden="true"></span>必须启用JavaScript才能正确显示此内容</div>
      <article>
         <header>
            <ol class="breadcrumb" vocab="http://schema.org/" typeof="BreadcrumbList">
               <li property="itemListElement" typeof="ListItem"><a href="index.html" property="item" typeof="WebPage"><span property="name">数据库PL / SQL语言参考</span></a></li>
               <li class="active" property="itemListElement" typeof="ListItem">PL / SQL包</li>
            </ol>
            <a id="GUID-C285EC5A-BE50-4192-A88E-48C0778B34E0" name="GUID-C285EC5A-BE50-4192-A88E-48C0778B34E0"></a><a id="LNPLS692"></a><a id="LNPLS009"></a>
            
            <h2 id="LNPLS-GUID-C285EC5A-BE50-4192-A88E-48C0778B34E0" class="sect2"><span class="enumeration_chapter">10个</span> PL / SQL包</h2>
         </header>
         <div class="ind">
            <div>
               <p>本章介绍如何将相关的PL / SQL代码和数据捆绑到一个包中，其内容可供许多应用程序使用。</p>
               <div class="section">
                  <p class="subhead1" id="GUID-C285EC5A-BE50-4192-A88E-48C0778B34E0__GUID-CA5BA22A-6C2D-4D9F-B5EE-32E5D9F30883">话题</p>
               </div>
               <!-- class="section" -->
               <ul style="list-style-type:disc">
                  <li>
                     <p><a href="plsql-packages.html#GUID-8D02540E-C697-4498-9261-848F6D4E5CB5" title="包是一个模式对象，它对逻辑上相关的PL / SQL类型，变量，常量，子程序，游标和异常进行分组。包被编译并存储在数据库中，其中许多应用程序可以共享其内容。">什么是套餐？</a></p>
                  </li>
                  <li>
                     <p><a href="plsql-packages.html#GUID-F2763E50-C2C6-4A4B-AEFA-103EB8529FD5">使用包的原因</a></p>
                  </li>
                  <li>
                     <p><a href="plsql-packages.html#GUID-85E86008-3460-4596-B43A-13D54D6E04C7">包装规格</a></p>
                  </li>
                  <li>
                     <p><a href="plsql-packages.html#GUID-49A935CE-825D-4FEA-BF2D-89F87EA9C750">包装体</a></p>
                  </li>
                  <li>
                     <p><a href="plsql-packages.html#GUID-5946DBAF-D010-40E4-B119-CA76FA5AFA3A">包实例化和初始化</a></p>
                  </li>
                  <li>
                     <p><a href="plsql-packages.html#GUID-08E1FC04-9EF3-4396-83C6-4812F8ECABF4" title="包声明的变量，常量和游标的值（在其规范或正文中）构成其包状态。">包装状态</a></p>
                  </li>
                  <li>
                     <p><a href="plsql-packages.html#GUID-001EF960-7491-411B-A5F3-D1260A45794B" title="对于SERIALLY_REUSABLE包，工作单元是服务器调用。">SERIALLY_REUSABLE包</a></p>
                  </li>
                  <li>
                     <p><a href="plsql-packages.html#GUID-4C39BAEB-9F20-4620-B5B0-8DDDBF783AB2">包装书写指南</a></p>
                  </li>
                  <li>
                     <p><a href="plsql-packages.html#GUID-3A313D35-26B6-4A0D-A128-231692BCBC97">包装示例</a></p>
                  </li>
                  <li>
                     <p><a href="plsql-packages.html#GUID-6471BE85-7F01-4218-BC6B-C945C588FEFF">STANDARD包如何定义PL / SQL环境</a></p>
                  </li>
               </ul>
            </div><a id="LNPLS00901"></a><div class="props_rev_3"><a id="GUID-8D02540E-C697-4498-9261-848F6D4E5CB5" name="GUID-8D02540E-C697-4498-9261-848F6D4E5CB5"></a><h3 id="LNPLS-GUID-8D02540E-C697-4498-9261-848F6D4E5CB5" class="sect3"><span class="enumeration_section">10.1</span>什么是套餐？
               </h3>
               <div>
                  <p><span class="bold">包</span>是一个模式对象，它对逻辑上相关的PL / SQL类型，变量，常量，子程序，游标和异常进行分组。包被编译并存储在数据库中，其中许多应用程序可以共享其内容。
                  </p>
                  <p>包始终具有<span class="bold">规范</span> ，该<span class="bold">规范</span>声明可以从包外引用的<span class="bold">公共项</span> 。
                  </p>
                  <p>如果公共项目包括游标或子程序，则包裹也必须具有<span class="bold">正文</span> 。正文必须定义公共游标的查询和公共子程序的代码。正文还可以声明和定义无法从包外引用的<span class="bold">私有项</span> ，但对于包的内部工作是必需的。最后，正文可以有一个<span class="bold">初始化部分</span> ，其语句初始化变量并执行其他一次性设置步骤，以及异常处理部分。您可以在不更改规范或公共项目引用的情况下更改正文;因此，您可以将包装体视为黑盒子。
                  </p>
                  <p>在包规范或包体中，可以使用<span class="bold">调用规范</span>将包子程序映射到外部Java或C子程序，该<span class="bold">规范</span>将外部子程序名称，参数类型和返回类型映射到它们的SQL副本。
                  </p>
                  <p>包规范的<span class="bold"><code class="codeph">AUTHID</code></span> <span class="bold">子句</span>确定包中的子程序和游标是否以其定义者（默认）或调用者的权限运行，以及它们是否在定义者或调用者的模式中解析了对模式对象的非限定引用。
                  </p>
                  <p>程序包规范的<span class="bold"><code class="codeph">ACCESSIBLE</code></span> <span class="bold"><code class="codeph">BY</code></span> <span class="bold">子句</span>允许您指定可以访问程序包的PL / SQL单元的白名单。您可以在以下情况中使用此子句：</p>
                  <ul style="list-style-type:disc">
                     <li>
                        <p>您将PL / SQL应用程序实现为多个包 - 一个包提供应用程序编程接口（API）和帮助程序包来完成工作。您希望客户端可以访问API，但不能访问帮助程序包。因此，您省略了API包规范中的<code class="codeph">ACCESSIBLE</code> <code class="codeph">BY</code>子句，并将其包含在每个帮助程序包规范中，您指定只有API包才能访问帮助程序包。
                        </p>
                     </li>
                     <li>
                        <p>您可以创建一个实用程序包，以便为同一模式中的某些（但不是所有）PL / SQL单元提供服务。要将程序包的使用限制在目标单元中，请在程序包规范中的<code class="codeph">ACCESSIBLE</code> <code class="codeph">BY</code>子句中列出它们。
                        </p>
                     </li>
                  </ul>
                  <div class="infoboxnotealso" id="GUID-8D02540E-C697-4498-9261-848F6D4E5CB5__GUID-AAFC67D5-018E-485D-9CE9-D5B557AFF22C">
                     <p class="notep1">也可以看看：</p>
                     <ul style="list-style-type:disc">
                        <li>
                           <p><span class="q">“ <a href="plsql-packages.html#GUID-85E86008-3460-4596-B43A-13D54D6E04C7">包规范</a> ”</span> ，了解有关包规范的更多信息</p>
                        </li>
                        <li>
                           <p> <span class="q">“ <a href="plsql-packages.html#GUID-49A935CE-825D-4FEA-BF2D-89F87EA9C750">包体</a> ”</span>有关包体的更多信息</p>
                        </li>
                        <li>
                           <p><span class="q">“ <a href="function-declaration-and-definition.html#GUID-4E19FB09-46B5-4CE5-8A5B-CD815C29DA1C" title="在调用函数之前，必须声明并定义它。您可以先声明它（使用function_declaration），然后在同一个块，子程序或包中（使用function_definition）定义它，或者同时声明和定义它（使用function_definition）。">功能声明和定义</a> ”</span></p>
                        </li>
                        <li>
                           <p><span class="q">“ <a href="procedure-declaration-and-definition.html#GUID-9A48D7CE-3720-46A4-B5CA-C2250CA86AF2" title="在调用过程之前，必须声明并定义它。您可以先声明它（使用procedure_declaration），然后在同一个块，子程序或包中使用procedure_definition定义它，或者同时声明和定义它（使用procedure_definition）。">程序声明和定义</a> ”</span></p>
                        </li>
                        <li>
                           <p><span class="q">“ <a href="plsql-subprograms.html#GUID-41D23DE7-3C07-41CF-962B-F92B696594B5" title="如果在DR单元（定义者权限单元）中包含已连接的用户数据库链接，则必须向将运行DR单元的用户授予INHERIT REMOTE PRIVILEGES权限。">祈求者的权利和定义者的权利（AUTHID财产）</a> ”</span></p>
                        </li>
                     </ul>
                  </div>
               </div>
            </div><a id="LNPLS00902"></a><div class="props_rev_3"><a id="GUID-F2763E50-C2C6-4A4B-AEFA-103EB8529FD5" name="GUID-F2763E50-C2C6-4A4B-AEFA-103EB8529FD5"></a><h3 id="LNPLS-GUID-F2763E50-C2C6-4A4B-AEFA-103EB8529FD5" class="sect3"><span class="enumeration_section">10.2</span>使用包裹的原因</h3>
               <div>
                  <p>软件包支持开发和维护可靠，可重用的代码，具有以下功能：</p>
                  <ul style="list-style-type:disc">
                     <li>
                        <p><span class="bold">模块化</span></p>
                        <p>通过包，您可以在命名的PL / SQL模块中封装逻辑上相关的类型，变量，常量，子程序，游标和异常。您可以使每个包易于理解，并使包之间的接口简单，清晰且定义良好。这种做法有助于应用程序开发。</p>
                     </li>
                     <li>
                        <p><span class="bold">更轻松的应用设计</span></p>
                        <p>在设计应用程序时，您最初需要的只是包规范中的接口信息。您可以在没有身体的情况下编写和编译规范。接下来，您可以编译引用包的独立子程序。在准备好完成应用程序之前，无需完全定义包体。</p>
                     </li>
                     <li>
                        <p><span class="bold">隐藏的实施细节</span></p>
                        <p>使用包可以在包规范中共享您的接口信息，并在包体中隐藏实现细节。隐藏实体细节有以下优点：</p>
                        <ul style="list-style-type:disc">
                           <li>
                              <p>您可以在不影响应用程序界面的情况下更改实施细节。</p>
                           </li>
                           <li>
                              <p>应用程序用户无法开发依赖于您可能想要更改的实现细节的代码。</p>
                           </li>
                        </ul>
                     </li>
                     <li>
                        <p><span class="bold">增加了功能</span></p>
                        <p>包公共变量和游标可以在会话的整个生命周期中持续存在。它们可以由在环境中运行的所有子程序共享。它们允许您跨事务维护数据，而无需将其存储在数据库中。（对于包公共变量和游标在会话期间不会持续存在的情况，请参阅<span class="q">“ <a href="plsql-packages.html#GUID-08E1FC04-9EF3-4396-83C6-4812F8ECABF4" title="包声明的变量，常量和游标的值（在其规范或正文中）构成其包状态。">包状态</a> ”</span> 。）
                        </p>
                     </li>
                     <li>
                        <p><span class="bold">更好的性能</span></p>
                        <p>第一次调用包子程序时，Oracle数据库会将整个包加载到内存中。在包中同时调用其他子程序不需要磁盘I / O.</p>
                        <p>包防止级联依赖和不必要的重新编译。例如，如果更改包函数的主体，Oracle数据库不会重新编译调用该函数的其他子程序，因为这些子程序仅依赖于规范中声明的参数和返回值。</p>
                     </li>
                     <li>
                        <p><span class="bold">更容易授予角色</span></p>
                        <p>您可以在包上授予角色，而不是在包中的每个对象上授予角色。</p>
                     </li>
                  </ul>
                  <div class="infoboxnote" id="GUID-F2763E50-C2C6-4A4B-AEFA-103EB8529FD5__GUID-57E93D66-5C59-410F-96B1-4726B9A4A9A3">
                     <p class="notep1">注意：</p>
                     <p>您无法从包内引用主变量。</p>
                  </div>
               </div>
            </div><a id="LNPLS694"></a><a id="LNPLS00904"></a><div class="props_rev_3"><a id="GUID-85E86008-3460-4596-B43A-13D54D6E04C7" name="GUID-85E86008-3460-4596-B43A-13D54D6E04C7"></a><h3 id="LNPLS-GUID-85E86008-3460-4596-B43A-13D54D6E04C7" class="sect3"><span class="enumeration_section">10.3</span>包装规格</h3>
               <div>
                  <p><span class="bold">包规范</span>声明<span class="bold">公共项</span> 。公共项的范围是包的模式。公共项目在架构中的任何位置都可见。要引用范围但不可见的公共项目，请使用包名称对其进行限定。（有关范围，可见性和限定条件的信息，请参阅<span class="q">“ <a href="plsql-language-fundamentals.html#GUID-2FC17012-FC99-4614-90DD-ADC99F2EDBE9" title="标识符的范围是PL / SQL单元的区域，您可以从中引用标识符。标识符的可见性是PL / SQL单元的区域，您可以从中引用标识符而不限定它。标识符是声明它的PL / SQL单元的本地标识符。如果该单元具有子单元，则标识符对它们是全局的。">标识符的范围和可见性</a> ”</span> 。）
                  </p>
                  <p>每个公共项目声明都包含使用该项目所需的所有信息。例如，假设包规范以这种方式声明函数<code class="codeph">factorial</code> ：</p><pre class="oac_no_warn" dir="ltr">功能因子（n INTEGER）返回整数; - 返回n！
</pre><p>该声明显示<code class="codeph">factorial</code>需要类型的一个参数， <code class="codeph">INTEGER</code>和返回类型的值<code class="codeph">INTEGER</code> ，这是调用者必须知道要调用<code class="codeph">factorial</code> 。Invokers不需要知道如何实现<code class="codeph">factorial</code>因（例如，它是迭代的还是递归的）。
                  </p>
                  <div class="infoboxnote" id="GUID-85E86008-3460-4596-B43A-13D54D6E04C7__GUID-DEEAEC15-6D37-4052-91AD-095C01B1BCF2">
                     <p class="notep1">注意：</p>
                     <p>要将程序包的使用限制为指定的PL / SQL单元，请在程序包规范中包含<code class="codeph">ACCESSIBLE</code> <code class="codeph">BY</code>子句。
                     </p>
                  </div>
                  <div class="section">
                     <p class="subhead2" id="GUID-85E86008-3460-4596-B43A-13D54D6E04C7__GUID-994130FA-079D-4358-9351-A66991E375FD">话题</p>
                  </div>
                  <!-- class="section" -->
                  <div class="section">
                     <ul style="list-style-type:disc">
                        <li>
                           <p><a href="plsql-packages.html#GUID-F82E9BF3-147B-4FB3-ABB9-1A94A781AA7D">适当的公共项目</a></p>
                        </li>
                        <li>
                           <p><a href="plsql-packages.html#GUID-1E1FB4FA-CD97-443C-AE37-6D5C146E2B80">创建包规范</a></p>
                        </li>
                     </ul>
                  </div>
                  <!-- class="section" -->
               </div><a id="LNPLS00911"></a><div class="props_rev_3"><a id="GUID-F82E9BF3-147B-4FB3-ABB9-1A94A781AA7D" name="GUID-F82E9BF3-147B-4FB3-ABB9-1A94A781AA7D"></a><h4 id="LNPLS-GUID-F82E9BF3-147B-4FB3-ABB9-1A94A781AA7D" class="sect4"><span class="enumeration_section">10.3.1</span>适当的公共项目</h4>
                  <div>
                     <p>适当的公共项目是：</p>
                     <ul style="list-style-type:disc">
                        <li>
                           <p>多个子程序使用的类型，变量，常量，子程序，游标和异常</p>
                           <p>包规范中定义的类型是PL / SQL用户定义的子类型（在<span class="q">“ <a href="plsql-data-types.html#GUID-0E03C20F-2960-4ED9-8692-D4DCBF1F9670" title="PL / SQL允许您定义自己的子类型。">用户定义的PL / SQL子类型</a> ”中描述</span> ）或PL / SQL复合类型（在<a href="plsql-collections-and-records.html#GUID-7115C8B6-62F9-496D-BEC3-F7441DFE148A" title="PL / SQL允许您定义两种复合数据类型：集合和记录。">PL / SQL集合和记录中描述</a> ）。
                           </p>
                           <div class="infoboxnote" id="GUID-F82E9BF3-147B-4FB3-ABB9-1A94A781AA7D__GUID-1C153CA6-0861-4FDA-8A8F-07EC4E60C4DA">
                              <p class="notep1">注意：</p>
                              <p>程序包规范中定义的PL / SQL复合类型与相同定义的本地或独立类型不兼容（请参阅<a href="plsql-collections-and-records.html#GUID-7C84EBD2-D0A5-4126-8EB7-FF9243EE5B47__CHDIHDIJ">示例5-33</a> ， <a href="plsql-collections-and-records.html#GUID-7C84EBD2-D0A5-4126-8EB7-FF9243EE5B47__CIHBGBBH">示例5-34</a>和<a href="plsql-collections-and-records.html#GUID-7DC81088-1265-4C46-A04D-E3AD10BCC04F__CIHFBIAF">示例5-39</a> ）。
                              </p>
                           </div>
                        </li>
                        <li>
                           <p>独立子程序参数的关联数组类型</p>
                           <p>您无法在架构级别声明关联数组类型。因此，要将关联数组变量作为参数传递给独立子程序，必须在包规范中声明该变量的类型。这样做使得类型既可用于调用的子程序（声明该类型的形式参数），也可用于调用子程序或匿名块（声明该类型的变量）。见<a href="plsql-packages.html#GUID-1E1FB4FA-CD97-443C-AE37-6D5C146E2B80__BABDFGED">例10-2</a> 。
                           </p>
                        </li>
                        <li>
                           <p>在同一会话中的子程序调用之间必须保持可用的变量</p>
                        </li>
                        <li>
                           <p>读写公共变量的子程序（“get”和“set”子程序）</p>
                           <p>提供这些子程序以阻止程序包用户直接读取和写入公共变量。</p>
                        </li>
                        <li>
                           <p>相互调用的子程序</p>
                           <p>您无需担心包子程序的编译顺序，因为您必须对彼此调用的独立子程序进行编译。</p>
                        </li>
                        <li>
                           <p>重载的子程序</p>
                           <p>重载的子程序是同一子程序的变体。也就是说，它们具有相同的名称但不同的形式参数。有关它们的更多信息，请参阅<span class="q">“ <a href="plsql-subprograms.html#GUID-47D5A50E-7AAF-4C80-A06A-37593EA2526A">重载的子程序</a> ”</span> 。
                           </p>
                        </li>
                     </ul>
                     <div class="infoboxnote" id="GUID-F82E9BF3-147B-4FB3-ABB9-1A94A781AA7D__GUID-DCCE5C66-1170-4A4B-BB1B-97023EB7C547">
                        <p class="notep1">注意：</p>
                        <p>您不能间接引用远程包公共变量。例如，如果子程序引用包公共变量，则无法通过数据库链接调用子程序。</p>
                     </div>
                  </div>
               </div><a id="LNPLS813"></a><a id="LNPLS720"></a><a id="LNPLS99922"></a><div class="props_rev_3"><a id="GUID-1E1FB4FA-CD97-443C-AE37-6D5C146E2B80" name="GUID-1E1FB4FA-CD97-443C-AE37-6D5C146E2B80"></a><h4 id="LNPLS-GUID-1E1FB4FA-CD97-443C-AE37-6D5C146E2B80" class="sect4"><span class="enumeration_section">10.3.2</span>创建包规范</h4>
                  <div>
                     <div class="section">
                        <p>要创建包规范，请使用<span class="q">“ <a href="CREATE-PACKAGE-statement.html#GUID-03A70A54-90FF-4293-B6B8-F0B35E184AC5" title="CREATE PACKAGE语句创建或替换存储包的规范，存储包是数据库中作为一个单元存储的相关过程，函数和其他程序对象的封装集合。">CREATE PACKAGE语句</a> ”</span> 。
                        </p>
                        <p>由于<a href="plsql-packages.html#GUID-1E1FB4FA-CD97-443C-AE37-6D5C146E2B80__CIHEJJHJ">示例10-1</a>和<a href="plsql-packages.html#GUID-1E1FB4FA-CD97-443C-AE37-6D5C146E2B80__BABDFGED">示例10-2中</a>的包规范未声明游标或子程序，因此包<code class="codeph">trans_data</code>和<code class="codeph">aa_pkg</code>不需要<code class="codeph">aa_pkg</code> 。
                        </p>
                     </div>
                     <!-- class="section" -->
                     <div class="example" id="GUID-1E1FB4FA-CD97-443C-AE37-6D5C146E2B80__CIHEJJHJ">
                        <p class="titleinexample">例10-1简单包规范</p>
                        <p>在此示例中，包<code class="codeph">trans_data</code>的规范声明了两个公共类型和三个公共变量。
                        </p><pre class="oac_no_warn" dir="ltr">创建或替换包装trans_data AUTHID DEFINER作为类型TimeRec是记录（分钟SMALLINT，小时SMALLINT）; TYPE TransRec IS RECORD（类别VARCHAR2（10），帐户INT，金额REAL，time_of TimeRec）; minimum_balance CONSTANT REAL：= 10.00; number_processed INT; insufficient_funds EXCEPTION; PRAGMA EXCEPTION_INIT（insufficient_funds，-4097）; END trans_data; /</pre></div>
                     <!-- class="example" -->
                     <div class="example" id="GUID-1E1FB4FA-CD97-443C-AE37-6D5C146E2B80__BABDFGED">
                        <p class="titleinexample">示例10-2将关联数组传递给独立子程序</p>
                        <p>在此示例中，包<code class="codeph">aa_pkg</code>的规范声明了一个关联数组类型<code class="codeph">aa_type</code> 。然后，独立过程<code class="codeph">print_aa</code>声明类型为<code class="codeph">aa_type</code>的形式参数。接下来，匿名块声明<code class="codeph">aa_type</code>类型的变量，填充它，并将其传递给打印它的过程<code class="codeph">print_aa</code> 。
                        </p><pre class="oac_no_warn" dir="ltr">创建或替换包<span class="bold">aa_pkg</span> AUTHID DEFINER是类型<span class="bold">aa_type</span> IS表的INTEGER INDEX BY VARCHAR2（15）;结束; / CREATE OR REPLACE PROCEDURE print_aa（ <span class="bold">aa aa_pkg.aa_type</span> ）AUTHID DEFINER IS I VARCHAR2（15）;开始我：= aa。第一;虽然我不是空的LOOP DBMS_OUTPUT.PUT_LINE（aa（i）||''|| i）;我：= aa。NEXT（ⅰ）;结束循环;结束; / DECLARE <span class="bold">aa_var aa_pkg.aa_type</span> ; BEGIN aa_var（'zero'）：= 0; aa_var（'one'）：= 1; aa_var（'two'）：= 2; <span class="bold">print_aa（aa_var）</span> ;结束; /</pre><p>结果：</p><pre class="oac_no_warn" dir="ltr">1一2 2 0 0</pre></div>
                     <!-- class="example" -->
                  </div>
               </div>
            </div><a id="LNPLS721"></a><a id="LNPLS00905"></a><div class="props_rev_3"><a id="GUID-49A935CE-825D-4FEA-BF2D-89F87EA9C750" name="GUID-49A935CE-825D-4FEA-BF2D-89F87EA9C750"></a><h3 id="LNPLS-GUID-49A935CE-825D-4FEA-BF2D-89F87EA9C750" class="sect3"><span class="enumeration_section">10.4</span>包装体</h3>
               <div>
                  <p>如果包规范声明游标或子程序，则需要包体;否则，它是可选的。包体和包规范必须位于同一模式中。</p>
                  <p>包规范中的每个游标或子程序声明都必须在包体中具有相应的定义。相应的子程序声明和定义的标题必须逐字逐句匹配，白色空间除外。</p>
                  <p>要创建包体，请使用<span class="q">“ <a href="CREATE-PACKAGE-BODY-statement.html#GUID-68526FF2-96A1-4F14-A10B-4DD3E1CD80BE" title="CREATE PACKAGE BODY语句创建或替换存储包的主体，该包是相关过程，存储函数和作为单元存储在数据库中的其他程序对象的封装集合。">CREATE PACKAGE BODY Statement</a> ”</span> 。
                  </p>
                  <p>在包规范中声明并在包体中定义的游标和子程序是可以从包外引用的公共项。包体还可以声明和定义无法从包外引用的<span class="bold">私有项</span> ，但是包的内部工作是必需的。
                  </p>
                  <p>最后，正文可以有一个<span class="bold">初始化部分</span> ，其语句初始化公共变量并执行其他一次性设置步骤。初始化部分仅在第一次引用包时运行。初始化部分可以包括异常处理程序。
                  </p>
                  <p>您可以更改包体，而无需更改规范或对公共项的引用。</p>
                  <div class="example" id="GUID-49A935CE-825D-4FEA-BF2D-89F87EA9C750__CJAGEFEB">
                     <p class="titleinexample">例10-3匹配包规范和主体</p>
                     <p>在此示例中，相应子程序声明和定义的标题不一致地逐字匹配;因此，即使<code class="codeph">employees.hire_date%TYPE</code>为<code class="codeph">DATE</code> ，PL / SQL也会引发异常。</p><pre class="oac_no_warn" dir="ltr">CREATE PACKAGE emp_bonus AS PROCEDURE calc_bonus（date_hired <span class="bold">employees.hire_date％TYPE</span> ）;结束emp_bonus; / CREATE PACKAGE BODY emp_bonus AS  -  DATE与employees.hire_date不匹配％TYPE PROCEDURE calc_bonus（date_hired <span class="bold">DATE</span> ）是BEGIN DBMS_OUTPUT.PUT_LINE（'雇用'|| date_hired ||'的员工获得奖金。“）;结束;结束emp_bonus; /</pre><p>结果：</p><pre class="oac_no_warn" dir="ltr">警告：使用编译错误创建的Package Body。
</pre><p>显示错误（在SQL * Plus中）：</p><pre class="oac_no_warn" dir="ltr">显示错误</pre><p>结果：</p><pre class="oac_no_warn" dir="ltr">PACKAGE BODY EMP_BONUS的错误：LINE / COL ERROR -------- -------------------------------- --------------------------------- 2/13 PLS-00323：子程序或游标'CALC_BONUS'在一个声明包规范，必须在包体中定义</pre><p>纠正问题：</p><pre class="oac_no_warn" dir="ltr">创建或替换程序包emp_bonus作为程序calc_bonus（ <span class="bold">date_hired employees.hire_date％TYPE</span> ）是BEGIN DBMS_OUTPUT.PUT_LINE（'雇用'|| date_hired ||'的员工获得奖金。“）;结束;结束emp_bonus; /</pre><p>结果：</p><pre class="oac_no_warn" dir="ltr">包体创建。
</pre></div>
                  <!-- class="example" -->
               </div>
            </div><a id="LNPLS99926"></a><div class="props_rev_3"><a id="GUID-5946DBAF-D010-40E4-B119-CA76FA5AFA3A" name="GUID-5946DBAF-D010-40E4-B119-CA76FA5AFA3A"></a><h3 id="LNPLS-GUID-5946DBAF-D010-40E4-B119-CA76FA5AFA3A" class="sect3"><span class="enumeration_section">10.5</span>包实例化和初始化</h3>
               <div>
                  <p>当会话引用包项时，Oracle数据库会为该会话实例化包。引用包的每个会话都有自己的包的实例化。</p>
                  <p>当Oracle数据库实例化一个包时，它会初始化它。初始化包括以下适用的任何一项：</p>
                  <ul style="list-style-type:disc">
                     <li>
                        <p>将初始值分配给公共常量</p>
                     </li>
                     <li>
                        <p>将初始值分配给声明指定它们的公共变量</p>
                     </li>
                     <li>
                        <p>执行包体的初始化部分</p>
                     </li>
                  </ul>
               </div>
            </div><a id="LNPLS804"></a><div class="props_rev_3"><a id="GUID-08E1FC04-9EF3-4396-83C6-4812F8ECABF4" name="GUID-08E1FC04-9EF3-4396-83C6-4812F8ECABF4"></a><h3 id="LNPLS-GUID-08E1FC04-9EF3-4396-83C6-4812F8ECABF4" class="sect3"><span class="enumeration_section">10.6</span>包装状态</h3>
               <div>
                  <p>包声明的变量，常量和游标的值（在其规范或正文中）构成其<strong class="term">包状态</strong> 。
                  </p>
                  <p>如果PL / SQL包声明至少一个变量，常量或游标，那么包是<span class="bold">有状态的</span> ;否则，它是<span class="bold">无国籍的</span> 。
                  </p>
                  <p>引用包项的每个会话都有自己的包的实例化。如果包是有状态的，则实例化包括其状态。</p>
                  <p>包状态在会话期间持续存在，除非在以下情况中：</p>
                  <ul style="list-style-type:disc">
                     <li>
                        <p>包是<code class="codeph">SERIALLY_REUSABLE</code> 。</p>
                     </li>
                     <li>
                        <p>包体重新编译。</p>
                        <p>如果重新编译实例化的有状态包的主体（显式地，使用<span class="q">“ <a href="ALTER-PACKAGE-statement.html#GUID-61273667-8D8F-4E79-9D81-072CFFE3A7F1" title="ALTER PACKAGE语句显式重新编译包规范，正文或两者。显式重新编译消除了对隐式运行时重新编译的需要，并防止了相关的运行时编译错误和性能开销。">ALTER PACKAGE语句</a> ”</span>或隐式），则下一次调用包中的子程序会导致Oracle数据库丢弃现有包状态并引发异常ORA -04068。
                        </p>
                        <p>在PL / SQL引发异常之后，对包的引用会导致Oracle数据库重新实例化该包，并重新初始化它。因此，先前对包状态的更改将丢失。</p>
                     </li>
                     <li>
                        <p>任何会话的实例化包都将失效并重新生效。</p>
                        <p>如果任何会话的实例化包被无效并重新生效，则会丢失所有会话的包实例化（包括包状态）。</p>
                     </li>
                  </ul>
                  <p>如果程序包的状态在会话期间（或更长时间）保持不变，则Oracle数据库会将程序包视为无状态。这是一个包的项，它的所有项都是编译时常量。</p>
                  <p><span class="bold">编译时常量</span>是一个常量，PL / SQL编译器可以在编译时确定该值。初始值为文字的常量始终为编译时常量。一个常量，其初始值不是文字，但优化器减少为文字，也是编译时常量。PL / SQL优化器是否可以将非文字表达式减少为文字取决于优化级别。因此，在一个优化级别编译时无状态的程序包在以不同的优化级别编译时可能是有状态的。
                  </p>
                  <div class="infoboxnotealso" id="GUID-08E1FC04-9EF3-4396-83C6-4812F8ECABF4__GUID-27A37E69-47C5-41AA-98F7-3D2045845476">
                     <p class="notep1">也可以看看：</p>
                     <ul style="list-style-type:disc">
                        <li>
                           <p><span class="q">“ <a href="plsql-packages.html#GUID-001EF960-7491-411B-A5F3-D1260A45794B" title="对于SERIALLY_REUSABLE包，工作单元是服务器调用。">SERIALLY_REUSABLE包</a> ”</span></p>
                        </li>
                        <li>
                           <p><span class="q">“ <a href="plsql-packages.html#GUID-5946DBAF-D010-40E4-B119-CA76FA5AFA3A">包实例化和初始化</a> ”</span>有关初始化的信息</p>
                        </li>
                        <li>
                           <p>有关架构对象失效和重新验证的信息，请参见<a href="../adfns/schema-object-dependency.html#ADFNS99967" target="_blank"><span class="italic">“Oracle数据库开发指南”</span></a></p>
                        </li>
                        <li>
                           <p>有关优化程序的信息，请参阅<span class="q">“ <a href="plsql-optimization-and-tuning.html#GUID-8BC4231B-2E5C-47D6-BE14-6D75CE14C57E" title="编译器可以执行的一个优化是子程序内联。">PL / SQL Optimizer</a> ”</span></p>
                        </li>
                     </ul>
                  </div>
               </div>
            </div><a id="LNPLS722"></a><a id="LNPLS99977"></a><div class="props_rev_3"><a id="GUID-001EF960-7491-411B-A5F3-D1260A45794B" name="GUID-001EF960-7491-411B-A5F3-D1260A45794B"></a><h3 id="LNPLS-GUID-001EF960-7491-411B-A5F3-D1260A45794B" class="sect3"><span class="enumeration_section">10.7</span> SERIALLY_REUSABLE包</h3>
               <div>
                  <p><code class="codeph">SERIALLY_REUSABLE</code>包使您可以设计更好地管理内存的应用程序以实现可伸缩性。
                  </p>
                  <p>如果包不是<code class="codeph">SERIALLY_REUSABLE</code> ，则其包状态存储在每个用户的用户全局区域（UGA）中。因此，所需的UGA存储量随着用户数量的增加而线性增加，从而限制了可扩展性。包状态可以持续一段时间，锁定UGA内存直到会话结束。在某些应用程序（如Oracle Office）中，典型会话持续数天。
                  </p>
                  <p>如果包是<code class="codeph">SERIALLY_REUSABLE</code> ，则其包状态存储在系统全局区域（SGA）中的小池中的工作区中。程序包状态仅在服务器调用的生命周期内持续存在。服务器调用后，工作区返回池。如果后续服务器调用引用该包，则Oracle数据库将重用池中的实例。重用实例化会重新初始化它;因此，在先前的服务器调用中对包状态所做的更改是不可见的。（有关初始化的信息，请参阅<span class="q">“ <a href="plsql-packages.html#GUID-5946DBAF-D010-40E4-B119-CA76FA5AFA3A">包实例化和初始化</a> ”</span> 。）
                  </p>
                  <div class="infoboxnote" id="GUID-001EF960-7491-411B-A5F3-D1260A45794B__GUID-8AA9A74C-FD0E-4762-92C0-56557D80C81A">
                     <p class="notep1">注意：</p>
                     <p>尝试从数据库触发器或SQL语句调用的PL / SQL子程序访问<code class="codeph">SERIALLY_REUSABLE</code>包会引发错误。
                     </p>
                  </div>
                  <div class="section">
                     <p class="subhead2" id="GUID-001EF960-7491-411B-A5F3-D1260A45794B__GUID-3F0B0AE1-BEE9-4931-95B6-42397FC196CA">话题</p>
                  </div>
                  <!-- class="section" -->
                  <div class="section">
                     <ul style="list-style-type:disc">
                        <li>
                           <p><a href="plsql-packages.html#GUID-78DA1333-7938-472E-9A67-37C50370AB69">创建SERIALLY_REUSABLE包</a></p>
                        </li>
                        <li>
                           <p><a href="plsql-packages.html#GUID-0881061B-1F72-4F13-8BBA-B0959199851B" title="对于SERIALLY_REUSABLE包，工作单元是服务器调用。">SERIALLY_REUSABLE包装工作单位</a></p>
                        </li>
                        <li>
                           <p><a href="plsql-packages.html#GUID-CD7C61F3-C1C9-48CC-9429-209AABB62E19">SERIALLY_REUSABLE包中的显式游标</a></p>
                        </li>
                     </ul>
                  </div>
                  <!-- class="section" -->
               </div><a id="LNPLS810"></a><a id="LNPLS99925"></a><div class="props_rev_3"><a id="GUID-78DA1333-7938-472E-9A67-37C50370AB69" name="GUID-78DA1333-7938-472E-9A67-37C50370AB69"></a><h4 id="LNPLS-GUID-78DA1333-7938-472E-9A67-37C50370AB69" class="sect4"><span class="enumeration_section">10.7.1</span>创建SERIALLY_REUSABLE包</h4>
                  <div>
                     <div class="section">
                        <p>要创建<code class="codeph">SERIALLY_REUSABLE</code>包，请在包规范中包含<code class="codeph">SERIALLY_REUSABLE</code> pragma，如果存在，则包括包体。
                        </p>
                        <p><a href="plsql-packages.html#GUID-78DA1333-7938-472E-9A67-37C50370AB69__BABBIBDC">例10-4</a>创建了两个非常简单的<code class="codeph">SERIALLY_REUSABLE</code>包，一个只有一个规范，另一个包含规范和主体。
                        </p>
                        <div class="infoboxnotealso" id="GUID-78DA1333-7938-472E-9A67-37C50370AB69__GUID-E8D82F0C-DEFA-41DF-800D-524D392C7F3C">
                           <p class="notep1">也可以看看：</p>
                           <p><span class="q">“ <a href="SERIALLY_REUSABLE-pragma.html#GUID-35B02603-B794-403C-9E0D-E40208CEAF35" title="SERIALLY_REUSABLE pragma指定仅对服务器的一次调用需要包状态（例如，对数据库的OCI调用或通过数据库链接的存储过程调用）。">SERIALLY_REUSABLE Pragma</a> ”</span></p>
                        </div>
                     </div>
                     <!-- class="section" -->
                     <div class="example" id="GUID-78DA1333-7938-472E-9A67-37C50370AB69__BABBIBDC">
                        <p class="titleinexample">示例10-4创建SERIALLY_REUSABLE包</p><pre class="oac_no_warn" dir="ltr"><span class="bold">- 创建脱胎SERIALLY_REUSABLE包：</span>创建或替换包装<span class="bold">bodiless_pkg</span> AUTHID DEFINER是<span class="bold">PRAGMA SERIALLY_REUSABLE;</span> n NUMBER：= 5;结束; / <span class="bold">- 使用规范和正文创建SERIALLY_REUSABLE包：</span>创建或替换包装pkg AUTHID DEFINER是<span class="bold">PRAGMA SERIALLY_REUSABLE;</span> n NUMBER：= 5;结束; /创建或替换包装<span class="bold">身体</span> pkg是<span class="bold">PRAGMA SERIALLY_REUSABLE;</span>开始n：= 5;结束; /</pre></div>
                     <!-- class="example" -->
                  </div>
               </div><a id="LNPLS809"></a><a id="LNPLS99924"></a><div class="props_rev_3"><a id="GUID-0881061B-1F72-4F13-8BBA-B0959199851B" name="GUID-0881061B-1F72-4F13-8BBA-B0959199851B"></a><h4 id="LNPLS-GUID-0881061B-1F72-4F13-8BBA-B0959199851B" class="sect4"><span class="enumeration_section">10.7.2</span> SERIALLY_REUSABLE包装工作单位</h4>
                  <div>
                     <p>对于<code class="codeph">SERIALLY_REUSABLE</code>包，工作单元是服务器调用。
                     </p>
                     <p>您必须仅在工作单元中使用其公共变量。</p>
                     <div class="infoboxnote" id="GUID-0881061B-1F72-4F13-8BBA-B0959199851B__GUID-57B4ECE9-9259-4880-A05C-C8E8E0E9532F">
                        <p class="notep1">注意：</p>
                        <p>如果您犯了错误并依赖于在先前工作单元中设置的公共变量的值，那么您的程序可能会失败。PL / SQL无法检查此类情况。</p>
                     </div>
                     <p>在<code class="codeph">SERIALLY_REUSABLE</code>包的工作单元（服务器调用）完成后，Oracle数据库执行以下操作：</p>
                     <ul style="list-style-type:disc">
                        <li>
                           <p>关闭所有打开的游标。</p>
                        </li>
                        <li>
                           <p>释放一些不可重用的内存（例如，内存用于收集和长<code class="codeph">VARCHAR2</code>变量）</p>
                        </li>
                        <li>
                           <p>将包实例化返回到为此包保留的可重用实例化池。</p>
                        </li>
                     </ul>
                     <div class="example" id="GUID-0881061B-1F72-4F13-8BBA-B0959199851B__BABFAFDC">
                        <p class="titleinexample">例10-5 SERIALLY_REUSABLE Pragma的影响</p>
                        <p>在这个例子中，脱胎包<code class="codeph">pkg</code>和<code class="codeph">sr_pkg</code>是相同的，除了<code class="codeph">sr_pkg</code>是<code class="codeph">SERIALLY_REUSABLE</code>而<code class="codeph">pkg</code>不是。每个包声明公共变量<code class="codeph">n</code> ，初始值为5。然后，匿名块将每个变量的值更改为10。接下来，另一个匿名块打印每个变量的值。<code class="codeph">pkg</code>的值。 <code class="codeph">n</code>仍然是10，因为<code class="codeph">pkg</code>的状态在会话期间持续存在。<code class="codeph">sr_pkg</code>的值。 <code class="codeph">n</code>为5，因为<code class="codeph">sr_pkg</code>的状态仅在服务器调用的生命<code class="codeph">sr_pkg</code>持续存在。
                        </p><pre class="oac_no_warn" dir="ltr">创建或替换<span class="bold">包装pkg</span> IS n NUMBER：= 5;结束pkg; /创建或替换<span class="bold">包装sr_pkg</span>是<span class="bold">PRAGMA SERIALLY_REUSABLE;</span> n NUMBER：= 5; END sr_pkg; / BEGIN pkg.n：= 10; sr_pkg.n：= 10;结束; / BEGIN DBMS_OUTPUT.PUT_LINE（'pkg.n：'|| pkg.n）; DBMS_OUTPUT.PUT_LINE（'sr_pkg.n：'|| sr_pkg.n）;结束; /</pre><p>结果：</p><pre class="oac_no_warn" dir="ltr"><span class="bold">pkg.n:10</span> <span class="bold">sr_pkg.n:5</span>
</pre></div>
                     <!-- class="example" -->
                  </div>
               </div><a id="LNPLS811"></a><a id="LNPLS99923"></a><div class="props_rev_3"><a id="GUID-CD7C61F3-C1C9-48CC-9429-209AABB62E19" name="GUID-CD7C61F3-C1C9-48CC-9429-209AABB62E19"></a><h4 id="LNPLS-GUID-CD7C61F3-C1C9-48CC-9429-209AABB62E19" class="sect4"><span class="enumeration_section">10.7.3</span> SERIALLY_REUSABLE包中的显式游标</h4>
                  <div>
                     <p><code class="codeph">SERIALLY_REUSABLE</code>程序包中的显式游标保持打开状态，直到您关闭它或其工作单元（服务器调用）结束。要重新打开游标，您必须进行新的服务器调用。服务器调用可以与子程序调用不同，如<a href="plsql-packages.html#GUID-CD7C61F3-C1C9-48CC-9429-209AABB62E19__BABHACDC">例10-6</a>所示。
                     </p>
                     <p>相反，在您关闭它或断开与会话的连接之前，包中的非<code class="codeph">SERIALLY_REUSABLE</code>的显式游标将保持打开状态。
                     </p>
                     <div class="example" id="GUID-CD7C61F3-C1C9-48CC-9429-209AABB62E19__BABHACDC">
                        <p class="titleinexample">例10-6 SERIALLY_REUSABLE包中的游标在Call Boundary打开</p><pre class="oac_no_warn" dir="ltr">DROP TABLE人; CREATE TABLE people（名称VARCHAR2（20））; INSERT INTO人（姓名）VALUES（'John Smith'）; INSERT INTO人（姓名）VALUES（'Mary Jones'）; INSERT INTO people（name）VALUES（'Joe Brown'）; INSERT INTO people（name）VALUES（'Jane White'）;创建或替换<span class="bold">包装sr_pkg</span>是<span class="bold">PRAGMA SERIALLY_REUSABLE;</span> <span class="bold">CURSOR c</span> IS SELECT FROM FROM people; END sr_pkg; / CREATE OR REPLACE PROCEDURE fetch_from_cursor IS v_name people.name％TYPE; BEGIN IF sr_pkg.c％ISOPEN，然后DBMS_OUTPUT.PUT_LINE（'光标已打开。“）; ELSE DBMS_OUTPUT.PUT_LINE（'光标已关闭;现在打开。“）; OPEN sr_pkg.c;万一; FETCH sr_pkg.c INTO v_name; DBMS_OUTPUT.PUT_LINE（'Fetched：'|| v_name）; FETCH sr_pkg.c INTO v_name; DBMS_OUTPUT.PUT_LINE（'Fetched：'|| v_name）; END fetch_from_cursor; /</pre><p>首先调用服务器：</p><pre class="oac_no_warn" dir="ltr">BEGIN fetch_from_cursor; fetch_from_cursor;结束; /</pre><p>结果：</p><pre class="oac_no_warn" dir="ltr"><span class="bold">光标关闭;现在开放。</span>获取：约翰史密斯获取：玛丽琼斯<span class="bold">光标开放。</span>获取：乔布朗得到：简怀特</pre><p>对服务器的新调用：</p><pre class="oac_no_warn" dir="ltr">BEGIN fetch_from_cursor; fetch_from_cursor;结束; /</pre><p>结果：</p><pre class="oac_no_warn" dir="ltr"><span class="bold">光标关闭;现在开放。</span>获取：约翰史密斯获取：玛丽琼斯<span class="bold">光标开放。</span>获取：乔布朗得到：简怀特</pre></div>
                     <!-- class="example" -->
                  </div>
               </div>
            </div><a id="LNPLS826"></a><a id="LNPLS1996"></a><a id="LNPLS00909"></a><div class="props_rev_3"><a id="GUID-4C39BAEB-9F20-4620-B5B0-8DDDBF783AB2" name="GUID-4C39BAEB-9F20-4620-B5B0-8DDDBF783AB2"></a><h3 id="LNPLS-GUID-4C39BAEB-9F20-4620-B5B0-8DDDBF783AB2" class="sect3"><span class="enumeration_section">10.8</span>包装书写指南</h3>
               <div>
                  <ul style="list-style-type:disc">
                     <li>
                        <p>熟悉Oracle数据库提供的软件包，避免编写复制其功能的软件包。</p>
                        <p>有关Oracle数据库提供的软件包的更多信息，请参阅<a href="../arpls/introduction-to-oracle-supplied-plsql-packages-and-types.html#ARPLS-GUID-4AA6AA30-CAEE-4DCD-B214-9AD51D0229B4" target="_blank"><span class="italic">Oracle Database PL / SQL软件包和类型参考</span></a> 。
                        </p>
                     </li>
                     <li>
                        <p>保持您的包一般，以便将来的应用程序可以重用它们。</p>
                     </li>
                     <li>
                        <p>在包体之前设计和定义包规范。</p>
                     </li>
                     <li>
                        <p>在包规范中，仅声明调用程序必须可见的项。</p>
                        <p>这种做法可以防止其他开发人员对您的实现细节构建不安全的依赖关系，并减少重新编译的需要。</p>
                        <p>如果更改包规范，则必须重新编译调用包的公共子程序的任何子程序。如果仅更改包体，则无需重新编译这些子程序。</p>
                     </li>
                     <li>
                        <p>在包规范中声明公共游标并在包体中定义它们，如<a href="plsql-packages.html#GUID-4C39BAEB-9F20-4620-B5B0-8DDDBF783AB2__CIHFBJCG">例10-7所示</a> 。
                        </p>
                        <p>此练习允许您从包用户隐藏游标的查询，并在不更改游标声明的情况下更改它们。</p>
                     </li>
                     <li>
                        <p>在包体的初始化部分而不是在声明中分配初始值。</p>
                        <p>这种做法具有以下优点：</p>
                        <ul style="list-style-type:disc">
                           <li>
                              <p>用于计算初始值的代码可以更复杂并且更好地记录。</p>
                           </li>
                           <li>
                              <p>如果计算初始值会引发异常，则初始化部分可以使用自己的异常处理程序来处理它。</p>
                           </li>
                        </ul>
                     </li>
                     <li>
                        <p>如果将数据库应用程序实现为多个PL / SQL包 - 一个提供API和帮助程序包的包来完成工作，那么使帮助程序包仅可用于API包，如<a href="plsql-packages.html#GUID-4C39BAEB-9F20-4620-B5B0-8DDDBF783AB2__CIHFBJEB">例10-8所示</a> 。
                        </p>
                     </li>
                  </ul>
                  <p>在<a href="plsql-packages.html#GUID-4C39BAEB-9F20-4620-B5B0-8DDDBF783AB2__CIHFBJCG">例10-7中</a> ，光标<code class="codeph">c1</code>的声明和定义分别在包<code class="codeph">emp_stuff</code>的规范和正文中。游标声明仅指定返回值的数据类型，而不是查询，它出现在游标定义中（有关完整语法和语义，请参阅<span class="q">“ <a href="explicit-cursor-declaration-and-definition.html#GUID-38C5DBA3-9DEC-4AF2-9B5E-7B721D11A77C" title="显式游标是指向私有SQL区域的命名指针，该区域存储用于处理特定查询或DML语句的信息 - 通常是返回或影响多行的语句。">显式游标声明和定义</a> ”</span> ）。
                  </p>
                  <p><a href="plsql-packages.html#GUID-4C39BAEB-9F20-4620-B5B0-8DDDBF783AB2__CIHFBJEB">例10-8</a>创建了一个API包和一个帮助包。由于帮助程序包规范中的<code class="codeph">ACCESSIBLE</code> <code class="codeph">BY</code>子句，只有API包可以访问帮助程序包。
                  </p>
                  <div class="example" id="GUID-4C39BAEB-9F20-4620-B5B0-8DDDBF783AB2__CIHFBJCG">
                     <p class="titleinexample">例10-7在包中分离游标声明和定义</p><pre class="oac_no_warn" dir="ltr">CREATE PACKAGE emp_stuff AS <span class="bold">CURSOR c1 RETURN员工％ROWTYPE; - 声明游标</span> END emp_stuff; / CREATE PACKAGE BODY emp_stuff AS <span class="bold">CURSOR c1 RETURN employees％ROWTYPE IS</span> <span class="bold">SELECT * FROM employees WHERE salary&gt; 2500; - 定义游标</span> END emp_stuff; /</pre></div>
                  <!-- class="example" -->
                  <div class="example" id="GUID-4C39BAEB-9F20-4620-B5B0-8DDDBF783AB2__CIHFBJEB">
                     <p class="titleinexample">例10-8可以通过条款访问</p><pre class="oac_no_warn" dir="ltr">创建或替换包装助手AUTHID DEFINER <span class="bold">可访问（api）</span>程序h1;程序h2;结束; /创建或替换包装辅助程序是程序h1是BEGIN DBMS_OUTPUT.PUT_LINE（'辅助程序h1'）;结束;程序h2是BEGIN DBMS_OUTPUT.PUT_LINE（'助手程序h2'）;结束;结束; /创建或替换包装api AUTHID DEFINER是程序p1;程序p2;结束; /创建或替换程序包程序程序p1是BEGIN DBMS_OUTPUT.PUT_LINE（'API程序p1'）; helper.h1;结束;程序p2是BEGIN DBMS_OUTPUT.PUT_LINE（'API程序p2'）; helper.h2;结束;结束; /</pre><p>调用API包中的过程：</p><pre class="oac_no_warn" dir="ltr">BEGIN api.p1; api.p2;结束; /</pre><p>结果：</p><pre class="oac_no_warn" dir="ltr">API程序p1帮助程序h1 API程序p2辅助程序h2</pre><p>在helper包中调用一个过程：</p><pre class="oac_no_warn" dir="ltr">BEGIN helper.h1;结束; /</pre><p>结果：</p><pre class="oac_no_warn" dir="ltr">SQL&gt; BEGIN 2 helper.h1; 3结束; 4 / helper.h1; *第2行的错误：ORA-06550：第2行第3列： <span class="bold">PLS-00904：访问对象的权限不足HELPER</span> ORA-06550：第2行第3列：PL / SQL：语句被忽略</pre></div>
                  <!-- class="example" -->
               </div>
            </div><a id="LNPLS816"></a><a id="LNPLS00906"></a><div class="props_rev_3"><a id="GUID-3A313D35-26B6-4A0D-A128-231692BCBC97" name="GUID-3A313D35-26B6-4A0D-A128-231692BCBC97"></a><h3 id="LNPLS-GUID-3A313D35-26B6-4A0D-A128-231692BCBC97" class="sect3"><span class="enumeration_section">10.9</span>包装示例</h3>
               <div>
                  <p><a href="plsql-packages.html#GUID-3A313D35-26B6-4A0D-A128-231692BCBC97__CJAIICFE">示例10-9</a>创建表， <code class="codeph">log</code>和包<code class="codeph">emp_admin</code> ，然后从匿名块调用包子程序。包装有规格和正文。
                  </p>
                  <p>规范声明了一个公共类型，游标和异常，以及三个公共子程序。一个公共子程序过载（有关重载子程序的信息，请参阅<span class="q">“ <a href="plsql-subprograms.html#GUID-47D5A50E-7AAF-4C80-A06A-37593EA2526A">重载的子程序</a> ”</span> ）。
                  </p>
                  <p>正文声明了一个私有变量，定义了规范声明的公共游标和子程序，声明并定义了私有函数，并具有初始化部分。</p>
                  <p>初始化部分（仅在匿名块第一次引用包时运行）在表<code class="codeph">log</code>插入一行，并将私有变量<code class="codeph">number_hired</code>初始化为零。每次调用包过程<code class="codeph">hire_employee</code> ，它都会更新私有变量<code class="codeph">number_hired</code> 。
                  </p>
                  <div class="example" id="GUID-3A313D35-26B6-4A0D-A128-231692BCBC97__CJAIICFE">
                     <p class="titleinexample">示例10-9创建emp_admin包</p><pre class="oac_no_warn" dir="ltr"><span class="bold">- 记录跟踪更改（不是包的一部分）：</span> DROP TABLE log; CREATE TABLE log（date_of_action DATE，user_id VARCHAR2（20），package_name VARCHAR2（30））; <span class="bold">- 包规范：</span> CREATE OR REPLACE PACKAGE emp_admin AUTHID DEFINER AS <span class="bold">- 声明公共类型，游标和异常：</span> TYPE EmpRecTyp IS RECORD（emp_id NUMBER，sal NUMBER）; CURSOR desc_salary RETURN EmpRecTyp; invalid_salary EXCEPTION; <span class="bold">- 声明公共子程序：</span> FUNCTION hire_employee（last_name VARCHAR2，first_name VARCHAR2，email VARCHAR2，phone_number VARCHAR2，job_id VARCHAR2，salary NUMBER，commission_pct NUMBER，manager_id NUMBER，department_id NUMBER）返回号码; <span class="bold">- 公共子程序之前的重载：</span> PROCEDURE fire_employee（emp_id NUMBER）;程序fire_employee（emp_email VARCHAR2）; PROCEDURE raise_salary（emp_id NUMBER，NUMBER）;功能nth_highest_salary（n NUMBER）返回EmpRecTyp; END emp_admin; / <span class="bold">- 包体：</span> CREATE OR REPLACE PACKAGE BODY emp_admin AS number_hired NUMBER; <span class="bold">- 私有变量，仅在此包中可见</span> <span class="bold">- 定义在包规范中声明的游标：</span> CURSOR desc_salary返回EmpRecTyp IS SELECT employee_id，salary FROM employees ORDER BY salary DESC; <span class="bold">- 定义在包规范中声明的子程序：</span> FUNCTION hire_employee（last_name VARCHAR2，first_name VARCHAR2，email VARCHAR2，phone_number VARCHAR2，job_id VARCHAR2，salary NUMBER，commission_pct NUMBER，manager_id NUMBER，department_id NUMBER）返回号码是new_emp_id NUMBER; BEGIN new_emp_id：= employees_seq。NEXTVAL; INSERT INTO员工（employee_id，last_name，first_name，email，phone_number，hire_date，job_id，salary，commission_pct，manager_id，department_id）VALUES（new_emp_id，hire_employee.last_name，hire_employee.first_name，hire_employee.email，hire_employee.phone_number，SYSDATE，hire_employee。 job_id，hire_employee.salary，hire_employee.commission_pct，hire_employee.manager_id，hire_employee.department_id）; number_hired：= number_hired + 1; DBMS_OUTPUT.PUT_LINE（'雇用的雇员人数是'|| TO_CHAR（number_hired））;返回new_emp_id; END hire_employee;程序fire_employee（emp_id NUMBER）从员工开始删除WHERE employee_id = emp_id;结束fire_employee;程序fire_employee（emp_email VARCHAR2）从员工开始删除WHERE email = emp_email;结束fire_employee; <span class="bold">- 定义私有函数，仅在包内可用：</span> FUNCTION sal_ok（jobid VARCHAR2，sal NUMBER）RETURN BOOLEAN是min_sal NUMBER; max_sal NUMBER; BEGIN SELECT MIN（薪水），MAX（薪水）INTO min_sal，max_sal FROM employees WHERE job_id = jobid;返回（sal&gt; = min_sal）AND（sal &lt;= max_sal）;结束sal_ok; PROCEDURE raise_salary（emp_id NUMBER，NUMBER）IS sal NUMBER（8,2）; jobid VARCHAR2（10）; BEGIN SELECT job_id，薪水INTO jobid，sal FROM employees WHERE employee_id = emp_id;如果<span class="bold">sal_ok（jobid，sal + amount）</span>那么<span class="bold">- 调用私有函数</span> UPDATE employees SET salary = salary + amount WHERE employee_id = emp_id; ELSE RAISE invalid_salary;万一;当invalid_salary那么EXCEPTION那么DBMS_OUTPUT.PUT_LINE（'工资超出指定范围。“）; END raise_salary;功能nth_highest_salary（n NUMBER）RETURN EmpRecTyp IS emp_rec EmpRecTyp; BEGIN OPEN desc_salary; FOR i IN 1..n LOOP FETCH desc_salary INTO emp_rec;结束循环;关闭desc_salary; RETURN emp_rec; END nth_highest_salary; BEGIN <span class="bold">- 初始化包体的一部分</span> INSERT INTO log（date_of_action，user_id，package_name）VALUES（SYSDATE，USER，'EMP_ADMIN'）; number_hired：= 0; END emp_admin; / <span class="bold">- 在匿名块中调用包子程序：</span> DECLARE new_emp_id NUMBER（6）; BEGIN new_emp_id：= <span class="bold">emp_admin.hire_employee</span> （'Belden'，'Enrique'，'EBELDEN'，'555.111.2222'，'ST_CLERK'，2500，.1,101,110）; DBMS_OUTPUT.PUT_LINE（'员工ID是'|| TO_CHAR（new_emp_id））; <span class="bold">emp_admin.raise_salary</span> （new_emp_id，100）; DBMS_OUTPUT.PUT_LINE（'第10个最高薪水是'|| TO_CHAR（ <span class="bold">emp_admin.nth_highest_salary（10）.sal</span> ）||'，属于员工：'|| TO_CHAR（ <span class="bold">emp_admin.nth_highest_salary（10）.emp_id</span> ））; <span class="bold">emp_admin.fire_employee（new_emp_id）</span> ; - 您还可以按如下方式删除新添加的员工： - <span class="bold">emp_admin.fire_employee（'EBELDEN'）</span> ;结束; /</pre><p>结果类似于：</p><pre class="oac_no_warn" dir="ltr">雇用的员工人数为1人员编号为210第10名最高薪资为11500，属于员工：168</pre></div>
                  <!-- class="example" -->
               </div>
            </div><a id="LNPLS00907"></a><div class="props_rev_3"><a id="GUID-6471BE85-7F01-4218-BC6B-C945C588FEFF" name="GUID-6471BE85-7F01-4218-BC6B-C945C588FEFF"></a><h3 id="LNPLS-GUID-6471BE85-7F01-4218-BC6B-C945C588FEFF" class="sect3"><span class="enumeration_section">10.10</span> STANDARD包如何定义PL / SQL环境</h3>
               <div>
                  <p>名为<code class="codeph">STANDARD</code>的包定义了PL / SQL环境。包规范声明公共类型，变量，异常，子程序，它们可自动提供给PL / SQL程序。例如，包<code class="codeph">STANDARD</code>声明函数<code class="codeph">ABS</code> ，它返回其参数的绝对值，如下所示：</p><pre class="oac_no_warn" dir="ltr">功能ABS（n号）返回号码;</pre><p>程序包<code class="codeph">STANDARD</code>的内容对应用程序直接可见。您不需要通过为包名称添加前缀来限定对其内容的引用。例如，您可以从数据库触发器，存储的子程序，Oracle工具或3GL应用程序中调用<code class="codeph">ABS</code> ，如下所示：</p><pre class="oac_no_warn" dir="ltr">abs_diff：= ABS（x  -  y）;</pre><p>如果您声明自己的<code class="codeph">ABS</code>版本，则您的本地声明会覆盖公共声明。您仍然可以通过指定其全名来调用SQL函数：</p><pre class="oac_no_warn" dir="ltr">abs_diff：= STANDARD.ABS（x  -  y）;</pre><p>大多数SQL函数都是重载的。例如，包<code class="codeph">STANDARD</code>包含以下声明：</p><pre class="oac_no_warn" dir="ltr">功能TO_CHAR（右DATE）RETURN VARCHAR2;功能TO_CHAR（左数）RETURN VARCHAR2; FUNCTION TO_CHAR（左DATE，右VARCHAR2）RETURN VARCHAR2;功能TO_CHAR（左边NUMBER，右边VARCHAR2）RETURN VARCHAR2;</pre><p>PL / SQL通过匹配形式和实际参数的数量和数据类型来解析<code class="codeph">TO_CHAR</code>的调用。
                  </p>
               </div>
            </div>
         </div>
      </article>
   </body>
</html>