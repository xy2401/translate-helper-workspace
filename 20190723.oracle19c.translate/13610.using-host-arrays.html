<html lang="en-us" dir="ltr" xml:lang="en-us">
   <head>
      <meta http-equiv="Content-Type" content="text/html; charset=utf-8"></meta>
      <meta name="viewport" content="width=device-width, initial-scale=1"></meta>
      <meta http-equiv="X-UA-Compatible" content="IE=edge"></meta>
      <title>使用主机阵列</title>
      <meta property="og:site_name" content="Oracle Help Center"></meta>
      <meta property="og:title" content="Programmer&#39;s Guide to the Oracle Precompilers"></meta>
      <meta property="og:description" content=""></meta>
      <link rel="stylesheet" href="/sp_common/book-template/ohc-book-template/css/book.css"></link>
      <link rel="shortcut icon" href="/sp_common/book-template/ohc-common/img/favicon.ico"></link>
      <meta name="application-name" content="Programmer&#39;s Guide to the Oracle Precompilers"></meta>
      <meta name="generator" content="DITA Open Toolkit version 1.8.5 (Mode = doc)"></meta>
      <meta name="plugin" content="SP_docbuilder HTML plugin release 18.2.2"></meta>
      <link rel="alternate" href="programmers-guide-oracle-precompilers.pdf" title="PDF File" type="application/pdf"></link>
      <meta name="robots" content="all"></meta>
      <link rel="schema.dcterms" href="http://purl.org/dc/terms/"></link>
      <meta name="dcterms.created" content="2019-01-11T01:36:30-08:00"></meta>
      <meta name="dcterms.title" content="Programmer&#39;s Guide to the Oracle Precompilers"></meta>
      <meta name="dcterms.dateCopyrighted" content="2008, 2019"></meta>
      <meta name="dcterms.category" content="database"></meta>
      <meta name="dcterms.identifier" content="E96474-01"></meta>
      
      <meta name="dcterms.product" content="en/database/oracle/oracle-database/19"></meta>
      
      <link rel="prev" href="error-handling-diagnostics.html" title="Previous" type="text/html"></link>
      <link rel="next" href="using-dynamic-SQL.html" title="Next" type="text/html"></link>
      <script>
        document.write('<style type="text/css">');
        document.write('body > .noscript, body > .noscript ~ * { visibility: hidden; }');
        document.write('</style>');
     </script>
      <script src="/sp_common/book-template/requirejs/require.js" data-main="/sp_common/book-template/ohc-book-template/js/book-config"></script>
      <script>
            if (window.require === undefined) {
                document.write('<script data-main="sp_common/book-template/ohc-book-template/js/book-config" src="sp_common/book-template/requirejs/require.js"><\/script>');
                document.write('<link href="sp_common/book-template/ohc-book-template/css/book.css" rel="stylesheet"/>');
            }
        </script>
      <script type="application/json" id="ssot-metadata">{"primary":{"category":{"short_name":"database","element_name":"Database","display_in_url":true},"suite":{"short_name":"oracle","element_name":"Oracle","display_in_url":true},"product_group":{"short_name":"not-applicable","element_name":"Not applicable","display_in_url":false},"product":{"short_name":"oracle-database","element_name":"Oracle Database","display_in_url":true},"release":{"short_name":"19","element_name":"Release 19","display_in_url":true}}}</script>
      
    <meta name="dcterms.isVersionOf" content="ZZPRE"></meta>
    <meta name="dcterms.release" content="Release 19"></meta>
  </head>
   <body dir="ltr">
      <div class="noscript alert alert-danger text-center" role="alert">
         <a href="error-handling-diagnostics.html" class="pull-left"><span class="glyphicon glyphicon-chevron-left" aria-hidden="true"></span>上一页</a> <a href="using-dynamic-SQL.html" class="pull-right">下一页<span class="glyphicon glyphicon-chevron-right" aria-hidden="true"></span></a> <span class="fa fa-exclamation-triangle" aria-hidden="true"></span>必须启用JavaScript才能正确显示此内容</div>
      <article>
         <header>
            <ol class="breadcrumb" vocab="http://schema.org/" typeof="BreadcrumbList">
               <li property="itemListElement" typeof="ListItem"><a href="index.html" property="item" typeof="WebPage"><span property="name">程序员指南Oracle预编译器</span></a></li>
               <li class="active" property="itemListElement" typeof="ListItem">使用主机阵列</li>
            </ol>
            <a id="GUID-F8DD2840-4F8C-4093-A4F9-51C9FE9FA59F" name="GUID-F8DD2840-4F8C-4093-A4F9-51C9FE9FA59F"></a>
            
            <h2 id="ZZPRE-GUID-F8DD2840-4F8C-4093-A4F9-51C9FE9FA59F" class="sect2"><span class="enumeration_chapter">9</span>使用主机阵列</h2>
         </header>
         <div class="ind">
            <div>
               <p>本章介绍以下内容：</p>
               <ul style="list-style-type:disc">
                  <li>
                     <p><a href="using-host-arrays.html#GUID-15A437EC-4B5E-4651-B1BF-6A59D432A142">什么是主机阵列？</a></p>
                  </li>
                  <li>
                     <p><a href="using-host-arrays.html#GUID-D2BB8D23-4C72-450E-952A-07DCD0058832">为什么要使用数组？</a></p>
                  </li>
                  <li>
                     <p><a href="using-host-arrays.html#GUID-249FD50B-2FB8-425A-9CA8-906FEC6397A8">声明主机阵列</a></p>
                  </li>
                  <li>
                     <p><a href="using-host-arrays.html#GUID-4745E48D-905B-4A6A-A5AE-BDE35E52F5D0">关于在SQL语句中使用数组</a></p>
                  </li>
                  <li>
                     <p><a href="using-host-arrays.html#GUID-0CC543AC-ABEC-452C-A7C7-9B24ECB0DA33">关于选择数组</a></p>
                  </li>
                  <li>
                     <p><a href="using-host-arrays.html#GUID-3B4397E4-F992-454F-97B3-CB53C8EA248E">关于使用指标数组</a></p>
                  </li>
                  <li>
                     <p><a href="using-host-arrays.html#GUID-67713341-6FF8-4FF6-B5A7-C390A2B0B802">关于使用FOR子句</a></p>
                  </li>
                  <li>
                     <p><a href="using-host-arrays.html#GUID-F74653D4-1D3D-4518-9F10-BC1B50DD2566">关于使用WHERE子句</a></p>
                  </li>
                  <li>
                     <p><a href="using-host-arrays.html#GUID-5E5021B0-116F-4242-8053-6CEE6B7B154E">关于模仿当前的条款</a></p>
                  </li>
                  <li>
                     <p><a href="using-host-arrays.html#GUID-F7B6624A-363B-4CAA-8F87-0D0EEB822F33">关于使用SQLERRD（3）</a></p>
                  </li>
               </ul>
               <p>本章介绍如何使用数组来简化编码并提高程序性能。您将学习如何使用数组操作Oracle数据，如何使用单个SQL语句操作数组的所有元素，以及如何限制处理的数组元素的数量。回答以下问题：</p>
               <ul style="list-style-type:disc">
                  <li>
                     <p>什么是主机阵列？</p>
                  </li>
                  <li>
                     <p>为何使用数组？</p>
                  </li>
                  <li>
                     <p>如何声明主机数组？</p>
                  </li>
                  <li>
                     <p>如何在SQL语句中使用数组？</p>
                  </li>
               </ul>
            </div><a id="ZZPRE842"></a><div class="props_rev_3"><a id="GUID-15A437EC-4B5E-4651-B1BF-6A59D432A142" name="GUID-15A437EC-4B5E-4651-B1BF-6A59D432A142"></a><h3 id="ZZPRE-GUID-15A437EC-4B5E-4651-B1BF-6A59D432A142" class="sect3"><span class="enumeration_section">9.1</span>什么是主机阵列？
               </h3>
               <div>
                  <p><a id="d70073e94" class="indexterm-anchor"></a> <span class="italic">数组</span>是与单个变量名称关联的相关数据项（称为<span class="italic">元素</span> ）的集合。当声明为主变量时，该数组称为a <a id="d70073e103" class="indexterm-anchor"></a> <span class="italic">主机阵列</span> 。同样，声明为数组的指示符变量称为<a id="d70073e109" class="indexterm-anchor"></a> <span class="italic">指标数组</span> 。指示符数组可以与任何主机阵列相关联。
                  </p>
               </div>
            </div><a id="ZZPRE843"></a><div class="props_rev_3"><a id="GUID-D2BB8D23-4C72-450E-952A-07DCD0058832" name="GUID-D2BB8D23-4C72-450E-952A-07DCD0058832"></a><h3 id="ZZPRE-GUID-D2BB8D23-4C72-450E-952A-07DCD0058832" class="sect3"><span class="enumeration_section">9.2</span>为什么要使用数组？
               </h3>
               <div>
                  <p>阵列可以简化编程并提供改进的性能。编写应用程序时，通常会遇到存储和操作大量数据的问题。数组简化了命名和引用每个集合中各个项的任务。</p>
                  <p><a id="d70073e138" class="indexterm-anchor"></a>使用数组可以提高应用程序的性能。数组允许您使用单个SQL语句操作整个数据项集合。因此，Oracle通信开销显着降低，尤其是在网络环境中。例如，假设您要将有关300名员工的信息插入EMP表。如果没有数组，您的程序必须执行300个单独的<code class="codeph">INSERTs</code> - 每个员工一个。对于数组，只需要完成一个<code class="codeph">INSERT</code> 。
                  </p>
               </div>
            </div><a id="ZZPRE844"></a><div class="props_rev_3"><a id="GUID-249FD50B-2FB8-425A-9CA8-906FEC6397A8" name="GUID-249FD50B-2FB8-425A-9CA8-906FEC6397A8"></a><h3 id="ZZPRE-GUID-249FD50B-2FB8-425A-9CA8-906FEC6397A8" class="sect3"><span class="enumeration_section">9.3</span>声明主机阵列</h3>
               <div>
                  <div class="section">
                     <p><a id="d70073e178" class="indexterm-anchor"></a><a id="d70073e180" class="indexterm-anchor"></a>您可以在Declare Section中声明主机数组，就像简单的主机变量一样。您还<span class="italic">标注</span> （集的大小）主机阵列的声明部分。在以下示例中，您将声明三个主机阵列并使用它们标注它们<a id="d70073e188" class="indexterm-anchor"></a> 50个要素：</p><pre class="oac_no_warn" dir="ltr">EXEC SQL BEGIN DECLARE SECTION; emp_name（50）CHARACTER（20）; emp_number（50）INTEGER;薪水（50）REAL; EXEC SQL END DECLARE SECTION;</pre></div>
                  <!-- class="section" -->
               </div><a id="ZZPRE845"></a><div class="props_rev_3"><a id="GUID-75644851-65D0-4D71-AA86-B3F143CD3F53" name="GUID-75644851-65D0-4D71-AA86-B3F143CD3F53"></a><h4 id="ZZPRE-GUID-75644851-65D0-4D71-AA86-B3F143CD3F53" class="sect4"><span class="enumeration_section">9.3.1</span>标注数组</h4>
                  <div>
                     <p><a id="d70073e216" class="indexterm-anchor"></a>主机阵列的最大尺寸为32,767个元素。如果使用超过最大值的主机阵列，则会出现“参数超出范围”运行时错误。如果在单个SQL语句中使用多个主机数组，则它们的维度应相同。否则，在预编译时发出“数组大小不匹配”警告消息。如果忽略此警告，预编译器将使用SQL操作的<span class="italic">最小</span>维度。
                     </p>
                  </div>
               </div><a id="ZZPRE846"></a><div class="props_rev_3"><a id="GUID-8340AE22-CA85-4300-B685-49ED17ABB891" name="GUID-8340AE22-CA85-4300-B685-49ED17ABB891"></a><h4 id="ZZPRE-GUID-8340AE22-CA85-4300-B685-49ED17ABB891" class="sect4"><span class="enumeration_section">9.3.2</span>限制</h4>
                  <div>
                     <p><a id="d70073e245" class="indexterm-anchor"></a>您不能声明主机指针数组。此外，可能是主机阵列<a id="d70073e250" class="indexterm-anchor"></a> SQL语句中引用的内容仅限于一个维度。因此，以下示例中声明的二维数组<span class="italic">无效</span> ：</p><pre class="oac_no_warn" dir="ltr">EXEC SQL BEGIN DECLARE SECTION; hi_lo_scores（25,25）INTEGER; - 不允许EXEC SQL END DECLARE SECTION;</pre></div>
               </div>
            </div><a id="ZZPRE847"></a><div class="props_rev_3"><a id="GUID-4745E48D-905B-4A6A-A5AE-BDE35E52F5D0" name="GUID-4745E48D-905B-4A6A-A5AE-BDE35E52F5D0"></a><h3 id="ZZPRE-GUID-4745E48D-905B-4A6A-A5AE-BDE35E52F5D0" class="sect3"><span class="enumeration_section">9.4</span>关于在SQL语句中使用数组</h3>
               <div>
                  <p>Oracle预编译器允许在数据操作语句中使用主机数组。您可以在<code class="codeph">INSERT</code> ， <code class="codeph">UPDATE</code>和<code class="codeph">DELETE</code>语句中将主机数组用作输入变量，在<code class="codeph">SELECT</code>和<code class="codeph">FETCH</code>语句的<code class="codeph">INTO</code>子句中使用输出变量。
                  </p>
                  <p><a id="d70073e302" class="indexterm-anchor"></a>请注意，当<code class="codeph">MODE=ANSI14</code> ，数组操作是<span class="italic">不允许</span>的。换句话说，只有当<code class="codeph">MODE</code> = { <code class="codeph">ANSI|ANSI13|ORACLE}</code>时，才能在SQL语句中引用主机数组。
                  </p>
                  <p>用于主机数组和简单主机变量的语法几乎相同。一个区别是可选的FOR子句，它允许您控制数组处理。此外，在SQL语句中混合主机数组和简单主机变量存在限制。</p>
                  <p>以下部分说明了在数据操作语句中使用主机数组。</p>
               </div>
            </div><a id="ZZPRE848"></a><div class="props_rev_3"><a id="GUID-0CC543AC-ABEC-452C-A7C7-9B24ECB0DA33" name="GUID-0CC543AC-ABEC-452C-A7C7-9B24ECB0DA33"></a><h3 id="ZZPRE-GUID-0CC543AC-ABEC-452C-A7C7-9B24ECB0DA33" class="sect3"><span class="enumeration_section">9.5</span>关于选择数组</h3>
               <div>
                  <p><a id="d70073e344" class="indexterm-anchor"></a>您可以<a id="d70073e349" class="indexterm-anchor"></a>在<code class="codeph">SELECT</code>语句中使用主机数组作为输出变量。如果知道select将返回的最大行数，只需使用该数量的元素标注主机数组。在以下示例中，您可以直接选择三个主机阵列。知道select将返回不超过50行，您可以使用50个元素标注数组：</p><pre class="oac_no_warn" dir="ltr">EXEC SQL BEGIN DECLARE SECTION; emp_name（50）CHARACTER（20）; emp_number（50）INTEGER;薪水（50）REAL; EXEC SQL END DECLARE SECTION; EXEC SQL SELECT ENAME，EMPNO，SAL INTO：emp_name，：emp_number，：salary FROM EMP WHERE SAL&gt; 1000;</pre><p>在此示例中， <code class="codeph">SELECT</code>语句最多返回50行。如果符合条件的行少于50个，或者您只想检索50行，则此方法就足够了。但是，如果有超过50个符合条件的行，则无法以这种方式检索所有行。如果重新执行<code class="codeph">SELECT</code>语句，它只会再次返回前50行，即使更多符合条件。您必须标注较大的数组或声明游标以与<code class="codeph">FETCH</code>语句一起使用。
                  </p>
                  <p>如果<code class="codeph">SELECT INTO</code>语句返回的行数多于您标注的元素数，则Oracle会发出错误消息</p><pre class="oac_no_warn" dir="ltr">SQL-02112：SELECT ...INTO返回太多行</pre><p>除非您指定<code class="codeph">SELECT_ERROR</code> = <code class="codeph">NO</code> 。有关<code class="codeph">SELECT_ERROR</code>选项的更多信息，请参阅<span class="q">“ <a href="running-Oracle-precompilers.html#GUID-A15025BA-F60A-4144-BD81-A4394E02C8B9">SELECT_ERROR</a> ”</span></p>
               </div><a id="ZZPRE849"></a><div class="props_rev_3"><a id="GUID-0A10BBFA-F206-4F1F-A060-91A5E5EF65D8" name="GUID-0A10BBFA-F206-4F1F-A060-91A5E5EF65D8"></a><h4 id="ZZPRE-GUID-0A10BBFA-F206-4F1F-A060-91A5E5EF65D8" class="sect4"><span class="enumeration_section">9.5.1</span>批量提取</h4>
                  <div>
                     <p><a id="d70073e417" class="indexterm-anchor"></a>如果您不知道select将返回的最大行数，您可以声明<a id="d70073e420" class="indexterm-anchor"></a>并在“批处理”中打开一个cursor_name fetch。循环内的批量提取可让您轻松检索大量行。每次提取都会返回当前活动集中的下一批行。在以下示例中，您将获取20行批处理：</p><pre class="oac_no_warn" dir="ltr"><a id="d70073e424" class="indexterm-anchor"></a> EXEC SQL BEGIN DECLARE SECTION; emp_number（20）INTEGER;薪水（20）REAL; EXEC SQL END DECLARE SECTION; EXEC SQL DECLARE emp_cursor CURSOR FOR SELECT EMPNO，SAL FROM EMP; EXEC SQL OPEN emp_cursor; EXEC SQL WHENEVER NOT FOUND DO <span class="bold">...</span>LOOP EXEC SQL FETCH emp_cursor INTO：emp_number，：salary; - 处理批次行ENDLOOP;</pre></div>
               </div><a id="ZZPRE850"></a><div class="props_rev_3"><a id="GUID-82A8C632-2902-4249-9D18-CE2EE2C779D7" name="GUID-82A8C632-2902-4249-9D18-CE2EE2C779D7"></a><h4 id="ZZPRE-GUID-82A8C632-2902-4249-9D18-CE2EE2C779D7" class="sect4"><span class="enumeration_section">9.5.2获取</span>的行数</h4>
                  <div>
                     <p>每次提取最多返回数组维度中的行数。在以下情况下返回的行数较少：</p>
                     <ul style="list-style-type:disc">
                        <li>
                           <p>达到活动集的结尾。“无数据发现”Oracle警告代码返回到SQLCA中的SQLCODE。例如，如果您获取维度为100但仍返回20行的数组，则会发生这种情况。</p>
                        </li>
                        <li>
                           <p>仍然需要获取完整批次的行。例如，如果您将70行添加到维度20的数组中，则会发生这种情况，因为在第三次提取之后，仍然只有10行需要提取。</p>
                        </li>
                        <li>
                           <p>处理行时检测到错误。提取失败，适用的Oracle错误代码返回给SQLCODE。</p>
                        </li>
                     </ul>
                     <p>返回的累计行数可以在SQLCA的SQLERRD的第三个元素中找到，称为<a id="d70073e472" class="indexterm-anchor"></a>本指南中的SQLERRD（3）。这适用于每个打开的游标。在以下示例中，请注意如何单独维护每个游标的状态：</p><pre class="oac_no_warn" dir="ltr">EXEC SQL OPEN cursor1; EXEC SQL OPEN cursor2; EXEC SQL FETCH cursor1 INTO：array_of_20; - 现在在SQLERRD（3）中运行总计是20 EXEC SQL FETCH cursor2 INTO：array_of_30; - 现在在SQLERRD（3）中运行总数是30，而不是50 EXEC SQL FETCH cursor1 INTO：array_of_20; - 现在在SQLERRD（3）中运行总计是40（20 + 20）EXEC SQL FETCH cursor2 INTO：array_of_30; - 现在在SQLERRD（3）中运行总计为60（30 + 30）</pre></div>
               </div><a id="ZZPRE852"></a><a id="ZZPRE851"></a><div class="props_rev_3"><a id="GUID-8FAD0EE2-EE53-4140-B102-FD82CA00A91D" name="GUID-8FAD0EE2-EE53-4140-B102-FD82CA00A91D"></a><h4 id="ZZPRE-GUID-8FAD0EE2-EE53-4140-B102-FD82CA00A91D" class="sect4"><span class="enumeration_section">9.5.3</span>限制</h4>
                  <div>
                     <div class="section">
                        <p><a id="d70073e503" class="indexterm-anchor"></a>仅在子查询中允许在<code class="codeph">SELECT</code>语句的<code class="codeph">WHERE</code>子句中使用主机数组。（例如，请参阅<span class="q">“ <a href="using-host-arrays.html#GUID-F74653D4-1D3D-4518-9F10-BC1B50DD2566">关于使用WHERE子句</a> ”</span> 。）此外，您不能在<code class="codeph">SELECT</code>或<code class="codeph">FETCH</code>语句的INTO子句中将简单主机变量与主机数组混合使用;如果任何主机变量是一个数组，则所有主变量都必须是数组。<a href="using-host-arrays.html#GUID-8FAD0EE2-EE53-4140-B102-FD82CA00A91D__BGBJFAID" title="主机数组对select语句有效">表9-1</a>显示了主机数组的使用在<code class="codeph">SELECT</code> <code class="codeph">INTO</code>语句中有效。
                        </p>
                     </div>
                     <!-- class="section" -->
                     <div class="tblformal" id="GUID-8FAD0EE2-EE53-4140-B102-FD82CA00A91D__BGBJFAID">
                        <p class="titleintable">表9-1 SELECT INTO的有效主机数组</p>
                        <table cellpadding="4" cellspacing="0" class="Formal" title="SELECT INTO的有效主机数组" width="100%" border="1" summary="host arrays valid for select statement" frame="hsides" rules="rows">
                           <thead>
                              <tr align="left" valign="top">
                                 <th align="left" valign="bottom" width="33%" id="d70073e548">INTO条款</th>
                                 <th align="left" valign="bottom" width="33%" id="d70073e551">条款</th>
                                 <th align="left" valign="bottom" width="33%" id="d70073e554">有效？</th>
                              </tr>
                           </thead>
                           <tbody>
                              <tr align="left" valign="top">
                                 <td align="left" valign="top" width="33%" id="d70073e559" headers="d70073e548 ">
                                    <p>排列</p>
                                 </td>
                                 <td align="left" valign="top" width="33%" headers="d70073e559 d70073e551 ">
                                    <p>排列</p>
                                 </td>
                                 <td align="left" valign="top" width="33%" headers="d70073e559 d70073e554 ">
                                    <p>没有</p>
                                 </td>
                              </tr>
                              <tr align="left" valign="top">
                                 <td align="left" valign="top" width="33%" id="d70073e569" headers="d70073e548 ">
                                    <p>纯量</p>
                                 </td>
                                 <td align="left" valign="top" width="33%" headers="d70073e569 d70073e551 ">
                                    <p>纯量</p>
                                 </td>
                                 <td align="left" valign="top" width="33%" headers="d70073e569 d70073e554 ">
                                    <p>是</p>
                                 </td>
                              </tr>
                              <tr align="left" valign="top">
                                 <td align="left" valign="top" width="33%" id="d70073e579" headers="d70073e548 ">
                                    <p>排列</p>
                                 </td>
                                 <td align="left" valign="top" width="33%" headers="d70073e579 d70073e551 ">
                                    <p>纯量</p>
                                 </td>
                                 <td align="left" valign="top" width="33%" headers="d70073e579 d70073e554 ">
                                    <p>是</p>
                                 </td>
                              </tr>
                              <tr align="left" valign="top">
                                 <td align="left" valign="top" width="33%" id="d70073e589" headers="d70073e548 ">
                                    <p>纯量</p>
                                 </td>
                                 <td align="left" valign="top" width="33%" headers="d70073e589 d70073e551 ">
                                    <p>排列</p>
                                 </td>
                                 <td align="left" valign="top" width="33%" headers="d70073e589 d70073e554 ">
                                    <p>没有</p>
                                 </td>
                              </tr>
                           </tbody>
                        </table>
                     </div>
                     <!-- class="inftblhruleinformal" -->
                  </div>
               </div><a id="ZZPRE853"></a><div class="props_rev_3"><a id="GUID-1DE28D67-C963-4428-9532-7F1AD3AC0DE4" name="GUID-1DE28D67-C963-4428-9532-7F1AD3AC0DE4"></a><h4 id="ZZPRE-GUID-1DE28D67-C963-4428-9532-7F1AD3AC0DE4" class="sect4"><span class="enumeration_section">9.5.4</span>关于获取空值</h4>
                  <div>
                     <p>如果在缺少指示符数组的主机数组中选择或获取null，Oracle将停止处理，将SQLERRD（3）设置为已处理的行数，并发出以下错误消息：</p><pre class="oac_no_warn" dir="ltr">ORA-01405：获取的列值为NULL</pre><p>要了解如何查找空值和截断值，请参阅<span class="q">“ <a href="using-embedded-SQL.html#GUID-E4FC1AF8-5BCC-49CB-B3A5-83C99CA7A45A">关于使用指示符变量</a> ”</span> 。
                     </p>
                  </div>
               </div><a id="ZZPRE854"></a><div class="props_rev_3"><a id="GUID-CDB327B4-7D1A-4766-9B93-52DFA1A13B9C" name="GUID-CDB327B4-7D1A-4766-9B93-52DFA1A13B9C"></a><h4 id="ZZPRE-GUID-CDB327B4-7D1A-4766-9B93-52DFA1A13B9C" class="sect4"><span class="enumeration_section">9.5.5</span>关于获取截断值</h4>
                  <div>
                     <p>当DBMS = V7时，如果您选择或将截断的列值提取到缺少指示符数组的主机数组中，Oracle将停止处理，将SQLERRD（3）设置为已处理的行数，并发出以下错误消息：</p><pre class="oac_no_warn" dir="ltr">ORA-01406：获取的列值被截断</pre><p>您可以在截断发生之前检查SQLERRD（3）以查找处理的行数。行处理的计数包括导致截断错误的行。</p>
                     <p>当MODE = ANSI时，截断不被视为错误，因此Oracle继续处理。</p>
                     <p>同样，在进行数组选择和提取时，始终使用指示符数组。这样，如果Oracle将一个或多个截断的列值分配给输出主机数组，您可以在关联的指标数组中找到列值的原始长度。</p>
                  </div>
               </div><a id="ZZPRE856"></a><a id="ZZPRE855"></a><div class="props_rev_3"><a id="GUID-716CDB3E-435B-4E86-A9D5-ECCB3413B5F9" name="GUID-716CDB3E-435B-4E86-A9D5-ECCB3413B5F9"></a><h4 id="ZZPRE-GUID-716CDB3E-435B-4E86-A9D5-ECCB3413B5F9" class="sect4"><span class="enumeration_section">9.5.6</span>关于使用数组插入</h4>
                  <div>
                     <p><a id="d70073e688" class="indexterm-anchor"></a>您可以在<code class="codeph">INSERT</code>语句中将主机数组用作输入变量。只需确保程序在执行<code class="codeph">INSERT</code>语句之前使用数据填充数组。如果数组中的某些元素不相关，则可以使用<code class="codeph">FOR</code>子句来控制插入的行数。请参阅<a href="using-host-arrays.html#GUID-67713341-6FF8-4FF6-B5A7-C390A2B0B802">关于使用FOR子句</a> 。
                     </p>
                     <p>下面是使用主机数组插入的示例：</p><pre class="oac_no_warn" dir="ltr">EXEC SQL BEGIN DECLARE SECTION; emp_name（50）CHARACTER（20）; emp_number（50）INTEGER;薪水（50）REAL; EXEC SQL END DECLARE SECTION; - 填充主机数组EXEC SQL INSERT INTO EMP（ENAME，EMPNO，SAL）VALUES（：emp_name，：emp_number，：salary）;</pre><p>插入的累计行数可以在SQLERRD（3）中找到。</p>
                     <p>虽然在功能上等同于以下语句，但最后一个示例中的<code class="codeph">INSERT</code>语句更有效，因为它只发出一次对Oracle的调用：</p><pre class="oac_no_warn" dir="ltr">FOR i = 1 TO array_dimension EXEC SQL INSERT INTO EMP（ENAME，EMPNO，SAL）VALUES（：emp_name [i]，：emp_number [i]，：salary [i]）; ENDFOR;</pre><p>在这个虚构的例子中（假想因为主机变量<span class="italic">不能</span>在SQL语句中下标），您可以使用FOR循环按顺序访问所有数组元素。
                     </p>
                     <div class="section">
                        <p class="subhead3" id="GUID-716CDB3E-435B-4E86-A9D5-ECCB3413B5F9__GUID-65B4D956-3B25-4C25-A91B-C79BDE6CF9A8">限制</p>
                     </div>
                     <!-- class="section" -->
                     <div class="section">
                        <p>您不能在<code class="codeph">INSERT</code>语句的VALUES子句中使用指针数组;所有数组元素都必须是数据项。此外，混合用的VALUES子句中主机阵列简单主机变量<code class="codeph">INSERT</code>语句是<span class="italic">不允许</span>的;如果任何主机变量是一个数组，则所有主变量都必须是数组。
                        </p>
                     </div>
                     <!-- class="section" -->
                  </div>
               </div><a id="ZZPRE858"></a><a id="ZZPRE857"></a><div class="props_rev_3"><a id="GUID-2EAA4B54-A57A-4427-878D-F63D9718D56D" name="GUID-2EAA4B54-A57A-4427-878D-F63D9718D56D"></a><h4 id="ZZPRE-GUID-2EAA4B54-A57A-4427-878D-F63D9718D56D" class="sect4"><span class="enumeration_section">9.5.7</span>关于使用数组更新</h4>
                  <div>
                     <p><a id="d70073e767" class="indexterm-anchor"></a>您<a id="d70073e772" class="indexterm-anchor"></a>也可以在<code class="codeph">UPDATE</code>语句中将主机数组用作输入变量，如以下示例所示：</p><pre class="oac_no_warn" dir="ltr">EXEC SQL BEGIN DECLARE SECTION; emp_number（50）INTEGER;薪水（50）REAL; EXEC SQL END DECLARE SECTION; - 填充主机数组EXEC SQL UPDATE EMP SET SAL =：salary WHERE EMPNO =：emp_number;</pre><p>更新的累积行数可以在SQLERRD（3）中找到。该数字<span class="italic">不</span>包括通过级联更新处理的行。
                     </p>
                     <p>如果数组中的某些元素不相关，则可以使用FOR子句限制更新的行数。</p>
                     <p>最后一个示例显示了使用唯一键（ <span class="italic">emp_number</span> ）的典型更新。每个数组元素只限一行进行更新。在以下示例中，每个数组元素限定多行：</p><pre class="oac_no_warn" dir="ltr">EXEC SQL BEGIN DECLARE SECTION; job_title（10）CHARACTER（10）;佣金（50）REAL; EXEC SQL END DECLARE SECTION; - 填充主机数组EXEC SQL UPDATE EMP SET COMM =：委托WHERE JOB =：job_title;</pre><p><span class="bold">限制：</span>混合简单的主机变量在主机阵列<code class="codeph">SET</code>或<code class="codeph">WHERE</code>的子句<code class="codeph">UPDATE</code>语句是<span class="italic">不允许</span>的。如果任何主机变量是一个数组，则所有主变量都必须是数组。此外，如果在SET子句中使用主机数组，则<span class="italic">必须</span>在<code class="codeph">WHERE</code>子句中使用一个主机数组。但是，它们的维度和数据类型无法匹配。
                     </p>
                     <p>您不能在UPDATE语句中将主机数组与<code class="codeph">CURRENT</code> OF子句一起使用。有关替代方法，请参阅<a href="using-host-arrays.html#GUID-5E5021B0-116F-4242-8053-6CEE6B7B154E">关于模仿CURRENT OF子句</a> 。
                     </p>
                     <p><a href="using-host-arrays.html#GUID-2EAA4B54-A57A-4427-878D-F63D9718D56D__BGBCJHCH" title="数组在更新语句中有效">表9-2</a>显示了主机数组在<code class="codeph">UPDATE</code>语句中的有效使用情况：</p>
                     <div class="tblformal" id="GUID-2EAA4B54-A57A-4427-878D-F63D9718D56D__BGBCJHCH">
                        <p class="titleintable">表9-2 UPDATE的有效主机数组</p>
                        <table cellpadding="4" cellspacing="0" class="Formal" title="UPDATE的有效主机数组" width="100%" border="1" summary="arrays valid in an update statement" frame="hsides" rules="rows">
                           <thead>
                              <tr align="left" valign="top">
                                 <th align="left" valign="bottom" width="33%" id="d70073e848">SET子句</th>
                                 <th align="left" valign="bottom" width="33%" id="d70073e851">条款</th>
                                 <th align="left" valign="bottom" width="33%" id="d70073e854">有效？</th>
                              </tr>
                           </thead>
                           <tbody>
                              <tr align="left" valign="top">
                                 <td align="left" valign="top" width="33%" id="d70073e859" headers="d70073e848 ">
                                    <p>排列</p>
                                 </td>
                                 <td align="left" valign="top" width="33%" headers="d70073e859 d70073e851 ">
                                    <p>排列</p>
                                 </td>
                                 <td align="left" valign="top" width="33%" headers="d70073e859 d70073e854 ">
                                    <p>是</p>
                                 </td>
                              </tr>
                              <tr align="left" valign="top">
                                 <td align="left" valign="top" width="33%" id="d70073e869" headers="d70073e848 ">
                                    <p>纯量</p>
                                 </td>
                                 <td align="left" valign="top" width="33%" headers="d70073e869 d70073e851 ">
                                    <p>纯量</p>
                                 </td>
                                 <td align="left" valign="top" width="33%" headers="d70073e869 d70073e854 ">
                                    <p>是</p>
                                 </td>
                              </tr>
                              <tr align="left" valign="top">
                                 <td align="left" valign="top" width="33%" id="d70073e879" headers="d70073e848 ">
                                    <p>排列</p>
                                 </td>
                                 <td align="left" valign="top" width="33%" headers="d70073e879 d70073e851 ">
                                    <p>纯量</p>
                                 </td>
                                 <td align="left" valign="top" width="33%" headers="d70073e879 d70073e854 ">
                                    <p>没有</p>
                                 </td>
                              </tr>
                              <tr align="left" valign="top">
                                 <td align="left" valign="top" width="33%" id="d70073e889" headers="d70073e848 ">
                                    <p>纯量</p>
                                 </td>
                                 <td align="left" valign="top" width="33%" headers="d70073e889 d70073e851 ">
                                    <p>排列</p>
                                 </td>
                                 <td align="left" valign="top" width="33%" headers="d70073e889 d70073e854 ">
                                    <p>没有</p>
                                 </td>
                              </tr>
                           </tbody>
                        </table>
                     </div>
                     <!-- class="inftblhruleinformal" -->
                  </div>
               </div><a id="ZZPRE859"></a><div class="props_rev_3"><a id="GUID-580A8174-8920-4E67-9E53-C0B5C0EE2852" name="GUID-580A8174-8920-4E67-9E53-C0B5C0EE2852"></a><h4 id="ZZPRE-GUID-580A8174-8920-4E67-9E53-C0B5C0EE2852" class="sect4"><span class="enumeration_section">9.5.8</span>关于使用数组删除</h4>
                  <div>
                     <p><a id="d70073e919" class="indexterm-anchor"></a>您还可以在<code class="codeph">DELETE</code>语句中将主机数组用作输入变量。这就像在<code class="codeph">WHERE</code>子句中使用主机数组的连续元素重复执行<code class="codeph">DELETE</code>语句一样。因此，每次执行都可能从表中删除零个，一个或多个行。下面是使用主机数组删除的示例：</p><pre class="oac_no_warn" dir="ltr">EXEC SQL BEGIN DECLARE SECTION; ...emp_number（50）INTEGER; EXEC SQL END DECLARE SECTION; - 填充主机数组EXEC SQL DELETE FROM EMP WHERE EMPNO =：emp_number;</pre><p>删除的累计行数可以在SQLERRD（3）中找到。这个数字<span class="italic">不</span>包括被删除级联处理的行。
                     </p>
                     <p>最后一个示例显示了使用唯一键（ <span class="italic">emp_number</span> ）的典型删除。每个数组元素只限一行进行删除。在以下示例中，每个数组元素限定多行：</p><pre class="oac_no_warn" dir="ltr">EXEC SQL BEGIN DECLARE SECTION; ...job_title（10）CHARACTER（10）; EXEC SQL END DECLARE SECTION; - 填充主机数组EXEC SQL DELETE FROM EMP WHERE JOB =：job_title;</pre></div>
               </div><a id="ZZPRE860"></a><div class="props_rev_3"><a id="GUID-67DE5FD5-5ACC-4891-BD0F-E43EA19D1394" name="GUID-67DE5FD5-5ACC-4891-BD0F-E43EA19D1394"></a><h4 id="ZZPRE-GUID-67DE5FD5-5ACC-4891-BD0F-E43EA19D1394" class="sect4"><span class="enumeration_section">9.5.9</span>限制</h4>
                  <div>
                     <p>混合与宿主数组的简单主机变量<code class="codeph">WHERE</code>一个子句<code class="codeph">DELETE</code>语句是<span class="italic">不允许</span>的;如果任何主机变量是一个数组，则所有主变量都必须是数组。此外，您不能在<code class="codeph">DELETE</code>语句中将主机数组与<code class="codeph">CURRENT</code> <code class="codeph">OF</code>子句一起使用。有关替代方案，请参阅<span class="q">“ <a href="using-host-arrays.html#GUID-5E5021B0-116F-4242-8053-6CEE6B7B154E">关于模仿当前条款</a> ”</span> 。
                     </p>
                  </div>
               </div>
            </div><a id="ZZPRE861"></a><div class="props_rev_3"><a id="GUID-3B4397E4-F992-454F-97B3-CB53C8EA248E" name="GUID-3B4397E4-F992-454F-97B3-CB53C8EA248E"></a><h3 id="ZZPRE-GUID-3B4397E4-F992-454F-97B3-CB53C8EA248E" class="sect3"><span class="enumeration_section">9.6</span>关于使用指标数组</h3>
               <div>
                  <p>您可以使用指示符数组将空值分配给输入主机数组，并检测输出主机数组中的空值或截断值。以下示例显示如何使用指示符数组插入：</p><pre class="oac_no_warn" dir="ltr">EXEC SQL BEGIN DECLARE SECTION; emp_number（50）INTEGER; dept_number（50）INTEGER;佣金（50）REAL; ind_comm（50）SMALLINT; - 指标数组EXEC SQL END DECLARE SECTION; - 填充主机阵列 - 填充指标数组;要插入一个null  -  COMM列，将-1分配给相应的元素 - 指示符数组EXEC SQL INSERT INTO EMP（EMPNO，DEPTNO，COMM）VALUES（：emp_number，：dept_number，：commission：ind_comm）;</pre><p>指示器阵列的尺寸不能小于主机阵列的尺寸。</p>
               </div>
            </div><a id="ZZPRE862"></a><div class="props_rev_3"><a id="GUID-67713341-6FF8-4FF6-B5A7-C390A2B0B802" name="GUID-67713341-6FF8-4FF6-B5A7-C390A2B0B802"></a><h3 id="ZZPRE-GUID-67713341-6FF8-4FF6-B5A7-C390A2B0B802" class="sect3"><span class="enumeration_section">9.7</span>关于使用FOR子句</h3>
               <div>
                  <p>您可以使用可选的FOR子句来设置由以下任何SQL语句处理的数组元素的数量：</p>
                  <ul style="list-style-type:disc">
                     <li>
                        <p><code class="codeph">删除</code></p>
                     </li>
                     <li>
                        <p><code class="codeph">执行</code></p>
                     </li>
                     <li>
                        <p><code class="codeph">取</code></p>
                     </li>
                     <li>
                        <p><code class="codeph">插入</code></p>
                     </li>
                     <li>
                        <p><code class="codeph">打开</code></p>
                     </li>
                     <li>
                        <p><code class="codeph">UPDATE</code></p>
                     </li>
                  </ul>
                  <p><a id="d70073e1069" class="indexterm-anchor"></a> <code class="codeph">FOR</code>子句在<code class="codeph">UPDATE</code> ， <code class="codeph">INSERT</code>和<code class="codeph">DELETE</code>语句中特别有用。使用这些语句，您可能不想使用整个数组。<code class="codeph">FOR</code>子句允许您将所使用的元素限制为所需的数字，如下所示<a id="d70073e1088" class="indexterm-anchor"></a>示例显示：</p><pre class="oac_no_warn" dir="ltr">EXEC SQL BEGIN DECLARE SECTION; emp_name（100）CHARACTER（20）;薪水（100）REAL; rows_to_insert INTEGER; EXEC SQL END DECLARE SECTION; - 填充主机数组set rows_to_insert = 25; - 设置FOR子句变量EXEC SQL FOR：rows_to_insert  - 只处理25行INSERT INTO EMP（ENAME，SAL）VALUES（：emp_name，：salary）;</pre><p><code class="codeph">FOR</code>子句必须使用整数宿主变量来计算数组元素。例如，以下声明是非法的：</p><pre class="oac_no_warn" dir="ltr">EXEC SQL FOR 25  - 非法插入EMP（ENAME，EMPNO，SAL）值（：emp_name，：emp_number，：salary）;</pre><p><a id="d70073e1103" class="indexterm-anchor"></a> <code class="codeph">FOR</code> -clause变量指定要处理的数组元素的数量。确保数字不超过最小的数组维度。此外，数字必须是正数。如果为负或零，则不处理任何行。
                  </p>
               </div><a id="ZZPRE863"></a><div class="props_rev_3"><a id="GUID-535D3C68-51FE-481A-9E2D-08B94E53BD77" name="GUID-535D3C68-51FE-481A-9E2D-08B94E53BD77"></a><h4 id="ZZPRE-GUID-535D3C68-51FE-481A-9E2D-08B94E53BD77" class="sect4"><span class="enumeration_section">9.7.1</span>限制</h4>
                  <div>
                     <p><a id="d70073e1132" class="indexterm-anchor"></a>两个限制使<code class="codeph">FOR</code>子句语义保持清晰：您不能在<code class="codeph">SELECT</code>语句中使用FOR子句或使用<code class="codeph">CURRENT</code> <code class="codeph">OF</code>子句。
                     </p>
                  </div>
               </div><a id="ZZPRE864"></a><div class="props_rev_3"><a id="GUID-79073FE4-6F9D-45F5-B6E4-D10FE8BF0F4B" name="GUID-79073FE4-6F9D-45F5-B6E4-D10FE8BF0F4B"></a><h4 id="ZZPRE-GUID-79073FE4-6F9D-45F5-B6E4-D10FE8BF0F4B" class="sect4"><span class="enumeration_section">9.7.2</span>在SELECT语句中</h4>
                  <div>
                     <p>如果在<code class="codeph">SELECT</code>语句中使用<code class="codeph">FOR</code>子句，则会收到以下错误消息：</p><pre class="oac_no_warn" dir="ltr">PCC-E-0056：SELECT语句中不允许使用FOR子句...
</pre><p><code class="codeph">SELECT</code>语句中不允许使用<code class="codeph">FOR</code>子句，因为它的含义不清楚。这是否意味着“执行此<code class="codeph">SELECT</code>语句<span class="italic">n</span>次”？或者，它是否意味着“执行此<code class="codeph">SELECT</code>语句一次，但返回<span class="italic">n</span>行”？前一种情况的问题是每次执行都可能返回多行。在后一种情况下，最好声明一个游标并在<code class="codeph">FETCH</code>语句中使用<code class="codeph">FOR</code>子句，如下所示：</p><pre class="oac_no_warn" dir="ltr">EXEC SQL FOR：限制FETCH emp_cursor INTO ...</pre></div>
               </div><a id="ZZPRE865"></a><div class="props_rev_3"><a id="GUID-EA2ABB98-5595-42E0-B111-75AABABE5085" name="GUID-EA2ABB98-5595-42E0-B111-75AABABE5085"></a><h4 id="ZZPRE-GUID-EA2ABB98-5595-42E0-B111-75AABABE5085" class="sect4"><span class="enumeration_section">9.7.3</span>使用CURRENT OF子句</h4>
                  <div>
                     <p>您可以使用<code class="codeph">UPDATE</code>或<code class="codeph">DELETE</code>语句中的<code class="codeph">CURRENT OF</code>子句来引用<code class="codeph">FETCH</code>语句返回的最新行，如以下示例所示：</p><pre class="oac_no_warn" dir="ltr">EXEC SQL DECLARE emp_cursor CURSOR FOR SELECT ENAME，SAL FROM EMP WHERE EMPNO =：emp_number; ...EXEC SQL OPEN emp_cursor; ...EXEC SQL FETCH emp_cursor INTO：emp_name，：salary; ...EXEC SQL UPDATE EMP SET SAL =：new_salary WHERE CURRENT OF emp_cursor;</pre><p>但是，您不能将FOR子句与<code class="codeph">CURRENT</code> <code class="codeph">OF</code>子句一起使用。以下语句无效，因为<span class="italic">limit</span>的唯一逻辑值为1（您只能更新或删除当前行一次）：</p><pre class="oac_no_warn" dir="ltr">EXEC SQL FOR：limit UPDATE EMP SET SAL =：new_salary WHERE CURRENT OF emp_cursor; ...EXEC SQL FOR：限制DELETE FROM EMP WHERE CURRENT OF_ emprsor;</pre></div>
               </div>
            </div><a id="ZZPRE866"></a><div class="props_rev_3"><a id="GUID-F74653D4-1D3D-4518-9F10-BC1B50DD2566" name="GUID-F74653D4-1D3D-4518-9F10-BC1B50DD2566"></a><h3 id="ZZPRE-GUID-F74653D4-1D3D-4518-9F10-BC1B50DD2566" class="sect3"><span class="enumeration_section">9.8</span>关于使用WHERE子句</h3>
               <div>
                  <p><a id="d70073e1285" class="indexterm-anchor"></a> Oracle将包含维度<span class="italic">n的</span>主机数组的SQL语句视为使用<span class="italic">n个</span>不同的标量变量（各个数组元素）执行<span class="italic">n</span>次的相同SQL语句。仅当此类处理不明确时，预编译器才会发出以下错误消息：</p><pre class="oac_no_warn" dir="ltr">PCC-S-0055：不允许将数组&lt;name&gt;作为绑定变量...
</pre><p>例如，假设声明</p><pre class="oac_no_warn" dir="ltr">EXEC SQL BEGIN DECLARE SECTION; mgr_number（50）INTEGER; job_title（50）CHARACTER（20）; EXEC SQL END DECLARE SECTION;</pre><p>如果声明，这将是模棱两可的</p><pre class="oac_no_warn" dir="ltr">EXEC SQL SELECT MGR INTO：mgr_number FROM EMP WHERE JOB =：job_title;</pre><p>被视为虚构的陈述</p><pre class="oac_no_warn" dir="ltr">FOR i = 1到50 SELECT MGR INTO：mgr_number [i] FROM EMP WHERE JOB =：job_title [i]; ENDFOR;</pre><p>因为多行可能符合<code class="codeph">WHERE</code> -clause搜索条件，但只有一个输出变量可用于接收数据。因此，会发出错误消息。
                  </p>
                  <p>但是，如果声明如此，则不会含糊不清</p><pre class="oac_no_warn" dir="ltr">EXEC SQL UPDATE EMP SET MGR =：mgr_number WHERE EMPNO IN（从EMP中选择EMPNO，其中JOB =：job_title）;</pre><p>被视为虚构的陈述</p><pre class="oac_no_warn" dir="ltr">FOR i = 1到50 UPDATE EMP SET MGR =：mgr_number [i] WHERE EMPNO IN（从EMP中选择EMPNO，其中JOB =：job_title [i]）; ENDFOR;</pre><p>因为是在<span class="italic">mgr_number</span> <code class="codeph">SET</code>的每一行匹配<span class="italic">JOB_TITLE</span>子句中的<code class="codeph">WHERE</code>子句中，即使每个<span class="italic">JOB_TITLE</span>多行匹配。匹配每个<span class="italic">job_title的</span>所有行可以<code class="codeph">SET</code>为相同的<span class="italic">mgr_number</span> 。因此，不会发出任何错误消息。
                  </p>
               </div>
            </div><a id="ZZPRE867"></a><div class="props_rev_3"><a id="GUID-5E5021B0-116F-4242-8053-6CEE6B7B154E" name="GUID-5E5021B0-116F-4242-8053-6CEE6B7B154E"></a><h3 id="ZZPRE-GUID-5E5021B0-116F-4242-8053-6CEE6B7B154E" class="sect3"><span class="enumeration_section">9.9</span>关于模仿当前条款</h3>
               <div>
                  <p><a id="d70073e1376" class="indexterm-anchor"></a>您可以在<code class="codeph">DELETE</code>或<code class="codeph">UPDATE</code>语句中使用<code class="codeph">CURRENT OF</code> <span class="italic">游标</span>子句来引用从游标中获取的最新行。但是，您不能将<code class="codeph">CURRENT OF</code>与主机阵列一起使用。而是选择每行的<code class="codeph">ROWID</code> ，然后使用该值在更新或删除期间标识当前行。一个例子如下：</p><pre class="oac_no_warn" dir="ltr">EXEC SQL BEGIN DECLARE SECTION; emp_name（25）CHARACTER（20）; job_title（25）CHARACTER（15）; old_title（25）CHARACTER（15）; row_id（25）CHARACTER（18）; EXEC SQL END DECLARE SECTION; ...EXEC SQL DECLARE emp_cursor CURSOR FOR SELECT ENAME，JOB，ROWID FROM EMP; ...EXEC SQL OPEN emp_cursor; EXEC SQL WHENEVER未找到GOTO <span class="bold">......</span>...LOOP EXEC SQL FETCH emp_cursor INTO：emp_name，：job_title，：row_id; ...EXEC SQL DELETE FROM EMP WHERE JOB =：old_title AND ROWID =：row_id; EXEC SQL COMMIT WORK; ENDLOOP;</pre><p>但是，由于未使用<code class="codeph">FOR UPDATE OF</code>子句，因此<span class="italic">未</span>锁定获取的行。因此，如果另一个用户在您读取之后但在删除之前更改了行，则可能会得到不一致的结果。
                  </p>
                  <p></p>
               </div>
            </div><a id="ZZPRE868"></a><div class="props_rev_3"><a id="GUID-F7B6624A-363B-4CAA-8F87-0D0EEB822F33" name="GUID-F7B6624A-363B-4CAA-8F87-0D0EEB822F33"></a><h3 id="ZZPRE-GUID-F7B6624A-363B-4CAA-8F87-0D0EEB822F33" class="sect3"><span class="enumeration_section">9.10</span>关于使用SQLERRD（3）</h3>
               <div>
                  <p><a id="d70073e1447" class="indexterm-anchor"></a>对于<a id="d70073e1452" class="indexterm-anchor"></a> <code class="codeph">INSERT</code> ， <code class="codeph">UPDATE</code> ， <code class="codeph">DELETE</code>和<code class="codeph">SELECT</code> <code class="codeph">INTO</code>语句，SQLERRD（3）记录处理的行数。对于<a id="d70073e1473" class="indexterm-anchor"></a> <code class="codeph">FETCH</code>语句，它记录处理的行的累积总和。
                  </p>
                  <p>当使用具有<code class="codeph">FETCH</code>主机阵列时，要查找最近迭代返回的行数，请从其先前值（存储在另一个变量中）中减去SQLERRD（3）的当前值。在以下示例中，您确定最近一次提取返回的行数：</p><pre class="oac_no_warn" dir="ltr">EXEC SQL BEGIN DECLARE SECTION; emp_number（100）INTEGER; emp_name（100）CHARACTER（20）; EXEC SQL END DECLARE SECTION; ...rows_to获取INTEGER; rows_before INTEGER; rows_this_time INTEGER; ...EXEC SQL DECLARE emp_cursor CURSOR FOR SELECT EMPNO，ENAME from EMP WHERE DEPTNO = 30; EXEC SQL OPEN emp_cursor; EXEC SQL WHENEVER NOT FOUND CONTINUE; ...- 初始化循环变量set rows_to_fetch = 20; - 每个“批处理”集中的行数rows_before = 0; -  sqlerrd（3）的先前值设置rows_this_time = 20; WHILE rows_this_time = rows_to_fetch LOOP EXEC SQL FOR：rows_to_fetch FETCH emp_cursor INTO：emp_number，：emp_name; set rows_this_time = sqlca.sqlerrd（3） -  rows_before; set rows_before = sqlca.sqlerrd（3）; ENDLOOP; ENDWHILE;</pre><p>在阵列操作期间发生错误时，SQLERRD（3）也很有用。处理在导致错误的行停止，因此SQLERRD（3）给出成功处理的行数。</p>
               </div>
            </div>
         </div>
      </article>
   </body>
</html>