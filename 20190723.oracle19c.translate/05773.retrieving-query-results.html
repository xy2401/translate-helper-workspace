<html lang="en-us" dir="ltr" xml:lang="en-us">
   <head>
      <meta http-equiv="Content-Type" content="text/html; charset=utf-8"></meta>
      <meta name="viewport" content="width=device-width, initial-scale=1"></meta>
      <meta http-equiv="X-UA-Compatible" content="IE=edge"></meta>
      <title>检索查询结果</title>
      <meta property="og:site_name" content="Oracle Help Center"></meta>
      <meta property="og:title" content="Java API Developer&#39;s Guide "></meta>
      <meta property="og:description" content=""></meta>
      <link rel="stylesheet" href="/sp_common/book-template/ohc-book-template/css/book.css"></link>
      <link rel="shortcut icon" href="/sp_common/book-template/ohc-common/img/favicon.ico"></link>
      <meta name="application-name" content="Java API Developer&#39;s Guide"></meta>
      <meta name="generator" content="DITA Open Toolkit version 1.8.5 (Mode = doc)"></meta>
      <meta name="plugin" content="SP_docbuilder HTML plugin release 18.2.2"></meta>
      <link rel="alternate" href="olap-java-api-developers-guide.pdf" title="PDF File" type="application/pdf"></link>
      <meta name="robots" content="all"></meta>
      <link rel="schema.dcterms" href="http://purl.org/dc/terms/"></link>
      <meta name="dcterms.created" content="2019-01-10T13:53:39-08:00"></meta>
      
      <meta name="dcterms.dateCopyrighted" content="2000, 2019"></meta>
      <meta name="dcterms.category" content="database"></meta>
      <meta name="dcterms.identifier" content="E96402-01"></meta>
      
      <meta name="dcterms.product" content="en/database/oracle/oracle-database/19"></meta>
      
      <link rel="prev" href="understanding-cursor-classes-and-concepts.html" title="Previous" type="text/html"></link>
      <link rel="next" href="creating-dynamic-queries.html" title="Next" type="text/html"></link>
      <script>
        document.write('<style type="text/css">');
        document.write('body > .noscript, body > .noscript ~ * { visibility: hidden; }');
        document.write('</style>');
     </script>
      <script src="/sp_common/book-template/requirejs/require.js" data-main="/sp_common/book-template/ohc-book-template/js/book-config"></script>
      <script>
            if (window.require === undefined) {
                document.write('<script data-main="sp_common/book-template/ohc-book-template/js/book-config" src="sp_common/book-template/requirejs/require.js"><\/script>');
                document.write('<link href="sp_common/book-template/ohc-book-template/css/book.css" rel="stylesheet"/>');
            }
        </script>
      <script type="application/json" id="ssot-metadata">{"primary":{"category":{"short_name":"database","element_name":"Database","display_in_url":true},"suite":{"short_name":"oracle","element_name":"Oracle","display_in_url":true},"product_group":{"short_name":"not-applicable","element_name":"Not applicable","display_in_url":false},"product":{"short_name":"oracle-database","element_name":"Oracle Database","display_in_url":true},"release":{"short_name":"19","element_name":"Release 19","display_in_url":true}}}</script>
      
    <meta name="dcterms.title" content="OLAP Java API Developer&#39;s Guide"></meta>
    <meta name="dcterms.isVersionOf" content="OLAAP"></meta>
    <meta name="dcterms.release" content="Release 19"></meta>
  </head>
   <body dir="ltr">
      <div class="noscript alert alert-danger text-center" role="alert">
         <a href="understanding-cursor-classes-and-concepts.html" class="pull-left"><span class="glyphicon glyphicon-chevron-left" aria-hidden="true"></span>上一页</a> <a href="creating-dynamic-queries.html" class="pull-right">下一页<span class="glyphicon glyphicon-chevron-right" aria-hidden="true"></span></a> <span class="fa fa-exclamation-triangle" aria-hidden="true"></span>必须启用JavaScript才能正确显示此内容</div>
      <article>
         <header>
            <ol class="breadcrumb" vocab="http://schema.org/" typeof="BreadcrumbList">
               <li property="itemListElement" typeof="ListItem"><a href="index.html" property="item" typeof="WebPage"><span property="name">Java API开发人员指南</span></a></li>
               <li class="active" property="itemListElement" typeof="ListItem">检索查询结果</li>
            </ol>
            <a id="GUID-41769CCE-61BC-4A3C-8086-A4F6342458DA" name="GUID-41769CCE-61BC-4A3C-8086-A4F6342458DA"></a><a id="OLAAP362"></a>
            
            <h2 id="OLAAP-GUID-41769CCE-61BC-4A3C-8086-A4F6342458DA" class="sect2"><span class="enumeration_chapter">9</span>检索查询结果</h2>
         </header>
         <div class="ind">
            <div>
               <p>本章介绍如何使用Oracle OLAP Java API <code class="codeph">Cursor</code>检索查询结果以及如何获取对这些结果的访问权限。本章还介绍了如何自定义<code class="codeph">Cursor</code>的行为以适合显示结果的方法。有关<code class="codeph">Cursor</code>及其相关类的类层次结构的信息，以及有关位置，获取大小和范围的<code class="codeph">Cursor</code>概念的信息，请参阅<a href="understanding-cursor-classes-and-concepts.html#GUID-317FD4C8-9000-4A25-99FC-4D84D1894E0B">了解游标类和概念</a> 。
               </p>
               <p>本章包括以下主题：</p>
               <ul style="list-style-type:disc">
                  <li>
                     <p><a href="retrieving-query-results.html#GUID-8A1CAB10-C688-4366-BC57-8B41170BEE37">检索查询结果</a></p>
                  </li>
                  <li>
                     <p><a href="retrieving-query-results.html#GUID-2FF69CE4-873B-4CBF-B3B0-1376F114FEFB">导航CompoundCursor以获取不同的数据显示</a></p>
                  </li>
                  <li>
                     <p><a href="retrieving-query-results.html#GUID-7CA568E5-D368-4C65-BA47-51D095DFA335">指定游标的行为</a></p>
                  </li>
                  <li>
                     <p><a href="retrieving-query-results.html#GUID-9FC27E5E-C901-4838-B157-23834A3244A9">计算值的范围，起始和结束位置</a></p>
                  </li>
                  <li>
                     <p><a href="retrieving-query-results.html#GUID-BA2A974A-FF8F-49A1-8FF7-489E6BF5A9A5">指定获取大小</a></p>
                  </li>
               </ul>
            </div><a id="OLAAP364"></a><a id="OLAAP363"></a><div class="props_rev_3"><a id="GUID-8A1CAB10-C688-4366-BC57-8B41170BEE37" name="GUID-8A1CAB10-C688-4366-BC57-8B41170BEE37"></a><h3 id="OLAAP-GUID-8A1CAB10-C688-4366-BC57-8B41170BEE37" class="sect3"><span class="enumeration_section">9.1</span>检索查询结果</h3>
               <div>
                  <div class="section">
                     <p><a id="d26911e116" class="indexterm-anchor"></a>查询是OLAP Java API <code class="codeph">Source</code> ，它指定要从数据存储中检索的数据以及希望Oracle OLAP对数据执行的任何计算。<code class="codeph">Cursor</code>是检索或<span class="italic">获取</span> <code class="codeph">Source</code>指定的结果集的对象。为<code class="codeph">Source</code>创建<code class="codeph">Cursor</code>涉及以下步骤：</p>
                  </div>
                  <!-- class="section" -->
                  <ol>
                     <li><span>获取的主要<code class="codeph">Source</code>来自<code class="codeph">MdmObject</code>或创建派生<code class="codeph">Source</code> ，通过对业务<code class="codeph">DataProvider</code>或<code class="codeph">Source</code> 。有关获取或创建<code class="codeph">Source</code>对象的信息，请参阅<a href="understanding-source-objects.html#GUID-871159BB-8ED1-454B-B9FA-62F36683F4B2">了解源对象</a> 。</span></li>
                     <li><span>如果<code class="codeph">Source</code>是派<code class="codeph">Source</code> ，则提交您在其中创建<code class="codeph">Source</code>的<code class="codeph">Transaction</code> 。要提交<code class="codeph">Transaction</code> ，调用<code class="codeph">commitCurrentTransaction</code>你的方法<code class="codeph">TransactionProvider</code> 。有关提交<code class="codeph">Transaction</code>更多信息，请参阅<a href="using-transaction-provider.html#GUID-E290E8B5-CC10-4BDF-91B1-7189BE7F12B9">使用TransactionProvider</a> 。如果<code class="codeph">Source</code>是主要<code class="codeph">Source</code> ，那么您不需要提交<code class="codeph">Transaction</code> 。</span></li>
                     <li><span>通过调用<code class="codeph">DataProvider</code>的<code class="codeph">createCursorManager</code>方法并将该方法传递给<code class="codeph">Source</code>创建<code class="codeph">CursorManager</code> 。</span></li>
                     <li><span>通过调用<code class="codeph">CursorManager</code>的<code class="codeph">createCursor</code>方法创建一个<code class="codeph">Cursor</code> 。</span></li>
                  </ol>
                  <div class="example" id="GUID-8A1CAB10-C688-4366-BC57-8B41170BEE37__I1006606">
                     <p class="titleinexample">例9-1创建游标</p>
                     <p><a id="d26911e240" class="indexterm-anchor"></a><a id="d26911e244" class="indexterm-anchor"></a><a id="d26911e248" class="indexterm-anchor"></a><a id="d26911e252" class="indexterm-anchor"></a>此示例为派生的<code class="codeph">Source</code> <code class="codeph">querySource</code>创建一个<code class="codeph">Cursor</code> 。该示例使用名为<code class="codeph">dp</code>的<code class="codeph">DataProvider</code> 。该示例创建<code class="codeph">CursorManager</code>名为<code class="codeph">cursorMngr</code>和<code class="codeph">Cursor</code>命名<code class="codeph">queryCursor</code> 。
                     </p>
                     <p>最后，该示例关闭<code class="codeph">CursorManager</code> 。使用完<code class="codeph">Cursor</code> ，应关闭<code class="codeph">CursorManager</code>以释放资源。
                     </p><pre class="oac_no_warn" dir="ltr">CursorManager cursorMngr = dp.createCursorManager（querySource）; Cursor queryCursor = cursorMngr.createCursor（）; //以某种方式使用Cursor，例如显示它的值。cursorMngr.close（）;</pre></div>
                  <!-- class="example" -->
               </div><a id="OLAAP366"></a><a id="OLAAP367"></a><a id="OLAAP368"></a><a id="OLAAP369"></a><a id="OLAAP365"></a><div class="props_rev_3"><a id="GUID-2BC05080-A108-4728-9465-9DC97510FCB2" name="GUID-2BC05080-A108-4728-9465-9DC97510FCB2"></a><h4 id="OLAAP-GUID-2BC05080-A108-4728-9465-9DC97510FCB2" class="sect4"><span class="enumeration_section">9.1.1</span>从游标中获取值</h4>
                  <div>
                     <div class="section">
                        <p><a id="d26911e339" class="indexterm-anchor"></a> <code class="codeph">Cursor</code>接口封装了<span class="italic">当前位置</span>的概念，并具有移动当前位置的方法。<code class="codeph">ValueCursor</code>和<code class="codeph">CompoundCursor</code>接口扩展了<code class="codeph">Cursor</code>接口。Oracle OLAP Java API具有<code class="codeph">ValueCursor</code>和<code class="codeph">CompoundCursor</code>接口的实现。调用<code class="codeph">CursorManager</code>的<code class="codeph">createCursor</code>方法将返回<code class="codeph">ValueCursor</code>或<code class="codeph">CompoundCursor</code>实现，具体取决于您要为其创建<code class="codeph">Cursor</code>的<code class="codeph">Source</code> 。
                        </p>
                        <p>对于具有一组值的<code class="codeph">Source</code> ，将返回<code class="codeph">ValueCursor</code> 。<code class="codeph">ValueCursor</code>在其当前位置具有值，并且具有用于在当前位置获取值的方法。
                        </p>
                        <p>为具有多组值的<code class="codeph">Source</code>创建<code class="codeph">CompoundCursor</code> ，该<code class="codeph">Source</code>是具有一个或多个输出的<code class="codeph">Source</code> 。<code class="codeph">Source</code>每组值由<code class="codeph">CompoundCursor</code>的子<code class="codeph">ValueCursor</code>表示。<code class="codeph">CompoundCursor</code>具有获取其子<code class="codeph">Cursor</code>对象的方法。
                        </p>
                        <p><a id="d26911e424" class="indexterm-anchor"></a> <code class="codeph">Source</code>的结构决定了<code class="codeph">Cursor</code>的结构。甲<code class="codeph">Source</code>可以具有嵌套的输出，当一个或多个的输出的发生<code class="codeph">Source</code>本身是一个<code class="codeph">Source</code>与输出。如果<code class="codeph">Source</code>有一个嵌套的输出，那么<code class="codeph">CompoundCursor</code>为<code class="codeph">Source</code>有一个孩子<code class="codeph">CompoundCursor</code>对于嵌套输出。
                        </p>
                        <p><code class="codeph">CompoundCursor</code>协调它包含的子<code class="codeph">Cursor</code>对象的位置。<code class="codeph">CompoundCursor</code>的当前位置指定子<code class="codeph">Cursor</code>对象的一组位置。
                        </p>
                        <p>有关仅具有一级输出值的<code class="codeph">Source</code>的示例，请参见<a href="retrieving-query-results.html#GUID-2BC05080-A108-4728-9465-9DC97510FCB2__I1006671">示例9-4</a> 。有关具有嵌套输出值的<code class="codeph">Source</code>的示例，请参见<a href="retrieving-query-results.html#GUID-2BC05080-A108-4728-9465-9DC97510FCB2__I1006700">示例9-5</a> 。
                        </p>
                        <p><a id="d26911e484" class="indexterm-anchor"></a>表示单个值集的<code class="codeph">Source</code>的示例是由<code class="codeph">MdmDimension</code>的<code class="codeph">getSource</code>方法返回的值，例如表示产品值的<code class="codeph">MdmPrimaryDimension</code> 。为该<code class="codeph">Source</code>创建一个<code class="codeph">Cursor</code>返回一个<code class="codeph">ValueCursor</code> 。调用<code class="codeph">getCurrentValue</code>方法将返回该<code class="codeph">ValueCursor</code>当前位置的产品值。
                        </p>
                     </div>
                     <!-- class="section" -->
                     <div class="example" id="GUID-2BC05080-A108-4728-9465-9DC97510FCB2__I1006620">
                        <p class="titleinexample">示例9-2从ValueCursor获取单个值</p>
                        <p>此示例从<code class="codeph">mdmProdHier</code>获取<code class="codeph">Source</code> ， <code class="codeph">mdmProdHier</code>是表示产品值的<code class="codeph">MdmLevelHierarchy</code> ，并为该<code class="codeph">Source</code>创建<code class="codeph">Cursor</code> 。该示例将当前位置设置为<code class="codeph">ValueCursor</code>的第五个元素，并从<code class="codeph">Cursor</code>获取产品值。然后该示例关闭<code class="codeph">CursorManager</code> 。在示例中， <code class="codeph">dp</code>是<code class="codeph">DataProvider</code> 。
                        </p><pre class="oac_no_warn" dir="ltr">Source prodSource = mdmProdHier.getSource（）; //因为prodSource是主要的源，所以您不需要//提交当前的Transaction。CursorManager cursorMngr = dp.createCursorManager（prodSource）; Cursor prodCursor = cursorMngr.createCursor（）; //将Cursor转换为ValueCursor。ValueCursor prodValues =（ValueCursor）prodCursor; //将位置设置为ValueCursor的第五个元素。prodValues.setPosition（5）; //产品值是字符串。获取当前位置的值。String value = prodValues.getCurrentString（）; //使用值执行某些操作，例如显示它。//关闭CursorManager。cursorMngr.close（）;</pre></div>
                     <!-- class="example" -->
                     <div class="example" id="GUID-2BC05080-A108-4728-9465-9DC97510FCB2__I1006645">
                        <p class="titleinexample">示例9-3从ValueCursor获取所有值</p>
                        <p><a id="d26911e559" class="indexterm-anchor"></a>此示例使用与<a href="retrieving-query-results.html#GUID-2BC05080-A108-4728-9465-9DC97510FCB2__I1006620">示例9-2</a>相同的<code class="codeph">Cursor</code> 。此示例使用<code class="codeph">do...while</code>循环和<code class="codeph">next</code>的方法<code class="codeph">ValueCursor</code>通过的位置移动<code class="codeph">ValueCursor</code> 。<code class="codeph">next</code>方法从有效位置开始，并在<code class="codeph">Cursor</code>存在另一个位置时返回<code class="codeph">true</code> 。它还将当前位置推进到下一个位置。
                        </p>
                        <p>该示例将位置设置为<code class="codeph">ValueCursor</code>的第一个位置。该示例遍历位置并使用<code class="codeph">getCurrentValue</code>方法获取当前位置的值。
                        </p><pre class="oac_no_warn" dir="ltr">// prodValues是prodSource的ValueCursor。prodValues.setPosition（1）; do {println（prodValues.getCurrentValue）; } while（prodValues.next（））;</pre><p><a id="d26911e602" class="indexterm-anchor"></a><a id="d26911e606" class="indexterm-anchor"></a><a id="d26911e610" class="indexterm-anchor"></a><a id="d26911e614" class="indexterm-anchor"></a>由A表示的结果集的值<code class="codeph">CompoundCursor</code>是在子<code class="codeph">ValueCursor</code>所述的对象<code class="codeph">CompoundCursor</code> 。要获取这些值，您必须从<code class="codeph">CompoundCursor</code>获取子<code class="codeph">ValueCursor</code>对象。
                        </p>
                        <p><a id="d26911e636" class="indexterm-anchor"></a> <code class="codeph">CompoundCursor</code>一个示例是通过调用<code class="codeph">CursorManager</code>的<code class="codeph">createCursor</code>方法返回的<code class="codeph">Source</code> ，该方法表示由度量维度中的选定值指定的度量值。
                        </p>
                        <p><a href="retrieving-query-results.html#GUID-2BC05080-A108-4728-9465-9DC97510FCB2__I1006671">例9-4</a>使用一个名为<code class="codeph">units</code>的<code class="codeph">Source</code> ，它来自调用<code class="codeph">MdmBaseMeasure</code>的<code class="codeph">getSource</code>方法，该方法表示销售的单位数。度量的维度是<code class="codeph">MdmPrimaryDimension</code>对象，表示产品，客户，时间和渠道。此示例使用<code class="codeph">Source</code>对象来表示这些维度的默认层次结构中的选定值。这些<code class="codeph">Source</code>对象的名称是<code class="codeph">prodSel</code> ， <code class="codeph">custSel</code> ， <code class="codeph">timeSel</code>和<code class="codeph">chanSel</code> 。未显示表示度量和维度选择的<code class="codeph">Source</code>对象的创建。
                        </p>
                        <p><a href="retrieving-query-results.html#GUID-2BC05080-A108-4728-9465-9DC97510FCB2__I1006671">示例9-4</a>将维度选择连接到度量，从而生成名为<code class="codeph">unitsForSelections</code>的<code class="codeph">Source</code> 。它创建了一个<code class="codeph">CompoundCursor</code> ，命名<code class="codeph">unitsForSelCursor</code> ，为<code class="codeph">unitsForSelections</code> ，并得到基本<code class="codeph">ValueCursor</code>并从输出<code class="codeph">CompoundCursor</code> 。在这种情况下，每个输出都是<code class="codeph">ValueCursor</code> 。输出在<code class="codeph">List</code>中返回。在输出的顺序<code class="codeph">List</code>是其中输出是由连续的连接操作加入到输出列表中的顺序的逆。在示例中， <code class="codeph">dp</code>是<code class="codeph">DataProvider</code> 。
                        </p>
                     </div>
                     <!-- class="example" -->
                     <div class="example" id="GUID-2BC05080-A108-4728-9465-9DC97510FCB2__I1006671">
                        <p class="titleinexample">示例9-4从CompoundCursor获取ValueCursor对象</p><pre class="oac_no_warn" dir="ltr">Source unitsForSelections = units.join（prodSel）.join（custSel）.join（timeSel）.join（chanSel）; //提交当前事务（代码未显示）。//为unitsForSelections创建一个Cursor。CursorManager cursorMngr = dp.createCursorManager（unitsForSelections）; CompoundCursor unitsForSelCursor =（CompoundCursor）cursorMngr.createCursor（）; //获取基础ValueCursor。ValueCursor specifiedUnitsVals = unitsForSelCursor.getValueCursor（）; //获取输出List outputs = unitsForSelCursor.getOutputs（）; ValueCursor chanSelVals =（ValueCursor）outputs.get（0）; ValueCursor timeSelVals =（ValueCursor）outputs.get（1）; ValueCursor custSelVals =（ValueCursor）outputs.get（2）; ValueCursor prodSelVals =（ValueCursor）outputs.get（3）; //您现在可以从ValueCursor对象中获取值。//完成使用Cursor对象后，关闭CursorManager。cursorMngr.close（）;</pre><p><a href="retrieving-query-results.html#GUID-2BC05080-A108-4728-9465-9DC97510FCB2__I1006700">示例9-5</a>使用与<a href="retrieving-query-results.html#GUID-2BC05080-A108-4728-9465-9DC97510FCB2__I1006671">示例9-4</a>相同的单位度量，但它以不同方式将维度选择连接到度量。<a href="retrieving-query-results.html#GUID-2BC05080-A108-4728-9465-9DC97510FCB2__I1006700">例9-5</a>将两个维度选择连接在一起。然后，它将结果连接到通过将单维选择连接到度量而生成的<code class="codeph">Source</code> 。生成的<code class="codeph">Source</code> ， <code class="codeph">unitsForSelections</code>表示具有嵌套输出的查询，这意味着它具有多个级别的输出。
                        </p>
                        <p>所述<code class="codeph">CompoundCursor</code>这个示例创建<code class="codeph">unitsForSelections</code>因此还具有嵌套输出。<code class="codeph">CompoundCursor</code>具有子基值<code class="codeph">ValueCursor</code>并具有三个子<code class="codeph">ValueCursor</code>对象和一个子<code class="codeph">CompoundCursor</code>作为输出。
                        </p>
                        <p><a href="retrieving-query-results.html#GUID-2BC05080-A108-4728-9465-9DC97510FCB2__I1006700">例9-5</a>将通道尺寸值<code class="codeph">chanSel</code>的选择与客户尺寸值<code class="codeph">custSel</code>的选择结合<code class="codeph">custSel</code> 。结果是<code class="codeph">custByChanSel</code> ，一个<code class="codeph">Source</code> ，其客户值为基值，通道值为输出值。该示例连接到<code class="codeph">units</code>选择产品和时间值，然后加入<code class="codeph">custByChanSel</code> 。结果查询由<code class="codeph">unitsForSelections</code>表示。
                        </p>
                        <p>这个例子提交当前<code class="codeph">Transaction</code>并创建<code class="codeph">CompoundCursor</code> ，命名<code class="codeph">unitsForSelCursor</code> ，为<code class="codeph">unitsForSelections</code> 。
                        </p>
                        <p>该示例获取基本<code class="codeph">ValueCursor</code>和<code class="codeph">CompoundCursor</code>的输出。在示例中， <code class="codeph">dp</code>是<code class="codeph">DataProvider</code> 。
                        </p>
                     </div>
                     <!-- class="example" -->
                     <div class="example" id="GUID-2BC05080-A108-4728-9465-9DC97510FCB2__I1006700">
                        <p class="titleinexample">示例9-5从具有嵌套输出的CompoundCursor获取值</p><pre class="oac_no_warn" dir="ltr"><a id="d26911e834" class="indexterm-anchor"></a><a id="d26911e838" class="indexterm-anchor"></a>来源custByChanSel = custSel.join（chanSel）; Source unitsForSelections = units.join（prodSel）.join（timeSel）.join（custByChanSel）; //提交当前事务（代码未显示）。//为unitsForSelections创建一个Cursor。CursorManager cursorMngr = dp.createCursorManager（unitsForSelections）; Cursor unitsForSelCursor = cursorMngr.createCursor（）; //将Cursor发送到执行不同操作的方法//取决于Cursor是CompoundCursor还是// ValueCursor。printCursor（unitsForSelCursor）; cursorMngr.close（）; //未显示someMethod的剩余代码。//以下代码来自CursorPrintWriter类。
<a id="d26911e843" class="indexterm-anchor"></a> // printCursor方法有一个do ... while循环，它通过传递给它的Cursor的位置//移动。在每个位置，该方法打印通过循环的迭代次数，然后是冒号和空格。输出//对象是PrintWriter。该方法调用private _printTuple方法，//然后打印一个新行。“元组”是由父CompoundFursor的一个位置指定的输出ValueCursor值的集合。该方法为父CompoundCursor的每个位置打印一行。private void printCursor（Cursor rootCursor）{int i = 1; do {print（i ++ +“：”）; _printTuple（rootCursor）;的println（）;冲洗（）; } while（rootCursor.next（））;如果传递给_printTuple方法的Cursor是ValueCursor，那么//该方法将在ValueCursor的当前位置打印该值。//如果传入的Cursor是一个CompoundCursor，则该方法获取CompoundCursor的//输出并迭代输出，//为每个输出递归调用自身。然后该方法获得CompoundCursor的//基值ValueCursor并再次调用自身。private void _printTuple（Cursor cursor）{if（cursor instanceof CompoundCursor）{CompoundCursor compoundCursor =（CompoundCursor）cursor; //在每个输出的值之前放置一个左括号。print（“（”）; Iterator iterOutputs = compoundCursor.getOutputs（）。iterator（）; Cursor output =（Cursor）iterOutputs.next（）; _printTuple（output）; while（iterOutputs.hasNext（））{//放一个每个输出值后的逗号。打印（”，”）; _printTuple（（光标）iterOutputs.next（））; } //在最后一个输出的值后面加一个逗号。打印（”，”）; //获取基础ValueCursor。_printTuple（compoundCursor.getValueCursor（））; //在基值后面加上一个右括号，表示//元组的结尾。打印（”）”）; } else if（cursor instanceof ValueCursor）{ValueCursor valueCursor =（ValueCursor）cursor; if（valueCursor.hasCurrentValue（））print（valueCursor.getCurrentValue（））; else //如果此位置具有空值。打印（ “NA”）; }}</pre></div>
                     <!-- class="example" -->
                  </div>
               </div>
            </div><a id="OLAAP371"></a><a id="OLAAP372"></a><a id="OLAAP373"></a><a id="OLAAP370"></a><div class="props_rev_3"><a id="GUID-2FF69CE4-873B-4CBF-B3B0-1376F114FEFB" name="GUID-2FF69CE4-873B-4CBF-B3B0-1376F114FEFB"></a><h3 id="OLAAP-GUID-2FF69CE4-873B-4CBF-B3B0-1376F114FEFB" class="sect3"><span class="enumeration_section">9.2</span>导航CompoundCursor以获取不同的数据显示</h3>
               <div>
                  <div class="section">
                     <p>使用<code class="codeph">CompoundCursor</code>的方法，您可以轻松地移动或导航<code class="codeph">CompoundCursor</code>结构，并从<code class="codeph">CompoundCursor</code>的<code class="codeph">ValueCursor</code>后代获取值。来自多维OLAP查询的数据通常以交叉表格式显示，或以表格或图形显示。
                     </p>
                     <p>要显示多行和多列的数据，可以根据显示器的需要遍历<code class="codeph">CompoundCursor</code>不同级别的位置。对于某些显示（例如表格），您可以遍历父级<code class="codeph">CompoundCursor</code>的位置。对于其他显示（例如交叉表），可以循环遍历子<code class="codeph">Cursor</code>对象的位置。
                     </p>
                     <p><a id="d26911e913" class="indexterm-anchor"></a><a id="d26911e917" class="indexterm-anchor"></a>要在表视图中显示查询结果，其中每行包含来自每个输出<code class="codeph">ValueCursor</code>和基本<code class="codeph">ValueCursor</code> ，您可以确定顶级或根， <code class="codeph">CompoundCursor</code>的位置，然后迭代其位置。<a href="retrieving-query-results.html#GUID-2FF69CE4-873B-4CBF-B3B0-1376F114FEFB__I1006777">例9-6一次</a>只显示结果集的一部分。它为<code class="codeph">Source</code>创建一个<code class="codeph">Cursor</code> ，表示基于具有单位成本值的度量的查询。度量的维度是产品和时间维度。未显示主要<code class="codeph">Source</code>对象的创建和维度的派生选择。
                     </p>
                     <p>该示例将表示维值选择的<code class="codeph">Source</code>对象连接到表示度量的<code class="codeph">Source</code> 。它提交当前的<code class="codeph">Transaction</code> ，然后创建一个<code class="codeph">Cursor</code> ，将其转换为<code class="codeph">CompoundCursor</code> 。的示例设置的位置<code class="codeph">CompoundCursor</code> ，通过的12个位置迭代<code class="codeph">CompoundCursor</code> ，并打印出在那些位置中指定的值。该<code class="codeph">DataProvider</code>是<code class="codeph">dp</code> 。
                     </p>
                  </div>
                  <!-- class="section" -->
                  <div class="example" id="GUID-2FF69CE4-873B-4CBF-B3B0-1376F114FEFB__I1006777">
                     <p class="titleinexample">示例9-6导航表视图</p><pre class="oac_no_warn" dir="ltr">Source unitPriceByMonth = unitPrice.join（productSel）.join（timeSel）; //提交当前事务（代码未显示）。//为unitPriceByMonth创建一个光标。CursorManager cursorMngr = dp.createCursorManager（unitPriceByMonth）; CompoundCursor rootCursor =（CompoundCursor）cursorMngr.createCursor（）; //确定要显示的起始位置和行数。int start = 7; int numRows = 12; println（“月产品单价”）; println（“------- -------- ----------”）; //遍历根CompoundCursor的指定位置。//假设Cursor至少包含（start + numRows）个位置。for（int pos = start; pos &lt;start + numRows; pos ++）{//设置根CompoundCursor的位置。rootCursor.setPosition（POS）; //打印输出和基本ValueCursors的本地值。// getLocalValue方法从维度元素的唯一//值中获取本地值。String timeValue =（（ValueCursor）rootCursor.getOutputs（）。get（0））。getCurrentString（）; String timeLocVal = getLocalValue（timeValue）; String prodValue =（（ValueCursor）rootCursor.getOutputs（）。get（1））。getCurrentString（）; String prodLocVal = getLocalValue（prodValue）;对象价格= rootCursor.getValueCursor（）。getCurrentValue（）; println（timeLocVal +“”+ prodLocVal +“”+ price）; } cursorMngr.close（）;</pre><p>如果查询的时间选择具有八个值，例如2001和2002年的每个日历季度的第一个月，并且产品选择具有三个值，则<code class="codeph">unitPriceByMonth</code>查询的结果集具有二十四个位置。该示例显示下表，其中包含<code class="codeph">CompoundCursor</code>位置7到18指定的值。
                     </p><pre class="oac_no_warn" dir="ltr">月产品单价------- -------- ---------- 2001.07 ENVY ABM 2892.18 2001.07 ENVY EXE 3155.91 2001.07 ENVY STD 2505.57 2001.10 ENVY ABM 2856.86 2001.10 ENVY EXE 3105.53 2001.10 ENVY STD 2337.3 2002.01 ENVY ABM 2896.77 2002.01 ENVY EXE 3008.95 2002.01 ENVY STD 2140.71 2002.04 ENVY ABM 2880.39 2002.04 ENVY EXE 2953.96 2002.04 ENVY STD 2130.88</pre></div>
                  <!-- class="example" -->
                  <div class="example" id="GUID-2FF69CE4-873B-4CBF-B3B0-1376F114FEFB__I1006801">
                     <p class="titleinexample">示例9-7在没有页面的情况下导航交叉表视图</p>
                     <p>此示例使用与<a href="retrieving-query-results.html#GUID-2FF69CE4-873B-4CBF-B3B0-1376F114FEFB__I1006777">示例9-6</a>相同的查询。在交叉表视图中，第一行是列标题，在此示例中是<code class="codeph">prodSel</code>的值。<code class="codeph">prodSel</code>的输出是更快变化的输出，因为<code class="codeph">prodSel</code>维度选择是输出列表中的最后一个输出，该输出是由将度量连接到维度选择的操作产生的。其余行以行标题开头。行标题是来自较慢变化输出的值，即<code class="codeph">timeSel</code> 。列标题下的行的其余位置包含由维值集合指定的<code class="codeph">unitPrice</code>值。要在交叉表视图中显示查询结果，请迭代顶级<code class="codeph">CompoundCursor</code>的子项的位置。
                     </p>
                     <p>该<code class="codeph">DataProvider</code>是<code class="codeph">dp</code> 。
                     </p><pre class="oac_no_warn" dir="ltr"><a id="d26911e1023" class="indexterm-anchor"></a><a id="d26911e1027" class="indexterm-anchor"></a> Source unitPriceByMonth = unitPrice.join（productSel）.join（timeSel）; //提交当前事务（代码未显示）。//为unitPriceByMonth创建一个光标。CursorManager cursorMngr = dp.createCursorManager（unitPriceByMonth）; CompoundCursor rootCursor =（CompoundCursor）cursorMngr.createCursor（）; //获取输出和ValueCursor对象。List outputs = rootCursor.getOutputs（）; //第一个输出的值为timeSel，变速输出较慢。ValueCursor rowCursor =（ValueCursor）outputs.get（0）; //第二个输出具有更快的productSel变化值。ValueCursor columnCursor =（ValueCursor）outputs.get（1）; //基本ValueCursor具有unitPrice中的值。ValueCursor unitPriceValues = rootCursor.getValueCursor（）; //将值显示为交叉表。println（“PRODUCT”）; println（“---------------------------------”）;打印（“月”）; do {String value =（（ValueCursor）columnCursor）.getCurrentString（）; print（getContext（）。getLocalValue（value）+“”）; } while（columnCursor.next（））; println（“\ n ------- -------- -------- --------”）; //将Cursor列重置为第一个元素。columnCursor.setPosition（1）;执行{//打印行维值。String value =（（ValueCursor）rowCursor）.getCurrentString（）; print（getContext（）。getLocalValue（value）+“”）; //循环列。执行{//打印数据值。print（unitPriceValues.getCurrentValue（）+“”）; } while（columnCursor.next（））;的println（）; //将Cursor列重置为第一个元素。columnCursor.setPosition（1）; } while（rowCursor.next（））; cursorMngr.close（）;</pre><p>以下是<code class="codeph">unitPriceByMonth</code>查询指定的结果集中的值的交叉表视图。第一行将最右边的三列标记为具有产品值。第三行将第一列标记为具有月份值，然后使用该列的产品值标记最右边三列中的每一列。其余行在左列中具有月份值，然后具有指定月份和产品的单位的数据值。
                     </p><pre class="oac_no_warn" dir="ltr">产品---------------------------------月ENVY ABM ENVY EXE ENVY STD -------  - ------ -------- -------- 2001.01 3042.22 3223.28 2426.07 2001.04 3026.12 3107.65 2412.42 2001.07 2892.18 3155.91 2505.57 2001.10 2856.86 3105.53 2337.30 2002.01 2896.77 3008.95 2140.71 2002.04 2880.39 2953.96 2130.88 2002.07 2865.14 3002.34 2074.56 2002.10 2850.88 2943.96 1921.62</pre></div>
                  <!-- class="example" -->
                  <div class="example" id="GUID-2FF69CE4-873B-4CBF-B3B0-1376F114FEFB__I1006860">
                     <p class="titleinexample">示例9-8使用页面导航交叉表视图</p>
                     <p><a id="d26911e1043" class="indexterm-anchor"></a><a id="d26911e1047" class="indexterm-anchor"></a>此示例创建一个基于单位销售值的度量的<code class="codeph">Source</code> 。度量的维度是客户，产品，时间和渠道维度。维度的<code class="codeph">Source</code>对象表示维度值的选择。未显示这些<code class="codeph">Source</code>对象的创建。
                     </p>
                     <p>通过将维度选择连接到度量<code class="codeph">Source</code>而得到的查询表示由输出值指定的单位销售值。
                     </p>
                     <p>该示例为查询创建<code class="codeph">Cursor</code> ，然后将<code class="codeph">Cursor</code>发送到<code class="codeph">printAsCrosstab</code>方法，该方法在交叉表中打印<code class="codeph">Cursor</code>的值。该方法调用其他打印页面，列和行值的方法。
                     </p>
                     <p><code class="codeph">Cursor</code>的最快变化输出是产品的选择，其具有三个值（产品项ENVY ABM，ENVY EXE和ENVY STD）。产品值是交叉表的列标题。下一个变化最快的输出是客户的选择，它有三个值（客户COMP SERV TOK，COMP WHSE LON和COMP WHSE SD）。这三个值是行标题。页面尺寸是三个时间值（月份2000.01,2000.02和2000.03）和一个通道值（DIR，即直接销售渠道）的选择。
                     </p>
                     <p>该<code class="codeph">DataProvider</code>是<code class="codeph">dp</code> 。<code class="codeph">getLocalValue</code>方法从唯一维值获取本地值。
                     </p><pre class="oac_no_warn" dir="ltr">//在someMethod中。Source unitsForSelections = units.join（prodSel）.join（custSel）.join（timeSel）.join（chanSel）; //提交当前事务（代码未显示）。//为unitsForSelections创建一个Cursor。CursorManager cursorMngr = dp.createCursorManager（unitsForSelections）; CompoundCursor unitsForSelCursor =（CompoundCursor）cursorMngr.createCursor（）; //将Cursor发送到printAsCrosstab方法。printAsCrosstab（unitsForSelCursor）; cursorMngr.close（）; //未显示someMethod的其余代码。private void printAsCrosstab（CompoundCursor rootCursor）{List outputs = rootCursor.getOutputs（）; int nOutputs = outputs.size（）; //设置所有输出的初始位置。Iterator outputIter = outputs.iterator（）; while（outputIter.hasNext（））（（Cursor）outputIter.next（））。setPosition（1）; //最后一个输出变化最快;它代表列。//最后一个输出的下一个表示行。//所有其他输出都在页面上。游标colCursor =（光标）outputs.get（nOutputs  -  1）; Cursor rowCursor =（Cursor）outputs.get（nOutputs  -  2）; ArrayList pageCursors = new ArrayList（）; for（int i = 0; i &lt;nOutputs  -  2; i ++）{pageCursors.add（outputs.get（i））; } //获取具有数据值的基本ValueCursor。ValueCursor dataCursor = rootCursor.getValueCursor（）; //打印交叉表的页面。printPages（pageCursors，0，rowCursor，colCursor，dataCursor）; } //打印交叉表的页面。private void printPages（List pageCursors，int pageIndex，Cursor rowCursor，Cursor colCursor，ValueCursor dataCursor）{//获取此页面的光标。Cursor pageCursor =（Cursor）pageCursors.get（pageIndex）; //遍历此页面维度的值。do {//如果这是变化最快的页面尺寸，则打印页面。if（pageIndex == pageCursors.size（） -  1）{//打印页面尺寸的值。printPageHeadings（pageCursors）; //打印列标题。printColumnHeadings（colCursor）; //打印行。printRows（rowCursor，colCursor，dataCursor）; //打印几个空白行来分隔页面。的println（）;的println（）; } //如果这不是变化最快的页面，则递归到//下一个变化最快的维度。else {printPages（pageCursors，pageIndex + 1，rowCursor，colCursor，dataCursor）; while（pageCursor.next（））; //将此页面尺寸Cursor重置为其第一个元素。pageCursor.setPosition（1）; } //在每个页面上打印页面尺寸的值。private void printPageHeadings（List pageCursors）{//打印页面尺寸的值。Iterator pageIter = pageCursors.iterator（）; while（pageIter.hasNext（））{String value =（（ValueCursor）pageIter.next（））。getCurrentString（）;的println（的getLocalValue（值））; } println（）; } //在每个页面上打印列标题。private void printColumnHeadings（Cursor colCursor）{do {print（“\ t”）; String value =（（ValueCursor）colCursor）.getCurrentString（）;打印（的getLocalValue（值））; } while（colCursor.next（））;的println（）; colCursor.setPosition（1）; } //打印每页的行。private void printRows（Cursor rowCursor，Cursor colCursor，ValueCursor dataCursor）{//循环遍历行。执行{//打印行维值。String value =（（ValueCursor）rowCursor）.getCurrentString（）;打印（的getLocalValue（值））;打印（ “\ t” 的）; //循环列。执行{//打印数据值。打印（dataCursor.getCurrentValue（））;打印（ “\ t” 的）; } while（colCursor.next（））;的println（）; //将Cursor列重置为第一个元素。colCursor.setPosition（1）; } while（rowCursor.next（））; //将行Cursor重置为第一个元素。rowCursor.setPosition（1）; }</pre><p>该示例显示以下值，格式为交叉表。显示屏添加了页面，列和行标题，以标识尺寸的本地值。</p><pre class="oac_no_warn" dir="ltr">渠道DIR月2001.01产品------------------------------客户ENVY ABM ENVY EXE ENVY STD -------- ----- -------- -------- -------- COMP WHSE SD 0 0 1 COMP SERV TOK 2 4 2 COMP WHON LON 1 1 2 Channel DIR月2000.02产品------------------------------客户ENVY ABM ENVY EXE ENVY STD ----------- -  -------- -------- -------- COMP WHSE SD 1 1 1 COMP SERV TOK 5 6 6 COMP WHON LON 1 2 2 Channel DIR月2000.03产品 - -----------------------------客户ENVY ABM ENVY EXE ENVY STD -------------  - ------- -------- -------- COMP WHSE SD 0 2 2 COMP SERV TOK 2 0 2 COMP WHON LON 0 2 3</pre></div>
                  <!-- class="example" -->
               </div>
            </div><a id="OLAAP375"></a><a id="OLAAP374"></a><div class="props_rev_3"><a id="GUID-7CA568E5-D368-4C65-BA47-51D095DFA335" name="GUID-7CA568E5-D368-4C65-BA47-51D095DFA335"></a><h3 id="OLAAP-GUID-7CA568E5-D368-4C65-BA47-51D095DFA335" class="sect3"><span class="enumeration_section">9.3</span>指定游标的行为</h3>
               <div>
                  <div class="section">
                     <p><a id="d26911e1141" class="indexterm-anchor"></a>您可以指定<code class="codeph">Cursor</code>行为的以下方面。
                     </p>
                  </div>
                  <!-- class="section" -->
                  <div class="section">
                     <ul style="list-style-type:disc">
                        <li>
                           <p>一个的<span class="bold">读取大小</span> <code class="codeph">Cursor</code> ，这是结果的元件的数目设置的<code class="codeph">Cursor</code>检索在一个取操作。
                           </p>
                        </li>
                        <li>
                           <p>Oracle OLAP是否计算<code class="codeph">Cursor</code>的<span class="bold">范围</span> 。范围是<code class="codeph">Cursor</code>的位置总数。儿童的程度<code class="codeph">Cursor</code>一个的<code class="codeph">CompoundCursor</code>是相对于任何所述的较慢变化的输出<code class="codeph">CompoundCursor</code> 。
                           </p>
                        </li>
                        <li>
                           <p>Oracle OLAP是否计算子<code class="codeph">Cursor</code>的值开始或结束的父<code class="codeph">Cursor</code>中的位置。
                           </p>
                        </li>
                     </ul>
                     <p>若要指定<code class="codeph">Cursor</code>的行为，请使用为该<code class="codeph">Cursor</code>指定的<code class="codeph">CursorSpecification</code>方法。<code class="codeph">CursorSpecification</code>实现<code class="codeph">CursorInfoSpecification</code>接口。
                     </p>
                     <p>您可以通过调用<code class="codeph">DataProvider</code>的<code class="codeph">createCursorInfoSpecification</code>方法为<code class="codeph">Source</code>创建<code class="codeph">CursorSpecification</code> 。您可以使用<code class="codeph">CursorSpecification</code>方法来设置所需的特征。然后，通过调用<code class="codeph">DataProvider</code>的相应<code class="codeph">createCursorManager</code>方法创建<code class="codeph">CursorManager</code> 。
                     </p>
                     <div class="infoboxnote" id="GUID-7CA568E5-D368-4C65-BA47-51D095DFA335__GUID-625A646B-88A9-4DCD-9BA6-C47C0090C536">
                        <p class="notep1">注意：</p>
                        <p>在父指定范围或起始的计算或结束位置<code class="codeph">Cursor</code>一个孩子的电流值的<code class="codeph">Cursor</code>可以是一个非常昂贵的操作。计算可能需要相当多的时间和计算资源。您应该只在应用程序需要时指定这些计算。
                        </p>
                     </div>
                     <p>有关<code class="codeph">Source</code> ， <code class="codeph">Cursor</code>和<code class="codeph">CursorSpecification</code>对象的关系或获取大小，范围或<code class="codeph">Cursor</code>位置的概念的更多信息，请参阅<a href="understanding-cursor-classes-and-concepts.html#GUID-317FD4C8-9000-4A25-99FC-4D84D1894E0B">了解游标类和概念</a> 。
                     </p>
                     <p><a id="d26911e1266" class="indexterm-anchor"></a><a id="d26911e1270" class="indexterm-anchor"></a> <a href="retrieving-query-results.html#GUID-7CA568E5-D368-4C65-BA47-51D095DFA335__I1006988">例9-9</a>创建一个<code class="codeph">Source</code> ，创建一个<code class="codeph">CompoundCursorSpecification</code>的<code class="codeph">Source</code> ，然后获取子<code class="codeph">CursorSpecification</code>从顶级对象<code class="codeph">CompoundCursorSpecification</code> 。
                     </p>
                  </div>
                  <!-- class="section" -->
                  <div class="example" id="GUID-7CA568E5-D368-4C65-BA47-51D095DFA335__I1006988">
                     <p class="titleinexample">示例9-9获取源的CursorSpecification对象</p><pre class="oac_no_warn" dir="ltr">Source unitsForSelections = units.join（prodSel）.join（custSel）.join（timeSel）.join（chanSel）; //提交当前事务（代码未显示）。//为unitsForSelections创建CompoundCursorSpecification。CompoundCursorSpecification rootCursorSpec =（CompoundCursorSpecification）dp.createCursorInfoSpecification（unitsForSelections）; //获取基值的ValueCursorSpecification。ValueCursorSpecification baseValueSpec = rootCursorSpec.getValueCursorSpecification（）; //获取输出的ValueCursorSpecification对象。列表outputSpecs = rootCursorSpec.getOutputs（）; ValueCursorSpecification chanSelValCSpec =（ValueCursorSpecification）outputSpecs.get（0）; ValueCursorSpecification timeSelValCSpec =（ValueCursorSpecification）outputSpecs.get（1）; ValueCursorSpecification prodSelValCSpec =（ValueCursorSpecification）outputSpecs.get（2）; ValueCursorSpecification custSelValCSpec =（ValueCursorSpecification）outputSpecs.get（3）;</pre><p>获得<code class="codeph">CursorSpecification</code>对象后，可以使用它们的方法指定与它们对应的<code class="codeph">Cursor</code>对象的行为。
                     </p>
                  </div>
                  <!-- class="example" -->
               </div>
            </div><a id="OLAAP377"></a><a id="OLAAP378"></a><a id="OLAAP379"></a><a id="OLAAP376"></a><div class="props_rev_3"><a id="GUID-9FC27E5E-C901-4838-B157-23834A3244A9" name="GUID-9FC27E5E-C901-4838-B157-23834A3244A9"></a><h3 id="OLAAP-GUID-9FC27E5E-C901-4838-B157-23834A3244A9" class="sect3"><span class="enumeration_section">9.4</span>计算值的范围，起始和结束位置</h3>
               <div>
                  <p><a id="d26911e1344" class="indexterm-anchor"></a>要管理<code class="codeph">CompoundCursor</code>检索的结果集的显示，有时需要知道子<code class="codeph">Cursor</code>组件的范围。您可能还想知道子<code class="codeph">Cursor</code>的当前值在父<code class="codeph">CompoundCursor</code>开始位置。您可能想知道子<code class="codeph">Cursor</code>的当前值的<span class="bold">跨度</span> 。跨度是父的位置数<code class="codeph">Cursor</code>孩子的当前值<code class="codeph">Cursor</code>占据。您可以通过从结束位置减去值的起始位置并减去1来计算跨度。
                  </p>
                  <p>在获取<code class="codeph">Cursor</code>的范围或获取父<code class="codeph">Cursor</code>值的起始或结束位置之前，必须指定您希望Oracle OLAP计算范围或那些位置。要指定这些计算的性能，可以使用<code class="codeph">CursorSpecification</code>的<code class="codeph">Cursor</code> 。
                  </p>
                  <p><a id="d26911e1389" class="indexterm-anchor"></a><a id="d26911e1393" class="indexterm-anchor"></a> <a href="retrieving-query-results.html#GUID-9FC27E5E-C901-4838-B157-23834A3244A9__I1007004">例9-10</a>指定计算<code class="codeph">Cursor</code>的范围。该示例使用<a href="retrieving-query-results.html#GUID-7CA568E5-D368-4C65-BA47-51D095DFA335__I1006988">示例9-9中</a>的<code class="codeph">CompoundCursorSpecification</code> 。
                  </p>
                  <div class="example" id="GUID-9FC27E5E-C901-4838-B157-23834A3244A9__I1007004">
                     <p class="titleinexample">例9-10指定光标范围的计算</p><pre class="oac_no_warn" dir="ltr">rootCursorSpec.setExtentCalculationSpecified（真）;</pre><p>可以使用一个方法<code class="codeph">CursorSpecification</code>以确定是否<code class="codeph">CursorSpecification</code>指定的程度的计算<code class="codeph">Cursor</code>如在下面的例子。
                     </p><pre class="oac_no_warn" dir="ltr">boolean isSet = rootCursorSpec.isExtentCalculationSpecified（）;</pre><p><a id="d26911e1426" class="indexterm-anchor"></a> <a href="retrieving-query-results.html#GUID-9FC27E5E-C901-4838-B157-23834A3244A9__I1007024">实施例9-11</a>指定计算开始和结束一个孩子的电流值的位置<code class="codeph">Cursor</code>在父<code class="codeph">Cursor</code> 。该示例使用<a href="retrieving-query-results.html#GUID-7CA568E5-D368-4C65-BA47-51D095DFA335__I1006988">示例9-9中</a>的<code class="codeph">CompoundCursorSpecification</code> 。
                     </p>
                  </div>
                  <!-- class="example" -->
                  <div class="example" id="GUID-9FC27E5E-C901-4838-B157-23834A3244A9__I1007024">
                     <p class="titleinexample">示例9-11指定父级中起始位置和结束位置的计算</p><pre class="oac_no_warn" dir="ltr">//获取输出的CursorSpecification对象列表。//遍历列表，指定每个输出CursorSpecification的范围//的计算。Iterator iterOutputSpecs = rootCursorSpec.getOutputs（）。iterator（）; while（iterOutputSpecs.hasNext（））{ValueCursorSpecification valCursorSpec =（ValueCursorSpecification）iterOutputSpecs.next（）; valCursorSpec.setParentStartCalculationSpecified（真）; valCursorSpec.setParentEndCalculationSpecified（真）; }</pre><p>您可以使用<code class="codeph">CursorSpecification</code>方法来确定<code class="codeph">CursorSpecification</code>是否指定计算父<code class="codeph">Cursor</code> <code class="codeph">CursorSpecification</code> <code class="codeph">Cursor</code>的当前值的起始位置或结束位置，如下例所示。
                     </p><pre class="oac_no_warn" dir="ltr">Iterator iterOutputSpecs = rootCursorSpec.getOutputs（）。iterator（）; ValueCursorSpecification valCursorSpec =（ValueCursorSpecification）iterOutputSpecs.next（）; while（iterOutputSpecs.hasNext（））{if（valCursorSpec.isParentStartCalculationSpecified（））//执行某些操作。if（valCursorSpec.isParentEndCalculationSpecified（））//做点什么。valCursorSpec =（ValueCursorSpecification）iterOutputSpecs.next（）; }</pre><p><a href="retrieving-query-results.html#GUID-9FC27E5E-C901-4838-B157-23834A3244A9__I1007049">实施例9-12</a>确定在父位置的跨度<code class="codeph">CompoundCursor</code>一个孩子的电流值的<code class="codeph">Cursor</code>为两个的输出的<code class="codeph">CompoundCursor</code> 。该示例使用<a href="retrieving-query-results.html#GUID-2FF69CE4-873B-4CBF-B3B0-1376F114FEFB__I1006860">示例9-8中</a>的<code class="codeph">unitForSelections</code> <code class="codeph">Source</code> 。
                     </p>
                     <p>该示例获取时间和产品选择的当前值的起始位置和结束位置，然后计算父<code class="codeph">Cursor</code>中这些值的跨度。父级是根<code class="codeph">CompoundCursor</code> 。该<code class="codeph">DataProvider</code>是<code class="codeph">dp</code> 。
                     </p>
                  </div>
                  <!-- class="example" -->
                  <div class="example" id="GUID-9FC27E5E-C901-4838-B157-23834A3244A9__I1007049">
                     <p class="titleinexample">示例9-12计算值父级中位置的跨度</p><pre class="oac_no_warn" dir="ltr">Source unitsForSelections = units.join（prodSel）.join（custSel）.join（timeSel）.join（chanSel）; //提交当前事务（代码未显示）。//为unitsForSelections创建CompoundCursorSpecification。CompoundCursorSpecification rootCursorSpec =（CompoundCursorSpecification）dp.createCursorInfoSpecification（unitsForSelections）; //获取输出的CursorSpecification对象。列表outputSpecs = rootCursorSpec.getOutputs（）; ValueCursorSpecification timeSelValCSpec =（ValueCursorSpecification）outputSpecs.get（1）; //输出时间。ValueCursorSpecification prodSelValCSpec =（ValueCursorSpecification）outputSpecs.get（3）; //产品输出//指定起始位置和结束位置的计算。timeSelValCSpec.setParentStartCalculationSpecified（真）; timeSelValCSpec.setParentEndCalculationSpecified（真）; prodSelValCSpec.setParentStartCalculationSpecified（真）; prodSelValCSpec.setParentEndCalculationSpecified（真）; //创建CursorManager和Cursor。CursorManager cursorMngr = dp.createCursorManager（unitsForSelections，100，rootCursorSpec）; CompoundCursor rootCursor =（CompoundCursor）cursorMngr.createCursor（）; //获取子Cursor对象。ValueCursor baseValCursor = cursor.getValueCursor（）; List outputs = rootCursor.getOutputs（）; ValueCursor chanSelVals =（ValueCursor）outputs.get（0）; ValueCursor timeSelVals =（ValueCursor）outputs.get（1）; ValueCursor custSelVals =（ValueCursor）outputs.get（2）; ValueCursor prodSelVals =（ValueCursor）outputs.get（3）; //设置根CompoundCursor的位置。rootCursor.setPosition（15）; //获取当前位置的值并确定时间和产品输出值的范围。print（chanSelVals.getCurrentValue（）+“，”）; print（timeSelVals.getCurrentValue（）+“，\ n”）; print（custSelVals.getCurrentValue（）+“，”）; print（prodSelVals.getCurrentValue（）+“，”）;打印（baseValCursor.getCurrentValue（））;的println（）; //确定两个变化最快的输出的值的跨度。长跨度; span =（prodSelVals.getParentEnd（） -  prodSelVals.getParentStart（））+ 1）; println（“\ n”当前位置的“+ prodSelVals.getCurrentValue（）+”的范围是“+ span +”。“）span =（timeSelVals.getParentEnd（） -  timeSelVals.getParentStart（））+ 1）; println（“当前位置的”+ spanSelVals.getCurrentValue（）+“的范围是”+ span +“。”）cursorMngr.close（）;</pre><p>此示例显示以下文本。</p><pre class="oac_no_warn" dir="ltr">CHANNEL_PRIMARY :: CHANNEL :: DIR，CALENDAR_YEAR :: MONTH :: 2000.02，SHIPMENTS :: SHIP_TO :: COMP SERV TOK，PRODUCT_PRIMARY :: ITEM :: ENVY STD，6.0当前PRODUCT_PRIMARY :: ITEM :: ENVY STD的范围位置是1。CALENDAR_YEAR :: MONTH :: 2000.02在当前位置的跨度为9。</pre></div>
                  <!-- class="example" -->
               </div>
            </div><a id="OLAAP381"></a><a id="OLAAP380"></a><div class="props_rev_3"><a id="GUID-BA2A974A-FF8F-49A1-8FF7-489E6BF5A9A5" name="GUID-BA2A974A-FF8F-49A1-8FF7-489E6BF5A9A5"></a><h3 id="OLAAP-GUID-BA2A974A-FF8F-49A1-8FF7-489E6BF5A9A5" class="sect3"><span class="enumeration_section">9.5</span>指定获取大小</h3>
               <div>
                  <div class="section">
                     <p>在一次提取操作期间，Oracle OLAP发送到客户端应用程序的<code class="codeph">Cursor</code>元素的数量取决于为该<code class="codeph">Cursor</code>指定的提取大小。默认提取大小为100。要更改提取大小，可以在<code class="codeph">Source</code> <code class="codeph">Cursor</code>上设置提取大小。
                     </p>
                  </div>
                  <!-- class="section" -->
                  <div class="example" id="GUID-BA2A974A-FF8F-49A1-8FF7-489E6BF5A9A5__CHDGHJJC">
                     <p class="titleinexample">示例9-13指定获取大小</p>
                     <p><a id="d26911e1563" class="indexterm-anchor"></a><a id="d26911e1567" class="indexterm-anchor"></a>此示例从<a href="retrieving-query-results.html#GUID-7CA568E5-D368-4C65-BA47-51D095DFA335__I1006988">示例9-9中</a>的<code class="codeph">CompoundCursorSpecification</code>获取默认提取大小。该示例创建一个<code class="codeph">Cursor</code>并在其上设置不同的提取大小，然后获取<code class="codeph">Cursor</code>的提取大小。该<code class="codeph">DataProvider</code>是<code class="codeph">dp</code> 。
                     </p><pre class="oac_no_warn" dir="ltr">println（“默认提取大小为”+ rootCursorSpec.getDefaultFetchSize（）+“。”）; Source source = rootCursorSpec.getSource（）; CursorManager cursorMngr = dp.createCursorManager（source）;游标rootCursor = cursorMngr.createCursor（）; rootCursor.setFetchSize（10）; println（“获取大小现在是”+ rootCursor.getFetchSize（））+“。”;</pre><p>该示例显示以下文本。</p><pre class="oac_no_warn" dir="ltr">默认提取大小为100。获取大小现在为10。</pre></div>
                  <!-- class="example" -->
               </div>
            </div>
         </div>
      </article>
   </body>
</html>