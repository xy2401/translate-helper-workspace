<html lang="en-us" dir="ltr" xml:lang="en-us">
   <head>
      <meta http-equiv="Content-Type" content="text/html; charset=utf-8"></meta>
      <meta name="viewport" content="width=device-width, initial-scale=1"></meta>
      <meta http-equiv="X-UA-Compatible" content="IE=edge"></meta>
      <title>JDBC中的Java Streams</title>
      <meta property="og:site_name" content="Oracle Help Center"></meta>
      <meta property="og:title" content="JDBC Developer&#39;s Guide"></meta>
      <meta property="og:description" content=""></meta>
      <link rel="stylesheet" href="/sp_common/book-template/ohc-book-template/css/book.css"></link>
      <link rel="shortcut icon" href="/sp_common/book-template/ohc-common/img/favicon.ico"></link>
      <meta name="application-name" content="JDBC Developer&#39;s Guide"></meta>
      <meta name="generator" content="DITA Open Toolkit version 1.8.5 (Mode = doc)"></meta>
      <meta name="plugin" content="SP_docbuilder HTML plugin release 18.2.2"></meta>
      <link rel="alternate" href="jdbc-developers-guide.pdf" title="PDF File" type="application/pdf"></link>
      <meta name="robots" content="all"></meta>
      <link rel="schema.dcterms" href="http://purl.org/dc/terms/"></link>
      <meta name="dcterms.created" content="2019-02-13T13:20:37-08:00"></meta>
      <meta name="dcterms.title" content="JDBC Developer&#39;s Guide"></meta>
      <meta name="dcterms.dateCopyrighted" content="1999, 2019"></meta>
      <meta name="dcterms.category" content="database"></meta>
      <meta name="dcterms.identifier" content="E96471-02"></meta>
      
      <meta name="dcterms.product" content="en/database/oracle/oracle-database/19"></meta>
      
      <link rel="prev" href="accessing-and-manipulating-Oracle-data.html" title="Previous" type="text/html"></link>
      <link rel="next" href="Oracle-object-types.html" title="Next" type="text/html"></link>
      <script>
        document.write('<style type="text/css">');
        document.write('body > .noscript, body > .noscript ~ * { visibility: hidden; }');
        document.write('</style>');
     </script>
      <script src="/sp_common/book-template/requirejs/require.js" data-main="/sp_common/book-template/ohc-book-template/js/book-config"></script>
      <script>
            if (window.require === undefined) {
                document.write('<script data-main="sp_common/book-template/ohc-book-template/js/book-config" src="sp_common/book-template/requirejs/require.js"><\/script>');
                document.write('<link href="sp_common/book-template/ohc-book-template/css/book.css" rel="stylesheet"/>');
            }
        </script>
      <script type="application/json" id="ssot-metadata">{"primary":{"category":{"short_name":"database","element_name":"Database","display_in_url":true},"suite":{"short_name":"oracle","element_name":"Oracle","display_in_url":true},"product_group":{"short_name":"not-applicable","element_name":"Not applicable","display_in_url":false},"product":{"short_name":"oracle-database","element_name":"Oracle Database","display_in_url":true},"release":{"short_name":"19","element_name":"Release 19","display_in_url":true}}}</script>
      
    <meta name="dcterms.isVersionOf" content="JJDBC"></meta>
    <meta name="dcterms.release" content="Release 19"></meta>
  </head>
   <body dir="ltr">
      <div class="noscript alert alert-danger text-center" role="alert">
         <a href="accessing-and-manipulating-Oracle-data.html" class="pull-left"><span class="glyphicon glyphicon-chevron-left" aria-hidden="true"></span>上一页</a> <a href="Oracle-object-types.html" class="pull-right">下一页<span class="glyphicon glyphicon-chevron-right" aria-hidden="true"></span></a> <span class="fa fa-exclamation-triangle" aria-hidden="true"></span>必须启用JavaScript才能正确显示此内容</div>
      <article>
         <header>
            <ol class="breadcrumb" vocab="http://schema.org/" typeof="BreadcrumbList">
               <li property="itemListElement" typeof="ListItem"><a href="index.html" property="item" typeof="WebPage"><span property="name">JDBC开发人员指南</span></a></li>
               <li property="itemListElement" typeof="ListItem"><a href="data-access-and-manipulation.html" property="item" typeof="WebPage"><span property="name">数据访问和操作</span></a></li>
               <li class="active" property="itemListElement" typeof="ListItem">JDBC中的Java Streams</li>
            </ol>
            <a id="GUID-B7ACBCEB-367D-4B39-A9E2-B0EAE6D475BC" name="GUID-B7ACBCEB-367D-4B39-A9E2-B0EAE6D475BC"></a><a id="JJDBC28409"></a>
            
            <h2 id="JJDBC-GUID-B7ACBCEB-367D-4B39-A9E2-B0EAE6D475BC" class="sect2"><span class="enumeration_chapter">12</span> JDBC中的Java Streams</h2>
         </header>
         <div class="ind">
            <div>
               <p>这个<a id="d49423e22" class="indexterm-anchor"></a><a id="d49423e26" class="indexterm-anchor"></a>本章介绍了Oracle Java数据库连接（JDBC）驱动程序如何处理多种数据类型的Java流。通过数据流，您可以读取最多2千兆字节（GB）的<code class="codeph">LONG</code>列数据。
               </p>
               <p>本章包含以下主题：</p>
               <ul style="list-style-type:disc">
                  <li>
                     <p><a href="Java-streams-in-JDBC.html#GUID-F65AB98A-00B9-4B23-972F-F5E4200B4C10">Java Streams概述</a></p>
                  </li>
                  <li>
                     <p><a href="Java-streams-in-JDBC.html#GUID-E9EBBAB9-BE2D-491F-BB36-A19911B4A9EB">关于Streaming LONG或LONG RAW Columns</a></p>
                  </li>
                  <li>
                     <p><a href="Java-streams-in-JDBC.html#GUID-6AE64DE5-A05B-43C5-894D-4260BC731DDA">关于Streaming CHAR_ VARCHAR_或RAW列</a></p>
                  </li>
                  <li>
                     <p><a href="Java-streams-in-JDBC.html#GUID-9DFFE7D3-C173-4D9D-8F0E-746CEAA324E5">关于流式传输LOB和外部文件</a></p>
                  </li>
                  <li>
                     <p><a href="Java-streams-in-JDBC.html#GUID-2A5CD25F-E34E-49E3-BD78-A27B50A18A6B">数据流和多列之间的关系</a></p>
                  </li>
                  <li>
                     <p><a href="Java-streams-in-JDBC.html#GUID-D2A59D17-639C-4122-87F9-A36CEDEE6D3D">流和行预取之间的关系</a></p>
                  </li>
                  <li>
                     <p><a href="Java-streams-in-JDBC.html#GUID-AF94E206-56E2-452C-B88A-C7EAD2AAF05D">关闭流</a></p>
                  </li>
                  <li>
                     <p><a href="Java-streams-in-JDBC.html#GUID-16F826CB-4141-4451-9CAC-F3C8205A80BD">关于流的注意事项和注意事项</a></p>
                  </li>
               </ul>
            </div><a id="JJDBC28410"></a><div class="props_rev_3"><a id="GUID-F65AB98A-00B9-4B23-972F-F5E4200B4C10" name="GUID-F65AB98A-00B9-4B23-972F-F5E4200B4C10"></a><h3 id="JJDBC-GUID-F65AB98A-00B9-4B23-972F-F5E4200B4C10" class="sect3"><span class="enumeration_section">12.1</span> Java Streams概述</h3>
               <div>
                  <div class="section">
                     <p>Oracle JDBC驱动程序支持在服务器和客户端之间以任一方向操纵数据流。驱动程序支持所有流转换：二进制，ASCII和Unicode。以下是每种类型的流的简要说明：</p>
                     <ul style="list-style-type:disc">
                        <li>
                           <p>二进制</p>
                           <p>用于<code class="codeph">RAW</code>字节数据，对应于<code class="codeph">getBinaryStream</code>方法</p>
                        </li>
                        <li>
                           <p>ASCII</p>
                           <p>用于ISO-Latin-1编码中的ASCII字节，对应于<code class="codeph">getAsciiStream</code>方法</p>
                        </li>
                        <li>
                           <p>统一</p>
                           <p>用于<code class="codeph">UTF-16</code>编码的Unicode字节，对应于<code class="codeph">getUnicodeStream</code>方法</p>
                        </li>
                     </ul>
                     <p><code class="codeph">getBinaryStream</code> ， <code class="codeph">getAsciiStream</code>和<code class="codeph">getUnicodeStream</code>方法返回<code class="codeph">InputStream</code>对象中的数据字节。
                     </p>
                     <div class="infoboxnote" id="GUID-F65AB98A-00B9-4B23-972F-F5E4200B4C10__GUID-92D97B1B-7B5B-4422-ACD5-2A32D99066DD">
                        <p class="notep1">注意：</p>
                        <p>从Oracle Database 12 <span class="italic">c</span>第1版（12.1）开始，不推荐使用<code class="codeph">CONNECTION_PROPERTY_STREAM_CHUNK_SIZE</code> ，驱动程序不会在内部使用它来设置流块大小。
                        </p>
                     </div>
                     <div class="infoboxnotealso" id="GUID-F65AB98A-00B9-4B23-972F-F5E4200B4C10__GUID-83DE62F8-6226-41D0-A8E8-5CB4EA32A9C1">
                        <p class="notep1">也可以看看：</p>
                        <p><a href="LOBs-and-BFiles.html#GUID-401E10DB-16B5-41C9-965E-E5F286F01E4C">使用LOB和BFILE</a></p>
                     </div>
                  </div>
                  <!-- class="section" -->
               </div>
            </div><a id="JJDBC28411"></a><div class="props_rev_3"><a id="GUID-E9EBBAB9-BE2D-491F-BB36-A19911B4A9EB" name="GUID-E9EBBAB9-BE2D-491F-BB36-A19911B4A9EB"></a><h3 id="JJDBC-GUID-E9EBBAB9-BE2D-491F-BB36-A19911B4A9EB" class="sect3"><span class="enumeration_section">12.2</span>关于Streaming Long或LONG RAW Columns</h3>
               <div>
                  <p>本节包括以下主题：</p>
                  <ul style="list-style-type:disc">
                     <li>
                        <p><a href="Java-streams-in-JDBC.html#GUID-E7D523A2-0B17-4714-9ACC-B45160C82C65">Streaming LONG或LONG RAW Columns概述</a></p>
                     </li>
                     <li>
                        <p><a href="Java-streams-in-JDBC.html#GUID-5572A63D-A5AC-4ABC-9028-BDB7A2F9177A">长期数据转换</a></p>
                     </li>
                     <li>
                        <p><a href="Java-streams-in-JDBC.html#GUID-D4437DEC-25C3-4D47-BF1F-D91B19DCC69E">长期数据转换</a></p>
                     </li>
                     <li>
                        <p><a href="Java-streams-in-JDBC.html#GUID-5CAF21D3-84EE-4F5E-B133-2BD22F5EC98A">示例：Streaming LONG RAW Data</a></p>
                     </li>
                     <li>
                        <p><a href="Java-streams-in-JDBC.html#GUID-E1C93335-F7D4-4122-A8A3-932D3349DFD4">关于避免长期或长期流媒体播放</a></p>
                     </li>
                  </ul>
               </div>
               <div class="props_rev_3"><a id="GUID-E7D523A2-0B17-4714-9ACC-B45160C82C65" name="GUID-E7D523A2-0B17-4714-9ACC-B45160C82C65"></a><h4 id="JJDBC-GUID-E7D523A2-0B17-4714-9ACC-B45160C82C65" class="sect4"><span class="enumeration_section">12.2.1</span>流式传输长或长列的概述</h4>
                  <div>
                     <p><a id="d49423e231" class="indexterm-anchor"></a><a id="d49423e235" class="indexterm-anchor"></a>当查询选择一个或多个<code class="codeph">LONG</code>或<code class="codeph">LONG</code> <code class="codeph">RAW</code>列时，JDBC驱动程序会以流模式将这些列传输到客户端。在流模式下，JDBC驱动程序不会从<code class="codeph">LONG</code>或<code class="codeph">LONG RAW</code>列的网络中读取列数据，直到需要时为止。列数据保留在网络通信通道中，直到您的代码调用<code class="codeph">getXXX</code>方法读取列数据。即使在调用之后，也只是根据需要读取列数据以填充getXXX调用的返回值。由于列数据保留在通信信道中，因此流模式会干扰连接的所有其他使用。除读取列数据外，对连接的任何使用都将丢弃通道中的列数据。虽然流模式可以有效利用内存并最大限度地减少网络往返，但它会干扰许多其他数据库操作。
                     </p>
                     <div class="infoboxnote" id="GUID-E7D523A2-0B17-4714-9ACC-B45160C82C65__GUID-29DD9AE0-D790-436E-AA1F-2F4901D93214">
                        <p class="notep1">注意：</p>
                        <p>Oracle建议避免使用<code class="codeph">LONG</code>和<code class="codeph">LONG RAW</code>列。请改用<code class="codeph">LOB</code> 。
                        </p>
                     </div>
                     <p>要访问的数据<code class="codeph">LONG</code>列，就可以得到该列作为Java <code class="codeph">InputStream</code>对象，并使用<code class="codeph">read</code>的方法<code class="codeph">InputStream</code>对象。或者，您可以将数据作为<code class="codeph">String</code>或<code class="codeph">byte</code>数组获取。在这种情况下，驱动程序将为您执行流式处理。
                     </p>
                     <p>您可以使用三种流类型中的任何一种获得<code class="codeph">LONG</code>和<code class="codeph">LONG</code> <code class="codeph">RAW</code>数据。驱动程序会根据数据库和驱动程序的字符集为您执行转换。
                     </p>
                     <div class="infoboxnote" id="GUID-E7D523A2-0B17-4714-9ACC-B45160C82C65__GUID-BBB9E177-8D43-4B67-B7D3-E09667CF3486">
                        <p class="notep1">注意：</p>
                        <p>不要创建包含<code class="codeph">LONG</code>列的表。请改用大对象（LOB）列， <code class="codeph">CLOB</code> ， <code class="codeph">NCLOB</code>和<code class="codeph">BLOB</code> 。仅支持<code class="codeph">LONG</code>列以实现向后兼容性。Oracle建议您将现有的<code class="codeph">LONG</code>列转换为<code class="codeph">LOB</code>列。与<code class="codeph">LONG</code>列相比， <code class="codeph">LOB</code>列的限制要少得多。
                        </p>
                     </div>
                  </div>
               </div><a id="JJDBC28412"></a><div class="props_rev_3"><a id="GUID-5572A63D-A5AC-4ABC-9028-BDB7A2F9177A" name="GUID-5572A63D-A5AC-4ABC-9028-BDB7A2F9177A"></a><h4 id="JJDBC-GUID-5572A63D-A5AC-4ABC-9028-BDB7A2F9177A" class="sect4"><span class="enumeration_section">12.2.2</span>长期数据转换</h4>
                  <div>
                     <div class="section">
                        <p><a id="d49423e358" class="indexterm-anchor"></a><a id="d49423e362" class="indexterm-anchor"></a>对<code class="codeph">getBinaryStream</code>的调用返回<code class="codeph">RAW</code>数据。对<code class="codeph">getAsciiStream</code>的调用将<code class="codeph">RAW</code>数据转换为十六进制并返回ASCII表示。对<code class="codeph">getUnicodeStream</code>的调用将<code class="codeph">RAW</code>数据转换为十六进制并返回Unicode字符。
                        </p>
                     </div>
                     <!-- class="section" -->
                  </div>
               </div><a id="JJDBC28414"></a><a id="JJDBC28413"></a><div class="props_rev_3"><a id="GUID-D4437DEC-25C3-4D47-BF1F-D91B19DCC69E" name="GUID-D4437DEC-25C3-4D47-BF1F-D91B19DCC69E"></a><h4 id="JJDBC-GUID-D4437DEC-25C3-4D47-BF1F-D91B19DCC69E" class="sect4"><span class="enumeration_section">12.2.3</span>长数据转换</h4>
                  <div>
                     <div class="section">
                        <p><a id="d49423e412" class="indexterm-anchor"></a><a id="d49423e416" class="indexterm-anchor"></a>当您使用<code class="codeph">getAsciiStream</code>获取<code class="codeph">LONG</code>数据时，驱动程序会假定数据库中的基础数据使用<code class="codeph">US7ASCII</code>或<code class="codeph">WE8ISO8859P1</code>字符集。如果假设为真，则驱动程序返回与ASCII字符对应的字节。如果数据库未使用<code class="codeph">US7ASCII</code>或<code class="codeph">WE8ISO8859P1</code>字符集，则对<code class="codeph">getAsciiStream</code>的调用将返回无意义的信息。
                        </p>
                        <p>当您使用<code class="codeph">getUnicodeStream</code>获取<code class="codeph">LONG</code>数据时，您将获得<code class="codeph">UTF-16</code>编码的Unicode字符流。这适用于Oracle支持的所有基础数据库字符集。
                        </p>
                        <p>当您使用<code class="codeph">getBinaryStream</code>获取<code class="codeph">LONG</code>数据时，有两种可能的情况：</p>
                        <ul style="list-style-type:disc">
                           <li>
                              <p>如果驱动程序是JDBC OCI且<span class="italic">客户端</span>字符集<span class="italic">不是</span> <code class="codeph">US7ASCII</code>或<code class="codeph">WE8ISO8859P1</code> ，则对<code class="codeph">getBinaryStream</code>的调用将返回<code class="codeph">UTF-8</code> 。如果<span class="italic">客户端</span>字符集是<code class="codeph">US7ASCII</code>或<code class="codeph">WE8ISO8859P1</code> ，则该调用返回<code class="codeph">US7ASCII</code>字节流。
                              </p>
                           </li>
                           <li>
                              <p>如果驱动程序是JDBC Thin且<span class="italic">数据库</span>字符集<span class="italic">不是</span> <code class="codeph">US7ASCII</code>或<code class="codeph">WE8ISO8859P1</code> ，则对<code class="codeph">getBinaryStream</code>的调用将返回<code class="codeph">UTF-8</code> 。如果服务器端字符集是<code class="codeph">US7ASCII</code>或<code class="codeph">WE8ISO8859P1</code> ，则该调用返回<code class="codeph">US7ASCII</code>字节流。
                              </p>
                           </li>
                        </ul>
                        <div class="infoboxnote" id="GUID-D4437DEC-25C3-4D47-BF1F-D91B19DCC69E__GUID-77B2A5F6-8634-422C-89E1-2708D1202504">
                           <p class="notep1">注意：</p>
                           <p>接收<code class="codeph">LONG</code>或<code class="codeph">LONG</code> <code class="codeph">RAW</code>列作为流要求您特别注意从数据库中检索列的顺序。
                           </p>
                        </div>
                        <p>下表总结了每种流类型的<code class="codeph">LONG</code>和<code class="codeph">LONG</code> <code class="codeph">RAW</code>数据转换。
                        </p>
                     </div>
                     <!-- class="section" -->
                     <div class="tblformal" id="GUID-D4437DEC-25C3-4D47-BF1F-D91B19DCC69E__G1028088">
                        <p class="titleintable">表12-1长期和长期原始数据转换</p>
                        <table cellpadding="4" cellspacing="0" class="Formal" title="长期和长期数据转换" width="100%" border="1" summary="table" frame="hsides" rules="rows">
                           <thead>
                              <tr align="left" valign="top">
                                 <th align="left" valign="bottom" width="11%" id="d49423e563">数据类型</th>
                                 <th align="left" valign="bottom" width="38%" id="d49423e566">BinaryStream</th>
                                 <th align="left" valign="bottom" width="32%" id="d49423e569">AsciiStream</th>
                                 <th align="left" valign="bottom" width="18%" id="d49423e572">UnicodeStream</th>
                              </tr>
                           </thead>
                           <tbody>
                              <tr align="left" valign="top">
                                 <td align="left" valign="top" width="11%" id="d49423e577" headers="d49423e563 ">
                                    <p><span class="bold">长</span></p>
                                 </td>
                                 <td align="left" valign="top" width="38%" headers="d49423e577 d49423e566 ">
                                    <p>表示Unicode <code class="codeph">UTF-8</code>中字符的字节。如果数据库字符集是<code class="codeph">US7ASCII</code>或<code class="codeph">WE8ISO8859P1</code> ，则字节可以表示<code class="codeph">US7ASCII</code>或<code class="codeph">WE8ISO8859P1</code>的字符。
                                    </p>
                                 </td>
                                 <td align="left" valign="top" width="32%" headers="d49423e577 d49423e569 ">
                                    <p>表示ISO-Latin-1（ <code class="codeph">WE8ISO8859P1</code> ）编码中字符的字节</p>
                                 </td>
                                 <td align="left" valign="top" width="18%" headers="d49423e577 d49423e572 ">
                                    <p>表示Unicode <code class="codeph">UTF-16</code>编码字符的字节</p>
                                 </td>
                              </tr>
                              <tr align="left" valign="top">
                                 <td align="left" valign="top" width="11%" id="d49423e612" headers="d49423e563 ">
                                    <p><span class="bold">LONG RAW</span></p>
                                 </td>
                                 <td align="left" valign="top" width="38%" headers="d49423e612 d49423e566 ">
                                    <p>数据不变</p>
                                 </td>
                                 <td align="left" valign="top" width="32%" headers="d49423e612 d49423e569 ">
                                    <p>十六进制字节的ASCII表示</p>
                                 </td>
                                 <td align="left" valign="top" width="18%" headers="d49423e612 d49423e572 ">
                                    <p>十六进制字节的Unicode表示</p>
                                 </td>
                              </tr>
                           </tbody>
                        </table>
                     </div>
                     <!-- class="inftblhruleinformal" -->
                  </div>
                  <div>
                     <div class="relinfo">
                        <p><strong>相关话题</strong></p>
                        <ul>
                           <li><a href="globalization-support.html#GUID-CE02B998-DD6A-46FC-8ECF-AD2413F09A97">全球化支持</a></li>
                           <li><a href="Java-streams-in-JDBC.html#GUID-2A5CD25F-E34E-49E3-BD78-A27B50A18A6B">数据流和多列之间的关系</a></li>
                        </ul>
                     </div>
                  </div>
                  
               </div><a id="JJDBC28416"></a><a id="JJDBC28417"></a><a id="JJDBC28415"></a><div class="props_rev_3"><a id="GUID-5CAF21D3-84EE-4F5E-B133-2BD22F5EC98A" name="GUID-5CAF21D3-84EE-4F5E-B133-2BD22F5EC98A"></a><h4 id="JJDBC-GUID-5CAF21D3-84EE-4F5E-B133-2BD22F5EC98A" class="sect4"><span class="enumeration_section">12.2.4</span>示例：流式传输长期数据</h4>
                  <div>
                     <div class="section">
                        <p><code class="codeph">get</code> <span class="italic"><code class="codeph">XXX</code></span> <code class="codeph">Stream</code>方法的一个特性是它使您能够以递增方式获取数据。相反， <code class="codeph">getBytes</code>在一次调用中获取所有数据。<a id="d49423e678" class="indexterm-anchor"></a>本节包含两个获取二进制数据流的示例。第一个版本使用<code class="codeph">getBinaryStream</code>方法获取<code class="codeph">LONG</code> <code class="codeph">RAW</code>数据，第二个版本使用<code class="codeph">getBytes</code>方法。
                        </p>
                     </div>
                     <!-- class="section" -->
                     <div class="section">
                        <p class="subhead3" id="GUID-5CAF21D3-84EE-4F5E-B133-2BD22F5EC98A__GUID-5C17073E-929D-4547-9F9F-57BE1F661D96">使用getBinaryStream获取LONG RAW数据列</p>
                     </div>
                     <!-- class="section" -->
                     <div class="section">
                        <p>这个<a id="d49423e702" class="indexterm-anchor"></a>示例将<code class="codeph">LONG</code> <code class="codeph">RAW</code>列的内容写入本地文件系统上的文件。在这种情况下，驱动程序以递增方式获取数据。
                        </p>
                        <p>以下代码创建表，该表存储与名称LESLIE关联的<code class="codeph">LONG</code> <code class="codeph">RAW</code>数据列：</p><pre class="oac_no_warn" dir="ltr">-  SQL代码：create table streamexample（NAME varchar2（256），GIFDATA long raw）;插入到streamexample值（'LESLIE'，'00010203040506070809'）;</pre><p>以下Java代码段将<code class="codeph">LONG</code> <code class="codeph">RAW</code>列中的数据写入名为<code class="codeph">leslie.gif:</code>的文件中<code class="codeph">leslie.gif:</code></p><pre class="oac_no_warn" dir="ltr">ResultSet rset = stmt.executeQuery（“从streamexample中选择GIFDATA，其中NAME ='LESLIE'”）; //获取第一行if（rset.next（））{//将GIF数据作为从Oracle传输到客户端的流InputStream gif_data = rset.getBinaryStream（1）;尝试{FileOutputStream file = null; file = new FileOutputStream（“leslie.gif”）; int chunk; while（（chunk = gif_data.read（））！= -1）file.write（chunk）; } catch（Exception e）{String err = e.toString（）;的System.out.println（ERR）; } finally {if file！= null（）file.close（）; }}</pre><p>在此示例中，对<code class="codeph">getBinaryStream</code>的调用返回的<code class="codeph">InputStream</code>对象直接从数据库连接读取数据。
                        </p>
                     </div>
                     <!-- class="section" -->
                     <div class="section">
                        <p class="subhead3" id="GUID-5CAF21D3-84EE-4F5E-B133-2BD22F5EC98A__GUID-20DE26E4-F3D7-43BA-978E-D8739BA83085">使用getBytes获取LONG RAW数据列</p>
                     </div>
                     <!-- class="section" -->
                     <div class="section">
                        <p>这个<a id="d49423e747" class="indexterm-anchor"></a>示例使用<code class="codeph">getBytes</code>而不是<code class="codeph">getBinaryStream</code>获取<code class="codeph">GIFDATA</code>列的内容。在这种情况下，驱动程序在一次调用中获取所有数据并将其存储在字节数组中。代码段如下：</p><pre class="oac_no_warn" dir="ltr">ResultSet rset2 = stmt.executeQuery（“从streamexample中选择GIFDATA，其中NAME ='LESLIE'”）; //获取第一行if（rset2.next（））{//将GIF数据作为从Oracle传输到客户端字节的流[] bytes = rset2.getBytes（1）;尝试{FileOutputStream file = null; file = new FileOutputStream（“leslie2.gif”）; file.write（字节）; } catch（Exception e）{String err = e.toString（）;的System.out.println（ERR）; } finally {if file！= null（）file.close（）; }}</pre><p>由于<code class="codeph">LONG RAW</code>列最多可包含2千兆字节的数据，因此<code class="codeph">getBytes</code>示例可以使用比<code class="codeph">getBinaryStream</code>示例更多的内存。如果您不知道<code class="codeph">LONG</code>或<code class="codeph">LONG RAW</code>列中数据的最大大小，请使用流。
                        </p>
                     </div>
                     <!-- class="section" -->
                  </div>
               </div><a id="JJDBC28418"></a><div class="props_rev_3"><a id="GUID-E1C93335-F7D4-4122-A8A3-932D3349DFD4" name="GUID-E1C93335-F7D4-4122-A8A3-932D3349DFD4"></a><h4 id="JJDBC-GUID-E1C93335-F7D4-4122-A8A3-932D3349DFD4" class="sect4"><span class="enumeration_section">12.2.5</span>关于避免长时间或长时间的流式传输</h4>
                  <div>
                     <div class="section">
                        <div class="infoboxnote" id="GUID-E1C93335-F7D4-4122-A8A3-932D3349DFD4__GUID-59920A95-6CAC-48A2-9F70-22A52174EEA6">
                           <p class="notep1">注意：</p>
                           <p>从Oracle Database 12 <span class="italic">c</span>第1版（12.1）开始，不推荐使用此方法。
                           </p>
                        </div>
                        <p><a id="d49423e808" class="indexterm-anchor"></a> JDBC驱动程序自动流式传输任何<code class="codeph">LONG</code>和<code class="codeph">LONG RAW</code>列。但是，您可能希望避免数据流。例如，如果您有一个非常小的<code class="codeph">LONG</code>列，那么您可能希望避免以递增方式返回数据，而是在一次调用中返回数据。
                        </p>
                        <p>要避免流式传输，请使用<code class="codeph">defineColumnType</code>方法重新定义<code class="codeph">LONG</code>列的类型。例如，如果将<code class="codeph">LONG</code>或<code class="codeph">LONG RAW</code>列重新定义为<code class="codeph">VARCHAR</code>或<code class="codeph">VARBINARY</code>类型，则驱动程序将不会自动流式传输数据。
                        </p>
                        <p>如果使用<code class="codeph">defineColumnType</code>重新定义列类型，则必须在查询中声明列的类型。如果您没有声明列的类型，那么<code class="codeph">executeQuery</code>将失败。此外，您必须将<code class="codeph">Statement</code>对象<code class="codeph">oracle.jdbc.为<code class="codeph">oracle.jdbc.OracleStatement</code> 。
                        </p>
                        <p>另外一个好处是，使用<code class="codeph">defineColumnType</code>可以在运行查询时为OCI驱动程序保存数据库往返。如果没有<code class="codeph">defineColumnType</code> ，这些JDBC驱动程序必须请求列类型的数据类型。JDBC Thin驱动程序不会从<code class="codeph">defineColumnType</code> ，因为它始终使用最少的往返次数。
                        </p>
                        <p>使用上一节中的示例，将<code class="codeph">Statement</code>对象<code class="codeph">stmt</code>为<code class="codeph">OracleStatement</code> ，并将包含<code class="codeph">LONG RAW</code>数据的列重新定义为<code class="codeph">VARBINARAY</code>类型。数据未流式传输。相反，它以字节数组的形式返回。代码段如下：</p><pre class="oac_no_warn" dir="ltr">//将语句stmt强制转换为OracleStatement oracle.jdbc。OracleStatement ostmt =（oracle.jdbc。OracleStatement）语句; //将索引位置1处的LONG列重新定义为VARBINARY ostmt.defineColumnType（1，Types。VARBINARY）; //执行查询以获取名为“LESLIE”的图像ResultSet rset = ostmt.executeQuery（“从streamexample中选择GIFDATA，其中NAME ='LESLIE'”）; //这里没有流式传输数据rset.next（）; byte [] bytes = rset.getBytes（1）;</pre></div>
                     <!-- class="section" -->
                  </div>
                  <div>
                     <div class="relinfo">
                        <p><strong>相关话题</strong></p>
                        <ul>
                           <li><a href="release-changes.html#GUID-AC113DA4-DA08-4FB8-A447-7C3A6CDD8F22">不推荐的功能</a></li>
                        </ul>
                     </div>
                  </div>
                  
               </div>
            </div><a id="JJDBC28419"></a><div class="props_rev_3"><a id="GUID-6AE64DE5-A05B-43C5-894D-4260BC731DDA" name="GUID-6AE64DE5-A05B-43C5-894D-4260BC731DDA"></a><h3 id="JJDBC-GUID-6AE64DE5-A05B-43C5-894D-4260BC731DDA" class="sect3"><span class="enumeration_section">12.3</span>关于Streaming CHAR，VARCHAR或RAW列</h3>
               <div>
                  <div class="infoboxnote" id="GUID-6AE64DE5-A05B-43C5-894D-4260BC731DDA__GUID-ADAB68FA-6F1C-4072-A91C-CEAC916E2A6C">
                     <p class="notep1">注意：</p>
                     <p>从Oracle Database 12 <span class="italic">c</span>第1版（12.1）开始，不推荐使用此方法。
                     </p>
                  </div>
                  <p><a id="d49423e927" class="indexterm-anchor"></a><a id="d49423e931" class="indexterm-anchor"></a><a id="d49423e935" class="indexterm-anchor"></a>如果使用<code class="codeph">defineColumnType</code> Oracle扩展将<code class="codeph">CHAR</code> ， <code class="codeph">VARCHAR</code>或<code class="codeph">RAW</code>列重新定义为<code class="codeph">LONGVARCHAR</code>或<code class="codeph">LONGVARBINARY</code> ，则可以将该列作为流获取。程序的行为就像列实际上是<code class="codeph">LONG</code>或<code class="codeph">LONG RAW</code>类型一样。请注意，没有太多意义，因为这些列通常很短。
                  </p>
                  <p>如果尝试将<code class="codeph">CHAR</code> ， <code class="codeph">VARCHAR</code>或<code class="codeph">RAW</code>列作为数据流而不重新定义列类型，则JDBC驱动程序将返回Java <code class="codeph">InputStream</code> ，但不会发生实际流。对于这些数据类型，JDBC驱动程序在调用<code class="codeph">executeQuery</code>方法或<code class="codeph">next</code>方法期间将数据完全提取到内存缓冲区中。<code class="codeph">get</code> <span class="italic"><code class="codeph">XXX</code></span> <code class="codeph">Stream</code>入口点返回从此缓冲区读取数据的流。
                  </p>
               </div>
               <div>
                  <div class="relinfo">
                     <p><strong>相关话题</strong></p>
                     <ul>
                        <li><a href="release-changes.html#GUID-AC113DA4-DA08-4FB8-A447-7C3A6CDD8F22">不推荐的功能</a></li>
                     </ul>
                  </div>
               </div>
               
            </div><a id="JJDBC28421"></a><a id="JJDBC28422"></a><a id="JJDBC28420"></a><div class="props_rev_3"><a id="GUID-9DFFE7D3-C173-4D9D-8F0E-746CEAA324E5" name="GUID-9DFFE7D3-C173-4D9D-8F0E-746CEAA324E5"></a><h3 id="JJDBC-GUID-9DFFE7D3-C173-4D9D-8F0E-746CEAA324E5" class="sect3"><span class="enumeration_section">12.4</span>关于流式传输LOB和外部文件</h3>
               <div>
                  <p><a id="d49423e1029" class="indexterm-anchor"></a>术语大对象（LOB）是指数据项太大而无法直接存储在数据库表中。相反，定位器存储在数据库表中，该表指向实际数据的位置。外部文件的管理方式类似。JDBC驱动程序可以通过使用strea ms支持以下类型：</p>
                  <ul style="list-style-type:disc">
                     <li>
                        <p>二进制大对象（BLOB）</p>
                        <p>对于非结构化二进制数据</p>
                     </li>
                     <li>
                        <p>字符大对象（CLOB）</p>
                        <p>对于角色数据</p>
                     </li>
                     <li>
                        <p>国家大字体（NCLOB）</p>
                        <p>对于国家字符数据</p>
                     </li>
                     <li>
                        <p>二进制文件（BFILE）</p>
                        <p>对于外部文件</p>
                     </li>
                  </ul>
                  <p>LOB和BFILE的行为与本章中描述的其他类型的流数据不同。而不是将实际数据存储在表中，而是存储定位器。可以使用此定位器操作实际数据，包括以流的形式读取和写入数据。即使在流式传输时，也只有大量数据（由大小定义）通过网络流式传输。相比之下，当流式传输<code class="codeph">LONG</code>或<code class="codeph">LONG</code> <code class="codeph">RAW</code> ，整个数据将通过网络流式传输。
                  </p>
                  <div class="section">
                     <p class="subhead2" id="GUID-9DFFE7D3-C173-4D9D-8F0E-746CEAA324E5__GUID-7F090CF3-C1FD-424D-96CE-5DD6D5964B9D">流BLOB，CLOB和NCLOB</p>
                  </div>
                  <!-- class="section" -->
                  <div class="section">
                     <p>当查询获取一个或多个<code class="codeph">BLOB</code> ， <code class="codeph">CLOB</code>或<code class="codeph">NCLOB</code>列时，JDBC驱动程序将数据传输到客户端。该数据可以作为流来访问。要从JDBC操作<code class="codeph">BLOB</code> ， <code class="codeph">CLOB</code>或<code class="codeph">NCLOB</code>数据，请使用Oracle扩展类<code class="codeph">oracle.sql.BLOB</code> ， <code class="codeph">oracle.sql.CLOB</code>和<code class="codeph">oracle.sql.NCLOB</code> 。这些类提供特定的功能，诸如从读取<code class="codeph">BLOB</code> ， <code class="codeph">CLOB</code> ，或<code class="codeph">NCLOB</code>为输入流，从输出流写入一个<code class="codeph">BLOB</code> ， <code class="codeph">CLOB</code> ，或<code class="codeph">NCLOB</code> ，确定的长度<code class="codeph">BLOB</code> ， <code class="codeph">CLOB</code> ，或<code class="codeph">NCLOB</code> ，闭<code class="codeph">BLOB</code> ， <code class="codeph">CLOB</code>或<code class="codeph">NCLOB</code> 。</p>
                     <div class="infoboxnote" id="GUID-9DFFE7D3-C173-4D9D-8F0E-746CEAA324E5__GUID-5C2C2856-AC88-4337-BE65-FAE8258CD6E3">
                        <p class="notep1">注意：</p>
                        <p>从Oracle Database 12 <span class="italic">c</span>第1版（12.1）开始，不推荐使用<code class="codeph">oracle.sql</code>包中的具体类，并将其替换为<code class="codeph">oracle.jdbc</code>包中的接口。Oracle建议您尽可能使用<code class="codeph">java.sql</code>包中提供的方法，以<code class="codeph">java.sql</code> Oracle特定扩展的<code class="codeph">oracle.jdbc</code>包中提供的标准兼容性和方法。有关这些接口的更多信息，请参阅MoS Note 1364193.1。
                        </p>
                     </div>
                     <div class="infoboxnotealso" id="GUID-9DFFE7D3-C173-4D9D-8F0E-746CEAA324E5__GUID-2A04F6A3-4508-470F-B0F1-0B9B46FB0415">
                        <p class="notep1">也可以看看：</p>
                        <p><span class="q">“ <a href="LOBs-and-BFiles.html#GUID-B88A9B7F-FFDD-4B9F-9B6D-ED9C70B7545F">LOB的数据接口</a> ”</span></p>
                     </div>
                  </div>
                  <!-- class="section" -->
                  <div class="section">
                     <p class="subhead2" id="GUID-9DFFE7D3-C173-4D9D-8F0E-746CEAA324E5__GUID-F433F7C8-81C4-4661-A5E9-47AB633F2BCF">流式BFILE</p>
                  </div>
                  <!-- class="section" -->
                  <div class="section">
                     <p><a id="d49423e1176" class="indexterm-anchor"></a><a id="d49423e1180" class="indexterm-anchor"></a>外部文件或BFILE用于将定位器存储到数据库外部的文件中。该文件可以存储在数据服务器的文件系统上的某个位置。定位器指向文件的实际位置。
                     </p>
                     <p>当查询获取一个或多个<code class="codeph">BFILE</code>列时，JDBC驱动程序会根据需要将文件传输到客户端。可以作为流访问数据要从JDBC操作BFILE数据，请使用Oracle扩展类<code class="codeph">oracle.sql.BFILE</code> 。此类提供特定功能，例如从BFILE读取到输入流，从输出流写入BFILE，确定BFILE的长度以及关闭BFILE。</p>
                  </div>
                  <!-- class="section" -->
               </div>
            </div><a id="JJDBC28424"></a><a id="JJDBC28425"></a><a id="JJDBC28423"></a><div class="props_rev_3"><a id="GUID-2A5CD25F-E34E-49E3-BD78-A27B50A18A6B" name="GUID-2A5CD25F-E34E-49E3-BD78-A27B50A18A6B"></a><h3 id="JJDBC-GUID-2A5CD25F-E34E-49E3-BD78-A27B50A18A6B" class="sect3"><span class="enumeration_section">12.5</span>数据流和多列之间的关系</h3>
               <div>
                  <p><a id="d49423e1218" class="indexterm-anchor"></a>如果查询获取多个列并且其中一列包含数据流，则在读取流之前，流列之后的列的内容不可用，并且一旦读取任何后续列，则流列不再可用。任何读取流列之外的列的尝试都会关闭流列。
                  </p>
                  <div class="section">
                     <p class="subhead2" id="GUID-2A5CD25F-E34E-49E3-BD78-A27B50A18A6B__GUID-F5E60400-216A-4DDD-AC2C-BC20F66B127F">具有多列的流示例</p>
                  </div>
                  <!-- class="section" -->
                  <div class="section">
                     <p>请考虑以下代码：</p><pre class="oac_no_warn" dir="ltr">ResultSet rset = stmt.executeQuery（“从TABLE中选择DATECOL，LONGCOL，NUMBERCOL”）;而rset.next（）{//获取日期数据java.sql。日期日期= rset.getDate（1）; //获取流数据InputStream is = rset.getAsciiStream（2）; //打开一个文件来存储gif数据FileOutputStream file = new FileOutputStream（“ascii.dat”）; //循环，从ascii流读取和//写入文件int chunk; while（（chunk = is.read（））！= -1）file.write（chunk）; //关闭文件file.close（）; //获取数字列数据int n = rset.getInt（3）; }</pre><p>每行的传入数据具有以下形状：</p><pre class="oac_no_warn" dir="ltr">&lt;a date&gt; &lt;长列的字符&gt; &lt;a number&gt;</pre><p>在处理结果集的每一行时，必须在读取数字列之前完成流列的任何处理。</p>
                  </div>
                  <!-- class="section" -->
                  <div class="section" id="GUID-2A5CD25F-E34E-49E3-BD78-A27B50A18A6B__I1014850">
                     <p class="subhead2" id="GUID-2A5CD25F-E34E-49E3-BD78-A27B50A18A6B__GUID-C1F13488-2710-4397-BE86-2901CC5E691E">绕过流数据列</p>
                  </div>
                  <!-- class="section" -->
                  <div class="section">
                     <p>在某些情况下，您可能希望避免读取包含流数据的列。如果你<a id="d49423e1243" class="indexterm-anchor"></a>不想读取这样的数据，然后调用stream对象的<code class="codeph">close</code>方法。此方法丢弃流数据并使驱动程序能够继续从包含非流数据的所有列读取数据，并按照包含流数据的列进行操作。即使您有意丢弃流，但以与<code class="codeph">SELECT</code>语句中相同的顺序检索列是一种很好的编程习惯。
                     </p>
                     <p>在以下示例中，将丢弃<code class="codeph">LONG</code>列中的流数据，并且仅恢复来自<code class="codeph">DATE</code>和<code class="codeph">NUMBER</code>列的数据：</p><pre class="oac_no_warn" dir="ltr">ResultSet rset = stmt.executeQuery（“从TABLE中选择DATECOL，LONGCOL，NUMBERCOL”）;而rset.next（）{//获取日期java.sql。日期日期= rset.getDate（1）; //访问流数据并使用close（）将其丢弃InputStream is = rset.getAsciiStream（2）; is.close（）; //获取数字列数据int n = rset.getInt（3）; }</pre></div>
                  <!-- class="section" -->
               </div>
               <div>
                  <div class="relinfo">
                     <p><strong>相关话题</strong></p>
                     <ul>
                        <li><a href="Java-streams-in-JDBC.html#GUID-6A449885-5082-44B2-93B6-36060EEA7C15">关于流数据注意事项</a></li>
                        <li><a href="Java-streams-in-JDBC.html#GUID-9DFFE7D3-C173-4D9D-8F0E-746CEAA324E5">关于流式传输LOB和外部文件</a></li>
                     </ul>
                  </div>
               </div>
               
            </div><a id="JJDBC28426"></a><div class="props_rev_3"><a id="GUID-AF94E206-56E2-452C-B88A-C7EAD2AAF05D" name="GUID-AF94E206-56E2-452C-B88A-C7EAD2AAF05D"></a><h3 id="JJDBC-GUID-AF94E206-56E2-452C-B88A-C7EAD2AAF05D" class="sect3"><span class="enumeration_section">12.6</span>关闭流</h3>
               <div>
                  <div class="section">
                     <p><a id="d49423e1307" class="indexterm-anchor"></a>您可以通过调用<code class="codeph">close</code>方法随时丢弃流中的数据。当您不再需要它时关闭流是一种很好的编程习惯。例如：</p><pre class="oac_no_warn" dir="ltr">...InputStream是= rset.getAsciiStream（2）; is.close（）;</pre><div class="infoboxnote" id="GUID-AF94E206-56E2-452C-B88A-C7EAD2AAF05D__GUID-461DE5C3-65AD-45A7-91CC-96ADB13587F9">
                        <p class="notep1">注意：</p>
                        <p>关闭流对LONG或LONG RAW列的性能影响很小。所有数据仍然在网络中传输，驱动程序必须从网络中读取这些位。</p>
                     </div>
                  </div>
                  <!-- class="section" -->
               </div>
               <div>
                  <div class="relinfo">
                     <p><strong>相关话题</strong></p>
                     <ul>
                        <li><a href="Java-streams-in-JDBC.html#GUID-2A5CD25F-E34E-49E3-BD78-A27B50A18A6B">数据流和多列之间的关系</a></li>
                        <li><a href="Java-streams-in-JDBC.html#GUID-6A449885-5082-44B2-93B6-36060EEA7C15">关于流数据注意事项</a></li>
                     </ul>
                  </div>
               </div>
               
            </div><a id="JJDBC28427"></a><div class="props_rev_3"><a id="GUID-16F826CB-4141-4451-9CAC-F3C8205A80BD" name="GUID-16F826CB-4141-4451-9CAC-F3C8205A80BD"></a><h3 id="JJDBC-GUID-16F826CB-4141-4451-9CAC-F3C8205A80BD" class="sect3"><span class="enumeration_section">12.7</span>流的注意事项和注意事项</h3>
               <div>
                  <div class="section">
                     <p>本节讨论有关使用流的几个警示问题：</p>
                     <ul style="list-style-type:disc">
                        <li>
                           <p><a href="Java-streams-in-JDBC.html#GUID-6A449885-5082-44B2-93B6-36060EEA7C15">关于流数据注意事项</a></p>
                        </li>
                        <li>
                           <p><a href="Java-streams-in-JDBC.html#GUID-6921B177-A519-47AA-8DD0-66E6FA9F50AE">关于使用Streams来避免对setBytes和setString的限制</a></p>
                        </li>
                        <li>
                           <p><a href="Java-streams-in-JDBC.html#GUID-D2A59D17-639C-4122-87F9-A36CEDEE6D3D">流和行预取之间的关系</a></p>
                        </li>
                     </ul>
                  </div>
                  <!-- class="section" -->
               </div><a id="JJDBC28428"></a><div class="props_rev_3"><a id="GUID-6A449885-5082-44B2-93B6-36060EEA7C15" name="GUID-6A449885-5082-44B2-93B6-36060EEA7C15"></a><h4 id="JJDBC-GUID-6A449885-5082-44B2-93B6-36060EEA7C15" class="sect4"><span class="enumeration_section">12.7.1</span>关于流数据注意事项</h4>
                  <div>
                     <p>本节介绍了必须采取的一些预防措施，以确保您不会意外丢弃或丢失流数据。如果执行与数据库通信的任何JDBC操作（除了读取当前流），驱动程序将自动丢弃流数据。两个常见的预防措施是：</p>
                     <ul style="list-style-type:disc">
                        <li>
                           <p>访问后使用流数据。</p>
                           <p>要从包含数据流的列恢复数据，仅提取列是不够的。您必须立即处理该列的内容。否则，当您获取下一列时，将丢弃内容。</p>
                        </li>
                        <li>
                           <p>以与<code class="codeph">SELECT</code>语句中相同的顺序调用流列。
                           </p>
                           <p>如果查询提取多个列，则数据库将每行作为一组字节发送，表示<code class="codeph">SELECT</code>顺序中的列。如果其中一列包含流数据，则数据库会在继续下一列之前发送整个数据流。
                           </p>
                           <p>如果不使用<code class="codeph">SELECT</code>语句中的顺序来访问数据，则可能会丢失流数据。也就是说，如果绕过流数据列并访问其后面的列中的数据，则流数据将丢失。例如，如果<span class="italic">在</span>从流数据列读取数据<span class="italic">之前</span>尝试访问<code class="codeph">NUMBER</code>列的数据，则JDBC驱动程序首先读取然后自动丢弃流数据。如果<code class="codeph">LONG</code>列包含大量数据，则效率非常低。
                           </p>
                           <p>如果您稍后尝试在程序中访问<code class="codeph">LONG</code>列，则数据将不可用，并且驱动程序将返回“ <code class="codeph">Stream Closed</code> ”错误。
                           </p>
                        </li>
                     </ul>
                     <p>后面的例子如下例所示：</p><pre class="oac_no_warn" dir="ltr">ResultSet rset = stmt.executeQuery（“从TABLE中选择DATECOL，LONGCOL，NUMBERCOL”）;而rset.next（）{int n = rset.getInt（3）; //这会丢弃流数据InputStream is = rset.getAsciiStream（2）; //引发错误：流已关闭。}</pre><p>如果您获得了流但<span class="italic">在</span>获取<code class="codeph">NUMBER</code>列<span class="italic">之前</span>未使用它，则流仍会自动关闭：</p><pre class="oac_no_warn" dir="ltr">ResultSet rset = stmt.executeQuery（“从TABLE中选择DATECOL，LONGCOL，NUMBERCOL”）;而rset.next（）{InputStream is = rset.getAsciiStream（2）; //获取流int n = rset.getInt（3）; //丢弃流数据并关闭流} int c = is.read（）; // c为-1：不再有读取流的字符</pre></div>
               </div><a id="JJDBC28429"></a><div class="props_rev_3"><a id="GUID-6921B177-A519-47AA-8DD0-66E6FA9F50AE" name="GUID-6921B177-A519-47AA-8DD0-66E6FA9F50AE"></a><h4 id="JJDBC-GUID-6921B177-A519-47AA-8DD0-66E6FA9F50AE" class="sect4"><span class="enumeration_section">12.7.2</span>关于使用流来避免对setBytes和setString的限制</h4>
                  <div>
                     <div class="section">
                        <p>从Oracle数据库<span class="italic">12c</span>中开始，其用于与所述数据的大小限制<code class="codeph">setBytes</code>和<code class="codeph">setString</code>方法，已显著增加。任何Java <code class="codeph">byte</code>数组都可以传递给<code class="codeph">setBytes</code> ，任何Java <code class="codeph">String</code>都可以传递给<code class="codeph">setString</code> 。JDBC驱动程序自动切换到使用<code class="codeph">setBinaryStream</code>或<code class="codeph">setCharacterStream</code>或使用<code class="codeph">setBytesForBlob</code>或<code class="codeph">setStringForClob</code> ，具体取决于数据的大小，语句是SQL还是PL / SQL，以及使用的驱动程序。
                        </p>
                        <p>早期版本的Oracle数据库和服务器端内部驱动程序存在一些限制。</p>
                     </div>
                     <!-- class="section" -->
                  </div>
                  <div>
                     <div class="relinfo">
                        <p><strong>相关话题</strong></p>
                        <ul>
                           <li><a href="LOBs-and-BFiles.html#GUID-B88A9B7F-FFDD-4B9F-9B6D-ED9C70B7545F">LOB的数据接口</a></li>
                        </ul>
                     </div>
                  </div>
                  
               </div><a id="JJDBC28430"></a><div class="props_rev_3"><a id="GUID-D2A59D17-639C-4122-87F9-A36CEDEE6D3D" name="GUID-D2A59D17-639C-4122-87F9-A36CEDEE6D3D"></a><h4 id="JJDBC-GUID-D2A59D17-639C-4122-87F9-A36CEDEE6D3D" class="sect4"><span class="enumeration_section">12.7.3</span>流和行预取之间的关系</h4>
                  <div>
                     <div class="section">
                        <p>如果JDBC驱动程序遇到<a id="d49423e1567" class="indexterm-anchor"></a><a id="d49423e1571" class="indexterm-anchor"></a>包含数据流的列，然后将行提取大小设置回一。行提取大小是Oracle性能增强，可以在每次访问数据库时检索多行数据。
                        </p>
                     </div>
                     <!-- class="section" -->
                  </div>
               </div>
            </div>
         </div>
      </article>
   </body>
</html>