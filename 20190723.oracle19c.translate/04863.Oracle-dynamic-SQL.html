<html lang="en-us" dir="ltr" xml:lang="en-us">
   <head>
      <meta http-equiv="Content-Type" content="text/html; charset=utf-8"></meta>
      <meta name="viewport" content="width=device-width, initial-scale=1"></meta>
      <meta http-equiv="X-UA-Compatible" content="IE=edge"></meta>
      <title>Oracle动态SQL</title>
      <meta property="og:site_name" content="Oracle Help Center"></meta>
      <meta property="og:title" content="Programmer&#39;s Guide"></meta>
      <meta property="og:description" content=""></meta>
      <link rel="stylesheet" href="/sp_common/book-template/ohc-book-template/css/book.css"></link>
      <link rel="shortcut icon" href="/sp_common/book-template/ohc-common/img/favicon.ico"></link>
      <meta name="application-name" content="Programmer&#39;s Guide"></meta>
      <meta name="generator" content="DITA Open Toolkit version 1.8.5 (Mode = doc)"></meta>
      <meta name="plugin" content="SP_docbuilder HTML plugin release 18.2.2"></meta>
      <link rel="alternate" href="cobol-programmers-guide.pdf" title="PDF File" type="application/pdf"></link>
      <meta name="robots" content="all"></meta>
      <link rel="schema.dcterms" href="http://purl.org/dc/terms/"></link>
      <meta name="dcterms.created" content="2019-01-11T02:40:40-08:00"></meta>
      
      <meta name="dcterms.dateCopyrighted" content="1996, 2019"></meta>
      <meta name="dcterms.category" content="database"></meta>
      <meta name="dcterms.identifier" content="E96466-01"></meta>
      
      <meta name="dcterms.product" content="en/database/oracle/oracle-database/19"></meta>
      
      <link rel="prev" href="error-handling-and-diagnostics.html" title="Previous" type="text/html"></link>
      <link rel="next" href="applications.html" title="Next" type="text/html"></link>
      <script>
        document.write('<style type="text/css">');
        document.write('body > .noscript, body > .noscript ~ * { visibility: hidden; }');
        document.write('</style>');
     </script>
      <script src="/sp_common/book-template/requirejs/require.js" data-main="/sp_common/book-template/ohc-book-template/js/book-config"></script>
      <script>
            if (window.require === undefined) {
                document.write('<script data-main="sp_common/book-template/ohc-book-template/js/book-config" src="sp_common/book-template/requirejs/require.js"><\/script>');
                document.write('<link href="sp_common/book-template/ohc-book-template/css/book.css" rel="stylesheet"/>');
            }
        </script>
      <script type="application/json" id="ssot-metadata">{"primary":{"category":{"short_name":"database","element_name":"Database","display_in_url":true},"suite":{"short_name":"oracle","element_name":"Oracle","display_in_url":true},"product_group":{"short_name":"not-applicable","element_name":"Not applicable","display_in_url":false},"product":{"short_name":"oracle-database","element_name":"Oracle Database","display_in_url":true},"release":{"short_name":"19","element_name":"Release 19","display_in_url":true}}}</script>
      
    <meta name="dcterms.title" content="Pro*COBOL Programmer&#39;s Guide"></meta>
    <meta name="dcterms.isVersionOf" content="LNPCB"></meta>
    <meta name="dcterms.release" content="Release 19"></meta>
  </head>
   <body dir="ltr">
      <div class="noscript alert alert-danger text-center" role="alert">
         <a href="error-handling-and-diagnostics.html" class="pull-left"><span class="glyphicon glyphicon-chevron-left" aria-hidden="true"></span>上一页</a> <a href="applications.html" class="pull-right">下一页<span class="glyphicon glyphicon-chevron-right" aria-hidden="true"></span></a> <span class="fa fa-exclamation-triangle" aria-hidden="true"></span>必须启用JavaScript才能正确显示此内容</div>
      <article>
         <header>
            <ol class="breadcrumb" vocab="http://schema.org/" typeof="BreadcrumbList">
               <li property="itemListElement" typeof="ListItem"><a href="index.html" property="item" typeof="WebPage"><span property="name">程序员指南</span></a></li>
               <li property="itemListElement" typeof="ListItem"><a href="introduction-and-concepts.html" property="item" typeof="WebPage"><span property="name">介绍和概念</span></a></li>
               <li class="active" property="itemListElement" typeof="ListItem">Oracle动态SQL</li>
            </ol>
            <a id="GUID-C325218F-3DFF-4551-A5EB-483ADB24E324" name="GUID-C325218F-3DFF-4551-A5EB-483ADB24E324"></a><a id="LNPCB009"></a>
            
            <h2 id="LNPCB-GUID-C325218F-3DFF-4551-A5EB-483ADB24E324" class="sect2"><span class="enumeration_chapter">9</span> Oracle动态SQL</h2>
         </header>
         <div class="ind">
            <div>
               <p>本章介绍如何使用动态SQL，这是一种高级编程技术，可为您的应用程序增加灵活性和功能。在权衡了动态SQL的优缺点之后，您将学习四种方法 - 从简单到复杂 - 用于编写在运行时“即时”接受和处理SQL语句的程序。您将了解每种方法的要求和限制，以及如何为给定作业选择正确的方法。</p>
               <p>主题是：</p>
               <ul style="list-style-type:disc">
                  <li>
                     <p><a href="Oracle-dynamic-SQL.html#GUID-DF3623CC-9429-41D5-9570-D50F7E020E56">动态SQL</a></p>
                  </li>
                  <li>
                     <p><a href="Oracle-dynamic-SQL.html#GUID-A56CF61E-75A6-4B38-9450-88E2B892A4F3">动态SQL的优缺点</a></p>
                  </li>
                  <li>
                     <p><a href="Oracle-dynamic-SQL.html#GUID-C9169A84-8C27-4C97-98D4-CB752B818661">何时使用动态SQL</a></p>
                  </li>
                  <li>
                     <p><a href="Oracle-dynamic-SQL.html#GUID-758EF3A0-62D0-4A13-8C52-D57E51BA040E">动态SQL语句的要求</a></p>
                  </li>
                  <li>
                     <p><a href="Oracle-dynamic-SQL.html#GUID-0C94DC5B-7F8A-4E23-8913-EEAFFFCFBBBE">如何处理动态SQL语句</a></p>
                  </li>
                  <li>
                     <p><a href="Oracle-dynamic-SQL.html#GUID-6A5290B0-1C8A-4296-9D8A-5D6A1DA71C2C">使用动态SQL的方法</a></p>
                  </li>
                  <li>
                     <p><a href="Oracle-dynamic-SQL.html#GUID-D748469E-AF51-45FD-AD24-E063D5A8D2FC">使用方法1</a></p>
                  </li>
                  <li>
                     <p><a href="Oracle-dynamic-SQL.html#GUID-831761FE-3327-42CB-B752-059B2D3D2D9A">示例程序6：动态SQL方法1</a></p>
                  </li>
                  <li>
                     <p><a href="Oracle-dynamic-SQL.html#GUID-0C0E313A-0142-4B10-8A29-BF59AFEE52D3">使用方法2</a></p>
                  </li>
                  <li>
                     <p><a href="Oracle-dynamic-SQL.html#GUID-7C396D57-55A0-4A5D-8A12-ECDFC088BA1B">示例程序7：动态SQL方法2</a></p>
                  </li>
                  <li>
                     <p><a href="Oracle-dynamic-SQL.html#GUID-EB61DAC0-F600-4775-9F41-838542A0B4FF">使用方法3</a></p>
                  </li>
                  <li>
                     <p><a href="Oracle-dynamic-SQL.html#GUID-11144CD4-BB17-4392-8497-9225D7119798">示例程序8：动态SQL方法3</a></p>
                  </li>
                  <li>
                     <p><a href="Oracle-dynamic-SQL.html#GUID-FBFBAED9-1541-4E4E-BA9F-192582B7A7E2">使用Oracle方法4</a></p>
                  </li>
                  <li>
                     <p><a href="Oracle-dynamic-SQL.html#GUID-D38FED05-3568-4E54-91B7-406F25000D1B">使用DECLARE STATEMENT语句</a></p>
                  </li>
                  <li>
                     <p><a href="Oracle-dynamic-SQL.html#GUID-0F95D426-2256-4EF5-B022-0AD06C2AC4CA">使用主机表</a></p>
                  </li>
                  <li>
                     <p><a href="Oracle-dynamic-SQL.html#GUID-E4F3236E-B588-41FF-8A2F-DFB111F214DB">使用PL / SQL</a></p>
                  </li>
                  <li>
                     <p><a href="Oracle-dynamic-SQL.html#GUID-0AD16F5E-7039-4C35-90F1-5543AE675329">动态SQL语句缓存</a></p>
                  </li>
               </ul>
            </div><a id="LNPCB573"></a><div class="props_rev_3"><a id="GUID-DF3623CC-9429-41D5-9570-D50F7E020E56" name="GUID-DF3623CC-9429-41D5-9570-D50F7E020E56"></a><h3 id="LNPCB-GUID-DF3623CC-9429-41D5-9570-D50F7E020E56" class="sect3"><span class="enumeration_section">9.1</span>动态SQL</h3>
               <div>
                  <p>大多数数据库应用程序执行特定的工例如，一个简单的程序可能会提示用户输入员工编号，然后更新EMP和DEPT表中的行。在这种情况下，您知道在预编译时UPDATE语句的组成。也就是说，您知道可能更改哪些表，为每个表和列定义的约束，可能更新的列以及每列的数据类型。<a id="d66034e135" class="indexterm-anchor"></a></p>
                  <p>但是，某些应用程序必须在运行时接受（或构建）和处理各种SQL语句。例如，通用报表编写者必须为其生成的各种报表构建不同的SELECT语句。在这种情况下，语句的构成在运行时才会被识别。这些陈述可以并且可能会从执行变为执行。它们恰当地称为<span class="italic">动态</span> SQL语句。<a id="d66034e144" class="indexterm-anchor"></a></p>
                  <p>与静态SQL语句不同，动态SQL语句未嵌入源程序中。相反，它们存储在运行时输入或由程序构建的字符串中。它们可以交互式输入或从文件中读取。<a id="d66034e148" class="indexterm-anchor"></a></p>
               </div>
            </div><a id="LNPCB574"></a><div class="props_rev_3"><a id="GUID-A56CF61E-75A6-4B38-9450-88E2B892A4F3" name="GUID-A56CF61E-75A6-4B38-9450-88E2B892A4F3"></a><h3 id="LNPCB-GUID-A56CF61E-75A6-4B38-9450-88E2B892A4F3" class="sect3"><span class="enumeration_section">9.2</span>动态SQL的优缺点</h3>
               <div>
                  <p>接受和处理动态定义的SQL语句的主机程序比普通的嵌入式SQL程序更通用。可以使用对SQL知之甚少或根本不了解的用户的输入以交互方式构建动态SQL语句。<a id="d66034e176" class="indexterm-anchor"></a></p>
                  <p>例如，您的程序可能只是提示用户在SELECT，UPDATE或DELETE语句的WHERE子句中使用搜索条件。更复杂的程序可能允许用户从列出SQL操作，表和视图名称，列名称等的菜单中进行选择。因此，动态SQL允许您编写高度灵活的应用程序。</p>
                  <p>但是，一些动态查询需要复杂的编码，特殊数据结构的使用以及更多的运行时处理。虽然您可能没有注意到增加的处理时间，但除非您完全理解动态SQL概念和方法，否则您可能会发现编码很困难。</p>
               </div>
            </div><a id="LNPCB575"></a><div class="props_rev_3"><a id="GUID-C9169A84-8C27-4C97-98D4-CB752B818661" name="GUID-C9169A84-8C27-4C97-98D4-CB752B818661"></a><h3 id="LNPCB-GUID-C9169A84-8C27-4C97-98D4-CB752B818661" class="sect3"><span class="enumeration_section">9.3</span>何时使用动态SQL</h3>
               <div>
                  <p>实际上，静态SQL几乎可以满足您的所有编程需求。仅在需要开放式灵活性时才使用动态SQL。当预编译时未知以下一项或多项时，建议使用它：<a id="d66034e209" class="indexterm-anchor"></a></p>
                  <ul style="list-style-type:disc">
                     <li>
                        <p>SQL语句的文本（命令，子句等）</p>
                     </li>
                     <li>
                        <p>主机变量的数量</p>
                     </li>
                     <li>
                        <p>主机变量的数据类型</p>
                     </li>
                     <li>
                        <p>对数据库对象的引用，例如列，索引，序列，表，用户名和视图</p>
                     </li>
                  </ul>
               </div>
            </div><a id="LNPCB576"></a><div class="props_rev_3"><a id="GUID-758EF3A0-62D0-4A13-8C52-D57E51BA040E" name="GUID-758EF3A0-62D0-4A13-8C52-D57E51BA040E"></a><h3 id="LNPCB-GUID-758EF3A0-62D0-4A13-8C52-D57E51BA040E" class="sect3"><span class="enumeration_section">9.4</span>动态SQL语句的要求</h3>
               <div>
                  <p>要表示动态SQL语句，字符串必须包含有效DML或DDL SQL语句的文本，但<span class="italic">不</span>包含EXEC SQL子句，主机语言分隔符或语句终止符。<a id="d66034e253" class="indexterm-anchor"></a></p>
                  <p>在大多数情况下，字符串可以包含<span class="italic">虚拟</span>主机变量。它们在SQL语句中保存实际主机变量的位置。因为虚拟主机变量只是占位符，所以不要声明它们并且可以将它们命名为任何你喜欢的（不允许使用连字符）。例如，Oracle不区分以下两个字符串</p><pre class="oac_no_warn" dir="ltr">'从EMP删除MGR =：MGRNUMBER和JOB =：JOBTITLE''从EMP删除MGR =：M和JOB =：J'</pre></div>
            </div><a id="LNPCB577"></a><div class="props_rev_3"><a id="GUID-0C94DC5B-7F8A-4E23-8913-EEAFFFCFBBBE" name="GUID-0C94DC5B-7F8A-4E23-8913-EEAFFFCFBBBE"></a><h3 id="LNPCB-GUID-0C94DC5B-7F8A-4E23-8913-EEAFFFCFBBBE" class="sect3"><span class="enumeration_section">9.5</span>如何处理动态SQL语句</h3>
               <div>
                  <p>通常，应用程序会提示用户输入SQL语句的文本以及语句中使用的主机变量的值。然后Oracle <span class="italic">解析</span> SQL语句。也就是说，Oracle检查SQL语句以确保它遵循语法规则并引用有效的数据库对象。解析还涉及检查数据库访问权限，保留所需资源以及查找最佳访问路径。<a id="d66034e291" class="indexterm-anchor"></a></p>
                  <p>接下来，Oracle <span class="italic">将</span>主机变量<span class="italic">绑定</span>到SQL语句。也就是说，Oracle获取主机变量的地址，以便它可以读取或写入它们的值。<a id="d66034e300" class="indexterm-anchor"></a><a id="d66034e302" class="indexterm-anchor"></a></p>
                  <p>如果该语句是查询，则定义SELECT变量，然后Oracle FETCH它们，直到检索到所有行。然后关闭光标。</p>
                  <p>然后Oracle <span class="italic">执行</span> SQL语句。也就是说，Oracle执行SQL语句请求的内容，例如从表中删除行。
                  </p>
                  <p>可以使用主机变量的新值重复执行SQL语句。</p>
               </div>
            </div><a id="LNPCB579"></a><a id="LNPCB578"></a><div class="props_rev_3"><a id="GUID-6A5290B0-1C8A-4296-9D8A-5D6A1DA71C2C" name="GUID-6A5290B0-1C8A-4296-9D8A-5D6A1DA71C2C"></a><h3 id="LNPCB-GUID-6A5290B0-1C8A-4296-9D8A-5D6A1DA71C2C" class="sect3"><span class="enumeration_section">9.6</span>使用动态SQL的方法</h3>
               <div>
                  <div class="section">
                     <p>本节介绍可用于定义动态SQL语句的四种方法。它简要描述了每种方法的功能和局限性，然后提供了选择正确方法的指南。后面的部分将向您展示如何使用这些方法。</p>
                     <p>这四种方法越来越普遍。也就是说，方法2包括方法1，方法3包括方法1和2，等等。但是，每种方法对于处理某种SQL语句最有用，因为<a href="Oracle-dynamic-SQL.html#GUID-6A5290B0-1C8A-4296-9D8A-5D6A1DA71C2C__i5308">适当的使用方法</a>显示：</p>
                  </div>
                  <!-- class="section" -->
                  <div class="tblformal" id="GUID-6A5290B0-1C8A-4296-9D8A-5D6A1DA71C2C__GUID-C07A42FF-92B7-4A98-9A46-0886F08CABAA">
                     <p class="titleintable">表9-1 <span class="italic" id="GUID-6A5290B0-1C8A-4296-9D8A-5D6A1DA71C2C__i5308"><span class="bold">使用的适当方法</span></span></p>
                     <table cellpadding="4" cellspacing="0" class="Formal" title="适当的使用方法" width="100%" border="1" summary="q" frame="hsides" rules="rows">
                        <thead>
                           <tr align="left" valign="top">
                              <th align="left" valign="bottom" width="15%" id="d66034e359">方法</th>
                              <th align="left" valign="bottom" width="85%" id="d66034e362">一种SQL语句</th>
                           </tr>
                        </thead>
                        <tbody>
                           <tr align="left" valign="top">
                              <td align="left" valign="top" width="15%" id="d66034e367" headers="d66034e359 ">
                                 <p>1</p>
                              </td>
                              <td align="left" valign="top" width="85%" headers="d66034e367 d66034e362 ">
                                 <p>没有输入主机变量的非查询。</p>
                              </td>
                           </tr>
                           <tr align="left" valign="top">
                              <td align="left" valign="top" width="15%" id="d66034e374" headers="d66034e359 ">
                                 <p>2</p>
                              </td>
                              <td align="left" valign="top" width="85%" headers="d66034e374 d66034e362 ">
                                 <p>具有已知数量的输入主机变量的非查询。</p>
                              </td>
                           </tr>
                           <tr align="left" valign="top">
                              <td align="left" valign="top" width="15%" id="d66034e381" headers="d66034e359 ">
                                 <p>3</p>
                              </td>
                              <td align="left" valign="top" width="85%" headers="d66034e381 d66034e362 ">
                                 <p>使用已知数量的选择列表项和输入主变量进行查询。</p>
                              </td>
                           </tr>
                           <tr align="left" valign="top">
                              <td align="left" valign="top" width="15%" id="d66034e388" headers="d66034e359 ">
                                 <p>4</p>
                              </td>
                              <td align="left" valign="top" width="85%" headers="d66034e388 d66034e362 ">
                                 <p>使用未知数量的选择列表项或输入主机变量进行查询。</p>
                              </td>
                           </tr>
                        </tbody>
                     </table>
                  </div>
                  <!-- class="inftblhruleinformal" -->
                  <div class="section">
                     <p>术语<span class="italic">select-list项</span>包括列名和表达式。
                     </p>
                  </div>
                  <!-- class="section" -->
               </div><a id="LNPCB580"></a><div class="props_rev_3"><a id="GUID-C0CC6476-8442-456B-B0C8-4F617A95B976" name="GUID-C0CC6476-8442-456B-B0C8-4F617A95B976"></a><h4 id="LNPCB-GUID-C0CC6476-8442-456B-B0C8-4F617A95B976" class="sect4"><span class="enumeration_section">9.6.1</span>方法1</h4>
                  <div>
                     <p>此方法允许程序接受或构建动态SQL语句，然后使用EXECUTE IMMEDIATE命令立即执行它。SQL语句不能是查询（SELECT语句），并且不能包含输入主机变量的任何占位符。例如，以下主机字符串符合条件：<a id="d66034e424" class="indexterm-anchor"></a><a id="d66034e428" class="indexterm-anchor"></a></p><pre class="oac_no_warn" dir="ltr">'删除EMP，DEPTNO = 20''选择EMP到SCOTT'</pre><p>使用方法1，每次执行时都会解析SQL语句（无论您是否设置了HOLD_CURSOR = YES）。</p>
                  </div>
               </div><a id="LNPCB581"></a><div class="props_rev_3"><a id="GUID-FF0E1173-9FE1-454D-AF7A-0149B912E0E1" name="GUID-FF0E1173-9FE1-454D-AF7A-0149B912E0E1"></a><h4 id="LNPCB-GUID-FF0E1173-9FE1-454D-AF7A-0149B912E0E1" class="sect4"><span class="enumeration_section">9.6.2</span>方法2</h4>
                  <div>
                     <p>此方法允许程序接受或构建动态SQL语句，然后使用PREPARE和EXECUTE命令对其进行处理。SQL语句不能是查询。必须在预编译时知道输入主变量的占位符数和输入主变量的数据类型。例如，以下主机字符串属于以下类别：<a id="d66034e460" class="indexterm-anchor"></a><a id="d66034e464" class="indexterm-anchor"></a></p><pre class="oac_no_warn" dir="ltr">'插入EMP（ENAME，JOB）值（：EMPNAME，：JOBTITLE）''从EMP删除EMPNO =：EMPNUMBER'</pre><p>使用方法2，可以通过调用PREPARE一次解析SQL语句一次，并使用不同的主机变量值执行多次。当还指定了RELEASE_CURSOR = YES时，这不是真的，因为必须在每次执行之前再次准备语句。</p>
                     <div class="infoboxnote" id="GUID-FF0E1173-9FE1-454D-AF7A-0149B912E0E1__GUID-6D6D58C2-1E04-4EEC-B125-06945EFE0D79">
                        <p class="notep1">注意：</p>
                        <p>一旦完成PREPARE，就会执行诸如CREATE之类的SQL数据定义语句。<a id="d66034e475" class="indexterm-anchor"></a></p>
                     </div>
                  </div>
               </div><a id="LNPCB582"></a><div class="props_rev_3"><a id="GUID-6CA29FAA-B55F-4C61-B225-64185E2E19BF" name="GUID-6CA29FAA-B55F-4C61-B225-64185E2E19BF"></a><h4 id="LNPCB-GUID-6CA29FAA-B55F-4C61-B225-64185E2E19BF" class="sect4"><span class="enumeration_section">9.6.3</span>方法3</h4>
                  <div>
                     <p>此方法允许程序接受或构建动态查询，然后使用带有DECLARE，OPEN，FETCH和CLOSE游标命令的PREPARE命令对其进行处理。必须在预编译时知道选择列表项的数量，输入主机变量的占位符数以及输入主机变量的数据类型。例如，以下主机字符串符合条件：<a id="d66034e504" class="indexterm-anchor"></a><a id="d66034e508" class="indexterm-anchor"></a></p><pre class="oac_no_warn" dir="ltr">“按DEPTNO从EMP集团中选择DEPTNO，MIN（SAL），MAX（SAL）”选择ENAME，EMPNO从EMP到DEPTNO =：DEPTNUMBER'</pre></div>
               </div><a id="LNPCB583"></a><div class="props_rev_3"><a id="GUID-437503D8-4EFD-494C-BAED-533AB254C39D" name="GUID-437503D8-4EFD-494C-BAED-533AB254C39D"></a><h4 id="LNPCB-GUID-437503D8-4EFD-494C-BAED-533AB254C39D" class="sect4"><span class="enumeration_section">9.6.4</span>方法4</h4>
                  <div>
                     <p>此方法允许程序接受或构建动态SQL语句，然后使用描述符对其进行处理（在<span class="q">“ <a href="Oracle-dynamic-SQL.html#GUID-FBFBAED9-1541-4E4E-BA9F-192582B7A7E2">使用Oracle方法4</a> ”中</span>讨论）。在运行时之前，选择列表项的数量，输入主机变量的占位符数以及输入主机变量的数据类型可能是未知的。例如，以下主机字符串属于以下类别：<a id="d66034e543" class="indexterm-anchor"></a></p><pre class="oac_no_warn" dir="ltr">'INSERT INTO EMP（ <span class="italic">未知</span> ）VALUES（ <span class="italic">未知</span> ）''从EMP WHERE DEPTNO = 20'选择<span class="italic">未知</span></pre><p>对于包含未知数量的选择列表项或输入主机变量的动态SQL语句，需要方法4。</p>
                  </div>
               </div><a id="LNPCB584"></a><div class="props_rev_3"><a id="GUID-1E6D7D97-DE6F-4C6E-A3C3-A660C4E31016" name="GUID-1E6D7D97-DE6F-4C6E-A3C3-A660C4E31016"></a><h4 id="LNPCB-GUID-1E6D7D97-DE6F-4C6E-A3C3-A660C4E31016" class="sect4"><span class="enumeration_section">9.6.5</span>指南</h4>
                  <div>
                     <p>使用所有四种方法，必须将动态SQL语句存储在字符串中，该字符串必须是主变量或带引号的文字。将SQL语句存储在字符串中时，请省略关键字EXEC SQL和语句终止符。<a id="d66034e584" class="indexterm-anchor"></a><a id="d66034e588" class="indexterm-anchor"></a></p>
                     <p>使用方法2和3，必须在预编译时知道输入主变量的占位符数和输入主变量的数据类型。</p>
                     <p>每个后续方法对应用程序施加的约束较少，但编码起来更加困难。通常，使用最简单的方法。但是，如果方法1将重复执行动态SQL语句，请使用方法2来避免为每次执行重新解析。</p>
                     <p>方法4提供了最大的灵活性，但需要复杂的编码和对动态SQL概念的充分理解。通常，仅当您不能使用方法1,2或3时才使用方法4。</p>
                     <p><a href="Oracle-dynamic-SQL.html#GUID-CDE681C0-14B6-4C49-AD84-7122A3B71E75__I3709">图9-1中</a>的决策逻辑将帮助您选择正确的方法。<a id="d66034e602" class="indexterm-anchor"></a></p>
                  </div><a id="LNPCB586"></a><a id="LNPCB585"></a><div class="props_rev_3"><a id="GUID-CDE681C0-14B6-4C49-AD84-7122A3B71E75" name="GUID-CDE681C0-14B6-4C49-AD84-7122A3B71E75"></a><h5 id="LNPCB-GUID-CDE681C0-14B6-4C49-AD84-7122A3B71E75" class="sect5"><span class="enumeration_section">9.6.5.1</span>避免常见错误</h5>
                     <div>
                        <div class="section">
                           <p>如果使用字符数组存储动态SQL语句，请在存储SQL语句之前对数组进行空白填充。这样，你就清除了无关紧要的角色。当您将数组重用于不同的SQL语句时，这一点尤为重要。通常，在存储SQL语句之前始终初始化（或重新初始化）主机字符串。</p>
                           <p>不要空终止主机字符串。Oracle不会将null终止符识别为字符串结束标记。相反，Oracle将其视为SQL语句的一部分。</p>
                           <p>如果使用VARCHAR变量存储动态SQL语句，请确保在执行PREPARE或EXECUTE IMMEDIATE语句之前正确设置（或重置）VARCHAR的长度。</p>
                           <p>EXECUTE重置SQLCA中的SQLWARN警告标志。因此，要捕获诸如无条件更新（由省略WHERE子句引起）之类的错误，请在执行PREPARE语句之后但在执行EXECUTE语句之前检查SQLWARN标志。</p>
                           <p><a href="Oracle-dynamic-SQL.html#GUID-CDE681C0-14B6-4C49-AD84-7122A3B71E75__I3709">图9-1</a>显示了如何选择正确的方法。
                           </p>
                           <div class="figure" id="GUID-CDE681C0-14B6-4C49-AD84-7122A3B71E75__I3709">
                              <p class="titleinfigure">图9-1选择正确的方法</p><img src="img/pco81058.gif" alt="下面是图9-1的描述" title="下面是图9-1的描述" longdesc="img_text/pco81058.html"><br><a href="img_text/pco81058.html">“图9-1选择正确方法”的说明</a></div>
                           <!-- class="figure" -->
                        </div>
                        <!-- class="section" -->
                     </div>
                  </div>
               </div>
            </div><a id="LNPCB587"></a><div class="props_rev_3"><a id="GUID-D748469E-AF51-45FD-AD24-E063D5A8D2FC" name="GUID-D748469E-AF51-45FD-AD24-E063D5A8D2FC"></a><h3 id="LNPCB-GUID-D748469E-AF51-45FD-AD24-E063D5A8D2FC" class="sect3"><span class="enumeration_section">9.7</span>使用方法1</h3>
               <div>
                  <div class="section">
                     <p>最简单的动态SQL语句仅导致“成功”或“失败”，并且不使用主机变量。一些例子如下：</p><pre class="oac_no_warn" dir="ltr">'DELETE FROM table_name WHERE column_name = constant''CREATE TABLE table_name ...''DROP INDEX index_name''UPDATE table_name SET column_name = constant''GRANT SELECT ON table_name TO username'</pre></div>
                  <!-- class="section" -->
               </div><a id="LNPCB588"></a><div class="props_rev_3"><a id="GUID-835BC701-9369-4DC2-BCE7-FD6D1E7E0378" name="GUID-835BC701-9369-4DC2-BCE7-FD6D1E7E0378"></a><h4 id="LNPCB-GUID-835BC701-9369-4DC2-BCE7-FD6D1E7E0378" class="sect4"><span class="enumeration_section">9.7.1</span> EXECUTE IMMEDIATE语句</h4>
                  <div>
                     <p>方法1解析，然后使用EXECUTE IMMEDIATE命令立即执行SQL语句。该命令后跟一个字符串（主机变量或文字），其中包含要执行的SQL语句，该语句不能是查询。</p>
                     <p>EXECUTE IMMEDIATE语句的语法如下：<a id="d66034e699" class="indexterm-anchor"></a><a id="d66034e703" class="indexterm-anchor"></a><a id="d66034e707" class="indexterm-anchor"></a></p><pre class="oac_no_warn" dir="ltr">EXEC SQL EXECUTE IMMEDIATE {：HOST-STRING | STRING-LITERAL} END-EXEC。</pre><p>在以下示例中，您使用主机变量<span class="italic">SQL-STMT</span>来存储用户输入的SQL语句：</p><pre class="oac_no_warn" dir="ltr">EXEC SQL BEGIN DECLARE SECTION END-EXEC。 ...01 SQL-STMT PIC X（120）; EXEC SQL END DECLARE SECTION END-EXEC。 ...环。显示'输入SQL语句：'没有进展。接受SQL-STMT END-EXEC。 *  -  sql_stmt现在包含SQL语句的文本<span class="bold"> </span> EXEC SQL EXECUTE IMMEDIATE：SQL-STMT END-EXEC。下一个。 ...
</pre><p>因为EXECUTE IMMEDIATE在每次执行之前解析输入SQL语句，所以方法1最适合仅执行一次的语句。数据定义语句通常属于此类别。</p>
                  </div>
               </div><a id="LNPCB589"></a><div class="props_rev_3"><a id="GUID-00641679-A6EE-402E-8D82-761EF46CB56F" name="GUID-00641679-A6EE-402E-8D82-761EF46CB56F"></a><h4 id="LNPCB-GUID-00641679-A6EE-402E-8D82-761EF46CB56F" class="sect4"><span class="enumeration_section">9.7.2</span>一个例子</h4>
                  <div>
                     <p>程序的以下片段提示用户在UPDATE语句的WHERE子句中使用搜索条件，然后使用方法1执行语句：<a id="d66034e749" class="indexterm-anchor"></a></p><pre class="oac_no_warn" dir="ltr">...* RELEASE_CURSOR = YES选项指示PRO * COBOL *释放与嵌入式SQL *语句相关的隐式游标。这样做可以确保Oracle不会在表格上保持*锁定，因此后续数据操作*对这些表格的操作不会导致PARE-LOCK *错误。 EXEC ORACLE选项（RELEASE_CURSOR = YES）END-EXEC。 * EXEC SQL BEGIN DECLARE SECTION END-EXEC。 01 USERNAME PIC X（10）值“SCOTT”。01 PASSWD PIC X（10）VALUE“TIGER”。01 DYNSTMT PIC X（80）。EXEC SQL END DECLARE SECTION END-EXEC。 01 UPDATESTMT PIC X（40）。01 SEARCH-COND PIC X（40）。...显示“输入声明的搜索条件：”。移动“UPDATE EMP SET COMM = 500 WHERE”到UPDATESTMT。显示UPDATESTMT。接受搜索 -  COND。 *将SEARCH-COND连接到UPDATESTMT并将结果*存储在DYNSTMT中。严格按照SIZE SEARCH-COND划分给DYNSTMT的大小更新。 EXEC SQL EXECUTE IMMEDIATE：DYNSTMT END-EXEC。</pre></div>
               </div>
            </div><a id="LNPCB590"></a><div class="props_rev_3"><a id="GUID-831761FE-3327-42CB-B752-059B2D3D2D9A" name="GUID-831761FE-3327-42CB-B752-059B2D3D2D9A"></a><h3 id="LNPCB-GUID-831761FE-3327-42CB-B752-059B2D3D2D9A" class="sect3"><span class="enumeration_section">9.8</span>示例程序6：动态SQL方法1</h3>
               <div>
                  <p>此程序使用动态SQL方法1创建表，插入行，提交插入，然后删除表。<a id="d66034e785" class="indexterm-anchor"></a></p><pre class="oac_no_warn" dir="ltr">************************************************** *************** *示例程序6：动态SQL方法1 * * * *此程序使用动态SQL方法1创建表，* *插入行，提交插入，然后放下桌子。* ************************************************* ****************身份识别部门。 PROGRAM-ID。DYNSQL1。环境部门。数据部门。工作储存部分。 *包括ORACLE通讯区域，结构*通过ORACLE提供额外的运行状态*可用于该计划的信息。 EXEC SQL包含SQLCA END-EXEC。 *包括ORACLE通讯区域，结构*通过ORACLE提供额外的运行状态*可用于该计划的信息。 EXEC SQL包含ORACA END-EXEC。 *选项ORACA =是必须指定使用* ORACA。 EXEC ORACLE选项（ORACA = YES）END-EXEC。 * RELEASE_CURSOR = YES选项指示PRO * COBOL *释放与嵌入式SQL *语句相关的隐式游标。这可以确保ORACLE不会在表格上锁定*锁定，因此后续数据操作*对这些表格的操作不会导致错误锁定*错误。 EXEC ORACLE选项（RELEASE_CURSOR = YES）END-EXEC。 EXEC SQL BEGIN DECLARE SECTION END-EXEC。 01 USERNAME PIC X（10）值“SCOTT”。01 PASSWD PIC X（10）VALUE“TIGER”。01 DYNSTMT PIC X（80）变化。 EXEC SQL END DECLARE SECTION END-EXEC。 *需要展示计算的DECLARE VARIABLES。 01 ORASLNRD PIC 9（9）。程序部门。主要。 *如果出现ORACLE错误，请分析SQLERROR。执行SQL WHENEVER SQLERROR GOTO SQLERROR END-EXEC。 *如果出现错误*，请在ORACA中保存当前SQL语句的文本。移动1到ORASTXTF。 *连接到ORACLE。 EXEC SQL CONNECT：USERNAME IDENTIFIED BY：PASSWD END-EXEC。显示“”。显示“作为用户连接到ORACLE：”没有任何进展。显示用户名。显示“”。*执行一个标志性的立场创建表。在这里，你*一般使用一个固定的变量，不论是在本程序中如何下载。但是，如果你愿意，你可以使用立陶宛。显示“创建表DYN1（COL1 CHAR（4））”。显示“”。EXEC SQL EXECUTE IMMEDIATE“CREATE TABLE DYN1（COL1 CHAR（4））”END-EXEC。 *为不同的DYNSTMT分配一个SQL语句。 *设定-ARR部分长度的一部分。移动“插入DYN1值（'测试'）”到DYNSTMT-ARR。向DYNSTMT-LEN移动36。显示DYNSTMT-ARR。显示“”。*执行DYNSTMT以插入行。SQL语句是一个*可变的变量，程序可以在运行时确定*。 EXEC SQL EXECUTE IMMEDIATE：DYNSTMT END-EXEC。 *承认插入。 EXEC SQL COMMIT WORK END-EXEC。 *改变DYNSTMT并执行它以降低表格。将“DROP TABLE DYN1”移至DYNSTMT-ARR。向DYNSTMT-LEN移动19。显示DYNSTMT-ARR。显示“”。EXEC SQL EXECUTE IMMEDIATE：DYNSTMT END-EXEC。 *承诺任何待处理的更改并断开与ORACLE的连接。 EXEC SQL COMMIT RELEASE END-EXEC。显示“有一个好日子！”。显示“”。停止运行。 SQLERROR。 * ORACLE ERROR HANDLER。打印诊断文本包含*错误消息，当前SQL语句和错误位置。显示SQLERRMC。显示“IN”，ORASTXTC。移动ORASLNR到ORASLNRD。显示“在线”，ORASLNRD，“OF”，ORASFNMC。 *禁用ORACLE错误检查以避免无限循环*应该在此段内发生另一个错误。执行SQL WHENEVER SQLERROR CONTINUE END-EXEC。 *返回任何待处理的更改并断开与ORACLE的连接。 EXEC SQL ROLLBACK RELEASE END-EXEC。停止运行。</pre></div>
            </div><a id="LNPCB591"></a><div class="props_rev_3"><a id="GUID-0C0E313A-0142-4B10-8A29-BF59AFEE52D3" name="GUID-0C0E313A-0142-4B10-8A29-BF59AFEE52D3"></a><h3 id="LNPCB-GUID-0C0E313A-0142-4B10-8A29-BF59AFEE52D3" class="sect3"><span class="enumeration_section">9.9</span>使用方法2</h3>
               <div>
                  <p>方法1在一步中做了什么，方法2做了两个。首先准备（命名和解析）动态SQL语句（不能是查询），然后执行。</p>
                  <p>使用方法2，SQL语句可以包含输入主变量和指示符变量的占位符。您可以一次PREPARE SQL语句，然后使用不同的主机变量值重复执行它。另外，如果您还没有指定MODE = ANSI，你<span class="italic">不需要</span>重新准备后COMMIT或ROLLBACK（除非你注销并重新连接）的SQL语句。<a id="d66034e821" class="indexterm-anchor"></a><a id="d66034e825" class="indexterm-anchor"></a><a id="d66034e829" class="indexterm-anchor"></a><a id="d66034e833" class="indexterm-anchor"></a><a id="d66034e837" class="indexterm-anchor"></a></p>
                  <p>PREPARE语句的语法如下：</p><pre class="oac_no_warn" dir="ltr">执行SQL <span class="italic">准备</span>来自{： <span class="italic">HOST-STRING</span> |的名称<span class="italic">STRING-LITERAL</span> } END-EXEC。</pre><p>PREPARE解析SQL语句并为其命名。</p>
                  <p><span class="italic">STATEMENT-NAME</span>是预编译器使用的标识符， <span class="italic">而不是</span>主机或程序变量，不应在COBOL语句中声明。它只是指定您要执行的预准备语句。</p>
                  <p>EXECUTE语句的语法是</p><pre class="oac_no_warn" dir="ltr">EXEC SQL EXECUTE <span class="italic">语句名称</span> [使用<span class="italic">HST-VARIABLE-LIST</span> ] END-EXEC。</pre><p>其中<span class="italic">HOST-VARIABLE-LIST</span>代表以下语法：</p><pre class="oac_no_warn" dir="ltr">： <span class="italic">HOST-VAR1</span> [： <span class="italic">INDICATOR1</span> ] [， <span class="italic">HOST-VAR2</span> [： <span class="italic">INDICATOR2</span> ]，...]
</pre><p>EXECUTE使用为每个输入主机变量提供的值执行已解析的SQL语句。在以下示例中，输入SQL语句包含占位符<span class="italic">n</span> ：</p><pre class="oac_no_warn" dir="ltr">EXEC SQL BEGIN DECLARE SECTION END-EXEC。 ...01 EMP-NUMBER PIC S9（4）COMP VALUE ZERO。 ...01 DELETE-STMT PIC X（120）值空间。 ...EXEC SQL END DECLARE SECTION END-EXEC。 01 WHERE-STMT PIC X（40）。01 SEARCH-COND PIC X（40）。...移动'从EMP中删除EMPNO =：N和'到哪里 -  STMT。显示'完成此声明的搜索条件：'。显示在哪里 -  STMT。接受搜索 -  COND。 *将SEARCH-COND连接到WHERE-STMT并存储在DELETE-STMT STRING WHERE-STMT由SIZE SEARCH-COND删除，大小由DELETE-STMT删除。 EXEC SQL PREPARE SQLSTMT FROM：DELETE-STMT END-EXEC。环。显示'输入员工编号：'没有进展。接受EMP-NUMBER。如果EMP-NUMBER = 0转到下一步。 EXEC SQL EXECUTE SQLSTMT使用：EMP-NUMBER END-EXEC。下一个。</pre><p>使用方法2，您必须在预编译时知道输入主机变量的数据类型。在最后一个示例中， <span class="italic">EMP-NUMBER</span>被声明为PIC S9（4）COMP类型。它也可以声明为PIC X（4）或COMP-1类型，因为Oracle支持所有这些数据类型转换为NUMBER内部数据类型。
                  </p>
               </div><a id="LNPCB592"></a><div class="props_rev_3"><a id="GUID-0DE2E234-D162-46C4-B736-D3E032B8BF29" name="GUID-0DE2E234-D162-46C4-B736-D3E032B8BF29"></a><h4 id="LNPCB-GUID-0DE2E234-D162-46C4-B736-D3E032B8BF29" class="sect4"><span class="enumeration_section">9.9.1</span>使用条款</h4>
                  <div>
                     <div class="section">
                        <p>完成SQL语句EXECUTE后，USING子句中的输入主机变量将替换准备好的动态SQL语句中的相应占位符。<a id="d66034e930" class="indexterm-anchor"></a></p>
                        <p>PREPARE之后的动态SQL语句中的每个占位符都必须与USING子句中的主机变量相对应。因此，如果相同的占位符在PREPARE之后的语句中出现两次或更多次，则每个外观必须对应于USING子句中的主变量。如果USING子句中的一个主变量是一个数组，则所有主变量都必须是数组。否则，只处理一条记录。</p>
                        <p>占位符的名称不需要与主变量的名称匹配。但是，PREPARE之后动态SQL语句中占位符的顺序必须与USING子句中相应主机变量的顺序匹配。</p>
                        <p>要指定NULL，可以将指示符变量与USING子句中的主变量相关联。<a id="d66034e940" class="indexterm-anchor"></a></p>
                     </div>
                     <!-- class="section" -->
                  </div>
                  <div>
                     <div class="relinfo">
                        <p><strong>相关话题</strong></p>
                        <ul>
                           <li><a href="embedded-SQL.html#GUID-CB6FDC6E-6FED-478D-8A47-B9CDE504C102">使用指标变量</a></li>
                        </ul>
                     </div>
                  </div>
               </div>
            </div><a id="LNPCB593"></a><div class="props_rev_3"><a id="GUID-7C396D57-55A0-4A5D-8A12-ECDFC088BA1B" name="GUID-7C396D57-55A0-4A5D-8A12-ECDFC088BA1B"></a><h3 id="LNPCB-GUID-7C396D57-55A0-4A5D-8A12-ECDFC088BA1B" class="sect3"><span class="enumeration_section">9.10</span>示例程序7：动态SQL方法2</h3>
               <div>
                  <p>此程序使用动态SQL方法2将两行插入EMP表，然后删除它们。<a id="d66034e979" class="indexterm-anchor"></a></p><pre class="oac_no_warn" dir="ltr">************************************************** *************** *示例程序7：动态SQL方法2 * * * *此程序使用动态SQL方法2将两行* *插入EMP表，然后删除它们。* ************************************************* ****************身份识别部门。 PROGRAM-ID。DYNSQL2。环境部门。数据部门。工作储存部分。 *包括SQL通信区域，通过* ORACLE为*程序提供运行状态信息（如错误*代码，警告标志和诊断文本）的结构。 EXEC SQL包含SQLCA END-EXEC。 *包括ORACLE通讯区域，通过* ORACLE为计划提供额外的运行状况信息*的结构。 EXEC SQL包含ORACA END-EXEC。 *选项ORACA =是必须指定使用* ORACA。 EXEC ORACLE选项（ORACA = YES）END-EXEC。 EXEC SQL BEGIN DECLARE SECTION END-EXEC。 01 USERNAME PIC X（10）值“SCOTT”。01 PASSWD PIC X（10）VALUE“TIGER”。01 DYNSTMT PIC X（80）变化。 01 EMPNO PIC S9（4）计算价值1234。01 DEPTNO1 PIC S9（4）计算值10。01 DEPTNO2 PIC S9（4）计算值20。EXEC SQL END DECLARE SECTION END-EXEC。 *需要展示计算的DECLARE VARIABLES。 01 EMPNOD PIC 9（4）。01 DEPTNO1D PIC 9（2）。01 DEPTNO2D PIC 9（2）。01 ORASLNRD PIC 9（9）。程序部门。主要。 *如果出现ORACLE错误，请分析SQLERROR。执行SQL WHENEVER SQLERROR GOTO SQLERROR END-EXEC。 *如果出现错误*，请在ORACA中保存当前SQL语句的文本。移动1到ORASTXTF。 *连接到ORACLE。 EXEC SQL CONNECT：USERNAME IDENTIFIED BY：PASSWD END-EXEC。显示“”。显示“连接到ORACLE。”。显示“”。*为不同的DYNSTMT分配一个SQL语句。两个方面*阵列和长度部分必须正确设置。注*声明包含两个主机可变平稳器，* V1和V2，实际输入主机变量必须在执行时间提供*。移动“插入EMP（EMPNO，DEPTNO）值（：V1，：V2）”到DYNSTMT-ARR。移动49到DYNSTMT-LEN。 *显示SQL语句及其当前输入主机*变量。显示DYNSTMT-ARR。移动EMPNO到EMPNOD。将DEPTNO1转移到DEPTNO1D。显示“V1 =”，EMPNOD，“V2 =”，DEPTNO1D。 *准备语句与包含SQL语句的*字符串的语句名称相关联。声明名称是*一个SQL标识符，而不是主机变量，因此*不会出现在声明部分中。 *单个声明名称可能比一般情况下准备好，*可选择不同的弦乐变量。 EXEC SQL PREPARE S FROM：DYNSTMT END-EXEC。 *执行声明执行准备的SQL声明*使用指定的输入主机变量，*在准备的*声明中为替补持有人定位*。对于每个发言者在*声明中发表的声明，在使用条款中必须是可变的。 *就是说，如果一个安置者在*声明中发生了多次，相应的变量必须在使用条款中出现多个时间。只有在声明不包含任何地方使用者的情况下，才可以使用条款。 *单个准备的声明可能会执行不止一次，*可选择使用不同的输入主机变量。 EXEC SQL EXECUTE S使用：EMPNO，：DEPTNO1 END-EXEC。 *增加EMPNO并显示新的输入主机变量。添加1到EMPNO。移动EMPNO到EMPNOD。将DEPTNO2转移到DEPTNO2D。显示“V1 =”，EMPNOD，“V2 =”，DEPTNO2D。 *重新插入EMPNO的新价值和*不同的输入主机变量，DEPTNO2。REPREPARE不是必需的。 EXEC SQL EXECUTE S使用：EMPNO，：DEPTNO2 END-EXEC。 *为DYNSTMT分配新价值。移动“从EMP中删除DEPTNO =：V1或DEPTNO =：V2”到DYNSTMT-ARR。向DYNSTMT-LEN移动50。 *显示新的SQL语句及其当前输入主机*变量。显示DYNSTMT-ARR。显示“V1 =”，DEPTNO1D，“V2 =”，DEPTNO2D。 *从新DYNSTMT获得补偿。 EXEC SQL PREPARE S FROM：DYNSTMT END-EXEC。 *执行新的S以前删除两行*插入。 EXEC SQL EXECUTE S使用：DEPTNO1，：DEPTNO2 END-EXEC。 * ROLLBACK任何待处理更改和ORACLE断开连接。 EXEC SQL ROLLBACK RELEASE END-EXEC。显示“”。显示“有一个好日子！”。显示“”。停止运行。 SQLERROR。 * ORACLE ERROR HANDLER。打印诊断文本包含*错误消息，当前SQL语句和错误位置。显示SQLERRMC。显示“IN”，ORASTXTC。移动ORASLNR到ORASLNRD。显示“在线”，ORASLNRD，“OF”，ORASFNMC。 *禁用ORACLE错误检查以避免无限循环*应该在此段内发生另一个错误。执行SQL WHENEVER SQLERROR CONTINUE END-EXEC。 *返回任何待处理的更改并断开与ORACLE的连接。 EXEC SQL ROLLBACK RELEASE END-EXEC。停止运行。</pre></div>
            </div><a id="LNPCB594"></a><div class="props_rev_3"><a id="GUID-EB61DAC0-F600-4775-9F41-838542A0B4FF" name="GUID-EB61DAC0-F600-4775-9F41-838542A0B4FF"></a><h3 id="LNPCB-GUID-EB61DAC0-F600-4775-9F41-838542A0B4FF" class="sect3"><span class="enumeration_section">9.11</span>使用方法3</h3>
               <div>
                  <p>方法3类似于方法2，但将PREPARE语句与定义和操作游标所需的语句组合在一起。这允许您的程序接受和处理查询。实际上，如果动态SQL语句是查询，则<span class="italic">必须</span>使用方法3或4。<a id="d66034e1012" class="indexterm-anchor"></a></p>
                  <p>对于方法3，必须在预编译时知道查询选择列表中的列数和输入主机变量的占位符数。但是，在运行时之前不需要指定数据库对象（如表和列）的名称（它们不能复制主变量的名称）。还可以在运行时指定限制，分组和排序查询结果（例如WHERE，GROUP BY和ORDER BY）的子句。</p>
                  <p>使用方法3，您可以使用以下嵌入式SQL语句序列：</p><pre class="oac_no_warn" dir="ltr">EXEC SQL PREPARE <span class="italic">STATEMENTNAME</span> FROM {： <span class="italic">HOST-STRING</span> | <span class="italic">STRING-LITERAL</span> } END-EXEC。用于<span class="italic">STATEMENTNAME</span> END-EXEC的EXEC SQL DECLARE <span class="italic">CURSORNAME</span> CURSOR。 EXEC SQL OPEN <span class="italic">CURSORNAME</span> [使用<span class="italic">主机 - 变量 - 列表</span> ] END-EXEC。 EXEC SQL FETCH <span class="italic">CURSORNAME进入</span> <span class="italic">主机 - 变量 - 列表</span> END-EXEC。 EXEC SQL CLOSE <span class="italic">CURSORNAME</span> END-EXEC。</pre><p>现在让我们看看每个声明的作用。</p>
               </div><a id="LNPCB595"></a><div class="props_rev_3"><a id="GUID-053F63F2-F830-4551-9D74-9DDC6D91AF27" name="GUID-053F63F2-F830-4551-9D74-9DDC6D91AF27"></a><h4 id="LNPCB-GUID-053F63F2-F830-4551-9D74-9DDC6D91AF27" class="sect4"><span class="enumeration_section">9.11.1准备</span></h4>
                  <div>
                     <div class="section">
                        <p>PREPARE语句解析动态SQL语句并为其指定名称。在以下示例中，PREPARE解析存储在字符串<span class="italic">SELECT-STMT中</span>的查询，并为其指定名称<span class="italic">SQLSTMT</span> ：<a id="d66034e1086" class="indexterm-anchor"></a><a id="d66034e1090" class="indexterm-anchor"></a></p><pre class="oac_no_warn" dir="ltr">移动'选择MGR，从EMP中的作业SAL &lt;：SALARY'到SELECT-STMT。 EXEC SQL PREPARE SQLSTMT FROM：SELECT-STMT END-EXEC。</pre><p>通常，查询WHERE子句在运行时从终端输入或由应用程序生成。</p>
                        <p>标识符<span class="italic">SQLSTMT</span> <span class="italic">不是</span>主机或程序变量，但必须是唯一的。它指定一个特定的动态SQL语句。
                        </p>
                        <p>以下陈述也是正确的：</p><pre class="oac_no_warn" dir="ltr">EXEC SQL PREPARE SQLSTMT来自'SELECT MGR，JOB from EMP WHERE SAL &lt;：SALARY'END-EXEC。</pre><p>以下使用'％'通配符的PREPARE语句也是正确的：</p><pre class="oac_no_warn" dir="ltr">移动“选择ENAME从测试中，ENAME喜欢'SMIT％'”到MY-STMT。从MY-STMT END-EXEC执行SQL预备。</pre></div>
                     <!-- class="section" -->
                  </div>
               </div><a id="LNPCB596"></a><div class="props_rev_3"><a id="GUID-CC788C72-3B90-46B6-AB44-801F45B8A93C" name="GUID-CC788C72-3B90-46B6-AB44-801F45B8A93C"></a><h4 id="LNPCB-GUID-CC788C72-3B90-46B6-AB44-801F45B8A93C" class="sect4"><span class="enumeration_section">9.11.2声明</span></h4>
                  <div>
                     <div class="section">
                        <p>DECLARE语句通过为游标指定名称并将其与特定查询相关联来定义游标。游标声明是其预编译单元的本地。继续我们的示例，DECLARE定义了一个名为<span class="italic">EMPCURSOR</span>的游标并将其与<span class="italic">SQLSTMT</span>关联，如下所示：<a id="d66034e1145" class="indexterm-anchor"></a><a id="d66034e1149" class="indexterm-anchor"></a></p><pre class="oac_no_warn" dir="ltr">SQLSTMT END-EXEC的EXEC SQL DECLARE EMPCURSOR CURSOR。</pre><p>标识符<span class="italic">SQLSTMT</span>和<span class="italic">EMPCURSOR</span> <span class="italic">不是</span>主机或程序变量，但必须是唯一的。如果使用相同的语句名称声明两个游标，Pro * COBOL会将两个游标名称视为同义。例如，如果执行语句</p><pre class="oac_no_warn" dir="ltr">EXEC SQL PREPARE SQLSTMT FROM：SELECT-STMT END-EXEC。 SQLSTMT END-EXEC的EXEC SQL DECLARE EMPCURSOR。 EXEC SQL PREPARE SQLSTMT FROM：DELETE-STMT END-EXEC。 SQLSTMT END-EXEC的EXEC SQL DECLARE DEPCURSOR。</pre><p>当您打开<span class="italic">EMPCURSOR时</span> ，您将处理存储在<span class="italic">DELETE-STMT</span>中的动态SQL语句，而不是存储在<span class="italic">SELECT-STMT</span>中的动态SQL语句<span class="italic">。</span></p>
                     </div>
                     <!-- class="section" -->
                  </div>
               </div><a id="LNPCB597"></a><div class="props_rev_3"><a id="GUID-FB63E836-2E50-4BA7-8F1E-F25678546BC0" name="GUID-FB63E836-2E50-4BA7-8F1E-F25678546BC0"></a><h4 id="LNPCB-GUID-FB63E836-2E50-4BA7-8F1E-F25678546BC0" class="sect4"><span class="enumeration_section">9.11.3</span>开放</h4>
                  <div>
                     <div class="section">
                        <p>OPEN语句分配游标，绑定输入主机变量，并执行查询，识别其活动集。OPEN还将光标定位在活动集中的第一行，并将SQLCA中SQLERRD的第三个元素保留的行处理计数归零。 USING子句中的输入主机变量替换PREPAREd动态SQL语句中的相应占位符。<a id="d66034e1204" class="indexterm-anchor"></a><a id="d66034e1208" class="indexterm-anchor"></a></p>
                        <p>在我们的示例中，OPEN分配<span class="italic">EMPCURSOR</span>并将主机变量<span class="italic">SALARY</span>分配给WHERE子句，如下所示：</p><pre class="oac_no_warn" dir="ltr">EXEC SQL OPEN EMPCURSOR使用：SALARY END-EXEC。</pre></div>
                     <!-- class="section" -->
                  </div>
               </div><a id="LNPCB598"></a><div class="props_rev_3"><a id="GUID-FB753F52-5AE2-43CB-8D1B-E502BA6BE480" name="GUID-FB753F52-5AE2-43CB-8D1B-E502BA6BE480"></a><h4 id="LNPCB-GUID-FB753F52-5AE2-43CB-8D1B-E502BA6BE480" class="sect4"><span class="enumeration_section">9.11.4</span> FETCH</h4>
                  <div>
                     <div class="section">
                        <p>FETCH语句从活动集返回一行，将选择列表中的列值分配给INTO子句中的相应主机变量，并将光标前进到下一行。当找不到更多行时，FETCH将“找不到数据”错误代码返回到SQLCA中的SQLCODE。<a id="d66034e1247" class="indexterm-anchor"></a><a id="d66034e1251" class="indexterm-anchor"></a></p>
                        <p>在我们的示例中，FETCH从活动集返回一行，并将列MGR和JOB的值分配给主变量<span class="italic">MGR-NUMBER</span>和<span class="italic">JOB-TITLE</span> ，如下所示：</p><pre class="oac_no_warn" dir="ltr">EXEC SQL FETCH EMPCURSOR INTO：MGR-NUMBER，：JOB-TITLE END-EXEC。</pre><p>主机表可以与方法3一起使用。</p>
                     </div>
                     <!-- class="section" -->
                  </div>
               </div><a id="LNPCB599"></a><div class="props_rev_3"><a id="GUID-87742536-A1AA-4BD1-9797-7816072A5013" name="GUID-87742536-A1AA-4BD1-9797-7816072A5013"></a><h4 id="LNPCB-GUID-87742536-A1AA-4BD1-9797-7816072A5013" class="sect4"><span class="enumeration_section">9.11.5</span>关闭</h4>
                  <div>
                     <div class="section">
                        <p>CLOSE语句禁用游标。关闭游标后，您将无法再使用它。在我们的示例中，CLOSE语句禁用<span class="italic">EMPCURSOR</span> ，如下所示：</p><pre class="oac_no_warn" dir="ltr">EXEC SQL CLOSE EMPCURSOR END-EXEC。</pre></div>
                     <!-- class="section" -->
                  </div>
               </div>
            </div><a id="LNPCB600"></a><div class="props_rev_3"><a id="GUID-11144CD4-BB17-4392-8497-9225D7119798" name="GUID-11144CD4-BB17-4392-8497-9225D7119798"></a><h3 id="LNPCB-GUID-11144CD4-BB17-4392-8497-9225D7119798" class="sect3"><span class="enumeration_section">9.12</span>示例程序8：动态SQL方法3</h3>
               <div>
                  <p>此程序使用动态SQL方法3从EMP表中检索给定部门中所有员工的名称。<a id="d66034e1328" class="indexterm-anchor"></a></p><pre class="oac_no_warn" dir="ltr">************************************************** *************** *示例程序8：动态SQL方法3 * * * *此程序使用动态SQL方法3来检索给定部门中所有员工的姓名* * EMP表。* ************************************************* ****************身份识别部门。 PROGRAM-ID。DYNSQL3。环境部门。数据部门。工作储存部分。 *包括SQL通信区域，通过* ORACLE为*程序提供运行状态信息（如错误*代码，警告标志和诊断文本）的结构。 EXEC SQL包含SQLCA END-EXEC。 *包括ORACLE通讯区域，通过* ORACLE为计划提供额外的运行状况信息*的结构。 EXEC SQL包含ORACA END-EXEC。 *必须指定ORACA = YES选项才能使用* ORACA。 EXEC ORACLE选项（ORACA = YES）END-EXEC。 EXEC SQL BEGIN DECLARE SECTION END-EXEC。 01 USERNAME PIC X（10）值“SCOTT”。01 PASSWD PIC X（10）VALUE“TIGER”。01 DYNSTMT PIC X（80）变化。 01 ENAME PIC X（10）。01 DEPTNO PIC S9999计算价值10。EXEC SQL END DECLARE SECTION END-EXEC。 *需要展示计算的DECLARE VARIABLES。 01 DEPTNOD PIC 9（2）。01 ENAMED PIC X（10）。01 SQLERRD3 PIC 9（2）。01 ORASLNRD PIC 9（4）。程序部门。主要。 *如果出现ORACLE错误，请分析SQLERROR。执行SQL WHENEVER SQLERROR转到SQLERROR END-EXEC。 *如果出现错误*，请在ORACA中保存当前SQL语句的文本。移动1到ORASTXTF。 *连接到ORACLE。 EXEC SQL CONNECT：USERNAME IDENTIFIED BY：PASSWD END-EXEC。显示“”。显示“连接到ORACLE。”。显示“”。*为不同的DYNSTMT分配一个SQL查询。*阵列和长度部分必须正确设置。请注意*声明包含一个主机变量PLACEHOLDER，V1，*因为必须在开放时提供实际输入主机变量*。移动“从EMP到DEPTNO = V1的选择ENAME”到DYNSTMT-ARR。移动40到DYNSTMT-LEN。 *显示SQL语句及其当前输入主机*可变。显示DYNSTMT-ARR。转移到DEPTNO。显示“V1 =”，DEPTNOD。显示“”。显示“员工”。显示“--------”。*准备声明表示包含带有选择声明的*字符串的声明名称。声明名称，*必须是独特的，是一个SQL标识符，而不是主机*可变，因此不会出现在声明部分中。 EXEC SQL PREPARE S FROM：DYNSTMT END-EXEC。 *声明声明是一份准备好的声明*声明。光标名称，如声明名称，*未出现在声明部分中。用于S END-EXEC的EXEC SQL DECLARE C CURSOR。 *开放式声明使用指定的输入主机变量评估准备的主动设置*查询*在准备的*查询中为替补持有人定位*。对于每个发言者在*声明中发表的声明，在使用条款中必须是可变的。 *就是说，如果一个安置者在*声明中发生了多次，相应的变量必须在使用条款中出现多个*时间。只有在声明不包含任何地方使用者的情况下，才可以使用条款。 *在FETCH的准备工作中，OPEN放置在活动集的第一行*的游标。 *单个声明的游标可能会一次打开，*可选择使用不同的输入主机变量。 EXEC SQL OPEN C使用：DEPTNO END-EXEC。 *当所有行都被*回收时，分支都没有找到。 EXEC SQL WHENEVER未找到去找不到END-EXEC。 GetRows的。 * FETCH声明将当前的选择列表*行放入由INTO条款指定的变量中，然后*将光标推进到下一行。如果有更多*选择列表比输出主机变量更多，则额外*场不返回。指定更多输出主机*变量列表中的变量导致ORACLE错误。 EXEC SQL FETCH C INTO：ENAME END-EXEC。移动ENAME到ENAMED。显示已启用。 *检测到未发现的情况。转到GETROWS。未找到。将SQLERRD（3）移到SQLERRD3。显示“”。显示“QUERY RETURNED”，SQLERRD3，“ROW（S）。”。*关闭声明发布与* CURSOR相关的资源。 EXEC SQL CLOSE C END-EXEC。 *承诺任何待处理的更改并断开与ORACLE的连接。 EXEC SQL COMMIT RELEASE END-EXEC。显示“”。显示“有一个好日子！”。显示“”。停止运行。 SQLERROR。 * ORACLE ERROR HANDLER。打印诊断文本包含*错误消息，当前SQL语句和错误位置。显示SQLERRMC。显示“IN”，ORASTXTC。移动ORASLNR到ORASLNRD。显示“在线”，ORASLNRD，“OF”，ORASFNMC。 *禁用ORACLE错误检查以避免无限循环*应该在此段内发生另一个错误。执行SQL WHENEVER SQLERROR CONTINUE END-EXEC。 *与游行相关的释放资源。 EXEC SQL CLOSE C END-EXEC。 *返回任何待处理的更改并断开与ORACLE的连接。 EXEC SQL ROLLBACK RELEASE END-EXEC。停止运行。</pre></div>
            </div><a id="LNPCB601"></a><div class="props_rev_3"><a id="GUID-FBFBAED9-1541-4E4E-BA9F-192582B7A7E2" name="GUID-FBFBAED9-1541-4E4E-BA9F-192582B7A7E2"></a><h3 id="LNPCB-GUID-FBFBAED9-1541-4E4E-BA9F-192582B7A7E2" class="sect3"><span class="enumeration_section">9.13</span>使用Oracle方法4</h3>
               <div>
                  <p>本节仅提供概述。有关详细信息，请参阅<a href="Oracle-dynamic-SQL-method-4.html#GUID-C6256169-5928-466C-B7C7-960D20705EED">Oracle Dynamic SQL：方法4</a> 。
                  </p>
                  <p>Oracle方法4不支持LOB。对于LOB应用程序和所有其他新应用程序使用ANSI动态SQL。</p>
                  <p>您的程序无法使用方法3处理某种动态SQL语句。如果输入主机变量的选择列表项或占位符的数量在运行时之前是未知的，则程序必须使用描述符。<span class="italic">描述符</span>是程序和Oracle用于在动态SQL语句中保存变量的完整描述的内存区域。<a id="d66034e1369" class="indexterm-anchor"></a><a id="d66034e1373" class="indexterm-anchor"></a></p>
                  <p>回想一下，对于多行查询，您将FETCH选择的列值INTO到已声明的输出主机变量列表中。如果选择列表未知，则INTO子句无法在预编译时建立主机变量列表。例如，您知道以下查询返回两个列值：</p><pre class="oac_no_warn" dir="ltr">EXEC SQL SELECT ENAME，EMPNO来自EMP，其中DEPTNO =：DEPT-NUMBER END-EXEC。</pre><p>但是，如果您让用户定义选择列表，您可能不知道查询将返回多少列值。</p>
               </div><a id="LNPCB602"></a><div class="props_rev_3"><a id="GUID-6BFE1096-89C4-42BA-89CC-D37F6FBF57BB" name="GUID-6BFE1096-89C4-42BA-89CC-D37F6FBF57BB"></a><h4 id="LNPCB-GUID-6BFE1096-89C4-42BA-89CC-D37F6FBF57BB" class="sect4"><span class="enumeration_section">9.13.1</span>需要SQLDA</h4>
                  <div>
                     <div class="section">
                        <p>要处理这种动态查询，您的程序必须发出DESCRIBE SELECT LIST命令并声明一个名为SQL Descriptor Area（SQLDA）的数据结构。因为它包含查询选择列表中列的描述，所以此结构也称为<span class="italic">选择描述符</span> 。<a id="d66034e1411" class="indexterm-anchor"></a><a id="d66034e1415" class="indexterm-anchor"></a><a id="d66034e1417" class="indexterm-anchor"></a><a id="d66034e1419" class="indexterm-anchor"></a><a id="d66034e1423" class="indexterm-anchor"></a></p>
                        <p>同样，如果动态SQL语句包含输入主机变量的未知数量的占位符，则USING子句无法在预编译时建立主机变量列表。</p>
                        <p>要处理动态SQL语句，程序必须发出DESCRIBE BIND VARIABLES命令并声明另一种称为<span class="italic">绑定描述符</span>的SQLDA，以保存输入主机变量的占位符的描述。（输入主变量也称为<span class="italic">绑定变量</span> 。）<a id="d66034e1437" class="indexterm-anchor"></a></p>
                        <p>如果您的程序有多个活动的SQL语句（例如，它可能已经为两个或多个游标使用了OPEN），则每个语句都必须有自己的SQLDAs语句。但是，非并发游标可以重用SQLDA。程序中的SQLDA数量没有设置限制。</p>
                     </div>
                     <!-- class="section" -->
                  </div>
               </div><a id="LNPCB603"></a><div class="props_rev_3"><a id="GUID-378C600E-53B9-4508-B188-DF05BECD2E21" name="GUID-378C600E-53B9-4508-B188-DF05BECD2E21"></a><h4 id="LNPCB-GUID-378C600E-53B9-4508-B188-DF05BECD2E21" class="sect4"><span class="enumeration_section">9.13.2</span> DESCRIBE声明</h4>
                  <div>
                     <div class="section">
                        <p>DESCRIBE初始化描述符以保存选择列表项或输入主变量的描述。</p>
                        <p>如果提供选择描述符，则DESCRIBE SELECT LIST语句将检查准备好的动态查询中的每个选择列表项，以确定其名称，数据类型，约束，长度，比例和精度。然后它将此信息存储在选择描述符中。<a id="d66034e1468" class="indexterm-anchor"></a></p>
                        <p>如果提供绑定描述符，则DESCRIBE BIND VARIABLES语句将检查准备好的动态SQL语句中的每个占位符，以确定其名称，长度以及其关联的输入主机变量的数据类型。然后，它将此信息存储在绑定描述符中供您使用。例如，您可以使用占位符名称来提示用户输入主机变量的值。<a id="d66034e1474" class="indexterm-anchor"></a></p>
                     </div>
                     <!-- class="section" -->
                  </div>
               </div><a id="LNPCB604"></a><div class="props_rev_3"><a id="GUID-DA600F4E-C799-4D15-872C-8CA092EB44FC" name="GUID-DA600F4E-C799-4D15-872C-8CA092EB44FC"></a><h4 id="LNPCB-GUID-DA600F4E-C799-4D15-872C-8CA092EB44FC" class="sect4"><span class="enumeration_section">9.13.3</span> SQLDA内容</h4>
                  <div>
                     <div class="section">
                        <p>SQLDA是一种主机程序数据结构，它包含选择列表项或输入主机变量的描述。<a id="d66034e1504" class="indexterm-anchor"></a></p>
                        <p>虽然SQLDAs在主机语言中有所不同，但通用选择SQLDA包含有关查询选择列表的以下信息：<a id="d66034e1508" class="indexterm-anchor"></a><a id="d66034e1512" class="indexterm-anchor"></a></p>
                        <ul style="list-style-type:disc">
                           <li>
                              <p>可以DESCRIBEd的最大列数</p>
                           </li>
                           <li>
                              <p>DESCRIBE找到的实际列数</p>
                           </li>
                           <li>
                              <p>用于存储列值的缓冲区地址</p>
                           </li>
                           <li>
                              <p>列值的长度</p>
                           </li>
                           <li>
                              <p>列值的数据类型</p>
                           </li>
                           <li>
                              <p>指标变量值的地址</p>
                           </li>
                           <li>
                              <p>用于存储列名称的缓冲区地址</p>
                           </li>
                           <li>
                              <p>用于存储列名称的缓冲区大小</p>
                           </li>
                           <li>
                              <p>列名的当前长度</p>
                           </li>
                        </ul>
                        <p>通用绑定SQLDA包含有关SQL语句中输入主机变量的以下信息：</p>
                        <ul style="list-style-type:disc">
                           <li>
                              <p>可以DESCRIBEd的最大占位符数</p>
                           </li>
                           <li>
                              <p>DESCRIBE找到的实际占位符数</p>
                           </li>
                           <li>
                              <p>输入主变量的地址</p>
                           </li>
                           <li>
                              <p>输入主机变量的长度</p>
                           </li>
                           <li>
                              <p>输入主机变量的数据类型</p>
                           </li>
                           <li>
                              <p>指标变量的地址</p>
                           </li>
                           <li>
                              <p>用于存储占位符名称的缓冲区地址</p>
                           </li>
                           <li>
                              <p>用于存储占位符名称的缓冲区大小</p>
                           </li>
                           <li>
                              <p>当前占位符名称的长度</p>
                           </li>
                           <li>
                              <p>用于存储指示符变量名称的缓冲区地址</p>
                           </li>
                           <li>
                              <p>用于存储指示符变量名称的缓冲区大小</p>
                           </li>
                           <li>
                              <p>指标变量名称的当前长度</p>
                           </li>
                        </ul>
                     </div>
                     <!-- class="section" -->
                  </div>
               </div><a id="LNPCB605"></a><div class="props_rev_3"><a id="GUID-A81F5DFC-C3B4-4DA1-9676-3E9D07E51F34" name="GUID-A81F5DFC-C3B4-4DA1-9676-3E9D07E51F34"></a><h4 id="LNPCB-GUID-A81F5DFC-C3B4-4DA1-9676-3E9D07E51F34" class="sect4"><span class="enumeration_section">9.13.4</span>实施方法4</h4>
                  <div>
                     <p>使用方法4，通常使用以下嵌入式SQL语句序列：</p><pre class="oac_no_warn" dir="ltr">来自{： <span class="italic">HOST-STRING</span> |的EXEC SQL PREPARE <span class="italic">语句名称</span> <span class="italic">STRING-LITERAL</span> } END-EXE EXEC SQL DECLARE <span class="italic">CURSOR-NAME</span> CURSOR for <span class="italic">STATEMENT-NAME</span> END-EXEC。 EXEC SQL描述<span class="italic">语句名称的</span>绑定变量到<span class="italic">绑定描述符名称</span> END-EXEC。 EXEC SQL OPEN <span class="italic">CURSOR-NAME</span> [使用描述<span class="italic">符绑定</span>描述<span class="italic">符名称</span> ] END-EXEC。 EXEC SQL DESCRIBE [SELECT LIST FOR] <span class="italic">STATEMENT-NAME</span> INTO <span class="italic">SELECT-DESCRIPTOR-NAME</span> END-EXEC。 EXEC SQL FETCH <span class="italic">CURSOR-NAME</span>使用DESCRIPTOR <span class="italic">SELECT-DESCRIPTOR-NAME</span> END-EXEC。 EXEC SQL CLOSE <span class="italic">CURSOR-NAME</span> END-EXEC。</pre><p>选择和绑定描述符不需要串联工作。如果查询选择列表中的列数已知，但输入主变量的占位符数未知，则可以使用方法4 OPEN语句和以下方法3 FETCH语句：</p><pre class="oac_no_warn" dir="ltr">EXEC SQL FETCH <span class="italic">EMPCURSOR</span> INTO： <span class="italic">HOST-VARIABLE-LIST</span> END-EXEC。</pre><p>相反，如果已知输入主变量的占位符数，但选择列表中的列数未知，则可以将以下方法3 OPEN语句与方法4 FETCH语句一起使用：</p><pre class="oac_no_warn" dir="ltr">EXEC SQL OPEN <span class="italic">CURSORNAME</span> [使用<span class="italic">主机 - 变量 - 列表</span> ] END-EXEC。</pre><p>请注意，EXECUTE可用于方法4的非查询。</p>
                  </div>
               </div>
            </div><a id="LNPCB606"></a><div class="props_rev_3"><a id="GUID-D38FED05-3568-4E54-91B7-406F25000D1B" name="GUID-D38FED05-3568-4E54-91B7-406F25000D1B"></a><h3 id="LNPCB-GUID-D38FED05-3568-4E54-91B7-406F25000D1B" class="sect3"><span class="enumeration_section">9.14</span>使用DECLARE STATEMENT语句</h3>
               <div>
                  <div class="section">
                     <p>使用方法2,3和4，您可能需要使用该语句<a id="d66034e1701" class="indexterm-anchor"></a><a id="d66034e1705" class="indexterm-anchor"></a><a id="d66034e1709" class="indexterm-anchor"></a><a id="d66034e1713" class="indexterm-anchor"></a></p><pre class="oac_no_warn" dir="ltr">EXEC SQL [AT <span class="italic">dbname</span> ] DECLARE <span class="italic">statementname</span> STATEMENT END-EXEC。</pre><p>其中<span class="italic">dbname</span>和<span class="italic">statementname</span>是Pro * COBOL使用的标识符， <span class="italic">而不是</span>主机或程序变量。
                     </p>
                     <p>DECLARE STATEMENT声明动态SQL语句的名称，以便PREPARE，EXECUTE，DECLARE CURSOR和DESCRIBE可以引用该语句。如果要在非默认数据库中执行动态SQL语句，则需要它。使用方法2的示例如下：<a id="d66034e1738" class="indexterm-anchor"></a><a id="d66034e1742" class="indexterm-anchor"></a></p><pre class="oac_no_warn" dir="ltr">EXEC SQL AT <span class="italic">remotedb</span> DECLARE <span class="italic">sqlstmt</span> STATEMENT END-EXEC。 EXEC SQL PREPARE <span class="italic">sqltmt</span> FROM： <span class="italic">sqlstring</span> END-EXEC。 EXEC SQL EXECUTE <span class="italic">sqlstm</span> t END-EXEC。</pre><p>在示例中， <span class="italic">remotedb</span>告诉Oracle在哪里执行SQL语句。
                     </p>
                     <p>对于方法3和4，如果DECLARE CURSOR语句在PREPARE语句之前，则还需要DECLARE STATEMENT，如以下示例所示：</p><pre class="oac_no_warn" dir="ltr">EXEC SQL DECLARE <span class="italic">sqlstmt</span> STATEMENT END-EXEC。用于<span class="italic">sqlstmt</span> END-EXEC的EXEC SQL DECLARE <span class="italic">empcursor</span> CURSOR。 EXEC SQL PREPARE <span class="italic">sqlstmt</span> FROM： <span class="italic">sqlstring</span> END-EXEC。</pre><p>通常的陈述顺序是</p><pre class="oac_no_warn" dir="ltr">EXEC SQL PREPARE <span class="italic">sqlstmt</span> FROM： <span class="italic">sqlstring</span> END-EXEC。用于<span class="italic">sqlstmt</span> END-EXEC的EXEC SQL DECLARE <span class="italic">empcursor</span> CURSOR。</pre></div>
                  <!-- class="section" -->
               </div>
            </div><a id="LNPCB607"></a><div class="props_rev_3"><a id="GUID-0F95D426-2256-4EF5-B022-0AD06C2AC4CA" name="GUID-0F95D426-2256-4EF5-B022-0AD06C2AC4CA"></a><h3 id="LNPCB-GUID-0F95D426-2256-4EF5-B022-0AD06C2AC4CA" class="sect3"><span class="enumeration_section">9.15</span>使用主机表</h3>
               <div>
                  <div class="section">
                     <p>在静态和动态SQL中使用主机表是类似的。例如，要将输入主机表与动态SQL方法2一起使用，请使用语法<a id="d66034e1829" class="indexterm-anchor"></a><a id="d66034e1833" class="indexterm-anchor"></a></p><pre class="oac_no_warn" dir="ltr">EXEC SQL EXECUTE <span class="italic">statementname</span> USING： <span class="italic">HOST-TABLE-LIST</span> END-EXEC。</pre><p>其中<span class="italic">HOST-TABLE-LIST</span>包含一个或多个主机表。使用方法3，使用以下语法：</p><pre class="oac_no_warn" dir="ltr">OPEN <span class="italic">cursorname</span>使用： <span class="italic">HOST-TABLE-LIST</span> END-EXEC。</pre><p>要使用方法3的输出主机表，请使用以下语法：</p><pre class="oac_no_warn" dir="ltr">FETCH <span class="italic">cursorname</span> INTO： <span class="italic">HOST-TABLE-LIST</span> END-EXEC。</pre><p>使用方法4，必须使用可选的FOR子句告诉Oracle输入或输出主机表的大小。要了解如何完成此操作，请参阅主机语言补充。<a id="d66034e1870" class="indexterm-anchor"></a></p>
                  </div>
                  <!-- class="section" -->
               </div>
            </div><a id="LNPCB608"></a><div class="props_rev_3"><a id="GUID-E4F3236E-B588-41FF-8A2F-DFB111F214DB" name="GUID-E4F3236E-B588-41FF-8A2F-DFB111F214DB"></a><h3 id="LNPCB-GUID-E4F3236E-B588-41FF-8A2F-DFB111F214DB" class="sect3"><span class="enumeration_section">9.16</span>使用PL / SQL</h3>
               <div>
                  <p>Pro * COBOL将PL / SQL块视为单个SQL语句。因此，像SQL语句一样，PL / SQL块可以存储在字符串主变量或文字中。将PL / SQL块存储在字符串中时，省略关键字EXEC SQL EXECUTE，关键字END-EXEC和语句终止符。<a id="d66034e1898" class="indexterm-anchor"></a></p>
                  <p>但是，Pro * COBOL处理SQL和PL / SQL的方式有两点不同：</p>
                  <ul style="list-style-type:disc">
                     <li>
                        <p>所有PL / SQL主机变量都应以与输入主机变量相同的方式处理，无论它们是输入还是输出主变量（或两者）。</p>
                     </li>
                     <li>
                        <p>您无法从PL / SQL块进行FETCH，因为它可能包含任意数量的SQL语句。但是，您可以使用游标变量实现类似的功能。</p>
                     </li>
                  </ul>
               </div><a id="LNPCB609"></a><div class="props_rev_3"><a id="GUID-948ACE8D-94F6-40F5-8DAC-F7308FA7A534" name="GUID-948ACE8D-94F6-40F5-8DAC-F7308FA7A534"></a><h4 id="LNPCB-GUID-948ACE8D-94F6-40F5-8DAC-F7308FA7A534" class="sect4"><span class="enumeration_section">9.16.1</span>使用方法1</h4>
                  <div>
                     <p>如果PL / SQL块不包含主机变量，则可以使用方法1以常规方式执行PL / SQL字符串。<a id="d66034e1933" class="indexterm-anchor"></a></p>
                  </div>
               </div><a id="LNPCB610"></a><div class="props_rev_3"><a id="GUID-0B7E090E-038E-478F-801E-4F8D4341E5CB" name="GUID-0B7E090E-038E-478F-801E-4F8D4341E5CB"></a><h4 id="LNPCB-GUID-0B7E090E-038E-478F-801E-4F8D4341E5CB" class="sect4"><span class="enumeration_section">9.16.2</span>使用方法2</h4>
                  <div>
                     <p>如果PL / SQL块包含已知数量的输入和输出主机变量，则可以使用方法2以常规方式PREPARE和EXECUTE PL / SQL字符串。<a id="d66034e1961" class="indexterm-anchor"></a></p>
                     <p>您必须将<span class="italic">所有</span>主变量放在USING子句中。完成PL / SQL字符串EXECUTE后，USING子句中的主机变量会在PREPARE之后替换字符串中的相应占位符。虽然Pro * COBOL将所有PL / SQL主机变量视为输入主机变量，但值是正确分配的。输入（程序）值分配给输入主变量，输出（列）值分配给输出主变量。
                     </p>
                     <p>PREPARE之后的PL / SQL字符串中的每个占位符必须与USING子句中的主机变量相对应。因此，如果相同的占位符在PREPAREd字符串中出现两次或多次，则每个外观必须对应于USING子句中的主变量。<a id="d66034e1972" class="indexterm-anchor"></a></p>
                  </div>
               </div><a id="LNPCB611"></a><div class="props_rev_3"><a id="GUID-67E1BDF0-D62B-433E-913F-C1E8518FCA23" name="GUID-67E1BDF0-D62B-433E-913F-C1E8518FCA23"></a><h4 id="LNPCB-GUID-67E1BDF0-D62B-433E-913F-C1E8518FCA23" class="sect4"><span class="enumeration_section">9.16.3</span>使用方法3</h4>
                  <div>
                     <p>方法2和3是相同的，除了方法3允许完成FETCH。由于您无法从PL / SQL块进行FETCH，因此请改用方法2。<a id="d66034e2001" class="indexterm-anchor"></a></p>
                  </div>
               </div><a id="LNPCB612"></a><div class="props_rev_3"><a id="GUID-EC327B9E-A070-4BC1-94D9-AF02F9346976" name="GUID-EC327B9E-A070-4BC1-94D9-AF02F9346976"></a><h4 id="LNPCB-GUID-EC327B9E-A070-4BC1-94D9-AF02F9346976" class="sect4"><span class="enumeration_section">9.16.4</span>使用方法4</h4>
                  <div>
                     <p>如果PL / SQL块包含未知数量的输入或输出主机变量，则必须使用方法4。<a id="d66034e2029" class="indexterm-anchor"></a></p>
                     <p>要使用方法4，请为所有输入和输出主机变量设置一个绑定描述符。执行DESCRIBE BIND VARIABLES将有关输入<span class="italic">和</span>输出主机变量的信息存储在绑定描述符中。因为您使用与输入主机变量关联的方法引用所有PL / SQL主机变量，所以执行DESCRIBE SELECT LIST无效。
                     </p>
                     <p>在主机语言补充中详细介绍了使用方法4绑定描述符。</p>
                     <p>请注意，在动态SQL方法4中，主机数组不能绑定到具有“table”类型参数的PL / SQL过程。</p>
                  </div>
               </div><a id="LNPCB613"></a><div class="props_rev_3"><a id="GUID-B6F7FD7F-1DAD-4BC9-A7D0-515849B9C629" name="GUID-B6F7FD7F-1DAD-4BC9-A7D0-515849B9C629"></a><h4 id="LNPCB-GUID-B6F7FD7F-1DAD-4BC9-A7D0-515849B9C629" class="sect4"><span class="enumeration_section">9.16.5</span>注意</h4>
                  <div>
                     <p>不要在将动态处理的PL / SQL块中使用ANSI样式的注释（ -   -  ...），因为忽略了行尾字符。因此，ANSI样式的注释扩展到块的末尾，而不仅仅是行的末尾。相反，使用C风格的评论（/ * ...* /）。<a id="d66034e2066" class="indexterm-anchor"></a></p>
                  </div>
               </div>
            </div><a id="LNPCB615"></a><a id="LNPCB614"></a><div class="props_rev_3"><a id="GUID-0AD16F5E-7039-4C35-90F1-5543AE675329" name="GUID-0AD16F5E-7039-4C35-90F1-5543AE675329"></a><h3 id="LNPCB-GUID-0AD16F5E-7039-4C35-90F1-5543AE675329" class="sect3"><span class="enumeration_section">9.17</span>动态SQL语句缓存</h3>
               <div>
                  <p>语句缓存是指为每个会话提供和管理语句缓存的功能。在服务器中，这意味着可以使用游标而无需再次解析语句。可以在预编译器应用程序中启用语句缓存，这将有助于提高依赖于动态SQL语句的所有应用程序的性能。通过消除在重用时解析动态语句的开销来实现性能改进。预编译器应用程序用户可以使用新的命令行选项stmt_cache（对于语句高速缓存大小）来获得此性能改进，这将启用动态语句的语句高速缓存。通过启用新选项，将在会话创建时创建语句缓存。缓存仅适用于动态语句，静态语句的游标缓存与新功能共存。</p>
                  <p>命令行选项<code class="codeph">stmt_cache</code>可以给出0到65535范围内的任何值。默认情况下禁用语句缓存（值0）。可以将<code class="codeph">stmt_cache</code>选项设置为保存应用程序中预期的不同动态SQL语句数。
                  </p>
                  <div class="example" id="GUID-0AD16F5E-7039-4C35-90F1-5543AE675329__GUID-388EADE2-F7E2-4FCC-9244-2535CDBACCF5">
                     <p class="titleinexample">示例9-1使用stmt_cache选项</p>
                     <p>此示例演示了<code class="codeph">stmt_cache</code>选项的<code class="codeph">stmt_cache</code> 。在此程序中，您将行插入表中，并使用循环中的光标选择插入的行。使用stmt_cache选项预编译此程序时，与正常的预编译相比，性能会提高。
                     </p><pre class="oac_no_warn" dir="ltr">************************************************** *************** * stmtcache：* * * *注意：* *当此程序用于测量性能和* *而不使用stmt_cache选项时，请在*中执行以下更改*节目，* * 1。将ROWSCNT增加到高值，比如10000。* * 2。删除所有DISPLAY语句，通常是程序* *占程序执行总时间的重要部分。* ************************************************* ****************身份识别部门。 PROGRAM-ID。 stmtcache。环境部门。配置部分。数据部门。工作储存部分。 * EMBEDDED COBOL（文件“STMTCACHE.PCO”）EXEC SQL BEGIN DECLARE SECTION END-EXEC。 01 USERNAME PIC X（10）变化。 01 PASSWD PIC X（10）变化。 01 DYNSTMT PIC X（100）变化。 01 DYNSTMT2 PIC X（100）变化。 01 ENAME PIC X（10）。01 COMM PIC X（9）。EXEC SQL END DECLARE SECTION END-EXEC。 01 ROWSCNT PIC 9（4）COMP值10。01 LOOPNO PIC 9（4）。01 STRINGFIELDS。 02 STR PIC X（18）变化。 EXEC SQL包含SQLCA END-EXEC。程序部门。 BEGIN-PGM。执行SQL WHENEVER SQLERROR执行SQL-ERROR END-EXEC。表演登录。移动“插入奖励（ENAME，COMM）值（：A，：B）”到DYNSTMT-ARR。移动53到DYNSTMT-LEN。显示“插入”，ROWSCNT，“行进入BONUS表。”。执行INSDATA从1比1到LOOPNO&gt; ROWSCNT改变循环。显示“”。显示“从BONUS获取插入的行。”。显示“ENAME COMM”。移动“选择ENAME，COMM从奖励，其中COMM =：A”到DYNSTMT2-ARR。移动43到DYNSTMT2-LEN。移动1到LOOPNO。 *用于准备和获取ROWSCNT次数FETCHDATA的循环。 *在循环中进行准备，以便* stmt_caching的优势可见EXEC SQL PREPARE S2 FROM：DYNSTMT2 END-EXEC。用于S2 END-EXEC的EXEC SQL DECLARE C1游标。 EXEC SQL OPEN C1使用：LOOPNO END-EXEC。 EXEC SQL WHENEVER未找到去找不到END-EXEC。 GetRows的。 *关闭光标，以便* stmt_cache EXEC SQL FETCH C1 INTO：ENAME，：COMM END-EXEC不需要重新分析。显示ENAME，COMM。转到GETROWS。未找到。 EXEC SQL CLOSE C1 END-EXEC。 COMPUTE LOOPNO = LOOPNO + 1。IF LOOPNO &lt;= ROWSCNT然后转到FETCHDATA END-IF。 EXEC SQL ROLLBACK工作发布END-EXEC。停止运行。登录。将“scott”移至USERNAME-ARR。移动5到USERNAME-LEN。将“老虎”移到PASSWD-ARR。移动5到PASSWD-LEN。 EXEC SQL CONNECT：USERNAME IDENTIFIED BY：PASSWD END-EXEC。 *填充主变量并插入表INSDATA。 EXEC SQL PREPARE S1 FROM：DYNSTMT END-EXEC。移动“”到STR。 STRING“EMP_”，LOOPNO进入STR END-STRING。移动STR到ENAME。将LOOPNO移至COMM。 EXEC SQL EXECUTE S1使用：ENAME，：COMM END-EXEC。 *处理SQL错误条件SQL-ERROR。执行SQL WHENEVER SQLERROR CONTINUE END-EXEC。显示“”。显示“ORACLE ERROR DETECTED：”。显示“”。显示SQLERRMC。 EXEC SQL ROLLBACK工作发布END-EXEC。停止运行。</pre></div>
                  <!-- class="example" -->
               </div>
            </div>
         </div>
      </article>
   </body>
</html>