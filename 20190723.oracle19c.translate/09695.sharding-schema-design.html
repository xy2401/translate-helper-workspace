<html lang="en-us" dir="ltr" xml:lang="en-us">
   <head>
      <meta http-equiv="Content-Type" content="text/html; charset=utf-8"></meta>
      <meta name="viewport" content="width=device-width, initial-scale=1"></meta>
      <meta http-equiv="X-UA-Compatible" content="IE=edge"></meta>
      <meta name="abstract" content="To obtain the benefits of sharding, the schema of a sharded database should be designed in a way that maximizes the number of database requests executed on a single shard."></meta>
      <meta name="description" content="To obtain the benefits of sharding, the schema of a sharded database should be designed in a way that maximizes the number of database requests executed on a single shard."></meta>
      <title>分片数据库模式设计</title>
      <meta property="og:site_name" content="Oracle Help Center"></meta>
      <meta property="og:title" content="Using Oracle Sharding"></meta>
      <meta property="og:description" content="To obtain the benefits of sharding, the schema of a sharded database should be designed in a way that maximizes the number of database requests executed on a single shard."></meta>
      <link rel="stylesheet" href="/sp_common/book-template/ohc-book-template/css/book.css"></link>
      <link rel="shortcut icon" href="/sp_common/book-template/ohc-common/img/favicon.ico"></link>
      <meta name="application-name" content="Using Oracle Sharding"></meta>
      <meta name="generator" content="DITA Open Toolkit version 1.8.5 (Mode = doc)"></meta>
      <meta name="plugin" content="SP_docbuilder HTML plugin release 18.2.2"></meta>
      <link rel="alternate" href="using-oracle-sharding.pdf" title="PDF File" type="application/pdf"></link>
      <meta name="robots" content="all"></meta>
      <link rel="schema.dcterms" href="http://purl.org/dc/terms/"></link>
      <meta name="dcterms.created" content="2019-02-14T12:19:13-08:00"></meta>
      <meta name="dcterms.title" content="Using Oracle Sharding"></meta>
      <meta name="dcterms.dateCopyrighted" content="2018, 2019"></meta>
      <meta name="dcterms.category" content="database"></meta>
      <meta name="dcterms.identifier" content="E87088-04"></meta>
      
      <meta name="dcterms.product" content="en/database/oracle/oracle-database/19"></meta>
      
      <link rel="prev" href="sharding-overview.html" title="Previous" type="text/html"></link>
      <link rel="next" href="sharding-physical-organization.html" title="Next" type="text/html"></link>
      <script>
        document.write('<style type="text/css">');
        document.write('body > .noscript, body > .noscript ~ * { visibility: hidden; }');
        document.write('</style>');
     </script>
      <script src="/sp_common/book-template/requirejs/require.js" data-main="/sp_common/book-template/ohc-book-template/js/book-config"></script>
      <script>
            if (window.require === undefined) {
                document.write('<script data-main="sp_common/book-template/ohc-book-template/js/book-config" src="sp_common/book-template/requirejs/require.js"><\/script>');
                document.write('<link href="sp_common/book-template/ohc-book-template/css/book.css" rel="stylesheet"/>');
            }
        </script>
      <script type="application/json" id="ssot-metadata">{"primary":{"category":{"short_name":"database","element_name":"Database","display_in_url":true},"suite":{"short_name":"oracle","element_name":"Oracle","display_in_url":true},"product_group":{"short_name":"not-applicable","element_name":"Not applicable","display_in_url":false},"product":{"short_name":"oracle-database","element_name":"Oracle Database","display_in_url":true},"release":{"short_name":"19","element_name":"Release 19","display_in_url":true}}}</script>
      
    <meta name="dcterms.isVersionOf" content="SHARD"></meta>
    <meta name="dcterms.release" content="Release 19"></meta>
  </head>
   <body dir="ltr">
      <div class="noscript alert alert-danger text-center" role="alert">
         <a href="sharding-overview.html" class="pull-left"><span class="glyphicon glyphicon-chevron-left" aria-hidden="true"></span>上一页</a> <a href="sharding-physical-organization.html" class="pull-right">下一页<span class="glyphicon glyphicon-chevron-right" aria-hidden="true"></span></a> <span class="fa fa-exclamation-triangle" aria-hidden="true"></span>必须启用JavaScript才能正确显示此内容</div>
      <article>
         <header>
            <ol class="breadcrumb" vocab="http://schema.org/" typeof="BreadcrumbList">
               <li property="itemListElement" typeof="ListItem"><a href="index.html" property="item" typeof="WebPage"><span property="name">使用Oracle Sharding</span></a></li>
               <li class="active" property="itemListElement" typeof="ListItem">分片数据库模式设计</li>
            </ol>
            <a id="GUID-1B8DAEE1-A662-4516-9EA9-04FF711211C3" name="GUID-1B8DAEE1-A662-4516-9EA9-04FF711211C3"></a>
            
            <h2 id="SHARD-GUID-1B8DAEE1-A662-4516-9EA9-04FF711211C3" class="sect2"><span class="enumeration_chapter">2</span> Sharded Database Schema Design</h2>
         </header>
         <div class="ind">
            <div>
               <p>为了获得分片的好处，分片数据库的模式应该以最大化在单个分片上执行的数据库请求数的方式设计。</p>
               <p>以下主题描述了用于此目的的对象：</p>
            </div>
            <div>
               <ul class="ullinks">
                  <li class="ulchildlink"><a href="sharding-schema-design.html#GUID-1DBC6C7F-4E0C-47E5-8870-05F829D6C3B3">Sharded Tables</a><br>分片表是一个表，在多个数据库之间划分为更小且更易于管理的部分，称为分片。
                  </li>
                  <li class="ulchildlink"><a href="sharding-schema-design.html#GUID-4E2E01CA-5103-4F4D-AB2A-79527A62B2E7">Sharded Table Family</a><br>分片表族是一组以相同方式分片的表。
                  </li>
                  <li class="ulchildlink"><a href="sharding-schema-design.html#GUID-50D56C0A-5185-4F04-A0CA-EAA442E825D3">重复的表格</a><br>除了分片表，SDB还可以包含在所有分片上重复的表。
                  </li>
                  <li class="ulchildlink"><a href="sharding-schema-design.html#GUID-FCD9BB15-6B24-4EF0-A66B-4AE16D5DA286">在所有碎片上创建的非表对象</a><br>除了重复的表之外，其他模式对象（例如用户，角色，视图，索引，同义词，函数，过程和包）以及非模式数据库对象（例如表空间，表空间集，目录和上下文）可以是在所有分片上创建。
                  </li>
                  <li class="ulchildlink"><a href="sharding-schema-design.html#GUID-FD5760B7-1F77-4A3C-A74C-2C70B2469E16">Sharded数据库中的DDL执行</a><br>要在SDB中创建模式，必须在分片目录数据库上发出DDL命令，该数据库在分片上执行之前验证DDL并在本地执行它们。
                  </li>
                  <li class="ulchildlink"><a href="sharding-schema-design.html#GUID-67BC4EEF-91D7-4240-8975-06C94E2FEA8C">Sharded数据库中的PL / SQL过程执行</a><br>与在配置中的所有分片上执行DDL语句的方式相同，Oracle提供的某些PL / SQL过程也是如此。这些特定过程调用的行为就像它们是分片DDL语句一样，它们被传播到所有分片，由目录跟踪，并在每次将新分片添加到配置时运行。
                  </li>
                  <li class="ulchildlink"><a href="sharding-schema-design.html#GUID-1ED42D4E-7A13-4303-9EF7-253BAE6A4999">在Shards上生成唯一序列号</a><br>Oracle Sharding允许您为非主键列生成跨分片的全局唯一序列号，并由分片数据库处理。
                  </li>
               </ul>
            </div>
            
            <div class="sect2"><a id="GUID-1DBC6C7F-4E0C-47E5-8870-05F829D6C3B3" name="GUID-1DBC6C7F-4E0C-47E5-8870-05F829D6C3B3"></a><h3 id="SHARD-GUID-1DBC6C7F-4E0C-47E5-8870-05F829D6C3B3" class="sect3"><span class="enumeration_section">2.1</span>分类表</h3>
               <div>
                  <p>分片表是一个表，在多个数据库之间划分为更小且更易于管理的部分，称为分片。</p>
                  <p>分片的主要好处包括：</p>
                  <ul id="GUID-1DBC6C7F-4E0C-47E5-8870-05F829D6C3B3__UL_VLV_C1D_KGB" style="list-style-type:disc">
                     <li>
                        <p><span class="bold">线性可扩展性</span> 。分片消除了性能瓶颈，并且可以通过添加分片来线性扩展性能和容量。
                        </p>
                     </li>
                     <li>
                        <p> <span class="bold">故障遏制</span> 。Sharding是一种无共享硬件基础架构，可消除单点故障，例如共享磁盘，SAN和集群件，并提供强大的故障隔离 - 一个分片的故障或速度降低不会影响其他分片的性能或可用性。
                        </p>
                     </li>
                     <li>
                        <p><span class="bold">数据的地理分布</span> 。当数据必须位于特定的管辖区域时，分片可以将特定数据存储在靠近其消费者的位置并满足法规要求。
                        </p>
                     </li>
                     <li>
                        <p><span class="bold">滚动升级</span> 。一次在一个分片上应用配置更改不会影响其他分片，并允许管理员首先测试一小部分数据的更改。
                        </p>
                     </li>
                     <li>
                        <p><span class="bold">云部署的简单性</span> 。分片非常适合在云中部署。可以根据需要调整碎片的大小以适应可用的任何云基础设施并且仍然实现所需的服务级别。Oracle Sharding支持内部部署，云和混合部署模型。
                        </p>
                     </li>
                  </ul>
                  <div class="section">
                     <p class="subhead2" id="GUID-1DBC6C7F-4E0C-47E5-8870-05F829D6C3B3__GUID-FEA6F86B-09E1-4DF5-A5DE-B980A45DFBB9">碎片架构</p>
                     <p>应用程序将数据库池视为单个逻辑数据库。通过向池中添加数据库（分片），应用程序可以在任何平台上弹性地将数据，事务和用户扩展到任何级别。Oracle数据库支持最多可扩展1000个分片。</p>
                     <p>下图说明了Oracle Sharding的主要体系结构组件：</p>
                     <ul id="GUID-1DBC6C7F-4E0C-47E5-8870-05F829D6C3B3__UL_NDW_M1D_KGB" style="list-style-type:disc">
                        <li>
                           <p>分片数据库（SDB） - 单个逻辑Oracle数据库，在不共享硬件或软件的物理Oracle数据库（分片）池中水平分区</p>
                        </li>
                        <li>
                           <p>碎片 - 托管分片数据库子集的独立物理Oracle数据库</p>
                        </li>
                        <li>
                           <p>全局服务 - 提供对SDB中数据的访问的数据库服务</p>
                        </li>
                        <li>
                           <p>分片目录 - 支持自动分片部署，分片数据库集中管理和多分片查询的Oracle数据库</p>
                        </li>
                        <li>
                           <p>Shard director  - 网络侦听器，支持基于分片键的高性能连接路由</p>
                        </li>
                        <li>
                           <p>连接池 - 在运行时，通过跨池连接路由数据库请求来充当分片导向器</p>
                        </li>
                        <li>
                           <p>管理界面 -  GDSCTL（命令行实用程序）和Oracle企业管理器（GUI）</p>
                        </li>
                     </ul>
                     <div class="figure" id="GUID-1DBC6C7F-4E0C-47E5-8870-05F829D6C3B3__GUID-65F25F7E-0A7B-4DC2-8B45-21DE4055DFA2">
                        <p class="titleinfigure">图2-1 Oracle Sharding架构</p><img id="GUID-1DBC6C7F-4E0C-47E5-8870-05F829D6C3B3__IMAGE_ODW_M1D_KGB" src="img/admin_3v_143d.png" alt="下面描述图2-1" title="下面描述图2-1" longdesc="img_text/admin_3v_143d.html"><br><a href="img_text/admin_3v_143d.html">“图2-1 Oracle Sharding架构”的说明</a></div>
                     <!-- class="figure" -->
                  </div>
                  <!-- class="section" -->
                  <div class="section">
                     <p class="subhead2" id="GUID-1DBC6C7F-4E0C-47E5-8870-05F829D6C3B3__GUID-628DEA40-7CAF-4662-9BD5-799AB25D68BA">分片和分区</p>
                     <p>Oracle Sharding本质上是分布式分区，因为它通过支持跨分片的表分区分发来扩展分区。</p>
                     <p>基于分片键，分区在表空间级别的分片中分布。密钥的示例包括客户ID，帐号和国家ID。分片键支持以下数据类型：</p>
                     <ul id="GUID-1DBC6C7F-4E0C-47E5-8870-05F829D6C3B3__UL_OHB_5ZC_KGB" style="list-style-type:disc">
                        <li>
                           <p><code class="codeph">数</code></p>
                        </li>
                        <li>
                           <p><code class="codeph">整数</code></p>
                        </li>
                        <li>
                           <p><code class="codeph">SMALLINT</code></p>
                        </li>
                        <li>
                           <p><code class="codeph">生的</code></p>
                        </li>
                        <li>
                           <p><code class="codeph">（N）VARCHAR</code></p>
                        </li>
                        <li>
                           <p><code class="codeph">（N）VARCHAR2</code></p>
                        </li>
                        <li>
                           <p><code class="codeph">（N）CHAR</code></p>
                        </li>
                        <li>
                           <p><code class="codeph">日期</code></p>
                        </li>
                        <li>
                           <p><code class="codeph">TIMESTAMP</code></p>
                        </li>
                     </ul>
                     <p>分片表的每个分区都驻留在一个单独的表空间中，每个表空间都与一个特定的分片相关联。根据分片方法，可以自动建立关联或由管理员定义关联。</p>
                     <p>即使分片表的分区驻留在多个分片中，对于应用程序，该表的外观和行为与单个数据库中的分区表完全相同。应用程序发出的SQL语句永远不必引用分片或依赖于分片数量及其配置。</p>
                     <p></p>
                  </div>
                  <!-- class="section" -->
                  <div class="example" id="GUID-1DBC6C7F-4E0C-47E5-8870-05F829D6C3B3__GUID-FA524CC9-8238-40D6-AA6A-BAFC7E5A93C1">
                     <p class="titleinexample">例2-1 Sharded Table</p>
                     <p>熟悉的表分区SQL语法指定了如何跨分片对行进行分区。例如，以下SQL语句创建一个分片表，根据分片键<code class="codeph">cust_id</code>在分片上水平分区表：</p><pre class="pre codeblock"><code>CREATE SHARDED TABLE客户（cust_id NUMBER NOT NULL，名称VARCHAR2（50），地址VARCHAR2（250），区域VARCHAR2（20），类VARCHAR2（3），注册DATE CONSTRAINT cust_pk PRIMARY KEY（cust_id））PARTITION BY CONSISTENT HASH（cust_id ）PARTITIONS AUTO TABLESPACE SET ts1;</code></pre><p>上表由一致哈希分区，哈希是一种在可伸缩分布式系统中常用的特殊类型的哈希分区。此技术自动跨分片传播表空间，以提供均匀的数据和工作负载分布。请注意，不支持分片表上的全局索引，但支持本地索引。</p>
                  </div>
                  <!-- class="example" -->
                  <div class="section">
                     <p class="subhead2" id="GUID-1DBC6C7F-4E0C-47E5-8870-05F829D6C3B3__GUID-49480A54-1E79-4E26-983D-3566D39B7EB5">表空间集</p>
                     <p>Oracle Sharding创建和管理表空间作为一个称为<strong class="term">表空间集</strong>的单元。<code class="codeph">PARTITIONS AUTO</code>子句指定应自动确定分区数。这种类型的散列在分片之间迁移数据方面提供了更大的灵活性和效率，这对于弹性可伸缩性非常重要。
                     </p>
                     <p>表空间是SDB中数据分布的逻辑单元。跨分片的分区分布是通过在驻留在不同分片上的表空间中自动创建分区来实现的。为了最小化多分片连接的数量，相关表的相应分区始终存储在同一分片中。分片表的每个分区都存储在单独的表空间中。</p>
                     <div class="infoboxnote" id="GUID-1DBC6C7F-4E0C-47E5-8870-05F829D6C3B3__GUID-A6E8D269-524F-453D-8E43-2730AEAF190B">
                        <p class="notep1">注意：</p>
                        <p>表空间集仅支持Oracle托管文件。</p>
                        <p>不能独立于整个表空间集删除或更改单个表空间。</p>
                        <p><code class="codeph">TABLESPACE SET</code>不能与用户定义的分片方法一起使用。
                        </p>
                     </div>
                  </div>
                  <!-- class="section" -->
               </div>
               <div>
                  <div class="familylinks">
                     <div class="parentlink">
                        <p><strong>父主题：</strong> <a href="sharding-schema-design.html#GUID-1B8DAEE1-A662-4516-9EA9-04FF711211C3" title="为了获得分片的好处，分片数据库的模式应该以最大化在单个分片上执行的数据库请求数的方式设计。">Sharded Database Schema Design</a></p>
                     </div>
                  </div>
               </div>
               
            </div>
            <div class="sect2"><a id="GUID-4E2E01CA-5103-4F4D-AB2A-79527A62B2E7" name="GUID-4E2E01CA-5103-4F4D-AB2A-79527A62B2E7"></a><h3 id="SHARD-GUID-4E2E01CA-5103-4F4D-AB2A-79527A62B2E7" class="sect3"><span class="enumeration_section">2.2</span> Sharded Table Family</h3>
               <div>
                  <p>分片表族是一组以相同方式分片的表。</p>
                  <p>通常，数据库表之间存在父子关系，子表（外键）中的引用约束引用父表的主键。通过这种关系链接的多个表通常形成树状结构，其中每个孩子具有单个父母。一组这样的表被称为表族。表系列中没有父表的表称为根表。表系列中只能有一个根表。</p>
                  <div class="section">
                     <p class="subhead2" id="GUID-4E2E01CA-5103-4F4D-AB2A-79527A62B2E7__GUID-00DCE558-E935-4252-BC60-406CFCA93686">表格系列是如何划分的</p>
                     <p>为了说明表系列的分片，请考虑Customers-Orders-LineItems模式的示例。此架构中的表可能如下面的示例所示。这三个表具有父子关系，Customers是根表。</p>
                     <p>客户表：</p><pre class="oac_no_warn" dir="ltr">CustNo名称地址位置类--------- ---------- -------------- --------- --- --- 123 Brown 100 Main St us3 Gold 456 Jones 300 Pine Ave us1 Silver 999 Smith 453 Cherry St us2 Bronze</pre><p>订单表：</p><pre class="oac_no_warn" dir="ltr">OrderNo CustNo OrderDate --------- -------- ----------- 4001 123 14-FEB-2013 4002 456 09-MAR-2013 4003 456 05-APR -2013 4004 123 27-MAY-2013 4005 999 01-SEP-2013</pre><p>LineItems表：</p><pre class="oac_no_warn" dir="ltr">LineNo OrderNo CustNo StockNo Quantity ------ ------- ------ ------- -------- 40011 4001 123 05683022 1 40012 4001 123 45423609 4 40013 4001 123 68584904 1 40021 4002 456 05683022 1 40022 4002 456 45423509 3 40022 4003 456 80345330 16 40041 4004 123 45423509 1 40042 4004 123 68584904 2 40051 4005 999 80345330 12</pre><p>这些表可以按客户表（即根）中的客户编号<code class="codeph">CustNo</code>进行分片。包含与客户123有关的数据的分片显示在以下示例表中。
                     </p>
                     <p>客户表：</p><pre class="oac_no_warn" dir="ltr">CustNo名称地址位置类--------- ---------- -------------- ----------  - ---- 123 Brown 100 Main St us3 Gold</pre><p>订单表：</p><pre class="oac_no_warn" dir="ltr">OrderNo CustNo OrderDate --------- -------- ----------- 4001 123 14-FEB-2013 4004 123 27-MAY-2013</pre><p>LineItems表：</p><pre class="oac_no_warn" dir="ltr">LineNo OrderNo CustNo StockNo Quantity ------ ------- ------ ------- -------- 40011 4001 123 05683022 1 40012 4001 123 45423609 4 40013 4001 123 68584904 1 40041 4004 123 45423509 1 40042 4004 123 68584904 2</pre></div>
                  <!-- class="section" -->
                  <div class="section">
                     <p class="subhead2" id="GUID-4E2E01CA-5103-4F4D-AB2A-79527A62B2E7__GUID-BC7C69ED-9C86-47C4-922A-36E859DF0776">使用CREATE TABLE创建分片表族</p>
                     <p>创建分片表系列的推荐方法是使用引用分区指定表之间的父子关系。</p>
                     <p>Customers-Orders-LineItems模式的相应<code class="codeph">CREATE TABLE</code>语句如下所示。第一个语句创建表系列的根表 -  Customers。
                     </p><pre class="pre codeblock"><code>CREATE SHARDED TABLE客户（CustNo NUMBER NOT NULL，Name VARCHAR2（50），Address VARCHAR2（250），CONSTRAINT RootPK PRIMARY KEY（CustNo））PARTITION BY CONSISTENT HASH（CustNo）PARTITIONS AUTO TABLESPACE SET ts1;</code></pre><p>以下两个语句创建Orders和LineItems表，它们是Customers表的子项和孙项。</p><pre class="pre codeblock"><code>CREATE SHARDED TABLE Orders（OrderNo NUMBER NOT NULL，CustNo NUMBER NOT NULL，OrderDate DATE，CONSTRAINT OrderPK PRIMARY KEY（CustNo，OrderNo），CONSTRAINT CustFK FOREIGN KEY（CustNo）REFERENCES Customers（CustNo））PARTITION BY REFERENCE（CustFK）;</code></pre><pre class="pre codeblock"><code>CREATE SHARDED TABLE LineItems（CustNo NUMBER NOT NULL，LineNo NUMBER（2）NOT NULL，OrderNo NUMBER（5）NOT NULL，StockNo NUMBER（4），Quantity NUMBER（2），CONSTRAINT LinePK PRIMARY KEY（CustNo，OrderNo，LineNo）， CONSTRAINT LineFK FOREIGN KEY（CustNo，OrderNo）REFERENCES Orders（CustNo，OrderNo））PARFERTION BY REFERENCE（LineFK）;</code></pre><p>在上面的示例语句中，系列中所有表的相应分区存储在同一个表空间集-TS1中。但是，可以为每个表指定单独的表空间集。</p>
                     <p>通过引用进行分区简化了语法，因为仅为根表指定了分区方案。此外，在根表上执行的分区管理操作会自动传播到其后代。例如，在向根表添加分区时，会在其所有后代上创建新分区。</p>
                     <p>请注意，在上面的示例语句中，用作分片键的分区列<code class="codeph">CustNo</code>存在于所有三个表中。尽管参数分区通常允许子表与父表等分，而不必复制子表中的键列。这样做的原因是引用分区需要父表中的主键，因为必须在用于将子项链接到其父项的子表的外键约束中指定主键。但是，分片表上的主键必须与分片键相同，或者包含分片键作为前导列。这使得可以在不与其他分片协调的情况下实施主键的全局唯一性 - 这是线性可伸缩性的关键要求。
                     </p>
                     <p>总而言之，在分片数据库中使用引用分区表需要遵守以下规则：</p>
                     <ul style="list-style-type:disc">
                        <li>
                           <p>分片表上的主键必须与分片键相同，或者与分片键前缀的其他列相同。这是在不与其他分片协调的情况下强制实施主键的全局唯一性所必需的。</p>
                        </li>
                        <li>
                           <p>引用分区需要父表中的主键，因为必须在子表的外键约束中指定主键以将子项链接到其父表。例如，要将LineItems（子）表链接到Orders（父）表，您需要Orders表中的主键。第二条规则意味着Orders表中的主键以<code class="codeph">CustNo</code>值为前缀。（这是一个不特定于Oracle Sharding的现有分区规则。）
                           </p>
                        </li>
                     </ul>
                     <p>在某些情况下，创建引用分区所需的主键和外键约束是不可能或不可取的。对于这种情况，在表系列中指定父子关系要求所有表都是显式<code class="codeph">CREATE SHARDED TABLE</code> ，并且每个子表都是使用<code class="codeph">CREATE SHARDED TABLE</code>中的<code class="codeph">PARENT</code>子句创建的，该子句包含其父级的名称。语法示例如下所示。
                     </p><pre class="pre codeblock"><code>CREATE SHARDED TABLE客户（CustNo NUMBER NOT NULL，Name VARCHAR2（50），Address VARCHAR2（250），region VARCHAR2（20），class VARCHAR2（3），signup DATE）PARTITION BY CONSISTENT HASH（CustNo）PARTITIONS AUTO TABLESPACE SET ts1;创建SHARDED TABLE订单（OrderNo NUMBER，CustNo NUMBER NOT NULL，OrderDate DATE） <span class="bold">PARENT客户</span>按一致哈希分区（CustNo）PARTITIONS AUTO TABLESPACE SET ts1; CREATE SHARDED TABLE LineItems（LineNo NUMBER，OrderNo NUMBER，CustNo NUMBER NOT NULL，StockNo NUMBER，Quantity NUMBER） <span class="bold">PARENT Customers</span> PARTITION BY CONSISTENT HASH（CustNo）PARTITIONS AUTO TABLESPACE SET ts1;</code></pre><p>由于在所有<code class="codeph">CREATE SHARDED TABLE</code>语句中都完全指定了分区方案，因此任何表都可以独立地进行子分区。引用分区不允许这样做，其中只能为根表指定子分区，并且子表划分方案对于表系列中的所有表都是相同的。
                     </p>
                     <p>请注意，此方法仅支持两级表系列，即所有子级必须具有相同的父级和子级才能存在。只要父表中的分区列存在于所有子表中，这不是限制。</p>
                  </div>
                  <!-- class="section" -->
                  <div class="section">
                     <p class="subhead2" id="GUID-4E2E01CA-5103-4F4D-AB2A-79527A62B2E7__GUID-78BB5A7B-F6B6-4ACD-B2A4-D331D08508E8">大块</p>
                     <p>分片之间的数据迁移单位是一个块。块是一组表空间，用于存储表系列中所有表的相应分区。块包含来自一组相关表的每个表的单个分区。这保证了来自不同分片表的相关数据可以一起移动。创建SDB时，将指定每个分片中的块数。</p>
                  </div>
                  <!-- class="section" -->
                  <div class="section">
                     <p class="subhead2" id="GUID-4E2E01CA-5103-4F4D-AB2A-79527A62B2E7__GUID-F307A398-CA26-4C33-8F32-9E9AE8D83286">Sharded数据库中的多个表系列</p>
                     <div class="infoboxnote" id="GUID-4E2E01CA-5103-4F4D-AB2A-79527A62B2E7__GUID-A0CCA651-6A61-4B1E-89A6-BF2261E9CB70">
                        <p class="notep1">注意：</p>在Oracle Database 19c中，Oracle Sharding包括对多个表系列的支持。此功能仅适用于系统管理的分片数据库。复合和用户定义的分片数据库仅支持一个表系列。
                     </div>
                     <p>分片数据库可以有多个表系列，其中来自不同表系列的所有数据都位于相同的块中，这些块包含来自共享相同散列键范围的不同表系列的分区。跨表族查询应该是最小的，并且只在分片协调器上执行。每个表族都与不同的全局服务相关联。来自不同表系列的应用程序各自拥有自己的连接池和服务，并使用自己的分片键路由到正确的分片。</p>
                     <p>每个表族都由其根表标识。不同表族中的表不应相互关联。每个表族都应该有自己的分片键定义，而在子表中具有相同分片键列的相同限制在每个表族中仍然适用。这意味着来自不同表系列的所有表都以相同的方式进行分片，并将相同的哈希值分成相同数量的块，每个块包含来自所有表系列的数据。</p>
                     <p>以下示例说明如何使用<code class="codeph">PARENT</code>子句创建多个表系列。
                     </p><pre class="pre codeblock"><code>CREATE SHARDED TABLE客户&lt;===表系列＃1（CustId NUMBER NOT NULL，Name VARCHAR2（50），Address VARCHAR2（250），region VARCHAR2（20），class VARCHAR2（3），signup DATE）PARTITION BY CONSISTENT HASH（ CustId）PARTITIONS AUTO TABLESPACE SET ts1;创建SHARDED TABLE订单（OrderNo NUMBER，CustId NUMBER，OrderDate DATE） <span class="bold">PARENT客户按</span>一致哈希分区（CustId）PARTITIONS AUTO TABLESPACE SET ts1;创建SHARDED TABLE LineItems（LineNo NUMBER，OrderNo NUMBER，CustId NUMBER，StockNo NUMBER，Quantity NUMBER）） <span class="bold">PARENT Customers</span> PARTITION BY CONSISTENT HASH（CustId）PARTITIONS AUTO TABLESPACE SET ts1;创建SHARDED TABLE产品&lt;===表系列＃2（ProdId NUMBER NOT NULL，CONSTRAINT pk_products PRIMARY KEY（ProdId））由一致哈希（ProdId）分区分区自动表空间设置ts_2;</code></pre><p>如果现有表系列已使用表空间集并且您尝试将其用于另一个表系列，则抛出ORA-3850。</p>
                     <p>创建第一个根表（即第一个表系列）时，所有现有的全局服务都会自动与之关联。创建更多表系列后，可以使用GDSCTL命令<code class="codeph">MODIFY SERVICE</code>更改表系列服务关联。例如，</p><pre class="pre codeblock"><code>GDSCTL&gt; MODIFY SERVICE -GDSPOOL shdpool -TABLE_FAMILY sales.customer -SERVICE sales</code></pre><div class="infoboxnote" id="GUID-4E2E01CA-5103-4F4D-AB2A-79527A62B2E7__GUID-562CA524-3141-4148-9051-FB878F664567">
                        <p class="notep1">注意：</p>
                        <p>跨表系列的连接可能效率不高，如果您有许多此类连接，或者它们对性能至关重要，则应使用重复的表而不是多个表系列。</p>
                     </div>
                  </div>
                  <!-- class="section" -->
                  <div class="section"></div>
                  <!-- class="section" -->
               </div>
               <div>
                  <div class="infoboxnotealso" id="GUID-4E2E01CA-5103-4F4D-AB2A-79527A62B2E7__GUID-49673F2F-2B83-4FB8-879B-1F0BB6DE2A67">
                     <p class="notep1">也可以看看：</p>
                     <p><a href="../vldbg/partition-concepts.html#VLDBG-GUID-54D18B18-6838-4115-9389-E1FB0D20A8CA" target="_blank"><span><cite>Oracle数据库VLDB和分区指南</cite></span></a></p>
                     <p>用于GDSCTL命令参考的<a href="../gsmug/gdsctl-reference.html#GSMUG-GUID-E6E76443-AD85-455C-99AA-BF0A7856F880" target="_blank"><span><cite>Oracle数据库全局数据服务概念和管理指南</cite></span></a></p>
                  </div>
                  <div class="familylinks">
                     <div class="parentlink">
                        <p><strong>父主题：</strong> <a href="sharding-schema-design.html#GUID-1B8DAEE1-A662-4516-9EA9-04FF711211C3" title="为了获得分片的好处，分片数据库的模式应该以最大化在单个分片上执行的数据库请求数的方式设计。">Sharded Database Schema Design</a></p>
                     </div>
                  </div>
               </div>
               
            </div>
            <div class="sect2"><a id="GUID-50D56C0A-5185-4F04-A0CA-EAA442E825D3" name="GUID-50D56C0A-5185-4F04-A0CA-EAA442E825D3"></a><h3 id="SHARD-GUID-50D56C0A-5185-4F04-A0CA-EAA442E825D3" class="sect3"><span class="enumeration_section">2.3</span>重复的表格</h3>
               <div>
                  <p>除了分片表，SDB还可以包含在所有分片上重复的表。</p>
                  <p>对于许多应用程序，通过在所有分片中复制只读或主要读取表，可以最大化单个分片处理的数据库请求数。对于通常与分片表一起访问的相对较小的表，此策略是一个不错的选择。每个分片中具有相同内容的表称为重复表。</p>
                  <p>SDB包括跨分片水平分区的分片表，以及复制到所有分片的重复表。重复的表包含参考信息，例如，每个分片共有的Stock Items表。分片和重复表的组合使得与分片键关联的所有事务都可以由单个分片处理。该技术实现了线性可扩展性和故障隔离。</p>
                  <p>作为需要复制表的示例，请考虑<a href="sharding-schema-design.html#GUID-4E2E01CA-5103-4F4D-AB2A-79527A62B2E7" title="A sharded table family is a set of tables that are sharded in the same way.">Sharded Table Family中</a>描述的<a href="sharding-schema-design.html#GUID-4E2E01CA-5103-4F4D-AB2A-79527A62B2E7" title="分片表族是一组以相同方式分片的表。">表族</a> 。数据库模式还可能包含<code class="codeph">Products</code>表，该表包含为此表系列创建的分片中的所有客户共享的数据，并且无法按客户编号进行分片。要在订单处理期间防止多分片查询，必须在所有分片上复制整个表。
                  </p>
                  <p>分片表（Customers，Orders和LineItems）与重复表（Products）之间的区别如下图所示。</p>
                  <div class="figure" id="GUID-50D56C0A-5185-4F04-A0CA-EAA442E825D3__GUID-BDE4A5B3-9ECE-4E00-8D7A-AFC1E345D229">
                     <p class="titleinfigure">图2-2 SDB中的分片表和重复表</p><img src="img/admin_3v_138e.png" alt="下面是图2-2的描述" title="下面是图2-2的描述" longdesc="img_text/admin_3v_138e.html"><br><a href="img_text/admin_3v_138e.html">“图2-2分片表和SDB中的重复表”的说明</a></div>
                  <!-- class="figure" -->
                  <div class="section">
                     <p class="subhead2" id="GUID-50D56C0A-5185-4F04-A0CA-EAA442E825D3__GUID-CD94F26B-6F9E-4713-95DD-747EC1D56ED2">使用CREATE TABLE创建重复的表</p>
                     <p>可以使用以下语句创建重复的Products表。</p><pre class="pre codeblock"><code>CREATE DUPLICATED TABLE产品（StockNo NUMBER PRIMARY KEY，Description VARCHAR2（20），Price NUMBER（6,2））;</code></pre></div>
                  <!-- class="section" -->
                  <div class="section">
                     <p class="subhead2" id="GUID-50D56C0A-5185-4F04-A0CA-EAA442E825D3__GUID-03DCD4A9-DF79-450A-B36E-F46F91B6D09B">更新重复表并同步其内容</p>
                     <p>Oracle Sharding使用Materialized View Replication同步重复表的内容。每个分片上的重复表由物化视图表示。物化视图的主表位于分片目录中。<code class="codeph">CREATE DUPLICATED TABLE</code>语句自动创建<code class="codeph">CREATE DUPLICATED TABLE</code>化视图复制所需的主表，物化视图和其他对象。
                     </p>
                     <p>在Oracle Database 12c第2版中，客户端必须连接到分片目录数据库才能更新重复的表。在Oracle Database 18c和更高版本中，您可以更新分片上的重复表。更新首先通过dblink从分片传播到分片目录上的主表。然后，由于物化视图刷新，更新将异步传播到所有其他分片。</p>
                     <p>所有分片的物化视图都以可配置的频率自动刷新。所有重复表的刷新频率由数据库初始化参数<code class="codeph">SHRD_DUPL_TABLE_REFRESH_RATE</code> 。参数的默认值为60秒。
                     </p>
                     <div class="infoboxnote" id="GUID-50D56C0A-5185-4F04-A0CA-EAA442E825D3__GUID-8D9B6557-E034-4D79-86A9-27705077BB26">
                        <p class="notep1">注意：</p>
                        <p>当在分片上运行的事务尝试更新在分片目录上删除的行时，可能出现竞争条件。在这种情况下，将返回错误并回滚分片上的事务。</p>
                        <p>更新分片上的重复表时，不支持以下用例：</p>
                        <ul style="list-style-type:disc">
                           <li>
                              <p>更新dblinks不支持的LOB或数据类型</p>
                           </li>
                           <li>
                              <p>更新或删除由同一事务插入的行</p>
                           </li>
                        </ul>
                     </div>
                  </div>
                  <!-- class="section" -->
               </div>
               <div>
                  <div class="infoboxnotealso" id="GUID-50D56C0A-5185-4F04-A0CA-EAA442E825D3__GUID-AEA0D593-FAA1-4335-8C82-36916A3A5F4F">
                     <p class="notep1">也可以看看：</p><a href="../admin/read-only-materialized-view-concepts.html#ADMIN-GUID-A422B474-4BED-4A60-AEDB-E93630746083" target="_blank"><span><cite>Oracle数据库管理员指南</cite></span></a></div>
                  <div class="familylinks">
                     <div class="parentlink">
                        <p><strong>父主题：</strong> <a href="sharding-schema-design.html#GUID-1B8DAEE1-A662-4516-9EA9-04FF711211C3" title="为了获得分片的好处，分片数据库的模式应该以最大化在单个分片上执行的数据库请求数的方式设计。">Sharded Database Schema Design</a></p>
                     </div>
                  </div>
               </div>
               
            </div>
            <div class="sect2"><a id="GUID-FCD9BB15-6B24-4EF0-A66B-4AE16D5DA286" name="GUID-FCD9BB15-6B24-4EF0-A66B-4AE16D5DA286"></a><h3 id="SHARD-GUID-FCD9BB15-6B24-4EF0-A66B-4AE16D5DA286" class="sect3"><span class="enumeration_section">2.4</span>在所有碎片上创建的非表对象</h3>
               <div>
                  <p>除了重复的表之外，其他模式对象（例如用户，角色，视图，索引，同义词，函数，过程和包）以及非模式数据库对象（例如表空间，表空间集，目录和上下文）可以是在所有分片上创建。</p>
                  <p>与在<code class="codeph">CREATE</code>语句中需要额外关键字的表不同 - <code class="codeph">SHARDED</code>或<code class="codeph">DUPLICATED</code>使用现有语法在所有分片上创建其他对象。唯一的要求是必须启用<code class="codeph">SHARD DDL</code>会话属性。
                  </p>
                  <p>请注意，此版本不支持在以下对象的所有分片上<span class="italic">自动</span>创建。可以通过连接到各个分片来创建这些对象。
                  </p>
                  <ul style="list-style-type:disc">
                     <li>
                        <p>簇</p>
                     </li>
                     <li>
                        <p>控制文件</p>
                     </li>
                     <li>
                        <p>数据库链接</p>
                     </li>
                     <li>
                        <p>磁盘组</p>
                     </li>
                     <li>
                        <p>版</p>
                     </li>
                     <li>
                        <p>闪回档案</p>
                     </li>
                     <li>
                        <p>物化区域地图</p>
                     </li>
                     <li>
                        <p>大纲</p>
                     </li>
                     <li>
                        <p>PFILE</p>
                     </li>
                     <li>
                        <p>轮廓</p>
                     </li>
                     <li>
                        <p>还原点</p>
                     </li>
                     <li>
                        <p>回滚段</p>
                     </li>
                     <li>
                        <p>摘要</p>
                     </li>
                  </ul>
                  <p>物化视图和视图日志Oracle数据库支持的起始<span class="italic">18℃，</span>用以下限制：</p>
                  <ul style="list-style-type:disc">
                     <li>
                        <p>在分片表上创建的物化视图在目录数据库中保持为空，而分片上的相应物化视图包含来自每个单独分片的数据。</p>
                     </li>
                     <li>
                        <p>对于分片表的物化视图，仅支持<code class="codeph">REFRESH COMPLETE ON DEMAND USING TRUSTED CONSTRAINTS</code>的<code class="codeph">REFRESH COMPLETE ON DEMAND USING TRUSTED CONSTRAINTS</code>选项。
                        </p>
                     </li>
                  </ul>
               </div>
               <div>
                  <div class="familylinks">
                     <div class="parentlink">
                        <p><strong>父主题：</strong> <a href="sharding-schema-design.html#GUID-1B8DAEE1-A662-4516-9EA9-04FF711211C3" title="为了获得分片的好处，分片数据库的模式应该以最大化在单个分片上执行的数据库请求数的方式设计。">Sharded Database Schema Design</a></p>
                     </div>
                  </div>
               </div>
               
            </div>
            <div class="sect2"><a id="GUID-FD5760B7-1F77-4A3C-A74C-2C70B2469E16" name="GUID-FD5760B7-1F77-4A3C-A74C-2C70B2469E16"></a><h3 id="SHARD-GUID-FD5760B7-1F77-4A3C-A74C-2C70B2469E16" class="sect3"><span class="enumeration_section">2.5</span> Sharded数据库中的DDL执行</h3>
               <div>
                  <div><span>要在SDB中创建模式，必须在分片目录数据库上发出DDL命令，该数据库在分片上执行之前验证DDL并在本地执行它们。</span> 因此，分片目录数据库包含分片数据库中存在的所有对象的本地副本，并充当SDB架构的主副本。如果目录验证和DDL的执行成功，则DDL会自动传播到所有分片，并按照分片目录上的顺序应用。
                  </div>
                  <p>如果在DDL传播期间分片已关闭或无法访问，则目录会跟踪无法应用于分片的DDL，然后在分片备份时应用它们。当新的分片添加到SDB时，在SDB中执行的所有DDL在客户端可访问之前以相同的顺序应用于分片。</p>
                  <p>您可以通过两种方式在SDB中发布DDL：</p>
                  <ul style="list-style-type:disc">
                     <li>
                        <p>使用GDSCTL <code class="codeph">sql</code>命令。
                        </p>
                        <p>以这种方式发出DDL时，GDSCTL会等待所有分片完成执行DDL并返回执行状态。例如</p><pre class="pre codeblock"><code>GDSCTL&gt; sql“create tablespace set tbsset”</code></pre></li>
                     <li>
                        <p>使用<code class="codeph">GDS$CATALOG. <span class="variable" translate="no">sdbname</span></code>使用SQL * Plus连接到分片目录数据库<code class="codeph">GDS$CATALOG. <span class="variable" translate="no">sdbname</span></code>服务。例如</p><pre class="pre codeblock"><code>SQL&gt; create tablespace set tbsset;</code></pre><p>在分片目录数据库上发出DDL命令时，它会在本地完成执行时返回状态，但DDL到所有分片的传播会在后台异步发生。</p>
                     </li>
                  </ul>
                  <div class="section">
                     <p class="subhead2" id="GUID-FD5760B7-1F77-4A3C-A74C-2C70B2469E16__GUID-18B4FED1-AF9A-4DA7-A608-3F396E410524">验证DDL传播</p>
                     <p>您可以使用GDSCTL <code class="codeph">show ddl</code>和<code class="codeph">config shard</code>命令检查DDL传播到分片的状态。在分片目录上使用SQL * Plus执行DDL时，必须执行此检查，因为SQL * Plus不会在所有分片上返回执行状态。当分片上的DDL失败时，该分片上的所有其他DDL都将被阻止，直到故障得到解决并执行GDSCTL <code class="codeph">recover shard</code>命令。请注意，用户必须具有GSM_ADMIN权限才能执行这些GDSCTL命令。
                     </p>
                  </div>
                  <!-- class="section" -->
                  <div class="section">
                     <p class="subhead2" id="GUID-FD5760B7-1F77-4A3C-A74C-2C70B2469E16__GUID-300AC412-5294-4C85-BCAC-65DF177E9F7F">在本地和全球创建对象</p>
                     <p>使用GDSCTL <code class="codeph">sql</code>命令发出创建对象的DDL时，将在所有分片上创建对象。还在分片目录数据库中创建该对象的主副本。存在于所有分片上的对象和目录数据库称为<span class="italic">SDB对象</span> 。
                     </p>
                     <p>使用SQL * Plus连接到分片目录时，可以创建两种类型的对象：SDB对象和本地对象。<span class="italic">本地对象</span>是仅存在于分片目录中的传统对象。例如，本地对象可用于管理目的，或者它们可以由源自目录数据库的多分片查询使用，以生成和存储报告。
                     </p>
                     <p>在SQL * Plus会话中创建的对象类型（SDB或本地）取决于是否在会话中启用了<code class="codeph">SHARD DDL</code>模式。默认情况下，在SDB用户的分片目录数据库上启用此模式 - 存在于所有分片和分片目录数据库中的用户。在会话中启用<code class="codeph">SHARD DDL</code>创建的所有对象都是SDB对象。要创建本地对象，SDB用户必须首先运行<code class="codeph">alter session disable shard ddl</code> 。禁用<code class="codeph">SHARD DDL</code>创建的所有对象都是本地对象。要在会话中启用<code class="codeph">SHARD DDL</code> ，SDB用户必须运行<code class="codeph">alter session enable shard ddl</code> 。
                     </p>
                     <p>有关<code class="codeph">SHARD DDL</code>会话参数的详细信息，请参阅<a href="sharding-schema-design.html#GUID-B69FD5E1-7DDC-4867-9C26-9849C507E8C4__ALTERSESSION-3E7191AD">ALTER SESSION</a> 。
                     </p>
                  </div>
                  <!-- class="section" -->
                  <div class="section">
                     <p class="subhead2" id="GUID-FD5760B7-1F77-4A3C-A74C-2C70B2469E16__GUID-E4A620EF-C4E2-4886-B55E-7F4FE48694A6">创建SDB用户以创建架构对象</p>
                     <p>仅存在于分片目录数据库中的本地用户没有在SDB中创建模式对象的权限。因此，创建SDB模式的第一步是通过以SYSDBA连接到分片目录数据库，启用<code class="codeph">SHARD DDL</code>并执行<code class="codeph">CREATE USER</code>命令来创建SDB用户。当SDB用户连接到目录数据库时，默认情况下启用<code class="codeph">SHARD DDL</code>模式。
                     </p>
                     <div class="infoboxnote" id="GUID-FD5760B7-1F77-4A3C-A74C-2C70B2469E16__GUID-53959C1B-AB72-4165-8413-5177650AFD3F">
                        <p class="notep1">注意：</p>
                        <p>如果本地用户启用<code class="codeph">SHARD DDL</code>模式，则可以创建非模式SDB对象，例如表空间，目录和上下文;但是，它们无法创建模式SDB对象，例如表，视图，索引，函数，过程等。
                        </p>
                        <p>分片对象不能对本地对象有任何依赖性。例如，您无法在本地表上创建所有分片视图。</p>
                     </div>
                  </div>
                  <!-- class="section" -->
                  <div class="section">
                     <p class="subhead2" id="GUID-FD5760B7-1F77-4A3C-A74C-2C70B2469E16__GUID-0B91C7B4-2060-44BC-A50C-FE0A26DBADC6">DDL执行示例</p>
                     <p>以下示例演示了发出DDL，检查其执行状态以及遇到错误时要执行的操作的步骤。这些示例是针对使用SQL * Plus发出DDL时的情况，但在使用GDSCTL <code class="codeph">sql</code>命令时应用相同的状态检查和更正操作。
                     </p>
                  </div>
                  <!-- class="section" -->
                  <div class="example" id="GUID-FD5760B7-1F77-4A3C-A74C-2C70B2469E16__GUID-A4259AFA-082A-4E9B-ACB8-DA9B38394F09">
                     <p class="titleinexample">示例2-2分片目录上的DDL执行错误</p>
                     <p>在此示例中，用户在<code class="codeph">CREATE USER</code>命令中输入错误。
                     </p><pre class="pre codeblock"><code>SQL&gt; alter session enable shard ddl;会话改变了。SQL&gt; CREATE USER example_user IDENTRIFIED BY out_standing1; CREATE USER example_user IDENTRIFIED BY out_Standing1 *第1行的错误：ORA-00922：缺少或无效选项</code></pre><p>DDL无法在分片目录上执行，并且正如预期的那样，GDSCTL <code class="codeph">show ddl</code>命令显示没有在任何分片上执行DDL：</p><pre class="pre codeblock"><code>GDSCTL&gt; show ddl id DDL Text Failed shards  -  -------- -------------</code></pre><p>然后用户以正确的拼写重复该命令。请注意，由于使用了相同的会话，因此无需再次运行<code class="codeph">alter session enable shard ddl</code> 。
                     </p><pre class="pre codeblock"><code>SQL&gt; CREATE USER example_user IDENTIFIED BY out_Standing1;用户创建。</code></pre><p>现在<code class="codeph">show ddl</code>显示DDL已在分片目录数据库上成功执行，并且在任何联机分片上都没有失败。
                     </p><pre class="pre codeblock"><code>GDSCTL&gt; show ddl id DDL Text Failed shards  -  -------- ------------- 1 create user example_user由*****标识</code></pre><div class="infoboxnote" id="GUID-FD5760B7-1F77-4A3C-A74C-2C70B2469E16__GUID-BD9A4F92-7505-4BFE-A975-08305DB16E86">
                        <p class="notep1">注意：</p>
                        <p>对于在DDL执行时关闭的任何分片，在备份分片时会自动应用DDL。</p>
                     </div>
                  </div>
                  <!-- class="example" -->
                  <div class="example" id="GUID-FD5760B7-1F77-4A3C-A74C-2C70B2469E16__GUID-80B09F09-EC5D-42DE-B2AF-45E1A02B1D98">
                     <p class="titleinexample">示例2-3通过对该分片执行纠正操作从分片上的错误中恢复</p>
                     <p>在此示例中，用户尝试为系统管理的分片表创建表空间集。但其中一个分片上的datafile目录不可写，因此DDL在目录上成功执行，但在分片上失败。</p><pre class="pre codeblock"><code>SQL&gt; connect example_user / out_Standing1已连接的SQL&gt; create tablespace set tbsset;表空间已创建。</code></pre><p>请注意，不需要运行<code class="codeph">alter session enable shard ddl</code>因为用户example_user是作为SDB用户创建的，默认情况下启用了shard ddl。
                     </p>
                     <p>使用GDSCTL <code class="codeph">show ddl</code>检查状态：</p><pre class="pre codeblock"><code>GDSCTL&gt; show ddl id DDL Text Failed shards  -  -------- ------------- 1 create user example_user由***** 2创建表空间set tbsset shard01</code></pre><p>命令输出显示分片shard01上的DDL失败。运行GDSCTL <code class="codeph">config shard</code>命令以获取详细信息：</p><pre class="pre codeblock"><code>GDSCTL&gt; config shard -shard shard01 Conversion ='：'名称：shard01 Shard Group：dbs1状态：Ok状态：Deployed Region：east连接字符串：（DESCRIPTION =（ADDRESS =（HOST = shard01-host）（PORT = 1521）（ PROTOCOL = tcp））（CONNECT_DATA =（SID = shard01）））SCAN地址：ONS远程端口：0磁盘阈值，ms：20 CPU阈值，％：75版本：18.0.0.0 <span class="bold">DDL失败：create tablespace set tbsset DDL错误： ORA-02585：创建tablepsace设置失败，其中一个表空间未创建ORA-01119：创建数据库文件时出错\'/ ade / b / 3667445372 / oracle / rdbms / dbs / SHARD01 / datafile / o1_mf_tbsset_％u_.dbf \' ORA-27040：文件创建错误，无法创建文件Linux-x86_64错误：13：权限被拒绝附加信息：1 \（ngsmoci_execute \）失败的DDL ID：2</span>可用性：ONLINE</code></pre><p>以“Failed DDL：”开头的文本表示问题。要解决此问题，用户必须登录到分片数据库主机并使目录可写。</p>
                     <p>显示目录的权限：</p><pre class="pre codeblock"><code>cd $ ORACLE_HOME / rdbms / dbs ls -l ../ | grep dbs dr-xr-xr-x 4 oracle dba 102400 Jul 20 15:41 dbs /</code></pre><p>将目录更改为可写：</p><pre class="pre codeblock"><code>chmod + w。ls -l ../ | grep dbs drwxrwxr-x 4 oracle dba 102400 Jul 20 15:41 dbs /</code></pre><p>返回GDSCTL控制台并发出<code class="codeph">recover shard</code>命令：</p><pre class="pre codeblock"><code>GDSCTL&gt;恢复shard -shard shard01</code></pre><p>再次检查状态：</p><pre class="pre codeblock"><code>GDSCTL&gt; show ddl id DDL Text Failed shards  -  -------- ------------- 1 create user example_user由***** 2创建表空间set tbsset GDSCTL&gt; config shard -shard shard01 Conversion ='：'名称：shard01 Shard组：dbs1状态：Ok状态：Deployed Region：east连接字符串：（DESCRIPTION =（ADDRESS =（HOST = shard01-host）（PORT = 1521）（PROTOCOL = tcp））（CONNECT_DATA =（SID = shard01）））SCAN地址：ONS远程端口：0磁盘阈值，ms：20 CPU阈值，％：75版本：18.0.0.0上次失败DDL：DDL错误：--- DDL id ：可用性：在线</code></pre><p>如上所示，不再出现失败的DDL错误。</p>
                  </div>
                  <!-- class="example" -->
                  <div class="example" id="GUID-FD5760B7-1F77-4A3C-A74C-2C70B2469E16__GUID-EE10FFFC-5D97-43A1-8ECF-89CCDB035B21">
                     <p class="titleinexample">示例2-4通过对所有其他分片执行更正操作从分片上的错误中恢复</p>
                     <p>在此示例中，用户尝试创建另一个表空间集tbs_set，但是分片上的DDL失败，因为已存在具有相同名称的现有本地表空间。</p>
                     <p>在分片目录上：</p><pre class="pre codeblock"><code>SQL&gt; create tablespace set tbs_set;表空间已创建。</code></pre><p>使用GDSCTL <code class="codeph">show ddl</code>命令检查状态：</p><pre class="pre codeblock"><code>GDSCTL&gt; show ddl id DDL Text Failed shards  -  -------- ------------- 1 create user example_user由***** 2创建表空间set tbsset 3 create tablespace set tbs_set shard01 GDSCTL&gt; config shard -shard shard01 Conversion ='：'Name：shard01 ...... <span class="bold">Failed DDL：create tablespace set tbs_set DDL错误：ORA-02585：创建表空间设置失败，其中一个表空间未创建ORA-01543： tablespace \'TBS_SET \'已经存在\（ngsmoci_execute \）</span></code></pre><p>此问题的解决方案是以本地数据库管理员身份登录shard01，删除表空间TBS_SET，然后运行GDSCTL <code class="codeph">recover shard -shard shard01</code> 。但是假设您要保留此表空间，而是选择删除具有名称冲突的新创建的表空间集，并创建另一个具有不同名称的表空间集，例如tbsset2。以下示例显示了如何在分片目录上执行此操作：</p><pre class="pre codeblock"><code>SQL&gt; drop tablespace set tbs_set; SQL&gt; create tablespace set tbs_set2;</code></pre><p>使用GDSCTL检查状态：</p><pre class="pre codeblock"><code>GDSCTL&gt; show ddl id DDL Text Failed shards  -  -------- ------------- 1 create user example_user由***** 2创建表空间set tbsset 3 create tablespace set tbs_set shard01 4 drop tablespace set tbs_set 5 create tablespace set tbsset2</code></pre><p>你可以看到在shard01上没有尝试DDL 4和5，因为DDL 3在那里失败了。要使此分片与分片目录保持一致，必须运行GDSCTL <code class="codeph">recover shard</code>命令。但是，在此分片上执行DDL 3没有意义，因为它会再次失败并且您实际上不想再创建表空间集tbs_set。要使用<code class="codeph">–ignore_first</code>选项跳过DDL 3运行<code class="codeph">recover shard</code>分<code class="codeph">–ignore_first</code> ：</p><pre class="pre codeblock"><code>GDSCTL&gt; recover shard -shard shard01 -ignore_first <span class="bold">GSM错误：dbs1 shard01：ORA-00959：tablespace \'TBS_SET \'不存在（ngsmoci_execute）</span> GDSCTL&gt; show ddl id DDL Text Failed shards  -  -------- ------------- 1创建用户sidney标识***** 2创建表空间set tbsset 3 create tablespace set tbs_set 4 drop tablespace set tbs_set shard01 5 create tablespace set tbsset2</code></pre><p>这次DDL 3没有失败，因为它被跳过了。但是，应用了下一个DDL（4  -  drop tablespace set tbs_set）并导致错误，因为在分片上不存在要删除的表空间。</p>
                     <p>因为<code class="codeph">–ignore_first</code>选项仅跳过第一个DDL，所以您需要再次执行<code class="codeph">recover shard</code>以跳过<code class="codeph">drop</code>语句：</p><pre class="pre codeblock"><code>GDSCTL&gt;恢复shard -shard shard01 -ignore_first GDSCTL&gt; show ddl id DDL文本失败的分片 -  -------- ------------- 1创建由***标识的用户sidney ** 2创建表空间集tbsset 3创建表空间集tbs_set 4 drop tablespace set tbs_set 5 create tablespace set tbsset2</code></pre><p>请注意，不再显示任何故障，并且所有DDL都已成功应用于分片。</p>
                     <p>使用<code class="codeph">–ignore_first</code>选项运行<code class="codeph">recover shard</code> ，会在增量部署期间将失败的DDL标记为被忽略。因此，当将新分片添加到SDB时，将跳过DDL编号3和4，并且仅应用DDL编号1和5。
                     </p>
                  </div>
                  <!-- class="example" -->
               </div>
               <div>
                  <ul class="ullinks">
                     <li class="ulchildlink"><a href="sharding-schema-design.html#GUID-B69FD5E1-7DDC-4867-9C26-9849C507E8C4">Sharded数据库的DDL语法扩展</a><br>Oracle Sharding引入了对SQL DDL语句的更改。具有此语法的DDL语句只能对分片数据库执行。
                     </li>
                  </ul>
                  <div class="familylinks">
                     <div class="parentlink">
                        <p><strong>父主题：</strong> <a href="sharding-schema-design.html#GUID-1B8DAEE1-A662-4516-9EA9-04FF711211C3" title="为了获得分片的好处，分片数据库的模式应该以最大化在单个分片上执行的数据库请求数的方式设计。">Sharded Database Schema Design</a></p>
                     </div>
                  </div>
               </div>
               
               <div class="sect3"><a id="GUID-B69FD5E1-7DDC-4867-9C26-9849C507E8C4" name="GUID-B69FD5E1-7DDC-4867-9C26-9849C507E8C4"></a><h4 id="SHARD-GUID-B69FD5E1-7DDC-4867-9C26-9849C507E8C4" class="sect4"><span class="enumeration_section">2.5.1</span> Sharded数据库的DDL语法扩展</h4>
                  <div>
                     <p>Oracle Sharding引入了对SQL DDL语句的更改。具有此语法的DDL语句只能对分片数据库执行。</p>
                     <p>请注意，不需要更改查询和DML语句来支持Oracle Sharding，并且对DDL语句的更改非常有限。大多数现有的DDL语句在分片数据库上的工作方式相同，语法和语义与常规Oracle数据库相同。</p>
                     <div class="section">
                        <p class="subhead3" id="GUID-B69FD5E1-7DDC-4867-9C26-9849C507E8C4__GUID-4222E6D3-5BA2-4EDB-BCC1-9F25C1CC6CA5">创建TABLESPACE SET</p>
                        <p>这是为Oracle Sharding引入的新声明。它的语法类似于<code class="codeph">CREATE TABLESPACE</code> 。</p><pre class="pre codeblock"><code>CREATE TABLESPACE SET tablespace_set [IN SHARDSPACE shardspace] [USING TEMPLATE（{MINIMUM EXTENT size_clause | BLOCKSIZE integer [K] | logging_clause | FORCE LOGGING | ENCRYPTION tablespace_encryption_spec | DEFAULT [table_compression] storage_clause | {ONLINE | OFFLINE} | extent_management_clause | segment_management_clause | flashback_mode_clause} ...）];</code></pre><p>该语句创建一个表空间集，可用作一个或多个分片表和索引的逻辑存储单元。表空间集由多个Oracle表空间组成，这些表空间分布在分片空间中的分片中。</p>
                        <p>请注意，在系统管理的分片中，分片数据库中只有一个默认分片空间。表空间集中的表空间数自动确定，并且等于相应分片空间中的块数。</p>
                        <p>表空间集中的所有表空间都是bigfile并具有相同的属性。属性在<code class="codeph">USING TEMPLATE</code>子句中指定。此子句与典型表空间的<code class="codeph">permanent_tablespace_clause</code>相同，但不能在<code class="codeph">datafile_tempfile_spec</code>子句中指定数据文件名。表空间集中每个表空间的数据文件名称将自动生成。
                        </p>
                        <p>请注意，表空间集只能包含永久表空间，没有系统，撤消或临时表空间集。</p>
                        <p id="GUID-B69FD5E1-7DDC-4867-9C26-9849C507E8C4__GUID-95EC7020-1ABE-4560-BB9A-C107CA4EB4D0"><span class="bold">例</span></p><pre class="pre codeblock"><code>使用模板创建TAPLESPACE SET TSP_SET_1在SHARDSPACE sgr1中（数据文件大小100米扩展管理本地区域空间管理自动）;</code></pre></div>
                     <!-- class="section" -->
                     <div class="section">
                        <p class="subhead3" id="GUID-B69FD5E1-7DDC-4867-9C26-9849C507E8C4__GUID-8633D06B-A328-4C40-B79A-03E8298D0268">ALTER TABLESPACE SET</p>
                        <p>无法修改表空间集的shardspace属性。表空间集的所有其他属性都可以像常规永久表空间一样进行更改。由于表空间集中的表空间是bigfile，因此不支持<code class="codeph">ADD DATAFILE</code>和<code class="codeph">DROP DATAFILE</code>子句。
                        </p>
                     </div>
                     <!-- class="section" -->
                     <div class="section">
                        <p class="subhead3" id="GUID-B69FD5E1-7DDC-4867-9C26-9849C507E8C4__GUID-EB609ECE-464F-4BD1-88E9-2D7FC2FCD4B5">DROP TABLESPACE SET和PURGE TABLESPACE SET</p>
                        <p>这些语句的语法和语义类似于<code class="codeph">DROP</code>和<code class="codeph">PURGE TABLESPACE</code>语句。
                        </p>
                     </div>
                     <!-- class="section" -->
                     <div class="section">
                        <p class="subhead3" id="GUID-B69FD5E1-7DDC-4867-9C26-9849C507E8C4__GUID-6DA2227F-FE28-4ECB-96D1-BCDA32FB33B9">创建表</p>
                        <p>此语句已扩展为允许创建分片和重复表以及表系列的规范。</p>
                        <p id="GUID-B69FD5E1-7DDC-4867-9C26-9849C507E8C4__GUID-F8AC1BEE-6905-4D82-9344-0249A4FBDC42"><span class="bold">句法</span></p><pre class="pre codeblock"><code>CREATE [{GLOBAL TEMPORARY | SHARDED | DUPLICATED}] TABLE [架构。 ] table {relational_table | object_table | XMLType_table} [PARENT [schema。 ]表];</code></pre><p><code class="codeph">CREATE TABLE</code>语句的以下部分旨在支持Oracle Sharding：</p>
                        <ul style="list-style-type:disc">
                           <li>
                              <p><code class="codeph">SHARDED</code>和<code class="codeph">DUPLICATED</code>关键字表示表内容分别跨分片分区或在所有分片上重复。<code class="codeph">DUPLICATED</code>关键字是创建重复表的唯一语法更改。下面描述的所有其他更改仅适用于分片表。
                              </p>
                           </li>
                           <li>
                              <p><code class="codeph">PARENT</code>子句将分片表链接到其表族的根表。
                              </p>
                           </li>
                           <li>
                              <p>要创建分片表，请使用<code class="codeph">TABLESPACE SET</code>代替<code class="codeph">TABLESPACE</code> 。包含<code class="codeph">TABLESPACE</code>所有子句都扩展为包含<code class="codeph">TABLESPACE SET</code> 。</p>
                           </li>
                           <li>
                              <p><code class="codeph">table_partitioning_clauses</code>三个子句： <code class="codeph">consistent_hash_partitions</code> ， <code class="codeph">consistent_hash_with_subpartitions</code>和<code class="codeph">partition_set_clause</code> 。
                              </p><pre class="pre codeblock"><code>table_partitioning_clauses :: = {range_partitions | hash_partitions | list_partitions | composite_range_partitions | composite_hash_partitions | composite_list_partitions | reference_partitioning | system_partitioning <span class="bold">| consistent_hash_partitions | consistent_hash_with_subpartitions | partition_set_clause</span> }</code></pre></li>
                        </ul>
                        <p>当前版本中分片表的限制：</p>
                        <ul style="list-style-type:disc">
                           <li>
                              <p>没有为分片表设置默认表空间。</p>
                           </li>
                           <li>
                              <p>临时表无法分片或重复。</p>
                           </li>
                           <li>
                              <p>不支持以索引为单位的分片表。</p>
                           </li>
                           <li>
                              <p>分片表不能包含嵌套表列或标识列。</p>
                           </li>
                           <li>
                              <p>在分片表上定义的主键约束必须包含分片列。不支持引用重复表列的分片表的列上的外键约束。</p>
                           </li>
                           <li>
                              <p>分片表不支持系统分区和间隔范围分区。通过一致性散列进行分区不支持单个散列分区的规范。</p>
                           </li>
                           <li>
                              <p><code class="codeph">PARTITION BY</code>或<code class="codeph">PARTITIONSET BY</code>子句中使用的分片表中的列不能是虚拟列。
                              </p>
                           </li>
                        </ul>
                        <p>以下不支持当前版本中的重复表：</p>
                        <ul style="list-style-type:disc">
                           <li>
                              <p>系统和引用分区表</p>
                           </li>
                           <li>
                              <p>LONG，abstract（支持MDSYS数据类型），REF数据类型</p>
                           </li>
                           <li>
                              <p>没有主键的最大列数为999</p>
                           </li>
                           <li>
                              <p><code class="codeph">nologging</code> ， <code class="codeph">parallel</code> ， <code class="codeph">inmemory</code>选项</p>
                           </li>
                           <li>
                              <p>重复表中的XMLType列不能在非ASSM表空间中使用</p>
                           </li>
                        </ul>
                        <p id="GUID-B69FD5E1-7DDC-4867-9C26-9849C507E8C4__GUID-AD258DAF-1B98-48CC-8C42-1D7AFD4E2C53"><span class="bold">例</span></p><pre class="pre codeblock"><code>CREATE SHARDED TABLE客户（cust_id NUMBER NOT NULL，名称VARCHAR2（50），地址VARCHAR2（250），location_id VARCHAR2（20），类VARCHAR2（3），signup_date DATE，CONSTRAINT cust_pk PRIMARY KEY（cust_id，class））PARTITIONSET BY LIST （类）由一致哈希分区（cust_id）PARTITIONS AUTO（PARTITIONSET金币值（'gld'）TABLESPACE SET ts2，PARTITIONSET银价值（'slv'）TABLESPACE SET ts1）;</code></pre></div>
                     <!-- class="section" -->
                     <div class="section">
                        <p class="subhead3" id="GUID-B69FD5E1-7DDC-4867-9C26-9849C507E8C4__GUID-B3AFC614-9ED3-4B9C-BD9B-C22BF2E71DE4">更改表</p>
                        <p>系统管理或复合分片数据库中的分片表不支持以下选项：</p>
                        <ul style="list-style-type:disc">
                           <li>
                              <p>改名</p>
                           </li>
                           <li>
                              <p>添加外键约束</p>
                           </li>
                           <li>
                              <p>单个分区和子分区上的所有操作</p>
                           </li>
                           <li>
                              <p>分片上与分区相关的所有操作，TRUNCATE分区，UNUSABLE LOCAL INDEXES和REBUILD UNUSABLE LOCAL INDEXES除外</p>
                           </li>
                        </ul>
                        <p>重复表不支持以下内容：</p>
                        <ul style="list-style-type:disc">
                           <li>
                              <p>数据类型：long，abstract（支持MDSYS数据类型），REF</p>
                           </li>
                           <li>
                              <p>列选项：矢量编码，不可见列，嵌套表</p>
                           </li>
                           <li>
                              <p>对象类型</p>
                           </li>
                           <li>
                              <p>集群表</p>
                           </li>
                           <li>
                              <p>外部表</p>
                           </li>
                           <li>
                              <p>ILM政策</p>
                           </li>
                           <li>
                              <p>PARENT条款</p>
                           </li>
                           <li>
                              <p>闪回表操作</p>
                           </li>
                           <li>
                              <p>系统和参考分区</p>
                           </li>
                           <li>
                              <p>启用<code class="codeph">nologging</code>选项</p>
                           </li>
                           <li>
                              <p>截断表</p>
                           </li>
                           <li>
                              <p>删除重复的表实体化视图日志</p>
                           </li>
                           <li>
                              <p>删除分片上的重复表实体化视图</p>
                           </li>
                           <li>
                              <p>更改分片上的物化视图（重复表）</p>
                           </li>
                        </ul>
                     </div>
                     <!-- class="section" -->
                     <div class="section" id="GUID-B69FD5E1-7DDC-4867-9C26-9849C507E8C4__ALTERSESSION-3E7191AD">
                        <p class="subhead3" id="GUID-B69FD5E1-7DDC-4867-9C26-9849C507E8C4__GUID-CBC0DE20-63C8-44D7-A2CF-256074B6D2D3">改变会话</p>
                        <p>会话级<code class="codeph">SHARD DDL</code>参数设置针对分片目录数据库发出的DDL的范围。
                        </p><pre class="pre codeblock"><code>ALTER SESSION {ENABLE | DISABLE} <span class="bold">SHARD DDL</span> ;</code></pre><p>启用<code class="codeph">SHARD DDL</code> ，会话中发出的所有DDL都在分片目录和所有分片上执行。禁用<code class="codeph">SHARD DDL</code> ，仅对分片目录数据库执行DDL。默认情况下，SDB用户（存在于所有分片和目录中的用户）启用<code class="codeph">SHARD DDL</code> 。要创建SDB用户，必须在运行<code class="codeph">CREATE USER</code>之前启用<code class="codeph">SHARD DDL</code>参数。</p>
                     </div>
                     <!-- class="section" -->
                  </div>
                  <div>
                     <div class="familylinks">
                        <div class="parentlink">
                           <p><strong>父主题：</strong> <a href="sharding-schema-design.html#GUID-FD5760B7-1F77-4A3C-A74C-2C70B2469E16" title="要在SDB中创建模式，必须在分片目录数据库上发出DDL命令，该数据库在分片上执行之前验证DDL并在本地执行它们。">Sharded数据库中的DDL执行</a></p>
                        </div>
                     </div>
                  </div>
                  
               </div>
            </div>
            <div class="sect2"><a id="GUID-67BC4EEF-91D7-4240-8975-06C94E2FEA8C" name="GUID-67BC4EEF-91D7-4240-8975-06C94E2FEA8C"></a><h3 id="SHARD-GUID-67BC4EEF-91D7-4240-8975-06C94E2FEA8C" class="sect3"><span class="enumeration_section">2.6</span> Sharded Database中的PL / SQL过程执行</h3>
               <div>
                  <p>与在配置中的所有分片上执行DDL语句的方式相同，Oracle提供的某些PL / SQL过程也是如此。这些特定过程调用的行为就像它们是分片DDL语句一样，它们被传播到所有分片，由目录跟踪，并在每次将新分片添加到配置时运行。</p>
                  <p>以下所有过程都可以表现为分片DDL语句。</p>
                  <ul id="GUID-67BC4EEF-91D7-4240-8975-06C94E2FEA8C__UL_SCD_CPH_2GB" style="list-style-type:disc">
                     <li>DBMS_FGA包中的任何过程</li>
                     <li>DBMS_RLS包中的任何过程</li>
                     <li>DBMS_STATS包中的以下过程：<ul id="GUID-67BC4EEF-91D7-4240-8975-06C94E2FEA8C__UL_QXH_FPH_2GB" style="list-style-type:disc">
                           <li>GATHER_INDEX_STATS</li>
                           <li>GATHER_TABLE_STATS</li>
                           <li>GATHER_SCHEMA_STATS</li>
                           <li>GATHER_DATABASE_STATS</li>
                           <li>GATHER_SYSTEM_STATS</li>
                        </ul>
                     </li>
                     <li>DBMS_GOLDENGATE_ADM包中的以下过程：<ul id="GUID-67BC4EEF-91D7-4240-8975-06C94E2FEA8C__UL_GGD_JPH_2GB" style="list-style-type:disc">
                           <li>ADD_AUTO_CDR</li>
                           <li>ADD_AUTO_CDR_COLUMN_GROUP</li>
                           <li>ADD_AUTO_CDR_DELTA_RES</li>
                           <li>ALTER_AUTO_CDR</li>
                           <li>ALTER_AUTO_CDR_COLUMN_GROUP</li>
                           <li>PURGE_TOMBSTONES</li>
                           <li>REMOVE_AUTO_CDR</li>
                           <li>REMOVE_AUTO_CDR_COLUMN_GROUP</li>
                           <li>REMOVE_AUTO_CDR_DELTA_RES</li>
                        </ul>
                     </li>
                  </ul>
                  <p>要以与分片DDL语句相同的方式运行其中一个过程，请执行以下步骤。</p>
                  <ol id="GUID-67BC4EEF-91D7-4240-8975-06C94E2FEA8C__OL_AHY_QPH_2GB">
                     <li>使用SQL * Plus作为具有gsm_pooladmin_role的数据库用户连接到分片目录数据库。</li>
                     <li>使用<code class="codeph">alter session enable shard ddl</code>启用分片DDL。
                     </li>
                     <li>使用名为<code class="codeph">SYS.EXEC_SHARD_PLSQL</code>的特定于分片的PL / SQL过程运行目标过程。<p>此过程采用单个CLOB参数，该参数是指定完全限定的过程名称及其参数的字符串。请注意，在不使用<code class="codeph">EXEC_SHARD_PLSQL</code>情况下运行目标过程会导致过程仅在目录上运行，并且不会传播到所有分片。在不指定完全限定名称的情况下运行该过程（例如， <code class="codeph">SYS.DBMS_RLS.ADD_POLICY</code> ）将导致错误。
                        </p>
                     </li>
                  </ol>
                  <p>例如，要在所有分片上运行<code class="codeph">DBMS_RLS.ADD_POLICY</code> ，请在启用分片DLL后从SQL * Plus执行以下操作。</p><pre class="pre codeblock"><code>exec sys.exec_shard_plsql（'sys.dbms_rls.add_policy（object_schema =&gt;''testuser1''，object_name =&gt;''DEPARTMENTS''，policy_name =&gt;''dept_vpd_pol''，function_schema =&gt;''testuser1''，policy_function = &gt;''authorized_emps''，statement_types =&gt;''INSERT，UPDATE，DELETE，SELECT，INDEX''，update_check =&gt; TRUE）'）;</code></pre><p>请注意目标过程调用规范中需要双引号，因为调用规范本身是<code class="codeph">exec_shard_plsql</code>的字符串参数。
                  </p>
                  <p>如果目标过程在分片目录数据库上正确执行，则它将排队等待处理所有当前部署的分片。目录上的目标过程执行中的任何错误都将返回到SQL * Plus会话。可以使用与DDL相同的方式跟踪在分片上执行期间的错误。</p>
               </div>
               <div>
                  <div class="familylinks">
                     <div class="parentlink">
                        <p><strong>父主题：</strong> <a href="sharding-schema-design.html#GUID-1B8DAEE1-A662-4516-9EA9-04FF711211C3" title="为了获得分片的好处，分片数据库的模式应该以最大化在单个分片上执行的数据库请求数的方式设计。">Sharded Database Schema Design</a></p>
                     </div>
                  </div>
               </div>
               
            </div>
            <div class="sect2"><a id="GUID-1ED42D4E-7A13-4303-9EF7-253BAE6A4999" name="GUID-1ED42D4E-7A13-4303-9EF7-253BAE6A4999"></a><h3 id="SHARD-GUID-1ED42D4E-7A13-4303-9EF7-253BAE6A4999" class="sect3"><span class="enumeration_section">2.7</span>在碎片上生成唯一序列号</h3>
               <div>
                  <p>Oracle Sharding允许您为非主键列生成跨分片的全局唯一序列号，并由分片数据库处理。</p>
                  <p>当customer_id是分片键时，客户通常需要为非主键列生成唯一ID，例如order_id。对于这种情况，此功能允许您跨分片生成唯一的序列号，而不需要您管理应用程序中给定非主键列的全局唯一性。</p>
                  <p>新对象<code class="codeph">SHARDED SEQUENCE</code>支持此功能。在分片目录上创建分片序列，但在每个分片上都有一个实例。每个实例生成单调递增的数字，这些数字属于与其他分片上使用的范围不重叠的范围。因此，每个生成的数字都是全球唯一的。
                  </p>
                  <p>例如，可以使用分片序列来为按客户ID分片的表生成唯一的订单号。使用客户ID作为密钥建立与分片的连接的应用程序可以使用分片序列的本地实例来生成全局唯一的订单号。</p>
                  <p>请注意，分片序列生成的数字不能立即用作插入此分片的新行的分片键，因为键值可能属于另一个分片，插入将导致错误。要插入新行，应用程序应首先生成分片键的值，然后使用它连接到相应的分片。生成分片键新值的典型方法是在分片目录上使用常规（非分片）序列。</p>
                  <p>如果单个分片密钥生成器成为瓶颈，则可以使用分片序列来实现此目的。在这种情况下，应用程序应连接到随机分片（使用全局服务而不指定分片键），从分片序列中获取唯一键值，然后使用键值连接到相应的分片。</p>
                  <p>为了支持此功能，新的<code class="codeph">SEQUENCE</code>对象的条款， <code class="codeph">SHARD</code>和<code class="codeph">NOSHARD</code> ，包括在<code class="codeph">SEQUENCE</code>对象的DDL语法，如下面的<code class="codeph">CREATE</code>语句的语法。
                  </p><pre class="pre codeblock"><code>创建| ALTER SEQUENCE [架构。 ]序列[{INCREMENT BY | START WITH}整数| {MAXVALUE整数| NOMAXVALUE} | {MINVALUE整数| NOMINVALUE} | {CYCLE | NOCYCLE} | {CACHE整数| NOCACHE} | {订购| NOORDER} | {SCALE {EXTEND | NOEXTEND} | NOSCALE} | <span class="bold">{SHARD {EXTEND | NOEXTEND} | NOSHARD}</span> ]</code></pre><div class="section">
                     <p><code class="codeph">NOSHARD</code>是序列的默认值。如果指定了<code class="codeph">SHARD</code>子句，则此属性将在序列对象的字典表中注册，并使用<code class="codeph">DBA_SEQUENCES</code> ， <code class="codeph">USER_SEQUENCES</code>和<code class="codeph">ALL_SEQUENCES</code>视图显示。
                     </p>
                     <p>当<code class="codeph">SHARD</code>被指定， <code class="codeph">EXTEND</code>和<code class="codeph">NOEXTEND</code>子句定义分片序列的行为。指定<code class="codeph">EXTEND</code> ，生成的序列值全部为长度<span class="italic">（x + y）</span> ，其中<span class="italic">x</span>是大小为4的<code class="codeph">SHARD</code>偏移量的长度（对应于最大碎片数量的宽度，即1000）序列值的开头， <span class="italic">y</span>是序列<code class="codeph">MAXVALUE</code> / <code class="codeph">MINVALUE</code>的最大位数。</p>
                     <p>为默认设置<code class="codeph">SHARD</code>条文是<code class="codeph">NOEXTEND</code> 。使用<code class="codeph">NOEXTEND</code>设置，生成的序列值最多与<code class="codeph">MAXVALUE</code> / <code class="codeph">MINVALUE</code>序列中的最大位数一样宽。此设置对于与使用序列填充固定宽度列的现有应用程序集成非常有用。在指定了<code class="codeph">SHARD NOEXTEND</code>的序列上调用<code class="codeph">NEXTVAL</code>时，如果生成的值需要比序列的<code class="codeph">MAXVALUE</code> / <code class="codeph">MINVALUE</code>更多的表示位数，则抛出用户错误。</p>
                     <p>如果还使用<code class="codeph">SHARD</code>子句指定了<code class="codeph">SCALE</code>子句，则序列会在分片内为多个实例和会话生成可伸缩值，这些实例和会话是全局唯一的。当使用<code class="codeph">SHARD</code>和<code class="codeph">SCALE</code>关键字指定<code class="codeph">EXTEND</code> ，生成的序列值都是长度<span class="italic">（x + y + z）</span> ，其中<span class="italic">x</span>是大小为4的前置<code class="codeph">SHARD</code>偏移的长度， <span class="italic">y</span>是可缩放偏移的长度（默认<span class="italic">值为</span> 6）， <span class="italic">z</span>是<code class="codeph">MAXVALUE</code> / <code class="codeph">MINVALUE</code>序列中的最大位数。</p>
                     <div class="infoboxnote" id="GUID-1ED42D4E-7A13-4303-9EF7-253BAE6A4999__GUID-2A9F25F6-BCCA-4C35-A3F5-DAEB0C31BBB2">
                        <p class="notep1">注意：</p>
                        <p>使用<code class="codeph">SHARD</code>子句时，请勿在序列上指定<code class="codeph">ORDER</code> 。使用<code class="codeph">SHARD</code>生成全局无序值。如果需要<code class="codeph">ORDER</code>则在每个节点上本地创建序列。
                        </p>
                        <p><code class="codeph">SHARD</code>关键字将与<code class="codeph">CACHE</code>和<code class="codeph">NOCACHE</code>操作模式结合使用。
                        </p>
                     </div>
                  </div>
                  <!-- class="section" -->
                  <div class="section"></div>
                  <!-- class="section" -->
               </div>
               <div>
                  <div class="infoboxnotealso" id="GUID-1ED42D4E-7A13-4303-9EF7-253BAE6A4999__GUID-C2BD0705-3628-44E3-9BE0-35FFD0041F42">
                     <p class="notep1">也可以看看：</p>
                     <p><a href="../sqlrf/Changes-in-This-Release-for-Oracle-Database-SQL-Language-Reference.html#SQLRF-GUID-3C11D3A9-8B14-4DCC-B212-B7FE57EE81E8" target="_blank"><span><cite>Oracle数据库SQL语言参考</cite></span></a></p>
                  </div>
                  <div class="familylinks">
                     <div class="parentlink">
                        <p><strong>父主题：</strong> <a href="sharding-schema-design.html#GUID-1B8DAEE1-A662-4516-9EA9-04FF711211C3" title="为了获得分片的好处，分片数据库的模式应该以最大化在单个分片上执行的数据库请求数的方式设计。">Sharded Database Schema Design</a></p>
                     </div>
                  </div>
               </div>
               
            </div>
         </div>
      </article>
   </body>
</html>