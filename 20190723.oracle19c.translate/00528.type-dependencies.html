<html lang="en-us" dir="ltr" xml:lang="en-us">
   <head>
      <meta http-equiv="Content-Type" content="text/html; charset=utf-8"></meta>
      <meta name="viewport" content="width=device-width, initial-scale=1"></meta>
      <meta http-equiv="X-UA-Compatible" content="IE=edge"></meta>
      <title>键入依赖项</title>
      <meta property="og:site_name" content="Oracle Help Center"></meta>
      <meta property="og:title" content="Object-Relational Developer&#39;s Guide "></meta>
      <meta property="og:description" content=""></meta>
      <link rel="stylesheet" href="/sp_common/book-template/ohc-book-template/css/book.css"></link>
      <link rel="shortcut icon" href="/sp_common/book-template/ohc-common/img/favicon.ico"></link>
      <meta name="application-name" content="Object-Relational Developer&#39;s Guide"></meta>
      <meta name="generator" content="DITA Open Toolkit version 1.8.5 (Mode = doc)"></meta>
      <meta name="plugin" content="SP_docbuilder HTML plugin release 18.2.2"></meta>
      <link rel="alternate" href="object-relational-developers-guide.pdf" title="PDF File" type="application/pdf"></link>
      <meta name="robots" content="all"></meta>
      <link rel="schema.dcterms" href="http://purl.org/dc/terms/"></link>
      <meta name="dcterms.created" content="2019-01-11T02:05:10-08:00"></meta>
      
      <meta name="dcterms.dateCopyrighted" content="1996, 2019"></meta>
      <meta name="dcterms.category" content="database"></meta>
      <meta name="dcterms.identifier" content="E96436-01"></meta>
      
      <meta name="dcterms.product" content="en/database/oracle/oracle-database/19"></meta>
      
      <link rel="prev" href="privileges-on-object-types-and-their-methods.html" title="Previous" type="text/html"></link>
      <link rel="next" href="synonyms-for-object-types.html" title="Next" type="text/html"></link>
      <script>
        document.write('<style type="text/css">');
        document.write('body > .noscript, body > .noscript ~ * { visibility: hidden; }');
        document.write('</style>');
     </script>
      <script src="/sp_common/book-template/requirejs/require.js" data-main="/sp_common/book-template/ohc-book-template/js/book-config"></script>
      <script>
            if (window.require === undefined) {
                document.write('<script data-main="sp_common/book-template/ohc-book-template/js/book-config" src="sp_common/book-template/requirejs/require.js"><\/script>');
                document.write('<link href="sp_common/book-template/ohc-book-template/css/book.css" rel="stylesheet"/>');
            }
        </script>
      <script type="application/json" id="ssot-metadata">{"primary":{"category":{"short_name":"database","element_name":"Database","display_in_url":true},"suite":{"short_name":"oracle","element_name":"Oracle","display_in_url":true},"product_group":{"short_name":"not-applicable","element_name":"Not applicable","display_in_url":false},"product":{"short_name":"oracle-database","element_name":"Oracle Database","display_in_url":true},"release":{"short_name":"19","element_name":"Release 19","display_in_url":true}}}</script>
      
    <meta name="dcterms.title" content="Object-Relational Developer&#39;s Guide"></meta>
    <meta name="dcterms.isVersionOf" content="ADOBJ"></meta>
    <meta name="dcterms.release" content="Release 19"></meta>
  </head>
   <body dir="ltr">
      <div class="noscript alert alert-danger text-center" role="alert">
         <a href="privileges-on-object-types-and-their-methods.html" class="pull-left"><span class="glyphicon glyphicon-chevron-left" aria-hidden="true"></span>上一页</a> <a href="synonyms-for-object-types.html" class="pull-right">下一页<span class="glyphicon glyphicon-chevron-right" aria-hidden="true"></span></a> <span class="fa fa-exclamation-triangle" aria-hidden="true"></span>必须启用JavaScript才能正确显示此内容</div>
      <article>
         <header>
            <ol class="breadcrumb" vocab="http://schema.org/" typeof="BreadcrumbList">
               <li property="itemListElement" typeof="ListItem"><a href="index.html" property="item" typeof="WebPage"><span property="name">对象关系开发人员指南</span></a></li>
               <li property="itemListElement" typeof="ListItem"><a href="managing-oracle-objects.html" property="item" typeof="WebPage"><span property="name">管理Oracle对象</span></a></li>
               <li class="active" property="itemListElement" typeof="ListItem">键入依赖项</li>
            </ol>
            <a id="GUID-7A7391E8-494A-4FEC-8954-B0FDBE8CC9AB" name="GUID-7A7391E8-494A-4FEC-8954-B0FDBE8CC9AB"></a><a id="ADOBJ00402"></a>
            
            <h2 id="ADOBJ-GUID-7A7391E8-494A-4FEC-8954-B0FDBE8CC9AB" class="sect2"><span class="enumeration_section">7.2</span>键入依赖关系</h2>
         </header>
         <div class="ind">
            <div>
               <p>类型依赖关系分为两大类：</p>
               <ul style="list-style-type:disc">
                  <li>
                     <p>类型相互依赖于其定义的情况，其中一种类型可能是另一种类型定义的一部分。</p>
                  </li>
                  <li>
                     <p>创建或删除类型的情况因类型具有的依赖性（如表或类型）而变得复杂。</p>
                  </li>
               </ul>
               <p>本节包括以下主题：</p>
               <ul style="list-style-type:disc">
                  <li>
                     <p><a href="type-dependencies.html#GUID-BA1896CD-3D75-4658-A768-47FC4EBBE078">创建不完整的类型</a></p>
                  </li>
                  <li>
                     <p><a href="type-dependencies.html#GUID-6EA4FADD-EACE-49CD-8ED8-8A0F5A297D6B">完成不完整类型</a></p>
                  </li>
                  <li>
                     <p><a href="type-dependencies.html#GUID-21C48D1A-5222-4C3B-A851-A11FE098B5E9">手动重新编译类型</a></p>
                  </li>
                  <li>
                     <p><a href="type-dependencies.html#GUID-DE251FEC-8F11-46E3-B696-05A15D35F8FB">将CREATE OR REPLACE TYPE与Type和Table Dependencies一起使用</a></p>
                  </li>
                  <li>
                     <p><a href="type-dependencies.html#GUID-B1BD4A66-A1A2-4A8D-BA75-406C2F5D732D" title="特定类型的可替换表或列不仅取决于该类型，还取决于该类型的所有子类型。">键入可替换表和列的依赖项</a></p>
                  </li>
                  <li>
                     <p><a href="type-dependencies.html#GUID-0CF9462B-1FAA-4C45-BE31-5BC70E981EFA">DROP TYPE FORCE选项</a></p>
                  </li>
                  <li>
                     <p><a href="synonyms-for-object-types.html#GUID-24E2C8E5-5900-46D3-8632-681B4ACC6714" title="您使用CREATE SYNONYM语句创建类型同义词。">创建类型同义词</a></p>
                  </li>
                  <li>
                     <p><a href="synonyms-for-object-types.html#GUID-26378111-A8E0-4B7C-BE8E-7293FCAE0E1E">使用类型同义词</a></p>
                  </li>
               </ul>
            </div><a id="ADOBJ7363"></a><a id="ADOBJ7651"></a><div class="props_rev_3"><a id="GUID-BA1896CD-3D75-4658-A768-47FC4EBBE078" name="GUID-BA1896CD-3D75-4658-A768-47FC4EBBE078"></a><h3 id="ADOBJ-GUID-BA1896CD-3D75-4658-A768-47FC4EBBE078" class="sect3"><span class="enumeration_section">7.2.1</span>创建不完整类型</h3>
               <div>
                  <div class="section">
                     <p>直接或通过中间类型相互依赖的类型称为相互依赖。例如，您可能希望定义对象类型<code class="codeph">employee</code>和<code class="codeph">department</code>以这样的方式的一个属性<code class="codeph">employee</code>是员工属于和一个属性的部门<code class="codeph">department</code>是谁管理部门的员工。
                     </p>
                     <p>如果使用箭头显示图表，显示一组相互依赖的类型之间的关系，则连接形成一个循环。要定义这样的循环依赖关系，必须对圆的至少一个段使用<code class="codeph">REF</code> 。
                     </p>
                     <p>例如，您可以定义<a href="type-dependencies.html#GUID-BA1896CD-3D75-4658-A768-47FC4EBBE078__BCGHICIC">例7-7中</a>显示的类型。
                     </p>
                  </div>
                  <!-- class="section" -->
                  <div class="example" id="GUID-BA1896CD-3D75-4658-A768-47FC4EBBE078__BCGHICIC">
                     <p class="titleinexample">示例7-7创建从属对象类型</p><pre class="oac_no_warn" dir="ltr">- 需要Ex。 7-1和密码CONNECT user1  - 输入密码ALTER SESSION SET PLSQL_WARNINGS ='enable：all'; <span class="bold">CREATE TYPE部门; //占位符</span> / CREATE TYPE员工AS OBJECT（名称VARCHAR2（30），部门REF部门，supv REF员工）; / CREATE TYPE emp_list AS员工表; / <span class="bold">CREATE TYPE部门AS OBJECT</span> （名称VARCHAR2（30），mgr REF员工，员工emp_list）; /</pre></div>
                  <!-- class="example" -->
                  <div class="section">
                     <p>这是一组合法的相互依赖类型和SQL DDL语句的合法序列。Oracle数据库编译它没有错误。</p>
                     <p>请注意， <a href="type-dependencies.html#GUID-BA1896CD-3D75-4658-A768-47FC4EBBE078__BCGHICIC">示例7-7</a>中的代码会两次创建类型<code class="codeph">department</code> 。第一个语句是一个可选的，不完整的<code class="codeph">department</code>声明，作为<code class="codeph">employee</code>的<code class="codeph">REF</code>属性指向的占位符。声明不完整，因为它省略了<code class="codeph">AS</code> <code class="codeph">OBJECT</code>短语并且没有列出任何属性或方法。这些在稍后的完整声明中指定，以完成该类型。与此同时， <code class="codeph">department</code>被创建为不完整的对象类型。这使得<code class="codeph">employee</code>的编译能够顺利进行。
                     </p>
                     <p>如果不创建不完整类型作为占位符，则引用缺少类型的类型仍会编译，但编译会继续出错。例如，如果<code class="codeph">department</code>根本不存在，Oracle数据库会将其创建为不完整类型并编译有错误的<code class="codeph">employee</code> 。然后， <code class="codeph">employee</code>将在下次某些操作访问时重新编译。这一次，如果已经创建了它所依赖的所有类型并且满足了它的依赖性，那么它将编译而不会出错。
                     </p>
                     <p>不完整类型还允许您创建包含尚未创建的子类型的<code class="codeph">REF</code>属性的类型。要创建这样的超类型，首先要创建一个不完整类型的要引用的子类型。创建超类型后创建完整的子类型。
                     </p>
                  </div>
                  <!-- class="section" -->
               </div>
            </div><a id="ADOBJ7364"></a><div class="props_rev_3"><a id="GUID-6EA4FADD-EACE-49CD-8ED8-8A0F5A297D6B" name="GUID-6EA4FADD-EACE-49CD-8ED8-8A0F5A297D6B"></a><h3 id="ADOBJ-GUID-6EA4FADD-EACE-49CD-8ED8-8A0F5A297D6B" class="sect3"><span class="enumeration_section">7.2.2</span>完成不完整类型</h3>
               <div>
                  <div class="section">
                     <p>当您创建了由不完整类型引用的所有类型时，请完成不完整类型的声明，因为不再需要它保持不完整。</p>
                     <p>完成该类型会重新编译它并使系统能够释放各种锁。使用<code class="codeph">CREATE</code> <code class="codeph">TYPE</code>语句完成类型。
                     </p>
                  </div>
                  <!-- class="section" -->
                  <div class="section">
                     <ul style="list-style-type:disc">
                        <li>
                           <p>执行<code class="codeph">CREATE</code> <code class="codeph">TYPE</code>语句，该语句指定<code class="codeph">TYPE</code>的属性和方法，如<a href="type-dependencies.html#GUID-BA1896CD-3D75-4658-A768-47FC4EBBE078__BCGHICIC">例7-7</a>末尾所示。
                           </p>
                        </li>
                     </ul>
                     <p>此外，您必须完成数据库为您创建的任何不完整类型。如果，如上一节所述，您没有明确地将<code class="codeph">department</code>创建为不完整类型，那么数据库就是这样做的。在这种情况下，您仍需要完成它。
                     </p>
                     <p>您必须将不完整的对象类型作为对象类型完成：您无法将对象类型作为集合类型（嵌套表类型或数组类型）完成。唯一的选择是放弃类型。</p>
                  </div>
                  <!-- class="section" -->
               </div>
            </div><a id="ADOBJ7368"></a><div class="props_rev_3"><a id="GUID-21C48D1A-5222-4C3B-A851-A11FE098B5E9" name="GUID-21C48D1A-5222-4C3B-A851-A11FE098B5E9"></a><h3 id="ADOBJ-GUID-21C48D1A-5222-4C3B-A851-A11FE098B5E9" class="sect3"><span class="enumeration_section">7.2.3</span>手动重新编译类型</h3>
               <div>
                  <div class="section">
                     <p>如果创建了具有编译错误的类型，并且您尝试对其进行操作（例如创建表或插入行），则可能会收到错误。您需要在尝试操作之前重新编译该类型。您使用<code class="codeph">ALTER</code> <code class="codeph">TYPE</code>语句重新编译。
                     </p>
                  </div>
                  <!-- class="section" -->
                  <div class="section">
                     <ul style="list-style-type:disc">
                        <li>
                           <p>执行<code class="codeph">ALTER</code> <code class="codeph">TYPE</code> <span class="italic"><code class="codeph">typename</code></span> <code class="codeph">COMPILE</code>语句。成功编译类型后，再次尝试操作。
                           </p>
                        </li>
                     </ul>
                  </div>
                  <!-- class="section" -->
               </div>
            </div><a id="ADOBJ7366"></a><a id="ADOBJ7365"></a><div class="props_rev_3"><a id="GUID-DE251FEC-8F11-46E3-B696-05A15D35F8FB" name="GUID-DE251FEC-8F11-46E3-B696-05A15D35F8FB"></a><h3 id="ADOBJ-GUID-DE251FEC-8F11-46E3-B696-05A15D35F8FB" class="sect3"><span class="enumeration_section">7.2.4</span>使用带有类型和表依赖关系的CREATE或REPLACE TYPE</h3>
               <div>
                  <div class="section">
                     <p>如果要替换的类型具有表或类型依赖项，则<code class="codeph">CREATE</code> <code class="codeph">OR</code> <code class="codeph">REPLACE</code> <code class="codeph">TYPE</code>语句将引发错误。这适用于对象，varrays和嵌套表类型。这也适用于涉及继承或类型组合的类型依赖项（将一种类型嵌入另一种类型）。后者可能是一种类型是另一种类型的属性的情况。
                     </p>
                     <p>使用带有<code class="codeph">CREATE</code> <code class="codeph">OR</code> <code class="codeph">REPLACE</code> <code class="codeph">TYPE</code>语句的<code class="codeph">FORCE</code>选项可以替换类型依赖项但不依赖于表依赖项的类型。表依赖性仍会导致错误。
                     </p>
                  </div>
                  <!-- class="section" -->
                  <div class="section">
                     <ul style="list-style-type:disc">
                        <li>
                           <p>如果<code class="codeph">FORCE</code>选项具有类型依赖性，请将<code class="codeph">FORCE</code>选项与<code class="codeph">CREATE</code> <code class="codeph">OR</code> <code class="codeph">REPLACE</code> <code class="codeph">TYPE</code>语句一起使用以替换类型。
                           </p>
                        </li>
                     </ul>
                     <p><a href="type-dependencies.html#GUID-DE251FEC-8F11-46E3-B696-05A15D35F8FB__CHDHAAFE">例7-8</a>显示了由于类型依赖性而失败的<code class="codeph">CREATE</code> <code class="codeph">OR</code> <code class="codeph">REPLACE</code>语句（第二个语句）。
                     </p>
                  </div>
                  <!-- class="section" -->
                  <div class="example" id="GUID-DE251FEC-8F11-46E3-B696-05A15D35F8FB__CHDHAAFE">
                     <p class="titleinexample">例7-8创建或替换类型和表失败</p><pre class="oac_no_warn" dir="ltr">SQL&gt; CREATE类型t1 AS OBJECT（一个数字）不是最终的; 2 /创建类型。SQL&gt; CREATE TYPE t2 <span class="bold">UNDER t1</span> （b varchar（10））; 2 /创建类型。SQL&gt; CREATE OR REPLACE TYPE t1 AS OBJECT（c varchar（20））; 2 /创建或替换类型t1作为对象（c varchar（20））; *第1行的错误：ORA-02303：不能删除或替换类型或表依赖的类型</pre></div>
                  <!-- class="example" -->
               </div>
            </div><a id="ADOBJ7367"></a><div class="props_rev_3"><a id="GUID-C4E930C1-BEE0-43DC-9C32-C0D6B9FDF3A3" name="GUID-C4E930C1-BEE0-43DC-9C32-C0D6B9FDF3A3"></a><h3 id="ADOBJ-GUID-C4E930C1-BEE0-43DC-9C32-C0D6B9FDF3A3" class="sect3"><span class="enumeration_section">7.2.5</span>用力创建或替换类型</h3>
               <div>
                  <div class="section">
                     <p>如果类型具有表依赖性，则<code class="codeph">CREATE</code> <code class="codeph">OR</code> <code class="codeph">REPLACE</code> <code class="codeph">FORCE</code>语句将失败，因为无法替换具有表依赖关系的类型。
                     </p>
                     <p><a href="type-dependencies.html#GUID-C4E930C1-BEE0-43DC-9C32-C0D6B9FDF3A3__CHDGIJHC">示例7-9</a>显示了<code class="codeph">CREATE</code> <code class="codeph">OR</code> <code class="codeph">REPLACE</code> <code class="codeph">FORCE</code>语句成功替换具有类型依赖关系的类型然后使用父类型创建表的代码。但是，最终的<code class="codeph">CREATE</code> <code class="codeph">OR</code> <code class="codeph">REPLACE</code> <code class="codeph">FORCE</code>语句失败，因为类型现在具有表依赖性，即使使用<code class="codeph">FORCE</code>选项，也无法替换具有表依赖性的类型。
                     </p>
                     <div class="infoboxnotealso" id="GUID-C4E930C1-BEE0-43DC-9C32-C0D6B9FDF3A3__GUID-3402862C-2992-4DA3-A684-2A8B4B3F165B">
                        <p class="notep1">也可以看看：</p>
                        <p>有关<code class="codeph">CREATE</code> <code class="codeph">OR REPLACE TYPE</code> SQL语句的详细信息，请<a href="../lnpls/CREATE-TYPE-statement.html#LNPLS01375" target="_blank"><span class="italic">参见Oracle Database PL / SQL语言参考</span></a></p>
                     </div>
                  </div>
                  <!-- class="section" -->
                  <div class="example" id="GUID-C4E930C1-BEE0-43DC-9C32-C0D6B9FDF3A3__CHDGIJHC">
                     <p class="titleinexample">示例7-9使用FORCE创建或替换</p><pre class="oac_no_warn" dir="ltr">SQL&gt; CREATE OR REPLACE TYPE t1 FORCE AS OBJECT（c varchar（20））; 2 /创建类型。SQL&gt; CREATE TABLE tb1（c1 t1）;表创建。SQL&gt; CREATE OR REPLACE TYPE t1 FORCE AS OBJECT（d number）; 2 / <code class="codeph">CREATE OR REPLACE TYPE</code> t1 FORCE as OBJECT（d number）; *第1行的错误：ORA-22866：无法用表依赖项替换类型</pre></div>
                  <!-- class="example" -->
               </div>
            </div><a id="ADOBJ7652"></a><a id="ADOBJ7369"></a><div class="props_rev_3"><a id="GUID-B1BD4A66-A1A2-4A8D-BA75-406C2F5D732D" name="GUID-B1BD4A66-A1A2-4A8D-BA75-406C2F5D732D"></a><h3 id="ADOBJ-GUID-B1BD4A66-A1A2-4A8D-BA75-406C2F5D732D" class="sect3"><span class="enumeration_section">7.2.6可</span>替换表和列的类型依赖性</h3>
               <div>
                  <p>特定类型的可替换表或列不仅取决于该类型，还取决于该类型的所有子类型。</p>
                  <p>这是因为对于在类型的子类型中添加的每个属性，将隐藏列添加到表中。即使可替换表或列不包含该子类型的数据，也会添加隐藏列。</p>
                  <p>在<a href="type-dependencies.html#GUID-B1BD4A66-A1A2-4A8D-BA75-406C2F5D732D__CHDCAFBG">示例7-10中</a> ， <code class="codeph">person_typ</code>类型的<code class="codeph">persons</code>表不仅依赖于<code class="codeph">person_typ</code> ，还依赖于<code class="codeph">person_typ</code>子类型<code class="codeph">student_typ</code>和<code class="codeph">part_time_student_typ</code> 。
                  </p>
                  <p>如果尝试删除具有依赖类型，表或列的子类型，则<code class="codeph">DROP</code> <code class="codeph">TYPE</code>语句将返回错误并中止。因此，尝试删除<code class="codeph">part_time_student_typ</code>会因为依赖<code class="codeph">persons</code>表而引发错误。
                  </p>
                  <p>如果存在依赖表或列但不包含要删除的类型的数据，则可以使用<code class="codeph">VALIDATE</code>关键字删除该类型。<code class="codeph">VALIDATE</code>关键字使Oracle数据库检查指定类型的实际存储实例，如果未找到，则删除该类型。这还会删除与该类型唯一的属性关联的隐藏列。
                  </p>
                  <p>在<a href="type-dependencies.html#GUID-B1BD4A66-A1A2-4A8D-BA75-406C2F5D732D__CHDCAFBG">示例7-10中</a> ，第一个<code class="codeph">DROP</code> <code class="codeph">TYPE</code>语句失败，因为<code class="codeph">part_time_student_typ</code>具有从属表（ <code class="codeph">persons</code> ）。但是如果<code class="codeph">persons</code>包含<code class="codeph">part_time_student_typ</code>实例（也没有任何其他依赖表或列），则<code class="codeph">VALIDATE</code>关键字会导致第二个<code class="codeph">DROP</code> <code class="codeph">TYPE</code>语句成功。
                  </p>
                  <div class="example" id="GUID-B1BD4A66-A1A2-4A8D-BA75-406C2F5D732D__CHDCAFBG">
                     <p class="titleinexample">示例7-10带有和不带有VALIDATE的DROP TYPE</p><pre class="oac_no_warn" dir="ltr">CREATE TYPE person_typ AS OBJECT（idno NUMBER，名称VARCHAR2（30），手机VARCHAR2（20））NOT FINAL; / CREATE TYPE student_typ UNDER person_typ（dept_id NUMBER，major VARCHAR2（30））NOT FINAL; / CREATE TYPE part_time_student_typ UNDER student_typ（number_hours NUMBER）; / CREATE TABLE人员OF person_typ; - 由于存在Persons表<span class="bold">DROP</span> <span class="bold">TYPE</span> part_time_student_typ  - 不正确的语句，以下生成错误; -继成功，如果有part_time_student_typ <span class="bold">DROP</span> <span class="bold">TYPE</span> part_time_student_typ <span class="bold">验证</span>了没有存储的情况;</pre><div class="infoboxnote" id="GUID-B1BD4A66-A1A2-4A8D-BA75-406C2F5D732D__GUID-EEC79704-B4BC-4E36-8675-6061EA6EE498">
                        <p class="notep1">注意：</p>
                        <p>Oracle建议您在删除子类型时始终使用<code class="codeph">VALIDATE</code>选项。
                        </p>
                     </div>
                     <div class="infoboxnotealso" id="GUID-B1BD4A66-A1A2-4A8D-BA75-406C2F5D732D__GUID-99604A71-923E-4B9A-9FBC-CC44D3E7B96E">
                        <p class="notep1">也可以看看：</p>
                        <p><span class="q">“ <a href="inheritance-in-sql-object-types.html#GUID-903F72C4-E4CE-4175-9972-EA13450F2DFB">类型层次中的类型替换</a> ”</span>用于进一步解释可替代性</p>
                     </div>
                  </div>
                  <!-- class="example" -->
               </div>
            </div><a id="ADOBJ7370"></a><div class="props_rev_3"><a id="GUID-0CF9462B-1FAA-4C45-BE31-5BC70E981EFA" name="GUID-0CF9462B-1FAA-4C45-BE31-5BC70E981EFA"></a><h3 id="ADOBJ-GUID-0CF9462B-1FAA-4C45-BE31-5BC70E981EFA" class="sect3"><span class="enumeration_section">7.2.7</span> DROP TYPE FORCE选项</h3>
               <div>
                  <p><code class="codeph">DROP</code> <code class="codeph">TYPE</code>语句有一个<code class="codeph">FORCE</code>选项，即使它可能具有依赖类型或表，也会导致类型被删除。
                  </p>
                  <p>请谨慎使用<code class="codeph">FORCE</code>选项，因为存在的任何相关类型或表都标记为无效，并且在删除类型时将无法访问。由于此原因标记为无效的表中的数据永远不能再次访问。可以在这样的表上执行的唯一操作是删除它。
                  </p>
                  <div class="infoboxnotealso" id="GUID-0CF9462B-1FAA-4C45-BE31-5BC70E981EFA__GUID-085938A7-BE34-46B4-8B0B-56A6F25E9CF8">
                     <p class="notep1">也可以看看：</p>
                     <p>有关如何更改类型的信息，请参阅<span class="q">“ <a href="type-evolution.html#GUID-AD083363-701A-4CE4-8795-C55D7EBCCB47">类型演变</a> ”</span> 。
                     </p>
                  </div>
               </div>
            </div>
         </div>
      </article>
   </body>
</html>