<!DOCTYPE html
  SYSTEM "about:legacy-compat">
<html xml:lang="en-us" lang="en-us">
   <head>
      <meta http-equiv="Content-Type" content="text/html; charset=utf-8">
      <meta name="viewport" content="width=device-width, initial-scale=1">
      <meta http-equiv="X-UA-Compatible" content="IE=edge">
      <meta name="abstract" content="Oracle Text provides ways to improve your query and indexing performance.">
      <meta name="description" content="Oracle Text provides ways to improve your query and indexing performance.">
      <title>Tuning Oracle Text</title>
      <meta property="og:site_name" content="Oracle Help Center">
      <meta property="og:title" content="Application Developer's Guide ">
      <meta property="og:description" content="Oracle Text provides ways to improve your query and indexing performance.">
      <link rel="stylesheet" href="/sp_common/book-template/ohc-book-template/css/book.css">
      <link rel="shortcut icon" href="/sp_common/book-template/ohc-common/img/favicon.ico">
      <meta name="application-name" content="Application Developer's Guide">
      <meta name="generator" content="DITA Open Toolkit version 1.8.5 (Mode = doc)">
      <meta name="plugin" content="SP_docbuilder HTML plugin release 18.2.2">
      <link rel="alternate" href="text-application-developers-guide.pdf" title="PDF File" type="application/pdf">
      <meta name="robots" content="all">
      <link rel="schema.dcterms" href="http://purl.org/dc/terms/">
      <meta name="dcterms.created" content="2019-01-07T01:45:16-08:00">
      
      <meta name="dcterms.dateCopyrighted" content="2001, 2019">
      <meta name="dcterms.category" content="database">
      <meta name="dcterms.identifier" content="E96275-01">
      
      <meta name="dcterms.product" content="en/database/oracle/oracle-database/19">
      
      <link rel="prev" href="classifying-documents-in-oracle-text.html" title="Previous" type="text/html">
      <link rel="next" href="searching-document-sections-in-oracle-text.html" title="Next" type="text/html">
      <script>
        document.write('<style type="text/css">');
        document.write('body > .noscript, body > .noscript ~ * { visibility: hidden; }');
        document.write('</style>');
     </script>
      <script data-main="/sp_common/book-template/ohc-book-template/js/book-config" src="/sp_common/book-template/requirejs/require.js"></script>
      <script>
            if (window.require === undefined) {
                document.write('<script data-main="sp_common/book-template/ohc-book-template/js/book-config" src="sp_common/book-template/requirejs/require.js"><\/script>');
                document.write('<link href="sp_common/book-template/ohc-book-template/css/book.css" rel="stylesheet"/>');
            }
        </script>
      <script type="application/json" id="ssot-metadata">{"primary":{"category":{"short_name":"database","element_name":"Database","display_in_url":true},"suite":{"short_name":"oracle","element_name":"Oracle","display_in_url":true},"product_group":{"short_name":"not-applicable","element_name":"Not applicable","display_in_url":false},"product":{"short_name":"oracle-database","element_name":"Oracle Database","display_in_url":true},"release":{"short_name":"19","element_name":"Release 19","display_in_url":true}}}</script>
      
    <meta name="dcterms.title" content="Text Application Developer's Guide">
    <meta name="dcterms.isVersionOf" content="CCAPP">
    <meta name="dcterms.release" content="Release 19">
  </head>
   <body>
      <div class="noscript alert alert-danger text-center" role="alert">
         <a href="classifying-documents-in-oracle-text.html" class="pull-left"><span class="glyphicon glyphicon-chevron-left" aria-hidden="true"></span>Previous</a>
         <a href="searching-document-sections-in-oracle-text.html" class="pull-right">Next<span class="glyphicon glyphicon-chevron-right" aria-hidden="true"></span></a>
         <span class="fa fa-exclamation-triangle" aria-hidden="true"></span> JavaScript must be enabled to correctly display this content
        
      </div>
      <article>
         <header>
            <ol class="breadcrumb" vocab="http://schema.org/" typeof="BreadcrumbList">
               <li property="itemListElement" typeof="ListItem"><a href="index.html" property="item" typeof="WebPage"><span property="name">Application Developer's Guide </span></a></li>
               <li class="active" property="itemListElement" typeof="ListItem"> Tuning Oracle Text </li>
            </ol>
            <a id="GUID-96F4B2AC-59E5-4B02-A85B-A7B2C20C4BDF" name="GUID-96F4B2AC-59E5-4B02-A85B-A7B2C20C4BDF"></a><a id="CCAPP0500"></a>
            
            <h2 id="CCAPP-GUID-96F4B2AC-59E5-4B02-A85B-A7B2C20C4BDF" class="sect2"><span class="enumeration_chapter">10 </span> Tuning Oracle Text 
            </h2>
         </header>
         <div class="ind">
            <div>
               <p>Oracle Text provides ways to improve your query and indexing performance. </p>
               <p>This chapter contains the following topics:</p>
               <ul style="list-style-type: disc;">
                  <li>
                     <p><a href="tuning-oracle-text.html#GUID-6F920664-89E8-4CF5-A974-225F51E276EF">Optimizing Queries with Statistics</a></p>
                  </li>
                  <li>
                     <p><a href="tuning-oracle-text.html#GUID-3B8371B5-F7AC-4A94-80EE-510B7820EE6D">Optimizing Queries for Response Time</a> 
                     </p>
                  </li>
                  <li>
                     <p><a href="tuning-oracle-text.html#GUID-21432876-BCE4-4250-A67F-C6E76017B872">Optimizing Queries for Throughput</a></p>
                  </li>
                  <li>
                     <p><a href="tuning-oracle-text.html#GUID-0A82CB4D-A252-4838-ACA1-8EF10FCD9A29">Composite Domain Index in Oracle Text</a></p>
                  </li>
                  <li>
                     <p><a href="tuning-oracle-text.html#GUID-F315BDEC-F569-4A1C-939F-99B3B64726FA">Performance Tuning with CDI</a></p>
                  </li>
                  <li>
                     <p><a href="tuning-oracle-text.html#GUID-E282E4C7-6F64-46AB-909D-1E2F07A563CF">Solving Index and Query Bottlenecks by Using Tracing</a></p>
                  </li>
                  <li>
                     <p><a href="tuning-oracle-text.html#GUID-51F4ABF4-83A1-44EA-80FB-EF72430D3A1A">Using Parallel Queries</a></p>
                  </li>
                  <li>
                     <p><a href="tuning-oracle-text.html#GUID-45AA18EF-710D-4A32-8A6C-3522054B10A8">Tuning Queries with Blocking Operations</a></p>
                  </li>
                  <li>
                     <p><a href="tuning-oracle-text.html#GUID-90312BBE-00D7-4200-B6AF-77CAFAA5D2F3">Frequently Asked Questions About Query Performance</a></p>
                  </li>
                  <li>
                     <p><a href="tuning-oracle-text.html#GUID-82000645-74B9-407E-A9C0-C1ACEE319BD9">Frequently Asked Questions About Indexing Performance</a></p>
                  </li>
                  <li>
                     <p><a href="tuning-oracle-text.html#GUID-45D2A9BB-17BC-4B68-A3F1-A0C01B4ACDA3">Frequently Asked Questions About Updating the Index</a></p>
                  </li>
               </ul>
            </div><a id="CCAPP9633"></a><div class="props_rev_3"><a id="GUID-6F920664-89E8-4CF5-A974-225F51E276EF" name="GUID-6F920664-89E8-4CF5-A974-225F51E276EF"></a><h3 id="CCAPP-GUID-6F920664-89E8-4CF5-A974-225F51E276EF" class="sect3"><span class="enumeration_section">10.1 </span>Optimizing Queries with Statistics
               </h3>
               <div>
                  <p>Query optimization with statistics uses the collected statistics on the tables and indexes in a query to select an execution plan that can process the query in the most efficient manner. As a general rule, Oracle recommends that you collect statistics on your base table if you are interested in improving your query performance. Optimizing with statistics enables a more accurate estimation of the selectivity and costs of the <code class="codeph">CONTAINS</code> predicate and thus a better execution plan.
                  </p>
                  <p>The optimizer attempts to choose the best execution plan based on the following parameters:</p>
                  <ul style="list-style-type: disc;">
                     <li>
                        <p>The selectivity on the <code class="codeph">CONTAINS</code> predicate
                        </p>
                     </li>
                     <li>
                        <p>The selectivity of other predicates in the query</p>
                     </li>
                     <li>
                        <p>The CPU and I/O costs of processing the <code class="codeph">CONTAINS</code> predicates
                        </p>
                     </li>
                  </ul>
                  <p>The following topics discuss how to use statistics with the extensible query optimizer:</p>
                  <ul style="list-style-type: disc;">
                     <li>
                        <p><a href="tuning-oracle-text.html#GUID-E4F013A8-E83C-44AF-B9A4-CA1FBF717730">Collecting Statistics</a></p>
                     </li>
                     <li>
                        <p><a href="tuning-oracle-text.html#GUID-A2137127-9B0D-48EE-962F-2408F49FA244">Query Optimization with Statistics Example</a></p>
                     </li>
                     <li>
                        <p><a href="tuning-oracle-text.html#GUID-763C6A28-275A-4C6F-A740-5A02F9E13575">Re-Collecting Statistics</a></p>
                     </li>
                     <li>
                        <p><a href="tuning-oracle-text.html#GUID-225089FD-7E86-4DB0-8D37-D04213D1D053">Deleting Statistics</a></p>
                     </li>
                  </ul>
                  <div class="infoboxnote" id="GUID-6F920664-89E8-4CF5-A974-225F51E276EF__GUID-38AC436F-535D-4E4A-BA59-5DA54E2BC1D1">
                     <p class="notep1">Note:</p>
                     <p>Importing and exporting statistics on domain indexes, including Oracle Text indexes, is not supported with the <code class="codeph">DBMS_STATS</code> package. For more information on importing and exporting statistics, see the <a href="../arpls/DBMS_STATS.html#ARPLS059" target="_blank"><span class="italic">Oracle Database PL/SQL Packages and Types Reference</span></a>.
                     </p>
                  </div>
                  <div class="infoboxnotealso" id="GUID-6F920664-89E8-4CF5-A974-225F51E276EF__GUID-EE16CCEF-1071-4816-8DF6-2F23D7724EC4">
                     <p class="notep1">See Also:</p>
                     <p><a href="../ccref/oracle-text-CONTAINS-query-operators.html#CCREF0300" target="_blank"><span class="italic">Oracle Text Reference</span></a> for information on the <code class="codeph">CONTAINS</code> query operator
                     </p>
                  </div>
               </div><a id="CCAPP9634"></a><div class="props_rev_3"><a id="GUID-E4F013A8-E83C-44AF-B9A4-CA1FBF717730" name="GUID-E4F013A8-E83C-44AF-B9A4-CA1FBF717730"></a><h4 id="CCAPP-GUID-E4F013A8-E83C-44AF-B9A4-CA1FBF717730" class="sect4"><span class="enumeration_section">10.1.1 </span>Collecting Statistics
                  </h4>
                  <div>
                     <p>By default, Oracle Text uses the cost-based optimizer (CBO) to determine the best execution plan for a query. </p>
                     <p>To enable the optimizer to better estimate costs, calculate the statistics on the table you queried table:</p><pre class="oac_no_warn" dir="ltr">ANALYZE TABLE &lt;table_name&gt; COMPUTE STATISTICS;
</pre><p>Alternatively, estimate the statistics on a sample of the table:</p><pre class="oac_no_warn" dir="ltr">ANALYZE TABLE &lt;table_name&gt; ESTIMATE STATISTICS 1000 ROWS;
</pre><p>or</p><pre class="oac_no_warn" dir="ltr">ANALYZE TABLE &lt;table_name&gt; ESTIMATE STATISTICS 50 PERCENT;
</pre><p>You can also collect statistics in parallel with the <code class="codeph">DBMS_STATS.GATHER_TABLE_STATS</code> procedure:
                     </p><pre class="oac_no_warn" dir="ltr">begin
 
DBMS_STATS.GATHER_TABLE_STATS('owner', 'table_name',
                                       estimate_percent=&gt;50,
                                       block_sample=&gt;TRUE,
                                       degree=&gt;4) ;
 
end  ;
</pre><p>These statements collect statistics on all objects associated with <code class="codeph">table_name,</code> including the table columns and any indexes (b-tree, bitmap, or Text domain) associated with the table.
                     </p>
                     <p>To re-collect the statistics on a table, enter the <code class="codeph">ANALYZE</code> statement as many times as necessary or use the <code class="codeph">DBMS_STATS</code> package.
                     </p>
                     <p>By collecting statistics on the Text domain index, the CBO in Oracle Database can perform the following tasks:</p>
                     <ul style="list-style-type: disc;">
                        <li>
                           <p>Estimate the selectivity of the <code class="codeph">CONTAINS</code> predicate
                           </p>
                        </li>
                        <li>
                           <p>Estimate the I/O and CPU costs of using the Oracle Text index (that is, the cost of processing the <code class="codeph">CONTAINS</code> predicate by using the domain index)
                           </p>
                        </li>
                        <li>
                           <p>Estimate the I/O and CPU costs of each invocation of <code class="codeph">CONTAINS</code></p>
                        </li>
                     </ul>
                     <p>Knowing the selectivity of a <code class="codeph">CONTAINS</code> predicate is useful for queries that contain more than one predicate, such as in structured queries. This way the CBO can better decide whether to use the domain index to evaluate <code class="codeph">CONTAINS</code> or to apply the <code class="codeph">CONTAINS</code> predicate as a post filter.
                     </p>
                     <div class="infoboxnotealso" id="GUID-E4F013A8-E83C-44AF-B9A4-CA1FBF717730__GUID-58EA9CED-2938-41B3-8FC7-8F7E5D6B147F">
                        <p class="notep1">See Also:</p>
                        <p></p>
                        <ul style="list-style-type: disc;">
                           <li>
                              <p><a href="../sqlrf/ANALYZE.html#SQLRF-GUID-535CE98E-2359-4147-839F-DCB3772C1B0E" target="_blank"><span class="italic">Oracle Database SQL Language Reference</span></a> for more information about the <code class="codeph">ANALYZE</code> statement
                              </p>
                           </li>
                           <li>
                              <p><a href="../arpls/DBMS_STATS.html#ARPLS059" target="_blank"><span class="italic">Oracle Database PL/SQL Packages and Types Reference</span></a> for information about <code class="codeph">DBMS_STATS</code> package
                              </p>
                           </li>
                        </ul>
                     </div>
                  </div>
               </div><a id="CCAPP9635"></a><div class="props_rev_3"><a id="GUID-A2137127-9B0D-48EE-962F-2408F49FA244" name="GUID-A2137127-9B0D-48EE-962F-2408F49FA244"></a><h4 id="CCAPP-GUID-A2137127-9B0D-48EE-962F-2408F49FA244" class="sect4"><span class="enumeration_section">10.1.2 </span>Query Optimization with Statistics Example
                  </h4>
                  <div>
                     <p>The following structured query provides an example for optimizing statistics:</p><pre class="oac_no_warn" dir="ltr">select score(1) from tab where contains(txt, 'freedom', 1)  &gt; 0 and author = 'King' and year &gt; 1960;
</pre><p>Assume the following:</p>
                     <ul style="list-style-type: disc;">
                        <li>
                           <p>The author column is of type <code class="codeph">VARCHAR2</code> and the year column is of type <code class="codeph">NUMBER.</code> 
                           </p>
                        </li>
                        <li>
                           <p>A b-tree index on the <code class="codeph">author</code> column.
                           </p>
                        </li>
                        <li>
                           <p>The structured <code class="codeph">author</code> predicate is highly selective with respect to the <code class="codeph">CONTAINS</code> predicate and the <code class="codeph">year</code> predicate. That is, the structured predicate (author = 'King') returns a much smaller number of rows with respect to the <code class="codeph">year</code> and <code class="codeph">CONTAINS</code> predicates individually, say 5 rows returned versus 1000 and 1500 rows, respectively.
                           </p>
                        </li>
                     </ul>
                     <p>In this situation, Oracle Text can execute this query more efficiently by first scanning a b-tree index range on the structured predicate (author = 'King'), then accessing a table by rowid, and then applying the other two predicates to the rows returned from the b-tree table access.</p>
                     <div class="infoboxnote" id="GUID-A2137127-9B0D-48EE-962F-2408F49FA244__GUID-1B6F57EE-ED6A-42F9-89FD-172E7FD1BE09">
                        <p class="notep1">Note:</p>
                        <p>When statistics are not collected for a Oracle Text index, the CBO assumes low selectivity and index costs for the <code class="codeph">CONTAINS</code> predicate.
                        </p>
                     </div>
                  </div>
               </div><a id="CCAPP9636"></a><div class="props_rev_3"><a id="GUID-763C6A28-275A-4C6F-A740-5A02F9E13575" name="GUID-763C6A28-275A-4C6F-A740-5A02F9E13575"></a><h4 id="CCAPP-GUID-763C6A28-275A-4C6F-A740-5A02F9E13575" class="sect4"><span class="enumeration_section">10.1.3 </span>Re-Collecting Statistics
                  </h4>
                  <div>
                     <p>After synchronizing your index, you can re-collect statistics on a single index to update the cost estimates.</p>
                     <p>If your base table was reanalyzed before the synchronization, it is sufficient to analyze the index after the synchronization without reanalyzing the entire table.</p>
                     <p>To re-collect statistics, enter one of the following statements:</p><pre class="oac_no_warn" dir="ltr">ANALYZE INDEX &lt;index_name&gt; COMPUTE STATISTICS;
</pre><pre class="oac_no_warn" dir="ltr">ANALYZE INDEX &lt;index_name&gt; ESTIMATE STATISTICS SAMPLE 50 PERCENT;</pre></div>
               </div><a id="CCAPP9637"></a><div class="props_rev_3"><a id="GUID-225089FD-7E86-4DB0-8D37-D04213D1D053" name="GUID-225089FD-7E86-4DB0-8D37-D04213D1D053"></a><h4 id="CCAPP-GUID-225089FD-7E86-4DB0-8D37-D04213D1D053" class="sect4"><span class="enumeration_section">10.1.4 </span>Deleting Statistics
                  </h4>
                  <div>
                     <p>Delete the statistics associated with a table:</p><pre class="oac_no_warn" dir="ltr">ANALYZE TABLE &lt;table_name&gt; DELETE STATISTICS;
</pre><p>Delete statistics on one index:</p><pre class="oac_no_warn" dir="ltr">ANALYZE INDEX &lt;index_name&gt; DELETE STATISTICS;</pre></div>
               </div>
            </div><a id="CCAPP9234"></a><div class="props_rev_3"><a id="GUID-3B8371B5-F7AC-4A94-80EE-510B7820EE6D" name="GUID-3B8371B5-F7AC-4A94-80EE-510B7820EE6D"></a><h3 id="CCAPP-GUID-3B8371B5-F7AC-4A94-80EE-510B7820EE6D" class="sect3"><span class="enumeration_section">10.2 </span>Optimizing Queries for Response Time
               </h3>
               <div>
                  <p>By default, Oracle Text optimizes queries for throughput so that queries return all rows in the shortest time possible. </p>
                  <p>However, in many cases, especially in a web application, you must optimize queries for response time, because you are only interested in obtaining the first few hits of a potentially large hitlist in the shortest time possible. </p>
                  <p>The following sections describe some ways to optimize <code class="codeph">CONTAINS</code> queries for response time:
                  </p>
                  <ul style="list-style-type: disc;">
                     <li>
                        <p><a href="tuning-oracle-text.html#GUID-ED7BEE09-A89F-4094-BB2E-E02B44B9DAF5">Other Factors that Influence Query Response Time</a></p>
                     </li>
                     <li>
                        <p><a href="tuning-oracle-text.html#GUID-169F2EB1-5E78-43E2-9FFD-1D9DFE2E1AA2">Improved Response Time with FIRST_ROWS(n) Hint for ORDER BY Queries</a></p>
                     </li>
                     <li>
                        <p><a href="tuning-oracle-text.html#GUID-84B7D7B4-49EB-4F22-BAEA-A68904D8A013">Improved Response Time Using the DOMAIN_INDEX_SORT Hint</a></p>
                     </li>
                     <li>
                        <p><a href="tuning-oracle-text.html#GUID-DE0B4638-A760-47C4-8593-F68ECEBFD370">Improved Response Time using Local Partitioned CONTEXT Index</a></p>
                     </li>
                     <li>
                        <p><a href="tuning-oracle-text.html#GUID-4723908A-C5DD-401C-B71B-05C5F33DD52D">Improved Response Time with Local Partitioned Index for Order by Score</a></p>
                     </li>
                     <li>
                        <p><a href="tuning-oracle-text.html#GUID-8D490B4B-9A28-4FEA-AD73-9B91CD213542">Improved Response Time with Query Filter Cache</a></p>
                     </li>
                     <li>
                        <p><a href="tuning-oracle-text.html#GUID-9AD2AB93-2FB6-4C49-8082-046ED90F2C08">Improved Response Time using BIG_IO Option of CONTEXT Index</a></p>
                     </li>
                     <li>
                        <p><a href="tuning-oracle-text.html#GUID-8D3C30AE-D466-46C1-A281-916B7D48994C">Improved Response Time using SEPARATE_OFFSETS Option of CONTEXT Index</a></p>
                     </li>
                     <li>
                        <p><a href="tuning-oracle-text.html#GUID-54F2466B-7D05-45AC-A64E-04717F75C507">Improved Response Time Using the STAGE_ITAB, STAGE_ITAB_MAX_ROWS, and STAGE_ITAB_PARALLEL Options of CONTEXT Index</a></p>
                     </li>
                  </ul>
               </div><a id="CCAPP9235"></a><div class="props_rev_3"><a id="GUID-ED7BEE09-A89F-4094-BB2E-E02B44B9DAF5" name="GUID-ED7BEE09-A89F-4094-BB2E-E02B44B9DAF5"></a><h4 id="CCAPP-GUID-ED7BEE09-A89F-4094-BB2E-E02B44B9DAF5" class="sect4"><span class="enumeration_section">10.2.1 </span>Other Factors That Influence Query Response Time
                  </h4>
                  <div>
                     <p>The following factors can influence query response time:</p>
                     <ul style="list-style-type: disc;">
                        <li>
                           <p>Collection of table statistics</p>
                        </li>
                        <li>
                           <p>Memory allocation</p>
                        </li>
                        <li>
                           <p>Sorting</p>
                        </li>
                        <li>
                           <p>Presence of large object (LOB) columns in your base table</p>
                        </li>
                        <li>
                           <p>Partitioning</p>
                        </li>
                        <li>
                           <p>Parallelism</p>
                        </li>
                        <li>
                           <p>The number term expansions in your query</p>
                           <div class="infoboxnotealso" id="GUID-ED7BEE09-A89F-4094-BB2E-E02B44B9DAF5__GUID-C047BD97-E42F-4D4E-B5BF-1A4BB689F0F1">
                              <p class="notep1">See Also:</p>
                              <p><span class="q">"<a href="tuning-oracle-text.html#GUID-90312BBE-00D7-4200-B6AF-77CAFAA5D2F3">Frequently Asked Questions About Query Performance</a>"</span></p>
                           </div>
                        </li>
                     </ul>
                  </div>
               </div><a id="CCAPP9236"></a><div class="props_rev_3"><a id="GUID-169F2EB1-5E78-43E2-9FFD-1D9DFE2E1AA2" name="GUID-169F2EB1-5E78-43E2-9FFD-1D9DFE2E1AA2"></a><h4 id="CCAPP-GUID-169F2EB1-5E78-43E2-9FFD-1D9DFE2E1AA2" class="sect4"><span class="enumeration_section">10.2.2 </span>Improved Response Time with the FIRST_ROWS(n) Hint for ORDER BY Queries
                  </h4>
                  <div>
                     <p>When you need the first rows of an <code class="codeph">ORDER BY</code> query, Oracle recommends that you use the cost-based <code class="codeph">FIRST_ROWS(n)</code> hint.
                     </p>
                     <div class="infoboxnote" id="GUID-169F2EB1-5E78-43E2-9FFD-1D9DFE2E1AA2__GUID-739F64F7-3668-4882-B311-FEE094A854F5">
                        <p class="notep1">Note:</p>
                        <p>As the <code class="codeph">FIRST_ROWS(n)</code> hint is cost-based, Oracle recommends that you collect statistics on your tables before you use this hint. 
                        </p>
                     </div>
                     <p>You use the <code class="codeph">FIRST_ROWS(n)</code> hint in cases where you want the first <span class="italic">n</span> number of rows in the shortest possible time. For example, consider the following PL/SQL block that uses a cursor to retrieve the first 10 hits of a query and the <code class="codeph">FIRST_ROWS(n)</code> hint to optimize the response time:
                     </p><pre class="oac_no_warn" dir="ltr">declare
cursor c is 

select /*+ FIRST_ROWS(10) */ article_id from articles_tab
   where contains(article, 'Omophagia')&gt;0 order by pub_date desc;

begin</pre><pre class="oac_no_warn" dir="ltr">for i in c
loop
insert into t_s values(i.pk, i.col);
exit when c%rowcount &gt; 11;
end loop;</pre><pre class="oac_no_warn" dir="ltr">end;
/
</pre><p>The <code class="codeph">c</code> cursor is a <code class="codeph">SELECT</code> statement that returns the rowids that contain the word <span class="italic">omophagia</span> in sorted order. The code loops through the cursor to extract the first 10 rows. These rows are stored in the temporary <code class="codeph">t_s</code> table.
                     </p>
                     <p>With the <code class="codeph">FIRST_ROWS(n)</code> hint, the optimizer instructs the Oracle Text index to return rowids in score-sorted order when the cost of returning the top-N hits is lower.
                     </p>
                     <p>Without the hint, Oracle Database sorts the rowids after the Oracle Text index returns <span class="italic">all</span> rows in unsorted order that satisfy the <code class="codeph">CONTAINS</code> predicate. Retrieving the entire result set takes time.
                     </p>
                     <p>Because only the first 10 hits are needed in this query, using the hint results in better performance.</p>
                     <div class="infoboxnote" id="GUID-169F2EB1-5E78-43E2-9FFD-1D9DFE2E1AA2__GUID-3E358C4E-6E9E-4043-92F4-9C6D089D77BB">
                        <p class="notep1">Note:</p>
                        <p>Use the <code class="codeph">FIRST_ROWS(n)</code> hint when you need only the first few hits of a query. When you need the entire result set, do not use this hint as it might result in poor performance. 
                        </p>
                     </div>
                  </div>
               </div><a id="CCAPP9237"></a><div class="props_rev_3"><a id="GUID-84B7D7B4-49EB-4F22-BAEA-A68904D8A013" name="GUID-84B7D7B4-49EB-4F22-BAEA-A68904D8A013"></a><h4 id="CCAPP-GUID-84B7D7B4-49EB-4F22-BAEA-A68904D8A013" class="sect4"><span class="enumeration_section">10.2.3 </span>Improved Response Time Using the DOMAIN_INDEX_SORT Hint
                  </h4>
                  <div>
                     <p>You can also optimize for response time by using the related <code class="codeph">DOMAIN_INDEX_SORT</code> hint. Like <code class="codeph">FIRST_ROWS(n),</code> when queries are optimized for response time, Oracle Text returns the first rows in the shortest time possible.
                     </p>
                     <p>For example, you can use this hint:</p><pre class="oac_no_warn" dir="ltr">select /*+ DOMAIN_INDEX_SORT */ pk, score(1), col from ctx_tab 
            where contains(txt_col, 'test', 1) &gt; 0 order by score(1) desc;
</pre><p>However, this hint is only rule-based. This means that Oracle Text always chooses the index which satisfies the <code class="codeph">ORDER BY</code> clause. This hint might result in suboptimal performance for queries where the <code class="codeph">CONTAINS</code> clause is very selective. In these cases, Oracle recommends that you use the <code class="codeph">FIRST_ROWS(n)</code> hint, which is fully cost-based.
                     </p>
                  </div>
               </div><a id="CCAPP9238"></a><div class="props_rev_3"><a id="GUID-DE0B4638-A760-47C4-8593-F68ECEBFD370" name="GUID-DE0B4638-A760-47C4-8593-F68ECEBFD370"></a><h4 id="CCAPP-GUID-DE0B4638-A760-47C4-8593-F68ECEBFD370" class="sect4"><span class="enumeration_section">10.2.4 </span>Improved Response Time Using the Local Partitioned CONTEXT Index
                  </h4>
                  <div>
                     <p>Partitioning your data and creating local partitioned indexes can improve your query performance. On a partitioned table, each partition has its own set of index tables. Effectively, there are multiple indexes, but the results are combined as necessary to produce the final result set. </p>
                     <p>Create the <code class="codeph">CONTEXT</code> index with the <code class="codeph">LOCAL</code> keyword: 
                     </p><pre class="oac_no_warn" dir="ltr">CREATE INDEX index_name ON table_name (column_name) 
INDEXTYPE IS ctxsys.context
PARAMETERS ('...')
LOCAL
</pre><p>With partitioned tables and indexes, you can improve performance of the following types of queries:</p>
                     <ul style="list-style-type: disc;">
                        <li>
                           <p><span class="bold">Range Search on Partition Key Column:</span> This query restricts the search to a particular range of values on a column that is also the partition key. For example, consider a query on a date range:
                           </p><pre class="oac_no_warn" dir="ltr">SELECT storyid FROM storytab WHERE CONTAINS(story, 'oliver')&gt;0 and pub_date BETWEEN '1-OCT-93' AND '1-NOV-93';</pre><p>If the date range is quite restrictive, it is very likely that the query can be satisfied by only looking in a single partition.</p>
                        </li>
                        <li>
                           <p><span class="bold">ORDER BY Partition Key Column:</span> This query requires only the first <code class="codeph">n</code> hits, and the <code class="codeph">ORDER BY</code> clause names the partition key. Consider an <code class="codeph">ORDER BY</code> query on a <code class="codeph">price</code> column to fetch the first 20 hits:
                           </p><pre class="oac_no_warn" dir="ltr">SELECT * FROM (</pre><pre class="oac_no_warn" dir="ltr">SELECT itemid FROM item_tab WHERE CONTAINS(item_desc, 'cd player')
  &gt;0 ORDER BY price)
  WHERE ROWNUM &lt; 20;</pre><p>In this example, with the table partitioned by price, the query might only need to get hits from the first partition to satisfy the query. </p>
                        </li>
                     </ul>
                  </div>
               </div><a id="CCAPP9241"></a><div class="props_rev_3"><a id="GUID-4723908A-C5DD-401C-B71B-05C5F33DD52D" name="GUID-4723908A-C5DD-401C-B71B-05C5F33DD52D"></a><h4 id="CCAPP-GUID-4723908A-C5DD-401C-B71B-05C5F33DD52D" class="sect4"><span class="enumeration_section">10.2.5 </span>Improved Response Time with the Local Partitioned Index for Order by Score
                  </h4>
                  <div>
                     <p>The <code class="codeph">DOMAIN_INDEX_SORT</code> hint on a local partitioned index might result in poor performance, especially when you order by score. All hits to the query across all partitions must be obtained before the results can be sorted.
                     </p>
                     <p>Instead, use an inline view when you use the <code class="codeph">DOMAIN_INDEX_SORT</code> hint. Specifically, use the <code class="codeph">DOMAIN_INDEX_SORT</code> hint to improve query performance on a local partitioned index under the following conditions:
                     </p>
                     <ul style="list-style-type: disc;">
                        <li>
                           <p>The Oracle Text query itself, including the order by <code class="codeph">SCORE</code>() clause, is expressed as an in-line view. 
                           </p>
                        </li>
                        <li>
                           <p>The Oracle Text query inside the in-line view contains the <code class="codeph">DOMAIN_INDEX_SORT</code> hint. 
                           </p>
                        </li>
                        <li>
                           <p>The query on the in-line view has a <code class="codeph">ROWNUM</code> predicate that limits the number of rows to fetch from the view. 
                           </p>
                        </li>
                     </ul>
                     <p>For example, the following Oracle Text query and local Oracle Text index are created on a partitioned <code class="codeph">doc_tab</code> table: 
                     </p><pre class="oac_no_warn" dir="ltr">     select doc_id, score(1) from doc_tab 
        where contains(doc, 'oracle', 1)&gt;0 
        order by score(1) desc;
</pre><p>If you are interested in fetching only the top 20 rows, you can rewrite the query as follows:</p><pre class="oac_no_warn" dir="ltr">     select * from 
          (select /*+ DOMAIN_INDEX_SORT */ doc_id, score(1) from doc_tab 
              where contains(doc, 'oracle', 1)&gt;0 order by score(1) desc) 
      where rownum &lt; 21;</pre><div class="infoboxnotealso" id="GUID-4723908A-C5DD-401C-B71B-05C5F33DD52D__GUID-AA5F204B-8CE7-43D3-9DD9-EB184DF03B3B">
                        <p class="notep1">See Also:</p>
                        <p><a href="../sqlrf/EXPLAIN-PLAN.html#SQLRF-GUID-FD540872-4ED3-4936-96A2-362539931BA0" target="_blank"><span class="italic">Oracle Database SQL Language Reference</span></a> for more information about the <code class="codeph">EXPLAIN PLAN</code> statement
                        </p>
                     </div>
                  </div>
               </div><a id="CCAPP9551"></a><div class="props_rev_3"><a id="GUID-8D490B4B-9A28-4FEA-AD73-9B91CD213542" name="GUID-8D490B4B-9A28-4FEA-AD73-9B91CD213542"></a><h4 id="CCAPP-GUID-8D490B4B-9A28-4FEA-AD73-9B91CD213542" class="sect4"><span class="enumeration_section">10.2.6 </span>Improved Response Time with the Query Filter Cache
                  </h4>
                  <div>
                     <p>Oracle Text provides a cache layer called the query filter cache that you can use to cache the query results. The query filter cache is sharable across queries. Multiple queries can reuse cached query results to improve the query response time.</p>
                     <p>Use the <a id="d24571e1395" class="indexterm-anchor"></a><code class="codeph">ctxfiltercache</code> operator to specify which query results to cache. The following example uses the operator to store the results of the <code class="codeph">common_predicate</code> query in the cache:
                     </p><pre class="oac_no_warn" dir="ltr">select * from docs where contains(txt, 'ctxfiltercache((common_predicate), FALSE)')&gt;0;</pre><p>In this example, the cached results of the <code class="codeph">common_predicate</code> query are reused by the <code class="codeph">new_query</code> query, to improve the query response time.
                     </p><pre class="oac_no_warn" dir="ltr">select * from docs where contains(txt, 'new_query &amp; ctxfiltercache((common_predicate), FALSE)')&gt;0; 
</pre><div class="infoboxnote" id="GUID-8D490B4B-9A28-4FEA-AD73-9B91CD213542__GUID-4A36AC7B-6A33-411A-80A2-4B368A6AB791">
                        <p class="notep1">Note:</p>
                        <p></p>
                        <ul style="list-style-type: disc;">
                           <li>
                              <p>You can specify the size of the query filter cache by using the basic <a id="d24571e1421" class="indexterm-anchor"></a><code class="codeph">query_filter_cache_size</code> storage attribute.
                              </p>
                           </li>
                           <li>
                              <p>The <a id="d24571e1429" class="indexterm-anchor"></a><code class="codeph">ctx_filter_cache_statistics</code> view provides various statistics about the query filter cache.
                              </p>
                           </li>
                        </ul>
                     </div>
                     <div class="infoboxnotealso" id="GUID-8D490B4B-9A28-4FEA-AD73-9B91CD213542__GUID-799CFE6F-3E8A-499D-B86A-DBF9E50A3145">
                        <p class="notep1">See Also:</p>
                        <p><a href="../ccref/oracle-text-indexing-elements.html#CCREF0245" target="_blank"><span class="italic">Oracle Text Reference</span></a> for more information about:
                        </p>
                        <ul style="list-style-type: disc;">
                           <li>
                              <p><code class="codeph">ctxfiltercache</code> operator
                              </p>
                           </li>
                           <li>
                              <p><code class="codeph">query_filter_cache_size</code> basic storage attribute
                              </p>
                           </li>
                           <li>
                              <p><code class="codeph">ctx_filter_cache_statistics</code> view
                              </p>
                           </li>
                        </ul>
                     </div>
                  </div>
               </div><a id="CCAPP9552"></a><div class="props_rev_3"><a id="GUID-9AD2AB93-2FB6-4C49-8082-046ED90F2C08" name="GUID-9AD2AB93-2FB6-4C49-8082-046ED90F2C08"></a><h4 id="CCAPP-GUID-9AD2AB93-2FB6-4C49-8082-046ED90F2C08" class="sect4"><span class="enumeration_section">10.2.7 </span>Improved Response Time Using the BIG_IO Option of CONTEXT Index
                  </h4>
                  <div>
                     <p>Oracle Text provides the <a id="d24571e1521" class="indexterm-anchor"></a><code class="codeph">BIG_IO</code> option for improving the query performance for the <code class="codeph">CONTEXT</code> indexes that extensively use IO operations. The query performance improvement is mainly for data stored on rotating disks, not for data stored on solid state disks.
                     </p>
                     <p>When you enable the <code class="codeph">BIG_IO</code> option, a <code class="codeph">CONTEXT</code> index creates token type pairs with one large object (LOB) data type for each unique token text. Tokens with the same text but different token types correspond to different rows in the <code class="codeph">$I</code> table. 
                     </p>
                     <p>The indexes with the <code class="codeph">BIG_IO</code> option enabled should have the token LOBs created as SecureFile LOBs, so that the data is stored sequentially in multiple blocks. This method improves the response time of the queries, because the queries can now perform longer sequential reads instead of many short reads.
                     </p>
                     <div class="infoboxnote" id="GUID-9AD2AB93-2FB6-4C49-8082-046ED90F2C08__GUID-7367A842-89FE-406B-8C89-5BF5553CCE01">
                        <p class="notep1">Note:</p>
                        <p>If you use SecureFiles, you must set the <code class="codeph">COMPATIBLE</code> setting to 11.0 or higher. In addition, you must create the LOB on an automatic segment space management (ASSM) tablespace. When you migrate the existing Oracle Text indexes to SecureFiles, use an ASSM tablespace. To help migrate the existing indexes to SecureFiles, you can extend <code class="codeph">ALTER INDEX REBUILD</code> to provide storage preferences that only affect the $I table.
                        </p>
                     </div>
                     <p>To create a <code class="codeph">CONTEXT</code> index with the <code class="codeph">BIG_IO</code> index option, first create a basic storage preference by setting the value of its <code class="codeph">BIG_IO</code> storage attribute to <code class="codeph">YES,</code> and then specify this storage preference while creating the <code class="codeph">CONTEXT</code> index.
                     </p>
                     <p>The following example creates a basic <code class="codeph">mystore</code> storage preference and sets the value of its <code class="codeph">BIG_IO</code> storage attribute to <code class="codeph">YES:</code></p><pre class="oac_no_warn" dir="ltr">exec ctx_ddl.create_preference('mystore', 'BASIC_STORAGE');
exec ctx_ddl.set_attribute('mystore', 'BIG_IO', 'YES');</pre><p>To disable the <code class="codeph">BIG_IO</code> option, update the existing storage preference (<code class="codeph">mystore</code>) by setting the value of its <code class="codeph">BIG_IO</code> storage attribute to <code class="codeph">NO,</code> and then rebuild the index.
                     </p><pre class="oac_no_warn" dir="ltr">exec ctx_ddl.set_attribute('mystore', 'BIG_IO', 'NO');
alter index idx rebuild('replace storage mystore');</pre><div class="infoboxnotewarn" id="GUID-9AD2AB93-2FB6-4C49-8082-046ED90F2C08__GUID-3601FAF1-231E-443D-86B0-1A2FBA23C585">
                        <p class="notep1">WARNING:</p>
                        <p>Do not use the replace metadata operation to disable the <code class="codeph">BIG_IO</code> index option. It can leave the index in an inconsistent state.
                        </p>
                     </div>
                     <p>To enable the <code class="codeph">BIG_IO</code> option for a partitioned index without rebuilding the index, modify the basic storage preference by setting the value of its <code class="codeph">BIG_IO</code> storage attribute to <code class="codeph">YES,</code> replace the global index metadata using <code class="codeph">ctx_ddl.replace_index_metadata,</code> and then call <code class="codeph">optimize_index</code> in <code class="codeph">REBUILD</code> mode for each partition of the partitioned index table.
                     </p>
                     <p>The following example enables the <code class="codeph">BIG_IO</code> option for the <code class="codeph">idx</code> partitioned index:
                     </p><pre class="oac_no_warn" dir="ltr">exec ctx_ddl.set_attribute('mystore', 'BIG_IO', 'YES');
exec ctx_ddl.replace_index_metadata('idx', 'replace storage mystore');
exec ctx_ddl.optimize_index('idx', 'rebuild', part_name=&gt;'part1');</pre><div class="infoboxnote" id="GUID-9AD2AB93-2FB6-4C49-8082-046ED90F2C08__GUID-D93129AE-B590-419D-8725-EBC75474D978">
                        <p class="notep1">Note:</p>
                        <p>If a procedure modifies the existing index tables with only the <code class="codeph">BIG_IO</code> option enabled, then it will not result in reindexing of the data.
                        </p>
                     </div>
                     <div class="infoboxnote" id="GUID-9AD2AB93-2FB6-4C49-8082-046ED90F2C08__GUID-87E28EC3-6C71-4BD2-B6DF-2D2A88CBEB45">
                        <p class="notep1">Note:</p>
                        <p>Because the <code class="codeph">BIG_IO</code> index option performs longer sequential reads, the queries that use the <code class="codeph">BIG_IO</code> index option require a large program global area (PGA) memory.
                        </p>
                     </div>
                  </div>
               </div><a id="CCAPP9553"></a><div class="props_rev_3"><a id="GUID-8D3C30AE-D466-46C1-A281-916B7D48994C" name="GUID-8D3C30AE-D466-46C1-A281-916B7D48994C"></a><h4 id="CCAPP-GUID-8D3C30AE-D466-46C1-A281-916B7D48994C" class="sect4"><span class="enumeration_section">10.2.8 </span>Improved Response Time Using the SEPARATE_OFFSETS Option of the CONTEXT Index
                  </h4>
                  <div>
                     <p>Oracle Text provides the <a id="d24571e1716" class="indexterm-anchor"></a><code class="codeph">SEPARATE_OFFSETS</code> option to improve the query performance for the <code class="codeph">CONTEXT</code> indexes that use IO operations, and whose queries are mainly single-word or Boolean queries.
                     </p>
                     <p>The <code class="codeph">SEPARATE_OFFSETS</code> option creates a different postings list structure for the tokens of type <code class="codeph">TEXT.</code> Instead of interspersing docids, frequencies, info-length (length of the offsets information), and the offsets in the postings list, the <code class="codeph">SEPARATE_OFFSETS</code> option stores all docids and frequencies at the beginning of the postings list, and all info-lengths and offsets at the end of the postings list. The header at the beginning of the posting contains the information about the boundary points between docids and offsets. Because separation of docids and offsets reduces the time for the queries to read the data, it improves the query response time.
                     </p>
                     <p>Performance of the <code class="codeph">SEPARATE_OFFSETS</code> option is best realized when you use it in conjunction with the <code class="codeph">BIG_IO</code> option and for tokens with a very long posting.
                     </p>
                     <p>To create a <code class="codeph">CONTEXT</code> index with the <code class="codeph">SEPARATE_OFFSETS</code> option, first create a basic storage preference by setting the value of its <code class="codeph">SEPARATE_OFFSETS</code> storage attribute to <code class="codeph">T.</code> Next, specify this storage preference when you create the <code class="codeph">CONTEXT</code> index.
                     </p>
                     <p>The following example creates a basic <code class="codeph">mystore</code> storage preference and sets the value of its <code class="codeph">SEPARATE_OFFSETS</code> storage attribute to <code class="codeph">T:</code></p><pre class="oac_no_warn" dir="ltr">exec ctx_ddl.create_preference('mystore', 'BASIC_STORAGE');
exec ctx_ddl.set_attribute('mystore', 'SEPARATE_OFFSETS', 'T');</pre><p>To disable the <code class="codeph">SEPARATE_OFFSETS</code> option, update the existing storage preference (<code class="codeph">mystore</code>) by setting the value of its <code class="codeph">SEPARATE_OFFSETS</code> storage attribute to <code class="codeph">F,</code> and then rebuild the index.
                     </p><pre class="oac_no_warn" dir="ltr">exec ctx_ddl.set_attribute('mystore', 'SEPARATE_OFFSETS', 'F');
alter index idx rebuild('replace storage mystore');</pre><div class="infoboxnotewarn" id="GUID-8D3C30AE-D466-46C1-A281-916B7D48994C__GUID-A8158A06-5648-4AD9-BEA0-2321746BD819">
                        <p class="notep1">WARNING:</p>
                        <p>Do not use replace metadata operation to disable the <code class="codeph">SEPARATE_OFFSETS</code> index option, as it can leave the index in an inconsistent state.
                        </p>
                     </div>
                     <p>To enable the <code class="codeph">SEPARATE_OFFSETS</code> option for a partitioned index without rebuilding the index, modify the basic storage preference by setting the value of its <code class="codeph">SEPARATE_OFFSETS</code> storage attribute to <code class="codeph">T,</code> replace the global index metadata by using <code class="codeph">ctx_ddl.replace_index_metadata,</code> and then call <code class="codeph">optimize_index</code> in REBUILD mode for each partition in the partitioned index table.
                     </p>
                     <p>The following example enables the <code class="codeph">SEPARATE_OFFSETS</code> option for the partitioned <code class="codeph">idx</code> index:
                     </p><pre class="oac_no_warn" dir="ltr">exec ctx_ddl.set_attribute('mystore', 'SEPARATE_OFFSETS', 'T');
exec ctx_ddl.replace_index_metadata('idx', 'replace storage mystore');
exec ctx_ddl.optimize_index('idx', 'rebuild', part_name=&gt;'part1');</pre><div class="infoboxnote" id="GUID-8D3C30AE-D466-46C1-A281-916B7D48994C__GUID-A378A48E-AC57-4955-89BE-3CE72B574A28">
                        <p class="notep1">Note:</p>
                        <p>If a procedure modifies the existing index tables with only the <code class="codeph">SEPARATE_OFFSETS</code> option enabled, then the data is not reindexed.
                        </p>
                     </div>
                  </div>
               </div><a id="CCAPP9554"></a><div class="props_rev_3"><a id="GUID-54F2466B-7D05-45AC-A64E-04717F75C507" name="GUID-54F2466B-7D05-45AC-A64E-04717F75C507"></a><h4 id="CCAPP-GUID-54F2466B-7D05-45AC-A64E-04717F75C507" class="sect4"><span class="enumeration_section">10.2.9 </span>Improved Response Time Using the STAGE_ITAB, STAGE_ITAB_MAX_ROWS, and STAGE_ITAB_PARALLEL Options of CONTEXT Index
                  </h4>
                  <div>
                     <p>Oracle Text provides the <a id="d24571e1893" class="indexterm-anchor"></a><code class="codeph">STAGE_ITAB</code> option for improving the query performance for the <code class="codeph">CONTEXT</code> indexes that extensively use insert, update, and delete operations for near real-time indexing.
                     </p>
                     <p>If you do not use the <code class="codeph">STAGE_ITAB</code> index option, then when you add a new document to the <code class="codeph">CONTEXT</code> index, <code class="codeph">SYNC_INDEX</code> is called to make the documents searchable. This call creates new rows in the <code class="codeph">$I</code> table, and increases the fragmentation in the <code class="codeph">$I</code> table. The result is deterioration of the query performance.
                     </p>
                     <p>When you enable the <code class="codeph">STAGE_ITAB</code> index option, the following happens:
                     </p>
                     <ul style="list-style-type: disc;">
                        <li>
                           <p>Information about the new documents is stored in the <code class="codeph">$G</code> staging table, not in the <code class="codeph">$I</code> table. This storage ensures that the <code class="codeph">$I</code> table is not fragmented and does not deteriorate the query performance.
                           </p>
                        </li>
                        <li>
                           <p>The <code class="codeph">$H</code> b-tree index is created on the <code class="codeph">$G</code> table. The <code class="codeph">$G</code> table and <code class="codeph">$H</code> b-tree index are equivalent to the <code class="codeph">$I</code> table and <code class="codeph">$X</code> b-tree index.
                           </p>
                        </li>
                     </ul>
                     <p>Use the <code class="codeph">MERGE</code> optimization mode to optimize the rows in the <code class="codeph">$G</code> table and move them to the <code class="codeph">$I</code> table.
                     </p>
                     <div class="infoboxnote" id="GUID-54F2466B-7D05-45AC-A64E-04717F75C507__GUID-A43D5EC1-197B-483D-92D8-1F39FECCAEE9">
                        <p class="notep1">Note:</p>
                        <p>The <code class="codeph">$G</code> table is stored in the <code class="codeph">KEEP</code> pool. To improve query performance, you should allocate sufficient <code class="codeph">KEEP</code> pool memory and maintain a large enough <code class="codeph">$G</code> table size by using the new <code class="codeph">stage_itab_max_rows</code> option.
                        </p>
                     </div>
                     <p>To create a <code class="codeph">CONTEXT</code> index with the <code class="codeph">STAGE_ITAB</code> index option, first create a basic storage preference by setting the value of its <code class="codeph">STAGE_ITAB</code> storage attribute to <code class="codeph">YES.</code> Next, specify this storage preference when you create the <code class="codeph">CONTEXT</code> index.
                     </p>
                     <p>The following example creates a basic <code class="codeph">mystore</code> storage preference and sets the value of its <code class="codeph">STAGE_ITAB</code> storage attribute to <code class="codeph">YES:</code></p><pre class="oac_no_warn" dir="ltr">exec ctx_ddl.create_preference('mystore', 'BASIC_STORAGE');
exec ctx_ddl.set_attribute('mystore', 'STAGE_ITAB', 'YES');</pre><p>You can also enable the <code class="codeph">STAGE_ITAB</code> index option for an existing nonpartitioned <code class="codeph">CONTEXT</code> index by using the rebuild option of the <code class="codeph">ALTER INDEX</code> statement.
                     </p><pre class="oac_no_warn" dir="ltr">alter index IDX rebuild parameters('replace storage mystore');</pre><p>To disable the <code class="codeph">STAGE_ITAB</code> option for a nonpartitioned <code class="codeph">CONTEXT</code> index, update the existing storage preference (<code class="codeph">mystore</code>) by setting the value of its <code class="codeph">STAGE_ITAB</code> storage attribute to <code class="codeph">NO,</code> and then rebuild the index.
                     </p><pre class="oac_no_warn" dir="ltr">exec ctx_ddl.set_attribute('mystore', 'STAGE_ITAB', 'NO');
alter index idx rebuild('replace storage mystore');</pre><p>This operation runs the optimization process by using the <code class="codeph">MERGE</code> optimization mode and then drops the <code class="codeph">$G</code> table.
                     </p>
                     <p>The rebuild option of the <code class="codeph">ALTER INDEX</code> statement does not work with the partitioned <code class="codeph">CONTEXT</code> index for enabling and disabling the <code class="codeph">STAGE_ITAB</code> option. 
                     </p>
                     <p>The following example enables the <code class="codeph">STAGE_ITAB</code> option for the partitioned <code class="codeph">CONTEXT</code> <code class="codeph">idx</code> index:
                     </p><pre class="oac_no_warn" dir="ltr">alter index idx parameters('add stage_itab');</pre><p>The following example disables the <code class="codeph">STAGE_ITAB</code> option for the partitioned <code class="codeph">CONTEXT</code> <code class="codeph">idx</code> index:
                     </p><pre class="oac_no_warn" dir="ltr">alter index idx parameters('remove stage_itab');</pre><p>Starting with Oracle Database 12<span class="italic">c</span> Release 2 (12.2), the contents of <code class="codeph">$G</code> are automatically moved to <code class="codeph">$I</code> during index synchronization when <code class="codeph">$G</code> has more than 1 million rows. This value is controlled by the <code class="codeph">STAGE_ITAB_MAX_ROWS</code> attribute of the <code class="codeph">STORAGE</code> preference.
                     </p>
                     <div class="infoboxnote" id="GUID-54F2466B-7D05-45AC-A64E-04717F75C507__GUID-9EDDF5DD-8229-4CB2-9AD8-989E1373FFC7">
                        <p class="notep1">Note:</p>
                        <p>If an occasional index synchronization takes a long time, you can either reduce the value of the <code class="codeph">STAGE_ITAB_MAX_ROWS</code> parameter or increase the degree of parallelism by using the <code class="codeph">STAGE_ITAB_PARALLEL</code> attribute of the <code class="codeph">STORAGE</code> preference. If you set the value of <code class="codeph">STAGE_ITAB_MAX_ROWS</code> to a very small value, then the contents of <code class="codeph">$G</code> are moved to <code class="codeph">$I</code> frequently. So, do not be set it to a very low value.
                        </p>
                     </div>
                     <div class="infoboxnote" id="GUID-54F2466B-7D05-45AC-A64E-04717F75C507__GUID-B7A48630-33B2-4C24-A338-7CBF6A4C937D">
                        <p class="notep1">Note:</p>
                        <p>To use the <code class="codeph">STAGE_ITAB</code> index option for a <code class="codeph">CONTEXT</code> index, you must specify the <code class="codeph">g_index_clause</code> and <code class="codeph">g_table_clause</code> <code class="codeph">BASIC_STORAGE</code> preferences.
                        </p>
                     </div>
                     <p>The query performance is deteriorated when <code class="codeph">$G</code> table is too fragmented. To avoid deterioration, starting with Oracle Database Release 18c, Oracle Text provides automatic background optimize merge for every index or partition. To enable automatic background optimize merge, you must set the <code class="codeph">STAGE_ITAB</code> and <code class="codeph">STAGE_ITAB_AUTO_OPT</code> storage preference attributes to <code class="codeph">TRUE,</code> and you must create the index with a storage preference.
                     </p>
                     <p>By default, if you had enabled <code class="codeph">STAGE_ITAB</code> in indexes before you upgraded to Oracle Database Release 18c, then <code class="codeph">STAGE_ITAB_AUTO_OPT</code> is not enabled. If <code class="codeph">STAGE_ITAB</code> and <code class="codeph">AUTO_OPTIMIZE</code> are enabled in existing indexes, then you must disable <code class="codeph">AUTO_OPTIMIZE</code> before you enable <code class="codeph">STAGE_ITAB_AUTO_OPT.</code></p>
                     <p>The following example creates a basic <code class="codeph">mystore</code> storage preference and sets the value of its <code class="codeph">STAGE_ITAB_AUTO_OPT</code> storage attribute to <code class="codeph">TRUE:</code></p><pre class="pre codeblock"><code>exec ctx_ddl.create_preference('mystore', 'basic_storage');
exec ctx_ddl.set_attribute('mystore', 'stage_itab', 'TRUE');
exec ctx_ddl.set_attribute('mystore', 'stage_itab_auto_opt', 'TRUE');
exec ctx_ddl.set_attribute(mystore, 'stage_itab_parallel', 16);</code></pre><div class="infoboxnotealso" id="GUID-54F2466B-7D05-45AC-A64E-04717F75C507__GUID-96B52DC7-B82F-4977-8C3E-01DDFCD7DF62">
                        <p class="notep1">See Also:</p>
                        <p><a href="../ccref/CTX_OUTPUT-package.html#CCREF0800" target="_blank"><span class="italic">Oracle Text Reference</span></a> for more information about <code class="codeph">BASIC_STORAGE</code></p>
                     </div>
                  </div>
               </div>
            </div><a id="CCAPP9242"></a><div class="props_rev_3"><a id="GUID-21432876-BCE4-4250-A67F-C6E76017B872" name="GUID-21432876-BCE4-4250-A67F-C6E76017B872"></a><h3 id="CCAPP-GUID-21432876-BCE4-4250-A67F-C6E76017B872" class="sect3"><span class="enumeration_section">10.3 </span>Optimizing Queries for Throughput
               </h3>
               <div>
                  <p>When you optimize a query for throughput, the default behavior returns all hits in the shortest time possible.</p>
                  <p>Here is how you can explicitly optimize queries for throughput:</p>
                  <ul style="list-style-type: disc;">
                     <li>
                        <p><span class="bold">CHOOSE and ALL ROWS Modes:</span> By default, you optimize queries with the <code class="codeph">CHOOSE</code> and <code class="codeph">ALL_ROWS</code> modes. Oracle Text returns <span class="italic">all</span> rows in the shortest time possible.
                        </p>
                     </li>
                     <li>
                        <p><span class="bold">FIRST_ROWS(n) Mode:</span> In <code class="codeph">FIRST_ROWS(n)</code> mode, the optimizer in Oracle Database optimizes for fast response time by having the Text domain index return score-sorted rows, if possible. This is the default behavior when you use the <code class="codeph">FIRST_ROWS(n)</code> hint.
                        </p>
                        <p>If you want to optimize throughput with <code class="codeph">FIRST_ROWS(n),</code> then use the <code class="codeph">DOMAIN_INDEX_NO_SORT</code> hint. Better throughput means that you are interested in getting all query rows in the shortest time possible.
                        </p>
                        <p>The following example achieves better throughput by not using the Text domain index to return score-sorted rows. Instead, Oracle Text sorts the rows after all rows that satisfy the <code class="codeph">CONTAINS</code> predicate are retrieved from the index: 
                        </p><pre class="oac_no_warn" dir="ltr">select /*+ FIRST_ROWS(10) DOMAIN_INDEX_NO_SORT */ pk, score(1), col from ctx_tab 
            where contains(txt_col, 'test', 1) &gt; 0 order by score(1) desc;</pre></li>
                  </ul>
                  <div class="infoboxnotealso" id="GUID-21432876-BCE4-4250-A67F-C6E76017B872__GUID-FDE8A34B-1CA3-4CBF-8D97-C23EB4327E50">
                     <p class="notep1">See Also:</p>
                     <p> <a href="../tgsql/query-optimizer-concepts.html#TGSQL-GUID-06129ACE-36B2-4534-AE68-EDFCAEBB3B5D" target="_blank"><span class="italic">Oracle Database SQL Tuning Guide</span></a> for more information about the query optimizer and using hints such as <code class="codeph">FIRST_ROWS(n)</code> and <code class="codeph">CHOOSE</code></p>
                  </div>
               </div>
            </div><a id="CCAPP9245"></a><div class="props_rev_3"><a id="GUID-0A82CB4D-A252-4838-ACA1-8EF10FCD9A29" name="GUID-0A82CB4D-A252-4838-ACA1-8EF10FCD9A29"></a><h3 id="CCAPP-GUID-0A82CB4D-A252-4838-ACA1-8EF10FCD9A29" class="sect3"><span class="enumeration_section">10.4 </span>Composite Domain Index in Oracle Text
               </h3>
               <div>
                  <p>The Composite Domain Index (CDI) feature of the Extensibility Framework in Oracle Database enables structured columns to be indexed by Oracle Text. Therefore, both text and one or more structured criteria can be satisfied by one single Oracle Text index row source. Performance for the following types of queries is improved:</p>
                  <ul style="list-style-type: disc;">
                     <li>
                        <p>Oracle Text query with structured criteria in the SQL <code class="codeph">WHERE</code> clause
                        </p>
                     </li>
                     <li>
                        <p>Oracle Text query with structured <code class="codeph">ORDER</code> <code class="codeph">BY</code> criteria
                        </p>
                     </li>
                     <li>
                        <p>A combination of the previous two query types</p>
                     </li>
                  </ul>
                  <p>As with concatenated b-tree indexes or bitmap indexes, applications experience a slowdown in data manipulation language (DML) performance as the number of <code class="codeph">FILTER</code> <code class="codeph">BY</code> and <code class="codeph">ORDER</code> <code class="codeph">BY</code> columns increases. Where <code class="codeph">SCORE</code>-sort pushdown is optimized for response time, the structured sort or combination of <code class="codeph">SCORE</code> and structured sort pushdown is also optimized for response time, but not for throughput. However, using <code class="codeph">DOMAIN_INDEX_SORT</code> or <code class="codeph">FIRST_ROWS</code><code class="codeph">(n)</code> hints to force the sort to be pushed into the CDI while fetching the entire hitlist may result in poor query response time.
                  </p>
               </div>
            </div><a id="CCAPP9513"></a><a id="CCAPP9246"></a><div class="props_rev_3"><a id="GUID-F315BDEC-F569-4A1C-939F-99B3B64726FA" name="GUID-F315BDEC-F569-4A1C-939F-99B3B64726FA"></a><h3 id="CCAPP-GUID-F315BDEC-F569-4A1C-939F-99B3B64726FA" class="sect3"><span class="enumeration_section">10.5 </span>Performance Tuning with CDI
               </h3>
               <div>
                  <p>Because you can map a <code class="codeph">FILTER BY</code> column to <code class="codeph">MDATA,</code> you can optimize query performances for equality searches by restricting the supported functionality of <code class="codeph">RANGE</code> and <code class="codeph">LIKE.</code> However, Oracle does not recommend mapping a <code class="codeph">FILTER</code> <code class="codeph">BY</code> column to <code class="codeph">MDATA</code> if the <code class="codeph">FILTER</code> <code class="codeph">BY</code> column contains sequential values or has very high cardinality. Doing so can result in a very long and narrow <code class="codeph">$I</code> table and reduced <code class="codeph">$X</code> performance. One example of such a sequential column might be one that uses the <code class="codeph">DATE</code> stamp. For such sequential columns, mapping to <code class="codeph">SDATA</code> is recommended.
                  </p>
                  <p>Use the following hints to push or not push the <code class="codeph">SORT</code> and <code class="codeph">FILTER</code> <code class="codeph">BY</code> predicates into the CDI:
                  </p>
                  <ul style="list-style-type: disc;">
                     <li>
                        <p><code class="codeph">DOMAIN_INDEX_SORT:</code> The query optimizer tries to push the applicable sorting criteria into the specified CDI.
                        </p>
                     </li>
                     <li>
                        <p><code class="codeph">DOMAIN_INDEX_NO_SORT:</code> The query optimizer tries <span class="bold">not</span> to push sorting criteria into the specified CDI.
                        </p>
                     </li>
                     <li>
                        <p><code class="codeph">DOMAIN_INDEX_FILTER</code>(<span class="italic">table name</span> <span class="italic">index name</span>): The query optimizer tries to push the applicable <code class="codeph">FILTER</code> <code class="codeph">BY</code> predicates into the specified CDI.
                        </p>
                     </li>
                     <li>
                        <p><code class="codeph">DOMAIN_INDEX_NO_FILTER</code>(<span class="italic">table name</span> <span class="italic">index name</span>): The query optimizer does not try to push the applicable <code class="codeph">FILTER</code> <code class="codeph">BY</code> predicate(s) into the specified CDI.
                        </p>
                     </li>
                  </ul>
                  <div class="infoboxnote" id="GUID-F315BDEC-F569-4A1C-939F-99B3B64726FA__GUID-A07D0C51-E53C-4FE5-842A-EFDC900126AD">
                     <p class="notep1">Note:</p>
                     <p>The <code class="codeph">domain_index_filter</code> hint does not force the query optimizer to use CDI. Instead, if the CBO chooses to use the CDI, then it should also push the filter predicate into the index. To force the query optimizer to choose the CDI index, you additionally need to use the <code class="codeph">INDEX</code> hint.
                     </p>
                  </div>
                  <div class="example" id="GUID-F315BDEC-F569-4A1C-939F-99B3B64726FA__GUID-C727C451-D842-423D-83BD-7F17AB4C3295">
                     <p class="titleinexample">Example 10-1 Performance Tuning an Oracle Text Query with CDI Hints</p>
                     <p>The following example performs an optimized query on the <code class="codeph">books</code> table.
                     </p><pre class="oac_no_warn" dir="ltr">SELECT bookid, pub_date, source FROM
  (SELECT /*+ domain_index_sort domain_index_filter(books books_ctxcdi) */ bookid, pub_date, source
      FROM books
      WHERE CONTAINS(text, 'aaa',1)&gt;0 AND bookid &gt;= 80
      ORDER BY PUB_DATE desc nulls last, SOURCE asc  nulls last, score(1) desc)
 WHERE rownum &lt; 20;</pre></div>
                  <!-- class="example" -->
               </div>
            </div><a id="CCAPP9247"></a><div class="props_rev_3"><a id="GUID-E282E4C7-6F64-46AB-909D-1E2F07A563CF" name="GUID-E282E4C7-6F64-46AB-909D-1E2F07A563CF"></a><h3 id="CCAPP-GUID-E282E4C7-6F64-46AB-909D-1E2F07A563CF" class="sect3"><span class="enumeration_section">10.6 </span>Solving Index and Query Bottlenecks by Using Tracing
               </h3>
               <div>
                  <p>Oracle Text includes a <span class="italic">tracing</span> feature that enables you to identify bottlenecks in indexing and querying.
                  </p>
                  <p>Oracle Text provides a set of predefined <span class="italic">traces.</span> Each trace is identified by a unique number. <code class="codeph">CTX_OUTPUT</code> includes a symbol for this number.
                  </p>
                  <p>Each trace measures a specific numeric quantity, such as the number of <code class="codeph">$I</code> rows selected during text queries. 
                  </p>
                  <p>Traces are cumulative counters, so usage is as follows:</p>
                  <ol>
                     <li>
                        <p>The user enables a trace.</p>
                     </li>
                     <li>
                        <p>The user performs one or more operations. Oracle Text measures activities and accumulates the results in the trace.</p>
                     </li>
                     <li>
                        <p>The user retrieves the trace value, which is the total value across all operations done in step 2.</p>
                     </li>
                     <li>
                        <p>The user resets the trace to 0.</p>
                     </li>
                     <li>
                        <p>The user starts over at Step 2.</p>
                     </li>
                  </ol>
                  <p>So, for instance, if in step 2 the user runs two queries, and query 1 selects 15 rows from <code class="codeph">$I,</code> and query 2 selects 17 rows from <code class="codeph">$I,</code> then in step 3 the value of the trace is 32 (15 + 17).
                  </p>
                  <p>Traces are associated with a sessionthey can measure operations that take place within a single session, and, conversely, cannot make measurements across sessions.</p>
                  <p>During parallel synchronization or optimization, the trace profile is copied to the slave sessions if and only if tracing is currently enabled. Each slave accumulates its own traces and implicitly writes all trace values to the slave logfile before termination.</p>
                  <div class="infoboxnotealso" id="GUID-E282E4C7-6F64-46AB-909D-1E2F07A563CF__GUID-4E830C0B-461E-44DD-AB0E-FF5F0AEB006B">
                     <p class="notep1">See Also:</p>
                     <p><a href="../ccref/CTX_OUTPUT-package.html#CCREF0800" target="_blank"><span class="italic">Oracle Text Reference</span></a></p>
                  </div>
               </div>
            </div><a id="CCAPP9248"></a><div class="props_rev_3"><a id="GUID-51F4ABF4-83A1-44EA-80FB-EF72430D3A1A" name="GUID-51F4ABF4-83A1-44EA-80FB-EF72430D3A1A"></a><h3 id="CCAPP-GUID-51F4ABF4-83A1-44EA-80FB-EF72430D3A1A" class="sect3"><span class="enumeration_section">10.7 </span>Using Parallel Queries
               </h3>
               <div>
                  <p>In general, parallel queries are optimal for Decision Support System (DSS) and Online Analysis Processing (OLAP). They are also optimal for analytical systems that have large data collections, multiple CPUs with a low number of concurrent users, or <a id="d24571e2846" class="indexterm-anchor"></a><a id="d24571e2850" class="indexterm-anchor"></a>Oracle Real Application Clusters (Oracle RAC) nodes.
                  </p>
                  <p>Oracle Text supports the following parallel queries:</p>
                  <ul style="list-style-type: disc;">
                     <li>
                        <p><a href="tuning-oracle-text.html#GUID-068C5AA8-D3C9-4885-B49A-8CA8E3BDE018">Parallel Queries on a Local Context Index</a></p>
                     </li>
                     <li>
                        <p><a href="tuning-oracle-text.html#GUID-EF57F3D2-52ED-4571-B860-4986657C2D2C">Parallelizing Queries Across Oracle RAC Nodes</a></p>
                     </li>
                  </ul>
               </div><a id="CCAPP9249"></a><div class="props_rev_3"><a id="GUID-068C5AA8-D3C9-4885-B49A-8CA8E3BDE018" name="GUID-068C5AA8-D3C9-4885-B49A-8CA8E3BDE018"></a><h4 id="CCAPP-GUID-068C5AA8-D3C9-4885-B49A-8CA8E3BDE018" class="sect4"><span class="enumeration_section">10.7.1 </span>Parallel Queries on a Local Context Index
                  </h4>
                  <div>
                     <p><span class="italic">Parallel query</span> refers to the parallelized processing of a local <code class="codeph">CONTEXT</code> index. Based on the parallel degree of the index and various system attributes, Oracle determines the number of parallel query slaves to be spawned to process the index. Each parallel query slave processes one or more index partitions. This default query behavior applies to local indexes that are created in parallel.
                     </p>
                     <p>However, for heavily loaded systems with a high number of concurrent users, query throughput is generally worse with parallel query; if the query is run serially, the top-N hits can usually be satisfied by the first few partitions. For example, take the typical top-N text queries with an <code class="codeph">ORDER</code> <code class="codeph">BY</code> partition key column:
                     </p><pre class="oac_no_warn" dir="ltr">select * from (
        select story_id from stories_tab where contains(...)&gt;0 order by 
publication_date desc)
    where rownum &lt;= 10;
</pre><p>These text queries generally perform <span class="italic">worse</span> with a parallel query.
                     </p>
                     <p>You can disable parallel querying after a parallel index operation with an <code class="codeph">ALTER INDEX</code> statement:
                     </p><pre class="oac_no_warn" dir="ltr">Alter index &lt;text index name&gt; NOPARALLEL;
Alter index &lt;text index name&gt; PARALLEL 1;
</pre><p>You can also enable or increase the parallel degree:</p><pre class="oac_no_warn" dir="ltr">Alter index &lt;text index name&gt; parallel &lt; parallel degree &gt;;</pre></div>
               </div><a id="CCAPP9471"></a><div class="props_rev_3"><a id="GUID-EF57F3D2-52ED-4571-B860-4986657C2D2C" name="GUID-EF57F3D2-52ED-4571-B860-4986657C2D2C"></a><h4 id="CCAPP-GUID-EF57F3D2-52ED-4571-B860-4986657C2D2C" class="sect4"><span class="enumeration_section">10.7.2 </span>Parallelizing Queries Across Oracle RAC Nodes
                  </h4>
                  <div>
                     <p>Oracle Real Application Clusters (Oracle RAC) provides an excellent solution for improving query throughput. If you can get good performance from Oracle Text with a light query load, then you can expect to get excellent scalability from Oracle RAC as the query load increases.</p>
                     <p>You can achieve further improvements in Oracle Text performance by physically partitioning the text data and Oracle Text indexes (using local partitioned indexes) and ensuring that partitions are handled by separate Oracle RAC nodes. This way, you avoid duplication of the cache contents across multiple nodes and, therefore, maximize the benefit of Oracle RAC cache fusion.</p>
                     <p>In Oracle 10<span class="italic">g</span> Release 1, you must force each Oracle Text index partition into a separate database file when the index is created. This enables the "remastering" feature in Oracle RAC to force database file affinity, where each node concentrates on a particular database file and, therefore, a particular Oracle Text index partition.
                     </p>
                     <p>In Oracle 10<span class="italic">g</span> Release 2 and later, Oracle supports database object-level affinity, which makes it much easier to allocate index objects (<code class="codeph">$I</code> and <code class="codeph">$R</code> tables) to particular nodes.
                     </p>
                     <p>Although Oracle RAC offers solutions for improving query throughput and performance, it does not necessarily enable you to continue to get the same performance improvements as you scale up the data volumes. You are more likely to see improvements by increasing the amount of memory available to the system global area (SGA) cache or by partitioning your data so that queries do not have to hit all table partitions in order to provide the required set of query results.</p>
                  </div>
               </div>
            </div><a id="CCAPP9251"></a><div class="props_rev_3"><a id="GUID-45AA18EF-710D-4A32-8A6C-3522054B10A8" name="GUID-45AA18EF-710D-4A32-8A6C-3522054B10A8"></a><h3 id="CCAPP-GUID-45AA18EF-710D-4A32-8A6C-3522054B10A8" class="sect3"><span class="enumeration_section">10.8 </span>Tuning Queries with Blocking Operations
               </h3>
               <div>
                  <p>If you issue a query with more than one predicate, you can cause a blocking operation in the execution plan. For example, consider the following mixed query:</p><pre class="oac_no_warn" dir="ltr">select docid from mytab where contains(text, 'oracle', 1) &gt; 0 
  AND colA &gt; 5 
  AND colB &gt; 1 
  AND colC &gt; 3; 
</pre><p>Assume that all predicates are unselective and colA, colB, and colC have bitmap indexes. The CBO in Oracle Database chooses the following execution plan:</p><pre class="oac_no_warn" dir="ltr">TABLE ACCESS BY ROWIDS
  BITMAP CONVERSION TO ROWIDS
    BITMAP AND
      BITMAP INDEX COLA_BMX
      BITMAP INDEX COLB_BMX
      BITMAP INDEX COLC_BMX
      BITMAP CONVERSION FROM ROWIDS
        SORT ORDER BY
          DOMAIN INDEX MYINDEX
</pre><p>Because <code class="codeph">BITMAP</code> <code class="codeph">AND</code> is a blocking operation, Oracle Text must temporarily save the rowid and score pairs returned from the Oracle Text domain index before it runs the <code class="codeph">BITMAP</code> <code class="codeph">AND</code> operation.
                  </p>
                  <p>Oracle Text attempts to save these rowid and score pairs in memory. However, when the size of the result set exceeds the <code class="codeph">SORT_AREA_SIZE</code> initialization parameter, Oracle Text spills these results to temporary segments on disk.
                  </p>
                  <p>Because saving results to disk causes extra overhead, you can improve performance by increasing the <code class="codeph">SORT_AREA_SIZE</code> parameter.
                  </p><pre class="oac_no_warn" dir="ltr">alter session set SORT_AREA_SIZE = &lt;new memory size in bytes&gt;;
</pre><p>For example, set the buffer to approximately 8 megabytes.</p><pre class="oac_no_warn" dir="ltr">alter session set SORT_AREA_SIZE = 8300000;</pre><div class="infoboxnotealso" id="GUID-45AA18EF-710D-4A32-8A6C-3522054B10A8__GUID-80052CB4-1040-4D63-8C76-F09014CE5458">
                     <p class="notep1">See Also:</p>
                     <p><a href="../tgdba/managing-operating-system-resources.html#TGDBA-GUID-1C9C8D2D-AEB3-46C8-94D3-0BF24551870E" target="_blank"><span class="italic">Oracle Database Performance Tuning Guide</span></a> and <a href="../refrn/SORT_AREA_SIZE.html#REFRN-GUID-A343E04E-B484-4791-8B01-12E182AA00C7" target="_blank"><span class="italic">Oracle Database Reference</span></a> for more information on <code class="codeph">SORT_AREA_SIZE</code></p>
                  </div>
               </div>
            </div><a id="CCAPP9252"></a><div class="props_rev_3"><a id="GUID-90312BBE-00D7-4200-B6AF-77CAFAA5D2F3" name="GUID-90312BBE-00D7-4200-B6AF-77CAFAA5D2F3"></a><h3 id="CCAPP-GUID-90312BBE-00D7-4200-B6AF-77CAFAA5D2F3" class="sect3"><span class="enumeration_section">10.9 </span>Frequently Asked Questions About Query Performance
               </h3>
               <div>
                  <p>This section answers some of the frequently asked questions about query performance. </p>
                  <ul style="list-style-type: disc;">
                     <li>
                        <p><a href="tuning-oracle-text.html#GUID-2522997E-2CCB-4AED-8EC8-D10CEC7293FE">What is Query Performance?</a></p>
                     </li>
                     <li>
                        <p><a href="tuning-oracle-text.html#GUID-124913E6-83D6-4525-8856-2EF87B32FD8F">What is the fastest type of text query?</a></p>
                     </li>
                     <li>
                        <p><a href="tuning-oracle-text.html#GUID-9896CBA2-946B-4202-952F-A891DA944DF9">Should I collect statistics on my tables?</a></p>
                     </li>
                     <li>
                        <p><a href="tuning-oracle-text.html#GUID-461B30DE-424D-40D8-A25F-5EF08A24D670">How does the size of my data affect queries?</a></p>
                     </li>
                     <li>
                        <p><a href="tuning-oracle-text.html#GUID-E0B29AC4-AB3C-489C-B7E8-FD972D5399A8">How does the format of my data affect queries?</a></p>
                     </li>
                     <li>
                        <p><a href="tuning-oracle-text.html#GUID-BAC89AA2-829C-4A96-8266-85960EE837E4">What is a functional versus an indexed lookup?</a></p>
                     </li>
                     <li>
                        <p><a href="tuning-oracle-text.html#GUID-C2AC7280-37D9-4F16-8618-67FD1B97BAC7">What tables are involved in queries?</a></p>
                     </li>
                     <li>
                        <p><a href="tuning-oracle-text.html#GUID-55032801-6D7B-4E93-AA6C-FF6B98CD76B3">How is $R contention reduced?</a></p>
                     </li>
                     <li>
                        <p><a href="tuning-oracle-text.html#GUID-99E8D918-EB5B-4835-81E0-D7C533DA9E4A">Does sorting the results slow a text-only query?</a></p>
                     </li>
                     <li>
                        <p><a href="tuning-oracle-text.html#GUID-76416A9B-F4A8-47D4-874E-3E8FABD8ECB1">How do I make an ORDER BY score query faster?</a></p>
                     </li>
                     <li>
                        <p><a href="tuning-oracle-text.html#GUID-AFB7B3D3-0B03-4BE4-834F-BF1295CD11CD">Which memory settings affect querying?</a></p>
                     </li>
                     <li>
                        <p><a href="tuning-oracle-text.html#GUID-19431FDB-AD40-4DCF-A235-D372F7C9B33B">Does out-of-line LOB storage of wide base table columns improve performance?</a></p>
                     </li>
                     <li>
                        <p><a href="tuning-oracle-text.html#GUID-9F51A472-C8F5-4F1F-A17B-8A21BB38CBC5">How can I make a CONTAINS query on more than one column faster?</a></p>
                     </li>
                     <li>
                        <p><a href="tuning-oracle-text.html#GUID-7E174101-D66D-43E9-9A8B-69EBA73F6502">Is it OK to have many expansions in a query?</a></p>
                     </li>
                     <li>
                        <p><a href="tuning-oracle-text.html#GUID-3E1CF9FB-60EE-4FA7-98CC-C0C895BEF2B8">How can local partition indexes help?</a></p>
                     </li>
                     <li>
                        <p><a href="tuning-oracle-text.html#GUID-D278E686-664A-4083-AF02-F3F27DE973E1">Should I query in parallel?</a></p>
                     </li>
                     <li>
                        <p><a href="tuning-oracle-text.html#GUID-AB3F280E-4FBE-417C-BA1E-5FEFBE731906">Should I index themes?</a></p>
                     </li>
                     <li>
                        <p><a href="tuning-oracle-text.html#GUID-BC4B11B8-348C-47AF-A49D-99EE0312F73F">When should I use a CTXCAT index?</a></p>
                     </li>
                     <li>
                        <p><a href="tuning-oracle-text.html#GUID-7844B5A5-E096-4B6E-91D0-59D23B46B375">When is a CTXCAT index NOT suitable?</a></p>
                     </li>
                     <li>
                        <p><a href="tuning-oracle-text.html#GUID-6AC6C18F-2F28-4DAA-ACDF-F59615B1CFD9">What optimizer hints are available and what do they do?</a></p>
                     </li>
                  </ul>
               </div><a id="CCAPP9253"></a><div class="props_rev_3"><a id="GUID-2522997E-2CCB-4AED-8EC8-D10CEC7293FE" name="GUID-2522997E-2CCB-4AED-8EC8-D10CEC7293FE"></a><h4 id="CCAPP-GUID-2522997E-2CCB-4AED-8EC8-D10CEC7293FE" class="sect4"><span class="enumeration_section">10.9.1 </span>What is query performance?
                  </h4>
                  <div>
                     <p><span class="bold">Answer:</span> There are two measures of query performance:
                     </p>
                     <ul style="list-style-type: disc;">
                        <li>
                           <p><span class="bold">Response time:</span> The time to get an answer to an individual query
                           </p>
                        </li>
                        <li>
                           <p><span class="bold">Throughput:</span> The number of queries that can be run in any given time period; for example, queries each second
                           </p>
                        </li>
                     </ul>
                     <p>These two measures are related, but they are not the same. In a heavily loaded system, you want maximum throughput, whereas in a relatively lightly loaded system, you probably want minimum response time. Also, some applications require a query to deliver all hits to the user, whereas others only require the first 20 hits from an ordered set. It is important to distinguish between these two scenarios. </p>
                  </div>
               </div><a id="CCAPP9254"></a><div class="props_rev_3"><a id="GUID-124913E6-83D6-4525-8856-2EF87B32FD8F" name="GUID-124913E6-83D6-4525-8856-2EF87B32FD8F"></a><h4 id="CCAPP-GUID-124913E6-83D6-4525-8856-2EF87B32FD8F" class="sect4"><span class="enumeration_section">10.9.2 </span>What is the fastest type of Oracle Text query?
                  </h4>
                  <div>
                     <p><span class="bold">Answer: </span>The fastest type of query meets the following conditions: 
                     </p>
                     <ul style="list-style-type: disc;">
                        <li>
                           <p>Single <code class="codeph">CONTAINS</code> clause 
                           </p>
                        </li>
                        <li>
                           <p>No other conditions in the <code class="codeph">WHERE</code> clause 
                           </p>
                        </li>
                        <li>
                           <p>No <code class="codeph">ORDER</code> <code class="codeph">BY</code> clause
                           </p>
                        </li>
                        <li>
                           <p>Returns only the first page of results (for example, the first 10 or 20 hits) </p>
                        </li>
                     </ul>
                  </div>
               </div><a id="CCAPP9255"></a><div class="props_rev_3"><a id="GUID-9896CBA2-946B-4202-952F-A891DA944DF9" name="GUID-9896CBA2-946B-4202-952F-A891DA944DF9"></a><h4 id="CCAPP-GUID-9896CBA2-946B-4202-952F-A891DA944DF9" class="sect4"><span class="enumeration_section">10.9.3 </span>Should I collect statistics on my tables?
                  </h4>
                  <div>
                     <p><span class="bold">Answer:</span> Yes. Collecting statistics on your tables enables Oracle Text to do cost-based analysis. This helps Oracle Text choose the most efficient execution plan for your queries. 
                     </p>
                     <p>If your queries are always pure text queries (no structured predicate and no joins), you should delete statistics on your Oracle Text index.</p>
                  </div>
               </div><a id="CCAPP9256"></a><div class="props_rev_3"><a id="GUID-461B30DE-424D-40D8-A25F-5EF08A24D670" name="GUID-461B30DE-424D-40D8-A25F-5EF08A24D670"></a><h4 id="CCAPP-GUID-461B30DE-424D-40D8-A25F-5EF08A24D670" class="sect4"><span class="enumeration_section">10.9.4 </span>How does the size of my data affect queries?
                  </h4>
                  <div>
                     <p><span class="bold">Answer: </span>The speed at which the Oracle Text index can deliver rowids is not affected by the actual size of the data. Oracle Text query speed is related to the number of rows that must be fetched from the index table, the number of hits requested, the number of hits produced by the query, and the presence or absence of sorting. 
                     </p>
                  </div>
               </div><a id="CCAPP9257"></a><div class="props_rev_3"><a id="GUID-E0B29AC4-AB3C-489C-B7E8-FD972D5399A8" name="GUID-E0B29AC4-AB3C-489C-B7E8-FD972D5399A8"></a><h4 id="CCAPP-GUID-E0B29AC4-AB3C-489C-B7E8-FD972D5399A8" class="sect4"><span class="enumeration_section">10.9.5 </span>How does the format of my data affect queries?
                  </h4>
                  <div>
                     <p><span class="bold">Answer:</span> The format of the documents (plain ASCII text, HTML, or Microsoft Word) should make no difference to query speed. The documents are filtered to plain text at indexing time, not query time. 
                     </p>
                     <p>The cleanliness of the data makes a difference. Spell-checked and subedited text for publication tends to have a much smaller total vocabulary (and therefore size of the index table) than informal text such as email, which contains spelling errors and abbreviations. For a given index memory setting, the extra text takes up memory, creates more fragmented rows, and adversely affects query response time. </p>
                  </div>
               </div><a id="CCAPP9258"></a><div class="props_rev_3"><a id="GUID-BAC89AA2-829C-4A96-8266-85960EE837E4" name="GUID-BAC89AA2-829C-4A96-8266-85960EE837E4"></a><h4 id="CCAPP-GUID-BAC89AA2-829C-4A96-8266-85960EE837E4" class="sect4"><span class="enumeration_section">10.9.6 </span>What is the difference between an indexed lookup and a functional lookup
                  </h4>
                  <div>
                     <p><span class="bold">Answer:</span> The kernel can query the Oracle Text index with an indexed lookup and a functional lookup. In the indexed lookup, the first and most common case, the kernel asks the Oracle Text index for all rowids that satisfy a particular text search. These rowids are returned in batches.
                     </p>
                     <p>In the functional lookup, the kernel passes individual rowids to the Oracle Text index and asks whether that particular rowid satisfies a certain text criterion. The functional lookup is most commonly used with a very selective structured clause, so that only a few rowids must be checked against the Oracle Text index. Here is an example of a search where a functional lookup is useful: </p><pre class="oac_no_warn" dir="ltr">SELECT ID, SCORE(1), TEXT FROM MYTABLE</pre><pre class="oac_no_warn" dir="ltr">WHERE START_DATE = '21 Oct 1992'         &lt;- highly selective
AND CONTAINS (TEXT, 'commonword') &gt; 0    &lt;- unselective
</pre><p>Functional invocation is also used for an Oracle Text query that is ordered by a structured column (for example date, price) and if the Oracle Text query contains unselective words.</p>
                  </div>
               </div><a id="CCAPP9259"></a><div class="props_rev_3"><a id="GUID-C2AC7280-37D9-4F16-8618-67FD1B97BAC7" name="GUID-C2AC7280-37D9-4F16-8618-67FD1B97BAC7"></a><h4 id="CCAPP-GUID-C2AC7280-37D9-4F16-8618-67FD1B97BAC7" class="sect4"><span class="enumeration_section">10.9.7 </span>What tables are involved in queries?
                  </h4>
                  <div>
                     <p><span class="bold">Answer:</span> All queries look at the index token table. The tables name has the form of <code class="codeph">DR$indexname$I</code> and contains the list of tokens (<code class="codeph">TOKEN_TEXT</code> column) and the information about the row and word positions where the token occurs (<code class="codeph">TOKEN_INFO</code> column). 
                     </p>
                     <p>The row information is stored as internal docid values that must be translated into external rowid values. The table that you use depends on the type of lookup:</p>
                     <ul style="list-style-type: disc;">
                        <li>
                           <p>For functional lookups, use the <code class="codeph">$K</code> table, <code class="codeph">DR$indexname$K.</code> This simple Index Organized Table (IOT) contains a row for each docid/rowid pair.
                           </p>
                        </li>
                        <li>
                           <p>For indexed lookups, use the <code class="codeph">$R</code> table, <code class="codeph">DR$indexname$R.</code> This table holds the complete list of rowids in a BLOB column.
                           </p>
                        </li>
                     </ul>
                     <p>Starting with Oracle Database 12<span class="italic">c</span> Release 2 (12.2), a new storage attribute, <code class="codeph">SMALL_R_ROW,</code> was introduced to reduce the size of the <code class="codeph">$R</code> row. It populates <code class="codeph">$R</code> rows on demand instead of creating 22 static rows, thereby reducing the Data Manipulation Language contention. The contention happens when parallel insert, update, and delete operations try to lock the same <code class="codeph">$R</code> row. 
                     </p>
                     <p>You can easily find out whether a functional or indexed lookup is being used by examining a SQL trace and looking for the <code class="codeph">$K</code> or <code class="codeph">$R</code> tables.
                     </p>
                     <div class="infoboxnote" id="GUID-C2AC7280-37D9-4F16-8618-67FD1B97BAC7__GUID-8BD69135-5AA9-4FE5-AB2C-E11D0DA0B729">
                        <p class="notep1">Note:</p>
                        <p>These internal index tables are subject to change from release to release. Oracle recommends that you do not directly access these tables in your application.</p>
                     </div>
                  </div>
               </div>
               <div class="sect3"><a id="GUID-55032801-6D7B-4E93-AA6C-FF6B98CD76B3" name="GUID-55032801-6D7B-4E93-AA6C-FF6B98CD76B3"></a><h4 id="CCAPP-GUID-55032801-6D7B-4E93-AA6C-FF6B98CD76B3" class="sect4"><span class="enumeration_section">10.9.8 </span>How is the $R table contention reduced?
                  </h4>
                  <div>
                     <div class="p">The <code class="codeph">$R</code> contention during base table delete and update operations has become a recurring theme over the past few years. Currently, each <code class="codeph">$R</code> index table has 22 static rows, and each row can contain up to 200 million rowids. The contention happens when the parallel insert, update, and delete operations try to lock the same <code class="codeph">$R</code> row for insert or delete operations. The following enhancements made during this release reduce the contention:
                        <ul style="list-style-type: disc;">
                           <li>
                              <p>The maximum number of rowids that each <code class="codeph">$R</code> row can contain is 70,000, which translates to 1 MB of data stored on each row. To use this feature, you must set the <code class="codeph">SMALL_R_ROW</code> storage attribute.
                              </p>
                           </li>
                           <li>
                              <p>The <code class="codeph">$R</code> rows are created on demand instead of just populating a pre-determined number of rows. 
                              </p>
                           </li>
                        </ul>
                     </div>
                  </div>
               </div><a id="CCAPP9260"></a><div class="props_rev_3"><a id="GUID-99E8D918-EB5B-4835-81E0-D7C533DA9E4A" name="GUID-99E8D918-EB5B-4835-81E0-D7C533DA9E4A"></a><h4 id="CCAPP-GUID-99E8D918-EB5B-4835-81E0-D7C533DA9E4A" class="sect4"><span class="enumeration_section">10.9.9 </span>Does sorting the results slow a text-only query?
                  </h4>
                  <div>
                     <p><span class="bold">Answer:</span> Yes, it certainly does. 
                     </p>
                     <p>If Oracle Text does not sort, then it can return results as it finds them. This approach is quicker when the application needs to display only a page of results at a time. </p>
                  </div>
               </div><a id="CCAPP9261"></a><div class="props_rev_3"><a id="GUID-76416A9B-F4A8-47D4-874E-3E8FABD8ECB1" name="GUID-76416A9B-F4A8-47D4-874E-3E8FABD8ECB1"></a><h4 id="CCAPP-GUID-76416A9B-F4A8-47D4-874E-3E8FABD8ECB1" class="sect4"><span class="enumeration_section">10.9.10 </span>How do I make an ORDER BY score query faster?
                  </h4>
                  <div>
                     <p><span class="bold">Answer:</span> Sorting by relevance (<code class="codeph">SCORE(n)</code>) can be fast if you use the <code class="codeph">FIRST_ROWS(n)</code> hint. In this case, Oracle Text performs a high-speed internal sort when fetching from the Oracle Text index tables. 
                     </p>
                     <p>Here is an example of this query: </p><pre class="oac_no_warn" dir="ltr">              SELECT /*+ FIRST_ROWS(10) */ ID, SCORE(1), TEXT FROM mytable
                WHERE CONTAINS (TEXT, 'searchterm', 1) &gt; 0
                ORDER BY SCORE(1) DESC;
</pre><p>It is important to note that, there must be no other criteria in the <code class="codeph">WHERE</code> clause, other than a single <code class="codeph">CONTAINS.</code></p>
                  </div>
               </div><a id="CCAPP9262"></a><div class="props_rev_3"><a id="GUID-AFB7B3D3-0B03-4BE4-834F-BF1295CD11CD" name="GUID-AFB7B3D3-0B03-4BE4-834F-BF1295CD11CD"></a><h4 id="CCAPP-GUID-AFB7B3D3-0B03-4BE4-834F-BF1295CD11CD" class="sect4"><span class="enumeration_section">10.9.11 </span>Which memory settings affect querying?
                  </h4>
                  <div>
                     <p><span class="bold">Answer:</span> For querying, you want to strive for a large system global area (SGA). You can set these SGA parameters in your Oracle Database initialization file. You can also set these parameters dynamically. 
                     </p>
                     <p>The <code class="codeph">SORT_AREA_SIZE</code> parameter controls the memory that is available for sorting <code class="codeph">ORDER BY</code> queries. You should increase the size of this parameter if you frequently order by structured columns.
                     </p>
                     <div class="infoboxnotealso" id="GUID-AFB7B3D3-0B03-4BE4-834F-BF1295CD11CD__GUID-A7175F29-6BD8-4A4F-9D2C-4DA29B181E06">
                        <p class="notep1">See Also:</p>
                        <p></p>
                        <ul style="list-style-type: disc;">
                           <li>
                              <p><a href="../admin/managing-memory.html#ADMIN-GUID-BEABE53D-8058-4834-B99B-5C80A8AD5B06" target="_blank"><span class="italic">Oracle Database Administrator's Guide</span></a> for more information on setting SGA related parameters
                              </p>
                           </li>
                           <li>
                              <p><a href="../tgdba/database-memory-allocation.html#TGDBA-GUID-E9265077-B296-485A-BC2C-0AF55762D1EC" target="_blank"><span class="italic">Oracle Database Performance Tuning Guide</span></a> for more information on memory allocation
                              </p>
                           </li>
                           <li>
                              <p><a href="../refrn/SORT_AREA_SIZE.html#REFRN-GUID-A343E04E-B484-4791-8B01-12E182AA00C7" target="_blank"><span class="italic">Oracle Database Reference</span></a> for more information on setting the <code class="codeph">SORT_AREA_SIZE</code> parameter
                              </p>
                           </li>
                        </ul>
                     </div>
                  </div>
               </div><a id="CCAPP9263"></a><div class="props_rev_3"><a id="GUID-19431FDB-AD40-4DCF-A235-D372F7C9B33B" name="GUID-19431FDB-AD40-4DCF-A235-D372F7C9B33B"></a><h4 id="CCAPP-GUID-19431FDB-AD40-4DCF-A235-D372F7C9B33B" class="sect4"><span class="enumeration_section">10.9.12 </span>Does out-of-line LOB storage of wide base table columns improve performance?
                  </h4>
                  <div>
                     <p><span class="bold">Answer: </span>Yes. Typically, a <code class="codeph">SELECT</code> statement selects more than one column from your base table. Because Oracle Text fetches columns to memory, it is more efficient to store wide base table columns such as large objects (LOBs) out of line, especially when these columns are rarely updated but frequently selected. 
                     </p>
                     <p>When LOBs are stored out of line, only the LOB locators need to be fetched to memory during querying. Out-of-line storage reduces the effective size of the base table. It makes it easier for Oracle Text to cache the entire table to memory, and so reduces the cost of selecting columns from the base table, and speeds up text queries.</p>
                     <p>In addition, smaller base tables cached in memory enables more index table data to be cached during querying, which improves performance.</p>
                  </div>
               </div><a id="CCAPP9264"></a><div class="props_rev_3"><a id="GUID-9F51A472-C8F5-4F1F-A17B-8A21BB38CBC5" name="GUID-9F51A472-C8F5-4F1F-A17B-8A21BB38CBC5"></a><h4 id="CCAPP-GUID-9F51A472-C8F5-4F1F-A17B-8A21BB38CBC5" class="sect4"><span class="enumeration_section">10.9.13 </span>How can I speed up a CONTAINS query on more than one column?
                  </h4>
                  <div>
                     <p><span class="bold">Answer:</span> The fastest type of query is one where there is only a single <code class="codeph">CONTAINS</code> clause and no other conditions in the <code class="codeph">WHERE</code> clause. 
                     </p>
                     <p>Consider the following multiple <code class="codeph">CONTAINS</code> query: 
                     </p><pre class="oac_no_warn" dir="ltr">              SELECT title, isbn FROM booklist
                WHERE CONTAINS (title, 'horse') &gt; 0
                  AND CONTAINS (abstract, 'racing') &gt; 0
</pre><p>You can get the same result with section searching and the <code class="codeph">WITHIN</code> operator:
                     </p><pre class="oac_no_warn" dir="ltr">              SELECT title, isbn FROM booklist
                WHERE CONTAINS (alltext, 
                  'horse WITHIN title AND racing WITHIN abstract')&gt;0
</pre><p>This query is completed more quickly than the single <code class="codeph">CONTAINS</code> clause. To use a query like this, you must copy all data into a single text column for indexing, with section tags around each column's data. You can do that with PL/SQL procedures before indexing, or you can use the <code class="codeph">USER_DATASTORE</code> datastore during indexing to synthesize structured columns with the text column into one document. 
                     </p>
                  </div>
               </div><a id="CCAPP9265"></a><div class="props_rev_3"><a id="GUID-7E174101-D66D-43E9-9A8B-69EBA73F6502" name="GUID-7E174101-D66D-43E9-9A8B-69EBA73F6502"></a><h4 id="CCAPP-GUID-7E174101-D66D-43E9-9A8B-69EBA73F6502" class="sect4"><span class="enumeration_section">10.9.14 </span>Can I have many expansions in a query?
                  </h4>
                  <div>
                     <p><span class="bold">Answer:</span> Each distinct word used in a query requires at least one row to be fetched from the index table. It is therefore best to keep the number of expansions down as much as possible. 
                     </p>
                     <p>You should not use expansions such as wild cards, thesaurus, stemming, and fuzzy matching unless they are necessary to the task. In general, a few expansions (for example, 10 to 20) does not cause difficulty, but avoid a large number of expansions (80 or 100) in a query. Use the query feedback mechanism to determine the number of expansions for any particular query expression.</p>
                     <p>For wildcard and stem queries, you can avoid term expansion from query time to index time by creating prefix, substring, or stem indexes. Query performance increases at the cost of longer indexing time and added disk space. </p>
                     <p>Prefix and substring indexes can improve wildcard performance. You enable prefix and substring indexing with the <code class="codeph">BASIC_WORDLIST</code> preference. The following example sets the wordlist preference for prefix and substring indexing. For prefix indexing, it specifies that Oracle Text creates token prefixes between 3 and 4 characters long:
                     </p><pre class="oac_no_warn" dir="ltr">begin </pre><pre class="oac_no_warn" dir="ltr">ctx_ddl.create_preference('mywordlist', 'BASIC_WORDLIST'); 
ctx_ddl.set_attribute('mywordlist','PREFIX_INDEX','TRUE');
ctx_ddl.set_attribute('mywordlist','PREFIX_MIN_LENGTH', '3');
ctx_ddl.set_attribute('mywordlist','PREFIX_MAX_LENGTH', '4');
ctx_ddl.set_attribute('mywordlist','SUBSTRING_INDEX', 'YES');</pre><pre class="oac_no_warn" dir="ltr">end</pre><p></p>
                     <p>Enable stem indexing with the <code class="codeph">BASIC_LEXER</code> preference:
                     </p><pre class="oac_no_warn" dir="ltr">begin</pre><pre class="oac_no_warn" dir="ltr">ctx_ddl.create_preference('mylex', 'BASIC_LEXER');
ctx_ddl.set_attribute ( 'mylex', 'index_stems', 'ENGLISH');</pre><pre class="oac_no_warn" dir="ltr">end;</pre></div>
               </div><a id="CCAPP9266"></a><div class="props_rev_3"><a id="GUID-3E1CF9FB-60EE-4FA7-98CC-C0C895BEF2B8" name="GUID-3E1CF9FB-60EE-4FA7-98CC-C0C895BEF2B8"></a><h4 id="CCAPP-GUID-3E1CF9FB-60EE-4FA7-98CC-C0C895BEF2B8" class="sect4"><span class="enumeration_section">10.9.15 </span>How can local partition indexes help?
                  </h4>
                  <div>
                     <p><span class="bold">Answer:</span> You can create local partitioned <code class="codeph">CONTEXT</code> indexes on partitioned tables. This means that, on a partitioned table, each partition has its own set of index tables. Effectively, the results from the multiple indexes are combined as necessary to produce the final result set. 
                     </p>
                     <p>Use the <code class="codeph">LOCAL</code> keyword to create the index: 
                     </p><pre class="oac_no_warn" dir="ltr">CREATE INDEX index_name ON table_name (column_name) 
INDEXTYPE IS ctxsys.context
PARAMETERS ('...')
LOCAL
</pre><p>With partitioned tables and local indexes, you can improve performance of the following types of <code class="codeph">CONTAINS</code> queries:
                     </p>
                     <ul style="list-style-type: disc;">
                        <li>
                           <p><span class="bold">Range Search on Partition Key Column:</span> This query restricts the search to a particular range of values on a column that is also the partition key.
                           </p>
                        </li>
                        <li>
                           <p><span class="bold">ORDER BY Partition Key Column:</span> This query requires only the first <code class="codeph">n</code> hits, and the <code class="codeph">ORDER BY</code> clause names the partition key.
                           </p>
                           <div class="infoboxnotealso" id="GUID-3E1CF9FB-60EE-4FA7-98CC-C0C895BEF2B8__GUID-DBF5C15E-932A-44E2-8C04-55EA59A9B0EE">
                              <p class="notep1">See Also:</p>
                              <p><span class="q">"<a href="tuning-oracle-text.html#GUID-DE0B4638-A760-47C4-8593-F68ECEBFD370">Improved Response Time using Local Partitioned CONTEXT Index</a>"</span></p>
                           </div>
                        </li>
                     </ul>
                  </div>
               </div><a id="CCAPP9267"></a><div class="props_rev_3"><a id="GUID-D278E686-664A-4083-AF02-F3F27DE973E1" name="GUID-D278E686-664A-4083-AF02-F3F27DE973E1"></a><h4 id="CCAPP-GUID-D278E686-664A-4083-AF02-F3F27DE973E1" class="sect4"><span class="enumeration_section">10.9.16 </span>Should I query in parallel?
                  </h4>
                  <div>
                     <p><span class="bold">Answer:</span> It depends on system load and server capacity. Even though parallel querying is the default behavior for indexes created in parallel, it usually degrades the overall query throughput on heavily loaded systems.
                     </p>
                     <p>Parallel queries are optimal for Decision Support System (DSS) and Online Analysis Processing (OLAP). They are also optimal for analytical systems that have large data collections, multiple CPUs with a low number of concurrent users, or Oracle Real Application Clusters (Oracle RAC) nodes.</p>
                     <div class="infoboxnotealso" id="GUID-D278E686-664A-4083-AF02-F3F27DE973E1__GUID-E7D43ECB-6788-49A4-8412-19C31BCCD9AF">
                        <p class="notep1">See Also:</p>
                        <p><span class="q">"<a href="tuning-oracle-text.html#GUID-51F4ABF4-83A1-44EA-80FB-EF72430D3A1A">Using Parallel Queries</a>"</span></p>
                     </div>
                  </div>
               </div><a id="CCAPP9268"></a><div class="props_rev_3"><a id="GUID-AB3F280E-4FBE-417C-BA1E-5FEFBE731906" name="GUID-AB3F280E-4FBE-417C-BA1E-5FEFBE731906"></a><h4 id="CCAPP-GUID-AB3F280E-4FBE-417C-BA1E-5FEFBE731906" class="sect4"><span class="enumeration_section">10.9.17 </span>Should I index themes?
                  </h4>
                  <div>
                     <p><span class="bold">Answer:</span> Indexing theme information with a <code class="codeph">CONTEXT</code> index takes longer and also increases the size of your index. However, theme indexes enable <code class="codeph">ABOUT</code> queries to be more precise by using the knowledge base. If your application uses many <code class="codeph">ABOUT</code> queries, it might be worthwhile to create a theme component to the index, despite the extra indexing time and extra storage space required.
                     </p>
                     <div class="infoboxnotealso" id="GUID-AB3F280E-4FBE-417C-BA1E-5FEFBE731906__GUID-6FBB9B06-ACD1-46E9-9B5F-568868F40775">
                        <p class="notep1">See Also:</p>
                        <p><span class="q">"<a href="querying-with-oracle-text.html#GUID-E3ED0880-E919-43BE-BC10-1837D76F0E8F">ABOUT Queries and Themes</a>"</span></p>
                     </div>
                  </div>
               </div><a id="CCAPP9269"></a><div class="props_rev_3"><a id="GUID-BC4B11B8-348C-47AF-A49D-99EE0312F73F" name="GUID-BC4B11B8-348C-47AF-A49D-99EE0312F73F"></a><h4 id="CCAPP-GUID-BC4B11B8-348C-47AF-A49D-99EE0312F73F" class="sect4"><span class="enumeration_section">10.9.18 </span>When should I use a CTXCAT index?
                  </h4>
                  <div>
                     <p><span class="bold">Answer:</span> <code class="codeph">CTXCAT</code> indexes work best when the text is in small chunks (just a few lines), and you want searches to restrict or sort the result set according to certain structured criteria, such as numbers or dates. 
                     </p>
                     <p>For example, consider an online auction site. Each item for sale has a short description, a current bid price, and start and end dates for the auction. A user might want to see all records with <span class="italic">antique cabinet</span> in the description, with a current bid price less than $500. Because he is particularly interested in newly posted items, he wants the results sorted by auction start time. 
                     </p>
                     <p>This search is not always efficient with a <code class="codeph">CONTAINS</code> structured query on a <code class="codeph">CONTEXT</code> index. The response time can vary significantly depending on the structured and <code class="codeph">CONTAINS</code> clauses, because the intersection of structured and <code class="codeph">CONTAINS</code> clauses or the Oracle Text query ordering is computed during query time.
                     </p>
                     <p>By including structured information within the <code class="codeph">CTXCAT</code> index, you ensure that the query response time is always in an optimal range regardless of search criteria. Because the interaction between text and structured query is precomputed during indexing, query response time is optimum.
                     </p>
                  </div>
               </div><a id="CCAPP9270"></a><div class="props_rev_3"><a id="GUID-7844B5A5-E096-4B6E-91D0-59D23B46B375" name="GUID-7844B5A5-E096-4B6E-91D0-59D23B46B375"></a><h4 id="CCAPP-GUID-7844B5A5-E096-4B6E-91D0-59D23B46B375" class="sect4"><span class="enumeration_section">10.9.19 </span>When is a CTXCAT index NOT suitable?
                  </h4>
                  <div>
                     <p><span class="bold">Answer:</span> There are differences in the time and space needed to create the index. <code class="codeph">CTXCAT</code> indexes take a bit longer to create, and they use considerably more disk space than <code class="codeph">CONTEXT</code> indexes. If you are tight on disk space, consider carefully whether <code class="codeph">CTXCAT</code> indexes are appropriate for you.
                     </p>
                     <p>With query operators, you can use the richer <code class="codeph">CONTEXT</code> grammar in <code class="codeph">CATSEARCH</code> queries with query templates. The older restriction of a single <code class="codeph">CATSEARCH</code> query grammar no longer holds.
                     </p>
                  </div>
               </div><a id="CCAPP9271"></a><div class="props_rev_3"><a id="GUID-6AC6C18F-2F28-4DAA-ACDF-F59615B1CFD9" name="GUID-6AC6C18F-2F28-4DAA-ACDF-F59615B1CFD9"></a><h4 id="CCAPP-GUID-6AC6C18F-2F28-4DAA-ACDF-F59615B1CFD9" class="sect4"><span class="enumeration_section">10.9.20 </span>What optimizer hints are available and what do they do?
                  </h4>
                  <div>
                     <p><span class="bold">Answer:</span> To drive the query with a text or b-tree index, you can use the <code class="codeph">INDEX(table column)</code> optimizer hint in the usual way.
                     </p>
                     <p>You can also use the <code class="codeph">NO_INDEX(table column)</code> hint to disable a specific index.
                     </p>
                     <p>The <code class="codeph">FIRST_ROWS(n)</code> hint has a special meaning for text queries. Use it when you need the first <code class="codeph">n</code> hits to a query. When you use the <code class="codeph">DOMAIN_INDEX_SORT</code> hint in conjunction with <code class="codeph">ORDER BY SCORE(n) DESC,</code> you tell the Oracle optimizer to accept a sorted set from the Oracle Text index and to sort no farther.
                     </p>
                     <div class="infoboxnotealso" id="GUID-6AC6C18F-2F28-4DAA-ACDF-F59615B1CFD9__GUID-8288AFDF-74A9-407C-B349-9A322DAA1274">
                        <p class="notep1">See Also:</p>
                        <p><span class="q">"<a href="tuning-oracle-text.html#GUID-3B8371B5-F7AC-4A94-80EE-510B7820EE6D">Optimizing Queries for Response Time</a>"</span></p>
                     </div>
                  </div>
               </div>
            </div><a id="CCAPP9272"></a><div class="props_rev_3"><a id="GUID-82000645-74B9-407E-A9C0-C1ACEE319BD9" name="GUID-82000645-74B9-407E-A9C0-C1ACEE319BD9"></a><h3 id="CCAPP-GUID-82000645-74B9-407E-A9C0-C1ACEE319BD9" class="sect3"><span class="enumeration_section">10.10 </span>Frequently Asked Questions About Indexing Performance
               </h3>
               <div>
                  <p>This section answers some of the frequently asked questions about indexing performance. </p>
                  <ul style="list-style-type: disc;">
                     <li>
                        <p><a href="tuning-oracle-text.html#GUID-A8DD62AA-F50D-4929-A692-61180F5BACE1">How long should indexing take?</a></p>
                     </li>
                     <li>
                        <p><a href="tuning-oracle-text.html#GUID-BBF8E750-E6C9-4149-AB88-8403EC583536">Which index memory settings should I use?</a></p>
                     </li>
                     <li>
                        <p><a href="tuning-oracle-text.html#GUID-AF9AEA5F-7665-4342-8EC8-963701CABCB4">How much disk overhead will indexing require?</a></p>
                     </li>
                     <li>
                        <p><a href="tuning-oracle-text.html#GUID-24EF49DB-AFFB-499C-BC57-000941C6833F">How does the format of my data affect indexing?</a></p>
                     </li>
                     <li>
                        <p><a href="tuning-oracle-text.html#GUID-7ADB0B30-0E1A-4308-B941-3BEEA5DEA5E5">Can parallel indexing improve performance?</a></p>
                     </li>
                     <li>
                        <p><a href="tuning-oracle-text.html#GUID-EA5B318D-9D38-4D4E-925B-8FA9CFD81561">How can I improve index performance for creating local partitioned index?</a></p>
                     </li>
                     <li>
                        <p><a href="tuning-oracle-text.html#GUID-E89DE5BB-7C25-4901-A890-B7925506A3DF">How can I tell how much indexing has completed?</a></p>
                     </li>
                  </ul>
               </div><a id="CCAPP9273"></a><div class="props_rev_3"><a id="GUID-A8DD62AA-F50D-4929-A692-61180F5BACE1" name="GUID-A8DD62AA-F50D-4929-A692-61180F5BACE1"></a><h4 id="CCAPP-GUID-A8DD62AA-F50D-4929-A692-61180F5BACE1" class="sect4"><span class="enumeration_section">10.10.1 </span>How long should indexing take?
                  </h4>
                  <div>
                     <p><span class="bold">Answer:</span> Indexing text is a resource-intensive process. The speed of indexing depends on the power of your hardware. Indexing speed depends on CPU and I/O capacity.  With sufficient I/O capacity to read in the original data and write out index entries, the CPU is the limiting factor.
                     </p>
                     <p>Tests with Intel x86 (Core 2 architecture, 2.5GHz)  CPUs have shown that Oracle Text can index around 100 GB of text per CPU core, per day. This speed would be expected to increase as CPU clock speeds increase and CPU architectures become more efficient.</p>
                     <p>Other factors, such as your document format, location of your data, and the calls to user-defined datastores, filters, and lexers, can affect your indexing speed. </p>
                  </div>
               </div><a id="CCAPP9274"></a><div class="props_rev_3"><a id="GUID-BBF8E750-E6C9-4149-AB88-8403EC583536" name="GUID-BBF8E750-E6C9-4149-AB88-8403EC583536"></a><h4 id="CCAPP-GUID-BBF8E750-E6C9-4149-AB88-8403EC583536" class="sect4"><span class="enumeration_section">10.10.2 </span>Which index memory settings should I use?
                  </h4>
                  <div>
                     <p><span class="bold">Answer:</span> You can set your index memory with the <code class="codeph">DEFAULT_INDEX_MEMORY</code> and <code class="codeph">MAX_INDEX_MEMORY</code> system parameters. You can also set your index memory at runtime with the <code class="codeph">CREATE INDEX</code> <code class="codeph">memory</code> parameter in the parameter string.
                     </p>
                     <p>You should aim to set the <code class="codeph">DEFAULT_INDEX_MEMORY</code> value as high as possible, without causing paging. 
                     </p>
                     <p>You can also improve indexing performance by increasing the <code class="codeph">SORT_AREA_SIZE</code> system parameter.
                     </p>
                     <p>Oracle recommends that you use a large index memory setting. Large settings, even up to hundreds of megabytes, can improve the speed of indexing and reduce fragmentation of the final indexes. However, if you set the index memory setting too high, then memory paging reduces indexing speed.</p>
                     <p>With parallel indexing, each stream requires its own index memory. When dealing with very large tables, you can tune your database system global area (SGA) differently for indexing and retrieval. For querying, you want to get as much information cached in the SGA block buffer cache as possible. So you should allocate a large amount of memory to the block buffer cache. Because this approach does not make any difference to indexing, you would be better off reducing the size of the SGA to make more room for large index memory settings during indexing.</p>
                     <p>You set the size of SGA in your Oracle Database initialization file.</p>
                     <div class="infoboxnotealso" id="GUID-BBF8E750-E6C9-4149-AB88-8403EC583536__GUID-D9908D9A-EBDC-4258-A538-AED03646C7B4">
                        <p class="notep1">See Also:</p>
                        <p></p>
                        <ul style="list-style-type: disc;">
                           <li>
                              <p><a href="../ccref/oracle-text-indexing-elements.html#CCREF0245" target="_blank"><span class="italic">Oracle Text Reference</span></a> to learn more about Oracle Text system parameters
                              </p>
                           </li>
                           <li>
                              <p><a href="../admin/managing-memory.html#ADMIN-GUID-BEABE53D-8058-4834-B99B-5C80A8AD5B06" target="_blank"><span class="italic">Oracle Database Administrator's Guide</span></a> for more information on setting SGA related parameters
                              </p>
                           </li>
                           <li>
                              <p><a href="../tgdba/database-memory-allocation.html#TGDBA-GUID-E9265077-B296-485A-BC2C-0AF55762D1EC" target="_blank"><span class="italic">Oracle Database Performance Tuning Guide</span></a> for more information on memory allocation
                              </p>
                           </li>
                           <li>
                              <p><a href="../refrn/SORT_AREA_SIZE.html#REFRN-GUID-A343E04E-B484-4791-8B01-12E182AA00C7" target="_blank"><span class="italic">Oracle Database Reference</span></a> for more information on setting the <code class="codeph">SORT_AREA_SIZE</code> parameter
                              </p>
                           </li>
                        </ul>
                     </div>
                  </div>
               </div><a id="CCAPP9275"></a><div class="props_rev_3"><a id="GUID-AF9AEA5F-7665-4342-8EC8-963701CABCB4" name="GUID-AF9AEA5F-7665-4342-8EC8-963701CABCB4"></a><h4 id="CCAPP-GUID-AF9AEA5F-7665-4342-8EC8-963701CABCB4" class="sect4"><span class="enumeration_section">10.10.3 </span>How much disk overhead will indexing require?
                  </h4>
                  <div>
                     <p><span class="bold">Answer:</span> The overhead, the amount of space needed for the index tables, varies between about 50 and 200 percent of the original text volume. Generally, larger amounts of text result in smaller overhead, but many small records use more overhead than fewer large records. Also, clean data (such as published text) requires less overhead than dirty data such as emails or discussion notes, because the dirty data is likely to include many misspelled and abbreviated words.
                     </p>
                     <p>A text-only index is smaller than a combined text and theme index. A prefix and substring index makes the index significantly larger.</p>
                  </div>
               </div><a id="CCAPP9276"></a><div class="props_rev_3"><a id="GUID-24EF49DB-AFFB-499C-BC57-000941C6833F" name="GUID-24EF49DB-AFFB-499C-BC57-000941C6833F"></a><h4 id="CCAPP-GUID-24EF49DB-AFFB-499C-BC57-000941C6833F" class="sect4"><span class="enumeration_section">10.10.4 </span>How does the format of my data affect indexing?
                  </h4>
                  <div>
                     <p><span class="bold">Answer:</span> You can expect much lower storage overhead for formatted documents such as Microsoft Word files because the documents tend to be very large compared to the actual text held in them. So 1 GB of Word documents might only require 50 MB of index space, whereas 1 GB of plain text might require 500 MB, because there is ten times as much plain text in the latter set. 
                     </p>
                     <p>Indexing time is less clear-cut. Although the reduction in the amount of text to be indexed has an obvious effect, you must balance this against the cost of filtering the documents with the <code class="codeph">AUTO_FILTER</code> filter or other user-defined filters.
                     </p>
                  </div>
               </div><a id="CCAPP9277"></a><div class="props_rev_3"><a id="GUID-7ADB0B30-0E1A-4308-B941-3BEEA5DEA5E5" name="GUID-7ADB0B30-0E1A-4308-B941-3BEEA5DEA5E5"></a><h4 id="CCAPP-GUID-7ADB0B30-0E1A-4308-B941-3BEEA5DEA5E5" class="sect4"><span class="enumeration_section">10.10.5 </span>Can parallel indexing improve performance?
                  </h4>
                  <div>
                     <p><span class="bold">Answer:</span> Parallel indexing can improve index performance when you have a large amount of data and multiple CPUs.
                     </p>
                     <p>Use the <code class="codeph">PARALLEL</code> keyword to create an index with up to three separate indexing processes, depending on your resources.
                     </p><pre class="oac_no_warn" dir="ltr">CREATE INDEX index_name ON table_name (column_name) 
INDEXTYPE IS ctxsys.context PARAMETERS ('...') PARALLEL 3;
</pre><p>You can also use parallel indexing to create local partitioned indexes on partitioned tables. However, indexing performance improves only with multiple CPUs.</p>
                     <div class="infoboxnote" id="GUID-7ADB0B30-0E1A-4308-B941-3BEEA5DEA5E5__GUID-CCAE3B53-7729-4E68-8A52-9CF4D35A5954">
                        <p class="notep1">Note:</p>
                        <p>Using <code class="codeph">PARALLEL</code> to create a local partitioned index enables parallel queries. (Creating a nonpartitioned index in parallel does not turn on parallel query processing.)
                        </p>
                        <p>Parallel querying degrades query throughput especially on heavily loaded systems. Because of this, Oracle recommends that you disable parallel querying after parallel indexing. To do so, use <code class="codeph">ALTER INDEX NOPARALLEL.</code></p>
                     </div>
                  </div>
               </div><a id="CCAPP9278"></a><div class="props_rev_3"><a id="GUID-EA5B318D-9D38-4D4E-925B-8FA9CFD81561" name="GUID-EA5B318D-9D38-4D4E-925B-8FA9CFD81561"></a><h4 id="CCAPP-GUID-EA5B318D-9D38-4D4E-925B-8FA9CFD81561" class="sect4"><span class="enumeration_section">10.10.6 </span>How can I improve index performance when I create a local partitioned index?
                  </h4>
                  <div>
                     <p><span class="bold">Answer:</span> When you have multiple CPUs, you can improve indexing performance by creating a local index in parallel.
                     </p>
                     <p>You can create a local partitioned index in parallel in the following ways:</p>
                     <ul style="list-style-type: disc;">
                        <li>
                           <p>Use the <code class="codeph">PARALLEL</code> clause with the <code class="codeph">LOCAL</code> clause in the <code class="codeph">CREATE INDEX</code> statement. In this case, the maximum parallel degree is limited to the number of partitions.
                           </p>
                        </li>
                        <li>
                           <p>Create an unusable index, and then run the <code class="codeph">DBMS_PCLXUTIL.BUILD_PART_INDEX</code> utility. This method can result in a higher degree of parallelism, especially if you have more CPUs than partitions.
                           </p>
                        </li>
                     </ul>
                     <p>The following is an example of the second method. The base table has three partitions. You create a local partitioned unusable index first, and then run the <code class="codeph">DBMS_PCLUTIL.BUILD_PART_INDEX</code>, to build the three partitions in parallel (inter-partition parallelism). Inside each partition, index creation occurs in parallel (intra-partition parallelism) with a parallel degree of 2.
                     </p><pre class="oac_no_warn" dir="ltr">create index tdrbip02bx on tdrbip02b(text) 
indextype is ctxsys.context local (partition tdrbip02bx1, 
                                   partition tdrbip02bx2, 
                                   partition tdrbip02bx3) 
unusable; 

exec dbms_pclxutil.build_part_index(3,2,'TDRBIP02B','TDRBIP02BX',TRUE); </pre></div>
               </div><a id="CCAPP9279"></a><div class="props_rev_3"><a id="GUID-E89DE5BB-7C25-4901-A890-B7925506A3DF" name="GUID-E89DE5BB-7C25-4901-A890-B7925506A3DF"></a><h4 id="CCAPP-GUID-E89DE5BB-7C25-4901-A890-B7925506A3DF" class="sect4"><span class="enumeration_section">10.10.7 </span>How can I tell how much indexing has completed?
                  </h4>
                  <div>
                     <p><span class="bold">Answer:</span> You can use the <code class="codeph">CTX_OUTPUT.START_LOG</code> procedure to log output from the indexing process. The filename is normally written to <code class="codeph">$ORACLE_HOME/ctx/log,</code> but you can change the directory by using the <code class="codeph">LOG_DIRECTORY</code> parameter in <code class="codeph">CTX_ADM.SET_PARAMETER.</code></p>
                     <div class="infoboxnotealso" id="GUID-E89DE5BB-7C25-4901-A890-B7925506A3DF__GUID-45113A64-4C60-423E-B5D5-9F3753B6108B">
                        <p class="notep1">See Also:</p>
                        <p><a href="../ccref/CTX_OUTPUT-package.html#CCREF0800" target="_blank"><span class="italic">Oracle Text Reference</span></a> to learn more about the <code class="codeph">CTX_OUTPUT</code> package
                        </p>
                     </div>
                  </div>
               </div>
            </div><a id="CCAPP9280"></a><div class="props_rev_3"><a id="GUID-45D2A9BB-17BC-4B68-A3F1-A0C01B4ACDA3" name="GUID-45D2A9BB-17BC-4B68-A3F1-A0C01B4ACDA3"></a><h3 id="CCAPP-GUID-45D2A9BB-17BC-4B68-A3F1-A0C01B4ACDA3" class="sect3"><span class="enumeration_section">10.11 </span>Frequently Asked Questions About Updating the Index
               </h3>
               <div>
                  <p>This section answers some of the frequently asked questions about updating your index and related performance issues.</p>
                  <ul style="list-style-type: disc;">
                     <li>
                        <p><a href="tuning-oracle-text.html#GUID-995688F6-F94E-428E-8801-F8C9A9238E42">How often should I index new or updated records?</a></p>
                     </li>
                     <li>
                        <p><a href="tuning-oracle-text.html#GUID-BA566D03-EB35-4FE0-9786-040828D2AFC8">How can I tell when my indexes are getting fragmented?</a></p>
                     </li>
                     <li>
                        <p><a href="tuning-oracle-text.html#GUID-5F422D6F-6965-43F5-ABDF-AC449F539030">Does memory allocation affect index synchronization?</a></p>
                     </li>
                  </ul>
               </div><a id="CCAPP9281"></a><div class="props_rev_3"><a id="GUID-995688F6-F94E-428E-8801-F8C9A9238E42" name="GUID-995688F6-F94E-428E-8801-F8C9A9238E42"></a><h4 id="CCAPP-GUID-995688F6-F94E-428E-8801-F8C9A9238E42" class="sect4"><span class="enumeration_section">10.11.1 </span>How often should I index new or updated records?
                  </h4>
                  <div>
                     <p><span class="bold">Answer:</span> If you run reindexing with <code class="codeph">CTX_DDL.SYNC_INDEX</code> less often, your indexes will be less fragmented, and you will not have to optimize them as often.
                     </p>
                     <p>However, your data becomes progressively more out-of-date, and that may be unacceptable to your users. </p>
                     <p>Overnight indexing is acceptable for many systems. In this case,  data that is less than a day old is not searchable. Other systems use hourly, 10-minute, or 5-minute updates.</p>
                     <div class="infoboxnotealso" id="GUID-995688F6-F94E-428E-8801-F8C9A9238E42__GUID-DB5881A8-6AF8-4D4D-822B-093C37AFEFC8">
                        <p class="notep1">See Also:</p>
                        <p></p>
                        <ul style="list-style-type: disc;">
                           <li>
                              <p><a href="../ccref/CTX_DDL-package.html#CCREF0652" target="_blank"><span class="italic">Oracle Text Reference</span></a> to learn more about using <code class="codeph">CTX_DDL.SYNC_INDEX</code></p>
                           </li>
                           <li>
                              <p><span class="q">"<a href="maintaining-oracle-text-indexes.html#GUID-4313B6A6-510F-41E8-9B5C-3559F42742D4">Managing DML Operations for a CONTEXT Index</a>"</span></p>
                           </li>
                        </ul>
                     </div>
                  </div>
               </div><a id="CCAPP9282"></a><div class="props_rev_3"><a id="GUID-BA566D03-EB35-4FE0-9786-040828D2AFC8" name="GUID-BA566D03-EB35-4FE0-9786-040828D2AFC8"></a><h4 id="CCAPP-GUID-BA566D03-EB35-4FE0-9786-040828D2AFC8" class="sect4"><span class="enumeration_section">10.11.2 </span>How can I tell when my indexes are fragmented?
                  </h4>
                  <div>
                     <p><span class="bold">Answer:</span> The best way is to time some queries, run index optimization, and then time the same queries (restarting the database to clear the SGA each time, of course). If the queries speed up significantly, then optimization was worthwhile. If they do not, then you can wait longer next time.   
                     </p>
                     <p>You can also use <code class="codeph">CTX_REPORT.INDEX_STATS</code> to analyze index fragmentation.
                     </p>
                     <div class="infoboxnotealso" id="GUID-BA566D03-EB35-4FE0-9786-040828D2AFC8__GUID-E9A1BAE9-0FEE-4B06-9E92-00C5F7698BA1">
                        <p class="notep1">See Also:</p>
                        <p></p>
                        <ul style="list-style-type: disc;">
                           <li>
                              <p><a href="../ccref/CTX_REPORT-package.html#CCREF1100" target="_blank"><span class="italic">Oracle Text Reference</span></a> to learn more about using the <code class="codeph">CTX_REPORT</code> package
                              </p>
                           </li>
                           <li>
                              <p><span class="q">"<a href="maintaining-oracle-text-indexes.html#GUID-9960D8E4-0AE8-48B0-82D5-B203695463DE">Optimizing the Index</a>"</span></p>
                           </li>
                        </ul>
                     </div>
                  </div>
               </div><a id="CCAPP9283"></a><div class="props_rev_3"><a id="GUID-5F422D6F-6965-43F5-ABDF-AC449F539030" name="GUID-5F422D6F-6965-43F5-ABDF-AC449F539030"></a><h4 id="CCAPP-GUID-5F422D6F-6965-43F5-ABDF-AC449F539030" class="sect4"><span class="enumeration_section">10.11.3 </span>Does memory allocation affect index synchronization?
                  </h4>
                  <div>
                     <p><span class="bold">Answer:</span> Yes, the same way as for normal indexing. There are often far fewer records to be indexed during a synchronize operation, so it is not usually necessary to provide hundreds of megabytes of indexing memory. 
                     </p>
                  </div>
               </div>
            </div>
         </div>
      </article>
   </body>
</html>