<html lang="en-us" dir="ltr" xml:lang="en-us">
   <head>
      <meta http-equiv="Content-Type" content="text/html; charset=utf-8"></meta>
      <meta name="viewport" content="width=device-width, initial-scale=1"></meta>
      <meta http-equiv="X-UA-Compatible" content="IE=edge"></meta>
      <meta name="abstract" content="Oracle Text provides ways to improve your query and indexing performance."></meta>
      <meta name="description" content="Oracle Text provides ways to improve your query and indexing performance."></meta>
      <title>调整Oracle Text</title>
      <meta property="og:site_name" content="Oracle Help Center"></meta>
      <meta property="og:title" content="Application Developer&#39;s Guide "></meta>
      <meta property="og:description" content="Oracle Text provides ways to improve your query and indexing performance."></meta>
      <link rel="stylesheet" href="/sp_common/book-template/ohc-book-template/css/book.css"></link>
      <link rel="shortcut icon" href="/sp_common/book-template/ohc-common/img/favicon.ico"></link>
      <meta name="application-name" content="Application Developer&#39;s Guide"></meta>
      <meta name="generator" content="DITA Open Toolkit version 1.8.5 (Mode = doc)"></meta>
      <meta name="plugin" content="SP_docbuilder HTML plugin release 18.2.2"></meta>
      <link rel="alternate" href="text-application-developers-guide.pdf" title="PDF File" type="application/pdf"></link>
      <meta name="robots" content="all"></meta>
      <link rel="schema.dcterms" href="http://purl.org/dc/terms/"></link>
      <meta name="dcterms.created" content="2019-01-07T01:45:16-08:00"></meta>
      
      <meta name="dcterms.dateCopyrighted" content="2001, 2019"></meta>
      <meta name="dcterms.category" content="database"></meta>
      <meta name="dcterms.identifier" content="E96275-01"></meta>
      
      <meta name="dcterms.product" content="en/database/oracle/oracle-database/19"></meta>
      
      <link rel="prev" href="classifying-documents-in-oracle-text.html" title="Previous" type="text/html"></link>
      <link rel="next" href="searching-document-sections-in-oracle-text.html" title="Next" type="text/html"></link>
      <script>
        document.write('<style type="text/css">');
        document.write('body > .noscript, body > .noscript ~ * { visibility: hidden; }');
        document.write('</style>');
     </script>
      <script src="/sp_common/book-template/requirejs/require.js" data-main="/sp_common/book-template/ohc-book-template/js/book-config"></script>
      <script>
            if (window.require === undefined) {
                document.write('<script data-main="sp_common/book-template/ohc-book-template/js/book-config" src="sp_common/book-template/requirejs/require.js"><\/script>');
                document.write('<link href="sp_common/book-template/ohc-book-template/css/book.css" rel="stylesheet"/>');
            }
        </script>
      <script type="application/json" id="ssot-metadata">{"primary":{"category":{"short_name":"database","element_name":"Database","display_in_url":true},"suite":{"short_name":"oracle","element_name":"Oracle","display_in_url":true},"product_group":{"short_name":"not-applicable","element_name":"Not applicable","display_in_url":false},"product":{"short_name":"oracle-database","element_name":"Oracle Database","display_in_url":true},"release":{"short_name":"19","element_name":"Release 19","display_in_url":true}}}</script>
      
    <meta name="dcterms.title" content="Text Application Developer&#39;s Guide"></meta>
    <meta name="dcterms.isVersionOf" content="CCAPP"></meta>
    <meta name="dcterms.release" content="Release 19"></meta>
  </head>
   <body dir="ltr">
      <div class="noscript alert alert-danger text-center" role="alert">
         <a href="classifying-documents-in-oracle-text.html" class="pull-left"><span class="glyphicon glyphicon-chevron-left" aria-hidden="true"></span>上一页</a> <a href="searching-document-sections-in-oracle-text.html" class="pull-right">下一页<span class="glyphicon glyphicon-chevron-right" aria-hidden="true"></span></a> <span class="fa fa-exclamation-triangle" aria-hidden="true"></span>必须启用JavaScript才能正确显示此内容</div>
      <article>
         <header>
            <ol class="breadcrumb" vocab="http://schema.org/" typeof="BreadcrumbList">
               <li property="itemListElement" typeof="ListItem"><a href="index.html" property="item" typeof="WebPage"><span property="name">应用程序开发人员指南</span></a></li>
               <li class="active" property="itemListElement" typeof="ListItem">调整Oracle Text</li>
            </ol>
            <a id="GUID-96F4B2AC-59E5-4B02-A85B-A7B2C20C4BDF" name="GUID-96F4B2AC-59E5-4B02-A85B-A7B2C20C4BDF"></a><a id="CCAPP0500"></a>
            
            <h2 id="CCAPP-GUID-96F4B2AC-59E5-4B02-A85B-A7B2C20C4BDF" class="sect2"><span class="enumeration_chapter">10</span>调整Oracle Text</h2>
         </header>
         <div class="ind">
            <div>
               <p>Oracle Text提供了改进查询和索引性能的方法。</p>
               <p>本章包含以下主题：</p>
               <ul style="list-style-type:disc">
                  <li>
                     <p><a href="tuning-oracle-text.html#GUID-6F920664-89E8-4CF5-A974-225F51E276EF">使用统计信息优化查询</a></p>
                  </li>
                  <li>
                     <p><a href="tuning-oracle-text.html#GUID-3B8371B5-F7AC-4A94-80EE-510B7820EE6D">优化响应时间的查询</a> 
                     </p>
                  </li>
                  <li>
                     <p><a href="tuning-oracle-text.html#GUID-21432876-BCE4-4250-A67F-C6E76017B872">优化吞吐量查询</a></p>
                  </li>
                  <li>
                     <p><a href="tuning-oracle-text.html#GUID-0A82CB4D-A252-4838-ACA1-8EF10FCD9A29">Oracle Text中的复合域索引</a></p>
                  </li>
                  <li>
                     <p><a href="tuning-oracle-text.html#GUID-F315BDEC-F569-4A1C-939F-99B3B64726FA">使用CDI进行性能调整</a></p>
                  </li>
                  <li>
                     <p><a href="tuning-oracle-text.html#GUID-E282E4C7-6F64-46AB-909D-1E2F07A563CF">使用跟踪解决索引和查询瓶颈</a></p>
                  </li>
                  <li>
                     <p><a href="tuning-oracle-text.html#GUID-51F4ABF4-83A1-44EA-80FB-EF72430D3A1A">使用并行查询</a></p>
                  </li>
                  <li>
                     <p><a href="tuning-oracle-text.html#GUID-45AA18EF-710D-4A32-8A6C-3522054B10A8">使用阻止操作调整查询</a></p>
                  </li>
                  <li>
                     <p><a href="tuning-oracle-text.html#GUID-90312BBE-00D7-4200-B6AF-77CAFAA5D2F3">关于查询性能的常见问题解答</a></p>
                  </li>
                  <li>
                     <p><a href="tuning-oracle-text.html#GUID-82000645-74B9-407E-A9C0-C1ACEE319BD9">有关索引性能的常见问题解答</a></p>
                  </li>
                  <li>
                     <p><a href="tuning-oracle-text.html#GUID-45D2A9BB-17BC-4B68-A3F1-A0C01B4ACDA3">有关更新索引的常见问题解答</a></p>
                  </li>
               </ul>
            </div><a id="CCAPP9633"></a><div class="props_rev_3"><a id="GUID-6F920664-89E8-4CF5-A974-225F51E276EF" name="GUID-6F920664-89E8-4CF5-A974-225F51E276EF"></a><h3 id="CCAPP-GUID-6F920664-89E8-4CF5-A974-225F51E276EF" class="sect3"><span class="enumeration_section">10.1</span>使用统计信息优化查询</h3>
               <div>
                  <p>使用统计信息的查询优化使用收集的查询中的表和索引的统计信息来选择可以以最有效的方式处理查询的执行计划。作为一般规则，如果您有兴趣提高查询性能，Oracle建议您收集基表的统计信息。通过统计进行优化，可以更准确地估计<code class="codeph">CONTAINS</code>谓词的选择性和成本，从而实现更好的执行计划。
                  </p>
                  <p>优化程序尝试根据以下参数选择最佳执行计划：</p>
                  <ul style="list-style-type:disc">
                     <li>
                        <p>对<code class="codeph">CONTAINS</code>谓词的选择性</p>
                     </li>
                     <li>
                        <p>查询中其他谓词的选择性</p>
                     </li>
                     <li>
                        <p>处理<code class="codeph">CONTAINS</code>谓词的CPU和I / O成本</p>
                     </li>
                  </ul>
                  <p>以下主题讨论如何使用可扩展查询优化器的统计信息：</p>
                  <ul style="list-style-type:disc">
                     <li>
                        <p><a href="tuning-oracle-text.html#GUID-E4F013A8-E83C-44AF-B9A4-CA1FBF717730">收集统计数据</a></p>
                     </li>
                     <li>
                        <p><a href="tuning-oracle-text.html#GUID-A2137127-9B0D-48EE-962F-2408F49FA244">查询优化与统计示例</a></p>
                     </li>
                     <li>
                        <p><a href="tuning-oracle-text.html#GUID-763C6A28-275A-4C6F-A740-5A02F9E13575">重新收集统计数据</a></p>
                     </li>
                     <li>
                        <p><a href="tuning-oracle-text.html#GUID-225089FD-7E86-4DB0-8D37-D04213D1D053">删除统计信息</a></p>
                     </li>
                  </ul>
                  <div class="infoboxnote" id="GUID-6F920664-89E8-4CF5-A974-225F51E276EF__GUID-38AC436F-535D-4E4A-BA59-5DA54E2BC1D1">
                     <p class="notep1">注意：</p>
                     <p><code class="codeph">DBMS_STATS</code>程序包不支持导入和导出域索引（包括Oracle Text索引）的统计信息。有关导入和导出统计信息的更多信息，请参阅<a href="../arpls/DBMS_STATS.html#ARPLS059" target="_blank"><span class="italic">Oracle Database PL / SQL包和类型参考</span></a> 。
                     </p>
                  </div>
                  <div class="infoboxnotealso" id="GUID-6F920664-89E8-4CF5-A974-225F51E276EF__GUID-EE16CCEF-1071-4816-8DF6-2F23D7724EC4">
                     <p class="notep1">也可以看看：</p>
                     <p>有关<code class="codeph">CONTAINS</code>查询运算符的信息，请参阅<a href="../ccref/oracle-text-CONTAINS-query-operators.html#CCREF0300" target="_blank"><span class="italic">Oracle Text Reference</span></a></p>
                  </div>
               </div><a id="CCAPP9634"></a><div class="props_rev_3"><a id="GUID-E4F013A8-E83C-44AF-B9A4-CA1FBF717730" name="GUID-E4F013A8-E83C-44AF-B9A4-CA1FBF717730"></a><h4 id="CCAPP-GUID-E4F013A8-E83C-44AF-B9A4-CA1FBF717730" class="sect4"><span class="enumeration_section">10.1.1</span>收集统计数据</h4>
                  <div>
                     <p>默认情况下，Oracle Text使用基于开销的优化程序（CBO）来确定查询的最佳执行计划。</p>
                     <p>要使优化程序能够更好地估算成本，请计算要查询的表的统计信息：</p><pre class="oac_no_warn" dir="ltr">ANALYZE TABLE &lt;table_name&gt; COMPUTE STATISTICS;</pre><p>或者，估算表格样本的统计数据：</p><pre class="oac_no_warn" dir="ltr">ANALYZE TABLE &lt;table_name&gt; ESTIMATE STATISTICS 1000 ROWS;</pre><p>要么</p><pre class="oac_no_warn" dir="ltr">ANALYZE TABLE &lt;table_name&gt; ESTIMATE STATISTICS 50 PERCENT;</pre><p>您还可以与<code class="codeph">DBMS_STATS.GATHER_TABLE_STATS</code>过程并行收集统计信息：</p><pre class="oac_no_warn" dir="ltr">开始DBMS_STATS.GATHER_TABLE_STATS（'owner'，'table_name'，estimate_percent =&gt; 50，block_sample =&gt; TRUE，degree =&gt; 4）;结束 ;</pre><p>这些语句收集与<code class="codeph">table_name,</code>关联的所有对象的统计信息<code class="codeph">table_name,</code>包括表列和与表关联的任何索引（b-tree，bitmap或Text域）。
                     </p>
                     <p>要重新收集表的统计信息，请根据需要多次输入<code class="codeph">ANALYZE</code>语句或使用<code class="codeph">DBMS_STATS</code>包。
                     </p>
                     <p>通过收集有关Text域索引的统计信息，Oracle数据库中的CBO可以执行以下任务：</p>
                     <ul style="list-style-type:disc">
                        <li>
                           <p>估计<code class="codeph">CONTAINS</code>谓词的选择性</p>
                        </li>
                        <li>
                           <p>估计使用Oracle Text索引的I / O和CPU成本（即使用域索引处理<code class="codeph">CONTAINS</code>谓词的成本）</p>
                        </li>
                        <li>
                           <p>估计每次<code class="codeph">CONTAINS</code>调用的I / O和CPU成本</p>
                        </li>
                     </ul>
                     <p>了解<code class="codeph">CONTAINS</code>谓词的选择性对于包含多个谓词的查询很有用，例如在结构化查询中。通过这种方式，CBO可以更好地决定是使用域索引来评估<code class="codeph">CONTAINS</code>还是将<code class="codeph">CONTAINS</code>谓词应用为后置过滤器。
                     </p>
                     <div class="infoboxnotealso" id="GUID-E4F013A8-E83C-44AF-B9A4-CA1FBF717730__GUID-58EA9CED-2938-41B3-8FC7-8F7E5D6B147F">
                        <p class="notep1">也可以看看：</p>
                        <p></p>
                        <ul style="list-style-type:disc">
                           <li>
                              <p>有关<code class="codeph">ANALYZE</code>语句的更多信息，请<a href="../sqlrf/ANALYZE.html#SQLRF-GUID-535CE98E-2359-4147-839F-DCB3772C1B0E" target="_blank"><span class="italic">参见Oracle数据库SQL语言参考</span></a></p>
                           </li>
                           <li>
                              <p>有关<code class="codeph">DBMS_STATS</code>包的信息<a href="../arpls/DBMS_STATS.html#ARPLS059" target="_blank"><span class="italic">，请参见Oracle Database PL / SQL包和类型参考</span></a></p>
                           </li>
                        </ul>
                     </div>
                  </div>
               </div><a id="CCAPP9635"></a><div class="props_rev_3"><a id="GUID-A2137127-9B0D-48EE-962F-2408F49FA244" name="GUID-A2137127-9B0D-48EE-962F-2408F49FA244"></a><h4 id="CCAPP-GUID-A2137127-9B0D-48EE-962F-2408F49FA244" class="sect4"><span class="enumeration_section">10.1.2</span>使用统计信息示例的查询优化</h4>
                  <div>
                     <p>以下结构化查询提供了优化统计信息的示例：</p><pre class="oac_no_warn" dir="ltr">从tab中选择得分（1），其中包含（txt，'freedom'，1）&gt; 0和author ='King'，年份&gt; 1960;</pre><p>假设如下：</p>
                     <ul style="list-style-type:disc">
                        <li>
                           <p>作者列的类型为<code class="codeph">VARCHAR2</code> ，年份列的类型为<code class="codeph">NUMBER.</code> 
                           </p>
                        </li>
                        <li>
                           <p><code class="codeph">author</code>列上的b树索引。
                           </p>
                        </li>
                        <li>
                           <p>结构化<code class="codeph">author</code>谓词对于<code class="codeph">CONTAINS</code>谓词和<code class="codeph">year</code>谓词具有高度选择性。也就是说，结构化谓词（author ='King'）相对于<code class="codeph">year</code>和<code class="codeph">CONTAINS</code>谓词单独返回的行数要少得多，比如分别返回5行和1000行和1500行。
                           </p>
                        </li>
                     </ul>
                     <p>在这种情况下，Oracle Text可以通过首先扫描结构化谓词（author ='King'）上的b-tree索引范围，然后通过rowid访问表，然后将其他两个谓词应用于行来更有效地执行此查询从b-tree表访问返回。</p>
                     <div class="infoboxnote" id="GUID-A2137127-9B0D-48EE-962F-2408F49FA244__GUID-1B6F57EE-ED6A-42F9-89FD-172E7FD1BE09">
                        <p class="notep1">注意：</p>
                        <p>如果未收集Oracle Text索引的统计信息，则CBO会假定<code class="codeph">CONTAINS</code>谓词的选择性和索引成本较低。
                        </p>
                     </div>
                  </div>
               </div><a id="CCAPP9636"></a><div class="props_rev_3"><a id="GUID-763C6A28-275A-4C6F-A740-5A02F9E13575" name="GUID-763C6A28-275A-4C6F-A740-5A02F9E13575"></a><h4 id="CCAPP-GUID-763C6A28-275A-4C6F-A740-5A02F9E13575" class="sect4"><span class="enumeration_section">10.1.3</span>重新收集统计数据</h4>
                  <div>
                     <p>同步索引后，您可以重新收集单个索引的统计信息以更新成本估算。</p>
                     <p>如果在同步之前重新分析了基表，则在同步后分析索引就足够了，而无需重新分析整个表。</p>
                     <p>要重新收集统计信息，请输入以下语句之一：</p><pre class="oac_no_warn" dir="ltr">ANALYZE INDEX &lt;index_name&gt; COMPUTE STATISTICS;</pre><pre class="oac_no_warn" dir="ltr">ANALYZE INDEX &lt;index_name&gt;估算统计样本50％;</pre></div>
               </div><a id="CCAPP9637"></a><div class="props_rev_3"><a id="GUID-225089FD-7E86-4DB0-8D37-D04213D1D053" name="GUID-225089FD-7E86-4DB0-8D37-D04213D1D053"></a><h4 id="CCAPP-GUID-225089FD-7E86-4DB0-8D37-D04213D1D053" class="sect4"><span class="enumeration_section">10.1.4</span>删除统计信息</h4>
                  <div>
                     <p>删除与表关联的统计信息：</p><pre class="oac_no_warn" dir="ltr">ANALYZE TABLE &lt;table_name&gt; DELETE STATISTICS;</pre><p>删除一个索引的统计信息：</p><pre class="oac_no_warn" dir="ltr">ANALYZE INDEX &lt;index_name&gt; DELETE STATISTICS;</pre></div>
               </div>
            </div><a id="CCAPP9234"></a><div class="props_rev_3"><a id="GUID-3B8371B5-F7AC-4A94-80EE-510B7820EE6D" name="GUID-3B8371B5-F7AC-4A94-80EE-510B7820EE6D"></a><h3 id="CCAPP-GUID-3B8371B5-F7AC-4A94-80EE-510B7820EE6D" class="sect3"><span class="enumeration_section">10.2</span>优化响应时间的查询</h3>
               <div>
                  <p>默认情况下，Oracle Text会优化对吞吐量的查询，以便查询在尽可能短的时间内返回所有行。</p>
                  <p>但是，在许多情况下，尤其是在Web应用程序中，您必须优化查询响应时间，因为您只想在尽可能短的时间内获得潜在大型命中列表的前几次命中。</p>
                  <p>以下部分描述了优化<code class="codeph">CONTAINS</code>查询响应时间的一些方法：</p>
                  <ul style="list-style-type:disc">
                     <li>
                        <p><a href="tuning-oracle-text.html#GUID-ED7BEE09-A89F-4094-BB2E-E02B44B9DAF5">影响查询响应时间的其他因素</a></p>
                     </li>
                     <li>
                        <p><a href="tuning-oracle-text.html#GUID-169F2EB1-5E78-43E2-9FFD-1D9DFE2E1AA2">使用FIRST_ROWS改进响应时间（n）提示ORDER BY查询</a></p>
                     </li>
                     <li>
                        <p><a href="tuning-oracle-text.html#GUID-84B7D7B4-49EB-4F22-BAEA-A68904D8A013">使用DOMAIN_INDEX_SORT提示改进了响应时间</a></p>
                     </li>
                     <li>
                        <p><a href="tuning-oracle-text.html#GUID-DE0B4638-A760-47C4-8593-F68ECEBFD370">使用本地分区的CONTEXT索引改进响应时间</a></p>
                     </li>
                     <li>
                        <p><a href="tuning-oracle-text.html#GUID-4723908A-C5DD-401C-B71B-05C5F33DD52D">改进了按分数排序的本地分区索引的响应时间</a></p>
                     </li>
                     <li>
                        <p><a href="tuning-oracle-text.html#GUID-8D490B4B-9A28-4FEA-AD73-9B91CD213542">使用查询过滤器缓存改进响应时间</a></p>
                     </li>
                     <li>
                        <p><a href="tuning-oracle-text.html#GUID-9AD2AB93-2FB6-4C49-8082-046ED90F2C08">使用CONTEXT索引的BIG_IO选项改进响应时间</a></p>
                     </li>
                     <li>
                        <p><a href="tuning-oracle-text.html#GUID-8D3C30AE-D466-46C1-A281-916B7D48994C">使用CONTEXT索引的SEPARATE_OFFSETS选项改进响应时间</a></p>
                     </li>
                     <li>
                        <p><a href="tuning-oracle-text.html#GUID-54F2466B-7D05-45AC-A64E-04717F75C507">使用STEX_ITAB，STAGE_ITAB_MAX_ROWS和STAGE_ITAB_PARALLEL改进响应时间CONTEXT索引的选项</a></p>
                     </li>
                  </ul>
               </div><a id="CCAPP9235"></a><div class="props_rev_3"><a id="GUID-ED7BEE09-A89F-4094-BB2E-E02B44B9DAF5" name="GUID-ED7BEE09-A89F-4094-BB2E-E02B44B9DAF5"></a><h4 id="CCAPP-GUID-ED7BEE09-A89F-4094-BB2E-E02B44B9DAF5" class="sect4"><span class="enumeration_section">10.2.1</span>影响查询响应时间的其他因素</h4>
                  <div>
                     <p>以下因素会影响查询响应时间：</p>
                     <ul style="list-style-type:disc">
                        <li>
                           <p>表统计的集合</p>
                        </li>
                        <li>
                           <p>内存分配</p>
                        </li>
                        <li>
                           <p>排序</p>
                        </li>
                        <li>
                           <p>基表中存在大对象（LOB）列</p>
                        </li>
                        <li>
                           <p>分区</p>
                        </li>
                        <li>
                           <p>排比</p>
                        </li>
                        <li>
                           <p>查询中的术语扩展数</p>
                           <div class="infoboxnotealso" id="GUID-ED7BEE09-A89F-4094-BB2E-E02B44B9DAF5__GUID-C047BD97-E42F-4D4E-B5BF-1A4BB689F0F1">
                              <p class="notep1">也可以看看：</p>
                              <p><span class="q">“ <a href="tuning-oracle-text.html#GUID-90312BBE-00D7-4200-B6AF-77CAFAA5D2F3">关于查询性能的常见问题解答</a> ”</span></p>
                           </div>
                        </li>
                     </ul>
                  </div>
               </div><a id="CCAPP9236"></a><div class="props_rev_3"><a id="GUID-169F2EB1-5E78-43E2-9FFD-1D9DFE2E1AA2" name="GUID-169F2EB1-5E78-43E2-9FFD-1D9DFE2E1AA2"></a><h4 id="CCAPP-GUID-169F2EB1-5E78-43E2-9FFD-1D9DFE2E1AA2" class="sect4"><span class="enumeration_section">10.2.2</span>使用FIRDER_ROWS（n）提示修改ORDER BY查询的响应时间</h4>
                  <div>
                     <p>当您需要<code class="codeph">ORDER BY</code>查询的第一行时，Oracle建议您使用基于成本的<code class="codeph">FIRST_ROWS(n)</code>提示。
                     </p>
                     <div class="infoboxnote" id="GUID-169F2EB1-5E78-43E2-9FFD-1D9DFE2E1AA2__GUID-739F64F7-3668-4882-B311-FEE094A854F5">
                        <p class="notep1">注意：</p>
                        <p>由于<code class="codeph">FIRST_ROWS(n)</code>提示是基于成本的，因此Oracle建议您在使用此提示之前收集有关表的统计信息。
                        </p>
                     </div>
                     <p>如果您希望在最短的时间内获得前<span class="italic">n</span>行，则使用<code class="codeph">FIRST_ROWS(n)</code>提示。例如，考虑以下PL / SQL块，它使用游标检索查询的前10个命中，并使用<code class="codeph">FIRST_ROWS(n)</code>提示来优化响应时间：</p><pre class="oac_no_warn" dir="ltr">声明光标c是从articles_tab中选择/ * + FIRST_ROWS（10）* / article_id，其中包含（article，'Omophagia'）&gt; 0 order by pub_date desc;开始</pre><pre class="oac_no_warn" dir="ltr">for c in c loop insert into t_s values（i.pk，i.col）;当c％rowcount&gt; 11时退出;结束循环;</pre><pre class="oac_no_warn" dir="ltr">结束; /</pre><p><code class="codeph">c</code> cursor是一个<code class="codeph">SELECT</code>语句， <span class="italic">它</span>以排序顺序返回包含单词<span class="italic">omophagia</span>的rowid。代码循环通过游标以提取前10行。这些行存储在临时<code class="codeph">t_s</code>表中。
                     </p>
                     <p>使用<code class="codeph">FIRST_ROWS(n)</code>提示，当返回前N个命中的成本较低时，优化器指示Oracle Text索引以分数排序顺序返回rowid。
                     </p>
                     <p>在没有提示的情况下，Oracle数据库会在Oracle Text索引返回满足<code class="codeph">CONTAINS</code>谓词的未排序顺序的<span class="italic">所有</span>行之后对rowid进行排序。检索整个结果集需要时间。
                     </p>
                     <p>因为此查询中只需要前10个匹配，所以使用提示可以获得更好的性能。</p>
                     <div class="infoboxnote" id="GUID-169F2EB1-5E78-43E2-9FFD-1D9DFE2E1AA2__GUID-3E358C4E-6E9E-4043-92F4-9C6D089D77BB">
                        <p class="notep1">注意：</p>
                        <p>当您只需要查询的前几个匹配时，请使用<code class="codeph">FIRST_ROWS(n)</code>提示。当您需要整个结果集时，请不要使用此提示，因为它可能会导致性能不佳。
                        </p>
                     </div>
                  </div>
               </div><a id="CCAPP9237"></a><div class="props_rev_3"><a id="GUID-84B7D7B4-49EB-4F22-BAEA-A68904D8A013" name="GUID-84B7D7B4-49EB-4F22-BAEA-A68904D8A013"></a><h4 id="CCAPP-GUID-84B7D7B4-49EB-4F22-BAEA-A68904D8A013" class="sect4"><span class="enumeration_section">10.2.3</span>使用DOMAIN_INDEX_SORT提示改进响应时间</h4>
                  <div>
                     <p>您还可以使用相关的<code class="codeph">DOMAIN_INDEX_SORT</code>提示来优化响应时间。与<code class="codeph">FIRST_ROWS(n),</code>当针对响应时间优化查询时，Oracle Text会在尽可能短的时间内返回第一行。
                     </p>
                     <p>例如，您可以使用此提示：</p><pre class="oac_no_warn" dir="ltr">选择/ * + DOMAIN_INDEX_SORT * / pk，得分（1），col来自ctx_tab，其中包含（txt_col，'test'，1）&gt; 0 order by score（1）desc;</pre><p>但是，此提示仅基于规则。这意味着Oracle Text始终选择满足<code class="codeph">ORDER BY</code>子句的索引。对于<code class="codeph">CONTAINS</code>子句非常有选择性的查询，此提示可能会导致性能欠佳。在这些情况下，Oracle建议您使用<code class="codeph">FIRST_ROWS(n)</code>提示，该提示完全基于成本。
                     </p>
                  </div>
               </div><a id="CCAPP9238"></a><div class="props_rev_3"><a id="GUID-DE0B4638-A760-47C4-8593-F68ECEBFD370" name="GUID-DE0B4638-A760-47C4-8593-F68ECEBFD370"></a><h4 id="CCAPP-GUID-DE0B4638-A760-47C4-8593-F68ECEBFD370" class="sect4"><span class="enumeration_section">10.2.4</span>使用本地分区的CONTEXT索引改进响应时间</h4>
                  <div>
                     <p>对数据进行分区并创建本地分区索引可以提高查询性能。在分区表上，每个分区都有自己的一组索引表。实际上，有多个索引，但结果会根据需要进行组合以生成最终结果集。</p>
                     <p>使用<code class="codeph">LOCAL</code>关键字创建<code class="codeph">CONTEXT</code>索引：</p><pre class="oac_no_warn" dir="ltr">CREATE INDEX index_name ON table_name（column_name）INDEXTYPE IS ctxsys.context PARAMETERS（'...'）LOCAL</pre><p>使用分区表和索引，可以提高以下类型查询的性能：</p>
                     <ul style="list-style-type:disc">
                        <li>
                           <p><span class="bold">分区键列上的范围搜索：</span>此查询将搜索限制为也是分区键的列上的特定值范围。例如，考虑对日期范围的查询：</p><pre class="oac_no_warn" dir="ltr">SELECT storyid FROM storytab WHERE CONTAINS（story，'oliver'）&gt; 0和pub_date BETWEEN'1-OCT-93'AND'1-NOV-93';</pre><p>如果日期范围非常严格，则很可能只通过查看单个分区来满足查询。</p>
                        </li>
                        <li>
                           <p><span class="bold">ORDER BY分区键列：</span>此查询仅需要前<code class="codeph">n</code>命中， <code class="codeph">ORDER BY</code>子句命名分区键。考虑<code class="codeph">price</code>列上的<code class="codeph">ORDER BY</code>查询以获取前20个点击：</p><pre class="oac_no_warn" dir="ltr">SELECT * FROM（</pre><pre class="oac_no_warn" dir="ltr">SELECT itemid FROM item_tab WHERE CONTAINS（item_desc，'cd player'）&gt; 0 ORDER BY price）WHERE ROWNUM &lt;20;</pre><p>在此示例中，对于按价格分区的表，查询可能只需要从第一个分区获取命中以满足查询。</p>
                        </li>
                     </ul>
                  </div>
               </div><a id="CCAPP9241"></a><div class="props_rev_3"><a id="GUID-4723908A-C5DD-401C-B71B-05C5F33DD52D" name="GUID-4723908A-C5DD-401C-B71B-05C5F33DD52D"></a><h4 id="CCAPP-GUID-4723908A-C5DD-401C-B71B-05C5F33DD52D" class="sect4"><span class="enumeration_section">10.2.5</span>改进了按分数<span class="enumeration_section">排序</span>的本地分区索引的响应时间</h4>
                  <div>
                     <p>对本地分区索引的<code class="codeph">DOMAIN_INDEX_SORT</code>提示可能会导致性能不佳，尤其是在按分数排序时。必须先获取所有分区中查询的所有命中，然后才能对结果进行排序。
                     </p>
                     <p>而是在使用<code class="codeph">DOMAIN_INDEX_SORT</code>提示时使用内联视图。具体来说，在以下条件下使用<code class="codeph">DOMAIN_INDEX_SORT</code>提示来提高本地分区索引的查询性能：</p>
                     <ul style="list-style-type:disc">
                        <li>
                           <p>Oracle Text查询本身（包括<code class="codeph">SCORE</code> （）子句的顺序）表示为内嵌视图。
                           </p>
                        </li>
                        <li>
                           <p>内联视图中的Oracle Text查询包含<code class="codeph">DOMAIN_INDEX_SORT</code>提示。
                           </p>
                        </li>
                        <li>
                           <p>内联视图上的查询具有<code class="codeph">ROWNUM</code>谓词，该谓词限制从视图中获取的行数。
                           </p>
                        </li>
                     </ul>
                     <p>例如，在分区的<code class="codeph">doc_tab</code>表上创建以下Oracle Text查询和本地Oracle Text索引：</p><pre class="oac_no_warn" dir="ltr">选择doc_id，得分（1）来自doc_tab，其中包含（doc，'oracle'，1）&gt; 0 order by score（1）desc;</pre><p>如果您只想获取前20行，则可以按如下方式重写查询：</p><pre class="oac_no_warn" dir="ltr">select * from（select / * + DOMAIN_INDEX_SORT * / doc_id，得分（1）来自doc_tab，其中包含（doc，'oracle'，1）&gt; 0 order by score（1）desc）其中rownum &lt;21;</pre><div class="infoboxnotealso" id="GUID-4723908A-C5DD-401C-B71B-05C5F33DD52D__GUID-AA5F204B-8CE7-43D3-9DD9-EB184DF03B3B">
                        <p class="notep1">也可以看看：</p>
                        <p>有关<code class="codeph">EXPLAIN PLAN</code>语句的更多信息，请<a href="../sqlrf/EXPLAIN-PLAN.html#SQLRF-GUID-FD540872-4ED3-4936-96A2-362539931BA0" target="_blank"><span class="italic">参见Oracle数据库SQL语言参考</span></a></p>
                     </div>
                  </div>
               </div><a id="CCAPP9551"></a><div class="props_rev_3"><a id="GUID-8D490B4B-9A28-4FEA-AD73-9B91CD213542" name="GUID-8D490B4B-9A28-4FEA-AD73-9B91CD213542"></a><h4 id="CCAPP-GUID-8D490B4B-9A28-4FEA-AD73-9B91CD213542" class="sect4"><span class="enumeration_section">10.2.6</span>使用查询过滤器缓存改进响应时间</h4>
                  <div>
                     <p>Oracle Text提供了一个称为查询过滤器缓存的缓存层，可用于缓存查询结果。查询过滤器缓存可跨查询共享。多个查询可以重用缓存的查询结果来改善查询响应时间。</p>
                     <p>使用<a id="d24571e1395" class="indexterm-anchor"></a> <code class="codeph">ctxfiltercache</code>运算符指定要缓存的查询结果。以下示例使用运算符将<code class="codeph">common_predicate</code>查询的结果存储在缓存中：</p><pre class="oac_no_warn" dir="ltr">select * from docs where contains（txt，'ctxfiltercache（（common_predicate），FALSE）'）&gt; 0;</pre><p>在这个例子中，的缓存结果<code class="codeph">common_predicate</code>查询被重用<code class="codeph">new_query</code>查询，来提高查询响应时间。
                     </p><pre class="oac_no_warn" dir="ltr">select * from docs where contains（txt，'new_query＆ctxfiltercache（（common_predicate），FALSE）'）&gt; 0;</pre><div class="infoboxnote" id="GUID-8D490B4B-9A28-4FEA-AD73-9B91CD213542__GUID-4A36AC7B-6A33-411A-80A2-4B368A6AB791">
                        <p class="notep1">注意：</p>
                        <p></p>
                        <ul style="list-style-type:disc">
                           <li>
                              <p>您可以使用basic指定查询过滤器缓存的大小<a id="d24571e1421" class="indexterm-anchor"></a> <code class="codeph">query_filter_cache_size</code>存储属性。
                              </p>
                           </li>
                           <li>
                              <p>该<a id="d24571e1429" class="indexterm-anchor"></a> <code class="codeph">ctx_filter_cache_statistics</code>视图提供有关查询过滤器缓存的各种统计信息。
                              </p>
                           </li>
                        </ul>
                     </div>
                     <div class="infoboxnotealso" id="GUID-8D490B4B-9A28-4FEA-AD73-9B91CD213542__GUID-799CFE6F-3E8A-499D-B86A-DBF9E50A3145">
                        <p class="notep1">也可以看看：</p>
                        <p><a href="../ccref/oracle-text-indexing-elements.html#CCREF0245" target="_blank"><span class="italic">Oracle Text Reference</span></a>有关的更多信息：</p>
                        <ul style="list-style-type:disc">
                           <li>
                              <p><code class="codeph">ctxfiltercache</code>运算符</p>
                           </li>
                           <li>
                              <p><code class="codeph">query_filter_cache_size</code>基本存储属性</p>
                           </li>
                           <li>
                              <p><code class="codeph">ctx_filter_cache_statistics</code>视图</p>
                           </li>
                        </ul>
                     </div>
                  </div>
               </div><a id="CCAPP9552"></a><div class="props_rev_3"><a id="GUID-9AD2AB93-2FB6-4C49-8082-046ED90F2C08" name="GUID-9AD2AB93-2FB6-4C49-8082-046ED90F2C08"></a><h4 id="CCAPP-GUID-9AD2AB93-2FB6-4C49-8082-046ED90F2C08" class="sect4"><span class="enumeration_section">10.2.7</span>使用CONTEXT索引的BIG_IO选项改进响应时间</h4>
                  <div>
                     <p>Oracle Text提供了<a id="d24571e1521" class="indexterm-anchor"></a> <code class="codeph">BIG_IO</code>选项，用于提高广泛使用IO操作的<code class="codeph">CONTEXT</code>索引的查询性能。查询性能改进主要用于存储在旋转磁盘上的数据，而不是存储在固态磁盘上的数据。
                     </p>
                     <p>启用<code class="codeph">BIG_IO</code>选项时， <code class="codeph">CONTEXT</code>索引会为每个唯一标记文本创建一个具有一个大对象（LOB）数据类型的标记类型对。具有相同文本但不同标记类型的标记对应于<code class="codeph">$I</code>表中的不同行。
                     </p>
                     <p>启用了<code class="codeph">BIG_IO</code>选项的索引应该将令牌LOB创建为SecureFile LOB，以便将数据按顺序存储在多个块中。此方法可以改善查询的响应时间，因为查询现在可以执行更长的顺序读取而不是许多短读取。
                     </p>
                     <div class="infoboxnote" id="GUID-9AD2AB93-2FB6-4C49-8082-046ED90F2C08__GUID-7367A842-89FE-406B-8C89-5BF5553CCE01">
                        <p class="notep1">注意：</p>
                        <p>如果使用SecureFiles，则必须将<code class="codeph">COMPATIBLE</code>设置为11.0或更高。此外，您必须在自动段空间管理（ASSM）表空间上创建LOB。将现有Oracle Text索引迁移到SecureFiles时，请使用ASSM表空间。要帮助将现有索引迁移到SecureFiles，可以扩展<code class="codeph">ALTER INDEX REBUILD</code>以提供仅影响$ I表的存储首选项。
                        </p>
                     </div>
                     <p>要使用<code class="codeph">BIG_IO</code>索引选项创建<code class="codeph">CONTEXT</code>索引，首先通过将其<code class="codeph">BIG_IO</code>存储属性的值设置为<code class="codeph">YES,</code>来创建基本存储首选项<code class="codeph">YES,</code>然后在创建<code class="codeph">CONTEXT</code>索引时指定此存储首选项。
                     </p>
                     <p>以下示例创建基本<code class="codeph">mystore</code>存储首选项，并将其<code class="codeph">BIG_IO</code>存储属性的值设置为<code class="codeph">YES:</code></p><pre class="oac_no_warn" dir="ltr">exec ctx_ddl.create_preference（'mystore'，'BASIC_STORAGE'）; exec ctx_ddl.set_attribute（'mystore'，'BIG_IO'，'YES'）;</pre><p>要禁用<code class="codeph">BIG_IO</code>选项，请通过将其<code class="codeph">BIG_IO</code>存储属性的值设置为<code class="codeph">NO,</code>来更新现有存储首选项（ <code class="codeph">mystore</code> ） <code class="codeph">NO,</code>然后重建索引。
                     </p><pre class="oac_no_warn" dir="ltr">exec ctx_ddl.set_attribute（'mystore'，'BIG_IO'，'NO'）; alter index idx rebuild（'replace storage mystore'）;</pre><div class="infoboxnotewarn" id="GUID-9AD2AB93-2FB6-4C49-8082-046ED90F2C08__GUID-3601FAF1-231E-443D-86B0-1A2FBA23C585">
                        <p class="notep1">警告：</p>
                        <p>请勿使用替换元数据操作来禁用<code class="codeph">BIG_IO</code>索引选项。它可以使索引处于不一致状态。
                        </p>
                     </div>
                     <p>要在不重建索引的情况下为分区索引启用<code class="codeph">BIG_IO</code>选项，请通过将其<code class="codeph">BIG_IO</code>存储属性的值设置为<code class="codeph">YES,</code>来修改基本存储首选项，使用<code class="codeph">ctx_ddl.replace_index_metadata,</code>替换全局索引元数据<code class="codeph">ctx_ddl.replace_index_metadata,</code>然后在<code class="codeph">REBUILD</code>模式下为每个<code class="codeph">ctx_ddl.replace_index_metadata,</code>调用<code class="codeph">optimize_index</code>分区索引表的分区。
                     </p>
                     <p>以下示例为<code class="codeph">idx</code>分区索引启用<code class="codeph">BIG_IO</code>选项：</p><pre class="oac_no_warn" dir="ltr">exec ctx_ddl.set_attribute（'mystore'，'BIG_IO'，'YES'）; exec ctx_ddl.replace_index_metadata（'idx'，'replace storage mystore'）; exec ctx_ddl.optimize_index（'idx'，'rebuild'，part_name =&gt;'part1'）;</pre><div class="infoboxnote" id="GUID-9AD2AB93-2FB6-4C49-8082-046ED90F2C08__GUID-D93129AE-B590-419D-8725-EBC75474D978">
                        <p class="notep1">注意：</p>
                        <p>如果过程仅在启用<code class="codeph">BIG_IO</code>选项的情况下修改现有索引表，则不会导致重新索引数据。
                        </p>
                     </div>
                     <div class="infoboxnote" id="GUID-9AD2AB93-2FB6-4C49-8082-046ED90F2C08__GUID-87E28EC3-6C71-4BD2-B6DF-2D2A88CBEB45">
                        <p class="notep1">注意：</p>
                        <p>由于<code class="codeph">BIG_IO</code>索引选项执行较长的顺序读取，因此使用<code class="codeph">BIG_IO</code>索引选项的查询需要大型程序全局区域（PGA）内存。
                        </p>
                     </div>
                  </div>
               </div><a id="CCAPP9553"></a><div class="props_rev_3"><a id="GUID-8D3C30AE-D466-46C1-A281-916B7D48994C" name="GUID-8D3C30AE-D466-46C1-A281-916B7D48994C"></a><h4 id="CCAPP-GUID-8D3C30AE-D466-46C1-A281-916B7D48994C" class="sect4"><span class="enumeration_section">10.2.8</span>使用CONTEXT索引的SEPARATE_OFFSETS选项改进响应时间</h4>
                  <div>
                     <p>Oracle Text提供了<a id="d24571e1716" class="indexterm-anchor"></a> <code class="codeph">SEPARATE_OFFSETS</code>选项用于提高使用IO操作的<code class="codeph">CONTEXT</code>索引的查询性能，其查询主要是单字或布尔查询。
                     </p>
                     <p><code class="codeph">SEPARATE_OFFSETS</code>选项为<code class="codeph">TEXT.</code>类型的标记创建不同的过帐列表结构<code class="codeph">TEXT.</code> <code class="codeph">SEPARATE_OFFSETS</code>选项不是在发布列表中散布docids，频率，信息长度（偏移信息的长度）和偏移，而是在发布列表的开头存储所有docids和频率，以及所有信息长度和偏移量。发布列表的结尾。发布开头的标题包含有关docids和偏移之间的边界点的信息。由于docids和offsets的分离减少了查询读取数据的时间，因此可以缩短查询响应时间。
                     </p>
                     <p>当您将其与<code class="codeph">BIG_IO</code>选项一起使用以及具有非常长的发布的令牌时，最好实现<code class="codeph">SEPARATE_OFFSETS</code>选项的性能。
                     </p>
                     <p>要使用<code class="codeph">SEPARATE_OFFSETS</code>选项创建<code class="codeph">CONTEXT</code>索引，请首先通过将其<code class="codeph">SEPARATE_OFFSETS</code>存储属性的值设置为<code class="codeph">T.</code>来创建基本存储首选项<code class="codeph">T.</code>接下来，在创建<code class="codeph">CONTEXT</code>索引时指定此存储首选项。
                     </p>
                     <p>以下示例创建基本<code class="codeph">mystore</code>存储首选项，并将其<code class="codeph">SEPARATE_OFFSETS</code>存储属性的值设置为<code class="codeph">T:</code></p><pre class="oac_no_warn" dir="ltr">exec ctx_ddl.create_preference（'mystore'，'BASIC_STORAGE'）; exec ctx_ddl.set_attribute（'mystore'，'SEPARATE_OFFSETS'，'T'）;</pre><p>要禁用<code class="codeph">SEPARATE_OFFSETS</code>选项，请通过将其<code class="codeph">SEPARATE_OFFSETS</code>存储属性的值设置为<code class="codeph">F,</code>来更新现有存储首选项（ <code class="codeph">mystore</code> ） <code class="codeph">F,</code>然后重建索引。
                     </p><pre class="oac_no_warn" dir="ltr">exec ctx_ddl.set_attribute（'mystore'，'SEPARATE_OFFSETS'，'F'）; alter index idx rebuild（'replace storage mystore'）;</pre><div class="infoboxnotewarn" id="GUID-8D3C30AE-D466-46C1-A281-916B7D48994C__GUID-A8158A06-5648-4AD9-BEA0-2321746BD819">
                        <p class="notep1">警告：</p>
                        <p>不要使用替换元数据操作来禁用<code class="codeph">SEPARATE_OFFSETS</code>索引选项，因为它可能使索引处于不一致状态。
                        </p>
                     </div>
                     <p>要为分区索引启用<code class="codeph">SEPARATE_OFFSETS</code>选项而不重建索引，请通过将其<code class="codeph">SEPARATE_OFFSETS</code>存储属性的值设置为<code class="codeph">T,</code>来修改基本存储首选项，使用<code class="codeph">ctx_ddl.replace_index_metadata,</code>替换全局索引元数据<code class="codeph">ctx_ddl.replace_index_metadata,</code>然后在REBUILD模式下调用<code class="codeph">optimize_index</code>分区索引表中的每个分区。
                     </p>
                     <p>以下示例为分区的<code class="codeph">idx</code>索引启用<code class="codeph">SEPARATE_OFFSETS</code>选项：</p><pre class="oac_no_warn" dir="ltr">exec ctx_ddl.set_attribute（'mystore'，'SEPARATE_OFFSETS'，'T'）; exec ctx_ddl.replace_index_metadata（'idx'，'replace storage mystore'）; exec ctx_ddl.optimize_index（'idx'，'rebuild'，part_name =&gt;'part1'）;</pre><div class="infoboxnote" id="GUID-8D3C30AE-D466-46C1-A281-916B7D48994C__GUID-A378A48E-AC57-4955-89BE-3CE72B574A28">
                        <p class="notep1">注意：</p>
                        <p>如果过程仅在启用了<code class="codeph">SEPARATE_OFFSETS</code>选项的情况下修改现有索引表，则不会重新索引数据。
                        </p>
                     </div>
                  </div>
               </div><a id="CCAPP9554"></a><div class="props_rev_3"><a id="GUID-54F2466B-7D05-45AC-A64E-04717F75C507" name="GUID-54F2466B-7D05-45AC-A64E-04717F75C507"></a><h4 id="CCAPP-GUID-54F2466B-7D05-45AC-A64E-04717F75C507" class="sect4"><span class="enumeration_section">10.2.9</span>使用STEX_ITAB，STAGE_ITAB_MAX_ROWS和STAGE_ITAB_PARALLEL语境索引选项改进响应时间</h4>
                  <div>
                     <p>Oracle Text提供了<a id="d24571e1893" class="indexterm-anchor"></a> <code class="codeph">STAGE_ITAB</code>选项，用于提高<code class="codeph">CONTEXT</code>索引的查询性能，该索引广泛使用插入，更新和删除操作进行近实时索引。
                     </p>
                     <p>如果不使用<code class="codeph">STAGE_ITAB</code>索引选项，则在将新文档添加到<code class="codeph">CONTEXT</code>索引时，将调用<code class="codeph">SYNC_INDEX</code>以使文档可搜索。这个调用在创建新行<code class="codeph">$I</code>表，并增加了碎裂<code class="codeph">$I</code>表。结果是查询性能下降。
                     </p>
                     <p>启用<code class="codeph">STAGE_ITAB</code>索引选项时，会发生以下情况：</p>
                     <ul style="list-style-type:disc">
                        <li>
                           <p>有关新文档的信息存储在<code class="codeph">$G</code> staging表中，而不是<code class="codeph">$I</code>表中。此存储可确保<code class="codeph">$I</code>表不会碎片化，并且不会降低查询性能。
                           </p>
                        </li>
                        <li>
                           <p><code class="codeph">$H</code> b-tree索引在<code class="codeph">$G</code>表上创建。<code class="codeph">$G</code>表和<code class="codeph">$H</code> b-tree索引等价于<code class="codeph">$I</code>表和<code class="codeph">$X</code> b-tree索引。
                           </p>
                        </li>
                     </ul>
                     <p>使用<code class="codeph">MERGE</code>优化模式优化<code class="codeph">$G</code>表中的行并将它们移动到<code class="codeph">$I</code>表。
                     </p>
                     <div class="infoboxnote" id="GUID-54F2466B-7D05-45AC-A64E-04717F75C507__GUID-A43D5EC1-197B-483D-92D8-1F39FECCAEE9">
                        <p class="notep1">注意：</p>
                        <p><code class="codeph">$G</code>表存储在<code class="codeph">KEEP</code>池中。要提高查询性能，应使用新的<code class="codeph">stage_itab_max_rows</code>选项分配足够的<code class="codeph">KEEP</code>池内存并维护足够大的<code class="codeph">$G</code>表大小。
                        </p>
                     </div>
                     <p>要使用<code class="codeph">STAGE_ITAB</code>索引选项创建<code class="codeph">CONTEXT</code>索引，请首先通过将其<code class="codeph">STAGE_ITAB</code>存储属性的值设置为<code class="codeph">YES.</code>来创建基本存储首选项<code class="codeph">YES.</code>接下来，在创建<code class="codeph">CONTEXT</code>索引时指定此存储首选项。
                     </p>
                     <p>以下示例创建基本<code class="codeph">mystore</code>存储首选项，并将其<code class="codeph">STAGE_ITAB</code>存储属性的值设置为<code class="codeph">YES:</code></p><pre class="oac_no_warn" dir="ltr">exec ctx_ddl.create_preference（'mystore'，'BASIC_STORAGE'）; exec ctx_ddl.set_attribute（'mystore'，'STAGE_ITAB'，'YES'）;</pre><p>您还可以使用<code class="codeph">ALTER INDEX</code>语句的rebuild选项为现有的非分区<code class="codeph">CONTEXT</code>索引启用<code class="codeph">STAGE_ITAB</code>索引选项。
                     </p><pre class="oac_no_warn" dir="ltr">alter index IDX rebuild parameters（'replace storage mystore'）;</pre><p>要为未分区的<code class="codeph">CONTEXT</code>索引禁用<code class="codeph">STAGE_ITAB</code>选项，请通过将其<code class="codeph">STAGE_ITAB</code>存储属性的值设置为<code class="codeph">NO,</code>来更新现有存储首选项（ <code class="codeph">mystore</code> ） <code class="codeph">NO,</code>然后重建索引。
                     </p><pre class="oac_no_warn" dir="ltr">exec ctx_ddl.set_attribute（'mystore'，'STAGE_ITAB'，'NO'）; alter index idx rebuild（'replace storage mystore'）;</pre><p>此操作使用<code class="codeph">MERGE</code>优化模式运行优化过程，然后删除<code class="codeph">$G</code>表。
                     </p>
                     <p><code class="codeph">ALTER INDEX</code>语句的rebuild选项不适用于分区的<code class="codeph">CONTEXT</code>索引，用于启用和禁用<code class="codeph">STAGE_ITAB</code>选项。
                     </p>
                     <p>以下示例为分区的<code class="codeph">CONTEXT</code> <code class="codeph">idx</code>索引启用<code class="codeph">STAGE_ITAB</code>选项：</p><pre class="oac_no_warn" dir="ltr">alter index idx参数（'add stage_itab'）;</pre><p>以下示例禁用分区的<code class="codeph">CONTEXT</code> <code class="codeph">idx</code>索引的<code class="codeph">STAGE_ITAB</code>选项：</p><pre class="oac_no_warn" dir="ltr">alter index idx parameters（'remove stage_itab'）;</pre><p>从Oracle Database 12 <span class="italic">c</span>第2版（12.2）开始，当<code class="codeph">$G</code>超过100万行时， <code class="codeph">$G</code>的内容在索引同步期间自动移动到<code class="codeph">$I</code>此值由<code class="codeph">STORAGE</code>首选项的<code class="codeph">STAGE_ITAB_MAX_ROWS</code>属性控制。
                     </p>
                     <div class="infoboxnote" id="GUID-54F2466B-7D05-45AC-A64E-04717F75C507__GUID-9EDDF5DD-8229-4CB2-9AD8-989E1373FFC7">
                        <p class="notep1">注意：</p>
                        <p>如果偶尔的索引同步需要很长时间，您可以通过使用<code class="codeph">STORAGE</code>首选项的<code class="codeph">STAGE_ITAB_PARALLEL</code>属性来减小<code class="codeph">STAGE_ITAB_MAX_ROWS</code>参数的值或增加并行度。如果将<code class="codeph">STAGE_ITAB_MAX_ROWS</code>的值设置为非常小的值，则<code class="codeph">$G</code>的内容将频繁移至<code class="codeph">$I</code>因此，不要将其设置为非常低的值。
                        </p>
                     </div>
                     <div class="infoboxnote" id="GUID-54F2466B-7D05-45AC-A64E-04717F75C507__GUID-B7A48630-33B2-4C24-A338-7CBF6A4C937D">
                        <p class="notep1">注意：</p>
                        <p>要对<code class="codeph">CONTEXT</code>索引使用<code class="codeph">STAGE_ITAB</code>索引选项，必须指定<code class="codeph">g_index_clause</code>和<code class="codeph">g_table_clause</code> <code class="codeph">BASIC_STORAGE</code>首选项。
                        </p>
                     </div>
                     <p>当<code class="codeph">$G</code>表格过于分散时，查询性能会下降。为了避免恶化，从Oracle Database Release 18c开始，Oracle Text为每个索引或分区提供自动后台优化合并。要启用自动后台优化合并，必须将<code class="codeph">STAGE_ITAB</code>和<code class="codeph">STAGE_ITAB_AUTO_OPT</code>存储首选项属性设置为<code class="codeph">TRUE,</code>并且必须使用存储首选项创建索引。
                     </p>
                     <p>默认情况下，如果在升级到Oracle Database Release 18c之前已在索引中启用了<code class="codeph">STAGE_ITAB</code> ，则不会启用<code class="codeph">STAGE_ITAB_AUTO_OPT</code> 。如果<code class="codeph">STAGE_ITAB</code>和<code class="codeph">AUTO_OPTIMIZE</code>在现有的索引被启用，则必须禁用<code class="codeph">AUTO_OPTIMIZE</code>启用前<code class="codeph">STAGE_ITAB_AUTO_OPT.</code></p>
                     <p>以下示例创建基本<code class="codeph">mystore</code>存储首选项，并将其<code class="codeph">STAGE_ITAB_AUTO_OPT</code>存储属性的值设置为<code class="codeph">TRUE:</code></p><pre class="pre codeblock"><code>exec ctx_ddl.create_preference（'mystore'，'basic_storage'）; exec ctx_ddl.set_attribute（'mystore'，'stage_itab'，'TRUE'）; exec ctx_ddl.set_attribute（'mystore'，'stage_itab_auto_opt'，'TRUE'）; exec ctx_ddl.set_attribute（'mystore'，'stage_itab_parallel'，16）;</code></pre><div class="infoboxnotealso" id="GUID-54F2466B-7D05-45AC-A64E-04717F75C507__GUID-96B52DC7-B82F-4977-8C3E-01DDFCD7DF62">
                        <p class="notep1">也可以看看：</p>
                        <p>有关<code class="codeph">BASIC_STORAGE</code>更多信息，请<code class="codeph">BASIC_STORAGE</code> <a href="../ccref/CTX_OUTPUT-package.html#CCREF0800" target="_blank"><span class="italic">Oracle Text Reference</span></a></p>
                     </div>
                  </div>
               </div>
            </div><a id="CCAPP9242"></a><div class="props_rev_3"><a id="GUID-21432876-BCE4-4250-A67F-C6E76017B872" name="GUID-21432876-BCE4-4250-A67F-C6E76017B872"></a><h3 id="CCAPP-GUID-21432876-BCE4-4250-A67F-C6E76017B872" class="sect3"><span class="enumeration_section">10.3</span>优化吞吐量查询</h3>
               <div>
                  <p>优化吞吐量查询时，默认行为会在尽可能短的时间内返回所有匹配。</p>
                  <p>以下是如何显式优化吞吐量查询：</p>
                  <ul style="list-style-type:disc">
                     <li>
                        <p><span class="bold">选择和所有行模式：</span>默认情况下，您使用<code class="codeph">CHOOSE</code>和<code class="codeph">ALL_ROWS</code>模式优化查询。Oracle Text在尽可能短的时间内返回<span class="italic">所有</span>行。
                        </p>
                     </li>
                     <li>
                        <p><span class="bold">FIRST_ROWS（n）模式：</span>在<code class="codeph">FIRST_ROWS(n)</code>模式下，Oracle数据库中的优化器通过让Text域索引返回分数排序行（如果可能）来优化快速响应时间。这是使用<code class="codeph">FIRST_ROWS(n)</code>提示时的默认行为。
                        </p>
                        <p>如果要使用<code class="codeph">FIRST_ROWS(n),</code>优化吞吐量<code class="codeph">FIRST_ROWS(n),</code>使用<code class="codeph">DOMAIN_INDEX_NO_SORT</code>提示。更高的吞吐量意味着您有兴趣在尽可能短的时间内获取所有查询行。
                        </p>
                        <p>以下示例通过不使用Text域索引返回分数排序行来实现更好的吞吐量。相反，Oracle Text会在从索引中检索满足<code class="codeph">CONTAINS</code>谓词的所有行之后对行进行排序：</p><pre class="oac_no_warn" dir="ltr">select / * + FIRST_ROWS（10）DOMAIN_INDEX_NO_SORT * / pk，score（1），col from ctx_tab where contains（txt_col，'test'，1）&gt; 0 order by score（1）desc;</pre></li>
                  </ul>
                  <div class="infoboxnotealso" id="GUID-21432876-BCE4-4250-A67F-C6E76017B872__GUID-FDE8A34B-1CA3-4CBF-8D97-C23EB4327E50">
                     <p class="notep1">也可以看看：</p>
                     <p> 有关查询优化器和使用<code class="codeph">FIRST_ROWS(n)</code>和<code class="codeph">CHOOSE</code>等提示的更多信息，请参阅<a href="../tgsql/query-optimizer-concepts.html#TGSQL-GUID-06129ACE-36B2-4534-AE68-EDFCAEBB3B5D" target="_blank"><span class="italic">“Oracle数据库SQL调优指南”</span></a></p>
                  </div>
               </div>
            </div><a id="CCAPP9245"></a><div class="props_rev_3"><a id="GUID-0A82CB4D-A252-4838-ACA1-8EF10FCD9A29" name="GUID-0A82CB4D-A252-4838-ACA1-8EF10FCD9A29"></a><h3 id="CCAPP-GUID-0A82CB4D-A252-4838-ACA1-8EF10FCD9A29" class="sect3"><span class="enumeration_section">10.4</span> Oracle Text中的复合域索引</h3>
               <div>
                  <p>Oracle数据库中可扩展性框架的复合域索引（CDI）功能使结构化列可以由Oracle Text编制索引。因此，单个Oracle Text索引行源可以满足文本和一个或多个结构化标准。以下类型的查询的性能得到改进：</p>
                  <ul style="list-style-type:disc">
                     <li>
                        <p>SQL语句在SQL <code class="codeph">WHERE</code>子句中使用结构化条件查询</p>
                     </li>
                     <li>
                        <p>具有结构化<code class="codeph">ORDER</code> <code class="codeph">BY</code>条件的Oracle Text查询</p>
                     </li>
                     <li>
                        <p>前两种查询类型的组合</p>
                     </li>
                  </ul>
                  <p>与连续的b树索引或位图索引一样，随着<code class="codeph">FILTER</code> <code class="codeph">BY</code>和<code class="codeph">ORDER</code> <code class="codeph">BY</code>列数量的增加，应用程序的数据操作语言（DML）性能会下降。在针对响应时间优化<code class="codeph">SCORE</code> -sort下推的情况下， <code class="codeph">SCORE</code>和结构化排序下推的结构化排序或组合也针对响应时间进行了优化，但不针对吞吐量进行了优化。但是，使用<code class="codeph">DOMAIN_INDEX_SORT</code>或<code class="codeph">FIRST_ROWS</code> <code class="codeph">(n)</code>提示强制将排序推送到CDI，同时获取整个命中列表可能会导致查询响应时间不佳。
                  </p>
               </div>
            </div><a id="CCAPP9513"></a><a id="CCAPP9246"></a><div class="props_rev_3"><a id="GUID-F315BDEC-F569-4A1C-939F-99B3B64726FA" name="GUID-F315BDEC-F569-4A1C-939F-99B3B64726FA"></a><h3 id="CCAPP-GUID-F315BDEC-F569-4A1C-939F-99B3B64726FA" class="sect3"><span class="enumeration_section">10.5</span>使用CDI进行性能调整</h3>
               <div>
                  <p>因为您可以将<code class="codeph">FILTER BY</code>列映射到<code class="codeph">MDATA,</code>所以可以通过限制<code class="codeph">RANGE</code>和<code class="codeph">LIKE.</code>支持的功能来优化相等搜索的查询性能<code class="codeph">LIKE.</code>但是，如果<code class="codeph">FILTER</code> <code class="codeph">BY</code>列包含顺序值或具有非常高的基数，Oracle建议不要将<code class="codeph">FILTER</code> <code class="codeph">BY</code>列映射到<code class="codeph">MDATA</code> 。这样做可能会导致非常长而窄的<code class="codeph">$I</code>表并降低<code class="codeph">$X</code>性能。这种顺序列的一个示例可以是使用<code class="codeph">DATE</code>标记的列。对于此类顺序列，建议映射到<code class="codeph">SDATA</code> 。
                  </p>
                  <p>使用以下提示将<code class="codeph">SORT</code>和<code class="codeph">FILTER</code> <code class="codeph">BY</code>谓词推入或不推入CDI：</p>
                  <ul style="list-style-type:disc">
                     <li>
                        <p><code class="codeph">DOMAIN_INDEX_SORT:</code>查询优化器尝试将适用的排序条件推送到指定的CDI。</p>
                     </li>
                     <li>
                        <p><code class="codeph">DOMAIN_INDEX_NO_SORT:</code>查询优化器尝试<span class="bold">不</span>将排序条件推送到指定的CDI。</p>
                     </li>
                     <li>
                        <p><code class="codeph">DOMAIN_INDEX_FILTER</code> （ <span class="italic">表名</span> <span class="italic">索引名称</span> ）：查询优化器尝试将适用的<code class="codeph">FILTER</code> <code class="codeph">BY</code>谓词推送到指定的CDI。</p>
                     </li>
                     <li>
                        <p><code class="codeph">DOMAIN_INDEX_NO_FILTER</code> （ <span class="italic">表名</span> <span class="italic">索引名称</span> ）：查询优化器不会尝试将适用的<code class="codeph">FILTER</code> <code class="codeph">BY</code>谓词推送到指定的CDI中。</p>
                     </li>
                  </ul>
                  <div class="infoboxnote" id="GUID-F315BDEC-F569-4A1C-939F-99B3B64726FA__GUID-A07D0C51-E53C-4FE5-842A-EFDC900126AD">
                     <p class="notep1">注意：</p>
                     <p><code class="codeph">domain_index_filter</code>提示不会强制查询优化器使用CDI。相反，如果CBO选择使用CDI，那么它也应该将过滤谓词推送到索引中。要强制查询优化器选择CDI索引，您还需要使用<code class="codeph">INDEX</code>提示。
                     </p>
                  </div>
                  <div class="example" id="GUID-F315BDEC-F569-4A1C-939F-99B3B64726FA__GUID-C727C451-D842-423D-83BD-7F17AB4C3295">
                     <p class="titleinexample">示例10-1使用CDI提示调优Oracle文本查询的性能</p>
                     <p>以下示例在<code class="codeph">books</code>表上执行优化查询。
                     </p><pre class="oac_no_warn" dir="ltr">SELECT bookid，pub_date，source FROM（SELECT / * + domain_index_sort domain_index_filter（books books_ctxcdi）* / bookid，pub_date，source FROM books WHERE CONTAINS（text，'aaa'，1）&gt; 0 AND bookid&gt; = 80 ORDER BY PUB_DATE desc nulls最后，SOURCE asc nulls last，score（1）desc）WHERE rownum &lt;20;</pre></div>
                  <!-- class="example" -->
               </div>
            </div><a id="CCAPP9247"></a><div class="props_rev_3"><a id="GUID-E282E4C7-6F64-46AB-909D-1E2F07A563CF" name="GUID-E282E4C7-6F64-46AB-909D-1E2F07A563CF"></a><h3 id="CCAPP-GUID-E282E4C7-6F64-46AB-909D-1E2F07A563CF" class="sect3"><span class="enumeration_section">10.6</span>使用跟踪解决索引和查询瓶颈</h3>
               <div>
                  <p>Oracle Text包含一个<span class="italic">跟踪</span>功能，使您能够识别索引和查询中的瓶颈。
                  </p>
                  <p>Oracle Text提供了一组预定义的<span class="italic">跟踪。</span> 每条迹线都由唯一编号标识。<code class="codeph">CTX_OUTPUT</code>包含此编号的符号。
                  </p>
                  <p>每个跟踪都会测量特定的数字量，例如在文本查询期间选择的<code class="codeph">$I</code>行数。
                  </p>
                  <p>跟踪是累积计数器，因此用法如下：</p>
                  <ol>
                     <li>
                        <p>用户启用跟踪。</p>
                     </li>
                     <li>
                        <p>用户执行一个或多个操作。Oracle Text测量活动并在跟踪中累积结果。</p>
                     </li>
                     <li>
                        <p>用户检索跟踪值，该值是在步骤2中完成的所有操作的总值。</p>
                     </li>
                     <li>
                        <p>用户将跟踪重置为0。</p>
                     </li>
                     <li>
                        <p>用户从步骤2开始。</p>
                     </li>
                  </ol>
                  <p>因此，例如，如果在步骤2中用户运行两个查询，并且查询1从<code class="codeph">$I,</code>选择15行<code class="codeph">$I,</code>并且查询2从<code class="codeph">$I,</code>选择17行<code class="codeph">$I,</code>则在步骤3中，跟踪的值为32（15 + 17） ）。
                  </p>
                  <p>跟踪与会话相关联 - 它们可以测量在单个会话中发生的操作，相反，无法跨会话进行测量。</p>
                  <p>在并行同步或优化期间，当且仅当当前启用了跟踪时，才会将跟踪配置文件复制到从属会话。每个从器件累积自己的跟踪，并在终止之前将所有跟踪值隐式写入从属日志文件。</p>
                  <div class="infoboxnotealso" id="GUID-E282E4C7-6F64-46AB-909D-1E2F07A563CF__GUID-4E830C0B-461E-44DD-AB0E-FF5F0AEB006B">
                     <p class="notep1">也可以看看：</p>
                     <p><a href="../ccref/CTX_OUTPUT-package.html#CCREF0800" target="_blank"><span class="italic">Oracle Text Reference</span></a></p>
                  </div>
               </div>
            </div><a id="CCAPP9248"></a><div class="props_rev_3"><a id="GUID-51F4ABF4-83A1-44EA-80FB-EF72430D3A1A" name="GUID-51F4ABF4-83A1-44EA-80FB-EF72430D3A1A"></a><h3 id="CCAPP-GUID-51F4ABF4-83A1-44EA-80FB-EF72430D3A1A" class="sect3"><span class="enumeration_section">10.7</span>使用并行查询</h3>
               <div>
                  <p>通常，并行查询对于决策支持系统（DSS）和在线分析处理（OLAP）是最佳的。它们也适用于具有大量数据集合的分析系统，具有较少并发用户数的多个CPU，或者<a id="d24571e2846" class="indexterm-anchor"></a><a id="d24571e2850" class="indexterm-anchor"></a> Oracle Real Application Clusters（Oracle RAC）节点。
                  </p>
                  <p>Oracle Text支持以下并行查询：</p>
                  <ul style="list-style-type:disc">
                     <li>
                        <p><a href="tuning-oracle-text.html#GUID-068C5AA8-D3C9-4885-B49A-8CA8E3BDE018">本地上下文索引的并行查询</a></p>
                     </li>
                     <li>
                        <p><a href="tuning-oracle-text.html#GUID-EF57F3D2-52ED-4571-B860-4986657C2D2C">跨Oracle RAC节点并行化查询</a></p>
                     </li>
                  </ul>
               </div><a id="CCAPP9249"></a><div class="props_rev_3"><a id="GUID-068C5AA8-D3C9-4885-B49A-8CA8E3BDE018" name="GUID-068C5AA8-D3C9-4885-B49A-8CA8E3BDE018"></a><h4 id="CCAPP-GUID-068C5AA8-D3C9-4885-B49A-8CA8E3BDE018" class="sect4"><span class="enumeration_section">10.7.1</span>本地上下文索引的并行查询</h4>
                  <div>
                     <p><span class="italic">并行查询</span>是指本地<code class="codeph">CONTEXT</code>索引的并行处理。根据索引的并行度和各种系统属性，Oracle确定要生成以处理索引的并行查询从属的数量。每个并行查询从属处理一个或多个索引分区。此默认查询行为适用于并行创建的本地索引。
                     </p>
                     <p>但是，对于具有大量并发用户的高负载系统，并行查询的查询吞吐量通常更差;如果查询是串行运行的，那么前N个命中通常可以通过前几个分区来满足。例如，使用<code class="codeph">ORDER</code> <code class="codeph">BY</code>分区键列进行典型的前N个文本查询：</p><pre class="oac_no_warn" dir="ltr">select * from（从stories_tab中选择story_id，其中包含（...）&gt; 0 order by publication_date desc）其中rownum &lt;= 10;</pre><p>这些文本查询通常在并行查询时表现<span class="italic">更差</span> 。
                     </p>
                     <p>您可以在使用<code class="codeph">ALTER INDEX</code>语句进行并行索引操作后禁用并行查询：</p><pre class="oac_no_warn" dir="ltr">更改索引&lt;文本索引名称&gt; NOPARALLEL;更改索引&lt;文本索引名称&gt; PARALLEL 1;</pre><p>您还可以启用或增加并行度：</p><pre class="oac_no_warn" dir="ltr">更改索引&lt;文本索引名称&gt;并行&lt;并行度&gt;;</pre></div>
               </div><a id="CCAPP9471"></a><div class="props_rev_3"><a id="GUID-EF57F3D2-52ED-4571-B860-4986657C2D2C" name="GUID-EF57F3D2-52ED-4571-B860-4986657C2D2C"></a><h4 id="CCAPP-GUID-EF57F3D2-52ED-4571-B860-4986657C2D2C" class="sect4"><span class="enumeration_section">10.7.2</span>跨Oracle RAC节点并行化查询</h4>
                  <div>
                     <p>Oracle Real Application Clusters（Oracle RAC）为提高查询吞吐量提供了出色的解决方案。如果您可以通过轻量级查询加载从Oracle Text获得良好性能，那么随着查询负载的增加，您可以期望从Oracle RAC获得出色的可伸缩性。</p>
                     <p>您可以通过物理分区文本数据和Oracle Text索引（使用本地分区索引）并确保分区由单独的Oracle RAC节点处理来实现Oracle Text性能的进一步改进。这样，您可以避免跨多个节点重复缓存内容，从而最大限度地发挥Oracle RAC缓存融合的优势。</p>
                     <p>在Oracle <span class="italic">10g</span>第1版中，必须在创建索引时将每个Oracle Text索引分区强制为单独的数据库文件。这使得Oracle RAC中的“重新制作”功能可以强制实现数据库文件关联，其中每个节点都集中在特定的数据库文件上，因此也是特定的Oracle Text索引分区。
                     </p>
                     <p>在Oracle <span class="italic">10g</span>第2版及更高版本中，Oracle支持数据库对象级关联，这使得将索引对象（ <code class="codeph">$I</code>和<code class="codeph">$R</code>表）分配给特定节点变得更加容易。
                     </p>
                     <p>尽管Oracle RAC提供了用于提高查询吞吐量和性能的解决方案，但它并不一定能够在扩展数据卷时继续获得相同的性能改进。您更有可能通过增加系统全局区域（SGA）缓存可用的内存量或通过对数据进行分区来查看改进，以便查询不必命中所有表分区以提供所需的查询结果集。</p>
                  </div>
               </div>
            </div><a id="CCAPP9251"></a><div class="props_rev_3"><a id="GUID-45AA18EF-710D-4A32-8A6C-3522054B10A8" name="GUID-45AA18EF-710D-4A32-8A6C-3522054B10A8"></a><h3 id="CCAPP-GUID-45AA18EF-710D-4A32-8A6C-3522054B10A8" class="sect3"><span class="enumeration_section">10.8</span>使用阻止操作调整查询</h3>
               <div>
                  <p>如果发出具有多个谓词的查询，则可以在执行计划中导致阻止操作。例如，请考虑以下混合查询：</p><pre class="oac_no_warn" dir="ltr">从mytab中选择docid，其中包含（text，'oracle'，1）&gt; 0 AND colA&gt; 5 AND colB&gt; 1 AND colC&gt; 3;</pre><p>假设所有谓词都是非选择性的，colA，colB和colC都有位图索引。Oracle数据库中的CBO选择以下执行计划：</p><pre class="oac_no_warn" dir="ltr">表格通过ROWIDS BITMAP转换为ROWIDS BITMAP和BITMAP索引COLA_BMX BITMAP索引COLB_BMX BITMAP索引COLC_BMX来自ROWIDS的BITMAP转换按区域索引MYINDEX排序</pre><p>由于<code class="codeph">BITMAP</code> <code class="codeph">AND</code>是阻塞操作，因此Oracle Text必须在运行<code class="codeph">BITMAP</code> <code class="codeph">AND</code>操作之前临时保存从Oracle Text域索引返回的rowid和score对。
                  </p>
                  <p>Oracle Text尝试将这些rowid和score对保存在内存中。但是，当结果集的大小超过<code class="codeph">SORT_AREA_SIZE</code>初始化参数时，Oracle Text会将这些结果溢出到磁盘上的临时段。
                  </p>
                  <p>由于将结果保存到磁盘会导致额外开销，因此可以通过增加<code class="codeph">SORT_AREA_SIZE</code>参数来提高性能。
                  </p><pre class="oac_no_warn" dir="ltr">alter session set SORT_AREA_SIZE = &lt;新的内存大小，以字节为单位&gt;;</pre><p>例如，将缓冲区设置为大约8兆字节。</p><pre class="oac_no_warn" dir="ltr">alter session set SORT_AREA_SIZE = 8300000;</pre><div class="infoboxnotealso" id="GUID-45AA18EF-710D-4A32-8A6C-3522054B10A8__GUID-80052CB4-1040-4D63-8C76-F09014CE5458">
                     <p class="notep1">也可以看看：</p>
                     <p>有关<code class="codeph">SORT_AREA_SIZE</code>更多信息，请<a href="../refrn/SORT_AREA_SIZE.html#REFRN-GUID-A343E04E-B484-4791-8B01-12E182AA00C7" target="_blank"><span class="italic">参见</span></a> <a href="../tgdba/managing-operating-system-resources.html#TGDBA-GUID-1C9C8D2D-AEB3-46C8-94D3-0BF24551870E" target="_blank"><span class="italic">“Oracle数据库性能调整指南”</span></a>和“ <a href="../refrn/SORT_AREA_SIZE.html#REFRN-GUID-A343E04E-B484-4791-8B01-12E182AA00C7" target="_blank"><span class="italic">Oracle数据库参考</span></a> ”</p>
                  </div>
               </div>
            </div><a id="CCAPP9252"></a><div class="props_rev_3"><a id="GUID-90312BBE-00D7-4200-B6AF-77CAFAA5D2F3" name="GUID-90312BBE-00D7-4200-B6AF-77CAFAA5D2F3"></a><h3 id="CCAPP-GUID-90312BBE-00D7-4200-B6AF-77CAFAA5D2F3" class="sect3"><span class="enumeration_section">10.9</span>关于查询性能的常见问题解答</h3>
               <div>
                  <p>本节回答有关查询性能的一些常见问题。</p>
                  <ul style="list-style-type:disc">
                     <li>
                        <p><a href="tuning-oracle-text.html#GUID-2522997E-2CCB-4AED-8EC8-D10CEC7293FE">什么是查询性能？</a></p>
                     </li>
                     <li>
                        <p><a href="tuning-oracle-text.html#GUID-124913E6-83D6-4525-8856-2EF87B32FD8F">什么是最快的文本查询类型？</a></p>
                     </li>
                     <li>
                        <p><a href="tuning-oracle-text.html#GUID-9896CBA2-946B-4202-952F-A891DA944DF9">我应该收集有关表格的统计数据吗？</a></p>
                     </li>
                     <li>
                        <p><a href="tuning-oracle-text.html#GUID-461B30DE-424D-40D8-A25F-5EF08A24D670">我的数据大小如何影响查询？</a></p>
                     </li>
                     <li>
                        <p><a href="tuning-oracle-text.html#GUID-E0B29AC4-AB3C-489C-B7E8-FD972D5399A8">我的数据格式如何影响查询？</a></p>
                     </li>
                     <li>
                        <p><a href="tuning-oracle-text.html#GUID-BAC89AA2-829C-4A96-8266-85960EE837E4">什么是功能与索引查找？</a></p>
                     </li>
                     <li>
                        <p><a href="tuning-oracle-text.html#GUID-C2AC7280-37D9-4F16-8618-67FD1B97BAC7">查询涉及哪些表？</a></p>
                     </li>
                     <li>
                        <p><a href="tuning-oracle-text.html#GUID-55032801-6D7B-4E93-AA6C-FF6B98CD76B3">$ R争用如何减少？</a></p>
                     </li>
                     <li>
                        <p><a href="tuning-oracle-text.html#GUID-99E8D918-EB5B-4835-81E0-D7C533DA9E4A">排序结果会减慢纯文本查询的速度吗？</a></p>
                     </li>
                     <li>
                        <p><a href="tuning-oracle-text.html#GUID-76416A9B-F4A8-47D4-874E-3E8FABD8ECB1">如何更快地进行ORDER BY分数查询？</a></p>
                     </li>
                     <li>
                        <p><a href="tuning-oracle-text.html#GUID-AFB7B3D3-0B03-4BE4-834F-BF1295CD11CD">哪些内存设置会影响查询？</a></p>
                     </li>
                     <li>
                        <p><a href="tuning-oracle-text.html#GUID-19431FDB-AD40-4DCF-A235-D372F7C9B33B">宽基表列的外部LOB存储是否提高了性能？</a></p>
                     </li>
                     <li>
                        <p><a href="tuning-oracle-text.html#GUID-9F51A472-C8F5-4F1F-A17B-8A21BB38CBC5">如何更快地在多个列上进行CONTAINS查询？</a></p>
                     </li>
                     <li>
                        <p><a href="tuning-oracle-text.html#GUID-7E174101-D66D-43E9-9A8B-69EBA73F6502">在查询中进行多次扩展是否可以？</a></p>
                     </li>
                     <li>
                        <p><a href="tuning-oracle-text.html#GUID-3E1CF9FB-60EE-4FA7-98CC-C0C895BEF2B8">本地分区索引如何帮助？</a></p>
                     </li>
                     <li>
                        <p><a href="tuning-oracle-text.html#GUID-D278E686-664A-4083-AF02-F3F27DE973E1">我应该并行查询吗？</a></p>
                     </li>
                     <li>
                        <p><a href="tuning-oracle-text.html#GUID-AB3F280E-4FBE-417C-BA1E-5FEFBE731906">我应该索引主题吗？</a></p>
                     </li>
                     <li>
                        <p><a href="tuning-oracle-text.html#GUID-BC4B11B8-348C-47AF-A49D-99EE0312F73F">我什么时候应该使用CTXCAT索引？</a></p>
                     </li>
                     <li>
                        <p><a href="tuning-oracle-text.html#GUID-7844B5A5-E096-4B6E-91D0-59D23B46B375">什么时候CTXCAT索引不合适？</a></p>
                     </li>
                     <li>
                        <p><a href="tuning-oracle-text.html#GUID-6AC6C18F-2F28-4DAA-ACDF-F59615B1CFD9">有哪些优化器提示可用，它们有什么作用？</a></p>
                     </li>
                  </ul>
               </div><a id="CCAPP9253"></a><div class="props_rev_3"><a id="GUID-2522997E-2CCB-4AED-8EC8-D10CEC7293FE" name="GUID-2522997E-2CCB-4AED-8EC8-D10CEC7293FE"></a><h4 id="CCAPP-GUID-2522997E-2CCB-4AED-8EC8-D10CEC7293FE" class="sect4"><span class="enumeration_section">10.9.1</span>什么是查询性能？
                  </h4>
                  <div>
                     <p><span class="bold">答：</span>查询性能有两种衡量标准：</p>
                     <ul style="list-style-type:disc">
                        <li>
                           <p><span class="bold">响应时间：</span>获得单个查询答案的时间</p>
                        </li>
                        <li>
                           <p><span class="bold">吞吐量：</span>在任何给定时间段内可以运行的查询数量;例如，每秒查询一次</p>
                        </li>
                     </ul>
                     <p>这两项措施是相关的，但它们并不相同。在负载很重的系统中，您需要最大吞吐量，而在负载相对较轻的系统中，您可能需要最短的响应时间。此外，某些应用程序需要查询以向用户提供所有匹配，而其他应用程序仅需要来自有序集的前20个匹配。区分这两种情况很重要。</p>
                  </div>
               </div><a id="CCAPP9254"></a><div class="props_rev_3"><a id="GUID-124913E6-83D6-4525-8856-2EF87B32FD8F" name="GUID-124913E6-83D6-4525-8856-2EF87B32FD8F"></a><h4 id="CCAPP-GUID-124913E6-83D6-4525-8856-2EF87B32FD8F" class="sect4"><span class="enumeration_section">10.9.2</span>什么是最快的Oracle Text查询类型？
                  </h4>
                  <div>
                     <p><span class="bold">答：</span>最快的查询类型符合以下条件：</p>
                     <ul style="list-style-type:disc">
                        <li>
                           <p>单个<code class="codeph">CONTAINS</code>子句</p>
                        </li>
                        <li>
                           <p><code class="codeph">WHERE</code>子句中没有其他条件</p>
                        </li>
                        <li>
                           <p>没有<code class="codeph">ORDER</code> <code class="codeph">BY</code>子句</p>
                        </li>
                        <li>
                           <p>仅返回结果的第一页（例如，前10或20次点击）</p>
                        </li>
                     </ul>
                  </div>
               </div><a id="CCAPP9255"></a><div class="props_rev_3"><a id="GUID-9896CBA2-946B-4202-952F-A891DA944DF9" name="GUID-9896CBA2-946B-4202-952F-A891DA944DF9"></a><h4 id="CCAPP-GUID-9896CBA2-946B-4202-952F-A891DA944DF9" class="sect4"><span class="enumeration_section">10.9.3</span>我应该收集有关表格的统计数据吗？
                  </h4>
                  <div>
                     <p><span class="bold">答：</span>是的。通过收集表的统计信息，Oracle Text可以进行基于成本的分析。这有助于Oracle Text为您的查询选择最有效的执行计划。
                     </p>
                     <p>如果您的查询始终是纯文本查询（没有结构化谓词且没有连接），则应删除Oracle Text索引的统计信息。</p>
                  </div>
               </div><a id="CCAPP9256"></a><div class="props_rev_3"><a id="GUID-461B30DE-424D-40D8-A25F-5EF08A24D670" name="GUID-461B30DE-424D-40D8-A25F-5EF08A24D670"></a><h4 id="CCAPP-GUID-461B30DE-424D-40D8-A25F-5EF08A24D670" class="sect4"><span class="enumeration_section">10.9.4</span>我的数据大小如何影响查询？
                  </h4>
                  <div>
                     <p><span class="bold">答案：</span> Oracle Text索引可以提供rowid的速度不受实际数据大小的影响。Oracle Text查询速度与必须从索引表中提取的行数，请求的命中数，查询生成的命中数以及是否存在排序有关。
                     </p>
                  </div>
               </div><a id="CCAPP9257"></a><div class="props_rev_3"><a id="GUID-E0B29AC4-AB3C-489C-B7E8-FD972D5399A8" name="GUID-E0B29AC4-AB3C-489C-B7E8-FD972D5399A8"></a><h4 id="CCAPP-GUID-E0B29AC4-AB3C-489C-B7E8-FD972D5399A8" class="sect4"><span class="enumeration_section">10.9.5</span>我的数据格式如何影响查询？
                  </h4>
                  <div>
                     <p><span class="bold">答：</span>文档格式（纯ASCII文本，HTML或Microsoft Word）对查询速度没有影响。文档在索引时过滤为纯文本，而不是查询时间。
                     </p>
                     <p>数据的清洁度有所不同。用于发布的拼写检查和子编辑文本往往具有比非正式文本（包括拼写错误和缩写）小得多的总词汇量（因此索引表的大小）。对于给定的索引内存设置，额外文本占用内存，创建更多碎片行，并对查询响应时间产生负面影响。</p>
                  </div>
               </div><a id="CCAPP9258"></a><div class="props_rev_3"><a id="GUID-BAC89AA2-829C-4A96-8266-85960EE837E4" name="GUID-BAC89AA2-829C-4A96-8266-85960EE837E4"></a><h4 id="CCAPP-GUID-BAC89AA2-829C-4A96-8266-85960EE837E4" class="sect4"><span class="enumeration_section">10.9.6</span>索引查找和功能查找之间有什么区别</h4>
                  <div>
                     <p><span class="bold">答案：</span>内核可以使用索引查找和功能查找来查询Oracle Text索引。在索引查找中，第一个也是最常见的情况是，内核向Oracle Text索引询问满足特定文本搜索的所有rowid。这些rowid分批返回。
                     </p>
                     <p>在函数查找中，内核将各个rowid传递给Oracle Text索引，并询问该特定rowid是否满足某个文本标准。函数查找最常用于非常有选择性的结构化子句，因此必须根据Oracle Text索引检查几个rowid。以下是功能查找有用的搜索示例：</p><pre class="oac_no_warn" dir="ltr">SELECT ID，SCORE（1），来自MYTABLE的文字</pre><pre class="oac_no_warn" dir="ltr">在START_DATE ='1992年10月21日'&lt; - 高度选择性和包含（TEXT，'commonword'）&gt; 0 &lt; - 非选择性</pre><p>功能调用还用于按结构化列排序的Oracle Text查询（例如日期，价格）以及Oracle Text查询是否包含非选择性单词。</p>
                  </div>
               </div><a id="CCAPP9259"></a><div class="props_rev_3"><a id="GUID-C2AC7280-37D9-4F16-8618-67FD1B97BAC7" name="GUID-C2AC7280-37D9-4F16-8618-67FD1B97BAC7"></a><h4 id="CCAPP-GUID-C2AC7280-37D9-4F16-8618-67FD1B97BAC7" class="sect4"><span class="enumeration_section">10.9.7</span>查询涉及哪些表？
                  </h4>
                  <div>
                     <p><span class="bold">答案：</span>所有查询都会查看索引令牌表。表的名称具有<code class="codeph">DR$indexname$I</code>的形式，并包含令牌列表（ <code class="codeph">TOKEN_TEXT</code>列）以及有关令牌发生的行和字位置的信息（ <code class="codeph">TOKEN_INFO</code>列）。
                     </p>
                     <p>行信息存储为内部docid值，必须转换为外部rowid值。您使用的表取决于查找的类型：</p>
                     <ul style="list-style-type:disc">
                        <li>
                           <p>对于功能查找，请使用<code class="codeph">$K</code>表， <code class="codeph">DR$indexname$K.</code>这个简单的索引组织表（IOT）包含每个docid / rowid对的行。
                           </p>
                        </li>
                        <li>
                           <p>对于索引查找，请使用<code class="codeph">$R</code>表， <code class="codeph">DR$indexname$R.</code>此表包含BLOB列中的rowid的完整列表。
                           </p>
                        </li>
                     </ul>
                     <p>从Oracle Database 12 <span class="italic">c</span>第2版（12.2） <code class="codeph">SMALL_R_ROW,</code>引入了一个新的存储属性<code class="codeph">SMALL_R_ROW,</code>来减小<code class="codeph">$R</code>行的大小。它按需填充<code class="codeph">$R</code>行而不是创建22个静态行，从而减少了数据操作语言争用。当并行插入，更新和删除操作尝试锁定相同的<code class="codeph">$R</code>行时，会发生争用。
                     </p>
                     <p>通过检查SQL跟踪并查找<code class="codeph">$K</code>或<code class="codeph">$R</code>表，可以轻松找出是否正在使用功能查询或索引查找。
                     </p>
                     <div class="infoboxnote" id="GUID-C2AC7280-37D9-4F16-8618-67FD1B97BAC7__GUID-8BD69135-5AA9-4FE5-AB2C-E11D0DA0B729">
                        <p class="notep1">注意：</p>
                        <p>这些内部索引表可能会随发行版的不同而变化。Oracle建议您不要直接访问应用程序中的这些表。</p>
                     </div>
                  </div>
               </div>
               <div class="sect3"><a id="GUID-55032801-6D7B-4E93-AA6C-FF6B98CD76B3" name="GUID-55032801-6D7B-4E93-AA6C-FF6B98CD76B3"></a><h4 id="CCAPP-GUID-55032801-6D7B-4E93-AA6C-FF6B98CD76B3" class="sect4"><span class="enumeration_section">10.9.8</span>如何减少$ R表争用？
                  </h4>
                  <div>
                     <div class="p">基表删除和更新操作期间的<code class="codeph">$R</code>争用已成为过去几年中反复出现的主题。目前，每个<code class="codeph">$R</code>索引表有22个静态行，每行最多可包含2亿个rowid。当并行插入，更新和删除操作尝试锁定插入或删除操作的相同<code class="codeph">$R</code>行时，会发生争用。此版本中的以下增强功能减少了争用：<ul style="list-style-type:disc">
                           <li>
                              <p>每个<code class="codeph">$R</code>行可以包含的最大rowid数是70,000，这意味着每行存储1 MB的数据。要使用此功能，必须设置<code class="codeph">SMALL_R_ROW</code>存储属性。
                              </p>
                           </li>
                           <li>
                              <p><code class="codeph">$R</code>行是按需创建的，而不是仅填充预定数量的行。
                              </p>
                           </li>
                        </ul>
                     </div>
                  </div>
               </div><a id="CCAPP9260"></a><div class="props_rev_3"><a id="GUID-99E8D918-EB5B-4835-81E0-D7C533DA9E4A" name="GUID-99E8D918-EB5B-4835-81E0-D7C533DA9E4A"></a><h4 id="CCAPP-GUID-99E8D918-EB5B-4835-81E0-D7C533DA9E4A" class="sect4"><span class="enumeration_section">10.9.9</span>排序结果是否会减慢纯文本查询的速度？
                  </h4>
                  <div>
                     <p><span class="bold">答：</span>是的，确实如此。
                     </p>
                     <p>如果Oracle Text没有排序，那么它可以在找到它们时返回结果。当应用程序需要一次只显示一页结果时，此方法更快。</p>
                  </div>
               </div><a id="CCAPP9261"></a><div class="props_rev_3"><a id="GUID-76416A9B-F4A8-47D4-874E-3E8FABD8ECB1" name="GUID-76416A9B-F4A8-47D4-874E-3E8FABD8ECB1"></a><h4 id="CCAPP-GUID-76416A9B-F4A8-47D4-874E-3E8FABD8ECB1" class="sect4"><span class="enumeration_section">10.9.10</span>如何更快地进行ORDER BY分数查询？
                  </h4>
                  <div>
                     <p><span class="bold">答案：</span>如果使用<code class="codeph">FIRST_ROWS(n)</code>提示，按相关性排序（ <code class="codeph">SCORE(n)</code> ）可能会很快。在这种情况下，Oracle Text在从Oracle Text索引表中获取时执行高速内部排序。
                     </p>
                     <p>以下是此查询的示例：</p><pre class="oac_no_warn" dir="ltr">SELECT / * + FIRST_ROWS（10）* / ID，SCORE（1），TEXT FROM mytable WHERE CONTAINS（TEXT，'searchterm'，1）&gt; 0 ORDER BY SCORE（1）DESC;</pre><p>值得注意的是，除了单个<code class="codeph">CONTAINS.</code>之外， <code class="codeph">WHERE</code>子句中不能有其他标准<code class="codeph">CONTAINS.</code></p>
                  </div>
               </div><a id="CCAPP9262"></a><div class="props_rev_3"><a id="GUID-AFB7B3D3-0B03-4BE4-834F-BF1295CD11CD" name="GUID-AFB7B3D3-0B03-4BE4-834F-BF1295CD11CD"></a><h4 id="CCAPP-GUID-AFB7B3D3-0B03-4BE4-834F-BF1295CD11CD" class="sect4"><span class="enumeration_section">10.9.11</span>哪些内存设置会影响查询？
                  </h4>
                  <div>
                     <p><span class="bold">答：</span>对于查询，您需要争取一个大型系统全局区域（SGA）。您可以在Oracle数据库初始化文件中设置这些SGA参数。您也可以动态设置这些参数。
                     </p>
                     <p><code class="codeph">SORT_AREA_SIZE</code>参数控制可用于排序<code class="codeph">ORDER BY</code>查询的内存。如果经常按结构化列排序，则应增加此参数的大小。
                     </p>
                     <div class="infoboxnotealso" id="GUID-AFB7B3D3-0B03-4BE4-834F-BF1295CD11CD__GUID-A7175F29-6BD8-4A4F-9D2C-4DA29B181E06">
                        <p class="notep1">也可以看看：</p>
                        <p></p>
                        <ul style="list-style-type:disc">
                           <li>
                              <p>有关设置SGA相关参数的详细信息，请参见<a href="../admin/managing-memory.html#ADMIN-GUID-BEABE53D-8058-4834-B99B-5C80A8AD5B06" target="_blank"><span class="italic">“Oracle数据库管理员指南”</span></a></p>
                           </li>
                           <li>
                              <p>有关内存分配的详细信息，请<a href="../tgdba/database-memory-allocation.html#TGDBA-GUID-E9265077-B296-485A-BC2C-0AF55762D1EC" target="_blank"><span class="italic">参见“Oracle数据库性能调整指南</span></a></p>
                           </li>
                           <li>
                              <p>有关设置<code class="codeph">SORT_AREA_SIZE</code>参数的详细信息，请<a href="../refrn/SORT_AREA_SIZE.html#REFRN-GUID-A343E04E-B484-4791-8B01-12E182AA00C7" target="_blank"><span class="italic">参见Oracle数据库参考</span></a></p>
                           </li>
                        </ul>
                     </div>
                  </div>
               </div><a id="CCAPP9263"></a><div class="props_rev_3"><a id="GUID-19431FDB-AD40-4DCF-A235-D372F7C9B33B" name="GUID-19431FDB-AD40-4DCF-A235-D372F7C9B33B"></a><h4 id="CCAPP-GUID-19431FDB-AD40-4DCF-A235-D372F7C9B33B" class="sect4"><span class="enumeration_section">10.9.12</span>宽基表列的外线LOB存储是否提高了性能？
                  </h4>
                  <div>
                     <p><span class="bold">答：</span>是的。通常， <code class="codeph">SELECT</code>语句从基表中选择多个列。由于Oracle Text将列提取到内存，因此将大型基表列（如大对象（LOB））存储在线外会更有效，尤其是当这些列很少更新但经常被选中时。
                     </p>
                     <p>当LOB存储在行外时，在查询期间只需要将LOB定位符提取到内存。外部存储减少了基表的有效大小。它使Oracle Text更容易将整个表缓存到内存中，因此降低了从基表中选择列的成本，并加快了文本查询的速度。</p>
                     <p>此外，缓存在内存中的较小基表允许在查询期间缓存更多索引表数据，从而提高性能。</p>
                  </div>
               </div><a id="CCAPP9264"></a><div class="props_rev_3"><a id="GUID-9F51A472-C8F5-4F1F-A17B-8A21BB38CBC5" name="GUID-9F51A472-C8F5-4F1F-A17B-8A21BB38CBC5"></a><h4 id="CCAPP-GUID-9F51A472-C8F5-4F1F-A17B-8A21BB38CBC5" class="sect4"><span class="enumeration_section">10.9.13</span>如何在多个列上加速CONTAINS查询？
                  </h4>
                  <div>
                     <p><span class="bold">答案：</span>最快的查询类型是只有一个<code class="codeph">CONTAINS</code>子句而<code class="codeph">WHERE</code>子句中没有其他条件的<code class="codeph">WHERE</code> 。
                     </p>
                     <p>考虑以下多个<code class="codeph">CONTAINS</code>查询：</p><pre class="oac_no_warn" dir="ltr">SELECT title，isbn FROM booklist WHERE CONTAINS（title，'horse'）&gt; 0 AND CONTAINS（abstract，'racing'）&gt; 0</pre><p>您可以通过节搜索和<code class="codeph">WITHIN</code>运算符获得相同的结果：</p><pre class="oac_no_warn" dir="ltr">SELECT title，isbn FROM booklist WHERE CONTAINS（alltext，'horse WITHIN title AND racing WITHIN abstract'）&gt; 0</pre><p>此查询比单个<code class="codeph">CONTAINS</code>子句更快地完成。要使用这样的查询，您必须将所有数据复制到单个文本列中以进行索引，并在每个列的数据周围添加节标记。您可以在建立索引之前使用PL / SQL过程执行此操作，也可以在索引<code class="codeph">USER_DATASTORE</code>期间使用<code class="codeph">USER_DATASTORE</code>数据存储区将带有text列的结构化列合成为一个文档。
                     </p>
                  </div>
               </div><a id="CCAPP9265"></a><div class="props_rev_3"><a id="GUID-7E174101-D66D-43E9-9A8B-69EBA73F6502" name="GUID-7E174101-D66D-43E9-9A8B-69EBA73F6502"></a><h4 id="CCAPP-GUID-7E174101-D66D-43E9-9A8B-69EBA73F6502" class="sect4"><span class="enumeration_section">10.9.14</span>我可以在查询中进行多次扩展吗？
                  </h4>
                  <div>
                     <p><span class="bold">答案：</span>查询中使用的每个不同的单词都需要从索引表中提取至少一行。因此，最好尽可能减少扩展次数。
                     </p>
                     <p>你不应该使用扩展，如通配符，词库，词干和模糊匹配，除非它们是任务所必需的。通常，一些扩展（例如，10到20）不会造成困难，但在查询中避免大量扩展（80或100）。使用查询反馈机制确定任何特定查询表达式的扩展数。</p>
                     <p>对于通配符和词干查询，您可以通过创建前缀，子字符串或词干索引来避免从查询时间到索引时间的术语扩展。查询性能的增加是以更长的索引时间和增加的磁盘空间为代价的。</p>
                     <p>前缀和子字符串索引可以提高通配符性能。您可以使用<code class="codeph">BASIC_WORDLIST</code>首选项启用前缀和子字符串索引。以下示例为前缀和子字符串索引设置wordlist首选项。对于前缀索引，它指定Oracle Text创建3到4个字符长的令牌前缀：</p><pre class="oac_no_warn" dir="ltr">开始</pre><pre class="oac_no_warn" dir="ltr">ctx_ddl.create_preference（'mywordlist'，'BASIC_WORDLIST'）; ctx_ddl.set_attribute（ 'mywordlist'， 'PREFIX_INDEX'， 'TRUE'）; ctx_ddl.set_attribute（'mywordlist'，'PREFIX_MIN_LENGTH'，'3'）; ctx_ddl.set_attribute（'mywordlist'，'PREFIX_MAX_LENGTH'，'4'）; ctx_ddl.set_attribute（'mywordlist'，'SUBSTRING_INDEX'，'YES'）;</pre><pre class="oac_no_warn" dir="ltr">结束</pre><p></p>
                     <p>使用<code class="codeph">BASIC_LEXER</code>首选项启用词干索引：</p><pre class="oac_no_warn" dir="ltr">开始</pre><pre class="oac_no_warn" dir="ltr">ctx_ddl.create_preference（'mylex'，'BASIC_LEXER'）; ctx_ddl.set_attribute（'mylex'，'index_stems'，'ENGLISH'）;</pre><pre class="oac_no_warn" dir="ltr">结束;</pre></div>
               </div><a id="CCAPP9266"></a><div class="props_rev_3"><a id="GUID-3E1CF9FB-60EE-4FA7-98CC-C0C895BEF2B8" name="GUID-3E1CF9FB-60EE-4FA7-98CC-C0C895BEF2B8"></a><h4 id="CCAPP-GUID-3E1CF9FB-60EE-4FA7-98CC-C0C895BEF2B8" class="sect4"><span class="enumeration_section">10.9.15</span>本地分区索引如何帮助？
                  </h4>
                  <div>
                     <p><span class="bold">答案：</span>您可以在分区表上创建本地分区的<code class="codeph">CONTEXT</code>索引。这意味着，在分区表上，每个分区都有自己的一组索引表。有效地，根据需要组合来自多个索引的结果以产生最终结果集。
                     </p>
                     <p>使用<code class="codeph">LOCAL</code>关键字创建索引：</p><pre class="oac_no_warn" dir="ltr">CREATE INDEX index_name ON table_name（column_name）INDEXTYPE IS ctxsys.context PARAMETERS（'...'）LOCAL</pre><p>使用分区表和本地索引，可以提高以下类型的<code class="codeph">CONTAINS</code>查询的性能：</p>
                     <ul style="list-style-type:disc">
                        <li>
                           <p><span class="bold">分区键列上的范围搜索：</span>此查询将搜索限制为也是分区键的列上的特定值范围。
                           </p>
                        </li>
                        <li>
                           <p><span class="bold">ORDER BY分区键列：</span>此查询仅需要前<code class="codeph">n</code>命中， <code class="codeph">ORDER BY</code>子句命名分区键。
                           </p>
                           <div class="infoboxnotealso" id="GUID-3E1CF9FB-60EE-4FA7-98CC-C0C895BEF2B8__GUID-DBF5C15E-932A-44E2-8C04-55EA59A9B0EE">
                              <p class="notep1">也可以看看：</p>
                              <p><span class="q">“ <a href="tuning-oracle-text.html#GUID-DE0B4638-A760-47C4-8593-F68ECEBFD370">使用本地分区的CONTEXT索引改善了响应时间</a> ”</span></p>
                           </div>
                        </li>
                     </ul>
                  </div>
               </div><a id="CCAPP9267"></a><div class="props_rev_3"><a id="GUID-D278E686-664A-4083-AF02-F3F27DE973E1" name="GUID-D278E686-664A-4083-AF02-F3F27DE973E1"></a><h4 id="CCAPP-GUID-D278E686-664A-4083-AF02-F3F27DE973E1" class="sect4"><span class="enumeration_section">10.9.16</span>我应该并行查询吗？
                  </h4>
                  <div>
                     <p><span class="bold">答：</span>这取决于系统负载和服务器容量。尽管并行查询是并行创建的索引的默认行为，但它通常会降低负载较重的系统上的整体查询吞吐量。
                     </p>
                     <p>并行查询是决策支持系统（DSS）和在线分析处理（OLAP）的最佳选择。它们也是具有大型数据集合，具有少量并发用户的多个CPU或Oracle Real Application Clusters（Oracle RAC）节点的分析系统的最佳选择。</p>
                     <div class="infoboxnotealso" id="GUID-D278E686-664A-4083-AF02-F3F27DE973E1__GUID-E7D43ECB-6788-49A4-8412-19C31BCCD9AF">
                        <p class="notep1">也可以看看：</p>
                        <p><span class="q">“ <a href="tuning-oracle-text.html#GUID-51F4ABF4-83A1-44EA-80FB-EF72430D3A1A">使用并行查询</a> ”</span></p>
                     </div>
                  </div>
               </div><a id="CCAPP9268"></a><div class="props_rev_3"><a id="GUID-AB3F280E-4FBE-417C-BA1E-5FEFBE731906" name="GUID-AB3F280E-4FBE-417C-BA1E-5FEFBE731906"></a><h4 id="CCAPP-GUID-AB3F280E-4FBE-417C-BA1E-5FEFBE731906" class="sect4"><span class="enumeration_section">10.9.17</span>我应该索引主题吗？
                  </h4>
                  <div>
                     <p><span class="bold">答：</span>使用<code class="codeph">CONTEXT</code>索引索引主题信息需要更长时间，并且还会增加索引的大小。但是，主题索引通过使用知识库使<code class="codeph">ABOUT</code>查询更加精确。如果您的应用程序使用了很多<code class="codeph">ABOUT</code>查询，那么为索引创建主题组件可能是值得的，尽管需要额外的索引时间和额外的存储空间。
                     </p>
                     <div class="infoboxnotealso" id="GUID-AB3F280E-4FBE-417C-BA1E-5FEFBE731906__GUID-6FBB9B06-ACD1-46E9-9B5F-568868F40775">
                        <p class="notep1">也可以看看：</p>
                        <p><span class="q">“ <a href="querying-with-oracle-text.html#GUID-E3ED0880-E919-43BE-BC10-1837D76F0E8F">关于查询和主题</a> ”</span></p>
                     </div>
                  </div>
               </div><a id="CCAPP9269"></a><div class="props_rev_3"><a id="GUID-BC4B11B8-348C-47AF-A49D-99EE0312F73F" name="GUID-BC4B11B8-348C-47AF-A49D-99EE0312F73F"></a><h4 id="CCAPP-GUID-BC4B11B8-348C-47AF-A49D-99EE0312F73F" class="sect4"><span class="enumeration_section">10.9.18</span>何时应使用CTXCAT指数？
                  </h4>
                  <div>
                     <p><span class="bold">答案：</span> <code class="codeph">CTXCAT</code>索引在文本处于小块（仅几行）时效果最佳，并且您希望搜索根据某些结构化条件（如数字或日期）限制或排序结果集。
                     </p>
                     <p>例如，考虑在线拍卖网站。每个待售商品都有简短描述，当前竞标价格以及拍卖的开始和结束日期。用户可能希望在说明中查看带有<span class="italic">古董柜的</span>所有记录，当前出价低于500美元。因为他对新发布的项目特别感兴趣，所以他希望按拍卖开始时间排序结果。
                     </p>
                     <p>对于<code class="codeph">CONTEXT</code>索引上的<code class="codeph">CONTAINS</code>结构化查询，此搜索并不总是有效。响应时间可根据结构和显著变化<code class="codeph">CONTAINS</code>子句，由于结构化的交点和<code class="codeph">CONTAINS</code>条款或在Oracle文本查询排序在查询时间计算的。
                     </p>
                     <p>通过在<code class="codeph">CTXCAT</code>索引中包含结构化信息，可以确保查询响应时间始终处于最佳范围，而不管搜索条件如何。由于文本和结构化查询之间的交互是在索引期间预先计算的，因此查询响应时间是最佳的。
                     </p>
                  </div>
               </div><a id="CCAPP9270"></a><div class="props_rev_3"><a id="GUID-7844B5A5-E096-4B6E-91D0-59D23B46B375" name="GUID-7844B5A5-E096-4B6E-91D0-59D23B46B375"></a><h4 id="CCAPP-GUID-7844B5A5-E096-4B6E-91D0-59D23B46B375" class="sect4"><span class="enumeration_section">10.9.19</span>何时CTXCAT索引不合适？
                  </h4>
                  <div>
                     <p><span class="bold">答：</span>创建索引所需的时间和空间存在差异。<code class="codeph">CTXCAT</code>索引需要更长时间才能创建，并且它们使用的磁盘空间比<code class="codeph">CONTEXT</code>索引多得多。如果您的磁盘空间<code class="codeph">CTXCAT</code> ，请仔细考虑<code class="codeph">CTXCAT</code>索引是否适合您。
                     </p>
                     <p>使用查询运算符，您可以使用查询模板在<code class="codeph">CATSEARCH</code>查询中使用更丰富的<code class="codeph">CONTEXT</code>语法。单个<code class="codeph">CATSEARCH</code>查询语法的旧限制不再成立。
                     </p>
                  </div>
               </div><a id="CCAPP9271"></a><div class="props_rev_3"><a id="GUID-6AC6C18F-2F28-4DAA-ACDF-F59615B1CFD9" name="GUID-6AC6C18F-2F28-4DAA-ACDF-F59615B1CFD9"></a><h4 id="CCAPP-GUID-6AC6C18F-2F28-4DAA-ACDF-F59615B1CFD9" class="sect4"><span class="enumeration_section">10.9.20有</span>哪些优化器提示可用，它们有什么作用？
                  </h4>
                  <div>
                     <p><span class="bold">答案：</span>要使用text或b-tree索引驱动查询，可以按常规方式使用<code class="codeph">INDEX(table column)</code>优化程序提示。
                     </p>
                     <p>您还可以使用<code class="codeph">NO_INDEX(table column)</code>提示来禁用特定索引。
                     </p>
                     <p><code class="codeph">FIRST_ROWS(n)</code>提示对文本查询具有特殊含义。当您需要查询的前<code class="codeph">n</code>次点击时使用它。当您将<code class="codeph">DOMAIN_INDEX_SORT</code>提示与<code class="codeph">ORDER BY SCORE(n) DESC,</code>结合使用时<code class="codeph">ORDER BY SCORE(n) DESC,</code>您可以告诉Oracle优化器接受Oracle Text索引中的有序集并进行更远的排序。
                     </p>
                     <div class="infoboxnotealso" id="GUID-6AC6C18F-2F28-4DAA-ACDF-F59615B1CFD9__GUID-8288AFDF-74A9-407C-B349-9A322DAA1274">
                        <p class="notep1">也可以看看：</p>
                        <p><span class="q">“ <a href="tuning-oracle-text.html#GUID-3B8371B5-F7AC-4A94-80EE-510B7820EE6D">优化响应时间的查询</a> ”</span></p>
                     </div>
                  </div>
               </div>
            </div><a id="CCAPP9272"></a><div class="props_rev_3"><a id="GUID-82000645-74B9-407E-A9C0-C1ACEE319BD9" name="GUID-82000645-74B9-407E-A9C0-C1ACEE319BD9"></a><h3 id="CCAPP-GUID-82000645-74B9-407E-A9C0-C1ACEE319BD9" class="sect3"><span class="enumeration_section">10.10</span>关于索引性能的常见问题解答</h3>
               <div>
                  <p>本节回答有关索引性能的一些常见问题。</p>
                  <ul style="list-style-type:disc">
                     <li>
                        <p><a href="tuning-oracle-text.html#GUID-A8DD62AA-F50D-4929-A692-61180F5BACE1">索引需要多长时间？</a></p>
                     </li>
                     <li>
                        <p><a href="tuning-oracle-text.html#GUID-BBF8E750-E6C9-4149-AB88-8403EC583536">我应该使用哪种索引内存设置？</a></p>
                     </li>
                     <li>
                        <p><a href="tuning-oracle-text.html#GUID-AF9AEA5F-7665-4342-8EC8-963701CABCB4">索引需要多少磁盘开销？</a></p>
                     </li>
                     <li>
                        <p><a href="tuning-oracle-text.html#GUID-24EF49DB-AFFB-499C-BC57-000941C6833F">我的数据格式如何影响索引？</a></p>
                     </li>
                     <li>
                        <p><a href="tuning-oracle-text.html#GUID-7ADB0B30-0E1A-4308-B941-3BEEA5DEA5E5">并行索引可以提高性能吗？</a></p>
                     </li>
                     <li>
                        <p><a href="tuning-oracle-text.html#GUID-EA5B318D-9D38-4D4E-925B-8FA9CFD81561">如何提高创建本地分区索引的索引性能？</a></p>
                     </li>
                     <li>
                        <p><a href="tuning-oracle-text.html#GUID-E89DE5BB-7C25-4901-A890-B7925506A3DF">如何判断索引编制完成了多少？</a></p>
                     </li>
                  </ul>
               </div><a id="CCAPP9273"></a><div class="props_rev_3"><a id="GUID-A8DD62AA-F50D-4929-A692-61180F5BACE1" name="GUID-A8DD62AA-F50D-4929-A692-61180F5BACE1"></a><h4 id="CCAPP-GUID-A8DD62AA-F50D-4929-A692-61180F5BACE1" class="sect4"><span class="enumeration_section">10.10.1</span>索引需要多长时间？
                  </h4>
                  <div>
                     <p><span class="bold">答：</span>索引文本是一个资源密集型过程。索引的速度取决于硬件的功率。索引速度取决于CPU和I / O容量。有足够的I / O容量来读取原始数据并写出索引条目，CPU是限制因素。
                     </p>
                     <p>采用Intel x86（Core 2架构，2.5GHz）CPU的测试表明，Oracle Text每天可为每个CPU核心索引大约100 GB的文本。随着CPU时钟速度的增加和CPU架构变得更加高效，预计这种速度将会提高。</p>
                     <p>其他因素（例如文档格式，数据位置以及对用户定义的数据存储，过滤器和词法分析器的调用）可能会影响索引速度。</p>
                  </div>
               </div><a id="CCAPP9274"></a><div class="props_rev_3"><a id="GUID-BBF8E750-E6C9-4149-AB88-8403EC583536" name="GUID-BBF8E750-E6C9-4149-AB88-8403EC583536"></a><h4 id="CCAPP-GUID-BBF8E750-E6C9-4149-AB88-8403EC583536" class="sect4"><span class="enumeration_section">10.10.2</span>我应该使用哪种索引内存设置？
                  </h4>
                  <div>
                     <p><span class="bold">答案：</span>您可以使用<code class="codeph">DEFAULT_INDEX_MEMORY</code>和<code class="codeph">MAX_INDEX_MEMORY</code>系统参数设置索引内存。您还可以使用参数字符串中的<code class="codeph">CREATE INDEX</code> <code class="codeph">memory</code>参数在运行时设置索引内存。
                     </p>
                     <p>您应该将<code class="codeph">DEFAULT_INDEX_MEMORY</code>值设置为尽可能高，而不会导致分页。
                     </p>
                     <p>您还可以通过增加<code class="codeph">SORT_AREA_SIZE</code>系统参数来提高索引性能。
                     </p>
                     <p>Oracle建议您使用大型索引内存设置。大型设置，甚至高达数百兆字节，可以提高索引速度并减少最终索引的碎片。但是，如果将索引内存设置设置得太高，则内存分页会降低索引速度。</p>
                     <p>使用并行索引，每个流都需要自己的索引内存。处理非常大的表时，可以不同地调整数据库系统全局区域（SGA）以进行索引和检索。对于查询，您希望尽可能多地在SGA块缓冲区缓存中缓存信息。因此，您应该为块缓冲区缓存分配大量内存。因为这种方法对索引没有任何影响，所以最好减小SGA的大小，以便在索引期间为大型索引内存设置腾出更多空间。</p>
                     <p>您可以在Oracle数据库初始化文件中设置SGA的大小。</p>
                     <div class="infoboxnotealso" id="GUID-BBF8E750-E6C9-4149-AB88-8403EC583536__GUID-D9908D9A-EBDC-4258-A538-AED03646C7B4">
                        <p class="notep1">也可以看看：</p>
                        <p></p>
                        <ul style="list-style-type:disc">
                           <li>
                              <p><a href="../ccref/oracle-text-indexing-elements.html#CCREF0245" target="_blank"><span class="italic">Oracle Text Reference</span></a>了解有关Oracle Text系统参数的更多信息</p>
                           </li>
                           <li>
                              <p>有关设置SGA相关参数的详细信息，请参见<a href="../admin/managing-memory.html#ADMIN-GUID-BEABE53D-8058-4834-B99B-5C80A8AD5B06" target="_blank"><span class="italic">“Oracle数据库管理员指南”</span></a></p>
                           </li>
                           <li>
                              <p>有关内存分配的详细信息，请<a href="../tgdba/database-memory-allocation.html#TGDBA-GUID-E9265077-B296-485A-BC2C-0AF55762D1EC" target="_blank"><span class="italic">参见“Oracle数据库性能调整指南</span></a></p>
                           </li>
                           <li>
                              <p>有关设置<code class="codeph">SORT_AREA_SIZE</code>参数的详细信息，请<a href="../refrn/SORT_AREA_SIZE.html#REFRN-GUID-A343E04E-B484-4791-8B01-12E182AA00C7" target="_blank"><span class="italic">参见Oracle数据库参考</span></a></p>
                           </li>
                        </ul>
                     </div>
                  </div>
               </div><a id="CCAPP9275"></a><div class="props_rev_3"><a id="GUID-AF9AEA5F-7665-4342-8EC8-963701CABCB4" name="GUID-AF9AEA5F-7665-4342-8EC8-963701CABCB4"></a><h4 id="CCAPP-GUID-AF9AEA5F-7665-4342-8EC8-963701CABCB4" class="sect4"><span class="enumeration_section">10.10.3</span>索引需要多少磁盘开销？
                  </h4>
                  <div>
                     <p><span class="bold">答案：</span>开销，索引表所需的空间量，在原始文本卷的大约50％到200％之间变化。通常，较大量的文本会导致较小的开销，但许多小记录比较少的大记录使用更多的开销。此外，干净的数据（例如发布的文本）比诸如电子邮件或讨论笔记之类的脏数据需要更少的开销，因为脏数据可能包括许多拼写错误和缩写的单词。
                     </p>
                     <p>纯文本索引小于组合文本和主题索引。前缀和子字符串索引使索引显着增大。</p>
                  </div>
               </div><a id="CCAPP9276"></a><div class="props_rev_3"><a id="GUID-24EF49DB-AFFB-499C-BC57-000941C6833F" name="GUID-24EF49DB-AFFB-499C-BC57-000941C6833F"></a><h4 id="CCAPP-GUID-24EF49DB-AFFB-499C-BC57-000941C6833F" class="sect4"><span class="enumeration_section">10.10.4</span>我的数据格式如何影响索引？
                  </h4>
                  <div>
                     <p><span class="bold">答：</span>对于格式化文档（如Microsoft Word文件），您可以期望更低的存储开销，因为文档与其中保存的实际文本相比往往非常大。因此，1 GB的Word文档可能只需要50 MB的索引空间，而1 GB的纯文本可能需要500 MB，因为后者的纯文本数量是后者的十倍。
                     </p>
                     <p>索引时间不那么明确。尽管要编制索引的文本数量的减少具有明显的效果，但您必须将其与使用<code class="codeph">AUTO_FILTER</code>过滤器或其他用户定义的过滤器过滤文档的成本进行平衡。
                     </p>
                  </div>
               </div><a id="CCAPP9277"></a><div class="props_rev_3"><a id="GUID-7ADB0B30-0E1A-4308-B941-3BEEA5DEA5E5" name="GUID-7ADB0B30-0E1A-4308-B941-3BEEA5DEA5E5"></a><h4 id="CCAPP-GUID-7ADB0B30-0E1A-4308-B941-3BEEA5DEA5E5" class="sect4"><span class="enumeration_section">10.10.5</span>并行索引可以提高性能吗？
                  </h4>
                  <div>
                     <p><span class="bold">答：</span>当您拥有大量数据和多个CPU时，并行索引可以提高索引性能。
                     </p>
                     <p>使用<code class="codeph">PARALLEL</code>关键字创建最多包含三个独立索引进程的索引，具体取决于您的资源。
                     </p><pre class="oac_no_warn" dir="ltr">CREATE INDEX index_name ON table_name（column_name）INDEXTYPE IS ctxsys.context PARAMETERS（'...'）PARALLEL 3;</pre><p>您还可以使用并行索引在分区表上创建本地分区索引。但是，索引性能仅在多个CPU的情况下才会提高。</p>
                     <div class="infoboxnote" id="GUID-7ADB0B30-0E1A-4308-B941-3BEEA5DEA5E5__GUID-CCAE3B53-7729-4E68-8A52-9CF4D35A5954">
                        <p class="notep1">注意：</p>
                        <p>使用<code class="codeph">PARALLEL</code>创建本地分区索引可启用并行查询。（并行创建非分区索引不会启用并行查询处理。）
                        </p>
                        <p>并行查询会降低查询吞吐量，尤其是在负载较重的系统上。因此，Oracle建议您在并行索引后禁用并行查询。为此，请使用<code class="codeph">ALTER INDEX NOPARALLEL.</code></p>
                     </div>
                  </div>
               </div><a id="CCAPP9278"></a><div class="props_rev_3"><a id="GUID-EA5B318D-9D38-4D4E-925B-8FA9CFD81561" name="GUID-EA5B318D-9D38-4D4E-925B-8FA9CFD81561"></a><h4 id="CCAPP-GUID-EA5B318D-9D38-4D4E-925B-8FA9CFD81561" class="sect4"><span class="enumeration_section">10.10.6</span>创建本地分区索引时，如何提高索引性能？
                  </h4>
                  <div>
                     <p><span class="bold">答：</span>当您有多个CPU时，可以通过并行创建本地索引来提高索引性能。
                     </p>
                     <p>您可以通过以下方式并行创建本地分区索引：</p>
                     <ul style="list-style-type:disc">
                        <li>
                           <p>将<code class="codeph">PARALLEL</code>子句与<code class="codeph">CREATE INDEX</code>语句中的<code class="codeph">LOCAL</code>子句一起使用。在这种情况下，最大并行度限于分区数。
                           </p>
                        </li>
                        <li>
                           <p>创建一个不可用的索引，然后运行<code class="codeph">DBMS_PCLXUTIL.BUILD_PART_INDEX</code>实用程序。此方法可以实现更高的并行度，尤其是当您拥有的CPU数量多于分区时。
                           </p>
                        </li>
                     </ul>
                     <p>以下是第二种方法的示例。基表有三个分区。首先创建本地分区不可用索引，然后运行<code class="codeph">DBMS_PCLUTIL.BUILD_PART_INDEX</code> ，以并行构建三个分区（分区间并行）。在每个分区内部，索引创建并行发生（分区内并行），并行度为2。
                     </p><pre class="oac_no_warn" dir="ltr">在tdrbip02b上创建索引tdrbip02bx（文本）indextype是ctxsys.context local（分区tdrbip02bx1，分区tdrbip02bx2，分区tdrbip02bx3）不可用; exec dbms_pclxutil.build_part_index（3,2，'TDRBIP02B'，'TDRBIP02BX'，TRUE）;</pre></div>
               </div><a id="CCAPP9279"></a><div class="props_rev_3"><a id="GUID-E89DE5BB-7C25-4901-A890-B7925506A3DF" name="GUID-E89DE5BB-7C25-4901-A890-B7925506A3DF"></a><h4 id="CCAPP-GUID-E89DE5BB-7C25-4901-A890-B7925506A3DF" class="sect4"><span class="enumeration_section">10.10.7</span>如何判断索引<span class="enumeration_section">编制</span>完成了多少？
                  </h4>
                  <div>
                     <p><span class="bold">答案：</span>您可以使用<code class="codeph">CTX_OUTPUT.START_LOG</code>过程记录索引过程的输出。文件名通常写入<code class="codeph">$ORACLE_HOME/ctx/log,</code>但您可以使用<code class="codeph">LOG_DIRECTORY</code>中的<code class="codeph">LOG_DIRECTORY</code>参数更改目录<code class="codeph">CTX_ADM.SET_PARAMETER.</code></p>
                     <div class="infoboxnotealso" id="GUID-E89DE5BB-7C25-4901-A890-B7925506A3DF__GUID-45113A64-4C60-423E-B5D5-9F3753B6108B">
                        <p class="notep1">也可以看看：</p>
                        <p><a href="../ccref/CTX_OUTPUT-package.html#CCREF0800" target="_blank"><span class="italic">Oracle Text Reference</span></a>了解有关<code class="codeph">CTX_OUTPUT</code>包的更多信息</p>
                     </div>
                  </div>
               </div>
            </div><a id="CCAPP9280"></a><div class="props_rev_3"><a id="GUID-45D2A9BB-17BC-4B68-A3F1-A0C01B4ACDA3" name="GUID-45D2A9BB-17BC-4B68-A3F1-A0C01B4ACDA3"></a><h3 id="CCAPP-GUID-45D2A9BB-17BC-4B68-A3F1-A0C01B4ACDA3" class="sect3"><span class="enumeration_section">10.11</span>关于更新索引的常见问题解答</h3>
               <div>
                  <p>本节回答有关更新索引和相关性能问题的一些常见问题。</p>
                  <ul style="list-style-type:disc">
                     <li>
                        <p><a href="tuning-oracle-text.html#GUID-995688F6-F94E-428E-8801-F8C9A9238E42">我应该多久索引新的或更新的记录？</a></p>
                     </li>
                     <li>
                        <p><a href="tuning-oracle-text.html#GUID-BA566D03-EB35-4FE0-9786-040828D2AFC8">如何判断我的索引是否碎片化？</a></p>
                     </li>
                     <li>
                        <p><a href="tuning-oracle-text.html#GUID-5F422D6F-6965-43F5-ABDF-AC449F539030">内存分配是否影响索引同步？</a></p>
                     </li>
                  </ul>
               </div><a id="CCAPP9281"></a><div class="props_rev_3"><a id="GUID-995688F6-F94E-428E-8801-F8C9A9238E42" name="GUID-995688F6-F94E-428E-8801-F8C9A9238E42"></a><h4 id="CCAPP-GUID-995688F6-F94E-428E-8801-F8C9A9238E42" class="sect4"><span class="enumeration_section">10.11.1</span>我应该多久索引新的或更新的记录？
                  </h4>
                  <div>
                     <p><span class="bold">答：</span>如果您经常使用<code class="codeph">CTX_DDL.SYNC_INDEX</code>重新<code class="codeph">CTX_DDL.SYNC_INDEX</code>索引，那么您的索引将更少碎片化，您不必经常优化它们。
                     </p>
                     <p>但是，您的数据会逐渐变得过时，这对您的用户来说可能是不可接受的。</p>
                     <p>对许多系统来说，隔夜索引是可以接受的。在这种情况下，不到一天的数据是不可搜索的。其他系统使用每小时，10分钟或5分钟的更新。</p>
                     <div class="infoboxnotealso" id="GUID-995688F6-F94E-428E-8801-F8C9A9238E42__GUID-DB5881A8-6AF8-4D4D-822B-093C37AFEFC8">
                        <p class="notep1">也可以看看：</p>
                        <p></p>
                        <ul style="list-style-type:disc">
                           <li>
                              <p><a href="../ccref/CTX_DDL-package.html#CCREF0652" target="_blank"><span class="italic">Oracle Text Reference</span></a>了解有关使用<code class="codeph">CTX_DDL.SYNC_INDEX</code>更多信息</p>
                           </li>
                           <li>
                              <p><span class="q">“ <a href="maintaining-oracle-text-indexes.html#GUID-4313B6A6-510F-41E8-9B5C-3559F42742D4">管理CONTEXT索引的DML操作</a> ”</span></p>
                           </li>
                        </ul>
                     </div>
                  </div>
               </div><a id="CCAPP9282"></a><div class="props_rev_3"><a id="GUID-BA566D03-EB35-4FE0-9786-040828D2AFC8" name="GUID-BA566D03-EB35-4FE0-9786-040828D2AFC8"></a><h4 id="CCAPP-GUID-BA566D03-EB35-4FE0-9786-040828D2AFC8" class="sect4"><span class="enumeration_section">10.11.2</span>如何区分索引的碎片？
                  </h4>
                  <div>
                     <p><span class="bold">答：</span>最好的方法是为一些查询计时，运行索引优化，然后对相同的查询进行计时（当然，每次重新启动数据库以清除SGA）。如果查询速度显着提高，那么优化是值得的。如果他们不这样做，那么下次你可以等待更长时间。
                     </p>
                     <p>您还可以使用<code class="codeph">CTX_REPORT.INDEX_STATS</code>来分析索引碎片。
                     </p>
                     <div class="infoboxnotealso" id="GUID-BA566D03-EB35-4FE0-9786-040828D2AFC8__GUID-E9A1BAE9-0FEE-4B06-9E92-00C5F7698BA1">
                        <p class="notep1">也可以看看：</p>
                        <p></p>
                        <ul style="list-style-type:disc">
                           <li>
                              <p><a href="../ccref/CTX_REPORT-package.html#CCREF1100" target="_blank"><span class="italic">Oracle Text Reference</span></a>了解有关使用<code class="codeph">CTX_REPORT</code>包的更多信息</p>
                           </li>
                           <li>
                              <p><span class="q">“ <a href="maintaining-oracle-text-indexes.html#GUID-9960D8E4-0AE8-48B0-82D5-B203695463DE">优化指数</a> ”</span></p>
                           </li>
                        </ul>
                     </div>
                  </div>
               </div><a id="CCAPP9283"></a><div class="props_rev_3"><a id="GUID-5F422D6F-6965-43F5-ABDF-AC449F539030" name="GUID-5F422D6F-6965-43F5-ABDF-AC449F539030"></a><h4 id="CCAPP-GUID-5F422D6F-6965-43F5-ABDF-AC449F539030" class="sect4"><span class="enumeration_section">10.11.3</span>内存分配是否会影响索引同步？
                  </h4>
                  <div>
                     <p><span class="bold">答：</span>是的，与正常索引相同。在同步操作期间索引的记录通常要少得多，因此通常不需要提供数百兆的索引内存。
                     </p>
                  </div>
               </div>
            </div>
         </div>
      </article>
   </body>
</html>