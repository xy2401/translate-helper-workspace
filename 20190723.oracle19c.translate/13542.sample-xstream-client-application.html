<html lang="en-us" dir="ltr" xml:lang="en-us">
   <head>
      <meta http-equiv="Content-Type" content="text/html; charset=utf-8"></meta>
      <meta name="viewport" content="width=device-width, initial-scale=1"></meta>
      <meta http-equiv="X-UA-Compatible" content="IE=edge"></meta>
      <meta name="abstract" content="Examples illustrate how to configure the Oracle Database components that are used by XStream. The examples configure sample client applications that communicate with an XStream outbound server and inbound server."></meta>
      <meta name="description" content="Examples illustrate how to configure the Oracle Database components that are used by XStream. The examples configure sample client applications that communicate with an XStream outbound server and inbound server."></meta>
      <title>示例XStream客户端应用程序</title>
      <meta property="og:site_name" content="Oracle Help Center"></meta>
      <meta property="og:title" content="XStream Guide "></meta>
      <meta property="og:description" content="Examples illustrate how to configure the Oracle Database components that are used by XStream. The examples configure sample client applications that communicate with an XStream outbound server and inbound server."></meta>
      <link rel="stylesheet" href="/sp_common/book-template/ohc-book-template/css/book.css"></link>
      <link rel="shortcut icon" href="/sp_common/book-template/ohc-common/img/favicon.ico"></link>
      <meta name="application-name" content="XStream Guide"></meta>
      <meta name="generator" content="DITA Open Toolkit version 1.8.5 (Mode = doc)"></meta>
      <meta name="plugin" content="SP_docbuilder HTML plugin release 18.2.2"></meta>
      <link rel="alternate" href="xstream-guide.pdf" title="PDF File" type="application/pdf"></link>
      <meta name="robots" content="all"></meta>
      <link rel="schema.dcterms" href="http://purl.org/dc/terms/"></link>
      <meta name="dcterms.created" content="2019-01-07T01:45:15-08:00"></meta>
      
      <meta name="dcterms.dateCopyrighted" content="2009, 2019"></meta>
      <meta name="dcterms.category" content="database"></meta>
      <meta name="dcterms.identifier" content="E96280-01"></meta>
      
      <meta name="dcterms.product" content="en/database/oracle/oracle-database/19"></meta>
      
      <link rel="prev" href="appendixes.html" title="Previous" type="text/html"></link>
      <link rel="next" href="xstream-out-restrictions.html" title="Next" type="text/html"></link>
      <script>
        document.write('<style type="text/css">');
        document.write('body > .noscript, body > .noscript ~ * { visibility: hidden; }');
        document.write('</style>');
     </script>
      <script src="/sp_common/book-template/requirejs/require.js" data-main="/sp_common/book-template/ohc-book-template/js/book-config"></script>
      <script>
            if (window.require === undefined) {
                document.write('<script data-main="sp_common/book-template/ohc-book-template/js/book-config" src="sp_common/book-template/requirejs/require.js"><\/script>');
                document.write('<link href="sp_common/book-template/ohc-book-template/css/book.css" rel="stylesheet"/>');
            }
        </script>
      <script type="application/json" id="ssot-metadata">{"primary":{"category":{"short_name":"database","element_name":"Database","display_in_url":true},"suite":{"short_name":"oracle","element_name":"Oracle","display_in_url":true},"product_group":{"short_name":"not-applicable","element_name":"Not applicable","display_in_url":false},"product":{"short_name":"oracle-database","element_name":"Oracle Database","display_in_url":true},"release":{"short_name":"19","element_name":"Release 19","display_in_url":true}}}</script>
      
    <meta name="dcterms.title" content="XStream Guide"></meta>
    <meta name="dcterms.isVersionOf" content="XSTRM"></meta>
    <meta name="dcterms.release" content="Release 19"></meta>
  </head>
   <body dir="ltr">
      <div class="noscript alert alert-danger text-center" role="alert">
         <a href="appendixes.html" class="pull-left"><span class="glyphicon glyphicon-chevron-left" aria-hidden="true"></span>上一页</a> <a href="xstream-out-restrictions.html" class="pull-right">下一页<span class="glyphicon glyphicon-chevron-right" aria-hidden="true"></span></a> <span class="fa fa-exclamation-triangle" aria-hidden="true"></span>必须启用JavaScript才能正确显示此内容</div>
      <article>
         <header>
            <ol class="breadcrumb" vocab="http://schema.org/" typeof="BreadcrumbList">
               <li property="itemListElement" typeof="ListItem"><a href="index.html" property="item" typeof="WebPage"><span property="name">XStream指南</span></a></li>
               <li property="itemListElement" typeof="ListItem"><a href="appendixes.html" property="item" typeof="WebPage"><span property="name">附录</span></a></li>
               <li class="active" property="itemListElement" typeof="ListItem">示例XStream客户端应用程序</li>
            </ol>
            <a id="GUID-B914FF75-92AA-4270-BF71-E9A5AA9228F8" name="GUID-B914FF75-92AA-4270-BF71-E9A5AA9228F8"></a>
            
            <h2 id="XSTRM-GUID-B914FF75-92AA-4270-BF71-E9A5AA9228F8" class="sect2"><span class="enumeration_chapter">A</span>样品XStream的客户端应用程序</h2>
         </header>
         <div class="ind">
            <div>
               <p>示例说明如何配置XStream使用的Oracle数据库组件。这些示例配置与XStream出站服务器和入站服务器通信的示例客户端应用程序。</p>
            </div>
            <div>
               <ul class="ullinks">
                  <li class="ulchildlink"><a href="sample-xstream-client-application.html#GUID-0C0C8EC2-3730-4294-B8D8-D865DF5CAC94">关于Sample XStream客户端应用程序</a><br>示例XStream客户端应用程序说明了XStream Out和XStream In应用程序所需的基本任务。
                  </li>
                  <li class="ulchildlink"><a href="sample-xstream-client-application.html#GUID-E54E3782-5710-4889-B206-77CCB5BE0EB4">Oracle Call Interface API的示例XStream客户端应用程序</a><br>要为OCI API运行示例XStream客户端应用程序，请编译并链接应用程序文件。
                  </li>
                  <li class="ulchildlink"><a href="sample-xstream-client-application.html#GUID-952CEB45-9E0D-49AE-853A-912524B49853">Java API的示例XStream客户端应用程序</a><br>要为Java API运行示例XStream客户端应用程序，请编译并链接应用程序文件。
                  </li>
               </ul>
               <div class="infoboxnotealso" id="GUID-B914FF75-92AA-4270-BF71-E9A5AA9228F8__GUID-23B0AF79-7AA7-43A2-8A86-14BDFBF48D7E">
                  <p class="notep1">也可以看看：</p>
                  <ul style="list-style-type:disc">
                     <li>
                        <p><span class="q">“ <a href="xstream-out-concepts.html#GUID-B59B1F79-91F6-4495-B946-5DCEB317E0D6" title="熟悉与XStream Out相关的概念。">XStream Out Concepts</a> ”</span></p>
                     </li>
                     <li>
                        <p><span class="q">“ <a href="introduction-to-xstream.html#GUID-21FC23DF-2881-4CFD-AF74-9A1173D768FF" title="有几种常见的XStream用例。">XStream用例</a> ”</span></p>
                     </li>
                     <li>
                        <p><a href="../lnoci/intro-to-oci-interface-for-XStream.html#LNOCI72903" target="_blank"><span><cite>Oracle调用接口程序员指南</cite></span></a></p>
                     </li>
                     <li>
                        <p><a href="../stxjv/index.html" target="_blank"><span><cite>Oracle数据库XStream Java API参考</cite></span></a></p>
                     </li>
                  </ul>
               </div>
               <div class="familylinks">
                  <div class="parentlink">
                     <p><strong>父主题：</strong> <a href="appendixes.html#GUID-08D451B5-2D76-447B-B39B-20CC73110D19" title="附录包括有关XStream客户端应用程序和XStream限制的信息。">附录</a></p>
                  </div>
               </div>
            </div>
            <a id="XSTRM1640"></a><a id="XSTRM1568"></a><a id="XSTRM72732"></a><div class="props_rev_3"><a id="GUID-0C0C8EC2-3730-4294-B8D8-D865DF5CAC94" name="GUID-0C0C8EC2-3730-4294-B8D8-D865DF5CAC94"></a><h3 id="XSTRM-GUID-0C0C8EC2-3730-4294-B8D8-D865DF5CAC94" class="sect3"><span class="enumeration_section">A.1</span>关于示例XStream客户端应用程序</h3>
               <div>
                  <p>示例XStream客户端应用程序说明了XStream Out和XStream In应用程序所需的基本任务。</p>
                  <p>该应用程序执行以下任务：</p>
                  <ul style="list-style-type:disc">
                     <li>
                        <p>它附加到XStream出站服务器和入站服务器，并等待来自出站服务器的LCR。出站服务器和入站服务器位于两个不同的数据库中。</p>
                     </li>
                     <li>
                        <p>当它从出站服务器收到LCR时，它会立即将LCR发送到入站服务器。</p>
                     </li>
                     <li>
                        <p>它定期从入站服务器获取已处理的低位置，并将此值发送到出站服务器。</p>
                     </li>
                     <li>
                        <p>它定期从出站服务器向入站服务器发送“ping”LCR，以便在活动较少时将入站服务器处理的低位置向前移动。</p>
                     </li>
                  </ul>
                  <p>在不将LCR发送到入站服务器的XStream Out配置中，客户端应用程序必须以另一种方式获取已处理的低位置。</p>
                  <p>此应用程序无限期地等待来自出站服务器的事务。要中断应用程序，请输入操作系统的中断命令。例如，某些操作系统上的中断命令是<code class="codeph">control-C</code> 。如果程序重新启动，则出站服务器开始从上一次运行期间设置的已处理低位发送LCR。
                  </p>
                  <p><a href="sample-xstream-client-application.html#GUID-0C0C8EC2-3730-4294-B8D8-D865DF5CAC94__CBDIHADI">图A-1</a>提供了本节中配置的XStream环境的概述。
                  </p>
                  <div class="figure" id="GUID-0C0C8EC2-3730-4294-B8D8-D865DF5CAC94__CBDIHADI">
                     <p class="titleinfigure">图A-1 XStream配置示例</p><img src="img/xstrm508.gif" width="600" alt="下面是图A-1的描述" title="下面是图A-1的描述" longdesc="img_text/xstrm508.html"><br><a href="img_text/xstrm508.html">“图A-1 XStream配置示例”的说明</a></div>
                  <!-- class="figure" -->
                  <p>在运行示例应用程序之前，请确保存在以下组件：</p>
                  <ul style="list-style-type:disc">
                     <li>
                        <p>两个Oracle数据库，它们之间具有网络连接</p>
                     </li>
                     <li>
                        <p>两个数据库上的XStream管理员</p>
                     </li>
                     <li>
                        <p>一个数据库上的出站服务器配置，包括捕获进程，队列和出站服务器</p>
                     </li>
                     <li>
                        <p>另一个数据库上的入站服务器配置</p>
                     </li>
                  </ul>
                  <p>如果您使用多租户容器数据库（CDB）运行示例应用程序，请确保客户端应用程序连接到正确的容器：</p>
                  <ul style="list-style-type:disc">
                     <li>
                        <p>当客户端应用程序连接到出站服务器时，它必须连接到根。</p>
                     </li>
                     <li>
                        <p>当客户端应用程序连接到入站服务器时，它必须连接到创建入站服务器的容器。</p>
                     </li>
                  </ul>
                  <p>以下部分中的示例应用程序执行相同的任务。一个示例应用程序使用OCI API，另一个使用Java API。</p>
                  <ul style="list-style-type:disc">
                     <li>
                        <p><a href="sample-xstream-client-application.html#GUID-E54E3782-5710-4889-B206-77CCB5BE0EB4" title="要为OCI API运行示例XStream客户端应用程序，请编译并链接应用程序文件。">Oracle Call Interface API的示例XStream客户端应用程序</a></p>
                     </li>
                     <li>
                        <p><a href="sample-xstream-client-application.html#GUID-952CEB45-9E0D-49AE-853A-912524B49853" title="要为Java API运行示例XStream客户端应用程序，请编译并链接应用程序文件。">Java API的示例XStream客户端应用程序</a></p>
                     </li>
                  </ul>
                  <div class="infoboxnote" id="GUID-0C0C8EC2-3730-4294-B8D8-D865DF5CAC94__GUID-4231CE64-849C-4E9B-BDE1-268608E66A2E">
                     <p class="notep1">注意：</p>
                     <p>Oracle数据库安装包括几个XStream演示。这些演示位于以下位置：</p><pre class="oac_no_warn" dir="ltr">$ ORACLE_HOME / RDBMS /演示/ XStream的</pre></div>
               </div>
               <div>
                  <div class="infoboxnotealso" id="GUID-0C0C8EC2-3730-4294-B8D8-D865DF5CAC94__GUID-EA6145CF-AA41-47AE-BB6E-900BE0424BA2">
                     <p class="notep1">也可以看看：</p>
                     <ul style="list-style-type:disc">
                        <li>
                           <p><span class="q">“ <a href="general-xstream-concepts.html#GUID-077AAE24-54CF-4102-9969-9540608FFB65" title="每个LCR都有一个位置属性。LCR的位置标识其在交易中的LCR流中的位置。">在LCR流中定位订单</a> ”</span></p>
                        </li>
                        <li>
                           <p><span class="q">“ <a href="configuring-xstream-out.html#GUID-1338E648-E214-4666-98A1-8B8D0085EB23" title="您可以配置XStream Out使用的Oracle数据库组件。">配置XStream Out</a> ”</span></p>
                        </li>
                        <li>
                           <p><span class="q">“ <a href="configuring-xstream-in.html#GUID-B0F20D2D-7F63-4CE6-B15F-435B5A3DFBED" title="您可以配置XStream使用的Oracle数据库组件。">配置XStream</a> ”</span></p>
                        </li>
                        <li>
                           <p><a href="../arpls/DBMS_XSTREAM_AUTH.html#ARPLS73653" target="_blank"><span><cite>Oracle数据库PL / SQL包和类型参考</cite></span></a></p>
                        </li>
                     </ul>
                  </div>
                  <div class="familylinks">
                     <div class="parentlink">
                        <p><strong>父主题：</strong> <a href="sample-xstream-client-application.html#GUID-B914FF75-92AA-4270-BF71-E9A5AA9228F8" title="示例说明如何配置XStream使用的Oracle数据库组件。这些示例配置与XStream出站服务器和入站服务器通信的示例客户端应用程序。">示例XStream客户端应用程序</a></p>
                     </div>
                  </div>
               </div>
               
            </div><a id="XSTRM1569"></a><div class="props_rev_3"><a id="GUID-E54E3782-5710-4889-B206-77CCB5BE0EB4" name="GUID-E54E3782-5710-4889-B206-77CCB5BE0EB4"></a><h3 id="XSTRM-GUID-E54E3782-5710-4889-B206-77CCB5BE0EB4" class="sect3"><span class="enumeration_section">A.2</span> Oracle Call Interface API的示例XStream客户端应用程序</h3>
               <div>
                  <p>要为OCI API运行示例XStream客户端应用程序，请编译并链接应用程序文件。</p>
                  <p>接下来，在命令行中输入以下内容：</p><pre class="oac_no_warn" dir="ltr">xio -ob_svr <span class="italic">xout_name</span> -ob_db <span class="italic">sn_xout_db</span> -ob_usr <span class="italic">xout_cu</span> -ob_pwd <span class="italic">xout_cu_pass</span> -ib_svr <span class="italic">xin_name</span> -ib_db <span class="italic">sn_xin_db</span> -ib_usr <span class="italic">xin_au</span> -ib_pwd <span class="italic">xin_au_pass</span>
</pre><p>替换以下占位符的适当值：</p>
                  <ul style="list-style-type:disc">
                     <li>
                        <p><span class="italic">xout_name</span>是出站服务器的名称。
                        </p>
                     </li>
                     <li>
                        <p><span class="italic">sn_xout_db</span>是出站服务器数据库的服务名称。
                        </p>
                     </li>
                     <li>
                        <p><span class="italic">xout_cu</span>是出站服务器的连接用户。
                        </p>
                     </li>
                     <li>
                        <p><span class="italic">xout_cu_pass</span>是出站服务器的连接用户的密码。
                        </p>
                     </li>
                     <li>
                        <p><span class="italic">xin_name</span>是入站服务器的名称。
                        </p>
                     </li>
                     <li>
                        <p><span class="italic">sn_xin_db</span>是入站服务器数据库的服务名称。
                        </p>
                     </li>
                     <li>
                        <p><span class="italic">xin_au</span>是入站服务器的应用用户。
                        </p>
                     </li>
                     <li>
                        <p><span class="italic">xin_au_pass</span>是入站服务器的应用用户的密码。
                        </p>
                     </li>
                  </ul>
                  <p>示例客户端应用程序运行时，它会打印有关正在处理的行LCR的信息。输出类似于以下内容：</p><pre class="oac_no_warn" dir="ltr">----------- ROW LCR标题----------------- src_db_name = DB.EXAMPLE.COM cmd_type = UPDATE txid = 17.0.74 owner = HR oname = COUNTRIES ----------- ROW LCR标题----------------- src_db_name = DB.EXAMPLE.COM cmd_type = COMMIT txid = 17.0.74  - --------- ROW LCR标题----------------- src_db_name = DB.EXAMPLE.COM cmd_type = UPDATE txid = 12.25.77 owner = OE oname = ORDERS ----------- ROW LCR标题----------------- src_db_name = DB.EXAMPLE.COM cmd_type = UPDATE txid = 12.25.77 owner = OE oname =订单</pre><p>此输出包含每行LCR的以下信息：</p>
                  <ul style="list-style-type:disc">
                     <li>
                        <p><code class="codeph">src_db_name</code>显示封装在行LCR中的更改的源数据库。</p>
                     </li>
                     <li>
                        <p><code class="codeph">cmd_type</code>显示进行更改的SQL语句的类型。
                        </p>
                     </li>
                     <li>
                        <p><code class="codeph">txid</code>显示包含行LCR的事务的事务ID。</p>
                     </li>
                     <li>
                        <p><code class="codeph">owner</code>显示已更改的数据库对象的所有者。
                        </p>
                     </li>
                     <li>
                        <p><code class="codeph">oname</code>显示已更改的数据库对象的名称。
                        </p>
                     </li>
                  </ul>
                  <p>此演示位于以下位置：</p><pre class="oac_no_warn" dir="ltr">$ ORACLE_HOME / RDBMS /演示/ XStream的/ OCI</pre><p>演示的文件名是<code class="codeph">xio.c</code>有关编译和运行应用程序的更多信息，请参阅演示目录中的<code class="codeph">README.txt</code>文件。
                  </p>
                  <p>使用OCI API的示例应用程序的代码如下：</p><pre class="oac_no_warn" dir="ltr">#ifndef OCI_ORACLE #include &lt;oci.h&gt; #endif #ifndef _STDIO_H #include &lt;stdio.h&gt; #endif #ifndef _STDLIB_H #include &lt;stdlib.h&gt; #endif #ifndef _STRING_H #include &lt;string.h&gt; #endif #ifndef _MALLOC_H #include &lt;malloc.h&gt; #endif / * -------------------------------------- -------------------------------- *内部结构* -------------- -------------------------------------------------- ------ * / #define M_DBNAME_LEN（128）typedef struct conn_info / * connect info * / {oratext * user; ub4 userlen; oratext * passw; ub4 passwlen; oratext * dbname; ub4 dbnamelen; oratext * svrnm; ub4 svrnmlen; } conn_info_t; typedef struct params {conn_info_t xout; / *出站信息* / conn_info_t xin; / *入站信息* /} params_t; typedef struct oci / * OCI处理* / {OCIEnv * envp; / *环境句柄* / OCIError * errp; / *错误句柄* / OCIServer * srvp; / *服务器句柄* / OCISvcCtx * svcp; / *服务句柄* / OCISession * authp; OCIStmt * stmtp;布尔附加;布尔出站; } oci_t; static void connect_db（conn_info_t * opt_params_p，oci_t ** ocip，ub2 char_csid，ub2 nchar_csid）; static void disconnect_db（oci_t * ocip）; static void ocierror（oci_t * ocip，char * msg）; static void attach（oci_t * ocip，conn_info_t * conn，boolean outbound）; static void detach（oci_t * ocip）; static void get_lcrs（oci_t * xin_ocip，oci_t * xout_ocip）; static void get_chunks（oci_t * xin_ocip，oci_t * xout_ocip）; static void print_lcr（oci_t * ocip，void * lcrp，ub1 lcrtype，oratext ** src_db_name，ub2 * src_db_namel）; static void print_chunk（ub1 * chunk_ptr，ub4 chunk_len，ub2 dty）; static void get_inputs（conn_info_t * xout_params，conn_info_t * xin_params，int argc，char ** argv）; static void get_db_charsets（conn_info_t * params_p，ub2 * char_csid，ub2 * nchar_csid）; static void set_client_charset（oci_t * outbound_ocip）; #define OCICALL（ocip，function）do {\ sword status = function; \ if（OCI_SUCCESS == status）break; \ else if（OCI_ERROR == status）\ {ocierror（ocip，（char *）“OCI_ERROR”）; \ exit（1）;} \ else {printf（“遇到错误％d \ n”，状态）; \ exit（1）;} \} while（0）/ * ----------- -------------------------------------------------- -------- * MAINPROGRAM * --------------------------------------- ------------------------------ * / main（int argc，char ** argv）{/ *出站和入站连接信息* / conn_info_t xout_params; conn_info_t xin_params; oci_t * xout_ocip =（oci_t *）NULL; oci_t * xin_ocip =（oci_t *）NULL; ub2 obdb_char_csid = 0; / * outbound db char csid * / ub2 obdb_nchar_csid = 0; / * outbound db nchar csid * / / *解析命令行参数* / get_inputs（＆xout_params，＆xin_params，argc，argv）; / *获取出站数据库CHAR和NCHAR字符集信息* / get_db_charsets（＆xout_params，＆obdb_char_csid，＆obdb_nchar_csid）; / *连接到出站数据库并将客户端env设置为出站字符集*，以便在将LCR从出站*直接传输到入站服务器时最小化字符转换。* / connect_db（＆xout_params，＆xout_ocip，obdb_char_csid，obdb_nchar_csid）; / *附加到出站服务器* / attach（xout_ocip，＆xout_params，TRUE）; / *连接到入站数据库并将客户端字符集设置为与*出站数据库字符集相同。* / connect_db（＆xin_params，＆xin_ocip，obdb_char_csid，obdb_nchar_csid）; / *附加到入站服务器* / attach（xin_ocip，＆xin_params，FALSE）; / *从出站服务器获取lcrs并发送到入站服务器* / get_lcrs（xin_ocip，xout_ocip）; / *从XStream服务器分离* / detach（xout_ocip）;分离（xin_ocip）; / *从两个数据库断开连接* / disconnect_db（xout_ocip）; disconnect_db（xin_ocip）;自由（xout_ocip）;自由（xin_ocip）;退出（0）; } / * ----------------------------------------------- ---------------------- * connect_db  - 连接到数据库并将env设置为给定的* char和nchar字符集id。* ------------------------------------------------- -------------------- * / static void connect_db（conn_info_t * params_p，oci_t ** ociptr，ub2 char_csid，ub2 nchar_csid）{oci_t * ocip; printf（“以％作为％。* s @％。*”连接到Oracle，params_p-&gt; userlen，params_p-&gt; user，params_p-&gt; dbnamelen，params_p-&gt; dbname）; if（char_csid &amp;&amp; nchar_csid）printf（“使用char csid =％d和nchar csid =％d”，char_csid，nchar_csid）;的printf（ “\ n”）; ocip =（oci_t *）malloc（sizeof（oci_t））; if（OCIEnvNlsCreate（＆ocip-&gt; envp，OCI_OBJECT，（dvoid *）0，（dvoid *（*）（dvoid *，size_t））0，（dvoid *（*）（dvoid *，dvoid *，size_t））0， （void（*）（dvoid *，dvoid *））0，（size_t）0，（dvoid **）0，char_csid，nchar_csid））{ocierror（ocip，（char *）“OCIEnvCreate（）failed”）; } if（OCIHandleAlloc（（dvoid *）ocip-&gt; envp，（dvoid **）＆ocip-&gt; errp，（ub4）OCI_HTYPE_ERROR，（size_t）0，（dvoid **）0））{ocierror（ocip，（char * ）“OCIHandleAlloc（OCI_HTYPE_ERROR）失败”）; } / *登录到数据库* / OCICALL（ocip，OCILogon（ocip-&gt; envp，ocip-&gt; errp，＆ocip-&gt; svcp，params_p-&gt; user，params_p-&gt; userlen，params_p-&gt; passw，params_p-&gt; passwlen，params_p - &gt; dbname，params_p-&gt; dbnamelen））; / *分配服务器句柄* / OCICALL（ocip，OCIHandleAlloc（（dvoid *）ocip-&gt; envp，（dvoid **）＆ocip-&gt; srvp，OCI_HTYPE_SERVER，（size_t）0，（dvoid **）0））; OCICALL（ocip，OCIHandleAlloc（（dvoid *）ocip-&gt; envp，（dvoid **）＆ocip-&gt; stmtp，（ub4）OCI_HTYPE_STMT，（size_t）0，（dvoid **）0））; if（* ociptr ==（oci_t *）NULL）{* ociptr = ocip; } / * ---------------------------------------------- ----------------------- * get_db_charsets  - 获取数据库CHAR和NCHAR字符集ID。* ------------------------------------------------- -------------------- * / static const oratext GET_DB_CHARSETS [] = \“select parameter，value from nls_database_parameters where parameter = \'NLS_CHARACTERSET'或parameter ='NLS_NCHAR_CHARACTERSET' “; #define PARM_BUFLEN（30）static void get_db_charsets（conn_info_t * params_p，ub2 * char_csid，ub2 * nchar_csid）{OCIDefine * defnp1 =（OCIDefine *）NULL; OCIDefine * defnp2 =（OCIDefine *）NULL; oratext parm [PARM_BUFLEN]; oratext值[OCI_NLS_MAXBUFSZ]; ub2 parm_len = 0; ub2 value_len = 0; oci_t ocistruct; oci_t * ocip =＆ocistruct; * char_csid = 0; * nchar_csid = 0; memset（ocip，0，sizeof（ocistruct））; if（OCIEnvCreate（＆ocip-&gt; envp，OCI_OBJECT，（dvoid *）0，（dvoid *（*）（dvoid *，size_t））0，（dvoid *（*）（dvoid *，dvoid *，size_t））0， （void（*）（dvoid *，dvoid *））0，（size_t）0，（dvoid **）0））{ocierror（ocip，（char *）“OCIEnvCreate（）failed”）; } if（OCIHandleAlloc（（dvoid *）ocip-&gt; envp，（dvoid **）＆ocip-&gt; errp，（ub4）OCI_HTYPE_ERROR，（size_t）0，（dvoid **）0））{ocierror（ocip，（char * ）“OCIHandleAlloc（OCI_HTYPE_ERROR）失败”）; } OCICALL（ocip，OCILogon（ocip-&gt; envp，ocip-&gt; errp，＆ocip-&gt; svcp，params_p-&gt; user，params_p-&gt; userlen，params_p-&gt; passw，params_p-&gt; passwlen，params_p-&gt; dbname，params_p-&gt; dbnamelen））; OCICALL（ocip，OCIHandleAlloc（（dvoid *）ocip-&gt; envp，（dvoid **）＆ocip-&gt; stmtp，（ub4）OCI_HTYPE_STMT，（size_t）0，（dvoid **）0））; / *执行stmt以选择db nls char和nchar字符集* / OCICALL（ocip，OCIStmtPrepare（ocip-&gt; stmtp，ocip-&gt; errp，（CONST text *）GET_DB_CHARSETS，（ub4）strlen（（char *）GET_DB_CHARSETS） ，（ub4）OCI_NTV_SYNTAX，（ub4）OCI_DEFAULT））; OCICALL（ocip，OCIDefineByPos（ocip-&gt; stmtp，＆defnp1，ocip-&gt; errp，（ub4）1，parm，PARM_BUFLEN，SQLT_CHR，（void *）0，＆parm_len，（ub2 *）0，OCI_DEFAULT））; OCICALL（ocip，OCIDefineByPos（ocip-&gt; stmtp，＆defnp2，ocip-&gt; errp，（ub4）2，value，OCI_NLS_MAXBUFSZ，SQLT_CHR，（void *）0，＆value_len，（ub2 *）0，OCI_DEFAULT））; OCICALL（ocip，OCIStmtExecute（ocip-&gt; svcp，ocip-&gt; stmtp，ocip-&gt; errp，（ub4）0，（ub4）0，（const OCISnapshot *）0，（OCISnapshot *）0，（ub4）OCI_DEFAULT）） ; while（OCIStmtFetch（ocip-&gt; stmtp，ocip-&gt; errp，1，OCI_FETCH_NEXT，OCI_DEFAULT）== OCI_SUCCESS）{value [value_len] ='\ 0'; if（parm_len == strlen（“NLS_CHARACTERSET”）&amp;&amp;！memcmp（parm，“NLS_CHARACTERSET”，parm_len））{* char_csid = OCINlsCharSetNameToId（ocip-&gt; envp，value）; printf（“出站数据库NLS_CHARACTERSET =％。* s（csid =％d）\ n”，value_len，value，* char_csid）; } else if（parm_len == strlen（“NLS_NCHAR_CHARACTERSET”）&amp;&amp;！memcmp（parm，“NLS_NCHAR_CHARACTERSET”，parm_len））{* nchar_csid = OCINlsCharSetNameToId（ocip-&gt; envp，value）; printf（“出站数据库NLS_NCHAR_CHARACTERSET =％。* s（csid =％d）\ n”，value_len，value，* nchar_csid）; disconnect_db（ocip）; } / * ----------------------------------------------- ---------------------- * attach  - 附加到连接信息中指定的XStream服务器* ---------------- -------------------------------------------------- --- * / static void attach（oci_t * ocip，conn_info_t * conn，boolean outbound）{sword err; printf（“附加到XStream％s服务器'％。* s'\ n”，出站？“outbound”：“inbound”，conn-&gt; svrnmlen，conn-&gt; svrnm）; if（outbound）{OCICALL（ocip，OCIXStreamOutAttach（ocip-&gt; svcp，ocip-&gt; errp，conn-&gt; svrnm，（ub2）conn-&gt; svrnmlen，（ub1 *）0,0，OCI_DEFAULT））; } else {OCICALL（ocip，OCIXStreamInAttach（ocip-&gt; svcp，ocip-&gt; errp，conn-&gt; svrnm，（ub2）conn-&gt; svrnmlen，（oratext *）“From_XOUT”，9，（ub1 *）0,0， OCI_DEFAULT））; } ocip-&gt; attached = TRUE; ocip-&gt; outbound = outbound; } / * ----------------------------------------------- ---------------------- * ping_svr  - 通过发送提交LCR来Ping入站服务器。 * ------------------------------------------------- -------------------- * / static void ping_svr（oci_t * xin_ocip，void * commit_lcr，ub1 * cmtpos，ub2 cmtpos_len，oratext * source_db，ub2 source_db_len）{OCIDate src_time; oratext txid [128]; OCICALL（xin_ocip，OCIDateSysDate（xin_ocip-&gt; errp，＆src_time））; sprintf（（char *）txid，“Ping％2d：％2d：％2d”，src_time。OCIDateTime。OCITimeHH，src_time。OCIDateTime。OCITimeMI，src_time。OCIDateTime。OCITimeSS）; / *使用新的txid初始化LCR并提交位置* / OCICALL（xin_ocip，OCILCRHeaderSet（xin_ocip-&gt; svcp，xin_ocip-&gt; errp，source_db，source_db_len，（oratext *）OCI_LCR_ROW_CMD_COMMIT，（ub2）strlen（OCI_LCR_ROW_CMD_COMMIT），（oratext *） 0,0，/ * null owner * /（oratext *）0,0，/ * null object * /（ub1 *）0,0，/ * null tag * / txid，（ub2）strlen（（char *）txid ），＆src_time，cmtpos，cmtpos_len，0，commit_lcr，OCI_DEFAULT））; / *将commit lcr发送到入站服务器。* / if（OCIXStreamInLCRSend（xin_ocip-&gt; svcp，xin_ocip-&gt; errp，commit_lcr，OCI_LCR_XROW，0，OCI_DEFAULT）== OCI_ERROR）{ocierror（xin_ocip，（char *）“oCIXStreamInLCRSend在ping_svr（）中失败”）; } / * ---------------------------------------------- ----------------------- * get_lcrs  - 从出站服务器获取LCR并发送到入站服务器。* ------------------------------------------------- -------------------- * / static void get_lcrs（oci_t * xin_ocip，oci_t * xout_ocip）{sword status = OCI_SUCCESS; void * lcr; ub1 lcrtype; oraub8标志; ub1 proclwm [OCI_LCR_MAX_POSITION_LEN]; ub2 proclwm_len = 0; ub1 sv_pingpos [OCI_LCR_MAX_POSITION_LEN]; ub2 sv_pingpos_len = 0; ub1 fetchlwm [OCI_LCR_MAX_POSITION_LEN]; ub2 fetchlwm_len = 0; void * commit_lcr =（void *）0; oratext * lcr_srcdb =（oratext *）0; ub2 lcr_srcdb_len = 0; oratext source_db [M_DBNAME_LEN]; ub2 source_db_len = 0; ub4 lcrcnt = 0; / *通过发送* commit lcr创建一个lcr来定期ping入站服务器。* / commit_lcr =（void *）0; OCICALL（xin_ocip，OCILCRNew（xin_ocip-&gt; svcp，xin_ocip-&gt; errp，OCI_DURATION_SESSION，OCI_LCR_XROW，＆commit_lcr，OCI_DEFAULT））; while（status == OCI_SUCCESS）{lcrcnt = 0; / *在每个批处理之前重置lcr计数* / while（（status = OCIXStreamOutLCRReceive（xout_ocip-&gt; svcp，xout_ocip-&gt; errp，＆lcr，＆lcrtype，＆flag，fetchlwm，＆fetchlwm_len，OCI_DEFAULT））== OCI_STILL_EXECUTING）{lcrcnt ++; / * LCR的打印头刚收到* / print_lcr（xout_ocip，lcr，lcrtype，＆lcr_srcdb，＆lcr_srcdb_len）; / *保存源数据库以构建ping lcr以后* / if（！source_db_len &amp;&amp; lcr_srcdb_len）{memcpy（source_db，lcr_srcdb，lcr_srcdb_len）; source_db_len = lcr_srcdb_len; } / *发送刚收到的LCR * / if（OCIXStreamInLCRSend（xin_ocip-&gt; svcp，xin_ocip-&gt; errp，lcr，lcrtype，flag，OCI_DEFAULT）== OCI_ERROR）{ocierror（xin_ocip，（char *）“OCIXStreamInLCRSend failed”） ;如果LCR具有分块列（即，具有LOB / Long / XMLType列）* / if（flag＆OCI_XSTREAM_MORE_ROW_DATA）{/ *接收并发送分块列* / get_chunks（xin_ocip，xout_ocip）; if（status == OCI_ERROR）ocierror（xout_ocip，（char *）“OCIXStreamOutLCRReceive failed”）; / *清除保存的ping位置，如果我们刚收到一些新的lcrs * / if（lcrcnt）{sv_pingpos_len = 0; / *如果在之前的WHILE循环期间没有收到lcrs并获得新的fetch * LWM，则发送commit lcr以使用新的* fetch LWM位置ping入站服务器。* / else if（fetchlwm_len&gt; 0 &amp;&amp; source_db_len&gt; 0 &amp;&amp;（fetchlwm_len！= sv_pingpos_len || memcmp（sv_pingpos，fetchlwm，fetchlwm_len）））{/ *为了确保我们不发送具有重复位置的多个lcrs，只有在我们保存了最后一个ping位置时才发送*新的ping。* / if（sv_pingpos_len&gt; 0）{ping_svr（xin_ocip，commit_lcr，fetchlwm，fetchlwm_len，source_db，source_db_len）; } / *保存刚刚发送到入站服务器的位置* / memcpy（sv_pingpos，fetchlwm，fetchlwm_len）; sv_pingpos_len = fetchlwm_len; / *刷新入站网络以将所有lcrs刷新到入站服务器* / OCICALL（xin_ocip，OCIXStreamInFlush（xin_ocip-&gt; svcp，xin_ocip-&gt; errp，OCI_DEFAULT））; / *获取处理的入站服务器的LWM * / OCICALL（xin_ocip，OCIXStreamInProcessedLWMGet（xin_ocip-&gt; svcp，xin_ocip-&gt; errp，proclwm，＆proclwm_len，OCI_DEFAULT））; if（proclwm_len&gt; 0）{/ *为出站服务器设置已处理的LWM * / OCICALL（xout_ocip，OCIXStreamOutProcessedLWMSet（xout_ocip-&gt; svcp，xout_ocip-&gt; errp，proclwm，proclwm_len，OCI_DEFAULT））;如果（状态！= OCI_SUCCESS）ocierror（xout_ocip，（char *）“get_lcrs（）遇到错误”）; } / * ----------------------------------------------- ---------------------- * get_chunks  - 获取当前LCR的每个块并将其发送到入站服务器。* ------------------------------------------------- -------------------- * / static void get_chunks（oci_t * xin_ocip，oci_t * xout_ocip）{oratext * colname; ub2 colname_len; ub2寒冷; oraub8 col_flags; ub2 col_csid; ub4 chunk_len; ub1 * chunk_ptr; oraub8 row_flag;剑错; sb4 rtncode; do {/ *从出站服务器* / OCICALL获取一个块（xout_ocip，OCIXStreamOutChunkReceive（xout_ocip-&gt; svcp，xout_ocip-&gt; errp，＆colname，＆colname_len，＆coldty，＆col_flags，＆col_csid，＆chunk_len，＆chunk_ptr，＆row_flag，OCI_DEFAULT））; / * print chunked column info * / printf（“Chunked column name =％。* s DTY =％d chunk len =％d csid =％d col_flag = 0x％lx \ n”，colname_len，colname，coldty，chunk_len，col_csid ，col_flags）; / * print chunk data * / print_chunk（chunk_ptr，chunk_len，coldty）; / *将刚刚收到的块发送到入站服务器* / OCICALL（xin_ocip，OCIXStreamInChunkSend（xin_ocip-&gt; svcp，xin_ocip-&gt; errp，colname，colname_len，coldty，col_flags，col_csid，chunk_len，chunk_ptr，row_flag，OCI_DEFAULT））; } while（row_flag＆OCI_XSTREAM_MORE_ROW_DATA）; } / * ----------------------------------------------- ---------------------- * print_chunk  - 打印分块列信息。仅打印每个块的前50个字节。* ------------------------------------------------- -------------------- * / static void print_chunk（ub1 * chunk_ptr，ub4 chunk_len，ub2 dty）{＃define MAX_PRINT_BYTES（50）/ * print max of 50 bytes每块* / ub4 print_bytes; if（chunk_len == 0）返回; print_bytes = chunk_len&gt; MAX_PRINT_BYTES？MAX_PRINT_BYTES：chunk_len; printf（“Data =”）; if（dty == SQLT_CHR）printf（“％。* s”，print_bytes，chunk_ptr）;别的{ub2 idx; for（idx = 0; idx &lt;print_bytes; idx ++）printf（“％02x”，chunk_ptr [idx]）; } printf（“\ n”）; } / * ----------------------------------------------- ---------------------- * print_lcr  - 打印给定lcr的标题信息。* ------------------------------------------------- -------------------- * / static void print_lcr（oci_t * ocip，void * lcrp，ub1 lcrtype，oratext ** src_db_name，ub2 * src_db_namel）{oratext * cmd_type ; ub2 cmd_type_len; oratext *所有者; ub2 ownerl; oratext * oname; ub2 onamel; oratext * txid; ub2 txidl;剑回; printf（“\ n -----------％s LCR Header ----------------- \ n”，lcrtype == OCI_LCR_XDDL？“DDL”：“ROW”）; / *获取LCR标头信息* / ret = OCILCRHeaderGet（ocip-&gt; svcp，ocip-&gt; errp，src_db_name，src_db_namel，/ * source db * /＆cmd_type，＆cmd_type_len，/ *命令类型* /＆owner，＆ownerl，/ *所有者名称* /＆oname，＆onamel，/ *对象名称* /（ub1 **）0，（ub2 *）0，/ * lcr标签* /＆txid，＆txidl，（OCIDate *）0，/ * txn id＆src time * / （ub2 *）0，（ub2 *）0，/ * OLD / NEW col cnts * /（ub1 **）0，（ub2 *）0，/ * LCR位置* /（oraub8 *）0，lcrp，OCI_DEFAULT） ;如果（退！= OCI_SUCCESS）ocierror（ocip，（char *）“OCILCRHeaderGet failed”）; else {printf（“src_db_name =％。* s \ n cmd_type =％。* s txid =％。* s \ n”，* src_db_namel，* src_db_name，cmd_type_len，cmd_type，txidl，txid）; if（ownerl&gt; 0）printf（“owner =％。* s oname =％。* s \ n”，ownerl，owner，onamel，oname）; } / * ---------------------------------------------- ----------------------- * detach  - 从XStream服务器分离* ------------------- -------------------------------------------------- * / static void detach（oci_t * ocip）{sword err = OCI_SUCCESS; printf（“从XStream％s服务器分离\ n”，ocip-&gt; outbound？“出境”：“入境”）; if（ocip-&gt; outbound）{OCICALL（ocip，OCIXStreamOutDetach（ocip-&gt; svcp，ocip-&gt; errp，OCI_DEFAULT））; } else {OCICALL（ocip，OCIXStreamInDetach（ocip-&gt; svcp，ocip-&gt; errp，（ub1 *）0，（ub2 *）0，/ *处理后的LWM * / OCI_DEFAULT））; } / * ---------------------------------------------- ----------------------- * disconnect_db  - 从数据库注销* ------------------- -------------------------------------------------- * / static void disconnect_db（oci_t * ocip）{if（OCILogoff（ocip-&gt; svcp，ocip-&gt; errp））{ocierror（ocip，（char *）“OCILogoff（）failed”）; } if（ocip-&gt; errp）OCIHandleFree（（dvoid *）ocip-&gt; errp，（ub4）OCI_HTYPE_ERROR）; if（ocip-&gt; envp）OCIHandleFree（（dvoid *）ocip-&gt; envp，（ub4）OCI_HTYPE_ENV）; } / * ----------------------------------------------- ---------------------- * ocierror  - 打印错误状态并退出程序* ------------------ -------------------------------------------------- -  * / static void ocierror（oci_t * ocip，char * msg）{sb4 errcode = 0; text bufp [4096]; if（ocip-&gt; errp）{OCIErrorGet（（dvoid *）ocip-&gt; errp，（ub4）1，（text *）NULL，＆errcode，bufp，（ub4）4096，（ub4）OCI_HTYPE_ERROR）; printf（“％s \ n％s”，msg，bufp）; } else puts（msg）; printf（“\ n”）;出口（1）; } / * ----------------------------------------------- --------------------- * print_usage  - 打印命令用法* ---------------------- -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  - -*/ 静态的void print_usage（int exitcode）{puts（“\ nUsage：xio -ob_svr &lt;outbound_svr&gt; -ob_db &lt;outbound_db&gt; \ n”“ -  ob_usr &lt;conn_user&gt; -ob_pwd &lt;conn_user_pwd&gt; \ n”“ -  ib_svr &lt;inbound_svr&gt; -ib_db &lt; inbound_db&gt; \ n“” -  ib_usr &lt;apply_user&gt; -ib_pwd &lt;apply_user_pwd&gt; \ n“）; puts（“ob_svr：出站服务器名称\ n”“ob_db：出站服务器的数据库名称\ n”“ob_usr：将用户连接到出站服务器\ n”“ob_pwd：出站连接用户的密码\ n”“ib_svr：入站服务器名称\ n“”ib_db：入站服务器的数据库名称\ n“”ib_usr：为入站服务器申请用户\ n“”ib_pwd：入站申请用户的密码\ n“）;出口（退出码）; } / * ----------------------------------------------- --------------------- * get_inputs  - 从命令行获取用户输入* ------------------- -------------------------------------------------- * / static void get_inputs（conn_info_t * xout_params，conn_info_t * xin_params，int argc，char ** argv）{char * option; char *值; memset（xout_params，0，sizeof（* xout_params））; memset（xin_params，0，sizeof（* xin_params））; while（ -  argc）{/ *获取选项名称* / argv ++; option = * argv; / *检查选项是否以“ - ”开头* / if（！strncmp（option，（char *）“ - ”，1））{option ++; } else {printf（“错误：错误的参数'％s'\ n”，选项）; print_usage（1）; } / *获取选项* / --argc的值;的argv ++; value = * argv;如果（！strncmp（option，（char *）“ob_db”，5））{xout_params-&gt; dbname =（oratext *）value; xout_params-&gt; dbnamelen =（ub4）strlen（value）;如果（！）strncmp（option，（char *）“ob_usr”，6））{xout_params-&gt; user =（oratext *）value; xout_params-&gt; userlen =（ub4）strlen（value）;如果（！）strncmp（option，（char *）“ob_pwd”，6））{xout_params-&gt; passw =（oratext *）value; xout_params-&gt; passwlen =（ub4）strlen（value）;如果（！）strncmp（option，（char *）“ob_svr”，6））{xout_params-&gt; svrnm =（oratext *）value; xout_params-&gt; svrnmlen =（ub4）strlen（value）;如果（！）strncmp（option，（char *）“ib_db”，5））{xin_params-&gt; dbname =（oratext *）value; xin_params-&gt; dbnamelen =（ub4）strlen（value）;如果（！）strncmp（option，（char *）“ib_usr”，6））{xin_params-&gt; user =（oratext *）value; xin_params-&gt; userlen =（ub4）strlen（value）;如果（！）strncmp（option，（char *）“ib_pwd”，6））{xin_params-&gt; passw =（oratext *）value; xin_params-&gt; passwlen =（ub4）strlen（value）;如果（！）strncmp（option，（char *）“ib_svr”，6））{xin_params-&gt; svrnm =（oratext *）value; xin_params-&gt; svrnmlen =（ub4）strlen（value）; } else {printf（“错误：未知选项'％s'。\ n”，选项）; print_usage（1）;如果没有指定任何参数，则打印用法和退出* / if（！）xout_params-&gt; svrnmlen || ！xout_params-&gt; passwlen || ！xout_params-&gt; userlen || ！xout_params-&gt; dbnamelen || ！xin_params-&gt; svrnmlen || ！xin_params-&gt; passwlen || ！xin_params-&gt; userlen || ！xin_params-&gt; dbnamelen）{printf（“错误：缺少命令参数。\ n”）; print_usage（1）; }}</pre></div>
               <div>
                  <div class="familylinks">
                     <div class="parentlink">
                        <p><strong>父主题：</strong> <a href="sample-xstream-client-application.html#GUID-B914FF75-92AA-4270-BF71-E9A5AA9228F8" title="示例说明如何配置XStream使用的Oracle数据库组件。这些示例配置与XStream出站服务器和入站服务器通信的示例客户端应用程序。">示例XStream客户端应用程序</a></p>
                     </div>
                  </div>
               </div>
               
            </div><a id="XSTRM1570"></a><div class="props_rev_3"><a id="GUID-952CEB45-9E0D-49AE-853A-912524B49853" name="GUID-952CEB45-9E0D-49AE-853A-912524B49853"></a><h3 id="XSTRM-GUID-952CEB45-9E0D-49AE-853A-912524B49853" class="sect3"><span class="enumeration_section">A.3</span> Java API的示例XStream客户端应用程序</h3>
               <div>
                  <p>要为Java API运行示例XStream客户端应用程序，请编译并链接应用程序文件。</p>
                  <p>接下来，在命令行中输入以下内容：</p><pre class="oac_no_warn" dir="ltr">java xio <span class="italic">xsin_oraclesid</span> <span class="italic">xsin_host</span> <span class="italic">xsin_port</span> <span class="italic">xsin_username</span> <span class="italic">xsin_passwd</span> <span class="italic">xin_servername</span> <span class="italic">xsout_oraclesid</span> <span class="italic">xsout_host</span> <span class="italic">xsout_port</span> <span class="italic">xsout_username</span> <span class="italic">xsout_passwd</span> <span class="italic">xsout_servername</span>
</pre><p>替换以下占位符的适当值：</p>
                  <ul style="list-style-type:disc">
                     <li>
                        <p><span class="italic">xsin_oraclesid</span>是入站服务器数据库的Oracle SID。
                        </p>
                     </li>
                     <li>
                        <p><span class="italic">xsin_host</span>是运行入站服务器的计算机系统的主机名。
                        </p>
                     </li>
                     <li>
                        <p><span class="italic">xsin_port</span>是入站服务器数据库的侦听器的端口号。
                        </p>
                     </li>
                     <li>
                        <p><span class="italic">xsin_username</span>是入站服务器的应用用户。
                        </p>
                     </li>
                     <li>
                        <p><span class="italic">xsin_passwd</span>是入站服务器的应用用户的密码。
                        </p>
                     </li>
                     <li>
                        <p><span class="italic">xin_servername</span>是入站服务器的名称。
                        </p>
                     </li>
                     <li>
                        <p><span class="italic">xsout_oraclesid</span>是出站服务器数据库的Oracle SID。
                        </p>
                     </li>
                     <li>
                        <p><span class="italic">xsout_host</span>是运行出站服务器的计算机系统的主机名。
                        </p>
                     </li>
                     <li>
                        <p><span class="italic">xsout_port</span>是出站服务器数据库的侦听器的端口号。
                        </p>
                     </li>
                     <li>
                        <p><span class="italic">xsout_username</span>是出站服务器的连接用户。
                        </p>
                     </li>
                     <li>
                        <p><span class="italic">xsout_passwd</span>是出站服务器的连接用户的密码。
                        </p>
                     </li>
                     <li>
                        <p><span class="italic">xsout_servername</span>是出站服务器的名称。
                        </p>
                     </li>
                  </ul>
                  <p>示例客户端应用程序运行时，它会打印有关附加到入站服务器和出站服务器的信息，以及每个服务器的最后位置。输出类似于以下内容：</p><pre class="oac_no_warn" dir="ltr">xsin_host = server2.example.com xsin_port = 1482 xsin_ora_sid = db2 xsin connection url：jdbc：oracle：oci：@ server2.example.com:1482:db2 xsout_host = server1.example.com xsout_port = 1481 xsout_ora_sid = db1 xsout connection url： jdbc：oracle：oci：@ server1.example.com:1481：db1附加到入站服务器：xin入站服务器最后位置是：0000000920250000000100000001000000092025000000010000000101附加到出站服务器：xout最后位置是：0000000920250000000100000001000000092025000000010000000101</pre><p>此演示位于以下位置：</p><pre class="oac_no_warn" dir="ltr">$ ORACLE_HOME / RDBMS /演示/ XStream的/ JAVA</pre><p>该演示的文件名是<code class="codeph">xio.java</code> 。有关编译和运行应用程序的更多信息，请参阅演示目录中的<code class="codeph">README.txt</code>文件。
                  </p>
                  <p>使用Java API的示例应用程序的代码如下：</p><pre class="oac_no_warn" dir="ltr">导入oracle.streams。*; import oracle.jdbc.internal。的OracleConnection; import oracle.jdbc。*; import oracle.sql。*; import java.sql。*; import java.util。*; public class xio {public static String xsinusername = null; public static String xsinpasswd = null; public static String xsinName = null; public static String xsoutusername = null; public static String xsoutpasswd = null; public static String xsoutName = null; public static String in_url = null; public static String out_url = null; public static Connection in_conn = null; public static Connection out_conn = null; public static XStreamIn xsIn = null; public static XStreamOut xsOut = null; public static byte [] lastPosition = null; public static byte [] processedLowPosition = null; public static void main（String args []）{//获取入站和出站服务器的连接URL in_url = parseXSInArguments（args）; out_url = parseXSOutArguments（args）; //创建与入站和出站服务器的连接in_conn = createConnection（in_url，xsinusername，xsinpasswd）; out_conn = createConnection（out_url，xsoutusername，xsoutpasswd）; //附加到入站和出站服务器xsIn = attachInbound（in_conn）; xsOut = attachOutbound（out_conn）; //主循环获取lcrs get_lcrs（xsIn，xsOut）; //从入站和出站服务器detachInbound（xsIn）分离; detachOutbound（xsOut）; } //解析参数以获取conncetion url到入站db public static String parseXSInArguments（String args []）{String trace，pref;字符串orasid，主机，端口; if（args.length！= 12）{printUsage（）; System.exit（0）; } orasid = args [0]; host = args [1]; port = args [2]; xsinusername = args [3]; xsinpasswd = args [4]; xsinName = args [5]; System.out.println（“xsin_host =”+ host）; System.out.println（“xsin_port =”+ port）; System.out.println（“xsin_ora_sid =”+ orasid）; String in_url =“jdbc：oracle：oci：@”+ host +“：”+ port +“：”+ orasid; System.out.println（“xsin connection url：”+ in_url）; return in_url; } //解析参数以获取conncetion url到outbound db public static String parseXSOutArguments（String args []）{String trace，pref;字符串orasid，主机，端口; if（args.length！= 12）{printUsage（）; System.exit（0）; } orasid = args [6]; host = args [7]; port = args [8]; xsoutusername = args [9]; xsoutpasswd = args [10]; xsoutName = args [11]; System.out.println（“xsout_host =”+ host）; System.out.println（“xsout_port =”+ port）; System.out.println（“xsout_ora_sid =”+ orasid）; String out_url =“jdbc：oracle：oci：@”+ host +“：”+ port +“：”+ orasid; System.out.println（“xsout connection url：”+ out_url）;返回out_url; } //打印出示例程序用法消息public static void printUsage（）{System.out.println（“”）; System.out.println（“用法：java xio”+“&lt;xsin_oraclesid&gt;”+“&lt;xsin_host&gt;”+“&lt;xsin_port&gt;”）; System.out.println（“”+“&lt;xsin_username&gt;”+“&lt;xsin_passwd&gt;”+“&lt;xsin_servername&gt;”）; System.out.println（“”+“&lt;xsout_oraclesid&gt;”+“&lt;xsout_host&gt;”+“&lt;xsout_port&gt;”）; System.out.println（“”+“&lt;xsout_username&gt;”+“&lt;xsout_passwd&gt;”+“&lt;xsout_servername&gt;”）; } //创建与Oracle数据库的连接public static Connection createConnection（String url，String username，String passwd）{try {DriverManager.registerDriver（new oracle.jdbc。一个OracleDriver（））; return DriverManager.getConnection（url，username，passwd）; } catch（Exception e）{System.out.println（“无法建立DB连接到：”+ url）; e.printStackTrace（）; return null; } // //附加到XStream入站服务器public static XStreamIn attachInbound（Connection in_conn）{XStreamIn xsIn = null;尝试{xsIn = XStreamIn.attach（（OracleConnection）in_conn，xsinName，“XSDEMOINCLIENT”，XStreamIn。DEFAULT_MODE）; //使用最后一个位置来决定我们应该从哪里开始发送LCRs lastPosition = xsIn.getLastPosition（）; System.out.println（“附加到入站服务器：”+ xsinName）; System.out.print（“入站服务器最后位置是：”）; if（null == lastPosition）{System.out.println（“null”）; } else {printHex（lastPosition）; } return xsIn; } catch（例外e）{System.out.println（“无法附加到入站服务器：”+ xsinName）;的System.out.println（e.getMessage（））; e.printStackTrace（）; return null; } // //附加到XStream出站服务器public static XStreamOut attachOutbound（Connection out_conn）{XStreamOut xsOut = null;尝试{//当连接到出站服务器时，客户端需要告诉出站//服务器最后一个位置。xsOut = XStreamOut.attach（（OracleConnection）out_conn，xsoutName，lastPosition，XStreamOut。DEFAULT_MODE）; System.out.println（“附加到出站服务器：”+ xsoutName）; System.out.print（“Last Position is：”）; if（lastPosition！= null）{printHex（lastPosition）; } else {System.out.println（“NULL”）; } return xsOut; } catch（例外e）{System.out.println（“无法附加到出站服务器：”+ xsoutName）;的System.out.println（e.getMessage（））; e.printStackTrace（）; return null; //从XStream入站服务器分离public static void detachInbound（XStreamIn xsIn）{byte [] processedLowPosition = null;尝试{processedLowPosition = xsIn.detach（XStreamIn。DEFAULT_MODE）; System.out.print（“入站服务器处理低位置是：”）; if（processedLowPosition！= null）{printHex（processedLowPosition）; } else {System.out.println（“NULL”）; catch（Exception e）{System.out.println（“无法从入站服务器分离：”+ xsinName）;的System.out.println（e.getMessage（））; e.printStackTrace（）; //从XStream Outbound Server分离public static void detachOutbound（XStreamOut xsOut）{try {xsOut.detach（XStreamOut。DEFAULT_MODE）; } catch（Exception e）{System.out.println（“无法从出站服务器分离：”+ xsoutName）;的System.out.println（e.getMessage（））; e.printStackTrace（）; public static void get_lcrs（XStreamIn xsIn，XStreamOut xsOut）{if（null == xsIn）{System.out.println（“xstreamIn is null”）; System.exit（0）; } if（null == xsOut）{System.out.println（“xstreamOut is null”）; System.exit（0）; } try {while（true）{//从出站服务器接收LCR LCR alcr = xsOut.receiveLCR（XStreamOut。DEFAULT_MODE）; if（xsOut.getBatchStatus（）== XStreamOut。EXECUTING）//批处理是活动的{断言！= null; //将LCR发送到入站服务器xsIn.sendLCR（alcr，XStreamIn。DEFAULT_MODE）; //也为此LCR获取块数据（如果有的话）（例如RowLCR实例）{//从出站接收块然后发送到入站if（（（RowLCR）alcr）.hasChunkData（））{ChunkColumnValue chunk = null; do {chunk = xsOut.receiveChunk（XStreamOut。DEFAULT_MODE）; xsIn.sendChunk（chunk，XStreamIn。DEFAULT_MODE）;而（！chunk.isEndOfRow（））; processedLowPosition = alcr.getPosition（）; } else // batch is end {assert alcr == null; //刷新网络xsIn.flush（XStreamIn。DEFAULT_MODE）; //从入站服务器获取processed_low_position processedLowPosition = xsIn.getProcessedLowWatermark（）; //更新oubound服务器上的processed_low_position if（null！= processedLowPosition）xsOut.setProcessedLowWatermark（processedLowPosition，XStreamOut。DEFAULT_MODE）; catch（Exception e）{System.out.println（“处理LCR时的异常”）;的System.out.println（e.getMessage（））; e.printStackTrace（）; public static void printHex（byte [] b）{for（int i = 0; i &lt;b.length; ++ i）{System.out.print（Integer.toHexString（（b [i]＆0xFF）| 0x100 ）.substring（1,3））; System.out.println（“”）; }}</pre></div>
               <div>
                  <div class="familylinks">
                     <div class="parentlink">
                        <p><strong>父主题：</strong> <a href="sample-xstream-client-application.html#GUID-B914FF75-92AA-4270-BF71-E9A5AA9228F8" title="示例说明如何配置XStream使用的Oracle数据库组件。这些示例配置与XStream出站服务器和入站服务器通信的示例客户端应用程序。">示例XStream客户端应用程序</a></p>
                     </div>
                  </div>
               </div>
               
            </div>
         </div>
      </article>
   </body>
</html>