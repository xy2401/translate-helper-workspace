<html lang="en-us" dir="ltr" xml:lang="en-us">
   <head>
      <meta http-equiv="Content-Type" content="text/html; charset=utf-8"></meta>
      <meta name="viewport" content="width=device-width, initial-scale=1"></meta>
      <meta http-equiv="X-UA-Compatible" content="IE=edge"></meta>
      <title>Oracle Java消息服务类型示例</title>
      <meta property="og:site_name" content="Oracle Help Center"></meta>
      <meta property="og:title" content="Advanced Queuing User&#39;s Guide "></meta>
      <meta property="og:description" content=""></meta>
      <link rel="stylesheet" href="/sp_common/book-template/ohc-book-template/css/book.css"></link>
      <link rel="shortcut icon" href="/sp_common/book-template/ohc-common/img/favicon.ico"></link>
      <meta name="application-name" content="Advanced Queuing User&#39;s Guide"></meta>
      <meta name="generator" content="DITA Open Toolkit version 1.8.5 (Mode = doc)"></meta>
      <meta name="plugin" content="SP_docbuilder HTML plugin release 18.2.2"></meta>
      <link rel="alternate" href="oracle-database-advanced-queuing.pdf" title="PDF File" type="application/pdf"></link>
      <meta name="robots" content="all"></meta>
      <link rel="schema.dcterms" href="http://purl.org/dc/terms/"></link>
      <meta name="dcterms.created" content="2019-02-12T10:53:09-08:00"></meta>
      
      <meta name="dcterms.dateCopyrighted" content="1996, 2019"></meta>
      <meta name="dcterms.category" content="database"></meta>
      <meta name="dcterms.identifier" content="E96511-01"></meta>
      
      <meta name="dcterms.product" content="en/database/oracle/oracle-database/19"></meta>
      
      <link rel="prev" href="jms-shared-interfaces.html" title="Previous" type="text/html"></link>
      <link rel="next" href="omg-introduction.html" title="Next" type="text/html"></link>
      <script>
        document.write('<style type="text/css">');
        document.write('body > .noscript, body > .noscript ~ * { visibility: hidden; }');
        document.write('</style>');
     </script>
      <script src="/sp_common/book-template/requirejs/require.js" data-main="/sp_common/book-template/ohc-book-template/js/book-config"></script>
      <script>
            if (window.require === undefined) {
                document.write('<script data-main="sp_common/book-template/ohc-book-template/js/book-config" src="sp_common/book-template/requirejs/require.js"><\/script>');
                document.write('<link href="sp_common/book-template/ohc-book-template/css/book.css" rel="stylesheet"/>');
            }
        </script>
      <script type="application/json" id="ssot-metadata">{"primary":{"category":{"short_name":"database","element_name":"Database","display_in_url":true},"suite":{"short_name":"oracle","element_name":"Oracle","display_in_url":true},"product_group":{"short_name":"not-applicable","element_name":"Not applicable","display_in_url":false},"product":{"short_name":"oracle-database","element_name":"Oracle Database","display_in_url":true},"release":{"short_name":"19","element_name":"Release 19","display_in_url":true}}}</script>
      
    <meta name="dcterms.title" content="Oracle® Database Advanced Queuing"></meta>
    <meta name="dcterms.isVersionOf" content="ADQUE"></meta>
    <meta name="dcterms.release" content="Release 19"></meta>
  </head>
   <body dir="ltr">
      <div class="noscript alert alert-danger text-center" role="alert">
         <a href="jms-shared-interfaces.html" class="pull-left"><span class="glyphicon glyphicon-chevron-left" aria-hidden="true"></span>上一页</a> <a href="omg-introduction.html" class="pull-right">下一页<span class="glyphicon glyphicon-chevron-right" aria-hidden="true"></span></a> <span class="fa fa-exclamation-triangle" aria-hidden="true"></span>必须启用JavaScript才能正确显示此内容</div>
      <article>
         <header>
            <ol class="breadcrumb" vocab="http://schema.org/" typeof="BreadcrumbList">
               <li property="itemListElement" typeof="ListItem"><a href="index.html" property="item" typeof="WebPage"><span property="name">高级排队用户指南</span></a></li>
               <li class="active" property="itemListElement" typeof="ListItem">Oracle Java消息服务类型示例</li>
            </ol>
            <a id="GUID-07B1C510-0A70-4C98-9D16-AAC23578B66A" name="GUID-07B1C510-0A70-4C98-9D16-AAC23578B66A"></a><a id="ADQUE1600"></a>
            
            <h2 id="ADQUE-GUID-07B1C510-0A70-4C98-9D16-AAC23578B66A" class="sect2"><span class="enumeration_chapter">16</span> Oracle Java消息服务类型示例</h2>
         </header>
         <div class="ind">
            <div>
               <p>以下示例说明了如何使用Oracle JMS类型对Oracle数据库高级队列（AQ）消息进行<a href="glossary.html#GUID-BC8D60E8-953A-4C6C-8163-F7AE187B768B"><span class="xrefglossterm">出</span></a> <a href="glossary.html#GUID-B21E60F7-4BFA-42A2-9A8F-B781C2A55ED9"><span class="xrefglossterm">列</span></a>队列和<a href="glossary.html#GUID-B21E60F7-4BFA-42A2-9A8F-B781C2A55ED9"><span class="xrefglossterm">排队</span></a> 。
               </p>
               <ul style="list-style-type:disc">
                  <li>
                     <p><a href="jms-service-types-examples.html#GUID-D3F77697-9069-4D3D-9A5D-3D83245BE1F7">如何设置Oracle数据库高级队列JMS类型示例</a></p>
                  </li>
                  <li>
                     <p><a href="jms-service-types-examples.html#GUID-D2118ED4-285B-4C73-A88B-09B9F55BBB76">JMS BytesMessage示例</a></p>
                  </li>
                  <li>
                     <p><a href="jms-service-types-examples.html#GUID-2A106B5C-925F-4ED2-9C4D-331BAF261F66">JMS StreamMessage示例</a></p>
                  </li>
                  <li>
                     <p><a href="jms-service-types-examples.html#GUID-806DD371-1C4B-4176-98BF-70C4401C4AF3">JMS MapMessage示例</a></p>
                  </li>
                  <li>
                     <p><a href="jms-service-types-examples.html#GUID-CFB48BB3-9498-4AF2-904A-3D081E6B9A34">更多Oracle数据库高级队列JMS示例</a></p>
                  </li>
               </ul>
            </div><a id="ADQUE3179"></a><a id="ADQUE3684"></a><a id="ADQUE3177"></a><div class="props_rev_3"><a id="GUID-D3F77697-9069-4D3D-9A5D-3D83245BE1F7" name="GUID-D3F77697-9069-4D3D-9A5D-3D83245BE1F7"></a><h3 id="ADQUE-GUID-D3F77697-9069-4D3D-9A5D-3D83245BE1F7" class="sect3"><span class="enumeration_section">16.1</span>如何设置Oracle数据库高级队列JMS类型示例</h3>
               <div>
                  <div class="section">
                     <p>要运行<a href="jms-service-types-examples.html#GUID-D2118ED4-285B-4C73-A88B-09B9F55BBB76__I1005861">示例16-3</a>到<a href="jms-service-types-examples.html#GUID-806DD371-1C4B-4176-98BF-70C4401C4AF3__I1006473">示例16-8，请</a>按照下列步骤操作：</p>
                  </div>
                  <!-- class="section" -->
                  <ol>
                     <li class="stepexpand"><span>将<a href="jms-service-types-examples.html#GUID-D3F77697-9069-4D3D-9A5D-3D83245BE1F7__I1005669">示例16-1</a>复制并保存为<code class="codeph">setup.sql</code> 。</span></li>
                     <li class="stepexpand"><span>运行<code class="codeph">setup.sql</code>如下：</span><div><pre class="oac_no_warn" dir="ltr">sqlplus / NOLOG @ setup.sql</pre></div>
                     </li>
                     <li class="stepexpand"><span>以<code class="codeph">jmsuser/jmsuser</code>身份登录SQL * Plus。</span></li>
                     <li class="stepexpand"><span>为每种类型的<a href="glossary.html#GUID-2028AECF-DB3E-40E2-99B6-A35674C08038"><span class="xrefglossterm">消息</span></a>运行相应的SQL脚本对。</span><div>
                           <p>例如，对于JMS <code class="codeph">BytesMessage</code> ，运行<a href="jms-service-types-examples.html#GUID-D2118ED4-285B-4C73-A88B-09B9F55BBB76__I1005861">例16-3</a>和<a href="jms-service-types-examples.html#GUID-D2118ED4-285B-4C73-A88B-09B9F55BBB76__CIHBJGDD">例16-4</a> 。
                           </p>
                        </div>
                     </li>
                     <li class="stepexpand"><span>确保数据库参数<code class="codeph">java_pool-size</code>足够大。例如，您可以使用<code class="codeph">java_pool_size</code> = 20M。</span></li>
                  </ol>
                  <div class="example" id="GUID-D3F77697-9069-4D3D-9A5D-3D83245BE1F7__I1005669">
                     <p class="titleinexample">示例16-1设置运行JMS类型的环境示例</p><pre class="oac_no_warn" dir="ltr">连接系统;输入密码： <span class="italic">密码</span> Rem Rem创建JMS用户：jmsuser Rem DROP USER jmsuser CASCADE; CREATE USER jmsuser IDENTIFIED BY jmsuser;在DBMS_AQADM上执行GRANT EXECUTE到jmsuser;在DBMS_AQ上执行GRANT EXECUTE到jmsuser;在DBMS_LOB上执行GRANT EXECUTE到jmsuser;在DBMS_JMS_PLSQL上执行GRANT EXECUTE到jmsuser; set echo offset verify offconnect sysDROP USER jmsuser CASCADE; ACCEPT password CHAR PROMPT'输入JMSUSER的密码：'HIDECREATE USER jmsuser IDENTIFIED BY＆password; GRANT DBA，AQ_ADMINISTRATOR_ROLE，AQ_USER_ROLE to jmsuser; GRANT EXECUTE ON DBMS_AQADM to jmsuser; GRANT EXECUTE ON DBMS_AQ TO jmsuser;在DBMS_LOB上执行GRANT EXECUTE到jmsuser;在DBMS_JMS_PLSQL上执行GRANT执行到jmsuser;连接jmsuser /＆password Rem Rem为五个有效负载创建五个AQ队列表和五个队列：Rem SYS.AQ $ _JMS_TEXT_MESSAGE Rem SYS.AQ $ _JMS_BYTES_MESSAGE Rem SYS.AQ $ _JMS_STREAM_MESSAG Rem SYS.AQ $ _JMS_MAP_MESSAGE Rem SYS.AQ $ _JMS_MESSAGE Rem EXECUTE DBMS_AQADM.CREATE_QUEUE_TABLE（Queue_table =&gt;'jmsuser.jms_qtt_text'，Queue_payload_type =&gt;'SYS.AQ $ _JMS_TEXT_MESSAGE'，compatible =&gt;'8.1.0'）; EXECUTE DBMS_AQADM.CREATE_QUEUE_TABLE（Queue_table =&gt;'jmsuser.jms_qtt_bytes'，Queue_payload_type =&gt;'SYS.AQ $ _JMS_BYTES_MESSAGE'，compatible =&gt;'8.1.0'）; EXECUTE DBMS_AQADM.CREATE_QUEUE_TABLE（Queue_table =&gt;'jmsuser.jms_qtt_stream'，Queue_payload_type =&gt;'SYS.AQ $ _JMS_STREAM_MESSAGE'，compatible =&gt;'8.1.0'）; EXECUTE DBMS_AQADM.CREATE_QUEUE_TABLE（Queue_table =&gt;'jmsuser.jms_qtt_map'，Queue_payload_type =&gt;'SYS.AQ $ _JMS_MAP_MESSAGE'，compatible =&gt;'8.1.0'）; EXECUTE DBMS_AQADM.CREATE_QUEUE_TABLE（Queue_table =&gt;'jmsuser.jms_qtt_general'，Queue_payload_type =&gt;'SYS.AQ $ _JMS_MESSAGE'，compatible =&gt;'8.1.0'）; EXECUTE DBMS_AQADM.CREATE_QUEUE（Queue_name =&gt;'jmsuser.jms_text_que'，Queue_table =&gt;'jmsuser.jms_qtt_text'）; EXECUTE DBMS_AQADM.CREATE_QUEUE（Queue_name =&gt;'jmsuser.jms_bytes_que'，Queue_table =&gt;'jmsuser.jms_qtt_bytes'）; EXECUTE DBMS_AQADM.CREATE_QUEUE（Queue_name =&gt;'jmsuser.jms_stream_que'，Queue_table =&gt;'jmsuser.jms_qtt_stream'）; EXECUTE DBMS_AQADM.CREATE_QUEUE（Queue_name =&gt;'jmsuser.jms_map_que'，Queue_table =&gt;'jmsuser.jms_qtt_map'）; EXECUTE DBMS_AQADM.CREATE_QUEUE（Queue_name =&gt;'jmsuser.jms_general_que'，Queue_table =&gt;'jmsuser.jms_qtt_general'）; Rem Rem启动队列并启用队列和队列Rem EXECUTE DBMS_AQADM.START_QUEUE（Queue_name =&gt;'jmsuser.jms_text_que'）; EXECUTE DBMS_AQADM.START_QUEUE（Queue_name =&gt;'jmsuser.jms_bytes_que'）; EXECUTE DBMS_AQADM.START_QUEUE（Queue_name =&gt;'jmsuser.jms_stream_que'）; EXECUTE DBMS_AQADM.START_QUEUE（Queue_name =&gt;'jmsuser.jms_map_que'）; EXECUTE DBMS_AQADM.START_QUEUE（Queue_name =&gt;'jmsuser.jms_general_que'）; Rem示例中使用的支持实用程序帮助在SQLPLUS环境中显示结果Rem Rem在SQLPLUS Rem中显示RAW数据创建或替换过程display_raw（rdata raw）IS pos pls_integer;长度pls_integer; BEGIN pos：= 1; length：= UTL_RAW.LENGTH（rdata）; WHILE pos &lt;= length LOOP IF pos + 20&gt; length + 1 THEN dbms_output.put_line（UTL_RAW.SUBSTR（rdata，pos，length-pos + 1））; ELSE dbms_output.put_line（UTL_RAW.SUBSTR（rdata，pos，20））;万一; pos：= pos + 20;结束循环; END display_raw; /显示错误; Rem Rem在SQLPLUS中显示BLOB数据Rem创建或替换过程display_blob（bdata blob）IS pos pls_integer;长度pls_integer; BEGIN length：= dbms_lob.getlength（bdata）; pos：= 1; WHILE pos &lt;= length LOOP display_raw（DBMS_LOB.SUBSTR（bdata，2000，pos））; pos：= pos + 2000;结束循环; END display_blob; /显示错误; Rem Rem在SQLPLUS Rem中显示VARCHAR数据创建或替换过程display_varchar（vdata varchar）IS pos pls_integer; text_len pls_integer; BEGIN text_len：= length（vdata）; pos：= 1; WHILE pos &lt;= text_len LOOP IF pos + 20&gt; text_len + 1 THEN dbms_output.put_line（SUBSTR（vdata，pos，text_len-pos + 1））; ELSE dbms_output.put_line（SUBSTR（vdata，pos，20））;万一; pos：= pos + 20;结束循环; END display_varchar; /显示错误; Rem Rem在SQLPLUS中显示CLOB数据Rem创建或替换过程display_clob（cdata clob）IS pos pls_integer;长度pls_integer; BEGIN length：= dbms_lob.getlength（cdata）; pos：= 1; WHILE pos &lt;= length LOOP display_varchar（DBMS_LOB.SUBSTR（cdata，2000，pos））; pos：= pos + 2000;结束循环; END display_clob; /显示错误; Rem Rem在SQLPLUS Rem Rem中显示SYS.AQ $ _JMS_EXCEPTION数据当应用程序收到ORA-24197错误时，这意味着JAVA存储的Rem过程抛出了一些无法进行catergorized的异常。Rem用户可以使用SYS.AQ $ _JMS_BYTES_MESSAGE，Rem SYS.AQ $ _JMS_STREAM_MESSAG或SYS.AQ $ _JMS_MAP_MESSAGE Rem的GET_EXCEPTION过程来检索SYS.AQ $ _JMS_EXCEPTION对象，该对象包含有关此JAVA异常的更详细的Rem信息，包括异常名称，JAVA错误Rem消息和堆栈跟踪。Rem Rem这个实用程序功能是帮助显示Rem SQLPLUS中的SYS.AQ $ _JMS_EXCEPTION对象Rem创建或替换过程display_exp（exp SYS.AQ $ _JMS_EXCEPTION）IS pos1 pls_integer; pos2 pls_integer; text_data varchar（2000）; BEGIN dbms_output.put_line（'exception：'|| exp.exp_name）; DBMS_OUTPUT.PUT_LINE（ 'ERR_MSG：' || exp.err_msg）; DBMS_OUTPUT.PUT_LINE（ '堆栈：' ||长度（exp.stack））; pos1：= 1; LOOP pos2：= INSTR（exp.stack，chr（10），pos1）;如果pos2 = 0那么pos2：= length（exp.stack）+1;万一; dbms_output.put_line（SUBSTR（exp.stack，pos1，pos2-pos1））;如果pos2&gt;长度（exp.stack）那么退出;万一; pos1：= pos2 + 1;结束循环; END display_exp; /显示错误;出口;</pre></div>
                  <!-- class="example" -->
                  <div class="example" id="GUID-D3F77697-9069-4D3D-9A5D-3D83245BE1F7__GUID-73ABCCB7-400C-4236-9D63-5F596C8E9B7C">
                     <p class="titleinexample">示例16-2设置示例</p>
                  </div>
                  <!-- class="example" -->
                  <div class="section">
                     <p><a href="jms-service-types-examples.html#GUID-D3F77697-9069-4D3D-9A5D-3D83245BE1F7__I1005669">例16-1</a>为JMS类型示例执行必要的设置。复制并将其保存为<code class="codeph">setup.sql</code> 。
                     </p>
                  </div>
                  <!-- class="section" -->
               </div>
            </div><a id="ADQUE3181"></a><a id="ADQUE3182"></a><a id="ADQUE3180"></a><div class="props_rev_3"><a id="GUID-D2118ED4-285B-4C73-A88B-09B9F55BBB76" name="GUID-D2118ED4-285B-4C73-A88B-09B9F55BBB76"></a><h3 id="ADQUE-GUID-D2118ED4-285B-4C73-A88B-09B9F55BBB76" class="sect3"><span class="enumeration_section">16.2</span> JMS BytesMessage示例</h3>
               <div>
                  <div class="section">
                     <p>本节包含说明JMS <code class="codeph">BytesMessage</code>队和出列的示例。
                     </p>
                     <p><a href="jms-service-types-examples.html#GUID-D2118ED4-285B-4C73-A88B-09B9F55BBB76__I1005861">例16-3</a>显示了如何使用带有<code class="codeph">DBMS_AQ</code>函数的JMS类型成员函数来填充和排队数据库中表示为<code class="codeph">sys.aq$_jms_bytes_message</code>类型的JMS <code class="codeph">BytesMessage</code> 。稍后此消息可由JAVA <a href="glossary.html#GUID-9885B911-8AC1-49F3-922E-1F8D64C4501D"><span class="xrefglossterm">Oracle Java消息服务</span></a> （Oracle JMS）客户端出列。
                     </p>
                     <p><a href="jms-service-types-examples.html#GUID-D2118ED4-285B-4C73-A88B-09B9F55BBB76__CIHBJGDD">示例16-4</a>说明了如何使用带有<code class="codeph">DBMS_AQ</code>函数的JMS类型成员函数从数据库中表示为<code class="codeph">sys.aq$_jms_bytes_message</code>类型的JMS <code class="codeph">BytesMessage</code>出列数据并从中检索数据。此消息可能由Oracle JMS客户端排队。
                     </p>
                  </div>
                  <!-- class="section" -->
                  <div class="example" id="GUID-D2118ED4-285B-4C73-A88B-09B9F55BBB76__I1005861">
                     <p class="titleinexample">示例16-3填充和排队BytesMessage</p><pre class="oac_no_warn" dir="ltr">set echo offset verify offconnect sysDROP USER jmsuser CASCADE; ACCEPT password CHAR PROMPT'输入JMSUSER的密码：'HIDECREATE USER jmsuser IDENTIFIED BY＆password; GRANT DBA，AQ_ADMINISTRATOR_ROLE，AQ_USER_ROLE to jmsuser; GRANT EXECUTE ON DBMS_AQADM to jmsuser; GRANT EXECUTE ON DBMS_AQ TO jmsuser;在DBMS_LOB上执行GRANT EXECUTE到jmsuser;在DBMS_JMS_PLSQL上执行GRANT EXECUTE到jmsuser;在DECLARE id上连接jmsuser /＆password SET ECHO ON set serveroutput pls_integer; agent sys.aq $ _agent：= sys.aq $ _agent（''，null，0）; message sys.aq $ _jms_bytes_message; enqueue_options dbms_aq.enqueue_options_t; message_properties dbms_aq.message_properties_t; msgstr raw（16）; java_exp异常;编译指示EXCEPTION_INIT（java_exp，-24197）; BEGIN  - 构造一个空的BytesMessage对象消息：= sys.aq $ _jms_bytes_message.construct; - 显示如何设置JMS头消息.set_replyto（agent）; message.set_type（ 'tkaqpet1'）; message.set_userid（ 'jmsuser'）; message.set_appid（ 'plsql_enq'）; message.set_groupid（ 'ST'）; message.set_groupseq（1）; - 显示如何设置JMS用户属性message.set_string_property（'color'，'RED'）; message.set_int_property（'year'，1999）; message.set_float_property（'price'，16999.99）; message.set_long_property（'mileage'，300000）; message.set_boolean_property（'import'，True）; message.set_byte_property（'password'， -  127）; - 显示如何填充aq $ _jms_bytes_message的消息有效负载 - 传递-1在sys.aq $ _jms_bytes_message的消息存储库中保留新的插槽。- 要在一个会话中同时运行的sys.aq $ _jms_bytes_message类型的最大数量为20。如果当前操作的消息已经为20，则调用带参数-1的clean_body函数可能会导致ORA-24199错误。- 用户负责调用clean或clean_all函数来清理消息存储库。id：= message.clear_body（-1）; - 将数据写入BytesMessage paylaod。这些功能类似于JMS JAVA api。- 有关详细信息，请参阅文档。- 将字节写入BytesMessage有效负载message.write_byte（id，10）; - 将RAW数据作为字节数组写入BytesMessage有效负载message.write_bytes（id，UTL_RAW.XRANGE（HEXTORAW（'00'），HEXTORAW（'FF'）））; - 将一部分RAW数据作为字节数组写入BytesMessage有效负载 - 注意偏移遵循JAVA约定，从0开始message.write_bytes（id，UTL_RAW.XRANGE（HEXTORAW（'00'），HEXTORAW（'FF'） ），0,16）; - 将字符写入BytesMessage有效负载message.write_char（id，'A'）; - 将一个double写入BytesMessage有效负载message.write_double（id，9999.99）; - 将一个浮点写入BytesMessage有效负载message.write_float（id，99.99）; - 将一个int写入BytesMessage有效负载message.write_int（id，12345）; - 将一个long写入BytesMessage有效负载message.write_long（id，1234567）; - 写一个BytesMessage有效负载message.write_short（id，123）的简短; - 将字符串写入BytesMessage有效负载， - 字符串在消息有效负载message.write_utf（id，'Hello World！）中以UTF8编码。“）; - 将数据从JAVA存储过程（JServ）刷新到PL / SQL端 - 如果不执行此操作，PL / SQL消息仍为空。message.flush（ID）; - 当用户 - 不打算再对此消息进行paylaod填充时，使用clean_all或clean来清理消息存储库sys.aq $ _jms_bytes_message.clean_all（）; --message.clean（ID）; - 使用DBMS_AQ包dbms_aq.enqueue将此消息排入AQ队列（queue_name =&gt;'jmsuser.jms_bytes_que'，enqueue_options =&gt; enqueue_options，message_properties =&gt; message_properties，payload =&gt; message，msgid =&gt; msgid）; java_exp之后的异常那么dbms_output.put_line（'异常信息：'）; display_exp（sys.aq $ _jms_stream_message.get_exception（））;结束; / commit;</pre></div>
                  <!-- class="example" -->
                  <div class="example" id="GUID-D2118ED4-285B-4C73-A88B-09B9F55BBB76__CIHBJGDD">
                     <p class="titleinexample">示例16-4出列和检索JMS BytesMessage数据</p><pre class="oac_no_warn" dir="ltr">设置echo off set verify off DROP USER jmsuser CASCADE;接受密码CHAR PROMPT'输入JMSUSER的密码：'HIDE CREATE USER jmsuser IDENTIFIED BY＆password;在DBMS_AQADM上执行GRANT EXECUTE到jmsuser;在DBMS_AQ上执行GRANT EXECUTE到jmsuser;在DBMS_LOB上执行GRANT EXECUTE到jmsuser;在DBMS_JMS_PLSQL上执行GRANT EXECUTE到jmsuser;在设置serveroutput上连接jmsuser /＆password set echo，大小为20000 DECLARE id pls_integer; blob_data blob; clob_data clob; blob_len pls_integer; message sys.aq $ _jms_bytes_message; agent sys.aq $ _agent; dequeue_options dbms_aq.dequeue_options_t; message_properties dbms_aq.message_properties_t; msgstr raw（16）; gdata sys.aq $ _jms_value; java_exp异常;编译指示EXCEPTION_INIT（java_exp，-24197）; BEGIN DBMS_OUTPUT.ENABLE（20000）; - 使用DBMS_AQ包dbms_aq.dequeue从队列队列中取消此消息（queue_name =&gt;'jmsuser.jms_bytes_que'，dequeue_options =&gt; dequeue_options，message_properties =&gt; message_properties，payload =&gt; message，msgid =&gt; msgid）; - 检索标头代理：= message.get_replyto; dbms_output.put_line（'Type：'|| message.get_type ||'UserId：'|| message.get_userid ||'AppId：'|| message.get_appid ||'GroupId：'|| message.get_groupid ||'GroupSeq ：'|| message.get_groupseq）; - 检索用户属性dbms_output.put_line（'price：'|| message.get_float_property（'price'））; dbms_output.put_line（'color：'|| message.get_string_property（'color'））;如果message.get_boolean_property（'import'）= TRUE那么dbms_output.put_line（'import：Yes'）; ELSIF message.get_boolean_property（'import'）= FALSE那么dbms_output.put_line（'import：No'）;万一; dbms_output.put_line（'year：'|| message.get_int_property（'year'））; dbms_output.put_line（'mileage：'|| message.get_long_property（'mileage'））; dbms_output.put_line（'password：'|| message.get_byte_property（'password'））; - 显示如何检索aq $ _jms_bytes_message的消息有效负载 - 准备调用，将PL / SQL aq $ _jms_bytes_message对象中的内容以字节数组的形式发送到Java存储过程（Jserv）。- 传递-1在sys.aq $ _jms_bytes_message的msg存储中保留一个新槽。- 在会话中同时运行的最大sys.aq $ _jms_bytes_message类型的消息是20。打电话给clean_body fn。使用参数-1  - 如果操作的消息已经是20，则可能导致ORA-24199错误。- 您必须调用clean或clean_all函数来清理消息存储库。id：= message.prepare（-1）; - 从BytesMessage paylaod读取数据。这些fns。类似于JMS Java  -  API。有关详细信息，请参阅JMS类型一章。DBMS_OUTPUT.PUT_LINE（ '有效载荷：'）; - 从BytesMessage有效负载dbms_output.put_line读取一个字节（'read_byte：'|| message.read_byte（id））; - 从BytesMessage有效负载dbms_output.put_line（'read_bytes：'）中读取一个字节数组到blob对象中; blob_len：= message.read_bytes（id，blob_data，272）; display_blob（blob_data）; - 从BytesMessage有效负载dbms_output.put_line读取一个char（'read_char：'|| message.read_char（id））; - 从BytesMessage有效负载dbms_output.put_line读取一个double（'read_double：'|| message.read_double（id））; - 从BytesMessage有效负载dbms_output.put_line读取一个浮点数（'read_float：'|| message.read_float（id））; - 从BytesMessage有效负载dbms_output.put_line读取一个int（'read_int：'|| message.read_int（id））; - 从BytesMessage有效负载dbms_output.put_line读取一个long（'read_long：'|| message.read_long（id））; - 从BytesMessage有效负载dbms_output.put_line读取一个short（'read_short：'|| message.read_short（id））; - 从BytesMessage有效负载读取字符串。- 字符串在消息有效负载dbms_output.put_line（'read_utf：'）中以UTF8编码; message.read_utf（id，clob_data）; display_clob（clob_data）; - 当用户 - 不打算再对此消息进行paylaod检索时，使用clean_all或clean来清理消息存储库message.clean（id）; -  sys.aq $ _jms_bytes_message.clean_all（）; java_exp之后的异常那么dbms_output.put_line（'异常信息：'）; display_exp（sys.aq $ _jms_bytes_message.get_exception（））;结束; / commit;</pre></div>
                  <!-- class="example" -->
               </div>
            </div><a id="ADQUE3184"></a><a id="ADQUE3185"></a><a id="ADQUE3183"></a><div class="props_rev_3"><a id="GUID-2A106B5C-925F-4ED2-9C4D-331BAF261F66" name="GUID-2A106B5C-925F-4ED2-9C4D-331BAF261F66"></a><h3 id="ADQUE-GUID-2A106B5C-925F-4ED2-9C4D-331BAF261F66" class="sect3"><span class="enumeration_section">16.3</span> JMS StreamMessage示例</h3>
               <div>
                  <div class="section">
                     <p>本节包含说明JMS <code class="codeph">StreamMessage</code>队和出列的示例。
                     </p>
                     <p><a href="jms-service-types-examples.html#GUID-2A106B5C-925F-4ED2-9C4D-331BAF261F66__CIHGJBCG">例16-5</a>显示了如何使用带有<code class="codeph">DBMS_AQ</code>函数的JMS类型成员函数来填充和排队数据库中表示为<code class="codeph">sys.aq$_jms_stream_message</code>类型的JMS <code class="codeph">StreamMessage</code> 。稍后此消息可由Oracle JMS客户端出列。
                     </p>
                     <p><a href="jms-service-types-examples.html#GUID-2A106B5C-925F-4ED2-9C4D-331BAF261F66__I1006207">例16-6</a>显示了如何使用带有<code class="codeph">DBMS_AQ</code>函数的JMS类型成员函数从数据库中表示为<code class="codeph">sys.aq$_jms_stream_message</code>类型的JMS <code class="codeph">StreamMessage</code>出列数据并从中检索数据。此消息可能由Oracle JMS客户端排队。
                     </p>
                  </div>
                  <!-- class="section" -->
                  <div class="example" id="GUID-2A106B5C-925F-4ED2-9C4D-331BAF261F66__CIHGJBCG">
                     <p class="titleinexample">示例16-5填充和排队JMS StreamMessage</p><pre class="oac_no_warn" dir="ltr">设置echo off set verify off DROP USER jmsuser CASCADE;接受密码CHAR PROMPT'输入JMSUSER的密码：'HIDE CREATE USER jmsuser IDENTIFIED BY＆password;在DBMS_AQADM上执行GRANT EXECUTE到jmsuser;在DBMS_AQ上执行GRANT EXECUTE到jmsuser;在DBMS_LOB上执行GRANT EXECUTE到jmsuser;在DBMS_JMS_PLSQL上执行GRANT EXECUTE到jmsuser; connect jmsuser /＆password SET ECHO ON在DECLARE id pls_integer上设置serveroutput; agent sys.aq $ _agent：= sys.aq $ _agent（''，null，0）; message sys.aq $ _jms_stream_message; enqueue_options dbms_aq.enqueue_options_t; message_properties dbms_aq.message_properties_t; msgstr raw（16）; java_exp异常;编译指示EXCEPTION_INIT（java_exp，-24197）; BEGIN  - 构造一个空的StreamMessage对象消息：= sys.aq $ _jms_stream_message.construct; - 显示如何设置JMS头消息.set_replyto（agent）; message.set_type（ 'tkaqpet1'）; message.set_userid（ 'jmsuser'）; message.set_appid（ 'plsql_enq'）; message.set_groupid（ 'ST'）; message.set_groupseq（1）; - 显示如何设置JMS用户属性message.set_string_property（'color'，'RED'）; message.set_int_property（'year'，1999）; message.set_float_property（'price'，16999.99）; message.set_long_property（'mileage'，300000）; message.set_boolean_property（'import'，True）; message.set_byte_property（'password'， -  127）; - 显示如何填充aq $ _jms_stream_message的消息有效负载 - 传递-1在sys.aq $ _jms_stream_message的消息存储中保留一个新插槽。- 要在一个会话中同时运行的sys.aq $ _jms_stream_message类型的最大数量的消息是20。如果当前操作的消息已经为20，则调用带参数-1的clean_body函数可能会导致ORA-24199错误。- 用户负责调用clean或clean_all函数来清理消息存储库。id：= message.clear_body（-1）; - 将数据写入消息paylaod。这些功能类似于JMS JAVA api。- 有关详细信息，请参阅文档。- 将一个字节写入StreamMessage有效载荷message.write_byte（id，10）; - 将RAW数据作为字节数组写入StreamMessage有效负载message.write_bytes（id，UTL_RAW.XRANGE（HEXTORAW（'00'），HEXTORAW（'FF'）））; - 将RAW数据的一部分作为字节数组写入StreamMessage有效负载 - 注意偏移遵循JAVA约定，从0开始message.write_bytes（id，UTL_RAW.XRANGE（HEXTORAW（'00'），HEXTORAW（'FF'） ）），0,16）; - 将一个字符写入StreamMessage有效负载message.write_char（id，'A'）; - 将一个double写入StreamMessage有效负载message.write_double（id，9999.99）; - 将一个浮点写入StreamMessage有效负载message.write_float（id，99.99）; - 将一个int写入StreamMessage有效负载message.write_int（id，12345）; - 将一个long写入StreamMessage有效负载message.write_long（id，1234567）; - 写一个简短的StreamMessage有效载荷message.write_short（id，123）; - 将一个字符串写入StreamMessage有效负载message.write_string（id，'Hello World！“）; - 将数据从JAVA存储过程（JServ）刷新到PL / SQL端 - 如果不执行此操作，PL / SQL消息仍为空。message.flush（ID）; - 当用户 - 不打算再对此消息进行paylaod填充时，使用clean_all或clean来清理消息存储库sys.aq $ _jms_stream_message.clean_all（）; --message.clean（ID）; - 使用DBMS_AQ包dbms_aq.enqueue将此消息排入AQ队列（queue_name =&gt;'jmsuser.jms_stream_que'，enqueue_options =&gt; enqueue_options，message_properties =&gt; message_properties，payload =&gt; message，msgid =&gt; msgid）; java_exp之后的异常那么dbms_output.put_line（'异常信息：'）; display_exp（sys.aq $ _jms_stream_message.get_exception（））;结束; / commit;</pre></div>
                  <!-- class="example" -->
                  <div class="example" id="GUID-2A106B5C-925F-4ED2-9C4D-331BAF261F66__I1006207">
                     <p class="titleinexample">示例16-6从JMS StreamMessage中出列和检索数据</p><pre class="oac_no_warn" dir="ltr">设置echo off set verify off DROP USER jmsuser CASCADE;接受密码CHAR PROMPT'输入JMSUSER的密码：'HIDE CREATE USER jmsuser IDENTIFIED BY＆password;在DBMS_AQADM上执行GRANT EXECUTE到jmsuser;在DBMS_AQ上执行GRANT EXECUTE到jmsuser;在DBMS_LOB上执行GRANT EXECUTE到jmsuser;在DBMS_JMS_PLSQL上执行GRANT EXECUTE到jmsuser;在DECLARE id pls_integer上的set serveroutput上连接jmsuser /＆password set echo; blob_data blob; clob_data clob; message sys.aq $ _jms_stream_message; agent sys.aq $ _agent; dequeue_options dbms_aq.dequeue_options_t; message_properties dbms_aq.message_properties_t; msgstr raw（16）; gdata sys.aq $ _jms_value; java_exp异常;编译指示EXCEPTION_INIT（java_exp，-24197）; BEGIN DBMS_OUTPUT.ENABLE（20000）; - 使用DBMS_AQ包dbms_aq.dequeue从队列队列中取消此消息（queue_name =&gt;'jmsuser.jms_stream_que'，dequeue_options =&gt; dequeue_options，message_properties =&gt; message_properties，payload =&gt; message，msgid =&gt; msgid）; - 检索标头代理：= message.get_replyto; dbms_output.put_line（'Type：'|| message.get_type ||'UserId：'|| message.get_userid ||'AppId：'|| message.get_appid ||'GroupId：'|| message.get_groupid ||'GroupSeq ：'|| message.get_groupseq）; - 检索用户属性dbms_output.put_line（'price：'|| message.get_float_property（'price'））; dbms_output.put_line（'color：'|| message.get_string_property（'color'））;如果message.get_boolean_property（'import'）= TRUE那么dbms_output.put_line（'import：Yes'）; ELSIF message.get_boolean_property（'import'）= FALSE那么dbms_output.put_line（'import：No'）;万一; dbms_output.put_line（'year：'|| message.get_int_property（'year'））; dbms_output.put_line（'mileage：'|| message.get_long_property（'mileage'））; dbms_output.put_line（'password：'|| message.get_byte_property（'password'））; - 显示如何检索aq $ _jms_stream_message的消息有效负载 -  prepare调用以字节数组的形式将PL / SQL aq $ _jms_stream_message对象中的内容发送到-JAVA存储过程（Jserv）。- 传递-1在sys.aq $ _jms_stream_message的消息存储区中保留一个新插槽。- 要在一个会话中同时运行的sys.aq $ _jms_stream_message类型的最大数量的消息是20。如果当前操作的消息已经为20，则调用带参数-1的clean_body函数可能会导致ORA-24199错误。- 用户负责调用clean或clean_all函数来清理消息存储库。id：= message.prepare（-1）; - 假设用户知道StreamMessage有效负载中的数据类型。- 用户可以使用与数据类型对应的特定读取功能。- 这些功能类似于JMS JAVA api。有关详细信息，请参阅文档dbms_output.put_line（'按Type：'检索有效负载）; - 从StreamMessage有效负载dbms_output.put_line读取一个字节（'read_byte：'|| message.read_byte（id））; - 从StreamMessage有效负载dbms_output.put_line（'read_bytes：'）中将字节数组读入blob对象; message.read_bytes（id，blob_data）; display_blob（blob_data）; - 从StreamMessage有效负载dbms_output.put_line（'read_bytes：'）中将另一个字节数组读入blob对象; message.read_bytes（id，blob_data）; display_blob（blob_data）; - 从StreamMessage有效负载dbms_output.put_line（'read_char：'|| message.read_char（id））中读取一个char; - 从StreamMessage有效负载dbms_output.put_line读取一个double（'read_double：'|| message.read_double（id））; - 从StreamMessage有效负载dbms_output.put_line（'read_float：'|| message.read_float（id））中读取一个浮点数; - 从StreamMessage有效负载dbms_output.put_line读取一个int（'read_int：'|| message.read_int（id））; - 从StreamMessage有效负载dbms_output.put_line读取一个long（'read_long：'|| message.read_long（id））; - 从StreamMessage有效负载dbms_output.put_line读取一个short（'read_short：'|| message.read_short（id））; - 从StreamMessage有效负载dbms_output.put_line（'read_string：'）读取一个字符串到clob数据; message.read_string（id，clob_data）; display_clob（clob_data）; - 假设用户不知道StreamMessage有效负载中的数据类型。- 用户可以使用read_object方法将数据读入sys.aq $ _jms_value对象 - 这些函数类似于JMS JAVA api。有关详细信息，请参阅文档- 将流指针重置为消息的开头，以便我们可以再次读取消息有效负载。message.reset（ID）; LOOP message.read_object（id，gdata）;如果gdata IS NULL那么退出;万一; CASE gdata.type WHEN sys.dbms_jms_plsql。DATA_TYPE_BYTE那么dbms_output.put_line（'read_object / byte：'|| gdata.num_val）;什么时候sys.dbms_jms_plsql。DATA_TYPE_SHORT那么dbms_output.put_line（'read_object / short：'|| gdata.num_val）;什么时候sys.dbms_jms_plsql。DATA_TYPE_INTEGER那么dbms_output.put_line（'read_object / int：'|| gdata.num_val）;什么时候sys.dbms_jms_plsql。DATA_TYPE_LONG那么dbms_output.put_line（'read_object / long：'|| gdata.num_val）;什么时候sys.dbms_jms_plsql。DATA_TYPE_FLOAT那么dbms_output.put_line（'read_object / float：'|| gdata.num_val）;什么时候sys.dbms_jms_plsql。DATA_TYPE_DOUBLE那么dbms_output.put_line（'read_object / double：'|| gdata.num_val）;什么时候sys.dbms_jms_plsql。DATA_TYPE_BOOLEAN那么dbms_output.put_line（'read_object / boolean：'|| gdata.num_val）;什么时候sys.dbms_jms_plsql。DATA_TYPE_CHARACTER那么dbms_output.put_line（'read_object / char：'|| gdata.char_val）;什么时候sys.dbms_jms_plsql。DATA_TYPE_STRING那么dbms_output.put_line（'read_object / string：'）; display_clob（gdata.text_val）;什么时候sys.dbms_jms_plsql。DATA_TYPE_BYTES那么dbms_output.put_line（'read_object / bytes：'）; display_blob（gdata.bytes_val）; ELSE dbms_output.put_line（'没有这样的数据类型'）;结束案例;结束循环; - 当用户 - 不打算再对此消息进行paylaod检索时，使用clean_all或clean来清理消息存储库message.clean（id）; -  sys.aq $ _jms_stream_message.clean_all（）; java_exp之后的异常那么dbms_output.put_line（'异常信息：'）; display_exp（sys.aq $ _jms_stream_message.get_exception（））;结束; / commit;</pre></div>
                  <!-- class="example" -->
               </div>
            </div><a id="ADQUE3187"></a><a id="ADQUE3188"></a><a id="ADQUE3186"></a><div class="props_rev_3"><a id="GUID-806DD371-1C4B-4176-98BF-70C4401C4AF3" name="GUID-806DD371-1C4B-4176-98BF-70C4401C4AF3"></a><h3 id="ADQUE-GUID-806DD371-1C4B-4176-98BF-70C4401C4AF3" class="sect3"><span class="enumeration_section">16.4</span> JMS MapMessage示例</h3>
               <div>
                  <div class="section">
                     <p>本节包含说明JMS <code class="codeph">MapMessage</code>队和出列的示例。
                     </p>
                     <p><a href="jms-service-types-examples.html#GUID-806DD371-1C4B-4176-98BF-70C4401C4AF3__I1006368">实施例16-7</a>显示了如何使用JMS类型成员函数与<code class="codeph">DBMS_AQ</code>函数来填充和排队一个JMS <code class="codeph">MapMessage</code>表示为<code class="codeph">sys.aq$_jms_map_message</code>在数据库类型。稍后此消息可由Oracle JMS客户端出列。
                     </p>
                     <p><a href="jms-service-types-examples.html#GUID-806DD371-1C4B-4176-98BF-70C4401C4AF3__I1006473">实施例16-8</a>示出了如何使用JMS类型成员函数与<code class="codeph">DBMS_AQ</code>函数来从JMS出列和检索数据<code class="codeph">MapMessage</code>表示为<code class="codeph">sys.aq$_jms_map_message</code>在数据库类型。此消息可以由Oracle JMS客户端排队。
                     </p>
                  </div>
                  <!-- class="section" -->
                  <div class="example" id="GUID-806DD371-1C4B-4176-98BF-70C4401C4AF3__I1006368">
                     <p class="titleinexample">示例16-7填充和排队JMS MapMessage</p><pre class="oac_no_warn" dir="ltr">设置echo off set verify off DROP USER jmsuser CASCADE;接受密码CHAR PROMPT'输入JMSUSER的密码：'HIDE CREATE USER jmsuser IDENTIFIED BY＆password;在DBMS_AQADM上执行GRANT EXECUTE到jmsuser;在DBMS_AQ上执行GRANT EXECUTE到jmsuser;在DBMS_LOB上执行GRANT EXECUTE到jmsuser;在DBMS_JMS_PLSQL上执行GRANT EXECUTE到jmsuser; connect jmsuser /＆password SET ECHO ON在DECLARE id pls_integer上设置serveroutput; agent sys.aq $ _agent：= sys.aq $ _agent（''，null，0）; message sys.aq $ _jms_map_message; enqueue_options dbms_aq.enqueue_options_t; message_properties dbms_aq.message_properties_t; msgstr raw（16）; java_exp异常;编译指示EXCEPTION_INIT（java_exp，-24197）; BEGIN  - 构造一个空的地图消息对象消息：= sys.aq $ _jms_map_message.construct; - 显示如何设置JMS头消息.set_replyto（agent）; message.set_type（ 'tkaqpet1'）; message.set_userid（ 'jmsuser'）; message.set_appid（ 'plsql_enq'）; message.set_groupid（ 'ST'）; message.set_groupseq（1）; - 显示如何设置JMS用户属性message.set_string_property（'color'，'RED'）; message.set_int_property（'year'，1999）; message.set_float_property（'price'，16999.99）; message.set_long_property（'mileage'，300000）; message.set_boolean_property（'import'，True）; message.set_byte_property（'password'， -  127）; - 显示如何填充aq $ _jms_map_message的消息有效内容 - 传递-1在sys.aq $ _jms_map_message的消息存储中保留一个新插槽。- 要在一个会话中同时运行的sys.aq $ _jms_map_message类型的最大数量的消息是20。如果当前操作的消息已经为20，则调用带参数-1的clean_body函数可能会导致ORA-24199错误。- 用户负责调用clean或clean_all函数来清理消息存储库。id：= message.clear_body（-1）; - 将数据写入消息paylaod。这些功能类似于JMS JAVA api。- 有关详细信息，请参阅文档。- 在地图消息有效载荷message.set_byte中设置一个字节条目（id，'BYTE'，10）; - 使用地图消息有效载荷中的RAW数据设置字节数组条目message.set_bytes（id，'BYTES'，UTL_RAW.XRANGE（HEXTORAW（'00'），HEXTORAW（'FF'）））; - 仅使用地图消息有效负载中的一部分RAW数据设置字节数组条目 - 注意偏移遵循JAVA约定，从0消息开始.set_bytes（id，'BYTES_PART'，UTL_RAW.XRANGE（HEXTORAW（'00'） ），HEXTORAW（'FF'）），0,16）; - 在地图消息有效负载message.set_char中设置一个char条目（id，'CHAR'，'A'）; - 在地图消息有效负载message.set_double中设置一个双重条目（id，'DOUBLE'，9999.99）; - 在地图消息有效负载message.set_float中设置一个浮点项（id，'FLOAT'，99.99）; - 在地图消息有效负载message.set_int中设置一个int条目（id，'INT'，12345）; - 在地图消息有效负载message.set_long中设置一个长条目（id，'LONG'，1234567）; - 在地图消息有效负载message.set_short（id，'SHORT'，123）中设置一个短条目; - 在地图消息有效负载message.set_string中设置字符串条目（id，'STRING'，'Hello World！“）; - 将数据从JAVA存储过程（JServ）刷新到PL / SQL端 - 如果不执行此操作，PL / SQL消息仍为空。message.flush（ID）; - 当用户不再计划对此消息进行paylaod填充时，使用clean_all或clean来清理消息存储库sys.aq $ _jms_map_message.clean_all（）; --message.clean（ID）; - 使用DBMS_AQ包dbms_aq.enqueue将此消息排入AQ队列（queue_name =&gt;'jmsuser.jms_map_que'，enqueue_options =&gt; enqueue_options，message_properties =&gt; message_properties，payload =&gt; message，msgid =&gt; msgid）;结束; / commit;</pre></div>
                  <!-- class="example" -->
                  <div class="example" id="GUID-806DD371-1C4B-4176-98BF-70C4401C4AF3__I1006473">
                     <p class="titleinexample">示例16-8从JMS MapMessage中出列和检索数据</p><pre class="oac_no_warn" dir="ltr">设置echo off set verify off DROP USER jmsuser CASCADE;接受密码CHAR PROMPT'输入JMSUSER的密码：'HIDE CREATE USER jmsuser IDENTIFIED BY＆password;在DBMS_AQADM上执行GRANT EXECUTE到jmsuser;在DBMS_AQ上执行GRANT EXECUTE到jmsuser;在DBMS_LOB上执行GRANT EXECUTE到jmsuser;在DBMS_JMS_PLSQL上执行GRANT EXECUTE到jmsuser;在DECLARE id pls_integer上的set serveroutput上连接jmsuser /＆password set echo; blob_data blob; clob_data clob; message sys.aq $ _jms_map_message; agent sys.aq $ _agent; dequeue_options dbms_aq.dequeue_options_t; message_properties dbms_aq.message_properties_t; msgstr raw（16）; name_arr sys.aq $ _jms_namearray; gdata sys.aq $ _jms_value; java_exp异常;编译指示EXCEPTION_INIT（java_exp，-24197）; BEGIN DBMS_OUTPUT.ENABLE（20000）; - 使用DBMS_AQ包dbms_aq.dequeue从队列队列中取消此消息（queue_name =&gt;'jmsuser.jms_map_que'，dequeue_options =&gt; dequeue_options，message_properties =&gt; message_properties，payload =&gt; message，msgid =&gt; msgid）; - 检索标头代理：= message.get_replyto; dbms_output.put_line（'Type：'|| message.get_type ||'UserId：'|| message.get_userid ||'AppId：'|| message.get_appid ||'GroupId：'|| message.get_groupid ||'GroupSeq ：'|| message.get_groupseq）; - 检索用户属性dbms_output.put_line（'price：'|| message.get_float_property（'price'））; dbms_output.put_line（'color：'|| message.get_string_property（'color'））;如果message.get_boolean_property（'import'）= TRUE那么dbms_output.put_line（'import：Yes'）; ELSIF message.get_boolean_property（'import'）= FALSE那么dbms_output.put_line（'import：No'）;万一; dbms_output.put_line（'year：'|| message.get_int_property（'year'））; dbms_output.put_line（'mileage：'|| message.get_long_property（'mileage'））; dbms_output.put_line（'password：'|| message.get_byte_property（'password'））; - 显示如何检索aq $ _jms_map_message的消息有效负载 - 'Prepare'以字节数组的形式将PL / SQL aq $ _jms_map_message对象中的内容发送到Java存储过程（Jserv）。- 传递-1在 -  sys.aq $ _jms_map_message的消息存储库中保留一个新插槽。sys.aq $ _jms_map_message的最大数量 - 在一个会话中同时操作的消息类型是20。- 调用带参数-1的clean_body函数 - 如果当前操作的消息是 - 已经20，则可能导致ORA-24199错误。用户负责调用clean或clean_all函数 - 清理消息存储库。id：= message.prepare（-1）; - 假设用户知道地图消息有效负载中的名称和类型。- 用户可以使用名称来获取相应的值。- 这些函数类似于JMS Java API。有关详细信息，请参阅JMS类型一章。dbms_output.put_line（'按名称检索有效负载：'）; - 从地图消息有效负载dbms_output.put_line获取一个字节条目（'get_byte：'|| message.get_byte（id，'BYTE'））; - 从映射消息有效负载dbms_output.put_line（'get_bytes：'）获取字节数组条目; message.get_bytes（id，'BYTES'，blob_data）; display_blob（blob_data）; - 从映射消息有效负载dbms_output.put_line（'get_bytes：'）获取另一个字节数组条目; message.get_bytes（id，'BYTES_PART'，blob_data）; display_blob（blob_data）; - 从地图消息有效负载dbms_output.put_line获取char条目（'get_char：'|| message.get_char（id，'CHAR'））; - 从地图消息有效负载dbms_output.put_line获取双重条目（'get_double：'|| message.get_double（id，'DOUBLE'））; - 从映射消息有效负载dbms_output.put_line获取一个float条目（'get_float：'|| message.get_float（id，'FLOAT'））; - 从映射消息有效负载dbms_output.put_line获取一个int条目（'get_int：'|| message.get_int（id，'INT'））; - 从地图消息有效负载dbms_output.put_line获取一个长条目（'get_long：'|| message.get_long（id，'LONG'））; - 从地图消息有效负载dbms_output.put_line获取一个简短条目（'get_short：'|| message.get_short（id，'SHORT'））; - 从地图消息有效负载dbms_output.put_line（'get_string：'）获取字符串条目; message.get_string（id，'STRING'，clob_data）; display_clob（clob_data）; - 假设用户不知道地图消息有效负载中的名称和类型。- 用户可以首先检索包含 -  payload中所有名称的name数组，并遍历名称列表并获取相应的值。这些函数类似于JMS Java API。- 有关详细信息，请参阅JMS类型章节。dbms_output.put_line（'通过迭代检索有效负载：'）; - 从地图消息有效负载中获取名称数组name_arr：= message.get_names（id）; - 遍历name数组以检索每个名称的值。FOR i IN name_arr。FIRST..name_arr。最后的循环 - 测试地图消息有效负载中是否存在名称 - （在这种情况下，没有必要说明如何使用它）IF message.item_exists（id，name_arr（i））那么dbms_output.put_line （'item exists：'|| name_arr（i））; - 因为我们不知道条目的类型，我们必须使用sys.aq $ _jms_value  - 类型对象来返回数据的消息.get_object（id，name_arr（i），gdata）;如果gdata不是NULL那么CASE gdata.type WHEN sys.dbms_jms_plsql。DATA_TYPE_BYTE那么dbms_output.put_line（'get_object / byte：'|| gdata.num_val）;什么时候sys.dbms_jms_plsql。DATA_TYPE_SHORT那么dbms_output.put_line（'get_object / short：'|| gdata.num_val）;什么时候sys.dbms_jms_plsql。DATA_TYPE_INTEGER那么dbms_output.put_line（'get_object / int：'|| gdata.num_val）;什么时候sys.dbms_jms_plsql。DATA_TYPE_LONG那么dbms_output.put_line（'get_object / long：'|| gdata.num_val）;什么时候sys.dbms_jms_plsql。DATA_TYPE_FLOAT那么dbms_output.put_line（'get_object / float：'|| gdata.num_val）;什么时候sys.dbms_jms_plsql。DATA_TYPE_DOUBLE那么dbms_output.put_line（'get_object / double：'|| gdata.num_val）;什么时候sys.dbms_jms_plsql。DATA_TYPE_BOOLEAN那么dbms_output.put_line（'get_object / boolean：'|| gdata.num_val）;什么时候sys.dbms_jms_plsql。DATA_TYPE_CHARACTER那么dbms_output.put_line（'get_object / char：'|| gdata.char_val）;什么时候sys.dbms_jms_plsql。DATA_TYPE_STRING那么dbms_output.put_line（'get_object / string：'）; display_clob（gdata.text_val）;什么时候sys.dbms_jms_plsql。DATA_TYPE_BYTES那么dbms_output.put_line（'get_object / bytes：'）; display_blob（gdata.bytes_val）; ELSE dbms_output.put_line（'没有这样的数据类型'）;结束案例;万一; ELSE dbms_output.put_line（'item not exists：'|| name_arr（i））;万一;结束循环; - 当用户 - 不打算再对此消息进行paylaod填充时，使用clean_all或clean来清理消息存储库message.clean（id）; -  sys.aq $ _jms_map_message.clean_all（）; java_exp之后的异常那么dbms_output.put_line（'异常信息：'）; display_exp（sys.aq $ _jms_stream_message.get_exception（））;结束; / commit;</pre></div>
                  <!-- class="example" -->
               </div>
            </div><a id="ADQUE3190"></a><a id="ADQUE3191"></a><a id="ADQUE3189"></a><div class="props_rev_3"><a id="GUID-CFB48BB3-9498-4AF2-904A-3D081E6B9A34" name="GUID-CFB48BB3-9498-4AF2-904A-3D081E6B9A34"></a><h3 id="ADQUE-GUID-CFB48BB3-9498-4AF2-904A-3D081E6B9A34" class="sect3"><span class="enumeration_section">16.5</span>更多Oracle数据库高级队列JMS示例</h3>
               <div>
                  <div class="section">
                     <p><a href="jms-service-types-examples.html#GUID-CFB48BB3-9498-4AF2-904A-3D081E6B9A34__i1006655">示例16-9中</a>的示例程序在通过Oracle JMS管理接口创建的Oracle数据库高级队列队列中排队大型<code class="codeph">TextMessage</code> （以及JMS用户属性）以保存JMS <code class="codeph">TEXT</code>消息。此示例中排队的<code class="codeph">TextMessage</code>和<code class="codeph">BytesMessage</code>都可以使用Oracle JMS客户端出列。
                     </p>
                     <p><a href="jms-service-types-examples.html#GUID-CFB48BB3-9498-4AF2-904A-3D081E6B9A34__CHDECGGB">例16-10中</a>的示例程序将大型<code class="codeph">BytesMessage</code>排入队列。
                     </p>
                  </div>
                  <!-- class="section" -->
                  <div class="example" id="GUID-CFB48BB3-9498-4AF2-904A-3D081E6B9A34__i1006655">
                     <p class="titleinexample">示例16-9将大型TextMessage排入队列</p><pre class="oac_no_warn" dir="ltr">DECLARE text varchar2（32767）; agent sys.aq $ _agent：= sys.aq $ _agent（''，null，0）; message sys.aq $ _jms_text_message; enqueue_options dbms_aq.enqueue_options_t; message_properties dbms_aq.message_properties_t; msgstr raw（16）; BEGIN消息：= sys.aq $ _jms_text_message.construct; message.set_replyto（剂）; message.set_type（ 'tkaqpet2'）; message.set_userid（ 'jmsuser'）; message.set_appid（ 'plsql_enq'）; message.set_groupid（ 'ST'）; message.set_groupseq（1）; message.set_boolean_property（'import'，True）; message.set_string_property（'color'，'RED'）; message.set_short_property（'year'，1999）; message.set_long_property（'mileage'，300000）; message.set_double_property（'price'，16999.99）; message.set_byte_property（'password'，127）; FOR i IN 1..500 LOOP text：= CONCAT（text，'1234567890'）;结束循环; message.set_text（文本）; dbms_aq.enqueue（queue_name =&gt;'jmsuser.jms_text_t1'，enqueue_options =&gt; enqueue_options，message_properties =&gt; message_properties，payload =&gt; message，msgid =&gt; msgid）;结束;</pre></div>
                  <!-- class="example" -->
                  <div class="example" id="GUID-CFB48BB3-9498-4AF2-904A-3D081E6B9A34__CHDECGGB">
                     <p class="titleinexample">示例16-10将大BytesMessage排入队列</p><pre class="oac_no_warn" dir="ltr">DECLARE text VARCHAR2（32767）; bytes RAW（32767）; agent sys.aq $ _agent：= sys.aq $ _agent（''，null，0）; message sys.aq $ _jms_bytes_message;身体BLOB;位置INT; enqueue_options dbms_aq.enqueue_options_t; message_properties dbms_aq.message_properties_t; msgstr raw（16）; BEGIN消息：= sys.aq $ _jms_bytes_message.construct; message.set_replyto（剂）; message.set_type（ 'tkaqper4'）; message.set_userid（ 'jmsuser'）; message.set_appid（ 'plsql_enq_raw'）; message.set_groupid（ 'ST'）; message.set_groupseq（1）; message.set_boolean_property（'import'，True）; message.set_string_property（'color'，'RED'）; message.set_short_property（'year'，1999）; message.set_long_property（'mileage'，300000）; message.set_double_property（'price'，16999.99）; - 准备一个巨大的有效载荷到一个blob for i IN 1..1000 LOOP text：= CONCAT（text，'0123456789ABCDEF'）;结束循环; bytes：= HEXTORAW（text）; dbms_lob.createtemporary（lob_loc =&gt; body，cache =&gt; TRUE）; dbms_lob.open（body，DBMS_LOB.LOB_READWRITE）;位置：= 1; FOR i IN 1..10 LOOP dbms_lob.write（lob_loc =&gt; body，amount =&gt; FLOOR（（LENGTH（bytes）+1）/ 2），offset =&gt; position，buffer =&gt; bytes）; position：= position + FLOOR（（LENGTH（bytes）+1）/ 2）;结束循环; - 准备消息的结束message.set_bytes（body）; dbms_aq.enqueue（queue_name =&gt;'jmsuser.jms_bytes_t1'，enqueue_options =&gt; enqueue_options，message_properties =&gt; message_properties，payload =&gt; message，msgid =&gt; msgid）; dbms_lob.freetemporary（lob_loc =&gt; body）;结束;</pre></div>
                  <!-- class="example" -->
               </div>
            </div>
         </div>
      </article>
   </body>
</html>