<html lang="en-us" dir="ltr" xml:lang="en-us">
   <head>
      <meta http-equiv="Content-Type" content="text/html; charset=utf-8"></meta>
      <meta name="viewport" content="width=device-width, initial-scale=1"></meta>
      <meta http-equiv="X-UA-Compatible" content="IE=edge"></meta>
      <meta name="abstract" content="Managing tables includes tasks such as creating tables, loading tables, altering tables, and dropping tables."></meta>
      <meta name="description" content="Managing tables includes tasks such as creating tables, loading tables, altering tables, and dropping tables."></meta>
      <title>管理表</title>
      <meta property="og:site_name" content="Oracle Help Center"></meta>
      <meta property="og:title" content="Database Administrator’s Guide "></meta>
      <meta property="og:description" content="Managing tables includes tasks such as creating tables, loading tables, altering tables, and dropping tables."></meta>
      <link rel="stylesheet" href="/sp_common/book-template/ohc-book-template/css/book.css"></link>
      <link rel="shortcut icon" href="/sp_common/book-template/ohc-common/img/favicon.ico"></link>
      <meta name="application-name" content="Database Administrator’s Guide"></meta>
      <meta name="generator" content="DITA Open Toolkit version 1.8.5 (Mode = doc)"></meta>
      <meta name="plugin" content="SP_docbuilder HTML plugin release 18.2.2"></meta>
      <link rel="alternate" href="database-administrators-guide.pdf" title="PDF File" type="application/pdf"></link>
      <meta name="robots" content="all"></meta>
      <link rel="schema.dcterms" href="http://purl.org/dc/terms/"></link>
      <meta name="dcterms.created" content="2019-03-14T11:02:35-07:00"></meta>
      
      <meta name="dcterms.dateCopyrighted" content="1996, 2019"></meta>
      <meta name="dcterms.category" content="database"></meta>
      <meta name="dcterms.identifier" content="E96348-04"></meta>
      
      <meta name="dcterms.product" content="en/database/oracle/oracle-database/19"></meta>
      
      <link rel="prev" href="managing-space-for-schema-objects.html" title="Previous" type="text/html"></link>
      <link rel="next" href="managing-indexes.html" title="Next" type="text/html"></link>
      <script>
        document.write('<style type="text/css">');
        document.write('body > .noscript, body > .noscript ~ * { visibility: hidden; }');
        document.write('</style>');
     </script>
      <script src="/sp_common/book-template/requirejs/require.js" data-main="/sp_common/book-template/ohc-book-template/js/book-config"></script>
      <script>
            if (window.require === undefined) {
                document.write('<script data-main="sp_common/book-template/ohc-book-template/js/book-config" src="sp_common/book-template/requirejs/require.js"><\/script>');
                document.write('<link href="sp_common/book-template/ohc-book-template/css/book.css" rel="stylesheet"/>');
            }
        </script>
      <script type="application/json" id="ssot-metadata">{"primary":{"category":{"short_name":"database","element_name":"Database","display_in_url":true},"suite":{"short_name":"oracle","element_name":"Oracle","display_in_url":true},"product_group":{"short_name":"not-applicable","element_name":"Not applicable","display_in_url":false},"product":{"short_name":"oracle-database","element_name":"Oracle Database","display_in_url":true},"release":{"short_name":"19","element_name":"Release 19","display_in_url":true}}}</script>
      
    <meta name="dcterms.title" content="Database Administrator&#39;s Guide"></meta>
    <meta name="dcterms.isVersionOf" content="ADMIN"></meta>
    <meta name="dcterms.release" content="Release 19"></meta>
  </head>
   <body dir="ltr">
      <div class="noscript alert alert-danger text-center" role="alert">
         <a href="managing-space-for-schema-objects.html" class="pull-left"><span class="glyphicon glyphicon-chevron-left" aria-hidden="true"></span>上一页</a> <a href="managing-indexes.html" class="pull-right">下一页<span class="glyphicon glyphicon-chevron-right" aria-hidden="true"></span></a> <span class="fa fa-exclamation-triangle" aria-hidden="true"></span>必须启用JavaScript才能正确显示此内容</div>
      <article>
         <header>
            <ol class="breadcrumb" vocab="http://schema.org/" typeof="BreadcrumbList">
               <li property="itemListElement" typeof="ListItem"><a href="index.html" property="item" typeof="WebPage"><span property="name">数据库管理员指南</span></a></li>
               <li property="itemListElement" typeof="ListItem"><a href="schema-objects.html" property="item" typeof="WebPage"><span property="name">架构对象</span></a></li>
               <li class="active" property="itemListElement" typeof="ListItem">管理表</li>
            </ol>
            <a id="GUID-707B02F5-E589-4C20-8E2E-5ED4F7888702" name="GUID-707B02F5-E589-4C20-8E2E-5ED4F7888702"></a><a id="ADMIN015"></a>
            
            <h2 id="ADMIN-GUID-707B02F5-E589-4C20-8E2E-5ED4F7888702" class="sect2"><span class="enumeration_chapter">20</span>管理表</h2>
         </header>
         <div class="ind">
            <div>
               <p>管理表包括创建表，加载表，更改表和删除表等任务。</p>
               <div class="infoboxnote" id="GUID-707B02F5-E589-4C20-8E2E-5ED4F7888702__GUID-C69FB35C-9EA1-444F-ABC9-473E0743A3F5">
                  <p class="notep1">实时SQL：</p>
                  <p>要查看和运行与本章有关Oracle Live SQL的示例，请转到<a href="https://livesql.oracle.com/apex/livesql/docs/admin/managing-tables/create-modify.html" target="_blank"><span class="italic">Oracle Live SQL：创建和修改表</span></a> 。
                  </p>
               </div>
            </div>
            <div>
               <ul class="ullinks">
                  <li class="ulchildlink"><a href="managing-tables.html#GUID-2634BF31-512E-4276-99D4-848A535D273B">关于表格</a><br>表是Oracle数据库中数据存储的基本单元。数据存储在行和列中。
                  </li>
                  <li class="ulchildlink"><a href="managing-tables.html#GUID-86F766C5-2344-4790-95E4-4E813A0B21DA">管理表指南</a><br>遵循指南可以使表的管理更容易，并且可以在创建表时以及加载，更新和查询表数据时提高性能。
                  </li>
                  <li class="ulchildlink"><a href="managing-tables.html#GUID-D2802D28-D8B3-4C21-99EC-342DC42F9898">创建表</a><br>使用SQL语句<code class="codeph">CREATE TABLE</code> 。</li>
                  <li class="ulchildlink"><a href="managing-tables.html#GUID-7B5676FC-59B4-418F-826B-8F4D7E3690E2">加载表格</a><br>有几种将数据加载到表中的技术。
                  </li>
                  <li class="ulchildlink"><a href="managing-tables.html#GUID-43794F5A-1B13-4E97-B4DD-31AEB9633E9A">优化批量更新的性能</a><br>该<code class="codeph">EXECUTE_UPDATE</code>在程序<code class="codeph">DBMS_REDEFINITION</code>包可以优化的批量更新的表的性能。性能已优化，因为更新未记录在重做日志中。
                  </li>
                  <li class="ulchildlink"><a href="managing-tables.html#GUID-7BFAA5E3-1509-4691-BBED-35F863F7D09F">自动收集表格统计信息</a><br>PL / SQL包<code class="codeph">DBMS_STATS</code>允许您生成和管理基于成本的优化的统计信息。您可以使用此包来收集，修改，查看，导出，导入和删除统计信息。您还可以使用此包来标识或命名已收集的统计信息。
                  </li>
                  <li class="ulchildlink"><a href="managing-tables.html#GUID-D4AE1CF2-08F7-4AB2-9317-0DE20AC70D44">改变表格</a><br>您使用<code class="codeph">ALTER TABLE</code>语句<code class="codeph">ALTER TABLE</code> 。要更改表，该表必须包含在模式中，或者您必须具有表的<code class="codeph">ALTER</code>对象特权或<code class="codeph">ALTER ANY TABLE</code>系统特权。
                  </li>
                  <li class="ulchildlink"><a href="managing-tables.html#GUID-92361F74-4796-407D-A3B9-569C6E544E34">在线重新定义表格</a><br>您可以修改表的逻辑或物理结构。
                  </li>
                  <li class="ulchildlink"><a href="managing-tables.html#GUID-2DD8A6E0-0195-4F3F-83A9-74BE0980FBA4">研究和扭转错误的表格变化</a><br>为了使您能够研究和逆转对表的错误更改，Oracle数据库提供了一组功能，您可以使用这些功能查看数据库对象的过去状态，或者在不使用时间点介质恢复的情况下将数据库对象返回到先前状态。这些功能称为<span class="bold">Oracle闪回功能</span> 。
                  </li>
                  <li class="ulchildlink"><a href="managing-tables.html#GUID-14433799-D469-4A56-AAE4-089D3C3E1A5C">使用Oracle闪回表恢复表</a><br>通过Oracle闪回表，您可以将表还原到以前某个时间点的状态。
                  </li>
                  <li class="ulchildlink"><a href="managing-tables.html#GUID-C35B192C-1C8B-425F-A003-D36D0EABEB3A">删除表</a><br>要删除不再需要的表，请使用<code class="codeph">DROP TABLE</code>语句。
                  </li>
                  <li class="ulchildlink"><a href="managing-tables.html#GUID-16E1CE4C-0189-4CF5-8047-F5039587D130">使用闪回删除和管理回收站</a><br>删除表时，数据库不会立即删除与表关联的空间。数据库重命名表并将其和任何关联的对象放在回收站中，如果表被错误地删除，则可以在以后恢复。此功能称为闪回删除， <code class="codeph">FLASHBACK</code> <code class="codeph">TABLE</code>语句用于恢复表。
                  </li>
                  <li class="ulchildlink"><a href="managing-tables.html#GUID-D9BCA9BF-EAA8-431D-BDBB-ED5B3C59C5E4">管理索引组织表</a><br>索引组织表的存储组织是主B树索引的变体。与堆组织表不同，数据以主键顺序存储。
                  </li>
                  <li class="ulchildlink"><a href="managing-tables.html#GUID-4C17C266-A5F8-4C3C-B90F-5A02BE41F264">管理分区表</a><br>分区表使您的数据可以分解为更小，更易于管理的部分，称为分区，甚至是子分区。每个分区可以具有单独的物理属性，例如启用或禁用压缩，压缩类型，物理存储设置和表空间，从而提供可以更好地调整可用性和性能的结构。此外，每个分区都可以单独管理，这可以简化并减少备份和管理所需的时间。
                  </li>
                  <li class="ulchildlink"><a href="managing-tables.html#GUID-F6948F0E-0557-4C42-9145-1897DE974CC3">管理外部表</a><br>外部表是不驻留在数据库中的表，但位于数据库外部的外部文件中，例如操作系统文件或Hadoop分布式文件系统（HDFS）文件。
                  </li>
                  <li class="ulchildlink"><a href="managing-tables.html#GUID-FB55B947-2599-4D0E-8971-E05F49F6AF28">管理混合分区表</a><br>混合分区表是一个分区表，其中一些分区驻留在数据库中，一些分区驻留在数据库外部的外部文件中，例如操作系统文件或Hadoop分布式文件系统（HDFS）文件。
                  </li>
                  <li class="ulchildlink"><a href="managing-tables.html#GUID-9E47D91A-E1F2-42F7-8704-1571B34C0410">表数据字典视图</a><br>您可以查询一组数据字典视图以获取有关表的信息。
                  </li>
               </ul>
               <div class="familylinks">
                  <div class="parentlink">
                     <p><strong>父主题：</strong> <a href="schema-objects.html#GUID-2DA8C61C-58B0-4892-8E5D-E7A9120BC120" title="您可以在Oracle数据库中创建和管理架构对象。">模式对象</a></p>
                  </div>
               </div>
            </div>
            <a id="ADMIN11003"></a><div class="props_rev_3"><a id="GUID-2634BF31-512E-4276-99D4-848A535D273B" name="GUID-2634BF31-512E-4276-99D4-848A535D273B"></a><h3 id="ADMIN-GUID-2634BF31-512E-4276-99D4-848A535D273B" class="sect3"><span class="enumeration_section">20.1</span>关于表格</h3>
               <div>
                  <p>表是Oracle数据库中数据存储的基本单元。数据存储在行和列中。</p>
                  <p>您可以使用表名定义表，例如<code class="codeph">employees</code>和一组列。您为每列提供一个列名，例如<code class="codeph">employee_id</code> ， <code class="codeph">last_name</code>和<code class="codeph">job_id</code> ;数据类型，例如<code class="codeph">VARCHAR2</code> ， <code class="codeph">DATE</code>或<code class="codeph">NUMBER</code> ;和宽度。宽度可以由数据类型预先确定，如<code class="codeph">DATE</code> 。如果列具有<code class="codeph">NUMBER</code>数据类型，请定义精度和比例而不是宽度。行是对应于单个记录的列信息的集合。
                  </p>
                  <p>您可以为表的每列指定规则。这些规则称为完整性约束。一个例子是<code class="codeph">NOT NULL</code>完整性约束。此约束强制列在每行中包含值。
                  </p>
                  <p>您可以在存储之前调用透明数据加密来加密数据。如果用户通过直接使用操作系统工具查看Oracle数据文件来尝试绕过数据库访问控制机制，则加密会阻止这些用户查看敏感数据。</p>
                  <p>表还可以包括虚拟列。<span class="bold">虚拟列</span>与任何其他表列类似，只是它的值是通过计算表达式派生的。表达式可以包括来自同一个表的列，常量，SQL函数和用户定义的PL / SQL函数。您无法显式写入虚拟列。
                  </p>
                  <p>某些列类型（如<code class="codeph">LOB</code> ，varrays和嵌套表）存储在它们自己的段中。<code class="codeph">LOB</code>和varrays存储在<code class="codeph">LOB</code>段中，而嵌套表存储在存储表中。您可以为这些段指定一个<code class="codeph">STORAGE</code>子句，该子句将覆盖在表级别指定的存储参数。
                  </p>
                  <p>创建表后，可以使用SQL语句或使用Oracle批量装入实用程序插入数据行。然后可以使用SQL查询，删除或更新表数据。</p>
               </div>
               <div>
                  <div class="infoboxnotealso" id="GUID-2634BF31-512E-4276-99D4-848A535D273B__GUID-3E6F2600-79D2-4D91-932C-4C11B0D42BE6">
                     <p class="notep1">也可以看看：</p>
                     <p></p>
                     <ul style="list-style-type:disc">
                        <li>
                           <p><a href="../cncpt/tables-and-table-clusters.html#CNCPT211" target="_blank"><span class="italic">Oracle数据库概念，</span></a>用于表的概述</p>
                        </li>
                        <li>
                           <p><a href="../sqlrf/Data-Types.html#SQLRF0021" target="_blank"><span class="italic">Oracle数据库SQL语言参考，</span></a>用于描述Oracle数据库数据类型</p>
                        </li>
                        <li>
                           <p><a href="managing-space-for-schema-objects.html#GUID-1950156D-DECC-4E76-84D9-2C2A3D8D6565" title="管理模式对象的空间涉及诸如管理表空间警报和空间分配，回收未使用的空间，删除未使用的对象存储，监视空间使用和容量规划等任务。">管理模式对象的空间，</a>以获取管理表空间的指南</p>
                        </li>
                        <li>
                           <p><a href="managing-schema-objects.html#GUID-5BEEEA18-8606-48CA-B51A-34FD301BF93B" title="您可以使用Oracle数据库创建和管理多种类型的模式对象。">管理模式对象</a>以获取有关管理表的其他方面的信息，例如指定完整性约束和分析表</p>
                        </li>
                        <li>
                           <p><a href="../asoag/asopart1.html#ASOAG600" target="_blank"><span class="italic">“Oracle数据库高级安全指南”，</span></a>用于讨论透明数据加密</p>
                        </li>
                     </ul>
                  </div>
                  <div class="familylinks">
                     <div class="parentlink">
                        <p><strong>父主题：</strong> <a href="managing-tables.html#GUID-707B02F5-E589-4C20-8E2E-5ED4F7888702" title="管理表包括创建表，加载表，更改表和删除表等任务。">管理表</a></p>
                     </div>
                  </div>
               </div>
               
            </div><a id="ADMIN01502"></a><div class="props_rev_3"><a id="GUID-86F766C5-2344-4790-95E4-4E813A0B21DA" name="GUID-86F766C5-2344-4790-95E4-4E813A0B21DA"></a><h3 id="ADMIN-GUID-86F766C5-2344-4790-95E4-4E813A0B21DA" class="sect3"><span class="enumeration_section">20.2</span>管理表指南</h3>
               <p>遵循指南可以使表的管理更容易，并且可以在创建表时以及加载，更新和查询表数据时提高性能。</p>
               <div>
                  <ul class="ullinks">
                     <li class="ulchildlink"><a href="managing-tables.html#GUID-809CEB2A-16F1-435C-B69E-EAF0DB778781">在创建它们之前设计表</a><br>通常，应用程序开发人员负责设计应用程序的元素，包括表格。数据库管理员负责建立将保存应用程序表的基础表空间的属性。
                     </li>
                     <li class="ulchildlink"><a href="managing-tables.html#GUID-43128EAC-5B7C-4A5C-AA9B-6C69EEFC7F3F">指定要创建的表的类型</a><br>您可以使用Oracle数据库创建不同类型的表。
                     </li>
                     <li class="ulchildlink"><a href="managing-tables.html#GUID-716489CE-CBDE-414A-BEDA-3E1DEC83BE97">指定每个表的位置</a><br>建议在<code class="codeph">CREATE TABLE</code>语句中指定<code class="codeph">TABLESPACE</code>子句以标识要存储新表的表空间。对于分区表，您可以选择标识要存储每个分区的表空间。
                     </li>
                     <li class="ulchildlink"><a href="managing-tables.html#GUID-D5E6D2FB-C708-4CF4-BCD7-F38C10A73A1F">考虑并行化表创建</a><br>在<code class="codeph">CREATE TABLE</code>语句中使用子查询（ <code class="codeph">AS SELECT</code> ）创建表时，可以使用并行执行。由于多个进程协同工作以创建表，因此提高了表创建操作的性能。
                     </li>
                     <li class="ulchildlink"><a href="managing-tables.html#GUID-E9EB5D85-49D8-4A29-9DF3-A7CBBA484EE3">在创建表时考虑使用NOLOGGING</a><br>要最有效地创建表，请使用<code class="codeph">CREATE TABLE...的<code class="codeph">NOLOGGING</code>子句<code class="codeph">CREATE TABLE...AS SELECT</code>语句。<code class="codeph">NOLOGGING</code>子句导致在表创建期间生成最少的重做信息。
                     </li>
                     <li class="ulchildlink"><a href="managing-tables.html#GUID-34D15DD1-0925-4C9A-BE8A-3EE91671E526">考虑使用表压缩</a><br>随着数据库大小的增长，请考虑使用表压缩来节省空间并提高性能。
                     </li>
                     <li class="ulchildlink"><a href="managing-tables.html#GUID-C431C787-F714-4A3B-A745-90F6BCD92A1B">使用Enterprise Manager云控制管理表压缩</a><br>您可以使用Oracle Enterprise Manager Cloud Control管理表压缩。
                     </li>
                     <li class="ulchildlink"><a href="managing-tables.html#GUID-C7B346C7-40F4-41D2-8DF1-81565096E03B">考虑使用段级和行级压缩分层</a><br>通过段级压缩分层，您可以在表中的段级别指定压缩。行级压缩分层使您可以在表中的行级别指定压缩。您可以在同一个表中使用这些组合，以便对表中数据的存储和管理方式进行细粒度控制。
                     </li>
                     <li class="ulchildlink"><a href="managing-tables.html#GUID-0A837830-9FF7-40FF-8540-93B2DF3A37E7">考虑使用属性聚簇表</a><br>属性聚簇表是一个堆组织表，它根据用户指定的聚簇指令将数据存储在磁盘上。
                     </li>
                     <li class="ulchildlink"><a href="managing-tables.html#GUID-05AF604F-B923-4256-BA47-B7E0E29386EE">考虑使用区域地图</a><br>区域是磁盘上的一组连续数据块。区域图跟踪所有单个区域的指定列的最小值和最大值。
                     </li>
                     <li class="ulchildlink"><a href="managing-tables.html#GUID-8487BAFD-B157-4CBA-8330-2A3088C0A173">考虑在内存中的列存储中存储表</a><br>内存中列存储是系统全局区域（SGA）的可选部分，用于存储针对快速扫描进行了优化的表，表分区和其他数据库对象的副本。在内存中列存储中，表数据按列而不是SGA中的行存储。</li>
                     <li class="ulchildlink"><a href="managing-tables.html#GUID-38DBFC2E-FC6C-46E2-A7A1-6FA703F9DC01">考虑使用不可见列</a><br>您可以使用不可见列来更改表，而不会中断使用该表的应用程序。
                     </li>
                     <li class="ulchildlink"><a href="managing-tables.html#GUID-F9D38568-4F95-4053-B21F-F318077C29E5">考虑加密包含敏感数据的列</a><br>您可以加密包含敏感数据的各个表列。敏感数据的示例包括社会安全号码，信用卡号码和医疗记录。列加密对您的应用程序是透明的，但有一些限制。
                     </li>
                     <li class="ulchildlink"><a href="managing-tables.html#GUID-2823F411-EC06-49D0-998E-C76CB139794E">了解延迟细分创建</a><br>在本地管理的表空间中创建堆组织表时，数据库会延迟创建表段，直到插入第一行。
                     </li>
                     <li class="ulchildlink"><a href="managing-tables.html#GUID-BFDCA073-3AEC-4399-A95A-C4888120B958">实现细分</a><br><code class="codeph">DBMS_SPACE_ADMIN</code>程序包包含<code class="codeph">MATERIALIZE_DEFERRED_SEGMENTS()</code>过程，该过程使您能够实现为启用了延迟段创建而创建的表，表分区和从属对象的段。
                     </li>
                     <li class="ulchildlink"><a href="managing-tables.html#GUID-A9EDF4CF-FFBA-4D09-A4BB-621BE977E4FC">估计表格大小并相应地计划</a><br>在创建表之前估计表的大小。最好将此作为数据库规划的一部分。了解数据库表的大小和用途是数据库规划的重要部分。
                     </li>
                     <li class="ulchildlink"><a href="managing-tables.html#GUID-66B37910-379C-4FB1-81B1-D2671FDCDE46">创建表时要考虑的限制</a><br>创建表时需要考虑一些限制。
                     </li>
                  </ul>
                  <div class="familylinks">
                     <div class="parentlink">
                        <p><strong>父主题：</strong> <a href="managing-tables.html#GUID-707B02F5-E589-4C20-8E2E-5ED4F7888702" title="管理表包括创建表，加载表，更改表和删除表等任务。">管理表</a></p>
                     </div>
                  </div>
               </div>
               <a id="ADMIN11625"></a><div class="props_rev_3"><a id="GUID-809CEB2A-16F1-435C-B69E-EAF0DB778781" name="GUID-809CEB2A-16F1-435C-B69E-EAF0DB778781"></a><h4 id="ADMIN-GUID-809CEB2A-16F1-435C-B69E-EAF0DB778781" class="sect4"><span class="enumeration_section">20.2.1</span>创建设计表之前的设计表</h4>
                  <div>
                     <p>通常，应用程序开发人员负责设计应用程序的元素，包括表格。数据库管理员负责建立将保存应用程序表的基础表空间的属性。</p>
                     <p>DBA或应用程序开发人员，或两者共同工作，可以负责实际创建表，具体取决于站点的实践。与应用程序开发人员合作，在设计表时请考虑以下准则：</p>
                     <ul style="list-style-type:disc">
                        <li>
                           <p>对表，列，索引和集群使用描述性名称。</p>
                        </li>
                        <li>
                           <p>在缩写和使用单数和复数形式的表名和列时保持一致。</p>
                        </li>
                        <li>
                           <p>使用<code class="codeph">COMMENT</code>命令记录每个表及其列的含义。
                           </p>
                        </li>
                        <li>
                           <p>规范化每个表格。</p>
                        </li>
                        <li>
                           <p>为每列选择适当的数据类型。</p>
                        </li>
                        <li>
                           <p>考虑您的应用程序是否会从向某些表添加一个或多个虚拟列中获益。</p>
                        </li>
                        <li>
                           <p>定义最后允许空值的列，以节省存储空间。</p>
                        </li>
                        <li>
                           <p>适当时使用群集表，以节省存储空间并优化SQL语句的性能。</p>
                        </li>
                     </ul>
                     <p>在创建表之前，还应确定是否使用完整性约束。可以在表的列上定义完整性约束，以自动强制执行数据库的业务规则。</p>
                  </div>
                  <div>
                     <div class="familylinks">
                        <div class="parentlink">
                           <p><strong>父主题：</strong> <a href="managing-tables.html#GUID-86F766C5-2344-4790-95E4-4E813A0B21DA" title="遵循指南可以使表的管理更容易，并且可以在创建表时以及加载，更新和查询表数据时提高性能。">管理表的准则</a></p>
                        </div>
                     </div>
                  </div>
                  
               </div><a id="ADMIN11626"></a><div class="props_rev_3"><a id="GUID-43128EAC-5B7C-4A5C-AA9B-6C69EEFC7F3F" name="GUID-43128EAC-5B7C-4A5C-AA9B-6C69EEFC7F3F"></a><h4 id="ADMIN-GUID-43128EAC-5B7C-4A5C-AA9B-6C69EEFC7F3F" class="sect4"><span class="enumeration_section">20.2.2</span>指定要创建的表类型</h4>
                  <div>
                     <p>您可以使用Oracle数据库创建不同类型的表。</p>
                     <p>以下是您可以创建的表类型：</p>
                     <div class="tblformal" id="GUID-43128EAC-5B7C-4A5C-AA9B-6C69EEFC7F3F__GUID-651DE281-85A3-4665-8EA6-2C282C2F8DFB">
                        <table cellpadding="4" cellspacing="0" class="Formal" title="" width="100%" border="1" summary="Column 1 lists some of the various types of tables, column 2 describes each type of table." frame="hsides" rules="rows">
                           <thead>
                              <tr align="left" valign="top">
                                 <th align="left" valign="bottom" width="30%" id="d192334e679">表格类型</th>
                                 <th align="left" valign="bottom" width="70%" id="d192334e682">描述</th>
                              </tr>
                           </thead>
                           <tbody>
                              <tr align="left" valign="top">
                                 <td align="left" valign="top" width="30%" id="d192334e687" headers="d192334e679 ">
                                    <p>普通（堆组织）表</p>
                                 </td>
                                 <td align="left" valign="top" width="70%" headers="d192334e687 d192334e682 ">
                                    <p>这是表的基本通用类型，是本章的主要主题。它的数据存储为无序集合（堆）。</p>
                                 </td>
                              </tr>
                              <tr align="left" valign="top">
                                 <td align="left" valign="top" width="30%" id="d192334e694" headers="d192334e679 ">
                                    <p>集群表</p>
                                 </td>
                                 <td align="left" valign="top" width="70%" headers="d192334e694 d192334e682 ">
                                    <p>群集表是一个群集的表。集群是一组共享相同数据块的表，因为它们共享公共列并且通常一起使用。</p>
                                    <p><a href="managing-clusters.html#GUID-2EB6D65C-3DD8-4C92-A8B4-C05197B6CF2D" title="使用群集可以提高性能并减少磁盘空间需求。">管理群</a>集中讨论了群集和群集表。
                                    </p>
                                 </td>
                              </tr>
                              <tr align="left" valign="top">
                                 <td align="left" valign="top" width="30%" id="d192334e710" headers="d192334e679 ">
                                    <p>索引组织表</p>
                                 </td>
                                 <td align="left" valign="top" width="70%" headers="d192334e710 d192334e682 ">
                                    <p>与普通（堆组织的）表不同，索引组织表的数据以主键排序方式存储在B树索引结构中。除了存储索引组织表行的主键列值之外，B树中的每个索引条目也存储非键列值。</p>
                                    <p>索引组织表在<span class="q">“ <a href="managing-tables.html#GUID-D9BCA9BF-EAA8-431D-BDBB-ED5B3C59C5E4" title="索引组织表的存储组织是主B树索引的变体。与堆组织表不同，数据以主键顺序存储。">管理索引组织表</a> ”</span>中讨论。
                                    </p>
                                 </td>
                              </tr>
                              <tr align="left" valign="top">
                                 <td align="left" valign="top" width="30%" id="d192334e727" headers="d192334e679 ">
                                    <p>分区表</p>
                                 </td>
                                 <td align="left" valign="top" width="70%" headers="d192334e727 d192334e682 ">
                                    <p>分区表使您的数据可以分解为更小，更易于管理的部分，称为分区，甚至是子分区。每个分区可以具有单独的物理属性，例如启用或禁用压缩，压缩类型，物理存储设置和表空间，从而提供可以更好地调整可用性和性能的结构。此外，每个分区都可以单独管理，这可以简化并减少备份和管理所需的时间。</p>
                                    <p><a href="../vldbg/partition-concepts.html#VLDBG-GUID-EA7EF5CB-DD49-43AF-889A-F83AAC0D7D51" target="_blank"><span class="italic">Oracle Database VLDB和Partitioning Guide</span></a>中讨论了分区表。
                                    </p>
                                 </td>
                              </tr>
                              <tr align="left" valign="top">
                                 <td align="left" valign="top" width="30%" id="d192334e741" headers="d192334e679 ">
                                    <p>外部表</p>
                                 </td>
                                 <td align="left" valign="top" width="70%" headers="d192334e741 d192334e682 ">
                                    <p>外部表是不驻留在数据库中的表，但驻留在数据库外部的外部文件中，例如操作系统文件或Hadoop分布式文件系统（HDFS）文件。</p>
                                    <p>管理外部表中讨论了<a href="managing-tables.html#GUID-F6948F0E-0557-4C42-9145-1897DE974CC3" title="外部表是不驻留在数据库中的表，但位于数据库外部的外部文件中，例如操作系统文件或Hadoop分布式文件系统（HDFS）文件。">外部表</a> 。
                                    </p>
                                 </td>
                              </tr>
                              <tr align="left" valign="top">
                                 <td align="left" valign="top" width="30%" id="d192334e757" headers="d192334e679 ">
                                    <p>混合分区表</p>
                                 </td>
                                 <td align="left" valign="top" width="70%" headers="d192334e757 d192334e682 ">
                                    <p>混合分区表是一个分区表，其中一些分区驻留在数据库中，一些分区驻留在数据库外部的外部文件中，例如操作系统文件或Hadoop分布式文件系统（HDFS）文件。</p>
                                    <p><a href="../vldbg/partition-concepts.html#VLDBG-GUID-C2B04585-BCFC-40D6-AFAB-47DF99A31C76" target="_blank"><span class="italic">Oracle Database VLDB和Partitioning Guide</span></a>中讨论了混合分区表。
                                    </p>
                                 </td>
                              </tr>
                           </tbody>
                        </table>
                     </div>
                     <!-- class="inftblhruleinformal" -->
                  </div>
                  <div>
                     <div class="familylinks">
                        <div class="parentlink">
                           <p><strong>父主题：</strong> <a href="managing-tables.html#GUID-86F766C5-2344-4790-95E4-4E813A0B21DA" title="遵循指南可以使表的管理更容易，并且可以在创建表时以及加载，更新和查询表数据时提高性能。">管理表的准则</a></p>
                        </div>
                     </div>
                  </div>
                  
               </div><a id="ADMIN11627"></a><div class="props_rev_3"><a id="GUID-716489CE-CBDE-414A-BEDA-3E1DEC83BE97" name="GUID-716489CE-CBDE-414A-BEDA-3E1DEC83BE97"></a><h4 id="ADMIN-GUID-716489CE-CBDE-414A-BEDA-3E1DEC83BE97" class="sect4"><span class="enumeration_section">20.2.3</span>指定每个表的位置</h4>
                  <div>
                     <p>建议在<code class="codeph">CREATE TABLE</code>语句中指定<code class="codeph">TABLESPACE</code>子句以标识要存储新表的表空间。对于分区表，您可以选择标识要存储每个分区的表空间。
                     </p>
                     <p>确保您在所使用的任何表空间上具有适当的权限和配额。如果未在<code class="codeph">CREATE TABLE</code>语句中指定表空间，则会在默认表空间中创建该表。
                     </p>
                     <p>指定表空间以包含新表时，请确保您了解所选内容的含义。通过在创建每个表期间正确指定表空间，可以提高数据库系统的性能并减少数据库管理所需的时间。</p>
                     <p>以下情况说明了如何不指定表空间或指定不合适的表空间会影响性能：</p>
                     <ul style="list-style-type:disc">
                        <li>
                           <p>如果在<code class="codeph">SYSTEM</code>表空间中创建用户对象，则数据库的性能会受到影响，因为数据字典对象和用户对象都必须争用相同的数据文件。用户的对象不应存储在<code class="codeph">SYSTEM</code>表空间中。要避免这种情况，请确保在数据库中创建所有用户时为其分配默认表空间。
                           </p>
                        </li>
                        <li>
                           <p>如果应用程序关联表被任意存储在各种表空间中，则可以增加完成该应用程序数据的管理操作（例如备份和恢复）所需的时间。</p>
                        </li>
                     </ul>
                  </div>
                  <div>
                     <div class="familylinks">
                        <div class="parentlink">
                           <p><strong>父主题：</strong> <a href="managing-tables.html#GUID-86F766C5-2344-4790-95E4-4E813A0B21DA" title="遵循指南可以使表的管理更容易，并且可以在创建表时以及加载，更新和查询表数据时提高性能。">管理表的准则</a></p>
                        </div>
                     </div>
                  </div>
                  
               </div><a id="ADMIN11628"></a><div class="props_rev_3"><a id="GUID-D5E6D2FB-C708-4CF4-BCD7-F38C10A73A1F" name="GUID-D5E6D2FB-C708-4CF4-BCD7-F38C10A73A1F"></a><h4 id="ADMIN-GUID-D5E6D2FB-C708-4CF4-BCD7-F38C10A73A1F" class="sect4"><span class="enumeration_section">20.2.4</span>考虑并行化表创建</h4>
                  <div>
                     <p>在<code class="codeph">CREATE TABLE</code>语句中使用子查询（ <code class="codeph">AS SELECT</code> ）创建表时，可以使用并行执行。由于多个进程协同工作以创建表，因此提高了表创建操作的性能。
                     </p>
                     <p>并行化表创建将在<span class="q">“ <a href="managing-tables.html#GUID-2C1E31D1-C0EE-48D6-8C11-31AE9AFF5440" title="指定AS SELECT子句以创建表并使用其他表中的数据填充表时，可以使用并行执行。">并行化表创建</a> ”</span>一节中讨论。
                     </p>
                  </div>
                  <div>
                     <div class="familylinks">
                        <div class="parentlink">
                           <p><strong>父主题：</strong> <a href="managing-tables.html#GUID-86F766C5-2344-4790-95E4-4E813A0B21DA" title="遵循指南可以使表的管理更容易，并且可以在创建表时以及加载，更新和查询表数据时提高性能。">管理表的准则</a></p>
                        </div>
                     </div>
                  </div>
                  
               </div><a id="ADMIN11629"></a><div class="props_rev_3"><a id="GUID-E9EB5D85-49D8-4A29-9DF3-A7CBBA484EE3" name="GUID-E9EB5D85-49D8-4A29-9DF3-A7CBBA484EE3"></a><h4 id="ADMIN-GUID-E9EB5D85-49D8-4A29-9DF3-A7CBBA484EE3" class="sect4"><span class="enumeration_section">20.2.5</span>在创建表时考虑使用NOLOGGING</h4>
                  <div>
                     <p>要最有效地创建表，请使用<code class="codeph">CREATE TABLE...的<code class="codeph">NOLOGGING</code>子句<code class="codeph">CREATE TABLE...AS SELECT</code>语句。<code class="codeph">NOLOGGING</code>子句导致在表创建期间生成最少的重做信息。
                     </p>
                     <p>使用<code class="codeph">NOLOGGING</code>子句有以下好处：</p>
                     <ul style="list-style-type:disc">
                        <li>
                           <p>空间保存在重做日志文件中。</p>
                        </li>
                        <li>
                           <p>创建表所需的时间减少了。</p>
                        </li>
                        <li>
                           <p>并行创建大型表的性能得到改善。</p>
                        </li>
                     </ul>
                     <p><code class="codeph">NOLOGGING</code>子句还指定不记录使用SQL * Loader和直接加载<code class="codeph">INSERT</code>操作的后续直接加载。后续DML语句（ <code class="codeph">UPDATE</code> ， <code class="codeph">DELETE</code>和常规路径插入）不受表的<code class="codeph">NOLOGGING</code>属性的影响并生成重做。
                     </p>
                     <p>如果在创建表后不能丢失表（例如，您将无法再访问用于创建表的数据），则应在创建表后立即进行备份。在某些情况下，例如为临时使用而创建的表，可能不需要此预防措施。</p>
                     <p>通常，对于较大的表而言，指定<code class="codeph">NOLOGGING</code>的相对性能改进比较小的表更大。对于小型表， <code class="codeph">NOLOGGING</code>对创建表所需的时间几乎没有影响。但是，对于较大的表，性能改进可能很大，尤其是在并行化表创建时。
                     </p>
                  </div>
                  <div>
                     <div class="familylinks">
                        <div class="parentlink">
                           <p><strong>父主题：</strong> <a href="managing-tables.html#GUID-86F766C5-2344-4790-95E4-4E813A0B21DA" title="遵循指南可以使表的管理更容易，并且可以在创建表时以及加载，更新和查询表数据时提高性能。">管理表的准则</a></p>
                        </div>
                     </div>
                  </div>
                  
               </div>
               <div class="sect3"><a id="GUID-34D15DD1-0925-4C9A-BE8A-3EE91671E526" name="GUID-34D15DD1-0925-4C9A-BE8A-3EE91671E526"></a><h4 id="ADMIN-GUID-34D15DD1-0925-4C9A-BE8A-3EE91671E526" class="sect4"><span class="enumeration_section">20.2.6</span>考虑使用表压缩</h4>
                  <p>随着数据库大小的增长，请考虑使用表压缩来节省空间并提高性能。</p>
                  <div>
                     <ul class="ullinks">
                        <li class="ulchildlink"><a href="managing-tables.html#GUID-ED833867-4B7F-442E-A70C-9C19DAA8F445">关于表压缩</a><br>压缩可节省磁盘空间，减少数据库缓冲区高速缓存中的内存使用，并可显着提高读取期间的查询执行速度。
                        </li>
                        <li class="ulchildlink"><a href="managing-tables.html#GUID-3FDE903A-6CA8-40B5-8B0B-FC9F5BB9C667">与表压缩相关的示例</a><br>示例说明了使用表压缩。
                        </li>
                        <li class="ulchildlink"><a href="managing-tables.html#GUID-F10EF5C9-AA5C-4F74-87DD-603955A64CB2">压缩和分区表</a><br>表可以包含压缩和未压缩的分区，不同的分区可以使用不同的压缩方法。如果表及其某个分区的压缩设置不匹配，则分区设置优先于分区。
                        </li>
                        <li class="ulchildlink"><a href="managing-tables.html#GUID-E56CD5F0-2788-4B05-A72D-CAD9A986B127">确定表是否压缩</a><br>在<code class="codeph">*_TABLES</code>数据字典视图中，压缩表在<code class="codeph">COMPRESSION</code>列中具有<code class="codeph">ENABLED</code> 。
                        </li>
                        <li class="ulchildlink"><a href="managing-tables.html#GUID-FA9385A5-C77E-4E8F-809F-7704BAD9EE2D">确定哪些行是压缩的</a><br>要确定行的压缩级别，请使用<code class="codeph">DBMS_COMPRESSION</code>包中的<code class="codeph">GET_COMPRESSION_TYPE</code>函数。
                        </li>
                        <li class="ulchildlink"><a href="managing-tables.html#GUID-364F249F-ED4D-4CF3-B4FE-9724D5978D5E">更改压缩级别</a><br>您可以更改分区，表或表空间的压缩级别。
                        </li>
                        <li class="ulchildlink"><a href="managing-tables.html#GUID-321C8937-3F4A-4641-9B77-CB06BDE9382C">在压缩表中添加和删除列</a><br>将列添加到压缩表或从压缩表中删除列时，会有一些限制。
                        </li>
                        <li class="ulchildlink"><a href="managing-tables.html#GUID-BD0E0587-1BF3-4EB1-9E0E-4F24F0B54A0B">导出和导入混合列压缩表</a><br>可以使用Data Pump Import实用程序的<code class="codeph">impdp</code>命令导入混合列压缩表。
                        </li>
                        <li class="ulchildlink"><a href="managing-tables.html#GUID-4826DC4F-F4E5-4500-AF00-EAA8F46E9AD5">恢复混合列压缩表</a><br>有时可能必须从备份还原混合列压缩表。该表可以还原到支持混合列压缩的系统，也可以还原到不支持混合列压缩的系统。
                        </li>
                        <li class="ulchildlink"><a href="managing-tables.html#GUID-13D5D4C8-AA82-4AF6-A730-D36CA6DDEA31">压缩表的注释和限制</a><br>考虑与压缩表相关的注释和限制。
                        </li>
                        <li class="ulchildlink"><a href="managing-tables.html#GUID-11A2D127-327C-4530-A457-F041FC091C4A">包装压缩表</a><br>如果在使用基本表压缩或混合列压缩压缩的表上使用常规DML，则所有插入和更新的行都将以未压缩或压缩较少的格式存储。要“压缩”压缩表以便压缩这些行，请使用<code class="codeph">ALTER</code> <code class="codeph">TABLE</code> <code class="codeph">MOVE</code>语句。
                        </li>
                     </ul>
                     <div class="familylinks">
                        <div class="parentlink">
                           <p><strong>父主题：</strong> <a href="managing-tables.html#GUID-86F766C5-2344-4790-95E4-4E813A0B21DA" title="遵循指南可以使表的管理更容易，并且可以在创建表时以及加载，更新和查询表数据时提高性能。">管理表的准则</a></p>
                        </div>
                     </div>
                  </div>
                  <a id="ADMIN13949"></a><a id="ADMIN13950"></a><a id="ADMIN13948"></a><div class="props_rev_3"><a id="GUID-ED833867-4B7F-442E-A70C-9C19DAA8F445" name="GUID-ED833867-4B7F-442E-A70C-9C19DAA8F445"></a><h5 id="ADMIN-GUID-ED833867-4B7F-442E-A70C-9C19DAA8F445" class="sect5"><span class="enumeration_section">20.2.6.1</span>关于表压缩</h5>
                     <div>
                        <p>压缩可节省磁盘空间，减少数据库缓冲区高速缓存中的内存使用，并可显着提高读取期间的查询执行速度。</p>
                        <p>压缩具有数据加载和DML的CPU开销成本。但是，这个成本可以通过降低I / O要求来抵消。由于压缩表数据在内存中保持压缩，因此压缩也可以提高DML操作的性能，因为更多行可以适合数据库缓冲区缓存（如果启用了闪存缓存）。</p>
                        <p>表压缩对应用程序完全透明。它在决策支持系统（DSS），在线事务处理（OLTP）系统和归档系统中很有用。</p>
                        <p>您可以为表空间，表或分区指定压缩。如果在表空间级别指定，则默认情况下会压缩在该表空间中创建的所有表。</p>
                        <p>Oracle数据库支持多种表压缩方法。它们总结在<a href="managing-tables.html#GUID-ED833867-4B7F-442E-A70C-9C19DAA8F445__BABEEFHI" title="此表描述了表压缩的类型。它具有以下列：表压缩方法，压缩级别，CPU开销，应用程序和注释">表20-1中</a> 。
                        </p>
                        <div class="tblformal" id="GUID-ED833867-4B7F-442E-A70C-9C19DAA8F445__BABEEFHI">
                           <p class="titleintable">表20-1表压缩方法</p>
                           <table cellpadding="4" cellspacing="0" class="Formal" title="表压缩方法" width="100%" border="1" summary="This table describes the types of table compression. It has the following columns:  Table Compression Method, Compression Level, CPU Overhead,, Applications, and Notes" frame="hsides" rules="rows">
                              <thead>
                                 <tr align="left" valign="top">
                                    <th align="left" valign="bottom" id="d192334e1218">表压缩方法</th>
                                    <th align="left" valign="bottom" id="d192334e1221">压缩等级</th>
                                    <th align="left" valign="bottom" id="d192334e1224">CPU开销</th>
                                    <th align="left" valign="bottom" id="d192334e1227">应用</th>
                                    <th align="left" valign="bottom" id="d192334e1230">笔记</th>
                                 </tr>
                              </thead>
                              <tbody>
                                 <tr align="left" valign="top">
                                    <td align="left" valign="top" id="d192334e1235" headers="d192334e1218 ">
                                       <p>基本表压缩</p>
                                    </td>
                                    <td align="left" valign="top" headers="d192334e1235 d192334e1221 ">
                                       <p>高</p>
                                    </td>
                                    <td align="left" valign="top" headers="d192334e1235 d192334e1224 ">
                                       <p>最小</p>
                                    </td>
                                    <td align="left" valign="top" headers="d192334e1235 d192334e1227 ">
                                       <p>DSS</p>
                                    </td>
                                    <td align="left" valign="top" headers="d192334e1235 d192334e1230 ">
                                       <p>没有。</p>
                                    </td>
                                 </tr>
                                 <tr align="left" valign="top">
                                    <td align="left" valign="top" id="d192334e1251" headers="d192334e1218 ">
                                       <p>高级行压缩</p>
                                    </td>
                                    <td align="left" valign="top" headers="d192334e1251 d192334e1221 ">
                                       <p>高</p>
                                    </td>
                                    <td align="left" valign="top" headers="d192334e1251 d192334e1224 ">
                                       <p>最小</p>
                                    </td>
                                    <td align="left" valign="top" headers="d192334e1251 d192334e1227 ">
                                       <p>OLTP，DSS</p>
                                    </td>
                                    <td align="left" valign="top" headers="d192334e1251 d192334e1230 ">
                                       <p>没有。</p>
                                    </td>
                                 </tr>
                                 <tr align="left" valign="top">
                                    <td align="left" valign="top" id="d192334e1267" headers="d192334e1218 ">
                                       <p>仓库压缩（混合列压缩）</p>
                                    </td>
                                    <td align="left" valign="top" headers="d192334e1267 d192334e1221 ">
                                       <p>更高</p>
                                    </td>
                                    <td align="left" valign="top" headers="d192334e1267 d192334e1224 ">
                                       <p>更高</p>
                                    </td>
                                    <td align="left" valign="top" headers="d192334e1267 d192334e1227 ">
                                       <p>DSS</p>
                                    </td>
                                    <td align="left" valign="top" headers="d192334e1267 d192334e1230 ">
                                       <p>压缩级别和CPU开销取决于指定的压缩级别（LOW或HIGH）。</p>
                                    </td>
                                 </tr>
                                 <tr align="left" valign="top">
                                    <td align="left" valign="top" id="d192334e1283" headers="d192334e1218 ">
                                       <p>归档压缩（混合列压缩）</p>
                                    </td>
                                    <td align="left" valign="top" headers="d192334e1283 d192334e1221 ">
                                       <p>最高</p>
                                    </td>
                                    <td align="left" valign="top" headers="d192334e1283 d192334e1224 ">
                                       <p>最高</p>
                                    </td>
                                    <td align="left" valign="top" headers="d192334e1283 d192334e1227 ">
                                       <p>存档</p>
                                    </td>
                                    <td align="left" valign="top" headers="d192334e1283 d192334e1230 ">
                                       <p>压缩级别和CPU开销取决于指定的压缩级别（LOW或HIGH）。</p>
                                    </td>
                                 </tr>
                              </tbody>
                           </table>
                        </div>
                        <!-- class="inftblhruleinformal" -->
                        <p>使用基本表压缩，仓库压缩或归档压缩时，只有在批量加载数据或将数组插入表中时才会发生压缩。</p>
                        <p>基本表压缩支持有限的数据类型和SQL操作。</p>
                        <p>高级行压缩适用于OLTP应用程序，并压缩由任何SQL操作操作的数据。使用高级行压缩时，在将数据插入，更新或批量加载到表中时会发生压缩。允许高级行压缩的操作包括：</p>
                        <ul style="list-style-type:disc">
                           <li>
                              <p>单行插入和更新</p>
                              <p>插入和更新不会立即压缩。更新已压缩的块时，任何未更新的列通常都会保持压缩状态。更新的列以未压缩的格式存储，类似于任何未压缩的块。当块达到数据库控制的阈值时，将重新压缩更新的值。当块中的数据达到数据库控制的阈值时，也会压缩插入的数据。</p>
                           </li>
                           <li>
                              <p>数组插入</p>
                              <p>数组插入包括没有<code class="codeph">APPEND</code>提示的<code class="codeph">INSERT INTO SELECT</code> SQL语句，以及来自PL / SQL和Oracle调用接口（OCI）等编程接口的数组插入。
                              </p>
                           </li>
                           <li>
                              <p>以下直接路径<code class="codeph">INSERT</code>方法：</p>
                              <ul style="list-style-type:disc">
                                 <li>
                                    <p>直接路径SQL * Loader</p>
                                 </li>
                                 <li>
                                    <p><code class="codeph">CREATE</code> <code class="codeph">TABLE</code> <code class="codeph">AS</code> <code class="codeph">SELECT</code>语句</p>
                                 </li>
                                 <li>
                                    <p>并行<code class="codeph">INSERT</code>语句</p>
                                 </li>
                                 <li>
                                    <p>带有<code class="codeph">APPEND</code>或<code class="codeph">APPEND_VALUES</code>提示的<code class="codeph">INSERT</code>语句</p>
                                 </li>
                              </ul>
                              <p>使用这些直接路径<code class="codeph">INSERT</code>方法执行的<code class="codeph">INSERT</code>会立即被压缩。
                              </p>
                           </li>
                        </ul>
                        <p>仓库压缩和归档压缩实现了最高的压缩级别，因为它们使用混合列压缩技术。混合列压缩技术使用修改形式的柱状存储而不是行主存储。这使数据库能够将类似的数据存储在一起，从而提高了压缩算法的有效性。对于更新的数据，混合列压缩使用更多CPU并将更新的行移动到行格式，以便将来更新更快。由于此优化，您应该仅将其用于不经常更新的数据。</p>
                        <p>混合列压缩的较高压缩级别仅通过插入直接路径或插入阵列的数据来实现。支持常规插入和更新，但会导致行从列格式移动到行格式，并降低压缩级别。您可以使用自动数据优化（ADO）策略将这些行自动移回所需的混合列压缩级别。</p>
                        <p>使用混合列压缩（仓库和归档），要立即压缩阵列插入，必须满足以下条件：</p>
                        <ul style="list-style-type:disc">
                           <li>
                              <p>该表必须存储在本地管理的表空间中，并启用自动段空间管理（ASSM）。</p>
                           </li>
                           <li>
                              <p>数据库兼容级别必须为12.2.0或更高。</p>
                           </li>
                        </ul>
                        <p>不管压缩方法， <code class="codeph">DELETE</code>压缩块上的操作是相同的<code class="codeph">DELETE</code>非压缩块上操作。由SQL <code class="codeph">DELETE</code>操作引起的在数据块上获得的任何空间都由后续SQL <code class="codeph">INSERT</code>操作重用。使用混合列压缩技术，当删除压缩单元中的所有行时，压缩单元中的空间可供重用。
                        </p>
                        <p><a href="managing-tables.html#GUID-ED833867-4B7F-442E-A70C-9C19DAA8F445__BABGGEAA" title="此表列出了三种表压缩的特征。列包括：表压缩方法，CREATE / ALTER TABLE语法，直接路径插入，DML和Notes">表20-2</a>列出了每种表压缩方法的特征。
                        </p>
                        <div class="tblformalwide" id="GUID-ED833867-4B7F-442E-A70C-9C19DAA8F445__BABGGEAA">
                           <p class="titleintable">表20-2表压缩特性</p>
                           <table cellpadding="4" cellspacing="0" class="FormalWide" title="表压缩特性" width="100%" border="1" summary="This table lists characteristics of the three types of table compression. Columns are: Table Compression Method, CREATE/ALTER TABLE syntax,  Direct Path Insert, DML, and Notes" frame="hsides" rules="rows">
                              <thead>
                                 <tr align="left" valign="top">
                                    <th align="left" valign="bottom" width="27%" id="d192334e1413">表压缩方法</th>
                                    <th align="left" valign="bottom" width="21%" id="d192334e1416">CREATE / ALTER TABLE语法</th>
                                    <th align="left" valign="bottom" width="18%" id="d192334e1419">直接路径或数组插入</th>
                                    <th align="left" valign="bottom" width="34%" id="d192334e1422">笔记</th>
                                 </tr>
                              </thead>
                              <tbody>
                                 <tr align="left" valign="top">
                                    <td align="left" valign="top" width="27%" id="d192334e1427" headers="d192334e1413 ">
                                       <p>基本表压缩</p>
                                    </td>
                                    <td align="left" valign="top" width="21%" headers="d192334e1427 d192334e1416 ">
                                       <p><code class="codeph">行商店压缩[基本]</code></p>
                                    </td>
                                    <td align="left" valign="top" width="18%" headers="d192334e1427 d192334e1419 ">
                                       <p>行使用基本表压缩进行压缩。</p>
                                    </td>
                                    <td align="left" valign="top" width="34%" headers="d192334e1427 d192334e1422 ">
                                       <p><code class="codeph">ROW STORE COMPRESS</code>和<code class="codeph">ROW STORE COMPRESS</code> <code class="codeph">BASIC</code>是等效的。
                                       </p>
                                       <p>插入的行不使用直接路径或数组插入和更新的行是未压缩的。</p>
                                    </td>
                                 </tr>
                                 <tr align="left" valign="top">
                                    <td align="left" valign="top" width="27%" id="d192334e1451" headers="d192334e1413 ">
                                       <p>高级行压缩</p>
                                    </td>
                                    <td align="left" valign="top" width="21%" headers="d192334e1451 d192334e1416 ">
                                       <p><code class="codeph">ROW STORE COMPRESS ADVANCED</code></p>
                                    </td>
                                    <td align="left" valign="top" width="18%" headers="d192334e1451 d192334e1419 ">
                                       <p>行使用高级行压缩进行压缩。</p>
                                    </td>
                                    <td align="left" valign="top" width="34%" headers="d192334e1451 d192334e1422 ">
                                       <p>使用或不使用直接路径或数组插入和更新的行插入的行使用高级行压缩进行压缩。</p>
                                    </td>
                                 </tr>
                                 <tr align="left" valign="top">
                                    <td align="left" valign="top" width="27%" id="d192334e1465" headers="d192334e1413 ">
                                       <p>仓库压缩（混合列压缩）</p>
                                    </td>
                                    <td align="left" valign="top" width="21%" headers="d192334e1465 d192334e1416 ">
                                       <p><code class="codeph">COLUMN STORE COMPRESS for QUERY [LOW | HIGH]</code></p>
                                    </td>
                                    <td align="left" valign="top" width="18%" headers="d192334e1465 d192334e1419 ">
                                       <p>行通过仓库压缩进行压缩。</p>
                                    </td>
                                    <td align="left" valign="top" width="34%" headers="d192334e1465 d192334e1422 ">
                                       <p>此压缩方法可能导致高CPU开销。</p>
                                       <p>在不使用直接路径或数组插入的情况下插入的更新行和行以行格式而不是列格式存储，因此具有较低的压缩级别。</p>
                                    </td>
                                 </tr>
                                 <tr align="left" valign="top">
                                    <td align="left" valign="top" width="27%" id="d192334e1481" headers="d192334e1413 ">
                                       <p>归档压缩（混合列压缩）</p>
                                    </td>
                                    <td align="left" valign="top" width="21%" headers="d192334e1481 d192334e1416 ">
                                       <p><code class="codeph">COLUMN STORE COMPRESS for ARCHIVE [LOW | HIGH]</code></p>
                                    </td>
                                    <td align="left" valign="top" width="18%" headers="d192334e1481 d192334e1419 ">
                                       <p>行使用存档压缩进行压缩。</p>
                                    </td>
                                    <td align="left" valign="top" width="34%" headers="d192334e1481 d192334e1422 ">
                                       <p>此压缩方法可能导致高CPU开销。</p>
                                       <p>在不使用直接路径或数组插入的情况下插入的更新行和行以行格式而不是列格式存储，因此具有较低的压缩级别。</p>
                                    </td>
                                 </tr>
                              </tbody>
                           </table>
                        </div>
                        <!-- class="inftblhruleinformal" -->
                        <p>您可以使用<code class="codeph">CREATE</code> <code class="codeph">TABLE</code>语句的<code class="codeph">COMPRESS</code>子句指定表压缩。您可以使用<code class="codeph">ALTER</code> <code class="codeph">TABLE</code>语句中的这些子句为现有表启用压缩。在这种情况下，仅压缩在压缩之后插入或更新的数据。使用<code class="codeph">ALTER</code> <code class="codeph">TABLE</code> <code class="codeph">MOVE</code>语句还可以对插入和更新的数据进行压缩，但它也会压缩现有数据。同样，您可以使用<code class="codeph">ALTER</code> <code class="codeph">TABLE</code>禁用现有压缩表的表压缩...<code class="codeph">NOCOMPRESS</code>声明。在这种情况下，已经压缩的所有数据都将保持压缩状态，并且未压缩地插入新数据。
                        </p>
                        <p><code class="codeph">COLUMN STORE COMPRESS FOR QUERY HIGH</code>选项是默认的数据仓库压缩模式。在Exadata存储上使用混合列压缩时，它可提供良好的压缩和性能。<code class="codeph">COLUMN STORE COMPRESS FOR QUERY LOW</code>选项应该用于负载性能至关重要的环境中。它的加载速度比使用<code class="codeph">COLUMN STORE COMPRESS FOR QUERY HIGH</code>选项压缩的数据要快。
                        </p>
                        <p><code class="codeph">COLUMN STORE COMPRESS FOR ARCHIVE LOW</code>选项是默认的归档压缩模式。它提供高压缩级别，非常适合不常访问的数据。<code class="codeph">COLUMN STORE COMPRESS FOR ARCHIVE HIGH</code>选项应该用于很少访问的数据。
                        </p>
                        <p><code class="codeph">DBMS_COMPRESSION</code>包提供的压缩顾问程序可帮助您使用特定压缩方法确定特定表的预期压缩级别。
                        </p>
                        <div class="infoboxnote" id="GUID-ED833867-4B7F-442E-A70C-9C19DAA8F445__GUID-9FCB369A-F201-486E-828D-D95CAD2AAB0D">
                           <p class="notep1">注意：</p>
                           <p>混合列压缩依赖于底层存储系统。有关更多信息，请参见<a href="../dblic/Licensing-Information.html#DBLIC-GUID-0F9EB85D-4610-4EDF-89C2-4916A0E7AC87" target="_blank"><span class="italic">Oracle数据库许可</span></a>信息。
                           </p>
                        </div>
                     </div>
                     <div>
                        <div class="infoboxnotealso" id="GUID-ED833867-4B7F-442E-A70C-9C19DAA8F445__GUID-94FC3BED-646B-45A5-8528-97B9F1F5D5F1">
                           <p class="notep1">也可以看看：</p>
                           <p></p>
                           <ul style="list-style-type:disc">
                              <li>
                                 <p><a href="../cncpt/tables-and-table-clusters.html#CNCPT1132" target="_blank"><span class="italic">Oracle Database Concepts，</span></a>用于表压缩的概述</p>
                              </li>
                              <li>
                                 <p><span class="q">“ <a href="managing-tablespaces.html#GUID-556AFD6F-E0DA-4694-AB75-A3F8BA43EB03" title="创建表空间时，可以为表空间中创建的所有表和索引指定默认的数据压缩。默认压缩级别也适用于组成表空间的分区。压缩此数据可以减少磁盘使用。">关于具有默认压缩属性的表空间</a> ”</span></p>
                              </li>
                           </ul>
                        </div>
                        <div class="familylinks">
                           <div class="parentlink">
                              <p><strong>父主题：</strong> <a href="managing-tables.html#GUID-34D15DD1-0925-4C9A-BE8A-3EE91671E526" title="随着数据库大小的增长，请考虑使用表压缩来节省空间并提高性能。">考虑使用表压缩</a></p>
                           </div>
                        </div>
                     </div>
                     
                  </div><a id="ADMIN13952"></a><a id="ADMIN13953"></a><a id="ADMIN13954"></a><a id="ADMIN13955"></a><a id="ADMIN13956"></a><a id="ADMIN13951"></a><div class="props_rev_3"><a id="GUID-3FDE903A-6CA8-40B5-8B0B-FC9F5BB9C667" name="GUID-3FDE903A-6CA8-40B5-8B0B-FC9F5BB9C667"></a><h5 id="ADMIN-GUID-3FDE903A-6CA8-40B5-8B0B-FC9F5BB9C667" class="sect5"><span class="enumeration_section">20.2.6.2</span>与表压缩相关的示例</h5>
                     <div>
                        <p>示例说明了使用表压缩。</p>
                        <div class="example" id="GUID-3FDE903A-6CA8-40B5-8B0B-FC9F5BB9C667__BABBFCGB">
                           <p class="titleinexample">示例20-1使用高级行压缩创建表</p>
                           <p>以下示例对表<code class="codeph">orders</code>启用高级行压缩：</p><pre class="oac_no_warn" dir="ltr">CREATE TABLE命令......ROW STORE COMPRESS ADVANCED;</pre><p><code class="codeph">orders</code>表的数据在直接路径<code class="codeph">INSERT</code> ，数组插入和传统DML期间被压缩。</p>
                        </div>
                        <!-- class="example" -->
                        <div class="example" id="GUID-3FDE903A-6CA8-40B5-8B0B-FC9F5BB9C667__BABBCDIH">
                           <p class="titleinexample">示例20-2使用基本表压缩创建表</p>
                           <p>以下相同的语句在<code class="codeph">sales_history</code>表上启用基本表压缩，该表是数据仓库中的事实表：</p><pre class="oac_no_warn" dir="ltr">CREATE TABLE sales_history ...ROW STORE COMPRESS BASIC; CREATE TABLE sales_history ...ROW STORE COMPRESS;</pre><p>针对此表运行频繁的查询，但不需要DML。</p>
                        </div>
                        <!-- class="example" -->
                        <div class="example" id="GUID-3FDE903A-6CA8-40B5-8B0B-FC9F5BB9C667__BABFBGDI">
                           <p class="titleinexample">示例20-3使用直接路径插入将行插入表中</p>
                           <p>这个例子演示了如何使用<a id="d192334e1656" class="indexterm-anchor"></a> <code class="codeph">APPEND</code>提示使用直接路径<code class="codeph">INSERT</code>将行插入<code class="codeph">sales_history</code>表。</p><pre class="oac_no_warn" dir="ltr">INSERT / * + APPEND * / INTO sales_history SELECT * FROM sales WHERE cust_id = 8890;承诺;</pre></div>
                        <!-- class="example" -->
                        <div class="example" id="GUID-3FDE903A-6CA8-40B5-8B0B-FC9F5BB9C667__GUID-447DBECC-91B8-4C48-86C7-24CA127476C8">
                           <p class="titleinexample">示例20-4使用数组插入将行插入表中</p>
                           <p>此示例演示如何在SQL中使用数组插入将行插入<code class="codeph">sales_history</code>表。
                           </p><pre class="oac_no_warn" dir="ltr">INSERT INTO sales_history SELECT * FROM sales WHERE cust_id = 8890;承诺;</pre><p>此示例演示如何在PL / SQL中使用数组插入将行插入<code class="codeph">hr.jobs_test</code>表。
                           </p><pre class="oac_no_warn" dir="ltr">DECLARE TYPE table_def IS TABLE of hr.jobs％ROWTYPE; array table_def：= table_def（）; BEGIN SELECT * BULK收集数组来自hr.jobs; FORALL我在array.first .. array.last INSERT INTO hr.jobs_test VALUES array（i）;承诺;结束; /</pre><div class="infoboxnote" id="GUID-3FDE903A-6CA8-40B5-8B0B-FC9F5BB9C667__GUID-9EA51DC3-764B-45E6-A490-84A0992E0CFF">
                              <p class="notep1">注意：</p>
                              <p>对于混合列压缩（仓库和归档），对于在SQL，PL / SQL或OCI中执行的阵列插入，要立即压缩，该表必须存储在本地管理的表空间中，并启用自动段空间管理（ASSM），并且数据库兼容级别必须为12.2.0或更高。</p>
                           </div>
                        </div>
                        <!-- class="example" -->
                        <div class="example" id="GUID-3FDE903A-6CA8-40B5-8B0B-FC9F5BB9C667__BABGDBEB">
                           <p class="titleinexample">示例20-5使用仓库压缩创建表</p>
                           <p>此示例在表<code class="codeph">sales_history</code>上启用混合列压缩：</p><pre class="oac_no_warn" dir="ltr">CREATE TABLE sales_history ...COLUMN STORE COMPRESS FOR QUERY;</pre><p>该表是使用默认的<code class="codeph">COLUMN STORE COMPRESS FOR QUERY HIGH</code>选项创建的。此选项提供比基本表压缩或高级行压缩更高级别的压缩。当针对此表运行频繁查询并且不需要DML时，它可以正常工作。
                           </p>
                        </div>
                        <!-- class="example" -->
                        <div class="example" id="GUID-3FDE903A-6CA8-40B5-8B0B-FC9F5BB9C667__BABDDEEI">
                           <p class="titleinexample">示例20-6使用存档压缩创建表</p>
                           <p>以下示例在表<code class="codeph">sales_history</code>上启用混合列压缩：</p><pre class="oac_no_warn" dir="ltr">CREATE TABLE sales_history ...COLUMN STORE COMPRESS FOR ARCHIVE;</pre><p>该表是使用默认的<code class="codeph">COLUMN STORE COMPRESS FOR ARCHIVE LOW</code>选项创建的。此选项提供比基本，高级行或仓库压缩更高级别的压缩。当负载性能至关重要且不经常访问数据时，它可以很好地工作。默认的<code class="codeph">COLUMN STORE COMPRESS FOR ARCHIVE LOW</code>选项提供比<code class="codeph">COLUMN STORE COMPRESS FOR ARCHIVE HIGH</code>选项更低的压缩级别。
                           </p>
                        </div>
                        <!-- class="example" -->
                     </div>
                     <div>
                        <div class="familylinks">
                           <div class="parentlink">
                              <p><strong>父主题：</strong> <a href="managing-tables.html#GUID-34D15DD1-0925-4C9A-BE8A-3EE91671E526" title="随着数据库大小的增长，请考虑使用表压缩来节省空间并提高性能。">考虑使用表压缩</a></p>
                           </div>
                        </div>
                     </div>
                     
                  </div><a id="ADMIN13957"></a><div class="props_rev_3"><a id="GUID-F10EF5C9-AA5C-4F74-87DD-603955A64CB2" name="GUID-F10EF5C9-AA5C-4F74-87DD-603955A64CB2"></a><h5 id="ADMIN-GUID-F10EF5C9-AA5C-4F74-87DD-603955A64CB2" class="sect5"><span class="enumeration_section">20.2.6.3</span>压缩和分区表</h5>
                     <div>
                        <p>表可以包含压缩和未压缩的分区，不同的分区可以使用不同的压缩方法。如果表及其某个分区的压缩设置不匹配，则分区设置优先于分区。</p>
                        <p>要更改分区的压缩方法，请执行以下操作之一：</p>
                        <ul style="list-style-type:disc">
                           <li>
                              <p>要仅更改新数据的压缩方法，请使用<code class="codeph">ALTER</code> <code class="codeph">TABLE</code> ...<code class="codeph">MODIFY</code> <code class="codeph">PARTITION</code> ......<code class="codeph">COMPRESS</code> ......
                              </p>
                           </li>
                           <li>
                              <p>要更改新数据和现有数据的压缩方法，请使用<code class="codeph">ALTER</code> <code class="codeph">TABLE</code> ...<code class="codeph">MOVE</code> <code class="codeph">PARTITION</code> ......<code class="codeph">COMPRESS</code> ...或在线表重新定义。
                              </p>
                           </li>
                        </ul>
                        <p>执行这些语句时，请指定压缩方法。例如，运行以下语句将压缩方法更改为新数据和现有数据的高级行压缩：</p><pre class="oac_no_warn" dir="ltr">ALTER TABLE ...移动分区......ROW STORE COMPRESS ADVANCED ......</pre></div>
                     <div>
                        <div class="familylinks">
                           <div class="parentlink">
                              <p><strong>父主题：</strong> <a href="managing-tables.html#GUID-34D15DD1-0925-4C9A-BE8A-3EE91671E526" title="随着数据库大小的增长，请考虑使用表压缩来节省空间并提高性能。">考虑使用表压缩</a></p>
                           </div>
                        </div>
                     </div>
                     
                  </div><a id="ADMIN13958"></a><div class="props_rev_3"><a id="GUID-E56CD5F0-2788-4B05-A72D-CAD9A986B127" name="GUID-E56CD5F0-2788-4B05-A72D-CAD9A986B127"></a><h5 id="ADMIN-GUID-E56CD5F0-2788-4B05-A72D-CAD9A986B127" class="sect5"><span class="enumeration_section">20.2.6.4</span>确定表是否压缩</h5>
                     <div>
                        <p>在<code class="codeph">*_TABLES</code>数据字典视图中，压缩表在<code class="codeph">COMPRESSION</code>列中具有<code class="codeph">ENABLED</code> 。
                        </p>
                        <div class="section">
                           <p>对于分区表，此<code class="codeph">*_TAB_PARTITIONS</code> null， <code class="codeph">*_TAB_PARTITIONS</code>视图的<code class="codeph">COMPRESSION</code>列指示已压缩的分区。此外， <code class="codeph">COMPRESS_FOR</code>列指示用于表或分区的压缩方法。
                           </p><pre class="oac_no_warn" dir="ltr">SQL&gt; SELECT table_name，compression，compress_for FROM user_tables; TABLE_NAME COMPRESSION COMPRESS_FOR ---------------- ------------ ----------------- T1 DISABLED T2启用基本T3启用高级T4启用查询高T5启用存档低</pre><pre class="oac_no_warn" dir="ltr">SQL&gt; SELECT table_name，partition_name，compression，compress_for FROM user_tab_partitions; TABLE_NAME PARTITION_NAME COMPRESSION COMPRESS_FOR ----------- ---------------- ----------- -------- ---------------------- SALES Q4_2004 ENABLED ARCHIVE HIGH ...销售额Q3_2008获得高销售额Q4_2008获得高销售额Q1_2009获得高级销售额Q2_2009获得高级销售额</pre></div>
                        <!-- class="section" -->
                     </div>
                     <div>
                        <div class="familylinks">
                           <div class="parentlink">
                              <p><strong>父主题：</strong> <a href="managing-tables.html#GUID-34D15DD1-0925-4C9A-BE8A-3EE91671E526" title="随着数据库大小的增长，请考虑使用表压缩来节省空间并提高性能。">考虑使用表压缩</a></p>
                           </div>
                        </div>
                     </div>
                     
                  </div><a id="ADMIN13959"></a><div class="props_rev_3"><a id="GUID-FA9385A5-C77E-4E8F-809F-7704BAD9EE2D" name="GUID-FA9385A5-C77E-4E8F-809F-7704BAD9EE2D"></a><h5 id="ADMIN-GUID-FA9385A5-C77E-4E8F-809F-7704BAD9EE2D" class="sect5"><span class="enumeration_section">20.2.6.5</span>确定哪些行是压缩的</h5>
                     <div>
                        <p>要确定行的压缩级别，请使用<code class="codeph">DBMS_COMPRESSION</code>包中的<code class="codeph">GET_COMPRESSION_TYPE</code>函数。
                        </p>
                        <div class="section">
                           <p>例如，以下查询返回<code class="codeph">hr.employees</code>表中行的压缩类型：</p><pre class="oac_no_warn" dir="ltr">SELECT DECODE（DBMS_COMPRESSION.GET_COMPRESSION_TYPE（ownname =&gt;'HR'，tabname =&gt;'EMPLOYEES'，subobjname =&gt;''，row_id =&gt;'AAAVEIAAGAAAABTAAD'），1，'无压缩'，2，'高级行压缩'， 4，“查询高的混合列压缩”，8，“查询低的混合列压缩”，16，“存档高的混合列压缩”，32，“存档低的混合列压缩”，4096，'基本表压缩'，'未知压缩类型'）compression_type FROM DUAL;</pre></div>
                        <!-- class="section" -->
                     </div>
                     <div>
                        <div class="infoboxnotealso" id="GUID-FA9385A5-C77E-4E8F-809F-7704BAD9EE2D__GUID-845D69CA-2210-4671-97CD-9BD1B15B1313">
                           <p class="notep1">也可以看看：</p>
                           <p>有关<code class="codeph">GET_COMPRESSION_TYPE</code>其他信息，请<code class="codeph">GET_COMPRESSION_TYPE</code> <a href="../arpls/DBMS_COMPRESSION.html#ARPLS65610" target="_blank"><span class="italic">Oracle Database PL / SQL包和类型参考</span></a></p>
                        </div>
                        <div class="familylinks">
                           <div class="parentlink">
                              <p><strong>父主题：</strong> <a href="managing-tables.html#GUID-34D15DD1-0925-4C9A-BE8A-3EE91671E526" title="随着数据库大小的增长，请考虑使用表压缩来节省空间并提高性能。">考虑使用表压缩</a></p>
                           </div>
                        </div>
                     </div>
                     
                  </div><a id="ADMIN13960"></a><div class="props_rev_3"><a id="GUID-364F249F-ED4D-4CF3-B4FE-9724D5978D5E" name="GUID-364F249F-ED4D-4CF3-B4FE-9724D5978D5E"></a><h5 id="ADMIN-GUID-364F249F-ED4D-4CF3-B4FE-9724D5978D5E" class="sect5"><span class="enumeration_section">20.2.6.6</span>更改压缩级别</h5>
                     <div>
                        <p>您可以更改分区，表或表空间的压缩级别。</p>
                        <div class="section">
                           <p>例如，假设公司对其销售数据使用仓库压缩，但很少访问超过六个月的销售数据。如果销售数据存储在基于数据年龄分区的表中，则可以将旧数据的压缩级别更改为存档压缩以释放磁盘空间。</p>
                           <p>要更改分区或子分区的压缩级别，可以使用以下语句：</p>
                        </div>
                        <!-- class="section" -->
                        <div class="section">
                           <ul style="list-style-type:disc">
                              <li>
                                 <p><code class="codeph">ALTER</code> <code class="codeph">TABLE</code> <code class="codeph">...</code> <code class="codeph">MOVE</code> <code class="codeph">PARTITION</code> <code class="codeph">...</code> <code class="codeph">线上</code></p>
                              </li>
                              <li>
                                 <p><code class="codeph">ALTER</code> <code class="codeph">TABLE</code> <code class="codeph">...</code> <code class="codeph">MOVE</code> <code class="codeph">SUBPARTITION</code> <code class="codeph">...</code> <code class="codeph">线上</code></p>
                              </li>
                           </ul>
                           <p>这两个语句支持<code class="codeph">ONLINE</code>关键字，这使得DML操作可以在正在移动的分区或子分区上不间断地运行。在移动分区或子分区时，这些语句还会自动更新所有索引。你也可以使用<code class="codeph">ALTER TABLE...MODIFY PARTITION</code>语句或在线重新定义以更改分区的压缩级别。
                           </p>
                           <p>如果表没有分区，那么你可以使用<code class="codeph">ALTER TABLE...移动...COMPRESS FOR...</code>语句更改压缩级别。<code class="codeph">ALTER TABLE...在命令运行时， MOVE</code>语句不允许对表执行DML语句。但是，您还可以使用联机重定义来压缩表，从而在重新定义期间使表可用于查询和DML语句。
                           </p>
                           <p>若要更改表空间的压缩级别，请使用<code class="codeph">ALTER TABLESPACE</code>语句。
                           </p>
                        </div>
                        <!-- class="section" -->
                     </div>
                     <div>
                        <div class="infoboxnotealso" id="GUID-364F249F-ED4D-4CF3-B4FE-9724D5978D5E__GUID-67134359-DDFF-4630-AC25-C48DF35FA22A">
                           <p class="notep1">也可以看看：</p>
                           <p></p>
                           <ul style="list-style-type:disc">
                              <li>
                                 <p><span class="q">“ <a href="managing-tables.html#GUID-3DE67CF4-84C5-4AED-A8A3-B1D28D8EBEF6" title="ALTER TABLE ...假设您在目标表空间中具有适当的配额，MOVE [PARTITION | SUBPARTITION]语句使您可以移动表，分区或子分区以更改任何物理存储属性（如压缩或表空间）。">将表移动到新段或表空间</a> ”</span>以获取有关<code class="codeph">ALTER TABLE</code>命令的其他信息</p>
                              </li>
                              <li>
                                 <p><span class="q">“ <a href="managing-tables.html#GUID-F95114BC-F512-4A1F-B5BD-07DDDE60D934" title="在任何数据库系统中，有时需要修改表的逻辑或物理结构，以提高查询或DML的性能，适应应用程序更改或管理存储。您可以使用DBMS_REDEFINITION包在线重新定义表。">在线重新定义表格</a> ”</span></p>
                              </li>
                              <li>
                                 <p>有关<code class="codeph">DBMS_REDEFINITION</code>包的其他信息，请参阅<a href="../arpls/DBMS_REDEFINITION.html#ARPLS042" target="_blank"><span class="italic">Oracle Database PL / SQL包和类型参考</span></a></p>
                              </li>
                           </ul>
                        </div>
                        <div class="familylinks">
                           <div class="parentlink">
                              <p><strong>父主题：</strong> <a href="managing-tables.html#GUID-34D15DD1-0925-4C9A-BE8A-3EE91671E526" title="随着数据库大小的增长，请考虑使用表压缩来节省空间并提高性能。">考虑使用表压缩</a></p>
                           </div>
                        </div>
                     </div>
                     
                  </div><a id="ADMIN13961"></a><div class="props_rev_3"><a id="GUID-321C8937-3F4A-4641-9B77-CB06BDE9382C" name="GUID-321C8937-3F4A-4641-9B77-CB06BDE9382C"></a><h5 id="ADMIN-GUID-321C8937-3F4A-4641-9B77-CB06BDE9382C" class="sect5"><span class="enumeration_section">20.2.6.7</span>在压缩表中添加和删除列</h5>
                     <div>
                        <p>将列添加到压缩表或从压缩表中删除列时，会有一些限制。</p>
                        <p>将列添加到压缩表时，以下限制适用：</p>
                        <ul style="list-style-type:disc">
                           <li>
                              <p>高级行压缩，仓库压缩和存档压缩：如果为添加的列指定了默认值并且已填充表，则必须满足优化添加列行为的条件。<a href="../sqlrf/ALTER-TABLE.html#SQLRF53355" target="_blank"><span class="italic">Oracle数据库SQL语言参考</span></a>中描述了这些条件。
                              </p>
                           </li>
                        </ul>
                        <p>删除压缩表中的列时，以下限制适用：</p>
                        <ul style="list-style-type:disc">
                           <li>
                              <p>基本表压缩：不支持删除列。</p>
                           </li>
                           <li>
                              <p>高级行压缩，仓库压缩和归档压缩：支持<code class="codeph">DROP</code> <code class="codeph">COLUMN</code> ，但在数据库内部设置<code class="codeph">UNUSED</code>列以避免长时间运行的解压缩和重新压缩操作。
                              </p>
                           </li>
                        </ul>
                     </div>
                     <div>
                        <div class="familylinks">
                           <div class="parentlink">
                              <p><strong>父主题：</strong> <a href="managing-tables.html#GUID-34D15DD1-0925-4C9A-BE8A-3EE91671E526" title="随着数据库大小的增长，请考虑使用表压缩来节省空间并提高性能。">考虑使用表压缩</a></p>
                           </div>
                        </div>
                     </div>
                     
                  </div><a id="ADMIN13962"></a><div class="props_rev_3"><a id="GUID-BD0E0587-1BF3-4EB1-9E0E-4F24F0B54A0B" name="GUID-BD0E0587-1BF3-4EB1-9E0E-4F24F0B54A0B"></a><h5 id="ADMIN-GUID-BD0E0587-1BF3-4EB1-9E0E-4F24F0B54A0B" class="sect5"><span class="enumeration_section">20.2.6.8</span>导出和导入混合列压缩表</h5>
                     <div>
                        <p>可以使用Data Pump Import实用程序的<code class="codeph">impdp</code>命令导入混合列压缩表。
                        </p>
                        <div class="section">
                           <p>默认情况下， <code class="codeph">impdp</code>命令保留表属性，导入的表是混合列压缩表。在不支持混合列压缩的表空间上， <code class="codeph">impdp</code>命令失败并显示错误。也可以使用<code class="codeph">expdp</code>命令导出表。
                           </p>
                           <p>您可以使用<code class="codeph">impdp</code>命令的<code class="codeph">TRANSFORM=SEGMENT_ATTRIBUTES:n</code>选项子句将Hybrid Columnar Compression表导入为未压缩的表。
                           </p>
                           <p>在导入期间，可以将未压缩或高级行压缩表转换为混合列压缩格式。要将非混合列压缩表转换为混合列压缩表，请执行以下操作：</p>
                        </div>
                        <!-- class="section" -->
                        <ol>
                           <li><span>使用<code class="codeph">ALTER TABLESPACE ...指定表空间的默认压缩<code class="codeph">ALTER TABLESPACE ...SET DEFAULT COMPRESS</code>命令。</span></li>
                           <li><span>导入期间覆盖导入表的<code class="codeph">SEGMENT_ATTRIBUTES</code>选项。</span></li>
                        </ol>
                        <div class="section"></div>
                        <!-- class="section" -->
                     </div>
                     <div>
                        <div class="infoboxnotealso" id="GUID-BD0E0587-1BF3-4EB1-9E0E-4F24F0B54A0B__GUID-9FF05C5B-8DB6-4022-A17C-CCCD1FF2086C">
                           <p class="notep1">也可以看看：</p>
                           <p></p>
                           <ul style="list-style-type:disc">
                              <li>
                                 <p>有关Data Pump Import实用<a href="../sutil/datapump-import-utility.html#SUTIL300" target="_blank"><span class="italic">程序</span></a>的其他信息，请<a href="../sutil/datapump-import-utility.html#SUTIL300" target="_blank"><span class="italic">参见Oracle数据库实用</span></a>程序</p>
                              </li>
                              <li>
                                 <p>有关<code class="codeph">ALTER TABLESPACE</code>命令的其他信息，请<a href="../sqlrf/ALTER-TABLESPACE.html#SQLRF01002" target="_blank"><span class="italic">参见Oracle数据库SQL语言参考</span></a></p>
                              </li>
                           </ul>
                        </div>
                        <div class="familylinks">
                           <div class="parentlink">
                              <p><strong>父主题：</strong> <a href="managing-tables.html#GUID-34D15DD1-0925-4C9A-BE8A-3EE91671E526" title="随着数据库大小的增长，请考虑使用表压缩来节省空间并提高性能。">考虑使用表压缩</a></p>
                           </div>
                        </div>
                     </div>
                     
                  </div><a id="ADMIN13963"></a><div class="props_rev_3"><a id="GUID-4826DC4F-F4E5-4500-AF00-EAA8F46E9AD5" name="GUID-4826DC4F-F4E5-4500-AF00-EAA8F46E9AD5"></a><h5 id="ADMIN-GUID-4826DC4F-F4E5-4500-AF00-EAA8F46E9AD5" class="sect5"><span class="enumeration_section">20.2.6.9</span>恢复混合列压缩表</h5>
                     <div>
                        <p>有时可能必须从备份还原混合列压缩表。该表可以还原到支持混合列压缩的系统，也可以还原到不支持混合列压缩的系统。</p>
                        <div class="section">
                           <p>将具有混合列压缩的表还原到支持混合列压缩的系统时，照常使用Oracle Recovery Manager（RMAN）还原文件。</p>
                           <p>将混合列压缩表还原到不支持混合列压缩的系统时，必须将表从混合列压缩转换为高级行压缩或未压缩格式。要恢复表，请执行以下操作：</p>
                        </div>
                        <!-- class="section" -->
                        <ol>
                           <li class="stepexpand"><span>确保环境中有足够的存储空间来保存未压缩或高级行压缩格式的数据。</span></li>
                           <li class="stepexpand"><span>使用RMAN还原混合列压缩表空间。</span></li>
                           <li class="stepexpand"><span>完成以下操作之一，将表从混合列压缩转换为高级行压缩或未压缩格式：</span><div>
                                 <ul style="list-style-type:disc">
                                    <li>
                                       <p>使用以下语句将数据压缩从混合列压缩更改为<code class="codeph">ROW STORE COMPRESS ADVANCED</code> ：</p><pre class="oac_no_warn" dir="ltr">ALTER TABLE <span class="italic"><code class="codeph">table_name</code></span> MOVE ROW STORE COMPRESS ADVANCED;</pre></li>
                                    <li>
                                       <p>使用以下语句将数据压缩从Hybrid Columnar Compression更改为<code class="codeph">NOCOMPRESS</code> ：</p><pre class="oac_no_warn" dir="ltr">ALTER TABLE <span class="italic"><code class="codeph">table_name</code></span> MOVE NOCOMPRESS;</pre></li>
                                    <li>
                                       <p>使用以下语句将每个分区更改为<code class="codeph">NOCOMPRESS</code> ：</p><pre class="oac_no_warn" dir="ltr">ALTER TABLE <span class="italic"><code class="codeph">table_name</code></span> MOVE PARTITION <span class="italic"><code class="codeph">partition_name</code></span> NOCOMPRESS;</pre><p>分别更改每个分区。</p>
                                       <p>如果分区在移动时需要DML，则包含<code class="codeph">ONLINE</code>关键字：</p><pre class="oac_no_warn" dir="ltr">ALTER TABLE <span class="italic"><code class="codeph">table_name</code></span> MOVE PARTITION <span class="italic"><code class="codeph">partition_name</code></span> NOCOMPRESS ONLINE;</pre><p>在线移动分区可能比离线移动分区要花费更长的时间。</p>
                                    </li>
                                    <li>
                                       <p>使用以下语句将数据并行移动到<code class="codeph">NOCOMPRESS</code> ：</p><pre class="oac_no_warn" dir="ltr">ALTER TABLE <span class="italic"><code class="codeph">table_name</code></span> MOVE NOCOMPRESS PARALLEL;</pre></li>
                                 </ul>
                              </div>
                           </li>
                        </ol>
                        <div class="section"></div>
                        <!-- class="section" -->
                     </div>
                     <div>
                        <div class="infoboxnotealso" id="GUID-4826DC4F-F4E5-4500-AF00-EAA8F46E9AD5__GUID-0E5D85AE-8C5B-4DF6-B3AB-12C193E79BA9">
                           <p class="notep1">也可以看看：</p>
                           <p></p>
                           <ul style="list-style-type:disc">
                              <li>
                                 <p>有关RMAN的其他信息，请参见<a href="../bradv/getting-started-rman.html#BRADV89346" target="_blank"><span class="italic">“Oracle数据库备份和恢复用户指南”</span></a></p>
                              </li>
                              <li>
                                 <p>有关<code class="codeph">ALTER TABLE</code>命令的其他信息，请<a href="../sqlrf/ALTER-TABLE.html#SQLRF01001" target="_blank"><span class="italic">参见Oracle数据库SQL语言参考</span></a></p>
                              </li>
                           </ul>
                        </div>
                        <div class="familylinks">
                           <div class="parentlink">
                              <p><strong>父主题：</strong> <a href="managing-tables.html#GUID-34D15DD1-0925-4C9A-BE8A-3EE91671E526" title="随着数据库大小的增长，请考虑使用表压缩来节省空间并提高性能。">考虑使用表压缩</a></p>
                           </div>
                        </div>
                     </div>
                     
                  </div><a id="ADMIN13964"></a><div class="props_rev_3"><a id="GUID-13D5D4C8-AA82-4AF6-A730-D36CA6DDEA31" name="GUID-13D5D4C8-AA82-4AF6-A730-D36CA6DDEA31"></a><h5 id="ADMIN-GUID-13D5D4C8-AA82-4AF6-A730-D36CA6DDEA31" class="sect5"><span class="enumeration_section">20.2.6.10</span>压缩表的注释和限制</h5>
                     <div>
                        <p>考虑与压缩表相关的注释和限制。</p>
                        <p>以下是与压缩表相关的注释和限制：</p>
                        <ul style="list-style-type:disc">
                           <li>
                              <div class="p">以下类型的表不支持高级行压缩，仓库压缩和存档压缩：<ul style="list-style-type:disc">
                                    <li>
                                       <p>索引组织表</p>
                                    </li>
                                    <li>
                                       <p>外部表格</p>
                                    </li>
                                    <li>
                                       <p>具有<code class="codeph">LONG</code>或<code class="codeph">LONG RAW</code>列的表</p>
                                    </li>
                                    <li>
                                       <p>临时表</p>
                                    </li>
                                    <li>
                                       <p>启用了<code class="codeph">ROWDEPENDENCIES</code>表</p>
                                    </li>
                                    <li>
                                       <p>集群表</p>
                                    </li>
                                 </ul>
                              </div>
                           </li>
                           <li>
                              <p>使用以下压缩方法压缩的表不支持在线段缩小：</p>
                              <ul style="list-style-type:disc">
                                 <li>
                                    <p>使用<code class="codeph">ROW STORE COMPRESS BASIC</code>基本表压缩</p>
                                 </li>
                                 <li>
                                    <p>使用<code class="codeph">COLUMN STORE COMPRESS FOR QUERY</code>仓库压缩</p>
                                 </li>
                                 <li>
                                    <p>使用<code class="codeph">COLUMN STORE COMPRESS FOR ARCHIVE</code>归档压缩</p>
                                 </li>
                              </ul>
                           </li>
                           <li>
                              <p>本节中描述的表压缩方法不适用于SecureFiles大对象（LOB）。SecureFiles LOB有自己的压缩方法。有关更多信息，请参见<a href="../adlob/using-oracle-LOBs-storage.html#ADLOB4444" target="_blank"><span class="italic">Oracle Database SecureFiles和Large Objects Developer's Guide</span></a> 。
                              </p>
                           </li>
                           <li>
                              <p>压缩技术使用CPU。确保您有足够的可用CPU来处理额外的负载。</p>
                           </li>
                           <li>
                              <p>除非另行指定，否则使用基本表压缩创建的表将<code class="codeph">PCT_FREE</code>参数自动设置为<code class="codeph">0</code> 。
                              </p>
                           </li>
                        </ul>
                     </div>
                     <div>
                        <div class="familylinks">
                           <div class="parentlink">
                              <p><strong>父主题：</strong> <a href="managing-tables.html#GUID-34D15DD1-0925-4C9A-BE8A-3EE91671E526" title="随着数据库大小的增长，请考虑使用表压缩来节省空间并提高性能。">考虑使用表压缩</a></p>
                           </div>
                        </div>
                     </div>
                     
                  </div><a id="ADMIN13965"></a><div class="props_rev_3"><a id="GUID-11A2D127-327C-4530-A457-F041FC091C4A" name="GUID-11A2D127-327C-4530-A457-F041FC091C4A"></a><h5 id="ADMIN-GUID-11A2D127-327C-4530-A457-F041FC091C4A" class="sect5"><span class="enumeration_section">20.2.6.11</span>包装压缩表</h5>
                     <div>
                        <p>如果在使用基本表压缩或混合列压缩压缩的表上使用常规DML，则所有插入和更新的行都将以未压缩或压缩较少的格式存储。要“压缩”压缩表以便压缩这些行，请使用<code class="codeph">ALTER</code> <code class="codeph">TABLE</code> <code class="codeph">MOVE</code>语句。
                        </p>
                        <div class="section">
                           <p>此操作对表执行独占锁定，因此在完成之前会阻止任何更新和加载。如果这是不可接受的，那么您可以使用在线表重新定义。</p>
                           <p>移动分区或子分区时，可以使用<code class="codeph">ALTER</code> <code class="codeph">TABLE</code> <code class="codeph">MOVE</code>语句压缩分区或子分区，同时仍允许DML操作在正在移动的分区或子分区上运行中断。
                           </p>
                        </div>
                        <!-- class="section" -->
                     </div>
                     <div>
                        <div class="infoboxnotealso" id="GUID-11A2D127-327C-4530-A457-F041FC091C4A__GUID-CF706F58-44AA-40FF-BBA1-455E5A5F6D47">
                           <p class="notep1">也可以看看：</p>
                           <ul style="list-style-type:disc">
                              <li>
                                 <p><a href="../sqlrf/ALTER-TABLE.html#SQLRF01001" target="_blank"><span class="italic">Oracle数据库SQL语言参考</span></a>有关<code class="codeph">ALTER</code> <code class="codeph">TABLE</code>更多详细信息...<code class="codeph">COMPRESS</code>和<code class="codeph">ALTER</code> <code class="codeph">TABLE</code> ......<code class="codeph">MOVE</code>语句，包括限制</p>
                              </li>
                              <li>
                                 <p>有关表分区的详细信息，请<a href="../vldbg/partition-table-compression.html#VLDBG00404" target="_blank"><span class="italic">参见“Oracle数据库VLDB和分区指南”</span></a></p>
                              </li>
                              <li>
                                 <p><span class="q">“ <a href="managing-tables.html#GUID-F95114BC-F512-4A1F-B5BD-07DDDE60D934" title="在任何数据库系统中，有时需要修改表的逻辑或物理结构，以提高查询或DML的性能，适应应用程序更改或管理存储。您可以使用DBMS_REDEFINITION包在线重新定义表。">在线重新定义表格</a> ”</span></p>
                              </li>
                              <li>
                                 <p><span class="q">“ <a href="managing-tables.html#GUID-3DE67CF4-84C5-4AED-A8A3-B1D28D8EBEF6" title="ALTER TABLE ...假设您在目标表空间中具有适当的配额，MOVE [PARTITION | SUBPARTITION]语句使您可以移动表，分区或子分区以更改任何物理存储属性（如压缩或表空间）。">将表移动到新段或表空间</a> ”</span>以获取有关移动表，分区或子分区的更多信息</p>
                              </li>
                           </ul>
                        </div>
                        <div class="familylinks">
                           <div class="parentlink">
                              <p><strong>父主题：</strong> <a href="managing-tables.html#GUID-34D15DD1-0925-4C9A-BE8A-3EE91671E526" title="随着数据库大小的增长，请考虑使用表压缩来节省空间并提高性能。">考虑使用表压缩</a></p>
                           </div>
                        </div>
                     </div>
                     
                  </div>
               </div><a id="ADMIN14300"></a><div class="sect3"><a id="GUID-C431C787-F714-4A3B-A745-90F6BCD92A1B" name="GUID-C431C787-F714-4A3B-A745-90F6BCD92A1B"></a><h4 id="ADMIN-GUID-C431C787-F714-4A3B-A745-90F6BCD92A1B" class="sect4"><span class="enumeration_section">20.2.7</span>使用Enterprise Manager云控制管理表压缩</h4>
                  <div>
                     <p>您可以使用Oracle Enterprise Manager Cloud Control管理表压缩。</p>
                     <p></p>
                  </div>
                  <div>
                     <ul class="ullinks">
                        <li class="ulchildlink"><a href="managing-tables.html#GUID-1827B634-3CC7-47E9-8711-0B376F0770E8">表压缩和企业管理器云控制</a><br>Enterprise Manager显示多个中央压缩页面，这些页面汇总了数据库和表空间级别的压缩功能，并包含指向不同压缩页面的链接。“压缩”页面显示数据库级别和表空间级别的压缩存储空间的摘要。
                        </li>
                        <li class="ulchildlink"><a href="managing-tables.html#GUID-41BA9ED3-3DA1-4069-A87C-458831787731">在数据库级别查看压缩摘要</a><br>您可以在数据库级别查看“压缩摘要”信息。
                        </li>
                        <li class="ulchildlink"><a href="managing-tables.html#GUID-10CA7B47-6000-4292-9E67-20B062E702EA">在表空间级别查看压缩摘要</a><br>您可以在表空间级别查看压缩摘要信息。
                        </li>
                        <li class="ulchildlink"><a href="managing-tables.html#GUID-65490EE0-046A-4F5B-B8B6-F88D3B6CAF48">估算压缩比</a><br>您可以运行Compression Advisor来计算特定对象的压缩率。
                        </li>
                        <li class="ulchildlink"><a href="managing-tables.html#GUID-607E82AF-69CF-4DAC-ABEB-F2F27492FF38">压缩对象</a><br>您可以压缩对象，例如表格。
                        </li>
                        <li class="ulchildlink"><a href="managing-tables.html#GUID-E6EB188A-9BE3-4030-BE5F-A6D9E3383432">查看压缩建议</a><br>您可以从Segment Advisor查看压缩建议，并根据它们执行操作。
                        </li>
                        <li class="ulchildlink"><a href="managing-tables.html#GUID-3EA670DB-C9F4-493E-9EA9-94C745C92A93">在对象上启动自动数据优化</a><br>您可以在对象上启动自动数据优化。
                        </li>
                     </ul>
                     <div class="familylinks">
                        <div class="parentlink">
                           <p><strong>父主题：</strong> <a href="managing-tables.html#GUID-86F766C5-2344-4790-95E4-4E813A0B21DA" title="遵循指南可以使表的管理更容易，并且可以在创建表时以及加载，更新和查询表数据时提高性能。">管理表的准则</a></p>
                        </div>
                     </div>
                  </div>
                  
                  <div class="sect4"><a id="GUID-1827B634-3CC7-47E9-8711-0B376F0770E8" name="GUID-1827B634-3CC7-47E9-8711-0B376F0770E8"></a><h5 id="ADMIN-GUID-1827B634-3CC7-47E9-8711-0B376F0770E8" class="sect5"><span class="enumeration_section">20.2.7.1</span>表压缩和企业管理器云控制</h5>
                     <div>
                        <p>Enterprise Manager显示多个中央压缩页面，这些页面汇总了数据库和表空间级别的压缩功能，并包含指向不同压缩页面的链接。“压缩”页面显示数据库级别和表空间级别的压缩存储空间的摘要。</p>
                        <p>在数据库级别，“数据库压缩摘要”页面显示总数据库大小（所有对象的总大小，包括压缩和未压缩），数据库中压缩对象的总大小，数据库中未压缩对象的总大小以及压缩对象的总大小与总数据库大小的比率。这为您提供了有关压缩数据库中存储空间的一般概念。然后，您可以根据显示的信息采取措施。</p>
                        <p>同样在表空间级别，“表空间的压缩摘要”页面显示总表空间大小（所有对象的总大小，包括压缩和未压缩），表空间中压缩对象的总大小，表空间中未压缩对象的总大小以及压缩对象的总大小与总表空间大小的比率。</p>
                        <p>您可以使用“压缩”功能执行以下任务：</p>
                        <ul style="list-style-type:disc">
                           <li>
                              <p>查看数据库级别前100个表空间或表空间级别前100个对象的压缩存储空间摘要。您可以查看在使用最多数据库存储的前100个表空间中的每个表空间中压缩多少存储空间的摘要，包括表空间的总大小，表空间的压缩大小，表空间的未压缩大小以及表空间中的压缩存储。然后，您可以根据显示的信息执行压缩任务。</p>
                           </li>
                           <li>
                              <p>查看由四种对象类型的每种压缩类型压缩的存储大小：表，索引，LOB（大对象）和DBFS（Oracle数据库文件系统）。</p>
                           </li>
                           <li>
                              <p>计算特定对象的压缩率。</p>
                           </li>
                           <li>
                              <p>压缩对象（表空间，表，分区或LOB）。这样可以节省存储空间。您可以运行Compression Advisor以确定可以保存多少空间，然后对该对象执行压缩操作。</p>
                           </li>
                           <li>
                              <p>查看Segment Advisor的压缩建议。您可以访问Segment Advisor的链接以压缩细分。</p>
                           </li>
                        </ul>
                     </div>
                     <div>
                        <div class="familylinks">
                           <div class="parentlink">
                              <p><strong>父主题：</strong> <a href="managing-tables.html#GUID-C431C787-F714-4A3B-A745-90F6BCD92A1B" title="您可以使用Oracle Enterprise Manager Cloud Control管理表压缩。">使用Enterprise Manager云控制管理表压缩</a></p>
                           </div>
                        </div>
                     </div>
                     
                  </div><a id="ADMIN14301"></a><div class="props_rev_3"><a id="GUID-41BA9ED3-3DA1-4069-A87C-458831787731" name="GUID-41BA9ED3-3DA1-4069-A87C-458831787731"></a><h5 id="ADMIN-GUID-41BA9ED3-3DA1-4069-A87C-458831787731" class="sect5"><span class="enumeration_section">20.2.7.2</span>在数据库级别查看压缩摘要</h5>
                     <div>
                        <p>您可以在数据库级别查看“压缩摘要”信息。</p>
                        <ol>
                           <li class="stepexpand"><span>从<span class="bold">Administration</span>菜单中，选择<span class="bold">Storage</span> ，然后选择<span class="bold">Compression</span> 。</span><div>
                                 <p>Enterprise Manager显示“前100个表空间的压缩摘要”页面。</p>
                              </div>
                           </li>
                           <li class="stepexpand"><span>您可以在数据库级别查看有关存储压缩的摘要信息，包括在“空间使用”部分中的总数据库大小，数据库中压缩对象的总大小以及压缩对象的总大小与总数据库的比率大小和未压缩的对象大小。段计数部分的类似信息也显示在“段计数”部分中。</span></li>
                           <li class="stepexpand"><span>您可以查看每种压缩类型对四种对象类型使用的存储大小：表，索引，LOB（大对象）和DBFS（Oracle数据库文件系统）。单击图表中的每种颜色将显示“段的压缩摘要”页面，该页面按特定对象类型和压缩类型在数据库中按大小显示前100个段的压缩信息。</span></li>
                        </ol>
                     </div>
                     <div>
                        <div class="familylinks">
                           <div class="parentlink">
                              <p><strong>父主题：</strong> <a href="managing-tables.html#GUID-C431C787-F714-4A3B-A745-90F6BCD92A1B" title="您可以使用Oracle Enterprise Manager Cloud Control管理表压缩。">使用Enterprise Manager云控制管理表压缩</a></p>
                           </div>
                        </div>
                     </div>
                     
                  </div><a id="ADMIN14302"></a><div class="props_rev_3"><a id="GUID-10CA7B47-6000-4292-9E67-20B062E702EA" name="GUID-10CA7B47-6000-4292-9E67-20B062E702EA"></a><h5 id="ADMIN-GUID-10CA7B47-6000-4292-9E67-20B062E702EA" class="sect5"><span class="enumeration_section">20.2.7.3</span>在表空间级别查看压缩摘要</h5>
                     <div>
                        <p>您可以在表空间级别查看压缩摘要信息。</p>
                        <ol>
                           <li class="stepexpand"><span>从<span class="bold">Administration</span>菜单中，选择<span class="bold">Storage</span> ，然后选择<span class="bold">Compression</span> 。</span><div>
                                 <p>Enterprise Manager显示“前100个表空间的压缩摘要”页面。</p>
                              </div>
                           </li>
                           <li class="stepexpand"><span>在“按大小排列的前100个永久表空间”表中，单击要查看其压缩摘要的表空间的行。</span></li>
                           <li class="stepexpand"><span>单击“ <span class="bold">显示压缩详细信息”</span></span><div>
                                 <p>Enterprise Manager显示“表空间中前100个对象的压缩摘要”页面。在此页面中，您可以查看总表空间大小，表空间中压缩对象的总大小，压缩对象总大小与总表空间大小的比率以及表空间中未压缩的对象大小。</p>
                                 <p>您还可以按四种对象类型的每种压缩类型查看压缩的表空间存储大小：表，索引，LOB和DBFS。单击图表中的每种颜色将显示“压缩段的摘要”对话框，其中显示特定对象类型和压缩类型的表空间中按大小排列的前100个段的压缩信息。</p>
                                 <p>最后，您可以查看使用最多表空间存储的前100个段中的每个段的压缩摘要。</p>
                              </div>
                           </li>
                        </ol>
                     </div>
                     <div>
                        <div class="familylinks">
                           <div class="parentlink">
                              <p><strong>父主题：</strong> <a href="managing-tables.html#GUID-C431C787-F714-4A3B-A745-90F6BCD92A1B" title="您可以使用Oracle Enterprise Manager Cloud Control管理表压缩。">使用Enterprise Manager云控制管理表压缩</a></p>
                           </div>
                        </div>
                     </div>
                     
                  </div><a id="ADMIN14303"></a><div class="props_rev_3"><a id="GUID-65490EE0-046A-4F5B-B8B6-F88D3B6CAF48" name="GUID-65490EE0-046A-4F5B-B8B6-F88D3B6CAF48"></a><h5 id="ADMIN-GUID-65490EE0-046A-4F5B-B8B6-F88D3B6CAF48" class="sect5"><span class="enumeration_section">20.2.7.4</span>估算压缩比</h5>
                     <div>
                        <p>您可以运行Compression Advisor来计算特定对象的压缩率。</p>
                        <ol>
                           <li class="stepexpand"><span>从<span class="bold">Administration</span>菜单中，选择<span class="bold">Storage</span> ，然后选择<span class="bold">Compression</span> 。</span><div>
                                 <p>Enterprise Manager显示“前100个表空间的压缩摘要”页面。</p>
                              </div>
                           </li>
                           <li class="stepexpand"><span>从“按大小排列的前100个永久表空间”表中，选择一个表空间，然后单击“ <span class="bold">显示压缩详细信息”</span>以查看所选表空间的压缩详细信息。</span><div>
                                 <p>企业管理器显示“按大小排列的前100个对象”表。</p>
                              </div>
                           </li>
                           <li class="stepexpand"><span>选择一个对象，然后单击该对象的<span class="bold">Estimate Compression Ratio</span> 。</span><div>
                                 <p>企业管理器显示“估计压缩比”对话框。输入以下信息：</p>
                                 <ul style="list-style-type:disc">
                                    <li>
                                       <p>在“输入参数”部分下，输入或选择临时暂存表空间。您可以直接输入名称，也可以从单击图标时显示的列表中进行选择。</p>
                                    </li>
                                    <li>
                                       <p>输入压缩类型。您可以选择“基本”，“高级”，“查询低”，“查询高”，“存档低”或“存档高”。对于HCC压缩类型（查询低，查询高，存档低或存档高）。请确保该表包含至少一百万行。</p>
                                    </li>
                                    <li>
                                       <p>在“计划作业”部分中，输入作业的名称和描述。</p>
                                    </li>
                                    <li>
                                       <p>在“计划”部分中，输入作业信息，例如何时开始，是否重复作业，是否应该有宽限期和持续时间信息。</p>
                                    </li>
                                    <li>
                                       <p>在各自的部分中输入数据库凭据和主机凭据。</p>
                                    </li>
                                    <li>
                                       <p>单击<span class="bold">确定</span> 。</p>
                                    </li>
                                 </ul>
                              </div>
                           </li>
                        </ol>
                        <div class="section">
                           <p>作业立即运行或计划运行，您将返回“表空间中前100个对象的压缩摘要”页面。</p>
                        </div>
                        <!-- class="section" -->
                     </div>
                     <div>
                        <div class="familylinks">
                           <div class="parentlink">
                              <p><strong>父主题：</strong> <a href="managing-tables.html#GUID-C431C787-F714-4A3B-A745-90F6BCD92A1B" title="您可以使用Oracle Enterprise Manager Cloud Control管理表压缩。">使用Enterprise Manager云控制管理表压缩</a></p>
                           </div>
                        </div>
                     </div>
                     
                  </div><a id="ADMIN14304"></a><div class="props_rev_3"><a id="GUID-607E82AF-69CF-4DAC-ABEB-F2F27492FF38" name="GUID-607E82AF-69CF-4DAC-ABEB-F2F27492FF38"></a><h5 id="ADMIN-GUID-607E82AF-69CF-4DAC-ABEB-F2F27492FF38" class="sect5"><span class="enumeration_section">20.2.7.5</span>压缩对象</h5>
                     <div>
                        <p>您可以压缩对象，例如表格。</p>
                        <ol>
                           <li class="stepexpand"><span>从<span class="bold">Administration</span>菜单中，选择<span class="bold">Storage</span> ，然后选择<span class="bold">Compression</span> 。</span><div>
                                 <p>Enterprise Manager显示“前100个表空间的压缩摘要”页面。</p>
                              </div>
                           </li>
                           <li class="stepexpand"><span>从“按大小排列的前100个永久表空间”表中，选择一个表空间，然后单击“ <span class="bold">显示压缩详细信息”</span>以查看所选表空间的“压缩详细信息”。</span><div>
                                 <p>Enterprise Manager显示“表空间中前100个对象的压缩摘要”页面。</p>
                              </div>
                           </li>
                           <li class="stepexpand"><span>选择一个对象（如表），然后单击“ <span class="bold">压缩”</span>以压缩对象。</span></li>
                        </ol>
                     </div>
                     <div>
                        <div class="familylinks">
                           <div class="parentlink">
                              <p><strong>父主题：</strong> <a href="managing-tables.html#GUID-C431C787-F714-4A3B-A745-90F6BCD92A1B" title="您可以使用Oracle Enterprise Manager Cloud Control管理表压缩。">使用Enterprise Manager云控制管理表压缩</a></p>
                           </div>
                        </div>
                     </div>
                     
                  </div><a id="ADMIN14305"></a><div class="props_rev_3"><a id="GUID-E6EB188A-9BE3-4030-BE5F-A6D9E3383432" name="GUID-E6EB188A-9BE3-4030-BE5F-A6D9E3383432"></a><h5 id="ADMIN-GUID-E6EB188A-9BE3-4030-BE5F-A6D9E3383432" class="sect5"><span class="enumeration_section">20.2.7.6</span>查看压缩建议</h5>
                     <div>
                        <p>您可以从Segment Advisor查看压缩建议，并根据它们执行操作。</p>
                        <ol>
                           <li class="stepexpand"><span>从<span class="bold">Administration</span>菜单中，选择<span class="bold">Storage</span> ，然后选择<span class="bold">Compression</span> 。</span><div>
                                 <p>Enterprise Manager显示“前100个表空间的压缩摘要”页面。</p>
                              </div>
                           </li>
                           <li class="stepexpand"><span>在“压缩建议”部分中，单击“带压缩建议的细分”字段中显示的数字。</span><div>
                                 <p>Enterprise Manager显示Segment Advisor Recommendations页面。您可以使用Automatic Segment Advisor作业来检测维护窗口中的段问题。建议源自最近运行的自动和用户计划的段顾问程序作业。</p>
                              </div>
                           </li>
                        </ol>
                     </div>
                     <div>
                        <div class="familylinks">
                           <div class="parentlink">
                              <p><strong>父主题：</strong> <a href="managing-tables.html#GUID-C431C787-F714-4A3B-A745-90F6BCD92A1B" title="您可以使用Oracle Enterprise Manager Cloud Control管理表压缩。">使用Enterprise Manager云控制管理表压缩</a></p>
                           </div>
                        </div>
                     </div>
                     
                  </div><a id="ADMIN14306"></a><div class="props_rev_3"><a id="GUID-3EA670DB-C9F4-493E-9EA9-94C745C92A93" name="GUID-3EA670DB-C9F4-493E-9EA9-94C745C92A93"></a><h5 id="ADMIN-GUID-3EA670DB-C9F4-493E-9EA9-94C745C92A93" class="sect5"><span class="enumeration_section">20.2.7.7</span>启动对象的自动数据优化</h5>
                     <div>
                        <p>您可以在对象上启动自动数据优化。</p>
                        <ol>
                           <li class="stepexpand"><span>从<span class="bold">Administration</span>菜单中，选择<span class="bold">Storage</span> ，然后选择<span class="bold">Compression</span> 。</span><div>
                                 <p>Enterprise Manager显示“前100个表空间的压缩摘要”页面。</p>
                              </div>
                           </li>
                           <li class="stepexpand"><span>从“按大小排列的前100个永久表空间”表中，选择一个表空间，然后单击“ <span class="bold">显示压缩详细信息”</span>以查看所选表空间的压缩详细信息。</span><div>
                                 <p>Enterprise Manager显示“表空间中前100个对象的压缩摘要”页面。</p>
                              </div>
                           </li>
                           <li class="stepexpand"><span>从“按大小排列的前100个对象”表中，选择一个对象，然后单击“ <span class="bold">自动数据压缩”</span> 。</span><div>
                                 <p>Enterprise Manager显示对象的“编辑”页面，您可以在该对象上启动对象的“自动数据优化”。</p>
                              </div>
                           </li>
                        </ol>
                     </div>
                     <div>
                        <div class="familylinks">
                           <div class="parentlink">
                              <p><strong>父主题：</strong> <a href="managing-tables.html#GUID-C431C787-F714-4A3B-A745-90F6BCD92A1B" title="您可以使用Oracle Enterprise Manager Cloud Control管理表压缩。">使用Enterprise Manager云控制管理表压缩</a></p>
                           </div>
                        </div>
                     </div>
                     
                  </div>
               </div><a id="ADMIN14028"></a><a id="ADMIN14029"></a><a id="ADMIN14027"></a><div class="props_rev_3"><a id="GUID-C7B346C7-40F4-41D2-8DF1-81565096E03B" name="GUID-C7B346C7-40F4-41D2-8DF1-81565096E03B"></a><h4 id="ADMIN-GUID-C7B346C7-40F4-41D2-8DF1-81565096E03B" class="sect4"><span class="enumeration_section">20.2.8</span>考虑使用段级和行级压缩分层</h4>
                  <div>
                     <p>通过段级压缩分层，您可以在表中的段级别指定压缩。行级压缩分层使您可以在表中的行级别指定压缩。您可以在同一个表中使用这些组合，以便对表中数据的存储和管理方式进行细粒度控制。</p>
                     <p>  </p>
                     <p>随着用户对段和行的修改随时间而变化，更改它们的压缩级别通常是有益的。例如，某些段和行在添加到数据库后可能会在短时间内被修改，但随着时间的推移，修改可能会变得不那么频繁。</p>
                     <p>您可以使用压缩分层来指定基于规则压缩的段和行。例如，您可以指定使用高级行压缩压缩两周内未修改的行。您还可以指定在六个月内未修改的段使用仓库压缩进行压缩。</p>
                     <p>必须满足以下先决条件才能使用段级和行级压缩分层：</p>
                     <ul style="list-style-type:disc">
                        <li>
                           <p><code class="codeph">HEAT_MAP</code>初始化参数必须设置为<code class="codeph">ON</code> 。</p>
                        </li>
                        <li>
                           <p><code class="codeph">COMPATIBLE</code>初始化参数必须设置为<code class="codeph">12.0.0</code>或更高。
                           </p>
                        </li>
                     </ul>
                     <p>要使用段级压缩分层或行级压缩分层，请执行以下SQL语句之一并包括指定规则的自动数据优化（ADO）策略：</p>
                     <ul style="list-style-type:disc">
                        <li>
                           <p><code class="codeph">CREATE</code> <code class="codeph">TABLE</code></p>
                        </li>
                        <li>
                           <p><code class="codeph">ALTER</code> <code class="codeph">TABLE</code></p>
                        </li>
                     </ul>
                     <div class="example" id="GUID-C7B346C7-40F4-41D2-8DF1-81565096E03B__GUID-01A98DE1-73B0-4A50-BD77-CCD40591DD51">
                        <p class="titleinexample">例20-7行级压缩分层</p>
                        <p>此示例为<code class="codeph">oe.orders</code>表指定行级压缩分层。Oracle数据库在14天后使用仓库（ <code class="codeph">QUERY</code> ）压缩压缩行，无需修改。
                        </p><pre class="oac_no_warn" dir="ltr">ALTER TABLE oe.orders ILM ADD POLICY COLUMN STORE COMPRESS for QUERY ROW 14天后没有修改;</pre></div>
                     <!-- class="example" -->
                     <div class="example" id="GUID-C7B346C7-40F4-41D2-8DF1-81565096E03B__GUID-BBCEB586-0617-45F1-9BC9-288333D38BDE">
                        <p class="titleinexample">例20-8段级压缩分层</p>
                        <p>此示例为<code class="codeph">oe.order_items</code>表指定段级压缩分层。Oracle数据库在六个月后使用归档（ <code class="codeph">ARCHIVE</code> <code class="codeph">HIGH</code> ）压缩压缩段，而不修改段中的任何行，并且没有查询访问段中的任何行。
                        </p><pre class="oac_no_warn" dir="ltr">ALTER TABLE oe.order_items ILM ADD POLICY COLUMN STORE COMPRESS在6个月无法访问后进入存档高位;</pre></div>
                     <!-- class="example" -->
                     <div class="section">
                        <div class="infoboxnote" id="GUID-C7B346C7-40F4-41D2-8DF1-81565096E03B__GUID-9FCB369A-F201-486E-828D-D95CAD2AAB0D">
                           <p class="notep1">注意：</p>
                           <p>这些示例指定了Hybrid Columnar Compression，它依赖于底层存储系统。有关更多信息，请参见<a href="../dblic/Licensing-Information.html#DBLIC2152" target="_blank"><span class="italic">Oracle数据库许可</span></a>信息。
                           </p>
                        </div>
                     </div>
                     <!-- class="section" -->
                  </div>
                  <div>
                     <div class="infoboxnotealso" id="GUID-C7B346C7-40F4-41D2-8DF1-81565096E03B__GUID-F04970D3-8A74-4339-AD97-C0BC5287BCB9">
                        <p class="notep1">也可以看看：</p>
                        <p></p>
                        <ul style="list-style-type:disc">
                           <li>
                              <p><span class="q">“ <a href="managing-tables.html#GUID-ED833867-4B7F-442E-A70C-9C19DAA8F445" title="压缩可节省磁盘空间，减少数据库缓冲区高速缓存中的内存使用，并可显着提高读取期间的查询执行速度。">考虑使用表压缩</a> ”</span>以获取有关不同压缩级别的信息</p>
                           </li>
                           <li>
                              <p><span class="q">“ <a href="managing-memory.html#GUID-7990553D-9199-4AFE-B912-40ADC9C3EDF1" title="Oracle数据库内存（Database In-Memory）是Oracle数据库12c第1版（12.1.0.2）中首次引入的一套功能，可极大地提高实时分析和混合工作负载的性能。">使用Oracle数据库内存提高查询性能</a> ”</span></p>
                           </li>
                           <li>
                              <p>有关段级和行级压缩分层的详细信息<a href="../vldbg/time-based-info.html#VLDBG007" target="_blank"><span class="italic">，请参见“Oracle数据库VLDB和分区指南”</span></a></p>
                           </li>
                        </ul>
                     </div>
                     <div class="familylinks">
                        <div class="parentlink">
                           <p><strong>父主题：</strong> <a href="managing-tables.html#GUID-86F766C5-2344-4790-95E4-4E813A0B21DA" title="遵循指南可以使表的管理更容易，并且可以在创建表时以及加载，更新和查询表数据时提高性能。">管理表的准则</a></p>
                        </div>
                     </div>
                  </div>
                  
               </div><a id="ADMIN13999"></a><div class="props_rev_3"><a id="GUID-0A837830-9FF7-40FF-8540-93B2DF3A37E7" name="GUID-0A837830-9FF7-40FF-8540-93B2DF3A37E7"></a><h4 id="ADMIN-GUID-0A837830-9FF7-40FF-8540-93B2DF3A37E7" class="sect4"><span class="enumeration_section">20.2.9</span>考虑使用属性聚簇表</h4>
                  <div>
                     <p>属性聚簇表是一个堆组织表，它根据用户指定的聚簇指令将数据存储在磁盘上。</p>
                     <div class="infoboxnote" id="GUID-0A837830-9FF7-40FF-8540-93B2DF3A37E7__GUID-634278EA-2F5E-47F9-8E7E-4BCA5CD44520">
                        <p class="notep1">注意：</p>
                        <p>从Oracle Database 12 <span class="italic">c</span>第1版（12.1.0.2）开始提供此功能。
                        </p>
                     </div>
                     <p>指令如下：</p>
                     <ul style="list-style-type:disc">
                        <li>
                           <p><code class="codeph">CLUSTERING</code> <code class="codeph">...</code> <code class="codeph">BY</code> <code class="codeph">LINEAR</code> <code class="codeph">ORDER</code>指令根据指定的列对表中的数据进行排序。
                           </p>
                           <p>当查询限定clustering子句中指定的列的前缀时， <code class="codeph">BY</code> <code class="codeph">LINEAR</code> <code class="codeph">ORDER</code>集群（默认情况下）最好。例如，如果<code class="codeph">sh.sales</code>查询通常指定客户ID或客户ID和产品ID，则可以使用线性列顺序<code class="codeph">cust_id</code> ， <code class="codeph">prod_id</code>在表中对数据进行集群。请注意，指定的列可以位于多个表中。
                           </p>
                        </li>
                        <li>
                           <p><code class="codeph">CLUSTERING</code> <code class="codeph">...</code> <code class="codeph">BY</code> <code class="codeph">INTERLEAVED</code> <code class="codeph">ORDER</code>指令使用特殊算法（一种允许多列I / O减少的z顺序函数）对一个或多个表中的数据进行排序。
                           </p>
                           <p><code class="codeph">BY</code> <code class="codeph">INTERLEAVED</code> <code class="codeph">ORDER</code>集群是最好的，当查询指定各种列的组合。列可以在一个或多个表中。例如，如果<code class="codeph">sh.sales</code>查询在不同的订单中指定不同的维度，则可以根据这些维度中的列对<code class="codeph">sales</code>表中的数据进行聚类。
                           </p>
                        </li>
                     </ul>
                     <p>属性集群可用于以下类型的操作：</p>
                     <ul style="list-style-type:disc">
                        <li>
                           <p>直接路径<code class="codeph">INSERT</code></p>
                           <p>请参阅<span class="q">“ <a href="managing-tables.html#GUID-134D6EB6-219E-4820-AB54-8C60067A8F0F" title="加载大量数据时，可以使用直接路径INSERT来提高加载性能。">使用Direct-Path INSERT提高INSERT性能</a> ”</span> 。
                           </p>
                        </li>
                        <li>
                           <p>在线重新定义</p>
                           <p>请参阅<span class="q">“ <a href="managing-tables.html#GUID-F95114BC-F512-4A1F-B5BD-07DDDE60D934" title="在任何数据库系统中，有时需要修改表的逻辑或物理结构，以提高查询或DML的性能，适应应用程序更改或管理存储。您可以使用DBMS_REDEFINITION包在线重新定义表。">在线重新定义表</a> ”</span> 。
                           </p>
                        </li>
                        <li>
                           <p>数据移动操作，例如<code class="codeph">ALTER</code> <code class="codeph">TABLE</code> <code class="codeph">...</code> <code class="codeph">MOVE</code>操作</p>
                           <p>请参阅<span class="q">“ <a href="managing-tables.html#GUID-3DE67CF4-84C5-4AED-A8A3-B1D28D8EBEF6" title="ALTER TABLE ...假设您在目标表空间中具有适当的配额，MOVE [PARTITION | SUBPARTITION]语句使您可以移动表，分区或子分区以更改任何物理存储属性（如压缩或表空间）。">将表移动到新段或表空间</a> ”</span> 。
                           </p>
                        </li>
                        <li>
                           <p>创建新段的分区维护操作，例如<code class="codeph">ALTER</code> <code class="codeph">TABLE</code> <code class="codeph">...</code> <code class="codeph">MERGE</code> <code class="codeph">PARTITION</code>操作</p>
                           <p>请参见<a href="../vldbg/maintenance-partition-tables-indexes.html#VLDBG1118" target="_blank"><span class="italic">Oracle数据库VLDB和分区指南</span></a> 。
                           </p>
                        </li>
                     </ul>
                     <p>传统DML忽略属性聚类。</p>
                     <p>属性聚簇表具有以下优点：</p>
                     <ul style="list-style-type:disc">
                        <li>
                           <p>当属性聚类与公共索引访问对齐时，表查找可以实现更优化的单块I / O.例如，对于为属性聚类选择的前导列上的索引范围扫描，可以进行优化的I / O.</p>
                        </li>
                        <li>
                           <p>数据排序可为Exadata存储索引和内存中最小/最大修剪提供更优化的修剪。</p>
                        </li>
                        <li>
                           <p>您可以根据其他表中的联接属性对事实表进行聚类。</p>
                        </li>
                        <li>
                           <p>属性聚类可以改善数据压缩，从而间接提高表扫描成本。当相同的值在磁盘上彼此接近时，数据库可以更轻松地压缩它们。</p>
                        </li>
                     </ul>
                     <p>属性集群表通常用于数据仓库环境，但它们在可以从这些优势中受益的任何环境中都很有用。使用<code class="codeph">CREATE</code> <code class="codeph">TABLE</code> SQL语句中的<code class="codeph">CLUSTERING</code>子句创建属性集群表。
                     </p>
                  </div>
                  <div>
                     <div class="infoboxnotealso" id="GUID-0A837830-9FF7-40FF-8540-93B2DF3A37E7__GUID-6B0BA18F-C34F-47ED-BC6C-B6CFEB417AC2">
                        <p class="notep1">也可以看看：</p>
                        <p></p>
                        <ul style="list-style-type:disc">
                           <li>
                              <p>有关属性集群表的概念性信息的<a href="../cncpt/tables-and-table-clusters.html#CNCPT89316" target="_blank"><span class="italic">Oracle数据库概念</span></a></p>
                           </li>
                           <li>
                              <p>有关使用属性聚簇表的信息，请<a href="../dwhsg/attribute-clustering.html#DWHSG8917" target="_blank"><span class="italic">参见“Oracle数据库数据仓库指南”</span></a></p>
                           </li>
                           <li>
                              <p><a href="../sqlrf/CREATE-TABLE.html#SQLRF01402" target="_blank"><span class="italic">Oracle数据库SQL语言参考</span></a></p>
                           </li>
                        </ul>
                     </div>
                     <div class="familylinks">
                        <div class="parentlink">
                           <p><strong>父主题：</strong> <a href="managing-tables.html#GUID-86F766C5-2344-4790-95E4-4E813A0B21DA" title="遵循指南可以使表的管理更容易，并且可以在创建表时以及加载，更新和查询表数据时提高性能。">管理表的准则</a></p>
                        </div>
                     </div>
                  </div>
                  
               </div><a id="ADMIN14000"></a><div class="props_rev_3"><a id="GUID-05AF604F-B923-4256-BA47-B7E0E29386EE" name="GUID-05AF604F-B923-4256-BA47-B7E0E29386EE"></a><h4 id="ADMIN-GUID-05AF604F-B923-4256-BA47-B7E0E29386EE" class="sect4"><span class="enumeration_section">20.2.10</span>考虑使用区域地图</h4>
                  <div>
                     <p>区域是磁盘上的一组连续数据块。区域图跟踪所有单个区域的指定列的最小值和最大值。</p>
                     <div class="infoboxnote" id="GUID-05AF604F-B923-4256-BA47-B7E0E29386EE__GUID-79E7D659-F801-4E4D-BCF3-2973B6534586">
                        <p class="notep1">注意：</p>
                        <p>从Oracle Database 12 <span class="italic">c</span>第1版（12.1.0.2）开始提供此功能。
                        </p>
                     </div>
                     <p>当SQL语句包含存储在区域映射中的列的谓词时，数据库会将谓词值与区域中存储的最小值和最大值进行比较，以确定在SQL执行期间要读取的区域。区域映射的主要优点是表扫描的I / O减少。通过跳过查询结果中不需要的表块来减少I / O.使用<code class="codeph">CREATE</code> <code class="codeph">MATERIALIZED</code> <code class="codeph">ZONEMAP</code> SQL语句创建区域映射。
                     </p>
                     <p>只要在表上指定了属性聚类，就可以在聚簇列上自动创建区域映射。由于聚类，列的最小值和最大值与属性聚簇表中的连续数据块相关，这允许使用关联的区域映射进行更有效的I / O修剪。</p>
                     <div class="infoboxnote" id="GUID-05AF604F-B923-4256-BA47-B7E0E29386EE__GUID-69494561-730A-41F8-8C1D-FA85696138A4">
                        <p class="notep1">注意：</p>
                        <p>区域映射和属性聚簇表可以一起使用或单独使用。</p>
                     </div>
                  </div>
                  <div>
                     <div class="infoboxnotealso" id="GUID-05AF604F-B923-4256-BA47-B7E0E29386EE__GUID-1D585463-1535-4B09-9F7F-70C2901A1840">
                        <p class="notep1">也可以看看：</p>
                        <p></p>
                        <ul style="list-style-type:disc">
                           <li>
                              <p><span class="q">“ <a href="managing-tables.html#GUID-0A837830-9FF7-40FF-8540-93B2DF3A37E7" title="属性聚簇表是一个堆组织表，它根据用户指定的聚簇指令将数据存储在磁盘上。">考虑使用属性集群表</a> ”</span></p>
                           </li>
                           <li>
                              <p>有关区域映射的概念性信息的<a href="../cncpt/tables-and-table-clusters.html#CNCPT89204" target="_blank"><span class="italic">Oracle数据库概念</span></a></p>
                           </li>
                           <li>
                              <p>有关使用区域映射的信息，请参阅<a href="../dwhsg/using-zone-maps.html#DWHSG8935" target="_blank"><span class="italic">“Oracle数据库数据仓库指南”</span></a></p>
                           </li>
                           <li>
                              <p>有关<code class="codeph">CREATE</code> <code class="codeph">MATERIALIZED</code> <code class="codeph">ZONEMAP</code>语句的信息，请<a href="../sqlrf/CREATE-MATERIALIZED-ZONEMAP.html#SQLRF56867" target="_blank"><span class="italic">参见Oracle数据库SQL语言参考</span></a></p>
                           </li>
                        </ul>
                     </div>
                     <div class="familylinks">
                        <div class="parentlink">
                           <p><strong>父主题：</strong> <a href="managing-tables.html#GUID-86F766C5-2344-4790-95E4-4E813A0B21DA" title="遵循指南可以使表的管理更容易，并且可以在创建表时以及加载，更新和查询表数据时提高性能。">管理表的准则</a></p>
                        </div>
                     </div>
                  </div>
                  
               </div><a id="ADMIN14217"></a><div class="props_rev_3"><a id="GUID-8487BAFD-B157-4CBA-8330-2A3088C0A173" name="GUID-8487BAFD-B157-4CBA-8330-2A3088C0A173"></a><h4 id="ADMIN-GUID-8487BAFD-B157-4CBA-8330-2A3088C0A173" class="sect4"><span class="enumeration_section">20.2.11</span>考虑在内存列存储中存储表</h4>
                  <div>
                     <p>内存中列存储是系统全局区域（SGA）的可选部分，用于存储针对快速扫描进行了优化的表，表分区和其他数据库对象的副本。在内存中列存储中，表数据按列而不是SGA中的行存储。</p>
                     <div class="infoboxnote" id="GUID-8487BAFD-B157-4CBA-8330-2A3088C0A173__GUID-2138D64F-2E77-41D4-A428-381A6E1E0208">
                        <p class="notep1">注意：</p>
                        <p>从Oracle Database 12 <span class="italic">c</span>第1版（12.1.0.2）开始提供此功能。
                        </p>
                     </div>
                  </div>
                  <div>
                     <div class="infoboxnotealso" id="GUID-8487BAFD-B157-4CBA-8330-2A3088C0A173__GUID-A1E2A558-BA86-44DA-9FAC-4EED376A70E3">
                        <p class="notep1">也可以看看：</p>
                        <p></p>
                        <ul style="list-style-type:disc">
                           <li>
                              <p><span class="q">“ <a href="managing-memory.html#GUID-7990553D-9199-4AFE-B912-40ADC9C3EDF1" title="Oracle数据库内存（Database In-Memory）是Oracle数据库12c第1版（12.1.0.2）中首次引入的一套功能，可极大地提高实时分析和混合工作负载的性能。">使用Oracle数据库内存提高查询性能</a> ”</span></p>
                           </li>
                           <li>
                              <p><a href="../cncpt/index.html" target="_blank"><span class="italic">Oracle数据库概念</span></a></p>
                           </li>
                        </ul>
                     </div>
                     <div class="familylinks">
                        <div class="parentlink">
                           <p><strong>父主题：</strong> <a href="managing-tables.html#GUID-86F766C5-2344-4790-95E4-4E813A0B21DA" title="遵循指南可以使表的管理更容易，并且可以在创建表时以及加载，更新和查询表数据时提高性能。">管理表的准则</a></p>
                        </div>
                     </div>
                  </div>
                  
               </div>
               <div class="sect3"><a id="GUID-38DBFC2E-FC6C-46E2-A7A1-6FA703F9DC01" name="GUID-38DBFC2E-FC6C-46E2-A7A1-6FA703F9DC01"></a><h4 id="ADMIN-GUID-38DBFC2E-FC6C-46E2-A7A1-6FA703F9DC01" class="sect4"><span class="enumeration_section">20.2.12</span>考虑使用不可见列</h4>
                  <p>您可以使用不可见列来更改表，而不会中断使用该表的应用程序。</p>
                  <div>
                     <ul class="ullinks">
                        <li class="ulchildlink"><a href="managing-tables.html#GUID-D7E99BBA-192C-41E7-9150-62AA188725E4">了解不可见的列</a><br>您可以使单个表列不可见。表的任何通用访问都不会显示表中的不可见列。
                        </li>
                        <li class="ulchildlink"><a href="managing-tables.html#GUID-6AF5669A-5278-473A-A24F-3B3598110E3D">隐形列和列排序</a><br>隐藏列和列排序有特殊注意事项。
                        </li>
                     </ul>
                     <div class="familylinks">
                        <div class="parentlink">
                           <p><strong>父主题：</strong> <a href="managing-tables.html#GUID-86F766C5-2344-4790-95E4-4E813A0B21DA" title="遵循指南可以使表的管理更容易，并且可以在创建表时以及加载，更新和查询表数据时提高性能。">管理表的准则</a></p>
                        </div>
                     </div>
                  </div>
                  <a id="ADMIN13866"></a><div class="props_rev_3"><a id="GUID-D7E99BBA-192C-41E7-9150-62AA188725E4" name="GUID-D7E99BBA-192C-41E7-9150-62AA188725E4"></a><h5 id="ADMIN-GUID-D7E99BBA-192C-41E7-9150-62AA188725E4" class="sect5"><span class="enumeration_section">20.2.12.1</span>了解不可见列</h5>
                     <div>
                        <p>您可以使单个表列不可见。表的任何通用访问都不会显示表中的不可见列。</p>
                        <p>例如，以下操作不会在输出中显示不可见的列：</p>
                        <ul style="list-style-type:disc">
                           <li>
                              <p>SQL中的<code class="codeph">SELECT</code> <code class="codeph">*</code> <code class="codeph">FROM</code>语句</p>
                           </li>
                           <li>
                              <p>SQL * Plus中的<code class="codeph">DESCRIBE</code>命令</p>
                           </li>
                           <li>
                              <p>PL / SQL中的<code class="codeph">%ROWTYPE</code>属性声明</p>
                           </li>
                           <li>
                              <p>Oracle Call Interface（OCI）中的描述</p>
                           </li>
                        </ul>
                        <p>只有在列列表中显式指定不可见列时，才能使用<code class="codeph">SELECT</code>语句显示不可见列的输出。同样，只有在<code class="codeph">INSERT</code>语句的列列表中显式指定不可见列时，才能将值插入不可见列。如果省略<code class="codeph">INSERT</code>语句中的列列表，则该语句只能将值插入可见列。
                        </p>
                        <p>您可以在创建表或向表中添加列时使列不可见，稍后您可以更改表以使同一列可见。您还可以更改表以使可见列不可见。</p>
                        <p>如果要在不中断使用该表的应用程序的情况下对表进行更改，则可以使用不可见列。向表中添加不可见列后，必须访问不可见列的查询和其他操作必须按名称明确引用该列。将应用程序迁移到不可见列的帐户时，可以使不可见列可见。</p>
                        <p>虚拟列可以是不可见的。此外，您可以在创建表时使用不可见列作为分区键。</p>
                        <p>以下限制适用于不可见列：</p>
                        <ul style="list-style-type:disc">
                           <li>
                              <p>以下类型的表不能包含不可见的列：</p>
                              <ul style="list-style-type:disc">
                                 <li>
                                    <p>外部表格</p>
                                 </li>
                                 <li>
                                    <p>群集表</p>
                                 </li>
                                 <li>
                                    <p>临时表</p>
                                 </li>
                              </ul>
                           </li>
                           <li>
                              <p>用户定义类型的属性不可见。</p>
                           </li>
                        </ul>
                        <div class="infoboxnote" id="GUID-D7E99BBA-192C-41E7-9150-62AA188725E4__GUID-4B04478C-5B08-4ED1-9002-503AA2E2BE32">
                           <p class="notep1">注意：</p>
                           <p>不可见列与系统生成的隐藏列不同。您可以使隐藏列可见，但不能使隐藏列可见。</p>
                        </div>
                     </div>
                     <div>
                        <div class="infoboxnotealso" id="GUID-D7E99BBA-192C-41E7-9150-62AA188725E4__GUID-E90D34E6-C343-42AB-ACB0-B245C7080C14">
                           <p class="notep1">也可以看看：</p>
                           <p></p>
                           <ul style="list-style-type:disc">
                              <li>
                                 <p><span class="q">“ <a href="managing-tables.html#GUID-D2802D28-D8B3-4C21-99EC-342DC42F9898" title="使用SQL语句CREATE TABLE创建表。">创建表</a> ”</span></p>
                              </li>
                              <li>
                                 <p><span class="q">“ <a href="managing-tables.html#GUID-3BBC0224-E218-422F-803A-B2FE56906E44" title="要将列添加到现有表，请使用ALTER TABLE ...ADD声明。">添加表格列</a> ”</span></p>
                              </li>
                              <li>
                                 <p><span class="q">“ <a href="managing-tables.html#GUID-93BA4E59-A16F-42B3-9EB5-440532F07AEE" title="使用ALTER TABLE ...用于修改现有列定义的MODIFY语句。您可以修改列数据类型，默认值，列约束，列表达式（对于虚拟列），列加密和可见/不可见属性。">修改现有列定义</a> ”</span></p>
                              </li>
                           </ul>
                        </div>
                        <div class="familylinks">
                           <div class="parentlink">
                              <p><strong>父主题：</strong> <a href="managing-tables.html#GUID-38DBFC2E-FC6C-46E2-A7A1-6FA703F9DC01" title="您可以使用不可见列来更改表，而不会中断使用该表的应用程序。">考虑使用不可见列</a></p>
                           </div>
                        </div>
                     </div>
                     
                  </div><a id="ADMIN13867"></a><div class="props_rev_3"><a id="GUID-6AF5669A-5278-473A-A24F-3B3598110E3D" name="GUID-6AF5669A-5278-473A-A24F-3B3598110E3D"></a><h5 id="ADMIN-GUID-6AF5669A-5278-473A-A24F-3B3598110E3D" class="sect5"><span class="enumeration_section">20.2.12.2</span>不可见列和列排序</h5>
                     <div>
                        <p>隐藏列和列排序有特殊注意事项。</p>
                        <p>数据库通常按照<code class="codeph">CREATE</code> <code class="codeph">TABLE</code>语句中列出的顺序存储列。如果向表中添加新列，则新列将成为表的列顺序中的最后一列。
                        </p>
                        <p>当表包含一个或多个不可见列时，不可见列不包含在表的列顺序中。当访问表中的所有列时，列排序很重要。例如， <code class="codeph">SELECT</code> <code class="codeph">*</code> <code class="codeph">FROM</code>语句显示表的列顺序中的列。由于不可见列不包含在此类表的通用访问中，因此它们不包含在列顺序中。
                        </p>
                        <p>当您显示不可见的列时，该列将作为最后一列包含在表的列顺序中。当您使可见列不可见时，不可见列不会包含在列顺序中，并且可能会重新排列表中可见列的顺序。</p>
                        <p>例如，请考虑下表中包含不可见列：</p><pre class="oac_no_warn" dir="ltr">CREATE TABLE mytable（INT，b INT INVISIBLE，c INT）;</pre><p>由于列<code class="codeph">b</code>不可见，因此该表具有以下列顺序：</p>
                        <div class="tblformal" id="GUID-6AF5669A-5278-473A-A24F-3B3598110E3D__GUID-D7853FA5-B783-4744-BE95-6A721A701473">
                           <table cellpadding="4" cellspacing="0" class="Formal" title="" width="100%" border="1" summary="This table lists each visible column in the table and the column’s column order." frame="hsides" rules="rows">
                              <thead>
                                 <tr align="left" valign="top">
                                    <th align="left" valign="bottom" width="50%" id="d192334e3977">柱</th>
                                    <th align="left" valign="bottom" width="50%" id="d192334e3980">列顺序</th>
                                 </tr>
                              </thead>
                              <tbody>
                                 <tr align="left" valign="top">
                                    <td align="left" valign="top" width="50%" id="d192334e3985" headers="d192334e3977 ">
                                       <p><code class="codeph">一个</code></p>
                                    </td>
                                    <td align="left" valign="top" width="50%" headers="d192334e3985 d192334e3980 ">
                                       <p>1</p>
                                    </td>
                                 </tr>
                                 <tr align="left" valign="top">
                                    <td align="left" valign="top" width="50%" id="d192334e3993" headers="d192334e3977 ">
                                       <p><code class="codeph">C</code></p>
                                    </td>
                                    <td align="left" valign="top" width="50%" headers="d192334e3993 d192334e3980 ">
                                       <p>2</p>
                                    </td>
                                 </tr>
                              </tbody>
                           </table>
                        </div>
                        <!-- class="inftblhruleinformal" -->
                        <p>接下来，使列<code class="codeph">b</code>可见：</p><pre class="oac_no_warn" dir="ltr">ALTER TABLE mytable MODIFY（b VISIBLE）;</pre><p>当列<code class="codeph">b</code>可见时，它将成为表的列顺序中的最后一列。因此，该表具有以下列顺序：</p>
                        <div class="tblformal" id="GUID-6AF5669A-5278-473A-A24F-3B3598110E3D__GUID-8A867ABD-C53C-4B7E-9610-B0E437AB6286">
                           <table cellpadding="4" cellspacing="0" class="Formal" title="" width="100%" border="1" summary="This table lists each visible column in the table and the column’s column order." frame="hsides" rules="rows">
                              <thead>
                                 <tr align="left" valign="top">
                                    <th align="left" valign="bottom" width="50%" id="d192334e4020">柱</th>
                                    <th align="left" valign="bottom" width="50%" id="d192334e4023">列顺序</th>
                                 </tr>
                              </thead>
                              <tbody>
                                 <tr align="left" valign="top">
                                    <td align="left" valign="top" width="50%" id="d192334e4028" headers="d192334e4020 ">
                                       <p><code class="codeph">一个</code></p>
                                    </td>
                                    <td align="left" valign="top" width="50%" headers="d192334e4028 d192334e4023 ">
                                       <p>1</p>
                                    </td>
                                 </tr>
                                 <tr align="left" valign="top">
                                    <td align="left" valign="top" width="50%" id="d192334e4036" headers="d192334e4020 ">
                                       <p><code class="codeph">C</code></p>
                                    </td>
                                    <td align="left" valign="top" width="50%" headers="d192334e4036 d192334e4023 ">
                                       <p>2</p>
                                    </td>
                                 </tr>
                                 <tr align="left" valign="top">
                                    <td align="left" valign="top" width="50%" id="d192334e4044" headers="d192334e4020 ">
                                       <p><code class="codeph">b</code></p>
                                    </td>
                                    <td align="left" valign="top" width="50%" headers="d192334e4044 d192334e4023 ">
                                       <p>3</p>
                                    </td>
                                 </tr>
                              </tbody>
                           </table>
                        </div>
                        <!-- class="inftblhruleinformal" -->
                        <p>考虑另一个示例，说明具有不可见列的表中的列排序。下表不包含任何不可见的列：</p><pre class="oac_no_warn" dir="ltr">CREATE TABLE mytable2（x INT，y INT，z INT）;</pre><p>此表具有以下列顺序：</p>
                        <div class="tblformal" id="GUID-6AF5669A-5278-473A-A24F-3B3598110E3D__GUID-FC544B54-AF28-49C1-B243-1738EA8537EA">
                           <table cellpadding="4" cellspacing="0" class="Formal" title="" width="100%" border="1" summary="This table lists each visible column in the table and the column’s column order." frame="hsides" rules="rows">
                              <thead>
                                 <tr align="left" valign="top">
                                    <th align="left" valign="bottom" width="50%" id="d192334e4066">柱</th>
                                    <th align="left" valign="bottom" width="50%" id="d192334e4069">列顺序</th>
                                 </tr>
                              </thead>
                              <tbody>
                                 <tr align="left" valign="top">
                                    <td align="left" valign="top" width="50%" id="d192334e4074" headers="d192334e4066 ">
                                       <p><code class="codeph">X</code></p>
                                    </td>
                                    <td align="left" valign="top" width="50%" headers="d192334e4074 d192334e4069 ">
                                       <p>1</p>
                                    </td>
                                 </tr>
                                 <tr align="left" valign="top">
                                    <td align="left" valign="top" width="50%" id="d192334e4082" headers="d192334e4066 ">
                                       <p><code class="codeph">ÿ</code></p>
                                    </td>
                                    <td align="left" valign="top" width="50%" headers="d192334e4082 d192334e4069 ">
                                       <p>2</p>
                                    </td>
                                 </tr>
                                 <tr align="left" valign="top">
                                    <td align="left" valign="top" width="50%" id="d192334e4090" headers="d192334e4066 ">
                                       <p><code class="codeph">ž</code></p>
                                    </td>
                                    <td align="left" valign="top" width="50%" headers="d192334e4090 d192334e4069 ">
                                       <p>3</p>
                                    </td>
                                 </tr>
                              </tbody>
                           </table>
                        </div>
                        <!-- class="inftblhruleinformal" -->
                        <p>接下来，使列<code class="codeph">y</code>不可见：</p><pre class="oac_no_warn" dir="ltr">ALTER TABLE mytable2 MODIFY（y INVISIBLE）;</pre><p>当您使列<code class="codeph">y</code>不可见时，列<code class="codeph">y</code>不再包含在表的列顺序中，并且它会更改列<code class="codeph">z</code>的列顺序。因此，该表具有以下列顺序：</p>
                        <div class="tblformal" id="GUID-6AF5669A-5278-473A-A24F-3B3598110E3D__GUID-A5D35751-CD68-4DDE-87D0-F7F235A830A1">
                           <table cellpadding="4" cellspacing="0" class="Formal" title="" width="100%" border="1" summary="This table lists each visible column in the table and the column’s column order." frame="hsides" rules="rows">
                              <thead>
                                 <tr align="left" valign="top">
                                    <th align="left" valign="bottom" width="50%" id="d192334e4123">柱</th>
                                    <th align="left" valign="bottom" width="50%" id="d192334e4126">列顺序</th>
                                 </tr>
                              </thead>
                              <tbody>
                                 <tr align="left" valign="top">
                                    <td align="left" valign="top" width="50%" id="d192334e4131" headers="d192334e4123 ">
                                       <p><code class="codeph">X</code></p>
                                    </td>
                                    <td align="left" valign="top" width="50%" headers="d192334e4131 d192334e4126 ">
                                       <p>1</p>
                                    </td>
                                 </tr>
                                 <tr align="left" valign="top">
                                    <td align="left" valign="top" width="50%" id="d192334e4139" headers="d192334e4123 ">
                                       <p><code class="codeph">ž</code></p>
                                    </td>
                                    <td align="left" valign="top" width="50%" headers="d192334e4139 d192334e4126 ">
                                       <p>2</p>
                                    </td>
                                 </tr>
                              </tbody>
                           </table>
                        </div>
                        <!-- class="inftblhruleinformal" -->
                        <p>使列<code class="codeph">y</code>再次可见：</p><pre class="oac_no_warn" dir="ltr">ALTER TABLE mytable2 MODIFY（y VISIBLE）;</pre><p>列<code class="codeph">y</code>现在是表的列顺序的最后一个：</p>
                        <div class="tblformal" id="GUID-6AF5669A-5278-473A-A24F-3B3598110E3D__GUID-81F47812-EBD7-48F9-A4C1-3B1ECE5418B0">
                           <table cellpadding="4" cellspacing="0" class="Formal" title="" width="100%" border="1" summary="This table lists each visible column in the table and the column’s column order." frame="hsides" rules="rows">
                              <thead>
                                 <tr align="left" valign="top">
                                    <th align="left" valign="bottom" width="50%" id="d192334e4167">柱</th>
                                    <th align="left" valign="bottom" width="50%" id="d192334e4170">列顺序</th>
                                 </tr>
                              </thead>
                              <tbody>
                                 <tr align="left" valign="top">
                                    <td align="left" valign="top" width="50%" id="d192334e4175" headers="d192334e4167 ">
                                       <p><code class="codeph">X</code></p>
                                    </td>
                                    <td align="left" valign="top" width="50%" headers="d192334e4175 d192334e4170 ">
                                       <p>1</p>
                                    </td>
                                 </tr>
                                 <tr align="left" valign="top">
                                    <td align="left" valign="top" width="50%" id="d192334e4183" headers="d192334e4167 ">
                                       <p><code class="codeph">ž</code></p>
                                    </td>
                                    <td align="left" valign="top" width="50%" headers="d192334e4183 d192334e4170 ">
                                       <p>2</p>
                                    </td>
                                 </tr>
                                 <tr align="left" valign="top">
                                    <td align="left" valign="top" width="50%" id="d192334e4191" headers="d192334e4167 ">
                                       <p><code class="codeph">ÿ</code></p>
                                    </td>
                                    <td align="left" valign="top" width="50%" headers="d192334e4191 d192334e4170 ">
                                       <p>3</p>
                                    </td>
                                 </tr>
                              </tbody>
                           </table>
                        </div>
                        <!-- class="inftblhruleinformal" -->
                     </div>
                     <div>
                        <div class="familylinks">
                           <div class="parentlink">
                              <p><strong>父主题：</strong> <a href="managing-tables.html#GUID-38DBFC2E-FC6C-46E2-A7A1-6FA703F9DC01" title="您可以使用不可见列来更改表，而不会中断使用该表的应用程序。">考虑使用不可见列</a></p>
                           </div>
                        </div>
                     </div>
                     
                  </div>
               </div><a id="ADMIN12330"></a><div class="props_rev_3"><a id="GUID-F9D38568-4F95-4053-B21F-F318077C29E5" name="GUID-F9D38568-4F95-4053-B21F-F318077C29E5"></a><h4 id="ADMIN-GUID-F9D38568-4F95-4053-B21F-F318077C29E5" class="sect4"><span class="enumeration_section">20.2.13</span>考虑加密包含敏感数据的列</h4>
                  <div>
                     <p>您可以加密包含敏感数据的各个表列。敏感数据的示例包括社会安全号码，信用卡号码和医疗记录。列加密对您的应用程序是透明的，但有一些限制。</p>
                     <p>虽然加密并不是为了解决所有安全问题，但它确实可以保护您的数据免受试图绕过数据库安全功能并直接通过操作系统文件系统访问数据库文件的用户的攻击。</p>
                     <p>列加密使用Oracle数据库的透明数据加密功能，该功能要求您创建密钥库以存储数据库的主加密密钥。必须先打开密钥库，然后才能创建包含加密列的表，然后才能存储或检索加密数据。当您打开密钥库时，它可供所有会话使用，并且在您明确关闭它或数据库关闭之前它将保持打开状态。</p>
                     <p>透明数据加密支持行业标准加密算法，包括以下类型的加密算法：高级加密标准（AES）和三重数据加密标准（3DES）算法：</p>
                     <ul style="list-style-type:disc">
                        <li>
                           <p>高级加密标准（AES）</p>
                        </li>
                        <li>
                           <p>咏叹调</p>
                        </li>
                        <li>
                           <p>鬼</p>
                        </li>
                        <li>
                           <p>种子</p>
                        </li>
                        <li>
                           <p>三重数据加密标准（3DES）</p>
                        </li>
                     </ul>
                     <p>有关支持的加密算法的详细信息，请参见<a href="../asoag/introduction-to-transparent-data-encryption.html#ASOAG9578" target="_blank"><span><cite>Oracle数据库高级安全性指南</cite></span></a> 。
                     </p>
                     <p>您可以选择在创建表时使用的算法。表中的所有加密列都使用相同的算法。默认值为AES192。加密密钥长度由算法名称暗示。例如，AES128算法使用128位密钥。</p>
                     <p>如果计划加密一个或多个表中的许多列，则可能需要考虑加密整个表空间并将这些表存储在该表空间中。表空间加密也使用透明数据加密功能，但在物理块级加密，可以比加密许多列更好。在表空间级别加密的另一个原因是解决列加密的以下限制：</p>
                     <ul style="list-style-type:disc">
                        <li>
                           <p>列加密不支持某些数据类型，例如对象数据类型。</p>
                        </li>
                        <li>
                           <p>您不能将可传输表空间功能用于包含具有加密列的表的表空间。</p>
                        </li>
                        <li>
                           <p>其他限制，详见“ <a href="../asoag/configuring-transparent-data-encryption.html#ASOAG9518" target="_blank"><span class="italic">Oracle数据库高级安全指南”</span></a> 。
                           </p>
                        </li>
                     </ul>
                  </div>
                  <div>
                     <div class="infoboxnotealso" id="GUID-F9D38568-4F95-4053-B21F-F318077C29E5__GUID-F9DADA0A-D772-43D5-BBB2-AA7A33C02189">
                        <p class="notep1">也可以看看：</p>
                        <ul style="list-style-type:disc">
                           <li>
                              <p>有关透明数据加密的详细信息，请参见<a href="../asoag/asopart1.html#ASOAG600" target="_blank"><span class="italic">Oracle数据库高级安全性指南</span></a></p>
                           </li>
                           <li>
                              <p><a href="../dbimi/configuration-and-administration-tools-overview.html#DBIMI248" target="_blank"><span class="italic">“Oracle数据库企业用户安全性管理员指南”，</span></a>了解有关创建和打开密钥库的说明</p>
                           </li>
                           <li>
                              <p>有关<code class="codeph">CREATE</code> <code class="codeph">TABLE</code>语句的信息，请<a href="../sqlrf/CREATE-TABLE.html#SQLRF01402" target="_blank"><span class="italic">参见Oracle数据库SQL语言参考</span></a></p>
                           </li>
                           <li>
                              <p><a href="../racad/design-and-deployment-techniques.html#RACAD510" target="_blank"><span class="italic">“Oracle Real Application Clusters管理和部署指南”</span></a> ，了解有关在Oracle Real Application Clusters环境中使用密钥库的信息</p>
                           </li>
                        </ul>
                     </div>
                     <div class="familylinks">
                        <div class="parentlink">
                           <p><strong>父主题：</strong> <a href="managing-tables.html#GUID-86F766C5-2344-4790-95E4-4E813A0B21DA" title="遵循指南可以使表的管理更容易，并且可以在创建表时以及加载，更新和查询表数据时提高性能。">管理表的准则</a></p>
                        </div>
                     </div>
                  </div>
                  
               </div><a id="ADMIN13319"></a><div class="props_rev_3"><a id="GUID-2823F411-EC06-49D0-998E-C76CB139794E" name="GUID-2823F411-EC06-49D0-998E-C76CB139794E"></a><h4 id="ADMIN-GUID-2823F411-EC06-49D0-998E-C76CB139794E" class="sect4"><span class="enumeration_section">20.2.14</span>了解延迟段创建</h4>
                  <div>
                     <p>在本地管理的表空间中创建堆组织表时，数据库会延迟创建表段，直到插入第一行。</p>
                     <p>此外，对于表的任何LOB列，作为表创建的一部分隐式创建的任何索引以及随后在表上显式创建的任何索引，都会延迟段创建。</p>
                     <p>这种空间分配方法的优点如下：</p>
                     <ul style="list-style-type:disc">
                        <li>
                           <p>它在安装时创建数百或数千个表的应用程序中节省了大量磁盘空间，其中许多表可能永远不会被填充。</p>
                        </li>
                        <li>
                           <p>它减少了应用程序安装时间</p>
                        </li>
                     </ul>
                     <p>插入第一行时会有一个小的性能损失，因为必须在那时创建新的段。</p>
                     <p>要启用延迟段创建，必须将兼容性设置为<code class="codeph">11.2.0</code>或更高版本。
                     </p>
                     <p><code class="codeph">CREATE</code> <code class="codeph">TABLE</code>语句的新子句是：</p>
                     <ul style="list-style-type:disc">
                        <li>
                           <p><code class="codeph">SEGMENT</code> <code class="codeph">CREATION</code> <code class="codeph">DEFERRED</code> 
                           </p>
                        </li>
                        <li>
                           <p><code class="codeph">SEGMENT</code> <code class="codeph">CREATION</code> <code class="codeph">IMMEDIATE</code></p>
                        </li>
                     </ul>
                     <p>这些子句覆盖<code class="codeph">DEFERRED_SEGMENT_CREATION</code>初始化参数的默认设置<code class="codeph">TRUE</code> ，该参数推迟了段创建。要禁用延迟段创建，请将此参数设置为<code class="codeph">FALSE</code> 。</p>
                     <p>请注意，在创建具有延迟段创建的表时，新表将显示在<code class="codeph">*_TABLES</code>视图中，但在插入第一行之前， <code class="codeph">*_SEGMENTS</code>视图中不会显示任何条目。
                     </p>
                     <p>您可以通过查看验证延迟段创建<code class="codeph">SEGMENT_CREATED</code>列<code class="codeph">*_TABLES</code> ， <code class="codeph">*_INDEXES</code>和<code class="codeph">*_LOBS</code>为分区表视图，并在<code class="codeph">*_TAB_PARTITIONS</code> ， <code class="codeph">*_IND_PARTITIONS,</code>和<code class="codeph">*_LOB_PARTITIONS</code>分区表意见。
                     </p>
                     <div class="infoboxnote" id="GUID-2823F411-EC06-49D0-998E-C76CB139794E__GUID-5D389AE4-4362-4C48-8ABB-8F15422D1343">
                        <p class="notep1">注意：</p>
                        <p>使用这种新的分配方法，必须进行适当的容量规划，以便数据库具有足够的磁盘空间来在填充表时处理段创建。请参阅<span class="q">“ <a href="managing-space-for-schema-objects.html#GUID-BF0E093F-AE77-4A8E-BC17-68AFE4FE6977" title="Oracle数据库提供了两种计划数据库对象容量的方法：使用Cloud Control或DBMS_SPACE PL / SQL包。DBMS_SPACE包中的三个过程使您能够预测新对象的大小并监视现有数据库对象的大小。">数据库对象的容量规划</a> ”</span> 。
                        </p>
                     </div>
                     <p>以下示例创建两个表以演示延迟段创建。第一个表使用<code class="codeph">SEGMENT</code> <code class="codeph">CREATION</code> <code class="codeph">DEFERRED</code>子句。最初没有为它创建任何段。第二个表使用<code class="codeph">SEGMENT</code> <code class="codeph">CREATION</code> <code class="codeph">IMMEDIATE</code>子句，因此会立即为其创建段。
                     </p><pre class="oac_no_warn" dir="ltr">CREATE TABLE part_time_employees（empno NUMBER（8），name VARCHAR2（30），hourly_rate NUMBER（7,2））SEGMENT CREATION DEFERRED; CREATE TABLE hourly_employees（empno NUMBER（8），name VARCHAR2（30），hourly_rate NUMBER（7,2））SEGMENT CREATION IMYEDIATE PARTITION BY RANGE（empno）（PARTITION empno_to_100值不超过（100），PARTITION empno_to_200值少于（200） ））;</pre><p>对下面的查询<code class="codeph">USER_SEGMENTS</code>返回两行<code class="codeph">HOURLY_EMPLOYEES</code> ，每一个分区，但返回任何行<code class="codeph">PART_TIME_EMPLOYEES because</code>段创建该表被推迟。
                     </p><pre class="oac_no_warn" dir="ltr">SELECT segment_name，partition_name FROM user_segments; SEGMENT_NAME PARTITION_NAME -------------------- ---------------------------- -  HOURLY_EMPLOYEES EMPNO_TO_100 HOURLY_EMPLOYEES EMPNO_TO_200</pre><p><code class="codeph">USER_TABLES</code>视图显示<code class="codeph">PART_TIME_EMPLOYEES</code>没有段：</p><pre class="oac_no_warn" dir="ltr">SELECT table_name，segment_created FROM user_tables;</pre><pre class="oac_no_warn" dir="ltr">TABLE_NAME SEGMENT_CREATED ------------------------------ ------------------ ---------------------- PART_TIME_EMPLOYEES NO HOURLY_EMPLOYEES N / A.</pre><p>对于已分区的<code class="codeph">HOURLY_EMPLOYEES</code>表， <code class="codeph">segment_created</code> <code class="codeph">HOURLY_EMPLOYEES</code> <code class="codeph">N/A</code>因为<code class="codeph">USER_TABLES</code>视图不提供分区表的信息。它可以从<code class="codeph">USER_TAB_PARTITIONS</code>视图中获得，如下所示。
                     </p><pre class="oac_no_warn" dir="ltr">SELECT table_name，segment_created，partition_name FROM user_tab_partitions; TABLE_NAME SEGMENT_CREATED PARTITION_NAME -------------------- -------------------- ------- ----------------------- HOURLY_EMPLOYEES YES EMPNO_TO_100 HOURLY_EMPLOYEES YES EMPNO_TO_200</pre><p>以下语句将员工添加到这些表中。</p><pre class="oac_no_warn" dir="ltr">INSERT INTO hourly_employees VALUES（99，'FRose'，20.00）; INSERT INTO hourly_employees VALUES（150，'LRose'，25.00）; INSERT INTO part_time_employees VALUES（50，'KReilly'，10.00）;</pre><p>重复与之前相同的<code class="codeph">SELECT</code>语句表明<code class="codeph">PART_TIME_EMPLOYEES</code>现在有一个段，因为插入了行数据。<code class="codeph">HOURLY_EMPLOYEES</code>仍然像以前一样。
                     </p><pre class="oac_no_warn" dir="ltr">SELECT segment_name，partition_name FROM user_segments; SEGMENT_NAME PARTITION_NAME -------------------- ---------------------------- -  PART_TIME_EMPLOYEES HOURLY_EMPLOYEES EMPNO_TO_100 HOURLY_EMPLOYEES EMPNO_TO_200</pre><p></p><pre class="oac_no_warn" dir="ltr">SELECT table_name，segment_created FROM user_tables; TABLE_NAME SEGMENT_CREATED -------------------- -------------------- PART_TIME_EMPLOYEES YES HOURLY_EMPLOYEES N / A</pre><p><code class="codeph">USER_TAB_PARTITIONS</code>视图不会更改。
                     </p>
                  </div>
                  <div>
                     <div class="infoboxnotealso" id="GUID-2823F411-EC06-49D0-998E-C76CB139794E__GUID-444CD276-8A17-4A3B-904D-629A0A64EFBB">
                        <p class="notep1">也可以看看：</p>
                        <p>有关延迟段创建的注释和限制的<a href="../sqlrf/CREATE-TABLE.html#SQLRF54479" target="_blank"><span class="italic">Oracle数据库SQL语言参考</span></a></p>
                     </div>
                     <div class="familylinks">
                        <div class="parentlink">
                           <p><strong>父主题：</strong> <a href="managing-tables.html#GUID-86F766C5-2344-4790-95E4-4E813A0B21DA" title="遵循指南可以使表的管理更容易，并且可以在创建表时以及加载，更新和查询表数据时提高性能。">管理表的准则</a></p>
                        </div>
                     </div>
                  </div>
                  
               </div><a id="ADMIN13460"></a><div class="props_rev_3"><a id="GUID-BFDCA073-3AEC-4399-A95A-C4888120B958" name="GUID-BFDCA073-3AEC-4399-A95A-C4888120B958"></a><h4 id="ADMIN-GUID-BFDCA073-3AEC-4399-A95A-C4888120B958" class="sect4"><span class="enumeration_section">20.2.15</span>实现细分</h4>
                  <div>
                     <p><code class="codeph">DBMS_SPACE_ADMIN</code>程序包包含<code class="codeph">MATERIALIZE_DEFERRED_SEGMENTS()</code>过程，该过程使您能够实现为启用了延迟段创建而创建的表，表分区和从属对象的段。
                     </p>
                     <div class="section">
                        <p>您可以根据需要添加段，而不是从您需要的更多开始并不必要地使用数据库资源。</p>
                        <p>以下示例为<code class="codeph">HR</code>模式中的<code class="codeph">EMPLOYEES</code>表实现了段。
                        </p><pre class="oac_no_warn" dir="ltr">BEGIN DBMS_SPACE_ADMIN.MATERIALIZE_DEFERRED_SEGMENTS（schema_name =&gt;'HR'，table_name =&gt;'EMPLOYEES'）;结束;</pre></div>
                     <!-- class="section" -->
                  </div>
                  <div>
                     <div class="infoboxnotealso" id="GUID-BFDCA073-3AEC-4399-A95A-C4888120B958__GUID-4132CE93-A88A-43C8-B1B6-ACB525AF657A">
                        <p class="notep1">也可以看看：</p>
                        <p>有关此过程的详细信息，请<a href="../arpls/DBMS_SPACE_ADMIN.html#ARPLS73095" target="_blank"><span class="italic">参见Oracle Database PL / SQL包和类型参考</span></a></p>
                     </div>
                     <div class="familylinks">
                        <div class="parentlink">
                           <p><strong>父主题：</strong> <a href="managing-tables.html#GUID-86F766C5-2344-4790-95E4-4E813A0B21DA" title="遵循指南可以使表的管理更容易，并且可以在创建表时以及加载，更新和查询表数据时提高性能。">管理表的准则</a></p>
                        </div>
                     </div>
                  </div>
                  
               </div><a id="ADMIN11631"></a><div class="props_rev_3"><a id="GUID-A9EDF4CF-FFBA-4D09-A4BB-621BE977E4FC" name="GUID-A9EDF4CF-FFBA-4D09-A4BB-621BE977E4FC"></a><h4 id="ADMIN-GUID-A9EDF4CF-FFBA-4D09-A4BB-621BE977E4FC" class="sect4"><span class="enumeration_section">20.2.16相应</span>估算表格大小和计划</h4>
                  <div>
                     <p>在创建表之前估计表的大小。最好将此作为数据库规划的一部分。了解数据库表的大小和用途是数据库规划的重要部分。</p>
                     <p>您可以使用表的组合估计大小以及索引，撤消空间和重做日志文件的估计值来确定保存目标数据库所需的磁盘空间量。根据这些估算，您可以进行正确的硬件购买。</p>
                     <p>您可以使用单个表的估计大小和增长率来更好地确定最适合该表的表空间及其基础数据文件的属性。这使您可以更轻松地管理表磁盘空间并提高使用该表的应用程序的I / O性能。</p>
                  </div>
                  <div>
                     <div class="infoboxnotealso" id="GUID-A9EDF4CF-FFBA-4D09-A4BB-621BE977E4FC__GUID-DA0EFCD9-9030-459C-B64E-8AD076A57326">
                        <p class="notep1">也可以看看：</p>
                        <p><span class="q">“ <a href="managing-space-for-schema-objects.html#GUID-BF0E093F-AE77-4A8E-BC17-68AFE4FE6977" title="Oracle数据库提供了两种计划数据库对象容量的方法：使用Cloud Control或DBMS_SPACE PL / SQL包。DBMS_SPACE包中的三个过程使您能够预测新对象的大小并监视现有数据库对象的大小。">数据库对象的容量规划</a> ”</span></p>
                     </div>
                     <div class="familylinks">
                        <div class="parentlink">
                           <p><strong>父主题：</strong> <a href="managing-tables.html#GUID-86F766C5-2344-4790-95E4-4E813A0B21DA" title="遵循指南可以使表的管理更容易，并且可以在创建表时以及加载，更新和查询表数据时提高性能。">管理表的准则</a></p>
                        </div>
                     </div>
                  </div>
                  
               </div><a id="ADMIN11632"></a><div class="props_rev_3"><a id="GUID-66B37910-379C-4FB1-81B1-D2671FDCDE46" name="GUID-66B37910-379C-4FB1-81B1-D2671FDCDE46"></a><h4 id="ADMIN-GUID-66B37910-379C-4FB1-81B1-D2671FDCDE46" class="sect4"><span class="enumeration_section">20.2.17</span>创建表时要考虑的限制</h4>
                  <div>
                     <p>创建表时需要考虑一些限制。</p>
                     <p>以下是一些可能影响您的表格规划和使用的限制：</p>
                     <ul style="list-style-type:disc">
                        <li>
                           <p>包含对象类型的表无法导入到Oracle8之前的数据库中。</p>
                        </li>
                        <li>
                           <p>您不能将导出的表合并到不同模式中具有相同名称的预先存在的表中。</p>
                        </li>
                        <li>
                           <p>当原始数据仍存在于数据库中时，您无法将类型和范围表移动到其他模式。</p>
                        </li>
                        <li>
                           <p>Oracle数据库对表（或对象类型的属性）可以具有的列总数有限制。有关此限制，请参阅<a href="https://www.oracle.com/pls/topic/lookup?ctx=en/database/oracle/oracle-database/19/admin&amp;id=REFRN004" target="_blank"><span class="italic">Oracle数据库参考</span></a> 。
                           </p>
                           <p>此外，当您创建包含用户定义的类型数据的表时，数据库会将用户定义类型的列映射到关系列，以存储用户定义的类型数据。这会导致创建其他关系列。这会导致“隐藏”关系列在<code class="codeph">DESCRIBE</code>表语句中不可见，并且不会被<code class="codeph">SELECT *</code>语句返回。因此，当您创建对象表或具有<code class="codeph">REF</code> ，varray，嵌套表或对象类型列的关系表时，请注意数据库实际为表创建的列总数可能多于您指定的列数。
                           </p>
                           <div class="infoboxnotealso" id="GUID-66B37910-379C-4FB1-81B1-D2671FDCDE46__GUID-4749E150-80E2-4336-B33D-30079597E370">
                              <p class="notep1">也可以看看：</p>
                              <p>有关用户定义类型的更多信息，请<a href="https://www.oracle.com/pls/topic/lookup?ctx=en/database/oracle/oracle-database/19/admin&amp;id=ADOBJ001" target="_blank"><span class="italic">参见“Oracle数据库对象关系开发人员指南”</span></a></p>
                           </div>
                        </li>
                     </ul>
                  </div>
                  <div>
                     <div class="familylinks">
                        <div class="parentlink">
                           <p><strong>父主题：</strong> <a href="managing-tables.html#GUID-86F766C5-2344-4790-95E4-4E813A0B21DA" title="遵循指南可以使表的管理更容易，并且可以在创建表时以及加载，更新和查询表数据时提高性能。">管理表的准则</a></p>
                        </div>
                     </div>
                  </div>
                  
               </div>
            </div><a id="ADMIN01503"></a><div class="props_rev_3"><a id="GUID-D2802D28-D8B3-4C21-99EC-342DC42F9898" name="GUID-D2802D28-D8B3-4C21-99EC-342DC42F9898"></a><h3 id="ADMIN-GUID-D2802D28-D8B3-4C21-99EC-342DC42F9898" class="sect3"><span class="enumeration_section">20.3</span>创建表</h3>
               <div>
                  <p>使用SQL语句<code class="codeph">CREATE TABLE</code> 。</p>
                  <p>要在架构中创建新表，您必须具有<code class="codeph">CREATE TABLE</code>系统特权。要在另一个用户的模式中创建表，您必须具有<code class="codeph">CREATE ANY TABLE</code>系统特权。此外，表的所有者必须具有包含该表的表空间的配额，或者<code class="codeph">UNLIMITED TABLESPACE</code>系统特权。
                  </p>
               </div>
               <div>
                  <ul class="ullinks">
                     <li class="ulchildlink"><a href="managing-tables.html#GUID-F772A328-C752-4230-9EB1-1E07F28F03C4">示例：创建表</a><br>一个示例说明了创建表。
                     </li>
                     <li class="ulchildlink"><a href="managing-tables.html#GUID-6EB347F0-64BA-4B15-8182-41BA7D5A876F">创建临时表</a><br>临时表在要缓冲（暂时保留）结果集的应用程序中很有用，可能是因为它是通过运行多个DML操作构造的。您可以创建全局临时表或私有临时表。
                     </li>
                     <li class="ulchildlink"><a href="managing-tables.html#GUID-2C1E31D1-C0EE-48D6-8C11-31AE9AFF5440">并行化表创建</a><br>指定<code class="codeph">AS SELECT</code>子句以创建表并使用其他表中的数据填充表时，可以使用并行执行。
                     </li>
                  </ul>
                  <div class="infoboxnotealso" id="GUID-D2802D28-D8B3-4C21-99EC-342DC42F9898__GUID-5A300375-8E2E-4513-9EC7-976938BE168F">
                     <p class="notep1">也可以看看：</p>
                     <p><a href="https://www.oracle.com/pls/topic/lookup?ctx=en/database/oracle/oracle-database/19/admin&amp;id=SQLRF01402" target="_blank"><span class="italic">Oracle数据库SQL语言参考，</span></a>了解本章中讨论的<code class="codeph">CREATE TABLE</code>和其他SQL语句的确切语法</p>
                  </div>
                  <div class="familylinks">
                     <div class="parentlink">
                        <p><strong>父主题：</strong> <a href="managing-tables.html#GUID-707B02F5-E589-4C20-8E2E-5ED4F7888702" title="管理表包括创建表，加载表，更改表和删除表等任务。">管理表</a></p>
                     </div>
                  </div>
               </div>
               <a id="ADMIN11004"></a><div class="props_rev_3"><a id="GUID-F772A328-C752-4230-9EB1-1E07F28F03C4" name="GUID-F772A328-C752-4230-9EB1-1E07F28F03C4"></a><h4 id="ADMIN-GUID-F772A328-C752-4230-9EB1-1E07F28F03C4" class="sect4"><span class="enumeration_section">20.3.1</span>示例：创建表</h4>
                  <div>
                     <p>一个示例说明了创建表。</p>
                     <div class="section">
                        <p>发出以下语句时，在<code class="codeph">hr</code>模式中创建一个名为<code class="codeph">admin_emp</code>的表，并将其存储在<code class="codeph">admin_tbs</code>表空间中：</p>
                        <div class="infoboxnote" id="GUID-F772A328-C752-4230-9EB1-1E07F28F03C4__GUID-C69FB35C-9EA1-444F-ABC9-473E0743A3F5">
                           <p class="notep1">实时SQL：</p>
                           <p>在Oracle Live SQL上查看并运行Oracle Live SQL的相关示例<a href="https://livesql.oracle.com/apex/livesql/docs/admin/managing-tables/create-modify.html" target="_blank"><span class="italic">：创建和修改表</span></a> 。
                           </p>
                        </div><pre class="oac_no_warn" dir="ltr">CREATE TABLE hr.admin_emp（empno NUMBER（5）PRIMARY KEY，ename VARCHAR2（15）NOT NULL，ssn NUMBER（9）ENCRYPT使用'AES256'，作业VARCHAR2（10），mgr NUMBER（5），雇用DATE DEFAULT（sysdate） ），照片BLOB，sal NUMBER（7,2），hrly_rate NUMBER（7,2）生成始终为（sal / 2080），comm NUMBER（7,2），deptno NUMBER（3）NOT NULL CONSTRAINT admin_dept_fkey REFERENCES hr.departments （department_id），注释VARCHAR2（32767），状态VARCHAR2（10）INVISIBLE）TABLESPACE admin_tbs存储（初始50K）;表上的评论hr.admin_emp IS'增强的员工表';</pre><p>请注意以下关于此示例：</p>
                     </div>
                     <!-- class="section" -->
                     <div class="section">
                        <ul style="list-style-type:disc">
                           <li>
                              <p>完整性约束在表的几列中定义。</p>
                           </li>
                           <li>
                              <p><code class="codeph">STORAGE</code>子句指定第一个范围的大小。有关此子句的详细信息，请参见<a href="https://www.oracle.com/pls/topic/lookup?ctx=en/database/oracle/oracle-database/19/admin&amp;id=SQLRF30013" target="_blank"><span class="italic">Oracle数据库SQL语言参考</span></a> 。
                              </p>
                           </li>
                           <li>
                              <p>通过Oracle数据库的透明数据加密功能，在一列（ <code class="codeph">ssn</code> ）上定义加密。因此，必须打开密钥库才能使此<code class="codeph">CREATE</code> <code class="codeph">TABLE</code>语句成功。
                              </p>
                           </li>
                           <li>
                              <p><code class="codeph">photo</code>列的数据类型为<code class="codeph">BLOB</code> ，它是被调用的数据类型集的成员<a id="d192334e4995" class="indexterm-anchor"></a><a id="d192334e4997" class="indexterm-anchor"></a><a id="d192334e4999" class="indexterm-anchor"></a>大对象（LOB）。LOB用于存储半结构化数据（例如XML树）和非结构化数据（例如彩色图像中的比特流）。
                              </p>
                           </li>
                           <li>
                              <p>一列定义为虚拟列（ <code class="codeph">hrly_rate</code> ）。此列计算员工的小时费率，即年薪除以2,080。有关虚拟列规则的讨论，请参见<a href="../sqlrf/CREATE-TABLE.html#SQLRF54465" target="_blank"><span class="italic">Oracle数据库SQL语言参考</span></a> 。
                              </p>
                           </li>
                           <li>
                              <p><code class="codeph">comments</code>列是<code class="codeph">VARCHAR2</code>列，大于4000字节。从Oracle Database 12 <span class="italic">c</span>开始， <code class="codeph">VARCHAR2</code> ， <code class="codeph">NVARCHAR2</code>和<code class="codeph">RAW</code>数据类型的最大大小增加到32767字节。
                              </p>
                              <p>要使用扩展数据类型，请将<code class="codeph">MAX_STRING_SIZE</code>初始化参数设置为<code class="codeph">EXTENDED</code> 。有关设置此参数的信息，请参见<a href="https://www.oracle.com/pls/topic/lookup?ctx=en/database/oracle/oracle-database/19/admin&amp;id=REFRN10321" target="_blank"><span class="italic">Oracle数据库参考</span></a> 。
                              </p>
                           </li>
                           <li>
                              <p><code class="codeph">status</code>列不可见。
                              </p>
                           </li>
                           <li>
                              <p><code class="codeph">COMMENT</code>语句用于存储表的注释。您查询<code class="codeph">*_TAB_COMMENTS</code>数据字典视图以检索此类注释。有关更多信息，请参见<a href="https://www.oracle.com/pls/topic/lookup?ctx=en/database/oracle/oracle-database/19/admin&amp;id=SQLRF01109" target="_blank"><span class="italic">Oracle数据库SQL语言参考</span></a> 。
                              </p>
                           </li>
                        </ul>
                     </div>
                     <!-- class="section" -->
                  </div>
                  <div>
                     <div class="infoboxnotealso" id="GUID-F772A328-C752-4230-9EB1-1E07F28F03C4__GUID-D871C45D-6CEE-4747-AE6A-05C01069D01C">
                        <p class="notep1">也可以看看：</p>
                        <p></p>
                        <ul style="list-style-type:disc">
                           <li>
                              <p><a href="https://www.oracle.com/pls/topic/lookup?ctx=en/database/oracle/oracle-database/19/admin&amp;id=SQLRF0021" target="_blank"><span class="italic">“Oracle数据库SQL语言参考”</span></a> ，其中提供了可以为表列指定的数据类型的说明</p>
                           </li>
                           <li>
                              <p><span class="q">“ <a href="managing-schema-objects.html#GUID-A6587008-A4F2-4333-A47C-F1AB0B4538FA" title="完整性约束是限制表中一列或多列的值的规则。约束子句可以出现在CREATE TABLE或ALTER TABLE语句中，并标识受约束影响的一列或多列，并标识约束的条件。">管理诚信约束</a> ”</span></p>
                           </li>
                           <li>
                              <p><span class="q">“ <a href="managing-tables.html#GUID-D7E99BBA-192C-41E7-9150-62AA188725E4" title="您可以使单个表列不可见。表的任何通用访问都不会显示表中的不可见列。">了解不可见的列</a> ”</span></p>
                           </li>
                           <li>
                              <p>有关透明数据加密的信息，请参见<a href="https://www.oracle.com/pls/topic/lookup?ctx=en/database/oracle/oracle-database/19/admin&amp;id=ASOAG600" target="_blank"><span class="italic">“Oracle数据库高级安全指南</span></a></p>
                           </li>
                           <li>
                              <p>有关LOB的更多信息，请参见<a href="https://www.oracle.com/pls/topic/lookup?ctx=en/database/oracle/oracle-database/19/admin&amp;id=ADLOB" target="_blank"><span class="italic">Oracle Database SecureFiles和Large Objects Developer's Guide</span></a> 。
                              </p>
                           </li>
                        </ul>
                     </div>
                     <div class="familylinks">
                        <div class="parentlink">
                           <p><strong>父主题：</strong> <a href="managing-tables.html#GUID-D2802D28-D8B3-4C21-99EC-342DC42F9898" title="使用SQL语句CREATE TABLE创建表。">创建表</a></p>
                        </div>
                     </div>
                  </div>
                  
               </div>
               <div class="sect3"><a id="GUID-6EB347F0-64BA-4B15-8182-41BA7D5A876F" name="GUID-6EB347F0-64BA-4B15-8182-41BA7D5A876F"></a><h4 id="ADMIN-GUID-6EB347F0-64BA-4B15-8182-41BA7D5A876F" class="sect4"><span class="enumeration_section">20.3.2</span>创建临时表</h4>
                  <div>
                     <p>临时表在要缓冲（暂时保留）结果集的应用程序中很有用，可能是因为它是通过运行多个DML操作构造的。您可以创建全局临时表或私有临时表。</p>
                  </div>
                  <div>
                     <ul class="ullinks">
                        <li class="ulchildlink"><a href="managing-tables.html#GUID-23B23DCF-7482-4585-9C63-AC073C5DE224">临时表概述</a><br><strong class="term">临时表</strong>包含仅在事务或会话期间存在的数据。
                        </li>
                        <li class="ulchildlink"><a href="managing-tables.html#GUID-8A4441BC-9B9E-46AA-9CEE-D825440F34C7">创建临时表时的注意事项</a><br>创建临时表时请注意一些注意事项。
                        </li>
                        <li class="ulchildlink"><a href="managing-tables.html#GUID-095B7DA3-010E-4B9A-9F07-5DDD00D53824">创建全局临时表</a><br>全局临时表是永久数据库对象，存储在磁盘上并对连接到数据库的所有会话可见。
                        </li>
                        <li class="ulchildlink"><a href="managing-tables.html#GUID-9B373086-0760-4B18-9688-BACFF07EC74B">创建私有临时表</a><br>专用临时表是在事务或会话结束时删除的临时数据库对象。私有临时表存储在内存中，每个临时表仅对创建它的会话可见。
                        </li>
                     </ul>
                     <div class="familylinks">
                        <div class="parentlink">
                           <p><strong>父主题：</strong> <a href="managing-tables.html#GUID-D2802D28-D8B3-4C21-99EC-342DC42F9898" title="使用SQL语句CREATE TABLE创建表。">创建表</a></p>
                        </div>
                     </div>
                  </div>
                  
                  <div class="props_rev_3"><a id="GUID-23B23DCF-7482-4585-9C63-AC073C5DE224" name="GUID-23B23DCF-7482-4585-9C63-AC073C5DE224"></a><h5 id="ADMIN-GUID-23B23DCF-7482-4585-9C63-AC073C5DE224" class="sect5"><span class="enumeration_section">20.3.2.1</span>临时表概述</h5>
                     <div>
                        <p><strong class="term">临时表</strong>包含仅在事务或会话期间存在的数据。
                        </p>
                        <p>临时表中的数据对会话是私有的。每个会话只能查看和修改自己的数据。</p>
                        <p>您可以创建<strong class="term">全局临时表</strong>或<strong class="term">私有临时表</strong> 。下表显示了它们之间的本质区别。
                        </p>
                        <div class="tblformal" id="GUID-23B23DCF-7482-4585-9C63-AC073C5DE224__GUID-19E8339E-64AE-4BD3-93A3-699A416FC5DB">
                           <p class="titleintable">表20-3临时表特性</p>
                           <table cellpadding="4" cellspacing="0" class="Formal" title="临时表特征" border="1" summary="Describes the characteristic of global and private temporary tables" frame="hsides" rules="rows">
                              <thead>
                                 <tr align="left" valign="top">
                                    <th align="left" valign="bottom" id="d192334e5269">特性</th>
                                    <th align="left" valign="bottom" id="d192334e5271">全球</th>
                                    <th align="left" valign="bottom" id="d192334e5273">私人的</th>
                                 </tr>
                              </thead>
                              <tbody>
                                 <tr align="left" valign="top">
                                    <td align="left" valign="top" id="d192334e5277" headers="d192334e5269 ">命名规则</td>
                                    <td align="left" valign="top" headers="d192334e5277 d192334e5271 ">与永久表相同</td>
                                    <td align="left" valign="top" headers="d192334e5277 d192334e5273 ">必须以<code class="codeph">ORA$PTT_</code>为前缀</td>
                                 </tr>
                                 <tr align="left" valign="top">
                                    <td align="left" valign="top" id="d192334e5286" headers="d192334e5269 ">表定义的可见性</td>
                                    <td align="left" valign="top" headers="d192334e5286 d192334e5271 ">所有会议</td>
                                    <td align="left" valign="top" headers="d192334e5286 d192334e5273 ">只有创建表的会话</td>
                                 </tr>
                                 <tr align="left" valign="top">
                                    <td align="left" valign="top" id="d192334e5293" headers="d192334e5269 ">存储表定义</td>
                                    <td align="left" valign="top" headers="d192334e5293 d192334e5271 ">磁盘</td>
                                    <td align="left" valign="top" headers="d192334e5293 d192334e5273 ">只有记忆</td>
                                 </tr>
                                 <tr align="left" valign="top">
                                    <td align="left" valign="top" id="d192334e5300" headers="d192334e5269 ">类型</td>
                                    <td align="left" valign="top" headers="d192334e5300 d192334e5271 ">特定于事务（ <code class="codeph">ON COMMIT DELETE ROWS</code> ）或特定于会话（ <code class="codeph">ON COMMIT PRESERVE ROWS</code> ）</td>
                                    <td align="left" valign="top" headers="d192334e5300 d192334e5273 ">特定于交易（ <code class="codeph">ON COMMIT DROP DEFINITION</code> ）或特定于会话（ <code class="codeph">ON COMMIT PRESERVE DEFINITION</code> ）</td>
                                 </tr>
                              </tbody>
                           </table>
                        </div>
                        <!-- class="inftblhruleinformal" -->
                        <p>对于某些类型的查询，数据库会自动创建第三种类型的临时表，称为<strong class="term">游标持续时间临时表</strong> 。
                        </p>
                     </div>
                     <div>
                        <div class="infoboxnotealso" id="GUID-23B23DCF-7482-4585-9C63-AC073C5DE224__GUID-BA3205F9-E55D-4108-9DFB-805A32A31B14">
                           <p class="notep1">也可以看看：</p>
                           <p><a href="https://www.oracle.com/pls/topic/lookup?ctx=en/database/oracle/oracle-database/19/admin&amp;id=TGSQL-GUID-C1AE164B-E99F-418A-9B2A-1ADB036048DF" target="_blank"><span><cite>Oracle数据库SQL调优指南</cite></span></a> ，了解有关游标持续时间临时表的更多信息</p>
                        </div>
                        <div class="familylinks">
                           <div class="parentlink">
                              <p><strong>父主题：</strong> <a href="managing-tables.html#GUID-6EB347F0-64BA-4B15-8182-41BA7D5A876F" title="临时表在要缓冲（暂时保留）结果集的应用程序中很有用，可能是因为它是通过运行多个DML操作构造的。您可以创建全局临时表或私有临时表。">创建临时表</a></p>
                           </div>
                        </div>
                     </div>
                     
                  </div>
                  <div class="sect4"><a id="GUID-8A4441BC-9B9E-46AA-9CEE-D825440F34C7" name="GUID-8A4441BC-9B9E-46AA-9CEE-D825440F34C7"></a><h5 id="ADMIN-GUID-8A4441BC-9B9E-46AA-9CEE-D825440F34C7" class="sect5"><span class="enumeration_section">20.3.2.2</span>创建临时表时的注意事项</h5>
                     <div>
                        <p>创建临时表时请注意一些注意事项。</p>
                        <p>与永久表不同，临时表在创建时不会自动分配段。而是在执行第一个<code class="codeph">INSERT</code> （或<code class="codeph">CREATE</code> <code class="codeph">TABLE</code> <code class="codeph">AS</code> <code class="codeph">SELECT</code> ）时分配段。因此，如果在第一次<code class="codeph">INSERT</code>之前执行<code class="codeph">SELECT</code> ， <code class="codeph">UPDATE</code>或<code class="codeph">DELETE</code> ，则该表似乎为空。
                        </p>
                        <p>仅当当前没有会话绑定到该临时表时，才允许在现有临时表上执行DDL操作（ <code class="codeph">TRUNCATE</code>除外）。
                        </p>
                        <p>如果回滚事务，则输入的数据将丢失，但表定义仍然存在。</p>
                        <p>特定于事务的临时表一次只允许一个事务。如果单个事务范围中存在多个自治事务，则每个自治事务只能在前一个提交时使用该表。</p>
                        <p>因为临时表中的数据根据定义是临时的，所以在系统发生故障时，临时表数据的备份和恢复不可用。要准备此类故障，您应该开发用于保留临时表数据的备用方法。</p>
                     </div>
                     <div>
                        <div class="familylinks">
                           <div class="parentlink">
                              <p><strong>父主题：</strong> <a href="managing-tables.html#GUID-6EB347F0-64BA-4B15-8182-41BA7D5A876F" title="临时表在要缓冲（暂时保留）结果集的应用程序中很有用，可能是因为它是通过运行多个DML操作构造的。您可以创建全局临时表或私有临时表。">创建临时表</a></p>
                           </div>
                        </div>
                     </div>
                     
                  </div>
                  <div class="sect4"><a id="GUID-095B7DA3-010E-4B9A-9F07-5DDD00D53824" name="GUID-095B7DA3-010E-4B9A-9F07-5DDD00D53824"></a><h5 id="ADMIN-GUID-095B7DA3-010E-4B9A-9F07-5DDD00D53824" class="sect5"><span class="enumeration_section">20.3.2.3</span>创建全局临时表</h5>
                     <div>
                        <p>全局临时表是永久数据库对象，存储在磁盘上并对连接到数据库的所有会话可见。</p>
                     </div>
                     <div>
                        <ul class="ullinks">
                           <li class="ulchildlink"><a href="managing-tables.html#GUID-48131690-63ED-4F13-BF8C-4A292D679EBA">关于创建全局临时表</a><br>全局临时表的元数据对多个用户及其会话可见，但其内容对于会话是本地的。
                           </li>
                           <li class="ulchildlink"><a href="managing-tables.html#GUID-A48CB362-FC15-4A26-8386-906A55F6788E">示例：创建全局临时表</a><br>示例说明了如何创建全局临时表。
                           </li>
                        </ul>
                        <div class="familylinks">
                           <div class="parentlink">
                              <p><strong>父主题：</strong> <a href="managing-tables.html#GUID-6EB347F0-64BA-4B15-8182-41BA7D5A876F" title="临时表在要缓冲（暂时保留）结果集的应用程序中很有用，可能是因为它是通过运行多个DML操作构造的。您可以创建全局临时表或私有临时表。">创建临时表</a></p>
                           </div>
                        </div>
                     </div>
                     
                     <div class="sect5"><a id="GUID-48131690-63ED-4F13-BF8C-4A292D679EBA" name="GUID-48131690-63ED-4F13-BF8C-4A292D679EBA"></a><h6 id="ADMIN-GUID-48131690-63ED-4F13-BF8C-4A292D679EBA" class="sect6"><span class="enumeration_section">20.3.2.3.1</span>关于创建全局临时表</h6>
                        <div>
                           <p>全局临时表的元数据对多个用户及其会话可见，但其内容对于会话是本地的。</p>
                           <p>例如，假设基于Web的航空公司预订应用程序允许客户创建多个可选行程。每个行程由全局临时表中的一行表示。应用程序更新行以反映行程中的更改。当客户决定她想要使用哪个行程时，应用程序会将该行程的行移动到持久表。</p>
                           <p>在会话期间，行程数据是私人的。在会话结束时，将删除可选路线。</p>
                           <p>全局临时表的定义对所有会话都是可见的，但全局临时表中的数据仅对将数据插入表中的会话可见。</p>
                           <p>使用<code class="codeph">CREATE GLOBAL TEMPORARY TABLE</code>语句创建全局临时表。<code class="codeph">ON COMMIT</code>子句指示表中的数据是<span class="bold">特定</span>于<span class="bold">事务</span> （默认）还是<span class="bold">特定</span>于<span class="bold">会话</span> ，其含义如下：</p>
                           <div class="tblformal" id="GUID-48131690-63ED-4F13-BF8C-4A292D679EBA__GUID-0F724AC5-978F-4BFE-9CDC-2BAD71DFE520">
                              <table cellpadding="4" cellspacing="0" class="Formal" title="" width="100%" border="1" summary="Column 1 lists the ON COMMIT clause settings, column 2 describes the implications of that setting for global temporary tables." frame="hsides" rules="rows">
                                 <thead>
                                    <tr align="left" valign="top">
                                       <th align="left" valign="bottom" width="24%" id="d192334e5532">ON COMMIT设置</th>
                                       <th align="left" valign="bottom" width="76%" id="d192334e5535">启示</th>
                                    </tr>
                                 </thead>
                                 <tbody>
                                    <tr align="left" valign="top">
                                       <td align="left" valign="top" width="24%" id="d192334e5540" headers="d192334e5532 ">
                                          <p><code class="codeph">删除行</code> 
                                          </p>
                                       </td>
                                       <td align="left" valign="top" width="76%" headers="d192334e5540 d192334e5535 ">
                                          <p>这将创建一个特定于事务的全局临时表。会话将绑定到全局临时表，并且事务首先插入到表中。绑定在交易结束时消失。每次提交后，数据库都会截断表（删除所有行）。</p>
                                       </td>
                                    </tr>
                                    <tr align="left" valign="top">
                                       <td align="left" valign="top" width="24%" id="d192334e5549" headers="d192334e5532 ">
                                          <p><code class="codeph">保留行</code> 
                                          </p>
                                       </td>
                                       <td align="left" valign="top" width="76%" headers="d192334e5549 d192334e5535 ">
                                          <p>这将创建一个特定于会话的全局临时表。会话绑定到全局临时表，并在会话中将第一个插入到表中。此绑定在会话结束时消失，或者通过在会话中发出表的<code class="codeph">TRUNCATE</code> 。终止会话时，数据库会截断表。
                                          </p>
                                       </td>
                                    </tr>
                                 </tbody>
                              </table>
                           </div>
                           <!-- class="inftblhruleinformal" -->
                        </div>
                        <div>
                           <div class="familylinks">
                              <div class="parentlink">
                                 <p><strong>父主题：</strong> <a href="managing-tables.html#GUID-095B7DA3-010E-4B9A-9F07-5DDD00D53824" title="全局临时表是永久数据库对象，存储在磁盘上并对连接到数据库的所有会话可见。">创建全局临时表</a></p>
                              </div>
                           </div>
                        </div>
                        
                     </div><a id="ADMIN11633"></a><div class="props_rev_3"><a id="GUID-A48CB362-FC15-4A26-8386-906A55F6788E" name="GUID-A48CB362-FC15-4A26-8386-906A55F6788E"></a><h6 id="ADMIN-GUID-A48CB362-FC15-4A26-8386-906A55F6788E" class="sect6"><span class="enumeration_section">20.3.2.3.2</span>示例：创建全局临时表</h6>
                        <div>
                           <p>示例说明了如何创建全局临时表。</p>
                           <div class="section">
                              <p>此语句创建一个特定于事务的全局临时表：</p><pre class="oac_no_warn" dir="ltr">CREATE GLOBAL TEMPORARY TABLE admin_work_area_trans（startdate DATE，enddate DATE，class CHAR（20））ON COMMIT DELETE ROWS;</pre><p>此语句创建一个特定于会话的全局临时表：</p><pre class="oac_no_warn" dir="ltr">CREATE GLOBAL TEMPORARY TABLE admin_work_area_session（startdate DATE，enddate DATE，class CHAR（20））ON COMMIT PRESERVE ROWS;</pre><p>可以在全局临时表上创建索引。它们也是临时的，索引中的数据与基础表中的数据具有相同的会话或事务范围。</p>
                              <p><a id="d192334e5608" class="indexterm-anchor"></a>默认情况下，全局临时表中的行存储在创建它的用户的默认临时表空间中。但是，您可以在创建全局临时表时使用<code class="codeph">CREATE GLOBAL TEMPORARY TABLE</code>的<code class="codeph">TABLESPACE</code>子句将全局临时表分配给另一个表空间。您可以使用此功能来节省全局临时表使用的空间。例如，如果必须执行许多小型全局临时表操作，并且为排序操作配置了默认临时表空间，因此使用较大的扩展区大小，这些小操作将占用大量不必要的磁盘空间。在这种情况下，最好分配具有较小扩展区大小的第二个临时表空间。
                              </p>
                              <p>以下两个语句创建一个临时表空间，其大小为64 KB，然后在该表空间中创建一个新的全局临时表。</p><pre class="oac_no_warn" dir="ltr">CREATE TEMPORARY TABLESPACE tbs_t1 TEMPFILE'tbs_t1.f'尺寸50m重新使用MAXEXIZE UNLIMITED EXTENT MANAGEMENT本地均匀尺寸64K; CREATE GLOBAL TEMPORARY TABLE admin_work_area（startdate DATE，enddate DATE，class CHAR（20））ON COMMIT DELETE ROWS TABLESPACE tbs_t1;</pre></div>
                           <!-- class="section" -->
                        </div>
                        <div>
                           <div class="infoboxnotealso" id="GUID-A48CB362-FC15-4A26-8386-906A55F6788E__GUID-63EF3091-39AC-47B8-ACD3-8D7ED5ACBE04">
                              <p class="notep1">也可以看看：</p>
                              <ul style="list-style-type:disc">
                                 <li>
                                    <p><span class="q">“ <a href="managing-tablespaces.html#GUID-9B6544CD-BFF3-4EA8-B06B-0CBC5A91EA45" title="临时表空间包含仅在会话期间保留的临时数据。临时表空间可以改善不适合内存的多个排序操作的并发性，并可以提高排序期间的空间管理操作的效率。">关于临时表空间</a> ”</span></p>
                                 </li>
                                 <li>
                                    <p>有关使用<code class="codeph">CREATE TABLE</code>语句创建全局临时表的更多信息，请参阅<a href="https://www.oracle.com/pls/topic/lookup?ctx=en/database/oracle/oracle-database/19/admin&amp;id=SQLRF01402" target="_blank"><span><cite>Oracle数据库SQL语言参考</cite></span></a> ，其中包括适用的限制</p>
                                 </li>
                              </ul>
                           </div>
                           <div class="familylinks">
                              <div class="parentlink">
                                 <p><strong>父主题：</strong> <a href="managing-tables.html#GUID-095B7DA3-010E-4B9A-9F07-5DDD00D53824" title="全局临时表是永久数据库对象，存储在磁盘上并对连接到数据库的所有会话可见。">创建全局临时表</a></p>
                              </div>
                           </div>
                        </div>
                        
                     </div>
                  </div>
                  <div class="sect4"><a id="GUID-9B373086-0760-4B18-9688-BACFF07EC74B" name="GUID-9B373086-0760-4B18-9688-BACFF07EC74B"></a><h5 id="ADMIN-GUID-9B373086-0760-4B18-9688-BACFF07EC74B" class="sect5"><span class="enumeration_section">20.3.2.4</span>创建私有临时表</h5>
                     <p>专用临时表是在事务或会话结束时删除的临时数据库对象。私有临时表存储在内存中，每个临时表仅对创建它的会话可见。</p>
                     <div>
                        <ul class="ullinks">
                           <li class="ulchildlink"><a href="managing-tables.html#GUID-456384FD-630A-4515-A89D-79E56E28FD70">关于创建私有临时表</a><br>私有临时表的元数据和内容仅在创建它的会话中可见。
                           </li>
                           <li class="ulchildlink"><a href="managing-tables.html#GUID-BDD1152B-B041-4496-8651-D554E05A0870">示例：创建私有临时表</a><br>这些示例说明了如何创建私有临时表。
                           </li>
                        </ul>
                        <div class="familylinks">
                           <div class="parentlink">
                              <p><strong>父主题：</strong> <a href="managing-tables.html#GUID-6EB347F0-64BA-4B15-8182-41BA7D5A876F" title="临时表在要缓冲（暂时保留）结果集的应用程序中很有用，可能是因为它是通过运行多个DML操作构造的。您可以创建全局临时表或私有临时表。">创建临时表</a></p>
                           </div>
                        </div>
                     </div>
                     
                     <div class="sect5"><a id="GUID-456384FD-630A-4515-A89D-79E56E28FD70" name="GUID-456384FD-630A-4515-A89D-79E56E28FD70"></a><h6 id="ADMIN-GUID-456384FD-630A-4515-A89D-79E56E28FD70" class="sect6"><span class="enumeration_section">20.3.2.4.1</span>关于创建私有临时表</h6>
                        <div>
                           <p>私有临时表的元数据和内容仅在创建它的会话中可见。</p>
                           <p>私有临时表在以下情况下很有用：</p>
                           <ul style="list-style-type:disc">
                              <li>
                                 <p>当应用程序将临时数据存储在一次填充的临时表中时，读取几次，然后在事务或会话结束时删除</p>
                              </li>
                              <li>
                                 <p>当会话无限期维护时，必须为不同的事务创建不同的临时表</p>
                              </li>
                              <li>
                                 <p>创建临时表时，不得启动新事务或提交现有事务</p>
                              </li>
                              <li>
                                 <p>当同一用户的不同会话必须对临时表使用相同的名称时</p>
                              </li>
                              <li>
                                 <p>只读数据库需要临时表时</p>
                              </li>
                           </ul>
                           <p>例如，假设报告应用程序仅使用一个模式，但应用程序使用与模式的多个连接来运行不同的报告。会话在单个事务期间使用私有临时表进行计算，每个会话创建一个具有相同名称的私有临时表。当每个事务提交时，不再需要其临时数据。私有临时表的定义和私有临时表中的数据都只对创建表的会话可见。</p>
                           <p>使用<code class="codeph">CREATE PRIVATE TEMPORARY TABLE</code>语句创建专用临时表。<code class="codeph">ON COMMIT</code>子句指示表中的数据是<span class="bold">特定</span>于<span class="bold">事务</span> （默认）还是<span class="bold">特定</span>于<span class="bold">会话</span> ，其含义如下：</p>
                           <div class="tblformal" id="GUID-456384FD-630A-4515-A89D-79E56E28FD70__GUID-5763E2A6-BC52-4069-BA2A-DEB87E06290D">
                              <table cellpadding="4" cellspacing="0" class="Formal" title="" width="100%" border="1" summary="Column 1 lists the ON COMMIT clause settings, column 2 describes the implications of that setting for private temporary tables." frame="hsides" rules="rows">
                                 <thead>
                                    <tr align="left" valign="top">
                                       <th align="left" valign="bottom" width="24%" id="d192334e5783">ON COMMIT设置</th>
                                       <th align="left" valign="bottom" width="76%" id="d192334e5786">启示</th>
                                    </tr>
                                 </thead>
                                 <tbody>
                                    <tr align="left" valign="top">
                                       <td align="left" valign="top" width="24%" id="d192334e5791" headers="d192334e5783 ">
                                          <p><code class="codeph">DROP DEFINITION</code> 
                                          </p>
                                       </td>
                                       <td align="left" valign="top" width="76%" headers="d192334e5791 d192334e5786 ">
                                          <p>这将创建一个特定于事务的私有临时表。表中的所有数据都将丢失，并且在事务结束时会删除该表。</p>
                                       </td>
                                    </tr>
                                    <tr align="left" valign="top">
                                       <td align="left" valign="top" width="24%" id="d192334e5800" headers="d192334e5783 ">
                                          <p><code class="codeph">保留定义</code> 
                                          </p>
                                       </td>
                                       <td align="left" valign="top" width="76%" headers="d192334e5800 d192334e5786 ">
                                          <p>这将创建一个特定于会话的私有临时表。表中的所有数据都将丢失，并且在创建表的会话结束时删除该表。</p>
                                       </td>
                                    </tr>
                                 </tbody>
                              </table>
                           </div>
                           <!-- class="inftblhruleinformal" -->
                           <div class="infoboxnote" id="GUID-456384FD-630A-4515-A89D-79E56E28FD70__GUID-AEAAABD3-C848-4D88-A1D8-CEDC9A896858">
                              <p class="notep1">注意：</p>
                              <p>必须根据初始化参数<code class="codeph">private_temp_table_prefix</code>为私有临时表的名称添加前缀。
                              </p>
                           </div>
                        </div>
                        <div>
                           <div class="familylinks">
                              <div class="parentlink">
                                 <p><strong>父主题：</strong> <a href="managing-tables.html#GUID-9B373086-0760-4B18-9688-BACFF07EC74B" title="专用临时表是在事务或会话结束时删除的临时数据库对象。私有临时表存储在内存中，每个临时表仅对创建它的会话可见。">创建私有临时表</a></p>
                              </div>
                           </div>
                        </div>
                        
                     </div>
                     <div class="props_rev_3"><a id="GUID-BDD1152B-B041-4496-8651-D554E05A0870" name="GUID-BDD1152B-B041-4496-8651-D554E05A0870"></a><h6 id="ADMIN-GUID-BDD1152B-B041-4496-8651-D554E05A0870" class="sect6"><span class="enumeration_section">20.3.2.4.2</span>示例：创建私有临时表</h6>
                        <div>
                           <p>这些示例说明了如何创建私有临时表。</p>
                           <div class="section">
                              <p>此语句创建一个特定于事务的私有临时表：</p><pre class="oac_no_warn" dir="ltr">创建私有临时表ORA $ PTT_sales_ptt_transaction（time_id DATE，amount_sold NUMBER（10,2））ON COMMIT DROP DEFINITION;</pre><p>此语句创建一个特定于会话的私有临时表：</p><pre class="oac_no_warn" dir="ltr">创建私有临时表ORA $ PTT_sales_ptt_session（time_id DATE，amount_sold NUMBER（10,2））ON COMMIT PRESERVE DEFINITION;</pre><p>默认情况下，私有临时表中的行存储在创建它的用户的默认临时表空间中。但是，您可以使用<code class="codeph">CREATE PRIVATE TEMPORARY TABLE</code>语句的<code class="codeph">TABLESPACE</code>子句在创建临时表期间将专用临时表分配给另一个临时表空间。
                              </p>
                           </div>
                           <!-- class="section" -->
                        </div>
                        <div>
                           <div class="infoboxnotealso" id="GUID-BDD1152B-B041-4496-8651-D554E05A0870__GUID-63EF3091-39AC-47B8-ACD3-8D7ED5ACBE04">
                              <p class="notep1">也可以看看：</p>
                              <ul style="list-style-type:disc">
                                 <li>
                                    <p><span class="q">“ <a href="managing-tablespaces.html#GUID-9B6544CD-BFF3-4EA8-B06B-0CBC5A91EA45" title="临时表空间包含仅在会话期间保留的临时数据。临时表空间可以改善不适合内存的多个排序操作的并发性，并可以提高排序期间的空间管理操作的效率。">关于临时表空间</a> ”</span></p>
                                 </li>
                                 <li>
                                    <p>有关使用<code class="codeph">CREATE TABLE</code>语句创建专用临时表的更多信息，请参阅<a href="https://www.oracle.com/pls/topic/lookup?ctx=en/database/oracle/oracle-database/19/admin&amp;id=SQLRF01402" target="_blank"><span><cite>Oracle数据库SQL语言参考</cite></span></a> ，包括适用的限制</p>
                                 </li>
                              </ul>
                           </div>
                           <div class="familylinks">
                              <div class="parentlink">
                                 <p><strong>父主题：</strong> <a href="managing-tables.html#GUID-9B373086-0760-4B18-9688-BACFF07EC74B" title="专用临时表是在事务或会话结束时删除的临时数据库对象。私有临时表存储在内存中，每个临时表仅对创建它的会话可见。">创建私有临时表</a></p>
                              </div>
                           </div>
                        </div>
                        
                     </div>
                  </div>
               </div><a id="ADMIN11634"></a><div class="props_rev_3"><a id="GUID-2C1E31D1-C0EE-48D6-8C11-31AE9AFF5440" name="GUID-2C1E31D1-C0EE-48D6-8C11-31AE9AFF5440"></a><h4 id="ADMIN-GUID-2C1E31D1-C0EE-48D6-8C11-31AE9AFF5440" class="sect4"><span class="enumeration_section">20.3.3</span>并行化表创建</h4>
                  <div>
                     <p>指定<code class="codeph">AS SELECT</code>子句以创建表并使用其他表中的数据填充表时，可以使用并行执行。
                     </p>
                     <div class="section">
                        <p><code class="codeph">CREATE TABLE...AS SELECT</code>语句包含两部分： <code class="codeph">CREATE</code>部分（DDL）和<code class="codeph">SELECT</code>部分（查询）。Oracle数据库可以并行化语句的两个部分。如果满足以下条件<span class="italic">之一</span> ，则<code class="codeph">CREATE</code>部分将并行化：</p>
                     </div>
                     <!-- class="section" -->
                     <div class="section">
                        <ul style="list-style-type:disc">
                           <li>
                              <p><code class="codeph">PARALLEL</code>子句包含在<code class="codeph">CREATE TABLE...AS SELECT</code>语句</p>
                           </li>
                           <li>
                              <p>指定了<code class="codeph">ALTER SESSION FORCE PARALLEL DDL</code>语句</p>
                           </li>
                        </ul>
                        <p>如果满足以下<span class="italic">所有条件</span> ，则并行化查询部分：</p>
                        <ul style="list-style-type:disc">
                           <li>
                              <p>查询包括并行提示规范（ <code class="codeph">PARALLEL</code>或<code class="codeph">PARALLEL_INDEX</code> ） <span class="italic">或</span> <code class="codeph">CREATE</code>部分包括<code class="codeph">PARALLEL</code>子句<span class="italic">或</span>查询中引用的模式对象具有与之关联的<code class="codeph">PARALLEL</code>声明。
                              </p>
                           </li>
                           <li>
                              <p>查询中指定的至少一个表需要全表扫描<span class="italic">或</span>跨越多个分区的索引范围扫描。
                              </p>
                           </li>
                        </ul>
                        <p>如果您并行创建表，那么该表将具有与之关联的并行声明（ <code class="codeph">PARALLEL</code>子句）。表上可能进行并行化的任何后续DML或查询将尝试使用并行执行。
                        </p>
                        <p>以下简单语句并行化表的创建，并使用表压缩将结果存储为压缩格式：</p><pre class="oac_no_warn" dir="ltr">CREATE TABLE hr.admin_emp_dept PARALLEL COMPRESS as SELECT * FROM hr.employees WHERE department_id = 10;</pre><p>在这种情况下， <code class="codeph">PARALLEL</code>子句告诉数据库在创建表时选择最佳数量的并行执行服务器。
                        </p>
                     </div>
                     <!-- class="section" -->
                  </div>
                  <div>
                     <div class="infoboxnotealso" id="GUID-2C1E31D1-C0EE-48D6-8C11-31AE9AFF5440__GUID-8A9830E2-FF2A-4786-81DE-068DF482899C">
                        <p class="notep1">也可以看看：</p>
                        <p></p>
                        <ul style="list-style-type:disc">
                           <li>
                              <p>有关使用并行执行的详细信息，请<a href="https://www.oracle.com/pls/topic/lookup?ctx=en/database/oracle/oracle-database/19/admin&amp;id=VLDBG010" target="_blank"><span class="italic">参见“Oracle数据库VLDB和分区指南”</span></a></p>
                           </li>
                           <li>
                              <p><span class="q">“ <a href="managing-processes.html#GUID-1DEC7073-6F34-48B3-A2EC-3B5CDD3AD89C" title="您可以管理SQL语句的并行处理。在此配置中，Oracle数据库可以在多个并行进程之间划分处理SQL语句的工作。">管理并行SQL执行的进程</a> ”</span></p>
                           </li>
                        </ul>
                     </div>
                     <div class="familylinks">
                        <div class="parentlink">
                           <p><strong>父主题：</strong> <a href="managing-tables.html#GUID-D2802D28-D8B3-4C21-99EC-342DC42F9898" title="使用SQL语句CREATE TABLE创建表。">创建表</a></p>
                        </div>
                     </div>
                  </div>
                  
               </div>
            </div><a id="ADMIN11635"></a><div class="props_rev_3"><a id="GUID-7B5676FC-59B4-418F-826B-8F4D7E3690E2" name="GUID-7B5676FC-59B4-418F-826B-8F4D7E3690E2"></a><h3 id="ADMIN-GUID-7B5676FC-59B4-418F-826B-8F4D7E3690E2" class="sect3"><span class="enumeration_section">20.4</span>加载表</h3>
               <div>
                  <p>有几种将数据加载到表中的技术。</p>
                  <div class="infoboxnote" id="GUID-7B5676FC-59B4-418F-826B-8F4D7E3690E2__GUID-1A597EAC-924D-41D8-9F25-7DA80CB1EE6A">
                     <p class="notep1">注意：</p>
                     <p>分区表的任何新段的第一个范围的默认大小为8 MB而不是64 KB。这有助于提高分区表上的插入和查询的性能。尽管分区表将以较大的初始大小开始，但一旦插入了足够的数据，空间消耗将与先前版本中的相同。您可以通过在表的storage子句中设置<code class="codeph">INITIAL</code>大小来覆盖此缺省值。此新默认值仅适用于表分区和LOB分区。
                     </p>
                  </div>
               </div>
               <div>
                  <ul class="ullinks">
                     <li class="ulchildlink"><a href="managing-tables.html#GUID-7ED50F3F-2BEB-4FDE-85B7-F8FB0D50FC66">加载表的方法</a><br>有几种方法可以将数据插入或初始加载到表中。
                     </li>
                     <li class="ulchildlink"><a href="managing-tables.html#GUID-134D6EB6-219E-4820-AB54-8C60067A8F0F">使用Direct-Path INSERT提高INSERT性能</a><br>加载大量数据时，可以使用直接路径<code class="codeph">INSERT</code>来提高加载性能。</li>
                     <li class="ulchildlink"><a href="managing-tables.html#GUID-9B894C55-5D79-4AA9-95DE-C216D6C417E8">使用常规插入来加载表</a><br>在<span class="bold">传统的INSERT操作</span>期间，数据库重用表中的空闲空间，将新插入的数据与现有数据交错。在此类操作期间，数据库还维护参照完整性约束。与直接路径<code class="codeph">INSERT</code>操作不同，传统的<code class="codeph">INSERT</code>操作不需要对表进行独占锁定。
                     </li>
                     <li class="ulchildlink"><a href="managing-tables.html#GUID-36DB026B-4702-477A-92C4-EA2795D2B37F">使用DML错误记录避免批量INSERT故障</a><br>您可以使用DML错误日志记录功能来避免批量<code class="codeph">INSERT</code>故障。
                     </li>
                  </ul>
                  <div class="familylinks">
                     <div class="parentlink">
                        <p><strong>父主题：</strong> <a href="managing-tables.html#GUID-707B02F5-E589-4C20-8E2E-5ED4F7888702" title="管理表包括创建表，加载表，更改表和删除表等任务。">管理表</a></p>
                     </div>
                  </div>
               </div>
               <a id="ADMIN13461"></a><div class="props_rev_3"><a id="GUID-7ED50F3F-2BEB-4FDE-85B7-F8FB0D50FC66" name="GUID-7ED50F3F-2BEB-4FDE-85B7-F8FB0D50FC66"></a><h4 id="ADMIN-GUID-7ED50F3F-2BEB-4FDE-85B7-F8FB0D50FC66" class="sect4"><span class="enumeration_section">20.4.1</span>加载表的方法</h4>
                  <div>
                     <p>有几种方法可以将数据插入或初始加载到表中。</p>
                     <p>最常用的有以下几种：</p>
                     <div class="tblformal" id="GUID-7ED50F3F-2BEB-4FDE-85B7-F8FB0D50FC66__GUID-3EF37926-F34A-45C8-9EDB-ADE72B6F47B8">
                        <table cellpadding="4" cellspacing="0" class="Formal" title="" width="100%" border="1" summary="Column 1 lists the methods of inserting data into tables, column 2 describes each method." frame="hsides" rules="rows">
                           <thead>
                              <tr align="left" valign="top">
                                 <th align="left" valign="bottom" width="33%" id="d192334e6180">方法</th>
                                 <th align="left" valign="bottom" width="67%" id="d192334e6183">描述</th>
                              </tr>
                           </thead>
                           <tbody>
                              <tr align="left" valign="top">
                                 <td align="left" valign="top" width="33%" id="d192334e6188" headers="d192334e6180 ">
                                    <p>使用SQL * Loader</p>
                                 </td>
                                 <td align="left" valign="top" width="67%" headers="d192334e6188 d192334e6183 ">
                                    <p>此Oracle实用程序将外部文件中的数据加载到Oracle数据库的表中。</p>
                                    <p>从Oracle Database 12 <span class="italic">c开始</span> ，SQL * Loader支持快速模式。SQL * Loader express模式消除了对控制文件的需求。Express模式简化了从外部文件加载数据的过程。使用快速模式，SQL * Loader尝试使用外部表加载方法。如果无法使用外部表加载方法，则SQL * Loader会尝试使用直接路径。如果无法使用直接路径，则SQL * Loader使用常规路径。
                                    </p>
                                    <p>SQL * Loader express模式根据表列类型自动识别输入数据类型并控制并行性。SQL * Loader使用默认值来简化使用，但您可以使用命令行参数覆盖许多默认值。您可以选择指定直接路径或传统路径加载方法，而不是使用快速模式。</p>
                                    <p>有关SQL * Loader的信息，请参阅<a href="https://www.oracle.com/pls/topic/lookup?ctx=en/database/oracle/oracle-database/19/admin&amp;id=SUTIL003" target="_blank"><span class="italic">Oracle数据库实用程序</span></a> 。
                                    </p>
                                 </td>
                              </tr>
                              <tr align="left" valign="top">
                                 <td align="left" valign="top" width="33%" id="d192334e6209" headers="d192334e6180 ">
                                    <p><a href="https://www.oracle.com/pls/topic/lookup?ctx=en/database/oracle/oracle-database/19/admin&amp;id=SQLRF01402" target="_blank"><code class="codeph">CREATE TABLE</code> ...<code class="codeph">AS SELECT</code></a>语句（CTAS）</p>
                                 </td>
                                 <td align="left" valign="top" width="67%" headers="d192334e6209 d192334e6183 ">
                                    <p>使用此SQL语句，您可以创建一个表，并使用从另一个现有表（包括外部表）中选择的数据填充该表。</p>
                                 </td>
                              </tr>
                              <tr align="left" valign="top">
                                 <td align="left" valign="top" width="33%" id="d192334e6223" headers="d192334e6180 ">
                                    <p><a href="https://www.oracle.com/pls/topic/lookup?ctx=en/database/oracle/oracle-database/19/admin&amp;id=SQLRF01604" target="_blank"><code class="codeph">INSERT</code></a>语句</p>
                                 </td>
                                 <td align="left" valign="top" width="67%" headers="d192334e6223 d192334e6183 ">
                                    <p><code class="codeph">INSERT</code>语句使您可以通过指定列值或通过指定从另一个现有表（包括外部表）中选择数据的子查询来向表中添加行。
                                    </p>
                                    <p><code class="codeph">INSERT</code>语句的一种形式启用直接路径<code class="codeph">INSERT</code> ，它可以提高性能，并且对批量加载很有用。请参阅<span class="q">“ <a href="managing-tables.html#GUID-134D6EB6-219E-4820-AB54-8C60067A8F0F" title="加载大量数据时，可以使用直接路径INSERT来提高加载性能。">使用Direct-Path INSERT提高INSERT性能</a> ”</span> 。
                                    </p>
                                    <p>如果要插入大量数据并希望在遇到错误时避免语句终止和回滚，则可以插入DML错误日志记录。请参阅<span class="q">“ <a href="managing-tables.html#GUID-B71385AD-2D21-42F3-9249-3D6364887746" title="使用带子查询的INSERT语句加载表时，如果发生错误，则语句将终止并完全回滚。这可能浪费时间和系统资源。对于此类INSERT语句，可以使用DML错误日志记录功能来避免这种情况。">使用DML错误记录避免批量INSERT故障</a> ”</span> 。
                                    </p>
                                 </td>
                              </tr>
                              <tr align="left" valign="top">
                                 <td align="left" valign="top" width="33%" id="d192334e6272" headers="d192334e6180 ">
                                    <p><a href="https://www.oracle.com/pls/topic/lookup?ctx=en/database/oracle/oracle-database/19/admin&amp;id=SQLRF01606" target="_blank"><code class="codeph">MERGE</code></a>声明</p>
                                 </td>
                                 <td align="left" valign="top" width="67%" headers="d192334e6272 d192334e6183 ">
                                    <p><code class="codeph">MERGE</code>语句允许您通过从另一个现有表中选择行来将行插入或更新表的行。如果新数据中的行对应于表中已存在的项，则执行<code class="codeph">UPDATE</code> ，否则执行<code class="codeph">INSERT</code> 。
                                    </p>
                                 </td>
                              </tr>
                           </tbody>
                        </table>
                     </div>
                     <!-- class="inftblhruleinformal" -->
                     <div class="infoboxnote" id="GUID-7ED50F3F-2BEB-4FDE-85B7-F8FB0D50FC66__GUID-A40976DC-1D59-4F20-8E3C-0A0109C762FD">
                        <p class="notep1">注意：</p>
                        <p>本书中仅包含了一些将数据插入表格的详细信息和示例。特定于数据仓库和应用程序开发的Oracle文档提供了有关在表中插入和操作数据的更多信息。看到：</p>
                        <ul style="list-style-type:disc">
                           <li>
                              <p><a href="https://www.oracle.com/pls/topic/lookup?ctx=en/database/oracle/oracle-database/19/admin&amp;id=DWHSG8270" target="_blank"><span class="italic">Oracle数据库数据仓库指南</span></a></p>
                           </li>
                           <li>
                              <p><a href="https://www.oracle.com/pls/topic/lookup?ctx=en/database/oracle/oracle-database/19/admin&amp;id=ADLOB45151" target="_blank"><span class="italic">Oracle Database SecureFiles和大对象开发人员指南</span></a></p>
                           </li>
                        </ul>
                     </div>
                  </div>
                  <div>
                     <div class="infoboxnotealso" id="GUID-7ED50F3F-2BEB-4FDE-85B7-F8FB0D50FC66__GUID-7D755420-5C16-4218-8748-A4B6FFDB3BCD">
                        <p class="notep1">也可以看看：</p>
                        <p><span class="q">“ <a href="managing-tables.html#GUID-F6948F0E-0557-4C42-9145-1897DE974CC3" title="外部表是不驻留在数据库中的表，但位于数据库外部的外部文件中，例如操作系统文件或Hadoop分布式文件系统（HDFS）文件。">管理外部表</a> ”</span></p>
                     </div>
                     <div class="familylinks">
                        <div class="parentlink">
                           <p><strong>父主题：</strong> <a href="managing-tables.html#GUID-7B5676FC-59B4-418F-826B-8F4D7E3690E2" title="有几种将数据加载到表中的技术。">加载表</a></p>
                        </div>
                     </div>
                  </div>
                  
               </div><a id="ADMIN01509"></a><div class="props_rev_3"><a id="GUID-134D6EB6-219E-4820-AB54-8C60067A8F0F" name="GUID-134D6EB6-219E-4820-AB54-8C60067A8F0F"></a><h4 id="ADMIN-GUID-134D6EB6-219E-4820-AB54-8C60067A8F0F" class="sect4"><span class="enumeration_section">20.4.2</span>使用Direct-Path INSERT提高INSERT性能</h4>
                  <p>加载大量数据时，可以使用直接路径<code class="codeph">INSERT</code>来提高加载性能。</p>
                  <div>
                     <ul class="ullinks">
                        <li class="ulchildlink"><a href="managing-tables.html#GUID-BC07CE7E-92E3-4C2D-BA31-88659D10BD30">关于Direct-Path INSERT</a><br>直接路径插入操作通常比传统插入操作更快。
                        </li>
                        <li class="ulchildlink"><a href="managing-tables.html#GUID-8D6EF7DE-A433-4198-BE57-D2826C4F36D9">Direct-Path INSERT的工作原理</a><br>您可以对分区和非分区表使用直接路径<code class="codeph">INSERT</code> 。
                        </li>
                        <li class="ulchildlink"><a href="managing-tables.html#GUID-93B8D899-B508-4961-A1E7-F141531B0469">使用Direct-Path INSERT加载数据</a><br>您可以加载直接路径数据<code class="codeph">INSERT</code>通过直接路径<code class="codeph">INSERT</code> ，或通过直接路径模式下使用Oracle SQL * Loader实用程序的SQL语句，将在并行模式下的数据。直接路径<code class="codeph">INSERT</code>可以以串行或并行模式完成。
                        </li>
                        <li class="ulchildlink"><a href="managing-tables.html#GUID-C5C17959-0BB5-4764-8E6F-799B4DC80F5D">直接路径INSERT的记录模式</a><br>直接路径<code class="codeph">INSERT</code>允许您选择是否在插入操作期间记录重做和撤消信息。
                        </li>
                        <li class="ulchildlink"><a href="managing-tables.html#GUID-C23CE17E-5F49-4F32-8EF3-5E3B00EAF81A">直接路径INSERT的其他注意事项</a><br></li>
                     </ul>
                     <div class="familylinks">
                        <div class="parentlink">
                           <p><strong>父主题：</strong> <a href="managing-tables.html#GUID-7B5676FC-59B4-418F-826B-8F4D7E3690E2" title="有几种将数据加载到表中的技术。">加载表</a></p>
                        </div>
                     </div>
                  </div>
                  <a id="ADMIN11643"></a><div class="props_rev_3"><a id="GUID-BC07CE7E-92E3-4C2D-BA31-88659D10BD30" name="GUID-BC07CE7E-92E3-4C2D-BA31-88659D10BD30"></a><h5 id="ADMIN-GUID-BC07CE7E-92E3-4C2D-BA31-88659D10BD30" class="sect5"><span class="enumeration_section">20.4.2.1</span>关于直接路径INSERT</h5>
                     <div>
                        <p>直接路径插入操作通常比传统插入操作更快。</p>
                        <p>Oracle数据库以两种方式之一将数据插入表中：</p>
                        <ul style="list-style-type:disc">
                           <li>
                              <p>在<span class="bold">传统的INSERT操作</span>期间，数据库重用表中的空闲空间，将新插入的数据与现有数据交错。在此类操作期间，数据库还维护参照完整性约束。
                              </p>
                           </li>
                           <li>
                              <p>在<span class="bold">直接路径INSERT操作期间</span> ，数据库将插入的数据追加到表中的现有数据之后。数据直接写入数据文件，绕过缓冲区缓存。不重用表中的可用空间，并忽略参照完整性约束。直接路径<code class="codeph">INSERT</code>性能明显优于传统插入式。
                              </p>
                           </li>
                        </ul>
                        <p>数据库可以以串行模式（一个进程执行语句）或并行模式插入数据，其中多个进程同时协同工作以运行单个SQL语句。后者称为并行执行。</p>
                        <p>以下是直接路径<code class="codeph">INSERT</code>好处：</p>
                        <ul style="list-style-type:disc">
                           <li>
                              <p>在直接路径<code class="codeph">INSERT</code>期间，您可以禁用重做和撤消条目的日志记录以减少加载时间。相反，传统的插入操作必须始终记录这些条目，因为这些操作会重用自由空间并保持参照完整性。
                              </p>
                           </li>
                           <li>
                              <p>即使以并行模式运行，直接路径<code class="codeph">INSERT</code>操作也可确保事务的原子性。在并行直接路径加载期间（使用SQL * Loader）无法保证原子性。
                              </p>
                           </li>
                        </ul>
                        <p>执行并行直接路径加载时，SQL * Loader和<code class="codeph">INSERT</code>语句之间的一个显着区别如下：如果在使用SQL * Loader的并行直接路径加载期间发生错误，则加载完成，但某些索引可能在结束时标记为<code class="codeph">UNUSABLE</code>加载。相反，并行直接路径<code class="codeph">INSERT</code>在索引更新期间发生错误时回滚语句。
                        </p>
                        <div class="infoboxnote" id="GUID-BC07CE7E-92E3-4C2D-BA31-88659D10BD30__GUID-B03C9A49-CF88-439D-9898-6D84AF18AD6D">
                           <p class="notep1">注意：</p>
                           <p>传统的<code class="codeph">INSERT</code>操作在插入期间检查违反<code class="codeph">NOT</code> <code class="codeph">NULL</code>约束的情况。因此，如果传统的<code class="codeph">INSERT</code>操作违反了<code class="codeph">NOT</code> <code class="codeph">NULL</code>约束，则在插入期间返回错误。直接路径<code class="codeph">INSERT</code>操作在插入之前检查<code class="codeph">NOT</code> <code class="codeph">NULL</code>约束的违反。因此，如果违反直接路径<code class="codeph">INSERT</code>操作的<code class="codeph">NOT</code> <code class="codeph">NULL</code>约束，则在插入之前返回错误。
                           </p>
                        </div>
                     </div>
                     <div>
                        <div class="familylinks">
                           <div class="parentlink">
                              <p><strong>父主题：</strong> <a href="managing-tables.html#GUID-134D6EB6-219E-4820-AB54-8C60067A8F0F" title="加载大量数据时，可以使用直接路径INSERT来提高加载性能。">使用Direct-Path INSERT提高INSERT性能</a></p>
                           </div>
                        </div>
                     </div>
                     
                  </div><a id="ADMIN11645"></a><div class="props_rev_3"><a id="GUID-8D6EF7DE-A433-4198-BE57-D2826C4F36D9" name="GUID-8D6EF7DE-A433-4198-BE57-D2826C4F36D9"></a><h5 id="ADMIN-GUID-8D6EF7DE-A433-4198-BE57-D2826C4F36D9" class="sect5"><span class="enumeration_section">20.4.2.2</span>直接路径INSERT如何工作</h5>
                     <p>您可以对分区和非分区表使用直接路径<code class="codeph">INSERT</code> 。
                     </p>
                     <div>
                        <ul class="ullinks">
                           <li class="ulchildlink"><a href="managing-tables.html#GUID-1B719948-83B5-438A-B23D-899596756883">串行直接路径INSERT到分区或非分区表</a><br>单个进程插入超出表段或每个分区段的当前高水位线的数据。（ <strong class="term">高水位线</strong>是从未格式化块以接收数据的级别。）当<code class="codeph">COMMIT</code>运行时，高水位线标记将更新为新值，使数据对用户可见。
                           </li>
                           <li class="ulchildlink"><a href="managing-tables.html#GUID-52FBF45A-F2DC-4AE8-AD95-F9778D52CDD8">并行直接路径INSERT到分区表</a><br>这种情况类似于串行直接路径<code class="codeph">INSERT</code> 。为每个并行执行服务器分配一个或多个分区，在一个分区上只有一个进程。
                           </li>
                           <li class="ulchildlink"><a href="managing-tables.html#GUID-DC46ABB2-E80D-4083-9949-E2F59FD2B104">并行直接路径INSERT到非分区表</a><br>每个并行执行服务器分配一个新的临时段，并将数据插入该临时段。当<code class="codeph">COMMIT</code>运行时，并行执行协调器将新的临时段合并到主表段中，用户可以看到它。
                           </li>
                        </ul>
                        <div class="familylinks">
                           <div class="parentlink">
                              <p><strong>父主题：</strong> <a href="managing-tables.html#GUID-134D6EB6-219E-4820-AB54-8C60067A8F0F" title="加载大量数据时，可以使用直接路径INSERT来提高加载性能。">使用Direct-Path INSERT提高INSERT性能</a></p>
                           </div>
                        </div>
                     </div>
                     <a id="ADMIN11646"></a><div class="props_rev_3"><a id="GUID-1B719948-83B5-438A-B23D-899596756883" name="GUID-1B719948-83B5-438A-B23D-899596756883"></a><h6 id="ADMIN-GUID-1B719948-83B5-438A-B23D-899596756883" class="sect6"><span class="enumeration_section">20.4.2.2.1</span>串行直接路径INSERT到分区或非分区表</h6>
                        <p>单个进程插入超出表段或每个分区段的当前高水位线的数据。（ <strong class="term">高水位线</strong>是从未格式化块以接收数据的级别。）当<code class="codeph">COMMIT</code>运行时，高水位线标记将更新为新值，使数据对用户可见。
                        </p>
                        <div>
                           <div class="familylinks">
                              <div class="parentlink">
                                 <p><strong>父主题：</strong> <a href="managing-tables.html#GUID-8D6EF7DE-A433-4198-BE57-D2826C4F36D9" title="您可以对分区和非分区表使用直接路径INSERT。">Direct-Path INSERT的工作原理</a></p>
                              </div>
                           </div>
                        </div>
                        
                     </div><a id="ADMIN11647"></a><div class="props_rev_3"><a id="GUID-52FBF45A-F2DC-4AE8-AD95-F9778D52CDD8" name="GUID-52FBF45A-F2DC-4AE8-AD95-F9778D52CDD8"></a><h6 id="ADMIN-GUID-52FBF45A-F2DC-4AE8-AD95-F9778D52CDD8" class="sect6"><span class="enumeration_section">20.4.2.2.2</span>并行直接路径INSERT到分区表</h6>
                        <div>
                           <p>这种情况类似于串行直接路径<code class="codeph">INSERT</code> 。为每个并行执行服务器分配一个或多个分区，在一个分区上只有一个进程。
                           </p>
                           <p>每个并行执行服务器插入超出其分配的分区段的当前高水位线的数据。当<code class="codeph">COMMIT</code>运行时，每个分区段的高水位标记将更新为其新值，从而使用户可以看到数据。
                           </p>
                        </div>
                        <div>
                           <div class="familylinks">
                              <div class="parentlink">
                                 <p><strong>父主题：</strong> <a href="managing-tables.html#GUID-8D6EF7DE-A433-4198-BE57-D2826C4F36D9" title="您可以对分区和非分区表使用直接路径INSERT。">Direct-Path INSERT的工作原理</a></p>
                              </div>
                           </div>
                        </div>
                        
                     </div><a id="ADMIN11648"></a><div class="props_rev_3"><a id="GUID-DC46ABB2-E80D-4083-9949-E2F59FD2B104" name="GUID-DC46ABB2-E80D-4083-9949-E2F59FD2B104"></a><h6 id="ADMIN-GUID-DC46ABB2-E80D-4083-9949-E2F59FD2B104" class="sect6"><span class="enumeration_section">20.4.2.2.3</span>并行直接路径INSERT到非<span class="enumeration_section">分区</span>表</h6>
                        <p>每个并行执行服务器分配一个新的临时段，并将数据插入该临时段。当<code class="codeph">COMMIT</code>运行时，并行执行协调器将新的临时段合并到主表段中，用户可以看到它。
                        </p>
                        <div>
                           <div class="familylinks">
                              <div class="parentlink">
                                 <p><strong>父主题：</strong> <a href="managing-tables.html#GUID-8D6EF7DE-A433-4198-BE57-D2826C4F36D9" title="您可以对分区和非分区表使用直接路径INSERT。">Direct-Path INSERT的工作原理</a></p>
                              </div>
                           </div>
                        </div>
                        
                     </div>
                  </div><a id="ADMIN11644"></a><div class="props_rev_3"><a id="GUID-93B8D899-B508-4961-A1E7-F141531B0469" name="GUID-93B8D899-B508-4961-A1E7-F141531B0469"></a><h5 id="ADMIN-GUID-93B8D899-B508-4961-A1E7-F141531B0469" class="sect5"><span class="enumeration_section">20.4.2.3</span>使用Direct-Path INSERT加载数据</h5>
                     <p>您可以加载直接路径数据<code class="codeph">INSERT</code>通过直接路径<code class="codeph">INSERT</code> ，或通过直接路径模式下使用Oracle SQL * Loader实用程序的SQL语句，将在并行模式下的数据。直接路径<code class="codeph">INSERT</code>可以以串行或并行模式完成。
                     </p>
                     <div>
                        <ul class="ullinks">
                           <li class="ulchildlink"><a href="managing-tables.html#GUID-C0590D13-D8AD-4B59-9BF0-B698A48A414A">带有SQL语句的串行模式插入</a><br>有多种方法可以使用SQL在串行模式下激活直接路径<code class="codeph">INSERT</code> 。</li>
                           <li class="ulchildlink"><a href="managing-tables.html#GUID-251DA0BF-FE74-459B-9874-7BA48AD43E79">带有SQL语句的并行模式插入</a><br>在并行模式下<code class="codeph">INSERT</code> ，默认为直接路径<code class="codeph">INSERT</code> 。但是，您可以使用<code class="codeph">NOAPPEND</code> <code class="codeph">PARALLEL</code>提示使用常规<code class="codeph">INSERT</code>以并行模式<code class="codeph">INSERT</code> 。
                           </li>
                        </ul>
                        <div class="familylinks">
                           <div class="parentlink">
                              <p><strong>父主题：</strong> <a href="managing-tables.html#GUID-134D6EB6-219E-4820-AB54-8C60067A8F0F" title="加载大量数据时，可以使用直接路径INSERT来提高加载性能。">使用Direct-Path INSERT提高INSERT性能</a></p>
                           </div>
                        </div>
                     </div>
                     <a id="ADMIN13320"></a><div class="props_rev_3"><a id="GUID-C0590D13-D8AD-4B59-9BF0-B698A48A414A" name="GUID-C0590D13-D8AD-4B59-9BF0-B698A48A414A"></a><h6 id="ADMIN-GUID-C0590D13-D8AD-4B59-9BF0-B698A48A414A" class="sect6"><span class="enumeration_section">20.4.2.3.1</span>带有SQL语句的串行模式插入</h6>
                        <div>
                           <p>有多种方法可以使用SQL在串行模式下激活直接路径<code class="codeph">INSERT</code> 。</p>
                           <p>您可以通过以下方式使用SQL以串行模式激活直接路径<code class="codeph">INSERT</code> ：</p>
                           <ul style="list-style-type:disc">
                              <li>
                                 <p>如果要使用子查询执行<code class="codeph">INSERT</code> ，请在每个<code class="codeph">INSERT</code>语句中指定<code class="codeph">APPEND</code>提示，紧跟在<code class="codeph">INSERT</code>关键字之后，或紧跟在<code class="codeph">INSERT</code>语句的子查询中的<code class="codeph">SELECT</code>关键字之后。
                                 </p>
                              </li>
                              <li>
                                 <p>如果使用<code class="codeph">VALUES</code>子句执行<code class="codeph">INSERT</code> ，请在<code class="codeph">INSERT</code>关键字后面的每个<code class="codeph">INSERT</code>语句中指定<code class="codeph">APPEND_VALUES</code>提示。当要加载数十万或数百万行时，最好使用带有<code class="codeph">VALUES</code>子句的直接路径<code class="codeph">INSERT</code> 。典型的使用场景是使用OCI的数组插入。另一种使用场景可能是在PL / SQL中的<code class="codeph">FORALL</code>语句中插入。</p>
                              </li>
                           </ul>
                           <p>如果在带有<code class="codeph">VALUES</code>子句的<code class="codeph">INSERT</code>语句中指定<code class="codeph">APPEND</code>提示（而不是<code class="codeph">APPEND_VALUES</code>提示），则忽略<code class="codeph">APPEND</code>提示并执行常规插入。
                           </p>
                           <p>以下是使用<code class="codeph">APPEND</code>提示执行直接路径<code class="codeph">INSERT</code>的示例：</p><pre class="oac_no_warn" dir="ltr">INSERT / * + APPEND * / INTO sales_hist SELECT * FROM sales WHERE cust_id = 8890;</pre><p>以下PL / SQL代码片段是使用<code class="codeph">APPEND_VALUES</code>提示的示例：</p><pre class="oac_no_warn" dir="ltr">FORALL IN IN 1..numrecords INSERT / * + APPEND_VALUES * / INTO orderdata VALUES（ordernum（i），custid（i），orderdate（i），shipmode（i），paymentid（i））;承诺;</pre></div>
                        <div>
                           <div class="familylinks">
                              <div class="parentlink">
                                 <p><strong>父主题：</strong> <a href="managing-tables.html#GUID-93B8D899-B508-4961-A1E7-F141531B0469" title="您可以使用直接路径INSERT SQL语句，以并行模式插入数据或使用直接路径模式下的Oracle SQL * Loader实用程序来使用直接路径INSERT加载数据。直接路径INSERT可以以串行或并行模式完成。">使用Direct-Path INSERT加载数据</a></p>
                              </div>
                           </div>
                        </div>
                        
                     </div><a id="ADMIN13321"></a><div class="props_rev_3"><a id="GUID-251DA0BF-FE74-459B-9874-7BA48AD43E79" name="GUID-251DA0BF-FE74-459B-9874-7BA48AD43E79"></a><h6 id="ADMIN-GUID-251DA0BF-FE74-459B-9874-7BA48AD43E79" class="sect6"><span class="enumeration_section">20.4.2.3.2</span>带有SQL语句的并行模式插入</h6>
                        <div>
                           <p>在并行模式下<code class="codeph">INSERT</code> ，默认为直接路径<code class="codeph">INSERT</code> 。但是，您可以使用<code class="codeph">NOAPPEND</code> <code class="codeph">PARALLEL</code>提示使用常规<code class="codeph">INSERT</code>以并行模式<code class="codeph">INSERT</code> 。
                           </p>
                           <p>要以并行DML模式运行，必须满足以下要求：</p>
                           <ul style="list-style-type:disc">
                              <li>
                                 <p>您必须安装Oracle Enterprise Edition。</p>
                              </li>
                              <li>
                                 <p>您必须在会话中启用并行DML。为此，请提交以下声明：</p><pre class="oac_no_warn" dir="ltr">ALTER SESSION {ENABLE | FORCE} PARALLEL DML;</pre></li>
                              <li>
                                 <p>您必须满足以下至少一项要求：</p>
                                 <ul style="list-style-type:disc">
                                    <li>
                                       <p>在创建时或随后指定目标表的并行属性</p>
                                    </li>
                                    <li>
                                       <p>为每个插入操作指定<code class="codeph">PARALLEL</code>提示</p>
                                    </li>
                                    <li>
                                       <p>将数据库初始化参数<code class="codeph">PARALLEL_DEGREE_POLICY</code>为<code class="codeph">AUTO</code></p>
                                    </li>
                                 </ul>
                              </li>
                           </ul>
                           <p>要禁用直接路径<code class="codeph">INSERT</code> ，请在每个<code class="codeph">INSERT</code>语句中指定<code class="codeph">NOAPPEND</code>提示。这样做会覆盖并行DML模式。
                           </p>
                           <div class="infoboxnote" id="GUID-251DA0BF-FE74-459B-9874-7BA48AD43E79__GUID-67BF1E35-1B13-4CC5-903A-68A35C760C6C">
                              <p class="notep1">注意：</p>
                              <p>插入完成后，您无法立即查询或修改使用直接路径<code class="codeph">INSERT</code>插入的数据。如果尝试这样做，则会生成ORA-12838错误。在尝试读取或修改新插入的数据之前，必须先发出<code class="codeph">COMMIT</code>语句。
                              </p>
                           </div>
                        </div>
                        <div>
                           <div class="infoboxnotealso" id="GUID-251DA0BF-FE74-459B-9874-7BA48AD43E79__GUID-FAD6D19C-697C-4CAB-9BFE-75CF91F388FE">
                              <p class="notep1">也可以看看：</p>
                              <p></p>
                              <ul style="list-style-type:disc">
                                 <li>
                                    <p><span class="q">“ <a href="managing-tables.html#GUID-9B894C55-5D79-4AA9-95DE-C216D6C417E8" title="在传统的INSERT操作期间，数据库重用表中的空闲空间，将新插入的数据与现有数据交错。在此类操作期间，数据库还维护参照完整性约束。与直接路径INSERT操作不同，传统的INSERT操作不需要对表进行独占锁定。">使用常规插入加载表</a> ”</span></p>
                                 </li>
                                 <li>
                                    <p>有关使用提示的详细信息，请<a href="https://www.oracle.com/pls/topic/lookup?ctx=en/database/oracle/oracle-database/19/admin&amp;id=TGSQL259" target="_blank"><span class="italic">参见“Oracle数据库SQL调优指南”</span></a></p>
                                 </li>
                                 <li>
                                    <p>有关<code class="codeph">INSERT</code>语句的子查询语法以及使用直接路径<code class="codeph">INSERT</code>其他限制的更多信息，请<a href="https://www.oracle.com/pls/topic/lookup?ctx=en/database/oracle/oracle-database/19/admin&amp;id=SQLRF01604" target="_blank"><span class="italic">参见Oracle数据库SQL语言参考</span></a></p>
                                 </li>
                              </ul>
                           </div>
                           <div class="familylinks">
                              <div class="parentlink">
                                 <p><strong>父主题：</strong> <a href="managing-tables.html#GUID-93B8D899-B508-4961-A1E7-F141531B0469" title="您可以使用直接路径INSERT SQL语句，以并行模式插入数据或使用直接路径模式下的Oracle SQL * Loader实用程序来使用直接路径INSERT加载数据。直接路径INSERT可以以串行或并行模式完成。">使用Direct-Path INSERT加载数据</a></p>
                              </div>
                           </div>
                        </div>
                        
                     </div>
                  </div><a id="ADMIN11649"></a><div class="props_rev_3"><a id="GUID-C5C17959-0BB5-4764-8E6F-799B4DC80F5D" name="GUID-C5C17959-0BB5-4764-8E6F-799B4DC80F5D"></a><h5 id="ADMIN-GUID-C5C17959-0BB5-4764-8E6F-799B4DC80F5D" class="sect5"><span class="enumeration_section">20.4.2.4</span>直接路径INSERT的记录模式</h5>
                     <div>
                        <p>直接路径<code class="codeph">INSERT</code>允许您选择是否在插入操作期间记录重做和撤消信息。
                        </p>
                        <p>您可以通过以下方式为直接路径<code class="codeph">INSERT</code>指定日志记录模式：</p>
                        <ul style="list-style-type:disc">
                           <li>
                              <p>您可以在创建时（在<code class="codeph">CREATE</code>语句中）或随后（在<code class="codeph">ALTER</code>语句中）为表，分区，索引或<code class="codeph">LOB</code>存储指定日志记录模式。
                              </p>
                           </li>
                           <li>
                              <p>如果您在以下时间未指定<code class="codeph">LOGGING</code>或<code class="codeph">NOLOGGING</code> ：</p>
                              <ul style="list-style-type:disc">
                                 <li>
                                    <p>分区的logging属性默认为其表的logging属性。</p>
                                 </li>
                                 <li>
                                    <p>表或索引的logging属性默认为它所驻留的表空间的logging属性。</p>
                                 </li>
                                 <li>
                                    <p>的日志记录属性<code class="codeph">LOB</code>存储默认为<code class="codeph">LOGGING</code>如果指定<code class="codeph">CACHE</code>的<code class="codeph">LOB</code>存储。如果未指定<code class="codeph">CACHE</code> ，则日志记录属性默认为<code class="codeph">LOB</code>值所在的表空间的值。
                                    </p>
                                 </li>
                              </ul>
                           </li>
                           <li>
                              <p>您可以在<code class="codeph">CREATE</code> <code class="codeph">TABLESPACE</code>或<code class="codeph">ALTER</code> <code class="codeph">TABLESPACE</code>语句中设置表空间的logging属性。
                              </p>
                              <div class="infoboxnote" id="GUID-C5C17959-0BB5-4764-8E6F-799B4DC80F5D__GUID-0015C951-F55C-44B5-A533-7FDE3945A53C">
                                 <p class="notep1">注意：</p>
                                 <p>如果数据库或表空间处于<code class="codeph">FORCE</code> <code class="codeph">LOGGING</code>模式，则无论日志记录设置如何，直接路径<code class="codeph">INSERT</code>始终都会记录。
                                 </p>
                              </div>
                           </li>
                        </ul>
                     </div>
                     <div>
                        <ul class="ullinks">
                           <li class="ulchildlink"><a href="managing-tables.html#GUID-CCC1353B-02E4-40CB-8235-43EE904260DD">带记录的直接路径INSERT</a><br>在此模式下，Oracle数据库执行完整的重做日志记录以进行实例和介质恢复。
                           </li>
                           <li class="ulchildlink"><a href="managing-tables.html#GUID-D9CE7675-CD18-41BC-820A-D794AF279B96">没有记录的直接路径INSERT</a><br>在此模式下，Oracle数据库无需重做或撤消日志记录即可插入数据。相反，数据库记录少量块范围无效重做记录，并使用有关最近直接写入的信息定期更新控制文件。
                           </li>
                        </ul>
                        <div class="familylinks">
                           <div class="parentlink">
                              <p><strong>父主题：</strong> <a href="managing-tables.html#GUID-134D6EB6-219E-4820-AB54-8C60067A8F0F" title="加载大量数据时，可以使用直接路径INSERT来提高加载性能。">使用Direct-Path INSERT提高INSERT性能</a></p>
                           </div>
                        </div>
                     </div>
                     <a id="ADMIN11650"></a><div class="props_rev_3"><a id="GUID-CCC1353B-02E4-40CB-8235-43EE904260DD" name="GUID-CCC1353B-02E4-40CB-8235-43EE904260DD"></a><h6 id="ADMIN-GUID-CCC1353B-02E4-40CB-8235-43EE904260DD" class="sect6"><span class="enumeration_section">20.4.2.4.1</span>带记录的直接路径INSERT</h6>
                        <div>
                           <p>在此模式下，Oracle数据库执行完整的重做日志记录以进行实例和介质恢复。</p>
                           <p>如果数据库处于<code class="codeph">ARCHIVELOG</code>模式，则可以将重做日志存档到磁带。如果数据库处于<code class="codeph">NOARCHIVELOG</code>模式，则可以恢复实例崩溃，但不能恢复磁盘故障。
                           </p>
                        </div>
                        <div>
                           <div class="familylinks">
                              <div class="parentlink">
                                 <p><strong>父主题：</strong> <a href="managing-tables.html#GUID-C5C17959-0BB5-4764-8E6F-799B4DC80F5D" title="直接路径INSERT允许您选择是否在插入操作期间记录重做和撤消信息。">Direct-Path INSERT的日志记录模式</a></p>
                              </div>
                           </div>
                        </div>
                        
                     </div><a id="ADMIN13485"></a><div class="props_rev_3"><a id="GUID-D9CE7675-CD18-41BC-820A-D794AF279B96" name="GUID-D9CE7675-CD18-41BC-820A-D794AF279B96"></a><h6 id="ADMIN-GUID-D9CE7675-CD18-41BC-820A-D794AF279B96" class="sect6"><span class="enumeration_section">20.4.2.4.2</span>没有记录的直接路径INSERT</h6>
                        <div>
                           <p>在此模式下，Oracle数据库无需重做或撤消日志记录即可插入数据。相反，数据库记录少量块范围无效重做记录，并使用有关最近直接写入的信息定期更新控制文件。</p>
                           <p>没有日志记录的直接路径<code class="codeph">INSERT</code>可提高性能。但是，如果您随后必须执行介质恢复，则失效重做记录会将一系列块标记为逻辑损坏，因为没有为它们记录重做数据。因此，在执行此类插入操作后备份数据非常重要。
                           </p>
                           <p>通过禁用控制文件的定期更新，可以显着提高不可恢复的直接路径插入的性能。您可以通过将初始化参数<code class="codeph">DB_UNRECOVERABLE_SCN_TRACKING</code>设置为<code class="codeph">FALSE</code> 。但是，如果在禁用这些控制文件更新的情况下执行不可恢复的直接路径插入，则将无法再准确查询数据库以确定当前是否有任何数据文件无法恢复。
                           </p>
                        </div>
                        <div>
                           <div class="infoboxnotealso" id="GUID-D9CE7675-CD18-41BC-820A-D794AF279B96__GUID-75AB31B6-390B-4E0E-B0B6-D9B9FC91ED09">
                              <p class="notep1">也可以看看：</p>
                              <p></p>
                              <ul style="list-style-type:disc">
                                 <li>
                                    <p>有关不可恢复的数据文件的详细信息，请参见<a href="https://www.oracle.com/pls/topic/lookup?ctx=en/database/oracle/oracle-database/19/admin&amp;id=BRADV89598" target="_blank"><span class="italic">“Oracle数据库备份和恢复用户指南”</span></a></p>
                                 </li>
                                 <li>
                                    <p><a href="../sbydb/examples-of-using-oracle-data-guard.html#SBYDB4896" target="_blank"><span class="italic">Oracle Data Guard概念和管理中的</span></a> “确定在不可恢复的操作后是否需要备份”部分</p>
                                 </li>
                              </ul>
                           </div>
                           <div class="familylinks">
                              <div class="parentlink">
                                 <p><strong>父主题：</strong> <a href="managing-tables.html#GUID-C5C17959-0BB5-4764-8E6F-799B4DC80F5D" title="直接路径INSERT允许您选择是否在插入操作期间记录重做和撤消信息。">Direct-Path INSERT的日志记录模式</a></p>
                              </div>
                           </div>
                        </div>
                        
                     </div>
                  </div><a id="ADMIN11652"></a><div class="props_rev_3"><a id="GUID-C23CE17E-5F49-4F32-8EF3-5E3B00EAF81A" name="GUID-C23CE17E-5F49-4F32-8EF3-5E3B00EAF81A"></a><h5 id="ADMIN-GUID-C23CE17E-5F49-4F32-8EF3-5E3B00EAF81A" class="sect5"><span class="enumeration_section">20.4.2.5</span>直接路径INSERT的其他注意事项</h5>
                     <div>
                        <p>使用直接路径<code class="codeph">INSERT</code> ，请考虑与压缩表，索引维护，磁盘空间和锁定相关的问题。
                        </p>
                     </div>
                     <div>
                        <ul class="ullinks">
                           <li class="ulchildlink"><a href="managing-tables.html#GUID-DD27876D-D988-4BE6-B3AD-63FE49F5B1AE">压缩表和直接路径INSERT</a><br>如果使用基本表压缩创建表，则必须使用直接路径<code class="codeph">INSERT</code>在加载表时压缩表数据。如果使用高级行，仓库或存档压缩创建表，则使用直接路径<code class="codeph">INSERT</code>可实现最佳压缩比。</li>
                           <li class="ulchildlink"><a href="managing-tables.html#GUID-E7C4E948-9BF7-47BB-874C-F0BD525DD3AF">使用Direct-Path INSERT进行索引维护</a><br>Oracle数据库在对具有索引的表（已分区或未分区）的直接路径<code class="codeph">INSERT</code>操作结束时执行索引维护。
                           </li>
                           <li class="ulchildlink"><a href="managing-tables.html#GUID-251E9E51-9381-4097-8256-0B6D2D37ACE8">直接路径INSERT的空间考虑</a><br>直接路径<code class="codeph">INSERT</code>比传统路径<code class="codeph">INSERT</code>需要更多空间。</li>
                           <li class="ulchildlink"><a href="managing-tables.html#GUID-2E573512-51EA-4470-894A-C4BA20593273">使用Direct-Path INSERT锁定注意事项</a><br>在直接路径<code class="codeph">INSERT</code>期间，数据库获取表（或分区表的所有分区）上的独占锁。
                           </li>
                        </ul>
                        <div class="familylinks">
                           <div class="parentlink">
                              <p><strong>父主题：</strong> <a href="managing-tables.html#GUID-134D6EB6-219E-4820-AB54-8C60067A8F0F" title="加载大量数据时，可以使用直接路径INSERT来提高加载性能。">使用Direct-Path INSERT提高INSERT性能</a></p>
                           </div>
                        </div>
                     </div>
                     <a id="ADMIN12633"></a><div class="props_rev_3"><a id="GUID-DD27876D-D988-4BE6-B3AD-63FE49F5B1AE" name="GUID-DD27876D-D988-4BE6-B3AD-63FE49F5B1AE"></a><h6 id="ADMIN-GUID-DD27876D-D988-4BE6-B3AD-63FE49F5B1AE" class="sect6"><span class="enumeration_section">20.4.2.5.1</span>压缩表和直接路径INSERT</h6>
                        <div>
                           <p>如果使用基本表压缩创建表，则必须使用直接路径<code class="codeph">INSERT</code>在加载表时压缩表数据。如果使用高级行，仓库或存档压缩创建表，则使用直接路径<code class="codeph">INSERT</code>可实现最佳压缩比。</p>
                           <p>有关详细信息，请参阅<span class="q">“ <a href="managing-tables.html#GUID-ED833867-4B7F-442E-A70C-9C19DAA8F445" title="压缩可节省磁盘空间，减少数据库缓冲区高速缓存中的内存使用，并可显着提高读取期间的查询执行速度。">考虑使用表压缩</a> ”</span> 。
                           </p>
                        </div>
                        <div>
                           <div class="familylinks">
                              <div class="parentlink">
                                 <p><strong>父主题：</strong> <a href="managing-tables.html#GUID-C23CE17E-5F49-4F32-8EF3-5E3B00EAF81A">Direct-Path INSERT的其他注意事项</a></p>
                              </div>
                           </div>
                        </div>
                        
                     </div><a id="ADMIN11653"></a><div class="props_rev_3"><a id="GUID-E7C4E948-9BF7-47BB-874C-F0BD525DD3AF" name="GUID-E7C4E948-9BF7-47BB-874C-F0BD525DD3AF"></a><h6 id="ADMIN-GUID-E7C4E948-9BF7-47BB-874C-F0BD525DD3AF" class="sect6"><span class="enumeration_section">20.4.2.5.2</span>使用Direct-Path INSERT进行索引维护</h6>
                        <div>
                           <p>Oracle数据库在对具有索引的表（已分区或未分区）的直接路径<code class="codeph">INSERT</code>操作结束时执行索引维护。
                           </p>
                           <p>此索引维护由并行执行服务器执行，用于并行直接路径<code class="codeph">INSERT</code>或由单个进程执行串行直接路径<code class="codeph">INSERT</code> 。您可以通过在<code class="codeph">INSERT</code>操作之前使索引不可用然后在之后重建它来避免索引维护对性能的影响。
                           </p>
                        </div>
                        <div>
                           <div class="infoboxnotealso" id="GUID-E7C4E948-9BF7-47BB-874C-F0BD525DD3AF__GUID-522B2276-102E-488B-BA67-F300F4EC93C2">
                              <p class="notep1">也可以看看：</p>
                              <p><span class="q">“ <a href="managing-indexes.html#GUID-A7A6C478-78CC-4A49-B2DB-A7F46BD57692" title="如果使索引不可用，优化程序将忽略该索引，并且不由DML维护。当您使分区索引的一个分区不可用时，索引的其他分区仍然有效。">使索引无法使用</a> ”</span></p>
                           </div>
                           <div class="familylinks">
                              <div class="parentlink">
                                 <p><strong>父主题：</strong> <a href="managing-tables.html#GUID-C23CE17E-5F49-4F32-8EF3-5E3B00EAF81A">Direct-Path INSERT的其他注意事项</a></p>
                              </div>
                           </div>
                        </div>
                        
                     </div><a id="ADMIN11654"></a><div class="props_rev_3"><a id="GUID-251E9E51-9381-4097-8256-0B6D2D37ACE8" name="GUID-251E9E51-9381-4097-8256-0B6D2D37ACE8"></a><h6 id="ADMIN-GUID-251E9E51-9381-4097-8256-0B6D2D37ACE8" class="sect6"><span class="enumeration_section">20.4.2.5.3</span>使用直接路径INSERT的空间考虑因素</h6>
                        <div>
                           <p>直接路径<code class="codeph">INSERT</code>比传统路径<code class="codeph">INSERT</code>需要更多空间。</p>
                           <p>所有串行直接路径<code class="codeph">INSERT</code>操作以及并行直接路径<code class="codeph">INSERT</code>到分区表中，都会在受影响段的高水位线上方插入数据。这需要一些额外的空间。
                           </p>
                           <p>并行直接路径<code class="codeph">INSERT</code>到非分区表需要更多空间，因为它为每个并行度创建一个临时段。如果非分区表在自动段空间管理模式下不在本地管理的表空间中，则可以修改<code class="codeph">NEXT</code>和<code class="codeph">PCTINCREASE</code>存储参数和<code class="codeph">MINIMUM</code> <code class="codeph">EXTENT</code>表空间参数的值，以便为临时段提供足够（但不过量）的存储。选择这些参数的值，以便：</p>
                           <ul style="list-style-type:disc">
                              <li>
                                 <p>每个范围的大小不能太小（不小于1 MB）。此设置会影响对象中的区域总数。</p>
                              </li>
                              <li>
                                 <p>每个范围的大小不是很大，以至于并行<code class="codeph">INSERT</code>导致大于必要的段上的空间浪费。
                                 </p>
                              </li>
                           </ul>
                           <p>直接路径<code class="codeph">INSERT</code>操作完成后，您可以将这些参数重置为更适合串行操作的设置。
                           </p>
                        </div>
                        <div>
                           <div class="familylinks">
                              <div class="parentlink">
                                 <p><strong>父主题：</strong> <a href="managing-tables.html#GUID-C23CE17E-5F49-4F32-8EF3-5E3B00EAF81A">Direct-Path INSERT的其他注意事项</a></p>
                              </div>
                           </div>
                        </div>
                        
                     </div><a id="ADMIN11655"></a><div class="props_rev_3"><a id="GUID-2E573512-51EA-4470-894A-C4BA20593273" name="GUID-2E573512-51EA-4470-894A-C4BA20593273"></a><h6 id="ADMIN-GUID-2E573512-51EA-4470-894A-C4BA20593273" class="sect6"><span class="enumeration_section">20.4.2.5.4</span>使用直接路径INSERT锁定注意事项</h6>
                        <div>
                           <p>在直接路径<code class="codeph">INSERT</code>期间，数据库获取表（或分区表的所有分区）上的独占锁。
                           </p>
                           <p>因此，用户无法对表执行任何并发插入，更新或删除操作，并且不允许并发索引创建和构建操作。但是，支持并发查询，但查询将仅在插入操作之前返回信息。</p>
                        </div>
                        <div>
                           <div class="familylinks">
                              <div class="parentlink">
                                 <p><strong>父主题：</strong> <a href="managing-tables.html#GUID-C23CE17E-5F49-4F32-8EF3-5E3B00EAF81A">Direct-Path INSERT的其他注意事项</a></p>
                              </div>
                           </div>
                        </div>
                        
                     </div>
                  </div>
               </div><a id="ADMIN13494"></a><div class="props_rev_3"><a id="GUID-9B894C55-5D79-4AA9-95DE-C216D6C417E8" name="GUID-9B894C55-5D79-4AA9-95DE-C216D6C417E8"></a><h4 id="ADMIN-GUID-9B894C55-5D79-4AA9-95DE-C216D6C417E8" class="sect4"><span class="enumeration_section">20.4.3</span>使用常规插入加载表</h4>
                  <div>
                     <p>在<span class="bold">传统的INSERT操作</span>期间，数据库重用表中的空闲空间，将新插入的数据与现有数据交错。在此类操作期间，数据库还维护参照完整性约束。与直接路径<code class="codeph">INSERT</code>操作不同，传统的<code class="codeph">INSERT</code>操作不需要对表进行独占锁定。
                     </p>
                     <div class="section">
                        <p>其他几个限制适用于直接路径<code class="codeph">INSERT</code> ，并不适用于常规操作<code class="codeph">INSERT</code>操作。有关这些限制的信息，请参见<a href="https://www.oracle.com/pls/topic/lookup?ctx=en/database/oracle/oracle-database/19/admin&amp;id=SQLRF55049" target="_blank"><span class="italic">Oracle数据库SQL语言参考</span></a> 。
                        </p>
                        <p>您可以使用<code class="codeph">NOAPPEND</code>提示以串行模式或并行模式执行传统的<code class="codeph">INSERT</code>操作。
                        </p>
                        <p>以下是使用<code class="codeph">NOAPPEND</code>提示在串行模式下执行常规<code class="codeph">INSERT</code>的示例：</p><pre class="oac_no_warn" dir="ltr">INSERT / * + NOAPPEND * / INTO sales_hist SELECT * FROM sales WHERE cust_id = 8890;</pre><p>以下是使用<code class="codeph">NOAPPEND</code>提示以并行模式执行传统<code class="codeph">INSERT</code>的示例：</p><pre class="oac_no_warn" dir="ltr">INSERT / * + NOAPPEND PARALLEL * / INTO sales_hist SELECT * FROM sales;</pre><p>要以并行DML模式运行，必须满足以下要求：</p>
                     </div>
                     <!-- class="section" -->
                     <div class="section">
                        <ul style="list-style-type:disc">
                           <li>
                              <p>您必须安装Oracle Enterprise Edition。</p>
                           </li>
                           <li>
                              <p>您必须在会话中启用并行DML。为此，请提交以下声明：</p><pre class="oac_no_warn" dir="ltr">ALTER SESSION {ENABLE | FORCE} PARALLEL DML;</pre></li>
                           <li>
                              <p>您必须满足以下至少一项要求：</p>
                              <ul style="list-style-type:disc">
                                 <li>
                                    <p>在创建时或随后指定目标表的并行属性</p>
                                 </li>
                                 <li>
                                    <p>为每个插入操作指定<code class="codeph">PARALLEL</code>提示</p>
                                 </li>
                                 <li>
                                    <p>将数据库初始化参数<code class="codeph">PARALLEL_DEGREE_POLICY</code>为<code class="codeph">AUTO</code></p>
                                 </li>
                              </ul>
                           </li>
                        </ul>
                     </div>
                     <!-- class="section" -->
                  </div>
                  <div>
                     <div class="familylinks">
                        <div class="parentlink">
                           <p><strong>父主题：</strong> <a href="managing-tables.html#GUID-7B5676FC-59B4-418F-826B-8F4D7E3690E2" title="有几种将数据加载到表中的技术。">加载表</a></p>
                        </div>
                     </div>
                  </div>
                  
               </div>
               <div class="sect3"><a id="GUID-36DB026B-4702-477A-92C4-EA2795D2B37F" name="GUID-36DB026B-4702-477A-92C4-EA2795D2B37F"></a><h4 id="ADMIN-GUID-36DB026B-4702-477A-92C4-EA2795D2B37F" class="sect4"><span class="enumeration_section">20.4.4</span>使用DML错误记录避免批量INSERT失败</h4>
                  <p>您可以使用DML错误日志记录功能来避免批量<code class="codeph">INSERT</code>故障。
                  </p>
                  <div>
                     <ul class="ullinks">
                        <li class="ulchildlink"><a href="managing-tables.html#GUID-B71385AD-2D21-42F3-9249-3D6364887746">使用DML错误记录插入数据</a><br>使用<code class="codeph">INSERT</code>查询的<code class="codeph">INSERT</code>语句加载表时，如果发生错误，则语句将终止并完全回滚。这可能浪费时间和系统资源。对于此类<code class="codeph">INSERT</code>语句，可以使用DML错误日志记录功能来避免这种情况。
                        </li>
                        <li class="ulchildlink"><a href="managing-tables.html#GUID-6377C9FD-1243-451A-8345-D84D187A929E">错误记录表格式</a><br>错误记录表具有特定格式。
                        </li>
                        <li class="ulchildlink"><a href="managing-tables.html#GUID-4E5F45D4-DA96-48AE-A3DD-7AC5C1C11076">创建错误记录表</a><br>您可以手动创建错误日志记录表，也可以使用PL / SQL包自动为您创建一个。
                        </li>
                        <li class="ulchildlink"><a href="managing-tables.html#GUID-B8C0D6EE-6D5E-4415-90F5-81B310201440">错误记录限制和警告</a><br>错误记录表中未记录某些错误。
                        </li>
                     </ul>
                     <div class="familylinks">
                        <div class="parentlink">
                           <p><strong>父主题：</strong> <a href="managing-tables.html#GUID-7B5676FC-59B4-418F-826B-8F4D7E3690E2" title="有几种将数据加载到表中的技术。">加载表</a></p>
                        </div>
                     </div>
                  </div>
                  <a id="ADMIN12632"></a><a id="ADMIN10261"></a><div class="props_rev_3"><a id="GUID-B71385AD-2D21-42F3-9249-3D6364887746" name="GUID-B71385AD-2D21-42F3-9249-3D6364887746"></a><h5 id="ADMIN-GUID-B71385AD-2D21-42F3-9249-3D6364887746" class="sect5"><span class="enumeration_section">20.4.4.1</span>使用DML错误记录插入数据</h5>
                     <div>
                        <p>使用<code class="codeph">INSERT</code>查询的<code class="codeph">INSERT</code>语句加载表时，如果发生错误，则语句将终止并完全回滚。这可能浪费时间和系统资源。对于此类<code class="codeph">INSERT</code>语句，可以使用DML错误日志记录功能来避免这种情况。
                        </p>
                        <div class="section">
                           <p>要使用DML错误日志记录，请添加一个语句子句，该子句指定错误日志记录表的名称，数据库记录DML操作期间遇到的错误。将此错误日志记录子句添加到<code class="codeph">INSERT</code>语句时，某些类型的错误不再终止并回滚该语句。而是记录每个错误并继续声明。然后，您可以在以后对错误的行采取纠正措施。
                           </p>
                           <p>DML错误日志记录与<code class="codeph">INSERT</code> ， <code class="codeph">UPDATE</code> ， <code class="codeph">MERGE</code>和<code class="codeph">DELETE</code>语句一起使用。本节重点介绍<code class="codeph">INSERT</code>语句。
                           </p>
                           <p>要使用DML错误日志记录插入数据：</p>
                        </div>
                        <!-- class="section" -->
                        <ol>
                           <li class="stepexpand"><span>创建错误记录表。（可选的）</span><div>
                                 <p>您可以手动创建表，也可以使用<code class="codeph">DBMS_ERRLOG</code>包自动为您创建表。有关详细信息，请参阅<span class="q">“ <a href="managing-tables.html#GUID-4E5F45D4-DA96-48AE-A3DD-7AC5C1C11076" title="您可以手动创建错误日志记录表，也可以使用PL / SQL包自动为您创建一个。">创建错误记录表</a> ”</span> 。
                                 </p>
                              </div>
                           </li>
                           <li class="stepexpand"><span>执行<code class="codeph">INSERT</code>语句并包含错误记录子句。本条款：</span><div>
                                 <ul style="list-style-type:disc">
                                    <li>
                                       <p>（可选）引用您创建的错误日志记录表。如果未提供错误日志记录表名称，则数据库将使用默认名称登录到错误日志记录表。默认错误记录表名称是<code class="codeph">ERR$_</code>后跟要插入的表名称的前25个字符。
                                       </p>
                                    </li>
                                    <li>
                                       <p>（可选）包括一个<span class="bold">标记</span> （括号中的数字或字符串文字），它被添加到错误日志中以帮助识别导致错误的语句。如果省略标记，则使用<code class="codeph">NULL</code>值。
                                       </p>
                                    </li>
                                    <li>
                                       <p>可选地包括<code class="codeph">REJECT LIMIT</code>子条款。
                                       </p>
                                       <p>此子句指示<code class="codeph">INSERT</code>语句终止和回滚之前可能遇到的最大错误数。您也可以指定<code class="codeph">UNLIMITED</code> 。默认拒绝限制为零，这意味着在遇到第一个错误时，将记录错误并回滚语句。对于并行DML操作，拒绝限制应用于每个并行执行服务器。
                                       </p>
                                    </li>
                                 </ul>
                                 <div class="infoboxnote" id="GUID-B71385AD-2D21-42F3-9249-3D6364887746__GUID-96A6F051-18E5-4B50-9883-043665D24BF6">
                                    <p class="notep1">注意：</p>
                                    <p>如果语句超出拒绝限制并回滚，则错误记录表将保留到目前为止记录的日志条目。</p>
                                 </div>
                                 <p>有关错误记录子句语法信息，请参见<a href="../sqlrf/INSERT.html#SQLRF55061" target="_blank"><span class="italic">Oracle数据库SQL语言参考</span></a> 。
                                 </p>
                              </div>
                           </li>
                           <li class="stepexpand"><span>查询错误记录表并对生成错误的行采取纠正措施。</span><div>
                                 <p>有关错误记录表结构的详细信息，请参阅本节后面的<span class="q">“ <a href="managing-tables.html#GUID-6377C9FD-1243-451A-8345-D84D187A929E" title="错误记录表具有特定格式。">错误记录表格式</a> ”</span> 。
                                 </p>
                              </div>
                           </li>
                        </ol>
                        <div class="example" id="GUID-B71385AD-2D21-42F3-9249-3D6364887746__GUID-F50D13D3-C365-4AA2-8113-282AFE79F4BE">
                           <p class="titleinexample">示例20-9使用DML错误记录插入数据</p>
                           <p>以下语句将行插入<code class="codeph">DW_EMPL</code>表，并将错误记录到<code class="codeph">ERR_EMPL</code>表。标记' <code class="codeph">daily_load</code> '被复制到每个日志条目。如果错误数超过25，语句将终止并回滚。
                           </p><pre class="oac_no_warn" dir="ltr">INSERT INTO dw_empl SELECT employee_id，first_name，last_name，hire_date，salary，department_id FROM employees WHERE hire_date&gt; sysdate  -  7 LOG ERRORS INTO err_empl（'daily_load'）REJECT LIMIT 25</pre><p>有关更多示例，请参阅“ <a href="../sqlrf/INSERT.html#SQLRF55104" target="_blank"><span class="italic">Oracle数据库SQL语言参考”</span></a>和“ <a href="https://www.oracle.com/pls/topic/lookup?ctx=en/database/oracle/oracle-database/19/admin&amp;id=DWHSG8337" target="_blank"><span class="italic">Oracle数据库数据仓库指南”</span></a> 。
                           </p>
                        </div>
                        <!-- class="example" -->
                     </div>
                     <div>
                        <div class="familylinks">
                           <div class="parentlink">
                              <p><strong>父主题：</strong> <a href="managing-tables.html#GUID-36DB026B-4702-477A-92C4-EA2795D2B37F" title="您可以使用DML错误日志记录功能来避免批量INSERT故障。">使用DML错误记录避免批量INSERT故障</a></p>
                           </div>
                        </div>
                     </div>
                     
                  </div><a id="ADMIN13064"></a><a id="ADMIN13065"></a><a id="ADMIN11636"></a><div class="props_rev_3"><a id="GUID-6377C9FD-1243-451A-8345-D84D187A929E" name="GUID-6377C9FD-1243-451A-8345-D84D187A929E"></a><h5 id="ADMIN-GUID-6377C9FD-1243-451A-8345-D84D187A929E" class="sect5"><span class="enumeration_section">20.4.4.2</span>错误记录表格式</h5>
                     <div>
                        <p>错误记录表具有特定格式。</p>
                        <p>错误记录表由两部分组成：</p>
                        <ul style="list-style-type:disc">
                           <li>
                              <p>描述错误的一组必需列。例如，一列包含Oracle错误号。</p>
                              <p><a href="managing-tables.html#GUID-6377C9FD-1243-451A-8345-D84D187A929E__CJABHICH" title="此表包含5行，每个行对应于错误记录表中的每个必需错误描述列。列出每个列名称及其数据类型和描述。列是Oracle错误号，错误消息文本，行ID，导致错误的操作类型，以及来自log errors子句的用户定义标记。">表20-4</a>列出了这些错误描述列。
                              </p>
                           </li>
                           <li>
                              <p>一组可选列，包含导致错误的行中的数据。列名称与要插入的表中的列名称匹配（“DML表”）。</p>
                              <p>错误记录表的这一部分中的列数可以是零，一个或多个，直到DML表中的列数。如果错误日志记录表中存在与DML表中的列同名的列，则插入的有问题行的相应数据将写入此错误日志记录表列。如果DML表列在错误日志记录表中没有对应的列，则不会记录该列。如果错误日志记录表包含名称与DML表列不匹配的列，则忽略该列。</p>
                              <p>由于类型转换错误是可能发生的一种错误，因此错误日志记录表中可选列的数据类型必须是能够捕获任何值而不会丢失数据或转换错误的类型。（如果可选的日志列与DML表列的类型相同，则将有问题的数据捕获到日志中可能会遇到导致错误的相同数据转换问题。）数据库尽最大努力为导致转换错误的数据记录有意义的值。如果无法导出值，则会为该列记录<code class="codeph">NULL</code> 。插入错误日志记录表时出错导致语句终止。
                              </p>
                              <p><a href="managing-tables.html#GUID-6377C9FD-1243-451A-8345-D84D187A929E__CJADIFDC" title="此表包含7行，其中每行列出DML表中的数据类型以及错误记录表中的相应数据类型。例如，NUMBER，DATE和所有字符类型的数据类型都会获得相应的错误日志数据类型VARCHAR2或NVARCHAR2。">表20-5</a>列出了DML表中用于每种数据类型的建议错误记录表列数据类型。使用<code class="codeph">DBMS_ERRLOG</code>包自动创建错误日志记录表时，将使用这些建议的数据类型。
                              </p>
                           </li>
                        </ul>
                        <div class="tblformalwide" id="GUID-6377C9FD-1243-451A-8345-D84D187A929E__CJABHICH">
                           <p class="titleintable">表20-4强制错误说明列</p>
                           <table cellpadding="4" cellspacing="0" class="FormalWide" title="强制错误说明列" width="100%" border="1" summary="This table contains 5 rows, one for each of the mandatory error description columns in the error logging table. Each column name is listed with its data type and a description. The columns are Oracle error number, error message text, row ID, type of operation that caused the error, and the user-defined tag from the log errors clause." frame="hsides" rules="rows">
                              <thead>
                                 <tr align="left" valign="top">
                                    <th align="left" valign="bottom" id="d192334e8175">列名称</th>
                                    <th align="left" valign="bottom" id="d192334e8178">数据类型</th>
                                    <th align="left" valign="bottom" id="d192334e8181">描述</th>
                                 </tr>
                              </thead>
                              <tbody>
                                 <tr align="left" valign="top">
                                    <td align="left" valign="top" id="d192334e8186" headers="d192334e8175 ">
                                       <p><code class="codeph">ORA_ERR_NUMBER $</code></p>
                                    </td>
                                    <td align="left" valign="top" headers="d192334e8186 d192334e8178 ">
                                       <p><code class="codeph">数</code></p>
                                    </td>
                                    <td align="left" valign="top" headers="d192334e8186 d192334e8181 ">
                                       <p>Oracle错误号</p>
                                    </td>
                                 </tr>
                                 <tr align="left" valign="top">
                                    <td align="left" valign="top" id="d192334e8198" headers="d192334e8175 ">
                                       <p><code class="codeph">ORA_ERR_MESG $</code></p>
                                    </td>
                                    <td align="left" valign="top" headers="d192334e8198 d192334e8178 ">
                                       <p><code class="codeph">VARCHAR2（2000）</code></p>
                                    </td>
                                    <td align="left" valign="top" headers="d192334e8198 d192334e8181 ">
                                       <p>Oracle错误消息文本</p>
                                    </td>
                                 </tr>
                                 <tr align="left" valign="top">
                                    <td align="left" valign="top" id="d192334e8210" headers="d192334e8175 ">
                                       <p><code class="codeph">ORA_ERR_ROWID $</code></p>
                                    </td>
                                    <td align="left" valign="top" headers="d192334e8210 d192334e8178 ">
                                       <p><code class="codeph">ROWID</code></p>
                                    </td>
                                    <td align="left" valign="top" headers="d192334e8210 d192334e8181 ">
                                       <p>错误行的Rowid（用于更新和删除）</p>
                                    </td>
                                 </tr>
                                 <tr align="left" valign="top">
                                    <td align="left" valign="top" id="d192334e8222" headers="d192334e8175 ">
                                       <p><code class="codeph">ORA_ERR_OPTYP $</code></p>
                                    </td>
                                    <td align="left" valign="top" headers="d192334e8222 d192334e8178 ">
                                       <p><code class="codeph">VARCHAR2（2）</code></p>
                                    </td>
                                    <td align="left" valign="top" headers="d192334e8222 d192334e8181 ">
                                       <p>操作类型：插入（ <code class="codeph">I</code> ），更新（ <code class="codeph">U</code> ），删除（ <code class="codeph">D</code> ）</p>
                                       <p>注意： <code class="codeph">MERGE</code>操作的update子句和insert子句中的错误由<code class="codeph">U</code>和<code class="codeph">I</code>值区分。
                                       </p>
                                    </td>
                                 </tr>
                                 <tr align="left" valign="top">
                                    <td align="left" valign="top" id="d192334e8254" headers="d192334e8175 ">
                                       <p><code class="codeph">ORA_ERR_TAG $</code></p>
                                    </td>
                                    <td align="left" valign="top" headers="d192334e8254 d192334e8178 ">
                                       <p><code class="codeph">VARCHAR2（2000）</code></p>
                                    </td>
                                    <td align="left" valign="top" headers="d192334e8254 d192334e8181 ">
                                       <p>用户在错误记录子句中提供的标记的值</p>
                                    </td>
                                 </tr>
                              </tbody>
                           </table>
                        </div>
                        <!-- class="inftblhruleinformal" -->
                        <div class="tblformalwide" id="GUID-6377C9FD-1243-451A-8345-D84D187A929E__CJADIFDC">
                           <p class="titleintable">表20-5错误记录表列数据类型</p>
                           <table cellpadding="4" cellspacing="0" class="FormalWide" title="记录表列数据类型时出错" width="100%" border="1" summary="This table contains 7 rows, where each row lists a data type from the DML table and the corresponding data type in the error logging table. For example, the data types of NUMBER, DATE, and all character types get a corresponding error log data type of VARCHAR2 or NVARCHAR2." frame="hsides" rules="rows">
                              <thead>
                                 <tr align="left" valign="top">
                                    <th align="left" valign="bottom" id="d192334e8276">DML表列类型</th>
                                    <th align="left" valign="bottom" id="d192334e8279">错误记录表列类型</th>
                                    <th align="left" valign="bottom" id="d192334e8282">笔记</th>
                                 </tr>
                              </thead>
                              <tbody>
                                 <tr align="left" valign="top">
                                    <td align="left" valign="top" id="d192334e8287" headers="d192334e8276 ">
                                       <p><code class="codeph">数</code></p>
                                    </td>
                                    <td align="left" valign="top" headers="d192334e8287 d192334e8279 ">
                                       <p><code class="codeph">VARCHAR2（4000）</code></p>
                                    </td>
                                    <td align="left" valign="top" headers="d192334e8287 d192334e8282 ">
                                       <p>能够记录转换错误</p>
                                    </td>
                                 </tr>
                                 <tr align="left" valign="top">
                                    <td align="left" valign="top" id="d192334e8299" headers="d192334e8276 ">
                                       <p><code class="codeph">CHAR / VARCHAR2（n）的</code></p>
                                    </td>
                                    <td align="left" valign="top" headers="d192334e8299 d192334e8279 ">
                                       <p><code class="codeph">VARCHAR2（4000）</code></p>
                                    </td>
                                    <td align="left" valign="top" headers="d192334e8299 d192334e8282 ">
                                       <p>记录任何值而不丢失信息</p>
                                    </td>
                                 </tr>
                                 <tr align="left" valign="top">
                                    <td align="left" valign="top" id="d192334e8311" headers="d192334e8276 ">
                                       <p><code class="codeph">NCHAR / NVARCHAR2（n）的</code></p>
                                    </td>
                                    <td align="left" valign="top" headers="d192334e8311 d192334e8279 ">
                                       <p><code class="codeph">NVARCHAR2（4000）</code></p>
                                    </td>
                                    <td align="left" valign="top" headers="d192334e8311 d192334e8282 ">
                                       <p>记录任何值而不丢失信息</p>
                                    </td>
                                 </tr>
                                 <tr align="left" valign="top">
                                    <td align="left" valign="top" id="d192334e8323" headers="d192334e8276 ">
                                       <p><code class="codeph">DATE / TIMESTAMP</code></p>
                                    </td>
                                    <td align="left" valign="top" headers="d192334e8323 d192334e8279 ">
                                       <p><code class="codeph">VARCHAR2（4000）</code></p>
                                    </td>
                                    <td align="left" valign="top" headers="d192334e8323 d192334e8282 ">
                                       <p>记录任何值而不丢失信息。使用默认日期/时间格式掩码转换为字符格式</p>
                                    </td>
                                 </tr>
                                 <tr align="left" valign="top">
                                    <td align="left" valign="top" id="d192334e8335" headers="d192334e8276 ">
                                       <p><code class="codeph">生的</code></p>
                                    </td>
                                    <td align="left" valign="top" headers="d192334e8335 d192334e8279 ">
                                       <p><code class="codeph">RAW（2000）</code></p>
                                    </td>
                                    <td align="left" valign="top" headers="d192334e8335 d192334e8282 ">
                                       <p>记录任何值而不丢失信息</p>
                                    </td>
                                 </tr>
                                 <tr align="left" valign="top">
                                    <td align="left" valign="top" id="d192334e8347" headers="d192334e8276 ">
                                       <p><code class="codeph">ROWID</code></p>
                                    </td>
                                    <td align="left" valign="top" headers="d192334e8347 d192334e8279 ">
                                       <p><code class="codeph">UROWID</code></p>
                                    </td>
                                    <td align="left" valign="top" headers="d192334e8347 d192334e8282 ">
                                       <p>记录任何rowid类型</p>
                                    </td>
                                 </tr>
                                 <tr align="left" valign="top">
                                    <td align="left" valign="top" id="d192334e8359" headers="d192334e8276 ">
                                       <p><code class="codeph">LONG / LOB</code></p>
                                    </td>
                                    <td align="left" valign="top" headers="d192334e8359 d192334e8279 ">
                                       <p></p>
                                    </td>
                                    <td align="left" valign="top" headers="d192334e8359 d192334e8282 ">
                                       <p>不支持</p>
                                    </td>
                                 </tr>
                                 <tr align="left" valign="top">
                                    <td align="left" valign="top" id="d192334e8369" headers="d192334e8276 ">
                                       <p>用户定义的类型</p>
                                    </td>
                                    <td align="left" valign="top" headers="d192334e8369 d192334e8279 ">
                                       <p></p>
                                    </td>
                                    <td align="left" valign="top" headers="d192334e8369 d192334e8282 ">
                                       <p>不支持</p>
                                    </td>
                                 </tr>
                              </tbody>
                           </table>
                        </div>
                        <!-- class="inftblhruleinformal" -->
                     </div>
                     <div>
                        <div class="familylinks">
                           <div class="parentlink">
                              <p><strong>父主题：</strong> <a href="managing-tables.html#GUID-36DB026B-4702-477A-92C4-EA2795D2B37F" title="您可以使用DML错误日志记录功能来避免批量INSERT故障。">使用DML错误记录避免批量INSERT故障</a></p>
                           </div>
                        </div>
                     </div>
                     
                  </div><a id="ADMIN11637"></a><div class="props_rev_3"><a id="GUID-4E5F45D4-DA96-48AE-A3DD-7AC5C1C11076" name="GUID-4E5F45D4-DA96-48AE-A3DD-7AC5C1C11076"></a><h5 id="ADMIN-GUID-4E5F45D4-DA96-48AE-A3DD-7AC5C1C11076" class="sect5"><span class="enumeration_section">20.4.4.3</span>创建错误记录表</h5>
                     <p>您可以手动创建错误日志记录表，也可以使用PL / SQL包自动为您创建一个。</p>
                     <div>
                        <ul class="ullinks">
                           <li class="ulchildlink"><a href="managing-tables.html#GUID-4507BD65-0B16-49C2-935B-9F8292340FE1">自动创建错误记录表</a><br>您使用<code class="codeph">DBMS_ERRLOG</code>包自动创建错误记录表。
                           </li>
                           <li class="ulchildlink"><a href="managing-tables.html#GUID-CB420DE8-506F-4D08-B876-C5806B75B9D5">手动创建错误记录表</a><br>您使用标准DDL手动创建错误日志记录表。
                           </li>
                        </ul>
                        <div class="familylinks">
                           <div class="parentlink">
                              <p><strong>父主题：</strong> <a href="managing-tables.html#GUID-36DB026B-4702-477A-92C4-EA2795D2B37F" title="您可以使用DML错误日志记录功能来避免批量INSERT故障。">使用DML错误记录避免批量INSERT故障</a></p>
                           </div>
                        </div>
                     </div>
                     <a id="ADMIN11638"></a><div class="props_rev_3"><a id="GUID-4507BD65-0B16-49C2-935B-9F8292340FE1" name="GUID-4507BD65-0B16-49C2-935B-9F8292340FE1"></a><h6 id="ADMIN-GUID-4507BD65-0B16-49C2-935B-9F8292340FE1" class="sect6"><span class="enumeration_section">20.4.4.3.1</span>自动创建错误记录表</h6>
                        <div>
                           <p>您使用<code class="codeph">DBMS_ERRLOG</code>包自动创建错误记录表。
                           </p>
                           <div class="section">
                              <p><code class="codeph">CREATE_ERROR_LOG</code>过程创建一个错误记录表，其中包含所有必需的错误描述列以及指定DML表中的所有列，并执行<a href="managing-tables.html#GUID-6377C9FD-1243-451A-8345-D84D187A929E__CJADIFDC" title="此表包含7行，其中每行列出DML表中的数据类型以及错误记录表中的相应数据类型。例如，NUMBER，DATE和所有字符类型的数据类型都会获得相应的错误日志数据类型VARCHAR2或NVARCHAR2。">表20-5中</a>所示的数据类型映射。
                              </p>
                              <p>以下语句创建上一个示例中使用的错误记录表。</p><pre class="oac_no_warn" dir="ltr">EXECUTE DBMS_ERRLOG.CREATE_ERROR_LOG（'DW_EMPL'，'ERR_EMPL'）;</pre><p>有关<code class="codeph">DBMS_ERRLOG</code>详细信息，请参阅<a href="https://www.oracle.com/pls/topic/lookup?ctx=en/database/oracle/oracle-database/19/admin&amp;id=ARPLS680" target="_blank"><span class="italic">Oracle Database PL / SQL包和类型参考</span></a> 。</p>
                           </div>
                           <!-- class="section" -->
                        </div>
                        <div>
                           <div class="familylinks">
                              <div class="parentlink">
                                 <p><strong>父主题：</strong> <a href="managing-tables.html#GUID-4E5F45D4-DA96-48AE-A3DD-7AC5C1C11076" title="您可以手动创建错误日志记录表，也可以使用PL / SQL包自动为您创建一个。">创建错误记录表</a></p>
                              </div>
                           </div>
                        </div>
                        
                     </div><a id="ADMIN11639"></a><div class="props_rev_3"><a id="GUID-CB420DE8-506F-4D08-B876-C5806B75B9D5" name="GUID-CB420DE8-506F-4D08-B876-C5806B75B9D5"></a><h6 id="ADMIN-GUID-CB420DE8-506F-4D08-B876-C5806B75B9D5" class="sect6"><span class="enumeration_section">20.4.4.3.2</span>手动创建错误记录表</h6>
                        <div>
                           <p>您使用标准DDL手动创建错误日志记录表。</p>
                           <div class="section">
                              <p>有关表结构要求，请参阅<span class="q">“ <a href="managing-tables.html#GUID-6377C9FD-1243-451A-8345-D84D187A929E" title="错误记录表具有特定格式。">错误记录表格式</a> ”</span> 。您必须包含所有必填错误说明列。它们可以是任何顺序，但必须是表中的第一列。
                              </p>
                           </div>
                           <!-- class="section" -->
                        </div>
                        <div>
                           <div class="familylinks">
                              <div class="parentlink">
                                 <p><strong>父主题：</strong> <a href="managing-tables.html#GUID-4E5F45D4-DA96-48AE-A3DD-7AC5C1C11076" title="您可以手动创建错误日志记录表，也可以使用PL / SQL包自动为您创建一个。">创建错误记录表</a></p>
                              </div>
                           </div>
                        </div>
                        
                     </div>
                  </div><a id="ADMIN11640"></a><div class="props_rev_3"><a id="GUID-B8C0D6EE-6D5E-4415-90F5-81B310201440" name="GUID-B8C0D6EE-6D5E-4415-90F5-81B310201440"></a><h5 id="ADMIN-GUID-B8C0D6EE-6D5E-4415-90F5-81B310201440" class="sect5"><span class="enumeration_section">20.4.4.4</span>错误记录限制和注意事项</h5>
                     <div>
                        <p>错误记录表中未记录某些错误。</p>
                        <p>Oracle数据库在DML操作期间记录以下错误：</p>
                        <ul style="list-style-type:disc">
                           <li>
                              <p>列值太大</p>
                           </li>
                           <li>
                              <p>约束违规（ <code class="codeph">NOT</code> <code class="codeph">NULL</code> ，唯一，引用和检查约束）</p>
                           </li>
                           <li>
                              <p>触发器执行期间引发的错误</p>
                           </li>
                           <li>
                              <p>子查询中的列与表的相应列之间的类型转换导致的错误</p>
                           </li>
                           <li>
                              <p>分区映射错误</p>
                           </li>
                           <li>
                              <p>某些<code class="codeph">MERGE</code>操作错误（ <code class="codeph">ORA-30926</code> ：无法为<code class="codeph">MERGE</code>操作获取稳定的行集。）
                              </p>
                           </li>
                        </ul>
                        <p>某些错误未记录，导致DML操作终止并回滚。有关这些错误的列表以及其他DML日志记录限制，请参阅<a href="https://www.oracle.com/pls/topic/lookup?ctx=en/database/oracle/oracle-database/19/admin&amp;id=SQLRF55101" target="_blank"><span class="italic">Oracle数据库SQL语言参考</span></a>的<code class="codeph">INSERT</code>部分中对<code class="codeph">error_logging_clause</code>的讨论。
                        </p>
                     </div>
                     <div>
                        <ul class="ullinks">
                           <li class="ulchildlink"><a href="managing-tables.html#GUID-A7CDC31E-263D-4D61-874C-14480FA053BB">空间考虑因素</a><br>在使用DML错误日志记录之前，请确保考虑空间要求。您不仅需要为插入的表提供可用空间，还需要为错误记录表提供可用空间。
                           </li>
                           <li class="ulchildlink"><a href="managing-tables.html#GUID-79D1A415-105D-4058-8EDD-E1E757AD8986">安全</a><br>发出带有DML错误日志记录的<code class="codeph">INSERT</code>语句的用户必须对错误记录表具有<code class="codeph">INSERT</code>权限。
                           </li>
                        </ul>
                        <div class="familylinks">
                           <div class="parentlink">
                              <p><strong>父主题：</strong> <a href="managing-tables.html#GUID-36DB026B-4702-477A-92C4-EA2795D2B37F" title="您可以使用DML错误日志记录功能来避免批量INSERT故障。">使用DML错误记录避免批量INSERT故障</a></p>
                           </div>
                        </div>
                     </div>
                     <a id="ADMIN11641"></a><div class="props_rev_3"><a id="GUID-A7CDC31E-263D-4D61-874C-14480FA053BB" name="GUID-A7CDC31E-263D-4D61-874C-14480FA053BB"></a><h6 id="ADMIN-GUID-A7CDC31E-263D-4D61-874C-14480FA053BB" class="sect6"><span class="enumeration_section">20.4.4.4.1</span>空间考虑因素</h6>
                        <p>在使用DML错误日志记录之前，请确保考虑空间要求。您不仅需要为插入的表提供可用空间，还需要为错误记录表提供可用空间。</p>
                        <div>
                           <div class="familylinks">
                              <div class="parentlink">
                                 <p><strong>父主题：</strong> <a href="managing-tables.html#GUID-B8C0D6EE-6D5E-4415-90F5-81B310201440" title="错误记录表中未记录某些错误。">错误记录限制和警告</a></p>
                              </div>
                           </div>
                        </div>
                        
                     </div><a id="ADMIN11642"></a><div class="props_rev_3"><a id="GUID-79D1A415-105D-4058-8EDD-E1E757AD8986" name="GUID-79D1A415-105D-4058-8EDD-E1E757AD8986"></a><h6 id="ADMIN-GUID-79D1A415-105D-4058-8EDD-E1E757AD8986" class="sect6"><span class="enumeration_section">20.4.4.4.2</span>安全性</h6>
                        <div>
                           <p>发出带有DML错误日志记录的<code class="codeph">INSERT</code>语句的用户必须对错误记录表具有<code class="codeph">INSERT</code>权限。
                           </p>
                        </div>
                        <div>
                           <div class="infoboxnotealso" id="GUID-79D1A415-105D-4058-8EDD-E1E757AD8986__GUID-EA76A20C-AAF9-4D5E-8B48-69F8AAF4449D">
                              <p class="notep1">也可以看看：</p>
                              <p> 用于DML错误日志记录示例的<a href="../sqlrf/INSERT.html#SQLRF55101" target="_blank"><span class="italic">Oracle数据库SQL语言参考</span></a>和<a href="https://www.oracle.com/pls/topic/lookup?ctx=en/database/oracle/oracle-database/19/admin&amp;id=DWHSG8337" target="_blank"><span class="italic">Oracle数据库数据仓库指南</span></a> 。
                              </p>
                           </div>
                           <div class="familylinks">
                              <div class="parentlink">
                                 <p><strong>父主题：</strong> <a href="managing-tables.html#GUID-B8C0D6EE-6D5E-4415-90F5-81B310201440" title="错误记录表中未记录某些错误。">错误记录限制和警告</a></p>
                              </div>
                           </div>
                        </div>
                        
                     </div>
                  </div>
               </div>
            </div>
            <div class="sect2"><a id="GUID-43794F5A-1B13-4E97-B4DD-31AEB9633E9A" name="GUID-43794F5A-1B13-4E97-B4DD-31AEB9633E9A"></a><h3 id="ADMIN-GUID-43794F5A-1B13-4E97-B4DD-31AEB9633E9A" class="sect3"><span class="enumeration_section">20.5</span>优化批量更新的性能</h3>
               <div>
                  <p>该<code class="codeph">EXECUTE_UPDATE</code>在程序<code class="codeph">DBMS_REDEFINITION</code>包可以优化的批量更新的表的性能。性能已优化，因为更新未记录在重做日志中。
                  </p>
                  <div class="section">
                     <p><code class="codeph">EXECUTE_UPDATE</code>过程自动使用联机表重新定义的组件，例如临时表，物化视图和物化视图日志，以实现对表的优化批量更新。<code class="codeph">EXECUTE_UPDATE</code>过程还会删除受影响行的碎片，并确保更新是原子的。如果批量更新引发任何错误，则可以使用<code class="codeph">ABORT_UPDATE</code>过程撤消<code class="codeph">EXECUTE_UPDATE</code>过程所做的更改。
                     </p>
                     <p></p>
                     <p>以下限制适用于<code class="codeph">EXECUTE_UPDATE</code>过程：</p>
                     <ul style="list-style-type:disc">
                        <li>
                           <p>适用于联机表重定义的所有限制都适用于<code class="codeph">EXECUTE_UPDATE</code>过程和<code class="codeph">ABORT_UPDATE</code>过程。
                           </p>
                        </li>
                        <li>
                           <p>您不能同时在表上运行多个<code class="codeph">EXECUTE_UPDATE</code>过程。
                           </p>
                        </li>
                        <li>
                           <p>当<code class="codeph">EXECUTE_UPDATE</code>过程在表上运行时，不要在表上对来自不同会话的DML进行更改。<code class="codeph">EXECUTE_UPDATE</code>过程完成后，这些DML更改将丢失。
                           </p>
                        </li>
                        <li>
                           <p>该表不能具有触发<code class="codeph">UPDATE</code>语句的任何触发器。
                           </p>
                        </li>
                        <li>
                           <p>传递给<code class="codeph">EXECUTE_UPDATE</code>过程的<code class="codeph">UPDATE</code>语句不能包含具有分区扩展名的表。
                           </p>
                        </li>
                        <li>
                           <p>该表不能具有以下用户定义类型：varrays，REF和嵌套表。</p>
                        </li>
                        <li>
                           <p>该表不能具有以下Oracle提供的类型： <code class="codeph">ANYTYPE</code> ， <code class="codeph">ANYDATASET</code> ，URI类型， <code class="codeph">SDO_TOPO_GEOMETRY</code> ， <code class="codeph">SDO_GEORASTER</code>和<code class="codeph">Expression</code> 。
                           </p>
                        </li>
                        <li>
                           <p>该表不能具有以下类型的列：隐藏列，虚拟列，未使用的列，伪列或标识列。</p>
                        </li>
                        <li>
                           <p>该表不能是对象表。</p>
                        </li>
                        <li>
                           <p>该表不能具有虚拟专用数据库（VPD）策略。</p>
                        </li>
                        <li>
                           <p>该表不能具有检查约束。</p>
                        </li>
                        <li>
                           <p>无法为行存档启用该表。</p>
                        </li>
                     </ul>
                     <p>要优化批量更新的性能：</p>
                  </div>
                  <!-- class="section" -->
                  <ol>
                     <li class="stepexpand"><span>在SQL * Plus中，以具有执行表的在线重新定义所需特权的用户身份进行连接。</span><div>具体而言，用户必须具有<span class="q">“ <a href="managing-tables.html#GUID-0191D286-24D5-4E2A-817B-99FAAB96D4B3" title="Execute privileges on the DBMS_REDEFINITION package are required to run subprograms in the package. Execute privileges on the DBMS_REDEFINITION package are granted to EXECUTE_CATALOG_ROLE.">DBMS_REDEFINITION包所需</a></span>的权限”中描述的<span class="q"><a href="managing-tables.html#GUID-0191D286-24D5-4E2A-817B-99FAAB96D4B3" title="要在程序包中运行子程序，需要DBMS_REDEFINITION程序包的执行权限。DBMS_REDEFINITION包的执行权限被授予EXECUTE_CATALOG_ROLE。">权限</a></span> 。
                        </div>
                     </li>
                     <li class="stepexpand"><span>运行<code class="codeph">EXECUTE_UPDATE</code>过程，并指定执行批量更新的SQL语句。</span><div>如果出现错误，则使用<code class="codeph">ABORT_UPDATE</code>过程撤消<code class="codeph">EXECUTE_UPDATE</code>过程所做的更改。
                        </div>
                     </li>
                     <li class="stepexpand"><span>执行备份更新的数据。</span><div>由于<code class="codeph">EXECUTE_UPDATE</code>过程不会记录重做日志中的更改，因此在执行数据库备份或包含更新表的表空间之前，无法进行恢复。
                        </div>
                     </li>
                  </ol>
                  <div class="example" id="GUID-43794F5A-1B13-4E97-B4DD-31AEB9633E9A__GUID-B15BB319-4D40-42AC-941D-CC283B213446">
                     <p class="titleinexample">示例20-10执行产品数据的优化批量更新</p>
                     <p>此示例对<code class="codeph">oe.order_items</code>表执行批量更新。具体而言，它设置<code class="codeph">unit_price</code>每个订单项目的与<code class="codeph">product_id</code>的<code class="codeph">3106</code>至<code class="codeph">45</code> 。如果批量更新失败，则<code class="codeph">ABORT_UPDATE</code>过程将取消<code class="codeph">EXECUTE_UPDATE</code>过程执行的所有更改，该过程将数据返回到过程运行之前的状态。
                     </p><pre class="pre codeblock"><code>DECLARE update_stmt VARCHAR2（300）：='UPDATE oe.order_items SET unit_price = 45 WHERE product_id = 3106'; BEGIN DBMS_REDEFINITION.EXECUTE_UPDATE（update_stmt）; NO_DATA_FOUND，然后DBMS_OUTPUT.PUT_LINE（'没有找到SELECT数据'）的异常; DBMS_REDEFINITION.ABORT_UPDATE（update_stmt）;等等，而DBMS_OUTPUT.PUT_LINE（'失败的原因是'|| SQLERRM）; IF（SQLCODE = 100）那么DBMS_REDEFINITION.ABORT_UPDATE（update_stmt）;万一;结束; /</code></pre></div>
                  <!-- class="example" -->
               </div>
               <div>
                  <div class="familylinks">
                     <div class="parentlink">
                        <p><strong>父主题：</strong> <a href="managing-tables.html#GUID-707B02F5-E589-4C20-8E2E-5ED4F7888702" title="管理表包括创建表，加载表，更改表和删除表等任务。">管理表</a></p>
                     </div>
                  </div>
               </div>
               
            </div><a id="ADMIN11656"></a><div class="props_rev_3"><a id="GUID-7BFAA5E3-1509-4691-BBED-35F863F7D09F" name="GUID-7BFAA5E3-1509-4691-BBED-35F863F7D09F"></a><h3 id="ADMIN-GUID-7BFAA5E3-1509-4691-BBED-35F863F7D09F" class="sect3"><span class="enumeration_section">20.6</span>自动收集表格统计信息</h3>
               <div>
                  <p>PL / SQL包<code class="codeph">DBMS_STATS</code>允许您生成和管理基于成本的优化的统计信息。您可以使用此包来收集，修改，查看，导出，导入和删除统计信息。您还可以使用此包来标识或命名已收集的统计信息。
                  </p>
                  <div class="section">
                     <p>以前，您通过在<code class="codeph">CREATE</code> （或<code class="codeph">ALTER</code> ） <code class="codeph">TABLE</code>语句中指定<code class="codeph">MONITORING</code>关键字，使<code class="codeph">DBMS_STATS</code>能够自动收集表的统计信息。不推荐使用<code class="codeph">MONITORING</code>和<code class="codeph">NOMONITORING</code>关键字，并自动收集统计信息。如果您确实指定了这些关键字，则会忽略它们。
                     </p>
                     <p>自上次收集统计信息以来，监控跟踪表的<code class="codeph">INSERT</code> ， <code class="codeph">UPDATE</code>和<code class="codeph">DELETE</code>操作的大致数量。在SGA中维护有关受影响的行数的信息，直到周期性地（大约每三个小时）SMON将数据合并到数据字典中。通过<code class="codeph">DBA_TAB_MODIFICATIONS,ALL_TAB_MODIFICATIONS</code>或<code class="codeph">USER_TAB_MODIFICATIONS</code>视图可以看到此数据字典信息。数据库使用这些视图来标识具有陈旧统计信息的表。
                     </p>
                     <p><code class="codeph">STATISTICS_LEVEL</code>初始化参数的默认值为<code class="codeph">TYPICAL</code> ，它启用自动统计信息收集。自动统计信息收集和<code class="codeph">DBMS_STATS</code>包使优化器能够生成准确的执行计划。将<code class="codeph">STATISTICS_LEVEL</code>初始化参数设置为<code class="codeph">BASIC</code>会禁用Oracle数据库特性和功能所需的许多重要统计信息的收集。要禁用对所有表的监视，请将<code class="codeph">STATISTICS_LEVEL</code>初始化参数设置为<code class="codeph">BASIC</code> 。自动统计信息收集和<code class="codeph">DBMS_STATS</code>包使优化器能够生成准确的执行计划。
                     </p>
                  </div>
                  <!-- class="section" -->
               </div>
               <div>
                  <div class="infoboxnotealso" id="GUID-7BFAA5E3-1509-4691-BBED-35F863F7D09F__GUID-D99038F8-A18A-4091-A841-6E04E2E93132">
                     <p class="notep1">也可以看看：</p>
                     <p></p>
                     <ul style="list-style-type:disc">
                        <li>
                           <p>有关<code class="codeph">STATISTICS_LEVEL</code>初始化参数的详细信息，请<a href="https://www.oracle.com/pls/topic/lookup?ctx=en/database/oracle/oracle-database/19/admin&amp;id=REFRN10214" target="_blank"><span class="italic">参见Oracle数据库参考</span></a></p>
                        </li>
                        <li>
                           <p><a href="https://www.oracle.com/pls/topic/lookup?ctx=en/database/oracle/oracle-database/19/admin&amp;id=TGSQL389" target="_blank"><span class="italic">“Oracle数据库SQL调优指南”，</span></a>以获取有关管理优化程序统计信</p>
                        </li>
                        <li>
                           <p>有关使用<code class="codeph">DBMS_STATS</code>程序包的信息，请参阅<a href="https://www.oracle.com/pls/topic/lookup?ctx=en/database/oracle/oracle-database/19/admin&amp;id=ARPLS059" target="_blank"><span class="italic">Oracle Database PL / SQL程序包和类型参考</span></a></p>
                        </li>
                        <li>
                           <p><span class="q">“ <a href="managing-automated-database-maintenance-tasks.html#GUID-3810CCA3-4F23-4886-AB56-AE9408725502" title="自动维护任务是定期自动启动以对数据库执行维护操作的任务。一个示例是收集查询优化器的架构对象的统计信息的任务。">关于自动维护任务</a> ”，</span>以获取有关使用计划程序自动收集统计信息的信息</p>
                        </li>
                     </ul>
                  </div>
                  <div class="familylinks">
                     <div class="parentlink">
                        <p><strong>父主题：</strong> <a href="managing-tables.html#GUID-707B02F5-E589-4C20-8E2E-5ED4F7888702" title="管理表包括创建表，加载表，更改表和删除表等任务。">管理表</a></p>
                     </div>
                  </div>
               </div>
               
            </div><a id="ADMIN01504"></a><div class="props_rev_3"><a id="GUID-D4AE1CF2-08F7-4AB2-9317-0DE20AC70D44" name="GUID-D4AE1CF2-08F7-4AB2-9317-0DE20AC70D44"></a><h3 id="ADMIN-GUID-D4AE1CF2-08F7-4AB2-9317-0DE20AC70D44" class="sect3"><span class="enumeration_section">20.7</span>改变表格</h3>
               <div>
                  <p>您使用<code class="codeph">ALTER TABLE</code>语句<code class="codeph">ALTER TABLE</code> 。要更改表，该表必须包含在模式中，或者您必须具有表的<code class="codeph">ALTER</code>对象特权或<code class="codeph">ALTER ANY TABLE</code>系统特权。
                  </p>
                  <div class="infoboxnote" id="GUID-D4AE1CF2-08F7-4AB2-9317-0DE20AC70D44__GUID-683DCDCA-A6FA-4CE4-9AC5-CDC0DD626332">
                     <p class="notep1">注意：</p>
                     <p>在更改表格之前，请熟悉这样做的后果。<a href="https://www.oracle.com/pls/topic/lookup?ctx=en/database/oracle/oracle-database/19/admin&amp;id=SQLRF01001" target="_blank"><span class="italic">Oracle数据库SQL语言参考</span></a>在<code class="codeph">ALTER TABLE</code>子句的描述中列出了许多这些后果。
                     </p>
                     <p>如果视图，物化视图，触发器，域索引，基于函数的索引，检查约束，函数，包的过程依赖于基表，则基表或其列的更改可以影响依赖对象。有关数据库如何管理依赖关系的信息，请参阅<span class="q">“ <a href="managing-schema-objects.html#GUID-46D82F8E-C360-4223-B469-18039B1FFB21" title="Oracle数据库提供了一种自动机制，可确保从属对象始终与其引用的对象保持同步。您也可以手动重新编译无效对象。">管理对象依赖关系</a> ”</span> 。
                     </p>
                  </div>
               </div>
               <div>
                  <ul class="ullinks">
                     <li class="ulchildlink"><a href="managing-tables.html#GUID-E369C065-BD19-4EC3-8633-1E43D8F4B2C6">使用ALTER TABLE语句的原因</a><br>使用<code class="codeph">ALTER TABLE</code>语句有几个原因。
                     </li>
                     <li class="ulchildlink"><a href="managing-tables.html#GUID-527D1F68-1335-4888-B492-210E82049CED">改变表的物理属性</a><br>更改表的物理属性时需要考虑几个因素。
                     </li>
                     <li class="ulchildlink"><a href="managing-tables.html#GUID-E84FFA18-5D0D-4012-A7C1-42A50207F48B">将表移动到新段或表空间</a><br>您可以将表移动到新段或表空间以启用压缩或执行数据维护。
                     </li>
                     <li class="ulchildlink"><a href="managing-tables.html#GUID-3CAE4C1E-BCF6-4F74-BF86-4888E0026FC5">手动为表分配存储空间</a><br>Oracle数据库根据需要为表的数据段动态分配其他扩展区。但是，您可能希望明确地为表分配额外的范围。例如，在Oracle Real Application Clusters环境中，可以为特定实例显式分配表的范围。
                     </li>
                     <li class="ulchildlink"><a href="managing-tables.html#GUID-93BA4E59-A16F-42B3-9EB5-440532F07AEE">修改现有列定义</a><br>使用<code class="codeph">ALTER TABLE...用于修改现有列定义的MODIFY</code>语句。您可以修改列数据类型，默认值，列约束，列表达式（对于虚拟列），列加密和可见/不可见属性。
                     </li>
                     <li class="ulchildlink"><a href="managing-tables.html#GUID-3BBC0224-E218-422F-803A-B2FE56906E44">添加表列</a><br>要将列添加到现有表，请使用<code class="codeph">ALTER TABLE...ADD</code>声明。
                     </li>
                     <li class="ulchildlink"><a href="managing-tables.html#GUID-D8835B01-E36C-4C41-A2C8-BA923D294C37">重命名表列</a><br>Oracle数据库允许您重命名表中的现有列。使用<code class="codeph">ALTER TABLE</code>语句的<code class="codeph">RENAME COLUMN</code>子句重命名列。
                     </li>
                     <li class="ulchildlink"><a href="managing-tables.html#GUID-29CA8FDC-55FB-4BEF-AE4A-5D1B4D2BE1E1">滴表列</a><br>您可以从表中删除不再需要的列，包括索引组织表。这提供了一种方便的方法来释放数据库中的空间，并避免您必须导出/导入数据，然后重新创建索引和约束。
                     </li>
                     <li class="ulchildlink"><a href="managing-tables.html#GUID-E41130FA-C2C6-4CA0-922B-A3281632B65B">以只读模式放置表</a><br>您可以使用<code class="codeph">ALTER</code> <code class="codeph">TABLE</code>将表放在只读模式下...<code class="codeph">READ</code> <code class="codeph">ONLY</code>语句，并使用<code class="codeph">ALTER</code> <code class="codeph">TABLE</code>将其返回到读/写模式...<code class="codeph">READ</code> <code class="codeph">WRITE</code>语句。
                     </li>
                  </ul>
                  <div class="familylinks">
                     <div class="parentlink">
                        <p><strong>父主题：</strong> <a href="managing-tables.html#GUID-707B02F5-E589-4C20-8E2E-5ED4F7888702" title="管理表包括创建表，加载表，更改表和删除表等任务。">管理表</a></p>
                     </div>
                  </div>
               </div>
               <a id="ADMIN11657"></a><div class="props_rev_3"><a id="GUID-E369C065-BD19-4EC3-8633-1E43D8F4B2C6" name="GUID-E369C065-BD19-4EC3-8633-1E43D8F4B2C6"></a><h4 id="ADMIN-GUID-E369C065-BD19-4EC3-8633-1E43D8F4B2C6" class="sect4"><span class="enumeration_section">20.7.1</span>使用ALTER TABLE语句的原因</h4>
                  <div>
                     <p>使用<code class="codeph">ALTER TABLE</code>语句有几个原因。
                     </p>
                     <p>您可以使用<code class="codeph">ALTER</code> <code class="codeph">TABLE</code>语句执行影响表的以下任何操作：</p>
                     <ul style="list-style-type:disc">
                        <li>
                           <p>修改物理特性（ <code class="codeph">INITRANS</code>或存储参数）</p>
                        </li>
                        <li>
                           <p>将表移动到新的段或表空间</p>
                        </li>
                        <li>
                           <p>显式分配扩展区或释放未使用的空间</p>
                        </li>
                        <li>
                           <p>添加，删除或重命名列，或修改现有列定义（数据类型，长度，默认值， <code class="codeph">NOT NULL</code>完整性约束，列表达式（对于虚拟列）和加密属性。）
                           </p>
                        </li>
                        <li>
                           <p>修改表的日志记录属性</p>
                        </li>
                        <li>
                           <p>修改<code class="codeph">CACHE</code> / <code class="codeph">NOCACHE</code>属性</p>
                        </li>
                        <li>
                           <p>添加，修改或删除与表关联的完整性约束</p>
                        </li>
                        <li>
                           <p>启用或禁用与表关联的完整性约束或触发器</p>
                        </li>
                        <li>
                           <p>修改表的并行度</p>
                        </li>
                        <li>
                           <p>重命名表格</p>
                        </li>
                        <li>
                           <p>将表置于只读模式并将其返回到读/写模式</p>
                        </li>
                        <li>
                           <p>添加或修改索引组织的表特征</p>
                        </li>
                        <li>
                           <p>改变外部表的特征</p>
                        </li>
                        <li>
                           <p>添加或修改<code class="codeph">LOB</code>列</p>
                        </li>
                        <li>
                           <p>添加或修改对象类型，嵌套表或varray列</p>
                        </li>
                        <li>
                           <p>修改表分区</p>
                           <p>与Oracle数据库<span class="italic">12c的</span>开始，你可以在两个以上的分区或子分区的时间，如劈分区上执行某些操作和合并分区操作。有关信息，请参见“ <a href="https://www.oracle.com/pls/topic/lookup?ctx=en/database/oracle/oracle-database/19/admin&amp;id=VLDBG1118" target="_blank"><span class="italic">Oracle数据库VLDB和分区指南</span></a> ”。
                           </p>
                        </li>
                     </ul>
                     <p>其中许多操作将在后续章节中讨论。</p>
                  </div>
                  <div>
                     <div class="familylinks">
                        <div class="parentlink">
                           <p><strong>父主题：</strong> <a href="managing-tables.html#GUID-D4AE1CF2-08F7-4AB2-9317-0DE20AC70D44" title="您使用ALTER TABLE语句更改表。要更改表，该表必须包含在模式中，或者您必须具有表的ALTER对象特权或ALTER ANY TABLE系统特权。">更改表</a></p>
                        </div>
                     </div>
                  </div>
                  
               </div><a id="ADMIN11658"></a><div class="props_rev_3"><a id="GUID-527D1F68-1335-4888-B492-210E82049CED" name="GUID-527D1F68-1335-4888-B492-210E82049CED"></a><h4 id="ADMIN-GUID-527D1F68-1335-4888-B492-210E82049CED" class="sect4"><span class="enumeration_section">20.7.2</span>改变表的物理属性</h4>
                  <div>
                     <p>更改表的物理属性时需要考虑几个因素。</p>
                     <div class="section">
                        <p>更改表的事务条目设置<code class="codeph">INITRANS</code>时，请注意<code class="codeph">INITRANS</code>的新设置<code class="codeph">INITRANS</code>适用于随后为该表分配的数据块。
                        </p>
                        <p>存储参数<code class="codeph">INITIAL</code>和<code class="codeph">MINEXTENTS</code>不能更改。其他存储参数的所有新设置（例如， <code class="codeph">NEXT</code> ， <code class="codeph">PCTINCREASE</code> ）仅影响随后为表分配的范围。分配的下一个范围的大小由<code class="codeph">NEXT</code>和<code class="codeph">PCTINCREASE</code>的当前值确定，并且不基于这些参数的先前值。
                        </p>
                     </div>
                     <!-- class="section" -->
                  </div>
                  <div>
                     <div class="infoboxnotealso" id="GUID-527D1F68-1335-4888-B492-210E82049CED__GUID-5DDEE73F-94D5-43AE-9B0E-FC5F5433042E">
                        <p class="notep1">也可以看看：</p>
                        <p>讨论<a href="../sqlrf/Common-SQL-DDL-Clauses.html#SQLRF021" target="_blank"><span class="italic">Oracle数据库SQL语言参考</span></a>中的物理属性子句和存储子句</p>
                     </div>
                     <div class="familylinks">
                        <div class="parentlink">
                           <p><strong>父主题：</strong> <a href="managing-tables.html#GUID-D4AE1CF2-08F7-4AB2-9317-0DE20AC70D44" title="您使用ALTER TABLE语句更改表。要更改表，该表必须包含在模式中，或者您必须具有表的ALTER对象特权或ALTER ANY TABLE系统特权。">更改表</a></p>
                        </div>
                     </div>
                  </div>
                  
               </div>
               <div class="sect3"><a id="GUID-E84FFA18-5D0D-4012-A7C1-42A50207F48B" name="GUID-E84FFA18-5D0D-4012-A7C1-42A50207F48B"></a><h4 id="ADMIN-GUID-E84FFA18-5D0D-4012-A7C1-42A50207F48B" class="sect4"><span class="enumeration_section">20.7.3</span>将表移动到新段或表空间</h4>
                  <p>您可以将表移动到新段或表空间以启用压缩或执行数据维护。</p>
                  <div>
                     <ul class="ullinks">
                        <li class="ulchildlink"><a href="managing-tables.html#GUID-3DE67CF4-84C5-4AED-A8A3-B1D28D8EBEF6">关于将表移动到新段或表空间</a><br><code class="codeph">ALTER TABLE...假设您在目标表空间中具有适当的配额， MOVE [PARTITION|SUBPARTITION]</code>语句使您可以移动表，分区或子分区以更改任何物理存储属性（如压缩或表空间）。
                        </li>
                        <li class="ulchildlink"><a href="managing-tables.html#GUID-A1CA0DB3-FFEC-42DC-8845-C67FA82055A5">移动一张桌子</a><br>使用<code class="codeph">ALTER TABLE...MOVE</code>语句将表移动到新段或表空间。
                        </li>
                        <li class="ulchildlink"><a href="managing-tables.html#GUID-3FFA2D35-C675-48A7-BF18-796505018E83">在线移动表分区或子分区</a><br>使用<code class="codeph">ALTER TABLE...MOVE PARTITION</code>语句或<code class="codeph">ALTER TABLE...MOVE SUBPARTITION</code>语句分别移动表分区或子分区。
                        </li>
                     </ul>
                     <div class="familylinks">
                        <div class="parentlink">
                           <p><strong>父主题：</strong> <a href="managing-tables.html#GUID-D4AE1CF2-08F7-4AB2-9317-0DE20AC70D44" title="您使用ALTER TABLE语句更改表。要更改表，该表必须包含在模式中，或者您必须具有表的ALTER对象特权或ALTER ANY TABLE系统特权。">更改表</a></p>
                        </div>
                     </div>
                  </div>
                  <a id="ADMIN11659"></a><div class="props_rev_3"><a id="GUID-3DE67CF4-84C5-4AED-A8A3-B1D28D8EBEF6" name="GUID-3DE67CF4-84C5-4AED-A8A3-B1D28D8EBEF6"></a><h5 id="ADMIN-GUID-3DE67CF4-84C5-4AED-A8A3-B1D28D8EBEF6" class="sect5"><span class="enumeration_section">20.7.3.1</span>关于将表移动到新段或表空间</h5>
                     <div>
                        <p><code class="codeph">ALTER TABLE...假设您在目标表空间中具有适当的配额， MOVE [PARTITION|SUBPARTITION]</code>语句使您可以移动表，分区或子分区以更改任何物理存储属性（如压缩或表空间）。
                        </p>
                        <p><code class="codeph">ALTER TABLE ...MOVE</code>语句支持<code class="codeph">ONLINE</code>关键字，该关键字使数据操作语言（DML）操作能够在正在移动的表，分区或子分区上不间断地运行。以下语句在线移动表，分区或子分区：</p>
                        <ul style="list-style-type:disc">
                           <li>
                              <p><code class="codeph">ALTER</code> <code class="codeph">TABLE</code> <code class="codeph">...</code> <code class="codeph">MOVE</code> <code class="codeph">...</code> <code class="codeph">线上</code></p>
                           </li>
                           <li>
                              <p><code class="codeph">ALTER</code> <code class="codeph">TABLE</code> <code class="codeph">...</code> <code class="codeph">MOVE</code> <code class="codeph">PARTITION</code> <code class="codeph">...</code> <code class="codeph">线上</code></p>
                           </li>
                           <li>
                              <p><code class="codeph">ALTER</code> <code class="codeph">TABLE</code> <code class="codeph">...</code> <code class="codeph">MOVE</code> <code class="codeph">SUBPARTITION</code> <code class="codeph">...</code> <code class="codeph">线上</code></p>
                           </li>
                        </ul>
                        <p>移动表会更改表中行的rowid。如果移动表并包含<code class="codeph">ONLINE</code>关键字和<code class="codeph">UPDATE INDEXES</code>子句，则索引在移动操作期间仍然可用。如果包含<code class="codeph">UPDATE INDEXES</code>子句但不包含<code class="codeph">ONLINE</code>关键字，则索引在移动操作后立即可用。<code class="codeph">UPDATE INDEXES</code>子句只能更改表的全局索引的存储属性，或者更改表上任何全局分区索引的索引分区的存储属性。如果不包含<code class="codeph">UPDATE INDEXES</code>子句，则对rowid的更改会导致表上的索引标记为<code class="codeph">UNUSABLE</code> ，并且使用这些索引访问表的DML会收到ORA-01502错误。在这种情况下，必须删除或重建表上的索引。
                        </p>
                        <p>移动操作会导致表的任何统计信息无效，并且应在移动表后收集新的统计信息。</p>
                        <p>如果表包含<code class="codeph">LOB</code>列，则此语句可用于将表与<code class="codeph">LOB</code>数据以及明确指定的<code class="codeph">LOB</code>索引段（与此表关联）一起移动。如果未指定，则默认为不移动<code class="codeph">LOB</code>数据和<code class="codeph">LOB</code>索引段。
                        </p>
                     </div>
                     <div>
                        <div class="familylinks">
                           <div class="parentlink">
                              <p><strong>父主题：</strong> <a href="managing-tables.html#GUID-E84FFA18-5D0D-4012-A7C1-42A50207F48B" title="您可以将表移动到新段或表空间以启用压缩或执行数据维护。">将表移动到新段或表空间</a></p>
                           </div>
                        </div>
                     </div>
                     
                  </div><a id="ADMIN14002"></a><a id="ADMIN14001"></a><div class="props_rev_3"><a id="GUID-A1CA0DB3-FFEC-42DC-8845-C67FA82055A5" name="GUID-A1CA0DB3-FFEC-42DC-8845-C67FA82055A5"></a><h5 id="ADMIN-GUID-A1CA0DB3-FFEC-42DC-8845-C67FA82055A5" class="sect5"><span class="enumeration_section">20.7.3.2</span>移动表格</h5>
                     <div>
                        <p>使用<code class="codeph">ALTER TABLE...MOVE</code>语句将表移动到新段或表空间。
                        </p>
                        <div class="section">
                           <p>在此语句中使用<code class="codeph">ONLINE</code>关键字时，数据操作语言（DML）操作可以继续在正在移动的表上不间断地运行。如果不包含<code class="codeph">ONLINE</code>关键字，则在移动操作期间无法对表中的数据执行并发DML操作。
                           </p>
                        </div>
                        <!-- class="section" -->
                        <div class="section">
                           <p>要移动一张桌子：</p>
                           <ol>
                              <li>
                                 <p>在SQL * Plus中，以用户身份连接以更改表的必要权限。</p>
                                 <p>有关更改表所需特权的信息，请参见<a href="https://www.oracle.com/pls/topic/lookup?ctx=en/database/oracle/oracle-database/19/admin&amp;id=SQLRF01001" target="_blank"><span class="italic">Oracle数据库SQL语言参考</span></a> 。
                                 </p>
                              </li>
                              <li>
                                 <p>运行<code class="codeph">ALTER</code> <code class="codeph">TABLE</code> <code class="codeph">...</code> <code class="codeph">MOVE</code>声明。
                                 </p>
                              </li>
                           </ol>
                        </div>
                        <!-- class="section" -->
                        <div class="example" id="GUID-A1CA0DB3-FFEC-42DC-8845-C67FA82055A5__GUID-6C37A0E6-6A2B-476A-86C8-7BC7D9885819">
                           <p class="titleinexample">示例20-11在联机模式下将表移动到新表空间</p>
                           <p>以下语句将<code class="codeph">hr.jobs</code>表联机移动到新的段和表空间，指定新的存储参数。<code class="codeph">ONLINE</code>关键字意味着DML操作可以在移动操作期间不间断地在表上运行。<code class="codeph">hr_tbs</code>表空间必须存在。
                           </p><pre class="oac_no_warn" dir="ltr">ALTER TABLE hr.jobs移动在线存储（初始20K下一个40K MINEXTENTS 2 MAXEXTENTS 20 PCTINCREASE 0）TABLESPACE hr_tbs;</pre></div>
                        <!-- class="example" -->
                        <div class="example" id="GUID-A1CA0DB3-FFEC-42DC-8845-C67FA82055A5__GUID-4CDDF3B5-B832-4FA2-9D0B-A6B7B46CF51C">
                           <p class="titleinexample">示例20-12移动表并更新表的索引</p>
                           <p>假设以下语句创建了一个表及其索引：</p><pre class="pre codeblock"><code>CREATE TABLE dept_exp（DEPTNO NUMBER（2）NOT NULL，DNAME VARCHAR2（14），LOC VARCHAR2（13））TABLESPACE tbs_1; CREATE INDEX i1_deptno ON dept_exp（deptno）TABLESPACE tbs_1; CREATE INDEX i2_dname ON dept_exp（dname）TABLESPACE tbs_1;</code></pre><p>以下语句将表移动到新的表空间（ <code class="codeph">tbs_2</code> ）并压缩表。它还将索引<code class="codeph">i2_dbname</code>移动到表空间<code class="codeph">tbs_2</code>并指定在移动操作之后<code class="codeph">i1_deptno</code>索引和<code class="codeph">i2_dname</code>索引都可用。
                           </p><pre class="pre codeblock"><code>ALTER TABLE dept_exp MOVE COMPRESS TABLESPACE tbs_2 UPDATE INDEXES（i1_deptno TABLESPACE tbs_1，i2_dname TABLESPACE tbs_2）;</code></pre><p>请注意，此语句不包含<code class="codeph">ONLINE</code>关键字。但是，如果DML操作必须能够在移动操作期间不间断地在表上运行，或者在移动操作期间索引必须可用，则支持<code class="codeph">ONLINE</code>关键字。
                           </p>
                           <p>在运行这些语句之前，必须存在<code class="codeph">tbs_1</code>和<code class="codeph">tbs_2</code>表空间。
                           </p>
                        </div>
                        <!-- class="example" -->
                     </div>
                     <div>
                        <div class="familylinks">
                           <div class="parentlink">
                              <p><strong>父主题：</strong> <a href="managing-tables.html#GUID-E84FFA18-5D0D-4012-A7C1-42A50207F48B" title="您可以将表移动到新段或表空间以启用压缩或执行数据维护。">将表移动到新段或表空间</a></p>
                           </div>
                        </div>
                     </div>
                     
                  </div><a id="ADMIN14004"></a><a id="ADMIN14003"></a><div class="props_rev_3"><a id="GUID-3FFA2D35-C675-48A7-BF18-796505018E83" name="GUID-3FFA2D35-C675-48A7-BF18-796505018E83"></a><h5 id="ADMIN-GUID-3FFA2D35-C675-48A7-BF18-796505018E83" class="sect5"><span class="enumeration_section">20.7.3.3</span>在线移动表分区或子分区</h5>
                     <div>
                        <p>使用<code class="codeph">ALTER TABLE...MOVE PARTITION</code>语句或<code class="codeph">ALTER TABLE...MOVE SUBPARTITION</code>语句分别移动表分区或子分区。
                        </p>
                        <div class="section">
                           <p>当您将<code class="codeph">ONLINE</code>关键字与这些语句中的任何一个一起使用时，DML操作可以继续在正在移动的分区或子分区上不间断地运行。如果不包含<code class="codeph">ONLINE</code>关键字，则在移动操作完成之前，不允许对分区或子分区中的数据执行DML操作。
                           </p>
                           <p>包含<code class="codeph">UPDATE</code> <code class="codeph">INDEXES</code>子句时，这些语句在移动期间维护本地索引和全局索引。因此，对这些语句使用<code class="codeph">ONLINE</code>关键字可以消除在移动后通过维护全局索引和手动重建索引来重新获得分区性能所需的时间。
                           </p>
                           <p>某些限制适用于移动表分区和子分区。有关这些限制的信息，请参见<a href="https://www.oracle.com/pls/topic/lookup?ctx=en/database/oracle/oracle-database/19/admin&amp;id=SQLRF53455" target="_blank"><span class="italic">Oracle数据库SQL语言参考</span></a> 。
                           </p>
                        </div>
                        <!-- class="section" -->
                        <div class="section">
                           <p>要在线移动表分区或子分区：</p>
                           <ol>
                              <li>
                                 <p>在SQL * Plus中，以具有必要权限的用户身份连接以更改表并移动分区或子分区。</p>
                                 <p>有关所需权限的信息，请参见<a href="https://www.oracle.com/pls/topic/lookup?ctx=en/database/oracle/oracle-database/19/admin&amp;id=SQLRF53167" target="_blank"><span class="italic">Oracle数据库SQL语言参考</span></a> 。
                                 </p>
                                 <p>请参见<span class="q">“ <a href="getting-started-with-database-administration.html#GUID-895EC72B-C620-4D93-9F23-3F6DC1706764" title="Oracle数据库包括以下组件：Oracle数据库实例，它是进程和内存的集合，以及一组包含用户数据和系统数据的磁盘文件。">使用SQL * Plus连接到数据库</a> ”</span> 。
                                 </p>
                              </li>
                              <li>
                                 <p>运行<code class="codeph">ALTER</code> <code class="codeph">TABLE</code> <code class="codeph">...</code> <code class="codeph">MOVE</code> <code class="codeph">PARTITION</code>或<code class="codeph">ALTER</code> <code class="codeph">TABLE</code> <code class="codeph">...</code> <code class="codeph">MOVE</code> <code class="codeph">SUBPARTITION</code>声明。
                                 </p>
                              </li>
                           </ol>
                        </div>
                        <!-- class="section" -->
                        <div class="section"></div>
                        <!-- class="section" -->
                        <div class="example" id="GUID-3FFA2D35-C675-48A7-BF18-796505018E83__GUID-71C3CC2A-022B-4C5E-843D-10C932AC86BF">
                           <p class="titleinexample">示例20-13将表分区移动到新段</p>
                           <p>以下语句将<code class="codeph">sh.sales</code>表的<code class="codeph">sales_q4_2003</code>分区移动到包含高级行压缩和索引维护的新段：</p><pre class="oac_no_warn" dir="ltr">ALTER TABLE销售MOVE PARTITION sales_q4_2003 ROW STORE COMPRESS ADVANCED UPDATE INDEXES ONLINE;</pre></div>
                        <!-- class="example" -->
                     </div>
                     <div>
                        <div class="infoboxnotealso" id="GUID-3FFA2D35-C675-48A7-BF18-796505018E83__GUID-0691EB4C-D000-49EB-BE3D-875624CB5C39">
                           <p class="notep1">也可以看看：</p>
                           <p></p>
                           <ul style="list-style-type:disc">
                              <li>
                                 <p><a href="https://www.oracle.com/pls/topic/lookup?ctx=en/database/oracle/oracle-database/19/admin&amp;id=VLDBG1193" target="_blank"><span class="italic">Oracle数据库VLDB和分区指南</span></a></p>
                              </li>
                              <li>
                                 <p><a href="https://www.oracle.com/pls/topic/lookup?ctx=en/database/oracle/oracle-database/19/admin&amp;id=SQLRF53453" target="_blank"><span class="italic">Oracle数据库SQL语言参考</span></a></p>
                              </li>
                           </ul>
                        </div>
                        <div class="familylinks">
                           <div class="parentlink">
                              <p><strong>父主题：</strong> <a href="managing-tables.html#GUID-E84FFA18-5D0D-4012-A7C1-42A50207F48B" title="您可以将表移动到新段或表空间以启用压缩或执行数据维护。">将表移动到新段或表空间</a></p>
                           </div>
                        </div>
                     </div>
                     
                  </div>
               </div><a id="ADMIN11660"></a><div class="props_rev_3"><a id="GUID-3CAE4C1E-BCF6-4F74-BF86-4888E0026FC5" name="GUID-3CAE4C1E-BCF6-4F74-BF86-4888E0026FC5"></a><h4 id="ADMIN-GUID-3CAE4C1E-BCF6-4F74-BF86-4888E0026FC5" class="sect4"><span class="enumeration_section">20.7.4</span>手动为表分配存储空间</h4>
                  <div>
                     <p>Oracle数据库根据需要为表的数据段动态分配其他扩展区。但是，您可能希望明确地为表分配额外的范围。例如，在Oracle Real Application Clusters环境中，可以为特定实例显式分配表的范围。</p>
                     <div class="section">
                        <p>您可以使用<code class="codeph">ALTER TABLE...为表分配新范围<code class="codeph">ALTER TABLE...ALLOCATE EXTENT</code>语句。
                        </p>
                        <p>您还可以使用<code class="codeph">ALTER TABLE</code>的<code class="codeph">DEALLOCATE UNUSED</code>子句显式释放未使用的空间。这在<span class="q">“ <a href="managing-space-for-schema-objects.html#GUID-1F297567-4BEC-438E-9E13-683D2BB47F44" title="您可以回收未使用的空间。Segment Advisor是一个Oracle数据库组件，用于标识具有可用于回收的空间的段。">回收未使用的空间</a> ”中</span>描述。
                        </p>
                     </div>
                     <!-- class="section" -->
                  </div>
                  <div>
                     <div class="familylinks">
                        <div class="parentlink">
                           <p><strong>父主题：</strong> <a href="managing-tables.html#GUID-D4AE1CF2-08F7-4AB2-9317-0DE20AC70D44" title="您使用ALTER TABLE语句更改表。要更改表，该表必须包含在模式中，或者您必须具有表的ALTER对象特权或ALTER ANY TABLE系统特权。">更改表</a></p>
                        </div>
                     </div>
                  </div>
                  
               </div><a id="ADMIN14005"></a><a id="ADMIN11661"></a><div class="props_rev_3"><a id="GUID-93BA4E59-A16F-42B3-9EB5-440532F07AEE" name="GUID-93BA4E59-A16F-42B3-9EB5-440532F07AEE"></a><h4 id="ADMIN-GUID-93BA4E59-A16F-42B3-9EB5-440532F07AEE" class="sect4"><span class="enumeration_section">20.7.5</span>修改现有列定义</h4>
                  <div>
                     <p>使用<code class="codeph">ALTER TABLE...用于修改现有列定义的MODIFY</code>语句。您可以修改列数据类型，默认值，列约束，列表达式（对于虚拟列），列加密和可见/不可见属性。
                     </p>
                     <div class="section">
                        <p>如果所有现有数据都满足新长度，则可以增加现有列的长度，或减小它。从Oracle Database 12 <span class="italic">c开始</span> ，您可以为<code class="codeph">VARCHAR2</code> ， <code class="codeph">NVARCHAR2</code>和<code class="codeph">RAW</code>数据类型指定最大32767字节的大小。在此版本之前， <code class="codeph">VARCHAR2</code>和<code class="codeph">NVARCHAR2</code>数据类型的最大大小为4000字节， <code class="codeph">RAW</code>数据类型的最大大小为2000字节。要使用扩展数据类型，请将<code class="codeph">MAX_STRING_SIZE</code>初始化参数设置为<code class="codeph">EXTENDED</code> 。</p>
                        <p>您可以将列从字节语义更改为<code class="codeph">CHAR</code>语义，反之亦然。必须设置初始化参数<code class="codeph">BLANK_TRIMMING=TRUE</code>才能减少非空<code class="codeph">CHAR</code>列的长度。
                        </p>
                        <p>如果要修改表以增加数据类型<code class="codeph">CHAR</code>列的长度，则会意识到这可能是一项耗时的操作，并且可能需要大量额外存储，尤其是在表包含许多行的情况下。这是因为每行中的<code class="codeph">CHAR</code>值必须填空以满足新的列长度。
                        </p>
                        <p>如果修改列的visible / invisible属性，则不能在同一SQL语句中包含任何其他列修改选项。</p>
                     </div>
                     <!-- class="section" -->
                     <div class="example" id="GUID-93BA4E59-A16F-42B3-9EB5-440532F07AEE__GUID-52317441-5ED5-49A2-BEA6-BB3D22172C4C">
                        <p class="titleinexample">示例20-14将列的长度更改为大于4000字节的大小</p>
                        <p>此示例将<code class="codeph">oe.product_information</code>表中<code class="codeph">product_description</code>列的长度更改为32767字节。
                        </p><pre class="oac_no_warn" dir="ltr">ALTER TABLE oe.product_information MODIFY（product_description VARCHAR2（32767））;</pre></div>
                     <!-- class="example" -->
                  </div>
                  <div>
                     <div class="infoboxnotealso" id="GUID-93BA4E59-A16F-42B3-9EB5-440532F07AEE__GUID-BA2DF856-459C-4637-814C-F3319B8D2322">
                        <p class="notep1">也可以看看：</p>
                        <p></p>
                        <ul style="list-style-type:disc">
                           <li>
                              <p>有关修改表列和其他限制的其他信息，请<a href="https://www.oracle.com/pls/topic/lookup?ctx=en/database/oracle/oracle-database/19/admin&amp;id=SQLRF01001" target="_blank"><span class="italic">参见Oracle数据库SQL语言参考</span></a></p>
                           </li>
                           <li>
                              <p>有关<code class="codeph">MAX_STRING_SIZE</code>初始化参数的信息，请<code class="codeph">MAX_STRING_SIZE</code> <a href="https://www.oracle.com/pls/topic/lookup?ctx=en/database/oracle/oracle-database/19/admin&amp;id=REFRN10321" target="_blank"><span class="italic">Oracle数据库参考</span></a></p>
                           </li>
                        </ul>
                     </div>
                     <div class="familylinks">
                        <div class="parentlink">
                           <p><strong>父主题：</strong> <a href="managing-tables.html#GUID-D4AE1CF2-08F7-4AB2-9317-0DE20AC70D44" title="您使用ALTER TABLE语句更改表。要更改表，该表必须包含在模式中，或者您必须具有表的ALTER对象特权或ALTER ANY TABLE系统特权。">更改表</a></p>
                        </div>
                     </div>
                  </div>
                  
               </div><a id="ADMIN11005"></a><div class="props_rev_3"><a id="GUID-3BBC0224-E218-422F-803A-B2FE56906E44" name="GUID-3BBC0224-E218-422F-803A-B2FE56906E44"></a><h4 id="ADMIN-GUID-3BBC0224-E218-422F-803A-B2FE56906E44" class="sect4"><span class="enumeration_section">20.7.6</span>添加表列</h4>
                  <div>
                     <p>要将列添加到现有表，请使用<code class="codeph">ALTER TABLE...ADD</code>声明。
                     </p>
                     <div class="section">
                        <p>以下语句更改<code class="codeph">hr.admin_emp</code>表以添加名为<code class="codeph">bonus</code>的新列：</p><pre class="oac_no_warn" dir="ltr">ALTER TABLE hr.admin_emp ADD（奖金数量（7,2））;</pre><div class="infoboxnote" id="GUID-3BBC0224-E218-422F-803A-B2FE56906E44__GUID-C69FB35C-9EA1-444F-ABC9-473E0743A3F5">
                           <p class="notep1">实时SQL：</p>
                           <p>在Oracle Live SQL上查看并运行Oracle Live SQL的相关示例<a href="https://livesql.oracle.com/apex/livesql/docs/admin/managing-tables/create-modify.html" target="_blank"><span class="italic">：创建和修改表</span></a> 。
                           </p>
                        </div>
                        <p>如果将新列添加到表中，则除非指定<code class="codeph">DEFAULT</code>子句，否则该列最初为<code class="codeph">NULL</code> 。如果为某些表类型的可为空列指定<code class="codeph">DEFAULT</code>子句，则默认值将存储为元数据，但列本身不会填充数据。但是，将重写指定新列的后续查询，以便在结果集中返回默认值。此行为可优化操作的资源使用和存储要求。
                        </p>
                        <p>仅当表不包含任何行或指定默认值时，才能添加具有<code class="codeph">NOT</code> <code class="codeph">NULL</code>约束的列。
                        </p>
                        <div class="infoboxnote" id="GUID-3BBC0224-E218-422F-803A-B2FE56906E44__GUID-01AFB5C3-1FA2-41E7-BA6B-892CA1A765E5">
                           <p class="notep1">注意：</p>
                           <ul style="list-style-type:disc">
                              <li>
                                 <p>如果在表上启用基本表压缩，则只有在未指定默认值时才能添加列。</p>
                              </li>
                              <li>
                                 <p>如果在表上启用高级行压缩，则可以使用或不使用默认值向该表添加列。</p>
                              </li>
                              <li>
                                 <p>如果新列是虚拟列，则其值由其列表达式确定。（请注意，虚拟列的值仅在查询时计算。）</p>
                              </li>
                           </ul>
                        </div>
                     </div>
                     <!-- class="section" -->
                  </div>
                  <div>
                     <div class="infoboxnotealso" id="GUID-3BBC0224-E218-422F-803A-B2FE56906E44__GUID-4D6B9EE4-ACEF-4689-AE2C-EB642827579E">
                        <p class="notep1">也可以看看：</p>
                        <ul style="list-style-type:disc">
                           <li>
                              <p><a href="https://www.oracle.com/pls/topic/lookup?ctx=en/database/oracle/oracle-database/19/admin&amp;id=SQLRF53350" target="_blank"><span class="italic">Oracle数据库SQL语言参考</span></a> ，用于添加表列的规则和限制</p>
                           </li>
                           <li>
                              <p><span class="q">“ <a href="managing-tables.html#GUID-ED833867-4B7F-442E-A70C-9C19DAA8F445" title="压缩可节省磁盘空间，减少数据库缓冲区高速缓存中的内存使用，并可显着提高读取期间的查询执行速度。">考虑使用表压缩</a> ”</span></p>
                           </li>
                           <li>
                              <p><a href="https://www.oracle.com/pls/topic/lookup?ctx=en/database/oracle/oracle-database/19/admin&amp;id=CNCPT89199" target="_blank"><span class="italic">Oracle数据库概念</span></a></p>
                           </li>
                           <li>
                              <p><span class="q">“ <a href="managing-tables.html#GUID-F772A328-C752-4230-9EB1-1E07F28F03C4" title="一个示例说明了创建表。">示例：创建表</a> ”</span>以获取虚拟列的示例</p>
                           </li>
                        </ul>
                     </div>
                     <div class="familylinks">
                        <div class="parentlink">
                           <p><strong>父主题：</strong> <a href="managing-tables.html#GUID-D4AE1CF2-08F7-4AB2-9317-0DE20AC70D44" title="您使用ALTER TABLE语句更改表。要更改表，该表必须包含在模式中，或者您必须具有表的ALTER对象特权或ALTER ANY TABLE系统特权。">更改表</a></p>
                        </div>
                     </div>
                  </div>
                  
               </div><a id="ADMIN11662"></a><div class="props_rev_3"><a id="GUID-D8835B01-E36C-4C41-A2C8-BA923D294C37" name="GUID-D8835B01-E36C-4C41-A2C8-BA923D294C37"></a><h4 id="ADMIN-GUID-D8835B01-E36C-4C41-A2C8-BA923D294C37" class="sect4"><span class="enumeration_section">20.7.7</span>重命名表列</h4>
                  <div>
                     <p>Oracle数据库允许您重命名表中的现有列。使用<code class="codeph">ALTER TABLE</code>语句的<code class="codeph">RENAME COLUMN</code>子句重命名列。
                     </p>
                     <div class="section">
                        <p>新名称不得与表中任何现有列的名称冲突。<code class="codeph">RENAME COLUMN</code>子句不允许使用其他条款。
                        </p>
                        <p>以下语句重命名<code class="codeph">hr.admin_emp</code>表的<code class="codeph">comm</code>列。
                        </p><pre class="oac_no_warn" dir="ltr">ALTER TABLE hr.admin_emp RENAME COLUMN comm to commission;</pre><div class="infoboxnote" id="GUID-D8835B01-E36C-4C41-A2C8-BA923D294C37__GUID-C69FB35C-9EA1-444F-ABC9-473E0743A3F5">
                           <p class="notep1">实时SQL：</p>
                           <p>在Oracle Live SQL上查看并运行Oracle Live SQL的相关示例<a href="https://livesql.oracle.com/apex/livesql/docs/admin/managing-tables/create-modify.html" target="_blank"><span class="italic">：创建和修改表</span></a> 。
                           </p>
                        </div>
                        <p>如前所述，更改表列可能会使依赖对象无效。但是，重命名列时，数据库会更新关联的数据字典表，以确保基于函数的索引和检查约束保持有效。</p>
                        <p>Oracle数据库还允许您重命名列约束。这在<span class="q">“ <a href="managing-schema-objects.html#GUID-E2BBB7F9-F200-4587-80E3-49CB7A06DB1C" title="ALTER TABLE ...RENAME CONSTRAINT语句使您可以重命名表的任何当前存在的约束。新约束名称不得与用户的任何现有约束名称冲突。">重命名约束</a> ”中</span>讨论。
                        </p>
                        <div class="infoboxnote" id="GUID-D8835B01-E36C-4C41-A2C8-BA923D294C37__GUID-A0E28DF4-46F4-4BD0-B6F4-8470D7383C65">
                           <p class="notep1">注意：</p>
                           <p><code class="codeph">ALTER TABLE</code>的<code class="codeph">RENAME TO</code>子句在语法上与<code class="codeph">RENAME COLUMN</code>子句类似，但用于重命名表本身。
                           </p>
                        </div>
                     </div>
                     <!-- class="section" -->
                  </div>
                  <div>
                     <div class="familylinks">
                        <div class="parentlink">
                           <p><strong>父主题：</strong> <a href="managing-tables.html#GUID-D4AE1CF2-08F7-4AB2-9317-0DE20AC70D44" title="您使用ALTER TABLE语句更改表。要更改表，该表必须包含在模式中，或者您必须具有表的ALTER对象特权或ALTER ANY TABLE系统特权。">更改表</a></p>
                        </div>
                     </div>
                  </div>
                  
               </div><a id="ADMIN11663"></a><div class="props_rev_3"><a id="GUID-29CA8FDC-55FB-4BEF-AE4A-5D1B4D2BE1E1" name="GUID-29CA8FDC-55FB-4BEF-AE4A-5D1B4D2BE1E1"></a><h4 id="ADMIN-GUID-29CA8FDC-55FB-4BEF-AE4A-5D1B4D2BE1E1" class="sect4"><span class="enumeration_section">20.7.8滴落</span>柱</h4>
                  <div>
                     <p>您可以从表中删除不再需要的列，包括索引组织表。这提供了一种方便的方法来释放数据库中的空间，并避免您必须导出/导入数据，然后重新创建索引和约束。</p>
                     <div class="infoboxnote" id="GUID-29CA8FDC-55FB-4BEF-AE4A-5D1B4D2BE1E1__GUID-0DC6B51D-B07E-43AC-9B38-F6D5F8C22DDB">
                        <p class="notep1">注意：</p>您不能从表中删除所有列，也不能从<code class="codeph">SYS</code>拥有的表中删除列。任何这样做的尝试都会导致错误。
                     </div>
                  </div>
                  <div>
                     <ul class="ullinks">
                        <li class="ulchildlink"><a href="managing-tables.html#GUID-E8545644-E243-4149-BB57-A234C7030313">从表中删除列</a><br>当您发出<code class="codeph">ALTER TABLE...DROP COLUMN</code>语句，列描述符和与目标列关联的数据将从表中的每一行中删除。您可以使用一个语句删除多个列。
                        </li>
                        <li class="ulchildlink"><a href="managing-tables.html#GUID-74A86E52-E2D2-405E-B888-94164E3973B9">标记列未使用</a><br>如果您担心从大表中的所有行中删除列数据所需的时间长度，您可以使用<code class="codeph">ALTER TABLE...SET UNUSED</code>语句。
                        </li>
                        <li class="ulchildlink"><a href="managing-tables.html#GUID-1AB2E206-EC3E-45CF-93F6-07C6C070FD5F">删除未使用的列</a><br><code class="codeph">ALTER TABLE...DROP UNUSED COLUMNS</code>语句是未使用列上允许的唯一操作。它物理地从表中删除未使用的列并回收磁盘空间。
                        </li>
                        <li class="ulchildlink"><a href="managing-tables.html#GUID-75B77430-F1F8-44AE-9D03-0C0CA6448FF4">在压缩表中删除列</a><br>如果在表上启用高级行压缩，则可以删除表列。如果仅启用基本表压缩，则不能删除列。
                        </li>
                     </ul>
                     <div class="infoboxnotealso" id="GUID-29CA8FDC-55FB-4BEF-AE4A-5D1B4D2BE1E1__GUID-65830D5B-081B-48DA-B8A4-7A477A66C320">
                        <p class="notep1">也可以看看：</p>
                        <p> 有关从表中删除列的其他限制和选项的信息，请<a href="https://www.oracle.com/pls/topic/lookup?ctx=en/database/oracle/oracle-database/19/admin&amp;id=SQLRF01001" target="_blank"><span class="italic">参见“Oracle数据库SQL语言参考</span></a> ”</p>
                     </div>
                     <div class="familylinks">
                        <div class="parentlink">
                           <p><strong>父主题：</strong> <a href="managing-tables.html#GUID-D4AE1CF2-08F7-4AB2-9317-0DE20AC70D44" title="您使用ALTER TABLE语句更改表。要更改表，该表必须包含在模式中，或者您必须具有表的ALTER对象特权或ALTER ANY TABLE系统特权。">更改表</a></p>
                        </div>
                     </div>
                  </div>
                  <a id="ADMIN11664"></a><div class="props_rev_3"><a id="GUID-E8545644-E243-4149-BB57-A234C7030313" name="GUID-E8545644-E243-4149-BB57-A234C7030313"></a><h5 id="ADMIN-GUID-E8545644-E243-4149-BB57-A234C7030313" class="sect5"><span class="enumeration_section">20.7.8.1</span>从表中删除列</h5>
                     <div>
                        <p>当您发出<code class="codeph">ALTER TABLE...DROP COLUMN</code>语句，列描述符和与目标列关联的数据将从表中的每一行中删除。您可以使用一个语句删除多个列。
                        </p>
                        <div class="section">
                           <p>以下语句是从<code class="codeph">hr.admin_emp</code>表中删除列的<code class="codeph">hr.admin_emp</code> 。第一个语句只删除了<code class="codeph">sal</code>列：</p><pre class="oac_no_warn" dir="ltr">ALTER TABLE hr.admin_emp DROP COLUMN sal;</pre><p>下一个声明会删除<code class="codeph">bonus</code>和<code class="codeph">comm</code>列：</p><pre class="oac_no_warn" dir="ltr">ALTER TABLE hr.admin_emp DROP（奖金，佣金）;</pre><div class="infoboxnote" id="GUID-E8545644-E243-4149-BB57-A234C7030313__GUID-C69FB35C-9EA1-444F-ABC9-473E0743A3F5">
                              <p class="notep1">实时SQL：</p>
                              <p>在Oracle Live SQL上查看并运行Oracle Live SQL的相关示例<a href="https://livesql.oracle.com/apex/livesql/docs/admin/managing-tables/create-modify.html" target="_blank"><span class="italic">：创建和修改表</span></a> 。
                              </p>
                           </div>
                        </div>
                        <!-- class="section" -->
                     </div>
                     <div>
                        <div class="familylinks">
                           <div class="parentlink">
                              <p><strong>父主题：</strong> <a href="managing-tables.html#GUID-29CA8FDC-55FB-4BEF-AE4A-5D1B4D2BE1E1" title="您可以从表中删除不再需要的列，包括索引组织表。这提供了一种方便的方法来释放数据库中的空间，并避免您必须导出/导入数据，然后重新创建索引和约束。">删除表列</a></p>
                           </div>
                        </div>
                     </div>
                     
                  </div><a id="ADMIN11665"></a><div class="props_rev_3"><a id="GUID-74A86E52-E2D2-405E-B888-94164E3973B9" name="GUID-74A86E52-E2D2-405E-B888-94164E3973B9"></a><h5 id="ADMIN-GUID-74A86E52-E2D2-405E-B888-94164E3973B9" class="sect5"><span class="enumeration_section">20.7.8.2</span>标记列未使用</h5>
                     <div>
                        <p>如果您担心从大表中的所有行中删除列数据所需的时间长度，您可以使用<code class="codeph">ALTER TABLE...SET UNUSED</code>语句。
                        </p>
                        <div class="section">
                           <p>此语句将一个或多个列标记为未使用，但实际上不会删除目标列数据或还原这些列占用的磁盘空间。但是，标记为未使用的列不会显示在查询或数据字典视图中，并且会删除其名称，以便新列可以重用该名称。在大多数情况下，还会删除列上定义的约束，索引和统计信息。例外情况是，未删除标记为未使用的LOB列的任何内部索引。</p>
                           <p>要将<code class="codeph">hiredate</code>和<code class="codeph">mgr</code>列标记为未使用，请执行以下语句：</p><pre class="oac_no_warn" dir="ltr">ALTER TABLE hr.admin_emp SET UNUSED（hiredate，mgr）;</pre><div class="infoboxnote" id="GUID-74A86E52-E2D2-405E-B888-94164E3973B9__GUID-C69FB35C-9EA1-444F-ABC9-473E0743A3F5">
                              <p class="notep1">实时SQL：</p>
                              <p>在Oracle Live SQL上查看并运行Oracle Live SQL的相关示例<a href="https://livesql.oracle.com/apex/livesql/docs/admin/managing-tables/create-modify.html" target="_blank"><span class="italic">：创建和修改表</span></a> 。
                              </p>
                           </div>
                           <p>您可以稍后通过发出<code class="codeph">ALTER TABLE...来删除标记为未使用的列<code class="codeph">ALTER TABLE...DROP UNUSED COLUMNS</code>声明。每当发出表的任何特定列或列的显式删除时，也会从目标表中删除未使用的列。
                           </p>
                           <p>数据字典视图<code class="codeph">USER_UNUSED_COL_TABS</code> ， <code class="codeph">ALL_UNUSED_COL_TABS</code> ，或<code class="codeph">DBA_UNUSED_COL_TABS</code>可用于列出包含未使用的列的所有表。<code class="codeph">COUNT</code>字段显示表中未使用的列数。
                           </p><pre class="oac_no_warn" dir="ltr">SELECT * FROM DBA_UNUSED_COL_TABS; OWNER TABLE_NAME COUNT --------------------------- -------------------- ------- ----- HR ADMIN_EMP 2</pre><p>对于外部表， <code class="codeph">SET</code> <code class="codeph">UNUSED</code>语句将透明地转换为<code class="codeph">ALTER</code> <code class="codeph">TABLE</code> <code class="codeph">DROP</code> <code class="codeph">COLUMN</code>语句。由于外部表仅包含数据库中的元数据，因此<code class="codeph">DROP</code> <code class="codeph">COLUMN</code>语句与<code class="codeph">SET</code> <code class="codeph">UNUSED</code>语句等效执行。
                           </p>
                        </div>
                        <!-- class="section" -->
                     </div>
                     <div>
                        <div class="familylinks">
                           <div class="parentlink">
                              <p><strong>父主题：</strong> <a href="managing-tables.html#GUID-29CA8FDC-55FB-4BEF-AE4A-5D1B4D2BE1E1" title="您可以从表中删除不再需要的列，包括索引组织表。这提供了一种方便的方法来释放数据库中的空间，并避免您必须导出/导入数据，然后重新创建索引和约束。">删除表列</a></p>
                           </div>
                        </div>
                     </div>
                     
                  </div><a id="ADMIN11666"></a><div class="props_rev_3"><a id="GUID-1AB2E206-EC3E-45CF-93F6-07C6C070FD5F" name="GUID-1AB2E206-EC3E-45CF-93F6-07C6C070FD5F"></a><h5 id="ADMIN-GUID-1AB2E206-EC3E-45CF-93F6-07C6C070FD5F" class="sect5"><span class="enumeration_section">20.7.8.3</span>删除未使用的列</h5>
                     <div>
                        <p><code class="codeph">ALTER TABLE...DROP UNUSED COLUMNS</code>语句是未使用列上允许的唯一操作。它物理地从表中删除未使用的列并回收磁盘空间。
                        </p>
                        <div class="section">
                           <p>在随后的<code class="codeph">ALTER TABLE</code>语句中，指定了可选子句<code class="codeph">CHECKPOINT</code> 。此子句导致在处理指定行数后应用检查点，在本例中为250。检查点减少了在删除列操作期间累积的撤消日志量，以避免可能耗尽撤消空间。
                           </p><pre class="oac_no_warn" dir="ltr">ALTER TABLE hr.admin_emp DROP UNUSED COLUMNS CHECKPOINT 250;</pre><div class="infoboxnote" id="GUID-1AB2E206-EC3E-45CF-93F6-07C6C070FD5F__GUID-C69FB35C-9EA1-444F-ABC9-473E0743A3F5">
                              <p class="notep1">实时SQL：</p>
                              <p>在Oracle Live SQL上查看并运行Oracle Live SQL的相关示例<a href="https://livesql.oracle.com/apex/livesql/docs/admin/managing-tables/create-modify.html" target="_blank"><span class="italic">：创建和修改表</span></a> 。
                              </p>
                           </div>
                        </div>
                        <!-- class="section" -->
                     </div>
                     <div>
                        <div class="familylinks">
                           <div class="parentlink">
                              <p><strong>父主题：</strong> <a href="managing-tables.html#GUID-29CA8FDC-55FB-4BEF-AE4A-5D1B4D2BE1E1" title="您可以从表中删除不再需要的列，包括索引组织表。这提供了一种方便的方法来释放数据库中的空间，并避免您必须导出/导入数据，然后重新创建索引和约束。">删除表列</a></p>
                           </div>
                        </div>
                     </div>
                     
                  </div><a id="ADMIN12495"></a><div class="props_rev_3"><a id="GUID-75B77430-F1F8-44AE-9D03-0C0CA6448FF4" name="GUID-75B77430-F1F8-44AE-9D03-0C0CA6448FF4"></a><h5 id="ADMIN-GUID-75B77430-F1F8-44AE-9D03-0C0CA6448FF4" class="sect5"><span class="enumeration_section">20.7.8.4</span>在压缩表中删除列</h5>
                     <div>
                        <p>如果在表上启用高级行压缩，则可以删除表列。如果仅启用基本表压缩，则不能删除列。</p>
                     </div>
                     <div>
                        <div class="infoboxnotealso" id="GUID-75B77430-F1F8-44AE-9D03-0C0CA6448FF4__GUID-9623CB79-2F4E-47AA-98FD-20F396BAD3CD">
                           <p class="notep1">也可以看看：</p>
                           <p><span class="q">“ <a href="managing-tables.html#GUID-ED833867-4B7F-442E-A70C-9C19DAA8F445" title="压缩可节省磁盘空间，减少数据库缓冲区高速缓存中的内存使用，并可显着提高读取期间的查询执行速度。">考虑使用表压缩</a> ”</span></p>
                        </div>
                        <div class="familylinks">
                           <div class="parentlink">
                              <p><strong>父主题：</strong> <a href="managing-tables.html#GUID-29CA8FDC-55FB-4BEF-AE4A-5D1B4D2BE1E1" title="您可以从表中删除不再需要的列，包括索引组织表。这提供了一种方便的方法来释放数据库中的空间，并避免您必须导出/导入数据，然后重新创建索引和约束。">删除表列</a></p>
                           </div>
                        </div>
                     </div>
                     
                  </div>
               </div><a id="ADMIN12316"></a><div class="props_rev_3"><a id="GUID-E41130FA-C2C6-4CA0-922B-A3281632B65B" name="GUID-E41130FA-C2C6-4CA0-922B-A3281632B65B"></a><h4 id="ADMIN-GUID-E41130FA-C2C6-4CA0-922B-A3281632B65B" class="sect4"><span class="enumeration_section">20.7.9</span>以只读模式放置表</h4>
                  <div>
                     <p>您可以使用<code class="codeph">ALTER</code> <code class="codeph">TABLE</code>将表放在只读模式下...<code class="codeph">READ</code> <code class="codeph">ONLY</code>语句，并使用<code class="codeph">ALTER</code> <code class="codeph">TABLE</code>将其返回到读/写模式...<code class="codeph">READ</code> <code class="codeph">WRITE</code>语句。
                     </p>
                     <div class="section">
                        <p>只读模式有意义的表的示例是配置表。如果您的应用程序包含在安装后未修改且用户不得修改的配置表，则应用程序安装脚本可以将这些表置于只读模式。</p>
                        <p>要将表置于只读模式，您必须具有<code class="codeph">TABLE</code>的<code class="codeph">ALTER</code> <code class="codeph">TABLE</code>特权或<code class="codeph">ALTER</code> <code class="codeph">ANY</code> <code class="codeph">TABLE</code>特权。此外， <code class="codeph">COMPATIBLE</code>初始化参数必须设置为<code class="codeph">11.2.0</code>或更高。
                        </p>
                        <p>以下示例将<code class="codeph">SALES</code>表置于只读模式：</p><pre class="oac_no_warn" dir="ltr">更改表销售仅供参考;</pre><p>以下示例将表返回到读/写模式：</p><pre class="oac_no_warn" dir="ltr">ALTER TABLE SALES READ WRITE;</pre></div>
                     <!-- class="section" -->
                     <div class="section">
                        <p>当表处于只读模式时，不允许尝试修改表数据的操作。在将表或分区置于只读模式后，表上的<code class="codeph">SELECT <span class="codeinlineitalic">column_list</span> ON <span class="codeinlineitalic">table_name</span></code>语句必须始终返回相同的数据集。
                        </p>
                        <p>只读表上不允许执行以下操作：</p>
                        <ul style="list-style-type:disc">
                           <li>
                              <p>只读表或只读分区上的所有DML操作</p>
                           </li>
                           <li>
                              <p><code class="codeph">TRUNCATE</code> <code class="codeph">TABLE</code></p>
                           </li>
                           <li>
                              <p><code class="codeph">SELECT</code> <code class="codeph">FOR</code> <code class="codeph">UPDATE</code></p>
                           </li>
                           <li>
                              <p><code class="codeph">ALTER</code> <code class="codeph">TABLE</code> <code class="codeph">RENAME</code> / <code class="codeph">DROP</code> <code class="codeph">COLUMN</code></p>
                           </li>
                           <li>
                              <p>只读分区的<code class="codeph">DROP</code>或只读表的分区</p>
                           </li>
                           <li>
                              <p><code class="codeph">ALTER</code> <code class="codeph">TABLE</code> <code class="codeph">SET</code> <code class="codeph">COLUMN</code> <code class="codeph">UNUSED</code></p>
                           </li>
                           <li>
                              <p><code class="codeph">ALTER</code> <code class="codeph">TABLE</code> <code class="codeph">DROP</code> / <code class="codeph">TRUNCATE</code> / <code class="codeph">EXCHANGE</code> <code class="codeph">(</code> <code class="codeph">SUB</code> <code class="codeph">)</code> <code class="codeph">PARTITION</code></p>
                           </li>
                           <li>
                              <p><code class="codeph">ALTER</code> <code class="codeph">TABLE</code> <code class="codeph">UPGRADE</code> <code class="codeph">INCLUDING</code> <code class="codeph">DATA</code>或<code class="codeph">ALTER</code> <code class="codeph">TYPE</code> <code class="codeph">CASCADE</code> <code class="codeph">INCLUDING</code> <code class="codeph">TABLE</code> <code class="codeph">DATA</code>与只读表家属一个类型</p>
                           </li>
                           <li>
                              <p>在线重新定义</p>
                           </li>
                           <li>
                              <p><code class="codeph">FLASHBACK</code> <code class="codeph">TABLE</code></p>
                           </li>
                        </ul>
                        <p>只读表允许以下操作：</p>
                        <ul style="list-style-type:disc">
                           <li>
                              <p><code class="codeph">选择</code></p>
                           </li>
                           <li>
                              <p><code class="codeph">CREATE</code> / <code class="codeph">ALTER</code> / <code class="codeph">DROP</code> <code class="codeph">INDEX</code></p>
                           </li>
                           <li>
                              <p><code class="codeph">ALTER</code> <code class="codeph">TABLE</code> <code class="codeph">ADD</code> / <code class="codeph">MODIFY</code> <code class="codeph">COLUMN</code></p>
                           </li>
                           <li>
                              <p><code class="codeph">ALTER</code> <code class="codeph">TABLE</code> <code class="codeph">ADD</code> / <code class="codeph">MODIFY</code> / <code class="codeph">DROP</code> / <code class="codeph">ENABLE</code> / <code class="codeph">DISABLE</code> <code class="codeph">CONSTRAINT</code></p>
                           </li>
                           <li>
                              <p><code class="codeph">ALTER</code> <code class="codeph">TABLE</code>用于物理属性更改</p>
                           </li>
                           <li>
                              <p><code class="codeph">ALTER</code> <code class="codeph">TABLE</code> <code class="codeph">DROP</code> <code class="codeph">UNUSED</code> <code class="codeph">COLUMNS</code></p>
                           </li>
                           <li>
                              <p><code class="codeph">ALTER</code> <code class="codeph">TABLE</code> <code class="codeph">ADD</code> / <code class="codeph">COALESCE</code> / <code class="codeph">MERGE</code> / <code class="codeph">MODIFY</code> / <code class="codeph">MOVE</code> / <code class="codeph">RENAME</code> / <code class="codeph">SPLIT</code> <code class="codeph">(SUB)PARTITION</code></p>
                           </li>
                           <li>
                              <p><code class="codeph">ALTER</code> <code class="codeph">TABLE</code> <code class="codeph">MOVE</code></p>
                           </li>
                           <li>
                              <p><code class="codeph">ALTER</code> <code class="codeph">TABLE</code> <code class="codeph">ENABLE</code> <code class="codeph">ROW</code> <code class="codeph">MOVEMENT</code>和<code class="codeph">ALTER</code> <code class="codeph">TABLE</code> <code class="codeph">SHRINK</code></p>
                           </li>
                           <li>
                              <p><code class="codeph">RENAME</code> <code class="codeph">TABLE</code>和<code class="codeph">ALTER</code> <code class="codeph">TABLE</code> <code class="codeph">RENAME</code> <code class="codeph">TO</code></p>
                           </li>
                           <li>
                              <p><code class="codeph">DROP</code> <code class="codeph">TABLE</code></p>
                           </li>
                           <li>
                              <p><code class="codeph">ALTER</code> <code class="codeph">TABLE</code> <code class="codeph">DEALLOCATE</code> <code class="codeph">UNUSED</code></p>
                           </li>
                           <li>
                              <p><code class="codeph">ALTER</code> <code class="codeph">TABLE</code> <code class="codeph">ADD</code> / <code class="codeph">DROP</code> <code class="codeph">SUPPLEMENTAL</code> <code class="codeph">LOG</code></p>
                           </li>
                        </ul>
                     </div>
                     <!-- class="section" -->
                  </div>
                  <div>
                     <div class="infoboxnotealso" id="GUID-E41130FA-C2C6-4CA0-922B-A3281632B65B__GUID-52D9C479-D959-47B8-9917-DB65DE9A8608">
                        <p class="notep1">也可以看看：</p>
                        <p></p>
                        <ul style="list-style-type:disc">
                           <li>
                              <p>有关<code class="codeph">ALTER</code> <code class="codeph">TABLE</code>语句的更多信息，请<a href="https://www.oracle.com/pls/topic/lookup?ctx=en/database/oracle/oracle-database/19/admin&amp;id=SQLRF01001" target="_blank"><span class="italic">参见Oracle数据库SQL语言参考</span></a></p>
                           </li>
                           <li>
                              <p>有关只读<a href="https://www.oracle.com/pls/topic/lookup?ctx=en/database/oracle/oracle-database/19/admin&amp;id=VLDBG-GUID-9D7149B6-A2FF-47CA-8F00-47CBFD33F82B" target="_blank"><span><cite>分区</cite></span></a>的详细信息，请<a href="https://www.oracle.com/pls/topic/lookup?ctx=en/database/oracle/oracle-database/19/admin&amp;id=VLDBG-GUID-9D7149B6-A2FF-47CA-8F00-47CBFD33F82B" target="_blank"><span><cite>参见“Oracle数据库VLDB和分区指南”</cite></span></a></p>
                           </li>
                        </ul>
                     </div>
                     <div class="familylinks">
                        <div class="parentlink">
                           <p><strong>父主题：</strong> <a href="managing-tables.html#GUID-D4AE1CF2-08F7-4AB2-9317-0DE20AC70D44" title="您使用ALTER TABLE语句更改表。要更改表，该表必须包含在模式中，或者您必须具有表的ALTER对象特权或ALTER ANY TABLE系统特权。">更改表</a></p>
                        </div>
                     </div>
                  </div>
                  
               </div>
            </div>
            <div class="sect2"><a id="GUID-92361F74-4796-407D-A3B9-569C6E544E34" name="GUID-92361F74-4796-407D-A3B9-569C6E544E34"></a><h3 id="ADMIN-GUID-92361F74-4796-407D-A3B9-569C6E544E34" class="sect3"><span class="enumeration_section">20.8</span>在线重新定义表格</h3>
               <p>您可以修改表的逻辑或物理结构。</p>
               <div>
                  <ul class="ullinks">
                     <li class="ulchildlink"><a href="managing-tables.html#GUID-F95114BC-F512-4A1F-B5BD-07DDDE60D934">关于在线重新定义表格</a><br>在任何数据库系统中，有时需要修改表的逻辑或物理结构，以提高查询或DML的性能，适应应用程序更改或管理存储。您可以使用<code class="codeph">DBMS_REDEFINITION</code>包在线重新定义表。
                     </li>
                     <li class="ulchildlink"><a href="managing-tables.html#GUID-A63096F3-DD43-4E0F-803E-BACC0D0EFD2D">在线表重新定义的功能</a><br>通过联机表重定义，您可以在表保持联机时以多种不同方式修改表。
                     </li>
                     <li class="ulchildlink"><a href="managing-tables.html#GUID-0191D286-24D5-4E2A-817B-99FAAB96D4B3">DBMS_REDEFINITION包所需的权限</a><br>要在程序包中运行子程序，需要<code class="codeph">DBMS_REDEFINITION</code>程序包的执行权限。<code class="codeph">DBMS_REDEFINITION</code>包的执行权限被授予<code class="codeph">EXECUTE_CATALOG_ROLE</code> 。</li>
                     <li class="ulchildlink"><a href="managing-tables.html#GUID-CB5589F0-B328-4620-8809-C53696972B4C">在线重新定义表的限制</a><br>有几个限制适用于表的在线重新定义。
                     </li>
                     <li class="ulchildlink"><a href="managing-tables.html#GUID-4F3B5CFB-C29C-4216-86D2-B8FC98D0FE2F">使用REDEF_TABLE过程执行在线重新定义</a><br>您可以使用<code class="codeph">REDEF_TABLE</code>过程中的<code class="codeph">DBMS_REDEFINITION</code>包执行表的存储属性的在线重新定义。
                     </li>
                     <li class="ulchildlink"><a href="managing-tables.html#GUID-4156DC5F-06C6-41D5-8C5A-C1586DEDE43E">使用DBMS_REDEFINITION中的多个过程在线重新定义表</a><br>您可以使用<code class="codeph">DBMS_REDEFINITION</code>包中的多个过程在线重新定义表。
                     </li>
                     <li class="ulchildlink"><a href="managing-tables.html#GUID-1153B8CB-5CF2-4C46-B5EB-F7903F801AF5">重新定义过程的结果</a><br>重新定义过程有几个结果。
                     </li>
                     <li class="ulchildlink"><a href="managing-tables.html#GUID-B3981CA4-02E9-430C-8449-3EC28B00A06E">执行中间同步</a><br>在重新定义过程中，如果在原始表上执行了大量DML语句，则可以将临时表与原始表同步。
                     </li>
                     <li class="ulchildlink"><a href="managing-tables.html#GUID-D902E9EE-9EA2-434B-934E-43A549D64CEB">在线表重新定义期间刷新相关的物化视图</a><br>要在联机表重新定义期间刷新相关的快速可刷新<code class="codeph">REDEF_TABLE</code> ，请在<code class="codeph">REDEF_TABLE</code>过程或<code class="codeph">START_REDEF_TABLE</code>过程中将<code class="codeph">refresh_dep_mviews</code>参数设置为<code class="codeph">Y</code>
                     </li>
                     <li class="ulchildlink"><a href="managing-tables.html#GUID-273794DD-440A-43DE-B252-8AC91D54FC33">监控在线表重新定义进度</a><br>您可以查询<code class="codeph">V$ONLINE_REDEF</code>视图以监视联机表重定义操作的进度。
                     </li>
                     <li class="ulchildlink"><a href="managing-tables.html#GUID-58F4E092-A86D-4E00-96F6-56A596C91A53">失败后重新启动在线表重新定义</a><br>如果联机表重新定义失败，则可以检查<code class="codeph">DBA_REDEFINITION_STATUS</code>视图以查看错误信息和可重新启动的信息。
                     </li>
                     <li class="ulchildlink"><a href="managing-tables.html#GUID-FDCA40B7-D2EC-4900-98E4-8F1DACEDE0CF">回滚在线表重新定义</a><br>您可以在联机表重新定义后启用表的回滚，以将表恢复为其原始定义，并保留对表所做的DML更改。
                     </li>
                     <li class="ulchildlink"><a href="managing-tables.html#GUID-0C266A74-406A-485B-B545-5618EE3D02F8">在错误之后中止在线表重新定义和清理</a><br>您可以中止在线重新定义过程。这样做会丢弃与重新定义过程相关联的临时日志和表。调用此过程后，可以删除临时表及其依赖对象。
                     </li>
                     <li class="ulchildlink"><a href="managing-tables.html#GUID-9A31C4B1-1DA5-4DF8-8567-8642821056D6">在线重新定义一个或多个分区</a><br>您可以在线重新定义表的一个或多个分区。例如，如果您希望将分区移动到不同的表空间并在操作期间保持分区可用于DML，则此功能非常有用。
                     </li>
                     <li class="ulchildlink"><a href="managing-tables.html#GUID-4E77A941-A660-4DB3-A7B8-D15FBD9BF509">在线表重新定义示例</a><br>示例说明了表的在线重新定义。
                     </li>
                  </ul>
                  <div class="familylinks">
                     <div class="parentlink">
                        <p><strong>父主题：</strong> <a href="managing-tables.html#GUID-707B02F5-E589-4C20-8E2E-5ED4F7888702" title="管理表包括创建表，加载表，更改表和删除表等任务。">管理表</a></p>
                     </div>
                  </div>
               </div>
               <a id="ADMIN01514"></a><div class="props_rev_3"><a id="GUID-F95114BC-F512-4A1F-B5BD-07DDDE60D934" name="GUID-F95114BC-F512-4A1F-B5BD-07DDDE60D934"></a><h4 id="ADMIN-GUID-F95114BC-F512-4A1F-B5BD-07DDDE60D934" class="sect4"><span class="enumeration_section">20.8.1</span>关于在线重新定义表</h4>
                  <div>
                     <p>在任何数据库系统中，有时需要修改表的逻辑或物理结构，以提高查询或DML的性能，适应应用程序更改或管理存储。您可以使用<code class="codeph">DBMS_REDEFINITION</code>包在线重新定义表。
                     </p>
                     <p>Oracle数据库提供了一种机制，可以在不显着影响表的可用性的情况下进行表结构修改。该机制称为<span class="bold">在线表重新定义</span> 。与传统的重新定义表格的方法相比，在线重新定义表格可以大大提高可用性。
                     </p>
                     <p>在线重新定义表时，在重定义过程的大部分时间内，查询和DML都可以访问它。通常，仅在非常小的窗口期间将表锁定在独占模式中，该窗口独立于表的大小和重新定义的复杂性，并且对用户完全透明。但是，如果在重新定义期间有许多并发DML操作，则在锁定表之前可能需要更长的等待时间。</p>
                     <p>联机表重新定义需要一定量的可用空间，该空间大约等于正在重新定义的表所使用的空间。如果添加新列，可能需要更多空间。</p>
                     <p>您可以使用Oracle企业管理器云控制（云控制）重组对象向导或<code class="codeph">DBMS_REDEFINITION</code>包执行在线表重新定义。
                     </p>
                     <div class="infoboxnote" id="GUID-F95114BC-F512-4A1F-B5BD-07DDDE60D934__GUID-3C9AF78D-546A-41A8-B42D-33675F266E40">
                        <p class="notep1">注意：</p>
                        <p><span class="bold">要调用“重组对象”向导：</span></p>
                        <ol>
                           <li>
                              <p>在Cloud Control的“表”页面上，单击“ <span class="bold">选择”</span>列以选择要重新定义的表。
                              </p>
                           </li>
                           <li>
                              <p>在“操作”列表中，选择“ <span class="bold">重新组织”</span> 。
                              </p>
                           </li>
                           <li>
                              <p>单击<span class="bold">Go</span> 。</p>
                           </li>
                        </ol>
                     </div>
                  </div>
                  <div>
                     <div class="infoboxnotealso" id="GUID-F95114BC-F512-4A1F-B5BD-07DDDE60D934__GUID-EF64190D-5107-4901-BA00-D72E94767415">
                        <p class="notep1">也可以看看：</p>
                        <p><a href="https://www.oracle.com/pls/topic/lookup?ctx=en/database/oracle/oracle-database/19/admin&amp;id=ARPLS042" target="_blank"><span class="italic">Oracle Database PL / SQL包和类型参考</span></a> ，以获取<code class="codeph">DBMS_REDEFINITION</code>包的说明</p>
                     </div>
                     <div class="familylinks">
                        <div class="parentlink">
                           <p><strong>父主题：</strong> <a href="managing-tables.html#GUID-92361F74-4796-407D-A3B9-569C6E544E34" title="您可以修改表的逻辑或物理结构。">在线重新定义表</a></p>
                        </div>
                     </div>
                  </div>
                  
               </div><a id="ADMIN11667"></a><div class="props_rev_3"><a id="GUID-A63096F3-DD43-4E0F-803E-BACC0D0EFD2D" name="GUID-A63096F3-DD43-4E0F-803E-BACC0D0EFD2D"></a><h4 id="ADMIN-GUID-A63096F3-DD43-4E0F-803E-BACC0D0EFD2D" class="sect4"><span class="enumeration_section">20.8.2</span>在线表重定义的特征</h4>
                  <div>
                     <p>通过联机表重定义，您可以在表保持联机时以多种不同方式修改表。</p>
                     <p>在线表重新定义使您能够：</p>
                     <ul style="list-style-type:disc">
                        <li>
                           <p>修改表或集群的存储参数</p>
                        </li>
                        <li>
                           <p>将表或集群移动到其他表空间</p>
                           <div class="infoboxnote" id="GUID-A63096F3-DD43-4E0F-803E-BACC0D0EFD2D__GUID-3959471B-1540-4AB1-A3E5-E3DD6506B75D">
                              <p class="notep1">注意：</p>
                              <p>如果在将表移动到另一个表空间时保持表可用于DML并不重要，那么可以使用更简单的<code class="codeph">ALTER</code> <code class="codeph">TABLE</code> <code class="codeph">MOVE</code>命令。请参阅<span class="q">“ <a href="managing-tables.html#GUID-3DE67CF4-84C5-4AED-A8A3-B1D28D8EBEF6" title="ALTER TABLE ...假设您在目标表空间中具有适当的配额，MOVE [PARTITION | SUBPARTITION]语句使您可以移动表，分区或子分区以更改任何物理存储属性（如压缩或表空间）。">将表移动到新段或表空间</a> ”</span> 。
                              </p>
                           </div>
                        </li>
                        <li>
                           <p>在表或集群中添加，修改或删除一个或多个列</p>
                        </li>
                        <li>
                           <p>添加或删除分区支持（仅限非群集表）</p>
                        </li>
                        <li>
                           <p>更改分区结构</p>
                        </li>
                        <li>
                           <p>更改单个表分区或子分区的物理属性，包括将其移动到同一模式中的其他表空间</p>
                           <p>从Oracle Database 12 <span class="italic">c开始</span> ，您可以在不使用联机表重新定义的情况下在线移动分区或子分区。DML操作可以继续在正在移动的分区或子分区上不间断地运行。请参阅<span class="q">“ <a href="managing-tables.html#GUID-3DE67CF4-84C5-4AED-A8A3-B1D28D8EBEF6" title="ALTER TABLE ...假设您在目标表空间中具有适当的配额，MOVE [PARTITION | SUBPARTITION]语句使您可以移动表，分区或子分区以更改任何物理存储属性（如压缩或表空间）。">将表移动到新段或表空间</a> ”</span> 。
                           </p>
                        </li>
                        <li>
                           <p>更改实例化视图日志或Oracle数据库高级队列队列表的物理属性</p>
                           <div class="infoboxnote" id="GUID-A63096F3-DD43-4E0F-803E-BACC0D0EFD2D__GUID-9F9913F7-AEA1-46CA-AA6A-0C2D1D2693F0">
                              <p class="notep1">注意：</p>
                              <p>该<code class="codeph">REDEF_TABLE</code>在程序<code class="codeph">DBMS_REDEFINITION</code>包不支持改变Oracle数据库高级队列队列表中的物理性质。
                              </p>
                           </div>
                        </li>
                        <li>
                           <p>添加对并行查询的支持</p>
                        </li>
                        <li>
                           <p>重新创建表或集群以减少碎片</p>
                           <div class="infoboxnote" id="GUID-A63096F3-DD43-4E0F-803E-BACC0D0EFD2D__GUID-4AE5F2B4-1D3C-4D37-AD4D-FCDF6BBF8070">
                              <p class="notep1">注意：</p>
                              <p>在许多情况下，在线细分缩小是减少碎片的一种更简单的方法。请参阅<span class="q">“ <a href="managing-space-for-schema-objects.html#GUID-1F297567-4BEC-438E-9E13-683D2BB47F44" title="您可以回收未使用的空间。Segment Advisor是一个Oracle数据库组件，用于标识具有可用于回收的空间的段。">回收未使用的空间</a> ”</span> 。
                              </p>
                           </div>
                        </li>
                        <li>
                           <p>将正常表（堆组织）的组织更改为索引组织表，或者反过来。</p>
                        </li>
                        <li>
                           <p>将关系表转换为具有对象列的表，或者反过来。</p>
                        </li>
                        <li>
                           <p>将对象表转换为关系表或具有对象列的表，或者反过来。</p>
                        </li>
                        <li>
                           <p>压缩或更改表，分区，索引键或LOB列的压缩类型。</p>
                        </li>
                        <li>
                           <p>将LOB列从BasicFiles LOB存储转换为SecureFiles LOB存储，或者反过来。</p>
                        </li>
                        <li>
                           <p>您可以在联机表重新定义后启用表的回滚，以将表恢复为其原始定义，并保留对表所做的DML更改。</p>
                        </li>
                        <li>
                           <p>通过在<code class="codeph">REDEF_TABLE</code>过程或<code class="codeph">START_REDEF_TABLE</code>过程中将<code class="codeph">refresh_dep_mviews</code>参数设置为<code class="codeph">Y</code> ，可以在联机表重新定义期间刷新相关的快速可刷新物化视图。
                           </p>
                        </li>
                        <li>
                           <p>您可以查询<code class="codeph">V$ONLINE_REDEF</code>视图以监视联机表重定义操作的进度。
                           </p>
                        </li>
                        <li>
                           <p>当联机表重新定义失败时，通常可以纠正导致失败的问题并重新启动上次停止的联机重新定义过程。</p>
                        </li>
                     </ul>
                     <p>您可以将上述两个或多个用法示例合并为一个操作。有关<span class="q"><a href="managing-tables.html#GUID-4E77A941-A660-4DB3-A7B8-D15FBD9BF509__BABFAHGD">示例，</a></span>请参阅<span class="q">“</span> <span class="q"><a href="managing-tables.html#GUID-4E77A941-A660-4DB3-A7B8-D15FBD9BF509" title="示例说明了表的在线重新定义。">在线表重新定义示例</a> ”</span>中的<span class="q">“ <a href="managing-tables.html#GUID-4E77A941-A660-4DB3-A7B8-D15FBD9BF509__BABFAHGD">示例8</a> ”</span> 。
                     </p>
                  </div>
                  <div>
                     <div class="familylinks">
                        <div class="parentlink">
                           <p><strong>父主题：</strong> <a href="managing-tables.html#GUID-92361F74-4796-407D-A3B9-569C6E544E34" title="您可以修改表的逻辑或物理结构。">在线重新定义表</a></p>
                        </div>
                     </div>
                  </div>
                  
               </div><a id="ADMIN11678"></a><div class="props_rev_3"><a id="GUID-0191D286-24D5-4E2A-817B-99FAAB96D4B3" name="GUID-0191D286-24D5-4E2A-817B-99FAAB96D4B3"></a><h4 id="ADMIN-GUID-0191D286-24D5-4E2A-817B-99FAAB96D4B3" class="sect4"><span class="enumeration_section">20.8.3</span> DBMS_REDEFINITION包所需的权限</h4>
                  <div>
                     <p>要在程序包中运行子程序，需要<code class="codeph">DBMS_REDEFINITION</code>程序包的执行权限。<code class="codeph">DBMS_REDEFINITION</code>包的执行权限被授予<code class="codeph">EXECUTE_CATALOG_ROLE</code> 。</p>
                     <p>此外，对于用户使用程序包重新定义用户模式中的表，必须为用户授予以下权限：</p>
                     <ul style="list-style-type:disc">
                        <li>
                           <p><code class="codeph">CREATE</code> <code class="codeph">TABLE</code></p>
                        </li>
                        <li>
                           <p><code class="codeph">CREATE</code> <code class="codeph">MATERIALIZED</code> <code class="codeph">VIEW</code></p>
                        </li>
                     </ul>
                     <p>执行<code class="codeph">COPY_TABLE_DEPENDENTS</code>过程也需要<code class="codeph">CREATE TRIGGER</code>权限。
                     </p>
                     <p>对于用户使用该包重新定义其他模式中的表，必须为用户授予以下权限：</p>
                     <ul style="list-style-type:disc">
                        <li>
                           <p><code class="codeph">CREATE</code> <code class="codeph">ANY</code> <code class="codeph">TABLE</code></p>
                        </li>
                        <li>
                           <p><code class="codeph">ALTER</code> <code class="codeph">ANY</code> <code class="codeph">TABLE</code></p>
                        </li>
                        <li>
                           <p><code class="codeph">DROP</code> <code class="codeph">ANY</code> <code class="codeph">TABLE</code></p>
                        </li>
                        <li>
                           <p><code class="codeph">LOCK</code> <code class="codeph">ANY TABLE</code></p>
                        </li>
                        <li>
                           <p><code class="codeph">SELECT</code> <code class="codeph">ANY</code> <code class="codeph">TABLE</code></p>
                        </li>
                     </ul>
                     <p>在其他模式中的表上执行<code class="codeph">COPY_TABLE_DEPENDENTS</code>需要以下附加权限：</p>
                     <ul style="list-style-type:disc">
                        <li>
                           <p><code class="codeph">CREATE</code> <code class="codeph">ANY</code> <code class="codeph">TRIGGER</code></p>
                        </li>
                        <li>
                           <p><code class="codeph">CREATE</code> <code class="codeph">ANY</code> <code class="codeph">INDEX</code></p>
                        </li>
                     </ul>
                  </div>
                  <div>
                     <div class="familylinks">
                        <div class="parentlink">
                           <p><strong>父主题：</strong> <a href="managing-tables.html#GUID-92361F74-4796-407D-A3B9-569C6E544E34" title="您可以修改表的逻辑或物理结构。">在线重新定义表</a></p>
                        </div>
                     </div>
                  </div>
                  
               </div><a id="ADMIN01510"></a><div class="props_rev_3"><a id="GUID-CB5589F0-B328-4620-8809-C53696972B4C" name="GUID-CB5589F0-B328-4620-8809-C53696972B4C"></a><h4 id="ADMIN-GUID-CB5589F0-B328-4620-8809-C53696972B4C" class="sect4"><span class="enumeration_section">20.8.4</span>表的在线重新定义限制</h4>
                  <div>
                     <p>有几个限制适用于表的在线重新定义。</p>
                     <p>以下限制适用于表的在线重新定义：</p>
                     <ul style="list-style-type:disc">
                        <li>
                           <p>如果要使用主键或伪主键（唯一键或具有<span class="italic">非空</span>约束的所有组件列的约束）重新定义表，则后重新定义表必须具有相同的主键或伪主键列。如果要使用rowid重新定义表，则表不能是索引组织表。
                           </p>
                        </li>
                        <li>
                           <p>重新定义具有实例化视图日志的表后，任何相关实例化视图的后续刷新必须是完全刷新。</p>
                           <p>这个限制有一个例外。当联机表重新定义使用<code class="codeph">REDEF_TABLE</code>或<code class="codeph">START_REDEF_TABLE</code>过程，并且过程中的<code class="codeph">refresh_dep_mviews</code>参数设置为<code class="codeph">Y</code> ，将在联机表重新定义操作期间刷新为增量刷新配置的任何相关实例化视图。
                           </p>
                        </li>
                        <li>
                           <p>可以重新定义在n路主配置中复制的表，但不允许使用水平子集（表中的行子集），垂直子集（表中的列的子集）和列转换。</p>
                        </li>
                        <li>
                           <p>索引组织表的溢出表不能独立在线重新定义。</p>
                        </li>
                        <li>
                           <p>启用了闪回数据存档的表无法在线重新定义。您无法为临时表启用闪回数据存档。</p>
                        </li>
                        <li>
                           <p>可以在线重新定义具有<code class="codeph">LONG</code>列的表，但必须将这些列转换为<code class="codeph">CLOBS</code> 。此外， <code class="codeph">LONG RAW</code>列必须转换为<code class="codeph">BLOBS</code> 。带有<code class="codeph">LOB</code>列的表是可以接受的。
                           </p>
                        </li>
                        <li>
                           <p>在具有足够并行执行资源的系统上，并且在未对临时表进行分区的情况下，可以并行执行将<code class="codeph">LONG</code>列重新定义到<code class="codeph">LOB</code>列，前提是：</p>
                           <ul style="list-style-type:disc">
                              <li>
                                 <p>用于在临时表中存储<code class="codeph">LOB</code>列的段属于本地管理的表空间，并启用了自动段空间管理（ASSM）。
                                 </p>
                              </li>
                              <li>
                                 <p>从一个<code class="codeph">LONG</code>列到一个<code class="codeph">LOB</code>列有一个简单的映射，临时表只有一个<code class="codeph">LOB</code>列。
                                 </p>
                              </li>
                           </ul>
                           <p>在临时表被分区的情况下，应用用于分区的并行执行的常规方法。</p>
                        </li>
                        <li>
                           <p>无法在线重新定义<code class="codeph">SYS</code>和<code class="codeph">SYSTEM</code>模式中的表。
                           </p>
                        </li>
                        <li>
                           <p>临时表不能重新定义。</p>
                        </li>
                        <li>
                           <p>无法重新定义表中的行子集。</p>
                        </li>
                        <li>
                           <p>在将临时表中的列映射到原始表的列时，只能使用简单的确定性表达式，序列和<code class="codeph">SYSDATE</code> 。例如，不允许子查询。
                           </p>
                        </li>
                        <li>
                           <p>如果作为重新定义的一部分添加了新列，并且这些列没有列映射，则在重新定义完成之前，不能将它们声明为<code class="codeph">NOT</code> <code class="codeph">NULL</code> 。
                           </p>
                        </li>
                        <li>
                           <p>重新定义的表与临时表之间不存在任何引用约束。</p>
                        </li>
                        <li>
                           <p>表重新定义无法完成<code class="codeph">NOLOGGING</code> 。</p>
                        </li>
                        <li>
                           <p>对于物化视图日志和队列表，在线重新定义仅限于物理属性的更改。不允许水平或垂直子集，也不允许任何列转换。列映射字符串的唯一有效值是<code class="codeph">NULL</code> 。</p>
                        </li>
                        <li> 
                           <p>您无法在包含一个或多个嵌套表的分区上执行联机重定义。</p>
                        </li>
                        <li>
                           <p>您可以使用列映射中的<code class="codeph">CAST</code>运算符将<code class="codeph">VARRAY</code>转换为嵌套表。但是，您无法将嵌套表转换为<code class="codeph">VARRAY</code> 。</p>
                        </li>
                        <li>
                           <p>当在列<code class="codeph">col_mapping</code>所述的参数<code class="codeph">DBMS_REDEFINITION.START_REDEF_TABLE</code>过程包括序列，所述<code class="codeph">orderby_cols</code>参数必须是<code class="codeph">NULL</code> 。</p>
                        </li>
                        <li>
                           <p>对于虚拟专用数据库（VPD）的安全政策，当表<code class="codeph">copy_vpd_opt</code>参数指定为<code class="codeph">DBMS_REDEFINITION.CONS_VPD_AUTO</code> ，受到以下限制：</p>
                           <ul style="list-style-type:disc">
                              <li>
                                 <p>原始表和临时表之间的列映射字符串必须为<code class="codeph">NULL</code>或<code class="codeph">'*'</code> 。
                                 </p>
                              </li>
                              <li>
                                 <p>临时表中不存在VPD策略。</p>
                              </li>
                           </ul>
                           <p>请参阅<span class="q">“ <a href="managing-tables.html#GUID-070A3AEC-4226-4E65-BDB0-A5B2B5B48B1F" title="如果重新定义的原始表具有为其指定的VPD策略，则可以使用START_REDEF_TABLE过程中的copy_vpd_opt参数在联机重新定义期间处理这些策略。">在线重新定义期间处理虚拟专用数据库（VPD）策略</a> ”</span> 。另请参阅“ <a href="https://www.oracle.com/pls/topic/lookup?ctx=en/database/oracle/oracle-database/19/admin&amp;id=DBSEG242" target="_blank"><span class="italic">Oracle数据库安全指南”</span></a>以获取有关VPD策略的信息。
                           </p>
                        </li>
                        <li>
                           <p>如果表通过引用分区相关，则联机重定义不能在单独的<code class="codeph">DBMS_REDEFINITION</code>会话中同时在多个表上运行。
                           </p> 
                           <p>有关参考分区的详细信息，请参见“ <a href="../vldbg/partition-create-tables-indexes.html#VLDBG1093" target="_blank"><span class="italic">Oracle数据库VLDB和分区指南”</span></a> 。
                           </p>
                        </li>
                        <li>
                           <p>如果其他表具有引用重新定义的表的<code class="codeph">REF</code>列，则在线重新定义对象表或<code class="codeph">XMLType</code>表可能会导致其他表中的悬空<code class="codeph">REF</code> 。
                           </p> 
                           <p>有关悬空<code class="codeph">REF</code>的更多信息，请参见<a href="../sqlrf/Data-Types.html#SQLRF51006" target="_blank"><span class="italic">Oracle数据库SQL语言参考</span></a> 。
                           </p>
                        </li>
                        <li>
                           <p>无法在线重新定义使用Oracle Label Security（OLS）的表。</p> 
                           <p>请参阅<a href="https://www.oracle.com/pls/topic/lookup?ctx=en/database/oracle/oracle-database/19/admin&amp;id=OLSAG001" target="_blank"><span><cite>Oracle Label Security管理员指南</cite></span></a> 。
                           </p>
                        </li>
                        <li>
                           <p>无法在线重新定义具有细粒度访问控制的表。</p>
                        </li>
                        <li>
                           <p>无法在线重新定义使用Oracle Real Application Security的表。</p>
                           <p>请参见<a href="https://www.oracle.com/pls/topic/lookup?ctx=en/database/oracle/oracle-database/19/admin&amp;id=DBSEG-GUID-4C76D168-B534-4E12-A4AA-B434FC3E3328" target="_blank"><span><cite>Oracle数据库安全指南</cite></span></a> 。
                           </p>
                        </li>
                     </ul>
                  </div>
                  <div>
                     <div class="familylinks">
                        <div class="parentlink">
                           <p><strong>父主题：</strong> <a href="managing-tables.html#GUID-92361F74-4796-407D-A3B9-569C6E544E34" title="您可以修改表的逻辑或物理结构。">在线重新定义表</a></p>
                        </div>
                     </div>
                  </div>
                  
               </div><a id="ADMIN14159"></a><div class="props_rev_3"><a id="GUID-4F3B5CFB-C29C-4216-86D2-B8FC98D0FE2F" name="GUID-4F3B5CFB-C29C-4216-86D2-B8FC98D0FE2F"></a><h4 id="ADMIN-GUID-4F3B5CFB-C29C-4216-86D2-B8FC98D0FE2F" class="sect4"><span class="enumeration_section">20.8.5</span>使用REDEF_TABLE过程执行在线重定义</h4>
                  <div>
                     <p>您可以使用<code class="codeph">REDEF_TABLE</code>过程中的<code class="codeph">DBMS_REDEFINITION</code>包执行表的存储属性的在线重新定义。
                     </p>
                     <p>当您要更改以下属性时， <code class="codeph">REDEF_TABLE</code>过程使您可以在一个步骤中执行表的存储属性的在线重新定义：</p>
                     <ul style="list-style-type:disc">
                        <li>
                           <p>表空间更改，包括表，分区，索引或LOB列的表空间更改</p>
                        </li>
                        <li>
                           <p>压缩类型更改，包括表，分区，索引键或LOB列的压缩类型更改</p>
                        </li>
                        <li>
                           <p>对于LOB列，更改为<code class="codeph">SECUREFILE</code>或<code class="codeph">BASICFILE</code>存储</p>
                        </li>
                     </ul>
                     <p>当您的在线重新定义操作不限于这些更改时，您必须使用多个步骤对表进行在线重新定义。的步骤包括调用所述多个过程<code class="codeph">DBMS_REDEFINITION</code>包，其中包括以下步骤： <code class="codeph">CAN_REDEF_TABLE</code> ， <code class="codeph">START_REDEF_TABLE</code> ， <code class="codeph">COPY_TABLE_DEPENDENTS</code> ，和<code class="codeph">FINISH_REDEF_TABLE</code> 。</p>
                     <div class="infoboxnote" id="GUID-4F3B5CFB-C29C-4216-86D2-B8FC98D0FE2F__GUID-B41618F7-2B3E-45C1-AA66-746A98D8F2AA">
                        <p class="notep1">注意：</p>使用<code class="codeph">REDEF_TABLE</code>过程重新定义表时，不支持联机表重新定义回滚。
                     </div>
                  </div>
                  <div>
                     <div class="infoboxnotealso" id="GUID-4F3B5CFB-C29C-4216-86D2-B8FC98D0FE2F__GUID-A8BF2FBE-65A2-4076-8F1F-0FA03DCC3424">
                        <p class="notep1">也可以看看：</p>
                        <p></p>
                        <ul style="list-style-type:disc">
                           <li>
                              <p><a href="https://www.oracle.com/pls/topic/lookup?ctx=en/database/oracle/oracle-database/19/admin&amp;id=ARPLS74410" target="_blank"><span class="italic">Oracle Database PL / SQL包和类型参考</span></a>了解过程详细信息</p>
                           </li>
                           <li>
                              <p><span class="q">“ <a href="managing-tables.html#GUID-4E77A941-A660-4DB3-A7B8-D15FBD9BF509" title="示例说明了表的在线重新定义。">在线表重新定义示例</a> ”中的</span> <a href="managing-tables.html#GUID-4E77A941-A660-4DB3-A7B8-D15FBD9BF509__BABEAFDD">示例1</a></p>
                           </li>
                           <li>
                              <p><span class="q">“ <a href="managing-tables.html#GUID-3C702CE8-9676-4825-B92A-D4AFE78FE402" title="您可以在DBMS_REDEFINITION包中使用多个过程来执行表的在线重新定义。">在DBMS_REDEFINITION中使用多个过程执行在线重新定义</a> ”</span>以获取更多信息</p>
                           </li>
                        </ul>
                     </div>
                     <div class="familylinks">
                        <div class="parentlink">
                           <p><strong>父主题：</strong> <a href="managing-tables.html#GUID-92361F74-4796-407D-A3B9-569C6E544E34" title="您可以修改表的逻辑或物理结构。">在线重新定义表</a></p>
                        </div>
                     </div>
                  </div>
                  
               </div>
               <div class="sect3"><a id="GUID-4156DC5F-06C6-41D5-8C5A-C1586DEDE43E" name="GUID-4156DC5F-06C6-41D5-8C5A-C1586DEDE43E"></a><h4 id="ADMIN-GUID-4156DC5F-06C6-41D5-8C5A-C1586DEDE43E" class="sect4"><span class="enumeration_section">20.8.6使用DBMS_REDEFINITION中的</span>多个过程在线重新定义表</h4>
                  <p>您可以使用<code class="codeph">DBMS_REDEFINITION</code>包中的多个过程在线重新定义表。
                  </p>
                  <div>
                     <ul class="ullinks">
                        <li class="ulchildlink"><a href="managing-tables.html#GUID-3C702CE8-9676-4825-B92A-D4AFE78FE402">在DBMS_REDEFINITION中使用多个过程执行在线重新定义</a><br>您可以在<code class="codeph">DBMS_REDEFINITION</code>包中使用多个过程来执行表的在线重新定义。
                        </li>
                        <li class="ulchildlink"><a href="managing-tables.html#GUID-CDFF0B74-1C6A-4916-9E07-C09F0D309B53">构造列映射字符串</a><br>作为参数传递给<code class="codeph">START_REDEF_TABLE</code>的列映射字符串包含以逗号分隔的列映射对列表。
                        </li>
                        <li class="ulchildlink"><a href="managing-tables.html#GUID-070A3AEC-4226-4E65-BDB0-A5B2B5B48B1F">在线重新定义期间处理虚拟专用数据库（VPD）策略</a><br>如果重新定义的原始表具有为其指定的VPD策略，则可以使用<code class="codeph">START_REDEF_TABLE</code>过程中的<code class="codeph">copy_vpd_opt</code>参数在联机重新定义期间处理这些策略。
                        </li>
                        <li class="ulchildlink"><a href="managing-tables.html#GUID-15A3E7E4-043A-4C48-BE2F-6D1F4B69317E">自动创建从属对象</a><br>您可以使用<code class="codeph">COPY_TABLE_DEPENDENTS</code>过程在临时表上自动创建依赖对象。
                        </li>
                        <li class="ulchildlink"><a href="managing-tables.html#GUID-B3AA1388-F093-4861-BB7C-896EDF072602">手动创建依赖对象</a><br>如果使用SQL * Plus或Cloud Control在临时表上手动创建依赖对象，则必须使用<code class="codeph">REGISTER_DEPENDENT_OBJECT</code>过程来注册从属对象。注册依赖对象使重新定义完成过程能够将依赖对象名称恢复为重新定义之前的对象名称。
                        </li>
                     </ul>
                     <div class="familylinks">
                        <div class="parentlink">
                           <p><strong>父主题：</strong> <a href="managing-tables.html#GUID-92361F74-4796-407D-A3B9-569C6E544E34" title="您可以修改表的逻辑或物理结构。">在线重新定义表</a></p>
                        </div>
                     </div>
                  </div>
                  <a id="ADMIN12634"></a><a id="ADMIN11668"></a><div class="props_rev_3"><a id="GUID-3C702CE8-9676-4825-B92A-D4AFE78FE402" name="GUID-3C702CE8-9676-4825-B92A-D4AFE78FE402"></a><h5 id="ADMIN-GUID-3C702CE8-9676-4825-B92A-D4AFE78FE402" class="sect5"><span class="enumeration_section">20.8.6.1在DBMS_REDEFINITION中</span>使用多个过程执行在线重定义</h5>
                     <div>
                        <p>您可以在<code class="codeph">DBMS_REDEFINITION</code>包中使用多个过程来执行表的在线重新定义。
                        </p>
                        <div class="section">
                           <p>要使用多个步骤在线重新定义表格：</p>
                        </div>
                        <!-- class="section" -->
                        <ol>
                           <li class="stepexpand"><span>选择重定义方法：按键或按行</span><div>
                                 <p><span class="bold">按键 -</span>选择主键或伪主键以用于重新定义。伪主键是唯一键，所有组件列都具有<code class="codeph">NOT NULL</code>约束。对于此方法，重定义之前和之后的表的版本应具有相同的主键列。这是重新定义的首选和默认方法。
                                 </p>
                                 <p><span class="bold">通过rowid  -</span>如果没有可用的密钥，请使用此方法。在此方法中，名为<code class="codeph">M_ROW$$</code>的隐藏列将添加到表的重新定义后的版本中。建议在重新定义完成后删除此列或将其标记为未使用。重新定义的最后阶段会自动将此列设置为未使用。然后你可以使用<code class="codeph">ALTER</code> <code class="codeph">TABLE</code> ...<code class="codeph">DROP</code> <code class="codeph">UNUSED</code> <code class="codeph">COLUMNS</code>语句将其删除。
                                 </p>
                                 <p>您不能在索引组织表上使用此方法。</p>
                              </div>
                           </li>
                           <li class="stepexpand"><span>验证是否可以通过调用<code class="codeph">CAN_REDEF_TABLE</code>过程在线重新定义表。如果该表不是在线重新定义的候选者，则此过程会引发错误，指示无法在线重新定义表的原因。</span></li>
                           <li class="stepexpand"><span>使用所有所需的逻辑和物理属性创建一个空的临时表（与要重新定义的表在同一模式中）。如果要删除列，则不要将它们包含在临时表的定义中。如果要添加列，则将列定义添加到临时表。如果要修改列，则在临时表中使用所需的属性创建它。</span><div>
                                 <p>没有必要创建临时表，其中包含重新定义的表的所有索引，约束，授权和触发器，因为这些将在复制依赖对象时在步骤<a href="managing-tables.html#GUID-3C702CE8-9676-4825-B92A-D4AFE78FE402__i1013092">7中</a>定义。
                                 </p>
                              </div>
                           </li>
                           <li class="stepexpand"><span>如果要使用rowid方法重新定义分区表，请在临时表上启用行移动。</span><div><pre class="oac_no_warn" dir="ltr">ALTER TABLE ...ENABLE ROW MOVEMENT;</pre></div>
                           </li>
                           <li class="stepexpand"><span>（可选）如果要重新定义大型表并希望通过并行运行来提高下一步的性能，请发出以下语句：</span><div><pre class="oac_no_warn" dir="ltr">ALTER SESSION FORCE PARALLEL DML PARALLEL并行<span class="italic">度</span> ; ALTER SESSION FORCE PARALLEL QUERY PARALLEL并行<span class="italic">度</span> ;</pre></div>
                           </li>
                           <li class="stepexpand" id="GUID-3C702CE8-9676-4825-B92A-D4AFE78FE402__BABEIFBA"><span>通过调用<code class="codeph">START_REDEF_TABLE</code>启动重新定义过程，提供以下内容：</span><div>
                                 <ul style="list-style-type:disc">
                                    <li>
                                       <p>要在<code class="codeph">uname</code>和<code class="codeph">orig_table</code>参数中重新定义的表的模式和表名</p>
                                    </li>
                                    <li>
                                       <p><code class="codeph">int_table</code>参数中的临时表名</p>
                                    </li>
                                    <li>
                                       <p>列映射字符串，用于将要重新定义的表的列映射到<code class="codeph">col_mapping</code>参数中的临时表的列</p>
                                       <p>有关详细信息，请参阅<span class="q">“ <a href="managing-tables.html#GUID-CDFF0B74-1C6A-4916-9E07-C09F0D309B53" title="作为参数传递给START_REDEF_TABLE的列映射字符串包含以逗号分隔的列映射对列表。">构造列映射字符串</a> ”</span> 。
                                       </p>
                                    </li>
                                    <li>
                                       <p><code class="codeph">options_flag</code>参数中的重定义方法</p>
                                       <p>提供包常量以指定重定义方法。<code class="codeph">DBMS_REDEFINITION.CONS_USE_PK</code>用于指示应使用主键或伪主键完成重定义。<code class="codeph">DBMS_REDEFINITION.CONS_USE_ROWID</code>用于指示应使用rowid完成重定义。如果省略此参数，则假定使用默认的重定义方法（ <code class="codeph">CONS_USE_PK</code> ）。
                                       </p>
                                    </li>
                                    <li>
                                       <p>（可选）用于对<code class="codeph">orderby_cols</code>参数中的行进行排序的列</p>
                                    </li>
                                    <li>
                                       <p>重新定义分区表的一个分区或多个分区时， <code class="codeph">part_name</code>参数中的分区名称</p>
                                       <p>有关详细信息，请参阅<span class="q">“ <a href="managing-tables.html#GUID-9A31C4B1-1DA5-4DF8-8567-8642821056D6" title="您可以在线重新定义表的一个或多个分区。例如，如果您希望将分区移动到不同的表空间并在操作期间保持分区可用于DML，则此功能非常有用。">一个或多个分区的在线重新定义</a> ”</span> 。
                                       </p>
                                    </li>
                                    <li>
                                       <p>处理<code class="codeph">copy_vpd_opt</code>参数中的表上定义的虚拟专用数据库（VPD）策略的<code class="codeph">copy_vpd_opt</code></p>
                                       <p>有关详细信息，请参阅<span class="q">“ <a href="managing-tables.html#GUID-070A3AEC-4226-4E65-BDB0-A5B2B5B48B1F" title="如果重新定义的原始表具有为其指定的VPD策略，则可以使用START_REDEF_TABLE过程中的copy_vpd_opt参数在联机重新定义期间处理这些策略。">在线重新定义期间处理虚拟专用数据库（VPD）策略</a> ”</span> 。
                                       </p>
                                    </li>
                                 </ul>
                                 <p>由于此过程涉及复制数据，因此可能需要一段时间。正在重新定义的表在整个过程中仍可用于查询和DML。</p>
                                 <div class="infoboxnote" id="GUID-3C702CE8-9676-4825-B92A-D4AFE78FE402__GUID-C7F7B313-FA45-40D7-880D-988093874270">
                                    <p class="notep1">注意：</p>
                                    <p></p>
                                    <ul style="list-style-type:disc">
                                       <li>
                                          <p>您可以查询<code class="codeph">DBA_REDEFINITION_OBJECTS</code>视图以列出当前涉及在线重新定义的对象。
                                          </p>
                                       </li>
                                       <li>
                                          <p>如果<code class="codeph">START_REDEF_TABLE</code>因任何原因失败，则必须调用<code class="codeph">ABORT_REDEF_TABLE</code> ，否则后续重新定义表的尝试将失败。
                                          </p>
                                       </li>
                                    </ul>
                                 </div>
                              </div>
                           </li>
                           <li class="stepexpand" id="GUID-3C702CE8-9676-4825-B92A-D4AFE78FE402__i1013092"><span>使用以下两种方法之一，将要重新定义的表中的依赖对象（如触发器，索引，物化视图日志，授权和约束）和统计信息复制到临时表中。方法1是首选方法，因为它更自动，但有时您可能会选择使用方法2。方法1还允许您将表统计信息复制到临时表。</span><div>
                                 <ul style="list-style-type:disc">
                                    <li>
                                       <p>方法1：自动创建从属对象</p>
                                       <p>使用<code class="codeph">COPY_TABLE_DEPENDENTS</code>过程在临时表上自动创建依赖对象。此过程还会<span class="bold">注册</span>从属对象。注册依赖对象使得这些对象的身份及其复制的对应物可以在以后作为重新定义完成过程的一部分自动交换。结果是，当重新定义完成时，依赖对象的名称将与原始依赖对象的名称相同。
                                       </p>
                                       <p>有关更多信息，请参阅<span class="q">“ <a href="managing-tables.html#GUID-15A3E7E4-043A-4C48-BE2F-6D1F4B69317E" title="您可以使用COPY_TABLE_DEPENDENTS过程在临时表上自动创建依赖对象。">自动创建从属对象</a> ”</span> 。
                                       </p>
                                    </li>
                                    <li>
                                       <p>方法2：手动创建从属对象</p>
                                       <p>您可以在临时表上手动创建依赖对象，然后注册它们。有关更多信息，请参阅<span class="q">“ <a href="managing-tables.html#GUID-B3AA1388-F093-4861-BB7C-896EDF072602" title="如果使用SQL * Plus或Cloud Control在临时表上手动创建依赖对象，则必须使用REGISTER_DEPENDENT_OBJECT过程来注册从属对象。注册依赖对象使重新定义完成过程能够将依赖对象名称恢复为重新定义之前的对象名称。">手动创建从属对象</a> ”</span> 。
                                       </p>
                                       <div class="infoboxnote" id="GUID-3C702CE8-9676-4825-B92A-D4AFE78FE402__GUID-989ADA6A-5C95-4005-A0E2-D4DB68C0D740">
                                          <p class="notep1">注意：</p>
                                          <p>在Oracle9 <span class="italic">i中</span> ，您<span class="italic">需要</span>在临时表上手动创建触发器，索引，授权和约束，并且可能仍然存在您希望或必须这样做的情况。在这种情况下，必须创建禁用涉及临时表的任何引用约束（即临时表是引用约束的父表或子表）。在线重新定义完成后，将自动启用参照约束。此外，在重新定义过程完成或中止之前，临时表上定义的任何触发器都不会执行。
                                          </p>
                                       </div>
                                    </li>
                                 </ul>
                              </div>
                           </li>
                           <li class="stepexpand" id="GUID-3C702CE8-9676-4825-B92A-D4AFE78FE402__BABGDBJH"><span>执行<code class="codeph">FINISH_REDEF_TABLE</code>过程以完成表的重新定义。在此过程中，原始表在独占模式下锁定的时间非常短，与原始表中的数据量无关。但是， <code class="codeph">FINISH_REDEF_TABLE</code>将在完成重新定义之前等待所有挂起的DML提交。</span><div>
                                 <p><a id="d192334e13002" class="indexterm-anchor"></a>您可以使用<code class="codeph">FINISH_REDEF_TABLE</code>过程中的<code class="codeph">dml_lock_timeout</code>参数来指定过程等待挂起的DML提交的时间。该参数指定在过程正常结束之前等待的秒数。为此参数指定非<code class="codeph">NULL</code>值时，可以重新启动<code class="codeph">FINISH_REDEF_TABLE</code>过程，并从超时时间点开始继续。当参数设置为<code class="codeph">NULL</code> ，该过程不会超时。在这种情况下，如果手动停止该过程，则必须使用<code class="codeph">ABORT_REDEF_TABLE</code>过程中止在线表重新定义，并从步骤<a href="managing-tables.html#GUID-3C702CE8-9676-4825-B92A-D4AFE78FE402__BABEIFBA">6</a>开始重新开始。
                                 </p>
                              </div>
                           </li>
                           <li class="stepexpand"><span>等待对临时表的任何长时间运行的查询完成，然后删除临时表。</span><div>
                                 <p>如果在存在针对它运行的活动查询时删除临时表，则可能会遇到<code class="codeph">ORA-08103</code>错误（“对象不再存在”）。
                                 </p>
                              </div>
                           </li>
                        </ol>
                        <div class="section"></div>
                        <!-- class="section" -->
                     </div>
                     <div>
                        <div class="infoboxnotealso" id="GUID-3C702CE8-9676-4825-B92A-D4AFE78FE402__GUID-0184203F-1FB8-41E6-849E-C79C1D57DAF7">
                           <p class="notep1">也可以看看：</p>
                           <p></p>
                           <ul style="list-style-type:disc">
                              <li>
                                 <p><span class="q">“ <a href="managing-tables.html#GUID-4E77A941-A660-4DB3-A7B8-D15FBD9BF509" title="示例说明了表的在线重新定义。">在线表格重新定义示例</a> ”</span></p>
                              </li>
                              <li>
                                 <p>有关包详细信息的<a href="https://www.oracle.com/pls/topic/lookup?ctx=en/database/oracle/oracle-database/19/admin&amp;id=ARPLS042" target="_blank"><span class="italic">Oracle Database PL / SQL包和类型参考</span></a></p>
                              </li>
                           </ul>
                        </div>
                        <div class="familylinks">
                           <div class="parentlink">
                              <p><strong>父主题：使用</strong> <a href="managing-tables.html#GUID-4156DC5F-06C6-41D5-8C5A-C1586DEDE43E" title="您可以使用DBMS_REDEFINITION包中的多个过程在线重新定义表。">DBMS_REDEFINITION中的多个过程在线重新定义表</a></p>
                           </div>
                        </div>
                     </div>
                     
                  </div><a id="ADMIN12635"></a><a id="ADMIN11669"></a><div class="props_rev_3"><a id="GUID-CDFF0B74-1C6A-4916-9E07-C09F0D309B53" name="GUID-CDFF0B74-1C6A-4916-9E07-C09F0D309B53"></a><h5 id="ADMIN-GUID-CDFF0B74-1C6A-4916-9E07-C09F0D309B53" class="sect5"><span class="enumeration_section">20.8.6.2</span>构造列映射字符串</h5>
                     <div>
                        <p>作为参数传递给<code class="codeph">START_REDEF_TABLE</code>的列映射字符串包含以逗号分隔的列映射对列表。
                        </p>
                        <p>每对都具有以下语法：</p><pre class="oac_no_warn" dir="ltr">[ <span class="italic">expression</span> ] <span class="italic">column_name</span>
</pre><p><span class="italic"><code class="codeph">column_name</code></span>术语表示临时表中的列。根据SQL <code class="codeph">SELECT</code>语句中表达式的规则，可选<span class="italic"><code class="codeph">expression</code></span>可以包括重新定义的表中的列，常量，运算符，函数或方法调用等。但是，只能使用简单的确定性子表达式 - 即，在一个评估和下一个加上序列和<code class="codeph">SYSDATE</code>之间结果不变的子表达式。不允许子查询。在最简单的情况下，表达式只包含重新定义的表中的列名。
                        </p>
                        <p>如果存在表达式，则在重新定义期间将其值放在指定的临时表列中。如果省略表达式，则假定重新定义的表和临时表都具有名为<span class="italic"><code class="codeph">column_name</code></span> ，并且重新定义的表中该列的值放在临时表的同一列中。
                        </p>
                        <p>例如，如果要重新定义的表中的<code class="codeph">override</code>列要重命名为<code class="codeph">override_commission</code> ，并且每个重写佣金要提高2％，则正确的列映射对是：</p><pre class="oac_no_warn" dir="ltr">覆盖* 1.02 override_commission</pre><p>如果您提供' <code class="codeph">*</code> '或<code class="codeph">NULL</code>作为列映射字符串，则假定所有列（其名称未更改）将包含在临时表中。否则，仅考虑字符串中明确指定的那些列。列映射对的顺序并不重要。
                        </p>
                        <p>有关列映射字符串的示例，请参阅<span class="q">“ <a href="managing-tables.html#GUID-4E77A941-A660-4DB3-A7B8-D15FBD9BF509" title="示例说明了表的在线重新定义。">联机表重新定义示例</a> ”</span> 。
                        </p>
                        <div class="section">
                           <p class="subhead3" id="GUID-CDFF0B74-1C6A-4916-9E07-C09F0D309B53__GUID-B5B475F4-0FC2-450C-BB5C-D18AFD3F7343">数据转换</p>
                        </div>
                        <!-- class="section" -->
                        <div class="section">
                           <p>映射列时，您可以转换数据类型，但有一些限制。</p>
                           <p>如果提供' <code class="codeph">*</code> '或<code class="codeph">NULL</code>作为列映射字符串，则仅支持SQL允许的隐式转换。例如，您可以从<code class="codeph">CHAR</code>转换为<code class="codeph">VARCHAR2</code> ，从<code class="codeph">INTEGER</code>转换为<code class="codeph">NUMBER</code> ，依此类推。
                           </p>
                           <p>要执行其他数据类型转换（包括从一种对象类型转换为另一种对象类型或将一种集合类型转换为另一种对象类型），必须提供具有执行转换的表达式的列映射对。表达式可以包括<code class="codeph">CAST</code>函数，内置函数（如<code class="codeph">TO_NUMBER</code> ，您创建的转换函数等。
                           </p>
                        </div>
                        <!-- class="section" -->
                     </div>
                     <div>
                        <div class="familylinks">
                           <div class="parentlink">
                              <p><strong>父主题：使用</strong> <a href="managing-tables.html#GUID-4156DC5F-06C6-41D5-8C5A-C1586DEDE43E" title="您可以使用DBMS_REDEFINITION包中的多个过程在线重新定义表。">DBMS_REDEFINITION中的多个过程在线重新定义表</a></p>
                           </div>
                        </div>
                     </div>
                     
                  </div><a id="ADMIN13868"></a><div class="props_rev_3"><a id="GUID-070A3AEC-4226-4E65-BDB0-A5B2B5B48B1F" name="GUID-070A3AEC-4226-4E65-BDB0-A5B2B5B48B1F"></a><h5 id="ADMIN-GUID-070A3AEC-4226-4E65-BDB0-A5B2B5B48B1F" class="sect5"><span class="enumeration_section">20.8.6.3</span>在线重定义过程中处理虚拟专用数据库（VPD）策略</h5>
                     <div>
                        <p>如果重新定义的原始表具有为其指定的VPD策略，则可以使用<code class="codeph">START_REDEF_TABLE</code>过程中的<code class="codeph">copy_vpd_opt</code>参数在联机重新定义期间处理这些策略。
                        </p>
                        <p>您可以为此参数指定以下值：</p>
                        <div class="tblformal" id="GUID-070A3AEC-4226-4E65-BDB0-A5B2B5B48B1F__GUID-25494F06-19CF-4D41-B7CB-6B6D2CF3BE12">
                           <table cellpadding="4" cellspacing="0" class="Formal" title="" width="100%" border="1" summary="This table lists each con_vpd_opt parameter value and a description for each parameter value." frame="hsides" rules="rows">
                              <thead>
                                 <tr align="left" valign="top">
                                    <th align="left" valign="bottom" width="50%" id="d192334e13256">参数值</th>
                                    <th align="left" valign="bottom" width="50%" id="d192334e13259">描述</th>
                                 </tr>
                              </thead>
                              <tbody>
                                 <tr align="left" valign="top">
                                    <td align="left" valign="top" width="50%" id="d192334e13264" headers="d192334e13256 ">
                                       <p><code class="codeph">DBMS_REDEFINITION.CONS_VPD_NONE</code></p>
                                    </td>
                                    <td align="left" valign="top" width="50%" headers="d192334e13264 d192334e13259 ">
                                       <p>如果原始表上没有VPD策略，请指定此值。该值是默认值。</p>
                                       <p>如果指定了此值，并且原始表存在VPD策略，则会引发错误。</p>
                                    </td>
                                 </tr>
                                 <tr align="left" valign="top">
                                    <td align="left" valign="top" width="50%" id="d192334e13274" headers="d192334e13256 ">
                                       <p><code class="codeph">DBMS_REDEFINITION.CONS_VPD_AUTO</code></p>
                                    </td>
                                    <td align="left" valign="top" width="50%" headers="d192334e13274 d192334e13259 ">
                                       <p>指定此值可在联机重新定义期间自动将VPD策略从原始表复制到新表。</p>
                                    </td>
                                 </tr>
                                 <tr align="left" valign="top">
                                    <td align="left" valign="top" width="50%" id="d192334e13282" headers="d192334e13256 ">
                                       <p><code class="codeph">DBMS_REDEFINITION.CONS_VPD_MANUAL</code></p>
                                    </td>
                                    <td align="left" valign="top" width="50%" headers="d192334e13282 d192334e13259 ">
                                       <p>指定此值可在联机重新定义期间手动将VPD策略从原始表复制到新表。</p>
                                    </td>
                                 </tr>
                              </tbody>
                           </table>
                        </div>
                        <!-- class="inftblhruleinformal" -->
                        <p>如果是原来的表没有指定VPD策略，然后指定的默认值<code class="codeph">DBMS_REDEFINITION.CONS_VPD_NONE</code>为<code class="codeph">copy_vpd_opt</code>参数。
                        </p>
                        <p>指定<code class="codeph">DBMS_REDEFINITION.CONS_VPD_AUTO</code>为<code class="codeph">copy_vpd_opt</code>参数时，列名和列类型是原始表和临时表中的相同。要使用此值，原始表和临时表之间的列映射字符串必须为<code class="codeph">NULL</code>或<code class="codeph">'*'</code> 。当您使用<code class="codeph">DBMS_REDEFINITION.CONS_VPD_AUTO</code>的<code class="codeph">copy_vpd_opt</code>参数，只有表所有者和用户调用在线重定义可以在网上重新定义期间访问临时表。
                        </p>
                        <p>指定<code class="codeph">DBMS_REDEFINITION.CONS_VPD_MANUAL</code>为<code class="codeph">copy_vpd_opt</code>时任一下列条件为真参数：</p>
                        <ul style="list-style-type:disc">
                           <li>
                              <p>为原始表指定了VPD策略，并且原始表和临时表之间存在列映射。</p>
                           </li>
                           <li>
                              <p>您希望在联机重新定义表时添加或修改VPD策略。</p>
                           </li>
                        </ul>
                        <p>要手动复制VPD策略，请在运行<code class="codeph">START_REDEF_TABLE</code>过程之前为临时表指定VPD策略。完成表的在线重新定义后，重新定义的表具有修改的策略。
                        </p>
                     </div>
                     <div>
                        <div class="infoboxnotealso" id="GUID-070A3AEC-4226-4E65-BDB0-A5B2B5B48B1F__GUID-BCF2749E-E66E-4BED-8A2F-88D513FEE309">
                           <p class="notep1">也可以看看：</p>
                           <p></p>
                           <ul style="list-style-type:disc">
                              <li>
                                 <p>对于与具有VPD策略的表相关的限制<span class="q"><a href="managing-tables.html#GUID-CB5589F0-B328-4620-8809-C53696972B4C" title="Several restrictions apply to online redefinition of tables.">，</a> “</span>对<span class="q"><a href="managing-tables.html#GUID-CB5589F0-B328-4620-8809-C53696972B4C" title="有几个限制适用于表的在线重新定义。">表的在线重新定义的</a></span>限制<span class="q">”</span></p>
                              </li>
                              <li>
                                 <p><span class="q">“ <a href="managing-tables.html#GUID-4E77A941-A660-4DB3-A7B8-D15FBD9BF509" title="示例说明了表的在线重新定义。">在线表重新定义示例</a> ”，</span>用于重新定义具有VPD策略的表的示例</p>
                              </li>
                              <li>
                                 <p><a href="https://www.oracle.com/pls/topic/lookup?ctx=en/database/oracle/oracle-database/19/admin&amp;id=DBSEG007" target="_blank"><span class="italic">Oracle数据库安全指南</span></a></p>
                              </li>
                           </ul>
                        </div>
                        <div class="familylinks">
                           <div class="parentlink">
                              <p><strong>父主题：使用</strong> <a href="managing-tables.html#GUID-4156DC5F-06C6-41D5-8C5A-C1586DEDE43E" title="您可以使用DBMS_REDEFINITION包中的多个过程在线重新定义表。">DBMS_REDEFINITION中的多个过程在线重新定义表</a></p>
                           </div>
                        </div>
                     </div>
                     
                  </div><a id="ADMIN11670"></a><div class="props_rev_3"><a id="GUID-15A3E7E4-043A-4C48-BE2F-6D1F4B69317E" name="GUID-15A3E7E4-043A-4C48-BE2F-6D1F4B69317E"></a><h5 id="ADMIN-GUID-15A3E7E4-043A-4C48-BE2F-6D1F4B69317E" class="sect5"><span class="enumeration_section">20.8.6.4</span>自动创建从属对象</h5>
                     <div>
                        <p>您可以使用<code class="codeph">COPY_TABLE_DEPENDENTS</code>过程在临时表上自动创建依赖对象。
                        </p>
                        <div class="section">
                           <p>通过检查<code class="codeph">num_errors</code>输出参数，可以发现在复制依赖对象时是否发生错误。如果<code class="codeph">ignore_errors</code>参数设置为<code class="codeph">TRUE</code> ，则即使在创建对象时遇到错误， <code class="codeph">COPY_TABLE_DEPENDENTS</code>过程<code class="codeph">COPY_TABLE_DEPENDENTS</code>继续复制依赖对象。您可以通过查询<code class="codeph">DBA_REDEFINITION_ERRORS</code>视图来查看这些错误。
                           </p>
                           <p>错误的原因包括：</p>
                        </div>
                        <!-- class="section" -->
                        <div class="section">
                           <ul style="list-style-type:disc">
                              <li>
                                 <p>缺乏系统资源</p>
                              </li>
                              <li>
                                 <p>表的逻辑结构的更改，需要重新编码依赖对象。</p>
                                 <p>有关此类错误的讨论，请参见<span class="q">“ <a href="managing-tables.html#GUID-4E77A941-A660-4DB3-A7B8-D15FBD9BF509" title="示例说明了表的在线重新定义。">在线表重新定义示例</a> ”</span>中的示例3。
                                 </p>
                              </li>
                           </ul>
                           <p>如果<code class="codeph">ignore_errors</code>设置为<code class="codeph">FALSE</code> ，则<code class="codeph">COPY_TABLE_DEPENDENTS</code>程序停止复印，只要遇到任何错误的对象。
                           </p>
                           <p>更正任何错误后，您可以通过重新执行<code class="codeph">COPY_TABLE_DEPENDENTS</code>过程再次尝试复制从属对象。（可选）您可以手动创建对象，然后按照<span class="q">“ <a href="managing-tables.html#GUID-B3AA1388-F093-4861-BB7C-896EDF072602" title="如果使用SQL * Plus或Cloud Control在临时表上手动创建依赖对象，则必须使用REGISTER_DEPENDENT_OBJECT过程来注册从属对象。注册依赖对象使重新定义完成过程能够将依赖对象名称恢复为重新定义之前的对象名称。">手动创建从属对象</a> ”中的</span>说明进行注册。必要时可以多次使用<code class="codeph">COPY_TABLE_DEPENDENTS</code>过程。如果已成功复制对象，则不会再次复制该对象。
                           </p>
                        </div>
                        <!-- class="section" -->
                     </div>
                     <div>
                        <div class="familylinks">
                           <div class="parentlink">
                              <p><strong>父主题：使用</strong> <a href="managing-tables.html#GUID-4156DC5F-06C6-41D5-8C5A-C1586DEDE43E" title="您可以使用DBMS_REDEFINITION包中的多个过程在线重新定义表。">DBMS_REDEFINITION中的多个过程在线重新定义表</a></p>
                           </div>
                        </div>
                     </div>
                     
                  </div><a id="ADMIN11671"></a><div class="props_rev_3"><a id="GUID-B3AA1388-F093-4861-BB7C-896EDF072602" name="GUID-B3AA1388-F093-4861-BB7C-896EDF072602"></a><h5 id="ADMIN-GUID-B3AA1388-F093-4861-BB7C-896EDF072602" class="sect5"><span class="enumeration_section">20.8.6.5</span>手动创建从属对象</h5>
                     <div>
                        <p>如果使用SQL * Plus或Cloud Control在临时表上手动创建依赖对象，则必须使用<code class="codeph">REGISTER_DEPENDENT_OBJECT</code>过程来注册从属对象。注册依赖对象使重新定义完成过程能够将依赖对象名称恢复为重新定义之前的对象名称。
                        </p>
                        <div class="section">
                           <p>以下是需要您手动创建依赖对象的示例更改：</p>
                        </div>
                        <!-- class="section" -->
                        <div class="section">
                           <ul style="list-style-type:disc">
                              <li>
                                 <p>将索引移动到另一个表空间</p>
                              </li>
                              <li>
                                 <p>修改索引的列</p>
                              </li>
                              <li>
                                 <p>修改约束</p>
                              </li>
                              <li>
                                 <p>修改触发器</p>
                              </li>
                              <li>
                                 <p>修改物化视图日志</p>
                              </li>
                           </ul>
                           <p>运行<code class="codeph">REGISTER_DEPENDENT_OBJECT</code>过程时，必须使用<code class="codeph">dep_type</code>参数指定依赖对象的<code class="codeph">dep_type</code> 。您可以在此参数中指定以下常量：</p>
                           <ul style="list-style-type:disc">
                              <li>
                                 <p>当依赖对象是索引时<code class="codeph">DEMS_REDEFINITION.CONS_INDEX</code></p>
                              </li>
                              <li>
                                 <p>当从属对象类型是约束时， <code class="codeph">DEMS_REDEFINITION.CONS_CONSTRAINT</code></p>
                              </li>
                              <li>
                                 <p>当依赖对象是触发器时<code class="codeph">DEMS_REDEFINITION.CONS_TRIGGER</code></p>
                              </li>
                              <li>
                                 <p>当从属对象是物化视图日志时， <code class="codeph">DEMS_REDEFINITION.CONS_MVLOG</code></p>
                              </li>
                           </ul>
                           <p>如果<code class="codeph">COPY_TABLE_DEPENDENTS</code>过程无法复制依赖对象并且需要手动干预，则还可以使用<code class="codeph">REGISTER_DEPENDENT_OBJECT</code>过程。
                           </p>
                           <p>您可以查询<code class="codeph">DBA_REDEFINITION_OBJECTS</code>视图以确定注册了哪些依赖对象。此视图显示使用<code class="codeph">REGISTER_DEPENDENT_OBJECT</code>过程显式注册的依赖对象，或隐式使用<code class="codeph">COPY_TABLE_DEPENDENTS</code>过程注册的依赖对象。视图中仅显示当前信息。
                           </p>
                           <p><code class="codeph">UNREGISTER_DEPENDENT_OBJECT</code>过程可用于取消注册正在重新定义的表上的依赖对象以及临时表。
                           </p>
                           <div class="infoboxnote" id="GUID-B3AA1388-F093-4861-BB7C-896EDF072602__GUID-8C12F516-2E86-40A8-9CAC-65DAD9F6093F">
                              <p class="notep1">注意：</p>
                              <p></p>
                              <ul style="list-style-type:disc">
                                 <li>
                                    <p>手动创建的依赖对象不必与其对应的原始依赖对象相同。例如，在临时表上手动创建实例化视图日志时，可以记录不同的列。此外，临时表可以具有更多或更少的依赖对象。</p>
                                 </li>
                                 <li>
                                    <p>如果重新定义的表包含命名的LOB段，则在线重新定义期间，LOB段名称将由系统生成的名称替换。为避免这种情况，您可以使用新的LOB段名称创建临时表。</p>
                                 </li>
                              </ul>
                           </div>
                        </div>
                        <!-- class="section" -->
                     </div>
                     <div>
                        <div class="infoboxnotealso" id="GUID-B3AA1388-F093-4861-BB7C-896EDF072602__GUID-C2BA5DF3-AC17-41C6-92CD-50F8B33A94A7">
                           <p class="notep1">也可以看看：</p>
                           <p><a href="managing-tables.html#GUID-4E77A941-A660-4DB3-A7B8-D15FBD9BF509__CJAGDACH">示例4</a>在<span class="q">“ <a href="managing-tables.html#GUID-4E77A941-A660-4DB3-A7B8-D15FBD9BF509" title="示例说明了表的在线重新定义。">在线表重新定义示例</a> ”中</span>用于注册从属对象的示例</p>
                        </div>
                        <div class="familylinks">
                           <div class="parentlink">
                              <p><strong>父主题：使用</strong> <a href="managing-tables.html#GUID-4156DC5F-06C6-41D5-8C5A-C1586DEDE43E" title="您可以使用DBMS_REDEFINITION包中的多个过程在线重新定义表。">DBMS_REDEFINITION中的多个过程在线重新定义表</a></p>
                           </div>
                        </div>
                     </div>
                     
                  </div>
               </div><a id="ADMIN11672"></a><div class="props_rev_3"><a id="GUID-1153B8CB-5CF2-4C46-B5EB-F7903F801AF5" name="GUID-1153B8CB-5CF2-4C46-B5EB-F7903F801AF5"></a><h4 id="ADMIN-GUID-1153B8CB-5CF2-4C46-B5EB-F7903F801AF5" class="sect4"><span class="enumeration_section">20.8.7</span>重新定义过程的结果</h4>
                  <div>
                     <p>重新定义过程有几个结果。</p>
                     <p>以下是重新定义过程的最终结果：</p>
                     <ul style="list-style-type:disc">
                        <li>
                           <p>假设使用了<code class="codeph">REDEF_TABLE</code>或<code class="codeph">COPY_TABLE_DEPENDENTS</code> ，原始表将使用临时表的列，索引，约束，授权，触发器和统计信息进行重新定义。
                           </p>
                        </li>
                        <li>
                           <p>已注册的从属对象（显式使用<code class="codeph">REGISTER_DEPENDENT_OBJECT</code>或隐式使用<code class="codeph">COPY_TABLE_DEPENDENTS</code> ）将自动重命名，以便重新定义的表上的从属对象名称与重新定义之前相同。
                           </p>
                           <div class="infoboxnote" id="GUID-1153B8CB-5CF2-4C46-B5EB-F7903F801AF5__GUID-919C1844-6DFA-4F73-868F-EF194ADED2EF">
                              <p class="notep1">注意：</p>
                              <p>如果未完成注册或未执行自动复制，则必须手动重命名依赖对象。</p>
                           </div>
                        </li>
                        <li>
                           <p>涉及临时表的引用约束现在涉及重新定义的表并且已启用。</p>
                        </li>
                        <li>
                           <p>原始表（在重新定义之前）上定义的任何索引，触发器，物化视图日志，授权和约束都将传输到临时表，并在用户删除临时表时被删除。在重新定义之前涉及原始表的任何引用约束现在涉及临时表并被禁用。</p>
                        </li>
                        <li>
                           <p>某些PL / SQL对象，视图，同义词和其他依赖于表的对象可能会失效。只有那些依赖于已更改的表元素的对象才会失效。例如，如果PL / SQL过程仅查询重新定义的表中未重定义的列，则该过程仍然有效。有关架构对象依赖关系的更多信息，请参阅<span class="q">“ <a href="managing-schema-objects.html#GUID-46D82F8E-C360-4223-B469-18039B1FFB21" title="Oracle数据库提供了一种自动机制，可确保从属对象始终与其引用的对象保持同步。您也可以手动重新编译无效对象。">管理对象依赖关系</a> ”</span> 。
                           </p>
                        </li>
                     </ul>
                  </div>
                  <div>
                     <div class="familylinks">
                        <div class="parentlink">
                           <p><strong>父主题：</strong> <a href="managing-tables.html#GUID-92361F74-4796-407D-A3B9-569C6E544E34" title="您可以修改表的逻辑或物理结构。">在线重新定义表</a></p>
                        </div>
                     </div>
                  </div>
                  
               </div><a id="ADMIN11673"></a><div class="props_rev_3"><a id="GUID-B3981CA4-02E9-430C-8449-3EC28B00A06E" name="GUID-B3981CA4-02E9-430C-8449-3EC28B00A06E"></a><h4 id="ADMIN-GUID-B3981CA4-02E9-430C-8449-3EC28B00A06E" class="sect4"><span class="enumeration_section">20.8.8</span>执行中间同步</h4>
                  <div>
                     <p>在重新定义过程中，如果在原始表上执行了大量DML语句，则可以将临时表与原始表同步。</p>
                     <div class="section">
                        <p>通过调用<code class="codeph">START_REDEF_TABLE</code>并在调用<code class="codeph">FINISH_REDEF_TABLE</code>之前启动重新定义过程后，可能已在原始表上执行了大量DML语句。如果您知道这种情况，则建议您定期将临时表与原始表同步。
                        </p>
                        <p>使用<code class="codeph">START_REDEF_TABLE</code>过程启动联机表重定义操作时，它会创建内部物化视图以促进同步。刷新此内部物化视图以使临时表与原始表同步。
                        </p>
                        <p>要将临时表与原始表同步：</p>
                        <ul style="list-style-type:disc">
                           <li>
                              <p>运行<code class="codeph">SYNC_INTERIM_TABLE</code>在程序<code class="codeph">DBMS_REDEFINITION</code>包。
                              </p>
                           </li>
                        </ul>
                        <p>调用此过程可缩短<code class="codeph">FINISH_REDEF_TABLE</code>完成重新定义过程所需的时间。您可以调用<code class="codeph">SYNC_INTERIM_TABLE</code>的次数没有限制。</p>
                        <p>在<code class="codeph">FINISH_REDEF_TABLE</code>期间锁定原始表的少量时间与是否已调用<code class="codeph">SYNC_INTERIM_TABLE</code>无关。
                        </p>
                     </div>
                     <!-- class="section" -->
                  </div>
                  <div>
                     <div class="familylinks">
                        <div class="parentlink">
                           <p><strong>父主题：</strong> <a href="managing-tables.html#GUID-92361F74-4796-407D-A3B9-569C6E544E34" title="您可以修改表的逻辑或物理结构。">在线重新定义表</a></p>
                        </div>
                     </div>
                  </div>
                  
               </div>
               <div class="sect3"><a id="GUID-D902E9EE-9EA2-434B-934E-43A549D64CEB" name="GUID-D902E9EE-9EA2-434B-934E-43A549D64CEB"></a><h4 id="ADMIN-GUID-D902E9EE-9EA2-434B-934E-43A549D64CEB" class="sect4"><span class="enumeration_section">20.8.9</span>在线表重新定义期间刷新相关的物化视图</h4>
                  <div>
                     <p>要在联机表重新定义期间刷新相关的快速可刷新<code class="codeph">REDEF_TABLE</code> ，请在<code class="codeph">REDEF_TABLE</code>过程或<code class="codeph">START_REDEF_TABLE</code>过程中将<code class="codeph">refresh_dep_mviews</code>参数设置为<code class="codeph">Y</code>
                     </p>
                     <div class="section">
                        <p>从属物化视图是在重新定义的表上定义的任何物化视图。在线表重新定义后执行完全刷新的从属物化视图可能非常耗时。您可以在联机表重新定义期间逐步刷新快速可刷新的物化视图，以提高操作效率。</p>
                        <p>以下限制适用于刷新从属实体化视图：</p>
                        <ul style="list-style-type:disc">
                           <li>
                              <p>物化视图必须快速刷新。</p>
                           </li>
                           <li>
                              <p>不支持<code class="codeph">ROWID</code>物化视图。
                              </p>
                           </li>
                           <li>
                              <p>不支持物化连接视图。</p>
                           </li>
                        </ul>
                        <p>在线表重新定义后，需要完全刷新相关的<code class="codeph">ROWID</code>物化视图和物化连接视图。
                        </p>
                     </div>
                     <!-- class="section" -->
                     <ol>
                        <li class="stepexpand"><span>在SQL * Plus中，以具有执行表的在线重新定义所需特权的用户身份进行连接。</span><div>具体而言，用户必须具有<span class="q">“ <a href="managing-tables.html#GUID-0191D286-24D5-4E2A-817B-99FAAB96D4B3" title="Execute privileges on the DBMS_REDEFINITION package are required to run subprograms in the package. Execute privileges on the DBMS_REDEFINITION package are granted to EXECUTE_CATALOG_ROLE.">DBMS_REDEFINITION包所需</a></span>的权限”中描述的<span class="q"><a href="managing-tables.html#GUID-0191D286-24D5-4E2A-817B-99FAAB96D4B3" title="要在程序包中运行子程序，需要DBMS_REDEFINITION程序包的执行权限。DBMS_REDEFINITION包的执行权限被授予EXECUTE_CATALOG_ROLE。">权限</a></span> 。
                           </div>
                           <div>请参见<span class="q">“ <a href="getting-started-with-database-administration.html#GUID-895EC72B-C620-4D93-9F23-3F6DC1706764" title="Oracle数据库包括以下组件：Oracle数据库实例，它是进程和内存的集合，以及一组包含用户数据和系统数据的磁盘文件。">使用SQL * Plus连接到数据库</a> ”</span> 。
                           </div>
                        </li>
                        <li class="stepexpand"><span>使用以下方法之一对表执行在线重新定义：</span><ul>
                              <li>运行<code class="codeph">REDEF_TABLE</code>过程并确保<code class="codeph">refresh_dep_mviews</code>参数设置为<code class="codeph">Y</code><p>使用此方法，在重新定义操作结束时执行一次从属物化视图的快速刷新。</p>
                              </li>
                              <li>使用<code class="codeph">START_REDEF_TABLE</code>过程启动在线表重新定义，并确保将<code class="codeph">refresh_dep_mviews</code>参数设置为<code class="codeph">Y</code>此方法以<code class="codeph">FINISH_REDEF_TABLE</code>过程结束。
                                 <p>使用此方法，在运行<code class="codeph">START_REDEF_TABLE</code>过程时，每次运行<code class="codeph">SYNC_INTERIM_TABLE</code>过程以及运行<code class="codeph">FINISH_REDEF_TABLE</code>过程时，都会执行从属物化视图的快速刷新。
                                 </p>
                                 <div class="infoboxnote" id="GUID-D902E9EE-9EA2-434B-934E-43A549D64CEB__GUID-6C5964CF-9414-4674-AAE7-784EDFCE264F">
                                    <p class="notep1">注意：</p>
                                    <ul style="list-style-type:disc">
                                       <li>
                                          <p>您可以通过查询<code class="codeph">DBA_REDEFINITION_STATUS</code>视图来检查在线表重新定义操作的<code class="codeph">refresh_dep_mviews</code>参数的值。
                                          </p>
                                       </li>
                                       <li>
                                          <p>您可以通过查询<code class="codeph">V$ONLINE_REDEF</code>视图中的<code class="codeph">REFRESH_STATEMENT_SQL_ID</code>和<code class="codeph">REFRESH_STATEMENT</code>列来检查在联机表重新定义期间自动运行的刷新进度。您可以使用<code class="codeph">REFRESH_STATEMENT_SQL_ID</code>列中返回的<code class="codeph">SQL_ID</code>值来监视视图中的刷新进度，例如<code class="codeph">V$SQL</code>视图和<code class="codeph">V$SQL_MONITOR</code>视图。
                                          </p>
                                       </li>
                                       <li>
                                          <p>如果要在联机表重定义操作期间更改<code class="codeph">refresh_dep_mviews</code>参数的值，则可以使用<code class="codeph">DBMS_REDEFINITION.SET_PARAM</code>过程重置参数。
                                          </p>
                                       </li>
                                    </ul>
                                 </div>
                              </li>
                           </ul>
                        </li>
                     </ol>
                     <div class="example" id="GUID-D902E9EE-9EA2-434B-934E-43A549D64CEB__GUID-22E434E5-A00D-4D07-A9BB-B4B4959382A4">
                        <p class="titleinexample">示例20-15运行REDEF_TABLE过程时刷新从属实体化视图</p>此示例重新定义<code class="codeph">hr.employees</code>表以使用高级行压缩来压缩表并刷新相关的物化视图。<pre class="pre codeblock"><code>BEGIN DBMS_REDEFINITION.REDEF_TABLE（uname =&gt;'HR'，tname =&gt;'EMPLOYEES'，table_compression_type =&gt;'ROW STORE COMPRESS ADVANCED'，refresh_dep_mviews =&gt;'Y'）;结束; /</code></pre></div>
                     <!-- class="example" -->
                     <div class="example" id="GUID-D902E9EE-9EA2-434B-934E-43A549D64CEB__GUID-30B89390-F2BB-40B8-BFA9-A6020B8DADED">
                        <p class="titleinexample">示例20-16以START_REDEF_TABLE过程开始时刷新从属实体化视图</p>
                        <p>假设您要重新定义<code class="codeph">oe.orders</code>表。表定义是：</p><pre class="pre codeblock"><code>CREATE TABLE oe.orders（order_id NUMBER（12），order_date TIMESTAMP WITH LOCAL TIME ZONE，order_mode VARCHAR2（8），customer_id NUMBER（6），order_status NUMBER（2），order_total NUMBER（8,2），sales_rep_id NUMBER（6） ，promotion_id NUMBER（6））;</code></pre><p>此示例重新定义表以将<code class="codeph">order_mode</code>列的大小增加到<code class="codeph">16</code> 。临时表定义是：</p><pre class="pre codeblock"><code>CREATE TABLE oe.int_orders（order_id NUMBER（12），order_date TIMESTAMP WITH LOCAL TIME ZONE，order_mode VARCHAR2（16），customer_id NUMBER（6），order_status NUMBER（2），order_total NUMBER（8,2），sales_rep_id NUMBER（6） ，promotion_id NUMBER（6））;</code></pre><p>还假设此表具有相关的物化视图。该表具有使用以下语句创建的物化视图日志：</p><pre class="pre codeblock"><code>使用PRIMARY KEY，ROWID创建物料化的视图登录oe.orders;</code></pre><p><code class="codeph">oe.orders</code>表具有以下依赖的物化视图：</p><pre class="pre codeblock"><code>创建物化视图oe.orders_pk快速刷新选择*来自oe.orders; CREATE MATERIALIZED VIEW oe.orders_rowid快速刷新，选择*来自oe.orders;</code></pre><p><code class="codeph">oe.orders_pk</code>物化视图是一种快速可刷新的主键物化视图。因此，可以在联机表重新定义期间刷新它。
                        </p>
                        <p><code class="codeph">oe.orders_rowid</code>物化视图可快速刷新，但它是一个<code class="codeph">ROWID</code>物化视图。因此，在联机表重新定义期间无法刷新。
                        </p>
                        <p>完成以下步骤以在<code class="codeph">oe.orders</code>表上执行联机表重新定义，同时刷新<code class="codeph">oe.orders_pk</code>物化视图：</p>
                        <ol>
                           <li>
                              <p>开始重新定义过程。</p><pre class="oac_no_warn" dir="ltr">BEGIN DBMS_REDEFINITION.START_REDEF_TABLE（uname =&gt;'oe'，orig_table =&gt;'orders'，int_table =&gt;'int_orders'，options_flag =&gt; DBMS_REDEFINITION.CONS_USE_PK，refresh_dep_mviews =&gt;'Y'）;结束; /</pre></li>
                           <li>
                              <p>复制相关对象。（自动在<code class="codeph">oe.int_orders</code>上创建任何触发器，索引，物化视图日志，授权和约束。）
                              </p><pre class="oac_no_warn" dir="ltr">DECLARE num_errors PLS_INTEGER; BEGIN DBMS_REDEFINITION.COPY_TABLE_DEPENDENTS（uname =&gt;'oe'，orig_table =&gt;'orders'，int_table =&gt;'int_orders'，copy_indexes =&gt; DBMS_REDEFINITION.CONS_ORIG_PARAMS，copy_triggers =&gt; TRUE，copy_constraints =&gt; TRUE，copy_privileges =&gt; TRUE，ignore_errors = &gt; TRUE，num_errors =&gt; num_errors）;结束; /</pre></li>
                           <li>
                              <div class="p">检查重定义状态：<pre class="oac_no_warn" dir="ltr">选择REDEFINITION_ID，REFRESH_DEP_MVIEWS来自DBA_REDEFINITION_STATUS，其中BASE_TABLE_OWNER ='OE'和BASE_TABLE_NAME ='ORDERS';</pre></div>
                           </li>
                           <li>
                              <p>在原始表上执行DML。例如：</p><pre class="oac_no_warn" dir="ltr">INSERT INTO oe.orders VALUES（3000，sysdate，'direct'，102,1,42283.2,154，NULL）;承诺;</pre></li>
                           <li>
                              <p>同步临时表<code class="codeph">oe.int_orders</code> 。此步骤刷新从属物化视图<code class="codeph">oe.orders_pk</code> 。
                              </p><pre class="oac_no_warn" dir="ltr">BEGIN DBMS_REDEFINITION.SYNC_INTERIM_TABLE（uname =&gt;'OE'，orig_table =&gt;'ORDERS'，int_table =&gt;'INT_ORDERS'）;结束; /</pre></li>
                           <li>
                              <div class="p">检查<code class="codeph">oe.orders</code>表的从属物化视图的刷新状态：<pre class="oac_no_warn" dir="ltr">选择m。所有者，m。MVIEW_NAME，m。STALENESS，m。来自ALL_MVIEWS的LAST_REFRESH_DATE m，ALL_MVIEW_DETAIL_RELATIONS d其中。OWNER = d。所有者和m。MVIEW_NAME = d。MVIEW_NAME和d。DETAILOBJ_OWNER ='OE'和d。DETAILOBJ_NAME ='订单';</pre><code class="codeph">oe.orders_pk</code>物化视图在上一步中被刷新，因此它的<code class="codeph">STALENESS</code>状态为<code class="codeph">FRESH</code> 。该<code class="codeph">oe.orders_rowid</code>物化视图在上一步中未刷新，所以它有<code class="codeph">NEEDS_COMPLILE</code>其<code class="codeph">STALENESS</code>的状态。
                              </div>
                           </li>
                           <li>
                              <p>完成重新定义。</p><pre class="oac_no_warn" dir="ltr">BEGIN DBMS_REDEFINITION.FINISH_REDEF_TABLE（uname =&gt;'OE'，orig_table =&gt;'ORDERS'，int_table =&gt;'INT_ORDERS'）;结束; /</pre><p>您可以查询<code class="codeph">oe.orders_pk</code>物化视图以确认插入到<code class="codeph">oe.orders</code>表中的新行存在于物化视图中，因为它在联机表重新定义期间已刷新。
                              </p>
                           </li>
                        </ol>
                     </div>
                     <!-- class="example" -->
                  </div>
                  <div>
                     <div class="relinfo">
                        <p><strong>相关话题</strong></p>
                        <ul>
                           <li><a href="managing-tables.html#GUID-273794DD-440A-43DE-B252-8AC91D54FC33" title="您可以查询V $ ONLINE_REDEF视图以监视联机表重定义操作的进度。">监控在线表重新定义进度</a></li>
                        </ul>
                     </div>
                     <div class="familylinks">
                        <div class="parentlink">
                           <p><strong>父主题：</strong> <a href="managing-tables.html#GUID-92361F74-4796-407D-A3B9-569C6E544E34" title="您可以修改表的逻辑或物理结构。">在线重新定义表</a></p>
                        </div>
                     </div>
                  </div>
               </div>
               <div class="sect3"><a id="GUID-273794DD-440A-43DE-B252-8AC91D54FC33" name="GUID-273794DD-440A-43DE-B252-8AC91D54FC33"></a><h4 id="ADMIN-GUID-273794DD-440A-43DE-B252-8AC91D54FC33" class="sect4"><span class="enumeration_section">20.8.10</span>监控在线表重定义进度</h4>
                  <div>
                     <p>您可以查询<code class="codeph">V$ONLINE_REDEF</code>视图以监视联机表重定义操作的进度。
                     </p>
                     <div class="section">
                        <p>在线重新定义表的过程中，某些操作可能需要很长时间才能执行。在执行这些操作时，您可以查询<code class="codeph">V$ONLINE_REDEF</code>视图以获取有关操作进度的详细信息。例如， <code class="codeph">DBMS_REDEFINITION.START_REDEF_TABLE</code>过程可能需要很长时间才能将<code class="codeph">DBMS_REDEFINITION.START_REDEF_TABLE</code>加载到临时表中。
                        </p>
                        <p><code class="codeph">V$ONLINE_REDEF</code>视图为<code class="codeph">PROGRESS</code>列中的操作提供百分比完整值。此视图显示在<code class="codeph">OPERATION</code>列中完成操作所需的总步骤数的当前步骤。例如，如果操作中有10个步骤，则此列可能会显示<code class="codeph">Step 6 out of 10</code> 10步中的<code class="codeph">Step 6 out of 10</code> 。该视图还包括<code class="codeph">SUBOPERATION</code>列和<code class="codeph">DETAILED_MESSAGE</code>列，以获取有关当前操作的更详细信息。
                        </p>
                        <p>在联机表重新定义过程中，将创建内部物化视图，并在某些操作期间刷新此物化视图，以使原始表和临时表保持同步。您可以通过查询<code class="codeph">V$ONLINE_REDEF</code>视图中的<code class="codeph">REFRESH_STATEMENT_SQL_ID</code>和<code class="codeph">REFRESH_STATEMENT</code>列来检查在联机表重新定义期间自动运行的刷新进度。您可以使用<code class="codeph">REFRESH_STATEMENT_SQL_ID</code>列中返回的<code class="codeph">SQL_ID</code>值来监视视图中的刷新进度，例如<code class="codeph">V$SQL</code>视图和<code class="codeph">V$SQL_MONITOR</code>视图。
                        </p>
                     </div>
                     <!-- class="section" -->
                     <ol>
                        <li><span>在与执行联机表重新定义的会话分开的会话中连接到数据库。</span></li>
                        <li><span>查询<code class="codeph">V$ONLINE_REDEF</code>视图。</span></li>
                     </ol>
                     <div class="example" id="GUID-273794DD-440A-43DE-B252-8AC91D54FC33__GUID-FD4211D3-6CD8-4047-9E35-BE15B0E533C7">
                        <p class="titleinexample">示例20-17监视在线表重新定义进度</p>
                        <p>此示例通过添加<code class="codeph">cust_alt_phone_number</code>列重新定义Oracle提供的<code class="codeph">sh.customers</code>表。
                        </p><pre class="pre codeblock"><code>CREATE TABLE客户（cust_id NUMBER NOT NULL，cust_first_name VARCHAR2（20）NOT NULL，cust_last_name VARCHAR2（40）NOT NULL，cust_gender CHAR（1）NOT NULL，cust_year_of_birth NUMBER（4）NOT NULL，cust_marital_status VARCHAR2（20），cust_street_address VARCHAR2（ 40）NOT NULL，cust_postal_code VARCHAR2（10）NOT NULL，cust_city VARCHAR2（30）NOT NULL，cust_city_id NUMBER NOT NULL，cust_state_province VARCHAR2（40）NOT NULL，cust_state_province_id NUMBER NOT NULL，country_id NUMBER NOT NULL，cust_main_phone_number VARCHAR2（25）NOT NOT NULL，cust_income_level VARCHAR2（30），cust_credit_limit NUMBER，cust_email VARCHAR2（50），cust_total VARCHAR2（14）NOT NULL，cust_total_id NUMBER NOT NULL，cust_src_id NUMBER，cust_eff_from DATE，cust_eff_to DATE，cust_valid VARCHAR2（1））;</code></pre><p>该表包含大量数据，在线表重新定义过程中的一些操作需要时间。此示例通过查询<code class="codeph">V$ONLINE_REDEF</code>视图来监视各种操作。
                        </p>
                        <ol>
                           <li>
                              <p>在SQL * Plus中，以具有执行表的在线重新定义所需特权的用户身份进行连接。</p>
                              <p>具体而言，用户必须具有<span class="q">“ <a href="managing-tables.html#GUID-0191D286-24D5-4E2A-817B-99FAAB96D4B3" title="Execute privileges on the DBMS_REDEFINITION package are required to run subprograms in the package. Execute privileges on the DBMS_REDEFINITION package are granted to EXECUTE_CATALOG_ROLE.">DBMS_REDEFINITION包所需</a></span>的权限”中描述的<span class="q"><a href="managing-tables.html#GUID-0191D286-24D5-4E2A-817B-99FAAB96D4B3" title="要在程序包中运行子程序，需要DBMS_REDEFINITION程序包的执行权限。DBMS_REDEFINITION包的执行权限被授予EXECUTE_CATALOG_ROLE。">权限</a></span> 。
                              </p>
                              <p>请参见<span class="q">“ <a href="getting-started-with-database-administration.html#GUID-895EC72B-C620-4D93-9F23-3F6DC1706764" title="Oracle数据库包括以下组件：Oracle数据库实例，它是进程和内存的集合，以及一组包含用户数据和系统数据的磁盘文件。">使用SQL * Plus连接到数据库</a> ”</span> 。
                              </p>
                           </li>
                           <li>
                              <p>创建一个临时表<code class="codeph">sh.int_customers</code> 。
                              </p><pre class="oac_no_warn" dir="ltr">CREATE TABLE sh.int_customers（cust_id NUMBER NOT NULL，cust_first_name VARCHAR2（20）NOT NULL，cust_last_name VARCHAR2（40）NOT NULL，cust_gender CHAR（1）NOT NULL，cust_year_of_birth NUMBER（4）NOT NULL，cust_marital_status VARCHAR2（20），cust_street_address VARCHAR2（40）NOT NULL，cust_postal_code VARCHAR2（10）NOT NULL，cust_city VARCHAR2（30）NOT NULL，cust_city_id NUMBER NOT NULL，cust_state_province VARCHAR2（40）NOT NULL，cust_state_province_id NUMBER NOT NULL，country_id NUMBER NOT NULL，cust_main_phone_number VARCHAR2（25 ）NOT NULL，cust_income_level VARCHAR2（30），cust_credit_limit NUMBER，cust_email VARCHAR2（50），cust_total VARCHAR2（14）NOT NULL，cust_total_id NUMBER NOT NULL，cust_src_id NUMBER，cust_eff_from DATE，cust_eff_to DATE，cust_valid VARCHAR2（1），cust_alt_phone_number VARCHAR2（ 25））;</pre></li>
                           <li>
                              <p>启动重新定义过程，并监视操作的进度。</p><pre class="oac_no_warn" dir="ltr">BEGIN DBMS_REDEFINITION.START_REDEF_TABLE（uname =&gt;'sh'，orig_table =&gt;'customers'，int_table =&gt;'int_customers'，options_flag =&gt; DBMS_REDEFINITION.CONS_USE_PK）;结束; /</pre><p>当此操作正在运行时，并且在与执行联机表重新定义的会话分开的会话中，查询<code class="codeph">V$ONLINE_REDEF</code>视图以监视其进度：</p><pre class="pre codeblock"><code>SELECT * FROM V $ ONLINE_REDEF;</code></pre><p>此查询的输出可能显示以下内容：</p>
                              <ul style="list-style-type:disc">
                                 <li>
                                    <p><code class="codeph">START_REDEF_TABLE</code>进行<code class="codeph">OPERATION</code></p>
                                 </li>
                                 <li>
                                    <p><code class="codeph">complete refresh the materialized view</code> <code class="codeph">SUBOPERATION</code> <code class="codeph">complete refresh the materialized view</code></p>
                                 </li>
                                 <li>
                                    <p><code class="codeph">PROGRESS</code> <code class="codeph">step 6 out of 7</code></p>
                                 </li>
                              </ul>
                           </li>
                           <li>
                              <p>复制相关对象。（自动在<code class="codeph">sh.int_customers</code>上创建任何触发器，索引，物化视图日志，授权和约束。）
                              </p><pre class="oac_no_warn" dir="ltr">DECLARE num_errors PLS_INTEGER; BEGIN DBMS_REDEFINITION.COPY_TABLE_DEPENDENTS（uname =&gt;'sh'，orig_table =&gt;'customers'，int_table =&gt;'int_customers'，copy_indexes =&gt; DBMS_REDEFINITION.CONS_ORIG_PARAMS，copy_triggers =&gt; TRUE，copy_constraints =&gt; TRUE，copy_privileges =&gt; TRUE，ignore_errors = &gt; TRUE，num_errors =&gt; num_errors）;结束; /</pre><p>当此操作正在运行时，并且在与执行联机表重新定义的会话分开的会话中，查询<code class="codeph">V$ONLINE_REDEF</code>视图以监视其进度：</p><pre class="pre codeblock"><code>SELECT * FROM V $ ONLINE_REDEF;</code></pre><p>此查询的输出可能显示以下内容：</p>
                              <ul style="list-style-type:disc">
                                 <li>
                                    <p><code class="codeph">COPY_TABLE_DEPENDENTS</code>进行<code class="codeph">OPERATION</code></p>
                                 </li>
                                 <li>
                                    <p><code class="codeph">copy the indexes</code> <code class="codeph">SUBOPERATION</code> <code class="codeph">copy the indexes</code></p>
                                 </li>
                                 <li>
                                    <p><code class="codeph">PROGRESS</code> <code class="codeph">step 3 out of 7</code></p>
                                 </li>
                              </ul>
                              <p>请注意，此调用的<code class="codeph">ignore_errors</code>参数设置为<code class="codeph">TRUE</code> 。原因是临时表是使用主键约束创建的，当<code class="codeph">COPY_TABLE_DEPENDENTS</code>尝试从原始表复制主键约束和索引时，会发生错误。您可以忽略这些错误。
                              </p>
                           </li>
                           <li>
                              <p>同步临时表<code class="codeph">hr.int_emp_redef</code> 。
                              </p><pre class="oac_no_warn" dir="ltr">BEGIN DBMS_REDEFINITION.SYNC_INTERIM_TABLE（uname =&gt;'sh'，orig_table =&gt;'customers'，int_table =&gt;'int_customers'）;结束; /</pre></li>
                           <li>
                              <p>完成重新定义。</p><pre class="oac_no_warn" dir="ltr">BEGIN DBMS_REDEFINITION.FINISH_REDEF_TABLE（uname =&gt;'sh'，orig_table =&gt;'customers'，int_table =&gt;'int_customers'）;结束; /</pre></li>
                        </ol>
                     </div>
                     <!-- class="example" -->
                  </div>
                  <div>
                     <div class="relinfo">
                        <p><strong>相关话题</strong></p>
                        <ul>
                           <li><a href="managing-tables.html#GUID-D902E9EE-9EA2-434B-934E-43A549D64CEB" title="要在联机表重新定义期间刷新相关的快速可刷新实体化视图，请在REDEF_TABLE过程或START_REDEF_TABLE过程中将refresh_dep_mviews参数设置为Y.">在线表重新定义期间刷新相关的物化视图</a></li>
                        </ul>
                     </div>
                     <div class="familylinks">
                        <div class="parentlink">
                           <p><strong>父主题：</strong> <a href="managing-tables.html#GUID-92361F74-4796-407D-A3B9-569C6E544E34" title="您可以修改表的逻辑或物理结构。">在线重新定义表</a></p>
                        </div>
                     </div>
                  </div>
               </div>
               <div class="sect3"><a id="GUID-58F4E092-A86D-4E00-96F6-56A596C91A53" name="GUID-58F4E092-A86D-4E00-96F6-56A596C91A53"></a><h4 id="ADMIN-GUID-58F4E092-A86D-4E00-96F6-56A596C91A53" class="sect4"><span class="enumeration_section">20.8.11</span>失败后重新启动在线表重新定义</h4>
                  <div>
                     <p>如果联机表重新定义失败，则可以检查<code class="codeph">DBA_REDEFINITION_STATUS</code>视图以查看错误信息和可重新启动的信息。
                     </p>
                     <div class="section">
                        <p>如果<code class="codeph">RESTARTABLE</code>为<code class="codeph">Y</code> ，则可以更正错误并重新启动上次停止的在线重新定义过程。如果<code class="codeph">RESTARTABLE</code>为<code class="codeph">N</code> ，则必须中止重定义操作。
                        </p>
                        <p>在某些情况下，可以在失败后重新启动表的在线重新定义。重新启动操作意味着在线重新定义过程从故障停止的地方开始，并且不会丢失任何工作。例如，如果<code class="codeph">SYNC_INTERIM_TABLE</code>过程调用由于“无法扩展表空间中的表”错误而失败，则可以通过增加空间不足的表空间大小并重新运行<code class="codeph">SYNC_INTERIM_TABLE</code>过程调用来解决问题。
                        </p>
                        <p>如果联机表重新定义失败，则可以完成以下步骤以重新启动它：</p>
                     </div>
                     <!-- class="section" -->
                     <ol>
                        <li class="stepexpand"><span>查询<code class="codeph">DBA_REDEFINITION_STATUS</code>视图以确定失败的原因以及纠正失败的操作。</span><div>例如，运行以下查询：<pre class="pre codeblock"><code>SELECT BASE_TABLE_NAME，INTERIM_OBJECT_NAME，操作，状态，可重新启动，来自DBA_REDEFINITION_STATUS的操作;</code></pre></div>
                           <div>如果<code class="codeph">RESTARTABLE</code>值为<code class="codeph">Y</code> ，则可以重新启动操作。如果<code class="codeph">RESTARTABLE</code>值为<code class="codeph">N</code> ，则无法重新启动操作，并且必须从头开始重新定义。
                           </div>
                        </li>
                        <li class="stepexpand"><span>执行上一步查询结果中指定的操作。</span></li>
                        <li class="stepexpand"><span>使用查询结果中指定的操作重新启动在线重新定义，并运行所有后续操作以完成表的在线重新定义。</span></li>
                     </ol>
                     <div class="example" id="GUID-58F4E092-A86D-4E00-96F6-56A596C91A53__GUID-B3F87946-75EC-43F0-AF6D-1D8FD2B62643">
                        <p class="titleinexample">示例20-18 SYNC_INTERIM_TABLE过程调用失败</p>
                        <div class="p">此示例说明重新启动在<code class="codeph">SYNC_INTERIM_TABLE</code>过程调用上失败的联机重定义操作，并显示以下错误：<pre class="pre codeblock"><code>BEGIN DBMS_REDEFINITION.SYNC_INTERIM_TABLE（'U1'，'ORIG'，'INT'）;结束; / ORA-42009：同步重定义ORA-01653时发生错误：无法扩展表U1。表空间中的INT由8表示my_tbs ORA-06512：在“SYS.DBMS_REDEFINITION”，第148行ORA-06512：在“SYS.DBMS_REDEFINITION”，第2807行ORA-06512：在第2行</code></pre></div>
                        <ol>
                           <li>
                              <p>查询<code class="codeph">DBA_REDEFINITION_STATUS</code>视图：</p><pre class="pre codeblock"><code>选择BASE_TABLE_NAME，INT_TABLE_NAME，操作，状态，可重新启动，来自DBA_REDEFINITION_STATUS的操作; BASE_TABLE_NAME INT_OBJ_NAME操作状态可重启动作--------------- ------------ ----------------- -  ------- ----------- --------- ORIG INT SYNC_INTERIM_TABLE FAILED Y修复错误</code></pre><p>可以重新启动在线重新定义操作，因为查询结果中的<code class="codeph">RESTARTABLE</code>为<code class="codeph">Y</code>要重新启动操作，请更正操作失败时返回的错误并重新启动操作。在此示例中，错误为“ORA-01653：无法扩展表<code class="codeph">U1.表空间<code class="codeph">my_tbs</code> INT</code>为8“。
                              </p>
                           </li>
                           <li>
                              <div class="p">通过<code class="codeph">my_tbs</code>添加数据文件来增加<code class="codeph">my_tbs</code>表空间的大小：<pre class="pre codeblock"><code>ALTER TABLESPACE my_tbs添加数据文件'/u02/oracle/data/my_tbs2.dbf'SIZE 100M;</code></pre></div>
                           </li>
                           <li>
                              <p>重新运行<code class="codeph">SYNC_INTERIM_TABLE</code>过程调用：</p><pre class="pre codeblock"><code>BEGIN DBMS_REDEFINITION.SYNC_INTERIM_TABLE（'U1'，'ORIG'，'INT'）;结束; /</code></pre></li>
                        </ol>
                     </div>
                     <!-- class="example" -->
                     <div class="example" id="GUID-58F4E092-A86D-4E00-96F6-56A596C91A53__GUID-98026593-33B0-4CC9-A805-BFFBBB463E75">
                        <p class="titleinexample">例20-19物化视图日志问题</p>
                        <p>在原始表上启动重新定义后，物化视图日志可能存在问题。例如，由于某种原因，物化视图日志可能会被意外删除或损坏。在这种情况下，返回类似于以下的错误：</p><pre class="pre codeblock"><code>第1行的错误：ORA-42010：同步重定义ORA-12034时发生错误：物化视图登录“HR”。“T1”比上次刷新小</code></pre><p>假设正在重新定义使用以下SQL语句创建的表：</p><pre class="pre codeblock"><code>CREATE TABLE hr.t1（c1 NUMBER PRIMARY KEY，c2 NUMBER）TABLESPACE example_tbs;</code></pre><p>假设使用以下更改表的表空间的SQL语句创建了一个临时表：</p><pre class="pre codeblock"><code>CREATE TABLE hr.int_t1（c1 NUMBER PRIMARY KEY，c2 NUMBER）TABLESPACE hr_tbs;</code></pre><ol>
                           <li>
                              <p>在SQL * Plus中，以具有执行表的在线重新定义所需特权的用户身份进行连接。</p>
                              <p>具体而言，用户必须具有<span class="q">“ <a href="managing-tables.html#GUID-0191D286-24D5-4E2A-817B-99FAAB96D4B3" title="Execute privileges on the DBMS_REDEFINITION package are required to run subprograms in the package. Execute privileges on the DBMS_REDEFINITION package are granted to EXECUTE_CATALOG_ROLE.">DBMS_REDEFINITION包所需</a></span>的权限”中描述的<span class="q"><a href="managing-tables.html#GUID-0191D286-24D5-4E2A-817B-99FAAB96D4B3" title="要在程序包中运行子程序，需要DBMS_REDEFINITION程序包的执行权限。DBMS_REDEFINITION包的执行权限被授予EXECUTE_CATALOG_ROLE。">权限</a></span> 。
                              </p>
                              <p>请参见<span class="q">“ <a href="getting-started-with-database-administration.html#GUID-895EC72B-C620-4D93-9F23-3F6DC1706764" title="Oracle数据库包括以下组件：Oracle数据库实例，它是进程和内存的集合，以及一组包含用户数据和系统数据的磁盘文件。">使用SQL * Plus连接到数据库</a> ”</span> 。
                              </p>
                           </li>
                           <li>
                              <p>开始重新定义过程。</p><pre class="oac_no_warn" dir="ltr">BEGIN DBMS_REDEFINITION.START_REDEF_TABLE（uname =&gt;'hr'，orig_table =&gt;'t1'，int_table =&gt;'int_t1'）;结束; /</pre></li>
                           <li>
                              <p>删除原始表上的物化视图日志。</p><pre class="pre codeblock"><code>DROP MATERIALIZED VIEW LOG ON hr.t1;</code></pre></li>
                           <li>
                              <p>在原始表上创建新的物化视图日志。</p><pre class="pre codeblock"><code>在hr.t1创建物料化视图日志与COMMIT SCN PURGE IMMEDIATE ASYNCHRONOUS;</code></pre></li>
                           <li>
                              <p>同步临时表<code class="codeph">hr.int_t1</code> 。
                              </p><pre class="pre codeblock"><code>BEGIN DBMS_REDEFINITION.SYNC_INTERIM_TABLE（uname =&gt;'hr'，orig_table =&gt;'t1'，int_table =&gt;'int_t1'）;结束; / BEGIN *第1行的错误：ORA-42010：同步重定义ORA-12034时发生错误：物化视图登录“HR”。“T1”比上次刷新小</code></pre></li>
                           <li>
                              <p>因为返回了错误，请检查<code class="codeph">DBA_REDEFINITION_STATUS</code>视图。
                              </p><pre class="pre codeblock"><code>COLUMN BASE_OBJECT_NAME格式A11列操作格式A10列状态格式A10列可重新格式A11列ERR_TXT格式A15列操作格式A18 SELECT BASE_OBJECT_NAME，操作，状态，可重新启动，ERR_TXT，操作来自DBE_REDEFINITION_STATUS订购BASE_TABLE_NAME，BASE_OBJECT_NAME; BASE_OBJECT操作状态可重新启动的ERR_TXT操作----------- ---------- ---------- -----------  - ------------- ------------------ T1 SYNC_REDEF失败N ORA-12034：配合中止重定义_TABLE rialized view log on“HR “。”T1“比刷新更年轻</code></pre><p>无法重新启动联机重定义操作，因为<code class="codeph">RESTARTABLE</code>在查询结果中为<code class="codeph">N</code> ，而<code class="codeph">ACTION</code>列指示必须中止联机表重定义操作。
                              </p>
                           </li>
                           <li>
                              <p>中止在线表重新定义操作。</p><pre class="pre codeblock"><code>BEGIN DBMS_REDEFINITION.ABORT_REDEF_TABLE（uname =&gt;'hr'，orig_table =&gt;'t1'，int_table =&gt;'int_t1'）;结束; /</code></pre></li>
                        </ol>
                     </div>
                     <!-- class="example" -->
                  </div>
                  <div>
                     <div class="familylinks">
                        <div class="parentlink">
                           <p><strong>父主题：</strong> <a href="managing-tables.html#GUID-92361F74-4796-407D-A3B9-569C6E544E34" title="您可以修改表的逻辑或物理结构。">在线重新定义表</a></p>
                        </div>
                     </div>
                  </div>
                  
               </div>
               <div class="sect3"><a id="GUID-FDCA40B7-D2EC-4900-98E4-8F1DACEDE0CF" name="GUID-FDCA40B7-D2EC-4900-98E4-8F1DACEDE0CF"></a><h4 id="ADMIN-GUID-FDCA40B7-D2EC-4900-98E4-8F1DACEDE0CF" class="sect4"><span class="enumeration_section">20.8.12</span>回滚在线表重新定义</h4>
                  <div>
                     <p>您可以在联机表重新定义后启用表的回滚，以将表恢复为其原始定义，并保留对表所做的DML更改。</p>
                  </div>
                  <div>
                     <ul class="ullinks">
                        <li class="ulchildlink"><a href="managing-tables.html#GUID-290254D6-C1C9-4A55-92DF-DF0A32EA0590">关于联机表重新定义回滚</a><br>在联机表重新定义之后，您可以在联机表重新定义之前将表回滚到其定义，同时保留对表所做的所有数据操作语言（DML）更改。
                        </li>
                        <li class="ulchildlink"><a href="managing-tables.html#GUID-816DDA7F-51DD-423E-AE80-C49F8658A093">执行在线表重新定义回滚</a><br><code class="codeph">DBMS_REDEFINITION</code>包中的<code class="codeph">ROLLBACK</code>过程返回一个在线重新定义为其原始定义的表，同时保留DML更改。
                        </li>
                     </ul>
                     <div class="familylinks">
                        <div class="parentlink">
                           <p><strong>父主题：</strong> <a href="managing-tables.html#GUID-92361F74-4796-407D-A3B9-569C6E544E34" title="您可以修改表的逻辑或物理结构。">在线重新定义表</a></p>
                        </div>
                     </div>
                  </div>
                  
                  <div class="sect4"><a id="GUID-290254D6-C1C9-4A55-92DF-DF0A32EA0590" name="GUID-290254D6-C1C9-4A55-92DF-DF0A32EA0590"></a><h5 id="ADMIN-GUID-290254D6-C1C9-4A55-92DF-DF0A32EA0590" class="sect5"><span class="enumeration_section">20.8.12.1</span>关于联机表重定义回滚</h5>
                     <div>
                        <p>在联机表重新定义之后，您可以在联机表重新定义之前将表回滚到其定义，同时保留对表所做的所有数据操作语言（DML）更改。</p>
                        <p>在某些情况下，您可能希望撤消对表的在线重新定义。例如，重新定义后的表操作性能可能比重新定义之前的性能更差。在这些情况下，您可以将表回滚到其原始定义，同时保留在重新定义表后对表所做的所有DML更改。当重新定义更改表的存储特征时，主要使用联机表重新定义回滚，并且更改意外地导致性能下降。</p>
                        <p>为了使网上表格重新定义回滚， <code class="codeph">ENABLE_ROLLBACK</code>参数必须设置为<code class="codeph">TRUE</code>中<code class="codeph">DBMS_REDEFINITION.START_TABLE_REDEF</code>程序。当此参数设置为true时，Oracle数据库会在重新定义完成后维护重新定义期间创建的临时表。您可以运行<code class="codeph">SYNC_INTERIM_TABLE</code>过程以定期同步临时表，以将对重新定义的表所做的DML更改应用于临时表。内部物化视图和物化视图日志可以维护临时表。如果您决定回滚联机表重新定义，则会同步临时表，并且Oracle数据库会切换回它，以便该表具有其原始定义。
                        </p>
                        <p>以下限制适用于联机表重定义回滚：</p>
                        <ul style="list-style-type:disc">
                           <li>
                              <p>如果原始表的列与临时表的列之间没有一对一的映射，则在重新定义期间，列映射中必须没有运算符或函数。</p>
                              <p>当原始表的列与临时表的列一对一映射时，列映射中可以有运算符和函数。</p>
                           </li>
                           <li>
                              <p>为重新定义启用回滚时，在回滚或中止联机表重新定义之前，无法再次重新定义表。</p>
                           </li>
                        </ul>
                     </div>
                     <div>
                        <div class="familylinks">
                           <div class="parentlink">
                              <p><strong>父主题：</strong> <a href="managing-tables.html#GUID-FDCA40B7-D2EC-4900-98E4-8F1DACEDE0CF" title="您可以在联机表重新定义后启用表的回滚，以将表恢复为其原始定义，并保留对表所做的DML更改。">回滚联机表重新定义</a></p>
                           </div>
                        </div>
                     </div>
                     
                  </div>
                  <div class="sect4"><a id="GUID-816DDA7F-51DD-423E-AE80-C49F8658A093" name="GUID-816DDA7F-51DD-423E-AE80-C49F8658A093"></a><h5 id="ADMIN-GUID-816DDA7F-51DD-423E-AE80-C49F8658A093" class="sect5"><span class="enumeration_section">20.8.12.2</span>执行在线表重定义回滚</h5>
                     <div>
                        <p><code class="codeph">DBMS_REDEFINITION</code>包中的<code class="codeph">ROLLBACK</code>过程返回一个在线重新定义为其原始定义的表，同时保留DML更改。
                        </p>
                        <div class="section">
                           <p>要使用<code class="codeph">ROLLBACK</code>过程，必须在联机表重新定义期间启用联机表重新定义回滚。如果您决定保留在线表重新定义所做的更改，则可以运行<code class="codeph">ABORT_ROLLBACK</code>过程。
                           </p>
                        </div>
                        <!-- class="section" -->
                        <ol>
                           <li class="stepexpand"><span>执行表的在线重新定义，从<code class="codeph">START_REDEF_TABLE</code>过程开始，到<code class="codeph">FINISH_REDEF_TABLE</code>过程结束。</span><div>在<code class="codeph">START_REDEF_TABLE</code>过程中， <code class="codeph">ENABLE_ROLLBACK</code>参数必须设置为<code class="codeph">TRUE</code> 。此参数的默认值为<code class="codeph">FALSE</code> 。</div>
                           </li>
                           <li class="stepexpand"><strong>可选：</strong> <span>定期运行<code class="codeph">SYNC_INTERIM_TABLE</code>过程，将对重新定义的表所做的DML更改应用于临时表。</span><div>如果定期将DML更改应用于临时表，则可以提高联机表重定义回滚的性能。</div>
                           </li>
                           <li class="stepexpand"><span>选择以下选项之一：</span><ul>
                                 <li>如果要撤消在线表重新定义所做的更改并返回到原始表定义，请在<code class="codeph">DBMS_REDEFINITION</code>包中运行<code class="codeph">ROLLBACK</code>过程。
                                 </li>
                                 <li>如果您想保留通过在线表重定义所做的更改，然后运行<code class="codeph">ABORT_ROLLBACK</code>在程序<code class="codeph">DBMS_REDEFINITION</code>包。
                                    <p>中止回滚会停止维护临时表，并删除启用回滚的物化视图和物化视图日志。</p>
                                 </li>
                              </ul>
                           </li>
                        </ol>
                        <div class="example" id="GUID-816DDA7F-51DD-423E-AE80-C49F8658A093__GUID-9C78761F-12D2-4144-8B78-8C9C24C8F7D0">
                           <p class="titleinexample">例20-20回滚在线表重新定义</p>
                           <p>此示例说明了通过更改表的存储特征来在线重新定义表。具体来说，此示例在联机重新定义期间压缩表的表空间。假设您希望在完成在线重新定义后评估表的性能。如果表的执行效果不如预期，那么您希望能够回滚在线重新定义所做的更改。</p>
                           <p>假设以下语句创建了原始表空间和表：</p><pre class="pre codeblock"><code>CREATE TABLESPACE tst_rollback_tbs DATAFILE'tst_rollback_tbs.dbf'SIZE 10M ONLINE; CREATE TABLE hr.tst_rollback（rllbck_id NUMBER（6）PRIMARY KEY，rllbck_name VARCHAR2（20））TABLESPACE tst_rollback_tbs STORAGE（INITIAL 2M）;</code></pre><ol>
                              <li>
                                 <p>在SQL * Plus中，以具有执行表的在线重新定义所需特权的用户身份进行连接。</p>
                                 <p>具体而言，用户必须具有<span class="q">“ <a href="managing-tables.html#GUID-0191D286-24D5-4E2A-817B-99FAAB96D4B3" title="Execute privileges on the DBMS_REDEFINITION package are required to run subprograms in the package. Execute privileges on the DBMS_REDEFINITION package are granted to EXECUTE_CATALOG_ROLE.">DBMS_REDEFINITION包所需</a></span>的权限”中描述的<span class="q"><a href="managing-tables.html#GUID-0191D286-24D5-4E2A-817B-99FAAB96D4B3" title="要在程序包中运行子程序，需要DBMS_REDEFINITION程序包的执行权限。DBMS_REDEFINITION包的执行权限被授予EXECUTE_CATALOG_ROLE。">权限</a></span> 。
                                 </p>
                                 <p>请参见<span class="q">“ <a href="getting-started-with-database-administration.html#GUID-895EC72B-C620-4D93-9F23-3F6DC1706764" title="Oracle数据库包括以下组件：Oracle数据库实例，它是进程和内存的集合，以及一组包含用户数据和系统数据的磁盘文件。">使用SQL * Plus连接到数据库</a> ”</span> 。
                                 </p>
                              </li>
                              <li>
                                 <p>为临时表创建压缩表空间。</p><pre class="oac_no_warn" dir="ltr">CREATE TABLESPACE tst_cmp_rollback_tbs DEFAULT ROW STORE COMPRESS ADVANCED DATAFILE'tst_cmp_rollback_tbs.dbf'SIZE 10M ONLINE;</pre></li>
                              <li>
                                 <p>创建临时表<code class="codeph">hr.int_tst_rollback</code> 。
                                 </p><pre class="oac_no_warn" dir="ltr">CREATE TABLE hr.int_tst_rollback（rllbck_id NUMBER（6）PRIMARY KEY，rllbck_name VARCHAR2（20））TABLESPACE tst_cmp_rollback_tbs STORAGE（INITIAL 2M）;</pre><p>确保临时表使用上一步中创建的压缩表空间。</p>
                              </li>
                              <li>
                                 <p>开始重新定义过程。</p><pre class="oac_no_warn" dir="ltr">BEGIN DBMS_REDEFINITION.START_REDEF_TABLE（uname =&gt;'hr'，orig_table =&gt;'tst_rollback'，int_table =&gt;'int_tst_rollback'，options_flag =&gt; DBMS_REDEFINITION.CONS_USE_PK，enable_rollback =&gt; TRUE）;结束; /</pre><p>确保将<code class="codeph">enable_rollback</code>设置为<code class="codeph">TRUE</code>以便可以回滚在线重新定义所做的更改。
                                 </p>
                              </li>
                              <li>
                                 <p>复制相关对象。</p><pre class="oac_no_warn" dir="ltr">DECLARE num_errors PLS_INTEGER; BEGIN DBMS_REDEFINITION.COPY_TABLE_DEPENDENTS（uname =&gt;'hr'，orig_table =&gt;'tst_rollback'，int_table =&gt;'int_tst_rollback'，copy_indexes =&gt; DBMS_REDEFINITION.CONS_ORIG_PARAMS，copy_triggers =&gt; TRUE，copy_constraints =&gt; TRUE，copy_privileges =&gt; TRUE，ignore_errors = &gt; TRUE，num_errors =&gt; num_errors）;结束; /</pre></li>
                              <li>
                                 <p>查询<code class="codeph">DBA_REDEFINITION_ERRORS</code>视图以检查错误。
                                 </p><pre class="oac_no_warn" dir="ltr">SET LONG 8000 SET PAGES 8000 COLUMN OBJECT_NAME标题'对象名'格式A20列BASE_TABLE_NAME标题'基表名'格式A10列DDL_TXT标题'导致错误的DDL'格式A40 SELECT OBJECT_NAME，BASE_TABLE_NAME，DDL_TXT来自DBA_REDEFINITION_ERRORS;</pre><p>您可以忽略与主键和索引相关的错误。</p>
                              </li>
                              <li>
                                 <p>同步临时表<code class="codeph">hr.int_tst_rollback</code> 。
                                 </p><pre class="oac_no_warn" dir="ltr">BEGIN DBMS_REDEFINITION.SYNC_INTERIM_TABLE（uname =&gt;'hr'，orig_table =&gt;'tst_rollback'，int_table =&gt;'int_tst_rollback'）;结束; /</pre></li>
                              <li>
                                 <p>完成重新定义。</p><pre class="oac_no_warn" dir="ltr">BEGIN DBMS_REDEFINITION.FINISH_REDEF_TABLE（uname =&gt;'hr'，orig_table =&gt;'tst_rollback'，int_table =&gt;'int_tst_rollback'）;结束; /</pre><p>表<code class="codeph">hr.tst_rollbck</code>仅在此步骤结束时的小窗口中以独占模式锁定。在此调用之后，重新定义表<code class="codeph">hr.tst_rollback</code> ，使其具有<code class="codeph">hr.int_tst_rollback</code>表的所有属性。在此示例中，现在压缩<code class="codeph">hr.tst_rollbck</code>表的表空间。
                                 </p>
                              </li>
                              <li>
                                 <p>在评估期间，您可以定期同步临时表<code class="codeph">hr.int_tst_rollback</code> 。
                                 </p><pre class="oac_no_warn" dir="ltr">BEGIN DBMS_REDEFINITION.SYNC_INTERIM_TABLE（uname =&gt;'hr'，orig_table =&gt;'tst_rollback'，int_table =&gt;'int_tst_rollback'）;结束; /</pre><p>同步表会将原始表更新为对重新定义的表所做的DML更改。定期同步表时，回滚操作更有效，因为必须对原始表进行更少的DML更改。您可以查询<code class="codeph">DBA_REDEFINITION_STATUS</code>视图的<code class="codeph">STATUS</code>列以确定回滚操作的状态。
                                 </p>
                              </li>
                              <li>
                                 <p>请执行以下操作之一：</p>
                                 <ul style="list-style-type:disc">
                                    <li>
                                       <div class="p">假设重新定义的表的执行效果不如预期，并回滚在线重新定义所做的更改。<pre class="oac_no_warn" dir="ltr">BEGIN DBMS_REDEFINITION.ROLLBACK（uname =&gt;'hr'，orig_table =&gt;'tst_rollback'，int_table =&gt;'int_tst_rollback'）;结束; /</pre></div>
                                    </li>
                                    <li>
                                       <div class="p">假设重新定义的表按预期执行，并中止回滚以保留在线表重新定义所做的更改并清理启用回滚的数据库对象。<pre class="oac_no_warn" dir="ltr">BEGIN DBMS_REDEFINITION.ABORT_ROLLBACK（uname =&gt;'hr'，orig_table =&gt;'tst_rollback'，int_table =&gt;'int_tst_rollback'）;结束; /</pre></div>
                                    </li>
                                 </ul>
                              </li>
                           </ol>
                        </div>
                        <!-- class="example" -->
                     </div>
                     <div>
                        <div class="familylinks">
                           <div class="parentlink">
                              <p><strong>父主题：</strong> <a href="managing-tables.html#GUID-FDCA40B7-D2EC-4900-98E4-8F1DACEDE0CF" title="您可以在联机表重新定义后启用表的回滚，以将表恢复为其原始定义，并保留对表所做的DML更改。">回滚联机表重新定义</a></p>
                           </div>
                        </div>
                     </div>
                     
                  </div>
               </div><a id="ADMIN11674"></a><div class="props_rev_3"><a id="GUID-0C266A74-406A-485B-B545-5618EE3D02F8" name="GUID-0C266A74-406A-485B-B545-5618EE3D02F8"></a><h4 id="ADMIN-GUID-0C266A74-406A-485B-B545-5618EE3D02F8" class="sect4"><span class="enumeration_section">20.8.13</span>在错误发生后中止在线表重新定义和清理</h4>
                  <div>
                     <p>您可以中止在线重新定义过程。这样做会丢弃与重新定义过程相关联的临时日志和表。调用此过程后，可以删除临时表及其依赖对象。</p>
                     <div class="section">
                        <p>如果在重新定义过程中出现错误，或者您选择手动终止重新定义过程，则中止在线重新定义过程：</p>
                        <ul style="list-style-type:disc">
                           <li>
                              <p>运行<code class="codeph">ABORT_REDEF_TABLE</code>过程。
                              </p>
                           </li>
                        </ul>
                        <p>如果必须重新启动在线重新定义过程，如果您没有首先调用<code class="codeph">ABORT_REDEF_TABLE</code> ，则后续重新定义表的尝试将失败。
                        </p>
                        <div class="infoboxnote" id="GUID-0C266A74-406A-485B-B545-5618EE3D02F8__GUID-2C824890-B297-4635-98C7-EB389E7688D3">
                           <p class="notep1">注意：</p>
                           <p>如果重新定义过程因<code class="codeph">FINISH_REDEF_TABLE</code>过程超时而停止，则无需调用<code class="codeph">ABORT_REDEF_TABLE</code>过程。<code class="codeph">FINISH_REDEF_TABLE</code>过程中的<code class="codeph">dml_lock_timeout</code>参数控制超时时间。有关详细信息，请参阅<span class="q">“使用<a href="managing-tables.html#GUID-3C702CE8-9676-4825-B92A-D4AFE78FE402" title="您可以在DBMS_REDEFINITION包中使用多个过程来执行表的在线重新定义。">DBMS_REDEFINITION中的多个过程执行在线重新定义</a> ”中的</span>步骤<a href="managing-tables.html#GUID-3C702CE8-9676-4825-B92A-D4AFE78FE402__BABGDBJH">8</a></p>
                        </div>
                     </div>
                     <!-- class="section" -->
                  </div>
                  <div>
                     <div class="familylinks">
                        <div class="parentlink">
                           <p><strong>父主题：</strong> <a href="managing-tables.html#GUID-92361F74-4796-407D-A3B9-569C6E544E34" title="您可以修改表的逻辑或物理结构。">在线重新定义表</a></p>
                        </div>
                     </div>
                  </div>
                  
               </div><a id="ADMIN11675"></a><div class="props_rev_3"><a id="GUID-9A31C4B1-1DA5-4DF8-8567-8642821056D6" name="GUID-9A31C4B1-1DA5-4DF8-8567-8642821056D6"></a><h4 id="ADMIN-GUID-9A31C4B1-1DA5-4DF8-8567-8642821056D6" class="sect4"><span class="enumeration_section">20.8.14</span>在线重新定义一个或多个分区</h4>
                  <div>
                     <p>您可以在线重新定义表的一个或多个分区。例如，如果您希望将分区移动到不同的表空间并在操作期间保持分区可用于DML，则此功能非常有用。</p>
                     <p>您可以一次重新定义表中的多个分区。如果这样做，则在表重新定义过程中需要多个临时表。确保您有足够的可用空间和撤消空间来完成表重新定义。</p>
                     <p>重新定义多个分区时，即使遇到特定分区的错误，也可以指定重定义继续。为此，请在<code class="codeph">DBMS_REDEFINITION</code>包中的重新定义过程中将<code class="codeph">continue_after_errors</code>参数设置为<code class="codeph">TRUE</code> 。您可以检查<code class="codeph">DBA_REDEFINITION_STATUS</code>视图以查看重新定义过程中是否遇到任何错误。此视图中的<code class="codeph">STATUS</code>列显示每个分区的重新定义过程是成功还是失败。
                     </p>
                     <p>您还可以一次重新定义整个表一个分区，以减少资源需求。例如，要将非常大的表移动到不同的表空间，您可以一次将其移动一个分区，以最小化完成移动所需的可用空间和撤消空间。</p>
                     <p>重新定义分区与通过以下方式重新定义表不同：</p>
                     <ul style="list-style-type:disc">
                        <li>
                           <p>无需复制依赖对象。重新定义单个分区时，使用<code class="codeph">COPY_TABLE_DEPENDENTS</code>过程无效。
                           </p>
                        </li>
                        <li>
                           <p>您必须在临时表上手动创建和注册任何本地索引。</p>
                           <p>请参阅<span class="q">“ <a href="managing-tables.html#GUID-B3AA1388-F093-4861-BB7C-896EDF072602" title="如果使用SQL * Plus或Cloud Control在临时表上手动创建依赖对象，则必须使用REGISTER_DEPENDENT_OBJECT过程来注册从属对象。注册依赖对象使重新定义完成过程能够将依赖对象名称恢复为重新定义之前的对象名称。">手动创建从属对象</a> ”</span> 。
                           </p>
                        </li>
                        <li>
                           <p><code class="codeph">START_REDEF_TABLE</code>的列映射字符串必须为<code class="codeph">NULL</code> 。</p>
                        </li>
                     </ul>
                     <div class="infoboxnote" id="GUID-9A31C4B1-1DA5-4DF8-8567-8642821056D6__GUID-F2E5AFC5-9B67-40E6-BB28-CC6FA94BBF70">
                        <p class="notep1">注意：</p>
                        <p>从Oracle Database 12 <span class="italic">c开始</span> ，您可以使用更简单的<code class="codeph">ALTER</code> <code class="codeph">TABLE</code> <code class="codeph">...</code><code class="codeph">MOVE</code> <code class="codeph">PARTITION</code> <code class="codeph">...</code> <code class="codeph">ONLINE</code>语句，用于在不使用联机表重定义的情况下在线移动分区或子分区。DML操作可以继续在正在移动的分区或子分区上不间断地运行。请参阅<span class="q">“ <a href="managing-tables.html#GUID-3DE67CF4-84C5-4AED-A8A3-B1D28D8EBEF6" title="ALTER TABLE ...假设您在目标表空间中具有适当的配额，MOVE [PARTITION | SUBPARTITION]语句使您可以移动表，分区或子分区以更改任何物理存储属性（如压缩或表空间）。">将表移动到新段或表空间</a> ”</span> 。
                        </p>
                     </div>
                  </div>
                  <div>
                     <ul class="ullinks">
                        <li class="ulchildlink"><a href="managing-tables.html#GUID-F183AA70-A1CF-44F9-A139-DE67EEA5025E">单个分区的在线重新定义规则</a><br>重新定义单个分区的基础机制是数据库的<span class="bold">交换分区</span>功能（ <code class="codeph">ALTER</code> <code class="codeph">TABLE</code> ...<code class="codeph">EXCHANGE</code> <code class="codeph">PARTITION</code> ）。
                        </li>
                     </ul>
                     <div class="infoboxnotealso" id="GUID-9A31C4B1-1DA5-4DF8-8567-8642821056D6__GUID-3172CB12-63FC-48E0-8702-D912A620B686">
                        <p class="notep1">也可以看看：</p>
                        <p><a href="https://www.oracle.com/pls/topic/lookup?ctx=en/database/oracle/oracle-database/19/admin&amp;id=VLDBG1193" target="_blank"><span class="italic">Oracle数据库VLDB和分区指南</span></a></p>
                     </div>
                     <div class="familylinks">
                        <div class="parentlink">
                           <p><strong>父主题：</strong> <a href="managing-tables.html#GUID-92361F74-4796-407D-A3B9-569C6E544E34" title="您可以修改表的逻辑或物理结构。">在线重新定义表</a></p>
                        </div>
                     </div>
                  </div>
                  <a id="ADMIN11676"></a><div class="props_rev_3"><a id="GUID-F183AA70-A1CF-44F9-A139-DE67EEA5025E" name="GUID-F183AA70-A1CF-44F9-A139-DE67EEA5025E"></a><h5 id="ADMIN-GUID-F183AA70-A1CF-44F9-A139-DE67EEA5025E" class="sect5"><span class="enumeration_section">20.8.14.1</span>单一分区在线重新定义规则</h5>
                     <div>
                        <p>重新定义单个分区的基础机制是数据库的<span class="bold">交换分区</span>功能（ <code class="codeph">ALTER</code> <code class="codeph">TABLE</code> ...<code class="codeph">EXCHANGE</code> <code class="codeph">PARTITION</code> ）。
                        </p>
                        <p>因此，在线重新定义单个分区的规则和限制受此机制的约束。以下是一些一般限制：</p>
                        <ul style="list-style-type:disc">
                           <li>
                              <p>不允许进行逻辑更改（例如添加或删除列）。</p>
                           </li>
                           <li>
                              <p>不允许更改分区方法（例如从范围分区更改为散列分区）。</p>
                           </li>
                        </ul>
                        <p>以下是定义临时表的规则：</p>
                        <ul style="list-style-type:disc">
                           <li>
                              <p>如果重新定义的分区是范围，散列或列表分区，则临时表必须是非分区的。</p>
                           </li>
                           <li>
                              <p>如果重新定义的分区是复合范围 - 散列分区表的范围分区，则临时表必须是散列分区表。此外，临时表的分区键必须与范围哈希分区表的子分区键相同，并且临时表中的分区数必须与重新定义的范围分区中的子分区数相同。</p>
                           </li>
                           <li>
                              <p>如果重新定义的分区是复合范围列表分区表的范围分区，则临时表必须是列表分区表。此外，临时表的分区键必须与范围列表分区表的子分区键相同，并且临时表的列表分区的值列表必须与范围分区中列表子分区的值列表完全匹配。重新定义。</p>
                           </li>
                           <li>
                              <p>如果将临时表定义为压缩，则必须使用重定义的按键方法，而不是by-rowid方法。</p>
                           </li>
                        </ul>
                        <p>如果重新定义的表是分区索引组织表，则适用这些附加规则：</p>
                        <ul style="list-style-type:disc">
                           <li>
                              <p>临时表也必须是索引组织的。</p>
                           </li>
                           <li>
                              <p>原始表和临时表必须在相同列上具有相同顺序的主键。</p>
                           </li>
                           <li>
                              <p>如果启用了前缀压缩，则必须为原始表和临时表启用它，并使用相同的前缀长度。</p>
                           </li>
                           <li>
                              <p>原始表和临时表都必须具有溢出段，或者两者都不能具有溢出段。同样对于映射表。</p>
                           </li>
                        </ul>
                     </div>
                     <div>
                        <div class="infoboxnotealso" id="GUID-F183AA70-A1CF-44F9-A139-DE67EEA5025E__GUID-2C2CEA86-85FE-4CD0-BF2B-B12E6DAA53FC">
                           <p class="notep1">也可以看看：</p>
                           <p></p>
                           <ul style="list-style-type:disc">
                              <li>
                                 <p>“ <a href="https://www.oracle.com/pls/topic/lookup?ctx=en/database/oracle/oracle-database/19/admin&amp;id=VLDBG1156" target="_blank"><span class="italic">Oracle数据库VLDB和分区指南</span></a> ”中的“交换分区”一节</p>
                              </li>
                              <li>
                                 <p><span class="q">“ <a href="managing-tables.html#GUID-4E77A941-A660-4DB3-A7B8-D15FBD9BF509" title="示例说明了表的在线重新定义。">在线表重新定义示例</a> ”，</span>用于重新定义具有分区的表的示例</p>
                              </li>
                           </ul>
                        </div>
                        <div class="familylinks">
                           <div class="parentlink">
                              <p><strong>父主题：</strong> <a href="managing-tables.html#GUID-9A31C4B1-1DA5-4DF8-8567-8642821056D6" title="您可以在线重新定义表的一个或多个分区。例如，如果您希望将分区移动到不同的表空间并在操作期间保持分区可用于DML，则此功能非常有用。">一个或多个分区的在线重新定义</a></p>
                           </div>
                        </div>
                     </div>
                     
                  </div>
               </div><a id="ADMIN14160"></a><a id="ADMIN12636"></a><a id="ADMIN12637"></a><a id="ADMIN12638"></a><a id="ADMIN13869"></a><a id="ADMIN13879"></a><a id="ADMIN13880"></a><a id="ADMIN14161"></a><a id="ADMIN11677"></a><div class="props_rev_3"><a id="GUID-4E77A941-A660-4DB3-A7B8-D15FBD9BF509" name="GUID-4E77A941-A660-4DB3-A7B8-D15FBD9BF509"></a><h4 id="ADMIN-GUID-4E77A941-A660-4DB3-A7B8-D15FBD9BF509" class="sect4"><span class="enumeration_section">20.8.15</span>在线表重定义示例</h4>
                  <div>
                     <p>示例说明了表的在线重新定义。</p>
                     <div class="section">
                        <p>有关以下示例，请参阅<a href="https://www.oracle.com/pls/topic/lookup?ctx=en/database/oracle/oracle-database/19/admin&amp;id=ARPLS042" target="_blank"><span class="italic">Oracle Database PL / SQL包和类型参考</span></a>以获取所有<code class="codeph">DBMS_REDEFINITION</code>子程序的描述。
                        </p>
                        <div class="tblformalwide" id="GUID-4E77A941-A660-4DB3-A7B8-D15FBD9BF509__GUID-984E987C-615A-4CF9-8FBB-CEC7EEA7910A">
                           <table cellpadding="4" cellspacing="0" class="FormalWide" title="" width="100%" border="1" summary="This table summarizes the purpose of each of the four online redefinition example and provides hyperlinks to each." frame="hsides" rules="rows">
                              <thead>
                                 <tr align="left" valign="top">
                                    <th align="left" valign="bottom" id="d192334e15437">例</th>
                                    <th align="left" valign="bottom" id="d192334e15440">描述</th>
                                 </tr>
                              </thead>
                              <tbody>
                                 <tr align="left" valign="top">
                                    <td align="left" valign="top" id="d192334e15445" headers="d192334e15437 ">
                                       <p><a href="managing-tables.html#GUID-4E77A941-A660-4DB3-A7B8-D15FBD9BF509__BABEAFDD">例1</a></p>
                                    </td>
                                    <td align="left" valign="top" headers="d192334e15445 d192334e15440 ">
                                       <p>使用<code class="codeph">REDEF_TABLE</code>过程在一个步骤中重新定义表的存储属性。
                                       </p>
                                    </td>
                                 </tr>
                                 <tr align="left" valign="top">
                                    <td align="left" valign="top" id="d192334e15456" headers="d192334e15437 ">
                                       <p><a href="managing-tables.html#GUID-4E77A941-A660-4DB3-A7B8-D15FBD9BF509__CJAEBFJA">例2</a></p>
                                    </td>
                                    <td align="left" valign="top" headers="d192334e15456 d192334e15440 ">
                                       <p>通过添加新列并添加分区来重新定义表。</p>
                                    </td>
                                 </tr>
                                 <tr align="left" valign="top">
                                    <td align="left" valign="top" id="d192334e15464" headers="d192334e15437 ">
                                       <p><a href="managing-tables.html#GUID-4E77A941-A660-4DB3-A7B8-D15FBD9BF509__CJAEIAED">例3</a></p>
                                    </td>
                                    <td align="left" valign="top" headers="d192334e15464 d192334e15440 ">
                                       <p>演示使用对象数据类型重新定义。</p>
                                    </td>
                                 </tr>
                                 <tr align="left" valign="top">
                                    <td align="left" valign="top" id="d192334e15472" headers="d192334e15437 ">
                                       <p><a href="managing-tables.html#GUID-4E77A941-A660-4DB3-A7B8-D15FBD9BF509__CJAGDACH">例4</a></p>
                                    </td>
                                    <td align="left" valign="top" headers="d192334e15472 d192334e15440 ">
                                       <p>使用手动注册的依赖对象演示重新定义。</p>
                                    </td>
                                 </tr>
                                 <tr align="left" valign="top">
                                    <td align="left" valign="top" id="d192334e15480" headers="d192334e15437 ">
                                       <p><a href="managing-tables.html#GUID-4E77A941-A660-4DB3-A7B8-D15FBD9BF509__BABDGIBA">例5</a></p>
                                    </td>
                                    <td align="left" valign="top" headers="d192334e15480 d192334e15440 ">
                                       <p>重新定义多个分区，将它们移动到不同的表空间。</p>
                                    </td>
                                 </tr>
                                 <tr align="left" valign="top">
                                    <td align="left" valign="top" id="d192334e15488" headers="d192334e15437 ">
                                       <p><a href="managing-tables.html#GUID-4E77A941-A660-4DB3-A7B8-D15FBD9BF509__BABBIGBI">例6</a></p>
                                    </td>
                                    <td align="left" valign="top" headers="d192334e15488 d192334e15440 ">
                                       <p>使用虚拟专用数据库（VPD）策略重新定义表，而不更改任何表的列的属性。</p>
                                    </td>
                                 </tr>
                                 <tr align="left" valign="top">
                                    <td align="left" valign="top" id="d192334e15496" headers="d192334e15437 ">
                                       <p><a href="managing-tables.html#GUID-4E77A941-A660-4DB3-A7B8-D15FBD9BF509__BABFFJAA">例7</a></p>
                                    </td>
                                    <td align="left" valign="top" headers="d192334e15496 d192334e15440 ">
                                       <p>使用VPD策略重新定义表，并更改其中一个表列的属性。</p>
                                    </td>
                                 </tr>
                                 <tr align="left" valign="top">
                                    <td align="left" valign="top" id="d192334e15504" headers="d192334e15437 ">
                                       <p><a href="managing-tables.html#GUID-4E77A941-A660-4DB3-A7B8-D15FBD9BF509__BABFAHGD">例8</a></p>
                                    </td>
                                    <td align="left" valign="top" headers="d192334e15504 d192334e15440 ">
                                       <p>通过使用在线重新定义进行多项更改来重新定义表。</p>
                                    </td>
                                 </tr>
                              </tbody>
                           </table>
                        </div>
                        <!-- class="inftblhruleinformal" -->
                     </div>
                     <!-- class="section" -->
                     <div class="section" id="GUID-4E77A941-A660-4DB3-A7B8-D15FBD9BF509__BABEAFDD">
                        <p class="subhead3" id="GUID-4E77A941-A660-4DB3-A7B8-D15FBD9BF509__GUID-05CCF5FD-D06F-4C0C-95EC-F4E30F32B95A">例1</p>
                     </div>
                     <!-- class="section" -->
                     <div class="section">
                        <p>此示例说明使用<code class="codeph">REDEF_TABLE</code>过程在线重新定义表的存储属性。
                        </p>
                        <p>原始表名为<code class="codeph">print_ads</code> ，在<code class="codeph">pm</code>模式中定义如下：</p><pre class="oac_no_warn" dir="ltr">名字空？输入----------------------------------------- -------- ---------------------------- AD_ID NUMBER（6）AD_TEXT CLOB</pre><p>在此表中，LOB列<code class="codeph">ad_text</code>使用BasicFiles LOB存储。
                        </p>
                        <p>使用以下SQL语句创建表的索引：</p><pre class="oac_no_warn" dir="ltr">CREATE INDEX pm.print_ads_ix ON print_ads（ad_id）TABLESPACE示例;</pre><p>该表重新定义如下：</p>
                        <ul style="list-style-type:disc">
                           <li>
                              <p>该表使用高级行压缩进行压缩。</p>
                           </li>
                           <li>
                              <p>表的表空间从<code class="codeph">EXAMPLE</code>更改为<code class="codeph">NEWTBS</code> 。此示例假定<code class="codeph">NEWTBS</code>表空间存在。
                              </p>
                           </li>
                           <li>
                              <p>索引使用<code class="codeph">COMPRESS 1</code>压缩进行压缩。
                              </p>
                           </li>
                           <li>
                              <p>索引的表空间从<code class="codeph">EXAMPLE</code>更改为<code class="codeph">NEWIDXTBS</code> 。此示例假定存在<code class="codeph">NEWIDXTBS</code>表空间。
                              </p>
                           </li>
                           <li>
                              <p>表中的LOB列使用<code class="codeph">COMPRESS</code> <code class="codeph">HIGH</code>压缩进行压缩。
                              </p>
                           </li>
                           <li>
                              <p>LOB列的表空间从<code class="codeph">EXAMPLE</code>更改为<code class="codeph">NEWLOBTBS</code> 。此示例假定<code class="codeph">NEWLOBTBS</code>表空间存在。
                              </p>
                           </li>
                           <li>
                              <p>LOB列已更改为SecureFiles LOB存储。</p>
                           </li>
                        </ul>
                        <p>重新定义的步骤如下所示。</p>
                        <ol>
                           <li>
                              <p>在SQL * Plus中，以具有执行表的在线重新定义所需特权的用户身份进行连接。</p>
                              <p>具体而言，用户必须具有<span class="q">“ <a href="managing-tables.html#GUID-0191D286-24D5-4E2A-817B-99FAAB96D4B3" title="Execute privileges on the DBMS_REDEFINITION package are required to run subprograms in the package. Execute privileges on the DBMS_REDEFINITION package are granted to EXECUTE_CATALOG_ROLE.">DBMS_REDEFINITION包所需</a></span>的权限”中描述的<span class="q"><a href="managing-tables.html#GUID-0191D286-24D5-4E2A-817B-99FAAB96D4B3" title="要在程序包中运行子程序，需要DBMS_REDEFINITION程序包的执行权限。DBMS_REDEFINITION包的执行权限被授予EXECUTE_CATALOG_ROLE。">权限</a></span> 。
                              </p>
                              <p>请参见<span class="q">“ <a href="getting-started-with-database-administration.html#GUID-895EC72B-C620-4D93-9F23-3F6DC1706764" title="Oracle数据库包括以下组件：Oracle数据库实例，它是进程和内存的集合，以及一组包含用户数据和系统数据的磁盘文件。">使用SQL * Plus连接到数据库</a> ”</span> 。
                              </p>
                           </li>
                           <li>
                              <p>运行<code class="codeph">REDEF_TABLE</code>过程：</p><pre class="oac_no_warn" dir="ltr">BEGIN DBMS_REDEFINITION.REDEF_TABLE（uname =&gt;'PM'，tname =&gt;'PRINT_ADS'，table_compression_type =&gt;'ROW STORE COMPRESS ADVANCED'，table_part_tablespace =&gt;'NEWTBS'，index_key_compression_type =&gt;'COMPRESS 1'，index_tablespace =&gt;'NEWIDXTBS' ，lob_compression_type =&gt;'COMPRESS HIGH'，lob_tablespace =&gt;'NEWLOBTBS'，lob_store_as =&gt;'SECUREFILE'）;结束; /</pre></li>
                        </ol>
                        <div class="infoboxnote" id="GUID-4E77A941-A660-4DB3-A7B8-D15FBD9BF509__GUID-5950A82E-DDB2-40B1-9297-6055DA73C274">
                           <p class="notep1">注意：</p>
                           <p>如果发生错误，则删除临时表，并且必须重新执行<code class="codeph">REDEF_TABLE</code>过程。
                           </p>
                        </div>
                     </div>
                     <!-- class="section" -->
                     <div class="section" id="GUID-4E77A941-A660-4DB3-A7B8-D15FBD9BF509__CJAEBFJA">
                        <p class="subhead3" id="GUID-4E77A941-A660-4DB3-A7B8-D15FBD9BF509__GUID-F827DB94-52ED-4E15-B75B-17E4D198BEAB">例2</p>
                     </div>
                     <!-- class="section" -->
                     <div class="section">
                        <p>此示例说明了通过添加新列和添加分区来在线重新定义表。</p>
                        <p>名为<code class="codeph">emp_redef</code>的原始表在<code class="codeph">hr</code>模式中定义，如下所示：</p><pre class="oac_no_warn" dir="ltr">名称类型--------- ---------------------------- EMPNO NUMBER（5）&lt; - 主键ENAME VARCHAR2 （15）JOB VARCHAR2（10）DEPTNO号码（3）</pre><p>该表重新定义如下：</p>
                        <ul style="list-style-type:disc">
                           <li>
                              <p>添加新列<code class="codeph">mgr</code> ， <code class="codeph">hiredate</code> ， <code class="codeph">sal</code>和<code class="codeph">bonus</code> 。
                              </p>
                           </li>
                           <li>
                              <p>新列<code class="codeph">bonus</code>初始化为0（零）。
                              </p>
                           </li>
                           <li>
                              <p>列<code class="codeph">deptno</code>的值增加了10。
                              </p>
                           </li>
                           <li>
                              <p>重新定义的表由<code class="codeph">empno</code>上的范围分区。
                              </p>
                           </li>
                        </ul>
                        <p>重新定义的步骤如下所示。</p>
                        <ol>
                           <li>
                              <p>在SQL * Plus中，以具有执行表的在线重新定义所需特权的用户身份进行连接。</p>
                              <p>具体而言，用户必须具有<span class="q">“ <a href="managing-tables.html#GUID-0191D286-24D5-4E2A-817B-99FAAB96D4B3" title="Execute privileges on the DBMS_REDEFINITION package are required to run subprograms in the package. Execute privileges on the DBMS_REDEFINITION package are granted to EXECUTE_CATALOG_ROLE.">DBMS_REDEFINITION包所需</a></span>的权限”中描述的<span class="q"><a href="managing-tables.html#GUID-0191D286-24D5-4E2A-817B-99FAAB96D4B3" title="要在程序包中运行子程序，需要DBMS_REDEFINITION程序包的执行权限。DBMS_REDEFINITION包的执行权限被授予EXECUTE_CATALOG_ROLE。">权限</a></span> 。
                              </p>
                              <p>请参见<span class="q">“ <a href="getting-started-with-database-administration.html#GUID-895EC72B-C620-4D93-9F23-3F6DC1706764" title="Oracle数据库包括以下组件：Oracle数据库实例，它是进程和内存的集合，以及一组包含用户数据和系统数据的磁盘文件。">使用SQL * Plus连接到数据库</a> ”</span> 。
                              </p>
                           </li>
                           <li>
                              <p>验证该表是否为在线重新定义的候选者。在这种情况下，您指定使用主键或伪主键完成重定义。</p><pre class="oac_no_warn" dir="ltr">BEGIN DBMS_REDEFINITION.CAN_REDEF_TABLE（uname =&gt;'hr'，tname =&gt;'emp_redef'，options_flag =&gt; DBMS_REDEFINITION.CONS_USE_PK）;结束; /</pre></li>
                           <li>
                              <p>创建临时表<code class="codeph">hr.int_emp_redef</code> 。
                              </p><pre class="oac_no_warn" dir="ltr">CREATE TABLE hr.int_emp_redef（empno NUMBER（5）PRIMARY KEY，ename VARCHAR2（15）NOT NULL，job VARCHAR2（10），mgr NUMBER（5），hiredate DATE DEFAULT（sysdate），sal NUMBER（7,2），deptno NUMBER（3）NOT NULL，奖金NUMBER（7,2）DEFAULT（0））按比例分区（empno）（PARTITION emp1000值不超过（1000）TABLESPACE admin_tbs，PARTITION emp2000 VALUES比（2000）TABLESPACE admin_tbs2）;</pre><p>确保指定的表空间存在。</p>
                           </li>
                           <li>
                              <p>开始重新定义过程。</p><pre class="oac_no_warn" dir="ltr">BEGIN DBMS_REDEFINITION.START_REDEF_TABLE（uname =&gt;'hr'，orig_table =&gt;'emp_redef'，int_table =&gt;'int_emp_redef'，col_mapping =&gt;'empno empno，ename ename，job job，deptno + 10 deptno，0 bonus'，options_flag = &gt; DBMS_REDEFINITION.CONS_USE_PK）;结束; /</pre></li>
                           <li>
                              <p>复制相关对象。（自动在<code class="codeph">hr.int_emp_redef</code>上创建任何触发器，索引，物化视图日志，授权和约束。）
                              </p><pre class="oac_no_warn" dir="ltr">DECLARE num_errors PLS_INTEGER; BEGIN DBMS_REDEFINITION.COPY_TABLE_DEPENDENTS（uname =&gt;'hr'，orig_table =&gt;'emp_redef'，int_table =&gt;'int_emp_redef'，copy_indexes =&gt; DBMS_REDEFINITION.CONS_ORIG_PARAMS，copy_triggers =&gt; TRUE，copy_constraints =&gt; TRUE，copy_privileges =&gt; TRUE，ignore_errors = &gt; TRUE，num_errors =&gt; num_errors）;结束; /</pre><p>请注意，此调用的<code class="codeph">ignore_errors</code>参数设置为<code class="codeph">TRUE</code> 。原因是临时表是使用主键约束创建的，当<code class="codeph">COPY_TABLE_DEPENDENTS</code>尝试从原始表复制主键约束和索引时，会发生错误。您可以忽略这些错误，但必须运行下一步中显示的查询以查看是否存在其他错误。
                              </p>
                           </li>
                           <li>
                              <p>查询<code class="codeph">DBA_REDEFINITION_ERRORS</code>视图以检查错误。
                              </p><pre class="oac_no_warn" dir="ltr">SET LONG 8000 SET PAGES 8000 COLUMN OBJECT_NAME标题'对象名'格式A20列BASE_TABLE_NAME标题'基表名'格式A10列DDL_TXT标题'导致错误的DDL'格式A40 SELECT OBJECT_NAME，BASE_TABLE_NAME，DDL_TXT来自DBA_REDEFINITION_ERRORS;导致错误的对象名称基表DDL -------------------- ---------- ------------ ---------------------------- SYS_C006796 EMP_REDEF CREATE UNIQUE INDEX“HR”。“TMP $$ _ SYS_C006 7960”ON“HR”。“ INT_EMP_REDEF“（”EMPNO“）PCTFREE 10 INITRANS 2 MAXTRANS 255存储（初始65536下一个1048576 MIN EXTENTS 1 MAXEXTENTS 2147483645 PCTINCREASE 0 FREELISTS 1 FREELIST GRO UPS 1 BUFFER_POOL DEFAULT）TABLESPACE”ADMIN_TBS“SYS_C006794 EMP_REDEF ALTER TABLE”HR“。”INT_EMP_REDEF“修改（“ENAME”CONSTRAINT“TMP $$ _ SYS_C0067940”NOT NULL ENABLE NOVALIDATE）SYS_C006795 EMP_REDEF ALTER TABLE“HR”。“INT_EMP_REDEF”MODIFY（“DEPTNO”CONSTRAINT“TMP $$ _ SYS_C0067950”NOT NULL ENABLE NOVALIDATE）SYS_C006796 EMP_REDEF ALTER TABLE“ HR“。”INT_EMP_REDEF“ADD CON STRAINT”TMP $$ _ SYS_C0067960“PRIMARY KEY（”EMPNO“）使用索引PCTFREE 10 INITRANS 2 MAXT RANS 255存储（最初65536下一个1048576 MIN EXTENTS 1 MAXEXTENTS 2147483645 PCTINCREASE 0 FREELISTS 1 FREELIST GRO UPS 1 BUFFER_POOL DEFAULT）TABLESPACE“ADMIN_TBS “启用NOVALID ATE</pre><p>这些错误是由临时表上的现有主键约束引起的，可以忽略。请注意，使用此方法，更改后重新定义的表上的主键约束和索引的名称。另一种避免错误和名称更改的方法是定义没有主键约束的临时表。在这种情况下，主键约束和索引将从原始表中复制。</p>
                              <div class="infoboxnote" id="GUID-4E77A941-A660-4DB3-A7B8-D15FBD9BF509__GUID-24B21E84-08C3-48D7-96FF-5D49A40E79E7">
                                 <p class="notep1">注意：</p>
                                 <p>最好的方法是使用主键约束定义临时表，使用<code class="codeph">REGISTER_DEPENDENT_OBJECT</code>注册主键约束和索引，然后使用<code class="codeph">COPY_TABLE_DEPENDENTS</code>复制剩余的依赖对象。此方法可避免错误，并确保重新定义的表始终具有主键，并且依赖对象名称不会更改。
                                 </p>
                              </div>
                           </li>
                           <li>
                              <p>（可选）同步临时表<code class="codeph">hr.int_emp_redef</code> 。
                              </p><pre class="oac_no_warn" dir="ltr">BEGIN DBMS_REDEFINITION.SYNC_INTERIM_TABLE（uname =&gt;'hr'，orig_table =&gt;'emp_redef'，int_table =&gt;'int_emp_redef'）;结束; /</pre></li>
                           <li>
                              <p>完成重新定义。</p><pre class="oac_no_warn" dir="ltr">BEGIN DBMS_REDEFINITION.FINISH_REDEF_TABLE（uname =&gt;'hr'，orig_table =&gt;'emp_redef'，int_table =&gt;'int_emp_redef'）;结束; /</pre><p>表<code class="codeph">hr.emp_redef</code>仅在此步骤结束时的小窗口中以独占模式锁定。在此调用之后，重新定义表<code class="codeph">hr.emp_redef</code> ，使其具有<code class="codeph">hr.int_emp_redef</code>表的所有属性。
                              </p>
                              <p>请考虑在此过程中为<code class="codeph">dml_lock_timeout</code>参数指定非<code class="codeph">NULL</code>值。有关详细信息，请参阅<span class="q">“ <a href="managing-tables.html#GUID-3C702CE8-9676-4825-B92A-D4AFE78FE402" title="您可以在DBMS_REDEFINITION包中使用多个过程来执行表的在线重新定义。">在DBMS_REDEFINITION中使用多个过程执行在线重新定义</a> ”中的</span>步骤<a href="managing-tables.html#GUID-3C702CE8-9676-4825-B92A-D4AFE78FE402__BABGDBJH">8</a> 。
                              </p>
                           </li>
                           <li>
                              <p>等待对临时表的任何长时间运行的查询完成，然后删除临时表。</p>
                           </li>
                        </ol>
                     </div>
                     <!-- class="section" -->
                     <div class="section" id="GUID-4E77A941-A660-4DB3-A7B8-D15FBD9BF509__CJAEIAED">
                        <p class="subhead3" id="GUID-4E77A941-A660-4DB3-A7B8-D15FBD9BF509__GUID-950C6F84-E6A8-4659-9F11-D40460B414C6">例3</p>
                     </div>
                     <!-- class="section" -->
                     <div class="section">
                        <p>此示例重新定义表以将列更改为对象属性。重新定义的表获取一个新对象类型的列。</p>
                        <p>原始表名为<code class="codeph">customer</code> ，定义如下：</p><pre class="oac_no_warn" dir="ltr">名称类型------------ ------------- CID NUMBER &lt; - 主键NAME VARCHAR2（30）STREET VARCHAR2（100）CITY VARCHAR2（30）STATE VARCHAR2 （2）ZIP编号（5）</pre><p>新对象的类型定义是：</p><pre class="oac_no_warn" dir="ltr">CREATE TYPE addr_t AS OBJECT（street VARCHAR2（100），city VARCHAR2（30），state VARCHAR2（2），zip NUMBER（5,0））; /</pre><p>以下是重新定义的步骤：</p>
                        <ol>
                           <li>
                              <p>在SQL * Plus中，以具有执行表的在线重新定义所需特权的用户身份进行连接。</p>
                              <p>具体而言，用户必须具有<span class="q">“ <a href="managing-tables.html#GUID-0191D286-24D5-4E2A-817B-99FAAB96D4B3" title="Execute privileges on the DBMS_REDEFINITION package are required to run subprograms in the package. Execute privileges on the DBMS_REDEFINITION package are granted to EXECUTE_CATALOG_ROLE.">DBMS_REDEFINITION包所需</a></span>的权限”中描述的<span class="q"><a href="managing-tables.html#GUID-0191D286-24D5-4E2A-817B-99FAAB96D4B3" title="要在程序包中运行子程序，需要DBMS_REDEFINITION程序包的执行权限。DBMS_REDEFINITION包的执行权限被授予EXECUTE_CATALOG_ROLE。">权限</a></span> 。
                              </p>
                              <p>请参见<span class="q">“ <a href="getting-started-with-database-administration.html#GUID-895EC72B-C620-4D93-9F23-3F6DC1706764" title="Oracle数据库包括以下组件：Oracle数据库实例，它是进程和内存的集合，以及一组包含用户数据和系统数据的磁盘文件。">使用SQL * Plus连接到数据库</a> ”</span> 。
                              </p>
                           </li>
                           <li>
                              <p>验证该表是否为在线重新定义的候选者。指定使用主键或伪主键完成重定义。</p><pre class="oac_no_warn" dir="ltr">BEGIN DBMS_REDEFINITION.CAN_REDEF_TABLE（uname =&gt;'steve'，tname =&gt;'customer'，options_flag =&gt; DBMS_REDEFINITION.CONS_USE_PK）;结束; /</pre></li>
                           <li>
                              <p>创建临时表<code class="codeph">int_customer</code> 。
                              </p><pre class="oac_no_warn" dir="ltr">CREATE TABLE int_customer（CID NUMBER，NAME VARCHAR2（30），ADDR addr_t）;</pre><p>请注意，临时表中未定义主键。在步骤<a href="managing-tables.html#GUID-4E77A941-A660-4DB3-A7B8-D15FBD9BF509__CJAJJECE">6</a>中复制依赖对象时，将复制主键约束和索引。
                              </p>
                           </li>
                           <li>
                              <p>由于<code class="codeph">customer</code>是一个非常大的表，因此请为下一步指定并行操作。
                              </p><pre class="oac_no_warn" dir="ltr">ALTER SESSION FORCE PARALLEL DML PARALLEL 4; ALTER SESSION FORCE PARALLEL QUERY PARALLEL 4;</pre></li>
                           <li>
                              <p>使用主键启动重新定义过程。</p><pre class="oac_no_warn" dir="ltr">BEGIN DBMS_REDEFINITION.START_REDEF_TABLE（uname =&gt;'steve'，orig_table =&gt;'customer'，int_table =&gt;'int_customer'，col_mapping =&gt;'cid cid，name name，addr_t（street，city，state，zip）addr'）;结束; /</pre><p>请注意， <code class="codeph">addr_t(street, city, state, zip)</code>是对对象构造函数的调用。
                              </p>
                           </li>
                           <li id="GUID-4E77A941-A660-4DB3-A7B8-D15FBD9BF509__CJAJJECE">
                              <p>复制相关对象。</p><pre class="oac_no_warn" dir="ltr">DECLARE num_errors PLS_INTEGER; BEGIN DBMS_REDEFINITION.COPY_TABLE_DEPENDENTS（uname =&gt;'steve'，orig_table =&gt;'customer'，int_table =&gt;'int_customer'，copy_indexes =&gt; DBMS_REDEFINITION.CONS_ORIG_PARAMS，copy_triggers =&gt; TRUE，copy_constraints =&gt; TRUE，copy_privileges =&gt; TRUE，ignore_errors = &gt; FALSE，num_errors =&gt; num_errors，copy_statistics =&gt; TRUE）;结束; /</pre><p>请注意，对于此调用，最后一个参数指示要将表统计信息复制到临时表。</p>
                           </li>
                           <li>
                              <p>（可选）同步临时表。</p><pre class="oac_no_warn" dir="ltr">BEGIN DBMS_REDEFINITION.SYNC_INTERIM_TABLE（uname =&gt;'steve'，orig_table =&gt;'customer'，int_table =&gt;'int_customer'）;结束; /</pre></li>
                           <li>
                              <p>完成重新定义。</p><pre class="oac_no_warn" dir="ltr">BEGIN DBMS_REDEFINITION.FINISH_REDEF_TABLE（uname =&gt;'steve'，orig_table =&gt;'customer'，int_table =&gt;'int_customer'）;结束; /</pre><p>请考虑在此过程中为<code class="codeph">dml_lock_timeout</code>参数指定非<code class="codeph">NULL</code>值。有关详细信息，请参阅<span class="q">“ <a href="managing-tables.html#GUID-3C702CE8-9676-4825-B92A-D4AFE78FE402" title="您可以在DBMS_REDEFINITION包中使用多个过程来执行表的在线重新定义。">在DBMS_REDEFINITION中使用多个过程执行在线重新定义</a> ”中的</span>步骤<a href="managing-tables.html#GUID-3C702CE8-9676-4825-B92A-D4AFE78FE402__BABGDBJH">8</a> 。
                              </p>
                           </li>
                           <li>
                              <p>等待对临时表的任何长时间运行的查询完成，然后删除临时表。</p>
                           </li>
                        </ol>
                     </div>
                     <!-- class="section" -->
                     <div class="section" id="GUID-4E77A941-A660-4DB3-A7B8-D15FBD9BF509__CJAGDACH">
                        <p class="subhead3" id="GUID-4E77A941-A660-4DB3-A7B8-D15FBD9BF509__GUID-74052BB1-477F-4626-8CAA-50F56EC4637A">例4</p>
                     </div>
                     <!-- class="section" -->
                     <div class="section">
                        <p>此示例说明必须手动创建和注册从属对象的情况。</p>
                        <p>要重新定义的表定义如下：</p><pre class="oac_no_warn" dir="ltr">CREATE TABLE steve.t1（c1 NUMBER）;</pre><p>该表具有列c1的索引：</p><pre class="oac_no_warn" dir="ltr">CREATE INDEX steve.index1 ON steve.t1（c1）;</pre><p>考虑在重新定义之后列<code class="codeph">c1</code>变为列<code class="codeph">c2</code>的情况。在这种情况下， <code class="codeph">COPY_TABLE_DEPENDENTS</code>尝试在与<code class="codeph">index1</code>对应的临时表上创建索引，并尝试在列<code class="codeph">c1</code>上创建它，该列在临时表中不存在。这会导致错误。因此，您必须在列<code class="codeph">c2</code>上手动创建索引并进行注册。
                        </p>
                        <p>以下是重新定义的步骤：</p>
                        <ol>
                           <li>
                              <p>在SQL * Plus中，以具有执行表的在线重新定义所需特权的用户身份进行连接。</p>
                              <p>具体而言，用户必须具有<span class="q">“ <a href="managing-tables.html#GUID-0191D286-24D5-4E2A-817B-99FAAB96D4B3" title="Execute privileges on the DBMS_REDEFINITION package are required to run subprograms in the package. Execute privileges on the DBMS_REDEFINITION package are granted to EXECUTE_CATALOG_ROLE.">DBMS_REDEFINITION包所需</a></span>的权限”中描述的<span class="q"><a href="managing-tables.html#GUID-0191D286-24D5-4E2A-817B-99FAAB96D4B3" title="要在程序包中运行子程序，需要DBMS_REDEFINITION程序包的执行权限。DBMS_REDEFINITION包的执行权限被授予EXECUTE_CATALOG_ROLE。">权限</a></span> 。
                              </p>
                              <p>请参见<span class="q">“ <a href="getting-started-with-database-administration.html#GUID-895EC72B-C620-4D93-9F23-3F6DC1706764" title="Oracle数据库包括以下组件：Oracle数据库实例，它是进程和内存的集合，以及一组包含用户数据和系统数据的磁盘文件。">使用SQL * Plus连接到数据库</a> ”</span> 。
                              </p>
                           </li>
                           <li>
                              <p>确保<code class="codeph">t1</code>是<code class="codeph">CAN_REDEF_TABLE</code>在线重新定义的候选<code class="codeph">CAN_REDEF_TABLE</code> ，然后使用<code class="codeph">START_REDEF_TABLE</code>开始重新定义过程。</p><pre class="oac_no_warn" dir="ltr">BEGIN DBMS_REDEFINITION.CAN_REDEF_TABLE（uname =&gt;'steve'，tname =&gt;'t1'，options_flag =&gt; DBMS_REDEFINITION.CONS_USE_ROWID）;结束; /</pre></li>
                           <li>
                              <p>创建临时表<code class="codeph">int_t1</code>并在列<code class="codeph">c2</code>上创建索引<code class="codeph">int_index1</code> 。
                              </p><pre class="oac_no_warn" dir="ltr">CREATE TABLE steve.int_t1（c2 NUMBER）; CREATE INDEX steve.int_index1 ON steve.int_t1（c2）;</pre></li>
                           <li>
                              <p>开始重新定义过程。</p><pre class="oac_no_warn" dir="ltr">BEGIN DBMS_REDEFINITION.START_REDEF_TABLE（uname =&gt;'steve'，orig_table =&gt;'t1'，int_table =&gt;'int_t1'，col_mapping =&gt;'c1 c2'，options_flag =&gt; DBMS_REDEFINITION.CONS_USE_ROWID）;结束; /</pre></li>
                           <li>
                              <p>注册原始（ <code class="codeph">index1</code> ）和interim（ <code class="codeph">int_index1</code> ）依赖对象。
                              </p><pre class="oac_no_warn" dir="ltr">BEGIN DBMS_REDEFINITION.REGISTER_DEPENDENT_OBJECT（uname =&gt;'steve'，orig_table =&gt;'t1'，int_table =&gt;'int_t1'，dep_type =&gt; DBMS_REDEFINITION.CONS_INDEX，dep_owner =&gt;'steve'，dep_orig_name =&gt;'index1'，dep_int_name =&gt; 'int_index1'）;结束; /</pre></li>
                           <li>
                              <p>复制依赖对象。</p><pre class="oac_no_warn" dir="ltr">DECLARE num_errors PLS_INTEGER; BEGIN DBMS_REDEFINITION.COPY_TABLE_DEPENDENTS（uname =&gt;'steve'，orig_table =&gt;'t1'，int_table =&gt;'int_t1'，copy_indexes =&gt; DBMS_REDEFINITION.CONS_ORIG_PARAMS，copy_triggers =&gt; TRUE，copy_constraints =&gt; TRUE，copy_privileges =&gt; TRUE，ignore_errors = &gt; TRUE，num_errors =&gt; num_errors）;结束; /</pre></li>
                           <li>
                              <p>（可选）同步临时表。</p><pre class="oac_no_warn" dir="ltr">BEGIN DBMS_REDEFINITION.SYNC_INTERIM_TABLE（uname =&gt;'steve'，orig_table =&gt;'t1'，int_table =&gt;'int_t1'）;结束; /</pre></li>
                           <li>
                              <p>完成重新定义。</p><pre class="oac_no_warn" dir="ltr">BEGIN DBMS_REDEFINITION.FINISH_REDEF_TABLE（uname =&gt;'steve'，orig_table =&gt;'t1'，int_table =&gt;'int_t1'）;结束; /</pre></li>
                           <li>
                              <p>等待对临时表的任何长时间运行的查询完成，然后删除临时表。</p>
                           </li>
                        </ol>
                     </div>
                     <!-- class="section" -->
                     <div class="section" id="GUID-4E77A941-A660-4DB3-A7B8-D15FBD9BF509__BABDGIBA">
                        <p class="subhead3" id="GUID-4E77A941-A660-4DB3-A7B8-D15FBD9BF509__GUID-EE0F519E-522E-4D08-9758-CF2C8059374D">例5</p>
                     </div>
                     <!-- class="section" -->
                     <div class="section">
                        <p>此示例演示重新定义多个分区。它将范围分区的销售表的两个分区移动到新的表空间。包含要重新定义的分区的表定义如下：</p><pre class="oac_no_warn" dir="ltr">CREATE TABLE steve.salestable（s_productid NUMBER，s_saledate DATE，s_custid NUMBER，s_totalprice NUMBER）TABLESPACE用户PARTITION BY RANGE（s_saledate）（PARTITION sal10q1值小于（TO_DATE（'01 -APR-2010'，'DD-MON-YYYY'） ）），PARTITION sal10q2值不超过（2010年7月1日 - '2010年7月'，'DD-MON-YYYY'）），分配sal10q3值不到（截止日期为（'01 -OCT-2010'，'DD-MON-） YYYY'）），PARTITION sal10q4价值不到（截止日期（'01 -JAN-2011'，'DD-MON-YYYY'）））;</pre><p>此示例将<code class="codeph">sal10q1</code>分区移动到<code class="codeph">sales1</code>表空间，将<code class="codeph">sal10q2</code>分区移动到<code class="codeph">sales2</code>表空间。<code class="codeph">sal10q3</code>和<code class="codeph">sal10q4</code>分区未移动。
                        </p>
                        <p>要移动分区，必须存在表空间<code class="codeph">sales1</code>和<code class="codeph">sales2</code> 。以下示例创建了这些表空间：</p><pre class="oac_no_warn" dir="ltr">CREATE TABLESPACE sales1 DATAFILE'/u02/oracle/data/sales01.dbf'SIZE 50M EXTENT MANAGEMENT LOCAL AUTOALLOCATE; CREATE TABLESPACE sales2 DATAFILE'/ u02/oracle/data/sales02.dbf'SIZE 50M EXTENT MANAGEMENT LOCAL AUTOALLOCATE;</pre><div class="infoboxnote" id="GUID-4E77A941-A660-4DB3-A7B8-D15FBD9BF509__GUID-F26DFE4D-B5CE-4431-9D8E-6F251558F45D">
                           <p class="notep1">注意：</p>
                           <p>您也可以通过执行两个<code class="codeph">ALTER</code> <code class="codeph">TABLE</code>完成此操作<code class="codeph">...</code> <code class="codeph">MOVE</code> <code class="codeph">PARTITION</code> <code class="codeph">...</code> <code class="codeph">ONLINE</code>声明。请参阅<span class="q">“ <a href="managing-tables.html#GUID-3DE67CF4-84C5-4AED-A8A3-B1D28D8EBEF6" title="ALTER TABLE ...假设您在目标表空间中具有适当的配额，MOVE [PARTITION | SUBPARTITION]语句使您可以移动表，分区或子分区以更改任何物理存储属性（如压缩或表空间）。">将表移动到新段或表空间</a> ”</span> 。
                           </p>
                        </div>
                        <p>该表具有本地分区索引，定义如下：</p><pre class="oac_no_warn" dir="ltr">CREATE INDEX steve.sales_index ON steve.salestable（s_saledate，s_productid，s_custid）LOCAL;</pre><p>这是步骤。在以下过程调用中，请注意额外参数：partition name（ <code class="codeph">part_name</code> ）。
                        </p>
                        <ol>
                           <li>
                              <p>在SQL * Plus中，以具有执行表的在线重新定义所需特权的用户身份进行连接。</p>
                              <p>具体而言，用户必须具有<span class="q">“ <a href="managing-tables.html#GUID-0191D286-24D5-4E2A-817B-99FAAB96D4B3" title="Execute privileges on the DBMS_REDEFINITION package are required to run subprograms in the package. Execute privileges on the DBMS_REDEFINITION package are granted to EXECUTE_CATALOG_ROLE.">DBMS_REDEFINITION包所需</a></span>的权限”中描述的<span class="q"><a href="managing-tables.html#GUID-0191D286-24D5-4E2A-817B-99FAAB96D4B3" title="要在程序包中运行子程序，需要DBMS_REDEFINITION程序包的执行权限。DBMS_REDEFINITION包的执行权限被授予EXECUTE_CATALOG_ROLE。">权限</a></span> 。
                              </p>
                              <p>请参见<span class="q">“ <a href="getting-started-with-database-administration.html#GUID-895EC72B-C620-4D93-9F23-3F6DC1706764" title="Oracle数据库包括以下组件：Oracle数据库实例，它是进程和内存的集合，以及一组包含用户数据和系统数据的磁盘文件。">使用SQL * Plus连接到数据库</a> ”</span> 。
                              </p>
                           </li>
                           <li>
                              <p>确保<code class="codeph">salestable</code>是重新定义的候选者。
                              </p><pre class="oac_no_warn" dir="ltr">BEGIN DBMS_REDEFINITION.CAN_REDEF_TABLE（uname =&gt;'steve'，tname =&gt;'salestable'，options_flag =&gt; DBMS_REDEFINITION.CONS_USE_ROWID，part_name =&gt;'sal10q1，sal10q2'）;结束; /</pre></li>
                           <li>
                              <p>在新表空间中创建临时表。因为这是范围分区的重新定义，所以临时表是非分区的。</p><pre class="oac_no_warn" dir="ltr">CREATE TABLE steve.int_salestb1（s_productid NUMBER，s_saledate DATE，s_custid NUMBER，s_totalprice NUMBER）TABLESPACE sales1; CREATE TABLE steve.int_salestb2（s_productid NUMBER，s_saledate DATE，s_custid NUMBER，s_totalprice NUMBER）TABLESPACE sales2;</pre></li>
                           <li>
                              <p>使用rowid启动重新定义过程。</p><pre class="oac_no_warn" dir="ltr">BEGIN DBMS_REDEFINITION.START_REDEF_TABLE（uname =&gt;'steve'，orig_table =&gt;'salestable'，int_table =&gt;'int_salestb1，int_salestb2'，col_mapping =&gt; NULL，options_flag =&gt; DBMS_REDEFINITION.CONS_USE_ROWID，part_name =&gt;'sal10q1，sal10q2'，continue_after_errors =&gt; TRUE）;结束; /</pre><p>请注意， <code class="codeph">part_name</code>参数指定了两个分区，并且<code class="codeph">int_table</code>参数指定了每个分区的临时表。此外， <code class="codeph">continue_after_errors</code>参数设置为<code class="codeph">TRUE</code>以便重新定义过程即使遇到特定分区的错误也会继续。
                              </p>
                           </li>
                           <li>
                              <p>在临时表上手动创建任何本地索引。</p><pre class="oac_no_warn" dir="ltr">CREATE INDEX steve.int_sales1_index ON steve.int_salestb1（s_saledate，s_productid，s_custid）TABLESPACE sales1; CREATE INDEX steve.int_sales2_index ON steve.int_salestb2（s_saledate，s_productid，s_custid）TABLESPACE sales2;</pre></li>
                           <li>
                              <p>可选择同步临时表。</p><pre class="oac_no_warn" dir="ltr">BEGIN DBMS_REDEFINITION.SYNC_INTERIM_TABLE（uname =&gt;'steve'，orig_table =&gt;'salestable'，int_table =&gt;'int_salestb1，int_salestb2'，part_name =&gt;'sal10q1，sal10q2'，continue_after_errors =&gt; TRUE）;结束; /</pre></li>
                           <li>
                              <p>完成重新定义。</p><pre class="oac_no_warn" dir="ltr">BEGIN DBMS_REDEFINITION.FINISH_REDEF_TABLE（uname =&gt;'steve'，orig_table =&gt;'salestable'，int_table =&gt;'int_salestb1，int_salestb2'，part_name =&gt;'sal10q1，sal10q2'，continue_after_errors =&gt; TRUE）;结束; /</pre><p>请考虑在此过程中为<code class="codeph">dml_lock_timeout</code>参数指定非<code class="codeph">NULL</code>值。有关详细信息，请参阅<span class="q">“ <a href="managing-tables.html#GUID-3C702CE8-9676-4825-B92A-D4AFE78FE402" title="您可以在DBMS_REDEFINITION包中使用多个过程来执行表的在线重新定义。">在DBMS_REDEFINITION中使用多个过程执行在线重新定义</a> ”中的</span>步骤<a href="managing-tables.html#GUID-3C702CE8-9676-4825-B92A-D4AFE78FE402__BABGDBJH">8</a> 。
                              </p>
                           </li>
                           <li>
                              <p>等待对临时表的任何长时间运行的查询完成，然后删除临时表。</p>
                           </li>
                           <li>
                              <p>（可选）查询<code class="codeph">DBA_REDEFINITION_STATUS</code>视图以确保每个分区的重新定义成功。
                              </p><pre class="oac_no_warn" dir="ltr">SELECT BASE_TABLE_OWNER，BASE_TABLE_NAME，OPERATION，STATUS FROM DBA_REDEFINITION_STATUS;</pre><p>如果任何分区的重新定义失败，则查询<code class="codeph">DBA_REDEFINITION_ERRORS</code>视图以确定失败的原因。纠正导致故障的条件，并重新运行在线重新定义。
                              </p>
                           </li>
                        </ol>
                        <p>以下查询显示表中的两个分区已移至新的表空间：</p><pre class="oac_no_warn" dir="ltr">SELECT PARTITION_NAME，TABLESPACE_NAME来自DBA_TAB_PARTITIONS，其中TABLE_NAME ='SALESTABLE'; PARTITION_NAME TABLESPACE_NAME ------------------------------ ------------------ ------------ SAL10Q1 SALES1 SAL10Q2 SALES2 SAL10Q3用户SAL10Q4用户选择4行。</pre></div>
                     <!-- class="section" -->
                     <div class="section" id="GUID-4E77A941-A660-4DB3-A7B8-D15FBD9BF509__BABBIGBI">
                        <p class="subhead3" id="GUID-4E77A941-A660-4DB3-A7B8-D15FBD9BF509__GUID-AC52C6BA-21B4-4879-A5A8-0C338DD4BE78">例6</p>
                     </div>
                     <!-- class="section" -->
                     <div class="section">
                        <p>此示例说明了使用虚拟专用数据库（VPD）策略在线重新定义表。该示例禁用表的所有触发器，而不更改表中的任何列名称或列类型。</p>
                        <p>要重新定义的表定义如下：</p><pre class="oac_no_warn" dir="ltr">CREATE TABLE hr.employees（employee_id NUMBER（6）PRIMARY KEY，first_name VARCHAR2（20），last_name VARCHAR2（25）CONSTRAINT emp_last_name_nn NOT NULL，email VARCHAR2（25）CONSTRAINT emp_email_nn NOT NULL，phone_number VARCHAR2（20），hire_date DATE CONSTRAINT emp_hire_date_nn NOT NULL，job_id VARCHAR2（10）CONSTRAINT emp_job_nn NOT NULL，工资NUMBER（8,2），commission_pct NUMBER（2,2），manager_id NUMBER（6），department_id NUMBER（4），CONSTRAINT emp_salary_min检查（工资&gt; 0）， CONSTRAINT emp_email_uk UNIQUE（email））;</pre><p>如果安装了<code class="codeph">HR</code>示例模式，则此表存在于数据库中。
                        </p>
                        <p>假设为VPD策略创建了以下<code class="codeph">auth_emp_dep_100</code>函数：</p><pre class="oac_no_warn" dir="ltr">创建或替换函数hr.auth_emp_dep_100（schema_var IN VARCHAR2，table_var IN VARCHAR2）RETURN VARCHAR2 AS return_val VARCHAR2（400）; unm VARCHAR2（30）; BEGIN SELECT USER INTO FROM DUAL; IF（unm ='HR'）THEN return_val：= NULL; ELSE return_val：='DEPARTMENT_ID = 100';万一; RETURN return_val; END auth_emp_dep_100; /</pre><p>以下<code class="codeph">ADD_POLICY</code>过程使用<code class="codeph">auth_emp_dep_100</code>函数为原始表<code class="codeph">hr.employees</code>指定VPD策略：</p><pre class="oac_no_warn" dir="ltr">BEGIN DBMS_RLS.ADD_POLICY（object_schema =&gt;'hr'，object_name =&gt;'employees'，policy_name =&gt;'employees_policy'，function_schema =&gt;'hr'，policy_function =&gt;'auth_emp_dep_100'，statement_types =&gt;'选择，插入，更新，删除'）;结束; /</pre><p>在此示例中，重新定义<code class="codeph">hr.employees</code>表以禁用其所有触发器。重新定义期间不会更改列名称或列类型。因此，指定<code class="codeph">DBMS_REDEFINITION.CONS_VPD_AUTO</code>为<code class="codeph">copy_vpd_opt</code>在<code class="codeph">START_REFEF_TABLE</code>程序。
                        </p>
                        <p>重新定义的步骤如下所示。</p>
                        <ol>
                           <li>
                              <p>在SQL * Plus中，以用户身份连接，具有执行表的在线重新定义所需的权限以及管理VPD策略所需的权限。</p>
                              <p>具体而言，用户必须具有<span class="q">“ <a href="managing-tables.html#GUID-0191D286-24D5-4E2A-817B-99FAAB96D4B3" title="要在程序包中运行子程序，需要DBMS_REDEFINITION程序包的执行权限。DBMS_REDEFINITION包的执行权限被授予EXECUTE_CATALOG_ROLE。">DBMS_REDEFINITION包所需的</a></span>权限<span class="q">”</span>和<code class="codeph">DBMS_RLS</code>包的<code class="codeph">EXECUTE</code>权限中描述的权限。
                              </p>
                              <p>请参见<span class="q">“ <a href="getting-started-with-database-administration.html#GUID-895EC72B-C620-4D93-9F23-3F6DC1706764" title="Oracle数据库包括以下组件：Oracle数据库实例，它是进程和内存的集合，以及一组包含用户数据和系统数据的磁盘文件。">使用SQL * Plus连接到数据库</a> ”</span> 。
                              </p>
                           </li>
                           <li>
                              <p>验证该表是否为在线重新定义的候选者。在这种情况下，您指定使用主键或伪主键完成重定义。</p><pre class="oac_no_warn" dir="ltr">BEGIN DBMS_REDEFINITION.CAN_REDEF_TABLE（'hr'，'employees'，DBMS_REDEFINITION.CONS_USE_PK）;结束; /</pre></li>
                           <li>
                              <p>创建临时表<code class="codeph">hr.int_employees</code> 。
                              </p><pre class="oac_no_warn" dir="ltr">CREATE TABLE hr.int_employees（employee_id NUMBER（6），first_name VARCHAR2（20），last_name VARCHAR2（25），电子邮件VARCHAR2（25），phone_number VARCHAR2（20），hire_date DATE，job_id VARCHAR2（10），工资NUMBER（8， 2），commission_pct NUMBER（2,2），manager_id NUMBER（6），department_id NUMBER（4））;</pre></li>
                           <li>
                              <p>开始重新定义过程。</p><pre class="oac_no_warn" dir="ltr">BEGIN DBMS_REDEFINITION.START_REDEF_TABLE（uname =&gt;'hr'，orig_table =&gt;'employees'，int_table =&gt;'int_employees'，col_mapping =&gt; NULL，options_flag =&gt; DBMS_REDEFINITION.CONS_USE_PK，orderby_cols =&gt; NULL，part_name =&gt; NULL，copy_vpd_opt = &gt; DBMS_REDEFINITION.CONS_VPD_AUTO）;结束; /</pre><p>当<code class="codeph">copy_vpd_opt</code>参数设置为<code class="codeph">DBMS_REDEFINITION.CONS_VPD_AUTO</code> ，只有表所有者和用户调用在线重定义可以在网上重新定义期间访问临时表。
                              </p>
                              <p>另请注意， <code class="codeph">col_mapping</code>参数设置为<code class="codeph">NULL</code> 。当<code class="codeph">copy_vpd_opt</code>参数设置为<code class="codeph">DBMS_REDEFINITION.CONS_VPD_AUTO</code> ，该<code class="codeph">col_mapping</code>参数必须是<code class="codeph">NULL</code>或<code class="codeph">'*'</code> 。请参阅<span class="q">“ <a href="managing-tables.html#GUID-070A3AEC-4226-4E65-BDB0-A5B2B5B48B1F" title="如果重新定义的原始表具有为其指定的VPD策略，则可以使用START_REDEF_TABLE过程中的copy_vpd_opt参数在联机重新定义期间处理这些策略。">在线重新定义期间处理虚拟专用数据库（VPD）策略</a> ”</span> 。
                              </p>
                           </li>
                           <li>
                              <p>复制相关对象。（自动在<code class="codeph">hr.int_employees</code>上创建任何触发器，索引，物化视图日志，授权和约束。）
                              </p><pre class="oac_no_warn" dir="ltr">DECLARE num_errors PLS_INTEGER; BEGIN DBMS_REDEFINITION.COPY_TABLE_DEPENDENTS（uname =&gt;'hr'，orig_table =&gt;'employees'，int_table =&gt;'int_employees'，copy_indexes =&gt; DBMS_REDEFINITION.CONS_ORIG_PARAMS，copy_triggers =&gt; TRUE，copy_constraints =&gt; TRUE，copy_privileges =&gt; TRUE，ignore_errors = &gt; FALSE，num_errors =&gt; num_errors）;结束; /</pre></li>
                           <li>
                              <p>禁用临时表上的所有触发器。</p><pre class="oac_no_warn" dir="ltr">ALTER TABLE hr.int_employees DISABLE ALL TRIGGERS;</pre></li>
                           <li>
                              <p>（可选）同步临时表<code class="codeph">hr.int_employees</code> 。
                              </p><pre class="oac_no_warn" dir="ltr">BEGIN DBMS_REDEFINITION.SYNC_INTERIM_TABLE（uname =&gt;'hr'，orig_table =&gt;'employees'，int_table =&gt;'int_employees'）;结束; /</pre></li>
                           <li>
                              <p>完成重新定义。</p><pre class="oac_no_warn" dir="ltr">BEGIN DBMS_REDEFINITION.FINISH_REDEF_TABLE（uname =&gt;'hr'，orig_table =&gt;'employees'，int_table =&gt;'int_employees'）;结束; /</pre><p>表<code class="codeph">hr.employees</code>仅在此步骤结束时的小窗口中以独占模式锁定。在此调用之后，重新定义表<code class="codeph">hr.employees</code> ，使其具有<code class="codeph">hr.int_employees</code>表的所有属性。
                              </p>
                              <p>请考虑在此过程中为<code class="codeph">dml_lock_timeout</code>参数指定非<code class="codeph">NULL</code>值。有关详细信息，请参阅<span class="q">“ <a href="managing-tables.html#GUID-3C702CE8-9676-4825-B92A-D4AFE78FE402" title="您可以在DBMS_REDEFINITION包中使用多个过程来执行表的在线重新定义。">在DBMS_REDEFINITION中使用多个过程执行在线重新定义</a> ”中的</span>步骤<a href="managing-tables.html#GUID-3C702CE8-9676-4825-B92A-D4AFE78FE402__BABGDBJH">8</a> 。
                              </p>
                           </li>
                           <li>
                              <p>等待对临时表的任何长时间运行的查询完成，然后删除临时表。</p>
                           </li>
                        </ol>
                     </div>
                     <!-- class="section" -->
                     <div class="section" id="GUID-4E77A941-A660-4DB3-A7B8-D15FBD9BF509__BABFFJAA">
                        <p class="subhead3" id="GUID-4E77A941-A660-4DB3-A7B8-D15FBD9BF509__GUID-6B0D4F52-E137-4E95-B121-E75B544ABBB2">例7</p>
                     </div>
                     <!-- class="section" -->
                     <div class="section">
                        <p>此示例说明了使用虚拟专用数据库（VPD）策略在线重新定义表。该示例更改表中列的名称。</p>
                        <p>要重新定义的表定义如下：</p><pre class="oac_no_warn" dir="ltr">CREATE TABLE oe.orders（order_id NUMBER（12）PRIMARY KEY，order_date TIMESTAMP WITH LOCAL TIME ZONE CONSTRAINT order_date_nn NOT NULL，order_mode VARCHAR2（8），customer_id NUMBER（6）CONSTRAINT order_customer_id_nn NOT NULL，order_status NUMBER（2），order_total NUMBER（ 8,2），sales_rep_id NUMBER（6），promotion_id NUMBER（6），CONSTRAINT order_mode_lov CHECK（order_mode in（'direct'，'online'）），CONSTRAINT order_total_min check（order_total&gt; = 0））;</pre><p>如果安装了<code class="codeph">OE</code>示例模式，则此表存在于数据库中。
                        </p>
                        <p>假设为VPD策略创建了以下<code class="codeph">auth_orders</code>函数：</p><pre class="oac_no_warn" dir="ltr">创建或替换函数oe.auth_orders（schema_var IN VARCHAR2，table_var IN VARCHAR2）RETURN VARCHAR2 AS return_val VARCHAR2（400）; unm VARCHAR2（30）; BEGIN SELECT USER INTO FROM DUAL; IF（unm ='OE'）那么return_val：= NULL; ELSE return_val：='SALES_REP_ID = 159';万一; RETURN return_val; END auth_orders; /</pre><p>以下<code class="codeph">ADD_POLICY</code>过程使用<code class="codeph">auth_orders</code>函数为原始表<code class="codeph">oe.orders</code>指定VPD策略：</p><pre class="oac_no_warn" dir="ltr">BEGIN DBMS_RLS.ADD_POLICY（object_schema =&gt;'oe'，object_name =&gt;'orders'，policy_name =&gt;'orders_policy'，function_schema =&gt;'oe'，policy_function =&gt;'auth_orders'，statement_types =&gt;'选择，插入，更新，删除'）;结束; /</pre><p>在此示例中，重新定义了表以将<code class="codeph">sales_rep_id</code>列更改为<code class="codeph">sale_pid</code> 。当一个或多个列名或列类型重新定义过程中更改，必须指定<code class="codeph">DBMS_REDEFINITION.CONS_VPD_MANUAL</code>为<code class="codeph">copy_vpd_opt</code>在<code class="codeph">START_REFEF_TABLE</code>程序。
                        </p>
                        <p>重新定义的步骤如下所示。</p>
                        <ol>
                           <li>
                              <p>在SQL * Plus中，以用户身份连接，具有执行表的在线重新定义所需的权限以及管理VPD策略所需的权限。</p>
                              <p>具体而言，用户必须具有<span class="q">“ <a href="managing-tables.html#GUID-0191D286-24D5-4E2A-817B-99FAAB96D4B3" title="要在程序包中运行子程序，需要DBMS_REDEFINITION程序包的执行权限。DBMS_REDEFINITION包的执行权限被授予EXECUTE_CATALOG_ROLE。">DBMS_REDEFINITION包所需的</a></span>权限<span class="q">”</span>和<code class="codeph">DBMS_RLS</code>包的<code class="codeph">EXECUTE</code>权限中描述的权限。
                              </p>
                              <p>请参见<span class="q">“ <a href="getting-started-with-database-administration.html#GUID-895EC72B-C620-4D93-9F23-3F6DC1706764" title="Oracle数据库包括以下组件：Oracle数据库实例，它是进程和内存的集合，以及一组包含用户数据和系统数据的磁盘文件。">使用SQL * Plus连接到数据库</a> ”</span> 。
                              </p>
                           </li>
                           <li>
                              <p>验证该表是否为在线重新定义的候选者。在这种情况下，您指定使用主键或伪主键完成重定义。</p><pre class="oac_no_warn" dir="ltr">BEGIN DBMS_REDEFINITION.CAN_REDEF_TABLE（uname =&gt;'oe'，tname =&gt;'orders'，options_flag =&gt; DBMS_REDEFINITION.CONS_USE_PK）;结束; /</pre></li>
                           <li>
                              <p>创建一个临时表<code class="codeph">oe.int_orders</code> 。
                              </p><pre class="oac_no_warn" dir="ltr">CREATE TABLE oe.int_orders（order_id NUMBER（12），order_date TIMESTAMP WITH LOCAL TIME ZONE，order_mode VARCHAR2（8），customer_id NUMBER（6），order_status NUMBER（2），order_total NUMBER（8,2），sales_pid NUMBER（6） ，promotion_id NUMBER（6））;</pre><p>请注意， <code class="codeph">sales_rep_id</code>列已更改为临时表中的<code class="codeph">sales_pid</code>列。
                              </p>
                           </li>
                           <li>
                              <p>开始重新定义过程。</p><pre class="oac_no_warn" dir="ltr">BEGIN DBMS_REDEFINITION.START_REDEF_TABLE（uname =&gt;'oe'，orig_table =&gt;'orders'，int_table =&gt;'int_orders'，col_mapping =&gt;'order_id order_id，order_date order_date，order_mode order_mode，customer_id customer_id，order_status order_status，order_total order_total，sales_rep_id sales_pid ，promotion_id promotion_id'，options_flag =&gt; DBMS_REDEFINITION.CONS_USE_PK，orderby_cols =&gt; NULL，part_name =&gt; NULL，copy_vpd_opt =&gt; DBMS_REDEFINITION.CONS_VPD_MANUAL）;结束; /</pre><p>由于列名是在原表和临时表不同， <code class="codeph">DBMS_REDEFINITION.CONS_VPD_MANUAL</code>必须为指定<code class="codeph">copy_vpd_opt</code>参数。请参阅<span class="q">“ <a href="managing-tables.html#GUID-070A3AEC-4226-4E65-BDB0-A5B2B5B48B1F" title="如果重新定义的原始表具有为其指定的VPD策略，则可以使用START_REDEF_TABLE过程中的copy_vpd_opt参数在联机重新定义期间处理这些策略。">在线重新定义期间处理虚拟专用数据库（VPD）策略</a> ”</span> 。
                              </p>
                           </li>
                           <li>
                              <p>在临时表上创建VPD策略。</p>
                              <p>在此示例中，完成以下步骤：</p>
                              <ol type="a">
                                 <li>
                                    <p>为VPD策略创建一个名为<code class="codeph">auth_orders_sales_pid</code>的新函数，该函数指定<code class="codeph">sales_pid</code>列而不是<code class="codeph">sales_rep_id</code>列：</p><pre class="oac_no_warn" dir="ltr">创建或替换函数oe.auth_orders_sales_pid（schema_var IN VARCHAR2，table_var IN VARCHAR2）RETURN VARCHAR2 AS return_val VARCHAR2（400）; unm VARCHAR2（30）; BEGIN SELECT USER INTO FROM DUAL; IF（unm ='OE'）那么return_val：= NULL; ELSE return_val：='SALES_PID = 159';万一; RETURN return_val; END auth_orders_sales_pid; /</pre></li>
                                 <li>
                                    <p>运行<code class="codeph">ADD_POLICY</code>过程并指定新函数<code class="codeph">auth_orders_sales_pid</code>和临时表<code class="codeph">int_orders</code> ：</p><pre class="oac_no_warn" dir="ltr">BEGIN DBMS_RLS.ADD_POLICY（object_schema =&gt;'oe'，object_name =&gt;'int_orders'，policy_name =&gt;'orders_policy'，function_schema =&gt;'oe'，policy_function =&gt;'auth_orders_sales_pid'，statement_types =&gt;'选择，插入，更新，删除'）;结束; /</pre></li>
                              </ol>
                           </li>
                           <li>
                              <p>复制相关对象。（自动在<code class="codeph">oe.int_orders</code>上创建任何触发器，索引，物化视图日志，授权和约束。）
                              </p><pre class="oac_no_warn" dir="ltr">DECLARE num_errors PLS_INTEGER; BEGIN DBMS_REDEFINITION.COPY_TABLE_DEPENDENTS（uname =&gt;'oe'，orig_table =&gt;'orders'，int_table =&gt;'int_orders'，copy_indexes =&gt; DBMS_REDEFINITION.CONS_ORIG_PARAMS，copy_triggers =&gt; TRUE，copy_constraints =&gt; TRUE，copy_privileges =&gt; TRUE，ignore_errors = &gt; TRUE，num_errors =&gt; num_errors）;结束; /</pre><p>请注意，此调用的<code class="codeph">ignore_errors</code>参数设置为<code class="codeph">TRUE</code> 。原因是原始表具有与<code class="codeph">sales_rep_id</code>列相关的索引和约束，并且此列在临时表中更改为<code class="codeph">sales_pid</code> 。下一步显示错误并描述如何在临时表上创建索引和约束。
                              </p>
                           </li>
                           <li>
                              <p>查询<code class="codeph">DBA_REDEFINITION_ERRORS</code>视图以检查错误。
                              </p><pre class="oac_no_warn" dir="ltr">SET LONG 8000 SET PAGES 8000 COLUMN OBJECT_NAME标题'对象名'格式A20列BASE_TABLE_NAME标题'基表名'格式A10列DDL_TXT标题'导致错误的DDL'格式A40 SELECT OBJECT_NAME，BASE_TABLE_NAME，DDL_TXT来自DBA_REDEFINITION_ERRORS;导致错误的对象名称基表DDL -------------------- ---------- ------------ ---------------------------- ORDERS_SALES_REP_FK ORDERS ALTER TABLE“OE”。“INT_ORDERS”添加CONSTR AINT“TMP $$ _ ORDERS_SALES_REP_FK1”FOREIG N KEY（“SALES_REP_ID”）参考“HR”。“EMPLOYEES”（“EMPLOYE E_ID”）ON DELETE SET NULL DISABLE ORD_SALES_REP_IX ORDERS CREATE INDEX“OE”。“TMP $$ _ ORD_SALES_REP_I X0”ON“OE”。“INT_ORDERS”（“ SALES_REP_ID“）PCTFREE 10 INITRANS 2 MAXTRANS 255 COM PUTE STATISTICS STORAGE（INITIAL 65536 NEXT 1048576 MIN EXTENTS 1 MAXEXTENTS 2147483645 PCTINCREASE 0 FREELISTS 1 FREELIST GRO UPS 1 BUFFER_POOL DEFAULT）TABLESPACE”EXAMPLE“TMP $$ _ ORDERS_SALES_R ORDERS ALTER TABLE”OE“。” INT_ORDERS“ADD CONSTR EP_FK0 AINT”TMP $$ _ TMP $$ _ ORDERS_SALES_RE0“FORE IGN KEY（”SALES_REP_ID“）REFERENCES”HR“。”INT_EMPLOYEES“（”EMP LOYEE_ID“）ON DELETE SET NULL DISABLE</pre><p>如有必要，请更正输出中报告的错误。</p>
                              <p>在此示例中，原始表在<code class="codeph">sales_rep_id</code>列上具有索引和外键约束。无法将索引和约束复制到临时表，因为列的名称已从<code class="codeph">sales_rep_id</code>更改为<code class="codeph">sales_pid</code> 。
                              </p>
                              <p>要更正问题，请通过完成以下步骤在临时表上添加索引和约束：</p>
                              <ol type="a">
                                 <li>
                                    <p>添加索引：</p><pre class="oac_no_warn" dir="ltr">ALTER TABLE oe.int_orders ADD（CONSTRAINT orders_sales_pid_fk FOREIGN KEY（sales_pid）REFERENCES hr.employees（employee_id）ON DELETE SET NULL）;</pre></li>
                                 <li>
                                    <p>添加外键约束：</p><pre class="oac_no_warn" dir="ltr">CREATE INDEX ord_sales_pid_ix ON oe.int_orders（sales_pid）;</pre></li>
                              </ol>
                           </li>
                           <li>
                              <p>（可选）同步临时表<code class="codeph">oe.int_orders</code> 。
                              </p><pre class="oac_no_warn" dir="ltr">BEGIN DBMS_REDEFINITION.SYNC_INTERIM_TABLE（uname =&gt;'oe'，orig_table =&gt;'orders'，int_table =&gt;'int_orders'）;结束; /</pre></li>
                           <li>
                              <p>完成重新定义。</p><pre class="oac_no_warn" dir="ltr">BEGIN DBMS_REDEFINITION.FINISH_REDEF_TABLE（uname =&gt;'oe'，orig_table =&gt;'orders'，int_table =&gt;'int_orders'）;结束; /</pre><p>表<code class="codeph">oe.orders</code>仅在此步骤结束时的小窗口中以独占模式锁定。在此调用之后，重新定义表<code class="codeph">oe.orders</code> ，使其具有<code class="codeph">oe.int_orders</code>表的所有属性。
                              </p>
                              <p>请考虑在此过程中为<code class="codeph">dml_lock_timeout</code>参数指定非<code class="codeph">NULL</code>值。有关详细信息，请参阅<span class="q">“ <a href="managing-tables.html#GUID-3C702CE8-9676-4825-B92A-D4AFE78FE402" title="您可以在DBMS_REDEFINITION包中使用多个过程来执行表的在线重新定义。">在DBMS_REDEFINITION中使用多个过程执行在线重新定义</a> ”中的</span>步骤<a href="managing-tables.html#GUID-3C702CE8-9676-4825-B92A-D4AFE78FE402__BABGDBJH">8</a> 。
                              </p>
                           </li>
                           <li>
                              <p>等待对临时表的任何长时间运行的查询完成，然后删除临时表。</p>
                           </li>
                        </ol>
                     </div>
                     <!-- class="section" -->
                     <div class="section" id="GUID-4E77A941-A660-4DB3-A7B8-D15FBD9BF509__BABFAHGD">
                        <p class="subhead3" id="GUID-4E77A941-A660-4DB3-A7B8-D15FBD9BF509__GUID-291F762F-80D5-45B6-9765-710CB5CE3C8F">例8</p>
                     </div>
                     <!-- class="section" -->
                     <div class="section">
                        <p>此示例说明使用联机重定义对表进行多项更改。</p>
                        <p>要重新定义的表定义如下：</p><pre class="oac_no_warn" dir="ltr">CREATE TABLE testredef.original（col1 NUMBER PRIMARY KEY，col2 VARCHAR2（10），col3 CLOB，col4 DATE）ORGANIZATION INDEX;</pre><p>该表重新定义如下：</p>
                        <ul style="list-style-type:disc">
                           <li>
                              <p>该表使用高级行压缩进行压缩。</p>
                           </li>
                           <li>
                              <p>LOB列已更改为SecureFiles LOB存储。</p>
                           </li>
                           <li>
                              <p>表的表空间从<code class="codeph">example</code>更改为<code class="codeph">testredeftbs</code> ，表的块大小从8KB更改为16KB。</p>
                              <p>此示例假定数据库块大小为8KB。此示例还假定已设置<code class="codeph">DB_16K_CACHE_SIZE</code>初始化参数，并且使用16KB块大小创建了<code class="codeph">testredef</code>表空间。例如：</p><pre class="oac_no_warn" dir="ltr">CREATE TABLESPACE testredeftbs DATAFILE'/u01/app/oracle/oradata/testredef01.dbf'SIZE 500M EXTENT MANAGEMENT LOCAL AUTOALLOCATE SEGMENT SPACE MANAGEMENT AUTO BLOCKSIZE 16384;</pre></li>
                           <li>
                              <p>该表在<code class="codeph">col1</code>列上进行了分区。
                              </p>
                           </li>
                           <li>
                              <p><code class="codeph">col5</code>列已添加。
                              </p>
                           </li>
                           <li>
                              <p><code class="codeph">col2</code>列被删除。
                              </p>
                           </li>
                           <li>
                              <p>将重命名列<code class="codeph">col3</code>和<code class="codeph">col4</code> ，并更改它们在表中的位置。
                              </p>
                           </li>
                           <li>
                              <p><code class="codeph">col3</code>列的类型从<code class="codeph">DATE</code>更改为<code class="codeph">TIMESTAMP</code> 。</p>
                           </li>
                           <li>
                              <p>该表从索引组织表（IOT）更改为堆组织表。</p>
                           </li>
                           <li>
                              <p>该表经过碎片整理。</p>
                              <p>要演示碎片整理，必须填充表。出于此示例的目的，您可以使用此PL / SQL块来填充表：</p><pre class="oac_no_warn" dir="ltr">DECLARE V_CLOB CLOB;我开始于0..999 LOOP V_CLOB：= NULL; FOR J IN 1..1000 LOOP V_CLOB：= V_CLOB || TO_CHAR（I，'0000'）;结束循环; INSERT INTO testredef.original VALUES（I，TO_CHAR（I），V_CLOB，SYSDATE + I）;承诺;结束循环;承诺;结束; /</pre><p>运行以下SQL语句，通过删除每第三行来对表进行分段：</p><pre class="oac_no_warn" dir="ltr">DELETE FROM testredef.original WHERE（COL1 / 3）&lt;&gt; TRUNC（COL1 / 3）;</pre><p>您可以使用<code class="codeph">DBMS_SPACE.SPACE_USAGE</code>过程确认碎片。
                              </p>
                              <div class="infoboxnotealso" id="GUID-4E77A941-A660-4DB3-A7B8-D15FBD9BF509__GUID-14A5C4E6-6E27-41EA-8A24-CF98DEC4576E">
                                 <p class="notep1">也可以看看：</p>
                                 <p>有关<code class="codeph">DBMS_SPACE.SPACE_USAGE</code>过程的详细信息，请<code class="codeph">DBMS_SPACE.SPACE_USAGE</code> <a href="https://www.oracle.com/pls/topic/lookup?ctx=en/database/oracle/oracle-database/19/admin&amp;id=ARPLS68113" target="_blank"><span class="italic">Oracle Database PL / SQL包和类型参考</span></a></p>
                              </div>
                           </li>
                        </ul>
                        <p>重新定义的步骤如下所示。</p>
                        <ol>
                           <li>
                              <p>在SQL * Plus中，以具有执行表的在线重新定义所需特权的用户身份进行连接。</p>
                              <p>具体而言，用户必须具有<span class="q">“ <a href="managing-tables.html#GUID-0191D286-24D5-4E2A-817B-99FAAB96D4B3" title="Execute privileges on the DBMS_REDEFINITION package are required to run subprograms in the package. Execute privileges on the DBMS_REDEFINITION package are granted to EXECUTE_CATALOG_ROLE.">DBMS_REDEFINITION包所需</a></span>的权限”中描述的<span class="q"><a href="managing-tables.html#GUID-0191D286-24D5-4E2A-817B-99FAAB96D4B3" title="要在程序包中运行子程序，需要DBMS_REDEFINITION程序包的执行权限。DBMS_REDEFINITION包的执行权限被授予EXECUTE_CATALOG_ROLE。">权限</a></span> 。
                              </p>
                              <p>请参见<span class="q">“ <a href="getting-started-with-database-administration.html#GUID-895EC72B-C620-4D93-9F23-3F6DC1706764" title="Oracle数据库包括以下组件：Oracle数据库实例，它是进程和内存的集合，以及一组包含用户数据和系统数据的磁盘文件。">使用SQL * Plus连接到数据库</a> ”</span> 。
                              </p>
                           </li>
                           <li>
                              <p>验证该表是否为在线重新定义的候选者。在这种情况下，您指定使用主键或伪主键完成重定义。</p><pre class="oac_no_warn" dir="ltr">BEGIN DBMS_REDEFINITION.CAN_REDEF_TABLE（uname =&gt;'testredef'，tname =&gt;'original'，options_flag =&gt; DBMS_REDEFINITION.CONS_USE_PK）;结束; /</pre></li>
                           <li>
                              <p>创建一个临时表<code class="codeph">testredef.interim</code> 。
                              </p><pre class="oac_no_warn" dir="ltr">CREATE TABLE testredef.interim（col1 NUMBER，col3 TIMESTAMP，col4 CLOB，col5 VARCHAR2（3））LOB（col4）STORE AS SECUREFILE（NOCACHE FILESYSTEM_LIKE_LOGGING）按范围划分（COL1）（PARTITION par1值小于（333），PARTITION par2价值低于（666），分区par3值低于（MAXVALUE））TABLESPACE testredeftbs ROW STORE COMPRESS ADVANCED;</pre></li>
                           <li>
                              <p>开始重新定义过程。</p><pre class="oac_no_warn" dir="ltr">BEGIN DBMS_REDEFINITION.START_REDEF_TABLE（uname =&gt;'testredef'，orig_table =&gt;'original'，int_table =&gt;'interim'，col_mapping =&gt;'col1 col1，TO_TIMESTAMP（col4）col3，col3 col4'，options_flag =&gt; DBMS_REDEFINITION.CONS_USE_PK） ;结束; /</pre></li>
                           <li>
                              <p>复制依赖对象。</p><pre class="oac_no_warn" dir="ltr">DECLARE num_errors PLS_INTEGER; BEGIN DBMS_REDEFINITION.COPY_TABLE_DEPENDENTS（uname =&gt;'testredef'，orig_table =&gt;'original'，int_table =&gt;'interim'，copy_indexes =&gt; DBMS_REDEFINITION.CONS_ORIG_PARAMS，copy_triggers =&gt; TRUE，copy_constraints =&gt; TRUE，copy_privileges =&gt; TRUE，ignore_errors = &gt; TRUE，num_errors =&gt; num_errors）;结束; /</pre></li>
                           <li>
                              <p>（可选）同步临时表。</p><pre class="oac_no_warn" dir="ltr">BEGIN DBMS_REDEFINITION.SYNC_INTERIM_TABLE（uname =&gt;'testredef'，orig_table =&gt;'original'，int_table =&gt;'interim'）;结束; /</pre></li>
                           <li>
                              <p>完成重新定义。</p><pre class="oac_no_warn" dir="ltr">BEGIN DBMS_REDEFINITION.FINISH_REDEF_TABLE（uname =&gt;'testredef'，orig_table =&gt;'original'，int_table =&gt;'interim'）;结束; /</pre></li>
                        </ol>
                     </div>
                     <!-- class="section" -->
                  </div>
                  <div>
                     <div class="infoboxnotealso" id="GUID-4E77A941-A660-4DB3-A7B8-D15FBD9BF509__GUID-51F5F4AC-A199-4072-AEA5-8A871DF8C7AF">
                        <p class="notep1">也可以看看：</p><a href="https://www.oracle.com/pls/topic/lookup?ctx=en/database/oracle/oracle-database/19/admin&amp;id=COMSC" target="_blank"><span><cite>Oracle数据库示例模式</cite></span></a></div>
                     <div class="familylinks">
                        <div class="parentlink">
                           <p><strong>父主题：</strong> <a href="managing-tables.html#GUID-92361F74-4796-407D-A3B9-569C6E544E34" title="您可以修改表的逻辑或物理结构。">在线重新定义表</a></p>
                        </div>
                     </div>
                  </div>
                  
               </div>
            </div><a id="ADMIN01513"></a><div class="props_rev_3"><a id="GUID-2DD8A6E0-0195-4F3F-83A9-74BE0980FBA4" name="GUID-2DD8A6E0-0195-4F3F-83A9-74BE0980FBA4"></a><h3 id="ADMIN-GUID-2DD8A6E0-0195-4F3F-83A9-74BE0980FBA4" class="sect3"><span class="enumeration_section">20.9</span>研究和扭转错误的表格变化</h3>
               <div>
                  <p>为了使您能够研究和逆转对表的错误更改，Oracle数据库提供了一组功能，您可以使用这些功能查看数据库对象的过去状态，或者在不使用时间点介质恢复的情况下将数据库对象返回到先前状态。这些功能称为<span class="bold">Oracle闪回功能</span> 。
                  </p>
                  <p>要研究错误的更改，您可以使用多个Oracle闪回查询来查看特定时间点的行数据。更有效的方法是使用Oracle闪回版本查询在一段时间内查看对行的所有更改。使用此功能，可以将一个<code class="codeph">VERSIONS</code>子句附加到<code class="codeph">SELECT</code>语句，该语句指定要在其中查看行值更改的系统更改编号（SCN）或时间戳范围。查询还可以返回关联的元数据，例如负责更改的事务。
                  </p>
                  <p>识别错误事务后，可以使用Oracle闪回事务查询来识别事务所做的其他更改。然后，您可以使用Oracle闪回事务来反转错误的事务。（请注意，Oracle闪回事务还必须反转所有依赖事务 - 后续事务涉及与错误事务相同的行。）您还可以选择使用<span class="q">“ <a href="managing-tables.html#GUID-14433799-D469-4A56-AAE4-089D3C3E1A5C" title="Oracle Flashback Table enables you to restore a table to its state as of a previous point in time.">使用Oracle闪回表恢复表</a> ”中</span>所述的<span class="q"><a href="managing-tables.html#GUID-14433799-D469-4A56-AAE4-089D3C3E1A5C" title="通过Oracle闪回表，您可以将表还原到以前某个时间点的状态。">Oracle闪回表</a></span> 。
                  </p>
                  <div class="infoboxnote" id="GUID-2DD8A6E0-0195-4F3F-83A9-74BE0980FBA4__GUID-5C167E50-0114-46AA-85C2-42EA9DF39C4B">
                     <p class="notep1">注意：</p>
                     <p>您必须使用自动撤消管理才能使用Oracle闪回功能。请参阅<span class="q">“ <a href="managing-undo.html#GUID-106B56C9-CB60-4E46-86A6-BF645E9E1A7F" title="Oracle数据库可以自动管理撤消信息和空间。">自动撤消管理简介</a> ”</span> 。
                     </p>
                  </div>
               </div>
               <div>
                  <div class="infoboxnotealso" id="GUID-2DD8A6E0-0195-4F3F-83A9-74BE0980FBA4__GUID-E24515AD-6BAD-44F8-80DB-9DCEB95288C8">
                     <p class="notep1">也可以看看：</p>
                     <p>有关Oracle闪回功能的信息，请参见<a href="https://www.oracle.com/pls/topic/lookup?ctx=en/database/oracle/oracle-database/19/admin&amp;id=ADFNS1008" target="_blank"><span class="italic">“Oracle数据库开发指南</span></a>
                     </p>
                  </div>
                  <div class="familylinks">
                     <div class="parentlink">
                        <p><strong>父主题：</strong> <a href="managing-tables.html#GUID-707B02F5-E589-4C20-8E2E-5ED4F7888702" title="管理表包括创建表，加载表，更改表和删除表等任务。">管理表</a></p>
                     </div>
                  </div>
               </div>
               
            </div><a id="ADMIN01512"></a><div class="props_rev_3"><a id="GUID-14433799-D469-4A56-AAE4-089D3C3E1A5C" name="GUID-14433799-D469-4A56-AAE4-089D3C3E1A5C"></a><h3 id="ADMIN-GUID-14433799-D469-4A56-AAE4-089D3C3E1A5C" class="sect3"><span class="enumeration_section">20.10</span>使用Oracle闪回表恢复表</h3>
               <div>
                  <p>通过Oracle闪回表，您可以将表还原到以前某个时间点的状态。</p>
                  <p>它提供了一种快速的在线解决方案，用于恢复用户或应用程序意外修改或删除的表。在许多情况下，Oracle闪回表无需您执行更复杂的时间点恢复操作。<a id="d192334e17109" class="indexterm-anchor"></a></p>
                  <p>Oracle闪回表：</p>
                  <ul style="list-style-type:disc">
                     <li>
                        <p>将指定表中的所有数据还原到时间戳或SCN描述的先前时间点。</p>
                     </li>
                     <li>
                        <p>在线执行还原操作。</p>
                     </li>
                     <li>
                        <p>自动维护应用程序与闪回表一起运行所必需的所有表属性，例如索引，触发器和约束。</p>
                     </li>
                     <li>
                        <p>维护分布式环境中的任何远程状态。例如，如果复制的表被闪回，则复制所需的所有表修改。</p>
                     </li>
                     <li>
                        <p>维护约束指定的数据完整性。如果没有违反表约束，则闪回表。这包括通过包含在一个表之间指定的任何引用完整性约束<code class="codeph">FLASHBACK TABLE</code>语句并没有被包含在另一个表<code class="codeph">FLASHBACK TABLE</code>语句。
                        </p>
                     </li>
                     <li>
                        <p>即使在闪回操作之后，原始表中的数据也不会丢失。您可以稍后恢复到原始状态。</p>
                     </li>
                  </ul>
                  <div class="infoboxnote" id="GUID-14433799-D469-4A56-AAE4-089D3C3E1A5C__GUID-1E26D70B-1470-4464-980C-5DB0A3129B08">
                     <p class="notep1">注意：</p>
                     <p>您必须使用自动撤消管理才能使用Oracle闪回表。请参阅<span class="q">“ <a href="managing-undo.html#GUID-106B56C9-CB60-4E46-86A6-BF645E9E1A7F" title="Oracle数据库可以自动管理撤消信息和空间。">自动撤消管理简介</a> ”</span> 。
                     </p>
                  </div>
               </div>
               <div>
                  <div class="infoboxnotealso" id="GUID-14433799-D469-4A56-AAE4-089D3C3E1A5C__GUID-D449AC70-261D-43EC-A095-988D9BAFC50D">
                     <p class="notep1">也可以看看：</p>
                     <p>有关<code class="codeph">FLASHBACK TABLE</code>语句的详细信息，请<code class="codeph">FLASHBACK TABLE</code> <a href="https://www.oracle.com/pls/topic/lookup?ctx=en/database/oracle/oracle-database/19/admin&amp;id=BRADV81517" target="_blank"><span class="italic">“Oracle数据库备份和恢复用户指南”</span></a> 。
                     </p>
                  </div>
                  <div class="familylinks">
                     <div class="parentlink">
                        <p><strong>父主题：</strong> <a href="managing-tables.html#GUID-707B02F5-E589-4C20-8E2E-5ED4F7888702" title="管理表包括创建表，加载表，更改表和删除表等任务。">管理表</a></p>
                     </div>
                  </div>
               </div>
               
            </div><a id="ADMIN01505"></a><div class="props_rev_3"><a id="GUID-C35B192C-1C8B-425F-A003-D36D0EABEB3A" name="GUID-C35B192C-1C8B-425F-A003-D36D0EABEB3A"></a><h3 id="ADMIN-GUID-C35B192C-1C8B-425F-A003-D36D0EABEB3A" class="sect3"><span class="enumeration_section">20.11</span>删除表</h3>
               <div>
                  <p>要删除不再需要的表，请使用<code class="codeph">DROP TABLE</code>语句。
                  </p>
                  <p>该表必须包含在您的模式中，或者您必须具有<code class="codeph">DROP ANY TABLE</code>系统特权。
                  </p>
                  <div class="infoboxnote" id="GUID-C35B192C-1C8B-425F-A003-D36D0EABEB3A__GUID-29E210C2-ABE3-446A-86ED-A877255C99DE">
                     <p class="notep1">注意：</p>
                     <p>在放弃一张桌子之前，请熟悉这样做的后果：</p>
                     <ul style="list-style-type:disc">
                        <li>
                           <p>删除表将从数据字典中删除表定义。表格的所有行都不再可访问。</p>
                        </li>
                        <li>
                           <p>与表关联的所有索引和触发器都将被删除。</p>
                        </li>
                        <li>
                           <p>依赖于删除表的所有视图和PL / SQL程序单元仍然存在，但仍然无效（不可用）。有关数据库如何管理依赖关系的信息，请参阅<span class="q">“ <a href="managing-schema-objects.html#GUID-46D82F8E-C360-4223-B469-18039B1FFB21" title="Oracle数据库提供了一种自动机制，可确保从属对象始终与其引用的对象保持同步。您也可以手动重新编译无效对象。">管理对象依赖关系</a> ”</span> 。
                           </p>
                        </li>
                        <li>
                           <p>已删除表的所有同义词仍然存在，但在使用时会返回错误。</p>
                        </li>
                        <li>
                           <p>为删除的表分配的所有扩展区都将返回到表空间的可用空间，并且可供需要新扩展区或新对象的任何其他对象使用。从群集的块中删除与群集表对应的所有行。集群表是<a href="managing-clusters.html#GUID-2EB6D65C-3DD8-4C92-A8B4-C05197B6CF2D" title="使用群集可以提高性能并减少磁盘空间需求。">Managing Clusters</a>的主题。
                           </p>
                        </li>
                     </ul>
                  </div>
                  <p>以下语句删除了<code class="codeph">hr.int_admin_emp</code>表：</p><pre class="oac_no_warn" dir="ltr">DROP TABLE hr.int_admin_emp;</pre><p>如果要删除的表包含由其他表的外键引用的任何主键或唯一键，并且您打算删除子表的<code class="codeph">FOREIGN KEY</code>约束，则在<code class="codeph">DROP TABLE</code>语句中包含<code class="codeph">CASCADE</code>子句，如下所示：</p><pre class="oac_no_warn" dir="ltr">DROP TABLE hr.admin_emp CASCADE CONSTRAINTS;</pre><p>删除表时，通常数据库不会立即释放与表关联的空间。相反，数据库重命名表并将其放在回收站中，如果您发现错误地删除了表，则可以使用<code class="codeph">FLASHBACK</code> <code class="codeph">TABLE</code>语句在以后对其进行恢复。如果您希望在发出<code class="codeph">DROP TABLE</code>语句时立即释放与表关联的空间，请包含<code class="codeph">PURGE</code>子句，如以下语句所示：</p><pre class="oac_no_warn" dir="ltr">DROP TABLE hr.admin_emp PURGE;</pre><p>也许不是删除表，而是要截断它。<code class="codeph">TRUNCATE</code>语句提供了一种快速有效的方法来删除表中的所有行，但它不会影响与被截断的表（列定义，约束，触发器等）或授权相关联的任何结构。<code class="codeph">TRUNCATE</code>语句在<span class="q">“ <a href="managing-schema-objects.html#GUID-14D4966B-997B-4C26-9AD8-89EDF7B26F53" title="您可以删除表的所有行或一组聚簇表中的所有行，以便表（或群集）仍然存在，但是完全为空。例如，考虑一个包含月度数据的表，并且在每个月末，您必须在归档其数据后清空它（删除所有行）。">截断表和集群</a> ”中</span>讨论。
                  </p>
                  <div class="infoboxnote" id="GUID-C35B192C-1C8B-425F-A003-D36D0EABEB3A__GUID-C69FB35C-9EA1-444F-ABC9-473E0743A3F5">
                     <p class="notep1">实时SQL：</p>
                     <p>在Oracle Live SQL上查看并运行Oracle Live SQL的相关示例<a href="https://livesql.oracle.com/apex/livesql/docs/admin/managing-tables/create-modify.html" target="_blank"><span class="italic">：创建和修改表</span></a> 。
                     </p>
                  </div>
               </div>
               <div>
                  <div class="familylinks">
                     <div class="parentlink">
                        <p><strong>父主题：</strong> <a href="managing-tables.html#GUID-707B02F5-E589-4C20-8E2E-5ED4F7888702" title="管理表包括创建表，加载表，更改表和删除表等任务。">管理表</a></p>
                     </div>
                  </div>
               </div>
               
            </div><a id="ADMIN01511"></a><div class="props_rev_3"><a id="GUID-16E1CE4C-0189-4CF5-8047-F5039587D130" name="GUID-16E1CE4C-0189-4CF5-8047-F5039587D130"></a><h3 id="ADMIN-GUID-16E1CE4C-0189-4CF5-8047-F5039587D130" class="sect3"><span class="enumeration_section">20.12</span>使用闪回删除和管理回收站</h3>
               <div>
                  <p>删除表时，数据库不会立即删除与表关联的空间。数据库重命名表并将其和任何关联的对象放在回收站中，如果表被错误地删除，则可以在以后恢复。此功能称为闪回删除， <code class="codeph">FLASHBACK</code> <code class="codeph">TABLE</code>语句用于恢复表。
                  </p>
                  <p>在讨论为此目的使用<code class="codeph">FLASHBACK</code> <code class="codeph">TABLE</code>语句之前，了解回收站的工作原理以及如何管理其内容非常重要。
                  </p>
               </div>
               <div>
                  <ul class="ullinks">
                     <li class="ulchildlink"><a href="managing-tables.html#GUID-09C5BFE4-973F-4CB6-91BB-1BD2E27D9639">什么是回收站？</a><br>回收站实际上是一个数据字典表，其中包含有关已删除对象的信息。删除的表和任何关联的对象（如索引，约束，嵌套表等）不会被删除，仍占用空间。
                     </li>
                     <li class="ulchildlink"><a href="managing-tables.html#GUID-371BE1F5-5B21-4B88-B85E-BB9A773C9FA6">启用和禁用回收站</a><br>启用回收站后，已删除的表及其依赖对象将放置在回收站中。禁用回收站时，丢弃的表及其依赖对象<span class="italic">不会</span>放在回收站中;它们被删除，您必须使用其他方法来恢复它们（例如从备份中恢复）。
                     </li>
                     <li class="ulchildlink"><a href="managing-tables.html#GUID-119967AE-E205-44F6-AFDE-5AB56983B0E7">查看和查询回收站中的对象</a><br>Oracle数据库提供了两个视图，用于获取有关回收站中对象的信息。
                     </li>
                     <li class="ulchildlink"><a href="managing-tables.html#GUID-82E62BDB-E886-4EF9-943C-C62D632E499B">清除回收站中的对象</a><br>如果您决定永远不会从回收站还原项目，则可以使用<code class="codeph">PURGE</code>语句从回收站中删除项目及其关联对象并释放其存储空间。您需要与放弃项目时相同的权限。
                     </li>
                     <li class="ulchildlink"><a href="managing-tables.html#GUID-DA084A97-1D94-47D5-B8AE-FE449F8680E8">从回收站恢复表</a><br>使用<code class="codeph">FLASHBACK</code> <code class="codeph">TABLE</code> ...<code class="codeph">TO</code> <code class="codeph">BEFORE</code> <code class="codeph">DROP</code>语句从回收站中恢复对象。
                     </li>
                  </ul>
                  <div class="familylinks">
                     <div class="parentlink">
                        <p><strong>父主题：</strong> <a href="managing-tables.html#GUID-707B02F5-E589-4C20-8E2E-5ED4F7888702" title="管理表包括创建表，加载表，更改表和删除表等任务。">管理表</a></p>
                     </div>
                  </div>
               </div>
               <a id="ADMIN12640"></a><a id="ADMIN11679"></a><div class="props_rev_3"><a id="GUID-09C5BFE4-973F-4CB6-91BB-1BD2E27D9639" name="GUID-09C5BFE4-973F-4CB6-91BB-1BD2E27D9639"></a><h4 id="ADMIN-GUID-09C5BFE4-973F-4CB6-91BB-1BD2E27D9639" class="sect4"><span class="enumeration_section">20.12.1</span>什么是回收站？
                  </h4>
                  <div>
                     <p>回收站实际上是一个数据字典表，其中包含有关已删除对象的信息。删除的表和任何关联的对象（如索引，约束，嵌套表等）不会被删除，仍占用空间。</p>
                     <p>它们继续计入用户空间配额，直到从回收站中特别清除，或者由于表空间空间限制而必须由数据库清除它们的不太可能的情况。</p>
                     <p>可以将每个用户视为拥有自己的回收站，因为除非用户具有<code class="codeph">SYSDBA</code>权限，否则用户在回收站中可以访问的唯一对象是用户拥有的对象。用户可以使用以下语句在回收站中查看其对象：</p><pre class="oac_no_warn" dir="ltr">SELECT * FROM RECYCLEBIN;</pre><p>只有<code class="codeph">DROP</code> <code class="codeph">TABLE</code> SQL语句将对象放在回收站中。它添加了表及其关联对象，以便它们可以作为一个组进行恢复。除了表本身之外，添加到回收站的关联对象还可以包括以下类型的对象：</p>
                     <ul style="list-style-type:disc">
                        <li>
                           <p>嵌套表</p>
                        </li>
                        <li>
                           <p>LOB细分</p>
                        </li>
                        <li>
                           <p>索引</p>
                        </li>
                        <li>
                           <p>约束（不包括外键约束）</p>
                        </li>
                        <li>
                           <p>触发器</p>
                        </li>
                        <li>
                           <p>集群</p>
                        </li>
                     </ul>
                     <p>删除包含其内容的表空间时，表空间中的对象不会放在回收站中，并且数据库会清除回收站中位于表空间中的对象的所有条目。删除表空间时，数据库还会清除表空间中对象的任何回收站条目，不包括内容，否则表空间为空。同样：</p>
                     <ul style="list-style-type:disc">
                        <li>
                           <p>删除用户时，属于该用户的任何对象都不会放在回收站中，并且清除回收站中的所有对象。</p>
                        </li>
                        <li>
                           <p>删除群集时，其成员表不会放在回收站中，并且会清除回收站中的所有前成员表。</p>
                        </li>
                        <li>
                           <p>删除类型时，任何依赖对象（如子类型）都不会放在回收站中，并且清除回收站中的任何以前的依赖对象。</p>
                        </li>
                     </ul>
                     <div class="section">
                        <p class="subhead3" id="GUID-09C5BFE4-973F-4CB6-91BB-1BD2E27D9639__GUID-D286BADC-88F4-4126-8DAC-5C6DA1AB2684">回收站中的对象命名</p>
                     </div>
                     <!-- class="section" -->
                     <div class="section">
                        <p>当一个删除的表移动到<a id="d192334e17538" class="indexterm-anchor"></a>回收站，表及其关联对象被赋予系统生成的名称。这对于避免在多个表具有相同名称时可能出现的名称冲突是必要的。在以下情况下可能会发生这种情况：</p>
                        <ul style="list-style-type:disc">
                           <li>
                              <p>用户删除表，使用相同的名称重新创建它，然后再次删除它。</p>
                           </li>
                           <li>
                              <p>两个用户具有相同名称的表，并且两个用户都删除了他们的表。</p>
                           </li>
                        </ul>
                        <p>重命名约定如下：</p><pre class="oac_no_warn" dir="ltr">BIN $ <span class="italic"><code class="codeph">unique_id</code></span> $ <span class="italic"><code class="codeph">version</code></span>
</pre><p>哪里：</p>
                        <ul style="list-style-type:disc">
                           <li>
                              <p><span class="italic"><code class="codeph">unique_id</code></span>是此对象的26个字符的全局唯一标识符，这使得回收站名称在所有数据库中都是唯一的</p>
                           </li>
                           <li>
                              <p><span class="italic"><code class="codeph">version</code></span>是数据库分配的版本号</p>
                           </li>
                        </ul>
                     </div>
                     <!-- class="section" -->
                  </div>
                  <div>
                     <div class="familylinks">
                        <div class="parentlink">
                           <p><strong>父主题：</strong> <a href="managing-tables.html#GUID-16E1CE4C-0189-4CF5-8047-F5039587D130" title="删除表时，数据库不会立即删除与表关联的空间。数据库重命名表并将其和任何关联的对象放在回收站中，如果表被错误地删除，则可以在以后恢复。此功能称为闪回删除，FLASHBACK TABLE语句用于恢复表。">使用闪回删除和管理回收站</a></p>
                        </div>
                     </div>
                  </div>
                  
               </div><a id="ADMIN11680"></a><div class="props_rev_3"><a id="GUID-371BE1F5-5B21-4B88-B85E-BB9A773C9FA6" name="GUID-371BE1F5-5B21-4B88-B85E-BB9A773C9FA6"></a><h4 id="ADMIN-GUID-371BE1F5-5B21-4B88-B85E-BB9A773C9FA6" class="sect4"><span class="enumeration_section">20.12.2</span>启用和禁用回收站</h4>
                  <div>
                     <p>启用回收站后，已删除的表及其依赖对象将放置在回收站中。禁用回收站时，丢弃的表及其依赖对象<span class="italic">不会</span>放在回收站中;它们被删除，您必须使用其他方法来恢复它们（例如从备份中恢复）。
                     </p>
                     <div class="section">
                        <p>禁用回收站不会清除或以其他方式影响回收站中已有的对象。默认情况下启用回收站。</p>
                        <p>您可以通过更改<code class="codeph">recyclebin</code>初始化参数来启用和禁用回收站。此参数不是动态的，因此在使用<code class="codeph">ALTER</code> <code class="codeph">SYSTEM</code>语句更改数据库时需要重新启动数据库。
                        </p>
                        <p>要启用回收站：</p>
                        <ol>
                           <li>
                              <p>发出以下陈述之一：</p><pre class="oac_no_warn" dir="ltr">ALTER SESSION SET recyclebin = ON; ALTER SYSTEM SET recyclebin = ON SCOPE = SPFILE;</pre></li>
                           <li>
                              <p>如果您使用<code class="codeph">ALTER</code> <code class="codeph">SYSTEM</code> ，请重新启动数据库。
                              </p>
                           </li>
                        </ol>
                     </div>
                     <!-- class="section" -->
                     <div class="section">
                        <p>要禁用回收站：</p>
                        <ol>
                           <li>
                              <p>发出以下陈述之一：</p><pre class="oac_no_warn" dir="ltr">ALTER SESSION SET recyclebin = OFF; ALTER SYSTEM SET recyclebin = OFF SCOPE = SPFILE;</pre></li>
                           <li>
                              <p>如果您使用<code class="codeph">ALTER</code> <code class="codeph">SYSTEM</code> ，请重新启动数据库。
                              </p>
                           </li>
                        </ol>
                     </div>
                     <!-- class="section" -->
                  </div>
                  <div>
                     <div class="infoboxnotealso" id="GUID-371BE1F5-5B21-4B88-B85E-BB9A773C9FA6__GUID-327AC7B7-8642-442A-B0D6-7DB9E24695CD">
                        <p class="notep1">也可以看看：</p>
                        <p></p>
                        <ul style="list-style-type:disc">
                           <li>
                              <p><span class="q">“ <a href="creating-and-configuring-an-oracle-database.html#GUID-8BAD86FC-27C5-4103-8151-AC5BADF274E3" title="当Oracle实例启动时，它会从初始化参数文件中读取初始化参数。此文件必须至少指定DB_NAME参数。所有其他参数都具有默认值。">关于初始化参数和初始化参数文件</a> ”</span>有关初始化参数的更多信息</p>
                           </li>
                           <li>
                              <p><span class="q">“ <a href="creating-and-configuring-an-oracle-database.html#GUID-2DCF90DE-9F5C-48EA-9BE2-47FC2A7DFC30" title="您可以更改初始化参数值以影响数据库实例的操作。">更改初始化参数值</a> ”</span>以获取动态和静态初始化参数的说明</p>
                           </li>
                        </ul>
                     </div>
                     <div class="familylinks">
                        <div class="parentlink">
                           <p><strong>父主题：</strong> <a href="managing-tables.html#GUID-16E1CE4C-0189-4CF5-8047-F5039587D130" title="删除表时，数据库不会立即删除与表关联的空间。数据库重命名表并将其和任何关联的对象放在回收站中，如果表被错误地删除，则可以在以后恢复。此功能称为闪回删除，FLASHBACK TABLE语句用于恢复表。">使用闪回删除和管理回收站</a></p>
                        </div>
                     </div>
                  </div>
                  
               </div><a id="ADMIN11681"></a><div class="props_rev_3"><a id="GUID-119967AE-E205-44F6-AFDE-5AB56983B0E7" name="GUID-119967AE-E205-44F6-AFDE-5AB56983B0E7"></a><h4 id="ADMIN-GUID-119967AE-E205-44F6-AFDE-5AB56983B0E7" class="sect4"><span class="enumeration_section">20.12.3</span>查看和查询回收站中的对象</h4>
                  <div>
                     <p>Oracle数据库提供了两个视图，用于获取有关回收站中对象的信息。</p>
                     <div class="section">
                        <div class="tblformal" id="GUID-119967AE-E205-44F6-AFDE-5AB56983B0E7__GUID-2A825710-AFB9-4039-ABD4-3D5E72FCFBAB">
                           <table cellpadding="4" cellspacing="0" class="Formal" title="" width="100%" border="1" summary="Column 1 lists the views for obtaning information from the recycle bin, column 2 describes the view." frame="hsides" rules="rows">
                              <thead>
                                 <tr align="left" valign="top">
                                    <th align="left" valign="bottom" width="30%" id="d192334e17753">视图</th>
                                    <th align="left" valign="bottom" width="70%" id="d192334e17756">描述</th>
                                 </tr>
                              </thead>
                              <tbody>
                                 <tr align="left" valign="top">
                                    <td align="left" valign="top" width="30%" id="d192334e17761" headers="d192334e17753 ">
                                       <p><code class="codeph">USER_RECYCLEBIN</code> 
                                       </p>
                                    </td>
                                    <td align="left" valign="top" width="70%" headers="d192334e17761 d192334e17756 ">
                                       <p>用户可以使用此视图在回收站中查看自己的已删除对象。它有一个同义词<code class="codeph">RECYCLEBIN</code> ，易于使用。
                                       </p>
                                    </td>
                                 </tr>
                                 <tr align="left" valign="top">
                                    <td align="left" valign="top" width="30%" id="d192334e17773" headers="d192334e17753 ">
                                       <p><code class="codeph">DBA_RECYCLEBIN</code> 
                                       </p>
                                    </td>
                                    <td align="left" valign="top" width="70%" headers="d192334e17773 d192334e17756 ">
                                       <p>此视图使管理员可以看到回收站中所有已删除的对象</p>
                                    </td>
                                 </tr>
                              </tbody>
                           </table>
                        </div>
                        <!-- class="inftblhruleinformal" -->
                        <p>这些视图的一个用途是标识数据库已分配给已删除对象的名称，如以下示例所示：</p><pre class="oac_no_warn" dir="ltr">SELECT object_name，original_name FROM dba_recyclebin WHERE owner ='HR'; OBJECT_NAME ORIGINAL_NAME ------------------------------ ------------------ -------------- BIN $ yrMKlZaLMhfgNAgAIMenRA == $ 0员工</pre><p>您还可以使用SQL * Plus命令<code class="codeph">SHOW RECYCLEBIN</code>查看回收站的内容。</p><pre class="oac_no_warn" dir="ltr">SQL&gt; show recyclebin ORIGINAL NAME RECYCLEBIN NAME OBJECT TYPE DROP TIME ---------------- ---------------------- -------- ------------ ------------------- EMPLOYEES BIN $ yrMKlZaVMhfgNAgAIMenRA == $ 0 TABLE 2003-10 -27：14：00：19</pre><p>您可以查询回收站中的对象，就像查询其他对象一样。但是，您必须指定在回收站中标识的对象的名称。例如：</p><pre class="oac_no_warn" dir="ltr">SELECT * FROM“BIN $ yrMKlZaVMhfgNAgAIMenRA == $ 0”;</pre></div>
                     <!-- class="section" -->
                  </div>
                  <div>
                     <div class="familylinks">
                        <div class="parentlink">
                           <p><strong>父主题：</strong> <a href="managing-tables.html#GUID-16E1CE4C-0189-4CF5-8047-F5039587D130" title="删除表时，数据库不会立即删除与表关联的空间。数据库重命名表并将其和任何关联的对象放在回收站中，如果表被错误地删除，则可以在以后恢复。此功能称为闪回删除，FLASHBACK TABLE语句用于恢复表。">使用闪回删除和管理回收站</a></p>
                        </div>
                     </div>
                  </div>
                  
               </div><a id="ADMIN11682"></a><div class="props_rev_3"><a id="GUID-82E62BDB-E886-4EF9-943C-C62D632E499B" name="GUID-82E62BDB-E886-4EF9-943C-C62D632E499B"></a><h4 id="ADMIN-GUID-82E62BDB-E886-4EF9-943C-C62D632E499B" class="sect4"><span class="enumeration_section">20.12.4</span>清除回收站中的对象</h4>
                  <div>
                     <p>如果您决定永远不会从回收站还原项目，则可以使用<code class="codeph">PURGE</code>语句从回收站中删除项目及其关联对象并释放其存储空间。您需要与放弃项目时相同的权限。
                     </p>
                     <div class="section">
                        <p>使用<code class="codeph">PURGE</code>语句清除表时，可以使用回收站中已知表的名称或表的原始名称。可以从<code class="codeph">DBA_</code>或<code class="codeph">USER_RECYCLEBIN</code>视图获取回收站名称，如<span class="q">“ <a href="managing-tables.html#GUID-119967AE-E205-44F6-AFDE-5AB56983B0E7" title="Oracle数据库提供了两个视图，用于获取有关回收站中对象的信息。">查看和查询回收站中的对象</a> ”中所示</span> 。下面的假设示例清除了表<code class="codeph">hr.int_admin_emp</code> ，当它放在回收站中时，它被重命名为<code class="codeph">BIN$jsleilx392mk2=293$0</code> ：</p><pre class="oac_no_warn" dir="ltr">PURGE TABLE“BIN $ jsleilx392mk2 = 293 $ 0”;</pre><p>您可以使用以下语句获得相同的结果：</p><pre class="oac_no_warn" dir="ltr">PURGE TABLE int_admin_emp;</pre><p>您可以使用<code class="codeph">PURGE</code>语句清除回收站中来自指定表空间的所有对象，或仅清除属于指定用户的表空间对象，如以下示例所示：</p><pre class="oac_no_warn" dir="ltr">PURGE TABLESPACE示例; PURGE TABLESPACE示例USER oe;</pre><p>用户可以使用以下语句清除自己对象的回收站，并释放对象空间：</p><pre class="oac_no_warn" dir="ltr">PURGE RECYCLEBIN;</pre><p>如果您具有<code class="codeph">SYSDBA</code>权限或<code class="codeph">PURGE</code> <code class="codeph">DBA_RECYCLEBIN</code>系统特权，则可以通过在前一个语句中指定<code class="codeph">DBA_RECYCLEBIN</code>而不是<code class="codeph">RECYCLEBIN</code>来清除整个回收站。
                        </p>
                        <p>您还可以使用<code class="codeph">PURGE</code>语句从回收站中清除索引，或者从回收站中清除指定表空间中的所有对象。
                        </p>
                     </div>
                     <!-- class="section" -->
                  </div>
                  <div>
                     <div class="infoboxnotealso" id="GUID-82E62BDB-E886-4EF9-943C-C62D632E499B__GUID-BE031A1D-0CFD-4B7D-91C8-69F0ABE254F0">
                        <p class="notep1">也可以看看：</p>
                        <p>有关<code class="codeph">PURGE</code>语句的更多信息，请<a href="https://www.oracle.com/pls/topic/lookup?ctx=en/database/oracle/oracle-database/19/admin&amp;id=SQLRF01803" target="_blank"><span class="italic">参见Oracle数据库SQL语言参考</span></a></p>
                     </div>
                     <div class="familylinks">
                        <div class="parentlink">
                           <p><strong>父主题：</strong> <a href="managing-tables.html#GUID-16E1CE4C-0189-4CF5-8047-F5039587D130" title="删除表时，数据库不会立即删除与表关联的空间。数据库重命名表并将其和任何关联的对象放在回收站中，如果表被错误地删除，则可以在以后恢复。此功能称为闪回删除，FLASHBACK TABLE语句用于恢复表。">使用闪回删除和管理回收站</a></p>
                        </div>
                     </div>
                  </div>
                  
               </div><a id="ADMIN12641"></a><a id="ADMIN11683"></a><div class="props_rev_3"><a id="GUID-DA084A97-1D94-47D5-B8AE-FE449F8680E8" name="GUID-DA084A97-1D94-47D5-B8AE-FE449F8680E8"></a><h4 id="ADMIN-GUID-DA084A97-1D94-47D5-B8AE-FE449F8680E8" class="sect4"><span class="enumeration_section">20.12.5</span>从回收站恢复表</h4>
                  <div>
                     <p>使用<code class="codeph">FLASHBACK</code> <code class="codeph">TABLE</code> ...<code class="codeph">TO</code> <code class="codeph">BEFORE</code> <code class="codeph">DROP</code>语句从回收站中恢复对象。
                     </p>
                     <div class="section">
                        <p>您可以指定回收站中表的名称或原始表名。可选的<code class="codeph">RENAME TO</code>子句允许您在恢复时重命名该表。可以从<code class="codeph">DBA_</code>或<code class="codeph">USER_RECYCLEBIN</code>视图获取回收站名称，如<span class="q">“ <a href="managing-tables.html#GUID-119967AE-E205-44F6-AFDE-5AB56983B0E7" title="Oracle数据库提供了两个视图，用于获取有关回收站中对象的信息。">查看和查询回收站中的对象</a> ”中所示</span> 。要使用<code class="codeph">FLASHBACK</code> <code class="codeph">TABLE</code> ......<code class="codeph">TO</code> <code class="codeph">BEFORE</code> <code class="codeph">DROP</code>语句<code class="codeph">BEFORE</code> ，您需要具有删除表所需的相同权限。
                        </p>
                        <p>以下示例恢复<code class="codeph">int_admin_emp</code>表并为其分配新名称：</p><pre class="oac_no_warn" dir="ltr">FLASHBACK TABLE int_admin_emp在DROP重命名为int2_admin_emp之前;</pre><p>如果多次删除表，则系统生成的回收站名称非常有用。例如，假设您在回收站中有三个版本的<code class="codeph">int2_admin_emp</code>表，并且您希望恢复第二个版本。您可以通过发出两个<code class="codeph">FLASHBACK TABLE</code>语句来执行此操作，也可以查询回收站，然后闪回到相应的系统生成的名称，如以下示例所示。在查询中包含创建时间可以帮助您验证是否正在还原正确的表。
                        </p><pre class="oac_no_warn" dir="ltr">SELECT object_name，original_name，createtime FROM recyclebin; OBJECT_NAME ORIGINAL_NAME CREATETIME ------------------------------ ---------------  - ----------------- BIN $ yrMKlZaLMhfgNAgAIMenRA == $ 0 INT2_ADMIN_EMP 2006-02-05：21：05：52 BIN $ yrMKlZaVMhfgNAgAIMenRA == $ 0 INT2_ADMIN_EMP 2006-02-05：21： 25:13 BIN $ yrMKlZaQMhfgNAgAIMenRA == $ 0 INT2_ADMIN_EMP 2006-02-05：22：05：53 FLASHBACK TABLE“BIN $ yrMKlZaVMhfgNAgAIMenRA == $ 0”在DROP之前;</pre></div>
                     <!-- class="section" -->
                     <div class="section">
                        <p class="subhead3" id="GUID-DA084A97-1D94-47D5-B8AE-FE449F8680E8__GUID-9CA8BA4D-238D-4416-8A9C-315FF10BF14A">恢复从属对象</p>
                     </div>
                     <!-- class="section" -->
                     <div class="section">
                        <p>从回收站还原表时，索引等依赖对象不会返回其原始名称;他们保留了系统生成的回收站名称。您必须手动重命名依赖对象才能还原其原始名称。如果计划手动还原从属对象的原始名称，请确保<span class="italic">在</span>还原表<span class="italic">之前</span>记下每个依赖对象的系统生成的回收站名称。
                        </p>
                        <p>以下是从<code class="codeph">HR</code>示例模式还原已删除表<code class="codeph">JOB_HISTORY</code>的某些索引的原始名称的示例。该示例假定您以<code class="codeph">HR</code>用户身份登录。
                        </p>
                     </div>
                     <!-- class="section" -->
                     <ol>
                        <li class="stepexpand"><span>删除<code class="codeph">JOB_HISTORY</code> ，在从回收站恢复之前，请运行以下查询：</span><div><pre class="oac_no_warn" dir="ltr">SELECT OBJECT_NAME，ORIGINAL_NAME，TYPE FROM RECYCLEBIN; OBJECT_NAME ORIGINAL_NAME TYPE ------------------------------ ----------------- -------- BIN $ DBo9UChtZSbgQFeMiAdCcQ == $ 0 JHIST_JOB_IX INDEX BIN $ DBo9UChuZSbgQFeMiAdCcQ == $ 0 JHIST_EMPLOYEE_IX INDEX BIN $ DBo9UChvZSbgQFeMiAdCcQ == $ 0 JHIST_DEPARTMENT_IX INDEX BIN $ DBo9UChwZSbgQFeMiAdCcQ == $ 0 JHIST_EMP_ID_ST_DATE_PK INDEX BIN $ DBo9UChxZSbgQFeMiAdCcQ == $ 0 JOB_HISTORY表</pre></div>
                        </li>
                        <li class="stepexpand"><span>使用以下命令恢复表：</span><div><pre class="oac_no_warn" dir="ltr">FLASHBACK TABLE JOB_HISTORY在DROP之前;</pre></div>
                        </li>
                        <li class="stepexpand"><span>运行以下查询以验证所有<code class="codeph">JOB_HISTORY</code>索引是否保留其系统生成的回收站名称：</span><div><pre class="oac_no_warn" dir="ltr">SELECT INDEX_NAME FROM USER_INDEXES WHERE TABLE_NAME ='JOB_HISTORY'; INDEX_NAME ------------------------------ BIN $ DBo9UChwZSbgQFeMiAdCcQ == $ 0 BIN $ DBo9UChtZSbgQFeMiAdCcQ == $ 0 BIN $ DBo9UChuZSbgQFeMiAdCcQ == $ 0 BIN $ DBo9UChvZSbgQFeMiAdCcQ == $ 0</pre></div>
                        </li>
                        <li class="stepexpand"><span>恢复前两个索引的原始名称，如下所示：</span><div><pre class="oac_no_warn" dir="ltr">ALTER INDEX“BIN $ DBo9UChtZSbgQFeMiAdCcQ == $ 0”重命名为JHIST_JOB_IX; ALTER INDEX“BIN $ DBo9UChuZSbgQFeMiAdCcQ == $ 0”重播给JHIST_EMPLOYEE_IX;</pre><p>请注意，系统生成的名称周围需要双引号。</p>
                           </div>
                        </li>
                     </ol>
                  </div>
                  <div>
                     <div class="familylinks">
                        <div class="parentlink">
                           <p><strong>父主题：</strong> <a href="managing-tables.html#GUID-16E1CE4C-0189-4CF5-8047-F5039587D130" title="删除表时，数据库不会立即删除与表关联的空间。数据库重命名表并将其和任何关联的对象放在回收站中，如果表被错误地删除，则可以在以后恢复。此功能称为闪回删除，FLASHBACK TABLE语句用于恢复表。">使用闪回删除和管理回收站</a></p>
                        </div>
                     </div>
                  </div>
                  
               </div>
            </div><a id="ADMIN01506"></a><div class="props_rev_3"><a id="GUID-D9BCA9BF-EAA8-431D-BDBB-ED5B3C59C5E4" name="GUID-D9BCA9BF-EAA8-431D-BDBB-ED5B3C59C5E4"></a><h3 id="ADMIN-GUID-D9BCA9BF-EAA8-431D-BDBB-ED5B3C59C5E4" class="sect3"><span class="enumeration_section">20.13</span>管理索引组织表</h3>
               <p>索引组织表的存储组织是主B树索引的变体。与堆组织表不同，数据以主键顺序存储。</p>
               <div>
                  <ul class="ullinks">
                     <li class="ulchildlink"><a href="managing-tables.html#GUID-26B31531-E4EF-44B1-9193-415E69F7E65C">什么是索引组织表？</a><br><span class="bold">索引组织表</span>具有存储组织，该组织是主B树的变体。与将数据存储为无序集合（堆）的普通（堆组织）表不同，索引组织表的数据以主键排序方式存储在B树索引结构中。索引结构中的每个叶块都存储键和非键列。
                     </li>
                     <li class="ulchildlink"><a href="managing-tables.html#GUID-F3965F25-01CD-464C-B065-025442A6C43F">创建索引组织表</a><br>索引组织表提供快速主键访问和高可用性。
                     </li>
                     <li class="ulchildlink"><a href="managing-tables.html#GUID-4E51E139-9352-4F95-93FE-7CB626646308">维护索引组织表</a><br>索引组织表与仅在物理组织中的普通表不同。从逻辑上讲，它们的处理方式与普通表相同。您可以像在<code class="codeph">INSERT</code> ， <code class="codeph">SELECT</code> ， <code class="codeph">DELETE</code>和<code class="codeph">UPDATE</code>语句中指定常规表一样指定索引组织表。
                     </li>
                     <li class="ulchildlink"><a href="managing-tables.html#GUID-F0DA4974-0FC7-4227-873D-A5D7156D68D6">在索引组织表上创建辅助索引</a><br>辅助索引是索引组织表的索引。辅助索引是一个独立的模式对象，与索引组织表分开存储。
                     </li>
                     <li class="ulchildlink"><a href="managing-tables.html#GUID-3FDB4F70-4DD9-47BF-811B-F5CA0F168832">分析索引组织表</a><br>与普通表一样，使用<code class="codeph">DBMS_STATS</code>包或<code class="codeph">ANALYZE</code>语句分析索引组织表。
                     </li>
                     <li class="ulchildlink"><a href="managing-tables.html#GUID-9118B891-326A-4579-9BBD-A3A6DDF4016A">将ORDER BY子句与索引组织表一起使用</a><br>如果<code class="codeph">ORDER BY</code>子句仅引用主键列或其前缀，则优化程序会避免排序开销，因为返回的行按主键列排序。
                     </li>
                     <li class="ulchildlink"><a href="managing-tables.html#GUID-43FB7062-D7FE-4E29-9199-5ACDE7799958">将索引组织表转换为常规表</a><br>您可以使用Oracle导入或导出实用程序或<code class="codeph">CREATE TABLE...将索引组织表转换为常规（堆组织） <code class="codeph">CREATE TABLE...AS SELECT</code>语句。
                     </li>
                  </ul>
                  <div class="familylinks">
                     <div class="parentlink">
                        <p><strong>父主题：</strong> <a href="managing-tables.html#GUID-707B02F5-E589-4C20-8E2E-5ED4F7888702" title="管理表包括创建表，加载表，更改表和删除表等任务。">管理表</a></p>
                     </div>
                  </div>
               </div>
               <a id="ADMIN11684"></a><div class="props_rev_3"><a id="GUID-26B31531-E4EF-44B1-9193-415E69F7E65C" name="GUID-26B31531-E4EF-44B1-9193-415E69F7E65C"></a><h4 id="ADMIN-GUID-26B31531-E4EF-44B1-9193-415E69F7E65C" class="sect4"><span class="enumeration_section">20.13.1</span>什么是索引组织表？
                  </h4>
                  <div>
                     <p><span class="bold">索引组织表</span>具有存储组织，该组织是主B树的变体。与将数据存储为无序集合（堆）的普通（堆组织）表不同，索引组织表的数据以主键排序方式存储在B树索引结构中。索引结构中的每个叶块都存储键和非键列。
                     </p>
                     <p>索引组织表的结构具有以下优点：</p>
                     <ul style="list-style-type:disc">
                        <li>
                           <p>主键上的快速随机访问，因为仅索引扫描就足够了。并且，由于没有单独的表存储区域，因此对表数据的更改（例如添加新行，更新行或删除行）仅导致更新索引结构。</p>
                        </li>
                        <li>
                           <p>主键上的快速范围访问，因为行按主键顺序聚类。</p>
                        </li>
                        <li>
                           <p>降低存储要求，因为避免了主键的重复。它们不存储在索引和基础表中，就像堆组织表一样。</p>
                        </li>
                     </ul>
                     <p>索引组织表具有全表功能。它们支持约束，触发器，LOB和对象列，分区，并行操作，联机重组和复制等功能。并且，它们提供以下附加功能：</p>
                     <ul style="list-style-type:disc">
                        <li>
                           <p>前缀压缩</p>
                        </li>
                        <li>
                           <p>溢出存储区域和特定列放置</p>
                        </li>
                        <li>
                           <p>辅助索引，包括位图索引。</p>
                        </li>
                     </ul>
                     <p>索引组织表非常适合OLTP应用程序，这需要快速的主键访问和高可用性。例如，在电子订单处理中使用的订单表上的查询和DML主要基于主键访问，并且大量并发DML可能导致行链接和索引中的低效空间使用，导致经常需要重新组织。由于可以在线重组索引组织表而不会使其二级索引无效，因此大大减少或消除了不可用窗口。</p>
                     <p>索引组织表适用于为特定于应用程序的索引结构建模。例如，包含文本，图像和音频数据的基于内容的信息检索应用程序需要可以使用索引组织表有效建模的反向索引。互联网搜索引擎的一个基本组成部分是反向索引，可以使用索引组织表进行建模。</p>
                     <p>这些只是索引组织表的一些应用程序。</p>
                  </div>
                  <div>
                     <div class="infoboxnotealso" id="GUID-26B31531-E4EF-44B1-9193-415E69F7E65C__GUID-9AF95098-7D2F-4FBC-94E6-830030C824C5">
                        <p class="notep1">也可以看看：</p>
                        <p></p>
                        <ul style="list-style-type:disc">
                           <li>
                              <p><a href="https://www.oracle.com/pls/topic/lookup?ctx=en/database/oracle/oracle-database/19/admin&amp;id=CNCPT911" target="_blank"><span class="italic">Oracle Database Concepts，</span></a>用于更全面地描述索引组织表</p>
                           </li>
                           <li>
                              <p>有关分区索引组织表的信息<a href="https://www.oracle.com/pls/topic/lookup?ctx=en/database/oracle/oracle-database/19/admin&amp;id=VLDBG1112" target="_blank"><span class="italic">，请参见“Oracle数据库VLDB和分区指南”</span></a></p>
                           </li>
                        </ul>
                     </div>
                     <div class="familylinks">
                        <div class="parentlink">
                           <p><strong>父主题：</strong> <a href="managing-tables.html#GUID-D9BCA9BF-EAA8-431D-BDBB-ED5B3C59C5E4" title="索引组织表的存储组织是主B树索引的变体。与堆组织表不同，数据以主键顺序存储。">管理索引组织表</a></p>
                        </div>
                     </div>
                  </div>
                  
               </div>
               <div class="sect3"><a id="GUID-F3965F25-01CD-464C-B065-025442A6C43F" name="GUID-F3965F25-01CD-464C-B065-025442A6C43F"></a><h4 id="ADMIN-GUID-F3965F25-01CD-464C-B065-025442A6C43F" class="sect4"><span class="enumeration_section">20.13.2</span>创建索引组织表</h4>
                  <p>索引组织表提供快速主键访问和高可用性。</p>
                  <div>
                     <ul class="ullinks">
                        <li class="ulchildlink"><a href="managing-tables.html#GUID-D2166A16-09C6-43DC-8299-D805AC6C2DE8">关于创建索引组织表</a><br>您可以使用<code class="codeph">CREATE TABLE</code>语句创建索引组织表。
                        </li>
                        <li class="ulchildlink"><a href="managing-tables.html#GUID-D7BF95BE-7587-4273-86BC-560096B584FC">示例：创建索引组织表</a><br>一个示例说明了创建索引组织表。
                        </li>
                        <li class="ulchildlink"><a href="managing-tables.html#GUID-B75C00F7-241C-423B-A68A-1D587FD9D825">索引组织表的限制</a><br>创建索引组织表时，有几个限制。
                        </li>
                        <li class="ulchildlink"><a href="managing-tables.html#GUID-8458007A-6B9F-4146-AC1A-704EB57F0DE2">创建包含对象类型的索引组织表</a><br>索引组织表可以存储对象类型。
                        </li>
                        <li class="ulchildlink"><a href="managing-tables.html#GUID-E60A24D9-3DC0-4E0F-9B65-7B348560D2DC">选择和监控阈值</a><br>选择一个可容纳关键列的阈值，以及前几个非关键列（如果经常访问它们）。
                        </li>
                        <li class="ulchildlink"><a href="managing-tables.html#GUID-2EA88382-8D2D-4E2F-8E89-0DBE2DB4B5CC">使用INCLUDING条款</a><br>除了指定<code class="codeph">PCTTHRESHOLD</code> ，还可以使用<code class="codeph">INCLUDING</code>子句来控制与索引组织表中的键列一起存储的非键列。
                        </li>
                        <li class="ulchildlink"><a href="managing-tables.html#GUID-7E30807C-A239-4ACE-917D-F658103A7F39">并行化索引组织表创建</a><br><code class="codeph">CREATE TABLE...AS SELECT</code>语句可以创建索引组织表并将现有表中的数据加载到其中。通过包含<code class="codeph">PARALLEL</code>子句，可以并行完成加载。
                        </li>
                        <li class="ulchildlink"><a href="managing-tables.html#GUID-D4D9F29D-461C-4394-B082-4FB59C89866F">使用前缀压缩</a><br>使用前缀压缩（也称为密钥压缩）创建索引组织表可以消除重复出现的键列前缀值。
                        </li>
                     </ul>
                     <div class="familylinks">
                        <div class="parentlink">
                           <p><strong>父主题：</strong> <a href="managing-tables.html#GUID-D9BCA9BF-EAA8-431D-BDBB-ED5B3C59C5E4" title="索引组织表的存储组织是主B树索引的变体。与堆组织表不同，数据以主键顺序存储。">管理索引组织表</a></p>
                        </div>
                     </div>
                  </div>
                  <a id="ADMIN11685"></a><div class="props_rev_3"><a id="GUID-D2166A16-09C6-43DC-8299-D805AC6C2DE8" name="GUID-D2166A16-09C6-43DC-8299-D805AC6C2DE8"></a><h5 id="ADMIN-GUID-D2166A16-09C6-43DC-8299-D805AC6C2DE8" class="sect5"><span class="enumeration_section">20.13.2.1</span>关于创建索引组织表</h5>
                     <div>
                        <p>您可以使用<code class="codeph">CREATE TABLE</code>语句创建索引组织表。
                        </p>
                        <p>创建索引组织表时，必须提供其他信息：</p>
                        <ul style="list-style-type:disc">
                           <li>
                              <p><code class="codeph">ORGANIZATION INDEX</code>限定符，表示这是一个索引组织表</p>
                           </li>
                           <li>
                              <p>通过列约束子句（对于单列主键）或表约束子句（对于多列主键）指定的主键。</p>
                           </li>
                        </ul>
                        <p>（可选）您可以指定以下内容：</p>
                        <ul style="list-style-type:disc">
                           <li>
                              <p>一个<code class="codeph">OVERFLOW</code>子句，它通过在一个单独的溢出数据段中存储一些非键列来保留B树索引的密集聚类。
                              </p>
                           </li>
                           <li>
                              <p><code class="codeph">PCTTHRESHOLD</code>值，当使用溢出段时，它定义存储在索引块中的行部分的最大大小，以块大小的百分比表示。导致行大小超过此最大值的行列存储在溢出段中。该行在列边界处被分成两个部分，即头部和尾部。头部件符合指定的阈值，并与密钥一起存储在索引叶块中。尾件作为一个或多个行件存储在溢流区域中。因此，索引条目包含键值，符合指定阈值的非键列值以及指向行其余部分的指针。
                              </p>
                           </li>
                           <li>
                              <p><code class="codeph">INCLUDING</code>子句，可用于指定要使用主键存储在索引块中的非键列。
                              </p>
                           </li>
                        </ul>
                     </div>
                     <div>
                        <div class="familylinks">
                           <div class="parentlink">
                              <p><strong>父主题：</strong> <a href="managing-tables.html#GUID-F3965F25-01CD-464C-B065-025442A6C43F" title="索引组织表提供快速主键访问和高可用性。">创建索引组织表</a></p>
                           </div>
                        </div>
                     </div>
                     
                  </div><a id="ADMIN11686"></a><div class="props_rev_3"><a id="GUID-D7BF95BE-7587-4273-86BC-560096B584FC" name="GUID-D7BF95BE-7587-4273-86BC-560096B584FC"></a><h5 id="ADMIN-GUID-D7BF95BE-7587-4273-86BC-560096B584FC" class="sect5"><span class="enumeration_section">20.13.2.2</span>示例：创建索引组织表</h5>
                     <div>
                        <p>一个示例说明了创建索引组织表。</p>
                        <div class="section">
                           <p>以下语句创建一个索引组织表：</p><pre class="oac_no_warn" dir="ltr">CREATE TABLE admin_docindex（token char（20），doc_id NUMBER，token_frequency NUMBER，token_offsets VARCHAR2（2000），CONSTRAINT pk_admin_docindex PRIMARY KEY（token，doc_id））ORGANIZATION INDEX TABLESPACE admin_tbs PCTTHRESHOLD 20 OVERFLOW TABLESPACE admin_tbs2;</pre><p>此示例创建一个名为<code class="codeph">admin_docindex</code>的索引组织表，其中主键由列<code class="codeph">token</code>和<code class="codeph">doc_id</code> 。<code class="codeph">OVERFLOW</code>和<code class="codeph">PCTTHRESHOLD</code>子句指定如果行的长度超过索引块大小的20％，则超过该阈值的列以及其后的所有列将移动到溢出段。溢出段存储在<code class="codeph">admin_tbs2</code>表空间中。
                           </p>
                        </div>
                        <!-- class="section" -->
                     </div>
                     <div>
                        <div class="infoboxnotealso" id="GUID-D7BF95BE-7587-4273-86BC-560096B584FC__GUID-6B84DC85-9C45-4FA9-8780-571CF9C66E71">
                           <p class="notep1">也可以看看：</p>
                           <p>有关创建索引组织表的语法的详细信息，请<a href="https://www.oracle.com/pls/topic/lookup?ctx=en/database/oracle/oracle-database/19/admin&amp;id=SQLRF01402" target="_blank"><span class="italic">参见Oracle数据库SQL语言参考</span></a></p>
                        </div>
                        <div class="familylinks">
                           <div class="parentlink">
                              <p><strong>父主题：</strong> <a href="managing-tables.html#GUID-F3965F25-01CD-464C-B065-025442A6C43F" title="索引组织表提供快速主键访问和高可用性。">创建索引组织表</a></p>
                           </div>
                        </div>
                     </div>
                     
                  </div><a id="ADMIN12496"></a><div class="props_rev_3"><a id="GUID-B75C00F7-241C-423B-A68A-1D587FD9D825" name="GUID-B75C00F7-241C-423B-A68A-1D587FD9D825"></a><h5 id="ADMIN-GUID-B75C00F7-241C-423B-A68A-1D587FD9D825" class="sect5"><span class="enumeration_section">20.13.2.3</span>索引组织表的限制</h5>
                     <div>
                        <p>创建索引组织表时，有几个限制。</p>
                        <p>以下是创建索引组织表的限制。</p>
                        <ul style="list-style-type:disc">
                           <li>
                              <p>最大列数为1000。</p>
                           </li>
                           <li>
                              <p>行的索引部分中的最大列数为255，包括键和非键列。如果需要超过255列，则必须使用溢出段。</p>
                           </li>
                           <li>
                              <p>您可以包含在主键中的最大列数为32。</p>
                           </li>
                           <li>
                              <p><code class="codeph">PCTTHRESHOLD</code>必须在1-50范围内。默认值为50。
                              </p>
                           </li>
                           <li>
                              <p>所有键列都必须符合指定的阈值。</p>
                           </li>
                           <li>
                              <p>如果行的最大大小超过索引块大小的50％，并且未指定溢出段，则<code class="codeph">CREATE</code> <code class="codeph">TABLE</code>语句将失败。
                              </p>
                           </li>
                           <li>
                              <p>索引组织表不能包含虚拟列。</p>
                           </li>
                           <li>
                              <p>当表具有外键，并且外键的父级是索引组织表时，更新包含外键的行的会话可以在另一个会话更新父表中的非键列时挂起。</p>
                              <p>例如，考虑一种情况，其中<code class="codeph">departments</code>表是索引组织表， <code class="codeph">department_id</code>是其主键。有一个<code class="codeph">employees</code>表，其<code class="codeph">department_id</code>列是<code class="codeph">departments</code>表的外键。假设一个会话更新<code class="codeph">department_name</code>在连续<code class="codeph">departments</code>表，该<code class="codeph">department_id</code>是<code class="codeph">20</code> ，而另一个会话正在更新的行<code class="codeph">employees</code>表，该<code class="codeph">department_id</code>为<code class="codeph">20</code> 。在这种情况下，更新<code class="codeph">employees</code>表的会话可以挂起，直到更新<code class="codeph">departments</code>表的会话提交或回滚。
                              </p>
                           </li>
                        </ul>
                     </div>
                     <div>
                        <div class="familylinks">
                           <div class="parentlink">
                              <p><strong>父主题：</strong> <a href="managing-tables.html#GUID-F3965F25-01CD-464C-B065-025442A6C43F" title="索引组织表提供快速主键访问和高可用性。">创建索引组织表</a></p>
                           </div>
                        </div>
                     </div>
                     
                  </div><a id="ADMIN11687"></a><div class="props_rev_3"><a id="GUID-8458007A-6B9F-4146-AC1A-704EB57F0DE2" name="GUID-8458007A-6B9F-4146-AC1A-704EB57F0DE2"></a><h5 id="ADMIN-GUID-8458007A-6B9F-4146-AC1A-704EB57F0DE2" class="sect5"><span class="enumeration_section">20.13.2.4</span>创建包含对象类型的索引组织表</h5>
                     <div>
                        <p>索引组织表可以存储对象类型。</p>
                        <div class="section">
                           <p>以下示例创建对象类型<code class="codeph">admin_typ</code> ，然后创建包含对象类型<code class="codeph">admin_typ</code>列的索引组织表：</p><pre class="oac_no_warn" dir="ltr">创建或替换类型admin_typ AS OBJECT（col1 NUMBER，col2 VARCHAR2（6））; CREATE TABLE admin_iot（c1 NUMBER主键，c2 admin_typ）组织索引;</pre><p>您还可以创建索引组织的对象类型表。例如：</p><pre class="oac_no_warn" dir="ltr">CREATE TABLE admin_iot2 OF admin_typ（col1 PRIMARY KEY）组织索引;</pre><p>下面的另一个示例显示，索引组织表有效地存储嵌套表。对于嵌套表列，数据库在内部创建一个存储表来保存所有嵌套表行。</p><pre class="oac_no_warn" dir="ltr">CREATE TYPE project_t AS OBJECT（pno NUMBER，pname VARCHAR2（80））; / CREATE TYPE project_set AS TABLE OF project_t; / CREATE TABLE proj_tab（eno NUMBER，项目PROJECT_SET）NESTED TABLE项目STORE AS emp_project_tab（（PRIMARY KEY（nested_table_id，pno））ORGANIZATION INDEX）返回定位器;</pre><p>属于单个嵌套表实例的行由<code class="codeph">nested_table_id</code>列标识。如果使用普通表来存储嵌套表列，则嵌套表行通常会被解除群集。但是，当您使用索引组织表时，可以基于<code class="codeph">nested_table_id</code>列对嵌套表行进行聚类。
                           </p>
                        </div>
                        <!-- class="section" -->
                     </div>
                     <div>
                        <div class="infoboxnotealso" id="GUID-8458007A-6B9F-4146-AC1A-704EB57F0DE2__GUID-8ED0D93A-6B97-473A-90B5-CE8F04F0D6E7">
                           <p class="notep1">也可以看看：</p>
                           <p></p>
                           <ul style="list-style-type:disc">
                              <li>
                                 <p>有关用于创建索引组织表的语法的详细信息，请<a href="https://www.oracle.com/pls/topic/lookup?ctx=en/database/oracle/oracle-database/19/admin&amp;id=SQLRF01402" target="_blank"><span class="italic">参见Oracle数据库SQL语言参考</span></a></p>
                              </li>
                              <li>
                                 <p>有关创建分区索引组织表的信息<a href="https://www.oracle.com/pls/topic/lookup?ctx=en/database/oracle/oracle-database/19/admin&amp;id=VLDBG1112" target="_blank"><span class="italic">，请参见“Oracle数据库VLDB和分区指南”</span></a></p>
                              </li>
                              <li>
                                 <p><a href="https://www.oracle.com/pls/topic/lookup?ctx=en/database/oracle/oracle-database/19/admin&amp;id=ADOBJ001" target="_blank"><span class="italic">Oracle数据库对象关系开发人员指南</span></a> ，了解有关对象类型的信息</p>
                              </li>
                           </ul>
                        </div>
                        <div class="familylinks">
                           <div class="parentlink">
                              <p><strong>父主题：</strong> <a href="managing-tables.html#GUID-F3965F25-01CD-464C-B065-025442A6C43F" title="索引组织表提供快速主键访问和高可用性。">创建索引组织表</a></p>
                           </div>
                        </div>
                     </div>
                     
                  </div><a id="ADMIN11689"></a><div class="props_rev_3"><a id="GUID-E60A24D9-3DC0-4E0F-9B65-7B348560D2DC" name="GUID-E60A24D9-3DC0-4E0F-9B65-7B348560D2DC"></a><h5 id="ADMIN-GUID-E60A24D9-3DC0-4E0F-9B65-7B348560D2DC" class="sect5"><span class="enumeration_section">20.13.2.5</span>选择和监控阈值</h5>
                     <div>
                        <p>选择一个可容纳关键列的阈值，以及前几个非关键列（如果经常访问它们）。</p>
                        <div class="section">
                           <p>选择阈值后，您可以监视表以验证您指定的值是否合适。你可以使用<code class="codeph">ANALYZE</code> <code class="codeph">TABLE</code> ...<code class="codeph">LIST</code> <code class="codeph">CHAINED</code> <code class="codeph">ROWS</code>语句，用于确定超过阈值的行数和标识。
                           </p>
                        </div>
                        <!-- class="section" -->
                     </div>
                     <div>
                        <div class="infoboxnotealso" id="GUID-E60A24D9-3DC0-4E0F-9B65-7B348560D2DC__GUID-1C791607-341C-413C-AD6C-4840CF3AA803">
                           <p class="notep1">也可以看看：</p>
                           <p></p>
                           <ul style="list-style-type:disc">
                              <li>
                                 <p><span class="q">“ <a href="managing-schema-objects.html#GUID-AA49BB99-71E6-439C-BB0F-D4F0EAF63FB7" title="您可以使用带有LIST CHAINED ROWS子句的ANALYZE语句查看表或集群的已链接和已迁移行。此语句的结果存储在显式创建的指定表中，以接受LIST CHAINED ROWS子句返回的信息。这些结果可用于确定您是否有足够的空间来更新行。">列出表和群集的链式行</a> ”</span>以获取有关链接行的更多信息</p>
                              </li>
                              <li>
                                 <p>有关<code class="codeph">ANALYZE</code>语句语法的<a href="https://www.oracle.com/pls/topic/lookup?ctx=en/database/oracle/oracle-database/19/admin&amp;id=SQLRF01105" target="_blank"><span class="italic">Oracle数据库SQL语言参考</span></a></p>
                              </li>
                           </ul>
                        </div>
                        <div class="familylinks">
                           <div class="parentlink">
                              <p><strong>父主题：</strong> <a href="managing-tables.html#GUID-F3965F25-01CD-464C-B065-025442A6C43F" title="索引组织表提供快速主键访问和高可用性。">创建索引组织表</a></p>
                           </div>
                        </div>
                     </div>
                     
                  </div><a id="ADMIN11690"></a><div class="props_rev_3"><a id="GUID-2EA88382-8D2D-4E2F-8E89-0DBE2DB4B5CC" name="GUID-2EA88382-8D2D-4E2F-8E89-0DBE2DB4B5CC"></a><h5 id="ADMIN-GUID-2EA88382-8D2D-4E2F-8E89-0DBE2DB4B5CC" class="sect5"><span class="enumeration_section">20.13.2.6</span>使用INCLUDING条款</h5>
                     <div>
                        <p>除了指定<code class="codeph">PCTTHRESHOLD</code> ，还可以使用<code class="codeph">INCLUDING</code>子句来控制与索引组织表中的键列一起存储的非键列。
                        </p>
                        <div class="section">
                           <p>数据库容纳所有非键列，直到并包括索引叶块中<code class="codeph">INCLUDING</code>子句中指定的列，前提是它不超过指定的阈值。<code class="codeph">INCLUDING</code>子句中指定的列之外的所有非键列都存储在溢出段中。如果<code class="codeph">INCLUDING</code>和<code class="codeph">PCTTHRESHOLD</code>条款发生冲突，则<code class="codeph">PCTTHRESHOLD</code>优先。
                           </p>
                           <div class="infoboxnote" id="GUID-2EA88382-8D2D-4E2F-8E89-0DBE2DB4B5CC__GUID-D4D05545-1CC2-4ADE-8CE6-AA684284A92A">
                              <p class="notep1">注意：</p>
                              <p>Oracle数据库将索引组织表的所有主键列移动到表的开头（按其键顺序），以提供有效的基于主键的访问。举个例子：</p><pre class="oac_no_warn" dir="ltr">CREATE TABLE admin_iot4（INT，b INT，c INT，d INT，主键（c，b））组织索引;</pre><p>存储的列顺序为： <code class="codeph">cbad</code> （而不是： <code class="codeph">abcd</code> ）。最后一个主键列是<code class="codeph">b</code> ，基于存储的列顺序。<code class="codeph">INCLUDING</code>列可以是最后一个主键列（本例中为<code class="codeph">b</code> ），也可以是任何非键列（即存储列顺序中<code class="codeph">b</code>之后的任何列）。
                              </p>
                           </div>
                           <p>以下<code class="codeph">CREATE TABLE</code>语句类似于前面<span class="q">“ <a href="managing-tables.html#GUID-D7BF95BE-7587-4273-86BC-560096B584FC" title="一个示例说明了创建索引组织表。">示例：创建索引组织表</a> ”中</span>显示的语句，但是被修改为创建索引组织表，其中<code class="codeph">token_offsets</code>列值始终存储在溢出区域中：</p><pre class="oac_no_warn" dir="ltr">CREATE TABLE admin_docindex2（令牌CHAR（20），doc_id NUMBER，token_frequency NUMBER，token_offsets VARCHAR2（2000），CONSTRAINT pk_admin_docindex2 PRIMARY KEY（令牌，doc_id））组织索引表空间admin_tbs PCTTHRESHOLD 20包括token_frequency OVERFLOW TABLESPACE admin_tbs2;</pre><p>这里，只有<code class="codeph">token_offsets</code>之前的非键列（在这种情况下只有一个列）与索引叶块中的键列值一起存储。
                           </p>
                        </div>
                        <!-- class="section" -->
                     </div>
                     <div>
                        <div class="familylinks">
                           <div class="parentlink">
                              <p><strong>父主题：</strong> <a href="managing-tables.html#GUID-F3965F25-01CD-464C-B065-025442A6C43F" title="索引组织表提供快速主键访问和高可用性。">创建索引组织表</a></p>
                           </div>
                        </div>
                     </div>
                     
                  </div><a id="ADMIN11691"></a><div class="props_rev_3"><a id="GUID-7E30807C-A239-4ACE-917D-F658103A7F39" name="GUID-7E30807C-A239-4ACE-917D-F658103A7F39"></a><h5 id="ADMIN-GUID-7E30807C-A239-4ACE-917D-F658103A7F39" class="sect5"><span class="enumeration_section">20.13.2.7</span>并行化索引组织表的创建</h5>
                     <div>
                        <p><code class="codeph">CREATE TABLE...AS SELECT</code>语句可以创建索引组织表并将现有表中的数据加载到其中。通过包含<code class="codeph">PARALLEL</code>子句，可以并行完成加载。
                        </p>
                        <div class="section">
                           <p>以下语句通过从传统表<code class="codeph">hr.jobs</code>选择行来并行创建索引组织表：</p><pre class="oac_no_warn" dir="ltr">CREATE TABLE admin_iot3（i PRIMARY KEY，j，k，l）ORGANIZATION INDEX PARALLEL as SELECT * FROM hr.jobs;</pre><p>此语句提供了使用SQL * Loader进行并行批量加载的替代方法。</p>
                        </div>
                        <!-- class="section" -->
                     </div>
                     <div>
                        <div class="familylinks">
                           <div class="parentlink">
                              <p><strong>父主题：</strong> <a href="managing-tables.html#GUID-F3965F25-01CD-464C-B065-025442A6C43F" title="索引组织表提供快速主键访问和高可用性。">创建索引组织表</a></p>
                           </div>
                        </div>
                     </div>
                     
                  </div><a id="ADMIN11692"></a><div class="props_rev_3"><a id="GUID-D4D9F29D-461C-4394-B082-4FB59C89866F" name="GUID-D4D9F29D-461C-4394-B082-4FB59C89866F"></a><h5 id="ADMIN-GUID-D4D9F29D-461C-4394-B082-4FB59C89866F" class="sect5"><span class="enumeration_section">20.13.2.8</span>使用前缀压缩</h5>
                     <div>
                        <p>使用前缀压缩（也称为密钥压缩）创建索引组织表可以消除重复出现的键列前缀值。</p>
                        <div class="section">
                           <p>前缀压缩将索引键分为前缀和后缀条目。通过在索引块中的所有后缀条目之间共享前缀条目来实现压缩。这种共享可以节省大量空间，允许您在每个索引块中存储更多密钥，同时提高性能。</p>
                           <p>您可以使用<code class="codeph">COMPRESS</code>子句启用前缀压缩，同时：</p>
                        </div>
                        <!-- class="section" -->
                        <div class="section">
                           <ul style="list-style-type:disc">
                              <li>
                                 <p>创建索引组织表</p>
                              </li>
                              <li>
                                 <p>移动索引组织表</p>
                              </li>
                           </ul>
                           <p>您还可以指定前缀长度（作为键列的数量），它标识键列如何分为前缀和后缀条目。</p><pre class="oac_no_warn" dir="ltr">CREATE TABLE admin_iot5（i INT，j INT，k INT，l INT，PRIMARY KEY（i，j，k））ORGANIZATION INDEX COMPRESS;</pre><p>前面的语句等同于以下语句：</p><pre class="oac_no_warn" dir="ltr">CREATE TABLE admin_iot6（i INT，j INT，k INT，l INT，PRIMARY KEY（i，j，k））ORGANIZATION INDEX COMPRESS 2;</pre><p>对于值列表（1,2,3），（1,2,4），（1,2,7），（1,3,5），（1,3,4），（1,4， 4）（1,2），（1,3）的重复出现被压缩掉。</p>
                           <p>您还可以覆盖用于压缩的默认前缀长度，如下所示：</p><pre class="oac_no_warn" dir="ltr">CREATE TABLE admin_iot7（i INT，j INT，k INT，l INT，PRIMARY KEY（i，j，k））ORGANIZATION INDEX COMPRESS 1;</pre><p>对于值列表（1,2,3），（1,2,4），（1,2,7），（1,3,5），（1,3,4），（1,4， 4），1的重复出现被压缩掉。</p>
                           <p>您可以按如下方式禁用压缩：</p><pre class="oac_no_warn" dir="ltr">ALTER TABLE admin_iot5 MOVE NOCOMPRESS;</pre><p>前缀压缩的一个应用是在时间序列应用程序中，该应用程序使用属于单个项目的一组带时间戳的行，例如股票价格。索引组织表对于此类应用程序很有吸引力，因为它能够基于主键对行进行聚类。通过使用主键（库存符号，时间戳）定义索引组织表，您可以有效地存储和操作时间序列数据。通过使用带有前缀压缩的索引组织表，按时间序列压缩项目标识符（例如，股票代码）的重复出现，可以节省更多存储空间。</p>
                        </div>
                        <!-- class="section" -->
                     </div>
                     <div>
                        <div class="infoboxnotealso" id="GUID-D4D9F29D-461C-4394-B082-4FB59C89866F__GUID-933412DA-D527-4D78-90E2-CC455F8509FA">
                           <p class="notep1">也可以看看：</p>
                           <p> 有关前缀压缩的更多信息，请参阅<a href="https://www.oracle.com/pls/topic/lookup?ctx=en/database/oracle/oracle-database/19/admin&amp;id=CNCPT1177" target="_blank"><span class="italic">Oracle数据库概</span></a></p>
                        </div>
                        <div class="familylinks">
                           <div class="parentlink">
                              <p><strong>父主题：</strong> <a href="managing-tables.html#GUID-F3965F25-01CD-464C-B065-025442A6C43F" title="索引组织表提供快速主键访问和高可用性。">创建索引组织表</a></p>
                           </div>
                        </div>
                     </div>
                     
                  </div>
               </div><a id="ADMIN11693"></a><div class="props_rev_3"><a id="GUID-4E51E139-9352-4F95-93FE-7CB626646308" name="GUID-4E51E139-9352-4F95-93FE-7CB626646308"></a><h4 id="ADMIN-GUID-4E51E139-9352-4F95-93FE-7CB626646308" class="sect4"><span class="enumeration_section">20.13.3</span>维护索引组织表</h4>
                  <p>索引组织表与仅在物理组织中的普通表不同。从逻辑上讲，它们的处理方式与普通表相同。您可以像在<code class="codeph">INSERT</code> ， <code class="codeph">SELECT</code> ， <code class="codeph">DELETE</code>和<code class="codeph">UPDATE</code>语句中指定常规表一样指定索引组织表。
                  </p>
                  <div>
                     <ul class="ullinks">
                        <li class="ulchildlink"><a href="managing-tables.html#GUID-40D450CF-2534-426E-A1DC-9169D8D33E95">改变索引组织表</a><br>普通表可用的所有alter选项都可用于索引组织表。这包括<code class="codeph">ADD</code> ， <code class="codeph">MODIFY</code>和<code class="codeph">DROP</code> <code class="codeph">COLUMNS</code>和<code class="codeph">CONSTRAINTS</code> 。但是，无法删除，延迟或禁用索引组织表的主键约束。
                        </li>
                        <li class="ulchildlink"><a href="managing-tables.html#GUID-B56F7070-4702-4C64-BA0B-1B692885D607">移动（重建）索引组织表</a><br>由于索引组织表主要存储在B树索引中，因此可能会因增量更新而遇到碎片。但是，您可以使用<code class="codeph">ALTER TABLE...MOVE</code>语句重建索引并减少此碎片。
                        </li>
                     </ul>
                     <div class="familylinks">
                        <div class="parentlink">
                           <p><strong>父主题：</strong> <a href="managing-tables.html#GUID-D9BCA9BF-EAA8-431D-BDBB-ED5B3C59C5E4" title="索引组织表的存储组织是主B树索引的变体。与堆组织表不同，数据以主键顺序存储。">管理索引组织表</a></p>
                        </div>
                     </div>
                  </div>
                  <a id="ADMIN11694"></a><div class="props_rev_3"><a id="GUID-40D450CF-2534-426E-A1DC-9169D8D33E95" name="GUID-40D450CF-2534-426E-A1DC-9169D8D33E95"></a><h5 id="ADMIN-GUID-40D450CF-2534-426E-A1DC-9169D8D33E95" class="sect5"><span class="enumeration_section">20.13.3.1修改</span>索引组织表</h5>
                     <div>
                        <p>普通表可用的所有alter选项都可用于索引组织表。这包括<code class="codeph">ADD</code> ， <code class="codeph">MODIFY</code>和<code class="codeph">DROP</code> <code class="codeph">COLUMNS</code>和<code class="codeph">CONSTRAINTS</code> 。但是，无法删除，延迟或禁用索引组织表的主键约束。
                        </p>
                        <div class="section">
                           <p>您可以使用<code class="codeph">ALTER TABLE</code>语句修改主键索引和溢出数据段的物理和存储属性。在<code class="codeph">OVERFLOW</code>关键字之前指定的所有属性都适用于主键索引段。<code class="codeph">OVERFLOW</code>关键字后指定的所有属性都适用于溢出数据段。例如，您可以将主键索引段的<code class="codeph">INITRANS</code>设置为4，将数据段<code class="codeph">INITRANS</code>的溢出<code class="codeph">INITRANS</code>为6，如下所示：</p><pre class="oac_no_warn" dir="ltr">ALTER TABLE admin_docindex INITRANS 4 OVERFLOW INITRANS 6;</pre><p>您还可以更改<code class="codeph">PCTTHRESHOLD</code>和<code class="codeph">INCLUDING</code>列值。在后续操作期间，使用新设置将行分成头部和溢出尾部。例如，可以为<code class="codeph">admin_docindex</code>表更改<code class="codeph">PCTHRESHOLD</code>和<code class="codeph">INCLUDING</code>列值，如下所示：</p><pre class="oac_no_warn" dir="ltr">ALTER TABLE admin_docindex PCTTHRESHOLD 15包括doc_id;</pre><p>通过将<code class="codeph">INCLUDING</code>列设置为<code class="codeph">doc_id</code> ，跟随<code class="codeph">token_frequency</code>和<code class="codeph">token_offsets</code>所有列都存储在溢出数据段中。
                           </p>
                           <p>对于在没有溢出数据段的情况下创建的索引组织表，可以使用<code class="codeph">ADD OVERFLOW</code>子句添加溢出数据段。例如，您可以向表<code class="codeph">admin_iot3</code>添加溢出段，如下所示：</p><pre class="oac_no_warn" dir="ltr">ALTER TABLE admin_iot3 ADD OVERFLOW TABLESPACE admin_tbs2;</pre></div>
                        <!-- class="section" -->
                     </div>
                     <div>
                        <div class="familylinks">
                           <div class="parentlink">
                              <p><strong>父主题：</strong> <a href="managing-tables.html#GUID-4E51E139-9352-4F95-93FE-7CB626646308" title="索引组织表与仅在物理组织中的普通表不同。从逻辑上讲，它们的处理方式与普通表相同。您可以像在INSERT，SELECT，DELETE和UPDATE语句中指定常规表一样指定索引组织表。">维护索引组织表</a></p>
                           </div>
                        </div>
                     </div>
                     
                  </div><a id="ADMIN11695"></a><div class="props_rev_3"><a id="GUID-B56F7070-4702-4C64-BA0B-1B692885D607" name="GUID-B56F7070-4702-4C64-BA0B-1B692885D607"></a><h5 id="ADMIN-GUID-B56F7070-4702-4C64-BA0B-1B692885D607" class="sect5"><span class="enumeration_section">20.13.3.2</span>移动（重建）索引组织表</h5>
                     <div>
                        <p>由于索引组织表主要存储在B树索引中，因此可能会因增量更新而遇到碎片。但是，您可以使用<code class="codeph">ALTER TABLE...MOVE</code>语句重建索引并减少此碎片。
                        </p>
                        <div class="section">
                           <p>以下语句重建索引组织表<code class="codeph">admin_docindex</code> ：</p><pre class="oac_no_warn" dir="ltr">ALTER TABLE admin_docindex MOVE;</pre><p>您可以使用<code class="codeph">ONLINE</code>关键字在线重建索引组织表。如果存在，则在指定<code class="codeph">OVERFLOW</code>关键字时重建溢出数据段。例如，要重建<code class="codeph">admin_docindex</code>表而不是溢出数据段，请按如下方式在线执行：</p><pre class="oac_no_warn" dir="ltr">ALTER TABLE admin_docindex MOVE ONLINE;</pre><p>要重建<code class="codeph">admin_docindex</code>表及其溢出数据段，请执行以下语句中所示的移动操作。此语句还说明了将表和溢出数据段移动到新的表空间。
                           </p><pre class="oac_no_warn" dir="ltr">ALTER TABLE admin_docindex MOVE TABLESPACE admin_tbs2 OVERFLOW TABLESPACE admin_tbs3;</pre><p>在最后一个语句中，创建了一个带有LOB列（CLOB）的索引组织表。稍后，移动表，并重建<code class="codeph">LOB</code>索引和数据段并将其移动到新的表空间。
                           </p><pre class="oac_no_warn" dir="ltr">CREATE TABLE admin_iot_lob（c1 number（6）主键，admin_lob CLOB）ORGANIZATION INDEX LOB（admin_lob）STORE AS（TABLESPACE admin_tbs2）; 。。。ALTER TABLE admin_iot_lob MOVE LOB（admin_lob）STORE AS（TABLESPACE admin_tbs3）;</pre></div>
                        <!-- class="section" -->
                     </div>
                     <div>
                        <div class="infoboxnotealso" id="GUID-B56F7070-4702-4C64-BA0B-1B692885D607__GUID-10695C33-CE9C-413C-8A51-C1C2862D15BA">
                           <p class="notep1">也可以看看：</p>
                           <p><a href="https://www.oracle.com/pls/topic/lookup?ctx=en/database/oracle/oracle-database/19/admin&amp;id=ADLOB45315" target="_blank"><span class="italic">Oracle Database SecureFiles和Large Objects Developer's Guide</span></a> ，了解有关索引组织表中LOB的信息</p>
                        </div>
                        <div class="familylinks">
                           <div class="parentlink">
                              <p><strong>父主题：</strong> <a href="managing-tables.html#GUID-4E51E139-9352-4F95-93FE-7CB626646308" title="索引组织表与仅在物理组织中的普通表不同。从逻辑上讲，它们的处理方式与普通表相同。您可以像在INSERT，SELECT，DELETE和UPDATE语句中指定常规表一样指定索引组织表。">维护索引组织表</a></p>
                           </div>
                        </div>
                     </div>
                     
                  </div>
               </div>
               <div class="sect3"><a id="GUID-F0DA4974-0FC7-4227-873D-A5D7156D68D6" name="GUID-F0DA4974-0FC7-4227-873D-A5D7156D68D6"></a><h4 id="ADMIN-GUID-F0DA4974-0FC7-4227-873D-A5D7156D68D6" class="sect4"><span class="enumeration_section">20.13.4</span>在索引组织表上创建二级索引</h4>
                  <p>辅助索引是索引组织表的索引。辅助索引是一个独立的模式对象，与索引组织表分开存储。</p>
                  <div>
                     <ul class="ullinks">
                        <li class="ulchildlink"><a href="managing-tables.html#GUID-7B0F152A-DFF6-4147-BAD4-9C49BFDF3785">关于索引组织表的二级索引</a><br>您可以在索引组织表上创建二级索引，以提供多个访问路径。
                        </li>
                        <li class="ulchildlink"><a href="managing-tables.html#GUID-C9309222-B06F-4C6C-9341-B9918073E182">在索引组织表上创建二级索引</a><br>您可以在索引组织表上创建二级索引。
                        </li>
                        <li class="ulchildlink"><a href="managing-tables.html#GUID-6F7F6F38-CD87-4352-A44E-2BCB92BC777D">在逻辑Rowid中维护物理猜测</a><br>逻辑rowid可以包括猜测，其在猜测时标识行的块位置。数据库不使用全键搜索，而是使用guess直接搜索块。
                        </li>
                        <li class="ulchildlink"><a href="managing-tables.html#GUID-38301C16-EDD2-40AA-B4B1-75F2E7B81C52">在索引组织表上指定位图索引</a><br>支持索引组织表的位图索引，前提是使用映射表创建索引组织表。
                        </li>
                     </ul>
                     <div class="familylinks">
                        <div class="parentlink">
                           <p><strong>父主题：</strong> <a href="managing-tables.html#GUID-D9BCA9BF-EAA8-431D-BDBB-ED5B3C59C5E4" title="索引组织表的存储组织是主B树索引的变体。与堆组织表不同，数据以主键顺序存储。">管理索引组织表</a></p>
                        </div>
                     </div>
                  </div>
                  <a id="ADMIN11696"></a><div class="props_rev_3"><a id="GUID-7B0F152A-DFF6-4147-BAD4-9C49BFDF3785" name="GUID-7B0F152A-DFF6-4147-BAD4-9C49BFDF3785"></a><h5 id="ADMIN-GUID-7B0F152A-DFF6-4147-BAD4-9C49BFDF3785" class="sect5"><span class="enumeration_section">20.13.4.1</span>关于索引组织表的二级索引</h5>
                     <div>
                        <p>您可以在索引组织表上创建二级索引，以提供多个访问路径。</p>
                        <p>索引组织表上的二级索引与普通表上的索引有两种不同：</p>
                        <ul style="list-style-type:disc">
                           <li>
                              <p>它们存储逻辑rowid而不是物理rowid。这是必要的，因为B树索引中行的固有可移动性导致行没有永久物理地址。如果行的物理位置发生更改，则其逻辑rowid仍然有效。这样做的一个效果是表维护操作，例如<code class="codeph">ALTER TABLE</code> ...<code class="codeph">MOVE</code> ，不会使二级索引无法使用。
                              </p>
                           </li>
                           <li>
                              <p>逻辑rowid还包括物理猜测，该物理猜测标识可能在其中找到行的数据库块地址。如果物理猜测是正确的，一旦找到辅助密钥，二级索引扫描将产生一个额外的I / O.性能类似于普通表上的二级索引扫描。</p>
                           </li>
                        </ul>
                        <p>在索引组织表上支持唯一且非唯一的二级索引，基于函数的二级索引和位图索引作为二级索引。</p>
                     </div>
                     <div>
                        <div class="familylinks">
                           <div class="parentlink">
                              <p><strong>父主题：</strong> <a href="managing-tables.html#GUID-F0DA4974-0FC7-4227-873D-A5D7156D68D6" title="辅助索引是索引组织表的索引。辅助索引是一个独立的模式对象，与索引组织表分开存储。">在索引组织表上创建辅助索引</a></p>
                           </div>
                        </div>
                     </div>
                     
                  </div><a id="ADMIN11697"></a><div class="props_rev_3"><a id="GUID-C9309222-B06F-4C6C-9341-B9918073E182" name="GUID-C9309222-B06F-4C6C-9341-B9918073E182"></a><h5 id="ADMIN-GUID-C9309222-B06F-4C6C-9341-B9918073E182" class="sect5"><span class="enumeration_section">20.13.4.2</span>在索引组织表上创建二级索引</h5>
                     <div>
                        <p>您可以在索引组织表上创建二级索引。</p>
                        <div class="section">
                           <p>以下语句显示在<code class="codeph">docindex</code>索引组织表上创建辅助索引，其中<code class="codeph">doc_id</code>和<code class="codeph">token</code>是键列：</p><pre class="oac_no_warn" dir="ltr">在Docindex上创建INDEX Doc_id_index（Doc_id，Token）;</pre><p>此二级索引允许数据库有效地处理查询，例如以下内容，涉及<code class="codeph">doc_id</code>上的谓词：</p><pre class="oac_no_warn" dir="ltr">SELECT Token FROM Docindex WHERE Doc_id = 1;</pre></div>
                        <!-- class="section" -->
                     </div>
                     <div>
                        <div class="familylinks">
                           <div class="parentlink">
                              <p><strong>父主题：</strong> <a href="managing-tables.html#GUID-F0DA4974-0FC7-4227-873D-A5D7156D68D6" title="辅助索引是索引组织表的索引。辅助索引是一个独立的模式对象，与索引组织表分开存储。">在索引组织表上创建辅助索引</a></p>
                           </div>
                        </div>
                     </div>
                     
                  </div><a id="ADMIN11698"></a><div class="props_rev_3"><a id="GUID-6F7F6F38-CD87-4352-A44E-2BCB92BC777D" name="GUID-6F7F6F38-CD87-4352-A44E-2BCB92BC777D"></a><h5 id="ADMIN-GUID-6F7F6F38-CD87-4352-A44E-2BCB92BC777D" class="sect5"><span class="enumeration_section">20.13.4.3</span>维护逻辑行中的物理猜测</h5>
                     <div>
                        <p>逻辑rowid可以包括猜测，其在猜测时标识行的块位置。数据库不使用全键搜索，而是使用guess直接搜索块。</p>
                        <div class="section">
                           <p>但是，当插入新行时，猜测可能会变得陈旧。索引仍可通过逻辑rowid的主键组件使用，但对行的访问速度较慢。</p>
                           <ol>
                              <li>
                                 <p>使用<code class="codeph">DBMS_STATS</code>包收集索引统计信息以监视猜测的陈旧性。
                                 </p>
                                 <p>数据库检查现有猜测是否仍然有效，并在数据字典中记录具有有效猜测的行的百分比。</p>
                              </li>
                              <li>
                                 <p>查询<code class="codeph">DBA_INDEXES</code>视图（和相关视图）的<code class="codeph">PCT_DIRECT_ACCESS</code>列以显示与现有猜测相关的统计信息。
                                 </p>
                              </li>
                              <li>
                                 <p>要获得新的猜测，您可以重建二级索引。</p>
                              </li>
                           </ol>
                           <p>在索引组织表上重建二级索引涉及读取基表，而不像在普通表上重建索引。</p>
                           <p>更快，更轻量的固定猜测方法是使用<code class="codeph">ALTER</code> <code class="codeph">INDEX</code> ......<code class="codeph">UPDATE</code> <code class="codeph">BLOCK</code> <code class="codeph">REFERENCES</code>声明。此语句在线执行，而基础索引组织表仍允许使用DML。
                           </p>
                           <p>重建二级索引或以其他方式更新猜测中的块引用后，再次收集索引统计信息。</p>
                        </div>
                        <!-- class="section" -->
                     </div>
                     <div>
                        <div class="familylinks">
                           <div class="parentlink">
                              <p><strong>父主题：</strong> <a href="managing-tables.html#GUID-F0DA4974-0FC7-4227-873D-A5D7156D68D6" title="辅助索引是索引组织表的索引。辅助索引是一个独立的模式对象，与索引组织表分开存储。">在索引组织表上创建辅助索引</a></p>
                           </div>
                        </div>
                     </div>
                     
                  </div><a id="ADMIN11699"></a><div class="props_rev_3"><a id="GUID-38301C16-EDD2-40AA-B4B1-75F2E7B81C52" name="GUID-38301C16-EDD2-40AA-B4B1-75F2E7B81C52"></a><h5 id="ADMIN-GUID-38301C16-EDD2-40AA-B4B1-75F2E7B81C52" class="sect5"><span class="enumeration_section">20.13.4.4</span>在索引组织表上指定位图索引</h5>
                     <div>
                        <p>支持索引组织表的位图索引，前提是使用映射表创建索引组织表。</p>
                        <div class="section">
                           <p>这是通过在<code class="codeph">CREATE</code> <code class="codeph">TABLE</code>语句中指定用于创建索引组织表的<code class="codeph">MAPPING</code> <code class="codeph">TABLE</code>子句或在<code class="codeph">ALTER</code> <code class="codeph">TABLE</code>语句中稍后添加映射表来完成的。
                           </p>
                        </div>
                        <!-- class="section" -->
                     </div>
                     <div>
                        <div class="infoboxnotealso" id="GUID-38301C16-EDD2-40AA-B4B1-75F2E7B81C52__GUID-F5872522-BC92-4822-AF7D-0534422D0904">
                           <p class="notep1">也可以看看：</p>
                           <p><a href="https://www.oracle.com/pls/topic/lookup?ctx=en/database/oracle/oracle-database/19/admin&amp;id=CNCPT88857" target="_blank"><span class="italic">Oracle Database Concepts，</span></a>用于描述映射表</p>
                        </div>
                        <div class="familylinks">
                           <div class="parentlink">
                              <p><strong>父主题：</strong> <a href="managing-tables.html#GUID-F0DA4974-0FC7-4227-873D-A5D7156D68D6" title="辅助索引是索引组织表的索引。辅助索引是一个独立的模式对象，与索引组织表分开存储。">在索引组织表上创建辅助索引</a></p>
                           </div>
                        </div>
                     </div>
                     
                  </div>
               </div><a id="ADMIN11700"></a><div class="props_rev_3"><a id="GUID-3FDB4F70-4DD9-47BF-811B-F5CA0F168832" name="GUID-3FDB4F70-4DD9-47BF-811B-F5CA0F168832"></a><h4 id="ADMIN-GUID-3FDB4F70-4DD9-47BF-811B-F5CA0F168832" class="sect4"><span class="enumeration_section">20.13.5</span>分析索引组织表</h4>
                  <p>与普通表一样，使用<code class="codeph">DBMS_STATS</code>包或<code class="codeph">ANALYZE</code>语句分析索引组织表。
                  </p>
                  <div>
                     <ul class="ullinks">
                        <li class="ulchildlink"><a href="managing-tables.html#GUID-12BF66C1-9C44-499C-9317-D1F74CB3D9F6">收集索引组织表的优化器统计信息</a><br>要收集优化程序统计信息，请使用<code class="codeph">DBMS_STATS</code>程序包。
                        </li>
                        <li class="ulchildlink"><a href="managing-tables.html#GUID-88F30FE4-1945-485C-BA53-6D8BF11DD907">验证索引组织表的结构</a><br>使用<code class="codeph">ANALYZE</code>语句验证索引组织表的结构或列出任何链接的行。
                        </li>
                     </ul>
                     <div class="familylinks">
                        <div class="parentlink">
                           <p><strong>父主题：</strong> <a href="managing-tables.html#GUID-D9BCA9BF-EAA8-431D-BDBB-ED5B3C59C5E4" title="索引组织表的存储组织是主B树索引的变体。与堆组织表不同，数据以主键顺序存储。">管理索引组织表</a></p>
                        </div>
                     </div>
                  </div>
                  <a id="ADMIN11701"></a><div class="props_rev_3"><a id="GUID-12BF66C1-9C44-499C-9317-D1F74CB3D9F6" name="GUID-12BF66C1-9C44-499C-9317-D1F74CB3D9F6"></a><h5 id="ADMIN-GUID-12BF66C1-9C44-499C-9317-D1F74CB3D9F6" class="sect5"><span class="enumeration_section">20.13.5.1</span>收集索引组织表的优化器统计信息</h5>
                     <div>
                        <p>要收集优化程序统计信息，请使用<code class="codeph">DBMS_STATS</code>程序包。
                        </p>
                        <div class="section">
                           <p>例如，以下语句收集<code class="codeph">hr</code>模式中索引组织的<code class="codeph">countries</code>表的统计信息：</p><pre class="oac_no_warn" dir="ltr">EXECUTE DBMS_STATS.GATHER_TABLE_STATS（'HR'，'COUNTRIES'）;</pre><p><code class="codeph">DBMS_STATS</code>包分析主键索引段和溢出数据段，并计算表的逻辑和物理统计信息。
                           </p>
                        </div>
                        <!-- class="section" -->
                        <div class="section">
                           <ul style="list-style-type:disc">
                              <li>
                                 <p>可以使用<code class="codeph">USER_TABLES</code> ， <code class="codeph">ALL_TABLES</code>或<code class="codeph">DBA_TABLES</code>查询逻辑统计信息。</p>
                              </li>
                              <li>
                                 <p>您可以使用<code class="codeph">USER_INDEXES</code> ， <code class="codeph">ALL_INDEXES</code>或<code class="codeph">DBA_INDEXES</code> （以及使用主键索引名称）查询主键索引段的物理统计信息。例如，您可以获取表<code class="codeph">admin_docindex</code>的主键索引段物理统计信息，如下所示：</p><pre class="oac_no_warn" dir="ltr">SELECT LAST_ANALYZED，BLEVEL，LEAF_BLOCKS，DISTINCT_KEYS FROM DBA_INDEXES WHERE INDEX_NAME ='PK_ADMIN_DOCINDEX';</pre></li>
                              <li>
                                 <p>您可以使用<code class="codeph">USER_TABLES</code> ， <code class="codeph">ALL_TABLES</code>或<code class="codeph">DBA_TABLES</code>查询溢出数据段的物理统计信息。您可以通过搜索<code class="codeph">IOT_TYPE = 'IOT_OVERFLOW'</code>来识别溢出条目。例如，您可以获取与<code class="codeph">admin_docindex</code>表关联的溢出数据段物理属性，如下所示：</p><pre class="oac_no_warn" dir="ltr">从DBA_TABLES中选择LAST_ANALYZED，NUM_ROWS，BLOCKS，EMPTY_BLOCKS，其中IOT_TYPE ='IOT_OVERFLOW'和IOT_NAME ='ADMIN_DOCINDEX';</pre><div class="infoboxnotealso" id="GUID-12BF66C1-9C44-499C-9317-D1F74CB3D9F6__GUID-5785B085-2AAD-4127-BE8F-BA53394DD20D">
                                    <p class="notep1">也可以看看：</p>
                                    <p></p>
                                    <ul style="list-style-type:disc">
                                       <li>
                                          <p>有关收集优化程序统计信息的详细信息，请<a href="https://www.oracle.com/pls/topic/lookup?ctx=en/database/oracle/oracle-database/19/admin&amp;id=TGSQL389" target="_blank"><span class="italic">参见“Oracle数据库SQL调优指</span></a></p>
                                       </li>
                                       <li>
                                          <p>有关<code class="codeph">DBMS_STATS</code>包的更多信息，请<a href="https://www.oracle.com/pls/topic/lookup?ctx=en/database/oracle/oracle-database/19/admin&amp;id=ARPLS059" target="_blank"><span class="italic">参见Oracle Database PL / SQL包和类型参考</span></a></p>
                                       </li>
                                    </ul>
                                 </div>
                              </li>
                           </ul>
                        </div>
                        <!-- class="section" -->
                     </div>
                     <div>
                        <div class="familylinks">
                           <div class="parentlink">
                              <p><strong>父主题：</strong> <a href="managing-tables.html#GUID-3FDB4F70-4DD9-47BF-811B-F5CA0F168832" title="与普通表一样，使用DBMS_STATS包或ANALYZE语句分析索引组织表。">分析索引组织表</a></p>
                           </div>
                        </div>
                     </div>
                     
                  </div><a id="ADMIN11702"></a><div class="props_rev_3"><a id="GUID-88F30FE4-1945-485C-BA53-6D8BF11DD907" name="GUID-88F30FE4-1945-485C-BA53-6D8BF11DD907"></a><h5 id="ADMIN-GUID-88F30FE4-1945-485C-BA53-6D8BF11DD907" class="sect5"><span class="enumeration_section">20.13.5.2</span>验证索引组织表的结构</h5>
                     <div>
                        <p>使用<code class="codeph">ANALYZE</code>语句验证索引组织表的结构或列出任何链接的行。
                        </p>
                        <p>这些操作将在本书其他地方的以下部分中讨论：</p>
                        <ul style="list-style-type:disc">
                           <li>
                              <p><span class="q">“ <a href="managing-schema-objects.html#GUID-4D413507-A992-44B0-8366-867B78E0B6FF" title="要验证表，索引，集群或物化视图的结构的完整性，请使用带有VALIDATE STRUCTURE选项的ANALYZE语句。">验证表，索引，群集和物化视图</a> ”</span></p>
                           </li>
                           <li>
                              <p><span class="q">“ <a href="managing-schema-objects.html#GUID-AA49BB99-71E6-439C-BB0F-D4F0EAF63FB7" title="您可以使用带有LIST CHAINED ROWS子句的ANALYZE语句查看表或集群的已链接和已迁移行。此语句的结果存储在显式创建的指定表中，以接受LIST CHAINED ROWS子句返回的信息。这些结果可用于确定您是否有足够的空间来更新行。">列出表和群集的链式行</a> ”</span> 
                              </p>
                              <div class="infoboxnote" id="GUID-88F30FE4-1945-485C-BA53-6D8BF11DD907__GUID-D202F7FF-9C20-4B09-B271-6716C5FD4A28">
                                 <p class="notep1">注意：</p>
                                 <p>列出索引组织表的链接行时需要特别注意。这些在<a href="https://www.oracle.com/pls/topic/lookup?ctx=en/database/oracle/oracle-database/19/admin&amp;id=SQLRF01105" target="_blank"><span class="italic">Oracle数据库SQL语言参考中</span></a>进行了讨论。
                                 </p>
                              </div>
                           </li>
                        </ul>
                     </div>
                     <div>
                        <div class="familylinks">
                           <div class="parentlink">
                              <p><strong>父主题：</strong> <a href="managing-tables.html#GUID-3FDB4F70-4DD9-47BF-811B-F5CA0F168832" title="与普通表一样，使用DBMS_STATS包或ANALYZE语句分析索引组织表。">分析索引组织表</a></p>
                           </div>
                        </div>
                     </div>
                     
                  </div>
               </div><a id="ADMIN11703"></a><div class="props_rev_3"><a id="GUID-9118B891-326A-4579-9BBD-A3A6DDF4016A" name="GUID-9118B891-326A-4579-9BBD-A3A6DDF4016A"></a><h4 id="ADMIN-GUID-9118B891-326A-4579-9BBD-A3A6DDF4016A" class="sect4"><span class="enumeration_section">20.13.6</span>将ORDER BY子句与索引组织表一起使用</h4>
                  <div>
                     <p>如果<code class="codeph">ORDER BY</code>子句仅引用主键列或其前缀，则优化程序会避免排序开销，因为返回的行按主键列排序。
                     </p>
                     <div class="section">
                        <p>以下查询避免了排序开销，因为数据已经在主键上排序：</p><pre class="oac_no_warn" dir="ltr">SELECT * FROM admin_docindex2 ORDER BY token，doc_id; SELECT * FROM admin_docindex2 ORDER BY token;</pre><p>但是，如果在主键列或非主键列的后缀上有<code class="codeph">ORDER BY</code>子句，则需要进行其他排序（假设未定义其他二级索引）。
                        </p><pre class="oac_no_warn" dir="ltr">SELECT * FROM admin_docindex2 ORDER BY doc_id; SELECT * FROM admin_docindex2 ORDER BY token_frequency;</pre></div>
                     <!-- class="section" -->
                  </div>
                  <div>
                     <div class="familylinks">
                        <div class="parentlink">
                           <p><strong>父主题：</strong> <a href="managing-tables.html#GUID-D9BCA9BF-EAA8-431D-BDBB-ED5B3C59C5E4" title="索引组织表的存储组织是主B树索引的变体。与堆组织表不同，数据以主键顺序存储。">管理索引组织表</a></p>
                        </div>
                     </div>
                  </div>
                  
               </div><a id="ADMIN11704"></a><div class="props_rev_3"><a id="GUID-43FB7062-D7FE-4E29-9199-5ACDE7799958" name="GUID-43FB7062-D7FE-4E29-9199-5ACDE7799958"></a><h4 id="ADMIN-GUID-43FB7062-D7FE-4E29-9199-5ACDE7799958" class="sect4"><span class="enumeration_section">20.13.7</span>将索引组织表转换为常规表</h4>
                  <div>
                     <p>您可以使用Oracle导入或导出实用程序或<code class="codeph">CREATE TABLE...将索引组织表转换为常规（堆组织） <code class="codeph">CREATE TABLE...AS SELECT</code>语句。
                     </p>
                     <div class="section">
                        <p>要将索引组织表转换为常规表：</p>
                     </div>
                     <!-- class="section" -->
                     <div class="section">
                        <ul style="list-style-type:disc">
                           <li>
                              <p>使用常规路径导出索引组织的表数据。</p>
                           </li>
                           <li>
                              <p>使用相同的定义创建常规表定义。</p>
                           </li>
                           <li>
                              <p>导入索引组织的表数据，确保<code class="codeph">IGNORE=y</code> （确保忽略对象存在错误）。
                              </p>
                              <div class="infoboxnote" id="GUID-43FB7062-D7FE-4E29-9199-5ACDE7799958__GUID-6DB3A195-C075-4AA2-A635-E038484CB1AC">
                                 <p class="notep1">注意：</p>
                                 <p>在将索引组织表转换为常规表之前，请注意，使用Oracle8之前版本的Export实用程序无法导出索引组织表。</p>
                              </div>
                              <div class="infoboxnotealso" id="GUID-43FB7062-D7FE-4E29-9199-5ACDE7799958__GUID-C2729962-6995-44CE-9BAE-F1F856ABB5D1">
                                 <p class="notep1">也可以看看：</p>
                                 <p>有关使用原始<code class="codeph">IMP</code>和<code class="codeph">EXP</code>实用程序以及数据泵导入和导出实用<a href="../sutil/index.html" target="_blank"><span class="italic">程序</span></a>的更多详细信息，请参见<a href="../sutil/index.html" target="_blank"><span class="italic">Oracle数据库实用</span></a>程序</p>
                              </div>
                           </li>
                        </ul>
                     </div>
                     <!-- class="section" -->
                  </div>
                  <div>
                     <div class="familylinks">
                        <div class="parentlink">
                           <p><strong>父主题：</strong> <a href="managing-tables.html#GUID-D9BCA9BF-EAA8-431D-BDBB-ED5B3C59C5E4" title="索引组织表的存储组织是主B树索引的变体。与堆组织表不同，数据以主键顺序存储。">管理索引组织表</a></p>
                        </div>
                     </div>
                  </div>
                  
               </div>
            </div>
            <div class="props_rev_3"><a id="GUID-4C17C266-A5F8-4C3C-B90F-5A02BE41F264" name="GUID-4C17C266-A5F8-4C3C-B90F-5A02BE41F264"></a><h3 id="ADMIN-GUID-4C17C266-A5F8-4C3C-B90F-5A02BE41F264" class="sect3"><span class="enumeration_section">20.14</span>管理分区表</h3>
               <div>
                  <p>分区表使您的数据可以分解为更小，更易于管理的部分，称为分区，甚至是子分区。每个分区可以具有单独的物理属性，例如启用或禁用压缩，压缩类型，物理存储设置和表空间，从而提供可以更好地调整可用性和性能的结构。此外，每个分区都可以单独管理，这可以简化并减少备份和管理所需的时间。</p>
                  <p>有关管理分区表的更多信息，请参见“ <a href="https://www.oracle.com/pls/topic/lookup?ctx=en/database/oracle/oracle-database/19/admin&amp;id=VLDBG-GUID-EA7EF5CB-DD49-43AF-889A-F83AAC0D7D51" target="_blank"><span class="italic">Oracle数据库VLDB和分区指南”</span></a> 。
                  </p>
               </div>
               <div>
                  <div class="familylinks">
                     <div class="parentlink">
                        <p><strong>父主题：</strong> <a href="managing-tables.html#GUID-707B02F5-E589-4C20-8E2E-5ED4F7888702" title="管理表包括创建表，加载表，更改表和删除表等任务。">管理表</a></p>
                     </div>
                  </div>
               </div>
               
            </div><a id="ADMIN01507"></a><div class="props_rev_3"><a id="GUID-F6948F0E-0557-4C42-9145-1897DE974CC3" name="GUID-F6948F0E-0557-4C42-9145-1897DE974CC3"></a><h3 id="ADMIN-GUID-F6948F0E-0557-4C42-9145-1897DE974CC3" class="sect3"><span class="enumeration_section">20.15</span>管理外部表</h3>
               <p>外部表是不驻留在数据库中的表，但位于数据库外部的外部文件中，例如操作系统文件或Hadoop分布式文件系统（HDFS）文件。</p>
               <div>
                  <ul class="ullinks">
                     <li class="ulchildlink"><a href="managing-tables.html#GUID-697B86CC-875C-4F68-AF80-49B41F33AE45">关于外部表</a><br>Oracle数据库允许您对外部表中的数据进行只读访问。<span class="bold">外部表</span>定义为不驻留在数据库中的表，它们可以是提供访问驱动程序的任何格式。
                     </li>
                     <li class="ulchildlink"><a href="managing-tables.html#GUID-4BABDCB5-640B-46B3-A392-EED9C7B542CB">创建外部表</a><br>您可以使用带有<code class="codeph">ORGANIZATION</code> <code class="codeph">EXTERNAL</code>子句的<code class="codeph">CREATE</code> <code class="codeph">TABLE</code>语句创建外部表。此语句仅在数据字典中创建元数据。
                     </li>
                     <li class="ulchildlink"><a href="managing-tables.html#GUID-84C934CC-2116-482A-B47A-558F643437DC">改变外部表格</a><br>您可以使用<code class="codeph">ALTER TABLE</code>语句修改外部表。
                     </li>
                     <li class="ulchildlink"><a href="managing-tables.html#GUID-67A4ED3F-0366-4E59-A79C-45E6997E43FA">预处理外部表</a><br>外部表可以由用户提供的预处理程序预处理。通过使用预处理程序，用户可以使用不是驱动程序支持的格式的文件中的数据。
                     </li>
                     <li class="ulchildlink"><a href="managing-tables.html#GUID-6E4219FF-A557-452E-A6E9-96C38BA87EE0">覆盖查询中外部表的参数</a><br><code class="codeph">SELECT</code>语句的<code class="codeph">EXTERNAL MODIFY</code>子句修改外部表参数。
                     </li>
                     <li class="ulchildlink"><a href="managing-tables.html#GUID-621E5DDE-36D9-4661-9D14-80DE35858C3F">使用内联外部表</a><br>内联外部表使外部表的运行时定义成为SQL语句的一部分，而无需将外部表创建为数据字典中的持久对象。
                     </li>
                     <li class="ulchildlink"><a href="managing-tables.html#GUID-2A801016-0399-4925-AD1B-A02683E81B59">分区外部表</a><br>对于大量数据，外部表的分区可提供快速查询性能和增强的数据维护。
                     </li>
                     <li class="ulchildlink"><a href="managing-tables.html#GUID-8467E062-FBC3-4BC9-B7E9-BF56B31B419E">删除外部表</a><br>对于外部表， <code class="codeph">DROP</code> <code class="codeph">TABLE</code>语句仅删除数据库中的表元数据。它对驻留在数据库之外的实际数据没有影响。
                     </li>
                     <li class="ulchildlink"><a href="managing-tables.html#GUID-C5B61599-74AA-4004-AFCD-1A95B3BA11C2">外部表的系统和对象权限</a><br>外部表的系统和对象权限是常规表的子集。
                     </li>
                  </ul>
                  <div class="familylinks">
                     <div class="parentlink">
                        <p><strong>父主题：</strong> <a href="managing-tables.html#GUID-707B02F5-E589-4C20-8E2E-5ED4F7888702" title="管理表包括创建表，加载表，更改表和删除表等任务。">管理表</a></p>
                     </div>
                  </div>
               </div>
               <a id="ADMIN12896"></a><div class="props_rev_3"><a id="GUID-697B86CC-875C-4F68-AF80-49B41F33AE45" name="GUID-697B86CC-875C-4F68-AF80-49B41F33AE45"></a><h4 id="ADMIN-GUID-697B86CC-875C-4F68-AF80-49B41F33AE45" class="sect4"><span class="enumeration_section">20.15.1</span>关于外部表</h4>
                  <div>
                     <p>Oracle数据库允许您对外部表中的数据进行只读访问。<span class="bold">外部表</span>定义为不驻留在数据库中的表，它们可以是提供访问驱动程序的任何格式。
                     </p>
                     <p>通过为数据库提供描述外部表的元数据，数据库能够公开外部表中的数据，就好像它是驻留在常规数据库表中的数据一样。可以使用SQL直接和并行查询外部数据。</p>
                     <p>例如，您可以选择，加入或排序外部表数据。您还可以为外部表创建视图和同义词。但是，在外部表上不能进行DML操作（ <code class="codeph">UPDATE</code> ， <code class="codeph">INSERT</code>或<code class="codeph">DELETE</code> ），也不能创建索引。
                     </p>
                     <p>外部表提供了一个框架，用于将任意<code class="codeph">SELECT</code>语句的结果卸载为可由Oracle Data Pump使用的独立于平台的Oracle专有格式。外部表为执行数据仓库常见的基本提取，转换和加载（ETL）任务提供了有价值的方法。
                     </p>
                     <p>使用<code class="codeph">CREATE TABLE...定义外部表的元数据<code class="codeph">CREATE TABLE...ORGANIZATION EXTERNAL</code>声明。可以将此外部表定义视为允许对外部数据运行任何SQL查询而无需首先将外部数据加载到数据库中的视图。访问驱动程序是用于读取表中外部数据的机制。使用外部表卸载数据时，将根据<code class="codeph">SELECT</code>语句中的数据类型自动创建元数据。
                     </p>
                     <p>Oracle数据库为外部表提供访问驱动程序。默认访问驱动程序是<code class="codeph">ORACLE_LOADER</code> ，它允许使用Oracle加载程序技术从外部文件读取数据。<code class="codeph">ORACLE_LOADER</code>访问驱动程序提供数据映射功能，这些功能是SQL * Loader实用程序的控制文件语法的子集。另一个访问驱动程序<code class="codeph">ORACLE_DATAPUMP</code>允许您卸载数据，即从数据库读取数据并将其插入由一个或多个外部文件表示的外部表中，然后将其重新加载到Oracle数据库中。
                     </p>
                     <p>从Oracle Database 12 <span class="italic">c</span>第2版（12.2）开始，可以使用新的访问驱动程序<code class="codeph">ORACLE_HIVE</code>和<code class="codeph">ORACLE_HDFS</code> 。<code class="codeph">ORACLE_HIVE</code>访问驱动程序可以提取存储在Apache Hive中的数据。<code class="codeph">ORACLE_HDFS</code>访问驱动程序可以提取存储在Hadoop分布式文件系统（HDFS）中的数据。
                     </p>
                     <p>从Oracle Database 18c开始，支持内联外部表。内联外部表使外部表的运行时定义成为SQL语句的一部分，而无需将外部表创建为数据字典中的持久对象。</p>
                     <div class="infoboxnote" id="GUID-697B86CC-875C-4F68-AF80-49B41F33AE45__GUID-F00877C3-7F16-48B7-85CC-D281F6EB6D2C">
                        <p class="notep1">注意：</p>
                        <p>收集外部表的统计信息不支持<code class="codeph">ANALYZE</code>语句。请改用<code class="codeph">DBMS_STATS</code>包。
                        </p>
                     </div>
                  </div>
                  <div>
                     <div class="infoboxnotealso" id="GUID-697B86CC-875C-4F68-AF80-49B41F33AE45__GUID-3294389A-4023-4D78-8594-857689BF8A96">
                        <p class="notep1">也可以看看：</p>
                        <ul style="list-style-type:disc">
                           <li>
                              <p>适用于外部表的限制的<a href="https://www.oracle.com/pls/topic/lookup?ctx=en/database/oracle/oracle-database/19/admin&amp;id=SQLRF54503" target="_blank"><span class="italic">Oracle数据库SQL语言参考</span></a></p>
                           </li>
                           <li>
                              <p>有关访问驱动<a href="https://www.oracle.com/pls/topic/lookup?ctx=en/database/oracle/oracle-database/19/admin&amp;id=SUTIL011" target="_blank"><span class="italic">程序</span></a>的信息，请<a href="https://www.oracle.com/pls/topic/lookup?ctx=en/database/oracle/oracle-database/19/admin&amp;id=SUTIL011" target="_blank"><span class="italic">参见Oracle Database Utilities</span></a></p>
                           </li>
                           <li>
                              <p><a href="https://www.oracle.com/pls/topic/lookup?ctx=en/database/oracle/oracle-database/19/admin&amp;id=DWHSG8312" target="_blank"><span class="italic">“Oracle数据库数据仓库指南”，</span></a>以获取有关在数据仓库环境中为ETL使用外部表的信息</p>
                           </li>
                           <li>
                              <p>有关使用<code class="codeph">DBMS_STATS</code>程序包的信息，请<code class="codeph">DBMS_STATS</code> <a href="https://www.oracle.com/pls/topic/lookup?ctx=en/database/oracle/oracle-database/19/admin&amp;id=TGSQL389" target="_blank"><span class="italic">“Oracle数据库SQL调优指南”</span></a></p>
                           </li>
                           <li>
                              <p>有关<code class="codeph">ORACLE_HIVE</code>和<code class="codeph">ORACLE_HDFS</code>驱动程序的信息以及有关外部表的更多信息，请<code class="codeph">ORACLE_HDFS</code> <a href="https://www.oracle.com/pls/topic/lookup?ctx=en/database/oracle/oracle-database/19/admin&amp;id=SUTIL-GUID-038ED956-A6EE-4C6D-B7C9-0D406B8088B6" target="_blank"><span><cite>Oracle数据库实用程序</cite></span></a></p>
                           </li>
                        </ul>
                     </div>
                     <div class="familylinks">
                        <div class="parentlink">
                           <p><strong>父主题：</strong> <a href="managing-tables.html#GUID-F6948F0E-0557-4C42-9145-1897DE974CC3" title="外部表是不驻留在数据库中的表，但位于数据库外部的外部文件中，例如操作系统文件或Hadoop分布式文件系统（HDFS）文件。">管理外部表</a></p>
                        </div>
                     </div>
                  </div>
                  
               </div><a id="ADMIN12642"></a><a id="ADMIN11705"></a><div class="props_rev_3"><a id="GUID-4BABDCB5-640B-46B3-A392-EED9C7B542CB" name="GUID-4BABDCB5-640B-46B3-A392-EED9C7B542CB"></a><h4 id="ADMIN-GUID-4BABDCB5-640B-46B3-A392-EED9C7B542CB" class="sect4"><span class="enumeration_section">20.15.2</span>创建外部表</h4>
                  <div>
                     <p>您可以使用带有<code class="codeph">ORGANIZATION</code> <code class="codeph">EXTERNAL</code>子句的<code class="codeph">CREATE</code> <code class="codeph">TABLE</code>语句创建外部表。此语句仅在数据字典中创建元数据。
                     </p>
                     <div class="section">
                        <div class="infoboxnote" id="GUID-4BABDCB5-640B-46B3-A392-EED9C7B542CB__GUID-18248F77-B086-4F1A-91FF-0E10F936AEDB">
                           <p class="notep1">注意：</p>
                           <ul style="list-style-type:disc">
                              <li>
                                 <p>从Oracle Database 12 <span class="italic">c</span>第2版（12.2）开始，您可以对外部表进行分区，以便为大量数据提供快速查询性能和增强的数据维护。
                                 </p>
                              </li>
                              <li>
                                 <p>外部表可以有虚拟列。但是，无法使用<code class="codeph"><span class="codeinlineitalic">evaluation_edition_clause</span></code>或<code class="codeph"><span class="codeinlineitalic">unusable_edition_clause</span></code>定义外部表中的虚拟列。
                                 </p>
                              </li>
                           </ul>
                        </div>
                        <p>以下示例创建外部表，然后将数据上载到数据库表。或者，您可以通过指定<code class="codeph">CREATE TABLE</code>语句的<code class="codeph">AS</code> <span class="italic"><code class="codeph">subquery</code></span>子句来通过外部表框架卸载数据。外部表数据泵卸载只能使用<code class="codeph">ORACLE_DATAPUMP</code>访问驱动程序。
                        </p>
                     </div>
                     <!-- class="section" -->
                     <div class="section">
                        <p class="subhead3" id="GUID-4BABDCB5-640B-46B3-A392-EED9C7B542CB__GUID-D93EE6CC-82A7-418E-9193-720D8051C0BE">示例：创建外部表并加载数据</p>
                     </div>
                     <!-- class="section" -->
                     <div class="section">
                        <p>在此示例中，外部表的数据驻留在两个文本文件<code class="codeph">empxt1.dat</code>和<code class="codeph">empxt2.dat</code> 。
                        </p>
                        <p>文件<code class="codeph">empxt1.dat</code>包含以下示例数据：</p><pre class="oac_no_warn" dir="ltr">360，Jane，Janus，ST_CLERK，121,17-MAY-2001,3000,0,50，jjanus 361，Mark，Jasper，SA_REP，145,17-MAY-2001,8000，.1,80，mjasper 362，Brenda ，Starr，AD_ASST，200,17-MAY-2001,5500,0,10，bstarr 363，Alex，Alda，AC_MGR，145,17-MAY-2001,9000，.15,80，aalda</pre><p>文件<code class="codeph">empxt2.dat</code>包含以下示例数据：</p><pre class="oac_no_warn" dir="ltr">401，Jesse，Cromwell，HR_REP，203,17-MAY-2001,7000,0,40，jcromwel 402，Abby，Applegate，IT_PROG，103,17-MAY-2001,9000，.2,60，aapplega 403，Carol ，Cousins，AD_VP，100,17-MAY-2001,27000，.3,90，ccousins 404，John，Richardson，AC_ACCOUNT,205,17-MAY-2001,5000,0,110，jrichard</pre><p>以下SQL语句在<code class="codeph">hr</code>模式中创建名为<code class="codeph">admin_ext_employees</code>的外部表，并将外部表中的数据加载到<code class="codeph">hr.employees</code>表中。
                        </p><pre class="oac_no_warn" dir="ltr">CONNECT / AS SYSDBA; - 设置目录并授予对hr CREATE OR REPLACE DIRECTORY admin_dat_dir AS'/ flatfiles / data'的访问权限;创建或替换目录admin_log_dir AS'/ flatfiles / log';创建或替换目录admin_bad_dir AS'/ flatfiles / bad'; GRANT READ ON DIRECTORY admin_dat_dir TO hr; GRANT WRITE ON DIRECTORY admin_log_dir TO hr; GRANT WRITE ON DIRECTORY admin_bad_dir TO hr; - 小时连接。出现提示时提供用户密码（hr）。CONNECT hr  - 创建外部表CREATE TABLE admin_ext_employees（employee_id NUMBER（4），first_name VARCHAR2（20），last_name VARCHAR2（25），job_id VARCHAR2（10），manager_id NUMBER（4），hire_date DATE，salary NUMBER（8， 2），commission_pct NUMBER（2,2），department_id NUMBER（4），电子邮件VARCHAR2（25））ORGANIZATION EXTERNAL（类型ORACLE_LOADER DEFAULT目录admin_dat_dir访问参数（由换行符badfile admin_bad_dir分隔的记录：'empxt％a_％p.bad' logfile admin_log_dir：'empxt％a_％p.log'字段以'，'缺少的字段值终止为空（employee_id，first_name，last_name，job_id，manager_id，hire_date char date_format date mask“dd-mon-yyyy”，salary，commission_pct ，department_id，email））LOCATION（'empxt1.dat'，'empxt2.dat'））PARALLEL REJECT LIMIT UNLIMITED; - 启用并行加载（如果要加载大量数据，则很好）ALTER SESSION ENABLE PARALLEL DML; - 在hr employees表中加载数据INSERT INTO employees（employee_id，first_name，last_name，job_id，manager_id，hire_date，salary，commission_pct，department_id，email）SELECT * FROM admin_ext_employees;</pre><p>以下段落包含有关此示例的描述性信息。</p>
                        <p>此示例中的前几个语句为包含数据源的操作系统目录以及访问参数中指定的错误记录和日志文件创建目录对象。您还必须根据需要授予<code class="codeph">READ</code>或<code class="codeph">WRITE</code>目录对象权限。
                        </p>
                        <div class="infoboxnote" id="GUID-4BABDCB5-640B-46B3-A392-EED9C7B542CB__GUID-260CAC28-C529-4A2A-BB14-67C896934643">
                           <p class="notep1">注意：</p>
                           <p>创建目录对象或BFILE时，请确保满足以下条件：</p>
                           <ul style="list-style-type:disc">
                              <li>
                                 <p>操作系统文件不能是符号链接或硬链接。</p>
                              </li>
                              <li>
                                 <p>Oracle数据库目录对象中指定的操作系统目录路径必须是现有的OS目录路径。</p>
                              </li>
                              <li>
                                 <p>目录对象中指定的操作系统目录路径不应在其组件中包含任何符号链接。</p>
                              </li>
                           </ul>
                        </div>
                        <p><code class="codeph">TYPE</code>规范指示外部表的访问驱动程序。访问驱动程序是解释数据库外部数据的API。如果省略<code class="codeph">TYPE</code>规范，则<code class="codeph">ORACLE_LOADER</code>是默认的访问驱动程序。如果指定<code class="codeph">AS</code> <span class="italic"><code class="codeph">subquery</code></span>子句以从一个Oracle数据库卸载数据并将其重新加载到相同或不同的Oracle数据库中，则必须指定<code class="codeph">ORACLE_DATAPUMP</code>访问驱动程序。
                        </p>
                        <p>在<code class="codeph">ACCESS PARAMETERS</code>子句中指定的<code class="codeph">ACCESS PARAMETERS</code>对数据库是不透明的。这些访问参数由访问驱动程序定义，并在访问外部表时由数据库提供给访问驱动程序。有关<code class="codeph">ORACLE_LOADER</code>访问参数的说明，请参见<a href="https://www.oracle.com/pls/topic/lookup?ctx=en/database/oracle/oracle-database/19/admin&amp;id=SUTIL012" target="_blank"><span class="italic">Oracle数据库实用程序</span></a> 。
                        </p>
                        <p><code class="codeph">PARALLEL</code>子句启用对数据源的并行查询。默认情况下，并行性粒度是数据源，但只要有可能，就会实现数据源中的并行访问。例如，如果指定了<code class="codeph">PARALLEL=3</code> ，那么多个并行执行服务器可能正在处理数据源。但是，只有满足以下所有条件时，访问驱动程序才会提供数据源中的并行访问：</p>
                        <ul style="list-style-type:disc">
                           <li>
                              <p>媒体允许在数据源中随机定位。</p>
                           </li>
                           <li>
                              <p>可以从随机位置找到记录边界。</p>
                           </li>
                           <li>
                              <p>数据文件足够大，可以分成多个块。</p>
                              <div class="infoboxnote" id="GUID-4BABDCB5-640B-46B3-A392-EED9C7B542CB__GUID-9978E83D-939A-4B6D-92EA-DF750A8B6C45">
                                 <p class="notep1">注意：</p>
                                 <p>指定<code class="codeph">PARALLEL</code>子句<span class="italic">仅</span>在处理大量数据<span class="italic">时才</span>有价值。否则，不建议指定<code class="codeph">PARALLEL</code>子句，这样做可能是有害的。
                                 </p>
                              </div>
                           </li>
                        </ul>
                        <p><code class="codeph">REJECT</code> <code class="codeph">LIMIT</code>子句指定在查询外部数据期间可能发生的错误数量没有限制。对于并行访问， <code class="codeph">REJECT</code> <code class="codeph">LIMIT</code>独立地应用于每个并行执行服务器。例如，如果指定<code class="codeph">REJECT</code> <code class="codeph">LIMIT</code>为10，则每个并行查询过程最多可允许10次拒绝。因此，如果平行度为2且<code class="codeph">REJECT</code> <code class="codeph">LIMIT</code>为10，则该语句可能会因10到20次拒绝而失败。如果一个并行服务器处理所有10个拒绝，则达到限制，并终止该语句。但是，一个并行执行服务器可以处理九个拒绝，另一个并行执行服务器可以处理九个拒绝，该语句将成功拒绝18个。因此，并行查询中<code class="codeph">REJECT</code> <code class="codeph">LIMIT</code>的唯一精确强制值为<code class="codeph">0</code>且<code class="codeph">UNLIMITED</code> 。</p>
                        <p>在此示例中， <code class="codeph">INSERT</code> <code class="codeph">INTO</code> <code class="codeph">TABLE</code>语句生成从外部数据源到Oracle数据库SQL引擎的数据流，在该引擎中处理数据。当访问驱动程序从外部表源解析数据并将其提供给外部表接口时，外部数据将从其外部表示转换为其Oracle数据库内部数据类型。
                        </p>
                     </div>
                     <!-- class="section" -->
                  </div>
                  <div>
                     <div class="infoboxnotealso" id="GUID-4BABDCB5-640B-46B3-A392-EED9C7B542CB__GUID-8E3B0300-71DA-4BF2-8644-F16DC7B17B01">
                        <p class="notep1">也可以看看：</p>
                        <p><a href="https://www.oracle.com/pls/topic/lookup?ctx=en/database/oracle/oracle-database/19/admin&amp;id=SQLRF01402" target="_blank"><span class="italic">“Oracle数据库SQL语言参考”</span></a>提供了用于创建外部表的<code class="codeph">CREATE TABLE</code>语句的语法的详细信息，并指定了对子句使用的限制</p>
                     </div>
                     <div class="familylinks">
                        <div class="parentlink">
                           <p><strong>父主题：</strong> <a href="managing-tables.html#GUID-F6948F0E-0557-4C42-9145-1897DE974CC3" title="外部表是不驻留在数据库中的表，但位于数据库外部的外部文件中，例如操作系统文件或Hadoop分布式文件系统（HDFS）文件。">管理外部表</a></p>
                        </div>
                     </div>
                  </div>
                  
               </div><a id="ADMIN13066"></a><a id="ADMIN11706"></a><div class="props_rev_3"><a id="GUID-84C934CC-2116-482A-B47A-558F643437DC" name="GUID-84C934CC-2116-482A-B47A-558F643437DC"></a><h4 id="ADMIN-GUID-84C934CC-2116-482A-B47A-558F643437DC" class="sect4"><span class="enumeration_section">20.15.3</span>更改外部表</h4>
                  <div>
                     <p>您可以使用<code class="codeph">ALTER TABLE</code>语句修改外部表。
                     </p>
                     <div class="section">
                        <p>您可以使用<a href="managing-tables.html#GUID-84C934CC-2116-482A-B47A-558F643437DC__BABGCGDH" title="第1列列出了可用于更改外部表特征的ALTER TABLE子句。第2列描述了子句的用法，第3列提供了示例。">表20-6中</a>显示的任何<code class="codeph">ALTER TABLE</code>子句来更改外部表的特征。不允许其他条款。
                        </p>
                        <div class="tblformal" id="GUID-84C934CC-2116-482A-B47A-558F643437DC__BABGCGDH">
                           <p class="titleintable">表20-6外部表的ALTER TABLE子句</p>
                           <table cellpadding="4" cellspacing="0" class="Formal" title="外部表的ALTER TABLE子句" width="100%" border="1" summary="Column 1 lists the ALTER TABLE clauses that can be used to change the characteristics of an exernal table. Column 2 describes the clause usage, and column 3 provides examples." frame="hsides" rules="rows">
                              <thead>
                                 <tr align="left" valign="top">
                                    <th align="left" valign="bottom" width="22%" id="d192334e20894">ALTER TABLE子句</th>
                                    <th align="left" valign="bottom" width="39%" id="d192334e20897">描述</th>
                                    <th align="left" valign="bottom" width="38%" id="d192334e20900">例</th>
                                 </tr>
                              </thead>
                              <tbody>
                                 <tr align="left" valign="top">
                                    <td align="left" valign="top" width="22%" id="d192334e20905" headers="d192334e20894 ">
                                       <p><code class="codeph">拒绝限制</code> 
                                       </p>
                                    </td>
                                    <td align="left" valign="top" width="39%" headers="d192334e20905 d192334e20897 ">
                                       <p>更改拒绝限制。默认值为<code class="codeph">0</code> 。
                                       </p>
                                    </td>
                                    <td align="left" valign="top" width="38%" headers="d192334e20905 d192334e20900 "><pre class="pre codeblock"><code>ALTER TABLE admin_ext_employees REJECT LIMIT 100;</code></pre></td>
                                 </tr>
                                 <tr align="left" valign="top">
                                    <td align="left" valign="top" width="22%" id="d192334e20920" headers="d192334e20894 ">
                                       <p><code class="codeph">PROJECT</code> <code class="codeph">COLUMN</code></p>
                                    </td>
                                    <td align="left" valign="top" width="39%" headers="d192334e20920 d192334e20897 ">
                                       <p>确定访问驱动程序如何验证后续查询中的行：</p>
                                       <ul style="list-style-type:disc">
                                          <li>
                                             <p><code class="codeph">PROJECT</code> <code class="codeph">COLUMN</code> <code class="codeph">REFERENCED</code> ：访问驱动程序仅处理查询的选择列表中的列。从同一外部表查询不同的列列表时，此设置可能无法提供一致的行集。
                                             </p>
                                          </li>
                                          <li>
                                             <p><code class="codeph">PROJECT</code> <code class="codeph">COLUMN</code> <code class="codeph">ALL</code> ：访问驱动程序处理外部表上定义的所有列。查询外部表时，此设置始终提供一致的行集。这是默认值。
                                             </p>
                                          </li>
                                       </ul>
                                    </td>
                                    <td align="left" valign="top" width="38%" headers="d192334e20920 d192334e20900 "><pre class="pre codeblock"><code>ALTER TABLE admin_ext_employees PROJECT COLUMN REFERENCED; ALTER TABLE admin_ext_employees PROJECT COLUMN ALL;</code></pre></td>
                                 </tr>
                                 <tr align="left" valign="top">
                                    <td align="left" valign="top" width="22%" id="d192334e20957" headers="d192334e20894 ">
                                       <p><code class="codeph">默认目录</code> 
                                       </p>
                                    </td>
                                    <td align="left" valign="top" width="39%" headers="d192334e20957 d192334e20897 ">
                                       <p>更改默认目录规范。</p>
                                    </td>
                                    <td align="left" valign="top" width="38%" headers="d192334e20957 d192334e20900 "><pre class="pre codeblock"><code>ALTER TABLE admin_ext_employees DEFAULT DIRECTORY admin_dat2_dir;</code></pre></td>
                                 </tr>
                                 <tr align="left" valign="top">
                                    <td align="left" valign="top" width="22%" id="d192334e20969" headers="d192334e20894 ">
                                       <p><code class="codeph">访问参数</code></p>
                                    </td>
                                    <td align="left" valign="top" width="39%" headers="d192334e20969 d192334e20897 ">
                                       <p>允许更改访问参数，而无需删除和重新创建外部表元数据。</p>
                                    </td>
                                    <td align="left" valign="top" width="38%" headers="d192334e20969 d192334e20900 "><pre class="pre codeblock"><code>ALTER TABLE admin_ext_employees访问参数（字段由';'终止）;</code></pre></td>
                                 </tr>
                                 <tr align="left" valign="top">
                                    <td align="left" valign="top" width="22%" id="d192334e20980" headers="d192334e20894 ">
                                       <p><code class="codeph">地点</code></p>
                                    </td>
                                    <td align="left" valign="top" width="39%" headers="d192334e20980 d192334e20897 ">
                                       <p>允许更改数据源，而无需删除和重新创建外部表元数据。</p>
                                    </td>
                                    <td align="left" valign="top" width="38%" headers="d192334e20980 d192334e20900 "><pre class="pre codeblock"><code>ALTER TABLE admin_ext_employees LOCATION（'empxt3.txt'，'empxt4.txt'）;</code></pre></td>
                                 </tr>
                                 <tr align="left" valign="top">
                                    <td align="left" valign="top" width="22%" id="d192334e20991" headers="d192334e20894 ">
                                       <p><code class="codeph">平行</code></p>
                                    </td>
                                    <td align="left" valign="top" width="39%" headers="d192334e20991 d192334e20897 ">
                                       <p>与常规表没有区别。允许更改并行度。</p>
                                    </td>
                                    <td align="left" valign="top" width="38%" headers="d192334e20991 d192334e20900 ">
                                       <p>没有新的语法</p>
                                    </td>
                                 </tr>
                                 <tr align="left" valign="top">
                                    <td align="left" valign="top" width="22%" id="d192334e21002" headers="d192334e20894 ">
                                       <p><code class="codeph">添加栏目</code></p>
                                    </td>
                                    <td align="left" valign="top" width="39%" headers="d192334e21002 d192334e20897 ">
                                       <p>与常规表没有区别。允许将列添加到外部表。不允许使用虚拟列。</p>
                                    </td>
                                    <td align="left" valign="top" width="38%" headers="d192334e21002 d192334e20900 ">
                                       <p>没有新的语法</p>
                                    </td>
                                 </tr>
                                 <tr align="left" valign="top">
                                    <td align="left" valign="top" width="22%" id="d192334e21013" headers="d192334e20894 ">
                                       <p><code class="codeph">修改栏目</code></p>
                                    </td>
                                    <td align="left" valign="top" width="39%" headers="d192334e21013 d192334e20897 ">
                                       <p>与常规表没有区别。允许修改外部表列。不允许使用虚拟列。</p>
                                    </td>
                                    <td align="left" valign="top" width="38%" headers="d192334e21013 d192334e20900 ">
                                       <p>没有新的语法</p>
                                    </td>
                                 </tr>
                                 <tr align="left" valign="top">
                                    <td align="left" valign="top" width="22%" id="d192334e21024" headers="d192334e20894 ">
                                       <p><code class="codeph">设置未使用</code></p>
                                    </td>
                                    <td align="left" valign="top" width="39%" headers="d192334e21024 d192334e20897 ">
                                       <p>透明地转换为<code class="codeph">ALTER TABLE DROP COLUMN</code>命令。由于外部表仅包含数据库中的元数据，因此<code class="codeph">DROP COLUMN</code>命令与<code class="codeph">SET UNUSED</code>命令等效执行。
                                       </p>
                                    </td>
                                    <td align="left" valign="top" width="38%" headers="d192334e21024 d192334e20900 ">
                                       <p>没有新的语法</p>
                                    </td>
                                 </tr>
                                 <tr align="left" valign="top">
                                    <td align="left" valign="top" width="22%" id="d192334e21044" headers="d192334e20894 ">
                                       <p><code class="codeph">DROP COLUMN</code></p>
                                    </td>
                                    <td align="left" valign="top" width="39%" headers="d192334e21044 d192334e20897 ">
                                       <p>与常规表没有区别。允许删除外部表列。</p>
                                    </td>
                                    <td align="left" valign="top" width="38%" headers="d192334e21044 d192334e20900 ">
                                       <p>没有新的语法</p>
                                    </td>
                                 </tr>
                                 <tr align="left" valign="top">
                                    <td align="left" valign="top" width="22%" id="d192334e21055" headers="d192334e20894 ">
                                       <p><code class="codeph">重命名</code></p>
                                    </td>
                                    <td align="left" valign="top" width="39%" headers="d192334e21055 d192334e20897 ">
                                       <p>与常规表没有区别。允许重命名外部表。</p>
                                    </td>
                                    <td align="left" valign="top" width="38%" headers="d192334e21055 d192334e20900 ">
                                       <p>没有新的语法</p>
                                    </td>
                                 </tr>
                              </tbody>
                           </table>
                        </div>
                        <!-- class="inftblhruleinformal" -->
                     </div>
                     <!-- class="section" -->
                  </div>
                  <div>
                     <div class="familylinks">
                        <div class="parentlink">
                           <p><strong>父主题：</strong> <a href="managing-tables.html#GUID-F6948F0E-0557-4C42-9145-1897DE974CC3" title="外部表是不驻留在数据库中的表，但位于数据库外部的外部文件中，例如操作系统文件或Hadoop分布式文件系统（HDFS）文件。">管理外部表</a></p>
                        </div>
                     </div>
                  </div>
                  
               </div><a id="ADMIN12898"></a><div class="props_rev_3"><a id="GUID-67A4ED3F-0366-4E59-A79C-45E6997E43FA" name="GUID-67A4ED3F-0366-4E59-A79C-45E6997E43FA"></a><h4 id="ADMIN-GUID-67A4ED3F-0366-4E59-A79C-45E6997E43FA" class="sect4"><span class="enumeration_section">20.15.4</span>预处理外部表</h4>
                  <div>
                     <p>外部表可以由用户提供的预处理程序预处理。通过使用预处理程序，用户可以使用不是驱动程序支持的格式的文件中的数据。</p>
                     <div class="section">
                        <div class="infoboxnote" id="GUID-67A4ED3F-0366-4E59-A79C-45E6997E43FA__GUID-382C2FF9-5EBC-48C8-B314-F0906978863E">
                           <p class="notep1">警告：</p>
                           <p>使用<code class="codeph">PREPROCESSOR</code>子句时需要考虑安全问题。有关更多信息，请参见<a href="https://www.oracle.com/pls/topic/lookup?ctx=en/database/oracle/oracle-database/19/admin&amp;id=DBSEG10007" target="_blank"><span class="italic">Oracle数据库安全指南</span></a>
                           </p>
                        </div>
                        <p>例如，用户可能想要访问以压缩格式存储的数据。为<code class="codeph">ORACLE_LOADER</code>访问驱动程序指定解压缩程序允许在访问驱动程序处理数据时解压缩数据。
                        </p>
                        <p>要使用预处理功能，您必须指定<code class="codeph">PREPROCESSOR</code>中的访问参数条款<code class="codeph">ORACLE_LOADER</code>访问驱动程序。预处理器必须是目录对象，访问外部表的用户必须具有目录对象的<code class="codeph">EXECUTE</code>特权。以下示例包含<code class="codeph">PREPROCESSOR</code>子句，并指定目录和预处理程序。
                        </p><pre class="oac_no_warn" dir="ltr">CREATE TABLE sales_transactions_ext（PROD_ID NUMBER，CUST_ID NUMBER，TIME_ID DATE，CHANNEL_ID CHAR，PROMO_ID NUMBER，QUANTITY_SOLD NUMBER，AMOUNT_SOLD NUMBER（10,2），UNIT_COST NUMBER（10,2），UNIT_PRICE NUMBER（10,2））ORGANIZATION external（TYPE oracle_loader DEFAULT DIRECTORY data_file_dir访问参数（记录由NEWLINE CHARACTERSET AL32UTF8预处理程序删除<span class="bold"><code class="codeph">PREPROCESSOR exec_file_dir:'zcat'</code></span> zcat'BADFILE log_file_dir：'sh_sales.bad_xt'logFILE log_file_dir：'sh_sales.log_xt'FIELDS TERMINATED BY“|”LDRTRIM（PROD_ID，CUST_ID，TIME_ID，CHANNEL_ID ，PROMO_ID，QUANTITY_SOLD，AMOUNT_SOLD，UNIT_COST，UNIT_PRICE））location（'sh_sales.dat.gz'））REJECT LIMIT UNLIMITED;</pre><p><code class="codeph">PREPROCESSOR</code>子句不适用于使用Oracle Database Vault的数据库。
                        </p>
                        <div class="infoboxnote" id="GUID-67A4ED3F-0366-4E59-A79C-45E6997E43FA__GUID-226216D9-4F3A-4284-8939-2452F9BBB2EC">
                           <p class="notep1">注意：</p>在Windows平台上，预处理程序必须具有<code class="codeph">.bat</code>或<code class="codeph">.cmd</code>扩展名。
                        </div>
                     </div>
                     <!-- class="section" -->
                  </div>
                  <div>
                     <div class="infoboxnotealso" id="GUID-67A4ED3F-0366-4E59-A79C-45E6997E43FA__GUID-44361B4F-DAEE-428E-9258-9CC38E9AB97D">
                        <p class="notep1">也可以看看：</p>
                        <p></p>
                        <ul style="list-style-type:disc">
                           <li>
                              <p><a href="../sutil/oracle_loader-access-driver.html#SUTIL1385" target="_blank"><span class="italic">Oracle数据库实用程序</span></a>提供有关<code class="codeph">PREPROCESSOR</code>子句的更多信息</p>
                           </li>
                           <li>
                              <p>有关<code class="codeph">PREPROCESSOR</code>子句的安全隐患的更多信息，请<code class="codeph">PREPROCESSOR</code> <a href="../dbseg/keeping-your-oracle-database-secure.html#DBSEG10007" target="_blank"><span class="italic">“Oracle数据库安全指南”</span></a></p>
                           </li>
                        </ul>
                     </div>
                     <div class="familylinks">
                        <div class="parentlink">
                           <p><strong>父主题：</strong> <a href="managing-tables.html#GUID-F6948F0E-0557-4C42-9145-1897DE974CC3" title="外部表是不驻留在数据库中的表，但位于数据库外部的外部文件中，例如操作系统文件或Hadoop分布式文件系统（HDFS）文件。">管理外部表</a></p>
                        </div>
                     </div>
                  </div>
                  
               </div>
               <div class="sect3"><a id="GUID-6E4219FF-A557-452E-A6E9-96C38BA87EE0" name="GUID-6E4219FF-A557-452E-A6E9-96C38BA87EE0"></a><h4 id="ADMIN-GUID-6E4219FF-A557-452E-A6E9-96C38BA87EE0" class="sect4"><span class="enumeration_section">20.15.5</span>覆盖查询中外部表的参数</h4>
                  <div>
                     <p><code class="codeph">SELECT</code>语句的<code class="codeph">EXTERNAL MODIFY</code>子句修改外部表参数。
                     </p>
                     <div class="section"> 
                        <p>您可以在<code class="codeph">EXTERNAL MODIFY</code>子句中覆盖外部表的以下子句：</p>
                        <ul style="list-style-type:disc">
                           <li>
                              <p><code class="codeph">默认目录</code></p>
                           </li>
                           <li>
                              <p><code class="codeph">地点</code></p>
                           </li>
                           <li>
                              <p><code class="codeph">访问参数</code></p>
                           </li>
                           <li>
                              <p><code class="codeph">拒绝限制</code></p>
                           </li>
                        </ul>
                        <p>您可以在单个查询中修改多个子句。可以为<code class="codeph">LOCATION</code>和<code class="codeph">REJECT LIMIT</code>指定绑定变量，但不能为<code class="codeph">DEFAULT DIRECTORY</code>或<code class="codeph">ACCESS PARAMETERS</code>指定绑定变量。</p>
                        <p>修改仅适用于查询。它们不会永久影响表格。</p>
                        <p>对于分区外部表，只能覆盖表级子句。</p>
                     </div>
                     <!-- class="section" -->
                     <ol>
                        <li><span>以具有查询外部表所需特权的用户身份连接到数据库。</span></li>
                        <li><span>使用<code class="codeph">EXTERNAL MODIFY</code>子句在外部表上发出<code class="codeph">SELECT</code>语句。</span></li>
                     </ol>
                     <div class="example" id="GUID-6E4219FF-A557-452E-A6E9-96C38BA87EE0__GUID-AD7B486B-0E52-47DB-B5B3-92D635510918">
                        <p class="titleinexample">示例20-21在查询中覆盖外部表的参数</p>
                        <p>假设名为<code class="codeph">sales_external</code>的外部表将<code class="codeph">REJECT LIMIT</code>设置为<code class="codeph">25</code> 。以下查询将此设置修改为<code class="codeph">REJECT LIMIT UNLIMITED</code> ：</p><pre class="pre codeblock"><code>SELECT * FROM sales_external EXTERNAL MODIFY（LOCATION（'sales_9.csv'）REJECT LIMIT UNLIMITED）;</code></pre></div>
                     <!-- class="example" -->
                  </div>
                  <div>
                     <div class="familylinks">
                        <div class="parentlink">
                           <p><strong>父主题：</strong> <a href="managing-tables.html#GUID-F6948F0E-0557-4C42-9145-1897DE974CC3" title="外部表是不驻留在数据库中的表，但位于数据库外部的外部文件中，例如操作系统文件或Hadoop分布式文件系统（HDFS）文件。">管理外部表</a></p>
                        </div>
                     </div>
                  </div>
                  
               </div>
               <div class="props_rev_3"><a id="GUID-621E5DDE-36D9-4661-9D14-80DE35858C3F" name="GUID-621E5DDE-36D9-4661-9D14-80DE35858C3F"></a><h4 id="ADMIN-GUID-621E5DDE-36D9-4661-9D14-80DE35858C3F" class="sect4"><span class="enumeration_section">20.15.6</span>使用内联外部表</h4>
                  <div>
                     <p>内联外部表使外部表的运行时定义成为SQL语句的一部分，而无需将外部表创建为数据字典中的持久对象。</p>
                     <div class="section">
                        <p>对于内联外部表，可以在运行时在<code class="codeph">SELECT</code>语句中使用与创建具有<code class="codeph">CREATE TABLE</code>语句的外部表相同的语法。在查询块的<code class="codeph">FROM</code>子句中指定内联外部表。包含内联外部表的查询还可以包括用于连接，聚合等的常规表。
                        </p>
                        <p>以下SQL语句对外部数据执行运行时查询：</p><pre class="pre codeblock"><code>SELECT * FROM EXTERNAL（（time_id DATE NOT NULL，prod_id INTEGER NOT NULL，quantity_sold NUMBER（10,2），amount_sold NUMBER（10,2））TYPE ORACLE_LOADER DEFAULT DIRECTORY data_dir1访问参数（记录由'|'终止的NEWLINE字段删除的记录）LOCATION（'sales_9.csv'）REJECT LIMIT UNLIMITED）sales_external;</code></pre><p>虽然之前未创建名为<code class="codeph">sales_external</code>表，但此查询将读取外部数据并返回结果。
                        </p>
                        <div class="infoboxnote" id="GUID-621E5DDE-36D9-4661-9D14-80DE35858C3F__GUID-B2F9A4C6-EEA2-4CF4-9C94-060A50572ED7">
                           <p class="notep1">注意：</p>
                           <p>内联外部表不支持分区。查询可以控制要扫描的目录和文件，以便可以通过省略查询不需要的文件来完成修剪。</p>
                        </div>
                     </div>
                     <!-- class="section" -->
                  </div>
                  <div>
                     <div class="familylinks">
                        <div class="parentlink">
                           <p><strong>父主题：</strong> <a href="managing-tables.html#GUID-F6948F0E-0557-4C42-9145-1897DE974CC3" title="外部表是不驻留在数据库中的表，但位于数据库外部的外部文件中，例如操作系统文件或Hadoop分布式文件系统（HDFS）文件。">管理外部表</a></p>
                        </div>
                     </div>
                  </div>
                  
               </div>
               <div class="sect3"><a id="GUID-2A801016-0399-4925-AD1B-A02683E81B59" name="GUID-2A801016-0399-4925-AD1B-A02683E81B59"></a><h4 id="ADMIN-GUID-2A801016-0399-4925-AD1B-A02683E81B59" class="sect4"><span class="enumeration_section">20.15.7对</span>外部表进行分区</h4>
                  <div>
                     <p>对于大量数据，外部表的分区可提供快速查询性能和增强的数据维护。</p>
                  </div>
                  <div>
                     <ul class="ullinks">
                        <li class="ulchildlink"><a href="managing-tables.html#GUID-AA3995EC-D147-464A-A9D3-680522B0A1B6">关于分区外部表</a><br>在外部表中对数据进行分区类似于对数据库中存储的表进行分区，但存在一些差异。分区外部表的文件可以存储在文件系统，Apache Hive存储或Hadoop分布式文件系统（HDFS）中。
                        </li>
                        <li class="ulchildlink"><a href="managing-tables.html#GUID-43901AC6-BA21-4B1E-977C-41E031472E8D">分区外部表的限制</a><br>某些限制适用于分区外部表。
                        </li>
                        <li class="ulchildlink"><a href="managing-tables.html#GUID-A20ABC65-3E62-46B8-90D2-85AE6A29697D">创建分区外部表</a><br>您可以通过发出带有<code class="codeph">ORGANIZATION EXTERNAL</code>子句和<code class="codeph">PARTITION BY</code>子句的<code class="codeph">CREATE TABLE</code>语句来创建非复合分区外部表。要创建复合分区外部表，还必须包含<code class="codeph">SUBPARTITION BY</code>子句。
                        </li>
                        <li class="ulchildlink"><a href="managing-tables.html#GUID-E731CB7E-0F74-43DA-93D8-B53E55651B8C">更改分区外部表</a><br>您可以使用<code class="codeph">ALTER TABLE</code>语句来修改分区外部表的表级外部参数，但不能修改分区级外部表和子分区级参数。
                        </li>
                     </ul>
                     <div class="familylinks">
                        <div class="parentlink">
                           <p><strong>父主题：</strong> <a href="managing-tables.html#GUID-F6948F0E-0557-4C42-9145-1897DE974CC3" title="外部表是不驻留在数据库中的表，但位于数据库外部的外部文件中，例如操作系统文件或Hadoop分布式文件系统（HDFS）文件。">管理外部表</a></p>
                        </div>
                     </div>
                  </div>
                  
                  <div class="sect4"><a id="GUID-AA3995EC-D147-464A-A9D3-680522B0A1B6" name="GUID-AA3995EC-D147-464A-A9D3-680522B0A1B6"></a><h5 id="ADMIN-GUID-AA3995EC-D147-464A-A9D3-680522B0A1B6" class="sect5"><span class="enumeration_section">20.15.7.1</span>关于分区外部表</h5>
                     <div>
                        <p>在外部表中对数据进行分区类似于对数据库中存储的表进行分区，但存在一些差异。分区外部表的文件可以存储在文件系统，Apache Hive存储或Hadoop分布式文件系统（HDFS）中。</p>
                        <p>在尝试对外部表进行分区之前，您应该了解与<a href="../vldbg/partition-concepts.html#VLDBG-GUID-EA7EF5CB-DD49-43AF-889A-F83AAC0D7D51" target="_blank"><span><cite>Oracle Database VLDB和Partitioning Guide中的</cite></span></a>分区相关的概念。
                        </p>
                        <p>分区外部表的主要原因是利用分区存储在数据库中的表所提供的相同性能改进。具体来说，分区修剪和分区连接可以提高查询性能。分区修剪意味着查询可以关注外部表中的数据子集而不是所有数据，因为查询只能应用于一个分区。当连接两个表并且两个表在连接键上分区时，或者引用分区表与其父表连接时，可以应用分区连接。分区连接将大型连接分解为在每个分区之间发生的较小连接，从而在更短的时间内完成整个连接。</p>
                        <p>外部表支持大多数数据库中的表支持的分区策略。外部表可以按范围或列表进行分区，并支持复合分区。但是，外部表不支持散列分区。</p>
                        <p>对于存储在数据库中的分区表，使用表空间指定每个分区的存储。对于分区外部表，通过指示每个分区的目录和文件来指定每个分区的存储。</p>
                        <div class="section">
                           <p class="subhead3" id="GUID-AA3995EC-D147-464A-A9D3-680522B0A1B6__GUID-42177466-C84E-42D3-988F-CA84466ADDF7">创建分区外部表的子句</p>
                           <p>创建非分区外部表的子句如下：</p>
                           <ul style="list-style-type:disc">
                              <li>
                                 <p><code class="codeph">TYPE</code> - 指定外部表类型的访问驱动程序（ <code class="codeph">ORACLE_LOADER</code> ， <code class="codeph">ORACLE_DATAPUMP</code> ， <code class="codeph">ORACLE_HIVE</code>和<code class="codeph">ORACLE_HDFS</code> ）。
                                 </p>
                              </li>
                              <li>
                                 <p><code class="codeph">DEFAULT DIRECTORY</code> - 使用目录对象指定用于未明确命名目录对象的所有输入和输出文件的缺省目录。
                                 </p>
                              </li>
                              <li>
                                 <p><code class="codeph">ACCESS PARAMETERS</code> - 描述外部数据源。
                                 </p>
                              </li>
                              <li>
                                 <p><code class="codeph">LOCATION</code> - 指定外部表的文件。
                                 </p>
                              </li>
                              <li>
                                 <p><code class="codeph">REJECT LIMIT</code> - 指定查询外部数据期间可能发生的错误数。
                                 </p>
                              </li>
                           </ul>
                           <p>创建分区外部表时，必须包含定义每个分区的<code class="codeph">PARTITION</code>子句。下表描述了在外部表创建期间每个级别允许的子句。
                           </p>
                           <div class="tblformal" id="GUID-AA3995EC-D147-464A-A9D3-680522B0A1B6__GUID-DC5A13B4-EB08-42AB-A5C2-9DC5741A9753">
                              <p class="titleintable">表20-7外部表子句和分区</p>
                              <table cellpadding="4" cellspacing="0" class="Formal" title="外部表子句和分区" border="1" summary="This table lists each external table clause and describes whether the clause is allowed at each level." frame="hsides" rules="rows">
                                 <thead>
                                    <tr align="left" valign="top">
                                       <th align="left" valign="bottom" id="d192334e21548">条款</th>
                                       <th align="left" valign="bottom" id="d192334e21550">表级别</th>
                                       <th align="left" valign="bottom" id="d192334e21552">分区级别</th>
                                       <th align="left" valign="bottom" id="d192334e21554">分区级别</th>
                                    </tr>
                                 </thead>
                                 <tbody>
                                    <tr align="left" valign="top">
                                       <td align="left" valign="top" id="d192334e21558" headers="d192334e21548 ">
                                          <p><code class="codeph">类型</code></p>
                                       </td>
                                       <td align="left" valign="top" headers="d192334e21558 d192334e21550 ">
                                          <p>允许</p>
                                       </td>
                                       <td align="left" valign="top" headers="d192334e21558 d192334e21552 ">
                                          <p>不允许</p>
                                       </td>
                                       <td align="left" valign="top" headers="d192334e21558 d192334e21554 ">
                                          <p>不允许</p>
                                       </td>
                                    </tr>
                                    <tr align="left" valign="top">
                                       <td align="left" valign="top" id="d192334e21572" headers="d192334e21548 ">
                                          <p><code class="codeph">默认目录</code></p>
                                       </td>
                                       <td align="left" valign="top" headers="d192334e21572 d192334e21550 ">
                                          <p>允许</p>
                                       </td>
                                       <td align="left" valign="top" headers="d192334e21572 d192334e21552 ">
                                          <p>允许</p>
                                       </td>
                                       <td align="left" valign="top" headers="d192334e21572 d192334e21554 ">
                                          <p>允许</p>
                                       </td>
                                    </tr>
                                    <tr align="left" valign="top">
                                       <td align="left" valign="top" id="d192334e21586" headers="d192334e21548 ">
                                          <p><code class="codeph">访问参数</code></p>
                                       </td>
                                       <td align="left" valign="top" headers="d192334e21586 d192334e21550 ">
                                          <p>允许</p>
                                       </td>
                                       <td align="left" valign="top" headers="d192334e21586 d192334e21552 ">
                                          <p>不允许</p>
                                       </td>
                                       <td align="left" valign="top" headers="d192334e21586 d192334e21554 ">
                                          <p>不允许</p>
                                       </td>
                                    </tr>
                                    <tr align="left" valign="top">
                                       <td align="left" valign="top" id="d192334e21600" headers="d192334e21548 ">
                                          <p><code class="codeph">地点</code></p>
                                       </td>
                                       <td align="left" valign="top" headers="d192334e21600 d192334e21550 ">
                                          <p>不允许</p>
                                       </td>
                                       <td align="left" valign="top" headers="d192334e21600 d192334e21552 ">
                                          <p>允许</p>
                                       </td>
                                       <td align="left" valign="top" headers="d192334e21600 d192334e21554 ">
                                          <p>允许</p>
                                       </td>
                                    </tr>
                                    <tr align="left" valign="top">
                                       <td align="left" valign="top" id="d192334e21614" headers="d192334e21548 ">
                                          <p><code class="codeph">拒绝限制</code></p>
                                       </td>
                                       <td align="left" valign="top" headers="d192334e21614 d192334e21550 ">
                                          <p>允许</p>
                                       </td>
                                       <td align="left" valign="top" headers="d192334e21614 d192334e21552 ">
                                          <p>不允许</p>
                                       </td>
                                       <td align="left" valign="top" headers="d192334e21614 d192334e21554 ">
                                          <p>不允许</p>
                                       </td>
                                    </tr>
                                 </tbody>
                              </table>
                           </div>
                           <!-- class="inftblhruleinformal" -->
                           <p>对于非复合分区表，必须在分区的<code class="codeph">LOCATION</code>子句中指定分区的文件。对于复合分区表，必须在子分区的<code class="codeph">LOCATION</code>子句中指定子分区的文件。当分区具有子分区时，可以为子分区指定<code class="codeph">LOCATION</code>子句，但不能为分区指定<code class="codeph">LOCATION</code>子句。如果省略了分区或子分区的<code class="codeph">LOCATION</code>子句，则会创建空分区或子分区。
                           </p>
                           <p>在<code class="codeph">LOCATION</code>子句中，文件在表单<code class="codeph"><span class="variable" translate="no">directory:file</span></code>中命名，一个子句可以指定多个文件。<code class="codeph"><span class="variable" translate="no">directory</span></code>部分是可选的。以下规则适用于分区或子分区使用的目录：</p>
                           <ul style="list-style-type:disc">
                              <li>
                                 <p>在<code class="codeph">LOCATION</code>子句中为分区或子分区指定目录时，它仅适用于该位置。
                                 </p>
                              </li>
                              <li>
                                 <p>在特定分区的<code class="codeph">LOCATION</code>子句中，对于没有目录规范的每个文件，按顺序使用<code class="codeph">DEFAULT DIRECTORY</code>子句中指定的<code class="codeph">DEFAULT DIRECTORY</code>作为分区或表级别。
                                 </p>
                                 <p>例如，当<code class="codeph">CREATE TABLE</code>语句的<code class="codeph">ORGANIZATION EXTERNAL</code>子句包含<code class="codeph">DEFAULT DIRECTORY</code>子句，并且语句中的<code class="codeph">PARTITION</code>子句未在其<code class="codeph">LOCATION</code>子句中指定文件的目录时，该文件使用<code class="codeph">DEFAULT DIRECTORY</code>子句中指定的<code class="codeph">DEFAULT DIRECTORY</code>对于表。
                                 </p>
                              </li>
                              <li>
                                 <p>在特定子分区的<code class="codeph">LOCATION</code>子句中，对于没有目录规范的每个文件，请按顺序使用<code class="codeph">DEFAULT DIRECTORY</code>子句中为子分区，分区或表级别指定的<code class="codeph">DEFAULT DIRECTORY</code> 。
                                 </p>
                                 <p>例如，当<code class="codeph">PARTITION</code>子句包含<code class="codeph">DEFAULT DIRECTORY</code>子句，并且分区中的<code class="codeph">SUBPARITION</code>子句未在其<code class="codeph">LOCATION</code>子句中指定文件的目录时，该文件将使用<code class="codeph">DEFAULT DIRECTORY</code>子句中为该分区指定的<code class="codeph">DEFAULT DIRECTORY</code> 。
                                 </p>
                              </li>
                              <li>
                                 <p>无法在<code class="codeph">LOCATION</code>子句中指定分区或子分区的缺省目录。它只能在<code class="codeph">DEFAULT DIRECTORY</code>子句中指定。
                                 </p>
                              </li>
                           </ul>
                           <div class="infoboxnotealso" id="GUID-AA3995EC-D147-464A-A9D3-680522B0A1B6__GUID-0C31211C-13F0-46FE-A654-95338B67FCAF">
                              <p class="notep1">也可以看看：</p><a href="managing-tables.html#GUID-A20ABC65-3E62-46B8-90D2-85AE6A29697D__GUID-EEC4D7A8-208C-4626-91DE-4105F607D531">例20-23</a>说明了目录规则</div>
                        </div>
                        <!-- class="section" -->
                        <div class="section">
                           <p class="subhead3" id="GUID-AA3995EC-D147-464A-A9D3-680522B0A1B6__GUID-DCA1D4FB-8A3E-4E0E-B72F-67C172A5C7F6">使用ORACLE_HIVE访问驱动程序</p>
                           <p>Apache Hive有自己的分区。要创建分区外部表，请使用<code class="codeph">DBMS_HADOOP</code>包中的<code class="codeph">CREATE_EXTDDL_FOR_HIVE</code>过程。此过程生成数据定义语言（DDL）语句，您可以使用这些语句创建与Apache Hive存储中的分区对应的分区外部表。
                           </p>
                           <p><code class="codeph">DBMS_HADOOP</code>包还包括<code class="codeph">SYNC_PARTITIONS_FOR_HIVE</code>过程。此过程自动将Apache Hive存储中分区外部表的分区与存储在Oracle数据库中的同一表的分区元数据同步。
                           </p>
                        </div>
                        <!-- class="section" -->
                     </div>
                     <div>
                        <div class="relinfo">
                           <p><strong>相关话题</strong></p>
                           <ul>
                              <li><a href="managing-tables.html#GUID-84C934CC-2116-482A-B47A-558F643437DC" title="您可以使用ALTER TABLE语句修改外部表。">改变外部表格</a></li>
                              <li><a href="https://www.oracle.com/pls/topic/lookup?ctx=en/database/oracle/oracle-database/19/admin&amp;id=SUTIL-GUID-74478A87-C89A-47E1-A8BF-DA556A3C2115" target="_blank"><span><cite>Oracle数据库实用程序</cite></span></a></li>
                              <li><a href="https://www.oracle.com/pls/topic/lookup?ctx=en/database/oracle/oracle-database/19/admin&amp;id=ARPLS-GUID-3900B7D4-E4AE-4CAB-8D21-4E53FF8D40D5" target="_blank"><span><cite>Oracle数据库PL / SQL包和类型参考</cite></span></a></li>
                           </ul>
                        </div>
                        <div class="familylinks">
                           <div class="parentlink">
                              <p><strong>父主题：对</strong> <a href="managing-tables.html#GUID-2A801016-0399-4925-AD1B-A02683E81B59" title="对于大量数据，外部表的分区可提供快速查询性能和增强的数据维护。">外部表进行分区</a></p>
                           </div>
                        </div>
                     </div>
                  </div>
                  <div class="sect4"><a id="GUID-43901AC6-BA21-4B1E-977C-41E031472E8D" name="GUID-43901AC6-BA21-4B1E-977C-41E031472E8D"></a><h5 id="ADMIN-GUID-43901AC6-BA21-4B1E-977C-41E031472E8D" class="sect5"><span class="enumeration_section">20.15.7.2</span>分区外部表的限制</h5>
                     <div>
                        <p>某些限制适用于分区外部表。</p>
                        <p>以下是对分区外部表的限制：</p>
                        <ul style="list-style-type:disc">
                           <li>
                              <p>适用于非分区外部表的所有限制也适用于分区外部表。</p>
                           </li>
                           <li>
                              <p>适用于存储在数据库中的表的分区限制也适用于分区外部表，例如最大分区数。</p>
                           </li>
                           <li>
                              <p>Oracle数据库无法保证分区的外部文件包含满足分区定义的数据。</p>
                           </li>
                           <li>
                              <p>只能在<code class="codeph">PARTITION</code>或<code class="codeph">SUBPARTITION</code>子句中指定<code class="codeph">DEFAULT DIRECTORY</code>和<code class="codeph">LOCATION</code>子句。
                              </p>
                           </li>
                           <li>
                              <p>使用<code class="codeph">ALTER TABLE</code>语句更改分区外部表时，不支持以下子句： <code class="codeph">MODIFY PARTITION</code> ， <code class="codeph">EXCHANGE PARTITION</code> ， <code class="codeph">MOVE PARTITION</code> ， <code class="codeph">MERGE PARTITIONS</code> ， <code class="codeph">SPLIT PARTITION</code> ， <code class="codeph">COALESCE PARTITION</code>和<code class="codeph">TRUNCATE PARTITION</code> 。</p>
                           </li>
                           <li>
                              <p>不支持引用分区，自动列表分区和间隔分区。</p> 
                           </li>
                           <li>
                              <p>不支持子分区模板。</p>
                           </li>
                           <li>
                              <p><code class="codeph">ORACLE_DATAPUMP</code>访问驱动程序无法使用<code class="codeph">CREATE TABLE AS SELECT</code>语句为分区填充外部文件。
                              </p>
                           </li>
                           <li>
                              <p>不为分区外部表收集增量统计信息。</p>
                           </li>
                           <li>
                              <p>除了可以用于其他驱动程序的分区方法的限制之外， <code class="codeph">ORACLE_HIVE</code>访问驱动程序不支持范围和复合分区。
                              </p>
                           </li>
                           <li>
                              <p>带有<code class="codeph">EXTERNAL MODIFY</code>子句的<code class="codeph">SELECT</code>语句不能覆盖分区级或子分区级子句。只能使用<code class="codeph">EXTERNAL MODIFY</code>子句覆盖表级别支持的<code class="codeph">EXTERNAL MODIFY</code>子句。由于分区外部表的表级别不允许使用<code class="codeph">LOCATION</code>子句，因此不能使用<code class="codeph">EXTERNAL MODIFY</code>子句覆盖该子句。
                              </p>
                           </li>
                        </ul>
                     </div>
                     <div>
                        <div class="infoboxnotealso" id="GUID-43901AC6-BA21-4B1E-977C-41E031472E8D__GUID-8E3B0300-71DA-4BF2-8644-F16DC7B17B01">
                           <p class="notep1">也可以看看：</p>
                           <div class="p">
                              <ul style="list-style-type:disc">
                                 <li>
                                    <p><span class="q">“ <a href="managing-tables.html#GUID-697B86CC-875C-4F68-AF80-49B41F33AE45" title="Oracle数据库允许您对外部表中的数据进行只读访问。外部表定义为不驻留在数据库中的表，它们可以是提供访问驱动程序的任何格式。">关于外部表</a> ”</span></p>
                                 </li>
                                 <li>
                                    <p><a href="https://www.oracle.com/pls/topic/lookup?ctx=en/database/oracle/oracle-database/19/admin&amp;id=SQLRF01402" target="_blank"><span class="italic">“Oracle数据库SQL语言参考”</span></a>提供了用于创建外部表的<code class="codeph">CREATE TABLE</code>语句的语法的详细信息，并指定了对子句使用的限制</p>
                                 </li>
                              </ul>
                           </div>
                        </div>
                        <div class="familylinks">
                           <div class="parentlink">
                              <p><strong>父主题：对</strong> <a href="managing-tables.html#GUID-2A801016-0399-4925-AD1B-A02683E81B59" title="对于大量数据，外部表的分区可提供快速查询性能和增强的数据维护。">外部表进行分区</a></p>
                           </div>
                        </div>
                     </div>
                     
                  </div>
                  <div class="sect4"><a id="GUID-A20ABC65-3E62-46B8-90D2-85AE6A29697D" name="GUID-A20ABC65-3E62-46B8-90D2-85AE6A29697D"></a><h5 id="ADMIN-GUID-A20ABC65-3E62-46B8-90D2-85AE6A29697D" class="sect5"><span class="enumeration_section">20.15.7.3</span>创建分区外部表</h5>
                     <div>
                        <p>您可以通过发出带有<code class="codeph">ORGANIZATION EXTERNAL</code>子句和<code class="codeph">PARTITION BY</code>子句的<code class="codeph">CREATE TABLE</code>语句来创建非复合分区外部表。要创建复合分区外部表，还必须包含<code class="codeph">SUBPARTITION BY</code>子句。
                        </p>
                        <div class="section"> 
                           <p><code class="codeph">PARTITION BY</code>子句和<code class="codeph">SUBPARTITION BY</code>子句指定每个分区和子分区的外部文件的位置。
                           </p>
                        </div>
                        <!-- class="section" -->
                        <div class="p">要创建分区外部表，数据库必须达到12.2.0兼容级别或更高级别。</div>
                        <!-- class="section" -->
                        <ol>
                           <li class="stepexpand"><span>以具有创建外部表所需特权的用户身份连接到数据库。</span><div>有关所需权限的信息，请参见<a href="https://www.oracle.com/pls/topic/lookup?ctx=en/database/oracle/oracle-database/19/admin&amp;id=SQLRF01402" target="_blank"><span><cite>Oracle数据库SQL语言参考</cite></span></a> 。
                              </div>
                           </li>
                           <li class="stepexpand"><span>使用<code class="codeph">ORGANIZATION EXTERNAL</code>子句和<code class="codeph">PARTITION BY</code>子句发出<code class="codeph">CREATE TABLE</code>语句。对于复合分区表，还包括<code class="codeph">SUBPARTITION BY</code>子句。</span></li>
                        </ol>
                        <div class="example" id="GUID-A20ABC65-3E62-46B8-90D2-85AE6A29697D__GUID-CDA8C3EB-03D8-4E30-969F-4D799CA51480">
                           <p class="titleinexample">示例20-22使用所有分区共有的访问参数创建分区外部表</p>
                           <p>此示例创建一个名为<code class="codeph">orders_external_range</code>的外部表，该表由<code class="codeph">order_date</code>列中的日期数据分区。<code class="codeph">ACCESS PARAMETERS</code>子句在表级别为<code class="codeph">ORACLE_LOADER</code>访问驱动程序指定。<code class="codeph">data_dir1</code>目录对象是用于分区<code class="codeph">month1</code> ， <code class="codeph">month2</code>和<code class="codeph">month3</code>的默认目录对象。该<code class="codeph">pmax</code>分区指定<code class="codeph">data_dir2</code>中目录对象<code class="codeph">DEFAULT DIRECTORY</code>子句，所以<code class="codeph">data_dir2</code>目录对象被用于<code class="codeph">pmax</code>分区。
                           </p><pre class="pre codeblock"><code>- 设置目录并授予对oe CREATE OR REPLACE DIRECTORY data_dir1 AS'/ flatfiles / data1'的访问权限;创建或替换DIRECTORY目录data_dir2 AS'/ flatfiles / data2';创建或替换DIRECTORY目标bad_dir AS'/ flatfiles / bad';创建或替换DIRECTORY目录log_dir AS'/ flatfiles / log'; GRANT READ ON DIRECTORY data_dir1 to oe; GRANT READ ON DIRECTORY data_dir2 TO oe; GRANT WRITE ON DIRECTORY bad_dir to oe; GRANT WRITE ON DIRECTORY log_dir to oe; -  oe连接。出现提示时提供用户密码（oe）。CONNECT oe  - 创建分区外部表CREATE TABLE orders_external_range（order_id NUMBER（12），order_date DATE NOT NULL，customer_id NUMBER（6）NOT NULL，order_status NUMBER（2），order_total NUMBER（8,2），sales_rep_id NUMBER（6） ））外部组织（类型ORACLE_LOADER默认目录data_dir1访问参数（记录由NEWLINE BADFILE删除bad_dir：'sh％a_％p.bad'LOGFILE log_dir：'sh％a_％p.log'FIELDS终止'|'缺少字段值ARE NULL））并行拒绝限制按范围无限分区（order_date）（PARTITION month1 VALUES少于（TO_DATE（'31 -12-2014'，'DD-MM-YYYY'））LOCATION（'sales_1.csv'），PARTITION month2价值不到（截止日期（'31 -01-2015'，'DD-MM-YYYY'））LOCATION（'sales_2.csv'），PARTITION month3 VALUE少于（2015年2月28日'，'28 -02-2015'，'' DD-MM-YYYY'））LOCATION（'sales_3.csv'），PARTITION pmax VALUE少于（MAXVALUE）DEFAULT DIRECTORY data_dir2 LOCATION（'sales_4.csv'））;</code></pre><p>在前面的示例中，为<code class="codeph">pmax</code>分区指定了默认目录<code class="codeph">data_dir2</code> 。您还可以通过以下方式在<code class="codeph">LOCATION</code>子句中为此分区中的特定位置指定目录：</p><pre class="pre codeblock"><code>PARTITION pmax VALUE少于（MAXVALUE）位置（'data_dir2：sales_4.csv'）</code></pre><p>请注意，在这种情况下，为<code class="codeph">sales_4.csv</code>位置指定目录<code class="codeph">data_dir2</code> ，但<code class="codeph">data_dir2</code>目录不是该分区的缺省目录。因此， <code class="codeph">pmax</code>分区的缺省目录与表的缺省目录相同，即<code class="codeph">data_dir1</code> 。
                           </p>
                        </div>
                        <!-- class="example" -->
                        <div class="example" id="GUID-A20ABC65-3E62-46B8-90D2-85AE6A29697D__GUID-EEC4D7A8-208C-4626-91DE-4105F607D531">
                           <p class="titleinexample">示例20-23创建复合列表范围分区外部表</p>
                           <p>此示例创建一个名为<code class="codeph">accounts</code>的外部表，该表由<code class="codeph">region</code>列中的数据分区。使用<code class="codeph">balance</code>列中数据的范围对此分区进行子分区。<code class="codeph">ACCESS PARAMETERS</code>子句在表级别为<code class="codeph">ORACLE_LOADER</code>访问驱动程序指定。为每个子分区指定了<code class="codeph">LOCATION</code>子句。
                           </p>
                           <p>有一个表级别的<code class="codeph">DEFAULT DIRECTORY</code>子句设置为<code class="codeph">data_dir1</code>目录对象，该目录对象用于所有子分区，但以下情况除外：</p>
                           <ul style="list-style-type:disc">
                              <li>
                                 <p>有一个分区级<code class="codeph">DEFAULT DIRECTORY</code>子句设置为分区<code class="codeph">p_southcentral</code>的<code class="codeph">data_dir2</code>目录对象。在该分区中，以下子分区使用此默认目录： <code class="codeph">p_sc_low</code> ， <code class="codeph">p_sc_high</code>和<code class="codeph">p_sc_extraordinary</code> 。
                                 </p>
                              </li>
                              <li>
                                 <p>在分区<code class="codeph">p_southcentral</code> ，子分区<code class="codeph">p_sc_average</code>具有设置为<code class="codeph">data_dir3</code>目录对象的子分区级<code class="codeph">DEFAULT DIRECTORY</code>子句，并且此子分区使用<code class="codeph">data_dir3</code>目录对象。
                                 </p>
                              </li>
                              <li>
                                 <p>如前所述， <code class="codeph">p_sc_high</code>子分区的默认目录是<code class="codeph">data_dir2</code> 。<code class="codeph">p_sc_high</code>子分区没有<code class="codeph">DEFAULT DIRECTORY</code>子句，默认目录<code class="codeph">data_dir2</code>继承自分区<code class="codeph">p_southcentral</code>的<code class="codeph">PARTITION BY</code>子句中指定的<code class="codeph">DEFAULT DIRECTORY</code> 。<code class="codeph">p_sc_high</code>子分区中的文件使用以下目录：</p>
                                 <ul style="list-style-type:disc">
                                    <li>
                                       <p><code class="codeph">psch1.csv</code>文件使用<code class="codeph">data_dir2</code> ，即子分区的默认目录。
                                       </p>
                                    </li>
                                    <li>
                                       <p><code class="codeph">psch2.csv</code>文件使用<code class="codeph">data_dir4</code>目录，因为为该位置指定了<code class="codeph">data_dir4</code>目录。
                                       </p>
                                    </li>
                                 </ul>
                              </li>
                           </ul><pre class="pre codeblock"><code>- 设置目录并授予对oe CREATE OR REPLACE DIRECTORY data_dir1 AS'/ stage / data1_dir'的访问权限;创建或替换DIRECTORY目录data_dir2 AS'/ stage / data2_dir';创建或替换DIRECTORY目录data_dir3 AS'/ stage / data3_dir';创建或替换DIRECTORY目录data_dir4 AS'/ stage / data4_dir';创建或替换DIRECTORY目录bad_dir AS'/ stage / bad_dir';创建或替换DIRECTORY目录log_dir AS'/ stage / log_dir'; GRANT READ ON DIRECTORY data_dir1 to oe; GRANT READ ON DIRECTORY data_dir2 TO oe; GRANT READ ON DIRECTORY data_dir3 TO oe; GRANT READ ON DIRECTORY data_dir4 TO oe; GRANT WRITE ON DIRECTORY bad_dir to oe; GRANT WRITE ON DIRECTORY log_dir to oe; -  oe连接。出现提示时提供用户密码（oe）。CONNECT oe  - 创建分区外部表CREATE TABLE帐户（id NUMBER，account_number NUMBER，customer_id NUMBER，余额NUMBER，branch_id NUMBER，区域VARCHAR（2），状态VARCHAR2（1））ORGANIZATION EXTERNAL（类型ORACLE_LOADER DEFAULT目录data_dir1访问参数（由NEWLINE BADFILE删除的记录bad_dir：'sh％a_％p.bad'LOGFILE log_dir：'sh％a_％p.log'FIELDS终止'|'缺少字段值为空））并行拒绝限制列表的无限分区（区域）按范围减少（余额）（PARTITION p_northwest VALUES（'OR'，'WA'）（SUBPARTITION p_nw_low值小于（1000）位置（'pnwl.csv'），SUBPARTITION p_nw_average值小于（10000）位置（' pnwa.csv'），SUBPARTITION p_nw_high值小于（100000）LOCATION（'pnwh.csv'），SUBPARTITION p_nw_extraordinary Value不到（MAXVALUE）LOCATION（'pnwe.csv'）），PARTITION p_southwest VALUES（'AZ'，' UT'，'NM'）（SUBPARTITION p_sw_low值小于（1000）位置（'pswl.csv'），SUB PARTITION p_sw_average值小于（10000）位置（'pswa.csv'），SUBPARTITION p_sw_high值小于（100000）LOCATION（'pswh.csv'），SUBPARTITION p_sw_extraordinary VALUES少于（MAXVALUE）LOCATION（'pswe.csv'） ），PARTITION p_northeast VALUES（'NY'，'VM'，'NJ'）（SUBPARTITION p_ne_low VALUE少于（1000）LOCATION（'pnel.csv'），SUBPARTITION p_ne_average VALUES少于（10000）位置（'pnea.csv '），SUBPARTITION p_ne_high值低于（100000）位置（'pneh.csv'），SUBPARTITION p_ne_extraordinary值低于（MAXVALUE）位置（'pnee.csv'）），PARTITION p_southeast VALUES（'FL'，'GA'） （SUBPARTITION p_se_low值小于（1000）位置（'psel.csv'），SUBPARTITION p_se_average值小于（10000）位置（'psea.csv'），SUBPARTITION p_se_high值小于（100000）位置（'pseh.csv' ），SUBPARTITION p_se_extraordinary Value不到（MAXVALUE）位置（'psee.csv'）），PARTITION p_northcentral VALUES（'SD'，'WI'）（SUBPARTITION p_nc_low VALUES LE SS THAN（1000）LOCATION（'pncl.csv'），SUBPARTITION p_nc_average VALUE少于（10000）位置（'pnca.csv'），SUBPARTITION p_nc_high值低于（100000）LOCATION（'pnch.csv'），SUBPARTITION p_nc_extraordinary值小于（MAXVALUE）位置（'pnce.csv'）），PARTITION p_southcentral VALUES（'OK'，'TX'）DEFAULT DIRECTORY data_dir2（SUBPARTITION p_sc_low VALUES少于（1000）LOCATION（'pscl.csv'），SUBPARTITION p_sc_average值少于（10000）默认目录data_dir3位置（'psca.csv'），SUBPARTITION p_sc_high值小于（100000）位置（'psch1.csv'，'data_dir4：psch2.csv'），SUBPARTITION p_sc_extraordinary VALUES少于（ MAXVALUE）LOCATION（'psce.csv'）））;</code></pre></div>
                        <!-- class="example" -->
                        <div class="section"></div>
                        <!-- class="section" -->
                     </div>
                     <div>
                        <div class="infoboxnotealso" id="GUID-A20ABC65-3E62-46B8-90D2-85AE6A29697D__GUID-D1914939-33E0-4441-8119-11F4EC0C6CAC">
                           <p class="notep1">也可以看看：</p><a href="https://www.oracle.com/pls/topic/lookup?ctx=en/database/oracle/oracle-database/19/admin&amp;id=VLDBG-GUID-09CFA3CD-66B7-4CDF-A086-6958D113BDD1" target="_blank"><span><cite>Oracle数据库VLDB和分区指南</cite></span></a></div>
                        <div class="familylinks">
                           <div class="parentlink">
                              <p><strong>父主题：对</strong> <a href="managing-tables.html#GUID-2A801016-0399-4925-AD1B-A02683E81B59" title="对于大量数据，外部表的分区可提供快速查询性能和增强的数据维护。">外部表进行分区</a></p>
                           </div>
                        </div>
                     </div>
                     
                  </div>
                  <div class="sect4"><a id="GUID-E731CB7E-0F74-43DA-93D8-B53E55651B8C" name="GUID-E731CB7E-0F74-43DA-93D8-B53E55651B8C"></a><h5 id="ADMIN-GUID-E731CB7E-0F74-43DA-93D8-B53E55651B8C" class="sect5"><span class="enumeration_section">20.15.7.4</span>更改分区外部表</h5>
                     <div>
                        <p>您可以使用<code class="codeph">ALTER TABLE</code>语句来修改分区外部表的表级外部参数，但不能修改分区级外部表和子分区级参数。
                        </p>
                        <div class="section">
                           <p>外部文件的位置在<code class="codeph">PARTITION BY</code>和<code class="codeph">SUBPARTITION BY</code>子句中指定。分区的外部文件在分区的<code class="codeph">PARTITION BY</code>子句中指定。子分区的外部文件在子分区的<code class="codeph">SUBPARTITION BY</code>子句中指定。
                           </p>
                           <p>唯一的例外是在创建分区外部表期间无法在表级别指定<code class="codeph">LOCATION</code>子句。因此，无法在修改分区外部表的<code class="codeph">ALTER TABLE</code>语句中的表级别添加<code class="codeph">LOCATION</code>子句。
                           </p>
                           <p>在分区级别，仅支持<code class="codeph">ADD</code> ， <code class="codeph">DROP</code>和<code class="codeph">RENAME</code>操作。<code class="codeph">ALTER TABLE</code>语句不能修改现有分区和子分区的属性。但是，在添加新分区或子分区时，可以在<code class="codeph">PARTITION</code>子句或<code class="codeph">SUBPARTITION</code>子句中包含<code class="codeph">DEFAULT DIRECTORY</code>和<code class="codeph">LOCATION</code>子句。
                           </p>
                        </div>
                        <!-- class="section" -->
                        <ol>
                           <li><span>以具有更改外部表所需特权的用户身份连接到数据库。</span></li>
                           <li><span>发出<code class="codeph">ALTER TABLE</code>语句。</span></li>
                        </ol>
                        <div class="example" id="GUID-E731CB7E-0F74-43DA-93D8-B53E55651B8C__GUID-CDA8C3EB-03D8-4E30-969F-4D799CA51480">
                           <p class="titleinexample">示例20-24重命名分区外部表的分区</p>
                           <p>此示例重命名名为<code class="codeph">orders_external_range</code>的分区外部表的分区。
                           </p><pre class="pre codeblock"><code>ALTER TABLE orders_external_range RENAME PARTITION pmax TO other_months;</code></pre></div>
                        <!-- class="example" -->
                     </div>
                     <div>
                        <div class="familylinks">
                           <div class="parentlink">
                              <p><strong>父主题：对</strong> <a href="managing-tables.html#GUID-2A801016-0399-4925-AD1B-A02683E81B59" title="对于大量数据，外部表的分区可提供快速查询性能和增强的数据维护。">外部表进行分区</a></p>
                           </div>
                        </div>
                     </div>
                     
                  </div>
               </div><a id="ADMIN11707"></a><div class="props_rev_3"><a id="GUID-8467E062-FBC3-4BC9-B7E9-BF56B31B419E" name="GUID-8467E062-FBC3-4BC9-B7E9-BF56B31B419E"></a><h4 id="ADMIN-GUID-8467E062-FBC3-4BC9-B7E9-BF56B31B419E" class="sect4"><span class="enumeration_section">20.15.8</span>删除外部表</h4>
                  <p>对于外部表， <code class="codeph">DROP</code> <code class="codeph">TABLE</code>语句仅删除数据库中的表元数据。它对驻留在数据库之外的实际数据没有影响。
                  </p>
                  <div>
                     <div class="familylinks">
                        <div class="parentlink">
                           <p><strong>父主题：</strong> <a href="managing-tables.html#GUID-F6948F0E-0557-4C42-9145-1897DE974CC3" title="外部表是不驻留在数据库中的表，但位于数据库外部的外部文件中，例如操作系统文件或Hadoop分布式文件系统（HDFS）文件。">管理外部表</a></p>
                        </div>
                     </div>
                  </div>
                  
               </div><a id="ADMIN11708"></a><div class="props_rev_3"><a id="GUID-C5B61599-74AA-4004-AFCD-1A95B3BA11C2" name="GUID-C5B61599-74AA-4004-AFCD-1A95B3BA11C2"></a><h4 id="ADMIN-GUID-C5B61599-74AA-4004-AFCD-1A95B3BA11C2" class="sect4"><span class="enumeration_section">20.15.9</span>外部表的系统和对象权限</h4>
                  <div>
                     <p>外部表的系统和对象权限是常规表的子集。</p>
                     <p>只有以下系统权限适用于外部表：</p>
                     <ul style="list-style-type:disc">
                        <li>
                           <p><code class="codeph">ALTER</code> <code class="codeph">ANY</code> <code class="codeph">TABLE</code> 
                           </p>
                        </li>
                        <li>
                           <p><code class="codeph">CREATE</code> <code class="codeph">ANY</code> <code class="codeph">TABLE</code> 
                           </p>
                        </li>
                        <li>
                           <p><code class="codeph">DROP</code> <code class="codeph">ANY</code> <code class="codeph">TABLE</code> 
                           </p>
                        </li>
                        <li>
                           <p><code class="codeph">READ</code> <code class="codeph">ANY</code> <code class="codeph">TABLE</code> 
                           </p>
                        </li>
                        <li>
                           <p><code class="codeph">SELECT</code> <code class="codeph">ANY</code> <code class="codeph">TABLE</code> 
                           </p>
                        </li>
                     </ul>
                     <p>只有以下对象权限适用于外部表：</p>
                     <ul style="list-style-type:disc">
                        <li>
                           <p><code class="codeph">改变</code> 
                           </p>
                        </li>
                        <li>
                           <p><code class="codeph">读</code> 
                           </p>
                        </li>
                        <li>
                           <p><code class="codeph">选择</code> 
                           </p>
                        </li>
                     </ul>
                     <p>但是，与目录关联的对象权限是：</p>
                     <ul style="list-style-type:disc">
                        <li>
                           <p><code class="codeph">读</code> 
                           </p>
                        </li>
                        <li>
                           <p><code class="codeph">写</code> 
                           </p>
                        </li>
                     </ul>
                     <p>对于外部表，对包含数据源的目录对象需要<code class="codeph">READ</code>权限，而包含bad，log或discard文件的目录对象需要<code class="codeph">WRITE</code>权限。
                     </p>
                  </div>
                  <div>
                     <div class="familylinks">
                        <div class="parentlink">
                           <p><strong>父主题：</strong> <a href="managing-tables.html#GUID-F6948F0E-0557-4C42-9145-1897DE974CC3" title="外部表是不驻留在数据库中的表，但位于数据库外部的外部文件中，例如操作系统文件或Hadoop分布式文件系统（HDFS）文件。">管理外部表</a></p>
                        </div>
                     </div>
                  </div>
                  
               </div>
            </div>
            <div class="props_rev_3"><a id="GUID-FB55B947-2599-4D0E-8971-E05F49F6AF28" name="GUID-FB55B947-2599-4D0E-8971-E05F49F6AF28"></a><h3 id="ADMIN-GUID-FB55B947-2599-4D0E-8971-E05F49F6AF28" class="sect3"><span class="enumeration_section">20.16</span>管理混合分区表</h3>
               <div>
                  <p>混合分区表是一个分区表，其中一些分区驻留在数据库中，一些分区驻留在数据库外部的外部文件中，例如操作系统文件或Hadoop分布式文件系统（HDFS）文件。</p>
                  <div class="infoboxnote" id="GUID-FB55B947-2599-4D0E-8971-E05F49F6AF28__GUID-3D688EF4-D2A4-427B-816B-1EE4AF8055F8">
                     <p class="notep1">注意：</p>
                     <p>适用于外部表的限制也适用于混合分区表。</p>
                  </div>
               </div>
               <div>
                  <div class="infoboxnotealso" id="GUID-FB55B947-2599-4D0E-8971-E05F49F6AF28__GUID-1170381B-9829-40F7-8D08-EBE96ECEF42E">
                     <p class="notep1">也可以看看：</p>
                     <ul id="GUID-FB55B947-2599-4D0E-8971-E05F49F6AF28__UL_EQM_ZLT_2GB" style="list-style-type:disc">
                        <li><span class="q">“ <a href="managing-tables.html#GUID-2A801016-0399-4925-AD1B-A02683E81B59" title="对于大量数据，外部表的分区可提供快速查询性能和增强的数据维护。">分区外部表</a> ”</span></li>
                        <li>
                           <p>有关管理混合分区表的详细信息<a href="https://www.oracle.com/pls/topic/lookup?ctx=en/database/oracle/oracle-database/19/admin&amp;id=VLDBG-GUID-C2B04585-BCFC-40D6-AFAB-47DF99A31C76" target="_blank"><span class="italic">，请参见“Oracle数据库VLDB和分区指南”</span></a></p>
                        </li>
                     </ul>
                  </div>
                  <div class="familylinks">
                     <div class="parentlink">
                        <p><strong>父主题：</strong> <a href="managing-tables.html#GUID-707B02F5-E589-4C20-8E2E-5ED4F7888702" title="管理表包括创建表，加载表，更改表和删除表等任务。">管理表</a></p>
                     </div>
                  </div>
               </div>
               
            </div><a id="ADMIN12643"></a><a id="ADMIN01508"></a><div class="props_rev_3"><a id="GUID-9E47D91A-E1F2-42F7-8704-1571B34C0410" name="GUID-9E47D91A-E1F2-42F7-8704-1571B34C0410"></a><h3 id="ADMIN-GUID-9E47D91A-E1F2-42F7-8704-1571B34C0410" class="sect3"><span class="enumeration_section">20.17</span>表数据字典视图</h3>
               <div>
                  <p>您可以查询一组数据字典视图以获取有关表的信息。</p>
                  <div class="section">
                     <div class="tblformal" id="GUID-9E47D91A-E1F2-42F7-8704-1571B34C0410__GUID-B50A3582-3F23-429B-8F68-497909C32DD4">
                        <table cellpadding="4" cellspacing="0" class="Formal" title="" width="100%" border="1" summary="Column 1 lists the names of views that can be used to access information about tables. Column 2 describes the view." frame="hsides" rules="rows">
                           <thead>
                              <tr align="left" valign="top">
                                 <th align="left" valign="bottom" width="33%" id="d192334e22660">视图</th>
                                 <th align="left" valign="bottom" width="67%" id="d192334e22663">描述</th>
                              </tr>
                           </thead>
                           <tbody>
                              <tr align="left" valign="top">
                                 <td align="left" valign="top" width="33%" id="d192334e22668" headers="d192334e22660 ">
                                    <p><code class="codeph"><a href="https://www.oracle.com/pls/topic/lookup?ctx=en/database/oracle/oracle-database/19/admin&amp;id=REFRN23286" target="_blank">DBA_TABLES</a></code> 
                                    </p>
                                    <p><code class="codeph"><a href="https://www.oracle.com/pls/topic/lookup?ctx=en/database/oracle/oracle-database/19/admin&amp;id=REFRN20286" target="_blank">ALL_TABLES</a></code> 
                                    </p>
                                    <p><code class="codeph"><a href="https://www.oracle.com/pls/topic/lookup?ctx=en/database/oracle/oracle-database/19/admin&amp;id=REFRN26286" target="_blank">USER_TABLES</a></code> 
                                    </p>
                                 </td>
                                 <td align="left" valign="top" width="67%" headers="d192334e22668 d192334e22663 ">
                                    <p><code class="codeph">DBA</code>视图描述了数据库中的所有关系表。<code class="codeph">ALL</code>视图描述了用户可访问的所有表。<code class="codeph">USER</code>视图仅限于用户拥有的表。这些视图中的某些列包含由<code class="codeph">DBMS_STATS</code>包或<code class="codeph">ANALYZE</code>语句生成的统计信息。
                                    </p>
                                 </td>
                              </tr>
                              <tr align="left" valign="top">
                                 <td align="left" valign="top" width="33%" id="d192334e22705" headers="d192334e22660 ">
                                    <p><code class="codeph"><a href="https://www.oracle.com/pls/topic/lookup?ctx=en/database/oracle/oracle-database/19/admin&amp;id=REFRN23277" target="_blank">DBA_TAB_COLUMNS</a></code> 
                                    </p>
                                    <p><code class="codeph"><a href="../refrn/ALL_TAB_COLUMNS.html#REFRN20277" target="_blank">ALL_TAB_COLUMNS</a></code> 
                                    </p>
                                    <p><code class="codeph"><a href="https://www.oracle.com/pls/topic/lookup?ctx=en/database/oracle/oracle-database/19/admin&amp;id=REFRN26277" target="_blank">USER_TAB_COLUMNS</a></code> 
                                    </p>
                                 </td>
                                 <td align="left" valign="top" width="67%" headers="d192334e22705 d192334e22663 ">
                                    <p>这些视图描述了数据库中的表，视图和集群的列。这些视图中的某些列包含由<code class="codeph">DBMS_STATS</code>包或<code class="codeph">ANALYZE</code>语句生成的统计信息。
                                    </p>
                                 </td>
                              </tr>
                              <tr align="left" valign="top">
                                 <td align="left" valign="top" width="33%" id="d192334e22734" headers="d192334e22660 ">
                                    <p><code class="codeph"><a href="https://www.oracle.com/pls/topic/lookup?ctx=en/database/oracle/oracle-database/19/admin&amp;id=REFRN23003" target="_blank">DBA_ALL_TABLES</a></code> 
                                    </p>
                                    <p><code class="codeph"><a href="https://www.oracle.com/pls/topic/lookup?ctx=en/database/oracle/oracle-database/19/admin&amp;id=REFRN20003" target="_blank">ALL_ALL_TABLES</a></code> 
                                    </p>
                                    <p><code class="codeph"><a href="https://www.oracle.com/pls/topic/lookup?ctx=en/database/oracle/oracle-database/19/admin&amp;id=REFRN26003" target="_blank">USER_ALL_TABLES</a></code> 
                                    </p>
                                 </td>
                                 <td align="left" valign="top" width="67%" headers="d192334e22734 d192334e22663 ">
                                    <p>这些视图描述了数据库中的所有关系表和对象表。本书中没有具体讨论对象表。</p>
                                 </td>
                              </tr>
                              <tr align="left" valign="top">
                                 <td align="left" valign="top" width="33%" id="d192334e22757" headers="d192334e22660 ">
                                    <p><code class="codeph"><a href="https://www.oracle.com/pls/topic/lookup?ctx=en/database/oracle/oracle-database/19/admin&amp;id=REFRN23278" target="_blank">DBA_TAB_COMMENTS</a></code> 
                                    </p>
                                    <p><code class="codeph"><a href="https://www.oracle.com/pls/topic/lookup?ctx=en/database/oracle/oracle-database/19/admin&amp;id=REFRN20278" target="_blank">ALL_TAB_COMMENTS</a></code> 
                                    </p>
                                    <p><code class="codeph"><a href="https://www.oracle.com/pls/topic/lookup?ctx=en/database/oracle/oracle-database/19/admin&amp;id=REFRN26278" target="_blank">USER_TAB_COMMENTS</a></code> 
                                    </p>
                                 </td>
                                 <td align="left" valign="top" width="67%" headers="d192334e22757 d192334e22663 ">
                                    <p>这些视图显示表和视图的注释。使用<code class="codeph">COMMENT</code>语句输入<code class="codeph">COMMENT</code> 。
                                    </p>
                                 </td>
                              </tr>
                              <tr align="left" valign="top">
                                 <td align="left" valign="top" width="33%" id="d192334e22783" headers="d192334e22660 ">
                                    <p><code class="codeph"><a href="https://www.oracle.com/pls/topic/lookup?ctx=en/database/oracle/oracle-database/19/admin&amp;id=REFRN23040" target="_blank">DBA_COL_COMMENTS</a></code> 
                                    </p>
                                    <p><code class="codeph"><a href="https://www.oracle.com/pls/topic/lookup?ctx=en/database/oracle/oracle-database/19/admin&amp;id=REFRN20040" target="_blank">ALL_COL_COMMENTS</a></code> 
                                    </p>
                                    <p><code class="codeph"><a href="https://www.oracle.com/pls/topic/lookup?ctx=en/database/oracle/oracle-database/19/admin&amp;id=REFRN26040" target="_blank">USER_COL_COMMENTS</a></code> 
                                    </p>
                                 </td>
                                 <td align="left" valign="top" width="67%" headers="d192334e22783 d192334e22663 ">
                                    <p>这些视图显示表和视图列的注释。使用<code class="codeph">COMMENT</code>语句输入<code class="codeph">COMMENT</code> 。
                                    </p>
                                 </td>
                              </tr>
                              <tr align="left" valign="top">
                                 <td align="left" valign="top" width="33%" id="d192334e22809" headers="d192334e22660 ">
                                    <p><code class="codeph"><a href="../refrn/DBA_EXTERNAL_TABLES.html#REFRN23074" target="_blank">DBA_EXTERNAL_TABLES</a></code> 
                                    </p>
                                    <p><code class="codeph"><a href="../refrn/ALL_EXTERNAL_TABLES.html#REFRN20074" target="_blank">ALL_EXTERNAL_TABLES</a></code> 
                                    </p>
                                    <p><code class="codeph"><a href="../refrn/USER_EXTERNAL_TABLES.html#REFRN26074" target="_blank">USER_EXTERNAL_TABLES</a></code> 
                                    </p>
                                 </td>
                                 <td align="left" valign="top" width="67%" headers="d192334e22809 d192334e22663 ">
                                    <p>这些视图列出了数据库中外部表的特定属性。</p>
                                 </td>
                              </tr>
                              <tr align="left" valign="top">
                                 <td align="left" valign="top" width="33%" id="d192334e22832" headers="d192334e22660 ">
                                    <p><code class="codeph"><a href="https://www.oracle.com/pls/topic/lookup?ctx=en/database/oracle/oracle-database/19/admin&amp;id=REFRN23073" target="_blank">DBA_EXTERNAL_LOCATIONS</a></code> 
                                    </p>
                                    <p><code class="codeph"><a href="https://www.oracle.com/pls/topic/lookup?ctx=en/database/oracle/oracle-database/19/admin&amp;id=REFRN20073" target="_blank">ALL_EXTERNAL_LOCATIONS</a></code> 
                                    </p>
                                    <p><code class="codeph"><a href="https://www.oracle.com/pls/topic/lookup?ctx=en/database/oracle/oracle-database/19/admin&amp;id=REFRN26073" target="_blank">USER_EXTERNAL_LOCATIONS</a></code> 
                                    </p>
                                 </td>
                                 <td align="left" valign="top" width="67%" headers="d192334e22832 d192334e22663 ">
                                    <p>这些视图列出了外部表的数据源。</p>
                                 </td>
                              </tr>
                              <tr align="left" valign="top">
                                 <td align="left" valign="top" width="33%" id="d192334e22855" headers="d192334e22660 ">
                                    <p><code class="codeph"><a href="https://www.oracle.com/pls/topic/lookup?ctx=en/database/oracle/oracle-database/19/admin&amp;id=REFRN-GUID-AF3D6082-FB4E-4CDC-A03E-07462B706499" target="_blank">DBA_XTERNAL_PART_TABLES</a></code> 
                                    </p>
                                    <p><code class="codeph"><a href="https://www.oracle.com/pls/topic/lookup?ctx=en/database/oracle/oracle-database/19/admin&amp;id=REFRN-GUID-9EE228C3-2FEF-4F78-888F-01DAB9350586" target="_blank">ALL_XTERNAL_PART_TABLES</a></code> 
                                    </p>
                                    <p><code class="codeph"><a href="../refrn/USER_XTERNAL_PART_TABLES.html#REFRN-GUID-39704779-342F-4DCC-AE23-02EFAAB8FCDF" target="_blank">USER_XTERNAL_PART_TABLES</a></code> 
                                    </p>
                                 </td>
                                 <td align="left" valign="top" width="67%" headers="d192334e22855 d192334e22663 ">
                                    <p>这些视图列出了数据库中分区外部表的特定属性。</p>
                                 </td>
                              </tr>
                              <tr align="left" valign="top">
                                 <td align="left" valign="top" width="33%" id="d192334e22878" headers="d192334e22660 ">
                                    <p><code class="codeph"><a href="https://www.oracle.com/pls/topic/lookup?ctx=en/database/oracle/oracle-database/19/admin&amp;id=REFRN-GUID-05276931-0DD9-4393-858B-D2F0FC394BB8" target="_blank">DBA_XTERNAL_TAB_PARTITIONS</a></code> 
                                    </p>
                                    <p><code class="codeph"><a href="https://www.oracle.com/pls/topic/lookup?ctx=en/database/oracle/oracle-database/19/admin&amp;id=REFRN-GUID-31E8F336-229E-4C77-9686-283E442D96CC" target="_blank">ALL_XTERNAL_TAB_PARTITIONS</a></code> 
                                    </p>
                                    <p><code class="codeph"><a href="https://www.oracle.com/pls/topic/lookup?ctx=en/database/oracle/oracle-database/19/admin&amp;id=REFRN-GUID-778FC05D-E62E-4052-8AF5-72B1AFA535C2" target="_blank">USER_XTERNAL_TAB_PARTITIONS</a></code> 
                                    </p>
                                 </td>
                                 <td align="left" valign="top" width="67%" headers="d192334e22878 d192334e22663 ">
                                    <p>这些视图列出了数据库中分区外部表的分区级信息。</p>
                                 </td>
                              </tr>
                              <tr align="left" valign="top">
                                 <td align="left" valign="top" width="33%" id="d192334e22901" headers="d192334e22660 ">
                                    <p><code class="codeph"><a href="https://www.oracle.com/pls/topic/lookup?ctx=en/database/oracle/oracle-database/19/admin&amp;id=REFRN-GUID-EE3CEBBC-4D70-499D-9233-512287C80E69" target="_blank">DBA_XTERNAL_TAB_SUBPARTITIONS</a></code> 
                                    </p>
                                    <p><code class="codeph"><a href="https://www.oracle.com/pls/topic/lookup?ctx=en/database/oracle/oracle-database/19/admin&amp;id=REFRN-GUID-A3AAB0D5-754D-4F71-80E5-FD488D160FA7" target="_blank">ALL_XTERNAL_TAB_SUBPARTITIONS</a></code> 
                                    </p>
                                    <p><code class="codeph"><a href="../refrn/USER_XTERNAL_TAB_SUBPARTITIONS.html#REFRN-GUID-39656112-F5A5-4D7F-A945-769D2A57E873" target="_blank">USER_XTERNAL_TAB_SUBPARTITIONS</a></code> 
                                    </p>
                                 </td>
                                 <td align="left" valign="top" width="67%" headers="d192334e22901 d192334e22663 ">
                                    <p>这些视图列出了数据库中分区外部表的子分区级信息。</p>
                                 </td>
                              </tr>
                              <tr align="left" valign="top">
                                 <td align="left" valign="top" width="33%" id="d192334e22924" headers="d192334e22660 ">
                                    <p><code class="codeph"><a href="https://www.oracle.com/pls/topic/lookup?ctx=en/database/oracle/oracle-database/19/admin&amp;id=REFRN-GUID-3BD7CD71-C3B4-4AAF-ACEA-208A404FBC0D" target="_blank">DBA_XTERNAL_LOC_PARTITIONS</a></code> 
                                    </p>
                                    <p><code class="codeph"><a href="https://www.oracle.com/pls/topic/lookup?ctx=en/database/oracle/oracle-database/19/admin&amp;id=REFRN-GUID-34127B29-EAA5-467F-A937-E8809EE7DAAB" target="_blank">ALL_XTERNAL_LOC_PARTITIONS</a></code> 
                                    </p>
                                    <p><code class="codeph"><a href="https://www.oracle.com/pls/topic/lookup?ctx=en/database/oracle/oracle-database/19/admin&amp;id=REFRN-GUID-B0BF1824-13C7-4E9A-94A3-F2A439D38BD2" target="_blank">USER_XTERNAL_LOC_PARTITIONS</a></code> 
                                    </p>
                                 </td>
                                 <td align="left" valign="top" width="67%" headers="d192334e22924 d192334e22663 ">
                                    <p>这些视图列出了外部表中分区的数据源。</p>
                                 </td>
                              </tr>
                              <tr align="left" valign="top">
                                 <td align="left" valign="top" width="33%" id="d192334e22948" headers="d192334e22660 ">
                                    <p><code class="codeph"><a href="https://www.oracle.com/pls/topic/lookup?ctx=en/database/oracle/oracle-database/19/admin&amp;id=REFRN-GUID-3BD7CD71-C3B4-4AAF-ACEA-208A404FBC0D" target="_blank">DBA_XTERNAL_LOC_SUBPARTITIONS</a></code> 
                                    </p>
                                    <p><code class="codeph"><a href="../refrn/ALL_XTERNAL_LOC_PARTITIONS.html#REFRN-GUID-34127B29-EAA5-467F-A937-E8809EE7DAAB" target="_blank">ALL_XTERNAL_LOC_SUBPARTITIONS</a></code> 
                                    </p>
                                    <p><code class="codeph"><a href="https://www.oracle.com/pls/topic/lookup?ctx=en/database/oracle/oracle-database/19/admin&amp;id=REFRN-GUID-B0BF1824-13C7-4E9A-94A3-F2A439D38BD2" target="_blank">USER_XTERNAL_LOC_SUBPARTITIONS</a></code> 
                                    </p>
                                 </td>
                                 <td align="left" valign="top" width="67%" headers="d192334e22948 d192334e22663 ">
                                    <p>这些视图列出了外部表中子分区的数据源。</p>
                                 </td>
                              </tr>
                              <tr align="left" valign="top">
                                 <td align="left" valign="top" width="33%" id="d192334e22971" headers="d192334e22660 ">
                                    <p><code class="codeph"><a href="../refrn/DBA_TAB_HISTOGRAMS.html#REFRN23279" target="_blank">DBA_TAB_HISTOGRAMS</a></code> 
                                    </p>
                                    <p><code class="codeph"><a href="https://www.oracle.com/pls/topic/lookup?ctx=en/database/oracle/oracle-database/19/admin&amp;id=REFRN20279" target="_blank">ALL_TAB_HISTOGRAMS</a></code> 
                                    </p>
                                    <p><code class="codeph"><a href="https://www.oracle.com/pls/topic/lookup?ctx=en/database/oracle/oracle-database/19/admin&amp;id=REFRN26279" target="_blank">USER_TAB_HISTOGRAMS</a></code> 
                                    </p>
                                 </td>
                                 <td align="left" valign="top" width="67%" headers="d192334e22971 d192334e22663 ">
                                    <p>这些视图描述了表和视图的直方图。</p>
                                 </td>
                              </tr>
                              <tr align="left" valign="top">
                                 <td align="left" valign="top" width="33%" id="d192334e22994" headers="d192334e22660 ">
                                    <p><code class="codeph"><a href="https://www.oracle.com/pls/topic/lookup?ctx=en/database/oracle/oracle-database/19/admin&amp;id=REFRN23376" target="_blank">DBA_TAB_STATISTICS</a></code></p>
                                    <p><code class="codeph"><a href="https://www.oracle.com/pls/topic/lookup?ctx=en/database/oracle/oracle-database/19/admin&amp;id=REFRN20376" target="_blank">ALL_TAB_STATISTICS</a></code></p>
                                    <p><code class="codeph"><a href="https://www.oracle.com/pls/topic/lookup?ctx=en/database/oracle/oracle-database/19/admin&amp;id=REFRN26376" target="_blank">USER_TAB_STATISTICS</a></code></p>
                                 </td>
                                 <td align="left" valign="top" width="67%" headers="d192334e22994 d192334e22663 ">
                                    <p>这些视图包含表的优化程序统计信息。</p>
                                 </td>
                              </tr>
                              <tr align="left" valign="top">
                                 <td align="left" valign="top" width="33%" id="d192334e23014" headers="d192334e22660 ">
                                    <p><code class="codeph"><a href="https://www.oracle.com/pls/topic/lookup?ctx=en/database/oracle/oracle-database/19/admin&amp;id=REFRN23275" target="_blank">DBA_TAB_COL_STATISTICS</a></code> 
                                    </p>
                                    <p><code class="codeph"><a href="https://www.oracle.com/pls/topic/lookup?ctx=en/database/oracle/oracle-database/19/admin&amp;id=REFRN20275" target="_blank">ALL_TAB_COL_STATISTICS</a></code> 
                                    </p>
                                    <p><code class="codeph"><a href="https://www.oracle.com/pls/topic/lookup?ctx=en/database/oracle/oracle-database/19/admin&amp;id=REFRN26275" target="_blank">USER_TAB_COL_STATISTICS</a></code> 
                                    </p>
                                 </td>
                                 <td align="left" valign="top" width="67%" headers="d192334e23014 d192334e22663 ">
                                    <p>这些视图提供从相关<code class="codeph">TAB_COLUMNS</code>视图中提取的列统计信息和直方图信息。
                                    </p>
                                 </td>
                              </tr>
                              <tr align="left" valign="top">
                                 <td align="left" valign="top" width="33%" id="d192334e23040" headers="d192334e22660 ">
                                    <p><code class="codeph"><a href="https://www.oracle.com/pls/topic/lookup?ctx=en/database/oracle/oracle-database/19/admin&amp;id=REFRN23280" target="_blank">DBA_TAB_MODIFICATIONS</a></code> 
                                    </p>
                                    <p><code class="codeph"><a href="https://www.oracle.com/pls/topic/lookup?ctx=en/database/oracle/oracle-database/19/admin&amp;id=REFRN20280" target="_blank">ALL_TAB_MODIFICATIONS</a></code> 
                                    </p>
                                    <p><code class="codeph"><a href="../refrn/USER_TAB_MODIFICATIONS.html#REFRN26280" target="_blank">USER_TAB_MODIFICATIONS</a></code> 
                                    </p>
                                 </td>
                                 <td align="left" valign="top" width="67%" headers="d192334e23040 d192334e22663 ">
                                    <p>这些视图描述自上次收集表统计信息以来已修改的表。他们没有立即填充，但经过一段时间（通常3小时）后。</p>
                                 </td>
                              </tr>
                              <tr align="left" valign="top">
                                 <td align="left" valign="top" width="33%" id="d192334e23063" headers="d192334e22660 ">
                                    <p><code class="codeph"><a href="../refrn/DBA_ENCRYPTED_COLUMNS.html#REFRN23534" target="_blank">DBA_ENCRYPTED_COLUMNS</a></code></p>
                                    <p><code class="codeph"><a href="https://www.oracle.com/pls/topic/lookup?ctx=en/database/oracle/oracle-database/19/admin&amp;id=REFRN20534" target="_blank">ALL_ENCRYPTED_COLUMNS</a></code></p>
                                    <p><code class="codeph"><a href="https://www.oracle.com/pls/topic/lookup?ctx=en/database/oracle/oracle-database/19/admin&amp;id=REFRN26534" target="_blank">USER_ENCRYPTED_COLUMNS</a></code></p>
                                 </td>
                                 <td align="left" valign="top" width="67%" headers="d192334e23063 d192334e22663 ">
                                    <p>这些视图列出了已加密的表列，并且对于每列，列出了正在使用的加密算法。</p>
                                 </td>
                              </tr>
                              <tr align="left" valign="top">
                                 <td align="left" valign="top" width="33%" id="d192334e23083" headers="d192334e22660 ">
                                    <p><code class="codeph"><a href="https://www.oracle.com/pls/topic/lookup?ctx=en/database/oracle/oracle-database/19/admin&amp;id=REFRN23300" target="_blank">DBA_UNUSED_COL_TABS</a></code> 
                                    </p>
                                    <p><code class="codeph"><a href="https://www.oracle.com/pls/topic/lookup?ctx=en/database/oracle/oracle-database/19/admin&amp;id=REFRN20300" target="_blank">ALL_UNUSED_COL_TABS</a></code> 
                                    </p>
                                    <p><code class="codeph"><a href="https://www.oracle.com/pls/topic/lookup?ctx=en/database/oracle/oracle-database/19/admin&amp;id=REFRN26300" target="_blank">USER_UNUSED_COL_TABS</a></code> 
                                    </p>
                                 </td>
                                 <td align="left" valign="top" width="67%" headers="d192334e23083 d192334e22663 ">
                                    <p>这些视图列出了具有未使用列的表，由<code class="codeph">ALTER TABLE ...标记<code class="codeph">ALTER TABLE ...SET UNUSED</code>语句。
                                    </p>
                                 </td>
                              </tr>
                              <tr align="left" valign="top">
                                 <td align="left" valign="top" width="33%" id="d192334e23109" headers="d192334e22660 ">
                                    <p><code class="codeph"><a href="https://www.oracle.com/pls/topic/lookup?ctx=en/database/oracle/oracle-database/19/admin&amp;id=REFRN23160" target="_blank">DBA_PARTIAL_DROP_TABS</a></code> 
                                    </p>
                                    <p><code class="codeph"><a href="../refrn/ALL_PARTIAL_DROP_TABS.html#REFRN20160" target="_blank">ALL_PARTIAL_DROP_TABS</a></code> 
                                    </p>
                                    <p><code class="codeph"><a href="../refrn/USER_PARTIAL_DROP_TABS.html#REFRN26160" target="_blank">USER_PARTIAL_DROP_TABS</a></code> 
                                    </p>
                                 </td>
                                 <td align="left" valign="top" width="67%" headers="d192334e23109 d192334e22663 ">
                                    <p>这些视图列出了已部分完成<code class="codeph">DROP COLUMN</code>操作的表。这些操作可能不完整，因为操作被用户中断或系统故障。
                                    </p>
                                 </td>
                              </tr>
                           </tbody>
                        </table>
                     </div>
                     <!-- class="inftblhruleinformal" -->
                  </div>
                  <!-- class="section" -->
                  <div class="section">
                     <p class="subhead2" id="GUID-9E47D91A-E1F2-42F7-8704-1571B34C0410__GUID-7134EEF7-1D9D-42EC-8439-0E66152F27B1">示例：显示列信息</p>
                     <p><a id="d192334e23138" class="indexterm-anchor"></a>可以使用以<code class="codeph">_COLUMNS</code>后缀结尾的其中一个视图列出列信息，例如名称，数据类型，长度，精度，比例和默认数据值。例如，以下查询列出了<code class="codeph">emp</code>和<code class="codeph">dept</code>表的所有默认列值：</p><pre class="oac_no_warn" dir="ltr">SELECT TABLE_NAME，COLUMN_NAME，DATA_TYPE，DATA_LENGTH，LAST_ANALYZED FROM DBA_TAB_COLUMNS WHERE OWNER ='HR'ODER BY TABLE_NAME;</pre><p>以下是查询的输出：</p><pre class="oac_no_warn" dir="ltr">TABLE_NAME COLUMN_NAME DATA_TYPE DATA_LENGTH LAST_ANALYZED -------------------- -------------------- ----- ----- ------------ ------------- COUNTRY COUNTRY_ID CHAR 2 05-FEB-03 COUNTRIES COUNTRY_NAME VARCHAR2 40 05-FEB-03 COUNTRIES REGION_ID第22号05-FEB-03部门部门_ID号码22 05-FEB-03部门DEPARTMENT_NAME VARCHAR2 30 05-FEB-03部门经理_ID号码22 05-FEB-03部门位置_ID号码22 05-FEB-03员工员工人数22 22-FEB -03 EMPLOYEES FIRST_NAME VARCHAR2 20 05-FEB-03员工LAST_NAME VARCHAR2 25 05-FEB-03员工电子邮件VARCHAR2 25 05-FEB-03。。。LOCATIONS COUNTRY_ID CHAR 2 05-FEB-03 REGIONS REGION_ID NUMBER 22 05-FEB-03 REGIONS REGION_NAME VARCHAR2 25 05-FEB-03 51行已选中。</pre></div>
                  <!-- class="section" -->
               </div>
               <div>
                  <div class="infoboxnotealso" id="GUID-9E47D91A-E1F2-42F7-8704-1571B34C0410__GUID-C429F17F-1CCC-47A3-8830-B3ADDE1F5E7B">
                     <p class="notep1">也可以看看：</p>
                     <p></p>
                     <ul style="list-style-type:disc">
                        <li>
                           <p><a href="../adobj/key-features-object-relational-model.html#ADOBJ7034" target="_blank"><span class="italic">Oracle数据库对象关系开发人员指南</span></a> ，了解有关对象表的信息</p>
                        </li>
                        <li>
                           <p><a href="../tgsql/gathering-optimizer-statistics.html#TGSQL389" target="_blank"><span class="italic">“Oracle数据库SQL调优指南”，</span></a>以获取有关直方图和生成表统计信息的信息</p>
                        </li>
                        <li>
                           <p><span class="q">“ <a href="managing-schema-objects.html#GUID-DB5A9A4E-054B-4ECF-8E97-C93DC9783675" title="您可以收集有关架构对象的信息并分析该信息。">关于分析表，索引和群集</a> ”</span></p>
                        </li>
                     </ul>
                  </div>
                  <div class="familylinks">
                     <div class="parentlink">
                        <p><strong>父主题：</strong> <a href="managing-tables.html#GUID-707B02F5-E589-4C20-8E2E-5ED4F7888702" title="管理表包括创建表，加载表，更改表和删除表等任务。">管理表</a></p>
                     </div>
                  </div>
               </div>
               
            </div>
         </div>
      </article>
   </body>
</html>