<html lang="en-us" dir="ltr" xml:lang="en-us">
   <head>
      <meta http-equiv="Content-Type" content="text/html; charset=utf-8"></meta>
      <meta name="viewport" content="width=device-width, initial-scale=1"></meta>
      <meta http-equiv="X-UA-Compatible" content="IE=edge"></meta>
      <title>使用动态SQL</title>
      <meta property="og:site_name" content="Oracle Help Center"></meta>
      <meta property="og:title" content="Programmer&#39;s Guide to the Oracle Precompilers"></meta>
      <meta property="og:description" content=""></meta>
      <link rel="stylesheet" href="/sp_common/book-template/ohc-book-template/css/book.css"></link>
      <link rel="shortcut icon" href="/sp_common/book-template/ohc-common/img/favicon.ico"></link>
      <meta name="application-name" content="Programmer&#39;s Guide to the Oracle Precompilers"></meta>
      <meta name="generator" content="DITA Open Toolkit version 1.8.5 (Mode = doc)"></meta>
      <meta name="plugin" content="SP_docbuilder HTML plugin release 18.2.2"></meta>
      <link rel="alternate" href="programmers-guide-oracle-precompilers.pdf" title="PDF File" type="application/pdf"></link>
      <meta name="robots" content="all"></meta>
      <link rel="schema.dcterms" href="http://purl.org/dc/terms/"></link>
      <meta name="dcterms.created" content="2019-01-11T01:36:30-08:00"></meta>
      <meta name="dcterms.title" content="Programmer&#39;s Guide to the Oracle Precompilers"></meta>
      <meta name="dcterms.dateCopyrighted" content="2008, 2019"></meta>
      <meta name="dcterms.category" content="database"></meta>
      <meta name="dcterms.identifier" content="E96474-01"></meta>
      
      <meta name="dcterms.product" content="en/database/oracle/oracle-database/19"></meta>
      
      <link rel="prev" href="using-host-arrays.html" title="Previous" type="text/html"></link>
      <link rel="next" href="writing-user-exits.html" title="Next" type="text/html"></link>
      <script>
        document.write('<style type="text/css">');
        document.write('body > .noscript, body > .noscript ~ * { visibility: hidden; }');
        document.write('</style>');
     </script>
      <script src="/sp_common/book-template/requirejs/require.js" data-main="/sp_common/book-template/ohc-book-template/js/book-config"></script>
      <script>
            if (window.require === undefined) {
                document.write('<script data-main="sp_common/book-template/ohc-book-template/js/book-config" src="sp_common/book-template/requirejs/require.js"><\/script>');
                document.write('<link href="sp_common/book-template/ohc-book-template/css/book.css" rel="stylesheet"/>');
            }
        </script>
      <script type="application/json" id="ssot-metadata">{"primary":{"category":{"short_name":"database","element_name":"Database","display_in_url":true},"suite":{"short_name":"oracle","element_name":"Oracle","display_in_url":true},"product_group":{"short_name":"not-applicable","element_name":"Not applicable","display_in_url":false},"product":{"short_name":"oracle-database","element_name":"Oracle Database","display_in_url":true},"release":{"short_name":"19","element_name":"Release 19","display_in_url":true}}}</script>
      
    <meta name="dcterms.isVersionOf" content="ZZPRE"></meta>
    <meta name="dcterms.release" content="Release 19"></meta>
  </head>
   <body dir="ltr">
      <div class="noscript alert alert-danger text-center" role="alert">
         <a href="using-host-arrays.html" class="pull-left"><span class="glyphicon glyphicon-chevron-left" aria-hidden="true"></span>上一页</a> <a href="writing-user-exits.html" class="pull-right">下一页<span class="glyphicon glyphicon-chevron-right" aria-hidden="true"></span></a> <span class="fa fa-exclamation-triangle" aria-hidden="true"></span>必须启用JavaScript才能正确显示此内容</div>
      <article>
         <header>
            <ol class="breadcrumb" vocab="http://schema.org/" typeof="BreadcrumbList">
               <li property="itemListElement" typeof="ListItem"><a href="index.html" property="item" typeof="WebPage"><span property="name">程序员指南Oracle预编译器</span></a></li>
               <li class="active" property="itemListElement" typeof="ListItem">使用动态SQL</li>
            </ol>
            <a id="GUID-5C0F172A-6D8C-45FC-8F23-B544995108FE" name="GUID-5C0F172A-6D8C-45FC-8F23-B544995108FE"></a><a id="ZZPRE869"></a>
            
            <h2 id="ZZPRE-GUID-5C0F172A-6D8C-45FC-8F23-B544995108FE" class="sect2"><span class="enumeration_chapter">10</span>使用动态SQL</h2>
         </header>
         <div class="ind">
            <div>
               <p>本章介绍以下部分：</p>
               <ul style="list-style-type:disc">
                  <li>
                     <p><a href="using-dynamic-SQL.html#GUID-09DE3FA0-C622-466A-9A2E-A7735A970271">什么是动态SQL？</a> 
                     </p>
                  </li>
                  <li>
                     <p><a href="using-dynamic-SQL.html#GUID-FF94FD6C-7224-42AC-895A-18DD4DD386CD">动态SQL的优缺点</a></p>
                  </li>
                  <li>
                     <p><a href="using-dynamic-SQL.html#GUID-B9CBB2E6-5A6C-46FD-9089-27A73A3AF803">何时使用动态SQL</a></p>
                  </li>
                  <li>
                     <p><a href="using-dynamic-SQL.html#GUID-6E1145C9-54DD-4861-85B1-8F406701F65F">动态SQL语句的要求</a></p>
                  </li>
                  <li>
                     <p><a href="using-dynamic-SQL.html#GUID-30F8C760-69E7-4524-BF21-92C063CF513B">如何处理动态SQL语句</a></p>
                  </li>
                  <li>
                     <p><a href="using-dynamic-SQL.html#GUID-189A80C3-3816-42AC-AB03-CC664C0E9E85">使用动态SQL的方法</a></p>
                  </li>
                  <li>
                     <p><a href="using-dynamic-SQL.html#GUID-16F4F40D-E2C0-455C-9088-9173F96218A0">关于使用方法1</a></p>
                  </li>
                  <li>
                     <p><a href="using-dynamic-SQL.html#GUID-6D4826F3-E794-4A64-A9E9-497B9096B4C7">关于使用方法2</a></p>
                  </li>
                  <li>
                     <p><a href="using-dynamic-SQL.html#GUID-0234861C-39A8-4AE3-980E-31CA185076F1">关于使用方法3</a></p>
                  </li>
                  <li>
                     <p><a href="using-dynamic-SQL.html#GUID-C4762850-789A-463B-B573-7A7630EC1931">使用方法4</a></p>
                  </li>
                  <li>
                     <p><a href="using-dynamic-SQL.html#GUID-364E812E-312C-42BE-B0DA-7AC132EF46B8">关于使用DECLARE STATEMENT语句</a></p>
                  </li>
                  <li>
                     <p><a href="using-dynamic-SQL.html#GUID-25F8ABB7-6A51-4C3A-9DE7-DF86E3E3AA6B">关于使用PL / SQL</a></p>
                  </li>
               </ul>
               <p>本章介绍如何使用动态SQL，这是一种高级编程技术，可为应用程序增加灵活性和功能。在权衡了动态SQL的优缺点之后，您将学习从简单到复杂的四种方法，用于编写在运行时“即时”接受和处理SQL语句的程序。您将了解每种方法的要求和限制，以及如何为给定作业选择正确的方法。</p>
            </div><a id="ZZPRE870"></a><div class="props_rev_3"><a id="GUID-09DE3FA0-C622-466A-9A2E-A7735A970271" name="GUID-09DE3FA0-C622-466A-9A2E-A7735A970271"></a><h3 id="ZZPRE-GUID-09DE3FA0-C622-466A-9A2E-A7735A970271" class="sect3"><span class="enumeration_section">10.1</span>什么是动态SQL？
               </h3>
               <div>
                  <p><a id="d71876e106" class="indexterm-anchor"></a><a id="d71876e108" class="indexterm-anchor"></a>大多数数据库应用程序执行特定的工例如，一个简单的程序可能会提示用户输入员工编号，然后更新EMP和DEPT表中的行。在这种情况下，您知道在预编译时<code class="codeph">UPDATE</code>语句的组成。也就是说，您知道可能更改哪些表，为每个表和列定义的约束，可能更新的列以及每列的数据类型。
                  </p>
                  <p>但是，某些应用程序必须在运行时接受（或构建）和处理各种SQL语句。例如，通用报表编写者必须为其生成的各种报表构建不同的<code class="codeph">SELECT</code>语句。在这种情况下，语句的构成在运行时才会被识别。这些陈述可以并且可能会从执行变为执行。它们恰当地称为<span class="italic">动态</span> SQL语句。
                  </p>
                  <p>与静态SQL语句不同，动态SQL语句未嵌入源程序中。相反，它们存储在运行时输入或由程序构建的字符串中。它们可以交互式输入或从文件中读取。</p>
                  <p></p>
               </div>
            </div><a id="ZZPRE871"></a><div class="props_rev_3"><a id="GUID-FF94FD6C-7224-42AC-895A-18DD4DD386CD" name="GUID-FF94FD6C-7224-42AC-895A-18DD4DD386CD"></a><h3 id="ZZPRE-GUID-FF94FD6C-7224-42AC-895A-18DD4DD386CD" class="sect3"><span class="enumeration_section">10.2</span>动态SQL的优缺点</h3>
               <div>
                  <p><a id="d71876e148" class="indexterm-anchor"></a>接受和处理动态定义的SQL语句的主机程序比普通的嵌入式SQL程序更通用。可以使用对SQL知之甚少或根本不了解的用户的输入以交互方式构建动态SQL语句。</p>
                  <p>例如，您的程序可能只是提示用户在<code class="codeph">SELECT</code> ， <code class="codeph">UPDATE</code>或<code class="codeph">DELETE</code>语句的<code class="codeph">WHERE</code>子句中使用搜索条件。更复杂的程序可能允许用户从列出SQL操作，表和视图名称，列名称等的菜单中进行选择。因此，动态SQL允许您编写高度灵活的应用程序。
                  </p>
                  <p>但是，一些动态查询需要复杂的编码，特殊数据结构的使用以及更多的运行时处理。虽然您可能没有注意到增加的处理时间，但除非您完全理解动态SQL概念和方法，否则您可能会发现编码很困难。</p>
                  <p></p>
               </div>
            </div><a id="ZZPRE872"></a><div class="props_rev_3"><a id="GUID-B9CBB2E6-5A6C-46FD-9089-27A73A3AF803" name="GUID-B9CBB2E6-5A6C-46FD-9089-27A73A3AF803"></a><h3 id="ZZPRE-GUID-B9CBB2E6-5A6C-46FD-9089-27A73A3AF803" class="sect3"><span class="enumeration_section">10.3</span>何时使用动态SQL</h3>
               <div>
                  <p>实际上，静态SQL几乎可以满足您的所有编程需求。仅在需要开放式灵活性时才使用动态SQL。当预编译时未知以下一项或多项时，建议使用它：<a id="d71876e193" class="indexterm-anchor"></a></p>
                  <ul style="list-style-type:disc">
                     <li>
                        <p>Sql语句的文本（命令，子句等等）</p>
                     </li>
                     <li>
                        <p>主机变量的数量</p>
                     </li>
                     <li>
                        <p>主机变量的数据类型</p>
                     </li>
                     <li>
                        <p>对数据库对象的引用，如列，索引，序列，表，用户名和视图</p>
                     </li>
                  </ul>
               </div>
            </div><a id="ZZPRE873"></a><div class="props_rev_3"><a id="GUID-6E1145C9-54DD-4861-85B1-8F406701F65F" name="GUID-6E1145C9-54DD-4861-85B1-8F406701F65F"></a><h3 id="ZZPRE-GUID-6E1145C9-54DD-4861-85B1-8F406701F65F" class="sect3"><span class="enumeration_section">10.4</span>动态SQL语句的要求</h3>
               <div>
                  <p><a id="d71876e237" class="indexterm-anchor"></a>要表示动态SQL语句，字符串必须包含有效SQL语句的文本，但<span class="italic">不</span>包含EXEC SQL子句，主机语言分隔符或语句终止符或以下任何嵌入式SQL命令：</p>
                  <ul style="list-style-type:disc">
                     <li>
                        <p><code class="codeph">关</code></p>
                     </li>
                     <li>
                        <p><code class="codeph">宣布</code></p>
                     </li>
                     <li>
                        <p><code class="codeph">描述</code></p>
                     </li>
                     <li>
                        <p><code class="codeph">执行</code></p>
                     </li>
                     <li>
                        <p><code class="codeph">取</code></p>
                     </li>
                     <li>
                        <p><code class="codeph">包括</code></p>
                     </li>
                     <li>
                        <p><code class="codeph">打开</code></p>
                     </li>
                     <li>
                        <p><code class="codeph">准备</code></p>
                     </li>
                     <li>
                        <p><code class="codeph">每当</code></p>
                     </li>
                  </ul>
                  <p><a id="d71876e283" class="indexterm-anchor"></a>在大多数情况下，字符串可以包含<span class="italic">虚拟</span>主机变量。它们在SQL语句中保存实际主机变量的位置。因为虚拟主机变量只是<a id="d71876e289" class="indexterm-anchor"></a><a id="d71876e293" class="indexterm-anchor"></a>占位符，您不会声明它们，并可以将它们命名为您喜欢的任何名称。例如，Oracle不区分以下两个字符串：</p><pre class="oac_no_warn" dir="ltr">'从EMP删除MGR =：mgr_number AND JOB =：job_title''从EMP删除MGR =：m AND JOB =：j'</pre></div>
            </div><a id="ZZPRE874"></a><div class="props_rev_3"><a id="GUID-30F8C760-69E7-4524-BF21-92C063CF513B" name="GUID-30F8C760-69E7-4524-BF21-92C063CF513B"></a><h3 id="ZZPRE-GUID-30F8C760-69E7-4524-BF21-92C063CF513B" class="sect3"><span class="enumeration_section">10.5</span>如何处理动态SQL语句</h3>
               <div>
                  <p><a id="d71876e321" class="indexterm-anchor"></a><a id="d71876e325" class="indexterm-anchor"></a>通常，应用程序会提示用户输入SQL语句的文本以及语句中使用的主机变量的值。然后Oracle <span class="italic">解析</span> SQL语句。也就是说，Oracle检查SQL语句以确保它遵循语法规则并引用有效的数据库对象。解析还涉及检查数据库访问权限，保留所需资源以及查找最佳访问路径。
                  </p>
                  <p><a id="d71876e332" class="indexterm-anchor"></a><a id="d71876e334" class="indexterm-anchor"></a>接下来，Oracle <span class="italic">将</span>主机变量<span class="italic">绑定</span>到SQL语句。也就是说，Oracle获取主机变量的地址，以便它可以读取或写入它们的值。
                  </p>
                  <p>然后Oracle <span class="italic">执行</span> SQL语句。也就是说，Oracle执行SQL语句请求的内容，例如从表中删除行。
                  </p>
                  <p>可以使用主机变量的新值重复执行SQL语句。</p>
               </div>
            </div><a id="ZZPRE876"></a><a id="ZZPRE875"></a><div class="props_rev_3"><a id="GUID-189A80C3-3816-42AC-AB03-CC664C0E9E85" name="GUID-189A80C3-3816-42AC-AB03-CC664C0E9E85"></a><h3 id="ZZPRE-GUID-189A80C3-3816-42AC-AB03-CC664C0E9E85" class="sect3"><span class="enumeration_section">10.6</span>使用动态SQL的方法</h3>
               <div>
                  <p>本节介绍可用于定义动态SQL语句的四种方法。它简要描述了每种方法的功能和局限性，然后提供了选择正确方法的指南。后面的部分描述了如何使用这些方法。此外，您可以在本指南的补充中找到示例主机语言程序。</p>
                  <p>这四种方法越来越普遍。也就是说，方法2包括方法1，方法3包括方法1和2，等等。但是，每种方法对于处理某种SQL语句最有用，如<a href="using-dynamic-SQL.html#GUID-189A80C3-3816-42AC-AB03-CC664C0E9E85__BCEGIJJC" title="使用动态sql的方法">表10-1</a>所示。
                  </p>
                  <div class="tblformal" id="GUID-189A80C3-3816-42AC-AB03-CC664C0E9E85__BCEGIJJC">
                     <p class="titleintable">表10-1动态SQL方法适用性</p>
                     <table cellpadding="4" cellspacing="0" class="Formal" title="动态SQL方法适用性" width="100%" border="1" summary="methods for using dynamic sql" frame="hsides" rules="rows">
                        <thead>
                           <tr align="left" valign="top">
                              <th align="left" valign="bottom" width="13%" id="d71876e390">方法</th>
                              <th align="left" valign="bottom" width="87%" id="d71876e393">一种SQL语句</th>
                           </tr>
                        </thead>
                        <tbody>
                           <tr align="left" valign="top">
                              <td align="left" valign="top" width="13%" id="d71876e398" headers="d71876e390 ">
                                 <p>1</p>
                              </td>
                              <td align="left" valign="top" width="87%" headers="d71876e398 d71876e393 ">
                                 <p>没有输入主变量的非查询</p>
                              </td>
                           </tr>
                           <tr align="left" valign="top">
                              <td align="left" valign="top" width="13%" id="d71876e405" headers="d71876e390 ">
                                 <p>2</p>
                              </td>
                              <td align="left" valign="top" width="87%" headers="d71876e405 d71876e393 ">
                                 <p>具有已知数量的输入主变量的非查询</p>
                              </td>
                           </tr>
                           <tr align="left" valign="top">
                              <td align="left" valign="top" width="13%" id="d71876e412" headers="d71876e390 ">
                                 <p>3</p>
                              </td>
                              <td align="left" valign="top" width="87%" headers="d71876e412 d71876e393 ">
                                 <p>查询具有已知数量的选择列表项和输入主变量</p>
                              </td>
                           </tr>
                           <tr align="left" valign="top">
                              <td align="left" valign="top" width="13%" id="d71876e419" headers="d71876e390 ">
                                 <p>4</p>
                              </td>
                              <td align="left" valign="top" width="87%" headers="d71876e419 d71876e393 ">
                                 <p>查询具有未知数量的选择列表项或输入主变量</p>
                              </td>
                           </tr>
                        </tbody>
                     </table>
                  </div>
                  <!-- class="inftblhruleinformal" -->
                  <p>术语<span class="italic">select-list项</span>包括列名和表达式。
                  </p>
               </div><a id="ZZPRE877"></a><div class="props_rev_3"><a id="GUID-2CFACD56-25D2-417A-A5F1-C5917E3610B3" name="GUID-2CFACD56-25D2-417A-A5F1-C5917E3610B3"></a><h4 id="ZZPRE-GUID-2CFACD56-25D2-417A-A5F1-C5917E3610B3" class="sect4"><span class="enumeration_section">10.6.1</span>方法1</h4>
                  <div>
                     <div class="section">
                        <p>此方法允许程序接受或构建动态SQL语句，然后使用<code class="codeph">EXECUTE</code> <code class="codeph">IMMEDIATE</code>命令立即执行它。SQL语句不能是查询（ <code class="codeph">SELECT</code>语句），并且不能包含输入主机变量的任何占位符。例如，以下主机字符串符合条件：</p><pre class="oac_no_warn" dir="ltr">'从EMP删除DEPTNO = 20''选择EMP到斯科特'</pre><p>使用方法1，每次执行时都会解析SQL语句（除非指定<code class="codeph">HOLD_CURSOR</code> = <code class="codeph">YES</code> ）。
                        </p>
                     </div>
                     <!-- class="section" -->
                  </div>
               </div><a id="ZZPRE878"></a><div class="props_rev_3"><a id="GUID-F1FF4F30-336F-43D0-85C1-AAA624CEB9C8" name="GUID-F1FF4F30-336F-43D0-85C1-AAA624CEB9C8"></a><h4 id="ZZPRE-GUID-F1FF4F30-336F-43D0-85C1-AAA624CEB9C8" class="sect4"><span class="enumeration_section">10.6.2</span>方法2</h4>
                  <div>
                     <div class="section">
                        <p>此方法允许程序接受或构建动态SQL语句，然后使用<code class="codeph">PREPARE</code>和<code class="codeph">EXECUTE</code>命令对其进行处理<a id="d71876e501" class="indexterm-anchor"></a> 。SQL语句不能是查询。必须在预编译时知道输入主机变量的占位符数和输入主机变量的数据类型。例如，以下主机字符串属于以下类别：</p><pre class="oac_no_warn" dir="ltr">'INSERT INTO EMP（ENAME，JOB）VALUES（：emp_name，：job_title）''从EMP删除EMPNO =：emp_number'</pre><p>使用方法2，SQL语句只解析一次（除非您指定<code class="codeph">RELEASE_CURSOR</code> = <code class="codeph">YES</code> ），但它可以使用不同的主机变量值执行多次。诸如<code class="codeph">CREATE</code>类的SQL数据定义语句在它们是<code class="codeph">PREPARE</code> d时执行。</p>
                     </div>
                     <!-- class="section" -->
                  </div>
               </div><a id="ZZPRE879"></a><div class="props_rev_3"><a id="GUID-CDCAC1E4-5F06-421A-80FC-8B119B5788E8" name="GUID-CDCAC1E4-5F06-421A-80FC-8B119B5788E8"></a><h4 id="ZZPRE-GUID-CDCAC1E4-5F06-421A-80FC-8B119B5788E8" class="sect4"><span class="enumeration_section">10.6.3</span>方法3</h4>
                  <div>
                     <div class="section">
                        <p>此方法允许程序接受或构建动态查询，然后使用带有<code class="codeph">DECLARE</code> ， <code class="codeph">OPEN</code> ， <code class="codeph">FETCH</code>和<code class="codeph">CLOSE</code>游标命令的PREPARE命令处理它。必须在预编译时知道选择列表项的数量，输入主机变量的占位符数以及输入主机变量的数据类型。例如，以下主机字符串符合条件：</p><pre class="oac_no_warn" dir="ltr">'按DEPTNO从EMP GROUP中选择DEPTNO，MIN（SAL），MAX（SAL）''选择ENAME，EMPNO从EMP到DEPTNO =：dept_number'</pre></div>
                     <!-- class="section" -->
                  </div>
               </div><a id="ZZPRE880"></a><div class="props_rev_3"><a id="GUID-7711238F-BE2F-4858-8E6D-C7271375CF8B" name="GUID-7711238F-BE2F-4858-8E6D-C7271375CF8B"></a><h4 id="ZZPRE-GUID-7711238F-BE2F-4858-8E6D-C7271375CF8B" class="sect4"><span class="enumeration_section">10.6.4</span>方法4</h4>
                  <div>
                     <div class="section">
                        <p>此方法允许程序接受或构建动态SQL语句，然后使用描述符对其进行处理（在“使用方法4”中讨论）。在运行时之前，选择列表项的数量，输入主机变量的占位符数以及输入主机变量的数据类型可能是未知的。例如，以下主机字符串属于以下类别：</p><pre class="oac_no_warn" dir="ltr">'INSERT INTO EMP（&lt;unknown&gt;）VALUES（&lt;unknown&gt;）''SELECT &lt;unknown&gt; FROM EMP WHERE DEPTNO = 20'</pre><p>对于包含未知数量的选择列表项或输入主机变量的动态SQL语句，需要方法4。</p>
                     </div>
                     <!-- class="section" -->
                  </div>
               </div><a id="ZZPRE881"></a><div class="props_rev_3"><a id="GUID-A00CDB28-2CB4-4622-87CF-093FDBE172CD" name="GUID-A00CDB28-2CB4-4622-87CF-093FDBE172CD"></a><h4 id="ZZPRE-GUID-A00CDB28-2CB4-4622-87CF-093FDBE172CD" class="sect4"><span class="enumeration_section">10.6.5</span>指南</h4>
                  <div>
                     <p><a id="d71876e608" class="indexterm-anchor"></a><a id="d71876e612" class="indexterm-anchor"></a>使用所有四种方法，必须将动态SQL语句存储在字符串中，该字符串必须是主变量或带引号的文字。将SQL语句存储在字符串中时，请省略关键字EXEC SQL和语句终止符。
                     </p>
                     <p><a id="d71876e618" class="indexterm-anchor"></a>使用方法2和3，必须在预编译时知道输入主变量的占位符数和输入主变量的数据类型。
                     </p>
                     <p>每个后续方法对应用程序施加的约束较少，但编码起来更加困难。通常，使用最简单的方法。但是，如果要由方法1重复执行动态SQL语句，请使用方法2来避免每次执行的重新分析。</p>
                     <p>方法4提供了最大的灵活性，但需要复杂的编码和对动态SQL概念的充分理解。通常，仅当您不能使用方法1,2或3时才使用方法4。<a href="using-dynamic-SQL.html#GUID-2F002EC7-F447-4AA3-9646-65DFF46D3B3F__CHDJHDJA">图10-1中</a>的决策逻辑将帮助您选择正确的方法。
                     </p>
                  </div>
               </div><a id="ZZPRE883"></a><a id="ZZPRE882"></a><div class="props_rev_3"><a id="GUID-2F002EC7-F447-4AA3-9646-65DFF46D3B3F" name="GUID-2F002EC7-F447-4AA3-9646-65DFF46D3B3F"></a><h4 id="ZZPRE-GUID-2F002EC7-F447-4AA3-9646-65DFF46D3B3F" class="sect4"><span class="enumeration_section">10.6.6</span>避免常见错误</h4>
                  <div>
                     <div class="section">
                        <p>如果使用字符数组存储动态SQL语句，请在存储SQL语句之前对数组进行空白填充。这样，你就清除了无关紧要的角色。当您将数组重用于不同的SQL语句时，这一点尤为重要。通常，在存储SQL语句之前始终初始化（或重新初始化）主机字符串。</p>
                        <p>不要空终止主机字符串。Oracle不会将null终止符识别为字符串结尾的标记。相反，Oracle将其视为SQL语句的一部分。</p>
                        <p>如果使用<code class="codeph">VARCHAR</code>变量存储动态SQL语句，请确保在执行PREPARE或<code class="codeph">EXECUTE</code> <code class="codeph">IMMEDIATE</code>语句之前正确设置（或重置） <code class="codeph">VARCHAR</code>的长度。
                        </p>
                        <p><code class="codeph">EXECUTE</code>重置SQLCA中的SQLWARN警告标志。因此，要捕获诸如无条件更新（由省略<code class="codeph">WHERE</code>子句引起）之类的错误，请在执行<code class="codeph">PREPARE</code>语句之后但在执行<code class="codeph">EXECUTE</code>语句之前检查SQLWARN标志。
                        </p>
                        <div class="figure" id="GUID-2F002EC7-F447-4AA3-9646-65DFF46D3B3F__CHDJHDJA">
                           <p class="titleinfigure">图10-1选择正确的方法</p><img src="img/image013.gif" alt="下面是图10-1的描述" title="下面是图10-1的描述" longdesc="img_text/image013.html"><br><a href="img_text/image013.html">“图10-1选择正确方法”的说明</a></div>
                        <!-- class="figure" -->
                     </div>
                     <!-- class="section" -->
                  </div>
               </div>
            </div><a id="ZZPRE884"></a><div class="props_rev_3"><a id="GUID-16F4F40D-E2C0-455C-9088-9173F96218A0" name="GUID-16F4F40D-E2C0-455C-9088-9173F96218A0"></a><h3 id="ZZPRE-GUID-16F4F40D-E2C0-455C-9088-9173F96218A0" class="sect3"><span class="enumeration_section">10.7</span>关于使用方法1</h3>
               <div>
                  <p><a id="d71876e709" class="indexterm-anchor"></a>最简单的动态SQL语句仅导致“成功”或“失败”，并且不使用主机变量。一些例子如下：</p><pre class="oac_no_warn" dir="ltr">'DELETE FROM table_name WHERE column_name = constant''CREATE TABLE table_name ...''DROP INDEX index_name''UPDATE table_name SET column_name = constant''GRANT SELECT ON table_name TO username''REVOKE RESOURCE FROM username'</pre></div><a id="ZZPRE885"></a><div class="props_rev_3"><a id="GUID-96884DCF-A70A-4C01-84FB-14CE9E1B8A0B" name="GUID-96884DCF-A70A-4C01-84FB-14CE9E1B8A0B"></a><h4 id="ZZPRE-GUID-96884DCF-A70A-4C01-84FB-14CE9E1B8A0B" class="sect4"><span class="enumeration_section">10.7.1</span> EXECUTE IMMEDIATE语句</h4>
                  <div>
                     <div class="section">
                        <p><a id="d71876e738" class="indexterm-anchor"></a>方法1解析，然后使用<code class="codeph">EXECUTE</code> <code class="codeph">IMMEDIATE</code>命令立即执行SQL语句。该命令后跟一个字符串（主机变量或文字），其中包含要执行的SQL语句，该语句不能是查询。
                        </p>
                        <p><a id="d71876e750" class="indexterm-anchor"></a> <code class="codeph">EXECUTE</code> <code class="codeph">IMMEDIATE</code>语句的语法如下：</p><pre class="oac_no_warn" dir="ltr">EXEC SQL EXECUTE IMMEDIATE {：host_string |字符串字面量 };</pre><p><a id="d71876e764" class="indexterm-anchor"></a>在以下示例中，您使用主机变量<span class="italic">sql_stmt</span>来存储用户输入的SQL语句：</p><pre class="oac_no_warn" dir="ltr">EXEC SQL BEGIN DECLARE SECTION; ...sql_stmt CHARACTER（120）; EXEC SQL END DECLARE SECTION; ...LOOP显示'输入SQL语句：';读取sql_stmt;如果sql_stmt为空那么退出循环;万一; -  sql_stmt现在包含SQL语句的文本EXEC SQL EXECUTE IMMEDIATE：sql_stmt; ENDLOOP;</pre><p>您还可以使用字符串文字，如以下示例所示：</p><pre class="oac_no_warn" dir="ltr">EXEC SQL EXECUTE IMMEDIATE'从MILLER中撤回资源';</pre><p>因为EXECUTE IMMEDIATE在每次执行之前解析输入SQL语句，所以方法1最适合仅执行一次的语句。数据定义语句通常属于此类别。</p>
                     </div>
                     <!-- class="section" -->
                  </div>
               </div><a id="ZZPRE886"></a><div class="props_rev_3"><a id="GUID-2589EFC3-AEF9-4B6E-ADE4-BA521B663E9C" name="GUID-2589EFC3-AEF9-4B6E-ADE4-BA521B663E9C"></a><h4 id="ZZPRE-GUID-2589EFC3-AEF9-4B6E-ADE4-BA521B663E9C" class="sect4"><span class="enumeration_section">10.7.2</span>一个例子</h4>
                  <div>
                     <p><a id="d71876e801" class="indexterm-anchor"></a>以下程序提示用户在<code class="codeph">UPDATE</code>语句的<code class="codeph">WHERE</code>子句中使用搜索条件，然后使用方法1执行语句：</p><pre class="oac_no_warn" dir="ltr">EXEC SQL BEGIN DECLARE SECTION;用户名CHARACTER（20）;密码CHARACTER（20）; update_stmt CHARACTER（120）; EXEC SQL END DECLARE SECTION; search_cond CHARACTER（40）; EXEC SQL包含SQLCA;显示'用户名？“;读取用户名;显示'密码？“;读密码;执行SQL WHENEVER SQLERROR GOTO sql_error; EXEC SQL CONNECT：用户名IDENTIFIED BY：密码;显示'连接到Oracle'; set update_stmt ='UPDATE EMP SET COMM = 500 WHERE';显示'输入以下语句的搜索条件：'; display update_stmt;读search_cond; concatenate update_stmt，search_cond; EXEC SQL EXECUTE IMMEDIATE：update_stmt; EXEC SQL COMMIT WORK RELEASE;退出计划; sql_error：EXEC SQL WHENEVER SQLERROR CONTINUE; EXEC SQL ROLLBACK工作版;显示'处理错误';退出程序有错误;</pre></div>
               </div>
            </div><a id="ZZPRE887"></a><div class="props_rev_3"><a id="GUID-6D4826F3-E794-4A64-A9E9-497B9096B4C7" name="GUID-6D4826F3-E794-4A64-A9E9-497B9096B4C7"></a><h3 id="ZZPRE-GUID-6D4826F3-E794-4A64-A9E9-497B9096B4C7" class="sect3"><span class="enumeration_section">10.8</span>关于使用方法2</h3>
               <div>
                  <p><a id="d71876e839" class="indexterm-anchor"></a>方法1在一步中做了什么，方法2做了两个。动态SQL语句， <a id="d71876e844" class="indexterm-anchor"></a>它不能是一个查询，首先是<code class="codeph">PREPARE</code> d（命名和解析），然后执行。
                  </p>
                  <p> <a id="d71876e854" class="indexterm-anchor"></a>使用方法2，SQL语句可以包含<a id="d71876e859" class="indexterm-anchor"></a>输入主变量和指标变量的占位符。您可以一次<code class="codeph">PREPARE</code> SQL语句，然后使用不同的主机变量值重复<code class="codeph">EXECUTE</code>它。而且，你<span class="italic">不必</span> rePREPARE后的SQL语句<code class="codeph">COMMIT</code>或<code class="codeph">ROLLBACK</code> （除非你注销并重新连接）。
                  </p>
                  <p>请注意，您可以使用方法4对非查询<code class="codeph">EXECUTE</code> 。
                  </p>
                  <p><code class="codeph">PREPARE</code>语句的语法如下：</p><pre class="oac_no_warn" dir="ltr">EXEC SQL PREPARE statement_name FROM {：host_string |字符串字面量 };</pre><p><code class="codeph">PREPARE</code>解析SQL语句并为其命名。
                  </p>
                  <p><span class="italic">statement_name</span>是预编译器使用的标识符， <span class="italic">而不是</span>主机或程序变量，不应在Declare Section中声明。它只是指定要<code class="codeph">EXECUTE</code>的<code class="codeph">PREPAREd</code>语句。</p>
                  <p><code class="codeph">EXECUTE</code>语句的语法是</p><pre class="oac_no_warn" dir="ltr">EXEC SQL EXECUTE statement_name [USING host_variable_list];</pre><p>其中<span class="italic">host_variable_list</span>代表以下语法：</p><pre class="oac_no_warn" dir="ltr">：host_variable1 [：indicator1] [，host_variable2 [：indicator2]，...]
</pre><p><code class="codeph">EXECUTE</code>使用为每个输入主机变量提供的值执行已解析的SQL语句。在以下示例中，输入SQL语句包含占位符<span class="italic">n</span> ：</p><pre class="oac_no_warn" dir="ltr">EXEC SQL BEGIN DECLARE SECTION; ...emp_number INTEGER; delete_stmt CHARACTER（120）; EXEC SQL END DECLARE SECTION; search_cond CHARACTER（40）; ...set delete_stmt ='DELETE FROM EMP WHERE EMPNO =：n AND';显示'完成以下语句的搜索条件：'; display delete_stmt;读search_cond; concatenate delete_stmt，search_cond; EXEC SQL PREPARE sql_stmt FROM：delete_stmt; LOOP显示'输入员工编号：';读取emp_number;如果emp_number = 0那么退出循环; EXEC SQL EXECUTE sql_stmt USING：emp_number; ENDLOOP;</pre><p>使用方法2，您必须在预编译时知道输入主机变量的数据类型。在最后一个示例中， <span class="italic">emp_number</span>被声明为<code class="codeph">INTEGER</code>类型。它也可以声明为<code class="codeph">CHARACTER</code>或<code class="codeph">REAL</code>类型，因为Oracle支持所有这些数据类型转换为<code class="codeph">NUMBER</code>数据类型。
                  </p>
               </div><a id="ZZPRE888"></a><div class="props_rev_3"><a id="GUID-25E6C4AD-4E12-4039-BC00-586DD183E92F" name="GUID-25E6C4AD-4E12-4039-BC00-586DD183E92F"></a><h4 id="ZZPRE-GUID-25E6C4AD-4E12-4039-BC00-586DD183E92F" class="sect4"><span class="enumeration_section">10.8.1</span>使用条款</h4>
                  <div>
                     <p>当SQL语句为<code class="codeph">EXECUTEd</code> ， <code class="codeph">USING</code>子句中的输入主机变量将替换<code class="codeph">PREPAREd</code>动态SQL语句中的相应占位符。
                     </p>
                     <p>PREPAREd动态SQL语句中的每个占位符都必须与<code class="codeph">USING</code>子句中的主机变量相对应。因此，如果相同的占位符在<code class="codeph">PREPAREd</code>语句中出现两次或多次，则每个外观必须对应于<code class="codeph">USING</code>子句中的主变量。如果<code class="codeph">USING</code>子句中的一个主变量是一个数组，则所有主变量都必须是数组。
                     </p>
                     <p><a id="d71876e1001" class="indexterm-anchor"></a>占位符的名称不需要与主变量的名称匹配。但是， <code class="codeph">PREPAREd</code>动态SQL语句中占位符的顺序必须与<code class="codeph">USING</code>子句中相应主机变量的顺序匹配。
                     </p>
                     <p><a id="d71876e1013" class="indexterm-anchor"></a>要指定空值，可以将指示符变量与<code class="codeph">USING</code>子句中的主变量相关联。有关更多信息，请参阅<span class="q">“ <a href="using-embedded-SQL.html#GUID-E4FC1AF8-5BCC-49CB-B3A5-83C99CA7A45A">关于使用指示符变量</a> ”</span> 。
                     </p>
                  </div>
               </div><a id="ZZPRE889"></a><div class="props_rev_3"><a id="GUID-AFD24CAC-6353-4295-814B-0C8C5CCD25EB" name="GUID-AFD24CAC-6353-4295-814B-0C8C5CCD25EB"></a><h4 id="ZZPRE-GUID-AFD24CAC-6353-4295-814B-0C8C5CCD25EB" class="sect4"><span class="enumeration_section">10.8.2</span>一个例子</h4>
                  <div>
                     <p> <a id="d71876e1048" class="indexterm-anchor"></a>以下程序提示用户在<code class="codeph">UPDATE</code>语句的<code class="codeph">WHERE</code>子句中使用搜索条件，然后使用方法2准备并执行该语句。请注意， <code class="codeph">UPDATE</code>语句的<code class="codeph">SET</code>子句包含占位符（ <span class="italic">c</span> ）。
                     </p><pre class="oac_no_warn" dir="ltr">EXEC SQL BEGIN DECLARE SECTION;用户名CHARACTER（20）;密码CHARACTER（20）; sql_stmt CHARACTER（80）; empno INTEGER VALUE 1234; deptno1 INTEGER VALUE 97; deptno2 INTEGER VALUE 99; EXEC SQL END DECLARE SECTION; EXEC SQL包含SQLCA; EXEC ORACLE选项（ORACA = YES）;执行SQL WHENEVER SQLERROR GOTO sql_error;显示'用户名？“;读取用户名;显示'密码？“;读密码; EXEC SQL CONNECT：用户名IDENTIFIED BY：密码;显示'连接到Oracle'; set sql_stmt ='INSERT INTO EMP（EMPNO，DEPTNO）VALUES（：v1，：v2）';显示“V1 =”，empno，“V2 =”，deptno1; EXEC SQL PREPARE S FROM：sql_stmt; EXEC SQL EXECUTE S使用：empno，：deptno1; set empno = empno + 1;显示“V1 =”，empno，“V2 =”，deptno2; EXEC SQL EXECUTE S使用：empno，：deptno2; set sql_stmt ='DELETE FROM EMP WHERE DEPTNO =：v1 OR DEPTNO =：v2“）'; display”V1 =“，deptno1，”V2 =“，deptno2; EXEC SQL PREPARE S FROM：sql_stmt; EXEC SQL EXECUTE S使用： deptno1，：deptno2; EXEC SQL COMMIT WORK RELEASE;退出程序; sql_error：EXEC SQL WHENEVER SQLERROR CONTINUE;显示'处理错误'; EXEC SQL ROLLBACK WORK RELEASE;退出程序出错;</pre></div>
               </div>
            </div><a id="ZZPRE890"></a><div class="props_rev_3"><a id="GUID-0234861C-39A8-4AE3-980E-31CA185076F1" name="GUID-0234861C-39A8-4AE3-980E-31CA185076F1"></a><h3 id="ZZPRE-GUID-0234861C-39A8-4AE3-980E-31CA185076F1" class="sect3"><span class="enumeration_section">10.9</span>关于使用方法3</h3>
               <div>
                  <p><a id="d71876e1093" class="indexterm-anchor"></a>方法3类似于方法2 <a id="d71876e1098" class="indexterm-anchor"></a>但是将<code class="codeph">PREPARE</code>语句与定义和操作游标所需的语句结合起来。这允许您的程序接受和处理查询。实际上，如果动态SQL语句是查询，则<span class="italic">必须</span>使用方法3或4。
                  </p>
                  <p><a id="d71876e1110" class="indexterm-anchor"></a>对于方法3，必须在预编译时知道查询选择列表中的列数和输入主机变量的占位符数。但是，在运行时之前不需要指定数据库对象（如表和列）的名称（它们不能复制主变量的名称）。还可以在运行时指定限制，分组和排序查询结果（例如<code class="codeph">WHERE</code> ， <code class="codeph">GROUP</code> <code class="codeph">BY</code>和<code class="codeph">ORDER</code> <code class="codeph">BY</code> ）的<code class="codeph">BY</code> 。
                  </p>
                  <p>使用方法3，您可以使用以下嵌入式SQL语句序列：</p><pre class="oac_no_warn" dir="ltr">PREPARE statement_name FROM {：host_string |字符串字面量 }; DECLARE cursor_name CURSOR FOR statement_name; OPEN cursor_name [USING host_variable_list]; FETCH cursor_name INTO host_variable_list; CLOSE cursor_name;</pre><p>现在让我们看看每个声明的作用。</p>
               </div><a id="ZZPRE891"></a><div class="props_rev_3"><a id="GUID-47931071-4091-4D65-9AD4-21D4BEC2804A" name="GUID-47931071-4091-4D65-9AD4-21D4BEC2804A"></a><h4 id="ZZPRE-GUID-47931071-4091-4D65-9AD4-21D4BEC2804A" class="sect4"><span class="enumeration_section">10.9.1准备</span></h4>
                  <div>
                     <div class="section">
                        <p><a id="d71876e1164" class="indexterm-anchor"></a> <code class="codeph">PREPARE</code>解析动态SQL语句并为其命名。在以下示例中， <code class="codeph">PREPARE</code>解析存储在字符串<span class="italic">select_stmt中</span>的查询，并为其指定名称<span class="italic">sql_stmt</span> ：</p><pre class="oac_no_warn" dir="ltr">set select_stmt ='SELECT MGR，JOB FROM EMP WHERE SAL &lt;：salary'; EXEC SQL PREPARE sql_stmt FROM：select_stmt;</pre><p>通常，查询<code class="codeph">WHERE</code>子句在运行时从终端输入或由应用程序生成。
                        </p>
                        <p>标识符<span class="italic">sql_stmt</span> <span class="italic">不是</span>主机或程序变量，但必须是唯一的。它指定一个特定的动态SQL语句。
                        </p>
                     </div>
                     <!-- class="section" -->
                  </div>
               </div><a id="ZZPRE892"></a><div class="props_rev_3"><a id="GUID-E0FCAF15-F8E5-4AF8-A155-77ABA06C2370" name="GUID-E0FCAF15-F8E5-4AF8-A155-77ABA06C2370"></a><h4 id="ZZPRE-GUID-E0FCAF15-F8E5-4AF8-A155-77ABA06C2370" class="sect4"><span class="enumeration_section">10.9.2声明</span></h4>
                  <div>
                     <div class="section">
                        <p><code class="codeph">DECLARE</code>通过为游标指定名称并将其与特定查询相关联来定义游标。游标声明是其预编译单元的本地。继续我们的示例， <code class="codeph">DECLARE</code>定义了一个名为<span class="italic">emp_cursor</span>的游标并将其与<span class="italic">sql_stmt</span>相关联，如下所示：</p><pre class="oac_no_warn" dir="ltr"><a id="d71876e1230" class="indexterm-anchor"></a>执行SQL DECLARE emp_cursor CURSOR FOR sql_stmt;</pre><p>标识符<span class="italic">sql_stmt</span>和<span class="italic">emp_cursor</span> <span class="italic">不是</span>主机或程序变量，但必须是唯一的。如果使用相同的语句名称声明两个游标，则预编译器会将两个游标名称视为同义。例如，如果执行语句</p><pre class="oac_no_warn" dir="ltr">EXEC SQL PREPARE sql_stmt FROM：select_stmt; EXEC SQL DECLARE emp_cursor FOR sql_stmt; EXEC SQL PREPARE sql_stmt FROM：delete_stmt; EXEC SQL DECLARE dept_cursor FOR sql_stmt;</pre><p>当您打开<span class="italic">emp_cursor时</span> ，您将处理存储在<span class="italic">delete_stmt</span>中的动态SQL语句，而不是存储在<span class="italic">select_stmt</span>中的动态SQL语句<span class="italic">。</span></p>
                     </div>
                     <!-- class="section" -->
                  </div>
               </div><a id="ZZPRE893"></a><div class="props_rev_3"><a id="GUID-D6313AED-13FD-42B7-B229-5694EE080400" name="GUID-D6313AED-13FD-42B7-B229-5694EE080400"></a><h4 id="ZZPRE-GUID-D6313AED-13FD-42B7-B229-5694EE080400" class="sect4"><span class="enumeration_section">10.9.3</span>开放</h4>
                  <div>
                     <div class="section">
                        <p><a id="d71876e1287" class="indexterm-anchor"></a> <code class="codeph">OPEN</code>分配Oracle游标，绑定输入主机变量，并执行查询，识别其活动集。OPEN还将光标定位在活动集中的第一行，并将SQLCA中SQLERRD的第三个元素保留的行处理计数归零。 USING子句中的输入主机变量替换<code class="codeph">PREPAREd</code>动态SQL语句中的相应占位符。
                        </p>
                        <p>在我们的示例中， <code class="codeph">OPEN</code>分配<span class="italic">emp_cursor</span>并将主机变量<span class="italic">salary</span>分配给<code class="codeph">WHERE</code>子句，如下所示：</p><pre class="oac_no_warn" dir="ltr">EXEC SQL OPEN emp_cursor使用：salary;</pre></div>
                     <!-- class="section" -->
                  </div>
               </div><a id="ZZPRE894"></a><div class="props_rev_3"><a id="GUID-A2105218-5AF9-481E-B7D9-8607062E76B7" name="GUID-A2105218-5AF9-481E-B7D9-8607062E76B7"></a><h4 id="ZZPRE-GUID-A2105218-5AF9-481E-B7D9-8607062E76B7" class="sect4"><span class="enumeration_section">10.9.4</span> FETCH</h4>
                  <div>
                     <div class="section">
                        <p><code class="codeph">FETCH</code>从活动集返回一行，将选择列表中的列值分配给<code class="codeph">INTO</code>子句中的相应主机变量，并将光标前进到下一行。当找不到更多行时， <code class="codeph">FETCH</code>将“无数据找到”Oracle错误代码返回到SQLCA中的SQLCODE。</p>
                        <p><a id="d71876e1345" class="indexterm-anchor"></a>在我们的示例中，FETCH从活动集返回一行，并将列MGR和JOB的值分配给主变量<span class="italic">mgr_number</span>和<span class="italic">job_title</span> ，如下所示：</p><pre class="oac_no_warn" dir="ltr">EXEC SQL FETCH emp_cursor INTO：mgr_number，：job_title;</pre></div>
                     <!-- class="section" -->
                  </div>
               </div><a id="ZZPRE895"></a><div class="props_rev_3"><a id="GUID-1D1151ED-608B-4B8C-AA38-6B6449340665" name="GUID-1D1151ED-608B-4B8C-AA38-6B6449340665"></a><h4 id="ZZPRE-GUID-1D1151ED-608B-4B8C-AA38-6B6449340665" class="sect4"><span class="enumeration_section">10.9.5</span>关闭</h4>
                  <div>
                     <div class="section">
                        <p><code class="codeph">CLOSE</code>禁用光标。<code class="codeph">CLOSE</code>游标后，您无法再从中进行<code class="codeph">FETCH</code> 。在我们的示例中， <code class="codeph">CLOSE</code>语句禁用<span class="italic">emp_cursor</span> ，如下所示：</p><pre class="oac_no_warn" dir="ltr">EXEC SQL CLOSE emp_cursor;</pre></div>
                     <!-- class="section" -->
                  </div>
               </div><a id="ZZPRE896"></a><div class="props_rev_3"><a id="GUID-2F2CF0C2-9066-462C-AD85-D377DB2B7766" name="GUID-2F2CF0C2-9066-462C-AD85-D377DB2B7766"></a><h4 id="ZZPRE-GUID-2F2CF0C2-9066-462C-AD85-D377DB2B7766" class="sect4"><span class="enumeration_section">10.9.6</span>一个例子</h4>
                  <div>
                     <p> <a id="d71876e1420" class="indexterm-anchor"></a>以下程序提示用户在查询的<code class="codeph">WHERE</code>子句中使用搜索条件，然后使用方法3准备并执行查询。
                     </p><pre class="oac_no_warn" dir="ltr">EXEC SQL BEGIN DECLARE SECTION;用户名CHARACTER（20）;密码CHARACTER（20）; dept_number INTEGER; emp_name CHARACTER（10）;工资真实; select_stmt CHARACTER（120）; EXEC SQL END DECLARE SECTION; search_cond CHARACTER（40）; EXEC SQL包含SQLCA;显示'用户名？“;读取用户名;显示'密码？“;读密码;执行SQL WHENEVER SQLERROR GOTO sql_error; EXEC SQL CONNECT：用户名IDENTIFIED BY：密码;显示'连接到Oracle'; set select_stmt ='SELECT ENAME，SAL FROM EMP WHERE';显示'输入以下语句的搜索条件：'; display select_stmt;读search_cond; concatenate select_stmt，search_cond; EXEC SQL PREPARE sql_stmt FROM：select_stmt;执行SQL DECLARE emp_cursor CURSOR FOR sql_stmt; EXEC SQL OPEN emp_cursor; EXEC SQL WHENEVER NOT FOUND GOTO no_more;显示'员工薪水';显示'-------- ------'; LOOP EXEC SQL FETCH emp_cursor INTO：emp_name，：salary;显示emp_name，工资; ENDLOOP; no_more：EXEC SQL CLOSE emp_cursor; EXEC SQL COMMIT WORK RELEASE;退出计划; sql_error：EXEC SQL WHENEVER SQLERROR CONTINUE; EXEC SQL ROLLBACK工作版;退出程序有错误;</pre></div>
               </div>
            </div><a id="ZZPRE897"></a><div class="props_rev_3"><a id="GUID-C4762850-789A-463B-B573-7A7630EC1931" name="GUID-C4762850-789A-463B-B573-7A7630EC1931"></a><h3 id="ZZPRE-GUID-C4762850-789A-463B-B573-7A7630EC1931" class="sect3"><span class="enumeration_section">10.10</span>使用方法4</h3>
               <div>
                  <p><a id="d71876e1455" class="indexterm-anchor"></a>方法4的实现非常依赖于语言。因此，本节仅概述。有关详细信息，请参阅主机语言补充。
                  </p>
                  <p>您的程序无法使用方法3处理某种动态SQL语句。如果输入主机变量的选择列表项或占位符的数量在运行时之前是未知的，则程序必须使用描述符。一个<a id="d71876e1462" class="indexterm-anchor"></a> <span class="italic">descriptor</span>是程序和Oracle用于在动态SQL语句中保存变量的完整描述的内存区域。
                  </p>
                  <p><a id="d71876e1470" class="indexterm-anchor"></a>回想一下，对于多行查询，您将<code class="codeph">FETCH</code>选定的列值<code class="codeph">INTO</code>到已声明的输出主机变量列表中。如果选择列表未知，则<code class="codeph">INTO</code>子句无法在预编译时建立主机变量列表。例如，您知道以下查询返回两个列值：</p><pre class="oac_no_warn" dir="ltr">SELECT ENAME，EMPNO from EMP WHERE DEPTNO =：dept_number;</pre><p>但是，如果您让用户定义选择列表，您可能不知道查询将返回多少列值。</p>
               </div><a id="ZZPRE898"></a><div class="props_rev_3"><a id="GUID-EE32B8F6-EC76-4413-8654-553D0D04B0B7" name="GUID-EE32B8F6-EC76-4413-8654-553D0D04B0B7"></a><h4 id="ZZPRE-GUID-EE32B8F6-EC76-4413-8654-553D0D04B0B7" class="sect4"><span class="enumeration_section">10.10.1</span>需要SQLDA</h4>
                  <div>
                     <p><a id="d71876e1513" class="indexterm-anchor"></a>要处理这种动态查询，您的程序必须发出<code class="codeph">DESCRIBE</code> <code class="codeph">SELECT</code> <code class="codeph">LIST</code>命令并声明一个名为SQL Descriptor Area的数据结构<a id="d71876e1525" class="indexterm-anchor"></a> （SQLDA）。因为它包含查询选择列表中列的描述，所以此结构也称为<span class="italic">选择描述符</span> 。
                     </p>
                     <p>同样，如果动态SQL语句包含输入主机变量的未知数量的占位符，则<code class="codeph">USING</code>子句无法在预编译时建立主机变量列表。
                     </p>
                     <p><a id="d71876e1539" class="indexterm-anchor"></a>要处理动态SQL语句，程序必须发出<code class="codeph">DESCRIBE</code> <code class="codeph">BIND</code> <code class="codeph">VARIABLES</code>命令并声明另一种称为<span class="italic">绑定描述符</span>的SQLDA，以保存输入主机变量占位符的描述。（输入主变量也称为<span class="italic">绑定变量</span> 。）
                     </p>
                     <p>如果您的程序有多个活动的SQL语句（例如，它可能打开了两个或更多个游标），则每个语句都必须有自己的SQLDA。但是，非并发游标可以重用SQLDA。程序中的SQLDA数量没有设置限制。</p>
                  </div>
               </div><a id="ZZPRE899"></a><div class="props_rev_3"><a id="GUID-FD8C392F-A0A6-41C7-BCC5-4EBB51D35630" name="GUID-FD8C392F-A0A6-41C7-BCC5-4EBB51D35630"></a><h4 id="ZZPRE-GUID-FD8C392F-A0A6-41C7-BCC5-4EBB51D35630" class="sect4"><span class="enumeration_section">10.10.2</span> DESCRIBE声明</h4>
                  <div>
                     <div class="section">
                        <p><a id="d71876e1581" class="indexterm-anchor"></a> DESCRIBE初始化描述符以保存选择列表项或输入主变量的描述。<a id="d71876e1584" class="indexterm-anchor"></a></p>
                        <p>如果提供选择描述符，则<code class="codeph">DESCRIBE</code> <code class="codeph">SELECT</code> <code class="codeph">LIST</code>语句将检查<code class="codeph">PREPAREd</code>动态查询中的每个选择列表项，以确定其名称，数据类型，约束，长度，比例和精度。然后它将此信息存储在选择描述符中。
                        </p>
                        <p>如果提供绑定描述符，则<code class="codeph">DESCRIBE</code> <code class="codeph">BIND</code> <code class="codeph">VARIABLES</code>语句将检查<code class="codeph">PREPAREd</code>动态SQL语句中的每个占位符，以确定其名称，长度以及其关联的输入主机变量的数据类型。然后，它将此信息存储在绑定描述符中供您使用。例如，您可以使用占位符名称来提示用户输入主机变量的值。
                        </p>
                     </div>
                     <!-- class="section" -->
                  </div>
               </div><a id="ZZPRE900"></a><div class="props_rev_3"><a id="GUID-094EB69B-E8A7-4ACA-BB74-BDEDA29C02D0" name="GUID-094EB69B-E8A7-4ACA-BB74-BDEDA29C02D0"></a><h4 id="ZZPRE-GUID-094EB69B-E8A7-4ACA-BB74-BDEDA29C02D0" class="sect4"><span class="enumeration_section">10.10.3</span>什么是SQLDA？
                  </h4>
                  <div>
                     <p>SQLDA是一种主机程序数据结构，它包含选择列表项或输入主机变量的描述。</p>
                     <p>SQLDA变量<span class="italic">未</span>在Declare部分中定义。
                     </p>
                     <p>虽然SQLDAs在主机语言中有所不同，但通用选择SQLDA包含有关查询选择列表的以下信息：</p>
                     <ul style="list-style-type:disc">
                        <li>
                           <p>可以描述的最大列数</p>
                        </li>
                        <li>
                           <p>由describe找到的实际列数</p>
                        </li>
                        <li>
                           <p>用于存储列值的缓冲区地址</p>
                        </li>
                        <li>
                           <p>列值的长度</p>
                        </li>
                        <li>
                           <p>列值的数据类型</p>
                        </li>
                        <li>
                           <p>指标变量值的地址</p>
                        </li>
                        <li>
                           <p>用于存储列名称的缓冲区地址</p>
                        </li>
                        <li>
                           <p>用于存储列名称的缓冲区大小</p>
                        </li>
                        <li>
                           <p>列名的当前长度</p>
                        </li>
                     </ul>
                     <p>通用绑定SQLDA包含有关SQL语句中输入主机变量的以下信息：</p>
                     <ul style="list-style-type:disc">
                        <li>
                           <p>可以描述的最大占位符数</p>
                        </li>
                        <li>
                           <p>通过describe找到的实际占位符数</p>
                        </li>
                        <li>
                           <p>输入主变量的地址</p>
                        </li>
                        <li>
                           <p>输入主机变量的长度</p>
                        </li>
                        <li>
                           <p>输入主机变量的数据类型</p>
                        </li>
                        <li>
                           <p>指标变量的地址</p>
                        </li>
                        <li>
                           <p>用于存储占位符名称的缓冲区地址</p>
                        </li>
                        <li>
                           <p>用于存储占位符名称的缓冲区大小</p>
                        </li>
                        <li>
                           <p>占位符名称的当前长度</p>
                        </li>
                        <li>
                           <p>用于存储指示符变量名称的缓冲区地址</p>
                        </li>
                        <li>
                           <p>用于存储指示符变量名称的缓冲区大小</p>
                        </li>
                        <li>
                           <p>指标变量名称的当前长度</p>
                        </li>
                     </ul>
                     <p>要查看特定主机语言的SQLDA结构和变量名称，请参阅主机语言补充。</p>
                  </div>
               </div><a id="ZZPRE901"></a><div class="props_rev_3"><a id="GUID-62C89F8E-21BB-43A3-A3BE-D21A95DCF1D3" name="GUID-62C89F8E-21BB-43A3-A3BE-D21A95DCF1D3"></a><h4 id="ZZPRE-GUID-62C89F8E-21BB-43A3-A3BE-D21A95DCF1D3" class="sect4"><span class="enumeration_section">10.10.4</span>实施方法4</h4>
                  <div>
                     <p>使用方法4，通常使用以下嵌入式SQL语句序列：</p><pre class="oac_no_warn" dir="ltr">EXEC SQL PREPARE statement_name FROM {：host_string |字符串字面量 }; EXEC SQL DECLARE cursor_name CURSOR FOR statement_name;对于statement_name INTO bind_descriptor_name，EXEC SQL DESCRIBE BIND VARIABLES; EXEC SQL OPEN cursor_name [USING DESCRIPTOR bind_descriptor_name]; EXEC SQL DESCRIBE [SELECT LIST FOR] statement_name INTO select_descriptor_name; EXEC SQL FETCH cursor_name使用DESCRIPTOR select_descriptor_name; EXEC SQL CLOSE cursor_name;</pre><p>选择和绑定描述符不需要串联工作。如果查询选择列表中的列数已知，但输入主机变量的占位符数未知，则可以使用方法4 <code class="codeph">OPEN</code>语句和以下方法3 <code class="codeph">FETCH</code>语句：</p><pre class="oac_no_warn" dir="ltr">EXEC SQL FETCH emp_cursor INTO host_variable_list;</pre><p>相反，如果已知输入主变量的占位符数，但选择列表中的列数未知，则可以将以下方法3 <code class="codeph">OPEN</code>语句与方法4 <code class="codeph">FETCH</code>语句一起使用：</p><pre class="oac_no_warn" dir="ltr">EXEC SQL OPEN cursor_name [USING host_variable_list];</pre><p>请注意， <code class="codeph">EXECUTE</code>可用于方法4的非查询。
                     </p>
                     <p>要了解这些语句如何允许程序使用描述符处理动态SQL语句，请参阅主机语言补充。</p>
                  </div>
               </div>
            </div><a id="ZZPRE902"></a><div class="props_rev_3"><a id="GUID-364E812E-312C-42BE-B0DA-7AC132EF46B8" name="GUID-364E812E-312C-42BE-B0DA-7AC132EF46B8"></a><h3 id="ZZPRE-GUID-364E812E-312C-42BE-B0DA-7AC132EF46B8" class="sect3"><span class="enumeration_section">10.11</span>关于使用DECLARE STATEMENT语句</h3>
               <div>
                  <p><a id="d71876e1788" class="indexterm-anchor"></a>使用方法2,3和4，您可能需要使用该语句</p><pre class="oac_no_warn" dir="ltr">EXEC SQL [AT db_name] DECLARE statement_name STATEMENT;</pre><p>其中<span class="italic">db_name</span>和<span class="italic">statement_name</span>是预编译器使用的标识符， <span class="italic">而不是</span>主机或程序变量。
                  </p>
                  <p><code class="codeph">DECLARE</code> <code class="codeph">STATEMENT</code>声明动态SQL语句的名称，以便<code class="codeph">PREPARE</code> ， <code class="codeph">EXECUTE</code> ， <code class="codeph">DECLARE</code> <code class="codeph">CURSOR</code>和<code class="codeph">DESCRIBE</code>可以引用该语句。它是<a id="d71876e1829" class="indexterm-anchor"></a>如果要在非默认数据库中执行动态SQL语句，则需要。使用方法2的示例如下：</p><pre class="oac_no_warn" dir="ltr">EXEC SQL AT remote_db DECLARE sql_stmt STATEMENT; EXEC SQL PREPARE sql_stmt FROM：sql_string; EXEC SQL EXECUTE sql_stmt;</pre><p>在该示例中， <span class="italic">remote_db</span>告诉Oracle在哪里<code class="codeph">EXECUTE</code> SQL语句。
                  </p>
                  <p><a id="d71876e1845" class="indexterm-anchor"></a>用方法<a id="d71876e1850" class="indexterm-anchor"></a> 3和<a id="d71876e1855" class="indexterm-anchor"></a> 4，如果DECLARE <code class="codeph">CURSOR</code>语句在PREPARE语句之前，则还需要<code class="codeph">DECLARE</code> <code class="codeph">STATEMENT</code> ，如以下示例所示：</p><pre class="oac_no_warn" dir="ltr">EXEC SQL DECLARE sql_stmt STATEMENT;执行SQL DECLARE emp_cursor CURSOR FOR sql_stmt; EXEC SQL PREPARE sql_stmt FROM：sql_string;</pre><p>通常的陈述顺序是</p><pre class="oac_no_warn" dir="ltr">EXEC SQL PREPARE sql_stmt FROM：sql_string;执行SQL DECLARE emp_cursor CURSOR FOR sql_stmt;</pre></div><a id="ZZPRE903"></a><div class="props_rev_3"><a id="GUID-406CB08D-F866-43B6-9420-27AF3EFA288E" name="GUID-406CB08D-F866-43B6-9420-27AF3EFA288E"></a><h4 id="ZZPRE-GUID-406CB08D-F866-43B6-9420-27AF3EFA288E" class="sect4"><span class="enumeration_section">10.11.1</span>主机阵列的使用</h4>
                  <div>
                     <p><a id="d71876e1896" class="indexterm-anchor"></a><a id="d71876e1900" class="indexterm-anchor"></a>在静态和动态SQL中使用主机数组是类似的。例如，要将输入主机数组与动态SQL方法2一起使用，请使用语法</p><pre class="oac_no_warn" dir="ltr">EXEC SQL EXECUTE statement_name USING host_array_list;</pre><p>其中<span class="italic">host_array_list</span>包含一个或多个主机阵列。使用方法3，使用以下语法：</p><pre class="oac_no_warn" dir="ltr">OPEN cursor_name使用host_array_list;</pre><p>要使用方法3使用输出主机数组，请使用以下语法：</p><pre class="oac_no_warn" dir="ltr">FETCH cursor_name INTO host_array_list;</pre><p>使用方法4，必须使用可选的FOR子句告诉Oracle输入或输出主机阵列的大小。要了解如何完成此操作，请参阅主机语言补充。</p>
                     <p></p>
                  </div>
               </div>
            </div><a id="ZZPRE904"></a><div class="props_rev_3"><a id="GUID-25F8ABB7-6A51-4C3A-9DE7-DF86E3E3AA6B" name="GUID-25F8ABB7-6A51-4C3A-9DE7-DF86E3E3AA6B"></a><h3 id="ZZPRE-GUID-25F8ABB7-6A51-4C3A-9DE7-DF86E3E3AA6B" class="sect3"><span class="enumeration_section">10.12</span>关于使用PL / SQL</h3>
               <div>
                  <p><a id="d71876e1943" class="indexterm-anchor"></a> Oracle预编译器将PL / SQL块视为单个SQL语句。所以，就像一个<a id="d71876e1946" class="indexterm-anchor"></a> SQL语句，PL / SQL块可以存储在字符串主变量或文字中。将PL / SQL块存储在字符串中时，省略关键字EXEC SQL <code class="codeph">EXECUTE</code> ，关键字END-EXEC和语句终止符。
                  </p>
                  <p>但是，预编译器处理SQL和PL / SQL的方式有两点不同：</p>
                  <ul style="list-style-type:disc">
                     <li>
                        <p>预编译器将所有PL / SQL主变量视为<span class="italic">输入</span>主变量，无论它们是PL / SQL块内的输入还是输出主变量（或两者）。
                        </p>
                     </li>
                     <li>
                        <p>您无法从PL / SQL块进行FETCH，因为它可能包含任意数量的SQL语句。</p>
                     </li>
                  </ul>
               </div><a id="ZZPRE905"></a><div class="props_rev_3"><a id="GUID-208024EB-90D7-4CAA-95BA-342240FBF1C7" name="GUID-208024EB-90D7-4CAA-95BA-342240FBF1C7"></a><h4 id="ZZPRE-GUID-208024EB-90D7-4CAA-95BA-342240FBF1C7" class="sect4"><span class="enumeration_section">10.12.1</span>使用方法1</h4>
                  <div>
                     <p><a id="d71876e1987" class="indexterm-anchor"></a>如果PL / SQL块不包含主机变量，则可以使用方法1以常规方式<code class="codeph">EXECUTE</code> PL / SQL字符串。
                     </p>
                  </div>
               </div><a id="ZZPRE906"></a><div class="props_rev_3"><a id="GUID-3D0AF9F7-3851-469E-8F84-F1D07345F2D9" name="GUID-3D0AF9F7-3851-469E-8F84-F1D07345F2D9"></a><h4 id="ZZPRE-GUID-3D0AF9F7-3851-469E-8F84-F1D07345F2D9" class="sect4"><span class="enumeration_section">10.12.2</span>使用方法2</h4>
                  <div>
                     <p><a id="d71876e2016" class="indexterm-anchor"></a>如果PL / SQL块包含已知数量的输入和输出主机变量，则可以使用方法2以常规方式<code class="codeph">PREPARE</code>和<code class="codeph">EXECUTE</code> PL / SQL字符串。
                     </p>
                     <p>您必须将<span class="italic">所有</span>主变量放在USING子句中。当PL / SQL字符串为<code class="codeph">EXECUTEd</code> ，USING子句中的主变量将替换<code class="codeph">PREPAREd</code>字符串中的相应占位符。虽然预编译器将所有PL / SQL主机变量视为输入主机变量，但是值是正确分配的。输入（程序）值分配给输入主变量，输出（列）值分配给输出主变量。
                     </p>
                     <p><code class="codeph">PREPAREd</code> PL / SQL字符串中的每个占位符都必须与<code class="codeph">USING</code>子句中的主机变量相对应。因此，如果相同的占位符在<code class="codeph">PREPAREd</code>字符串中出现两次或多次，则每个外观必须对应于USING子句中的主机变量。
                     </p>
                  </div>
               </div><a id="ZZPRE907"></a><div class="props_rev_3"><a id="GUID-60E80DC6-F288-4123-8DC6-DC363E25DA04" name="GUID-60E80DC6-F288-4123-8DC6-DC363E25DA04"></a><h4 id="ZZPRE-GUID-60E80DC6-F288-4123-8DC6-DC363E25DA04" class="sect4"><span class="enumeration_section">10.12.3</span>方法3</h4>
                  <div>
                     <p><a id="d71876e2071" class="indexterm-anchor"></a>除了方法3允许<code class="codeph">FETCHing</code>之外，方法2和3是相同的。由于您无法从PL / SQL块进行<code class="codeph">FETCH</code> ，因此请改用方法2。
                     </p>
                  </div>
               </div><a id="ZZPRE908"></a><div class="props_rev_3"><a id="GUID-8A644727-9074-424E-AF79-AA6603091DA3" name="GUID-8A644727-9074-424E-AF79-AA6603091DA3"></a><h4 id="ZZPRE-GUID-8A644727-9074-424E-AF79-AA6603091DA3" class="sect4"><span class="enumeration_section">10.12.4</span>使用方法4</h4>
                  <div>
                     <p><a id="d71876e2103" class="indexterm-anchor"></a>如果PL / SQL块包含未知数量的输入或输出主机变量，则必须使用方法4。
                     </p>
                     <p>要使用方法4，请为所有输入和输出主机变量设置一个绑定描述符。执行<code class="codeph">DESCRIBE</code> <code class="codeph">BIND</code> <code class="codeph">VARIABLES</code>将有关输入<span class="italic">和</span>输出主机变量的信息存储在绑定描述符中。由于预编译器将所有PL / SQL主机变量视为输入主机变量，因此执行<code class="codeph">DESCRIBE</code> <code class="codeph">SELECT</code> <code class="codeph">LIST</code>无效。
                     </p>
                     <p>在主机语言补充中详细介绍了使用方法4绑定描述符。</p>
                     <div class="infoboxnote" id="GUID-8A644727-9074-424E-AF79-AA6603091DA3__GUID-7EAD97A0-939E-447A-B096-27A0121065AB">
                        <p class="notep1">注意：</p>
                        <p>在动态SQL方法4中，主机数组不能绑定到带有“table”类型参数的PL / SQL过程。</p>
                     </div>
                  </div>
               </div><a id="ZZPRE909"></a><div class="props_rev_3"><a id="GUID-F12F7699-0216-407A-8DED-A3F068C839A6" name="GUID-F12F7699-0216-407A-8DED-A3F068C839A6"></a><h4 id="ZZPRE-GUID-F12F7699-0216-407A-8DED-A3F068C839A6" class="sect4"><span class="enumeration_section">10.12.5</span>注意</h4>
                  <div>
                     <p><a id="d71876e2158" class="indexterm-anchor"></a>不要在将动态处理的PL / SQL块中使用ANSI样式的注释（ -   -  ...），因为忽略了行尾字符。因此，ANSI样式的注释扩展到块的末尾，而不仅仅是行的末尾。相反，使用C风格的评论（/ * ...* /）。
                     </p>
                  </div>
               </div>
            </div>
         </div>
      </article>
   </body>
</html>