<html lang="en-us" dir="ltr" xml:lang="en-us">
   <head>
      <meta http-equiv="Content-Type" content="text/html; charset=utf-8"></meta>
      <meta name="viewport" content="width=device-width, initial-scale=1"></meta>
      <meta http-equiv="X-UA-Compatible" content="IE=edge"></meta>
      <title>语句和结果集缓存</title>
      <meta property="og:site_name" content="Oracle Help Center"></meta>
      <meta property="og:title" content="JDBC Developer&#39;s Guide"></meta>
      <meta property="og:description" content=""></meta>
      <link rel="stylesheet" href="/sp_common/book-template/ohc-book-template/css/book.css"></link>
      <link rel="shortcut icon" href="/sp_common/book-template/ohc-common/img/favicon.ico"></link>
      <meta name="application-name" content="JDBC Developer&#39;s Guide"></meta>
      <meta name="generator" content="DITA Open Toolkit version 1.8.5 (Mode = doc)"></meta>
      <meta name="plugin" content="SP_docbuilder HTML plugin release 18.2.2"></meta>
      <link rel="alternate" href="jdbc-developers-guide.pdf" title="PDF File" type="application/pdf"></link>
      <meta name="robots" content="all"></meta>
      <link rel="schema.dcterms" href="http://purl.org/dc/terms/"></link>
      <meta name="dcterms.created" content="2019-02-13T13:20:37-08:00"></meta>
      <meta name="dcterms.title" content="JDBC Developer&#39;s Guide"></meta>
      <meta name="dcterms.dateCopyrighted" content="1999, 2019"></meta>
      <meta name="dcterms.category" content="database"></meta>
      <meta name="dcterms.identifier" content="E96471-02"></meta>
      
      <meta name="dcterms.product" content="en/database/oracle/oracle-database/19"></meta>
      
      <link rel="prev" href="performance-and-scalability.html" title="Previous" type="text/html"></link>
      <link rel="next" href="performance-extensions.html" title="Next" type="text/html"></link>
      <script>
        document.write('<style type="text/css">');
        document.write('body > .noscript, body > .noscript ~ * { visibility: hidden; }');
        document.write('</style>');
     </script>
      <script src="/sp_common/book-template/requirejs/require.js" data-main="/sp_common/book-template/ohc-book-template/js/book-config"></script>
      <script>
            if (window.require === undefined) {
                document.write('<script data-main="sp_common/book-template/ohc-book-template/js/book-config" src="sp_common/book-template/requirejs/require.js"><\/script>');
                document.write('<link href="sp_common/book-template/ohc-book-template/css/book.css" rel="stylesheet"/>');
            }
        </script>
      <script type="application/json" id="ssot-metadata">{"primary":{"category":{"short_name":"database","element_name":"Database","display_in_url":true},"suite":{"short_name":"oracle","element_name":"Oracle","display_in_url":true},"product_group":{"short_name":"not-applicable","element_name":"Not applicable","display_in_url":false},"product":{"short_name":"oracle-database","element_name":"Oracle Database","display_in_url":true},"release":{"short_name":"19","element_name":"Release 19","display_in_url":true}}}</script>
      
    <meta name="dcterms.isVersionOf" content="JJDBC"></meta>
    <meta name="dcterms.release" content="Release 19"></meta>
  </head>
   <body dir="ltr">
      <div class="noscript alert alert-danger text-center" role="alert">
         <a href="performance-and-scalability.html" class="pull-left"><span class="glyphicon glyphicon-chevron-left" aria-hidden="true"></span>上一页</a> <a href="performance-extensions.html" class="pull-right">下一页<span class="glyphicon glyphicon-chevron-right" aria-hidden="true"></span></a> <span class="fa fa-exclamation-triangle" aria-hidden="true"></span>必须启用JavaScript才能正确显示此内容</div>
      <article>
         <header>
            <ol class="breadcrumb" vocab="http://schema.org/" typeof="BreadcrumbList">
               <li property="itemListElement" typeof="ListItem"><a href="index.html" property="item" typeof="WebPage"><span property="name">JDBC开发人员指南</span></a></li>
               <li property="itemListElement" typeof="ListItem"><a href="performance-and-scalability.html" property="item" typeof="WebPage"><span property="name">性能和可伸缩性</span></a></li>
               <li class="active" property="itemListElement" typeof="ListItem">语句和结果集缓存</li>
            </ol>
            <a id="GUID-F3F4BB63-356A-4F65-81B1-5C84FC35A16D" name="GUID-F3F4BB63-356A-4F65-81B1-5C84FC35A16D"></a><a id="JJDBC28649"></a>
            
            <h2 id="JJDBC-GUID-F3F4BB63-356A-4F65-81B1-5C84FC35A16D" class="sect2"><span class="enumeration_chapter">20</span>语句和结果集缓存</h2>
         </header>
         <div class="ind">
            <div>
               <p>本章介绍了语句缓存（Oracle Java数据库连接（JDBC）扩展）的优点和用法。</p>
               <div class="infoboxnote" id="GUID-F3F4BB63-356A-4F65-81B1-5C84FC35A16D__GUID-FC9BD3E5-B4F2-4865-8DA0-984A5D5F6EE0">
                  <p class="notep1">注意：</p>
                  <p>仅当您确定表结构在数据库中保持不变时才使用语句缓存。如果更改表结构，然后重用在更改表结构之前创建并执行的语句，则可能会出错。</p>
               </div>
               <p>本章包含以下部分：</p>
               <ul style="list-style-type:disc">
                  <li>
                     <p><a href="statement-and-resultset-caching.html#GUID-DE966F8D-3D12-4697-A7A4-A09E0DF58CA1">关于语句缓存</a></p>
                  </li>
                  <li>
                     <p><a href="statement-and-resultset-caching.html#GUID-6BD392DE-C6CE-4743-8176-D011A597AE0D">关于使用语句缓存</a></p>
                  </li>
                  <li>
                     <p><a href="statement-and-resultset-caching.html#GUID-60A76058-8FD3-4A0E-B6DB-B60DC76C6E59">关于重用语句对象</a></p>
                  </li>
                  <li>
                     <p><a href="statement-and-resultset-caching.html#GUID-5D1A9E2F-F191-4FCF-994C-C1D5B143FC4F">关于结果集缓存</a></p>
                  </li>
               </ul>
            </div><a id="JJDBC28650"></a><div class="props_rev_3"><a id="GUID-DE966F8D-3D12-4697-A7A4-A09E0DF58CA1" name="GUID-DE966F8D-3D12-4697-A7A4-A09E0DF58CA1"></a><h3 id="JJDBC-GUID-DE966F8D-3D12-4697-A7A4-A09E0DF58CA1" class="sect3"><span class="enumeration_section">20.1</span>关于语句缓存</h3>
               <div>
                  <p>语句缓存通过缓存重复使用的可执行语句（例如循环或重复调用的方法）来提高性能。从JDBC 3.0开始，JDBC标准定义了语句缓存接口。</p>
                  <p>语句缓存可以执行以下操作：</p>
                  <ul style="list-style-type:disc">
                     <li>
                        <p>防止重复创建游标的开销</p>
                     </li>
                     <li>
                        <p>防止重复的语句解析和创建</p>
                     </li>
                     <li>
                        <p>在客户端重用数据结构</p>
                     </li>
                  </ul>
                  <p>本节包括以下主题：</p>
                  <ul style="list-style-type:disc">
                     <li>
                        <p><a href="statement-and-resultset-caching.html#GUID-50791E8A-769F-4261-A5F6-057EB8B7A054">语句缓存的基础知识</a></p>
                     </li>
                     <li>
                        <p><a href="statement-and-resultset-caching.html#GUID-CF36BCE2-4B24-4975-8673-F90E5A9BEF5A">隐式语句缓存</a></p>
                     </li>
                     <li>
                        <p><a href="statement-and-resultset-caching.html#GUID-DFBC7F09-5F27-42E1-8044-24733A6AE5F8">显式语句缓存</a></p>
                     </li>
                  </ul>
                  <div class="infoboxnote" id="GUID-DE966F8D-3D12-4697-A7A4-A09E0DF58CA1__GUID-B497605E-BF7B-489E-B34C-4B824B9A3525">
                     <p class="notep1">注意：</p>
                     <p>Oracle强烈建议您使用隐式语句缓存。Oracle JDBC驱动程序的设计假设启用了隐式语句高速缓存。因此，不使用Statement缓存会对性能产生负面影响。</p>
                  </div>
               </div><a id="JJDBC28651"></a><div class="props_rev_3"><a id="GUID-50791E8A-769F-4261-A5F6-057EB8B7A054" name="GUID-50791E8A-769F-4261-A5F6-057EB8B7A054"></a><h4 id="JJDBC-GUID-50791E8A-769F-4261-A5F6-057EB8B7A054" class="sect4"><span class="enumeration_section">20.1.1</span>语句缓存的基础知识</h4>
                  <div>
                     <p>应用程序使用Statement缓存来缓存与特定物理连接关联的语句。缓存与<code class="codeph">OracleConnection</code>对象关联。<code class="codeph">OracleConnection</code>包括启用Statement缓存的方法。启用语句缓存时，在调用<code class="codeph">close</code>方法时会缓存语句对象。
                     </p>
                     <p>由于每个物理连接都有自己的缓存，因此如果为多个物理连接启用Statement缓存，则可以存在多个缓存。在连接高速缓存上启用语句高速缓存时，逻辑连接将受益于在基础物理连接上启用的语句高速缓存。如果您尝试在连接缓存所持有的逻辑连接上启用语句缓存，则会引发异常。</p>
                     <p>Statement缓存有两种类型：隐式和显式。可以独立于另一个启用或禁用每种类型的Statement缓存。您既可以使用，也可以同时使用，或者两者都有效。两种类型的Statement缓存都为每个连接共享一个缓存。</p>
                  </div>
               </div><a id="JJDBC28652"></a><div class="props_rev_3"><a id="GUID-CF36BCE2-4B24-4975-8673-F90E5A9BEF5A" name="GUID-CF36BCE2-4B24-4975-8673-F90E5A9BEF5A"></a><h4 id="JJDBC-GUID-CF36BCE2-4B24-4975-8673-F90E5A9BEF5A" class="sect4"><span class="enumeration_section">20.1.2</span>隐式语句缓存</h4>
                  <div>
                     <p>启用隐式语句缓存时<a id="d64860e168" class="indexterm-anchor"></a><a id="d64860e174" class="indexterm-anchor"></a> ，当您调用此语句对象的<code class="codeph">close</code>方法时，JDBC会自动缓存准备或可调用的语句。使用标准连接对象和语句对象方法缓存和检索准备好的和可调用的语句。
                     </p>
                     <p>简单语句不是隐式缓存的，因为隐式语句缓存使用SQL字符串作为键，而普通语句在没有SQL字符串的情况下创建。因此，隐式语句缓存仅适用于<a id="d64860e184" class="indexterm-anchor"></a> <code class="codeph">OraclePreparedStatement</code>和<code class="codeph">OracleCallableStatement</code> <a id="d64860e191" class="indexterm-anchor"></a>使用SQL字符串创建的对象。您<span class="italic">不能</span>对<code class="codeph">OracleStatement</code>使用隐式语句缓存。当您创建一个<code class="codeph">OraclePreparedStatement</code>或<code class="codeph">OracleCallableStatement</code> ，JDBC驱动程序会自动搜索匹配的语句缓存。匹配标准如下：</p>
                     <ul style="list-style-type:disc">
                        <li>
                           <p>语句中的SQL字符串必须与缓存中的SQL字符串相同。</p>
                        </li>
                        <li>
                           <p>语句类型必须相同，即准备或可调用。</p>
                        </li>
                        <li>
                           <p>语句生成的可滚动类型的结果集必须相同，即仅向前或可滚动。</p>
                        </li>
                     </ul>
                     <p>如果在缓存搜索期间找到匹配项，则返回缓存的语句。如果未找到匹配项，则创建并返回新语句。在任何一种情况下，当您调用语句对象的<code class="codeph">close</code>方法时，都会缓存语句及其游标和状态。
                     </p>
                     <p>当一个缓存<a id="d64860e224" class="indexterm-anchor"></a> <code class="codeph">OraclePreparedStatement</code>或<code class="codeph">OracleCallableStatement</code> <a id="d64860e231" class="indexterm-anchor"></a>检索对象后，状态和数据信息将自动重新初始化并重置为默认值，同时保存元数据。使用a从缓存中删除语句以符合最大大小<a id="d64860e234" class="indexterm-anchor"></a><a id="d64860e240" class="indexterm-anchor"></a><a id="d64860e244" class="indexterm-anchor"></a><a id="d64860e246" class="indexterm-anchor"></a>最近最少使用（LRU）算法。
                     </p>
                     <div class="infoboxnote" id="GUID-CF36BCE2-4B24-4975-8673-F90E5A9BEF5A__GUID-CC0785F3-9026-474E-99CD-3964B83E56AA">
                        <p class="notep1">注意：</p>
                        <p>JDBC驱动程序不会清除元数据。但是，尽管出于性能原因保存了元数据，但它没有语义影响。来自隐式缓存的语句看起来好像是新创建的。</p>
                     </div>
                     <p>您可以阻止隐式缓存特定语句。</p>
                  </div>
                  <div>
                     <div class="relinfo">
                        <p><strong>相关话题</strong></p>
                        <ul>
                           <li><a href="statement-and-resultset-caching.html#GUID-70EF2E8D-805A-4057-995F-34B58ADC0CFD">关于使用隐式语句缓存</a></li>
                        </ul>
                     </div>
                  </div>
                  
               </div><a id="JJDBC28654"></a><a id="JJDBC28653"></a><div class="props_rev_3"><a id="GUID-DFBC7F09-5F27-42E1-8044-24733A6AE5F8" name="GUID-DFBC7F09-5F27-42E1-8044-24733A6AE5F8"></a><h4 id="JJDBC-GUID-DFBC7F09-5F27-42E1-8044-24733A6AE5F8" class="sect4"><span class="enumeration_section">20.1.3</span>显式语句缓存</h4>
                  <div>
                     <p><a id="d64860e288" class="indexterm-anchor"></a><a id="d64860e294" class="indexterm-anchor"></a>显式语句缓存使您可以缓存和检索选定的准备和可调用语句。显式语句缓存依赖于您提供的键，一个任意Java <code class="codeph">String</code> 。
                     </p>
                     <div class="infoboxnote" id="GUID-DFBC7F09-5F27-42E1-8044-24733A6AE5F8__GUID-FEE8E80F-3B04-4F04-A5EF-EA6B03AAE090">
                        <p class="notep1">注意：</p>
                        <p>无法缓存普通语句。</p>
                     </div>
                     <p>由于显式语句缓存保留语句数据和状态以及元数据，因此它具有隐式语句缓存的性能优势，而隐式语句缓存仅保留元数据。但是，在使用此类缓存时必须谨慎，因为显式语句缓存会保存所有三种类型的信息以供重用，您可能不知道从事先使用语句时保留了哪些数据和状态。</p>
                     <p>可以通过以下几点区分隐式和显式语句缓存：</p>
                     <ul style="list-style-type:disc">
                        <li>
                           <p>检索语句</p>
                           <p>在隐式语句缓存的情况下，您不需要特殊操作来从缓存中检索语句。相反，无论何时调用<code class="codeph">prepareStatement</code>或<code class="codeph">prepareCall</code> ，JDBC都会自动检查缓存中是否有匹配的语句，如果找到则返回它。但是，在显式语句缓存的情况下，您使用专门的Oracle <code class="codeph">WithKey</code>方法来缓存和检索语句对象。
                           </p>
                        </li>
                        <li>
                           <p>提供关键</p>
                           <p>隐式语句缓存使用准备或可调用语句的SQL字符串作为键，不需要您执行任何操作。相反，显式语句缓存要求您提供Java <code class="codeph">String</code> ，并将其用作键。
                           </p>
                        </li>
                        <li>
                           <p>回复陈述</p>
                           <p>在隐式语句缓存期间，如果JDBC驱动程序无法在缓存中找到语句，则它将自动创建一个语句。但是，在显式语句缓存期间，如果JDBC驱动程序无法在缓存中找到匹配的语句，则它将返回<code class="codeph">null</code>值。
                           </p>
                        </li>
                     </ul>
                     <p><a href="statement-and-resultset-caching.html#GUID-DFBC7F09-5F27-42E1-8044-24733A6AE5F8__G1076722" title="表">表20-1</a>比较了隐式和显式语句缓存中使用的不同方法。
                     </p>
                     <div class="tblformalwide" id="GUID-DFBC7F09-5F27-42E1-8044-24733A6AE5F8__G1076722">
                        <p class="titleintable">表20-1语句缓存中使用的比较方法</p>
                        <table cellpadding="4" cellspacing="0" class="FormalWide" title="比较语句缓存中使用的方法" width="100%" border="1" summary="table" frame="hsides" rules="rows">
                           <thead>
                              <tr align="left" valign="top">
                                 <th align="left" valign="bottom" width="12%" id="d64860e358">缓存类型</th>
                                 <th align="left" valign="bottom" width="29%" id="d64860e361">分配</th>
                                 <th align="left" valign="bottom" width="21%" id="d64860e364">插入缓存</th>
                                 <th align="left" valign="bottom" width="37%" id="d64860e367">从缓存中检索</th>
                              </tr>
                           </thead>
                           <tbody>
                              <tr align="left" valign="top">
                                 <td align="left" valign="top" width="12%" id="d64860e372" headers="d64860e358 ">
                                    <p>含蓄</p>
                                 </td>
                                 <td align="left" valign="top" width="29%" headers="d64860e372 d64860e361 ">
                                    <p><code class="codeph">prepareStatement prepareCall</code></p>
                                 </td>
                                 <td align="left" valign="top" width="21%" headers="d64860e372 d64860e364 ">
                                    <p><code class="codeph">关</code></p>
                                 </td>
                                 <td align="left" valign="top" width="37%" headers="d64860e372 d64860e367 ">
                                    <p><code class="codeph">prepareStatement prepareCall</code></p>
                                 </td>
                              </tr>
                              <tr align="left" valign="top">
                                 <td align="left" valign="top" width="12%" id="d64860e392" headers="d64860e358 ">
                                    <p>明确的</p>
                                 </td>
                                 <td align="left" valign="top" width="29%" headers="d64860e392 d64860e361 ">
                                    <p><code class="codeph">createStatement prepareStatement prepareCall</code></p>
                                 </td>
                                 <td align="left" valign="top" width="21%" headers="d64860e392 d64860e364 ">
                                    <p><code class="codeph">closeWithKey</code></p>
                                 </td>
                                 <td align="left" valign="top" width="37%" headers="d64860e392 d64860e367 ">
                                    <p><code class="codeph">getStatementWithKey getCallWithKey</code></p>
                                 </td>
                              </tr>
                           </tbody>
                        </table>
                     </div>
                     <!-- class="inftblhruleinformal" -->
                  </div>
               </div>
            </div><a id="JJDBC28655"></a><div class="props_rev_3"><a id="GUID-6BD392DE-C6CE-4743-8176-D011A597AE0D" name="GUID-6BD392DE-C6CE-4743-8176-D011A597AE0D"></a><h3 id="JJDBC-GUID-6BD392DE-C6CE-4743-8176-D011A597AE0D" class="sect3"><span class="enumeration_section">20.2</span>关于使用语句缓存</h3>
               <div>
                  <p>本节讨论以下主题：</p>
                  <ul style="list-style-type:disc">
                     <li>
                        <p><a href="statement-and-resultset-caching.html#GUID-3E425401-A7F0-49FA-A057-01DB6ECCFFC9">关于启用和禁用语句缓存</a></p>
                     </li>
                     <li>
                        <p><a href="statement-and-resultset-caching.html#GUID-D410355C-0318-41AC-AC93-3CDC59EFFD37">关于关闭缓存的语句</a></p>
                     </li>
                     <li>
                        <p><a href="statement-and-resultset-caching.html#GUID-70EF2E8D-805A-4057-995F-34B58ADC0CFD">关于使用隐式语句缓存</a></p>
                     </li>
                     <li>
                        <p><a href="statement-and-resultset-caching.html#GUID-968C6FA9-D861-4624-B7E7-568B63DF4D08">关于使用显式语句缓存</a></p>
                     </li>
                  </ul>
               </div><a id="JJDBC28657"></a><a id="JJDBC28658"></a><a id="JJDBC28659"></a><a id="JJDBC28660"></a><a id="JJDBC28661"></a><a id="JJDBC28662"></a><a id="JJDBC28656"></a><div class="props_rev_3"><a id="GUID-3E425401-A7F0-49FA-A057-01DB6ECCFFC9" name="GUID-3E425401-A7F0-49FA-A057-01DB6ECCFFC9"></a><h4 id="JJDBC-GUID-3E425401-A7F0-49FA-A057-01DB6ECCFFC9" class="sect4"><span class="enumeration_section">20.2.1</span>关于启用和禁用语句缓存</h4>
                  <div>
                     <p>使用<code class="codeph">OracleConnection</code> API时，可以独立于另一个启用或禁用隐式和显式语句缓存。您可以同时使用它们，也可以同时使用它们或两者都有效。
                     </p>
                     <div class="section">
                        <p class="subhead3" id="GUID-3E425401-A7F0-49FA-A057-01DB6ECCFFC9__GUID-8093CBA2-C30E-4C04-BF27-E654650BC150">启用隐式语句缓存</p>
                     </div>
                     <!-- class="section" -->
                     <div class="section">
                        <p>有两种方法可以启用隐式语句缓存。第一种方法在非池化物理连接上启用语句缓存，您需要使用<code class="codeph">setStatementCacheSize</code>方法显式指定每个连接的语句大小。第二种方法在池化逻辑连接上启用语句缓存。池中的每个连接都有自己的Statement缓存，其最大大小可以通过设置<code class="codeph">MaxStatementsLimit</code>属性来指定。
                        </p>
                     </div>
                     <!-- class="section" -->
                     <div class="section">
                        <p class="subhead3" id="GUID-3E425401-A7F0-49FA-A057-01DB6ECCFFC9__GUID-F5B4E54F-F528-4AA5-94E9-AA39B47E0540">方法1</p>
                     </div>
                     <!-- class="section" -->
                     <div class="section">
                        <p>执行以下步骤：</p>
                        <ul style="list-style-type:disc">
                           <li>
                              <p>在连接上调用<code class="codeph">OracleDataSource.setImplicitCachingEnabled(true)</code>方法，将<code class="codeph">OracleDataSource</code>属性<code class="codeph">implicitCachingEnabled</code>设置为<code class="codeph">true</code> 。例如：</p><pre class="oac_no_warn" dir="ltr">OracleDataSource ods = new OracleDataSource（）; ...ods.setImplicitCachingEnabled（真）; ...
</pre></li>
                           <li>
                              <p>在物理连接上调用<code class="codeph">OracleConnection.setStatementCacheSize</code>方法。您提供的参数是缓存中的最大语句数。例如，以下代码指定十个语句的高速缓存大小：</p><pre class="oac_no_warn" dir="ltr">（（的OracleConnection）康恩）.setStatementCacheSize（10）;</pre></li>
                        </ul>
                     </div>
                     <!-- class="section" -->
                     <div class="section">
                        <p class="subhead3" id="GUID-3E425401-A7F0-49FA-A057-01DB6ECCFFC9__GUID-11810DA3-4EF9-4D09-8DE6-D78C6CF5A813">方法2</p>
                     </div>
                     <!-- class="section" -->
                     <div class="section">
                        <p>执行以下步骤：</p>
                        <ul style="list-style-type:disc">
                           <li>
                              <p>将<code class="codeph">OracleDataSource</code>属性<code class="codeph">implicitCachingEnabled</code>和<code class="codeph">connectionCachingEnabled</code>为<code class="codeph">true</code> 。例如：</p><pre class="oac_no_warn" dir="ltr">OracleDataSource ods = new OracleDataSource（）; ...ods.setConnectionCachingEnabled（true）; ods.setImplicitCachingEnabled（true）; ...
</pre></li>
                           <li>
                              <p>使用连接缓存时，将<code class="codeph">MaxStatementsLimit</code>属性设置为连接缓存上的正整数。例如：</p><pre class="oac_no_warn" dir="ltr">属性cacheProps = new Properties（）; ...cacheProps.put（“MaxStatementsLimit”，“50”）;</pre></li>
                        </ul>
                        <p>要确定是否启用了隐式缓存，请调用<code class="codeph">getImplicitCachingEnabled</code> ，如果启用了隐式缓存，则返回<code class="codeph">true</code> ，否则返回<code class="codeph">false</code> 。
                        </p>
                        <div class="infoboxnote" id="GUID-3E425401-A7F0-49FA-A057-01DB6ECCFFC9__GUID-4C702324-D20C-4D04-A746-F74D7EBF3D1A">
                           <p class="notep1">注意：</p>
                           <p>启用语句高速缓存可启用隐式和显式语句高速缓存。</p>
                        </div>
                     </div>
                     <!-- class="section" -->
                     <div class="section">
                        <p class="subhead3" id="GUID-3E425401-A7F0-49FA-A057-01DB6ECCFFC9__GUID-B4AD33D6-38E3-4453-A025-A3BE3D14257C">禁用隐式语句缓存</p>
                     </div>
                     <!-- class="section" -->
                     <div class="section">
                        <p>通过在连接上调用<code class="codeph">setImplicitCachingEnabled(false)</code>或将<code class="codeph">ImplicitCachingEnabled</code>属性设置为<code class="codeph">false</code>来禁用隐式语句缓存。
                        </p>
                     </div>
                     <!-- class="section" -->
                     <div class="section">
                        <p class="subhead3" id="GUID-3E425401-A7F0-49FA-A057-01DB6ECCFFC9__GUID-6A06E0CD-878F-4BD4-9E8C-DA536A40B451">启用显式语句缓存</p>
                     </div>
                     <!-- class="section" -->
                     <div class="section">
                        <p>要启用显式语句高速缓存，必须首先设置语句高速缓存大小。要设置高速缓存大小，请在物理连接上调用<code class="codeph">OracleConnection.setStatementCacheSize</code>方法。您提供的参数是缓存中的最大语句数。参数<code class="codeph">0</code>指定不缓存。要检查缓存大小，请按以下方式使用<code class="codeph">getStatementCacheSize</code>方法：</p><pre class="oac_no_warn" dir="ltr">System.out.println（“Stmt Cache size is”+（（OracleConnection）conn）.getStatementCacheSize（））;</pre><p>以下代码指定十个语句的高速缓存大小：</p><pre class="oac_no_warn" dir="ltr">（（的OracleConnection）康恩）.setStatementCacheSize（10）;</pre><p>通过在连接上调用<code class="codeph">setExplicitCachingEnabled(true)</code>来启用显式语句缓存。
                        </p>
                        <p>要确定是否启用了显式缓存，请调用<code class="codeph">getExplicitCachingEnabled</code> ，如果启用了显式缓存，则返回<code class="codeph">true</code> ，否则返回<code class="codeph">false</code> 。
                        </p>
                        <div class="infoboxnote" id="GUID-3E425401-A7F0-49FA-A057-01DB6ECCFFC9__GUID-6103DC22-7A1C-41A0-8231-12EB9711922A">
                           <p class="notep1">注意：</p>
                           <ul style="list-style-type:disc">
                              <li>
                                 <p>您可以独立地为特定物理连接启用隐式和显式缓存。因此，可以在同一会话期间隐式和显式地执行Statement缓存。</p>
                              </li>
                              <li>
                                 <p>隐式和显式语句缓存共享<span class="italic">相同的</span>缓存。设置语句高速缓存大小时请记住这一点。
                                 </p>
                              </li>
                           </ul>
                        </div>
                     </div>
                     <!-- class="section" -->
                     <div class="section">
                        <p class="subhead3" id="GUID-3E425401-A7F0-49FA-A057-01DB6ECCFFC9__GUID-4F1F45B0-DDB5-4766-90FD-D1ECBF89DE00">禁用显式语句缓存</p>
                     </div>
                     <!-- class="section" -->
                     <div class="section">
                        <p>通过调用<code class="codeph">setExplicitCachingEnabled(false)</code>禁用显式语句缓存。禁用缓存或关闭缓存会清除缓存。以下示例禁用显式语句缓存：<a id="d64860e654" class="indexterm-anchor"></a></p><pre class="oac_no_warn" dir="ltr">（（的OracleConnection）康恩）.setExplicitCachingEnabled（假）;</pre></div>
                     <!-- class="section" -->
                  </div>
               </div><a id="JJDBC28664"></a><a id="JJDBC28665"></a><a id="JJDBC28666"></a><a id="JJDBC28663"></a><div class="props_rev_3"><a id="GUID-D410355C-0318-41AC-AC93-3CDC59EFFD37" name="GUID-D410355C-0318-41AC-AC93-3CDC59EFFD37"></a><h4 id="JJDBC-GUID-D410355C-0318-41AC-AC93-3CDC59EFFD37" class="sect4"><span class="enumeration_section">20.2.2</span>关于关闭缓存语句</h4>
                  <div>
                     <p>执行以下操作以关闭Statement并确保它不会返回到缓存：</p>
                     <div class="section">
                        <p class="subhead3" id="GUID-D410355C-0318-41AC-AC93-3CDC59EFFD37__GUID-BE0E8A7C-0001-46F7-99D6-26570EFCA6A5">在J2SE 5.0中</p>
                     </div>
                     <!-- class="section" -->
                     <div class="section">
                        <ul style="list-style-type:disc">
                           <li>
                              <p>禁用该语句的缓存</p><pre class="oac_no_warn" dir="ltr">stmt.setDisableStmtCaching（真）;</pre></li>
                           <li>
                              <p>调用语句对象的<code class="codeph">close</code>方法</p><pre class="oac_no_warn" dir="ltr">stmt.close（）;</pre></li>
                        </ul>
                     </div>
                     <!-- class="section" -->
                     <div class="section">
                        <p class="subhead3" id="GUID-D410355C-0318-41AC-AC93-3CDC59EFFD37__GUID-FA67A4E5-80B3-4307-A6A8-5C2A18F6289B">在JSE 6.0中</p>
                     </div>
                     <!-- class="section" -->
                     <div class="section"><pre class="oac_no_warn" dir="ltr">stmt.setPoolable（假）; stmt.close（）;</pre></div>
                     <!-- class="section" -->
                     <div class="section">
                        <p class="subhead3" id="GUID-D410355C-0318-41AC-AC93-3CDC59EFFD37__GUID-6B67FF68-3866-4BC4-A486-962E85E3720C">物理关闭缓存的语句</p>
                     </div>
                     <!-- class="section" -->
                     <div class="section">
                        <p>启用隐式语句缓存后，您无法手动关闭语句。语句对象的<code class="codeph">close</code>方法缓存语句而不是关闭它。该声明在以下三个条件之一下自动关闭：</p>
                        <ul style="list-style-type:disc">
                           <li>
                              <p>关闭关联连接时</p>
                           </li>
                           <li>
                              <p>当缓存达到其大小限制时，LRU算法从缓存中抢占最近最少使用的语句对象</p>
                           </li>
                           <li>
                              <p>如果在禁用语句高速缓存的语句上调用<code class="codeph">close</code>方法</p>
                           </li>
                        </ul>
                     </div>
                     <!-- class="section" -->
                  </div>
               </div><a id="JJDBC28668"></a><a id="JJDBC28669"></a><a id="JJDBC28670"></a><a id="JJDBC28671"></a><a id="JJDBC28667"></a><div class="props_rev_3"><a id="GUID-70EF2E8D-805A-4057-995F-34B58ADC0CFD" name="GUID-70EF2E8D-805A-4057-995F-34B58ADC0CFD"></a><h4 id="JJDBC-GUID-70EF2E8D-805A-4057-995F-34B58ADC0CFD" class="sect4"><span class="enumeration_section">20.2.3</span>关于使用隐式语句缓存</h4>
                  <div>
                     <p>启用隐式语句缓存后，默认情况下会自动缓存所有准备和可调用语句。隐式语句缓存包括以下步骤：</p>
                     <ol>
                        <li>
                           <p>启用隐式语句缓存。</p>
                        </li>
                        <li>
                           <p>使用其中一种标准方法分配语句。</p>
                        </li>
                        <li>
                           <p>禁用您不想缓存的任何特定语句的隐式语句缓存。这是一个可选步骤。</p>
                        </li>
                        <li>
                           <p>使用<code class="codeph">close</code>方法缓存语句。
                           </p>
                        </li>
                        <li>
                           <p>通过调用适当的标准prepare方法检索隐式缓存的语句。</p>
                        </li>
                     </ol>
                     <div class="section">
                        <p class="subhead3" id="GUID-70EF2E8D-805A-4057-995F-34B58ADC0CFD__GUID-54FB304A-0E62-44AC-B2C5-FF456C01218B">为隐式缓存分配语句</p>
                     </div>
                     <!-- class="section" -->
                     <div class="section">
                        <p>要为隐式语句缓存分配语句，请像通常那样使用<code class="codeph">prepareStatement</code>或<code class="codeph">prepareCall</code>方法。
                        </p>
                        <p>以下代码分配一个名为<code class="codeph">pstmt</code>的新语句对象：</p><pre class="oac_no_warn" dir="ltr">PreparedStatement pstmt = conn.prepareStatement（“UPDATE \ temp SET ename =？在哪里rowid =？“）;</pre></div>
                     <!-- class="section" -->
                     <div class="section" id="GUID-70EF2E8D-805A-4057-995F-34B58ADC0CFD__i1072689">
                        <p class="subhead3" id="GUID-70EF2E8D-805A-4057-995F-34B58ADC0CFD__GUID-5CCE5D15-45E4-44E8-A292-14A5A65DE3AB">禁用特定语句的隐式语句缓存</p>
                     </div>
                     <!-- class="section" -->
                     <div class="section">
                        <p>通过为连接启用隐式语句缓存，默认情况下，将自动缓存该连接的所有可调用和预准备语句。要防止特定的可调用或预准备语句被隐式缓存，请使用<a id="d64860e808" class="indexterm-anchor"></a>语句对象的<code class="codeph">setDisableStmtCaching</code>方法。您可以通过在任何不常用的语句上调用<code class="codeph">setDisableStmtCaching</code>方法来管理缓存空间。
                        </p>
                        <p>以下代码禁用<code class="codeph">pstmt</code>隐式语句缓存：<code class="codeph"></code></p><pre class="oac_no_warn" dir="ltr">PreparedStatement pstmt = conn.prepareStatement（“SELECT 1 from DUAL”）; （（OraclePreparedStatement）数PreparedStatement pstmt）.setDisableStmtCaching（真）; pstmt.close（）;</pre><div class="infoboxnote" id="GUID-70EF2E8D-805A-4057-995F-34B58ADC0CFD__GUID-0819F6BD-CA13-44E4-8B33-37A4ECFE98F8">
                           <p class="notep1">注意：</p>
                           <p>如果您使用的是JSE 6，则可以使用标准JDBC 4.0方法<code class="codeph">setPoolable</code>禁用语句缓存：</p><pre class="oac_no_warn" dir="ltr">PreparedStatement.setPoolable（假）;</pre><p>使用以下命令检查<code class="codeph">Statement</code>对象是否可以使用：</p><pre class="oac_no_warn" dir="ltr">Statement.isPoolable（）;</pre></div>
                     </div>
                     <!-- class="section" -->
                     <div class="section">
                        <p class="subhead3" id="GUID-70EF2E8D-805A-4057-995F-34B58ADC0CFD__GUID-FB8933A9-F608-48D2-8A0B-F814F812F046">隐式缓存语句</p>
                     </div>
                     <!-- class="section" -->
                     <div class="section">
                        <p>要缓存已分配的语句，请调用语句对象的<code class="codeph">close</code>方法。当调用<code class="codeph">close</code>的上法<code class="codeph">OraclePreparedStatement</code>或<code class="codeph">OracleCallableStatement</code>对象，JDBC驱动程序会自动将缓存中的这一说法，除非你有这种说法禁用缓存。
                        </p>
                        <p>以下代码缓存<code class="codeph">pstmt</code>语句：</p><pre class="oac_no_warn" dir="ltr">pstmt.close（）;</pre></div>
                     <!-- class="section" -->
                     <div class="section">
                        <p class="subhead3" id="GUID-70EF2E8D-805A-4057-995F-34B58ADC0CFD__GUID-0AB1DC9D-6A8A-4E1E-AB48-6D7D5E69D07D">检索隐式缓存的语句</p>
                     </div>
                     <!-- class="section" -->
                     <div class="section">
                        <p>要检索隐式缓存语句，请根据语句类型调用<code class="codeph">prepareStatement</code>或<code class="codeph">prepareCall</code>方法。
                        </p>
                        <p>以下代码使用<code class="codeph">prepareStatement</code>方法从缓存中检索<code class="codeph">pstmt</code> ：</p><pre class="oac_no_warn" dir="ltr">pstmt = conn.prepareStatement（“UPDATE \ temp SET ename =？在哪里rowid =？“）;</pre></div>
                     <!-- class="section" -->
                  </div><a id="JJDBC28673"></a><a id="JJDBC28672"></a><div class="props_rev_3"><a id="GUID-A9FF7B73-F256-4872-88BE-AFFD5D5A7062" name="GUID-A9FF7B73-F256-4872-88BE-AFFD5D5A7062"></a><h5 id="JJDBC-GUID-A9FF7B73-F256-4872-88BE-AFFD5D5A7062" class="sect5"><span class="enumeration_section">20.2.3.1</span>语句分配和隐式语句缓存中使用的方法</h5>
                     <div>
                        <div class="section">
                           <p><a href="statement-and-resultset-caching.html#GUID-A9FF7B73-F256-4872-88BE-AFFD5D5A7062__g1076757" title="表">表20-2</a>描述了用于分配语句和检索隐式缓存语句的方法。
                           </p>
                        </div>
                        <!-- class="section" -->
                        <div class="tblformal" id="GUID-A9FF7B73-F256-4872-88BE-AFFD5D5A7062__g1076757">
                           <p class="titleintable">表20-2语句分配和隐式语句缓存中使用的方法</p>
                           <table cellpadding="4" cellspacing="0" class="Formal" title="语句分配和隐式语句缓存中使用的方法" width="100%" border="1" summary="table" frame="hsides" rules="rows">
                              <thead>
                                 <tr align="left" valign="top">
                                    <th align="left" valign="bottom" width="32%" id="d64860e926">方法</th>
                                    <th align="left" valign="bottom" width="68%" id="d64860e929">隐式语句缓存的功能</th>
                                 </tr>
                              </thead>
                              <tbody>
                                 <tr align="left" valign="top">
                                    <td align="left" valign="top" width="32%" id="d64860e934" headers="d64860e926 ">
                                       <p><code class="codeph">prepareStatement</code></p>
                                    </td>
                                    <td align="left" valign="top" width="68%" headers="d64860e934 d64860e929 ">
                                       <p>执行缓存搜索，查找并返回所需的缓存<code class="codeph">OraclePreparedStatement</code>对象，或者如果未找到匹配项，则分配新的<code class="codeph">OraclePreparedStatement</code>对象</p>
                                    </td>
                                 </tr>
                                 <tr align="left" valign="top">
                                    <td align="left" valign="top" width="32%" id="d64860e948" headers="d64860e926 ">
                                       <p><code class="codeph">方法prepareCall</code></p>
                                    </td>
                                    <td align="left" valign="top" width="68%" headers="d64860e948 d64860e929 ">
                                       <p>执行缓存搜索，查找并返回所需的缓存<code class="codeph">OracleCallableStatement</code>对象，或者如果未找到匹配项，则分配新的<code class="codeph">OracleCallableStatement</code>对象</p>
                                    </td>
                                 </tr>
                              </tbody>
                           </table>
                        </div>
                        <!-- class="inftblhruleinformal" -->
                        <div class="section">
                           <p><a href="statement-and-resultset-caching.html#GUID-A9FF7B73-F256-4872-88BE-AFFD5D5A7062__CBHBFBAF">示例20-1</a>提供了一个示例代码，该代码显示了如何启用隐式语句缓存。
                           </p>
                        </div>
                        <!-- class="section" -->
                        <div class="example" id="GUID-A9FF7B73-F256-4872-88BE-AFFD5D5A7062__CBHBFBAF">
                           <p class="titleinexample">示例20-1使用隐式语句缓存</p><pre class="oac_no_warn" dir="ltr">import java.sql。PreparedStatement的; import java.sql。ResultSet的; import java.sql。的SQLException; import java.util。性能; import javax.sql。数据源; import oracle.jdbc。的OracleConnection; import oracle.jdbc.pool。OracleDataSource;公共类TestJdbc {/ ** *获取连接，准备语句，执行查询，获取结果，关闭连接。* @param ods用于获取连接的DataSource。* / private static void doSQL（DataSource ods）抛出SQLException {final String SQL =“从all_users中选择用户名”; OracleConnection conn = null; PreparedStatement ps = null; ResultSet rs = null; try {conn =（OracleConnection）ods.getConnection（）; System.out.println（“Connection：”+ conn）; System.out.println（“Connection getImplicitCachingEnabled：”+ conn.getImplicitCachingEnabled（））; System.out.println（“Connection getStatementCacheSize：”+ conn.getStatementCacheSize（））; ps = conn.prepareStatement（SQL）; System.out.println（“PreparedStatement：”+ ps）; rs = ps.executeQuery（）; while（rs.next（））{String owner = rs.getString（1）; System.out.println（所有者）;终于{if（rs！）= null）{rs.close（）;如果（ps！= null）{ps.close（）; conn.close（）; public static void main（String [] args）{try {OracleDataSource ods = new OracleDataSource（）; ods.setDriverType（“thin”）; ods.setServerName（“localhost”）; ods.setPortNumber（5221）; ods.setServiceName（“orcl”）; ods.setUser（“HR”）; ods.setPassword（“hr”）; ods.setConnectionCachingEnabled（true）; ods.setImplicitCachingEnabled（true）;属性cacheProps = new Properties（）; cacheProps.put（“InitialLimit”，“1”）; cacheProps.put（“MinLimit”，“1”）; cacheProps.put（“MaxLimit”，“5”）; cacheProps.put（“MaxStatementsLimit”，“50”）; ods.setConnectionCacheProperties（cacheProps）; System.out.println（“DataSource getImplicitCachingEnabled：”+ ods.getImplicitCachingEnabled（））; for（int i = 0; i &lt;5; i ++）{doSQL（ods）; catch（Exception ex）{ex.printStackTrace（）; }}}</pre></div>
                        <!-- class="example" -->
                     </div>
                  </div>
               </div><a id="JJDBC28675"></a><a id="JJDBC28676"></a><a id="JJDBC28677"></a><a id="JJDBC28674"></a><div class="props_rev_3"><a id="GUID-968C6FA9-D861-4624-B7E7-568B63DF4D08" name="GUID-968C6FA9-D861-4624-B7E7-568B63DF4D08"></a><h4 id="JJDBC-GUID-968C6FA9-D861-4624-B7E7-568B63DF4D08" class="sect4"><span class="enumeration_section">20.2.4</span>关于使用显式语句缓存</h4>
                  <div>
                     <p>启用显式语句缓存时，可以显式缓存已准备或可调用的语句。显式语句缓存包括以下步骤：</p>
                     <ol>
                        <li>
                           <p>启用显式语句缓存。</p>
                        </li>
                        <li>
                           <p>使用其中一种标准方法分配语句。</p>
                        </li>
                        <li>
                           <p>使用<code class="codeph">closeWithKey</code>方法通过使用键关闭语句来显式缓存语句。
                           </p>
                        </li>
                        <li>
                           <p>通过调用适当的Oracle WithKey方法检索显式缓存的语句，并指定相应的键。</p>
                        </li>
                        <li>
                           <p>通过使用<code class="codeph">closeWithKey</code>方法再次关闭它来重新缓存打开的显式缓存语句。每次关闭缓存语句时，都会使用其键重新缓存它。
                           </p>
                        </li>
                     </ol>
                     <div class="section">
                        <p class="subhead3" id="GUID-968C6FA9-D861-4624-B7E7-568B63DF4D08__GUID-BC35F76E-655A-4086-9BC4-28E88AFC1CC3">为显式缓存分配语句</p>
                     </div>
                     <!-- class="section" -->
                     <div class="section">
                        <p>要为显式语句缓存分配语句，请像通常那样使用<code class="codeph">createStatement</code> ， <code class="codeph">prepareStatement</code>或<code class="codeph">prepareCall</code>方法。
                        </p>
                        <p>以下代码分配一个名为<code class="codeph">pstmt</code>的新语句对象：</p><pre class="oac_no_warn" dir="ltr">PreparedStatement pstmt = conn.prepareStatement（“UPDATE \ temp SET ename =？在哪里rowid =？“）;</pre></div>
                     <!-- class="section" -->
                     <div class="section">
                        <p class="subhead3" id="GUID-968C6FA9-D861-4624-B7E7-568B63DF4D08__GUID-930C7CA5-B4C8-4128-831D-F901F9B58C87">显式缓存语句</p>
                     </div>
                     <!-- class="section" -->
                     <div class="section">
                        <p>要显式缓存已分配的语句，请调用语句对象的<code class="codeph">closeWithKey</code>方法，并指定键。关键是您提供的任意Java <code class="codeph">String</code> 。<code class="codeph">closeWithKey</code>方法按<code class="codeph">closeWithKey</code>缓存语句。这意味着数据，状态和元数据将被保留并且不会被清除。
                        </p>
                        <p>以下代码使用键<code class="codeph">"mykey"</code>缓存<code class="codeph">pstmt</code>语句：</p><pre class="oac_no_warn" dir="ltr">（（OraclePreparedStatement）pstmt）.closeWithKey（“mykey”）;</pre></div>
                     <!-- class="section" -->
                     <div class="section">
                        <p class="subhead3" id="GUID-968C6FA9-D861-4624-B7E7-568B63DF4D08__GUID-899B056E-8205-487B-8D93-F57EA68A46C9">检索显式缓存的语句</p>
                     </div>
                     <!-- class="section" -->
                     <div class="section">
                        <p>要调用显式缓存的语句，请根据语句类型调用<code class="codeph">getStatementWithKey</code>或<code class="codeph">getCallWithKey</code>方法。
                        </p>
                        <p>如果检索具有指定键的语句，则JDBC驱动程序将根据指定的键在高速缓存中搜索该语句。如果找到匹配项，则返回匹配语句及其状态，数据和元数据。此信息与上次结束语句时的信息相同。如果未找到匹配项，则JDBC驱动程序返回<code class="codeph">null</code> 。
                        </p>
                        <p>以下代码使用带有<code class="codeph">getStatementWithKey</code>方法的<code class="codeph">"mykey"</code>键从缓存中调用<code class="codeph">pstmt</code> 。回想一下，使用<code class="codeph">"mykey"</code>键缓存了<code class="codeph">pstmt</code>语句对象。
                        </p><pre class="oac_no_warn" dir="ltr">pstmt =（（OracleConnection）conn）。getStatementWithKey（“mykey”）;</pre><p>如果在<code class="codeph">pstmt</code>语句对象上调用<code class="codeph">creationState</code>方法，则该方法返回<code class="codeph">EXPLICIT</code> 。</p>
                        <div class="infoboxnote" id="GUID-968C6FA9-D861-4624-B7E7-568B63DF4D08__GUID-5818FF92-F7CE-4F17-B9EF-19723E16318D">
                           <p class="notep1">注意：</p>
                           <p>检索显式缓存的语句时，请确保在指定键时使用适合语句类型的方法。例如，如果使用<code class="codeph">prepareStatement</code>方法分配语句，则使用<code class="codeph">getStatementWithKey</code>方法从缓存中检索该语句。JDBC驱动程序<span class="italic">不</span>验证声明它返回的类型。
                           </p>
                        </div>
                     </div>
                     <!-- class="section" -->
                  </div><a id="JJDBC28678"></a><div class="props_rev_3"><a id="GUID-6E6FE54B-CD93-4C77-8D14-9656F472E86F" name="GUID-6E6FE54B-CD93-4C77-8D14-9656F472E86F"></a><h5 id="JJDBC-GUID-6E6FE54B-CD93-4C77-8D14-9656F472E86F" class="sect5"><span class="enumeration_section">20.2.4.1</span>用于检索显式缓存语句的方法</h5>
                     <div>
                        <div class="section">
                           <p><a href="statement-and-resultset-caching.html#GUID-6E6FE54B-CD93-4C77-8D14-9656F472E86F__g1076741" title="表">表20-3</a>描述了用于检索显式缓存语句的方法。
                           </p>
                        </div>
                        <!-- class="section" -->
                        <div class="tblformal" id="GUID-6E6FE54B-CD93-4C77-8D14-9656F472E86F__g1076741">
                           <p class="titleintable">表20-3用于检索显式缓存语句的方法</p>
                           <table cellpadding="4" cellspacing="0" class="Formal" title="用于检索显式缓存语句的方法" width="100%" border="1" summary="table" frame="hsides" rules="rows">
                              <thead>
                                 <tr align="left" valign="top">
                                    <th align="left" valign="bottom" width="44%" id="d64860e1166">方法</th>
                                    <th align="left" valign="bottom" width="56%" id="d64860e1169">显式语句缓存的功能</th>
                                 </tr>
                              </thead>
                              <tbody>
                                 <tr align="left" valign="top">
                                    <td align="left" valign="top" width="44%" id="d64860e1174" headers="d64860e1166 ">
                                       <p><code class="codeph">getStatementWithKey</code></p>
                                    </td>
                                    <td align="left" valign="top" width="56%" headers="d64860e1174 d64860e1169 ">
                                       <p>指定从缓存中检索预准备语句所需的密钥</p>
                                    </td>
                                 </tr>
                                 <tr align="left" valign="top">
                                    <td align="left" valign="top" width="44%" id="d64860e1182" headers="d64860e1166 ">
                                       <p><code class="codeph">getCallWithKey</code></p>
                                    </td>
                                    <td align="left" valign="top" width="56%" headers="d64860e1182 d64860e1169 ">
                                       <p>指定从缓存中检索可调用语句所需的密钥</p>
                                    </td>
                                 </tr>
                              </tbody>
                           </table>
                        </div>
                        <!-- class="inftblhruleinformal" -->
                     </div>
                  </div>
               </div>
            </div><a id="JJDBC28679"></a><div class="props_rev_3"><a id="GUID-60A76058-8FD3-4A0E-B6DB-B60DC76C6E59" name="GUID-60A76058-8FD3-4A0E-B6DB-B60DC76C6E59"></a><h3 id="JJDBC-GUID-60A76058-8FD3-4A0E-B6DB-B60DC76C6E59" class="sect3"><span class="enumeration_section">20.3</span>关于重用语句对象</h3>
               <div>
                  <p>JDBC 3.0规范引入了语句池的功能，使应用程序能够以与使用<code class="codeph">Connection</code>对象相同的方式重用<code class="codeph">PreparedStatement</code>对象。<code class="codeph">PreparedStatement</code>对象可以透明方式由多个逻辑连接重用。
                  </p>
                  <p>本节包括以下主题：</p>
                  <ul style="list-style-type:disc">
                     <li>
                        <p><a href="statement-and-resultset-caching.html#GUID-31C86EE4-9292-4FAE-BEE2-75E9749E0969">关于使用汇总语句</a></p>
                     </li>
                     <li>
                        <p><a href="statement-and-resultset-caching.html#GUID-B65BBA20-C969-4950-BE7C-EBFEBA1EB5F1">关于结束汇总声明</a></p>
                     </li>
                  </ul>
                  <div class="infoboxnote" id="GUID-60A76058-8FD3-4A0E-B6DB-B60DC76C6E59__GUID-38684C6E-330E-4A9A-9850-8812DED36176">
                     <p class="notep1">注意：</p>
                     <p>Oracle JDBC驱动程序使用隐式语句缓存来支持语句池。</p>
                  </div>
               </div><a id="JJDBC28680"></a><div class="props_rev_3"><a id="GUID-31C86EE4-9292-4FAE-BEE2-75E9749E0969" name="GUID-31C86EE4-9292-4FAE-BEE2-75E9749E0969"></a><h4 id="JJDBC-GUID-31C86EE4-9292-4FAE-BEE2-75E9749E0969" class="sect4"><span class="enumeration_section">20.3.1</span>关于使用池化语句</h4>
                  <div>
                     <p>应用程序可以通过从<code class="codeph">Statement</code>接口调用<code class="codeph">isPoolable</code>方法来确定数据源是否支持语句池。如果返回值为<code class="codeph">true</code> ，则应用程序知道正在合并<code class="codeph">PreparedStatement</code>对象。应用程序还可以使用<code class="codeph">Statement</code>接口中的<code class="codeph">setPoolable</code>方法请求汇集或不池化的<code class="codeph">Statement</code> 。
                     </p>
                     <p>重用池化语句应该对应用程序完全透明，也就是说，无论<code class="codeph">PreparedStatement</code>对象是否参与语句池，应用程序代码都应保持不变。如果应用程序关闭<code class="codeph">PreparedStatement</code>对象，它仍必须调用<code class="codeph">Connection.prepareStatement</code>方法才能重用它。
                     </p>
                     <div class="infoboxnote" id="GUID-31C86EE4-9292-4FAE-BEE2-75E9749E0969__GUID-EDA1DBC4-9373-4A49-86D1-49F09CDEA94D">
                        <p class="notep1">注意：</p>
                        <p>应用程序无法直接控制语句的汇总方式。语句池与<code class="codeph">PooledConnection</code>对象关联，其行为由生成它的<code class="codeph">ConnectionPoolDataSource</code>对象的属性确定。
                        </p>
                     </div>
                  </div>
               </div><a id="JJDBC28681"></a><div class="props_rev_3"><a id="GUID-B65BBA20-C969-4950-BE7C-EBFEBA1EB5F1" name="GUID-B65BBA20-C969-4950-BE7C-EBFEBA1EB5F1"></a><h4 id="JJDBC-GUID-B65BBA20-C969-4950-BE7C-EBFEBA1EB5F1" class="sect4"><span class="enumeration_section">20.3.2</span>关于关闭合并报表</h4>
                  <div>
                     <p>应用程序关闭池化语句的方式与关闭非池化语句的方式完全相同。一旦语句关闭，无论是池化还是非池化，它都不再可供应用程序使用，并且尝试重用它会导致抛出异常。唯一可见的区别是应用程序无法直接关闭正在汇总的物理语句。这是由池管理器完成的。<code class="codeph">PooledConnection.closeAll</code>方法关闭给定物理连接上打开的所有语句，释放与这些语句关联的资源。
                     </p>
                     <p>以下方法可以关闭池化语句：</p>
                     <ul style="list-style-type:disc">
                        <li>
                           <p><a id="d64860e1334" class="indexterm-anchor"></a><a id="d64860e1338" class="indexterm-anchor"></a><code class="codeph">close</code></p>
                           <p>这个<code class="codeph">java.sql.Statement</code>接口方法由应用程序调用。如果正在汇总语句，则它会关闭应用程序使用的逻辑语句，但不会关闭正在汇总的物理语句。
                           </p>
                        </li>
                        <li>
                           <p><a id="d64860e1349" class="indexterm-anchor"></a><a id="d64860e1353" class="indexterm-anchor"></a><code class="codeph">close</code></p>
                           <p>这个<code class="codeph">java.sql.Connection</code>接口方法由应用程序调用。此方法的行为有所不同，具体取决于使用语句的连接是否正在合并：</p>
                           <ul style="list-style-type:disc">
                              <li>
                                 <p>非圆形连接</p>
                                 <p>此方法关闭物理连接以及该连接创建的所有语句。这是必要的，因为垃圾收集机制无法检测何时可以释放外部管理的资源。</p>
                              </li>
                              <li>
                                 <p>汇集连接</p>
                                 <p>此方法关闭逻辑连接及其返回的逻辑语句，但<code class="codeph">PooledConnection</code>打开底层的<code class="codeph">PooledConnection</code>对象和任何关联的池化语句</p>
                              </li>
                           </ul>
                        </li>
                        <li>
                           <p><code class="codeph">PooledConnection.closeAll</code></p>
                           <p>连接池管理器调用此方法来关闭<code class="codeph">PooledConnection</code>对象<code class="codeph">PooledConnection</code>所有物理语句</p>
                        </li>
                     </ul>
                  </div>
               </div>
            </div><a id="JJDBC28682"></a><div class="props_rev_3"><a id="GUID-5D1A9E2F-F191-4FCF-994C-C1D5B143FC4F" name="GUID-5D1A9E2F-F191-4FCF-994C-C1D5B143FC4F"></a><h3 id="JJDBC-GUID-5D1A9E2F-F191-4FCF-994C-C1D5B143FC4F" class="sect3"><span class="enumeration_section">20.4</span>关于结果集缓存</h3>
               <div>
                  <div class="section">
                     <p>您的应用程序有时会向数据库发送重复查询。为了改善重复查询的响应时间，可以将查询，查询片段和PL / SQL函数的结果缓存在内存中。结果缓存存储在所有会话中共享的查询结果。重复执行这些查询时，将直接从高速缓存中检索结果。</p>
                     <div class="infoboxnote" id="GUID-5D1A9E2F-F191-4FCF-994C-C1D5B143FC4F__GUID-320549CB-EAD4-490D-B7AB-93A642B9D0B0">
                        <p class="notep1">注意：</p>
                        <p>如果结果集非常大，则由于大小限制，它可能不会被缓存。</p>
                     </div>
                     <p>您必须使用结果缓存提示注释查询或查询片段，以指示结果将存储在查询结果缓存中。</p>
                     <p>可以通过以下方式缓存查询结果集：</p>
                     <ul style="list-style-type:disc">
                        <li>
                           <p><a href="statement-and-resultset-caching.html#GUID-769AF0BA-E91D-4867-825D-45A46D5FF0E4">服务器端结果集缓存</a></p>
                        </li>
                        <li>
                           <p><a href="statement-and-resultset-caching.html#GUID-0DBA7293-CC9F-446F-959F-34B23F393F80">客户端结果集缓存</a></p>
                        </li>
                     </ul>
                     <div class="infoboxnote" id="GUID-5D1A9E2F-F191-4FCF-994C-C1D5B143FC4F__GUID-6866DB41-CD53-416F-BF0E-A4D4A3FF2EB8">
                        <p class="notep1">注意：</p>
                        <ul style="list-style-type:disc">
                           <li>
                              <p>服务器端和客户端结果集缓存对于只读或主要读取数据最有用。它们可能会降低具有高动态结果的查询的性能。</p>
                           </li>
                           <li>
                              <p>服务器端和客户端结果集缓存都使用内存。因此，缓存非常大的结果集可能会导致性能问题。</p>
                           </li>
                        </ul>
                     </div>
                  </div>
                  <!-- class="section" -->
               </div><a id="JJDBC28683"></a><div class="props_rev_3"><a id="GUID-769AF0BA-E91D-4867-825D-45A46D5FF0E4" name="GUID-769AF0BA-E91D-4867-825D-45A46D5FF0E4"></a><h4 id="JJDBC-GUID-769AF0BA-E91D-4867-825D-45A46D5FF0E4" class="sect4"><span class="enumeration_section">20.4.1</span>服务器端结果集缓存</h4>
                  <div>
                     <div class="section">
                        <p>自Oracle Database <span class="italic">11g</span>第1版以来，已为JDBC Thin和JDBC Oracle调用接口（OCI）驱动程序引入了对服务器端结果集缓存的支持。服务器端结果缓存用于在内存中缓存当前查询，查询片段和PL / SQL函数的结果，然后在将来执行查询，查询片段或PL / SQL函数时使用缓存结果。缓存的结果驻留在SGA的结果缓存内存部分中。只要成功修改了在其创建中使用的数据库对象，缓存的结果就会自动失效。服务器端缓存可以是以下两种类型：</p>
                        <ul style="list-style-type:disc">
                           <li>
                              <p>SQL查询结果缓存</p>
                           </li>
                           <li>
                              <p>PL / SQL函数结果缓存</p>
                           </li>
                        </ul>
                        <div class="infoboxnotealso" id="GUID-769AF0BA-E91D-4867-825D-45A46D5FF0E4__GUID-77C37F76-CC40-48AF-ADD1-678615365BFC">
                           <p class="notep1">也可以看看：</p>
                           <ul style="list-style-type:disc">
                              <li>
                                 <p>有关SQL查询结果缓存的详细信息，请<a href="../tgdba/tuning-result-cache.html#TGDBA631" target="_blank"><span class="italic">参见Oracle数据库性能调整指南</span></a></p>
                              </li>
                              <li>
                                 <p>有关PL / SQL函数结果缓存的更多信息，请<a href="../lnpls/plsql-subprograms.html#LNPLS00817" target="_blank"><span class="italic">参见Oracle Database PL / SQL语言参考</span></a></p>
                              </li>
                           </ul>
                        </div>
                     </div>
                     <!-- class="section" -->
                  </div>
               </div>
               <div class="props_rev_3"><a id="GUID-0DBA7293-CC9F-446F-959F-34B23F393F80" name="GUID-0DBA7293-CC9F-446F-959F-34B23F393F80"></a><h4 id="JJDBC-GUID-0DBA7293-CC9F-446F-959F-34B23F393F80" class="sect4"><span class="enumeration_section">20.4.2</span>客户端结果集缓存</h4>
                  <div>
                     <div class="section">
                        <p>客户端结果集缓存功能支持客户端内存中SQL查询结果集的客户端缓存。通过这种方式，应用程序可以使用客户端内存来利用客户端结果集缓存来改善重复查询的响应时间。</p>
                        <p>本节包括以下主题：</p>
                        <ul style="list-style-type:disc">
                           <li>
                              <p><a href="statement-and-resultset-caching.html#GUID-822D17D2-9872-430A-87F1-0F8B6F2E58DF">启用客户端结果集缓存</a></p>
                           </li>
                           <li>
                              <p><a href="statement-and-resultset-caching.html#GUID-5E30E39C-D773-4A00-94EF-861AE4DDEF78">客户端结果集缓存的好处</a></p>
                           </li>
                           <li>
                              <p><a href="statement-and-resultset-caching.html#GUID-DA1EEDD3-E6C5-4D34-B9A4-069C3690870E">JDBC中的使用指南</a></p>
                           </li>
                        </ul>
                     </div>
                     <!-- class="section" -->
                  </div>
                  <div class="sect4"><a id="GUID-822D17D2-9872-430A-87F1-0F8B6F2E58DF" name="GUID-822D17D2-9872-430A-87F1-0F8B6F2E58DF"></a><h5 id="JJDBC-GUID-822D17D2-9872-430A-87F1-0F8B6F2E58DF" class="sect5"><span class="enumeration_section">20.4.2.1</span>启用客户端结果集缓存</h5>
                     <div>
                        <p></p>
                        <p>Oracle Database Release 18c支持JDBC瘦驱动程序中的客户端结果集缓存。您可以使用新的<code class="codeph">oracle.jdbc.enableQueryResultCache</code>连接属性来启用此功能。此属性的默认值为<code class="codeph">true</code> ，表示默认情况下启用此功能。您可以通过将属性设置为<code class="codeph">false</code>来禁用此功能。
                        </p>
                        <div class="infoboxnote" id="GUID-822D17D2-9872-430A-87F1-0F8B6F2E58DF__GUID-96BBCA50-81F7-402D-9048-17FB2CA820F4">
                           <p class="notep1">注意：</p>
                           <ul style="list-style-type:disc">
                              <li>
                                 <p>在Oracle Database 12 <span class="italic">c</span>第2版（12.2）中， <code class="codeph">enableQueryResultCache</code>属性可用作<code class="codeph">enableResultSetCache</code> ，默认值为<code class="codeph">false</code> 。您可以通过将<code class="codeph">enableResultSetCache</code>属性设置为<code class="codeph">true</code>来启用此功能。
                                 </p>
                              </li>
                              <li>
                                 <p>JDBC OCI驱动程序已经支持客户端结果集缓存。</p>
                              </li>
                           </ul>
                        </div>
                        <div class="infoboxnotealso" id="GUID-822D17D2-9872-430A-87F1-0F8B6F2E58DF__GUID-B214E566-ADFF-4746-9354-C8777666C9A0">
                           <p class="notep1">也可以看看：</p>
                           <p><a href="../lnoci/performance-topics.html#LNOCI10103" target="_blank"><span class="italic">Oracle调用接口程序员指南</span></a></p>
                        </div>
                        <p>要使用此功能，必须按以下方式设置以下数据库初始化参数：</p><pre class="pre codeblock"><code>CLIENT_RESULT_CACHE_SIZE = 100M CLIENT_RESULT_CACHE_LAG = 1000</code></pre><p><code class="codeph">CLIENT_RESULT_CACHE_SIZE</code>参数的此值控制瘦驱动程序可用于其缓存的内存量。
                        </p>
                        <p>然后可以对只读或读取主表进行注释，并将其数据缓存在驱动程序上。例如， <code class="codeph">RESULT_CACHE(MODE FORCE)</code> 。
                        </p>
                        <p>您还可以使用SQL提示<code class="codeph">/*+RESULT_CACHE */</code>来标识符合缓存条件的查询。
                        </p>
                        <div class="infoboxnotealso" id="GUID-822D17D2-9872-430A-87F1-0F8B6F2E58DF__GUID-51E8406F-C81C-4264-BAC7-7DA01ABD9159">
                           <p class="notep1">也可以看看：</p><a href="../jajdb/index.html" target="_blank"><span class="italic">Oracle数据库JDBC Java API参考</span></a></div>
                     </div>
                  </div>
                  <div class="props_rev_3"><a id="GUID-5E30E39C-D773-4A00-94EF-861AE4DDEF78" name="GUID-5E30E39C-D773-4A00-94EF-861AE4DDEF78"></a><h5 id="JJDBC-GUID-5E30E39C-D773-4A00-94EF-861AE4DDEF78" class="sect5"><span class="enumeration_section">20.4.2.2</span>客户端结果集缓存的优点</h5>
                     <div>
                        <div class="section">
                           <p>客户端结果集缓存的好处如下：</p>
                           <ul style="list-style-type:disc">
                              <li>
                                 <p>客户端结果集缓存对应用程序完全透明，其结果集数据缓存与影响其结果集的任何会话或数据库更改保持一致。</p>
                              </li>
                              <li>
                                 <p>表注释使客户端结果集对JDBC应用程序透明地工作。否则，您必须使用提示启用它。缓存命中避免执行查询和往返服务器以获取结果集。这可以为服务器资源（例如，服务器CPU和服务器I / O）节省大量性能。</p>
                                 <div class="infoboxnotealso" id="GUID-5E30E39C-D773-4A00-94EF-861AE4DDEF78__GUID-B4D218AF-E0F4-4F70-9308-EA78C8B9ADC8">
                                    <p class="notep1">也可以看看：</p>
                                    <p><a href="statement-and-resultset-caching.html#GUID-1007119D-A2F7-43D5-8A53-206033BA35FD">表注释</a>和<a href="statement-and-resultset-caching.html#GUID-E628A526-EA86-450C-B974-63422881E875">SQL提示</a></p>
                                 </div>
                              </li>
                              <li>
                                 <p>客户端上的结果缓存是按进程进行的，因此多个客户端会话可以同时使用匹配的缓存结果集。</p>
                              </li>
                              <li>
                                 <p>客户端上的结果缓存最大限度地减少了每个应用程序拥有自己的自定义结果集缓存的需要。</p>
                              </li>
                              <li>
                                 <p>客户端上的结果缓存使用比服务器内存便宜的客户端内存。</p>
                              </li>
                           </ul>
                        </div>
                        <!-- class="section" -->
                     </div>
                  </div>
                  <div class="props_rev_3"><a id="GUID-DA1EEDD3-E6C5-4D34-B9A4-069C3690870E" name="GUID-DA1EEDD3-E6C5-4D34-B9A4-069C3690870E"></a><h5 id="JJDBC-GUID-DA1EEDD3-E6C5-4D34-B9A4-069C3690870E" class="sect5"><span class="enumeration_section">20.4.2.3</span> JDBC中的使用指南</h5>
                     <div>
                        <div class="section">
                           <p>您可以通过以下三种方式启用结果集缓存：</p>
                           <ul style="list-style-type:disc">
                              <li>
                                 <p><a href="statement-and-resultset-caching.html#GUID-1764F69A-8E6B-4B78-AAF0-1D6257B3BBE5">RESULT_CACHE_MODE参数</a></p>
                              </li>
                              <li>
                                 <p><a href="statement-and-resultset-caching.html#GUID-1007119D-A2F7-43D5-8A53-206033BA35FD">表注释</a></p>
                              </li>
                              <li>
                                 <p><a href="statement-and-resultset-caching.html#GUID-E628A526-EA86-450C-B974-63422881E875">SQL提示</a></p>
                              </li>
                           </ul>
                           <div class="infoboxnote" id="GUID-DA1EEDD3-E6C5-4D34-B9A4-069C3690870E__GUID-615B0647-6DE8-4BBF-9B23-15180BB8C9AD">
                              <p class="notep1">注意：</p>
                              <ul style="list-style-type:disc">
                                 <li>
                                    <p>使用客户端结果集缓存时，必须在应用程序级别使用JDBC语句缓存或缓存语句。</p>
                                 </li>
                                 <li>
                                    <p>SQL提示优先于会话参数<code class="codeph">RESULT_CACHE_MODE</code>和表注释。表注释<code class="codeph">FORCE</code>优先于会话参数。
                                    </p>
                                 </li>
                              </ul>
                           </div>
                        </div>
                        <!-- class="section" -->
                     </div>
                     <div>
                        <div class="relinfo">
                           <p><strong>相关话题</strong></p>
                           <ul>
                              <li><a href="statement-and-resultset-caching.html#GUID-F3F4BB63-356A-4F65-81B1-5C84FC35A16D">语句和结果集缓存</a></li>
                           </ul>
                        </div>
                     </div>
                     
                     <div class="props_rev_3"><a id="GUID-1764F69A-8E6B-4B78-AAF0-1D6257B3BBE5" name="GUID-1764F69A-8E6B-4B78-AAF0-1D6257B3BBE5"></a><h6 id="JJDBC-GUID-1764F69A-8E6B-4B78-AAF0-1D6257B3BBE5" class="sect6"><span class="enumeration_section">20.4.2.3.1</span> RESULT_CACHE_MODE参数</h6>
                        <div>
                           <div class="section">
                              <p>您可以使用<code class="codeph">RESULT_CACHE_MODE</code>参数来确定查询中表的结果缓存模式。将此子句与<code class="codeph">ALTER SESSION</code>和<code class="codeph">ALTER SYSTEM</code>语句一起使用，或在服务器参数文件（ <code class="codeph">init.ora</code> ）中使用以确定结果缓存。您可以设置<code class="codeph">RESULT_CACHE_MODE</code>参数以控制SQL查询结果缓存是用于所有查询，还是仅用于使用SQL提示或表注释使用结果缓存提示进行批注的查询。
                              </p>
                           </div>
                           <!-- class="section" -->
                        </div>
                     </div>
                     <div class="props_rev_3"><a id="GUID-1007119D-A2F7-43D5-8A53-206033BA35FD" name="GUID-1007119D-A2F7-43D5-8A53-206033BA35FD"></a><h6 id="JJDBC-GUID-1007119D-A2F7-43D5-8A53-206033BA35FD" class="sect6"><span class="enumeration_section">20.4.2.3.2</span>表注释</h6>
                        <div>
                           <div class="section">
                              <p>您可以使用表注释来启用结果缓存，而无需更改代码。<code class="codeph">ALTER TABLE</code>和<code class="codeph">CREATE TABLE</code>语句使您可以使用结果缓存模式注释表。语法是：</p><pre class="oac_no_warn" dir="ltr">CREATE | ALTER TABLE [&lt;schema&gt;。] &lt;table&gt; ...[RESULT_CACHE（MODE {FORCE | DEFAULT}）]</pre><p>以下示例显示如何将表注释与<code class="codeph">CREATE TABLE</code>语句一起使用：</p><pre class="oac_no_warn" dir="ltr">CREATE TABLE foo（NUMBER，b VARCHAR2（20））RESULT_CACHE（MODE FORCE）;</pre><p>以下示例显示如何将表注释与<code class="codeph">ALTER TABLE</code>语句一起使用：</p><pre class="oac_no_warn" dir="ltr">ALTER TABLE foo RESULT_CACHE（MODE DEFAULT）;</pre></div>
                           <!-- class="section" -->
                        </div>
                     </div>
                     <div class="props_rev_3"><a id="GUID-E628A526-EA86-450C-B974-63422881E875" name="GUID-E628A526-EA86-450C-B974-63422881E875"></a><h6 id="JJDBC-GUID-E628A526-EA86-450C-B974-63422881E875" class="sect6"><span class="enumeration_section">20.4.2.3.3</span> SQL提示</h6>
                        <div>
                           <div class="section">
                              <p>您可以使用SQL提示通过使用<code class="codeph">/*+ result_cache */</code>或/ * + no_result_cache * / hint对查询进行批注来指定要缓存的查询。例如，请查看以下代码段：</p><pre class="oac_no_warn" dir="ltr">String query =“select / * + result_cache * / *来自员工employee_id &lt;：1”; （（oracle.jdbc。的OracleConnection）康涅狄格州）.setImplicitCachingEnabled（真）; （（oracle.jdbc。的OracleConnection）康恩）.setStatementCacheSize（10）; PreparedStatement pstmt; ResultSet rs; for（int j = 0; j &lt;10; j ++）{pstmt = conn.prepareStatement（query）; pstmt.setInt（1,7500）; rs = pstmt.executeQuery（）; while（rs.next（））{//查看值} rs.close; pstmt.close（）; }}</pre><p>在前面的示例中，客户端结果缓存提示<code class="codeph">/*+ result_cache */</code>被注释为实际查询，即， <code class="codeph">select * from employees where employee_id &lt; : 1</code> 。因此，查询的第一次执行将转到数据库，并为查询的其余九次执行缓存结果集。这显着提高了应用程序的性能。这主要用于只读数据。
                              </p>
                              <p>以下是SQL提示的更多示例。以下所有示例都假定使用以下命令对<code class="codeph">dept</code>表进行结果缓存注释：</p><pre class="oac_no_warn" dir="ltr">ALTER TABLE dept result_cache（MODE FORCE）;</pre></div>
                           <!-- class="section" -->
                           <div class="section">
                              <p class="subhead3" id="GUID-E628A526-EA86-450C-B974-63422881E875__GUID-57E656F2-6000-4BDC-B72B-9F8D5D7A08E5">例子</p>
                           </div>
                           <!-- class="section" -->
                           <div class="section">
                              <ul style="list-style-type:disc">
                                 <li>
                                    <p>SELECT * FROM员工</p>
                                    <p>结果集不会被缓存。</p>
                                 </li>
                                 <li>
                                    <p>SELECT * FROM部门</p>
                                    <p>结果集将被缓存。</p>
                                 </li>
                                 <li>
                                    <p>SELECT / * + result_cache * / employee_id来自员工</p>
                                    <p>结果集将被缓存。</p>
                                 </li>
                                 <li>
                                    <p>SELECT / * + no_result_cache * / department_id来自部门</p>
                                    <p>结果集不会被缓存。</p>
                                 </li>
                                 <li>
                                    <p>SELECT / * + result_cache * / * FROM departments</p>
                                    <p>虽然不需要查询提示，但结果集将被缓存。</p>
                                 </li>
                                 <li>
                                    <p>SELECT e.first_name FROM employees e，departments d WHERE e.department_id = d.department_id</p>
                                    <p>结果集不会被缓存，因为查询提示既不可用也不是所有表都注释为<code class="codeph">FORCE</code> 。</p>
                                 </li>
                              </ul>
                              <div class="infoboxnote" id="GUID-E628A526-EA86-450C-B974-63422881E875__GUID-1948B9E8-654E-4F0B-81A6-4004E656EFBC">
                                 <p class="notep1">注意：</p>
                                 <p>有关使用指南，客户端缓存一致性，部署时间设置，客户端缓存统计信息，客户端结果缓存验证以及OCI客户端结果缓存和服务器结果缓存的信息，请参阅<a href="../lnoci/performance-topics.html#LNOCI10103" target="_blank"><span class="italic">Oracle Call Interface Programmer's Guide</span></a> 。
                                 </p>
                              </div>
                           </div>
                           <!-- class="section" -->
                        </div>
                     </div>
                  </div>
               </div>
            </div>
         </div>
      </article>
   </body>
</html>