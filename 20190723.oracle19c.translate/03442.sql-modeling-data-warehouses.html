<html lang="en-us" dir="ltr" xml:lang="en-us">
   <head>
      <meta http-equiv="Content-Type" content="text/html; charset=utf-8"></meta>
      <meta name="viewport" content="width=device-width, initial-scale=1"></meta>
      <meta http-equiv="X-UA-Compatible" content="IE=edge"></meta>
      <title>用于建模的SQL</title>
      <meta property="og:site_name" content="Oracle Help Center"></meta>
      <meta property="og:title" content="Data Warehousing Guide"></meta>
      <meta property="og:description" content=""></meta>
      <link rel="stylesheet" href="/sp_common/book-template/ohc-book-template/css/book.css"></link>
      <link rel="shortcut icon" href="/sp_common/book-template/ohc-common/img/favicon.ico"></link>
      <meta name="application-name" content="Data Warehousing Guide"></meta>
      <meta name="generator" content="DITA Open Toolkit version 1.8.5 (Mode = doc)"></meta>
      <meta name="plugin" content="SP_docbuilder HTML plugin release 18.2.2"></meta>
      <link rel="alternate" href="database-data-warehousing-guide.pdf" title="PDF File" type="application/pdf"></link>
      <meta name="robots" content="all"></meta>
      <link rel="schema.dcterms" href="http://purl.org/dc/terms/"></link>
      <meta name="dcterms.created" content="2019-01-09T00:20:13-08:00"></meta>
      
      <meta name="dcterms.dateCopyrighted" content="2001, 2019"></meta>
      <meta name="dcterms.category" content="database"></meta>
      <meta name="dcterms.identifier" content="E96243-01"></meta>
      
      <meta name="dcterms.product" content="en/database/oracle/oracle-database/19"></meta>
      
      <link rel="prev" href="sql-pattern-matching-data-warehouses.html" title="Previous" type="text/html"></link>
      <link rel="next" href="advanced-analytical-sql-data-warehouses.html" title="Next" type="text/html"></link>
      <script>
        document.write('<style type="text/css">');
        document.write('body > .noscript, body > .noscript ~ * { visibility: hidden; }');
        document.write('</style>');
     </script>
      <script src="/sp_common/book-template/requirejs/require.js" data-main="/sp_common/book-template/ohc-book-template/js/book-config"></script>
      <script>
            if (window.require === undefined) {
                document.write('<script data-main="sp_common/book-template/ohc-book-template/js/book-config" src="sp_common/book-template/requirejs/require.js"><\/script>');
                document.write('<link href="sp_common/book-template/ohc-book-template/css/book.css" rel="stylesheet"/>');
            }
        </script>
      <script type="application/json" id="ssot-metadata">{"primary":{"category":{"short_name":"database","element_name":"Database","display_in_url":true},"suite":{"short_name":"oracle","element_name":"Oracle","display_in_url":true},"product_group":{"short_name":"not-applicable","element_name":"Not applicable","display_in_url":false},"product":{"short_name":"oracle-database","element_name":"Oracle Database","display_in_url":true},"release":{"short_name":"19","element_name":"Release 19","display_in_url":true}}}</script>
      
    <meta name="dcterms.title" content="Database Data Warehousing Guide"></meta>
    <meta name="dcterms.isVersionOf" content="DWHSG"></meta>
    <meta name="dcterms.release" content="Release 19"></meta>
  </head>
   <body dir="ltr">
      <div class="noscript alert alert-danger text-center" role="alert">
         <a href="sql-pattern-matching-data-warehouses.html" class="pull-left"><span class="glyphicon glyphicon-chevron-left" aria-hidden="true"></span>上一页</a> <a href="advanced-analytical-sql-data-warehouses.html" class="pull-right">下一页<span class="glyphicon glyphicon-chevron-right" aria-hidden="true"></span></a> <span class="fa fa-exclamation-triangle" aria-hidden="true"></span>必须启用JavaScript才能正确显示此内容</div>
      <article>
         <header>
            <ol class="breadcrumb" vocab="http://schema.org/" typeof="BreadcrumbList">
               <li property="itemListElement" typeof="ListItem"><a href="index.html" property="item" typeof="WebPage"><span property="name">数据仓库指南</span></a></li>
               <li property="itemListElement" typeof="ListItem"><a href="part-relational-analytics.html" property="item" typeof="WebPage"><span property="name">关系分析</span></a></li>
               <li class="active" property="itemListElement" typeof="ListItem">用于建模的SQL</li>
            </ol>
            <a id="GUID-538F78AA-9BF3-46F2-93D1-39A8739B3237" name="GUID-538F78AA-9BF3-46F2-93D1-39A8739B3237"></a>
            
            <h2 id="DWHSG-GUID-538F78AA-9BF3-46F2-93D1-39A8739B3237" class="sect2"><span class="enumeration_chapter">22</span>用于建模的SQL</h2>
         </header>
         <div class="ind">
            <div>
               <p>本章讨论使用SQL建模，包括：</p>
               <ul style="list-style-type:disc">
                  <li>
                     <p><a href="sql-modeling-data-warehouses.html#GUID-C1C6A6EA-F824-4E15-B2E1-3021FC95CA3C">数据仓库中的SQL建模概述</a></p>
                  </li>
                  <li>
                     <p><a href="sql-modeling-data-warehouses.html#GUID-54154720-DA60-4DBA-A94C-AE5ECD8B2BBF">SQL建模的基本主题</a></p>
                  </li>
                  <li>
                     <p><a href="sql-modeling-data-warehouses.html#GUID-353F0903-9CD3-4BD9-A584-B31CB1FAB282">SQL建模的高级主题</a></p>
                  </li>
                  <li>
                     <p><a href="sql-modeling-data-warehouses.html#GUID-983B5378-4FCA-4452-B615-3A39B491F1E4">SQL建模的性能注意事项</a></p>
                  </li>
                  <li>
                     <p><a href="sql-modeling-data-warehouses.html#GUID-195E4085-EE47-4122-AED6-F358C0C2F716">SQL建模的示例</a></p>
                  </li>
               </ul>
            </div><a id="DWHSG8757"></a><a id="DWHSG8756"></a><div class="props_rev_3"><a id="GUID-C1C6A6EA-F824-4E15-B2E1-3021FC95CA3C" name="GUID-C1C6A6EA-F824-4E15-B2E1-3021FC95CA3C"></a><h3 id="DWHSG-GUID-C1C6A6EA-F824-4E15-B2E1-3021FC95CA3C" class="sect3"><span class="enumeration_section">22.1</span>数据仓库中SQL建模概述</h3>
               <div>
                  <p><code class="codeph">MODEL</code>子句<a id="d90648e71" class="indexterm-anchor"></a><a id="d90648e73" class="indexterm-anchor"></a>为SQL计算带来了新的功能和灵活性。使用<code class="codeph">MODEL</code>子句，您可以从查询结果创建多维数组，然后将公式（称为规则）应用于此数组以计算新值。规则的范围可以从基本算术到使用递归的联立方程。对于某些应用程序， <code class="codeph">MODEL</code>子句可以替换基于PC的电子表格。SQL中的模型利用了Oracle数据库在可伸缩性，可管理性，协作和安全性方面的优势。核心查询引擎可以处理无限量的数据。通过在数据库中定义和执行模型，用户可以避免将大型数据集传输到单独的建模环可以跨工作组轻松共享模型，确保所有应用程序的计算一致。正如可以共享模型一样，也可以使用Oracle的安全功能精确控制访问。凭借其丰富的功能， <code class="codeph">MODEL</code>子句可以增强所有类型的应用程序。
                  </p>
                  <p>通过<code class="codeph">MODEL</code>子句，您可以通过将查询列映射到三个组来创建多维数组：分区，维度和度量列。这些元素执行以下任务：</p>
                  <ul style="list-style-type:disc">
                     <li>
                        <p>分区列以类似于<a href="sql-analysis-reporting-data-warehouses.html#GUID-20EFBF1E-F79D-4E4A-906C-6E496EECA684" title="使用返回近似结果的SQL函数计算近似聚合。它们主要用于数据探索查询，其中不需要精确值，并且可以接受近似值。LISTAGG函数根据ORDER BY子句对每个组中的数据进行排序，然后连接度量列的值。Oracle数据库提供了一组返回近似百分位数结果的SQL函数。这些功能可用于监控质量，跟踪社交媒体活动，监控性能以及搜索数据集中的异常值。">SQL for Analysis and Reporting中</a>描述的分析函数的分区的方式定义结果集的逻辑块。<code class="codeph">MODEL</code>子句中的规则独立于其他分区应用于每个分区。因此，分区用作并行化<code class="codeph">MODEL</code>计算的边界点。
                        </p>
                     </li>
                     <li>
                        <p>维度列定义多维数组，用于标识分区中的单元格。默认情况下，维度的完整组合应仅标识分区中的一个单元格。在默认模式下，可以将它们视为与关系表的键类似。</p>
                     </li>
                     <li>
                        <p>度量等同于星型模式中的事实表的度量。它们通常包含数值，例如销售单位或成本。通过指定其完整的维度组合来访问每个单元格。请注意，每个分区可能具有与给定维度组合匹配的单元格。</p>
                     </li>
                  </ul>
                  <p><code class="codeph">MODEL</code>子句使您可以指定规则来操作由分区和维度列定义的多维数组中的单元格的度量值。规则通过直接指定维值来访问和更新度量列值。规则中使用的引用导致高度可读的模型。规则简洁灵活，可以使用通配符和循环结构来获得最大的表现力。Oracle数据库以有效的方式评估规则，尽可能并行化模型计算，并提供<code class="codeph">MODEL</code>子句与其他SQL子句的无缝集成。因此， <code class="codeph">MODEL</code>子句是一种可扩展且可管理的计算数据库中业务模型的方法。
                  </p>
                  <p><a href="sql-modeling-data-warehouses.html#GUID-C1C6A6EA-F824-4E15-B2E1-3021FC95CA3C__I1024102">图22-1</a>提供了SQL建模功能的概念性概述。该图有三个部分。顶部部分显示了将典型表划分为分区，维度和度量列的概念。中间部分显示了两个规则，用于计算2002年的<code class="codeph">Prod1</code>和<code class="codeph">Prod2</code>的值。最后，第三部分显示了一个查询的输出，该查询将规则应用于具有假设数据的此类表。无阴影输出是从数据库中检索的原始数据，而阴影输出显示由规则计算的行。注意，分区<code class="codeph">A</code>中的结果是独立于分区<code class="codeph">B</code>结果计算的。</p>
                  <div class="figure" id="GUID-C1C6A6EA-F824-4E15-B2E1-3021FC95CA3C__I1024102">
                     <p class="titleinfigure">图22-1模型元素</p><img src="img/dwhsg116.gif" alt="下面是图22-1的描述" title="下面是图22-1的描述" longdesc="img_text/dwhsg116.html"><br><a href="img_text/dwhsg116.html">“图22-1模型元素”的描述</a></div>
                  <!-- class="figure" -->
                  <p>本节包含以下主题：</p>
                  <ul style="list-style-type:disc">
                     <li>
                        <p><a href="sql-modeling-data-warehouses.html#GUID-0054F7CF-1F73-4B92-ADB1-6119F829ADD7">如何在SQL模型中处理数据</a></p>
                     </li>
                     <li>
                        <p><a href="sql-modeling-data-warehouses.html#GUID-AD92A5C6-C08D-48F5-A9C6-81E257FAABAF">为什么在数据仓库中使用SQL建模？</a></p>
                     </li>
                     <li>
                        <p><a href="sql-modeling-data-warehouses.html#GUID-CC847DA6-8838-412B-B984-AF75EA0FFAC8">关于SQL建模功能</a></p>
                     </li>
                  </ul>
               </div><a id="DWHSG9305"></a><a id="DWHSG8758"></a><div class="props_rev_3"><a id="GUID-0054F7CF-1F73-4B92-ADB1-6119F829ADD7" name="GUID-0054F7CF-1F73-4B92-ADB1-6119F829ADD7"></a><h4 id="DWHSG-GUID-0054F7CF-1F73-4B92-ADB1-6119F829ADD7" class="sect4"><span class="enumeration_section">22.1.1</span>如何在SQL模型中处理数据</h4>
                  <div>
                     <p><a href="sql-modeling-data-warehouses.html#GUID-0054F7CF-1F73-4B92-ADB1-6119F829ADD7__BEIDGJBA">图22-2</a> <a id="d90648e195" class="indexterm-anchor"></a>显示简单<code class="codeph">MODEL</code>子句中的处理流程。在这种情况下，您将通过包含三个规则的<code class="codeph">MODEL</code>子句来跟踪数据。其中一条规则更新现有值，而另外两条规则为预测创建新值。该图显示查询检索的数据行被送入<code class="codeph">MODEL</code>子句并重新排列为数组。定义数组后，将规则逐个应用于数据。<a href="sql-modeling-data-warehouses.html#GUID-0054F7CF-1F73-4B92-ADB1-6119F829ADD7__BEIDGJBA">图22-2中</a>的阴影单元表示规则创建的新数据，椭圆包围的单元表示新值的源数据。最后，数据（包括其更新值和新创建的值）将重新排列为行形式，并显示为查询结果。请注意，此查询不会将任何数据插入任何表。
                     </p>
                     <div class="figure" id="GUID-0054F7CF-1F73-4B92-ADB1-6119F829ADD7__BEIDGJBA">
                        <p class="titleinfigure">图22-2模型流程处理</p><img src="img/dwhsg120.png" alt="下面是图22-2的描述" title="下面是图22-2的描述" longdesc="img_text/dwhsg120.html"><br><a href="img_text/dwhsg120.html">“图22-2模型流程处理”的描述</a></div>
                     <!-- class="figure" -->
                  </div>
               </div><a id="DWHSG8760"></a><div class="props_rev_3"><a id="GUID-AD92A5C6-C08D-48F5-A9C6-81E257FAABAF" name="GUID-AD92A5C6-C08D-48F5-A9C6-81E257FAABAF"></a><h4 id="DWHSG-GUID-AD92A5C6-C08D-48F5-A9C6-81E257FAABAF" class="sect4"><span class="enumeration_section">22.1.2</span>为什么在数据仓库中使用SQL建模？
                  </h4>
                  <div>
                     <p>Oracle建模使您可以对数据执行复杂的计算。典型情况是您希望将业务规则应用于数据，然后生成报告。由于Oracle数据库将建模计算集成到数据库中，因此性能和可管理性得到显着提升。请考虑以下查询：</p><pre class="oac_no_warn" dir="ltr">SELECT SUBSTR（国家，1,20）国家，SUBSTR（产品，1,15）产品，年份，销售额FROM sales_view国家IN（'意大利'，'日本'）MODEL PARTITION BY（国家）DIMENSION BY（产品，年份） ）措施（销售销售）规则（销售['Bounce'，2002] =销售['Bounce'，2001] +销售['Bounce'，2000]，销售['Y Box'，2002] =销售['Y Box '，2001]，sales ['All_Products'，2002] = sales ['Bounce'，2002] + sales ['Y Box'，2002]）ORDER BY country，product，year;</pre><p>此查询对<code class="codeph">sales_view</code>的数据进行<code class="codeph">sales_view</code> （在<span class="q">“ <a href="sql-modeling-data-warehouses.html#GUID-C5C34EFE-B74C-45BA-8D4B-71E527F858F7">SQL建模示例的基本模式</a> ”中说明</span> ），以便在每个国家/地区执行由三个规则定义的模型计算。该模型计算2002年Bounce的销售额作为2000年和2001年销售额的总和，并将2002年Y Box的销售额设定为与2001年相同的值。此外，它还将2002年的新产品类别All_Products（ <code class="codeph">sales_view</code>没有产品All_Products）引入该年度Bounce和Y Box的销售总和。此查询的输出如下所示，其中粗体文本表示新值：</p><pre class="oac_no_warn" dir="ltr">国家产品年销售额-------------------- --------------- ----------  - ---------意大利弹跳1999 2474.78意大利弹跳2000 4333.69意大利弹跳2001 4846.3 <span class="bold">意大利弹跳2002 9179.99</span> ...意大利Y Box 1999 15215.16意大利Y Box 2000 29322.89意大利Y Box 2001 81207.55 <span class="bold">意大利Y Box 2002 81207.55</span> ...
<span class="bold">意大利All_Products 2002 90387.54</span> ...日本弹跳1999 2961.3日本弹跳2000 5133。53日本弹跳2001 6303。6 <span class="bold">日本弹跳2002 11437.13</span> ......日本Y Box 1999 22161。91日本Y Box 2000 45690.66日本Y Box 2001 89634。83 <span class="bold">日本Y Box 2002 89634.83</span> ...
<span class="bold">日本All_Products 2002 101071.96</span> ......
</pre><p>请注意，虽然输入中存在Bounce和Y Box的销售值，但会导出All_Products的值。</p>
                  </div>
               </div><a id="DWHSG8761"></a><div class="props_rev_3"><a id="GUID-CC847DA6-8838-412B-B984-AF75EA0FFAC8" name="GUID-CC847DA6-8838-412B-B984-AF75EA0FFAC8"></a><h4 id="DWHSG-GUID-CC847DA6-8838-412B-B984-AF75EA0FFAC8" class="sect4"><span class="enumeration_section">22.1.3</span>关于SQL建模功能</h4>
                  <div>
                     <p>Oracle数据库通过<code class="codeph">MODEL</code>子句提供以下功能：</p>
                     <ul style="list-style-type:disc">
                        <li>
                           <p>使用维值进行单元寻址</p>
                           <p>单个行中的度量列被视为多维数组中的单元格，可以使用维值进行引用和更新。例如，在事实表<code class="codeph">ft(country, year, sales)</code> ，你可以指定<code class="codeph">country</code>和<code class="codeph">year</code>是维列和<code class="codeph">sales</code>是测量和基准销售某一国家和年份的<code class="codeph">sales[country='Spain', year=1999]</code> 。这为您提供了1999年西班牙的销售价值。您还可以使用简写形式的<code class="codeph">sales['Spain', 1999]</code> ，其含义相同。但是，这些符号之间存在一些语义差异。有关更多详细信息，请参阅<span class="q">“ <a href="sql-modeling-data-warehouses.html#GUID-9ACD704F-0428-4F49-BF96-47486713E97E">关于SQL建模中的单元格引用</a> ”</span> 。
                           </p>
                        </li>
                        <li>
                           <p>符号数组计算</p>
                           <p>您可以指定一系列公式（称为规则）来操作数据。规则可以调用单个单元格或一组或一系列单元格上的函数。涉及单个细胞的示例如下：</p><pre class="oac_no_warn" dir="ltr">销售[country ='Spain'，year = 2001] = sales ['Spain'，2000] + sales ['Spain'，1999]</pre><p>这使西班牙2001年的销售额达到西班牙1999年和2000年的销售额。涉及一系列单元格的示例如下：</p><pre class="oac_no_warn" dir="ltr">销售[country ='Spain'，year = 2001] = MAX（销售）['西班牙'，1997年和2000年之间的年份]</pre><p>这使西班牙2001年的销售额等于1997年至2000年西班牙的最高销售额。</p>
                        </li>
                        <li>
                           <p><code class="codeph">UPSERT</code> ， <code class="codeph">UPSERT</code> <code class="codeph">ALL</code>和<code class="codeph">UPDATE</code>选项</p>
                           <p>使用默认的<code class="codeph">UPSERT</code>选项，您可以创建输入数据中不存在的单元格值。如果引用的单元格存在于数据中，则会更新。如果引用的单元格在数据中不存在，并且规则使用适当的表示法，则插入单元格。<code class="codeph">UPSERT</code> <code class="codeph">ALL</code>选项使您可以针对更多种规则使用<code class="codeph">UPSERT</code>行为。另一方面， <code class="codeph">UPDATE</code>选项永远不会插入任何新单元格。
                           </p>
                           <p>您可以全局指定这些选项，在这种情况下，它们适用于所有规则或每个规则。如果在规则级别指定选项，则它将覆盖全局选项。请考虑以下规则：</p><pre class="oac_no_warn" dir="ltr">UPDATE销售['西班牙'，1999] = 3567.99，UPSERT销售['西班牙'，2001] =销售['西班牙'，2000] +销售['西班牙'，1999]</pre><p>第一条规则更新了西班牙1999年的销售单元。第二条规则更新了2001年在西班牙销售的单元格（如果存在），否则会创建一个新单元格。</p>
                        </li>
                        <li>
                           <p>通配符维度规范</p>
                           <p>您可以使用<code class="codeph">ANY</code>和<code class="codeph">IS</code> <code class="codeph">ANY</code>指定维度中的所有值。例如，请考虑以下声明：</p><pre class="oac_no_warn" dir="ltr">销售[ANY，2001] =销售['日本'，2000]</pre><p>该规则规定所有国家的2001年销售额等于2000年日本的销售额。维度的所有值（包括空值）均满足<code class="codeph">ANY</code>规范。您也可以使用<code class="codeph">IS</code> <code class="codeph">ANY</code>谓词指定它，如下所示：</p><pre class="oac_no_warn" dir="ltr">销售[国家是，2001年] =销售['日本'，2000]</pre></li>
                        <li>
                           <p>使用<code class="codeph">CV</code>函数访问维值</p>
                           <p>您可以使用规则右侧的<code class="codeph">CV</code>函数来访问规则左侧引用的单元格的维度列的值。它使您能够将执行类似计算的多个规则组合到单个规则中，从而实现简洁的规范。例如，您可以组合以下规则：</p><pre class="oac_no_warn" dir="ltr">销售[country ='西班牙'，年= 2002] = 1.2 *销售['西班牙'，2001]，销售[country ='意大利'，年= 2002] = 1.2 *销售['意大利'，2001]，销售[ country ='Japan'，year = 2002] = 1.2 * sales ['Japan'，2001]</pre><p>它们可以组合成一个单一的规则：</p><pre class="oac_no_warn" dir="ltr">销售[国家IN（'西班牙'，'意大利'，'日本'），年= 2002] = 1.2 *销售[CV（国家），2001]</pre><p>观察<code class="codeph">CV</code>函数从规则的左侧到右侧传递<code class="codeph">country</code>维度的值。
                           </p>
                        </li>
                        <li>
                           <p>有序计算</p>
                           <p>对于更新一组单元格的规则，结果可能取决于维度值的排序。您可以通过在规则中指定<code class="codeph">ORDER</code> <code class="codeph">BY</code>来强制维度值的特定顺序。一个例子是以下规则：</p><pre class="oac_no_warn" dir="ltr">销售[国家是任何，2000年和2003年之间的年份]按年份排序= 1.05 *销售额[简历（国家），简历（年）-1]</pre><p>这确保了按年代顺序增加参考年份。</p>
                        </li>
                        <li>
                           <p>自动规则排序</p>
                           <p>可以使用<code class="codeph">AUTOMATIC</code> <code class="codeph">ORDER</code>关键字根据单元格之间的依赖关系自动排序<code class="codeph">MODEL</code>子句中的规则。例如，在以下分配中，最后两个规则将在第一个规则之前处理，因为第一个规则取决于第二个和第三个规则：</p><pre class="oac_no_warn" dir="ltr">规则自动订单{sales [c ='Spain'，y = 2001] = sales [c ='Spain'，y = 2000] + sales [c ='Spain'，y = 1999] sales [c ='Spain'， y = 2000] = 50000，销售[c ='西班牙'，y = 1999] = 40000}</pre></li>
                        <li>
                           <p>迭代规则评估</p>
                           <p>您可以指定迭代规则评估，在这种情况下，迭代地评估规则，直到满足终止条件。请考虑以下规范：</p><pre class="oac_no_warn" dir="ltr">模型维数（x）措施ITERATE（4）（s [x = 1] = s [x = 1] / 2）</pre><p>该陈述规定公式<code class="codeph">s[x=1] = s[x=1]/2</code>评估重复四次。迭代次数在<code class="codeph">MODEL</code>子句的<code class="codeph">ITERATE</code>选项中指定。也可以使用<code class="codeph">UNTIL</code>子句指定终止条件。
                           </p>
                           <p>迭代规则评估是用于对业务应用程序中的实体之间的递归关系建模的重要工具。例如，贷款金额可能取决于利率，而利率又取决于贷款金额。</p>
                        </li>
                        <li>
                           <p>参考模型</p>
                           <p>模型可以包括多个ref模型，它们是只读数组。规则可以引用来自不同参考模型的单元格规则只能在一个多维数组中更新或插入单元格，这个数组称为主模型。使用参考模型可以使模型与不同的维度相关联。例如，假设除了事实表<code class="codeph">ft(country, year, sales)</code> ，您还有一个表格，其中货币转换<code class="codeph">cr(country, ratio)</code> ， <code class="codeph">country</code>为维度列， <code class="codeph">ratio</code>为度量。此表中的每一行都给出了该国家货币与美元货币的转换比率。这两个表可用于以下规则：</p><pre class="oac_no_warn" dir="ltr">dollar_sales ['Spain'，2001] = sales ['Spain'，2000] * ratio ['Spain']</pre></li>
                        <li>
                           <p>可扩展计算</p>
                           <p>您可以独立于其他分区对每个分区内的数据进行分区和评估规则。这使得能够基于分区并行化模型计算。例如，请考虑以下模型：</p><pre class="oac_no_warn" dir="ltr">模型分区（国家）维度（年）措施（销售额）（销售额[年= 2001年] = AVG（销售额）[1990年和2000年之间的年份]</pre><p>数据按国家/地区划分，在每个分区中，您可以将2001年的销售额计算为1990年至2000年间销售额的平均值。可以并行处理分区，这样可以实现模型的可伸缩执行。</p>
                        </li>
                     </ul>
                  </div>
               </div>
            </div><a id="DWHSG8762"></a><div class="props_rev_3"><a id="GUID-54154720-DA60-4DBA-A94C-AE5ECD8B2BBF" name="GUID-54154720-DA60-4DBA-A94C-AE5ECD8B2BBF"></a><h3 id="DWHSG-GUID-54154720-DA60-4DBA-A94C-AE5ECD8B2BBF" class="sect3"><span class="enumeration_section">22.2</span> SQL建模的基本主题</h3>
               <div>
                  <p>本节介绍模型的一些基本概念和用法，包括：</p>
                  <ul style="list-style-type:disc">
                     <li>
                        <p><a href="sql-modeling-data-warehouses.html#GUID-C5C34EFE-B74C-45BA-8D4B-71E527F858F7">SQL建模示例的基本模式</a></p>
                     </li>
                     <li>
                        <p><a href="sql-modeling-data-warehouses.html#GUID-562DD586-2629-4890-89FF-DC2D693C10FF">MODEL子句语法</a></p>
                     </li>
                     <li>
                        <p><a href="sql-modeling-data-warehouses.html#GUID-5630AA95-81F0-4EF7-A3E8-6864155C854B">SQL建模中的关键字</a></p>
                     </li>
                     <li>
                        <p><a href="sql-modeling-data-warehouses.html#GUID-9ACD704F-0428-4F49-BF96-47486713E97E">关于SQL建模中的单元格引用</a></p>
                     </li>
                     <li>
                        <p><a href="sql-modeling-data-warehouses.html#GUID-AFD52CDE-F700-4850-ABB1-DFF0DD4961A9">关于SQL建模规则</a></p>
                     </li>
                     <li>
                        <p><a href="sql-modeling-data-warehouses.html#GUID-3DF6A3A2-1A15-4B4C-BD44-1EC2491A5181">SQL建模规则的评估顺序</a></p>
                     </li>
                     <li>
                        <p><a href="sql-modeling-data-warehouses.html#GUID-E23B515C-A552-40EA-B9D1-BB76AE843663">SQL建模规则的全局和本地关键字</a></p>
                     </li>
                     <li>
                        <p><a href="sql-modeling-data-warehouses.html#GUID-72373EAD-7ADD-4E4E-93BE-AB16FD2C5EC1">UPDATE，UPSERT和UPSERT ALL行为</a></p>
                     </li>
                     <li>
                        <p><a href="sql-modeling-data-warehouses.html#GUID-921A7D68-3982-460E-A0FC-AD50954710D3">在SQL建模中处理NULL和缺少单元格</a></p>
                     </li>
                     <li>
                        <p><a href="sql-modeling-data-warehouses.html#GUID-3715019F-674C-4CFA-BEAE-08F4C5757596">关于SQL建模中的参考模型</a></p>
                     </li>
                  </ul>
               </div><a id="DWHSG8763"></a><div class="props_rev_3"><a id="GUID-C5C34EFE-B74C-45BA-8D4B-71E527F858F7" name="GUID-C5C34EFE-B74C-45BA-8D4B-71E527F858F7"></a><h4 id="DWHSG-GUID-C5C34EFE-B74C-45BA-8D4B-71E527F858F7" class="sect4"><span class="enumeration_section">22.2.1</span> SQL建模示例的基本模式</h4>
                  <div>
                     <p>本章的示例基于以下视图<code class="codeph">sales_view</code> ，该视图派生自<code class="codeph">sh</code>示例模式。
                     </p><pre class="oac_no_warn" dir="ltr">CREATE VIEW sales_view AS SELECT country_name country，prod_name product，calendar_year year，SUM（amount_sold）sales，COUNT（amount_sold）cnt，MAX（calendar_year）KEEP（DENSE_RANK FIRST ORDER BY SUM（amount_sold）DESC）OVER（PARTITION BY country_name，prod_name） best_year，MAX（calendar_year）KEEP（DENSE_RANK最后订单按SUM（amount_sold）DESC）OVER（PARTITION BY country_name，prod_name）worst_year FROM sales，times，customers，countries，products WHERE sales.time_id = times.time_id AND sales.prod_id = products.prod_id AND sales.cust_id = customers.cust_id AND customers.country_id = countries.country_id GROUP BY country_name，prod_name，calendar_year;</pre><p>此查询计算按国家/地区，产品和年份分组的销售数据的<code class="codeph">SUM</code>和<code class="codeph">COUNT</code>聚合。它将报告在一个国家/地区销售的每种产品，即该国家/地区销售额最高的那一年。这被称为产品的<code class="codeph">best_year</code> 。同样， <code class="codeph">worst_year</code>给出了销售额最低的年份。</p>
                  </div>
               </div><a id="DWHSG8765"></a><a id="DWHSG8764"></a><div class="props_rev_3"><a id="GUID-562DD586-2629-4890-89FF-DC2D693C10FF" name="GUID-562DD586-2629-4890-89FF-DC2D693C10FF"></a><h4 id="DWHSG-GUID-562DD586-2629-4890-89FF-DC2D693C10FF" class="sect4"><span class="enumeration_section">22.2.2</span>模型子句语法</h4>
                  <div>
                     <div class="section">
                        <p><code class="codeph">MODEL</code>子句使您可以在SQL查询块中定义数据的多维计算。在多维应用程序中，事实表由唯一标识行的列组成，其余列用作依赖度量或属性。<code class="codeph">MODEL</code>子句允许您指定定义多维数组的<code class="codeph">PARTITION</code> ， <code class="codeph">DIMENSION</code>和<code class="codeph">MEASURE</code>列，对此多维数组进行操作的规则以及处理选项。
                        </p>
                        <p><code class="codeph">MODEL</code>子句包含表示分区内数组计算的更新列表，并且是SQL查询块的一部分。其结构如下：</p><pre class="oac_no_warn" dir="ltr">MODEL [&lt;global reference options&gt;] [&lt;reference models&gt;] [MAIN &lt;main-name&gt;] [PARTITION BY（&lt;cols&gt;）] DIMENSION BY（&lt;cols&gt;）MEASURES（&lt;cols&gt;）[&lt;reference options&gt;] [规则] &lt;规则选项&gt;（&lt;规则&gt;，&lt;规则&gt;，..，&lt;规则&gt;）&lt;全局参考选项&gt; :: = &lt;参考选项&gt; &lt;ret-opt&gt; &lt;ret-opt&gt; :: = RETURN { ALL | UPDATED} ROWS &lt;reference options&gt; :: = [IGNORE NAV | [KEEP NAV] [独特的尺寸| UNIQUE SINGLE REFERENCE] &lt;rule options&gt; :: = [UPDATE | UPSERT | UPSERT ALL] [自动订购|顺序排序] [ITERATE（&lt;number&gt;）[UNTIL &lt;condition&gt;]] &lt;reference models&gt; :: = REFERENCE ON &lt;ref-name&gt; ON（&lt;query&gt;）DIMENSION BY（&lt;cols&gt;）MEASURES（&lt;cols&gt;） &lt;参考选项&gt;</pre><p>每条规则代表一项任务。其左侧引用一个细胞或一组细胞，右侧可以包含涉及常数，宿主变量，单个细胞或整个细胞范围的聚集体的表达。例如，考虑<a href="sql-modeling-data-warehouses.html#GUID-562DD586-2629-4890-89FF-DC2D693C10FF__i1019340">示例22-1中</a>的查询，这是基于根据<a href="sql-modeling-data-warehouses.html#GUID-C5C34EFE-B74C-45BA-8D4B-71E527F858F7">SQL建模示例的基本架构中</a>所述创建的视图<code class="codeph">sales_view</code> 。
                        </p>
                     </div>
                     <!-- class="section" -->
                     <div class="example" id="GUID-562DD586-2629-4890-89FF-DC2D693C10FF__i1019340">
                        <p class="titleinexample">例22-1使用MODEL子句的简单查询</p><pre class="oac_no_warn" dir="ltr">SELECT SUBSTR（国家，1,20）国家，SUBSTR（产品，1,15）产品，年份，销售额FROM sales_view国家/地区（'意大利'，'日本'）模型返回更新行MAIN simple_model PARTITION BY（country）DIMENSION BY（产品，年份）MEASURES（销售）规则（销售['Bounce'，2001] = 1000，销售['Bounce'，2002] =销售['Bounce'，2001] +销售['Bounce'，2000]， sales ['Y Box'，2002] = sales ['Y Box'，2001]）按国家，产品，年份排序;</pre><p>此查询定义来自意大利和日本国家/地区的<code class="codeph">sales_view</code>行的模型计算。该模型的名称为<code class="codeph">simple_model</code> 。它对国家/地区的数据进行分区，并在每个分区中定义产品和年份的二维数组。此数组中的每个单元格都包含销售度量的值。该模型的第一条规则将2001年Bounce的销售额设定为1000。接下来的两条规则定义2002年Bounce的销售额是2001年和2000年的销售额之和，2002年Y Box的销售额与2001年的相同。
                        </p>
                        <p>指定<code class="codeph">RETURN</code> <code class="codeph">UPDATED</code> <code class="codeph">ROWS</code>使前面的查询仅返回由模型计算更新或插入的那些行。默认情况下或者如果使用<code class="codeph">RETURN</code> <code class="codeph">ALL</code> <code class="codeph">ROWS</code> ，您将获得所有行，而不仅仅是<code class="codeph">MODEL</code>子句更新或插入的行。该查询生成以下输出：</p><pre class="oac_no_warn" dir="ltr">国家产品年销售额-------------------- --------------- ----------  - ---------意大利弹跳2001 1000意大利弹跳2002 5333.69意大利Y Box 2002 81207.55日本弹跳2001 1000日本弹跳2002 6133。53日本Y Box 2002 89634.83</pre><p>请注意， <code class="codeph">MODEL</code>子句不会更新行或将行插入数据库表。以下查询通过显示<code class="codeph">sales_view</code>尚未更改来说明此情况：</p><pre class="oac_no_warn" dir="ltr">SELECT SUBSTR（国家，1,20）国家，SUBSTR（产品，1,15）产品，年份，销售额FROM sales_view国家IN（'意大利'，'日本'）;国家产品年销售额-------------------- --------------- ----------  - ---------意大利弹跳1999 2474.78意大利弹跳2000 4333.69意大利弹跳2001 4846.3 ......
</pre><p>请注意，此<code class="codeph">MODEL</code>子句在2001年完成的Bounce销售价值的更新未反映在数据库中。如果要在数据库表中更新或插入行，则应使用<code class="codeph">INSERT</code> ， <code class="codeph">UPDATE</code>或<code class="codeph">MERGE</code>语句。
                        </p>
                        <p>在前面的示例中，列在<code class="codeph">PARTITION</code> <code class="codeph">BY</code> ， <code class="codeph">DIMENSION</code> <code class="codeph">BY</code>和<code class="codeph">MEASURES</code>列表中指定。您还可以将常量，主机变量，单行函数，聚合函数，分析函数或涉及它们的表达式指定为分区和维度键和度量。但是，您必须在<code class="codeph">PARTITION</code> <code class="codeph">BY</code> ， <code class="codeph">DIMENSION</code> <code class="codeph">BY</code>和<code class="codeph">MEASURES</code>列表中对它们进行别名。必须使用别名在规则， <code class="codeph">SELECT</code>列表和查询<code class="codeph">ORDER</code> <code class="codeph">BY</code>引用这些表达式。以下示例显示如何使用表达式和别名：</p><pre class="oac_no_warn" dir="ltr">SELECT国家，p产品，年份，销售额，利润来自sales_view国家IN（'意大利'，'日本'）模型返回更新行分区（SUBSTR（国家，1,20）AS国家）DIMENSION BY（产品AS p，年度）措施（销售额，0 AS利润）规则（利润['Bounce'，2001] =销售['Bounce'，2001] * 0.25，销售['Bounce'，2002] =销售['Bounce'，2001] + sales ['Bounce'，2000]，profit ['Bounce'，2002] = sales ['Bounce'，2002] * 0.35）ORDER BY country，year;国家产品年销售利润------- --------- ---- -------- --------意大利弹跳2001 4846.3 1211.575意大利弹跳2002 9179.99 3212。9965日本弹跳2001 6303.6 1575。9日本弹跳2002 11437.13 4002.9955</pre></div>
                     <!-- class="example" -->
                     <div class="section">
                        <p>请注意，别名“0 AS profit”会将利润度量的所有单元格初始化为0。有关<code class="codeph">MODEL</code>子句语法的更多信息，请参见<a href="../sqlrf/SELECT.html#SQLRF55254" target="_blank"><span class="italic">Oracle数据库SQL语言参考</span></a> 。
                        </p>
                     </div>
                     <!-- class="section" -->
                  </div>
               </div><a id="DWHSG0221"></a><div class="props_rev_3"><a id="GUID-5630AA95-81F0-4EF7-A3E8-6864155C854B" name="GUID-5630AA95-81F0-4EF7-A3E8-6864155C854B"></a><h4 id="DWHSG-GUID-5630AA95-81F0-4EF7-A3E8-6864155C854B" class="sect4"><span class="enumeration_section">22.2.3</span> SQL建模中的关键字</h4>
                  <div>
                     <p>本节定义<a id="d90648e833" class="indexterm-anchor"></a><a id="d90648e837" class="indexterm-anchor"></a> SQL建模中使用的关键字。它包含以下主题：</p>
                     <ul style="list-style-type:disc">
                        <li>
                           <p><a href="sql-modeling-data-warehouses.html#GUID-24DB1AB7-9372-459F-B890-E43BA60B8A68">分配值和空值处理</a></p>
                        </li>
                        <li>
                           <p><a href="sql-modeling-data-warehouses.html#GUID-B0AC5C14-53EB-4A7E-B37D-54C87C56909F">计算定义</a></p>
                        </li>
                     </ul>
                  </div><a id="DWHSG8766"></a><div class="props_rev_3"><a id="GUID-24DB1AB7-9372-459F-B890-E43BA60B8A68" name="GUID-24DB1AB7-9372-459F-B890-E43BA60B8A68"></a><h5 id="DWHSG-GUID-24DB1AB7-9372-459F-B890-E43BA60B8A68" class="sect5"><span class="enumeration_section">22.2.3.1</span>赋值和空处理</h5>
                     <div>
                        <ul style="list-style-type:disc">
                           <li>
                              <p><code class="codeph">UPSERT</code></p>
                              <p>这会更新现有单元格的度量值。如果单元格不存在，并且规则具有适当的表示法，则插入它们。如果任何单元格引用是符号，则不插入单元格。</p>
                           </li>
                           <li>
                              <p><code class="codeph">UPSERT</code> <code class="codeph">ALL</code></p>
                              <p>这类似于<code class="codeph">UPSERT</code> ，除了它允许更广泛的规则符号插入新单元格。
                              </p>
                           </li>
                           <li>
                              <p><code class="codeph">UPDATE</code></p>
                              <p>这会更新现有单元格值。如果单元格值不存在，则不进行更新。</p>
                           </li>
                           <li>
                              <p><code class="codeph">IGNORE</code> <code class="codeph">NAV</code></p>
                              <p>对于数字单元格，这会将不可用的值视为0。这意味着查询结果集未提供给<code class="codeph">MODEL</code>的单元格将被视为计算的零。这可以在全局级别用于模型中的所有度量。
                              </p>
                           </li>
                           <li>
                              <p><code class="codeph">KEEP</code> <code class="codeph">NAV</code></p>
                              <p>这样可以保持不可用的单元格值不变。当在全局级别指定<code class="codeph">IGNORE</code> <code class="codeph">NAV</code>时，它可用于进行异常。这是默认值，可以省略。
                              </p>
                           </li>
                        </ul>
                     </div>
                  </div><a id="DWHSG8767"></a><div class="props_rev_3"><a id="GUID-B0AC5C14-53EB-4A7E-B37D-54C87C56909F" name="GUID-B0AC5C14-53EB-4A7E-B37D-54C87C56909F"></a><h5 id="DWHSG-GUID-B0AC5C14-53EB-4A7E-B37D-54C87C56909F" class="sect5"><span class="enumeration_section">22.2.3.2</span>计算定义</h5>
                     <div>
                        <div class="section">
                           <ul style="list-style-type:disc">
                              <li>
                                 <p><code class="codeph">措施</code></p>
                                 <p>由模型修改或创建的值集。</p>
                              </li>
                              <li>
                                 <p><code class="codeph">规则</code></p>
                                 <p>为度量指定值的表达式。</p>
                              </li>
                              <li>
                                 <p><code class="codeph">AUTOMATIC</code> <code class="codeph">ORDER</code></p>
                                 <p>这会导致所有规则根据其逻辑依赖性按顺序进行评估。</p>
                              </li>
                              <li>
                                 <p><code class="codeph">SEQUENTIAL</code> <code class="codeph">ORDER</code></p>
                                 <p>这会导致规则按写入顺序进行评估。这是默认值。</p>
                              </li>
                              <li>
                                 <p><code class="codeph">UNIQUE</code> <code class="codeph">DIMENSION</code></p>
                                 <p>这是默认值，这意味着<code class="codeph">MODEL</code>子句中<code class="codeph">PARTITION</code> <code class="codeph">BY</code>和<code class="codeph">DIMENSION</code> <code class="codeph">BY</code>列的组合必须唯一地标识模型中的每个单元格。必要时在查询执行时明确验证此唯一性，在这种情况下，它可能会增加处理时间。
                                 </p>
                              </li>
                              <li>
                                 <p><code class="codeph">UNIQUE</code> <code class="codeph">SINGLE</code> <code class="codeph">REFERENCE</code></p>
                                 <p><code class="codeph">PARTITION</code> <code class="codeph">BY</code>和<code class="codeph">DIMENSION</code> <code class="codeph">BY</code>子句唯一标识规则右侧的单点引用。这可以通过避免在查询执行时对唯一性的显式检查来减少处理时间。
                                 </p>
                              </li>
                              <li>
                                 <p><code class="codeph">RETURN</code> <code class="codeph">[ALL|UPDATED] ROWS</code></p>
                                 <p>这使您可以指定是返回所有选定的行还是仅返回规则更新的那些行。默认值为<code class="codeph">ALL</code> ，而替代方案是<code class="codeph">UPDATED</code> <code class="codeph">ROWS</code> 。</p>
                              </li>
                           </ul>
                        </div>
                        <!-- class="section" -->
                     </div>
                  </div>
               </div><a id="DWHSG8768"></a><div class="props_rev_3"><a id="GUID-9ACD704F-0428-4F49-BF96-47486713E97E" name="GUID-9ACD704F-0428-4F49-BF96-47486713E97E"></a><h4 id="DWHSG-GUID-9ACD704F-0428-4F49-BF96-47486713E97E" class="sect4"><span class="enumeration_section">22.2.4</span>关于SQL建模中的单元格引用</h4>
                  <div>
                     <p>在<a id="d90648e1065" class="indexterm-anchor"></a><a id="d90648e1067" class="indexterm-anchor"></a><a id="d90648e1071" class="indexterm-anchor"></a>在<code class="codeph">MODEL</code>子句中，关系被视为多维的单元格数组。此多维数组的单元格包含度量值，并在<code class="codeph">PARTITION</code> <code class="codeph">BY</code>键定义的每个分区内使用<code class="codeph">DIMENSION</code> <code class="codeph">BY</code>键进行索引。例如，请考虑在如<a href="sql-modeling-data-warehouses.html#GUID-C5C34EFE-B74C-45BA-8D4B-71E527F858F7">SQL架构示例的基本架构中</a>所述创建的视图<code class="codeph">sales_view</code>上运行以下查询：</p><pre class="oac_no_warn" dir="ltr">SELECT country，product，year，sales，best_year，best_year FROM sales_view MODEL PARTITION BY（country）DIMENSION BY（product，year）MEASURES（sales，best_year）（&lt;rules&gt; ..）按国家，产品，年份订购;</pre><p>这按国家/地区划分数据，并在每个分区内定义产品和年份的二维数组。此数组的单元格包含两个度量： <code class="codeph">sales</code>和<code class="codeph">best_year</code> 。
                     </p>
                     <p>通过指定<code class="codeph">DIMENSION</code> <code class="codeph">BY</code>键来访问单元格的度量值构成单元格引用。单元格引用的示例如下：</p><pre class="oac_no_warn" dir="ltr">销售[product ='Bounce'，年份= 2000]</pre><p>在这里，您将访问产品Bounce和2000年引用的单元格的销售值。在单元格引用中，您可以象征性地在前一个单元格引用中指定<code class="codeph">DIMENSION</code> <code class="codeph">BY</code>键，也可以在<code class="codeph">sales['Bounce', 2000]</code>按位置指定<code class="codeph">DIMENSION</code> <code class="codeph">BY</code>键。
                     </p>
                     <p>本节包含以下主题：</p>
                     <ul style="list-style-type:disc">
                        <li>
                           <p><a href="sql-modeling-data-warehouses.html#GUID-8EFA312C-6057-4D2C-9165-7992DE5F469D">符号尺寸参考</a></p>
                        </li>
                        <li>
                           <p><a href="sql-modeling-data-warehouses.html#GUID-2561D678-6DBB-4EDA-921A-9FB1D85923E0">位置尺寸参考</a></p>
                        </li>
                     </ul>
                  </div><a id="DWHSG8769"></a><div class="props_rev_3"><a id="GUID-8EFA312C-6057-4D2C-9165-7992DE5F469D" name="GUID-8EFA312C-6057-4D2C-9165-7992DE5F469D"></a><h5 id="DWHSG-GUID-8EFA312C-6057-4D2C-9165-7992DE5F469D" class="sect5"><span class="enumeration_section">22.2.4.1</span>符号尺寸参考</h5>
                     <div>
                        <p>符号维度引用（或符号引用）是使用布尔表达式指定<code class="codeph">DIMENSION</code> <code class="codeph">BY</code>键值的引用。例如，单元格引用<code class="codeph">sales[year &gt;= 2001]</code>在<code class="codeph">DIMENSION</code> <code class="codeph">BY</code>关键年份具有符号引用，并指定年份值大于或等于2001的所有单元格。产品和年份维度的符号引用示例是<code class="codeph">sales[product = 'Bounce', year &gt;= 2001]</code> 。
                        </p>
                     </div>
                  </div><a id="DWHSG8770"></a><div class="props_rev_3"><a id="GUID-2561D678-6DBB-4EDA-921A-9FB1D85923E0" name="GUID-2561D678-6DBB-4EDA-921A-9FB1D85923E0"></a><h5 id="DWHSG-GUID-2561D678-6DBB-4EDA-921A-9FB1D85923E0" class="sect5"><span class="enumeration_section">22.2.4.2</span>位置尺寸参考</h5>
                     <div>
                        <p>位置维度引用（或位置引用，简称）是为维度指定的常量或常量表达式。例如，单元格引用<code class="codeph">sales['Bounce']</code>具有产品维度的位置参考，并访问产品Bounce的销售值。单元格引用中的常量（或常量表达式）与为<code class="codeph">DIMENSION</code> <code class="codeph">BY</code>键指定的列顺序匹配。以下示例显示了维度上位置引用的用法：</p><pre class="oac_no_warn" dir="ltr">销售['Bounce'，2001]</pre><p>假设<code class="codeph">DIMENSION</code> <code class="codeph">BY</code>键是该订单中的产品和年份，它将访问Bounce和2001的销售值。
                        </p>
                        <p>根据它们的指定方式，单元格引用可以是单个单元格，也可以是多单元格引用。</p>
                     </div>
                  </div>
               </div><a id="DWHSG8771"></a><div class="props_rev_3"><a id="GUID-AFD52CDE-F700-4850-ABB1-DFF0DD4961A9" name="GUID-AFD52CDE-F700-4850-ABB1-DFF0DD4961A9"></a><h4 id="DWHSG-GUID-AFD52CDE-F700-4850-ABB1-DFF0DD4961A9" class="sect4"><span class="enumeration_section">22.2.5</span>关于SQL建模规则</h4>
                  <div>
                     <p>模型计算表示在操纵由<code class="codeph">PARTITION</code> <code class="codeph">BY</code> ， <code class="codeph">DIMENSION</code> <code class="codeph">BY</code>和<code class="codeph">MEASURES</code>子句定义的多维数组的单元格的规则中。规则是赋值语句，其左侧表示单元格或一系列单元格，其右侧是涉及常量，绑定变量，单个单元格或一系列单元格上的聚合函数的表达式。规则可以使用通配符和循环结构来获得最大的表现力。规则的示例如下：</p><pre class="oac_no_warn" dir="ltr">销售['Bounce'，2003] = 1.2 *销售['Bounce'，2002]</pre><p>该规则表明，对于产品Bounce，2003年的销售额比2002年增加了20％。</p>
                     <p>请注意，此规则指的是左侧和右侧的单个单元格，并且相对简单。可以使用多单元格引用，聚合和嵌套单元格引用来编写复杂规则。</p>
                     <div class="section">
                        <p class="subhead3" id="GUID-AFD52CDE-F700-4850-ABB1-DFF0DD4961A9__GUID-9904F367-8805-42F3-A186-9F3A19B31E35">单细胞参考</p>
                        <p>这种类型的规则涉及左侧的单个单元格引用，右侧是常量和单个单元格引用。一些例子如下：</p><pre class="oac_no_warn" dir="ltr">sales [product ='Finding Fido'，year = 2003] = 100000 sales ['Bounce'，2003] = 1.2 * sales ['Bounce'，2002] sales [product ='Finding Fido'，year = 2004] = 0.8 *销售['标准鼠标垫'，年= 2003] +销售['寻找Fido'，2003]</pre></div>
                     <!-- class="section" -->
                     <div class="section">
                        <p class="subhead3" id="GUID-AFD52CDE-F700-4850-ABB1-DFF0DD4961A9__GUID-775B96EC-1BD4-403F-BA70-0C90E7A9B9CE">右侧的多单元引用</p>
                        <p>可以在规则的右侧使用多单元格引用，在这种情况下，需要对它们应用聚合函数以将它们转换为单个值。可以使用所有现有的聚合函数，包括分析聚合（逆百分位函数，假设的秩和分布函数等）和统计聚合（相关性，回归斜率等）和用户定义的聚合函数。也可以使用诸如<code class="codeph">RANK</code>和<code class="codeph">MOVING_AVG</code>类的窗口函数。例如，计算2003年Bounce的销售额比1998年至2002年期间的最大销售额多100的规则将是：</p><pre class="oac_no_warn" dir="ltr">销售['Bounce'，2003] = 100 + MAX（销售额）['Bounce'，1998年和2002年之间的年份]</pre><p>以下示例说明了反百分位函数<code class="codeph">PERCENTILE_DISC</code>的用法。该项目预计2003年的Fido销售额将比2003年之前所有年份的Finding Fido，Standard Mouse Pad和Boat产品的中位数销售额高出30％。
                        </p><pre class="oac_no_warn" dir="ltr">销售[product ='Finding Fido'，year = 2003] = 1.3 * PERCENTILE_DISC（0.5）WITHIN GROUP（按销售排序）[产品IN（'寻找Fido'，'标准鼠标垫'，'船'），年份&lt;2003 ]</pre><p>聚合函数只能出现在规则的右侧。聚合函数的参数可以是常量，绑定变量， <code class="codeph">MODEL</code>子句的度量或涉及它们的表达式。例如，该规则计算2003年Bounce的销售额为1998年至2002年间销售额的加权平均值：</p><pre class="oac_no_warn" dir="ltr">销售['Bounce'，2003] = AVG（销售*重量）['Bounce'，1998年和2002年之间的年份]</pre></div>
                     <!-- class="section" -->
                     <div class="section">
                        <p class="subhead3" id="GUID-AFD52CDE-F700-4850-ABB1-DFF0DD4961A9__GUID-48BADB7D-56FE-4641-965A-479E84079982">左侧的多单元格参考</p>
                        <p>规则可以在左侧包含多单元格引用，如下所示：</p><pre class="oac_no_warn" dir="ltr">销售['标准鼠标垫'，年&gt; 2000] = 0.2 *销售['寻找Fido'，年= 2000]</pre><p>此规则访问左侧的一系列单元格（产品标准鼠标垫的单元格，年份大于2000），并将每个此类单元格的销售度量分配给右侧表达式计算的值。按照上述规则进行的计算被描述为“2000年后标准鼠标垫的销售额是2000年Finding Fido销售额的20％”。这种计算很简单，因为右侧单元格引用，因此右侧表达式对于左侧引用的所有单元格是相同的。</p>
                     </div>
                     <!-- class="section" -->
                     <div class="section">
                        <p class="subhead3" id="GUID-AFD52CDE-F700-4850-ABB1-DFF0DD4961A9__GUID-E88F99EC-1294-416B-8AF2-20E253853A7C">使用CV函数</p>
                        <p><code class="codeph">CV</code>函数的使用提供了相对索引的能力，其中左侧引用的单元的维值在右侧单元引用上使用。<code class="codeph">CV</code>函数将维度键作为其参数，因此它提供左侧当前引用的单元格的<code class="codeph">DIMENSION</code> <code class="codeph">BY</code>键的值。例如，请考虑以下事项：</p><pre class="oac_no_warn" dir="ltr">销售[product ='标准鼠标垫'，年&gt; 2000] =销售[CV（产品），CV（年）] + 0.2 *销售['Finding Fido'，2000]</pre><p>当左侧引用单元格标准鼠标垫和2001时，右侧表达式将是：</p><pre class="oac_no_warn" dir="ltr">销售['标准鼠标垫'，2001] + 0.2 *销售['Finding Fido'，2000]</pre><p>类似地，当左侧引用单元格标准鼠标垫和2002时，您将评估的右侧表达式是：</p><pre class="oac_no_warn" dir="ltr">销售['标准鼠标垫'，2002] + 0.2 *销售['Finding Fido'，2000]</pre><p>另外，也可以使用<code class="codeph">CV</code>没有任何参数作为在<code class="codeph">CV()</code>和在这种情况下，暗示了位置引用。<code class="codeph">CV()</code>可以在单元格引用之外使用，但是当以这种方式使用时，其参数必须包含所需维度的名称。您还可以将前面的规则写为：</p><pre class="oac_no_warn" dir="ltr">销售[product ='标准鼠标垫'，年&gt; 2000] =销售[CV（），CV（）] + 0.2 *销售['Finding Fido'，2000]</pre><p>第一个<code class="codeph">CV()</code>参考对应<code class="codeph">CV(product)</code> ，后者对应<code class="codeph">CV(year)</code> 。<code class="codeph">CV</code>函数只能用于右侧单元格引用。另一个使用<code class="codeph">CV</code>函数的例子如下：</p><pre class="oac_no_warn" dir="ltr">销售[产品IN（'寻找Fido'，'标准鼠标垫'，'弹跳'），2002年和2004年之间的年份] = 2 *销售[CV（产品），CV（年）-10]</pre><p>这条规则说，对于Finding Fido，Standard Mouse Pad和Bounce等产品，2002年至2004年间的销售额将是10年前销售额的两倍。</p>
                     </div>
                     <!-- class="section" -->
                     <div class="section">
                        <p class="subhead3" id="GUID-AFD52CDE-F700-4850-ABB1-DFF0DD4961A9__GUID-5B68F18B-B873-4FF0-9107-EB0D4B1EED6C">使用ANY通配符</p>
                        <p>您可以在单元格引用中使用通配符<code class="codeph">ANY</code>来匹配所有维度值，包括空值。<code class="codeph">ANY</code>可以在规则的左侧和右侧使用。例如，计算“2003年所有产品的销售额比2002年的销售额增加10％”的规则如下：</p><pre class="oac_no_warn" dir="ltr">销售[产品IS ANY，2003] = 1.1 *销售[CV（产品），2002]</pre><p>使用位置引用，它也可以写成：</p><pre class="oac_no_warn" dir="ltr">销售[ANY，2003] = 1.1 *销售[CV（），2002]</pre><p>请注意，即使在位置上指定了<code class="codeph">ANY</code>也将其视为符号引用，因为它实际上意味着（ <code class="codeph">dimension IS NOT NULL OR dimension IS NULL</code> ）。
                        </p>
                     </div>
                     <!-- class="section" -->
                     <div class="section">
                        <p class="subhead3" id="GUID-AFD52CDE-F700-4850-ABB1-DFF0DD4961A9__GUID-9372BE77-A412-401A-A7B0-40707153CE17">嵌套单元格引用</p>
                        <p>单元格引用可以嵌套。换句话说，提供维度值的单元格引用可以在单元格引用中使用。假设<code class="codeph">best_year</code>是一个度量，嵌套单元格引用的示例如下：</p><pre class="oac_no_warn" dir="ltr">销售[product ='Bounce'，年= best_year ['Bounce'，2003]]</pre><p>这里，嵌套的单元格引用<code class="codeph">best_year['Bounce', 2003]</code>提供维度关键年份的值，并在年份的符号引用中使用。对于每年（ <code class="codeph">y</code> ）和产品（ <code class="codeph">p</code> ）组合，产品<code class="codeph">p</code>销售最高或最低的年份， <code class="codeph">best_year</code>和<code class="codeph">worst_year</code>给出的度量。以下规则计算2003年标准鼠标垫的销售额是Finding Fido销售额最高和最低年份的标准鼠标垫销售额的平均值：</p><pre class="oac_no_warn" dir="ltr">销售['标准鼠标垫'，2003] =（销售[CV（），best_year ['寻找Fido'，CV（年）]] +销售[CV（），worst_year ['寻找Fido'，CV（年）] ]）/ 2</pre><p>Oracle数据库只允许一个级别的嵌套，并且只有单个单元格引用可以用作嵌套单元格引用。多单元引用上的聚合不能用于嵌套单元格引用。</p>
                     </div>
                     <!-- class="section" -->
                  </div>
               </div><a id="DWHSG8778"></a><div class="props_rev_3"><a id="GUID-3DF6A3A2-1A15-4B4C-BD44-1EC2491A5181" name="GUID-3DF6A3A2-1A15-4B4C-BD44-1EC2491A5181"></a><h4 id="DWHSG-GUID-3DF6A3A2-1A15-4B4C-BD44-1EC2491A5181" class="sect4"><span class="enumeration_section">22.2.6</span> SQL建模规则的评估顺序</h4>
                  <div>
                     <p>通过defau lt，规则按照它们在<code class="codeph">MODEL</code>子句中出现的顺序进行评估。您可以在<code class="codeph">MODEL</code>子句中指定可选关键字<code class="codeph">SEQUENTIAL</code> <code class="codeph">ORDER</code> ，以使此类评估顺序显式。具有顺序规则评估顺序的SQL模型称为顺序模型。例如，以下<code class="codeph">RULES</code>规范使Oracle数据库按指定的顺序评估规则：</p><pre class="oac_no_warn" dir="ltr">规则顺序令（销售['弹跳'，2001] =销售['弹跳'，2000] +销售['弹跳'，1999]， - 规则R1销售['弹跳'，2000] = 50000， - 规则R2销售['Bounce'，1999] = 40000） - 规则R3</pre><p>或者，选项<code class="codeph">AUTOMATIC</code> <code class="codeph">ORDER</code>使Oracle数据库能够自动确定规则评估的顺序。Oracle检查规则中的单元格引用，并查找规则之间的依赖关系。如果在规则<code class="codeph">R1</code>左侧引用的单元格在另一个规则<code class="codeph">R2</code>的右侧引用，则<code class="codeph">R2</code>被视为依赖于<code class="codeph">R1</code> 。换句话说，规则<code class="codeph">R1</code>应规则之前评估<code class="codeph">R2</code> 。如果在前面的示例中指定<code class="codeph">AUTOMATIC</code> <code class="codeph">ORDER</code> ，如下所示：</p><pre class="oac_no_warn" dir="ltr">规则自动订购（销售['Bounce'，2001] =销售['Bounce'，2000] +销售['Bounce'，1999]，销售['Bounce'，2000] = 50000，销售['Bounce'，1999] = 40000）</pre><p>在规则1之前，以某种任意顺序评估规则2和3。这是因为规则1依赖于规则2和3，因此需要在规则2和规则3之后进行评估。第二和第三规则之间的评估顺序可以是任意的，因为它们不相互依赖。规则之间彼此独立的评估顺序可以是任意的。具有自动评估顺序的SQL模型（如前面的片段中所示）称为自动订单模型。</p>
                     <p>在自动订单模型中，不允许对同一单元格进行多次分配。换句话说，细胞的测量只能分配一次。在这种情况下，Oracle数据库将返回错误，因为结果将是不确定的。例如，以下规则规范将生成错误，因为<code class="codeph">sales['Bounce', 2001]</code>被分配了多次：</p><pre class="oac_no_warn" dir="ltr">规则自动订购（销售['Bounce'，2001] =销售['Bounce'，2000] +销售['Bounce'，1999]，销售['Bounce'，2001] = 50000，销售['Bounce'，2001] = 40000）</pre><p>分配2001年产品Bounce销售的规则并不相互依赖，因此，不能在它们之间修复特定的评估顺序。这导致不确定的结果，因为评估顺序是任意的 - <code class="codeph">sales['Bounce', 2001]</code>可以是40000或50000或1999和2000年的Bounce销售总和。Oracle Database通过在指定<code class="codeph">AUTOMATIC</code> <code class="codeph">ORDER</code>时禁止多次分配来防止这种情况。但是，顺序模型中的多个赋值很好。如果在前面的示例中指定了<code class="codeph">SEQUENTIAL</code> <code class="codeph">ORDER</code>而不是<code class="codeph">AUTOMATIC</code> <code class="codeph">ORDER</code> ，则<code class="codeph">sales['Bounce', 2001]</code>将为40000。
                     </p>
                  </div>
               </div><a id="DWHSG8779"></a><div class="props_rev_3"><a id="GUID-E23B515C-A552-40EA-B9D1-BB76AE843663" name="GUID-E23B515C-A552-40EA-B9D1-BB76AE843663"></a><h4 id="DWHSG-GUID-E23B515C-A552-40EA-B9D1-BB76AE843663" class="sect4"><span class="enumeration_section">22.2.7</span> SQL建模规则的全局和本地关键字</h4>
                  <div>
                     <p>您可以在<code class="codeph">RULES</code>子句中的全局级别指定<code class="codeph">UPDATE</code> ， <code class="codeph">UPSERT</code> ， <code class="codeph">UPSERT</code> <code class="codeph">ALL</code> ， <code class="codeph">IGNORE</code> <code class="codeph">NAV</code>和<code class="codeph">KEEP</code> <code class="codeph">NAV</code>选项，在这种情况下，所有规则都在相应的模式下运行。可以在每个规则的本地级别指定这些选项，在这种情况下，它们会覆盖全局行为。例如，在以下规范中：</p><pre class="oac_no_warn" dir="ltr">规则更新（UPDATE s ['Bounce'，2001] = sales ['Bounce'，2000] + sales ['Bounce'，1999]，UPSERT s ['Y Box'，2001] = sales ['Y Box'，2000 ] + sales ['Y Box'，1999]，sales ['Mouse Pad'，2001] = sales ['Mouse Pad'，2000] + sales ['Mouse Pad'，1999]）</pre><p><code class="codeph">UPDATE</code>选项在全局级别指定，因此第一个和第三个规则在更新模式下运行。第二个规则在upsert模式下运行，因为使用该规则指定了<code class="codeph">UPSERT</code>关键字。请注意，没有为第三个规则指定任何选项，因此它从全局选项继承更新行为。
                     </p>
                  </div>
               </div><a id="DWHSG0222"></a><div class="props_rev_3"><a id="GUID-72373EAD-7ADD-4E4E-93BE-AB16FD2C5EC1" name="GUID-72373EAD-7ADD-4E4E-93BE-AB16FD2C5EC1"></a><h4 id="DWHSG-GUID-72373EAD-7ADD-4E4E-93BE-AB16FD2C5EC1" class="sect4"><span class="enumeration_section">22.2.8</span> UPDATE，UPSERT和UPSERT ALL行为</h4>
                  <div>
                     <p>您<a id="d90648e1656" class="indexterm-anchor"></a><a id="d90648e1658" class="indexterm-anchor"></a><a id="d90648e1660" class="indexterm-anchor"></a>可以通过选择是否具有<code class="codeph">UPDATE</code> ， <code class="codeph">UPSERT</code>或<code class="codeph">UPSERT</code> <code class="codeph">ALL</code>语义来确定规则中的单元格的行为方式。默认情况下， <code class="codeph">MODEL</code>子句中的规则具有<code class="codeph">UPSERT</code>语义，但您可以指定可选的<code class="codeph">UPSERT</code>关键字以使upsert语义显式化。
                     </p>
                     <p>以下部分讨论了这三种行为：</p>
                     <ul style="list-style-type:disc">
                        <li>
                           <p><a href="sql-modeling-data-warehouses.html#GUID-1CB88EBB-9104-4BEA-8D5D-171E6490D5B4">更新行为</a></p>
                        </li>
                        <li>
                           <p><a href="sql-modeling-data-warehouses.html#GUID-3C0D6796-51FA-4353-A7D3-34003D74AFBA">UPSERT行为</a></p>
                        </li>
                        <li>
                           <p><a href="sql-modeling-data-warehouses.html#GUID-DFA61603-C37A-4A2D-866F-EE1EAB8F739A">UPSERT ALL行为</a></p>
                        </li>
                     </ul>
                  </div><a id="DWHSG8780"></a><div class="props_rev_3"><a id="GUID-1CB88EBB-9104-4BEA-8D5D-171E6490D5B4" name="GUID-1CB88EBB-9104-4BEA-8D5D-171E6490D5B4"></a><h5 id="DWHSG-GUID-1CB88EBB-9104-4BEA-8D5D-171E6490D5B4" class="sect5"><span class="enumeration_section">22.2.8.1</span>更新行为</h5>
                     <div>
                        <p><code class="codeph">UPDATE</code>选项强制执行严格更新模式。在此模式下，如果在左侧引用的单元格不存在，则忽略该规则。如果存在规则左侧引用的单元格，则使用右侧表达式的值更新其度量。否则，如果单元格引用是位置的，则创建一个新单元格（即，插入到多维数组中），其度量值等于右侧表达式的值。如果单元格引用不是位置，则不会插入单元格。请注意，如果单元格规范中存在任何符号引用，则在upsert规则中无法插入。例如，请考虑以下规则：</p><pre class="oac_no_warn" dir="ltr">sales ['Bounce'，2003] = sales ['Bounce'，2001] + sales ['Bounce'，2002]</pre><p>产品Bounce和2003年的单元格（如果存在）将使用2001年和2002年的Bounce销售额的总和进行更新，否则，它将被创建。如果您使用任何符号引用创建了相同的规则，则不会执行任何更新，如下所示：</p><pre class="oac_no_warn" dir="ltr">sales [prod ='Bounce'，year = 2003] = sales ['Bounce'，2001] + sales ['Bounce'，2002]</pre></div>
                  </div><a id="DWHSG8781"></a><div class="props_rev_3"><a id="GUID-3C0D6796-51FA-4353-A7D3-34003D74AFBA" name="GUID-3C0D6796-51FA-4353-A7D3-34003D74AFBA"></a><h5 id="DWHSG-GUID-3C0D6796-51FA-4353-A7D3-34003D74AFBA" class="sect5"><span class="enumeration_section">22.2.8.2</span> UPSERT行为</h5>
                     <div>
                        <p>当单元格缺失时，使用<code class="codeph">UPSERT</code>会创建与规则左侧引用的单元格对应的新单元格，单元格引用仅包含由常量限定的位置引用。请注意，使用<code class="codeph">FOR</code>循环创建的单元格引用（在<span class="q">“ <a href="sql-modeling-data-warehouses.html#GUID-353F0903-9CD3-4BD9-A584-B31CB1FAB282">SQL建模中的高级主题</a> ”中描述</span> ）被视为位置引用，因此<code class="codeph">FOR</code>循环创建的值将用于插入新单元格。假设您的单元格数量不超过2003年，请考虑以下规则：</p><pre class="oac_no_warn" dir="ltr">UPSERT销售['Bounce'，年份= 2004] = 1.1 *销售['Bounce'，2002]</pre><p>由于符号引用年= 2004，这不会创建任何新单元格。但是，请考虑以下事项：</p><pre class="oac_no_warn" dir="ltr">UPSERT销售['Bounce'，2004] = 1.1 *销售['Bounce'，2002]</pre><p>这将为2004年的产品Bounce创建一个新单元。在相关说明中，如果任何引用为<code class="codeph">ANY</code> ，则不会创建新单元格。这是因为<code class="codeph">ANY</code>是一个谓词，它限定所有维度值，包括<code class="codeph">NULL</code> 。如果维度<code class="codeph">d</code>存在引用<code class="codeph">ANY</code> ，那么它意味着与谓词相同（ <code class="codeph">d IS NOT NULL</code> <code class="codeph">OR</code> <code class="codeph">d IS NULL)</code> 。
                        </p>
                        <p>如果<code class="codeph">UPSERT</code>规则在其左侧单元格引用中使用<code class="codeph">FOR</code>循环，则通过执行每个维度的所有不同值的叉积来生成upsert单元格列表。虽然带有<code class="codeph">FOR</code>循环的<code class="codeph">UPSERT</code>可用于增加尺寸（参见<span class="q">“ <a href="sql-analysis-reporting-data-warehouses.html#GUID-01B5DD6F-C039-4223-B017-263F7788C4FA">报告的数据</a></span>密集<span class="q">”</span> ），但通常最好使用分区外连接操作进行<span class="q"><a href="sql-analysis-reporting-data-warehouses.html#GUID-01B5DD6F-C039-4223-B017-263F7788C4FA">密度化</a></span> 。
                        </p>
                     </div>
                  </div><a id="DWHSG8782"></a><div class="props_rev_3"><a id="GUID-DFA61603-C37A-4A2D-866F-EE1EAB8F739A" name="GUID-DFA61603-C37A-4A2D-866F-EE1EAB8F739A"></a><h5 id="DWHSG-GUID-DFA61603-C37A-4A2D-866F-EE1EAB8F739A" class="sect5"><span class="enumeration_section">22.2.8.3</span> UPSERT ALL行为</h5>
                     <div>
                        <p><code class="codeph">UPSERT</code> <code class="codeph">ALL</code>行为允许模型规则在其左侧具有存在谓词（比较， <code class="codeph">IN</code> ， <code class="codeph">ANY</code>等）以具有<code class="codeph">UPSERT</code>行为。例如，以下使用<code class="codeph">ANY</code>并创建Bay Area作为旧金山，圣何塞和奥克兰的组合：</p><pre class="oac_no_warn" dir="ltr">SELECT产品，时间，城市，销售来自<span class="italic">cube_subquery</span>模型PARTITION BY（产品） <span class="italic">维度</span> （时间，城市）措施（销售规则UPSERT ALL（s [ANY，'Bay Area'] = s [CV（），'San Francisco'] + s [CV（），'San Jose'] + s [CV（），'Oakland'] s ['2004'，ANY] = s ['2002'，CV（）] + s ['2003 '， 简历（）]）;</pre><p>在该示例中，第一规则仅针对每个不同的时间值插入湾区小区，并且第二规则针对包括湾区的每个不同的城市值插入2004小区。此示例相对简单，因为左侧使用的存在谓词是<code class="codeph">ANY</code>谓词，但您也可以使用<code class="codeph">UPSERT</code> <code class="codeph">ALL</code>进行更复杂的计算。
                        </p>
                        <p>重要的是要准确理解<code class="codeph">UPSERT</code> <code class="codeph">ALL</code>操作的作用，特别是在存在多个符号维度参考的情况下。请注意，该行为与使用<code class="codeph">FOR</code>循环的<code class="codeph">UPSERT</code>规则的行为不同。
                        </p>
                        <p>在评估<code class="codeph">UPSERT</code> <code class="codeph">ALL</code>规则时，Oracle数据库执行以下步骤来创建要插入的单元格引用列表：</p>
                        <ol>
                           <li>
                              <p>找到满足单元格引用的所有符号谓词的现有单元格。</p>
                           </li>
                           <li>
                              <p>仅使用具有符号引用的维度，找到这些单元格的不同维度值组合。</p>
                           </li>
                           <li>
                              <p>使用通过位置参考指定的尺寸值执行这些值组合的叉积。</p>
                           </li>
                           <li>
                              <p>然后使用步骤3的结果将新单元嵌入阵列中。</p>
                           </li>
                        </ol>
                     </div><a id="DWHSG9413"></a><div class="props_rev_3"><a id="GUID-9968AD2C-4229-408E-B3B9-D39162EB98E5" name="GUID-9968AD2C-4229-408E-B3B9-D39162EB98E5"></a><h6 id="DWHSG-GUID-9968AD2C-4229-408E-B3B9-D39162EB98E5" class="sect6"><span class="enumeration_section">22.2.8.3.1</span>示例：UPSERT ALL行为</h6>
                        <div>
                           <p>为了说明<span class="q">“ <a href="sql-modeling-data-warehouses.html#GUID-DFA61603-C37A-4A2D-866F-EE1EAB8F739A">UPSERT ALL Behavior</a> ”中</span>描述的四个步骤，这里是一个使用抽象数据和三维模型的简短示例。考虑一个由（ <code class="codeph">product</code> ， <code class="codeph">time</code> ， <code class="codeph">city</code> ）标注的模型，其中包含一个名为<code class="codeph">sales</code>的度量。您希望为<code class="codeph">z</code>城市创建新的销售值，并且这些销售值将从<code class="codeph">y</code>的城市复制。
                           </p><pre class="oac_no_warn" dir="ltr">UPSERT ALL销售[ANY，ANY，'z'] =销售[CV（产品），CV（时间），'y']</pre><p>我们的源数据集有以下四行：</p><pre class="oac_no_warn" dir="ltr">PROD TIME CITY SALES 1 2002 x 10 1 2003 x 15 2 2002 y 21 2 2003 y 24</pre><p>以下说明适用于此数据的四个步骤的详细信息：</p>
                           <ol>
                              <li>
                                 <p>因为规则的符号谓词是<code class="codeph">ANY</code> ，所以此示例中显示的任何行都是可接受的。
                                 </p>
                              </li>
                              <li>
                                 <p>具有符合条件的符号谓词的单元的不同维度组合是：（1,2002），（1,2003），（2,2002）和（2,2003）。</p>
                              </li>
                              <li>
                                 <p>您可以找到这些维度组合与使用位置参考指定的单元格的叉积。在这种情况下，它只是一个值为<code class="codeph">z</code>的叉积，得到的单元格引用是：（1,2002，z），（1,200，z），（2,2002，z）和（2， 2003，z）。
                                 </p>
                              </li>
                              <li>
                                 <p>将插入步骤3中列出的单元格，并根据城市<code class="codeph">y</code>计算销售额。由于城市<code class="codeph">y</code>中没有产品1的值，因此为产品1创建的单元格将具有<code class="codeph">NULL</code>作为其销售值。当然，不同的规则可能会为所有新单元格生成非<code class="codeph">NULL</code>结果。我们的结果集包括四个原始行和四个新行：</p>
                              </li>
                           </ol><pre class="oac_no_warn" dir="ltr">PROD TIME CITY SALES 1 2002 x 10 1 2003 x 15 2 2002 y 21 2 2003 y 24 1 2002 z NULL 1 2003 z NULL 2 2002 z 21 2 2003 z 24</pre><p>重要的是要注意，这些结果不是使用所有维度的所有值的叉积。如果是这种情况，你会有像（1,2002，y）和（2,2003，x）这样的单元格。相反，此处的结果是使用现有行中的维度组合创建的。</p>
                        </div>
                     </div>
                  </div>
               </div><a id="DWHSG8783"></a><div class="props_rev_3"><a id="GUID-921A7D68-3982-460E-A0FC-AD50954710D3" name="GUID-921A7D68-3982-460E-A0FC-AD50954710D3"></a><h4 id="DWHSG-GUID-921A7D68-3982-460E-A0FC-AD50954710D3" class="sect4"><span class="enumeration_section">22.2.9</span> SQL建模中NULL和丢失单元的处理</h4>
                  <div>
                     <p>使用模型的应用程序不仅要处理<code class="codeph">NULL</code>形式的单元测量的非确定性值，还要处理缺失单元格形式的非确定性。由单个单元格引用引用的单元格中缺少的单元称为缺失单元格。<code class="codeph">MODEL</code>子句为空值和缺失单元提供了与ANSI SQL标准一致的默认处理，并且还提供了根据业务逻辑以其他有用方式处理它们的选项，例如，将空值视为零以用于算术运算。
                     </p>
                     <p>默认情况下， <code class="codeph">NULL</code>单元格度量值的处理方式与在SQL中其他位置处理空值的方式相同。例如，在以下规则中：</p><pre class="oac_no_warn" dir="ltr">sales ['Bounce'，2001] = sales ['Bounce'，1999] + sales ['Bounce'，2000]</pre><p>如果1999年和2000年之一的Bounce销售额为<code class="codeph">NULL</code>则右侧表达式将评估为<code class="codeph">NULL</code> 。类似地，规则中的聚合函数将以与其常规行为相同的方式处理<code class="codeph">NULL</code>值，其中在聚合期间忽略<code class="codeph">NULL</code>值。
                     </p>
                     <p>丢失的单元格被视为具有<code class="codeph">NULL</code>度量值的单元格。例如，在前面的规则中，如果缺少Bounce和2000的单元格，则将其视为<code class="codeph">NULL</code>值，并将右侧表达式计算为<code class="codeph">NULL</code> 。</p>
                     <p>本节包含以下主题：</p>
                     <ul style="list-style-type:disc">
                        <li>
                           <p><a href="sql-modeling-data-warehouses.html#GUID-86507CB0-F34C-4758-94CF-ADEF99EB50D4">区分丢失的单元格与NULL</a></p>
                        </li>
                        <li>
                           <p><a href="sql-modeling-data-warehouses.html#GUID-1E78C1F8-1EA5-426C-B1B7-D394AF28A9FF">使用默认值来丢失单元格和NULL</a></p>
                        </li>
                        <li>
                           <p><a href="sql-modeling-data-warehouses.html#GUID-BA310B2D-1395-4424-9C3C-89173CE17601">在单元格引用中使用NULL</a></p>
                        </li>
                     </ul>
                  </div><a id="DWHSG8784"></a><div class="props_rev_3"><a id="GUID-86507CB0-F34C-4758-94CF-ADEF99EB50D4" name="GUID-86507CB0-F34C-4758-94CF-ADEF99EB50D4"></a><h5 id="DWHSG-GUID-86507CB0-F34C-4758-94CF-ADEF99EB50D4" class="sect5"><span class="enumeration_section">22.2.9.1</span>区分丢失的单元格与NULL</h5>
                     <div>
                        <div class="section">
                           <p>使用<code class="codeph">PRESENTV</code>和<code class="codeph">PRESENTNNV</code>函数可以识别丢失的单元格并将其与<code class="codeph">NULL</code>值区分开来。这些函数采用单个单元格引用和两个表达式作为参数，如<code class="codeph">PRESENTV(cell, expr1, expr2)</code> 。如果在<code class="codeph">MODEL</code>子句的数据输入中存在单元格<code class="codeph">cell</code>则<code class="codeph">PRESENTV</code>返回第一个表达式<code class="codeph">expr1</code> 。否则，它返回第二个表达式<code class="codeph">expr2</code> 。例如，请考虑以下事项：</p><pre class="oac_no_warn" dir="ltr">PRESENTV（销售['Bounce'，2000]，1.1 *销售['Bounce'，2000]，100）</pre><p>如果产品Bounce和2000年的单元格存在，则返回相应的销售额乘以1.1，否则返回100。请注意，如果2000年产品Bounce的销售额为<code class="codeph">NULL</code> ，则前面的规范将返回<code class="codeph">NULL</code> 。</p>
                           <p><code class="codeph">PRESENTNNV</code>函数不仅检查单元格的存在，还检查它是否为<code class="codeph">NULL</code> 。如果单元格存在且不为<code class="codeph">NULL</code> ，则返回第一个表达式<code class="codeph">expr1</code> ，否则返回第二个表达式<code class="codeph">expr2</code> 。例如，请考虑以下事项：</p><pre class="oac_no_warn" dir="ltr">PRESENTNNV（销售['Bounce'，2000]，1.1 *销售['Bounce'，2000]，100）</pre><p>如果<code class="codeph">sales['Bounce', 2000]</code>存在且不为<code class="codeph">NULL</code> ，则返回<code class="codeph">1.1*sales['Bounce', 2000]</code> 。否则，它返回100。
                           </p>
                           <p>应用程序可以在其模型中使用<code class="codeph">IS PRESENT</code>谓词以显式方式检查单元格的存在。如果单元格存在，则该谓词返回<code class="codeph">TRUE</code> ，否则返回<code class="codeph">FALSE</code> 。使用<code class="codeph">PRESENTNNV</code>的上述示例可以使用<code class="codeph">IS</code> <code class="codeph">PRESENT</code>编写为：</p><pre class="oac_no_warn" dir="ltr">销售['Bounce'，2000]的情况是现在和销售['Bounce'，2000]不是NULL而是1.1 *销售['Bounce'，2000] ELSE 100 END</pre><p><code class="codeph">IS PRESENT</code>谓词与<code class="codeph">PRESENTV</code>和<code class="codeph">PRESENTNNV</code>函数一样，检查输入数据中是否存在单元格，即在执行<code class="codeph">MODEL</code>子句之前存在的数据。这使您可以初始化由<code class="codeph">UPSERT</code>规则新插入的单元格的多个度量。例如，如果要初始化单元格的销售和利润值，如果数据中不存在，则对于产品Bounce和2003年分别为1000和500，您可以通过以下方式执行此操作：</p><pre class="oac_no_warn" dir="ltr">规则（UPSERT销售['Bounce'，2003] = PRESENTV（销售['Bounce'，2003]，销售['Bounce'，2003]，1000），UPSERT利润['Bounce'，2003] = PRESENTV（利润[' Bounce'，2003]，profit ['Bounce'，2003]，500））</pre><p>此<code class="codeph">PRESENTV</code>使用的<code class="codeph">PRESENTV</code>函数根据输入数据中单元格的存在返回<code class="codeph">TRUE</code>或<code class="codeph">FALSE</code> 。如果Bounce和2003的单元格被其中一个规则插入，则根据其评估顺序，另一个规则中的<code class="codeph">PRESENTV</code>函数仍将评估为<code class="codeph">FALSE</code> 。您可以将此行为视为规则评估的预处理步骤，该评估评估并替换所有<code class="codeph">PRESENTV</code>和<code class="codeph">PRESENTNNV</code>函数以及<code class="codeph">IS</code> <code class="codeph">PRESENT</code>谓词的各自值。
                           </p>
                        </div>
                        <!-- class="section" -->
                     </div>
                  </div><a id="DWHSG8785"></a><div class="props_rev_3"><a id="GUID-1E78C1F8-1EA5-426C-B1B7-D394AF28A9FF" name="GUID-1E78C1F8-1EA5-426C-B1B7-D394AF28A9FF"></a><h5 id="DWHSG-GUID-1E78C1F8-1EA5-426C-B1B7-D394AF28A9FF" class="sect5"><span class="enumeration_section">22.2.9.2</span>使用缺少单元格和NULL的默认值</h5>
                     <div>
                        <p>默认情况下， <code class="codeph">MODEL</code>子句将缺少的单元格视为具有<code class="codeph">NULL</code>度量值的单元格。可以在<code class="codeph">MODEL</code>子句中指定可选的<code class="codeph">KEEP</code> <code class="codeph">NAV</code>关键字以获得此行为。如果您的应用程序想要默认缺少单元格并将空值设置为某些值，则可以使用<code class="codeph">IS</code> <code class="codeph">PRESENT</code> ， <code class="codeph">IS</code> <code class="codeph">NULL</code>谓词和<code class="codeph">PRESENTV</code> ， <code class="codeph">PRESENTNNV</code>函数来执行此操作。但是如果你有很多单细胞参考和规则，它可能会变得很麻烦。您可以使用<code class="codeph">IGNORE</code> <code class="codeph">NAV</code>选项而不是默认的<code class="codeph">KEEP</code> <code class="codeph">NAV</code>选项来默认空值和缺少单元格：</p>
                        <ul style="list-style-type:disc">
                           <li>
                              <p>0表示数字数据</p>
                           </li>
                           <li>
                              <p>字符串/字符串数据的空字符串</p>
                           </li>
                           <li>
                              <p>01-JAN-2001用于数据类型数据</p>
                           </li>
                           <li>
                              <p>所有其他数据类型为<code class="codeph">NULL</code></p>
                           </li>
                        </ul>
                        <p>请考虑以下查询：</p><pre class="oac_no_warn" dir="ltr">SELECT product，year，sales FROM sales_view WHERE country ='Poland'MODEL DIMENSION BY（产品，年份）MEASURES（销售额）IGNORE NAV RULES UPSERT（销售['Bounce'，2003] =销售['Bounce'，2002] +销售['Bounce'，2001]）;</pre><p>在这里， <code class="codeph">MODEL</code>子句的输入没有产品Bounce和2002年的单元格。由于<code class="codeph">IGNORE</code> <code class="codeph">NAV</code>选项， <code class="codeph">sales['Bounce', 2002]</code>值默认为0（因为销售是数字类型）而不是<code class="codeph">NULL</code> 。因此， <code class="codeph">sales['Bounce', 2003]</code>价值将与<code class="codeph">sales['Bounce', 2001]</code> 。
                        </p>
                     </div>
                  </div><a id="DWHSG8786"></a><div class="props_rev_3"><a id="GUID-BA310B2D-1395-4424-9C3C-89173CE17601" name="GUID-BA310B2D-1395-4424-9C3C-89173CE17601"></a><h5 id="DWHSG-GUID-BA310B2D-1395-4424-9C3C-89173CE17601" class="sect5"><span class="enumeration_section">22.2.9.3</span>在单元格引用中使用NULL</h5>
                     <div>
                        <div class="section">
                           <p>要在单元格引用中使用<code class="codeph">NULL</code>值，必须使用以下之一：</p>
                        </div>
                        <!-- class="section" -->
                        <div class="section">
                           <ul style="list-style-type:disc">
                              <li>
                                 <p>使用外卡<code class="codeph">ANY</code>位置参考，如<code class="codeph">sales[ANY]</code> 。
                                 </p>
                              </li>
                              <li>
                                 <p>使用<code class="codeph">IS</code> <code class="codeph">ANY</code>谓词的符号引用，如<code class="codeph">sales[product IS ANY]</code> 。
                                 </p>
                              </li>
                              <li>
                                 <p><code class="codeph">sales[NULL]</code>的<code class="codeph">NULL</code>位置引用<code class="codeph">sales[NULL]</code> 。
                                 </p>
                              </li>
                              <li>
                                 <p>使用<code class="codeph">IS</code> <code class="codeph">NULL</code>谓词的符号引用，如<code class="codeph">sales[product IS NULL]</code> 。
                                 </p>
                              </li>
                           </ul>
                           <p>请注意，符号引用<code class="codeph">sales[product = NULL]</code>不会测试产品维度中的空值。此行为符合SQL对空值的标准处理。</p>
                        </div>
                        <!-- class="section" -->
                     </div>
                  </div>
               </div><a id="DWHSG8787"></a><div class="props_rev_3"><a id="GUID-3715019F-674C-4CFA-BEAE-08F4C5757596" name="GUID-3715019F-674C-4CFA-BEAE-08F4C5757596"></a><h4 id="DWHSG-GUID-3715019F-674C-4CFA-BEAE-08F4C5757596" class="sect4"><span class="enumeration_section">22.2.10</span>关于SQL建模中的参考模型</h4>
                  <div>
                     <p>除了规则操作的多维数组（称为主模型）之外，还可以在<code class="codeph">MODEL</code>子句中创建和引用一个或多个只读多维数组（称为参考模型）以充当查找主模型的表格。与主模型一样，参数模型在查询块上定义，并且具有<code class="codeph">DIMENSION</code> <code class="codeph">BY</code>和<code class="codeph">MEASURES</code>子句以分别指示其维度和度量。参考模型由以下子句创建：</p><pre class="oac_no_warn" dir="ltr">参考model_name ON（查询）DIMENSION BY（cols）MEASURES（cols）[参考选项]</pre><p>与主模型一样，在评估规则之前构建参考模型的多维数组。但是，与主模型不同，参考模型是只读的，因为它们的单元格无法更新，并且在构建后无法插入新单元格。因此，主模型中的规则可以访问参考模型的单元格，但是它们不能更新或将新单元格插入到参考模型中。以下是使用货币转换表作为参考模型的示例：</p><pre class="oac_no_warn" dir="ltr">CREATE TABLE dollar_conv_tbl（country VARCHAR2（30），exchange_rate NUMBER）; INSERT INTO dollar_conv_tbl VALUES（'Poland'，0.25）; INSERT INTO dollar_conv_tbl VALUES（'France'，0.14）; ...
</pre><p>现在，要将2003年波兰和法国的预计销售额转换为美元，您可以使用美元转换表作为参考模型，如以下命令所示。视图sales_view的创建方式如<a href="sql-modeling-data-warehouses.html#GUID-C5C34EFE-B74C-45BA-8D4B-71E527F858F7">SQL模型示例的基本模式中</a>所述。
                     </p><pre class="oac_no_warn" dir="ltr">SELECT country，year，sales，dollar_sales FROM sales_view GROUP BY country，year MODEL REFERENCE conv_ref ON（SELECT country，exchange_rate FROM dollar_conv_tbl）DIMENSION BY（country）MEASURES（exchange_rate）IGNORE NAV MAIN转换DIMENSION BY（国家，年）措施（SUM （销售）销售额，SUM（销售额）dollar_sales）IGNORE NAV RULES（dollar_sales ['France'，2003] = sales [CV（country），2002] * 1.02 * conv_ref.exchange_rate ['France']，dollar_sales ['Poland' ，2003] =销售['波兰'，2002] * 1.05 * exchange_rate ['波兰']）;</pre><p>在这个例子中观察到：</p>
                     <ul style="list-style-type:disc">
                        <li>
                           <p>在表<code class="codeph">dollar_conv_tbl</code>行上创建名为<code class="codeph">conv_ref</code>一维参考模型，并且其测量值<code class="codeph">exchange_rate</code>已在主模型的规则中引用。
                           </p>
                        </li>
                        <li>
                           <p>主模型（称为<code class="codeph">conversion</code> ）有两个维度，country和year，而参考模型<code class="codeph">conv_ref</code>有一个维度country。
                           </p>
                        </li>
                        <li>
                           <p>访问参考模型的<code class="codeph">exchange_rate</code>度量的不同样式。对法国来说，这是相当有明确<code class="codeph">model_name.measure_name</code>符号<code class="codeph">conv_ref.exchange_rate</code> ，而对于波兰，这是一个简单<code class="codeph">measure_name</code>参考<code class="codeph">exchange_rate</code> 。前一种表示法需要用于解决主模型和参考模型中列名称的任何歧义。
                           </p>
                        </li>
                     </ul>
                     <p>在这个例子中，增长率在规则中是硬编码的。法国的增长率为2％，波兰的增长率为5％。但它们可能来自一个单独的表，您可以在其上定义参考模型。假设您将<code class="codeph">growth_rate(country, year, rate)</code>表定义如下：</p><pre class="oac_no_warn" dir="ltr">CREATE TABLE growth_rate_tbl（国家VARCHAR2（30），年份NUMBER，growth_rate NUMBER）; INSERT INTO growth_rate_tbl VALUES（'Poland'，2002,2.5）; INSERT INTO growth_rate_tbl VALUES（'Poland'，2003,5）; ...INSERT INTO growth_rate_tbl VALUES（'France'，2002,3）; INSERT INTO growth_rate_tbl VALUES（'France'，2003,2.5）;</pre><p>然后，以下查询计算所有国家/地区2003年的预计销售额：</p><pre class="oac_no_warn" dir="ltr">SELECT country，year，sales，dollar_sales FROM sales_view GROUP BY country，year MODEL REFERENCE conv_ref ON（SELECT country，exchange_rate FROM dollar_conv_tbl）DIMENSION BY（country c）MEASURES（exchange_rate）IGNORE NAV REFERENCE growth_ref ON（SELECT country，year，growth_rate FROM growth_rate_tbl）DIMENSION BY（国家c，年y）措施（growth_rate）IGNORE NAV MAIN投影维度BY（国家，年）措施（SUM（销售）销售额，0 dollar_sales）IGNORE NAV RULES（dollar_sales [ANY，2003] = sales [ CV（country），2002] * growth_rate [CV（country），CV（year）] * exchange_rate [CV（country）]）;</pre><p>此查询显示<code class="codeph">MODEL</code>子句处理和关联不同维度对象的能力。参考模型<code class="codeph">conv_ref</code>具有一个维度，而参考模型<code class="codeph">growth_ref</code>和主模型具有两个维度。参考模型中单个单元格参考中的尺寸使用<code class="codeph">CV</code>函数指定，从而将主模型中的单元格与参考模型相关联。实际上，该规范在主模型和参考模型之间执行关系连接。
                     </p>
                     <p>参考模型还可以帮助您将键转换为序列号，使用序列号执行计算（例如，在减法操作中使用前一个句点），然后将序列号转换回键。例如，考虑一个将序列号分配给年的视图：</p><pre class="oac_no_warn" dir="ltr">CREATE或REPLACE VIEW year_2_seq（i，year）AS SELECT ROW_NUMBER（）OVER（ORDER BY calendar_year），calendar_year FROM（SELECT DISTINCT calendar_year FROM TIMES）;</pre><p>此视图可以定义两个查找表：整数到年<code class="codeph">i2y</code> ，它将序列号映射到整数，以及年到整数<code class="codeph">y2i</code> ，它执行反向映射。引用<code class="codeph">y2i.i[year]</code>和<code class="codeph">y2i.i[year] - 1</code>返回当前年份和前几年的序列号，参考<code class="codeph">i2y.y[y2i.i[year]-1]</code>返回年份密钥值去年。以下查询演示了参考模型的这种用法：</p><pre class="oac_no_warn" dir="ltr">SELECT country，product，year，sales，prior_period FROM sales_view MODEL REFERENCE y2i ON（SELECT year，i FROM year_2_seq）DIMENSION BY（y年）措施（i）参考i2y ON（选择年份，i FROM year_2_seq）DIMENSION BY（i）措施（年y）主要投影2分区（国家）维度（产品，年份）措施（销售额，CAST（NULL AS NUMBER）prior_period）（prior_period [ANY，ANY] =销售[CV（产品），i2y.y [ y2i.i [简历（年）]  -  1]]）按国家，产品，年份排序;</pre><p>参考模型单元格引用的嵌套在前面的示例中很明显。参考模型<code class="codeph">y2i</code>上的单元格引用嵌套在<code class="codeph">y2i</code>上的单元格引用内，而<code class="codeph">i2y</code>又嵌套在主SQL模型的单元格引用中。您可以在参考模型单元格引用上嵌套的级别没有限制。但是，在主SQL模型单元引用上只能有两个嵌套级别。
                     </p>
                     <p>最后，以下是对参考模型的规范和使用的限制：</p>
                     <ul style="list-style-type:disc">
                        <li>
                           <p>参考模型不能有<code class="codeph">PARTITION</code> <code class="codeph">BY</code>子句。
                           </p>
                        </li>
                        <li>
                           <p>定义参考模型的查询块不能与外部查询相关联。</p>
                        </li>
                        <li>
                           <p>必须命名参考模型，并且它们的名称应该是唯一的。</p>
                        </li>
                        <li>
                           <p>对参考模型的细胞的所有引用应该是单细胞参考。</p>
                        </li>
                     </ul>
                  </div>
               </div>
            </div><a id="DWHSG8788"></a><div class="props_rev_3"><a id="GUID-353F0903-9CD3-4BD9-A584-B31CB1FAB282" name="GUID-353F0903-9CD3-4BD9-A584-B31CB1FAB282"></a><h3 id="DWHSG-GUID-353F0903-9CD3-4BD9-A584-B31CB1FAB282" class="sect3"><span class="enumeration_section">22.3</span> SQL建模中的高级主题</h3>
               <div>
                  <p>本节讨论SQL建模中的更高级主题，包括：</p>
                  <ul style="list-style-type:disc">
                     <li>
                        <p><a href="sql-modeling-data-warehouses.html#GUID-13071F40-90AB-4E4F-AA33-A8827236939D">FOR SQL中的循环</a></p>
                     </li>
                     <li>
                        <p><a href="sql-modeling-data-warehouses.html#GUID-3D857B68-73BE-4B65-A077-D1D5FD37D76B">SQL建模中的迭代模型</a></p>
                     </li>
                     <li>
                        <p><a href="sql-modeling-data-warehouses.html#GUID-B0FA1BB9-C7B7-4EF2-82BA-B551B0087999">AUTOMATIC ORDER模型中的规则依赖性</a></p>
                     </li>
                     <li>
                        <p><a href="sql-modeling-data-warehouses.html#GUID-2523C916-C744-46B1-8D53-DF03204EAF85">SQL建模中的有序规则</a></p>
                     </li>
                     <li>
                        <p><a href="sql-modeling-data-warehouses.html#GUID-6B79CCE3-69E2-444C-84BE-50672330C546">SQL建模中的分析函数</a></p>
                     </li>
                     <li>
                        <p><a href="sql-modeling-data-warehouses.html#GUID-C3F6B53D-5BBE-48CB-83DD-C6E2587CDED8">独特的维度与SQL建模中的唯一单一引用</a></p>
                     </li>
                     <li>
                        <p><a href="sql-modeling-data-warehouses.html#GUID-AD6A9B81-492F-4724-9517-7758C4A98365">使用SQL进行建模时的规则和限制</a></p>
                     </li>
                  </ul>
               </div><a id="DWHSG0223"></a><div class="props_rev_3"><a id="GUID-13071F40-90AB-4E4F-AA33-A8827236939D" name="GUID-13071F40-90AB-4E4F-AA33-A8827236939D"></a><h4 id="DWHSG-GUID-13071F40-90AB-4E4F-AA33-A8827236939D" class="sect4"><span class="enumeration_section">22.3.1</span> SQL建模中的FOR循环</h4>
                  <div>
                     <p><code class="codeph">MODEL</code>子句提供了一个<code class="codeph">FOR</code>结构，可以在规则内部使用，以更紧凑地表达计算。它可以在规则的左侧和右侧使用。当在规则的左侧时， <code class="codeph">FOR</code>循环被视为位置引用。例如，考虑以下计算，估计2004年几种产品的销售额比2003年的销售额高出10％：</p><pre class="oac_no_warn" dir="ltr">RULES UPSERT（销售['Bounce'，2004] = 1.1 *销售['Bounce'，2003]，销售['标准鼠标垫'，2004] = 1.1 *销售['标准鼠标垫'，2003]，...销售['Y Box'，2004] = 1.1 *销售['Y Box'，2003]）</pre><p>在此计算中使用<code class="codeph">UPSERT</code>选项，以便在以前不存在于多维阵列中时插入这些产品和2004的单元格。这是相当笨重的，因为您必须拥有与产品一样多的规则。使用<code class="codeph">FOR</code>构造，可以紧凑地表示此计算，并且具有与以下内容完全相同的语义：</p><pre class="oac_no_warn" dir="ltr">RULES UPSERT（销售[FOR product IN（'Bounce'，'Standard Mouse Pad'，...，'Y Box'），2004] = 1.1 *销售[CV（product），2003]）</pre><p>如果您编写与此类似的规范，但没有<code class="codeph">FOR</code>关键字，如下所示：</p><pre class="oac_no_warn" dir="ltr">RULES UPSERT（销售[产品IN（'Bounce'，'标准鼠标垫'，......，'Y Box'），2004] = 1.1 *销售[CV（产品），2003]）</pre><p>即使您已指定<code class="codeph">UPSERT</code>也会获得<code class="codeph">UPDATE</code>语义。换句话说，将更新现有单元格，但此规范不会创建新单元格。这是因为产品上的多单元引用是符号引用，符号引用不允许插入新单元。您可以将<code class="codeph">FOR</code>构造视为一个宏，该宏通过单个规则生成具有位置引用的多个规则，从而保留<code class="codeph">UPSERT</code>语义。从概念上讲，以下规则：</p><pre class="oac_no_warn" dir="ltr">销售[FOR产品IN（'弹跳'，'标准鼠标垫'，...，'Y盒'），FOR年IN（2004年，2005年）] = 1.1 *销售[简历（产品），简历（年） - 1]</pre><p>可以视为以下规则的有序集合：</p><pre class="oac_no_warn" dir="ltr">销售['Bounce'，2004] = 1.1 *销售[CV（产品），CV（年）-1]，销售['Bounce'，2005] = 1.1 *销售[CV（产品），CV（年）-1 ]，销售['标准鼠标垫'，2004] = 1.1 *销售[简历（产品），简历（年）-1]，销售['标准鼠标垫'，2005] = 1.1 *销售[简历（产品），简历（年）-1]，......销售['Y Box'，2004] = 1.1 *销售[CV（产品），CV（年）-1]，销售['Y Box'，2005] = 1.1 *销售[CV（产品），CV（年） -1]</pre><p>前面示例中的<code class="codeph">FOR</code>构造的类型<code class="codeph">FOR</code> <code class="codeph">dimension</code> <code class="codeph">IN</code> <span class="italic"><code class="codeph">(list of values)</code></span> 。列表中的值应该是单值表达式，例如常量表达式，单单元格引用等。在最后一个示例中，在产品和年份上有单独的<code class="codeph">FOR</code>结构。也可以使用一个<code class="codeph">FOR</code>构造指定所有维度，并使用多列<code class="codeph">IN</code>列表指定值。例如，考虑一下，如果你只想估算2004年的Bounce，2005年的Standard Mouse Pad和2004年和2005年的Y Box的销售额。这可以表述如下：</p><pre class="oac_no_warn" dir="ltr">销售[FOR（产品，年份）IN（（'Bounce'，2004），（'Standard Mouse Pad'，2005），（'Y Box'，2004），（'Y Box'，2005））] = 1.1 *销售[简历（产品），简历（年）-1]</pre><p>当有n个维度<code class="codeph">d1, ..., dn</code>时<code class="codeph">FOR (d1, ..., dn) IN ((d1_val1, ..., dn_val1), ..., (d1_valm, ..., dn_valm)]</code>此<code class="codeph">FOR</code>结构的形式应为<code class="codeph">FOR (d1, ..., dn) IN ((d1_val1, ..., dn_val1), ..., (d1_valm, ..., dn_valm)]</code>列表中的<code class="codeph">d1, ..., dn</code>和<code class="codeph">m</code>值。
                     </p>
                     <p>在某些情况下，可以从表或子查询中检索<code class="codeph">FOR</code>维度的值列表。Oracle数据库提供了一种<code class="codeph">FOR</code>结构，如<code class="codeph">FOR</code> <code class="codeph">dimension</code> <code class="codeph">IN</code> <span class="italic"><code class="codeph">(subquery)</code></span>中那样处理这些情况。例如，假设感兴趣的产品存储在表<code class="codeph">interesting_products</code> ，则以下规则估计其2004年和2005年的销售额：</p><pre class="oac_no_warn" dir="ltr">销售[FOR产品IN（SELECT product_name FROM interesting_products）FOR IN（2004,2005）] = 1.1 *销售[CV（产品），CV（年）-1]</pre><p>作为另一个例子，考虑你想要引入一个名为<code class="codeph">new_country</code>的新国家的<code class="codeph">new_country</code> ，其销售模仿波兰的所有产品和波兰销售年份。这是通过发出以下声明来完成的：</p><pre class="oac_no_warn" dir="ltr">SELECT country，product，year，s FROM sales_view MODEL DIMENSION BY（国家，产品，年份）措施（销售）IGNORE NAV RULES UPSERT（s [FOR（国家，产品，年份）IN（SELECT DISTINCT'new_country'，product， year FROM sales_view WHERE country ='Poland'）] = s ['Poland'，CV（），CV（）]）ORDER BY country，year，product;</pre><p>视图sales_view的创建方式如<a href="sql-modeling-data-warehouses.html#GUID-C5C34EFE-B74C-45BA-8D4B-71E527F858F7">SQL模型示例的基本模式中</a>所述。
                     </p>
                     <p>请注意通过评估此规范中的子查询生成的多列<code class="codeph">IN</code> 。用于获取<code class="codeph">IN</code> -list的子查询无法与外部查询块相关联。
                     </p>
                     <p>请注意，规则创建的upsert列表是每个维度的不同值的交叉积。例如，如果有10个国家/地区值，5个年份值和3个产品值，您将生成包含150个单元格的upsert列表。</p>
                     <p>如果您知道感兴趣的值来自离散域，则可以使用<code class="codeph">FOR</code>构造<code class="codeph">FOR dimension FROM value1 TO value2 [INCREMENT | DECREMENT] value3</code> 。此规范通过从<code class="codeph">value1</code>开始并按<code class="codeph">value3</code>递增（或递减），得到<code class="codeph">value1</code>和<code class="codeph">value2</code>之间的<code class="codeph">value1</code> 。值<code class="codeph">value1</code> ， <code class="codeph">value2</code>和<code class="codeph">value3</code>应为单值表达式。例如，以下规则：</p><pre class="oac_no_warn" dir="ltr">销售['Bounce'，FOR 2001年至2005年增量1] =销售['Bounce'，年= CV（年）-1] * 1.2</pre><p>这在语义上按顺序等效于以下规则：</p><pre class="oac_no_warn" dir="ltr">sales ['Bounce'，2001] = sales ['Bounce'，2000] * 1.2，sales ['Bounce'，2002] = sales ['Bounce'，2001] * 1.2，...sales ['Bounce'，2005] = sales ['Bounce'，2004] * 1.2</pre><p>这种<code class="codeph">FOR</code>结构可用于数字，日期和日期时间数据类型的维度。增量/减量表达式<code class="codeph">value3</code>的类型对于数字维度应为数字，对于日期或日期时间类型的维度可以是数字或间隔。此外， <code class="codeph">value3</code>应为正数。如果使用<code class="codeph">FOR year FROM 2005 TO 2001 INCREMENT -1</code> Oracle数据库将返回错误。您应使用<code class="codeph">FOR year FROM 2005 TO 2001 DECREMENT 1</code>或<code class="codeph">FOR year FROM 2001 TO 2005 INCREMENT 1</code> 。
                     </p>
                     <p>要生成字符串值，可以使用<code class="codeph">FOR</code>构造<code class="codeph">FOR dimension LIKE string FROM value1 TO value2 [INCREMENT | DECREMENT] value3</code> 。字符串<code class="codeph">string</code>应仅包含一个<code class="codeph">%</code>字符。此规范通过使用适当的递增/递减值<code class="codeph">value3</code> <code class="codeph">value1</code>和<code class="codeph">value2</code>之间的<code class="codeph">value1</code>替换为<code class="codeph">%</code>来生成字符串。例如，请考虑以下规则：</p><pre class="oac_no_warn" dir="ltr">销售[FOR product LIKE'product-％'从1到3 INCREMENT 1,2003] =销售[CV（product），2002] * 1.2</pre><p>这相当于以下内容：</p><pre class="oac_no_warn" dir="ltr">sales ['product-1'，2003] = sales ['product-1'，2002] * 1.2，sales ['product-2'，2003] = sales ['product-2'，2002] * 1.2，sales [ 'product-3'，2003] = sales ['product-3'，2002] * 1.2</pre><p>在<code class="codeph">SEQUENTIAL</code> <code class="codeph">ORDER</code>模型中， <code class="codeph">FOR</code>构造表示的规则按生成顺序进行评估。相反，如果指定了<code class="codeph">AUTOMATIC</code> <code class="codeph">ORDER</code> ，则规则评估顺序将基于依赖性。例如，规则所代表的规则的评估顺序：</p><pre class="oac_no_warn" dir="ltr">销售['Bounce'，FOR 2004年至2001年DECREMENT 1] = 1.1 *销售['Bounce'，CV（年）-1]</pre><p>对于<code class="codeph">SEQUENTIAL</code> <code class="codeph">ORDER</code>模型，将按以下顺序生成规则：</p><pre class="oac_no_warn" dir="ltr">sales ['Bounce'，2004] = 1.1 * sales ['Bounce'，2003]，sales ['Bounce'，2003] = 1.1 * sales ['Bounce'，2002]，sales ['Bounce'，2002] = 1.1 * sales ['Bounce'，2001]，sales ['Bounce'，2001] = 1.1 * sales ['Bounce'，2000]</pre><p>而对于<code class="codeph">AUTOMATIC</code> <code class="codeph">ORDER</code>模型，订单将等同于：</p><pre class="oac_no_warn" dir="ltr">sales ['Bounce'，2001] = 1.1 * sales ['Bounce'，2000]，sales ['Bounce'，2002] = 1.1 * sales ['Bounce'，2001]，sales ['Bounce'，2003] = 1.1 * sales ['Bounce'，2002]，sales ['Bounce'，2004] = 1.1 * sales ['Bounce'，2003]</pre><div class="infoboxnotealso" id="GUID-13071F40-90AB-4E4F-AA33-A8827236939D__GUID-8A4D96B2-B038-4C73-9D9B-0C93CC9466B5">
                        <p class="notep1">也可以看看：</p>
                        <p><a href="sql-modeling-data-warehouses.html#GUID-10CEB733-E962-4506-BD07-9583251D339A">用FOR循环评估公式</a></p>
                     </div>
                  </div><a id="DWHSG8789"></a><div class="props_rev_3"><a id="GUID-10CEB733-E962-4506-BD07-9583251D339A" name="GUID-10CEB733-E962-4506-BD07-9583251D339A"></a><h5 id="DWHSG-GUID-10CEB733-E962-4506-BD07-9583251D339A" class="sect5"><span class="enumeration_section">22.3.1.1</span>用FOR循环评估公式</h5>
                     <div>
                        <div class="section">
                           <p><code class="codeph">FOR</code>循环结构提供了一种迭代机制，用于为维度或所有维度生成单值引用（对于<code class="codeph">IN</code>列表， <code class="codeph">IN</code>多列的情况下）。左侧的<code class="codeph">FOR</code>循环公式的评估基本上包括对这些<code class="codeph">FOR</code>循环生成的每个单值引用的公式右侧进行评估，并使用此单值引用将结果分配给指定的单元格。这些单个参考值的生成称为“展开<code class="codeph">FOR</code>循环”。这些展开的细胞按照它们在展开过程中产生的顺序进行评估。
                           </p>
                           <p>如何执行展开取决于为规则指定的<code class="codeph">UPSERT</code> ， <code class="codeph">UPDATE</code>和<code class="codeph">UPDATE</code> <code class="codeph">ALL</code>行为以及规则的特定特征。要理解这一点，需要讨论查询处理的两个阶段：查询计划创建和查询执行。查询计划创建是解决某些规则引用以创建有效查询执行计划的阶段。查询执行是必须确定所有剩余未解析引用的阶段。<code class="codeph">FOR</code>循环可以在查询计划生成或查询执行时展开。下面讨论了展开决策的细节。
                           </p>
                           <div class="infoboxnotealso" id="GUID-10CEB733-E962-4506-BD07-9583251D339A__GUID-26F0C850-E639-40E1-A537-14FA3CEC3B33">
                              <p class="notep1">也可以看看：</p>
                              <ul style="list-style-type:disc">
                                 <li>
                                    <p><a href="sql-modeling-data-warehouses.html#GUID-E00D151E-FA8B-48A9-9B21-62723787C075">展开UPDATE和UPSERT规则</a></p>
                                 </li>
                                 <li>
                                    <p><a href="sql-modeling-data-warehouses.html#GUID-8A41F257-4B7D-4837-A99D-7BA897711617">展开适用于UPSERT ALL：规则</a></p>
                                 </li>
                                 <li>
                                    <p><a href="sql-modeling-data-warehouses.html#GUID-DDC92205-4633-4F44-A768-5D3E17254B9F">在公式左侧使用FOR循环表达式的限制</a></p>
                                 </li>
                              </ul>
                           </div>
                        </div>
                        <!-- class="section" -->
                     </div><a id="DWHSG8790"></a><div class="props_rev_3"><a id="GUID-E00D151E-FA8B-48A9-9B21-62723787C075" name="GUID-E00D151E-FA8B-48A9-9B21-62723787C075"></a><h6 id="DWHSG-GUID-E00D151E-FA8B-48A9-9B21-62723787C075" class="sect6"><span class="enumeration_section">22.3.1.1.1</span>展开UPDATE和UPSERT规则</h6>
                        <div>
                           <div class="section">
                              <p>使用<code class="codeph">UPDATE</code>或<code class="codeph">UPSERT</code>规则时，如果展开规则的左侧保证生成单个单元格引用，则在查询执行时完成展开。如果展开过程无法生成单个单元格引用，则在创建查询计划时执行展开，并创建展开过程为每个生成的引用生成相同公式的副本。例如，在查询执行时会发生以下公式的展开，因为展开会生成单个单元格引用：</p><pre class="oac_no_warn" dir="ltr">销售[FOR product IN（'prod1'，'prod2'），2003] =销售[CV（product），2002] * 1.2</pre><p>但是，请考虑以下公式，其中由于另一维度上存在谓词，展开引用值不会生成单值引用：</p><pre class="oac_no_warn" dir="ltr">销售[FOR产品（'prod1'，'prod2'），年&gt; = 2003] =销售[CV（产品），2002] * 1.2</pre><p>年份维度上没有单值参考，因此即使在产品维度上展开<code class="codeph">FOR</code>循环，此公式左侧也不会出现单值参考。这意味着在创建查询计划时会发生展开，并使用以下公式将原始公式替换为原始公式：</p><pre class="oac_no_warn" dir="ltr">sales ['prod1'，year&gt; = 2003] = sales [CV（product），2002] * 1.2，sales ['prod2'，year&gt; = 2003] = sales [CV（product），2002] * 1.2</pre><p><code class="codeph">MODEL</code>子句中执行的分析和优化是在创建查询计划时展开后完成的（如果发生了这种情况），因此，从那时起，一切都好像在<code class="codeph">MODEL</code>子句中明确指定了多个规则。通过在这些情况下在查询计划创建时执行展开，可以实现更准确的分析和更好的公式评估优化。需要注意的一点是，公式的数量可能会增加，如果此增加推动公式的总数超出最大限制，Oracle数据库会发出错误信号。
                              </p>
                           </div>
                           <!-- class="section" -->
                        </div>
                     </div><a id="DWHSG8791"></a><div class="props_rev_3"><a id="GUID-8A41F257-4B7D-4837-A99D-7BA897711617" name="GUID-8A41F257-4B7D-4837-A99D-7BA897711617"></a><h6 id="DWHSG-GUID-8A41F257-4B7D-4837-A99D-7BA897711617" class="sect6"><span class="enumeration_section">22.3.1.1.2</span>展开UPSERT ALL：规则</h6>
                        <div>
                           <div class="section">
                              <p>具有<code class="codeph">UPSERT</code> <code class="codeph">ALL</code>行为的规则具有非常不同的方法来展开<code class="codeph">FOR</code>循环。无论使用什么谓词， <code class="codeph">UPSERT</code> <code class="codeph">ALL</code>规则都会在查询执行时展开<code class="codeph">FOR</code>循环。此行为避免了下一节中讨论的某些FOR循环限制。但是，与更优化的查询计划相比，存在更少限制的权衡。<code class="codeph">UPSERT</code> <code class="codeph">ALL</code>规则倾向于比类似的<code class="codeph">UPSERT</code>或<code class="codeph">UPDATE</code>规则更慢的性能，在设计模型时应该考虑这一点。
                              </p>
                           </div>
                           <!-- class="section" -->
                        </div>
                     </div><a id="DWHSG8792"></a><div class="props_rev_3"><a id="GUID-DDC92205-4633-4F44-A768-5D3E17254B9F" name="GUID-DDC92205-4633-4F44-A768-5D3E17254B9F"></a><h6 id="DWHSG-GUID-DDC92205-4633-4F44-A768-5D3E17254B9F" class="sect6"><span class="enumeration_section">22.3.1.1.3</span>在公式左侧使用FOR循环表达式的限制</h6>
                        <div>
                           <div class="section">
                              <p>对<code class="codeph">FOR</code>循环结构的使用的限制是基于在展开查询计划时还是在查询执行时进行展开来确定的。如果在创建查询计划时展开了左侧带有<code class="codeph">FOR</code>循环的公式（由于上一节中解释的原因），则需要评估展开的表达式必须是常量的表达式，其值在查询计划创建时可用。例如，请考虑以下语句：</p><pre class="oac_no_warn" dir="ltr">销售[对于像'prod％'这样的产品，从ITERATION_NUMBER到ITERATION_NUMBER + 1，年&gt; = 2003] =销售[CV（产品），2002] * 1.2</pre><p>如果此规则没有为其行为指定<code class="codeph">UPSERT</code> <code class="codeph">ALL</code> ，则会在创建查询计划时展开它。由于在创建查询计划时未知<code class="codeph">ITERATION_NUMBER</code>的值，并且需要该值来评估开始和结束表达式，因此除非在查询执行时展开该规则，否则Oracle数据库会发出错误信号。但是，在创建查询计划时将展开以下规则而不会出现任何错误：在这种情况下，展开时不需要<code class="codeph">ITERATION_NUMBER</code>的值，即使它在<code class="codeph">FOR</code>循环中显示为表达式：</p><pre class="oac_no_warn" dir="ltr">销售[对于产品（'prod'|| ITERATION_NUMBER，'prod'||（ITERATION_NUMBER + 1）），year&gt; = 2003] = sales [CV（product），2002] * 1.2</pre><p>在创建查询计划时无法评估具有以下任何条件的表达式：</p>
                              <ul style="list-style-type:disc">
                                 <li>
                                    <p>嵌套单元格引用</p>
                                 </li>
                                 <li>
                                    <p>参考模型查找</p>
                                 </li>
                                 <li>
                                    <p><code class="codeph">ITERATION_NUMBER</code>引用</p>
                                 </li>
                              </ul>
                              <p>如果在创建查询计划时展开，则使用<code class="codeph">FOR</code>循环的规则需要此类表达式的结果会导致错误。但是，如果在查询执行时进行展开，这些表达式不会导致任何错误。
                              </p>
                              <p>如果公式在其<code class="codeph">FOR</code>循环结构中具有子查询，并且此公式需要编译时展开，则在创建查询计划时会评估这些子查询，以便可以进行展开。在创建查询计划时评估子查询可以使游标不可共享，这意味着每次发出时都需要重新编译相同的查询。如果将此类公式的展开推迟到查询执行，则不需要编译时评估，并且该公式不会影响游标的可共享性。
                              </p>
                              <p>如果要在查询执行时展开公式，则公式的<code class="codeph">FOR</code>循环中的子查询可以引用<code class="codeph">WITH</code>子句中的表。如果必须在创建查询计划时展开公式，Oracle数据库会发出错误信号。
                              </p>
                           </div>
                           <!-- class="section" -->
                        </div>
                     </div>
                  </div>
               </div><a id="DWHSG8793"></a><div class="props_rev_3"><a id="GUID-3D857B68-73BE-4B65-A077-D1D5FD37D76B" name="GUID-3D857B68-73BE-4B65-A077-D1D5FD37D76B"></a><h4 id="DWHSG-GUID-3D857B68-73BE-4B65-A077-D1D5FD37D76B" class="sect4"><span class="enumeration_section">22.3.2</span> SQL建模中的迭代模型</h4>
                  <div>
                     <p>使用<code class="codeph">MODEL</code>子句的<code class="codeph">ITERATE</code>选项，您可以迭代地评估规则一定次数，您可以将其指定为<code class="codeph">ITERATE</code>子句的参数。<code class="codeph">ITERATE</code>只能为<code class="codeph">SEQUENTIAL</code> <code class="codeph">ORDER</code>模型指定，此类模型称为迭代模型。例如，请考虑以下事项：</p><pre class="oac_no_warn" dir="ltr">SELECT x，s FROM DUAL MODEL DIMENSION BY（1 AS x）MEASURES（1024 AS s）RULES UPDATE ITERATE（4）（s [1] = s [1] / 2）;</pre><p>在Oracle中，表<code class="codeph">DUAL</code>只有一行。因此，该模型定义了一个1维数组，其数量为x，其度量为<code class="codeph">s</code> ，单个元素<code class="codeph">s[1] = 1024</code> 。规则<code class="codeph">s[1] = s[1]/2</code>评估将重复四次。此查询的结果是单行，分别为列<code class="codeph">x</code>和<code class="codeph">s</code>值为1和64。<code class="codeph">ITERATE</code>子句的迭代参数数应为正整数常量。（可选）您可以指定提前终止条件，以在达到最大迭代之前停止规则评估。此条件在<code class="codeph">ITERATE</code>的<code class="codeph">UNTIL</code>子条款中指定，并在迭代结束时进行检查。因此，在指定<code class="codeph">ITERATE</code>时，您将至少进行一次迭代。<code class="codeph">ITERATE</code>子句的语法是：</p><pre class="oac_no_warn" dir="ltr">ITERATE（number_of_iterations）[UNTIL（条件）]</pre><p>迭代评估在完成指定的迭代次数后或终止条件的计算结果为<code class="codeph">TRUE</code>时停止，以先到者为准。
                     </p>
                     <p>在某些情况下，您可能希望终止条件基于更改，跨迭代，单元格的值。Oracle数据库提供了一种指定此类条件的机制，因为它使您能够访问<code class="codeph">UNTIL</code>条件中当前迭代之前和之后存在的单元格值。Oracle的<code class="codeph">PREVIOUS</code>函数将单个单元格引用作为参数，并返回上一次迭代后存在的单元格的度量值。您还可以使用系统变量<code class="codeph">ITERATION_NUMBER</code>访问当前迭代编号，该变量从值0开始并在每次迭代后递增。通过使用<code class="codeph">PREVIOUS</code>和<code class="codeph">ITERATION_NUMBER</code> ，您可以构建复杂的终止条件。
                     </p>
                     <p>考虑以下迭代模型，该模型指定迭代规则，直到连续迭代中<code class="codeph">s[1]</code>的值的变化低于1，最多为1000次：</p><pre class="oac_no_warn" dir="ltr">SELECT x，s，迭代FROM DUAL MODEL DIMENSION BY（1 AS x）测量（1024 AS，0 AS迭代）规则ITERATE（1000）UNTIL ABS（上一个（s [1]） -  s [1]）&lt;1（ s [1] = s [1] / 2，iterations [1] = ITERATION_NUMBER）;</pre><p>绝对值函数（ <code class="codeph">ABS</code> ）可能有助于终止条件，因为您可能不知道最近的值是正还是负。该模型中的规则将迭代11次，因为在第11次迭代之后， <code class="codeph">s[1]</code>的值将为0.5。对于<code class="codeph">x</code> ， <code class="codeph">s</code>和迭代，此查询分别生成单行，值为1,0.5,10。
                     </p>
                     <p>只能在<code class="codeph">UNTIL</code>条件下使用<code class="codeph">PREVIOUS</code>功能。但是， <code class="codeph">ITERATION_NUMBER</code>可以位于主模型中的任何位置。在以下示例中， <code class="codeph">ITERATION_NUMBER</code>用于单元格引用：</p><pre class="oac_no_warn" dir="ltr">选择国家，产品，年份，销售额FROM sales_view模型分区（国家）维度（产品，年份）措施（销售额）IGNORE NAV RULES ITERATE（3）（销售['Bounce'，2002 + ITERATION_NUMBER] =销售[' Bounce'，1999 + ITERATION_NUMBER]）;</pre><p>该声明实现了从阵列1999-2001到2002-2005中的单元格的Bounce销售的数组副本。</p>
                     <p>视图<code class="codeph">sales_view</code>创建方式如<a href="sql-modeling-data-warehouses.html#GUID-C5C34EFE-B74C-45BA-8D4B-71E527F858F7">SQL模型示例的基本模式中</a>所述。
                     </p>
                  </div>
               </div><a id="DWHSG8794"></a><div class="props_rev_3"><a id="GUID-B0FA1BB9-C7B7-4EF2-82BA-B551B0087999" name="GUID-B0FA1BB9-C7B7-4EF2-82BA-B551B0087999"></a><h4 id="DWHSG-GUID-B0FA1BB9-C7B7-4EF2-82BA-B551B0087999" class="sect4"><span class="enumeration_section">22.3.3</span> AUTOMATIC ORDER模型中的规则依赖性</h4>
                  <div>
                     <p>Oracle数据库根据其依赖关系确定<code class="codeph">AUTOMATIC</code> <code class="codeph">ORDER</code>模型中规则的评估顺序。仅在评估其依赖的规则后才评估规则。选择用于评估规则的算法基于依赖性分析以及模型中的规则是否具有循环（或循环）依赖性。循环依赖可以是“规则A取决于B而规则B取决于A”或自循环“规则取决于其自身”形式的形式。前者的一个例子是：</p><pre class="oac_no_warn" dir="ltr">sales ['Bounce'，2002] = 1.5 * sales ['Y Box'，2002]，sales ['Y Box'，2002] = 100000 / sales ['Bounce'，2002</pre><p>后者的一个例子是：</p><pre class="oac_no_warn" dir="ltr">销售['Bounce'，2002] = 25000 / sales ['Bounce'，2002]</pre><p>但是，由于在左侧和右侧访问了不同的措施，因此以下规则中没有自行循环：</p><pre class="oac_no_warn" dir="ltr">projected_sales ['Bounce'，2002] = 25000 / sales ['Bounce'，2002]</pre><p>当对<code class="codeph">AUTOMATIC</code> <code class="codeph">ORDER</code>模型的分析发现规则没有循环依赖关系时，Oracle数据库会按其依赖顺序评估规则。例如，在以下<code class="codeph">AUTOMATIC</code> <code class="codeph">ORDER</code>模型中：</p><pre class="oac_no_warn" dir="ltr">MODEL DIMENSION BY（prod，year）措施（销售）IGNORE NAV RULES AUTOMATIC ORDER（销售['SUV'，2001] = 10000，销售['标准鼠标垫'，2001] =销售['Finding Fido'，2001] * 0.10 +销售['船'，2001] * 0.50，销售['船'，2001] =销售['Finding Fido'，2001] * 0.25 +销售['SUV'，2001] * 0.75，销售['发现Fido'，2001] = 20000）</pre><p>规则2取决于规则3和规则4，而规则3取决于规则1和规则4，规则1和规则4不依赖于规则。在这种情况下，Oracle会发现规则依赖关系是非循环的，并在一个可能的评估顺序（1,4,3,2）或（4,1,3,2）中评估规则。这种类型的规则评估称为<code class="codeph">ACYCLIC</code>算法。
                     </p>
                     <p>在某些情况下，即使规则之间没有周期性依赖关系，Oracle数据库也可能无法确定您的模型是非循环的。如果在单元格引用中有复杂的表达式，则会发生这种情况。Oracle数据库假定规则是循环的，并采用<code class="codeph">CYCLIC</code>算法，该算法根据规则和数据迭代地评估模型。一旦达到收敛并且返回结果，迭代就会停止。收敛定义为模型的进一步执行不会改变模型中任何单元格的值的状态。当没有周期性依赖时，肯定会达到收敛。
                     </p>
                     <p>如果您的<code class="codeph">AUTOMATIC</code> <code class="codeph">ORDER</code>模型具有具有循环依赖性的规则，则Oracle数据库采用前面提到的<code class="codeph">CYCLIC</code>算法。如果在Oracle将尝试该算法的迭代次数内达到收敛，则会产生结果。否则，Oracle会报告周期检测错误。您可以通过手动排序规则并指定<code class="codeph">SEQUENTIAL</code> <code class="codeph">ORDER</code>来解决此问题。</p>
                  </div>
               </div><a id="DWHSG8796"></a><a id="DWHSG8795"></a><div class="props_rev_3"><a id="GUID-2523C916-C744-46B1-8D53-DF03204EAF85" name="GUID-2523C916-C744-46B1-8D53-DF03204EAF85"></a><h4 id="DWHSG-GUID-2523C916-C744-46B1-8D53-DF03204EAF85" class="sect4"><span class="enumeration_section">22.3.4</span> SQL建模中的有序规则</h4>
                  <div>
                     <p>有序规则是在左侧指定了<code class="codeph">ORDER BY</code>规则。它按<code class="codeph">ORDER BY</code>规定的顺序访问单元格并应用右侧计算。如果规则左侧有<code class="codeph">ANY</code>符号或符号引用但没有<code class="codeph">ORDER BY</code>子句，Oracle可能会返回错误，指出规则的结果取决于访问单元格的顺序，因此是非确定性的。请考虑以下<code class="codeph">SEQUENTIAL ORDER</code>模型：</p><pre class="oac_no_warn" dir="ltr">SELECT t，s FROM sales，times WHERE sales.time_id = times.time_id GROUP BY calendar_year MODEL DIMENSION BY（calendar_year t）MEASURES（SUM（amount_sold）s）规则序列顺序（s [ANY] = s [CV（t） - 1]）;</pre><p>该查询试图建立，为所有年<code class="codeph">t</code> ，销售<code class="codeph">s</code>值一年上一年的销售值。不幸的是，此规则的结果取决于访问单元格的顺序。如果以年份的升序访问单元格，则结果将是<a href="sql-modeling-data-warehouses.html#GUID-2523C916-C744-46B1-8D53-DF03204EAF85__CHDGBCFI" title="此表显示使用SEQUENTIAL ORDER的查询结果。">表22-1中第</a> 3列的结果。如果按降序访问它们，结果将是第4列的结果。
                     </p>
                     <div class="tblformal" id="GUID-2523C916-C744-46B1-8D53-DF03204EAF85__CHDGBCFI">
                        <p class="titleintable">表22-1有序规则</p>
                        <table cellpadding="4" cellspacing="0" class="Formal" title="订购规则" width="100%" border="1" summary="This table displays results of a query that uses SEQUENTIAL ORDER." frame="hsides" rules="rows">
                           <thead>
                              <tr align="left" valign="top">
                                 <th align="left" valign="bottom" width="21%" id="d90648e3520">Ť</th>
                                 <th align="left" valign="bottom" width="25%" id="d90648e3523">小号</th>
                                 <th align="left" valign="bottom" width="23%" id="d90648e3526">如果提升</th>
                                 <th align="left" valign="bottom" width="31%" id="d90648e3529">如果下降</th>
                              </tr>
                           </thead>
                           <tbody>
                              <tr align="left" valign="top">
                                 <td align="left" valign="top" width="21%" id="d90648e3534" headers="d90648e3520 ">
                                    <p>1998年</p>
                                 </td>
                                 <td align="left" valign="top" width="25%" headers="d90648e3534 d90648e3523 ">
                                    <p>1210000982</p>
                                 </td>
                                 <td align="left" valign="top" width="23%" headers="d90648e3534 d90648e3526 ">
                                    <p>空值</p>
                                 </td>
                                 <td align="left" valign="top" width="31%" headers="d90648e3534 d90648e3529 ">
                                    <p>空值</p>
                                 </td>
                              </tr>
                              <tr align="left" valign="top">
                                 <td align="left" valign="top" width="21%" id="d90648e3547" headers="d90648e3520 ">
                                    <p>1999年</p>
                                 </td>
                                 <td align="left" valign="top" width="25%" headers="d90648e3547 d90648e3523 ">
                                    <p>1473757581</p>
                                 </td>
                                 <td align="left" valign="top" width="23%" headers="d90648e3547 d90648e3526 ">
                                    <p>空值</p>
                                 </td>
                                 <td align="left" valign="top" width="31%" headers="d90648e3547 d90648e3529 ">
                                    <p>1210000982</p>
                                 </td>
                              </tr>
                              <tr align="left" valign="top">
                                 <td align="left" valign="top" width="21%" id="d90648e3560" headers="d90648e3520 ">
                                    <p>2000</p>
                                 </td>
                                 <td align="left" valign="top" width="25%" headers="d90648e3560 d90648e3523 ">
                                    <p>2376222384</p>
                                 </td>
                                 <td align="left" valign="top" width="23%" headers="d90648e3560 d90648e3526 ">
                                    <p>空值</p>
                                 </td>
                                 <td align="left" valign="top" width="31%" headers="d90648e3560 d90648e3529 ">
                                    <p>1473757581</p>
                                 </td>
                              </tr>
                              <tr align="left" valign="top">
                                 <td align="left" valign="top" width="21%" id="d90648e3573" headers="d90648e3520 ">
                                    <p>2001年</p>
                                 </td>
                                 <td align="left" valign="top" width="25%" headers="d90648e3573 d90648e3523 ">
                                    <p>1267107764</p>
                                 </td>
                                 <td align="left" valign="top" width="23%" headers="d90648e3573 d90648e3526 ">
                                    <p>空值</p>
                                 </td>
                                 <td align="left" valign="top" width="31%" headers="d90648e3573 d90648e3529 ">
                                    <p>2376222384</p>
                                 </td>
                              </tr>
                           </tbody>
                        </table>
                     </div>
                     <!-- class="inftblhruleinformal" -->
                     <p>如果希望按降序考虑单元格并获得第4列中给出的结果，则应指定：</p><pre class="oac_no_warn" dir="ltr">SELECT t，s FROM sales，times WHERE sales.time_id = times.time_id GROUP BY calendar_year MODEL DIMENSION BY（calendar_year t）MEASURES（SUM（amount_sold）s）规则序列顺序（s [ANY] ORDER BY t DESC = s [CV] （吨）-1]）;</pre><p>通常，只要在与左侧单元格引用匹配的单元格中生成唯一顺序，您就可以使用任何<code class="codeph">ORDER</code> <code class="codeph">BY</code>规范。规则的<code class="codeph">ORDER</code> <code class="codeph">BY</code>中的表达式可以包含常量，度量和维度键，您可以指定排序选项<code class="codeph">[ASC | DESC] [NULLS FIRST | NULLS LAST]</code>获得你想要的订单。
                     </p>
                     <p>您还可以在<code class="codeph">AUTOMATIC</code> <code class="codeph">ORDER</code>模型中为规则指定<code class="codeph">ORDER</code> <code class="codeph">BY</code> ，以使Oracle在规则评估期间按特定顺序考虑单元格。如果规则具有<code class="codeph">ORDER</code> <code class="codeph">BY</code>则规则永远不会被视为自循环。例如，要使用自循环公式进行以下<code class="codeph">AUTOMATIC</code> <code class="codeph">ORDER</code>模型非循环：</p><pre class="oac_no_warn" dir="ltr">模型维数BY（calendar_year t）MEASURES（SUM（amount_sold）s）规则自动顺序（s [ANY] = s [CV（t）-1]）</pre><p>您必须使用<code class="codeph">ORDER</code> <code class="codeph">BY</code>提供需要访问单元格以进行评估的顺序。例如，您可以说：</p><pre class="oac_no_warn" dir="ltr">s [ANY] ORDER BY t = s [CV（t） -  1]</pre><p>然后Oracle数据库选择一个<code class="codeph">ACYCLIC</code>算法（肯定会产生结果）进行公式评估。
                     </p>
                  </div>
               </div><a id="DWHSG0224"></a><div class="props_rev_3"><a id="GUID-6B79CCE3-69E2-444C-84BE-50672330C546" name="GUID-6B79CCE3-69E2-444C-84BE-50672330C546"></a><h4 id="DWHSG-GUID-6B79CCE3-69E2-444C-84BE-50672330C546" class="sect4"><span class="enumeration_section">22.3.5</span> SQL建模中的分析函数</h4>
                  <div>
                     <p><a id="d90648e3672" class="indexterm-anchor"></a><a id="d90648e3674" class="indexterm-anchor"></a><a id="d90648e3678" class="indexterm-anchor"></a><a id="d90648e3680" class="indexterm-anchor"></a>分析函数（也称为窗口函数）可以在规则的右侧使用。使用分析函数的能力为<code class="codeph">MODEL</code>子句增加了表达能力和灵活性。以下示例将分析函数与<code class="codeph">MODEL</code>子句组合在一起。首先，创建一个视图<code class="codeph">sales_rollup_time</code> ，它使用<code class="codeph">GROUPING_ID</code>函数计算不同聚合级别的标识符。然后，您可以在查询中使用该视图来计算季度和年度级别的累计销售额。
                     </p><pre class="oac_no_warn" dir="ltr">创建或替换视图sales_rollup_time AS SELECT country_name country，calendar_year year，calendar_quarter_desc quarter，GROUPING_ID（calendar_year，calendar_quarter_desc）gid，SUM（amount_sold）sale，COUNT（amount_sold）cnt FROM sales，times，customers，countries WHERE sales.time_id = times。 time_id AND sales.cust_id = customers.cust_id AND customers.country_id = countries.country_id GROUP BY country_name，calendar_year，ROLLUP（calendar_quarter_desc）ORDER BY gid，country，year，quarter; SELECT country，year，quarter，sale，csum FROM sales_rollup_time WHERE country IN（'United States of America'，'United Kingdom'）MODEL DIMENSION BY（country，year，quarter）MEASURES（sale，gid，0 csum）（csum [任何，任何，任何] = SUM（销售）OVER（按国家划分，解码（gid，0，年，null）按年份划分，按季度划分无限期预算））按国家，gid，年份，季度排序;国家季度销售CSUM ------------------------------ ---------- ----- -  ---------- ----------英国1998 1998-01 484733.96 484733.96英国1998 1998-02 386899.15 871633.11英国1998 1998-03 402296.49 1273929.6英国1998 1998 -04 384747.94 1658677.54英国1999 1999-01 394911.91 394911.91英国1999 1999-02 331068.38 725980.29英国1999 1999-03 383982.61 1109962.9英国1999 1999-04 398147.59 1508110.49英国2000 2000-01 424771.96 424771.96英国2000 2000-02 351400.62 776172.58英国2000 2000-03 385137.68 1161310.26英国2000 2000-04 390912.8 1552223.06英国2001 2001-01 343468.77 343468.77英国2001 2001-02 415168.32 758637.09英国2001 2001-03 478237.29 1236874.38英国2001 2001-04 437877.47 1674751.85英国1998 1658677.54 1658677.54英国1999 1508110.49 3166788.03英国2000 1552223.06 4719011.0 9英国2001 1674751.85 6393762.94 ... / *和美国的类似输出* /</pre><p>使用分析函数时存在一些特定限制。有关详细信息，请参阅<span class="q">“ <a href="sql-modeling-data-warehouses.html#GUID-AD6A9B81-492F-4724-9517-7758C4A98365">使用SQL进行建模时的规则和限制</a> ”</span> 。
                     </p>
                  </div>
               </div><a id="DWHSG8797"></a><div class="props_rev_3"><a id="GUID-C3F6B53D-5BBE-48CB-83DD-C6E2587CDED8" name="GUID-C3F6B53D-5BBE-48CB-83DD-C6E2587CDED8"></a><h4 id="DWHSG-GUID-C3F6B53D-5BBE-48CB-83DD-C6E2587CDED8" class="sect4"><span class="enumeration_section">22.3.6</span>独特的维度与SQL建模中的唯一单引用</h4>
                  <div>
                     <p><code class="codeph">MODEL</code>子句在其默认行为中，需要<code class="codeph">PARTITION</code> <code class="codeph">BY</code>和<code class="codeph">DIMENSION</code> <code class="codeph">BY</code>键来唯一标识模型输入中的每一行。如果数据不唯一，Oracle会验证并返回错误。<code class="codeph">PARTITION</code> <code class="codeph">BY</code>和<code class="codeph">DIMENSION</code> <code class="codeph">BY</code>键上的输入行集的唯一性可确保任何单个单元格引用访问模型中的一个且仅一个单元格。您可以在<code class="codeph">MODEL</code>子句中指定可选的<code class="codeph">UNIQUE</code> <code class="codeph">DIMENSION</code>关键字，以使此行为显式化。例如，以下查询在视图<code class="codeph">sales_view</code>上运行，该视图是按照<a href="sql-modeling-data-warehouses.html#GUID-C5C34EFE-B74C-45BA-8D4B-71E527F858F7">SQL建模示例的基本模式中</a>所述创建的：</p><pre class="oac_no_warn" dir="ltr">SELECT国家，产品，销售FROM sales_view国家IN（'法国'，'波兰'）模型独特尺寸分区（国家）尺寸乘（产品）措施（销售额）IGNORE NAV RULES UPSERT（销售['Bounce'] =销售['所有产品'] * 0.24）;</pre><p>这将返回唯一性违规错误，因为对模型的行集输入在<code class="codeph">country</code>和<code class="codeph">product</code>上不是唯一的，因为还需要<code class="codeph">year</code> ：</p><pre class="oac_no_warn" dir="ltr">第2行的错误：ORA-32638：MODEL维度中的非唯一寻址</pre><p>但是，以下查询不会返回此类错误：</p><pre class="oac_no_warn" dir="ltr">SELECT国家，产品，年份，销售FROM sales_view国家IN（'意大利'，'日本'）模型独特尺寸分区（国家）尺寸乘以（产品，年份）措施（销售）规则UPSERT（销售['Bounce' ，2003] =销售['所有产品'，2002] * 0.24）;</pre><p>在这种情况下， <code class="codeph">MODEL</code>子句的输入在<code class="codeph">country</code> ， <code class="codeph">product</code>和<code class="codeph">year</code>上是唯一的，如下所示：</p><pre class="oac_no_warn" dir="ltr">国家产品年销售额------- ----------------------------- ---- ------ - 意大利1.44MB外部3.5“Diskette 1998 3141.84意大利1.44MB外部3.5”Diskette 1999 3086.87意大利1.44MB外部3.5“Diskette 2000 3440.37意大利1.44MB外部3.5”Diskette 2001 855.23 ...
</pre><p>如果要放宽此唯一性检查，可以指定<code class="codeph">UNIQUE</code> <code class="codeph">SINGLE</code> <code class="codeph">REFERENCE</code>关键字。这可以节省处理时间。在这种情况下， <code class="codeph">MODEL</code>子句仅检查出现在规则右侧的单个单元格引用的唯一性。因此，如果指定<code class="codeph">UNIQUE</code> <code class="codeph">SINGLE</code> <code class="codeph">REFERENCE</code>而不是<code class="codeph">UNIQUE</code> <code class="codeph">DIMENSION</code> ，则返回唯一性违规错误的查询将会成功。</p>
                     <p><code class="codeph">UNIQUE</code> <code class="codeph">DIMENSION</code>和<code class="codeph">UNIQUE</code> <code class="codeph">SINGLE</code> <code class="codeph">REFERENCE</code>语义之间的另一个区别是左侧可以通过单个单元格引用的规则更新的单元格数。在<code class="codeph">UNIQUE</code> <code class="codeph">DIMENSION</code>的情况下，这样的规则最多可以更新一行，因为只有一个单元格与左侧的单个单元格引用匹配。这是因为输入行集在<code class="codeph">PARTITION</code> <code class="codeph">BY</code>和<code class="codeph">DIMENSION</code> <code class="codeph">BY</code>键上是唯一的。使用<code class="codeph">UNIQUE</code> <code class="codeph">SINGLE</code> <code class="codeph">REFERENCE</code> ，规则将更新与左侧单个单元格引用匹配的所有单元格。
                     </p>
                  </div>
               </div><a id="DWHSG0225"></a><div class="props_rev_3"><a id="GUID-AD6A9B81-492F-4724-9517-7758C4A98365" name="GUID-AD6A9B81-492F-4724-9517-7758C4A98365"></a><h4 id="DWHSG-GUID-AD6A9B81-492F-4724-9517-7758C4A98365" class="sect4"><span class="enumeration_section">22.3.7</span>使用SQL进行建模时的规则和限制</h4>
                  <div>
                     <div class="section">
                        <p>使用<code class="codeph">MODEL</code>子句时，适用一般规则和限制：</p>
                        <ul style="list-style-type:disc">
                           <li>
                              <p>唯一可以更新的列是主SQL模型的<code class="codeph">MEASURES</code>子句中指定的列。无法更新参考模型的度量。
                              </p>
                           </li>
                           <li>
                              <p>除了<code class="codeph">SELECT</code> <code class="codeph">DISTINCT</code>和<code class="codeph">ORDER</code> <code class="codeph">BY</code>子句之外，在查询块中的所有子句之后计算<code class="codeph">MODEL</code>子句。<code class="codeph">SELECT</code>列表中的这些子句和表达式在<code class="codeph">MODEL</code>子句之后进行计算。
                              </p>
                           </li>
                           <li>
                              <p>如果您的查询具有<code class="codeph">MODEL</code>子句，则查询的<code class="codeph">SELECT</code>和<code class="codeph">ORDER</code> <code class="codeph">BY</code>列表不能包含聚合或分析函数。如果需要，可以在<code class="codeph">PARTITION</code> <code class="codeph">BY</code> ， <code class="codeph">DIMENSION</code> <code class="codeph">BY</code>和<code class="codeph">MEASURES</code>列表中指定这些，并且需要使用别名。然后可以在<code class="codeph">SELECT</code>或<code class="codeph">ORDER</code> <code class="codeph">BY</code>子句中使用别名。在下面的示例中，分析函数<code class="codeph">RANK</code>在<code class="codeph">MODEL</code>子句的<code class="codeph">MEASURES</code>列表中指定和别名，并且其别名在<code class="codeph">SELECT</code>列表中使用，以便外部查询可以根据其排名对结果行进行排序。
                              </p><pre class="oac_no_warn" dir="ltr">SELECT country，product，year，s，RNK FROM（SELECT country，product，year，s，rnk FROM sales_view MODEL PARTITION BY（country）DIMENSION BY（product，year）MEASURES（sales s，year y，RANK（）OVER（按销售顺序）rnkES UPSERT（s ['Bounce Increase 90-99'，2001] = REGR_SLOPE（s，y）['Bounce'，1990年和2000年之间的年份]，s ['Bounce'，2001] = s ['弹跳'，2000] *（1 + s ['弹跳增加90-99'，2001]）））产品&lt;&gt;'弹跳增加90-99'按国家，年份，rnk，产品订购;</pre></li>
                           <li>
                              <p>如果规则右侧有多单元格引用，则需要应用函数来聚合引用为单个值的多个单元格的度量值。您可以为此目的使用任何类型的聚合函数：常规，分析聚合（反百分位数，假设排名和分布）或用户定义的聚合。</p>
                           </li>
                           <li>
                              <p>左侧只有位置单个单元格引用的规则具有<code class="codeph">UPSERT</code>语义。所有其他规则都具有<code class="codeph">UPDATE</code>语义，即使您为它们指定了<code class="codeph">UPSERT</code>选项也是如此。
                              </p>
                           </li>
                           <li>
                              <p><code class="codeph">FOR</code>循环中不允许负增量。此外，不允许空<code class="codeph">FOR</code>循环。<code class="codeph">FOR d FROM 2005 TO 2001 INCREMENT -1</code>是非法的。您应该使用<code class="codeph">FOR d FROM 2005 TO 2001 DECREMENT 1</code> 。<code class="codeph">FOR d FROM 2005 TO 2001 INCREMENT 1</code>是非法的，因为它指定一个空循环。
                              </p>
                           </li>
                           <li>
                              <p>除了<code class="codeph">FOR</code>构造之外，您不能在规则中使用嵌套查询表达式（子查询）。例如，发布以下内容是非法的：</p><pre class="oac_no_warn" dir="ltr">SELECT * FROM sales_view WHERE country ='Poland'MODEL DIMENSION BY（产品，年份）MEASURES（销售额）RULES UPSERT（销售['Bounce'，2003] =销售['Bounce'，2002] +（SELECT SUM（销售）来自sales_view））;</pre><p>这是因为规则右侧有子查询。相反，您可以通过以下合法方式重写前面的查询：</p><pre class="oac_no_warn" dir="ltr">SELECT * FROM sales_view WHERE country ='Poland'MODEL DIMENSION BY（产品，年份）MEASURES（销售销售，（SELECT SUM（销售）FROM sales_view）AS grand_total）RULES UPSERT（销售['Bounce'，2003] =销售[' Bounce'，2002] + grand_total ['Bounce'，2002]）;</pre></li>
                           <li>
                              <p>您还可以在规则左侧指定的<code class="codeph">FOR</code>构造中使用子查询。但是，他们：</p>
                              <ul style="list-style-type:disc">
                                 <li>
                                    <p>无法相关</p>
                                 </li>
                                 <li>
                                    <p>必须返回少于10,000行</p>
                                 </li>
                                 <li>
                                    <p>不能是<code class="codeph">WITH</code>子句中定义的查询</p>
                                 </li>
                                 <li>
                                    <p>会使光标变得不可用</p>
                                 </li>
                              </ul>
                           </li>
                        </ul>
                        <p>嵌套单元格引用具有以下限制：</p>
                        <ul style="list-style-type:disc">
                           <li>
                              <p>嵌套单元格引用必须是单个单元格引用。不支持嵌套单元格引用的聚合。因此，说<code class="codeph">s['Bounce', MAX(best_year)['Bounce', ANY]]</code>是违法的。
                              </p>
                           </li>
                           <li>
                              <p>主模型上的嵌套单元格引用仅支持一个嵌套级别。所以，例如， <code class="codeph">s['Bounce', best_year['Bounce', 2001]]</code>是合法的，但<code class="codeph">s['Bounce', best_year['Bounce', best_year['Bounce', 2001]]]</code>不是。
                              </p>
                           </li>
                           <li>
                              <p>不应在模型的任何规则中更新出现在<code class="codeph">AUTOMATIC</code> <code class="codeph">ORDER</code>模型中规则左侧的嵌套单元格引用。此限制可确保规则依赖关系不会因参考度量的更新而任意更改（从而导致非确定性结果）。
                              </p>
                              <p><code class="codeph">SEQUENTIAL</code> <code class="codeph">ORDER</code>模型中的嵌套单元格引用没有此类限制。此外，此限制不适用于<code class="codeph">SEQUENTIAL</code>或<code class="codeph">AUTOMATIC</code> <code class="codeph">ORDER</code>模型中规则右侧出现的嵌套引用。
                              </p>
                           </li>
                        </ul>
                        <p>参考模型具有以下限制：</p>
                        <ul style="list-style-type:disc">
                           <li>
                              <p>定义参考模型的查询无法与任何外部查询相关联。但是，它可以是包含子查询，视图等的查询。</p>
                           </li>
                           <li>
                              <p>参考模型不能有<code class="codeph">PARTITION</code> <code class="codeph">BY</code>子句。
                              </p>
                           </li>
                           <li>
                              <p>参考模型无法更新。</p>
                           </li>
                        </ul>
                        <p>窗口函数具有以下限制：</p>
                        <ul style="list-style-type:disc">
                           <li>
                              <p><code class="codeph">OVER</code>子句中的表达式可以是常量，度量，来自<code class="codeph">MODEL</code>子句的<code class="codeph">PARTITION</code> <code class="codeph">BY</code>和<code class="codeph">DIMENSION</code> <code class="codeph">BY</code>的键以及单个单元格表达式的表达式。<code class="codeph">OVER</code>子句中不允许聚合。因此，以下是可以的：</p><pre class="oac_no_warn" dir="ltr">rnk [ANY，ANY，ANY] = RANK（）OVER（按产品分类，按国家/地区销售）</pre><p>虽然以下不是：</p><pre class="oac_no_warn" dir="ltr">rnk [ANY，ANY，ANY] = RANK（）OVER（按国际划分，国家订单按SUM计算）</pre></li>
                           <li>
                              <p>右侧带窗口函数的规则左侧不能有<code class="codeph">ORDER</code> <code class="codeph">BY</code>子句。
                              </p>
                           </li>
                           <li>
                              <p>窗口函数和聚合函数不能同时位于规则的右侧。</p>
                           </li>
                           <li>
                              <p>窗口函数只能在<code class="codeph">UPDATE</code>规则的右侧使用。
                              </p>
                           </li>
                           <li>
                              <p>如果规则的左侧有<code class="codeph">FOR</code>循环，则不能在规则的右侧使用窗口函数。
                              </p>
                           </li>
                        </ul>
                     </div>
                     <!-- class="section" -->
                  </div>
               </div>
            </div><a id="DWHSG0226"></a><div class="props_rev_3"><a id="GUID-983B5378-4FCA-4452-B615-3A39B491F1E4" name="GUID-983B5378-4FCA-4452-B615-3A39B491F1E4"></a><h3 id="DWHSG-GUID-983B5378-4FCA-4452-B615-3A39B491F1E4" class="sect3"><span class="enumeration_section">22.4</span> SQL建模的性能注意事项</h3>
               <div>
                  <p>该<a id="d90648e4213" class="indexterm-anchor"></a>以下部分描述了在使用<code class="codeph">MODEL</code>子句时影响性能的主题：</p>
                  <ul style="list-style-type:disc">
                     <li>
                        <p><a href="sql-modeling-data-warehouses.html#GUID-703FA761-BFB3-467D-BB48-41C95E4E1879">并行执行和SQL建模</a></p>
                     </li>
                     <li>
                        <p><a href="sql-modeling-data-warehouses.html#GUID-4BBCBDA9-2B4E-41A6-A313-345806591206">聚合计算和SQL建模</a></p>
                     </li>
                     <li>
                        <p><a href="sql-modeling-data-warehouses.html#GUID-30A0D201-BAD0-4E27-A0FF-332B5531C45B">使用EXPLAIN PLAN来理解模型查询</a></p>
                     </li>
                  </ul>
               </div><a id="DWHSG8798"></a><div class="props_rev_3"><a id="GUID-703FA761-BFB3-467D-BB48-41C95E4E1879" name="GUID-703FA761-BFB3-467D-BB48-41C95E4E1879"></a><h4 id="DWHSG-GUID-703FA761-BFB3-467D-BB48-41C95E4E1879" class="sect4"><span class="enumeration_section">22.4.1</span>并行执行和SQL建模</h4>
                  <div>
                     <p><code class="codeph">MODEL</code> c lause计算可根据您拥有的处理器数量进行扩展。通过在<code class="codeph">PARTITION</code> <code class="codeph">BY</code>子句定义的分区上并行执行<code class="codeph">MODEL</code>计算来实现可伸缩性。数据是基于所述处理元件（也称为并行查询从站）之间分配<code class="codeph">PARTITION</code> <code class="codeph">BY</code>这样的键的值，与对于相同的值的所有行<code class="codeph">PARTITION</code> <code class="codeph">BY</code>键将去到相同的从站。请注意，分区的内部处理不会创建逻辑和内部处理的分区的一对一匹配。这样，每个从站都可以独立于其他从站完成<code class="codeph">MODEL</code>子句计算。数据分区可以基于散列或基于范围。考虑以下<code class="codeph">MODEL</code>子句：</p><pre class="oac_no_warn" dir="ltr">模型分区（国家）维度（产品，时间）措施（销售）规则更新（销售['Bounce'，2002] = 1.2 *销售['Bounce'，2001]，销售['Car'，2002] = 0.8 *销售['汽车'，2001]）</pre><p>这里输入数据将基于<code class="codeph">PARTITION</code> <code class="codeph">BY</code>密钥<code class="codeph">country</code>在从属服务器之间进行分区，并且此分区可以是散列或基于范围的。每个从站将评估其收到的数据的规则。
                     </p>
                     <p>模型计算的并行性受指定<code class="codeph">MODEL</code>子句的方式控制或限制。如果您的<code class="codeph">MODEL</code>子句没有<code class="codeph">PARTITION</code> <code class="codeph">BY</code>键，则无法并行计算（下面提到的例外情况）。如果<code class="codeph">PARTITION</code> <code class="codeph">BY</code>键具有非常低的基数，则并行度将受到限制。在这种情况下，Oracle会识别可用于分区的<code class="codeph">DIMENSION</code> <code class="codeph">BY</code>键。例如，考虑一个与前一个相当的<code class="codeph">MODEL</code>子句，但没有<code class="codeph">PARTITION</code> <code class="codeph">BY</code>键，如下所示：</p><pre class="oac_no_warn" dir="ltr">模型尺寸（国家，产品，时间）措施（销售）规则更新（销售[ANY，'Bounce'，2002] = 1.2 *销售[CV（国家），'Bounce'，2001]，销售[ANY，'Car '，2002'= 0.8 *销售[CV（国家），'汽车'，2001]）</pre><p>在这种情况下，Oracle数据库确定它可以使用<code class="codeph">DIMENSION</code> <code class="codeph">BY</code>密钥<code class="codeph">country</code>进行分区，并使用<code class="codeph">region</code>作为内部分区的基础。它在<code class="codeph">country</code>之间对从属数据进行分区，从而实现并行执行。
                     </p>
                  </div>
               </div><a id="DWHSG8799"></a><div class="props_rev_3"><a id="GUID-4BBCBDA9-2B4E-41A6-A313-345806591206" name="GUID-4BBCBDA9-2B4E-41A6-A313-345806591206"></a><h4 id="DWHSG-GUID-4BBCBDA9-2B4E-41A6-A313-345806591206" class="sect4"><span class="enumeration_section">22.4.2</span>聚合计算和SQL建模</h4>
                  <div>
                     <p><code class="codeph">MODEL</code>子句以两种不同的方式处理聚合：第一种是扫描和聚合分区中的数据的常规方式，第二种是有效的窗口样式聚合。下面介绍的第一种类型引入了一个新的维度成员ALL_2002_products，并将其值计算为所有产品的2002年销售额的总和：</p><pre class="oac_no_warn" dir="ltr">模型分区（国家）维度（产品，时间）措施（销售销售）规则UPSERT（销售['ALL_2002_products'，2002] = SUM（销售）[ANY，2002]）</pre><p>为了评估这种情况下的总和，将扫描每个分区以查找所有产品的2002单元格，并将对它们进行汇总。如果规则的左侧是引用多个单元格，则Oracle必须通过扫描左侧引用的每个单元格的分区来计算右侧聚合。例如，请考虑以下示例：</p><pre class="oac_no_warn" dir="ltr">模型分区（国家）维度（产品，时间）措施（销售额，0 avg_exclusive）规则更新（avg_exclusive [ANY，2002] = AVG（销售）[产品&lt;&gt;简历（产品），简历（时间）]）</pre><p>此规则为2002年的每个产品计算一个名为<code class="codeph">avg_exclusive</code>的度量。度量<code class="codeph">avg_exclusive</code>定义为除当前产品外的所有产品的平均销售额。在这种情况下，Oracle在2002年为每个产品扫描分区中的数据以计算聚合，这可能很昂贵。
                     </p>
                     <p>Oracle数据库在某些情况下使用分析函数中使用的窗口式计算来优化此类聚合的评估。这些场景涉及左侧具有多单元引用的规则和计算窗口计算，例如移动平均值，累积总和等。请考虑以下示例：</p><pre class="oac_no_warn" dir="ltr">模型分区（国家）维度（产品，时间）措施（销售销售，0 mavg）规则更新（mavg [产品IN（'Bounce'，'Y Box'，'鼠标垫'），ANY] = AVG（销售额） ）[CV（产品），时间缩短CV（时间）和CV（时间） -  2]）</pre><p>它计算三年内产品Bounce，Y Box和Mouse Pad的销售移动平均值。通过扫描左侧引用的每个单元的分区来评估聚合是非常低效的。Oracle将计算标识为窗口样式并有效地对其进行评估。它对产品，时间的输入进行排序，然后扫描数据一次以计算移动平均值。您可以将此规则视为应用于产品Bounce，Y Box和Mouse Pad的销售数据的分析函数：</p><pre class="oac_no_warn" dir="ltr">AVG（销售）超过（按产品排序按时间顺序排列2前进和当前行）</pre><p>此计算样式称为<code class="codeph">WINDOW (IN MODEL) SORT</code> 。当规则左侧有多单元格引用但没有<code class="codeph">ORDER</code> <code class="codeph">BY</code> ，这种聚合方式适用，右侧有一个简单的聚合（ <code class="codeph">SUM</code> ， <code class="codeph">COUNT</code> ， <code class="codeph">MIN</code> ， <code class="codeph">MAX</code> ， <code class="codeph">STDEV</code>和<code class="codeph">VAR</code> ），只有一个维度在右侧有一个布尔谓词（ <code class="codeph">&lt;</code> ， <code class="codeph">&lt;=</code> ， <code class="codeph">&gt;</code> ， <code class="codeph">&gt;=</code> ， <code class="codeph">BETWEEN</code> ），右边的所有其他维度都用<code class="codeph">CV</code>限定。</p>
                  </div>
               </div><a id="DWHSG8800"></a><div class="props_rev_3"><a id="GUID-30A0D201-BAD0-4E27-A0FF-332B5531C45B" name="GUID-30A0D201-BAD0-4E27-A0FF-332B5531C45B"></a><h4 id="DWHSG-GUID-30A0D201-BAD0-4E27-A0FF-332B5531C45B" class="sect4"><span class="enumeration_section">22.4.3</span>使用EXPLAIN PLAN理解模型查询</h4>
                  <div>
                     <div class="section">
                        <p>Oracle的解释计划工具完全了解模型。您将在查询的主要解释计划输出中看到一行，显示模型和使用的算法。参考模型在计划输出中使用关键字<code class="codeph">REFERENCE</code>进行标记。此外，如果任何规则有资格进行窗口式聚合计算，Oracle会使用<code class="codeph">WINDOW (IN MODEL) SORT</code>注释该计划。
                        </p>
                        <p>通过检查解释计划，您可以找到选择用于评估模型的算法。如果模型具有<code class="codeph">SEQUENTIAL</code> <code class="codeph">ORDER</code>语义，则显示<code class="codeph">ORDERED</code> 。对于<code class="codeph">AUTOMATIC</code> <code class="codeph">ORDER</code>模型，Oracle根据是选择<code class="codeph">ACYCLIC</code>还是<code class="codeph">CYCLIC</code>算法进行评估来显示<code class="codeph">ACYCLIC</code>或<code class="codeph">CYCLIC</code> 。此外，如果所有左侧单元格引用都是单个单元格引用，则计划输出将在<code class="codeph">ORDERED</code>和<code class="codeph">ACYCLIC</code>算法的情况下具有注释<code class="codeph">FAST</code> ，并且规则右侧的聚合（如果有）是简单的算术非不同聚合，如<code class="codeph">SUM</code> ， <code class="codeph">COUNT</code> ， <code class="codeph">AVG</code>等。在这种情况下，规则评估将是高效的，因此注释<code class="codeph">FAST</code> 。因此，您将在解释计划中看到的输出将为<code class="codeph">MODEL {ORDERED [FAST] | ACYCLIC [FAST] | CYCLIC}</code> 。
                        </p>
                        <p>本节包含以下主题：</p>
                     </div>
                     <!-- class="section" -->
                     <div class="section">
                        <ul style="list-style-type:disc">
                           <li>
                              <p><a href="sql-modeling-data-warehouses.html#GUID-30A0D201-BAD0-4E27-A0FF-332B5531C45B__CHDJHDHC">使用ORDERED FAST：示例</a></p>
                           </li>
                           <li>
                              <p><a href="sql-modeling-data-warehouses.html#GUID-30A0D201-BAD0-4E27-A0FF-332B5531C45B__CHDFHADC">使用ORDERED：示例</a></p>
                           </li>
                           <li>
                              <p><a href="sql-modeling-data-warehouses.html#GUID-30A0D201-BAD0-4E27-A0FF-332B5531C45B__CHDBBCII">使用ACYCLIC FAST：示例</a></p>
                           </li>
                           <li>
                              <p><a href="sql-modeling-data-warehouses.html#GUID-30A0D201-BAD0-4E27-A0FF-332B5531C45B__CHDJABEC">使用ACYCLIC：示例</a></p>
                           </li>
                           <li>
                              <p><a href="sql-modeling-data-warehouses.html#GUID-30A0D201-BAD0-4E27-A0FF-332B5531C45B__CHDDGGEC">使用CYCLIC：示例</a></p>
                           </li>
                        </ul>
                     </div>
                     <!-- class="section" -->
                     <div class="section" id="GUID-30A0D201-BAD0-4E27-A0FF-332B5531C45B__CHDJHDHC">
                        <p class="subhead3" id="GUID-30A0D201-BAD0-4E27-A0FF-332B5531C45B__GUID-48DDF661-809D-42B5-9FE7-55256FE13F4C">使用ORDERED FAST：示例</p>
                        <p>此模型在规则的左侧只有单个单元格引用，第一个规则右侧的聚合<code class="codeph">AVG</code>是一个简单的非不同聚合：</p><pre class="oac_no_warn" dir="ltr">选择国家，产品，年份，销售的解释计划FROM sales_view国家IN（'意大利'，'日本'）模型独特尺寸分区（国家）尺寸乘以（产品，年份）措施（销售额）规则UPSERT（销售[ 'Bounce'，2003] = AVG（销售）[ANY，2002] * 1.24，销售['Y Box'，2003] =销售['Bounce'，2003] * 0.25）;</pre></div>
                     <!-- class="section" -->
                     <div class="section" id="GUID-30A0D201-BAD0-4E27-A0FF-332B5531C45B__CHDFHADC">
                        <p class="subhead3" id="GUID-30A0D201-BAD0-4E27-A0FF-332B5531C45B__GUID-897048E6-BBC9-4C63-9B84-FD1DD2B39772">使用ORDERED：示例</p>
                        <p>由于第二个规则的左侧是多单元格引用，因此不会在以下选择<code class="codeph">FAST</code>方法：</p><pre class="oac_no_warn" dir="ltr">选择国家，产品，年份，销售的解释计划FROM sales_view国家IN（'意大利'，'日本'）模型独特尺寸分区（国家）尺寸乘以（产品，年份）措施（销售额）规则UPSERT（销售[ 'Bounce'，2003] = AVG（销售）[ANY，2002] * 1.24，销售[prod &lt;&gt;'Bounce'，2003] =销售['Bounce'，2003] * 0.25）;</pre></div>
                     <!-- class="section" -->
                     <div class="section" id="GUID-30A0D201-BAD0-4E27-A0FF-332B5531C45B__CHDBBCII">
                        <p class="subhead3" id="GUID-30A0D201-BAD0-4E27-A0FF-332B5531C45B__GUID-7159D42A-3CA2-43F8-8458-8539219D64BD">使用ACYCLIC FAST：示例</p>
                        <p>此模型中的规则不是循环的，解释计划将显示<code class="codeph">ACYCLIC</code> 。在这种情况下也选择<code class="codeph">FAST</code>方法。
                        </p><pre class="oac_no_warn" dir="ltr">选择国家，产品，年份，销售的分析计划FROM sales_view国家IN（'意大利'，'日本'）模型独特尺寸分区（国家）尺寸乘以（产品，年份）措施（销售）规则UPSERT AUTOMATIC ORDER（ sales ['Y Box'，2003] = sales ['Bounce'，2003] * 0.25，sales ['Bounce'，2003] = sales ['Bounce'，2002] / SUM（sales）[ANY，2002] * 2 * sales ['All Products'，2003]，sales ['All Products'，2003] = 200000）;</pre></div>
                     <!-- class="section" -->
                     <div class="section" id="GUID-30A0D201-BAD0-4E27-A0FF-332B5531C45B__CHDJABEC">
                        <p class="subhead3" id="GUID-30A0D201-BAD0-4E27-A0FF-332B5531C45B__GUID-7D82901B-DA7E-4838-AB97-25CFAB78F909">使用ACYCLIC：示例</p>
                        <p>此模型中的规则不是循环的。给出2002年中位数销售额的<code class="codeph">PERCENTILE_DISC</code>汇总在第二条规则中不是简单的汇总函数。因此，Oracle不会选择<code class="codeph">FAST</code>方法，而解释计划只会显示<code class="codeph">ACYCLIC</code> 。</p><pre class="oac_no_warn" dir="ltr">选择国家，产品，年份，销售额FROM sales_view国家IN（'意大利'，'日本'）模型独特尺寸分区（国家）尺寸乘以（产品，年份）措施（销售）规则UPSERT AUTOMATIC ORDER（销售[' Y Box'，2003] = sales ['Bounce'，2003] * 0.25，sales ['Bounce'，2003] = PERCENTILE_DISC（0.5）WITHIN GROUP（ORDER BY sales）[ANY，2002] / SUM（sales）[ANY ，2002] * 2 * sales ['All Products'，2003]，sales ['All Products'，2003] = 200000）;</pre></div>
                     <!-- class="section" -->
                     <div class="section" id="GUID-30A0D201-BAD0-4E27-A0FF-332B5531C45B__CHDDGGEC">
                        <p class="subhead3" id="GUID-30A0D201-BAD0-4E27-A0FF-332B5531C45B__GUID-034BA99E-3248-46D1-985A-6522B0A15789">使用CYCLIC：示例</p>
                        <p>Oracle为此模型选择了<code class="codeph">CYCLIC</code>算法，因为第二个和第三个规则之间存在一个循环。
                        </p><pre class="oac_no_warn" dir="ltr">选择国家，产品，年份，销售的解释计划FROM sales_view国家IN（'意大利'，'日本'）模型独特的尺寸分区（国家）尺寸乘以（产品，年份）措施（销售）IGNORE NAV RULES UPSERT AUTOMATIC订单（销售['所有产品'，2003] = 200000，销售['Y Box'，2003] =销售['Bounce'，2003] * 0.25，销售['Bounce'，2003] =销售['Y Box' ，2003] +（销售['Bounce'，2002] / SUM（销售）[ANY，2002] * 2 * sales ['All Products'，2003]））;</pre></div>
                     <!-- class="section" -->
                  </div>
               </div>
            </div><a id="DWHSG8806"></a><div class="props_rev_3"><a id="GUID-195E4085-EE47-4122-AED6-F358C0C2F716" name="GUID-195E4085-EE47-4122-AED6-F358C0C2F716"></a><h3 id="DWHSG-GUID-195E4085-EE47-4122-AED6-F358C0C2F716" class="sect3"><span class="enumeration_section">22.5</span> SQL建模示例</h3>
               <div>
                  <p>本节中的示例假定除了<code class="codeph">sales_view</code> （在<a href="sql-modeling-data-warehouses.html#GUID-C5C34EFE-B74C-45BA-8D4B-71E527F858F7">SQL建模示例的基本架构中</a>创建）之外，还定义了以下视图。它按产品和国家/地区查找销售额和数量的月度总计。
                  </p><pre class="oac_no_warn" dir="ltr">CREATE VIEW sales_view2 AS SELECT country_name country，prod_name product，calendar_year_name month，SUM（amount_sold）sale，COUNT（amount_sold）cnt FROM sales，times，customers，countries，products WHERE sales.time_id = times.time_id AND sales.prod_id = products.prod_id AND sales.cust_id = customers.cust_id AND customers.country_id = countries.country_id GROUP BY country_name，prod_name，calendar_year，calendar_month_name;</pre><p>本节包含以下示例：</p>
                  <ul style="list-style-type:disc">
                     <li>
                        <p><a href="sql-modeling-data-warehouses.html#GUID-0EA4B496-C9D5-4596-A727-3CB15853E245">SQL建模示例1：计算销售差异</a></p>
                     </li>
                     <li>
                        <p><a href="sql-modeling-data-warehouses.html#GUID-B287E2D2-6983-4A6C-B6CC-6A27C0100A37">SQL建模示例2：计算百分比变化</a></p>
                     </li>
                     <li>
                        <p><a href="sql-modeling-data-warehouses.html#GUID-7A067A66-3F08-4747-AC17-1A0BD41D406F">SQL建模示例3：计算净现值</a></p>
                     </li>
                     <li>
                        <p><a href="sql-modeling-data-warehouses.html#GUID-A768891C-B572-4860-890A-85143BFEBF9C">SQL建模示例4：使用联立方程计算</a></p>
                     </li>
                     <li>
                        <p><a href="sql-modeling-data-warehouses.html#GUID-DF19701F-FB63-4AA0-A285-F337DC9D6203">SQL建模示例5：使用回归计算</a></p>
                     </li>
                     <li>
                        <p><a href="sql-modeling-data-warehouses.html#GUID-6EACDDD4-96CE-456F-B2C2-3374E05EA96C">SQL建模示例6：计算抵押摊销</a></p>
                     </li>
                  </ul>
               </div><a id="DWHSG9207"></a><div class="props_rev_3"><a id="GUID-0EA4B496-C9D5-4596-A727-3CB15853E245" name="GUID-0EA4B496-C9D5-4596-A727-3CB15853E245"></a><h4 id="DWHSG-GUID-0EA4B496-C9D5-4596-A727-3CB15853E245" class="sect4"><span class="enumeration_section">22.5.1</span> SQL建模示例1：计算销售差异</h4>
                  <div>
                     <div class="section">
                        <p>显示意大利和西班牙的销售额以及每种产品的两者之间的差异。差异应放在<code class="codeph">country = 'Diff Italy-Spain'</code>的新行中。
                        </p><pre class="oac_no_warn" dir="ltr">SELECT product，country，sales FROM sales_view国家IN（'意大利'，'西班牙'）GROUP BY产品，国家MODEL PARTITION BY（产品）尺寸（国家）措施（SUM（销售）AS销售）规则UPSERT（销售[ 'DIFF ITALY-SPAIN'] =销售['意大利']  - 销售['西班牙']）;</pre><p>有关运行此示例所需的视图的信息，请参阅<span class="q">“ <a href="sql-modeling-data-warehouses.html#GUID-195E4085-EE47-4122-AED6-F358C0C2F716">SQL建模</a></span>示例”。
                        </p>
                     </div>
                     <!-- class="section" -->
                  </div>
               </div><a id="DWHSG9208"></a><div class="props_rev_3"><a id="GUID-B287E2D2-6983-4A6C-B6CC-6A27C0100A37" name="GUID-B287E2D2-6983-4A6C-B6CC-6A27C0100A37"></a><h4 id="DWHSG-GUID-B287E2D2-6983-4A6C-B6CC-6A27C0100A37" class="sect4"><span class="enumeration_section">22.5.2</span> SQL建模示例2：计算百分比变化</h4>
                  <div>
                     <div class="section">
                        <p>如果从2000年10月到2000年11月，每个国家的每个产品的销售额从2000年11月到2000年12月以相同的月率增长（或下降），那么第四季度的销售额对整个公司和每个国家的销售额是多少？</p><pre class="oac_no_warn" dir="ltr">SELECT国家，SUM（销售）FROM（SELECT产品，国家，月份，销售额FROM sales_view2 WHERE年份= 2000年和月份IN（'十月'，'十一月'）MODEL PARTITION BY（产品，国家）DIMENSION BY（月）措施（销售销售）规则（销售['十二月'] =（销售['十一月'] /销售['十月']）*销售['十一月']））GROUP BY GROUPING SETS（（），（country））;</pre><p>有关运行此示例所需的视图的信息，请参阅<span class="q">“ <a href="sql-modeling-data-warehouses.html#GUID-195E4085-EE47-4122-AED6-F358C0C2F716">SQL建模</a></span>示例”。
                        </p>
                     </div>
                     <!-- class="section" -->
                  </div>
               </div><a id="DWHSG9209"></a><div class="props_rev_3"><a id="GUID-7A067A66-3F08-4747-AC17-1A0BD41D406F" name="GUID-7A067A66-3F08-4747-AC17-1A0BD41D406F"></a><h4 id="DWHSG-GUID-7A067A66-3F08-4747-AC17-1A0BD41D406F" class="sect4"><span class="enumeration_section">22.5.3</span> SQL建模示例3：计算净现值</h4>
                  <div>
                     <div class="section">
                        <p>您<a id="d90648e4781" class="indexterm-anchor"></a>想要计算一系列定期现金流量的净现值（NPV）。您的业务情景涉及两个项目，每个项目从0时的初始投资开始，表示为负现金流。最初的投资之后是三年的正现金流。首先，创建一个表（ <code class="codeph">cash_flow</code> ）并用一些数据填充它，如下面的语句所示：</p><pre class="oac_no_warn" dir="ltr">CREATE TABLE cash_flow（年DATE，i INTEGER，prod VARCHAR2（3），金额NUMBER）; INSERT INTO cash_flow VALUES（TO_DATE（'1999'，'YYYY'），0，'vcr'， -  100.00）; INSERT INTO cash_flow VALUES（TO_DATE（'2000'，'YYYY'），1，'vcr'，12.00）; INSERT INTO cash_flow VALUES（TO_DATE（'2001'，'YYYY'），2，'vcr'，10.00）; INSERT INTO cash_flow VALUES（TO_DATE（'2002'，'YYYY'），3，'vcr'，20.00）; INSERT INTO cash_flow VALUES（TO_DATE（'1999'，'YYYY'），0，'dvd'， -  -200.00）; INSERT INTO cash_flow VALUES（TO_DATE（'2000'，'YYYY'），1，'dvd'，22.00）; INSERT INTO cash_flow VALUES（TO_DATE（'2001'，'YYYY'），2，'dvd'，12.00）; INSERT INTO cash_flow VALUES（TO_DATE（'2002'，'YYYY'），3，'dvd'，14.00）;</pre><p>有关运行此示例所需的视图的信息，请参阅<span class="q">“ <a href="sql-modeling-data-warehouses.html#GUID-195E4085-EE47-4122-AED6-F358C0C2F716">SQL建模</a></span>示例”。
                        </p>
                        <p>要使用0.14的贴现率计算净现值，请发出以下声明：</p><pre class="oac_no_warn" dir="ltr">SELECT year，i，prod，amount，npv FROM cash_flow MODEL PARTITION BY（prod）DIMENSION BY（i）MEASURES（amount，0 npv，year）RULES（npv [0] = amount [0]，npv [i！= 0] ORDER BY i = amount [CV（）] / POWER（1.14，CV（i））+ npv [CV（i）-1]）;我是PRO的NPV --------- ---------- --- ---------- ---------- 01-AUG -99 0 dvd -200 -200 01-AUG-00 1 dvd 22 -180.70175 01-AUG-01 2 dvd 12 -171.46814 01-AUG-02 3 dvd 14 -162.01854 01-AUG-99 0 vcr -100 -100 01 -AUG-00 1 vcr 12 -89.473684 01-AUG-01 2 vcr 10 -81.779009 01-AUG-02 3 vcr 20 -68.279579</pre></div>
                     <!-- class="section" -->
                  </div>
               </div><a id="DWHSG9210"></a><div class="props_rev_3"><a id="GUID-A768891C-B572-4860-890A-85143BFEBF9C" name="GUID-A768891C-B572-4860-890A-85143BFEBF9C"></a><h4 id="DWHSG-GUID-A768891C-B572-4860-890A-85143BFEBF9C" class="sect4"><span class="enumeration_section">22.5.4</span> SQL建模示例4：使用联立方程计算</h4>
                  <div>
                     <div class="section">
                        <p>您<a id="d90648e4825" class="indexterm-anchor"></a>希望您的利息支出等于您的净收入的30％（净=支付减去税减去利息）。利息可从总额中扣除，税收为工资的38％和资本收益的28％。你有10万美元的工资和15,000美元的资本收益。净收入，税收和利息支出未知。注意这是一个联立方程（net取决于兴趣，它取决于net），因此包括<code class="codeph">ITERATE</code>子句。
                        </p>
                        <p>有关运行此示例所需的视图的信息，请参阅<span class="q">“ <a href="sql-modeling-data-warehouses.html#GUID-195E4085-EE47-4122-AED6-F358C0C2F716">SQL建模</a></span>示例”。
                        </p>
                        <p>首先，创建一个名为<code class="codeph">ledger</code>的表：</p><pre class="oac_no_warn" dir="ltr">CREATE TABLE分类帐（帐户VARCHAR2（20），余额NUMBER（10,2））;</pre><p>然后，插入以下五行：</p><pre class="oac_no_warn" dir="ltr">INSERT INTO分类账VALUES（'薪水'，100000）; INSERT INTO分类账VALUES（'Capital_gains'，15000）; INSERT INTO分类账VALUES（'Net'，0）; INSERT INTO分类账VALUES（'Tax'，0）; INSERT INTO分类账VALUES（'兴趣'，0）;</pre><p>接下来，发出以下声明：</p><pre class="oac_no_warn" dir="ltr">SELECT s，账户FROM分类账MODEL DIMENSION BY（账户）MEASURES（余额s）规则ITERATE（100）（s ['Net'] = s ['薪水']  -  s ['兴趣']  -  s ['税'] ，s ['税'] =（s ['薪水']  -  s ['兴趣']）* 0.38 + s ['Capital_gains'] * 0.28，s ['兴趣'] = s ['净'] * 0.30 ）;</pre><p>输出（数字舍入）是：</p><pre class="oac_no_warn" dir="ltr">S ACCOUNT ---------- -------------------- 100000薪水15000 Capital_gains 48735.2445净36644.1821税14620.5734利息</pre></div>
                     <!-- class="section" -->
                  </div>
               </div><a id="DWHSG9211"></a><div class="props_rev_3"><a id="GUID-DF19701F-FB63-4AA0-A285-F337DC9D6203" name="GUID-DF19701F-FB63-4AA0-A285-F337DC9D6203"></a><h4 id="DWHSG-GUID-DF19701F-FB63-4AA0-A285-F337DC9D6203" class="sect4"><span class="enumeration_section">22.5.5</span> SQL建模示例5：使用回归计算</h4>
                  <div>
                     <div class="section">
                        <p>与2000年相比，2001年Bounce的销售额将与过去三年（1998年至2000年）之间的销售额相比有所增加。要计算增量，请使用回归函数<code class="codeph">REGR_SLOPE</code> ，如下所示。因为您正在计算下一个期间的值，所以将斜率添加到2000值就足够了。
                        </p><pre class="oac_no_warn" dir="ltr">SELECT * FROM（SELECT country，product，year，projected_sale，sales FROM sales_view WHERE country IN（'Italy'，'Japan'）AND product IN（'Bounce'）MODEL PARTITION BY（country）DIMENSION BY（product，year）MEASURES （销售销售，年y，CAST（NULL AS NUMBER）projected_sale）IGNORE NAV RULES UPSERT（projected_sale [FOR product IN（'Bounce'），2001] = sales [CV（），2000] + REGR_SLOPE（sales，y）[ CV（），1998年和2000年之间的年份]））按国家，产品，年份排序;</pre><p>有关运行此示例所需的视图的信息，请参阅<span class="q">“ <a href="sql-modeling-data-warehouses.html#GUID-195E4085-EE47-4122-AED6-F358C0C2F716">SQL建模</a></span>示例”。
                        </p>
                        <p>输出如下：</p><pre class="oac_no_warn" dir="ltr">国家产品年度PROJECTED_SALE销售------- ------- ---- -------------- -------意大利Bounce 1999 2474.78意大利Bounce 2000 4333.69意大利反弹2001 6192.6 4846。3日本反弹1999 2961。3日本反弹2000 5133。53日本反弹2001 7305.76 6303.6</pre></div>
                     <!-- class="section" -->
                  </div>
               </div><a id="DWHSG9212"></a><div class="props_rev_3"><a id="GUID-6EACDDD4-96CE-456F-B2C2-3374E05EA96C" name="GUID-6EACDDD4-96CE-456F-B2C2-3374E05EA96C"></a><h4 id="DWHSG-GUID-6EACDDD4-96CE-456F-B2C2-3374E05EA96C" class="sect4"><span class="enumeration_section">22.5.6</span> SQL建模示例6：计算抵押摊销</h4>
                  <div>
                     <div class="section">
                        <p>这个<a id="d90648e4920" class="indexterm-anchor"></a><a id="d90648e4922" class="indexterm-anchor"></a>示例使用从抵押事实表中选择的抵押贷款信息为任意数量的客户创建抵押摊销表。首先，创建两个表并插入所需的数据：</p>
                     </div>
                     <!-- class="section" -->
                     <div class="section">
                        <ul style="list-style-type:disc">
                           <li>
                              <p><code class="codeph">mortgage_facts</code></p>
                              <p>保存有关各个客户贷款的信息，包括客户名称，存储在该行中的贷款事实以及该事实的价值。为此示例存储的事实是贷款（ <code class="codeph">Loan</code> ），年利率（ <code class="codeph">Annual_Interest</code> ）和贷款的支付数量（ <code class="codeph">Payments</code> ）。此外，还插入了两个客户Smith和Jones的值。
                              </p><pre class="oac_no_warn" dir="ltr">CREATE TABLE mortgage_facts（客户VARCHAR2（20），事实VARCHAR2（20），金额NUMBER（10,2））; INSERT INTO mortgage_facts VALUES（'Smith'，'Loan'，100000）; INSERT INTO mortgage_facts VALUES（'Smith'，'Annual_Interest'，12）; INSERT INTO mortgage_facts VALUES（'Smith'，'Payments'，360）; INSERT INTO mortgage_facts VALUES（'Smith'，'Payment'，0）; INSERT INTO mortgage_facts VALUES（'Jones'，'Loan'，200000）; INSERT INTO mortgage_facts VALUES（'Jones'，'Annual_Interest'，12）; INSERT INTO mortgage_facts VALUES（'Jones'，'Payments'，180）; INSERT INTO mortgage_facts VALUES（'Jones'，'Payment'，0）;</pre></li>
                           <li>
                              <p><code class="codeph">抵押</code></p>
                              <p>保存计算的输出信息。列是客户，付款编号（ <code class="codeph">pmt_num</code> ），在该付款中应用的本金（ <code class="codeph">principalp</code> ），在该付款中应用的<code class="codeph">interestp</code> （ <code class="codeph">interestp</code> ）和剩余贷款余额（ <code class="codeph">mort_balance</code> ）。要将新单元格嵌入到分区中，每个分区至少需要预先存在一行。因此，您可以在抵押表中为两个客户的价值进行种子支付，然后再进行任何付款。可以使用基于<code class="codeph">mortgage_facts</code>表的SQL <code class="codeph">INSERT</code>语句轻松生成此种子信息。
                              </p>
                           </li>
                        </ul><pre class="oac_no_warn" dir="ltr">CREATE TABLE mortgage_facts（客户VARCHAR2（20），事实VARCHAR2（20），金额NUMBER（10,2））; INSERT INTO mortgage_facts VALUES（'Smith'，'Loan'，100000）; INSERT INTO mortgage_facts VALUES（'Smith'，'Annual_Interest'，12）; INSERT INTO mortgage_facts VALUES（'Smith'，'Payments'，360）; INSERT INTO mortgage_facts VALUES（'Smith'，'Payment'，0）; INSERT INTO mortgage_facts VALUES（'Smith'，'PaymentAmt'，null）; INSERT INTO mortgage_facts VALUES（'Jones'，'Loan'，200000）; INSERT INTO mortgage_facts VALUES（'Jones'，'Annual_Interest'，12）; INSERT INTO mortgage_facts VALUES（'Jones'，'Payments'，180）; INSERT INTO mortgage_facts VALUES（'Jones'，'Payment'，0）; INSERT INTO mortgage_facts VALUES（'Jones'，'PaymentAmt'，null）; CREATE TABLE抵押（客户VARCHAR2（20），pmt_num NUMBER（4），principalp NUMBER（10,2），interestp NUMBER（10,2），mort_balance NUMBER（10,2））; INSERT INTO抵押贷款价值（'琼斯'，0,0,0,200000）; INSERT INTO抵押贷款价值（'Smith'，0,0,0,100000）;</pre><p>有关运行此示例所需的视图的信息，请参阅<span class="q">“ <a href="sql-modeling-data-warehouses.html#GUID-195E4085-EE47-4122-AED6-F358C0C2F716">SQL建模</a></span>示例”。
                        </p>
                        <p>以下SQL语句很复杂，因此根据需要对各行进行了注释。稍后将更详细地解释这些行。</p><pre class="oac_no_warn" dir="ltr">选择c，p，m，pp，ip从按揭模式 - 参见1参考R ON（选择客户，事实，amt  - 参见2来自mortgage_facts模型维度（客户，事实）措施（金额） - 参见3规则（amt [any，'PaymentAmt'] =（amt [CV（），'Loan'] * Power（1+（amt [CV（），'Annual_Interest'] / 100/12），amt [CV（）， '付款']）*（amt [CV（），'Annual_Interest'] / 100/12））/（Power（1+（amt [CV（），'Annual_Interest'] / 100/12），amt [CV（ ），'付款']） -  1）））维度（客户，事实）度量（amt） - 参见4主要摊销分区（客户c） - 参见5维（0 p） - 参见6措施（principalp pp，interestp ip，mort_balance m，customer mc） - 参见7规则ITERATE（1000）UNTIL（ITERATION_NUMBER + 1 = r.amt [mc [0]，'付款']） - 见8（ip [ ITERATION_NUMBER + 1] = m [CV（） -  1] * r.amt [mc [0]，'Annual_Interest'] / 1200， - 见9 pp [ITERATION_NUMBER + 1] = r.amt [mc [0]， 'PaymentAmt']  -  ip [CV（）]， - 见10米[ITERATION_NUMBER + 1] = m [CV（） -  1]  -  pp [CV（）]  - 见11）ORDER BY c，p;</pre><p>以下数字表示示例中列出的数字：</p>
                        <p>1：这是主要模型定义的开始。</p>
                        <p>2到4：这些线标记标记为<code class="codeph">R</code>的参考模型的开始和结束。此模型定义了一个<code class="codeph">SELECT</code>语句，用于计算每个客户贷款的每月付款金额。<code class="codeph">SELECT</code>语句使用自己的<code class="codeph">MODEL</code>子句，从标记为3的行开始，使用单个规则根据来自<code class="codeph">mortgage_facts</code>表的信息定义<code class="codeph">amt</code>值。参考模型<code class="codeph">R</code>返回的度量是<code class="codeph">amt</code> ，按客户名称<code class="codeph">cust</code>和事实值<code class="codeph">fact</code>确定尺寸，如标记为4的行中所定义。
                        </p>
                        <p>计算参考模型一次，然后在主模型中使用这些值来计算其他计算。参考模型<code class="codeph">R</code>将为每个现有的<code class="codeph">mortgage_facts</code>行返回一行，并且它将为每个客户返回新计算的行，其中事实类型为<code class="codeph">Payment</code> ， <code class="codeph">amt</code>是每月付款金额。如果您希望使用<code class="codeph">R</code>输出中的特定金额，则使用表达式<code class="codeph">r.amt[&lt;customer_name&gt;,&lt;fact_name&gt;]</code> 。
                        </p>
                        <p>5：这是主要模型定义的延续。您将按客户对输出进行分区，别名为<code class="codeph">c</code> 。
                        </p>
                        <p>6：主模型的大小为常数0，别名为<code class="codeph">p</code> 。这表示一行的付款编号。
                        </p>
                        <p>7：定义了四项措施： <code class="codeph">principalp (pp)</code>是当月应用于贷款的本金金额， <code class="codeph">interestp (ip)</code>是当月支付的利息， <code class="codeph">mort_balance (m)</code>是贷款支付后的剩余抵押金额，和<code class="codeph">customer (mc)</code>用于支持分区。
                        </p>
                        <p>8：这开始了规则块。它将执行最多1000次的规则计算。由于每个客户每月执行一次计算，因此可以为贷款指定的最大月数为1000。当<code class="codeph">ITERATION_NUMBER+1</code>等于从参考<code class="codeph">R</code>派生的付款金额时，迭代停止。请注意，引用<code class="codeph">R</code>的值是引用子句中定义的<code class="codeph">amt</code> （amount）度量。该参考值的地址为<code class="codeph">r.amt[&lt;customer_name&gt;,&lt;fact&gt;]</code> 。迭代行中使用的表达式<code class="codeph">"r.amt[mc[0], 'Payments']"</code>被解析为来自引用<code class="codeph">R</code>的量，其中客户名称是由<code class="codeph">mc[0]</code>解析的值。因为每个分区只包含一个客户，所以<code class="codeph">mc[0]</code>只能有一个值。因此， <code class="codeph">"r.amt[mc[0], 'Payments']"</code>产生参考条款的当前客户付款数量的值。这意味着规则的执行次数与该客户的付款次数相同。
                        </p>
                        <p>9到11：此块中的前两个规则使用与8中解释的相同类型的<code class="codeph">r.amt</code>引用。区别在于ip规则将事实值定义为<code class="codeph">Annual_Interest</code> 。请注意，每个规则都引用其他一个度量的值。每个规则左侧使用的表达式<code class="codeph">"[ITERATION_NUMBER+1]"</code>将创建一个新的维度值，因此该度量将被置于结果集中。因此，结果将包括每个客户的所有付款的每月摊销行。
                        </p>
                        <p>该示例的最后一行按客户和贷款支付编号对结果进行排序。</p>
                     </div>
                     <!-- class="section" -->
                  </div>
               </div>
            </div>
         </div>
      </article>
   </body>
</html>