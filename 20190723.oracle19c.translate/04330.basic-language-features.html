<!DOCTYPE html
  SYSTEM "about:legacy-compat">
<html xml:lang="en-us" lang="en-us">
   <head>
      <meta http-equiv="Content-Type" content="text/html; charset=utf-8">
      <meta name="viewport" content="width=device-width, initial-scale=1">
      <meta http-equiv="X-UA-Compatible" content="IE=edge">
      <title>Basic Language Features</title>
      <meta property="og:site_name" content="Oracle Help Center">
      <meta property="og:title" content="SQLJ Developer's Guide ">
      <meta property="og:description" content="">
      <link rel="stylesheet" href="/sp_common/book-template/ohc-book-template/css/book.css">
      <link rel="shortcut icon" href="/sp_common/book-template/ohc-common/img/favicon.ico">
      <meta name="application-name" content="SQLJ Developer's Guide">
      <meta name="generator" content="DITA Open Toolkit version 1.8.5 (Mode = doc)">
      <meta name="plugin" content="SP_docbuilder HTML plugin release 18.2.2">
      <link rel="alternate" href="sqlj-developers-guide.pdf" title="PDF File" type="application/pdf">
      <meta name="robots" content="all">
      <link rel="schema.dcterms" href="http://purl.org/dc/terms/">
      <meta name="dcterms.created" content="2019-01-11T08:20:03-08:00">
      
      <meta name="dcterms.dateCopyrighted" content="1999, 2019">
      <meta name="dcterms.category" content="database">
      <meta name="dcterms.identifier" content="E96458-01">
      
      <meta name="dcterms.product" content="en/database/oracle/oracle-database/19">
      
      <link rel="prev" href="key-programming-considerations.html" title="Previous" type="text/html">
      <link rel="next" href="type-support.html" title="Next" type="text/html">
      <script>
        document.write('<style type="text/css">');
        document.write('body > .noscript, body > .noscript ~ * { visibility: hidden; }');
        document.write('</style>');
     </script>
      <script data-main="/sp_common/book-template/ohc-book-template/js/book-config" src="/sp_common/book-template/requirejs/require.js"></script>
      <script>
            if (window.require === undefined) {
                document.write('<script data-main="sp_common/book-template/ohc-book-template/js/book-config" src="sp_common/book-template/requirejs/require.js"><\/script>');
                document.write('<link href="sp_common/book-template/ohc-book-template/css/book.css" rel="stylesheet"/>');
            }
        </script>
      <script type="application/json" id="ssot-metadata">{"primary":{"category":{"short_name":"database","element_name":"Database","display_in_url":true},"suite":{"short_name":"oracle","element_name":"Oracle","display_in_url":true},"product_group":{"short_name":"not-applicable","element_name":"Not applicable","display_in_url":false},"product":{"short_name":"oracle-database","element_name":"Oracle Database","display_in_url":true},"release":{"short_name":"19","element_name":"Release 19","display_in_url":true}}}</script>
      
    <meta name="dcterms.title" content="SQLJ Developer's Guide">
    <meta name="dcterms.isVersionOf" content="JSQLJ">
    <meta name="dcterms.release" content="Release 19">
  </head>
   <body>
      <div class="noscript alert alert-danger text-center" role="alert">
         <a href="key-programming-considerations.html" class="pull-left"><span class="glyphicon glyphicon-chevron-left" aria-hidden="true"></span>Previous</a>
         <a href="type-support.html" class="pull-right">Next<span class="glyphicon glyphicon-chevron-right" aria-hidden="true"></span></a>
         <span class="fa fa-exclamation-triangle" aria-hidden="true"></span> JavaScript must be enabled to correctly display this content
        
      </div>
      <article>
         <header>
            <ol class="breadcrumb" vocab="http://schema.org/" typeof="BreadcrumbList">
               <li property="itemListElement" typeof="ListItem"><a href="index.html" property="item" typeof="WebPage"><span property="name">SQLJ Developer's Guide </span></a></li>
               <li class="active" property="itemListElement" typeof="ListItem"> Basic Language Features</li>
            </ol>
            <a id="GUID-D93359BA-4F29-49C2-8AAE-23F8BBCE8BE5" name="GUID-D93359BA-4F29-49C2-8AAE-23F8BBCE8BE5"></a><a id="JSQLJ270"></a>
            
            <h2 id="JSQLJ-GUID-D93359BA-4F29-49C2-8AAE-23F8BBCE8BE5" class="sect2"><span class="enumeration_chapter">5 </span> Basic Language Features
            </h2>
         </header>
         <div class="ind">
            <div>
               <p>SQLJ statements always begin with a <code class="codeph">#sql</code> token and can be broken into two main categories:
               </p>
               <ul style="list-style-type: disc;">
                  <li>
                     <p>Declarations: Used for creating Java classes for iterators, which is similar to Java Database Connectivity (JDBC) result sets, or connection contexts, which is designed to help you create strongly typed connections according to the sets of SQL entities being used.</p>
                  </li>
                  <li>
                     <p>Executable statements: Used to execute embedded SQL operations.</p>
                  </li>
               </ul>
               <p>This chapter discusses the following topics:</p>
               <ul style="list-style-type: disc;">
                  <li>
                     <p><a href="basic-language-features.html#GUID-74A36C5C-B63E-4489-A464-47387ABCB24E">Overview of SQLJ Declarations</a></p>
                  </li>
                  <li>
                     <p><a href="basic-language-features.html#GUID-863A3FD5-C7DB-4032-9DE7-6721287C9579">Overview of SQLJ Executable Statements</a></p>
                  </li>
                  <li>
                     <p><a href="basic-language-features.html#GUID-7B85631F-98E1-4A9A-BBC1-181A53D0D03D">Java Host_ Context_ and Result Expressions</a></p>
                  </li>
                  <li>
                     <p><a href="basic-language-features.html#GUID-E779CA66-DE27-48C8-A379-E793AF0FB280">Single-Row Query Results: SELECT INTO Statements</a></p>
                  </li>
                  <li>
                     <p><a href="basic-language-features.html#GUID-C6E5904A-2D17-40EA-9DF2-AD5BCEA58E2D">Multirow Query Results: SQLJ Iterators</a></p>
                  </li>
                  <li>
                     <p><a href="basic-language-features.html#GUID-74814900-4067-4EE0-B74B-A9A5F5DED86C">Assignment Statements (SET)</a></p>
                  </li>
                  <li>
                     <p><a href="basic-language-features.html#GUID-3FC4A9CC-9B63-4010-B842-0BDEA19C8C3B">Stored Procedure and Function Calls</a></p>
                  </li>
               </ul>
            </div><a id="JSQLJ271"></a><div class="props_rev_3"><a id="GUID-74A36C5C-B63E-4489-A464-47387ABCB24E" name="GUID-74A36C5C-B63E-4489-A464-47387ABCB24E"></a><h3 id="JSQLJ-GUID-74A36C5C-B63E-4489-A464-47387ABCB24E" class="sect3">Overview of SQLJ Declarations</h3>
               <div>
                  <p>A SQLJ declaration consists of the <code class="codeph">#sql</code> token followed by the declaration of a class. SQLJ declarations introduce specialized Java types into your application. There are currently two kinds of SQLJ declarations, iterator declarations and connection context declarations, defining Java classes as follows:
                  </p>
                  <ul style="list-style-type: disc;">
                     <li>
                        <p>Iterator declarations define iterator classes. Iterators are conceptually similar to JDBC result sets and are used to receive multi-row query data. An iterator is implemented as an instance of an iterator class.</p>
                     </li>
                     <li>
                        <p>Connection context declarations define connection context classes. Each connection context class is typically used for connections whose operations use a particular set of SQL entities, such as tables, views, and stored procedures. That is to say, instances of a particular connection context class are used to connect to schemas that include SQL entities with the same names and characteristics. SQLJ implements each database connection as an instance of a connection context class.</p>
                        <p>SQLJ includes the predefined <code class="codeph">sqlj.runtime.DefaultContext</code> connection context class. If you only require one connection context class, then you can use <code class="codeph">DefaultContext</code>, which does not require a connection context declaration.
                        </p>
                     </li>
                  </ul>
                  <p>In any iterator or connection context declaration, you may optionally include the following clauses:</p>
                  <ul style="list-style-type: disc;">
                     <li>
                        <p>The <code class="codeph">implements</code> clause: Specifies one or more interfaces that the generated class will implement.
                        </p>
                     </li>
                     <li>
                        <p>The <code class="codeph">with</code> clause: Specifies one or more initialized constants to be included in the generated class.
                        </p>
                     </li>
                  </ul>
                  <p>This section covers the following topics:</p>
                  <ul style="list-style-type: disc;">
                     <li>
                        <p><a href="basic-language-features.html#GUID-B0C0602E-65AE-4337-9AC3-0F4576A079F1">Rules for SQLJ Declarations</a></p>
                     </li>
                     <li>
                        <p><a href="basic-language-features.html#GUID-3B3F5EE5-0540-4196-A7BA-93628EE09B8F">Iterator Declarations</a></p>
                     </li>
                     <li>
                        <p><a href="basic-language-features.html#GUID-35341EB4-501B-4807-A6A1-88F92C8B76DF">Connection Context Declarations</a></p>
                     </li>
                     <li>
                        <p><a href="basic-language-features.html#GUID-1843167B-56CD-49CB-811B-4ACC5DF38035">Declaration IMPLEMENTS Clause</a></p>
                     </li>
                     <li>
                        <p><a href="basic-language-features.html#GUID-5E97C2F0-7249-48FD-A75B-AB5A465147C7">Declaration WITH Clause</a></p>
                     </li>
                  </ul>
               </div><a id="JSQLJ272"></a><div class="props_rev_3"><a id="GUID-B0C0602E-65AE-4337-9AC3-0F4576A079F1" name="GUID-B0C0602E-65AE-4337-9AC3-0F4576A079F1"></a><h4 id="JSQLJ-GUID-B0C0602E-65AE-4337-9AC3-0F4576A079F1" class="sect4">Rules for SQLJ Declarations</h4>
                  <div>
                     <p>SQLJ declarations are allowed in your SQLJ source code anywhere that a class definition would be allowed in standard Java. For example:</p><pre class="oac_no_warn" dir="ltr"><span class="italic">SQLJ declaration</span>;   // OK (top level scope)

class Outer
{
   <span class="italic">SQLJ declaration</span>; // OK (class level scope)

   class Inner
   {
      <span class="italic">SQLJ declaration</span>; // OK (nested class scope)
   }

   void func()
   {
      <span class="italic">SQLJ declaration</span>; // OK (method block)
   }
}
</pre><div class="infoboxnote" id="GUID-B0C0602E-65AE-4337-9AC3-0F4576A079F1__GUID-2D6AF3A4-A5E3-4749-ABE2-9FA3A03BB346">
                        <p class="notep1">Note:</p>
                        <p>As with standard Java, any public class should be declared in one of the following ways:</p>
                        <ul style="list-style-type: disc;">
                           <li>
                              <p>Declare it in a separate source file. The base name of the file should be the same as the class name.</p>
                           </li>
                           <li>
                              <p>Declare it at class-level scope or nested-class-level scope. In this case, it may be advisable to use <code class="codeph">public static</code> modifiers.
                              </p>
                           </li>
                        </ul>
                        <p>This is a requirement if you are using the standard <code class="codeph">javac</code> compiler provided with the Sun Microsystems JDK.
                        </p>
                     </div>
                  </div>
               </div><a id="JSQLJ273"></a><div class="props_rev_3"><a id="GUID-3B3F5EE5-0540-4196-A7BA-93628EE09B8F" name="GUID-3B3F5EE5-0540-4196-A7BA-93628EE09B8F"></a><h4 id="JSQLJ-GUID-3B3F5EE5-0540-4196-A7BA-93628EE09B8F" class="sect4">Iterator Declarations</h4>
                  <div>
                     <p>An iterator declaration creates a class that defines a kind of iterator for receiving query data. The declaration will specify the column types of the iterator instances, which must match the column types being selected from the database table.</p>
                     <p>Basic iterator declarations use the following syntax:</p><pre class="oac_no_warn" dir="ltr">#sql &lt;<span class="italic">modifiers</span>&gt; iterator<span class="italic"> iterator_classname</span> (<span class="italic">type declarations</span>);
</pre><p>Modifiers are optional and can be any standard Java class modifiers, such as <code class="codeph">public</code>, <code class="codeph">static</code>, and so on. Type declarations are separated by commas.
                     </p>
                     <p>There are two categories of iterators, named iterators and positional iterators. For named iterators, you must specify column names and types. For positional iterators, you need to specify only types.</p>
                     <p>The following is an example of a named iterator declaration:</p><pre class="oac_no_warn" dir="ltr">#sql public iterator EmpIter (String ename, double sal);
</pre><p>This statement results in the SQLJ translator creating a public <code class="codeph">EmpIter</code> class with a <code class="codeph">String</code> attribute <code class="codeph">ename</code> and a <code class="codeph">double</code> attribute <code class="codeph">sal</code>. You can use this iterator to select data from a database table with corresponding employee name and salary columns of matching names (<code class="codeph">ENAME</code> and <code class="codeph">SAL</code>) and data types (<code class="codeph">CHAR</code> and <code class="codeph">NUMBER</code>).
                     </p>
                     <p>Declaring <code class="codeph">EmpIter</code> as a positional iterator, instead of a named iterator, can be done as follows:
                     </p><pre class="oac_no_warn" dir="ltr">#sql public iterator EmpIter (String, double);
</pre><div class="infoboxnotealso" id="GUID-3B3F5EE5-0540-4196-A7BA-93628EE09B8F__GUID-C4421FC3-4A58-457B-88CB-C0D7473146F8">
                        <p class="notep1">See Also:</p>
                        <p><span class="q">"<a href="basic-language-features.html#GUID-C6E5904A-2D17-40EA-9DF2-AD5BCEA58E2D">Multirow Query Results: SQLJ Iterators</a>"</span></p>
                     </div>
                  </div>
               </div><a id="JSQLJ274"></a><div class="props_rev_3"><a id="GUID-35341EB4-501B-4807-A6A1-88F92C8B76DF" name="GUID-35341EB4-501B-4807-A6A1-88F92C8B76DF"></a><h4 id="JSQLJ-GUID-35341EB4-501B-4807-A6A1-88F92C8B76DF" class="sect4">Connection Context Declarations</h4>
                  <div>
                     <p>A connection context declaration creates a connection context class, whose instances are typically used for database connections that use a particular set of SQL entities. Basic connection context declarations use the following syntax:</p><pre class="oac_no_warn" dir="ltr">#sql &lt;<span class="italic">modifiers</span>&gt; context<span class="italic"> context_classname</span>;
</pre><p>As for iterator declarations, modifiers are optional and can be any standard Java class modifiers. For example:</p><pre class="oac_no_warn" dir="ltr">#sql public context MyContext;
</pre><p>As a result of this statement, the SQLJ translator creates a public <code class="codeph">MyContext</code> class. In your SQLJ code you can use instances of this class to create database connections to schemas that include a desired set of entities, such as tables, views, and stored procedures. Different instances of <code class="codeph">MyContext</code> might be used to connect to different schemas, but each schema might be expected, for example, to include an <code class="codeph">EMPLOYEES</code> table, a <code class="codeph">DEPARTMENTS</code> table, and a <code class="codeph">SECURE_EMPLOYEES</code> stored procedure.
                     </p>
                     <p>Declared connection context classes are an advanced topic and are not necessary for basic SQLJ applications that use only one interrelated set of SQL entities. In basic scenarios, you can use multiple connections by creating multiple instances of the <code class="codeph">sqlj.runtime.ref.DefaultContext</code> class, which does not require any connection context declarations.
                     </p>
                     <div class="infoboxnotealso" id="GUID-35341EB4-501B-4807-A6A1-88F92C8B76DF__GUID-241F095A-7026-4000-85C3-8836863DAD02">
                        <p class="notep1">See Also:</p>
                        <p><span class="q">"<a href="key-programming-considerations.html#GUID-02A50813-2D4D-4DC1-AD1A-014AF1EDC03D">Connection Considerations</a>"</span> and <span class="q">"<a href="advanced-language-features.html#GUID-DE7D99A8-ED65-4DEA-B274-3BC09EE0056A">Connection Contexts</a>"</span></p>
                     </div>
                  </div>
               </div><a id="JSQLJ275"></a><div class="props_rev_3"><a id="GUID-1843167B-56CD-49CB-811B-4ACC5DF38035" name="GUID-1843167B-56CD-49CB-811B-4ACC5DF38035"></a><h4 id="JSQLJ-GUID-1843167B-56CD-49CB-811B-4ACC5DF38035" class="sect4">Declaration IMPLEMENTS Clause</h4>
                  <div>
                     <p>When you declare any iterator class or connection context class, you can specify one or more interfaces to be implemented by the generated class.</p>
                     <p>Use the following syntax for an iterator class:</p><pre class="oac_no_warn" dir="ltr">#sql &lt;<span class="italic">modifiers</span>&gt; iterator<span class="italic"> iterator_classname</span> implements <span class="italic">intfc1</span>,..., <span class="italic">intfcN</span> 
     (<span class="italic">type declarations</span>);
</pre><p>The portion <code class="codeph">implements</code> <span class="italic"><code class="codeph">intfc1,..., intfcN</code></span> is known as the <code class="codeph">implements</code> clause. Note that in an iterator declaration, the <code class="codeph">implements</code> clause precedes the iterator type declarations.
                     </p>
                     <p>Here is the syntax for a connection context declaration:</p><pre class="oac_no_warn" dir="ltr">#sql &lt;<span class="italic">modifiers</span>&gt; context<span class="italic"> context_classname </span>implements <span class="italic">intfc1</span>,..., <span class="italic">intfcN</span>;
</pre><p>The <code class="codeph">implements</code> clause is potentially useful in either an iterator declaration or a connection context declaration, but is more likely to be useful in iterator declarations, particularly in implementing the <code class="codeph">sqlj.runtime.Scrollable</code> or <code class="codeph">sqlj.runtime.ForUpdate</code> interface. Scrollable iterators are supported in the Oracle SQLJ implementation.
                     </p>
                     <div class="infoboxnote" id="GUID-1843167B-56CD-49CB-811B-4ACC5DF38035__GUID-1986A5B0-0F46-4FC9-901F-034B30770D0B">
                        <p class="notep1">Note:</p>
                        <p>The SQLJ <code class="codeph">implements</code> clause corresponds to the Java <code class="codeph">implements</code> clause.
                        </p>
                     </div>
                     <p>The following example uses an <code class="codeph">implements</code> clause in declaring a named iterator class. Presume you have created a package, <code class="codeph">mypackage</code>, that includes an iterator interface, <code class="codeph">MyIterIntfc</code>.
                     </p><pre class="oac_no_warn" dir="ltr">#sql public iterator MyIter implements mypackage.MyIterIntfc 
     (String ename, int empno);
</pre><p>The declared class <code class="codeph">MyIter</code> will implement the <code class="codeph">mypackage.MyIterIntfc</code> interface.
                     </p>
                     <p>The following example declares a connection context class that implements an interface named <code class="codeph">MyConnCtxtIntfc</code>. Presume that it is in the package <code class="codeph">mypackage</code>.
                     </p><pre class="oac_no_warn" dir="ltr">#sql public context MyContext implements mypackage.MyConnCtxtIntfc;
</pre><div class="infoboxnotealso" id="GUID-1843167B-56CD-49CB-811B-4ACC5DF38035__GUID-697138C7-5A45-4C02-9EC3-81D67CF95BBF">
                        <p class="notep1">See Also:</p>
                        <p><span class="q">"<a href="advanced-language-features.html#GUID-6504E582-745D-4419-AE90-97CB95181C4C">Using the IMPLEMENTS Clause in Iterator Declarations</a>"</span> and <span class="q">"<a href="advanced-language-features.html#GUID-DBE080FD-E5E1-476B-8B7F-199D44C259BC">Using the IMPLEMENTS Clause in Connection Context Declarations</a>"</span></p>
                     </div>
                  </div>
               </div><a id="JSQLJ276"></a><div class="props_rev_3"><a id="GUID-5E97C2F0-7249-48FD-A75B-AB5A465147C7" name="GUID-5E97C2F0-7249-48FD-A75B-AB5A465147C7"></a><h4 id="JSQLJ-GUID-5E97C2F0-7249-48FD-A75B-AB5A465147C7" class="sect4">Declaration WITH Clause</h4>
                  <div>
                     <p>In declaring a connection context class or iterator class, you can use a <code class="codeph">with</code> clause to specify and initialize one or more constants to be included in the definition of the generated class. Most of this usage is standard, although Oracle implementation adds some extended functionality for iterator declarations.
                     </p>
                     <p>This section covers the following topics:</p>
                     <ul style="list-style-type: disc;">
                        <li>
                           <p><a href="basic-language-features.html#GUID-40673A09-9276-406D-9170-6B936E0546BB">Standard WITH Clause Usage</a></p>
                        </li>
                        <li>
                           <p><a href="basic-language-features.html#GUID-CE3C0979-706C-4BCE-91DE-D0EC5A46D4D6">Oracle-Specific WITH Clause Usage</a></p>
                        </li>
                        <li>
                           <p><a href="basic-language-features.html#GUID-59D146A5-BCAE-4E68-91EC-C79417686CCF">Example: Returnability</a></p>
                        </li>
                     </ul>
                  </div><a id="JSQLJ278"></a><a id="JSQLJ279"></a><a id="JSQLJ277"></a><div class="props_rev_3"><a id="GUID-40673A09-9276-406D-9170-6B936E0546BB" name="GUID-40673A09-9276-406D-9170-6B936E0546BB"></a><h5 id="JSQLJ-GUID-40673A09-9276-406D-9170-6B936E0546BB" class="sect5">Standard WITH Clause Usage</h5>
                     <div>
                        <p>In using a <code class="codeph">with</code> clause, the constants that are produced are always <code class="codeph">public static final</code>. Use the following syntax for an iterator class:
                        </p><pre class="oac_no_warn" dir="ltr">#sql &lt;<span class="italic">modifiers</span>&gt; iterator<span class="italic"> iterator_classname</span> with (<span class="italic">var1</span>=<span class="italic">value1</span>,..., <span class="italic">varN</span>=<span class="italic">valueN</span>)
     (<span class="italic">type declarations</span>);
</pre><p>The portion <code class="codeph">with</code> <code class="codeph">(</code><span class="italic"><code class="codeph">var1=value1,..., varN=valueN</code></span>) is the <code class="codeph">with</code> clause. Note that in an iterator declaration, the <code class="codeph">with</code> clause precedes the iterator type declarations.
                        </p>
                        <p>Where there is both a <code class="codeph">with</code> clause and an <code class="codeph">implements</code> clause, the <code class="codeph">implements</code> clause must come first. Note that parentheses are used to enclose <code class="codeph">with</code> lists, but not <code class="codeph">implements</code> lists.
                        </p>
                        <p>Here is the syntax for a connection context declaration that uses a <code class="codeph">with</code> clause:
                        </p><pre class="oac_no_warn" dir="ltr">#sql &lt;<span class="italic">modifiers</span>&gt; context<span class="italic"> context_classname </span>with (<span class="italic">var1</span>=<span class="italic">value1</span>,..., <span class="italic">varN</span>=<span class="italic">valueN</span>);
</pre><div class="infoboxnote" id="GUID-40673A09-9276-406D-9170-6B936E0546BB__GUID-F3CF08E6-0142-4961-843A-8F6F6EB36E41">
                           <p class="notep1">Note:</p>
                           <p>A predefined set of standard SQLJ constants can be defined in a <code class="codeph">with</code> clause. However, not all of these constants are meaningful to Oracle Database 12<span class="italic">c </span>Release 2 (12.2) or to Oracle SQLJ run time.
                           </p>
                           <p>Attempts to define constants other than the standard constants is legal with Oracle Database 12<span class="italic">c </span>Release 2 (12.2), but might not be portable to other SQLJ implementations and will generate a warning if you have the <code class="codeph">-warn=portable</code> flag enabled.
                           </p>
                        </div>
                        <div class="section">
                           <p class="subhead3" id="GUID-40673A09-9276-406D-9170-6B936E0546BB__GUID-8D91B4C8-0941-4C29-A57B-A74919880C8B">Supported WITH Clause Constants</p>
                        </div>
                        <!-- class="section" -->
                        <div class="section">
                           <p>The Oracle SQLJ implementation supports the following standard constants in connection context declarations:</p>
                           <ul style="list-style-type: disc;">
                              <li>
                                 <p><code class="codeph">typeMap</code>: a <code class="codeph">String</code> literal defining the name of a type map properties resource
                                 </p>
                                 <p>Oracle also supports the use of <code class="codeph">typeMap</code> in iterator declarations.
                                 </p>
                              </li>
                              <li>
                                 <p><code class="codeph">dataSource</code>: a <code class="codeph">String</code> literal defining the name under which a data source is looked up in the <code class="codeph">InitialContext</code></p>
                              </li>
                           </ul>
                           <p>The Oracle SQLJ implementation supports the following standard constants in iterator declarations:</p>
                           <ul style="list-style-type: disc;">
                              <li>
                                 <p><code class="codeph">sensitivity</code>: <code class="codeph">SENSITIVE</code>/<code class="codeph">ASENSITIVE</code>/<code class="codeph">INSENSITIVE</code>, to define the sensitivity of a scrollable iterator
                                 </p>
                              </li>
                              <li>
                                 <p><code class="codeph">returnability</code>: <code class="codeph">true</code>/<code class="codeph">false</code>, to define whether an iterator can be returned from a Java stored procedure or function
                                 </p>
                              </li>
                           </ul>
                        </div>
                        <!-- class="section" -->
                        <div class="section">
                           <p class="subhead3" id="GUID-40673A09-9276-406D-9170-6B936E0546BB__GUID-4ECBD3E0-DF9A-47F8-A46A-4F138ADE3AC5">Unsupported WITH Clause Constants</p>
                        </div>
                        <!-- class="section" -->
                        <div class="section">
                           <p>If you have SQLJ code that uses these constants, then they will not cause an error but will result in no operation. The Oracle SQLJ implementation does <span class="italic">not</span> support the following standard constants in connection context declarations:
                           </p>
                           <ul style="list-style-type: disc;">
                              <li>
                                 <p><code class="codeph">path</code>: a <code class="codeph">String</code> literal defining the name of a path to be prepended for resolution of Java stored procedures and functions
                                 </p>
                              </li>
                              <li>
                                 <p><code class="codeph">transformGroup</code>: a <code class="codeph">String</code> literal defining the name of a SQL transformation group that can be applied to SQL types
                                 </p>
                              </li>
                           </ul>
                           <p>The Oracle SQLJ implementation does <span class="italic">not</span> support the following standard constants, involving cursor states, in iterator declarations:
                           </p>
                           <ul style="list-style-type: disc;">
                              <li>
                                 <p><code class="codeph">holdability</code>: <code class="codeph">true</code>/<code class="codeph">false</code>, determining cursor holdability
                                 </p>
                                 <p>The concept of holdability is defined in the SQL specification. A cursor that is holdable can, subject to application request, be kept open and positioned on the current row even when a transaction is completed. Use of the cursor can then be continued in the next transaction of the same SQL session, however, subject to some limitations.</p>
                              </li>
                              <li>
                                 <p><code class="codeph">updateColumns</code>: a <code class="codeph">String</code> literal containing a comma-delimited list of column names
                                 </p>
                                 <p>An iterator declaration having a <code class="codeph">with</code> clause that specifies <code class="codeph">updateColumns</code> must also have an <code class="codeph">implements</code> clause that specifies the <code class="codeph">sqlj.runtime.ForUpdate</code> interface. The Oracle SQLJ implementation enforces this, even though <code class="codeph">updateColumns</code> is currently unsupported.
                                 </p>
                              </li>
                           </ul>
                           <p>The following is a sample connection context declaration using <code class="codeph">typeMap</code>:
                           </p><pre class="oac_no_warn" dir="ltr">#sql public context MyContext with (typeMap="MyPack.MyClass");
</pre><p>The declared class <code class="codeph">MyContext</code> will define a <code class="codeph">String</code> attribute <code class="codeph">typeMap</code> that will be <code class="codeph">public static final</code> and initialized to the value <code class="codeph">MyPack.MyClass</code>. This value is the fully qualified class name of a <code class="codeph">ListResourceBundle</code> implementation that provides the mapping between SQL and Java types for statements executed on instances of the <code class="codeph">MyContext</code> class.
                           </p>
                           <p>The following is a sample iterator declaration using <code class="codeph">sensitivity</code>:
                           </p><pre class="oac_no_warn" dir="ltr">#sql public iterator MyAsensitiveIter with (sensitivity=ASENSITIVE) 
     (String ename, int empno);
</pre><p>This declaration sets the cursor sensitivity to <code class="codeph">ASENSITIVE</code> for the <code class="codeph">MyAsensitiveIter</code> named iterator class.
                           </p>
                           <p>The following example uses both an <code class="codeph">implements</code> clause and a <code class="codeph">with</code> clause:
                           </p><pre class="oac_no_warn" dir="ltr">#sql public iterator MyScrollableIterator implements sqlj.runtime.Scrollable
     with (holdability=true) (String ename, int empno);
</pre><p>This declaration implements the interface <code class="codeph">sqlj.runtime.Scrollable</code> and enables the cursor <code class="codeph">holdability</code> for a named iterator class.
                           </p>
                           <div class="infoboxnote" id="GUID-40673A09-9276-406D-9170-6B936E0546BB__GUID-66133076-34EA-4F09-AE48-DB086DDE4443">
                              <p class="notep1">Note:</p>
                              <p><code class="codeph">holdability</code> is currently <span class="italic">not</span> supported.
                              </p>
                           </div>
                        </div>
                        <!-- class="section" -->
                     </div>
                  </div><a id="JSQLJ280"></a><div class="props_rev_3"><a id="GUID-CE3C0979-706C-4BCE-91DE-D0EC5A46D4D6" name="GUID-CE3C0979-706C-4BCE-91DE-D0EC5A46D4D6"></a><h5 id="JSQLJ-GUID-CE3C0979-706C-4BCE-91DE-D0EC5A46D4D6" class="sect5">Oracle-Specific WITH Clause Usage</h5>
                     <div>
                        <p>In addition to the standard <code class="codeph">with</code> clause usage in a connection context declaration to associate a type map with the connection context class, the Oracle SQLJ implementation enables you to use a <code class="codeph">with</code> clause to associate a type map with the iterator class in an iterator declaration. For example:
                        </p><pre class="oac_no_warn" dir="ltr">#sql iterator MyIterator with (typeMap="MyTypeMap") (Person pers, Address addr);
</pre><p>If you use Oracle-specific code generation and use type maps in your application, then your iterator and connection context declarations must use the same type maps.</p>
                        <div class="infoboxnotealso" id="GUID-CE3C0979-706C-4BCE-91DE-D0EC5A46D4D6__GUID-295EF242-FB89-42F8-90F3-AE7ABA8D4965">
                           <p class="notep1">See Also:</p>
                           <p><span class="q">"<a href="key-programming-considerations.html#GUID-E4C877C3-6E29-4053-BA8F-D0694B5D4968">Code Considerations and Limitations with Oracle-Specific Code Generation</a>"</span></p>
                        </div>
                     </div>
                  </div><a id="JSQLJ281"></a><div class="props_rev_3"><a id="GUID-59D146A5-BCAE-4E68-91EC-C79417686CCF" name="GUID-59D146A5-BCAE-4E68-91EC-C79417686CCF"></a><h5 id="JSQLJ-GUID-59D146A5-BCAE-4E68-91EC-C79417686CCF" class="sect5">Example: Returnability</h5>
                     <div>
                        <p>Use <code class="codeph">returnability=true</code> in the <code class="codeph">with</code> clause of a SQLJ iterator declaration to specify that the iterator can be returned from a Java stored procedure to a SQL or PL/SQL statement as a REF CURSOR. With the default <code class="codeph">returnability=false</code> setting, the iterator cannot be returned in this manner, and an attempt to do so will result in a SQL exception at run time.
                        </p>
                        <p>Create the following database table: </p><pre class="oac_no_warn" dir="ltr">create table sqljRetTab(str varchar2(30));
insert into sqljRetTab values ('sqljRetTabCol');
</pre><p>Define the <code class="codeph">RefCursorSQLJ</code> class in the <code class="codeph">RefCursorSQLJ.sqlj</code> source file as follows. Note that the iterator type <code class="codeph">MyIter</code> uses <code class="codeph">returnability=true</code>.
                        </p><pre class="oac_no_warn" dir="ltr">public class RefCursorSQLJ
{
   #sql static public iterator MyIter with (returnability=true) (String str);

   static public MyIter sqljUserRet() throws java.sql.SQLException
   {
        MyIter iter=null;
        try {
        #sql iter = {select str from sqljRetTab};
        } catch (java.sql.SQLException e)
        {
           e.printStackTrace();
           throw e;
        }
        System.err.println("iter is " + iter);
        return iter;
   }
}
</pre><p>Load <code class="codeph">RefCursorSQLJ.sqlj</code> into Oracle Java Virtual Machine (JVM) inside the database as follows:
                        </p><pre class="oac_no_warn" dir="ltr">% loadjava -u HR -r -f -v RefCursorSQLJ.sqlj
Password: <span class="italic">password</span>
</pre><p>Invoke the Java stored procedure defined for the <code class="codeph">sqljUserRet()</code> method:
                        </p><pre class="oac_no_warn" dir="ltr">create or replace package refcur_pkg as
     type refcur_t is ref cursor;
end;
/
create or replace function sqljUserRet
return refcur_pkg.refcur_t as
language java
name 'RefCursorSQLJ.sqljUserRet() return
RefCursorSQLJ.MyIter';
/
select HR.sqljUserRet from dual;
</pre><p>Here is the result of the <code class="codeph">SELECT</code> statement: 
                        </p><pre class="oac_no_warn" dir="ltr">    SQLJRET1
    --------------------
    CURSOR STATEMENT : 1

    STR
    ------------------------------
    sqljRetTabCol</pre></div>
                  </div>
               </div>
            </div><a id="JSQLJ282"></a><div class="props_rev_3"><a id="GUID-863A3FD5-C7DB-4032-9DE7-6721287C9579" name="GUID-863A3FD5-C7DB-4032-9DE7-6721287C9579"></a><h3 id="JSQLJ-GUID-863A3FD5-C7DB-4032-9DE7-6721287C9579" class="sect3">Overview of SQLJ Executable Statements</h3>
               <div>
                  <p>A SQLJ executable statement consists of the <code class="codeph">#sql</code> token followed by a SQLJ clause, which uses syntax that follows a specified standard for embedding executable SQL statements in Java code. The embedded SQL operation of a SQLJ executable statement can be any SQL operation supported by the JDBC driver.
                  </p>
                  <p>This section covers the following topics:</p>
                  <ul style="list-style-type: disc;">
                     <li>
                        <p><a href="basic-language-features.html#GUID-587C4F4D-48FC-41FE-9BC5-6B29DBDD8D97">Rules for SQLJ Executable Statements</a></p>
                     </li>
                     <li>
                        <p><a href="basic-language-features.html#GUID-220F9285-7EBE-4253-AA0C-901511567389">SQLJ Clauses</a></p>
                     </li>
                     <li>
                        <p><a href="basic-language-features.html#GUID-9F93C716-2C14-4AD0-B68F-EAC2CEDCDA60">Specifying Connection Context Instances and Execution Context Instances</a></p>
                     </li>
                     <li>
                        <p><a href="basic-language-features.html#GUID-18435E67-4949-46CE-9227-2F159D830774">Executable Statement Examples</a></p>
                     </li>
                     <li>
                        <p><a href="basic-language-features.html#GUID-F6528046-15F5-4A5B-9720-57BC82D4A13F">PL/SQL Blocks in Executable Statements</a></p>
                     </li>
                  </ul>
               </div><a id="JSQLJ283"></a><div class="props_rev_3"><a id="GUID-587C4F4D-48FC-41FE-9BC5-6B29DBDD8D97" name="GUID-587C4F4D-48FC-41FE-9BC5-6B29DBDD8D97"></a><h4 id="JSQLJ-GUID-587C4F4D-48FC-41FE-9BC5-6B29DBDD8D97" class="sect4">Rules for SQLJ Executable Statements</h4>
                  <div>
                     <p>A SQLJ executable statement must adhere to the following rules:</p>
                     <ul style="list-style-type: disc;">
                        <li>
                           <p>It is permitted in Java code wherever Java block statements are permitted. That is, it is permitted inside method definitions and static initialization blocks.</p>
                        </li>
                        <li>
                           <p>Its embedded SQL operation must be enclosed in curly braces: <code class="codeph">{...}</code>.
                           </p>
                        </li>
                        <li>
                           <p>It must be terminated with a semi-colon (;).</p>
                        </li>
                     </ul>
                     <div class="infoboxnote" id="GUID-587C4F4D-48FC-41FE-9BC5-6B29DBDD8D97__GUID-3B39D53B-180B-4629-8150-C81B27F67E82">
                        <p class="notep1">Note:</p>
                        <ul style="list-style-type: disc;">
                           <li>
                              <p>It is recommended that you do <span class="italic">not</span> close the SQL operation with a semi-colon. The parser will detect the end of the operation when it encounters the closing curly brace of the SQLJ clause.
                              </p>
                           </li>
                           <li>
                              <p>Everything inside the curly braces of a SQLJ executable statement is treated as SQL syntax and must follow SQL rules, with the exception of Java host expressions.</p>
                           </li>
                           <li>
                              <p>During offline parsing of SQL operations, all SQL syntax is checked. However, during online semantics-checking only data manipulation language (DML) operations can be parsed and checked. Data definition language (DDL) operations, transaction-control operations, or any other kinds of SQL operations cannot be parsed and checked.</p>
                           </li>
                        </ul>
                     </div>
                  </div>
               </div><a id="JSQLJ285"></a><a id="JSQLJ286"></a><a id="JSQLJ284"></a><div class="props_rev_3"><a id="GUID-220F9285-7EBE-4253-AA0C-901511567389" name="GUID-220F9285-7EBE-4253-AA0C-901511567389"></a><h4 id="JSQLJ-GUID-220F9285-7EBE-4253-AA0C-901511567389" class="sect4">SQLJ Clauses</h4>
                  <div>
                     <p>A SQLJ clause is the executable part of a statement, consisting of everything to the right of the <code class="codeph">#sql</code> token. This consists of embedded SQL inside curly braces, preceded by a Java result expression if appropriate, such as <code class="codeph">result</code> in the following example:
                     </p><pre class="oac_no_warn" dir="ltr">#sql { <span class="italic">SQL operation</span> };   // For a statement with no output, like INSERT
...
#sql <span class="italic">result</span> = { <span class="italic">SQL operation</span> };   // For a statement with output, like SELECT
</pre><p>A clause without a result expression, such as in the first SQLJ statement in the example, is known as a statement clause. A clause that does have a result expression, such as in the second SQLJ statement in the example, is known as an assignment clause.</p>
                     <p>A result expression can be anything from a simple variable that takes a stored-function return value to an iterator that takes several columns of data from a multi-row <code class="codeph">SELECT</code>, where the iterator can be an instance of an iterator class or subclass.
                     </p>
                     <p>A SQL operation in a SQLJ statement can use standard SQL syntax only or can use a clause with syntax specific to SQLJ.</p>
                     <p>Table 1 lists supported SQLJ statement clauses and Table 2 lists supported SQLJ assignment clauses. The last two entries in <a href="basic-language-features.html#GUID-220F9285-7EBE-4253-AA0C-901511567389__CBBHFEGH" title="The following table describes the various SQLJ Statement Clauses.">Table 5-1</a> are general categories for statement clauses that use standard SQL syntax or Oracle PL/SQL syntax, as opposed to SQLJ-specific syntax.
                     </p>
                     <div class="tblformal" id="GUID-220F9285-7EBE-4253-AA0C-901511567389__CBBHFEGH">
                        <p class="titleintable">Table 5-1 SQLJ Statement Clauses </p>
                        <table cellpadding="4" cellspacing="0" class="Formal" title="SQLJ Statement Clauses " summary="The following table describes the various SQLJ Statement Clauses." width="100%" frame="hsides" border="1" rules="rows">
                           <thead>
                              <tr align="left" valign="top">
                                 <th align="left" valign="bottom" width="27%" id="d14946e1254">Category</th>
                                 <th align="left" valign="bottom" width="30%" id="d14946e1257">Functionality</th>
                                 <th align="left" valign="bottom" width="43%" id="d14946e1260">More Information</th>
                              </tr>
                           </thead>
                           <tbody>
                              <tr align="left" valign="top">
                                 <td align="left" valign="top" width="27%" id="d14946e1265" headers="d14946e1254 ">
                                    <p><code class="codeph">SELECT INTO</code> clause
                                    </p>
                                 </td>
                                 <td align="left" valign="top" width="30%" headers="d14946e1265 d14946e1257 ">
                                    <p>Select data into Java host expressions.</p>
                                 </td>
                                 <td align="left" valign="top" width="43%" headers="d14946e1265 d14946e1260 ">
                                    <p><span class="q">"<a href="basic-language-features.html#GUID-E779CA66-DE27-48C8-A379-E793AF0FB280">Single-Row Query Results: SELECT INTO Statements</a>"</span></p>
                                 </td>
                              </tr>
                              <tr align="left" valign="top">
                                 <td align="left" valign="top" width="27%" id="d14946e1280" headers="d14946e1254 ">
                                    <p><code class="codeph">FETCH</code> clause
                                    </p>
                                 </td>
                                 <td align="left" valign="top" width="30%" headers="d14946e1280 d14946e1257 ">
                                    <p>Fetch data from a positional iterator.</p>
                                 </td>
                                 <td align="left" valign="top" width="43%" headers="d14946e1280 d14946e1260 ">
                                    <p><span class="q">"<a href="basic-language-features.html#GUID-C99760AC-46A2-446C-8CA6-D032FC4C303D">Using Positional Iterators</a>"</span></p>
                                 </td>
                              </tr>
                              <tr align="left" valign="top">
                                 <td align="left" valign="top" width="27%" id="d14946e1295" headers="d14946e1254 ">
                                    <p><code class="codeph">COMMIT</code> clause
                                    </p>
                                 </td>
                                 <td align="left" valign="top" width="30%" headers="d14946e1295 d14946e1257 ">
                                    <p>Commit changes to the data.</p>
                                 </td>
                                 <td align="left" valign="top" width="43%" headers="d14946e1295 d14946e1260 ">
                                    <p><span class="q">"<a href="key-programming-considerations.html#GUID-25F6527A-8A45-4679-868E-FB53CFFDB0B7">Using Manual COMMIT and ROLLBACK</a>"</span></p>
                                 </td>
                              </tr>
                              <tr align="left" valign="top">
                                 <td align="left" valign="top" width="27%" id="d14946e1310" headers="d14946e1254 ">
                                    <p><code class="codeph">ROLLBACK</code> clause
                                    </p>
                                 </td>
                                 <td align="left" valign="top" width="30%" headers="d14946e1310 d14946e1257 ">
                                    <p>Cancel changes to the data.</p>
                                 </td>
                                 <td align="left" valign="top" width="43%" headers="d14946e1310 d14946e1260 ">
                                    <p><span class="q">"<a href="key-programming-considerations.html#GUID-25F6527A-8A45-4679-868E-FB53CFFDB0B7">Using Manual COMMIT and ROLLBACK</a>"</span></p>
                                 </td>
                              </tr>
                              <tr align="left" valign="top">
                                 <td align="left" valign="top" width="27%" id="d14946e1325" headers="d14946e1254 ">
                                    <p><code class="codeph">SAVEPOINT RELEASE SAVEPOINT ROLLBACK TO</code> clauses
                                    </p>
                                 </td>
                                 <td align="left" valign="top" width="30%" headers="d14946e1325 d14946e1257 ">
                                    <p>Set a savepoint for future rollbacks, release a specified savepoint, roll back to a savepoint.</p>
                                 </td>
                                 <td align="left" valign="top" width="43%" headers="d14946e1325 d14946e1260 ">
                                    <p><span class="q">"<a href="key-programming-considerations.html#GUID-6A5E522A-4B6B-4B59-B644-85A45C82EDE5">Using Savepoints</a>"</span></p>
                                 </td>
                              </tr>
                              <tr align="left" valign="top">
                                 <td align="left" valign="top" width="27%" id="d14946e1344" headers="d14946e1254 ">
                                    <p><code class="codeph">SET TRANSACTION</code> clause
                                    </p>
                                 </td>
                                 <td align="left" valign="top" width="30%" headers="d14946e1344 d14946e1257 ">
                                    <p>Use advanced transaction control for access mode and isolation level.</p>
                                 </td>
                                 <td align="left" valign="top" width="43%" headers="d14946e1344 d14946e1260 ">
                                    <p><span class="q">"<a href="advanced-language-features.html#GUID-3B7EEA7A-5E45-4455-8255-2A5C1334DAD8">Advanced Transaction Control</a>"</span></p>
                                 </td>
                              </tr>
                              <tr align="left" valign="top">
                                 <td align="left" valign="top" width="27%" id="d14946e1359" headers="d14946e1254 ">
                                    <p>Procedure clause</p>
                                 </td>
                                 <td align="left" valign="top" width="30%" headers="d14946e1359 d14946e1257 ">
                                    <p>Call a stored procedure.</p>
                                 </td>
                                 <td align="left" valign="top" width="43%" headers="d14946e1359 d14946e1260 ">
                                    <p><span class="q">"<a href="basic-language-features.html#GUID-CDDD7913-A445-4BB3-8193-1A3C75A577C5">Calling Stored Procedures</a>"</span></p>
                                 </td>
                              </tr>
                              <tr align="left" valign="top">
                                 <td align="left" valign="top" width="27%" id="d14946e1372" headers="d14946e1254 ">
                                    <p>Assignment clause</p>
                                 </td>
                                 <td align="left" valign="top" width="30%" headers="d14946e1372 d14946e1257 ">
                                    <p>Assign values to Java host expressions.</p>
                                 </td>
                                 <td align="left" valign="top" width="43%" headers="d14946e1372 d14946e1260 ">
                                    <p><span class="q">"<a href="basic-language-features.html#GUID-74814900-4067-4EE0-B74B-A9A5F5DED86C">Assignment Statements (SET)</a>"</span></p>
                                 </td>
                              </tr>
                              <tr align="left" valign="top">
                                 <td align="left" valign="top" width="27%" id="d14946e1385" headers="d14946e1254 ">
                                    <p>SQL clause</p>
                                 </td>
                                 <td align="left" valign="top" width="30%" headers="d14946e1385 d14946e1257 ">
                                    <p>Use standard SQL syntax and functionality: <code class="codeph">UPDATE</code>, <code class="codeph">INSERT</code>, <code class="codeph">DELETE</code>.
                                    </p>
                                 </td>
                                 <td align="left" valign="top" width="43%" headers="d14946e1385 d14946e1260 ">
                                    <p>Oracle Database SQL Language Reference</p>
                                 </td>
                              </tr>
                              <tr align="left" valign="top">
                                 <td align="left" valign="top" width="27%" id="d14946e1404" headers="d14946e1254 ">
                                    <p>PL/SQL block</p>
                                 </td>
                                 <td align="left" valign="top" width="30%" headers="d14946e1404 d14946e1257 ">
                                    <p>Use <code class="codeph">BEGIN..END</code> or <code class="codeph">DECLARE..BEGIN..END</code> anonymous block inside SQLJ statement.
                                    </p>
                                 </td>
                                 <td align="left" valign="top" width="43%" headers="d14946e1404 d14946e1260 ">
                                    <p><span class="q">"<a href="basic-language-features.html#GUID-F6528046-15F5-4A5B-9720-57BC82D4A13F">PL/SQL Blocks in Executable Statements</a>"</span></p>
                                    <p><a href="../sqlrf/Introduction-to-Oracle-SQL.html#GUID-049B7AE8-11E1-4110-B3E4-D117907D77AC" target="_blank"><span class="italic">Oracle Database PL/SQL Language Reference</span></a></p>
                                 </td>
                              </tr>
                           </tbody>
                        </table>
                     </div>
                     <!-- class="inftblhruleinformal" -->
                     <div class="tblformal" id="GUID-220F9285-7EBE-4253-AA0C-901511567389__CBBFCJBJ">
                        <p class="titleintable">Table 5-2 SQLJ Assignment Clauses </p>
                        <table cellpadding="4" cellspacing="0" class="Formal" title="SQLJ Assignment Clauses " summary="summary" width="100%" frame="hsides" border="1" rules="rows">
                           <thead>
                              <tr align="left" valign="top">
                                 <th align="left" valign="bottom" width="26%" id="d14946e1438">Category</th>
                                 <th align="left" valign="bottom" width="29%" id="d14946e1441">Functionality</th>
                                 <th align="left" valign="bottom" width="45%" id="d14946e1444">More Information</th>
                              </tr>
                           </thead>
                           <tbody>
                              <tr align="left" valign="top">
                                 <td align="left" valign="top" width="26%" id="d14946e1449" headers="d14946e1438 ">
                                    <p>Query clause</p>
                                 </td>
                                 <td align="left" valign="top" width="29%" headers="d14946e1449 d14946e1441 ">
                                    <p>Select data into a SQLJ iterator.</p>
                                 </td>
                                 <td align="left" valign="top" width="45%" headers="d14946e1449 d14946e1444 ">
                                    <p><span class="q">"<a href="basic-language-features.html#GUID-C6E5904A-2D17-40EA-9DF2-AD5BCEA58E2D">Multirow Query Results: SQLJ Iterators</a>"</span></p>
                                 </td>
                              </tr>
                              <tr align="left" valign="top">
                                 <td align="left" valign="top" width="26%" id="d14946e1462" headers="d14946e1438 ">
                                    <p>Function clause</p>
                                 </td>
                                 <td align="left" valign="top" width="29%" headers="d14946e1462 d14946e1441 ">
                                    <p>Call a stored function.</p>
                                 </td>
                                 <td align="left" valign="top" width="45%" headers="d14946e1462 d14946e1444 ">
                                    <p><span class="q">"<a href="basic-language-features.html#GUID-18E7A8FC-D16A-4A57-9A9E-B85919E9160D">Calling Stored Functions</a>"</span></p>
                                 </td>
                              </tr>
                              <tr align="left" valign="top">
                                 <td align="left" valign="top" width="26%" id="d14946e1475" headers="d14946e1438 ">
                                    <p>Iterator conversion clause</p>
                                 </td>
                                 <td align="left" valign="top" width="29%" headers="d14946e1475 d14946e1441 ">
                                    <p>Convert a JDBC result set to a SQLJ iterator.</p>
                                 </td>
                                 <td align="left" valign="top" width="45%" headers="d14946e1475 d14946e1444 ">
                                    <p><span class="q">"<a href="advanced-language-features.html#GUID-76329A99-A510-4BEB-8271-46F689A10D2D__I1007234">Converting from Result Sets to Named or Positional Iterators</a>"</span></p>
                                 </td>
                              </tr>
                           </tbody>
                        </table>
                     </div>
                     <!-- class="inftblhruleinformal" -->
                     <div class="infoboxnote" id="GUID-220F9285-7EBE-4253-AA0C-901511567389__GUID-6A6AF323-2553-452A-A00E-FC91EFE4F30C">
                        <p class="notep1">Note:</p>
                        <p>A SQLJ statement is referred to by the same name as the clause that makes up the body of that statement. For example, an executable statement consisting of <code class="codeph">#sql</code> followed by a <code class="codeph">SELECT INTO</code> clause is referred to as a <code class="codeph">SELECT INTO</code> statement.
                        </p>
                     </div>
                  </div>
               </div><a id="JSQLJ287"></a><div class="props_rev_3"><a id="GUID-9F93C716-2C14-4AD0-B68F-EAC2CEDCDA60" name="GUID-9F93C716-2C14-4AD0-B68F-EAC2CEDCDA60"></a><h4 id="JSQLJ-GUID-9F93C716-2C14-4AD0-B68F-EAC2CEDCDA60" class="sect4">Specifying Connection Context Instances and Execution Context Instances</h4>
                  <div>
                     <div class="section">
                        <p>If you have defined multiple database connections and want to specify a particular connection context instance for an executable statement, then use the following syntax:</p><pre class="oac_no_warn" dir="ltr">#sql [<span class="italic">conn_context_instance</span>] { <span class="italic">SQL operation</span> };
</pre><p>If you have defined one or more execution context instances of the <code class="codeph">sqlj.runtime.ExecutionContext</code> class and want to specify one of them for use with an executable statement, then use the following syntax:
                        </p><pre class="oac_no_warn" dir="ltr">#sql [<span class="italic">exec_context_instance</span>] { <span class="italic">SQL operation</span> };
</pre><p>You can use an execution context instance to provide status or control of the SQL operation of a SQLJ executable statement. For example, you can use execution context instances in multithreading situations where multiple operations are occurring on the same connection.</p>
                        <p>You can also specify both a connection context instance and an execution context instance:</p><pre class="oac_no_warn" dir="ltr">#sql [<span class="italic">conn_context_instance</span>, <span class="italic">exec_context_instance</span>] { <span class="italic">SQL operation</span> };
</pre><div class="infoboxnote" id="GUID-9F93C716-2C14-4AD0-B68F-EAC2CEDCDA60__GUID-5CC4BDCF-C688-4DD6-83CD-DEA0DF4B3063">
                           <p class="notep1">Note:</p>
                           <ul style="list-style-type: disc;">
                              <li>
                                 <p>Include the square brackets around connection context instances and execution context instances. They are part of the syntax.</p>
                              </li>
                              <li>
                                 <p>If you specify both a connection context instance and an execution context instance, then the connection context instance must come first.</p>
                              </li>
                           </ul>
                        </div>
                     </div>
                     <!-- class="section" -->
                  </div>
               </div><a id="JSQLJ289"></a><a id="JSQLJ290"></a><a id="JSQLJ291"></a><a id="JSQLJ288"></a><div class="props_rev_3"><a id="GUID-18435E67-4949-46CE-9227-2F159D830774" name="GUID-18435E67-4949-46CE-9227-2F159D830774"></a><h4 id="JSQLJ-GUID-18435E67-4949-46CE-9227-2F159D830774" class="sect4">Executable Statement Examples</h4>
                  <div>
                     <p>This section provides examples of elementary SQLJ executable statements.</p>
                     <div class="section">
                        <p class="subhead3" id="GUID-18435E67-4949-46CE-9227-2F159D830774__GUID-0DC777D5-3F22-479C-A332-D9F7E0B206EE">Elementary INSERT</p>
                     </div>
                     <!-- class="section" -->
                     <div class="section">
                        <p>The following example demonstrates a basic <code class="codeph">INSERT</code>. The statement clause does not require any syntax specific to SQLJ.
                        </p>
                        <p>Consider an employee table <code class="codeph">EMP</code> with the following rows:
                        </p><pre class="oac_no_warn" dir="ltr">CREATE TABLE EMP (
   ENAME VARCHAR2(10),
   SAL NUMBER(7,2) );
</pre><p>Use the following SQLJ executable statement, which uses only standard SQL syntax, to insert Joe as a new employee into the <code class="codeph">EMP</code> table, specifying his name and salary:
                        </p><pre class="oac_no_warn" dir="ltr">#sql { INSERT INTO emp (ename, sal) VALUES ('Joe', 43000) };</pre></div>
                     <!-- class="section" -->
                     <div class="section">
                        <p class="subhead3" id="GUID-18435E67-4949-46CE-9227-2F159D830774__GUID-007BAA27-433E-4788-9CAB-B279CB77D21F">Elementary INSERT with Connection Context or Execution Context Instances</p>
                     </div>
                     <!-- class="section" -->
                     <div class="section">
                        <p>The following examples use <code class="codeph">ctx</code> as a connection context instance, which is an instance of either the default <code class="codeph">sqlj.runtime.ref.DefaultContext</code> or a class that you have previously declared in a connection context declaration, and <code class="codeph">execctx</code> as an execution context instance:
                        </p><pre class="oac_no_warn" dir="ltr">#sql [ctx] { INSERT INTO emp (ename, sal) VALUES ('Joe', 43000) };

#sql [execctx] { INSERT INTO emp (ename, sal) VALUES ('Joe', 43000) };

#sql [ctx, execctx] { INSERT INTO emp (ename, sal) VALUES ('Joe', 43000) };</pre></div>
                     <!-- class="section" -->
                     <div class="section">
                        <p class="subhead3" id="GUID-18435E67-4949-46CE-9227-2F159D830774__GUID-EA7C2D1B-03FF-4257-B7B5-031F7FE51753">A Simple SQLJ Method</p>
                     </div>
                     <!-- class="section" -->
                     <div class="section">
                        <p>This example demonstrates a simple method using SQLJ code, demonstrating how SQLJ statements interrelate with and are interspersed with Java statements. The SQLJ statement uses standard <code class="codeph">INSERT INTO </code><span class="italic"><code class="codeph">table</code></span><code class="codeph"> VALUES</code> syntax supported by the Oracle SQL implementation. The statement also uses Java host expressions, marked by colons (:), to define the values. Host expressions are used to pass data between the Java code and SQL instructions.
                        </p><pre class="oac_no_warn" dir="ltr">public static void writeSalesData (int[] itemNums, String[] itemNames)
       throws SQLException
{
  for (int i =0; i &lt; itemNums.length; i++)
    #sql { INSERT INTO sales VALUES(:(itemNums[i]), :(itemNames[i]), SYSDATE) };
}
</pre><div class="infoboxnote" id="GUID-18435E67-4949-46CE-9227-2F159D830774__GUID-A509F578-D7E6-43CF-8DBE-47C9BC56A4A6">
                           <p class="notep1">Note:</p>
                           <ul style="list-style-type: disc;">
                              <li>
                                 <p>The <code class="codeph">throws SQLException</code> <span class="italic">is</span> required.
                                 </p>
                              </li>
                              <li>
                                 <p>SQLJ function calls also use a <code class="codeph">VALUES</code> token, but these situations are not related semantically.
                                 </p>
                              </li>
                           </ul>
                        </div>
                     </div>
                     <!-- class="section" -->
                  </div>
               </div><a id="JSQLJ292"></a><div class="props_rev_3"><a id="GUID-F6528046-15F5-4A5B-9720-57BC82D4A13F" name="GUID-F6528046-15F5-4A5B-9720-57BC82D4A13F"></a><h4 id="JSQLJ-GUID-F6528046-15F5-4A5B-9720-57BC82D4A13F" class="sect4">PL/SQL Blocks in Executable Statements</h4>
                  <div>
                     <p>PL/SQL blocks can be used within the curly braces of a SQLJ executable statement just as SQL operations can, as in the following example: </p><pre class="oac_no_warn" dir="ltr">#sql {
   DECLARE
      n NUMBER;
   BEGIN
      n := 1;
      WHILE n &lt;= 100 LOOP
         INSERT INTO emp (empno) VALUES(2000 + n);
         n := n + 1;
      END LOOP;
   END
};
</pre><p>This example goes through a loop that inserts new employees in the <code class="codeph">emp</code> table, creating employee numbers <code class="codeph">2001</code> through <code class="codeph">2100</code>. It presumes data other than the employee number will be filled in later.
                     </p>
                     <p>Simple PL/SQL blocks can also be coded in a single line as follows:</p><pre class="oac_no_warn" dir="ltr">#sql { &lt;DECLARE ...&gt; BEGIN ... END; };
</pre><p>Using PL/SQL anonymous blocks within SQLJ statements is one way to use dynamic SQL in your application. You can also use dynamic SQL directly through SQLJ extensions provided by Oracle or through JDBC code within a SQLJ application.</p>
                     <div class="infoboxnotealso" id="GUID-F6528046-15F5-4A5B-9720-57BC82D4A13F__GUID-77D881AD-AE1A-47D6-A8D3-C4AC57DFE361">
                        <p class="notep1">See Also:</p>
                        <p><span class="q">"<a href="advanced-language-features.html#GUID-1A237022-5F1E-4C29-87D3-8E913F59C3FA">Support for Dynamic SQL</a>"</span> and <span class="q">"<a href="advanced-language-features.html#GUID-8AF6CBB6-D6B3-44AB-99D5-5ADF6495E568">SQLJ and JDBC Interoperability</a>"</span></p>
                     </div>
                     <div class="infoboxnote" id="GUID-F6528046-15F5-4A5B-9720-57BC82D4A13F__GUID-ECEA8F47-063C-4110-80B3-8D7BB304F2CA">
                        <p class="notep1">Note:</p>
                        <p>Remember that using PL/SQL in your SQLJ code would prevent portability to other platforms, because PL/SQL is Oracle-specific.</p>
                     </div>
                  </div>
               </div>
            </div><a id="JSQLJ293"></a><div class="props_rev_3"><a id="GUID-7B85631F-98E1-4A9A-BBC1-181A53D0D03D" name="GUID-7B85631F-98E1-4A9A-BBC1-181A53D0D03D"></a><h3 id="JSQLJ-GUID-7B85631F-98E1-4A9A-BBC1-181A53D0D03D" class="sect3">Java Host, Context, and Result Expressions</h3>
               <div>
                  <p>This section discusses three categories of Java expressions used in SQLJ code: host expressions, context expressions, and result expressions. Host expressions are the most frequently used Java expressions. Another category of expressions, called meta bind expressions, are used specifically for dynamic SQL operations and use syntax similar to that of host expressions.</p>
                  <div class="infoboxnotealso" id="GUID-7B85631F-98E1-4A9A-BBC1-181A53D0D03D__GUID-8D540532-3EA5-4911-AEB9-C691C877B93F">
                     <p class="notep1">See Also:</p>
                     <p><span class="q">"<a href="advanced-language-features.html#GUID-1A237022-5F1E-4C29-87D3-8E913F59C3FA">Support for Dynamic SQL</a>"</span></p>
                  </div>
                  <p>SQLJ uses Java host expressions to pass arguments between Java code and SQL operations. This is how you pass information between Java and SQL. Host expressions are interspersed within the embedded SQL operations in the SQLJ source code.</p>
                  <p>The most basic kind of host expression, consisting of only a Java identifier, is referred to as a host variable. A context expression specifies a connection context instance or execution context instance to be used for a SQLJ statement. A result expression specifies an output variable for query results or a function return.</p>
                  <p>This section covers the following topics:</p>
                  <ul style="list-style-type: disc;">
                     <li>
                        <p><a href="basic-language-features.html#GUID-F0DDF3C8-67A5-421E-A247-5318A74A6315">Overview of Host Expressions</a></p>
                     </li>
                     <li>
                        <p><a href="basic-language-features.html#GUID-C3594B6E-CF2F-4020-B995-314E9957E520">Basic Host Expression Syntax</a></p>
                     </li>
                     <li>
                        <p><a href="basic-language-features.html#GUID-25BF2A93-76D4-4232-96BD-8BC80F9B7386">Examples of Host Expressions</a></p>
                     </li>
                     <li>
                        <p><a href="basic-language-features.html#GUID-E2AFA583-2CEB-4EC3-9C13-BA21BFEBDD52">Overview of Result Expressions and Context Expressions</a></p>
                     </li>
                     <li>
                        <p><a href="basic-language-features.html#GUID-B76F8910-AA7B-4DF0-B470-02E27829862E">Evaluation of Java Expressions at Run Time</a></p>
                     </li>
                     <li>
                        <p><a href="basic-language-features.html#GUID-A06DF3CD-7BB2-42FC-A01E-3B6A5C5AE60F">Examples of Evaluation of Java Expressions at Run Time (ISO Code Generation)</a></p>
                     </li>
                     <li>
                        <p><a href="basic-language-features.html#GUID-AE6CB258-0865-40BB-AC83-7057FC1798F7">Restrictions on Host Expressions</a></p>
                     </li>
                  </ul>
               </div><a id="JSQLJ294"></a><div class="props_rev_3"><a id="GUID-F0DDF3C8-67A5-421E-A247-5318A74A6315" name="GUID-F0DDF3C8-67A5-421E-A247-5318A74A6315"></a><h4 id="JSQLJ-GUID-F0DDF3C8-67A5-421E-A247-5318A74A6315" class="sect4">Overview of Host Expressions</h4>
                  <div>
                     <p>Any valid Java expression can be used as a host expression. In the simplest case, the expression consists of just a single Java variable. Other kinds of host expressions include the following:</p>
                     <ul style="list-style-type: disc;">
                        <li>
                           <p>Arithmetic expressions</p>
                        </li>
                        <li>
                           <p>Java method calls with return values</p>
                        </li>
                        <li>
                           <p>Java class field values</p>
                        </li>
                        <li>
                           <p>Array elements</p>
                        </li>
                        <li>
                           <p>Conditional expressions (<code class="codeph">a ? b : c</code>)
                           </p>
                        </li>
                        <li>
                           <p>Logical expressions</p>
                        </li>
                        <li>
                           <p>Bitwise expressions</p>
                        </li>
                     </ul>
                     <p>Java identifiers used as host variables or in host expressions can represent any of the following:</p>
                     <ul style="list-style-type: disc;">
                        <li>
                           <p>Local variables</p>
                        </li>
                        <li>
                           <p>Declared parameters</p>
                        </li>
                        <li>
                           <p>Class fields</p>
                        </li>
                        <li>
                           <p>Static or instance method calls</p>
                        </li>
                     </ul>
                     <p>Local variables used in host expressions can be declared anywhere that other Java variables can be declared. Fields can be inherited from a superclass.</p>
                     <p>Java variables that are legal in the Java scope where the SQLJ executable statement appears can be used in a host expression in a SQL statement, presuming its type is convertible to or from a SQL data type. Host expressions can be input, output, or input-output.</p>
                     <div class="infoboxnotealso" id="GUID-F0DDF3C8-67A5-421E-A247-5318A74A6315__GUID-87DE464E-FB49-4E4D-9AF1-A0FBE98DFFA9">
                        <p class="notep1">See Also:</p>
                        <p><span class="q">"<a href="type-support.html#GUID-81FC46CA-8D0E-43F8-BD02-F9AA31625DEC">Supported Types for Host Expressions</a>"</span></p>
                     </div>
                  </div>
               </div><a id="JSQLJ296"></a><a id="JSQLJ297"></a><a id="JSQLJ295"></a><div class="props_rev_3"><a id="GUID-C3594B6E-CF2F-4020-B995-314E9957E520" name="GUID-C3594B6E-CF2F-4020-B995-314E9957E520"></a><h4 id="JSQLJ-GUID-C3594B6E-CF2F-4020-B995-314E9957E520" class="sect4">Basic Host Expression Syntax</h4>
                  <div>
                     <p>A host expression is preceded by a colon (:). If the desired mode of the host expression is not the default, then the colon must be followed by <code class="codeph">IN</code>, <code class="codeph">OUT</code>, or <code class="codeph">INOUT</code>, as appropriate, before the host expression itself. These are referred to as mode specifiers. The default is <code class="codeph">OUT</code> if the host expression is part of an <code class="codeph">INTO</code>-list or is the assignment expression in a <code class="codeph">SET</code> statement. Otherwise, the default is <code class="codeph">IN</code>. Any <code class="codeph">OUT</code> or <code class="codeph">INOUT</code> host expression must be assignable.
                     </p>
                     <div class="infoboxnote" id="GUID-C3594B6E-CF2F-4020-B995-314E9957E520__GUID-45F79AB9-9714-4E42-AF4B-F95D201EB1F8">
                        <p class="notep1">Note:</p>
                        <p>When using the default, you can still include the mode specifier if desired.</p>
                     </div>
                     <p>The SQL code that surrounds a host expression can use any vendor-specific SQL syntax. Therefore, no assumptions can be made about the syntax when parsing the SQL operations and determining the host expressions. To avoid any possible ambiguity, any host expression that is not a simple host variable (in other words, that is more complex than a nondotted Java identifier) must be enclosed in parentheses.</p>
                     <p>To summarize the basic syntax:</p>
                     <ul style="list-style-type: disc;">
                        <li>
                           <p>For a simple host variable without a mode specifier, put the host variable after the colon, as in the following example:</p><pre class="oac_no_warn" dir="ltr">:hostvar
</pre></li>
                        <li>
                           <p>For a simple host variable with a mode specifier, put the mode specifier after the colon and put white space (space, tab, newline, or comment) between the mode specifier and the host variable, as in the following example:</p><pre class="oac_no_warn" dir="ltr">:INOUT hostvar
</pre><p>The white space is required to distinguish between the mode specifier and the variable name.</p>
                        </li>
                        <li>
                           <p>For any other host expression, enclose the expression in parentheses and place it after the mode specifier or after the colon, if there is no mode specifier, as in the following examples:</p><pre class="oac_no_warn" dir="ltr">:IN(hostvar1+hostvar2)
:(hostvar3*hostvar4)
:(index--)
</pre><p>White space is not required after the mode specifier in this example, because the parenthesis is a suitable separator. However, a white space after the mode specifier is allowed.</p>
                           <p>An outer set of parentheses is needed even if the expression already starts with a begin-parenthesis, as in the following examples:</p><pre class="oac_no_warn" dir="ltr">:((x+y).z)
:(((y)x).myOutput())</pre></li>
                     </ul>
                     <div class="section">
                        <p class="subhead3" id="GUID-C3594B6E-CF2F-4020-B995-314E9957E520__GUID-13720975-2C30-445C-9A36-3C2726763CBA">Syntax Notes</p>
                     </div>
                     <!-- class="section" -->
                     <div class="section">
                        <p>Keep the following in mind regarding the host expression syntax:</p>
                        <ul style="list-style-type: disc;">
                           <li>
                              <p>White space is always allowed after the colon as well as after the mode specifier. Wherever white space is allowed, you can also have a comment.</p>
                              <p>You can have any of the following in the SQL namespace:</p>
                              <ul style="list-style-type: disc;">
                                 <li>
                                    <p>SQL comments after the colon and before the mode specifier</p>
                                 </li>
                                 <li>
                                    <p>SQL comments after the colon and before the host expression if there is no mode specifier</p>
                                 </li>
                                 <li>
                                    <p>SQL comments after the mode specifier and before the host expression</p>
                                 </li>
                              </ul>
                              <p>You can have the following in the Java namespace:</p>
                              <ul style="list-style-type: disc;">
                                 <li>
                                    <p>Java comments within the host expression (inside the parentheses)</p>
                                 </li>
                              </ul>
                           </li>
                           <li>
                              <p>The <code class="codeph">IN</code>, <code class="codeph">OUT</code>, and <code class="codeph">INOUT</code> syntax used for host variables and expressions are not case-sensitive. These tokens can be in uppercase, lowercase, or mixed.
                              </p>
                           </li>
                           <li>
                              <p>Do not confuse the <code class="codeph">IN</code>, <code class="codeph">OUT</code>, and <code class="codeph">INOUT</code> syntax of SQLJ host expressions with similar <code class="codeph">IN</code>, <code class="codeph">OUT</code>, and <code class="codeph">IN OUT</code> syntax used in PL/SQL declarations to specify the mode of parameters passed to PL/SQL stored functions and procedures.
                              </p>
                           </li>
                        </ul>
                     </div>
                     <!-- class="section" -->
                     <div class="section">
                        <p class="subhead3" id="GUID-C3594B6E-CF2F-4020-B995-314E9957E520__GUID-B4A1CD99-81BB-4310-83DC-55A2DE77C32E">Usage Notes</p>
                     </div>
                     <!-- class="section" -->
                     <div class="section">
                        <p>Keep the following in mind regarding the usage of host expressions:</p>
                        <ul style="list-style-type: disc;">
                           <li>
                              <p>A simple host variable can appear multiple times in the same SQLJ statement, as follows:</p>
                              <ul style="list-style-type: disc;">
                                 <li>
                                    <p>If the host variable appears only as an input variable, then there are no restrictions or complications.</p>
                                 </li>
                                 <li>
                                    <p>If at least one appearance of the host variable is as an output variable in a PL/SQL block, then you will receive a portability warning if the translator <code class="codeph">-warn=portability</code> flag is set. SQLJ run-time behavior in this situation is vendor-specific. Oracle SQLJ run time uses value semantics, as opposed to reference semantics, for all occurrences of the host variable.
                                    </p>
                                 </li>
                                 <li>
                                    <p>If at least one appearance of the host variable is as an output variable in a stored procedure call, stored function call, <code class="codeph">SET</code> statement, or <code class="codeph">INTO</code>-list, then you will <span class="italic">not</span> receive any warning. SQLJ run-time behavior in this situation is standardized, using value semantics.
                                    </p>
                                 </li>
                              </ul>
                              <div class="infoboxnote" id="GUID-C3594B6E-CF2F-4020-B995-314E9957E520__GUID-2E0FEE89-60BF-44F0-8947-92E4C7FDE50B">
                                 <p class="notep1">Note:</p>
                                 <p>The term output refers to <code class="codeph">OUT</code> or <code class="codeph">INOUT</code> variables, as applicable.
                                 </p>
                              </div>
                           </li>
                           <li>
                              <p>If a host expression that is a simple host variable appears multiple times in a SQLJ statement, then by default each appearance is treated completely independently of the other appearances, using value semantics. However, if you use the SQLJ translator <code class="codeph">-bind-by-identifier=true</code> setting, then this is not the case. With a <code class="codeph">true</code> setting, multiple appearances of the same host variable in a given SQLJ statement or PL/SQL block are treated as a single bind occurrence.
                              </p>
                           </li>
                           <li>
                              <p>When binding a string host expression into a <code class="codeph">WHERE</code> clause for comparison against <code class="codeph">CHAR</code> data, be aware that there is a SQLJ option, <code class="codeph">-fixedchar</code>, that accounts for blank padding in the <code class="codeph">CHAR</code> column when the comparison is made.
                              </p>
                           </li>
                        </ul>
                     </div>
                     <!-- class="section" -->
                  </div>
               </div><a id="JSQLJ299"></a><a id="JSQLJ300"></a><a id="JSQLJ301"></a><a id="JSQLJ302"></a><a id="JSQLJ298"></a><div class="props_rev_3"><a id="GUID-25BF2A93-76D4-4232-96BD-8BC80F9B7386" name="GUID-25BF2A93-76D4-4232-96BD-8BC80F9B7386"></a><h4 id="JSQLJ-GUID-25BF2A93-76D4-4232-96BD-8BC80F9B7386" class="sect4">Examples of Host Expressions</h4>
                  <div>
                     <div class="section">
                        <p>The following examples will help clarify the preceding syntax discussion.</p>
                        <div class="infoboxnote" id="GUID-25BF2A93-76D4-4232-96BD-8BC80F9B7386__GUID-58FFC95E-D8BA-4972-9BD6-4DF99A18063D">
                           <p class="notep1">Note:</p>
                           <p>Some of these examples use <code class="codeph">SELECT INTO</code> statements, which are described in <span class="q">"<a href="basic-language-features.html#GUID-E779CA66-DE27-48C8-A379-E793AF0FB280">Single-Row Query Results: SELECT INTO Statements</a>"</span>.
                           </p>
                        </div>
                     </div>
                     <!-- class="section" -->
                     <div class="section">
                        <p class="subhead3" id="GUID-25BF2A93-76D4-4232-96BD-8BC80F9B7386__GUID-2AB8820C-1B3F-4E50-9A6F-8036E0D056CF">Example 1</p>
                     </div>
                     <!-- class="section" -->
                     <div class="section">
                        <p>In this example, two input host variables are used, one as a test value for a <code class="codeph">WHERE</code> clause and one to contain new data to be sent to the database.
                        </p>
                        <p>Presume you have a database employee table <code class="codeph">emp</code> with an <code class="codeph">ename</code> column for employee names and a <code class="codeph">sal</code> column for employee salaries. The relevant Java code that defines the host variables is as follows:
                        </p><pre class="oac_no_warn" dir="ltr">String empname = "SMITH";
double salary = 25000.0;
...
#sql { UPDATE emp SET sal = :salary WHERE ename = :empname };
</pre><p><code class="codeph">IN</code> is the default, but you can state it explicitly as well:
                        </p><pre class="oac_no_warn" dir="ltr">#sql { UPDATE emp SET sal = :IN salary WHERE ename = :IN empname };
</pre><p>As you can see, the colon (:) can immediately precede the variable when not using the <code class="codeph">IN</code> token, but <code class="codeph">:IN</code> must be followed by white space before the host variable.
                        </p>
                     </div>
                     <!-- class="section" -->
                     <div class="section">
                        <p class="subhead3" id="GUID-25BF2A93-76D4-4232-96BD-8BC80F9B7386__GUID-8C86474E-8248-4EE5-8D33-FF5EF1E0145D">Example 2</p>
                     </div>
                     <!-- class="section" -->
                     <div class="section">
                        <p>This example uses an output host variable in a <code class="codeph">SELECT INTO</code> statement, where you want to find out the name of the employee whose employee number 28959.
                        </p><pre class="oac_no_warn" dir="ltr">String empname;
...
#sql { SELECT ename INTO :empname FROM emp WHERE empno = 28959 };
</pre><p><code class="codeph">OUT</code> is the default for an <code class="codeph">INTO</code>-list, but you can state it explicitly as well:
                        </p><pre class="oac_no_warn" dir="ltr">#sql { SELECT ename INTO :OUT empname FROM emp WHERE empno = 28959 };
</pre><p>This statement looks in the <code class="codeph">empno</code> column of the <code class="codeph">emp</code> table for employee number 28959, selects the name in the <code class="codeph">ename</code> column of that row, and outputs it to the <code class="codeph">empname</code> output host variable, which is a Java <code class="codeph">String</code>.
                        </p>
                     </div>
                     <!-- class="section" -->
                     <div class="section">
                        <p class="subhead3" id="GUID-25BF2A93-76D4-4232-96BD-8BC80F9B7386__GUID-3A31F19A-99D5-4DA5-92AA-19308CCE64E5">Example 3</p>
                     </div>
                     <!-- class="section" -->
                     <div class="section">
                        <p>This example uses an arithmetic expression as an input host expression. The Java variables <code class="codeph">balance</code> and <code class="codeph">minPmtRatio</code> are multiplied, and the result is used to update the <code class="codeph">minPayment</code> column of the <code class="codeph">creditacct</code> table for account number 537845.
                        </p><pre class="oac_no_warn" dir="ltr">float balance = 12500.0;
float minPmtRatio = 0.05;
...
#sql { UPDATE creditacct SET minPayment = :(balance * minPmtRatio) 
       WHERE acctnum = 537845 };
</pre><p>Alternatively, to use the <code class="codeph">IN</code> token:
                        </p><pre class="oac_no_warn" dir="ltr">#sql { UPDATE creditacct SET minPayment = :IN (balance * minPmtRatio) 
       WHERE acctnum = 537845 };
</pre></div>
                     <!-- class="section" -->
                     <div class="section">
                        <p class="subhead3" id="GUID-25BF2A93-76D4-4232-96BD-8BC80F9B7386__GUID-27F0ECC2-3C66-4DBD-BB05-B5AF6CAB9797">Example 4</p>
                     </div>
                     <!-- class="section" -->
                     <div class="section">
                        <p>This example shows the use of the output of a method call as an input host expression and also uses an input host variable. This statement uses the value returned by <code class="codeph">getNewSal()</code> to update the <code class="codeph">sal</code> column in the <code class="codeph">emp</code> table for the employee who is specified by the Java <code class="codeph">empname</code> variable. Java code initializing the host variables is also shown.
                        </p><pre class="oac_no_warn" dir="ltr">String empname = "SMITH";
double raise = 0.1;
...
#sql {UPDATE emp SET sal = :(getNewSal(raise, empname)) 
      WHERE ename = :empname};
</pre></div>
                     <!-- class="section" -->
                  </div>
               </div><a id="JSQLJ303"></a><div class="props_rev_3"><a id="GUID-E2AFA583-2CEB-4EC3-9C13-BA21BFEBDD52" name="GUID-E2AFA583-2CEB-4EC3-9C13-BA21BFEBDD52"></a><h4 id="JSQLJ-GUID-E2AFA583-2CEB-4EC3-9C13-BA21BFEBDD52" class="sect4">Overview of Result Expressions and Context Expressions</h4>
                  <div>
                     <p>A context expression is an input expression that specifies the name of a connection context instance or an execution context instance to be used in a SQLJ executable statement. Any legal Java expression that yields such a name can be used.</p>
                     <p>A result expression is an output expression used for query results or a function return. It can be any legal Java expression that is assignable, meaning that it can logically appear on the left side of an equals sign. This is sometimes referred to as an l-value.</p>
                     <p>The following examples can be used for either result expressions or context expressions:</p>
                     <ul style="list-style-type: disc;">
                        <li>
                           <p>Local variables</p>
                        </li>
                        <li>
                           <p>Declared parameters</p>
                        </li>
                        <li>
                           <p>Class fields</p>
                        </li>
                        <li>
                           <p>Array elements</p>
                        </li>
                     </ul>
                     <p>Result expressions and context expressions appear lexically in the SQLJ space, unlike host expressions, which appear lexically in the SQL space, that is, inside the curly brackets of a SQLJ executable statement. Therefore, a result expression or context expression must <span class="italic">not</span> be preceded by a colon.
                     </p>
                  </div>
               </div><a id="JSQLJ304"></a><div class="props_rev_3"><a id="GUID-B76F8910-AA7B-4DF0-B470-02E27829862E" name="GUID-B76F8910-AA7B-4DF0-B470-02E27829862E"></a><h4 id="JSQLJ-GUID-B76F8910-AA7B-4DF0-B470-02E27829862E" class="sect4">Evaluation of Java Expressions at Run Time</h4>
                  <div>
                     <p>This section discusses the evaluation of Java host expressions, connection context expressions, execution context expressions, and result expressions when your application executes.</p>
                     <p>Following is a simplified representation of a SQLJ executable statement that uses all these kinds of expressions:</p><pre class="oac_no_warn" dir="ltr">#sql [<span class="italic">connctxt_exp</span>, <span class="italic">execctxt_exp</span>] <span class="italic">result_exp</span> = { <span class="italic">SQL</span> <span class="italic">with host expression</span> };
</pre><p>Java expressions can be used as any of the following, as appropriate:</p>
                     <ul style="list-style-type: disc;">
                        <li>
                           <p>Connection context expression: Evaluated to specify the connection context instance to be used</p>
                        </li>
                        <li>
                           <p>Execution context expression: Evaluated to specify the execution context instance to be used</p>
                        </li>
                        <li>
                           <p>Result expression: To receive results, for example, from a stored function</p>
                        </li>
                        <li>
                           <p>Host expression</p>
                        </li>
                     </ul>
                     <p>For ISO standard code generation, the evaluation of Java expressions is well-defined, even for the use of any side effects that depend on the order in which expressions are evaluated.</p>
                     <p>For Oracle-specific code generation, evaluation of Java expressions follows the ISO standard when there are no side effects, except when the <code class="codeph">-bind-by-identifier</code> option is enabled, but is implementation-specific and subject to change when there are side effects.
                     </p>
                     <div class="infoboxnote" id="GUID-B76F8910-AA7B-4DF0-B470-02E27829862E__GUID-A0E82AD2-2F5D-4E94-975C-4AE8F3618BDD">
                        <p class="notep1">Note:</p>
                        <p>The following discussion and the related examples later do <span class="italic">not</span> apply to Oracle-specific code generation. If you use side effects as described here, then request ISO code generation during translation. 
                        </p>
                     </div>
                     <p>The following is a summary, for ISO code, of the overall order of evaluation, execution, and assignment of Java expressions for each statement that executes during run time. </p>
                     <ol>
                        <li>
                           <p>If there is a connection context expression, then it is evaluated immediately, before any other Java expressions are evaluated.</p>
                        </li>
                        <li>
                           <p>If there is an execution context expression, then it is evaluated after any connection context expression, but before any result expression.</p>
                        </li>
                        <li>
                           <p>If there is a result expression, then it is evaluated after any context expressions, but before any host expressions.</p>
                        </li>
                        <li>
                           <p>After evaluation of any context or result expressions, host expressions are evaluated from left to right as they appear in the SQL operation. As each host expression is encountered and evaluated, its value is saved to be passed to SQL.</p>
                           <p>Each host expression is evaluated once and only once.</p>
                        </li>
                        <li>
                           <p><code class="codeph">IN</code> and <code class="codeph">INOUT</code> parameters are passed to SQL, and the SQL operation is executed.
                           </p>
                        </li>
                        <li>
                           <p>After execution of the SQL operation, the output parameters, Java <code class="codeph">OUT</code> and <code class="codeph">INOUT</code> host expressions, are assigned output in order from left to right as they appear in the SQL operation.
                           </p>
                           <p>Each output host expression is assigned once and only once.</p>
                        </li>
                        <li>
                           <p>The result expression, if there is one, is assigned output last.</p>
                        </li>
                     </ol>
                     <div class="infoboxnote" id="GUID-B76F8910-AA7B-4DF0-B470-02E27829862E__GUID-585FD629-896A-400F-AF4F-E17C0499C889">
                        <p class="notep1">Note:</p>
                        <p>Host expressions inside a PL/SQL block are all evaluated together before any statements within the block are executed. They are evaluated in the order in which they appear, regardless of the control flow within the block.</p>
                     </div>
                     <p>Once the expressions in a statement have been evaluated, input and input-output host expressions are passed to SQL, and then the SQL operation is executed. After execution of the SQL operation, assignments are made to Java output host expressions, input-output host expressions, and result expressions as follows:</p>
                     <ol>
                        <li>
                           <p><code class="codeph">OUT</code> and <code class="codeph">INOUT</code> host expressions are assigned output in order from left to right.
                           </p>
                        </li>
                        <li>
                           <p> The result expression, if there is one, is assigned output last.</p>
                        </li>
                     </ol>
                     <p>Note that during run time, all host expressions are treated as distinct values, even if they share the same name or reference the same object. The execution of each SQL operation is treated as if invoking a remote method, and each host expression is taken as a distinct parameter. Each input or input-output parameter is evaluated and passed as it is first encountered, before any output assignments are made for that statement, and each output parameter is also taken as distinct and is assigned exactly once. </p>
                     <p>It is also important to remember that each host expression is evaluated only once. An <code class="codeph">INOUT</code> expression is evaluated when it is first encountered. When the output assignment is made, the expression itself is not reevaluated nor are any side-effects repeated.
                     </p>
                  </div>
               </div><a id="JSQLJ306"></a><a id="JSQLJ307"></a><a id="JSQLJ308"></a><a id="JSQLJ309"></a><a id="JSQLJ310"></a><a id="JSQLJ305"></a><div class="props_rev_3"><a id="GUID-A06DF3CD-7BB2-42FC-A01E-3B6A5C5AE60F" name="GUID-A06DF3CD-7BB2-42FC-A01E-3B6A5C5AE60F"></a><h4 id="JSQLJ-GUID-A06DF3CD-7BB2-42FC-A01E-3B6A5C5AE60F" class="sect4">Examples of Evaluation of Java Expressions at Run Time (ISO Code Generation)</h4>
                  <div>
                     <div class="section">
                        <p>This section discusses, for ISO code generation, how Java expressions are evaluated when your application executes.</p>
                        <div class="infoboxnote" id="GUID-A06DF3CD-7BB2-42FC-A01E-3B6A5C5AE60F__GUID-8C0ABD3F-DF8F-4DD7-8D41-4400D77546C0">
                           <p class="notep1">Note:</p>
                           <p>Do <span class="italic">not</span> count on these effects if you use Oracle-specific code generation. Request ISO code generation during translation if you depend on such effects.
                           </p>
                        </div>
                     </div>
                     <!-- class="section" -->
                     <div class="section">
                        <p class="subhead3" id="GUID-A06DF3CD-7BB2-42FC-A01E-3B6A5C5AE60F__GUID-AEEB69F2-2E4B-47F4-830B-F1CE4933CC73">Evaluation of Prefix and Postfix Operators</p>
                     </div>
                     <!-- class="section" -->
                     <div class="section">
                        <p>When a Java expression contains a Java postfix increment or decrement operator, the incrementing or decrementing occurs <span class="italic">after</span> the expression has been evaluated. Similarly, when a Java expression contains a Java prefix increment or decrement operator, the incrementing or decrementing occurs <span class="italic">before</span> the expression is evaluated. This is equivalent to how these operators are handled in standard Java code. 
                        </p>
                        <p>The following is an example of postfix operator:</p><pre class="oac_no_warn" dir="ltr">int indx = 1;
...
#sql { ... :OUT (array[indx]) ... :IN (indx++) ... };
</pre><p>This example is evaluated as follows:</p><pre class="oac_no_warn" dir="ltr">#sql { ... :OUT (array[1]) ... :IN (1) ... };
</pre><p>The <code class="codeph">indx</code> variable is incremented to 2 and will have that value the next time it is encountered, but not until after <code class="codeph">:IN (indx++)</code> has been evaluated.
                        </p>
                        <p>The following is the example of postfix operator:</p><pre class="oac_no_warn" dir="ltr">int indx = 1;
...
#sql { ... :OUT (array[indx++]) ... :IN (indx++) ... };
</pre><p>This example is evaluated as follows:</p><pre class="oac_no_warn" dir="ltr">#sql { ... :OUT (array[1]) ... :IN (2) ... };
</pre><p>The variable <code class="codeph">indx</code> is incremented to 2 after the first expression is evaluated, but before the second expression is evaluated. It is incremented to 3 after the second expression is evaluated and will have that value the next time it is encountered.
                        </p>
                        <p>The following example consists of both prefix and postfix operators:</p><pre class="oac_no_warn" dir="ltr">int indx = 1;
...
#sql { ... :OUT (array[++indx]) ... :IN (indx++) ... };
</pre><p>This example is evaluated as follows:</p><pre class="oac_no_warn" dir="ltr">#sql { ... :OUT (array[2]) ... :IN (2) ... };
</pre><p>The variable <code class="codeph">indx</code> is incremented to 2 before the first expression is evaluated. It is incremented to 3 after the second expression is evaluated and will have that value the next time it is encountered.
                        </p>
                     </div>
                     <!-- class="section" -->
                     <div class="section">
                        <p class="subhead3" id="GUID-A06DF3CD-7BB2-42FC-A01E-3B6A5C5AE60F__GUID-4B7E08C2-0A33-4C01-B56F-C4D24B66BE8E">Evaluation Order of IN, INOUT, and OUT Host Expressions</p>
                     </div>
                     <!-- class="section" -->
                     <div class="section">
                        <p>Host expressions are evaluated from left to right. Whether an expression is <code class="codeph">IN</code>, <code class="codeph">INOUT</code>, or <code class="codeph">OUT</code> makes no difference when it is evaluated. All that matters is its position in the left-to-right order.
                        </p>
                        <p>Consider the following example:</p><pre class="oac_no_warn" dir="ltr">int[5] arry;
int n = 0;
...
#sql { SET :OUT (arry[n]) = :(++n) };
</pre><p>This example is evaluated as follows:</p><pre class="oac_no_warn" dir="ltr">#sql { SET :OUT (arry[0]) = 1 };
</pre><p>One might expect input expressions to be evaluated before output expressions, but that is not the case. The expression <code class="codeph">:OUT (arry[n])</code> is evaluated first because it is the left-most expression. Then <code class="codeph">n</code> is incremented prior to evaluation of <code class="codeph">++n</code>, because it is being operated on by a prefix operator. Then <code class="codeph">++n</code> is evaluated as 1. The result will be assigned to <code class="codeph">arry[0]</code>, not <code class="codeph">arry[1]</code>, because <code class="codeph">0</code> was the value of <code class="codeph">n</code> when it was originally encountered.
                        </p>
                     </div>
                     <!-- class="section" -->
                     <div class="section">
                        <p class="subhead3" id="GUID-A06DF3CD-7BB2-42FC-A01E-3B6A5C5AE60F__GUID-894BD299-C504-470C-AEF1-DF5CAF77602D">Expressions in PL/SQL Blocks Are Evaluated Before Statements Are Executed</p>
                     </div>
                     <!-- class="section" -->
                     <div class="section">
                        <p>Host expressions in a PL/SQL block are all evaluated in one sequence, before any have been executed. Consider the following example:</p><pre class="oac_no_warn" dir="ltr">int x=3;
int z=5;
...
#sql { BEGIN :OUT x := 10; :OUT z := :x; END };
System.out.println("x=" + x + ", z=" + z);
</pre><p>This example is evaluated as follows:</p><pre class="oac_no_warn" dir="ltr">#sql { BEGIN :OUT x := 10; :OUT z := 3; END };
</pre><p>Therefore, it would print <code class="codeph">x=10, z=3</code>.
                        </p>
                        <p>All expressions in a PL/SQL block are evaluated before any are executed. In this example, the host expressions in the second statement, <code class="codeph">:OUT z </code>and<code class="codeph"> :x</code>, are evaluated before the first statement is executed. In particular, the second statement is evaluated while <code class="codeph">x</code> still has its original value of <code class="codeph">3</code>, before it has been assigned the value <code class="codeph">10</code>.
                        </p>
                        <p>Consider another example of how expressions are evaluated within a PL/SQL block:</p><pre class="oac_no_warn" dir="ltr">int x=1, y=4, z=3;
...
#sql { BEGIN
         :OUT x := :(y++) + 1;
         :OUT z := :x;
       END };
</pre><p>This example is evaluated as follows:</p><pre class="oac_no_warn" dir="ltr">#sql { BEGIN
          :OUT x := 4 + 1;
          :OUT z := 1;
       END };
</pre><p>The postfix increment operator is executed after <code class="codeph">:(y++)</code> is evaluated, so the expression is evaluated as <code class="codeph">4</code>, which is the initial value of <code class="codeph">y</code>. The second statement, <code class="codeph">:OUT z := :x</code>, is evaluated before the first statement is executed. Therefore, <code class="codeph">x</code> still has its initialized value of <code class="codeph">1</code>. After execution of this block, <code class="codeph">x</code> will have the value <code class="codeph">5</code> and <code class="codeph">z</code> will have the value <code class="codeph">1</code>.
                        </p>
                        <p>The following example demonstrates the difference between two statements appearing in a PL/SQL block in one SQLJ executable statement, and the same statements appearing in separate (consecutive) SQLJ executable statements.</p>
                        <p>First, consider the following, where two statements are in a PL/SQL block.</p><pre class="oac_no_warn" dir="ltr">int y=1;
...
#sql { BEGIN :OUT y := :y + 1; :OUT x := :y + 1; END };
</pre><p>This example is evaluated as follows:</p><pre class="oac_no_warn" dir="ltr">#sql { BEGIN :OUT y := 1 + 1; :OUT x := 1 + 1; END };
</pre><p>The <code class="codeph">:y</code> in the second statement is evaluated before either statement is executed. Therefore, <code class="codeph">y</code> has not yet received its output from the first statement. After execution of this block, both <code class="codeph">x</code> and <code class="codeph">y</code> have the value <code class="codeph">2</code>.
                        </p>
                        <p>Now, consider the situation where the same two statements are in PL/SQL blocks in separate SQLJ executable statements.</p><pre class="oac_no_warn" dir="ltr">int y=1;
#sql { BEGIN :OUT y := :y + 1; END };
#sql { BEGIN :OUT x := :y + 1; END };
</pre><p>The first statement is evaluated as follows:</p><pre class="oac_no_warn" dir="ltr">#sql { BEGIN :OUT y := 1 + 1; END };
</pre><p>Then, it is executed and <code class="codeph">y</code> is assigned the value <code class="codeph">2</code>.
                        </p>
                        <p>After execution of the first statement, the second statement is evaluated as follows:</p><pre class="oac_no_warn" dir="ltr">#sql { BEGIN :OUT x := 2 + 1; END };
</pre><p>This time, as opposed to the previous PL/SQL block example, <code class="codeph">y</code> has already received the value <code class="codeph">2</code> from execution of the previous statement. Therefore, x is assigned the value <code class="codeph">3</code> after execution of the second statement.
                        </p>
                     </div>
                     <!-- class="section" -->
                     <div class="section">
                        <p class="subhead3" id="GUID-A06DF3CD-7BB2-42FC-A01E-3B6A5C5AE60F__GUID-B7376A5A-5F9E-411F-B633-6082C24964B6">Expressions in PL/SQL Blocks Are Always Evaluated Once Only</p>
                     </div>
                     <!-- class="section" -->
                     <div class="section">
                        <p>Each host expression is evaluated once, and only once, regardless of program flow and logic.</p>
                        <p>Consider the following example of evaluation of host expression in a loop:</p><pre class="oac_no_warn" dir="ltr">int count = 0;
...
#sql {
   DECLARE
      n NUMBER
   BEGIN
      n := 1;
      WHILE n &lt;= 100 LOOP
         :IN (count++);
         n := n + 1;
      END LOOP;
   END
};
</pre><p>The Java <code class="codeph">count</code> variable will have the value <code class="codeph">0</code> when it is passed to SQL, because it is operated on by a postfix operator, as opposed to a prefix operator. It will then be incremented to <code class="codeph">1</code> and will hold that value throughout execution of this PL/SQL block. It is evaluated only once as the SQLJ executable statement is parsed and then is replaced by the value <code class="codeph">1</code> prior to SQL execution.
                        </p>
                        <p>Consider the following example that illustrates the evaluation of host expressions in conditional blocks. This example demonstrates how each expression is always evaluated, regardless of the program flow. As the block is executed, only one branch of the <code class="codeph">IF...THEN...ELSE</code> construct can be executed. However, before the block is executed, all expressions in the block are evaluated in the order that the statements appear.
                        </p><pre class="oac_no_warn" dir="ltr">int x;
...
(operations on x)
...
#sql {
   DECLARE
      n NUMBER
   BEGIN
      n := :x;
      IF n &lt; 10 THEN
         n := :(x++);
      ELSE
         n := :x * :x;
      END LOOP;
   END
};
</pre><p>Say the operations performed on <code class="codeph">x</code> resulted in <code class="codeph">x</code> having a value of <code class="codeph">15</code>. When the PL/SQL block is executed, the <code class="codeph">ELSE</code> branch will be executed and the <code class="codeph">IF</code> branch will not. However, all expressions in the PL/SQL block are evaluated before execution, regardless of program logic or flow. Therefore, <code class="codeph">x++</code> is evaluated, then <code class="codeph">x</code> is incremented, and then each <code class="codeph">x</code> is evaluated in the <code class="codeph">(x * x)</code> expression. The <code class="codeph">IF...THEN...ELSE</code> block is evaluated as follows:
                        </p><pre class="oac_no_warn" dir="ltr">IF n &lt; 10 THEN
   n := 15;
ELSE
   n := :16 * :16;
END LOOP;
</pre><p>After execution of this block, given an initial value of <code class="codeph">15</code> for <code class="codeph">x</code>, <code class="codeph">n</code> will have the value <code class="codeph">256</code>.
                        </p>
                     </div>
                     <!-- class="section" -->
                     <div class="section">
                        <p class="subhead3" id="GUID-A06DF3CD-7BB2-42FC-A01E-3B6A5C5AE60F__GUID-318DEC50-346C-46CB-A966-D8CFC333BFF6">Output Host Expressions Are Assigned Left to Right, Before Result Expression</p>
                     </div>
                     <!-- class="section" -->
                     <div class="section">
                        <p>Remember that <code class="codeph">OUT</code> and <code class="codeph">INOUT</code> host expressions are assigned in order from left to right, and then the result expression, if any, is assigned last. If the same variable is assigned more than once, then it will be overwritten according to this order, with the last assignment taking precedence.
                        </p>
                        <p>The following example contains multiple output host expressions referencing the same variable:</p><pre class="oac_no_warn" dir="ltr">#sql { CALL foo(:OUT x, :OUT x) };
</pre><p>If <code class="codeph">foo()</code> outputs the values <code class="codeph">2</code> and <code class="codeph">3</code>, respectively, then <code class="codeph">x</code> will have the value <code class="codeph">3</code> after the SQLJ executable statement has finished executing. The right-hand assignment will be performed last, thereby taking precedence.
                        </p>
                        <p>The following example contains multiple output host expressions referencing the same object:</p><pre class="oac_no_warn" dir="ltr">MyClass x = new MyClass();
MyClass y = x;
...
#sql { ... :OUT (x.field):=1 ... :OUT (y.field):=2 ... };
</pre><p>After execution of the SQLJ executable statement, <code class="codeph">x.field</code> will have a value of <code class="codeph">2</code>, and not <code class="codeph">1</code>, because <code class="codeph">x</code> is the same object as <code class="codeph">y</code>, and <code class="codeph">field</code> was assigned the value of <code class="codeph">2</code> after it was assigned the value of <code class="codeph">1</code>.
                        </p>
                        <p>The following example demonstrates the difference between having the output results of a function assigned to a result expression and having the results assigned to an <code class="codeph">OUT</code> host expression. Consider the following function, with the <code class="codeph">invar</code> input parameter, the <code class="codeph">outvar</code> output parameter, and a return value:
                        </p><pre class="oac_no_warn" dir="ltr">CREATE FUNCTION fn(invar NUMBER, outvar OUT NUMBER)
   RETURN NUMBER AS BEGIN
      outvar := invar + invar;
      return (invar * invar);
   END fn;
</pre><p>Now consider an example where the output of the function is assigned to a result expression:</p><pre class="oac_no_warn" dir="ltr">int x = 3;
#sql x = { VALUES(fn(:x, :OUT x)) };
</pre><p>The function will take <code class="codeph">3</code> as the input, will calculate <code class="codeph">6</code> as the output, and will return <code class="codeph">9</code>. After execution, the <code class="codeph">:OUT x</code> will be assigned first, giving <code class="codeph">x</code> a value of <code class="codeph">6</code>. But finally the result expression is assigned, giving <code class="codeph">x</code> the return value of <code class="codeph">9</code> and overwriting the value of <code class="codeph">6</code> previously assigned to <code class="codeph">x</code>. So <code class="codeph">x</code> will have the value <code class="codeph">9</code> the next time it is encountered.
                        </p>
                        <p>Now consider an example where the output of the function is assigned to an <code class="codeph">OUT</code> host variable instead of a result expression:
                        </p><pre class="oac_no_warn" dir="ltr">int x = 3;
#sql { BEGIN :OUT x := fn(:x, :OUT x); END };
</pre><p>In this case, there is no result expression and the <code class="codeph">OUT</code> variables are simply assigned left to right. After execution, the first <code class="codeph">:OUT x</code>, on the left side of the equation, is assigned first, giving <code class="codeph">x</code> the function return value of <code class="codeph">9</code>. However, proceeding left to right, the second <code class="codeph">:OUT x</code>, on the right side of the equation, is assigned last, giving <code class="codeph">x</code> the output value of <code class="codeph">6</code> and overwriting the value of <code class="codeph">9</code> previously assigned to <code class="codeph">x</code>. Therefore, <code class="codeph">x</code> will have the value <code class="codeph">6</code> the next time it is encountered.
                        </p>
                        <div class="infoboxnote" id="GUID-A06DF3CD-7BB2-42FC-A01E-3B6A5C5AE60F__GUID-C4C16FBB-35A2-4FF9-8668-B3B0677126E6">
                           <p class="notep1">Note:</p>
                           <p>Some unlikely cases have been used in these examples to explain the concepts of how host expressions are evaluated. In practice, it is not advisable to use the same variable in both an <code class="codeph">OUT</code> or <code class="codeph">INOUT</code> host expression or in an <code class="codeph">IN</code> host expression inside a single statement or PL/SQL block. The behavior in such cases is well defined in the Oracle SQLJ implementation, but this practice is not covered in the SQLJ specification. Therefore, code written in this manner will not be portable. Such code will generate a warning from the SQLJ translator if the <code class="codeph">portable</code> flag is set during semantics-checking.
                           </p>
                        </div>
                     </div>
                     <!-- class="section" -->
                  </div>
               </div><a id="JSQLJ311"></a><div class="props_rev_3"><a id="GUID-AE6CB258-0865-40BB-AC83-7057FC1798F7" name="GUID-AE6CB258-0865-40BB-AC83-7057FC1798F7"></a><h4 id="JSQLJ-GUID-AE6CB258-0865-40BB-AC83-7057FC1798F7" class="sect4">Restrictions on Host Expressions</h4>
                  <div>
                     <p>Do not use <code class="codeph">in</code>, <code class="codeph">out</code>, and <code class="codeph">inout</code> as identifiers in host expressions unless they are enclosed in parentheses. Otherwise, they might be mistaken for mode specifiers. This is not case-sensitive.
                     </p>
                     <p>For example, you could use an input host variable called <code class="codeph">in</code>, as follows:
                     </p><pre class="oac_no_warn" dir="ltr">:(in)
</pre><p>or:</p><pre class="oac_no_warn" dir="ltr">:IN(in)
</pre></div>
               </div>
            </div><a id="JSQLJ312"></a><div class="props_rev_3"><a id="GUID-E779CA66-DE27-48C8-A379-E793AF0FB280" name="GUID-E779CA66-DE27-48C8-A379-E793AF0FB280"></a><h3 id="JSQLJ-GUID-E779CA66-DE27-48C8-A379-E793AF0FB280" class="sect3">Single-Row Query Results: SELECT INTO Statements</h3>
               <div>
                  <p>When only a single row of data is being returned, SQLJ enables you to assign selected items directly to Java host expressions inside SQL syntax. This is done using the <code class="codeph">SELECT INTO</code> statement. This section covers the following topics:
                  </p>
                  <ul style="list-style-type: disc;">
                     <li>
                        <p><a href="basic-language-features.html#GUID-917A36A6-18D2-4447-958F-50C0889C258E">SELECT INTO Syntax</a></p>
                     </li>
                     <li>
                        <p><a href="basic-language-features.html#GUID-1AA5FB20-6B8E-4A32-834F-F19F1524D622">Examples of SELECT INTO Statements</a></p>
                     </li>
                     <li>
                        <p><a href="basic-language-features.html#GUID-05A04EF6-4966-4D0E-9EC3-DA64BF97B555">Examples with Host Expressions in SELECT-List</a></p>
                     </li>
                     <li>
                        <p><a href="basic-language-features.html#GUID-D7660C1B-9034-4CA2-848E-544E72F7D87E">SELECT INTO Error Conditions</a></p>
                     </li>
                  </ul>
               </div><a id="JSQLJ313"></a><div class="props_rev_3"><a id="GUID-917A36A6-18D2-4447-958F-50C0889C258E" name="GUID-917A36A6-18D2-4447-958F-50C0889C258E"></a><h4 id="JSQLJ-GUID-917A36A6-18D2-4447-958F-50C0889C258E" class="sect4">SELECT INTO Syntax</h4>
                  <div>
                     <p>The syntax for a <code class="codeph">SELECT INTO</code> statement is as follows:
                     </p><pre class="oac_no_warn" dir="ltr">#sql { SELECT <span class="italic">expression1,..., expressionN </span> INTO :<span class="italic">host_exp1,..., </span>:<span class="italic">host_expN </span> 
       FROM <span class="italic">table </span>&lt;<span class="italic">optional_clauses</span>&gt; };
</pre><p>Keep in mind the following:</p>
                     <ul style="list-style-type: disc;">
                        <li>
                           <p>The items <span class="italic"><code class="codeph">expression1</code></span> through <span class="italic"><code class="codeph">expressionN</code></span> are expressions specifying what is to be selected from the database. These can be any expressions valid for any <code class="codeph">SELECT</code> statement. This list of expressions is referred to as the <code class="codeph">SELECT</code>-list. In a simple case, these would be names of columns from a database table. It is also legal to include a host expression in the <code class="codeph">SELECT</code>-list.
                           </p>
                        </li>
                        <li>
                           <p>The items <span class="italic"><code class="codeph">host_exp1</code></span> through <span class="italic"><code class="codeph">host_expN</code></span> are target host expressions, such as variables or array elements. This list of host expressions is referred to as the <code class="codeph">INTO</code>-list.
                           </p>
                        </li>
                        <li>
                           <p>The item <span class="italic"><code class="codeph">table</code></span> is the name of the database table, view, or snapshot from which you are selecting the data.
                           </p>
                        </li>
                        <li>
                           <p>The item <span class="italic"><code class="codeph">optional_clauses</code></span> is for any additional clauses you want to include that are valid in a <code class="codeph">SELECT</code> statement, such as a <code class="codeph">WHERE</code> clause.
                           </p>
                        </li>
                     </ul>
                     <p>A <code class="codeph">SELECT INTO</code> statement must return one, and only one, row of data, otherwise an error will be generated at run time.
                     </p>
                     <p>The default is <code class="codeph">OUT</code> for a host expression in an <code class="codeph">INTO</code>-list, but you can optionally state this explicitly: 
                     </p><pre class="oac_no_warn" dir="ltr">#sql { SELECT <span class="italic">column_name1, column_name2 </span> INTO :OUT <span class="italic">host_exp1, </span>:OUT <span class="italic">host_exp2 </span> 
       FROM <span class="italic">table </span>WHERE <span class="italic">condition</span> };
</pre><p>Trying to use an <code class="codeph">IN</code> or <code class="codeph">INOUT</code> token in the <code class="codeph">INTO</code>-list will result in an error at translation time.
                     </p>
                     <div class="infoboxnote" id="GUID-917A36A6-18D2-4447-958F-50C0889C258E__GUID-7AD05B4F-ABA0-4367-BDF5-047C9FE6AF92">
                        <p class="notep1">Note:</p>
                        <ul style="list-style-type: disc;">
                           <li>
                              <p>Permissible syntax for <span class="italic"><code class="codeph">expression1</code></span> through <span class="italic"><code class="codeph">expressionN</code></span>, the <span class="italic"><code class="codeph">table</code></span>, and the optional clauses is the same as for any SQL <code class="codeph">SELECT</code> statement.
                              </p>
                           </li>
                           <li>
                              <p>There can be any number of <code class="codeph">SELECT</code>-list and <code class="codeph">INTO</code>-list items, as long as they match. That is, one INTO-list item per SELECT-list item, with compatible types. 
                              </p>
                           </li>
                        </ul>
                     </div>
                  </div>
               </div><a id="JSQLJ314"></a><div class="props_rev_3"><a id="GUID-1AA5FB20-6B8E-4A32-834F-F19F1524D622" name="GUID-1AA5FB20-6B8E-4A32-834F-F19F1524D622"></a><h4 id="JSQLJ-GUID-1AA5FB20-6B8E-4A32-834F-F19F1524D622" class="sect4">Examples of SELECT INTO Statements</h4>
                  <div>
                     <div class="section">
                        <p>The examples in this section use an employee table <code class="codeph">EMP</code> with the following rows:
                        </p><pre class="oac_no_warn" dir="ltr">CREATE TABLE EMP (
   EMPNO NUMBER(4),
   ENAME VARCHAR2(10),
   HIREDATE DATE );
</pre><p>The following is an example of a <code class="codeph">SELECT INTO</code> statement with a single host expression in the <code class="codeph">INTO</code>-list:
                        </p><pre class="oac_no_warn" dir="ltr">String empname;
#sql { SELECT ename INTO :enpname FROM emp WHERE empno=28959 };
</pre><p>The following is an example of a <code class="codeph">SELECT INTO</code> statement with multiple host expressions in the <code class="codeph">INTO</code>-list:
                        </p><pre class="oac_no_warn" dir="ltr">String empname;
Date hdate;
#sql { SELECT ename, hiredate INTO :empname, :hdate FROM emp 
       WHERE empno=28959 };
</pre></div>
                     <!-- class="section" -->
                  </div>
               </div><a id="JSQLJ315"></a><div class="props_rev_3"><a id="GUID-05A04EF6-4966-4D0E-9EC3-DA64BF97B555" name="GUID-05A04EF6-4966-4D0E-9EC3-DA64BF97B555"></a><h4 id="JSQLJ-GUID-05A04EF6-4966-4D0E-9EC3-DA64BF97B555" class="sect4">Examples with Host Expressions in SELECT-List</h4>
                  <div>
                     <p>It is legal to use Java host expressions in the <code class="codeph">SELECT</code>-list as well as in the <code class="codeph">INTO</code>-list. For example, you can select directly from one host expression into another, though this is of limited usefulness, as follows:
                     </p><pre class="oac_no_warn" dir="ltr">...
#sql { SELECT :name1 INTO :name2 FROM emp WHERE empno=28959 };
...
</pre><p>More realistically, you may want to perform an operation or concatenation on the data selected, as in the following examples. Assume Java variables were previously declared and assigned, as necessary.</p><pre class="oac_no_warn" dir="ltr">...
#sql { SELECT sal + :raise INTO :newsal FROM emp WHERE empno=28959 };
...

...
#sql { SELECT :(firstname + " ") || emp_last_name INTO :name FROM myemp 
       WHERE empno=28959 };
...
</pre><p>In the second example, presume <code class="codeph">myemp</code> is a table much like the <code class="codeph">emp</code> table but with an <code class="codeph">emp_last_name</code> column instead of an <code class="codeph">ename</code> column. In the <code class="codeph">SELECT</code> statement, <code class="codeph">firstname</code> is prepended to a single space (" "), using a Java host expression and the Java string concatenation operator (<code class="codeph">+</code>). This result is then passed to the SQL engine, which uses SQL string concatenation operator (<code class="codeph">||</code>) to append the last name.
                     </p>
                  </div>
               </div><a id="JSQLJ316"></a><div class="props_rev_3"><a id="GUID-D7660C1B-9034-4CA2-848E-544E72F7D87E" name="GUID-D7660C1B-9034-4CA2-848E-544E72F7D87E"></a><h4 id="JSQLJ-GUID-D7660C1B-9034-4CA2-848E-544E72F7D87E" class="sect4">SELECT INTO Error Conditions</h4>
                  <div>
                     <p>Remember that <code class="codeph">SELECT INTO</code> statements are intended for queries that return exactly one row of data only. A <code class="codeph">SELECT INTO</code> query that finds zero rows or multiple rows will result in an exception, as follows:
                     </p>
                     <ul style="list-style-type: disc;">
                        <li>
                           <p>A <code class="codeph">SELECT INTO</code> finding no rows will return an exception with a SQL state of <code class="codeph">2000</code>, representing a "no data" condition.
                           </p>
                        </li>
                        <li>
                           <p>A <code class="codeph">SELECT INTO</code> finding multiple rows will return an exception with a SQL state of <code class="codeph">21000</code>, representing a cardinality violation.
                           </p>
                        </li>
                     </ul>
                     <p>You can retrieve the SQL state through the <code class="codeph">getSQLState()</code> method of the <code class="codeph">java.sql.SQLException</code> class.
                     </p>
                     <p>This is vendor-independent behavior that is specified in the ISO SQLJ standard. There is no vendor-specific error code in these cases. The error code is always <code class="codeph">0</code>.
                     </p>
                  </div>
               </div>
            </div><a id="JSQLJ317"></a><div class="props_rev_3"><a id="GUID-C6E5904A-2D17-40EA-9DF2-AD5BCEA58E2D" name="GUID-C6E5904A-2D17-40EA-9DF2-AD5BCEA58E2D"></a><h3 id="JSQLJ-GUID-C6E5904A-2D17-40EA-9DF2-AD5BCEA58E2D" class="sect3">Multirow Query Results: SQLJ Iterators</h3>
               <div>
                  <p>A large number of SQL operations are multirow queries. Processing multirow query results in SQLJ requires a SQLJ iterator. A SQLJ iterator is a strongly typed version of a JDBC result set and is associated with the underlying database cursor. SQLJ iterators are primarily used to take query results from a <code class="codeph">SELECT</code> statement.
                  </p>
                  <p>Additionally, Oracle offers SQLJ extensions that enable you to use SQLJ iterators and result sets in the following ways:</p>
                  <ul style="list-style-type: disc;">
                     <li>
                        <p>As <code class="codeph">OUT</code> host variables in executable SQL statements
                        </p>
                     </li>
                     <li>
                        <p>As <code class="codeph">INTO</code>-list targets, such as in a <code class="codeph">SELECT INTO</code> statement
                        </p>
                     </li>
                     <li>
                        <p>As a return type from a stored function call</p>
                     </li>
                     <li>
                        <p>As column types in iterator declarations (essentially, nested iterators)</p>
                     </li>
                  </ul>
                  <div class="infoboxnote" id="GUID-C6E5904A-2D17-40EA-9DF2-AD5BCEA58E2D__GUID-29C8B40A-22C5-4477-9588-8036C151A1F2">
                     <p class="notep1">Note:</p>
                     <p>To use a SQLJ iterator in any of these ways, its class must be declared as <code class="codeph">public</code>. If you declared it at the class level or nested-class level, then it might be advisable to declare it as <code class="codeph">public static</code>.
                     </p>
                  </div>
                  <p>This section covers the following topics:</p>
                  <ul style="list-style-type: disc;">
                     <li>
                        <p><a href="basic-language-features.html#GUID-C20AEB54-A0BC-4863-8979-DFF181374B2B">Iterator Concepts</a></p>
                     </li>
                     <li>
                        <p><a href="basic-language-features.html#GUID-92CEA05F-80CF-40E1-B5D9-632CB2B10246">General Steps in Using an Iterator</a></p>
                     </li>
                     <li>
                        <p><a href="basic-language-features.html#GUID-4BEB2D79-A90D-4F5F-BAF9-754E717B4EAF">Named_ Positional_ and Result Set Iterators</a></p>
                     </li>
                     <li>
                        <p><a href="basic-language-features.html#GUID-FF318201-3A54-450E-AC86-616665E03DE2">Using Named Iterators</a></p>
                     </li>
                     <li>
                        <p><a href="basic-language-features.html#GUID-C99760AC-46A2-446C-8CA6-D032FC4C303D">Using Positional Iterators</a></p>
                     </li>
                     <li>
                        <p><a href="basic-language-features.html#GUID-D3CC3825-1F5D-45AF-9E96-5848B98B7D21">Using Iterators and Result Sets as Host Variables</a></p>
                     </li>
                     <li>
                        <p><a href="basic-language-features.html#GUID-A8BA5DEF-6CA2-4C06-8073-0F475851B7CA">Using Iterators and Result Sets as Iterator Columns</a></p>
                     </li>
                  </ul>
                  <div class="infoboxnotealso" id="GUID-C6E5904A-2D17-40EA-9DF2-AD5BCEA58E2D__GUID-4BBB0077-9CAB-4816-9F11-BD383566D333">
                     <p class="notep1">See Also:</p>
                     <p><span class="q">"<a href="advanced-language-features.html#GUID-9723BCED-0FA3-4AD9-B6C0-62B85B53C4EF">Iterator Class Implementation and Advanced Functionality</a>"</span></p>
                  </div>
               </div><a id="JSQLJ318"></a><div class="props_rev_3"><a id="GUID-C20AEB54-A0BC-4863-8979-DFF181374B2B" name="GUID-C20AEB54-A0BC-4863-8979-DFF181374B2B"></a><h4 id="JSQLJ-GUID-C20AEB54-A0BC-4863-8979-DFF181374B2B" class="sect4">Iterator Concepts</h4>
                  <div>
                     <p>Using a SQLJ iterator declaration results in a strongly typed iterator. This is the typical usage for iterators and takes particular advantage of SQLJ semantics-checking features during translation. It is also possible, and at times advantageous, to use weakly typed iterators. There are generic classes you can instantiate in order to use a weakly typed iterator.</p>
                     <p>This section covers the following topics:</p>
                     <ul style="list-style-type: disc;">
                        <li>
                           <p><a href="basic-language-features.html#GUID-F02EF0A4-F368-4286-B6E2-61264186BBC1">Overview of Strongly Typed Iterators</a></p>
                        </li>
                        <li>
                           <p><a href="basic-language-features.html#GUID-33DDF8DC-056E-49DB-A17D-CD55AA92F963">Overview of Weakly Typed Iterators</a></p>
                        </li>
                     </ul>
                  </div><a id="JSQLJ320"></a><a id="JSQLJ319"></a><div class="props_rev_3"><a id="GUID-F02EF0A4-F368-4286-B6E2-61264186BBC1" name="GUID-F02EF0A4-F368-4286-B6E2-61264186BBC1"></a><h5 id="JSQLJ-GUID-F02EF0A4-F368-4286-B6E2-61264186BBC1" class="sect5">Overview of Strongly Typed Iterators</h5>
                     <div>
                        <p>Before using a strongly typed iterator object, you must declare an iterator class. An iterator declaration specifies a Java class that SQLJ constructs for you, where the class attributes define the type and, optionally, the name of the columns of data in the iterator.</p>
                        <p>A SQLJ iterator object is an instance of such a specifically declared iterator class, with a fixed number of columns of predefined type. This is as opposed to a JDBC result set object, which is a standard <code class="codeph">java.sql.ResultSet</code> instance and can, in principle, contain any number of columns of any type.
                        </p>
                        <p>When you declare an iterator, you specify either just the data type of the selected columns, or both the data type and the name of the selected columns:</p>
                        <ul style="list-style-type: disc;">
                           <li>
                              <p>Specifying the names and data types defines a named iterator class.</p>
                           </li>
                           <li>
                              <p>Specifying just the data types defines a positional iterator class.</p>
                           </li>
                        </ul>
                        <p>The data types and names, if applicable, that you declare determine how query results will be stored in iterator objects you instantiate from that class. SQL data retrieved into an iterator object are converted to the Java types specified in the iterator declaration.</p>
                        <p>When you query to populate a named iterator object, the name and data type of the columns in the <code class="codeph">SELECT</code> statement must match the name and data type of the iterator columns. However, this is not case-sensitive. The order of the columns in the <code class="codeph">SELECT</code> statement is irrelevant. All that matters is that each column name in the <code class="codeph">SELECT</code> statement matches an iterator column name. In the simplest case, the database column names directly match the iterator column names.
                        </p>
                        <p>For example, data from an <code class="codeph">ENAME</code> column in a database table can be selected and put into an iterator <code class="codeph">ename</code> column. Alternatively, you can use an alias to map a database column name to an iterator column name if the names differ. Also, in a more complicated query, you can perform an operation between two columns and alias the result to match the corresponding iterator column name.
                        </p>
                        <p>Because SQLJ iterators are strongly typed, they offer the benefit of Java type-checking during the SQLJ semantics-checking phase.</p>
                        <p>As an example, consider the following table:</p><pre class="oac_no_warn" dir="ltr">CREATE TABLE EMPSAL (
   EMPNO NUMBER(4),
   ENAME VARCHAR2(10),
   OLDSAL NUMBER(10),
   RAISE NUMBER(10) );
</pre><p>Given this table, you can declare a named iterator as follows.</p><pre class="oac_no_warn" dir="ltr">#sql iterator SalNamedIter (int empno, String ename, float raise);
</pre><p>Once declared, you can use this named iterator as follows:</p><pre class="oac_no_warn" dir="ltr">class MyClass {
   void func() throws SQLException {
      ...
      SalNamedIter niter;
      #sql niter = { SELECT ename, empno, raise FROM empsal };
    
      ... <span class="italic">process niter</span> ...
   }
}
</pre><p>This is a simple case where the iterator column names match the table column names. Note that the order of items in the <code class="codeph">SELECT</code> statement does not matter when you use a named iterator. Data is matched by name, not position.
                        </p>
                        <p>When you query to populate a positional iterator object, the data is retrieved according to the order in which you select the columns. Data from the first column selected from the database table is placed into the first column of the iterator, and so on. The data types of the table columns must be convertible to the types of the iterator columns, but the names of the database columns are irrelevant, as the iterator columns have no names.</p>
                        <p>Given the <code class="codeph">EMPSAL</code> table, you can declare a positional iterator as follows:
                        </p><pre class="oac_no_warn" dir="ltr">#sql iterator SalPosIter (int, String, float);
</pre><p>You can use this positional iterator as follows:</p><pre class="oac_no_warn" dir="ltr">class MyClass {
   void func() throws SQLException {
      ...
      SalPosIter piter;
      #sql piter = { SELECT empno, ename, raise FROM empsal };
    
      ... <span class="italic">process piter</span> ...
   }
}
</pre><p>Note that the order of the data items in the <code class="codeph">SELECT</code> statement must be the same as in the iterator. The processing differs between named iterators and positional iterators.
                        </p>
                        <div class="section">
                           <p class="subhead3" id="GUID-F02EF0A4-F368-4286-B6E2-61264186BBC1__GUID-593FB6DE-90C3-4E8E-9DF6-48A604519CC9">General Iterator Notes</p>
                        </div>
                        <!-- class="section" -->
                        <div class="section">
                           <p>In addition to the preceding concepts, be aware of the following general notes about iterators:</p>
                           <ul style="list-style-type: disc;">
                              <li>
                                 <p>The <code class="codeph">SELECT *</code> syntax is allowed in populating an iterator, but is not recommended. In the case of a positional iterator, this requires that the number of columns in the table be equal to the number of columns in the iterator, and that the data types match in order. In the case of a named iterator, this requires that the number of columns in the table be greater than or equal to the number of columns in the iterator and that the name and data type of each iterator column match a database table column. However, if the number of columns in the table is greater, then a warning will be generated unless the translator <code class="codeph">-warn=nostrict</code> flag is set.
                                 </p>
                              </li>
                              <li>
                                 <p>Positional and named iterators are distinct and incompatible kinds of Java classes. An iterator object of one kind cannot be cast to an iterator object of the other kind.</p>
                              </li>
                              <li>
                                 <p>Unlike a SQL cursor, an iterator instance is a first-class Java object. That is, it can be passed and returned as a method parameter, for example. Also, an iterator instance can be declared using Java class modifiers, such as <code class="codeph">public</code> or <code class="codeph">private</code>.
                                 </p>
                              </li>
                              <li>
                                 <p>SQLJ supports interoperability and conversion between SQLJ iterators and JDBC result sets.</p>
                              </li>
                              <li>
                                 <p>Generally speaking, the contents of an iterator is determined only by the state of the database at the time of execution of the <code class="codeph">SELECT</code> statement that populated it. Subsequent <code class="codeph">UPDATE</code>, <code class="codeph">INSERT</code>, <code class="codeph">DELETE</code>, <code class="codeph">COMMIT</code>, or <code class="codeph">ROLLBACK</code> operations have no effect on the iterator or its contents. The exception to this is if you declare an iterator to be scrollable and sensitive to changes in the data.
                                 </p>
                              </li>
                           </ul>
                        </div>
                        <!-- class="section" -->
                     </div>
                  </div><a id="JSQLJ321"></a><div class="props_rev_3"><a id="GUID-33DDF8DC-056E-49DB-A17D-CD55AA92F963" name="GUID-33DDF8DC-056E-49DB-A17D-CD55AA92F963"></a><h5 id="JSQLJ-GUID-33DDF8DC-056E-49DB-A17D-CD55AA92F963" class="sect5">Overview of Weakly Typed Iterators</h5>
                     <div>
                        <p>In case you do not want to declare an iterator class, the Oracle SQLJ implementation enables you to use a weakly typed iterator. Such iterators are known as result set iterators. To use a plain, that is, nonscrollable result set iterator, instantiate the <code class="codeph">sqlj.runtime.ResultSetIterator</code> class. To use a scrollable result set iterator, instantiate the <code class="codeph">sqlj.runtime.ScrollableResultSetIterator</code> class.
                        </p>
                        <p>The drawback to using result set iterators, compared to strongly typed iterators, is that SQLJ cannot perform as much semantics-checking for your queries.</p>
                     </div>
                  </div>
               </div><a id="JSQLJ322"></a><div class="props_rev_3"><a id="GUID-92CEA05F-80CF-40E1-B5D9-632CB2B10246" name="GUID-92CEA05F-80CF-40E1-B5D9-632CB2B10246"></a><h4 id="JSQLJ-GUID-92CEA05F-80CF-40E1-B5D9-632CB2B10246" class="sect4">General Steps in Using an Iterator</h4>
                  <div>
                     <p>You must follow the following general steps to use SQLJ named or positional iterator:</p>
                     <ol>
                        <li>
                           <p>Use a SQLJ declaration to define the iterator class (in other words, to define the iterator type).</p>
                        </li>
                        <li>
                           <p>Declare a variable of the iterator class.</p>
                        </li>
                        <li>
                           <p>Populate the iterator variable with the results from a SQL query, using a <code class="codeph">SELECT</code> statement.
                           </p>
                        </li>
                        <li>
                           <p>Access the query columns in the iterator. How to accomplish this differs between named iterators and positional iterators.</p>
                        </li>
                        <li>
                           <p>When you finish processing the results of the query, close the iterator to release its resources.</p>
                        </li>
                     </ol>
                  </div>
               </div><a id="JSQLJ324"></a><a id="JSQLJ323"></a><div class="props_rev_3"><a id="GUID-4BEB2D79-A90D-4F5F-BAF9-754E717B4EAF" name="GUID-4BEB2D79-A90D-4F5F-BAF9-754E717B4EAF"></a><h4 id="JSQLJ-GUID-4BEB2D79-A90D-4F5F-BAF9-754E717B4EAF" class="sect4">Named, Positional, and Result Set Iterators</h4>
                  <div>
                     <p>There are advantages and appropriate situations for each kind of SQLJ iterator.</p>
                     <p>Named iterators enable greater flexibility. Because data selection into a named iterator matches the columns in the <code class="codeph">SELECT</code> statement to iterator columns by name, you need not be concerned about the order in your query. This is less prone to error, as it is not possible for data to be placed into the wrong column. If the names do not match, then the SQLJ translator will generate an error when it checks the SQL statements against the database.
                     </p>
                     <p>Positional iterators offer a familiar paradigm and syntax to developers who have experience with other embedded-SQL languages. With named iterators you use a <code class="codeph">next()</code> method to retrieve data, while with positional iterators you use <code class="codeph">FETCH INTO</code> syntax similar to that of Pro*C, for example. Each fetch implicitly advances to the next available row of the iterator before retrieving the next set of values.
                     </p>
                     <p>However, positional iterators do offer less flexibility than named iterators, because you are selecting data into iterator columns by position, instead of by name. You must be certain of the order of items in your <code class="codeph">SELECT</code> statement. Also, you must select data into all columns of the iterator. It is possible to have data written into the wrong iterator column, if the data type of that column happens to match the data type of the table column being selected.
                     </p>
                     <p>Access to individual data elements is also less convenient with positional iterators. Named iterators, because they store data by name, are able to have convenient accessor methods for each column. For example, there would be an <code class="codeph">ename()</code> method to retrieve data from an <code class="codeph">ename</code> iterator column. With positional iterators, you must fetch data directly into Java host expressions with the <code class="codeph">FETCH INTO</code> statement, and the host expressions must be in the correct order.
                     </p>
                     <p>If you do not want to declare strongly typed iterator classes for your queries, then you can choose the alternative of using weakly typed result set iterators. Result set iterators are most convenient when converting JDBC code to SQLJ code. You must balance this consideration against the fact that result set iterators, either <code class="codeph">ResultSetIterator</code> instances or <code class="codeph">ScrollableResultSetIterator</code> instances, do not allow complete SQLJ semantics-checking during translation. With named or positional iterators, SQLJ verifies that the data types of columns in the <code class="codeph">SELECT</code> statement match the Java types into which the data will be materialized. With result set iterators, this is not possible.
                     </p>
                     <div class="section">
                        <p class="subhead3" id="GUID-4BEB2D79-A90D-4F5F-BAF9-754E717B4EAF__GUID-F5A47A46-7048-44EE-971B-F30A0AB03F8E">Comparative Iterator Notes</p>
                     </div>
                     <!-- class="section" -->
                     <div class="section">
                        <p>Be aware of the following notes regarding SQLJ iterators:</p>
                        <ul style="list-style-type: disc;">
                           <li>
                              <p>In populating a positional iterator, the number of columns you select from the database must equal the number of columns in the iterator. In populating a named iterator, the number of columns you select from the database can never be less than the number of columns in the iterator, but can be greater than the number of columns in the iterator if you have the translator <code class="codeph">-warn=nostrict</code> flag set. Unmatched columns are ignored in this case.
                              </p>
                           </li>
                           <li>
                              <p>Although the term "fetching" often refers to fetching data from a database, remember that a <code class="codeph">FETCH INTO</code> statement for a positional iterator does not necessarily involve a round trip to the server. This depends on the row-prefetch value. This is because you are fetching data from the iterator, and not the database. However, if the row-prefetch value is <code class="codeph">1</code>, then each fetch does involve a separate trip to the database. The row-prefetch value determines how many rows are retrieved with each trip to the database.
                              </p>
                           </li>
                           <li>
                              <p>Result set iterators use the same <code class="codeph">FETCH INTO</code> syntax that is used with positional iterators and are subject to the same restriction at run time. That is, the number of data items in the <code class="codeph">SELECT</code>-list must match the number of variables that are assigned data in the <code class="codeph">FETCH</code> statement.
                              </p>
                           </li>
                        </ul>
                     </div>
                     <!-- class="section" -->
                  </div>
               </div><a id="JSQLJ326"></a><a id="JSQLJ327"></a><a id="JSQLJ328"></a><a id="JSQLJ325"></a><div class="props_rev_3"><a id="GUID-FF318201-3A54-450E-AC86-616665E03DE2" name="GUID-FF318201-3A54-450E-AC86-616665E03DE2"></a><h4 id="JSQLJ-GUID-FF318201-3A54-450E-AC86-616665E03DE2" class="sect4">Using Named Iterators</h4>
                  <div>
                     <div class="section">
                        <p>When you declare a named iterator class, you declare the name as well as the data type of each column of the iterator. When you select data into a named iterator, the columns in the <code class="codeph">SELECT</code> statement must match the iterator columns in two ways:
                        </p>
                     </div>
                     <!-- class="section" -->
                     <div class="section">
                        <ul style="list-style-type: disc;">
                           <li>
                              <p>The name of each data item in the <code class="codeph">SELECT</code> statement, either a table column name or an alias, must match an iterator column name. However, this is not case-sensitive. That is, <code class="codeph">ename</code> or <code class="codeph">Ename</code> would match <code class="codeph">ENAME</code>).
                              </p>
                           </li>
                           <li>
                              <p>The data type of each iterator column must be compatible with the data type of the corresponding data item in the <code class="codeph">SELECT</code> statement according to standard JDBC type mappings.
                              </p>
                           </li>
                        </ul>
                        <p>The order in which attributes are declared in the named iterator class declaration is irrelevant. Data is selected into the iterator based on name alone.</p>
                        <p>A named iterator has a <code class="codeph">next()</code> method to retrieve data row by row and an accessor method for each column to retrieve the individual data items. The accessor method names are identical to the column names. Unlike most accessor method names in Java, accessor method names in named iterator classes do not start with <code class="codeph">get</code>. For example, a named iterator object with a column <code class="codeph">sal</code> would have a <code class="codeph">sal()</code> accessor method.
                        </p>
                        <div class="infoboxnote" id="GUID-FF318201-3A54-450E-AC86-616665E03DE2__GUID-331BB72D-BDE5-44AB-BDA9-C051AABE3B0A">
                           <p class="notep1">Note:</p>
                           <p>The following restrictions apply in naming the columns of a named iterator:</p>
                           <ul style="list-style-type: disc;">
                              <li>
                                 <p>Column names cannot use Java reserved words.</p>
                              </li>
                              <li>
                                 <p>Column names cannot have the same name as utility methods provided in named iterator classes, such as the <code class="codeph">next()</code>, <code class="codeph">close()</code>, <code class="codeph">getResultSet()</code>, and <code class="codeph">isClosed()</code> methods. For scrollable named iterators, this includes additional methods such as <code class="codeph">previous()</code>, <code class="codeph">first()</code>, and <code class="codeph">last()</code>.
                                 </p>
                              </li>
                           </ul>
                        </div>
                     </div>
                     <!-- class="section" -->
                     <div class="section">
                        <p class="subhead3" id="GUID-FF318201-3A54-450E-AC86-616665E03DE2__GUID-DB9656A7-3792-489B-95F5-FC3CA9763E00">Declaring Named Iterator Classes</p>
                     </div>
                     <!-- class="section" -->
                     <div class="section">
                        <p>Use the following syntax to declare a named iterator class:</p><pre class="oac_no_warn" dir="ltr">#sql &lt;<span class="italic">modifiers</span>&gt; iterator <span class="italic">classname</span> &lt;<span class="italic">implements clause</span>&gt; &lt;<span class="italic">with clause</span>&gt; 
     ( <span class="italic">type-name-list</span> );
</pre><p>In this syntax, <span class="italic"><code class="codeph">modifiers</code></span> is an optional sequence of legal Java class modifiers, <span class="italic"><code class="codeph">classname</code></span> is the desired class name for the iterator, and <span class="italic"><code class="codeph">type-name-list</code></span> is a list of the Java types and names equivalent to or compatible with the column types and column names in a database table.
                        </p>
                        <p>The <code class="codeph">implements</code> clause and <code class="codeph">with</code> clause are optional, specifying interfaces to implement and variables to define and initialize, respectively.
                        </p>
                        <div class="infoboxnotealso" id="GUID-FF318201-3A54-450E-AC86-616665E03DE2__GUID-84E8EC66-7C4F-4561-96D0-E4FB54D294ED">
                           <p class="notep1">See Also:</p>
                           <p><span class="q">"<a href="basic-language-features.html#GUID-1843167B-56CD-49CB-811B-4ACC5DF38035">Declaration IMPLEMENTS Clause</a>"</span> and <span class="q">"<a href="basic-language-features.html#GUID-5E97C2F0-7249-48FD-A75B-AB5A465147C7">Declaration WITH Clause</a>"</span></p>
                        </div>
                        <p>Consider the following table:</p><pre class="oac_no_warn" dir="ltr">CREATE TABLE PROJECTS (
   ID NUMBER(4),
   PROJNAME VARCHAR(30),
   START_DATE DATE,
   DURATION NUMBER(3) );
</pre><p>You can declare the following named iterator to use with this table:</p><pre class="oac_no_warn" dir="ltr">#sql public iterator ProjIter (String projname, int id, Date deadline);
</pre><p>This will result in an iterator class with columns of data accessible, using the following provided accessor methods: <code class="codeph">projname()</code>, <code class="codeph">id()</code>, and <code class="codeph">deadline()</code>.
                        </p>
                        <div class="infoboxnote" id="GUID-FF318201-3A54-450E-AC86-616665E03DE2__GUID-705999B1-3028-45E5-A9BA-C66C855CF338">
                           <p class="notep1">Note:</p>
                           <p>As with standard Java, any public class should be declared in one of the following ways:</p>
                           <ul style="list-style-type: disc;">
                              <li>
                                 <p>Declare it in a separate source file. The base name of the file should be the same as the class name. </p>
                              </li>
                              <li>
                                 <p>Declare it at class-level scope or nested-class-level scope, with <code class="codeph">public static</code> modifiers.
                                 </p>
                              </li>
                           </ul>
                           <p>This is a requirement if you are using the standard <code class="codeph">javac</code> compiler provided with the Sun Microsystems JDK.
                           </p>
                        </div>
                     </div>
                     <!-- class="section" -->
                     <div class="section">
                        <p class="subhead3" id="GUID-FF318201-3A54-450E-AC86-616665E03DE2__GUID-6830C0B5-A137-4486-AE04-C66145C24AC3">Instantiating and Populating Named Iterators</p>
                     </div>
                     <!-- class="section" -->
                     <div class="section">
                        <p>Continuing to use the <code class="codeph">PROJECTS</code> table and <code class="codeph">ProjIter</code> iterator defined in the preceding section, note that there are columns in the table whose names and data types match the <code class="codeph">id</code> and <code class="codeph">projname</code> columns of the iterator. However, you must use an alias and perform an operation to populate the <code class="codeph">deadline</code> column of the iterator. Following is an example:
                        </p><pre class="oac_no_warn" dir="ltr">ProjIter projsIter;

#sql projsIter = { SELECT start_date + duration AS deadline, projname, id 
                   FROM projects WHERE start_date + duration &gt;= sysdate };
</pre><p>This calculates a deadline for each project by adding its duration to its start date, then aliases the results as <code class="codeph">deadline</code> to match the <code class="codeph">deadline</code> iterator column. It also uses a <code class="codeph">WHERE</code> clause so that only future deadlines are processed, that is, deadlines beyond the current system date in the database.
                        </p>
                        <p>Similarly, you must create an alias if you want to use a function call. Suppose you have a <code class="codeph">MAXIMUM()</code> function that takes a <code class="codeph">DURATION</code> entry and an integer as input and returns the maximum of the two. For example, you could input the value <code class="codeph">3</code> to ensure that each project has at least a three-month duration in your application.
                        </p>
                        <p>Now, presume you are declaring your iterator as follows:</p><pre class="oac_no_warn" dir="ltr">#sql public iterator ProjIter2 (String projname, int id, float duration);
</pre><p>You could use the <code class="codeph">MAXIMUM()</code> function in your query, with an alias for the result, as follows:
                        </p><pre class="oac_no_warn" dir="ltr">ProjIter2 projsIter2;

#sql projsIter2 = { SELECT id, projname, maximum(duration, 3) AS duration 
                    FROM projects };
</pre><p>Generally, you must use an alias in your query for any data item in the <code class="codeph">SELECT</code> statement whose name is not a legal Java identifier or does not match a column name in the iterator.
                        </p>
                        <p>Remember that in populating a named iterator, the number of columns you select from the database can never be less than the number of columns in the iterator. The number of columns you select can be greater than the number of columns in the iterator, because unmatched columns are ignored. However, this will generate a warning, unless you have the SQLJ <code class="codeph">-warn=nostrict</code> option set. 
                        </p>
                     </div>
                     <!-- class="section" -->
                     <div class="section">
                        <p class="subhead3" id="GUID-FF318201-3A54-450E-AC86-616665E03DE2__GUID-1A2EDF2F-CE4C-4746-9017-CD587354ADD6">Accessing Named Iterators</p>
                     </div>
                     <!-- class="section" -->
                     <div class="section">
                        <p>Use the <code class="codeph">next()</code> method of the named iterator object to step through the data that was selected into it. To access each column of each row, use the accessor methods generated by SQLJ, typically inside a <code class="codeph">while</code> loop. 
                        </p>
                        <p>Whenever <code class="codeph">next()</code> is called:
                        </p>
                        <ul style="list-style-type: disc;">
                           <li>
                              <p>If there is another row to retrieve from the iterator, then <code class="codeph">next()</code> retrieves the row and returns <code class="codeph">true</code>.
                              </p>
                           </li>
                           <li>
                              <p>If there are no more rows to retrieve, <code class="codeph">next()</code> returns <code class="codeph">false</code>.
                              </p>
                           </li>
                        </ul>
                        <p>The following is an example of how to access the data of a named iterator, repeating the declaration, instantiation, and population code illustrated in the preceding section.</p>
                        <div class="infoboxnote" id="GUID-FF318201-3A54-450E-AC86-616665E03DE2__GUID-C767C43E-D4A1-4E8C-BC91-1FCB9579D411">
                           <p class="notep1">Note:</p>
                           <p>Each iterator has a <code class="codeph">close()</code> method that you must always call when you finish retrieving data from the iterator. This is necessary to close the iterator and free its resources.
                           </p>
                        </div>
                        <p>Presume the following iterator class declaration:</p><pre class="oac_no_warn" dir="ltr">#sql public iterator ProjIter (String projname, int id, Date deadline);
</pre><p>Populate and then access an instance of this iterator class as follows:</p><pre class="oac_no_warn" dir="ltr">// Declare the iterator variable
ProjIter projsIter;

// Instantiate and populate iterator; order of SELECT doesn't matter
#sql projsIter = { SELECT start_date + duration AS deadline, projname, id 
                   FROM projects WHERE start_date + duration &gt;= sysdate };

// Process the results
while (projsIter.next()) {
   System.out.println("Project name is " + projsIter.projname());
   System.out.println("Project ID is " + projsIter.id());
   System.out.println("Project deadline is " + projsIter.deadline());
}  

// Close the iterator
projsIter.close();
...
</pre><p>Note the convenient use of the <code class="codeph">projname()</code>, <code class="codeph">id()</code>, and <code class="codeph">deadline()</code> accessor methods to retrieve the data. Note also that the order of the <code class="codeph">SELECT</code> items does not matter, nor does the order in which the accessor methods are used.
                        </p>
                        <p>However, remember that accessor method names are created with the case exactly as in your declaration of the iterator class. The following will generate compilation errors.</p>
                        <p>Consider the following declaration of the iterator:</p><pre class="oac_no_warn" dir="ltr">#sql iterator Cursor1 (String NAME);
</pre><p>The code for using the iterator is as follows:</p><pre class="oac_no_warn" dir="ltr">...
Cursor1 c1;
#sql c1 = { SELECT NAME FROM TABLE };
while (c1.next()) {
   System.out.println("The name is " + c1.name());
}
...
</pre><p>The <code class="codeph">Cursor1</code> class has a method called <code class="codeph">NAME()</code>, and not <code class="codeph">name()</code>. You will have to use <code class="codeph">c1.NAME()</code> in the <code class="codeph">System.out.println</code> statement.
                        </p>
                     </div>
                     <!-- class="section" -->
                  </div>
               </div><a id="JSQLJ330"></a><a id="JSQLJ331"></a><a id="JSQLJ332"></a><a id="JSQLJ333"></a><a id="JSQLJ329"></a><div class="props_rev_3"><a id="GUID-C99760AC-46A2-446C-8CA6-D032FC4C303D" name="GUID-C99760AC-46A2-446C-8CA6-D032FC4C303D"></a><h4 id="JSQLJ-GUID-C99760AC-46A2-446C-8CA6-D032FC4C303D" class="sect4">Using Positional Iterators</h4>
                  <div>
                     <div class="section">
                        <p>When you declare a positional iterator class, you declare the data type of each column but not the column name. The Java types into which the columns of the SQL query results are selected must be compatible with the data types of the SQL data. The names of the database columns or data items in the <code class="codeph">SELECT</code> statement are irrelevant. Because names are not used, the order in which you declare your positional iterator Java types must exactly match the order in which the data is selected.
                        </p>
                        <p>To retrieve data from a positional iterator once data has been selected into it, use a <code class="codeph">FETCH INTO</code> statement followed by an <code class="codeph">endFetch()</code> method call to determine if you have reached the end of the data.
                        </p>
                     </div>
                     <!-- class="section" -->
                     <div class="section">
                        <p class="subhead3" id="GUID-C99760AC-46A2-446C-8CA6-D032FC4C303D__GUID-771CB95C-D599-40CA-B350-9DC83E0DE08F">Declaring Positional Iterator Classes</p>
                     </div>
                     <!-- class="section" -->
                     <div class="section">
                        <p>Use the following syntax to declare a positional iterator class:</p><pre class="oac_no_warn" dir="ltr">#sql &lt;<span class="italic">modifiers</span>&gt; iterator <span class="italic">classname</span> &lt;<span class="italic">implements clause</span>&gt; &lt;<span class="italic">with clause</span>&gt; 
     ( <span class="italic">position-list</span> );
</pre><p>In this syntax, <span class="italic"><code class="codeph">modifiers</code></span> is an optional sequence of legal Java class modifiers and the<code class="codeph"> </code><span class="italic"><code class="codeph">position-list</code></span> is a list of Java types compatible with the column types in a database table.
                        </p>
                        <p>The <code class="codeph">implements</code> clause and <code class="codeph">with</code> clause are optional, specifying interfaces to implement and variables to define and initialize, respectively.
                        </p>
                        <div class="infoboxnotealso" id="GUID-C99760AC-46A2-446C-8CA6-D032FC4C303D__GUID-A3A74746-D86E-4C8D-9030-2BEDA19D0580">
                           <p class="notep1">See Also:</p>
                           <p><span class="q">"<a href="basic-language-features.html#GUID-1843167B-56CD-49CB-811B-4ACC5DF38035">Declaration IMPLEMENTS Clause</a>"</span> and <span class="q">"<a href="basic-language-features.html#GUID-5E97C2F0-7249-48FD-A75B-AB5A465147C7">Declaration WITH Clause</a>"</span></p>
                        </div>
                        <p>Now consider an employee table <code class="codeph">EMP</code> with the following rows:
                        </p><pre class="oac_no_warn" dir="ltr">CREATE TABLE EMP (
   EMPNO NUMBER(4),
   ENAME VARCHAR2(10), 
   SAL NUMBER(7,2) );
</pre><p>And consider the following positional iterator declaration:</p><pre class="oac_no_warn" dir="ltr">#sql public iterator EmpIter (String, int, float);
</pre><p>This example defines the <code class="codeph">EmpIter</code> Java class with unnamed <code class="codeph">String</code>, <code class="codeph">int</code>, and <code class="codeph">float</code> columns. Note that the table columns and iterator columns are in a different order, with the <code class="codeph">String</code> corresponding to <code class="codeph">ENAME</code> and the <code class="codeph">int</code> corresponding to <code class="codeph">EMPNO</code>. The order of the iterator columns determines the order in which you must select the data.
                        </p>
                        <div class="infoboxnote" id="GUID-C99760AC-46A2-446C-8CA6-D032FC4C303D__GUID-2CBB7430-DE41-437C-8778-A341136A1517">
                           <p class="notep1">Note:</p>
                           <p>As with standard Java, any public class should be declared in one of the following ways:</p>
                           <ul style="list-style-type: disc;">
                              <li>
                                 <p>Declare it in a separate source file. The base name of the file should be the same as the class name. </p>
                              </li>
                              <li>
                                 <p>Declare it at class-level scope or nested-class-level scope, with <code class="codeph">public static</code> modifiers.
                                 </p>
                              </li>
                           </ul>
                           <p>This is a requirement if you are using the standard <code class="codeph">javac</code> compiler provided with the Sun Microsystems JDK.
                           </p>
                        </div>
                     </div>
                     <!-- class="section" -->
                     <div class="section">
                        <p class="subhead3" id="GUID-C99760AC-46A2-446C-8CA6-D032FC4C303D__GUID-33304924-36DD-48B5-A121-F175D5F0A1AD">Instantiating and Populating Positional Iterators</p>
                     </div>
                     <!-- class="section" -->
                     <div class="section">
                        <p>Instantiating and populating a positional iterator is no different than doing so for a named iterator, except that you must be certain that the data items in the <code class="codeph">SELECT</code> statement are in the proper order.
                        </p>
                        <p>The three data types in the <code class="codeph">EmpIter</code> iterator class are compatible with the types of the <code class="codeph">EMP</code> table, but be careful how you select the data, because the order is different. The following will work, because the data items in the <code class="codeph">SELECT</code> statement are in the same order as the iterator columns:
                        </p><pre class="oac_no_warn" dir="ltr">EmpIter empsIter;

#sql empsIter = { SELECT ename, empno, sal FROM emp };
</pre><p>Remember that in populating a positional iterator, the number of columns you select from the database must equal the number of columns in the iterator.</p>
                     </div>
                     <!-- class="section" -->
                     <div class="section">
                        <p class="subhead3" id="GUID-C99760AC-46A2-446C-8CA6-D032FC4C303D__GUID-2DA51CA7-2959-420B-B9E2-31F868A2A4BD">Accessing Positional Iterators</p>
                     </div>
                     <!-- class="section" -->
                     <div class="section">
                        <p>Access the columns defined by a positional iterator using SQL <code class="codeph">FETCH INTO</code> syntax. The <code class="codeph">INTO</code> part of the command specifies Java host variables that receive the results columns. The host variables must be in the same order as the corresponding iterator columns. Use the <code class="codeph">endFetch()</code> method provided with all positional iterator classes to determine whether the last fetch reached the end of the data.
                        </p>
                        <div class="infoboxnote" id="GUID-C99760AC-46A2-446C-8CA6-D032FC4C303D__GUID-0A030C03-CFF8-4158-9334-E0C310B1FD1E">
                           <p class="notep1">Note:</p>
                           <ul style="list-style-type: disc;">
                              <li>
                                 <p>The <code class="codeph">endFetch()</code> method initially returns <code class="codeph">true</code> before any rows have been fetched, then returns <code class="codeph">false</code> once a row has been successfully retrieved, and then returns <code class="codeph">true</code> again when a <code class="codeph">FETCH</code> finds no more rows to retrieve. Therefore, you must perform the <code class="codeph">endFetch()</code> test <span class="italic">after</span> the <code class="codeph">FETCH INTO</code> statement. If your <code class="codeph">endFetch()</code> test precedes the <code class="codeph">FETCH INTO</code> statement, then you will never retrieve any rows, because <code class="codeph">endFetch()</code> would be true before your first <code class="codeph">FETCH</code> and you would immediately break out of the <code class="codeph">while</code> loop.
                                 </p>
                              </li>
                              <li>
                                 <p>The <code class="codeph">endFetch()</code> test must be <span class="italic">before</span> the results are processed, however, because the <code class="codeph">FETCH</code> does not throw a SQL exception when it reaches the end of the data, it just triggers the next <code class="codeph">endFetch()</code> call to return <code class="codeph">true</code>. If there is no <code class="codeph">endFetch()</code> test before results are processed, then your code will try to process <code class="codeph">NULL</code> or invalid data from the first <code class="codeph">FETCH</code> attempt after the end of the data had been reached. 
                                 </p>
                              </li>
                              <li>
                                 <p>Each iterator has a <code class="codeph">close()</code> method that you must always call once you finish retrieving data from it. This is necessary to close the iterator and free its resources.
                                 </p>
                              </li>
                           </ul>
                        </div>
                        <p>The following is an example, repeating the declaration, instantiation, and population code illustrated in the preceding section. Note that the Java host variables in the <code class="codeph">SELECT</code> statement are in the same order as the columns of the positional iterator, which is mandatory.
                        </p>
                        <p>First, presume the following iterator class declaration:</p><pre class="oac_no_warn" dir="ltr">#sql public iterator EmpIter (String, int, float);
</pre><p>Populate and then access an instance of this iterator class as follows:</p><pre class="oac_no_warn" dir="ltr">// Declare and initialize host variables
int empnum=0;
String empname=null;
float salary=0.0f;

// Declare an iterator instance
EmpIter empsIter;

#sql empsIter = { SELECT first_name, employee_id, salary FROM employees };

while (true) {
   #sql { FETCH :empsIter INTO :empnum, :empname, :salary };
   if (empsIter.endFetch()) break;  // This test must be AFTER fetch,
                                    // but before results are processed.
   System.out.println("Name is " + empname);
   System.out.println("Employee number is " + empnum);
   System.out.println("Salary is " + salary);
}

// Close the iterator
empsIter.close();
...
</pre><p>The <code class="codeph">empname</code>, <code class="codeph">empnum</code>, and <code class="codeph">salary</code> variables are Java host variables whose types must match the types of the iterator columns.
                        </p>
                        <p>Do not use the <code class="codeph">next()</code> method for a positional iterator. A <code class="codeph">FETCH</code> operation calls it implicitly to move to the next row.
                        </p>
                        <div class="infoboxnote" id="GUID-C99760AC-46A2-446C-8CA6-D032FC4C303D__GUID-272B10F7-1CDD-4E88-B33B-9C5EAD83DF26">
                           <p class="notep1">Note:</p>
                           <p>Host variables in a <code class="codeph">FETCH INTO</code> statement must always be initialized because they are assigned in one branch of a conditional statement. Otherwise, you will get a compiler error indicating they may never be assigned. <code class="codeph">FETCH</code> can assign the variables only if there was a row to be fetched.
                           </p>
                        </div>
                     </div>
                     <!-- class="section" -->
                     <div class="section">
                        <p class="subhead3" id="GUID-C99760AC-46A2-446C-8CA6-D032FC4C303D__GUID-8221C595-3FAF-48CC-B059-CA01C7421848">Positional Iterator Navigation with the next() Method</p>
                     </div>
                     <!-- class="section" -->
                     <div class="section">
                        <p>The positional iterator <code class="codeph">FETCH</code> clause discussed in the preceding section performs a movement, an implicit <code class="codeph">next()</code> call, before it populates the host variables, if any. As an alternative, the Oracle SQLJ implementation supports a special <code class="codeph">FETCH</code> syntax in conjunction with explicit <code class="codeph">next()</code> calls in order to use the same movement logic as with JDBC result sets and SQLJ named iterators. Using this special <code class="codeph">FETCH</code> syntax, the semantics differ. There is no implicit <code class="codeph">next()</code> call before the <code class="codeph">INTO</code>-list is populated.
                        </p>
                     </div>
                     <!-- class="section" -->
                  </div>
               </div><a id="JSQLJ335"></a><a id="JSQLJ336"></a><a id="JSQLJ337"></a><a id="JSQLJ334"></a><div class="props_rev_3"><a id="GUID-D3CC3825-1F5D-45AF-9E96-5848B98B7D21" name="GUID-D3CC3825-1F5D-45AF-9E96-5848B98B7D21"></a><h4 id="JSQLJ-GUID-D3CC3825-1F5D-45AF-9E96-5848B98B7D21" class="sect4">Using Iterators and Result Sets as Host Variables</h4>
                  <div>
                     <div class="section">
                        <p>SQLJ supports SQLJ iterators and JDBC result sets as host variables. Using iterators and result sets is fundamentally the same, with differences in declarations and in accessor methods to retrieve the data.</p>
                        <div class="infoboxnote" id="GUID-D3CC3825-1F5D-45AF-9E96-5848B98B7D21__GUID-1B398F78-8B77-4B88-BC97-E120383A09F4">
                           <p class="notep1">Note:</p>
                           <ul style="list-style-type: disc;">
                              <li>
                                 <p>Additionally, SQLJ supports iterators and result sets as return variables for stored functions.</p>
                              </li>
                              <li>
                                 <p>Oracle JDBC drivers currently do <span class="italic">not</span> support result sets as input host variables. There is a <code class="codeph">setCursor()</code> method in the <code class="codeph">OraclePreparedStatement</code> class, but it raises an exception at run time, if called.
                                 </p>
                              </li>
                           </ul>
                        </div>
                        <p>For the examples in this section, consider the following department and employee tables:</p><pre class="oac_no_warn" dir="ltr">CREATE TABLE DEPT (
   DEPTNO NUMBER(2),
   DNAME VARCHAR2(14) );

CREATE TABLE EMP (
   EMPNO NUMBER(4),
   ENAME VARCHAR2(10), 
   SAL NUMBER(7,2), 
   DEPTNO NUMBER(2) );
</pre></div>
                     <!-- class="section" -->
                     <div class="section">
                        <p class="subhead3" id="GUID-D3CC3825-1F5D-45AF-9E96-5848B98B7D21__GUID-21637270-642D-4204-87A3-BFCEEA13D6ED">Example: Use of Result Set as OUT Host Variable </p>
                     </div>
                     <!-- class="section" -->
                     <div class="section">
                        <p>This example uses a JDBC result set as an output host variable.</p><pre class="oac_no_warn" dir="ltr">...
ResultSet rs;
...
#sql { BEGIN
          OPEN :OUT rs FOR SELECT ename, empno FROM emp;
       END };

while (rs.next())
{
   String empname = rs.getString(1);
   int empnum = rs.getInt(2);
}
rs.close();
...
</pre><p>This example opens the result set <code class="codeph">rs</code> in a PL/SQL block to receive data from a <code class="codeph">SELECT</code> statement, selects data from the <code class="codeph">ENAME</code> and <code class="codeph">EMPNO</code> columns of the <code class="codeph">EMP</code> table, and then loops through the result set to retrieve data into local variables.
                        </p>
                     </div>
                     <!-- class="section" -->
                     <div class="section">
                        <p class="subhead3" id="GUID-D3CC3825-1F5D-45AF-9E96-5848B98B7D21__GUID-3C515AC9-C1DE-428B-B5B1-0B450600524A">Example: Use of Iterator as OUT Host Variable</p>
                     </div>
                     <!-- class="section" -->
                     <div class="section">
                        <p>This example uses a named iterator as an output host variable.</p>
                        <p>The iterator can be declared as follows:</p><pre class="oac_no_warn" dir="ltr">#sql public &lt;static&gt; iterator EmpIter (String ename, int empno);
</pre><p>The <code class="codeph">public</code> modifier is required, and the <code class="codeph">static</code> modifier may be advisable if your declaration is at class level or nested-class level.
                        </p>
                        <p>This iterator can be used as follows:</p><pre class="oac_no_warn" dir="ltr">...
EmpIter iter;
...
#sql { BEGIN
          OPEN :OUT iter FOR SELECT ename, empno FROM emp;
       END };

while (iter.next())
{
   String empname = iter.ename();
   int empnum = iter.empno();
   
   ...<span class="italic">process/output empname and empnum</span>...
}
iter.close();
...
</pre><p>This example opens the iterator <code class="codeph">iter</code> in a PL/SQL block to receive data from a <code class="codeph">SELECT</code> statement, selects data from the <code class="codeph">ENAME</code> and <code class="codeph">EMPNO</code> columns of the <code class="codeph">EMP</code> table, and then loops through the iterator to retrieve data into local variables.
                        </p>
                     </div>
                     <!-- class="section" -->
                     <div class="section">
                        <p class="subhead3" id="GUID-D3CC3825-1F5D-45AF-9E96-5848B98B7D21__GUID-A79C1BA2-6116-4785-A780-A19C1A87DC58">Example: Use of Iterator as OUT Host Variable for SELECT INTO</p>
                     </div>
                     <!-- class="section" -->
                     <div class="section">
                        <p>This example uses a named iterator as an output host variable, taking data through a <code class="codeph">SELECT INTO</code> statement. <code class="codeph">OUT</code> is the default for host variables in an <code class="codeph">INTO</code>-list.
                        </p>
                        <p>The iterator can be declared as follows:</p><pre class="oac_no_warn" dir="ltr">#sql public &lt;static&gt; iterator ENameIter (String ename);
</pre><p>The <code class="codeph">public</code> modifier is required, and the <code class="codeph">static</code> modifier may be advisable if your declaration is at class level or nested-class level.
                        </p>
                        <p>This iterator can be used as follows:</p><pre class="oac_no_warn" dir="ltr">...
ENameIter enamesIter;
String deptname;
...

#sql { SELECT dname, cursor 
      (SELECT ename FROM emp WHERE deptno = dept.deptno)
       INTO :deptname, :enamesIter FROM dept WHERE deptno = 20 };

System.out.println(deptname);
while (enamesIter.next())
{
   System.out.println(enamesIter.ename());
}
enamesIter.close();
... 
</pre><p>This example uses nested <code class="codeph">SELECT</code> statements to accomplish the following:
                        </p>
                        <ul style="list-style-type: disc;">
                           <li>
                              <p>Select the name of department number 20 from the <code class="codeph">DEPT</code> table, selecting it into the <code class="codeph">deptname</code> output host variable.
                              </p>
                           </li>
                           <li>
                              <p>Query the <code class="codeph">EMP</code> table to select all employees whose department number is 20, selecting the resulting cursor into the <code class="codeph">enamesIter</code> output host variable, which is a named iterator.
                              </p>
                           </li>
                           <li>
                              <p>Print the department name.</p>
                           </li>
                           <li>
                              <p>Loop through the named iterator printing employee names. This prints the names of all employees in the department.</p>
                           </li>
                        </ul>
                        <p>In most cases, using <code class="codeph">SELECT INTO</code> is more convenient than using nested iterators if you are retrieving a single row in the outer <code class="codeph">SELECT</code>, although that option is also available. Also, with nested iterators, you would have to process the data to determine how many rows there are in the outer <code class="codeph">SELECT</code>. With <code class="codeph">SELECT INTO</code> you are assured of just one row.
                        </p>
                     </div>
                     <!-- class="section" -->
                  </div>
               </div><a id="JSQLJ339"></a><a id="JSQLJ340"></a><a id="JSQLJ341"></a><a id="JSQLJ338"></a><div class="props_rev_3"><a id="GUID-A8BA5DEF-6CA2-4C06-8073-0F475851B7CA" name="GUID-A8BA5DEF-6CA2-4C06-8073-0F475851B7CA"></a><h4 id="JSQLJ-GUID-A8BA5DEF-6CA2-4C06-8073-0F475851B7CA" class="sect4">Using Iterators and Result Sets as Iterator Columns</h4>
                  <div>
                     <div class="section">
                        <p>The Oracle SQLJ implementation includes extensions that allow iterator declarations to specify columns of <code class="codeph">ResultSet</code> type or columns of other iterator types declared within the current scope. In other words, iterators and result sets can exist within iterators. These column types are used to retrieve a column in the form of a cursor. This is useful for nested <code class="codeph">SELECT</code> statements that return nested table information.
                        </p>
                        <p>The following examples are functionally identical. Each uses a nested result set or iterator, that is, result sets or iterators in a column within an iterator, to print all the employees in each department in the <code class="codeph">DEPT</code> table. The first example uses result sets within a named iterator, the second example uses named iterators within a named iterator, and the third example uses named iterators within a positional iterator.
                        </p>
                        <p>Following are the steps:</p>
                     </div>
                     <!-- class="section" -->
                     <ol>
                        <li><span>Select each department name (<code class="codeph">DNAME</code>) from the <code class="codeph">DEPT</code> table.</span></li>
                        <li><span>Do a nested <code class="codeph">SELECT</code> into a cursor to get all employees from the <code class="codeph">EMP</code> table for each department.</span></li>
                        <li><span>Put the department names and sets of employees into the outer iterator (<code class="codeph">iter</code>), which has a name column and an iterator column. The cursor with the employee information for any given department goes into the iterator column of the row of the outer iterator corresponding to the department.</span></li>
                        <li><span>Go through a nested loop that, for each department, prints the department name and then loops through the inner iterator to print all employee names for that department.</span></li>
                     </ol>
                     <div class="example" id="GUID-A8BA5DEF-6CA2-4C06-8073-0F475851B7CA__GUID-3BFEAA22-5407-4AA4-A0FD-017AE2E98BB8">
                        <p class="titleinexample">Example 5-1 Example: Result Set Column in a Named Iterator</p>
                        <p>This example uses a column of type <code class="codeph">ResultSet</code> in a named iterator. 
                        </p>
                        <p>The iterator can be declared as follows:</p><pre class="oac_no_warn" dir="ltr">#sql iterator DeptIter (String dname, ResultSet emps);
</pre><p>The code that uses the iterator is as follows:</p><pre class="oac_no_warn" dir="ltr">...
DeptIter iter;
...
#sql iter = { SELECT dname, cursor 
             (SELECT ename FROM emp WHERE deptno = dept.deptno) 
              AS emps FROM dept };

while (iter.next())
{
   System.out.println(iter.dname());
   ResultSet enamesRs = iter.emps();
   while (enamesRs.next())
   {
      String empname = enamesRs.getString(1);
      System.out.println(empname);
   }
   enamesRs.close();
}
iter.close();
...</pre></div>
                     <!-- class="example" -->
                     <div class="example" id="GUID-A8BA5DEF-6CA2-4C06-8073-0F475851B7CA__GUID-D4A615E6-3725-4DBE-9740-4DF4734057CE">
                        <p class="titleinexample">Example 5-2 Example: Named Iterator Column in a Named Iterator</p>
                        <p>This example uses a named iterator that has a column whose type is that of a previously defined named iterator (nested iterators).</p>
                        <p>The iterator declaration is as follows:</p><pre class="oac_no_warn" dir="ltr">#sql iterator ENameIter (String ename);
#sql iterator DeptIter (String dname, ENameIter emps);
</pre><p>The code that uses this iterator is as follows:</p><pre class="oac_no_warn" dir="ltr">...
DeptIter iter;
...
#sql iter = { SELECT dname, cursor 
             (SELECT ename FROM emp WHERE deptno = dept.deptno) 
              AS emps FROM dept };

while (iter.next())
{
   System.out.println(iter.dname());
   ENameIter enamesIter = iter.emps();
   while (enamesIter.next())
   {
      System.out.println(enamesIter.ename());
   }
   enamesIter.close();
}
iter.close();
...</pre></div>
                     <!-- class="example" -->
                     <div class="example" id="GUID-A8BA5DEF-6CA2-4C06-8073-0F475851B7CA__GUID-469E7D04-09B1-4E45-AA8C-E5AB756EC4B8">
                        <p class="titleinexample">Example 5-3 Example: Named Iterator Column in a Positional Iterator</p>
                        <p>This example uses a positional iterator that has a column whose type is that of a previously defined named iterator (nested iterators). This uses the <code class="codeph">FETCH INTO</code> syntax of positional iterators. This example is functionally equivalent to the previous two.
                        </p>
                        <p>Note that because the outer iterator is a positional iterator, there does not have to be an alias to match a column name, as was required when the outer iterator was a named iterator in the previous example.</p>
                        <p>The iterator declaration is as follows:</p><pre class="oac_no_warn" dir="ltr">#sql iterator ENameIter (String ename);
#sql iterator DeptIter (String, ENameIter);
</pre><p>The code that uses this iterator is as follows:</p><pre class="oac_no_warn" dir="ltr">...
DeptIter iter;
...
#sql iter = { SELECT dname, cursor 
             (SELECT ename FROM emp WHERE deptno = dept.deptno) 
              FROM dept };

while (true)
{
   String dname = null;
   ENameIter enamesIter = null;
   #sql { FETCH :iter INTO :dname, :enamesIter };
   if (iter.endFetch()) break;
   System.out.println(dname);
   while (enamesIter.next())
   {
      System.out.println(enamesIter.ename());
   }
   enamesIter.close();
}
iter.close();
...</pre></div>
                     <!-- class="example" -->
                  </div>
               </div>
            </div><a id="JSQLJ342"></a><div class="props_rev_3"><a id="GUID-74814900-4067-4EE0-B74B-A9A5F5DED86C" name="GUID-74814900-4067-4EE0-B74B-A9A5F5DED86C"></a><h3 id="JSQLJ-GUID-74814900-4067-4EE0-B74B-A9A5F5DED86C" class="sect3">Assignment Statements (SET)</h3>
               <div>
                  <p>SQLJ enables you to assign a value to a Java host expression inside a SQL operation. This is known as an assignment statement and is accomplished using the following syntax:</p><pre class="oac_no_warn" dir="ltr">#sql { SET :<span class="italic">host_exp</span> = <span class="italic">expression</span> };
</pre><p>The <span class="italic"><code class="codeph">host_exp</code></span> is the target host expression, such as a variable or array index. The <span class="italic"><code class="codeph">expression</code></span> could be a number, host expression, arithmetic expression, function call, or other construct that yields a valid result into the target host expression.
                  </p>
                  <p>The default is <code class="codeph">OUT</code> for a target host expression in an assignment statement, but you can optionally state this explicitly:
                  </p><pre class="oac_no_warn" dir="ltr">#sql { SET :OUT <span class="italic">host_exp</span> = <span class="italic">expression</span> };
</pre><p>Trying to use an <code class="codeph">IN</code> or <code class="codeph">INOUT</code> token in an assignment statement will result in an error at translation time.
                  </p>
                  <p>The preceding statements are functionally equivalent to the following PL/SQL code:</p><pre class="oac_no_warn" dir="ltr">#sql { BEGIN :OUT <span class="italic">host_exp</span> := <span class="italic">expression</span>; END };
</pre><p>Here is a simple example of an assignment statement:</p><pre class="oac_no_warn" dir="ltr">#sql { SET :x = foo1() + foo2() };
</pre><p>This statement assigns to <code class="codeph">x</code> the sum of the return values of <code class="codeph">foo1()</code> and <code class="codeph">foo2()</code> and assumes that the type of <code class="codeph">x</code> is compatible with the type of the sum of the outputs of these functions.
                  </p>
                  <p>Consider the following additional examples:</p><pre class="oac_no_warn" dir="ltr">int i2;
java.sql.Date dat;
...
#sql { SET :i2 = TO_NUMBER(substr('750 etc.', 1, 3)) +
        TO_NUMBER(substr('250 etc.', 1, 3)) };
...
#sql { SET :dat = sysdate };
...
</pre><p>The first statement will assign to <code class="codeph">i2</code> the value <code class="codeph">1000</code>. The <code class="codeph">substr()</code> calls takes the first three characters of the strings, that is, "750" and "250". The <code class="codeph">TO_NUMBER()</code> calls convert the strings to the numbers 750 and 250.
                  </p>
                  <p>The second statement will read the database system date and assign it to <code class="codeph">dat</code>.
                  </p>
                  <p>An assignment statement is especially useful when you are performing operations on return variables from functions stored in the database. You do not need an assignment statement to simply assign a function result to a variable, because you can accomplish this using standard function call syntax. You also do not need an assignment statement to manipulate output from Java functions, because you can accomplish that in a typical Java statement. So you can presume that <code class="codeph">foo1()</code> and <code class="codeph">foo2()</code> are stored functions in the database, not Java functions.
                  </p>
               </div>
            </div><a id="JSQLJ343"></a><div class="props_rev_3"><a id="GUID-3FC4A9CC-9B63-4010-B842-0BDEA19C8C3B" name="GUID-3FC4A9CC-9B63-4010-B842-0BDEA19C8C3B"></a><h3 id="JSQLJ-GUID-3FC4A9CC-9B63-4010-B842-0BDEA19C8C3B" class="sect3">Stored Procedure and Function Calls</h3>
               <div>
                  <p>SQLJ provides convenient syntax for calling stored procedures and stored functions in the database. These procedures and functions could be written in Java, PL/SQL, or any other language supported by the database.</p>
                  <p>A stored function requires a result expression in your SQLJ executable statement to accept the return value and, optionally, can take input, output, or input-output parameters as well.</p>
                  <p>A stored procedure does not have a return value. Optionally, it can take input, output, or input-output parameters. A stored procedure can return output through any output or input-output parameter.</p>
                  <p>This section covers the following topics:</p>
                  <ul style="list-style-type: disc;">
                     <li>
                        <p><a href="basic-language-features.html#GUID-CDDD7913-A445-4BB3-8193-1A3C75A577C5">Calling Stored Procedures</a></p>
                     </li>
                     <li>
                        <p><a href="basic-language-features.html#GUID-18E7A8FC-D16A-4A57-9A9E-B85919E9160D">Calling Stored Functions</a></p>
                     </li>
                     <li>
                        <p><a href="basic-language-features.html#GUID-F45F4FF0-6D2A-455D-A8A0-0BC3770845B2">Using Iterators and Result Sets as Stored Function Returns</a></p>
                     </li>
                  </ul>
               </div><a id="JSQLJ344"></a><div class="props_rev_3"><a id="GUID-CDDD7913-A445-4BB3-8193-1A3C75A577C5" name="GUID-CDDD7913-A445-4BB3-8193-1A3C75A577C5"></a><h4 id="JSQLJ-GUID-CDDD7913-A445-4BB3-8193-1A3C75A577C5" class="sect4">Calling Stored Procedures</h4>
                  <div>
                     <div class="section">
                        <p>Stored procedures do not have a return value but can take a list with input, output, and input-output parameters. Stored procedure calls use the <code class="codeph">CALL</code> token. The <code class="codeph">CALL</code> token is followed by white space and then the procedure name. There must be a space after the <code class="codeph">CALL</code> token to differentiate it from the procedure name. There <span class="italic">cannot</span> be a set of outer parentheses around the procedure call. This differs from the syntax for function calls. The syntax for the <code class="codeph">CALL</code> token is as follows:
                        </p><pre class="oac_no_warn" dir="ltr">#sql { CALL <span class="italic">PROC</span>(&lt;<span class="italic">PARAM_LIST&gt;</span>) };
</pre><p><span class="italic"><code class="codeph">PROC</code></span> is the name of the stored procedure, which can optionally take a list of input, output, and input-output parameters. <span class="italic"><code class="codeph">PROC</code></span> can include a schema or package name as well, such as <code class="codeph">HR.MYPROC()</code>.
                        </p>
                        <p>Presume that you have defined the following PL/SQL stored procedure:</p><pre class="oac_no_warn" dir="ltr">CREATE OR REPLACE PROCEDURE MAX_DEADLINE (deadline OUT DATE) IS
   BEGIN
      SELECT MAX(start_date + duration) INTO deadline FROM projects;
   END;
</pre><p>This reads the <code class="codeph">PROJECTS</code> table, looks at the <code class="codeph">START_DATE</code> and <code class="codeph">DURATION</code> columns, calculates <code class="codeph">start_date + duration</code> in each row, then takes the maximum <code class="codeph">START_DATE + DURATION</code> total, and assigns it to <code class="codeph">DEADLINE</code>, which is an output parameter of type <code class="codeph">DATE</code>.
                        </p>
                        <p>In SQLJ, you can call this <code class="codeph">MAX_DEADLINE</code> procedure as follows:
                        </p><pre class="oac_no_warn" dir="ltr">java.sql.Date maxDeadline;
...
#sql { CALL MAX_DEADLINE(:out maxDeadline) };
</pre><p>For any parameters, you must use the host expression tokens <code class="codeph">IN</code>, <code class="codeph">OUT</code>, and <code class="codeph">INOUT</code> appropriately, to match the input, output, and input-output designations of the stored procedure. Additionally, the types of the host variables you use in the parameter list must be compatible with the parameter types of the stored procedure.
                        </p>
                        <div class="infoboxnote" id="GUID-CDDD7913-A445-4BB3-8193-1A3C75A577C5__GUID-D2058647-C09A-4DFA-AEFC-B079AF2D619E">
                           <p class="notep1">Note:</p>
                           <p>If you want your application to be compatible with Oracle7 Database, then do <span class="italic">not</span> include empty parentheses for the parameter list if the procedure takes no parameters. For example:
                           </p><pre class="oac_no_warn" dir="ltr"><code class="codeph">#sql { CALL MAX_DEADLINE };</code></pre><p>not:</p><pre class="oac_no_warn" dir="ltr"><code class="codeph">#sql { CALL MAX_DEADLINE() };</code></pre></div>
                     </div>
                     <!-- class="section" -->
                  </div>
               </div><a id="JSQLJ345"></a><div class="props_rev_3"><a id="GUID-18E7A8FC-D16A-4A57-9A9E-B85919E9160D" name="GUID-18E7A8FC-D16A-4A57-9A9E-B85919E9160D"></a><h4 id="JSQLJ-GUID-18E7A8FC-D16A-4A57-9A9E-B85919E9160D" class="sect4">Calling Stored Functions</h4>
                  <div>
                     <div class="section">
                        <p>Stored functions have a return value and can also take a list of input, output, and input-output parameters. Stored function calls use the <code class="codeph">VALUES</code> token. The <code class="codeph">VALUES</code> token is followed by the function call. In standard SQLJ, the function call must be enclosed in a set of outer parentheses. In the Oracle SQLJ implementation, the outer parentheses are optional. When using the outer parentheses, it does not matter if there is white space between the <code class="codeph">VALUES</code> token and the begin-parenthesis. The syntax for the <code class="codeph">VALUES</code> token is as follows:
                        </p><pre class="oac_no_warn" dir="ltr">#sql <span class="italic">result</span> = { VALUES(<span class="italic">FUNC</span>(<span class="italic">PARAM_LIST</span>)) };
</pre><p>In this syntax, <span class="italic"><code class="codeph">result</code></span> is the result expression, which takes the function return value. <span class="italic"><code class="codeph">FUNC</code></span> is the name of the stored function, which can optionally take a list of input, output, and input-output parameters. <span class="italic"><code class="codeph">FUNC</code></span> can include a schema or package name, such as <code class="codeph">HR.MYFUNC()</code>.
                        </p>
                        <div class="infoboxnote" id="GUID-18E7A8FC-D16A-4A57-9A9E-B85919E9160D__GUID-F606890D-B9CB-406F-95D4-24E2E894EBDB">
                           <p class="notep1">Note:</p>
                           <p>A <code class="codeph">VALUES</code> token can also be used in <code class="codeph">INSERT INTO </code><span class="italic"><code class="codeph">table</code></span><code class="codeph"> VALUES</code> syntax supported by the Oracle SQL implementation, but these situations are unrelated semantically and syntactically.
                           </p>
                        </div>
                        <p>Referring back to the example in <span class="q">"<a href="basic-language-features.html#GUID-CDDD7913-A445-4BB3-8193-1A3C75A577C5">Calling Stored Procedures</a>"</span>, consider defining the stored procedure as a stored function instead, as follows:
                        </p><pre class="oac_no_warn" dir="ltr">CREATE OR REPLACE FUNCTION GET_MAX_DEADLINE RETURN DATE IS
   deadline DATE;
   BEGIN
      SELECT MAX(start_date + duration) INTO deadline FROM projects;
      RETURN deadline;
   END;
</pre><p>In SQLJ, you can call this <code class="codeph">GET_MAX_DEADLINE</code> function as follows:
                        </p><pre class="oac_no_warn" dir="ltr">java.sql.Date maxDeadline;
...
#sql maxDeadline = { VALUES(GET_MAX_DEADLINE) };
</pre><p>The result expression must have a type compatible with the return type of the function.</p>
                        <p>In the Oracle SQLJ implementation, the following syntax is also allowed:</p><pre class="oac_no_warn" dir="ltr">#sql maxDeadline = { VALUES GET_MAX_DEADLINE };
</pre><p>Note that the outer parentheses is omitted.</p>
                        <p>For stored function calls, as with stored procedures, you must use the host expression tokens <code class="codeph">IN</code>, <code class="codeph">OUT</code>, and <code class="codeph">INOUT</code> appropriately, to match the input, output, and input-output parameters of the stored function. Additionally, the types of the host variables you use in the parameter list must be compatible with the parameter types of the stored function.
                        </p>
                        <div class="infoboxnote" id="GUID-18E7A8FC-D16A-4A57-9A9E-B85919E9160D__GUID-BF91927A-251B-405F-9A6B-334C6E449500">
                           <p class="notep1">Note:</p>
                           <p>If you want your stored function to be portable to non-Oracle environments, then you should use only input parameters in the calling sequence, not output or input-output parameters.</p>
                        </div>
                     </div>
                     <!-- class="section" -->
                  </div>
               </div><a id="JSQLJ347"></a><a id="JSQLJ346"></a><div class="props_rev_3"><a id="GUID-F45F4FF0-6D2A-455D-A8A0-0BC3770845B2" name="GUID-F45F4FF0-6D2A-455D-A8A0-0BC3770845B2"></a><h4 id="JSQLJ-GUID-F45F4FF0-6D2A-455D-A8A0-0BC3770845B2" class="sect4">Using Iterators and Result Sets as Stored Function Returns</h4>
                  <div>
                     <div class="section">
                        <p>SQLJ supports assigning the return value of a stored function to an iterator or result set variable, if the function returns a REF CURSOR type.</p>
                        <p>The following example uses an iterator to take a stored function return. Using a result set is similar.</p>
                     </div>
                     <!-- class="section" -->
                     <div class="section">
                        <p class="subhead3" id="GUID-F45F4FF0-6D2A-455D-A8A0-0BC3770845B2__GUID-C602C78E-655D-46D1-AB5F-0C3217D1AB36">Example: Iterator as Stored Function Return</p>
                     </div>
                     <!-- class="section" -->
                     <div class="section">
                        <p>This example uses an iterator as a return type for a stored function, using a <code class="codeph">REF CURSOR</code> type in the process.
                        </p>
                        <p>Presume the following function definition:</p><pre class="oac_no_warn" dir="ltr">CREATE OR REPLACE PACKAGE sqlj_refcursor AS
   TYPE EMP_CURTYPE IS REF CURSOR;
   FUNCTION job_listing (j varchar2) RETURN EMP_CURTYPE;
END sqlj_refcursor;

CREATE OR REPLACE PACKAGE BODY sqlj_refcursor AS 
   FUNCTION job_listing (j varchar) RETURN EMP_CURTYPE IS 
   DECLARE
      rc EMP_CURTYPE;
   BEGIN
      OPEN rc FOR SELECT ename, empno FROM emp WHERE job = j;
      RETURN rc;
   END;
END sqlj_refcursor;
</pre><p>Declare the iterator as follows:</p><pre class="oac_no_warn" dir="ltr">#sql public &lt;static&gt; iterator EmpIter (String ename, int empno);
</pre><p>The <code class="codeph">public</code> modifier is required, and the <code class="codeph">static</code> modifier may be advisable if your declaration is at class level or nested-class level.
                        </p>
                        <p>The code that uses the iterator and the function is as follows:</p><pre class="oac_no_warn" dir="ltr">EmpIter iter;
...
#sql iter = { VALUES(sqlj_refcursor.job_listing('SALES')) };

while (iter.next())
{
   String empname = iter.ename();
   int empnum = iter.empno();

   ... <span class="italic">process empname and empnum</span> ...
}
iter.close();
...
</pre><p>This example calls the <code class="codeph">job_listing()</code> function to return an iterator that contains the name and employee number of each employee whose job title is SALES. It then retrieves this data from the iterator.
                        </p>
                     </div>
                     <!-- class="section" -->
                  </div>
               </div>
            </div>
         </div>
      </article>
   </body>
</html>