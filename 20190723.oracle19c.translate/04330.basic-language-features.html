<html lang="en-us" dir="ltr" xml:lang="en-us">
   <head>
      <meta http-equiv="Content-Type" content="text/html; charset=utf-8"></meta>
      <meta name="viewport" content="width=device-width, initial-scale=1"></meta>
      <meta http-equiv="X-UA-Compatible" content="IE=edge"></meta>
      <title>基本语言功能</title>
      <meta property="og:site_name" content="Oracle Help Center"></meta>
      <meta property="og:title" content="SQLJ Developer&#39;s Guide "></meta>
      <meta property="og:description" content=""></meta>
      <link rel="stylesheet" href="/sp_common/book-template/ohc-book-template/css/book.css"></link>
      <link rel="shortcut icon" href="/sp_common/book-template/ohc-common/img/favicon.ico"></link>
      <meta name="application-name" content="SQLJ Developer&#39;s Guide"></meta>
      <meta name="generator" content="DITA Open Toolkit version 1.8.5 (Mode = doc)"></meta>
      <meta name="plugin" content="SP_docbuilder HTML plugin release 18.2.2"></meta>
      <link rel="alternate" href="sqlj-developers-guide.pdf" title="PDF File" type="application/pdf"></link>
      <meta name="robots" content="all"></meta>
      <link rel="schema.dcterms" href="http://purl.org/dc/terms/"></link>
      <meta name="dcterms.created" content="2019-01-11T08:20:03-08:00"></meta>
      
      <meta name="dcterms.dateCopyrighted" content="1999, 2019"></meta>
      <meta name="dcterms.category" content="database"></meta>
      <meta name="dcterms.identifier" content="E96458-01"></meta>
      
      <meta name="dcterms.product" content="en/database/oracle/oracle-database/19"></meta>
      
      <link rel="prev" href="key-programming-considerations.html" title="Previous" type="text/html"></link>
      <link rel="next" href="type-support.html" title="Next" type="text/html"></link>
      <script>
        document.write('<style type="text/css">');
        document.write('body > .noscript, body > .noscript ~ * { visibility: hidden; }');
        document.write('</style>');
     </script>
      <script src="/sp_common/book-template/requirejs/require.js" data-main="/sp_common/book-template/ohc-book-template/js/book-config"></script>
      <script>
            if (window.require === undefined) {
                document.write('<script data-main="sp_common/book-template/ohc-book-template/js/book-config" src="sp_common/book-template/requirejs/require.js"><\/script>');
                document.write('<link href="sp_common/book-template/ohc-book-template/css/book.css" rel="stylesheet"/>');
            }
        </script>
      <script type="application/json" id="ssot-metadata">{"primary":{"category":{"short_name":"database","element_name":"Database","display_in_url":true},"suite":{"short_name":"oracle","element_name":"Oracle","display_in_url":true},"product_group":{"short_name":"not-applicable","element_name":"Not applicable","display_in_url":false},"product":{"short_name":"oracle-database","element_name":"Oracle Database","display_in_url":true},"release":{"short_name":"19","element_name":"Release 19","display_in_url":true}}}</script>
      
    <meta name="dcterms.title" content="SQLJ Developer&#39;s Guide"></meta>
    <meta name="dcterms.isVersionOf" content="JSQLJ"></meta>
    <meta name="dcterms.release" content="Release 19"></meta>
  </head>
   <body dir="ltr">
      <div class="noscript alert alert-danger text-center" role="alert">
         <a href="key-programming-considerations.html" class="pull-left"><span class="glyphicon glyphicon-chevron-left" aria-hidden="true"></span>上一页</a> <a href="type-support.html" class="pull-right">下一页<span class="glyphicon glyphicon-chevron-right" aria-hidden="true"></span></a> <span class="fa fa-exclamation-triangle" aria-hidden="true"></span>必须启用JavaScript才能正确显示此内容</div>
      <article>
         <header>
            <ol class="breadcrumb" vocab="http://schema.org/" typeof="BreadcrumbList">
               <li property="itemListElement" typeof="ListItem"><a href="index.html" property="item" typeof="WebPage"><span property="name">SQLJ开发人员指南</span></a></li>
               <li class="active" property="itemListElement" typeof="ListItem">基本语言功能</li>
            </ol>
            <a id="GUID-D93359BA-4F29-49C2-8AAE-23F8BBCE8BE5" name="GUID-D93359BA-4F29-49C2-8AAE-23F8BBCE8BE5"></a><a id="JSQLJ270"></a>
            
            <h2 id="JSQLJ-GUID-D93359BA-4F29-49C2-8AAE-23F8BBCE8BE5" class="sect2"><span class="enumeration_chapter">5</span>基本语言功能</h2>
         </header>
         <div class="ind">
            <div>
               <p>SQLJ语句总是以<code class="codeph">#sql</code>标记开头，可以分为两大类：</p>
               <ul style="list-style-type:disc">
                  <li>
                     <p>声明：用于为迭代器创建Java类，类似于Java数据库连接（JDBC）结果集或连接上下文，旨在帮助您根据所使用的SQL实体集创建强类型连接。</p>
                  </li>
                  <li>
                     <p>可执行语句：用于执行嵌入式SQL操作。</p>
                  </li>
               </ul>
               <p>本章讨论以下主题：</p>
               <ul style="list-style-type:disc">
                  <li>
                     <p><a href="basic-language-features.html#GUID-74A36C5C-B63E-4489-A464-47387ABCB24E">SQLJ声明概述</a></p>
                  </li>
                  <li>
                     <p><a href="basic-language-features.html#GUID-863A3FD5-C7DB-4032-9DE7-6721287C9579">SQLJ可执行语句概述</a></p>
                  </li>
                  <li>
                     <p><a href="basic-language-features.html#GUID-7B85631F-98E1-4A9A-BBC1-181A53D0D03D">Java Host_ Context_和Result Expressions</a></p>
                  </li>
                  <li>
                     <p><a href="basic-language-features.html#GUID-E779CA66-DE27-48C8-A379-E793AF0FB280">单行查询结果：SELECT INTO语句</a></p>
                  </li>
                  <li>
                     <p><a href="basic-language-features.html#GUID-C6E5904A-2D17-40EA-9DF2-AD5BCEA58E2D">多行查询结果：SQLJ迭代器</a></p>
                  </li>
                  <li>
                     <p><a href="basic-language-features.html#GUID-74814900-4067-4EE0-B74B-A9A5F5DED86C">作业陈述（SET）</a></p>
                  </li>
                  <li>
                     <p><a href="basic-language-features.html#GUID-3FC4A9CC-9B63-4010-B842-0BDEA19C8C3B">存储过程和函数调用</a></p>
                  </li>
               </ul>
            </div><a id="JSQLJ271"></a><div class="props_rev_3"><a id="GUID-74A36C5C-B63E-4489-A464-47387ABCB24E" name="GUID-74A36C5C-B63E-4489-A464-47387ABCB24E"></a><h3 id="JSQLJ-GUID-74A36C5C-B63E-4489-A464-47387ABCB24E" class="sect3">SQLJ声明概述</h3>
               <div>
                  <p>SQLJ声明包含<code class="codeph">#sql</code>标记，后跟类的声明。SQLJ声明在您的应用程序中引入了专门的Java类型。目前有两种SQLJ声明，迭代器声明和连接上下文声明，定义Java类如下：</p>
                  <ul style="list-style-type:disc">
                     <li>
                        <p>迭代器声明定义迭代器类。迭代器在概念上类似于JDBC结果集，用于接收多行查询数据。迭代器是作为迭代器类的实例实现的。</p>
                     </li>
                     <li>
                        <p>连接上下文声明定义连接上下文类。每个连接上下文类通常用于其操作使用特定SQL实体集（例如表，视图和存储过程）的连接。也就是说，特定连接上下文类的实例用于连接包含具有相同名称和特征的SQL实体的模式。SQLJ将每个数据库连接实现为连接上下文类的实例。</p>
                        <p>SQLJ包含预定义的<code class="codeph">sqlj.runtime.DefaultContext</code>连接上下文类。如果只需要一个连接上下文类，则可以使用<code class="codeph">DefaultContext</code> ，它不需要连接上下文声明。
                        </p>
                     </li>
                  </ul>
                  <p>在任何迭代器或连接上下文声明中，您可以选择包含以下子句：</p>
                  <ul style="list-style-type:disc">
                     <li>
                        <p><code class="codeph">implements</code>子句：指定生成的类将实现的一个或多个接口。
                        </p>
                     </li>
                     <li>
                        <p><code class="codeph">with</code>子句：指定要包含在生成的类中的一个或多个初始化常量。
                        </p>
                     </li>
                  </ul>
                  <p>本节包括以下主题：</p>
                  <ul style="list-style-type:disc">
                     <li>
                        <p><a href="basic-language-features.html#GUID-B0C0602E-65AE-4337-9AC3-0F4576A079F1">SQLJ声明的规则</a></p>
                     </li>
                     <li>
                        <p><a href="basic-language-features.html#GUID-3B3F5EE5-0540-4196-A7BA-93628EE09B8F">迭代器声明</a></p>
                     </li>
                     <li>
                        <p><a href="basic-language-features.html#GUID-35341EB4-501B-4807-A6A1-88F92C8B76DF">连接上下文声明</a></p>
                     </li>
                     <li>
                        <p><a href="basic-language-features.html#GUID-1843167B-56CD-49CB-811B-4ACC5DF38035">声明实施条款</a></p>
                     </li>
                     <li>
                        <p><a href="basic-language-features.html#GUID-5E97C2F0-7249-48FD-A75B-AB5A465147C7">声明条款</a></p>
                     </li>
                  </ul>
               </div><a id="JSQLJ272"></a><div class="props_rev_3"><a id="GUID-B0C0602E-65AE-4337-9AC3-0F4576A079F1" name="GUID-B0C0602E-65AE-4337-9AC3-0F4576A079F1"></a><h4 id="JSQLJ-GUID-B0C0602E-65AE-4337-9AC3-0F4576A079F1" class="sect4">SQLJ声明的规则</h4>
                  <div>
                     <p>SQLJ源代码允许在标准Java中允许类定义的任何地方使用SQLJ声明。例如：</p><pre class="oac_no_warn" dir="ltr"><span class="italic">SQLJ声明</span> ; // OK（顶级作用域）类Outer { <span class="italic">SQLJ声明</span> ; // OK（类级别范围）类Inner { <span class="italic">SQLJ声明</span> ; // OK（嵌套类范围）} void func（）{ <span class="italic">SQLJ声明</span> ; // OK（方法块）}}</pre><div class="infoboxnote" id="GUID-B0C0602E-65AE-4337-9AC3-0F4576A079F1__GUID-2D6AF3A4-A5E3-4749-ABE2-9FA3A03BB346">
                        <p class="notep1">注意：</p>
                        <p>与标准Java一样，任何公共类都应该通过以下方式之一声明：</p>
                        <ul style="list-style-type:disc">
                           <li>
                              <p>在单独的源文件中声明它。文件的基本名称应与类名相同。</p>
                           </li>
                           <li>
                              <p>在类级别范围或嵌套级别级别范围内声明它。在这种情况下，建议使用<code class="codeph">public static</code>修饰符。
                              </p>
                           </li>
                        </ul>
                        <p>如果您使用随Sun Microsystems JDK提供的标准<code class="codeph">javac</code>编译器，则这是必需的。</p>
                     </div>
                  </div>
               </div><a id="JSQLJ273"></a><div class="props_rev_3"><a id="GUID-3B3F5EE5-0540-4196-A7BA-93628EE09B8F" name="GUID-3B3F5EE5-0540-4196-A7BA-93628EE09B8F"></a><h4 id="JSQLJ-GUID-3B3F5EE5-0540-4196-A7BA-93628EE09B8F" class="sect4">迭代器声明</h4>
                  <div>
                     <p>迭代器声明创建一个类，该类定义一种用于接收查询数据的迭代器。声明将指定迭代器实例的列类型，它们必须与从数据库表中选择的列类型相匹配。</p>
                     <p>基本迭代器声明使用以下语法：</p><pre class="oac_no_warn" dir="ltr">#sql &lt; <span class="italic">modifiers</span> &gt; iterator <span class="italic">iterator_classname</span> （ <span class="italic">type declarations</span> ）;</pre><p>修饰符是可选的，可以是任何标准Java类修饰符，例如<code class="codeph">public</code> ， <code class="codeph">static</code>等。类型声明以逗号分隔。
                     </p>
                     <p>有两类迭代器，名为迭代器和位置迭代器。对于命名迭代器，您必须指定列名称和类型。对于位置迭代器，您只需要指定类型。</p>
                     <p>以下是命名迭代器声明的示例：</p><pre class="oac_no_warn" dir="ltr">#sql public iterator EmpIter（String ename，double sal）;</pre><p>此语句导致SQLJ转换器创建具有<code class="codeph">String</code>属性<code class="codeph">ename</code>和<code class="codeph">double</code>属性<code class="codeph">sal</code>的公共<code class="codeph">EmpIter</code>类。您可以使用此迭代器从数据库表中选择具有匹配名称（ <code class="codeph">ENAME</code>和<code class="codeph">SAL</code> ）和数据类型（ <code class="codeph">CHAR</code>和<code class="codeph">NUMBER</code> ）的相应员工姓名和工资列的数据。
                     </p>
                     <p>将<code class="codeph">EmpIter</code>声明为位置迭代器而不是命名迭代器，可以按如下方式进行：</p><pre class="oac_no_warn" dir="ltr">#sql public iterator EmpIter（String，double）;</pre><div class="infoboxnotealso" id="GUID-3B3F5EE5-0540-4196-A7BA-93628EE09B8F__GUID-C4421FC3-4A58-457B-88CB-C0D7473146F8">
                        <p class="notep1">也可以看看：</p>
                        <p><span class="q">“多<a href="basic-language-features.html#GUID-C6E5904A-2D17-40EA-9DF2-AD5BCEA58E2D">行查询结果：SQLJ迭代器</a> ”</span></p>
                     </div>
                  </div>
               </div><a id="JSQLJ274"></a><div class="props_rev_3"><a id="GUID-35341EB4-501B-4807-A6A1-88F92C8B76DF" name="GUID-35341EB4-501B-4807-A6A1-88F92C8B76DF"></a><h4 id="JSQLJ-GUID-35341EB4-501B-4807-A6A1-88F92C8B76DF" class="sect4">连接上下文声明</h4>
                  <div>
                     <p>连接上下文声明创建连接上下文类，其实例通常用于使用特定SQL实体集的数据库连接。基本连接上下文声明使用以下语法：</p><pre class="oac_no_warn" dir="ltr">#sql &lt; <span class="italic">modifiers</span> &gt; context <span class="italic">context_classname</span> ;</pre><p>至于迭代器声明，修饰符是可选的，可以是任何标准的Java类修饰符。例如：</p><pre class="oac_no_warn" dir="ltr">#sql public context MyContext;</pre><p>作为此语句的结果，SQLJ转换器创建一个公共<code class="codeph">MyContext</code>类。在SQLJ代码中，您可以使用此类的实例来创建与包含所需实体集（例如表，视图和存储过程）的模式的数据库连接。<code class="codeph">MyContext</code>不同实例可能用于连接到不同的模式，但可能需要每个模式，例如，包括<code class="codeph">EMPLOYEES</code>表， <code class="codeph">DEPARTMENTS</code>表和<code class="codeph">SECURE_EMPLOYEES</code>存储过程。
                     </p>
                     <p>声明的连接上下文类是一个高级主题，对于仅使用一组相互关联的SQL实体的基本SQLJ应用程序不是必需的。在基本方案中，您可以通过创建<code class="codeph">sqlj.runtime.ref.多个实例来使用多个连接<code class="codeph">sqlj.runtime.ref.DefaultContext</code>类，不需要任何连接上下文声明。
                     </p>
                     <div class="infoboxnotealso" id="GUID-35341EB4-501B-4807-A6A1-88F92C8B76DF__GUID-241F095A-7026-4000-85C3-8836863DAD02">
                        <p class="notep1">也可以看看：</p>
                        <p><span class="q">“ <a href="key-programming-considerations.html#GUID-02A50813-2D4D-4DC1-AD1A-014AF1EDC03D">连接注意事项</a> ”</span>和<span class="q">“ <a href="advanced-language-features.html#GUID-DE7D99A8-ED65-4DEA-B274-3BC09EE0056A">连接上下文</a> ”</span></p>
                     </div>
                  </div>
               </div><a id="JSQLJ275"></a><div class="props_rev_3"><a id="GUID-1843167B-56CD-49CB-811B-4ACC5DF38035" name="GUID-1843167B-56CD-49CB-811B-4ACC5DF38035"></a><h4 id="JSQLJ-GUID-1843167B-56CD-49CB-811B-4ACC5DF38035" class="sect4">声明实施条款</h4>
                  <div>
                     <p>声明任何迭代器类或连接上下文类时，可以指定要由生成的类实现的一个或多个接口。</p>
                     <p>对迭代器类使用以下语法：</p><pre class="oac_no_warn" dir="ltr">#sql &lt; <span class="italic">modifiers</span> &gt; iterator <span class="italic">iterator_classname</span>实现<span class="italic">intfc1</span> ，...， <span class="italic">intfcN</span> （ <span class="italic">类型声明</span> ）;</pre><p>该部分<code class="codeph">implements</code> <span class="italic"><code class="codeph">intfc1,..., intfcN</code></span>被称为<code class="codeph">implements</code>子句。请注意，在迭代器声明中， <code class="codeph">implements</code>子句位于迭代器类型声明之前。
                     </p>
                     <p>以下是连接上下文声明的语法：</p><pre class="oac_no_warn" dir="ltr">#sql &lt; <span class="italic">modifiers</span> &gt; context <span class="italic">context_classname</span>实现<span class="italic">intfc1</span> ，...， <span class="italic">intfcN</span> ;</pre><p><code class="codeph">implements</code>子句在迭代器声明或连接上下文声明中可能很有用，但在迭代器声明中更有用，特别是在实现<code class="codeph">sqlj.runtime.Scrollable</code>或<code class="codeph">sqlj.runtime.ForUpdate</code>接口。Oracle SQLJ实现支持可滚动迭代器。
                     </p>
                     <div class="infoboxnote" id="GUID-1843167B-56CD-49CB-811B-4ACC5DF38035__GUID-1986A5B0-0F46-4FC9-901F-034B30770D0B">
                        <p class="notep1">注意：</p>
                        <p>SQLJ <code class="codeph">implements</code>子句对应于Java <code class="codeph">implements</code>子句。
                        </p>
                     </div>
                     <p>以下示例在声明命名迭代器类时使用<code class="codeph">implements</code>子句。假设您已经创建了一个包<code class="codeph">mypackage</code> ，其中包含一个迭代器接口<code class="codeph">MyIterIntfc</code> 。
                     </p><pre class="oac_no_warn" dir="ltr">#sql public iterator MyIter实现mypackage。MyIterIntfc（String ename，int empno）;</pre><p>声明的类<code class="codeph">MyIter</code>将实现<code class="codeph">mypackage.MyIterIntfc</code>界面。
                     </p>
                     <p>以下示例声明了一个实现名为<code class="codeph">MyConnCtxtIntfc</code>的接口的连接上下文类。假设它在包<code class="codeph">mypackage</code> 。
                     </p><pre class="oac_no_warn" dir="ltr">#sql public context MyContext实现mypackage。MyConnCtxtIntfc;</pre><div class="infoboxnotealso" id="GUID-1843167B-56CD-49CB-811B-4ACC5DF38035__GUID-697138C7-5A45-4C02-9EC3-81D67CF95BBF">
                        <p class="notep1">也可以看看：</p>
                        <p><span class="q">“ <a href="advanced-language-features.html#GUID-6504E582-745D-4419-AE90-97CB95181C4C">在迭代器声明中使用IMPLEMENTS子句</a> ”</span>和<span class="q">“ <a href="advanced-language-features.html#GUID-DBE080FD-E5E1-476B-8B7F-199D44C259BC">在连接上下文声明中使用IMPLEMENTS子句</a> ”</span></p>
                     </div>
                  </div>
               </div><a id="JSQLJ276"></a><div class="props_rev_3"><a id="GUID-5E97C2F0-7249-48FD-A75B-AB5A465147C7" name="GUID-5E97C2F0-7249-48FD-A75B-AB5A465147C7"></a><h4 id="JSQLJ-GUID-5E97C2F0-7249-48FD-A75B-AB5A465147C7" class="sect4">声明条款</h4>
                  <div>
                     <p>在声明连接上下文类或迭代器类时，可以使用<code class="codeph">with</code>子句指定和初始化要包含在生成的类的定义中的一个或多个常量。尽管Oracle实现为迭代器声明添加了一些扩展功能，但大部分用法都是标准的。
                     </p>
                     <p>本节包括以下主题：</p>
                     <ul style="list-style-type:disc">
                        <li>
                           <p><a href="basic-language-features.html#GUID-40673A09-9276-406D-9170-6B936E0546BB">标准WITH子句用法</a></p>
                        </li>
                        <li>
                           <p><a href="basic-language-features.html#GUID-CE3C0979-706C-4BCE-91DE-D0EC5A46D4D6">特定于Oracle的WITH子句用法</a></p>
                        </li>
                        <li>
                           <p><a href="basic-language-features.html#GUID-59D146A5-BCAE-4E68-91EC-C79417686CCF">示例：可回收性</a></p>
                        </li>
                     </ul>
                  </div><a id="JSQLJ278"></a><a id="JSQLJ279"></a><a id="JSQLJ277"></a><div class="props_rev_3"><a id="GUID-40673A09-9276-406D-9170-6B936E0546BB" name="GUID-40673A09-9276-406D-9170-6B936E0546BB"></a><h5 id="JSQLJ-GUID-40673A09-9276-406D-9170-6B936E0546BB" class="sect5">标准WITH子句用法</h5>
                     <div>
                        <p>在使用<code class="codeph">with</code>子句时，生成的常量始终是<code class="codeph">public static final</code> 。对迭代器类使用以下语法：</p><pre class="oac_no_warn" dir="ltr">#sql &lt; <span class="italic">modifiers</span> &gt; iterator <span class="italic">iterator_classname</span> with（ <span class="italic">var1</span> = <span class="italic">value1</span> ，...， <span class="italic">varN</span> = <span class="italic">valueN</span> ）（ <span class="italic">type declarations</span> ）;</pre><p>的部分<code class="codeph">with</code> <code class="codeph">(</code> <span class="italic"><code class="codeph">var1=value1,..., varN=valueN</code></span> ）是<code class="codeph">with</code>子句。请注意，在迭代器声明中， <code class="codeph">with</code>子句位于迭代器类型声明之前。
                        </p>
                        <p>如果同时存在<code class="codeph">with</code>子句和<code class="codeph">implements</code>子句，那么<code class="codeph">implements</code>子句必须首先出现。请注意，括号用于括<code class="codeph">with</code>名单，但没有<code class="codeph">implements</code>列表。
                        </p>
                        <p>以下是使用<code class="codeph">with</code>子句的连接上下文声明的语法：</p><pre class="oac_no_warn" dir="ltr">#sql &lt; <span class="italic">modifiers</span> &gt; context <span class="italic">context_classname</span> with（ <span class="italic">var1</span> = <span class="italic">value1</span> ，...， <span class="italic">varN</span> = <span class="italic">valueN</span> ）;</pre><div class="infoboxnote" id="GUID-40673A09-9276-406D-9170-6B936E0546BB__GUID-F3CF08E6-0142-4961-843A-8F6F6EB36E41">
                           <p class="notep1">注意：</p>
                           <p>可以在<code class="codeph">with</code>子句中定义一组预定义的标准SQLJ常量。但是，并非所有这些常量对Oracle Database 12 <span class="italic">c</span>第2版（12.2）或Oracle SQLJ运行时都有意义。
                           </p>
                           <p>尝试定义标准常量以外的常量对于Oracle Database 12 <span class="italic">c</span>第2版（12.2）是合法的，但可能无法移植到其他SQLJ实现，并且如果启用了<code class="codeph">-warn=portable</code>标志，则会生成警告。
                           </p>
                        </div>
                        <div class="section">
                           <p class="subhead3" id="GUID-40673A09-9276-406D-9170-6B936E0546BB__GUID-8D91B4C8-0941-4C29-A57B-A74919880C8B">支持WITH子句常量</p>
                        </div>
                        <!-- class="section" -->
                        <div class="section">
                           <p>Oracle SQLJ实现在连接上下文声明中支持以下标准常量：</p>
                           <ul style="list-style-type:disc">
                              <li>
                                 <p><code class="codeph">typeMap</code> ：定义类型映射属性资源名称的<code class="codeph">String</code>文字</p>
                                 <p>Oracle还支持在迭代器声明中使用<code class="codeph">typeMap</code> 。
                                 </p>
                              </li>
                              <li>
                                 <p><code class="codeph">dataSource</code> ：一个<code class="codeph">String</code>文字，用于定义在<code class="codeph">InitialContext</code>查找数据源的名称</p>
                              </li>
                           </ul>
                           <p>Oracle SQLJ实现在迭代器声明中支持以下标准常量：</p>
                           <ul style="list-style-type:disc">
                              <li>
                                 <p><code class="codeph">sensitivity</code> ： <code class="codeph">SENSITIVE</code> / <code class="codeph">ASENSITIVE</code> / <code class="codeph">INSENSITIVE</code> ，用于定义可滚动迭代器的灵敏度</p>
                              </li>
                              <li>
                                 <p><code class="codeph">returnability</code> ： <code class="codeph">true</code> / <code class="codeph">false</code> ，用于定义是否可以从Java存储过程或函数返回迭代器</p>
                              </li>
                           </ul>
                        </div>
                        <!-- class="section" -->
                        <div class="section">
                           <p class="subhead3" id="GUID-40673A09-9276-406D-9170-6B936E0546BB__GUID-4ECBD3E0-DF9A-47F8-A46A-4F138ADE3AC5">不支持WITH子句常量</p>
                        </div>
                        <!-- class="section" -->
                        <div class="section">
                           <p>如果您有使用这些常量的SQLJ代码，那么它们不会导致错误但不会导致操作。甲骨文SQLJ实现<span class="italic">不</span>支持在连接上下文声明如下标准常量：</p>
                           <ul style="list-style-type:disc">
                              <li>
                                 <p><code class="codeph">path</code> ：一个<code class="codeph">String</code>文字，用于定义要为解析Java存储过程和函数而预先添加的路径的名称</p>
                              </li>
                              <li>
                                 <p><code class="codeph">transformGroup</code> ：一个<code class="codeph">String</code>文字，用于定义可应用于SQL类型的SQL转换组的名称</p>
                              </li>
                           </ul>
                           <p>Oracle SQLJ实现在迭代器声明中<span class="italic">不</span>支持以下标准常量，包括游标状态：</p>
                           <ul style="list-style-type:disc">
                              <li>
                                 <p><code class="codeph">holdability</code> ： <code class="codeph">true</code> / <code class="codeph">false</code> ，确定游标可保持性</p>
                                 <p>可持续性的概念在SQL规范中定义。根据应用程序请求，可保留的游标可以保持打开并定位在当前行上，即使事务已完成。然后，可以在同一SQL会话的下一个事务中继续使用游标，但受到一些限制。</p>
                              </li>
                              <li>
                                 <p><code class="codeph">updateColumns</code> ：包含以逗号分隔的列名列表的<code class="codeph">String</code>文字</p>
                                 <p>具有指定<code class="codeph">updateColumns</code>的<code class="codeph">with</code>子句的迭代器声明还必须具有指定<code class="codeph">sqlj.runtime.的<code class="codeph">implements</code>子句<code class="codeph">sqlj.runtime.ForUpdate</code>接口。Oracle SQLJ实现强制执行此操作，即使当前不支持<code class="codeph">updateColumns</code> 。
                                 </p>
                              </li>
                           </ul>
                           <p>以下是使用<code class="codeph">typeMap</code>的示例连接上下文声明：</p><pre class="oac_no_warn" dir="ltr">#sql public context MyContext with（typeMap =“MyPack。我的课”）;</pre><p>声明的类<code class="codeph">MyContext</code>将定义一个<code class="codeph">String</code>属性<code class="codeph">typeMap</code> ，它将是<code class="codeph">public static final</code>并初始化为值<code class="codeph">MyPack.MyClass</code> 。此值是<code class="codeph">ListResourceBundle</code>实现的完全限定类名，该实现为在<code class="codeph">MyContext</code>类的实例上执行的语句提供SQL和Java类型之间的映射。
                           </p>
                           <p>以下是使用<code class="codeph">sensitivity</code>的示例迭代器声明：</p><pre class="oac_no_warn" dir="ltr">#sql public iterator MyAsensitiveIter with（sensitivity = ASENSITIVE）（String ename，int empno）;</pre><p>此声明将<code class="codeph">MyAsensitiveIter</code>命名迭代器类的游标敏感性<code class="codeph">ASENSITIVE</code>为<code class="codeph">MyAsensitiveIter</code> 。
                           </p>
                           <p>以下示例使用<code class="codeph">implements</code>子句和<code class="codeph">with</code>子句：</p><pre class="oac_no_warn" dir="ltr">#sql public iterator MyScrollableIterator实现sqlj.runtime。Scrollable with（holdability = true）（String ename，int empno）;</pre><p>该声明实现了接口<code class="codeph">sqlj.runtime.Scrollable</code> ，使光标<code class="codeph">holdability</code>名为iterator类。
                           </p>
                           <div class="infoboxnote" id="GUID-40673A09-9276-406D-9170-6B936E0546BB__GUID-66133076-34EA-4F09-AE48-DB086DDE4443">
                              <p class="notep1">注意：</p>
                              <p><code class="codeph">holdability</code>目前<span class="italic">不</span>支持。
                              </p>
                           </div>
                        </div>
                        <!-- class="section" -->
                     </div>
                  </div><a id="JSQLJ280"></a><div class="props_rev_3"><a id="GUID-CE3C0979-706C-4BCE-91DE-D0EC5A46D4D6" name="GUID-CE3C0979-706C-4BCE-91DE-D0EC5A46D4D6"></a><h5 id="JSQLJ-GUID-CE3C0979-706C-4BCE-91DE-D0EC5A46D4D6" class="sect5">特定于Oracle的WITH子句用法</h5>
                     <div>
                        <p>除了在连接上下文声明中使用标准<code class="codeph">with</code>子句以将类型映射与连接上下文类相关联之外，Oracle SQLJ实现还允许您使用<code class="codeph">with</code>子句将类型映射与迭代器声明中的迭代器类相关联。例如：</p><pre class="oac_no_warn" dir="ltr">#sql iterator MyIterator with（typeMap =“MyTypeMap”）（Person pers，Address addr）;</pre><p>如果在应用程序中使用特定于Oracle的代码生成并使用类型映射，那么迭代器和连接上下文声明必须使用相同的类型映射。</p>
                        <div class="infoboxnotealso" id="GUID-CE3C0979-706C-4BCE-91DE-D0EC5A46D4D6__GUID-295EF242-FB89-42F8-90F3-AE7ABA8D4965">
                           <p class="notep1">也可以看看：</p>
                           <p><span class="q">“ <a href="key-programming-considerations.html#GUID-E4C877C3-6E29-4053-BA8F-D0694B5D4968">使用Oracle特定代码生成的代码注意事项和限制</a> ”</span></p>
                        </div>
                     </div>
                  </div><a id="JSQLJ281"></a><div class="props_rev_3"><a id="GUID-59D146A5-BCAE-4E68-91EC-C79417686CCF" name="GUID-59D146A5-BCAE-4E68-91EC-C79417686CCF"></a><h5 id="JSQLJ-GUID-59D146A5-BCAE-4E68-91EC-C79417686CCF" class="sect5">示例：可回收性</h5>
                     <div>
                        <p>在SQLJ迭代器声明的<code class="codeph">with</code>子句中使用<code class="codeph">returnability=true</code>指定迭代器可以作为REF CURSOR从Java存储过程返回到SQL或PL / SQL语句。使用默认的<code class="codeph">returnability=false</code>设置，不能以这种方式返回迭代器，并且尝试这样做将在运行时导致SQL异常。
                        </p>
                        <p>创建以下数据库表：</p><pre class="oac_no_warn" dir="ltr">create table sqljRetTab（str varchar2（30））;插入sqljRetTab值（'sqljRetTabCol'）;</pre><p>在<code class="codeph">RefCursorSQLJ.sqlj</code>源文件中定义<code class="codeph">RefCursorSQLJ</code>类，如下所示。请注意，迭代器类型<code class="codeph">MyIter</code>使用<code class="codeph">MyIter</code> <code class="codeph">returnability=true</code> 。
                        </p><pre class="oac_no_warn" dir="ltr">public class RefCursorSQLJ {#sql static public iterator MyIter with（returnability = true）（String str）; static public MyIter sqljUserRet（）抛出java.sql。SQLException {MyIter iter = null;尝试{#sql iter = {select str from sqljRetTab}; } catch（java.sql。SQLException e）{e.printStackTrace（）;扔掉; System.err.println（“iter is”+ iter）;归还它; }}</pre><p>将<code class="codeph">RefCursorSQLJ.sqlj</code>加载到数据库内的Oracle Java虚拟机（JVM）中，如下所示：</p><pre class="oac_no_warn" dir="ltr">％loadjava -u HR -r -f -v RefCursorSQLJ.sqlj密码： <span class="italic">密码</span>
</pre><p>调用为<code class="codeph">sqljUserRet()</code>方法定义的Java存储过程：</p><pre class="oac_no_warn" dir="ltr">创建或替换包refcur_pkg作为类型refcur_t是ref cursor;结束; / create或replace函数sqljUserRet返回refcur_pkg.refcur_t作为语言java名称'RefCursorSQLJ.sqljUserRet（）返回RefCursorSQLJ.MyIter'; /从双重选择HR.sqljUserRet;</pre><p>这是<code class="codeph">SELECT</code>语句的结果：</p><pre class="oac_no_warn" dir="ltr">SQLJRET1 --------------------游标声明：1 STR ------------------------ ------ sqljRetTabCol</pre></div>
                  </div>
               </div>
            </div><a id="JSQLJ282"></a><div class="props_rev_3"><a id="GUID-863A3FD5-C7DB-4032-9DE7-6721287C9579" name="GUID-863A3FD5-C7DB-4032-9DE7-6721287C9579"></a><h3 id="JSQLJ-GUID-863A3FD5-C7DB-4032-9DE7-6721287C9579" class="sect3">SQLJ可执行语句概述</h3>
               <div>
                  <p>SQLJ可执行语句由<code class="codeph">#sql</code>标记后跟SQLJ子句组成，该子句使用遵循指定标准的语法在Java代码中嵌入可执行SQL语句。SQLJ可执行语句的嵌入式SQL操作可以是JDBC驱动程序支持的任何SQL操作。
                  </p>
                  <p>本节包括以下主题：</p>
                  <ul style="list-style-type:disc">
                     <li>
                        <p><a href="basic-language-features.html#GUID-587C4F4D-48FC-41FE-9BC5-6B29DBDD8D97">SQLJ可执行语句的规则</a></p>
                     </li>
                     <li>
                        <p><a href="basic-language-features.html#GUID-220F9285-7EBE-4253-AA0C-901511567389">SQLJ条款</a></p>
                     </li>
                     <li>
                        <p><a href="basic-language-features.html#GUID-9F93C716-2C14-4AD0-B68F-EAC2CEDCDA60">指定连接上下文实例和执行上下文实例</a></p>
                     </li>
                     <li>
                        <p><a href="basic-language-features.html#GUID-18435E67-4949-46CE-9227-2F159D830774">可执行语句示例</a></p>
                     </li>
                     <li>
                        <p><a href="basic-language-features.html#GUID-F6528046-15F5-4A5B-9720-57BC82D4A13F">可执行语句中的PL / SQL块</a></p>
                     </li>
                  </ul>
               </div><a id="JSQLJ283"></a><div class="props_rev_3"><a id="GUID-587C4F4D-48FC-41FE-9BC5-6B29DBDD8D97" name="GUID-587C4F4D-48FC-41FE-9BC5-6B29DBDD8D97"></a><h4 id="JSQLJ-GUID-587C4F4D-48FC-41FE-9BC5-6B29DBDD8D97" class="sect4">SQLJ可执行语句的规则</h4>
                  <div>
                     <p>SQLJ可执行语句必须遵守以下规则：</p>
                     <ul style="list-style-type:disc">
                        <li>
                           <p>只要允许Java块语句，Java代码就允许使用它。也就是说，允许在方法定义和静态初始化块内部。</p>
                        </li>
                        <li>
                           <p>它的嵌入式SQL操作必须用大括号括起来： <code class="codeph">{...}</code> 。
                           </p>
                        </li>
                        <li>
                           <p>它必须以分号（;）结束。</p>
                        </li>
                     </ul>
                     <div class="infoboxnote" id="GUID-587C4F4D-48FC-41FE-9BC5-6B29DBDD8D97__GUID-3B39D53B-180B-4629-8150-C81B27F67E82">
                        <p class="notep1">注意：</p>
                        <ul style="list-style-type:disc">
                           <li>
                              <p>建议你<span class="italic">不要</span>用分号关闭SQL操作。解析器在遇到SQLJ子句的结束大括号时将检测操作的结束。
                              </p>
                           </li>
                           <li>
                              <p>SQLJ可执行语句的大括号内的所有内容都被视为SQL语法，并且必须遵循SQL规则，Java主机表达式除外。</p>
                           </li>
                           <li>
                              <p>在脱机解析SQL操作期间，将检查所有SQL语法。但是，在联机语义检查期间，只能解析和检查数据操作语言（DML）操作。无法解析和检查数据定义语言（DDL）操作，事务控制操作或任何其他类型的SQL操作。</p>
                           </li>
                        </ul>
                     </div>
                  </div>
               </div><a id="JSQLJ285"></a><a id="JSQLJ286"></a><a id="JSQLJ284"></a><div class="props_rev_3"><a id="GUID-220F9285-7EBE-4253-AA0C-901511567389" name="GUID-220F9285-7EBE-4253-AA0C-901511567389"></a><h4 id="JSQLJ-GUID-220F9285-7EBE-4253-AA0C-901511567389" class="sect4">SQLJ条款</h4>
                  <div>
                     <p>SQLJ子句是语句的可执行部分，由<code class="codeph">#sql</code>标记右侧的所有内容组成。这包括在花括号内嵌入的SQL，如果合适，在Java结果表达式之前，例如以下示例中的<code class="codeph">result</code> ：</p><pre class="oac_no_warn" dir="ltr">#sql { <span class="italic">SQL operation</span> }; //对于没有输出的语句，比如INSERT ......#sql <span class="italic">result</span> = { <span class="italic">SQL operation</span> }; //对于带有输出的语句，如SELECT</pre><p>没有结果表达式的子句（例如在示例中的第一个SQLJ语句中）称为语句子句。具有结果表达式的子句（例如在示例中的第二个SQLJ语句中）称为赋值子句。</p>
                     <p>结果表达式可以是从采用存储函数返回值的简单变量到从多行<code class="codeph">SELECT</code>获取多列数据的迭代器中的任何内容，其中迭代器可以是迭代器类或子类的实例。
                     </p>
                     <p>SQLJ语句中的SQL操作只能使用标准SQL语法，或者可以使用具有SQLJ特定语法的子句。</p>
                     <p>表1列出了受支持的SQLJ语句子句，表2列出了受支持的SQLJ赋值子句。<a href="basic-language-features.html#GUID-220F9285-7EBE-4253-AA0C-901511567389__CBBHFEGH" title="下表描述了各种SQLJ语句子句。">表5-1</a>中的最后两个条目是使用标准SQL语法或Oracle PL / SQL语法的语句子句的一般类别，而不是SQLJ特定的语法。
                     </p>
                     <div class="tblformal" id="GUID-220F9285-7EBE-4253-AA0C-901511567389__CBBHFEGH">
                        <p class="titleintable">表5-1 SQLJ语句子句</p>
                        <table cellpadding="4" cellspacing="0" class="Formal" title="SQLJ声明条款" width="100%" border="1" summary="The following table describes the various SQLJ Statement Clauses." frame="hsides" rules="rows">
                           <thead>
                              <tr align="left" valign="top">
                                 <th align="left" valign="bottom" width="27%" id="d14946e1254">类别</th>
                                 <th align="left" valign="bottom" width="30%" id="d14946e1257">功能</th>
                                 <th align="left" valign="bottom" width="43%" id="d14946e1260">更多信息</th>
                              </tr>
                           </thead>
                           <tbody>
                              <tr align="left" valign="top">
                                 <td align="left" valign="top" width="27%" id="d14946e1265" headers="d14946e1254 ">
                                    <p><code class="codeph">SELECT INTO</code>子句</p>
                                 </td>
                                 <td align="left" valign="top" width="30%" headers="d14946e1265 d14946e1257 ">
                                    <p>选择数据到Java主机表达式。</p>
                                 </td>
                                 <td align="left" valign="top" width="43%" headers="d14946e1265 d14946e1260 ">
                                    <p><span class="q">“ <a href="basic-language-features.html#GUID-E779CA66-DE27-48C8-A379-E793AF0FB280">单行查询结果：SELECT INTO语句</a> ”</span></p>
                                 </td>
                              </tr>
                              <tr align="left" valign="top">
                                 <td align="left" valign="top" width="27%" id="d14946e1280" headers="d14946e1254 ">
                                    <p><code class="codeph">FETCH</code>子句</p>
                                 </td>
                                 <td align="left" valign="top" width="30%" headers="d14946e1280 d14946e1257 ">
                                    <p>从位置迭代器获取数据。</p>
                                 </td>
                                 <td align="left" valign="top" width="43%" headers="d14946e1280 d14946e1260 ">
                                    <p><span class="q">“ <a href="basic-language-features.html#GUID-C99760AC-46A2-446C-8CA6-D032FC4C303D">使用位置迭代器</a> ”</span></p>
                                 </td>
                              </tr>
                              <tr align="left" valign="top">
                                 <td align="left" valign="top" width="27%" id="d14946e1295" headers="d14946e1254 ">
                                    <p><code class="codeph">COMMIT</code>子句</p>
                                 </td>
                                 <td align="left" valign="top" width="30%" headers="d14946e1295 d14946e1257 ">
                                    <p>提交对数据的更改。</p>
                                 </td>
                                 <td align="left" valign="top" width="43%" headers="d14946e1295 d14946e1260 ">
                                    <p><span class="q">“ <a href="key-programming-considerations.html#GUID-25F6527A-8A45-4679-868E-FB53CFFDB0B7">使用手动COMMIT和ROLLBACK</a> ”</span></p>
                                 </td>
                              </tr>
                              <tr align="left" valign="top">
                                 <td align="left" valign="top" width="27%" id="d14946e1310" headers="d14946e1254 ">
                                    <p><code class="codeph">ROLLBACK</code>子句</p>
                                 </td>
                                 <td align="left" valign="top" width="30%" headers="d14946e1310 d14946e1257 ">
                                    <p>取消对数据的更改。</p>
                                 </td>
                                 <td align="left" valign="top" width="43%" headers="d14946e1310 d14946e1260 ">
                                    <p><span class="q">“ <a href="key-programming-considerations.html#GUID-25F6527A-8A45-4679-868E-FB53CFFDB0B7">使用手动COMMIT和ROLLBACK</a> ”</span></p>
                                 </td>
                              </tr>
                              <tr align="left" valign="top">
                                 <td align="left" valign="top" width="27%" id="d14946e1325" headers="d14946e1254 ">
                                    <p><code class="codeph">SAVEPOINT RELEASE SAVEPOINT ROLLBACK TO</code>子句</p>
                                 </td>
                                 <td align="left" valign="top" width="30%" headers="d14946e1325 d14946e1257 ">
                                    <p>为将来的回滚设置保存点，释放指定的保存点，回滚到保存点。</p>
                                 </td>
                                 <td align="left" valign="top" width="43%" headers="d14946e1325 d14946e1260 ">
                                    <p><span class="q">“ <a href="key-programming-considerations.html#GUID-6A5E522A-4B6B-4B59-B644-85A45C82EDE5">使用保存点</a> ”</span></p>
                                 </td>
                              </tr>
                              <tr align="left" valign="top">
                                 <td align="left" valign="top" width="27%" id="d14946e1344" headers="d14946e1254 ">
                                    <p><code class="codeph">SET TRANSACTION</code>子句</p>
                                 </td>
                                 <td align="left" valign="top" width="30%" headers="d14946e1344 d14946e1257 ">
                                    <p>对访问模式和隔离级别使用高级事务控制。</p>
                                 </td>
                                 <td align="left" valign="top" width="43%" headers="d14946e1344 d14946e1260 ">
                                    <p><span class="q">“ <a href="advanced-language-features.html#GUID-3B7EEA7A-5E45-4455-8255-2A5C1334DAD8">高级交易控制</a> ”</span></p>
                                 </td>
                              </tr>
                              <tr align="left" valign="top">
                                 <td align="left" valign="top" width="27%" id="d14946e1359" headers="d14946e1254 ">
                                    <p>程序条款</p>
                                 </td>
                                 <td align="left" valign="top" width="30%" headers="d14946e1359 d14946e1257 ">
                                    <p>调用存储过程。</p>
                                 </td>
                                 <td align="left" valign="top" width="43%" headers="d14946e1359 d14946e1260 ">
                                    <p><span class="q">“ <a href="basic-language-features.html#GUID-CDDD7913-A445-4BB3-8193-1A3C75A577C5">调用存储过程</a> ”</span></p>
                                 </td>
                              </tr>
                              <tr align="left" valign="top">
                                 <td align="left" valign="top" width="27%" id="d14946e1372" headers="d14946e1254 ">
                                    <p>作业条款</p>
                                 </td>
                                 <td align="left" valign="top" width="30%" headers="d14946e1372 d14946e1257 ">
                                    <p>将值分配给Java主机表达式。</p>
                                 </td>
                                 <td align="left" valign="top" width="43%" headers="d14946e1372 d14946e1260 ">
                                    <p><span class="q">“ <a href="basic-language-features.html#GUID-74814900-4067-4EE0-B74B-A9A5F5DED86C">作业陈述（SET）</a> ”</span></p>
                                 </td>
                              </tr>
                              <tr align="left" valign="top">
                                 <td align="left" valign="top" width="27%" id="d14946e1385" headers="d14946e1254 ">
                                    <p>SQL子句</p>
                                 </td>
                                 <td align="left" valign="top" width="30%" headers="d14946e1385 d14946e1257 ">
                                    <p>使用标准SQL语法和功能： <code class="codeph">UPDATE</code> ， <code class="codeph">INSERT</code> ， <code class="codeph">DELETE</code> 。</p>
                                 </td>
                                 <td align="left" valign="top" width="43%" headers="d14946e1385 d14946e1260 ">
                                    <p>Oracle数据库SQL语言参考</p>
                                 </td>
                              </tr>
                              <tr align="left" valign="top">
                                 <td align="left" valign="top" width="27%" id="d14946e1404" headers="d14946e1254 ">
                                    <p>PL / SQL块</p>
                                 </td>
                                 <td align="left" valign="top" width="30%" headers="d14946e1404 d14946e1257 ">
                                    <p>使用<code class="codeph">BEGIN..END</code>或声明<code class="codeph">DECLARE..开始..在SQLJ语句中使用END</code>匿名块。
                                    </p>
                                 </td>
                                 <td align="left" valign="top" width="43%" headers="d14946e1404 d14946e1260 ">
                                    <p><span class="q">“ <a href="basic-language-features.html#GUID-F6528046-15F5-4A5B-9720-57BC82D4A13F">可执行语句中的PL / SQL块</a> ”</span></p>
                                    <p><a href="../sqlrf/Introduction-to-Oracle-SQL.html#GUID-049B7AE8-11E1-4110-B3E4-D117907D77AC" target="_blank"><span class="italic">Oracle数据库PL / SQL语言参考</span></a></p>
                                 </td>
                              </tr>
                           </tbody>
                        </table>
                     </div>
                     <!-- class="inftblhruleinformal" -->
                     <div class="tblformal" id="GUID-220F9285-7EBE-4253-AA0C-901511567389__CBBFCJBJ">
                        <p class="titleintable">表5-2 SQLJ分配子句</p>
                        <table cellpadding="4" cellspacing="0" class="Formal" title="SQLJ赋值子句" width="100%" border="1" summary="summary" frame="hsides" rules="rows">
                           <thead>
                              <tr align="left" valign="top">
                                 <th align="left" valign="bottom" width="26%" id="d14946e1438">类别</th>
                                 <th align="left" valign="bottom" width="29%" id="d14946e1441">功能</th>
                                 <th align="left" valign="bottom" width="45%" id="d14946e1444">更多信息</th>
                              </tr>
                           </thead>
                           <tbody>
                              <tr align="left" valign="top">
                                 <td align="left" valign="top" width="26%" id="d14946e1449" headers="d14946e1438 ">
                                    <p>查询条款</p>
                                 </td>
                                 <td align="left" valign="top" width="29%" headers="d14946e1449 d14946e1441 ">
                                    <p>将数据选择到SQLJ迭代器中。</p>
                                 </td>
                                 <td align="left" valign="top" width="45%" headers="d14946e1449 d14946e1444 ">
                                    <p><span class="q">“多<a href="basic-language-features.html#GUID-C6E5904A-2D17-40EA-9DF2-AD5BCEA58E2D">行查询结果：SQLJ迭代器</a> ”</span></p>
                                 </td>
                              </tr>
                              <tr align="left" valign="top">
                                 <td align="left" valign="top" width="26%" id="d14946e1462" headers="d14946e1438 ">
                                    <p>功能条款</p>
                                 </td>
                                 <td align="left" valign="top" width="29%" headers="d14946e1462 d14946e1441 ">
                                    <p>调用存储的函数。</p>
                                 </td>
                                 <td align="left" valign="top" width="45%" headers="d14946e1462 d14946e1444 ">
                                    <p><span class="q">“ <a href="basic-language-features.html#GUID-18E7A8FC-D16A-4A57-9A9E-B85919E9160D">调用存储函数</a> ”</span></p>
                                 </td>
                              </tr>
                              <tr align="left" valign="top">
                                 <td align="left" valign="top" width="26%" id="d14946e1475" headers="d14946e1438 ">
                                    <p>迭代器转换条款</p>
                                 </td>
                                 <td align="left" valign="top" width="29%" headers="d14946e1475 d14946e1441 ">
                                    <p>将JDBC结果集转换为SQLJ迭代器。</p>
                                 </td>
                                 <td align="left" valign="top" width="45%" headers="d14946e1475 d14946e1444 ">
                                    <p><span class="q">“ <a href="advanced-language-features.html#GUID-76329A99-A510-4BEB-8271-46F689A10D2D__I1007234">从结果集转换为命名或位置迭代器</a> ”</span></p>
                                 </td>
                              </tr>
                           </tbody>
                        </table>
                     </div>
                     <!-- class="inftblhruleinformal" -->
                     <div class="infoboxnote" id="GUID-220F9285-7EBE-4253-AA0C-901511567389__GUID-6A6AF323-2553-452A-A00E-FC91EFE4F30C">
                        <p class="notep1">注意：</p>
                        <p>SQLJ语句的名称与构成该语句主体的子句的名称相同。例如，由<code class="codeph">#sql</code>后跟<code class="codeph">SELECT INTO</code>子句组成的可执行语句称为<code class="codeph">SELECT INTO</code>语句。
                        </p>
                     </div>
                  </div>
               </div><a id="JSQLJ287"></a><div class="props_rev_3"><a id="GUID-9F93C716-2C14-4AD0-B68F-EAC2CEDCDA60" name="GUID-9F93C716-2C14-4AD0-B68F-EAC2CEDCDA60"></a><h4 id="JSQLJ-GUID-9F93C716-2C14-4AD0-B68F-EAC2CEDCDA60" class="sect4">指定连接上下文实例和执行上下文实例</h4>
                  <div>
                     <div class="section">
                        <p>如果已定义多个数据库连接并希望为可执行语句指定特定连接上下文实例，则使用以下语法：</p><pre class="oac_no_warn" dir="ltr">#sql [ <span class="italic">conn_context_instance</span> ] { <span class="italic">SQL operation</span> };</pre><p>如果已定义<code class="codeph">sqlj.runtime.一个或多个执行上下文实例<code class="codeph">sqlj.runtime.ExecutionContext</code>类，并希望指定其中一个用于可执行语句，然后使用以下语法：</p><pre class="oac_no_warn" dir="ltr">#sql [ <span class="italic">exec_context_instance</span> ] { <span class="italic">SQL operation</span> };</pre><p>您可以使用执行上下文实例来提供SQLJ可执行语句的SQL操作的状态或控制。例如，您可以在多线程情况下使用执行上下文实例，其中在同一连接上发生多个操作。</p>
                        <p>您还可以指定连接上下文实例和执行上下文实例：</p><pre class="oac_no_warn" dir="ltr">#sql [ <span class="italic">conn_context_instance</span> ， <span class="italic">exec_context_instance</span> ] { <span class="italic">SQL operation</span> };</pre><div class="infoboxnote" id="GUID-9F93C716-2C14-4AD0-B68F-EAC2CEDCDA60__GUID-5CC4BDCF-C688-4DD6-83CD-DEA0DF4B3063">
                           <p class="notep1">注意：</p>
                           <ul style="list-style-type:disc">
                              <li>
                                 <p>在连接上下文实例和执行上下文实例周围包括方括号。它们是语法的一部分。</p>
                              </li>
                              <li>
                                 <p>如果同时指定连接上下文实例和执行上下文实例，则必须首先连接上下文实例。</p>
                              </li>
                           </ul>
                        </div>
                     </div>
                     <!-- class="section" -->
                  </div>
               </div><a id="JSQLJ289"></a><a id="JSQLJ290"></a><a id="JSQLJ291"></a><a id="JSQLJ288"></a><div class="props_rev_3"><a id="GUID-18435E67-4949-46CE-9227-2F159D830774" name="GUID-18435E67-4949-46CE-9227-2F159D830774"></a><h4 id="JSQLJ-GUID-18435E67-4949-46CE-9227-2F159D830774" class="sect4">可执行语句示例</h4>
                  <div>
                     <p>本节提供了基本SQLJ可执行语句的示例。</p>
                     <div class="section">
                        <p class="subhead3" id="GUID-18435E67-4949-46CE-9227-2F159D830774__GUID-0DC777D5-3F22-479C-A332-D9F7E0B206EE">初级INSERT</p>
                     </div>
                     <!-- class="section" -->
                     <div class="section">
                        <p>以下示例演示了一个基本的<code class="codeph">INSERT</code> 。声明子句不需要任何特定于SQLJ的语法。</p>
                        <p>考虑具有以下行的员工表<code class="codeph">EMP</code> ：</p><pre class="oac_no_warn" dir="ltr">CREATE TABLE EMP（ENAME VARCHAR2（10），SAL NUMBER（7,2））;</pre><p>使用以下仅使用标准SQL语法的SQLJ可执行语句将Joe作为新员工插入<code class="codeph">EMP</code>表，并指定其名称和薪水：</p><pre class="oac_no_warn" dir="ltr">#sql {INSERT INTO emp（ename，sal）VALUES（'Joe'，43000）};</pre></div>
                     <!-- class="section" -->
                     <div class="section">
                        <p class="subhead3" id="GUID-18435E67-4949-46CE-9227-2F159D830774__GUID-007BAA27-433E-4788-9CAB-B279CB77D21F">具有连接上下文或执行上下文实例的基本INSERT</p>
                     </div>
                     <!-- class="section" -->
                     <div class="section">
                        <p>以下示例使用<code class="codeph">ctx</code>作为连接上下文实例，它是默认<code class="codeph">sqlj.runtime.ref.的实例<code class="codeph">sqlj.runtime.ref.DefaultContext</code>或先前在连接上下文声明中声明的类，以及<code class="codeph">execctx</code>作为执行上下文实例：</p><pre class="oac_no_warn" dir="ltr">#sql [ctx] {INSERT INTO emp（ename，sal）VALUES（'Joe'，43000）}; #sql [execctx] {INSERT INTO emp（ename，sal）VALUES（'Joe'，43000）}; #sql [ctx，execctx] {INSERT INTO emp（ename，sal）VALUES（'Joe'，43000）};</pre></div>
                     <!-- class="section" -->
                     <div class="section">
                        <p class="subhead3" id="GUID-18435E67-4949-46CE-9227-2F159D830774__GUID-EA7C2D1B-03FF-4257-B7B5-031F7FE51753">一个简单的SQLJ方法</p>
                     </div>
                     <!-- class="section" -->
                     <div class="section">
                        <p>此示例演示了一个使用SQLJ代码的简单方法，演示了SQLJ语句如何与Java语句相互关联并散布在其中。SQLJ语句使用Oracle SQL实现支持的标准<code class="codeph">INSERT INTO</code> <span class="italic"><code class="codeph">table</code></span> <code class="codeph">VALUES</code>语法。该语句还使用以冒号（:)标记的Java主机表达式来定义值。主机表达式用于在Java代码和SQL指令之间传递数据。
                        </p><pre class="oac_no_warn" dir="ltr">public static void writeSalesData（int [] itemNums，String [] itemNames）抛出SQLException {for（int i = 0; i &lt;itemNums.length; i ++）#sql {INSERT INTO sales VALUES（:( itemNums [i]）,: （itemNames [i]），SYSDATE）}; }</pre><div class="infoboxnote" id="GUID-18435E67-4949-46CE-9227-2F159D830774__GUID-A509F578-D7E6-43CF-8DBE-47C9BC56A4A6">
                           <p class="notep1">注意：</p>
                           <ul style="list-style-type:disc">
                              <li>
                                 <p><code class="codeph">throws SQLException</code> <span class="italic">是</span>必需的。
                                 </p>
                              </li>
                              <li>
                                 <p>SQLJ函数调用也使用<code class="codeph">VALUES</code>标记，但这些情况在语义上不相关。
                                 </p>
                              </li>
                           </ul>
                        </div>
                     </div>
                     <!-- class="section" -->
                  </div>
               </div><a id="JSQLJ292"></a><div class="props_rev_3"><a id="GUID-F6528046-15F5-4A5B-9720-57BC82D4A13F" name="GUID-F6528046-15F5-4A5B-9720-57BC82D4A13F"></a><h4 id="JSQLJ-GUID-F6528046-15F5-4A5B-9720-57BC82D4A13F" class="sect4">可执行语句中的PL / SQL块</h4>
                  <div>
                     <p>正如SQL操作一样，PL / SQL块可以在SQLJ可执行语句的花括号中使用，如下例所示：</p><pre class="oac_no_warn" dir="ltr">#sql {DECLARE n NUMBER;开始n：= 1;当n &lt;= 100 LOOP INSERT INTO emp（empno）VALUES（2000 + n）; n：= n + 1;结束循环;结束 };</pre><p>此示例通过循环在<code class="codeph">emp</code>表中插入新员工，创建员工编号<code class="codeph">2001</code>到<code class="codeph">2100</code> 。它假定员工编号以外的数据将在以后填写。
                     </p>
                     <p>简单的PL / SQL块也可以在一行中编码，如下所示：</p><pre class="oac_no_warn" dir="ltr">#sql {&lt;DECLARE ...&gt; BEGIN ......结束; };</pre><p>在SQLJ语句中使用PL / SQL匿名块是在应用程序中使用动态SQL的一种方法。您还可以通过Oracle提供的SQLJ扩展或SQLJ应用程序中的JDBC代码直接使用动态SQL。</p>
                     <div class="infoboxnotealso" id="GUID-F6528046-15F5-4A5B-9720-57BC82D4A13F__GUID-77D881AD-AE1A-47D6-A8D3-C4AC57DFE361">
                        <p class="notep1">也可以看看：</p>
                        <p><span class="q">“ <a href="advanced-language-features.html#GUID-1A237022-5F1E-4C29-87D3-8E913F59C3FA">支持动态SQL</a> ”</span>和<span class="q">“ <a href="advanced-language-features.html#GUID-8AF6CBB6-D6B3-44AB-99D5-5ADF6495E568">SQLJ和JDBC互操作性</a> ”</span></p>
                     </div>
                     <div class="infoboxnote" id="GUID-F6528046-15F5-4A5B-9720-57BC82D4A13F__GUID-ECEA8F47-063C-4110-80B3-8D7BB304F2CA">
                        <p class="notep1">注意：</p>
                        <p>请记住，在SQLJ代码中使用PL / SQL会阻止其他平台的可移植性，因为PL / SQL是特定于Oracle的。</p>
                     </div>
                  </div>
               </div>
            </div><a id="JSQLJ293"></a><div class="props_rev_3"><a id="GUID-7B85631F-98E1-4A9A-BBC1-181A53D0D03D" name="GUID-7B85631F-98E1-4A9A-BBC1-181A53D0D03D"></a><h3 id="JSQLJ-GUID-7B85631F-98E1-4A9A-BBC1-181A53D0D03D" class="sect3">Java主机，上下文和结果表达式</h3>
               <div>
                  <p>本节讨论SQLJ代码中使用的三类Java表达式：主机表达式，上下文表达式和结果表达式。主机表达式是最常用的Java表达式。另一类表达式称为元绑定表达式，专门用于动态SQL操作，并使用类似于主机表达式的语法。</p>
                  <div class="infoboxnotealso" id="GUID-7B85631F-98E1-4A9A-BBC1-181A53D0D03D__GUID-8D540532-3EA5-4911-AEB9-C691C877B93F">
                     <p class="notep1">也可以看看：</p>
                     <p><span class="q">“ <a href="advanced-language-features.html#GUID-1A237022-5F1E-4C29-87D3-8E913F59C3FA">支持动态SQL</a> ”</span></p>
                  </div>
                  <p>SQLJ使用Java主机表达式在Java代码和SQL操作之间传递参数。这是您在Java和SQL之间传递信息的方式。主机表达式散布在SQLJ源代码中的嵌入式SQL操作中。</p>
                  <p>最基本的主机表达式，仅由Java标识符组成，称为主机变量。上下文表达式指定要用于SQLJ语句的连接上下文实例或执行上下文实例。结果表达式指定查询结果或函数返回的输出变量。</p>
                  <p>本节包括以下主题：</p>
                  <ul style="list-style-type:disc">
                     <li>
                        <p><a href="basic-language-features.html#GUID-F0DDF3C8-67A5-421E-A247-5318A74A6315">主机表达概述</a></p>
                     </li>
                     <li>
                        <p><a href="basic-language-features.html#GUID-C3594B6E-CF2F-4020-B995-314E9957E520">基本主机表达式语法</a></p>
                     </li>
                     <li>
                        <p><a href="basic-language-features.html#GUID-25BF2A93-76D4-4232-96BD-8BC80F9B7386">主机表达的示例</a></p>
                     </li>
                     <li>
                        <p><a href="basic-language-features.html#GUID-E2AFA583-2CEB-4EC3-9C13-BA21BFEBDD52">结果表达式和上下文表达式概述</a></p>
                     </li>
                     <li>
                        <p><a href="basic-language-features.html#GUID-B76F8910-AA7B-4DF0-B470-02E27829862E">在运行时评估Java表达式</a></p>
                     </li>
                     <li>
                        <p><a href="basic-language-features.html#GUID-A06DF3CD-7BB2-42FC-A01E-3B6A5C5AE60F">在运行时评估Java表达式的示例（ISO代码生成）</a></p>
                     </li>
                     <li>
                        <p><a href="basic-language-features.html#GUID-AE6CB258-0865-40BB-AC83-7057FC1798F7">主机表达式的限制</a></p>
                     </li>
                  </ul>
               </div><a id="JSQLJ294"></a><div class="props_rev_3"><a id="GUID-F0DDF3C8-67A5-421E-A247-5318A74A6315" name="GUID-F0DDF3C8-67A5-421E-A247-5318A74A6315"></a><h4 id="JSQLJ-GUID-F0DDF3C8-67A5-421E-A247-5318A74A6315" class="sect4">主机表达概述</h4>
                  <div>
                     <p>任何有效的Java表达式都可以用作宿主表达式。在最简单的情况下，表达式只包含一个Java变量。其他类型的主机表达式包括以下内容：</p>
                     <ul style="list-style-type:disc">
                        <li>
                           <p>算术表达式</p>
                        </li>
                        <li>
                           <p>Java方法调用返回值</p>
                        </li>
                        <li>
                           <p>Java类字段值</p>
                        </li>
                        <li>
                           <p>数组元素</p>
                        </li>
                        <li>
                           <p>条件表达式（ <code class="codeph">a ?b : c</code> ）</p>
                        </li>
                        <li>
                           <p>逻辑表达式</p>
                        </li>
                        <li>
                           <p>按位表达式</p>
                        </li>
                     </ul>
                     <p>用作主机变量或主机表达式的Java标识符可表示以下任何一种：</p>
                     <ul style="list-style-type:disc">
                        <li>
                           <p>局部变量</p>
                        </li>
                        <li>
                           <p>声明的参数</p>
                        </li>
                        <li>
                           <p>类字段</p>
                        </li>
                        <li>
                           <p>静态或实例方法调用</p>
                        </li>
                     </ul>
                     <p>可以在任何可以声明其他Java变量的地方声明主机表达式中使用的局部变量。字段可以从超类继承。</p>
                     <p>出现SQLJ可执行语句的Java作用域中合法的Java变量可以在SQL语句的主表达式中使用，假设其类型可以转换为SQL数据类型或从SQL数据类型转换。主机表达式可以是输入，输出或输入输出。</p>
                     <div class="infoboxnotealso" id="GUID-F0DDF3C8-67A5-421E-A247-5318A74A6315__GUID-87DE464E-FB49-4E4D-9AF1-A0FBE98DFFA9">
                        <p class="notep1">也可以看看：</p>
                        <p><span class="q">“ <a href="type-support.html#GUID-81FC46CA-8D0E-43F8-BD02-F9AA31625DEC">主机表达式支持的类型</a> ”</span></p>
                     </div>
                  </div>
               </div><a id="JSQLJ296"></a><a id="JSQLJ297"></a><a id="JSQLJ295"></a><div class="props_rev_3"><a id="GUID-C3594B6E-CF2F-4020-B995-314E9957E520" name="GUID-C3594B6E-CF2F-4020-B995-314E9957E520"></a><h4 id="JSQLJ-GUID-C3594B6E-CF2F-4020-B995-314E9957E520" class="sect4">基本主机表达式语法</h4>
                  <div>
                     <p>主机表达式前面有冒号（:)。如果主机表达式的所需模式不是默认模式，则必须在主机表达式本身之前根据需要将冒号后跟<code class="codeph">IN</code> ， <code class="codeph">OUT</code>或<code class="codeph">INOUT</code> 。这些被称为模式说明符。如果主机表达式是<code class="codeph">INTO</code> -list的一部分或者是<code class="codeph">SET</code>语句中的赋值表达式，则缺省值为<code class="codeph">OUT</code> 。否则，默认值为<code class="codeph">IN</code> 。任何<code class="codeph">OUT</code>或<code class="codeph">INOUT</code>主机表达式都必须是可分配的。
                     </p>
                     <div class="infoboxnote" id="GUID-C3594B6E-CF2F-4020-B995-314E9957E520__GUID-45F79AB9-9714-4E42-AF4B-F95D201EB1F8">
                        <p class="notep1">注意：</p>
                        <p>使用默认值时，如果需要，仍可以包含模式说明符。</p>
                     </div>
                     <p>围绕主机表达式的SQL代码可以使用任何特定于供应商的SQL语法。因此，在解析SQL操作和确定主机表达式时，不能对语法做出任何假设。为避免任何可能的歧义，任何不是简单主机变量的宿主表达式（换句话说，比非指定Java标识符更复杂）必须括在括号中。</p>
                     <p>总结一下基本语法：</p>
                     <ul style="list-style-type:disc">
                        <li>
                           <p>对于没有模式说明符的简单主变量，将主变量放在冒号后面，如下例所示：</p><pre class="oac_no_warn" dir="ltr">：hostvar</pre></li>
                        <li>
                           <p>对于具有模式说明符的简单主变量，将模式说明符放在冒号后面，并在模式说明符和主变量之间放置空格（空格，制表符，换行符或注释），如下例所示：</p><pre class="oac_no_warn" dir="ltr">：INOUT hostvar</pre><p>需要使用空格来区分模式说明符和变量名称。</p>
                        </li>
                        <li>
                           <p>对于任何其他主机表达式，将表达式括在括号中并将其放在模式说明符之后或冒号之后（如果没有模式说明符），如以下示例所示：</p><pre class="oac_no_warn" dir="ltr">：IN（hostvar1 + hostvar2）:( hostvar3 * hostvar4）:( index--）</pre><p>在此示例中的模式说明符之后不需要空格，因为括号是合适的分隔符。但是，允许使用模式说明符后的空格。</p>
                           <p>即使表达式已经以开始括号开头，也需要一组外部圆括号，如下例所示：</p><pre class="oac_no_warn" dir="ltr">：（（x + y）.z）:(（（y）x）。myOutput（））</pre></li>
                     </ul>
                     <div class="section">
                        <p class="subhead3" id="GUID-C3594B6E-CF2F-4020-B995-314E9957E520__GUID-13720975-2C30-445C-9A36-3C2726763CBA">语法注释</p>
                     </div>
                     <!-- class="section" -->
                     <div class="section">
                        <p>关于主机表达式语法，请记住以下几点：</p>
                        <ul style="list-style-type:disc">
                           <li>
                              <p>在冒号之后以及在模式说明符之后总是允许空格。只要允许空白区域，您也可以发表评论。</p>
                              <p>您可以在SQL命名空间中具有以下任何内容：</p>
                              <ul style="list-style-type:disc">
                                 <li>
                                    <p>冒号后面和模式说明符之前的SQL注释</p>
                                 </li>
                                 <li>
                                    <p>如果没有模式说明符，冒号后和主机表达式之前的SQL注释</p>
                                 </li>
                                 <li>
                                    <p>模式说明符之后和主机表达式之前的SQL注释</p>
                                 </li>
                              </ul>
                              <p>您可以在Java命名空间中具有以下内容：</p>
                              <ul style="list-style-type:disc">
                                 <li>
                                    <p>主机表达式中的Java注释（括号内）</p>
                                 </li>
                              </ul>
                           </li>
                           <li>
                              <p>用于主机变量和表达式的<code class="codeph">IN</code> ， <code class="codeph">OUT</code>和<code class="codeph">INOUT</code>语法不区分大小写。这些令牌可以是大写，小写或混合。
                              </p>
                           </li>
                           <li>
                              <p>不要将SQLJ主机表达式的<code class="codeph">IN</code> ， <code class="codeph">OUT</code>和<code class="codeph">INOUT</code>语法与PL / SQL声明中使用的类似<code class="codeph">IN</code> ， <code class="codeph">OUT</code>和<code class="codeph">IN OUT</code>语法混淆，以指定传递给PL / SQL存储函数和过程的参数模式。
                              </p>
                           </li>
                        </ul>
                     </div>
                     <!-- class="section" -->
                     <div class="section">
                        <p class="subhead3" id="GUID-C3594B6E-CF2F-4020-B995-314E9957E520__GUID-B4A1CD99-81BB-4310-83DC-55A2DE77C32E">使用说明</p>
                     </div>
                     <!-- class="section" -->
                     <div class="section">
                        <p>关于主机表达式的使用，请记住以下几点：</p>
                        <ul style="list-style-type:disc">
                           <li>
                              <p>一个简单的宿主变量可以在同一个SQLJ语句中多次出现，如下所示：</p>
                              <ul style="list-style-type:disc">
                                 <li>
                                    <p>如果主变量仅作为输入变量出现，则没有限制或复杂性。</p>
                                 </li>
                                 <li>
                                    <p>如果主机变量的至少一个外观作为PL / SQL块中的输出变量，那么如果设置了translator <code class="codeph">-warn=portability</code>标志，则会收到可移植性警告。在这种情况下，SQLJ运行时行为是特定于供应商的。对于所有出现的主机变量，Oracle SQLJ运行时使用值语义而不是引用语义。
                                    </p>
                                 </li>
                                 <li>
                                    <p>如果主变量的至少一个外观在存储过程调用，存储函数调用， <code class="codeph">SET</code>语句或<code class="codeph">INTO</code> -list中作为输出变量，那么您将<span class="italic">不会</span>收到任何警告。在这种情况下，SQLJ运行时行为是使用值语义标准化的。
                                    </p>
                                 </li>
                              </ul>
                              <div class="infoboxnote" id="GUID-C3594B6E-CF2F-4020-B995-314E9957E520__GUID-2E0FEE89-60BF-44F0-8947-92E4C7FDE50B">
                                 <p class="notep1">注意：</p>
                                 <p>如果适用，术语输出指的是<code class="codeph">OUT</code>或<code class="codeph">INOUT</code>变量。
                                 </p>
                              </div>
                           </li>
                           <li>
                              <p>如果作为简单主机变量的主机表达式在SQLJ语句中多次出现，则默认情况下，使用值语义完全独立于其他外观处理每个外观。但是，如果使用SQLJ转换器<code class="codeph">-bind-by-identifier=true</code>设置，则情况并非如此。使用<code class="codeph">true</code>设置，给定SQLJ语句或PL / SQL块中同一主机变量的多次出现将被视为单个绑定事件。
                              </p>
                           </li>
                           <li>
                              <p>将字符串宿主表达式绑定到<code class="codeph">WHERE</code>子句以与<code class="codeph">CHAR</code>数据进行比较时，请注意有一个SQLJ选项<code class="codeph">-fixedchar</code> ，它在进行比较时考虑<code class="codeph">CHAR</code>列中的空白填充。
                              </p>
                           </li>
                        </ul>
                     </div>
                     <!-- class="section" -->
                  </div>
               </div><a id="JSQLJ299"></a><a id="JSQLJ300"></a><a id="JSQLJ301"></a><a id="JSQLJ302"></a><a id="JSQLJ298"></a><div class="props_rev_3"><a id="GUID-25BF2A93-76D4-4232-96BD-8BC80F9B7386" name="GUID-25BF2A93-76D4-4232-96BD-8BC80F9B7386"></a><h4 id="JSQLJ-GUID-25BF2A93-76D4-4232-96BD-8BC80F9B7386" class="sect4">主机表达的示例</h4>
                  <div>
                     <div class="section">
                        <p>以下示例将有助于阐明前面的语法讨论。</p>
                        <div class="infoboxnote" id="GUID-25BF2A93-76D4-4232-96BD-8BC80F9B7386__GUID-58FFC95E-D8BA-4972-9BD6-4DF99A18063D">
                           <p class="notep1">注意：</p>
                           <p>其中一些示例使用<code class="codeph">SELECT INTO</code>语句，这些语句在<span class="q">“ <a href="basic-language-features.html#GUID-E779CA66-DE27-48C8-A379-E793AF0FB280">单行查询结果：SELECT INTO语句</a> ”中描述</span> 。
                           </p>
                        </div>
                     </div>
                     <!-- class="section" -->
                     <div class="section">
                        <p class="subhead3" id="GUID-25BF2A93-76D4-4232-96BD-8BC80F9B7386__GUID-2AB8820C-1B3F-4E50-9A6F-8036E0D056CF">例1</p>
                     </div>
                     <!-- class="section" -->
                     <div class="section">
                        <p>在此示例中，使用了两个输入主机变量，一个作为<code class="codeph">WHERE</code>子句的测试值，另一个包含要发送到数据库的新数据。
                        </p>
                        <p>假设您有一个数据库员工表<code class="codeph">emp</code>其中包含员工姓名的<code class="codeph">ename</code>列和员工工资的<code class="codeph">sal</code>列。定义主机变量的相关Java代码如下：</p><pre class="oac_no_warn" dir="ltr">String empname =“SMITH”;双薪= 25000.0; ...#sql {UPDATE \ temp SET sal =：salary WHERE ename =：empname};</pre><p><code class="codeph">IN</code>是默认值，但您也可以明确说明：</p><pre class="oac_no_warn" dir="ltr">#sql {UPDATE \ temp SET sal =：IN薪水WHERE ename =：IN empname};</pre><p>如您所见，冒号（:)可以在不使用<code class="codeph">IN</code>标记时紧接在变量之前，但是<code class="codeph">:IN</code>必须在主变量之前跟随空格。
                        </p>
                     </div>
                     <!-- class="section" -->
                     <div class="section">
                        <p class="subhead3" id="GUID-25BF2A93-76D4-4232-96BD-8BC80F9B7386__GUID-8C86474E-8248-4EE5-8D33-FF5EF1E0145D">例2</p>
                     </div>
                     <!-- class="section" -->
                     <div class="section">
                        <p>此示例在<code class="codeph">SELECT INTO</code>语句中使用输出主机变量，您要在其中查找员工编号为28959的员工的姓名。
                        </p><pre class="oac_no_warn" dir="ltr">字符串empname; ...#sql {SELECT ename INTO：empname FROM emp WHERE empno = 28959};</pre><p><code class="codeph">OUT</code>是<code class="codeph">INTO</code> -list的默认值，但您也可以明确说明：</p><pre class="oac_no_warn" dir="ltr">#sql {SELECT ename INTO：OUT empname FROM emp WHERE empno = 28959};</pre><p>此语句在<code class="codeph">emp</code>表的<code class="codeph">empno</code>列中查找员工编号28959，在该行的<code class="codeph">ename</code>列中选择该名称，并将其输出到<code class="codeph">empname</code>输出主机变量（即Java <code class="codeph">String</code> 。
                        </p>
                     </div>
                     <!-- class="section" -->
                     <div class="section">
                        <p class="subhead3" id="GUID-25BF2A93-76D4-4232-96BD-8BC80F9B7386__GUID-3A31F19A-99D5-4DA5-92AA-19308CCE64E5">例3</p>
                     </div>
                     <!-- class="section" -->
                     <div class="section">
                        <p>此示例使用算术表达式作为输入主机表达式。Java变量<code class="codeph">balance</code>和<code class="codeph">minPmtRatio</code>相乘，结果用于更新<code class="codeph">creditacct</code>表的<code class="codeph">minPayment</code>列，帐号为537845。
                        </p><pre class="oac_no_warn" dir="ltr">浮动余额= 12500.0; float minPmtRatio = 0.05; ...#sql {UPDATE creditacct SET minPayment = :( balance * minPmtRatio）WHERE acctnum = 537845};</pre><p>或者，要使用<code class="codeph">IN</code>令牌：</p><pre class="oac_no_warn" dir="ltr">#sql {UPDATE creditacct SET minPayment =：IN（balance * minPmtRatio）WHERE acctnum = 537845};</pre></div>
                     <!-- class="section" -->
                     <div class="section">
                        <p class="subhead3" id="GUID-25BF2A93-76D4-4232-96BD-8BC80F9B7386__GUID-27F0ECC2-3C66-4DBD-BB05-B5AF6CAB9797">例4</p>
                     </div>
                     <!-- class="section" -->
                     <div class="section">
                        <p>此示例显示将方法调用的输出用作输入主机表达式，并使用输入主机变量。此语句使用<code class="codeph">getNewSal()</code>返回的值来更新<code class="codeph">emp</code>表中由<code class="codeph">sal</code> <code class="codeph">empname</code>变量指定的员工的<code class="codeph">sal</code>列。还显示了初始化主机变量的Java代码。
                        </p><pre class="oac_no_warn" dir="ltr">String empname =“SMITH”; double raise = 0.1; ...#sql {UPDATE \ temp SET sal = :( getNewSal（raise，empname））WHERE ename =：empname};</pre></div>
                     <!-- class="section" -->
                  </div>
               </div><a id="JSQLJ303"></a><div class="props_rev_3"><a id="GUID-E2AFA583-2CEB-4EC3-9C13-BA21BFEBDD52" name="GUID-E2AFA583-2CEB-4EC3-9C13-BA21BFEBDD52"></a><h4 id="JSQLJ-GUID-E2AFA583-2CEB-4EC3-9C13-BA21BFEBDD52" class="sect4">结果表达式和上下文表达式概述</h4>
                  <div>
                     <p>上下文表达式是一个输入表达式，它指定要在SQLJ可执行语句中使用的连接上下文实例的名称或执行上下文实例。可以使用任何产生这种名称的合法Java表达式。</p>
                     <p>结果表达式是用于查询结果或函数返回的输出表达式。它可以是任何可分配的合法Java表达式，这意味着它可以在逻辑上出现在等号的左侧。这有时被称为l值。</p>
                     <p>以下示例可用于结果表达式或上下文表达式：</p>
                     <ul style="list-style-type:disc">
                        <li>
                           <p>局部变量</p>
                        </li>
                        <li>
                           <p>声明的参数</p>
                        </li>
                        <li>
                           <p>类字段</p>
                        </li>
                        <li>
                           <p>数组元素</p>
                        </li>
                     </ul>
                     <p>结果表达式和上下文表达式在SQLJ空间中以词汇方式出现，与主机表达式不同，后者在SQL空间中以词法方式出现，即在SQLJ可执行语句的大括号内。因此，结果表达式或上下文表达式<span class="italic">不能</span>以冒号开头。
                     </p>
                  </div>
               </div><a id="JSQLJ304"></a><div class="props_rev_3"><a id="GUID-B76F8910-AA7B-4DF0-B470-02E27829862E" name="GUID-B76F8910-AA7B-4DF0-B470-02E27829862E"></a><h4 id="JSQLJ-GUID-B76F8910-AA7B-4DF0-B470-02E27829862E" class="sect4">在运行时评估Java表达式</h4>
                  <div>
                     <p>本节讨论在应用程序执行时对Java主机表达式，连接上下文表达式，执行上下文表达式和结果表达式的评估。</p>
                     <p>以下是使用所有这些表达式的SQLJ可执行语句的简化表示：</p><pre class="oac_no_warn" dir="ltr">#sql [ <span class="italic">connctxt_exp</span> ， <span class="italic">execctxt_exp</span> ] <span class="italic">result_exp</span> = { <span class="italic">带主机表达式的</span> <span class="italic">SQL</span> };</pre><p>根据需要，Java表达式可以用作以下任何一种：</p>
                     <ul style="list-style-type:disc">
                        <li>
                           <p>连接上下文表达式：已计算以指定要使用的连接上下文实例</p>
                        </li>
                        <li>
                           <p>执行上下文表达式：已计算以指定要使用的执行上下文实例</p>
                        </li>
                        <li>
                           <p>结果表达式：例如，从存储的函数接收结果</p>
                        </li>
                        <li>
                           <p>主持人表达</p>
                        </li>
                     </ul>
                     <p>对于ISO标准代码生成，Java表达式的评估是明确定义的，即使对于使用依赖于表达式计算顺序的任何副作用也是如此。</p>
                     <p>对于特定于Oracle的代码生成，当没有副作用时，Java表达式的评估遵循ISO标准，除非启用了<code class="codeph">-bind-by-identifier</code>选项，但是特定于实现，并且当存在副作用时可能会发生更改。
                     </p>
                     <div class="infoboxnote" id="GUID-B76F8910-AA7B-4DF0-B470-02E27829862E__GUID-A0E82AD2-2F5D-4E94-975C-4AE8F3618BDD">
                        <p class="notep1">注意：</p>
                        <p>下面的讨论和相关的例子后<span class="italic">并不</span>适用于Oracle的特定代码生成。如果您使用此处所述的副作用，请在翻译期间请求ISO代码生成。
                        </p>
                     </div>
                     <p>以下是ISO代码的摘要，概述了在运行时执行的每个语句的Java表达式的评估，执行和赋值的总体顺序。</p>
                     <ol>
                        <li>
                           <p>如果存在连接上下文表达式，则在评估任何其他Java表达式之前立即对其进行求值。</p>
                        </li>
                        <li>
                           <p>如果存在执行上下文表达式，则在任何连接上下文表达式之后但在任何结果表达式之前对其进行求值。</p>
                        </li>
                        <li>
                           <p>如果存在结果表达式，则在任何上下文表达式之后但在任何主机表达式之前对其进行求值。</p>
                        </li>
                        <li>
                           <p>在评估任何上下文或结果表达式之后，主机表达式将在SQL操作中从左到右进行计算。在遇到并计算每个宿主表达式时，会保存其值以传递给SQL。</p>
                           <p>每个主机表达式只进行一次评估。</p>
                        </li>
                        <li>
                           <p><code class="codeph">IN</code>和<code class="codeph">INOUT</code>参数传递给SQL，并执行SQL操作。
                           </p>
                        </li>
                        <li>
                           <p>执行SQL操作后，输出参数Java <code class="codeph">OUT</code>和<code class="codeph">INOUT</code>主机表达式按照从SQL操作中出现的顺序从左到右分配输出。
                           </p>
                           <p>每个输出主机表达式只分配一次。</p>
                        </li>
                        <li>
                           <p>结果表达式（如果有）将最后分配输出。</p>
                        </li>
                     </ol>
                     <div class="infoboxnote" id="GUID-B76F8910-AA7B-4DF0-B470-02E27829862E__GUID-585FD629-896A-400F-AF4F-E17C0499C889">
                        <p class="notep1">注意：</p>
                        <p>在执行块中的任何语句之前，PL / SQL块内的主机表达式都将一起计算。它们按照它们出现的顺序进行评估，而不管块内的控制流程如何。</p>
                     </div>
                     <p>一旦评估了语句中的表达式，就将输入和输出输出主机表达式传递给SQL，然后执行SQL操作。执行SQL操作后，将对Java输出主机表达式，输入输出主机表达式和结果表达式进行分配，如下所示：</p>
                     <ol>
                        <li>
                           <p><code class="codeph">OUT</code>和<code class="codeph">INOUT</code>主机表达式按从左到右的顺序分配输出。
                           </p>
                        </li>
                        <li>
                           <p>结果表达式（如果有）将最后分配输出。</p>
                        </li>
                     </ol>
                     <p>请注意，在运行时，所有主机表达式都被视为不同的值，即使它们共享相同的名称或引用相同的对象。每个SQL操作的执行都被视为调用远程方法，并且每个主机表达式都被视为一个不同的参数。在为该语句进行任何输出分配之前，每个输入或输入输出参数都会在首次遇到时进行评估和传递，并且每个输出参数也被视为不同并且仅分配一次。</p>
                     <p>记住每个主机表达式只评估一次也很重要。首次遇到<code class="codeph">INOUT</code>表达式时会对其进行求值。在进行输出分配时，表达式本身不会被重新评估，也不会重复任何副作用。
                     </p>
                  </div>
               </div><a id="JSQLJ306"></a><a id="JSQLJ307"></a><a id="JSQLJ308"></a><a id="JSQLJ309"></a><a id="JSQLJ310"></a><a id="JSQLJ305"></a><div class="props_rev_3"><a id="GUID-A06DF3CD-7BB2-42FC-A01E-3B6A5C5AE60F" name="GUID-A06DF3CD-7BB2-42FC-A01E-3B6A5C5AE60F"></a><h4 id="JSQLJ-GUID-A06DF3CD-7BB2-42FC-A01E-3B6A5C5AE60F" class="sect4">在运行时评估Java表达式的示例（ISO代码生成）</h4>
                  <div>
                     <div class="section">
                        <p>本节讨论ISO代码生成时如何在应用程序执行时评估Java表达式。</p>
                        <div class="infoboxnote" id="GUID-A06DF3CD-7BB2-42FC-A01E-3B6A5C5AE60F__GUID-8C0ABD3F-DF8F-4DD7-8D41-4400D77546C0">
                           <p class="notep1">注意：</p>
                           <p>如果你使用Oracle特有的代码生成<span class="italic">不要</span>在这些影响数。如果您依赖此类效果，请在翻译期间请求ISO代码生成。
                           </p>
                        </div>
                     </div>
                     <!-- class="section" -->
                     <div class="section">
                        <p class="subhead3" id="GUID-A06DF3CD-7BB2-42FC-A01E-3B6A5C5AE60F__GUID-AEEB69F2-2E4B-47F4-830B-F1CE4933CC73">前缀和后缀运算符的评估</p>
                     </div>
                     <!-- class="section" -->
                     <div class="section">
                        <p>当Java表达式包含Java后缀增量或减量运算符时，在计算表达式<span class="italic">之后</span>会发生递增或递减。类似地，当Java表达式包含Java前缀增量或减量运算符时，递增或递减发生<span class="italic">在</span>计算表达式<span class="italic">之前</span> 。这相当于在标准Java代码中处理这些运算符的方式。
                        </p>
                        <p>以下是后缀运算符的示例：</p><pre class="oac_no_warn" dir="ltr">int indx = 1; ...#sql {...：OUT（array [indx]）...：IN（indx ++）...};</pre><p>此示例评估如下：</p><pre class="oac_no_warn" dir="ltr">#sql {...：OUT（array [1]）...：IN（1）...};</pre><p><code class="codeph">indx</code>变量增加到2并且在下次遇到时将具有该值，但直到之后<code class="codeph">:IN (indx++)</code>已被评估。
                        </p>
                        <p>以下是后缀运算符的示例：</p><pre class="oac_no_warn" dir="ltr">int indx = 1; ...#sql {...：OUT（array [indx ++]）...：IN（indx ++）...};</pre><p>此示例评估如下：</p><pre class="oac_no_warn" dir="ltr">#sql {...：OUT（array [1]）...：IN（2）...};</pre><p>在计算第一个表达式之后，但在计算第二个表达式之前，变量<code class="codeph">indx</code>会增加到2。在计算第二个表达式后，它会增加到3，并在下次遇到它时具有该值。
                        </p>
                        <p>以下示例包含前缀和后缀运算符：</p><pre class="oac_no_warn" dir="ltr">int indx = 1; ...#sql {...：OUT（array [++ indx]）...：IN（indx ++）...};</pre><p>此示例评估如下：</p><pre class="oac_no_warn" dir="ltr">#sql {...：OUT（array [2]）...：IN（2）...};</pre><p>在计算第一个表达式之前，变量<code class="codeph">indx</code>增加到2。在计算第二个表达式后，它会增加到3，并在下次遇到它时具有该值。
                        </p>
                     </div>
                     <!-- class="section" -->
                     <div class="section">
                        <p class="subhead3" id="GUID-A06DF3CD-7BB2-42FC-A01E-3B6A5C5AE60F__GUID-4B7E08C2-0A33-4C01-B56F-C4D24B66BE8E">IN，INOUT和OUT主机表达式的评估顺序</p>
                     </div>
                     <!-- class="section" -->
                     <div class="section">
                        <p>主机表达式从左到右进行计算。表达式是<code class="codeph">IN</code> ， <code class="codeph">INOUT</code>还是<code class="codeph">OUT</code>在评估时没有区别。重要的是它从左到右的顺序。
                        </p>
                        <p>请考虑以下示例：</p><pre class="oac_no_warn" dir="ltr">int [5] arry; int n = 0; ...#sql {SET：OUT（arry [n]）= :( ++ n）};</pre><p>此示例评估如下：</p><pre class="oac_no_warn" dir="ltr">#sql {SET：OUT（arry [0]）= 1};</pre><p>有人可能希望在输出表达式之前评估输入表达式，但事实并非如此。表达式<code class="codeph">:OUT (arry[n])</code>首先被计算，因为它是最左边的表达式。然后<code class="codeph">n</code>被评价之前递增<code class="codeph">++n</code> ，因为它是由一个操作者前缀操作的。然后<code class="codeph">++n</code>被评估为1。结果将分配给<code class="codeph">arry[0]</code> ，而不是<code class="codeph">arry[1]</code> ，因为<code class="codeph">0</code>是最初遇到时的<code class="codeph">n</code>值。
                        </p>
                     </div>
                     <!-- class="section" -->
                     <div class="section">
                        <p class="subhead3" id="GUID-A06DF3CD-7BB2-42FC-A01E-3B6A5C5AE60F__GUID-894BD299-C504-470C-AEF1-DF5CAF77602D">在执行语句之前评估PL / SQL块中的表达式</p>
                     </div>
                     <!-- class="section" -->
                     <div class="section">
                        <p>PL / SQL块中的主机表达式在执行任何序列之前都按一个序列进行评估。请考虑以下示例：</p><pre class="oac_no_warn" dir="ltr">int x = 3; int z = 5; ...#sql {BEGIN：OUT x：= 10; ：OUT z：=：x;结束 }; System.out.println（“x =”+ x +“，z =”+ z）;</pre><p>此示例评估如下：</p><pre class="oac_no_warn" dir="ltr">#sql {BEGIN：OUT x：= 10; ：OUT z：= 3;结束 };</pre><p>因此，它将打印<code class="codeph">x=10, z=3</code> 。
                        </p>
                        <p>PL / SQL块中的所有表达式在执行任何表达式之前都要进行评估。在此示例中，第二个语句中的主机表达式<code class="codeph">:OUT z</code>和<code class="codeph">:x</code>在执行第一个语句之前进行计算。特别是，在为<code class="codeph">x</code>指定值<code class="codeph">10</code>之前， <code class="codeph">x</code>仍然具有其原始值<code class="codeph">3</code> ，将对其进行求值。
                        </p>
                        <p>考虑如何在PL / SQL块中计算表达式的另一个示例：</p><pre class="oac_no_warn" dir="ltr">int x = 1，y = 4，z = 3; ...#sql {BEGIN：OUT x：=：（y ++）+ 1; ：OUT z：=：x;结束 };</pre><p>此示例评估如下：</p><pre class="oac_no_warn" dir="ltr">#sql {BEGIN：OUT x：= 4 + 1; ：OUT z：= 1;结束 };</pre><p>后缀增量运算符在<code class="codeph">:(y++)</code>被计算之后执行，因此表达式被计算为<code class="codeph">4</code> ，这是<code class="codeph">y</code>的初始值。第二个语句<code class="codeph">:OUT z := :x</code> ，在执行第一个语句之前进行计算。因此， <code class="codeph">x</code>的初始值仍为<code class="codeph">1</code> 。执行此块后， <code class="codeph">x</code>将具有值<code class="codeph">5</code> ， <code class="codeph">z</code>将具有值<code class="codeph">1</code> 。
                        </p>
                        <p>以下示例演示了在一个SQLJ可执行语句中出现在PL / SQL块中的两个语句之间的区别，以及出现在单独（连续）SQLJ可执行语句中的相同语句。</p>
                        <p>首先，请考虑以下内容，其中两个语句位于PL / SQL块中。</p><pre class="oac_no_warn" dir="ltr">int y = 1; ...#sql {BEGIN：OUT y：=：y + 1; ：OUT x：=：y + 1;结束 };</pre><p>此示例评估如下：</p><pre class="oac_no_warn" dir="ltr">#sql {BEGIN：OUT y：= 1 + 1; ：OUT x：= 1 + 1;结束 };</pre><p>在执行任一语句之前，将评估第二个语句中的<code class="codeph">:y</code> 。因此， <code class="codeph">y</code>尚未收到第一个声明的输出。执行此块后， <code class="codeph">x</code>和<code class="codeph">y</code>的值均为<code class="codeph">2</code> 。
                        </p>
                        <p>现在，考虑在单独的SQLJ可执行语句中PL / SQL块中相同的两个语句的情况。</p><pre class="oac_no_warn" dir="ltr">int y = 1; #sql {BEGIN：OUT y：=：y + 1;结束 }; #sql {BEGIN：OUT x：=：y + 1;结束 };</pre><p>第一个陈述评估如下：</p><pre class="oac_no_warn" dir="ltr">#sql {BEGIN：OUT y：= 1 + 1;结束 };</pre><p>然后，执行它并为<code class="codeph">y</code>分配值<code class="codeph">2</code> 。
                        </p>
                        <p>执行第一个语句后，第二个语句的计算方法如下：</p><pre class="oac_no_warn" dir="ltr">#sql {BEGIN：OUT x：= 2 + 1;结束 };</pre><p>这次，与之前的PL / SQL块示例相反， <code class="codeph">y</code>已经从前一个语句的执行中接收到值<code class="codeph">2</code> 。因此，在执行第二个语句后，x被赋值为<code class="codeph">3</code> 。
                        </p>
                     </div>
                     <!-- class="section" -->
                     <div class="section">
                        <p class="subhead3" id="GUID-A06DF3CD-7BB2-42FC-A01E-3B6A5C5AE60F__GUID-B7376A5A-5F9E-411F-B633-6082C24964B6">PL / SQL块中的表达式始终只评估一次</p>
                     </div>
                     <!-- class="section" -->
                     <div class="section">
                        <p>无论程序流程和逻辑如何，每个主机表达式只被评估一次，并且只评估一次。</p>
                        <p>考虑以下在循环中评估主机表达式的示例：</p><pre class="oac_no_warn" dir="ltr">int count = 0; ...#sql {DECLARE n NUMBER BEGIN n：= 1;当n &lt;= 100 LOOP：IN（count ++）; n：= n + 1;结束循环;结束 };</pre><p>Java <code class="codeph">count</code>变量在传递给SQL时将具有值<code class="codeph">0</code> ，因为它由后缀运算符操作，而不是前缀运算符。然后它将增加到<code class="codeph">1</code>并在整个PL / SQL块的执行过程中保持该值。它仅在SQLJ可执行语句被解析时被评估一次，然后在SQL执行之前被值<code class="codeph">1</code>替换。
                        </p>
                        <p>请考虑以下示例，该示例说明了条件块中主机表达式的计算。此示例演示了如何始终评估每个表达式，而不管程序流程如何。执行块时，只有<code class="codeph">IF...一个分支<code class="codeph">IF...然后...可以执行ELSE</code>构造。但是，在执行块之前，将按语句出现的顺序计算块中的所有表达式。
                        </p><pre class="oac_no_warn" dir="ltr">int x; ...（对x的操作）......#sql {DECLARE n NUMBER BEGIN n：=：x; IF n &lt;10 THEN n：= :( x ++）; ELSE n：=：x *：x;结束循环;结束 };</pre><p>说上执行的操作<code class="codeph">x</code>导致<code class="codeph">x</code>具有值<code class="codeph">15</code> 。执行PL / SQL块时，将执行<code class="codeph">ELSE</code>分支，而不执行<code class="codeph">IF</code>分支。但是，无论程序逻辑或流程如何，PL / SQL块中的所有表达式都会在执行之前进行评估。因此，评估<code class="codeph">x++</code> ，然后递增<code class="codeph">x</code> ，然后在<code class="codeph">(x * x)</code>表达式中计算每个<code class="codeph">x</code> 。<code class="codeph">IF...然后...ELSE</code>块的评估如下：</p><pre class="oac_no_warn" dir="ltr">IF n &lt;10 THEN n：= 15; ELSE n：=：16 *：16;结束循环;</pre><p>在执行该块之后，给定<code class="codeph">x</code>的初始值<code class="codeph">15</code> ， <code class="codeph">n</code>将具有值<code class="codeph">256</code> 。
                        </p>
                     </div>
                     <!-- class="section" -->
                     <div class="section">
                        <p class="subhead3" id="GUID-A06DF3CD-7BB2-42FC-A01E-3B6A5C5AE60F__GUID-318DEC50-346C-46CB-A966-D8CFC333BFF6">输出主机表达式在结果表达式之前从左到右分配</p>
                     </div>
                     <!-- class="section" -->
                     <div class="section">
                        <p>请记住， <code class="codeph">OUT</code>和<code class="codeph">INOUT</code>主机表达式按从左到右的顺序分配，然后最后分配结果表达式（如果有）。如果同一个变量被分配了多次，那么它将根据此顺序被覆盖，最后一次分配优先。
                        </p>
                        <p>以下示例包含引用同一变量的多个输出主机表达式：</p><pre class="oac_no_warn" dir="ltr">#sql {CALL foo（：OUT x，：OUT x）};</pre><p>如果<code class="codeph">foo()</code>输出值<code class="codeph">2</code>和<code class="codeph">3</code> ，则在SQLJ可执行语句完成执行后<code class="codeph">x</code>将具有值<code class="codeph">3</code> 。右手分配将在最后执行，因此优先。
                        </p>
                        <p>以下示例包含引用同一对象的多个输出主机表达式：</p><pre class="oac_no_warn" dir="ltr">MyClass x = new MyClass（）; MyClass y = x; ...#sql {...：OUT（x.field）：= 1 ...：OUT（y.field）：= 2 ...};</pre><p>执行SQLJ可执行语句后， <code class="codeph">x.field</code>的值为<code class="codeph">2</code> ，而不是<code class="codeph">1</code> ，因为<code class="codeph">x</code>与<code class="codeph">y</code>对象相同，并且在为<code class="codeph">field</code>赋值<code class="codeph">2</code>后为其分配了值<code class="codeph">1</code> 。
                        </p>
                        <p>以下示例演示了将函数的输出结果分配给结果表达式并将结果分配给<code class="codeph">OUT</code>主机表达式之间的区别。考虑以下函数，使用<code class="codeph">invar</code>输入参数， <code class="codeph">outvar</code>输出参数和返回值：</p><pre class="oac_no_warn" dir="ltr">创建函数fn（invar NUMBER，outvar OUT NUMBER）返回NUMBER作为BEGIN outvar：= invar + invar; return（invar * invar）; END fn;</pre><p>现在考虑将函数的输出分配给结果表达式的示例：</p><pre class="oac_no_warn" dir="ltr">int x = 3; #sql x = {VALUES（fn（：x，：OUT x））};</pre><p>该函数将以<code class="codeph">3</code>为输入，将<code class="codeph">6</code>作为输出，并返回<code class="codeph">9</code> 。执行后，首先分配<code class="codeph">:OUT x</code> ，给<code class="codeph">x</code>值<code class="codeph">6</code> 。但最后分配了结果表达式，给<code class="codeph">x</code>返回值<code class="codeph">9</code>并覆盖先前分配给<code class="codeph">x</code>的值<code class="codeph">6</code> 。因此<code class="codeph">x</code>在下次遇到时将具有值<code class="codeph">9</code> 。
                        </p>
                        <p>现在考虑一个示例，其中函数的输出分配给<code class="codeph">OUT</code>主变量而不是结果表达式：</p><pre class="oac_no_warn" dir="ltr">int x = 3; #sql {BEGIN：OUT x：= fn（：x，：OUT x）;结束 };</pre><p>在这种情况下，没有结果表达式， <code class="codeph">OUT</code>变量只是从左到右分配。执行后，第一个<code class="codeph">:OUT x</code>在等式左边的<code class="codeph">:OUT x</code>首先被赋值，给<code class="codeph">x</code>的函数返回值为<code class="codeph">9</code> 。但是，从左到右，第二个<code class="codeph">:OUT x</code>在等式右边的<code class="codeph">:OUT x</code>最后分配，给<code class="codeph">x</code>输出值<code class="codeph">6</code>并覆盖先前分配给<code class="codeph">x</code>的<code class="codeph">9</code>的值。因此， <code class="codeph">x</code>将在下次遇到时具有值<code class="codeph">6</code> 。
                        </p>
                        <div class="infoboxnote" id="GUID-A06DF3CD-7BB2-42FC-A01E-3B6A5C5AE60F__GUID-C4C16FBB-35A2-4FF9-8668-B3B0677126E6">
                           <p class="notep1">注意：</p>
                           <p>在这些示例中使用了一些不太可能的情况来解释如何评估主机表达式的概念。实际上，不建议在<code class="codeph">OUT</code>或<code class="codeph">INOUT</code>主机表达式中使用相同的变量，也不建议在单个语句或PL / SQL块中的<code class="codeph">IN</code>主机表达式中使用相同的变量。在这种情况下的行为在Oracle SQLJ实现中已明确定义，但SQLJ规范中未涵盖此实践。因此，以这种方式编写的代码将不可移植。如果在语义检查期间设置了<code class="codeph">portable</code>标志，则此类代码将从SQLJ转换器生成警告。
                           </p>
                        </div>
                     </div>
                     <!-- class="section" -->
                  </div>
               </div><a id="JSQLJ311"></a><div class="props_rev_3"><a id="GUID-AE6CB258-0865-40BB-AC83-7057FC1798F7" name="GUID-AE6CB258-0865-40BB-AC83-7057FC1798F7"></a><h4 id="JSQLJ-GUID-AE6CB258-0865-40BB-AC83-7057FC1798F7" class="sect4">主机表达式的限制</h4>
                  <div>
                     <p>不要在主机表达式中使用<code class="codeph">in</code> ， <code class="codeph">out</code>和<code class="codeph">inout</code>作为标识符，除非它们括在括号中。否则，他们可能会被误认为是模式说明符。这不区分大小写。
                     </p>
                     <p>例如，您可以使用一个名为<code class="codeph">in</code>的输入主机变量，如下所示：</p><pre class="oac_no_warn" dir="ltr">：（在）</pre><p>要么：</p><pre class="oac_no_warn" dir="ltr">：IN（在）</pre></div>
               </div>
            </div><a id="JSQLJ312"></a><div class="props_rev_3"><a id="GUID-E779CA66-DE27-48C8-A379-E793AF0FB280" name="GUID-E779CA66-DE27-48C8-A379-E793AF0FB280"></a><h3 id="JSQLJ-GUID-E779CA66-DE27-48C8-A379-E793AF0FB280" class="sect3">单行查询结果：SELECT INTO语句</h3>
               <div>
                  <p>当只返回单行数据时，SQLJ允许您将所选项直接分配给SQL语法中的Java主机表达式。这是使用<code class="codeph">SELECT INTO</code>语句完成的。本节包括以下主题：</p>
                  <ul style="list-style-type:disc">
                     <li>
                        <p><a href="basic-language-features.html#GUID-917A36A6-18D2-4447-958F-50C0889C258E">SELECT INTO语法</a></p>
                     </li>
                     <li>
                        <p><a href="basic-language-features.html#GUID-1AA5FB20-6B8E-4A32-834F-F19F1524D622">SELECT INTO语句的示例</a></p>
                     </li>
                     <li>
                        <p><a href="basic-language-features.html#GUID-05A04EF6-4966-4D0E-9EC3-DA64BF97B555">SELECT-List中的主机表达式示例</a></p>
                     </li>
                     <li>
                        <p><a href="basic-language-features.html#GUID-D7660C1B-9034-4CA2-848E-544E72F7D87E">选择输入错误条件</a></p>
                     </li>
                  </ul>
               </div><a id="JSQLJ313"></a><div class="props_rev_3"><a id="GUID-917A36A6-18D2-4447-958F-50C0889C258E" name="GUID-917A36A6-18D2-4447-958F-50C0889C258E"></a><h4 id="JSQLJ-GUID-917A36A6-18D2-4447-958F-50C0889C258E" class="sect4">SELECT INTO语法</h4>
                  <div>
                     <p><code class="codeph">SELECT INTO</code>语句的语法如下：</p><pre class="oac_no_warn" dir="ltr">#sql {SELECT <span class="italic">expression1，...，expressionN</span> INTO： <span class="italic">host_exp1，...，</span> ： <span class="italic">host_expN</span> FROM <span class="italic">table</span> &lt; <span class="italic">optional_clauses</span> &gt;};</pre><p>请记住以下内容：</p>
                     <ul style="list-style-type:disc">
                        <li>
                           <p>项目<span class="italic"><code class="codeph">expression1</code></span>到<span class="italic"><code class="codeph">expressionN</code></span>是指定从数据库中选择什么的表达式。这些可以是对任何<code class="codeph">SELECT</code>语句有效的任何表达式。此表达式列表称为<code class="codeph">SELECT</code> -list。在一个简单的例子中，这些是数据库表中列的名称。在<code class="codeph">SELECT</code> -list中包含主机表达式也是合法的。
                           </p>
                        </li>
                        <li>
                           <p>项目<span class="italic"><code class="codeph">host_exp1</code></span>到<span class="italic"><code class="codeph">host_expN</code></span>是目标主机表达式，例如变量或数组元素。此主机表达式列表称为<code class="codeph">INTO</code> -list。
                           </p>
                        </li>
                        <li>
                           <p>项<span class="italic"><code class="codeph">table</code></span>是从中选择数据的数据库表，视图或快照的名称。
                           </p>
                        </li>
                        <li>
                           <p>该项目<span class="italic"><code class="codeph">optional_clauses</code></span>是要包括任何附加条款，在一个有效<code class="codeph">SELECT</code>语句，如<code class="codeph">WHERE</code>子句。
                           </p>
                        </li>
                     </ul>
                     <p><code class="codeph">SELECT INTO</code>语句必须返回一行且仅一行数据，否则将在运行时生成错误。
                     </p>
                     <p>对于<code class="codeph">INTO</code> -list中的主机表达式，默认值为<code class="codeph">OUT</code> ，但您可以选择明确说明：</p><pre class="oac_no_warn" dir="ltr">#sql {SELECT <span class="italic">column_name1，column_name2</span> INTO：OUT <span class="italic">host_exp1，</span> ：OUT <span class="italic">host_exp2</span> FROM <span class="italic">table</span> WHERE <span class="italic">condition</span> };</pre><p>尝试在<code class="codeph">INTO</code> -list中使用<code class="codeph">IN</code>或<code class="codeph">INOUT</code>标记将导致转换时出错。
                     </p>
                     <div class="infoboxnote" id="GUID-917A36A6-18D2-4447-958F-50C0889C258E__GUID-7AD05B4F-ABA0-4367-BDF5-047C9FE6AF92">
                        <p class="notep1">注意：</p>
                        <ul style="list-style-type:disc">
                           <li>
                              <p><span class="italic"><code class="codeph">expression1</code></span>到<span class="italic"><code class="codeph">expressionN</code></span> ， <span class="italic"><code class="codeph">table</code></span>和optional子句的允许语法与任何SQL <code class="codeph">SELECT</code>语句的语法相同。
                              </p>
                           </li>
                           <li>
                              <p>可以有任意数量的<code class="codeph">SELECT</code> -list和<code class="codeph">INTO</code> -list项目，只要它们匹配即可。也就是说，每个SELECT-list项目有一个INTO列表项，具有兼容类型。
                              </p>
                           </li>
                        </ul>
                     </div>
                  </div>
               </div><a id="JSQLJ314"></a><div class="props_rev_3"><a id="GUID-1AA5FB20-6B8E-4A32-834F-F19F1524D622" name="GUID-1AA5FB20-6B8E-4A32-834F-F19F1524D622"></a><h4 id="JSQLJ-GUID-1AA5FB20-6B8E-4A32-834F-F19F1524D622" class="sect4">SELECT INTO语句的示例</h4>
                  <div>
                     <div class="section">
                        <p>本节中的示例使用具有以下行的employee表<code class="codeph">EMP</code> ：</p><pre class="oac_no_warn" dir="ltr">CREATE TABLE EMP（EMPNO NUMBER（4），ENAME VARCHAR2（10），HIREDATE DATE）;</pre><p>以下是在<code class="codeph">INTO</code> -list中具有单个主机表达式的<code class="codeph">SELECT INTO</code>语句的示例：</p><pre class="oac_no_warn" dir="ltr">字符串empname; #sql {SELECT ename INTO：enpname FROM emp WHERE empno = 28959};</pre><p>以下是<code class="codeph">INTO</code> -list中具有多个主机表达式的<code class="codeph">SELECT INTO</code>语句的示例：</p><pre class="oac_no_warn" dir="ltr">字符串empname;日期命中; #sql {SELECT ename，hiredate INTO：empname，：hdate FROM emp WHERE empno = 28959};</pre></div>
                     <!-- class="section" -->
                  </div>
               </div><a id="JSQLJ315"></a><div class="props_rev_3"><a id="GUID-05A04EF6-4966-4D0E-9EC3-DA64BF97B555" name="GUID-05A04EF6-4966-4D0E-9EC3-DA64BF97B555"></a><h4 id="JSQLJ-GUID-05A04EF6-4966-4D0E-9EC3-DA64BF97B555" class="sect4">SELECT-List中的主机表达式示例</h4>
                  <div>
                     <p>在<code class="codeph">SELECT</code> -list和<code class="codeph">INTO</code> -list中使用Java主机表达式是合法的。例如，您可以直接从一个主表达式中选择另一个表达式，尽管这个用途有限，如下所示：</p><pre class="oac_no_warn" dir="ltr">...#sql {SELECT：name1 INTO：name2 FROM emp WHERE empno = 28959}; ...
</pre><p>更现实地，您可能希望对所选数据执行操作或连接，如以下示例所示。假设必要时先前声明并分配了Java变量。</p><pre class="oac_no_warn" dir="ltr">...#sql {SELECT sal +：raise INTO：newsal FROM emp WHERE empno = 28959}; ......#sql {SELECT：（firstname +“”）|| emp_last_name INTO：name FROM myemp WHERE empno = 28959}; ...
</pre><p>在第二个示例中，假设<code class="codeph">myemp</code>是一个非常类似于<code class="codeph">emp</code>表的表，但是带有<code class="codeph">emp_last_name</code>列而不是<code class="codeph">ename</code>列。在<code class="codeph">SELECT</code>语句中， <code class="codeph">firstname</code>置于单个空格（“”），使用Java主机表达式和Java字符串连接运算符（ <code class="codeph">+</code> ）。然后将此结果传递给SQL引擎，该引擎使用SQL字符串连接运算符（ <code class="codeph">||</code> ）附加姓氏。
                     </p>
                  </div>
               </div><a id="JSQLJ316"></a><div class="props_rev_3"><a id="GUID-D7660C1B-9034-4CA2-848E-544E72F7D87E" name="GUID-D7660C1B-9034-4CA2-848E-544E72F7D87E"></a><h4 id="JSQLJ-GUID-D7660C1B-9034-4CA2-848E-544E72F7D87E" class="sect4">选择输入错误条件</h4>
                  <div>
                     <p>请记住， <code class="codeph">SELECT INTO</code>语句仅适用于仅返回一行数据的查询。查找零行或多行的<code class="codeph">SELECT INTO</code>查询将导致异常，如下所示：</p>
                     <ul style="list-style-type:disc">
                        <li>
                           <p><code class="codeph">SELECT INTO</code>找不到行将返回SQL状态为<code class="codeph">2000</code>的异常，表示“无数据”条件。
                           </p>
                        </li>
                        <li>
                           <p><code class="codeph">SELECT INTO</code>查找多行将返回SQL状态为<code class="codeph">21000</code>的异常，表示基数违规。
                           </p>
                        </li>
                     </ul>
                     <p>您可以通过<code class="codeph">java.sql.的<code class="codeph">getSQLState()</code>方法检索SQL状态<code class="codeph">java.sql.SQLException</code>类。
                     </p>
                     <p>这是与ISO SQLJ标准中指定的独立于供应商的行为。在这些情况下，没有特定于供应商的错误代码。错误代码始终为<code class="codeph">0</code> 。
                     </p>
                  </div>
               </div>
            </div><a id="JSQLJ317"></a><div class="props_rev_3"><a id="GUID-C6E5904A-2D17-40EA-9DF2-AD5BCEA58E2D" name="GUID-C6E5904A-2D17-40EA-9DF2-AD5BCEA58E2D"></a><h3 id="JSQLJ-GUID-C6E5904A-2D17-40EA-9DF2-AD5BCEA58E2D" class="sect3">多行查询结果：SQLJ迭代器</h3>
               <div>
                  <p>大量SQL操作是多行查询。在SQLJ中处理多行查询结果需要一个SQLJ迭代器。SQLJ迭代器是JDBC结果集的强类型版本，并与底层数据库游标相关联。SQLJ迭代器主要用于从<code class="codeph">SELECT</code>语句中获取查询结果。
                  </p>
                  <p>此外，Oracle提供SQLJ扩展，使您能够以下列方式使用SQLJ迭代器和结果集：</p>
                  <ul style="list-style-type:disc">
                     <li>
                        <p>作为可执行SQL语句中的<code class="codeph">OUT</code>主变量</p>
                     </li>
                     <li>
                        <p>作为<code class="codeph">INTO</code> -list目标，例如在<code class="codeph">SELECT INTO</code>语句中</p>
                     </li>
                     <li>
                        <p>作为存储函数调用的返回类型</p>
                     </li>
                     <li>
                        <p>作为迭代器声明中的列类型（本质上是嵌套迭代器）</p>
                     </li>
                  </ul>
                  <div class="infoboxnote" id="GUID-C6E5904A-2D17-40EA-9DF2-AD5BCEA58E2D__GUID-29C8B40A-22C5-4477-9588-8036C151A1F2">
                     <p class="notep1">注意：</p>
                     <p>要以任何方式使用SQLJ迭代器，必须将其类声明为<code class="codeph">public</code> 。如果您在类级别或嵌套级别级别声明它，则建议将其声明为<code class="codeph">public static</code> 。
                     </p>
                  </div>
                  <p>本节包括以下主题：</p>
                  <ul style="list-style-type:disc">
                     <li>
                        <p><a href="basic-language-features.html#GUID-C20AEB54-A0BC-4863-8979-DFF181374B2B">迭代器概念</a></p>
                     </li>
                     <li>
                        <p><a href="basic-language-features.html#GUID-92CEA05F-80CF-40E1-B5D9-632CB2B10246">使用迭代器的一般步骤</a></p>
                     </li>
                     <li>
                        <p><a href="basic-language-features.html#GUID-4BEB2D79-A90D-4F5F-BAF9-754E717B4EAF">Named_ Positional_和Result Set迭代器</a></p>
                     </li>
                     <li>
                        <p><a href="basic-language-features.html#GUID-FF318201-3A54-450E-AC86-616665E03DE2">使用命名迭代器</a></p>
                     </li>
                     <li>
                        <p><a href="basic-language-features.html#GUID-C99760AC-46A2-446C-8CA6-D032FC4C303D">使用位置迭代器</a></p>
                     </li>
                     <li>
                        <p><a href="basic-language-features.html#GUID-D3CC3825-1F5D-45AF-9E96-5848B98B7D21">使用迭代器和结果集作为主机变量</a></p>
                     </li>
                     <li>
                        <p><a href="basic-language-features.html#GUID-A8BA5DEF-6CA2-4C06-8073-0F475851B7CA">使用迭代器和结果集作为迭代器列</a></p>
                     </li>
                  </ul>
                  <div class="infoboxnotealso" id="GUID-C6E5904A-2D17-40EA-9DF2-AD5BCEA58E2D__GUID-4BBB0077-9CAB-4816-9F11-BD383566D333">
                     <p class="notep1">也可以看看：</p>
                     <p><span class="q">“ <a href="advanced-language-features.html#GUID-9723BCED-0FA3-4AD9-B6C0-62B85B53C4EF">迭代器类实现和高级功能</a> ”</span></p>
                  </div>
               </div><a id="JSQLJ318"></a><div class="props_rev_3"><a id="GUID-C20AEB54-A0BC-4863-8979-DFF181374B2B" name="GUID-C20AEB54-A0BC-4863-8979-DFF181374B2B"></a><h4 id="JSQLJ-GUID-C20AEB54-A0BC-4863-8979-DFF181374B2B" class="sect4">迭代器概念</h4>
                  <div>
                     <p>使用SQLJ迭代器声明会生成强类型迭代器。这是迭代器的典型用法，并且在转换期间特别利用了SQLJ语义检查功能。使用弱类型迭代器也是可能的，并且有时是有利的。您可以实例化泛型类以使用弱类型迭代器。</p>
                     <p>本节包括以下主题：</p>
                     <ul style="list-style-type:disc">
                        <li>
                           <p><a href="basic-language-features.html#GUID-F02EF0A4-F368-4286-B6E2-61264186BBC1">强类型迭代器概述</a></p>
                        </li>
                        <li>
                           <p><a href="basic-language-features.html#GUID-33DDF8DC-056E-49DB-A17D-CD55AA92F963">弱类型迭代器概述</a></p>
                        </li>
                     </ul>
                  </div><a id="JSQLJ320"></a><a id="JSQLJ319"></a><div class="props_rev_3"><a id="GUID-F02EF0A4-F368-4286-B6E2-61264186BBC1" name="GUID-F02EF0A4-F368-4286-B6E2-61264186BBC1"></a><h5 id="JSQLJ-GUID-F02EF0A4-F368-4286-B6E2-61264186BBC1" class="sect5">强类型迭代器概述</h5>
                     <div>
                        <p>在使用强类型迭代器对象之前，必须声明一个迭代器类。迭代器声明指定SQLJ为您构造的Java类，其中类属性定义迭代器中的数据类型和（可选）数据列的名称。</p>
                        <p>SQLJ迭代器对象是这种特定声明的迭代器类的实例，具有固定数量的预定义类型的列。这与JDBC结果集对象相反，后者是标准的<code class="codeph">java.sql.ResultSet</code>实例，原则上可以包含任意类型的任意数量的列。
                        </p>
                        <p>声明迭代器时，既可以指定所选列的数据类型，也可以指定数据类型和所选列的名称：</p>
                        <ul style="list-style-type:disc">
                           <li>
                              <p>指定名称和数据类型定义了一个命名的迭代器类。</p>
                           </li>
                           <li>
                              <p>仅指定数据类型定义位置迭代器类。</p>
                           </li>
                        </ul>
                        <p>您声明的数据类型和名称（如果适用）确定查询结果将如何存储在您从该类实例化的迭代器对象中。检索到迭代器对象的SQL数据将转换为迭代器声明中指定的Java类型。</p>
                        <p>查询以填充命名的迭代器对象时， <code class="codeph">SELECT</code>语句中列的名称和数据类型必须与迭代器列的名称和数据类型匹配。但是，这不区分大小写。<code class="codeph">SELECT</code>语句中列的顺序无关紧要。重要的是<code class="codeph">SELECT</code>语句中的每个列名都与迭代器列名匹配。在最简单的情况下，数据库列名称直接与迭代器列名称匹配。
                        </p>
                        <p>例如，可以选择数据库表中<code class="codeph">ENAME</code>列的数据并将其放入迭代器<code class="codeph">ename</code>列。或者，如果名称不同，您可以使用别名将数据库列名映射到迭代器列名。此外，在更复杂的查询中，您可以在两列之间执行操作，并将结果别名以匹配相应的迭代器列名称。
                        </p>
                        <p>因为SQLJ迭代器是强类型的，所以它们在SQLJ语义检查阶段提供了Java类型检查的好处。</p>
                        <p>例如，请考虑下表：</p><pre class="oac_no_warn" dir="ltr">CREATE TABLE EMPSAL（EMPNO NUMBER（4），ENAME VARCHAR2（10），OLDSAL NUMBER（10），RAISE NUMBER（10））;</pre><p>给定此表，您可以如下声明命名迭代器。</p><pre class="oac_no_warn" dir="ltr">#sql iterator SalNamedIter（int empno，String ename，float raise）;</pre><p>声明后，您可以使用此命名迭代器，如下所示：</p><pre class="oac_no_warn" dir="ltr">class MyClass {void func（）抛出SQLException {...SalNamedIter niter; #sql niter = {SELECT ename，empno，raise FROM empsal}; ... <span class="italic">过程硝化</span> ...}}</pre><p>这是迭代器列名称与表列名称匹配的简单情况。请注意，使用命名迭代器时， <code class="codeph">SELECT</code>语句中的项的顺序无关紧要。数据按名称匹配，而不是位置。
                        </p>
                        <p>当您查询以填充位置迭代器对象时，将根据您选择列的顺序检索数据。将从数据库表中选择的第一列中的数据放入迭代器的第一列，依此类推。表列的数据类型必须可以转换为迭代器列的类型，但数据库列的名称是无关紧要的，因为迭代器列没有名称。</p>
                        <p>给定<code class="codeph">EMPSAL</code>表，您可以声明位置迭代器，如下所示：</p><pre class="oac_no_warn" dir="ltr">#sql iterator SalPosIter（int，String，float）;</pre><p>您可以使用此位置迭代器，如下所示：</p><pre class="oac_no_warn" dir="ltr">class MyClass {void func（）抛出SQLException {...SalPosIter piter; #sql piter = {SELECT empno，ename，raise FROM empsal}; ... <span class="italic">过程piter</span> ...}}</pre><p>请注意， <code class="codeph">SELECT</code>语句中的数据项的顺序必须与迭代器中的顺序相同。命名迭代器和位置迭代器之间的处理不同。
                        </p>
                        <div class="section">
                           <p class="subhead3" id="GUID-F02EF0A4-F368-4286-B6E2-61264186BBC1__GUID-593FB6DE-90C3-4E8E-9DF6-48A604519CC9">一般迭代器注释</p>
                        </div>
                        <!-- class="section" -->
                        <div class="section">
                           <p>除了前面的概念之外，请注意以下有关迭代器的一般说明：</p>
                           <ul style="list-style-type:disc">
                              <li>
                                 <p>填充迭代器时允许使用<code class="codeph">SELECT *</code>语法，但不建议这样做。对于位置迭代器，这要求表中的列数等于迭代器中的列数，并且数据类型按顺序匹配。对于命名迭代器，这要求表中的列数大于或等于迭代器中的列数，并且每个迭代器列的名称和数据类型与数据库表列匹配。但是，如果表中的列数较大，则除非设置了translator <code class="codeph">-warn=nostrict</code>标志，否则将生成警告。
                                 </p>
                              </li>
                              <li>
                                 <p>Positional和named迭代器是不同且不兼容的Java类。一种迭代器对象不能转换为另一种迭代器对象。</p>
                              </li>
                              <li>
                                 <p>与SQL游标不同，迭代器实例是第一类Java对象。也就是说，它可以作为方法参数传递和返回，例如。此外，可以使用Java类修饰符（例如<code class="codeph">public</code>或<code class="codeph">private</code>声明迭代器实例。
                                 </p>
                              </li>
                              <li>
                                 <p>SQLJ支持SQLJ迭代器和JDBC结果集之间的互操作性和转换。</p>
                              </li>
                              <li>
                                 <p>一般来说，迭代器的内容仅由执行填充它的<code class="codeph">SELECT</code>语句时的数据库状态决定。后续<code class="codeph">UPDATE</code> ， <code class="codeph">INSERT</code> ， <code class="codeph">DELETE</code> ， <code class="codeph">COMMIT</code>或<code class="codeph">ROLLBACK</code>操作对迭代器或其内容没有影响。例外情况是，如果声明迭代器可滚动且对数据中的更改敏感。
                                 </p>
                              </li>
                           </ul>
                        </div>
                        <!-- class="section" -->
                     </div>
                  </div><a id="JSQLJ321"></a><div class="props_rev_3"><a id="GUID-33DDF8DC-056E-49DB-A17D-CD55AA92F963" name="GUID-33DDF8DC-056E-49DB-A17D-CD55AA92F963"></a><h5 id="JSQLJ-GUID-33DDF8DC-056E-49DB-A17D-CD55AA92F963" class="sect5">弱类型迭代器概述</h5>
                     <div>
                        <p>如果您不想声明迭代器类，Oracle SQLJ实现允许您使用弱类型迭代器。这种迭代器称为结果集迭代器。要使用普通的，即不可滚动的结果集迭代器，请实例化<code class="codeph">sqlj.runtime.ResultSetIterator</code>类。要使用可滚动的结果集迭代器，请实例化<code class="codeph">sqlj.runtime.ScrollableResultSetIterator</code>类。
                        </p>
                        <p>与强类型迭代器相比，使用结果集迭代器的缺点是SQLJ无法对查询执行尽可能多的语义检查。</p>
                     </div>
                  </div>
               </div><a id="JSQLJ322"></a><div class="props_rev_3"><a id="GUID-92CEA05F-80CF-40E1-B5D9-632CB2B10246" name="GUID-92CEA05F-80CF-40E1-B5D9-632CB2B10246"></a><h4 id="JSQLJ-GUID-92CEA05F-80CF-40E1-B5D9-632CB2B10246" class="sect4">使用迭代器的一般步骤</h4>
                  <div>
                     <p>您必须按照以下一般步骤使用SQLJ命名或位置迭代器：</p>
                     <ol>
                        <li>
                           <p>使用SQLJ声明来定义迭代器类（换句话说，定义迭代器类型）。</p>
                        </li>
                        <li>
                           <p>声明迭代器类的变量。</p>
                        </li>
                        <li>
                           <p>使用<code class="codeph">SELECT</code>语句使用SQL查询的结果填充迭代器变量。
                           </p>
                        </li>
                        <li>
                           <p>访问迭代器中的查询列。如何实现这一点在命名迭代器和位置迭代器之间有所不同。</p>
                        </li>
                        <li>
                           <p>处理完查询结果后，关闭迭代器以释放其资源。</p>
                        </li>
                     </ol>
                  </div>
               </div><a id="JSQLJ324"></a><a id="JSQLJ323"></a><div class="props_rev_3"><a id="GUID-4BEB2D79-A90D-4F5F-BAF9-754E717B4EAF" name="GUID-4BEB2D79-A90D-4F5F-BAF9-754E717B4EAF"></a><h4 id="JSQLJ-GUID-4BEB2D79-A90D-4F5F-BAF9-754E717B4EAF" class="sect4">命名，位置和结果集迭代器</h4>
                  <div>
                     <p>每种SQLJ迭代器都有优点和适当的情况。</p>
                     <p>命名迭代器可以提供更大的灵活性。因为选择到命名迭代器中的数据会按名称将<code class="codeph">SELECT</code>语句中的列与迭代器列匹配，所以您无需关心查询中的顺序。这不容易出错，因为数据不可能被放入错误的列中。如果名称不匹配，则SQLJ转换程序在针对数据库检查SQL语句时将生成错误。
                     </p>
                     <p>位置迭代器为具有其他嵌入式SQL语言经验的开发人员提供了熟悉的范例和语法。使用命名迭代器，您可以使用<code class="codeph">next()</code>方法来检索数据，而使用位置迭代器，您可以使用类似于Pro * C的<code class="codeph">FETCH INTO</code>语法。在检索下一组值之前，每次提取都会隐式前进到迭代器的下一个可用行。
                     </p>
                     <p>但是，位置迭代器确实提供的灵活性比命名迭代器少，因为您是按位置而不是按名称将数据选择到迭代器列中。您必须确定<code class="codeph">SELECT</code>语句中的项目顺序。此外，您必须在迭代器的所有列中选择数据。如果该列的数据类型恰好与所选表列的数据类型匹配，则可以将数据写入错误的迭代器列。
                     </p>
                     <p>使用位置迭代器访问单个数据元素也不太方便。命名迭代器，因为它们按名称存储数据，能够为每列提供方便的访问器方法。例如，将有一个<code class="codeph">ename()</code>方法从<code class="codeph">ename</code>迭代器列中检索数据。使用位置迭代器，必须使用<code class="codeph">FETCH INTO</code>语句将数据直接提取到Java主机表达式中，并且主机表达式必须按正确顺序排列。
                     </p>
                     <p>如果您不想为查询声明强类型迭代器类，则可以选择使用弱类型结果集迭代器的替代方法。将JDBC代码转换为SQLJ代码时，结果集迭代器最方便。您必须平衡此考虑因素与结果集迭代器（ <code class="codeph">ResultSetIterator</code>实例或<code class="codeph">ScrollableResultSetIterator</code>实例）在转换期间不允许完整的SQLJ语义检查这一事实。使用命名或位置迭代器，SQLJ会验证<code class="codeph">SELECT</code>语句中列的数据类型是否与将要实现数据的Java类型相匹配。使用结果集迭代器，这是不可能的。
                     </p>
                     <div class="section">
                        <p class="subhead3" id="GUID-4BEB2D79-A90D-4F5F-BAF9-754E717B4EAF__GUID-F5A47A46-7048-44EE-971B-F30A0AB03F8E">比较迭代器注释</p>
                     </div>
                     <!-- class="section" -->
                     <div class="section">
                        <p>请注意有关SQLJ迭代器的以下注释：</p>
                        <ul style="list-style-type:disc">
                           <li>
                              <p>在填充位置迭代器时，从数据库中选择的列数必须等于迭代器中的列数。在填充命名迭代器时，从数据库中选择的列数永远不会小于迭代器中的列数，但如果你有translator <code class="codeph">-warn=nostrict</code>标志，则可以大于迭代器中的列数组。在这种情况下，将忽略不匹配的列。
                              </p>
                           </li>
                           <li>
                              <p>虽然术语“获取”通常是指从数据库中获取数据，但请记住，位置迭代器的<code class="codeph">FETCH INTO</code>语句不一定涉及到服务器的往返。这取决于行预取值。这是因为您从迭代器而不是数据库中获取数据。但是，如果行预取值为<code class="codeph">1</code> ，则每次提取确实涉及到数据库的单独行程。行预取值确定每次访问数据库时检索的行数。
                              </p>
                           </li>
                           <li>
                              <p>结果集迭代器使用与位置迭代器一起使用的相同<code class="codeph">FETCH INTO</code>语法，并且在运行时受到相同的限制。也就是说， <code class="codeph">SELECT</code> -list中的数据项数必须与<code class="codeph">FETCH</code>语句中分配数据的变量数相匹配。
                              </p>
                           </li>
                        </ul>
                     </div>
                     <!-- class="section" -->
                  </div>
               </div><a id="JSQLJ326"></a><a id="JSQLJ327"></a><a id="JSQLJ328"></a><a id="JSQLJ325"></a><div class="props_rev_3"><a id="GUID-FF318201-3A54-450E-AC86-616665E03DE2" name="GUID-FF318201-3A54-450E-AC86-616665E03DE2"></a><h4 id="JSQLJ-GUID-FF318201-3A54-450E-AC86-616665E03DE2" class="sect4">使用命名迭代器</h4>
                  <div>
                     <div class="section">
                        <p>声明命名迭代器类时，声明名称以及迭代器的每列的数据类型。当您在命名迭代器中选择数据时， <code class="codeph">SELECT</code>语句中的列必须以两种方式匹配迭代器列：</p>
                     </div>
                     <!-- class="section" -->
                     <div class="section">
                        <ul style="list-style-type:disc">
                           <li>
                              <p><code class="codeph">SELECT</code>语句中每个数据项的名称（表列名或别名）必须与迭代器列名匹配。但是，这不区分大小写。也就是说， <code class="codeph">ename</code>或<code class="codeph">Ename</code>将匹配<code class="codeph">ENAME</code> ）。
                              </p>
                           </li>
                           <li>
                              <p>根据标准JDBC类型映射，每个迭代器列的数据类型必须与<code class="codeph">SELECT</code>语句中相应数据项的数据类型兼容。
                              </p>
                           </li>
                        </ul>
                        <p>在命名的迭代器类声明中声明属性的顺序是无关紧要的。仅根据名称将数据选择到迭代器中。</p>
                        <p>命名迭代器具有<code class="codeph">next()</code>方法，用于逐行检索数据，以及每个列的访问器方法，以检索单个数据项。访问者方法名称与列名称相同。与Java中的大多数访问器方法名称不同，命名迭代器类中的访问器方法名称不以<code class="codeph">get</code>开头。例如，具有列<code class="codeph">sal</code>的命名迭代器对象将具有<code class="codeph">sal()</code>访问器方法。
                        </p>
                        <div class="infoboxnote" id="GUID-FF318201-3A54-450E-AC86-616665E03DE2__GUID-331BB72D-BDE5-44AB-BDA9-C051AABE3B0A">
                           <p class="notep1">注意：</p>
                           <p>以下限制适用于命名命名迭代器的列：</p>
                           <ul style="list-style-type:disc">
                              <li>
                                 <p>列名不能使用Java保留字。</p>
                              </li>
                              <li>
                                 <p>列名不能与命名迭代器类中提供的实用程序方法具有相同的名称，例如<code class="codeph">next()</code> ， <code class="codeph">close()</code> ， <code class="codeph">getResultSet()</code>和<code class="codeph">isClosed()</code>方法。对于可滚动的命名迭代器，这包括其他方法，如<code class="codeph">previous()</code> ， <code class="codeph">first()</code>和<code class="codeph">last()</code> 。
                                 </p>
                              </li>
                           </ul>
                        </div>
                     </div>
                     <!-- class="section" -->
                     <div class="section">
                        <p class="subhead3" id="GUID-FF318201-3A54-450E-AC86-616665E03DE2__GUID-DB9656A7-3792-489B-95F5-FC3CA9763E00">声明命名的迭代器类</p>
                     </div>
                     <!-- class="section" -->
                     <div class="section">
                        <p>使用以下语法声明一个命名的迭代器类：</p><pre class="oac_no_warn" dir="ltr">#sql &lt; <span class="italic">modifiers</span> &gt; iterator <span class="italic">classname</span> &lt; <span class="italic">implements子句</span> &gt; &lt; <span class="italic">with clause</span> &gt;（ <span class="italic">type-name-list</span> ）;</pre><p>在此语法中， <span class="italic"><code class="codeph">modifiers</code></span>是合法Java类修饰符的可选序列， <span class="italic"><code class="codeph">classname</code></span>是迭代器所需的类名，而<span class="italic"><code class="codeph">type-name-list</code></span>是与列类型和列等效或兼容的Java类型和名称的列表数据库表中的名称。
                        </p>
                        <p><code class="codeph">implements</code>子句和<code class="codeph">with</code>子句是可选的，分别指定要实现的接口和要定义和初始化的变量。
                        </p>
                        <div class="infoboxnotealso" id="GUID-FF318201-3A54-450E-AC86-616665E03DE2__GUID-84E8EC66-7C4F-4561-96D0-E4FB54D294ED">
                           <p class="notep1">也可以看看：</p>
                           <p><span class="q">“ <a href="basic-language-features.html#GUID-1843167B-56CD-49CB-811B-4ACC5DF38035">宣言实施条款</a> ”</span>和<span class="q">“ <a href="basic-language-features.html#GUID-5E97C2F0-7249-48FD-A75B-AB5A465147C7">声明条款</a> ”</span></p>
                        </div>
                        <p>请考虑下表：</p><pre class="oac_no_warn" dir="ltr">CREATE TABLE PROJECTS（ID号（4），PROJNAME VARCHAR（30），START_DATE DATE，DURATION NUMBER（3））;</pre><p>您可以声明以下命名迭代器以与此表一起使用：</p><pre class="oac_no_warn" dir="ltr">#sql public iterator ProjIter（String projname，int id，Date deadline）;</pre><p>这将导致使用以下提供的访问器方法访问具有可访问数据列的迭代器类： <code class="codeph">projname()</code> ， <code class="codeph">id()</code>和<code class="codeph">deadline()</code> 。
                        </p>
                        <div class="infoboxnote" id="GUID-FF318201-3A54-450E-AC86-616665E03DE2__GUID-705999B1-3028-45E5-A9BA-C66C855CF338">
                           <p class="notep1">注意：</p>
                           <p>与标准Java一样，任何公共类都应该通过以下方式之一声明：</p>
                           <ul style="list-style-type:disc">
                              <li>
                                 <p>在单独的源文件中声明它。文件的基本名称应与类名相同。</p>
                              </li>
                              <li>
                                 <p>使用<code class="codeph">public static</code> modifiers在类级别范围或嵌套类级别范围内声明它。
                                 </p>
                              </li>
                           </ul>
                           <p>如果您使用随Sun Microsystems JDK提供的标准<code class="codeph">javac</code>编译器，则这是必需的。</p>
                        </div>
                     </div>
                     <!-- class="section" -->
                     <div class="section">
                        <p class="subhead3" id="GUID-FF318201-3A54-450E-AC86-616665E03DE2__GUID-6830C0B5-A137-4486-AE04-C66145C24AC3">实例化和填充命名迭代器</p>
                     </div>
                     <!-- class="section" -->
                     <div class="section">
                        <p>继续使用上一节中定义的<code class="codeph">PROJECTS</code>表和<code class="codeph">ProjIter</code>迭代器，请注意表中的列的名称和数据类型与迭代器的<code class="codeph">id</code>和<code class="codeph">projname</code>列匹配。但是，您必须使用别名并执行操作以填充迭代器的<code class="codeph">deadline</code>列。以下是一个例子：</p><pre class="oac_no_warn" dir="ltr">ProjIter projsIter; #sql projsIter = {SELECT start_date + duration AS deadline，projname，id FROM projects WHERE start_date + duration&gt; = sysdate};</pre><p>这会通过将每个项目的持续时间添加到其开始日期来计算每个项目的截止日期，然后将结果作为<code class="codeph">deadline</code>别名以匹配<code class="codeph">deadline</code>迭代器列。它还使用<code class="codeph">WHERE</code>子句，以便仅处理未来的截止日期，即数据库中当前系统日期之外的截止日期。
                        </p>
                        <p>同样，如果要使用函数调用，则必须创建别名。假设您有一个<code class="codeph">MAXIMUM()</code>函数，它接受<code class="codeph">DURATION</code>条目和整数作为输入，并返回两者中的最大值。例如，您可以输入值<code class="codeph">3</code>以确保每个项目在您的应用程序中至少有三个月的持续时间。
                        </p>
                        <p>现在，假设您正在声明您的迭代器，如下所示：</p><pre class="oac_no_warn" dir="ltr">#sql public iterator ProjIter2（String projname，int id，float duration）;</pre><p>您可以在查询中使用<code class="codeph">MAXIMUM()</code>函数，并使用结果的别名，如下所示：</p><pre class="oac_no_warn" dir="ltr">ProjIter2 projsIter2; #sql projsIter2 = {SELECT id，projname，maximum（duration，3）AS duration FROM projects};</pre><p>通常，必须在查询中为<code class="codeph">SELECT</code>语句中的任何数据项使用别名，该语句的名称不是合法的Java标识符，或者与迭代器中的列名不匹配。
                        </p>
                        <p>请记住，在填充命名迭代器时，从数据库中选择的列数永远不会少于迭代器中的列数。您选择的列数可能大于迭代器中的列数，因为将忽略不匹配的列。但是，除非您设置了SQLJ <code class="codeph">-warn=nostrict</code>选项，否则这将生成警告。
                        </p>
                     </div>
                     <!-- class="section" -->
                     <div class="section">
                        <p class="subhead3" id="GUID-FF318201-3A54-450E-AC86-616665E03DE2__GUID-1A2EDF2F-CE4C-4746-9017-CD587354ADD6">访问命名迭代器</p>
                     </div>
                     <!-- class="section" -->
                     <div class="section">
                        <p>使用命名迭代器对象的<code class="codeph">next()</code>方法逐步查看选中的数据。要访问每行的每一列，请使用SQLJ生成的访问器方法，通常在<code class="codeph">while</code>循环中。
                        </p>
                        <p>每当调用<code class="codeph">next()</code> ：</p>
                        <ul style="list-style-type:disc">
                           <li>
                              <p>如果要从迭代器中检索另一行，则<code class="codeph">next()</code>检索该行并返回<code class="codeph">true</code> 。
                              </p>
                           </li>
                           <li>
                              <p>如果没有要检索的行，则<code class="codeph">next()</code>返回<code class="codeph">false</code> 。
                              </p>
                           </li>
                        </ul>
                        <p>以下是如何访问命名迭代器的数据，重复上一节中说明的声明，实例化和填充代码的示例。</p>
                        <div class="infoboxnote" id="GUID-FF318201-3A54-450E-AC86-616665E03DE2__GUID-C767C43E-D4A1-4E8C-BC91-1FCB9579D411">
                           <p class="notep1">注意：</p>
                           <p>每个迭代器都有一个<code class="codeph">close()</code>方法，在完成从迭代器中检索数据时必须始终调用该方法。这是关闭迭代器并释放其资源所必需的。
                           </p>
                        </div>
                        <p>假定以下迭代器类声明：</p><pre class="oac_no_warn" dir="ltr">#sql public iterator ProjIter（String projname，int id，Date deadline）;</pre><p>填充然后访问此迭代器类的实例，如下所示：</p><pre class="oac_no_warn" dir="ltr">//声明迭代器变量ProjIter projsIter; //实例化并填充迭代器; SELECT的顺序无关紧要#sql projsIter = {SELECT start_date + duration AS deadline，projname，id FROM projects WHERE start_date + duration&gt; = sysdate}; //处理结果while（projsIter.next（））{System.out.println（“Project name is”+ projsIter.projname（））; System.out.println（“Project ID is”+ projsIter.id（））; System.out.println（“项目截止日期为”+ projsIter.deadline（））; } //关闭迭代器projsIter.close（）; ...
</pre><p>注意方便地使用<code class="codeph">projname()</code> ， <code class="codeph">id()</code>和<code class="codeph">deadline()</code>访问器方法来检索数据。另请注意， <code class="codeph">SELECT</code>项的顺序无关紧要，访问器方法的顺序也不重要。
                        </p>
                        <p>但是，请记住，使用与迭代器类的声明中完全相同的情况创建访问器方法名称。以下将生成编译错误。</p>
                        <p>考虑以下迭代器声明：</p><pre class="oac_no_warn" dir="ltr">#sql iterator Cursor1（String NAME）;</pre><p>使用迭代器的代码如下：</p><pre class="oac_no_warn" dir="ltr">...Cursor1 c1; #sql c1 = {SELECT NAME FROM TABLE}; while（c1.next（））{System.out.println（“名称是”+ c1.name（））; } ...
</pre><p><code class="codeph">Cursor1</code>类有一个名为<code class="codeph">NAME()</code>的方法，而不是<code class="codeph">name()</code> 。你将不得不使用<code class="codeph">c1.<code class="codeph">System.out.println</code>语句中的NAME()</code> 。
                        </p>
                     </div>
                     <!-- class="section" -->
                  </div>
               </div><a id="JSQLJ330"></a><a id="JSQLJ331"></a><a id="JSQLJ332"></a><a id="JSQLJ333"></a><a id="JSQLJ329"></a><div class="props_rev_3"><a id="GUID-C99760AC-46A2-446C-8CA6-D032FC4C303D" name="GUID-C99760AC-46A2-446C-8CA6-D032FC4C303D"></a><h4 id="JSQLJ-GUID-C99760AC-46A2-446C-8CA6-D032FC4C303D" class="sect4">使用位置迭代器</h4>
                  <div>
                     <div class="section">
                        <p>声明位置迭代器类时，声明每列的数据类型，但不声明列名。选择SQL查询结果列的Java类型必须与SQL数据的数据类型兼容。<code class="codeph">SELECT</code>语句中的数据库列或数据项的名称无关紧要。由于未使用名称，因此声明位置迭代器Java类型的顺序必须与选择数据的顺序完全匹配。
                        </p>
                        <p>要在选择数据后从位置迭代器中检索数据，请使用<code class="codeph">FETCH INTO</code>语句，然后调用<code class="codeph">endFetch()</code>方法来确定是否已到达数据的末尾。
                        </p>
                     </div>
                     <!-- class="section" -->
                     <div class="section">
                        <p class="subhead3" id="GUID-C99760AC-46A2-446C-8CA6-D032FC4C303D__GUID-771CB95C-D599-40CA-B350-9DC83E0DE08F">声明位置迭代器类</p>
                     </div>
                     <!-- class="section" -->
                     <div class="section">
                        <p>使用以下语法声明位置迭代器类：</p><pre class="oac_no_warn" dir="ltr">#sql &lt; <span class="italic">modifiers</span> &gt; iterator <span class="italic">classname</span> &lt; <span class="italic">implements子句</span> &gt; &lt; <span class="italic">with clause</span> &gt;（ <span class="italic">position-list</span> ）;</pre><p>在此语法中， <span class="italic"><code class="codeph">modifiers</code></span>是合法Java类修饰符的可选序列<code class="codeph"> </code> <span class="italic"><code class="codeph">position-list</code></span>是与数据库表中的列类型兼容的Java类型列表。
                        </p>
                        <p><code class="codeph">implements</code>子句和<code class="codeph">with</code>子句是可选的，分别指定要实现的接口和要定义和初始化的变量。
                        </p>
                        <div class="infoboxnotealso" id="GUID-C99760AC-46A2-446C-8CA6-D032FC4C303D__GUID-A3A74746-D86E-4C8D-9030-2BEDA19D0580">
                           <p class="notep1">也可以看看：</p>
                           <p><span class="q">“ <a href="basic-language-features.html#GUID-1843167B-56CD-49CB-811B-4ACC5DF38035">宣言实施条款</a> ”</span>和<span class="q">“ <a href="basic-language-features.html#GUID-5E97C2F0-7249-48FD-A75B-AB5A465147C7">声明条款</a> ”</span></p>
                        </div>
                        <p>现在考虑具有以下行的员工表<code class="codeph">EMP</code> ：</p><pre class="oac_no_warn" dir="ltr">CREATE TABLE EMP（EMPNO NUMBER（4），ENAME VARCHAR2（10），SAL NUMBER（7,2））;</pre><p>并考虑以下位置迭代器声明：</p><pre class="oac_no_warn" dir="ltr">#sql public iterator EmpIter（String，int，float）;</pre><p>此示例使用未命名的<code class="codeph">String</code> ， <code class="codeph">int</code>和<code class="codeph">float</code>列定义<code class="codeph">EmpIter</code> Java类。请注意，表列和迭代器列的顺序不同， <code class="codeph">String</code>对应于<code class="codeph">ENAME</code> ， <code class="codeph">int</code>对应于<code class="codeph">EMPNO</code> 。迭代器列的顺序决定了您必须选择数据的顺序。
                        </p>
                        <div class="infoboxnote" id="GUID-C99760AC-46A2-446C-8CA6-D032FC4C303D__GUID-2CBB7430-DE41-437C-8778-A341136A1517">
                           <p class="notep1">注意：</p>
                           <p>与标准Java一样，任何公共类都应该通过以下方式之一声明：</p>
                           <ul style="list-style-type:disc">
                              <li>
                                 <p>在单独的源文件中声明它。文件的基本名称应与类名相同。</p>
                              </li>
                              <li>
                                 <p>使用<code class="codeph">public static</code> modifiers在类级别范围或嵌套类级别范围内声明它。
                                 </p>
                              </li>
                           </ul>
                           <p>如果您使用随Sun Microsystems JDK提供的标准<code class="codeph">javac</code>编译器，则这是必需的。</p>
                        </div>
                     </div>
                     <!-- class="section" -->
                     <div class="section">
                        <p class="subhead3" id="GUID-C99760AC-46A2-446C-8CA6-D032FC4C303D__GUID-33304924-36DD-48B5-A121-F175D5F0A1AD">实例化和填充位置迭代器</p>
                     </div>
                     <!-- class="section" -->
                     <div class="section">
                        <p>实例化和填充位置迭代器与对命名迭代器这样做没有什么不同，除了您必须确定<code class="codeph">SELECT</code>语句中的数据项的顺序正确。
                        </p>
                        <p><code class="codeph">EmpIter</code>迭代器类中的三种数据类型与<code class="codeph">EMP</code>表的类型兼容，但要小心选择数据的方式，因为顺序不同。以下内容将起作用，因为<code class="codeph">SELECT</code>语句中的数据项与迭代器列的顺序相同：</p><pre class="oac_no_warn" dir="ltr">EmpIter empsIter; #sql empsIter = {SELECT ename，empno，sal FROM emp};</pre><p>请记住，在填充位置迭代器时，从数据库中选择的列数必须等于迭代器中的列数。</p>
                     </div>
                     <!-- class="section" -->
                     <div class="section">
                        <p class="subhead3" id="GUID-C99760AC-46A2-446C-8CA6-D032FC4C303D__GUID-2DA51CA7-2959-420B-B9E2-31F868A2A4BD">访问位置迭代器</p>
                     </div>
                     <!-- class="section" -->
                     <div class="section">
                        <p>使用SQL <code class="codeph">FETCH INTO</code>语法访问由位置迭代器定义的列。命令的<code class="codeph">INTO</code>部分指定接收结果列的Java主变量。主变量的顺序必须与相应的迭代器列的顺序相同。使用随所有位置迭代器类提供的<code class="codeph">endFetch()</code>方法来确定最后一次获取是否到达数据末尾。
                        </p>
                        <div class="infoboxnote" id="GUID-C99760AC-46A2-446C-8CA6-D032FC4C303D__GUID-0A030C03-CFF8-4158-9334-E0C310B1FD1E">
                           <p class="notep1">注意：</p>
                           <ul style="list-style-type:disc">
                              <li>
                                 <p><code class="codeph">endFetch()</code>方法最初在获取任何行之前返回<code class="codeph">true</code> ，然后在成功检索到行后返回<code class="codeph">false</code> ，然后在<code class="codeph">FETCH</code>找不到要检索的行时再次返回<code class="codeph">true</code> 。因此，必须在<code class="codeph">FETCH INTO</code>语句<span class="italic">之后</span>执行<code class="codeph">endFetch()</code>测试。如果你的<code class="codeph">endFetch()</code>测试在<code class="codeph">FETCH INTO</code>语句之前，那么你将永远不会检索任何行，因为在第一个<code class="codeph">FETCH</code>之前<code class="codeph">endFetch()</code>将为真，你会立即突破<code class="codeph">while</code>循环。
                                 </p>
                              </li>
                              <li>
                                 <p><code class="codeph">endFetch()</code>测试必须<span class="italic">在</span>处理结果<span class="italic">之前</span> ，但是，因为<code class="codeph">FETCH</code>在到达数据末尾时不会抛出SQL异常，它只是触发下一个<code class="codeph">endFetch()</code>调用以返回<code class="codeph">true</code> 。如果在处理结果之前没有<code class="codeph">endFetch()</code>测试，则在达到数据结束后，您的代码将尝试处理来自第一次<code class="codeph">FETCH</code>尝试的<code class="codeph">NULL</code>或无效数据。
                                 </p>
                              </li>
                              <li>
                                 <p>每个迭代器都有一个<code class="codeph">close()</code>方法，一旦完成从中检索数据，就必须始终调用该方法。这是关闭迭代器并释放其资源所必需的。
                                 </p>
                              </li>
                           </ul>
                        </div>
                        <p>以下是一个示例，重复上一节中说明的声明，实例化和填充代码。请注意， <code class="codeph">SELECT</code>语句中的Java主变量与位置迭代器的列的顺序相同，这是必需的。
                        </p>
                        <p>首先，假设以下迭代器类声明：</p><pre class="oac_no_warn" dir="ltr">#sql public iterator EmpIter（String，int，float）;</pre><p>填充然后访问此迭代器类的实例，如下所示：</p><pre class="oac_no_warn" dir="ltr">//声明并初始化主变量int empnum = 0; String empname = null;浮动薪水= 0.0f; //声明一个迭代器实例EmpIter empsIter; #sql empsIter = {SELECT first_name，employee_id，salary FROM employees}; while（true）{#sql {FETCH：empsIter INTO：empnum，：empname，：salary}; if（empsIter.endFetch（））中断; //此测试必须是AFTER fetch，//但在处理结果之前。System.out.println（“Name is”+ empname）; System.out.println（“员工编号为”+ empnum）; System.out.println（“薪水是”+薪水）; } //关闭迭代器empsIter.close（）; ...
</pre><p><code class="codeph">empname</code> ， <code class="codeph">empnum</code>和<code class="codeph">salary</code>变量是Java主变量，其类型必须与迭代器列的类型匹配。
                        </p>
                        <p>不要将<code class="codeph">next()</code>方法用于位置迭代器。<code class="codeph">FETCH</code>操作隐式调用它以移动到下一行。
                        </p>
                        <div class="infoboxnote" id="GUID-C99760AC-46A2-446C-8CA6-D032FC4C303D__GUID-272B10F7-1CDD-4E88-B33B-9C5EAD83DF26">
                           <p class="notep1">注意：</p>
                           <p>必须始终初始化<code class="codeph">FETCH INTO</code>语句中的主机变量，因为它们是在条件语句的一个分支中分配的。否则，您将收到编译器错误，指示可能永远不会分配它们。只有在要提取的行时， <code class="codeph">FETCH</code>才能分配变量。
                           </p>
                        </div>
                     </div>
                     <!-- class="section" -->
                     <div class="section">
                        <p class="subhead3" id="GUID-C99760AC-46A2-446C-8CA6-D032FC4C303D__GUID-8221C595-3FAF-48CC-B059-CA01C7421848">使用next（）方法定位迭代器导航</p>
                     </div>
                     <!-- class="section" -->
                     <div class="section">
                        <p>上一节中讨论的位置迭代器<code class="codeph">FETCH</code>子句在填充主变量（如果有<code class="codeph">next()</code>之前执行一个移动，一个隐式的<code class="codeph">next()</code>调用。作为替代方案，Oracle SQLJ实现支持特殊的<code class="codeph">FETCH</code>语法以及显式的<code class="codeph">next()</code>调用，以便使用与JDBC结果集和SQLJ命名迭代器相同的移动逻辑。使用这种特殊的<code class="codeph">FETCH</code>语法，语义不同。在填充<code class="codeph">INTO</code> -list之前没有隐式的<code class="codeph">next()</code>调用。
                        </p>
                     </div>
                     <!-- class="section" -->
                  </div>
               </div><a id="JSQLJ335"></a><a id="JSQLJ336"></a><a id="JSQLJ337"></a><a id="JSQLJ334"></a><div class="props_rev_3"><a id="GUID-D3CC3825-1F5D-45AF-9E96-5848B98B7D21" name="GUID-D3CC3825-1F5D-45AF-9E96-5848B98B7D21"></a><h4 id="JSQLJ-GUID-D3CC3825-1F5D-45AF-9E96-5848B98B7D21" class="sect4">使用迭代器和结果集作为主机变量</h4>
                  <div>
                     <div class="section">
                        <p>SQLJ支持SQLJ迭代器和JDBC结果集作为主机变量。使用迭代器和结果集基本相同，声明和访问器方法在检索数据方面存在差异。</p>
                        <div class="infoboxnote" id="GUID-D3CC3825-1F5D-45AF-9E96-5848B98B7D21__GUID-1B398F78-8B77-4B88-BC97-E120383A09F4">
                           <p class="notep1">注意：</p>
                           <ul style="list-style-type:disc">
                              <li>
                                 <p>此外，SQLJ支持迭代器和结果集作为存储函数的返回变量。</p>
                              </li>
                              <li>
                                 <p>Oracle JDBC驱动程序当前<span class="italic">不</span>支持结果集作为输入主机变量。<code class="codeph">OraclePreparedStatement</code>类中有一个<code class="codeph">setCursor()</code>方法，但如果调用它会在运行时引发异常。
                                 </p>
                              </li>
                           </ul>
                        </div>
                        <p>对于本节中的示例，请考虑以下部门和员工表：</p><pre class="oac_no_warn" dir="ltr">CREATE TABLE DEPT（DEPTNO NUMBER（2），DNAME VARCHAR2（14））; CREATE TABLE EMP（EMPNO NUMBER（4），ENAME VARCHAR2（10），SAL NUMBER（7,2），DEPTNO NUMBER（2））;</pre></div>
                     <!-- class="section" -->
                     <div class="section">
                        <p class="subhead3" id="GUID-D3CC3825-1F5D-45AF-9E96-5848B98B7D21__GUID-21637270-642D-4204-87A3-BFCEEA13D6ED">示例：使用结果集作为OUT主变量</p>
                     </div>
                     <!-- class="section" -->
                     <div class="section">
                        <p>此示例使用JDBC结果集作为输出主机变量。</p><pre class="oac_no_warn" dir="ltr">...ResultSet rs; ...#sql {BEGIN OPEN：OUT rs FOR SELECT ename，empno FROM emp;结束 }; while（rs.next（））{String empname = rs.getString（1）; int empnum = rs.getInt（2）; } rs.close（）; ...
</pre><p>此示例在PL / SQL块中打开结果集<code class="codeph">rs</code>以从<code class="codeph">SELECT</code>语句接收数据，从<code class="codeph">EMP</code>表的<code class="codeph">ENAME</code>和<code class="codeph">EMPNO</code>列中选择数据，然后循环遍历结果集以将数据检索到本地变量。
                        </p>
                     </div>
                     <!-- class="section" -->
                     <div class="section">
                        <p class="subhead3" id="GUID-D3CC3825-1F5D-45AF-9E96-5848B98B7D21__GUID-3C515AC9-C1DE-428B-B5B1-0B450600524A">示例：使用Iterator作为OUT主变量</p>
                     </div>
                     <!-- class="section" -->
                     <div class="section">
                        <p>此示例使用命名迭代器作为输出主机变量。</p>
                        <p>迭代器可以声明如下：</p><pre class="oac_no_warn" dir="ltr">#sql public &lt;static&gt; iterator EmpIter（String ename，int empno）;</pre><p><code class="codeph">public</code>修饰符是必需的，如果声明是在类级别或嵌套级别级别，则建议使用<code class="codeph">static</code>修饰符。
                        </p>
                        <p>这个迭代器可以用如下：</p><pre class="oac_no_warn" dir="ltr">...更重要的是; ...#sql {BEGIN OPEN：OUT iter FOR SELECT ename，empno FROM emp;结束 }; while（iter.next（））{String empname = iter.ename（）; int empnum = iter.empno（）; ... <span class="italic">进程/输出empname和empnum</span> ...} iter.close（）; ...
</pre><p>此示例在PL / SQL块中打开迭代器<code class="codeph">iter</code>以从<code class="codeph">SELECT</code>语句接收数据，从<code class="codeph">EMP</code>表的<code class="codeph">ENAME</code>和<code class="codeph">EMPNO</code>列中选择数据，然后循环遍历迭代器以将数据检索到本地变量。
                        </p>
                     </div>
                     <!-- class="section" -->
                     <div class="section">
                        <p class="subhead3" id="GUID-D3CC3825-1F5D-45AF-9E96-5848B98B7D21__GUID-A79C1BA2-6116-4785-A780-A19C1A87DC58">示例：将Iterator用作SELECT INTO的OUT主变量</p>
                     </div>
                     <!-- class="section" -->
                     <div class="section">
                        <p>此示例使用命名迭代器作为输出主机变量，通过<code class="codeph">SELECT INTO</code>语句获取数据。<code class="codeph">OUT</code>是<code class="codeph">INTO</code> -list中主机变量的默认值。
                        </p>
                        <p>迭代器可以声明如下：</p><pre class="oac_no_warn" dir="ltr">#sql public &lt;static&gt; iterator ENameIter（String ename）;</pre><p><code class="codeph">public</code>修饰符是必需的，如果声明是在类级别或嵌套级别级别，则建议使用<code class="codeph">static</code>修饰符。
                        </p>
                        <p>这个迭代器可以用如下：</p><pre class="oac_no_warn" dir="ltr">...ENameIter enamesIter;字符串deptname; ...#sql {SELECT dname，cursor（SELECT ename FROM emp WHERE deptno = dept.deptno）INTO：deptname，：enamesIter FROM dept WHERE deptno = 20};的System.out.println（DEPTNAME）; while（enamesIter.next（））{System.out.println（enamesIter.ename（））; } enamesIter.close（）; ...
</pre><p>此示例使用嵌套的<code class="codeph">SELECT</code>语句来完成以下操作：</p>
                        <ul style="list-style-type:disc">
                           <li>
                              <p>从<code class="codeph">DEPT</code>表中选择部门号20的名称，将其选择为<code class="codeph">deptname</code>输出主机变量。
                              </p>
                           </li>
                           <li>
                              <p>查询<code class="codeph">EMP</code>表以选择部门号为20的所有员工，将结果光标选择到<code class="codeph">enamesIter</code>输出主变量中，该变量是命名迭代器。
                              </p>
                           </li>
                           <li>
                              <p>打印部门名称。</p>
                           </li>
                           <li>
                              <p>循环遍历命名迭代器打印员工姓名。这将打印部门中所有员工的姓名。</p>
                           </li>
                        </ul>
                        <p>在大多数情况下，如果要检索外部<code class="codeph">SELECT</code>的单个行，则使用<code class="codeph">SELECT INTO</code>比使用嵌套迭代器更方便，尽管该选项也可用。此外，对于嵌套迭代器，您必须处理数据以确定外部<code class="codeph">SELECT</code>有多少行。使用<code class="codeph">SELECT INTO</code>您可以确保只有一行。
                        </p>
                     </div>
                     <!-- class="section" -->
                  </div>
               </div><a id="JSQLJ339"></a><a id="JSQLJ340"></a><a id="JSQLJ341"></a><a id="JSQLJ338"></a><div class="props_rev_3"><a id="GUID-A8BA5DEF-6CA2-4C06-8073-0F475851B7CA" name="GUID-A8BA5DEF-6CA2-4C06-8073-0F475851B7CA"></a><h4 id="JSQLJ-GUID-A8BA5DEF-6CA2-4C06-8073-0F475851B7CA" class="sect4">使用迭代器和结果集作为迭代器列</h4>
                  <div>
                     <div class="section">
                        <p>Oracle SQLJ实现包括允许迭代器声明指定<code class="codeph">ResultSet</code>类型的列或在当前作用域内声明的其他迭代器类型的列的扩展。换句话说，迭代器和结果集可以存在于迭代器中。这些列类型用于以游标的形式检索列。这对于返回嵌套表信息的嵌套<code class="codeph">SELECT</code>语句很有用。
                        </p>
                        <p>以下示例在功能上是相同的。每个都使用嵌套的结果集或迭代器，即迭代器中的列中的结果集或迭代器，来打印<code class="codeph">DEPT</code>表中每个部门的所有员工。第一个示例在命名迭代器中使用结果集，第二个示例在命名迭代器中使用命名迭代器，第三个示例在位置迭代器中使用命名迭代器。
                        </p>
                        <p>以下是步骤：</p>
                     </div>
                     <!-- class="section" -->
                     <ol>
                        <li><span>从<code class="codeph">DEPT</code>表中选择每个部门名称（ <code class="codeph">DNAME</code> ）。</span></li>
                        <li><span>对游标执行嵌套<code class="codeph">SELECT</code>以从每个部门的<code class="codeph">EMP</code>表中获取所有员工。</span></li>
                        <li><span>将部门名称和雇员集放入外部迭代器（ <code class="codeph">iter</code> ），它具有名称列和迭代器列。带有任何给定部门的员工信息的游标进入与部门对应的外部迭代器行的迭代器列。</span></li>
                        <li><span>通过一个嵌套循环，为每个部门打印部门名称，然后遍历内部迭代器以打印该部门的所有员工姓名。</span></li>
                     </ol>
                     <div class="example" id="GUID-A8BA5DEF-6CA2-4C06-8073-0F475851B7CA__GUID-3BFEAA22-5407-4AA4-A0FD-017AE2E98BB8">
                        <p class="titleinexample">示例5-1示例：命名迭代器中的结果集列</p>
                        <p>此示例在命名迭代器中使用<code class="codeph">ResultSet</code>类型的列。
                        </p>
                        <p>迭代器可以声明如下：</p><pre class="oac_no_warn" dir="ltr">#sql iterator DeptIter（String dname，ResultSet \ temps）;</pre><p>使用迭代器的代码如下：</p><pre class="oac_no_warn" dir="ltr">...解决这个问题; ...#sql iter = {SELECT dname，cursor（SELECT ename FROM emp WHERE deptno = dept.deptno）AS emps FROM dept}; while（iter.next（））{System.out.println（iter.dname（））; ResultSet enamesRs = iter.emps（）; while（enamesRs.next（））{String empname = enamesRs.getString（1）;的System.out.println（empname）; } enamesRs.close（）; } iter.close（）; ...</pre></div>
                     <!-- class="example" -->
                     <div class="example" id="GUID-A8BA5DEF-6CA2-4C06-8073-0F475851B7CA__GUID-D4A615E6-3725-4DBE-9740-4DF4734057CE">
                        <p class="titleinexample">示例5-2示例：命名迭代器中的命名迭代器列</p>
                        <p>此示例使用一个命名迭代器，该迭代器的列类型是先前定义的命名迭代器（嵌套迭代器）的类型。</p>
                        <p>迭代器声明如下：</p><pre class="oac_no_warn" dir="ltr">#sql iterator ENameIter（String ename）; #sql iterator DeptIter（String dname，ENameIter emps）;</pre><p>使用此迭代器的代码如下：</p><pre class="oac_no_warn" dir="ltr">...解决这个问题; ...#sql iter = {SELECT dname，cursor（SELECT ename FROM emp WHERE deptno = dept.deptno）AS emps FROM dept}; while（iter.next（））{System.out.println（iter.dname（））; ENameIter enamesIter = iter.emps（）; while（enamesIter.next（））{System.out.println（enamesIter.ename（））; } enamesIter.close（）; } iter.close（）; ...</pre></div>
                     <!-- class="example" -->
                     <div class="example" id="GUID-A8BA5DEF-6CA2-4C06-8073-0F475851B7CA__GUID-469E7D04-09B1-4E45-AA8C-E5AB756EC4B8">
                        <p class="titleinexample">示例5-3示例：位置迭代器中的命名迭代器列</p>
                        <p>此示例使用一个位置迭代器，该迭代器的列类型是先前定义的命名迭代器（嵌套迭代器）的类型。这使用位置迭代器的<code class="codeph">FETCH INTO</code>语法。此示例在功能上等同于前两个。
                        </p>
                        <p>请注意，因为外部迭代器是位置迭代器，所以不必使用别名来匹配列名，这在外部迭代器是上一个示例中的命名迭代器时是必需的。</p>
                        <p>迭代器声明如下：</p><pre class="oac_no_warn" dir="ltr">#sql iterator ENameIter（String ename）; #sql iterator DeptIter（String，ENameIter）;</pre><p>使用此迭代器的代码如下：</p><pre class="oac_no_warn" dir="ltr">...解决这个问题; ...#sql iter = {SELECT dname，cursor（SELECT ename FROM emp WHERE deptno = dept.deptno）FROM dept}; while（true）{String dname = null; ENameIter enamesIter = null; #sql {FETCH：iter INTO：dname，：enamesIter}; if（iter.endFetch（））中断;的System.out.println（DNAME）; while（enamesIter.next（））{System.out.println（enamesIter.ename（））; } enamesIter.close（）; } iter.close（）; ...</pre></div>
                     <!-- class="example" -->
                  </div>
               </div>
            </div><a id="JSQLJ342"></a><div class="props_rev_3"><a id="GUID-74814900-4067-4EE0-B74B-A9A5F5DED86C" name="GUID-74814900-4067-4EE0-B74B-A9A5F5DED86C"></a><h3 id="JSQLJ-GUID-74814900-4067-4EE0-B74B-A9A5F5DED86C" class="sect3">作业陈述（SET）</h3>
               <div>
                  <p>SQLJ使您可以为SQL操作内的Java主机表达式赋值。这称为赋值语句，使用以下语法完成：</p><pre class="oac_no_warn" dir="ltr">#sql {SET： <span class="italic">host_exp</span> = <span class="italic">expression</span> };</pre><p><span class="italic"><code class="codeph">host_exp</code></span>是目标主机表达式，例如变量或数组索引。<span class="italic"><code class="codeph">expression</code></span>可以是数字，主表达式，算术表达式，函数调用或其他构造，它们将有效结果生成到目标主机表达式中。
                  </p>
                  <p>赋值语句中的目标主机表达式的默认值为<code class="codeph">OUT</code> ，但您可以选择明确说明：</p><pre class="oac_no_warn" dir="ltr">#sql {SET：OUT <span class="italic">host_exp</span> = <span class="italic">expression</span> };</pre><p>尝试在赋值语句中使用<code class="codeph">IN</code>或<code class="codeph">INOUT</code>标记将导致转换时出错。
                  </p>
                  <p>前面的语句在功能上等同于以下PL / SQL代码：</p><pre class="oac_no_warn" dir="ltr">#sql {BEGIN：OUT <span class="italic">host_exp</span> ：= <span class="italic">expression</span> ;结束 };</pre><p>这是一个赋值语句的简单示例：</p><pre class="oac_no_warn" dir="ltr">#sql {SET：x = foo1（）+ foo2（）};</pre><p>该语句将<code class="codeph">foo1()</code>和<code class="codeph">foo2()</code>的返回值之和分配给<code class="codeph">x</code> ，并假设<code class="codeph">x</code>的类型与这些函数的输出之和的类型兼容。
                  </p>
                  <p>请考虑以下附加示例：</p><pre class="oac_no_warn" dir="ltr">int i2; java.sql中。日期数据; ...#sql {SET：i2 = TO_NUMBER（substr（'750 etc.'，1,3））+ TO_NUMBER（substr（'250 etc.'，1,3））}; ...#sql {SET：dat = sysdate}; ...
</pre><p>第一个语句将为<code class="codeph">i2</code>赋值<code class="codeph">1000</code> 。<code class="codeph">substr()</code>调用接受字符串的前三个字符，即“750”和“250”。<code class="codeph">TO_NUMBER()</code>调用将字符串转换为数字750和250。
                  </p>
                  <p>第二个语句将读取数据库系统日期并将其分配给<code class="codeph">dat</code> 。
                  </p>
                  <p>当您对存储在数据库中的函数执行返回变量的操作时，赋值语句特别有用。您不需要赋值语句来简单地将函数结果赋给变量，因为您可以使用标准函数调用语法来完成此操作。您也不需要赋值语句来操作Java函数的输出，因为您可以在典型的Java语句中完成该操作。所以你可以假设<code class="codeph">foo1()</code>和<code class="codeph">foo2()</code>是数据库中存储的函数，而不是Java函数。
                  </p>
               </div>
            </div><a id="JSQLJ343"></a><div class="props_rev_3"><a id="GUID-3FC4A9CC-9B63-4010-B842-0BDEA19C8C3B" name="GUID-3FC4A9CC-9B63-4010-B842-0BDEA19C8C3B"></a><h3 id="JSQLJ-GUID-3FC4A9CC-9B63-4010-B842-0BDEA19C8C3B" class="sect3">存储过程和函数调用</h3>
               <div>
                  <p>SQLJ为在数据库中调用存储过程和存储函数提供了方便的语法。这些过程和函数可以用Java，PL / SQL或数据库支持的任何其他语言编写。</p>
                  <p>存储函数需要SQLJ可执行语句中的结果表达式来接受返回值，并且可选地还可以获取输入，输出或输入输出参数。</p>
                  <p>存储过程没有返回值。可选地，它可以采用输入，输出或输入 - 输出参数。存储过程可以通过任何输出或输入输出参数返回输出。</p>
                  <p>本节包括以下主题：</p>
                  <ul style="list-style-type:disc">
                     <li>
                        <p><a href="basic-language-features.html#GUID-CDDD7913-A445-4BB3-8193-1A3C75A577C5">调用存储过程</a></p>
                     </li>
                     <li>
                        <p><a href="basic-language-features.html#GUID-18E7A8FC-D16A-4A57-9A9E-B85919E9160D">调用存储函数</a></p>
                     </li>
                     <li>
                        <p><a href="basic-language-features.html#GUID-F45F4FF0-6D2A-455D-A8A0-0BC3770845B2">使用迭代器和结果集作为存储函数返回</a></p>
                     </li>
                  </ul>
               </div><a id="JSQLJ344"></a><div class="props_rev_3"><a id="GUID-CDDD7913-A445-4BB3-8193-1A3C75A577C5" name="GUID-CDDD7913-A445-4BB3-8193-1A3C75A577C5"></a><h4 id="JSQLJ-GUID-CDDD7913-A445-4BB3-8193-1A3C75A577C5" class="sect4">调用存储过程</h4>
                  <div>
                     <div class="section">
                        <p>存储过程没有返回值，但可以采用带有输入，输出和输入输出参数的列表。存储过程调用使用<code class="codeph">CALL</code>标记。<code class="codeph">CALL</code>令牌后跟空格，然后是过程名称。<code class="codeph">CALL</code>令牌后面必须有一个空格，以区别于过程名称。过程调用周围<span class="italic">不能</span>有一组外括号。这与函数调用的语法不同。<code class="codeph">CALL</code>令牌的语法如下：</p><pre class="oac_no_warn" dir="ltr">#sql {CALL <span class="italic">PROC</span> （&lt; <span class="italic">PARAM_LIST&gt;</span> ）};</pre><p><span class="italic"><code class="codeph">PROC</code></span>是存储过程的名称，可以选择获取输入，输出和输入输出参数列表。<span class="italic"><code class="codeph">PROC</code></span>也可以包含模式或包名称，例如<code class="codeph">HR.MYPROC()</code> 。
                        </p>
                        <p>假定您已定义以下PL / SQL存储过程：</p><pre class="oac_no_warn" dir="ltr">创建或替换程序MAX_DEADLINE（截止日期OUT DATE）是BEGIN SELECT MAX（start_date + duration）INTO截止日期FROM项目;结束;</pre><p>这将读取<code class="codeph">PROJECTS</code>表，查看<code class="codeph">START_DATE</code>和<code class="codeph">DURATION</code>列，计算每行中的<code class="codeph">start_date + duration</code> ，然后获取最大<code class="codeph">START_DATE + DURATION</code>总计，并将其分配给<code class="codeph">DEADLINE</code> ，这是<code class="codeph">DATE</code>类型的输出参数。</p>
                        <p>在SQLJ中，您可以按如下方式调用此<code class="codeph">MAX_DEADLINE</code>过程：</p><pre class="oac_no_warn" dir="ltr">java.sql中。日期maxDeadline; ...#sql {CALL MAX_DEADLINE（：out maxDeadline）};</pre><p>对于任何参数，必须适当地使用主机表达式标记<code class="codeph">IN</code> ， <code class="codeph">OUT</code>和<code class="codeph">INOUT</code> ，以匹配存储过程的输入，输出和输入输出指定。此外，您在参数列表中使用的主机变量的类型必须与存储过程的参数类型兼容。
                        </p>
                        <div class="infoboxnote" id="GUID-CDDD7913-A445-4BB3-8193-1A3C75A577C5__GUID-D2058647-C09A-4DFA-AEFC-B079AF2D619E">
                           <p class="notep1">注意：</p>
                           <p>如果你希望你的应用程序与数据库的Oracle7兼容，那么<span class="italic">不</span>包括参数一览表空括号如果程序不带任何参数。例如：</p><pre class="oac_no_warn" dir="ltr"><code class="codeph">#sql {CALL MAX_DEADLINE};</code></pre><p>不：</p><pre class="oac_no_warn" dir="ltr"><code class="codeph">#sql {CALL MAX_DEADLINE（）};</code></pre></div>
                     </div>
                     <!-- class="section" -->
                  </div>
               </div><a id="JSQLJ345"></a><div class="props_rev_3"><a id="GUID-18E7A8FC-D16A-4A57-9A9E-B85919E9160D" name="GUID-18E7A8FC-D16A-4A57-9A9E-B85919E9160D"></a><h4 id="JSQLJ-GUID-18E7A8FC-D16A-4A57-9A9E-B85919E9160D" class="sect4">调用存储函数</h4>
                  <div>
                     <div class="section">
                        <p>存储函数具有返回值，还可以获取输入，输出和输入输出参数列表。存储函数调用使用<code class="codeph">VALUES</code>标记。<code class="codeph">VALUES</code>标记之后是函数调用。在标准SQLJ中，函数调用必须包含在一组外括号中。在Oracle SQLJ实现中，外括号是可选的。使用外括号时， <code class="codeph">VALUES</code>标记和开始括号之间是否有空格并不重要。<code class="codeph">VALUES</code>标记的语法如下：</p><pre class="oac_no_warn" dir="ltr">#sql <span class="italic">result</span> = {VALUES（ <span class="italic">FUNC</span> （ <span class="italic">PARAM_LIST</span> ））};</pre><p>在此语法中， <span class="italic"><code class="codeph">result</code></span>是结果表达式，它接受函数返回值。<span class="italic"><code class="codeph">FUNC</code></span>是存储函数的名称，可以选择获取输入，输出和输入输出参数列表。<span class="italic"><code class="codeph">FUNC</code></span>可以包含模式或包名称，例如<code class="codeph">HR.MYFUNC()</code> 。
                        </p>
                        <div class="infoboxnote" id="GUID-18E7A8FC-D16A-4A57-9A9E-B85919E9160D__GUID-F606890D-B9CB-406F-95D4-24E2E894EBDB">
                           <p class="notep1">注意：</p>
                           <p><code class="codeph">VALUES</code>标记也可以在Oracle SQL实现支持的<code class="codeph">INSERT INTO</code> <span class="italic"><code class="codeph">table</code></span> <code class="codeph">VALUES</code>语法中使用，但这些情况在语义和语法上是不相关的。
                           </p>
                        </div>
                        <p>回头参考<span class="q">“ <a href="basic-language-features.html#GUID-CDDD7913-A445-4BB3-8193-1A3C75A577C5">调用存储过程</a> ”中</span>的示例，考虑将存储过程定义为存储函数，如下所示：</p><pre class="oac_no_warn" dir="ltr">创建或替换功能GET_MAX_DEADLINE返回日期是截止日期DATE; BEGIN SELECT MAX（start_date + duration）INTO截止日期FROM项目;返回截止日期;结束;</pre><p>在SQLJ中，您可以按如下方式调用此<code class="codeph">GET_MAX_DEADLINE</code>函数：</p><pre class="oac_no_warn" dir="ltr">java.sql中。日期maxDeadline; ...#sql maxDeadline = {VALUES（GET_MAX_DEADLINE）};</pre><p>结果表达式必须具有与函数的返回类型兼容的类型。</p>
                        <p>在Oracle SQLJ实现中，还允许使用以下语法：</p><pre class="oac_no_warn" dir="ltr">#sql maxDeadline = {VALUES GET_MAX_DEADLINE};</pre><p>请注意，省略了外括号。</p>
                        <p>对于存储函数调用，与存储过程一样，必须适当地使用主机表达式标记<code class="codeph">IN</code> ， <code class="codeph">OUT</code>和<code class="codeph">INOUT</code> ，以匹配存储函数的输入，输出和输入 - 输出参数。此外，您在参数列表中使用的主机变量类型必须与存储函数的参数类型兼容。
                        </p>
                        <div class="infoboxnote" id="GUID-18E7A8FC-D16A-4A57-9A9E-B85919E9160D__GUID-BF91927A-251B-405F-9A6B-334C6E449500">
                           <p class="notep1">注意：</p>
                           <p>如果希望存储的函数可以移植到非Oracle环境中，那么您应该只使用调用序列中的输入参数，而不是输出或输入输出参数。</p>
                        </div>
                     </div>
                     <!-- class="section" -->
                  </div>
               </div><a id="JSQLJ347"></a><a id="JSQLJ346"></a><div class="props_rev_3"><a id="GUID-F45F4FF0-6D2A-455D-A8A0-0BC3770845B2" name="GUID-F45F4FF0-6D2A-455D-A8A0-0BC3770845B2"></a><h4 id="JSQLJ-GUID-F45F4FF0-6D2A-455D-A8A0-0BC3770845B2" class="sect4">使用迭代器和结果集作为存储函数返回</h4>
                  <div>
                     <div class="section">
                        <p>如果函数返回REF CURSOR类型，SQLJ支持将存储函数的返回值赋给迭代器或结果集变量。</p>
                        <p>以下示例使用迭代器来获取存储函数返回。使用结果集是类似的。</p>
                     </div>
                     <!-- class="section" -->
                     <div class="section">
                        <p class="subhead3" id="GUID-F45F4FF0-6D2A-455D-A8A0-0BC3770845B2__GUID-C602C78E-655D-46D1-AB5F-0C3217D1AB36">示例：迭代器作为存储函数返回</p>
                     </div>
                     <!-- class="section" -->
                     <div class="section">
                        <p>此示例使用迭代器作为存储函数的返回类型，在进程中使用<code class="codeph">REF CURSOR</code>类型。
                        </p>
                        <p>假定以下函数定义：</p><pre class="oac_no_warn" dir="ltr">创建或替换包sqlj_refcursor AS TYPE EMP_CURTYPE是REF CURSOR;功能job_listing（j varchar2）RETURN EMP_CURTYPE; END sqlj_refcursor;创建或替换包主体sqlj_refcursor AS功能job_listing（j varchar）RETURN EMP_CURTYPE IS DECLARE rc EMP_CURTYPE; BEGIN OPEN rc FOR SELECT ename，empno FROM emp WHERE job = j;返回rc;结束; END sqlj_refcursor;</pre><p>声明迭代器如下：</p><pre class="oac_no_warn" dir="ltr">#sql public &lt;static&gt; iterator EmpIter（String ename，int empno）;</pre><p><code class="codeph">public</code>修饰符是必需的，如果声明是在类级别或嵌套级别级别，则建议使用<code class="codeph">static</code>修饰符。
                        </p>
                        <p>使用迭代器和函数的代码如下：</p><pre class="oac_no_warn" dir="ltr">更重要的是; ...#sql iter = {VALUES（sqlj_refcursor.job_listing（'SALES'））}; while（iter.next（））{String empname = iter.ename（）; int empnum = iter.empno（）; ... <span class="italic">进程empname和empnum</span> ...} iter.close（）; ...
</pre><p>此示例调用<code class="codeph">job_listing()</code>函数以返回迭代器，该迭代器包含作业标题为SALES的每个员工的姓名和员工编号。然后它从迭代器中检索此数据。
                        </p>
                     </div>
                     <!-- class="section" -->
                  </div>
               </div>
            </div>
         </div>
      </article>
   </body>
</html>