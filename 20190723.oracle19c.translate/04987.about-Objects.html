<html lang="en-us" dir="ltr" xml:lang="en-us">
   <head>
      <meta http-equiv="Content-Type" content="text/html; charset=utf-8"></meta>
      <meta name="viewport" content="width=device-width, initial-scale=1"></meta>
      <meta http-equiv="X-UA-Compatible" content="IE=edge"></meta>
      <title>对象</title>
      <meta property="og:site_name" content="Oracle Help Center"></meta>
      <meta property="og:title" content="Programmer&#39;s Guide"></meta>
      <meta property="og:description" content=""></meta>
      <link rel="stylesheet" href="/sp_common/book-template/ohc-book-template/css/book.css"></link>
      <link rel="shortcut icon" href="/sp_common/book-template/ohc-common/img/favicon.ico"></link>
      <meta name="application-name" content="Programmer&#39;s Guide"></meta>
      <meta name="generator" content="DITA Open Toolkit version 1.8.5 (Mode = doc)"></meta>
      <meta name="plugin" content="SP_docbuilder HTML plugin release 18.2.2"></meta>
      <link rel="alternate" href="c-c-programmers-guide.pdf" title="PDF File" type="application/pdf"></link>
      <meta name="robots" content="all"></meta>
      <link rel="schema.dcterms" href="http://purl.org/dc/terms/"></link>
      <meta name="dcterms.created" content="2019-01-11T03:52:01-08:00"></meta>
      
      <meta name="dcterms.dateCopyrighted" content="1996, 2019"></meta>
      <meta name="dcterms.category" content="database"></meta>
      <meta name="dcterms.identifier" content="E96467-01"></meta>
      
      <meta name="dcterms.product" content="en/database/oracle/oracle-database/19"></meta>
      
      <link rel="prev" href="about-LOBs.html" title="Previous" type="text/html"></link>
      <link rel="next" href="about-Collections.html" title="Next" type="text/html"></link>
      <script>
        document.write('<style type="text/css">');
        document.write('body > .noscript, body > .noscript ~ * { visibility: hidden; }');
        document.write('</style>');
     </script>
      <script src="/sp_common/book-template/requirejs/require.js" data-main="/sp_common/book-template/ohc-book-template/js/book-config"></script>
      <script>
            if (window.require === undefined) {
                document.write('<script data-main="sp_common/book-template/ohc-book-template/js/book-config" src="sp_common/book-template/requirejs/require.js"><\/script>');
                document.write('<link href="sp_common/book-template/ohc-book-template/css/book.css" rel="stylesheet"/>');
            }
        </script>
      <script type="application/json" id="ssot-metadata">{"primary":{"category":{"short_name":"database","element_name":"Database","display_in_url":true},"suite":{"short_name":"oracle","element_name":"Oracle","display_in_url":true},"product_group":{"short_name":"not-applicable","element_name":"Not applicable","display_in_url":false},"product":{"short_name":"oracle-database","element_name":"Oracle Database","display_in_url":true},"release":{"short_name":"19","element_name":"Release 19","display_in_url":true}}}</script>
      
    <meta name="dcterms.title" content="Pro*C/C++ Programmer&#39;s Guide"></meta>
    <meta name="dcterms.isVersionOf" content="LNPCC"></meta>
    <meta name="dcterms.release" content="Release 19"></meta>
  </head>
   <body dir="ltr">
      <div class="noscript alert alert-danger text-center" role="alert">
         <a href="about-LOBs.html" class="pull-left"><span class="glyphicon glyphicon-chevron-left" aria-hidden="true"></span>上一页</a> <a href="about-Collections.html" class="pull-right">下一页<span class="glyphicon glyphicon-chevron-right" aria-hidden="true"></span></a> <span class="fa fa-exclamation-triangle" aria-hidden="true"></span>必须启用JavaScript才能正确显示此内容</div>
      <article>
         <header>
            <ol class="breadcrumb" vocab="http://schema.org/" typeof="BreadcrumbList">
               <li property="itemListElement" typeof="ListItem"><a href="index.html" property="item" typeof="WebPage"><span property="name">程序员指南</span></a></li>
               <li property="itemListElement" typeof="ListItem"><a href="applications.html" property="item" typeof="WebPage"><span property="name">应用</span></a></li>
               <li class="active" property="itemListElement" typeof="ListItem">对象</li>
            </ol>
            <a id="GUID-0C106FBC-C023-4B86-817A-1867A69388F7" name="GUID-0C106FBC-C023-4B86-817A-1867A69388F7"></a><a id="LNPCC017"></a>
            
            <h2 id="LNPCC-GUID-0C106FBC-C023-4B86-817A-1867A69388F7" class="sect2"><span class="enumeration_chapter">17个</span>对象</h2>
         </header>
         <div class="ind">
            <div>
               <p>本章介绍了Pro * C / C ++中对用户定义对象的支持。本章包含以下主题：</p>
               <ul style="list-style-type:disc">
                  <li>
                     <p><a href="about-Objects.html#GUID-2B476A53-DFA4-4FAB-BC30-2B45605C171E">对象简介</a></p>
                  </li>
                  <li>
                     <p><a href="about-Objects.html#GUID-0EAA49C2-4F64-477C-A907-3EEC74F37CBE">关于在Pro * C / C ++中使用对象类型</a></p>
                  </li>
                  <li>
                     <p><a href="about-Objects.html#GUID-0C7ABD70-48A6-4769-B742-1D098CD372CC">对象缓存</a></p>
                  </li>
                  <li>
                     <p><a href="about-Objects.html#GUID-53163CC4-E17A-43E8-843B-02CBFDEBF449">关联接口</a></p>
                  </li>
                  <li>
                     <p><a href="about-Objects.html#GUID-1DB5F60D-55C9-4565-93D9-B155A86BB0C7">导航界面</a></p>
                  </li>
                  <li>
                     <p><a href="about-Objects.html#GUID-C0317114-582E-4D77-AC2E-C18E8DE6D23E">转换对象属性和C类型</a></p>
                  </li>
                  <li>
                     <p><a href="about-Objects.html#GUID-23A4843B-0673-4698-9358-9A714507D4DD">对象选项设置/获取</a></p>
                  </li>
                  <li>
                     <p><a href="about-Objects.html#GUID-DFA7F6BD-766A-440C-A5EC-EF97466F4EFB">对象的新预编译器选项</a></p>
                  </li>
                  <li>
                     <p><a href="about-Objects.html#GUID-34AFC95A-2A0F-4925-86F6-865E204CCBB4">Pro * C / C ++中的对象示例</a></p>
                  </li>
                  <li>
                     <p><a href="about-Objects.html#GUID-47435013-11A1-4977-AE0E-8A51F66D29C3">类型继承的示例代码</a></p>
                  </li>
                  <li>
                     <p><a href="about-Objects.html#GUID-D043EC3F-5DE7-4D09-B858-E9617327D6CD">导航访问的示例代码</a></p>
                  </li>
                  <li>
                     <p><a href="about-Objects.html#GUID-991F2F64-910B-46AD-AF38-BCAB90EACA88">关于使用C结构</a></p>
                  </li>
                  <li>
                     <p><a href="about-Objects.html#GUID-FFF48576-9D39-48D2-A199-D5E5E6B447E5">关于使用REF</a></p>
                  </li>
                  <li>
                     <p><a href="about-Objects.html#GUID-35C1DD18-7C3F-437E-A9DF-B9B2CE76DF2A">关于使用OCIDate_ OCIString_ OCINumber_和OCIRaw</a></p>
                  </li>
                  <li>
                     <p><a href="about-Objects.html#GUID-D46CF7DA-22AD-4EC7-ABAE-6376E344CE75">总结Pro * C / C ++中的新数据库类型</a></p>
                  </li>
                  <li>
                     <p><a href="about-Objects.html#GUID-4D7E09CE-34ED-4516-A129-83A7BCD82443">在动态SQL中使用Oracle数据类型的限制</a></p>
                  </li>
               </ul>
            </div><a id="LNPCC4315"></a><div class="props_rev_3"><a id="GUID-2B476A53-DFA4-4FAB-BC30-2B45605C171E" name="GUID-2B476A53-DFA4-4FAB-BC30-2B45605C171E"></a><h3 id="LNPCC-GUID-2B476A53-DFA4-4FAB-BC30-2B45605C171E" class="sect3"><span class="enumeration_section">17.1</span>对象简介</h3>
               <div>
                  <p>除了Oracle8以来支持的Oracle关系数据类型，Pro * C / C ++还支持用户定义的数据类型，它们是：</p>
                  <ul style="list-style-type:disc">
                     <li>
                        <p>对象类型</p>
                     </li>
                     <li>
                        <p>对象类型的REF</p>
                     </li>
                     <li>
                        <p>集合对象类型</p>
                     </li>
                     <li>
                        <p>输入继承</p>
                     </li>
                  </ul>
               </div>
               <div>
                  <div class="relinfo">
                     <p><strong>相关话题</strong></p>
                     <ul>
                        <li><a href="about-Collections.html#GUID-BCAD71D2-D01D-40C8-8BAD-08902363ECDA">集合</a></li>
                     </ul>
                  </div>
               </div>
               <a id="LNPCC4316"></a><div class="props_rev_3"><a id="GUID-E0D5C44C-53DE-4E71-808F-A22B9A8E2F65" name="GUID-E0D5C44C-53DE-4E71-808F-A22B9A8E2F65"></a><h4 id="LNPCC-GUID-E0D5C44C-53DE-4E71-808F-A22B9A8E2F65" class="sect4"><span class="enumeration_section">17.1.1</span>对象类型</h4>
                  <div>
                     <p>对象类型是用户定义的数据类型，它具有<span class="italic">属性</span> ，形成由CREATE TYPE SQL语句定义的数据类型的变量，以及作为对象类型的允许行为集的<span class="italic">方法</span> ，函数和过程。我们在本指南中仅考虑具有属性的对象类型。
                     </p>
                     <p>例如：</p><pre class="oac_no_warn" dir="ltr">- 定义对象类型......CREATE TYPE employee_type AS OBJECT（名称VARCHAR2（20），id NUMBER，MEMBER FUNCTION get_id（name VARCHAR2）RETURN NUMBER）; /  -   - 创建一个对象表...employee_type的CREATE TABLE员工; - 使用构造函数实例化对象...INSERT INTO员工VALUES（employee_type（'JONES'，10042））;</pre><p>LONG，LONG RAW，NCLOB，NCHAR和NCHAR变<span class="italic">不允许</span>作为对象的属性数据类型。
                     </p>
                  </div>
               </div><a id="LNPCC4317"></a><div class="props_rev_3"><a id="GUID-21C5A427-EC60-422F-B565-7FAD05648A38" name="GUID-21C5A427-EC60-422F-B565-7FAD05648A38"></a><h4 id="LNPCC-GUID-21C5A427-EC60-422F-B565-7FAD05648A38" class="sect4"><span class="enumeration_section">17.1.2</span>对象类型的REF</h4>
                  <div>
                     <p>REF（“reference”的缩写）是对存储在数据库表中的对象的引用，而不是对象本身。REF类型可以出现在关系列中，也可以作为对象类型的数据类型。例如，表<span class="italic">employee_tab</span>可以有一个列为对象类型<span class="italic">employee_t</span>本身的REF：</p><pre class="oac_no_warn" dir="ltr">CREATE TYPE employee_t AS OBJECT（empname CHAR（20），empno INTEGER，manager REF employee_t）; / CREATE TABLE employee_tab OF employee_t;</pre></div>
               </div><a id="LNPCC4318"></a><div class="props_rev_3"><a id="GUID-395C0A99-5BD6-432B-80A7-0FD8CAC174B3" name="GUID-395C0A99-5BD6-432B-80A7-0FD8CAC174B3"></a><h4 id="LNPCC-GUID-395C0A99-5BD6-432B-80A7-0FD8CAC174B3" class="sect4"><span class="enumeration_section">17.1.3</span>类型继承</h4>
                  <div>
                     <p><a id="d93390e275" class="indexterm-anchor"></a> Oracle支持对象的类型继承。这样可以在类似对象类型之间共享属性和方法，以及扩展对象类型的特征。
                     </p>
                     <p>Pro * C / C ++支持使用以下SQL运算符的对象类型的类型继承：</p>
                     <ul style="list-style-type:disc">
                        <li>
                           <p>IS <a id="d93390e284" class="indexterm-anchor"></a> OF <span class="italic">型</span></p>
                        </li>
                        <li>
                           <p>TRE AT</p>
                        </li>
                     </ul>
                     <p>IS OF <span class="italic">类型</span>运算符用于测试对象实例的特定<span class="italic">类型</span>信息。
                     </p>
                     <p>以下代码示例返回对所有<code class="codeph">p</code>对象的引用，其中<code class="codeph">p</code>的类型为<code class="codeph">Employee_t</code>和<code class="codeph">Student_t</code> 。
                     </p><pre class="oac_no_warn" dir="ltr">选择<a id="d93390e323" class="indexterm-anchor"></a> REF（p）FROM person_tab p WHERE VALUE（p）IS OF（Employee_t，Student_t）;</pre><p>以下代码示例返回其中<code class="codeph">p</code>仅为<code class="codeph">Student_t</code>类型的所有行。
                     </p><pre class="oac_no_warn" dir="ltr">选择<a id="d93390e340" class="indexterm-anchor"></a> VALUE（p）FROM person_tab p WHERE VALUE（p）IS OF（仅限Student_t）;</pre><p>TREAT运算符用于修改表达式的声明类型。</p>
                     <p>以下代码示例返回<code class="codeph">p</code>为<code class="codeph">Student_t</code>类型的所有行。对于不属于<code class="codeph">Student_t</code>类型的<code class="codeph">p</code>所有实例，返回null。
                     </p><pre class="oac_no_warn" dir="ltr">SELECT TR EAT（VALUE（p）AS Student_t）FROM person_tab p;</pre><p>以下代码示例返回对<code class="codeph">Student_t</code>类型的所有<code class="codeph">p</code>对象的<code class="codeph">Student_t</code>以及子类型<code class="codeph">Student_t</code>任何对象的<code class="codeph">PartTimeStudent_t</code> 。
                     </p><pre class="oac_no_warn" dir="ltr">选择治疗（REP <a id="d93390e386" class="indexterm-anchor"></a> （p）AS REF Student_t）FROM person_tab p WHERE VALUE（p）IS OF（Student_t）;</pre></div>
               </div>
            </div><a id="LNPCC4319"></a><div class="props_rev_3"><a id="GUID-0EAA49C2-4F64-477C-A907-3EEC74F37CBE" name="GUID-0EAA49C2-4F64-477C-A907-3EEC74F37CBE"></a><h3 id="LNPCC-GUID-0EAA49C2-4F64-477C-A907-3EEC74F37CBE" class="sect3"><span class="enumeration_section">17.2</span>关于在Pro * C / C ++中使用对象类型</h3>
               <div>
                  <p>在Pro * C / C ++应用程序中声明由OTT（对象类型转换器）生成的C结构指针作为主机和指示符变量。对于对象类型，指示符变量的使用是可选的，但Oracle建议使用它。</p>
                  <p>将Pro * C / C ++程序中的对象类型表示为使用OTT从数据库对象生成的C结构。你必须</p>
                  <ul style="list-style-type:disc">
                     <li>
                        <p>在Pro * C / C ++程序中包含OTT生成的头文件，其中包含结构定义和关联的NULL指示符结构，以及REF到对象类型的C类型。</p>
                     </li>
                     <li>
                        <p>输入OTT生成的typefile作为INTYPE Pro * C / C ++命令行选项。此类型文件对OTT生成的C结构与数据库中的关联对象类型之间的对应关系进行编码，以及模式和类型版本信息。</p>
                     </li>
                  </ul>
               </div>
               <div>
                  <div class="relinfo">
                     <p><strong>相关话题</strong></p>
                     <ul>
                        <li><a href="the-Object-type.html#GUID-502C3781-C88E-46B8-9EB2-9A93E0B4E7AE">对象类型转换器</a></li>
                     </ul>
                  </div>
               </div>
               <a id="LNPCC4320"></a><div class="props_rev_3"><a id="GUID-8FD4904E-6E8B-4CE0-8720-154D6E849C8D" name="GUID-8FD4904E-6E8B-4CE0-8720-154D6E849C8D"></a><h4 id="LNPCC-GUID-8FD4904E-6E8B-4CE0-8720-154D6E849C8D" class="sect4"><span class="enumeration_section">17.2.1</span> NULL指示符</h4>
                  <div>
                     <p>表示对象类型的NULL状态的C结构由对象类型转换器生成。必须在声明对象类型的指示符变量时使用这些生成的结构类型。</p>
                     <p>其他Oracle类型不需要对NULL指示符进行特殊处理。</p>
                     <p>由于对象类型具有内部结构，因此对象类型的NULL指示符也具有内部结构。非集合对象类型的NULL指示符结构为整个对象类型提供原子（单个）NULL状态，以及每个属性的NULL状态。OTT生成C结构以表示对象类型的NULL指示符结构。NULL指示符结构的名称是<span class="italic">Object_typename</span> _ind，其中<span class="italic">Object_typename</span>是数据库中用户定义类型的C结构的名称。
                     </p>
                  </div>
                  <div>
                     <div class="relinfo">
                        <p><strong>相关话题</strong></p>
                        <ul>
                           <li><a href="datatypes-and-host-variables.html#GUID-18395E0D-263A-49BF-9DAB-DA0C8775B9FC">数据类型和主机变量</a></li>
                        </ul>
                     </div>
                  </div>
                  
               </div>
            </div><a id="LNPCC4321"></a><div class="props_rev_3"><a id="GUID-0C7ABD70-48A6-4769-B742-1D098CD372CC" name="GUID-0C7ABD70-48A6-4769-B742-1D098CD372CC"></a><h3 id="LNPCC-GUID-0C7ABD70-48A6-4769-B742-1D098CD372CC" class="sect3"><span class="enumeration_section">17.3</span>对象缓存</h3>
               <div>
                  <p>对象缓存是客户端上的一个内存区域，它是为程序在与数据库对象连接时使用而分配的。有两个用于处理对象的接口。关联接口操纵对象的“瞬态”副本，导航接口操纵“持久”对象。</p>
               </div><a id="LNPCC4322"></a><div class="props_rev_3"><a id="GUID-38DF26FF-742D-4D0E-A06F-5CC0E54FB2C7" name="GUID-38DF26FF-742D-4D0E-A06F-5CC0E54FB2C7"></a><h4 id="LNPCC-GUID-38DF26FF-742D-4D0E-A06F-5CC0E54FB2C7" class="sect4"><span class="enumeration_section">17.3.1</span>持久性与对象的瞬态副本</h4>
                  <div>
                     <p>使用Pro * C / C ++中的EXEC SQL ALLOCATE语句在缓存中分配的对象是Oracle数据库中持久对象的<span class="italic">临时副本</span> 。因此，您可以在获取这些副本后在缓存中更新这些副本，但为了使这些更改在数据库中保持不变，您必须使用显式SQL命令。这种“瞬态复制”或“基于值”的对象缓存模型是关系模型的扩展，其中关系表的标量列可以被提取到主变量中，在适当的位置更新，并且更新传递给服务器。
                     </p>
                  </div>
               </div>
            </div><a id="LNPCC4323"></a><div class="props_rev_3"><a id="GUID-53163CC4-E17A-43E8-843B-02CBFDEBF449" name="GUID-53163CC4-E17A-43E8-843B-02CBFDEBF449"></a><h3 id="LNPCC-GUID-53163CC4-E17A-43E8-843B-02CBFDEBF449" class="sect3"><span class="enumeration_section">17.4</span>关联接口</h3>
               <div>
                  <p>关联接口操纵对象的瞬态副本。使用EXEC SQL ALLOCATE语句在对象缓存中分配内存。</p>
                  <p>为每个SQLLIB运行时上下文创建一个对象缓存。</p>
                  <p>对象由EXEC SQL SELECT或EXEC SQL FETCH语句检索。这些语句设置主机变量属性的值。如果提供了NULL指示符，则也会设置它。</p>
                  <p>使用EXEC SQL INSERT，EXEC SQL UPDATE和EXEC SQL DELETE语句插入，更新或删除对象。必须在执行语句之前设置对象主机变量的属性。</p>
                  <p>事务语句EXEC SQL COMMIT和EXEC SQL ROLLBACK用于在服务器上永久写入更改或取消更改。</p>
                  <p>您可以使用EXEC SQL FREE语句在对象的高速缓存中显式释放内存。当连接终止时，Oracle会隐式释放其分配的内存。</p>
               </div><a id="LNPCC4324"></a><div class="props_rev_3"><a id="GUID-76AA9759-E5E1-46F0-81F3-A34D17975D98" name="GUID-76AA9759-E5E1-46F0-81F3-A34D17975D98"></a><h4 id="LNPCC-GUID-76AA9759-E5E1-46F0-81F3-A34D17975D98" class="sect4"><span class="enumeration_section">17.4.1</span>何时使用关联接口</h4>
                  <div>
                     <p>在这些情况下使用：</p>
                     <ul style="list-style-type:disc">
                        <li>
                           <p>访问表的显式连接并不昂贵的大型对象集合。</p>
                        </li>
                        <li>
                           <p>访问不可引用的对象;他们没有对象身份。例如，关系列中的对象类型。</p>
                        </li>
                        <li>
                           <p>将UPDATE或INSERT等操作应用于一组对象时。例如，为部门中的所有员工添加1000美元的奖金。</p>
                        </li>
                     </ul>
                  </div>
               </div><a id="LNPCC4325"></a><div class="props_rev_3"><a id="GUID-8B78E759-CFA9-45BB-8854-51F5D192CBE8" name="GUID-8B78E759-CFA9-45BB-8854-51F5D192CBE8"></a><h4 id="LNPCC-GUID-8B78E759-CFA9-45BB-8854-51F5D192CBE8" class="sect4"><span class="enumeration_section">17.4.2</span>分配</h4>
                  <div>
                     <div class="section">
                        <p>您可以使用此语句在对象缓存中分配空间。语法是：</p><pre class="oac_no_warn" dir="ltr">EXEC SQL [AT [：] <span class="italic">database</span> ] ALLOCATE： <span class="italic">host_ptr</span> [[INDICATOR]： <span class="italic">ind_ptr</span> ];</pre><p>输入的变量是：</p>
                        <p>数据库（IN）</p>
                        <p>包含数据库连接名称的以零结尾的字符串，如前面通过语句建立的：</p><pre class="oac_no_warn" dir="ltr">EXEC SQL CONNECT： <span class="italic">user</span> [AT [：] <span class="italic">database</span> ];</pre><p>如果省略AT子句AT，或者<span class="italic">数据库</span>是空字符串，则假定使用默认数据库连接。
                        </p>
                        <p>host_ptr（IN）</p>
                        <p>指向OTT为对象类型，集合对象类型或REF生成的主机结构的指针，或指向新C数据类型之一的指针：OCIDate，OCINumber，OCIRaw或OCIString。</p>
                        <p>ind_ptr（IN）</p>
                        <p>指示符变量<span class="italic">ind_ptr</span>是可选的，关键字INDICATOR也是可选的。只有指向结构类型指示符的指针才能在ALLOCATE和FREE语句中使用。
                        </p>
                        <p><span class="italic">host_ptr</span>和<span class="italic">ind_ptr</span>可以是主机阵列。
                        </p>
                        <p>分配的持续时间是会话。即使未通过FREE语句明确释放，也会在会话（连接）终止时释放所有实例。</p>
                     </div>
                     <!-- class="section" -->
                  </div>
                  <div>
                     <div class="relinfo">
                        <p><strong>相关话题</strong></p>
                        <ul>
                           <li><a href="embedded-SQL-statements-and-directives.html#GUID-1B381F58-96EA-420F-8BF8-0047E734268E">ALLOCATE（可执行的嵌入式SQL扩展）</a></li>
                           <li><a href="embedded-SQL-statements-and-directives.html#GUID-D193A6EF-5B8D-491F-8BA1-215AA26B753B">免费（可执行的嵌入式SQL扩展）</a></li>
                        </ul>
                     </div>
                  </div>
                  
               </div><a id="LNPCC4326"></a><div class="props_rev_3"><a id="GUID-CB343FC4-35EF-44E5-B50D-65CA9051CCD0" name="GUID-CB343FC4-35EF-44E5-B50D-65CA9051CCD0"></a><h4 id="LNPCC-GUID-CB343FC4-35EF-44E5-B50D-65CA9051CCD0" class="sect4"><span class="enumeration_section">17.4.3</span>免费</h4>
                  <div>
                     <div class="section"><pre class="oac_no_warn" dir="ltr">EXEC SQL [AT [：] <span class="italic">database</span> ] [OBJECT] FREE： <span class="italic">host_ptr</span> [[INDICATOR]： <span class="italic">ind_ptr</span> ];</pre><p>使用FREE语句为放置在对象缓存中的对象取消分配空间。使用的变量与ALLOCATE语句中的变量相同。</p>
                        <div class="infoboxnote" id="GUID-CB343FC4-35EF-44E5-B50D-65CA9051CCD0__GUID-281B0EB0-DAC0-41CA-B4BF-055D5A93E324">
                           <p class="notep1">注意：</p>
                           <p>主机和指示符变量的指针<span class="italic">未</span>设置为null。
                           </p>
                        </div>
                     </div>
                     <!-- class="section" -->
                  </div>
               </div><a id="LNPCC4327"></a><div class="props_rev_3"><a id="GUID-529A59B8-D675-4782-BC5F-A9943599D2D2" name="GUID-529A59B8-D675-4782-BC5F-A9943599D2D2"></a><h4 id="LNPCC-GUID-529A59B8-D675-4782-BC5F-A9943599D2D2" class="sect4"><span class="enumeration_section">17.4.4</span> CACHE FREE ALL</h4>
                  <div>
                     <div class="section"><pre class="oac_no_warn" dir="ltr">EXEC SQL [AT [：] <span class="italic">数据库</span> ] [OBJECT] CACHE FREE ALL;</pre><p>使用前面的语句释放指定数据库连接的所有对象高速缓存内存。</p>
                     </div>
                     <!-- class="section" -->
                  </div>
                  <div>
                     <div class="relinfo">
                        <p><strong>相关话题</strong></p>
                        <ul>
                           <li><a href="embedded-SQL-statements-and-directives.html#GUID-EEDED3A8-63EA-4A25-920F-1B1882CE26AF">CACHE FREE ALL（可执行嵌入式SQL扩展）</a></li>
                        </ul>
                     </div>
                  </div>
                  
               </div><a id="LNPCC4329"></a><a id="LNPCC4328"></a><div class="props_rev_3"><a id="GUID-7BB3E466-ACE7-4143-BAAC-CAFDD3F9DEB4" name="GUID-7BB3E466-ACE7-4143-BAAC-CAFDD3F9DEB4"></a><h4 id="LNPCC-GUID-7BB3E466-ACE7-4143-BAAC-CAFDD3F9DEB4" class="sect4"><span class="enumeration_section">17.4.5</span>使用关联接口访问对象</h4>
                  <div>
                     <p>使用SQL访问对象时，Pro * C / C ++应用程序操纵持久对象的临时副本。这是关系访问接口的直接扩展，它使用SELECT，UPDATE和DELETE语句。</p>
                     <p>在<a href="about-Objects.html#GUID-7BB3E466-ACE7-4143-BAAC-CAFDD3F9DEB4__I449766">图17-1中</a> ，使用ALLOCATE语句为缓存中的内存副本分配内存。分配的对象不包含数据，但它具有OTT生成的结构的形式。</p><pre class="oac_no_warn" dir="ltr">person * per_p; ...EXEC SQL ALLOCATE：per_p;</pre><p>您可以执行SELECT语句来填充缓存。或者，使用FETCH语句或C赋值来使用数据填充缓存。</p><pre class="oac_no_warn" dir="ltr">EXEC SQL SELECT ...INTO：per_p FROM person_tab WHERE ...
</pre><p>使用INSERT，UPDATE或DELETE语句更改服务器对象，如图所示。您可以通过INSERT语句将数据插入表中：</p><pre class="oac_no_warn" dir="ltr">EXEC SQL INSERT INTO person_tab VALUES（：per_p）;</pre><p>最后，使用FREE语句与对象副本相关联的空闲内存：</p><pre class="oac_no_warn" dir="ltr">EXEC SQL FREE：per_p;</pre><div class="figure" id="GUID-7BB3E466-ACE7-4143-BAAC-CAFDD3F9DEB4__I449766">
                        <p class="titleinfigure">图17-1使用SQL访问对象</p><img src="img/lnpcc069.gif" width="603" alt="下面是图17-1的描述" title="下面是图17-1的描述" longdesc="img_text/lnpcc069.html"><br><a href="img_text/lnpcc069.html">“图17-1使用SQL访问对象”的说明</a></div>
                     <!-- class="figure" -->
                  </div>
               </div>
            </div><a id="LNPCC4330"></a><div class="props_rev_3"><a id="GUID-1DB5F60D-55C9-4565-93D9-B155A86BB0C7" name="GUID-1DB5F60D-55C9-4565-93D9-B155A86BB0C7"></a><h3 id="LNPCC-GUID-1DB5F60D-55C9-4565-93D9-B155A86BB0C7" class="sect3"><span class="enumeration_section">17.5</span>导航界面</h3>
               <div>
                  <p>使用导航界面访问与关联界面相同的模式。导航接口通过将REF解引用到对象并遍历（“导航”）从一个对象到另一个对象来访问持久和瞬态对象。一些定义如下。</p>
                  <p><span class="italic">固定</span>对象是用于表示取消引用对象的术语，允许程序访问它。
                  </p>
                  <p><span class="italic">取消固定</span>意味着向缓存指示不再需要该对象。
                  </p>
                  <p>可以将<span class="italic">解除引用</span>定义为使用REF在客户端中创建对象版本的服务器。虽然缓存维护缓存中的对象与相应的服务器对象之间的关联，但它不提供自动一致性。您有责任确保缓存中对象内容的正确性和一致性。
                  </p>
                  <p><span class="italic">释放</span>对象副本向缓存指示当前未使用该对象。要释放内存，请在不再需要时释放对象，使其符合隐式释放的条件。
                  </p>
                  <p><span class="italic">释放</span>对象副本会将其从缓存中删除并释放其内存区域。
                  </p>
                  <p><span class="italic">标记</span>对象会告知缓存已在缓存中更新了对象副本，并且在刷新对象副本时必须更新相应的服务器对象。
                  </p>
                  <p>取消<span class="italic">标记</span>对象将删除对象已更新的指示。
                  </p>
                  <p><span class="italic">刷新</span>对象会将对缓存中已标记副本所做的本地更改写入服务器中的相应对象。此时，缓存中的对象副本也未标记。
                  </p>
                  <p><span class="italic">刷新</span>缓存中的对象副本会将其替换为服务器中相应对象的最新值。
                  </p>
                  <p>导航和关联接口可以一起使用。</p>
                  <p>使用EXEC SQL OBJECT语句（导航界面）更新，删除和刷新缓存副本（将缓存中的更改写入服务器）。</p>
                  <div class="infoboxnotealso" id="GUID-1DB5F60D-55C9-4565-93D9-B155A86BB0C7__GUID-11B4E0D2-9251-4A2B-8999-50B664E81955">
                     <p class="notep1">也可以看看：</p>
                     <p><span class="q">“ <a href="about-Objects.html#GUID-D043EC3F-5DE7-4D09-B858-E9617327D6CD">导航访问的示例代码</a> ”，</span>用于说明一起使用导航和关联接口</p>
                  </div>
               </div><a id="LNPCC4331"></a><div class="props_rev_3"><a id="GUID-092F9382-DAC2-4AEF-B88C-415800B5253F" name="GUID-092F9382-DAC2-4AEF-B88C-415800B5253F"></a><h4 id="LNPCC-GUID-092F9382-DAC2-4AEF-B88C-415800B5253F" class="sect4"><span class="enumeration_section">17.5.1</span>何时使用导航界面</h4>
                  <div>
                     <p>使用导航界面：</p>
                     <ul style="list-style-type:disc">
                        <li>
                           <p>访问单个或一小组对象，其中表之间的显式连接很昂贵。使用解除引用在对象之间导航时，执行隐式连接，这比两个整个表中的显式连接便宜。</p>
                        </li>
                        <li>
                           <p>对许多不同的对象进行许多小的更改。将所有对象提取到客户端，进行更改，将其标记为已更新，并将所有更改刷新回服务器更方便。</p>
                        </li>
                     </ul>
                  </div>
               </div><a id="LNPCC4332"></a><div class="props_rev_3"><a id="GUID-A324D9BB-0981-4329-A3D2-AFF4BF03F6FF" name="GUID-A324D9BB-0981-4329-A3D2-AFF4BF03F6FF"></a><h4 id="LNPCC-GUID-A324D9BB-0981-4329-A3D2-AFF4BF03F6FF" class="sect4"><span class="enumeration_section">17.5.2</span>导航声明中使用的规则</h4>
                  <div>
                     <p>嵌入式SQL OBJECT语句稍后将通过以下假设进行描述：</p>
                     <ul style="list-style-type:disc">
                        <li>
                           <p>如果不存在AT子句，则假定为默认（未命名）连接。</p>
                        </li>
                        <li>
                           <p>除非特别说明，否则主机变量可以是数组。</p>
                        </li>
                        <li>
                           <p>使用FOR子句显式指定数组维度。如果不存在，则使用相关主变量的最小维度。</p>
                        </li>
                        <li>
                           <p>执行语句后，如果SQLCA作为状态变量提供，则处理的元素数将在sqlca.sqlerrd [2]中返回。</p>
                        </li>
                        <li>
                           <p>参数具有指定IN或OUT（或两者）以表示输入或输出。</p>
                        </li>
                     </ul>
                  </div>
                  <div>
                     <div class="relinfo">
                        <p><strong>相关话题</strong></p>
                        <ul>
                           <li><a href="embedded-SQL-statements-and-directives.html#GUID-0ABBFB3E-F2BA-4906-8DEF-53EA78D758B5">嵌入式SQL语句和指令</a></li>
                        </ul>
                     </div>
                  </div>
                  
               </div><a id="LNPCC4333"></a><div class="props_rev_3"><a id="GUID-2568C123-275E-48C7-9C35-805DADD4AD7E" name="GUID-2568C123-275E-48C7-9C35-805DADD4AD7E"></a><h4 id="LNPCC-GUID-2568C123-275E-48C7-9C35-805DADD4AD7E" class="sect4"><span class="enumeration_section">17.5.3</span>对象创建</h4>
                  <div>
                     <div class="section"><pre class="oac_no_warn" dir="ltr">EXEC SQL [AT [：] <span class="italic">database</span> ] [FOR [：] <span class="italic">count</span> ] OBJECT CREATE： <span class="italic">obj</span> [INDICATOR]： <span class="italic">obj_ind</span> [TABLE <span class="italic">tab</span> ] [RETURNING REF INTO： <span class="italic">ref</span> ];</pre><p>选项卡是：</p>
                        <p>{：hv | [架构。]表}</p>
                        <p>使用此语句在对象缓存中创建可引用对象。对象的类型对应于主变量<span class="italic">obj</span> 。当提供可选类型主变量（ <code class="codeph">:obj_ind,:ref,:ref_ind</code> ）时，它们必须全部对应于相同的类型。
                        </p>
                        <p>可引用对象可以是持久性的（提供TABLE子句），也可以是瞬态的（不存在TABLE子句）。永久对象被隐式固定并标记为已更新。瞬态对象被隐式固定。</p>
                        <p>主变量是：</p>
                        <p>obj（OUT）</p>
                        <p>对象实例主机变量<span class="italic">obj</span>必须是指向OTT生成的结构的指针。此变量用于确定在对象缓存中创建的可引用对象。成功执行后， <span class="italic">obj</span>将指向新创建的对象。
                        </p>
                        <p>obj_ind（OUT）</p>
                        <p>该变量指向OTT生成的指标结构。其类型必须与对象实例主机变量的类型匹配。成功执行后， <span class="italic">obj_ind</span>将成为可引用对象的并行指示器结构的指针。
                        </p>
                        <p>标签（IN）</p>
                        <p>使用table子句创建持久对象。表名可以指定为主机变量， <span class="italic">hv</span>或未声明的SQL标识符。它可以使用模式名称进行限定。不要在包含表名的主变量中使用尾随空格。
                        </p>
                        <p>hv（IN）</p>
                        <p>指定表的主机变量。如果使用主机变量， <span class="italic">则它不能</span>是数组。它不能是空白填充。它区分大小写。创建持久对象数组时，它们都与同一个表相关联。
                        </p>
                        <p>表（IN）</p>
                        <p>未声明的SQL标识符，区分大小写。</p>
                        <p>ref（OUT）</p>
                        <p>引用主机变量必须是指向OTT生成的引用类型的指针。<span class="italic">ref</span>的类型必须与对象实例主机变量的类型匹配。执行后， <span class="italic">ref</span>包含指向新创建对象的ref的指针。
                        </p>
                        <p>属性最初设置为null。目前不支持为对象视图创建新对象。</p>
                        <p>目前<span class="italic">不</span>支持为对象视图创建新对象。
                        </p>
                     </div>
                     <!-- class="section" -->
                  </div>
               </div><a id="LNPCC4334"></a><div class="props_rev_3"><a id="GUID-75659B97-BDB0-4A15-AC1A-7A8B2BBA70C8" name="GUID-75659B97-BDB0-4A15-AC1A-7A8B2BBA70C8"></a><h4 id="LNPCC-GUID-75659B97-BDB0-4A15-AC1A-7A8B2BBA70C8" class="sect4"><span class="enumeration_section">17.5.4</span>对象DEREF</h4>
                  <div>
                     <div class="section"><pre class="oac_no_warn" dir="ltr">EXEC SQL [AT [：] <span class="italic">database</span> ] [FOR [：] <span class="italic">count</span> ] OBJECT DEREF：ref INTO： <span class="italic">obj</span> [[INDICATOR]： <span class="italic">obj_ind</span> ] [FOR UPDATE [NOWAIT]];</pre><p>给定对象引用<span class="italic">ref</span> ，OBJECT DEREF语句将对象缓存中对应的对象或对象数组固定。在变量<span class="italic">obj</span>和<span class="italic">obj_ind</span>中返回指向这些对象的指针。
                        </p>
                        <p>主变量是：</p>
                        <p>ref（IN）</p>
                        <p>这是对象引用变量，它必须是指向OTT生成的引用类型的指针。取消引用此变量（或变量数组），返回指向缓存中相应对象的指针。</p>
                        <p>obj（OUT）</p>
                        <p>对象实例主机变量<span class="italic">obj</span>必须是指向OTT生成结构的指针。其类型必须与对象引用主机变量的类型匹配。成功执行后， <span class="italic">obj</span>包含指向对象缓存中固定对象的指针。
                        </p>
                        <p>obj_ind（OUT）</p>
                        <p>对象实例指示符变量<span class="italic">obj_ind</span>必须是指向OTT生成的指示符结构的指针。其类型必须与对象引用指示符变量的类型匹配。成功执行后， <span class="italic">obj_ind</span>包含指向可引用对象的并行指示器结构的指针。
                        </p>
                        <p>更新</p>
                        <p>如果存在此子句，则为服务器中的相应对象获取独占锁。</p>
                        <p>NOWAIT</p>
                        <p>如果存在此可选关键字，则如果另一个用户已锁定该对象，则会立即返回错误。</p>
                     </div>
                     <!-- class="section" -->
                  </div>
               </div><a id="LNPCC4335"></a><div class="props_rev_3"><a id="GUID-081CF130-1855-4A0E-B543-C284B27973EA" name="GUID-081CF130-1855-4A0E-B543-C284B27973EA"></a><h4 id="LNPCC-GUID-081CF130-1855-4A0E-B543-C284B27973EA" class="sect4"><span class="enumeration_section">17.5.5</span>对象释放</h4>
                  <div>
                     <div class="section"><pre class="oac_no_warn" dir="ltr">EXEC SQL [AT [：] <span class="italic">database</span> ] [FOR [：] <span class="italic">count</span> ] OBJECT RELEASE： <span class="italic">obj</span> ;</pre><p>此语句取消对象缓存中的对象。当某个对象未固定且未更新时，它有资格进行隐式释放。</p>
                        <p>如果对象已被解除引用n次，则必须将其释放n次才有资格从对象缓存中隐式释放。Oracle建议发布不再需要的所有对象。</p>
                     </div>
                     <!-- class="section" -->
                  </div>
               </div><a id="LNPCC4336"></a><div class="props_rev_3"><a id="GUID-02C13127-CE3C-4040-B26F-969382AF491B" name="GUID-02C13127-CE3C-4040-B26F-969382AF491B"></a><h4 id="LNPCC-GUID-02C13127-CE3C-4040-B26F-969382AF491B" class="sect4"><span class="enumeration_section">17.5.6</span>对象删除</h4>
                  <div>
                     <div class="section"><pre class="oac_no_warn" dir="ltr">EXEC SQL [AT [：] <span class="italic">database</span> ] [FOR [：] <span class="italic">count</span> ] OBJECT DELETE： <span class="italic">obj</span> ;</pre><p>对于持久对象，此语句将对象或对象数组标记为在对象缓存中删除。刷新对象或刷新缓存时，将在服务器中删除该对象。不释放对象高速缓存中保留的内存。</p>
                        <p>对于瞬态对象，该对象标记为已删除。不释放对象的内存。</p>
                     </div>
                     <!-- class="section" -->
                  </div>
               </div><a id="LNPCC4337"></a><div class="props_rev_3"><a id="GUID-13D8D19D-D2B1-4856-92C5-2F09B2D53FBF" name="GUID-13D8D19D-D2B1-4856-92C5-2F09B2D53FBF"></a><h4 id="LNPCC-GUID-13D8D19D-D2B1-4856-92C5-2F09B2D53FBF" class="sect4"><span class="enumeration_section">17.5.7</span>对象更新</h4>
                  <div>
                     <div class="section"><pre class="oac_no_warn" dir="ltr">EXEC SQL [AT [：] <span class="italic">database</span> ] [FOR [：] <span class="italic">count</span> ] OBJECT UPDATE： <span class="italic">obj</span> ;</pre><p>对于持久对象，此语句将它们标记为在对象缓存中更新。刷新对象或刷新缓存时，更改将写入服务器。</p>
                        <p>对于瞬态对象，此语句是无操作。</p>
                     </div>
                     <!-- class="section" -->
                  </div>
               </div><a id="LNPCC4338"></a><div class="props_rev_3"><a id="GUID-06633D93-9C9C-424B-A416-2686B4BAE9B1" name="GUID-06633D93-9C9C-424B-A416-2686B4BAE9B1"></a><h4 id="LNPCC-GUID-06633D93-9C9C-424B-A416-2686B4BAE9B1" class="sect4"><span class="enumeration_section">17.5.8物体</span>冲洗</h4>
                  <div>
                     <div class="section"><pre class="oac_no_warn" dir="ltr">EXEC SQL [AT [：] <span class="italic">database</span> ] [FOR [：] <span class="italic">count</span> ] OBJECT FLUSH： <span class="italic">obj</span> ;</pre><p>此语句将已标记为已更新，已删除或已创建的持久对象刷新到服务器。</p>
                        <div class="infoboxnote" id="GUID-06633D93-9C9C-424B-A416-2686B4BAE9B1__GUID-71854CB8-48B4-4D12-97BB-CB8E135B0CD7">
                           <p class="notep1">注意：</p>
                           <p>刷新对象时隐式获取独占锁。语句成功完成后，对象将取消标记。如果对象版本是LATEST（请参阅下一节），则将隐式刷新对象。</p>
                        </div>
                     </div>
                     <!-- class="section" -->
                  </div>
               </div><a id="LNPCC4340"></a><a id="LNPCC4341"></a><a id="LNPCC4339"></a><div class="props_rev_3"><a id="GUID-3E124735-91D3-495D-9080-2BB9B776B279" name="GUID-3E124735-91D3-495D-9080-2BB9B776B279"></a><h4 id="LNPCC-GUID-3E124735-91D3-495D-9080-2BB9B776B279" class="sect4"><span class="enumeration_section">17.5.9</span>对象的导航访问</h4>
                  <div>
                     <p>有关导航界面的说明，请参<a href="about-Objects.html#GUID-3E124735-91D3-495D-9080-2BB9B776B279__I449836">见图17-2</a> 。
                     </p>
                     <p>使用ALLOCATE语句在对象高速缓存中分配内存，以将REF副本分配给<span class="italic">person</span>对象。分配的REF不包含数据。
                     </p><pre class="oac_no_warn" dir="ltr">person * per_p; person_ref * per_ref_p; ...EXEC SQL ALLOCATE：per_p;</pre><p>使用SELECT语句填充已分配的内存以检索<span class="italic">person</span>对象的REF（具体格式取决于应用程序）：</p><pre class="oac_no_warn" dir="ltr">EXEC SQL SELECT ...INTO：per_ref_p;</pre><p>然后使用DEREF语句将对象固定在缓存中，以便可以在对象中进行更改。DEREF语句获取指针<span class="italic">per_ref_p</span>并在客户端缓存中创建<span class="italic">person</span>对象的实例。返回指向<span class="italic">person</span>对象的指针<span class="italic">per_p</span> 。
                     </p><pre class="oac_no_warn" dir="ltr">EXEC SQL OBJECT DEREF：per_ref_p INTO：per_p;</pre><div class="figure" id="GUID-3E124735-91D3-495D-9080-2BB9B776B279__I449836">
                        <p class="titleinfigure">图17-2导航访问</p><img src="img/lnpcc070.gif" width="504" alt="下面是图17-2的描述" title="下面是图17-2的描述" longdesc="img_text/lnpcc070.html"><br><a href="img_text/lnpcc070.html">“图17-2导航访问”的描述</a></div>
                     <!-- class="figure" -->
                     <p>使用C赋值语句或使用OBJECT SET语句进行数据转换，对缓存中的对象进行更改。</p>
                     <p>然后，您必须将对象标记为已更新。请参<a href="about-Objects.html#GUID-3E124735-91D3-495D-9080-2BB9B776B279__I449886">见图17-3</a> 。要将缓存中的对象标记为已更新，并且有资格刷新到服务器：</p><pre class="oac_no_warn" dir="ltr">EXEC SQL OBJECT UPDATE：per_p;</pre><p>您可以通过FLUSH语句将更改发送到服务器：</p><pre class="oac_no_warn" dir="ltr">EXEC SQL OBJECT FLUSH：per_p;</pre><p>您释放对象：</p><pre class="oac_no_warn" dir="ltr">EXEC SQL OBJECT RELEASE：per_p;</pre><div class="figure" id="GUID-3E124735-91D3-495D-9080-2BB9B776B279__I449886">
                        <p class="titleinfigure">图17-3导航访问（续）</p><img src="img/lnpcc071.gif" width="533" alt="下面是图17-3的描述" title="下面是图17-3的描述" longdesc="img_text/lnpcc071.html"><br><a href="img_text/lnpcc071.html">“图17-3导航访问（续）”的描述</a></div>
                     <!-- class="figure" -->
                     <p>下一节中的语句用于进行对象属性和C类型之间的转换。</p>
                  </div>
               </div>
            </div><a id="LNPCC4342"></a><div class="props_rev_3"><a id="GUID-C0317114-582E-4D77-AC2E-C18E8DE6D23E" name="GUID-C0317114-582E-4D77-AC2E-C18E8DE6D23E"></a><h3 id="LNPCC-GUID-C0317114-582E-4D77-AC2E-C18E8DE6D23E" class="sect3"><span class="enumeration_section">17.6</span>转换对象属性和C类型</h3>
               <div>
                  <p>本节介绍与属性和类型转换相关的问题。</p>
               </div><a id="LNPCC4343"></a><div class="props_rev_3"><a id="GUID-A2170426-231B-4671-AC7D-5520043A3BD0" name="GUID-A2170426-231B-4671-AC7D-5520043A3BD0"></a><h4 id="LNPCC-GUID-A2170426-231B-4671-AC7D-5520043A3BD0" class="sect4"><span class="enumeration_section">17.6.1</span>对象集</h4>
                  <div>
                     <div class="section"><pre class="oac_no_warn" dir="ltr">EXEC SQL [AT [：] <span class="italic">database</span> ] OBJECT SET [{'*'| { <span class="italic">attr</span> [， <span class="italic">attr</span> ]}} OF]： <span class="italic">obj</span> [[INDICATOR]： <span class="italic">obj_ind</span> ] TO {： <span class="italic">hv</span> [[INDICATOR]： <span class="italic">hv_ind</span> ] [，： <span class="italic">hv</span> [INDICATOR]： <span class="italic">hv_ind</span> ]]};</pre><p>将此语句与关联和导航接口创建的对象一起使用。此语句更新对象的属性。对于持久对象，更新和刷新对象时，更改将写入服务器。刷新缓存会将对更新对象所做的所有更改写入服务器。</p>
                        <p>OF <span class="bold"> </span>子句是可选的。如果不存在，则设置<span class="italic">obj的</span>所有属性。写作相同的结果：</p><pre class="oac_no_warn" dir="ltr">...对象集* ...
</pre><p>主变量列表可以包括分解以提供属性值的结构。但是， <span class="italic">obj中</span>的属性数必须与爆炸变量列表中的元素数相匹配。
                        </p>
                        <p>主机变量和属性是：</p>
                        <p>ATTR</p>
                        <p>属性不是主机变量，而是指定将更新对象的哪些属性的简单标识符。列表中的第一个属性与列表中的第一个表达式配对，依此类推。该属性必须是OCIString，OCINumber，OCIDate或OCIRef之一。</p>
                        <p>obj（IN / OUT）</p>
                        <p><span class="italic">obj</span>指定要更新的对象。绑定变量<span class="italic">obj</span>不能是数组。它必须是指向OTT生成结构的指针。
                        </p>
                        <p>obj_ind（IN / OUT）</p>
                        <p>将更新的并行指标结构。它必须是指向OTT生成的指标结构的指针。</p>
                        <p>hv（IN）</p>
                        <p>这是用作OBJECT SET语句的输入的绑定变量。 <span class="italic">hv</span>必须是int，float，OCIRef *，一维char数组或这些类型的结构。
                        </p>
                        <p>hv_ind（IN）</p>
                        <p>这是用作OBJECT SET语句的输入的关联指示符。 <span class="italic">hv_ind</span>必须是2字节整数标量或2字节整数标量的结构。
                        </p>
                        <p>使用指标变量：</p>
                        <p>如果存在主机变量指示符，则还必须存在对象指示符。</p>
                        <p>如果hv_ind设置为-1，则obj_ind中的关联字段设置为-1。</p>
                        <p>允许以下隐式转换：</p>
                        <ul style="list-style-type:disc">
                           <li>
                              <p>[OCIString | STRING | VARCHAR | CHARZ]到OCIString</p>
                           </li>
                           <li>
                              <p>OCIRef to OCIRef</p>
                           </li>
                           <li>
                              <p>[OCINumber | int |漂浮|双倍]到OCINumber</p>
                           </li>
                           <li>
                              <p>[OCIDate | STRING | VARCHAR | CHARZ]到OCIDate</p>
                              <div class="infoboxnote" id="GUID-A2170426-231B-4671-AC7D-5520043A3BD0__GUID-315402E7-90FC-4E07-B4BB-03155D68A1B4">
                                 <p class="notep1">注意：</p>
                                 <p></p>
                                 <ul style="list-style-type:disc">
                                    <li>
                                       <p>不允许嵌套结构。</p>
                                    </li>
                                    <li>
                                       <p>此语句不能用于将可引用对象设置为原子NULL。改为设置NULL指示符的相应字段。</p>
                                    </li>
                                    <li>
                                       <p>不支持OCIDateTime或OCIInterval数据类型与OCIString之间的转换。</p>
                                    </li>
                                 </ul>
                              </div>
                           </li>
                        </ul>
                     </div>
                     <!-- class="section" -->
                  </div>
               </div><a id="LNPCC4344"></a><div class="props_rev_3"><a id="GUID-C8E8F151-455E-45FD-AA11-68DD84D6B411" name="GUID-C8E8F151-455E-45FD-AA11-68DD84D6B411"></a><h4 id="LNPCC-GUID-C8E8F151-455E-45FD-AA11-68DD84D6B411" class="sect4"><span class="enumeration_section">17.6.2</span>对象获取</h4>
                  <div>
                     <div class="section"><pre class="oac_no_warn" dir="ltr">EXEC SQL [AT [：] <span class="italic">database</span> ] OBJECT GET [{'*'| { <span class="italic">attr</span> [， <span class="italic">attr</span> ]}} FROM]： <span class="italic">obj</span> [[INDICATOR]： <span class="italic">obj_ind</span> ] INTO {： <span class="italic">hv</span> [[INDICATOR]： <span class="italic">hv_ind</span> ] [，： <span class="italic">hv</span> [[INDICATOR]： <span class="italic">hv_ind</span> ]]};</pre><p>此语句将对象的属性转换为本机C类型。</p>
                        <p>FROM子句是可选的。如果不存在，则转换<span class="italic">obj的</span>所有属性。写作相同的结果：</p><pre class="oac_no_warn" dir="ltr">...OBJECT GET * FROM ...
</pre><p>主变量列表可以包括被分解以接收属性值的结构。但是， <span class="italic">obj中</span>的属性数必须与展开的主机变量列表中的元素数相匹配。
                        </p>
                        <p>主机变量和属性：</p>
                        <p>ATTR</p>
                        <p>属性不是主机变量，而是指定将检索对象的哪些属性的简单标识符。列表中的第一个属性与列表中的第一个主变量配对，依此类推。该属性必须表示基本类型。它必须是OCIString，OCINumber，OCIRef或OCIDate。</p>
                        <p>obj（IN）</p>
                        <p>这指定了用作属性检索源的对象。绑定变量<span class="italic">obj</span>不能是数组。
                        </p>
                        <p>hv（OUT）</p>
                        <p>这是用于保存OBJECT GET语句输出的绑定变量。它可以是int，float，double，一维char数组或包含这些类型的结构。该语句返回此主机变量中的转换属性值。</p>
                        <p>hv_ind（OUT）</p>
                        <p>这是属性值的关联指示符变量。它是一个2字节的整数标量或2字节整数标量的结构。</p>
                        <p>使用指标变量：</p>
                        <p>如果未指定对象指示符，则假定该属性有效。如果对象是原子级NULL或者请求的属性为NULL且未提供对象指示符变量，则将对象属性转换为C类型<span class="italic">是一个程序错误</span> 。<span class="italic">在这种情况下可能无法引发Oracle错误。</span></p>
                        <p>如果对象变量是原子级NULL或请求的属性为NULL，并且提供了主机变量指示符（ <span class="italic">hv_ind</span> ），则将其设置为-1。
                        </p>
                        <p>如果对象是原子级NULL或请求的属性为NULL，并且未提供主机变量指示符，则会引发错误。</p>
                        <p>允许以下隐式转换：</p>
                        <ul style="list-style-type:disc">
                           <li>
                              <p>OCIString到[STRING | VARCHAR | CHARZ | OCIString]</p>
                           </li>
                           <li>
                              <p>OCINumber到[int |漂浮|双| OCINumber]</p>
                           </li>
                           <li>
                              <p>OCIRef to OCIRef</p>
                           </li>
                           <li>
                              <p>OCI日期为[STRING | VARCHAR | CHARZ | OCIDate]</p>
                              <div class="infoboxnote" id="GUID-C8E8F151-455E-45FD-AA11-68DD84D6B411__GUID-A400A61B-9414-477C-9ACC-1BC5EE8357BD">
                                 <p class="notep1">注意：</p>
                                 <ul style="list-style-type:disc">
                                    <li>
                                       <p>不允许嵌套结构</p>
                                    </li>
                                    <li>
                                       <p>不支持OCIDateTime或OCIInterval数据类型与OCIString之间的转换</p>
                                    </li>
                                 </ul>
                              </div>
                           </li>
                        </ul>
                     </div>
                     <!-- class="section" -->
                  </div>
               </div>
            </div><a id="LNPCC4345"></a><div class="props_rev_3"><a id="GUID-23A4843B-0673-4698-9358-9A714507D4DD" name="GUID-23A4843B-0673-4698-9358-9A714507D4DD"></a><h3 id="LNPCC-GUID-23A4843B-0673-4698-9358-9A714507D4DD" class="sect3"><span class="enumeration_section">17.7</span>对象选项设置/获取</h3>
               <div>
                  <p>运行时上下文具有在创建和分配运行时上下文时设置为缺省值的选项。然后，您可以使用此嵌入式SQL指令设置这些选项：</p>
               </div><a id="LNPCC4347"></a><a id="LNPCC4346"></a><div class="props_rev_3"><a id="GUID-A603BDFE-FBB4-481C-9369-BAC53ABE4C59" name="GUID-A603BDFE-FBB4-481C-9369-BAC53ABE4C59"></a><h4 id="LNPCC-GUID-A603BDFE-FBB4-481C-9369-BAC53ABE4C59" class="sect4"><span class="enumeration_section">17.7.1</span>上下文对象选项集</h4>
                  <div>
                     <div class="section"><pre class="oac_no_warn" dir="ltr">EXEC SQL语境对象选项集{ <span class="italic">option</span> [， <span class="italic">option</span> ]} TO {： <span class="italic">hv</span> [，： <span class="italic">hv</span> ]};</pre><p>变量在哪里：</p>
                        <p>：hv（IN）......</p>
                        <p>输入绑定变量<span class="italic">hv ...</span>的类型为STRING，VARCHAR或CHARZ。</p>
                        <p>选项 ...</p>
                        <p>简单标识符，指定要更新的运行时上下文的哪个选项。第一个选项与第一个输入绑定变量配对，依此类推。以下是此时支持的值：</p>
                     </div>
                     <!-- class="section" -->
                     <div class="tblformal" id="GUID-A603BDFE-FBB4-481C-9369-BAC53ABE4C59__G470077">
                        <p class="titleintable">表17-1上下文对象选项值的有效选择</p>
                        <table cellpadding="4" cellspacing="0" class="Formal" title="上下文对象选项值的有效选择" width="100%" border="1" summary="Valid Choices for CONTEXT OBJECT OPTION Values" frame="hsides" rules="rows">
                           <thead>
                              <tr align="left" valign="top">
                                 <th align="left" valign="bottom" width="31%" id="d93390e1880">期权价值</th>
                                 <th align="left" valign="bottom" width="69%" id="d93390e1883">指定</th>
                              </tr>
                           </thead>
                           <tbody>
                              <tr align="left" valign="top">
                                 <td align="left" valign="top" width="31%" id="d93390e1888" headers="d93390e1880 ">
                                    <p>日期格式</p>
                                 </td>
                                 <td align="left" valign="top" width="69%" headers="d93390e1888 d93390e1883 ">
                                    <p>Date属性和集合元素的格式。</p>
                                 </td>
                              </tr>
                              <tr align="left" valign="top">
                                 <td align="left" valign="top" width="31%" id="d93390e1895" headers="d93390e1880 ">
                                    <p>DATELANG</p>
                                 </td>
                                 <td align="left" valign="top" width="69%" headers="d93390e1895 d93390e1883 ">
                                    <p>所有日期和日期时间类型的全球化支持语言。</p>
                                 </td>
                              </tr>
                           </tbody>
                        </table>
                     </div>
                     <!-- class="inftblhruleinformal" -->
                     <div class="section">
                        <p>一个例子是：</p><pre class="oac_no_warn" dir="ltr">char * new_format =“DD-MM-YYYY”; char * new_lang =“法语”; char * new_date =“14-07-1789”; / *许可证类型的一个属性是dateofbirth * / license * aLicense; .../ *上下文的声明和分配......* / EXEC SQL语境对象选项设置DATEFORMAT，DATELANG TO：new_format，：new_lang; / *获得的导航对象* / ...EXEC SQL OBJECT SET dateofbirth OF：aLicense TO：new_date; ...
</pre></div>
                     <!-- class="section" -->
                  </div>
                  <div>
                     <div class="relinfo">
                        <p><strong>相关话题</strong></p>
                        <ul>
                           <li><a href="../sqlrf/index.html" target="_blank"><span><cite>Oracle数据库SQL语言参考</cite></span></a></li>
                           <li><a href="embedded-SQL-statements-and-directives.html#GUID-7DABE6B3-BAA8-4A66-AF65-AD1216F7E897">上下文对象选项集（可执行嵌入式SQL Ext）</a></li>
                        </ul>
                     </div>
                  </div>
               </div><a id="LNPCC4348"></a><div class="props_rev_3"><a id="GUID-AAC33859-0CB5-4944-B816-9F0D3A6608AC" name="GUID-AAC33859-0CB5-4944-B816-9F0D3A6608AC"></a><h4 id="LNPCC-GUID-AAC33859-0CB5-4944-B816-9F0D3A6608AC" class="sect4"><span class="enumeration_section">17.7.2</span>上下文对象选项获取</h4>
                  <div>
                     <div class="section">
                        <p>受影响的上下文被理解为当时使用的上下文。要确定这些选项的值，请使用以下指令：</p><pre class="oac_no_warn" dir="ltr">EXEC SQL语境对象选项获取{ <span class="italic">option</span> [， <span class="italic">option</span> ]} INTO {： <span class="italic">hv</span> [，： <span class="italic">hv</span> ]};</pre><p><a href="about-Objects.html#GUID-A603BDFE-FBB4-481C-9369-BAC53ABE4C59__G470077" title="上下文对象选项值的有效选择">表17-1中</a>的<span class="italic">选项</span>值。
                        </p>
                        <p>绑定变量<span class="italic">hv</span> ...用作输出，类型为STRING，VARCHAR或CHARZ。受影响的上下文被理解为当时使用的上下文。
                        </p>
                     </div>
                     <!-- class="section" -->
                  </div>
                  <div>
                     <div class="relinfo">
                        <p><strong>相关话题</strong></p>
                        <ul>
                           <li><a href="../sqlrf/index.html" target="_blank"><span><cite>Oracle数据库SQL语言参考</cite></span></a></li>
                           <li><a href="embedded-SQL-statements-and-directives.html#GUID-CEEE04CB-1726-4DFD-B097-0489DC93C188">上下文对象选项GET（可执行的嵌入式SQL扩展）</a></li>
                        </ul>
                     </div>
                  </div>
               </div>
            </div><a id="LNPCC4349"></a><div class="props_rev_3"><a id="GUID-DFA7F6BD-766A-440C-A5EC-EF97466F4EFB" name="GUID-DFA7F6BD-766A-440C-A5EC-EF97466F4EFB"></a><h3 id="LNPCC-GUID-DFA7F6BD-766A-440C-A5EC-EF97466F4EFB" class="sect3"><span class="enumeration_section">17.8</span>对象的新预编译器选项</h3>
               <div>
                  <p>要支持对象，请使用以下预编译器选项：</p>
               </div><a id="LNPCC4350"></a><div class="props_rev_3"><a id="GUID-BE4EEED6-BA68-4BD9-9537-511C5890A91F" name="GUID-BE4EEED6-BA68-4BD9-9537-511C5890A91F"></a><h4 id="LNPCC-GUID-BE4EEED6-BA68-4BD9-9537-511C5890A91F" class="sect4"><span class="enumeration_section">17.8.1</span>版本</h4>
                  <div>
                     <div class="section">
                        <p>此选项确定EXEC SQL OBJECT DEREF语句返回的对象版本。这为您提供了缓存对象和服务器对象之间不同级别的一致性。</p>
                        <p>使用EXEC ORACLE OPTION语句将其设置为内联。允许的值是：</p>
                        <dl>
                           <dt class="dlterm"><a name="GUID-BE4EEED6-BA68-4BD9-9537-511C5890A91F__GUID-8EA7B6E0-86C1-4753-B379-371DFA189A57"><!-- --></a>最近（默认）</dt>
                           <dd>
                              <p>如果已在当前事务中将对象选择到对象缓存中，则返回该对象。如果尚未选择该对象，则从服务器检索该对象。对于以可序列化模式运行的事务，此选项与VERSION = LATEST具有相同的行为，而不会产生尽可能多的网络往返。该值可以安全地用于大多数Pro * C / C ++应用程序。</p>
                           </dd>
                           <dt class="dlterm"><a name="GUID-BE4EEED6-BA68-4BD9-9537-511C5890A91F__GUID-72749A9E-F1FE-46AE-91F9-021E9DCB4BB4"><!-- --></a>最新</dt>
                           <dd>
                              <p>如果对象不驻留在对象缓存中，则从数据库中检索它。如果它确实驻留在对象缓存中，则会从服务器刷新。谨慎使用此值，因为它将导致最大数量的网络往返。仅在必须使对象缓存与服务器端缓冲区保持一致时才使用它。</p>
                           </dd>
                           <dt class="dlterm"><a name="GUID-BE4EEED6-BA68-4BD9-9537-511C5890A91F__GUID-44050852-95C1-4CAC-AE3B-01E4BB883F32"><!-- --></a>任何</dt>
                           <dd>
                              <p>如果对象已驻留在对象缓存中，则返回该对象。如果对象不驻留在对象缓存中，请从服务器检索它。该值将导致最少的网络往返次数。用于访问只读对象的应用程序或用户可以独占访问对象的应用程序。</p>
                           </dd>
                        </dl>
                     </div>
                     <!-- class="section" -->
                  </div>
               </div><a id="LNPCC4351"></a><div class="props_rev_3"><a id="GUID-E9122145-AFB2-47A8-B6F7-33E279840610" name="GUID-E9122145-AFB2-47A8-B6F7-33E279840610"></a><h4 id="LNPCC-GUID-E9122145-AFB2-47A8-B6F7-33E279840610" class="sect4"><span class="enumeration_section">17.8.2</span>持续时间</h4>
                  <div>
                     <div class="section">
                        <p>使用此预编译器选项设置后续EXEC SQL OBJECT CREATE和EXEC SQL OBJECT DEREF语句使用的引脚持续时间。缓存中的对象在持续时间结束时隐式取消固定。</p>
                        <p>仅用于导航界面。</p>
                        <p>您可以在EXEC ORACLE OPTION语句中设置此选项。允许的值是：</p>
                        <dl>
                           <dt class="dlterm"><a name="GUID-E9122145-AFB2-47A8-B6F7-33E279840610__GUID-310D64C4-1C65-44D0-B888-93E013CCA154"><!-- --></a>交易（默认）</dt>
                           <dd>
                              <p>事务完成后，对象将被隐式取消固定。</p>
                           </dd>
                           <dt class="dlterm"><a name="GUID-E9122145-AFB2-47A8-B6F7-33E279840610__GUID-E5F49AF7-5D85-4BB1-9D5E-8364B151F061"><!-- --></a>会话</dt>
                           <dd>
                              <p>终止连接时隐式取消固定对象。</p>
                           </dd>
                        </dl>
                     </div>
                     <!-- class="section" -->
                  </div>
               </div><a id="LNPCC4352"></a><div class="props_rev_3"><a id="GUID-80A0FDFE-ECE3-45BE-B956-BCF0959D03C6" name="GUID-80A0FDFE-ECE3-45BE-B956-BCF0959D03C6"></a><h4 id="LNPCC-GUID-80A0FDFE-ECE3-45BE-B956-BCF0959D03C6" class="sect4"><span class="enumeration_section">17.8.3</span>对象</h4>
                  <div>
                     <div class="section">
                        <p>此预编译器选项提供了使用对象缓存的功能。</p>
                        <p>OBJECTS默认值，对于DBMS = NATIVE | V8，是的。对象缓存的默认大小与OCI默认缓存大小（8 MB）相同。</p>
                     </div>
                     <!-- class="section" -->
                  </div>
                  <div>
                     <div class="relinfo">
                        <p><strong>相关话题</strong></p>
                        <ul>
                           <li><a href="precompiler-options.html#GUID-5977237E-3C95-4BA1-BD35-5480482C1364">物体</a></li>
                        </ul>
                     </div>
                  </div>
                  
               </div><a id="LNPCC4353"></a><div class="props_rev_3"><a id="GUID-63254024-61DB-4A8B-B832-7E044CF2E1FF" name="GUID-63254024-61DB-4A8B-B832-7E044CF2E1FF"></a><h4 id="LNPCC-GUID-63254024-61DB-4A8B-B832-7E044CF2E1FF" class="sect4"><span class="enumeration_section">17.8.4</span> INTYPE</h4>
                  <div>
                     <div class="section">
                        <p>如果程序使用任何对象类型，集合对象类型或REF，则必须在此命令行选项中指定INTYPE文件。</p>
                        <p>指定INTYPE <span class="bold"> </span>选项使用语法：</p><pre class="oac_no_warn" dir="ltr">INTYPE = <span class="italic">filename1</span> INTYPE = <span class="italic">filename2</span> ...
</pre><p>其中<span class="italic">filename1</span>等等是OTT生成的类型<span class="italic">文件</span>的名称。这些文件是Pro * C / C ++的只读输入。其中的信息虽然是纯文本形式，但可能会被编码，并且可能不一定是您（用户）可以解释的。
                        </p>
                        <p>您可以提供多个INTYPE文件作为单个Pro * C / C ++预编译单元的输入。</p>
                        <p>此选项不能在EXEC ORACLE语句中内联使用。</p>
                        <p>OTT为在数据库中创建的对象类型生成C结构声明，并将类型名称和版本信息写入名为<span class="italic">typefile</span>的文件<span class="italic">。</span></p>
                        <p>对象类型可能不一定与C结构类型或表示它的C ++类类型具有相同的名称。出现这种情况的原因如下：</p>
                        <ul style="list-style-type:disc">
                           <li>
                              <p>服务器中指定的对象类型的名称包括C或C ++标识符中不合法的字符</p>
                           </li>
                           <li>
                              <p>用户要求OTT为结构或类使用不同的名称</p>
                           </li>
                           <li>
                              <p>用户要求OTT更改名称的大小写</p>
                           </li>
                        </ul>
                        <p>在这种情况下，不可能从结构或类声明中推断出它匹配的对象类型。Pro * C / C ++所需的此信息由OTT在类型文件中生成。</p>
                     </div>
                     <!-- class="section" -->
                  </div>
               </div><a id="LNPCC4354"></a><div class="props_rev_3"><a id="GUID-8FDF4410-C21A-4221-8649-3103E6B93017" name="GUID-8FDF4410-C21A-4221-8649-3103E6B93017"></a><h4 id="LNPCC-GUID-8FDF4410-C21A-4221-8649-3103E6B93017" class="sect4"><span class="enumeration_section">17.8.5</span> ERRTYPE</h4>
                  <div>
                     <div class="section"><pre class="oac_no_warn" dir="ltr">ERRTYPE = <span class="italic">文件名</span>
</pre><p>将错误写入指定的文件以及屏幕。如果省略，则错误仅指向屏幕。只允许一个ERRTYPE。与其他单值命令行选项一样，如果在命令行中为ERRTYPE输入多个值，则最后一个值将取代之前的值。</p>
                        <p>此选项不能在EXEC ORACLE语句中内联使用。</p>
                     </div>
                     <!-- class="section" -->
                  </div>
               </div><a id="LNPCC4355"></a><div class="props_rev_3"><a id="GUID-C9CB010C-FA5B-46BE-8F7C-BF7EB3E6D632" name="GUID-C9CB010C-FA5B-46BE-8F7C-BF7EB3E6D632"></a><h4 id="LNPCC-GUID-C9CB010C-FA5B-46BE-8F7C-BF7EB3E6D632" class="sect4"><span class="enumeration_section">17.8.6</span> SQLCHECK支持对象</h4>
                  <div>
                     <div class="section">
                        <p>根据Oracle类型的C绑定，对象类型及其属性在C程序中表示。如果预编译器命令行选项SQLCHECK设置为SEMANTICS或FULL，则Pro * C / C ++在预编译期间验证主机变量类型是否符合数据库模式中类型的强制C绑定。此外，始终执行运行时检查以验证在程序执行期间是否正确映射了Oracle类型。</p>
                        <p>以通常方式检查关系数据类型。</p>
                        <p>如果两种类型相同，或者两者之间允许转换，则关系SQL数据类型与主机变量类型兼容。另一方面，对象类型只有在相同类型时才兼容。他们一定</p>
                        <ul style="list-style-type:disc">
                           <li>
                              <p>有相同的名字</p>
                           </li>
                           <li>
                              <p>处于相同的模式中（如果明确指定了模式）</p>
                           </li>
                        </ul>
                        <p>当您指定选项SQLCHECK = SEMANTICS或FULL时，在预编译期间，Pro * C / C ++使用指定的用户标识和密码登录到数据库，并验证生成结构声明的对象类型是否与在中使用的对象类型相同嵌入式SQL语句。</p>
                     </div>
                     <!-- class="section" -->
                  </div>
               </div><a id="LNPCC4356"></a><div class="props_rev_3"><a id="GUID-17CEB7F6-F667-4F48-B787-BD9C7A9F58D8" name="GUID-17CEB7F6-F667-4F48-B787-BD9C7A9F58D8"></a><h4 id="LNPCC-GUID-17CEB7F6-F667-4F48-B787-BD9C7A9F58D8" class="sect4"><span class="enumeration_section">17.8.7</span>运行时类型检查</h4>
                  <div>
                     <p>Pro * C / C ++为输入INTYPE文件中的类型收集Object，集合Object和REF主变量的类型名称，版本和可能的模式信息，并将此信息存储在它生成的代码中。这样可以在运行时访问Object和REF绑定变量的类型信息。类型不匹配会返回适当的错误。</p>
                  </div>
               </div>
            </div><a id="LNPCC4357"></a><div class="props_rev_3"><a id="GUID-34AFC95A-2A0F-4925-86F6-865E204CCBB4" name="GUID-34AFC95A-2A0F-4925-86F6-865E204CCBB4"></a><h3 id="LNPCC-GUID-34AFC95A-2A0F-4925-86F6-865E204CCBB4" class="sect3"><span class="enumeration_section">17.9</span> Pro * C / C ++中的对象示例</h3>
               <div>
                  <p>让我们来看一个简单的对象示例。您创建一个类型<span class="italic">人员</span>和一个表<span class="italic">person_tab，</span>其列也是一个对象类型， <span class="italic">地址</span> ：</p><pre class="oac_no_warn" dir="ltr">create type person as object（lastname varchar2（20），firstname char（20），age int，addr address）/ create table person_tab of person;</pre><p>在表格中插入数据，然后继续。</p>
               </div><a id="LNPCC4358"></a><div class="props_rev_3"><a id="GUID-5E026BB2-1239-4F0D-A81D-6415F0E78CE2" name="GUID-5E026BB2-1239-4F0D-A81D-6415F0E78CE2"></a><h4 id="LNPCC-GUID-5E026BB2-1239-4F0D-A81D-6415F0E78CE2" class="sect4"><span class="enumeration_section">17.9.1</span>关联访问</h4>
                  <div>
                     <p>考虑如何使用Pro * C / C ++将<span class="italic">姓氏</span>值从“Smith”更改为“Smythe”。
                     </p>
                     <p>运行OTT以生成映射到<span class="italic">人的</span> C结构。在Pro * C / C ++程序中，您必须包含OTT生成的头文件。</p>
                     <p>在您的应用程序中，将指针<span class="italic">person_p</span>声明到客户端缓存中的持久内存。然后分配内存并使用返回的指针：</p><pre class="oac_no_warn" dir="ltr">char * new_name =“Smythe”; person * person_p; ...EXEC SQL ALLOCATE：person_p;</pre><p>现在为内存对象的副本分配内存。分配的对象尚未包含数据。</p>
                     <p>通过C赋值语句或使用SELECT或FETCH来检索现有对象，从而在缓存中填充数据：</p><pre class="oac_no_warn" dir="ltr">EXEC SQL SELECT VALUE（p）INTO：person_p FROM person_tab p WHERE lastname ='Smith';</pre><p>通过使用INSERT，UPDATE和DELETE语句将对缓存中的副本所做的更改传输到服务器数据库：</p><pre class="oac_no_warn" dir="ltr">EXEC SQL OBJECT SET姓氏：person_p TO：new_name; EXEC SQL INSERT INTO person_tab VALUES（：person_p）;</pre><p>以这种方式释放高速缓存：</p><pre class="oac_no_warn" dir="ltr">EXEC SQL FREE：person_p;</pre></div>
               </div><a id="LNPCC4359"></a><div class="props_rev_3"><a id="GUID-4CD81205-0436-409C-A1FC-46442159BFCD" name="GUID-4CD81205-0436-409C-A1FC-46442159BFCD"></a><h4 id="LNPCC-GUID-4CD81205-0436-409C-A1FC-46442159BFCD" class="sect4"><span class="enumeration_section">17.9.2</span>导航访问</h4>
                  <div>
                     <p>在对象缓存中分配内存，以便将REF副本分配给对象<span class="italic">人员</span> 。ALLOCATE语句返回指向REF的指针：</p><pre class="oac_no_warn" dir="ltr">person * person_p; person_ref * per_ref_p; ...EXEC SQL ALLOCATE：per_ref_p;</pre><p>分配的REF不包含任何数据。要使用数据填充它，请检索对象的REF：</p><pre class="oac_no_warn" dir="ltr">EXEC SQL SELECT ...INTO：per_ref_p;</pre><p>然后取消引用REF以将对象的实例放在客户端缓存中。dereference命令使用<span class="italic">per_ref_p</span>并在缓存中创建相应对象的实例：</p><pre class="oac_no_warn" dir="ltr">EXEC SQL OBJECT DEREF：per_ref_p INTO：person_p;</pre><p>使用C分配或使用OBJECT GET语句更改缓存中的数据：</p><pre class="oac_no_warn" dir="ltr">/ * lname是一个C变量，用于保存结果* / EXEC SQL OBJECT GET lastname FROM：person_p INTO：lname; ...EXEC SQL OBJECT SET姓氏：person_p TO：new_name; / *使用OBJECT UPDATE命令将已更改的对象标记为已更改* /; EXEC SQL OBJECT UPDATE：person_p; EXEC SQL FREE：per_ref_p;</pre><p>要在数据库中永久更改，请使用FLUSH：</p><pre class="oac_no_warn" dir="ltr">EXEC SQL OBJECT FLUSH：person_p;</pre><p>已对服务器进行了更改;现在可以释放该对象。释放的对象不一定立即从对象缓存中释放。它们被放置在最近最少使用的堆栈上。当缓存已满时，对象将被换出内存。</p>
                     <p>只释放对象;对象的REF保留在缓存中。要释放REF，请使用RELEASE语句。对于REF。要释放<code class="codeph">person_p</code>指向的对象：</p><pre class="oac_no_warn" dir="ltr">EXEC SQL OBJECT RELEASE：person_p;</pre><p>或者，如果已正确设置引脚持续时间，则发出事务提交并释放缓存中的所有对象。</p>
                  </div>
               </div>
            </div><a id="LNPCC4360"></a><div class="props_rev_3"><a id="GUID-47435013-11A1-4977-AE0E-8A51F66D29C3" name="GUID-47435013-11A1-4977-AE0E-8A51F66D29C3"></a><h3 id="LNPCC-GUID-47435013-11A1-4977-AE0E-8A51F66D29C3" class="sect3"><span class="enumeration_section">17.10</span>类型继承的示例代码</h3>
               <div>
                  <div class="section">
                     <p><a id="d93390e2502" class="indexterm-anchor"></a>以下代码示例创建四种对象类型：</p>
                     <ul style="list-style-type:disc">
                        <li>
                           <p>PERSON_T</p>
                        </li>
                        <li>
                           <p><code class="codeph">Employee_t</code>作为<code class="codeph">Person_t</code>的子类型</p>
                        </li>
                        <li>
                           <p><code class="codeph">Student_t</code>作为<code class="codeph">Person_t</code>的子类型</p>
                        </li>
                        <li>
                           <p><code class="codeph">PartTimeStudent_t</code>作为的一个亚型<code class="codeph">Student_t</code> 
                           </p>
                        </li>
                     </ul>
                     <p>和一张桌子：</p>
                     <ul style="list-style-type:disc">
                        <li>
                           <p><code class="codeph">person_tab</code>用于保存<code class="codeph">Person_t</code>及其子类型对象</p>
                        </li>
                     </ul>
                     <p></p>
                     <p>创建对象类型和表，然后在表中插入值的SQL文件<code class="codeph">inhdemo1.sql</code>是：</p>
                     <p></p><pre class="oac_no_warn" dir="ltr">连接斯科特/老虎; rem **始终将对象放在反向依赖顺序删除表person_tab中; drop类型PartTimeStudent_t; drop type Student_t; drop type Employee_t; drop类型Person_t; rem **创建TYPES，TYPED TABLES和TABLES我们需要rem **创建一个Person_t ADT CREATE TYPE Person_t AS OBJECT（ssn NUMBER，name VARCHAR2（30），address VARCHAR2（100））NOT FINAL; / rem **创建一个Person_t子类型Employee_t CREATE TYPE Employee_t UNDER Person_t（empid NUMBER，mgr VARCHAR2（30））; / rem **创建一个Person_t子类型Student_t CREATE TYPE Student_t UNDER Person_t（deptid NUMBER，major VARCHAR2（30））NOT FINAL; / rem **创建一个Student_t子类型PartTimeStudent_t CREATE TYPE PartTimeStudent_t UNDER Student_t（numhours NUMBER）; / rem **为person_t对象创建一个类型表CREATE table person_tab of person_t; rem **将2个Employee_t对象插入person_t类型表插入person_tab值（Employee_t（123456，'Alison Laurence'，'100 Geary Street，San Francisco，CA 94013'，1001，'CEO'））;插入person_tab值（Employee_t（234567，'William Bates'，'123 Main Street，Anytown，WA 97818'，1002，'CFO'））; rem **将2个Student_t对象插入person_t类型表插入person_tab值（Student_t（20001，'Van Gates'，'1825 Aikido Way，Los Angeles，CA，45300'，20，'English'））;插入person_tab值（Student_t（20002，'Bill Wallace'，'12 Shugyo Blvd，Los Angeles，CA，95100'，30，'Computer Science'））; rem **将1个PartTimeStudent_t对象插入person_t类型表插入person_tab值（PartTimeStudent_t（20003，'Jean Claude'，'874 Richmond Street，New York，NY 45100'，40，'Music'，20））;承诺;</pre><p></p>
                     <p>以下是我们的示例<code class="codeph">inhdemo1.typ</code>的intype文件<code class="codeph">inhdemo1.typ</code> ：</p>
                     <p></p><pre class="oac_no_warn" dir="ltr">case =相同类型person_t类型employee_t类型student_t类型parttimestudent_t</pre><p></p>
                     <p>以下是预编译器文件<code class="codeph">inhdemo1.pc</code> ：</p>
                     <p></p><pre class="oac_no_warn" dir="ltr">/ ******************* **************************** * *这是一个简单的Pro * C / C ++程序，旨在说明如何*访问类型继承对象。* *构建可执行文件：* * 1。在SQL * Plus中执行SQL脚本inhdemo1.sql来创建：*  -  4个对象类型person_t，employee_t作为person_t的子类型，* student_t作为person_t的子类型，parttimestudent_t作为* student_t的子类型。*  -  1个用于保存“person_t”的类型表person_tab及其子类型对象* * 2。运行OTT :(以下命令应出现在一行上）* ott intype = inhdemo1.typ hfile = inhdemo1.h outtype = out.typ * code = c userid = scott / tiger * * 3。使用Pro * C / C ++预编译：* proc inhdemo1 intype = out.typ * 4。编译/链接（此步骤是特定于平台的）* *************************************** ************************************* //包含文件* / #include &lt;stdio.h &gt; #include &lt;stdlib.h&gt; #include &lt;string.h&gt; #include &lt;sqlda.h&gt; #include &lt;sqlca.h&gt; / * SQL通讯区* / #include &lt;sql2oci.h&gt; / * OCI8的SQLLIB互操作性例程* / #include“inhdemo1.h”/ * OTT生成的标头，带有C typedef，用于* / / *数据库类型“person”和“address”* / / *宏* / #define ARRAY_SIZE 10 #define NAME_LENGTH 31 #define ADDR_LENGTH 101 / *全局变量* / char * uid =“scott / tiger”; int i; int count; VARCHAR dynstmt [100]; main（）{printf（“\ n *** STARTING OBJECT TYPE INHERITANCE DEMO *** \ n”）;执行SQL WHENEVER SQLERROR DO sql_error（“ORACLE error  -  \ n”）; EXEC SQL连接：uid; printf（“已成功连接。\ n”）; exec sql select count（*）into：count from person_tab; printf（“\ n表person_tab中有％d个条目。\ n”，count）; do_fetch_all（）; / *获取person_t对象* / do_fetch_employee（）; / *获取employee_t对象* / do_fetch_student（）; / *仅获取student_t对象* / do_fetch_parttimestudent（）; / *获取parttimestuden_t对象* / do_fetch_student_employee（）; / *获取student_t和employee_t对象* / printf（“\ n仅使用动态sql获取student_t对象：\ n”）; strcpy（（char *）dynstmt.arr，“person_tab p中的SELECT值（p），其中value（p）是（only student_t）”）; do_dynamic_fetch（）; / *使用动态sql * / printf（“\ n获取student_t及其子类型对象与动态sql：\ n”）获取student_t对象; strcpy（（char *）dynstmt.arr，“SELECT treat（value（p）as student_t）from person_tab p，其中value（p）是（student_t）”）; do_dynamic_fetch（）; / *使用动态sql * / printf获取student_t对象（“\ n ***对象类型继承演示结束*** \ n”）;出口（EXIT_SUCCESS）; } void printPerson（person）person_t * person; {int writtenSSN = -1; text writtenName [NAME_LENGTH]; text writtenAddr [ADDR_LENGTH]; EXEC SQL OBJECT获取SSN，NAME，ADDRESS FROM：person INTO：writtenSSN，：writtenName，：writtenAddr; printf（“\ nSSN =％10d \ nNAME =％s \ nAddr =％s \ n”，写入SSN，writeName，writtenAddr）; } void printEmployee（employee）employee_t * employee; {int writtenID = -1; text writtenMgr [NAME_LENGTH]; printPerson（雇员）; EXEC SQL OBJECT获取EMPID，MGR FROM：employee INTO：writtenID，：writtenMgr; printf（“EMPID =％10d \ nMGR =％s \ n”，writeID，writtenMgr）; } void printStudent（student）student_t * student; {int writtendeptid = -1; text writtenMajor [NAME_LENGTH]; printPerson（学生）; EXEC SQL OBJECT获得DEPTID，主要来自：学生INTO：writdeptid，：writtenMajor; printf（“DEPTID =％10d \ nMAJOR =％s \ n”，writedeptid，writtenMajor）; } void printPartTimeStudent（parttimes）parttimestudent_t * parttimes; {int written_numhours = -1; printStudent（parttimes）; EXEC SQL OBJECT GET NUMHOURS FROM：parttimes INTO：written_numhours; printf（“NUMHOURS =％10d \ n”，writ_numhours）; } / *声明错误处理函数。* / sql_error（msg）char * msg; {char err_msg [128]; size_t buf_len，msg_len; EXEC SQL WHENEVER SQLERROR CONTINUE; printf（“\ n％s \ n”，msg）; buf_len = sizeof（err_msg）; sqlglm（err_msg，＆buf_len，＆msg_len）; printf（“％。* s \ n”，msg_len，err_msg）; EXEC SQL ROLLBACK RELEASE;出口（EXIT_FAILURE）; / ************************************************ ***************************** *以下函数显示如何选择person_t对象*********** ************************************************** *************** / do_fetch_all（）{person_t * personArray [ARRAY_SIZE]; person_t_ind * personArray_ind [ARRAY_SIZE]; printf（“\ nFetching person_t objects：\ n”）; exec sql为person_tab p中的select value（p）声明c1游标; exec sql allocate：personArray：personArray_ind; exec sql open c1;每次都没有找到exec sql goto：done; while（sqlca.sqlcode == 0）{exec sql fetch c1 into：personArray：personArray_ind; if（sqlca.sqlcode == 1403）goto done; for（i = 0; i &lt;ARRAY_SIZE; i ++）printPerson（personArray [i]）; } done：for（i = 0; i &lt;sqlca.sqlerrd [2]％ARRAY_SIZE; i ++）printPerson（personArray [i]）; printf（“获取的person_t对象的总数：％d。\ n”，sqlca.sqlerrd [2]）; exec sql close c1; exec sql free：personArray：personArray_ind; / ************************************************ ***************************** *以下函数显示如何选择person_t子类型employee_t *对象******** ************************************************** ****************** / do_fetch_employee（）{employee_t * empArray [ARRAY_SIZE]; employee_t_ind * empArray_ind [ARRAY_SIZE]; printf（“\ nFetching employee_t objects：\ n”）; exec sql allocate：empArray：empArray_ind; exec sql声明c2游标，用于从person_tab p中选择值（p），其中value（p）是（employee_t）; exec sql open c2; exec sql什么时候找不到goto：done_emp; while（sqlca.sqlcode == 0）{exec sql fetch c2 into：empArray：empArray_ind; for（i = 0; i &lt;ARRAY_SIZE; i ++）printEmployee（empArray [i]）; } done_emp：for（i = 0; i &lt;sqlca.sqlerrd [2]％ARRAY_SIZE; i ++）printEmployee（empArray [i]）; printf（“获取的employee_t对象的总数：％d。\ n”，sqlca.sqlerrd [2]）; exec sql close c2; exec sql free：empArray：empArray_ind; / ************************************************ ***************************** *以下函数显示如何选择person_t子类型student_t *对象******** ************************************************** ****************** / do_fetch_student（）{student_t * studentArray [ARRAY_SIZE]; student_t_ind * studentArray_ind [ARRAY_SIZE]; printf（“\ nFetching student_t objects：\ n”）; exec sql声明c3游标用于从person_tab p中选择值（p），其中value（p）是（student_t）; exec sql allocate：studentArray：studentArray_ind; exec sql open c3;每次都没有找到exec sql goto：done_student; for（;;）{exec sql fetch c3 into：studentArray：studentArray_ind; for（i = 0; i &lt;ARRAY_SIZE; i ++）printStudent（studentArray [i]）; } done_student：for（i = 0; i &lt;sqlca.sqlerrd [2]％ARRAY_SIZE; i ++）printStudent（studentArray [i]）; printf（“获取的student_t对象的总数：％d。\ n”，sqlca.sqlerrd [2]）; exec sql close c3; exec sql免费：studentArray：studentArray_ind; / ************************************************ ***************************** *以下函数显示如何选择student_t子类型* parttimestudent对象******** ************************************************** ****************** / do_fetch_parttimestudent（）{parttimestudent_t * parttimestudentArrayArray [ARRAY_SIZE]; parttimestudent_t_ind * parttimestudentArrayArray_ind [ARRAY_SIZE]; printf（“\ nFetching parttimestudent_t objects：\ n”）; exec sql声明c4游标用于从person_tab p中选择值（p），其中value（p）是（parttimestudent_t）; exec sql allocate：parttimestudentArrayArray：parttimestudentArrayArray_ind; exec sql open c4;每次都没有找到exec sql goto：done_parttimestudent; while（sqlca.sqlcode == 0）{exec sql fetch c4 into：parttimestudentArrayArray：parttimestudentArrayArray_ind; for（i = 0; i &lt;ARRAY_SIZE; i ++）printPartTimeStudent（parttimestudentArrayArray [i]）; } done_parttimestudent：for（i = 0; i &lt;sqlca.sqlerrd [2]％ARRAY_SIZE; i ++）printPartTimeStudent（parttimestudentArrayArray [i]）; printf（“获取的parttimestudent_t对象的总数：％d。\ n”，sqlca.sqlerrd [2]）; exec sql close c4; exec sql free：parttimestudentArrayArray：parttimestudentArrayArray_ind; / ************************************************ ***************************** *以下函数显示如何选择person_t子类型student_t *和employee_t对象****** ************************************************** ******************** / do_fetch_student_employee（）{person_t * personArray [ARRAY_SIZE]; person_t_ind * personArray_ind [ARRAY_SIZE]; printf（“\ n仅获取student_t和employee_t对象：\ n”）; exec sql声明c5游标，用于从person_tab p中选择值（p），其中value（p）是（only student_t，employee_t）; exec sql allocate：personArray：personArray_ind; exec sql open c5;每次都没有找到exec sql goto：done_student_employee; while（sqlca.sqlcode == 0）{exec sql fetch c5 into：personArray：personArray_ind; for（i = 0; i &lt;ARRAY_SIZE; i ++）printPerson（personArray [i]）; } done_student_employee：for（i = 0; i &lt;sqlca.sqlerrd [2]％ARRAY_SIZE; i ++）printPerson（personArray [i]）; printf（“获取的stuent_t和employee_t对象的总数：％d。\ n”，sqlca.sqlerrd [2]）; exec sql close c5; exec sql free：personArray：personArray_ind; / ************************************************ ***************************** *以下函数显示如何使用动态sql选择person_t子类型student_t *对象。************************************************** ************************** / do_dynamic_fetch（）{student_t * student; student_t_ind * student_ind; exec sql allocate：student：student_ind; dynstmt.len =（unsigned short）strlen（（char *）dynstmt.arr）; EXEC SQL PREPARE S FROM：dynstmt;用于S的EXEC SQL DECLARE C CURSOR; EXEC SQL OPEN C; exec sql什么都没找到做破坏; for（;;）{EXEC SQL FETCH C INTO：student：student_ind; printStudent（学生）; } printf（“\ nQuery返回％d row％s。\ n”，sqlca.sqlerrd [2]，（sqlca.sqlerrd [2] == 1）？“”：“s”）; EXEC SQL CLOSE C; exec sql免费：student：student_ind; }</pre></div>
                  <!-- class="section" -->
               </div>
            </div><a id="LNPCC4361"></a><div class="props_rev_3"><a id="GUID-D043EC3F-5DE7-4D09-B858-E9617327D6CD" name="GUID-D043EC3F-5DE7-4D09-B858-E9617327D6CD"></a><h3 id="LNPCC-GUID-D043EC3F-5DE7-4D09-B858-E9617327D6CD" class="sect3"><span class="enumeration_section">17.11</span>导航访问的示例代码</h3>
               <div>
                  <div class="section">
                     <p>示例对象代码创建三种对象类型; <span class="italic">budoka</span>是一位武术专家：</p>
                     <ul style="list-style-type:disc">
                        <li>
                           <p>顾客</p>
                        </li>
                        <li>
                           <p>Budoka</p>
                        </li>
                        <li>
                           <p>地点</p>
                        </li>
                     </ul>
                     <p>和两个表：</p>
                     <ul style="list-style-type:disc">
                        <li>
                           <p><code class="codeph">person_tab</code></p>
                        </li>
                        <li>
                           <p><code class="codeph">customer_tab</code></p>
                        </li>
                     </ul>
                     <p>创建类型和表，然后在表中插入值的SQL文件<code class="codeph">navdemo1.sql</code>是：</p><pre class="oac_no_warn" dir="ltr">connect scott / tiger drop table customer_tab;跌落式客户; drop table person_tab; drop type budoka;掉落位置;创建类型位置作为对象（num number，street varchar2（60），city varchar2（30），state char（2），zip char（10））; / create type budoka as object（lastname varchar2（20），firstname varchar（20），birthdate date，age int，addr location）; / create table person_tab of budoka;创建类型客户作为对象（account_number varchar（20），aperson ref budoka）; / create table customer_tab of customer;插入person_tab值（budoka（'Seagal'，'Steven'，'14-FEB-1963'，34，location（1825，'Aikido Way'，'Los Angeles'，'CA'，45300）））;插入person_tab值（budoka（'Norris'，'Chuck'，'25 -DEC-1952'，45，location（291，'Grant Avenue'，'Hollywood'，'CA'，21003）））;插入person_tab值（budoka（'Wallace'，'Bill'，'29-FEB-1944'，53，location（874，'Richmond Street'，'New York'，'NY'，45100）））;插入person_tab值（budoka（'Van Damme'，'Jean Claude'，'12 -DEC-1964'，32，location（12，'Shugyo Blvd'，'Los Angeles'，'CA'，95100）））;插入customer_tab，从person_tab p中选择'AB123'，ref（p），其中p.lastname ='Seagal';插入customer_tab，从person_tab p中选择'DD492'，ref（p），其中p.lastname ='Norris';插入customer_tab，从person_tab p中选择'SM493'，ref（p），其中p.lastname ='Wallace';插入customer_tab，从person_tab p中选择'AC493'，ref（p），其中p.lastname ='Van Damme';承诺工作;</pre><p>以下是我们的示例<code class="codeph">navdemo1.typ</code>的intype文件<code class="codeph">navdemo1.typ</code> ：</p><pre class="oac_no_warn" dir="ltr">case =较低类型的位置类型budoka类型的客户</pre><p>OTT生成的头文件<code class="codeph">navdemo1.h</code>包含在带有<code class="codeph">#include</code>预处理器指令的预编译器代码中。
                     </p>
                     <p>阅读整个预编译器代码中的注释。该程序添加了一个新的budoka对象（成龙），然后打印出<span class="italic">customer_tab</span>表中的所有<span class="italic">客户</span> 。
                     </p>
                     <p>以下是预编译器文件<code class="codeph">navdemo1.pc</code> ：</p><pre class="oac_no_warn" dir="ltr">/ ******************* ************************ * *这是一个简单的Pro * C / C ++程序，旨在说明对象缓存中对象的*导航访问。* *构建可执行文件：* * 1。在SQL * Plus * 2中执行SQL脚本navdemo1.sql。运行OTT :(以下命令应出现在一行上）* ott intype = navdemo1.typ hfile = navdemo1.h outtype = navdemo1_o.typ * code = c user = scott / tiger * 3。使用Pro * C / C ++进行预编译：* proc navdemo1 intype = navdemo1_o.typ * 4。编译/链接（此步骤是特定于平台的）* *************************************** ********************************** / #include“navdemo1.h”#include &lt;stdio.h&gt;＃ include &lt;stdlib.h&gt; #include &lt;string.h&gt; #include &lt;sqlca.h&gt; void whoops（errcode，errtext，errtextlen）int errcode; char * errtext; int errtextlen; {printf（“错误！sqlcode =％d：text =％。* s“，errcode，errtextlen，errtext）; EXEC SQL WHENEVER SQLERROR CONTINUE; EXEC SQL ROLLBACK WORK RELEASE; exit（EXIT_FAILURE）;} void main（）{char * uid =”scott / tiger“; / *以下类型由OTT生成并在navdemo1.h * / customer * cust_p中定义; / *指向客户对象的指针* / customer_ind * cust_ind; / *指向客户* / customer_ref * cust_ref的指标结构的指针; / *指向客户对象引用的指针* / budoka * budo_p; / *指向budoka对象的指针* / budoka_ref * budo_ref; / *指向budoka对象引用的指针* / budoka_ind * budo_ind; / *指向budoka指标结构的指针* / / *这些是用于插入/检索对象数据的数据声明* / VARCHAR acct [21]; struct {char lname [21]，fname [21]; int age;} pers; struct {int num; char street [61] ，city [31]，state [3]，zip [11];} addr; EXEC SQL WHENEVER SQLERROR DO whoops（sqlca.sqlcode，sqlca.sqlerrm.sqlerrmc，sqlca.sqlerrm.sqlerrml）; EXEC SQL CONNECT：uid; EXEC SQL ALLOCATE：budo_ref; / *使用关联的指标*变量创建一个新的budoka对象，同时将REF返回到该budoka。* / EXEC SQL OBJECT CREATE：budo_p：budo_ind TABLE PERSON_TAB RETURNING REF INTO：budo_ref; / *使用关联的指示符创建一个新的客户对象* / EXEC SQL OBJECT CREATE：cust_p：cust_ind TABLE CUSTOMER_TAB; / *将所有budoka指标设置为NOT NULL。我们*将设置budoka的所有属性。* / budo_ind  - &gt; _ atomic = budo_ind-&gt; lastname = budo_ind-&gt; firstname = budo_ind-&gt; age = OCI_IND_NOTNULL; / *我们还将设置budoka的所有地址属性* / budo_ind-&gt; addr._atomic = budo_ind-&gt; addr.num = budo_ind-&gt; addr.street = budo_ind-&gt; addr.city = budo_ind-&gt; addr.state = budo_ind - &gt; addr.zip = OCI_IND_NOTNULL; / *同样设置所有客户属性* / cust_ind  - &gt; _ atomic = cust_ind-&gt; account_number = cust_ind-&gt; aperson = OCI_IND_NOTNULL; / *将默认的CHAR语义设置为类型5（STRING）* / EXEC ORACLE OPTION（char_map = string）; strcpy（（char *）pers.lname，（char *）“Chan”）; strcpy（（char *）pers.fname，（char *）“Jackie”）; pers.age = 38; / *将本机C类型转换为OTS类型* / EXEC SQL OBJECT SET lastname，firstname，age OF：budo_p TO：pers; addr.num = 1893; strcpy（（char *）addr.street，（char *）“Rumble Street”）; strcpy（（char *）addr.city，（char *）“Bronx”）; strcpy（（char *）addr.state，（char *）“NY”）; strcpy（（char *）addr.zip，（char *）“92510”）; / *将本机C类型转换为OTS类型* / EXEC SQL OBJECT SET：budo_p-&gt; addr TO：addr; acct.len = strlen（strcpy（（char *）acct.arr，（char *）“FS926”））; / *将本机C类型转换为OTS类型 - 还要注意REF类型* / EXEC SQL OBJECT SET account_number，aperson OF：cust_p TO：acct，：budo_ref; / *标记为更新了新客户和budoka * / EXEC SQL OBJECT UPDATE：cust_p; EXEC SQL OBJECT UPDATE：budo_p; / *现在将更改刷新到服务器，有效*将数据插入相应的表中。* / EXEC SQL OBJECT FLUSH：budo_p; EXEC SQL OBJECT FLUSH：cust_p; / *来自CUSTOMER_TAB * / EXEC SQL DECLARE的REF的关联访问权限ref_cur CURSOR FOR SELECT REF（c）FROM customer_tab c; EXEC SQL OPEN ref_cur;的printf（ “\ n”）; / *将REF分配给客户，以便在以下* / EXEC SQL ALLOCATE中使用：cust_ref; EXEC SQL WHENEVER NOT FOUND DO break; while（1）{EXEC SQL FETCH ref_cur INTO：cust_ref; / *固定客户REF，返回指向客户对象的指针* / EXEC SQL OBJECT DEREF：cust_ref INTO：cust_p：cust_ind; / *将OTS类型转换为本机C类型* / EXEC SQL OBJECT GET account_number FROM：cust_p INTO：acct; printf（“客户帐户是％。* s \ n”，acct.len，（char *）acct.arr）; / *固定budoka REF，返回指向budoka对象的指针* / EXEC SQL OBJECT DEREF：cust_p-&gt; aperson INTO：budo_p：budo_ind; / *将OTS类型转换为本机C类型* / EXEC SQL OBJECT GET lastname，firstname，age FROM：budo_p INTO：pers; printf（“姓氏：％s \ n第一名：％s \ nAge：％d \ n”，pers.lname，pers.fname，pers.age）; / *对地址属性也一样* / EXEC SQL OBJECT GET：budo_p-&gt; addr INTO：addr;的printf（ “地址：\ n”）; printf（“街道：％d％s \ n城市：％s \ n状态：％s \ n Zip：％s \ n \ n”，addr.num，addr.street，addr.city，addr.state，addr 。压缩）; / *取消固定客户对象和budoka对象* / EXEC SQL OBJECT RELEASE：cust_p; EXEC SQL OBJECT RELEASE：budo_p; } EXEC SQL CLOSE ref_cur;执行SQL WHENEVER NOT FOUND DO whoops（sqlca.sqlcode，sqlca.sqlerrm.sqlerrmc，sqlca.sqlerrm.sqlerrml）; / *关联地选择新创建的客户对象* / EXEC SQL SELECT VALUE（c）INTO：cust_p FROM customer_tab c WHERE c.account_number ='FS926'; / *标记为删除了新的客户对象* / EXEC SQL OBJECT DELETE：cust_p; / *刷新更改，有效删除客户对象* / EXEC SQL OBJECT FLUSH：cust_p; / *以相关方式为新创建的budoka对象选择REF * / EXEC SQL SELECT REF（p）INTO：budo_ref FROM person_tab p WHERE p.lastname ='Chan'; / *固定budoka REF，返回指向budoka对象的指针* / EXEC SQL OBJECT DEREF：budo_ref INTO：budo_p; / *在对象缓存中将新的budoka对象标记为已删除* / EXEC SQL OBJECT DELETE：budo_p; / *刷新更改，有效删除budoka对象* / EXEC SQL OBJECT FLUSH：budo_p; / *最后，释放所有对象缓存并注销* / EXEC SQL OBJECT CACHE FREE ALL; EXEC SQL COMMIT WORK RELEASE;出口（EXIT_SUCCESS）; }</pre><p>执行程序时，结果是：</p><pre class="oac_no_warn" dir="ltr">客户账户是AB123姓氏：Seagal名字：Steven出生日期：02-14-1963年龄：34地址：街道：1825 Aikido Way城市：洛杉矶州：CA邮编：45300客户账号是DD492姓：Norris名：查克出生日期：12-25-1952年龄：45地址：街道：291 Grant Avenue城市：好莱坞州：CA邮编：21003客户帐号是SM493姓：Wallace名字：比尔出生日期：02-29-1944年龄：53地址：街道：874 Richmond Street城市：纽约州：NY邮编：45100客户帐户是AC493姓氏：Van Damme名字：Jean Claude出生日期：12-12-1965年龄：32地址：街道：12 Shugyo Blvd城市：Los安吉利斯州：CA邮编：95100客户账户是FS926姓氏：Chan名字：Jackie出生日期：10-10-1959年龄：38地址：街道：1893 Rumble Street城市：布朗克斯州：NY邮编：92510</pre><div class="infoboxnotealso" id="GUID-D043EC3F-5DE7-4D09-B858-E9617327D6CD__GUID-6AF8007F-0CB2-4730-9737-A84AB4169536">
                        <p class="notep1">也可以看看：</p>
                        <p><span class="q">“ <a href="the-Object-type.html#GUID-030B4AA0-E54B-438C-B0A1-C3BE7ADF1530">OTT命令行</a> ”，</span>用于描述intype文件的格式</p>
                     </div>
                  </div>
                  <!-- class="section" -->
               </div>
            </div><a id="LNPCC4362"></a><div class="props_rev_3"><a id="GUID-991F2F64-910B-46AD-AF38-BCAB90EACA88" name="GUID-991F2F64-910B-46AD-AF38-BCAB90EACA88"></a><h3 id="LNPCC-GUID-991F2F64-910B-46AD-AF38-BCAB90EACA88" class="sect3"><span class="enumeration_section">17.12</span>关于使用C结构</h3>
               <div>
                  <p>在Oracle8之前，Pro * C / C ++允许您在SQL SELECT语句中将C结构指定为单个主机变量。在这种情况下，结构的每个成员都对应于关系表中的单个数据库列;也就是说，每个成员代表查询返回的选择列表中的单个项目。</p>
                  <p>在Oracle8 <span class="italic">i</span>及更高版本中，数据库中的对象类型是单个实体，可以选择为单个项目。这引入了Oracle7表示法的模糊性：是一组标量变量或一个对象的结构？
                  </p>
                  <p>Pro * C / C ++使用以下规则来解决歧义：</p>
                  <p>仅当C语言的C语句是使用OTT生成的C语句时，它才被视为表示对象类型，因此其类型描述出现在Pro * C / C ++的INTYPE选项中指定的类型文件中。假设所有其他主机结构都使用Oracle7语法，即使数据库中存在同名的数据类型也是如此。</p>
                  <p>因此，如果使用与现有结构主机变量类型具有相同名称的新对象类型，请注意Pro * C / C ++使用INTYPE文件中的对象类型定义。这可能导致编译错误。要更正此问题，您可以重命名现有的主机变量类型，或使用OTT为对象类型选择新名称。</p>
                  <p>前面的规则可<span class="italic">传递</span>地扩展到用户定义的数据类型，这些数据类型别名为OTT生成的数据类型。为了说明，让<span class="italic">emptype</span>成为OTT在头文件<code class="codeph">dbtypes.h</code>生成的结构，并且在Pro * C / C ++程序中有以下语句：</p><pre class="oac_no_warn" dir="ltr">#include &lt;dbtypes.h&gt; typedef emptype myemp; myemp *员工;</pre><p>对于在数据库中定义的某种对象类型，变量<span class="italic">employee</span>的typename <span class="italic">myemp</span>别名为OTT生成的typename <span class="italic">emptype</span> 。因此，Pro * C / C ++认为变量<span class="italic">employee</span>表示对象类型。
                  </p>
                  <p>前面的规则并不意味着具有或混淆了OTT生成类型的C结构不能用于非对象类型数据的提取。唯一的含义是Pro * C / C ++不会自动扩展这样的结构 - 用户可以自由地使用“longhand语法”并使用结构的各个字段来选择或更新单个数据库列。</p>
               </div>
            </div><a id="LNPCC4363"></a><div class="props_rev_3"><a id="GUID-FFF48576-9D39-48D2-A199-D5E5E6B447E5" name="GUID-FFF48576-9D39-48D2-A199-D5E5E6B447E5"></a><h3 id="LNPCC-GUID-FFF48576-9D39-48D2-A199-D5E5E6B447E5" class="sect3"><span class="enumeration_section">17.13</span>关于使用REF</h3>
               <div>
                  <p>REF类型表示对对象的引用，而不是对象本身。REF类型可能出现在关系列中，也可能出现在对象类型的属性中。</p>
               </div><a id="LNPCC4364"></a><div class="sect3"><a id="GUID-0C3D9579-3BA1-49C6-8863-C37CB90B6D01" name="GUID-0C3D9579-3BA1-49C6-8863-C37CB90B6D01"></a><h4 id="LNPCC-GUID-0C3D9579-3BA1-49C6-8863-C37CB90B6D01" class="sect4"><span class="enumeration_section">17.13.1</span>为REF生成C结构</h4>
                  <div>
                     <p>在类型转换期间由OTT生成对象类型的REF的C表示。例如，对数据库中用户定义的PERSON类型的引用可以用C表示为类型“Person_ref”。确切的类型名称由类型转换期间生效的OTT选项确定。必须在Pro * C / C ++的INTYPE选项和Pro * C / C ++程序中的OTT生成的头文件#include中指定OTT生成的类型文件。此方案确保在预编译期间可以通过Pro * C / C ++执行对REF的正确类型检查。</p>
                     <p>REF类型不需要OTT生成特殊指标结构;使用标量签名的2字节指示符代替。</p>
                  </div>
               </div><a id="LNPCC4365"></a><div class="sect3"><a id="GUID-9B54C69F-9879-4453-AFA4-BCF7AEAA66E0" name="GUID-9B54C69F-9879-4453-AFA4-BCF7AEAA66E0"></a><h4 id="LNPCC-GUID-9B54C69F-9879-4453-AFA4-BCF7AEAA66E0" class="sect4"><span class="enumeration_section">17.13.2</span>声明REF</h4>
                  <div>
                     <p>必须将表示Pro * C / C ++中的REF的主变量声明为指向相应OTT生成类型的指针。</p>
                     <p>与对象类型不同，REF的指示符变量被声明为带符号的2字节标量类型<code class="codeph">OCIInd</code> 。与往常一样，指标变量是可选的，但对于声明的每个主变量使用一个是一个很好的编程习惯。
                     </p>
                  </div>
               </div><a id="LNPCC4366"></a><div class="sect3"><a id="GUID-EB0A6C41-6D1D-4E32-9855-B6C0544323F9" name="GUID-EB0A6C41-6D1D-4E32-9855-B6C0544323F9"></a><h4 id="LNPCC-GUID-EB0A6C41-6D1D-4E32-9855-B6C0544323F9" class="sect4"><span class="enumeration_section">17.13.3</span>在嵌入式SQL中使用REF</h4>
                  <div>
                     <p>REF驻留在对象缓存中。但是，REF的指标是标量，无法在缓存中分配。它们通常驻留在用户堆栈中。</p>
                     <p>在嵌入式SQL中使用REF的主机结构之前，请使用EXEC SQL ALLOCATE命令在对象缓存中为其分配空间。使用后，免费使用EXEC SQL FREE或EXEC SQL CACHE FREE ALL命令。</p>
                     <p>标量指示符变量的内存未在对象缓存中分配，因此不允许在REF类型的ALLOCATE和FREE命令中显示指示符。声明为<code class="codeph">OCIInd</code>标量指标驻留在程序堆栈中。在运行时，ALLOCATE语句会在对象高速缓存中为指定的主机变量分配空间。对于导航界面，请使用EXEC SQL GET和EXEC SQL SET，而不是C赋值。
                     </p>
                     <p>Pro * C / C ++支持关联SQL语句和嵌入式PL / SQL块中的REF主变量。</p>
                  </div>
                  <div>
                     <div class="relinfo">
                        <p><strong>相关话题</strong></p>
                        <ul>
                           <li><a href="about-Objects.html#GUID-1DB5F60D-55C9-4565-93D9-B155A86BB0C7">导航界面</a></li>
                        </ul>
                     </div>
                  </div>
                  
               </div>
            </div><a id="LNPCC4367"></a><div class="props_rev_3"><a id="GUID-35C1DD18-7C3F-437E-A9DF-B9B2CE76DF2A" name="GUID-35C1DD18-7C3F-437E-A9DF-B9B2CE76DF2A"></a><h3 id="LNPCC-GUID-35C1DD18-7C3F-437E-A9DF-B9B2CE76DF2A" class="sect3"><span class="enumeration_section">17.14</span>关于使用OCIDate，OCIString，OCINumber和OCIRaw</h3>
               <div>
                  <p>这些OCI类型分别是日期的新C表示，变长的零终止字符串，Oracle编号和变长二进制数据。在某些情况下，这些类型提供的功能比这些数量的早期C表示更多。例如，OCIDate类型提供客户端例程来执行DATE算法，在早期版本中需要在服务器上使用SQL语句。</p>
               </div><a id="LNPCC4368"></a><div class="props_rev_3"><a id="GUID-88345D8C-14D5-44E7-B16E-A95C235A84EC" name="GUID-88345D8C-14D5-44E7-B16E-A95C235A84EC"></a><h4 id="LNPCC-GUID-88345D8C-14D5-44E7-B16E-A95C235A84EC" class="sect4"><span class="enumeration_section">17.14.1</span>声明OCIDate，OCIString，OCINumber，OCIRaw</h4>
                  <div>
                     <p>OCI *类型在OTT生成的结构中显示为对象类型属性，并且您将它们用作Pro * C / C ++程序中对象类型的一部分。除了在对象类型中使用它们之外，Oracle建议初学者级别的C和Pro * C / C ++用户避免声明这些类型的单个主机变量。有经验的Pro * C / C ++用户可能希望声明这些类型的C主机变量，以利用这些类型提供的高级功能。必须将主变量声明为指向这些类型的指针，例如， <code class="codeph">OCIString *s</code> 。相关（可选）指标是标量符号的2字节数量，例如， <code class="codeph">OCIInd s_ind</code> 。
                     </p>
                  </div>
               </div><a id="LNPCC4369"></a><div class="props_rev_3"><a id="GUID-33C9478A-E174-437A-8B78-2536DC9E63BE" name="GUID-33C9478A-E174-437A-8B78-2536DC9E63BE"></a><h4 id="LNPCC-GUID-33C9478A-E174-437A-8B78-2536DC9E63BE" class="sect4"><span class="enumeration_section">17.14.2</span>在嵌入式SQL中使用OCI类型</h4>
                  <div>
                     <p>可以使用EXEC SQL ALLOCATE在对象缓存中分配这些类型的主机变量的空间。标量指示符变量不允许出现在这些类型的ALLOCATE和FREE命令中。您可以在堆栈上静态分配这些指标，也可以在堆上动态分配。可以使用语句EXEC SQL FREE，EXEC SQL CACHE FREE ALL或在会话结束时自动解除空间分配。</p>
                  </div>
                  <div>
                     <div class="relinfo">
                        <p><strong>相关话题</strong></p>
                        <ul>
                           <li><a href="about-Objects.html#GUID-1DB5F60D-55C9-4565-93D9-B155A86BB0C7">导航界面</a></li>
                        </ul>
                     </div>
                  </div>
                  
               </div><a id="LNPCC4370"></a><div class="props_rev_3"><a id="GUID-F00719A9-17D4-409C-A072-360B7459B9EA" name="GUID-F00719A9-17D4-409C-A072-360B7459B9EA"></a><h4 id="LNPCC-GUID-F00719A9-17D4-409C-A072-360B7459B9EA" class="sect4"><span class="enumeration_section">17.14.3</span>操作OCI类型</h4>
                  <div>
                     <p>除了<code class="codeph">OCIDate</code> ，它是具有各种日期组件的单独字段的结构类型：年，月，日，小时等，其他OCI类型被封装，并且对外部用户来说是不透明的。与目前在Pro * C / C ++中处理现有C类型（如VARCHAR）的方式相比，您包含OCI头文件<code class="codeph">oci.h</code>并使用其函数执行DATE算法，并将这些类型转换为本机C类型和从本机C类型转换如<span class="italic">int</span> ， <span class="italic">char</span>等。
                     </p>
                  </div>
               </div>
            </div><a id="LNPCC4372"></a><a id="LNPCC4373"></a><a id="LNPCC4371"></a><div class="props_rev_3"><a id="GUID-D46CF7DA-22AD-4EC7-ABAE-6376E344CE75" name="GUID-D46CF7DA-22AD-4EC7-ABAE-6376E344CE75"></a><h3 id="LNPCC-GUID-D46CF7DA-22AD-4EC7-ABAE-6376E344CE75" class="sect3"><span class="enumeration_section">17.15</span>总结Pro * C / C ++中的新数据库类型</h3>
               <div>
                  <div class="section">
                     <p><a href="about-Objects.html#GUID-D46CF7DA-22AD-4EC7-ABAE-6376E344CE75__BAJDEAAI" title="在Pro * C / C ++中使用新的数据库类型">表17-2</a>列出了对象支持的新数据库类型：</p>
                  </div>
                  <!-- class="section" -->
                  <div class="tblformal" id="GUID-D46CF7DA-22AD-4EC7-ABAE-6376E344CE75__BAJDEAAI">
                     <p class="titleintable">表17-2在Pro * C / C ++中使用新数据库类型</p>
                     <table cellpadding="4" cellspacing="0" class="Formal" title="在Pro * C / C ++中使用新的数据库类型" width="100%" border="1" summary="Using New Database Types in Pro*C/C++" frame="hsides" rules="rows">
                        <thead>
                           <tr align="left" valign="top">
                              <th align="left" valign="bottom" width="18%" id="d93390e3179">操作数据库类型</th>
                              <th align="left" valign="bottom" width="15%" id="d93390e3183">宣布</th>
                              <th align="left" valign="bottom" width="21%" id="d93390e3187">分配</th>
                              <th align="left" valign="bottom" width="24%" id="d93390e3191">自由</th>
                              <th align="left" valign="bottom" width="23%" id="d93390e3195">操纵</th>
                           </tr>
                        </thead>
                        <tbody>
                           <tr align="left" valign="top">
                              <td align="left" valign="top" width="18%" id="d93390e3201" headers="d93390e3179 ">
                                 <p>对象类型</p>
                              </td>
                              <td align="left" valign="top" width="15%" headers="d93390e3201 d93390e3183 ">
                                 <p><span class="bold">主机</span> ：指向OTT生成的C结构的指针</p>
                                 <p><span class="bold">指标</span> ：指向OTT生成的指标结构的指针</p>
                              </td>
                              <td align="left" valign="top" width="21%" headers="d93390e3201 d93390e3187 ">
                                 <p>关联接口：</p>
                                 <p>EXEC SQL ALLOCATE</p>
                                 <p>导航界面：</p>
                                 <p>EXEC SQL OBJECT CREATE ...</p>
                                 <p>EXEC SQL OBJECT DEREF</p>
                                 <p>为对象缓存中的主机var和指示器分配内存</p>
                              </td>
                              <td align="left" valign="top" width="24%" headers="d93390e3201 d93390e3191 ">
                                 <p>通过EXEC SQL FREE或EXEC SQL CACHE FREE ALL释放，或在会话结束时自动释放。</p>
                              </td>
                              <td align="left" valign="top" width="23%" headers="d93390e3201 d93390e3195 ">
                                 <p>取消引用C指针以获取每个属性。操纵方法取决于属性的类型（见后面）。</p>
                              </td>
                           </tr>
                           <tr align="left" valign="top">
                              <td align="left" valign="top" width="18%" id="d93390e3233" headers="d93390e3179 ">
                                 <p>COLLECTION对象类型</p>
                                 <p>（嵌套表和不同的阵列）</p>
                              </td>
                              <td align="left" valign="top" width="15%" headers="d93390e3233 d93390e3183 ">
                                 <p><span class="bold">主机</span> ：指向OTT生成的C结构的指针</p>
                                 <p><span class="bold">指标</span> ：OCIInd</p>
                                 <p></p>
                              </td>
                              <td align="left" valign="top" width="21%" headers="d93390e3233 d93390e3187 ">
                                 <p>EXEC SQL ALLOCATE</p>
                                 <p>为对象缓存中的主机var分配内存。</p>
                              </td>
                              <td align="left" valign="top" width="24%" headers="d93390e3233 d93390e3191 ">
                                 <p>通过EXEC SQL FREE或EXEC SQL CACHE FREE ALL释放，或在会话结束时自动释放。</p>
                              </td>
                              <td align="left" valign="top" width="23%" headers="d93390e3233 d93390e3195 ">
                                 <p>使用OCIColl *函数（在oci.h中定义）来获取/设置元素。另见<a href="about-Collections.html#GUID-BCAD71D2-D01D-40C8-8BAD-08902363ECDA">集合</a> 。
                                 </p>
                              </td>
                           </tr>
                           <tr align="left" valign="top">
                              <td align="left" valign="top" width="18%" id="d93390e3264" headers="d93390e3179 ">
                                 <p>REF</p>
                              </td>
                              <td align="left" valign="top" width="15%" headers="d93390e3264 d93390e3183 ">
                                 <p><span class="bold">主机：</span>指向OTT生成的C结构的指针</p>
                                 <p><span class="bold">指标：</span> OCIInd</p>
                                 <p></p>
                                 <p></p>
                              </td>
                              <td align="left" valign="top" width="21%" headers="d93390e3264 d93390e3187 ">
                                 <p>EXEC SQL ALLOCATE</p>
                                 <p>为对象缓存中的主机var分配内存。</p>
                              </td>
                              <td align="left" valign="top" width="24%" headers="d93390e3264 d93390e3191 ">
                                 <p>通过EXEC SQL FREE或EXEC SQL CACHE FREE ALL释放，或在会话结束时自动释放。</p>
                              </td>
                              <td align="left" valign="top" width="23%" headers="d93390e3264 d93390e3195 ">
                                 <p>使用EXEC SQL OBJECT DEREF</p>
                                 <p>使用EXEC SQL OBJECT SET / GET进行导航界面。</p>
                              </td>
                           </tr>
                           <tr align="left" valign="top">
                              <td align="left" valign="top" width="18%" id="d93390e3292" headers="d93390e3179 ">
                                 <p>高球</p>
                              </td>
                              <td align="left" valign="top" width="15%" headers="d93390e3292 d93390e3183 ">
                                 <p><span class="bold">主办：</span> 
                                 </p>
                                 <p>OCIBlobLocator *，OCIClobLocator *或OCIBfileLocator *。</p>
                                 <p><span class="bold">指标：</span> OCIInd</p>
                                 <p></p>
                              </td>
                              <td align="left" valign="top" width="21%" headers="d93390e3292 d93390e3187 ">
                                 <p>EXEC SQL ALLOCATE</p>
                                 <p>使用for为用户堆中的主机var分配内存</p>
                                 <p>malloc（）函数。</p>
                              </td>
                              <td align="left" valign="top" width="24%" headers="d93390e3292 d93390e3191 ">
                                 <p>由EXEC SQL FREE释放，或在所有Pro * C / C ++连接关闭时自动释放。EXEC SQL CACHE FREE ALL仅释放对象的LOB属性。</p>
                              </td>
                              <td align="left" valign="top" width="23%" headers="d93390e3292 d93390e3195 ">
                                 <p>或者在dbms_lob包中使用嵌入式PL / SQL存储过程，或者</p>
                                 <p>使用oci.h中定义的OCILob *函数。</p>
                                 <p>另见<span class="q">“ <a href="about-LOBs.html#GUID-DEBB0C35-161B-4725-BE0D-A209B64B98A2">LOB</a> ”</span> 。
                                 </p>
                              </td>
                           </tr>
                           <tr align="left" valign="top">
                              <td align="left" valign="top" width="18%" id="d93390e3330" headers="d93390e3179 ">
                                 <p><span class="bold">注意：</span> 
                                 </p>
                                 <p>可以在Pro * C / C ++中批量获取/插入SQL操作中声明和使用这些类型的主机数组。</p>
                              </td>
                              <td align="left" valign="top" width="15%" headers="d93390e3330 d93390e3183 ">
                                 <p>-</p>
                              </td>
                              <td align="left" valign="top" width="21%" headers="d93390e3330 d93390e3187 ">
                                 <p>-</p>
                              </td>
                              <td align="left" valign="top" width="24%" headers="d93390e3330 d93390e3191 ">
                                 <p>-</p>
                              </td>
                              <td align="left" valign="top" width="23%" headers="d93390e3330 d93390e3195 ">
                                 <p>-</p>
                              </td>
                           </tr>
                        </tbody>
                     </table>
                  </div>
                  <!-- class="inftblhruleinformal" -->
                  <div class="section">
                     <p> <a href="about-Objects.html#GUID-D46CF7DA-22AD-4EC7-ABAE-6376E344CE75__BAJDBAEC" title="在Pro * C / C ++中使用新的C数据类型">表17-3</a>显示了如何在Pro * C / C ++中使用新的C数据类型：</p>
                  </div>
                  <!-- class="section" -->
                  <div class="tblformal" id="GUID-D46CF7DA-22AD-4EC7-ABAE-6376E344CE75__BAJDBAEC">
                     <p class="titleintable">表17-3在Pro * C / C ++中使用新的C数据类型</p>
                     <table cellpadding="4" cellspacing="0" class="Formal" title="在Pro * C / C ++中使用新的C数据类型" width="100%" border="1" summary="Using New C Datatypes in Pro*C/C++" frame="hsides" rules="rows">
                        <thead>
                           <tr align="left" valign="top">
                              <th align="left" valign="bottom" width="20%" id="d93390e3370">OperationsC类型</th>
                              <th align="left" valign="bottom" width="20%" id="d93390e3375">宣布</th>
                              <th align="left" valign="bottom" width="20%" id="d93390e3378">分配</th>
                              <th align="left" valign="bottom" width="20%" id="d93390e3381">自由</th>
                              <th align="left" valign="bottom" width="20%" id="d93390e3384">操纵</th>
                           </tr>
                        </thead>
                        <tbody>
                           <tr align="left" valign="top">
                              <td align="left" valign="top" width="20%" id="d93390e3389" headers="d93390e3370 ">
                                 <p>OCIDate</p>
                              </td>
                              <td align="left" valign="top" width="20%" headers="d93390e3389 d93390e3375 ">
                                 <p><span class="bold">主持人：</span> OCIDate *</p>
                                 <p><span class="bold">指标：</span> OCIInd</p>
                                 <p></p>
                              </td>
                              <td align="left" valign="top" width="20%" headers="d93390e3389 d93390e3378 ">
                                 <p>EXEC SQL ALLOCATE</p>
                                 <p>为对象缓存中的主机var分配内存</p>
                              </td>
                              <td align="left" valign="top" width="20%" headers="d93390e3389 d93390e3381 ">
                                 <p>通过EXEC SQL FREE或EXEC SQL CACHE FREE ALL释放，或在会话结束时自动释放。</p>
                              </td>
                              <td align="left" valign="top" width="20%" headers="d93390e3389 d93390e3384 ">
                                 <p>（1）使用oci.h中定义的OCIDate *函数。</p>
                                 <p>（2）使用EXEC SQL OBJECT GET / SET，或</p>
                                 <p>（3）使用oci.h中定义的OCINumber *函数。</p>
                              </td>
                           </tr>
                           <tr align="left" valign="top">
                              <td align="left" valign="top" width="20%" id="d93390e3418" headers="d93390e3370 ">
                                 <p>OCINumber</p>
                              </td>
                              <td align="left" valign="top" width="20%" headers="d93390e3418 d93390e3375 ">
                                 <p><span class="bold">主持人：</span> OCINumber *</p>
                                 <p><span class="bold">指标：</span> OCIInd</p>
                              </td>
                              <td align="left" valign="top" width="20%" headers="d93390e3418 d93390e3378 ">
                                 <p>EXEC SQL ALLOCATE</p>
                                 <p>为对象缓存中的主机var分配内存</p>
                              </td>
                              <td align="left" valign="top" width="20%" headers="d93390e3418 d93390e3381 ">
                                 <p>通过EXEC SQL FREE或EXEC SQL CACHE FREE ALL释放，或在会话结束时自动释放。</p>
                              </td>
                              <td align="left" valign="top" width="20%" headers="d93390e3418 d93390e3384 ">
                                 <p>（1）使用EXEC SQL OBJECT GET / SET，或</p>
                                 <p>（2）使用oci.h中定义的OCINumber *函数。</p>
                              </td>
                           </tr>
                           <tr align="left" valign="top">
                              <td align="left" valign="top" width="20%" id="d93390e3444" headers="d93390e3370 ">
                                 <p>OCIRaw</p>
                              </td>
                              <td align="left" valign="top" width="20%" headers="d93390e3444 d93390e3375 ">
                                 <p><span class="bold">主持人：</span> OCIRaw *</p>
                                 <p><span class="bold">指标：</span> OCIInd</p>
                              </td>
                              <td align="left" valign="top" width="20%" headers="d93390e3444 d93390e3378 ">
                                 <p>EXEC SQL ALLOCATE</p>
                                 <p>为对象缓存中的主机var分配内存</p>
                              </td>
                              <td align="left" valign="top" width="20%" headers="d93390e3444 d93390e3381 ">
                                 <p>通过EXEC SQL FREE或EXEC SQL CACHE FREE ALL释放，或在会话结束时自动释放。</p>
                              </td>
                              <td align="left" valign="top" width="20%" headers="d93390e3444 d93390e3384 ">
                                 <p>使用oci.h中定义的OCIRaw *函数。</p>
                              </td>
                           </tr>
                           <tr align="left" valign="top">
                              <td align="left" valign="top" width="20%" id="d93390e3468" headers="d93390e3370 ">
                                 <p>OCIString</p>
                              </td>
                              <td align="left" valign="top" width="20%" headers="d93390e3468 d93390e3375 ">
                                 <p><span class="bold">主持人：</span> OCIString *</p>
                                 <p><span class="bold">指标：</span> OCIInd</p>
                              </td>
                              <td align="left" valign="top" width="20%" headers="d93390e3468 d93390e3378 ">
                                 <p>EXEC SQL ALLOCATE</p>
                                 <p>为对象缓存中的主机var分配内存</p>
                              </td>
                              <td align="left" valign="top" width="20%" headers="d93390e3468 d93390e3381 ">
                                 <p>EXEC SQL FREE，或EXEC SQL CACHE FREE ALL，或在会话结束时自动执行。</p>
                              </td>
                              <td align="left" valign="top" width="20%" headers="d93390e3468 d93390e3384 ">
                                 <p>（1）使用EXEC SQL OBJECT GET / SET，或</p>
                                 <p>（2）使用oci.h中定义的OCIString *函数。</p>
                              </td>
                           </tr>
                           <tr align="left" valign="top">
                              <td align="left" valign="top" width="20%" id="d93390e3494" headers="d93390e3370 ">
                                 <p><span class="bold">注意：</span></p>
                                 <p>这些类型的主机阵列不能用于Pro * C / C ++中的批量获取/插入SQL操作。</p>
                              </td>
                              <td align="left" valign="top" width="20%" headers="d93390e3494 d93390e3375 ">
                                 <p>-</p>
                              </td>
                              <td align="left" valign="top" width="20%" headers="d93390e3494 d93390e3378 ">
                                 <p>-</p>
                              </td>
                              <td align="left" valign="top" width="20%" headers="d93390e3494 d93390e3381 ">
                                 <p>-</p>
                              </td>
                              <td align="left" valign="top" width="20%" headers="d93390e3494 d93390e3384 ">
                                 <p>-</p>
                              </td>
                           </tr>
                        </tbody>
                     </table>
                  </div>
                  <!-- class="inftblhruleinformal" -->
                  <div class="section">
                     <p>Oracle8的新数据类型是Ref，BLOB，NCLOB，CLOB和BFILE。这些类型可用于对象或关系列。在任何一种情况下，它们都根据C绑定映射到主机变量。</p>
                     <div class="infoboxnotealso" id="GUID-D46CF7DA-22AD-4EC7-ABAE-6376E344CE75__GUID-0D85FB55-978F-42E1-B74B-671C7BC1D381">
                        <p class="notep1">也可以看看：</p>
                        <p><span class="q">“ <a href="about-Objects.html#GUID-D46CF7DA-22AD-4EC7-ABAE-6376E344CE75">总结Pro * C / C ++中的新数据库类型</a> ”</span>以获取C绑定的描述</p>
                     </div>
                  </div>
                  <!-- class="section" -->
               </div>
            </div><a id="LNPCC4374"></a><div class="props_rev_3"><a id="GUID-4D7E09CE-34ED-4516-A129-83A7BCD82443" name="GUID-4D7E09CE-34ED-4516-A129-83A7BCD82443"></a><h3 id="LNPCC-GUID-4D7E09CE-34ED-4516-A129-83A7BCD82443" class="sect3"><span class="enumeration_section">17.16</span>在动态SQL中使用Oracle数据类型的限制</h3>
               <div>
                  <p>Pro * C / C ++目前支持这些不同类型的动态SQL方法：方法1,2,3和4（ANSI和Oracle）。</p>
                  <p>动态方法1,2和3将处理前面提到的所有Pro * C / C ++扩展，包括新对象类型，REF，嵌套表，变化数组，NCHAR，NCHAR变量和LOB类型。</p>
                  <p>较旧的Dynamic SQL方法4通常仅限于8.0版之前的Pro * C / C ++支持的Oracle类型。它确实允许NCHAR，NCHAR Varying和LOB数据类型的主机变量。动态方法4不适用于对象类型，嵌套表，变量数组和REF类型。</p>
                  <p>相反，对所有新应用程序使用ANSI动态SQL方法4，因为它支持Oracle8 <span class="italic">i中</span>引入的所有数据类型。
                  </p>
               </div>
               <div>
                  <div class="relinfo">
                     <p><strong>相关话题</strong></p>
                     <ul>
                        <li><a href="Oracle-dynamic-SQL.html#GUID-3B9E253A-F03D-431D-A77E-84C02C43F494">Oracle动态SQL</a></li>
                        <li><a href="ANSI-dynamic-SQL.html#GUID-BF450DA3-B05F-403E-B5DF-C967A20524BF">ANSI动态SQL</a></li>
                        <li><a href="Oracle-dynamic-SQL-method-4.html#GUID-B516B7C8-1859-4A54-B15D-DF0C3D3C474D">Oracle动态SQL：方法4</a></li>
                     </ul>
                  </div>
               </div>
               
            </div>
         </div>
      </article>
   </body>
</html>