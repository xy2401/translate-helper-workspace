<html lang="en-us" dir="ltr" xml:lang="en-us">
   <head>
      <meta http-equiv="Content-Type" content="text/html; charset=utf-8"></meta>
      <meta name="viewport" content="width=device-width, initial-scale=1"></meta>
      <meta http-equiv="X-UA-Compatible" content="IE=edge"></meta>
      <title>入门</title>
      <meta property="og:site_name" content="Oracle Help Center"></meta>
      <meta property="og:title" content="JDBC Developer&#39;s Guide"></meta>
      <meta property="og:description" content=""></meta>
      <link rel="stylesheet" href="/sp_common/book-template/ohc-book-template/css/book.css"></link>
      <link rel="shortcut icon" href="/sp_common/book-template/ohc-common/img/favicon.ico"></link>
      <meta name="application-name" content="JDBC Developer&#39;s Guide"></meta>
      <meta name="generator" content="DITA Open Toolkit version 1.8.5 (Mode = doc)"></meta>
      <meta name="plugin" content="SP_docbuilder HTML plugin release 18.2.2"></meta>
      <link rel="alternate" href="jdbc-developers-guide.pdf" title="PDF File" type="application/pdf"></link>
      <meta name="robots" content="all"></meta>
      <link rel="schema.dcterms" href="http://purl.org/dc/terms/"></link>
      <meta name="dcterms.created" content="2019-02-13T13:20:37-08:00"></meta>
      <meta name="dcterms.title" content="JDBC Developer&#39;s Guide"></meta>
      <meta name="dcterms.dateCopyrighted" content="1999, 2019"></meta>
      <meta name="dcterms.category" content="database"></meta>
      <meta name="dcterms.identifier" content="E96471-02"></meta>
      
      <meta name="dcterms.product" content="en/database/oracle/oracle-database/19"></meta>
      
      <link rel="prev" href="introducing-JDBC.html" title="Previous" type="text/html"></link>
      <link rel="next" href="overview-Oracle-JDBC.html" title="Next" type="text/html"></link>
      <script>
        document.write('<style type="text/css">');
        document.write('body > .noscript, body > .noscript ~ * { visibility: hidden; }');
        document.write('</style>');
     </script>
      <script src="/sp_common/book-template/requirejs/require.js" data-main="/sp_common/book-template/ohc-book-template/js/book-config"></script>
      <script>
            if (window.require === undefined) {
                document.write('<script data-main="sp_common/book-template/ohc-book-template/js/book-config" src="sp_common/book-template/requirejs/require.js"><\/script>');
                document.write('<link href="sp_common/book-template/ohc-book-template/css/book.css" rel="stylesheet"/>');
            }
        </script>
      <script type="application/json" id="ssot-metadata">{"primary":{"category":{"short_name":"database","element_name":"Database","display_in_url":true},"suite":{"short_name":"oracle","element_name":"Oracle","display_in_url":true},"product_group":{"short_name":"not-applicable","element_name":"Not applicable","display_in_url":false},"product":{"short_name":"oracle-database","element_name":"Oracle Database","display_in_url":true},"release":{"short_name":"19","element_name":"Release 19","display_in_url":true}}}</script>
      
    <meta name="dcterms.isVersionOf" content="JJDBC"></meta>
    <meta name="dcterms.release" content="Release 19"></meta>
  </head>
   <body dir="ltr">
      <div class="noscript alert alert-danger text-center" role="alert">
         <a href="introducing-JDBC.html" class="pull-left"><span class="glyphicon glyphicon-chevron-left" aria-hidden="true"></span>上一页</a> <a href="overview-Oracle-JDBC.html" class="pull-right">下一页<span class="glyphicon glyphicon-chevron-right" aria-hidden="true"></span></a> <span class="fa fa-exclamation-triangle" aria-hidden="true"></span>必须启用JavaScript才能正确显示此内容</div>
      <article>
         <header>
            <ol class="breadcrumb" vocab="http://schema.org/" typeof="BreadcrumbList">
               <li property="itemListElement" typeof="ListItem"><a href="index.html" property="item" typeof="WebPage"><span property="name">JDBC开发人员指南</span></a></li>
               <li property="itemListElement" typeof="ListItem"><a href="overview-of-JDBC.html" property="item" typeof="WebPage"><span property="name">概观</span></a></li>
               <li class="active" property="itemListElement" typeof="ListItem">入门</li>
            </ol>
            <a id="GUID-00FE03D7-48D6-4DA5-A3A0-8768D2936AB8" name="GUID-00FE03D7-48D6-4DA5-A3A0-8768D2936AB8"></a><a id="JJDBC20000"></a>
            
            <h2 id="JJDBC-GUID-00FE03D7-48D6-4DA5-A3A0-8768D2936AB8" class="sect2"><span class="enumeration_chapter">2</span>入门</h2>
         </header>
         <div class="ind">
            <div>
               <p>本章讨论Oracle Java数据库连接（JDBC）驱动程序版本，数据库版本和Java Development Kit（JDK）版本的兼容性。它还描述了测试客户端安装和配置以及运行简单应用程序的基础知识。本章包含以下部分：</p>
               <ul style="list-style-type:disc">
                  <li>
                     <p><a href="JDBC-getting-started.html#GUID-926E5324-D89A-4A00-B1AE-975C1089F0EA">Oracle JDBC驱动程序的版本兼容性</a></p>
                  </li>
                  <li>
                     <p><a href="JDBC-getting-started.html#GUID-E36056D2-80C1-4044-94BC-D6354EF3955C">验证JDBC客户端安装</a></p>
                  </li>
                  <li>
                     <p><a href="JDBC-getting-started.html#GUID-44E1770A-967E-4713-9AFF-86D9D4EDE188">JDBC中的基本步骤</a></p>
                  </li>
                  <li>
                     <p><a href="JDBC-getting-started.html#GUID-D59CA273-203C-431A-BB27-D660ACBFE105">示例：Connecting_ Querying_和处理结果</a></p>
                  </li>
                  <li>
                     <p><a href="JDBC-getting-started.html#GUID-2796DCC2-29FF-4D65-852F-ABCA3AFCEE9C">支持隐形列</a></p>
                  </li>
                  <li>
                     <p><a href="JDBC-getting-started.html#GUID-F30B1931-7755-4973-A113-DB6D25C85937">支持验证JSON数据</a></p>
                  </li>
                  <li>
                     <p><a href="JDBC-getting-started.html#GUID-FA6FA05D-CE5C-4A03-B70E-8DD9F8F5DD92">支持隐含结果</a></p>
                  </li>
                  <li>
                     <p><a href="JDBC-getting-started.html#GUID-6AFB71F0-EFA9-43A0-AF96-03E6FB2F3521">支持轻量级连接验证</a></p>
                  </li>
                  <li>
                     <p><a href="JDBC-getting-started.html#GUID-D5BB4E1F-59FD-4C5E-876C-71420F2DAE9B">支持数据库节点的Deprioritization</a></p>
                  </li>
                  <li>
                     <p><a href="JDBC-getting-started.html#GUID-65A18AD5-04DE-4EE0-8069-4F27449AC5B6">在流量控制器模式下支持Oracle Connection Manager</a></p>
                  </li>
                  <li>
                     <p><a href="JDBC-getting-started.html#GUID-98F62472-1415-4099-A6B6-7C13C6AEC040">JDBC程序中的存储过程调用</a></p>
                  </li>
                  <li>
                     <p><a href="JDBC-getting-started.html#GUID-E187D04E-B48D-4394-9DC5-1ECEEBC53AFD">关于处理SQL异常</a></p>
                  </li>
               </ul>
            </div><a id="JJDBC28047"></a><a id="JJDBC28048"></a><a id="JJDBC28046"></a><div class="props_rev_3"><a id="GUID-926E5324-D89A-4A00-B1AE-975C1089F0EA" name="GUID-926E5324-D89A-4A00-B1AE-975C1089F0EA"></a><h3 id="JJDBC-GUID-926E5324-D89A-4A00-B1AE-975C1089F0EA" class="sect3"><span class="enumeration_section">2.1</span> Oracle JDBC驱动程序的版本兼容性</h3>
               <div>
                  <div class="section">
                     <p>本节讨论一般JDBC版本兼容性问题。</p>
                  </div>
                  <!-- class="section" -->
                  <div class="section">
                     <p class="subhead2" id="GUID-926E5324-D89A-4A00-B1AE-975C1089F0EA__GUID-3086ADC1-DF91-4A77-923E-232DEB3D9E1C">向后兼容性</p>
                  </div>
                  <!-- class="section" -->
                  <div class="section">
                     <p>Oracle Database 12 <span class="italic">c</span>第2版（12.2.0.1）JDBC驱动程序已通过受支持的Oracle数据库版本（11.x.0.x）的认证。但是，它们未经过认证，无法使用较旧的，不受支持的数据库版本，例如10.2.x，10.1.x，9.2.x和9.0.1.x.
                     </p>
                     <div class="infoboxnote" id="GUID-926E5324-D89A-4A00-B1AE-975C1089F0EA__GUID-E5809AB0-6500-4CA5-A0A8-76DD81E70C48">
                        <p class="notep1">注意：</p>
                        <p>如果要使用快速连接故障转移机制，请将10.2 JDBC驱动程序与Oracle数据库10.2一起使用。如果数据库是10.1，则使用10.1 JDBC驱动程序。</p>
                     </div>
                  </div>
                  <!-- class="section" -->
                  <div class="section">
                     <p class="subhead2" id="GUID-926E5324-D89A-4A00-B1AE-975C1089F0EA__GUID-9BC987FC-E0F8-4BE8-948F-1F2E0E1777AB">前向兼容性</p>
                  </div>
                  <!-- class="section" -->
                  <div class="section">
                     <p>现有和支持的JDBC驱动程序经认证可与Oracle Database 12 <span class="italic">c</span>第2版（12.2）配合使用。
                     </p>
                     <div class="infoboxnote" id="GUID-926E5324-D89A-4A00-B1AE-975C1089F0EA__GUID-556A0A94-27EB-4353-8F6C-3589A41657DC">
                        <p class="notep1">注意：</p>
                        <p>在Oracle Database 12 <span class="italic">c</span>第2版（12.2.0.1）中，Oracle JDBC驱动程序不再支持JDK 6或更早版本。
                        </p>
                     </div>
                  </div>
                  <!-- class="section" -->
               </div>
               <div>
                  <div class="relinfo">
                     <p><strong>相关话题</strong></p>
                     <ul>
                        <li><a href="../jjucp/fast-connection-failover.html#JJUCP-GUID-126F8C9B-C0B3-426B-B07D-4B127BBDD867" target="_blank"><span><cite>Oracle通用连接池开发人员指南</cite></span></a></li>
                        <li><a href="http://www.oracle.com/technetwork/database/enterprise-edition/jdbc-faq-090281.html" target="_blank">http://www.oracle.com/technetwork/database/enterprise-edition/jdbc-faq-090281.html</a></li>
                     </ul>
                  </div>
               </div>
            </div><a id="JJDBC28049"></a><div class="props_rev_3"><a id="GUID-E36056D2-80C1-4044-94BC-D6354EF3955C" name="GUID-E36056D2-80C1-4044-94BC-D6354EF3955C"></a><h3 id="JJDBC-GUID-E36056D2-80C1-4044-94BC-D6354EF3955C" class="sect3"><span class="enumeration_section">2.2</span>验证JDBC客户端安装</h3>
               <div>
                  <div class="section">
                     <p>至<a id="d16478e179" class="indexterm-anchor"></a>验证JDBC客户端安装，您必须执行以下所有操作：</p>
                  </div>
                  <!-- class="section" -->
                  <div class="section">
                     <ul style="list-style-type:disc">
                        <li>
                           <p><a href="JDBC-getting-started.html#GUID-356ECF59-F426-4185-9D8D-74C99B83A2F0">检查已安装的目录和文件</a></p>
                        </li>
                        <li>
                           <p><a href="JDBC-getting-started.html#GUID-782A399A-78F5-4D1A-A4F3-F5AE35DE62DA">检查环境变量</a></p>
                        </li>
                        <li>
                           <p><a href="JDBC-getting-started.html#GUID-06BD7132-70A5-416D-B766-F6AB9961CC01">确保可以编译和运行Java代码</a></p>
                        </li>
                        <li>
                           <p><a href="JDBC-getting-started.html#GUID-FBF89046-1782-43B1-BFCF-121BC7FC8261">确定JDBC驱动程序的版本</a></p>
                        </li>
                        <li>
                           <p><a href="JDBC-getting-started.html#GUID-A7809785-56AF-4BD1-A04D-E69CA03489C5">测试JDBC和数据库连接</a></p>
                        </li>
                     </ul>
                     <p>本节介绍验证JDBC驱动程序的Oracle客户端安装的步骤，假设您已经安装了所选的驱动程序。安装Oracle JDBC驱动程序是特定于平台的。您必须按照要在平台特定文档中安装的驱动程序的安装说明进行操作。</p>
                     <p>如果使用JDBC Thin驱动程序，则客户端计算机上不会进行其他安装。如果使用JDBC Oracle调用接口（OCI）驱动程序，则还必须安装Oracle客户端软件。这包括Oracle Net和OCI库。</p>
                     <div class="infoboxnote" id="GUID-E36056D2-80C1-4044-94BC-D6354EF3955C__GUID-B1F6F95C-284B-4C69-92EE-4F25256B25A7">
                        <p class="notep1">注意：</p>
                        <p>JDBC Thin驱动程序要求在安装数据库的计算机上运行TCP / IP侦听器。</p>
                     </div>
                  </div>
                  <!-- class="section" -->
               </div><a id="JJDBC28050"></a><div class="props_rev_3"><a id="GUID-356ECF59-F426-4185-9D8D-74C99B83A2F0" name="GUID-356ECF59-F426-4185-9D8D-74C99B83A2F0"></a><h4 id="JJDBC-GUID-356ECF59-F426-4185-9D8D-74C99B83A2F0" class="sect4"><span class="enumeration_section">2.2.1</span>检查已安装的目录和文件</h4>
                  <div>
                     <div class="section">
                        <p>除其他外，安装Oracle Java产品还会创建以下目录：</p>
                     </div>
                     <!-- class="section" -->
                     <div class="section">
                        <ul style="list-style-type:disc">
                           <li>
                              <p><span class="italic"><code class="codeph">ORACLE_HOME</code></span> <code class="codeph">/jdbc</code></p>
                           </li>
                           <li>
                              <p><span class="italic"><code class="codeph">ORACLE_HOME</code></span> <code class="codeph">/jlib</code></p>
                           </li>
                        </ul>
                        <p>检查是否已在<span class="italic"><code class="codeph">ORACLE_HOME</code></span> <code class="codeph">/jdbc</code>目录中创建并填充了以下目录和文件：</p>
                        <ul style="list-style-type:disc">
                           <li>
                              <p><code class="codeph">演示</code></p>
                              <p>该目录包含一个压缩文件<code class="codeph">demo.zip</code>或<code class="codeph">demo.tar</code> 。解压缩此压缩文件时，将创建<code class="codeph">samples</code>目录和<code class="codeph">Samples-Readme.txt</code>文件。<code class="codeph">samples</code>目录包含示例程序，包括如何使用JDBC转义语法和Oracle SQL语法，PL / SQL块，流，用户定义类型，其他Oracle类型扩展和Oracle性能扩展的示例。
                              </p>
                           </li>
                           <li>
                              <p><code class="codeph">DOC</code></p>
                              <p>该目录包含<code class="codeph">javadoc.zip</code>文件，该文件是Oracle JDBC应用程序编程接口（API）文档。
                              </p>
                           </li>
                           <li>
                              <p><code class="codeph">LIB</code></p>
                              <p><code class="codeph">lib</code>目录包含以下必需的Java类：</p>
                              <ul style="list-style-type:disc">
                                 <li>
                                    <p><code class="codeph">orai18n.jar</code>和<code class="codeph">orai18n-mapping.jar</code></p>
                                    <p>包含全球化和多字节字符集支持的类</p>
                                 </li>
                                 <li>
                                    <p><code class="codeph">ojdbc8.jar</code>和<code class="codeph">ojdbc8_g.jar</code></p>
                                    <p>包含用于JDK 8的JDBC驱动程序类</p>
                                 </li>
                              </ul>
                           </li>
                        </ul>
                        <ul style="list-style-type:disc">
                           <li>
                              <p><code class="codeph">readme.txt文件</code></p>
                              <p>此文件包含有关驱动程序的最新和特定于发行版的信息，这些信息可能未包含在产品的其他文档中。</p>
                           </li>
                        </ul>
                        <p>检查是否已在<span class="italic"><code class="codeph">ORACLE_HOME</code></span> <code class="codeph">/jlib</code>目录中创建并填充了以下目录：</p>
                        <ul style="list-style-type:disc">
                           <li>
                              <p><code class="codeph">jta.jar</code>和<code class="codeph">jndi.jar</code></p>
                              <p>这些文件包含Java Transaction API（JTA）和Java命名和目录接口（JNDI）的类。仅当您使用JTA功能进行分布式事务管理或使用JNDI功能进行命名服务时，才需要这些功能。</p>
                           </li>
                           <li>
                              <p><code class="codeph">ons.jar</code></p>
                              <p>此JAR文件包含Oracle RAC快速应用程序通知的类。它还需要通用连接池（UCP）功能，如快速连接故障转移，运行时负载平衡，Web会话关联和事务关联。</p>
                           </li>
                        </ul>
                     </div>
                     <!-- class="section" -->
                  </div>
                  <div>
                     <div class="relinfo">
                        <p><strong>相关话题</strong></p>
                        <ul>
                           <li><a href="Oracle-RAC-FAN-API.html#GUID-672941ED-9553-4779-B1AD-7FEBC07603D6">Oracle RAC快速应用程序通知</a></li>
                           <li><a href="http://www.oracle.com/technetwork/java/javaee/jta/" target="_blank">jta.jar</a></li>
                           <li><a href="http://www.oracle.com/technetwork/java/jndi/index.html" target="_blank">jndi.jar</a></li>
                           <li><a href="../jjucp/using-Oracle-RAC-features.html#JJUCP-GUID-A0B5E9FF-84E1-40FC-8B2E-084C1134FDFD" target="_blank"><span><cite>Oracle通用连接池开发人员指南</cite></span></a></li>
                        </ul>
                     </div>
                  </div>
               </div><a id="JJDBC28052"></a><a id="JJDBC28053"></a><a id="JJDBC28054"></a><a id="JJDBC28051"></a><div class="props_rev_3"><a id="GUID-782A399A-78F5-4D1A-A4F3-F5AE35DE62DA" name="GUID-782A399A-78F5-4D1A-A4F3-F5AE35DE62DA"></a><h4 id="JJDBC-GUID-782A399A-78F5-4D1A-A4F3-F5AE35DE62DA" class="sect4"><span class="enumeration_section">2.2.2</span>检查环境变量</h4>
                  <div>
                     <div class="section">
                        <p>本节介绍了<a id="d16478e415" class="indexterm-anchor"></a>必须为JDBC OCI驱动程序和JDBC Thin驱动程序设置的环境变量，重点关注Solaris，Linux和Microsoft Windows平台。
                        </p>
                        <p>您必须为JDBC OCI或Thin驱动程序设置<code class="codeph">CLASSPATH</code>环境变量。在<code class="codeph">CLASSPATH</code>环境变量中包含以下内容：</p><pre class="oac_no_warn" dir="ltr"><span class="italic">ORACLE_HOME</span> /jdbc/lib/ojdbc8.jar <span class="italic">ORACLE_HOME</span> /jlib/orai18n.jar</pre><div class="infoboxnote" id="GUID-782A399A-78F5-4D1A-A4F3-F5AE35DE62DA__GUID-76BA7D30-41CB-4716-BB4D-97F05CEDA46A">
                           <p class="notep1">注意：</p>
                           <p>如果使用JTA功能和JNDI功能，则必须在<code class="codeph">CLASSPATH</code>环境变量中指定<code class="codeph">jta.jar</code>和<code class="codeph">jndi.jar</code> 。
                           </p>
                        </div>
                     </div>
                     <!-- class="section" -->
                     <div class="section">
                        <p class="subhead3" id="GUID-782A399A-78F5-4D1A-A4F3-F5AE35DE62DA__GUID-FEAE505F-3752-4947-9624-920961ADB569">JDBC OCI驱动程序</p>
                     </div>
                     <!-- class="section" -->
                     <div class="section">
                        <p>要使用JDBC OCI驱动程序，还必须为库路径环境变量设置以下值：</p>
                        <ul style="list-style-type:disc">
                           <li>
                              <p>在Solaris或Linux上，按如下所示设置<code class="codeph">LD_LIBRARY_PATH</code>环境变量：</p><pre class="oac_no_warn" dir="ltr"><span class="italic">ORACLE_HOME</span> / lib</pre><p>该目录包含<code class="codeph">libocijdbc11.so</code>共享对象库。
                              </p>
                           </li>
                           <li>
                              <p>在Microsoft Windows上，按如下方式设置<code class="codeph">PATH</code>环境变量：</p><pre class="oac_no_warn" dir="ltr"><span class="italic">ORACLE_HOME</span> \ bin</pre><p>该目录包含<code class="codeph">ocijdbc11.dll</code>动态链接库。
                              </p>
                           </li>
                        </ul>
                        <p>通过在库路径环境变量上包含JDBC OCI Instant Client数据共享库，可以在Instant Client模式下运行所有JDBC OCI演示程序。</p>
                     </div>
                     <!-- class="section" -->
                     <div class="section">
                        <p class="subhead3" id="GUID-782A399A-78F5-4D1A-A4F3-F5AE35DE62DA__GUID-7D977C6A-3EF1-46E1-AFD5-7C0AA03A0224">JDBC瘦驱动程序</p>
                     </div>
                     <!-- class="section" -->
                     <div class="section">
                        <p>要使用JDBC Thin驱动程序，您不必设置任何其他环境变量。但是，要使用JDBC服务器端Thin驱动程序，您需要设置权限。</p>
                     </div>
                     <!-- class="section" -->
                     <div class="section">
                        <p class="subhead3" id="GUID-782A399A-78F5-4D1A-A4F3-F5AE35DE62DA__GUID-3F529AAC-E53A-4441-8A24-6D719CE0704C">设置服务器端瘦驱动程序的权限</p>
                     </div>
                     <!-- class="section" -->
                     <div class="section">
                        <p>JDBC服务器端Thin驱动程序为其与数据库的连接打开一个套接字。由于Oracle数据库强制执行Java安全模型，因此将对<code class="codeph">SocketPermission</code>对象执行检查。
                        </p>
                        <p>要使用JDBC服务器端Thin驱动程序，必须为连接用户授予适当的权限。以下是如何为用户<code class="codeph">HR</code>授予权限的示例：</p><pre class="oac_no_warn" dir="ltr">创造角色jdbcthin; CALL dbms_java.grant_permission（'JDBCTHIN'，'java.net。SocketPermission'，'*'，'connect'）; GRANT jdbcthin TO HR;</pre><p>请注意， <code class="codeph">JDBCTHIN</code>调用中的<code class="codeph">grant_permission</code>必须为大写。星号（ <code class="codeph">*</code> ）是一种模式。您可以通过授予仅连接到特定计算机或端口的权限来限制用户。
                        </p>
                     </div>
                     <!-- class="section" -->
                  </div>
                  <div>
                     <div class="relinfo">
                        <p><strong>相关话题</strong></p>
                        <ul>
                           <li><a href="JDBC-OCI-features.html#GUID-A8201BD0-BAED-4C54-B53B-C26C5F295B32">JDBC OCI驱动程序特有的功能</a></li>
                           <li><a href="../jjdev/DBMS-JAVA-package.html#JJDEV-GUID-C6AE17E3-B1B0-4773-A5F5-CBBDB5B6D7CF" target="_blank"><span><cite>Oracle数据库Java开发人员指南</cite></span></a></li>
                        </ul>
                     </div>
                  </div>
               </div><a id="JJDBC28055"></a><div class="props_rev_3"><a id="GUID-06BD7132-70A5-416D-B766-F6AB9961CC01" name="GUID-06BD7132-70A5-416D-B766-F6AB9961CC01"></a><h4 id="JJDBC-GUID-06BD7132-70A5-416D-B766-F6AB9961CC01" class="sect4"><span class="enumeration_section">2.2.3</span>确保可以编译和运行Java代码</h4>
                  <div>
                     <div class="section">
                        <p><a id="d16478e555" class="indexterm-anchor"></a><a id="d16478e559" class="indexterm-anchor"></a>要进一步确保在客户端系统上正确设置Java，请转到<span class="italic"><code class="codeph">ORACLE_HOME</code></span> <code class="codeph">/jdbc/demo</code>目录下的<code class="codeph">samples</code>目录。现在，在命令行上依次键入以下命令，以查看Java编译器和Java解释器是否正常运行：</p><pre class="oac_no_warn" dir="ltr">javac java</pre><p>上述每个命令都应显示选项和参数列表，然后退出。理想情况下，验证您是否可以编译并运行一个简单的测试程序，例如<code class="codeph">jdbc/demo/samples/generic/SelectExample</code> 。
                        </p>
                     </div>
                     <!-- class="section" -->
                  </div>
               </div><a id="JJDBC28056"></a><div class="props_rev_3"><a id="GUID-FBF89046-1782-43B1-BFCF-121BC7FC8261" name="GUID-FBF89046-1782-43B1-BFCF-121BC7FC8261"></a><h4 id="JJDBC-GUID-FBF89046-1782-43B1-BFCF-121BC7FC8261" class="sect4"><span class="enumeration_section">2.2.4</span>确定JDBC驱动程序的版本</h4>
                  <div>
                     <div class="section">
                        <p>要确定JDBC驱动程序的版本，请调用<code class="codeph">OracleDatabaseMetaData</code>类的<code class="codeph">getDriverVersion</code>方法，如以下示例代码所示：</p><pre class="oac_no_warn" dir="ltr">import java.sql。*; import oracle.jdbc。*; import oracle.jdbc.pool。OracleDataSource; class JDBCVersion {public static void main（String args []）抛出SQLException {OracleDataSource ods = new OracleDataSource（）; ods.setURL（ “JDBC：预言：瘦：HR /小时@ &lt;主机&gt;：&lt;端口&gt;：&lt;服务&gt;”）; Connection conn = ods.getConnection（）; //创建Oracle DatabaseMetaData对象DatabaseMetaData meta = conn.getMetaData（）; //获取驱动程序信息：System.out.println（“JDBC驱动程序版本为”+ meta.getDriverVersion（））; }}</pre><p>您还可以通过执行以下命令来确定JDBC驱动程序的版本：</p>
                     </div>
                     <!-- class="section" -->
                     <div class="section">
                        <ul style="list-style-type:disc">
                           <li>
                              <p><code class="codeph">java -jar ojdbc8.jar</code></p>
                           </li>
                        </ul>
                     </div>
                     <!-- class="section" -->
                  </div>
               </div><a id="JJDBC28057"></a><div class="props_rev_3"><a id="GUID-A7809785-56AF-4BD1-A04D-E69CA03489C5" name="GUID-A7809785-56AF-4BD1-A04D-E69CA03489C5"></a><h4 id="JJDBC-GUID-A7809785-56AF-4BD1-A04D-E69CA03489C5" class="sect4"><span class="enumeration_section">2.2.5</span>测试JDBC和数据库连接</h4>
                  <div>
                     <div class="section">
                        <p><code class="codeph">samples</code> <a id="d16478e655" class="indexterm-anchor"></a><a id="d16478e659" class="indexterm-anchor"></a><a id="d16478e663" class="indexterm-anchor"></a> directory包含特定Oracle JDBC驱动程序的示例程序。其中一个程序<code class="codeph">JdbcCheckup.java</code>用于测试JDBC和数据库连接。程序将查询要连接的用户名，密码和数据库的名称。程序连接到数据库，查询字符串“ <code class="codeph">Hello World</code> ”，并将其打印到屏幕上。
                        </p>
                        <p>转到<code class="codeph">samples</code>目录，编译并运行<code class="codeph">JdbcCheckup.java</code>程序。如果查询结果打印没有错误，那么您的Java和JDBC安装是正确的。
                        </p>
                        <p>虽然<code class="codeph">JdbcCheckup.java</code>是一个简单的程序，但它通过执行以下操作演示了几个重要的功能：</p>
                     </div>
                     <!-- class="section" -->
                     <div class="section">
                        <ul style="list-style-type:disc">
                           <li>
                              <p>导入必要的Java类，包括JDBC类</p>
                           </li>
                           <li>
                              <p>创建一个<code class="codeph">DataSource</code>实例</p>
                           </li>
                           <li>
                              <p>连接数据库</p>
                           </li>
                           <li>
                              <p>运行一个简单的查询</p>
                           </li>
                           <li>
                              <p>将查询结果打印到屏幕上</p>
                           </li>
                        </ul>
                        <p>使用JDBC OCI驱动程序的<code class="codeph">JdbcCheckup.java</code>程序如下：</p><pre class="oac_no_warn" dir="ltr">/ * *此示例可用于检查JDBC安装。*只需运行它并提供连接信息。它将从数据库中选择*“Hello World”。* / //您需要导入java.sql和JDBC包以使用JDBC import java.sql。*; import oracle.jdbc。*; import oracle.jdbc.pool。OracleDataSource; //我们导入java.io以便能够从命令行import java.io中读取。*; class JdbcCheckup {public static void main（String args []）抛出SQLException，IOException {//提示用户输入连接信息System.out.println（“请输入信息以测试与数据库的连接”）;字符串用户;字符串密码;字符串数据库user = readEntry（“user：”）; int slash_index = user.indexOf（'/'）; if（slash_index！= -1）{password = user.substring（slash_index + 1）; user = user.substring（0，slash_index）; } else password = readEntry（“password：”）; database = readEntry（“database（一个TNSNAME条目）：”）; System.out.print（“连接数据库......”）; System.out.flush（）;的System.out.println（ “连接...”）; //打开OracleDataSource并获取连接OracleDataSource ods = new OracleDataSource（）; ods.setURL（“jdbc：oracle：oci：@”+ database）; ods.setUser（用户）; ods.setPassword（密码）; Connection conn = ods.getConnection（）;的System.out.println（ “连接”）; //创建语句Statement stmt = conn.createStatement（）; //执行SQL“Hello World”事件ResultSet rset = stmt.executeQuery（“从双重选择'Hello World'）; while（rset.next（））System.out.println（rset.getString（1））; //关闭结果集，语句和连接rset.close（）; stmt.close（）; conn.close（）; System.out.println（“你的JDBC安装是正确的。”）; } //实用程序函数从标准输入读取一行static String readEntry（String prompt）{try {StringBuffer buffer = new StringBuffer（）;是System.out.print（提示）; System.out.flush（）; int c = System.in.read（）;而（c！='\ n'&amp;&amp; c！= -1）{buffer.append（（char）c）; c = System.in.read（）; } return buffer.toString（）。trim（）; } catch（IOException e）{return“”; }}}</pre></div>
                     <!-- class="section" -->
                  </div>
               </div>
            </div><a id="JJDBC28058"></a><div class="props_rev_3"><a id="GUID-44E1770A-967E-4713-9AFF-86D9D4EDE188" name="GUID-44E1770A-967E-4713-9AFF-86D9D4EDE188"></a><h3 id="JJDBC-GUID-44E1770A-967E-4713-9AFF-86D9D4EDE188" class="sect3"><span class="enumeration_section">2.3</span> JDBC的基本步骤</h3>
               <div>
                  <div class="section">
                     <p>验证JDBC客户端安装后，您可以开始创建JDBC应用程序。<a id="d16478e738" class="indexterm-anchor"></a>使用Oracle JDBC驱动程序时，必须在程序中包含某些特定于驱动程序的信息。本节以教程的形式介绍了添加信息的位置和方式。本教程将指导您完成创建连接到客户端并从客户端查询数据库的代码的步骤。
                     </p>
                     <p>您必须编写代码才能执行以下任务：</p>
                  </div>
                  <!-- class="section" -->
                  <ol>
                     <li><span><a href="JDBC-getting-started.html#GUID-A1B90791-B55C-4066-A83C-2EBC4FB0DFE1">导入包</a></span></li>
                     <li><span><a href="JDBC-getting-started.html#GUID-F65BF3C1-FFB3-4513-AEB6-94A0D025AD39">打开与数据库的连接</a></span></li>
                     <li><span><a href="JDBC-getting-started.html#GUID-44000A82-7B5E-49A9-BB87-8A3A794E8F3A">创建语句对象</a></span></li>
                     <li><span><a href="JDBC-getting-started.html#GUID-B450DD30-C61D-454E-B83D-D18F1EDE7B44">运行查询并检索结果集对象</a></span></li>
                     <li><span><a href="JDBC-getting-started.html#GUID-C7FAF579-24DB-4682-BC83-44AC5E59A8D8">处理结果集对象</a></span></li>
                     <li><span><a href="JDBC-getting-started.html#GUID-0CEBD5D1-8D3E-4ED5-BB91-F69D0723D9E8">关闭结果集和语句对象</a></span></li>
                     <li><span><a href="JDBC-getting-started.html#GUID-6AC53BFD-6723-4D51-BEF1-B4441E6031DD">对数据库进行更改</a></span></li>
                     <li><span><a href="JDBC-getting-started.html#GUID-96D6787D-71A6-4282-B17E-0951DED3DEF9">关于提交更改</a></span></li>
                     <li><span><a href="JDBC-getting-started.html#GUID-9CFCCC9C-8386-4427-AC34-DEE0575B58BB">关闭连接</a></span></li>
                  </ol>
                  <div class="section">
                     <div class="infoboxnote" id="GUID-44E1770A-967E-4713-9AFF-86D9D4EDE188__GUID-A7E77335-7659-4150-AACA-043232744E29">
                        <p class="notep1">注意：</p>
                        <p>您必须提供前三个任务的Oracle驱动程序特定信息，这些任务使您的程序能够使用JDBC应用程序编程接口（API）来访问数据库。对于其他任务，您可以使用标准JDBC Java代码，就像使用任何Java应用程序一样。</p>
                     </div>
                  </div>
                  <!-- class="section" -->
               </div><a id="JJDBC28060"></a><a id="JJDBC28059"></a><div class="props_rev_3"><a id="GUID-A1B90791-B55C-4066-A83C-2EBC4FB0DFE1" name="GUID-A1B90791-B55C-4066-A83C-2EBC4FB0DFE1"></a><h4 id="JJDBC-GUID-A1B90791-B55C-4066-A83C-2EBC4FB0DFE1" class="sect4"><span class="enumeration_section">2.3.1</span>导入包</h4>
                  <div>
                     <div class="section">
                        <p>无论哪个Oracle <a id="d16478e821" class="indexterm-anchor"></a>您使用的JDBC驱动程序包括使用以下语法在程序开头的<a href="JDBC-getting-started.html#GUID-A1B90791-B55C-4066-A83C-2EBC4FB0DFE1__CIHBBIEG" title="表">表2-1</a>中显示的<code class="codeph">import</code>语句：</p><pre class="oac_no_warn" dir="ltr">import <span class="italic">&lt;package_name&gt;</span> ;</pre><div class="tblformal" id="GUID-A1B90791-B55C-4066-A83C-2EBC4FB0DFE1__CIHBBIEG">
                           <p class="titleintable">表2-1 JDBC驱动程序的导入语句</p>
                           <table cellpadding="4" cellspacing="0" class="Formal" title="导入JDBC驱动程序的语句" width="100%" border="1" summary="table" frame="hsides" rules="rows">
                              <thead>
                                 <tr align="left" valign="top">
                                    <th align="left" valign="bottom" width="39%" id="d16478e849">导入声明</th>
                                    <th align="left" valign="bottom" width="61%" id="d16478e852">提供</th>
                                 </tr>
                              </thead>
                              <tbody>
                                 <tr align="left" valign="top">
                                    <td align="left" valign="top" width="39%" id="d16478e857" headers="d16478e849 ">
                                       <p><code class="codeph">import java.sql。*;</code></p>
                                    </td>
                                    <td align="left" valign="top" width="61%" headers="d16478e857 d16478e852 ">
                                       <p>标准JDBC包。</p>
                                    </td>
                                 </tr>
                                 <tr align="left" valign="top">
                                    <td align="left" valign="top" width="39%" id="d16478e865" headers="d16478e849 ">
                                       <p><code class="codeph">import java.math。*;</code></p>
                                    </td>
                                    <td align="left" valign="top" width="61%" headers="d16478e865 d16478e852 ">
                                       <p><code class="codeph">BigDecimal</code>和<code class="codeph">BigInteger</code>类。如果您不打算在应用程序中使用这些类，则可以省略此包。
                                       </p>
                                    </td>
                                 </tr>
                                 <tr align="left" valign="top">
                                    <td align="left" valign="top" width="39%" id="d16478e879" headers="d16478e849 ">
                                       <p><a id="d16478e881" class="indexterm-anchor"></a><code class="codeph">import oracle.jdbc.*;</code></p>
                                       <p><code class="codeph">import oracle.jdbc.pool。*;</code></p>
                                       <p><code class="codeph">import oracle.sql。*;</code></p>
                                    </td>
                                    <td align="left" valign="top" width="61%" headers="d16478e879 d16478e852 ">
                                       <p>Oracle对JDBC的扩展。这是可选的。</p>
                                       <p><code class="codeph">OracleDataSource</code> 。
                                       </p>
                                       <p>Oracle类型扩展。这是可选的。</p>
                                    </td>
                                 </tr>
                              </tbody>
                           </table>
                        </div>
                        <!-- class="inftblhruleinformal" -->
                        <p>列为可选的Oracle软件包提供对Oracle JDBC驱动程序提供的扩展功能的访问，但不是本节中提供的示例所必需的。</p>
                        <div class="infoboxnote" id="GUID-A1B90791-B55C-4066-A83C-2EBC4FB0DFE1__GUID-01F63E5D-E0D6-4FFB-BF31-940084D57FEE">
                           <p class="notep1">注意：</p>
                           <p>最好只导入应用程序所需的类，而不是使用通配符星号（ <code class="codeph">*</code> ）。为简单起见，本指南使用星号（*），但这不是导入类和接口的推荐方法。
                           </p>
                        </div>
                     </div>
                     <!-- class="section" -->
                  </div>
               </div><a id="JJDBC28062"></a><a id="JJDBC28063"></a><a id="JJDBC28061"></a><div class="props_rev_3"><a id="GUID-F65BF3C1-FFB3-4513-AEB6-94A0D025AD39" name="GUID-F65BF3C1-FFB3-4513-AEB6-94A0D025AD39"></a><h4 id="JJDBC-GUID-F65BF3C1-FFB3-4513-AEB6-94A0D025AD39" class="sect4"><span class="enumeration_section">2.3.2</span>打开与数据库的连接</h4>
                  <div>
                     <div class="section">
                        <p>首先，您必须创建一个<code class="codeph">OracleDataSource</code>实例。然后，使用<code class="codeph">OracleDataSource.getConnection</code>方法打开与数据库的连接。检索到的连接的属性派生自<code class="codeph">OracleDataSource</code>实例。如果设置URL连接属性，则<code class="codeph">TNSEntryName</code>所有其他属性，包括<code class="codeph">TNSEntryName</code> ， <code class="codeph">DatabaseName</code> ， <code class="codeph">ServiceName</code> ， <code class="codeph">ServerName</code> ， <code class="codeph">PortNumber</code> ， <code class="codeph">Network Protocol</code>和驱动程序类型。
                        </p>
                     </div>
                     <!-- class="section" -->
                     <div class="section">
                        <p class="subhead3" id="GUID-F65BF3C1-FFB3-4513-AEB6-94A0D025AD39__GUID-FCB5716F-697A-4DF2-87E5-A7E90167A959">指定数据库URL，用户名和密码</p>
                     </div>
                     <!-- class="section" -->
                     <div class="section">
                        <p>以下代码设置数据源的URL，用户名和密码：</p><pre class="oac_no_warn" dir="ltr">OracleDataSource ods = new OracleDataSource（）; ods.setURL（ <span class="italic">url</span> ）; ods.setUser（ <span class="italic">user</span> ）; ods.setPassword（ <span class="italic">密码</span> ）;</pre><p>以下示例使用JDBC Thin驱动程序将用户<code class="codeph">HR</code>与密码<code class="codeph">hr</code>连接到具有服务<code class="codeph">orcl</code>的数据库，通过主机<code class="codeph">myhost</code>端口5221：</p><pre class="oac_no_warn" dir="ltr">OracleDataSource ods = new OracleDataSource（）; String url =“jdbc：oracle：thin：@ // myhost：5221 / orcl”; ods.setURL（URL）; ods.setUser（ “HR”）; ods.setPassword（ “HR”）; Connection conn = ods.getConnection（）;</pre><div class="infoboxnote" id="GUID-F65BF3C1-FFB3-4513-AEB6-94A0D025AD39__GUID-DB8F8247-D49E-4682-AAEB-F0C75EA3E63E">
                           <p class="notep1">注意：</p>
                           <p>参数中指定的用户名和密码将覆盖URL中指定的任何用户名和密码。</p>
                        </div>
                     </div>
                     <!-- class="section" -->
                     <div class="section">
                        <p class="subhead3" id="GUID-F65BF3C1-FFB3-4513-AEB6-94A0D025AD39__GUID-DFB4A082-F72E-43EC-9D46-C879D3142B55">指定包含用户名和密码的数据库URL</p>
                     </div>
                     <!-- class="section" -->
                     <div class="section">
                        <p>以下示例使用JDBC Oracle调用接口（OCI）驱动程序将用户<code class="codeph">HR</code>与密码<code class="codeph">hr</code>连接到透明网络基板（TNS）条目为<code class="codeph">myTNSEntry</code>的数据库主机。在这种情况下，URL包括用户名和密码，并且是唯一的输入参数。
                        </p><pre class="oac_no_warn" dir="ltr">String url =“jdbc：oracle：oci：HR / hr @ myTNSEntry”）; ods.setURL（URL）; Connection conn = ods.getConnection（）;</pre><p>如果要使用Thin驱动程序进行连接，则必须指定端口号。例如，如果要连接到端口5221上具有TCP / IP侦听器并且服务标识符为<code class="codeph">orcl</code>的主机<code class="codeph">myhost</code>上的数据库，请提供以下代码：</p><pre class="oac_no_warn" dir="ltr">String URL =“jdbc：oracle：thin：HR / hr @ // myhost：5221 / orcl”）; ods.setURL（URL）; Connection conn = ods.getConnection（）;</pre></div>
                     <!-- class="section" -->
                  </div>
                  <div>
                     <div class="relinfo">
                        <p><strong>相关话题</strong></p>
                        <ul>
                           <li><a href="data-sources-and-URLs.html#GUID-44572C63-10D2-478A-BB2E-ACF6674C59CC">数据源和URL</a></li>
                           <li><a href="data-sources-and-URLs.html#GUID-44572C63-10D2-478A-BB2E-ACF6674C59CC">数据源和URL</a></li>
                        </ul>
                     </div>
                  </div>
               </div><a id="JJDBC28064"></a><div class="props_rev_3"><a id="GUID-44000A82-7B5E-49A9-BB87-8A3A794E8F3A" name="GUID-44000A82-7B5E-49A9-BB87-8A3A794E8F3A"></a><h4 id="JJDBC-GUID-44000A82-7B5E-49A9-BB87-8A3A794E8F3A" class="sect4"><span class="enumeration_section">2.3.3</span>创建语句对象</h4>
                  <div>
                     <div class="section">
                        <p>一旦连接到数据库，并在此过程中创建一个<code class="codeph">Connection</code>对象，下一步就是创建一个<code class="codeph">Statement</code>对象。JDBC <code class="codeph">Connection</code>对象的<code class="codeph">createStatement</code>方法返回JDBC <code class="codeph">Statement</code>类型的对象。要继续上一节中创建<code class="codeph">Connection</code>对象<code class="codeph">conn</code>的示例，下面是一个如何创建<code class="codeph">Statement</code>对象的示例：</p><pre class="oac_no_warn" dir="ltr">语句stmt = conn.createStatement（）;</pre></div>
                     <!-- class="section" -->
                  </div>
               </div><a id="JJDBC28065"></a><div class="props_rev_3"><a id="GUID-B450DD30-C61D-454E-B83D-D18F1EDE7B44" name="GUID-B450DD30-C61D-454E-B83D-D18F1EDE7B44"></a><h4 id="JJDBC-GUID-B450DD30-C61D-454E-B83D-D18F1EDE7B44" class="sect4"><span class="enumeration_section">2.3.4</span>运行查询并检索结果集对象</h4>
                  <div>
                     <div class="section">
                        <p>要查询数据库，请使用<code class="codeph">Statement</code>对象的<code class="codeph">executeQuery</code>方法。此方法将SQL语句作为输入并返回JDBC <code class="codeph">ResultSet</code>对象。
                        </p>
                        <div class="infoboxnote" id="GUID-B450DD30-C61D-454E-B83D-D18F1EDE7B44__GUID-7E4F8B35-4C34-4DF0-9679-2A3B3537203A">
                           <p class="notep1">注意：</p>
                           <ul style="list-style-type:disc">
                              <li>
                                 <p>用于执行<code class="codeph">Statement</code>对象的方法取决于正在执行的SQL语句的类型。如果<code class="codeph">Statement</code>对象表示返回<code class="codeph">ResultSet</code>对象的SQL查询，则应使用<code class="codeph">executeQuery</code>方法。如果已知SQL是DDL语句或返回更新计数的DML语句，则应使用<code class="codeph">executeUpdate</code>方法。如果未知SQL语句的类型，则应使用<code class="codeph">execute</code>方法。
                                 </p>
                              </li>
                              <li>
                                 <p>对于标准JDBC驱动程序，如果正在执行的SQL字符串未返回<code class="codeph">ResultSet</code>对象，则<code class="codeph">executeQuery</code>方法将引发<code class="codeph">SQLException</code>异常。对于Oracle JDBC驱动程序，即使正在执行的SQL字符串未返回<code class="codeph">ResultSet</code>对象， <code class="codeph">executeQuery</code>方法也不会抛出<code class="codeph">SQLException</code>异常。
                                 </p>
                              </li>
                           </ul>
                        </div>
                        <p>要继续该示例，一旦创建了<code class="codeph">Statement</code>对象<code class="codeph">stmt</code> ，下一步就是运行一个查询，该查询返回一个<code class="codeph">ResultSet</code>对象，其中包含名为<code class="codeph">EMPLOYEES</code>的员工表的<code class="codeph">first_name</code>列的内容：</p><pre class="oac_no_warn" dir="ltr">ResultSet rset = stmt.executeQuery（“SELECT first_name FROM employees”）;</pre></div>
                     <!-- class="section" -->
                  </div>
               </div><a id="JJDBC28066"></a><div class="props_rev_3"><a id="GUID-C7FAF579-24DB-4682-BC83-44AC5E59A8D8" name="GUID-C7FAF579-24DB-4682-BC83-44AC5E59A8D8"></a><h4 id="JJDBC-GUID-C7FAF579-24DB-4682-BC83-44AC5E59A8D8" class="sect4"><span class="enumeration_section">2.3.5</span>处理结果集对象</h4>
                  <div>
                     <div class="section">
                        <p>一旦<a id="d16478e1233" class="indexterm-anchor"></a>运行查询，使用<code class="codeph">ResultSet</code>对象的<code class="codeph">next()</code>方法迭代结果。此方法逐行逐步执行结果集，在到达时检测结果集的结尾。
                        </p>
                        <p>要在迭代结果集时从数据集中提取数据，请使用<code class="codeph">ResultSet</code>对象的相应<code class="codeph">get</code> <span class="italic"><code class="codeph">XXX</code></span>方法，其中<span class="italic"><code class="codeph">XXX</code></span>对应于Java数据类型。
                        </p>
                        <p>例如，以下代码将迭代上一节中的<code class="codeph">ResultSet</code>对象<code class="codeph">rset</code> ，并将检索并打印每个员工姓名：</p><pre class="oac_no_warn" dir="ltr">while（rset.next（））System.out.println（rset.getString（1））;</pre><p><code class="codeph">next()</code>方法在到达结果集的末尾时返回<code class="codeph">false</code> 。员工姓名具体化为Java <code class="codeph">String</code>值。
                        </p>
                     </div>
                     <!-- class="section" -->
                  </div>
               </div><a id="JJDBC28067"></a><div class="props_rev_3"><a id="GUID-0CEBD5D1-8D3E-4ED5-BB91-F69D0723D9E8" name="GUID-0CEBD5D1-8D3E-4ED5-BB91-F69D0723D9E8"></a><h4 id="JJDBC-GUID-0CEBD5D1-8D3E-4ED5-BB91-F69D0723D9E8" class="sect4"><span class="enumeration_section">2.3.6</span>关闭结果集和语句对象</h4>
                  <div>
                     <div class="section">
                        <p>您<a id="d16478e1304" class="indexterm-anchor"></a><a id="d16478e1308" class="indexterm-anchor"></a>必须在完成使用后显式关闭<code class="codeph">ResultSet</code>和<code class="codeph">Statement</code>对象。这适用于您在使用Oracle JDBC驱动程序时创建的所有<code class="codeph">ResultSet</code>和<code class="codeph">Statement</code>对象。驱动程序没有终结器方法。清理例程由<code class="codeph">ResultSet</code>和<code class="codeph">Statement</code>类的<code class="codeph">close</code>方法执行。如果未显式关闭<code class="codeph">ResultSet</code>和<code class="codeph">Statement</code>对象，则可能发生严重的内存泄漏。您也可能在数据库中用完游标。关闭结果集和语句会释放数据库中的相应游标。如果仅关闭结果集，则不会释放光标。
                        </p>
                        <p>例如，如果<code class="codeph">ResultSet</code>对象是<code class="codeph">rset</code>且<code class="codeph">Statement</code>对象是<code class="codeph">stmt</code> ，则使用以下代码行关闭结果集和语句：</p><pre class="oac_no_warn" dir="ltr">rset.close（）; stmt.close（）;</pre><p>当您关闭给定<code class="codeph">Connection</code>对象创建的<code class="codeph">Statement</code>对象时，连接本身保持打开状态。
                        </p>
                        <div class="infoboxnote" id="GUID-0CEBD5D1-8D3E-4ED5-BB91-F69D0723D9E8__GUID-82B80617-9507-4A57-8A46-E702D92C3DF1">
                           <p class="notep1">注意：</p>
                           <p>通常，您应该在<code class="codeph">finally</code>子句中放置<code class="codeph">close</code>语句。
                           </p>
                        </div>
                     </div>
                     <!-- class="section" -->
                  </div>
               </div><a id="JJDBC28069"></a><a id="JJDBC28070"></a><a id="JJDBC28068"></a><div class="props_rev_3"><a id="GUID-6AC53BFD-6723-4D51-BEF1-B4441E6031DD" name="GUID-6AC53BFD-6723-4D51-BEF1-B4441E6031DD"></a><h4 id="JJDBC-GUID-6AC53BFD-6723-4D51-BEF1-B4441E6031DD" class="sect4"><span class="enumeration_section">2.3.7</span>对数据库进行更改</h4>
                  <div>
                     <div class="section">
                        <p class="subhead3" id="GUID-6AC53BFD-6723-4D51-BEF1-B4441E6031DD__GUID-F8E73EA6-68B8-4C46-96F4-64AA570C4AE1">DML操作</p>
                     </div>
                     <!-- class="section" -->
                     <div class="section">
                        <p>要执行DML（数据操作语言）操作（如INSERT或UPDATE操作），可以创建<code class="codeph">Statement</code>对象或<code class="codeph">PreparedStatement</code>对象。<code class="codeph">PreparedStatement</code>对象使您可以使用不同的输入参数集运行语句。JDBC <code class="codeph">Connection</code>对象的<code class="codeph">prepareStatement</code>方法允许您定义一个带有变量绑定参数的语句，并使用您的语句定义返回JDBC <code class="codeph">PreparedStatement</code>对象。
                        </p>
                        <p>使用<code class="codeph">PreparedStatement</code>对象上的<code class="codeph">set</code> <span class="italic"><code class="codeph">XXX</code></span>方法将数据绑定到要发送到数据库的预准备语句。
                        </p>
                        <p>以下示例说明如何使用预准备语句运行向<code class="codeph">EMPLOYEES</code>表添加两行的<code class="codeph">INSERT</code>操作。
                        </p><pre class="oac_no_warn" dir="ltr">//准备在EMPLOYEES表中插入新名称PreparedStatement pstmt = null;尝试{pstmt = conn.prepareStatement（“插入EMPLOYEES（EMPLOYEE_ID，FIRST_NAME）”值（？，？）“）; //添加LESLIE作为员工编号1500 pstmt.setInt（1,1500）; //第一个？适用于EMPLOYEE_ID pstmt.setString（2，“LESLIE”）; // 第二 ？适用于FIRST_NAME //插入pstmt.execute（）; //将MARSHA添加为员工编号507 pstmt.setInt（1,507）; // 首先 ？适用于EMPLOYEE_ID pstmt.setString（2，“MARSHA”）; // 第二 ？适用于FIRST_NAME //插入pstmt.execute（）; } finally {if（pstmt！= null）//关闭语句pstmt.close（）; }</pre></div>
                     <!-- class="section" -->
                     <div class="section">
                        <p class="subhead3" id="GUID-6AC53BFD-6723-4D51-BEF1-B4441E6031DD__GUID-E27F744A-39F2-4574-983A-1623011CCFEB">DDL操作</p>
                     </div>
                     <!-- class="section" -->
                     <div class="section">
                        <p>要执行数据定义语言（DDL）操作，必须创建<code class="codeph">Statement</code>对象。以下示例显示如何在数据库中创建表：</p><pre class="oac_no_warn" dir="ltr">//使用EMPLOYEE_ID和FIRST_NAME字符串查询列创建表EMPLOYEES;语句stmt = null; try {query =“create table EMPLOYEES”+“（EMPLOYEE_ID int，”+“FIRST_NAME varchar（50））”; stmt = conn.createStatement（）; stmt.executeUpdate（查询）; } finally {//关闭Statement对象stmt.close（）; }</pre><div class="infoboxnote" id="GUID-6AC53BFD-6723-4D51-BEF1-B4441E6031DD__GUID-A47A6E5F-2B6D-4BE9-8A05-E499DDDB9F43">
                           <p class="notep1">注意：</p>
                           <p>您还可以使用<code class="codeph">PreparedStatement</code>对象来执行DDL操作。但是，您不应该使用<code class="codeph">PreparedStatement</code>对象，因为这样的对象的有用部分是它可以有参数而DDL操作没有任何参数。
                           </p>
                           <p>此外，由于数据库限制，如果您使用<code class="codeph">PreparedStatement</code>对象进行DDL操作，那么它仅在第一次执行时有效。因此，您应该只使用<code class="codeph">Statement</code>对象进行DDL操作。
                           </p>
                        </div>
                        <p>以下示例显示如何在重新执行之前准备DDL语句：</p><pre class="oac_no_warn" dir="ltr">//语句stmt = null; PreparedStatement pstmt = null;尝试{pstmt = conn.prepareStatement（“插入EMPLOYEES（EMPLOYEE_ID，FIRST_NAME）”值（？，？）“）; stmt = conn.createStatement（”truncate table EMPLOYEES“）; //将LESLIE添加为员工编号1500 pstmt.setInt（1,1500）; //第一个？适用于EMPLOYEE_ID pstmt.setString（2，“LESLIE”）; // 第二 ？适用于FIRST_NAME pstmt.execute（）; stmt.executeUpdate（）; //将MARSHA添加为员工编号507 pstmt.setInt（1,507）; // 首先 ？适用于EMPLOYEE_ID pstmt.setString（2，“MARSHA”）; // 第二 ？适用于FIRST_NAME pstmt.execute（）; stmt.executeUpdate（）; } finally {if（pstmt！= null）//关闭语句pstmt.close（）; }</pre></div>
                     <!-- class="section" -->
                  </div>
                  <div>
                     <div class="relinfo">
                        <p><strong>相关话题</strong></p>
                        <ul>
                           <li><a href="accessing-and-manipulating-Oracle-data.html#GUID-018F8001-45D2-4368-82F2-3B227C1341D9">setObject和setOracleObject方法</a></li>
                           <li><a href="accessing-and-manipulating-Oracle-data.html#GUID-B34BA42E-A004-4A63-8252-96405D7110A6">其他setXXX方法</a></li>
                        </ul>
                     </div>
                  </div>
                  
               </div><a id="JJDBC29017"></a><a id="JJDBC28071"></a><div class="props_rev_3"><a id="GUID-96D6787D-71A6-4282-B17E-0951DED3DEF9" name="GUID-96D6787D-71A6-4282-B17E-0951DED3DEF9"></a><h4 id="JJDBC-GUID-96D6787D-71A6-4282-B17E-0951DED3DEF9" class="sect4"><span class="enumeration_section">2.3.8</span>关于提交更改</h4>
                  <div>
                     <p>默认情况下，数据操作语言（DML）操作在运行后立即自动提交。这被称为<a id="d16478e1522" class="indexterm-anchor"></a>自动提交模式。如果启用了自动提交模式，并且您对连接对象使用<code class="codeph">commit</code>或<code class="codeph">rollback</code>方法执行<code class="codeph">COMMIT</code>或<code class="codeph">ROLLBACK</code>操作，则会收到以下错误消息：</p>
                     <div class="tblformal" id="GUID-96D6787D-71A6-4282-B17E-0951DED3DEF9__CIAEFJEH">
                        <p class="titleintable">表2-2自动提交模式为ON时执行的操作的错误消息</p>
                        <table cellpadding="4" cellspacing="0" class="Formal" title="自动提交模式为ON时执行操作的错误消息" width="100%" border="1" summary="Error Messages" frame="hsides" rules="rows">
                           <thead>
                              <tr align="left" valign="top">
                                 <th align="left" valign="bottom" width="31%" id="d16478e1547">手术</th>
                                 <th align="left" valign="bottom" width="69%" id="d16478e1550">错误消息</th>
                              </tr>
                           </thead>
                           <tbody>
                              <tr align="left" valign="top">
                                 <td align="left" valign="top" width="31%" id="d16478e1555" headers="d16478e1547 ">
                                    <p><code class="codeph">承诺</code></p>
                                 </td>
                                 <td align="left" valign="top" width="69%" headers="d16478e1555 d16478e1550 ">
                                    <p><code class="codeph">无法提交自动提交设置</code></p>
                                 </td>
                              </tr>
                              <tr align="left" valign="top">
                                 <td align="left" valign="top" width="31%" id="d16478e1564" headers="d16478e1547 ">
                                    <p><code class="codeph">ROLLBACK</code></p>
                                 </td>
                                 <td align="left" valign="top" width="69%" headers="d16478e1564 d16478e1550 ">
                                    <p><code class="codeph">无法使用自动提交设置回滚</code></p>
                                 </td>
                              </tr>
                           </tbody>
                        </table>
                     </div>
                     <!-- class="inftblhruleinformal" -->
                     <p>如果在<code class="codeph">COMMIT</code>或<code class="codeph">ROLLBACK</code>操作期间引发SQLException并使用上表中提到的错误消息，则检查连接的自动提交状态，因为在对具有自动提交的连接执行这些操作时会出现异常值设置为<code class="codeph">true</code> 。
                     </p>
                     <p>针对以下任何一种情况引发此异常：</p>
                     <ul style="list-style-type:disc">
                        <li>
                           <p>当自动提交状态设置为<code class="codeph">true</code>并调用<code class="codeph">commit</code>或<code class="codeph">rollback</code>方法时</p>
                        </li>
                        <li>
                           <p>如果未更改自动提交的默认状态，则调用<code class="codeph">commit</code>或<code class="codeph">rollback</code>方法</p>
                        </li>
                        <li>
                           <p>当<code class="codeph">COMMIT_ON_ACCEPT_CHANGES</code>属性的值为<code class="codeph">true</code>并且在对行集调用<code class="codeph">acceptChanges</code>方法之后调用<code class="codeph">commit</code>或<code class="codeph">rollback</code>方法时</p>
                        </li>
                     </ul>
                     <p>但是，您可以在<code class="codeph">Connection</code>对象上使用以下方法调用禁用自动提交模式：</p><pre class="oac_no_warn" dir="ltr">conn.setAutoCommit（假）;</pre><p>如果禁用自动提交模式，则必须使用<code class="codeph">Connection</code>对象上的相应方法调用手动提交或回滚更改：</p><pre class="oac_no_warn" dir="ltr">conn.commit（）;</pre><p>要么：</p><pre class="oac_no_warn" dir="ltr">conn.rollback（）;</pre><p><code class="codeph">COMMIT</code>或<code class="codeph">ROLLBACK</code>操作会影响自上次<code class="codeph">COMMIT</code>或<code class="codeph">ROLLBACK</code>以来运行的所有DML语句。</p>
                     <div class="infoboxnote" id="GUID-96D6787D-71A6-4282-B17E-0951DED3DEF9__GUID-9285F874-43CD-4B43-92ED-C6B14EDF1D75">
                        <p class="notep1">注意：</p>
                        <ul style="list-style-type:disc">
                           <li>
                              <p>如果禁用了自动提交模式，并且在未显式提交或回滚上次更改的情况下关闭连接，则会运行隐式<code class="codeph">COMMIT</code>操作。
                              </p>
                           </li>
                           <li>
                              <p>任何数据定义语言（DDL）操作总是会导致隐式<code class="codeph">COMMIT</code> 。如果禁用自动提交模式，则此隐式<code class="codeph">COMMIT</code>将提交尚未显式提交或回滚的任何挂起的DML操作。
                              </p>
                           </li>
                        </ul>
                     </div>
                  </div>
                  <div>
                     <div class="relinfo">
                        <p><strong>相关话题</strong></p>
                        <ul>
                           <li><a href="JDBC-coding-tips.html#GUID-0E566AD1-2283-40A0-AD28-0EFBEF99FC9B">禁用自动提交模式</a></li>
                        </ul>
                     </div>
                  </div>
                  <a id="JJDBC28072"></a><div class="props_rev_3"><a id="GUID-E495B0CC-B1FF-4B29-9AEB-10573165E6E7" name="GUID-E495B0CC-B1FF-4B29-9AEB-10573165E6E7"></a><h5 id="JJDBC-GUID-E495B0CC-B1FF-4B29-9AEB-10573165E6E7" class="sect5"><span class="enumeration_section">2.3.8.1</span>更改提交行为</h5>
                     <div>
                        <div class="section">
                           <p>当事务更新数据库时，它会生成与此更新对应的重做条目。Oracle数据库将此重做缓冲在内存中，直到事务完成。提交事务时，Log Writer（LGWR）进程会将提交的重做条目写入磁盘，以及事务中所有更改的累积重做条目。默认情况下，Oracle数据库会在调用返回到客户端之前将重做写入磁盘。此行为会在提交中引入延迟，因为应用程序必须等待重做条目保留在磁盘上。</p>
                           <p>如果您的应用程序需要非常高的事务吞吐量并且您愿意交换提交持久性以降低提交延迟，那么您可以根据应用程序的需要更改默认<code class="codeph">COMMIT</code>操作的行为。您可以使用以下选项更改<code class="codeph">COMMIT</code>操作的行为：</p>
                        </div>
                        <!-- class="section" -->
                        <div class="section">
                           <ul style="list-style-type:disc">
                              <li>
                                 <p><code class="codeph">等待</code></p>
                              </li>
                              <li>
                                 <p><code class="codeph">NOWAIT</code></p>
                              </li>
                              <li>
                                 <p><code class="codeph">WRITEBATCH</code></p>
                              </li>
                              <li>
                                 <p><code class="codeph">WRITEIMMED</code></p>
                              </li>
                           </ul>
                           <p>这些选项使您可以控制提交阶段的两个不同方面：</p>
                           <ul style="list-style-type:disc">
                              <li>
                                 <p><code class="codeph">COMMIT</code>调用是否应该等待服务器处理它。这是通过使用<code class="codeph">WAIT</code>或<code class="codeph">NOWAIT</code>选项实现的。
                                 </p>
                              </li>
                              <li>
                                 <p>Log Writer是否应该批量调用。这是通过使用<code class="codeph">WRITEIMMED</code>或<code class="codeph">WRITEBATCH</code>选项实现的。
                                 </p>
                              </li>
                           </ul>
                           <p>您还可以将不同的选项组合在一起。例如，如果您希望<code class="codeph">COMMIT</code>调用返回而不等待服务器处理它，并且还希望日志<code class="codeph">WRITEBATCH</code>以批处理方式处理提交，那么您可以一起使用<code class="codeph">NOWAIT</code>和<code class="codeph">WRITEBATCH</code>选项。例如：</p><pre class="oac_no_warn" dir="ltr">（（OracleConnection）conn）.commit（EnumSet.of（OracleConnection。CommitOption。WRITEBATCH，OracleConnection。CommitOption。NOWAIT））;</pre><div class="infoboxnote" id="GUID-E495B0CC-B1FF-4B29-9AEB-10573165E6E7__GUID-27EB6180-0AE1-4DBF-8532-4A13A03239E6">
                              <p class="notep1">注意：</p>
                              <p>你不能一起使用<code class="codeph">WAIT</code>和<code class="codeph">NOWAIT</code>选项，因为它们具有相反的含义。如果这样做，那么JDBC驱动程序将抛出异常。这同样适用于<code class="codeph">WRITEIMMED</code>和<code class="codeph">WRITEBATCH</code>选项。
                              </p>
                           </div>
                        </div>
                        <!-- class="section" -->
                     </div>
                  </div>
               </div><a id="JJDBC28073"></a><div class="props_rev_3"><a id="GUID-9CFCCC9C-8386-4427-AC34-DEE0575B58BB" name="GUID-9CFCCC9C-8386-4427-AC34-DEE0575B58BB"></a><h4 id="JJDBC-GUID-9CFCCC9C-8386-4427-AC34-DEE0575B58BB" class="sect4"><span class="enumeration_section">2.3.9</span>关闭连接</h4>
                  <div>
                     <div class="section">
                        <p>您<a id="d16478e1813" class="indexterm-anchor"></a>在执行所有必需的操作并且不再需要连接后，必须关闭与数据库的连接。您可以使用<code class="codeph">Connection</code>对象的<code class="codeph">close</code>方法<code class="codeph">close</code> <code class="codeph">Connection</code> ，如下所示：</p><pre class="oac_no_warn" dir="ltr">conn.close（）;</pre><div class="infoboxnote" id="GUID-9CFCCC9C-8386-4427-AC34-DEE0575B58BB__GUID-FDE80679-3A3E-49B7-8286-82571E45897D">
                           <p class="notep1">注意：</p>
                           <p>通常，您应该在<code class="codeph">finally</code>子句中放置<code class="codeph">close</code>语句。
                           </p>
                        </div>
                     </div>
                     <!-- class="section" -->
                  </div>
               </div>
            </div><a id="JJDBC28074"></a><div class="props_rev_3"><a id="GUID-D59CA273-203C-431A-BB27-D660ACBFE105" name="GUID-D59CA273-203C-431A-BB27-D660ACBFE105"></a><h3 id="JJDBC-GUID-D59CA273-203C-431A-BB27-D660ACBFE105" class="sect3"><span class="enumeration_section">2.4</span>示例：连接，查询和处理结果</h3>
               <div>
                  <div class="section">
                     <p>以下部分中的步骤如以下示例所示，该示例使用Oracle JDBC Thin驱动程序创建数据源，连接到数据库，创建<code class="codeph">Statement</code>对象，运行查询以及处理结果集。
                     </p>
                     <p>请注意，用于创建<code class="codeph">Statement</code>对象，运行查询，返回和处理<code class="codeph">ResultSet</code>对象以及关闭语句和连接的代码使用标准JDBC API。</p><pre class="oac_no_warn" dir="ltr">import java.sql。连接; import java.sql。ResultSet的; import java.sql。声明; import java.sql。的SQLException; import oracle.jdbc.pool。OracleDataSource; class JdbcTest {public static void main（String args []）抛出SQLException {OracleDataSource ods = null;连接conn = null;语句stmt = null; ResultSet rset = null; //创建DataSource并连接到本地数据库ods = new OracleDataSource（）; ods.setURL（ “JDBC：预言：瘦：@ //本地主机：5221 / ORCL”）; ods.setUser（ “HR”）; ods.setPassword（ “HR”）; conn = ods.getConnection（）; try {//查询员工姓名stmt = conn.createStatement（）; rset = stmt.executeQuery（“SELECT first_name FROM employees”）; //打印名称while（rset.next（））System.out.println（rset.getString（1））; } //最后关闭结果集，语句和连接{if（rset！= null）rset.close（）;如果（stmt是！= null）stmt.close（）;如果（参数conn！= null）conn.close（）; }}}</pre><p>如果要调整OCI驱动程序的代码，请使用以下代码替换对<code class="codeph">OracleDataSource.setURL</code>方法的调用：</p><pre class="oac_no_warn" dir="ltr">ods.setURL（ “JDBC：预言：OCI：@MyHostString”）;</pre><p>其中， <code class="codeph">MyHostString</code>是<code class="codeph">TNSNAMES.ORA</code>文件中的一个条目。
                     </p>
                  </div>
                  <!-- class="section" -->
               </div>
            </div><a id="JJDBC29019"></a><a id="JJDBC29018"></a><div class="props_rev_3"><a id="GUID-2796DCC2-29FF-4D65-852F-ABCA3AFCEE9C" name="GUID-2796DCC2-29FF-4D65-852F-ABCA3AFCEE9C"></a><h3 id="JJDBC-GUID-2796DCC2-29FF-4D65-852F-ABCA3AFCEE9C" class="sect3"><span class="enumeration_section">2.5</span>支持隐形列</h3>
               <div>
                  <p>从此版本开始，Oracle数据库支持不可见列。使用此功能，您可以以隐藏模式向表中添加列，并使其稍后可见。JDBC提供API来检索有关不可见列的信息。要获取有关列是否不可见的信息，您可以使用<a id="d16478e1913" class="indexterm-anchor"></a> <code class="codeph">oracle.jdbc.提供了<code class="codeph">isColumnInvisible</code>方法<code class="codeph">oracle.jdbc.OracleResultSetMetaData</code>接口的方式如下：</p>
                  <div class="section">
                     <p class="subhead2" id="GUID-2796DCC2-29FF-4D65-852F-ABCA3AFCEE9C__GUID-69FAFA33-8B49-4116-8D15-CD9AAAB4FA96">例</p>
                  </div>
                  <!-- class="section" -->
                  <div class="section"><pre class="oac_no_warn" dir="ltr">...Connection conn = DriverManager.getConnection（jdbcURL，user，password）;语句stmt = conn.createStatement（）; stmt.executeQuery（“create table hiddenColsTable（a varchar（20），b int invisible）”）; stmt.executeUpdate（“插入hiddenColsTable（a，b）值（'somedata'，1）”）; stmt.executeUpdate（“插入hiddenColsTable（a，b）值（'newdata'，2）”）; System.out.println（“Invisible columns information”）;尝试{ResultSet rset = stmt.executeQuery（“SELECT a，b FROM hiddenColsTable”）; OracleResultSetMetaData rsmd =（OracleResultSetMetaData）rset.getMetaData（）; while（rset.next（））{System.out.println（“column1 value：”+ rset.getString（1））; System.out.println（“可见性：”+ rsmd.isColumnInvisible（1））; System.out.println（“column2 value：”+ rset.getInt（2））; System.out.println（“可见性：”+ rsmd.isColumnInvisible（2））; catch（Exception ex）{System.out.println（“Exception：”+ ex）; ex.printStackTrace（）; }</pre><p>或者，您也可以使用<a id="d16478e1929" class="indexterm-anchor"></a> <code class="codeph">oracle.jdbc.提供了<code class="codeph">getColumns</code>方法<code class="codeph">oracle.jdbc.OracleDatabaseMetaData</code>类，用于检索有关不可见列的信息。
                     </p>
                  </div>
                  <!-- class="section" -->
                  <div class="section">
                     <p class="subhead2" id="GUID-2796DCC2-29FF-4D65-852F-ABCA3AFCEE9C__GUID-7769CA6D-8D1C-499E-933A-D22B9D930009">例</p>
                  </div>
                  <!-- class="section" -->
                  <div class="section"><pre class="oac_no_warn" dir="ltr">...Connection conn = DriverManager.getConnection（jdbcURL，user，password）;语句stmt = conn.createStatement（）; stmt.executeQuery（“create table hiddenColsTable（a varchar（20），b int invisible）”）; stmt.executeUpdate（“插入hiddenColsTable（a，b）值（'somedata'，1）”）; stmt.executeUpdate（“插入hiddenColsTable（a，b）值（'newdata'，2）”）; System.out.println（“具有不可见列的表的getColumns”）;尝试{DatabaseMetaData dbmd = conn.getMetaData（）; ResultSet rs = dbmd.getColumns（null，“HR”，“hiddenColsTable”，null）; OracleResultSetMetaData rsmd =（OracleResultSetMetaData）rs.getMetaData（）; int colCount = rsmd.getColumnCount（）; System.out.println（“colCount：”+ colCount）; String [] columnNames = new String [colCount]; for（int i = 0; i &lt;colCount; ++ i）{columnNames [i] = rsmd.getColumnName（i + 1）; } while（rs.next（））{for（int i = 0; i &lt;colCount; ++ i）System.out.println（columnNames [i] +“：”+ rs.getString（columnNames [i]）） ; catch（Exception ex）{System.out.println（“Exception：”+ ex）; ex.printStackTrace（）; }</pre><div class="infoboxnote" id="GUID-2796DCC2-29FF-4D65-852F-ABCA3AFCEE9C__GUID-5CB8882C-77D8-4685-94D5-4030F67921CE">
                        <p class="notep1">注意：</p>
                        <p>服务器端内部驱动程序<code class="codeph">kprb</code>不支持获取有关不可见列的信息。
                        </p>
                     </div>
                  </div>
                  <!-- class="section" -->
               </div>
            </div>
            <div class="sect2"><a id="GUID-F30B1931-7755-4973-A113-DB6D25C85937" name="GUID-F30B1931-7755-4973-A113-DB6D25C85937"></a><h3 id="JJDBC-GUID-F30B1931-7755-4973-A113-DB6D25C85937" class="sect3"><span class="enumeration_section">2.6</span>支持验证JSON数据</h3>
               <div>
                  <p></p>
                  <p>从Oracle Database Release 18c开始，JDBC驱动程序可以验证<code class="codeph">ResultSet</code>返回的列是否为JSON列。要获取有关列是否为JSON的信息，可以使用<code class="codeph">oracle.jdbc.提供的<code class="codeph">isColumnJSON</code>方法<code class="codeph">oracle.jdbc.OracleResultSetMetaData</code>接口的方式如下：</p>
                  <div class="example" id="GUID-F30B1931-7755-4973-A113-DB6D25C85937__GUID-70331B81-604A-47EE-A315-421B5DCD231D">
                     <p class="titleinexample">例2-1示例</p><pre class="pre codeblock"><code>...public void test（Connection conn）抛出异常{try {show（“tkpjb26776242  -  start”）; CREATETABLE（conn）;在String sql =“SELECT col1，col2，col3，col4，col5，col6，col7，col8 FROM tkpjb26776242_tab”;语句stmt = conn.createStatement（）; ResultSet rs = stmt.executeQuery（sql）; ResultSetMetaData rsmd = rs.getMetaData（）; OracleResultSetMetaData orsmd =（OracleResultSetMetaData）rsmd; int colCnt = orsmd.getColumnCount（）; show（“Table has”+ colCnt +“columns。”）; for（int i = 1; i &lt;= colCnt; i ++）{String columnName = orsmd.getColumnName（i）; String typeName = orsmd.getColumnTypeName（i）; boolean invisible = orsmd.isColumnInvisible（i）; boolean json = orsmd.isColumnJSON（i）; show（columnName +“”+ typeName +（不可见？“不可见”：“”）+（json？“JSON”：“”））; } rs.close（）; stmt.close（）; show（“tkpjb26776242  -  end”）; } finally {dropTable（conn）; private void createTable（Connection conn）throws Exception {String sql =“create table tkpjb26776242_tab（”+“col1 clob，”+“col2 clob，”+“col3 clob INVISIBLE，”+“col4 clob INVISIBLE，”+“col5 varchar2（200），“+”col6 varchar2（200），“+”col7 varchar2（200）INVISIBLE，“+”col8 varchar2（200）INVISIBLE，“+”check（col2 IS JSON），“+”check（col4 IS JSON），“+”检查（col6 IS JSON），“+”检查（col8 IS JSON））“; Util.doSQL（conn，sql）; private void dropTable（Connection conn）throws Exception {String sql =“drop table tkpjb26776242_tab”; Util.trySQL（conn，sql）; } ...</code></pre></div>
                  <!-- class="example" -->
               </div>
            </div><a id="JJDBC29020"></a><a id="JJDBC29005"></a><div class="props_rev_3"><a id="GUID-FA6FA05D-CE5C-4A03-B70E-8DD9F8F5DD92" name="GUID-FA6FA05D-CE5C-4A03-B70E-8DD9F8F5DD92"></a><h3 id="JJDBC-GUID-FA6FA05D-CE5C-4A03-B70E-8DD9F8F5DD92" class="sect3"><span class="enumeration_section">2.7</span>支持隐含结果</h3>
               <div>
                  <p>从此版本开始，Oracle数据库支持在存储过程中执行的SQL语句的结果隐式返回到客户端应用程序，而无需显式使用<code class="codeph">REF CURSOR</code> 。您可以使用以下方法检索和处理PL / SQL过程或块返回的隐式结果：</p>
                  <div class="tblformal" id="GUID-FA6FA05D-CE5C-4A03-B70E-8DD9F8F5DD92__GUID-82DB4879-A1BF-4A0C-8BE7-47473B5C0FD5">
                     <table cellpadding="4" cellspacing="0" class="Formal" title="" width="100%" border="1" summary="This table describes the methods to work with implicit cursors" frame="hsides" rules="rows">
                        <thead>
                           <tr align="left" valign="top">
                              <th align="left" valign="bottom" width="37%" id="d16478e2024">方法</th>
                              <th align="left" valign="bottom" width="63%" id="d16478e2027">描述</th>
                           </tr>
                        </thead>
                        <tbody>
                           <tr align="left" valign="top">
                              <td align="left" valign="top" width="37%" id="d16478e2032" headers="d16478e2024 ">
                                 <p><code class="codeph">使用getMoreResults</code></p>
                              </td>
                              <td align="left" valign="top" width="63%" headers="d16478e2032 d16478e2027 ">
                                 <p>检查结果集中是否有更多可用结果</p>
                              </td>
                           </tr>
                           <tr align="left" valign="top">
                              <td align="left" valign="top" width="37%" id="d16478e2040" headers="d16478e2024 ">
                                 <p><a id="d16478e2042" class="indexterm-anchor"></a><code class="codeph">getMoreResults(int)</code></p>
                              </td>
                              <td align="left" valign="top" width="63%" headers="d16478e2040 d16478e2027 ">
                                 <p>检查结果集中是否有更多可用结果，如重载方法。此方法接受可以具有以下值之一的<code class="codeph">int</code>参数：</p>
                                 <ul style="list-style-type:disc">
                                    <li>
                                       <p><code class="codeph">KEEP_CURRENT_RESULT</code></p>
                                    </li>
                                    <li>
                                       <p><code class="codeph">CLOSE_ALL_RESULTS</code></p>
                                    </li>
                                    <li>
                                       <p><code class="codeph">CLOSE_CURRENT_RESULT</code></p>
                                    </li>
                                 </ul>
                              </td>
                           </tr>
                           <tr align="left" valign="top">
                              <td align="left" valign="top" width="37%" id="d16478e2066" headers="d16478e2024 ">
                                 <p><code class="codeph">的getResultSet</code></p>
                              </td>
                              <td align="left" valign="top" width="63%" headers="d16478e2066 d16478e2027 ">
                                 <p>迭代地从执行的PL / SQL语句中检索每个隐式结果</p>
                              </td>
                           </tr>
                        </tbody>
                     </table>
                  </div>
                  <!-- class="inftblhruleinformal" -->
                  <div class="infoboxnote" id="GUID-FA6FA05D-CE5C-4A03-B70E-8DD9F8F5DD92__GUID-24BB0E2F-FB00-48BA-8F76-7FEC69C67EA3">
                     <p class="notep1">注意：</p>
                     <ul style="list-style-type:disc">
                        <li>
                           <p>服务器端内部驱动程序<code class="codeph">kprb</code>不支持获取有关隐式结果的信息。
                           </p>
                        </li>
                        <li>
                           <p>只能隐式返回SELECT查询。</p>
                        </li>
                        <li>
                           <p>应用程序按顺序检索每个结果集，但可以从任何结果集中获取行，而与序列无关。</p>
                        </li>
                     </ul>
                  </div>
                  <p>假设您有一个名为<code class="codeph">foo</code>的过程，如下所示：</p><pre class="oac_no_warn" dir="ltr">创建过程foo为c1 sys_refcursor; c2 sys_refcursor;从hr.employees开始打开c1 for select *; dbms_sql.return_result（C1）; - 返回客户端 - 从hr.departments打开另一个游标打开c2 for select *; dbms_sql.return_result（c2）; - 回到客户端;</pre><p>以下代码片段演示了如何使用<code class="codeph">getMoreResults</code>方法检索PL / SQL过程返回的隐式结果：</p>
                  <div class="section">
                     <p class="subhead2" id="GUID-FA6FA05D-CE5C-4A03-B70E-8DD9F8F5DD92__GUID-C3C6C824-9CDD-4B8F-B43E-D4C21175281A">例1</p>
                  </div>
                  <!-- class="section" -->
                  <div class="section"><pre class="oac_no_warn" dir="ltr">String sql =“begin foo; end;”; ...Connection conn = DriverManager.getConnection（jdbcURL，user，password）;尝试{Statement stmt = conn.createStatement（）; stmt.executeQuery（sql）; while（stmt.getMoreResults（））{ResultSet rs = stmt.getResultSet（）;的System.out.println（ “结果集”）; while（rs.next（））{/ * get results * /}}}</pre><p>假设您有另一个名为<code class="codeph">foo</code>过程，如下所示：</p><pre class="oac_no_warn" dir="ltr">创建或替换过程foo asc1 sys_refcursor; c2 sys_refcursor; c3 sys_refcursor;为'select * from hr.employees'开始打开c1; dbms_sql.return_result（c1）;  - 'select * from hr.departments'的游标2打开c2; dbms_sql.return_result（c2）;  - 游标3打开c3，用于'select first_name from hr.employees'; dbms_sql.return_result（c3）;结束;</pre><p>以下代码片段演示了如何使用<code class="codeph">getMoreResults(int)</code>方法检索PL / SQL过程返回的隐式结果：</p>
                  </div>
                  <!-- class="section" -->
                  <div class="section">
                     <p class="subhead2" id="GUID-FA6FA05D-CE5C-4A03-B70E-8DD9F8F5DD92__GUID-54EE9DA5-AEDB-4019-BD67-E2B4C78E280D">例2</p>
                  </div>
                  <!-- class="section" -->
                  <div class="section"><pre class="oac_no_warn" dir="ltr">String sql =“begin foo; end;”; ...Connection conn = DriverManager.getConnection（jdbcURL， <span class="italic">user</span> ， <span class="italic">password</span> ）;尝试{Statement stmt = conn.createStatement（）; stmt.executeQuery（sql）; ResultSet rs = null; boolean retval = stmt.getMoreResults（Statement。KEEP_CURRENT_RESULT））if（retval）{rs = stmt.getResultSet（）;的System.out.println（ “结果集”）; while（rs.next（））{/ * get results * /}} / *关闭打开结果* / retval = stmt.getMoreResults（Statement。CLOSE_ALL_RESULTS）; if（retval）{System.out.println（“More ResultSet available”）; rs = stmt.getResultSet（）;的System.out.println（ “结果集”）; while（rs.next（））{/ * get results * /}} / * close current result set * / retval = stmt.getMoreResults（Statement。CLOSE_CURRENT_RESULT）; if（retval）{System.out.println（“More ResultSet available”）; rs = stmt.getResultSet（）; while（rs.next（））{/ * get Results * /}}}</pre></div>
                  <!-- class="section" -->
               </div>
            </div>
            <div class="sect2"><a id="GUID-6AFB71F0-EFA9-43A0-AF96-03E6FB2F3521" name="GUID-6AFB71F0-EFA9-43A0-AF96-03E6FB2F3521"></a><h3 id="JJDBC-GUID-6AFB71F0-EFA9-43A0-AF96-03E6FB2F3521" class="sect3"><span class="enumeration_section">2.8</span>支持轻量级连接验证</h3>
               <div>
                  <p></p>
                  <p>从Oracle Database Release 18c开始，JDBC Thin驱动程序支持轻量级连接验证。轻量级连接验证使JDBC应用程序能够通过发送不需要往返数据库的零长度NS数据包来验证连接有效性。对于Oracle数据库的早期版本，当您调用<code class="codeph">isValid(timeout)</code>方法来测试连接的有效性时，Oracle JDBC驱动程序使用乒乓协议，这是一项昂贵的操作，因为它完全往返于数据库。在Oracle数据库版本18c中， <code class="codeph">isValid(timeout)</code>方法将空数据包发送到数据库，而不是等待接收回来。因此，连接验证更快，从而提高了应用程序性能。
                  </p>
                  <p>默认情况下禁用轻量级连接验证。要启用此功能，必须将<code class="codeph">oracle.jdbc.defaultConnectionValidation</code>连接属性值设置为<code class="codeph">SOCKET</code> 。如果设置了此属性，那么当您调用<code class="codeph">isValid(timeout)</code>方法时，JDBC驱动程序将执行轻量级连接验证。
                  </p>
                  <div class="infoboxnote" id="GUID-6AFB71F0-EFA9-43A0-AF96-03E6FB2F3521__GUID-E9D44968-9A34-4AC0-93B4-7CA185BEBEC3">
                     <p class="notep1">注意：</p>
                     <ul style="list-style-type:disc">
                        <li>
                           <p>轻量级连接验证仅检查底层套接字运行状况。当<code class="codeph">isValid(timeout)</code>方法返回<code class="codeph">true</code> ，即，如果连接被称为有效，则此验证仅保证服务器不可到达（死套接字）。它不提供有关服务器进程的任何状态，例如它们是否正在运行。但是，默认情况下，即未启用轻量级连接验证时， <code class="codeph">isValid(timeout)</code>方法会检查客户端与服务器之间的网络是否完好无损。
                           </p>
                        </li>
                        <li>
                           <p>只有JDBC Thin驱动程序支持此功能。</p>
                        </li>
                     </ul>
                  </div>
                  <p><span class="bold">用于轻量级连接验证的新API</span></p>
                  <ul style="list-style-type:disc">
                     <li>
                        <p><code class="codeph">oracle.jdbc.defaultConnectionValidation</code></p>
                        <p>此连接属性指定连接验证的级别。此属性的可能值包括： <code class="codeph">NONE</code> ， <code class="codeph">LOCAL</code> ， <code class="codeph">SOCKET</code> ， <code class="codeph">NETWORK</code> ， <code class="codeph">SERVER</code>和<code class="codeph">COMPLETE</code> 。这些值区分大小写，并且设置除这些值之外的任何值都会引发异常。<code class="codeph">NETWORK</code>是默认值。</p>
                     </li>
                     <li>
                        <p><code class="codeph">public boolean isValid（ConnectionValidation validation_level，int timeout）抛出SQLException</code></p>
                        <p>现有的<code class="codeph">isValid(timeout)</code>方法的新变体接受两个参数：验证级别（ <code class="codeph">validation_level</code> ）和<code class="codeph">timeout</code> 。第一个参数指定连接验证的级别。
                        </p>
                     </li>
                  </ul>
                  <div class="example" id="GUID-6AFB71F0-EFA9-43A0-AF96-03E6FB2F3521__GUID-8FB906BE-3FCC-47A3-801C-C89390E0E41F">
                     <p class="titleinexample">示例2-2轻量级连接验证示例</p>
                     <p>以下代码片段演示了如何实现轻量级连接机制：</p><pre class="pre codeblock"><code>...OracleDataSource ods = new OracleDataSource（）; ods.setURL（URL）; ods.setUser（用户）; ods.setPassword（密码）; Connection conn = ods.getConnection（）; try {boolean isValid =（（OracleConnection）conn）。的isValid（ConnectionValidation。插座，超时）; System.out.println（“Connection isValid =”+ isValid）; } catch（Exception ex）{System.out.println（“Exception：”+ ex）; ex.printStackTrace（）; } ......</code></pre></div>
                  <!-- class="example" -->
               </div>
            </div>
            <div class="sect2"><a id="GUID-D5BB4E1F-59FD-4C5E-876C-71420F2DAE9B" name="GUID-D5BB4E1F-59FD-4C5E-876C-71420F2DAE9B"></a><h3 id="JJDBC-GUID-D5BB4E1F-59FD-4C5E-876C-71420F2DAE9B" class="sect3"><span class="enumeration_section">2.9</span>支持数据库节点的Deprioritization</h3>
               <div>
                  <p></p>
                  <div class="section">
                     <p>从Oracle Database 12 <span class="italic">c</span>第2版（12.2.0.1）开始，JDBC驱动程序支持对数据库节点进行优先级排序。当节点发生故障时，JDBC会在接下来的10分钟内对其进行优先级排序，这是默认的到期时间。例如，如果有三个节点A，B，C，并且节点A已关闭，则首先从节点B和C分配连接，然后从节点A分配连接。在默认的到期时间之后，节点A不再被优先级排序，也就是说，在可用性的基础上从所有三个节点分配连接。此外，在默认到期时间内，如果对节点A的连接尝试成功，则节点A不再被视为去优先级节点。您可以使用<code class="codeph">oracle.net.指定<code class="codeph">oracle.net.的默认到期时间<code class="codeph">oracle.net.DOWN_HOSTS_TIMEOUT</code>系统属性。
                     </p>
                     <p>例如，在以下URL中， <code class="codeph">scan_listener0</code>在检索其IP地址后配置了<code class="codeph">ip1</code> ， <code class="codeph">ip2</code>和<code class="codeph">ip3</code> IP地址。现在，如果<code class="codeph">ip1</code>被优先级排序，那么尝试IP地址的顺序将是<code class="codeph">ip2</code> ， <code class="codeph">ip3</code> ，然后是<code class="codeph">ip1</code> 。如果所有IP地址都不可用，则在尝试<code class="codeph">node_1</code>和<code class="codeph">node_2</code>之后，最后尝试整个主机。
                     </p>
                  </div>
                  <!-- class="section" -->
                  <div class="example" id="GUID-D5BB4E1F-59FD-4C5E-876C-71420F2DAE9B__GUID-A9F1321A-23A2-44C1-8CAC-262247CDFABF"><pre class="pre codeblock"><code>（DESCRIPTION_LIST =（DESCRIPTION =（ADDRESS_LIST =（ADDRESS =（PROTOCOL = tcp）（HOST = scan_listener0）（PORT = 1521））（ADDRESS =（PROTOCOL = tcp）（HOST = node_1）（PORT = 1528））（ADDRESS = （PROTOCOL = sdp）（HOST = node_2）（PORT = 1527）））（ADDRESS_LIST =（ADDRESS =（PROTOCOL = tcp）（HOST = node_3）（PORT = 1528）））（CONNECT_DATA =（SERVICE_NAME = cdb3））） （DESCRIPTION =（ADDRESS =（PROTOCOL = tcp）（HOST = node_0）（PORT = 1528））（CONNECT_DATA =（SERVICE_NAME = cdb3））））</code></pre></div>
                  <!-- class="example" -->
               </div>
            </div>
            <div class="sect2"><a id="GUID-65A18AD5-04DE-4EE0-8069-4F27449AC5B6" name="GUID-65A18AD5-04DE-4EE0-8069-4F27449AC5B6"></a><h3 id="JJDBC-GUID-65A18AD5-04DE-4EE0-8069-4F27449AC5B6" class="sect3"><span class="enumeration_section">2.10</span>在流量控制器模式下支持Oracle Connection Manager</h3>
               <div>
                  <p></p>
                  <p>Oracle Database Release 18c JDBC驱动程序支持Traffic Director模式下的Oracle Connection Manager，它是数据库客户端和数据库实例之间的代理。JDBC客户端可以在流量控制器模式下连接到Oracle连接管理器，流量控制器模式又连接到目标Oracle数据库。从客户端发送的双任务公共（TTC）消息由Oracle Connection Manager在流量控制器模式下截获。它解析传入的TTC消息并将请求中继到适当的目标数据库。收到响应后，流量控制器模式下的Oracle连接管理器会通过TTC响应将结果从目标数据库传输回客户端。</p>
                  <p>下图说明了Traffic Director模式下Oracle Connection Manager的体系结构：</p>
                  <div class="figure" id="GUID-65A18AD5-04DE-4EE0-8069-4F27449AC5B6__ORACLECONNECTIONMANAGERINTRAFFICDIR-54E999C1">
                     <p class="titleinfigure">图2-1流量控制器模式下Oracle Connection Manager的体系结构</p><img src="img/cmantraffdrmode.png" alt="下面描述图2-1" title="下面描述图2-1" longdesc="img_text/cmantraffdrmode.html"><br><a href="img_text/cmantraffdrmode.html">“图2-1流量控制器模式下Oracle Connection Manager的体系结构”的说明</a></div>
                  <!-- class="figure" -->
                  <div class="infoboxnotealso" id="GUID-65A18AD5-04DE-4EE0-8069-4F27449AC5B6__GUID-42A50B7D-8A5B-4275-8725-38C3E0DFE5ED">
                     <p class="notep1">也可以看看：</p>
                     <ul style="list-style-type:disc">
                        <li>
                           <p>有关配置<code class="codeph">cman.ora</code>文件以在Traffic Director模式下设置Oracle Connection Manager的详细信息，请<code class="codeph">cman.ora</code> <a href="../netag/configuring-oracle-connection-manager.html#NETAG-GUID-3917FC5D-4B23-4752-85BA-39A88C4D13F8" target="_blank"><span><cite>“Oracle数据库网络服务管理员指南”</cite></span></a></p>
                        </li>
                        <li>
                           <p><a href="../netrf/oracle-connection-manager-parameters.html#NETRF-GUID-E52E7D07-FD9C-4B21-9EEA-65D7B0AB453F" target="_blank"><span><cite>Oracle Database Net Services参考</cite></span></a> ，以获取有关Traffic Director模式参数中的Oracle Connection Manager的更多信息</p>
                        </li>
                     </ul>
                  </div>
               </div>
               <div class="sect3"><a id="GUID-C003C202-59A7-46D9-A044-0B6E70F0327B" name="GUID-C003C202-59A7-46D9-A044-0B6E70F0327B"></a><h4 id="JJDBC-GUID-C003C202-59A7-46D9-A044-0B6E70F0327B" class="sect4"><span class="enumeration_section">2.10.1</span>在流量控制器模式下运行Oracle Connection Manager的模式</h4>
                  <div>
                     <p></p>
                     <p>您可以在以下模式下以流量控制器模式运行Oracle Connection Manager：</p>
                     <ul style="list-style-type:disc">
                        <li>
                           <p><span class="bold">池化连接模式</span></p>
                           <p>池化连接模式使用称为代理驻留连接池的新功能，该功能是数据库驻留连接池的代理启用模式。代理驻留连接池减少了数据库上的连接负载，因为它通过较少数量的数据库连接多路复用大量客户端连接。使用Oracle Database 12 <span class="italic">c</span>第1版（12.1）JDBC驱动程序及更高版本的任何应用程序都可以使用此连接模式。
                           </p>
                           <div class="infoboxnote" id="GUID-C003C202-59A7-46D9-A044-0B6E70F0327B__GUID-C3BFC3CC-203D-469A-87B9-A101FA99BDFF">
                              <p class="notep1">注意：</p>
                              <p>此功能最适用于使用DRCP感知连接池的客户端。</p>
                           </div>
                        </li>
                        <li>
                           <p><span class="bold">非池化或专用连接模式</span></p>
                           <p>您可以将Nonpoled或专用连接模式与使用Oracle Database <span class="italic">11g</span>第2版（11.2.0.4）JDBC驱动程序及更高版本的应用程序一起使用。但是，在此模式下，某些功能（如连接多路复用）不可用。
                           </p>
                        </li>
                     </ul>
                  </div>
                  <div>
                     <div class="relinfo">
                        <p><strong>相关话题</strong></p>
                        <ul>
                           <li><a href="database-resident-connection-pooling.html#GUID-8B2DD8CE-5E6A-4D15-8997-D3261F137D8E">数据库驻留连接池概述</a></li>
                        </ul>
                     </div>
                     <div class="infoboxnotealso" id="GUID-C003C202-59A7-46D9-A044-0B6E70F0327B__GUID-3B394EC2-520C-419B-B35E-211B57D56F5B">
                        <p class="notep1">也可以看看：</p>
                        <ul style="list-style-type:disc">
                           <li>
                              <p><a href="../admin/managing-processes.html#ADMIN-GUID-E0032017-03B1-4F14-AF9B-BCC87C982DA8" target="_blank">数据库管理指南</a></p>
                           </li>
                           <li>
                              <p><a href="../jjucp/intro.html#JJUCP-GUID-F9DE0E14-C0D9-40E7-99A3-AC207CE9DF14" target="_blank">通用连接池开发人员指南</a></p>
                           </li>
                        </ul>
                     </div>
                  </div>
                  
               </div>
               <div class="sect3"><a id="GUID-C8DDB1C4-7855-40F1-921B-40BB43B2247F" name="GUID-C8DDB1C4-7855-40F1-921B-40BB43B2247F"></a><h4 id="JJDBC-GUID-C8DDB1C4-7855-40F1-921B-40BB43B2247F" class="sect4"><span class="enumeration_section">2.10.2</span> Oracle Director Manager在Traffic Director模式下的优点</h4>
                  <div>
                     <p></p>
                     <p>流量控制器模式中的Oracle Connection Manager具有以下优点：</p>
                     <ul style="list-style-type:disc">
                        <li>
                           <div class="p">透明的性能增强和连接多路复用，包括：<ul style="list-style-type:disc">
                                 <li>
                                    <p>对所有操作模式自动启用语句高速缓存，行预取和结果集高速缓存。</p>
                                 </li>
                                 <li>
                                    <p>使用代理驻留连接池（PRCP）的数据库会话多路复用（仅池化模式），其中PRCP是数据库驻留连接池（DRCP）的代理模式。应用程序在Traffic Director模式下的Oracle Connection Manager与数据库之间获得透明的连接时负载平衡和运行时负载平衡。</p>
                                 </li>
                                 <li>
                                    <p>对于Traffic Director模式实例中的多个Oracle Connection Manager，应用程序通过客户端连接时负载平衡或负载均衡器（BIG-IP，NGINX等）获得更高的可扩展性</p>
                                 </li>
                              </ul>
                           </div>
                        </li>
                        <li>
                           <div class="p">零应用程序停机时间<ul style="list-style-type:disc">
                                 <li>
                                    <div class="p">计划数据库维护或可插拔数据库（PDB）重定位<ul style="list-style-type:disc">
                                          <li>
                                             <p>合并模式</p>
                                             <p>流量控制器模式中的Oracle Connection Manager响应Oracle Notification Service（ONS）事件以计划中断和重定向工作。请求完成后，在流量控制器模式下，Oracle Connection Manager上的池中的连接将耗尽。Oracle Database <span class="italic">11g第</span> 2版（11.2.0.4）及更高版本支持服务重定位。
                                             </p>
                                             <p>对于PDB重定位，流量控制器模式下的Oracle连接管理器会在PDB重新定位时响应带内通知，即使未配置ONS时也是如此（对于Oracle数据库版本18c及更高版本的服务器）</p>
                                          </li>
                                          <li>
                                             <p>非汇集或专用模式</p>
                                             <div class="p">当客户端没有请求边界信息时，流量控制器模式中的Oracle连接管理器支持许多应用程序的计划中断（只要在请求或事务边界上只需要保留简单的会话状态和游标状态）。这种支持包括：<ul style="list-style-type:disc">
                                                   <li>
                                                      <p>在事务边界停止服务或PDB，或者它利用Oracle数据库版本18c连续应用程序可用性来停止请求边界处的服务</p>
                                                   </li>
                                                   <li>
                                                      <p>流量控制器模式中的Oracle连接管理器利用透明应用程序故障转移（TAF）故障转移还原来重新连接和还原简单状态。</p>
                                                   </li>
                                                </ul>
                                             </div>
                                          </li>
                                       </ul>
                                    </div>
                                 </li>
                                 <li>
                                    <p>针对大多数读取工作负载的计划外数据库中断</p>
                                 </li>
                              </ul>
                           </div>
                        </li>
                        <li>
                           <div class="p">流量控制器模式中Oracle Connection Manager的高可用性，以避免单点故障。这得到以下支持：<ul style="list-style-type:disc">
                                 <li>
                                    <p>流量控制器模式中的多个Oracle连接管理器实例，使用连接字符串中的负载平衡器或客户端负载平衡/故障转移</p>
                                 </li>
                                 <li>
                                    <p>在Traffic Director模式实例中滚动升级Oracle Connection Manager</p>
                                 </li>
                                 <li>
                                    <p>针对计划中断，在流量控制器模式下从客户端到Oracle Connection Manager的现有连接的正常关闭</p>
                                 </li>
                                 <li>
                                    <p>带有Oracle数据库版本18c及更高版本客户端的带内通知</p>
                                 </li>
                                 <li>
                                    <p>对于较旧的客户端，通知将与当前请求的响应一起发送</p>
                                 </li>
                              </ul>
                           </div>
                        </li>
                        <li>
                           <div class="p">为了安全性和隔离性，Traffic Director Mode中的Oracle Connection Manager提供：<ul style="list-style-type:disc">
                                 <li>
                                    <p>数据库代理支持传输控制协议/传输控制协议安全（TCP / TCPS）和协议转换</p>
                                 </li>
                                 <li>
                                    <p>防火墙基于IP地址，服务名称和安全套接字层/传输层安全性（SSL / TLS）钱包</p>
                                 </li>
                                 <li>
                                    <p>多租户环境中的租户隔离</p>
                                 </li>
                                 <li>
                                    <p>防止拒绝服务和模糊测试攻击</p>
                                 </li>
                                 <li>
                                    <p>跨Oracle数据库本地和Oracle Cloud安全地隧道传输数据库流量</p>
                                 </li>
                              </ul>
                           </div>
                        </li>
                     </ul>
                  </div>
               </div>
               <div class="sect3"><a id="GUID-41B25260-68F4-4080-A79D-7E2EA3670E5D" name="GUID-41B25260-68F4-4080-A79D-7E2EA3670E5D"></a><h4 id="JJDBC-GUID-41B25260-68F4-4080-A79D-7E2EA3670E5D" class="sect4"><span class="enumeration_section">2.10.3</span>流量控制器模式下Oracle Connection Manager的限制</h4>
                  <div>
                     <p></p>
                     <div class="section">
                        <p>流量控制器模式中的Oracle连接管理器不支持以下功能：</p>
                        <ul style="list-style-type:disc">
                           <li>
                              <p>分布式事务</p>
                           </li>
                           <li>
                              <p>高级排队（AQ）</p>
                           </li>
                           <li>
                              <p>数据库启动或数据库关闭调用</p>
                           </li>
                           <li>
                              <p>拆分</p>
                           </li>
                           <li>
                              <p>XML</p>
                           </li>
                           <li>
                              <p>SQL翻译</p>
                           </li>
                           <li>
                              <p>代理身份验证和SSL外部身份验证，例如LDAP中使用的专有名称（DN）</p>
                           </li>
                           <li>
                              <p>对象REF</p>
                           </li>
                           <li>
                              <p>会话切换</p>
                           </li>
                           <li>
                              <p>可滚动光标</p>
                           </li>
                           <li>
                              <p>每次迭代DML行计数</p>
                           </li>
                           <li>
                              <p>隐含的结果</p>
                           </li>
                           <li>
                              <p>连续查询通知（CQN）</p>
                           </li>
                           <li>
                              <p>客户端结果缓存</p>
                           </li>
                           <li>
                              <p>会话状态的PL / SQL回调修复数据库驻留连接池（DRCP）</p>
                           </li>
                           <li>
                              <p>数据库驻留连接池（DRCP）中的多个标记</p>
                           </li>
                           <li>
                              <p>应用程序连续性</p>
                           </li>
                           <li>
                              <p>身份验证如SYSDBA，SYSOPER等</p>
                           </li>
                           <li>
                              <p>真实应用安全</p>
                           </li>
                           <li>
                              <p>数据类型，如PL / SQL索引表绑定</p>
                           </li>
                           <li>
                              <p>批量复制（仅限ODP.Net）</p>
                           </li>
                           <li>
                              <p>自我调整（仅限ODP.Net）</p>
                           </li>
                           <li>
                              <p>ASO加密和支持的算法（仅限ASO）</p>
                           </li>
                        </ul>
                     </div>
                     <!-- class="section" -->
                  </div>
               </div>
            </div><a id="JJDBC28075"></a><div class="props_rev_3"><a id="GUID-98F62472-1415-4099-A6B6-7C13C6AEC040" name="GUID-98F62472-1415-4099-A6B6-7C13C6AEC040"></a><h3 id="JJDBC-GUID-98F62472-1415-4099-A6B6-7C13C6AEC040" class="sect3"><span class="enumeration_section">2.11</span> JDBC程序中的存储过程调用</h3>
               <div>
                  <div class="section">
                     <p>本节介绍Oracle JDBC驱动程序如何支持以下类型的存储过程：</p>
                     <ul style="list-style-type:disc">
                        <li>
                           <p><a href="JDBC-getting-started.html#GUID-E3DE7C3D-117B-498F-AA5D-159E9EC99770">PL / SQL存储过程</a></p>
                        </li>
                        <li>
                           <p><a href="JDBC-getting-started.html#GUID-DDC759FB-A823-4511-9846-F20EC3DA4FC0">Java存储过程</a></p>
                        </li>
                     </ul>
                  </div>
                  <!-- class="section" -->
               </div><a id="JJDBC28076"></a><div class="props_rev_3"><a id="GUID-E3DE7C3D-117B-498F-AA5D-159E9EC99770" name="GUID-E3DE7C3D-117B-498F-AA5D-159E9EC99770"></a><h4 id="JJDBC-GUID-E3DE7C3D-117B-498F-AA5D-159E9EC99770" class="sect4"><span class="enumeration_section">2.11.1</span> PL / SQL存储过程</h4>
                  <div>
                     <div class="section">
                        <p>JDBC支持使用JDBC转义语法或PL / SQL块语法调用PL / SQL过程/函数和匿名块。以下PL / SQL调用适用于任何Oracle JDBC驱动程序：</p><pre class="oac_no_warn" dir="ltr">// JDBC转义语法CallableStatement cs1 = conn.prepareCall（“{call proc（？，？）}“）; //存储过程CallableStatement cs2 = conn.prepareCall（”{？= call func（？，？）}“）; //存储的func // PL / SQL块语法CallableStatement cs3 = conn.prepareCall（”begin proc（？，？）;结束;“）; //存储过程CallableStatement cs4 = conn.prepareCall（”begin？：= func（？，？）;结束;“）; //存储的函数</pre><p>作为使用Oracle语法的示例，这里是一个PL / SQL代码片段，用于创建存储的函数。PL / SQL函数获取一个字符序列并将后缀连接到它：</p><pre class="oac_no_warn" dir="ltr">创建或替换函数foo（val1 char）返回char作为开始返回val1 || '后缀';结束;</pre><p>JDBC程序中的函数调用应如下所示：</p><pre class="oac_no_warn" dir="ltr">OracleDataSource ods = new OracleDataSource（）; ods.setURL（ “JDBC：预言：OCI：@ &lt;hoststring&gt;”）; ods.setUser（ “HR”）; ods.setPassword（ “HR”）; Connection conn = ods.getConnection（）; CallableStatement cs = conn.prepareCall（“begin？：= foo（？）;结束;“）; cs.registerOutParameter（1，类型。CHAR）; cs.setString（2，“aa”）; cs.execute（）; String result = cs.getString（1）;</pre></div>
                     <!-- class="section" -->
                  </div>
               </div><a id="JJDBC28077"></a><div class="props_rev_3"><a id="GUID-DDC759FB-A823-4511-9846-F20EC3DA4FC0" name="GUID-DDC759FB-A823-4511-9846-F20EC3DA4FC0"></a><h4 id="JJDBC-GUID-DDC759FB-A823-4511-9846-F20EC3DA4FC0" class="sect4"><span class="enumeration_section">2.11.2</span> Java存储过程</h4>
                  <div>
                     <div class="section">
                        <p><a id="d16478e2742" class="indexterm-anchor"></a><a id="d16478e2746" class="indexterm-anchor"></a>您可以使用JDBC通过SQL接口调用Java存储过程。调用Java存储过程的语法与调用PL / SQL存储过程的语法相同，假设它们已正确发布。也就是说，您已编写了调用规范，以将它们发布到Oracle数据字典中。应用程序可以使用Native Java Interface调用Java存储过程，以直接调用<code class="codeph">static</code> Java方法。
                        </p>
                     </div>
                     <!-- class="section" -->
                  </div>
               </div>
            </div><a id="JJDBC28080"></a><a id="JJDBC28078"></a><div class="props_rev_3"><a id="GUID-E187D04E-B48D-4394-9DC5-1ECEEBC53AFD" name="GUID-E187D04E-B48D-4394-9DC5-1ECEEBC53AFD"></a><h3 id="JJDBC-GUID-E187D04E-B48D-4394-9DC5-1ECEEBC53AFD" class="sect3"><span class="enumeration_section">2.12</span>关于处理SQL异常</h3>
               <div>
                  <p><a id="d16478e2779" class="indexterm-anchor"></a>为了处理错误条件，Oracle JDBC驱动程序抛出SQL异常，生成<code class="codeph">java.sql.实例<code class="codeph">java.sql.SQLException</code>类或其子类。错误可以源自JDBC驱动程序或数据库本身。生成的消息描述错误并识别引发错误的方法。还可以附加额外的运行时信息。
                  </p>
                  <p>JDBC 3.0仅定义了一个异常<code class="codeph">SQLException</code> 。但是，存在大量错误，区分它们很有用。因此，在JDBC 4.0中，引入了一组<code class="codeph">SQLException</code>异常的子类来标识不同类别的错误。
                  </p>
                  <p>基本异常处理可以包括检索错误消息，检索错误代码，检索SQL状态以及打印堆栈跟踪。<code class="codeph">SQLException</code>类包括在可用时检索所有这些信息的功能。
                  </p>
                  <div class="section">
                     <p class="subhead2" id="GUID-E187D04E-B48D-4394-9DC5-1ECEEBC53AFD__GUID-F34DA044-72B6-439E-9DE9-2600DB623013">检索错误信息</p>
                     <p>您可以使用<code class="codeph">SQLException</code>类的以下方法检索基本错误信息：</p>
                     <ul style="list-style-type:disc">
                        <li>
                           <p><code class="codeph">getMessage</code>类包括在可用时检索所有这些信息的功能。
                           </p>
                        </li>
                        <li>
                           <p><code class="codeph">getErrorCode</code>类包括在可用时检索所有这些信息的功能。
                           </p>
                        </li>
                        <li>
                           <p><code class="codeph">getSQLState</code>类包括在可用时检索所有这些信息的功能。
                           </p>
                        </li>
                     </ul>
                     <p>以下示例打印<code class="codeph">getMessage</code>方法调用的输出：</p><pre class="oac_no_warn" dir="ltr">catch（SQLException e）{System.out.println（“exception：”+ e.getMessage（））; }</pre><p>这将打印源自JDBC驱动程序的错误的输出，如下所示：</p><pre class="oac_no_warn" dir="ltr">异常：列类型无效</pre><div class="infoboxnote" id="GUID-E187D04E-B48D-4394-9DC5-1ECEEBC53AFD__GUID-A228B9C9-EEE8-405C-B4C2-87C6857609BE">
                        <p class="notep1">注意：</p>
                        <p>Oracle支持的备用语言和字符集中提供了错误消息文本。</p>
                     </div>
                  </div>
                  <!-- class="section" -->
                  <div class="section">
                     <p class="subhead2" id="GUID-E187D04E-B48D-4394-9DC5-1ECEEBC53AFD__GUID-D159D9A1-FD3C-4101-801D-CE713BF0F524">打印堆栈跟踪</p>
                  </div>
                  <!-- class="section" -->
                  <div class="section">
                     <p><code class="codeph">SQLException</code>类提供用于打印堆栈跟踪的<code class="codeph">printStackTrace()</code>方法。此方法将<code class="codeph">Throwable</code>对象的堆栈跟踪打印到标准错误流。您还可以指定<code class="codeph">java.io.PrintStream</code>对象或<code class="codeph">java.io.PrintWriter</code>对象用于输出。
                     </p>
                     <p>以下代码片段说明了如何捕获SQL异常并打印堆栈跟踪。</p><pre class="oac_no_warn" dir="ltr">尝试{&lt; <span class="italic">some code&gt;</span> } catch（SQLException e）{e.printStackTrace（）; }</pre><p>为了说明JDBC驱动程序如何处理错误，假设以下代码使用了错误的列索引：</p><pre class="oac_no_warn" dir="ltr">//迭代结果并打印代码的员工姓名// try {while（rset.next（））System.out.println（rset.getString（5））; //不正确的列索引} catch（SQLException e）{e.printStackTrace（）; }</pre><p>假设列索引不正确，运行该程序将产生以下错误文本：</p><pre class="oac_no_warn" dir="ltr">java.sql中。SQLException：oracle.jdbc中的列索引无效。一个OracleDriver。Employee.main上的OracleResultSetImpl.getDate（OracleResultSetImpl.java:1556）（Employee.java:41）</pre></div>
                  <!-- class="section" -->
               </div>
               <div>
                  <div class="relinfo">
                     <p><strong>相关话题</strong></p>
                     <ul>
                        <li><a href="JDBC-error-messages.html#GUID-4B127F75-44EE-4BF5-BA00-54A502A1EA06">JDBC错误消息</a></li>
                        <li><a href="../errmg/using-messages.html#ERRMG-GUID-CA5A766D-6CBF-4235-982F-86A6F34266CC" target="_blank"><span><cite>Oracle数据库错误消息参考</cite></span></a></li>
                     </ul>
                  </div>
               </div>
            </div>
         </div>
      </article>
   </body>
</html>