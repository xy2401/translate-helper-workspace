<html lang="en-us" dir="ltr" xml:lang="en-us">
   <head>
      <meta http-equiv="Content-Type" content="text/html; charset=utf-8"></meta>
      <meta name="viewport" content="width=device-width, initial-scale=1"></meta>
      <meta http-equiv="X-UA-Compatible" content="IE=edge"></meta>
      <meta name="abstract" content="Review these recommendations based on performance considerations when choosing a partitioning strategy."></meta>
      <meta name="description" content="Review these recommendations based on performance considerations when choosing a partitioning strategy."></meta>
      <title>选择分区策略的建议</title>
      <meta property="og:site_name" content="Oracle Help Center"></meta>
      <meta property="og:title" content="VLDB and Partitioning Guide"></meta>
      <meta property="og:description" content="Review these recommendations based on performance considerations when choosing a partitioning strategy."></meta>
      <link rel="stylesheet" href="/sp_common/book-template/ohc-book-template/css/book.css"></link>
      <link rel="shortcut icon" href="/sp_common/book-template/ohc-common/img/favicon.ico"></link>
      <meta name="application-name" content="VLDB and Partitioning Guide"></meta>
      <meta name="generator" content="DITA Open Toolkit version 1.8.5 (Mode = doc)"></meta>
      <meta name="plugin" content="SP_docbuilder HTML plugin release 18.2.2"></meta>
      <link rel="alternate" href="vldb-and-partitioning-guide.pdf" title="PDF File" type="application/pdf"></link>
      <meta name="robots" content="all"></meta>
      <link rel="schema.dcterms" href="http://purl.org/dc/terms/"></link>
      <meta name="dcterms.created" content="2019-04-23T18:05:22-07:00"></meta>
      <meta name="dcterms.title" content="VLDB and Partitioning Guide"></meta>
      <meta name="dcterms.dateCopyrighted" content="2008, 2019"></meta>
      <meta name="dcterms.category" content="database"></meta>
      <meta name="dcterms.identifier" content="E96199-03"></meta>
      
      <meta name="dcterms.product" content="en/database/oracle/oracle-database/19"></meta>
      
      <link rel="prev" href="partition-table-compression.html" title="Previous" type="text/html"></link>
      <link rel="next" href="partition-admin.html" title="Next" type="text/html"></link>
      <script>
        document.write('<style type="text/css">');
        document.write('body > .noscript, body > .noscript ~ * { visibility: hidden; }');
        document.write('</style>');
     </script>
      <script src="/sp_common/book-template/requirejs/require.js" data-main="/sp_common/book-template/ohc-book-template/js/book-config"></script>
      <script>
            if (window.require === undefined) {
                document.write('<script data-main="sp_common/book-template/ohc-book-template/js/book-config" src="sp_common/book-template/requirejs/require.js"><\/script>');
                document.write('<link href="sp_common/book-template/ohc-book-template/css/book.css" rel="stylesheet"/>');
            }
        </script>
      <script type="application/json" id="ssot-metadata">{"primary":{"category":{"short_name":"database","element_name":"Database","display_in_url":true},"suite":{"short_name":"oracle","element_name":"Oracle","display_in_url":true},"product_group":{"short_name":"not-applicable","element_name":"Not applicable","display_in_url":false},"product":{"short_name":"oracle-database","element_name":"Oracle Database","display_in_url":true},"release":{"short_name":"19","element_name":"Release 19","display_in_url":true}}}</script>
      
    <meta name="dcterms.isVersionOf" content="VLDBG"></meta>
    <meta name="dcterms.release" content="Release 19"></meta>
  </head>
   <body dir="ltr">
      <div class="noscript alert alert-danger text-center" role="alert">
         <a href="partition-table-compression.html" class="pull-left"><span class="glyphicon glyphicon-chevron-left" aria-hidden="true"></span>上一页</a> <a href="partition-admin.html" class="pull-right">下一页<span class="glyphicon glyphicon-chevron-right" aria-hidden="true"></span></a> <span class="fa fa-exclamation-triangle" aria-hidden="true"></span>必须启用JavaScript才能正确显示此内容</div>
      <article>
         <header>
            <ol class="breadcrumb" vocab="http://schema.org/" typeof="BreadcrumbList">
               <li property="itemListElement" typeof="ListItem"><a href="index.html" property="item" typeof="WebPage"><span property="name">VLDB和分区指南</span></a></li>
               <li property="itemListElement" typeof="ListItem"><a href="partition-availability.html" property="item" typeof="WebPage"><span property="name">可用性，可管理性和性能的分区</span></a></li>
               <li class="active" property="itemListElement" typeof="ListItem">选择分区策略的建议</li>
            </ol>
            <a id="GUID-9F7809B6-E68A-4425-AC99-BE00C7805408" name="GUID-9F7809B6-E68A-4425-AC99-BE00C7805408"></a><a id="VLDBG00406"></a>
            
            <h2 id="VLDBG-GUID-9F7809B6-E68A-4425-AC99-BE00C7805408" class="sect2">选择分区策略的建议</h2>
         </header>
         <div class="ind">
            <div>
               <p>在选择分区策略时，请根据性能注意事项查看这些建议。</p>
               <p>以下主题提供了有关选择分区策略的建议：</p>
               <ul style="list-style-type:disc">
                  <li>
                     <p><a href="recommendations-partition-strategy.html#GUID-EAFD703C-EFA9-4819-85BD-79F63B761A96" title="在组织类似数据（尤其是日期和时间数据）时，范围和间隔分区非常有用。">何时使用范围或间隔分区</a></p>
                  </li>
                  <li>
                     <p><a href="recommendations-partition-strategy.html#GUID-F023D3ED-262F-4B19-950A-D3C8F8CDB4F4" title="散列分区对于基于散列算法在分区中随机分布数据非常有用，而不是对类似数据进行分组。">何时使用哈希分区</a></p>
                  </li>
                  <li>
                     <p><a href="recommendations-partition-strategy.html#GUID-46E9F92A-4E34-4518-BAD9-6AB3C3F46ED0" title="列表分区对于根据离散值将行显式映射到分区很有用。">何时使用列表分区</a></p>
                  </li>
                  <li>
                     <p><a href="recommendations-partition-strategy.html#GUID-FA82A5ED-5676-45F0-ACE6-8D6ACCAE01D9" title="复合分区提供了在多个维度上进行分区的好处。">何时使用复合分区</a></p>
                  </li>
                  <li>
                     <p><a href="recommendations-partition-strategy.html#GUID-A5B70F62-8D83-4CB0-905D-91204CF6EA97" title="区间分区几乎可用于范围分区的每个表，并对新分区使用固定间隔。">何时使用间隔分区</a></p>
                  </li>
                  <li>
                     <p><a href="recommendations-partition-strategy.html#GUID-5E5BAB95-DE89-41CB-A61F-16A23A7A3B84" title="引用分区在某些情况下很有用。">何时使用参考分区</a></p>
                  </li>
                  <li>
                     <p><a href="recommendations-partition-strategy.html#GUID-811EDE81-7016-43AF-9078-A435DD52EFA5" title="对虚拟列进行分区可为派生列上的分区提供更大的灵活性。">何时对虚拟列进行分区</a></p>
                  </li>
                  <li>
                     <p><a href="recommendations-partition-strategy.html#GUID-8FB551B9-431A-4631-AF15-D17C08401E37" title="使用只读表时，请查看这些注意事项。">使用只读表空间时的注意事项</a></p>
                  </li>
               </ul>
            </div><a id="VLDBG14029"></a><a id="VLDBG1269"></a><div class="props_rev_3"><a id="GUID-EAFD703C-EFA9-4819-85BD-79F63B761A96" name="GUID-EAFD703C-EFA9-4819-85BD-79F63B761A96"></a><h3 id="VLDBG-GUID-EAFD703C-EFA9-4819-85BD-79F63B761A96" class="sect3">何时使用范围或间隔分区</h3>
               <div>
                  <p>在组织类似数据（尤其是日期和时间数据）时，范围和间隔分区非常有用。</p>
                  <p>范围分区是分区历史数据的便捷方法。范围分区的边界定义表或索引中分区的顺序。</p>
                  <p>区间分区是范围分区的扩展，其中超出一个时间点，分区由间隔定义。当数据插入分区时，数据库会自动创建间隔分区。</p>
                  <p>范围或间隔分区通常用于按类型<code class="codeph">DATE</code>的列按时间间隔组织数据。因此，访问范围分区的大多数SQL语句都关注时间帧。一个例子是类似于“从特定时间段选择数据”的SQL语句。在这种情况下，如果每个分区代表一个月的数据，则查询“查找月份06-DEC的数据”必须仅访问2006年的12月分区。这将扫描的数据量减少到可用总数据的一小部分，这是一种称为分区修剪的优化方法。
                  </p>
                  <p>当您定期加载新数据并清除旧数据时，范围分区也是理想的选择，因为添加或删除分区很容易。例如，通常保持滚动的数据窗口，保持过去36个月的在线数据。范围分区简化了此过程。要添加新月份的数据，请将其加载到单独的表中，清理，索引，然后使用<code class="codeph">EXCHANGE</code> <code class="codeph">PARTITION</code>语句将其添加到范围分区表中，同时原始表保持联机状态。添加新分区后，可以使用<code class="codeph">DROP</code> <code class="codeph">PARTITION</code>语句删除尾随月份。使用<code class="codeph">DROP</code> <code class="codeph">PARTITION</code>语句的替代方法可以是归档分区并将其设置为只读，但只有当分区位于不同的表空间中时，这才有效。您还可以使用插入到分区表中的数据滚动窗口来实现。
                  </p>
                  <p>间隔分区为数据到达时自动创建间隔分区提供了一种简便方法。间隔分区也可用于所有其他分区维护操作。</p>
                  <p>总之，在以下情况下考虑使用范围或间隔分区：</p>
                  <ul style="list-style-type:disc">
                     <li>
                        <p>非常大的表经常由好的分区列上的范围谓词扫描，例如<code class="codeph">ORDER_DATE</code>或<code class="codeph">PURCHASE_DATE</code> 。在该列上对表进行分区可启用分区修剪。
                        </p>
                     </li>
                     <li>
                        <p>您希望维护滚动的数据窗口。</p>
                     </li>
                     <li>
                        <p>您无法在分配的时间范围内对大型表执行管理操作（如备份和还原），但可以根据分区范围列将它们分成较小的逻辑块。</p>
                     </li>
                  </ul>
                  <p><a href="recommendations-partition-strategy.html#GUID-EAFD703C-EFA9-4819-85BD-79F63B761A96__BABJHDBE">示例3-5</a>创建表<code class="codeph">salestable</code> ，为期两年，即2005年和2006年，并根据列<code class="codeph">s_salesdate</code>按范围对其进行分区，以将数据分成八个季度，每个季度对应一个分区。未来的分区是通过每月间隔定义自动创建的。间隔分区以循环方式在提供的表空间列表中创建。短时间内分析销售数据可以利用分区修剪。销售表还支持滚动窗口方法。
                  </p>
                  <div class="example" id="GUID-EAFD703C-EFA9-4819-85BD-79F63B761A96__BABJHDBE">
                     <p class="titleinexample">示例3-5创建具有范围和间隔分区的表</p><pre class="oac_no_warn" dir="ltr">CREATE TABLE salestable（s_productid NUMBER，s_saledate DATE，s_custid NUMBER，s_totalprice NUMBER）PARTITION BY RANGE（s_saledate）INTERVAL（NUMTOYMINTERVAL（1，'MONTH'））STORE IN（tbs1，tbs2，tbs3，tbs4）（PARTITION sal05q1 VALUE少于（TO_DATE（'01 -APR-2005'，'DD-MON-YYYY'））TABLESPACE tbs1，PARTITION sal05q2值不到（截止日期（'01 -JUL-2005'，'DD-MON-YYYY'））TABLESPACE tbs2 ，PARTITION sal05q3的价值不到（截止日期（'01 -OCT-2005'，'DD-MON-YYYY'））TABLESPACE tbs3，PARTITION sal05q4价值不到（截止日期为（'01 -JAN-2006'，'DD-MON-） YYYY'））TABLESPACE tbs4，PARTITION sal06q1价值不到（截止日期（'01-APR-2006'，'DD-MON-YYYY'））TABLESPACE tbs1，PARTITION sal06q2价值不到（截止到2006年7月1日） ，'DD-MON-YYYY'）TABLESPACE tbs2，PARTITION sal06q3值不到（截止日期（'01 -OCT-2006'，'DD-MON-YYYY'））TABLESPACE tbs3，PARTITION sal06q4价值低于（7月4日） 01-JAN-2007'，'DD-MON-YYYY'））TABLESPACE tbs4）;</pre></div>
                  <!-- class="example" -->
                  <div class="section">
                     <div class="infoboxnotealso" id="GUID-EAFD703C-EFA9-4819-85BD-79F63B761A96__GUID-ADAD3D8B-1CE8-4B1D-BC18-AAF983B37266">
                        <p class="notep1">也可以看看：</p>
                        <p>有关间隔分区上的分区维护操作的详细信息，请参阅分区<a href="partition-admin.html#GUID-F2C99CFA-1090-4A62-B452-D4E116A40A34" title="使用分区表和索引时，分区管理是一项重要任务。">管理</a></p>
                     </div>
                  </div>
                  <!-- class="section" -->
               </div>
            </div><a id="VLDBG14030"></a><a id="VLDBG1270"></a><div class="props_rev_3"><a id="GUID-F023D3ED-262F-4B19-950A-D3C8F8CDB4F4" name="GUID-F023D3ED-262F-4B19-950A-D3C8F8CDB4F4"></a><h3 id="VLDBG-GUID-F023D3ED-262F-4B19-950A-D3C8F8CDB4F4" class="sect3">何时使用哈希分区</h3>
               <div>
                  <p>散列分区对于基于散列算法在分区中随机分布数据非常有用，而不是对类似数据进行分组。</p>
                  <p>虽然可以识别分区键，但有时候分区数据应该驻留在哪些区域并不明显。有时候需要分配数据，使其不对应于数据的业务或逻辑视图，而不是像在范围分区中那样。使用散列分区，根据将分区键传递给散列算法的结果将行放入分区。</p>
                  <p>使用此方法，数据在分区中随机分布，而不是分组。这对于某些数据来说是一种很好的方法，但可能不是管理历史数据的有效方法。但是，散列分区与范围分区共享一些性能特征。例如，分区修剪仅限于等式谓词。您还可以使用分区智能联接，并行索引访问和并行DML。</p>
                  <p>作为一般规则，使用散列分区用于以下目的：</p>
                  <ul style="list-style-type:disc">
                     <li>
                        <p>使用可能的均衡分区启用部分或完全并行分区连接。</p>
                     </li>
                     <li>
                        <p>在使用Oracle Real Application Clusters的MPP平台的节点之间均匀分布数据。因此，您可以在处理节点间并行语句时最小化互连流量。</p>
                     </li>
                     <li>
                        <p>根据主要由不同值或值列表约束的分区键来使用分区修剪和分区连接。</p>
                     </li>
                     <li>
                        <p>如果不使用在所有可用设备上划分条带和镜像的存储管理技术，则随机分发数据以避免I / O瓶颈。</p>
                     </li>
                  </ul>
                  <div class="infoboxnote" id="GUID-F023D3ED-262F-4B19-950A-D3C8F8CDB4F4__GUID-EF785C3F-A390-4F86-BF4F-0DCFF59CA85F">
                     <p class="notep1">注意：</p>
                     <p>使用散列分区，分区修剪仅支持相等或<code class="codeph">IN</code> -list谓词。
                     </p>
                  </div>
                  <p>为了获得最佳数据分布，应满足以下要求：</p>
                  <ul style="list-style-type:disc">
                     <li>
                        <p>选择唯一或几乎唯一的列或列组合。</p>
                     </li>
                     <li>
                        <p>为每个2的幂分区创建多个分区和子分区。例如，2,4,8,16,32,64,128等。</p>
                     </li>
                  </ul>
                  <p><a href="recommendations-partition-strategy.html#GUID-F023D3ED-262F-4B19-950A-D3C8F8CDB4F4__BABICGIB">示例3-6</a>使用列<code class="codeph">s_productid</code>作为分区键为表<code class="codeph">sales_hash</code>创建四个哈希分区。与products表的并行连接可以利用部分或完全分区连接。只访问单个产品或产品列表的销售数据的查询将受益于分区修剪。
                  </p>
                  <p>如果未明确指定分区名称，而是指定散列分区数，则Oracle会自动为分区生成内部名称。此外，您可以使用<code class="codeph">STORE</code> <code class="codeph">IN</code>子句以循环方式将散列分区分配给表空间。
                  </p>
                  <div class="example" id="GUID-F023D3ED-262F-4B19-950A-D3C8F8CDB4F4__BABICGIB">
                     <p class="titleinexample">示例3-6使用散列分区创建表</p><pre class="oac_no_warn" dir="ltr">CREATE TABLE sales_hash（s_productid NUMBER，s_saledate DATE，s_custid NUMBER，s_totalprice NUMBER）HASH（s_productid）的分区（PARTITION p1 TABLESPACE tbs1，PARTITION p2 TABLESPACE tbs2，PARTITION p3 TABLESPACE tbs3，PARTITION p4 TABLESPACE tbs4）;</pre></div>
                  <!-- class="example" -->
                  <div class="section">
                     <div class="infoboxnotealso" id="GUID-F023D3ED-262F-4B19-950A-D3C8F8CDB4F4__GUID-91D6A97E-6B88-4C13-A931-4977532C645E">
                        <p class="notep1">也可以看看：</p>
                        <ul style="list-style-type:disc">
                           <li>
                              <p><a href="partition-wise-joins.html#GUID-7C28CD29-5189-4A53-9691-380E13515015" title="分区操作可显着缩短响应时间并改善CPU和内存资源的使用。">Partition-Wise操作</a>以获取有关部分连接的信息</p>
                           </li>
                           <li>
                              <p>有关管理VLDB存储的详细信息<a href="vldb-storage.html#GUID-02C55147-04B1-4DBC-8CFC-637CE5E751DF" title="VLDB环境中的数据库文件的存储管理包括高可用性，性能和可管理性方面。">，请参阅VLDB的存储管理</a></p>
                           </li>
                           <li>
                              <p>有关创建散列分区表的更多示例的<a href="partition-admin.html#GUID-F2C99CFA-1090-4A62-B452-D4E116A40A34" title="使用分区表和索引时，分区管理是一项重要任务。">分区管理</a></p>
                           </li>
                           <li>
                              <p>用于分区语法的<a href="../sqlrf/CREATE-TABLE.html#SQLRF01402" target="_blank"><span><cite>Oracle数据库SQL语言参考</cite></span></a></p>
                           </li>
                        </ul>
                     </div>
                  </div>
                  <!-- class="section" -->
               </div>
            </div><a id="VLDBG14031"></a><a id="VLDBG1271"></a><div class="props_rev_3"><a id="GUID-46E9F92A-4E34-4518-BAD9-6AB3C3F46ED0" name="GUID-46E9F92A-4E34-4518-BAD9-6AB3C3F46ED0"></a><h3 id="VLDBG-GUID-46E9F92A-4E34-4518-BAD9-6AB3C3F46ED0" class="sect3">何时使用列表分区</h3>
               <div>
                  <p>列表分区对于根据离散值将行显式映射到分区很有用。</p>
                  <p>在<a href="recommendations-partition-strategy.html#GUID-46E9F92A-4E34-4518-BAD9-6AB3C3F46ED0__BABJAEDA">示例3-7中</a> ，状态Oregon和Washington的所有客户都存储在一个分区中，而其他状态的客户存储在不同的分区中。按地区分析其帐户的客户经理可以利用分区修剪。
                  </p>
                  <div class="example" id="GUID-46E9F92A-4E34-4518-BAD9-6AB3C3F46ED0__BABJAEDA">
                     <p class="titleinexample">示例3-7使用列表分区创建表</p><pre class="oac_no_warn" dir="ltr">CREATE TABLE帐户（ID NUMBER，account_number NUMBER，customer_id NUMBER，branch_id NUMBER，region VARCHAR（2），status VARCHAR2（1））PARTITION BY LIST（区域）（PARTITION p_northwest VALUES（'OR'，'WA'），PARTITION p_southwest VALUES（'AZ'，'UT'，'NM'），PARTITION p_northeast VALUES（'NY'，'VM'，'NJ'），PARTITION p_southeast VALUES（'FL'，'GA'），PARTITION p_northcentral VALUES（' SD'，'WI'），PARTITION p_southcentral VALUES（'OK'，'TX'））;</pre></div>
                  <!-- class="example" -->
               </div>
            </div><a id="VLDBG1272"></a><div class="props_rev_3"><a id="GUID-FA82A5ED-5676-45F0-ACE6-8D6ACCAE01D9" name="GUID-FA82A5ED-5676-45F0-ACE6-8D6ACCAE01D9"></a><h3 id="VLDBG-GUID-FA82A5ED-5676-45F0-ACE6-8D6ACCAE01D9" class="sect3">何时使用复合分区</h3>
               <div>
                  <p>复合分区提供了在多个维度上进行分区的好处。</p>
                  <p>从性能角度来看，您可以根据SQL语句在一个或两个维度上利用分区修剪，并且可以利用在任一维度上使用完全或部分分区连接。</p>
                  <p>您可以利用单个表的并行备份和恢复。复合分区还显着增加了分区的数量，这对于有效的并行执行可能是有益的。从可管理性的角度来看，如果许多语句可以从分区修剪或分区连接中受益，则可以实现滚动窗口以支持历史数据，并仍在另一个维度上进行分区。</p>
                  <p>您可以拆分表的备份，并且可以根据分区键的标识决定以不同方式存储数据。例如，您可能决定以只读的压缩格式存储特定产品类型的数据，并保持其他产品类型数据不压缩。</p>
                  <p>数据库将复合分区表中的每个子分区存储为单独的段。因此，子分区可能具有与表的属性或子分区所属的分区不同的属性。</p>
                  <p>讨论了以下主题：</p>
                  <ul style="list-style-type:disc">
                     <li>
                        <p><a href="recommendations-partition-strategy.html#GUID-EAFD703C-EFA9-4819-85BD-79F63B761A96" title="在组织类似数据（尤其是日期和时间数据）时，范围和间隔分区非常有用。">何时使用范围或间隔分区</a></p>
                     </li>
                     <li>
                        <p><a href="recommendations-partition-strategy.html#GUID-F023D3ED-262F-4B19-950A-D3C8F8CDB4F4" title="散列分区对于基于散列算法在分区中随机分布数据非常有用，而不是对类似数据进行分组。">何时使用哈希分区</a></p>
                     </li>
                     <li>
                        <p><a href="recommendations-partition-strategy.html#GUID-46E9F92A-4E34-4518-BAD9-6AB3C3F46ED0" title="列表分区对于根据离散值将行显式映射到分区很有用。">何时使用列表分区</a></p>
                     </li>
                     <li>
                        <p><a href="recommendations-partition-strategy.html#GUID-FA82A5ED-5676-45F0-ACE6-8D6ACCAE01D9" title="复合分区提供了在多个维度上进行分区的好处。">何时使用复合分区</a></p>
                     </li>
                     <li>
                        <p><a href="recommendations-partition-strategy.html#GUID-A5B70F62-8D83-4CB0-905D-91204CF6EA97" title="区间分区几乎可用于范围分区的每个表，并对新分区使用固定间隔。">何时使用间隔分区</a></p>
                     </li>
                     <li>
                        <p><a href="recommendations-partition-strategy.html#GUID-5E5BAB95-DE89-41CB-A61F-16A23A7A3B84" title="引用分区在某些情况下很有用。">何时使用参考分区</a></p>
                     </li>
                     <li>
                        <p><a href="recommendations-partition-strategy.html#GUID-811EDE81-7016-43AF-9078-A435DD52EFA5" title="对虚拟列进行分区可为派生列上的分区提供更大的灵活性。">何时对虚拟列进行分区</a></p>
                     </li>
                  </ul>
                  <div class="infoboxnotealso" id="GUID-FA82A5ED-5676-45F0-ACE6-8D6ACCAE01D9__GUID-A28604A3-CACF-4B19-92FB-DE149BDE8CEA">
                     <p class="notep1">也可以看看：</p>
                     <p><a href="../sqlrf/CREATE-TABLE.html#SQLRF01402" target="_blank"><span><cite>Oracle Database SQL语言参考</cite></span></a>有关语法和限制的详细信息</p>
                  </div>
               </div><a id="VLDBG14032"></a><a id="VLDBG1273"></a><div class="props_rev_3"><a id="GUID-52D62B9A-13CB-40EE-AFA2-6140CC3BEC06" name="GUID-52D62B9A-13CB-40EE-AFA2-6140CC3BEC06"></a><h4 id="VLDBG-GUID-52D62B9A-13CB-40EE-AFA2-6140CC3BEC06" class="sect4">何时使用复合范围哈希分区</h4>
                  <div>
                     <p>复合范围哈希分区对于存储历史记录的表特别常见，因此非常大，并且经常与其他大表连接。</p>
                     <p>对于这些类型的表（典型的数据仓库系统），复合范围哈希分区提供了范围级别的分区修剪的好处，并有机会在哈希级别执行并行的完全或部分分区连接。特定情况可以受益于特定SQL语句的两个维度上的分区修剪。</p>
                     <p>复合范围散列分区也可用于传统上使用散列分区的表，但也使用滚动窗口方法。随着时间的推移，数据可以从一个存储层移动到另一个存储层，压缩，存储在只读表空间中，最终被清除。信息生命周期管理（ILM）方案通常使用范围分区来实现分层存储方法。</p>
                     <p><a href="recommendations-partition-strategy.html#GUID-52D62B9A-13CB-40EE-AFA2-6140CC3BEC06__BABIJJBI">示例3-8</a>是因特网服务提供商的范围散列分区的<code class="codeph">page_history</code>表的示例。表定义针对特定<code class="codeph">client_ip</code>值的历史分析进行了优化（在这种情况下，查询受益于分区修剪）或跨多个IP地址进行分析，在这种情况下，查询可以利用完全或部分分区连接。
                     </p>
                     <p>此示例显示了间隔分区的使用。除了范围分区之外，还可以使用间隔分区，以便在将数据插入表时自动创建间隔分区。</p>
                     <div class="example" id="GUID-52D62B9A-13CB-40EE-AFA2-6140CC3BEC06__BABIJJBI">
                        <p class="titleinexample">示例3-8使用复合范围 - 散列分区创建表</p><pre class="oac_no_warn" dir="ltr">CREATE TABLE page_history（id NUMBER NOT NULL，url VARCHAR2（300）NOT NULL，view_date DATE NOT NULL，client_ip VARCHAR2（23）NOT NULL，from_url VARCHAR2（300），to_url VARCHAR2（300），timing_in_seconds NUMBER）PARTITION BY RANGE（view_date ）INTERVAL（NUMTODSINTERVAL（1，'DAY'））HASH（client_ip）SUBPARTITIONS 32（PARTITION p0值小于（'01 -JAN-2006'，'dd-MON-yyyy'））的分区）并行32压缩;</pre></div>
                     <!-- class="example" -->
                     <div class="section">
                        <div class="infoboxnotealso" id="GUID-52D62B9A-13CB-40EE-AFA2-6140CC3BEC06__GUID-A5CD7FDD-1A6E-4D08-BE23-89CE0992433A">
                           <p class="notep1">也可以看看：</p>
                           <p><a href="time-based-info.html#GUID-0193CE0F-4D9A-4D6F-8B19-E471DE94107C" title="Oracle数据库提供了基于时间管理和维护数据的策略。">管理和维护基于时间的信息，</a>以获取有关信息生命周期管理（ILM）和使用分区实施分层存储的更多详细信息</p>
                        </div>
                     </div>
                     <!-- class="section" -->
                  </div>
               </div><a id="VLDBG14033"></a><a id="VLDBG1274"></a><div class="props_rev_3"><a id="GUID-EA336B11-7C11-4239-A476-4FE58D6024F2" name="GUID-EA336B11-7C11-4239-A476-4FE58D6024F2"></a><h4 id="VLDBG-GUID-EA336B11-7C11-4239-A476-4FE58D6024F2" class="sect4">何时使用复合范围列表分区</h4>
                  <div>
                     <p>复合范围列表分区通常用于存储历史数据的大型表，并且通常在多个维度上访问。</p>
                     <p>通常，数据的历史视图是一个访问路径，但某些业务案例会向访问路径添加另一个分类。例如，区域客户经理对他们在特定时间段内在其所在地区注册了多少新客户非常感兴趣。ILM及其分层存储方法是创建范围列表分区表的常见原因，以便可以移动和压缩旧数据，但仍可以使用列表维度上的分区修剪。</p>
                     <p><a href="recommendations-partition-strategy.html#GUID-EA336B11-7C11-4239-A476-4FE58D6024F2__BABCCGFA">例3-9</a>创建了一个范围列表分区的<code class="codeph">call_detail_records</code>表。电信公司可以使用该表来分析特定类型的呼叫。该表使用<code class="codeph">from_number</code>和<code class="codeph">to_number</code>上的本地索引。
                     </p>
                     <p>此示例显示了间隔分区的使用。除了范围分区之外，还可以使用间隔分区，以便在将数据插入表时自动创建间隔分区。</p>
                     <div class="example" id="GUID-EA336B11-7C11-4239-A476-4FE58D6024F2__BABCCGFA">
                        <p class="titleinexample">示例3-9创建具有复合范围列表分区的表</p><pre class="oac_no_warn" dir="ltr">CREATE TABLE call_detail_records（id NUMBER，from_number VARCHAR2（20），to_number VARCHAR2（20），date_of_call DATE，distance VARCHAR2（1），call_duration_in_s NUMBER（4））PARTITION BY RANGE（date_of_call）INTERVAL（NUMTODSINTERVAL（1，'DAY'））通过列表（距离）的子目标子目标模板（子目标局部值（'L'）表格空间tbs1，子目标中长值（'M'）表格tbs2，子目标long_distance值（'D'）表格tbs3，SUBPARTITION国际价值（'我' ）TABLESPACE tbs4）（PARTITION p0值不到（截止日期（'01 -JAN-2005'，'dd-MON-yyyy'）））并行; CREATE INDEX from_number_ix ON call_detail_records（from_number）LOCAL PARALLEL NOLOGGING; CREATE INDEX to_number_ix ON call_detail_records（to_number）LOCAL PARALLEL NOLOGGING;</pre></div>
                     <!-- class="example" -->
                  </div>
               </div><a id="VLDBG14034"></a><a id="VLDBG1275"></a><div class="props_rev_3"><a id="GUID-A0C45C5E-874F-4286-B2BF-027F11B49697" name="GUID-A0C45C5E-874F-4286-B2BF-027F11B49697"></a><h4 id="VLDBG-GUID-A0C45C5E-874F-4286-B2BF-027F11B49697" class="sect4">何时使用复合范围范围分区</h4>
                  <div>
                     <p>复合范围范围分区对于在多个时间维度上存储时间相关数据的应用程序非常有用。</p>
                     <p>这些应用程序通常不使用一个特定的时间维度来访问数据，而是使用另一个时间维度，或者有时同时使用两个时间维度。例如，网络零售商希望根据下订单和订单发货时（分发给运输公司）分析其销售数据。</p>
                     <p>复合范围分区的其他业务案例包括ILM方案，以及存储历史数据并希望按其他维度的范围对其数据进行分类的应用程序。</p>
                     <p><a href="recommendations-partition-strategy.html#GUID-A0C45C5E-874F-4286-B2BF-027F11B49697__BABDJAJH">示例3-10</a>显示了范围范围分区表<code class="codeph">account_balance_history</code> 。银行可以使用对各个子分区的访问来联系其客户，以获得与某类客户相关的低余额提醒或特定促销。
                     </p>
                     <p>此示例显示了间隔分区的使用。除了范围分区之外，还可以使用间隔分区，以便在将数据插入表时自动创建间隔分区。在这种情况下，从2007年1月1日星期一开始创建7天（每周）间隔。</p>
                     <div class="example" id="GUID-A0C45C5E-874F-4286-B2BF-027F11B49697__BABDJAJH">
                        <p class="titleinexample">示例3-10创建具有复合范围范围分区的表</p><pre class="oac_no_warn" dir="ltr">CREATE TABLE account_balance_history（id NUMBER NOT NULL，account_number NUMBER NOT NULL，customer_id NUMBER NOT NULL，transaction_date DATE NOT NULL，amount_credited NUMBER，amount_debited NUMBER，end_of_day_balance NUMBER NOT NULL）PARTITION BY RANGE（transaction_date）INTERVAL（NUMTODSINTERVAL（7，'DAY'） ））按范围进行的子目标（end_of_day_balance）子目标模板（子目标不可接受的值小于（-1000），子目标信用值小于（0），子目标低值小于（500），子目标正常值小于（5000），子目录高价值低于（20000），超出特殊价值低于（MAXVALUE））（分区p0值不到（7月1日（'01 -JAN-2007'，'dd-MON-yyyy'）））;</pre></div>
                     <!-- class="example" -->
                  </div>
               </div><a id="VLDBG14035"></a><a id="VLDBG1276"></a><div class="props_rev_3"><a id="GUID-E21D8A38-C9D7-424E-B061-E76C22E5F9F4" name="GUID-E21D8A38-C9D7-424E-B061-E76C22E5F9F4"></a><h4 id="VLDBG-GUID-E21D8A38-C9D7-424E-B061-E76C22E5F9F4" class="sect4">何时使用复合列表散列分区</h4>
                  <div>
                     <p>复合列表 - 散列分区对于通常在一个维度上访问的大型表非常有用，但是（由于它们的大小）仍然必须利用与其他大型表连接的另一个维度上的并行完全或部分分区连接。</p>
                     <p><a href="recommendations-partition-strategy.html#GUID-E21D8A38-C9D7-424E-B061-E76C22E5F9F4__BABBDHAI">例3-11</a>显示了<code class="codeph">credit_card_accounts</code>表。该表在区域上按列表分区，以便客户经理快速访问其所在区域的帐户。子分区策略是对<code class="codeph">customer_id</code>哈希，因此针对在<code class="codeph">customer_id</code>上进行子分区的事务表的查询可以利用完全分区连接。与散列分区客户表的连接也可以从完全分区连接中受益。该表在<code class="codeph">is_active</code>列上有一个本<code class="codeph">is_active</code>图索引。
                     </p>
                     <div class="example" id="GUID-E21D8A38-C9D7-424E-B061-E76C22E5F9F4__BABBDHAI">
                        <p class="titleinexample">示例3-11使用复合列表 - 散列分区创建表</p><pre class="oac_no_warn" dir="ltr">CREATE TABLE credit_card_accounts（account_number NUMBER（16）NOT NULL，customer_id NUMBER NOT NULL，customer_region VARCHAR2（2）NOT NULL，is_active VARCHAR2（1）NOT NULL，date_opened DATE NOT NULL）PARTITION BY LIST（customer_region）SUBPARTITION BY HASH（customer_id）小组16（分区emea VALUES（'EU'，'ME'，'AF'），PARTITION amer VALUES（'NA'，'LA'），PARTITION apac VALUES（'SA'，'AU'，'NZ'，' IN'，'CH'））PARALLEL; CREATE BITMAP INDEX is_active_bix ON credit_card_accounts（is_active）LOCAL PARALLEL NOLOGGING;</pre></div>
                     <!-- class="example" -->
                  </div>
               </div><a id="VLDBG14036"></a><a id="VLDBG1277"></a><div class="props_rev_3"><a id="GUID-77C693E7-57BF-4CFC-B67D-449F6FF91F2E" name="GUID-77C693E7-57BF-4CFC-B67D-449F6FF91F2E"></a><h4 id="VLDBG-GUID-77C693E7-57BF-4CFC-B67D-449F6FF91F2E" class="sect4">何时使用复合列表 - 列表分区</h4>
                  <div>
                     <p>复合列表 - 列表分区对于通常在不同维度上访问的大型表非常有用。</p>
                     <p>您可以根据离散值将行专门映射到这些维上的分区。</p>
                     <p><a href="recommendations-partition-strategy.html#GUID-77C693E7-57BF-4CFC-B67D-449F6FF91F2E__BABDJFGA">例3-12</a>显示了一个非常频繁访问的<code class="codeph">current_inventory</code>表的示例。该表随着超市供应商当地仓库中的当前库存不断更新。从这些仓库到超市提供潜在的易腐食品，优化供应和交付非常重要。该表在<code class="codeph">warehouse_id</code>和<code class="codeph">product_id</code>上有本地索引。
                     </p>
                     <div class="example" id="GUID-77C693E7-57BF-4CFC-B67D-449F6FF91F2E__BABDJFGA">
                        <p class="titleinexample">示例3-12创建具有复合列表 - 列表分区的表</p><pre class="oac_no_warn" dir="ltr">CREATE TABLE current_inventory（warehouse_id NUMBER，warehouse_region VARCHAR2（2），product_id NUMBER，product_category VARCHAR2（12），amount_in_stock NUMBER，unit_of_shipping VARCHAR2（20），products_per_unit NUMBER，last_updated DATE）PARTITION BY LIST（warehouse_region）SUBPARTITION BY LIST（product_category）SUBPARTITION模板（SUBPARTITION易腐烂的价值（'乳制品'，'产品'，'肉'，'面包'），SUBPARTITION不易腐烂的价值（'罐头'，'包装'），子商品持久价值（'玩具'，'厨房用品'））（ PARTITION p_northwest VALUES（'OR'，'WA'），PARTITION p_southwest VALUES（'AZ'，'UT'，'NM'），PARTITION p_northeast VALUES（'NY'，'VM'，'NJ'），PARTITION p_southeast VALUES （'FL'，'GA'），PARTITION p_northcentral VALUES（'SD'，'WI'），PARTITION p_southcentral VALUES（'OK'，'TX'））; CREATE INDEX仓库_id_ix ON current_inventory（warehouse_id）本地平行的NOLOGGING; CREATE INDEX product_id_ix ON current_inventory（product_id）LOCAL PARALLEL NOLOGGING;</pre></div>
                     <!-- class="example" -->
                  </div>
               </div><a id="VLDBG14037"></a><a id="VLDBG1278"></a><div class="props_rev_3"><a id="GUID-8BADB67D-A0F4-4950-BCFD-8E72D9167EF8" name="GUID-8BADB67D-A0F4-4950-BCFD-8E72D9167EF8"></a><h4 id="VLDBG-GUID-8BADB67D-A0F4-4950-BCFD-8E72D9167EF8" class="sect4">何时使用复合列表范围分区</h4>
                  <div>
                     <p>复合列表范围分区对于在不同维度上访问的大型表非常有用。</p>
                     <p>对于最常用的维度，您可以专门将行映射到离散值上的分区。列表范围分区通常用于在列表分区中使用范围值的表，而范围列表分区通常用于范围分区内的离散列表值。列表范围分区不太常用于存储历史数据，即使等效方案都是合适的。可以使用区间列表分区来实现范围列表分区，而列表范围分区不支持区间分区。</p>
                     <p><a href="recommendations-partition-strategy.html#GUID-8BADB67D-A0F4-4950-BCFD-8E72D9167EF8__BABBHEII">示例3-13</a>显示了一个<code class="codeph">donations</code>表，用于存储不同货币的捐赠。根据金额，捐款分为小型，中型和高级。由于货币差异，范围不同。
                     </p>
                     <div class="example" id="GUID-8BADB67D-A0F4-4950-BCFD-8E72D9167EF8__BABBHEII">
                        <p class="titleinexample">示例3-13创建具有复合列表范围分区的表</p><pre class="oac_no_warn" dir="ltr">CREATE TABLE捐款（ID NUMBER，名称VARCHAR2（60），受益人VARCHAR2（80），payment_method VARCHAR2（30），货币VARCHAR2（3），金额NUMBER）按名单划分（货币）按范围减去（金额）（PARTITION p_eur VALUES） （'EUR'）（SUBPARTITION p_eur_small VALUES少于（8），SubPARTITION p_eur_medium值少于（80），SubPARTITION p_eur_high VALUES少于（MAXVALUE）），PARTITION p_gbp VALUES（'GBP'）（SUBPARTITION p_gbp_small VALUES少于（5） ），SUBPARTITION p_gbp_medium值小于（50），SUBPARTITION p_gbp_high值小于（MAXVALUE）），PARTITION p_aud_nzd_chf VALUES（'AUD'，'NZD'，'CHF'）（SUBPARTITION p_aud_nzd_chf_small VALUES少于（12），SUBPARTITION p_aud_nzd_chf_medium VALUES少于（120），SUBPARTITION p_aud_nzd_chf_high值小于（MAXVALUE）），PARTITION p_jpy VALUES（'JPY'）（SUBPARTITION p_jpy_small值小于（1200），SubPARTITION p_jpy_medium值小于（12000），SubPARTITION p_jpy_high值小于（MAXVALUE）），PARTITION p_inr VALUES（'INR'）（SUBPARTITION p_inr_small值小于（400），SUBPARTITION p_inr_medium值小于（4000），SUBPARTITION p_inr_high值小于（MAXVALUE）），PARTITION p_zar VALUES（'ZAR'） （SUBPARTITION p_zar_small值小于（70），SUBPARTITION p_zar_medium值小于（700），SubPARTITION p_zar_high值小于（MAXVALUE）），PARTITION p_default VALUES（DEFAULT）（SUBPARTITION p_default_small VALUES少于（10），SUBPARTITION p_default_medium值小于（100），SUBPARTITION p_default_high值低于（MAXVALUE）））启用行动;</pre></div>
                     <!-- class="example" -->
                  </div>
               </div>
            </div><a id="VLDBG1279"></a><div class="props_rev_3"><a id="GUID-A5B70F62-8D83-4CB0-905D-91204CF6EA97" name="GUID-A5B70F62-8D83-4CB0-905D-91204CF6EA97"></a><h3 id="VLDBG-GUID-A5B70F62-8D83-4CB0-905D-91204CF6EA97" class="sect3">何时使用间隔分区</h3>
               <div>
                  <p>区间分区几乎可用于范围分区的每个表，并对新分区使用固定间隔。</p>
                  <p>当插入该分区的数据时，数据库会自动创建间隔分区。在此之前，存在间隔分区但不为该分区创建段。</p>
                  <p>区间分区的好处是您不需要显式创建范围分区。除非创建具有不同间隔的范围分区，或者在创建范围分区时始终设置特定分区属性，否则应考虑使用间隔分区。您可以在区间定义中指定表空间列表。数据库以循环方式在提供的表空间列表中创建间隔分区。</p>
                  <p>如果升级应用程序并使用范围分区或复合范围 -  *分区，则可以轻松更改现有表定义以使用间隔分区。您无法手动将分区添加到间隔分区表。如果已自动创建新分区，则将来必须更改应用程序代码以防止显式创建范围分区。</p>
                  <p>以下SQL语句启动从范围分区到使用<code class="codeph">sales</code>表上的每月间隔分区的更改。
                  </p><pre class="oac_no_warn" dir="ltr">ALTER TABLE销售SET INTERVAL（NUMTOYMINTERVAL（1，'MONTH'））;</pre><p>您不能对引用分区表使用间隔分区。</p>
                  <p>可序列化事务不适用于间隔分区。将数据插入到没有段的间隔分区表的分区中会导致错误。</p>
               </div>
            </div><a id="VLDBG1280"></a><div class="props_rev_3"><a id="GUID-5E5BAB95-DE89-41CB-A61F-16A23A7A3B84" name="GUID-5E5BAB95-DE89-41CB-A61F-16A23A7A3B84"></a><h3 id="VLDBG-GUID-5E5BAB95-DE89-41CB-A61F-16A23A7A3B84" class="sect3">何时使用参考分区</h3>
               <div>
                  <p>引用分区在某些情况下很有用。</p>
                  <p>引用分区在以下方案中很有用：</p>
                  <ul style="list-style-type:disc">
                     <li>
                        <p>如果已将非主规则化或非规范化，则将主表中的列转换为子表，以便在两个表上获得分区修剪优势。</p>
                        <p>例如，您的<code class="codeph">orders</code>表存储<code class="codeph">order_date</code> ，但<code class="codeph">order_items</code>表（存储每个订单的一个或多个项目）不存储。要获取订单数据的历史分析不错的表现，你会传统复制<code class="codeph">order_date</code>列中的<code class="codeph">order_items</code>表的使用分区修剪<code class="codeph">order_items</code>表。
                        </p>
                        <p>您应该在这种情况下考虑引用分区，并避免重复<code class="codeph">order_date</code>列。连接两个表并在<code class="codeph">order_date</code>上使用谓词的查询自动受益于两个表上的分区修剪。
                        </p>
                     </li>
                     <li>
                        <p>如果经常连接两个大表，则表不会在连接键上进行分区，但是您希望利用分区智能连接。</p>
                        <p>引用分区隐式启用完全分区连接。</p>
                     </li>
                     <li>
                        <p>如果多个表中的数据具有相关的生命周期，则引用分区可以提供显着的可管理性优势。</p>
                        <p>针对主表的分区管理操作自动级联到其后代。例如，当您向主表添加分区时，该添加会自动传播到其所有后代。</p>
                        <p>要使用引用分区，必须在主表和引用表之间启用并强制执行外键关系。您可以级联引用分区表。</p>
                        <p>必须始终启用主键 - 外键关系，并且不能禁用。此关系也不能声明为延迟。这些是强制性要求，因为需要启用主键 - 外部关系来确定子表的数据放置。</p>
                     </li>
                  </ul>
               </div>
            </div><a id="VLDBG14038"></a><a id="VLDBG1281"></a><div class="props_rev_3"><a id="GUID-811EDE81-7016-43AF-9078-A435DD52EFA5" name="GUID-811EDE81-7016-43AF-9078-A435DD52EFA5"></a><h3 id="VLDBG-GUID-811EDE81-7016-43AF-9078-A435DD52EFA5" class="sect3">何时对虚拟列进行分区</h3>
               <div>
                  <p>对虚拟列进行分区可为派生列上的分区提供更大的灵活性。</p>
                  <p>通过虚拟列分区，您可以对表达式进行分区，该表达式可以使用其他列中的数据，并使用这些列执行计算。要用作分区键的虚拟列定义不支持PL / SQL函数调用。</p>
                  <p>虚拟列分区支持所有分区方法，以及性能和可管理性功能。要获得分区修剪的好处，请考虑使用虚拟列，如果经常使用不直接在列中捕获但可以派生的谓词来访问表。传统上，要获得分区修剪的好处，您必须添加一个单独的列来捕获和计算正确的值，并确保始终正确填充列以确保正确的查询检索。</p>
                  <p><a href="recommendations-partition-strategy.html#GUID-811EDE81-7016-43AF-9078-A435DD52EFA5__BABFDBEE">例3-14</a>显示了<code class="codeph">car_rentals</code>表。客户的确认号码包含两个字符的国家/地区名称，作为租车的地点。租车分析通常会评估区域模式，因此按国家/地区划分是有意义的。
                  </p>
                  <p>在此示例中，列<code class="codeph">country</code>定义为从确认编号派生的虚拟列。虚拟列不需要任何存储。如示例所示，虚拟列支持行移动。如果虚拟列在另一个分区中计算为不同的值，则数据库会将行迁移到其他分区。
                  </p>
                  <div class="example" id="GUID-811EDE81-7016-43AF-9078-A435DD52EFA5__BABFDBEE">
                     <p class="titleinexample">示例3-14创建具有用于分区的虚拟列的表</p><pre class="oac_no_warn" dir="ltr">CREATE TABLE car_rentals（id NUMBER NOT NULL，customer_id NUMBER NOT NULL，confirmation_number VARCHAR2（12）NOT NULL，car_id NUMBER，car_type VARCHAR2（10），requested_car_type VARCHAR2（10）NOT NULL，reservation_date DATE NOT NULL，start_date DATE NOT NULL，end_date DATE，country as（substr（confirmation_number，9,2）））分类列表（国家）HASH子客户（customer_id）SUBPARTITIONS 16（PARTITION north_america VALUES（'US'，'CA'，'MX'），PARTITION south_america VALUES （'BR'，'AR'，'PE'），PARTITION欧洲VALUES（'GB'，'DE'，'NL'，'BE'，'FR'，'ES'，'IT'，'CH'） ，PARTITION apac VALUES（'NZ'，'AU'，'IN'，'CN'））ENABLE ROW MOVEMENT;</pre></div>
                  <!-- class="example" -->
               </div>
            </div><a id="VLDBG1282"></a><div class="props_rev_3"><a id="GUID-8FB551B9-431A-4631-AF15-D17C08401E37" name="GUID-8FB551B9-431A-4631-AF15-D17C08401E37"></a><h3 id="VLDBG-GUID-8FB551B9-431A-4631-AF15-D17C08401E37" class="sect3">使用只读表空间时的注意事项</h3>
               <div>
                  <p>使用只读表时，请查看这些注意事项。</p>
                  <p>当在父表和子表之间定义参照完整性约束时，在外键上定义索引，并且该索引所在的表空间是只读的，然后约束的完整性检查在SQL中实现，而不是通过一致的读缓冲区访问。</p>
                  <p>这意味着如果子进程被分区，并且只有一些子分区的索引在只读表空间中，并且如果插入一个非读取子段，则在SX中的子表上获取TM入队模式。</p>
                  <p>SX模式与S请求不兼容，因此如果您尝试插入父级，则会阻止它，因为该插入尝试获取针对该子级的S TM队列。</p>
               </div>
            </div>
         </div>
      </article>
   </body>
</html>