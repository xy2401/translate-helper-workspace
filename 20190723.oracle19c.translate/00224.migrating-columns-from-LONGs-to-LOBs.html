<html lang="en-us" dir="ltr" xml:lang="en-us">
   <head>
      <meta http-equiv="Content-Type" content="text/html; charset=utf-8"></meta>
      <meta name="viewport" content="width=device-width, initial-scale=1"></meta>
      <meta http-equiv="X-UA-Compatible" content="IE=edge"></meta>
      <title>将列从LONG迁移到LOB</title>
      <meta property="og:site_name" content="Oracle Help Center"></meta>
      <meta property="og:title" content="Database SecureFiles and Large Objects Developer&#39;s Guide"></meta>
      <meta property="og:description" content=""></meta>
      <link rel="stylesheet" href="/sp_common/book-template/ohc-book-template/css/book.css"></link>
      <link rel="shortcut icon" href="/sp_common/book-template/ohc-common/img/favicon.ico"></link>
      <meta name="application-name" content="Database SecureFiles and Large Objects Developer&#39;s Guide"></meta>
      <meta name="generator" content="DITA Open Toolkit version 1.8.5 (Mode = doc)"></meta>
      <meta name="plugin" content="SP_docbuilder HTML plugin release 18.2.2"></meta>
      <link rel="alternate" href="securefiles-and-large-objects-developers-guide.pdf" title="PDF File" type="application/pdf"></link>
      <meta name="robots" content="all"></meta>
      <link rel="schema.dcterms" href="http://purl.org/dc/terms/"></link>
      <meta name="dcterms.created" content="2019-02-12T02:58:18-08:00"></meta>
      
      <meta name="dcterms.dateCopyrighted" content="1996, 2019"></meta>
      <meta name="dcterms.category" content="database"></meta>
      <meta name="dcterms.identifier" content="E96333-01"></meta>
      
      <meta name="dcterms.product" content="en/database/oracle/oracle-database/19"></meta>
      
      <link rel="prev" href="managing-LOBs.html" title="Previous" type="text/html"></link>
      <link rel="next" href="oracle-file-system.html" title="Next" type="text/html"></link>
      <script>
        document.write('<style type="text/css">');
        document.write('body > .noscript, body > .noscript ~ * { visibility: hidden; }');
        document.write('</style>');
     </script>
      <script src="/sp_common/book-template/requirejs/require.js" data-main="/sp_common/book-template/ohc-book-template/js/book-config"></script>
      <script>
            if (window.require === undefined) {
                document.write('<script data-main="sp_common/book-template/ohc-book-template/js/book-config" src="sp_common/book-template/requirejs/require.js"><\/script>');
                document.write('<link href="sp_common/book-template/ohc-book-template/css/book.css" rel="stylesheet"/>');
            }
        </script>
      <script type="application/json" id="ssot-metadata">{"primary":{"category":{"short_name":"database","element_name":"Database","display_in_url":true},"suite":{"short_name":"oracle","element_name":"Oracle","display_in_url":true},"product_group":{"short_name":"not-applicable","element_name":"Not applicable","display_in_url":false},"product":{"short_name":"oracle-database","element_name":"Oracle Database","display_in_url":true},"release":{"short_name":"19","element_name":"Release 19","display_in_url":true}}}</script>
      
    <meta name="dcterms.title" content="SecureFiles and Large Objects Developer&#39;s Guide"></meta>
    <meta name="dcterms.isVersionOf" content="ADLOB"></meta>
    <meta name="dcterms.release" content="Release 19"></meta>
  </head>
   <body dir="ltr">
      <div class="noscript alert alert-danger text-center" role="alert">
         <a href="managing-LOBs.html" class="pull-left"><span class="glyphicon glyphicon-chevron-left" aria-hidden="true"></span>上一页</a> <a href="oracle-file-system.html" class="pull-right">下一页<span class="glyphicon glyphicon-chevron-right" aria-hidden="true"></span></a> <span class="fa fa-exclamation-triangle" aria-hidden="true"></span>必须启用JavaScript才能正确显示此内容</div>
      <article>
         <header>
            <ol class="breadcrumb" vocab="http://schema.org/" typeof="BreadcrumbList">
               <li property="itemListElement" typeof="ListItem"><a href="index.html" property="item" typeof="WebPage"><span property="name">Database SecureFiles和Large Objects Developer's Guide</span></a></li>
               <li property="itemListElement" typeof="ListItem"><a href="LOB-administration.html" property="item" typeof="WebPage"><span property="name">LOB管理</span></a></li>
               <li class="active" property="itemListElement" typeof="ListItem">将列从LONG迁移到LOB</li>
            </ol>
            <a id="GUID-C6FC4583-4E71-4BDA-97CB-709EBC707773" name="GUID-C6FC4583-4E71-4BDA-97CB-709EBC707773"></a><a id="ADLOB008"></a>
            
            <h2 id="ADLOB-GUID-C6FC4583-4E71-4BDA-97CB-709EBC707773" class="sect2"><span class="enumeration_chapter">17将</span>列从LONG迁移到LOB</h2>
         </header>
         <div class="ind">
            <div>
               <p>有一些技术可以将使用<code class="codeph">LONG</code>数据类型的表迁移到LOB数据类型。
               </p>
               <p>话题：</p>
               <ul style="list-style-type:disc">
                  <li>
                     <p><a href="migrating-columns-from-LONGs-to-LOBs.html#GUID-12779894-59F6-4A6E-9089-1526F06396E4">将LONG列迁移到LOB列的好处</a></p>
                  </li>
                  <li>
                     <p><a href="migrating-columns-from-LONGs-to-LOBs.html#GUID-3D95C1C7-B8FF-4E9A-A94A-41FB93DF3659">将LONG列迁移到LOB列的前提条件</a></p>
                  </li>
                  <li>
                     <p><a href="migrating-columns-from-LONGs-to-LOBs.html#GUID-BF1FDC61-A0A3-4EBC-9C5C-11E0EF7113E2">使用utldtree.sql确定如何优化应用程序</a></p>
                  </li>
                  <li>
                     <p><a href="migrating-columns-from-LONGs-to-LOBs.html#GUID-8636A7D5-1149-40F9-A705-3903B5155D9B">将表从LONG转换为LOB数据类型</a></p>
                  </li>
                  <li>
                     <p><a href="migrating-columns-from-LONGs-to-LOBs.html#GUID-4B971F7F-5D26-4D82-923D-C1DF78B88822">将应用程序从LONG迁移到LOB</a></p>
                     <div class="infoboxnotealso" id="GUID-C6FC4583-4E71-4BDA-97CB-709EBC707773__GUID-3015B38F-EDCE-49E7-8372-DFF68F619C9E">
                        <p class="notep1">也可以看看：</p>
                        <p>为了支持各种编程环境中的LOB数据类型：</p>
                        <ul style="list-style-type:disc">
                           <li>
                              <p><a href="SQL-semantics-and-LOBs.html#GUID-47B94072-7782-40DD-BFD7-7D3D8A65B502" title="LOB支持各种SQL语义。">SQL语义和LOB</a></p>
                           </li>
                           <li>
                              <p><a href="PLSQL-semantics-for-LOBs.html#GUID-4147D9E6-173B-4D62-AC0A-C440CCE8A63D">LOB的PL / SQL语义</a></p>
                           </li>
                           <li>
                              <p><a href="data-interface-for-persistent-LOBs.html#GUID-4BFDD493-F3FE-451C-9B03-21669D635586">持久LOB的数据接口</a> 
                              </p>
                           </li>
                        </ul>
                     </div>
                  </li>
               </ul>
            </div><a id="ADLOB45614"></a><div class="props_rev_3"><a id="GUID-12779894-59F6-4A6E-9089-1526F06396E4" name="GUID-12779894-59F6-4A6E-9089-1526F06396E4"></a><h3 id="ADLOB-GUID-12779894-59F6-4A6E-9089-1526F06396E4" class="sect3">将LONG列迁移到LOB列的好处</h3>
               <div>
                  <p>将表列从<code class="codeph">LONG</code>数据类型迁移到LOB数据类型有很多好处。
                  </p>
                  <div class="infoboxnote" id="GUID-12779894-59F6-4A6E-9089-1526F06396E4__GUID-16D693A4-AE99-402C-8E94-D1348ECB6F87">
                     <p class="notep1">注意：</p>
                     <p>您可以使用各种技术执行以下任一操作：</p>
                     <ul style="list-style-type:disc">
                        <li>
                           <p>将<code class="codeph">LONG</code>类型的列转换为<code class="codeph">CLOB</code>或<code class="codeph">NCLOB</code>列</p>
                        </li>
                        <li>
                           <p>将<code class="codeph">LONG</code> <code class="codeph">RAW</code>类型的列转换为<code class="codeph">BLOB</code>类型列</p>
                        </li>
                     </ul>
                     <p>除非另有说明，否则本章中有关LONG到LOB转换的讨论适用于这两种数据类型转换。</p>
                  </div>
                  <p>这些项比较了各种应用程序开发方案中<code class="codeph">LONG</code>和LOB数据类型的语义：</p>
                  <ul style="list-style-type:disc">
                     <li>
                        <p><code class="codeph">LONG</code>类型列的数量是有限的。任何给定的表最多只能有一个<code class="codeph">LONG</code>类型列。表中的LOB类型列的数量不受限制。
                        </p>
                     </li>
                  </ul>
               </div>
            </div><a id="ADLOB45615"></a><div class="props_rev_3"><a id="GUID-3D95C1C7-B8FF-4E9A-A94A-41FB93DF3659" name="GUID-3D95C1C7-B8FF-4E9A-A94A-41FB93DF3659"></a><h3 id="ADLOB-GUID-3D95C1C7-B8FF-4E9A-A94A-41FB93DF3659" class="sect3">将LONG列迁移到LOB列的前提条件</h3>
               <div>
                  <p>在将<code class="codeph">LONG</code>列转换为LOB列之前，必须满足各种前提条件。
                  </p>
                  <div class="infoboxnotealso" id="GUID-3D95C1C7-B8FF-4E9A-A94A-41FB93DF3659__GUID-504B9059-71EC-45F3-BF33-B4BC8A8F2A0D">
                     <p class="notep1">也可以看看：</p>
                     <p>在转换表之前“将<span class="q"><a href="migrating-columns-from-LONGs-to-LOBs.html#GUID-4B971F7F-5D26-4D82-923D-C1DF78B88822">应用程序从LONG迁移到LOB</a> ”</span>以确定对LOB列的任何限制是否阻止您转换为LOB。
                     </p>
                  </div>
               </div><a id="ADLOB45616"></a><div class="props_rev_3"><a id="GUID-1B767610-36E7-4176-8DDA-CE776DF2B269" name="GUID-1B767610-36E7-4176-8DDA-CE776DF2B269"></a><h4 id="ADLOB-GUID-1B767610-36E7-4176-8DDA-CE776DF2B269" class="sect4">在转换为LOB之前删除LONG列上的域索引</h4>
                  <div>
                     <div class="p">在任何域索引<code class="codeph">LONG</code>列必须转换之前被丢弃<code class="codeph">LONG</code>列到LOB列。
                        <div class="infoboxnotealso" id="GUID-1B767610-36E7-4176-8DDA-CE776DF2B269__NOTE-1213-DFE53DE1">
                           <p class="notep1">也可以看看：</p>
                           <p><a href="migrating-columns-from-LONGs-to-LOBs.html#GUID-24BCAC5D-B4AA-4DDA-865F-CA172ACFBB32">重建从LONG转换为LOB数据类型的列的索引</a></p>
                        </div>
                     </div>
                  </div>
               </div><a id="ADLOB45617"></a><div class="props_rev_3"><a id="GUID-F235CF76-897A-41C8-8875-7D5F5177FD42" name="GUID-F235CF76-897A-41C8-8875-7D5F5177FD42"></a><h4 id="ADLOB-GUID-F235CF76-897A-41C8-8875-7D5F5177FD42" class="sect4">防止在转换为LOB数据类型的表上生成重做空间</h4>
                  <div>
                     <div class="section">
                        <p>生成重做空间可能会在转换<code class="codeph">LONG</code>列的过程中导致性能问题。仅当表具有<code class="codeph">LOGGING</code> ， <code class="codeph">LOGGING</code>在转换过程中记录表的重做更改。
                        </p>
                        <p>仅当LOB列的存储特征指示<code class="codeph">LOGGING</code>记录从<code class="codeph">LONG</code>转换为LOB的列的重做更改。 LOB列的日志记录设置（ <code class="codeph">LOGGING</code>或<code class="codeph">NOLOGGING</code> ）继承自创建LOB的表空间。
                        </p>
                        <p>要防止在迁移期间生成重做空间，请在迁移表之前执行以下操作（语法在BNF中）：</p>
                     </div>
                     <!-- class="section" -->
                     <ol>
                        <li class="stepexpand"><span><code class="codeph">ALTER TABLE Long_tab NOLOGGING;</code></span></li>
                        <li class="stepexpand"><span><code class="codeph">ALTER TABLE Long_tab MODIFY (long_col CLOB [DEFAULT &lt;</code> <span class="italic"><code class="codeph">default_val</code></span> <code class="codeph">&gt;]) LOB (long_col) STORE AS (NOCACHE NOLOGGING);</code></span><div>
                              <p>请注意，在<code class="codeph">STORE AS</code>子句中指定<code class="codeph">NOLOGGING</code>时，还必须指定<code class="codeph">NOCACHE</code> 。
                              </p>
                           </div>
                        </li>
                        <li class="stepexpand"><span><code class="codeph">ALTER TABLE Long_tab MODIFY LOB（long_col）（CACHE）;</code></span></li>
                        <li class="stepexpand"><span><code class="codeph">ALTER TABLE Long_tab LOGGING;</code></span></li>
                        <li class="stepexpand"><span>备份包含表和LOB列的表空间。</span></li>
                     </ol>
                  </div>
               </div>
            </div><a id="ADLOB45618"></a><div class="props_rev_3"><a id="GUID-BF1FDC61-A0A3-4EBC-9C5C-11E0EF7113E2" name="GUID-BF1FDC61-A0A3-4EBC-9C5C-11E0EF7113E2"></a><h3 id="ADLOB-GUID-BF1FDC61-A0A3-4EBC-9C5C-11E0EF7113E2" class="sect3">使用utldtree.sql确定如何优化应用程序</h3>
               <div>
                  <div class="section">
                     <p>将表从<code class="codeph">LONG</code>迁移到LOB列类型时，在PL / SQL中，应用程序的某些部分可能需要重写。您可以使用实用程序<code class="codeph">rdbms/admin/utldtree.sql</code>来确定哪些部分。
                     </p>
                     <p><code class="codeph">utldtree.sql</code>实用程序使您能够递归地查看依赖于给定对象的所有对象。例如，您可以查看依赖于具有<code class="codeph">LONG</code>列的表的所有对象。您只能看到您有权限的对象。
                     </p>
                     <p>有关如何使用<code class="codeph">utldtree.sql</code>的说明记录在文件本身中。此外，只有PL / SQL才需要<code class="codeph">utldtree.sql</code> 。对于SQL和OCI，您无需更改应用程序。
                     </p>
                  </div>
                  <!-- class="section" -->
               </div>
            </div><a id="ADLOB45619"></a><div class="props_rev_3"><a id="GUID-8636A7D5-1149-40F9-A705-3903B5155D9B" name="GUID-8636A7D5-1149-40F9-A705-3903B5155D9B"></a><h3 id="ADLOB-GUID-8636A7D5-1149-40F9-A705-3903B5155D9B" class="sect3">将表从LONG转换为LOB数据类型</h3>
               <div>
                  <div class="section">
                     <p>将现有表从<code class="codeph">LONG</code>数据类型迁移到LOB数据类型有各种问题和技术。
                     </p>
                     <p>话题：</p>
                  </div>
                  <!-- class="section" -->
                  <div class="section">
                     <ul style="list-style-type:disc">
                        <li>
                           <p><a href="migrating-columns-from-LONGs-to-LOBs.html#GUID-C94BB1FB-516F-40E5-B92F-879513A07463">迁移问题</a></p>
                        </li>
                        <li>
                           <p><span class="q">“ <a href="migrating-columns-from-LONGs-to-LOBs.html#GUID-54020D5A-CF56-4164-8711-68BDE84162EA">使用ALTER TABLE将LONG列转换为LOB列</a> ”</span></p>
                        </li>
                        <li>
                           <p><span class="q">“ <a href="migrating-columns-from-LONGs-to-LOBs.html#GUID-3744A2D0-F410-4DFE-B6DD-2BC6A56738D1">使用TO_LOB运算符将LONG复制到LOB列</a> ”</span></p>
                        </li>
                        <li>
                           <p><span class="q">“ <a href="migrating-columns-from-LONGs-to-LOBs.html#GUID-16B65DBF-790B-406F-B905-C0D1A0C38B32">在线重新定义具有LONG Columns的表</a> ”</span> ，其中高可用性至关重要</p>
                        </li>
                        <li>
                           <p>可以使用此实用程序进行转换时使用<span class="q">“ <a href="migrating-columns-from-LONGs-to-LOBs.html#GUID-30082C8B-2780-40E2-BE4F-F27185E7AFCA">使用Oracle Data Pump迁移数据库</a> ”</span></p>
                        </li>
                     </ul>
                  </div>
                  <!-- class="section" -->
               </div><a id="ADLOB45621"></a><div class="props_rev_3"><a id="GUID-C94BB1FB-516F-40E5-B92F-879513A07463" name="GUID-C94BB1FB-516F-40E5-B92F-879513A07463"></a><h4 id="ADLOB-GUID-C94BB1FB-516F-40E5-B92F-879513A07463" class="sect4">迁移问题</h4>
                  <div>
                     <p>有关移民的一般问题包括：</p>
                     <ul style="list-style-type:disc">
                        <li>
                           <p>所有<span class="bold"></span>为新LOB列维护先前<code class="codeph">LONG</code>列的约束。<code class="codeph">LONG</code>列允许的唯一约束是<code class="codeph">NULL</code>和<code class="codeph">NOT</code> <code class="codeph">NULL</code> 。要更改这些列的约束，或更改此表的任何其他列或属性，必须在后续的<code class="codeph">ALTER</code> <code class="codeph">TABLE</code>语句中执行此操作。
                           </p>
                        </li>
                        <li>
                           <p>如果未指定默认值，则<code class="codeph">LONG</code>列的默认值将成为LOB列的默认值。
                           </p>
                        </li>
                        <li>
                           <p>您桌面上的大多数现有触发器仍然可用，但<code class="codeph">UPDATE OF</code>触发器可能会导致问题。
                           </p>
                        </li>
                     </ul>
                     <div class="infoboxnotealso" id="GUID-C94BB1FB-516F-40E5-B92F-879513A07463__NOTE-133-DFE55F5E">
                        <p class="notep1">也可以看看：</p>
                        <p><a href="migrating-columns-from-LONGs-to-LOBs.html#GUID-4B971F7F-5D26-4D82-923D-C1DF78B88822">将应用程序从LONG迁移到LOB</a></p>
                     </div>
                  </div>
               </div><a id="ADLOB45620"></a><div class="props_rev_3"><a id="GUID-54020D5A-CF56-4164-8711-68BDE84162EA" name="GUID-54020D5A-CF56-4164-8711-68BDE84162EA"></a><h4 id="ADLOB-GUID-54020D5A-CF56-4164-8711-68BDE84162EA" class="sect4">使用ALTER TABLE将LONG列转换为LOB列</h4>
                  <div>
                     <div class="section">
                        <p>您可以使用SQL中的<code class="codeph">ALTER</code> <code class="codeph">TABLE</code>语句将<code class="codeph">LONG</code>列转换为LOB列。
                        </p>
                        <p>为此，请使用以下语法：</p><pre class="oac_no_warn" dir="ltr">ALTER TABLE [&lt;schema&gt;。] &lt;table_name&gt; MODIFY（&lt; <span class="bold">long_column_name</span> &gt; {CLOB | BLOB | NCLOB} <span class="bold">[DEFAULT &lt;default_value</span> &gt;]）[LOB_storage_clause];</pre><p>例如，如果您有一个按如下方式创建的表：</p><pre class="oac_no_warn" dir="ltr">CREATE TABLE Long_tab（id NUMBER，long_col LONG）;</pre><p>然后，您可以使用以下<code class="codeph">ALTER</code> <code class="codeph">TABLE</code>语句将表<code class="codeph">Long_tab</code>的列<code class="codeph">long_col</code>更改为数据类型<code class="codeph">CLOB</code> ：</p><pre class="oac_no_warn" dir="ltr">ALTER TABLE Long_tab MODIFY（long_col CLOB）;</pre><div class="infoboxnote" id="GUID-54020D5A-CF56-4164-8711-68BDE84162EA__GUID-6587BF67-4154-464E-85EE-0E01F4569DF8">
                           <p class="notep1">注意：</p>
                           <p><code class="codeph">ALTER</code> <code class="codeph">TABLE</code>语句将表的内容复制到新空间，并在操作结束时释放旧空间。这暂时使空间要求翻倍。
                           </p>
                        </div>
                        <p>请注意，使用<code class="codeph">ALTER</code> <code class="codeph">TABLE</code>语句将<code class="codeph">LONG</code>列转换为LOB列时，只允许以下选项：</p>
                     </div>
                     <!-- class="section" -->
                     <div class="section">
                        <ul style="list-style-type:disc">
                           <li>
                              <p><code class="codeph">DEFAULT</code> ，它允许您为LOB列指定默认值。
                              </p>
                           </li>
                           <li>
                              <p>可以在<code class="codeph">MODIFY</code>子句中指定<span class="italic"><code class="codeph">LOB_storage_clause</code></span> ，它允许您为转换列指定LOB存储特性。
                              </p>
                           </li>
                        </ul>
                        <p>将<code class="codeph">LONG</code>列转换为LOB类型列时，不允许使用其他<code class="codeph">ALTER</code> <code class="codeph">TABLE</code>选项。
                        </p>
                     </div>
                     <!-- class="section" -->
                  </div>
               </div><a id="ADLOB45622"></a><div class="props_rev_3"><a id="GUID-3744A2D0-F410-4DFE-B6DD-2BC6A56738D1" name="GUID-3744A2D0-F410-4DFE-B6DD-2BC6A56738D1"></a><h4 id="ADLOB-GUID-3744A2D0-F410-4DFE-B6DD-2BC6A56738D1" class="sect4">使用TO_LOB运算符将LONG复制到LOB列</h4>
                  <div>
                     <div class="section">
                        <p>如果您不想使用<code class="codeph">ALTER</code> <code class="codeph">TABLE</code> ，则可以使用<code class="codeph">LONG</code>列上的<code class="codeph">TO_LOB</code>运算符将其复制到LOB列。您可以将<code class="codeph">CREATE</code> <code class="codeph">TABLE</code> <code class="codeph">AS</code> <code class="codeph">SELECT</code>语句或<code class="codeph">INSERT</code> <code class="codeph">AS</code> <code class="codeph">SELECT</code>语句与<code class="codeph">TO_LOB</code>运算符一起使用，以将数据从<code class="codeph">LONG</code>列复制到<code class="codeph">CLOB</code>或<code class="codeph">NCLOB</code>列，或从<code class="codeph">LONG</code> <code class="codeph">RAW</code>列复制到<code class="codeph">BLOB</code>列。例如，如果您有一个包含<code class="codeph">LONG</code>列的表，其创建方式如下：</p><pre class="oac_no_warn" dir="ltr">CREATE TABLE Long_tab（id NUMBER，long_col LONG）;</pre><p>然后，您可以执行以下操作将列复制到LOB列：</p><pre class="oac_no_warn" dir="ltr">CREATE TABLE Lob_tab（id NUMBER，clob_col CLOB）; INSERT INTO Lob_tab SELECT id，TO_LOB（long_col）FROM long_tab;承诺;</pre><p>如果<code class="codeph">INSERT</code>返回错误（由于缺少撤消空间），则可以使用<code class="codeph">WHERE</code>子句以递增方式将<code class="codeph">LONG</code>数据迁移到LOB列。确保准确复制数据后，可以使用以下某个序列之一删除原始表并为新表创建视图或同义词：</p><pre class="oac_no_warn" dir="ltr">DROP TABLE Long_tab;从Lob_tab创建视图Long_tab（id，long_col）AS SELECT *;</pre><p>要么</p><pre class="oac_no_warn" dir="ltr">DROP TABLE Long_tab;创建SYNONYM Long_tab FOR Lob_tab;</pre><p>这一系列操作相当于将表<code class="codeph">Long_tab</code>的列<code class="codeph">Long_col</code>的数据类型从<code class="codeph">LONG</code>更改为<code class="codeph">CLOB</code> 。使用此技术，您必须在新表上重新创建任何约束，触发器，授权和索引。
                        </p>
                        <p>使用<code class="codeph">TO_LOB</code>运算符受以下限制：</p>
                     </div>
                     <!-- class="section" -->
                     <div class="section">
                        <ul style="list-style-type:disc">
                           <li>
                              <p>您可以使用<code class="codeph">TO_LOB</code>将数据复制到LOB列，但不能复制到对象类型的LOB属性。
                              </p>
                           </li>
                           <li>
                              <p>您不能将<code class="codeph">TO_LOB</code>与远程表一起使用。例如，以下语句不起作用：</p><pre class="oac_no_warn" dir="ltr">INSERT INTO tb1 @dblink（lob_col）SELECT TO_LOB（long_col）FROM tb2; INSERT INTO tb1（lob_col）SELECT TO_LOB（long_col）FROM tb2 @dblink; CREATE TABLE tb1 AS SELECT TO_LOB（long_col）FROM tb2 @dblink;</pre></li>
                           <li>
                              <p>在创建索引组织表时，不能在<code class="codeph">CREATE</code> <code class="codeph">TABLE</code> <code class="codeph">AS</code> <code class="codeph">SELECT</code>语句中使用<code class="codeph">TO_LOB</code>运算符将<code class="codeph">LONG</code>或<code class="codeph">LONG</code> <code class="codeph">RAW</code>列转换为LOB列。
                              </p>
                              <p>要解决此限制，请创建索引组织表，然后使用<code class="codeph">TO_LOB</code>运算符执行<code class="codeph">LONG</code>或<code class="codeph">LONG</code> <code class="codeph">RAW</code>列的<code class="codeph">INSERT</code> <code class="codeph">AS</code> <code class="codeph">SELECT</code> 。
                              </p>
                           </li>
                           <li>
                              <p>您不能在任何PL / SQL块中使用<code class="codeph">TO_LOB</code> 。
                              </p>
                           </li>
                        </ul>
                     </div>
                     <!-- class="section" -->
                  </div>
               </div><a id="ADLOB45624"></a><a id="ADLOB45625"></a><a id="ADLOB45623"></a><div class="props_rev_3"><a id="GUID-16B65DBF-790B-406F-B905-C0D1A0C38B32" name="GUID-16B65DBF-790B-406F-B905-C0D1A0C38B32"></a><h4 id="ADLOB-GUID-16B65DBF-790B-406F-B905-C0D1A0C38B32" class="sect4">使用LONG列的表的在线重新定义</h4>
                  <div>
                     <p>可以使用联机表重新定义来迁移具有<code class="codeph">LONG</code>和<code class="codeph">LONG</code> <code class="codeph">RAW</code>列的表。此技术适用于在高可用性至关重要的数据库表中迁移LONG列。
                     </p>
                     <p>要使用此技术，必须在重新定义过程中将<code class="codeph">LONG</code>列转换为LOB类型，如下所示：</p>
                     <ul style="list-style-type:disc">
                        <li>
                           <p>必须将任何<code class="codeph">LONG</code>列转换为<code class="codeph">CLOB</code>或<code class="codeph">NCLOB</code>列。
                           </p>
                        </li>
                        <li>
                           <p>任何<code class="codeph">LONG</code> <code class="codeph">RAW</code>列都必须转换为<code class="codeph">BLOB</code>列。
                           </p>
                        </li>
                     </ul>
                     <p>这种转换是利用执行<code class="codeph">TO_LOB()</code>操作者在的列映射<code class="codeph">DBMS_REDEFINITION.START_REDEF_TABLE()</code>过程。
                     </p>
                     <div class="infoboxnote" id="GUID-16B65DBF-790B-406F-B905-C0D1A0C38B32__GUID-BC6686A7-767F-4009-B880-B647DADF63CA">
                        <p class="notep1">注意：</p>
                        <p>除非按照本节中的说明将列转换为LOB类型，否则无法对具有<code class="codeph">LONG</code>或<code class="codeph">LONG</code> <code class="codeph">RAW</code>列的表执行在线重新定义。
                        </p>
                     </div>
                     <p>在线重新定义过程中涉及的常规任务在以下列表中给出。调出特定于转换<code class="codeph">LONG</code>和<code class="codeph">LONG</code> <code class="codeph">RAW</code>列的问题。有关此处未描述的在线重新定义过程的其他详细信息，请参阅本节末尾引用的相关文档。
                     </p>
                     <ul style="list-style-type:disc">
                        <li>
                           <p>创建一个空的临时表。重新定义过程完成后，此表保存迁移的数据。在临时表中：</p>
                           <ul style="list-style-type:disc">
                              <li>
                                 <p>为要迁移的原始表中的每个<code class="codeph">LONG</code>列定义<code class="codeph">CLOB</code>或<code class="codeph">NCLOB</code>列。
                                 </p>
                              </li>
                              <li>
                                 <p>为要迁移的原始表中的每个<code class="codeph">LONG</code> <code class="codeph">RAW</code>列定义<code class="codeph">BLOB</code>列。
                                 </p>
                              </li>
                           </ul>
                        </li>
                        <li>
                           <p>开始重新定义过程。要做到这一点，请拨打<code class="codeph">DBMS_REDEFINITION.START_REDEF_TABLE</code>并使用通过列映射<code class="codeph">TO_LOB</code>操作如下：</p><pre class="oac_no_warn" dir="ltr">DBMS_REDEFINITION.START_REDEF_TABLE（'schema_name'，'original_table'，'interim_table'，'TO_LOB（ <span class="italic"><code class="codeph">long_col_name</code></span> ） <span class="italic"><code class="codeph">lob_col_name</code></span> '，'options_flag'，'orderby_cols'）;</pre><p>其中<span class="italic"><code class="codeph">long_col_name</code></span>是要在原始表中转换的<code class="codeph">LONG</code>或<code class="codeph">LONG</code> <code class="codeph">RAW</code>列的名称， <span class="italic"><code class="codeph">lob_col_name</code></span>是临时表中LOB列的名称。此LOB列保存转换后的数据。
                           </p>
                        </li>
                        <li>
                           <p>按照相关文档中的说明调用<code class="codeph">DBMS_REDEFINITION.COPY_TABLE_DEPENDENTS</code>过程。
                           </p>
                        </li>
                        <li>
                           <p>按照相关文档中的说明调用<code class="codeph">DBMS_REDEFINITION.FINISH_REDEF_TABLE</code>过程。
                           </p>
                        </li>
                     </ul>
                     <div class="section">
                        <p class="subhead3" id="GUID-16B65DBF-790B-406F-B905-C0D1A0C38B32__GUID-ED6FCF72-9CEB-49E7-8ED2-07B0F28B5EE4">并行在线重新定义</p>
                     </div>
                     <!-- class="section" -->
                     <div class="section">
                        <p>在具有足够并行执行资源的系统上，可以在以下条件下并行执行<code class="codeph">LONG</code>列到LOB列的重新定义：</p>
                        <p>在目标表未分区的情况下：</p>
                        <ul style="list-style-type:disc">
                           <li>
                              <p>用于在目标表中存储LOB列的段属于具有自动段空间管理的本地管理表空间（ <a id="d85482e1468" class="indexterm-anchor"></a> ASSM）启用，现在是默认值。
                              </p>
                           </li>
                           <li>
                              <p>从一个<code class="codeph">LONG</code>列到一个LOB列有一个简单的映射，目标表只有一个LOB列。
                              </p>
                           </li>
                        </ul>
                        <p>在目标表被分区的情况下，应用用于分区的并行执行的常规方法。当目标表被分区时，则并行执行在线重新定义。</p>
                     </div>
                     <!-- class="section" -->
                     <div class="section">
                        <p class="subhead3" id="GUID-16B65DBF-790B-406F-B905-C0D1A0C38B32__GUID-3CDE7050-1296-4870-93BC-FBCED636213D">在线重新定义的示例</p>
                     </div>
                     <!-- class="section" -->
                     <div class="section">
                        <p>以下示例演示了使用LOB列的在线重新定义。</p><pre class="oac_no_warn" dir="ltr">REM在线重新定义所需的授予权限。GRANT执行ON DBMS_REDEFINITION到pm;给下午任何表格;下午给任何一张桌子;授权锁定任何表格到下午;授予创建任何表到下午; GRANT选择任何表到下午; REM执行克隆依赖对象所需的权限。授予创建任何触发器到下午;授予下午创造任何指数; connect pm / <span class="italic">passwd</span> drop table cust; create table cust（c_id number primary key，c_zip number，c_name varchar（30）default null，c_long long）;插入到cust值（1,94065，'hhh'，'ttt'）; - 创建临时表 - 不需要指定约束，因为它们是从原始表复制的。create table cust_int（c_id number not null，c_zip number，c_name varchar（30）default null，c_long clob）;声明col_mapping varchar2（1000）; BEGIN  - 将临时表中的所有列映射到原始表col_mapping：='c_id c_id，'|| 'c_zip c_zip，'|| 'c_name c_name，'|| 'to_lob（c_long）c_long'; dbms_redefinition.start_redef_table（'pm'，'cust'，'cust_int'，col_mapping）;结束; / declare error_count pls_integer：= 0; BEGIN dbms_redefinition.copy_table_dependents（'pm'，'cust'，'cust_int'，1，true，true，true，false，error_count）; dbms_output.put_line（'errors：='|| to_char（error_count））;结束; / exec dbms_redefinition.finish_redef_table（'pm'，'cust'，'cust_int'）; - 删除临时表删除表cust_int; desc cust; - 以下插入语句失败。这说明 - 迁移后保留c_id列的主键约束。插入到cust值（1,94065，'hhh'，'ttt'）; select * from cust;</pre><div class="infoboxnote" id="GUID-16B65DBF-790B-406F-B905-C0D1A0C38B32__GUID-3073BA3C-401B-4AA8-A7D8-24B7D5B22885">
                           <p class="notep1">注意：</p>
                           <p>相关文档提供了有关重新定义过程的其他详细信息：</p>
                           <ul style="list-style-type:disc">
                              <li>
                                 <p><a href="../admin/managing-tables.html#ADMIN01514" target="_blank"><span class="italic">“Oracle数据库管理员指南”</span></a>提供了在线重新定义表的详细过程和示例。
                                 </p>
                              </li>
                              <li>
                                 <p><a href="../arpls/DBMS_REDEFINITION.html#ARPLS042" target="_blank"><span class="italic">Oracle Database PL / SQL包和类型参考</span></a>包括有关<code class="codeph">DBMS_REDEFINITION</code>包中过程使用的语法和其他详细信息。
                                 </p>
                              </li>
                           </ul>
                        </div>
                     </div>
                     <!-- class="section" -->
                  </div>
               </div><a id="ADLOB45626"></a><div class="props_rev_3"><a id="GUID-30082C8B-2780-40E2-BE4F-F27185E7AFCA" name="GUID-30082C8B-2780-40E2-BE4F-F27185E7AFCA"></a><h4 id="ADLOB-GUID-30082C8B-2780-40E2-BE4F-F27185E7AFCA" class="sect4">使用Oracle Data Pump迁移数据库</h4>
                  <div>
                     <div class="section">
                        <p>如果要将数据导出为迁移到新数据库的一部分，请在目标数据库上使用LOB列创建表，Data Pump将隐式调用LONG-to-LOB函数。</p>
                        <div class="infoboxnotealso" id="GUID-30082C8B-2780-40E2-BE4F-F27185E7AFCA__FORDETAILSONUSINGORACLEDATAPUMPREFE-DFE5775B">
                           <p class="notep1">也可以看看：</p>
                           <p>有关使用Oracle Data Pump的更多信息，请<a href="../sutil/oracle-data-pump-overview.html#SUTIL-GUID-17FAE261-0972-4220-A2E4-44D479F519D4" target="_blank"><span><cite>参见Oracle数据库实用程序</cite></span></a></p>
                        </div>
                     </div>
                     <!-- class="section" -->
                  </div>
               </div>
            </div><a id="ADLOB45627"></a><div class="props_rev_3"><a id="GUID-4B971F7F-5D26-4D82-923D-C1DF78B88822" name="GUID-4B971F7F-5D26-4D82-923D-C1DF78B88822"></a><h3 id="ADLOB-GUID-4B971F7F-5D26-4D82-923D-C1DF78B88822" class="sect3">将应用程序从LONG迁移到LOB</h3>
               <div>
                  <p><code class="codeph">LONG</code>和LOB数据类型之间存在差异，这些差异可能会影响您的应用程序迁移计划或要求您修改应用程序。
                  </p>
               </div>
               <div class="props_rev_3"><a id="GUID-25C0FCCB-6E55-475A-8BC0-432686B85A5E" name="GUID-25C0FCCB-6E55-475A-8BC0-432686B85A5E"></a><h4 id="ADLOB-GUID-25C0FCCB-6E55-475A-8BC0-432686B85A5E" class="sect4">关于将应用程序从Longs迁移到LOB</h4>
                  <div>
                     <p>在PL / SQL和OCI环境中使用<code class="codeph">LONG</code>数据类型的大多数API都得到了增强，也可以使用LOB数据类型。
                     </p>
                     <p>这些API统称<span class="italic">为持久LOB</span>的<span class="italic">数据接口</span> ，或简称为<span class="italic">数据接口</span> 。除此之外，数据接口还具有以下优点：</p>
                     <ul style="list-style-type:disc">
                        <li>
                           <p>PL / SQL和OCI应用程序中所需的更改最少，这些应用程序使用具有从<code class="codeph">LONG</code>到LOB数据类型转换的列的表。
                           </p>
                        </li>
                        <li>
                           <p>您可以在应用程序中使用LOB数据类型，而无需处理LOB定位器。</p>
                           <div class="infoboxnotealso" id="GUID-25C0FCCB-6E55-475A-8BC0-432686B85A5E__GUID-A8C291D8-6C12-4400-B978-244B43F1C2B5">
                              <p class="notep1">也可以看看：</p>
                              <ul style="list-style-type:disc">
                                 <li>
                                    <p><a href="data-interface-for-persistent-LOBs.html#GUID-4BFDD493-F3FE-451C-9B03-21669D635586">持久性LOB的数据接口，以</a>获取有关数据接口中包含的PL / SQL和OCI API的详细信息。
                                    </p>
                                 </li>
                                 <li>
                                    <p><a href="SQL-semantics-and-LOBs.html#GUID-47B94072-7782-40DD-BFD7-7D3D8A65B502" title="LOB支持各种SQL语义。">SQL语义和LOB</a>有关LOB数据类型支持的SQL语法的详细信息。
                                    </p>
                                 </li>
                                 <li>
                                    <p><a href="PLSQL-semantics-for-LOBs.html#GUID-4147D9E6-173B-4D62-AC0A-C440CCE8A63D">LOB的PL / SQL语义，</a>用于LOB数据类型支持的PL / SQL语法的详细信息。
                                    </p>
                                 </li>
                              </ul>
                           </div>
                        </li>
                     </ul>
                  </div>
               </div><a id="ADLOB45628"></a><div class="props_rev_3"><a id="GUID-81417086-F005-40EA-80A3-44EBE4CAEEEB" name="GUID-81417086-F005-40EA-80A3-44EBE4CAEEEB"></a><h4 id="ADLOB-GUID-81417086-F005-40EA-80A3-44EBE4CAEEEB" class="sect4">群集表中不允许使用LOB列</h4>
                  <div>
                     <p>群集表中不允许使用LOB列，而允许使用<code class="codeph">LONG</code>列。如果表是集群的一部分，则任何<code class="codeph">LONG</code>或<code class="codeph">LONG</code> <code class="codeph">RAW</code>列都不能更改为LOB列。
                     </p>
                  </div>
               </div><a id="ADLOB45629"></a><div class="props_rev_3"><a id="GUID-8DB8045E-B8FD-4EAE-BBC7-F37D8A612833" name="GUID-8DB8045E-B8FD-4EAE-BBC7-F37D8A612833"></a><h4 id="ADLOB-GUID-8DB8045E-B8FD-4EAE-BBC7-F37D8A612833" class="sect4">触发器更新后不允许使用LOB列</h4>
                  <div>
                     <p>您不能在<code class="codeph">AFTER UPDATE</code> <code class="codeph">OF</code>触发器的<code class="codeph">UPDATE</code> <code class="codeph">OF</code>列表中包含LOB列。此类触发器允许使用<code class="codeph">LONG</code>列。例如，以下create trigger语句无效：</p><pre class="oac_no_warn" dir="ltr">CREATE TABLE t（lobcol CLOB）;创新TRIGGER触发更新后更新...;</pre><pre class="oac_no_warn" dir="ltr"></pre><p>所有其他触发器都适用于LOB列。</p>
                  </div>
               </div><a id="ADLOB45630"></a><div class="props_rev_3"><a id="GUID-24BCAC5D-B4AA-4DDA-865F-CA172ACFBB32" name="GUID-24BCAC5D-B4AA-4DDA-865F-CA172ACFBB32"></a><h4 id="ADLOB-GUID-24BCAC5D-B4AA-4DDA-865F-CA172ACFBB32" class="sect4">重建从LONG转换为LOB数据类型的列的索引</h4>
                  <div>
                     <div class="section">
                        <p>索引<span class="bold"></span>在将任何<code class="codeph">LONG</code>列转换为LOB列之后，必须手动重建要迁移的表的任何列。这包括基于函数的索引。
                        </p>
                        <p><code class="codeph">LONG</code>列上的任何基于函数的索引在转换过程中都不可用，必须在转换后重建。使用基于函数的索引的应用程序代码在转换后无需修改即可使用。
                        </p>
                        <p>需要注意的是，在任何域指标<code class="codeph">LONG</code>列必须转换之前被丢弃<code class="codeph">LONG</code>列到LOB列。您可以在转换后重建域索引。
                        </p>
                        <p>要在转换后重建索引，请使用以下步骤：</p>
                     </div>
                     <!-- class="section" -->
                     <ol>
                        <li class="stepexpand"><span>从原始表中选择索引，如下所示：</span><div><pre class="oac_no_warn" dir="ltr">SELECT index_name FROM user_indexes WHERE table_name ='LONG_TAB';</pre><div class="infoboxnote" id="GUID-24BCAC5D-B4AA-4DDA-865F-CA172ACFBB32__GUID-293FDAA1-90C2-4D17-BF3D-166F7B0ADA4A">
                                 <p class="notep1">注意：</p>
                                 <p>表名必须在此查询中大写。</p>
                              </div>
                           </div>
                        </li>
                        <li class="stepexpand"><span>对于选定的索引，请使用以下命令：</span><div><pre class="oac_no_warn" dir="ltr">ALTER INDEX &lt;index&gt; REBUILD</pre></div>
                        </li>
                     </ol>
                  </div>
               </div><a id="ADLOB45631"></a><div class="props_rev_3"><a id="GUID-9D6A3BE9-05F8-4461-8301-BF37F5C69341" name="GUID-9D6A3BE9-05F8-4461-8301-BF37F5C69341"></a><h4 id="ADLOB-GUID-9D6A3BE9-05F8-4461-8301-BF37F5C69341" class="sect4">空LOB与NULL和零长度LONG相比较</h4>
                  <div>
                     <p>LOB列可以保存<span class="italic">空</span> LOB。空LOB是完全初始化但未填充数据的LOB定位器。由于<code class="codeph">LONG</code>数据类型不使用定位符，因此<span class="italic">空</span>概念不适用于<code class="codeph">LONG</code>数据类型。
                     </p>
                     <p>插入初始值为<code class="codeph">NULL</code>或空字符串文字的LOB列值和<code class="codeph">LONG</code>列值都具有<code class="codeph">NULL</code>值。因此，在将列转换为LOB类型列后，在<code class="codeph">LONG</code>列中使用<code class="codeph">NULL</code>或零长度值的应用程序代码的功能完全相同。
                     </p>
                     <p>相反，初始化为空的LOB具有非<code class="codeph">NULL</code>值，如以下示例所示：</p><pre class="oac_no_warn" dir="ltr">CREATE TABLE long_tab（id NUMBER，long_col LONG）; CREATE TABLE lob_tab（id NUMBER，lob_col CLOB）; INSERT INTO long_tab值（1，NULL）; REM零长度字符串在LONG列中插入NULL：INSERT INTO long_tab values（1，''）; INSERT INTO lob_tab值（1，NULL）; REM零长度字符串在LOB列中插入NULL：INSERT INTO lob_tab values（1，''）; REM插入空LOB会插入非NULL值：INSERT INTO lob_tab values（1，empty_clob（））; DROP TABLE long_tab; DROP TABLE lob_tab;</pre></div>
               </div><a id="ADLOB45632"></a><div class="props_rev_3"><a id="GUID-4D1CFD16-CCBD-406D-AA98-225D4774BB1C" name="GUID-4D1CFD16-CCBD-406D-AA98-225D4774BB1C"></a><h4 id="ADLOB-GUID-4D1CFD16-CCBD-406D-AA98-225D4774BB1C" class="sect4">使用锚定类型进行重载</h4>
                  <div>
                     <div class="section">
                        <p>对于使用锚定类型的应用程序，某些重载变量在转换为LOB期间会解析为不同的目标。例如，假设程序<code class="codeph">p</code>超载了规范1和2：</p><pre class="oac_no_warn" dir="ltr">程序p（l long）是...; - （规范1）程序p（c clob）是......; - （规格2）</pre><p>和程序调用：</p><pre class="oac_no_warn" dir="ltr">声明var longtab.longcol％type;开始 ...P（VAR）; ...结束;</pre><p>在从<code class="codeph">LONG</code>列迁移到LOB列之前，此调用将解析为规范1。将<code class="codeph">longtab</code>迁移到LOB列后，此调用将解析为规范2。请注意，如果规范1中的参数类型是<code class="codeph">CHAR</code> ， <code class="codeph">VARCHAR2</code> ， <code class="codeph">RAW</code> ， <code class="codeph">LONG</code> <code class="codeph">RAW</code> 。</p>
                        <p>如果已将表从<code class="codeph">LONG</code>列迁移到LOB列，则必须手动检查应用程序并确定是否必须更改重载过程。
                        </p>
                        <p>在迁移之前包含带有LOB参数的重载过程的某些应用程序可能仍会中断。这包括不使用<code class="codeph">LONG</code>锚定类型的应用程序。例如，给定以下规范（1和2）以及程序<code class="codeph">p</code>过程调用：</p><pre class="oac_no_warn" dir="ltr">程序p（n号）是......; - （1）程序p（c clob）是......; - （2）p（'123'）; - 程序调用</pre><p>在迁移之前，唯一允许的转换是<code class="codeph">CHAR</code>到<code class="codeph">NUMBER</code> ，因此将选择规范1。迁移后，允许两次转换，因此调用不明确并引发重载错误。
                        </p>
                     </div>
                     <!-- class="section" -->
                  </div>
               </div><a id="ADLOB45633"></a><div class="props_rev_3"><a id="GUID-97D40D64-B271-45F3-96F6-AD1D20B478A9" name="GUID-97D40D64-B271-45F3-96F6-AD1D20B478A9"></a><h4 id="ADLOB-GUID-97D40D64-B271-45F3-96F6-AD1D20B478A9" class="sect4">LOB数据类型不支持某些隐式转换</h4>
                  <div>
                     <p>PL / SQL允许从<code class="codeph">NUMBER</code> ， <code class="codeph">DATE</code> ， <code class="codeph">ROW_ID</code> ， <code class="codeph">BINARY_INTEGER</code>和<code class="codeph">PLS_INTEGER</code>数据类型隐式转换为<code class="codeph">LONG</code> ;但是，不允许从这些数据类型到LOB的隐式转换。
                     </p>
                     <p>如果您的应用程序使用这些隐式转换，则必须使用<code class="codeph">TO_CHAR</code>运算符为字符数据显式转换这些类型，或者为二进制数据使用<code class="codeph">TO_RAW</code>运算符。例如，如果您的应用程序具有分配操作，例如：</p><pre class="oac_no_warn" dir="ltr">number_var：= long_var; - 转换后RHS是一个LOB变量。
</pre><p>那么你必须修改你的代码如下：</p><pre class="oac_no_warn" dir="ltr">number_var：= TO_CHAR（long_var）; - 假设long_var在转换后的类型为CLOB</pre><p>LOB类型不支持以下转换：</p>
                     <ul style="list-style-type:disc">
                        <li>
                           <p><code class="codeph">BLOB</code>到<code class="codeph">VARCHAR2</code> ， <code class="codeph">CHAR</code>或<code class="codeph">LONG</code></p>
                        </li>
                        <li>
                           <p><code class="codeph">CLOB</code>到<code class="codeph">RAW</code>或<code class="codeph">LONG</code> <code class="codeph">RAW</code></p>
                        </li>
                     </ul>
                     <p>这适用于发生隐式转换的所有操作。例如，如果应用程序中有<code class="codeph">SELECT</code>语句，如下所示：</p><pre class="oac_no_warn" dir="ltr">选择long_raw_column INTO my_varchar2 VARIABLE from my_table</pre><pre class="oac_no_warn" dir="ltr"></pre><p>转换表后， <code class="codeph">long_raw_column</code>是<code class="codeph">BLOB</code> ，然后<code class="codeph">SELECT</code>语句产生错误。要使此转换有效，必须使用<code class="codeph">TO_RAW</code>运算符将<code class="codeph">BLOB</code>显式转换为<code class="codeph">RAW</code> ，如下所示：</p><pre class="oac_no_warn" dir="ltr">SELECT TO_RAW（long_raw_column）INTO my_varchar2 VARIABLE from my_table</pre><pre class="oac_no_warn" dir="ltr"></pre><p>这同样适用于将<code class="codeph">CLOB</code>选择为<code class="codeph">RAW</code>变量，或者将<code class="codeph">CLOB</code>分配给<code class="codeph">RAW</code>和<code class="codeph">BLOB</code>分配给<code class="codeph">VARCHAR2</code> 。
                     </p>
                     <p> </p>
                  </div>
               </div>
            </div>
         </div>
      </article>
   </body>
</html>