<html lang="en-us" dir="ltr" xml:lang="en-us">
   <head>
      <meta http-equiv="Content-Type" content="text/html; charset=utf-8"></meta>
      <meta name="viewport" content="width=device-width, initial-scale=1"></meta>
      <meta http-equiv="X-UA-Compatible" content="IE=edge"></meta>
      <meta name="abstract" content="An explanation is given of how to use the Java Architecture for XML Binding (JAXB) class generator."></meta>
      <meta name="description" content="An explanation is given of how to use the Java Architecture for XML Binding (JAXB) class generator."></meta>
      <title>使用JAXB类生成器</title>
      <meta property="og:site_name" content="Oracle Help Center"></meta>
      <meta property="og:title" content="Programmer&#39;s Guide"></meta>
      <meta property="og:description" content="An explanation is given of how to use the Java Architecture for XML Binding (JAXB) class generator."></meta>
      <link rel="stylesheet" href="/sp_common/book-template/ohc-book-template/css/book.css"></link>
      <link rel="shortcut icon" href="/sp_common/book-template/ohc-common/img/favicon.ico"></link>
      <meta name="application-name" content="Programmer&#39;s Guide"></meta>
      <meta name="generator" content="DITA Open Toolkit version 1.8.5 (Mode = doc)"></meta>
      <meta name="plugin" content="SP_docbuilder HTML plugin release 18.2.2"></meta>
      <link rel="alternate" href="xml-developers-kit-programmers-guide.pdf" title="PDF File" type="application/pdf"></link>
      <meta name="robots" content="all"></meta>
      <link rel="schema.dcterms" href="http://purl.org/dc/terms/"></link>
      <meta name="dcterms.created" content="2019-01-11T05:58:48-08:00"></meta>
      
      <meta name="dcterms.dateCopyrighted" content="2001, 2019"></meta>
      <meta name="dcterms.category" content="database"></meta>
      <meta name="dcterms.identifier" content="E96292-01"></meta>
      
      <meta name="dcterms.product" content="en/database/oracle/oracle-database/19"></meta>
      
      <link rel="prev" href="using-XML-schema-processor-for-Java.html" title="Previous" type="text/html"></link>
      <link rel="next" href="using-XML-pipeline-processor-for-Java.html" title="Next" type="text/html"></link>
      <script>
        document.write('<style type="text/css">');
        document.write('body > .noscript, body > .noscript ~ * { visibility: hidden; }');
        document.write('</style>');
     </script>
      <script src="/sp_common/book-template/requirejs/require.js" data-main="/sp_common/book-template/ohc-book-template/js/book-config"></script>
      <script>
            if (window.require === undefined) {
                document.write('<script data-main="sp_common/book-template/ohc-book-template/js/book-config" src="sp_common/book-template/requirejs/require.js"><\/script>');
                document.write('<link href="sp_common/book-template/ohc-book-template/css/book.css" rel="stylesheet"/>');
            }
        </script>
      <script type="application/json" id="ssot-metadata">{"primary":{"category":{"short_name":"database","element_name":"Database","display_in_url":true},"suite":{"short_name":"oracle","element_name":"Oracle","display_in_url":true},"product_group":{"short_name":"not-applicable","element_name":"Not applicable","display_in_url":false},"product":{"short_name":"oracle-database","element_name":"Oracle Database","display_in_url":true},"release":{"short_name":"19","element_name":"Release 19","display_in_url":true}}}</script>
      
    <meta name="dcterms.title" content="XML Developers Kit Programmers Guide"></meta>
    <meta name="dcterms.isVersionOf" content="ADXDK"></meta>
    <meta name="dcterms.release" content="Release 19"></meta>
  </head>
   <body dir="ltr">
      <div class="noscript alert alert-danger text-center" role="alert">
         <a href="using-XML-schema-processor-for-Java.html" class="pull-left"><span class="glyphicon glyphicon-chevron-left" aria-hidden="true"></span>上一页</a> <a href="using-XML-pipeline-processor-for-Java.html" class="pull-right">下一页<span class="glyphicon glyphicon-chevron-right" aria-hidden="true"></span></a> <span class="fa fa-exclamation-triangle" aria-hidden="true"></span>必须启用JavaScript才能正确显示此内容</div>
      <article>
         <header>
            <ol class="breadcrumb" vocab="http://schema.org/" typeof="BreadcrumbList">
               <li property="itemListElement" typeof="ListItem"><a href="index.html" property="item" typeof="WebPage"><span property="name">程序员指南</span></a></li>
               <li property="itemListElement" typeof="ListItem"><a href="XDK-for-Java.html" property="item" typeof="WebPage"><span property="name">Oracle XML Developer's Kit for Java</span></a></li>
               <li class="active" property="itemListElement" typeof="ListItem">使用JAXB类生成器</li>
            </ol>
            <a id="GUID-97D4F251-F7C3-49A1-B478-3387BC3D3C15" name="GUID-97D4F251-F7C3-49A1-B478-3387BC3D3C15"></a><a id="ADXDK997"></a><a id="ADXDK6000"></a>
            
            <h2 id="ADXDK-GUID-97D4F251-F7C3-49A1-B478-3387BC3D3C15" class="sect2"><span class="enumeration_chapter">18</span>使用JAXB类生成器</h2>
         </header>
         <div class="ind">
            <div>
               <p>解释了如何使用Java Architecture for XML Binding（JAXB）类生成器。</p>
               <div class="section"> </div>
               <!-- class="section" -->
               <div class="infoboxnote" id="GUID-97D4F251-F7C3-49A1-B478-3387BC3D3C15__GUID-AF000931-D7E5-4436-A8A9-26FA5649095A">
                  <p class="notep1">注意：</p>
                  <p>将Java Architecture for XML Binding（JAXB）类生成器用于新应用程序，以利用可扩展标记语言（XML）数据的对象绑定功能。不推荐使用Oracle9i类生成器。Oracle数据库10g支持Oracle9i类生成器以实现向后兼容。</p>
               </div>
            </div><a id="ADXDK998"></a><a id="ADXDK19289"></a><div class="props_rev_3"><a id="GUID-26B7DCCE-8447-4D51-8E80-90B691346F17" name="GUID-26B7DCCE-8447-4D51-8E80-90B691346F17"></a><h3 id="ADXDK-GUID-26B7DCCE-8447-4D51-8E80-90B691346F17" class="sect3">JAXB类生成器简介</h3>
               <div>
                  <p>介绍JAXB类生成器的主题包括先决条件，标准和规范，编组和解组，验证和自定义。</p>
                  <div class="section"> </div>
                  <!-- class="section" -->
               </div><a id="ADXDK19290"></a><div class="props_rev_3"><a id="GUID-A292C49D-68F6-42ED-9C7A-460347C87252" name="GUID-A292C49D-68F6-42ED-9C7A-460347C87252"></a><h4 id="ADXDK-GUID-A292C49D-68F6-42ED-9C7A-460347C87252" class="sect4">使用JAXB类生成器的先决条件</h4>
                  <div>
                     <p>列出了使用JAXB类生成器的先决条件。</p>
                     <p>本章假设您对这些主题有一定的了解：</p>
                     <ul style="list-style-type:disc">
                        <li>
                           <p><a href="glossary.html#GUID-9A300561-B381-40D5-824C-153427438F3D"><span class="xrefglossterm">用于XML绑定的Java体系结构（JAXB）</span></a> 。有关JAXB的详细介绍，请参阅<a href="preface.html#GUID-2CD1F6B6-C8EC-42E3-97F2-589AABF9AFFB" title="列出了与此文档相关的Oracle资源。">相关文档中</a>列出的XML资源。
                           </p>
                        </li>
                        <li>
                           <p><a href="glossary.html#GUID-B1E6F2C9-39D7-42D5-817B-6210231ABF97" title="XML Schema语言也称为XML Schema，是一种W3C建议，用于在XML文档中使用简单数据类型和复杂结构。它解决了目前DTD中缺乏的领域，包括数据类型的定义和验证。"><span class="xrefglossterm">XML Schema语言</span></a> 。有关概述和建议阅读的链接，请参阅<a href="using-XML-schema-processor-for-Java.html#GUID-F41C7DA2-A3DF-463B-A08C-24E8F0621450" title="这里的主题介绍了如何使用Java的可扩展标记语言（XML）模式处理器。">使用XML Schema Processor for Java</a> 。
                           </p>
                        </li>
                     </ul>
                  </div>
               </div><a id="ADXDK19291"></a><div class="props_rev_3"><a id="GUID-48F3F639-194F-4EB4-81D5-7C4EC1C7D718" name="GUID-48F3F639-194F-4EB4-81D5-7C4EC1C7D718"></a><h4 id="ADXDK-GUID-48F3F639-194F-4EB4-81D5-7C4EC1C7D718" class="sect4">JAXB类生成器的标准和规范</h4>
                  <div>
                     <p>Oracle JAXB处理器实现了JSR-31， <span class="italic">用于XML绑定的Java体系结构（JAXB）</span> ，版本1.0，这是Java Community Process（JCP）的推荐。
                     </p>
                     <p>JAXB 1.0规范的Oracle XML Developer's Kit（XDK）实现<span class="italic">不</span>支持这些<span class="italic">可选</span>功能：</p>
                     <ul style="list-style-type:disc">
                        <li>
                           <p>Javadoc一代</p>
                        </li>
                        <li>
                           <p>失败快速验证</p>
                        </li>
                        <li>
                           <p>外部自定义文件</p>
                        </li>
                        <li>
                           <p>XML Schema概念在规范的E.2节中描述</p>
                        </li>
                     </ul>
                  </div>
                  <div>
                     <div class="relinfo">
                        <p><strong>相关话题</strong></p>
                        <ul>
                           <li><a href="XDK-standards.html#GUID-795A483B-12AC-4F6D-A606-6BE9DA963F0F" title="描述了Oracle XML Developer&#39;s Kit（XDK）标准。">Oracle XML Developer的套件标准</a></li>
                        </ul>
                     </div>
                  </div>
                  
               </div><a id="ADXDK19292"></a><div class="props_rev_3"><a id="GUID-CCB5205D-73E6-4ABA-86BD-C815900DAB90" name="GUID-CCB5205D-73E6-4ABA-86BD-C815900DAB90"></a><h4 id="ADXDK-GUID-CCB5205D-73E6-4ABA-86BD-C815900DAB90" class="sect4">JAXB类生成器功能</h4>
                  <div>
                     <p>用于Java的JAXB类生成器生成与XML模式对应的接口和实现类。它对Java开发人员的主要优势是自动化XML文档和Java代码之间的映射，这使程序能够使用生成的代码来读取，操作和重新创建XML数据。</p>
                     <p>可以扩展的Java类使开发人员无需了解底层XML数据结构即可访问XML数据。</p>
                     <p>Oracle JAXB类生成器为Java中的XML应用程序开发提供了以下优势：</p>
                     <ul style="list-style-type:disc">
                        <li>
                           <p>速度</p>
                           <p>由于模式到代码的转换是自动化的，因此您可以从输入XML模式快速生成Java代码。</p>
                        </li>
                        <li>
                           <p>便于使用</p>
                           <p>您可以调用生成的<code class="codeph">get</code>和<code class="codeph">set</code>方法，而不是从一开始就编写自己的代码。
                           </p>
                        </li>
                        <li>
                           <p>自动数据转换</p>
                           <p>您可以自动将XML文档数据转换为Java数据类型。</p>
                        </li>
                        <li>
                           <p>定制</p>
                           <p>JAXB提供了一个灵活的框架，使您可以自定义XML元素和属性的绑定。</p>
                        </li>
                     </ul>
                  </div>
               </div><a id="ADXDK19293"></a><div class="props_rev_3"><a id="GUID-97DB0107-C5ED-493B-B23D-7782AB1A6285" name="GUID-97DB0107-C5ED-493B-B23D-7782AB1A6285"></a><h4 id="ADXDK-GUID-97DB0107-C5ED-493B-B23D-7782AB1A6285" class="sect4">使用JAXB进行编组和解组</h4>
                  <div>
                     <p>JAXB是一个应用程序编程接口（API）和一组将XML数据映射到Java对象的工具。JAXB通过以Java格式将XML文档呈现给程序，简化了从Java程序对XML文档的访问。</p>
                     <div class="section">
                        <p>您可以使用JAXB API和工具来执行以下基本任务：</p>
                        <ol>
                           <li>
                              <p>使用<code class="codeph">orajaxb</code>命令行实用程序从XML模式生成和编译JAXB类。
                              </p>
                              <p>要使用JAXB类生成器生成Java类，必须为其提供XML模式。JAXB不支持文档类型定义（DTD）。但是，如<a href="using-XML-schema-processor-for-Java.html#GUID-BC0B8A74-265E-4EBF-B012-923DA614F744" title="由于XML Schema语言的强大功能和灵活性，您可能希望将现有DTD转换为XML架构文档。您可以使用XDK执行此转换。">将DTD转换为XML模式</a>中所述，您可以使用<code class="codeph">DTD2Schema</code>程序将DTD转换为XML模式。然后，您可以使用JAXB类生成器从架构生成类。
                              </p>
                              <p>JAXB编译器生成映射到源XML模式中的约束的Java类。这些类实现了<code class="codeph">get</code>和<code class="codeph">set</code>方法，您可以使用这些方法来获取和指定模式中每种元素和属性的数据。
                              </p>
                           </li>
                           <li>
                              <p>通过在Java程序中实例化生成的类来处理XML文档。</p>
                              <p>具体来说，您可以编写一个使用JAXB绑定框架来执行这些任务的程序：</p>
                              <ol type="a">
                                 <li>
                                    <p>解组XML文档。</p>
                                    <p>如JAXB规范中所述， <a href="glossary.html#GUID-491F320E-279A-42F5-B34B-4B8D75749DAB" title="读取XML文档和构建Java内容对象树的过程。每个内容对象直接对应于相应模式组件的输入文档中的实例。"><span class="xrefglossterm">解组</span></a>被定义为将数据从XML文档移动到Java生成的对象。
                                    </p>
                                 </li>
                                 <li>
                                    <p>验证XML文档。</p>
                                    <p>您可以在将内容解组到内容树之前或期间进行验证。您还可以通过在Java对象上调用验证API来按需验证。请参阅<a href="using-JAXB-class-generator.html#GUID-9141E178-83A7-4352-9179-9BE635B759FD" title="当编组树生成有效的XML文档时，Java内容树被认为对XML模式有效。">使用JAXB进行验证</a> 。</p>
                                 </li>
                                 <li>
                                    <p>修改Java内容对象。</p>
                                    <p>数据对象的内容树表示源XML文档的结构和内容。您可以使用为类定义的<code class="codeph">set</code>方法来修改元素和属性的内容。
                                    </p>
                                 </li>
                                 <li>
                                    <p>Marshal Java内容对象返回XML。</p>
                                    <p>与解组相反， <a href="glossary.html#GUID-F136597D-93E1-46D6-9903-E5DF66129BCD" title="遍历Java内容树并编写反映树内容的XML文档的过程。这是解组的反过来。"><span class="xrefglossterm">编组</span></a>是通过遍历Java类实例的内容树从Java对象创建XML文档。您可以将数据序列化为文档对象模型（DOM）树，Simple API for XML（SAX）内容处理程序，转换结果或输出流。
                                    </p>
                                 </li>
                              </ol>
                           </li>
                        </ol>
                     </div>
                     <!-- class="section" -->
                  </div>
               </div><a id="ADXDK19294"></a><div class="props_rev_3"><a id="GUID-9141E178-83A7-4352-9179-9BE635B759FD" name="GUID-9141E178-83A7-4352-9179-9BE635B759FD"></a><h4 id="ADXDK-GUID-9141E178-83A7-4352-9179-9BE635B759FD" class="sect4">使用JAXB进行验证</h4>
                  <div>
                     <p>当编组树生成有效的XML文档时，Java内容树被认为对XML模式有效。</p>
                     <p>JAXB应用程序可以在以下情况下执行验证：</p>
                     <ul style="list-style-type:disc">
                        <li>
                           <p>解组时间验证，在解组时通知应用程序错误和警告。如果解组包括无错误的验证，则输入XML文档和Java内容树是有效的。</p>
                        </li>
                        <li>
                           <p>按需验证应用程序启动的Java内容树。</p>
                        </li>
                        <li>
                           <p>快速验证，在使用<code class="codeph">set</code>和<code class="codeph">get</code>方法更新Java内容树时立即产生结果。正如<a href="using-JAXB-class-generator.html#GUID-48F3F639-194F-4EB4-81D5-7C4EC1C7D718" title="Oracle JAXB处理器实现了JSR-31，用于XML绑定的Java体系结构（JAXB），版本1.0，这是Java Community Process（JCP）的推荐。">JAXB类生成器的标准和规范中</a>所规定的，失败快速验证是JAXB 1.0规范中的可选功能，JAXB类生成器的XDK实现不支持该功能。
                           </p>
                        </li>
                     </ul>
                     <p>JAXB应用程序必须能够封送有效的Java内容树，但在调用编组API之前，它们不需要确保Java内容树有效。编组过程本身不验证内容树。当编组由于内容无效而失败时，程序需要抛出<code class="codeph">javax/xml/bind/MarshalException</code> 。
                     </p>
                  </div>
               </div><a id="ADXDK19295"></a><div class="props_rev_3"><a id="GUID-0EC35F1E-AA6F-4937-A232-5835F50BD2C7" name="GUID-0EC35F1E-AA6F-4937-A232-5835F50BD2C7"></a><h4 id="ADXDK-GUID-0EC35F1E-AA6F-4937-A232-5835F50BD2C7" class="sect4">JAXB定制</h4>
                  <div>
                     <p>XML模式中声明的元素和类型名称并不总是提供最有用的Java类名。您可以使用自定义绑定声明覆盖默认的JAXB绑定，这些声明在JAXB规范中进行了描述。</p>
                     <p>这些声明允许您自定义生成的JAXB类，超出XML模式中特定于XML的约束，以包括特定于Java的改进，例如类和包名称映射。</p>
                     <p>您可以注释架构以执行这些自定义：</p>
                     <ul style="list-style-type:disc">
                        <li>
                           <p>将XML名称绑定到用户定义的Java类名称</p>
                        </li>
                        <li>
                           <p>命名包，派生类和方法</p>
                        </li>
                        <li>
                           <p>选择要绑定到哪些类的元素</p>
                        </li>
                        <li>
                           <p>确定如何将每个属性和元素声明绑定到相应内容类中的属性</p>
                        </li>
                        <li>
                           <p>选择每个属性值或内容规范的类型</p>
                        </li>
                     </ul>
                     <p><a href="using-JAXB-class-generator.html#GUID-D5654A94-6253-4988-807A-9BBD6ADCDD52__CHDGCFDC" title="列出JAXB示例应用程序">表18-2中</a>列出的几个演示程序显示了JAXB自定义。
                     </p>
                     <div class="infoboxnotealso" id="GUID-0EC35F1E-AA6F-4937-A232-5835F50BD2C7__GUID-F9C23ABA-7EDB-4F2A-BBE3-1CB8E6E6F4D1">
                        <p class="notep1">也可以看看：</p>
                        <p><a href="using-JAXB-class-generator.html#GUID-C54597F9-B701-4D56-8254-1F6F3268F533" title="Sample10.java程序显示了一种JAXB定制形式。该程序显示您可以更改与输入XML架构中的元素对应的类的名称。">自定义顶级元素中的类名称，以</a>获取自定义演示的详细说明</p>
                     </div>
                  </div>
               </div>
            </div><a id="ADXDK999"></a><a id="ADXDK19296"></a><div class="props_rev_3"><a id="GUID-B1E3950B-1EB3-4175-AE95-66D462C9BE5E" name="GUID-B1E3950B-1EB3-4175-AE95-66D462C9BE5E"></a><h3 id="ADXDK-GUID-B1E3950B-1EB3-4175-AE95-66D462C9BE5E" class="sect3">使用JAXB类生成器：概述</h3>
               <div>
                  <p>这里的主题包括使用JAXB处理器，运行XML模式处理器演示程序以及使用JAXB类生成器命令行实用程序的基本过程。</p>
                  <div class="section"> </div>
                  <!-- class="section" -->
               </div><a id="ADXDK19298"></a><a id="ADXDK19299"></a><a id="ADXDK19297"></a><div class="props_rev_3"><a id="GUID-35B362B4-772E-44E7-80A2-E7F9A7443BC7" name="GUID-35B362B4-772E-44E7-80A2-E7F9A7443BC7"></a><h4 id="ADXDK-GUID-35B362B4-772E-44E7-80A2-E7F9A7443BC7" class="sect4">使用JAXB处理器：基本过程</h4>
                  <div>
                     <p>描述了XDK JAXB API基本过程。</p>
                     <div class="section">
                        <p>XDK JAXB API公开了这些包：</p>
                     </div>
                     <!-- class="section" -->
                     <div class="section">
                        <ul style="list-style-type:disc">
                           <li>
                              <p><code class="codeph">javax.xml.bind</code> ，为客户端应用程序提供运行时绑定框架，包括解组，编组和验证</p>
                           </li>
                           <li>
                              <p><code class="codeph">javax.xml.bind.util</code> ，提供有用的客户端实用程序类</p>
                           </li>
                        </ul>
                        <p><a href="using-JAXB-class-generator.html#GUID-35B362B4-772E-44E7-80A2-E7F9A7443BC7__BABHGDEA" title="此表描述了XDK Java API中可用的JAXB类和接口。">表18-1</a>中描述了<code class="codeph">javax.xml.bind</code>包中最重要的类和接口。这些构成了大多数JAXB应用程序的核心。
                        </p>
                        <div class="tblformalwide" id="GUID-35B362B4-772E-44E7-80A2-E7F9A7443BC7__BABHGDEA">
                           <p class="titleintable">表18-1 javax.xml.bind类和接口</p>
                           <table cellpadding="4" cellspacing="0" class="FormalWide" title="javax.xml.bind类和接口" width="100%" border="1" summary="This table describes the JAXB classes and interfaces available in the XDK Java API." frame="hsides" rules="rows">
                              <thead>
                                 <tr align="left" valign="top">
                                    <th align="left" valign="bottom" width="22%" id="d68249e1099">类/接口</th>
                                    <th align="left" valign="bottom" width="29%" id="d68249e1102">描述</th>
                                    <th align="left" valign="bottom" width="49%" id="d68249e1105">方法</th>
                                 </tr>
                              </thead>
                              <tbody>
                                 <tr align="left" valign="top">
                                    <td align="left" valign="top" width="22%" id="d68249e1110" headers="d68249e1099 ">
                                       <p><code class="codeph">JAXBContext</code>类</p>
                                    </td>
                                    <td align="left" valign="top" width="29%" headers="d68249e1110 d68249e1102 ">
                                       <p>提供用于管理实现JAXB绑定框架操作所必需的XML / Java绑定信息的抽象：unmarshal，marshal和validate。客户端应用程序通过调用<code class="codeph">newInstance()</code>方法获取此类的新实例。
                                       </p>
                                    </td>
                                    <td align="left" valign="top" width="49%" headers="d68249e1110 d68249e1105 ">
                                       <p>主要方法是：</p>
                                       <ul style="list-style-type:disc">
                                          <li>
                                             <p><code class="codeph">newInstance()</code>创建一个JAXB内容类。为此方法提供包含生成的类的包的名称。
                                             </p>
                                          </li>
                                          <li>
                                             <p><code class="codeph">createMarshaller()</code>创建一个可用于将内容树转换为XML的编组器。</p>
                                          </li>
                                          <li>
                                             <p><code class="codeph">createUnmarshaller()</code>创建一个可用于将XML转换为内容树的unmarshaller。
                                             </p>
                                          </li>
                                          <li>
                                             <p><code class="codeph">createValidator()</code>创建一个<code class="codeph">Validator</code>对象，该对象可以根据源模式验证Java内容树。
                                             </p>
                                          </li>
                                       </ul>
                                    </td>
                                 </tr>
                                 <tr align="left" valign="top">
                                    <td align="left" valign="top" width="22%" id="d68249e1149" headers="d68249e1099 ">
                                       <p><code class="codeph">Marshaller</code>界面</p>
                                    </td>
                                    <td align="left" valign="top" width="29%" headers="d68249e1149 d68249e1102 ">
                                       <p>控制将Java内容树序列化为XML数据的过程。</p>
                                    </td>
                                    <td align="left" valign="top" width="49%" headers="d68249e1149 d68249e1105 ">
                                       <p>主要方法是：</p>
                                       <ul style="list-style-type:disc">
                                          <li>
                                             <p><code class="codeph">getEventHandler()</code>返回当前或默认事件处理程序。
                                             </p>
                                          </li>
                                          <li>
                                             <p><code class="codeph">getProperty()</code>获取marshaller的底层实现中的属性。
                                             </p>
                                          </li>
                                          <li>
                                             <p><code class="codeph">marshal()</code>将内容树编组为DOM，SAX2事件，输出流，转换结果或<code class="codeph">Writer</code> 。
                                             </p>
                                          </li>
                                          <li>
                                             <p><code class="codeph">setEventHandler()</code>创建一个<code class="codeph">Validator</code>对象，该对象根据源模式验证java内容树。
                                             </p>
                                          </li>
                                       </ul>
                                    </td>
                                 </tr>
                                 <tr align="left" valign="top">
                                    <td align="left" valign="top" width="22%" id="d68249e1188" headers="d68249e1099 ">
                                       <p><code class="codeph">Unmarshaller</code>界面</p>
                                    </td>
                                    <td align="left" valign="top" width="29%" headers="d68249e1188 d68249e1102 ">
                                       <p>管理将XML数据反序列化为新创建的Java内容树的过程，可选择在解组时验证XML数据。</p>
                                    </td>
                                    <td align="left" valign="top" width="49%" headers="d68249e1188 d68249e1105 ">
                                       <p>主要方法是：</p>
                                       <ul style="list-style-type:disc">
                                          <li>
                                             <p><code class="codeph">getEventHandler()</code>返回当前或默认事件处理程序。
                                             </p>
                                          </li>
                                          <li>
                                             <p><code class="codeph">getUnmarshallerHandler()</code>返回一个unmarshaller处理程序对象，可用作XML管道中的一个组件。
                                             </p>
                                          </li>
                                          <li>
                                             <p><code class="codeph">isValidating()</code>指示unmarshaller是否设置为验证模式。
                                             </p>
                                          </li>
                                          <li>
                                             <p><code class="codeph">setEventHandler()</code>允许应用程序注册<code class="codeph">ValidationEventHandler</code> 。
                                             </p>
                                          </li>
                                          <li>
                                             <p><code class="codeph">setValidating()</code>指定unmarshaller在解组操作期间是否验证。
                                             </p>
                                          </li>
                                          <li>
                                             <p><code class="codeph">marshal()</code>从指定的文件，URL，输入流，输入源，SAX或DOM中解组XML数据。</p>
                                          </li>
                                       </ul>
                                    </td>
                                 </tr>
                                 <tr align="left" valign="top">
                                    <td align="left" valign="top" width="22%" id="d68249e1234" headers="d68249e1099 ">
                                       <p><code class="codeph">Validator</code>接口</p>
                                    </td>
                                    <td align="left" valign="top" width="29%" headers="d68249e1234 d68249e1102 ">
                                       <p>控制运行时内容树的验证。具体来说，此接口控制按需验证，使客户端能够接收有关在Java内容树中检测到的验证错误和警告的数据。</p>
                                    </td>
                                    <td align="left" valign="top" width="49%" headers="d68249e1234 d68249e1105 ">
                                       <p>主要方法是：</p>
                                       <ul style="list-style-type:disc">
                                          <li>
                                             <p><code class="codeph">getEventHandler()</code>返回当前或默认事件处理程序。
                                             </p>
                                          </li>
                                          <li>
                                             <p><code class="codeph">setEventHandler()</code>允许应用程序注册<code class="codeph">ValidationEventHandler</code> 。
                                             </p>
                                          </li>
                                          <li>
                                             <p><code class="codeph">validate()</code>在运行时按需验证Java内容树。此方法可以验证Java内容树的任意子树。
                                             </p>
                                          </li>
                                          <li>
                                             <p><code class="codeph">validateRoot()</code>验证以<code class="codeph">rootObj</code>根的Java内容树。您可以使用此方法验证整个Java内容树。
                                             </p>
                                          </li>
                                       </ul>
                                    </td>
                                 </tr>
                              </tbody>
                           </table>
                        </div>
                        <!-- class="inftblhruleinformal" -->
                        <p><a href="using-JAXB-class-generator.html#GUID-35B362B4-772E-44E7-80A2-E7F9A7443BC7__CHDBCBHJ">图18-1</a>描述了使用JAXB类生成器的框架的流程。
                        </p>
                        <div class="figure" id="GUID-35B362B4-772E-44E7-80A2-E7F9A7443BC7__CHDBCBHJ">
                           <p class="titleinfigure">图18-1 Java的JAXB类生成器</p><img src="img/adxdk003.gif" width="491" alt="下面是图18-1的描述" title="下面是图18-1的描述" longdesc="img_text/adxdk003.html"><br><a href="img_text/adxdk003.html">“图18-1用于Java的JAXB类生成器”的描述</a></div>
                        <!-- class="figure" -->
                        <p>该过程的基本阶段<a href="using-JAXB-class-generator.html#GUID-35B362B4-772E-44E7-80A2-E7F9A7443BC7__CHDBCBHJ">如图18-1</a>所示：</p>
                     </div>
                     <!-- class="section" -->
                     <ol>
                        <li class="stepexpand"><span>XML解析器解析XML模式并将解析的数据发送到JAXB类生成器。</span></li>
                        <li class="stepexpand"><span>类生成器基于输入XML模式创建Java类和接口。</span><div>
                              <p>默认情况下，一个XML元素或类型声明生成一个接口和一个类。例如，如果模式定义了名为<code class="codeph">&lt;anElement&gt;</code>的元素，则默认情况下，JAXB类生成器生成名为<code class="codeph">AnElement.java</code>的源文件和另一个名为<code class="codeph">AnElementImpl.java</code>的源文件。您可以使用自定义绑定声明来覆盖XML架构组件到Java表示的默认绑定。
                              </p>
                           </div>
                        </li>
                        <li class="stepexpand"><span>Java编译器将<code class="codeph">.java</code>源文件编译为类文件。必须编译所有生成的类，源文件和应用程序代码。</span></li>
                        <li class="stepexpand"><span>您的Java应用程序使用已编译的类和绑定框架来执行以下类型的任务：</span><div>
                              <ul style="list-style-type:disc">
                                 <li>
                                    <p>创建JAXB上下文。您可以使用此上下文来创建marshaller和unmarshaller。</p>
                                 </li>
                                 <li>
                                    <p>构建表示对XML模式有效的XML数据的对象树。您可以通过从符合模式的XML文档中解组数据或实例化类来执行此任务。</p>
                                 </li>
                                 <li>
                                    <p>访问和修改数据。</p>
                                 </li>
                                 <li>
                                    <p>（可选）验证相对于XML模式中表达的约束的数据修改。</p>
                                 </li>
                                 <li>
                                    <p>将数据分配给新的XML文档。</p>
                                 </li>
                              </ul>
                           </div>
                        </li>
                     </ol>
                     <div class="section">
                        <div class="infoboxnotealso" id="GUID-35B362B4-772E-44E7-80A2-E7F9A7443BC7__GUID-851098C1-C0B3-4E0A-97FF-5D6B312D0597">
                           <p class="notep1">也可以看看：</p>
                           <ul style="list-style-type:disc">
                              <li>
                                 <p>有关JAXB API的详细信息，请参阅<a href="../jaxml/index.html" target="_blank"><span><cite>Oracle Database XML Java API参考</cite></span></a></p>
                              </li>
                              <li>
                                 <p><a href="using-JAXB-class-generator.html#GUID-C465678A-AAA4-42EA-ACAB-DC2D294607CF" title="主题包括绑定复杂类型和在顶级元素中自定义类名。">使用JAXB类生成器处理XML以</a>获取JAXB处理的详细说明</p>
                              </li>
                           </ul>
                        </div>
                     </div>
                     <!-- class="section" -->
                  </div>
               </div><a id="ADXDK19301"></a><a id="ADXDK19300"></a><div class="props_rev_3"><a id="GUID-D5654A94-6253-4988-807A-9BBD6ADCDD52" name="GUID-D5654A94-6253-4988-807A-9BBD6ADCDD52"></a><h4 id="ADXDK-GUID-D5654A94-6253-4988-807A-9BBD6ADCDD52" class="sect4">运行XML架构处理器演示程序</h4>
                  <div>
                     <p>用于Java的JAXB类生成器的演示程序包含在<code class="codeph">$ORACLE_HOME/xdk/demo/java/jaxb</code> 。
                     </p>
                     <div class="section">
                        <p>具体来说，XDK包括<a href="using-JAXB-class-generator.html#GUID-D5654A94-6253-4988-807A-9BBD6ADCDD52__CHDGCFDC" title="列出JAXB示例应用程序">表18-2中</a>列出的JAXB演示。
                        </p>
                        <div class="tblformalwide" id="GUID-D5654A94-6253-4988-807A-9BBD6ADCDD52__CHDGCFDC">
                           <p class="titleintable">表18-2 JAXB类生成器演示</p>
                           <table cellpadding="4" cellspacing="0" class="FormalWide" title="JAXB类生成器演示" width="100%" border="1" summary="Lists the JAXB sample applications" frame="hsides" rules="rows">
                              <thead>
                                 <tr align="left" valign="top">
                                    <th align="left" valign="bottom" width="18%" id="d68249e1458">程序</th>
                                    <th align="left" valign="bottom" width="31%" id="d68249e1461">Oracle Home中的子目录</th>
                                    <th align="left" valign="bottom" width="51%" id="d68249e1464">证明。 。 。</th>
                                 </tr>
                              </thead>
                              <tbody>
                                 <tr align="left" valign="top">
                                    <td align="left" valign="top" width="18%" id="d68249e1469" headers="d68249e1458 ">
                                       <p><code class="codeph">SampleApp1.java</code></p>
                                    </td>
                                    <td align="left" valign="top" width="31%" headers="d68249e1469 d68249e1461 ">
                                       <p><code class="codeph">/ XDK /演示/ JAVA / JAXB /样本1</code></p>
                                    </td>
                                    <td align="left" valign="top" width="51%" headers="d68249e1469 d68249e1464 ">
                                       <p>将<code class="codeph">sample1.xsd</code>模式中的顶级元素和<code class="codeph">complexType</code>定义绑定到Java类。
                                       </p>
                                    </td>
                                 </tr>
                                 <tr align="left" valign="top">
                                    <td align="left" valign="top" width="18%" id="d68249e1487" headers="d68249e1458 ">
                                       <p><code class="codeph">SampleApp2.java</code></p>
                                    </td>
                                    <td align="left" valign="top" width="31%" headers="d68249e1487 d68249e1461 ">
                                       <p><code class="codeph">/ XDK /演示/ JAVA / JAXB /样品2</code></p>
                                    </td>
                                    <td align="left" valign="top" width="51%" headers="d68249e1487 d68249e1464 ">
                                       <p>在<code class="codeph">sample2.xsd</code>模式<code class="codeph">sample2.xsd</code>顶级元素与内联<code class="codeph">simpleType</code>定义<code class="codeph">sample2.xsd</code> 。
                                       </p>
                                    </td>
                                 </tr>
                                 <tr align="left" valign="top">
                                    <td align="left" valign="top" width="18%" id="d68249e1505" headers="d68249e1458 ">
                                       <p><code class="codeph">SampleApp3.java</code></p>
                                    </td>
                                    <td align="left" valign="top" width="31%" headers="d68249e1505 d68249e1461 ">
                                       <p><code class="codeph">/ XDK /演示/ JAVA / JAXB /样品3</code></p>
                                    </td>
                                    <td align="left" valign="top" width="51%" headers="d68249e1505 d68249e1464 ">
                                       <p>通过扩展从另一个顶级<code class="codeph">complexType</code>定义派生的顶级<code class="codeph">complexType</code>元素的绑定。有关此程序的详细说明，请参见<a href="using-JAXB-class-generator.html#GUID-DEB32387-4956-4DDB-89C1-0ED9487EE65B" title="Sample3.java显示了如何将复杂类型定义绑定到Java内容接口。XML模式中定义的一种复杂类型是通过另一种复杂类型的扩展派生的。">绑定复杂类型</a> 。
                                       </p>
                                    </td>
                                 </tr>
                                 <tr align="left" valign="top">
                                    <td align="left" valign="top" width="18%" id="d68249e1531" headers="d68249e1458 ">
                                       <p><code class="codeph">SampleApp4.java</code></p>
                                    </td>
                                    <td align="left" valign="top" width="31%" headers="d68249e1531 d68249e1461 ">
                                       <p><code class="codeph">/ XDK /演示/ JAVA / JAXB / Sample4</code></p>
                                    </td>
                                    <td align="left" valign="top" width="51%" headers="d68249e1531 d68249e1464 ">
                                       <p>内容模型在引用顶级命名组的<code class="codeph">complexType</code>中的绑定。
                                       </p>
                                    </td>
                                 </tr>
                                 <tr align="left" valign="top">
                                    <td align="left" valign="top" width="18%" id="d68249e1546" headers="d68249e1458 ">
                                       <p><code class="codeph">SampleApp5.java</code></p>
                                    </td>
                                    <td align="left" valign="top" width="31%" headers="d68249e1546 d68249e1461 ">
                                       <p><code class="codeph">/ XDK /演示/ JAVA / JAXB /实例5</code></p>
                                    </td>
                                    <td align="left" valign="top" width="51%" headers="d68249e1546 d68249e1464 ">
                                       <p><code class="codeph">&lt;choice&gt;</code>与<code class="codeph">maxOccurs</code>绑定在<code class="codeph">complexType</code>无<code class="codeph">complexType</code> 。
                                       </p>
                                    </td>
                                 </tr>
                                 <tr align="left" valign="top">
                                    <td align="left" valign="top" width="18%" id="d68249e1567" headers="d68249e1458 ">
                                       <p><code class="codeph">SampleApp6.java</code></p>
                                    </td>
                                    <td align="left" valign="top" width="31%" headers="d68249e1567 d68249e1461 ">
                                       <p><code class="codeph">/ XDK /演示/ JAVA / JAXB / Sample6</code></p>
                                    </td>
                                    <td align="left" valign="top" width="51%" headers="d68249e1567 d68249e1464 ">
                                       <p>原子数据类型的绑定。</p>
                                    </td>
                                 </tr>
                                 <tr align="left" valign="top">
                                    <td align="left" valign="top" width="18%" id="d68249e1579" headers="d68249e1458 ">
                                       <p><code class="codeph">SampleApp7.java</code></p>
                                    </td>
                                    <td align="left" valign="top" width="31%" headers="d68249e1579 d68249e1461 ">
                                       <p><code class="codeph">/ XDK /演示/ JAVA / JAXB / Sample7</code></p>
                                    </td>
                                    <td align="left" valign="top" width="51%" headers="d68249e1579 d68249e1464 ">
                                       <p>绑定<code class="codeph">complexType</code>定义，其中<code class="codeph">mixed="true"</code> 。
                                       </p>
                                    </td>
                                 </tr>
                                 <tr align="left" valign="top">
                                    <td align="left" valign="top" width="18%" id="d68249e1597" headers="d68249e1458 ">
                                       <p><code class="codeph">SampleApp8.java</code></p>
                                    </td>
                                    <td align="left" valign="top" width="31%" headers="d68249e1597 d68249e1461 ">
                                       <p><code class="codeph">/ XDK /演示/ JAVA / JAXB /样品8</code></p>
                                    </td>
                                    <td align="left" valign="top" width="51%" headers="d68249e1597 d68249e1464 ">
                                       <p>在两个不同的命名空间中声明的元素和类型的绑定。</p>
                                    </td>
                                 </tr>
                                 <tr align="left" valign="top">
                                    <td align="left" valign="top" width="18%" id="d68249e1609" headers="d68249e1458 ">
                                       <p><code class="codeph">SampleApp9.java</code></p>
                                    </td>
                                    <td align="left" valign="top" width="31%" headers="d68249e1609 d68249e1461 ">
                                       <p><code class="codeph">/ XDK /演示/ JAVA / JAXB / Sample9</code></p>
                                    </td>
                                    <td align="left" valign="top" width="51%" headers="d68249e1609 d68249e1464 ">
                                       <p>Java包名称的自定义。</p>
                                    </td>
                                 </tr>
                                 <tr align="left" valign="top">
                                    <td align="left" valign="top" width="18%" id="d68249e1621" headers="d68249e1458 ">
                                       <p><code class="codeph">SampleApp10.java</code></p>
                                    </td>
                                    <td align="left" valign="top" width="31%" headers="d68249e1621 d68249e1461 ">
                                       <p><code class="codeph">/ XDK /演示/ JAVA / JAXB / Sample10</code></p>
                                    </td>
                                    <td align="left" valign="top" width="51%" headers="d68249e1621 d68249e1464 ">
                                       <p>顶级元素中类名的自定义。有关此程序的详细说明，请参阅<a href="using-JAXB-class-generator.html#GUID-C54597F9-B701-4D56-8254-1F6F3268F533" title="Sample10.java程序显示了一种JAXB定制形式。该程序显示您可以更改与输入XML架构中的元素对应的类的名称。">在顶级元素中自定义类名</a> 。
                                       </p>
                                    </td>
                                 </tr>
                                 <tr align="left" valign="top">
                                    <td align="left" valign="top" width="18%" id="d68249e1642" headers="d68249e1458 ">
                                       <p><code class="codeph">SampleApp11.java</code></p>
                                    </td>
                                    <td align="left" valign="top" width="31%" headers="d68249e1642 d68249e1461 ">
                                       <p><code class="codeph">/ XDK /演示/ JAVA / JAXB / Sample11</code></p>
                                    </td>
                                    <td align="left" valign="top" width="51%" headers="d68249e1642 d68249e1464 ">
                                       <p>在<code class="codeph">complexType</code>元素内声明的重复模型组中发生的本地元素的类名的自定义。
                                       </p>
                                    </td>
                                 </tr>
                                 <tr align="left" valign="top">
                                    <td align="left" valign="top" width="18%" id="d68249e1658" headers="d68249e1458 ">
                                       <p><code class="codeph">SampleApp12.java</code></p>
                                    </td>
                                    <td align="left" valign="top" width="31%" headers="d68249e1658 d68249e1461 ">
                                       <p><code class="codeph">/ XDK /演示/ JAVA / JAXB / Sample12</code></p>
                                    </td>
                                    <td align="left" valign="top" width="51%" headers="d68249e1658 d68249e1464 ">
                                       <p>自定义属性名称。</p>
                                    </td>
                                 </tr>
                                 <tr align="left" valign="top">
                                    <td align="left" valign="top" width="18%" id="d68249e1670" headers="d68249e1458 ">
                                       <p><code class="codeph">SampleApp13.java</code></p>
                                    </td>
                                    <td align="left" valign="top" width="31%" headers="d68249e1670 d68249e1461 ">
                                       <p><code class="codeph">/ XDK /演示/ JAVA / JAXB / Sample13</code></p>
                                    </td>
                                    <td align="left" valign="top" width="51%" headers="d68249e1670 d68249e1464 ">
                                       <p>在全局<code class="codeph">simpleType</code>上指定的<code class="codeph">javaType</code>自定义。<code class="codeph">javaType</code>自定义指定在用户定义的类上声明的parse和print方法。
                                       </p>
                                    </td>
                                 </tr>
                                 <tr align="left" valign="top">
                                    <td align="left" valign="top" width="18%" id="d68249e1691" headers="d68249e1458 ">
                                       <p><code class="codeph">SampleApp14.java</code></p>
                                    </td>
                                    <td align="left" valign="top" width="31%" headers="d68249e1691 d68249e1461 ">
                                       <p><code class="codeph">/ XDK /演示/ JAVA / JAXB / Sample14</code></p>
                                    </td>
                                    <td align="left" valign="top" width="51%" headers="d68249e1691 d68249e1464 ">
                                       <p>自定义类型安全枚举类名称。</p>
                                    </td>
                                 </tr>
                              </tbody>
                           </table>
                        </div>
                        <!-- class="inftblhruleinformal" -->
                        <p>您可以在同一目录中找到描述如何在<code class="codeph">README</code>中编译和运行示例程序的文档。基本步骤是：</p>
                        <ol>
                           <li>
                              <p>转到<code class="codeph">$ORACLE_HOME/xdk/demo/java/jaxb</code>目录（UNIX）或<code class="codeph">%ORACLE_HOME%\xdk\demo\java\jaxb</code>目录（Windows）。
                              </p>
                           </li>
                           <li>
                              <p>确保按照<a href="getting-started-with-XDK-for-Java.html#GUID-EA5DB831-1D91-453A-AF7B-7B55343B1720" title="You can set up the XDK for Java environment using either an environment variable or a command-line option.">设置XDK for Java环境中的</a>描述<a href="getting-started-with-XDK-for-Java.html#GUID-EA5DB831-1D91-453A-AF7B-7B55343B1720" title="您可以使用环境变量或命令行选项设置XDK for Java环境。">设置</a>环境变量。
                              </p>
                           </li>
                           <li>
                              <p>在系统提示符下运行<code class="codeph">make</code> （UNIX）或<code class="codeph">Make.bat</code> （Windows）。<code class="codeph">make</code>实用程序为每个sample子目录执行以下顺序操作：</p>
                              <ol type="a">
                                 <li>
                                    <p>运行<code class="codeph">orajaxb</code>实用程序以基于输入XML架构生成Java类文件。对于大多数演示，输出类文件将写入<code class="codeph">generated</code>子目录。例如， <code class="codeph">make</code>文件为<code class="codeph">Sample1</code>子目录中的<code class="codeph">sample1.xsd</code>模式执行以下命令：</p><pre class="oac_no_warn" dir="ltr">cd。/样本1; $（JAVA_HOME）/ bin / java -classpath“$（MAKE_CLASSPATH）”\ oracle.xml.jaxb.orajaxb -schema sample1.xsd -targetPkg generated;回声;</pre></li>
                                 <li>
                                    <p>运行<code class="codeph">javac</code>实用程序来编译Java类。例如， <code class="codeph">make</code>实用程序为<code class="codeph">Sample1/generated/</code>子目录中的Java类文件执行以下命令：</p><pre class="oac_no_warn" dir="ltr">cd。/样本1 /产生; $（JAVA_HOME）/ bin / javac -classpath \“$（MAKE_CLASSPATH）”* .java</pre></li>
                                 <li>
                                    <p>运行<code class="codeph">javac</code>实用程序以编译使用上一步中编译的类的示例Java应用程序。例如， <code class="codeph">make</code>实用程序编译<code class="codeph">SampleApp1.java</code>程序：</p><pre class="oac_no_warn" dir="ltr">cd。/样本1; $（JAVA_HOME）/ bin / javac -classpath“$（MAKE_CLASSPATH）”\ SampleApp1.java</pre></li>
                                 <li>
                                    <p>运行示例Java应用程序并将结果写入日志文件。例如， <code class="codeph">make</code>实用程序执行<code class="codeph">SampleApp1</code>类并将输出写入<code class="codeph">sample1.out</code> ：</p><pre class="oac_no_warn" dir="ltr">cd。/样本1; $（JAVA_HOME）/ bin / java -classpath“$（MAKE_CLASSPATH）”\ SampleApp1&gt; sample1.out</pre></li>
                              </ol>
                           </li>
                        </ol>
                     </div>
                     <!-- class="section" -->
                  </div>
               </div><a id="ADXDK19303"></a><a id="ADXDK19302"></a><div class="props_rev_3"><a id="GUID-1EBF886C-9940-4379-9143-C515F350F7E0" name="GUID-1EBF886C-9940-4379-9143-C515F350F7E0"></a><h4 id="ADXDK-GUID-1EBF886C-9940-4379-9143-C515F350F7E0" class="sect4">使用JAXB类生成器命令行实用程序</h4>
                  <div>
                     <p>XDK包括<code class="codeph">orajaxb</code> ，它是一个命令行Java接口，可从输入XML模式生成Java类。Shell脚本<code class="codeph">$ORACLE_HOME/bin/orajaxb</code>和<code class="codeph">%ORACLE_HOME%\bin\orajaxb.bat</code>执行类<code class="codeph">oracle.xml.jaxb.orajaxb</code> 。
                     </p>
                     <p>要使用<code class="codeph">orajaxb</code> ，请确保按照<a href="getting-started-with-XDK-for-Java.html#GUID-EA5DB831-1D91-453A-AF7B-7B55343B1720" title="You can set up the XDK for Java environment using either an environment variable or a command-line option.">设置XDK for Java环境中的</a>描述<a href="getting-started-with-XDK-for-Java.html#GUID-EA5DB831-1D91-453A-AF7B-7B55343B1720" title="您可以使用环境变量或命令行选项设置XDK for Java环境。">设置</a> <code class="codeph">CLASSPATH</code> 。
                     </p>
                     <p><a href="using-JAXB-class-generator.html#GUID-1EBF886C-9940-4379-9143-C515F350F7E0__CHDFABII" title="此表列出了orajaxb命令行选项。选项和目的是列。">表18-3</a>列出了<code class="codeph">orajaxb</code>命令行选项。
                     </p>
                     <div class="tblformal" id="GUID-1EBF886C-9940-4379-9143-C515F350F7E0__CHDFABII">
                        <p class="titleintable">表18-3 orajaxb命令行选项</p>
                        <table cellpadding="4" cellspacing="0" class="Formal" title="orajaxb命令行选项" width="100%" border="1" summary="This table  lists the orajaxb command-line options. Option and Purpose are the columns." frame="hsides" rules="rows">
                           <thead>
                              <tr align="left" valign="top">
                                 <th align="left" valign="bottom" width="30%" id="d68249e1937">选项</th>
                                 <th align="left" valign="bottom" width="70%" id="d68249e1940">目的</th>
                              </tr>
                           </thead>
                           <tbody>
                              <tr align="left" valign="top">
                                 <td align="left" valign="top" width="30%" id="d68249e1945" headers="d68249e1937 ">
                                    <p>- <code class="codeph">help</code></p>
                                 </td>
                                 <td align="left" valign="top" width="70%" headers="d68249e1945 d68249e1940 ">
                                    <p>打印帮助信息。</p>
                                 </td>
                              </tr>
                              <tr align="left" valign="top">
                                 <td align="left" valign="top" width="30%" id="d68249e1954" headers="d68249e1937 ">
                                    <p>- <code class="codeph">version</code></p>
                                 </td>
                                 <td align="left" valign="top" width="70%" headers="d68249e1954 d68249e1940 ">
                                    <p>打印发行版。</p>
                                 </td>
                              </tr>
                              <tr align="left" valign="top">
                                 <td align="left" valign="top" width="30%" id="d68249e1963" headers="d68249e1937 ">
                                    <p>- <code class="codeph">outputdir</code> <span class="italic"><code class="codeph">OutputDir</code></span></p>
                                 </td>
                                 <td align="left" valign="top" width="70%" headers="d68249e1963 d68249e1940 ">
                                    <p>指定生成Java源文件的目录。如果模式具有命名空间，则程序将在outputDir中引用的包（对应于命名空间）中生成Java代码。默认情况下，当前目录是<span class="italic"><code class="codeph">outputDir</code></span> 。</p>
                                 </td>
                              </tr>
                              <tr align="left" valign="top">
                                 <td align="left" valign="top" width="30%" id="d68249e1980" headers="d68249e1937 ">
                                    <p>- <code class="codeph">schema</code> <span class="italic"><code class="codeph">SchemaFile</code></span></p>
                                 </td>
                                 <td align="left" valign="top" width="70%" headers="d68249e1980 d68249e1940 ">
                                    <p>指定输入XML架构。</p>
                                 </td>
                              </tr>
                              <tr align="left" valign="top">
                                 <td align="left" valign="top" width="30%" id="d68249e1993" headers="d68249e1937 ">
                                    <p>- <code class="codeph">targetPkg</code> <span class="italic"><code class="codeph">targetPkg</code></span></p>
                                 </td>
                                 <td align="left" valign="top" width="70%" headers="d68249e1993 d68249e1940 ">
                                    <p>指定目标包名称。此选项将覆盖包名称的任何绑定自定义，以及JAXB规范中定义的默认包名称算法。</p>
                                 </td>
                              </tr>
                              <tr align="left" valign="top">
                                 <td align="left" valign="top" width="30%" id="d68249e2006" headers="d68249e1937 ">
                                    <p>- <code class="codeph">interface</code></p>
                                 </td>
                                 <td align="left" valign="top" width="70%" headers="d68249e2006 d68249e1940 ">
                                    <p>仅生成接口。</p>
                                 </td>
                              </tr>
                              <tr align="left" valign="top">
                                 <td align="left" valign="top" width="30%" id="d68249e2015" headers="d68249e1937 ">
                                    <p>- <code class="codeph">verbose</code></p>
                                 </td>
                                 <td align="left" valign="top" width="70%" headers="d68249e2015 d68249e1940 ">
                                    <p>列出生成的类和接口。</p>
                                 </td>
                              </tr>
                              <tr align="left" valign="top">
                                 <td align="left" valign="top" width="30%" id="d68249e2024" headers="d68249e1937 ">
                                    <p>- <code class="codeph">defaultCus</code> <span class="italic"><code class="codeph">fileName</code></span></p>
                                 </td>
                                 <td align="left" valign="top" width="70%" headers="d68249e2024 d68249e1940 ">
                                    <p>生成默认的自定义文件。</p>
                                 </td>
                              </tr>
                              <tr align="left" valign="top">
                                 <td align="left" valign="top" width="30%" id="d68249e2037" headers="d68249e1937 ">
                                    <p>- <code class="codeph">extension</code></p>
                                 </td>
                                 <td align="left" valign="top" width="70%" headers="d68249e2037 d68249e1940 ">
                                    <p>允许特定于供应商的扩展，并且不严格遵循JAXB 1.0规范的附录E.2中指定的兼容性规则。指定后，程序将忽略JAXB 1.0不支持的功能，如符号，替换组和任何属性。</p>
                                 </td>
                              </tr>
                           </tbody>
                        </table>
                     </div>
                     <!-- class="inftblhruleinformal" -->
                  </div><a id="ADXDK19304"></a><div class="props_rev_3"><a id="GUID-B9EBD0CA-2F11-4D71-9E94-7FD68BDD451F" name="GUID-B9EBD0CA-2F11-4D71-9E94-7FD68BDD451F"></a><h5 id="ADXDK-GUID-B9EBD0CA-2F11-4D71-9E94-7FD68BDD451F" class="sect5">使用JAXB类生成器命令行实用程序：示例</h5>
                     <div>
                        <p>示例显示如何使用JAXB类生成器命令行实用程序。</p>
                        <div class="section">
                           <p>要测试<code class="codeph">orjaxb</code> ，请更改到目录<code class="codeph">$ORACLE_HOME/xdk/demo/java/jaxb/Sample1</code> 。如果您运行<code class="codeph">make</code>则该目录包含以下文件：</p><pre class="pre codeblock"><code>SampleApp1.class SampleApp1.java生成/ sample1.out sample1.xml sample1.xsd</code></pre><p>文件<code class="codeph">sample.xsd</code>是与XML文档<code class="codeph">sample1.xml</code>关联的XML模式。子目录<code class="codeph">generated/</code>包含从输入模式生成的类。您可以通过删除<code class="codeph">generated/</code>重新生成类的内容来测试<code class="codeph">orajaxb</code> 。
                           </p><pre class="pre codeblock"><code>rm生成/ * orajaxb -schema sample1.xsd -targetPkg生成-verbose</code></pre><p>终端显示此输出：</p><pre class="pre codeblock"><code>生成/生成的CType.java /生成的AComplexType.java /生成/生成的RElemOfCTypeInSameNs.java /生成的/ RType.java生成/生成的RElemOfSTypeInSameNs.java /生成的CTypeImpl.java /生成的AComplexTypeImpl.java /生成的AnElementImpl.java / RElemOfCTypeInSameNsImpl.java生成/ RTypeImpl.java生成/ RElemOfSTypeInSameNsImpl.java生成/ ObjectFactory.java</code></pre></div>
                        <!-- class="section" -->
                     </div>
                  </div>
               </div><a id="ADXDK19305"></a><div class="props_rev_3"><a id="GUID-2A8D5A7F-DF15-4355-8A9A-F985DE89D395" name="GUID-2A8D5A7F-DF15-4355-8A9A-F985DE89D395"></a><h4 id="ADXDK-GUID-2A8D5A7F-DF15-4355-8A9A-F985DE89D395" class="sect4">XDK中不支持JAXB功能</h4>
                  <div>
                     <p>描述了JAXB规范的XDK实现不支持的功能。</p>
                     <p>JAXB规范的XDK实现不支持以下功能：</p>
                     <ul style="list-style-type:disc">
                        <li>
                           <p>Javadoc一代</p>
                        </li>
                        <li>
                           <p>XML Schema组件“any”和替换组</p>
                        </li>
                     </ul>
                  </div>
               </div>
            </div><a id="ADXDK1000"></a><a id="ADXDK19306"></a><div class="props_rev_3"><a id="GUID-C465678A-AAA4-42EA-ACAB-DC2D294607CF" name="GUID-C465678A-AAA4-42EA-ACAB-DC2D294607CF"></a><h3 id="ADXDK-GUID-C465678A-AAA4-42EA-ACAB-DC2D294607CF" class="sect3">使用JAXB类生成器处理XML</h3>
               <div>
                  <p>主题包括绑定复杂类型和在顶级元素中自定义类名。</p>
                  <div class="section"> </div>
                  <!-- class="section" -->
               </div><a id="ADXDK19307"></a><div class="props_rev_3"><a id="GUID-DEB32387-4956-4DDB-89C1-0ED9487EE65B" name="GUID-DEB32387-4956-4DDB-89C1-0ED9487EE65B"></a><h4 id="ADXDK-GUID-DEB32387-4956-4DDB-89C1-0ED9487EE65B" class="sect4">绑定复杂类型</h4>
                  <div>
                     <p><code class="codeph">Sample3.java</code>显示了如何将复杂类型定义绑定到Java内容接口。XML模式中定义的一种复杂类型是通过另一种复杂类型的扩展派生的。
                     </p>
                  </div><a id="ADXDK19309"></a><a id="ADXDK19310"></a><a id="ADXDK19308"></a><div class="props_rev_3"><a id="GUID-80E81154-740C-4AAD-A33A-BAEBB1821D05" name="GUID-80E81154-740C-4AAD-A33A-BAEBB1821D05"></a><h5 id="ADXDK-GUID-80E81154-740C-4AAD-A33A-BAEBB1821D05" class="sect5">定义Schema以验证sample3.xml</h5>
                     <div>
                        <p>定义了一个XML模式<code class="codeph">schema3.xsd</code> ，用于验证XML文档<code class="codeph">schema3.xml</code> 。
                        </p>
                        <div class="section">
                           <p><a href="using-JAXB-class-generator.html#GUID-80E81154-740C-4AAD-A33A-BAEBB1821D05__CHDHFAIA">例18-1</a>显示了为示例应用程序提供输入的XML数据文档。<code class="codeph">sample3.xml</code>文档描述了员工的地址。
                           </p>
                           <p><a href="using-JAXB-class-generator.html#GUID-80E81154-740C-4AAD-A33A-BAEBB1821D05__CHDFGBAC">例18-2中</a>显示的XML模式定义了用于验证<code class="codeph">sample3.xml</code>的结构。模式定义了两个复杂类型和一个元素，它们是定义的：</p>
                        </div>
                        <!-- class="section" -->
                        <div class="section">
                           <ul style="list-style-type:disc">
                              <li>
                                 <p>第一个复杂类型，名为<code class="codeph">Address</code> ，是一系列元素。序列中的每个元素都描述了地址的一部分：名称，门号等。
                                 </p>
                              </li>
                              <li>
                                 <p>第二个复杂类型（名为<code class="codeph">USAddress</code> ）使用<code class="codeph">&lt;extension base="exp:Address"&gt;</code>元素通过向<code class="codeph">Address</code>序列添加特定于美国的元素来扩展<code class="codeph">Address</code> ：state，zip等。<code class="codeph">exp</code>前缀指定<code class="codeph">http://www.oracle.com/sample3/</code>名称空间。
                                 </p>
                              </li>
                              <li>
                                 <p>该元素名为<code class="codeph">myAddress</code> ，类型为<code class="codeph">exp:USAddress</code> 。<code class="codeph">exp</code>前缀指定<code class="codeph">http://www.oracle.com/sample3/</code>名称空间。在<code class="codeph">sample3.xml</code> ， <code class="codeph">myAddress</code>顶级元素（位于命名空间<code class="codeph">http://www.oracle.com/sample3/</code> ）符合模式定义。
                                 </p>
                              </li>
                           </ul>
                        </div>
                        <!-- class="section" -->
                        <div class="example" id="GUID-80E81154-740C-4AAD-A33A-BAEBB1821D05__CHDHFAIA">
                           <p class="titleinexample">例18-1 sample3.xml</p><pre class="oac_no_warn" dir="ltr">&lt;？xml版本=“1.0”？&gt; &lt;myAddress xmlns =“http://www.oracle.com/sample3/”xmlns：xsi =“http://www.w3.org/2001/XMLSchema-instance”xsi：schemaLocation =“http：// www .oracle.com / sample3 sample3.xsd“&gt; &lt;name&gt; James Bond &lt;/ name&gt; &lt;doorNumber&gt; 420 &lt;/ doorNumber&gt; &lt;street&gt; Oracle parkway &lt;/ street&gt; &lt;city&gt; Redwood shores &lt;/ city&gt; &lt;state&gt; CA &lt;/ state&gt; &lt;zip&gt; 94065 &lt;/ zip&gt; &lt;country&gt;美国&lt;/ country&gt; &lt;/ myAddress&gt;</pre></div>
                        <!-- class="example" -->
                        <div class="example" id="GUID-80E81154-740C-4AAD-A33A-BAEBB1821D05__CHDFGBAC">
                           <p class="titleinexample">例18-2 sample3.xsd</p><pre class="oac_no_warn" dir="ltr">&lt;？xml版本=“1.0”？&gt; &lt;！ - 将复杂类型定义绑定到java内容接口复杂类型定义通过扩展派生 - &gt; &lt;schema xmlns =“http://www.w3.org/2001/XMLSchema”xmlns：exp =“http ：//www.oracle.com/sample3/“targetNamespace =”http://www.oracle.com/sample3/“elementFormDefault =”qualified“&gt; &lt;complexType name =”Address“&gt; &lt;sequence&gt; &lt;element name =” name“type =”string“/&gt; &lt;element name =”doorNumber“type =”short“/&gt; &lt;element name =”street“type =”string“/&gt; &lt;element name =”city“type =”string“/ &gt; &lt;/ sequence&gt; &lt;/ complexType&gt; &lt;complexType name =“USAddress”&gt; &lt;complexContent&gt; &lt;extension base =“exp：Address”&gt; &lt;sequence&gt; &lt;element name =“state”type =“string”/&gt; &lt;element name =“zip”type =“integer”/&gt; &lt;element name =“country”type =“string”/&gt; &lt;/ sequence&gt; &lt;/ extension&gt; &lt;/ complexContent&gt; &lt;/ complexType&gt; &lt;element name =“myAddress”type = “exp：USAddress”/&gt; &lt;/ schema&gt;</pre></div>
                        <!-- class="example" -->
                     </div>
                  </div><a id="ADXDK19312"></a><a id="ADXDK19311"></a><div class="props_rev_3"><a id="GUID-4856DA6D-E775-4296-8563-C8A09E04D88D" name="GUID-4856DA6D-E775-4296-8563-C8A09E04D88D"></a><h5 id="ADXDK-GUID-4856DA6D-E775-4296-8563-C8A09E04D88D" class="sect5">生成和编译Java类</h5>
                     <div>
                        <p>如果您有XML文档和相应的XML模式，那么下一个处理阶段是从XML模式生成Java类。</p>
                        <div class="section">
                           <p>您可以使用<a href="using-JAXB-class-generator.html#GUID-1EBF886C-9940-4379-9143-C515F350F7E0" title="XDK包括orajaxb，它是一个命令行Java接口，可从输入XML模式生成Java类。Shell脚本$ ORACLE_HOME / bin / orajaxb和％ORACLE_HOME％\ bin \ orajaxb.bat执行类oracle.xml.jaxb.orajaxb。">使用JAXB类生成器命令行实用程序中</a>描述的JAXB命令行界面来执行此任务。
                           </p>
                           <p>假设您的环境是按照<a href="getting-started-with-XDK-for-Java.html#GUID-EA5DB831-1D91-453A-AF7B-7B55343B1720" title="You can set up the XDK for Java environment using either an environment variable or a command-line option.">设置XDK for Java环境中</a>所述进行<a href="getting-started-with-XDK-for-Java.html#GUID-EA5DB831-1D91-453A-AF7B-7B55343B1720" title="您可以使用环境变量或命令行选项设置XDK for Java环境。">设置的</a> ，则可以在<code class="codeph">generated</code>包中创建源文件：</p><pre class="oac_no_warn" dir="ltr">cd $ ORACLE_HOME / xdk / demo / java / jaxb / Sample3 orajaxb -schema sample1.xsd -targetPkg生成</pre><p>前面的<code class="codeph">orajaxb</code>命令在<code class="codeph">./generated/</code>子目录中创建这些源文件：</p><pre class="oac_no_warn" dir="ltr">Address.java AddressImpl.java MyAddress.java MyAddressImpl.java ObjectFactory.java USAddress.java USAddressImpl.java</pre><p>复杂类型<code class="codeph">Address</code>和<code class="codeph">USAddress</code>各有两个关联的源文件，元素<code class="codeph">MyAddress</code> 。以元素命名的源文件包含接口;带有后缀<code class="codeph">Impl</code>的文件包含实现接口的类。例如， <code class="codeph">Address.java</code>包含接口<code class="codeph">Address</code> ，而<code class="codeph">AddressImpl.java</code>包含实现<code class="codeph">Address</code>的类。
                           </p>
                           <p><code class="codeph">Address.java</code>源文件的内容如<a href="using-JAXB-class-generator.html#GUID-4856DA6D-E775-4296-8563-C8A09E04D88D__CHDEAHGH">例18-3</a>所示。
                           </p>
                           <p><code class="codeph">Address</code>复杂类型定义了一系列元素： <code class="codeph">name</code> ， <code class="codeph">doorNumber</code> ， <code class="codeph">street</code>和<code class="codeph">city</code> 。因此， <code class="codeph">Address</code>接口包含四个元素中每个元素的<code class="codeph">get</code>和<code class="codeph">set</code>方法签名。例如，接口包括用于检索<code class="codeph">&lt;name&gt;</code>元素中的数据的<code class="codeph">getName()</code>和用于修改此元素中的数据的<code class="codeph">setName()</code> 。
                           </p>
                           <p>您可以使用<code class="codeph">javac</code>编译Java源文件：</p><pre class="oac_no_warn" dir="ltr">cd $ ORACLE_HOME / xdk / demo / java / jaxb / Sample3 / generated javac * .java</pre></div>
                        <!-- class="section" -->
                        <div class="example" id="GUID-4856DA6D-E775-4296-8563-C8A09E04D88D__CHDEAHGH">
                           <p class="titleinexample">例18-3 Address.java</p><pre class="oac_no_warn" dir="ltr">包生成; public interface Address {public void setName（java.lang。字符串n）; public java.lang。String getName（）; public void setDoorNumber（短d）; public short getDoorNumber（）; public void setStreet（java.lang。String s）; public java.lang。String getStreet（）; public void setCity（java.lang。字符串c）; public java.lang。String getCity（）; }</pre></div>
                        <!-- class="example" -->
                     </div>
                  </div><a id="ADXDK19313"></a><div class="props_rev_3"><a id="GUID-A736D441-BA33-4B06-A5B8-D9ECC5C5A06A" name="GUID-A736D441-BA33-4B06-A5B8-D9ECC5C5A06A"></a><h5 id="ADXDK-GUID-A736D441-BA33-4B06-A5B8-D9ECC5C5A06A" class="sect5">处理sample3.xml中的XML数据</h5>
                     <div>
                        <p><code class="codeph">Sample3.java</code>解组XML数据文档，对其进行编组，并使用生成的类来打印和修改地址数据。
                        </p>
                        <div class="section">
                           <p>它显示了如何使用在<a href="using-JAXB-class-generator.html#GUID-4856DA6D-E775-4296-8563-C8A09E04D88D" title="If you have an XML document and corresponding XML schema, then the next stage of processing is to generate the Java classes from the XML schema.">生成和编译Java类</a>中<a href="using-JAXB-class-generator.html#GUID-4856DA6D-E775-4296-8563-C8A09E04D88D" title="如果您有XML文档和相应的XML模式，那么下一个处理阶段是从XML模式生成Java类。">生成</a>的Java类文件来处理<code class="codeph">sample3.xml</code>文档。
                           </p>
                           <p><code class="codeph">Sample3.java</code>程序按如下方式处理数据：</p>
                        </div>
                        <!-- class="section" -->
                        <ol>
                           <li class="stepexpand"><span>为XML数据文档文件名创建字符串，并为包含生成的类的目录创建名称。此名称是包名称。例如：</span><div><pre class="oac_no_warn" dir="ltr">String fileName =“sample3.xml”; String instancePath =“generated”;</pre></div>
                           </li>
                           <li class="stepexpand"><span>通过调用<code class="codeph">JAXBContext.newInstance()</code>实例化JAXB上下文。客户端应用程序通过使用上下文路径初始化它来获取此类的新实例。该路径包含一个Java包名称列表，其中包含marshaller可用的接口。这句话显示了这种技术：</span><div><pre class="oac_no_warn" dir="ltr">JAXBContext jc = JAXBContext.newInstance（instancePath）;</pre></div>
                           </li>
                           <li class="stepexpand"><span>实例化unmarshaller。<code class="codeph">Unmarshaller</code>类管理将XML数据反序列化为新创建的对象的过程，可选择在解组时验证XML数据。这句话显示了这种技术：</span><div><pre class="oac_no_warn" dir="ltr">Unmarshaller u = jc.createUnmarshaller（）;</pre></div>
                           </li>
                           <li class="stepexpand"><span>解组XML文档。调用<code class="codeph">Unmarshaller.unmarshal()</code>方法反序列化<code class="codeph">sample3.xml</code>文档并将内容树作为<code class="codeph">Object</code>返回。您可以通过调用<code class="codeph">fileToUrl()</code>辅助方法从XML文件名创建URL。该声明显示了该技术：</span><div><pre class="oac_no_warn" dir="ltr">Object obj = u.unmarshal（fileToURL（fileName））;</pre></div>
                           </li>
                           <li class="stepexpand"><span>实例化marshaller。<code class="codeph">Marshaller</code>类管理将Java内容树序列化为XML数据的过程。这句话显示了这种技术：</span><div><pre class="oac_no_warn" dir="ltr">Marshaller m = jc.createMarshaller（）;</pre></div>
                           </li>
                           <li class="stepexpand"><span>元帅内容树。调用<code class="codeph">Marshaller.marshal()</code>方法来封送由unmarshaller返回的内容树<code class="codeph">Object</code> 。您可以将数据序列化为DOM树，SAX内容处理程序，转换结果或输出流。此语句将XML数据（包括标记）序列化为输出流：</span><div><pre class="oac_no_warn" dir="ltr">m.marshal（obj，System.out）;</pre><p>默认情况下，编组器在将XML数据写入输出流时使用Unicode（UTF-8）编码的8位编码。</p>
                              </div>
                           </li>
                           <li class="stepexpand"><span>打印XML文档的内容。该程序实现了一个<code class="codeph">process()</code>方法，该方法接受内容树和marshaller作为参数。</span><div>
                                 <p>处理的第一阶段在没有XML标记的情况下打印XML文档中的数据。该方法将marshaller生成的<code class="codeph">Object</code>强制转换为<code class="codeph">MyAddress</code>类型。它继续调用一系列方法，其方法名称通过前缀<code class="codeph">get</code> XML元素的名称来构造。例如，要获取<a href="using-JAXB-class-generator.html#GUID-80E81154-740C-4AAD-A33A-BAEBB1821D05__CHDHFAIA">示例18-1中</a> <code class="codeph">&lt;city&gt;</code>元素中的数据，程序将调用<code class="codeph">getCity()</code> 。此代码片段显示了此技术：</p><pre class="oac_no_warn" dir="ltr">public static void process（Object obj，Marshaller m）抛出Throwable {generated。MyAddress elem =（生成。MyAddress）目标文件;的System.out.println（）; System.out.println（“我的地址是：”）; System.out.println（“name：”+ elem.getName（）+“\ n”+“doorNumber”+ elem.getDoorNumber（）+“\ n”+“street：”+ elem.getStreet（）+“\ n“+”city：“+ elem.getCity（）+”\ n“+”state：“+ elem.getState（）+”\ n“+”zip：“+ elem.getZip（）+”\ n“ +“country：”+ elem.getCountry（）+“\ n”+“\ n”）; ...
</pre></div>
                           </li>
                           <li class="stepexpand"><span>更改XML数据并打印它。<code class="codeph">process()</code>方法通过调用类似于前面的get方法的set方法继续。每个set方法的名称都是通过将<code class="codeph">set</code>前缀添加到XML元素的名称来构造的。例如， <code class="codeph">setCountry()</code>更改<code class="codeph">&lt;country&gt;</code>元素中的值。这些陈述显示了这种技术：</span><div><pre class="oac_no_warn" dir="ltr">短号= 550; elem.setDoorNumber（NUM）; elem.setCountry（ “印度”）; num = 10100; elem.setZip（new java.math。的BigInteger（ “100100”））; elem.setCity（ “诺依”）; elem.setState（ “德里”）;</pre><p>更改数据后，程序通过调用与上一步相同的get方法打印数据。</p>
                              </div>
                           </li>
                        </ol>
                     </div>
                  </div>
               </div><a id="ADXDK19314"></a><div class="props_rev_3"><a id="GUID-C54597F9-B701-4D56-8254-1F6F3268F533" name="GUID-C54597F9-B701-4D56-8254-1F6F3268F533"></a><h4 id="ADXDK-GUID-C54597F9-B701-4D56-8254-1F6F3268F533" class="sect4">自定义顶级元素中的类名</h4>
                  <div>
                     <p><code class="codeph">Sample10.java</code>程序显示了一种JAXB定制形式。该程序显示您可以更改与输入XML架构中的元素对应的类的名称。
                     </p>
                  </div><a id="ADXDK19316"></a><a id="ADXDK19317"></a><a id="ADXDK19315"></a><div class="props_rev_3"><a id="GUID-4E82459F-4799-4FC9-9A36-7703287021EE" name="GUID-4E82459F-4799-4FC9-9A36-7703287021EE"></a><h5 id="ADXDK-GUID-4E82459F-4799-4FC9-9A36-7703287021EE" class="sect5">定义Schema以验证schema10.xml</h5>
                     <div>
                        <p>定义了一个XML模式<code class="codeph">schema10.xsd</code> ，用于验证XML文档<code class="codeph">schema10.xml</code> 。
                        </p>
                        <div class="section">
                           <p><a href="using-JAXB-class-generator.html#GUID-4E82459F-4799-4FC9-9A36-7703287021EE__CHDDHGIJ">例18-4</a>显示了为示例应用程序提供输入的XML数据文档。<code class="codeph">sample10.xml</code>文档描述了一个业务。
                           </p>
                           <p><a href="using-JAXB-class-generator.html#GUID-4E82459F-4799-4FC9-9A36-7703287021EE__CHDFICJC">例18-5</a>显示了定义<code class="codeph">sample10.xml</code>结构的XML模式。模式定义了一个复杂类型和一个元素，如下所示：</p>
                        </div>
                        <!-- class="section" -->
                        <div class="section">
                           <ul style="list-style-type:disc">
                              <li>
                                 <p>复杂类型（名为<code class="codeph">businessType</code> ）是一系列元素。序列中的每个元素都描述了业务的一部分：title，owner和id。
                                 </p>
                              </li>
                              <li>
                                 <p>该元素名为<code class="codeph">business</code> ，属于<code class="codeph">biz:businessType</code>类型。<code class="codeph">biz</code>前缀指定<code class="codeph">http://jaxbcustomized/sample10/</code> namespace。在<code class="codeph">sample10.xml</code> ，该<code class="codeph">business</code>最高级别的元素，这是在命名空间中<code class="codeph">http://jaxbcustomized/sample10/</code> ，符合模式定义。
                                 </p>
                              </li>
                           </ul>
                        </div>
                        <!-- class="section" -->
                        <div class="example" id="GUID-4E82459F-4799-4FC9-9A36-7703287021EE__CHDDHGIJ">
                           <p class="titleinexample">例18-4 sample10.xml</p><pre class="oac_no_warn" dir="ltr">&lt;？xml版本=“1.0”？&gt; &lt;business xmlns =“http：// jaxbcustomized / sample10 /”&gt; &lt;title&gt;软件开发&lt;/ title&gt; &lt;owner&gt; Larry Peterson &lt;/ owner&gt; &lt;id&gt; 45123 &lt;/ id&gt; &lt;/ business&gt;</pre></div>
                        <!-- class="example" -->
                        <div class="example" id="GUID-4E82459F-4799-4FC9-9A36-7703287021EE__CHDFICJC">
                           <p class="titleinexample">例18-5 sample10.xsd</p><pre class="oac_no_warn" dir="ltr">&lt;？xml版本=“1.0”？&gt; &lt;！ - 在顶级元素中自定义类名 - &gt; &lt;schema xmlns =“http://www.w3.org/2001/XMLSchema”targetNamespace =“http：// jaxbcustomized / sample10 /”xmlns：biz =“http：// jaxbcustomized / sample10 /”xmlns：jaxb =“http://java.sun.com/xml/ns/jaxb”jaxb：version =“1.0”elementFormDefault =“qualified”&gt; &lt;element name =“ business“type =”biz：businessType“&gt; &lt;annotation&gt; &lt;appinfo&gt; &lt;jaxb：class name =”myBusiness“/&gt; &lt;/ appinfo&gt; &lt;/ annotation&gt; &lt;/ element&gt; &lt;complexType name =”businessType“&gt; &lt;sequence&gt; &lt;element name =“title”type =“string”/&gt; &lt;element name =“owner”type =“string”/&gt; &lt;element name =“id”type =“integer”/&gt; &lt;/ sequence&gt; &lt;/ complexType&gt; &lt;/模式&gt;</pre></div>
                        <!-- class="example" -->
                     </div><a id="ADXDK19318"></a><div class="props_rev_3"><a id="GUID-3A871D54-8F6C-4DEC-8E0A-DBE5B6123D5A" name="GUID-3A871D54-8F6C-4DEC-8E0A-DBE5B6123D5A"></a><h6 id="ADXDK-GUID-3A871D54-8F6C-4DEC-8E0A-DBE5B6123D5A" class="sect6">自定义架构绑定</h6>
                        <div>
                           <p>描述了XML模式<code class="codeph">sample10.xsd</code>中使用的绑定自定义。
                           </p>
                           <div class="section">
                              <p><a href="using-JAXB-class-generator.html#GUID-4E82459F-4799-4FC9-9A36-7703287021EE__CHDFICJC">例18-5中</a>显示的模式自定义<code class="codeph">business</code>元素与内联绑定声明的绑定。内联自定义的一般形式是：</p><pre class="oac_no_warn" dir="ltr">&lt;xs：annotation&gt; &lt;xs：appinfo&gt;。。绑定声明。。&lt;/ xs：appinfo&gt; &lt;/ xs：annotation&gt;</pre><p><a href="using-JAXB-class-generator.html#GUID-4E82459F-4799-4FC9-9A36-7703287021EE__CHDFICJC">例18-5</a>使用<code class="codeph">&lt;class&gt;</code>绑定声明将schema元素绑定到Java类名。您可以使用声明来自定义接口的名称或实现接口的类。JAXB类生成器支持<code class="codeph">&lt;class&gt;</code>自定义的此语法：</p><pre class="oac_no_warn" dir="ltr">&lt;class [name =“className”]&gt;</pre><p><code class="codeph">name</code>属性指定派生Java接口的名称。<a href="using-JAXB-class-generator.html#GUID-4E82459F-4799-4FC9-9A36-7703287021EE__CHDFICJC">例18-5</a>包含此自定义：</p><pre class="oac_no_warn" dir="ltr">&lt;jaxb：class name =“myBusiness”/&gt;</pre><p>因此，模式将<code class="codeph">business</code>元素绑定到接口<code class="codeph">myBusiness</code>而不是接口<code class="codeph">business</code> ，这是默认设置。
                              </p>
                           </div>
                           <!-- class="section" -->
                        </div>
                     </div>
                  </div><a id="ADXDK19320"></a><a id="ADXDK19319"></a><div class="props_rev_3"><a id="GUID-FFB7871B-1474-4449-8238-6682BF539319" name="GUID-FFB7871B-1474-4449-8238-6682BF539319"></a><h5 id="ADXDK-GUID-FFB7871B-1474-4449-8238-6682BF539319" class="sect5">生成和编译Java类</h5>
                     <div>
                        <p>获得XML文档和相应的XML模式后，下一步是从XML模式生成Java类。您可以使用JAXB命令行界面来执行此任务。</p>
                        <div class="section">
                           <p>如果按照<a href="getting-started-with-XDK-for-Java.html#GUID-EA5DB831-1D91-453A-AF7B-7B55343B1720" title="You can set up the XDK for Java environment using either an environment variable or a command-line option.">设置XDK for Java环境中的</a>描述<a href="getting-started-with-XDK-for-Java.html#GUID-EA5DB831-1D91-453A-AF7B-7B55343B1720" title="您可以使用环境变量或命令行选项设置XDK for Java环境。">设置环境</a> ，则可以在<code class="codeph">generated</code>包中创建源文件：</p><pre class="oac_no_warn" dir="ltr">cd $ ORACLE_HOME / xdk / demo / java / jaxb / Sample10 orajaxb -schema sample10.xsd</pre><p>因为前面的命令没有指定目标包，所以包名称是从模式的目标名称空间构造的，即<code class="codeph">http://jaxbcustomized/sample10/</code> 。因此，该实用程序在<code class="codeph">./jaxbcustomized/sample10/</code>子目录中生成这些源文件：</p><pre class="oac_no_warn" dir="ltr">BusinessType.java BusinessTypeImpl.java MyBusiness.java MyBusinessImpl.java ObjectFactory.java</pre><p>复杂类型<code class="codeph">businessType</code>有两个源文件， <code class="codeph">BusinessType.java</code>和<code class="codeph">BusinessTypeImpl.java</code> 。由于JAXB自定义， <code class="codeph">business</code>元素绑定到<code class="codeph">MyBusiness</code>接口并实现类<code class="codeph">MyBusinessImpl</code> 。
                           </p>
                           <p><a href="using-JAXB-class-generator.html#GUID-FFB7871B-1474-4449-8238-6682BF539319__CHDECCFJ">示例18-6中</a>显示了<code class="codeph">BusinessType.java</code>源文件的内容。
                           </p>
                           <p><code class="codeph">BusinessType</code>复杂类型定义了一系列元素： <code class="codeph">title</code> ， <code class="codeph">owner</code>和<code class="codeph">id</code> 。因此， <code class="codeph">Address</code>接口包含每个元素的<code class="codeph">get</code>和<code class="codeph">set</code>方法签名。例如，接口包括用于检索<code class="codeph">&lt;title&gt;</code>元素中的数据的<code class="codeph">getTitle()</code>和用于修改此元素中的数据的<code class="codeph">setTitle()</code> 。
                           </p>
                           <p>您可以使用<code class="codeph">javac</code>编译Java源文件：</p><pre class="oac_no_warn" dir="ltr">cd $ ORACLE_HOME / xdk / demo / java / jaxb / Sample10 / jaxbcustomized / sample10 javac * .java</pre></div>
                        <!-- class="section" -->
                        <div class="example" id="GUID-FFB7871B-1474-4449-8238-6682BF539319__CHDECCFJ">
                           <p class="titleinexample">例18-6 BusinessType.java</p><pre class="oac_no_warn" dir="ltr">package jaxbcustomized.sample10; public interface BusinessType {public void setTitle（java.lang。字符串t）; public java.lang。String getTitle（）; public void setOwner（java.lang。字符串o）; public java.lang。String getOwner（）; public void setId（java.math。BigInteger i）; public java.math。BigInteger getId（）; }</pre></div>
                        <!-- class="example" -->
                     </div>
                  </div><a id="ADXDK19321"></a><div class="props_rev_3"><a id="GUID-8F929D03-ACF4-4DC1-BEBC-09BAB2F3584B" name="GUID-8F929D03-ACF4-4DC1-BEBC-09BAB2F3584B"></a><h5 id="ADXDK-GUID-8F929D03-ACF4-4DC1-BEBC-09BAB2F3584B" class="sect5">处理sample10.xml中的XML数据</h5>
                     <div>
                        <p><code class="codeph">Sample10.java</code>解组XML文档，打印其内容，并将XML编组到标准输出。
                        </p>
                        <div class="section">
                           <p><code class="codeph">Sample10.java</code>说明如何处理数据<code class="codeph">sample10.xml</code>使用您在生成的类文件的文件<a href="using-JAXB-class-generator.html#GUID-FFB7871B-1474-4449-8238-6682BF539319" title="获得XML文档和相应的XML模式后，下一步是从XML模式生成Java类。您可以使用JAXB命令行界面来执行此任务。">生成和编译Java类</a> 。
                           </p>
                           <p><code class="codeph">Sample10.java</code>程序按如下方式处理XML数据：</p>
                        </div>
                        <!-- class="section" -->
                        <ol>
                           <li class="stepexpand"><span>为XML数据文档文件名创建字符串，并为包含生成的类的目录创建名称。此名称是包名称。例如：</span><div><pre class="oac_no_warn" dir="ltr">String fileName =“sample10.xml”; String instancePath =“jaxbcustomized.sample10”;</pre></div>
                           </li>
                           <li class="stepexpand"><span>通过调用<code class="codeph">JAXBContext.newInstance()</code>方法实例化JAXB上下文。该声明显示了这种技术：</span><div><pre class="oac_no_warn" dir="ltr">JAXBContext jc = JAXBContext.newInstance（instancePath）;</pre></div>
                           </li>
                           <li class="stepexpand"><span>创建unmarshaller。该声明显示了这种技术：</span><div><pre class="oac_no_warn" dir="ltr">Unmarshaller u = jc.createUnmarshaller（）;</pre></div>
                           </li>
                           <li class="stepexpand"><span>解组XML文档。程序解组文档两次：它首先返回一个<code class="codeph">Object</code> ，然后使用<code class="codeph">MyBusiness</code>转换返回一个<code class="codeph">MyBusiness</code>对象。该声明显示了这种技术：</span><div><pre class="oac_no_warn" dir="ltr">Object obj = u.unmarshal（fileToURL（fileName））; jaxbcustomized.sample10。MyBusiness bus =（jaxbcustomized.sample10。MyBusiness）u.unmarshal（fileToURL（fileName））;</pre></div>
                           </li>
                           <li class="stepexpand"><span>打印XML文档的内容。该程序调用<code class="codeph">MyBusiness</code>对象上的<code class="codeph">get</code>方法。此代码片段显示了此技术：</span><div><pre class="oac_no_warn" dir="ltr">System.out.println（“我的业务详情是：”）; System.out.println（“title：”+ bus.getTitle（））; System.out.println（“owner：”+ bus.getOwner（））; System.out.println（“id：”+ bus.getId（）。toString（））;的System.out.println（）;</pre></div>
                           </li>
                           <li class="stepexpand"><span>创建一个编组器。该声明显示了这种技术：</span><div><pre class="oac_no_warn" dir="ltr">Marshaller m = jc.createMarshaller（）;</pre></div>
                           </li>
                           <li class="stepexpand"><span>配置编组程序。您可以调用<code class="codeph">setProperty()</code>来配置marshaller的各种属性。<code class="codeph">JAXB_FORMATTED_OUTPUT</code>常量指定编组器必须使用换行符和缩进格式化生成的XML数据。这些陈述显示了这种技术：</span><div><pre class="oac_no_warn" dir="ltr">m.setProperty（编组器。JAXB_FORMATTED_OUTPUT，new Boolean（true））;</pre></div>
                           </li>
                           <li class="stepexpand"><span>元帅内容树。此语句将XML数据（包括标记）序列化为输出流：</span><div><pre class="oac_no_warn" dir="ltr">m.marshal（bus，System.out）;</pre><p>默认情况下，编组器在将XML数据写入输出流时使用UTF-8编码。</p>
                              </div>
                           </li>
                        </ol>
                     </div>
                  </div>
               </div>
            </div>
         </div>
      </article>
   </body>
</html>