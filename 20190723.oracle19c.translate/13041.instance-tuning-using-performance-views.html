<html lang="en-us" dir="ltr" xml:lang="en-us">
   <head>
      <meta http-equiv="Content-Type" content="text/html; charset=utf-8"></meta>
      <meta name="viewport" content="width=device-width, initial-scale=1"></meta>
      <meta http-equiv="X-UA-Compatible" content="IE=edge"></meta>
      <title>使用性能视图进行实例调整</title>
      <meta property="og:site_name" content="Oracle Help Center"></meta>
      <meta property="og:title" content="Database Performance Tuning Guide"></meta>
      <meta property="og:description" content=""></meta>
      <link rel="stylesheet" href="/sp_common/book-template/ohc-book-template/css/book.css"></link>
      <link rel="shortcut icon" href="/sp_common/book-template/ohc-common/img/favicon.ico"></link>
      <meta name="application-name" content="Database Performance Tuning Guide"></meta>
      <meta name="generator" content="DITA Open Toolkit version 1.8.5 (Mode = doc)"></meta>
      <meta name="plugin" content="SP_docbuilder HTML plugin release 18.2.2"></meta>
      <link rel="alternate" href="database-performance-tuning-guide.pdf" title="PDF File" type="application/pdf"></link>
      <meta name="robots" content="all"></meta>
      <link rel="schema.dcterms" href="http://purl.org/dc/terms/"></link>
      <meta name="dcterms.created" content="2019-03-12T22:26:14-07:00"></meta>
      <meta name="dcterms.title" content="Database Performance Tuning Guide"></meta>
      <meta name="dcterms.dateCopyrighted" content="2007, 2019"></meta>
      <meta name="dcterms.category" content="database"></meta>
      <meta name="dcterms.identifier" content="E96347-03"></meta>
      
      <meta name="dcterms.product" content="en/database/oracle/oracle-database/19"></meta>
      
      <link rel="prev" href="analyzing-sampled-data.html" title="Previous" type="text/html"></link>
      <link rel="next" href="part-III-tuning-database-memory.html" title="Next" type="text/html"></link>
      <script>
        document.write('<style type="text/css">');
        document.write('body > .noscript, body > .noscript ~ * { visibility: hidden; }');
        document.write('</style>');
     </script>
      <script src="/sp_common/book-template/requirejs/require.js" data-main="/sp_common/book-template/ohc-book-template/js/book-config"></script>
      <script>
            if (window.require === undefined) {
                document.write('<script data-main="sp_common/book-template/ohc-book-template/js/book-config" src="sp_common/book-template/requirejs/require.js"><\/script>');
                document.write('<link href="sp_common/book-template/ohc-book-template/css/book.css" rel="stylesheet"/>');
            }
        </script>
      <script type="application/json" id="ssot-metadata">{"primary":{"category":{"short_name":"database","element_name":"Database","display_in_url":true},"suite":{"short_name":"oracle","element_name":"Oracle","display_in_url":true},"product_group":{"short_name":"not-applicable","element_name":"Not applicable","display_in_url":false},"product":{"short_name":"oracle-database","element_name":"Oracle Database","display_in_url":true},"release":{"short_name":"19","element_name":"Release 19","display_in_url":true}}}</script>
      
    <meta name="dcterms.isVersionOf" content="TGDBA"></meta>
    <meta name="dcterms.release" content="Release 19"></meta>
  </head>
   <body dir="ltr">
      <div class="noscript alert alert-danger text-center" role="alert">
         <a href="analyzing-sampled-data.html" class="pull-left"><span class="glyphicon glyphicon-chevron-left" aria-hidden="true"></span>上一页</a> <a href="part-III-tuning-database-memory.html" class="pull-right">下一页<span class="glyphicon glyphicon-chevron-right" aria-hidden="true"></span></a> <span class="fa fa-exclamation-triangle" aria-hidden="true"></span>必须启用JavaScript才能正确显示此内容</div>
      <article>
         <header>
            <ol class="breadcrumb" vocab="http://schema.org/" typeof="BreadcrumbList">
               <li property="itemListElement" typeof="ListItem"><a href="index.html" property="item" typeof="WebPage"><span property="name">数据库性能调优指南</span></a></li>
               <li property="itemListElement" typeof="ListItem"><a href="part-II-diagnosing-and-tuning-database-performance.html" property="item" typeof="WebPage"><span property="name">诊断和调整数据库性能</span></a></li>
               <li class="active" property="itemListElement" typeof="ListItem">使用性能视图进行实例调整</li>
            </ol>
            <a id="GUID-07982549-507F-4465-8843-7F753BCF8F99" name="GUID-07982549-507F-4465-8843-7F753BCF8F99"></a><a id="TGDBA024"></a>
            
            <h2 id="TGDBA-GUID-07982549-507F-4465-8843-7F753BCF8F99" class="sect2"><span class="enumeration_chapter">10</span>使用性能视图进行实例调整</h2>
         </header>
         <div class="ind">
            <div>
               <p><a id="d25676e48" class="indexterm-anchor"></a><a id="d25676e52" class="indexterm-anchor"></a><a id="d25676e56" class="indexterm-anchor"></a>在初始配置数据库之后，定期监视和调整实例对于消除任何潜在的性能瓶颈非常重要。本章讨论使用Oracle <code class="codeph">V$</code>性能视图的调优过程。
               </p>
               <p>本章包含以下部分：</p>
               <ul style="list-style-type:disc">
                  <li>
                     <p><a href="instance-tuning-using-performance-views.html#GUID-18A2E92F-0F24-4F47-9C6E-6806E942A76A">实例调整步骤</a></p>
                  </li>
                  <li>
                     <p><a href="instance-tuning-using-performance-views.html#GUID-1335E243-77FE-4411-92CB-74F93DD23609">解释Oracle数据库统计信息</a></p>
                  </li>
                  <li>
                     <p><a href="instance-tuning-using-performance-views.html#GUID-386931AB-A199-41E8-A20C-7317A4FDCACC">等待事件统计</a></p>
                  </li>
                  <li>
                     <p><a href="instance-tuning-using-performance-views.html#GUID-E281EB31-5762-4945-9497-BBB923A6FF50">调整实例恢复性能：快速启动故障恢复</a></p>
                  </li>
               </ul>
            </div><a id="TGDBA02401"></a><div class="props_rev_3"><a id="GUID-18A2E92F-0F24-4F47-9C6E-6806E942A76A" name="GUID-18A2E92F-0F24-4F47-9C6E-6806E942A76A"></a><h3 id="TGDBA-GUID-18A2E92F-0F24-4F47-9C6E-6806E942A76A" class="sect3"><span class="enumeration_section">10.1</span>实例调整步骤</h3>
               <div>
                  <div class="section">
                     <p>这些是用于实例调优的Oracle性能方法的主要步骤：</p>
                  </div>
                  <!-- class="section" -->
                  <ol>
                     <li class="stepexpand"><span><a href="instance-tuning-using-performance-views.html#GUID-03BEA921-4BB8-4E55-95D1-7C4C6B7131CF">定义问题</a></span><div>
                           <p>从用户那里获得有关性能问题范围的坦诚反馈。</p>
                        </div>
                     </li>
                     <li class="stepexpand"><span><a href="instance-tuning-using-performance-views.html#GUID-26F451C1-3A30-4E9D-AD41-F1C02446E5A7">检查主机系统</a>并<a href="instance-tuning-using-performance-views.html#GUID-C0DE00D7-C69F-4938-9FE3-78A070524817">检查Oracle数据库统计信息</a></span><div>
                           <ul style="list-style-type:disc">
                              <li>
                                 <p>获取完整的操作系统，数据库和应用程序统计信息后，检查数据是否存在任何性能问题的证据。</p>
                              </li>
                              <li>
                                 <p>考虑常见性能错误列表，以查看收集的数据是否表明它们是导致问题的原因。</p>
                              </li>
                              <li>
                                 <p>使用收集的性能数据构建系统上发生的事件的概念模型。</p>
                              </li>
                           </ul>
                        </div>
                     </li>
                     <li class="stepexpand"><span><a href="instance-tuning-using-performance-views.html#GUID-AA7607E6-8A86-4A54-88B7-161CA970D052">实施和衡量变革</a></span><div>
                           <p>建议进行更改以及实施更改的预期结果。然后，实施更改并测量应用程序性能。</p>
                        </div>
                     </li>
                     <li class="stepexpand"><span>确定是否已满足步骤1中定义的性能目标。如果没有，则重复步骤2和3，直到达到性能目标。</span></li>
                  </ol>
                  <div class="section">
                     <p>本章的其余部分讨论使用Oracle数据库动态性能视图进行实例调优。但是，由于扩展功能列表，Oracle建议使用自动工作负载存储库（AWR）和自动数据库诊断监视器（ADDM）进行统计信息收集，监视和调整。</p>
                     <div class="infoboxnote" id="GUID-18A2E92F-0F24-4F47-9C6E-6806E942A76A__GUID-8049D2F9-B6E9-497D-9CE6-49CAA5B2BDEF">
                        <p class="notep1">注意：</p>
                        <p>如果您的站点没有AWR和ADDM功能，则可以使用Statspack收集Oracle数据库实例统计信息。</p>
                     </div>
                  </div>
                  <!-- class="section" -->
               </div><a id="TGDBA94436"></a><div class="props_rev_3"><a id="GUID-03BEA921-4BB8-4E55-95D1-7C4C6B7131CF" name="GUID-03BEA921-4BB8-4E55-95D1-7C4C6B7131CF"></a><h4 id="TGDBA-GUID-03BEA921-4BB8-4E55-95D1-7C4C6B7131CF" class="sect4"><span class="enumeration_section">10.1.1</span>定义问题</h4>
                  <div>
                     <div class="section">
                        <p>在尝试实施解决方案之前，充分理解调整练习的目的和问题的本质至关重要。没有这种理解，实际上不可能实施有效的改变。在此阶段收集的数据有助于确定下一步采取的步骤以及要检查的证据。</p>
                        <p>收集以下数据：</p>
                     </div>
                     <!-- class="section" -->
                     <ol>
                        <li class="stepexpand"><span>确定绩效目标。</span><div>
                              <p>可接受的绩效衡量标准是什么？一小时或几秒钟的响应时间将达到所需的性能水平？</p>
                           </div>
                        </li>
                        <li class="stepexpand"><span>确定问题的范围。</span><div>
                              <p>受经济放缓影响的是什么？例如，整个实例是否缓慢？它是特定的应用程序，程序，特定操作还是单个用户？</p>
                           </div>
                        </li>
                        <li class="stepexpand"><span>确定问题发生的时间范围。</span><div>
                              <p>问题只在高峰时段出现吗？性能在一天中会恶化吗？经济放缓是逐步的（在数月或数周的时间内）还是突然的？</p>
                           </div>
                        </li>
                        <li class="stepexpand"><span>量化减速。</span><div>
                              <p>这有助于确定问题的严重程度，并在决定为解决问题而实施的变更是否实际上有所改进时，还可作为比较的衡量标准。找到一致的可重复的响应时间或作业运行时间度量。时间比程序运行得好多少？</p>
                           </div>
                        </li>
                        <li class="stepexpand"><span>确定任何变化。</span><div>
                              <p>确定性能可接受后发生了哪些变化。这可能会迅速缩小潜在原因。例如，是否升级了操作系统软件，硬件，应用程序软件或Oracle数据库版本？是否已将更多数据加载到系统中，或者数据量或用户数量是否增长？</p>
                           </div>
                        </li>
                     </ol>
                     <div class="section">
                        <p>在这个阶段结束时，你应该很好地理解症状。如果可以将症状识别为程序或程序集的本地症状，则以与实例范围的性能问题不同的方式处理问题。</p>
                     </div>
                     <!-- class="section" -->
                  </div>
               </div><a id="TGDBA94437"></a><div class="props_rev_3"><a id="GUID-26F451C1-3A30-4E9D-AD41-F1C02446E5A7" name="GUID-26F451C1-3A30-4E9D-AD41-F1C02446E5A7"></a><h4 id="TGDBA-GUID-26F451C1-3A30-4E9D-AD41-F1C02446E5A7" class="sect4"><span class="enumeration_section">10.1.2</span>检查主机系统</h4>
                  <div>
                     <p>查看数据库服务器和数据库实例上的负载。考虑操作系统，I / O子系统和网络统计信息，因为检查这些区域有助于确定值得进一步调查的内容。在多层系统中，还要检查应用程序服务器中间层主机。</p>
                     <p>检查主机硬件通常可以很好地指示系统中的瓶颈。这决定了哪些Oracle数据库性能数据可用于交叉引用和进一步诊断。</p>
                     <p>要检查的数据包括以下内容：</p>
                     <ul style="list-style-type:disc">
                        <li>
                           <p><a href="instance-tuning-using-performance-views.html#GUID-AF97FAB4-36DB-464B-AB7F-1087F367E22D">CPU使用率</a></p>
                        </li>
                        <li>
                           <p><a href="instance-tuning-using-performance-views.html#GUID-6A042D12-3E50-470C-B41F-D20A67C97B1B">识别I / O问题</a></p>
                        </li>
                        <li>
                           <p><a href="instance-tuning-using-performance-views.html#GUID-ED2F69C0-1197-4639-BEFF-6DB0BDBAB683">识别网络问题</a></p>
                        </li>
                     </ul>
                  </div><a id="TGDBA94438"></a><div class="props_rev_3"><a id="GUID-AF97FAB4-36DB-464B-AB7F-1087F367E22D" name="GUID-AF97FAB4-36DB-464B-AB7F-1087F367E22D"></a><h5 id="TGDBA-GUID-AF97FAB4-36DB-464B-AB7F-1087F367E22D" class="sect5"><span class="enumeration_section">10.1.2.1</span> CPU使用率</h5>
                     <div>
                        <p>如果存在大量空闲CPU，则可能存在I / O，应用程序或数据库瓶颈。请注意，等待I / O应被视为空闲CPU。</p>
                        <p>如果CPU使用率很高，则确定是否正在有效使用CPU。大多数CPU使用率是由少量高CPU使用程序引起的，还是由均匀分布的工作负载消耗的CPU？</p>
                        <p>如果少量高使用率程序使用CPU，则查看程序以确定原因。检查某些进程是否仅消耗一个CPU的全部功能。根据流程的不同，这可能表示可以通过划分或并行化流程活动来解决CPU或流程限制的工作负载。</p>
                     </div><a id="TGDBA94439"></a><div class="props_rev_3"><a id="GUID-59B45479-273A-4451-B948-037694AD75A4" name="GUID-59B45479-273A-4451-B948-037694AD75A4"></a><h6 id="TGDBA-GUID-59B45479-273A-4451-B948-037694AD75A4" class="sect6"><span class="enumeration_section">10.1.2.1.1</span>非Oracle进程</h6>
                        <div>
                           <p>如果程序不是Oracle程序，则确定它们是否合法地需要该数量的CPU。如果是，请确定他们的执行是否延迟到非高峰时段。识别这些CPU密集型进程还可以帮助缩小特定活动（如I / O，网络和分页）消耗资源以及如何与数据库工作负载相关联。</p>
                        </div>
                     </div><a id="TGDBA94440"></a><div class="props_rev_3"><a id="GUID-E646D37F-AD4C-4819-89E6-6915AACC8099" name="GUID-E646D37F-AD4C-4819-89E6-6915AACC8099"></a><h6 id="TGDBA-GUID-E646D37F-AD4C-4819-89E6-6915AACC8099" class="sect6"><span class="enumeration_section">10.1.2.1.2</span> Oracle进程</h6>
                        <div>
                           <p>如果少量Oracle进程占用大部分CPU资源，则使用<code class="codeph">SQL_TRACE</code>和<code class="codeph">TKPROF</code>标识SQL或PL / SQL语句，以查看是否可以调整特定查询或PL / SQL程序单元。例如，如果SELECT语句的执行涉及缓存（逻辑读取）中的许多数据读取，那么它可能是CPU密集型的，这可以通过更好的SQL优化来避免。
                           </p>
                        </div>
                     </div><a id="TGDBA94441"></a><div class="props_rev_3"><a id="GUID-64630CAA-9FF7-4621-9D04-767B45407447" name="GUID-64630CAA-9FF7-4621-9D04-767B45407447"></a><h6 id="TGDBA-GUID-64630CAA-9FF7-4621-9D04-767B45407447" class="sect6"><span class="enumeration_section">10.1.2.1.3</span> Oracle数据库CPU统计信息</h6>
                        <div>
                           <p>Oracle数据库CPU统计信息在几个<code class="codeph">V$</code>视图中可用：</p>
                           <ul style="list-style-type:disc">
                              <li>
                                 <p><code class="codeph">V$SYSSTAT</code>显示所有会话的Oracle数据库CPU使用情况。该<code class="codeph">CPU</code> <code class="codeph">used</code> <code class="codeph">by</code> <code class="codeph">this</code> <code class="codeph">session</code>的统计显示了所有会话使用的总CPU。<code class="codeph">parse</code> <code class="codeph">time</code> <code class="codeph">cpu</code>统计信息显示用于解析的总CPU时间。
                                 </p>
                              </li>
                              <li>
                                 <p><code class="codeph">V$SESSTAT</code>显示每个会话的Oracle数据库CPU使用情况。使用此视图可确定哪个特定会话使用的CPU最多。</p>
                              </li>
                              <li>
                                 <p><code class="codeph">V$RSRC_CONSUMER_GROUP</code>显示Oracle数据库资源时每个使用者组的CPU利用率统计信息<a id="d25676e611" class="indexterm-anchor"></a>经理正在运行。
                                 </p>
                              </li>
                           </ul>
                        </div>
                     </div><a id="TGDBA94442"></a><div class="props_rev_3"><a id="GUID-9CE157DC-EDE2-49F4-961F-3296334FC771" name="GUID-9CE157DC-EDE2-49F4-961F-3296334FC771"></a><h6 id="TGDBA-GUID-9CE157DC-EDE2-49F4-961F-3296334FC771" class="sect6"><span class="enumeration_section">10.1.2.1.4</span>解释CPU统计信息</h6>
                        <div>
                           <p>重要的是要认识到CPU时间和实时是不同的。有8个CPU，实时任何给定的分钟，有8分钟的CPU时间可用。在Windows和UNIX上，这可以是用户时间或系统时间（Windows上的特权模式）。因此，对于每一分钟实时间隔，系统上所有进程（线程）使用的平均CPU时间可能大于一分钟。</p>
                           <p>在任何特定时刻，您都知道Oracle数据库在系统上使用了多长时间。因此，如果八分钟可用且Oracle数据库使用四分钟，那么您就知道Oracle使用了50％的所有CPU时间。如果您的流程没有消耗那个时间，那么其他一些流程就是。确定使用CPU时间的进程，找出原因，然后尝试调整它们。</p>
                           <p>如果CPU使用率均匀分布在许多Oracle服务器进程上，请检查<code class="codeph">V$SYS_TIME_MODEL</code>视图以帮助准确了解花费大部分时间的位置。
                           </p>
                           <div class="infoboxnotealso" id="GUID-9CE157DC-EDE2-49F4-961F-3296334FC771__GUID-D97499BB-DCEB-4AC4-9C07-B1BA78F5AAB3">
                              <p class="notep1">也可以看看：</p>
                              <p><span class="q">“ <a href="instance-tuning-using-performance-views.html#GUID-BB5A0533-F6F2-413C-A56D-A8BDB870536B__G44034" title="此表将等待事件与潜在原因相关联，并概述了下一步可能最有用的Oracle数据。">表10-1</a> ”</span>了解有关各种等待事件及其可能原因的更多信息</p>
                           </div>
                        </div>
                     </div>
                  </div><a id="TGDBA94443"></a><div class="props_rev_3"><a id="GUID-6A042D12-3E50-470C-B41F-D20A67C97B1B" name="GUID-6A042D12-3E50-470C-B41F-D20A67C97B1B"></a><h5 id="TGDBA-GUID-6A042D12-3E50-470C-B41F-D20A67C97B1B" class="sect5"><span class="enumeration_section">10.1.2.2</span>识别I / O问题</h5>
                     <div>
                        <p><a id="d25676e730" class="indexterm-anchor"></a><a id="d25676e734" class="indexterm-anchor"></a><a id="d25676e738" class="indexterm-anchor"></a>磁盘队列长度大于2或磁盘服务时间超过20-30ms就可以证明过度活跃的I / O系统。如果I / O系统过度活动，请检查可能从更多磁盘分配I / O中获益的潜在热点。还要确定是否可以通过使用这些资源降低程序的资源需求来减少负载。如果I / O问题是由Oracle数据库引起的，则可以开始I / O调整。如果Oracle数据库没有消耗可用的I / O资源，那么请确定正在耗尽I / O的进程。确定进程耗尽I / O的原因，然后调整此进程。
                        </p>
                        <p>可以使用Oracle数据库中的<code class="codeph">V$</code>视图和操作系统中的监视工具来识别I / O问题，如以下部分所述：</p>
                        <ul style="list-style-type:disc">
                           <li>
                              <p><a href="instance-tuning-using-performance-views.html#GUID-62BED48B-EE25-4B99-9E5C-F7768281C60A">使用V $视图识别I / O问题</a></p>
                           </li>
                           <li>
                              <p><a href="instance-tuning-using-performance-views.html#GUID-256449BA-E834-4C9C-B8BF-61E858F75219">使用操作系统监视工具识别I / O问题</a></p>
                           </li>
                        </ul>
                     </div><a id="TGDBA94444"></a><div class="props_rev_3"><a id="GUID-62BED48B-EE25-4B99-9E5C-F7768281C60A" name="GUID-62BED48B-EE25-4B99-9E5C-F7768281C60A"></a><h6 id="TGDBA-GUID-62BED48B-EE25-4B99-9E5C-F7768281C60A" class="sect6"><span class="enumeration_section">10.1.2.2.1</span>使用V $视图识别I / O问题</h6>
                        <div>
                           <div class="section">
                              <p>检查<code class="codeph">V$SYSTEM_EVENT</code>的Oracle等待事件数据，以查看顶部等待事件是否与I / O相关。I / O相关事件包括<code class="codeph">db</code> <code class="codeph">file</code> <code class="codeph">sequential</code> <code class="codeph">read</code> ， <code class="codeph">db</code> <code class="codeph">file</code> <code class="codeph">scattered</code> <code class="codeph">read</code> ， <code class="codeph">db</code> <code class="codeph">file</code> <code class="codeph">single</code> <code class="codeph">write</code> ， <code class="codeph">db</code> <code class="codeph">file</code> <code class="codeph">parallel</code> <code class="codeph">write</code>和<code class="codeph">log</code> <code class="codeph">file</code> <code class="codeph">parallel</code> <code class="codeph">write</code> 。这些是与针对数据文件和日志文件执行的I / O相对应的所有事件。如果这些等待事件中的任何一个对应于高平均时间，那么调查一下<a id="d25676e877" class="indexterm-anchor"></a> I / O争用。
                              </p>
                              <p>使用“自动存储库”报告中的I / O部分交叉引用主机I / O系统数据，以识别热数据文件和表空间。还要将操作系统报告的I / O时间与Oracle数据库报告的时间进行比较，以确定它们是否一致。</p>
                              <p>I / O问题也可以通过非I / O相关的等待事件表现出来。例如，在缓冲区高速缓存中找到空闲缓冲区的困难或将日志刷新到磁盘的高等待时间也可能是I / O问题的症状。在调查是否应重新配置I / O系统之前，请确定是否可以减少I / O系统上的负载。</p>
                              <p>要减少Oracle数据库导致的I / O负载，请使用以下视图检查为数据库进行的所有I / O调用收集的I / O统计信息：</p>
                           </div>
                           <!-- class="section" -->
                           <div class="section">
                              <ul style="list-style-type:disc">
                                 <li>
                                    <p><code class="codeph">V $ IOSTAT_CONSUMER_GROUP</code></p>
                                    <p><code class="codeph">V$IOSTAT_CONSUMER_GROUP</code>视图捕获消费者组的I / O统计信息。如果启用了Oracle数据库资源管理器，则会捕获属于当前启用的资源计划的所有使用者组的I / O统计信息。
                                    </p>
                                 </li>
                                 <li>
                                    <p><code class="codeph">V $ IOSTAT_FILE</code></p>
                                    <p><code class="codeph">V$IOSTAT_FILE</code>视图捕获已访问或已访问的数据库文件的I / O统计信息。<code class="codeph">SMALL_SYNC_READ_LATENCY</code>列显示单块同步读取的延迟（以毫秒为单位），这直接转换为客户端在进入下一个操作之前需要等待的时间。这定义了基于当前负载的存储子系统的响应性。如果关键数据文件存在高延迟，您可能需要考虑重新定位这些文件以缩短其服务时间。要计算延迟统计信息，必须将<code class="codeph">timed_statistics</code>设置为<code class="codeph">TRUE</code> 。</p>
                                 </li>
                                 <li>
                                    <p><code class="codeph">V $ IOSTAT_FUNCTION</code></p>
                                    <p><code class="codeph">V$IOSTAT_FUNCTION</code>视图捕获数据库函数（例如LGWR和DBWR）的I / O统计信息。
                                    </p>
                                    <p>I / O可以由具有不同功能的各种Oracle进程发出。顶级数据库函数分类在<code class="codeph">V$IOSTAT_FUNCTION</code>视图中。如果存在I / O功能冲突，则I / O将置于具有较低<code class="codeph">FUNCTION_ID</code>的存储桶中。例如，如果XDB从缓冲区高速缓存发出I / O，则I / O将被归类为XDB I / O，因为它具有较低的<code class="codeph">FUNCTION_ID</code>值。任何未分类的函数都放在Other桶中。您可以通过查询<code class="codeph">V$IOSTAT_FUNCTION</code>视图来显示<code class="codeph">FUNCTION_ID</code>层次结构：</p><pre class="oac_no_warn" dir="ltr">通过FUNCTION_ID从v $ iostat_function顺序中选择FUNCTION_ID，FUNCTION_NAME; FUNCTION_ID FUNCTION_NAME ----------- ------------------ 0 RMAN 1 DBWR 2 LGWR 3 ARCH 4 XDB 5 Streams AQ 6数据泵7恢复8缓冲区高速缓存读取9直接读取10直接写入11其他</pre></li>
                              </ul>
                              <p>这些<code class="codeph">V$IOSTAT</code>视图包含单块和多块读写操作的I / O统计信息。单块操作是小于或等于128千字节的小I / O.多块操作是大于128千字节的大I / O.对于每个操作，都会收集以下统计信息：</p>
                              <ul style="list-style-type:disc">
                                 <li>
                                    <p>识别码</p>
                                 </li>
                                 <li>
                                    <p>总等待时间（以毫秒为单位）</p>
                                 </li>
                                 <li>
                                    <p>执行的等待数（对于消费者组和功能）</p>
                                 </li>
                                 <li>
                                    <p>每个操作的请求数</p>
                                 </li>
                                 <li>
                                    <p>读取的单个和多个块字节数</p>
                                 </li>
                                 <li>
                                    <p>写入的单个和多个块字节的数量</p>
                                 </li>
                              </ul>
                              <p>您还应该查看通过查询<code class="codeph">V$SQLAREA</code>视图执行许多物理读取的SQL语句，或查看“自动工作负载存储库”报告中的“按读取顺序排列的SQL”部分。检查这些语句，看看如何调整它们以减少I / O数量。
                              </p>
                              <div class="infoboxnotealso" id="GUID-62BED48B-EE25-4B99-9E5C-F7768281C60A__GUID-D8926588-334E-4DA9-81D4-A75C6B90808D">
                                 <p class="notep1">也可以看看：</p>
                                 <p><a href="../refrn/index.html" target="_blank"><span class="italic">Oracle数据库参考</span></a>有关视图的更多信息<code class="codeph">V$IOSTAT_CONSUMER_GROUP</code> ， <code class="codeph">V$IOSTAT_FUNCTION</code> ， <code class="codeph">V$IOSTAT_FILE</code>和<code class="codeph">V$SQLAREA</code></p>
                              </div>
                           </div>
                           <!-- class="section" -->
                        </div>
                     </div><a id="TGDBA94445"></a><div class="props_rev_3"><a id="GUID-256449BA-E834-4C9C-B8BF-61E858F75219" name="GUID-256449BA-E834-4C9C-B8BF-61E858F75219"></a><h6 id="TGDBA-GUID-256449BA-E834-4C9C-B8BF-61E858F75219" class="sect6"><span class="enumeration_section">10.1.2.2.2</span>使用操作系统监视工具识别I / O问题</h6>
                        <div>
                           <div class="section">
                              <p>使用操作系统监视工具确定整个系统上正在运行的进程，并监视对所有文件的磁盘访问。请记住，保存数据文件和重做日志文件的磁盘也可以保存与Oracle数据库无关的文件。减少对包含数据库文件的磁盘的任何繁重访问。您只能通过操作系统工具监视对非数据库文件的访问，而不是通过<code class="codeph">V$</code>视图。
                              </p>
                              <p>许多UNIX系统上的实用程序（如<code class="codeph">sar</code> <code class="codeph">-d</code> （或<code class="codeph">iostat</code> ）和Windows系统上的管理性能监视工具）都会检查整个系统的I / O统计信息。
                              </p>
                              <div class="infoboxnotealso" id="GUID-256449BA-E834-4C9C-B8BF-61E858F75219__GUID-FF3E1157-A6BD-4E49-BEA5-FAD47C2566BC">
                                 <p class="notep1">也可以看看：</p>
                                 <p>有关平台上可用工具的操作系统文档</p>
                              </div>
                           </div>
                           <!-- class="section" -->
                        </div>
                     </div>
                  </div><a id="TGDBA94446"></a><div class="props_rev_3"><a id="GUID-ED2F69C0-1197-4639-BEFF-6DB0BDBAB683" name="GUID-ED2F69C0-1197-4639-BEFF-6DB0BDBAB683"></a><h5 id="TGDBA-GUID-ED2F69C0-1197-4639-BEFF-6DB0BDBAB683" class="sect5"><span class="enumeration_section">10.1.2.3</span>识别网络问题</h5>
                     <div>
                        <div class="section">
                           <p>使用操作系统实用程序，查看网络往返ping时间和冲突数。如果网络导致响应时间大幅延迟，则调查可能的原因。</p>
                           <p>要识别由远程访问数据库文件导致的网络I / O，请检查<code class="codeph">V$IOSTAT_NETWORK</code>视图。此视图包含由访问远程数据库实例上的文件导致的网络I / O统计信息，包括：</p>
                        </div>
                        <!-- class="section" -->
                        <div class="section">
                           <ul style="list-style-type:disc">
                              <li>
                                 <p>启动网络I / O的数据库客户端（例如RMAN和PLSQL）</p>
                              </li>
                              <li>
                                 <p>发出的读写操作数</p>
                              </li>
                              <li>
                                 <p>读取和写入的千字节数</p>
                              </li>
                              <li>
                                 <p>读取操作的总等待时间（以毫秒为单位）</p>
                              </li>
                              <li>
                                 <p>写入操作的总等待时间（以毫秒为单位）</p>
                              </li>
                           </ul>
                           <p>识别出网络问题的原因后，可以通过将大量数据传输安排到非高峰时间，或者通过将应用程序编码为对远程主机的批量请求来减少网络负载，而不是一次（或多次）访问一个请求的远程主机。</p>
                        </div>
                        <!-- class="section" -->
                     </div>
                  </div>
               </div><a id="TGDBA94447"></a><div class="props_rev_3"><a id="GUID-C0DE00D7-C69F-4938-9FE3-78A070524817" name="GUID-C0DE00D7-C69F-4938-9FE3-78A070524817"></a><h4 id="TGDBA-GUID-C0DE00D7-C69F-4938-9FE3-78A070524817" class="sect4"><span class="enumeration_section">10.1.3</span>检查Oracle数据库统计信息</h4>
                  <div>
                     <p>检查Oracle数据库统计信息并将其与操作系统统计信息交叉引用，以确保对问题进行一致的诊断。操作系统统计信息可以指示开始调整的好地方。但是，如果目标是调整Oracle数据库实例，那么在实施更正操作之前，请查看Oracle数据库统计信息以从数据库角度确定资源瓶颈。</p>
                     <p>本节包含以下主题。</p>
                     <ul style="list-style-type:disc">
                        <li>
                           <p><a href="instance-tuning-using-performance-views.html#GUID-2CC2320F-4CAA-4ECD-82C4-0A5FC4C9EF64">设置统计信息收集级别</a></p>
                        </li>
                        <li>
                           <p><a href="instance-tuning-using-performance-views.html#GUID-83A6CEC9-B4B5-4335-ACAF-D39C8649664B">等待事件</a></p>
                        </li>
                        <li>
                           <p><a href="instance-tuning-using-performance-views.html#GUID-C04DE613-6AF1-4A92-8E54-134F5E0BA904">包含等待事件统计信息的动态性能视图</a></p>
                        </li>
                        <li>
                           <p><a href="instance-tuning-using-performance-views.html#GUID-259D65EE-5F1B-4C2A-83BE-A6D03B232CDB">系统统计</a></p>
                        </li>
                        <li>
                           <p><a href="instance-tuning-using-performance-views.html#GUID-6FC05277-C094-4DEE-8D0E-FA91D9DE1E23">细分级统计</a></p>
                        </li>
                     </ul>
                     <div class="infoboxnotealso" id="GUID-C0DE00D7-C69F-4938-9FE3-78A070524817__GUID-FB225088-C797-496D-A172-126EBC7B2C0F">
                        <p class="notep1">也可以看看：</p>
                        <p><span class="q">“ <a href="instance-tuning-using-performance-views.html#GUID-1335E243-77FE-4411-92CB-74F93DD23609">解释Oracle数据库统计信息</a> ”</span></p>
                     </div>
                  </div><a id="TGDBA94448"></a><div class="props_rev_3"><a id="GUID-2CC2320F-4CAA-4ECD-82C4-0A5FC4C9EF64" name="GUID-2CC2320F-4CAA-4ECD-82C4-0A5FC4C9EF64"></a><h5 id="TGDBA-GUID-2CC2320F-4CAA-4ECD-82C4-0A5FC4C9EF64" class="sect5"><span class="enumeration_section">10.1.3.1</span>设置统计信息收集级别</h5>
                     <div>
                        <div class="section">
                           <p>Oracle数据库提供初始化参数<code class="codeph">STATISTICS_LEVEL</code> ，它控制数据库中的所有主要统计信息收集或建议。此参数设置数据库的统计信息收集级别。
                           </p>
                           <p>根据<code class="codeph">STATISTICS_LEVEL</code>的设置，收集某些建议或统计数据，如下所示：</p>
                        </div>
                        <!-- class="section" -->
                        <div class="section">
                           <ul style="list-style-type:disc">
                              <li>
                                 <p><code class="codeph">BASIC</code> ：不收集任何建议或统计数据。监控和许多自动功能被禁用。Oracle不建议使用此设置，因为它会禁用重要的Oracle数据库功能。
                                 </p>
                              </li>
                              <li>
                                 <p><code class="codeph">TYPICAL</code> ：这是默认值，可确保收集所有主要统计信息，同时提供最佳的整体数据库性能。此设置应适用于大多数环境。
                                 </p>
                              </li>
                              <li>
                                 <p><code class="codeph">ALL</code> ：包括使用<code class="codeph">TYPICAL</code>设置收集的所有建议或统计信息，以及定时操作系统统计信息和行源执行统计信息。
                                 </p>
                              </li>
                           </ul>
                           <div class="infoboxnotealso" id="GUID-2CC2320F-4CAA-4ECD-82C4-0A5FC4C9EF64__GUID-7F6CA743-3370-4930-BAD9-33B7242E2B57">
                              <p class="notep1">也可以看看：</p>
                              <ul style="list-style-type:disc">
                                 <li>有关<code class="codeph">STATISTICS_LEVEL</code>初始化参数的更多信息，请<a href="../refrn/STATISTICS_LEVEL.html#REFRN10214" target="_blank"><span class="italic">参见Oracle数据库参考</span></a> 。
                                 </li>
                                 <li>
                                    <p>有关<code class="codeph">V$STATISTICS_LEVEL</code>视图的信息，请<a href="../refrn/V-STATISTICS_LEVEL.html#REFRN30264" target="_blank"><span class="italic">参见Oracle数据库参考</span></a> 。此视图列出了<code class="codeph">STATISTICS_LEVEL</code>初始化参数控制的统计信息或建议的状态。
                                    </p>
                                 </li>
                              </ul>
                           </div>
                        </div>
                        <!-- class="section" -->
                     </div>
                  </div><a id="TGDBA94450"></a><div class="props_rev_3"><a id="GUID-83A6CEC9-B4B5-4335-ACAF-D39C8649664B" name="GUID-83A6CEC9-B4B5-4335-ACAF-D39C8649664B"></a><h5 id="TGDBA-GUID-83A6CEC9-B4B5-4335-ACAF-D39C8649664B" class="sect5"><span class="enumeration_section">10.1.3.2</span>等待事件</h5>
                     <div>
                        <p>等待事件是由服务器进程或线程递增的统计信息，表示必须等待事件完成才能继续处理。等待事件数据显示可能影响性能的各种问题症状，例如闩锁争用，缓冲区争用和<a id="d25676e1373" class="indexterm-anchor"></a> I / O争用。请记住，这些只是问题的症状，而不是实际原因。
                        </p>
                        <p>等待事件被分组到类中。等待事件<a id="d25676e1380" class="indexterm-anchor"></a><a id="d25676e1384" class="indexterm-anchor"></a>类包括：管理，应用程序，集群，提交，并发，配置，空闲，网络，其他，调度程序，系统I / O和用户I / O.</p>
                        <p>服务器进程可以等待以下内容：</p>
                        <ul style="list-style-type:disc">
                           <li>
                              <p>要变为可用的资源，例如缓冲区或锁存器。</p>
                           </li>
                           <li>
                              <p>要完成的操作，例如I / O.</p>
                           </li>
                           <li>
                              <p>还有更多工作要做，比如等待客户端提供下一个要执行的SQL语句。标识服务器进程正在等待更多工作的事件称为空闲事件。</p>
                           </li>
                        </ul>
                        <p>等待事件统计信息包括等待事件的次数以及等待事件完成的时间。如果初始化参数<code class="codeph">TIMED_STATISTICS</code>设置为<code class="codeph">true</code> ，那么您还可以查看每个资源等待的时间。
                        </p>
                        <p>要最大限度地缩短用户响应时间，请减少服务器进程等待事件完成所花费的时间。并非所有等待事件都具有相同的等待时间。因此，更重要的是检查等待总时间最多的事件，而不是等待具有大量事件的事件。通常，最好在监视性能时将动态参数<code class="codeph">TIMED_STATISTICS</code>设置为<code class="codeph">true</code> 。
                        </p>
                        <div class="infoboxnotealso" id="GUID-83A6CEC9-B4B5-4335-ACAF-D39C8649664B__GUID-BF0DCF9B-1F6A-4080-9581-CCDDEA04931D">
                           <p class="notep1">也可以看看：</p>
                           <ul style="list-style-type:disc">
                              <li>
                                 <p><span class="q">“ <a href="instance-tuning-using-performance-views.html#GUID-386931AB-A199-41E8-A20C-7317A4FDCACC">等待事件统计</a> ”</span></p>
                              </li>
                              <li>
                                 <p><span class="q">“ <a href="measuring-database-performance.html#GUID-1BA8F07A-1860-476C-8ABF-4C7D04BA8CD0">使用具有定时统计信息的等待事件</a> ”</span></p>
                              </li>
                              <li>
                                 <p>有关Oracle数据库等待事件的更多信息，请<a href="../refrn/oracle-wait-events.html#REFRN101" target="_blank"><span class="italic">参见Oracle数据库参</span></a></p>
                              </li>
                           </ul>
                        </div>
                     </div>
                  </div><a id="TGDBA94451"></a><div class="props_rev_3"><a id="GUID-C04DE613-6AF1-4A92-8E54-134F5E0BA904" name="GUID-C04DE613-6AF1-4A92-8E54-134F5E0BA904"></a><h5 id="TGDBA-GUID-C04DE613-6AF1-4A92-8E54-134F5E0BA904" class="sect5"><span class="enumeration_section">10.1.3.3</span>包含等待事件统计信息的动态性能视图</h5>
                     <div>
                        <div class="section">
                           <p>可以查询这些动态性能视图的等待事件统计信息：</p>
                           <ul style="list-style-type:disc">
                              <li>
                                 <p><a id="d25676e1492" class="indexterm-anchor"></a><code class="codeph">V$ACTIVE_SESSION_HISTORY</code> 
                                 </p>
                                 <p><code class="codeph">V$ACTIVE_SESSION_HISTORY</code>视图显示活动数据库会话活动，每秒采样一次。
                                 </p>
                              </li>
                              <li>
                                 <p><code class="codeph">V$SESS_TIME_MODEL</code>和<code class="codeph">V$SYS_TIME_MODEL</code> 
                                 </p>
                                 <p><code class="codeph">V$SESS_TIME_MODEL</code>和<code class="codeph">V$SYS_TIME_MODEL</code>视图包含时间模型统计信息，包括<code class="codeph">DB</code> <code class="codeph">time</code> ，即数据库调用所花费的总时间。
                                 </p>
                              </li>
                              <li>
                                 <p><a id="d25676e1526" class="indexterm-anchor"></a><code class="codeph">V$SESSION_WAIT </code></p>
                                 <p><code class="codeph">V$SESSION_WAIT</code>视图显示有关每个会话的当前或最后等待的信息（例如等待ID，类和时间）。
                                 </p>
                              </li>
                              <li>
                                 <p><a id="d25676e1537" class="indexterm-anchor"></a><code class="codeph">V$SESSION</code> 
                                 </p>
                                 <p><code class="codeph">V$SESSION</code>视图显示有关每个当前会话的信息，并包含与<code class="codeph">V$SESSION_WAIT</code>视图中相同的等待统计信息。如果适用，此视图还包含有关会话当前正在等待的对象的详细信息（例如对象编号，块编号，文件编号和行编号），阻塞会话负责当前等待（例如阻塞会话） ID，状态和类型）以及等待的时间量。
                                 </p>
                              </li>
                              <li>
                                 <p><a id="d25676e1552" class="indexterm-anchor"></a><code class="codeph">V$SESSION_EVENT </code></p>
                                 <p><code class="codeph">V$SESSION_EVENT</code>视图提供会话自启动以来等待的所有事件的摘要。
                                 </p>
                              </li>
                              <li>
                                 <p><a id="d25676e1563" class="indexterm-anchor"></a><code class="codeph">V$SESSION_WAIT_CLASS </code></p>
                                 <p><code class="codeph">V$SESSION_WAIT_CLASS</code>视图提供每个会话的等待次数和每类等待事件所花费的时间。
                                 </p>
                              </li>
                              <li>
                                 <p><a id="d25676e1574" class="indexterm-anchor"></a><code class="codeph">V$SESSION_WAIT_HISTORY </code></p>
                                 <p>该<a id="d25676e1580" class="indexterm-anchor"></a> <code class="codeph">V$SESSION_WAIT_HISTORY</code>视图显示有关每个活动会话的最后十个等待事件的信息（例如事件类型和等待时间）。
                                 </p>
                              </li>
                              <li>
                                 <p><a id="d25676e1587" class="indexterm-anchor"></a><code class="codeph">V$SYSTEM_EVENT </code></p>
                                 <p><code class="codeph">V$SYSTEM_EVENT</code>视图提供了自启动以来实例上所有事件等待的摘要。
                                 </p>
                              </li>
                              <li>
                                 <p><a id="d25676e1598" class="indexterm-anchor"></a><code class="codeph">V$EVENT_HISTOGRAM </code></p>
                                 <p><code class="codeph">V$EVENT_HISTOGRAM</code>视图显示基于事件的等待次数，最长等待时间和总等待时间的直方图。
                                 </p>
                              </li>
                              <li>
                                 <p><a id="d25676e1609" class="indexterm-anchor"></a><code class="codeph">V$FILE_HISTOGRAM </code></p>
                                 <p><code class="codeph">V$FILE_HISTOGRAM</code>视图显示在每个文件的单个块读取期间等待的时间的直方图。
                                 </p>
                              </li>
                              <li>
                                 <p><a id="d25676e1620" class="indexterm-anchor"></a><code class="codeph">V$SYSTEM_WAIT_CLASS </code></p>
                                 <p><code class="codeph">V$SYSTEM_WAIT_CLASS</code>视图提供等待数量和每类等待事件所花费时间的实例范围总时间。
                                 </p>
                              </li>
                              <li>
                                 <p><a id="d25676e1632" class="indexterm-anchor"></a><code class="codeph">V$TEMP_HISTOGRAM</code> 
                                 </p>
                                 <p><code class="codeph">V$TEMP_HISTOGRAM</code>视图显示在每个临时文件的单个块读取期间等待的时间的直方图。
                                 </p>
                              </li>
                           </ul>
                           <p>在执行无功性能调整时调查等待事件和相关的时序数据。列出最多时间的事件往往是性能瓶颈的强烈迹象。例如，通过查看<code class="codeph">V$SYSTEM_EVENT</code> ，您可能会注意到许多<code class="codeph">buffer</code> <code class="codeph">busy</code> <code class="codeph">waits</code> 。可能是许多进程插入到同一个块中，并且必须在插入之前等待彼此。解决方案可以是对所讨论的对象使用自动段空间管理或分区。
                           </p>
                           <div class="infoboxnotealso" id="GUID-C04DE613-6AF1-4A92-8E54-134F5E0BA904__GUID-E6845C98-4DF4-4EFA-8649-72E8B7627878">
                              <p class="notep1">也可以看看：</p>
                              <ul style="list-style-type:disc">
                                 <li>
                                    <p><span class="q">“ <a href="instance-tuning-using-performance-views.html#GUID-386931AB-A199-41E8-A20C-7317A4FDCACC">等待事件统计</a> ”</span>用于视图之间的差异<code class="codeph">V$SESSION_WAIT</code> ， <code class="codeph">V$SESSION_EVENT</code>和<code class="codeph">V$SYSTEM_EVENT</code></p>
                                 </li>
                                 <li>
                                    <p> 有关动态性能视图的信息，请参阅<a href="../refrn/dynamic-performance-views.html#REFRN003" target="_blank"><span class="italic">Oracle数据库参考</span></a></p>
                                 </li>
                              </ul>
                           </div>
                        </div>
                        <!-- class="section" -->
                     </div>
                  </div><a id="TGDBA94452"></a><div class="props_rev_3"><a id="GUID-259D65EE-5F1B-4C2A-83BE-A6D03B232CDB" name="GUID-259D65EE-5F1B-4C2A-83BE-A6D03B232CDB"></a><h5 id="TGDBA-GUID-259D65EE-5F1B-4C2A-83BE-A6D03B232CDB" class="sect5"><span class="enumeration_section">10.1.3.4</span>系统统计</h5>
                     <div>
                        <p>系统统计信息通常与等待事件数据结合使用，以查找性能问题原因的进一步证据。</p>
                        <p>例如，如果<code class="codeph">V$SYSTEM_EVENT</code>指示最大等待事件（就等待时间而言）是事件<code class="codeph">buffer</code> <code class="codeph">busy</code> <code class="codeph">waits</code> ，则查看视图中可用的特定缓冲区等待统计信息<a id="d25676e1746" class="indexterm-anchor"></a> <code class="codeph">V$WAITSTAT</code>查看哪种块类型具有最高等待次数和最长等待时间。
                        </p>
                        <p>在识别出块类型之后，还要看一下<a id="d25676e1753" class="indexterm-anchor"></a> <code class="codeph">V$SESSION</code>在问题发生时实时或<code class="codeph">V$ACTIVE_SESSION_HISTORY</code>和<code class="codeph">DBA_HIST_ACTIVE_SESS_HISTORY</code>视图在遇到问题后使用指示的对象编号识别竞争对象。这些数据的组合表明了适当的纠正措施。
                        </p>
                        <p>许多<code class="codeph">V$</code>视图中都提供了统计信息。以下是一些包含系统统计信息的<code class="codeph">V$</code>视图。
                        </p>
                        <div class="section">
                           <p class="subhead3" id="GUID-259D65EE-5F1B-4C2A-83BE-A6D03B232CDB__GUID-6C0179D4-CF10-4CB7-ADCC-2926095E96D4">V $ ACTIVE_SESSION_HISTORY</p>
                           <p>此视图显示活动数据库会话活动，每秒采样一次。</p>
                        </div>
                        <!-- class="section" -->
                        <div class="section">
                           <p class="subhead3" id="GUID-259D65EE-5F1B-4C2A-83BE-A6D03B232CDB__GUID-0002AAED-3F85-4855-A69D-4DD9181792CB">V $ SYSSTAT</p>
                           <p>它包含Oracle数据库许多不同部分的总体统计信息，包括回滚，逻辑和物理I / O以及解析数据。来自<code class="codeph">V$SYSSTAT</code>数据用于计算比率，例如缓冲区高速缓存命中率。
                           </p>
                        </div>
                        <!-- class="section" -->
                        <div class="section">
                           <p class="subhead3" id="GUID-259D65EE-5F1B-4C2A-83BE-A6D03B232CDB__GUID-D3AD5CDC-6CB1-4C7A-B244-AF6F08DAC5C9">V $ FILESTAT</p>
                           <p>其中包含每个文件的详细文件I / O统计信息，包括每个文件的I / O数和平均读取时间。</p>
                        </div>
                        <!-- class="section" -->
                        <div class="section">
                           <p class="subhead3" id="GUID-259D65EE-5F1B-4C2A-83BE-A6D03B232CDB__GUID-C1B58AC6-58FC-4C53-B718-699A98DD00C5">V $ ROLLSTAT</p>
                           <p>其中包含每个段的详细回滚和还原段统计信息。</p>
                        </div>
                        <!-- class="section" -->
                        <div class="section">
                           <p class="subhead3" id="GUID-259D65EE-5F1B-4C2A-83BE-A6D03B232CDB__GUID-3D32A808-3498-431C-B3D2-6D579B2A8ADC">V $ ENQUEUE_STAT</p>
                           <p>这包含详细<a id="d25676e1800" class="indexterm-anchor"></a>每个队列的队列统计数据，包括请求队列的次数，队列等待的次数以及等待时间。
                           </p>
                        </div>
                        <!-- class="section" -->
                        <div class="section">
                           <p class="subhead3" id="GUID-259D65EE-5F1B-4C2A-83BE-A6D03B232CDB__GUID-E730F919-8883-40BF-B373-09C8C84B7C24">V $ LATCH</p>
                           <p>这包含每个锁存器的详细锁存器使用情况统计信息，包括每个锁存器被请求的次数以及锁存器等待的次数。</p>
                           <div class="infoboxnotealso" id="GUID-259D65EE-5F1B-4C2A-83BE-A6D03B232CDB__GUID-A36FE694-79C7-4B9C-8832-2F3FF5B8F2A6">
                              <p class="notep1">也可以看看：</p>
                              <p>有关动态性能视图的信息，请参阅<a href="../refrn/dynamic-performance-views.html#REFRN003" target="_blank"><span class="italic">Oracle Database Reference</span></a></p>
                           </div>
                        </div>
                        <!-- class="section" -->
                     </div>
                  </div><a id="TGDBA94459"></a><div class="props_rev_3"><a id="GUID-6FC05277-C094-4DEE-8D0E-FA91D9DE1E23" name="GUID-6FC05277-C094-4DEE-8D0E-FA91D9DE1E23"></a><h5 id="TGDBA-GUID-6FC05277-C094-4DEE-8D0E-FA91D9DE1E23" class="sect5"><span class="enumeration_section">10.1.3.5</span>段级统计</h5>
                     <div>
                        <p>您可以收集细分级别统计信息，以帮助您发现与各个细分受众群相关的性能问题。收集和查看段级统计信息是有效识别实例中的热表或索引的好方法。</p>
                        <p>查看等待事件和系统统计信息以识别性能问题后，可以使用段级统计信息查找导致问题的特定表或索引。例如，考虑<code class="codeph">V$SYSTEM_EVENT</code>指示缓冲区忙等待导致相当长的等待时间。您可以从<code class="codeph">V$SEGMENT_STATISTICS</code>选择导致缓冲区忙等待的顶部段。然后，您可以集中精力消除这些细分中的问题。
                        </p>
                        <p>您可以通过以下动态性能视图查询段级统计信息：</p>
                        <ul style="list-style-type:disc">
                           <li>
                              <p><code class="codeph">V$SEGSTAT_NAME:</code>此视图列出了正在收集的细分统计信息以及每个统计信息的属性（例如，如果它是采样统计信息）。
                              </p>
                           </li>
                           <li>
                              <p><code class="codeph">V$SEGSTAT:</code>这是一个高效的实时监控视图，显示统计值，统计名称和其他基本信息。
                              </p>
                           </li>
                           <li>
                              <p><code class="codeph">V$SEGMENT_STATISTICS:</code>这是一个用户友好的统计值视图。除了<code class="codeph">V$SEGSTAT</code>所有列<code class="codeph">V$SEGSTAT</code> ，它还包含有关段所有者和表空间名称等信息。它使统计数据易于理解，但成本更高。
                              </p>
                              <div class="infoboxnotealso" id="GUID-6FC05277-C094-4DEE-8D0E-FA91D9DE1E23__GUID-4C748205-9996-430A-9774-055F70D20FB4">
                                 <p class="notep1">也可以看看：</p>
                                 <p> 有关动态性能视图的信息，请参阅<a href="../refrn/dynamic-performance-views.html#REFRN003" target="_blank"><span class="italic">Oracle Database Reference</span></a></p>
                              </div>
                           </li>
                        </ul>
                     </div>
                  </div>
               </div><a id="TGDBA94460"></a><div class="props_rev_3"><a id="GUID-AA7607E6-8A86-4A54-88B7-161CA970D052" name="GUID-AA7607E6-8A86-4A54-88B7-161CA970D052"></a><h4 id="TGDBA-GUID-AA7607E6-8A86-4A54-88B7-161CA970D052" class="sect4"><span class="enumeration_section">10.1.4</span>实施和衡量变化</h4>
                  <div>
                     <p>通常在调整练习结束时，可以识别可能有可能缓解问题的两个或三个更改。要确定哪个更改提供了最大的好处，建议一次只实施一个更改。应根据问题定义阶段中的基线数据测量来衡量变化的影响。</p>
                     <p>通常，大多数具有严重性能问题的站点会同时实现多个重叠更改，因此无法确定哪些更改提供了任何好处。虽然这不是一个问题，但如果随后出现类似问题，这将成为一个重大障碍，因为不可能知道哪些变化提供了最大的好处，哪些努力是优先考虑的。</p>
                     <p>如果无法单独实施更改，请尝试测量不同更改的效果。例如，测量进行初始化更改以优化重做生成的效果，与创建新索引以提高已修改查询的性能的效果分开。如果调整SQL，更改操作系统磁盘布局，并且同时更改初始化参数，则无法测量执行操作系统升级的好处。</p>
                     <p>性能调优是一个迭代过程。它不太可能找到解决整个实例性能问题的“银弹”。在大多数情况下，优秀的性能需要在性能调优阶段进行迭代，因为解决一个瓶颈通常会发现另一个（有时更糟）的问题。</p>
                     <p>知道何时停止调整也很重要。衡量绩效的最佳方法是用户感知，而不是统计数据与理想值的接近程度。</p>
                  </div>
               </div>
            </div><a id="TGDBA02405"></a><div class="props_rev_3"><a id="GUID-1335E243-77FE-4411-92CB-74F93DD23609" name="GUID-1335E243-77FE-4411-92CB-74F93DD23609"></a><h3 id="TGDBA-GUID-1335E243-77FE-4411-92CB-74F93DD23609" class="sect3"><span class="enumeration_section">10.2</span>解释Oracle数据库统计信息</h3>
               <div>
                  <p>收集涵盖实例出现性能问题的时间的统计信息。如果您之前捕获了基线数据以进行比较，那么您可以将当前数据与基线中最能代表问题工作负载的数据进行比较。</p>
                  <p>比较两个报告时，请确保两个报告来自系统运行类似工作负载的时间。</p>
               </div><a id="TGDBA94461"></a><div class="props_rev_3"><a id="GUID-8428E4EC-A0F7-4BFA-AC3D-67F4E508A486" name="GUID-8428E4EC-A0F7-4BFA-AC3D-67F4E508A486"></a><h4 id="TGDBA-GUID-8428E4EC-A0F7-4BFA-AC3D-67F4E508A486" class="sect4"><span class="enumeration_section">10.2.1</span>检查负载</h4>
                  <div>
                     <p>通常，等待事件是第一个检查的数据。但是，如果您有基线报告，请检查负载是否已更改。无论您是否有基线，查看资源使用率是否高都很有用。</p>
                     <p>要检查的与负载相关的统计信息包括<code class="codeph">redo</code> <code class="codeph">size</code> ， <code class="codeph">session</code> <code class="codeph">logical</code> <code class="codeph">reads</code> ， <code class="codeph">db</code> <code class="codeph">block</code> <code class="codeph">changes</code> ， <code class="codeph">physical</code> <code class="codeph">reads</code> ， <code class="codeph">physical read total bytes, physical</code> <code class="codeph">writes</code> ， <code class="codeph">physical write total bytes, parse</code> <code class="codeph">count</code> （ <code class="codeph">total</code> ）， <code class="codeph">parse</code> <code class="codeph">count</code> （ <code class="codeph">hard</code> ）和<code class="codeph">user</code> <code class="codeph">calls</code> 。从<code class="codeph">V$SYSSTAT</code>查询此数据。最好在几秒钟内和事务上规范化这些数据。通过使用物理读取总字节数和物理写入总字节数之和来检查每秒MB的总I / O负载也很有用。组合值包括用于缓冲缓存，重做日志，存档日志，恢复管理器（RMAN）备份和恢复以及任何Oracle数据库后台进程的I / O.
                     </p>
                     <p>在AWR报告中，查看“加载配置文件”部分。数据已经在事务和数秒内进行了规范化。</p>
                     <div class="section">
                        <p class="subhead3" id="GUID-8428E4EC-A0F7-4BFA-AC3D-67F4E508A486__GUID-B9F66F23-E519-4B0D-BC85-4329ACBA881F">改变负荷</p>
                        <p>几秒钟内的负载配置文件统计信息显示吞吐量的变化（即，实例是否每秒执行更多工作）。事务统计信息通过将这些更改与基线报告中的相应统计信息进行比较来识别应用程序特征的变化。</p>
                     </div>
                     <!-- class="section" -->
                     <div class="section">
                        <p class="subhead3" id="GUID-8428E4EC-A0F7-4BFA-AC3D-67F4E508A486__GUID-9F53D91F-0735-4AB3-9053-5F6E89278EFB">高活动率</p>
                        <p>检查在几秒钟内标准化的统计数据，以确定活动率是否非常高。很难对高值进行全面建议，因为每个站点的阈值都不同，并且取决于应用程序特性，CPU的数量和速度，操作系统，I / O系统和Oracle数据库版本。</p>
                        <p>以下是一些通用示例（每个站点的可接受值有所不同）：</p>
                        <ul style="list-style-type:disc">
                           <li>
                              <p>硬分析率超过100秒表示系统上存在大量的硬解析。高硬解析率会导致严重的性能问题，必须进行调查。通常，伴随着高硬解析率<a id="d25676e2162" class="indexterm-anchor"></a><a id="d25676e2166" class="indexterm-anchor"></a> latch共享池和库高速缓存锁存器上的争用。
                              </p>
                           </li>
                           <li>
                              <p>检查库高速缓存和共享池锁存事件的等待时间总和（锁存器：库高速缓存，锁存器：库高速缓存管脚，锁存器：库高速缓存锁定和锁存器：共享池）与在<code class="codeph">V$SYSSTAT</code>找到的统计<code class="codeph">DB</code> <code class="codeph">time</code>相比是否显着<code class="codeph">V$SYSSTAT</code> 。如果是这样，检查<code class="codeph">SQL</code> <code class="codeph">ordered</code> <code class="codeph">by</code> <code class="codeph">Parse</code> <code class="codeph">Calls</code>的AWR报告的部分。
                              </p>
                           </li>
                           <li>
                              <p>高软解析率可以是300秒或更高的速率。不必要的软解析也限制了应用程序的可伸缩性。最理想的是，SQL语句应该在每个会话中进行一次软解析并执行多次。</p>
                           </li>
                        </ul>
                     </div>
                     <!-- class="section" -->
                  </div>
               </div><a id="TGDBA94464"></a><div class="props_rev_3"><a id="GUID-03F070F3-81DF-4649-820C-DAD28AEF0871" name="GUID-03F070F3-81DF-4649-820C-DAD28AEF0871"></a><h4 id="TGDBA-GUID-03F070F3-81DF-4649-820C-DAD28AEF0871" class="sect4"><span class="enumeration_section">10.2.2</span>使用等待事件统计信息深入到瓶颈</h4>
                  <div>
                     <div class="section">
                        <p>每当Oracle进程等待某事时，它就会使用一组预定义的等待事件之一来记录等待。这些等待事件分组在等待类中。Idle等待类将进程等待的所有事件分组，当它没有工作要做并等待执行更多工作时。非空闲事件表示等待资源或操作完成所花费的非生产时间。</p>
                        <div class="infoboxnote" id="GUID-03F070F3-81DF-4649-820C-DAD28AEF0871__GUID-0A48D124-CAEA-407E-96CD-1AC9587492BD">
                           <p class="notep1">注意：</p>
                           <p>并非所有症状都可以通过等待事件来证明。有关可以检查的统计信息，请参阅<span class="q">“ <a href="instance-tuning-using-performance-views.html#GUID-07836086-3C62-4A4A-8392-25A8C34C4A66">其他统计信息</a> ”</span> 。
                           </p>
                        </div>
                        <p>使用等待事件数据的最有效方法是按等待时间对事件进行排序。仅当<code class="codeph">TIMED_STATISTICS</code>设置为<code class="codeph">true</code>时才可以执行此操作。否则，等待事件只能按等待的次数排序，这通常不是最能代表问题的排序。
                        </p>
                        <p>要获得时间花费的指示，请按照下列步骤操作：</p>
                     </div>
                     <!-- class="section" -->
                     <div class="section">
                        <ol>
                           <li>
                              <p>检查<code class="codeph">V$SYSTEM_EVENT</code>的数据收集。感兴趣的事件应按等待时间排序。
                              </p>
                              <p>确定具有最大等待时间百分比的等待事件。要确定等待时间的百分比，请添加所有等待事件的总等待时间，不包括空闲事件，例如<code class="codeph">Null event</code> ， <code class="codeph">SQL*Net message from client</code> <code class="codeph">SQL*Net message to client</code> <code class="codeph">SQL*Net more data to client</code> 。通过将每个事件的等待时间除以等待所有事件的总时间来计算五个最突出事件的相对百分比。
                              </p>
                              <p>或者，查看自动工作负载存储库报告开头的前5个定时事件部分。此部分自动对等待事件（省略空闲事件）进行排序，并计算相对百分比：</p><pre class="oac_no_warn" dir="ltr">前5个定时活动~~~~~~~~~~~~~~~~~~％总事件等待时间通话时间------------------ -------------------- ------------ ----------- ------- -  CPU时间559 88.80日志文件并行写入2,181 28 4.42 SQL * Net来自客户端的更多数据516,611 27 4.24 db file parallel write 13,383 13 2.04 db file sequential read 563 2 .27</pre><p>在某些情况下，可能会有一些具有相似百分比的事件。如果所有事件都与相同类型的资源请求相关（例如，所有与I / O相关的事件），则可以提供额外的证据。</p>
                           </li>
                           <li>
                              <p>查看这些事件的等待次数以及平均等待时间。例如，对于I / O相关事件，平均时间可能有助于确定I / O系统是否很慢。以下此数据示例来自AWR报告的“等待事件”部分：</p><pre class="oac_no_warn" dir="ltr">平均等待等待等待事件等待超时时间（秒）/ txn --------------------------- ------ --- --------- ---------- ------ ---------日志文件并行写入2,181 0 28 13 41.2 SQL * Net更多数据来自clie 516,611 0 27 0 9,747.4 db file parallel 13,383 0 13 1 252.5</pre></li>
                           <li>
                              <p>最重要的等待事件确定了下一个要调查的地方。<a href="instance-tuning-using-performance-views.html#GUID-BB5A0533-F6F2-413C-A56D-A8BDB870536B__G44034" title="This table links wait events to potential causes and gives an overview of the Oracle data that could be most useful to review next.">表10-1</a>列出了常见等待事件<a href="instance-tuning-using-performance-views.html#GUID-BB5A0533-F6F2-413C-A56D-A8BDB870536B__G44034" title="此表将等待事件与潜在原因相关联，并概述了下一步可能最有用的Oracle数据。">表</a> 。通常也可以快速查看高负载SQL。</p>
                           </li>
                           <li>
                              <p>检查等待事件指示的相关数据，以查看此数据提供的其他信息。确定此信息是否与等待事件数据一致。在大多数情况下，有足够的数据可以开始制定关于性能瓶颈的潜在原因的理论。</p>
                           </li>
                           <li>
                              <p>要确定此理论是否有效，请将您检查过的数据与其他可用的统计数据进行交叉检查以确保一致性。相应的统计信息因问题而异，但通常包括<code class="codeph">V$SYSSTAT</code>负载配置文件相关数据，操作系统统计信息等。与其他数据进行交叉检查以确认或反驳发展理论。
                              </p>
                           </li>
                        </ol>
                        <div class="infoboxnotealso" id="GUID-03F070F3-81DF-4649-820C-DAD28AEF0871__GUID-76354CB8-F3AD-40EE-8D77-56B8C95C9FD5">
                           <p class="notep1">也可以看看：</p>
                           <ul style="list-style-type:disc">
                              <li>
                                 <p><span class="q">“ <a href="instance-tuning-using-performance-views.html#GUID-34B5BAAB-02ED-402E-877F-AFF7945C2A8F">空闲等待事件</a> ”</span>表示空闲等待事件列表</p>
                              </li>
                              <li>
                                 <p>有关等待事件的更多信息，请参阅<a href="../refrn/oracle-wait-events.html#REFRN101" target="_blank"><span class="italic">Oracle数据库参</span></a></p>
                              </li>
                           </ul>
                        </div>
                     </div>
                     <!-- class="section" -->
                  </div>
               </div><a id="TGDBA94466"></a><a id="TGDBA94465"></a><div class="props_rev_3"><a id="GUID-BB5A0533-F6F2-413C-A56D-A8BDB870536B" name="GUID-BB5A0533-F6F2-413C-A56D-A8BDB870536B"></a><h4 id="TGDBA-GUID-BB5A0533-F6F2-413C-A56D-A8BDB870536B" class="sect4"><span class="enumeration_section">10.2.3</span>等待事件和潜在原因表</h4>
                  <div>
                     <p><a href="instance-tuning-using-performance-views.html#GUID-BB5A0533-F6F2-413C-A56D-A8BDB870536B__G44034" title="此表将等待事件与潜在原因相关联，并概述了下一步可能最有用的Oracle数据。">表10-1</a>将等待事件与可能的原因联系起来，并概述了下一步可能最有用的Oracle数据。
                     </p>
                     <div class="tblformalwide" id="GUID-BB5A0533-F6F2-413C-A56D-A8BDB870536B__G44034">
                        <p class="titleintable">表10-1等待事件和潜在原因</p>
                        <table cellpadding="4" cellspacing="0" class="FormalWide" title="等待事件和潜在原因" width="100%" border="1" summary="This table links wait events to potential causes and gives an overview of the Oracle data that could be most useful to review next." frame="hsides" rules="rows">
                           <thead>
                              <tr align="left" valign="top">
                                 <th align="left" valign="bottom" id="d25676e2406">等待事件</th>
                                 <th align="left" valign="bottom" id="d25676e2409">一般区域</th>
                                 <th align="left" valign="bottom" id="d25676e2412">可能的原因</th>
                                 <th align="left" valign="bottom" id="d25676e2415">寻找/检查</th>
                              </tr>
                           </thead>
                           <tbody>
                              <tr align="left" valign="top">
                                 <td align="left" valign="top" id="d25676e2420" headers="d25676e2406 ">
                                    <p><code class="codeph">缓冲区忙等待</code> 
                                    </p>
                                 </td>
                                 <td align="left" valign="top" headers="d25676e2420 d25676e2409 ">
                                    <p>缓冲区缓存，DBWR</p>
                                 </td>
                                 <td align="left" valign="top" headers="d25676e2420 d25676e2412 ">
                                    <p>取决于缓冲区类型。例如，等待索引块可能是由基于升序的主键引起的。</p>
                                 </td>
                                 <td align="left" valign="top" headers="d25676e2420 d25676e2415 ">
                                    <p>在问题发生时检查<code class="codeph">V$SESSION</code>以确定争用中的块类型。
                                    </p>
                                 </td>
                              </tr>
                              <tr align="left" valign="top">
                                 <td align="left" valign="top" id="d25676e2438" headers="d25676e2406 ">
                                    <p><code class="codeph">免费缓冲等待</code> 
                                    </p>
                                 </td>
                                 <td align="left" valign="top" headers="d25676e2438 d25676e2409 ">
                                    <p>缓冲区缓存，DBWR，I / O.</p>
                                 </td>
                                 <td align="left" valign="top" headers="d25676e2438 d25676e2412 ">
                                    <p>缓慢的DBWR（可能是由于I / O？）</p>
                                    <p>缓存太小</p>
                                 </td>
                                 <td align="left" valign="top" headers="d25676e2438 d25676e2415 ">
                                    <p>使用操作系统统计信息检查写入时间。检查缓冲区缓存统计信息以获取缓存太小的证据。</p>
                                 </td>
                              </tr>
                              <tr align="left" valign="top">
                                 <td align="left" valign="top" id="d25676e2455" headers="d25676e2406 ">
                                    <p><code class="codeph">db文件分散读取</code> 
                                    </p>
                                 </td>
                                 <td align="left" valign="top" headers="d25676e2455 d25676e2409 ">
                                    <p>I / O，SQL语句调优</p>
                                 </td>
                                 <td align="left" valign="top" headers="d25676e2455 d25676e2412 ">
                                    <p>调整不好的SQL</p>
                                    <p>慢速I / O系统</p>
                                 </td>
                                 <td align="left" valign="top" headers="d25676e2455 d25676e2415 ">
                                    <p>调查<code class="codeph">V$SQLAREA</code>以查看是否存在执行许多磁盘读取的SQL语句。交叉检查I / O系统和<code class="codeph">V$FILESTAT</code>因为读取时间很短。
                                    </p>
                                 </td>
                              </tr>
                              <tr align="left" valign="top">
                                 <td align="left" valign="top" id="d25676e2478" headers="d25676e2406 ">
                                    <p><code class="codeph">db文件顺序读取</code> 
                                    </p>
                                 </td>
                                 <td align="left" valign="top" headers="d25676e2478 d25676e2409 ">
                                    <p>I / O，SQL语句调优</p>
                                 </td>
                                 <td align="left" valign="top" headers="d25676e2478 d25676e2412 ">
                                    <p>调整不好的SQL</p>
                                    <p>慢速I / O系统</p>
                                 </td>
                                 <td align="left" valign="top" headers="d25676e2478 d25676e2415 ">
                                    <p>调查<code class="codeph">V$SQLAREA</code>以查看是否存在执行许多磁盘读取的SQL语句。交叉检查I / O系统和<code class="codeph">V$FILESTAT</code>因为读取时间很短。
                                    </p>
                                 </td>
                              </tr>
                              <tr align="left" valign="top">
                                 <td align="left" valign="top" id="d25676e2501" headers="d25676e2406 ">
                                    <p><code class="codeph">enqueue</code>等待（等待以<code class="codeph">enq:</code>开头<code class="codeph">enq:</code></p>
                                 </td>
                                 <td align="left" valign="top" headers="d25676e2501 d25676e2409 ">
                                    <p>锁</p>
                                 </td>
                                 <td align="left" valign="top" headers="d25676e2501 d25676e2412 ">
                                    <p>取决于入队的类型</p>
                                 </td>
                                 <td align="left" valign="top" headers="d25676e2501 d25676e2415 ">
                                    <p>看看<code class="codeph">V$ENQUEUE_STAT</code> 。</p>
                                 </td>
                              </tr>
                              <tr align="left" valign="top">
                                 <td align="left" valign="top" id="d25676e2522" headers="d25676e2406 ">
                                    <p><code class="codeph"></code>库高速缓存锁定等待： <code class="codeph">library</code> <code class="codeph">cache</code> ， <code class="codeph">library</code> <code class="codeph">cache</code> <code class="codeph">pin</code>和<code class="codeph">library</code> <code class="codeph">cache</code> <code class="codeph">lock</code> 
                                    </p>
                                 </td>
                                 <td align="left" valign="top" headers="d25676e2522 d25676e2409 ">
                                    <p>锁定争用</p>
                                 </td>
                                 <td align="left" valign="top" headers="d25676e2522 d25676e2412 ">
                                    <p>SQL解析或共享</p>
                                 </td>
                                 <td align="left" valign="top" headers="d25676e2522 d25676e2415 ">
                                    <p>检查<code class="codeph">V$SQLAREA</code>以查看是否存在具有相对较多的解析调用或大量子游标的SQL语句（列<code class="codeph">VERSION_COUNT</code> ）。检查<code class="codeph">V$SYSSTAT</code>解析统计<code class="codeph">V$SYSSTAT</code>及其每秒的相应速率。
                                    </p>
                                 </td>
                              </tr>
                              <tr align="left" valign="top">
                                 <td align="left" valign="top" id="d25676e2570" headers="d25676e2406 ">
                                    <p><code class="codeph">日志缓冲区空间</code> 
                                    </p>
                                 </td>
                                 <td align="left" valign="top" headers="d25676e2570 d25676e2409 ">
                                    <p>日志缓冲区，I / O.</p>
                                 </td>
                                 <td align="left" valign="top" headers="d25676e2570 d25676e2412 ">
                                    <p>日志缓冲区很小</p>
                                    <p>慢速I / O系统</p>
                                 </td>
                                 <td align="left" valign="top" headers="d25676e2570 d25676e2415 ">
                                    <p>检查<code class="codeph">V$SYSSTAT</code>的统计信息<code class="codeph">redo</code> <code class="codeph">buffer</code> <code class="codeph">allocation</code> <code class="codeph">retries</code> 。在配置内存章节中检查配置日志缓冲区。检查容纳联机重做日志的磁盘是否存在资源争用。
                                    </p>
                                 </td>
                              </tr>
                              <tr align="left" valign="top">
                                 <td align="left" valign="top" id="d25676e2602" headers="d25676e2406 ">
                                    <p><code class="codeph">日志文件同步</code> 
                                    </p>
                                 </td>
                                 <td align="left" valign="top" headers="d25676e2602 d25676e2409 ">
                                    <p>I / O，过度提交</p>
                                 </td>
                                 <td align="left" valign="top" headers="d25676e2602 d25676e2412 ">
                                    <p>存储在线日志的慢速磁盘</p>
                                    <p>未批量提交</p>
                                 </td>
                                 <td align="left" valign="top" headers="d25676e2602 d25676e2415 ">
                                    <p>检查容纳联机重做日志的磁盘是否存在资源争用。从<code class="codeph">V$SYSSTAT</code>检查每秒的事务数（ <code class="codeph">commits</code>和<code class="codeph">rollbacks</code> ）。</p>
                                 </td>
                              </tr>
                           </tbody>
                        </table>
                     </div>
                     <!-- class="inftblhruleinformal" -->
                     <div class="infoboxnotealso" id="GUID-BB5A0533-F6F2-413C-A56D-A8BDB870536B__GUID-9D5D710F-A0C4-4DD6-B44F-6ACD55DC9B00">
                        <p class="notep1">也可以看看：</p>
                        <ul style="list-style-type:disc">
                           <li>
                              <p><span class="q">“ <a href="instance-tuning-using-performance-views.html#GUID-386931AB-A199-41E8-A20C-7317A4FDCACC">等待事件统计</a> ”</span>有关<span class="q">“ <a href="instance-tuning-using-performance-views.html#GUID-BB5A0533-F6F2-413C-A56D-A8BDB870536B__G44034" title="此表将等待事件与潜在原因相关联，并概述了下一步可能最有用的Oracle数据。">表10-1</a> ”中</span>列出的每个事件的详细信息以及其他交叉检查信息</p>
                           </li>
                           <li>
                              <p> 有关动态性能视图的信息，请参阅<a href="../refrn/dynamic-performance-views.html#REFRN003" target="_blank"><span class="italic">Oracle Database Reference</span></a></p>
                           </li>
                           <li>
                              <p>我的Oracle支持通知<code class="codeph">buffer busy waits</code> （34405.1）和<code class="codeph">free buffer waits</code> （62172.1）。您还可以通过在My Oracle Support网站上搜索“忙缓冲区等待”和“可用缓冲区等待”来访问这些通知和相关通知。
                              </p>
                           </li>
                        </ul>
                     </div>
                  </div>
               </div><a id="TGDBA94467"></a><div class="props_rev_3"><a id="GUID-07836086-3C62-4A4A-8392-25A8C34C4A66" name="GUID-07836086-3C62-4A4A-8392-25A8C34C4A66"></a><h4 id="TGDBA-GUID-07836086-3C62-4A4A-8392-25A8C34C4A66" class="sect4"><span class="enumeration_section">10.2.4</span>附加统计</h4>
                  <div>
                     <p>有几个统计信息可以指示没有相应等待事件的性能问题。</p>
                     <div class="section">
                        <p class="subhead3" id="GUID-07836086-3C62-4A4A-8392-25A8C34C4A66__GUID-23CC047E-2BD6-4BBA-9B51-2A3E9FEA5905">重做日志空间请求统计信息</p>
                        <p><code class="codeph">V$SYSSTAT</code>统计信息<code class="codeph">redo</code> <code class="codeph">log</code> <code class="codeph">space</code> <code class="codeph">requests</code>指示服务器进程必须等待联机重做日志中的空间的次数，而不是重做日志缓冲区中的空间。使用此统计信息和等待事件表示您必须调整检查点，DBWR或归档程序活动，而不是LGWR。增加日志缓冲区的大小没有帮助。
                        </p>
                     </div>
                     <!-- class="section" -->
                     <div class="section">
                        <p class="subhead3" id="GUID-07836086-3C62-4A4A-8392-25A8C34C4A66__GUID-57DA9AD8-65D3-432A-9A5F-26A9B533617C">阅读一致性</p>
                        <p><a id="d25676e2734" class="indexterm-anchor"></a><a id="d25676e2736" class="indexterm-anchor"></a>您的系统可能会花费过多时间将更改回滚到块以保持一致的视图。请考虑以下方案：</p>
                        <ul style="list-style-type:disc">
                           <li>
                              <p>如果有许多小事务，并且在发生更改的同一个表的后台运行一个活动的长时间运行查询，则查询可能需要经常回滚这些更改，以获得读取一致的图像桌子。比较以下<code class="codeph">V$SYSSTAT</code>统计信息以确定是否发生这种情况：</p>
                              <ul style="list-style-type:disc">
                                 <li>
                                    <p><code class="codeph">consistent</code> ： <code class="codeph">changes</code> statistic指示数据库块具有应用回滚条目以对块执行一致读取的次数。产生大量<code class="codeph">consistent</code> <code class="codeph">changes</code>工作负载会消耗大量资源。
                                    </p>
                                 </li>
                                 <li>
                                    <p><code class="codeph">consistent gets</code> ：统计信息计算一致模式下的逻辑读取次数。
                                    </p>
                                 </li>
                              </ul>
                           </li>
                           <li>
                              <p>如果很少有非常大的回滚段，那么您的系统可能会花费大量时间在延迟块清除期间回滚事务表，以便准确找出事务提交的系统更改号（SCN）。当Oracle数据库提交事务时，所有已修改的块不一定立即使用提交SCN进行更新。在这种情况下，当读取或更新块时，稍后按需完成。这被称为延迟<a id="d25676e2771" class="indexterm-anchor"></a>阻止清理。
                              </p>
                              <p>以下<code class="codeph">V$SYSSTAT</code>统计数据的比率应接近1：</p><pre class="oac_no_warn" dir="ltr">ratio =事务表一致性读取 - 撤消记录应用/事务表一致读取回滚</pre><p>建议的解决方案是使用自动撤消管理。</p>
                           </li>
                           <li>
                              <p>如果没有足够的回滚段，则会出现回滚段（标头或块）争用。以下提供了此问题的证据：</p>
                              <ul style="list-style-type:disc">
                                 <li>
                                    <p>将<code class="codeph">WAITS</code>的数量与<code class="codeph">V$ROLLSTAT</code>的<code class="codeph">GETS</code> <code class="codeph">V$ROLLSTAT</code> ; <code class="codeph">WAITS</code>与<code class="codeph">GETS</code>的比例应该很小。
                                    </p>
                                 </li>
                                 <li>
                                    <p>检查<code class="codeph">V$WAITSTAT</code>以查看<code class="codeph">CLASS</code> ' <code class="codeph">undo</code> <code class="codeph">header</code> '的缓冲区是否有多个<code class="codeph">WAITS</code> 。
                                    </p>
                                 </li>
                              </ul>
                              <p>建议的解决方案是使用自动撤消管理。</p>
                           </li>
                        </ul>
                     </div>
                     <!-- class="section" -->
                     <div class="section">
                        <p class="subhead3" id="GUID-07836086-3C62-4A4A-8392-25A8C34C4A66__GUID-79CC7F0A-12F9-42B1-8343-1FD11435FC29">表格取连续行</p>
                        <p>您可以通过检查<code class="codeph">V$SYSSTAT</code>的<code class="codeph">table</code> <code class="codeph">fetch</code> <code class="codeph">continued</code> <code class="codeph">row</code>统计信息的数量来检测已迁移或已链接的行。少量链接行（小于1％）不太可能影响系统性能。但是，大部分链接行会影响性能。
                        </p>
                        <p>链接大于块大小的行是不可避免的。考虑使用具有较大块大小的表空间来存储此类数据。</p>
                        <p>但是，对于较小的行，可以通过使用合理的空间参数和良好的应用程序设计来避免链接。例如， <span class="italic">不要</span>插入已填充键值和一个空行中大多数其他列，然后更新该行与真实数据，从而导致该行的规模增长。而是插入从开头填充数据的行。
                        </p>
                        <p><a id="d25676e2853" class="indexterm-anchor"></a><a id="d25676e2855" class="indexterm-anchor"></a>如果<code class="codeph">UPDATE</code>语句增加了一行中的数据量以使该行不再适合其数据块，则Oracle数据库会尝试查找具有足够可用空间的另一个块来保存整个行。如果这样的块可用，则Oracle数据库将整个行移动到新块。此操作称为<span class="bold">行迁移</span> 。如果行太大而无法放入任何可用块，则数据库会将该行拆分为多个部分，并将每个部分存储在单独的块中。此操作称为<span class="bold">行链接</span> 。数据库还可以在插入行时对其进行链接。
                        </p>
                        <p>迁移和链接对性能尤其有害，具体如下：</p>
                        <ul style="list-style-type:disc">
                           <li>
                              <p><code class="codeph">UPDATE</code>语句导致迁移和链接执行不佳</p>
                           </li>
                           <li>
                              <p>选择已迁移或已链接的行的查询，因为这些行必须执行其他输入和输出</p>
                           </li>
                        </ul>
                        <p>名为<code class="codeph">CHAINED_ROWS</code>的示例输出表的定义显示在分发介质上可用的SQL脚本中。此脚本的通用名称是<code class="codeph">UTLCHN1</code> 。<code class="codeph">SQL</code> ，虽然它的确切名称和位置因您的平台而异。输出表必须与<code class="codeph">CHAINED_ROWS</code>表具有相同的列名，数据类型和大小。
                        </p>
                        <p>增加<code class="codeph">PCTFREE</code>可以帮助避免迁移的行。如果您在块中留出更多可用空间，则该行有增长空间。您还可以重新组织或重新创建具有高删除率的表和索引。如果表经常删除行，则数据块中可以包含部分可用空间。如果插入行并稍后展开，则插入的行可能会落入已删除行的块中，但仍没有足够的空间进行扩展。重组表确保主空闲块是完全空的块。
                        </p>
                        <div class="infoboxnote" id="GUID-07836086-3C62-4A4A-8392-25A8C34C4A66__GUID-F57C6C5C-C312-4393-B383-912BA3EF5BA3">
                           <p class="notep1">注意：</p>
                           <p><code class="codeph">PCTUSED</code>与<code class="codeph">PCTFREE</code> 。</p>
                        </div>
                        <div class="infoboxnotealso" id="GUID-07836086-3C62-4A4A-8392-25A8C34C4A66__GUID-97402459-3DB2-41FF-9AE9-87AD4EC22C08">
                           <p class="notep1">也可以看看：</p>
                           <ul style="list-style-type:disc">
                              <li>
                                 <p><a href="../cncpt/logical-storage-structures.html#CNCPT-GUID-71C6DECB-E7D0-4511-9BA1-127AAE8851EF" target="_blank"><span class="italic">Oracle数据库概念</span></a> <span class="italic"> </span>有关<code class="codeph">PCTUSED</code>更多信息</p>
                              </li>
                              <li>
                                 <p><a href="../admin/managing-tables.html#ADMIN-GUID-92361F74-4796-407D-A3B9-569C6E544E34" target="_blank"><span class="italic">Oracle数据库管理员指南</span></a> ，了解如何重组表</p>
                              </li>
                           </ul>
                        </div>
                     </div>
                     <!-- class="section" -->
                     <div class="section">
                        <p class="subhead3" id="GUID-07836086-3C62-4A4A-8392-25A8C34C4A66__GUID-30915155-E9B6-437B-9E96-F252B5F9A61F">解析相关统计</p>
                        <p>应用程序解析得越多，争用的可能性就越大，系统等待的时间也就越多。如果<code class="codeph">parse</code> <code class="codeph">time</code> <code class="codeph">CPU</code>占CPU时间的很大一部分，则花费时间来解析而不是执行语句。如果是这种情况，那么应用程序可能正在使用文字SQL，因此无法共享SQL，或者共享池配置不当。
                        </p>
                        <p>有几种统计信息可用于确定Oracle解析所花费的时间。从<code class="codeph">V$SYSSTAT</code>查询与解析相关的统计<code class="codeph">V$SYSSTAT</code> 。例如：</p><pre class="oac_no_warn" dir="ltr">SELECT NAME，VALUE FROM V $ SYSSTAT WHERE NAME IN（'解析时间cpu'，'解析时间已过去'，'解析计数（硬）'，'此会话使用的CPU'）;</pre><p>可以计算各种比率以帮助确定解析是否可能是一个问题：</p>
                        <ul style="list-style-type:disc">
                           <li>
                              <p>解析时间CPU /解析时间</p>
                              <p>此比率表示解析所花费的时间是由于解析操作本身，而不是等待资源（如锁存器）。比率为1是好的，表明没有花费经过的时间等待高度竞争的资源。</p>
                           </li>
                           <li>
                              <p>解析此会话使用的CPU / CPU</p>
                              <p>此比率表示Oracle服务器进程使用的CPU总量在与解析相关的操作上花费了多少。接近于零的比率是好的，表明大部分CPU不用于解析。</p>
                           </li>
                        </ul>
                     </div>
                     <!-- class="section" -->
                  </div>
               </div>
            </div><a id="TGDBA02410"></a><div class="props_rev_3"><a id="GUID-386931AB-A199-41E8-A20C-7317A4FDCACC" name="GUID-386931AB-A199-41E8-A20C-7317A4FDCACC"></a><h3 id="TGDBA-GUID-386931AB-A199-41E8-A20C-7317A4FDCACC" class="sect3"><span class="enumeration_section">10.3</span>等待事件统计</h3>
               <div>
                  <p><code class="codeph"></code> <code class="codeph">V$SESSION</code> ， <code class="codeph">V$SESSION_WAIT</code> ， <code class="codeph">V$SESSION_HISTORY</code> ， <code class="codeph">V$SESSION_EVENT</code>和<code class="codeph">V$SYSTEM_EVENT</code>视图提供有关等待的资源的信息，如果配置参数<code class="codeph">TIMED_STATISTICS</code>设置为<code class="codeph">true</code> ，则等待每个资源的等待时间。
                  </p>
                  <div class="infoboxnotealso" id="GUID-386931AB-A199-41E8-A20C-7317A4FDCACC__GUID-0723389C-EDF4-41D7-85B6-C08FDBBFE280">
                     <p class="notep1">也可以看看：</p>
                     <ul style="list-style-type:disc">
                        <li>
                           <p><span class="q">“ <a href="instance-tuning-using-performance-views.html#GUID-2CC2320F-4CAA-4ECD-82C4-0A5FC4C9EF64">设置统计</a></span>信息<span class="q"><a href="instance-tuning-using-performance-views.html#GUID-2CC2320F-4CAA-4ECD-82C4-0A5FC4C9EF64">收集级别</a> ”</span>以获取有关<code class="codeph">STATISTICS_LEVEL</code>设置的信息</p>
                        </li>
                        <li>
                           <p>有关包含等待事件统计信息的<code class="codeph">V$</code>视图的信息，请参阅<a href="../refrn/oracle-wait-events.html#REFRN-GUID-03BFEEFB-1020-4F3F-8CF8-A23E7026684B" target="_blank"><span class="italic">Oracle数据库参考</span></a></p>
                        </li>
                     </ul>
                  </div>
                  <p>在执行无功性能调整时调查等待事件和相关的时序数据。列出最多时间的事件往往是性能瓶颈的强烈迹象。</p>
                  <p>以下视图包含相同数据的相关但不同的视图：</p>
                  <ul style="list-style-type:disc">
                     <li>
                        <p><code class="codeph">V$SESSION</code>列出了每个当前会话的会话信息。它列出了当前正在等待的事件，或者每个会话上等待的事件。此视图还包含有关阻止会话，等待状态和等待时间的信息。
                        </p>
                     </li>
                     <li>
                        <p><code class="codeph">V$SESSION_WAIT</code>是当前状态视图。它列出了当前正在等待的事件，或者每个会话上等待的事件，等待状态和等待时间。
                        </p>
                     </li>
                     <li>
                        <p><code class="codeph">V$SESSION_WAIT_HISTORY</code>列出了每个当前会话的最后10个等待事件以及相关的等待时间。
                        </p>
                     </li>
                     <li>
                        <p><code class="codeph">V$SESSION_EVENT</code>列出了每个会话等待的事件的累积历史记录。会话退出后，将从此视图中删除该会话的等待事件统计信息。
                        </p>
                     </li>
                     <li>
                        <p><code class="codeph">V$SYSTEM_EVENT</code>列出了自实例启动以来整个实例等待的事件和时间（即，卷起的所有会话等待事件数据）。
                        </p>
                     </li>
                  </ul>
                  <p>由于<code class="codeph">V$SESSION_WAIT</code>是当前状态视图，因此它还包含比<code class="codeph">V$SESSION_EVENT</code>或<code class="codeph">V$SYSTEM_EVENT</code>更精细的信息。它包括三个参数列中的当前事件的附加识别数据： <code class="codeph">P1</code> ， <code class="codeph">P2</code>和<code class="codeph">P3</code> 。
                  </p>
                  <p>例如， <code class="codeph">V$SESSION_EVENT</code>可以显示会话124（SID = 124）在<code class="codeph">db</code> <code class="codeph">file</code> <code class="codeph">scattered</code> <code class="codeph">read</code>上有许多等待，但它不显示哪个文件和块编号。然而， <code class="codeph">V$SESSION_WAIT</code>示出了在文件编号<code class="codeph">P1</code> ，在读取块数<code class="codeph">P2</code> ，并在读取的块的数目<code class="codeph">P3</code> （ <code class="codeph">P1</code>和<code class="codeph">P2</code>让你确定哪些分段等待事件发生）。
                  </p>
                  <p>本节重点介绍使用<code class="codeph">V$SESSION_WAIT</code>示例。但是，Oracle建议在一定时间间隔内捕获性能数据，并保留此数据以进行性能和容量分析。AWR从<code class="codeph">V$SYSTEM_EVENT</code>视图查询这种形式的汇总数据。</p>
                  <p>本章描述了最常遇到的事件，以区分大小写的字母顺序列出。还包括要检查的其他与事件相关的数据。用于每个事件名称的案例是出现在<code class="codeph">V$SYSTEM_EVENT</code>视图中的<code class="codeph">V$SYSTEM_EVENT</code> 。
                  </p>
               </div><a id="TGDBA95374"></a><div class="props_rev_3"><a id="GUID-B1B8C07C-7255-40DD-B75D-386BCA50B4D5" name="GUID-B1B8C07C-7255-40DD-B75D-386BCA50B4D5"></a><h4 id="TGDBA-GUID-B1B8C07C-7255-40DD-B75D-386BCA50B4D5" class="sect4"><span class="enumeration_section">10.3.1</span>过去版本中等待事件统计信息的更改</h4>
                  <div>
                     <p>从Oracle Database <span class="italic">11g开始</span> ，Oracle数据库累积等待事件的等待计数和超时（例如在<code class="codeph">V$SYSTEM_EVENT</code>视图中）与过去的版本不同。连续等待某些类型的资源（例如队列）在内部被分成一组较短的等待呼叫。在之前的Oracle数据库<span class="italic">11克</span>的版本中，每个单独的内部等待呼叫计数为一个单独的等待。从Oracle Database <span class="italic">11g开始</span> ，单个资源等待被记录为单个等待，而不管等待期间会话经历的内部超时次数。
                     </p>
                     <p>此更改允许Oracle数据库显示更具代表性的等待计数，以及等待资源所花费的准确总时间。超时现在指的是资源等待，而不是单个内部等待调用。此更改还会影响平均等待时间和最长等待时间。例如，如果用户会话必须等待入队以便事务行锁定更新表中的单个行，并且获取入队需要10秒，Oracle数据库会将入队等待分解为3秒等待调用。在此示例中，将有三个3秒等待呼叫，然后是1秒等待呼叫。然而，从会话的角度来看，排队只有一次等待。</p>
                     <p>在发布之前，Oracle数据库11 <span class="italic">g，</span>则<code class="codeph">V$SYSTEM_EVENT</code>如下图将代表这个等待的情景：</p>
                     <ul style="list-style-type:disc">
                        <li>
                           <p><code class="codeph">TOTAL_WAITS</code> ：4次等待（3次3秒等待，1次等待1秒）</p>
                        </li>
                        <li>
                           <p><code class="codeph">TOTAL_TIMEOUTS</code> ：3次超时（前三次等待超时，并在最后等待期间获得入队）</p>
                        </li>
                        <li>
                           <p><code class="codeph">TIME_WAITED</code> ：10秒（4次等待的时间总和）</p>
                        </li>
                        <li>
                           <p><code class="codeph">AVERAGE_WAIT</code> ：2.5秒</p>
                        </li>
                        <li>
                           <p><code class="codeph">MAX_WAIT</code> ：3秒</p>
                        </li>
                     </ul>
                     <p>从Oracle Database <span class="italic">11g开始</span> ，此等待方案表示为：</p>
                     <ul style="list-style-type:disc">
                        <li>
                           <p><code class="codeph">TOTAL_WAITS</code> ：1等待（等待10秒）</p>
                        </li>
                        <li>
                           <p><code class="codeph">TOTAL_TIMEOUTS</code> ：0超时（在资源等待期间获取入队）</p>
                        </li>
                        <li>
                           <p>TIME_WAITED：10秒（资源等待的时间）</p>
                        </li>
                        <li>
                           <p><code class="codeph">AVERAGE_WAIT</code> ：10秒</p>
                        </li>
                        <li>
                           <p><code class="codeph">MAX_WAIT</code> ：10秒</p>
                        </li>
                     </ul>
                     <p>以下常见等待事件受此更改影响：</p>
                     <ul style="list-style-type:disc">
                        <li>
                           <p>入队等待（例如<code class="codeph">enq: name - reason</code> wait）</p>
                        </li>
                        <li>
                           <p>库高速缓存锁等待</p>
                        </li>
                        <li>
                           <p>库缓存引脚等待</p>
                        </li>
                        <li>
                           <p>行缓存锁等待</p>
                        </li>
                     </ul>
                     <p>以下统计信息受此更改影响：</p>
                     <ul style="list-style-type:disc">
                        <li>
                           <p>等待计数</p>
                        </li>
                        <li>
                           <p>等待时间</p>
                        </li>
                        <li>
                           <p>平均等待时间</p>
                        </li>
                        <li>
                           <p>最长等待时间</p>
                        </li>
                     </ul>
                     <p>以下视图受此更改影响：</p>
                     <ul style="list-style-type:disc">
                        <li>
                           <p><code class="codeph">V $ EVENT_HISTOGRAM</code></p>
                        </li>
                        <li>
                           <p><code class="codeph">V $ EVENTMETRIC</code></p>
                        </li>
                        <li>
                           <p><code class="codeph">V $ SERVICE_EVENT</code></p>
                        </li>
                        <li>
                           <p><code class="codeph">V $ SERVICE_WAIT_CLASS</code></p>
                        </li>
                        <li>
                           <p><code class="codeph">V $ SESSION_EVENT</code></p>
                        </li>
                        <li>
                           <p><code class="codeph">V $ SESSION_WAIT</code></p>
                        </li>
                        <li>
                           <p><code class="codeph">V $ SESSION_WAIT_CLASS</code></p>
                        </li>
                        <li>
                           <p><code class="codeph">V $ SESSION_WAIT_HISTORY</code></p>
                        </li>
                        <li>
                           <p><code class="codeph">V $ SYSTEM_EVENT</code></p>
                        </li>
                        <li>
                           <p><code class="codeph">V $ SYSTEM_WAIT_CLASS</code></p>
                        </li>
                        <li>
                           <p><code class="codeph">V $ WAITCLASSMETRIC</code></p>
                        </li>
                        <li>
                           <p><code class="codeph">V $ WAITCLASSMETRIC_HISTORY</code></p>
                        </li>
                     </ul>
                     <div class="infoboxnotealso" id="GUID-B1B8C07C-7255-40DD-B75D-386BCA50B4D5__GUID-C6EF4E14-9EB9-4D0E-B0E5-96AD6906D826">
                        <p class="notep1">也可以看看：</p>
                        <p><a href="../refrn/V-SYSTEM_EVENT.html#REFRN-GUID-65909323-09BD-48D1-B573-FF64BFA82C9A" target="_blank"><span class="italic">Oracle Database Reference</span></a> ，了解<code class="codeph">V$SYSTEM_EVENT</code>视图的说明</p>
                     </div>
                  </div>
               </div><a id="TGDBA94472"></a><div class="props_rev_3"><a id="GUID-03401D0F-DB3E-49E5-89E0-2F2A6164A5C0" name="GUID-03401D0F-DB3E-49E5-89E0-2F2A6164A5C0"></a><h4 id="TGDBA-GUID-03401D0F-DB3E-49E5-89E0-2F2A6164A5C0" class="sect4"><span class="enumeration_section">10.3.2</span>缓冲区忙等待</h4>
                  <div>
                     <p><a id="d25676e3436" class="indexterm-anchor"></a><a id="d25676e3438" class="indexterm-anchor"></a>此等待表示缓冲区高速缓存中存在多个缓冲区，多个进程正在尝试同时访问这些缓冲区。查询<code class="codeph">V$WAITSTAT</code>以获取每类缓冲区的等待统计信息。具有缓冲区忙等待的公共缓冲区类包括<code class="codeph">data</code> <code class="codeph">block</code> ， <code class="codeph">segment</code> <code class="codeph">header</code> ， <code class="codeph">undo</code> <code class="codeph">header</code>和<code class="codeph">undo</code> <code class="codeph">block</code> 。
                     </p>
                     <p>检查以下<code class="codeph">V$SESSION_WAIT</code>参数列：</p>
                     <ul style="list-style-type:disc">
                        <li>
                           <p><code class="codeph">P1</code> ：文件ID</p>
                        </li>
                        <li>
                           <p><code class="codeph">P2</code> ：块ID</p>
                        </li>
                        <li>
                           <p><code class="codeph">P3</code> ：班级ID</p>
                        </li>
                     </ul>
                     <div class="section">
                        <p class="subhead3" id="GUID-03401D0F-DB3E-49E5-89E0-2F2A6164A5C0__GUID-64D6E57B-3E25-4475-A4E6-20D799A5D886">原因</p>
                        <p>要确定可能的原因，首先查询<code class="codeph">V$SESSION</code>以在会话等待<code class="codeph">buffer</code> <code class="codeph">busy</code> <code class="codeph">waits</code>时识别<code class="codeph">ROW_WAIT_OBJ#</code>的值。例如：</p><pre class="oac_no_warn" dir="ltr">SELECT row_wait_obj＃FROM V $ SESSION WHERE EVENT ='buffer busy waits';</pre><p>要识别争用的对象和对象类型， <code class="codeph">DBA_OBJECTS</code>使用从<code class="codeph">V$SESSION</code>返回的<code class="codeph">ROW_WAIT_OBJ#</code>的值来查询<code class="codeph">DBA_OBJECTS</code> 。例如：</p><pre class="oac_no_warn" dir="ltr">SELECT owner，object_name，subobject_name，object_type FROM DBA_OBJECTS WHERE data_object_id = <span class="italic">＆row_wait_obj</span> ;</pre></div>
                     <!-- class="section" -->
                     <div class="section">
                        <p class="subhead3" id="GUID-03401D0F-DB3E-49E5-89E0-2F2A6164A5C0__GUID-B5BB3154-24A2-412A-BA36-B724B8D051DE">操作</p>
                        <p>所需的操作取决于争用的块类和实际段。</p>
                        <p> </p>
                        <p><span class="bold">段标题</span></p>
                        <p>如果争用在段头上，那么这很可能是空闲列表争用。</p>
                        <p><a id="d25676e3543" class="indexterm-anchor"></a>本地管理的表空间中的自动段空间管理消除了指定<code class="codeph">PCTUSED</code> ， <code class="codeph">FREELISTS</code>和<code class="codeph">FREELIST</code> <code class="codeph">GROUPS</code>参数的需要。如果可能，请从手动空间管理切换到自动分段空间管理（ASSM）。
                        </p>
                        <p>如果您无法使用ASSM，则以下信息是相关的（例如，因为表空间使用字典空间管理）。</p>
                        <p>一个<a id="d25676e3562" class="indexterm-anchor"></a>空闲列表是一个空闲数据块列表，通常包括段内几个不同范围内存在的块。自由列表由自由空间尚未达到PCTFREE或已用空间缩小到PCTUSED以下的块组成。使用<code class="codeph">FREELISTS</code>参数指定进程空闲列表的数量。<code class="codeph">FREELISTS</code>的默认值为1。最大值取决于数据块大小。
                        </p>
                        <p>要查找该段的空闲列表的当前设置，请运行以下命令：</p><pre class="oac_no_warn" dir="ltr">SELECT SEGMENT_NAME，来自DBA_SEGMENTS的FREELISTS WHERE SEGMENT_NAME = <span class="italic">段名称</span>和SEGMENT_TYPE = <span class="italic">段类型</span> ;</pre><p>设置免费列表，或增加免费列表的数量。如果添加更多免费列表并不能解决问题，那么使用免费列表组（即使在单个实例中，这也会产生影响）。如果使用Oracle RAC，请确保每个实例都有自己的空闲列表组。</p>
                        <div class="infoboxnotealso" id="GUID-03401D0F-DB3E-49E5-89E0-2F2A6164A5C0__GUID-919A6FB2-4AB2-414D-87F9-09B0EE2AABB1">
                           <p class="notep1">也可以看看：</p>
                           <p>有关自动段空间管理，空闲列表， <code class="codeph">PCTFREE</code>和<code class="codeph">PCTUSED</code>信息，请参阅<a href="../cncpt/logical-storage-structures.html#CNCPT-GUID-13CE5EDA-8C66-4CA0-87B5-4069215A368D" target="_blank"><span class="italic">Oracle数据库概念</span></a></p>
                        </div>
                        <p> </p>
                        <p><span class="bold">数据块</span></p>
                        <p>如果争用在表或索引（而不是段头）上：</p>
                        <ul style="list-style-type:disc">
                           <li>
                              <p>检查右侧索引。这些是由许多进程插入到同一点的索引。例如，那些使用序列号生成器作为键值的那些。</p>
                           </li>
                           <li>
                              <p>考虑使用ASSM，全局散列分区索引或增加空闲列表以避免多个进程尝试插入到同一个块中。</p>
                           </li>
                        </ul>
                        <p> </p>
                        <p><span class="bold">撤消标题</span></p>
                        <p>对于回滚段标题的争用：</p>
                        <ul style="list-style-type:disc">
                           <li>
                              <p>如果您未使用自动撤消管理，则添加更多回滚段。</p>
                           </li>
                        </ul>
                        <p> </p>
                        <p><span class="bold">撤消阻止</span></p>
                        <p>对于回滚段块的争用：</p>
                        <ul style="list-style-type:disc">
                           <li>
                              <p>如果您不使用自动撤消管理，请考虑使回滚段大小更大。</p>
                           </li>
                        </ul>
                     </div>
                     <!-- class="section" -->
                  </div>
               </div><a id="TGDBA94479"></a><div class="props_rev_3"><a id="GUID-E8F12EF9-B4A8-441F-9814-763BB793FAF9" name="GUID-E8F12EF9-B4A8-441F-9814-763BB793FAF9"></a><h4 id="TGDBA-GUID-E8F12EF9-B4A8-441F-9814-763BB793FAF9" class="sect4"><span class="enumeration_section">10.3.3</span> db文件分散读取</h4>
                  <div>
                     <p>此事件表示用户进程正在将缓冲区读入SGA缓冲区高速缓存，并且正在等待物理I / O调用返回。<code class="codeph">db file scattered read</code>的<code class="codeph">db file scattered read</code>发出分散读取以将数据读取到多个不连续的存储器位置。分散读取通常是多块读取。除了全表扫描之外，还可以进行快速全扫描（索引）。
                     </p>
                     <p><a id="d25676e3703" class="indexterm-anchor"></a><a id="d25676e3705" class="indexterm-anchor"></a><a id="d25676e3707" class="indexterm-anchor"></a> <code class="codeph">db</code> <code class="codeph">file</code> <code class="codeph">scattered</code> <code class="codeph">read</code>等待事件标识正在进行完整扫描。执行全扫描时<a id="d25676e3725" class="indexterm-anchor"></a>在缓冲区高速缓存中，读取的块被读入彼此物理上不相邻的存储器位置。这种读取称为分散读取调用，因为块分散在整个存储器中。这就是相应的等待事件被称为'db file scattered read'的原因。多块（最多<code class="codeph">DB_FILE_MULTIBLOCK_READ_COUNT</code>块）读取由于完全扫描到缓冲区缓存中显示为等待'db file scattered read'。
                     </p>
                     <p>检查以下<code class="codeph">V$SESSION_WAIT</code>参数列：</p>
                     <ul style="list-style-type:disc">
                        <li>
                           <p><code class="codeph">P1</code> ：绝对文件编号</p>
                        </li>
                        <li>
                           <p><code class="codeph">P2</code> ：正在读取的块</p>
                        </li>
                        <li>
                           <p><code class="codeph">P3</code> ：块数（应大于1）</p>
                        </li>
                     </ul>
                     <div class="section">
                        <p class="subhead3" id="GUID-E8F12EF9-B4A8-441F-9814-763BB793FAF9__GUID-68BD6F72-D37C-4EA5-BF9C-E72906BFE848">操作</p>
                        <p><a id="d25676e3758" class="indexterm-anchor"></a><a id="d25676e3762" class="indexterm-anchor"></a>在一个健康的系统上，物理读取等待应该是空闲等待后的最大等待。但是，还要考虑在应该进行小索引访问的操作（OLTP）系统上是否存在直接读取等待（表示具有并行查询的全表扫描）或<code class="codeph">db</code> <code class="codeph">file</code> <code class="codeph">scattered</code> <code class="codeph">read</code>等待。
                        </p>
                        <p>其他可能表明系统上I / O负载过大的事情包括：</p>
                        <ul style="list-style-type:disc">
                           <li>
                              <p>缓冲区缓存命中率不佳</p>
                           </li>
                           <li>
                              <p>这些等待事件累积了用户遇到响应时间较短的大部分等待时间</p>
                           </li>
                        </ul>
                     </div>
                     <!-- class="section" -->
                     <div class="section" id="GUID-E8F12EF9-B4A8-441F-9814-763BB793FAF9__ManagingExcessiveIO-F950BAC4">
                        <p class="subhead3" id="GUID-E8F12EF9-B4A8-441F-9814-763BB793FAF9__GUID-421BF002-406C-4403-9FB9-228F12301674">管理过多的I / O.</p>
                        <p><a id="d25676e3792" class="indexterm-anchor"></a><a id="d25676e3796" class="indexterm-anchor"></a>有几种方法可以处理过多的I / O等待。有效性的顺序如下：</p>
                        <ul style="list-style-type:disc">
                           <li>
                              <p>通过SQL调优减少I / O活动。</p>
                           </li>
                           <li>
                              <p>通过管理工作负载减少执行I / O的需要。</p>
                           </li>
                           <li>
                              <p>使用<code class="codeph">DBMS_STATS</code>包收集系统统计信息，允许查询优化器准确地使用完全扫描的可能访问路径。
                              </p>
                           </li>
                           <li>
                              <p>使用自动存储管理。</p>
                           </li>
                           <li>
                              <p>添加更多磁盘以减少每个磁盘的I / O数量。</p>
                           </li>
                           <li>
                              <p>通过在现有磁盘上重新分配I / O来缓解I / O热点。</p>
                           </li>
                        </ul>
                        <p>第一步应该是找到减少I / O的机会。检查由等待这些事件的会话运行的SQL语句以及导致<code class="codeph">V$SQLAREA</code>导致高物理I / O的语句。可能对导致过多I / O的执行计划产生负面影响的因素包括：</p>
                        <ul style="list-style-type:disc">
                           <li>
                              <p>SQL不正确优化</p>
                           </li>
                           <li>
                              <p>缺少索引</p>
                           </li>
                           <li>
                              <p>表的高度并行性（使优化器偏向扫描）</p>
                           </li>
                           <li>
                              <p>缺少优化程序的准确统计信息</p>
                           </li>
                           <li>
                              <p>将<code class="codeph">DB_FILE_MULTIBLOCK_READ_COUNT</code>初始化参数的值设置得太高，这有利于完全扫描</p>
                           </li>
                        </ul>
                     </div>
                     <!-- class="section" -->
                     <div class="section">
                        <p class="subhead3" id="GUID-E8F12EF9-B4A8-441F-9814-763BB793FAF9__GUID-949A4066-2523-4FF1-93B7-584EA205EEE3">I / O分配不足</p>
                        <p>除了减少I / O外，还要检查磁盘上文件的I / O分布。I / O是否在磁盘上均匀分布，或者某些磁盘上是否存在热点？磁盘数量是否足以满足数据库的I / O需求？</p>
                        <p>查看数据库的总I / O操作（读取和写入），并将其与使用的磁盘数进行比较。请记住包含LGWR和ARCH进程的I / O活动。</p>
                     </div>
                     <!-- class="section" -->
                     <div class="section">
                        <p class="subhead3" id="GUID-E8F12EF9-B4A8-441F-9814-763BB793FAF9__GUID-AED31856-922F-4498-A0FB-058DED052703">查找由等待I / O的会话执行的SQL语句</p>
                        <p><a id="d25676e3858" class="indexterm-anchor"></a><a id="d25676e3862" class="indexterm-anchor"></a>使用以下查询在某个时间点确定哪些会话正在等待I / O：</p><pre class="oac_no_warn" dir="ltr">SELECT SQL_ADDRESS，SQL_HASH_VALUE FROM V $ SESSION WHERE EVKE LIKE'db file％read';</pre></div>
                     <!-- class="section" -->
                     <div class="section">
                        <p class="subhead3" id="GUID-E8F12EF9-B4A8-441F-9814-763BB793FAF9__GUID-2853FBD3-24B4-44CD-B7D9-80670B1B13FE">查找需要I / O的对象</p>
                        <p><a id="d25676e3873" class="indexterm-anchor"></a>要确定可能的原因，首先查询<code class="codeph">V$SESSION</code>以在会话等待<code class="codeph">db</code> <code class="codeph">file</code> <code class="codeph">scattered</code> <code class="codeph">read</code>时识别<code class="codeph">ROW_WAIT_OBJ#</code>的值。例如：</p><pre class="oac_no_warn" dir="ltr">SELECT row_wait_obj＃FROM V $ SESSION WHERE EVENT ='db file scattered read';</pre><p>要识别争用的对象和对象类型， <code class="codeph">DBA_OBJECTS</code>使用从<code class="codeph">V$SESSION</code>返回的<code class="codeph">ROW_WAIT_OBJ#</code>的值来查询<code class="codeph">DBA_OBJECTS</code> 。例如：</p><pre class="oac_no_warn" dir="ltr">SELECT owner，object_name，subobject_name，object_type FROM DBA_OBJECTS WHERE data_object_id = <span class="italic">＆row_wait_obj</span> ;</pre></div>
                     <!-- class="section" -->
                  </div>
               </div><a id="TGDBA94487"></a><a id="TGDBA94485"></a><div class="props_rev_3"><a id="GUID-798559B6-D708-419C-BF02-83530522E591" name="GUID-798559B6-D708-419C-BF02-83530522E591"></a><h4 id="TGDBA-GUID-798559B6-D708-419C-BF02-83530522E591" class="sect4"><span class="enumeration_section">10.3.4</span> db文件顺序读取</h4>
                  <div>
                     <p><a id="d25676e3976" class="indexterm-anchor"></a><a id="d25676e3980" class="indexterm-anchor"></a>此事件表示用户进程正在将缓冲区读入SGA <a id="d25676e3983" class="indexterm-anchor"></a>缓冲区缓存并等待物理I / O调用返回。顺序读取是单块读取。
                     </p>
                     <p>单块I / O通常是使用索引的结果。由于范围边界或缓冲区缓存中存在缓冲区，很少会将全表扫描调用截断为单个块调用。这些等待也将显示为<code class="codeph">db file sequential read</code> 。
                     </p>
                     <p>检查以下<code class="codeph">V$SESSION_WAIT</code>参数列：</p>
                     <ul style="list-style-type:disc">
                        <li>
                           <p><code class="codeph">P1</code> ：绝对文件编号</p>
                        </li>
                        <li>
                           <p><code class="codeph">P2</code> ：正在读取的块</p>
                        </li>
                        <li>
                           <p><code class="codeph">P3</code> ：块数（应为1）</p>
                           <div class="infoboxnotealso" id="GUID-798559B6-D708-419C-BF02-83530522E591__GUID-3AF230F6-A5A6-4855-8AC9-CAF574397AC3">
                              <p class="notep1">也可以看看：</p>
                              <p><span class="q">“ <a href="instance-tuning-using-performance-views.html#GUID-E8F12EF9-B4A8-441F-9814-763BB793FAF9">db file scattered read</a> ”</span>有关管理过多I / O，I / O分配不足以及查找导致I / O和执行I / O的段的SQL的信息。
                              </p>
                           </div>
                        </li>
                     </ul>
                     <div class="section">
                        <p class="subhead3" id="GUID-798559B6-D708-419C-BF02-83530522E591__GUID-C82F282D-195C-40A8-B75D-165C3A0577EA">操作</p>
                        <p><a id="d25676e4024" class="indexterm-anchor"></a><a id="d25676e4028" class="indexterm-anchor"></a><a id="d25676e4032" class="indexterm-anchor"></a>在一个健康的系统上，物理读取等待应该是空闲等待后的最大等待。但是，还要考虑是否在大型数据仓库中存在<code class="codeph">db</code> <code class="codeph">file</code> <code class="codeph">sequential</code> <code class="codeph">reads</code> ，这些<code class="codeph">reads</code>应该主要通过并行查询来查看全表扫描。
                        </p>
                        <p>下图显示了这些等待事件之间的差异：</p>
                        <ul style="list-style-type:disc">
                           <li>
                              <p><code class="codeph">db</code> <code class="codeph">file</code> <code class="codeph">sequential</code> <code class="codeph">read</code> （单个块读入一个SGA缓冲区）</p>
                           </li>
                           <li>
                              <p><code class="codeph">db</code> <code class="codeph">file</code> <code class="codeph">scattered</code> <code class="codeph">read</code> （多块读入许多不连续的SGA缓冲区）</p>
                           </li>
                           <li>
                              <p><code class="codeph">direct</code> <code class="codeph">read</code> （单个或多个块读入PGA，绕过SGA）</p>
                           </li>
                        </ul>
                        <div class="figure" id="GUID-798559B6-D708-419C-BF02-83530522E591__I23087">
                           <p class="titleinfigure">图10-1分散读取，顺序读取和直接路径读取</p><img src="img/figure_101_scattered_read_sequential_read_and_direct_path_read.png" alt="下面是图10-1的描述" title="下面是图10-1的描述" longdesc="img_text/figure_101_scattered_read_sequential_read_and_direct_path_read.html"><br><a href="img_text/figure_101_scattered_read_sequential_read_and_direct_path_read.html">“图10-1分散读取，顺序读取和直接路径读取”的说明</a></div>
                        <!-- class="figure" -->
                     </div>
                     <!-- class="section" -->
                  </div>
               </div><a id="TGDBA94488"></a><div class="props_rev_3"><a id="GUID-2833BD11-FDF6-4134-A0DD-62E8CB32AE2C" name="GUID-2833BD11-FDF6-4134-A0DD-62E8CB32AE2C"></a><h4 id="TGDBA-GUID-2833BD11-FDF6-4134-A0DD-62E8CB32AE2C" class="sect4"><span class="enumeration_section">10.3.5</span>直接路径读取和直接路径读取温度</h4>
                  <div>
                     <p><a id="d25676e4149" class="indexterm-anchor"></a><a id="d25676e4153" class="indexterm-anchor"></a>当会话正在从磁盘读取缓冲区直接进入P GA（与SGA中的缓冲区缓存相对）时，它会等待此事件。如果I / O子系统不支持异步I / O，则每个等待对应于物理读取请求。</p>
                     <p>如果I / O子系统支持异步I / O，则该过程能够与发出的读取请求重叠，并处理PGA中存在的块。当进程尝试访问尚未从磁盘读取的PGA中的块时，它会发出等待调用并更新此事件的统计信息。因此，等待的数量不一定与读取请求的数量相同（与<code class="codeph">db</code> <code class="codeph">file</code> <code class="codeph">scattered</code> <code class="codeph">read</code>和<code class="codeph">db</code> <code class="codeph">file</code> <code class="codeph">sequential</code> <code class="codeph">read</code> ）。
                     </p>
                     <p>检查以下<code class="codeph">V$SESSION_WAIT</code>参数列：</p>
                     <ul style="list-style-type:disc">
                        <li>
                           <p><code class="codeph">P1</code> ：读取调用的File_id</p>
                        </li>
                        <li>
                           <p><code class="codeph">P2</code> ：启动读取调用的block_id</p>
                        </li>
                        <li>
                           <p><code class="codeph">P3</code> ：读取调用中的块数</p>
                        </li>
                     </ul>
                     <div class="section">
                        <p class="subhead3" id="GUID-2833BD11-FDF6-4134-A0DD-62E8CB32AE2C__GUID-70E628DE-A0AB-4AC0-B7C7-E37F8BE0C403">原因</p>
                        <p><a id="d25676e4215" class="indexterm-anchor"></a>在以下情况下会发生这种情况：</p>
                        <ul style="list-style-type:disc">
                           <li>
                              <p>这些排序太大而无法放入内存中，并且某些排序数据会直接写入磁盘。稍后使用直接读取读回该数据。</p>
                           </li>
                           <li>
                              <p>并行执行服务器用于扫描数据。</p>
                           </li>
                           <li>
                              <p>服务器进程处理缓冲区的速度比I / O系统返回缓冲区的速度快。这可能表示I / O系统过载。</p>
                           </li>
                        </ul>
                     </div>
                     <!-- class="section" -->
                     <div class="section">
                        <p class="subhead3" id="GUID-2833BD11-FDF6-4134-A0DD-62E8CB32AE2C__GUID-B73AB2FE-BAF9-435D-9BC0-BF6A0A4341D0">操作</p>
                        <p><code class="codeph">file_id</code>显示读取是针对<code class="codeph">TEMP</code>表空间中的对象（分类到磁盘）还是并行执行服务器的全表扫描。这种等待是大型数据仓库站点的最大等待。但是，如果工作负载不是决策支持系统（DSS）工作负载，那么请检查这种情况发生的原因。
                        </p>
                        <p> </p>
                        <p><span class="bold">排序到磁盘</span></p>
                        <p>检查当前正在经历等待的会话运行的SQL语句，以查看导致排序的原因。查询<code class="codeph">V$TEMPSEG_USAGE</code>以查找生成排序的SQL语句。还可以从<code class="codeph">V$SESSTAT</code>查询<code class="codeph">V$SESSTAT</code>的统计信息，以确定排序的大小。通过调整SQL语句来查看是否可以减少排序。如果<code class="codeph">WORKAREA_SIZE_POLICY</code>是<code class="codeph">MANUAL</code> ，则考虑增加系统的<code class="codeph">SORT_AREA_SIZE</code> （如果排序不是太大）或单个进程。如果<code class="codeph">WORKAREA_SIZE_POLICY</code>为<code class="codeph">AUTO</code> ，则调查是否增加<code class="codeph">PGA_AGGREGATE_TARGET</code> 。</p>
                        <p> </p>
                        <p><span class="bold">全表扫描</span></p>
                        <p>如果以高度并行性定义表，则此设置可能会使优化程序倾向于使用并行执行服务器进行全表扫描。使用直接路径读取检查要读入的对象。如果全表扫描是工作负载的有效部分，则确保I / O子系统足以满足并行度。如果您尚未使用磁盘条带化或Oracle自动存储管理（Oracle ASM），请考虑使用磁盘条带化。</p>
                        <p> </p>
                        <p><span class="bold">哈希区域大小</span></p>
                        <p>对于调用散列连接的查询计划， <code class="codeph">HASH_AREA_SIZE</code>过小会导致过多的I / O.如果<code class="codeph">WORKAREA_SIZE_POLICY</code>为<code class="codeph">MANUAL</code> ，则考虑增加系统或单个进程的<code class="codeph">HASH_AREA_SIZE</code> 。如果<code class="codeph">WORKAREA_SIZE_POLICY</code>为<code class="codeph">AUTO</code> ，则调查是否增加<code class="codeph">PGA_AGGREGATE_TARGET</code> 。</p>
                        <div class="infoboxnotealso" id="GUID-2833BD11-FDF6-4134-A0DD-62E8CB32AE2C__GUID-AB02D51A-E19C-47FF-9322-245834D4B3F2">
                           <p class="notep1">也可以看看：</p>
                           <ul style="list-style-type:disc">
                              <li>
                                 <p><span class="q">“</span> <span class="q"><a href="instance-tuning-using-performance-views.html#GUID-E8F12EF9-B4A8-441F-9814-763BB793FAF9">db file scattered read</a> ”</span>部分中的<span class="q">“管理过多的I / O</span> <span class="q">”</span></p>
                              </li>
                           </ul>
                        </div>
                     </div>
                     <!-- class="section" -->
                  </div>
               </div><a id="TGDBA94494"></a><div class="props_rev_3"><a id="GUID-EF32702E-D74B-49CB-B05F-CEC7A9613EF1" name="GUID-EF32702E-D74B-49CB-B05F-CEC7A9613EF1"></a><h4 id="TGDBA-GUID-EF32702E-D74B-49CB-B05F-CEC7A9613EF1" class="sect4"><span class="enumeration_section">10.3.6</span>直接路径写入和直接路径写入温度</h4>
                  <div>
                     <p><a id="d25676e4371" class="indexterm-anchor"></a><a id="d25676e4375" class="indexterm-anchor"></a>当进程直接从缓冲区写入时<a id="d25676e4380" class="indexterm-anchor"></a> PGA（与DBWR从缓冲区缓存中写入它们相反），进程等待此事件以完成写入调用。可以执行直接路径写入的操作包括磁盘上的排序，并行DML操作，直接路径<code class="codeph">INSERT</code> ，并行创建表选择以及一些LOB操作。
                     </p>
                     <p>与直接路径读取一样，如果I / O子系统支持异步写入，则等待的数量与发出的写入调用的数量不同。会话等待它是否已处理PGA中的所有缓冲区，并且在I / O请求完成之前无法继续工作。</p>
                     <div class="infoboxnotealso" id="GUID-EF32702E-D74B-49CB-B05F-CEC7A9613EF1__GUID-A435A36E-412D-4A9C-9F4F-963D364284E1">
                        <p class="notep1">也可以看看：</p>
                        <p>有关直接路径插入的信息，请参见<a href="../admin/managing-tables.html#ADMIN01509" target="_blank"><span class="italic">“Oracle数据库管理员指南”</span></a></p>
                     </div>
                     <p>检查以下<code class="codeph">V$SESSION_WAIT</code>参数列：</p>
                     <ul style="list-style-type:disc">
                        <li>
                           <p><code class="codeph">P1</code> ：写入调用的File_id</p>
                        </li>
                        <li>
                           <p><code class="codeph">P2</code> ：启动写入调用的block_id</p>
                        </li>
                        <li>
                           <p><code class="codeph">P3</code> ：写入调用中的块数</p>
                        </li>
                     </ul>
                     <div class="section">
                        <p class="subhead3" id="GUID-EF32702E-D74B-49CB-B05F-CEC7A9613EF1__GUID-9D597A68-9FF5-418B-B789-C9572DB5F8E9">原因</p>
                        <p><a id="d25676e4422" class="indexterm-anchor"></a>这种情况发生在以下情况：</p>
                        <ul style="list-style-type:disc">
                           <li>
                              <p>排序太大，无法放入内存并写入磁盘</p>
                           </li>
                           <li>
                              <p>发出并行DML以创建/填充对象</p>
                           </li>
                           <li>
                              <p>直接路径加载</p>
                           </li>
                        </ul>
                     </div>
                     <!-- class="section" -->
                     <div class="section">
                        <p class="subhead3" id="GUID-EF32702E-D74B-49CB-B05F-CEC7A9613EF1__GUID-3AE9706D-D1FA-4CC6-8A19-B2B037816126">操作</p>
                        <p><a id="d25676e4441" class="indexterm-anchor"></a>对于大型排序，请参阅<span class="q">“排序到磁盘”</span> 。
                        </p>
                        <p>对于并行DML，检查磁盘上的I / O分布，并确保I / O子系统针对并行度进行了充分配置。</p>
                     </div>
                     <!-- class="section" -->
                  </div>
               </div><a id="TGDBA94497"></a><div class="props_rev_3"><a id="GUID-95757696-4B7B-4D3F-A527-57BF0CCCC029" name="GUID-95757696-4B7B-4D3F-A527-57BF0CCCC029"></a><h4 id="TGDBA-GUID-95757696-4B7B-4D3F-A527-57BF0CCCC029" class="sect4"><span class="enumeration_section">10.3.7</span> enqueue（enq :)等待</h4>
                  <div>
                     <p><a id="d25676e4511" class="indexterm-anchor"></a><a id="d25676e4513" class="indexterm-anchor"></a>队列是用于协调对数据库资源的访问的锁。此事件表示会话正在等待另一个会话持有的锁定。
                     </p>
                     <p>enqueue的名称作为等待事件名称的一部分包含在<code class="codeph">enq:</code> <code class="codeph">enqueue</code> _ <code class="codeph">type</code> <code class="codeph">-</code> <code class="codeph">related</code> _ <code class="codeph">details</code> 。在某些情况下，可以为不同目的保留相同的入队类型，例如以下相关的<code class="codeph">TX</code>类型：</p>
                     <ul style="list-style-type:disc">
                        <li>
                           <p><code class="codeph">enq:</code> <code class="codeph">TX</code> <code class="codeph">-</code> <code class="codeph">allocate</code> <code class="codeph">ITL</code> <code class="codeph">entry</code> 
                           </p>
                        </li>
                        <li>
                           <p><code class="codeph">enq:</code> <code class="codeph">TX</code> <code class="codeph">-</code> <code class="codeph">contention</code> 
                           </p>
                        </li>
                        <li>
                           <p><code class="codeph">enq:</code> <code class="codeph">TX</code> <code class="codeph">-</code> <code class="codeph">index</code> <code class="codeph">contention</code> 
                           </p>
                        </li>
                        <li>
                           <p><code class="codeph">enq:</code> <code class="codeph">TX</code> <code class="codeph">-</code> <code class="codeph">row</code> <code class="codeph">lock</code> <code class="codeph">contention</code> 
                           </p>
                        </li>
                     </ul>
                     <p><code class="codeph">V$EVENT_NAME</code>视图提供了所有<code class="codeph">enq:</code>等待事件的完整列表。
                     </p>
                     <p>您可以检查以下<code class="codeph">V$SESSION_WAIT</code>参数列以获取其他信息：</p>
                     <ul style="list-style-type:disc">
                        <li>
                           <p><code class="codeph">P1</code> ：锁定<code class="codeph">TYPE</code> （或名称）和<code class="codeph">MODE</code></p>
                        </li>
                        <li>
                           <p><code class="codeph">P2</code> ：锁的资源标识符ID1</p>
                        </li>
                        <li>
                           <p><code class="codeph">P3</code> ：锁的资源标识符ID2</p>
                        </li>
                     </ul>
                     <div class="infoboxnotealso" id="GUID-95757696-4B7B-4D3F-A527-57BF0CCCC029__GUID-D6AB37E8-2F26-4C71-B08D-D46734D3BCB7">
                        <p class="notep1">也可以看看：</p>
                        <p> 有关Oracle数据库队列的更多信息，请<a href="../refrn/oracle-enqueue-names.html#REFRN102" target="_blank"><span class="italic">参见Oracle数据库参考</span></a></p>
                     </div>
                     <div class="section">
                        <p class="subhead3" id="GUID-95757696-4B7B-4D3F-A527-57BF0CCCC029__GUID-56AC21CE-4972-4D4E-A89C-65533899A40C">寻找锁和锁持有人</p>
                        <p>查询<code class="codeph">V$LOCK</code>以查找持有锁的会话。对于等待事件入队的每个会话，在<code class="codeph">V$LOCK</code>有一行， <code class="codeph">REQUEST</code> &lt;&gt; <code class="codeph">0</code> 。使用以下两个查询之一查找持有锁并等待锁的会话。
                        </p>
                        <p>如果有排队等待，您可以使用以下语句查看这些：</p><pre class="oac_no_warn" dir="ltr">SELECT * FROM V $ LOCK WHERE请求&gt; 0;</pre><p>要仅显示等待锁的持有者和服务员，请使用以下命令：</p><pre class="oac_no_warn" dir="ltr">SELECT DECODE（请求，0，'持有人：'，'服务员：'）|| sid sess，id1，id2，lmode，request，type FROM V $ LOCK WHERE（id1，id2，type）IN（SELECT id1，id2，type FROM V $ LOCK WHERE request&gt; 0）ORDER BY id1，request;</pre></div>
                     <!-- class="section" -->
                     <div class="section">
                        <p class="subhead3" id="GUID-95757696-4B7B-4D3F-A527-57BF0CCCC029__GUID-896F0491-596C-4FCE-B7A4-1907684B3AE4">操作</p>
                        <p>适当的操作取决于入队的类型。</p>
                        <p>如果contended-for enqueue是ST enqueue，则问题很可能是动态空间分配。当数据段中没有更多可用空间时，Oracle数据库会动态地将扩展区分配给段。此enqueue仅用于字典管理的表空间。</p>
                        <p>要解决对此资源的争用：</p>
                        <ul style="list-style-type:disc">
                           <li>
                              <p>检查临时（即排序）表空间是否使用<code class="codeph">TEMPFILES</code> 。如果没有，则切换到使用<code class="codeph">TEMPFILES</code> 。</p>
                           </li>
                           <li>
                              <p>如果包含动态增长的段的表空间是字典管理，则切换到使用本地管理的表空间。</p>
                           </li>
                           <li>
                              <p>如果无法切换到本地管理的表空间，则可以通过将增长对象的下一个范围大小更改为足够大以避免恒定空间分配来减少ST排队资源使用。要确定哪些细分受众群不断增长，请监控所有<code class="codeph">SEGMENT_NAMEs</code>的<code class="codeph">DBA_SEGMENTS</code>视图的<code class="codeph">EXTENTS</code>列。
                              </p>
                           </li>
                           <li>
                              <p>例如，通过使用<code class="codeph">ALTER</code> <code class="codeph">TABLE</code> <code class="codeph">ALLOCATE</code> <code class="codeph">EXTENT</code> SQL语句分配扩展区来预分配段中的空间。
                              </p>
                           </li>
                        </ul>
                        <div class="infoboxnotealso" id="GUID-95757696-4B7B-4D3F-A527-57BF0CCCC029__GUID-CFCE4334-9299-46AD-96F8-5E68183DB889">
                           <p class="notep1">也可以看看：</p>
                           <ul style="list-style-type:disc">
                              <li>
                                 <p>有关<code class="codeph">TEMPFILES</code>和本地管理的表空间的详细信息，请<code class="codeph">TEMPFILES</code> <a href="../admin/managing-tablespaces.html#ADMIN-GUID-1C162C60-6698-44F2-B2A9-F3E2D2958D88" target="_blank"><span class="italic">“Oracle数据库管理员指南”</span></a></p>
                              </li>
                              <li>
                                 <p>有关获取空间使用详细信息的详细信息，请参见<a href="../admin/managing-space-for-schema-objects.html#ADMIN014" target="_blank"><span class="italic">Oracle数据库管理员指南</span></a></p>
                              </li>
                           </ul>
                        </div>
                        <p>HW enqueue用于序列化超出段的高水位线的空间分配。</p>
                        <ul style="list-style-type:disc">
                           <li>
                              <p><code class="codeph">V$SESSION_WAIT.P2</code> / <code class="codeph">V$LOCK.ID1</code>是表空间编号。
                              </p>
                           </li>
                           <li>
                              <p><code class="codeph">V$SESSION_WAIT.P3</code> / <code class="codeph">V$LOCK.ID2</code>是正在为其分配空间的对象的段头的相对数据块地址（dba）。
                              </p>
                           </li>
                        </ul>
                        <p>如果这是对象的争用点，那么手动分配范围可以解决问题。</p>
                        <p>等待TM锁的最常见原因往往涉及外键约束，其中约束列未被索引。索引外键列以避免此问题。</p>
                        <p>当事务启动其第一次更改并持续到事务执行<code class="codeph">COMMIT</code>或<code class="codeph">ROLLBACK</code>时，这些是独占的。</p>
                        <ul style="list-style-type:disc">
                           <li>
                              <p>在模式6中等待TX：当会话等待另一个会话持有的行级别锁定时发生。当一个用户正在更新或删除另一个会话想要更新或删除的行时，会发生这种情况。这种类型的TX enqueue wait对应于等待事件<code class="codeph">enq:</code> <code class="codeph">TX</code> <code class="codeph">-</code> <code class="codeph">row</code> <code class="codeph">lock</code> <code class="codeph">contention</code> 。
                              </p>
                              <p>解决方案是让持有锁的第一个会话执行<code class="codeph">COMMIT</code>或<code class="codeph">ROLLBACK</code> 。</p>
                           </li>
                           <li>
                              <p>如果会话正在等待块中的ITL（感兴趣的事务列表）槽，则可以在模式4中等待TX。当会话想要锁定块中的行但一个或多个其他会话在同一块中锁定行时，会发生这种情况，并且块中没有空闲的ITL插槽。通常，Oracle数据库会动态添加另一个ITL插槽。如果块中没有足够的可用空间来添加ITL，则可能无法执行此操作。如果是，则会话在模式4中等待具有TX入队的时隙。这种类型的TX排队等待对应于等待事件<code class="codeph">enq:</code> <code class="codeph">TX</code> <code class="codeph">-</code> <code class="codeph">allocate</code> <code class="codeph">ITL</code> <code class="codeph">entry</code> 。
                              </p>
                              <p>解决方案是通过更改表的<code class="codeph">INITRANS</code>或<code class="codeph">MAXTRANS</code>来增加可用的ITL数（通过使用<code class="codeph">ALTER</code>语句，或通过重新创建具有更高值的表）。
                              </p>
                           </li>
                           <li>
                              <p>如果会话由于<code class="codeph">UNIQUE</code>索引中的潜在重复而等待，则也可能在模式4中等待TX。如果两个会话尝试插入相同的键值，则第二个会话必须等待以查看是否应该引发<code class="codeph">ORA-0001</code> 。这种类型的TX enqueue wait对应于等待事件<code class="codeph">enq:</code> <code class="codeph">TX</code> <code class="codeph">-</code> <code class="codeph">row</code> <code class="codeph">lock</code> <code class="codeph">contention</code> 。
                              </p>
                              <p>解决方案是让持有锁的第一个会话执行<code class="codeph">COMMIT</code>或<code class="codeph">ROLLBACK</code> 。</p>
                           </li>
                           <li>
                              <p>如果会话由于共享位图索引片段而等待，则也可能在模式4中等待TX。位图索引索引键值和一系列rowid。位图索引中的每个条目都可以覆盖实际表中的许多行。如果两个会话想要更新由相同位图索引片段覆盖的行，则第二个会话通过等待模式4中的TX锁定等待第一个事务为<code class="codeph">COMMIT</code>或<code class="codeph">ROLLBACK</code> 。这种类型的TX enqueue wait对应于等待事件<code class="codeph">enq:</code> <code class="codeph">TX</code> <code class="codeph">-</code> <code class="codeph">row</code> <code class="codeph">lock</code> <code class="codeph">contention</code> 。
                              </p>
                           </li>
                           <li>
                              <p>在模式4中等待TX也可能发生等待<code class="codeph">PREPARED</code>事务。
                              </p>
                           </li>
                           <li>
                              <p>当在索引中插入行的事务必须等待由另一个事务完成索引块拆分的结束时，也会发生模式4中的TX等待。这种类型的TX排队等待对应等待事件<code class="codeph">enq:</code> <code class="codeph">TX</code> <code class="codeph">-</code> <code class="codeph">index</code> <code class="codeph">contention</code> 。
                              </p>
                           </li>
                        </ul>
                        <div class="infoboxnotealso" id="GUID-95757696-4B7B-4D3F-A527-57BF0CCCC029__GUID-C5288296-1FA6-454F-923A-06BCE40B28F5">
                           <p class="notep1">也可以看看：</p>
                           <p>有关参照完整性和显式锁定数据的详细信息，请参见<a href="../adfns/sql-processing-for-application-developers.html#ADFNS007" target="_blank"><span class="italic">“Oracle数据库开发指南</span></a></p>
                        </div>
                     </div>
                     <!-- class="section" -->
                  </div>
               </div><a id="TGDBA94504"></a><div class="props_rev_3"><a id="GUID-B970776F-B94B-4610-93FE-9161ACB40D98" name="GUID-B970776F-B94B-4610-93FE-9161ACB40D98"></a><h4 id="TGDBA-GUID-B970776F-B94B-4610-93FE-9161ACB40D98" class="sect4"><span class="enumeration_section">10.3.8</span>等待等级中的事件</h4>
                  <div>
                     <p>此事件属于其他等待类，通常不应出现在系统上。此事件是Other等级中所有其他事件的聚合，例如<code class="codeph">latch free</code> ，并且仅在<code class="codeph">V$SESSION_EVENT</code>和<code class="codeph">V$SERVICE_EVENT</code>视图中使用。在这些视图中，其他等待类中的事件不会在每个会话中单独维护。相反，这些事件将汇总到此单个事件中，以减少用于维护其他等待类中事件的统计信息的内存。
                     </p>
                  </div>
               </div><a id="TGDBA94505"></a><div class="props_rev_3"><a id="GUID-01C9C892-4C0B-4524-82B3-146D1C191BDD" name="GUID-01C9C892-4C0B-4524-82B3-146D1C191BDD"></a><h4 id="TGDBA-GUID-01C9C892-4C0B-4524-82B3-146D1C191BDD" class="sect4"><span class="enumeration_section">10.3.9</span>空闲缓冲区等待</h4>
                  <div>
                     <p><a id="d25676e5051" class="indexterm-anchor"></a><a id="d25676e5053" class="indexterm-anchor"></a>此等待事件表示服务器进程无法找到空闲缓冲区并已发布数据库写入程序以通过写出脏缓冲区来生成空闲缓冲区。脏缓冲区是一个缓冲区，其内容已被修改。当DBWR将块写入磁盘时，将释放脏缓冲区以供重用。
                     </p>
                     <div class="section">
                        <p class="subhead3" id="GUID-01C9C892-4C0B-4524-82B3-146D1C191BDD__GUID-9AD52278-9A30-4109-8F1D-CC94B3709179">原因</p>
                        <p>在以下情况下，DBWR可能无法跟上编写脏缓冲区：</p>
                        <ul style="list-style-type:disc">
                           <li>
                              <p>I / O系统很慢。</p>
                           </li>
                           <li>
                              <p>它正在等待资源，例如锁存器。</p>
                           </li>
                           <li>
                              <p>缓冲区缓存非常小，以至于DBWR花费大部分时间来清理服务器进程的缓冲区。</p>
                           </li>
                           <li>
                              <p>缓冲区缓存非常大，以至于一个DBWR进程不足以在缓存中释放足够的缓冲区来满足请求。</p>
                           </li>
                        </ul>
                     </div>
                     <!-- class="section" -->
                     <div class="section">
                        <p class="subhead3" id="GUID-01C9C892-4C0B-4524-82B3-146D1C191BDD__GUID-EDECAA33-7FB3-4F34-AAEC-3D0B6C530A6B">操作</p>
                        <p>如果此事件频繁发生，则检查会话等待DBWR以查看是否有任何延迟DBWR。</p>
                        <p>如果它正在等待写入，那么确定什么是延迟写入并修复它。检查以下内容：</p>
                        <ul style="list-style-type:disc">
                           <li>
                              <p>检查<code class="codeph">V$FILESTAT</code>以查看大多数写入的位置。
                              </p>
                           </li>
                           <li>
                              <p>检查I / O系统的主机操作系统统计信息。写入时间是否可以接受？</p>
                           </li>
                        </ul>
                        <p>如果I / O很慢：</p>
                        <ul style="list-style-type:disc">
                           <li>
                              <p>考虑使用更快的I / O替代方案来加快写入时间。</p>
                           </li>
                           <li>
                              <p>在大量主轴（磁盘）和控制器上传播I / O活动。</p>
                           </li>
                        </ul>
                        <p>DBWR可能非常活跃，因为缓存太小。通过查看缓冲区缓存命中率是否较低来调查这是否是可能的原因。还可以使用<code class="codeph">V$DB_CACHE_ADVICE</code>视图来确定更大的高速缓存大小是否有利。
                        </p>
                        <p>如果高速缓存大小足够且I / O均匀分布，则可以使用异步I / O或使用多个数据库写入器来修改DBWR的行为。</p>
                     </div>
                     <!-- class="section" -->
                     <div class="section">
                        <p class="subhead3" id="GUID-01C9C892-4C0B-4524-82B3-146D1C191BDD__GUID-C4E6E4A3-1C05-4B90-9BB4-3969A425B6E4">考虑多个数据库写程序（DBWR）进程或I / O从属</p>
                        <p>当事务速率很高或缓冲区高速缓存大小太大以至于单个DBW <span class="italic">n</span>进程无法跟上负载时，配置多个数据库写程序进程或使用I / O从属进程非常有用。
                        </p>
                        <p><code class="codeph">DB_WRITER_PROCESSES</code>初始化参数允许您配置多个数据库写程序进程（从DBW0到DBW9以及从DBWa到DBWj）。配置多个DBWR进程分配识别要写入的缓冲区所需的工作，并且还通过这些进程分配I / O负载。对于具有多个CPU（每8个CPU至少有一个db writer）或多个处理器组（至少与处理器组一样多的db编写器）的系统，强烈建议使用多个db writer进程。
                        </p>
                        <p>根据CPU数量和处理器组数量，Oracle数据库为<code class="codeph">DB_WRITER_PROCESSES</code>选择适当的默认设置或调整用户指定的设置。
                        </p>
                        <p>如果使用多个DBWR进程是不切实际的，那么Oracle数据库提供了一种工具，可以将I / O负载分布在多个从属进程上。DBWR进程是扫描缓冲区高速缓存LRU列表以查找要写出的块的唯一进程。但是，这些块的I / O由I / O从站执行。I / O从站的数量由参数<code class="codeph">DBWR_IO_SLAVES</code>确定。</p>
                        <p><code class="codeph">DBWR_IO_SLAVES</code>适用于无法使用多个<code class="codeph">DB_WRITER_PROCESSES</code> （例如，您拥有单个CPU的情况）。当异步I / O不可用时，I / O从站也很有用，因为多个I / O从站通过释放DBWR来继续识别要写入的高速缓存中的块来模拟非阻塞的异步请求。通常首选操作系统级别的异步I / O（如果有）。
                        </p>
                        <p>在发出第一个I / O请求时，在数据库打开后立即分配DBWR I / O从站。除执行I / O外，DBWR继续执行所有与DBWR相关的工作。 I / O从站只代表DBWR执行I / O.批处理的写入在I / O从属之间并行化。</p>
                        <div class="infoboxnote" id="GUID-01C9C892-4C0B-4524-82B3-146D1C191BDD__GUID-91F2B2EE-C604-44E3-96FE-4684F614C220">
                           <p class="notep1">注意：</p>
                           <p>实现<code class="codeph">DBWR_IO_SLAVES</code>需要为I / O缓冲区和请求队列分配额外的共享内存。多个DBWR进程不能与I / O从站一起使用。配置I / O从站仅强制启动一个DBWR进程。
                           </p>
                        </div>
                        <p>当单个DBWR进程无法满足所需的工作负载时，配置多个DBWR进程可以提高性能。但是，在配置多个DBWR进程之前，请检查系统上是否可以使用和配置异步I / O.如果系统支持异步I / O但当前未使用，则启用异步I / O以查看是否可以缓解此问题。如果系统不支持异步I / O，或者配置了异步I / O且仍存在DBWR瓶颈，则配置多个DBWR进程。</p>
                        <div class="infoboxnote" id="GUID-01C9C892-4C0B-4524-82B3-146D1C191BDD__GUID-24125C74-66A9-4610-BE72-A743790C6E55">
                           <p class="notep1">注意：</p>
                           <p>如果您的平台上没有异步I / O，则可以通过将<code class="codeph">DISK_ASYNCH_IO</code>初始化参数设置为<code class="codeph">FALSE</code>来禁用异步I / O.</p>
                        </div>
                        <p>使用多个DBWR并行化缓冲区的收集和写入。因此，与具有相同数量的I / O从属的一个DBWR进程相比，多个DBW <span class="italic">n</span>进程应提供更多的吞吐量。出于这个原因，不推荐使用I / O从站，而是支持多个DBWR进程。仅当无法配置多个DBWR进程时，才应使用I / O从站。
                        </p>
                     </div>
                     <!-- class="section" -->
                  </div>
               </div><a id="TGDBA94515"></a><a id="TGDBA02415"></a><div class="props_rev_3"><a id="GUID-34B5BAAB-02ED-402E-877F-AFF7945C2A8F" name="GUID-34B5BAAB-02ED-402E-877F-AFF7945C2A8F"></a><h4 id="TGDBA-GUID-34B5BAAB-02ED-402E-877F-AFF7945C2A8F" class="sect4"><span class="enumeration_section">10.3.10</span>空闲等待事件</h4>
                  <div>
                     <p><a id="d25676e5214" class="indexterm-anchor"></a><a id="d25676e5218" class="indexterm-anchor"></a>这些事件属于Idle等待类，表示服务器进程正在等待，因为它没有工作。这通常意味着如果存在瓶颈，则瓶颈不适用于数据库资源。调整时应忽略大多数空闲事件，因为它们不表示性能瓶颈的性质。一些空闲事件可用于指示瓶颈不是什么。此类事件的一个示例是<code class="codeph">SQL Net message from client</code>最常遇到的空闲等待事件<code class="codeph">SQL Net message from client</code> 。<a href="instance-tuning-using-performance-views.html#GUID-34B5BAAB-02ED-402E-877F-AFF7945C2A8F__G43952" title="此表列出了空闲等待事件及其类别。">表10-2</a>中列出了此事件和其他空闲事件（及其类别）。
                     </p>
                     <div class="tblformalwide" id="GUID-34B5BAAB-02ED-402E-877F-AFF7945C2A8F__G43952">
                        <p class="titleintable">表10-2空闲等待事件</p>
                        <table cellpadding="4" cellspacing="0" class="FormalWide" title="空闲等待事件" width="100%" border="1" summary="This table lists the idle wait events and their categories." frame="hsides" rules="rows">
                           <thead>
                              <tr align="left" valign="top">
                                 <th align="left" valign="bottom" id="d25676e5243">等待名字</th>
                                 <th align="left" valign="bottom" id="d25676e5246">后台进程空闲事件</th>
                                 <th align="left" valign="bottom" id="d25676e5249">用户进程空闲事件</th>
                                 <th align="left" valign="bottom" id="d25676e5252">并行查询空闲事件</th>
                                 <th align="left" valign="bottom" id="d25676e5255">共享服务器空闲事件</th>
                                 <th align="left" valign="bottom" id="d25676e5258">Oracle Real Application Clusters空闲事件</th>
                              </tr>
                           </thead>
                           <tbody>
                              <tr align="left" valign="top">
                                 <td align="left" valign="top" id="d25676e5263" headers="d25676e5243 ">
                                    <p><code class="codeph">调度员计时器</code></p>
                                 </td>
                                 <td align="left" valign="top" headers="d25676e5263 d25676e5246 ">
                                    <p>。</p>
                                 </td>
                                 <td align="left" valign="top" headers="d25676e5263 d25676e5249 ">
                                    <p>。</p>
                                 </td>
                                 <td align="left" valign="top" headers="d25676e5263 d25676e5252 ">
                                    <p>。</p>
                                 </td>
                                 <td align="left" valign="top" headers="d25676e5263 d25676e5255 ">
                                    <p>X</p>
                                 </td>
                                 <td align="left" valign="top" headers="d25676e5263 d25676e5258 ">
                                    <p>。</p>
                                 </td>
                              </tr>
                              <tr align="left" valign="top">
                                 <td align="left" valign="top" id="d25676e5283" headers="d25676e5243 ">
                                    <p><code class="codeph">管道得到</code></p>
                                 </td>
                                 <td align="left" valign="top" headers="d25676e5283 d25676e5246 ">
                                    <p>。</p>
                                 </td>
                                 <td align="left" valign="top" headers="d25676e5283 d25676e5249 ">
                                    <p>X</p>
                                 </td>
                                 <td align="left" valign="top" headers="d25676e5283 d25676e5252 ">
                                    <p>。</p>
                                 </td>
                                 <td align="left" valign="top" headers="d25676e5283 d25676e5255 ">
                                    <p>。</p>
                                 </td>
                                 <td align="left" valign="top" headers="d25676e5283 d25676e5258 ">
                                    <p>。</p>
                                 </td>
                              </tr>
                              <tr align="left" valign="top">
                                 <td align="left" valign="top" id="d25676e5303" headers="d25676e5243 ">
                                    <p><code class="codeph">pmon计时器</code></p>
                                 </td>
                                 <td align="left" valign="top" headers="d25676e5303 d25676e5246 ">
                                    <p>X</p>
                                 </td>
                                 <td align="left" valign="top" headers="d25676e5303 d25676e5249 ">
                                    <p>。</p>
                                 </td>
                                 <td align="left" valign="top" headers="d25676e5303 d25676e5252 ">
                                    <p>。</p>
                                 </td>
                                 <td align="left" valign="top" headers="d25676e5303 d25676e5255 ">
                                    <p>。</p>
                                 </td>
                                 <td align="left" valign="top" headers="d25676e5303 d25676e5258 ">
                                    <p>。</p>
                                 </td>
                              </tr>
                              <tr align="left" valign="top">
                                 <td align="left" valign="top" id="d25676e5323" headers="d25676e5243 ">
                                    <p><code class="codeph">PX空闲等待</code></p>
                                 </td>
                                 <td align="left" valign="top" headers="d25676e5323 d25676e5246 ">
                                    <p>。</p>
                                 </td>
                                 <td align="left" valign="top" headers="d25676e5323 d25676e5249 ">
                                    <p>。</p>
                                 </td>
                                 <td align="left" valign="top" headers="d25676e5323 d25676e5252 ">
                                    <p>X</p>
                                 </td>
                                 <td align="left" valign="top" headers="d25676e5323 d25676e5255 ">
                                    <p>。</p>
                                 </td>
                                 <td align="left" valign="top" headers="d25676e5323 d25676e5258 ">
                                    <p>。</p>
                                 </td>
                              </tr>
                              <tr align="left" valign="top">
                                 <td align="left" valign="top" id="d25676e5343" headers="d25676e5243 ">
                                    <p><code class="codeph">PX Deq Credit：需要缓冲</code></p>
                                 </td>
                                 <td align="left" valign="top" headers="d25676e5343 d25676e5246 ">
                                    <p>。</p>
                                 </td>
                                 <td align="left" valign="top" headers="d25676e5343 d25676e5249 ">
                                    <p>。</p>
                                 </td>
                                 <td align="left" valign="top" headers="d25676e5343 d25676e5252 ">
                                    <p>X</p>
                                 </td>
                                 <td align="left" valign="top" headers="d25676e5343 d25676e5255 ">
                                    <p>。</p>
                                 </td>
                                 <td align="left" valign="top" headers="d25676e5343 d25676e5258 ">
                                    <p>。</p>
                                 </td>
                              </tr>
                              <tr align="left" valign="top">
                                 <td align="left" valign="top" id="d25676e5363" headers="d25676e5243 ">
                                    <p><code class="codeph">rdbms ipc消息</code></p>
                                 </td>
                                 <td align="left" valign="top" headers="d25676e5363 d25676e5246 ">
                                    <p>X</p>
                                 </td>
                                 <td align="left" valign="top" headers="d25676e5363 d25676e5249 ">
                                    <p>。</p>
                                 </td>
                                 <td align="left" valign="top" headers="d25676e5363 d25676e5252 ">
                                    <p>。</p>
                                 </td>
                                 <td align="left" valign="top" headers="d25676e5363 d25676e5255 ">
                                    <p>。</p>
                                 </td>
                                 <td align="left" valign="top" headers="d25676e5363 d25676e5258 ">
                                    <p>。</p>
                                 </td>
                              </tr>
                              <tr align="left" valign="top">
                                 <td align="left" valign="top" id="d25676e5383" headers="d25676e5243 ">
                                    <p><code class="codeph">共享服务器空闲等待</code></p>
                                 </td>
                                 <td align="left" valign="top" headers="d25676e5383 d25676e5246 ">
                                    <p>。</p>
                                 </td>
                                 <td align="left" valign="top" headers="d25676e5383 d25676e5249 ">
                                    <p>。</p>
                                 </td>
                                 <td align="left" valign="top" headers="d25676e5383 d25676e5252 ">
                                    <p>。</p>
                                 </td>
                                 <td align="left" valign="top" headers="d25676e5383 d25676e5255 ">
                                    <p>X</p>
                                 </td>
                                 <td align="left" valign="top" headers="d25676e5383 d25676e5258 ">
                                    <p>。</p>
                                 </td>
                              </tr>
                              <tr align="left" valign="top">
                                 <td align="left" valign="top" id="d25676e5403" headers="d25676e5243 ">
                                    <p><code class="codeph">smon计时器</code></p>
                                 </td>
                                 <td align="left" valign="top" headers="d25676e5403 d25676e5246 ">
                                    <p>X</p>
                                 </td>
                                 <td align="left" valign="top" headers="d25676e5403 d25676e5249 ">
                                    <p>。</p>
                                 </td>
                                 <td align="left" valign="top" headers="d25676e5403 d25676e5252 ">
                                    <p>。</p>
                                 </td>
                                 <td align="left" valign="top" headers="d25676e5403 d25676e5255 ">
                                    <p>。</p>
                                 </td>
                                 <td align="left" valign="top" headers="d25676e5403 d25676e5258 ">
                                    <p>。</p>
                                 </td>
                              </tr>
                              <tr align="left" valign="top">
                                 <td align="left" valign="top" id="d25676e5423" headers="d25676e5243 ">
                                    <p><code class="codeph">来自客户端的SQL * Net消息</code></p>
                                 </td>
                                 <td align="left" valign="top" headers="d25676e5423 d25676e5246 ">
                                    <p>。</p>
                                 </td>
                                 <td align="left" valign="top" headers="d25676e5423 d25676e5249 ">
                                    <p>X</p>
                                 </td>
                                 <td align="left" valign="top" headers="d25676e5423 d25676e5252 ">
                                    <p>。</p>
                                 </td>
                                 <td align="left" valign="top" headers="d25676e5423 d25676e5255 ">
                                    <p>。</p>
                                 </td>
                                 <td align="left" valign="top" headers="d25676e5423 d25676e5258 ">
                                    <p>。</p>
                                 </td>
                              </tr>
                           </tbody>
                        </table>
                     </div>
                     <!-- class="inftblhruleinformal" -->
                     <div class="infoboxnotealso" id="GUID-34B5BAAB-02ED-402E-877F-AFF7945C2A8F__GUID-0825CBB6-A718-4E44-B865-1699DE702314">
                        <p class="notep1">也可以看看：</p>
                        <p><a href="../refrn/descriptions-of-wait-events.html#REFRN-GUID-2FDDFAA4-24D0-4B80-A157-A907AF5C68E2" target="_blank"><span class="italic">Oracle数据库参考，</span></a>用于解释每个空闲等待事件</p>
                     </div>
                  </div>
               </div><a id="TGDBA94519"></a><a id="TGDBA94516"></a><div class="props_rev_3"><a id="GUID-64F78817-8B4C-4392-B518-CA31CF728B69" name="GUID-64F78817-8B4C-4392-B518-CA31CF728B69"></a><h4 id="TGDBA-GUID-64F78817-8B4C-4392-B518-CA31CF728B69" class="sect4"><span class="enumeration_section">10.3.11</span>锁存事件</h4>
                  <div>
                     <p>锁存器是Oracle数据库用于保护内存结构的低级内部锁。当服务器进程尝试获取锁存器时更新无锁存器事件，并且在第一次尝试时锁存器不可用。</p>
                     <p>对于更常用的锁存器，存在专用的与锁存器相关的等待事件，这通常会产生显着的争用。对于这些事件，锁存器的名称出现在等待事件的名称中，例如<code class="codeph">latch:</code> <code class="codeph">library</code> <code class="codeph">cache</code>或<code class="codeph">latch:</code> <code class="codeph">cache</code> <code class="codeph">buffers</code> <code class="codeph">chains</code> 。这使您能够快速确定特定类型的锁存器是否与大多数与锁存器相关的争用负责。等待所有其他锁存器被分组在通用<code class="codeph">latch</code> <code class="codeph">free</code>等待事件中。
                     </p>
                     <div class="infoboxnotealso" id="GUID-64F78817-8B4C-4392-B518-CA31CF728B69__GUID-4D74F9B8-0177-4459-8184-BF7E4CFED397">
                        <p class="notep1">也可以看看：</p>
                        <p>有关锁存器和内部锁的更多信息，请参见<a href="../cncpt/data-concurrency-and-consistency.html#CNCPT-GUID-E926E638-0161-4389-887B-4A31A529478A" target="_blank"><span class="italic">Oracle数据库概念</span></a></p>
                     </div>
                     <div class="section">
                        <p class="subhead3" id="GUID-64F78817-8B4C-4392-B518-CA31CF728B69__GUID-192BAFA1-F8FC-4964-A7C2-6B8CD9B78025">操作</p>
                        <p>如果锁定等待是整个系统等待时间的重要部分，或者遇到问题的个别用户，则此事件应该只是一个问题。</p>
                        <ul style="list-style-type:disc">
                           <li>
                              <p>检查相关资源的资源使用情况。例如，如果<a id="d25676e5585" class="indexterm-anchor"></a><a id="d25676e5589" class="indexterm-anchor"></a>库高速缓存锁存器是非常争用的，然后检查硬解决方案和软解析速率。
                              </p>
                           </li>
                           <li>
                              <p>检查经历闩锁争用的会话的SQL语句，以查看是否存在任何共性。</p>
                           </li>
                        </ul>
                        <p>检查以下<code class="codeph">V$SESSION_WAIT</code>参数列：</p>
                        <ul style="list-style-type:disc">
                           <li>
                              <p><code class="codeph">P1</code> ：锁存器的地址</p>
                           </li>
                           <li>
                              <p><code class="codeph">P2</code> ：锁存号码</p>
                           </li>
                           <li>
                              <p><code class="codeph">P3</code> ：进程已经睡眠的次数，等待锁存器</p>
                           </li>
                        </ul>
                     </div>
                     <!-- class="section" -->
                     <div class="section">
                        <p class="subhead3" id="GUID-64F78817-8B4C-4392-B518-CA31CF728B69__GUID-460BB349-BF91-4A37-9945-A2F3EC4AD427">示例：查找当前等待的锁存器</p><pre class="oac_no_warn" dir="ltr">SELECT EVENT，SUM（P3）SLEEPS，SUM（SECONDS_IN_WAIT）SECONDS_IN_WAIT来自V $ SESSION_WAIT，其中的事件类似'latch％'GROUP BY EVENT;</pre><p>上一个查询的一个问题是它比实例或长时间实例调优更多地讲述了会话调优或即时实例调优。</p>
                        <p>以下查询提供了有关长持续时间实例调整的更多信息，显示了在整个数据库时间内latch等待是否显着。</p><pre class="oac_no_warn" dir="ltr">SELECT EVENT，TIME_WAITED_MICRO，ROUND（TIME_WAITED_MICRO * 100 / S.DBTIME，1）PCT_DB_TIME FROM V $ SYSTEM_EVENT，（SELECT VALUE DBTIME FROM V $ SYS_TIME_MODEL WHERE STAT_NAME ='DB time'）S事件类似'latch％'ORDER BY PCT_DB_TIME ASC;</pre><p>不特定于latch等待的更一般的查询如下：</p><pre class="oac_no_warn" dir="ltr">SELECT EVENT，WAIT_CLASS，TIME_WAITED_MICRO，ROUND（TIME_WAITED_MICRO * 100 / S.DBTIME，1）PCT_DB_TIME FROM V $ SYSTEM_EVENT E，V $ EVENT_NAME N，（SELECT VALUE DBTIME FROM V $ SYS_TIME_MODEL WHERE STAT_NAME ='DB time'）S WHERE E .EVENT_ID = N.EVENT_ID和N.WAIT_CLASS NOT IN（'空闲'，'系统I / O'）按PCT_DB_TIME ASC排序;</pre><div class="tblformalwide" id="GUID-64F78817-8B4C-4392-B518-CA31CF728B69__GUID-263F4596-E79D-4A75-8CF4-9831AB0C6941">
                           <p class="titleintable">表10-3锁存等待事件</p>
                           <table cellpadding="4" cellspacing="0" class="FormalWide" title="闩锁等待事件" width="100%" border="1" summary="This table describes wait latch events. It names the latch and the SGA area it affects, and provides causes and symptoms of the event." frame="hsides" rules="rows">
                              <thead>
                                 <tr align="left" valign="top">
                                    <th align="left" valign="bottom" id="d25676e5645">闩</th>
                                    <th align="left" valign="bottom" id="d25676e5648">SGA区域</th>
                                    <th align="left" valign="bottom" id="d25676e5651">可能的原因</th>
                                    <th align="left" valign="bottom" id="d25676e5654">寻找：</th>
                                 </tr>
                              </thead>
                              <tbody>
                                 <tr align="left" valign="top">
                                    <td align="left" valign="top" id="d25676e5659" headers="d25676e5645 ">
                                       <p>共享池，库缓存</p>
                                    </td>
                                    <td align="left" valign="top" headers="d25676e5659 d25676e5648 ">
                                       <p>共享池</p>
                                    </td>
                                    <td align="left" valign="top" headers="d25676e5659 d25676e5651 ">
                                       <p>缺乏语句重用</p>
                                       <p>不使用绑定变量的语句</p>
                                       <p>应用程序游标缓存的大小不足</p>
                                       <p>每次执行后游标都会显式关闭</p>
                                       <p>经常登录和注销</p>
                                       <p>正在修改的基础对象结构（例如截断）</p>
                                       <p>共享池太小了</p>
                                    </td>
                                    <td align="left" valign="top" headers="d25676e5659 d25676e5654 ">
                                       <p>会话（在<code class="codeph">V$SESSTAT</code> ）高：</p>
                                       <ul style="list-style-type:disc">
                                          <li>
                                             <p><code class="codeph">解析时间CPU</code></p>
                                          </li>
                                          <li>
                                             <p><code class="codeph">parse</code> <code class="codeph">time</code> <code class="codeph">elapse</code></p>
                                          </li>
                                          <li>
                                             <p>的比例<code class="codeph">parse count (hard)</code> / <code class="codeph">execute</code> <code class="codeph">coun</code> ŧ</p>
                                          </li>
                                          <li>
                                             <p><code class="codeph">parse count (total)</code> / <code class="codeph">execute</code> <code class="codeph">count</code>比率</p>
                                          </li>
                                       </ul>
                                       <p>游标（在<code class="codeph">V$SQLAREA</code> / <code class="codeph">V$SQLSTATS</code> ）：</p>
                                       <ul style="list-style-type:disc">
                                          <li>
                                             <p><code class="codeph">PARSE_CALLS</code> / <code class="codeph">EXECUTIONS</code>比例高</p>
                                          </li>
                                          <li>
                                             <p><code class="codeph">EXECUTIONS</code> = 1仅在<code class="codeph">WHERE</code>子句中的文字中有所不同（即，不使用绑定变量）</p>
                                          </li>
                                          <li>
                                             <p>高<code class="codeph">RELOADS</code></p>
                                          </li>
                                          <li>
                                             <p>高度<code class="codeph">INVALIDATIONS</code></p>
                                          </li>
                                          <li>
                                             <p>大（&gt; 1mb） <code class="codeph">SHARABLE_MEM</code></p>
                                          </li>
                                       </ul>
                                    </td>
                                 </tr>
                                 <tr align="left" valign="top">
                                    <td align="left" valign="top" id="d25676e5766" headers="d25676e5645 ">
                                       <p>缓存缓冲区lru链</p>
                                    </td>
                                    <td align="left" valign="top" headers="d25676e5766 d25676e5648 ">
                                       <p>缓冲区缓存LRU列表</p>
                                    </td>
                                    <td align="left" valign="top" headers="d25676e5766 d25676e5651 ">
                                       <p>过多<a id="d25676e5775" class="indexterm-anchor"></a>缓冲区缓存吞吐量例如，迭代访问不正确索引的低效SQL（大索引范围扫描）或许多全表扫描</p>
                                       <p>DBWR无法跟上肮脏的工作量;因此，前台进程花费更长时间来保持锁存器寻找空闲缓冲区</p>
                                       <p>缓存可能太小</p>
                                    </td>
                                    <td align="left" valign="top" headers="d25676e5766 d25676e5654 ">
                                       <p>具有非常高的逻辑I / O或物理I / O的语句，使用非选择性索引</p>
                                    </td>
                                 </tr>
                                 <tr align="left" valign="top">
                                    <td align="left" valign="top" id="d25676e5788" headers="d25676e5645 ">
                                       <p>缓存缓冲链</p>
                                    </td>
                                    <td align="left" valign="top" headers="d25676e5788 d25676e5648 ">
                                       <p>缓冲缓存缓冲区</p>
                                    </td>
                                    <td align="left" valign="top" headers="d25676e5788 d25676e5651 ">
                                       <p>重复访问块（或少量块），称为热块</p>
                                    </td>
                                    <td align="left" valign="top" headers="d25676e5788 d25676e5654 ">
                                       <p>序列号生成代码，用于更新表中的行以生成数字，而不是使用序列号生成器</p>
                                       <p>索引叶子从非常多的进程中追逐，扫描具有非常相似的谓词的相同的非选择性索引</p>
                                       <p>识别热块所属的段</p>
                                    </td>
                                 </tr>
                                 <tr align="left" valign="top">
                                    <td align="left" valign="top" id="d25676e5805" headers="d25676e5645 ">
                                       <p>行缓存对象</p>
                                    </td>
                                    <td align="left" valign="top" headers="d25676e5805 d25676e5648 "> </td>
                                    <td align="left" valign="top" headers="d25676e5805 d25676e5651 "> </td>
                                    <td align="left" valign="top" headers="d25676e5805 d25676e5654 "> </td>
                                 </tr>
                              </tbody>
                           </table>
                        </div>
                        <!-- class="inftblhruleinformal" -->
                     </div>
                     <!-- class="section" -->
                     <div class="section">
                        <p class="subhead3" id="GUID-64F78817-8B4C-4392-B518-CA31CF728B69__GUID-5874DDE2-DE5D-41D6-821F-73629E87C07F">共享池和库高速缓存锁存争用</p>
                        <p>共享池或库高速缓存锁存器争用的主要原因是解析。有几种技术可用于识别不必要的解析和几种不必要的解析：</p>
                        <p>如果文字被绑定变量替换，则此方法标识可以共享的类似SQL语句。这个想法是：</p>
                        <ul style="list-style-type:disc">
                           <li>
                              <p>手动检查只有一次执行的SQL语句，看它们是否相似：</p><pre class="oac_no_warn" dir="ltr">SELECT SQL_TEXT FROM V $ SQLSTATS WHERE EXECUTIONS &lt;4 ORDER BY SQL_TEXT;</pre></li>
                           <li>
                              <p>或者，通过对可能类似的语句进行分组来自动执行此过程。估计可能相同的SQL语句的字节数，并按此字节数对SQL语句进行分组。例如，以下示例将仅在前60个字节之后不同的语句分组。</p><pre class="oac_no_warn" dir="ltr">SELECT SUBSTR（SQL_TEXT，1,60），COUNT（*）FROM V $ SQLSTATS WHERE EXECUTIONS &lt;4 GROUP BY SUBSTR（SQL_TEXT，1,60）COUNT（*）&gt; 1;</pre></li>
                           <li>
                              <p>或报告具有相同执行计划的不同SQL语句。以下查询选择至少共享四次共享相同执行计划的不同SQL语句。这些SQL语句可能使用文字而不是绑定变量。</p><pre class="oac_no_warn" dir="ltr">SELECT SQL_TEXT FROM V $ SQLSTATS WHERE PLAN_HASH_VALUE IN（从PLAN $ HASH_VALUE中选择PLAN_HASH_VALUE到具有COUNT（*）&gt; 4的PLAN_HASH_VALUE）按PLAN_HASH_VALUE排序;</pre></li>
                        </ul>
                        <p>检查<code class="codeph">V$SQLSTATS</code>视图。输入以下查询：</p><pre class="oac_no_warn" dir="ltr">SELECT SQL_TEXT，PARSE_CALLS，EXECUTIONS FROM V $ SQLSTATS ORDER BY PARSE_CALLS;</pre><p>当<code class="codeph">PARSE_CALLS</code>值接近给定语句的<code class="codeph">EXECUTIONS</code>值时，您可能会不断地重新声明该语句。使用较多的解析调用来调整语句。
                        </p>
                        <p>通过识别发生它们的会话来识别不必要的解析调用。可能是特定批处理程序或某些类型的应用程序执行大部分解析。要实现此目标，请运行以下查询：</p><pre class="oac_no_warn" dir="ltr">选择pa。SID，pa。值得“硬解析”，例如。VALUE“执行计数”来自V $ SESSTAT pa，V $ SESSTAT ex WHERE pa。SID = ex。SID和pa。STATISTIC＃=（SELECT STATISTIC＃FROM V $ STATNAME WHERE NAME ='parse count（hard）'）和ex。STATISTIC＃=（SELECT STATISTIC＃FROM V $ STATNAME WHERE NAME ='execute count'）AND pa。VALUE&gt; 0;</pre><p>结果是所有会话的列表以及它们执行的重新分析的数量。对于每个会话标识符（SID），请转到<code class="codeph">V$SESSION</code>以查找导致重新分析的程序的名称。
                        </p>
                        <div class="infoboxnote" id="GUID-64F78817-8B4C-4392-B518-CA31CF728B69__GUID-B4AB2DD4-3E7D-425A-B666-79273F3BC168">
                           <p class="notep1">注意：</p>
                           <p>因为此查询计算自实例启动以来的所有解析调用，所以最好查找具有高解析<span class="italic">率</span>的会话。例如，已连续50天的连接可能会显示一个高解析数字，但第二个连接可能已经持续了10分钟并且以更快的速度进行解析。
                           </p>
                        </div>
                        <p>输出类似于以下内容：</p><pre class="oac_no_warn" dir="ltr">SID Hard Parses Execute Count ------ ----------- ------------- 7 1 20 8 3 12690 6 26 325 11 84 1619</pre><p><code class="codeph">cache</code> <code class="codeph">buffers</code> <code class="codeph">lru</code> <code class="codeph">chain</code> <code class="codeph">lru</code>器保护<code class="codeph">cache</code> <code class="codeph">buffers</code>列表。从列表中添加，移动或删除缓冲区时，必须获取锁存器。
                        </p>
                        <p>对于对称多处理器（SMP）系统，Oracle数据库会自动将LRU锁存器的数量设置为等于系统上CPU数量的一半的值。对于非SMP系统，一个LRU锁存器就足够了。</p>
                        <p>争夺<a id="d25676e5887" class="indexterm-anchor"></a> LRU锁存器可能会阻碍具有大量CPU的SMP计算机的性能。通过查询<code class="codeph">V$LATCH</code> ， <code class="codeph">V$SESSION_EVENT</code>和<code class="codeph">V$SYSTEM_EVENT</code>来检测LRU锁存器争用。为避免争用，请考虑调整应用程序，绕过DSS作业的缓冲区缓存或重新设计应用程序。
                        </p>
                        <p><code class="codeph">cache</code> <code class="codeph">buffers</code> <code class="codeph">chains</code>存器用于保护缓冲区缓存中的缓冲区列表。从缓冲区高速缓存中搜索，添加或删除缓冲区时使用这些锁存器。对此锁存器的争用通常意味着存在极大争用的块（称为热块）。
                        </p>
                        <p>要识别频繁访问的缓冲区链，从而识别阻塞块，请使用视图<code class="codeph">V$LATCH_CHILDREN</code>查看<code class="codeph">cache</code> <code class="codeph">buffers</code> <code class="codeph">chains</code> <code class="codeph">V$LATCH_CHILDREN</code>器的锁存器统计信息。如果存在特定的<code class="codeph">cache</code> <code class="codeph">buffers</code> <code class="codeph">chains</code>锁存器，当与其他子锁存器相比时，其具有更多的<code class="codeph">GETS</code> ， <code class="codeph">MISSES</code>和<code class="codeph">SLEEPS</code> ，则这是针对子锁存器的争用。
                        </p>
                        <p>该锁存器具有存储器地址，由<code class="codeph">ADDR</code>列标识。使用与<code class="codeph">X$BH</code>表连接的<code class="codeph">ADDR</code>列中的值来标识受此锁存器保护的块。例如，给定一个严重竞争的锁存器的地址（ <code class="codeph">V$LATCH_CHILDREN.ADDR</code> ），这将查询文件和块号：</p><pre class="oac_no_warn" dir="ltr">SELECT OBJ data_object_id，FILE＃，DBABLK，CLASS，STATE，TCH FROM X $ BH WHERE HLADDR ='latch的地址'ORDER BY TCH;</pre><p><code class="codeph">X$BH.TCH</code>是缓冲区的触摸计数。<code class="codeph">X$BH.TCH</code>高值表示热块。
                        </p>
                        <p>每个锁存器都保护许多块。其中一个缓冲区可能是热块。任何具有高<code class="codeph">TCH</code>值的块都是潜在的热块。多次执行此查询，并标识始终显示在输出中的块。识别出热块后，使用文件编号和块编号查询<code class="codeph">DBA_EXTENTS</code> ，以识别该段。
                        </p>
                        <p>识别出热块后，可以使用以下查询识别它所属的段：</p><pre class="oac_no_warn" dir="ltr">SELECT OBJECT_NAME，SUBOBJECT_NAME FROM DBA_OBJECTS WHERE DATA_OBJECT_ID =＆obj;</pre><p>在查询中， <code class="codeph">&amp;obj</code>是<code class="codeph">X$BH</code>上一个查询中<code class="codeph">OBJ</code>列的值。</p>
                        <p><code class="codeph">row</code> <code class="codeph">cache</code> <code class="codeph">objects</code>锁存器保护数据字典。
                        </p>
                     </div>
                     <!-- class="section" -->
                  </div>
               </div><a id="TGDBA94527"></a><div class="props_rev_3"><a id="GUID-F09EF4C8-7128-4B1B-ADD6-C3D4BC547325" name="GUID-F09EF4C8-7128-4B1B-ADD6-C3D4BC547325"></a><h4 id="TGDBA-GUID-F09EF4C8-7128-4B1B-ADD6-C3D4BC547325" class="sect4"><span class="enumeration_section">10。3。12</span>日志文件并行写入</h4>
                  <div>
                     <p>此事件涉及将重做记录从日志缓冲区写入重做日志文件。</p>
                  </div>
               </div><a id="TGDBA94528"></a><div class="props_rev_3"><a id="GUID-FE902A76-E4D8-4A74-9CDF-E15A01D568F0" name="GUID-FE902A76-E4D8-4A74-9CDF-E15A01D568F0"></a><h4 id="TGDBA-GUID-FE902A76-E4D8-4A74-9CDF-E15A01D568F0" class="sect4"><span class="enumeration_section">10.3.13</span>库缓存引脚</h4>
                  <div>
                     <p>此事件管理库缓存并发。固定对象会导致堆加载到内存中。如果客户端想要修改或检查对象，则客户端必须在锁定后获取引脚。</p>
                  </div>
               </div><a id="TGDBA94529"></a><div class="props_rev_3"><a id="GUID-1A8EE470-1630-458F-9065-91E671318393" name="GUID-1A8EE470-1630-458F-9065-91E671318393"></a><h4 id="TGDBA-GUID-1A8EE470-1630-458F-9065-91E671318393" class="sect4"><span class="enumeration_section">10.3.14</span>库缓存锁定</h4>
                  <div>
                     <p>此事件控制库高速缓存的客户端之间的并发性。它获取对象句柄的锁定，以便：</p>
                     <ul style="list-style-type:disc">
                        <li>
                           <p>一个客户端可以阻止其他客户端访问同一个对象</p>
                        </li>
                        <li>
                           <p>客户端可以长时间保持依赖关系，这不允许其他客户端更改对象</p>
                        </li>
                     </ul>
                     <p>获取此锁定以在库高速缓存中定位对象。</p>
                  </div>
               </div><a id="TGDBA94531"></a><a id="TGDBA94530"></a><div class="props_rev_3"><a id="GUID-F5DD71ED-8BB0-43B5-9EBC-D9B1A040254D" name="GUID-F5DD71ED-8BB0-43B5-9EBC-D9B1A040254D"></a><h4 id="TGDBA-GUID-F5DD71ED-8BB0-43B5-9EBC-D9B1A040254D" class="sect4"><span class="enumeration_section">10。3。15</span>日志缓冲区空间</h4>
                  <div>
                     <p>当服务器进程正在等待日志缓冲区中的可用空间时，会发生此事件，因为所有重做的生成速度都比LGWR可以写出来的速度快。</p>
                     <div class="section">
                        <p class="subhead3" id="GUID-F5DD71ED-8BB0-43B5-9EBC-D9B1A040254D__GUID-91E97DD2-BDCD-4EEB-8D7A-4E4A2E426744">操作</p>
                     </div>
                     <!-- class="section" -->
                     <div class="section">
                        <p>修改<a id="d25676e6257" class="indexterm-anchor"></a>重做日志缓冲区大小。如果日志缓冲区的大小合理，则确保联机重做日志所在的磁盘不会受到影响<a id="d25676e6262" class="indexterm-anchor"></a> I / O争用。<code class="codeph">log</code> <code class="codeph">buffer</code> <code class="codeph">space</code>等待事件可能表示重做日志所在磁盘上的磁盘I / O争用，或者日志缓冲区太小。检查包含重做日志的磁盘的I / O配置文件，以调查I / O系统是否是瓶颈。如果I / O系统不是问题，那么重做日志缓冲区可能太小。增加重做日志缓冲区的大小，直到此事件不再重要。
                        </p>
                     </div>
                     <!-- class="section" -->
                  </div>
               </div><a id="TGDBA94532"></a><div class="props_rev_3"><a id="GUID-9963829C-6A58-44D3-BB3D-630DFEBC7FBF" name="GUID-9963829C-6A58-44D3-BB3D-630DFEBC7FBF"></a><h4 id="TGDBA-GUID-9963829C-6A58-44D3-BB3D-630DFEBC7FBF" class="sect4"><span class="enumeration_section">10。3。16</span>日志文件切换</h4>
                  <div>
                     <p>通常遇到两个等待事件：</p>
                     <ul style="list-style-type:disc">
                        <li>
                           <p>日志文件切换（需要存档）</p>
                        </li>
                        <li>
                           <p>日志文件切换（检查点不完整）</p>
                        </li>
                     </ul>
                     <p>在这两个事件中，LGWR无法切换到下一个联机重做日志文件。所有提交请求都等待此事件。</p>
                     <div class="section">
                        <p class="subhead3" id="GUID-9963829C-6A58-44D3-BB3D-630DFEBC7FBF__GUID-3071F786-564E-4B3E-80F6-C1F0669D45D7">操作</p>
                        <p>对于<code class="codeph">log</code> <code class="codeph">file</code> <code class="codeph">switch</code> （ <code class="codeph">needed</code> <code class="codeph">archiving</code> ）事件，请检查归档程序无法及时归档日志的原因。可能是由于以下原因：</p>
                        <ul style="list-style-type:disc">
                           <li>
                              <p>存档目标正在耗尽可用空间。</p>
                           </li>
                           <li>
                              <p>Archiver无法足够快地读取重做日志（与LGWR争用）。</p>
                           </li>
                           <li>
                              <p>Archiver无法足够快地写入（在归档目标上进行争用，或者没有足够的ARCH进程）。如果排除了其他可能性（例如慢速磁盘或完整归档目标），请考虑增加ARCn进程的数量。默认值为2。</p>
                           </li>
                           <li>
                              <p>如果您具有必需的远程传送存档日志，请检查此过程是否由于网络延迟而减慢，或者由于错误而导致写入未完成。</p>
                           </li>
                        </ul>
                        <p>根据瓶颈的性质，您可能需要重新分配I / O或向归档目标添加更多空间以缓解此问题。对于<code class="codeph">log</code> <code class="codeph">file</code> <code class="codeph">switch</code> （ <code class="codeph">checkpoint</code> <code class="codeph">incomplete</code> ）事件：</p>
                        <ul style="list-style-type:disc">
                           <li>
                              <p>检查DBWR是否缓慢，可能是由于I / O系统过载或缓慢。检查DBWR写入时间，检查I / O系统，并在必要时分配I / O.</p>
                           </li>
                           <li>
                              <p>检查重做日志是否太少或太小。如果您有一些重做日志或小的重做日志（例如，2 x 100k日志），并且您的系统产生足够的重做以在DBWR能够完成检查点之前遍历所有日志，那么增加大小或数量重做日志。</p>
                           </li>
                        </ul>
                     </div>
                     <!-- class="section" -->
                  </div>
               </div><a id="TGDBA94535"></a><a id="TGDBA94534"></a><div class="props_rev_3"><a id="GUID-38040CE0-704E-433B-8E08-29EB16C109F0" name="GUID-38040CE0-704E-433B-8E08-29EB16C109F0"></a><h4 id="TGDBA-GUID-38040CE0-704E-433B-8E08-29EB16C109F0" class="sect4"><span class="enumeration_section">10。3。17</span>日志文件同步</h4>
                  <div>
                     <p>当用户会话提交（或回滚）时，必须将会话的重做信息刷新到LGWR的重做日志文件中。执行<code class="codeph">COMMIT</code>或<code class="codeph">ROLLBACK</code>的服务器进程在此事件下等待写入重做日志以完成。
                     </p>
                     <div class="section">
                        <p class="subhead3" id="GUID-38040CE0-704E-433B-8E08-29EB16C109F0__GUID-940C2D77-36C6-4247-8B60-0A1792C3A1AE">操作</p>
                     </div>
                     <!-- class="section" -->
                     <div class="section">
                        <p>如果此事件的等待构成对系统的重大等待或者遇到响应时间问题的用户或系统等待的大量时间，则检查等待的平均时间。</p>
                        <p>如果等待的平均时间很短，但是等待的数量很高，则应用程序可能在每次<code class="codeph">INSERT</code>之后提交，而不是批处理<code class="codeph">COMMIT</code> 。应用程序可以通过提交50行而不是每行来减少等待。
                        </p>
                        <p>如果等待的平均时间很长，那么检查会话是否等待日志写入器，看看它花费大部分时间做什么等待。如果等待是因为I / O缓慢，请尝试以下操作：</p>
                        <ul style="list-style-type:disc">
                           <li>
                              <p>减少包含重做日志的磁盘上的其他I / O活动，或使用专用磁盘。</p>
                           </li>
                           <li>
                              <p>备用重做日志记录在不同的磁盘上，以最大限度地减少归档程序对日志写入程序的影响。</p>
                           </li>
                           <li>
                              <p>将重做日志移动到更快的磁盘或更快的I / O子系统（例如，从RAID 5切换到RAID 1）。</p>
                           </li>
                           <li>
                              <p>考虑使用原始设备（或磁盘供应商提供的模拟原始设备）来加速写入。</p>
                           </li>
                           <li>
                              <p>根据应用程序的类型，可以通过提交每<span class="italic">N</span>行而不是每行来批量<code class="codeph">COMMIT</code> ，以便需要更少的日志文件同步。
                              </p>
                           </li>
                        </ul>
                     </div>
                     <!-- class="section" -->
                  </div>
               </div><a id="TGDBA94536"></a><div class="props_rev_3"><a id="GUID-B085C235-45A2-49A8-97B8-A7FD433DC0C5" name="GUID-B085C235-45A2-49A8-97B8-A7FD433DC0C5"></a><h4 id="TGDBA-GUID-B085C235-45A2-49A8-97B8-A7FD433DC0C5" class="sect4"><span class="enumeration_section">10.3.18</span> rdbms ipc回复</h4>
                  <div>
                     <p>此事件用于等待其中一个后台进程的回复。</p>
                  </div>
               </div><a id="TGDBA94537"></a><div class="props_rev_3"><a id="GUID-2EAAF006-0954-4E83-871F-D9E67D7CC4AD" name="GUID-2EAAF006-0954-4E83-871F-D9E67D7CC4AD"></a><h4 id="TGDBA-GUID-2EAAF006-0954-4E83-871F-D9E67D7CC4AD" class="sect4"><span class="enumeration_section">10.3.19</span> SQL * Net事件</h4>
                  <div>
                     <p><a id="d25676e6637" class="indexterm-anchor"></a><a id="d25676e6639" class="indexterm-anchor"></a>以下事件表示数据库进程正在等待来自数据库链接或客户端进程的确认：</p>
                     <ul style="list-style-type:disc">
                        <li>
                           <p><code class="codeph">SQL * Net break / reset to client</code></p>
                        </li>
                        <li>
                           <p><code class="codeph">SQL * Net break / reset to dblink</code></p>
                        </li>
                        <li>
                           <p><code class="codeph">来自客户端的SQL * Net消息</code></p>
                        </li>
                        <li>
                           <p><code class="codeph">来自dblink的SQL * Net消息</code></p>
                        </li>
                        <li>
                           <p><code class="codeph">SQL * Net消息到客户端</code></p>
                        </li>
                        <li>
                           <p><code class="codeph">SQL * Net消息到dblink</code></p>
                        </li>
                        <li>
                           <p><code class="codeph">SQL * Net来自客户端的更多数据</code></p>
                        </li>
                        <li>
                           <p><code class="codeph">SQL * Net来自dblink的更多数据</code></p>
                        </li>
                        <li>
                           <p><code class="codeph">SQL * Net向客户端提供更多数据</code></p>
                        </li>
                        <li>
                           <p><code class="codeph">SQL * Net更多数据到dblink</code></p>
                        </li>
                     </ul>
                     <p>如果这些等待构成了系统上等待时间的很大一部分或者是遇到响应时间问题的用户，则网络或中间层可能成为瓶颈。</p>
                     <p>作为事件描述的事件是客户端的相关应诊断<code class="codeph">SQL*Net</code> <code class="codeph">message</code> <code class="codeph">from</code> <code class="codeph">client</code> 。作为事件描述的事件是dblink的相关应诊断<code class="codeph">SQL*Net</code> <code class="codeph">message</code> <code class="codeph">from</code> <code class="codeph">dblink</code> 。
                     </p>
                     <div class="section" id="GUID-2EAAF006-0954-4E83-871F-D9E67D7CC4AD__SQLNETMESSAGEFROMCLIENTIDLEWAITEVEN-F951261D">
                        <p class="subhead3" id="GUID-2EAAF006-0954-4E83-871F-D9E67D7CC4AD__GUID-C099E728-0DD1-4909-8B08-B091BD8353DE">来自客户端的SQL * Net消息</p>
                        <p>虽然这是一个空闲事件，但重要的是要解释何时可以使用此事件来诊断哪些不是问题。此事件表示服务器进程正在等待客户端进程的工作。但是，在某些情况下，如果用户遇到响应时间较短，则此事件可能会占用大部分等待时间。原因可能是网络瓶颈或客户端进程的资源瓶颈。</p>
                        <p>如果应用程序在服务器和客户端之间导致大量流量并且网络延迟（往返时间）很高，则可能发生网络瓶颈。症状包括以下内容：</p>
                        <ul style="list-style-type:disc">
                           <li>
                              <p>大量的等待此事件</p>
                           </li>
                           <li>
                              <p>数据库和客户端进程在大多数情况下都处于空闲状态（等待网络流量）</p>
                           </li>
                        </ul>
                        <p>要缓解网络瓶颈，请尝试以下操作：</p>
                        <ul style="list-style-type:disc">
                           <li>
                              <p>调整应用程序以减少往返次数。</p>
                           </li>
                           <li>
                              <p>探索减少延迟的选项（例如，与<code class="codeph">VSAT</code>链接相对的地面线路）。
                              </p>
                           </li>
                           <li>
                              <p>更改系统配置以将更高流量组件移动到更低延迟链路。</p>
                           </li>
                        </ul>
                        <p> <a id="d25676e6745" class="indexterm-anchor"></a><a id="d25676e6749" class="indexterm-anchor"></a>如果客户端进程正在使用大部分资源，那么在数据库中就无法完成任何操作。症状包括以下内容：</p>
                        <ul style="list-style-type:disc">
                           <li>
                              <p>等待的数量可能不大，但等待的时间可能很长</p>
                           </li>
                           <li>
                              <p>客户端进程具有较高的资源使用率</p>
                           </li>
                        </ul>
                        <p>在某些情况下，您可以看到等待用户的等待时间与客户端进程使用的CPU量密切相关。术语客户端在这里指的是n层体系结构中除数据库进程（中间层，桌面客户端）之外的任何进程。</p>
                     </div>
                     <!-- class="section" -->
                     <div class="section">
                        <p class="subhead3" id="GUID-2EAAF006-0954-4E83-871F-D9E67D7CC4AD__GUID-E501E1F0-E15B-4E4C-9686-CCD92B6F073D">来自dblink的SQL * Net消息</p>
                        <p><a id="d25676e6767" class="indexterm-anchor"></a><a id="d25676e6771" class="indexterm-anchor"></a>此事件表示会话已向远程节点发送消息并正在等待数据库链接的响应。由于以下原因，这一次可能会上升：</p>
                        <ul style="list-style-type:disc">
                           <li>
                              <p>网络瓶颈</p>
                              <p>有关信息，请参阅<span class="q">“ <a href="instance-tuning-using-performance-views.html#GUID-2EAAF006-0954-4E83-871F-D9E67D7CC4AD__SQLNETMESSAGEFROMCLIENTIDLEWAITEVEN-F951261D">来自客户端的SQL * Net消息</a> ”</span> 。
                              </p>
                           </li>
                           <li>
                              <p>在远程节点上执行SQL所花费的时间</p>
                              <p>查看在远程节点上运行的SQL很有用。登录到远程数据库，找到数据库链接创建的会话，并检查它正在运行的SQL语句。</p>
                           </li>
                           <li>
                              <p>往返消息的数量</p>
                              <p>会话和远程节点之间的每条消息都会增加延迟时间和处理开销。要减少交换的消息数，请使用数组提取和数组插入。</p>
                           </li>
                        </ul>
                     </div>
                     <!-- class="section" -->
                     <div class="section">
                        <p class="subhead3" id="GUID-2EAAF006-0954-4E83-871F-D9E67D7CC4AD__GUID-1041FF0E-B83C-4E4C-B01A-000E16CD53B2">SQL * Net向客户端提供更多数据</p>
                        <p>服务器进程正在向客户端发送更多数据或消息。以前对客户端的操作也是发送。</p>
                        <div class="infoboxnotealso" id="GUID-2EAAF006-0954-4E83-871F-D9E67D7CC4AD__GUID-EFEAC887-57BE-4CDB-B8F3-4F2376F44187">
                           <p class="notep1">也可以看看：</p>
                           <p><a href="../netag/optimizing-performance.html#NETAG-GUID-FC114CA9-4166-4195-8EFD-DB4FE8733D3F" target="_blank"><span class="italic">“Oracle数据库网络服务管理员指南”</span></a> ，详细讨论了网络优化</p>
                        </div>
                     </div>
                     <!-- class="section" -->
                  </div>
               </div>
            </div><a id="TGDBA13009"></a><div class="props_rev_3"><a id="GUID-E281EB31-5762-4945-9497-BBB923A6FF50" name="GUID-E281EB31-5762-4945-9497-BBB923A6FF50"></a><h3 id="TGDBA-GUID-E281EB31-5762-4945-9497-BBB923A6FF50" class="sect3"><span class="enumeration_section">10.4</span>调整实例恢复性能：快速启动故障恢复</h3>
               <div>
                  <p><a id="d25676e6858" class="indexterm-anchor"></a><a id="d25676e6862" class="indexterm-anchor"></a><a id="d25676e6866" class="indexterm-anchor"></a><a id="d25676e6868" class="indexterm-anchor"></a>本节介绍实例恢复，以及Oracle的快速启动故障恢复如何在发生崩溃或实例故障时提高可用性。它还提供了调整执行崩溃和实例恢复所需时间的指南。
                  </p>
                  <p>本节包含以下主题：</p>
                  <ul style="list-style-type:disc">
                     <li>
                        <p><a href="instance-tuning-using-performance-views.html#GUID-33C9C465-95E6-42C6-BE92-B587A5EAF5B6">关于实例恢复</a></p>
                     </li>
                     <li>
                        <p><a href="instance-tuning-using-performance-views.html#GUID-75455F43-DE5E-456C-BBC7-A28A782EE9D9">配置高速缓存恢复的持续时间：FAST_START_MTTR_TARGET</a></p>
                     </li>
                     <li>
                        <p><a href="instance-tuning-using-performance-views.html#GUID-2ACBA638-B8C4-428E-B23C-D2131BC6E993">调整FAST_START_MTTR_TARGET并使用MTTR Advisor</a></p>
                     </li>
                  </ul>
               </div><a id="TGDBA13010"></a><div class="props_rev_3"><a id="GUID-33C9C465-95E6-42C6-BE92-B587A5EAF5B6" name="GUID-33C9C465-95E6-42C6-BE92-B587A5EAF5B6"></a><h4 id="TGDBA-GUID-33C9C465-95E6-42C6-BE92-B587A5EAF5B6" class="sect4"><span class="enumeration_section">10.4.1</span>关于实例恢复</h4>
                  <div>
                     <p>实例和崩溃恢复是在崩溃或系统故障后自动将重做日志记录应用于Oracle数据块。在正常操作期间，如果一个实例干净地关闭（如使用<code class="codeph">SHUTDOWN IMMEDIATE</code>语句时），而不是异常终止，那么尚未写入磁盘上数据文件的内存中更改将作为一部分写入磁盘关机期间执行的检查点。
                     </p>
                     <p>但是，如果单个实例数据库崩溃或Oracle RAC配置的所有实例都崩溃，则Oracle Database会在下次启动时执行崩溃恢复。如果Oracle RAC配置的一个或多个实例崩溃，则幸存的实例会自动执行实例恢复。实例和崩溃恢复分两步进行：缓存恢复，然后是事务恢复。</p>
                     <p>一旦缓存恢复完成，就可以打开数据库，因此提高缓存恢复的性能对于提高可用性非常重要。</p>
                  </div><a id="TGDBA13011"></a><div class="props_rev_3"><a id="GUID-AB7657AA-9D5A-4DA9-97BD-01F50C4C98C8" name="GUID-AB7657AA-9D5A-4DA9-97BD-01F50C4C98C8"></a><h5 id="TGDBA-GUID-AB7657AA-9D5A-4DA9-97BD-01F50C4C98C8" class="sect5"><span class="enumeration_section">10.4.1.1</span>缓存恢复（前滚）</h5>
                     <div>
                        <p>在缓存恢复步骤期间，Oracle数据库将重做日志文件中的所有已提交和未提交的更改应用于受影响的数据块。缓存恢复处理所需的工作与数据库的更改速率（每秒更新事务）和检查点之间的时间成比例。</p>
                     </div>
                  </div><a id="TGDBA13012"></a><div class="props_rev_3"><a id="GUID-068D326D-5CFC-4C30-9B8A-D2535A6EA170" name="GUID-068D326D-5CFC-4C30-9B8A-D2535A6EA170"></a><h5 id="TGDBA-GUID-068D326D-5CFC-4C30-9B8A-D2535A6EA170" class="sect5"><span class="enumeration_section">10.4.1.2</span>交易恢复（回滚）</h5>
                     <div>
                        <p>要使数据库保持一致，必须撤消在崩溃时未提交的更改（换句话说，回滚）。在事务恢复步骤期间，Oracle数据库应用回滚段以撤消未提交的更改。</p>
                     </div>
                  </div><a id="TGDBA94549"></a><a id="TGDBA94550"></a><a id="TGDBA13013"></a><div class="props_rev_3"><a id="GUID-FFF3AFCE-2A3F-4F7B-A22E-67260849D237" name="GUID-FFF3AFCE-2A3F-4F7B-A22E-67260849D237"></a><h5 id="TGDBA-GUID-FFF3AFCE-2A3F-4F7B-A22E-67260849D237" class="sect5"><span class="enumeration_section">10.4.1.3</span>检查点和高速缓存恢复</h5>
                     <div>
                        <p>Oracle数据库会定期记录检查点。<span class="bold">检查点</span>是最高系统变化数（SCN），使得已知所有小于或等于该SCN的数据块被写入数据文件。如果发生故障，则只需在恢复期间应用包含高于检查点的SCN更改的重做记录。高速缓存恢复处理的持续时间由两个因素决定：SCN上的变化高于检查点的SCN的数据块的数量，以及需要读取以查找这些变化的日志块的数量。
                        </p>
                        <div class="section">
                           <p class="subhead3" id="GUID-FFF3AFCE-2A3F-4F7B-A22E-67260849D237__GUID-29E6E853-8446-4B9B-B5D2-59844B4E3512">检查点如何影响性能</p>
                           <p>频繁的检查点将脏缓冲区更频繁地写入数据文件，从而减少了实例发生故障时的缓存恢复时间。如果检查点经常出现，那么在当前检查点位置和日志结束之间的重做日志中应用重做记录涉及处理相对较少的数据块。这意味着恢复的缓存恢复阶段相当短。</p>
                           <p>但是，在高更新系统中，频繁的检查点可能会降低运行时性能，因为检查点会导致DBW <span class="italic">n</span>进程执行写入操作。
                           </p>
                        </div>
                        <!-- class="section" -->
                        <div class="section">
                           <p class="subhead3" id="GUID-FFF3AFCE-2A3F-4F7B-A22E-67260849D237__GUID-5ED894DC-0412-4A84-AC6A-1D651333B835">快速缓存恢复权衡</p>
                           <p>要最小化缓存恢复的持续时间，必须经常强制Oracle数据库检查点，从而将恢复期间应用的重做日志记录的数量保持在最低限度。但是，在高更新系统中，频繁的检查点会增加正常数据库操作的开销。</p>
                           <p>如果每日操作效率比最小化恢复时间更重要，则降低由于检查点而对数据文件的写入频率。这应该可以提高运营效率，但也可以增加缓存恢复时间。</p>
                        </div>
                        <!-- class="section" -->
                     </div>
                  </div>
               </div><a id="TGDBA13014"></a><div class="props_rev_3"><a id="GUID-75455F43-DE5E-456C-BBC7-A28A782EE9D9" name="GUID-75455F43-DE5E-456C-BBC7-A28A782EE9D9"></a><h4 id="TGDBA-GUID-75455F43-DE5E-456C-BBC7-A28A782EE9D9" class="sect4"><span class="enumeration_section">10.4.2</span>配置缓存恢复的持续时间：FAST_START_MTTR_TARGET</h4>
                  <div>
                     <p><a id="d25676e7175" class="indexterm-anchor"></a><a id="d25676e7177" class="indexterm-anchor"></a><a id="d25676e7181" class="indexterm-anchor"></a><a id="d25676e7187" class="indexterm-anchor"></a>快速启动故障恢复功能可缩短高速缓存恢复所需的时间，并通过限制脏缓冲区的数量和最近重做记录与最后一个检查点之间生成的重做记录数来使恢复受限并可预测。
                     </p>
                     <p>快速启动故障恢复的基础是快速启动检查点架构。而不是传统的事件驱动（即日志切换）检查点，它执行批量写入，快速启动检查点以递增方式发生。每个DBW <span class="italic">n</span>进程定期将缓冲区写入磁盘以提升检查点位置。首先写入最旧的修改块，以确保每次写入都允许检查点前进。快速启动检查点消除了批量写入以及传统检查点产生的I / O峰值。
                     </p>
                     <p>通过快速启动故障恢复功能， <code class="codeph">FAST_START_MTTR_TARGET</code>初始化参数简化了实例或系统故障的恢复时间配置。<code class="codeph">FAST_START_MTTR_TARGET</code>指定预期平均恢复时间（MTTR）的目标，即启动实例和执行缓存恢复所需的时间（以秒为单位）。设置<code class="codeph">FAST_START_MTTR_TARGET</code>后，数据库将管理增量检查点写入以尝试满足该目标。如果您为<code class="codeph">FAST_START_MTTR_TARGET</code>选择了实用值，则可以预期您的数据库平均会在您选择的大约秒数内恢复。
                     </p>
                     <div class="infoboxnote" id="GUID-75455F43-DE5E-456C-BBC7-A28A782EE9D9__GUID-0BDC8893-241D-425F-A252-7C784D0318A0">
                        <p class="notep1">注意：</p>
                        <p>使用<code class="codeph">FAST_START_MTTR_TARGET</code>时，必须禁用或删除<code class="codeph">FAST_START_IO_TARGET</code> ， <code class="codeph">LOG_CHECKPOINT_INTERVAL</code>和<code class="codeph">LOG_CHECKPOINT_TIMEOUT</code>初始化参数。设置这些参数会干扰用于管理缓存恢复时间以满足<code class="codeph">FAST_START_MTTR_TARGET.</code></p>
                     </div>
                  </div><a id="TGDBA94551"></a><div class="props_rev_3"><a id="GUID-DE2F016F-9344-44E1-856F-7F09D55595F5" name="GUID-DE2F016F-9344-44E1-856F-7F09D55595F5"></a><h5 id="TGDBA-GUID-DE2F016F-9344-44E1-856F-7F09D55595F5" class="sect5"><span class="enumeration_section">10.4.2.1</span> FAST_START_MTTR_TARGET的实用值</h5>
                     <div>
                        <p><code class="codeph">FAST_START_MTTR_TARGET</code>的最大值为3600秒（一小时）。如果将该值设置为大于3600，则Oracle数据库会将其舍入为3600。
                        </p>
                        <p>以下示例显示如何设置<code class="codeph">FAST_START_MTTR_TARGET</code>的值：</p><pre class="oac_no_warn" dir="ltr">SQL&gt; ALTER SYSTEM SET FAST_START_MTTR_TARGET = 30;</pre><p>原则上， <code class="codeph">FAST_START_MTTR_TARGET</code>的最小值是一秒。但是，您可以将<code class="codeph">FAST_START_MTTR_TARGET</code>设置为低这一事实并不意味着可以实现此目标。由于诸如数据库启动时间之类的因素，对可达到的最小MTTR目标存在实际限制。
                        </p>
                        <p>给定<code class="codeph">FAST_START_MTTR_TARGET</code>的当前值，数据库可以实现的<span class="bold">MTTR目标</span>称为<span class="bold">有效MTTR目标</span> 。您可以通过查看<code class="codeph">V$INSTANCE_RECOVERY</code>视图的<code class="codeph">TARGET_MTTR</code>列来查看当前有效的MTTR。
                        </p>
                        <p>数据库的MTTR目标值的实际范围定义为数据库的最低可实现有效MTTR目标与最坏情况下启动和缓存恢复最长的范围（即整个缓冲区时）缓存很脏）。 <span class="q">“ <a href="instance-tuning-using-performance-views.html#GUID-63DE4C5C-6FDF-4FBB-A8D4-CD5DB54E15D5">确定FAST_START_MTTR_TARGET的实际范围</a> ”</span>描述了确定可实现的MTTR目标值范围的过程，这是调整<code class="codeph">FAST_START_MTTR_TARGET</code>值的过程中的一个步骤。
                        </p>
                        <div class="infoboxnote" id="GUID-DE2F016F-9344-44E1-856F-7F09D55595F5__GUID-56FB69F6-D003-4E46-A8E5-32DC5A30EBBF">
                           <p class="notep1">注意：</p>
                           <p>将<code class="codeph">FAST_START_MTTR_TARGET</code>设置为超出实际范围的值通常没有用。如果您的<code class="codeph">FAST_START_MTTR_TARGET</code>值小于实际范围的下限，则效果就像您将其设置为实际范围的下限一样。在这种情况下，有效MTTR目标将是系统可以实现的最佳MTTR目标，但是检查点将处于最大值，这可能会影响正常的数据库性能。如果将<code class="codeph">FAST_START_MTTR_TARGET</code>设置为超过实际范围的时间，则MTTR目标将不会比最坏情况更好。
                           </p>
                        </div>
                     </div>
                  </div><a id="TGDBA94552"></a><div class="props_rev_3"><a id="GUID-B4882C55-DA46-46E6-9885-06AC0BDA5D4A" name="GUID-B4882C55-DA46-46E6-9885-06AC0BDA5D4A"></a><h5 id="TGDBA-GUID-B4882C55-DA46-46E6-9885-06AC0BDA5D4A" class="sect5"><span class="enumeration_section">10.4.2.2</span>降低检查点频率以优化运行时性能</h5>
                     <div>
                        <div class="section">
                           <p>要降低检查点频率并优化运行时性能，可以执行以下操作：</p>
                        </div>
                        <!-- class="section" -->
                        <div class="section">
                           <ul style="list-style-type:disc">
                              <li>
                                 <p>将<code class="codeph">FAST_START_MTTR_TARGET</code>的值设置为3600。这样可以实现快速启动检查点和快速启动故障恢复功能，但最大限度地减少了对运行时性能的影响，同时避免了对<code class="codeph">FAST_START_MTTR_TARGET</code>进行性能调整的需要。</p>
                              </li>
                              <li>
                                 <p>根据系统生成的重做次数调整在线重做日志文件的大小。尝试最多每20分钟切换一次日志。将日志文件设置得太小会增加检查点活动并降低性能。另请注意，所有重做日志文件的大小应相同。</p>
                                 <div class="infoboxnotealso" id="GUID-B4882C55-DA46-46E6-9885-06AC0BDA5D4A__GUID-234B027A-B857-4AC1-9DC9-FBD154BA5E46">
                                    <p class="notep1">也可以看看：</p>
                                    <p>有关检查点的详细信息，请参见<a href="../cncpt/oracle-database-instance.html#CNCPT-GUID-A6959126-0ECF-40A2-880D-D74A1BFB5BC4" target="_blank"><span class="italic">Oracle数据库概念</span></a></p>
                                 </div>
                              </li>
                           </ul>
                        </div>
                        <!-- class="section" -->
                     </div>
                  </div><a id="TGDBA94554"></a><a id="TGDBA94553"></a><div class="props_rev_3"><a id="GUID-C2F859B9-FB79-4786-B725-EBDAAE435393" name="GUID-C2F859B9-FB79-4786-B725-EBDAAE435393"></a><h5 id="TGDBA-GUID-C2F859B9-FB79-4786-B725-EBDAAE435393" class="sect5"><span class="enumeration_section">10.4.2.3</span>使用V $ INSTANCE_RECOVERY监控高速缓存恢复</h5>
                     <div>
                        <p><a id="d25676e7457" class="indexterm-anchor"></a> <code class="codeph">V$INSTANCE_RECOVERY</code>视图显示当前恢复参数设置。您还可以使用此视图中的统计信息来确定哪个因素对检查点的影响最大。
                        </p>
                        <p>下表列出了监视预测的缓存恢复性能最有用的列：</p>
                        <div class="tblformal" id="GUID-C2F859B9-FB79-4786-B725-EBDAAE435393__GUID-7E6C5FC6-E570-4052-8A72-D031B93F0F70">
                           <p class="titleintable">表10-4 V $ INSTANCE_RECOVERY列</p>
                           <table cellpadding="4" cellspacing="0" class="Formal" title="V $ INSTANCE_RECOVERY列" width="100%" border="1" summary="This table describes columns of the V$INSTANCE_RECOVERY view." frame="hsides" rules="rows">
                              <thead>
                                 <tr align="left" valign="top">
                                    <th align="left" valign="bottom" width="20%" id="d25676e7479">柱</th>
                                    <th align="left" valign="bottom" width="20%" id="d25676e7482">描述</th>
                                 </tr>
                              </thead>
                              <tbody>
                                 <tr align="left" valign="top">
                                    <td align="left" valign="top" width="20%" id="d25676e7487" headers="d25676e7479 ">
                                       <p><code class="codeph">TARGET_MTTR</code></p>
                                    </td>
                                    <td align="left" valign="top" width="20%" headers="d25676e7487 d25676e7482 ">
                                       <p>有效的MTTR目标，以秒为单位。如果未指定<code class="codeph">FAST_START_MTTR_TARGET</code>则此字段为0。
                                       </p>
                                    </td>
                                 </tr>
                                 <tr align="left" valign="top">
                                    <td align="left" valign="top" width="20%" id="d25676e7498" headers="d25676e7479 ">
                                       <p><code class="codeph">ESTIMATED_MTTR</code></p>
                                    </td>
                                    <td align="left" valign="top" width="20%" headers="d25676e7498 d25676e7482 ">
                                       <p>当前估计的MTTR（以秒为单位），基于当前脏缓冲区和日志块的数量。始终计算此字段，是否指定了<code class="codeph">FAST_START_MTTR_TARGET</code> 。
                                       </p>
                                    </td>
                                 </tr>
                              </tbody>
                           </table>
                        </div>
                        <!-- class="inftblhruleinformal" -->
                        <p>作为持续监控数据库的一部分，您可以定期将<code class="codeph">V$INSTANCE_RECOVERY.TARGET_MTTR</code>与<code class="codeph">FAST_START_MTTR_TARGET</code>进行比较。如果<code class="codeph">FAST_START_MTTR_TARGET</code>值在实际范围内，则这两个值通常应相同。如果<code class="codeph">TARGET_MTTR</code>始终长于<code class="codeph">FAST_START_MTTR_TARGET</code> ，则将<code class="codeph">FAST_START_MTTR_TARGET</code>设置为不小于<code class="codeph">TARGET_MTTR</code>的值。如果<code class="codeph">TARGET_MTTR</code>始终较短，则将<code class="codeph">FAST_START_MTTR_TARGET</code>设置为不大于<code class="codeph">TARGET_MTTR</code>的值。</p>
                        <div class="infoboxnotealso" id="GUID-C2F859B9-FB79-4786-B725-EBDAAE435393__GUID-BF817F76-587A-48D8-B1DB-4CC6BFBED2AC">
                           <p class="notep1">也可以看看：</p>
                           <p>有关<code class="codeph">V$INSTANCE_RECOVERY</code>视图的更多信息，请<a href="../refrn/V-INSTANCE_RECOVERY.html#REFRN30106" target="_blank"><span class="italic">参见Oracle数据库参考</span></a></p>
                        </div>
                     </div>
                  </div>
               </div><a id="TGDBA13015"></a><div class="props_rev_3"><a id="GUID-2ACBA638-B8C4-428E-B23C-D2131BC6E993" name="GUID-2ACBA638-B8C4-428E-B23C-D2131BC6E993"></a><h4 id="TGDBA-GUID-2ACBA638-B8C4-428E-B23C-D2131BC6E993" class="sect4"><span class="enumeration_section">10.4.3</span>调整FAST_START_MTTR_TARGET并使用MTTR Advisor</h4>
                  <div>
                     <p><a id="d25676e7602" class="indexterm-anchor"></a><a id="d25676e7608" class="indexterm-anchor"></a>要为数据库确定<code class="codeph">FAST_START_MTTR_TARGET</code>的适当值，请使用以下四个步骤：</p>
                     <ul style="list-style-type:disc">
                        <li>
                           <p><a href="instance-tuning-using-performance-views.html#GUID-57FFF0C9-E7C5-4ED4-9127-8C13D13D0B1F">校准FAST_START_MTTR_TARGET</a></p>
                        </li>
                        <li>
                           <p><a href="instance-tuning-using-performance-views.html#GUID-63DE4C5C-6FDF-4FBB-A8D4-CD5DB54E15D5">确定FAST_START_MTTR_TARGET的实际范围</a></p>
                        </li>
                        <li>
                           <p><a href="instance-tuning-using-performance-views.html#GUID-676A7E78-C073-40DA-A6A7-10E6E85FF1D5">使用MTTR Advisor评估不同的目标值</a></p>
                        </li>
                        <li>
                           <p><a href="instance-tuning-using-performance-views.html#GUID-A3E90981-6726-4E95-8245-C209D6AB0A59">确定重做日志的最佳大小</a></p>
                        </li>
                     </ul>
                  </div><a id="TGDBA94555"></a><div class="props_rev_3"><a id="GUID-57FFF0C9-E7C5-4ED4-9127-8C13D13D0B1F" name="GUID-57FFF0C9-E7C5-4ED4-9127-8C13D13D0B1F"></a><h5 id="TGDBA-GUID-57FFF0C9-E7C5-4ED4-9127-8C13D13D0B1F" class="sect5"><span class="enumeration_section">10.4.3.1</span>校准FAST_START_MTTR_TARGET</h5>
                     <div>
                        <p><code class="codeph">FAST_START_MTTR_TARGET</code>初始化参数使数据库计算内部系统触发器值，以限制重做日志的长度和数据高速缓存中的脏数据缓冲区的数量。此计算使用估计时间来读取重做块，估计读取和写入数据块的时间以及系统典型工作负载的特征，例如有多少脏缓冲区对应于多少更改向量，等等。
                        </p>
                        <p>最初，计算中使用内部默认值。这些默认值随着时间的推移被系统操作期间收集的I / O性能数据和实际缓存恢复所替换。</p>
                        <p>您必须执行多个实例恢复才能正确校准<code class="codeph">FAST_START_MTTR_TARGET</code>值。在开始校准之前，您必须确定是否针对数据库崩溃或硬件崩溃校准了<code class="codeph">FAST_START_MTTR_TARGET</code> 。如果您的数据库文件存储在文件系统中或者您的I / O子系统具有内存缓存，则需要考虑这一点，因为根据文件是否缓存，磁盘的读写时间存在很大差异。<code class="codeph">FAST_START_MTTR_TARGET</code>的适当值取决于哪种类型的崩溃对于快速恢复更为重要。
                        </p>
                        <p>要有效地校准<code class="codeph">FAST_START_MTTR_TARGET</code> ，请确保运行系统的典型工作负载足够长的时间，并执行多个实例恢复，以确保准确记录恢复期间读取重做块的时间和读取或写入数据块的时间。
                        </p>
                     </div>
                  </div><a id="TGDBA94556"></a><div class="props_rev_3"><a id="GUID-63DE4C5C-6FDF-4FBB-A8D4-CD5DB54E15D5" name="GUID-63DE4C5C-6FDF-4FBB-A8D4-CD5DB54E15D5"></a><h5 id="TGDBA-GUID-63DE4C5C-6FDF-4FBB-A8D4-CD5DB54E15D5" class="sect5"><span class="enumeration_section">10.4.3.2</span>确定FAST_START_MTTR_TARGET的实际范围</h5>
                     <div>
                        <p>校准后，您可以执行测试以确定数据库的<code class="codeph">FAST_START_MTTR_TARGET</code>的实际范围。
                        </p>
                     </div><a id="TGDBA94557"></a><div class="props_rev_3"><a id="GUID-7F16E87A-82AE-43DF-9301-7D24CBF8A4F8" name="GUID-7F16E87A-82AE-43DF-9301-7D24CBF8A4F8"></a><h6 id="TGDBA-GUID-7F16E87A-82AE-43DF-9301-7D24CBF8A4F8" class="sect6"><span class="enumeration_section">10.4.3.2.1</span>确定FAST_START_MTTR_TARGET的下限：场景</h6>
                        <div>
                           <div class="section">
                              <p>要确定实际范围的下限，请将<code class="codeph">FAST_START_MTTR_TARGET</code>设置为1，然后启动数据库。然后检查<code class="codeph">V$INSTANCE_RECOVERY.TARGET_MTTR</code>的值，并将此值用作<code class="codeph">FAST_START_MTTR_TARGET</code>的良好下限。数据库启动时间而不是缓存恢复时间通常是确定此限制的主要因素。
                              </p>
                              <p>例如，将<code class="codeph">FAST_START_MTTR_TARGET</code>设置为1：</p><pre class="oac_no_warn" dir="ltr">SQL&gt; ALTER SYSTEM SET FAST_START_MTTR_TARGET = 1;</pre><p>然后，在打开数据库后立即执行以下查询：</p><pre class="oac_no_warn" dir="ltr">SQL&gt; SELECT TARGET_MTTR，ESTIMATED_MTTR FROM V $ INSTANCE_RECOVERY;</pre><p>Oracle数据库响应如下：</p><pre class="oac_no_warn" dir="ltr">TARGET_MTTR ESTIMATED_MTTR 18 15</pre><p><code class="codeph">TARGET_MTTR</code>值为18秒是系统可以实现的最小MTTR目标，即<code class="codeph">FAST_START_MTTR_TARGET</code>的最低实际值。此最小值是根据平均数据库启动时间计算的。
                              </p>
                              <p><code class="codeph">ESTIMATED_MTTR</code>字段包含基于正在运行的数据库的当前状态的估计平均恢复时间。由于数据库刚刚打开，因此系统包含很少的脏缓冲区，因此如果此时实例失败，则不需要太多的缓存恢复。这就是为什么<code class="codeph">ESTIMATED_MTTR</code>目前可能低于最小可能的<code class="codeph">TARGET_MTTR</code> 。</p>
                              <p>最近的数据库活动可能会在短期内影响<code class="codeph">ESTIMATED_MTTR</code> 。假设您在数据库中经过一段时间的大量更新活动后立即查询<code class="codeph">V$INSTANCE_RECOVERY</code> 。Oracle数据库响应如下：</p><pre class="oac_no_warn" dir="ltr">TARGET_MTTR ESTIMATED_MTTR 18 30</pre><p>现在有效的MTTR目标仍然是18秒，估计的MTTR（如果在那一刻发生了崩溃）是30秒。这是可以接受的结果。这意味着某些检查点写入可能尚未完成，因此缓冲区高速缓存包含比目标更多的脏缓冲区。</p>
                              <p>现在等待60秒，然后重新发出查询到<code class="codeph">V$INSTANCE_RECOVERY</code> 。 Oracle数据库响应如下：</p><pre class="oac_no_warn" dir="ltr">TARGET_MTTR ESTIMATED_MTTR 18 25</pre><p>此时估计的MTTR已降至25秒，因为在此期间已写出一些脏缓冲区</p>
                           </div>
                           <!-- class="section" -->
                        </div>
                     </div><a id="TGDBA94558"></a><div class="props_rev_3"><a id="GUID-B17A039E-2107-451A-9E56-648F056A228A" name="GUID-B17A039E-2107-451A-9E56-648F056A228A"></a><h6 id="TGDBA-GUID-B17A039E-2107-451A-9E56-648F056A228A" class="sect6"><span class="enumeration_section">10.4.3.2.2</span>确定FAST_START_MTTR_TARGET的上限</h6>
                        <div>
                           <div class="section">
                              <p>要确定实际范围的上限，请将<code class="codeph">FAST_START_MTTR_TARGET</code>设置为3600，并在典型工作负载下运行数据库一段时间。然后检查<code class="codeph">V$INSTANCE_RECOVERY.TARGET_MTTR</code>的值。该值是<code class="codeph">FAST_START_MTTR_TARGET</code>的良好上限。</p>
                              <p>该过程基本上类似于<span class="q">“ <a href="instance-tuning-using-performance-views.html#GUID-7F16E87A-82AE-43DF-9301-7D24CBF8A4F8">确定FAST_START_MTTR_TARGET的下限：场景</a> ”中的过程</span> 。
                              </p>
                           </div>
                           <!-- class="section" -->
                        </div>
                     </div><a id="TGDBA94559"></a><div class="props_rev_3"><a id="GUID-CE2960DC-1DCF-441D-947F-7F0831467B6C" name="GUID-CE2960DC-1DCF-441D-947F-7F0831467B6C"></a><h6 id="TGDBA-GUID-CE2960DC-1DCF-441D-947F-7F0831467B6C" class="sect6"><span class="enumeration_section">10.4.3.2.3</span>选择FAST_START_MTTR_TARGET的初始值</h6>
                        <div>
                           <div class="section">
                              <p>确定<code class="codeph">FAST_START_MTTR_TARGET</code>参数的实际边界后，选择参数的初始值。如果您关心的是数据库性能，请选择实际范围内的较高值;如果优先级较短，则在实际范围内选择较低的值。当然，实际范围越窄，选择就越容易。
                              </p>
                              <p>例如，如果您发现实际范围在17到19秒之间，那么选择19将非常简单，因为它在恢复时间上的差异相对较小，同时最小化了检查点对系统性能的影响。但是，如果您发现实际范围介于18到40秒之间，则可以选择折衷值30，并相应地设置参数：</p><pre class="oac_no_warn" dir="ltr">SQL&gt; ALTER SYSTEM SET FAST_START_MTTR_TARGET = 30;</pre><p>然后，您可以继续使用MTTR Advisor来确定最佳值。</p>
                           </div>
                           <!-- class="section" -->
                        </div>
                     </div>
                  </div><a id="TGDBA94065"></a><div class="props_rev_3"><a id="GUID-676A7E78-C073-40DA-A6A7-10E6E85FF1D5" name="GUID-676A7E78-C073-40DA-A6A7-10E6E85FF1D5"></a><h5 id="TGDBA-GUID-676A7E78-C073-40DA-A6A7-10E6E85FF1D5" class="sect5"><span class="enumeration_section">10.4.3.3</span>使用MTTR Advisor评估不同的目标值</h5>
                     <div>
                        <p>为<code class="codeph">FAST_START_MTTR_TARGET</code>选择初步值后，可以使用MTTR Advisor评估不同<code class="codeph">FAST_START_MTTR_TARGET</code>设置对系统性能的影响，与您选择的设置进行比较。
                        </p>
                     </div><a id="TGDBA94560"></a><div class="props_rev_3"><a id="GUID-0751FA3F-B03A-495F-B053-3AE08FBC2895" name="GUID-0751FA3F-B03A-495F-B053-3AE08FBC2895"></a><h6 id="TGDBA-GUID-0751FA3F-B03A-495F-B053-3AE08FBC2895" class="sect6"><span class="enumeration_section">10.4.3.3.1</span>启用MTTR Advisor</h6>
                        <div>
                           <div class="section">
                              <p>要启用MTTR Advisor，请设置两个初始化参数<code class="codeph">STATISTICS_LEVEL</code>和<code class="codeph">FAST_START_MTTR_TARGET</code> 。</p>
                              <p><code class="codeph">STATISTICS_LEVEL</code>控制是否所有顾问程序都已启用且不是特定于MTTR Advisor。确保将其设置为<code class="codeph">TYPICAL</code>或<code class="codeph">ALL</code> 。然后，当<code class="codeph">FAST_START_MTTR_TARGET</code>设置为非零值时，将启用MTTR Advisor。
                              </p>
                           </div>
                           <!-- class="section" -->
                        </div>
                     </div><a id="TGDBA94561"></a><div class="props_rev_3"><a id="GUID-643ACE7E-E821-4CCC-94A6-9280EF44F234" name="GUID-643ACE7E-E821-4CCC-94A6-9280EF44F234"></a><h6 id="TGDBA-GUID-643ACE7E-E821-4CCC-94A6-9280EF44F234" class="sect6"><span class="enumeration_section">10.4.3.3.2</span>使用MTTR Advisor</h6>
                        <div>
                           <div class="section">
                              <p>启用MTTR Advisor后，运行典型的数据库工作负载一段时间。当MTTR Advisor为ON时，数据库模拟当前<code class="codeph">FAST_START_MTTR_TARGET</code>值下的检查点队列行为，以及有效<code class="codeph">FAST_START_MTTR_TARGET</code>值范围内的最多四个其他不同MTTR设置。（在这种情况下，数据库将在测试范围内的不同值之前确定<code class="codeph">FAST_START_MTTR_TARGET</code>本身的有效范围。）
                              </p>
                           </div>
                           <!-- class="section" -->
                        </div>
                     </div><a id="TGDBA94562"></a><div class="props_rev_3"><a id="GUID-E6F9223F-92F0-4F20-A846-B61C3CB39470" name="GUID-E6F9223F-92F0-4F20-A846-B61C3CB39470"></a><h6 id="TGDBA-GUID-E6F9223F-92F0-4F20-A846-B61C3CB39470" class="sect6"><span class="enumeration_section">10.4.3.3.3</span>查看MTTR Advisor结果：V $ MTTR_TARGET_ADVICE</h6>
                        <div>
                           <div class="section">
                              <p>通过动态性能视图<code class="codeph">V$MTTR_TARGET_ADVICE</code> ，您可以查看MTTR Advisor收集的统计信息或建议。
                              </p>
                              <p>数据库使用有关数据库的每个<code class="codeph">FAST_START_MTTR_TARGET</code>设置的效果的建议填充<code class="codeph">V$MTTR_TARGET_ADVICE</code> 。对于<code class="codeph">FAST_START_MTTR_TARGET</code>每个可能值，该行包含有关在针对该值FAST_START_MTTR_TARGET测试的工作负载下将执行多少缓存写入的详细信息。</p>
                              <p>具体来说，每行包含有关该值<code class="codeph">FAST_START_MTTR_TARGET</code>高速缓存写入，总物理写入（包括直接写入）和总I / O（包括读取）的信息，表示为操作总数和与操作下的操作相比的比率您选择的<code class="codeph">FAST_START_MTTR_TARGET</code>值。例如，比率为1.2表示缓存写入次数增加20％。
                              </p>
                              <p>了解不同<code class="codeph">FAST_START_MTTR_TARGET</code>设置对缓存写入活动和其他I / O的影响，可以更好地确定哪个<code class="codeph">FAST_START_MTTR_TARGET</code>值最适合您的恢复和性能需求。
                              </p>
                              <p>如果MTTR Advisor当前处于打开状态，则<code class="codeph">V$MTTR_TARGET_ADVICE</code>显示收集的Advisor信息。如果MTTR顾问目前<code class="codeph">OFF</code> ，那么视图显示收集到的信息的最后时间MTTR顾问为<code class="codeph">ON</code> ，因为数据库启动，如果有的话。如果自上次使用MTTR Advisor后已重新启动数据库，或者从未使用过该数据库，则视图将不显示任何行。
                              </p>
                              <div class="infoboxnotealso" id="GUID-E6F9223F-92F0-4F20-A846-B61C3CB39470__GUID-E0E6D9EB-F83C-4820-AE8A-300608421E3F">
                                 <p class="notep1">也可以看看：</p>
                                 <p><a href="../refrn/V-MTTR_TARGET_ADVICE.html#REFRN-GUID-9B817E47-F636-4626-9486-67EB97987C28" target="_blank"><span class="italic">Oracle Database Reference</span></a> ，了解<code class="codeph">V$MTTR_TARGET_ADVICE</code>视图的列详细信息</p>
                              </div>
                           </div>
                           <!-- class="section" -->
                        </div>
                     </div>
                  </div><a id="TGDBA94563"></a><div class="props_rev_3"><a id="GUID-A3E90981-6726-4E95-8245-C209D6AB0A59" name="GUID-A3E90981-6726-4E95-8245-C209D6AB0A59"></a><h5 id="TGDBA-GUID-A3E90981-6726-4E95-8245-C209D6AB0A59" class="sect5"><span class="enumeration_section">10.4.3.4</span>确定重做日志的最佳大小</h5>
                     <div>
                        <div class="section">
                           <p>您可以使用<code class="codeph">V$INSTANCE_RECOVERY</code>视图列<code class="codeph">OPTIMAL_LOGFILE_SIZE</code>来确定联机重做日志的大小。此字段显示重做日志文件大小（以兆字节为单位），根据<code class="codeph">FAST_START_MTTR_TARGET</code>的当前设置，该文件被视为最佳。如果此字段始终显示的值大于最小在线日志的大小，则应将所有在线日志配置为至少为此大小。
                           </p>
                           <p>但请注意，重做日志文件大小会影响MTTR。在某些情况下，您可以通过使用建议的最佳日志文件大小重新运行MTTR Advisor来优化您对最佳<code class="codeph">FAST_START_MTTR_TARGET</code>值的选择。
                           </p>
                        </div>
                        <!-- class="section" -->
                     </div>
                  </div>
               </div>
            </div>
         </div>
      </article>
   </body>
</html>