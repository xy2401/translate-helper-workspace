<html lang="en-us" dir="ltr" xml:lang="en-us">
   <head>
      <meta http-equiv="Content-Type" content="text/html; charset=utf-8"></meta>
      <meta name="viewport" content="width=device-width, initial-scale=1"></meta>
      <meta http-equiv="X-UA-Compatible" content="IE=edge"></meta>
      <title>使用源方法进行查询</title>
      <meta property="og:site_name" content="Oracle Help Center"></meta>
      <meta property="og:title" content="Java API Developer&#39;s Guide "></meta>
      <meta property="og:description" content=""></meta>
      <link rel="stylesheet" href="/sp_common/book-template/ohc-book-template/css/book.css"></link>
      <link rel="shortcut icon" href="/sp_common/book-template/ohc-common/img/favicon.ico"></link>
      <meta name="application-name" content="Java API Developer&#39;s Guide"></meta>
      <meta name="generator" content="DITA Open Toolkit version 1.8.5 (Mode = doc)"></meta>
      <meta name="plugin" content="SP_docbuilder HTML plugin release 18.2.2"></meta>
      <link rel="alternate" href="olap-java-api-developers-guide.pdf" title="PDF File" type="application/pdf"></link>
      <meta name="robots" content="all"></meta>
      <link rel="schema.dcterms" href="http://purl.org/dc/terms/"></link>
      <meta name="dcterms.created" content="2019-01-10T13:53:39-08:00"></meta>
      
      <meta name="dcterms.dateCopyrighted" content="2000, 2019"></meta>
      <meta name="dcterms.category" content="database"></meta>
      <meta name="dcterms.identifier" content="E96402-01"></meta>
      
      <meta name="dcterms.product" content="en/database/oracle/oracle-database/19"></meta>
      
      <link rel="prev" href="understanding-source-objects.html" title="Previous" type="text/html"></link>
      <link rel="next" href="using-transaction-provider.html" title="Next" type="text/html"></link>
      <script>
        document.write('<style type="text/css">');
        document.write('body > .noscript, body > .noscript ~ * { visibility: hidden; }');
        document.write('</style>');
     </script>
      <script src="/sp_common/book-template/requirejs/require.js" data-main="/sp_common/book-template/ohc-book-template/js/book-config"></script>
      <script>
            if (window.require === undefined) {
                document.write('<script data-main="sp_common/book-template/ohc-book-template/js/book-config" src="sp_common/book-template/requirejs/require.js"><\/script>');
                document.write('<link href="sp_common/book-template/ohc-book-template/css/book.css" rel="stylesheet"/>');
            }
        </script>
      <script type="application/json" id="ssot-metadata">{"primary":{"category":{"short_name":"database","element_name":"Database","display_in_url":true},"suite":{"short_name":"oracle","element_name":"Oracle","display_in_url":true},"product_group":{"short_name":"not-applicable","element_name":"Not applicable","display_in_url":false},"product":{"short_name":"oracle-database","element_name":"Oracle Database","display_in_url":true},"release":{"short_name":"19","element_name":"Release 19","display_in_url":true}}}</script>
      
    <meta name="dcterms.title" content="OLAP Java API Developer&#39;s Guide"></meta>
    <meta name="dcterms.isVersionOf" content="OLAAP"></meta>
    <meta name="dcterms.release" content="Release 19"></meta>
  </head>
   <body dir="ltr">
      <div class="noscript alert alert-danger text-center" role="alert">
         <a href="understanding-source-objects.html" class="pull-left"><span class="glyphicon glyphicon-chevron-left" aria-hidden="true"></span>上一页</a> <a href="using-transaction-provider.html" class="pull-right">下一页<span class="glyphicon glyphicon-chevron-right" aria-hidden="true"></span></a> <span class="fa fa-exclamation-triangle" aria-hidden="true"></span>必须启用JavaScript才能正确显示此内容</div>
      <article>
         <header>
            <ol class="breadcrumb" vocab="http://schema.org/" typeof="BreadcrumbList">
               <li property="itemListElement" typeof="ListItem"><a href="index.html" property="item" typeof="WebPage"><span property="name">Java API开发人员指南</span></a></li>
               <li class="active" property="itemListElement" typeof="ListItem">使用源方法进行查询</li>
            </ol>
            <a id="GUID-B5D5AF5D-330E-46D3-8BD7-E84B1373E6A7" name="GUID-B5D5AF5D-330E-46D3-8BD7-E84B1373E6A7"></a><a id="OLAAP291"></a>
            
            <h2 id="OLAAP-GUID-B5D5AF5D-330E-46D3-8BD7-E84B1373E6A7" class="sect2"><span class="enumeration_chapter">6</span>使用源方法进行查询</h2>
         </header>
         <div class="ind">
            <div>
               <p><a id="d17761e33" class="indexterm-anchor"></a>您可以通过生成一个<code class="codeph">Source</code>来创建查询，该<code class="codeph">Source</code>指定要检索的数据以及要对该数据执行的任何操作。要生成查询，请从主要<code class="codeph">Source</code>对象开始，这些对象表示度量的元数据以及要查询的维度及其属性。通常，您使用主<code class="codeph">Source</code>对象的方法来派生许多其他<code class="codeph">Source</code>对象，每个<code class="codeph">Source</code>对象都指定查询的一部分，例如维度成员的选择或对数据执行的操作。然后，您可以加入指定所需数据和操作的<code class="codeph">Source</code>对象。结果是一个代表查询的<code class="codeph">Source</code> 。然后，您可以通过为<code class="codeph">Source</code>创建<code class="codeph">Cursor</code>来检索数据。
               </p>
               <p>本章简要介绍了各种<code class="codeph">Source</code>方法，并更详细地讨论了其中的一些方法。它还讨论了如何使用这些方法进行一些典型的OLAP查询，并提供了其中一些示例。
               </p>
               <p>本章包括以下主题：</p>
               <ul style="list-style-type:disc">
                  <li>
                     <p><a href="making-queries-using-source-methods.html#GUID-316AAA82-2D0E-4CE0-AC33-C1764674DC72">描述基本源方法</a></p>
                  </li>
                  <li>
                     <p><a href="making-queries-using-source-methods.html#GUID-03C361B3-E046-4015-ACEB-AE5EF00E0DB2">使用基本方法</a></p>
                  </li>
                  <li>
                     <p><a href="making-queries-using-source-methods.html#GUID-41F505FD-DF76-4973-9668-B6C77C6CEC65">使用其他来源方法</a></p>
                  </li>
               </ul>
            </div><a id="OLAAP293"></a><a id="OLAAP292"></a><div class="props_rev_3"><a id="GUID-316AAA82-2D0E-4CE0-AC33-C1764674DC72" name="GUID-316AAA82-2D0E-4CE0-AC33-C1764674DC72"></a><h3 id="OLAAP-GUID-316AAA82-2D0E-4CE0-AC33-C1764674DC72" class="sect3"><span class="enumeration_section">6.1</span>描述基本源方法</h3>
               <div>
                  <div class="section">
                     <p><a id="d17761e124" class="indexterm-anchor"></a><a id="d17761e128" class="indexterm-anchor"></a><a id="d17761e132" class="indexterm-anchor"></a> <code class="codeph">Source</code>类有许多返回派生<code class="codeph">Source</code> 。派生的元素<code class="codeph">Source</code>从上<span>基座</span>的操作导致<code class="codeph">Source</code> ，它是<code class="codeph">Source</code> ，其方法返回衍生<code class="codeph">Source</code> 。只有少数方法执行<code class="codeph">Source</code>类的最基本操作。
                     </p>
                     <p><a id="d17761e161" class="indexterm-anchor"></a> <code class="codeph">Source</code>类的许多其他方法使用一个或多个基本方法来执行操作，例如按值或按位置选择基本<code class="codeph">Source</code>的元素，或者排序元素。本章和<a href="understanding-source-objects.html#GUID-871159BB-8ED1-454B-B9FA-62F36683F4B2">理解源对象中的</a>许多示例都使用其中一些方法。其他<code class="codeph">Source</code>方法获取具有<code class="codeph">Source</code>信息的对象，例如<code class="codeph">getID</code> ， <code class="codeph">getInputs</code>和<code class="codeph">getType</code>方法，执行比较（例如<code class="codeph">ge</code>和<code class="codeph">gt</code>方法），或将<code class="codeph">Source</code>的值从一种数据类型转换为另一种数据类型，例如<code class="codeph">toDoubleSource</code>方法。
                     </p>
                  </div>
                  <!-- class="section" -->
                  <div class="tblformal" id="GUID-316AAA82-2D0E-4CE0-AC33-C1764674DC72__CHDDACIA">
                     <p class="titleintable">表6-1基本源方法</p>
                     <table cellpadding="4" cellspacing="0" class="Formal" title="基本来源方法" width="100%" border="1" summary="This table lists the basic Source methods and provides brief descriptions of them." frame="hsides" rules="rows">
                        <thead>
                           <tr align="left" valign="top">
                              <th align="left" valign="bottom" width="31%" id="d17761e215">方法</th>
                              <th align="left" valign="bottom" width="69%" id="d17761e218">描述</th>
                           </tr>
                        </thead>
                        <tbody>
                           <tr align="left" valign="top">
                              <td align="left" valign="top" width="31%" id="d17761e223" headers="d17761e215 ">
                                 <p><a id="d17761e225" class="indexterm-anchor"></a><code class="codeph">alias</code></p>
                              </td>
                              <td align="left" valign="top" width="69%" headers="d17761e223 d17761e218 ">
                                 <p>返回一个<code class="codeph">Source</code> ，其具有相同的元件作为碱<code class="codeph">Source</code> ，但具有碱<code class="codeph">Source</code>作为类型。
                                 </p>
                              </td>
                           </tr>
                           <tr align="left" valign="top">
                              <td align="left" valign="top" width="31%" id="d17761e244" headers="d17761e215 ">
                                 <p><a id="d17761e246" class="indexterm-anchor"></a><code class="codeph">distinct</code></p>
                              </td>
                              <td align="left" valign="top" width="69%" headers="d17761e244 d17761e218 ">
                                 <p>返回一个<code class="codeph">Source</code> ，其具有相同的元件作为碱<code class="codeph">Source</code> ，不同之处在于被在基本复制的任何元件在派生只出现一次<code class="codeph">Source</code> 。
                                 </p>
                              </td>
                           </tr>
                           <tr align="left" valign="top">
                              <td align="left" valign="top" width="31%" id="d17761e265" headers="d17761e215 ">
                                 <p><a id="d17761e267" class="indexterm-anchor"></a><code class="codeph">join</code></p>
                              </td>
                              <td align="left" valign="top" width="69%" headers="d17761e265 d17761e218 ">
                                 <p>返回具有基本<code class="codeph">Source</code>元素的<code class="codeph">Source</code> ，该元素由方法调用的<code class="codeph">joined</code> ， <code class="codeph">comparison</code>和<code class="codeph">comparisonRule</code>参数指定。如果<code class="codeph">visible</code>参数为<code class="codeph">true</code> ，则连接的<code class="codeph">Source</code>是生成的<code class="codeph">Source</code>的输出。
                                 </p>
                              </td>
                           </tr>
                           <tr align="left" valign="top">
                              <td align="left" valign="top" width="31%" id="d17761e305" headers="d17761e215 ">
                                 <p><a id="d17761e307" class="indexterm-anchor"></a><code class="codeph">position</code></p>
                              </td>
                              <td align="left" valign="top" width="69%" headers="d17761e305 d17761e218 ">
                                 <p>返回一个<code class="codeph">Source</code> ，它具有基本<code class="codeph">Source</code>元素的位置，并且具有基本<code class="codeph">Source</code>作为输入。
                                 </p>
                              </td>
                           </tr>
                           <tr align="left" valign="top">
                              <td align="left" valign="top" width="31%" id="d17761e326" headers="d17761e215 ">
                                 <p><a id="d17761e328" class="indexterm-anchor"></a><code class="codeph">recursiveJoin</code></p>
                              </td>
                              <td align="left" valign="top" width="69%" headers="d17761e326 d17761e218 ">
                                 <p>类似于<code class="codeph">join</code>方法，但这种方法，在<code class="codeph">Source</code> ，它返回，定购的元素<code class="codeph">Source</code>的父子关系层次。
                                 </p>
                              </td>
                           </tr>
                           <tr align="left" valign="top">
                              <td align="left" valign="top" width="31%" id="d17761e347" headers="d17761e215 ">
                                 <p><a id="d17761e349" class="indexterm-anchor"></a><code class="codeph">value</code></p>
                              </td>
                              <td align="left" valign="top" width="69%" headers="d17761e347 d17761e218 ">
                                 <p>返回一个<code class="codeph">Source</code> ，其具有相同的元件作为碱<code class="codeph">Source</code> ，但具有碱<code class="codeph">Source</code>作为输入。
                                 </p>
                              </td>
                           </tr>
                        </tbody>
                     </table>
                  </div>
                  <!-- class="inftblhruleinformal" -->
                  <div class="section">
                     <p>以下主题描述了基本的<code class="codeph">Source</code>方法，并提供了一些使用它们的示例。
                     </p>
                     <ul style="list-style-type:disc">
                        <li>
                           <p><a href="making-queries-using-source-methods.html#GUID-03C361B3-E046-4015-ACEB-AE5EF00E0DB2">使用基本方法</a></p>
                        </li>
                        <li>
                           <p><a href="making-queries-using-source-methods.html#GUID-41F505FD-DF76-4973-9668-B6C77C6CEC65">使用其他来源方法</a></p>
                        </li>
                     </ul>
                  </div>
                  <!-- class="section" -->
               </div>
            </div><a id="OLAAP294"></a><div class="props_rev_3"><a id="GUID-03C361B3-E046-4015-ACEB-AE5EF00E0DB2" name="GUID-03C361B3-E046-4015-ACEB-AE5EF00E0DB2"></a><h3 id="OLAAP-GUID-03C361B3-E046-4015-ACEB-AE5EF00E0DB2" class="sect3"><span class="enumeration_section">6.2</span>使用基本方法</h3>
               <div>
                  <p><a id="d17761e419" class="indexterm-anchor"></a>以下主题提供了使用某些基本方法的示例。
                  </p>
                  <ul style="list-style-type:disc">
                     <li>
                        <p><a href="making-queries-using-source-methods.html#GUID-2599E060-9C27-4DE2-9673-B89A7CFDBBD1">使用别名方法</a></p>
                     </li>
                     <li>
                        <p><a href="making-queries-using-source-methods.html#GUID-33605F2C-B683-49FF-A5C9-BFDB6AD31167">使用distinct方法</a></p>
                     </li>
                     <li>
                        <p><a href="making-queries-using-source-methods.html#GUID-83221D91-C9C5-4BA7-A91F-A8F33C6A8F85">使用join方法</a></p>
                     </li>
                     <li>
                        <p><a href="making-queries-using-source-methods.html#GUID-50FB0A20-3E17-465D-BAFE-EB082C20FC68">使用位置方法</a></p>
                     </li>
                     <li>
                        <p><a href="making-queries-using-source-methods.html#GUID-31E4FFCF-E724-4C10-A4EC-1DFC5B70E10A">使用recursiveJoin方法</a></p>
                     </li>
                     <li>
                        <p><a href="making-queries-using-source-methods.html#GUID-77BC1C96-64D7-4CD4-8D3A-BFC44C69EF2B">使用值Method</a></p>
                     </li>
                  </ul>
               </div><a id="OLAAP296"></a><a id="OLAAP295"></a><div class="props_rev_3"><a id="GUID-2599E060-9C27-4DE2-9673-B89A7CFDBBD1" name="GUID-2599E060-9C27-4DE2-9673-B89A7CFDBBD1"></a><h4 id="OLAAP-GUID-2599E060-9C27-4DE2-9673-B89A7CFDBBD1" class="sect4"><span class="enumeration_section">6.2.1</span>使用别名方法</h4>
                  <div>
                     <div class="section">
                        <p>您使用<code class="codeph">alias</code>方法来控制<code class="codeph">Source</code>与输入的匹配。例如，如果要查明度量维度的成员指定的度量值是否大于同一维度的其他成员指定的度量值，则需要将度量的输入匹配两次在相同的连接操作中。为此，您可以派生两个<code class="codeph">Source</code>对象作为同一维度的别名，使它们输入从度量派生的两个<code class="codeph">Source</code>对象，将每个派生度量<code class="codeph">Source</code>连接到关联的别名维度<code class="codeph">Source</code>对象，然后比较结果。
                        </p>
                        <p><a href="making-queries-using-source-methods.html#GUID-2599E060-9C27-4DE2-9673-B89A7CFDBBD1__I1014430">例6-1</a>执行这样的操作。它生成一个<code class="codeph">Source</code> ，指定为CHANNEL_AWJ维度的每个值销售的单位数是否大于为CHANNEL_AWJ维度的其他值销售的单位数。
                        </p>
                        <p>该示例将<code class="codeph">units</code> （作为度量的<code class="codeph">Source</code>连接到<code class="codeph">Source</code>对象，这些对象是度量的三个维度的单个值的选择，以生成<code class="codeph">unitsSel</code> 。<code class="codeph">unitsSel</code> <code class="codeph">Source</code>指定由<code class="codeph">timeSel</code> ， <code class="codeph">custSel</code>和<code class="codeph">prodSel</code>对象指定的维度值的<code class="codeph">units</code>元素，这些对象是<code class="codeph">unitsSel</code>输出。<code class="codeph">unitsSel</code> <code class="codeph">Source</code>将CHANNEL_AWJ维度的<code class="codeph">Source</code>作为输入。
                        </p>
                        <p><code class="codeph">timeSel</code> ， <code class="codeph">custSel</code>和<code class="codeph">prodSel</code> <code class="codeph">Source</code>对象分别指定TIME_AWJ，CUSTOMER_AWJ和PRODUCT_AWJ维度的层次结构中的单个值。<code class="codeph">timeSel</code>值为<code class="codeph">CALENDAR_YEAR::MONTH::2001.01</code> ，标识2001年1月， <code class="codeph">custSel</code>值为<code class="codeph">SHIPMENTS::SHIP_TO::BUSN WRLD SJ</code> ，用于标识Business World San Jose客户， <code class="codeph">prodSel</code>值为<code class="codeph">PRODUCT_PRIMARY::ITEM::ENVY ABM</code> ，它标识了Envoy Ambassador便携式PC。</p>
                        <p><a id="d17761e599" class="indexterm-anchor"></a>下面的示例为<code class="codeph">chanHier</code>创建了两个别名<code class="codeph">chanAlias1</code>和<code class="codeph">chanAlias2</code> ，它是CHANNEL_AWJ维度的CHANNEL_PRIMARY层次结构的<code class="codeph">Source</code> 。然后它通过将<code class="codeph">unitsSel</code>与<code class="codeph">chanAlias1.value()</code>返回的<code class="codeph">Source</code>连接<code class="codeph">unitsSel</code>生成<code class="codeph">unitsSel1</code> 。该<code class="codeph">unitsSel1</code> <code class="codeph">Source</code>具有的元件和输出<code class="codeph">unitsSel</code>并且它具有<code class="codeph">chanAlias1</code>作为输入。类似地，该示例生成<code class="codeph">unitsSel2</code> ，其具有<code class="codeph">chanAlias2</code>作为输入。
                        </p>
                        <p><a id="d17761e649" class="indexterm-anchor"></a>该示例使用<code class="codeph">gt</code>的方法<code class="codeph">unitsSel1</code> ，其确定的值是否<code class="codeph">unitsSel1</code>比的值越大<code class="codeph">unitsSel2</code> 。最终的连接操作相匹配<code class="codeph">chanAlias1</code>与输入<code class="codeph">unitsSel1</code>并匹配<code class="codeph">chanAlias2</code>与输入<code class="codeph">unitsSel2</code> 。
                        </p>
                     </div>
                     <!-- class="section" -->
                     <div class="example" id="GUID-2599E060-9C27-4DE2-9673-B89A7CFDBBD1__I1014430">
                        <p class="titleinexample">例6-1用别名方法控制源代码输入匹配</p><pre class="oac_no_warn" dir="ltr">Source unitsSel = units.join（timeSel）.join（custSel）.join（prodSel）;来源chanAlias1 = chanHier.alias（）;来源chanAlias2 = chanHier.alias（）; NumberSource unitsSel1 =（NumberSource）unitsSel.join（chanAlias1.value（））; NumberSource unitsSel2 =（NumberSource）unitsSel.join（chanAlias2.value（））;源结果= unitsSel1.gt（unitsSel2）.join（chanAlias1）//输出2，列.join（chanAlias2）; //输出1，行;</pre><p><a id="d17761e685" class="indexterm-anchor"></a>该<code class="codeph">result</code> <code class="codeph">Source</code>指定查询“，是台的销量值<code class="codeph">unitsSel1</code>的通道值<code class="codeph">chanAlias1</code>不是出售的值的个单位<code class="codeph">unitsSel2</code>为通道值<code class="codeph">chanAlias2</code> ？“因为<code class="codeph">result</code>是由接合产生<code class="codeph">chanAlias2</code>到<code class="codeph">Source</code>通过返回<code class="codeph">unitsSel1.gt(unitsSel2).join(chanAlias1)</code> <code class="codeph">chanAlias2</code>是的第一输出<code class="codeph">result</code> ，并且<code class="codeph">chanAlias1</code>是的第二输出<code class="codeph">result</code> 。
                        </p>
                        <p><code class="codeph">result</code> <code class="codeph">Source</code> <code class="codeph">Cursor</code>具有回答查询的<code class="codeph">boolean</code>值作为值。<code class="codeph">Cursor</code>的第一个输出值是<code class="codeph">chanAlias2</code>指定的通道值，第二个输出的值是<code class="codeph">chanAlias1</code>指定的通道值。
                        </p>
                        <p><a id="d17761e761" class="indexterm-anchor"></a>以下是<code class="codeph">Cursor</code>值的显示，格式为添加了标题的交叉表。列边值是来自<code class="codeph">chanAlias1</code>的值，行边值是来自<code class="codeph">chanAlias2</code>的值。交叉表单元格的值是<code class="codeph">boolean</code>值，指示列通道值的销售单位值是否大于行通道值的单位销售值。例如，第一列中的交叉表值表示列渠道值<code class="codeph">Total Channel</code>的销售单位值不大于行<code class="codeph">Total Channel</code>值的单位销售价值，但它大于<code class="codeph">Direct Sales</code>的单位销售价值， <code class="codeph">Catalog</code>和<code class="codeph">Internet</code>行值。
                        </p><pre class="oac_no_warn" dir="ltr">----------------- chanAlias1 ---------------- chanAlias2 TotalChannel目录直销互联网---------- -  ------------ ------- ------------ -------- TotalChannel false false false false目录true false false false直接销售true true false false互联网true true true true</pre></div>
                     <!-- class="example" -->
                  </div>
               </div><a id="OLAAP298"></a><a id="OLAAP297"></a><div class="props_rev_3"><a id="GUID-33605F2C-B683-49FF-A5C9-BFDB6AD31167" name="GUID-33605F2C-B683-49FF-A5C9-BFDB6AD31167"></a><h4 id="OLAAP-GUID-33605F2C-B683-49FF-A5C9-BFDB6AD31167" class="sect4"><span class="enumeration_section">6.2.2</span>使用distinct方法</h4>
                  <div>
                     <div class="section">
                        <p><a id="d17761e834" class="indexterm-anchor"></a>您可以使用<code class="codeph">distinct</code>方法生成没有任何重复值的<code class="codeph">Source</code> ，如<a href="making-queries-using-source-methods.html#GUID-33605F2C-B683-49FF-A5C9-BFDB6AD31167__CBBECHCG">例6-2</a>所示。该示例连接两个维度成员选择。两个选择中都存在一些维度成员。该示例使用<code class="codeph">distinct</code>方法生成仅包含唯一维度成员且没有重复值的<code class="codeph">Source</code> 。
                        </p>
                        <p><a id="d17761e854" class="indexterm-anchor"></a><a id="d17761e858" class="indexterm-anchor"></a>的示例获取<code class="codeph">MdmStandardDimension</code>为CUSTOMER_AWJ维对象并获取<code class="codeph">MdmLevelHierarchy</code>对象该维度的市场层次结构。它得到<code class="codeph">StringSource</code>对象， <code class="codeph">mktHier</code> ，为<code class="codeph">MdmLevelHierarchy</code> 。然后使用<code class="codeph">selectValues</code>的方法<code class="codeph">mktHier</code>生产层次结构，成员的两个选择<code class="codeph">customersToSelect</code>和<code class="codeph">moreCustomersToSelect</code> 。<code class="codeph">customersToSelect</code>两名成员也出现在<code class="codeph">moreCustomersToSelect</code> <code class="codeph">customersToSelect</code> <code class="codeph">moreCustomersToSelect</code> 。
                        </p>
                        <p><a id="d17761e899" class="indexterm-anchor"></a>该示例使用<code class="codeph">appendValues</code>方法在<code class="codeph">combinedCustomers</code> <code class="codeph">Source</code>中<code class="codeph">combinedCustomers</code> <code class="codeph">customersToSelect</code>和<code class="codeph">moreCustomersToSelect</code>的元素。最后，该示例使用<code class="codeph">distinct</code>的方法<code class="codeph">combinedCustomers</code> ，它返回一个<code class="codeph">Source</code> ， <code class="codeph">distinctCombinedCustomers</code> ，仅具有层次结构的不同成员。
                        </p>
                     </div>
                     <!-- class="section" -->
                     <div class="example" id="GUID-33605F2C-B683-49FF-A5C9-BFDB6AD31167__CBBECHCG">
                        <p class="titleinexample">示例6-2使用distinct方法</p><pre class="oac_no_warn" dir="ltr">MdmStandardDimension mdmCustDim = mdmDBSchema.findOrCreateStandardDimension（“CUSTOMER_AWJ”）; MdmLevelHierarchy mdmMktHier = mdmCustDim.findOrCreateLevelHierarchy（“MARKETS”）; StringSource mktHier =（StringSource）mdmMktHier.getSource（）;来源customersToSelect = mktHier.selectValues（new String [] {“MARKETS :: SHIP_TO :: KOSH ENT BOS”，“MARKETS :: SHIP_TO :: KOSH ENT TOK”，“MARKETS :: SHIP_TO :: KOSH ENT WAN”}）;来源moreCustomersToSelect = mktHier.selectValues（new String [] {“MARKETS :: SHIP_TO :: KOSH ENT BOS”，“MARKETS :: SHIP_TO :: KOSH ENT TOK”，“MARKETS :: SHIP_TO :: BUSN WRLD NY”，“MARKETS :: SHIP_TO :: BUSN WRLD SJ“}）; Source combinedCustomers = customersToSelect.appendValues（moreCustomersToSelect）;来源distinctCombinedCustomers = combinedCustomers.distinct（）;</pre><p><code class="codeph">combinedCustomers</code> <code class="codeph">Source</code> <code class="codeph">Cursor</code>具有以下值：</p><pre class="oac_no_warn" dir="ltr">MARKETS :: SHIP_TO :: KOSH ENT BOS MARKETS :: SHIP_TO :: KOSH ENT TOK MARKETS :: SHIP_TO :: KOSH ENT WAN MARKETS :: SHIP_TO :: KOSH ENT BOS MARKETS :: SHIP_TO :: KOSH ENT TOK MARKETS :: SHIP_TO： ：BUSN WRLD NY MARKETS :: SHIP_TO :: BUSN WRLD SJ</pre><p><code class="codeph">distinctCombinedCustomers</code> <code class="codeph">Source</code> <code class="codeph">Cursor</code>具有以下值：</p><pre class="oac_no_warn" dir="ltr">MARKETS :: SHIP_TO :: KOSH ENT BOS MARKETS :: SHIP_TO :: KOSH ENT TOK MARKETS :: SHIP_TO :: KOSH ENT WAN MARKETS :: SHIP_TO :: BUSN WRLD NY MARKETS :: SHIP_TO :: BUSN WRLD SJ</pre></div>
                     <!-- class="example" -->
                  </div>
               </div><a id="OLAAP300"></a><a id="OLAAP299"></a><div class="props_rev_3"><a id="GUID-83221D91-C9C5-4BA7-A91F-A8F33C6A8F85" name="GUID-83221D91-C9C5-4BA7-A91F-A8F33C6A8F85"></a><h4 id="OLAAP-GUID-83221D91-C9C5-4BA7-A91F-A8F33C6A8F85" class="sect4"><span class="enumeration_section">6.2.3</span>使用连接方法</h4>
                  <div>
                     <div class="section">
                        <p>如<a href="understanding-source-objects.html#GUID-871159BB-8ED1-454B-B9FA-62F36683F4B2">了解源对象中所述</a> ，使用<code class="codeph">join</code>方法生成具有基本<code class="codeph">Source</code>元素的<code class="codeph">Source</code> ，该元素由方法的<code class="codeph">joined</code> ， <code class="codeph">comparison</code>和<code class="codeph">comparisonRule</code>参数确定。<code class="codeph">visible</code>参数确定<code class="codeph">joined</code>参数<code class="codeph">Source</code>是否是连接操作生成的<code class="codeph">Source</code>的输出。您还可以使用<code class="codeph">join</code>方法将<code class="codeph">Source</code>与基础或<code class="codeph">joined</code>参数<code class="codeph">Source</code>的输入进行匹配。
                        </p>
                        <p><a id="d17761e1052" class="indexterm-anchor"></a>本章中的大多数示例都使用<code class="codeph">join</code>方法的一个或多个签名， <a href="understanding-source-objects.html#GUID-871159BB-8ED1-454B-B9FA-62F36683F4B2">理解源对象中的</a>许多示例也是如此。<a href="making-queries-using-source-methods.html#GUID-83221D91-C9C5-4BA7-A91F-A8F33C6A8F85__CBBEBEJH">例6-3</a>使用完整的<code class="codeph">join</code>签名和最简单的<code class="codeph">join</code>签名。在该示例中，完整<code class="codeph">join</code>签名演示了如何使用<code class="codeph">COMPARISON_RULE_DESCENDING</code>作为<code class="codeph">comparisonRule</code>参数。
                        </p>
                        <p><a href="making-queries-using-source-methods.html#GUID-83221D91-C9C5-4BA7-A91F-A8F33C6A8F85__CBBEBEJH">例6-3</a>使用以下<code class="codeph">Source</code>对象。
                        </p>
                     </div>
                     <!-- class="section" -->
                     <div class="section">
                        <ul style="list-style-type:disc">
                           <li>
                              <p><code class="codeph">prodSelWithShortDescr</code> ，它是<code class="codeph">Source</code>通过与加入PRODUCT_AWJ维度的简短描述属性产生<code class="codeph">Source</code>为维度的PRODUCT_PRIMARY层次结构的FAMILY层级。
                              </p>
                           </li>
                           <li>
                              <p><code class="codeph">salesMeasure</code> ，它是UNITS_CUBE_AWJ多维数据集的SALES度量的<code class="codeph">Source</code> 。
                              </p>
                           </li>
                           <li>
                              <p><code class="codeph">timeSelWithShortDescr</code> ，它是<code class="codeph">Source</code>通过连接与所述TIME_AWJ维度的简短描述属性产生<code class="codeph">Source</code>为维度的CALENDAR_YEAR层次结构的所选择的成员。
                              </p>
                           </li>
                           <li>
                              <p><code class="codeph">custSelWithShortDescr</code> ，它是<code class="codeph">Source</code>通过连接与所述CUSTOMER_AWJ维度的简短描述属性产生<code class="codeph">Source</code>为维度的SHIPMENTS层次中所选择的部件。
                              </p>
                           </li>
                           <li>
                              <p><code class="codeph">chanSelWithShortDescr</code> ，它是<code class="codeph">Source</code>通过连接与所述CHANNEL_AWJ维度的简短描述属性产生<code class="codeph">Source</code>为维度的CHANNEL_PRIMARY层次结构的所选择的成员。
                              </p>
                           </li>
                        </ul>
                        <p>第一连接操作使用的完整签名<code class="codeph">join</code>方法与<code class="codeph">prodSelWithShortDescr</code>作为碱<code class="codeph">Source</code> ， <code class="codeph">salesMeasure</code>作为接合<code class="codeph">Source</code> ，所述<code class="codeph">Source</code>用于数字数据类型作为比较<code class="codeph">Source</code>和<code class="codeph">COMPARISON_RULE_DESCENDING</code>作为比较规则。该连接操作返回的<code class="codeph">Source</code>具有产品系列级别成员和相关产品简短描述值作为基本值以及具有降序销售额的输出。
                        </p>
                        <p>接下来的三个连接操作将加入度量的其他三个维度的单个成员选择。<code class="codeph">result</code> <code class="codeph">Source</code>按所有客户和所有渠道的2001年5月销售额的降序指定产品系列级别成员。
                        </p>
                     </div>
                     <!-- class="section" -->
                     <div class="example" id="GUID-83221D91-C9C5-4BA7-A91F-A8F33C6A8F85__CBBEBEJH">
                        <p class="titleinexample">示例6-3使用COMPARISON_RULE_DESCENDING</p><pre class="oac_no_warn" dir="ltr">来源结果= prodSelWithShortDescr.join（salesMeasure， <a id="d17761e1185" class="indexterm-anchor"></a> salesMeasure.getDataType（），Source。COMPARISON_RULE_DESCENDING，true）。join（timeSelWithShortDescr）.join（custSelWithShortDescr）.join（chanSelWithShortDescr）;</pre><p><code class="codeph">result</code> <code class="codeph">Source</code> <code class="codeph">Cursor</code>具有以下值，显示为表格。该表仅包括层次结构成员的短值描述和销售额值，并添加了标题和格式。
                        </p><pre class="oac_no_warn" dir="ltr">总渠道客户总数MAY-01总销售额产品系列------------------- ----------------- 3,580,239.72桌面个人电脑2,508,560.92便携式电脑891,807.30 CD / DVD 632,376.84调制解调器/传真444,444.38内存312,389.39附件291,510.88监视器222,995.92操作系统44,479.32文档</pre></div>
                     <!-- class="example" -->
                  </div>
               </div><a id="OLAAP302"></a><a id="OLAAP301"></a><div class="props_rev_3"><a id="GUID-50FB0A20-3E17-465D-BAFE-EB082C20FC68" name="GUID-50FB0A20-3E17-465D-BAFE-EB082C20FC68"></a><h4 id="OLAAP-GUID-50FB0A20-3E17-465D-BAFE-EB082C20FC68" class="sect4"><span class="enumeration_section">6.2.4</span>使用位置方法</h4>
                  <div>
                     <div class="section">
                        <p><a id="d17761e1241" class="indexterm-anchor"></a>您可以使用<code class="codeph">position</code>方法生成一个<code class="codeph">Source</code> ，该<code class="codeph">Source</code>具有基本元素的位置并将基数作为输入。<a href="making-queries-using-source-methods.html#GUID-50FB0A20-3E17-465D-BAFE-EB082C20FC68__CBBHFCIH">示例6-4</a>在生成<code class="codeph">Source</code>使用<code class="codeph">position</code>方法，该<code class="codeph">Source</code>指定TIME_AWJ维度的层次结构级别的第一个和最后一个成员的选择。
                        </p>
                        <p><a id="d17761e1261" class="indexterm-anchor"></a><a id="d17761e1265" class="indexterm-anchor"></a>在该示例中， <code class="codeph">mdmTimeDim</code>是<code class="codeph">MdmPrimaryDimension</code>为TIME_AWJ尺寸。该示例获取维度的level属性和CALENDAR_YEAR层次结构。然后它获取属性和层次结构的<code class="codeph">Source</code>对象。
                        </p>
                        <p><a id="d17761e1280" class="indexterm-anchor"></a>接下来，该示例创建一个<code class="codeph">Source</code>对象数组，并获取层次结构的<code class="codeph">MdmHierarchyLevel</code>组件的<code class="codeph">List</code> 。它获取每个级别的<code class="codeph">Source</code>对象并将其添加到数组，然后创建一个列表<code class="codeph">Source</code> ，其中包含级别的<code class="codeph">Source</code>对象作为元素值。
                        </p>
                        <p><a id="d17761e1305" class="indexterm-anchor"></a>然后，该示例生成<code class="codeph">levelMembers</code> ，它是一个<code class="codeph">Source</code> ，用于指定层次结构级别的成员。因为join操作的<code class="codeph">comparison</code>参数是<code class="codeph">levelList.value()</code>生成的<code class="codeph">Source</code> ， <code class="codeph">levelMembers</code>将<code class="codeph">levelList</code>作为输入。因此， <code class="codeph">levelMembers</code>是一个<code class="codeph">Source</code> ，它在连接操作中匹配输入时按级别返回每个级别的成员。
                        </p>
                        <p><a id="d17761e1339" class="indexterm-anchor"></a><a id="d17761e1343" class="indexterm-anchor"></a>的<code class="codeph">range</code> <code class="codeph">Source</code>指定的范围内的第二个元素的元素到下一个的最后一个元素的<code class="codeph">Source</code> 。
                        </p>
                        <p><a id="d17761e1358" class="indexterm-anchor"></a>下一个连接操作将生成<code class="codeph">firstAndLast</code> <code class="codeph">Source</code> 。操作的基础是<code class="codeph">levelMembers</code> 。的<code class="codeph">joined</code>参数是<code class="codeph">Source</code> ，从结果<code class="codeph">levelMembers.position()</code>方法。<code class="codeph">comparison</code>参数是<code class="codeph">range</code> <code class="codeph">Source</code> ，比较规则是<code class="codeph">COMPARISON_RULE_REMOVE</code> 。 <code class="codeph">visible</code>参数的值为<code class="codeph">true</code> 。因此， <code class="codeph">firstAndLast</code> <code class="codeph">Source</code>仅指定级别的第一个和最后一个成员，因为它从选择中删除了级别的所有其他成员。<code class="codeph">firstAndLast</code> <code class="codeph">Source</code>仍然将<code class="codeph">levelList</code>作为输入。
                        </p>
                        <p>最后的连接操作将<code class="codeph">firstAndLast</code>的输入与<code class="codeph">levelList</code> 。
                        </p>
                     </div>
                     <!-- class="section" -->
                     <div class="example" id="GUID-50FB0A20-3E17-465D-BAFE-EB082C20FC68__CBBHFCIH">
                        <p class="titleinexample">示例6-4选择第一个和最后一个时间元素</p><pre class="oac_no_warn" dir="ltr">MdmAttribute mdmTimeLevelAttr = mdmTimeDim.getLevelAttribute（）; MdmLevelHierarchy mdmCalHier = mdmTimeDim.findOrCreateLevelHierarchy（“CALENDAR_YEAR”）; Source levelRel = mdmTimeLevelAttr.getSource（）; StringSource calHier =（StringSource）mdmCalHier.getSource（）; Source [] levelSources = new Source [3];列表级别= mdmCalHier.getHierarchyLevels（）; for（int i = 0; i &lt;levelSources.length; i ++）{levelSources [i] =（（MdmHierarchyLevel）levels.get（i））。getSource（）;源levelList = dp.createListSource（levelSources）; Source levelMembers = calHier.join（levelRel，levelList.value（））;源范围= dp.createRangeSource（2，levelMembers.count（）。minus（1））; Source firstAndLast = levelMembers.join（levelMembers.position（），range，Source。COMPARISON_RULE_REMOVE，true）; Source result = firstAndLast.join（levelList）;</pre><p><code class="codeph">result</code> <code class="codeph">Source</code> <code class="codeph">Cursor</code>具有以下值，显示为添加了列标题和格式的表。左列命名级别，中间列是级别中成员的位置，右列是成员的本地值。TOTAL_TIME级别只有一个成员。
                        </p><pre class="oac_no_warn" dir="ltr">级别成员价值中的级别成员位置---------- ------------------------ --------- --- TOTAL_TIME 1 TOTAL YEAR 1 CY1998 YEAR 10 CY2007 QUARTER 1 CY1998。2007年第四季度第二季度。Q4 MONTH 1 1998.01 MONTH 120 2007.12</pre></div>
                     <!-- class="example" -->
                  </div>
               </div><a id="OLAAP304"></a><a id="OLAAP303"></a><div class="props_rev_3"><a id="GUID-31E4FFCF-E724-4C10-A4EC-1DFC5B70E10A" name="GUID-31E4FFCF-E724-4C10-A4EC-1DFC5B70E10A"></a><h4 id="OLAAP-GUID-31E4FFCF-E724-4C10-A4EC-1DFC5B70E10A" class="sect4"><span class="enumeration_section">6.2.5</span>使用recursiveJoin方法</h4>
                  <div>
                     <div class="section">
                        <p><a id="d17761e1480" class="indexterm-anchor"></a>您可以使用<code class="codeph">recursiveJoin</code>方法生成具有按层次排序的元素的<code class="codeph">Source</code> 。您只能将<code class="codeph">recursiveJoin</code>方法与<code class="codeph">MdmHierarchy</code>的<code class="codeph">Source</code>或此类<code class="codeph">Source</code>的子类型一起使用。该方法生成一个<code class="codeph">Source</code>其元素按层次结构中的父项及其子项按层次排序。
                        </p>
                        <p>像<code class="codeph">join</code>方法，可以使用<code class="codeph">recursiveJoin</code>方法以产生<code class="codeph">Source</code> ，其具有基体的元素<code class="codeph">Source</code>是由所确定的<code class="codeph">joined</code> ， <code class="codeph">comparison</code> ，和<code class="codeph">comparisonRule</code>该方法的参数。<code class="codeph">visible</code>参数确定连接的<code class="codeph">Source</code>是否是递归连接操作生成的<code class="codeph">Source</code>的输出。
                        </p>
                        <p>完整的<code class="codeph">recursiveJoin</code>方法具有其他参数，这些参数指定层次结构的父属性，结果是否应在其子项之前或之后具有父项，以及如果结果包括子项但不包括父项，则如何排序结果的元素。<code class="codeph">recursiveJoin</code>方法有几个签名，它们是完整签名的快捷方式。
                        </p>
                        <p><a href="making-queries-using-source-methods.html#GUID-31E4FFCF-E724-4C10-A4EC-1DFC5B70E10A__CBBDDAHE">示例6-5</a>使用<code class="codeph">recursiveJoin</code>方法，该方法首先列出父项，将父项限制为基数，并且不将连接的<code class="codeph">Source</code>添加为输出。该示例首先按层次级别对PRODUCT_AWJ维度的PRODUCT_PRIMARY层次结构的成员进行排序，然后按每个成员的包属性值进行排序。
                        </p>
                        <p><a id="d17761e1558" class="indexterm-anchor"></a>在第一个<code class="codeph">recursiveJoin</code>方法中， <code class="codeph">COMPARISON_RULE_ASCENDING</code>参数指定<code class="codeph">prodHier</code>层次结构的成员在每个级别内按升序字母顺序排列。<code class="codeph">prodParentAttr</code>对象是层次结构的父属性的<code class="codeph">Source</code> 。
                        </p>
                        <p>第二个<code class="codeph">recursiveJoin</code>方法中的<code class="codeph">prodPkgAttr</code>对象是维度的package属性的<code class="codeph">Source</code> 。只有ITEM级别的成员才具有相关的包属性值。由于聚合级别TOTAL_PRODUCT，CLASS和FAMILY中的成员没有相关包，因此这些级别中成员的包属性值为<code class="codeph">null</code> ，在结果中显示为<code class="codeph">NA</code> 。某些ITEM级别成员没有相关的包值，因此它们的值也是<code class="codeph">NA</code> 。
                        </p>
                        <p><a id="d17761e1600" class="indexterm-anchor"></a>第二个<code class="codeph">recursiveJoin</code>方法将包属性值连接到它们的相关层次结构成员，并按层次按层次排序成员，然后按包属性值按级别的升序按字母顺序对它们进行排序。<code class="codeph">COMPARISON_RULE_ASCENDING_NULLS_FIRST</code>参数指定具有<code class="codeph">null</code>值的成员出现在同一级别中的其他成员之前。然后，该示例加入方法，结果<code class="codeph">sortedHierAscending</code> ，到包属性以产生<code class="codeph">Source</code>具有包属性值作为元素值和<code class="codeph">sortedHierAscending</code>作为输出。
                        </p>
                        <p><a id="d17761e1625" class="indexterm-anchor"></a>第三个<code class="codeph">recursiveJoin</code>方法与第二个相同，只是<code class="codeph">COMPARISON_RULE_DESCENDING_NULLS_FIRST</code>参数按级别按包属性值按字母顺序降序对层次结构成员进行排序。
                        </p>
                     </div>
                     <!-- class="section" -->
                     <div class="example" id="GUID-31E4FFCF-E724-4C10-A4EC-1DFC5B70E10A__CBBDDAHE">
                        <p class="titleinexample">示例6-5按属性按层次排序产品</p><pre class="oac_no_warn" dir="ltr">源result1 = prodHier.recursiveJoin（prodDim.value（），prodHier.getDataType（），prodParentAttr，Source。COMPARISON_RULE_ASCENDING）; Source sortedHierAscending = prodHier.recursiveJoin（prodPkgAttr，prodPkgAttr.getDataType（），prodParentAttr，Source。COMPARISON_RULE_ASCENDING_NULLS_FIRST）;源result2 = prodPkgAttr.join（sortedHierAscending）; Source sortedHierDescending = prodHier.recursiveJoin（prodPkgAttr， <a id="d17761e1641" class="indexterm-anchor"></a> prodPkgAttr.getDataType（），prodParentAttr，Source。COMPARISON_RULE_DESCENDING_NULLS_FIRST）;源result3 = prodPkgAttr.join（sortedHierDescending）;</pre><p><code class="codeph">result1</code> <code class="codeph">Source</code> <code class="codeph">Cursor</code>具有以下值，并添加了标题。该列表仅包含<code class="codeph">Cursor</code>的前17个值。
                        </p><pre class="oac_no_warn" dir="ltr">产品主要层次结构值------------------------------------- PRODUCT_PRIMARY :: TOTAL_PRODUCT :: TOTAL PRODUCT_PRIMARY： ：CLASS :: HRD PRODUCT_PRIMARY :: FAMILY :: DISK PRODUCT_PRIMARY :: ITEM :: EXT CD ROM PRODUCT_PRIMARY :: ITEM :: EXT DVD PRODUCT_PRIMARY :: ITEM :: INT 8X DVD PRODUCT_PRIMARY :: ITEM :: INT CD ROM PRODUCT_PRIMARY :: ITEM :: INT CD USB PRODUCT_PRIMARY :: ITEM :: INT RW DVD PRODUCT_PRIMARY :: FAMILY :: DTPC PRODUCT_PRIMARY :: ITEM :: SENT FIN PRODUCT_PRIMARY :: ITEM :: SENT MM PRODUCT_PRIMARY :: ITEM :: SENT STD PRODUCT_PRIMARY :: FAMILY :: LTPC PRODUCT_PRIMARY :: ITEM :: ENVY ABM PRODUCT_PRIMARY :: ITEM :: ENVY EXE PRODUCT_PRIMARY :: ITEM :: ENVY STD ...
</pre><p><code class="codeph">result2</code> <code class="codeph">Source</code> <code class="codeph">Cursor</code>具有以下值，显示为添加了标题的表。该表仅包含<code class="codeph">Cursor</code>的前17个值。左列具有层次结构的成员值，右列具有成员的包属性值。
                        </p>
                        <p>首先显示具有<code class="codeph">null</code>值的ITEM级别成员，然后其他级别成员按包值的升序显示。由于package属性的数据类型是String，因此包值按升序字母顺序排列。
                        </p><pre class="oac_no_warn" dir="ltr">产品主要层次结构值包属性值------------------------------------- ------ ----------------- PRODUCT_PRIMARY :: TOTAL_PRODUCT :: TOTAL NA PRODUCT_PRIMARY :: CLASS :: HRD NA PRODUCT_PRIMARY :: FAMILY :: DISK NA PRODUCT_PRIMARY :: ITEM :: EXT CD ROM NA PRODUCT_PRIMARY :: ITEM :: INT 8X DVD NA PRODUCT_PRIMARY :: ITEM :: INT CD USB NA PRODUCT_PRIMARY :: ITEM :: EXT DVD Executive PRODUCT_PRIMARY :: ITEM :: INT CD ROM Laptop Value Pack PRODUCT_PRIMARY :: ITEM :: INT RW DVD多媒体PRODUCT_PRIMARY :: FAMILY :: DTPC NA PRODUCT_PRIMARY :: ITEM :: SENT FIN NA PRODUCT_PRIMARY :: ITEM :: SENT STD NA PRODUCT_PRIMARY :: ITEM :: SENT MM Multimedia PRODUCT_PRIMARY :: FAMILY :: LTPC NA RODUCT_PRIMARY :: ITEM： ：ENVY ABM NA PRODUCT_PRIMARY :: ITEM :: ENVY EXE Executive PRODUCT_PRIMARY :: ITEM :: ENVY STD Laptop Value Pack ...
</pre><p><code class="codeph">result3</code> <code class="codeph">Source</code> <code class="codeph">Cursor</code>具有以下值，显示为添加了标题的表。这次成员按降序排列，按包属性值按字母顺序排列。
                        </p><pre class="oac_no_warn" dir="ltr">产品主要层次结构值包属性值------------------------------------- ------ ----------------- PRODUCT_PRIMARY :: TOTAL_PRODUCT :: TOTAL NA PRODUCT_PRIMARY :: CLASS :: HRD NA PRODUCT_PRIMARY :: FAMILY :: DISK NA PRODUCT_PRIMARY :: ITEM :: EXT CD ROM NA PRODUCT_PRIMARY :: ITEM :: INT 8X DVD NA PRODUCT_PRIMARY :: ITEM :: INT CD USB NA PRODUCT_PRIMARY :: ITEM :: INT RW DVD Multimedia PRODUCT_PRIMARY :: ITEM :: INT CD ROM Laptop Value Pack PRODUCT_PRIMARY :: ITEM :: EXT DVD Executive PRODUCT_PRIMARY :: FAMILY :: DTPC NA PRODUCT_PRIMARY :: ITEM :: SENT FIN NA PRODUCT_PRIMARY :: ITEM :: SENT STD NA PRODUCT_PRIMARY :: ITEM :: SENT MM Multimedia PRODUCT_PRIMARY :: FAMILY :: LTPC NA PRODUCT_PRIMARY :: ITEM： ：ENVY ABM NA PRODUCT_PRIMARY :: ITEM :: ENVY STD Laptop Value Pack PRODUCT_PRIMARY :: ITEM :: ENVY EXE Executive ...</pre></div>
                     <!-- class="example" -->
                  </div>
               </div><a id="OLAAP305"></a><div class="props_rev_3"><a id="GUID-77BC1C96-64D7-4CD4-8D3A-BFC44C69EF2B" name="GUID-77BC1C96-64D7-4CD4-8D3A-BFC44C69EF2B"></a><h4 id="OLAAP-GUID-77BC1C96-64D7-4CD4-8D3A-BFC44C69EF2B" class="sect4"><span class="enumeration_section">6.2.6</span>使用值方法</h4>
                  <div>
                     <p><a id="d17761e1732" class="indexterm-anchor"></a>如<span class="q">“ <a href="understanding-source-objects.html#GUID-F00CC751-9451-4ECE-84AE-0B0ECC724D78">使用输入派生源</a> ” <a href="understanding-source-objects.html#GUID-F00CC751-9451-4ECE-84AE-0B0ECC724D78">中所述</a></span> ，您可以使用<code class="codeph">value</code>方法创建将自身作为输入的<code class="codeph">Source</code> 。该关系使您可以选择<code class="codeph">Source</code>的元素子集。您还可以使用值方法来反转关系。
                     </p>
                     <p>以下主题包含这些操作的示例。</p>
                     <ul style="list-style-type:disc">
                        <li>
                           <p><a href="making-queries-using-source-methods.html#GUID-6364436A-CFAE-44DA-89E5-C3216EBB4280">选择源的元素</a></p>
                        </li>
                        <li>
                           <p><a href="making-queries-using-source-methods.html#GUID-E40179C1-98E7-4690-A5EF-3D59681168E6">扭转关系</a></p>
                        </li>
                     </ul>
                  </div><a id="OLAAP307"></a><a id="OLAAP306"></a><div class="props_rev_3"><a id="GUID-6364436A-CFAE-44DA-89E5-C3216EBB4280" name="GUID-6364436A-CFAE-44DA-89E5-C3216EBB4280"></a><h5 id="OLAAP-GUID-6364436A-CFAE-44DA-89E5-C3216EBB4280" class="sect5"><span class="enumeration_section">6.2.6.1</span>选择源元素</h5>
                     <div>
                        <div class="section">
                           <p><a id="d17761e1802" class="indexterm-anchor"></a><a id="d17761e1806" class="indexterm-anchor"></a> <a href="understanding-source-objects.html#GUID-D196A026-C589-401A-B312-001702278183__BABBCGED">例5-11</a>和<a href="making-queries-using-source-methods.html#GUID-6364436A-CFAE-44DA-89E5-C3216EBB4280__CBBIEBGB">例6-6</a>演示了选择<code class="codeph">Source</code>元素的子集。在<a href="making-queries-using-source-methods.html#GUID-6364436A-CFAE-44DA-89E5-C3216EBB4280__CBBIEBGB">例6-6中</a> ， <code class="codeph">shipHier</code>是CUSTOMER_AWJ维度的SHIPMENTS层次结构的<code class="codeph">Source</code> 。该<code class="codeph">selectValues</code>的方法<code class="codeph">shipHier</code>产生<code class="codeph">custSel</code> ，这是一些元件的选择<code class="codeph">shipHier</code> 。该<code class="codeph">selectValues</code>的方法<code class="codeph">custSel</code>产生<code class="codeph">custSel2</code> ，它是选择的一个子集。
                           </p>
                           <p>第一个<code class="codeph">join</code>方法以<code class="codeph">custSel</code>为基础，以及连接的<code class="codeph">Source</code> 。它有<code class="codeph">custSel2</code>作为比较<code class="codeph">Source</code> 。生成的<code class="codeph">Source</code> ， <code class="codeph">result1</code>的元素是基础的笛卡尔积和已由比较<code class="codeph">Source</code>指定的已连接的<code class="codeph">Source</code>对象。该<code class="codeph">result1</code> <code class="codeph">Source</code>具有一组的元素的<code class="codeph">custSel</code>对的每个元素<code class="codeph">custSel</code>即在比较<code class="codeph">Source</code> 。<code class="codeph">visible</code>参数的<code class="codeph">true</code>值使得连接的<code class="codeph">Source</code>成为<code class="codeph">result1</code>的输出。
                           </p>
                           <p>第二个<code class="codeph">join</code>方法还将<code class="codeph">custSel</code>作为基础，将<code class="codeph">custSel2</code>作为比较<code class="codeph">Source</code> ，但它将<code class="codeph">custSel.value()</code>方法返回的<code class="codeph">Source</code>作为连接的<code class="codeph">Source</code> 。因为<code class="codeph">custSel</code>是已连接<code class="codeph">Source</code>的输入，所以基本<code class="codeph">Source</code>与该输入匹配。该输入关系导致生成的<code class="codeph">Source</code> ， <code class="codeph">result2</code> ，只有<code class="codeph">custSel</code>那些元素也在比较<code class="codeph">Source</code> 。
                           </p>
                        </div>
                        <!-- class="section" -->
                        <div class="example" id="GUID-6364436A-CFAE-44DA-89E5-C3216EBB4280__CBBIEBGB">
                           <p class="titleinexample">示例6-6选择源元素的子集</p><pre class="oac_no_warn" dir="ltr">StringSource custSel = shipHier.selectValues（new String [] {“SHIPMENTS :: SHIP_TO :: COMP WHSE SIN”，“SHIPMENTS :: SHIP_TO :: COMP WHSE LON”，“SHIPMENTS :: SHIP_TO :: COMP WHJ SJ”，“SHIPMENTS :: SHIP_TO :: COMP WHSE ATL“}）;来源custSel2 = custSel.selectValues（new String [] {“SHIPMENTS :: SHIP_TO :: COMP WHSE SIN”，“SHIPMENTS :: SHIP_TO :: COMP WHS SJ”}）;来源result1 = custSel.join（custSel，custSel2，true）;来源result2 = custSel.join（custSel.value（），custSel2，true）;</pre><p><code class="codeph">result1</code>的<code class="codeph">Cursor</code>具有下表中显示的值。该表具有不在<code class="codeph">Cursor</code>中的格式和标题。左列具有<code class="codeph">Cursor</code>输出元素的值。右列具有<code class="codeph">Cursor</code>的基值。
                           </p><pre class="oac_no_warn" dir="ltr">输出值result1值--------------------------------- ------------- -------------------- SHIPMENTS :: SHIP_TO :: COMP SJ SHIPMENTS :: SHIP_TO :: COMP ATL SHIPMENTS :: SHIP_TO :: COMP WHJ SJ SHIPMENTS :: SHIP_TO :: COMP SJ SHIPMENTS :: SHIP_TO :: COMP SJ SHIPMENTS :: SHIP_TO :: COMP SINS SHIPMENTS :: SHIP_TO :: COMP SJ SHIPMENTS :: SHIP_TO :: COMP WHOT LON SHIPMENTS :: SHIP_TO :: COMP WHSE SIN SHIPMENTS :: SHIP_TO :: COMP ATING SHIPMENTS :: SHIP_TO :: COMP SINS SHIPMENTS :: SHIP_TO :: COMP SJ SHIPMENTS :: SHIP_TO :: COMP SINS SHIPMENTS :: SHIP_TO :: COMP WHSE SIN SHIPMENTS :: SHIP_TO :: COMP WHSE SIN SHIPMENTS :: SHIP_TO :: COMP WHON LON</pre><p><code class="codeph">result2</code>的<code class="codeph">Cursor</code>具有以下值，显示为添加了标题的表。左列具有<code class="codeph">Cursor</code>输出元素的值。右列具有<code class="codeph">Cursor</code>的基值。
                           </p><pre class="oac_no_warn" dir="ltr">输出值result2值--------------------------------- ------------- -------------------- SHIPMENTS :: SHIP_TO :: COMP SJ SHIPMENTS :: SHIP_TO :: COMP SJ SHIPMENTS :: SHIP_TO :: COMP WHSE SIN SHIPMENTS :: SHIP_TO :: COMP WHSE SIN</pre></div>
                        <!-- class="example" -->
                     </div>
                  </div><a id="OLAAP309"></a><a id="OLAAP308"></a><div class="props_rev_3"><a id="GUID-E40179C1-98E7-4690-A5EF-3D59681168E6" name="GUID-E40179C1-98E7-4690-A5EF-3D59681168E6"></a><h5 id="OLAAP-GUID-E40179C1-98E7-4690-A5EF-3D59681168E6" class="sect5"><span class="enumeration_section">6.2.6.2撤销</span>关系</h5>
                     <div>
                        <div class="section">
                           <p><a id="d17761e2031" class="indexterm-anchor"></a><a id="d17761e2035" class="indexterm-anchor"></a><a id="d17761e2039" class="indexterm-anchor"></a> <code class="codeph">value</code>方法的另一个用途是反转关系，如<a href="making-queries-using-source-methods.html#GUID-E40179C1-98E7-4690-A5EF-3D59681168E6__CHDEIIIH">例6-7</a>所示。该示例反转CUSTOMER_AWJ维度的祖先属性关系，以生成表示后代关系的<code class="codeph">Source</code> ， <code class="codeph">marketsDescendants</code> 。<code class="codeph">marketsDescendants</code> <code class="codeph">Source</code>作为维度的MARKETS层次结构的<code class="codeph">Source</code>作为输入。当您使用与该输入匹配的<code class="codeph">Source</code>加入<code class="codeph">marketsDescendants</code>时，您将获得一个<code class="codeph">Source</code> ，该<code class="codeph">Source</code>指定层次结构的参与成员的后代。
                           </p>
                           <p>逆转关系的另一个例子是<a href="making-queries-using-source-methods.html#GUID-53956A82-8350-44A3-A01C-B0D69B83EFFD__CBBGEGFA">例6-10</a> 。它使用<code class="codeph">value</code>方法来反转父属性以获取父项的子项。
                           </p>
                           <p><a href="making-queries-using-source-methods.html#GUID-E40179C1-98E7-4690-A5EF-3D59681168E6__CHDEIIIH">例6-7</a>首先获取<code class="codeph">MdmStandardDimension</code>为CUSTOMER_AWJ尺寸和对象<code class="codeph">MdmLevelHierarchy</code>该维度的市场层次结构对象。它获取层次结构的<code class="codeph">Source</code> 。
                           </p>
                           <p><a id="d17761e2094" class="indexterm-anchor"></a>接下来的示例获取维度的祖先属性和它的<code class="codeph">Source</code> 。祖先属性将每个维度成员与该成员的祖先相关联。
                           </p>
                           <p>要生成表示维度的每个成员的后代的<code class="codeph">Source</code> ，该示例通过将层次结构的<code class="codeph">Source</code> <code class="codeph">mktHier</code>与祖先属性<code class="codeph">ancestorsAttr</code>连接来反转祖先关系。连接操作使用<code class="codeph">mktHier.value()</code>作为比较<code class="codeph">Source</code> ，因此连接操作<code class="codeph">marketsDescendants</code>返回的<code class="codeph">Source</code>具有<code class="codeph">mktHier</code>作为输入。所述<code class="codeph">marketsDescendants</code> <code class="codeph">Source</code>指定，对于每个元件<code class="codeph">ancestorsAttr</code> ，的元素<code class="codeph">mktHier</code>具有所述<code class="codeph">ancestorsAttr</code>元件作为其祖先。因为它具有<code class="codeph">mktHier</code>作为输入，所以<code class="codeph">marketsDescendants</code> <code class="codeph">Source</code>功能与表示层次结构的后代关系的属性相同。
                           </p>
                           <p>这个例子说明了这一点，当它加入<code class="codeph">mktHier</code>到<code class="codeph">marketsDescendants</code>在下面一行。
                           </p><pre class="oac_no_warn" dir="ltr">来源selValDescendants = marketsDescendants.join（mktHier，selVal）;</pre><p>在连接操作中，加入了<code class="codeph">Source</code> ， <code class="codeph">mktHier</code> ，用的输入相匹配<code class="codeph">marketsDescendants</code> 。比较<code class="codeph">Source</code>是<code class="codeph">selVal</code> ，它指定层次结构的单个成员。该加入操作返回<code class="codeph">selValDescendants</code> ，它指定的元素<code class="codeph">marketsDescendants</code>属于的后代<code class="codeph">selVal</code>构件。结果还包括祖先成员本身。所述<code class="codeph">mktHier</code> <code class="codeph">Source</code>不是的输出<code class="codeph">selValDescendants</code>因为签名<code class="codeph">join</code>使用的方法推导出<code class="codeph">Source</code>不具有接合<code class="codeph">Source</code>作为输出。
                           </p>
                           <p><a id="d17761e2214" class="indexterm-anchor"></a>下面的示例使用<code class="codeph">join</code>方法的完整签名来生成<code class="codeph">selValDescendantsOnly</code> ，它只包含后代而不包含祖先值。以除去祖先值时，例如再次使用该<code class="codeph">value</code>的方法，这时候返回一个<code class="codeph">Source</code>是在<code class="codeph">joined</code>返回连接操作的参数<code class="codeph">selValDescendantsOnly</code> 。比较<code class="codeph">Source</code>是<code class="codeph">selVal</code> ，比较规则是<code class="codeph">COMPARISON_RULE_REMOVE</code> 。</p>
                           <p><a id="d17761e2248" class="indexterm-anchor"></a>最后，该示例使用<code class="codeph">removeValue</code>方法生成<code class="codeph">selValDescendantsOnly2</code> ，这与<code class="codeph">selValDescendantsOnly</code>相同。这只是演示了<code class="codeph">removeValue</code>方法是返回<code class="codeph">selValDescendantsOnly</code>的连接操作的快捷方式。
                           </p>
                        </div>
                        <!-- class="section" -->
                        <div class="example" id="GUID-E40179C1-98E7-4690-A5EF-3D59681168E6__CHDEIIIH">
                           <p class="titleinexample">示例6-7使用值Method反转关系</p><pre class="oac_no_warn" dir="ltr">MdmStandardDimension mdmCustDim = mdmDBSchema.findOrCreateStandardDimension（“CUSTOMER_AWJ”）; MdmLevelHierarchy mdmMktHier = mdmCustDim.findOrCreateLevelHierarchy（“MARKETS”）; StringSource mktHier =（StringSource）mdmMktHier.getSource（）; MdmAttribute mdmAncestorsAttr = mdmCustDim.getAncestorsAttribute（）; Source ancestorsAttr = mdmAncestorsAttr.getSource（）; //反转祖先关系以获得后代关系。来源marketsDescendants = mktHier.join（ancestorsAttr，mktHier.value（））;来源selVal = mktHier.selectValue（“MARKETS :: ACCOUNT :: BUSN WRLD”）; //选择指定层次结构成员的后代。StringSource selValDescendants =（StringSource）marketsDescendants.join（mktHier，selVal）; //删除祖先值，以便只保留后代。源selValDescendantsOnly = selValDescendants.join（selValDescendants.value（），selVal，Source。COMPARISON_RULE_REMOVE），false; //使用removeValue方法生成相同的结果。来源selValDescendantsOnly2 = selValDescendants.removeValue（“MARKETS :: ACCOUNT :: BUSN WRLD”）;</pre><p><code class="codeph">selValDescendants</code>的<code class="codeph">Cursor</code>具有以下值。
                           </p><pre class="oac_no_warn" dir="ltr">MARKETS :: ACCOUNT :: BUSN WRLD MARKETS :: SHIP_TO :: BUSN WRLD HAM MARKETS :: SHIP_TO :: BUSN WRLD NAN MARKETS :: SHIP_TO :: BUSN WRLD NY MARKETS :: SHIP_TO :: BUSN WRLD SJ</pre><p><code class="codeph">selValDescendantsOnly</code>的<code class="codeph">Cursor</code>具有以下值。
                           </p><pre class="oac_no_warn" dir="ltr">MARKETS :: SHIP_TO :: BUSN WRLD HAM MARKETS :: SHIP_TO :: BUSN WRLD NAN MARKETS :: SHIP_TO :: BUSN WRLD NY MARKETS :: SHIP_TO :: BUSN WRLD SJ</pre><p><code class="codeph">selValDescendantsOnly2</code>的<code class="codeph">Cursor</code>具有以下值。
                           </p><pre class="oac_no_warn" dir="ltr">MARKETS :: SHIP_TO :: BUSN WRLD HAM MARKETS :: SHIP_TO :: BUSN WRLD NAN MARKETS :: SHIP_TO :: BUSN WRLD NY MARKETS :: SHIP_TO :: BUSN WRLD SJ</pre></div>
                        <!-- class="example" -->
                     </div>
                  </div>
               </div>
            </div><a id="OLAAP310"></a><div class="props_rev_3"><a id="GUID-41F505FD-DF76-4973-9668-B6C77C6CEC65" name="GUID-41F505FD-DF76-4973-9668-B6C77C6CEC65"></a><h3 id="OLAAP-GUID-41F505FD-DF76-4973-9668-B6C77C6CEC65" class="sect3"><span class="enumeration_section">6.3</span>使用其他来源方法</h3>
               <div>
                  <p>除了作为基本方法的各种签名的方法之外， <code class="codeph">Source</code>类还有许多使用基本方法组合的其他方法。一些方法基于单个位置执行选择，例如<code class="codeph">at</code>和<code class="codeph">offset</code>方法。其他人在一系列位置上操作，例如<code class="codeph">interval</code>方法。一些执行比较，例如<code class="codeph">eq</code>和<code class="codeph">gt</code> ，选择一个或多个元素，例如<code class="codeph">selectValue</code>或<code class="codeph">removeValue</code> ，或排序元素，例如<code class="codeph">sortAscending</code>或<code class="codeph">sortDescendingHierarchically</code> 。
                  </p>
                  <p><code class="codeph">Source</code>的子类每个都有其他专门的方法。例如， <code class="codeph">NumberSource</code>类有许多执行数学函数的方法，例如<code class="codeph">abs</code> ， <code class="codeph">div</code>和<code class="codeph">cos</code> ，以及执行聚合的方法，例如<code class="codeph">average</code>和<code class="codeph">total</code> 。
                  </p>
                  <p>以下主题提供了演示某些<code class="codeph">Source</code>方法的示例。一些示例是OLAP应用程序通常执行的任务。
                  </p>
                  <ul style="list-style-type:disc">
                     <li>
                        <p><a href="making-queries-using-source-methods.html#GUID-6039C35F-361A-430F-9015-5687F072245A">使用提取方法</a></p>
                     </li>
                     <li>
                        <p><a href="making-queries-using-source-methods.html#GUID-2DCC7EA8-B3E6-40E8-8F73-6584CD8667CA">创建立方体和旋转边缘</a></p>
                     </li>
                     <li>
                        <p><a href="making-queries-using-source-methods.html#GUID-53956A82-8350-44A3-A01C-B0D69B83EFFD">在层次结构中向上和向下钻取</a></p>
                     </li>
                     <li>
                        <p><a href="making-queries-using-source-methods.html#GUID-DB8D90EC-7527-42B3-AC6C-79CB4976DD2D">按度量值按层次排序</a></p>
                     </li>
                     <li>
                        <p><a href="making-queries-using-source-methods.html#GUID-A0ADEAE2-610C-4370-833E-4E10CB5EA925">使用NumberSource方法计算已售出单位的份额</a></p>
                     </li>
                     <li>
                        <p><a href="making-queries-using-source-methods.html#GUID-E1F9B138-7563-46A7-9D04-7B33991A156F">基于时间序列操作的选择</a></p>
                     </li>
                     <li>
                        <p><a href="making-queries-using-source-methods.html#GUID-C3436997-90D0-4C9D-9C91-1B74FD8E0638">使用参数化源对象选择一组元素</a></p>
                     </li>
                  </ul>
               </div><a id="OLAAP312"></a><a id="OLAAP311"></a><div class="props_rev_3"><a id="GUID-6039C35F-361A-430F-9015-5687F072245A" name="GUID-6039C35F-361A-430F-9015-5687F072245A"></a><h4 id="OLAAP-GUID-6039C35F-361A-430F-9015-5687F072245A" class="sect4"><span class="enumeration_section">6.3.1</span>使用提取方法</h4>
                  <div>
                     <div class="section">
                        <p><a id="d17761e2474" class="indexterm-anchor"></a><a id="d17761e2478" class="indexterm-anchor"></a>您可以使用<code class="codeph">extract</code>方法提取<code class="codeph">Source</code>的值，该值是另一个<code class="codeph">Source</code>的元素的值。如果<code class="codeph">Source</code>元素具有不是<code class="codeph">Source</code>对象的元素值，则<code class="codeph">extract</code>方法的操作类似于<code class="codeph">value</code>方法。
                        </p>
                        <p><a href="making-queries-using-source-methods.html#GUID-6039C35F-361A-430F-9015-5687F072245A__CBBBGBGC">示例6-8</a>使用<code class="codeph">extract</code>方法获取<code class="codeph">NumberSource</code>对象的值，这些对象本身就是<code class="codeph">Source</code> <code class="codeph">measDim</code>列表元素的值。每个<code class="codeph">NumberSource</code>对象代表一个度量。
                        </p>
                        <p><a id="d17761e2524" class="indexterm-anchor"></a><a id="d17761e2528" class="indexterm-anchor"></a>该示例从<code class="codeph">StringSource</code>对象中为UNITS_CUBE_AWJ多维数据集的维度的层次结构选择元素。<code class="codeph">cost</code> ， <code class="codeph">units</code>和<code class="codeph">sales</code>对象是多维数据集的COST，UNITS和SALES度量的<code class="codeph">NumberSource</code>对象。
                        </p>
                        <p><a id="d17761e2550" class="indexterm-anchor"></a>接下来，该示例创建<code class="codeph">measDim</code> ，它是一个列表<code class="codeph">Source</code> ，它具有三个<code class="codeph">NumberSource</code>对象作为元素值。然后使用<code class="codeph">extract</code>方法获取<code class="codeph">NumberSource</code>对象的值。生成的未命名<code class="codeph">Source</code>具有<code class="codeph">measDim</code>作为提取输入。第一个连接操作将<code class="codeph">measDim.extract()</code>作为基础<code class="codeph">Source</code> 。基本<code class="codeph">Source</code>的输入与<code class="codeph">measDim</code>匹配， <code class="codeph">measDim</code>是<code class="codeph">joined</code>参数。然后，该示例通过连接维度选择来匹配度量的其他输入，以生成<code class="codeph">result</code> <code class="codeph">Source</code> 。
                        </p>
                     </div>
                     <!-- class="section" -->
                     <div class="example" id="GUID-6039C35F-361A-430F-9015-5687F072245A__CBBBGBGC">
                        <p class="titleinexample">例6-8使用提取方法</p><pre class="oac_no_warn" dir="ltr">Source prodSel = prodHier.selectValues（new String [] {“PRODUCT_PRIMARY :: ITEM :: ENVY STD”，“PRODUCT_PRIMARY :: ITEM :: ENVY EXE”，“PRODUCT_PRIMARY :: ITEM :: ENVY ABM”}）; Source chanSel = chanHier.selectValue（“CHANNEL_PRIMARY :: CHANNEL :: DIR”）;源timeSel = timeHier.selectValue（“CALENDAR_YEAR :: MONTH :: 2001.05”）;来源custSel = custHier.selectValue（“SHIPMENTS :: TOTAL_CUSTOMER :: TOTAL”）;来源measDim = dp.createListSource（new Source [] {cost，units，sales}）;源结果= measDim.extract（）。join（measDim）//列.join（prodSel）// row .join（timeSel）// page .join（chanSel）// page .join（custSel）; //页面</pre><p>以下交叉表显示<code class="codeph">result</code> <code class="codeph">Source</code>的<code class="codeph">Cursor</code>值，并添加了标题和格式。
                        </p><pre class="oac_no_warn" dir="ltr">发货:: TOTAL_CUSTOMER :: TOTAL CHANNEL_PRIMARY :: CHANNEL :: DIR CALENDAR_YEAR :: MONTH :: 2001.05项目成本单位销售金额-------- ---------- ----- ----- ------------- ENVY ABM 73,316.10 26 77,825.54 ENVY EXE 111,588.30 37 116,470.45 ENVY STD 92,692.47 39 93,429.57</pre></div>
                     <!-- class="example" -->
                  </div>
               </div><a id="OLAAP314"></a><a id="OLAAP313"></a><div class="props_rev_3"><a id="GUID-2DCC7EA8-B3E6-40E8-8F73-6584CD8667CA" name="GUID-2DCC7EA8-B3E6-40E8-8F73-6584CD8667CA"></a><h4 id="OLAAP-GUID-2DCC7EA8-B3E6-40E8-8F73-6584CD8667CA" class="sect4"><span class="enumeration_section">6.3.2</span>创建立方体和旋转边缘</h4>
                  <div>
                     <div class="section">
                        <p>一种典型的OLAP操作是创建多维数据集，该多维数据集是多维数据数组。多维数据集的数据由多维数据集的列，行和页面边缘的元素指定。多维数据集的数据可以是来自度量维度成员指定的度量的数据。多维数据集数据也可以是由度量数据的某些计算指定的维度成员，例如单位销售数量大于指定数量的产品。</p>
                        <p><a id="d17761e2657" class="indexterm-anchor"></a><a id="d17761e2661" class="indexterm-anchor"></a><a id="d17761e2665" class="indexterm-anchor"></a><a id="d17761e2669" class="indexterm-anchor"></a><a id="d17761e2673" class="indexterm-anchor"></a><a id="d17761e2677" class="indexterm-anchor"></a><a id="d17761e2681" class="indexterm-anchor"></a><a id="d17761e2685" class="indexterm-anchor"></a><a id="d17761e2689" class="indexterm-anchor"></a><a id="d17761e2691" class="indexterm-anchor"></a><a id="d17761e2693" class="indexterm-anchor"></a><a id="d17761e2698" class="indexterm-anchor"></a><a id="d17761e2702" class="indexterm-anchor"></a>本主题中的大多数示例都创建了多维数据集。<a href="making-queries-using-source-methods.html#GUID-2DCC7EA8-B3E6-40E8-8F73-6584CD8667CA__CBAGDGHE">例6-9</a>创建了一个多维数据集，其中包含作为多维数据集数据销售的单位数量。列边缘值最初来自通道维度层次结构，行边缘值来自时间维度层次结构，页面边缘值来自产品和客户维度的层次结构。页面边缘上的产品和客户成员值由参数化的<code class="codeph">Source</code>对象表示。
                        </p>
                        <p>该示例将层次结构成员的选择连接到维度的短值描述属性，以便结果包括属性值。然后，该示例将从层次结构派生的<code class="codeph">Source</code>对象连接到度量的<code class="codeph">Source</code> ，以生成<code class="codeph">cube</code>查询。它提交当前的<code class="codeph">Transaction</code> ，然后为查询创建<code class="codeph">Cursor</code>并显示值。
                        </p>
                        <p>在显示<code class="codeph">Cursor</code>的值之后，该示例更改了客户选择的参数化<code class="codeph">Source</code>的<code class="codeph">Parameter</code>的值，从而在同一<code class="codeph">Transaction</code>使用相同的<code class="codeph">Cursor</code>检索不同的结果集。该示例重置的位置<code class="codeph">Cursor</code> ，并且显示的值<code class="codeph">Cursor</code>一次。
                        </p>
                        <p>然后，该示例将对列和行边进行旋转，以使列值为时间成员，行值为通道成员。它提交<code class="codeph">Transaction</code> ，为查询创建另一个<code class="codeph">Cursor</code> ，并显示值。然后它会更改每个<code class="codeph">Parameter</code>对象的值并再次显示<code class="codeph">Cursor</code>的值。
                        </p>
                        <p><code class="codeph">dp</code>对象是<code class="codeph">DataProvider</code> 。<code class="codeph">getContext</code>方法获取一个<code class="codeph">Context11g</code>对象，该对象具有一个以交叉表格式显示<code class="codeph">Cursor</code>值的方法。
                        </p>
                     </div>
                     <!-- class="section" -->
                     <div class="example" id="GUID-2DCC7EA8-B3E6-40E8-8F73-6584CD8667CA__CBAGDGHE">
                        <p class="titleinexample">示例6-9创建多维数据集并旋转边缘</p><pre class="oac_no_warn" dir="ltr">//使用来自CUSTOMER_AWJ和PRODUCT_AWJ维度的层次结构//的值创建参数对象。StringParameter custParam = new StringParameter（dp，“SHIPMENTS :: REGION :: EMEA”）; StringParameter prodParam = new StringParameter（dp，“PRODUCT_PRIMARY :: FAMILY :: LTPC”）; //使用Parameter对象创建参数化的Source对象。来源custParamSrc = custParam.createSource（）; Source prodParamSrc = prodParam.createSource（）; //使用参数//对象作为连接操作中的比较，从层次结构中选择单个值。源paramCustSel = custHier.join（custHier.value（），custParamSrc）;源paramProdSel = prodHier.join（prodHier.value（），prodParamSrc）; //从度量的其他维度中选择成员。源timeSel = timeHier.selectValues（new String [] {“CALENDAR_YEAR :: YEAR :: CY1999”“CALENDAR_YEAR :: YEAR :: CY2000”，“CALENDAR_YEAR :: YEAR :: CY2001”}）; Source chanSel = chanHier.selectValues（new String [] {“CHANNEL_PRIMARY :: CHANNEL :: DIR”，“CHANNEL_PRIMARY :: CHANNEL :: CAT”，“CHANNEL_PRIMARY :: CHANNEL :: INT”}）; //将层次结构选择加入到维度的简短描述属性中。Source columnEdge = chanSel.join（chanShortDescr）;源rowEdge = timeSel.join（timeShortDescr）; Source page1 = paramProdSel.join（prodShortDescr）; Source page2 = paramCustSel.join（custShortDescr）; //将维度选择加入度量。Source cube = units.join（columnEdge）.join（rowEdge）.join（page2）.join（page1）; //以下方法提交当前Transaction。的getContext（）提交（）; //为查询创建一个Cursor。CursorManager cursorMngr = dp.createCursorManager（cube）; CompoundCursor cubeCursor =（CompoundCursor）cursorMngr.createCursor（）; //将Cursor的值显示为交叉表。。的getContext（）displayCursorAsCrosstab（cubeCursor）; //更改客户参数值。custParam.setValue（ “SHIPMENTS :: REGION :: AMER”）; //将光标位置重置为1并再次显示值。cubeCursor.setPosition（1）;的println（）; 。的getContext（）displayCursorAsCrosstab（cubeCursor）; //旋转列和行边缘。columnEdge = timeSel.join（timeShortDescr）; rowEdge = chanSel.join（chanShortDescr）; //将维度选择加入度量。cube = units.join（columnEdge）.join（rowEdge））。join（page2）.join（page1）; //提交当前的交易。的getContext（）提交（）; //创建另一个光标。cursorMngr = dp.createCursorManager（cube）; cubeCursor =（CompoundCursor）cursorMngr.createCursor（）; 。的getContext（）displayCursorAsCrosstab（cubeCursor）; //更改产品参数值。prodParam.setValue（ “PRODUCT_PRIMARY :: FAMILY :: DTPC”）; //将Cursor位置重置为1 cubeCursor.setPosition（1）;的println（）; 。的getContext（）displayCursorAsCrosstab（cubeCursor）;</pre><p>以下交叉表具有由第一个<code class="codeph">displayCursorAsCrosstab</code>方法显示的<code class="codeph">cubeCursor</code>值。
                        </p><pre class="oac_no_warn" dir="ltr">便携式PC欧洲目录直销互联网1999 1986 86 0 2000 1777 193 10 2001 1449 196 215</pre><p>在示例更改了<code class="codeph">custParam</code> <code class="codeph">Parameter</code>对象的值之后，以下交叉表具有<code class="codeph">cubeCursor</code>的值。
                        </p><pre class="oac_no_warn" dir="ltr">便携式PC北美目录直销互联网1999 6841 385 0 2000 6457 622 35 2001 5472 696 846</pre><p>在旋转列和行边缘之后，下一个交叉表具有<code class="codeph">cubeCursor</code>的值。
                        </p><pre class="oac_no_warn" dir="ltr">便携式PC北美1999 2000 2001目录6841 6457 5472直接销售385 622 696互联网0 35 846</pre><p>更改<code class="codeph">prodParam</code> <code class="codeph">Parameter</code>对象的值后，最后一个交叉表具有<code class="codeph">cubeCursor</code>的值。
                        </p><pre class="oac_no_warn" dir="ltr">台式电脑北美1999 2000 2001目录14057 13210 11337直销793 1224 1319互联网0 69 1748</pre></div>
                     <!-- class="example" -->
                  </div>
               </div><a id="OLAAP316"></a><a id="OLAAP315"></a><div class="props_rev_3"><a id="GUID-53956A82-8350-44A3-A01C-B0D69B83EFFD" name="GUID-53956A82-8350-44A3-A01C-B0D69B83EFFD"></a><h4 id="OLAAP-GUID-53956A82-8350-44A3-A01C-B0D69B83EFFD" class="sect4"><span class="enumeration_section">6.3.3</span>在层次结构中向上和向下钻取</h4>
                  <div>
                     <div class="section">
                        <p><a id="d17761e2871" class="indexterm-anchor"></a><a id="d17761e2875" class="indexterm-anchor"></a><a id="d17761e2879" class="indexterm-anchor"></a><a id="d17761e2883" class="indexterm-anchor"></a><a id="d17761e2887" class="indexterm-anchor"></a><a id="d17761e2891" class="indexterm-anchor"></a>在维度层次结构中向上或向下钻取是另一种典型的OLAP操作。<a href="making-queries-using-source-methods.html#GUID-53956A82-8350-44A3-A01C-B0D69B83EFFD__CBBGEGFA">示例6-10</a>演示了获取维度层次结构的一个级别的成员，选择成员，然后获取该成员的父级，子级和祖先。该示例通过反转父关系来生成<code class="codeph">prodHierChildren</code> <code class="codeph">Source</code> ，从而获取父项的子<code class="codeph">prodHierChildren</code> 。
                        </p>
                        <p>该示例使用以下对象。</p>
                     </div>
                     <!-- class="section" -->
                     <div class="section">
                        <ul style="list-style-type:disc">
                           <li>
                              <p><code class="codeph">levelSrc</code> ，它是PRODUCT_AWJ维度的PRODUCT_PRIMARY层次结构的FAMILY级别的<code class="codeph">Source</code> 。
                              </p>
                           </li>
                           <li>
                              <p><code class="codeph">prodHier</code> ，它是PRODUCT_PRIMARY层次结构的<code class="codeph">Source</code> 。
                              </p>
                           </li>
                           <li>
                              <p><code class="codeph">prodHierParentAttr</code> ，它是层次结构的父属性的<code class="codeph">Source</code> 。
                              </p>
                           </li>
                           <li>
                              <p><code class="codeph">prodHierAncsAttr</code> ，它是层次结构的祖先属性的<code class="codeph">Source</code> 。
                              </p>
                           </li>
                           <li>
                              <p><code class="codeph">prodShortLabel</code> ，它是PRODUCT_AWJ维度的短值描述属性的<code class="codeph">Source</code> 。
                              </p>
                           </li>
                        </ul>
                     </div>
                     <!-- class="section" -->
                     <div class="example" id="GUID-53956A82-8350-44A3-A01C-B0D69B83EFFD__CBBGEGFA">
                        <p class="titleinexample">示例6-10在层次结构中钻取</p><pre class="oac_no_warn" dir="ltr">int pos = 5; //在级别Source的指定位置获取元素。Source levelElement = levelSrc.at（pos）; //获取关卡成员的祖先。Source levelElementAncs = prodHierAncsAttr.join（prodHier，levelElement）; //获取关卡成员的父级。Source levelElementParent = prodHierParentAttr.join（prodHier，levelElement）; //获得父母的孩子。来源prodHierChildren = prodHier.join（prodHierParentAttr，prodHier.value（））; //选择级别成员的子级。Source levelElementChildren = prodHierChildren.join（prodHier，levelElement）; //获取关卡成员的简短值描述。Source levelSrcWithShortDescr = prodShortLabel.join（levelSrc）; //获取子项的简短值描述。Source levelElementChildrenWithShortDescr = prodShortLabel.join（levelElementChildren）; //获取父母的简短值描述。Source levelElementParentWithShortDescr = prodShortLabel.join（prodHier，levelElementParent，true）; //获取祖先的简短值描述。Source levelElementAncsWithShortDescr = prodShortLabel.join（prodHier，levelElementAncs，true）; //提交当前的交易。的getContext（）提交（）; //创建Cursor对象并显示它们的值。println（“Level Source元素值：”）; 。的getContext（）displayResult（levelSrcWithShortDescr）; println（“\ nLevel Source element at position”+ pos +“：”）;的getContext（）displayResult（levelElement）。 println（“\ n级别成员的父级：”）; 。的getContext（）displayResult（levelElementParentWithShortDescr）; println（“\ nChildren of level member：”）; 。的getContext（）displayResult（levelElementChildrenWithShortDescr）; println（“\ n级别成员的先驱：”）; 。的getContext（）displayResult（levelElementAncsWithShortDescr）;</pre><p>以下列表包含<code class="codeph">displayResults</code>方法创建的<code class="codeph">Cursor</code>对象的值。
                        </p><pre class="oac_no_warn" dir="ltr">Level Source元素值：PRODUCT_PRIMARY :: FAMILY :: ACC，附件PRODUCT_PRIMARY :: FAMILY :: DISK，CD / DVD PRODUCT_PRIMARY :: FAMILY :: DOC，文档PRODUCT_PRIMARY :: FAMILY :: DTPC，Portable PC PRODUCT_PRIMARY :: FAMILY :: LTPC，台式电脑PRODUCT_PRIMARY :: FAMILY :: MEM，Memory PRODUCT_PRIMARY :: FAMILY :: MOD，调制解调器/传真PRODUCT_PRIMARY :: FAMILY :: MON，监控PRODUCT_PRIMARY :: FAMILY :: OS，操作系统级别位置元素位置5： PRODUCT_PRIMARY :: FAMILY：LTPC级别成员的父级：PRODUCT_PRIMARY :: CLASS :: HRD，硬件级别成员的子女：PRODUCT_PRIMARY :: ITEM :: ENVY ABM，Envoy Ambassador PRODUCT_PRIMARY :: ITEM :: ENVY EXE，Envoy Executive PRODUCT_PRIMARY :: ITEM :: ENVY STD，特使标准祖先级别成员：PRODUCT_PRIMARY :: TOTAL_PRODUCT :: TOTAL，总产品PRODUCT_PRIMARY :: CLASS :: HRD，硬件PRODUCT_PRIMARY :: FAMILY :: LTPC，Portable PC</pre></div>
                     <!-- class="example" -->
                  </div>
               </div><a id="OLAAP318"></a><a id="OLAAP317"></a><div class="props_rev_3"><a id="GUID-DB8D90EC-7527-42B3-AC6C-79CB4976DD2D" name="GUID-DB8D90EC-7527-42B3-AC6C-79CB4976DD2D"></a><h4 id="OLAAP-GUID-DB8D90EC-7527-42B3-AC6C-79CB4976DD2D" class="sect4"><span class="enumeration_section">6.3.4</span>按度量值分层次排序</h4>
                  <div>
                     <div class="section">
                        <p><a id="d17761e3002" class="indexterm-anchor"></a><a id="d17761e3006" class="indexterm-anchor"></a><a id="d17761e3010" class="indexterm-anchor"></a><a id="d17761e3014" class="indexterm-anchor"></a> <a href="making-queries-using-source-methods.html#GUID-DB8D90EC-7527-42B3-AC6C-79CB4976DD2D__CBBJDIAC">示例6-11</a>使用<code class="codeph">recursiveJoin</code>方法按UNITS度量值的升序分层次地对PRODUCT_AWJ维度的PRODUCT_PRIMARY层次结构的成员进行排序。该示例将已排序的产品连接到维度的短值描述属性，然后将该操作的结果<code class="codeph">sortedProductsShortDescr</code>到<code class="codeph">units</code> 。
                        </p>
                        <p>连续的<code class="codeph">joinHidden</code>方法连接<code class="codeph">units</code>的其他维度的选择以生成<code class="codeph">result</code> <code class="codeph">Source</code> ，其具有作为元素值的measure数据和作为输出的<code class="codeph">sortedProductsShortDescr</code> 。该示例使用<code class="codeph">joinHidden</code>方法，以便其他维度选择不是结果的输出。
                        </p>
                        <p>该示例使用以下对象。</p>
                     </div>
                     <!-- class="section" -->
                     <div class="section">
                        <ul style="list-style-type:disc">
                           <li>
                              <p><code class="codeph">prodHier</code> ，它是PRODUCT_PRIMARY层次结构的<code class="codeph">Source</code> 。
                              </p>
                           </li>
                           <li>
                              <p><code class="codeph">units</code> ，它是<code class="codeph">Source</code>售出的产品单元的计量单位。
                              </p>
                           </li>
                           <li>
                              <p><code class="codeph">prodParentAttr</code> ，它是PRODUCT_PRIMARY层次结构的父属性的<code class="codeph">Source</code> 。
                              </p>
                           </li>
                           <li>
                              <p><code class="codeph">prodShortDescr</code> ，它是PRODUCT_AWJ维度的短值描述属性的<code class="codeph">Source</code> 。
                              </p>
                           </li>
                           <li>
                              <p><code class="codeph">custSel</code> ，它是一个<code class="codeph">Source</code> ，它指定CUSTOMER_AWJ维度的SHIPMENTS层次结构的单个成员。该成员是<code class="codeph">SHIPMENTS::TOTAL_CUSTOMER::TOTAL</code> ，这是所有客户的总数。
                              </p>
                           </li>
                           <li>
                              <p><code class="codeph">chanSel</code> ，它是一个<code class="codeph">Source</code> ，它指定CHANNEL_AWJ维度的CHANNEL_PRIMARY层次结构的单个成员。成员值为<code class="codeph">CHANNEL_PRIMARY::CHANNEL::DIR</code> ，这是直接销售渠道。
                              </p>
                           </li>
                           <li>
                              <p><code class="codeph">timeSel</code> ，它是一个<code class="codeph">Source</code> ，用于指定TIME_AWJ维度的CALENDAR_YEAR层次结构的单个成员。该成员是<code class="codeph">CALENDAR_YEAR::YEAR::CY2001</code> ，即2001年。
                              </p>
                           </li>
                        </ul>
                     </div>
                     <!-- class="section" -->
                     <div class="example" id="GUID-DB8D90EC-7527-42B3-AC6C-79CB4976DD2D__CBBJDIAC">
                        <p class="titleinexample">示例6-11按度量值进行分层排序</p><pre class="oac_no_warn" dir="ltr">Source sortedProduct = prodHier.recursiveJoin（单位， <a id="d17761e3124" class="indexterm-anchor"></a> units.getDataType（），prodParentAttr，Source。COMPARISON_RULE_ASCENDING，true，//父母先是真的）; //将父级限制为基础Source sortedProductShortDescr = prodShortDescr.join（sortedProduct）; Source result = units.join（sortedProductShortDescr）.joinHidden（custSel）.joinHidden（chanSel）.joinHidden（timeSel）;</pre><p><code class="codeph">result</code> <code class="codeph">Source</code> <code class="codeph">Cursor</code>具有以下值，显示在添加了列标题和格式的表中。左列具有<code class="codeph">PRODUCT_PRIMARY</code>层次结构中的级别名称。右侧的下一列具有产品标识值，下一列具有产品的短值描述。最右边的栏目是通过直销渠道在2001年向所有客户销售的产品的单位数量。
                        </p>
                        <p>该表仅包含<code class="codeph">Cursor</code>的前九个和后十一个值，以及Software / Other类值。产品值按层次排列并按销售单位按升序排列。Hardware类出现在Software / Other类之前，因为Software / Other类具有更多的单位销售量。在硬件类中，便携式PC系列销售的设备数量最少，因此它首先出现。在软件/其他类中，附件系列销售的单元数量最多，因此它最后出现。
                        </p><pre class="oac_no_warn" dir="ltr">产品等级ID说明已售出的单位------------- ------------ ------------------- ---------- ---------- TOTAL_PRODUCT TOTAL总产品43,485 CLASS HRD硬件16,543家庭LTPC便携式电脑1,192 ITEM ENVY ABM特使大使330 ITEM ENVY EXE特使执行官385 ITEM ENVY STD特使标准477 FAMILY MON监视器1,193项19 SVGA监视器 -  19“Super VGA 207 ITEM 17 SVGA监视器 -  17”Super VGA 986 ...CLASS SFT软件/其他）27,242 ......FAMILY ACC配件18,949 ITEM ENVY EXT KBD特使外部键盘146 ITEM EXT KBD外部101键键盘678 ITEM MM SPKR 5多媒体扬声器 -  5“锥体717 ITEM STD MOUSE标准鼠标868 ITEM MM SPKR 3多媒体扬声器 -  3”锥体1,120项目144MB磁盘1.44MB外置3.5“软盘1,145 TEM KBRD REST键盘腕托2,231 ITEM LT CASE笔记本电脑便携包3,704 ITEM DLX MOUSE豪华鼠标3,884 ITEM MOUSE PAD鼠标垫4,456</pre></div>
                     <!-- class="example" -->
                  </div>
               </div><a id="OLAAP320"></a><a id="OLAAP319"></a><div class="props_rev_3"><a id="GUID-A0ADEAE2-610C-4370-833E-4E10CB5EA925" name="GUID-A0ADEAE2-610C-4370-833E-4E10CB5EA925"></a><h4 id="OLAAP-GUID-A0ADEAE2-610C-4370-833E-4E10CB5EA925" class="sect4"><span class="enumeration_section">6.3.5</span>使用NumberSource方法计算出售单位的份额</h4>
                  <div>
                     <div class="section">
                        <p><a id="d17761e3188" class="indexterm-anchor"></a><a id="d17761e3192" class="indexterm-anchor"></a><a id="d17761e3196" class="indexterm-anchor"></a><a id="d17761e3200" class="indexterm-anchor"></a><a id="d17761e3204" class="indexterm-anchor"></a> <a href="making-queries-using-source-methods.html#GUID-A0ADEAE2-610C-4370-833E-4E10CB5EA925__CBBDDCAH">示例6-12</a>使用<code class="codeph">NumberSource</code>方法<code class="codeph">div</code>和<code class="codeph">times</code>来生成一个<code class="codeph">Source</code> ，该<code class="codeph">Source</code>指定Desktop PC和Portable PC系列在所选时间，客户和通道值中销售的产品单元总数的份额。示例性的第一使用<code class="codeph">selectValue</code>的方法<code class="codeph">prodHier</code> ，它是<code class="codeph">Source</code>的PRODUCT_AWJ维度的层次结构，以产生<code class="codeph">totalProds</code> ，其指定与所述值的单个元件<code class="codeph">PRODUCT_PRIMARY::TOTAL_PRODUCT::TOTAL</code> ，这是的最高总体水平层次结构。
                        </p>
                        <p><a id="d17761e3240" class="indexterm-anchor"></a>所述<code class="codeph">joinHidden</code>所述的方法<code class="codeph">NumberSource</code> <code class="codeph">units</code>产生<code class="codeph">totalUnits</code> ，它指定了UNITS测量值在总产物的水平，而不必<code class="codeph">totalProds</code>出现的输出<code class="codeph">totalUnits</code> 。然后， <code class="codeph">units</code>的<code class="codeph">div</code>方法生成一个<code class="codeph">Source</code> ，表示每个单位的销售价值除以销售的单位总数。然后， <code class="codeph">times</code>方法将该<code class="codeph">div</code>运算的结果乘以100以生成<code class="codeph">productShare</code> ，其表示产品成员具有的总销售量的百分比或份额。<code class="codeph">productShare</code> <code class="codeph">Source</code>将<code class="codeph">units</code>的输入作为输入进行测量。
                        </p>
                        <p><code class="codeph">prodFamilies</code>对象是PRODUCT_PRIMARY层次结构的FAMILY级别的<code class="codeph">Source</code> 。<code class="codeph">productShare</code>的<code class="codeph">join</code>方法（ <code class="codeph">prodFamilies</code>作为已连接的<code class="codeph">Source</code> ）生成一个<code class="codeph">Source</code> ，用于指定每个产品系列对销售产品总数的份额。
                        </p>
                        <p><code class="codeph">custSel</code> ， <code class="codeph">chanSel</code>和<code class="codeph">timeSel</code> <code class="codeph">Source</code>对象是CUSTOMER_AWJ，CHANNEL_AWJ和TIME_AWJ维度的单个层次结构成员的选择。其余的<code class="codeph">join</code>方法将这些<code class="codeph">Source</code>对象与<code class="codeph">productShare</code>的其他输入匹配，以生成<code class="codeph">result</code> 。<code class="codeph">join</code>方法的<code class="codeph">join(Source joined, String comparison)</code>签名生成一个<code class="codeph">Source</code> ，该<code class="codeph">Source</code>没有连接的<code class="codeph">Source</code>作为输出。
                        </p>
                        <p><code class="codeph">result</code> <code class="codeph">Source</code>指定每个产品系列在2001年通过直销渠道销售给所有客户的产品总数的份额。
                        </p>
                     </div>
                     <!-- class="section" -->
                     <div class="example" id="GUID-A0ADEAE2-610C-4370-833E-4E10CB5EA925__CBBDDCAH">
                        <p class="titleinexample">示例6-12获取已售出单位的份额</p><pre class="oac_no_warn" dir="ltr">来源totalProds = prodHier.selectValue（“PRODUCT_PRIMARY :: TOTAL_PRODUCT :: TOTAL”）; NumberSource totalUnits =（NumberSource）units.joinHidden（totalProds）;来源productShare = units.div（totalUnits）.times（100）;源结果= productShare.join（prodFamilies）.join（timeHier，“CALENDAR_YEAR :: YEAR :: CY2001”）。join（chanHier，“CHANNEL_PRIMARY :: CHANNEL :: DIR”）。join（custHier，“SHIPMENTS :: TOTAL_CUSTOMER： ：总”）; Source sortedResult = result.sortAscending（）;</pre><p><code class="codeph">sortedResult</code> <code class="codeph">Source</code> <code class="codeph">Cursor</code>具有以下值，显示在添加了列标题和格式的表中。左栏具有产品系列值，右栏具有2001年通过直销渠道向所有客户销售的产品系列总单位数的份额。
                        </p><pre class="oac_no_warn" dir="ltr">产品系列成员占销售总量的份额----------------------------- ------------- ------------ PRODUCT_PRIMARY :: FAMILY :: LTPC 2.72％PRODUCT_PRIMARY :: FAMILY :: MON 2.73％PRODUCT_PRIMARY :: FAMILY :: MEM 3.57％PRODUCT_PRIMARY :: FAMILY :: DTPC 5.13％PRODUCT_PRIMARY： ：FAMILY :: DOC 6.4％PRODUCT_PRIMARY :: FAMILY :: DISK 11.71％PRODUCT_PRIMARY :: FAMILY :: MOD 11.92％PRODUCT_PRIMARY :: FAMILY :: OS 12.54％PRODUCT_PRIMARY :: FAMILY :: ACC 43.28％</pre></div>
                     <!-- class="example" -->
                  </div>
               </div><a id="OLAAP322"></a><a id="OLAAP323"></a><a id="OLAAP321"></a><div class="props_rev_3"><a id="GUID-E1F9B138-7563-46A7-9D04-7B33991A156F" name="GUID-E1F9B138-7563-46A7-9D04-7B33991A156F"></a><h4 id="OLAAP-GUID-E1F9B138-7563-46A7-9D04-7B33991A156F" class="sect4"><span class="enumeration_section">6.3.6</span>基于时间序列操作的选择</h4>
                  <div>
                     <div class="section">
                        <p><a id="d17761e3422" class="indexterm-anchor"></a><a id="d17761e3426" class="indexterm-anchor"></a><a id="d17761e3430" class="indexterm-anchor"></a><a id="d17761e3434" class="indexterm-anchor"></a><a id="d17761e3438" class="indexterm-anchor"></a>本主题有使用上的一系列的元素进行操作的方法的两个例子<code class="codeph">MdmLevelHierarchy</code>为TIME_AWJ尺寸的CALENDAR_YEAR层次。<a href="making-queries-using-source-methods.html#GUID-E1F9B138-7563-46A7-9D04-7B33991A156F__CBBHGDGG">例6-13</a>使用<code class="codeph">unitPrice</code>的<code class="codeph">lag</code>方法（它是UNIT_PRICE度量的<code class="codeph">Source</code>来生成<code class="codeph">unitPriceLag4</code> ，它为<code class="codeph">unitPrice</code>每个元素指定与层次结构的成员匹配的<code class="codeph">unitPrice</code>元素与层次结构匹配在层次结构中处于同一级别的四个时间段的成员。
                        </p>
                        <p>在示例中， <code class="codeph">dp</code>是<code class="codeph">DataProvider</code> 。<code class="codeph">createListSource</code>方法创建<code class="codeph">measuresDim</code> ，它具有<code class="codeph">unitPrice</code>和<code class="codeph">unitPriceLag4</code> <code class="codeph">Source</code>对象作为元素值。<code class="codeph">measuresDim</code>的<code class="codeph">extract</code>方法获取<code class="codeph">measuresDim</code>元素的值。<code class="codeph">extract</code>方法生成的<code class="codeph">Source</code>具有<code class="codeph">measuresDim</code>作为提取输入。第一个<code class="codeph">join</code>方法将<code class="codeph">Source</code> ， <code class="codeph">measuresDim</code>与<code class="codeph">extract</code>方法返回的<code class="codeph">Source</code>的输入相匹配。
                        </p>
                        <p><code class="codeph">unitPrice</code>和<code class="codeph">unitPriceLag4</code>度量都将PRODUCT_AWJ和TIME_AWJ维度的<code class="codeph">Source</code>对象作为输入。第二个<code class="codeph">join</code>方法匹配<code class="codeph">quarterLevel</code> ，它是TIME_AWJ维度的CALENDAR_YEAR层次结构的QUARTER级别的<code class="codeph">Source</code> ，以及度量的TIME_AWJ维度输入，并使其成为生成的<code class="codeph">Source</code>的输出。
                        </p>
                        <p><a id="d17761e3551" class="indexterm-anchor"></a> <code class="codeph">joinHidden</code>方法将<code class="codeph">prodSel</code>与度量的PRODUCT_AWJ维度输入进行匹配，并且不会使<code class="codeph">prodSel</code>成为生成的<code class="codeph">Source</code>的输出。<code class="codeph">prodSel</code> <code class="codeph">Source</code>指定单个层次结构成员<code class="codeph">PRODUCT_PRIMARY::FAMILY::DTPC</code> ，即台式PC。</p>
                        <p><code class="codeph">lagResult</code> <code class="codeph">Source</code>指定桌面PC产品系列的每个季度和四个季度前的季度的总单价。
                        </p>
                     </div>
                     <!-- class="section" -->
                     <div class="example" id="GUID-E1F9B138-7563-46A7-9D04-7B33991A156F__CBBHGDGG">
                        <p class="titleinexample">例6-13使用滞后方法</p><pre class="oac_no_warn" dir="ltr">NumberSource unitPriceLag4 = unitPrice.lag（mdmCalHier，4）; Source measuresDim = dp.createListSource（new Source [] {unitPrice，unitPriceLag4}）;源lagResult = measuresDim.extract（）。join（measuresDim）.join（quarterLevel）.joinHidden（prodSel）;</pre><p><code class="codeph">lagResult</code> <code class="codeph">Source</code> <code class="codeph">Cursor</code>具有以下值，显示在添加了列标题和格式的表中。左栏有四分之一，中间栏有该季度桌面PC系列成员的单价总和，右栏有四分之一前一季的单位价格总和。右列中的前四个值是<code class="codeph">NA</code>因为第1季度Q1-98是CALENDAR_YEAR层次结构中的第一个季度。该表仅包括前八个季度。
                        </p><pre class="oac_no_warn" dir="ltr">单价四分之一单价前四个季度--------------------------------- --------- -  -------------------- CALENDAR_YEAR :: QUARTER :: CY1998。Q1 2687.54 NA CALENDAR_YEAR :: QUARTER :: CY1998。Q2 2704.48 NA CALENDAR_YEAR :: QUARTER :: CY1998。Q3 2673.27 NA CALENDAR_YEAR :: QUARTER :: CY1998。Q4 2587.76 NA CALENDAR_YEAR :: QUARTER :: CY1999。Q1 2394.79 2687.54 CALENDAR_YEAR :: QUARTER :: CY1999。Q2 2337.18 2704.48 CALENDAR_YEAR :: QUARTER :: CY1999。Q3 2348.39 2673.27 CALENDAR_YEAR :: QUARTER :: CY1999。Q4 2177.89 2587.76 ......</pre></div>
                     <!-- class="example" -->
                     <div class="example" id="GUID-E1F9B138-7563-46A7-9D04-7B33991A156F__CBBFEDFJ">
                        <p class="titleinexample">示例6-14使用movingTotal方法</p>
                        <p><a id="d17761e3611" class="indexterm-anchor"></a><a id="d17761e3615" class="indexterm-anchor"></a><a id="d17761e3619" class="indexterm-anchor"></a>此示例使用与<a href="making-queries-using-source-methods.html#GUID-E1F9B138-7563-46A7-9D04-7B33991A156F__CBBHGDGG">示例6-13</a>相同的<code class="codeph">unitPrice</code> ， <code class="codeph">mdmCalHier</code> ， <code class="codeph">quarterLevel</code>和<code class="codeph">prodSel</code>对象，但它使用<code class="codeph">unitPriceMovingTotal</code>度量作为<code class="codeph">measuresDim</code>的第二个元素。<code class="codeph">unitPriceMovingTotal</code> <code class="codeph">Source</code>由<code class="codeph">unitPrice</code>的<code class="codeph">movingTotal</code>方法生成。该方法提供<code class="codeph">mdmCalHier</code> ，这是<code class="codeph">MdmLevelHierarchy</code>为TIME_AWJ维度的CALENDAR_YEAR层次结构中，作为<code class="codeph">dimension</code>参数和整数<code class="codeph">0</code>和<code class="codeph">3</code>作为起始和结束偏移值。
                        </p>
                        <p><code class="codeph">movingTotalResult</code> <code class="codeph">Source</code>为每个季度指定该季度Desktop PC系列成员的单位价格总和以及该单位价格加上未来三个季度的单位价格的总和。
                        </p><pre class="oac_no_warn" dir="ltr">NumberSource unitPriceMovingTotal = unitPrice.movingTotal（mdmCalHier，0,3）; Source measuresDim = dp.createListSource（new Source [] {unitPrice，unitPriceMovingTotal}）; Source movingTotalResult = measuresDim.extract（）。join（measuresDim）.join（quarterLevel）.joinHidden（prodSel）;</pre><p><code class="codeph">movingTotalResult</code> <code class="codeph">Source</code> <code class="codeph">Cursor</code>具有以下值，显示在添加了列标题和格式的表中。左栏有四分之一，中间列有该季度桌面PC系列成员的单价总和，左栏有该季度和接下来三个季度的单价总和。该表仅包括前八个季度。
                        </p><pre class="oac_no_warn" dir="ltr">单位价格移动总季度单位价格当前加上下三个时期--------------------------------- ----- ----- ------------------------------- CALENDAR_YEAR :: QUARTER :: CY1998。Q1 2687.54 10653.05 CALENDAR_YEAR :: QUARTER :: CY1998。Q2 2704.48 10360.30 CALENDAR_YEAR :: QUARTER :: CY1998。Q3 2673.27 9993.00 CALENDAR_YEAR :: QUARTER :: CY1998。Q4 2587.76 9668.12 CALENDAR_YEAR :: QUARTER :: CY1999。Q1 2394.79 9258.25 CALENDAR_YEAR :: QUARTER :: CY1999。Q2 2337.18 8911.87 CALENDAR_YEAR :: QUARTER :: CY1999。Q3 2348.39 8626.48 CALENDAR_YEAR :: QUARTER :: CY1999。Q4 2177.89 8291.37 ......</pre></div>
                     <!-- class="example" -->
                  </div>
               </div><a id="OLAAP325"></a><a id="OLAAP324"></a><div class="props_rev_3"><a id="GUID-C3436997-90D0-4C9D-9C91-1B74FD8E0638" name="GUID-C3436997-90D0-4C9D-9C91-1B74FD8E0638"></a><h4 id="OLAAP-GUID-C3436997-90D0-4C9D-9C91-1B74FD8E0638" class="sect4"><span class="enumeration_section">6.3.7</span>使用参数化源对象选择一组元素</h4>
                  <div>
                     <div class="section">
                        <p><a id="d17761e3734" class="indexterm-anchor"></a><a id="d17761e3738" class="indexterm-anchor"></a><a id="d17761e3742" class="indexterm-anchor"></a><a id="d17761e3746" class="indexterm-anchor"></a><a id="d17761e3750" class="indexterm-anchor"></a><a id="d17761e3754" class="indexterm-anchor"></a><a id="d17761e3758" class="indexterm-anchor"></a> <a href="making-queries-using-source-methods.html#GUID-C3436997-90D0-4C9D-9C91-1B74FD8E0638__CBBCFEBC">例6-15</a>使用<code class="codeph">NumberParameter</code>对象创建参数化的<code class="codeph">Source</code>对象。这些对象是<code class="codeph">prodHier</code>的<code class="codeph">interval</code>方法的<code class="codeph">bottom</code>和<code class="codeph">top</code>参数。该方法返回<code class="codeph">paramProdSelInterval</code> ，它是一个<code class="codeph">Source</code> ， <code class="codeph">prodHier</code>从层次结构的<code class="codeph">bottom</code>位置到<code class="codeph">top</code>位置指定<code class="codeph">prodHier</code>的元素集。
                        </p>
                        <p>产品<code class="codeph">Source</code>的元素指定出现在<code class="codeph">result</code> <code class="codeph">Source</code>中的<code class="codeph">units</code>度量的元素。通过更改<code class="codeph">Parameter</code>对象的值，您可以使用相同的<code class="codeph">Cursor</code>选择一组不同的单位销售值，而无需生成新的<code class="codeph">Source</code>和<code class="codeph">Cursor</code>对象。
                        </p>
                        <p>该示例使用以下对象。</p>
                     </div>
                     <!-- class="section" -->
                     <div class="section">
                        <ul style="list-style-type:disc">
                           <li>
                              <p><code class="codeph">dp</code> ，这是会话的<code class="codeph">DataProvider</code> 。
                              </p>
                           </li>
                           <li>
                              <p><code class="codeph">prodHier</code> ，它是PRODUCT_AWJ维度的PRODUCT_PRIMARY层次结构的<code class="codeph">Source</code> 。
                              </p>
                           </li>
                           <li>
                              <p><code class="codeph">prodShortDescr</code> ，它是PRODUCT_AWJ维度的短值描述属性的<code class="codeph">Source</code> 。
                              </p>
                           </li>
                           <li>
                              <p><code class="codeph">units</code> ，它是<code class="codeph">Source</code>售出的产品单元的计量单位。
                              </p>
                           </li>
                           <li>
                              <p><code class="codeph">chanHier</code> ，它是CHANNEL_AWJ维度的CHANNEL_PRIMARY层次结构的<code class="codeph">Source</code> 。
                              </p>
                           </li>
                           <li>
                              <p><code class="codeph">calHier</code> ，它是TIME_AWJ维度的CALENDAR_YEAR层次结构的<code class="codeph">Source</code> 。
                              </p>
                           </li>
                           <li>
                              <p><code class="codeph">shipHier</code> ，它是CUSTOMER_AWJ维度的SHIPMENTS层次结构的<code class="codeph">Source</code> 。
                              </p>
                           </li>
                           <li>
                              <p><code class="codeph">getContext</code>方法返回的<code class="codeph">Context11g</code>对象。<code class="codeph">Context11g</code>具有提交当前<code class="codeph">Transaction</code>方法，这些方法为<code class="codeph">Source</code>创建<code class="codeph">Cursor</code> ，显示文本，并显示<code class="codeph">Cursor</code>的值。
                              </p>
                           </li>
                        </ul>
                        <p><a id="d17761e3912" class="indexterm-anchor"></a><a id="d17761e3916" class="indexterm-anchor"></a> <code class="codeph">prodShortDescr</code>的<code class="codeph">join</code>方法获取<code class="codeph">paramProdSelInterval</code>元素的短值描述。接下来的四个<code class="codeph">join</code>方法将<code class="codeph">Source</code>对象与<code class="codeph">units</code> measure的输入进行匹配。该示例创建一个<code class="codeph">Cursor</code>并显示查询的结果集。接下来， <code class="codeph">resultCursor</code>的<code class="codeph">setPosition</code>方法将<code class="codeph">Cursor</code>的位置设置回第一个元素。
                        </p>
                        <p><code class="codeph">NumberParameter</code>对象的<code class="codeph">setValue</code>方法更改这些对象的值，这会更改查询指定的产品<code class="codeph">Source</code>元素的选择。然后，该示例再次显示<code class="codeph">Cursor</code>的值。
                        </p>
                     </div>
                     <!-- class="section" -->
                     <div class="example" id="GUID-C3436997-90D0-4C9D-9C91-1B74FD8E0638__CBBCFEBC">
                        <p class="titleinexample">示例6-15使用NumberParameter对象选择范围</p><pre class="oac_no_warn" dir="ltr">NumberParameter startParam = new NumberParameter（dp，1）; NumberParameter endParam = new NumberParameter（dp，6）; NumberSource startParamSrc =（NumberSource）startParam.createSource（）; NumberSource endParamSrc =（NumberSource）endParam.createSource（）;源paramProdSelInterval = prodHier.interval（startParamSrc，endParamSrc）;源paramProdSelIntervalShortDescr = prodShortDescr.join（paramProdSelInterval）; NumberSource result =（NumberSource）units.join（chanHier，“CHANNEL_PRIMARY :: CHANNEL :: INT”）。join（calHier，“CALENDAR_YEAR :: YEAR :: CY2001”）。join（shipHier，“SHIPMENTS :: TOTAL_CUSTOMER :: TOTAL” “）。join（paramProdSelIntervalShortDescr）; //提交当前事务。的getContext（）提交（）; CursorManager cursorMngr = dp.createCursorManager（result）;游标resultCursor = cursorMngr.createCursor（）; 。的getContext（）displayCursor（resultCursor）; //将光标位置重置为1。resultCursor.setPosition（1）; //更改参数化Source的值。startParam.setValue（7）; endParam.setValue（12）; //再次显示结果。。的getContext（）displayCursor（resultsCursor）;</pre><p>下表显示了<code class="codeph">resultCursor</code>的值，并添加了列标题和格式。左列具有产品层次结构成员，中间列具有短值描述，右列具有销售的单位数量。
                        </p><pre class="oac_no_warn" dir="ltr">产品描述已售出单位------------------------------------- --------- -------------- ---------- PRODUCT_PRIMARY :: TOTAL_PRODUCT :: TOTAL总产品53,572 PRODUCT_PRIMARY :: CLASS :: HRD硬件21,301 PRODUCT_PRIMARY :: FAMILY :: DISK Memory 6,634 PRODUCT_PRIMARY :: ITEM :: EXT CD ROM外部48X CD-ROM 136 PRODUCT_PRIMARY :: ITEM :: EXT DVD外部 -  DVD-RW  -  8X 1,526 PRODUCT_PRIMARY :: ITEM :: INT 8X DVD内部 -  DVD-RW  -  8X 1,543产品说明已售出单位------------------------------------- ---------- -------------------- PRODUCT_PRIMARY :: ITEM :: INT CD ROM内部48X CD-ROM 380 PRODUCT_PRIMARY :: ITEM :: INT CD USB内置48X CD- ROM USB 162 PRODUCT_PRIMARY :: ITEM :: INT RW DVD内部 -  DVD-RW  -  6X 2,887 PRODUCT_PRIMARY :: FAMILY :: DTPC台式电脑2,982 PRODUCT_PRIMARY :: ITEM :: SENT FIN Sentinel Financial 1,015 PRODUCT_PRIMARY :: ITEM :: SENT MM Sentinel多媒体875</pre></div>
                     <!-- class="example" -->
                  </div>
               </div>
            </div>
         </div>
      </article>
   </body>
</html>