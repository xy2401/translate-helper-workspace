<html lang="en-us" dir="ltr" xml:lang="en-us">
   <head>
      <meta http-equiv="Content-Type" content="text/html; charset=utf-8"></meta>
      <meta name="viewport" content="width=device-width, initial-scale=1"></meta>
      <meta http-equiv="X-UA-Compatible" content="IE=edge"></meta>
      <title>同步刷新</title>
      <meta property="og:site_name" content="Oracle Help Center"></meta>
      <meta property="og:title" content="Data Warehousing Guide"></meta>
      <meta property="og:description" content=""></meta>
      <link rel="stylesheet" href="/sp_common/book-template/ohc-book-template/css/book.css"></link>
      <link rel="shortcut icon" href="/sp_common/book-template/ohc-common/img/favicon.ico"></link>
      <meta name="application-name" content="Data Warehousing Guide"></meta>
      <meta name="generator" content="DITA Open Toolkit version 1.8.5 (Mode = doc)"></meta>
      <meta name="plugin" content="SP_docbuilder HTML plugin release 18.2.2"></meta>
      <link rel="alternate" href="database-data-warehousing-guide.pdf" title="PDF File" type="application/pdf"></link>
      <meta name="robots" content="all"></meta>
      <link rel="schema.dcterms" href="http://purl.org/dc/terms/"></link>
      <meta name="dcterms.created" content="2019-01-09T00:20:13-08:00"></meta>
      
      <meta name="dcterms.dateCopyrighted" content="2001, 2019"></meta>
      <meta name="dcterms.category" content="database"></meta>
      <meta name="dcterms.identifier" content="E96243-01"></meta>
      
      <meta name="dcterms.product" content="en/database/oracle/oracle-database/19"></meta>
      
      <link rel="prev" href="refreshing-materialized-views.html" title="Previous" type="text/html"></link>
      <link rel="next" href="monitoring-materialized-view-refresh.html" title="Next" type="text/html"></link>
      <script>
        document.write('<style type="text/css">');
        document.write('body > .noscript, body > .noscript ~ * { visibility: hidden; }');
        document.write('</style>');
     </script>
      <script src="/sp_common/book-template/requirejs/require.js" data-main="/sp_common/book-template/ohc-book-template/js/book-config"></script>
      <script>
            if (window.require === undefined) {
                document.write('<script data-main="sp_common/book-template/ohc-book-template/js/book-config" src="sp_common/book-template/requirejs/require.js"><\/script>');
                document.write('<link href="sp_common/book-template/ohc-book-template/css/book.css" rel="stylesheet"/>');
            }
        </script>
      <script type="application/json" id="ssot-metadata">{"primary":{"category":{"short_name":"database","element_name":"Database","display_in_url":true},"suite":{"short_name":"oracle","element_name":"Oracle","display_in_url":true},"product_group":{"short_name":"not-applicable","element_name":"Not applicable","display_in_url":false},"product":{"short_name":"oracle-database","element_name":"Oracle Database","display_in_url":true},"release":{"short_name":"19","element_name":"Release 19","display_in_url":true}}}</script>
      
    <meta name="dcterms.title" content="Database Data Warehousing Guide"></meta>
    <meta name="dcterms.isVersionOf" content="DWHSG"></meta>
    <meta name="dcterms.release" content="Release 19"></meta>
  </head>
   <body dir="ltr">
      <div class="noscript alert alert-danger text-center" role="alert">
         <a href="refreshing-materialized-views.html" class="pull-left"><span class="glyphicon glyphicon-chevron-left" aria-hidden="true"></span>上一页</a> <a href="monitoring-materialized-view-refresh.html" class="pull-right">下一页<span class="glyphicon glyphicon-chevron-right" aria-hidden="true"></span></a> <span class="fa fa-exclamation-triangle" aria-hidden="true"></span>必须启用JavaScript才能正确显示此内容</div>
      <article>
         <header>
            <ol class="breadcrumb" vocab="http://schema.org/" typeof="BreadcrumbList">
               <li property="itemListElement" typeof="ListItem"><a href="index.html" property="item" typeof="WebPage"><span property="name">数据仓库指南</span></a></li>
               <li property="itemListElement" typeof="ListItem"><a href="part-optimizing-dw.html" property="item" typeof="WebPage"><span property="name">优化数据仓库</span></a></li>
               <li class="active" property="itemListElement" typeof="ListItem">同步刷新</li>
            </ol>
            <a id="GUID-14730F6C-D96D-4AA3-A91E-9FBF456EC889" name="GUID-14730F6C-D96D-4AA3-A91E-9FBF456EC889"></a>
            
            <h2 id="DWHSG-GUID-14730F6C-D96D-4AA3-A91E-9FBF456EC889" class="sect2"><span class="enumeration_chapter">8</span>同步刷新</h2>
         </header>
         <div class="ind">
            <div>
               <p>本章介绍了一种将更改同步到数据仓库中的表和物化视图的方法。此方法基于同步对表和物化视图的更新，称为同步刷新。
               </p>
               <p>本章包括以下部分：</p>
               <ul style="list-style-type:disc">
                  <li>
                     <p><a href="synchronous-refresh.html#GUID-01C7861A-8A84-4ECE-9BBF-716FB5D20113">关于物化视图的同步刷新</a></p>
                  </li>
                  <li>
                     <p><a href="synchronous-refresh.html#GUID-8C78842C-8A78-4206-A303-7B74B8803A1C">对物化视图使用同步刷新</a></p>
                  </li>
                  <li>
                     <p><a href="synchronous-refresh.html#GUID-D393EB28-D659-4A0C-8BD8-B174262A27C0">使用同步刷新组</a></p>
                  </li>
                  <li>
                     <p><a href="synchronous-refresh.html#GUID-5C15E4A2-75FD-4B87-AD20-CE749676CE65">为同步刷新指定和准备更改数据</a></p>
                  </li>
                  <li>
                     <p><a href="synchronous-refresh.html#GUID-AEEB3AAA-BB56-4D8D-9F33-181F12E97AD6">同步刷新操作疑难解答</a></p>
                  </li>
                  <li>
                     <p><a href="synchronous-refresh.html#GUID-9E57C982-149A-4C0C-AB9C-3F8A3F4CE2E3">执行同步刷新资格分析</a></p>
                  </li>
                  <li>
                     <p><a href="synchronous-refresh.html#GUID-DC8054E4-FC5E-4DF1-8484-595562EA70CB">同步刷新安全注意事项概述</a></p>
                  </li>
               </ul>
            </div><a id="DWHSG9083"></a><div class="props_rev_3"><a id="GUID-01C7861A-8A84-4ECE-9BBF-716FB5D20113" name="GUID-01C7861A-8A84-4ECE-9BBF-716FB5D20113"></a><h3 id="DWHSG-GUID-01C7861A-8A84-4ECE-9BBF-716FB5D20113" class="sect3"><span class="enumeration_section">8.1</span>关于物化视图的同步刷新</h3>
               <div>
                  <p>同步刷新是Oracle Database 12 <span class="italic">c</span>第1版中引入的一种刷新方法，它使您能够保持一组表和在它们上定义的物化视图始终保持同步。它非常适用于数据仓库，其中增量数据的加载受到严格控制并且定期发生。
                  </p>
                  <p>在大多数数据仓库中，事实表按时间维度进行分区，并且通常，增量数据负载主要包括对最近时间段的更改。同步刷新利用这些特性来大大提高刷新性能和吞吐量。这样可以为计划查询和即席查询提供快速查询性能，这对于成功的数据仓库至关重要。</p>
                  <p>本节介绍同步刷新的主要要求和基本概念，包括以下内容：</p>
                  <ul style="list-style-type:disc">
                     <li>
                        <p><a href="synchronous-refresh.html#GUID-50E3A936-A1A2-4C25-A304-D4854A5AB13D">什么是同步刷新？</a></p>
                     </li>
                     <li>
                        <p><a href="synchronous-refresh.html#GUID-B7C9CD15-A741-4F9F-ACE3-375128958EAA">为什么要使用同步刷新？</a></p>
                     </li>
                     <li>
                        <p><a href="synchronous-refresh.html#GUID-2C51B6A4-ECA7-41C9-9356-DC1145D0318B">为同步刷新注册表和物化视图</a></p>
                     </li>
                     <li>
                        <p><a href="synchronous-refresh.html#GUID-DF69A4CD-ABAD-4195-AEA6-B34C26E426DF">指定刷新的更改数据</a></p>
                     </li>
                     <li>
                        <p><a href="synchronous-refresh.html#GUID-6107A6D9-4A8C-4D72-9631-060CE2E6AEEF">同步刷新准备和执行</a></p>
                     </li>
                     <li>
                        <p><a href="synchronous-refresh.html#GUID-9CB3EDE1-25F6-4B04-9E35-572DD86F620F">物化视图资格规则和同步刷新限制</a></p>
                     </li>
                  </ul>
               </div><a id="DWHSG9283"></a><div class="props_rev_3"><a id="GUID-50E3A936-A1A2-4C25-A304-D4854A5AB13D" name="GUID-50E3A936-A1A2-4C25-A304-D4854A5AB13D"></a><h4 id="DWHSG-GUID-50E3A936-A1A2-4C25-A304-D4854A5AB13D" class="sect4"><span class="enumeration_section">8.1.1</span>什么是同步刷新？
                  </h4>
                  <div>
                     <p>同步刷新是一种在数据仓库中维护表和物化视图的新方法，其中表和物化视图同时刷新。在传统的刷新方法中，更改将应用于基表，并使用以下刷新方法之一单独刷新实例化视图：</p>
                     <ul style="list-style-type:disc">
                        <li>
                           <p>如果此类日志可用，则使用物化视图日志进行基于日志的增量（快速）刷新</p>
                        </li>
                        <li>
                           <p>PCT刷新（如果适用）</p>
                        </li>
                        <li>
                           <p>完成刷新</p>
                        </li>
                     </ul>
                     <p>同步刷新结合了基于日志的增量（快速）刷新和PCT刷新方法的一些元素，但它仅适用于<code class="codeph">ON</code> <code class="codeph">DEMAND</code>物化视图，与其他两种方法不同。它与其他刷新方法有三个主要区别：</p>
                     <ul style="list-style-type:disc">
                        <li>
                           <p>同步刷新要求您注册表和物化视图。</p>
                        </li>
                        <li>
                           <p>同步刷新要求您根据某些正式指定的规则指定对数据的更改。</p>
                        </li>
                        <li>
                           <p>同步刷新的工作原理是将刷新操作分为两个步骤：准备和执行。与其他方法相比，该方法提供了一些重要的优点，例如更好的性能和更多的控制。</p>
                        </li>
                     </ul>
                     <p>同步刷新API在名为<code class="codeph">DBMS_SYNC_REFRESH</code>的新包中定义。有关此程序包的更多信息，请参阅<a href="../arpls/DBMS_SYNC_REFRESH.html#ARPLS73623" target="_blank"><span><cite>Oracle Database PL / SQL程序包和类型参考</cite></span></a> 。
                     </p>
                  </div>
               </div><a id="DWHSG9085"></a><div class="props_rev_3"><a id="GUID-B7C9CD15-A741-4F9F-ACE3-375128958EAA" name="GUID-B7C9CD15-A741-4F9F-ACE3-375128958EAA"></a><h4 id="DWHSG-GUID-B7C9CD15-A741-4F9F-ACE3-375128958EAA" class="sect4"><span class="enumeration_section">8.1.2</span>为什么要使用同步刷新？
                  </h4>
                  <div>
                     <p>与用于刷新数据仓库中的实体化视图的传统类型的方法相比，同步刷新具有以下优势：</p>
                     <ul style="list-style-type:disc">
                        <li>
                           <p>它通过非常有效地刷新从属物化视图本身来协调将更改加载到基表中。</p>
                        </li>
                        <li>
                           <p>它减少了优化程序无法使用物化视图重写查询的时间。</p>
                        </li>
                        <li>
                           <p>它非常适合数据仓库中常用的各种物化视图（物化聚合视图和物化连接视图）。它确实需要对物化视图进行分区以及事实表，如果物化视图当前未被分区，则可以有效地对它们进行分区以利用同步刷新。</p>
                        </li>
                        <li>
                           <p>它充分利用了分区和数据仓库加载周期的性质，以确保在整个刷新过程中物化视图和基表之间的同步。</p>
                        </li>
                        <li>
                           <p>在典型的数据仓库中，数据准备包括从一个或多个源中提取数据，清理和格式化以保持一致性，以及转换为数据仓库模式。数据准备区域称为临时区域，数据仓库中的基表从暂存区域中的表中加载。同步刷新方法适用于此模型，因为它允许您将更改数据加载到暂存日志中。</p>
                        </li>
                        <li>
                           <p>登台日志与传统快速刷新方法中的物化视图日志起着相同的作用。然而，有一个重要的区别。在传统的快速刷新方法中，首先更新基表，然后将变化从物化视图日志应用到物化视图。但是在同步刷新方法中，应用了分段日志的更改以刷新实例化视图，同时还应用于基表。</p>
                        </li>
                        <li>
                           <p>数据仓库中的大多数物化视图通常采用星型或雪花式模式，其中事实和维度表以外键连接到主键关系。同步刷新方法可以处理所有可能的更改数据加载方案中的两个模式，范围从添加到事实表的行到对事实和维度表的任意更改。</p>
                        </li>
                        <li>
                           <p>您可以选择以外部表的形式直接提供更改数据，而不是在暂存日志中提供更改负载数据，外部表包含要与基表中受影响的分区交换的数据。此功能由<code class="codeph">DBMS_SYNC_REFRESH</code>包中的<code class="codeph">REGISTER_PARTITION_OPERATION</code>过程提供。
                           </p>
                        </li>
                     </ul>
                  </div>
               </div><a id="DWHSG9086"></a><div class="props_rev_3"><a id="GUID-2C51B6A4-ECA7-41C9-9356-DC1145D0318B" name="GUID-2C51B6A4-ECA7-41C9-9356-DC1145D0318B"></a><h4 id="DWHSG-GUID-2C51B6A4-ECA7-41C9-9356-DC1145D0318B" class="sect4"><span class="enumeration_section">8.1.3</span>为同步刷新注册表和物化视图</h4>
                  <div>
                     <div class="section">
                        <p>在实际执行同步刷新之前，必须注册相应的表和物化视图。同步刷新提供了这些方法来注册表和物化视图：</p>
                     </div>
                     <!-- class="section" -->
                     <div class="section">
                        <ul style="list-style-type:disc">
                           <li>
                              <p>通过在表上创建<span class="bold">暂存</span> <span class="bold">日志</span>来使用同步刷新注册表。使用<code class="codeph">CREATE</code> <code class="codeph">MATERIALIZED</code> <code class="codeph">VIEW</code> <code class="codeph">LOG</code>语句创建分段日志，该语句的语法已在此版本中进行了扩展，以创建分段日志以及用于传统增量刷新的熟悉的物化视图日志。在表上创建登台日志后，它将被视为已注册同步刷新，并且只能使用同步刷新过程进行修改。换句话说，在其上定义了分段日志的表是使用同步刷新注册的，并且不能由用户直接修改。
                              </p>
                           </li>
                           <li>
                              <p>使用<code class="codeph">DBMS_SYNC_REFRESH</code>包中的<code class="codeph">REGISTER_MVIEWS</code>过程向同步刷新注册物化视图。<code class="codeph">REGISTER_MVIEWS</code>过程隐式创建称为同步刷新组的相关对象组。<span class="bold">同步</span> <span class="bold">刷新</span> <span class="bold">组</span>由所有相关的物化视图和表组成，这些视图和表必须作为单个实体一起刷新，因为它们彼此依赖。
                              </p>
                           </li>
                        </ul>
                        <div class="infoboxnotealso" id="GUID-2C51B6A4-ECA7-41C9-9356-DC1145D0318B__GUID-03226C2E-7F1E-403B-BA42-EC1328B1EB5C">
                           <p class="notep1">也可以看看：</p>
                           <ul style="list-style-type:disc">
                              <li>
                                 <p>有关<code class="codeph">CREATE</code> <code class="codeph">MATERIALIZED</code> <code class="codeph">VIEW</code> <code class="codeph">LOG</code>语句的更多信息，请<a href="../sqlrf/CREATE-MATERIALIZED-VIEW-LOG.html#SQLRF01303" target="_blank"><span><cite>参见Oracle数据库SQL语言参考</cite></span></a></p>
                              </li>
                              <li>
                                 <p>有关<code class="codeph">DBMS_SYNC_REFRESH</code>包的更多信息，请<code class="codeph">DBMS_SYNC_REFRESH</code> <a href="../arpls/DBMS_SYNC_REFRESH.html#ARPLS73623" target="_blank"><span><cite>Oracle Database PL / SQL包和类型参考</cite></span></a></p>
                              </li>
                           </ul>
                        </div>
                     </div>
                     <!-- class="section" -->
                  </div>
               </div><a id="DWHSG9087"></a><div class="props_rev_3"><a id="GUID-DF69A4CD-ABAD-4195-AEA6-B34C26E426DF" name="GUID-DF69A4CD-ABAD-4195-AEA6-B34C26E426DF"></a><h4 id="DWHSG-GUID-DF69A4CD-ABAD-4195-AEA6-B34C26E426DF" class="sect4"><span class="enumeration_section">8.1.4</span>指定刷新的更改数据</h4>
                  <div>
                     <div class="section">
                        <p>在其他刷新方法中，您可以直接修改实例化视图的基表，并且不会出现指定更改数据的问题。但是，对于同步刷新，您需要根据某些正式指定的规则并使用<code class="codeph">DBMS_SYNC_REFRESH</code>程序包提供的API来指定和准备更改数据。
                        </p>
                        <p>有两种方法可以指定更改数据：</p>
                     </div>
                     <!-- class="section" -->
                     <div class="section">
                        <ul style="list-style-type:disc">
                           <li>
                              <p>在外部表中提供更改数据，并使用<code class="codeph">REGISTER_PARTITION_OPERATION</code>过程进行<code class="codeph">REGISTER_PARTITION_OPERATION</code> 。
                              </p>
                              <p>有关更多详细信息，请参阅<span class="q">“ <a href="synchronous-refresh.html#GUID-DA9C2503-832C-49A0-BCC6-3A0B35F397E1">在捕获同步刷新的更改数据时使用分区操作</a> ”</span> 。
                              </p>
                           </li>
                           <li>
                              <p>通过暂存日志提供更改数据，并使用<code class="codeph">PREPARE_STAGING_LOG</code>过程处理它们。<span class="q">“ <a href="synchronous-refresh.html#GUID-E93084C2-BC19-4007-8F7F-D16FE72030E6">使用暂存日志同时捕获同步刷新的更改数据</a> ”</span>中描述了分段日志的格式和填充规则。在<code class="codeph">PREPARE_STAGING_LOG</code>表执行刷新操作之前，您需要为每个表运行<code class="codeph">PREPARE_STAGING_LOG</code>过程。
                              </p>
                           </li>
                        </ul>
                     </div>
                     <!-- class="section" -->
                  </div>
               </div><a id="DWHSG9088"></a><div class="props_rev_3"><a id="GUID-6107A6D9-4A8C-4D72-9631-060CE2E6AEEF" name="GUID-6107A6D9-4A8C-4D72-9631-060CE2E6AEEF"></a><h4 id="DWHSG-GUID-6107A6D9-4A8C-4D72-9631-060CE2E6AEEF" class="sect4"><span class="enumeration_section">8.1.5</span>同步刷新准备和执行</h4>
                  <div>
                     <div class="section">
                        <p>准备好更改数据后，您可以执行实际的刷新操作。同步刷新采用了一种刷新执行的新方法。它的工作原理是将刷新操作分为两个步骤：准备和执行。这是它与其他刷新方法之间的主要区别之一，并提供了一些重要的好处。</p>
                        <p>准备步骤确定事实表分区和物化视图分区之间的映射。此步骤计算新表，这些新表仅对应于增量更改数据加载已更改的事实表的分区。在计算了这些称为<span class="bold">外部</span> <span class="bold">表的表之后</span> ，刷新操作的实际执行发生在执行步骤中，该步骤仅包括将外部表与事实表或物化视图中的相应分区进行交换。
                        </p>
                        <p>通过将刷新执行步骤分为两个阶段并为它们提供单独的过程，同步刷新不仅可以控制刷新执行过程，还可以提高整体系统性能。它通过最小化直接访问或优化器无法使用实体化视图的时间来实现此目的，因为刷新过程会修改它们。在准备阶段，物化视图及其表不会被修改，因为此时所有刷新更改都记录在外部表中。因此，物化视图可用于需要读取它们的任何查询。只有在执行期间才会修改表和物化视图。执行性能主要受维度表更改次数的影响;如果这个数字很小，那么性能应该非常好，因为交换分区操作本身非常快。</p>
                        <p><code class="codeph">DBMS_SYNC_REFRESH</code>包提供了<code class="codeph">PREPARE_REFRESH</code>和<code class="codeph">EXECUTE_REFRESH</code>过程来执行这两个步骤。
                        </p>
                        <div class="infoboxnotealso" id="GUID-6107A6D9-4A8C-4D72-9631-060CE2E6AEEF__GUID-8DEC7708-4D30-43D2-B120-D4009470C9AE">
                           <p class="notep1">也可以看看：</p>
                           <ul style="list-style-type:disc">
                              <li>
                                 <p><a href="../arpls/DBMS_SYNC_REFRESH.html#ARPLS73623" target="_blank"><span><cite>Oracle数据库PL / SQL包和类型参考</cite></span></a></p>
                              </li>
                           </ul>
                        </div>
                     </div>
                     <!-- class="section" -->
                  </div>
               </div><a id="DWHSG9090"></a><div class="props_rev_3"><a id="GUID-9CB3EDE1-25F6-4B04-9E35-572DD86F620F" name="GUID-9CB3EDE1-25F6-4B04-9E35-572DD86F620F"></a><h4 id="DWHSG-GUID-9CB3EDE1-25F6-4B04-9E35-572DD86F620F" class="sect4"><span class="enumeration_section">8.1.6</span>物化视图资格规则和同步刷新限制</h4>
                  <div>
                     <p>物化视图有资格进行同步刷新的主要要求是物化视图必须使用可从其事实表的分区键派生的键进行分区。以下部分描述了同步刷新资格的其他要求。</p>
                     <p>本节包含以下主题：</p>
                     <ul style="list-style-type:disc">
                        <li>
                           <p><a href="synchronous-refresh.html#GUID-2A769373-2083-470A-A479-57A349731F74">同步刷新限制：分区</a></p>
                        </li>
                        <li>
                           <p><a href="synchronous-refresh.html#GUID-860B7F23-63B2-4201-AABE-7D1EBD7BF5E6">同步刷新限制：刷新选项</a></p>
                        </li>
                        <li>
                           <p><a href="synchronous-refresh.html#GUID-4A2FE559-E04E-4220-A1E9-9F264C4F6304">同步刷新限制：约束</a></p>
                        </li>
                        <li>
                           <p><a href="synchronous-refresh.html#GUID-9EFEDAE2-38D3-4F51-A531-4661CE090566">同步刷新限制：表</a></p>
                        </li>
                        <li>
                           <p><a href="synchronous-refresh.html#GUID-3075EC55-67F5-42CF-BDBF-126D8F2A9AD2">同步刷新限制：物化视图</a></p>
                        </li>
                        <li>
                           <p><a href="synchronous-refresh.html#GUID-50F75F56-0AC1-4253-A3E9-DB4B807014A8">同步刷新限制：具有聚合的物化视图</a></p>
                        </li>
                     </ul>
                  </div><a id="DWHSG9091"></a><div class="props_rev_3"><a id="GUID-2A769373-2083-470A-A479-57A349731F74" name="GUID-2A769373-2083-470A-A479-57A349731F74"></a><h5 id="DWHSG-GUID-2A769373-2083-470A-A479-57A349731F74" class="sect5"><span class="enumeration_section">8.1.6.1</span>同步刷新限制：分区</h5>
                     <div>
                        <div class="section">
                           <p>使用同步刷新有两个关键要求：</p>
                           <ul style="list-style-type:disc">
                              <li>
                                 <p>物化视图必须沿与事实表相同的维度进行分区。</p>
                              </li>
                              <li>
                                 <p>事实表的分区键应在功能上确定物化视图的分区键。</p>
                              </li>
                           </ul>
                           <p>术语<span class="italic">功能</span> <span class="italic">确定</span>意味着可以基于外键约束关系从事实表的分区键导出物化视图的分区键。如果物化视图的分区键与事实表的分区键相同，或者通过从事实表到维度表的连接相关，如星型或雪花模式，则满足此条件。例如，如果事实表由日期列（例如<code class="codeph">TIME_KEY</code>分区，则物化视图可以按<code class="codeph">TIME_KEY</code> ， <code class="codeph">MONTH</code>或<code class="codeph">YEAR</code>进行分区。</p>
                           <p>同步刷新支持事实表和物化视图上的两种类型的分区：范围分区和复合分区，当顶级分区类型为范围时。</p>
                        </div>
                        <!-- class="section" -->
                     </div>
                  </div><a id="DWHSG9092"></a><div class="props_rev_3"><a id="GUID-860B7F23-63B2-4201-AABE-7D1EBD7BF5E6" name="GUID-860B7F23-63B2-4201-AABE-7D1EBD7BF5E6"></a><h5 id="DWHSG-GUID-860B7F23-63B2-4201-AABE-7D1EBD7BF5E6" class="sect5"><span class="enumeration_section">8.1.6.2</span>同步刷新限制：刷新选项</h5>
                     <div>
                        <div class="section">
                           <p>定义实例化视图时，可以指定三个刷新选项：如何刷新;是否可以使用可信约束;以及要执行什么类型的刷新。如果未指定，则默认值分别为<code class="codeph">ON</code> <code class="codeph">DEMAND</code> ， <code class="codeph">ENFORCED</code>约束和<code class="codeph">FORCE</code> 。同步刷新要求前两个选项必须分别具有<code class="codeph">ON</code> <code class="codeph">DEMAND</code>和<code class="codeph">TRUSTED</code>约束值。同步刷新不要求刷新类型具有任何特定值，因此它可以是<code class="codeph">FAST</code> ， <code class="codeph">FORCE</code>或<code class="codeph">COMPLETE</code> 。</p>
                        </div>
                        <!-- class="section" -->
                     </div>
                  </div><a id="DWHSG9093"></a><div class="props_rev_3"><a id="GUID-4A2FE559-E04E-4220-A1E9-9F264C4F6304" name="GUID-4A2FE559-E04E-4220-A1E9-9F264C4F6304"></a><h5 id="DWHSG-GUID-4A2FE559-E04E-4220-A1E9-9F264C4F6304" class="sect5"><span class="enumeration_section">8.1.6.3</span>同步刷新限制：约束</h5>
                     <div>
                        <div class="section">
                           <p>事实和维度表之间的关系由表上的外键和主键约束声明。同步刷新信任这些约束以执行刷新，并要求必须在物化视图定义中指定<code class="codeph">USING</code> <code class="codeph">TRUSTED</code> <code class="codeph">CONSTRAINTS</code> 。这允许在刷新期间使用未经验证的<code class="codeph">RELY</code>约束并在<code class="codeph">UNKNOWN</code>或<code class="codeph">FRESH</code>状态下重写物化视图。
                           </p>
                           <p>为同步刷新注册表时，其约束可能处于<code class="codeph">VALIDATE</code>或<code class="codeph">NOVALIDATE</code>状态。如果表是维度表，则同步刷新将在刷新执行过程中保留此状态。
                           </p>
                           <p>但是，如果表是事实表，则同步刷新会在刷新执行期间标记约束<code class="codeph">NOVALIDATE</code>状态。这避免了在作为同步刷新方法的基础的分区交换期间验证对现有数据的约束的需要，并且提高了刷新执行的性能。
                           </p>
                           <p>由于同步刷新不强制对事实表施加约束，因此您必须验证所提供数据的完整性和一致性。</p>
                        </div>
                        <!-- class="section" -->
                     </div>
                  </div><a id="DWHSG9094"></a><div class="props_rev_3"><a id="GUID-9EFEDAE2-38D3-4F51-A531-4661CE090566" name="GUID-9EFEDAE2-38D3-4F51-A531-4661CE090566"></a><h5 id="DWHSG-GUID-9EFEDAE2-38D3-4F51-A531-4661CE090566" class="sect5"><span class="enumeration_section">8.1.6.4</span>同步刷新限制：表</h5>
                     <div>
                        <div class="section">
                           <p>要符合同步刷新条件，表必须满足以下条件：</p>
                           <ul style="list-style-type:disc">
                              <li>
                                 <p>该表不能在其上定义VPD或触发器。</p>
                              </li>
                              <li>
                                 <p>该表不能有任何<code class="codeph">RAW</code>类型。
                                 </p>
                              </li>
                              <li>
                                 <p>该表不能是远程的。</p>
                              </li>
                              <li>
                                 <p>为同步刷新注册的每个表的登台日志密钥应满足<span class="q">“ <a href="synchronous-refresh.html#GUID-44BDEF00-DB5A-4F28-8E2E-D99CEA905F9A">关于</a></span>登台日志密钥”中描述的要求。
                                 </p>
                              </li>
                           </ul>
                        </div>
                        <!-- class="section" -->
                     </div>
                  </div><a id="DWHSG9095"></a><div class="props_rev_2"><a id="GUID-3075EC55-67F5-42CF-BDBF-126D8F2A9AD2" name="GUID-3075EC55-67F5-42CF-BDBF-126D8F2A9AD2"></a><h5 id="DWHSG-GUID-3075EC55-67F5-42CF-BDBF-126D8F2A9AD2" class="sect5"><span class="enumeration_section">8.1.6.5</span>同步刷新限制：物化视图</h5>
                     <div>
                        <div class="section">
                           <p>还有一些其他限制特定于为同步刷新注册的物化视图：</p>
                           <ul style="list-style-type:disc">
                              <li>
                                 <p><code class="codeph">ROWID</code>列不能用于定义查询。它不相关，因为它使用分区交换，它用外表替换原始分区。因此，定义查询不应包含任何<code class="codeph">ROWID</code>列。
                                 </p>
                              </li>
                              <li>
                                 <p>同步刷新不支持物化视图定义中的嵌套物化视图， <code class="codeph">UNION</code> <code class="codeph">ALL</code>物化视图，子查询或复杂查询。定义查询必须符合星型或雪花式架构。
                                 </p>
                              </li>
                              <li>
                                 <p>这些SQL结构也不受支持：分析窗口函数（如<code class="codeph">RANK</code> ）， <code class="codeph">MODEL</code>子句和<code class="codeph">CONNECT</code> <code class="codeph">BY</code>子句。
                                 </p>
                              </li>
                              <li>
                                 <p>引用视图，远程表或外连接的实例化视图不支持同步刷新。</p>
                              </li>
                              <li>
                                 <p>物化视图不得包含对非重复表达式（如<code class="codeph">SYSDATE</code>和<code class="codeph">ROWNUM</code>引用。</p>
                              </li>
                           </ul>
                           <p>通常，适用于PCT刷新，快速刷新和一般查询重写的大多数限制也适用于同步刷新。这些限制可在以下网址获得</p>
                           <ul style="list-style-type:disc">
                              <li>
                                 <p><span class="q">“ <a href="basic-materialized-views.html#GUID-6A80266B-444E-4BB6-8A48-911E4619338B">关于查询重写的物化视图限制</a> ”</span></p>
                              </li>
                              <li>
                                 <p><span class="q">“ <a href="basic-materialized-views.html#GUID-A5409962-E85D-46DD-B34A-820074CA579C">一般查询重写限制</a> ”</span></p>
                              </li>
                              <li>
                                 <p><span class="q">“ <a href="basic-materialized-views.html#GUID-505C24CF-5D56-4820-88AA-2221410950E7">快速刷新的一般限制</a> ”</span></p>
                              </li>
                           </ul>
                        </div>
                        <!-- class="section" -->
                     </div>
                  </div><a id="DWHSG9096"></a><div class="props_rev_3"><a id="GUID-50F75F56-0AC1-4253-A3E9-DB4B807014A8" name="GUID-50F75F56-0AC1-4253-A3E9-DB4B807014A8"></a><h5 id="DWHSG-GUID-50F75F56-0AC1-4253-A3E9-DB4B807014A8" class="sect5"><span class="enumeration_section">8.1.6.6</span>同步刷新限制：具有聚合的物化视图</h5>
                     <div>
                        <div class="section">
                           <p>对于具有聚合的物化视图，同步刷新通过快速刷新共享这些限制：</p>
                           <ul style="list-style-type:disc">
                              <li>
                                 <p>仅支持<code class="codeph">SUM</code> ， <code class="codeph">COUNT</code> ， <code class="codeph">AVG</code> ， <code class="codeph">STDDEV</code> ， <code class="codeph">VARIANCE</code> ， <code class="codeph">MIN</code>和<code class="codeph">MAX</code> 。
                                 </p>
                              </li>
                              <li>
                                 <p>必须指定<code class="codeph">COUNT(*)</code> 。
                                 </p>
                              </li>
                              <li>
                                 <p>聚合函数必须仅作为表达式的最外层部分发生。也就是说，不允许诸如<code class="codeph">AVG(AVG(x))</code>或<code class="codeph">AVG(x)+ AVG(x)</code>聚合。
                                 </p>
                              </li>
                              <li>
                                 <p>对于每个聚合，例如<code class="codeph">AVG(expr)</code> ，必须存在相应的<code class="codeph">COUNT(expr)</code> 。Oracle建议指定<code class="codeph">SUM(expr)</code> 。
                                 </p>
                              </li>
                              <li>
                                 <p>如果指定了<code class="codeph">VARIANCE(expr)</code>或<code class="codeph">STDDEV(expr)</code>则必须指定<code class="codeph">COUNT(expr)</code>和<code class="codeph">SUM(expr)</code> 。Oracle建议指定<code class="codeph">SUM(expr *expr)</code> 。
                                 </p>
                              </li>
                           </ul>
                        </div>
                        <!-- class="section" -->
                     </div>
                  </div>
               </div>
            </div><a id="DWHSG9097"></a><div class="props_rev_3"><a id="GUID-8C78842C-8A78-4206-A303-7B74B8803A1C" name="GUID-8C78842C-8A78-4206-A303-7B74B8803A1C"></a><h3 id="DWHSG-GUID-8C78842C-8A78-4206-A303-7B74B8803A1C" class="sect3"><span class="enumeration_section">8.2</span>对物化视图使用同步刷新</h3>
               <div>
                  <div class="section">
                     <p>同步刷新在许多方面与其他刷新方法不同。一个是同步刷新的API包含在一个名为<code class="codeph">DBMS_SYNC_REFRESH</code>的新包中，而其他刷新方法则在<code class="codeph">DBMS_MVIEW</code>包中声明。另一个区别是在使用同步刷新注册对象后，一旦注册，其他刷新方法就不能与它们一起使用。
                     </p>
                     <p>与同步刷新相关的操作可分为以下三个广泛阶段：</p>
                  </div>
                  <!-- class="section" -->
                  <div class="section">
                     <ul style="list-style-type:disc">
                        <li>
                           <p><a href="synchronous-refresh.html#GUID-79DB80C5-E5F0-4709-B0AB-3F43E68F6445">同步刷新步骤1：注册阶段</a></p>
                        </li>
                        <li>
                           <p><a href="synchronous-refresh.html#GUID-200D698E-5AB0-4DAD-BBA1-F9FC7998D988">同步刷新步骤2：同步刷新阶段</a></p>
                        </li>
                        <li>
                           <p><a href="synchronous-refresh.html#GUID-03C3D5B9-C16E-4989-BA2C-279D59183162">同步刷新步骤3：取消注册阶段</a></p>
                        </li>
                     </ul>
                  </div>
                  <!-- class="section" -->
               </div><a id="DWHSG9099"></a><a id="DWHSG9100"></a><a id="DWHSG9101"></a><a id="DWHSG9098"></a><div class="props_rev_3"><a id="GUID-79DB80C5-E5F0-4709-B0AB-3F43E68F6445" name="GUID-79DB80C5-E5F0-4709-B0AB-3F43E68F6445"></a><h4 id="DWHSG-GUID-79DB80C5-E5F0-4709-B0AB-3F43E68F6445" class="sect4"><span class="enumeration_section">8.2.1</span>同步刷新步骤1：注册阶段</h4>
                  <div>
                     <div class="section">
                        <p>在此阶段（ <a href="synchronous-refresh.html#GUID-79DB80C5-E5F0-4709-B0AB-3F43E68F6445__BCGGGBID">图8-1</a> ），您可以注册用于同步刷新的对象。此阶段的两个步骤是首先注册表，然后是物化视图。您注册表（通过创建登台日志）和物化视图（使用<code class="codeph">REGISTER_MVIEWS</code>过程）。使用<code class="codeph">CREATE</code> <code class="codeph">MATERIALIZED</code> <code class="codeph">LOG</code> <code class="codeph">…</code> <code class="codeph">FOR</code> <code class="codeph">SYNCHRONOUS</code> <code class="codeph">REFRESH</code>语句创建登台日志。如果表已经有一个常规的物化视图日志，则可以使用<code class="codeph">ALTER</code> <code class="codeph">MATERIALIZED</code> <code class="codeph">LOG</code> <code class="codeph">…</code> <code class="codeph">FOR</code> <code class="codeph">SYNCHRONOUS</code> <code class="codeph">REFRESH</code>语句将其转换为分段日志。
                        </p>
                        <div class="figure" id="GUID-79DB80C5-E5F0-4709-B0AB-3F43E68F6445__BCGGGBID">
                           <p class="titleinfigure">图8-1注册阶段</p><img src="img/dwhsg_vm_157.png" alt="下面是图8-1的描述" title="下面是图8-1的描述" longdesc="img_text/dwhsg_vm_157.html"><br><a href="img_text/dwhsg_vm_157.html">“图8-1注册阶段”的描述</a></div>
                        <!-- class="figure" -->
                        <p>您可以使用语句创建登台日志，如<a href="synchronous-refresh.html#GUID-79DB80C5-E5F0-4709-B0AB-3F43E68F6445__BCGJJBFD">例8-1所示</a> 。
                        </p>
                     </div>
                     <!-- class="section" -->
                     <div class="example" id="GUID-79DB80C5-E5F0-4709-B0AB-3F43E68F6445__BCGJJBFD">
                        <p class="titleinexample">例8-1注册表</p><pre class="oac_no_warn" dir="ltr">创建物化视图登录事实同步刷新使用st_fact;</pre><p>如果表具有实例化视图日志，则可以使用语句将其更改为暂存日志，如下所示：</p><pre class="oac_no_warn" dir="ltr">ALTER MATERIALIZED VIEW LOG ON使用st_fact进行同步刷新的事实;</pre><p>您可以使用语句注册<a href="synchronous-refresh.html#GUID-79DB80C5-E5F0-4709-B0AB-3F43E68F6445__BCGCBBIE">实例</a>化视图，如<a href="synchronous-refresh.html#GUID-79DB80C5-E5F0-4709-B0AB-3F43E68F6445__BCGCBBIE">例8-2</a>所示。
                        </p>
                     </div>
                     <!-- class="example" -->
                     <div class="example" id="GUID-79DB80C5-E5F0-4709-B0AB-3F43E68F6445__BCGCBBIE">
                        <p class="titleinexample">示例8-2注册物化视图</p><pre class="oac_no_warn" dir="ltr">EXECUTE DBMS_SYNC_REFRESH.REGISTER_MVIEWS（'MV1'）;</pre><p>您可以一次注册多个物化视图：</p><pre class="oac_no_warn" dir="ltr">EXECUTE DBMS_SYNC_REFRESH.REGISTER_MVIEWS（'mv2，mv2_year，mv1_halfmonth'）;</pre></div>
                     <!-- class="example" -->
                  </div>
               </div><a id="DWHSG9103"></a><a id="DWHSG9102"></a><div class="props_rev_3"><a id="GUID-200D698E-5AB0-4DAD-BBA1-F9FC7998D988" name="GUID-200D698E-5AB0-4DAD-BBA1-F9FC7998D988"></a><h4 id="DWHSG-GUID-200D698E-5AB0-4DAD-BBA1-F9FC7998D988" class="sect4"><span class="enumeration_section">8.2.2</span>同步刷新步骤2：同步刷新阶段</h4>
                  <div>
                     <div class="section">
                        <p><a href="synchronous-refresh.html#GUID-200D698E-5AB0-4DAD-BBA1-F9FC7998D988__BCGJGEIA">图8-2</a>显示了同步刷新阶段。可以重复使用此阶段来执行同步刷新。这一阶段的三个主要步骤是：</p>
                     </div>
                     <!-- class="section" -->
                     <ol>
                        <li class="stepexpand"><span>准备刷新操作的更改数据。您可以在表中提供更改数据并使用<code class="codeph">REGISTER_PARTITION_OPERATION</code>过程进行注册，也可以通过填充分段日志来提供数据。在继续下一步之前，必须使用<code class="codeph">PREPARE_STAGING_LOG</code>过程处理分段日志。</span><div>
                              <p>一个例子是<a href="synchronous-refresh.html#GUID-82DB4858-381A-4F37-8A82-58463B6C57BE__BCGFBBHD">例8-12</a> 。
                              </p>
                           </div>
                        </li>
                        <li class="stepexpand"><span>执行刷新操作的第一步（ <code class="codeph">PREPARE_REFRESH</code> ）。这可能是一个长时间运行的操作，因为它准备并加载外部表。</span><div>
                              <p>一个例子是<a href="synchronous-refresh.html#GUID-DE05AC44-A036-447F-A8B1-4FEEC6503725__BCGCCJFA">例8-16</a> 。
                              </p>
                           </div>
                        </li>
                        <li class="stepexpand"><span>执行刷新操作的第二步和最后一步（ <code class="codeph">EXECUTE_REFRESH</code> ）。这通常运行得非常快，因为它通常包含一系列分区交换操作。</span><div>
                              <p>一个例子是<a href="synchronous-refresh.html#GUID-12BD73E0-A438-4F41-89D5-D48B2704C654__BCGHDIBJ">例8-20</a> 。
                              </p>
                           </div>
                        </li>
                     </ol>
                     <div class="section">
                        <p>在<a href="synchronous-refresh.html#GUID-200D698E-5AB0-4DAD-BBA1-F9FC7998D988__BCGJGEIA">图8-2中</a> ，实线箭头表示标准控制流程，虚线箭头用于错误处理案例。如果任一刷新操作（ <code class="codeph">PREPARE_REFRESH</code>或<code class="codeph">EXECUTE_REFRESH</code> ）引发用户错误，则使用<code class="codeph">ABORT_REFRESH</code>过程将表和物化视图还原到刷新操作之前存在的状态，解决问题，并从头开始重试刷新操作。
                        </p>
                        <div class="figure" id="GUID-200D698E-5AB0-4DAD-BBA1-F9FC7998D988__BCGJGEIA">
                           <p class="titleinfigure">图8-2刷新阶段</p><img src="img/dwhsg_vm_156.png" alt="下面是图8-2的描述" title="下面是图8-2的描述" longdesc="img_text/dwhsg_vm_156.html"><br><a href="img_text/dwhsg_vm_156.html">“图8-2刷新阶段”的说明</a></div>
                        <!-- class="figure" -->
                     </div>
                     <!-- class="section" -->
                  </div>
               </div><a id="DWHSG9105"></a><a id="DWHSG9106"></a><a id="DWHSG9107"></a><a id="DWHSG9104"></a><div class="props_rev_3"><a id="GUID-03C3D5B9-C16E-4989-BA2C-279D59183162" name="GUID-03C3D5B9-C16E-4989-BA2C-279D59183162"></a><h4 id="DWHSG-GUID-03C3D5B9-C16E-4989-BA2C-279D59183162" class="sect4"><span class="enumeration_section">8.2.3</span>同步刷新步骤3：取消注册阶段</h4>
                  <div>
                     <div class="section">
                        <p>如果选择停止使用同步刷新，则必须取消注册实例化视图， <a href="synchronous-refresh.html#GUID-03C3D5B9-C16E-4989-BA2C-279D59183162__BCGFDBDI">如图8-3</a>所示。物化视图首先取消注册<code class="codeph">UNREGISTER_MVIEWS</code>过程。然后，通过删除暂存日志或将暂存日志更改为普通日志来取消注册表。请注意，如果将分段日志转换为具有<code class="codeph">ALTER</code> <code class="codeph">MATERIALIZED</code> <code class="codeph">LOG</code> <code class="codeph">…</code> <code class="codeph">FOR</code> <code class="codeph">FAST</code> <code class="codeph">REFRESH</code>语句的普通物化视图日志，则可以使用标准快速刷新方法维护物化视图。
                        </p>
                        <div class="figure" id="GUID-03C3D5B9-C16E-4989-BA2C-279D59183162__BCGFDBDI">
                           <p class="titleinfigure">图8-3取消注册阶段</p><img src="img/dwhsg_vm_155.png" alt="下面是图8-3的描述" title="下面是图8-3的描述" longdesc="img_text/dwhsg_vm_155.html"><br><a href="img_text/dwhsg_vm_155.html">“图8-3取消注册阶段”的说明</a></div>
                        <!-- class="figure" -->
                        <p><a href="synchronous-refresh.html#GUID-03C3D5B9-C16E-4989-BA2C-279D59183162__BCGBCCBC">例8-3</a>说明了如何取消注册单个物化视图<code class="codeph">MV1</code> 。
                        </p>
                     </div>
                     <!-- class="section" -->
                     <div class="example" id="GUID-03C3D5B9-C16E-4989-BA2C-279D59183162__BCGBCCBC">
                        <p class="titleinexample">示例8-3取消注册物化视图</p><pre class="oac_no_warn" dir="ltr">EXECUTE DBMS_SYNC_REFRESH.UNREGISTER_MVIEWS（'MV1'）;</pre><p>您可以一次取消注册多个物化视图：</p><pre class="oac_no_warn" dir="ltr">EXECUTE DBMS_SYNC_REFRESH.UNREGISTER_MVIEWS（'mv2，mv2_year，mv1_halfmonth'）;</pre><p>您可以通过查询<code class="codeph">DBA_SR_OBJ_ALL</code>视图来验证是否已取消注册<code class="codeph">DBA_SR_OBJ_ALL</code>视图。
                        </p>
                        <p><a href="synchronous-refresh.html#GUID-03C3D5B9-C16E-4989-BA2C-279D59183162__BCGJCAHB">例8-4</a>说明了如何删除登台日志。
                        </p>
                     </div>
                     <!-- class="example" -->
                     <div class="example" id="GUID-03C3D5B9-C16E-4989-BA2C-279D59183162__BCGJCAHB">
                        <p class="titleinexample">示例8-4取消注册表</p><pre class="oac_no_warn" dir="ltr">DROP MATERIALIZED VIEW LOG ON事实;</pre><p>或者您可以将表更改为物化视图日志：</p><pre class="oac_no_warn" dir="ltr">更改材料查看登录事实快速刷新;</pre><p>您可以通过查询<code class="codeph">DBA_SR_OBJ_ALL</code>视图来验证是否已取消<code class="codeph">DBA_SR_OBJ_ALL</code> 。
                        </p>
                     </div>
                     <!-- class="example" -->
                  </div>
               </div>
            </div><a id="DWHSG9108"></a><div class="props_rev_3"><a id="GUID-D393EB28-D659-4A0C-8BD8-B174262A27C0" name="GUID-D393EB28-D659-4A0C-8BD8-B174262A27C0"></a><h3 id="DWHSG-GUID-D393EB28-D659-4A0C-8BD8-B174262A27C0" class="sect3"><span class="enumeration_section">8.3</span>使用同步刷新组</h3>
               <div>
                  <p>同步刷新的显着特征是对表及其物化视图的更改将一起加载和刷新，因此名称为同步刷新。对于要通过同步刷新维护的表和物化视图，必须注册对象。在为其创建登台日志时，将为同步刷新注册表，并使用<code class="codeph">REGISTER_MVIEWS</code>过程注册实例化视图。
                  </p>
                  <p>同步刷新支持刷新构建在多个表上的物化视图，其中包含一个或多个表的更改。必须一起刷新与约束相关的表，以确保数据完整性。此外，为同步刷新注册的某些表有可能在它们之上构建了几个物化视图，在这种情况下，所有这些物化视图也必须一起刷新。</p>
                  <p>Oracle Database不是让您跟踪这些依赖关系，而是在正确的表集上发出刷新命令，而是自动生成必须一起刷新的最小的表集和物化视图。这些集合称为同步刷新组或仅同步刷新组。每个同步刷新组由<code class="codeph">GROUP_ID</code> .value标识。
                  </p>
                  <p>与执行同步刷新（ <code class="codeph">PREPARE_REFRESH</code> ， <code class="codeph">EXECUTE_REFRESH</code>和<code class="codeph">ABORT_REFRESH</code> ）相关的三个过程将单个组ID或标识同步刷新组的组ID列表作为输入。
                  </p>
                  <p>为同步刷新注册的每个表或物化视图都分配了一个<code class="codeph">GROUP_ID</code>值，如果它们之间的依赖关系发生变化，则该值可能随时间而变化。发出<code class="codeph">REGISTER_MVIEWS</code>和<code class="codeph">UNREGISTER_MVIEWS</code>过程时会发生这种情况。以下示例显示了许多方案中的同步刷新组。
                  </p>
                  <p>由于<code class="codeph">GROUP_ID</code>值可能随时间变化，因此Oracle建议在调用同步刷新过程时不使用实际的<code class="codeph">GROUP_ID</code>值，而是使用函数<code class="codeph">DBMS_SYNC_REFRESH.GET_GROUP_ID</code> 。此函数将物化视图名称作为输入，并返回<code class="codeph">GROUP_ID</code>化视图的<code class="codeph">GROUP_ID</code>值。
                  </p>
                  <div class="infoboxnotealso" id="GUID-D393EB28-D659-4A0C-8BD8-B174262A27C0__GUID-348325CA-4877-45AB-9189-73DC1C7D09AA">
                     <p class="notep1">也可以看看：</p>
                     <p><a href="../arpls/DBMS_SYNC_REFRESH.html#ARPLS73623" target="_blank"><span><cite>Oracle Database PL / SQL包和类型参考</cite></span></a>有关如何使用<code class="codeph">DBMS_SYNC_REFRESH.REGISTER_MVIEWS</code>过程的信息</p>
                  </div>
                  <p>本节包含以下主题：</p>
                  <ul style="list-style-type:disc">
                     <li>
                        <p><a href="synchronous-refresh.html#GUID-FAC6FB90-55F8-486D-B3C8-C19389199717">具有同步刷新组的常见操作示例</a></p>
                     </li>
                     <li>
                        <p><a href="synchronous-refresh.html#GUID-37DDCE10-EFBD-4307-8037-72DC1FFEE4AE">使用多个同步刷新组的示例</a></p>
                     </li>
                  </ul>
               </div><a id="DWHSG9110"></a><a id="DWHSG9111"></a><a id="DWHSG9112"></a><a id="DWHSG9109"></a><div class="props_rev_3"><a id="GUID-FAC6FB90-55F8-486D-B3C8-C19389199717" name="GUID-FAC6FB90-55F8-486D-B3C8-C19389199717"></a><h4 id="DWHSG-GUID-FAC6FB90-55F8-486D-B3C8-C19389199717" class="sect4"><span class="enumeration_section">8.3.1</span>具有同步刷新组的常见操作示例</h4>
                  <div>
                     <div class="section">
                        <p><code class="codeph">rdbms/demo</code>目录中的同步刷新演示脚本使您可以查看可能执行的典型操作。主脚本是<code class="codeph">syncref_run.sql</code> ，其日志是<code class="codeph">syncref_run.log</code> 。<a href="synchronous-refresh.html#GUID-FAC6FB90-55F8-486D-B3C8-C19389199717__BCGIJAJC">下面的例8-5</a> ， <a href="synchronous-refresh.html#GUID-FAC6FB90-55F8-486D-B3C8-C19389199717__BCGJCFAC">例8-6</a>和<a href="synchronous-refresh.html#GUID-FAC6FB90-55F8-486D-B3C8-C19389199717__BCGFACBG">例8-7</a>说明了可以使用<code class="codeph">GET_GROUP_ID</code>函数的不同上下文。
                        </p>
                     </div>
                     <!-- class="section" -->
                     <div class="example" id="GUID-FAC6FB90-55F8-486D-B3C8-C19389199717__BCGIJAJC">
                        <p class="titleinexample">示例8-5显示在组中注册的对象</p>
                        <p>此示例说明如何在注册后显示在组中注册的对象。</p><pre class="oac_no_warn" dir="ltr">EXECUTE DBMS_SYNC_REFRESH.REGISTER_MVIEWS（'MV1'）;选择名称，类型，STAGING_LOG_NAME来自USER_SR_OBJ WHERE GROUP_ID = DBMS_SYNC_REFRESH.GET_GROUP_ID（'MV1'）ORDER BY TYPE，NAME; NAME TYPE STAGING_LOG_NAME ---------- ---------- ---------------- MV1 MVIEW FACT TABLE ST_FACT STORE TABLE ST_STORE TIME TABLE ST_TIME</pre></div>
                     <!-- class="example" -->
                     <div class="example" id="GUID-FAC6FB90-55F8-486D-B3C8-C19389199717__BCGJCFAC">
                        <p class="titleinexample">示例8-6调用刷新操作</p>
                        <p>此示例说明了如何调用刷新操作。</p><pre class="oac_no_warn" dir="ltr">EXECUTE DBMS_SYNC_REFRESH.PREPARE_REFRESH（ -  DBMS_SYNC_REFRESH.GET_GROUP_ID（'MV1'））; EXECUTE DBMS_SYNC_REFRESH.EXECUTE_REFRESH（ -  DBMS_SYNC_REFRESH.GET_GROUP_ID（'MV1'））;选择名称，类型，状态来自USER_SR_OBJ_STATUS WHERE GROUP_ID = DBMS_SYNC_REFRESH.GET_GROUP_ID（'MV1'）ORDER BY TYPE，NAME;</pre></div>
                     <!-- class="example" -->
                     <div class="example" id="GUID-FAC6FB90-55F8-486D-B3C8-C19389199717__BCGFACBG">
                        <p class="titleinexample">示例8-7验证组中注册的对象的状态</p>
                        <p>此示例说明如何在<code class="codeph">EXECUTE_REFRESH</code>操作之后验证在组中注册的对象的状态。
                        </p><pre class="oac_no_warn" dir="ltr">选择名称，类型，状态来自USER_SR_OBJ_STATUS WHERE GROUP_ID = DBMS_SYNC_REFRESH.GET_GROUP_ID（'MV1'）ORDER BY TYPE，NAME; NAME TYPE STATUS ---------------- ---------- ---------------- MV1 MVIEW COMPLETE FACT TABLE完整的商店表完整的时间表完成</pre></div>
                     <!-- class="example" -->
                  </div>
               </div><a id="DWHSG9114"></a><a id="DWHSG9115"></a><a id="DWHSG9113"></a><div class="props_rev_3"><a id="GUID-37DDCE10-EFBD-4307-8037-72DC1FFEE4AE" name="GUID-37DDCE10-EFBD-4307-8037-72DC1FFEE4AE"></a><h4 id="DWHSG-GUID-37DDCE10-EFBD-4307-8037-72DC1FFEE4AE" class="sect4"><span class="enumeration_section">8.3.2</span>使用多个同步刷新组的示例</h4>
                  <div>
                     <div class="section">
                        <p>您可以使用以下API一次使用多个刷新组：</p>
                     </div>
                     <!-- class="section" -->
                     <div class="section">
                        <ul style="list-style-type:disc">
                           <li>
                              <p><code class="codeph">GET_GROUP_ID_LIST</code> 
                              </p>
                              <p>将物化视图列表作为输入，并在列表中返回其组ID。</p>
                           </li>
                           <li>
                              <p><code class="codeph">GET_ALL_GROUP_IDS</code></p>
                              <p>返回列表中系统中所有组的组ID。</p>
                           </li>
                           <li>
                              <p>准备刷新过程（ <code class="codeph">PREPARE_REFRESH</code> ， <code class="codeph">EXECUTE_REFRESH</code>和<code class="codeph">ABORT_REFRESH</code> ）可以处理多个组。他们的重载版本一次接受组ID列表。
                              </p>
                           </li>
                        </ul>
                     </div>
                     <!-- class="section" -->
                     <div class="example" id="GUID-37DDCE10-EFBD-4307-8037-72DC1FFEE4AE__BCGJBHIJ">
                        <p class="titleinexample">示例8-8准备同步刷新组</p>
                        <p>此示例说明如何准备<code class="codeph">MV1</code> ， <code class="codeph">MV2</code>和<code class="codeph">MV3</code>的同步刷新组。
                        </p><pre class="oac_no_warn" dir="ltr">EXECUTE DBMS_SYNC_REFRESH.PREPARE_REFRESH（DBMS_SYNC_REFRESH.GET_GROUP_ID_LIST（'MV1，MV2，MV3'））;</pre><p>请注意，这三个物化视图不必全部在不同的组中。两个物化视图可能在一个组中，第三个在另一个组中;甚至所有三个物化视图都在同一组中。由于<code class="codeph">PREPARE_REFRESH</code>过载以接受组ID或组ID列表，因此上述调用将适用于所有情况。
                        </p>
                     </div>
                     <!-- class="example" -->
                     <div class="example" id="GUID-37DDCE10-EFBD-4307-8037-72DC1FFEE4AE__BCGCIDAF">
                        <p class="titleinexample">示例8-9执行同步刷新组</p>
                        <p>此示例说明如何准备和执行系统中所有同步刷新组的刷新。</p><pre class="oac_no_warn" dir="ltr">EXECUTE DBMS_SYNC_REFRESH.PREPARE_REFRESH（DBMS_SYNC_REFRESH.GET_ALL_GROUP_IDS）; EXECUTE DBMS_SYNC_REFRESH.EXECUTE_REFRESH（DBMS_SYNC_REFRESH.GET_ALL_GROUP_IDS）;</pre></div>
                     <!-- class="example" -->
                  </div>
               </div>
            </div><a id="DWHSG9116"></a><div class="props_rev_3"><a id="GUID-5C15E4A2-75FD-4B87-AD20-CE749676CE65" name="GUID-5C15E4A2-75FD-4B87-AD20-CE749676CE65"></a><h3 id="DWHSG-GUID-5C15E4A2-75FD-4B87-AD20-CE749676CE65" class="sect3"><span class="enumeration_section">8.4</span>指定和准备同步刷新的更改数据</h3>
               <div>
                  <div class="section">
                     <p>同步刷新要求您指定和准备用作<code class="codeph">PREPARE_REFRESH</code>和<code class="codeph">EXECUTE_REFRESH</code>过程输入的更改数据。指定更改数据有两种方法：</p>
                  </div>
                  <!-- class="section" -->
                  <div class="section">
                     <ul style="list-style-type:disc">
                        <li>
                           <p>在外部表中提供更改数据，并使用<code class="codeph">REGISTER_PARTITION_OPERATION</code>过程进行<code class="codeph">REGISTER_PARTITION_OPERATION</code> ，如<a href="synchronous-refresh.html#GUID-DA9C2503-832C-49A0-BCC6-3A0B35F397E1">使用分区操作同时捕获同步刷新的更改数据中所述</a> 。
                           </p>
                        </li>
                        <li>
                           <p>通过暂存日志提供更改数据，并使用<code class="codeph">PREPARE_STAGING_LOG</code>过程处理它们，如在<a href="synchronous-refresh.html#GUID-E93084C2-BC19-4007-8F7F-D16FE72030E6">捕获同步刷新的更改数据时使用暂存日志中</a>所述。
                           </p>
                        </li>
                     </ul>
                     <p>关于变更数据的一些重要观点是：</p>
                     <ul style="list-style-type:disc">
                        <li>
                           <p>这两种方法不是互斥的，可以同时使用，即使在同一个表上，但在指定的更改中不会有任何冲突。例如，您可以使用分段日志来指定具有少量更改的分区中的更改，但如果另一个分区有大量更改，则可以在外部表中提供该分区的更改。</p>
                        </li>
                        <li>
                           <p>对于维度表，您只能使用登台日志来提供更改。</p>
                        </li>
                        <li>
                           <p>同步刷新可以处理事实和维度表中的任意更改组合，但它针对最常见的数据仓库使用方案进行了优化，其中大部分更改仅针对事实表的几个分区。</p>
                        </li>
                        <li>
                           <p>同步刷新对使用非破坏性分区维护操作（PMOPS）没有限制，例如在数据仓库中常用的添加分区。这种PMOPS的使用与用于指定变更数据的方法没有直接关系。</p>
                        </li>
                        <li>
                           <p>同步刷新要求必须准备组中的所有暂存日志，即使暂存日志中没有注册更改也是如此。</p>
                        </li>
                     </ul>
                  </div>
                  <!-- class="section" -->
               </div><a id="DWHSG9118"></a><a id="DWHSG9117"></a><div class="props_rev_3"><a id="GUID-DA9C2503-832C-49A0-BCC6-3A0B35F397E1" name="GUID-DA9C2503-832C-49A0-BCC6-3A0B35F397E1"></a><h4 id="DWHSG-GUID-DA9C2503-832C-49A0-BCC6-3A0B35F397E1" class="sect4"><span class="enumeration_section">8.4.1</span>在捕获同步刷新的更改数据时使用分区操作</h4>
                  <div>
                     <div class="section">
                        <p>使用<code class="codeph">REGISTER_PARTITION_OPERATION</code>过程，您可以直接提供更改数据。此方法仅适用于事实表。对于每个更改的事实表分区，您必须提供包含该分区数据的外部表。同步刷新演示（ <code class="codeph">syncref_run.sql</code>和<code class="codeph">syncref_run.log</code> ）包含一个示例。步骤是：</p>
                     </div>
                     <!-- class="section" -->
                     <ol>
                        <li class="stepexpand"><span>为要替换的分区创建外部表。它必须与事实表具有相同的约束，并且可以在任何所需的表空间中创建。</span><div><pre class="oac_no_warn" dir="ltr">CREATE TABLE fact_ot_fp3（time_key DATE NOT NULL REFERENCES time（time_key），store_key INTEGER NOT NULL REFERENCES store（store_key），dollar_sales NUMBER（6,2），unit_sales INTEGER）tablespace syncref_fp3_tbs;</pre></div>
                        </li>
                        <li class="stepexpand"><span>将此分区的数据插入外部表。</span></li>
                        <li class="stepexpand"><span>注册此表以进行分区交换。</span><div><pre class="oac_no_warn" dir="ltr">开始DBMS_SYNC_REFRESH.REGISTER_PARTITION_OPERATION（partition_op =&gt;'EXCHANGE'，schema_name =&gt;'SYNCREF_USER'，base_table_name =&gt;'FACT'，partition_name =&gt;'FP3'，outside_partn_table_schema =&gt;'SYNCREF_USER'，outside_partn_table_name =&gt;'FACT_OT_FP3'）;结束; //</pre></div>
                        </li>
                     </ol>
                     <div class="section">
                        <p>注册外部表并执行刷新时，Oracle数据库在<code class="codeph">EXECUTE_REFRESH</code>时执行以下操作：</p><pre class="oac_no_warn" dir="ltr">ALTER TABLE FACT EXCHANGE PARTITION fp3 with TABLE fact_ot_fp3包括没有验证的指数;</pre><p>但是，您不得直接自行发布上述声明。如果您这样做，Oracle数据库将给出以下错误：</p><pre class="oac_no_warn" dir="ltr">ORA-31908：无法使用暂存日志修改表的内容。
</pre><p>除<code class="codeph">EXCHANGE</code>操作外，可以使用<code class="codeph">REGISTER_PARTITION_OPERATION</code>过程注册的另外两个分区操作是<code class="codeph">DROP</code>和<code class="codeph">TRUNCATE</code> 。</p>
                     </div>
                     <!-- class="section" -->
                     <div class="example" id="GUID-DA9C2503-832C-49A0-BCC6-3A0B35F397E1__BCGDJGBD">
                        <p class="titleinexample">示例8-10注册DROP操作</p>
                        <p>此示例说明如何使用以下语句指定第一个分区（ <code class="codeph">FP1</code> ）的丢弃。
                        </p><pre class="oac_no_warn" dir="ltr">开始DBMS_SYNC_REFRESH.REGISTER_PARTITION_OPERATION（partition_op =&gt;'DROP'，schema_name =&gt;'SYNCREF_USER'，base_table_name =&gt;'FACT'，partition_name =&gt;'FP1'）;结束; /</pre><p>如果您想要截断分区，则可以为<code class="codeph">partition_op</code>参数指定<code class="codeph">TRUNCATE</code>而不是<code class="codeph">DROP</code> 。
                        </p>
                        <p>三个分区操作（ <code class="codeph">EXCHANGE</code> ， <code class="codeph">DROP</code>和<code class="codeph">TRUNCATE</code> ）称为破坏性PMOPS，因为它们修改了表的内容。以下分区操作不具有破坏性，可以直接在使用同步刷新注册的表上执行：</p>
                        <ul style="list-style-type:disc">
                           <li>
                              <p><code class="codeph">ADD</code> <code class="codeph">PARTITION</code></p>
                           </li>
                           <li>
                              <p><code class="codeph">SPLIT</code> <code class="codeph">PARTITION</code></p>
                           </li>
                           <li>
                              <p><code class="codeph">MERGE</code> <code class="codeph">PARTITIONS</code></p>
                           </li>
                           <li>
                              <p><code class="codeph">MOVE</code> <code class="codeph">PARTITION</code></p>
                           </li>
                           <li>
                              <p><code class="codeph">RENAME</code> <code class="codeph">PARTITION</code></p>
                           </li>
                        </ul>
                        <p>在数据仓库中，这些分区操作通常用于管理大量数据，而同步刷新不会限制其使用。Oracle数据库仅要求在发出<code class="codeph">PREPARE_REFRESH</code>命令之前执行这些操作。这是因为<code class="codeph">PREPARE_REFRESH</code>过程计算事实表分区和物化视图分区之间的映射，如果在<code class="codeph">PREPARE_REFRESH</code>和<code class="codeph">EXECUTE_REFRESH</code>过程之间进行了任何分区维护，Oracle数据库将在<code class="codeph">EXECUTE_REFRESH</code>处检测到此情况并显示错误。
                        </p>
                        <p>您可以使用<code class="codeph">USER_SR_PARTN_OPS</code>目录视图来显示已注册的分区操作。
                        </p><pre class="oac_no_warn" dir="ltr">SELECT TABLE_NAME，PARTITION_OP，PARTITION_NAME，OUTSIDE_TABLE_SCHEMA ot_schema，OUTSIDE_TABLE_NAME ot_name FROM USER_SR_PARTN_OPS ORDER BY TABLE_NAME; TABLE_NAME PARTITION_ PARTITION_NAME OT_SCHEMA OT_NAME ---------- ---------- --------------- ---------- ----- -------------------- FACT EXCHANGE FP3 SYNCREF_USER FACT_OT_FP3选择1行。
</pre><p>这些分区操作由同步刷新操作使用，并由<code class="codeph">EXECUTE_REFRESH</code>过程自动取消注册。因此，如果在<code class="codeph">EXECUTE_REFRESH</code>之后查询<code class="codeph">USER_SR_PARTN_OPS</code> ，它将不显示任何行。
                        </p>
                        <p>注册分区后，如果发现错误或改变主意，可以使用<code class="codeph">UNREGISTER_PARTITION_OPERATION</code>命令撤消它：</p><pre class="oac_no_warn" dir="ltr">开始DBMS_SYNC_REFRESH.UNREGISTER_PARTITION_OPERATION（partition_op =&gt;'EXCHANGE'，schema_name =&gt;'SYNCREF_USER'，base_table_name =&gt;'FACT'，partition_name =&gt;'FP3'）;结束; /</pre></div>
                     <!-- class="example" -->
                  </div>
               </div><a id="DWHSG9119"></a><div class="props_rev_3"><a id="GUID-E93084C2-BC19-4007-8F7F-D16FE72030E6" name="GUID-E93084C2-BC19-4007-8F7F-D16FE72030E6"></a><h4 id="DWHSG-GUID-E93084C2-BC19-4007-8F7F-D16FE72030E6" class="sect4"><span class="enumeration_section">8.4.2</span>在捕获同步刷新的更改数据时使用分段日志</h4>
                  <div>
                     <p>在同步刷新中，登台日志的作用类似于增量刷新中的物化视图日志。它们是使用DDL语句创建的，可以更改为实体化视图日志。但是，与物化视图日志不同，您负责以指定格式将更改加载到登台日志中。登台日志中的每一行都必须有一个密钥才能唯一标识它;此密钥称为<span class="bold">登台</span> <span class="bold">日志</span> <span class="bold">密钥</span> ，在<span class="q">“ <a href="synchronous-refresh.html#GUID-44BDEF00-DB5A-4F28-8E2E-D99CEA905F9A">关于</a></span> <span class="bold">登台</span> <span class="bold">日志</span> <span class="bold">密钥</span> <span class="q">”中</span>定义。
                     </p>
                     <p>您负责填充登台日志，该登录日志将包含基表中的所有列以及<code class="codeph">CHAR(2)</code>类型的附加控制列<code class="codeph">DMLTYPE$$</code> 。这必须具有值<code class="codeph">'I'</code>以表示正在插入行， <code class="codeph">'D'</code>表示删除，并且<code class="codeph">'UN'</code>和<code class="codeph">'UO'</code>分别表示要更新的行的新旧值。最后两个必须成对出现。
                     </p>
                     <p>登台日志由<code class="codeph">PREPARE_STAGING_LOG</code>过程验证，并由同步刷新操作（ <code class="codeph">PREPARE_REFRESH</code>和<code class="codeph">EXECUTE_REFRESH</code> ）使用。在<code class="codeph">PREPARE_STAGING_LOG</code>验证期间，如果检测到错误，它们将在异常表中捕获。您可以查询视图<code class="codeph">USER_SR_STLOG_EXCEPTIONS</code>以获取有关异常的详细信息。
                     </p>
                     <p>同步刷新要求在为同步刷新组调用<code class="codeph">PREPARE_REFRESH</code>之前，必须使用<code class="codeph">PREPARE_STAGING_LOG</code>处理组中所有表的分段日志。即使表没有更改数据且其暂存日志为空，这也是必需的。
                     </p>
                     <p>本节包含以下主题：</p>
                     <ul style="list-style-type:disc">
                        <li>
                           <p><a href="synchronous-refresh.html#GUID-44BDEF00-DB5A-4F28-8E2E-D99CEA905F9A">关于暂存日志密钥</a></p>
                        </li>
                        <li>
                           <p><a href="synchronous-refresh.html#GUID-AB38C8B9-A34C-4B47-9A11-12A53B6317EB">关于暂存日志规则</a></p>
                        </li>
                        <li>
                           <p><a href="synchronous-refresh.html#GUID-F672472C-FBB9-4EAF-AA9B-610BDDA767C0">关于列更新为NULL</a></p>
                        </li>
                        <li>
                           <p><a href="synchronous-refresh.html#GUID-82DB4858-381A-4F37-8A82-58463B6C57BE">使用暂存日志的示例</a></p>
                        </li>
                        <li>
                           <p><a href="synchronous-refresh.html#GUID-D89D76FD-0476-4DE7-8FE5-B4EDBBE9220F">准备分段日志时的错误处理</a></p>
                        </li>
                     </ul>
                  </div><a id="DWHSG9120"></a><div class="props_rev_3"><a id="GUID-44BDEF00-DB5A-4F28-8E2E-D99CEA905F9A" name="GUID-44BDEF00-DB5A-4F28-8E2E-D99CEA905F9A"></a><h5 id="DWHSG-GUID-44BDEF00-DB5A-4F28-8E2E-D99CEA905F9A" class="sect5"><span class="enumeration_section">8.4.2.1</span>关于分段日志密钥</h5>
                     <div>
                        <p>要在基表上创建登台日志，基表必须具有密钥。如果表具有主键，则主键被视为表的登台日志上的暂存日志键。请注意，每个维度表都有一个主键。</p>
                        <p>使用事实表，他们拥有主键的情况较少见。如果表没有主键，则作为其维表的外键的列构成其暂存日志键。</p>
                        <p>登台日志的关键可以描述为：</p>
                        <ul style="list-style-type:disc">
                           <li>
                              <p>基表的主键。如果事实表具有主键，则有时将其称为代理键。</p>
                           </li>
                           <li>
                              <p>事实表的外键集。如果事实表没有主键，则适用。这种假设在数据仓库中很常见，但并未强制执行。</p>
                           </li>
                        </ul>
                        <p>有关加载登台日志的规则，请参阅<span class="q">“ <a href="synchronous-refresh.html#GUID-AB38C8B9-A34C-4B47-9A11-12A53B6317EB">关于</a></span>登台日志<span class="q"><a href="synchronous-refresh.html#GUID-AB38C8B9-A34C-4B47-9A11-12A53B6317EB">规则</a> ”</span> 。
                        </p>
                        <p><code class="codeph">PREPARE_STAGING_LOG</code>过程验证每个键值最多<code class="codeph">PREPARE_STAGING_LOG</code>指定一次。填充登台日志时，如果具有相同键值的行被多次更改，则您有责任合并更改。此过程称为<span class="bold">更改</span> <span class="bold">合并</span> 。在进行更改合并时，您必须：</p>
                        <ul style="list-style-type:disc">
                           <li>
                              <p>将同一行的删除插入合并到具有行<code class="codeph">'UO'</code>和<code class="codeph">'UN'</code>的更新操作中。
                              </p>
                           </li>
                           <li>
                              <p>将多个更新合并到一个更新中。</p>
                           </li>
                           <li>
                              <p>防止出现在分段日志中的同一行的插入更新 - 删除等空更改。</p>
                           </li>
                           <li>
                              <p>将插入合并后跟多个更新合并到单个插入中。</p>
                           </li>
                        </ul>
                     </div>
                  </div><a id="DWHSG9121"></a><div class="props_rev_3"><a id="GUID-AB38C8B9-A34C-4B47-9A11-12A53B6317EB" name="GUID-AB38C8B9-A34C-4B47-9A11-12A53B6317EB"></a><h5 id="DWHSG-GUID-AB38C8B9-A34C-4B47-9A11-12A53B6317EB" class="sect5"><span class="enumeration_section">8.4.2.2</span>关于暂存日志规则</h5>
                     <div>
                        <p>每行应包含构成主键的所有列的非空值。您需要合并所有更改，以便只能为一种类型的操作指定分段日志中的每个密钥。</p>
                        <p>对于要插入的行（ <code class="codeph">DMLTYPE$$</code>为<code class="codeph">'I'</code> ），必须为登台日志中的所有列提供有效值，以符合基表中相应列的任何约束。要插入的行的键不得存在于基表中。
                        </p>
                        <p>对于要删除的行（ <code class="codeph">DMLTYPE$$</code>为<code class="codeph">'D</code> ”），非键列值是可选的。类似地，对于指定要更新的列的旧值的行（ <code class="codeph">DMLTYPE$$</code>是<code class="codeph">'UO'</code> ），非键列值是可选的;一个重要的例外是其值正在更新为<code class="codeph">NULL</code>的列，如后面所述。
                        </p>
                        <p>对于指定要更新的列的新值的行（ <code class="codeph">DMLTYPE$$</code>是<code class="codeph">'UN'</code> ），非键列值是可选的，除了已更改的列的值。
                        </p>
                     </div>
                  </div><a id="DWHSG9122"></a><div class="props_rev_3"><a id="GUID-F672472C-FBB9-4EAF-AA9B-610BDDA767C0" name="GUID-F672472C-FBB9-4EAF-AA9B-610BDDA767C0"></a><h5 id="DWHSG-GUID-F672472C-FBB9-4EAF-AA9B-610BDDA767C0" class="sect5"><span class="enumeration_section">8.4.2.3</span>关于将列更新为NULL</h5>
                     <div>
                        <p>如果将列更新为<code class="codeph">NULL</code> ，则必须指定其旧值。否则，Oracle数据库可能无法将其与更新中值保持不变的列区分开来。
                        </p>
                        <p>例如，让表<code class="codeph">T1</code>有三列<code class="codeph">c1</code> ， <code class="codeph">c2</code>和<code class="codeph">c3</code> 。让（ <code class="codeph">c1, c2, c3) = (1, 5, 10)</code>有一行，并在暂存日志中提供以下信息：</p>
                        <div class="tblformal" id="GUID-F672472C-FBB9-4EAF-AA9B-610BDDA767C0__GUID-D59D54B1-6235-45BA-8583-944614B1F3D3">
                           <table cellpadding="4" cellspacing="0" class="Formal" title="" width="100%" border="1" summary="This table contains the old and new values for one row data in the staging log of table T1." frame="hsides" rules="rows">
                              <thead>
                                 <tr align="left" valign="top">
                                    <th align="left" valign="bottom" width="23%" id="d34570e2024">DMLTYPE $$</th>
                                    <th align="left" valign="bottom" width="18%" id="d34570e2027">C1</th>
                                    <th align="left" valign="bottom" width="29%" id="d34570e2030">C2</th>
                                    <th align="left" valign="bottom" width="29%" id="d34570e2033">C3</th>
                                 </tr>
                              </thead>
                              <tbody>
                                 <tr align="left" valign="top">
                                    <td align="left" valign="top" width="23%" id="d34570e2038" headers="d34570e2024 ">
                                       <p>UO</p>
                                    </td>
                                    <td align="left" valign="top" width="18%" headers="d34570e2038 d34570e2027 ">
                                       <p>1</p>
                                    </td>
                                    <td align="left" valign="top" width="29%" headers="d34570e2038 d34570e2030 ">
                                       <p>空值</p>
                                    </td>
                                    <td align="left" valign="top" width="29%" headers="d34570e2038 d34570e2033 ">
                                       <p>空值</p>
                                    </td>
                                 </tr>
                                 <tr align="left" valign="top">
                                    <td align="left" valign="top" width="23%" id="d34570e2051" headers="d34570e2024 ">
                                       <p>联合国</p>
                                    </td>
                                    <td align="left" valign="top" width="18%" headers="d34570e2051 d34570e2027 ">
                                       <p>1</p>
                                    </td>
                                    <td align="left" valign="top" width="29%" headers="d34570e2051 d34570e2030 ">
                                       <p>空值</p>
                                    </td>
                                    <td align="left" valign="top" width="29%" headers="d34570e2051 d34570e2033 ">
                                       <p>11</p>
                                    </td>
                                 </tr>
                              </tbody>
                           </table>
                        </div>
                        <!-- class="inftblhruleinformal" -->
                        <p>结果是新行可能是<code class="codeph">(1, 5, 11)</code>或<code class="codeph">(1, NULL, 11)</code>而没有指定旧值。但是，根据该规范，很明显新行是（ <code class="codeph">1, 5, 11)</code> 。如果要为<code class="codeph">c2</code>指定<code class="codeph">NULL</code> ，则应在<code class="codeph">UO</code>行中指定旧值，如下所示：</p>
                        <div class="tblformal" id="GUID-F672472C-FBB9-4EAF-AA9B-610BDDA767C0__GUID-B57F64A3-C933-4D64-8C45-F2A9E8C0ED03">
                           <table cellpadding="4" cellspacing="0" class="Formal" title="" width="100%" border="1" summary="This table contains the old and new values for one row data in the staging log of table T1." frame="hsides" rules="rows">
                              <thead>
                                 <tr align="left" valign="top">
                                    <th align="left" valign="bottom" width="25%" id="d34570e2094">DMLTYPE $$</th>
                                    <th align="left" valign="bottom" width="25%" id="d34570e2097">C1</th>
                                    <th align="left" valign="bottom" width="25%" id="d34570e2100">C2</th>
                                    <th align="left" valign="bottom" width="25%" id="d34570e2103">C3</th>
                                 </tr>
                              </thead>
                              <tbody>
                                 <tr align="left" valign="top">
                                    <td align="left" valign="top" width="25%" id="d34570e2108" headers="d34570e2094 ">
                                       <p>UO</p>
                                    </td>
                                    <td align="left" valign="top" width="25%" headers="d34570e2108 d34570e2097 ">
                                       <p>1</p>
                                    </td>
                                    <td align="left" valign="top" width="25%" headers="d34570e2108 d34570e2100 ">
                                       <p>五</p>
                                    </td>
                                    <td align="left" valign="top" width="25%" headers="d34570e2108 d34570e2103 ">
                                       <p>空值</p>
                                    </td>
                                 </tr>
                                 <tr align="left" valign="top">
                                    <td align="left" valign="top" width="25%" id="d34570e2121" headers="d34570e2094 ">
                                       <p>联合国</p>
                                    </td>
                                    <td align="left" valign="top" width="25%" headers="d34570e2121 d34570e2097 ">
                                       <p>1</p>
                                    </td>
                                    <td align="left" valign="top" width="25%" headers="d34570e2121 d34570e2100 ">
                                       <p>空值</p>
                                    </td>
                                    <td align="left" valign="top" width="25%" headers="d34570e2121 d34570e2103 ">
                                       <p>11</p>
                                    </td>
                                 </tr>
                              </tbody>
                           </table>
                        </div>
                        <!-- class="inftblhruleinformal" -->
                        <p>因为<code class="codeph">c2</code>的旧值是<code class="codeph">5</code> ，（列的正确的先前更新值），其新值将为<code class="codeph">NULL</code> ，新行为<code class="codeph">(1, NULL, 11)</code> 。
                        </p>
                     </div>
                  </div><a id="DWHSG9124"></a><a id="DWHSG9125"></a><a id="DWHSG9126"></a><a id="DWHSG9127"></a><a id="DWHSG9128"></a><a id="DWHSG9123"></a><div class="props_rev_3"><a id="GUID-82DB4858-381A-4F37-8A82-58463B6C57BE" name="GUID-82DB4858-381A-4F37-8A82-58463B6C57BE"></a><h5 id="DWHSG-GUID-82DB4858-381A-4F37-8A82-58463B6C57BE" class="sect5"><span class="enumeration_section">8.4.2.4</span>使用分段日志的示例</h5>
                     <div>
                        <p>本节说明使用登台日志的示例。</p>
                        <p><code class="codeph">PREPARE_STAGING_LOG</code>过程有一个名为<code class="codeph">PSL_MODE</code>的可选第三个参数。这允许您指定是否可以将登台日志中指定的三种类型的DML语句中的任何一种或全部视为可信，并且不受<code class="codeph">PREPARE_STAGING_LOG</code>过程的验证，如<a href="synchronous-refresh.html#GUID-82DB4858-381A-4F37-8A82-58463B6C57BE__BCGFFJHI">例8-11</a>所示。
                        </p>
                        <div class="example" id="GUID-82DB4858-381A-4F37-8A82-58463B6C57BE__BCGFFJHI">
                           <p class="titleinexample">示例8-11指定受信任的DML语句</p><pre class="oac_no_warn" dir="ltr">EXECUTE DBMS_SYNC_REFRESH.PREPARE_STAGING_LOG（'syncref_user'，'store'，DBMS_SYNC_REFRESH.INSERT_TRUSTED + DBMS_SYNC_REFRESH.DELETE_TRUSTED）;</pre><p>此调用将跳过<code class="codeph">STORE</code>的临时日志中的<code class="codeph">INSERT</code>和<code class="codeph">DELETE</code> DML语句的验证，但将验证<code class="codeph">UPDATE</code> DML语句。
                           </p>
                        </div>
                        <!-- class="example" -->
                        <div class="example" id="GUID-82DB4858-381A-4F37-8A82-58463B6C57BE__BCGFBBHD">
                           <p class="titleinexample">示例8-12准备分段日志</p>
                           <p>此示例取自演示<code class="codeph">syncref_run.sql</code> 。它显示用户已为删除和更新操作的所有列提供了值。如果这些值可用，建议使用此选项。
                           </p><pre class="oac_no_warn" dir="ltr">INSERT INTO st_store（dmltype $$，STORE_KEY，STORE_NUMBER，STORE_NAME，ZIPCODE）VALUES（'I'，5,5，'Store 5'，'03060'）; INSERT INTO st_store（dmltype $$，STORE_KEY，STORE_NUMBER，STORE_NAME，ZIPCODE）VALUES（'I'，6,6，'Store 6'，'03062'）; INSERT INTO st_store（dmltype $$，STORE_KEY，STORE_NUMBER，STORE_NAME，ZIPCODE）VALUES（'UO'，4,4，'Store 4'，'03062'）; INSERT INTO st_store（dmltype $$，STORE_KEY，STORE_NUMBER，STORE_NAME，ZIPCODE）VALUES（'UN'，4,4，'Stor4NewNam'，'03062'）; INSERT INTO st_store（dmltype $$，STORE_KEY，STORE_NUMBER，STORE_NAME，ZIPCODE）VALUES（'D'，3,3，'Store 3'，'03060'）; EXECUTE DBMS_SYNC_REFRESH.PREPARE_STAGING_LOG（'syncref_user'，'store'）; - 显示st_store的初始内容SELECT dmltype $$，STORE_KEY，STORE_NUMBER，STORE_NAME，ZIPCODE FROM st_store ORDER BY STORE_KEY ASC，dmltype $$ DESC; DM STORE_KEY STORE_NUMBER STORE_NAME ZIPCODE  -  --------- ------------ ---------- ------- D 3 3商店3 03060 UO 4 4商店4 03062 UN 4 4 Stor4NewNam 03062 I 5 5商店5 03060 I 5 5商店6 03062 5行选择。
</pre></div>
                        <!-- class="example" -->
                        <div class="example" id="GUID-82DB4858-381A-4F37-8A82-58463B6C57BE__BCGEEGJD">
                           <p class="titleinexample">示例8-13填写缺失值以删除和更新记录</p>
                           <p>此示例显示如果您未提供删除和更新操作的所有值，则在运行<code class="codeph">PREPARE_STAGING_LOG</code>过程时，Oracle数据库将填写缺失值。
                           </p><pre class="oac_no_warn" dir="ltr">INSERT INTO st_store（dmltype $$，STORE_KEY，STORE_NUMBER，STORE_NAME，ZIPCODE）VALUES（'D'，3，NULL，NULL，NULL）; INSERT INTO st_store（dmltype $$，STORE_KEY，STORE_NUMBER，STORE_NAME，ZIPCODE）VALUES（'UO'，4，NULL，NULL，NULL）; INSERT INTO st_store（dmltype $$，STORE_KEY，STORE_NUMBER，STORE_NAME，ZIPCODE）VALUES（'UN'，4，NULL，NULL，'03063'）; EXECUTE DBMS_SYNC_REFRESH.PREPARE_STAGING_LOG（'syncref_user'，'store'）; SELECT dmltype $$，STORE_KEY，STORE_NUMBER，STORE_NAME，ZIPCODE FROM ST_STORE ORDER BY STORE_KEY ASC，dmltype $$ DESC; DM STORE_KEY STORE_NUMBER STORE_NAME ZIPCODE  -  --------- ------------ ----------- --------- D 3 3商店3 03060 UO 4 4商店4 03062 UN 4 4商店4 03063</pre></div>
                        <!-- class="example" -->
                        <div class="example" id="GUID-82DB4858-381A-4F37-8A82-58463B6C57BE__BCGGACCB">
                           <p class="titleinexample">示例8-14将列更新为NULL</p>
                           <p>此示例说明如何将列更新为<code class="codeph">NULL</code> 。如果要将列值更新为<code class="codeph">NULL</code> ，则必须在<code class="codeph">UO</code>记录中提供其旧值。
                           </p>
                           <p>在此示例中，您的目标是将存储4的zipcode更改为03063，将其名称更改为<code class="codeph">NULL</code> 。您可以提供旧的zipcode值，但必须在<code class="codeph">'UO'</code>行中提供旧的<code class="codeph">store_name</code>值，否则<code class="codeph">store_name</code>将保持不变。
                           </p><pre class="oac_no_warn" dir="ltr">INSERT INTO st_store（dmltype $$，STORE_KEY，STORE_NUMBER，STORE_NAME，ZIPCODE）VALUES（'UO'，4，NULL，'Store 4'，NULL）; INSERT INTO st_store（dmltype $$，STORE_KEY，STORE_NUMBER，STORE_NAME，ZIPCODE）VALUES（'UN'，4，NULL，NULL，'03063'）; EXECUTE DBMS_SYNC_REFRESH.PREPARE_STAGING_LOG（'syncref_user'，'store'）; SELECT dmltype $$，STORE_KEY，STORE_NUMBER，STORE_NAME，ZIPCODE FROM st_store ORDER BY STORE_KEY ASC，dmltype $$ DESC; DM STORE_KEY STORE_NUMBER STORE_NAME ZIPCODE  -  --------- ------------ ----------- -------- UO 4 4商店4 03062 UN 4 4 03063</pre></div>
                        <!-- class="example" -->
                        <div class="example" id="GUID-82DB4858-381A-4F37-8A82-58463B6C57BE__BCGBGHFG">
                           <p class="titleinexample">示例8-15显示分段日志统计信息</p>
                           <p>此示例说明如何使用<code class="codeph">USER_SR_STLOG_STATS</code>目录视图显示登台日志统计信息。
                           </p><pre class="oac_no_warn" dir="ltr">SELECT TABLE_NAME，STAGING_LOG_NAME，NUM_INSERTS，NUM_DELETE，NUM_UPDATES FROM USER_SR_STLOG_STATS ORDER BY TABLE_NAME; TABLE_NAME STAGING_LOG_NAME NUM_INSERTS NUM_DELETES NUM_UPDATES ---------- ---------------- ----------- -------- --- ----------- FACT ST_FACT 4 1 1 STORE ST_STORE 2 1 1 TIME ST_TIME 1 0 0 3行选择。
</pre><p>如果在<code class="codeph">EXECUTE_REFRESH</code>过程结束时使用相同的查询，则不会获得任何行，表示更改数据已全部由同步刷新消耗。
                           </p>
                        </div>
                        <!-- class="example" -->
                     </div>
                  </div><a id="DWHSG9129"></a><div class="props_rev_3"><a id="GUID-D89D76FD-0476-4DE7-8FE5-B4EDBBE9220F" name="GUID-D89D76FD-0476-4DE7-8FE5-B4EDBBE9220F"></a><h5 id="DWHSG-GUID-D89D76FD-0476-4DE7-8FE5-B4EDBBE9220F" class="sect5"><span class="enumeration_section">8.4.2.5</span>准备分段日志时的错误处理</h5>
                     <div>
                        <p>当<code class="codeph">PREPARE_STAGING_LOG</code>过程处理表时，它将检测并报告仅与该表相关的变更数据规范中的错误。例如，它将验证正在插入的行的键是否已存在于基表中，并且确实存在要删除或更新的行的键。但是， <code class="codeph">PREPARE_STAGING_LOG</code>过程无法检测与表上的参照完整性约束相关的错误;也就是说，如果涉及多个表的更改数据规范存在不一致，则无法检测到错误。将在<code class="codeph">EXECUTE_REFRESH</code>过程时检测到此类错误。
                        </p>
                     </div>
                  </div>
               </div>
            </div><a id="DWHSG9130"></a><div class="props_rev_3"><a id="GUID-AEEB3AAA-BB56-4D8D-9F33-181F12E97AD6" name="GUID-AEEB3AAA-BB56-4D8D-9F33-181F12E97AD6"></a><h3 id="DWHSG-GUID-AEEB3AAA-BB56-4D8D-9F33-181F12E97AD6" class="sect3"><span class="enumeration_section">8.5</span>同步刷新操作故障排除</h3>
               <div>
                  <p>本节介绍如何监视两个同步刷新过程的状态， <code class="codeph">PREPARE_REFRESH</code>和<code class="codeph">EXECUTE_REFRESH</code>以及如何解决可能发生的错误。要成功使用同步刷新，您应该了解可能出现的不同类型的错误以及如何处理它们。
                  </p>
                  <p>最可能的错误来源之一是错误准备变更数据。运行<code class="codeph">EXECUTE_REFRESH</code>过程时，这些错误将表现为参照约束违规。在这种情况下，组的状态设置为<code class="codeph">ABORT</code> 。学会识别这些错误并解决它们非常重要。
                  </p>
                  <p>本节涉及的主题是：</p>
                  <ul style="list-style-type:disc">
                     <li>
                        <p><a href="synchronous-refresh.html#GUID-3E3A9189-D84D-4120-B901-48EFD19C19DC">刷新操作的状态概述</a></p>
                     </li>
                     <li>
                        <p><a href="synchronous-refresh.html#GUID-D2DE66DA-9D73-4789-A39B-040090819CCB">PREPARE_REFRESH如何设置STATUS字段</a></p>
                     </li>
                     <li>
                        <p><a href="synchronous-refresh.html#GUID-DE05AC44-A036-447F-A8B1-4FEEC6503725">使用PREPARE_REFRESH准备同步刷新的示例</a></p>
                     </li>
                     <li>
                        <p><a href="synchronous-refresh.html#GUID-85CAA6F2-B89F-4576-9A1B-32C2376CA97E">EXECUTE_REFRESH如何在同步刷新期间设置状态字段</a></p>
                     </li>
                     <li>
                        <p><a href="synchronous-refresh.html#GUID-12BD73E0-A438-4F41-89D5-D48B2704C654">使用EXECUTE_REFRESH执行同步刷新的示例</a></p>
                     </li>
                     <li>
                        <p><a href="synchronous-refresh.html#GUID-30E9A864-9C14-413B-93E4-6DD6E165BCC8">带有约束冲突的EXECUTE_REFRESH示例</a></p>
                     </li>
                  </ul>
               </div><a id="DWHSG9131"></a><div class="props_rev_3"><a id="GUID-3E3A9189-D84D-4120-B901-48EFD19C19DC" name="GUID-3E3A9189-D84D-4120-B901-48EFD19C19DC"></a><h4 id="DWHSG-GUID-3E3A9189-D84D-4120-B901-48EFD19C19DC" class="sect4"><span class="enumeration_section">8.5.1</span>刷新操作状态概述</h4>
                  <div>
                     <p><code class="codeph">DBMS_SYNC_REFRESH</code>包提供了三个控制刷新执行过程的过程。使用<code class="codeph">PREPARE_REFRESH</code>过程启动同步刷新，该过程计划整个刷新操作并执行大部分计算工作以进行刷新，然后执行<code class="codeph">EXECUTE_REFRESH</code>过程，执行刷新。提供的第三个过程是<code class="codeph">ABORT_REFRESH</code> ，如果这些过程中的任何一个失败，则用于从错误中恢复。
                     </p>
                     <p><code class="codeph">USER_SR_GRP_STATUS</code>和<code class="codeph">USER_SR_OBJ_STATUS</code>目录视图包含有关当前组的这些刷新操作状态的所有信息：</p>
                     <ul style="list-style-type:disc">
                        <li>
                           <p><code class="codeph">USER_SR_GRP_STATUS</code>视图显示整个组的状态。
                           </p>
                           <ul style="list-style-type:disc">
                              <li>
                                 <p><code class="codeph">OPERATION</code>字段指示在组上运行的当前刷新过程： <code class="codeph">PREPARE</code>或<code class="codeph">EXECUTE</code> 。</p>
                              </li>
                              <li>
                                 <p><code class="codeph">STATUS</code>字段指示操作的状态 - <code class="codeph">RUNNING</code> ， <code class="codeph">COMPLETE</code> ， <code class="codeph">ERROR</code> - <code class="codeph">SOFT</code> ， <code class="codeph">ERROR</code> - <code class="codeph">HARD</code> ， <code class="codeph">ABORT</code> ， <code class="codeph">PARTIAL</code> 。稍后将详细解释这些。
                                 </p>
                              </li>
                              <li>
                                 <p>该组由其组ID标识。</p>
                              </li>
                           </ul>
                        </li>
                        <li>
                           <p><code class="codeph">USER_SR_OBJ_STATUS</code>视图显示每个对象的状态。
                           </p>
                           <ul style="list-style-type:disc">
                              <li>
                                 <p>该对象由其所有者，名称和类型（ <code class="codeph">TABLE</code>或<code class="codeph">MVIEW</code> ）和组ID标识。</p>
                              </li>
                              <li>
                                 <p>的<code class="codeph">STATUS</code>字段，其可以被<code class="codeph">NOT</code> <code class="codeph">PROCESSED</code> ， <code class="codeph">ABORT</code> ，或<code class="codeph">COMPLETE</code> 。稍后将详细解释这些。
                                 </p>
                              </li>
                           </ul>
                        </li>
                     </ul>
                  </div>
               </div><a id="DWHSG9132"></a><div class="props_rev_3"><a id="GUID-D2DE66DA-9D73-4789-A39B-040090819CCB" name="GUID-D2DE66DA-9D73-4789-A39B-040090819CCB"></a><h4 id="DWHSG-GUID-D2DE66DA-9D73-4789-A39B-040090819CCB" class="sect4"><span class="enumeration_section">8.5.2</span> PREPARE_REFRESH如何设置STATUS字段</h4>
                  <div>
                     <p>当您启动新的<code class="codeph">PREPARE_REFRESH</code>作业时，组的<code class="codeph">STATUS</code>设置为<code class="codeph">RUNNING</code>并且组中对象的<code class="codeph">STATUS</code>设置为<code class="codeph">NOT</code> <code class="codeph">PROCESSED</code> 。 <code class="codeph">PREPARE_REFRESH</code>作业完成后，对象的状态保持不变，但组的状态更改为以下三个值之一：</p>
                     <ul style="list-style-type:disc">
                        <li>
                           <p><code class="codeph">COMPLETE</code>如果作业顺利完成。
                           </p>
                        </li>
                        <li>
                           <p><code class="codeph">ERROR_SOFT</code>如果作业遇到ORA-01536：超出了表空间'％s'错误的空间配额。
                           </p>
                        </li>
                        <li>
                           <p>否则为<code class="codeph">ERROR_HARD</code> （即，如果作业遇到ORA-01536以外的任何错误）。
                           </p>
                        </li>
                     </ul>
                     <p>使用<code class="codeph">PREPARE_REFRESH</code>过程时要记住以下<code class="codeph">PREPARE_REFRESH</code> ：</p>
                     <ul style="list-style-type:disc">
                        <li>
                           <p>组中对象的<code class="codeph">NOT</code> <code class="codeph">PROCESSED</code>状态表示<code class="codeph">PREPARE_REFRESH</code>作业未修改对象的数据。数据修改仅在<code class="codeph">EXECUTE_REFRESH</code>步骤中发生，此时状态将根据需要进行更改。这将在后面描述。
                           </p>
                        </li>
                        <li>
                           <p>如果<code class="codeph">STATUS</code>是<code class="codeph">ERROR_SOFT</code> ，则可以通过增加指定表空间的空间配额来修复ORA-01536错误，并恢复<code class="codeph">PREPARE_REFRESH</code> 。或者，您可以选择使用<code class="codeph">ABORT_REFRESH</code>中止刷新。</p>
                        </li>
                        <li>
                           <p>如果<code class="codeph">STATUS</code>值为<code class="codeph">ERROR_HARD</code> ，那么您唯一的选择是使用<code class="codeph">ABORT_REFRESH</code>中止刷新。</p>
                        </li>
                        <li>
                           <p>如果<code class="codeph">PREPARE_REFRESH</code>过程完成后的<code class="codeph">STATUS</code>值为<code class="codeph">RUNNING</code> ，则表示发生了错误。请联系Oracle支持服务以获取帮助。
                           </p>
                        </li>
                        <li>
                           <p><code class="codeph">ERROR_HARD</code>的<code class="codeph">STATUS</code>值可能与资源耗尽有关，因为<code class="codeph">PREPARE_REFRESH</code>过程可能是资源密集型的。如果您无法确定问题，请与Oracle支持服务联系以获取帮助。但是，如果您可以识别问题并修复它，那么您可以继续使用同步刷新，首先运行<code class="codeph">ABORT_REFRESH</code> ，然后运行<code class="codeph">PREPARE_REFRESH</code>过程。
                           </p>
                        </li>
                        <li>
                           <p>请记住，只有当组上的先前刷新操作（如果有）已成功完成执行或已中止时，才能启动新的<code class="codeph">PREPARE_REFRESH</code>作业。
                           </p>
                        </li>
                        <li>
                           <p>如果末尾的<code class="codeph">PREPARE_REFRESH</code>过程的<code class="codeph">STATUS</code>值不是<code class="codeph">COMPLETE</code> ，则无法继续执行<code class="codeph">EXECUTE_REFRESH</code>步骤。如果您无法使<code class="codeph">PREPARE_REFRESH</code>正常工作，则可以继续执行取消注册阶段，并使用其他刷新方法维护组中的对象。
                           </p>
                        </li>
                     </ul>
                  </div>
               </div><a id="DWHSG9134"></a><a id="DWHSG9135"></a><a id="DWHSG9136"></a><a id="DWHSG9137"></a><a id="DWHSG9133"></a><div class="props_rev_3"><a id="GUID-DE05AC44-A036-447F-A8B1-4FEEC6503725" name="GUID-DE05AC44-A036-447F-A8B1-4FEEC6503725"></a><h4 id="DWHSG-GUID-DE05AC44-A036-447F-A8B1-4FEEC6503725" class="sect4"><span class="enumeration_section">8.5.3</span>使用PREPARE_REFRESH准备同步刷新的示例</h4>
                  <div>
                     <div class="section">
                        <p>本节提供准备刷新时常见情况的示例。</p>
                     </div>
                     <!-- class="section" -->
                     <div class="example" id="GUID-DE05AC44-A036-447F-A8B1-4FEEC6503725__BCGCCJFA">
                        <p class="titleinexample">示例8-16 PREPARE_REFRESH成功，状态为COMPLETE</p>
                        <p>此示例显示<code class="codeph">PREPARE_REFRESH</code>过程成功完成。
                        </p><pre class="oac_no_warn" dir="ltr">EXECUTE DBMS_SYNC_REFRESH.PREPARE_REFRESH（DBMS_SYNC_REFRESH.GET_GROUP_ID（'MV1'））; PL / SQL过程成功完成。SELECT OPERATION，STATUS FROM USER_SR_GRP_STATUS WHERE GROUP_ID = DBMS_SYNC_REFRESH.GET_GROUP_ID（'MV1'）;操作状态--------- ------准备完成</pre></div>
                     <!-- class="example" -->
                     <div class="example" id="GUID-DE05AC44-A036-447F-A8B1-4FEEC6503725__BCGJJHBI">
                        <p class="titleinexample">示例8-17 PREPARE_REFRESH失败，状态为ERROR_SOFT</p>
                        <p>此示例显示遇到ORA-01536的<code class="codeph">PREPARE_REFRESH</code>过程。
                        </p><pre class="oac_no_warn" dir="ltr">EXECUTE DBMS_SYNC_REFRESH.PREPARE_REFRESH（DBMS_SYNC_REFRESH.GET_GROUP_ID（'MV1'））; BEGIN DBMS_SYNC_REFRESH.PREPARE_REFRESH（DBMS_SYNC_REFRESH.GET_GROUP_ID（'MV1'））;结束; *第1行的错误：ORA-01536：表空间'DUMMY_TS'ORA-06512超出空间配额：在“SYS.DBMS_SYNC_REFRESH”，第63行ORA-06512：在“SYS.DBMS_SYNC_REFRESH”，第411行ORA-06512：at“ SYS.DBMS_SYNC_REFRESH“，第429行ORA-06512：第1PL / SQL行成功完成。SELECT OPERATION，STATUS FROM USER_SR_GRP_STATUS WHERE GROUP_ID = DBMS_SYNC_REFRESH.GET_GROUP_ID（'MV1'）;操作状态--------- ------ PREPARE ERROR_SOFT</pre></div>
                     <!-- class="example" -->
                     <div class="example" id="GUID-DE05AC44-A036-447F-A8B1-4FEEC6503725__BCGGCBCA">
                        <p class="titleinexample">例8-18 PREPARE_REFRESH的恢复成功</p>
                        <p>此示例是<a href="synchronous-refresh.html#GUID-DE05AC44-A036-447F-A8B1-4FEEC6503725__BCGJJHBI">示例8-17</a>的延续。引发ORA-01536错误后，增加<code class="codeph">DUMMY_TS</code>的表空间并重新运行<code class="codeph">PREPARE_REFRESH</code>过程，该过程现在成功完成。请注意， <code class="codeph">PREPARE_REFRESH</code>过程将从停止的位置继续处理。另请注意， <code class="codeph">PREPARE_REFRESH</code>过程的使用与正常情况没有区别，并且不需要任何参数或设置来指示正在恢复过程。
                        </p><pre class="oac_no_warn" dir="ltr">EXECUTE DBMS_SYNC_REFRESH.PREPARE_REFRESH（DBMS_SYNC_REFRESH.GET_GROUP_ID（'MV1'））; PL / SQL过程成功完成。SELECT OPERATION，STATUS FROM USER_SR_GRP_STATUS WHERE GROUP_ID = DBMS_SYNC_REFRESH.GET_GROUP_ID（'MV1'）;操作状态--------- ------准备完成</pre></div>
                     <!-- class="example" -->
                     <div class="example" id="GUID-DE05AC44-A036-447F-A8B1-4FEEC6503725__BCGCBFJF">
                        <p class="titleinexample">例8-19 PREPARE_REFRESH的中止</p>
                        <p>此示例假定<code class="codeph">PREPARE_REFRESH</code>过程已失败且<code class="codeph">STATUS</code>值为<code class="codeph">ERROR_HARD</code> 。然后运行<code class="codeph">ABORT_REFRESH</code>过程以中止准备作业。请注意， <code class="codeph">STATUS</code>值最后已从<code class="codeph">ERROR_HARD</code>更改为<code class="codeph">ABORT</code> 。
                        </p><pre class="oac_no_warn" dir="ltr">SELECT OPERATION，STATUS FROM USER_SR_GRP_STATUS WHERE GROUP_ID = DBMS_SYNC_REFRESH.GET_GROUP_ID（'MV1'）;操作状态--------- ------ PREPARE ERROR_HARD EXECUTE DBMS_SYNC_REFRESH.ABORT_REFRESH（DBMS_SYNC_REFRESH.GET_GROUP_ID（'MV1'））; PL / SQL过程成功完成。SELECT OPERATION，STATUS FROM USER_SR_GRP_STATUS WHERE GROUP_ID = DBMS_SYNC_REFRESH.GET_GROUP_ID（'MV1'）;操作状态--------- ------ PREPARE ABORT</pre></div>
                     <!-- class="example" -->
                  </div>
               </div><a id="DWHSG9138"></a><div class="props_rev_3"><a id="GUID-85CAA6F2-B89F-4576-9A1B-32C2376CA97E" name="GUID-85CAA6F2-B89F-4576-9A1B-32C2376CA97E"></a><h4 id="DWHSG-GUID-85CAA6F2-B89F-4576-9A1B-32C2376CA97E" class="sect4"><span class="enumeration_section">8.5.4</span> EXECUTE_REFRESH如何在同步刷新期间设置状态字段</h4>
                  <div>
                     <p><code class="codeph">EXECUTE_REFRESH</code>过程将同步刷新组中的对象组划分为子组，每个子组都以原子方式刷新。第一个子组由基表组成。同步刷新组中的每个物化视图都放在一个单独的子组中，并以原子方式刷新。
                     </p>
                     <p>对于<code class="codeph">EXECUTE_REFRESH</code>过程， <code class="codeph">STATUS</code>字段的可能结束状态为： <code class="codeph">COMPLETE</code> ， <code class="codeph">PARTIAL</code>和<code class="codeph">ABORT</code> ：</p>
                     <ul style="list-style-type:disc">
                        <li>
                           <p><code class="codeph">STATUS</code> <code class="codeph">=</code> <code class="codeph">COMPLETE</code></p>
                           <p>如果基表和所有物化视图成功刷新，则会达到此状态。</p>
                        </li>
                        <li>
                           <p><code class="codeph">STATUS</code> <code class="codeph">=</code> <code class="codeph">ABORT</code></p>
                           <p>此状态表示基表子组的刷新失败;表格和物化视图中的数据是一致的但不变。如果发生这种情况，则应该存在与故障相关的错误。如果是用户错误，如违反约束，那么你就可以解决这个问题，并从头开始重新同步刷新操作（即<code class="codeph">PREPARE_STAGING_LOG</code>为组中的每个表<code class="codeph">PREPARE_REFRESH</code>和<code class="codeph">EXECUTE_REFRESH</code> ）。如果不是用户错误，那么您应该联系Oracle支持服务。
                           </p>
                        </li>
                        <li>
                           <p><code class="codeph">STATUS</code> <code class="codeph">=</code> <code class="codeph">PARTIAL</code></p>
                           <p>如果所有基表刷新成功并且某些（但不是全部）物化视图成功刷新，则会达到此状态。已成功刷新的表和物化视图中的数据彼此一致;其他物化视图陈旧，需要完全刷新。如果发生这种情况，则应该存在与故障相关的错误。这很可能不是用户错误，而是您应该向Oracle支持服务报告的Oracle错误。在这种状态下你有两个选择：</p>
                           <ul style="list-style-type:disc">
                              <li>
                                 <p>重试执行<code class="codeph">EXECUTE_REFRESH</code>过程。在这种情况下， <code class="codeph">EXECUTE_REFRESH</code>将使用另一种刷新方法（如PCT-refresh或<code class="codeph">COMPLETE</code> refresh）重新尝试刷新失败的实例化视图。如果所有物化视图都成功，则状态将设置为<code class="codeph">COMPLETE</code> 。否则，状态将保留在<code class="codeph">PARTIAL</code> 。</p>
                              </li>
                              <li>
                                 <p>调用<code class="codeph">ABORT_REFRESH</code>过程以中止<code class="codeph">ABORT_REFRESH</code>化视图。这将回滚对所有物化视图和基表的更改。在将分段日志或已注册的分区操作中的任何更改应用于它们之前，它们都将具有与原始状态相同的数据。
                                 </p>
                              </li>
                           </ul>
                        </li>
                     </ul>
                     <p>如果<code class="codeph">EXECUTE_REFRESH</code>过程中出现错误， <code class="codeph">USER_SR_GRP_STATUS</code>视图中的以下字段也很有用：</p>
                     <ul style="list-style-type:disc">
                        <li>
                           <p><code class="codeph">NUM_MVS_COMPLETED</code> ，包含已成功完成刷新操作的<code class="codeph">NUM_MVS_COMPLETED</code>化视图的数量。
                           </p>
                        </li>
                        <li>
                           <p><code class="codeph">NUM_MVS_ABORTED</code> ，其中包含已中止的物化视图的数量。
                           </p>
                        </li>
                        <li>
                           <p><code class="codeph">ERROR</code>和<code class="codeph">ERROR_MESSAGE</code> ，记录操作中遇到的错误。
                           </p>
                        </li>
                     </ul>
                     <p>在<code class="codeph">EXECUTE_REFRESH</code>过程结束时，组中对象的状态在<code class="codeph">USER_SR_OBJ_STATUS</code>视图中标记如下：</p>
                     <ul style="list-style-type:disc">
                        <li>
                           <p>如果已成功应用更改，则对象的状态将设置为<code class="codeph">COMPLETE</code> 。
                           </p>
                        </li>
                        <li>
                           <p>如果未成功应用更改，则对象的状态将设置为<code class="codeph">ABORT</code> 。在这种情况下，对象将处于刷新操作之前的状态。<code class="codeph">ERROR</code>和<code class="codeph">ERROR_MESSAGE</code>字段记录操作中遇到的错误。
                           </p>
                        </li>
                        <li>
                           <p>对象的状态保持<code class="codeph">NOT</code> <code class="codeph">PROCESSED</code>如果没有更改应用到它。
                           </p>
                        </li>
                     </ul>
                  </div>
               </div><a id="DWHSG9140"></a><a id="DWHSG9141"></a><a id="DWHSG9142"></a><a id="DWHSG9143"></a><a id="DWHSG9139"></a><div class="props_rev_3"><a id="GUID-12BD73E0-A438-4F41-89D5-D48B2704C654" name="GUID-12BD73E0-A438-4F41-89D5-D48B2704C654"></a><h4 id="DWHSG-GUID-12BD73E0-A438-4F41-89D5-D48B2704C654" class="sect4"><span class="enumeration_section">8.5.5</span>使用EXECUTE_REFRESH执行同步刷新的示例</h4>
                  <div>
                     <div class="section">
                        <p>本节提供执行刷新时常见情况的示例。</p>
                     </div>
                     <!-- class="section" -->
                     <div class="example" id="GUID-12BD73E0-A438-4F41-89D5-D48B2704C654__BCGHDIBJ">
                        <p class="titleinexample">示例8-20 EXECUTE_REFRESH成功完成</p>
                        <p><a href="synchronous-refresh.html#GUID-12BD73E0-A438-4F41-89D5-D48B2704C654__BCGHDIBJ">例8-20</a>显示了<code class="codeph">EXECUTE_REFRESH</code>过程成功完成。
                        </p><pre class="oac_no_warn" dir="ltr">EXECUTE DBMS_SYNC_REFRESH.EXECUTE_REFRESH（DBMS_SYNC_REFRESH.GET_GROUP_ID（'MV1'））; PL / SQL过程成功完成。SELECT OPERATION，STATUS FROM USER_SR_GRP_STATUS WHERE GROUP_ID = DBMS_SYNC_REFRESH.GET_GROUP_ID（'MV1'）;操作状态--------- ------执行完成</pre></div>
                     <!-- class="example" -->
                     <div class="example" id="GUID-12BD73E0-A438-4F41-89D5-D48B2704C654__BCGIJHFE">
                        <p class="titleinexample">例8-21 EXECUTE_REFRESH部分成功</p>
                        <p><a href="synchronous-refresh.html#GUID-12BD73E0-A438-4F41-89D5-D48B2704C654__BCGIJHFE">例8-21</a>显示了部分成功的<code class="codeph">EXECUTE_REFRESH</code>过程。在此示例中，在刷新基表之后但在完成所有物化视图的刷新之前， <code class="codeph">EXECUTE_REFRESH</code>过程失败。组的结果状态为<code class="codeph">PARTIAL</code>并抛出QSM-03280错误消息。
                        </p><pre class="oac_no_warn" dir="ltr">EXECUTE DBMS_SYNC_REFRESH.EXECUTE_REFRESH（DBMS_SYNC_REFRESH.GET_GROUP_ID（'MV1'））; BEGIN DBMS_SYNC_REFRESH.EXECUTE_REFRESH（DBMS_SYNC_REFRESH.GET_GROUP_ID（'MV1'））;结束; *第1行的错误：ORA-31928：同步刷新错误QSM-03280：一个或多个物化视图无法成功刷新。ORA-06512：在“SYS.DBMS_SYNC_REFRESH”，第63行ORA-06512：在“SYS.DBMS_SYNC_REFRESH”，第411行ORA-06512：在“SYS.DBMS_SYNC_REFRESH”，第446行ORA-06512：在第1行</pre><p>在<code class="codeph">EXECUTE_REFRESH</code> .procedure之后检查组本身的状态。请注意，操作字段设置为<code class="codeph">EXECUTE</code> ，状态为<code class="codeph">PARTIAL</code> 。</p><pre class="oac_no_warn" dir="ltr">SELECT OPERATION，STATUS FROM USER_SR_GRP_STATUS WHERE GROUP_ID = DBMS_SYNC_REFRESH.GET_GROUP_ID（'MV1'）;操作状态--------- ------------- EXECUTE PARTIAL</pre><p>通过查询<code class="codeph">USER_SR_GRP_STATUS</code>视图，您可以发现已中止的物化视图数为1，失败的物化视图为<code class="codeph">MV1</code> 。
                        </p>
                        <p>如果检查组中对象的状态，因为<code class="codeph">STORE</code>和<code class="codeph">TIME</code>未更改，则其状态为<code class="codeph">NOT</code> <code class="codeph">PROCESSED</code> 。</p><pre class="oac_no_warn" dir="ltr">选择名称，类型，状态来自USER_SR_OBJ_STATUS WHERE GROUP_ID = DBMS_SYNC_REFRESH.GET_GROUP_ID（'MV1'）ORDER BY TYPE，NAME; NAME TYPE STATUS ---------------- ---------- ---------------- MV1 MVIEW ABORT MV1_HALFMONTH MVIEW COMPLETE MV2 MVIEW完成MV2_YEAR MVIEW完成事实表完整存储表未处理时间表未处理选择7行。SELECT NUM_TBLS，NUM_MVS，NUM_MVS_COMPLETED，NUM_MVS_ABORTED来自USER_SR_GRP_STATUS WHERE GROUP_ID = DBMS_SYNC_REFRESH.GET_GROUP_ID（'MV1'）; NUM_TBLS NUM_MVS NUM_MVS_COMPLETED NUM_MVS_ABORTED -------- ------- ----------------- -------------- -  3 4 3 1</pre><p>此时，您可以再次尝试运行<code class="codeph">EXECUTE_REFRESH</code>过程。如果重试成功并且失败的物化视图成功，则组状态将设置为<code class="codeph">COMPLETE</code> 。否则，状态将保留在<code class="codeph">PARTIAL</code> 。这在<a href="synchronous-refresh.html#GUID-12BD73E0-A438-4F41-89D5-D48B2704C654__BCGGCHFG">例8-22中显示</a> 。您也可以中止刷新过程并返回到原始状态。这在<a href="synchronous-refresh.html#GUID-12BD73E0-A438-4F41-89D5-D48B2704C654__BCGHCEFA">例8-23中显示</a> 。
                        </p>
                     </div>
                     <!-- class="example" -->
                     <div class="example" id="GUID-12BD73E0-A438-4F41-89D5-D48B2704C654__BCGGCHFG">
                        <p class="titleinexample">示例8-22在PARTIAL状态后重试刷新</p>
                        <p><a href="synchronous-refresh.html#GUID-12BD73E0-A438-4F41-89D5-D48B2704C654__BCGGCHFG">例8-22</a>说明了<a href="synchronous-refresh.html#GUID-12BD73E0-A438-4F41-89D5-D48B2704C654__BCGIJHFE">例8-21</a>的继续。您重试<code class="codeph">EXECUTE_REFRESH</code>过程并成功：</p><pre class="oac_no_warn" dir="ltr">EXECUTE DBMS_SYNC_REFRESH.EXECUTE_REFRESH（DBMS_SYNC_REFRESH.GET_GROUP_ID（'MV1'））; PL / SQL过程成功完成。- 在EXECUTE_REFRESH操作后检查组本身的状态; - 注意操作字段设置为EXECUTE且状态为COMPLETE。 SELECT OPERATION，STATUS FROM USER_SR_GRP_STATUS WHERE GROUP_ID = DBMS_SYNC_REFRESH.GET_GROUP_ID（'MV1'）;操作状态--------- ---------执行完成</pre><p>通过查询<code class="codeph">USER_SR_GRP_STATUS</code>视图，可以发现已中止的物化视图数为0， <code class="codeph">MV1</code>的状态为<code class="codeph">COMPLETE</code> 。如果检查组中对象的状态，因为<code class="codeph">STORE</code>和<code class="codeph">TIME</code>未更改，则其状态为<code class="codeph">NOT</code> <code class="codeph">PROCESSED</code> 。</p><pre class="oac_no_warn" dir="ltr">选择名称，类型，状态来自USER_SR_GRP_STATUS WHERE GROUP_ID = DBMS_SYNC_REFRESH.GET_GROUP_ID（'MV1'）ORDER BY TYPE，NAME; NAME TYPE STATUS ---------------- ---------- ---------------- MV1 MVIEW COMPLETE MV1_HALFMONTH MVIEW COMPLETE MV2 MVIEW完成MV2_YEAR MVIEW完成事实表完整存储表未处理时间表未处理选择7行。SELECT NUM_TBLS，NUM_MVS，NUM_MVS_COMPLETED，NUM_MVS_ABORTED来自USER_SR_GRP_STATUS WHERE GROUP_ID = DBMS_SYNC_REFRESH.GET_GROUP_ID（'MV1'）; NUM_TBLS NUM_MVS NUM_MVS_COMPLETED NUM_MVS_ABORTED -------- ------- ----------------- -------------- -  3 4 4 0</pre><p>您可以检查表和物化视图，以验证更改数据中的更改是否已正确应用于它们，并且物化视图和表彼此一致。</p>
                     </div>
                     <!-- class="example" -->
                     <div class="example" id="GUID-12BD73E0-A438-4F41-89D5-D48B2704C654__BCGHCEFA">
                        <p class="titleinexample">示例8-23使用PARTIAL状态中止刷新</p>
                        <p><a href="synchronous-refresh.html#GUID-12BD73E0-A438-4F41-89D5-D48B2704C654__BCGHCEFA">例8-23</a>说明了中止处于<code class="codeph">PARTIAL</code>状态的刷新过程。
                        </p><pre class="oac_no_warn" dir="ltr">EXECUTE DBMS_SYNC_REFRESH.ABORT_REFRESH（DBMS_SYNC_REFRESH.GET_GROUP_ID（'MV1'））; PL / SQL过程成功完成。
</pre><p>在<code class="codeph">ABORT_REFRESH</code>过程之后检查组本身的状态;请注意，操作字段设置为<code class="codeph">EXECUTE</code>且状态为<code class="codeph">ABORT</code> 。</p><pre class="oac_no_warn" dir="ltr">SELECT OPERATION，STATUS FROM USER_SR_GRP_STATUS WHERE GROUP_ID = DBMS_SYNC_REFRESH.GET_GROUP_ID（'MV1'）;操作状态---------- -------执行中止</pre><p>通过查询<code class="codeph">USER_SR_GRP_STATUS</code>视图，您会看到所有物化视图都已中止，并且事实表也是如此。检查组中对象的状态;因为<code class="codeph">STORE</code>和<code class="codeph">TIME</code>是不变的，他们的地位是<code class="codeph">NOT</code> <code class="codeph">PROCESSED</code> 。</p><pre class="oac_no_warn" dir="ltr">选择名称，类型，状态来自USER_SR_GRP_STATUS WHERE GROUP_ID = DBMS_SYNC_REFRESH.GET_GROUP_ID（'MV1'）ORDER BY TYPE，NAME; NAME TYPE STATUS ---------------- ---------- ---------------- MV1 MVIEW ABORT MV1_HALFMONTH MVIEW ABORT MV2 MVIEW ABORT MV2_YEAR MVIEW ABORT FACT TABLE ABORT STORE TABLE NOT PROCESSED TIME TABLE NOT PROCESSED 7行选择。SELECT NUM_TBLS，NUM_MVS，NUM_MVS_COMPLETED，NUM_MVS_ABORTED来自USER_SR_GRP_STATUS WHERE GROUP_ID = DBMS_SYNC_REFRESH.GET_GROUP_ID（'MV1'）; NUM_TBLS NUM_MVS NUM_MVS_COMPLETED NUM_MVS_ABORTED -------- ------- ----------------- -------------- -  3 4 0 4</pre><p>您可以检查表和物化视图，以验证它们是否都处于原始状态，并且未对更改数据应用任何更改。</p>
                     </div>
                     <!-- class="example" -->
                  </div>
               </div><a id="DWHSG9145"></a><a id="DWHSG9144"></a><div class="props_rev_3"><a id="GUID-30E9A864-9C14-413B-93E4-6DD6E165BCC8" name="GUID-30E9A864-9C14-413B-93E4-6DD6E165BCC8"></a><h4 id="DWHSG-GUID-30E9A864-9C14-413B-93E4-6DD6E165BCC8" class="sect4"><span class="enumeration_section">8.5.6</span>带有约束冲突的EXECUTE_REFRESH示例</h4>
                  <div>
                     <div class="section">
                        <p>在同步刷新方法中，更改数据同时加载到表和实例化视图中以使它们保持同步。在其他刷新方法中，首先将更改数据加载到表中，然后检查所有已启用的约束。在同步刷新方法中，使用来自用户的可信数据准备外部表，并关闭约束验证以节省执行时间。以下示例显示了<code class="codeph">EXECUTE_REFRESH</code>过程捕获的约束违规。在这种情况下， <code class="codeph">EXECUTE_REFRESH</code>过程的最终状态将为<code class="codeph">ABORT</code> 。您必须在更改数据中识别并修复问题，并始终开始同步刷新阶段。
                        </p>
                     </div>
                     <!-- class="section" -->
                     <div class="example" id="GUID-30E9A864-9C14-413B-93E4-6DD6E165BCC8__BCGJJDEH">
                        <p class="titleinexample">示例8-24子密钥约束违规</p>
                        <p>在<a href="synchronous-refresh.html#GUID-30E9A864-9C14-413B-93E4-6DD6E165BCC8__BCGJJDEH">例8-24中</a> ，假设使用与<code class="codeph">rdbms/demo</code>目录中的文件<code class="codeph">syncref_run.sql</code>相同的表并使用相同的数据填充。特别地，表<code class="codeph">STORE</code>具有四行，其中主键<code class="codeph">STORE_KEY</code>具有值1到4，并且<code class="codeph">FACT</code>表具有引用所有四个存储的行，包括存储3。
                        </p>
                        <p>要演示父键约束违例，请使用删除<code class="codeph">STORE_KEY</code>为3的行填充<code class="codeph">STORE</code>的暂存日志。其他表没有其他更改。当<code class="codeph">EXECUTE_REFRESH</code>过程运行时，它会因ORA-02292错误而失败，如图所示。
                        </p><pre class="oac_no_warn" dir="ltr">INSERT INTO st_store（dmltype $$，STORE_KEY，STORE_NUMBER，STORE_NAME，ZIPCODE）VALUES（'D'，3,3，'Store 3'，'03060'）; - 准备登台日志EXECUTE DBMS_SYNC_REFRESH.PREPARE_STAGING_LOG（'syncref_user'，'fact'）; EXECUTE DBMS_SYNC_REFRESH.PREPARE_STAGING_LOG（'syncref_user'，'time'）; EXECUTE DBMS_SYNC_REFRESH.PREPARE_STAGING_LOG（'syncref_user'，'store'）; - 准备刷新EXECUTE DBMS_SYNC_REFRESH.PREPARE_REFRESH（DBMS_SYNC_REFRESH.GET_GROUP_ID（'MV1'））; - 执行刷新EXECUTE DBMS_SYNC_REFRESH.EXECUTE_REFRESH（ -  DBMS_SYNC_REFRESH.GET_GROUP_ID（'MV1'））; BEGIN DBMS_SYNC_REFRESH.EXECUTE_REFRESH（DBMS_SYNC_REFRESH.GET_GROUP_ID（'MV1'））;结束; *第1行的错误：ORA-02292：违反了完整性约束（SYNCREF_USER.SYS_C0031765） - 找到子记录ORA-06512：第1行ORA-06512：第“第71行ORBS-REFRESH”，第63行ORA-06512：“SYS。 DBMS_SYNC_REFRESH“，第411行ORA-06512：位于”SYS.DBMS_SYNC_REFRESH“，第446行ORA-06512：第1行</pre><p>在<code class="codeph">EXECUTE_REFRESH</code>过程之后检查组本身的状态。请注意，操作字段设置为<code class="codeph">EXECUTE</code> ，状态为<code class="codeph">ABORT</code> 。</p><pre class="oac_no_warn" dir="ltr">SELECT OPERATION，STATUS FROM USER_SR_GRP_STATUS WHERE GROUP_ID = DBMS_SYNC_REFRESH.GET_GROUP_ID（'MV1'）;操作状态---------- --------------执行中止</pre><p>如果检查基表和<code class="codeph">MV1</code>的内容，则会发现没有变化，并且它们都具有原始值。
                        </p>
                     </div>
                     <!-- class="example" -->
                  </div>
               </div>
            </div><a id="DWHSG9147"></a><a id="DWHSG9146"></a><div class="props_rev_3"><a id="GUID-9E57C982-149A-4C0C-AB9C-3F8A3F4CE2E3" name="GUID-9E57C982-149A-4C0C-AB9C-3F8A3F4CE2E3"></a><h3 id="DWHSG-GUID-9E57C982-149A-4C0C-AB9C-3F8A3F4CE2E3" class="sect3"><span class="enumeration_section">8.6</span>执行同步刷新资格分析</h3>
               <div>
                  <div class="section">
                     <p><code class="codeph">CAN_SYNCREF_TABLE</code>函数告诉您表及其相关的物化视图是否有资格进行同步刷新。它提供了对其分析的解释。如果表和视图不符合条件，您可以检查原因并尽可能采取适当的措施。要符合同步刷新的条件，表必须满足前面描述的各种条件。
                     </p>
                     <p>您可以通过两种方式调用<code class="codeph">CAN_SYNCREF_TABLE</code>函数：</p>
                  </div>
                  <!-- class="section" -->
                  <div class="section">
                     <ul style="list-style-type:disc">
                        <li>
                           <p>使用表来存储<code class="codeph">CAN_SYNCREF_TABLE</code>函数的输出</p>
                           <p>以下显示了使用输出表的基本语法：</p><pre class="oac_no_warn" dir="ltr">can_syncref_table（schema_name IN VARCHAR2，table_name IN VARCHAR2，statement_id IN VARCHAR2）</pre></li>
                        <li>
                           <p>使用VARRAY存储CAN_SYNCREF_TABLE函数的输出</p>
                           <p>要将<code class="codeph">CAN_SYNCREF_TABLE</code>函数的输出<code class="codeph">CAN_SYNCREF_TABLE</code>到<code class="codeph">VARRAY</code>而不是表，请按如下方式调用过程：</p><pre class="oac_no_warn" dir="ltr">can_syncref_table（schema_name IN VARCHAR2，table_name IN VARCHAR2，output_array IN OUT Sys。CanSyncRefTypeArray）</pre></li>
                     </ul>
                     <p>您可以通过执行<code class="codeph">utlcsrt.sql</code>脚本来创建名为<code class="codeph">SYNCREF_TABLE</code>的输出表。
                     </p>
                     <div class="tblformal" id="GUID-9E57C982-149A-4C0C-AB9C-3F8A3F4CE2E3__GUID-16DECA53-81BE-4D70-ACF1-8D97E2BA9067">
                        <p class="titleintable">表8-1 CAN_SYNCREF_TABLE</p>
                        <table cellpadding="4" cellspacing="0" class="Formal" title="CAN_SYNCREF_TABLE" width="100%" border="1" summary="This table describes the parameters of the CAN_SYNCREF_TABLE function." frame="hsides" rules="rows">
                           <thead>
                              <tr align="left" valign="top">
                                 <th align="left" valign="bottom" width="23%" id="d34570e3294">参数</th>
                                 <th align="left" valign="bottom" width="77%" id="d34570e3297">描述</th>
                              </tr>
                           </thead>
                           <tbody>
                              <tr align="left" valign="top">
                                 <td align="left" valign="top" width="23%" id="d34570e3302" headers="d34570e3294 ">
                                    <p><code class="codeph">SCHEMA_NAME</code></p>
                                 </td>
                                 <td align="left" valign="top" width="77%" headers="d34570e3302 d34570e3297 ">
                                    <p>基表的模式的名称。</p>
                                 </td>
                              </tr>
                              <tr align="left" valign="top">
                                 <td align="left" valign="top" width="23%" id="d34570e3310" headers="d34570e3294 ">
                                    <p><code class="codeph">base_table_name</code></p>
                                 </td>
                                 <td align="left" valign="top" width="77%" headers="d34570e3310 d34570e3297 ">
                                    <p>基表的名称。</p>
                                 </td>
                              </tr>
                              <tr align="left" valign="top">
                                 <td align="left" valign="top" width="23%" id="d34570e3318" headers="d34570e3294 ">
                                    <p><code class="codeph">statement_id</code></p>
                                 </td>
                                 <td align="left" valign="top" width="77%" headers="d34570e3318 d34570e3297 ">
                                    <p>一个字符串（ <code class="codeph">VARCHAR2(30)</code>用于标识与输出定向到用户模式中名为<code class="codeph">SYNCREF_TABLE</code>的表的<code class="codeph">CAN_SYNCREF_TABLE</code>函数调用有关的行。
                                    </p>
                                 </td>
                              </tr>
                              <tr align="left" valign="top">
                                 <td align="left" valign="top" width="23%" id="d34570e3335" headers="d34570e3294 ">
                                    <p><code class="codeph">output_array</code></p>
                                 </td>
                                 <td align="left" valign="top" width="77%" headers="d34570e3335 d34570e3297 ">
                                    <p><code class="codeph">CAN_SYNCREF_TABLE</code>在其中记录有关基表及其相关物化视图的同步刷新资格的信息的输出数组。
                                    </p>
                                 </td>
                              </tr>
                           </tbody>
                        </table>
                     </div>
                     <!-- class="inftblhruleinformal" -->
                     <div class="infoboxnote" id="GUID-9E57C982-149A-4C0C-AB9C-3F8A3F4CE2E3__GUID-59A88AF1-D638-40E7-A996-D00AFF3CF935">
                        <p class="notep1">注意：</p>
                        <p>只需要为<code class="codeph">CAN_SYNCREF_TABLE</code>函数提供一个<code class="codeph">statement_id</code>或<code class="codeph">output_array</code>参数。
                        </p>
                     </div>
                  </div>
                  <!-- class="section" -->
               </div><a id="DWHSG9148"></a><div class="props_rev_3"><a id="GUID-525992D6-4104-44BA-84D6-7B7CE50B8951" name="GUID-525992D6-4104-44BA-84D6-7B7CE50B8951"></a><h4 id="DWHSG-GUID-525992D6-4104-44BA-84D6-7B7CE50B8951" class="sect4"><span class="enumeration_section">8.6.1</span>使用SYNCREF_TABLE存储同步刷新资格分析的结果</h4>
                  <div>
                     <div class="section">
                        <p><code class="codeph">CAN_SYNCREF_TABLE</code>函数的输出可以定向到名为<code class="codeph">SYNCREF_TABLE</code>的表。您负责创建<code class="codeph">SYNCREF_TABLE</code> ;它可以在不再需要时丢弃。<code class="codeph">SYNCREF_TABLE</code>的格式如下：</p><pre class="oac_no_warn" dir="ltr">CREATE TABLE SYNCREF_TABLE（statement_id VARCHAR2（30），schema_name VARCHAR2（30），table_name VARCHAR2（30），mv_schema_name VARCHAR2（30），mv_name VARCHAR2（30），符合条件的VARCHAR2（1）， - 'Y'，'N'seq_num NUMBER，msg_number NUMBER，消息VARCHAR2（4000））;</pre><p>您必须在同一个表上为此过程的每次调用提供不同的<code class="codeph">statement_id</code>参数。如果不是，则会抛出错误。<code class="codeph">statement_id</code> ， <code class="codeph">schema_name</code>和<code class="codeph">table_name</code>字段标识给定表和<code class="codeph">statement_id</code>的结果。
                        </p>
                        <p>每行包含有关表或其从属物化视图的合格性的信息。<code class="codeph">CAN_SYNCREF_TABLE</code>函数保证每行都具有<code class="codeph">mv_schema_name</code>和<code class="codeph">mv_name</code>值，这些<code class="codeph">mv_schema_name</code> <code class="codeph">NULL</code>或非<code class="codeph">NULL</code> 。这些行具有以下语义：</p>
                     </div>
                     <!-- class="section" -->
                     <div class="section">
                        <ul style="list-style-type:disc">
                           <li>
                              <p>如果<code class="codeph">mv_schema_name</code>值为<code class="codeph">NULL</code>且<code class="codeph">mv_name</code>为<code class="codeph">NULL</code> ，则<code class="codeph">ELIGIBLE</code>字段描述该表是否符合同步刷新的条件;如果表不符合条件，则<code class="codeph">MSG_NUMBER</code>和<code class="codeph">MESSAGE</code>字段提供此原因。
                              </p>
                           </li>
                           <li>
                              <p>如果<code class="codeph">mv_schema_name</code>值为<code class="codeph">NOT</code> <code class="codeph">NULL</code>且<code class="codeph">mv_name</code>为<code class="codeph">NOT</code> <code class="codeph">NULL</code> ，则<code class="codeph">ELIGIBLE</code>字段描述物化视图是否符合同步刷新的条件;如果物化视图<code class="codeph">MSG_NUMBER</code> ，则<code class="codeph">MSG_NUMBER</code>和<code class="codeph">MESSAGE</code>字段提供此原因。
                              </p>
                           </li>
                        </ul>
                        <p>您必须在同一个表上为此过程的每次调用提供不同的<code class="codeph">statement_id</code>参数，否则将引发错误。<code class="codeph">statement_id</code> ， <code class="codeph">schema_name</code>和<code class="codeph">table_name</code>字段标识给定表和<code class="codeph">statement_id</code>的结果。
                        </p>
                     </div>
                     <!-- class="section" -->
                  </div>
               </div><a id="DWHSG9149"></a><div class="props_rev_3"><a id="GUID-07ED0045-231C-477A-91F8-109BF4A92553" name="GUID-07ED0045-231C-477A-91F8-109BF4A92553"></a><h4 id="DWHSG-GUID-07ED0045-231C-477A-91F8-109BF4A92553" class="sect4"><span class="enumeration_section">8.6.2</span>使用VARRAY存储同步刷新资格分析的结果</h4>
                  <div>
                     <div class="section">
                        <p>您可以将<code class="codeph">CAN_SYNCREF_TABLE</code>函数的输出保存在PL / SQL <code class="codeph">VARRAY</code> 。此数组的元素是<code class="codeph">CanSyncRefMessage</code>类型，它在<code class="codeph">SYS</code>模式中预定义，如以下示例所示：</p><pre class="oac_no_warn" dir="ltr">TYPE CanSyncRefMessage IS OBJECT（schema_name VARCHAR2（30），table_name VARCHAR2（30），mv_schema_name VARCHAR2（30），mv_name VARCHAR2（30），符合条件的VARCHAR2（1）， - 'Y'，'N'seq_num NUMBER，msg_number NUMBER，消息VARCHAR2（4000））;</pre><p>数组类型<code class="codeph">CanSyncRefArrayType</code>是<code class="codeph">CanSyncRefMessage</code>对象的<code class="codeph">VARRAY</code> ，在<code class="codeph">SYS</code>模式中预定义，如下所示：</p><pre class="oac_no_warn" dir="ltr">TYPE CanSyncRefArrayType AS VARRAY（256）OF CanSyncRefMessage;</pre><p>每个<code class="codeph">CanSyncRefMessage</code>记录都提供有关基表资格的消息或同步刷新的从属物化视图。字段的语义与<code class="codeph">SYNCREF_TABLE</code>相应字段的语义相同。但是， <code class="codeph">SYNCREF_TABLE</code>有一个在<code class="codeph">CanSyncRefMessage</code>不存在的<code class="codeph">statement_id</code>字段，因为当使用<code class="codeph">VARRAY</code>参数调用<code class="codeph">CAN_SYNCREF_TABLE</code>过程时，不提供<code class="codeph">statement_id</code> （因为它不是必需的）。
                        </p>
                        <p><code class="codeph">CanSyncRefArrayType</code>的默认大小限制为256个元素。如果需要超过256个元素， <code class="codeph">CanSyncRefArray</code> <code class="codeph">SYS</code> <code class="codeph">CanSyncRefArray</code>连接并重新定义<code class="codeph">CanSyncRefArray</code> 。以<code class="codeph">SYS</code>用户身份连接时，以下命令重新定义<code class="codeph">CanSyncRefArray</code>并将限制设置为2048个元素：</p><pre class="oac_no_warn" dir="ltr">创建或替换类型CanSyncRefArrayType AS VARRAY（2048）OF SYS.CanSyncRefMessage; / GRANT EXECUTE SYS.CanSyncRefMessage TO PUBLIC;为SYS.CanSyncRefMessage创建或替换公共SYNONYM CanSyncRefMessage; / GRANT EXECUTE ON SYS.CanSyncRefArrayType TO PUBLIC;创建或替换公共SYNONYM CanSyncRefArrayType FOR SYS.CanSyncRefArrayType; /</pre></div>
                     <!-- class="section" -->
                  </div>
               </div><a id="DWHSG9150"></a><div class="props_rev_3"><a id="GUID-3EA67828-9F6F-491A-8249-55564D88F284" name="GUID-3EA67828-9F6F-491A-8249-55564D88F284"></a><h4 id="DWHSG-GUID-3EA67828-9F6F-491A-8249-55564D88F284" class="sect4"><span class="enumeration_section">8.6.3</span>演示脚本</h4>
                  <div>
                     <p><code class="codeph">rdbms/demo</code>目录中的同步刷新演示脚本包含各种同步刷新操作的最常见方案的示例，包括<code class="codeph">CAN_SYNCREF_API</code> 。主要脚本是<code class="codeph">syncref_run.sql</code> ，其日志是<code class="codeph">syncref_run.log</code> 。文件<code class="codeph">syncref_cst.sql</code>定义了两个过程<code class="codeph">DO_CST</code>和<code class="codeph">DO_CST_ARR</code> ，它们简化了<code class="codeph">CAN_SYNCREF_TABLE</code>函数的使用，并以方便的格式在屏幕上显示信息。<code class="codeph">syncref_cst.sql</code>文件中记录了此格式。
                     </p>
                  </div>
               </div>
            </div><a id="DWHSG9151"></a><div class="props_rev_3"><a id="GUID-DC8054E4-FC5E-4DF1-8484-595562EA70CB" name="GUID-DC8054E4-FC5E-4DF1-8484-595562EA70CB"></a><h3 id="DWHSG-GUID-DC8054E4-FC5E-4DF1-8484-595562EA70CB" class="sect3"><span class="enumeration_section">8.7</span>同步刷新安全注意事项概述</h3>
               <div>
                  <p><code class="codeph">DBMS_SYNC_REFRESH</code>程序包的执行权限授予<code class="codeph">PUBLIC</code> ，因此所有用户都可以执行该程序包中的过程，以对其拥有的对象执行同步刷新。数据库管理员可以对数据库中的所有表和物化视图执行同步刷新操作。
                  </p>
                  <p>通常，如果没有<code class="codeph">DBA</code>权限的用户想要在另一个用户的表上使用同步刷新，则他必须具有读取和写入该表的完整权限;也就是说，用户必须对该表或物化视图具有<code class="codeph">SELECT</code> ， <code class="codeph">INSERT</code> ， <code class="codeph">UPDATE</code>和<code class="codeph">DELETE</code>权限。用户可以具有<code class="codeph">READ</code>权限而不是<code class="codeph">SELECT</code>权限。以下是一些例外情况：</p>
                  <ul style="list-style-type:disc">
                     <li>
                        <p><code class="codeph">PURGE_REFRESH_STATS</code>和<code class="codeph">ALTER_REFRESH_STATS_RETENTION</code>函数</p>
                        <p>这两个函数实现清除策略，可用于更改默认保留期。这些功能只能由数据库管理员执行。</p>
                     </li>
                     <li>
                        <p><code class="codeph">CAN_SYNCREF_TABLE</code>函数</p>
                        <p>这是一个咨询功能，用于检查与指定表关联的所有物化视图的同步刷新的合格性。因此，此函数需要对与指定表关联的所有实例化视图具有<code class="codeph">READ</code>或<code class="codeph">SELECT</code>权限。
                        </p>
                     </li>
                  </ul>
               </div>
            </div>
         </div>
      </article>
   </body>
</html>