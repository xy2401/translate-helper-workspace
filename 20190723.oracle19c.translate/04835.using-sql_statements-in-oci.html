<html lang="en-us" dir="ltr" xml:lang="en-us">
   <head>
      <meta http-equiv="Content-Type" content="text/html; charset=utf-8"></meta>
      <meta name="viewport" content="width=device-width, initial-scale=1"></meta>
      <meta http-equiv="X-UA-Compatible" content="IE=edge"></meta>
      <meta name="abstract" content="This chapter discusses the concepts and steps involved in processing SQL statements with Oracle Call Interface."></meta>
      <meta name="description" content="This chapter discusses the concepts and steps involved in processing SQL statements with Oracle Call Interface."></meta>
      <title>在OCI中使用SQL语句</title>
      <meta property="og:site_name" content="Oracle Help Center"></meta>
      <meta property="og:title" content="Programmer&#39;s Guide"></meta>
      <meta property="og:description" content="This chapter discusses the concepts and steps involved in processing SQL statements with Oracle Call Interface."></meta>
      <link rel="stylesheet" href="/sp_common/book-template/ohc-book-template/css/book.css"></link>
      <link rel="shortcut icon" href="/sp_common/book-template/ohc-common/img/favicon.ico"></link>
      <meta name="application-name" content="Programmer&#39;s Guide"></meta>
      <meta name="generator" content="DITA Open Toolkit version 1.8.5 (Mode = doc)"></meta>
      <meta name="plugin" content="SP_docbuilder HTML plugin release 18.2.2"></meta>
      <link rel="alternate" href="oracle-call-interface-programmers-guide.pdf" title="PDF File" type="application/pdf"></link>
      <meta name="robots" content="all"></meta>
      <link rel="schema.dcterms" href="http://purl.org/dc/terms/"></link>
      <meta name="dcterms.created" content="2019-01-14T08:46:00-08:00"></meta>
      
      <meta name="dcterms.dateCopyrighted" content="1996, 2019"></meta>
      <meta name="dcterms.category" content="database"></meta>
      <meta name="dcterms.identifier" content="E96204-01"></meta>
      
      <meta name="dcterms.product" content="en/database/oracle/oracle-database/19"></meta>
      
      <link rel="prev" href="data-types.html" title="Previous" type="text/html"></link>
      <link rel="next" href="binding-and-defining-in-oci.html" title="Next" type="text/html"></link>
      <script>
        document.write('<style type="text/css">');
        document.write('body > .noscript, body > .noscript ~ * { visibility: hidden; }');
        document.write('</style>');
     </script>
      <script src="/sp_common/book-template/requirejs/require.js" data-main="/sp_common/book-template/ohc-book-template/js/book-config"></script>
      <script>
            if (window.require === undefined) {
                document.write('<script data-main="sp_common/book-template/ohc-book-template/js/book-config" src="sp_common/book-template/requirejs/require.js"><\/script>');
                document.write('<link href="sp_common/book-template/ohc-book-template/css/book.css" rel="stylesheet"/>');
            }
        </script>
      <script type="application/json" id="ssot-metadata">{"primary":{"category":{"short_name":"database","element_name":"Database","display_in_url":true},"suite":{"short_name":"oracle","element_name":"Oracle","display_in_url":true},"product_group":{"short_name":"not-applicable","element_name":"Not applicable","display_in_url":false},"product":{"short_name":"oracle-database","element_name":"Oracle Database","display_in_url":true},"release":{"short_name":"19","element_name":"Release 19","display_in_url":true}}}</script>
      
    <meta name="dcterms.title" content="Oracle Call Interface Programmer&#39;s Guide"></meta>
    <meta name="dcterms.isVersionOf" content="LNOCI"></meta>
    <meta name="dcterms.release" content="Release 19"></meta>
  </head>
   <body dir="ltr">
      <div class="noscript alert alert-danger text-center" role="alert">
         <a href="data-types.html" class="pull-left"><span class="glyphicon glyphicon-chevron-left" aria-hidden="true"></span>上一页</a> <a href="binding-and-defining-in-oci.html" class="pull-right">下一页<span class="glyphicon glyphicon-chevron-right" aria-hidden="true"></span></a> <span class="fa fa-exclamation-triangle" aria-hidden="true"></span>必须启用JavaScript才能正确显示此内容</div>
      <article>
         <header>
            <ol class="breadcrumb" vocab="http://schema.org/" typeof="BreadcrumbList">
               <li property="itemListElement" typeof="ListItem"><a href="index.html" property="item" typeof="WebPage"><span property="name">程序员指南</span></a></li>
               <li class="active" property="itemListElement" typeof="ListItem">在OCI中使用SQL语句</li>
            </ol>
            <a id="GUID-3F20EDC9-D436-4A54-9698-4FA95988A819" name="GUID-3F20EDC9-D436-4A54-9698-4FA95988A819"></a><a id="LNOCI040"></a>
            
            <h2 id="LNOCI-GUID-3F20EDC9-D436-4A54-9698-4FA95988A819" class="sect2"><span class="enumeration_chapter">6</span>在OCI中使用SQL语句</h2>
         </header>
         <div class="ind">
            <div>
               <p>本章讨论使用Oracle Call Interface处理SQL语句时涉及的概念和步骤。</p>
               <p>本章包含以下主题：</p>
               <ul style="list-style-type:disc">
                  <li>
                     <p><a href="using-sql_statements-in-oci.html#GUID-8D6FD01B-5B8A-49A2-BFD8-71B404529F07" title="OCI程序最常见的任务之一是接受和处理SQL语句。">SQL语句处理概述</a></p>
                  </li>
                  <li>
                     <p><a href="using-sql_statements-in-oci.html#GUID-91AF021D-9FCD-4A4D-A647-2F2AB5B448B8" title="通过使用语句prepare调用和任何必要的绑定调用，准备执行SQL和PL / SQL语句。">关于准备报表</a></p>
                  </li>
                  <li>
                     <p><a href="using-sql_statements-in-oci.html#GUID-CB348BD8-9A45-4921-B397-ADFE96B75C70" title="大多数DML语句和一些查询（例如具有WHERE子句的查询）都需要程序将数据作为SQL或PL / SQL语句的一部分传递给Oracle数据库。">关于在OCI中绑定占位符</a></p>
                  </li>
                  <li>
                     <p><a href="using-sql_statements-in-oci.html#GUID-C71878A2-B089-4666-9898-AA56A54AD03D" title="OCI应用程序使用OCIStmtExecute（）单独执行预准备语句。">关于执行语句</a></p>
                  </li>
                  <li>
                     <p><a href="using-sql_statements-in-oci.html#GUID-DDB109DD-52EB-4AA8-A69A-34015F8D5D6E" title="如果您的OCI应用程序正在处理查询，您可能需要获取有关选择列表中的项目的更多信息。">关于描述选择列表项</a></p>
                  </li>
                  <li>
                     <p><a href="using-sql_statements-in-oci.html#GUID-F5FB3DBA-9FDA-45FC-AF5D-2D8D4C436296" title="Query语句将数据从数据库返回给您的应用程序。">关于在OCI中定义输出变量</a></p>
                  </li>
                  <li>
                     <p><a href="using-sql_statements-in-oci.html#GUID-E0EAF0A9-2C7D-468D-BF43-C9056F3497E6" title="如果OCI应用程序已处理查询，则通常需要在语句完成执行后使用OCIStmtFetch2（）获取结果。">关于获取结果</a></p>
                  </li>
                  <li>
                     <p><a href="using-sql_statements-in-oci.html#GUID-1728D572-BED3-4F80-BDC3-E6F9A66046B2" title="游标是结果集中的当前位置。">关于在OCI中使用可滚动游标</a></p>
                  </li>
               </ul>
            </div><a id="LNOCI16338"></a><a id="LNOCI16337"></a><div class="props_rev_3"><a id="GUID-8D6FD01B-5B8A-49A2-BFD8-71B404529F07" name="GUID-8D6FD01B-5B8A-49A2-BFD8-71B404529F07"></a><h3 id="LNOCI-GUID-8D6FD01B-5B8A-49A2-BFD8-71B404529F07" class="sect3"><span class="enumeration_section">6.1</span> SQL语句处理概述</h3>
               <div>
                  <p>OCI程序最常见的任务之一是接受和处理SQL语句。</p>
                  <p>第3章“OCI编程基础知识”讨论了任何OCI应用程序涉及的基本步骤。本章更详细地介绍了在OCI程序中处理SQL语句所涉及的特定任务。</p>
                  <p>本节概述了接受和处理SQL语句所涉及的具体步骤。</p>
                  <p>分配必要的句柄并连接到Oracle数据库后，请按照<a href="using-sql_statements-in-oci.html#GUID-8D6FD01B-5B8A-49A2-BFD8-71B404529F07__I448548">图6-1</a>中<a href="using-sql_statements-in-oci.html#GUID-8D6FD01B-5B8A-49A2-BFD8-71B404529F07__I448548">所示</a>的步骤操作。
                  </p>
                  <div class="figure" id="GUID-8D6FD01B-5B8A-49A2-BFD8-71B404529F07__I448548">
                     <p class="titleinfigure">图6-1处理SQL语句的步骤</p><img src="img/lnoci020.png" alt="下面是图6-1的描述" title="下面是图6-1的描述" longdesc="img_text/lnoci020.html"><br><a href="img_text/lnoci020.html">“图6-1处理SQL语句的步骤”的说明</a></div>
                  <!-- class="figure" -->
                  <ol>
                     <li>
                        <p>准备声明。使用<code class="codeph">OCIStmtPrepare2()</code>定义应用程序请求。<code class="codeph">OCIStmtPrepare2()</code>是一个加强版<code class="codeph">OCIStmtPrepare()</code>这是推出了支持语句缓存。从Oracle Database 12 <code class="codeph">c</code>第2版（12.2）开始，不推荐使用<code class="codeph">OCIStmtPrepare()</code> 。
                        </p>
                     </li>
                     <li>
                        <p>如有必要，绑定占位符。对于具有输入变量的DML语句和查询，请执行以下一个或多个绑定调用，以将每个输入变量（或PL / SQL输出变量）或数组的地址绑定到语句中的每个占位符。</p>
                        <ul style="list-style-type:disc">
                           <li>
                              <p><code class="codeph">OCIBindByPos2()</code>或<code class="codeph">OCIBindByPos()</code></p>
                           </li>
                           <li>
                              <p><code class="codeph">OCIBindByName2()</code>或<code class="codeph">OCIBindByName()</code></p>
                           </li>
                           <li>
                              <p><code class="codeph">OCIBindObject（）</code></p>
                           </li>
                           <li>
                              <p><code class="codeph">OCIBindDynamic（）</code></p>
                           </li>
                           <li>
                              <p><code class="codeph">OCIBindArrayOfStruct（）</code></p>
                           </li>
                        </ul>
                     </li>
                     <li>
                        <p>通过调用<code class="codeph">OCIStmtExecute()</code>执行该语句。对于DDL语句，不需要进一步的步骤。
                        </p>
                     </li>
                     <li>
                        <p>如有必要，使用<code class="codeph">OCIParamGet()</code>和<code class="codeph">OCIAttrGet()</code>描述选择列表项。如果在编译时已知选择列表项的数量和每个项的属性（例如其长度和数据类型），则不需要这是可选步骤。
                        </p>
                     </li>
                     <li>
                        <p>如有必要，定义输出变量。对于查询，执行一个或多个对<code class="codeph">OCIDefineByPos2()</code>或<code class="codeph">OCIDefineByPos()</code> ， <code class="codeph">OCIDefineObject()</code> ， <code class="codeph">OCIDefineDynamic()</code>或<code class="codeph">OCIDefineArrayOfStruct()</code>定义调用， <code class="codeph">OCIDefineByPos2()</code>为SQL语句中的每个选择列表项定义输出变量。请注意，您不使用define调用来定义匿名PL / SQL块中的输出变量。绑定数据时执行此操作。
                        </p>
                     </li>
                     <li>
                        <p>如有必要，通过调用<code class="codeph">OCIStmtFetch2()</code>获取查询结果。
                        </p>
                     </li>
                  </ol>
                  <p>完成这些步骤后，应用程序可以释放已分配的句柄，然后从服务器分离，或者它可以处理其他语句。</p>
                  <div class="infoboxnote" id="GUID-8D6FD01B-5B8A-49A2-BFD8-71B404529F07__GUID-8C43E4A5-00DA-417F-AEAC-A0925D1B1E4E">
                     <p class="notep1">注意：</p>
                     <p>OCI程序不再需要明确的解析步骤。如果必须解析语句，则该步骤在执行时发生，这意味着8.0版或更高版本的应用程序必须为DML和DDL语句发出执行命令。</p>
                  </div>
                  <p>以下部分详细介绍了每个步骤。</p>
                  <div class="infoboxnote" id="GUID-8D6FD01B-5B8A-49A2-BFD8-71B404529F07__GUID-B29CCA9E-01EC-4666-B12F-3B98118CE6FE">
                     <p class="notep1">注意：</p>
                     <p>步骤顺序的一些变化是可能的。例如，如果在编译时已知返回值的数据类型和长度，则可以在执行步骤之前执行define步骤。</p>
                  </div>
                  <p>如果您的应用程序必须执行以下任何操作，则可能需要超出前面列出的步骤：</p>
                  <ul style="list-style-type:disc">
                     <li>
                        <p>启动和管理多个交易</p>
                     </li>
                     <li>
                        <p>管理多个执行线程</p>
                     </li>
                     <li>
                        <p>执行分段插入，更新或提取</p>
                     </li>
                  </ul>
                  <div class="infoboxnotealso" id="GUID-8D6FD01B-5B8A-49A2-BFD8-71B404529F07__GUID-F46AE940-96E8-4121-8B87-26A230E94D09">
                     <p class="notep1">也可以看看：</p>
                     <ul style="list-style-type:disc">
                        <li>
                           <p><a href="performance-topics.html#GUID-4947CAE8-1F00-4897-BB2B-7F921E495175" title="语句缓存是指为每个会话提供和管理语句缓存的功能。">OCI中的语句缓存</a></p>
                        </li>
                        <li>
                           <p><a href="oci-programming-basics.html#GUID-4CFB8AF7-EF05-4E0F-847F-2D0710E552C5" title="本章介绍了使用OCI进行编程所涉及的概念和过程。">OCI编程基础</a></p>
                        </li>
                        <li>
                           <p><a href="statement-functions.html#GUID-E6C1DC67-D464-4D2A-9F19-737423D31779" title="准备SQL或PL / SQL语句以便执行。">OCIStmtPrepare2（）</a>或<a href="deprecated-oci-functions.html#GUID-FD74B639-8B97-4A5A-BC3E-269CE59345CA" title="从Oracle Database 12c第2版（12.2）开始，不推荐使用此功能。">OCIStmtPrepare（）</a></p>
                        </li>
                        <li>
                           <p><a href="bind-define-describe-functions.html#GUID-5C505821-323D-473D-825B-448C8D9A6702" title="在SQL语句或PL / SQL块中创建程序变量和占位符之间的关联。当客户端上的实际长度超过UB2MAXVAL时，在处理数据类型时使用此调用。">OCIBindByPos2（）</a>或<a href="bind-define-describe-functions.html#GUID-D28DF5A7-3C75-4E52-82F7-A5D6D5714E69" title="在SQL语句或PL / SQL块中创建程序变量和占位符之间的关联。">OCIBindByPos（）</a></p>
                        </li>
                        <li>
                           <p><a href="bind-define-describe-functions.html#GUID-55C47708-5468-4106-89BE-1AB60861D037" title="在SQL语句或PL / SQL块中创建程序变量和占位符之间的关联。当客户端上的实际长度超过UB2MAXVAL时，在处理数据类型时使用此函数。">OCIBindByName2（）</a>或<a href="bind-define-describe-functions.html#GUID-CD63DF78-2178-4727-A896-B9673C4A37F0" title="在SQL语句或PL / SQL块中创建程序变量和占位符之间的关联。">OCIBindByName（）</a></p>
                        </li>
                        <li>
                           <p><a href="bind-define-describe-functions.html#GUID-384B5D31-165B-4661-A334-8C2B5E475AEF" title="设置命名数据类型（对象）绑定所需的其他属性。">OCIBindObject（）</a></p>
                        </li>
                        <li>
                           <p><a href="bind-define-describe-functions.html#GUID-030270CB-346A-412E-B3B3-556DD6947BE2" title="注册用户回调以进行动态数据分配。">OCIBindDynamic（）</a></p>
                        </li>
                        <li>
                           <p><a href="bind-define-describe-functions.html#GUID-E83BF668-88FC-4F31-A950-3580B79588E0" title="设置静态数组绑定的跳过参数。">OCIBindArrayOfStruct（）</a></p>
                        </li>
                        <li>
                           <p><a href="statement-functions.html#GUID-98B26708-3E02-45C0-8258-5D5544F32BE9" title="将应用程序请求与服务器关联。">OCIStmtExecute（）</a></p>
                        </li>
                        <li>
                           <p><a href="handle-and-descriptor-functions.html#GUID-35D2FF91-139B-4A5C-97C8-8BC29866CCA4" title="返回由describe句柄或语句句柄中的position指定的参数的描述符。">OCIParamGet（）</a></p>
                        </li>
                        <li>
                           <p><a href="handle-and-descriptor-functions.html#GUID-FA199A99-4D7A-42C2-BB0A-C20047B95DF9" title="获取句柄属性的值。">OCIAttrGet（）</a></p>
                        </li>
                        <li>
                           <p><a href="bind-define-describe-functions.html#GUID-74939FB5-919E-4D24-B327-AFB532435061" title="将选择列表中的项与类型和输出数据缓冲区相关联。当客户端上的实际长度超过UB2MAXVAL时，在处理数据类型时使用此调用。">OCIDefineByPos2（）</a>或<a href="bind-define-describe-functions.html#GUID-CFE5AA54-DEBC-42D3-8A27-AFF1E7815691" title="将选择列表中的项与类型和输出数据缓冲区相关联。">OCIDefineByPos（）</a></p>
                        </li>
                        <li>
                           <p><a href="bind-define-describe-functions.html#GUID-F211198D-C88C-493B-A65E-2C2A95E6197B" title="设置命名数据类型或REF定义所需的其他属性。">OCIDefineObject（）</a></p>
                        </li>
                        <li>
                           <p><a href="bind-define-describe-functions.html#GUID-DD404526-9615-4E44-B790-1D17396C82A9" title="如果在OCIDefineByPos（）或OCIDefineByPos2（）中选择了OCI_DYNAMIC_FETCH模式，则设置所需的其他属性。">OCIDefineDynamic（）</a></p>
                        </li>
                        <li>
                           <p><a href="bind-define-describe-functions.html#GUID-D3F74828-5DA7-48AD-A170-120AD547DEB3" title="指定静态数组定义所需的其他属性，用于结构数组（多行，多列）提取。">OCIDefineArrayOfStruct（）</a></p>
                        </li>
                        <li>
                           <p><a href="statement-functions.html#GUID-DF585B90-58BA-45FC-B7CE-6F7F987C03B9" title="从（可滚动）结果集中获取一行。">OCIStmtFetch2（）</a></p>
                        </li>
                     </ul>
                  </div>
               </div>
            </div><a id="LNOCI16340"></a><a id="LNOCI16339"></a><div class="props_rev_3"><a id="GUID-91AF021D-9FCD-4A4D-A647-2F2AB5B448B8" name="GUID-91AF021D-9FCD-4A4D-A647-2F2AB5B448B8"></a><h3 id="LNOCI-GUID-91AF021D-9FCD-4A4D-A647-2F2AB5B448B8" class="sect3"><span class="enumeration_section">6.2</span>关于准备报表</h3>
               <div>
                  <p>通过使用语句prepare调用和任何必要的绑定调用，准备执行SQL和PL / SQL语句。</p>
                  <p>在此阶段，应用程序指定SQL或PL / SQL语句，并将语句中的关联占位符绑定到要执行的数据。客户端库分配存储以维护为执行准备的语句。</p>
                  <p>应用程序请求使用<code class="codeph">OCIStmtPrepare2()</code>调用准备执行SQL或PL / SQL语句，并将先前分配的语句句柄传递给此调用。这是一个完全本地的呼叫，不需要往返服务器。此时语句与特定服务器之间没有关联。
                  </p>
                  <p>在请求调用之后，应用程序可以在语句句柄上调用<code class="codeph">OCIAttrGet()</code> ，将<code class="codeph">OCI_ATTR_STMT_TYPE</code>传递给<code class="codeph">attrtype</code>参数，以确定准备了哪种类型的SQL语句。<a href="using-sql_statements-in-oci.html#GUID-91AF021D-9FCD-4A4D-A647-2F2AB5B448B8__CIHEHCEJ" title="该表有2列。第1列是属性值，第2列描述其对应的SQL语句类型。">表6-1</a>中列出了可能的属性值和相应的语句类型。
                  </p>
                  <div class="tblformal" id="GUID-91AF021D-9FCD-4A4D-A647-2F2AB5B448B8__CIHEHCEJ">
                     <p class="titleintable">表6-1 OCI_ATTR_STMT_TYPE值和语句类型</p>
                     <table cellpadding="4" cellspacing="0" class="Formal" title="OCI_ATTR_STMT_TYPE值和语句类型" width="100%" border="1" summary="This table has 2 columns. Column 1 is the attribute value and column 2 describes its corresponding SQL statement type." frame="hsides" rules="rows">
                        <thead>
                           <tr align="left" valign="top">
                              <th align="left" valign="bottom" width="45%" id="d70425e967">属性值</th>
                              <th align="left" valign="bottom" width="55%" id="d70425e970">声明类型</th>
                           </tr>
                        </thead>
                        <tbody>
                           <tr align="left" valign="top">
                              <td align="left" valign="top" width="45%" id="d70425e975" headers="d70425e967 ">
                                 <p><code class="codeph">OCI_STMT_SELECT</code></p>
                              </td>
                              <td align="left" valign="top" width="55%" headers="d70425e975 d70425e970 ">
                                 <p><code class="codeph">SELECT</code>语句</p>
                              </td>
                           </tr>
                           <tr align="left" valign="top">
                              <td align="left" valign="top" width="45%" id="d70425e985" headers="d70425e967 ">
                                 <p><code class="codeph">OCI_STMT_UPDATE</code></p>
                              </td>
                              <td align="left" valign="top" width="55%" headers="d70425e985 d70425e970 ">
                                 <p><code class="codeph">UPDATE</code>声明</p>
                              </td>
                           </tr>
                           <tr align="left" valign="top">
                              <td align="left" valign="top" width="45%" id="d70425e995" headers="d70425e967 ">
                                 <p><code class="codeph">OCI_STMT_DELETE</code></p>
                              </td>
                              <td align="left" valign="top" width="55%" headers="d70425e995 d70425e970 ">
                                 <p><code class="codeph">DELETE</code>语句</p>
                              </td>
                           </tr>
                           <tr align="left" valign="top">
                              <td align="left" valign="top" width="45%" id="d70425e1005" headers="d70425e967 ">
                                 <p><code class="codeph">OCI_STMT_INSERT</code></p>
                              </td>
                              <td align="left" valign="top" width="55%" headers="d70425e1005 d70425e970 ">
                                 <p><code class="codeph">INSERT</code>语句</p>
                              </td>
                           </tr>
                           <tr align="left" valign="top">
                              <td align="left" valign="top" width="45%" id="d70425e1015" headers="d70425e967 ">
                                 <p><code class="codeph">OCI_STMT_CREATE</code></p>
                              </td>
                              <td align="left" valign="top" width="55%" headers="d70425e1015 d70425e970 ">
                                 <p><code class="codeph">CREATE</code>语句</p>
                              </td>
                           </tr>
                           <tr align="left" valign="top">
                              <td align="left" valign="top" width="45%" id="d70425e1025" headers="d70425e967 ">
                                 <p><code class="codeph">OCI_STMT_DROP</code></p>
                              </td>
                              <td align="left" valign="top" width="55%" headers="d70425e1025 d70425e970 ">
                                 <p><code class="codeph">DROP</code>语句</p>
                              </td>
                           </tr>
                           <tr align="left" valign="top">
                              <td align="left" valign="top" width="45%" id="d70425e1035" headers="d70425e967 ">
                                 <p><code class="codeph">OCI_STMT_ALTER</code></p>
                              </td>
                              <td align="left" valign="top" width="55%" headers="d70425e1035 d70425e970 ">
                                 <p><code class="codeph">ALTER</code>声明</p>
                              </td>
                           </tr>
                           <tr align="left" valign="top">
                              <td align="left" valign="top" width="45%" id="d70425e1045" headers="d70425e967 ">
                                 <p><code class="codeph">OCI_STMT_BEGIN</code></p>
                              </td>
                              <td align="left" valign="top" width="55%" headers="d70425e1045 d70425e970 ">
                                 <p><code class="codeph">BEGIN</code> ......（PL / SQL）</p>
                              </td>
                           </tr>
                           <tr align="left" valign="top">
                              <td align="left" valign="top" width="45%" id="d70425e1055" headers="d70425e967 ">
                                 <p><code class="codeph">OCI_STMT_DECLARE</code></p>
                              </td>
                              <td align="left" valign="top" width="55%" headers="d70425e1055 d70425e970 ">
                                 <p><code class="codeph">DECLARE</code> ......（PL / SQL）</p>
                              </td>
                           </tr>
                           <tr align="left" valign="top">
                              <td align="left" valign="top" width="45%" id="d70425e1065" headers="d70425e967 ">
                                 <p><code class="codeph">OCI_STMT_CALL</code></p>
                              </td>
                              <td align="left" valign="top" width="55%" headers="d70425e1065 d70425e970 ">
                                 <p><code class="codeph">CALL</code> ......（PL / SQL）</p>
                              </td>
                           </tr>
                           <tr align="left" valign="top">
                              <td align="left" valign="top" width="45%" id="d70425e1075" headers="d70425e967 ">
                                 <p><code class="codeph">OCI_STMT_MERGE</code></p>
                              </td>
                              <td align="left" valign="top" width="55%" headers="d70425e1075 d70425e970 ">
                                 <p><code class="codeph">MERGE</code> ......（PL / SQL）</p>
                              </td>
                           </tr>
                        </tbody>
                     </table>
                  </div>
                  <!-- class="inftblhruleinformal" -->
                  <p>本节包括以下主题： <a href="using-sql_statements-in-oci.html#GUID-1FC53A56-7859-4099-8DB8-7674FB2470D5" title="通过将语句句柄与服务器的相应服务上下文句柄重新关联，可以在运行时在多个服务器上执行准备好的应用程序请求。">关于在多个服务器上使用预准备语句</a></p>
                  <div class="infoboxnotealso" id="GUID-91AF021D-9FCD-4A4D-A647-2F2AB5B448B8__GUID-B0A1D3C7-C225-412D-9AEC-2987E671F870">
                     <p class="notep1">也可以看看：</p>
                     <ul style="list-style-type:disc">
                        <li>
                           <p><a href="statement-functions.html#GUID-E6C1DC67-D464-4D2A-9F19-737423D31779" title="准备SQL或PL / SQL语句以便执行。">OCIStmtPrepare2（）</a></p>
                        </li>
                        <li>
                           <p><a href="handle-and-descriptor-functions.html#GUID-FA199A99-4D7A-42C2-BB0A-C20047B95DF9" title="获取句柄属性的值。">OCIAttrGet（）</a></p>
                        </li>
                        <li>
                           <p><a href="oci-programming-basics.html#GUID-46090C93-4BC4-4E88-AA09-3E9B716917A3" title="PL / SQL是Oracle对SQL语言的过程扩展。">关于在OCI程序中使用PL / SQL</a></p>
                        </li>
                     </ul>
                  </div>
               </div><a id="LNOCI16341"></a><div class="props_rev_3"><a id="GUID-1FC53A56-7859-4099-8DB8-7674FB2470D5" name="GUID-1FC53A56-7859-4099-8DB8-7674FB2470D5"></a><h4 id="LNOCI-GUID-1FC53A56-7859-4099-8DB8-7674FB2470D5" class="sect4"><span class="enumeration_section">6.2.1</span>关于在多个服务器上使用准备好的语句</h4>
                  <div>
                     <p>通过将语句句柄与服务器的相应服务上下文句柄重新关联，可以在运行时在多个服务器上执行准备好的应用程序请求。</p>
                     <p>在建立新关联时，有关当前服务上下文和语句句柄关联的所有信息都将丢失。</p>
                     <p>例如，考虑管理多个服务器的应用程序，例如网络管理器。在许多情况下，可能必须对多个服务器执行相同的<code class="codeph">SELECT</code>语句以检索要显示的信息。OCI允许网络管理器应用程序准备一次<code class="codeph">SELECT</code>语句并针对多个服务器执行它。在将准备好的语句与下一个服务器重新关联之前，它必须从每个服务器获取所有必需的行。
                     </p>
                     <div class="infoboxnote" id="GUID-1FC53A56-7859-4099-8DB8-7674FB2470D5__GUID-D891C149-5A14-49C1-8554-F2402CF925D4">
                        <p class="notep1">注意：</p>
                        <p>如果必须在同一服务器上频繁地重新执行预准备语句，则为另一个服务上下文准备新语句会更有效。</p>
                     </div>
                  </div>
               </div>
            </div><a id="LNOCI72596"></a><a id="LNOCI16342"></a><div class="props_rev_3"><a id="GUID-CB348BD8-9A45-4921-B397-ADFE96B75C70" name="GUID-CB348BD8-9A45-4921-B397-ADFE96B75C70"></a><h3 id="LNOCI-GUID-CB348BD8-9A45-4921-B397-ADFE96B75C70" class="sect3"><span class="enumeration_section">6.3</span>关于OCI中的绑定占位符</h3>
               <div>
                  <p>大多数DML语句和一些查询（例如具有<code class="codeph">WHERE</code>子句的<code class="codeph">WHERE</code> ）都需要程序将数据作为SQL或PL / SQL语句的一部分传递给Oracle数据库。
                  </p>
                  <p>这些数据可以是常量或文字，在编译程序时已知。例如，以下将数据库添加到数据库的SQL语句包含多个文字，例如“BESTRY”和2365：</p><pre class="oac_no_warn" dir="ltr">INSERT INTO VALUES（2365，'BESTRY'，'PROGRAMMER'，2000,20）</pre><p>将这样的语句编码到应用程序中将严重限制其有用性。每次将新员工添加到数据库时，都必须更改语句并重新编译程序。为了使程序更加灵活，您可以编写程序，以便用户可以在运行时提供输入数据。</p>
                  <p>当您准备包含要在运行时提供的输入数据的SQL语句或PL / SQL块时，SQL语句或PL / SQL块中的占位符标记必须提供数据的位置。例如，以下SQL语句包含五个占位符（由前面的冒号（ <code class="codeph">:ename</code> ）表示），用于显示程序必须提供输入数据的位置。
                  </p><pre class="oac_no_warn" dir="ltr">INSERT INTO emp VALUES（：empno，：ename，：job，：sal，：deptno）</pre><p>您可以在任何<code class="codeph">DELETE</code> ， <code class="codeph">INSERT</code> ， <code class="codeph">SELECT</code>或<code class="codeph">UPDATE</code>语句中或PL / SQL块中的输入变量中使用占位符，在语句中可以使用表达式或文字值的任何位置。在PL / SQL中，占位符也可用于输出变量。
                  </p>
                  <p>占位符不能用于表示其他Oracle对象，例如表。例如，以下内容<span class="italic">不是</span> <code class="codeph">emp</code>占位符的有效用法：</p><pre class="oac_no_warn" dir="ltr">INSERT INTO：emp VALUES（12345，'OERTEL'，'WRITER'，50000,30）</pre><p>对于SQL语句或PL / SQL块中的每个占位符，必须调用OCI例程，该例程将程序中变量的地址绑定到该占位符。当语句执行时，数据库将获取程序放入输入变量或绑定变量的数据，并使用SQL语句将其传递给服务器。</p>
                  <p>绑定用于非查询操作中的输入和输出变量。在<a href="using-sql_statements-in-oci.html#GUID-CB348BD8-9A45-4921-B397-ADFE96B75C70__CIHHHEFJ">示例6-1中</a> ，应绑定变量<code class="codeph">empno_out</code> ， <code class="codeph">ename_out</code> ， <code class="codeph">job_out</code> ， <code class="codeph">sal_out</code>和<code class="codeph">deptno_out</code> 。这些是outbinds（与常规的inbinds相对）。
                  </p>
                  <div class="example" id="GUID-CB348BD8-9A45-4921-B397-ADFE96B75C70__CIHHHEFJ">
                     <p class="titleinexample">例6-1在非查询操作中绑定输入和输出变量</p><pre class="oac_no_warn" dir="ltr">INSERT INTO emp VALUES（：empno，：ename，：job，：sal，：deptno）RETURNING（empno，ename，job，sal，deptno）INTO（：empno_out，：ename_out，：job_out，：sal_out，：deptno_out）</pre></div>
                  <!-- class="example" -->
                  <div class="section">
                     <p>本节包括以下主题： <a href="using-sql_statements-in-oci.html#GUID-A0A6D04B-C60D-4499-9951-873A6DD7D0D2" title="列出并描述形成占位符的规则。">占位符规则</a></p>
                     <div class="infoboxnotealso" id="GUID-CB348BD8-9A45-4921-B397-ADFE96B75C70__GUID-4E05D7F7-1F88-4456-AFF9-1261EA92761B">
                        <p class="notep1">也可以看看：</p>
                        <p><a href="binding-and-defining-in-oci.html#GUID-4C2BD7BB-5768-4E8A-82BF-84FB0030A8C5" title="本章介绍OCI中的绑定和定义。">OCI中的绑定和定义，</a>以获取有关实现绑定操作的详细信息</p>
                     </div>
                  </div>
                  <!-- class="section" -->
               </div><a id="LNOCI16343"></a><div class="props_rev_3"><a id="GUID-A0A6D04B-C60D-4499-9951-873A6DD7D0D2" name="GUID-A0A6D04B-C60D-4499-9951-873A6DD7D0D2"></a><h4 id="LNOCI-GUID-A0A6D04B-C60D-4499-9951-873A6DD7D0D2" class="sect4"><span class="enumeration_section">6.3.1</span>占位符规则</h4>
                  <div>
                     <p>列出并描述形成占位符的规则。</p>
                     <p>形成占位符的规则如下：</p>
                     <ul style="list-style-type:disc">
                        <li>
                           <p>第一个字符是冒号（“：”）。</p>
                        </li>
                        <li>
                           <p>冒号之后是下划线（“_”），A到Z，a到z或0到9的组合。但是，冒号后面的第一个字符不能是下划线。</p>
                        </li>
                        <li>
                           <p>这些字母必须仅来自英文字母，并且只有冒号后的前30个字符才有意义。该名称不区分大小写。</p>
                        </li>
                        <li>
                           <p>占位符只能包含冒号后的数字。如果只是数字，则占位符必须小于65536。如果名称以数字开头，则只允许数字。</p>
                        </li>
                        <li>
                           <p>连字符（“ - ”）是不允许的。</p>
                        </li>
                     </ul>
                  </div>
               </div>
            </div><a id="LNOCI16344"></a><div class="props_rev_3"><a id="GUID-C71878A2-B089-4666-9898-AA56A54AD03D" name="GUID-C71878A2-B089-4666-9898-AA56A54AD03D"></a><h3 id="LNOCI-GUID-C71878A2-B089-4666-9898-AA56A54AD03D" class="sect3"><span class="enumeration_section">6.4</span>关于执行语句</h3>
               <div>
                  <p>OCI应用程序使用<code class="codeph">OCIStmtExecute()</code>单独执行<code class="codeph">OCIStmtExecute()</code>准备语句。
                  </p>
                  <p>当OCI应用程序执行查询时，它从Oracle数据库接收与查询规范匹配的数据。在数据库中，数据以Oracle定义的格式存储。返回结果时，OCI应用程序可以请求将数据转换为特定的主机语言格式，并存储在特定的输出变量或缓冲区中。</p>
                  <p>对于查询的选择列表中的每个项目，OCI应用程序必须定义输出变量以接收查询的结果。define步骤指示缓冲区的地址和要检索的数据类型。</p>
                  <div class="infoboxnote" id="GUID-C71878A2-B089-4666-9898-AA56A54AD03D__GUID-E82F5F0B-DD20-49FE-8E4D-8E4AACE9D0E1">
                     <p class="notep1">注意：</p>
                     <p>如果在调用<code class="codeph">OCIStmtExecute()</code>之前为<code class="codeph">SELECT</code>语句定义了输出变量，则会将<code class="codeph">iters</code>参数指定的行数直接提取到定义的输出缓冲区中，并预取与预取计数等效的其他行。如果没有其他行，则完成提取而不调用<code class="codeph">OCIStmtFetch2()</code> 。
                     </p>
                  </div>
                  <p><span class="bold"></span>对于非查询，在数组操作期间执行语句的次数等于<code class="codeph">iters - rowoff</code> ，其中<code class="codeph">rowoff</code>是绑定数组中的偏移量，并且也是<code class="codeph">OCIStmtExecute()</code>调用的参数。
                  </p>
                  <p>例如，如果将10个项的数组绑定到<code class="codeph">INSERT</code>语句的占位符，并且将<code class="codeph">iters</code>设置为10，则当<code class="codeph">rowoff</code>为零时，所有10个项都将插入到单个执行调用中。如果<code class="codeph">rowoff</code>设置为2，则仅插入8个项目。
                  </p>
                  <div class="p">本节包括以下主题：<ul style="list-style-type:disc">
                        <li>
                           <p><a href="using-sql_statements-in-oci.html#GUID-A4D09C66-C273-46C3-9EC8-0BCFBE4E61CF" title="OCIStmtExecute（）调用提供了确保多个服务上下文在数据库提交的数据的相同一致快照上运行的能力。">执行快照</a></p>
                        </li>
                        <li>
                           <p><a href="using-sql_statements-in-oci.html#GUID-AE8B3835-50CD-49DB-925A-740F31E7FD3B" title="您可以为OCIStmtExecute（）调用指定多种模式。">OCIStmtExecute（）的执行模式</a></p>
                        </li>
                     </ul>
                  </div>
                  <div class="infoboxnotealso" id="GUID-C71878A2-B089-4666-9898-AA56A54AD03D__GUID-DD1BFE0C-6D36-4D60-8C8A-38A9591A5568">
                     <p class="notep1">也可以看看：</p>
                     <ul style="list-style-type:disc">
                        <li>
                           <p><a href="statement-functions.html#GUID-98B26708-3E02-45C0-8258-5D5544F32BE9" title="将应用程序请求与服务器关联。">OCIStmtExecute（）</a></p>
                        </li>
                        <li>
                           <p><a href="statement-functions.html#GUID-DF585B90-58BA-45FC-B7CE-6F7F987C03B9" title="从（可滚动）结果集中获取一行。">OCIStmtFetch2（）</a></p>
                        </li>
                        <li>
                           <p><a href="using-sql_statements-in-oci.html#GUID-F5FB3DBA-9FDA-45FC-AF5D-2D8D4C436296" title="Query语句将数据从数据库返回给您的应用程序。">关于在OCI中定义输出变量</a></p>
                        </li>
                     </ul>
                  </div>
               </div><a id="LNOCI16345"></a><div class="props_rev_3"><a id="GUID-A4D09C66-C273-46C3-9EC8-0BCFBE4E61CF" name="GUID-A4D09C66-C273-46C3-9EC8-0BCFBE4E61CF"></a><h4 id="LNOCI-GUID-A4D09C66-C273-46C3-9EC8-0BCFBE4E61CF" class="sect4"><span class="enumeration_section">6.4.1</span>执行快照</h4>
                  <div>
                     <p><code class="codeph">OCIStmtExecute()</code>调用提供了确保多个服务上下文在数据库提交的数据的相同一致快照上运行的能力。
                     </p>
                     <p>这是通过获取一个<code class="codeph">OCIStmtExecute()</code>调用的<code class="codeph">snap_out</code>参数的内容并将该值作为下一个<code class="codeph">OCIStmtExecute()</code>调用的<code class="codeph">snap_in</code>参数传递来实现的。
                     </p>
                     <div class="infoboxnote" id="GUID-A4D09C66-C273-46C3-9EC8-0BCFBE4E61CF__GUID-5D019542-B9C5-4317-B3E3-22C4866E490D">
                        <p class="notep1">注意：</p>
                        <p>即使两个调用都使用相同的快照，一个服务上下文中的未提交数据<span class="italic">也不</span>会对另一个上下文可见。
                        </p>
                     </div>
                     <p><code class="codeph">snap_out</code>和<code class="codeph">snap_in</code>参数的数据类型是<code class="codeph">OCISnapshot</code> 。OCISnapshot是使用<code class="codeph">OCIDescriptorAlloc()</code>函数分配的OCI快照描述符。
                     </p>
                     <p>调用<code class="codeph">OCIStmtExecute()</code>时无需指定<span class="italic">快照</span> 。以下示例代码显示了一个基本执行，其中<code class="codeph">snapsho</code> t参数作为<code class="codeph">NULL</code>传递。</p><pre class="oac_no_warn" dir="ltr">checkerr（errhp，OCIStmtExecute（svchp，stmthp，errhp，（ub4）1，（ub4）0，（OCISnapshot *）NULL，（OCISnapshot *）NULL，OCI_DEFAULT））;</pre><div class="infoboxnote" id="GUID-A4D09C66-C273-46C3-9EC8-0BCFBE4E61CF__GUID-ED0C13AA-D35C-4C64-B371-ED41963F76B8">
                        <p class="notep1">注意：</p>
                        <p>用户开发的<code class="codeph">checkerr()</code>函数评估来自OCI应用程序的返回码。
                        </p>
                     </div>
                     <div class="infoboxnotealso" id="GUID-A4D09C66-C273-46C3-9EC8-0BCFBE4E61CF__GUID-B93B608C-7050-492B-9882-B314A1F8445C">
                        <p class="notep1">也可以看看：</p>
                        <ul style="list-style-type:disc">
                           <li>
                              <p><a href="statement-functions.html#GUID-98B26708-3E02-45C0-8258-5D5544F32BE9" title="将应用程序请求与服务器关联。">OCIStmtExecute（）</a></p>
                           </li>
                           <li>
                              <p><a href="handle-and-descriptor-functions.html#GUID-E9EF2766-E078-49A7-B1D1-738E4BA4814F" title="分配存储以保存描述符或LOB定位符。">OCIDescriptorAlloc（）</a></p>
                           </li>
                           <li>
                              <p><a href="oci-programming-basics.html#GUID-82F35CC7-A79D-42CE-BF90-DE63FCBAAB7C" title="OCI描述符和定位符是不透明的数据结构，用于维护特定于数据的信息。">OCI描述符</a></p>
                           </li>
                        </ul>
                     </div>
                  </div>
               </div><a id="LNOCI16346"></a><div class="props_rev_3"><a id="GUID-AE8B3835-50CD-49DB-925A-740F31E7FD3B" name="GUID-AE8B3835-50CD-49DB-925A-740F31E7FD3B"></a><h4 id="LNOCI-GUID-AE8B3835-50CD-49DB-925A-740F31E7FD3B" class="sect4"><span class="enumeration_section">6.4.2</span> OCIStmtExecute（）的执行模式</h4>
                  <div>
                     <p>您可以为<code class="codeph">OCIStmtExecute()</code>调用指定多种模式。
                     </p>
                     <p>本节介绍OCIStmtExecute（）调用。有关参数<code class="codeph">mode</code>其他值，请参阅<code class="codeph">OCIStmtExecute()</code> 。
                     </p>
                     <div class="p">本节包括以下主题：<ul style="list-style-type:disc">
                           <li>
                              <p><a href="using-sql_statements-in-oci.html#GUID-665D540E-9BD1-4505-9FB8-1EBD7C0DFB7D" title="OCI提供执行阵列DML操作的能力。">使用批处理错误模式</a></p>
                           </li>
                           <li>
                              <p><a href="using-sql_statements-in-oci.html#GUID-4DC077FC-7F6C-4EB0-830C-530642A46B9D" title="显示如何使用批处理错误执行模式。">批错误模式的示例</a></p>
                           </li>
                        </ul>
                     </div>
                     <div class="infoboxnotealso" id="GUID-AE8B3835-50CD-49DB-925A-740F31E7FD3B__GUID-0BB59F1B-28D3-406F-8C78-F32F8F735B52">
                        <p class="notep1">也可以看看：</p>
                        <p><a href="statement-functions.html#GUID-98B26708-3E02-45C0-8258-5D5544F32BE9" title="将应用程序请求与服务器关联。">OCIStmtExecute（）</a></p>
                     </div>
                  </div><a id="LNOCI16347"></a><div class="props_rev_3"><a id="GUID-665D540E-9BD1-4505-9FB8-1EBD7C0DFB7D" name="GUID-665D540E-9BD1-4505-9FB8-1EBD7C0DFB7D"></a><h5 id="LNOCI-GUID-665D540E-9BD1-4505-9FB8-1EBD7C0DFB7D" class="sect5"><span class="enumeration_section">6.4.2.1</span>使用批处理错误模式</h5>
                     <div>
                        <p>OCI提供执行阵列DML操作的能力。</p>
                        <div class="section">
                           <p>例如，应用程序可以使用单个语句执行来处理<code class="codeph">INSERT</code> ， <code class="codeph">UPDATE</code>或<code class="codeph">DELETE</code>语句的数组。如果其中一个操作由于服务器的错误而失败，例如唯一约束违规，则阵列操作终止，并且OCI返回错误。数组中剩余的所有行都将被忽略。然后，应用程序必须重新执行数组的其余部分，如果遇到更多错误，则会再次完成整个过程，这会导致额外的往返。
                           </p>
                           <p>为了便于处理阵列DML操作，OCI提供<span class="italic">批处理错误模式</span> （也称为<span class="italic">增强型DML阵列</span>功能）。如果存在一个或多个错误，则在<code class="codeph">OCIStmtExecute()</code>调用中指定的此模式可简化DML阵列处理。在此模式下，OCI尝试插入，更新或删除所有行，并收集有关发生的任何错误的信息。然后，应用程序可以检索错误信息并重新执行在第一次调用期间失败的任何DML操作。这样，在第一次调用中尝试阵列中的所有DML操作，并且可以在第二次调用中重新发出任何失败的操作。
                           </p>
                           <div class="infoboxnote" id="GUID-665D540E-9BD1-4505-9FB8-1EBD7C0DFB7D__GUID-9D30323B-B0AC-4A05-906E-7D038B3A6561">
                              <p class="notep1">注意：</p>
                              <p>此功能仅适用于与8.1或更高版本服务器上运行的8.1版或更高版本OCI库链接的应用程序。还必须重新编码应用程序以考虑本节中描述的新程序逻辑。</p>
                           </div>
                           <p>此模式使用如下：</p>
                        </div>
                        <!-- class="section" -->
                        <ol>
                           <li class="stepexpand"><span>用户指定<code class="codeph">OCI_BATCH_ERRORS</code>作为<code class="codeph">OCIStmtExecute()</code>调用的<span class="italic">模式</span>参数。</span></li>
                           <li class="stepexpand"><span>在使用<code class="codeph">OCIStmtExecute()</code>执行数组DML操作后，应用程序可以通过在语句句柄上调用<code class="codeph">OCIAttrGet()</code>来检索操作期间遇到的错误数，以检索<code class="codeph">OCI_ATTR_NUM_DML_ERRORS</code>属性，如以下代码示例所示。</span><div>
                                 <p>调用OCIAttrGet（）以检索在数组DML操作期间遇到的错误数</p><pre class="oac_no_warn" dir="ltr">ub4 num_errs; OCIAttrGet（stmtp，OCI_HTYPE_STMT，＆num_errs，0，OCI_ATTR_NUM_DML_ERRORS，errhp）;</pre></div>
                           </li>
                           <li class="stepexpand"><span>应用程序使用<code class="codeph">OCIParamGet()</code>及其行信息从传递给<code class="codeph">OCIStmtExecute()</code>调用的错误句柄中提取每个错误。要检索信息，应用程序必须为<code class="codeph">OCIParamGet()</code>调用分配一个额外的新错误句柄，并使用批处理错误信息填充新的错误句柄。应用程序通过在新错误句柄上调用<code class="codeph">OCIAttrGet()</code> ，使用<code class="codeph">OCIErrorGet()</code>获取每个错误的语法，并将行偏移到发生错误的DML数组中。</span><div>
                                 <p>例如，在检索到<code class="codeph">num_errs</code> amount之后，应用程序可以发出以下代码示例中显示的以下调用。
                                 </p>
                                 <p>在数组DML操作后检索有关每个错误的信息</p><pre class="oac_no_warn" dir="ltr">OCIError errhndl，errhp2; for（i = 0; i &lt;num_errs; i ++）{OCIParamGet（errhp，OCI_HTYPE_ERROR，errhp2，（void **）＆errhndl，i）; OCIAttrGet（errhndl，OCI_HTYPE_ERROR，＆row_offset，0，OCI_ATTR_DML_ROW_OFFSET，errhp2）; OCIErrorGet（...，errhndl，...）;</pre><p>执行此操作后，应用程序可以使用从批处理错误中检索到的诊断信息来更正阵列中相应条目的绑定信息。一旦纠正或更新了适当的绑定缓冲区，应用程序就可以重新执行相关的DML语句。</p>
                                 <p>因为在编译时无法确定第一次执行中哪些行可能导致错误，所以后续DML的绑定应该通过在运行时传入适当的缓冲区来动态完成。在第一个DML操作完成的数组绑定中使用的绑定缓冲区可以重用。</p>
                                 <div class="infoboxnotealso" id="GUID-665D540E-9BD1-4505-9FB8-1EBD7C0DFB7D__GUID-05BC5278-5CD5-4A9D-AC40-741044179C67">
                                    <p class="notep1">也可以看看：</p>
                                    <ul style="list-style-type:disc">
                                       <li>
                                          <p><a href="statement-functions.html#GUID-98B26708-3E02-45C0-8258-5D5544F32BE9" title="将应用程序请求与服务器关联。">OCIStmtExecute（）</a></p>
                                       </li>
                                       <li>
                                          <p><a href="handle-and-descriptor-functions.html#GUID-FA199A99-4D7A-42C2-BB0A-C20047B95DF9" title="获取句柄属性的值。">OCIAttrGet（）</a></p>
                                       </li>
                                       <li>
                                          <p><a href="handle-and-descriptor-functions.html#GUID-35D2FF91-139B-4A5C-97C8-8BC29866CCA4" title="返回由describe句柄或语句句柄中的position指定的参数的描述符。">OCIParamGet（）</a></p>
                                       </li>
                                       <li>
                                          <p><a href="miscellaneous-functions.html#GUID-4B99087C-74F6-498A-8310-D6645172390A" title="返回错误消息和Oracle数据库错误代码。">OCIErrorGet（）</a></p>
                                       </li>
                                    </ul>
                                 </div>
                              </div>
                           </li>
                        </ol>
                     </div>
                  </div><a id="LNOCI72599"></a><a id="LNOCI16348"></a><div class="props_rev_2"><a id="GUID-4DC077FC-7F6C-4EB0-830C-530642A46B9D" name="GUID-4DC077FC-7F6C-4EB0-830C-530642A46B9D"></a><h5 id="LNOCI-GUID-4DC077FC-7F6C-4EB0-830C-530642A46B9D" class="sect5"><span class="enumeration_section">6.4.2.2</span>批错误模式示例</h5>
                     <div>
                        <p>显示如何使用批处理错误执行模式。</p>
                        <div class="section">
                           <p><a href="using-sql_statements-in-oci.html#GUID-4DC077FC-7F6C-4EB0-830C-530642A46B9D__CIHGDAIE">例6-2</a>显示了如何使用批处理错误执行模式的示例。在此示例中，假设您有一个应用程序将五行（具有两列，类型为<code class="codeph">NUMBER</code>和<code class="codeph">CHAR</code> ）插入表中。此外，假设在初始DML操作中仅成功插入了两行（1和3）。然后，用户继续纠正数据（第一次插入错误的数据）并发布带有更正数据的更新。用户使用语句处理<code class="codeph">stmtp1</code>和<code class="codeph">stmtp2</code>分别发出<code class="codeph">INSERT</code>和<code class="codeph">UPDATE</code>语句。
                           </p>
                           <p>在<a href="using-sql_statements-in-oci.html#GUID-4DC077FC-7F6C-4EB0-830C-530642A46B9D__CIHGDAIE">示例6-2中</a> ， <code class="codeph">OCIBindDynamic()</code>与回调一起使用，因为用户在编译时不知道哪些行可能返回错误。使用回调，您只需通过回调上下文传递存储在<code class="codeph">row_off</code>的错误行号，并仅发送必须更新或更正的行。可以在<code class="codeph">INSERT</code>和<code class="codeph">UPDATE</code>语句执行之间共享相同的绑定缓冲区。
                           </p>
                        </div>
                        <!-- class="section" -->
                        <div class="example" id="GUID-4DC077FC-7F6C-4EB0-830C-530642A46B9D__CIHGDAIE">
                           <p class="titleinexample">示例6-2使用批处理错误执行模式</p><pre class="oac_no_warn" dir="ltr">OCIBind * bindp1 [2]，* bindp2 [2]; ub4 num_errs，row_off [MAXROWS]，number [MAXROWS] = {1,2,3,4,5}; char grade [MAXROWS] = {'A'，'B'，'C'，'D'，'E'}; OCIError * errhp2; OCIError * errhndl [MAXROWS]; .../ *数组绑定所有位置* / OCIBindByPos（stmtp1，＆bindp1 [0]，errhp，1，（void *）＆number [0]，sizeof（number [0]），SQLT_INT，（void *）0，（ub2 * ）0，（ub2 *）0,0，（ub4 *）0，OCI_DEFAULT）; OCIBindByPos（stmtp1，＆bindp1 [1]，errhp，2，（void *）＆grade [0]，sizeof（grade [0]），SQLT_CHR，（void *）0，（ub2 *）0，（ub2 *）0， 0，（ub4 *）0，OCI_DEFAULT）; / *执行数组INSERT * / OCIStmtExecute（svchp，stmtp1，errhp，5,0,0,0，OCI_BATCH_ERRORS）; / *获取错误数量。使用不同的错误处理程序errhp2，以便*更改errhp的状态* / OCIAttrGet（stmtp1，OCI_HTYPE_STMT，＆num_errs，0，OCI_ATTR_NUM_DML_ERRORS，errhp2）; if（num_errs）{/ *用户可以执行以下两种操作之一：1）分配尽可能多的* / / *错误句柄作为错误数量，并在以后释放所有句柄* / / *;或者2）分配一个错误的句柄并重用* / / *相同的句柄用于所有错误* / for（i = 0; i &lt;num_errs; i ++）{OCIHandleAlloc（（void *）envhp，（void **）＆errhndl [ i]，（ub4）OCI_HTYPE_ERROR，0，（void *）0）; OCIParamGet（errhp，OCI_HTYPE_ERROR，errhp2，＆errhndl [i]，i）; OCIAttrGet（errhndl [i]，OCI_HTYPE_ERROR，＆row_off [i]，0，OCI_ATTR_DML_ROW_OFFSET，errhp2）; / * get server diagnostics * / OCIErrorGet（...，errhndl [i]，...）;修改绑定数据* / OCIBindByPos（stmtp2，＆bindp2 [0]，errhp，1，（void *）0，sizeof（grade [0]），SQLT_INT，（void *）0，（ub2 *） 0，（ub2 *）0,0，（ub4 *）0，OCI_DATA_AT_EXEC）; OCIBindByPos（stmtp2，＆bindp2 [1]，errhp，2，（void *）0，sizeof（number [0]），SQLT_DAT，（void *）0，（ub2 *）0，（ub2 *）0,0，（ ub4 *）0，OCI_DATA_AT_EXEC）; / *为每个绑定句柄注册回调，row_off和position *信息可以通过context *指针传递给回调函数。* / OCIBindDynamic（bindp2 [0]，errhp，ctxp1，my_callback，0,0）; OCIBindDynamic（bindp2 [1]，errhp，ctxp2，my_callback，0,0）; / *执行UPDATE语句* / OCIStmtExecute（svchp，stmtp2，errhp，num_errs，0,0,0，OCI_BATCH_ERRORS）; ...
</pre><div class="infoboxnotealso" id="GUID-4DC077FC-7F6C-4EB0-830C-530642A46B9D__GUID-81862A58-233D-4AA2-9416-7BA91BEF2EDF">
                              <p class="notep1">也可以看看：</p>
                              <p><a href="bind-define-describe-functions.html#GUID-030270CB-346A-412E-B3B3-556DD6947BE2" title="注册用户回调以进行动态数据分配。">OCIBindDynamic（）</a></p>
                           </div>
                        </div>
                        <!-- class="example" -->
                     </div>
                  </div>
               </div>
            </div><a id="LNOCI16349"></a><div class="props_rev_3"><a id="GUID-DDB109DD-52EB-4AA8-A69A-34015F8D5D6E" name="GUID-DDB109DD-52EB-4AA8-A69A-34015F8D5D6E"></a><h3 id="LNOCI-GUID-DDB109DD-52EB-4AA8-A69A-34015F8D5D6E" class="sect3"><span class="enumeration_section">6.5</span>关于描述选择列表项</h3>
               <div>
                  <p>如果您的OCI应用程序正在处理查询，您可能需要获取有关选择列表中的项目的更多信息。</p>
                  <p>对于直到运行时才知道其内容的动态查询尤其如此。在这种情况下，程序可能需要获得有关选择列表项的数据类型和列长度的信息。此信息是定义可能接收查询结果的输出变量所必需的。</p>
                  <p>例如，考虑一个查询，其中程序没有关于<code class="codeph">employees</code>表中列的先验信息：</p><pre class="oac_no_warn" dir="ltr">SELECT * FROM员工</pre><p>有两种类型的描述：隐式和显式。</p>
                  <p><span class="italic">隐式描述</span>不需要任何特殊的调用来检索描述从服务器获取信息，但特别要求<span class="italic">是</span>必要的访问信息。隐式描述允许应用程序<span class="italic">在执行</span>语句<span class="italic">之后</span>获取选择列表信息作为语句句柄的属性，而不进行特定的描述调用。它被称为<span class="italic">隐式，</span>因为不需要描述调用。描述信息随声明执行而<span class="italic">免费</span>提供。
                  </p>
                  <p><span class="italic">显式描述</span>要求应用程序调用特定函数以从服务器获取描述信息。应用程序可以隐式或显式地描述选择列表（查询）。必须明确描述其他模式元素。
                  </p>
                  <p>您可以在执行之前显式描述查询，方法是将<code class="codeph">OCI_DESCRIBE_ONLY</code>指定为<code class="codeph">OCIStmtExecute()</code>的模式，该模式不执行该语句，但返回选择列表描述。出于性能原因，Oracle建议应用程序使用隐式describe，它随标准语句执行而<span class="italic">免费</span>提供。
                  </p>
                  <p><code class="codeph">OCIDescribeAny()</code>调用的显式描述获取有关模式对象的信息，而不是选择列表。
                  </p>
                  <p>在所有情况下，通过读取句柄属性来检索有关列和数据类型的特定信息。</p>
                  <div class="p">本节包括以下主题：<ul style="list-style-type:disc">
                        <li>
                           <p><a href="using-sql_statements-in-oci.html#GUID-1494AB91-F7BD-4B73-97B9-4F3AA51D2EB2" title="执行SQL语句后，有关选择列表的信息可用作语句句柄的属性。不需要明确的描述调用。">隐含的描述</a></p>
                        </li>
                        <li>
                           <p><a href="using-sql_statements-in-oci.html#GUID-1FE451DB-FB37-4966-8334-AE04E532D27C" title="通过将OCI_DESCRIBE_ONLY指定为OCIStmtExecute（）的模式，可以在执行前显式描述查询">显式描述查询</a></p>
                        </li>
                     </ul>
                  </div>
                  <div class="infoboxnotealso" id="GUID-DDB109DD-52EB-4AA8-A69A-34015F8D5D6E__GUID-D17C0F49-3D91-4601-87CC-D3CEAA8285AA">
                     <p class="notep1">也可以看看：</p>
                     <ul style="list-style-type:disc">
                        <li>
                           <p><a href="describing-schema-metadata.html#GUID-CED0D15A-D873-43F7-A5B2-51FC0662C250" title="Performs an explicit describe of schema objects and their subschema objects.The OCIDescribeAny() call limits information returned to the basic information and stops expanding a node if it amounts to another describe operation.What to be aware of when performing describe operations.The OCI_ATTR_TYPECODE attribute returns typecodes that represent the types supplied by the user when a new type is created using the CREATE TYPE statement.To describe type objects, it is necessary to initialize the OCI process in object mode.The column attribute OCI_ATTR_PRECISION can be returned using an implicit describe with OCIStmtExecute() and an explicit describe with OCIDescribeAny().The OCI_ATTR_LIST_ARGUMENTS attribute for type methods represents second-level arguments for the method.This section describes the attributes and handles that belong to different parameters. Lists and describes the type-specific attributes for parameters for a table or view. Lists and describes the type-specific attributes when a parameter is for a procedure or function.Lists and describes the attributes when a parameter is for a package.Lists and describes the attributes when a parameter is for a type. Lists and describes the attributes when a parameter is for an attribute of a type.Lists and dsescribes the attributes when a parameter is for a method of a type.Lists and describes the attributes when a parameter is for a collection type.Lists and describes the attributes when a parameter is for a synonym.Lists and describes the attributes when a parameter is for a sequence.Lists and describes the attributes when a parameter is for a column of a table or view.Lists and describes the attributes when a parameter is for an argument of a procedure or function.Lists and describes the attributes when the parameter is for a list of columns, arguments, and subprograms, or fields of a package record type.Lists and describes the attributes when a parameter is for a schema type.Lists and describes the attributes when a parameter is for a database type.Lists and describes the attributes when a parameter is for a rule.Lists and describes the attributes when a parameter is for a rule set.Lists and describes the attributes when a parameter is for an evaluation context.Lists and describes the attributes when a parameter is for a table alias.Lists and describes the attributes when a parameter is for a variable.Lists and describes the attributes when a parameter is for a name-value pair.Query and column information are supported with character-length semantics.If the database column was created using character-length semantics, then the implicit describe information contains the character length, the byte length, and a flag indicating how the database column was created.Explicit describes of tables have three attributes: OCI_ATTR_DATA_SIZE, OCI_ATTR_CHAR_SIZE, and OCI_ATTR_CHAR_USED.Character-length semantics depends on the release of the server or client. It is best described when both server and client are Oracle9i or later. Otherwise, compatibility issues as described result.The following examples demonstrate the use of OCIDescribeAny() for describing different types of schema objects.Illustrates the use of an explicit describe that retrieves the column data types for a table.The steps required to describe type methods (also divided into functions and procedures) are identical to those of regular PL/SQL functions and procedures.Illustrates the use of an explicit describe on a named object type.Illustrates the use of an explicit describe on a named collection type.Shows a loop that retrieves the column names and data types corresponding to a query following query execution.Illustrates the use of invisible column properties and checking each column to determine if it is an invisible column.">描述模式元数据</a>以获取有关使用<a href="bind-define-describe-functions.html#GUID-AE9F73FB-DCC1-401E-8151-A8A89059163A" title="描述现有的模式和子模式对象。">OCIDescribeAny（）</a>获取与模式对象相关的<a href="describing-schema-metadata.html#GUID-CED0D15A-D873-43F7-A5B2-51FC0662C250" title="执行模式对象及其子模式对象的显式描述。OCIDescribeAny（）调用限制返回到基本信息的信息，并停止扩展节点（如果它等于另一个描述操作）。执行描述操作时应注意什么。OCI_ATTR_TYPECODE属性返回表示使用CREATE TYPE语句创建新类型时用户提供的类型的类型代码。要描述类型对象，必须在对象模式下初始化OCI进程。可以使用带有OCIStmtExecute（）的隐式描述和带有OCIDescribeAny（）的显式描述来返回列属性OCI_ATTR_PRECISION。类型方法的OCI_ATTR_LIST_ARGUMENTS属性表示方法的第二级参数。本节介绍属于不同参数的属性和句柄。列出并描述表或视图的参数的类型特定属性。列出并描述参数用于过程或函数时的特定于类型的属性。列出并描述参数用于包时的属性。列出并描述参数用于类型时的属性。列出并描述参数用于类型属性时的属性。当参数用于类型的方法时，列出并记录属性。列出并描述参数用于集合类型时的属性。列出并描述参数用于同义词时的属性。列出并描述参数用于序列时的属性。列出并描述参数用于表或视图列时的属性。列出并描述参数用于过程或函数的参数时的属性。当参数用于列，参数和子程序列表或包记录类型的字段时，列出并描述属性。列出并描述参数用于模式类型时的属性。列出并描述参数用于数据库类型时的属性。列出并描述参数用于规则时的属性。列出并描述参数用于规则集时的属性。列出并描述参数用于评估上下文时的属性。列出并描述参数用于表别名时的属性。列出并描述参数用于变量时的属性。列出并描述参数用于名称 - 值对时的属性。查询和列信息支持字符长度语义。如果使用字符长度语义创建数据库列，则隐式描述信息包含字符长度，字节长度和指示如何创建数据库列的标志。表的显式描述有三个属性：OCI_ATTR_DATA_SIZE，OCI_ATTR_CHAR_SIZE和OCI_ATTR_CHAR_USED.Character-length语义取决于服务器或客户端的发布。最好在服务器和客户端都是Oracle9i或更高版本时进行描述。否则，将导致兼容性问题。以下示例演示了如何使用OCIDescribeAny（）来描述不同类型的架构对象。说明使用显式描述来检索表的列数据类型。描述类型方法（也分为函数和过程）所需的步骤与常规PL / SQL函数和过程相同。说明在命名对象类型上使用显式描述。说明在命名集合类型上使用显式描述。显示一个循环，用于在查询执行后检索与查询对应的列名和数据类型。说明使用不可见列属性并检查每列以确定它是否为不可见列。">元数据</a>的信息</p>
                        </li>
                        <li>
                           <p><a href="statement-functions.html#GUID-98B26708-3E02-45C0-8258-5D5544F32BE9" title="将应用程序请求与服务器关联。">OCIStmtExecute（）</a></p>
                        </li>
                        <li>
                           <p><a href="bind-define-describe-functions.html#GUID-AE9F73FB-DCC1-401E-8151-A8A89059163A" title="描述现有的模式和子模式对象。">OCIDescribeAny（）</a></p>
                        </li>
                     </ul>
                     <p></p>
                  </div>
               </div><a id="LNOCI72600"></a><a id="LNOCI16350"></a><div class="props_rev_3"><a id="GUID-1494AB91-F7BD-4B73-97B9-4F3AA51D2EB2" name="GUID-1494AB91-F7BD-4B73-97B9-4F3AA51D2EB2"></a><h4 id="LNOCI-GUID-1494AB91-F7BD-4B73-97B9-4F3AA51D2EB2" class="sect4"><span class="enumeration_section">6.5.1</span>隐含描述</h4>
                  <div>
                     <p>执行SQL语句后，有关选择列表的信息可用作语句句柄的属性。不需要明确的描述调用。</p>
                     <p>要检索有关多个选择列表项的信息，应用程序可以在第一次将<span class="italic">pos</span>参数设置为1时调用<code class="codeph">OCIParamGet()</code> ，然后迭代<span class="italic">pos</span>的值并重复<code class="codeph">OCIParamGet()</code>调用，直到<code class="codeph">OCI_ERROR</code>带有<code class="codeph">ORA-24334</code> <code class="codeph">OCI_ERROR</code> 。应用程序还可以指定任意位置<span class="italic">n</span>以随机获取列。
                     </p>
                     <p>一旦为选择列表中的位置分配了参数描述符，应用程序就可以通过在参数描述符上调用<code class="codeph">OCIAttrGet()</code>来检索特定信息。参数描述符中可用的信息包括参数的数据类型和最大大小。
                     </p>
                     <p><a href="using-sql_statements-in-oci.html#GUID-1494AB91-F7BD-4B73-97B9-4F3AA51D2EB2__CIHHFJJE">示例6-3</a> <a href="using-sql_statements-in-oci.html#GUID-1494AB91-F7BD-4B73-97B9-4F3AA51D2EB2__CIHHFJJE">示例6-3</a>中的示例代码显示了一个循环，该循环在查询执行后检索与查询对应的列名和数据类型。通过先前调用<code class="codeph">OCIStmtPrepare2()</code>将查询与语句句柄相关联。
                     </p>
                     <p><a href="using-sql_statements-in-oci.html#GUID-1494AB91-F7BD-4B73-97B9-4F3AA51D2EB2__CIHHFJJE">例6-3中</a>的<code class="codeph">checkerr()</code>函数用于错误处理。完整列表可以在<a href="oci-demo-programs.html#GUID-75E18629-0C54-4495-A747-AFB346034F26" title="列出示例程序，其中包含示例代码，用于演示OCI句柄的分配和使用。">OCI演示程序</a>中的第一个示例应用程序中找到。
                     </p>
                     <p>对<code class="codeph">OCIAttrGet()</code>和<code class="codeph">OCIParamGet()</code>的调用是不需要网络往返的本地调用，因为在执行语句之后，所有选择列表信息都缓存在客户端。
                     </p>
                     <div class="example" id="GUID-1494AB91-F7BD-4B73-97B9-4F3AA51D2EB2__CIHHFJJE">
                        <p class="titleinexample">示例6-3隐式描述 - 选择列表可用作语句句柄的属性</p><pre class="oac_no_warn" dir="ltr">...OCIParam * mypard =（OCIParam *）0; ub2 dtype; text * col_name; ub4 counter，col_name_len，char_semantics; ub2 col_width; sb4 parm_status; text * sqlstmt =（text *）“SELECT * FROM employees WHERE employee_id = 100”; checkerr（errhp，OCIStmtPrepare2（svchp，＆stmthp，errhp，（OraText *）sqlstmt，（ub4）strlen（（char *）sqlstmt），NULL，0，（ub4）OCI_NTV_SYNTAX，（ub4）OCI_DEFAULT））; checkerr（errhp，OCIStmtExecute（svchp，stmthp，errhp，0,0，（OCISnapshot *）0，（OCISnapshot *）0，OCI_DEFAULT））; / *在选择列表中请求位置1的参数描述符* / counter = 1; parm_status = OCIParamGet（（void *）stmthp，OCI_HTYPE_STMT，errhp，（void **）＆mypard，（ub4）counter）; / *仅当成功检索到当前位置的描述符时才循环，从1 * / while开始（parm_status == OCI_SUCCESS）{/ *检索数据类型属性* / checkerr（errhp，OCIAttrGet（（void *）mypard，（ub4） ）OCI_DTYPE_PARAM，（void *）＆dtype，（ub4 *）0，（ub4）OCI_ATTR_DATA_TYPE，（OCIError *）errhp））; / *检索列名属性* / col_name_len = 0; checkerr（errhp，OCIAttrGet（（void *）mypard，（ub4）OCI_DTYPE_PARAM，（void **）＆col_name，（ub4 *）＆col_name_len，（ub4）OCI_ATTR_NAME，（OCIError *）errhp））; / *检索列* / char_semantics = 0的长度语义; checkerr（errhp，OCIAttrGet（（void *）mypard，（ub4）OCI_DTYPE_PARAM，（void *）＆char_semantics，（ub4 *）0，（ub4）OCI_ATTR_CHAR_USED，（OCIError *）errhp））; col_width = 0; if（char_semantics）/ *以字符* / checkerr（errhp，OCIAttrGet（（void *）mypard，（ub4）OCI_DTYPE_PARAM，（void *）＆col_width，（ub4 *）0，（ub4）OCI_ATTR_CHAR_SIZE，（OCIError）检索列宽*）errhp））; else / *以字节为单位检索列宽* / checkerr（errhp，OCIAttrGet（（void *）mypard，（ub4）OCI_DTYPE_PARAM，（void *）＆col_width，（ub4 *）0，（ub4）OCI_ATTR_DATA_SIZE，（OCIError *）errhp ））; / *递增计数器并获取下一个描述符，如果有一个* / counter ++; parm_status = OCIParamGet（（void *）stmthp，OCI_HTYPE_STMT，errhp，（void **）＆mypard，（ub4）counter）; } / * while * / ...
</pre><div class="infoboxnotealso" id="GUID-1494AB91-F7BD-4B73-97B9-4F3AA51D2EB2__GUID-439F6784-9B0D-4EDE-A84B-4BD86F6984E9">
                           <p class="notep1">也可以看看：</p>
                           <ul style="list-style-type:disc">
                              <li>
                                 <p><a href="handle-and-descriptor-functions.html#GUID-35D2FF91-139B-4A5C-97C8-8BC29866CCA4" title="返回由describe句柄或语句句柄中的position指定的参数的描述符。">OCIParamGet（）</a></p>
                              </li>
                              <li>
                                 <p><a href="handle-and-descriptor-functions.html#GUID-FA199A99-4D7A-42C2-BB0A-C20047B95DF9" title="获取句柄属性的值。">OCIAttrGet（）</a></p>
                              </li>
                              <li>
                                 <p><a href="statement-functions.html#GUID-E6C1DC67-D464-4D2A-9F19-737423D31779" title="准备SQL或PL / SQL语句以便执行。">OCIStmtPrepare2（）</a></p>
                              </li>
                              <li>
                                 <p><a href="handle-and-descriptor-functions.html#GUID-8218D5F2-139B-4FA9-BA4A-ED0126687C0F" title="分配一组描述符。">OCIArrayDescriptorAlloc（）</a></p>
                              </li>
                              <li>
                                 <p><a href="handle-and-descriptor-functions.html#GUID-8218D5F2-139B-4FA9-BA4A-ED0126687C0F" title="分配一组描述符。">OCIArrayDescriptorAlloc（）</a>可读取的参数描述符的特定属性列表的<a href="describing-schema-metadata.html#GUID-2EB52CE1-9947-472C-B8B3-24214D66EE19" title="本节介绍属于不同参数的属性和句柄。">参数属性</a></p>
                              </li>
                           </ul>
                        </div>
                     </div>
                     <!-- class="example" -->
                  </div>
               </div><a id="LNOCI72601"></a><a id="LNOCI16351"></a><div class="props_rev_3"><a id="GUID-1FE451DB-FB37-4966-8334-AE04E532D27C" name="GUID-1FE451DB-FB37-4966-8334-AE04E532D27C"></a><h4 id="LNOCI-GUID-1FE451DB-FB37-4966-8334-AE04E532D27C" class="sect4"><span class="enumeration_section">6.5.2</span>显式描述查询</h4>
                  <div>
                     <p>通过将<code class="codeph">OCI_DESCRIBE_ONLY</code>指定为<code class="codeph">OCIStmtExecute()</code>的模式，可以在执行前显式描述查询</p>
                     <p>这不执行语句，但返回选择列表描述。</p>
                     <div class="infoboxnote" id="GUID-1FE451DB-FB37-4966-8334-AE04E532D27C__GUID-9DBAC0A6-0912-4607-A80A-83A3820FD686">
                        <p class="notep1">注意：</p>
                        <p>为了最大限度地提高性能，Oracle建议应用程序以默认模式执行语句，并使用执行时附带的隐式描述。</p>
                     </div>
                     <p><a href="using-sql_statements-in-oci.html#GUID-1FE451DB-FB37-4966-8334-AE04E532D27C__CIHCGFEE">例6-4中</a>的代码演示了如何在选择列表中使用显式describe来返回有关列的信息。
                     </p>
                     <div class="example" id="GUID-1FE451DB-FB37-4966-8334-AE04E532D27C__CIHCGFEE">
                        <p class="titleinexample">示例6-4显式描述 - 返回每列的选择列表描述</p><pre class="oac_no_warn" dir="ltr">...int i = 0; ub4 numcols = 0; ub2 type = 0; OCIParam * colhd =（OCIParam *）0; / *列句柄* / text * sqlstmt =（text *）“SELECT * FROM employees WHERE employee_id = 100”; checkerr（errhp，OCIStmtPrepare2（svchp，＆stmthp，errhp，（OraText *）sqlstmt，（ub4）strlen（（char *）sqlstmt），NULL，0，（ub4）OCI_NTV_SYNTAX，（ub4）OCI_DEFAULT））; / *初始化svchp，stmthp，errhp，rowoff，iters，snap_in，snap_out * / / *将执行模式设置为OCI_DESCRIBE_ONLY。请注意，除了执行语句* / checkerr（errhp，OCIStmtExecute（svchp，stmthp，errhp，0,0，（OCISnapshot *）0，（OCISnapshot *）0）之外，将模式设置为OCI_DEFAULT会对语句进行隐式描述， OCI_DESCRIBE_ONLY））; / *获取查询中的列数* / checkerr（errhp，OCIAttrGet（（void *）stmthp，OCI_HTYPE_STMT，（void *）＆numcols，（ub4 *）0，OCI_ATTR_PARAM_COUNT，errhp））; / *遍历列列表并检索每列的数据类型。从pos = 1 * /开始（i = 1; i &lt;= numcols; i ++）{/ *获取列i * / checkerr的参数（errhp，OCIParamGet（（void *）stmthp，OCI_HTYPE_STMT，errhp，（void ** ）＆colhd，i））; / *获取列i * / type = 0的数据类型; checkerr（errhp，OCIAttrGet（（void *）colhd，OCI_DTYPE_PARAM，（void *）＆type，（ub4 *）0，OCI_ATTR_DATA_TYPE，errhp））; } ...
</pre><div class="infoboxnotealso" id="GUID-1FE451DB-FB37-4966-8334-AE04E532D27C__GUID-755DD05A-64EB-42FA-902E-7672D8152BBB">
                           <p class="notep1">也可以看看：</p>
                           <p><a href="statement-functions.html#GUID-98B26708-3E02-45C0-8258-5D5544F32BE9" title="将应用程序请求与服务器关联。">OCIStmtExecute（）</a></p>
                        </div>
                     </div>
                     <!-- class="example" -->
                  </div>
               </div>
            </div><a id="LNOCI16352"></a><div class="props_rev_3"><a id="GUID-F5FB3DBA-9FDA-45FC-AF5D-2D8D4C436296" name="GUID-F5FB3DBA-9FDA-45FC-AF5D-2D8D4C436296"></a><h3 id="LNOCI-GUID-F5FB3DBA-9FDA-45FC-AF5D-2D8D4C436296" class="sect3"><span class="enumeration_section">6.6</span>关于在OCI中定义输出变量</h3>
               <div>
                  <p>Query语句将数据从数据库返回给您的应用程序。</p>
                  <p>处理查询时，必须为选择列表中的每个项目定义输出变量或输出变量数组，以从中检索数据。define步骤创建一个关联，用于确定返回结果的存储位置以及格式。</p>
                  <p>例如，要处理以下语句，通常会定义两个输出变量：一个用于接收从<code class="codeph">name</code>列返回的值，另一个用于接收从<code class="codeph">ssn</code>列返回的值：</p><pre class="oac_no_warn" dir="ltr">SELECT name，ssn FROM employees WHERE empno =：empnum</pre><div class="infoboxnotealso" id="GUID-F5FB3DBA-9FDA-45FC-AF5D-2D8D4C436296__GUID-E3130724-AA9E-4D2B-AD0E-1A75CF1F3005">
                     <p class="notep1">也可以看看：</p>
                     <p><a href="binding-and-defining-in-oci.html#GUID-4C2BD7BB-5768-4E8A-82BF-84FB0030A8C5" title="本章介绍OCI中的绑定和定义。">OCI中的绑定和定义</a></p>
                  </div>
               </div>
            </div><a id="LNOCI16353"></a><div class="props_rev_3"><a id="GUID-E0EAF0A9-2C7D-468D-BF43-C9056F3497E6" name="GUID-E0EAF0A9-2C7D-468D-BF43-C9056F3497E6"></a><h3 id="LNOCI-GUID-E0EAF0A9-2C7D-468D-BF43-C9056F3497E6" class="sect3"><span class="enumeration_section">6.7</span>关于获取结果</h3>
               <div>
                  <p>如果OCI应用程序已处理查询，则通常需要在语句完成执行后使用<code class="codeph">OCIStmtFetch2()</code>获取结果。
                  </p>
                  <p><code class="codeph">OCIStmtFetch2()</code>函数支持<span class="italic">可滚动游标</span> 。
                  </p>
                  <p>将提取的数据检索到已由define操作指定的输出变量中。</p>
                  <div class="infoboxnote" id="GUID-E0EAF0A9-2C7D-468D-BF43-C9056F3497E6__GUID-C5DC1425-6EB1-4C0D-9D59-D79DF64D5AB2">
                     <p class="notep1">注意：</p>
                     <p>如果在调用<code class="codeph">OCIStmtExecute()</code>之前为<code class="codeph">SELECT</code>语句定义了输出变量，那么<code class="codeph">iters</code>参数指定的行数将直接<code class="codeph">iters</code>到定义的输出缓冲区中</p>
                     <div class="p">本节包括以下主题：<ul style="list-style-type:disc">
                           <li>
                              <p><a href="using-sql_statements-in-oci.html#GUID-531299F8-6F55-4550-B389-1B3346045FC2" title="如果LOB列或属性是选择列表的一部分，则它们可以作为LOB定位符或实际LOB值返回，具体取决于您定义它们的方式。">关于获取LOB数据</a></p>
                           </li>
                           <li>
                              <p><a href="using-sql_statements-in-oci.html#GUID-7AE9DBE2-5316-4802-99D1-969B72823F02" title="为了最大限度地减少服务器往返次数并优化性能，OCI可以在执行查询时预取结果集行。">关于设置预取计数</a></p>
                           </li>
                        </ul>
                     </div>
                  </div>
                  <div class="infoboxnotealso" id="GUID-E0EAF0A9-2C7D-468D-BF43-C9056F3497E6__GUID-9E5CCC5C-711B-4A5B-998C-ED09B56D1990">
                     <p class="notep1">也可以看看：</p>
                     <ul style="list-style-type:disc">
                        <li>
                           <p><a href="using-sql_statements-in-oci.html#GUID-1728D572-BED3-4F80-BDC3-E6F9A66046B2" title="游标是结果集中的当前位置。">关于在OCI中使用可滚动游标</a></p>
                        </li>
                        <li>
                           <p><a href="statement-functions.html#GUID-DF585B90-58BA-45FC-B7CE-6F7F987C03B9" title="从（可滚动）结果集中获取一行。">OCIStmtFetch2（）</a></p>
                        </li>
                        <li>
                           <p><a href="statement-functions.html#GUID-98B26708-3E02-45C0-8258-5D5544F32BE9" title="将应用程序请求与服务器关联。">OCIStmtExecute（）</a></p>
                        </li>
                        <li>
                           <p>前面提到的这些语句<a href="binding-and-defining-in-oci.html#GUID-E965AB3C-003F-45CD-82FA-586BBB4082A4" title="A basic define is done with a position call, OCIDefineByPos() or OCIDefineByPos2().">在OCI定义</a>中使用的<a href="binding-and-defining-in-oci.html#GUID-E965AB3C-003F-45CD-82FA-586BBB4082A4" title="使用位置调用OCIDefineByPos（）或OCIDefineByPos2（）完成基本定义。">步骤中</a>获取与示例代码相关的数据。有关更多信息，请参阅该示例。
                           </p>
                        </li>
                        <li>
                           <p>有关定义输出变量的信息<a href="binding-and-defining-in-oci.html#GUID-8A09BC68-4C3D-4977-86C9-134F73121E26" title="Query语句将数据从数据库返回给您的应用程序。">，请在OCI中定义概述</a></p>
                        </li>
                     </ul>
                  </div>
               </div><a id="LNOCI16354"></a><div class="props_rev_3"><a id="GUID-531299F8-6F55-4550-B389-1B3346045FC2" name="GUID-531299F8-6F55-4550-B389-1B3346045FC2"></a><h4 id="LNOCI-GUID-531299F8-6F55-4550-B389-1B3346045FC2" class="sect4"><span class="enumeration_section">6.7.1</span>关于获取LOB数据</h4>
                  <div>
                     <p>如果LOB列或属性是选择列表的一部分，则它们可以作为LOB定位符或实际LOB值返回，具体取决于您定义它们的方式。</p>
                     <p>如果获取了LOB定位符，则应用程序可以通过<code class="codeph">OCILobXXX</code>函数对这些定位器执行进一步操作。
                     </p>
                     <div class="infoboxnotealso" id="GUID-531299F8-6F55-4550-B389-1B3346045FC2__GUID-A4A28A80-A70B-48FC-B577-7AE99C3818D2">
                        <p class="notep1">也可以看看：</p>
                        <ul style="list-style-type:disc">
                           <li>
                              <p>有关在OCI中使用LOB定位器的更多信息，请参阅<a href="lobs-and-bfile-operations.html#GUID-0A094518-F97C-40BE-A336-259AA82BD0A2" title="本章介绍LOB和BFILE操作。">LOB和BFILE操作</a></p>
                           </li>
                           <li>
                              <p><a href="binding-and-defining-in-oci.html#GUID-16652266-2A22-43AB-8BA3-9868CCEC9271">关于定义LOB输出变量</a>用于使用和不使用定位器选择LOB数据的示例</p>
                           </li>
                        </ul>
                     </div>
                  </div>
               </div><a id="LNOCI16355"></a><div class="props_rev_3"><a id="GUID-7AE9DBE2-5316-4802-99D1-969B72823F02" name="GUID-7AE9DBE2-5316-4802-99D1-969B72823F02"></a><h4 id="LNOCI-GUID-7AE9DBE2-5316-4802-99D1-969B72823F02" class="sect4"><span class="enumeration_section">6.7.2</span>关于设置预取计数</h4>
                  <div>
                     <p>为了最大限度地减少服务器往返次数并优化性能，OCI可以在执行查询时预取结果集行。</p>
                     <p>您可以使用<code class="codeph">OCIAttrSet()</code>函数设置语句句柄的<code class="codeph">OCI_ATTR_PREFETCH_ROWS</code>或<code class="codeph">OCI_ATTR_PREFETCH_MEMORY</code>属性来自定义此预取。这些属性使用如下：</p>
                     <ul style="list-style-type:disc">
                        <li>
                           <p><code class="codeph">OCI_ATTR_PREFETCH_ROWS</code>设置要预取的行数。如果未设置，则默认值为1。如果<code class="codeph">OCIStmtExecute()</code>的<code class="codeph">iters</code>参数为0并且启用了预取，则在调用<code class="codeph">OCIStmtFetch2()</code>期间会缓冲这些行。执行后和提取之间可以更改预取值。
                           </p>
                        </li>
                        <li>
                           <p><code class="codeph">OCI_ATTR_PREFETCH_MEMORY</code>设置为要预取的行分配的内存。然后，应用程序将获取尽可能多的行，以适应那么多内存。
                           </p>
                        </li>
                     </ul>
                     <p>当设置了这两个属性时，OCI <code class="codeph">OCI_ATTR_PREFETCH_ROWS</code>行预取到<code class="codeph">OCI_ATTR_PREFETCH_ROWS</code>限制，除非达到<code class="codeph">OCI_ATTR_PREFETCH_MEMORY</code>限制，在这种情况下，OCI返回的行数可以容纳在大小为<code class="codeph">OCI_ATTR_PREFETCH_MEMORY</code>的缓冲区中。</p>
                     <p>默认情况下，打开预取，OCI会获取一个额外的行，除非查询不支持预取（请参阅下面的注释）。要关闭预取，请将<code class="codeph">OCI_ATTR_PREFETCH_ROWS</code>和<code class="codeph">OCI_ATTR_PREFETCH_MEMORY</code>属性都设置为零。
                     </p>
                     <p>如果显式设置了<code class="codeph">OCI_ATTR_PREFETCH_ROWS</code>和<code class="codeph">OCI_ATTR_PREFETCH_MEMORY</code>属性，则OCI使用两个约束中的更紧密来确定要预取的行数。
                     </p>
                     <p>要根据内存约束进行预取，请设置<code class="codeph">OCI_ATTR_PREFETCH_MEMORY</code>属性，并确保通过将其设置为零来禁用<code class="codeph">OCI_ATTR_PREFETCH_ROWS</code>属性（以覆盖默认设置1行）。
                     </p>
                     <p>要根据行数约束进行预取，请设置<code class="codeph">OCI_ATTR_PREFETCH_ROWS</code>属性并通过将其设置为零来禁用<code class="codeph">OCI_ATTR_PREFETCH_MEMORY</code>属性（如果它已明确设置为非零值）。
                     </p>
                     <p><code class="codeph">REF CURSOR</code>和嵌套游标列可以进行预取。默认情况下， <code class="codeph">REF CURSOR</code>没有打开预取。要打开<code class="codeph">REF CURSOR</code>的预取，请在从<code class="codeph">REF CURSOR</code>获取行之前设置<code class="codeph">OCI_ATTR_PREFETCH_ROWS</code>或<code class="codeph">OCI_ATTR_PREFETCH_MEMORY</code>属性。当<code class="codeph">REF CURSOR</code>传递一个OCI应用和PL / SQL之间多次并获取关于<code class="codeph">REF CURSOR</code>在OCI和PL / SQL完成后，通过OCI（如果启用）预取的行导致表现得好像OUT-应用正在PL / SQL中获取订单行。在这种情况下，不应在<code class="codeph">REF CURSOR</code>上启用OCI预取。
                     </p>
                     <div class="infoboxnote" id="GUID-7AE9DBE2-5316-4802-99D1-969B72823F02__GUID-BDED5EA1-B78B-429C-B938-02AD86D55370">
                        <p class="notep1">注意：</p>
                        <p>如果<code class="codeph">LONG</code> ，LOB或Opaque Type列（例如<code class="codeph">XMLType</code> ）是查询的一部分，则预取不起作用。
                        </p>
                     </div>
                     <div class="infoboxnotealso" id="GUID-7AE9DBE2-5316-4802-99D1-969B72823F02__GUID-DA3E7081-C740-46C5-9151-959E661E08A6">
                        <p class="notep1">也可以看看：</p>
                        <ul style="list-style-type:disc">
                           <li>
                              <p><a href="handle-and-descriptor-attributes.html#GUID-A251CF91-EB9F-4DBC-8BB8-FB5EA92C20DE" title="列出并描述语句句柄属性。">语句句柄属性</a></p>
                           </li>
                           <li>
                              <p><a href="handle-and-descriptor-functions.html#GUID-3741D7BD-7652-4D7A-8813-AC2AEA8D3B03" title="设置句柄或描述符的属性值。">OCIAttrSet（）</a></p>
                           </li>
                           <li>
                              <p><a href="statement-functions.html#GUID-98B26708-3E02-45C0-8258-5D5544F32BE9" title="将应用程序请求与服务器关联。">OCIStmtExecute（）</a></p>
                           </li>
                           <li>
                              <p><a href="statement-functions.html#GUID-DF585B90-58BA-45FC-B7CE-6F7F987C03B9" title="从（可滚动）结果集中获取一行。">OCIStmtFetch2（）</a></p>
                           </li>
                        </ul>
                        <p></p>
                     </div>
                  </div>
               </div>
            </div><a id="LNOCI16356"></a><div class="props_rev_3"><a id="GUID-1728D572-BED3-4F80-BDC3-E6F9A66046B2" name="GUID-1728D572-BED3-4F80-BDC3-E6F9A66046B2"></a><h3 id="LNOCI-GUID-1728D572-BED3-4F80-BDC3-E6F9A66046B2" class="sect3"><span class="enumeration_section">6.8</span>关于在OCI中使用可滚动游标</h3>
               <div>
                  <p>游标是<span class="italic">结果集中</span>的当前位置。
                  </p>
                  <p>执行游标会将查询结果放入一组称为结果集的行中，这些行可以按顺序或非顺序获取。在后一种情况下，游标称为<span class="italic">可滚动游标。</span></p>
                  <p>可滚动游标通过使用绝对或相对行数偏移到结果集中，支持从给定位置向前和向后访问结果集。</p>
                  <p>行从1开始编号。对于可滚动游标，您可以获取先前获取的行，结果集中的第n行或当前位置的第n行。部分或整个结果集的客户端缓存通过限制对服务器的调用来提高性能。</p>
                  <p>Oracle数据库不支持可滚动游标的DML操作。如果<code class="codeph">LONG</code>数据类型是选择列表的一部分，则无法使游标可滚动。
                  </p>
                  <p>此外，来自可滚动语句句柄的提取基于执行时的快照。OCI客户端预取与OCI可滚动游标一起使用。客户端预取高速缓存的大小可以由现有的OCI属性<code class="codeph">OCI_ATTR_PREFETCH_ROWS</code>和<code class="codeph">OCI_ATTR_PREFETCH_MEMORY</code> 。</p>
                  <div class="infoboxnote" id="GUID-1728D572-BED3-4F80-BDC3-E6F9A66046B2__GUID-54D355A4-C206-4DC4-A1F0-F3AC66052AA4">
                     <p class="notep1">注意：</p>
                     <p>除非您需要其功能，否则不要使用可滚动游标，因为它们使用更多服务器资源并且可以比不可滚动游标具有更长的响应时间。</p>
                  </div>
                  <p><code class="codeph">OCIStmtExecute()</code>调用具有可滚动游标的执行模式， <code class="codeph">OCI_STMT_SCROLLABLE_READONLY</code> 。语句句柄的缺省值是不可滚动的，仅限前向顺序访问，其中模式为<code class="codeph">OCI_FETCH_NEXT</code> 。每次执行语句句柄时都必须设置此执行模式。
                  </p>
                  <p>只能使用<code class="codeph">OCIAttrGet()</code>检索语句句柄属性<code class="codeph">OCI_ATTR_CURRENT_POSITION</code> 。该属性不能由应用程序设置;它表示结果集中的当前位置。
                  </p>
                  <p>对于不可滚动游标， <code class="codeph">OCI_ATTR_ROW_COUNT</code>是在执行此语句句柄后使用<code class="codeph">OCIStmtFetch2()</code>调用<code class="codeph">OCIStmtFetch2()</code>到用户缓冲区中的<code class="codeph">OCIStmtFetch2()</code> 。由于不可滚动游标仅是前向顺序，因此<code class="codeph">OCI_ATTR_ROW_COUNT</code>也表示应用程序检测到的最高行数。
                  </p>
                  <p>从Oracle Database 12.1版开始，如果行计数值可能超过OCI应用程序的<code class="codeph">UB4MAXVAL</code>值，则使用属性<code class="codeph">OCI_ATTR_UB8_ROW_COUNT</code>优先使用属性<code class="codeph">OCI_ATTR_ROW_COUNT</code> 。
                  </p>
                  <p>对于可滚动游标， <code class="codeph">OCI_ATTR_ROW_COUNT</code>表示提取到用户缓冲区中的最大（绝对）行号。因为应用程序可以任意定位提取，所以这不一定是自执行（可滚动）语句以来提取到用户缓冲区的行总数。
                  </p>
                  <p>语句句柄上的属性<code class="codeph">OCI_ATTR_ROWS_FETCHED</code>表示在上次提取调用或执行中成功提取到用户缓冲区的行数。它适用于可滚动和不可滚动的游标。
                  </p>
                  <p>使用<code class="codeph">OCIStmtFetch2()</code>调用，而不是<code class="codeph">OCIStmtFetch()</code>调用，该调用是为了向后兼容而保留的。我们鼓励您使用<code class="codeph"></code> <code class="codeph">OCIStmtFetch2()</code>适用于所有新应用程序，甚至是那些不使用可滚动游标的应用程序。此调用也适用于不可滚动的游标，但如果传递<code class="codeph">OCI_DEFAULT</code>或<code class="codeph">OCI_FETCH_NEXT</code>之外的任何其他方向，则可能引发错误。
                  </p>
                  <p>远程映射查询支持可滚动游标。可滚动游标支持透明应用程序故障转移（TAF）。</p>
                  <div class="infoboxnote" id="GUID-1728D572-BED3-4F80-BDC3-E6F9A66046B2__GUID-6C0E8BAB-B241-4AED-A1C3-86A4822C21CA">
                     <p class="notep1">注意：</p>
                     <p>如果在<code class="codeph">nrows</code>参数设置为0的情况下调用<code class="codeph">OCIStmtFetch2()</code> ，则会取消游标。
                     </p>
                  </div>
                  <div class="p">本节包括以下主题：<ul style="list-style-type:disc">
                        <li>
                           <p><a href="using-sql_statements-in-oci.html#GUID-EF4297B5-78A7-449A-ABB4-9C5B754D3A89" title="如果使用OCI客户端预取缓冲区，则响应时间会得到改善。">关于提高可滚动游标性能</a></p>
                        </li>
                        <li>
                           <p><a href="using-sql_statements-in-oci.html#GUID-4A994A3E-EA41-4DA1-B58C-2BBB3C083613" title="显示可滚动游标的使用。">可滚动游标上的访问示例</a></p>
                        </li>
                     </ul>
                  </div>
                  <div class="infoboxnotealso" id="GUID-1728D572-BED3-4F80-BDC3-E6F9A66046B2__GUID-95D92C90-1E96-4BFA-AC7F-377A7AFB3A78">
                     <p class="notep1">也可以看看：</p>
                     <ul style="list-style-type:disc">
                        <li>
                           <p><a href="statement-functions.html#GUID-98B26708-3E02-45C0-8258-5D5544F32BE9" title="将应用程序请求与服务器关联。">OCIStmtExecute（）</a></p>
                        </li>
                        <li>
                           <p><a href="handle-and-descriptor-functions.html#GUID-FA199A99-4D7A-42C2-BB0A-C20047B95DF9" title="获取句柄属性的值。">OCIAttrGet（）</a></p>
                        </li>
                        <li>
                           <p><a href="statement-functions.html#GUID-DF585B90-58BA-45FC-B7CE-6F7F987C03B9" title="从（可滚动）结果集中获取一行。">OCIStmtFetch2（）</a></p>
                        </li>
                        <li>
                           <p><a href="using-sql_statements-in-oci.html#GUID-7AE9DBE2-5316-4802-99D1-969B72823F02" title="为了最大限度地减少服务器往返次数并优化性能，OCI可以在执行查询时预取结果集行。">关于设置预取计数</a> 
                           </p>
                        </li>
                     </ul>
                  </div>
               </div><a id="LNOCI16357"></a><div class="props_rev_3"><a id="GUID-EF4297B5-78A7-449A-ABB4-9C5B754D3A89" name="GUID-EF4297B5-78A7-449A-ABB4-9C5B754D3A89"></a><h4 id="LNOCI-GUID-EF4297B5-78A7-449A-ABB4-9C5B754D3A89" class="sect4"><span class="enumeration_section">6.8.1</span>关于提高可滚动游标性能</h4>
                  <div>
                     <p>如果使用OCI客户端预取缓冲区，则响应时间会得到改善。</p>
                     <p>调用后<code class="codeph">OCIStmtExecute()</code>用于可滚动光标，调用<code class="codeph">OCIStmtFetch2()</code>使用<code class="codeph">OCI_FETCH_LAST</code>以获得结果集的大小。然后将<code class="codeph">OCI_ATTR_PREFETCH_ROWS</code>设置<code class="codeph">OCI_ATTR_PREFETCH_ROWS</code>大小的大约20％，如果结果集使用大量内存，则设置<code class="codeph">OCI_PREFETCH_MEMORY</code> 。
                     </p>
                     <div class="infoboxnotealso" id="GUID-EF4297B5-78A7-449A-ABB4-9C5B754D3A89__GUID-08630751-DF92-421D-A7EA-98E742A655F3">
                        <p class="notep1">也可以看看：</p>
                        <ul style="list-style-type:disc">
                           <li>
                              <p><a href="statement-functions.html#GUID-98B26708-3E02-45C0-8258-5D5544F32BE9" title="将应用程序请求与服务器关联。">OCIStmtExecute（）</a></p>
                           </li>
                           <li>
                              <p><a href="statement-functions.html#GUID-DF585B90-58BA-45FC-B7CE-6F7F987C03B9" title="从（可滚动）结果集中获取一行。">OCIStmtFetch2（）</a></p>
                           </li>
                        </ul>
                     </div>
                  </div>
               </div><a id="LNOCI72602"></a><a id="LNOCI16358"></a><div class="props_rev_3"><a id="GUID-4A994A3E-EA41-4DA1-B58C-2BBB3C083613" name="GUID-4A994A3E-EA41-4DA1-B58C-2BBB3C083613"></a><h4 id="LNOCI-GUID-4A994A3E-EA41-4DA1-B58C-2BBB3C083613" class="sect4"><span class="enumeration_section">6.8.2</span>可滚动游标上的访问示例</h4>
                  <div>
                     <p>显示可滚动游标的使用。</p>
                     <p>假设以下SQL查询返回结果集，并且表<code class="codeph">EMP</code>有14行：</p><pre class="oac_no_warn" dir="ltr">SELECT empno，ename FROM emp</pre><p><a href="using-sql_statements-in-oci.html#GUID-4A994A3E-EA41-4DA1-B58C-2BBB3C083613__CIHBFFEB">示例6-5中</a>显示了可滚动游标的一种用法。
                     </p>
                     <div class="example" id="GUID-4A994A3E-EA41-4DA1-B58C-2BBB3C083613__CIHBFFEB">
                        <p class="titleinexample">示例6-5对可滚动游标的访问</p><pre class="oac_no_warn" dir="ltr">.../ *在可滚动模式下执行可滚动游标* / OCIStmtExecute（svchp，stmthp，errhp，（ub4）0，（ub4）0，（CONST OCISnapshot *）NULL，（OCISnapshot *）NULL，OCI_STMT_SCROLLABLE_READONLY）; / *获取具有绝对行号6,7,8的行。在此调用之后，OCI_ATTR_CURRENT_POSITION = 8，OCI_ATTR_ROW_COUNT = 8 * / checkprint（errhp，OCIStmtFetch2（stmthp，errhp，（ub4）3，OCI_FETCH_ABSOLUTE，（sb4）6，OCI_DEFAULT）; / *获取具有绝对行号6,7的行， 8。在此调用之后，OCI_ATTR_CURRENT_POSITION = 8，OCI_ATTR_ROW_COUNT = 8 * / checkprint（errhp，OCIStmtFetch2（stmthp，errhp，（ub4）3，OCI_FETCH_RELATIVE，（sb4）-2，OCI_DEFAULT）; / *获取具有绝对行号14的行。在此调用之后，OCI_ATTR_CURRENT_POSITION = 14，OCI_ATTR_ROW_COUNT = 14 * / checkprint（errhp，OCIStmtFetch2（stmthp，errhp，（ub4）1，OCI_FETCH_LAST，（sb4）0，OCI_DEFAULT）; / *获取绝对行号为1的行。在此调用之后，OCI_ATTR_CURRENT_POSITION = 1，OCI_ATTR_ROW_COUNT = 14 * / checkprint（errhp，OCIStmtFetch2（stmthp，errhp，（ub4）1，OCI_FETCH_FIRST，（sb4）0，OCI_DEFAULT）; / *获取绝对行号为2,3的行， 4。在此调用之后，OCI_ATTR_CURRENT_POSITION = 4，OCI_ATTR_ROW_COUNT = 14 * / checkprint（errhp，OCIStmtFetch2（stmthp，errhp，（ub4）3，OCI_FETCH_NEXT，（sb4）0，OCI_DEFAULT）; / *获取具有绝对行号3,4的行， 5,6,7。在此调用之后，OCI_ATTR_CURRENT_POSITION = 7，OCI_ATTR_ROW_COUNT = 14。假设已分配用户的定义内存。* / checkprint（errhp，OCIStmtFetch2（stmthp，errhp，（ub4）5，OCI_FETCH_PRIOR，（sb4）0，OCI_DEFAULT）; ...} checkprint（errhp，status）{ub4 rows_fetched; / *这会在定义缓冲区* / checkerr（errhp，status）中打印fetch调用的结果之前检查是否有任何OCI错误; checkerr（errhp，OCIAttrGet（（CONST void *）stmthp，OCI_HTYPE_STMT，（void *）＆rows_fetched，（uint *）0，OCI_ATTR_ROWS_FETCHED，errhp））; } ...
</pre></div>
                     <!-- class="example" -->
                  </div>
               </div>
            </div>
         </div>
      </article>
   </body>
</html>