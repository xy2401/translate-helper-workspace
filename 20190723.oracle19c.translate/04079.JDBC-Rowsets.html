<html lang="en-us" dir="ltr" xml:lang="en-us">
   <head>
      <meta http-equiv="Content-Type" content="text/html; charset=utf-8"></meta>
      <meta name="viewport" content="width=device-width, initial-scale=1"></meta>
      <meta http-equiv="X-UA-Compatible" content="IE=edge"></meta>
      <title>JDBC RowSet</title>
      <meta property="og:site_name" content="Oracle Help Center"></meta>
      <meta property="og:title" content="JDBC Developer&#39;s Guide"></meta>
      <meta property="og:description" content=""></meta>
      <link rel="stylesheet" href="/sp_common/book-template/ohc-book-template/css/book.css"></link>
      <link rel="shortcut icon" href="/sp_common/book-template/ohc-common/img/favicon.ico"></link>
      <meta name="application-name" content="JDBC Developer&#39;s Guide"></meta>
      <meta name="generator" content="DITA Open Toolkit version 1.8.5 (Mode = doc)"></meta>
      <meta name="plugin" content="SP_docbuilder HTML plugin release 18.2.2"></meta>
      <link rel="alternate" href="jdbc-developers-guide.pdf" title="PDF File" type="application/pdf"></link>
      <meta name="robots" content="all"></meta>
      <link rel="schema.dcterms" href="http://purl.org/dc/terms/"></link>
      <meta name="dcterms.created" content="2019-02-13T13:20:37-08:00"></meta>
      <meta name="dcterms.title" content="JDBC Developer&#39;s Guide"></meta>
      <meta name="dcterms.dateCopyrighted" content="1999, 2019"></meta>
      <meta name="dcterms.category" content="database"></meta>
      <meta name="dcterms.identifier" content="E96471-02"></meta>
      
      <meta name="dcterms.product" content="en/database/oracle/oracle-database/19"></meta>
      
      <link rel="prev" href="resultset.html" title="Previous" type="text/html"></link>
      <link rel="next" href="globalization-support.html" title="Next" type="text/html"></link>
      <script>
        document.write('<style type="text/css">');
        document.write('body > .noscript, body > .noscript ~ * { visibility: hidden; }');
        document.write('</style>');
     </script>
      <script src="/sp_common/book-template/requirejs/require.js" data-main="/sp_common/book-template/ohc-book-template/js/book-config"></script>
      <script>
            if (window.require === undefined) {
                document.write('<script data-main="sp_common/book-template/ohc-book-template/js/book-config" src="sp_common/book-template/requirejs/require.js"><\/script>');
                document.write('<link href="sp_common/book-template/ohc-book-template/css/book.css" rel="stylesheet"/>');
            }
        </script>
      <script type="application/json" id="ssot-metadata">{"primary":{"category":{"short_name":"database","element_name":"Database","display_in_url":true},"suite":{"short_name":"oracle","element_name":"Oracle","display_in_url":true},"product_group":{"short_name":"not-applicable","element_name":"Not applicable","display_in_url":false},"product":{"short_name":"oracle-database","element_name":"Oracle Database","display_in_url":true},"release":{"short_name":"19","element_name":"Release 19","display_in_url":true}}}</script>
      
    <meta name="dcterms.isVersionOf" content="JJDBC"></meta>
    <meta name="dcterms.release" content="Release 19"></meta>
  </head>
   <body dir="ltr">
      <div class="noscript alert alert-danger text-center" role="alert">
         <a href="resultset.html" class="pull-left"><span class="glyphicon glyphicon-chevron-left" aria-hidden="true"></span>上一页</a> <a href="globalization-support.html" class="pull-right">下一页<span class="glyphicon glyphicon-chevron-right" aria-hidden="true"></span></a> <span class="fa fa-exclamation-triangle" aria-hidden="true"></span>必须启用JavaScript才能正确显示此内容</div>
      <article>
         <header>
            <ol class="breadcrumb" vocab="http://schema.org/" typeof="BreadcrumbList">
               <li property="itemListElement" typeof="ListItem"><a href="index.html" property="item" typeof="WebPage"><span property="name">JDBC开发人员指南</span></a></li>
               <li property="itemListElement" typeof="ListItem"><a href="data-access-and-manipulation.html" property="item" typeof="WebPage"><span property="name">数据访问和操作</span></a></li>
               <li class="active" property="itemListElement" typeof="ListItem">JDBC RowSet</li>
            </ol>
            <a id="GUID-AF2DA648-73E2-4D62-9EAF-E273BD88FA89" name="GUID-AF2DA648-73E2-4D62-9EAF-E273BD88FA89"></a><a id="JJDBC28630"></a>
            
            <h2 id="JJDBC-GUID-AF2DA648-73E2-4D62-9EAF-E273BD88FA89" class="sect2"><span class="enumeration_chapter">18个</span> JDBC RowSets</h2>
         </header>
         <div class="ind">
            <div>
               <p>本章包含以下部分：</p>
               <ul style="list-style-type:disc">
                  <li>
                     <p><a href="JDBC-Rowsets.html#GUID-55A0163A-8488-46A2-8CBC-52410CC12F17">JDBC RowSet概述</a></p>
                  </li>
                  <li>
                     <p><a href="JDBC-Rowsets.html#GUID-4B46C980-D32F-474D-8742-52A238CC1D3B">关于CachedRowSet</a></p>
                  </li>
                  <li>
                     <p><a href="JDBC-Rowsets.html#GUID-996D3872-FA2B-4BA5-99BA-62D5FB235583">关于JdbcRowSet</a></p>
                  </li>
                  <li>
                     <p><a href="JDBC-Rowsets.html#GUID-862F56C6-7874-4A18-8933-F487538D847D">关于WebRowSet</a></p>
                  </li>
                  <li>
                     <p><a href="JDBC-Rowsets.html#GUID-8AA0A89C-3CC2-4872-8EFD-3A390E712A4D">关于FilteredRowSet</a></p>
                  </li>
                  <li>
                     <p><a href="JDBC-Rowsets.html#GUID-60685532-AA0E-4692-A369-5F9D79AA9A72">关于JoinRowSet</a></p>
                  </li>
               </ul>
            </div><a id="JJDBC28631"></a><div class="props_rev_3"><a id="GUID-55A0163A-8488-46A2-8CBC-52410CC12F17" name="GUID-55A0163A-8488-46A2-8CBC-52410CC12F17"></a><h3 id="JJDBC-GUID-55A0163A-8488-46A2-8CBC-52410CC12F17" class="sect3"><span class="enumeration_section">18.1</span> JDBC RowSet概述</h3>
               <div>
                  <p>一个<a id="d61846e77" class="indexterm-anchor"></a> RowSet是一个对象，它封装来自Java数据库连接（JDBC）结果集或表格数据源的一组行。RowSet支持基于组件的开发模型，如JavaBeans，具有一组标准属性和事件通知机制。
                  </p>
                  <p>RowSets是通过可选包在JDBC 2.0中引入的。但是，RowSets的实现在JDBC RowSet实现规范（JSR-114）中标准化，该规范从Java平台标准版（Java SE）5.0开始作为非可选包提供。Java SE 6.0 RowSets包含更多支持RowId，National Language Charactersets等功能的API。Java SE Javadocs提供有关JDBC RowSet实现的标准接口和基类的信息。</p>
                  <p>JSR-114规范包括五种RowSet的实现细节：</p>
                  <ul style="list-style-type:disc">
                     <li>
                        <p><code class="codeph">CachedRowSet的</code></p>
                     </li>
                     <li>
                        <p><code class="codeph">的JdbcRowSet</code></p>
                     </li>
                     <li>
                        <p><code class="codeph">WebRowSet的</code></p>
                     </li>
                     <li>
                        <p><code class="codeph">FilteredRowSet的</code></p>
                     </li>
                     <li>
                        <p><code class="codeph">JoinRowSet中</code></p>
                     </li>
                  </ul>
                  <p>Oracle JDBC通过<code class="codeph">oracle.jdbc.rowset</code>包中提供的接口和类支持所有五种类型的RowSet。自Oracle Database <span class="italic">11g</span>第1版以来，已在服务器端驱动程序中添加了RowSet支持。因此，从Oracle Database <span class="italic">11g</span>第1版开始，RowSets支持在所有Oracle JDBC驱动程序类型中是统一的。标准Oracle JDBC Java Archive（JAR）文件（例如， <code class="codeph">ojdbc6.jar</code>和<code class="codeph">ojdbc7.jar</code>包含<code class="codeph">oracle.jdbc.rowset</code>包。
                  </p>
                  <div class="infoboxnote" id="GUID-55A0163A-8488-46A2-8CBC-52410CC12F17__GUID-10E0462F-3754-42DB-8F10-18F07F663999">
                     <p class="notep1">注意：</p>
                     <ul style="list-style-type:disc">
                        <li>
                           <p>具有不同文件后缀名称的其他JAR文件（例如， <code class="codeph">ojdbc6_g.jar</code> ， <code class="codeph">ojdbc6dms.jar</code>等）也包含<code class="codeph">oracle.jdbc.rowset</code>包。
                           </p>
                        </li>
                        <li>
                           <p>在Oracle Database <span class="italic">10g第</span> 2版中，实现类打包在<code class="codeph">ojdbc14.jar</code>文件中。
                           </p>
                        </li>
                        <li>
                           <p>在Oracle Database <span class="italic">10g第</span> 2版之前，实现类打包在<code class="codeph">ocrs12.jar</code>文件中。
                           </p>
                        </li>
                        <li>
                           <p>在Oracle Database <span class="italic">11g</span>第1版之前，服务器端驱动程序中没有RowSets支持。
                           </p>
                        </li>
                     </ul>
                  </div>
                  <div class="infoboxnote" id="GUID-55A0163A-8488-46A2-8CBC-52410CC12F17__GUID-CA7E4707-EB1E-482B-9228-9DBCCF29AD6E">
                     <p class="notep1">注意：</p>
                     <p>在Oracle数据库10g第2版（10.2）中，此程序包包含在标准Oracle JDBC JAR文件中： <code class="codeph">classes12.jar</code> ， <code class="codeph">ojdbc5.jar</code>和<code class="codeph">ojdbc6.jar</code> 。在Oracle Database <span class="italic">10g第</span> 2版（10.2）之前，行集实现类打包在<code class="codeph">ocrs12.jar</code>文件中。
                     </p>
                  </div>
                  <p>要使用Oracle RowSet实现，您需要从包中导入整个<code class="codeph">oracle.jdbc.rowset</code>包或特定的类和接口以获取所需的RowSet类型。对于客户端使用，还需要在<code class="codeph">CLASSPATH</code>环境变量中包含标准Oracle JAR文件，如<code class="codeph">ojdbc6.jar</code>或<code class="codeph">ojdbc7.jar</code> 。
                  </p>
                  <p>本节包括以下主题：</p>
                  <ul style="list-style-type:disc">
                     <li>
                        <p><a href="JDBC-Rowsets.html#GUID-BB79FB0E-0AA4-4302-BD79-CCE801102102">RowSet属性</a></p>
                     </li>
                     <li>
                        <p><a href="JDBC-Rowsets.html#GUID-C368A846-CA8A-4CFF-B374-0C8909F29149">事件和事件监听器</a></p>
                     </li>
                     <li>
                        <p><a href="JDBC-Rowsets.html#GUID-FB2499B5-25AF-4DD1-A289-51431A7EAF40">命令参数和命令执行</a></p>
                     </li>
                     <li>
                        <p><a href="JDBC-Rowsets.html#GUID-A67BF901-60C7-4420-B01D-3E05A50246FC">关于遍历RowSet</a></p>
                     </li>
                  </ul>
               </div><a id="JJDBC28632"></a><div class="props_rev_3"><a id="GUID-BB79FB0E-0AA4-4302-BD79-CCE801102102" name="GUID-BB79FB0E-0AA4-4302-BD79-CCE801102102"></a><h4 id="JJDBC-GUID-BB79FB0E-0AA4-4302-BD79-CCE801102102" class="sect4"><span class="enumeration_section">18.1.1</span> RowSet属性</h4>
                  <div>
                     <div class="section">
                        <p><code class="codeph">javax.sql.RowSet</code>接口提供了一组JavaBeans属性，可以通过单个接口更改这些属性以访问数据源中的数据。属性示例包括连接字符串，用户名，密码，连接类型和查询字符串。
                        </p>
                        <div class="infoboxnotealso" id="GUID-BB79FB0E-0AA4-4302-BD79-CCE801102102__GUID-87239389-5134-47CA-AE05-153BBFED4106">
                           <p class="notep1">也可以看看：</p>
                           <p>Java 2平台标准版（J2SE）Javadoc，其中包含<a href="http://docs.oracle.com/javase/1.5.0/docs/api/javax/sql/RowSet.html" target="_blank"><code class="codeph">http://docs.oracle.com/javase/1.5.0/docs/api/javax/sql/RowSet.html</code></a>的属性和属性描述的完整列表</p>
                        </div>
                        <p>该接口提供了用于设置和检索属性值的标准访问器方法。以下代码说明了如何设置一些<code class="codeph">RowSet</code>属性：</p><pre class="oac_no_warn" dir="ltr">...rowset.setUrl（ “JDBC：预言：OCI：@”）; rowset.setUsername（ “HR”）; rowset.setPassword（ “HR”）; rowset.setCommand（“SELECT employee_id，first_name，last_name，salary FROM employees”）; ...
</pre><p>在此示例中，URL，用户名，密码和SQL查询被设置为<code class="codeph">RowSet</code>属性，以将所有员工的员工编号，员工姓名和薪水检索到<code class="codeph">RowSet</code>对象中。
                        </p>
                     </div>
                     <!-- class="section" -->
                  </div>
               </div><a id="JJDBC28633"></a><div class="props_rev_3"><a id="GUID-C368A846-CA8A-4CFF-B374-0C8909F29149" name="GUID-C368A846-CA8A-4CFF-B374-0C8909F29149"></a><h4 id="JJDBC-GUID-C368A846-CA8A-4CFF-B374-0C8909F29149" class="sect4"><span class="enumeration_section">18.1.2</span>事件和事件监听器</h4>
                  <div>
                     <p>RowSet支持JavaBeans事件。<code class="codeph">RowSet</code>接口支持以下类型的事件：</p>
                     <ul style="list-style-type:disc">
                        <li>
                           <p><code class="codeph">cursorMoved</code></p>
                           <p>只要有光标移动，就会生成此事件。例如，当调用<code class="codeph">next</code>或<code class="codeph">previous</code>方法时。
                           </p>
                        </li>
                        <li>
                           <p><code class="codeph">rowChanged</code></p>
                           <p>从RowSet插入，更新或删除行时会生成此事件。</p>
                        </li>
                        <li>
                           <p><code class="codeph">rowSetChanged</code></p>
                           <p>创建或更改整个RowSet时会生成此事件。例如，调用<code class="codeph">execute</code>方法时。
                           </p>
                        </li>
                     </ul>
                     <p>应用程序组件可以实现RowSet侦听器以侦听这些RowSet事件，并在事件发生时执行所需的操作。对这些事件感兴趣的应用程序组件必须实现标准的<code class="codeph">javax.sql.RowSetListener</code>接口并使用<code class="codeph">RowSet</code>对象注册此类侦听器对象。收听者可使用被注册<code class="codeph">RowSet.addRowSetListener</code>方法使用和未注册<code class="codeph">RowSet.removeRowSetListener</code>方法。可以使用相同的<code class="codeph">RowSet</code>对象注册多个侦听器。
                     </p>
                     <p>以下代码说明了RowSet侦听器的注册：</p><pre class="oac_no_warn" dir="ltr">...MyRowSetListener rowsetListener = new MyRowSetListener（）; //添加行集侦听器rowset.addRowSetListener（rowsetListener）; ...
</pre><p>以下代码说明了一个侦听器实现：</p><pre class="oac_no_warn" dir="ltr">公共类MyRowSetListener实现RowSetListener {public void cursorMoved（RowSetEvent event）{//对光标移动的操作} public void rowChanged（RowSetEvent event）{//更改行的操作} public void rowSetChanged（RowSetEvent event）{//关于更改的操作of rowset}} //类MyRowSetListener的结尾</pre><p>只需处理选定事件的应用程序可以使用<code class="codeph">oracle.jdbc.rowset.仅实现所需的事件处理方法<code class="codeph">oracle.jdbc.rowset.OracleRowSetListenerAdapter</code>类，它是一个抽象类，具有所有事件处理方法的空实现。在以下代码中，仅处理<code class="codeph">rowSetChanged</code>事件，而应用程序不处理其余事件：</p><pre class="oac_no_warn" dir="ltr">...rowset.addRowSetListener（new oracle.jdbc.rowset。OracleRowSetListenerAdapter（）{public void rowSetChanged（RowSetEvent event）{//您对rowSetChanged的操作}}）; ...
</pre></div>
               </div><a id="JJDBC28634"></a><div class="props_rev_3"><a id="GUID-FB2499B5-25AF-4DD1-A289-51431A7EAF40" name="GUID-FB2499B5-25AF-4DD1-A289-51431A7EAF40"></a><h4 id="JJDBC-GUID-FB2499B5-25AF-4DD1-A289-51431A7EAF40" class="sect4"><span class="enumeration_section">18.1.3</span>命令参数和命令执行</h4>
                  <div>
                     <p><code class="codeph">RowSet</code>对象的<code class="codeph">command</code>属性通常表示SQL查询字符串，处理后将使用实际数据填充<code class="codeph">RowSet</code>对象。与常规JDBC处理一样，此查询字符串可以采用输入或绑定参数。<code class="codeph">javax.sql.RowSet</code>接口还提供了为此SQL查询设置输入参数的方法。设置所需的输入参数后，可以处理SQL查询以使用基础数据源中的数据填充<code class="codeph">RowSet</code>对象。以下代码说明了这个简单的序列：</p><pre class="oac_no_warn" dir="ltr">...rowset.setCommand（“SELECT first_name，last_name，salary FROM employees WHERE employee_id =？“）; //为名为”Douglas“的员工设置员工编号输入参数rowset.setInt（1,199）; rowset.execute（）; ...
</pre><p>在前面的示例中，员工编号199被设置为<code class="codeph">RowSet</code>对象的<code class="codeph">command</code>属性中指定的SQL查询的输入或绑定参数。处理SQL查询时， <code class="codeph">RowSet</code>对象将填充员工编号为199的员工的员工姓名和薪资信息。
                     </p>
                  </div>
               </div><a id="JJDBC28635"></a><div class="props_rev_3"><a id="GUID-A67BF901-60C7-4420-B01D-3E05A50246FC" name="GUID-A67BF901-60C7-4420-B01D-3E05A50246FC"></a><h4 id="JJDBC-GUID-A67BF901-60C7-4420-B01D-3E05A50246FC" class="sect4"><span class="enumeration_section">18.1.4</span>关于遍历RowSet</h4>
                  <div>
                     <p><code class="codeph">javax.sql.RowSet</code>接口扩展了<code class="codeph">java.sql.ResultSet</code>接口。因此， <code class="codeph">RowSet</code>接口提供了从<code class="codeph">ResultSet</code>接口继承的游标移动和定位方法，用于遍历<code class="codeph">RowSet</code>对象中的数据。一些继承的方法是<code class="codeph">absolute</code> ， <code class="codeph">beforeFirst</code> ， <code class="codeph">afterLast</code> ， <code class="codeph">next</code>和<code class="codeph">previous</code> 。
                     </p>
                     <p><code class="codeph">RowSet</code>接口可以像<code class="codeph">ResultSet</code>接口一样用于检索和更新数据。<code class="codeph">RowSet</code>接口提供了一种实现可滚动和可更新结果集的可选方法。<code class="codeph">ResultSet</code>接口提供的所有字段和方法都在<code class="codeph">RowSet</code>中实现。
                     </p>
                     <div class="infoboxnote" id="GUID-A67BF901-60C7-4420-B01D-3E05A50246FC__GUID-51B4A56C-FDC1-43E9-B8C0-9C6D70E5AAF5">
                        <p class="notep1">注意：</p>
                        <p><code class="codeph">ResultSet</code>的Oracle实现提供了<code class="codeph">java.sql.的可滚动和可更新属性<code class="codeph">java.sql.ResultSet</code>接口。
                        </p>
                     </div>
                     <p>以下代码说明了如何滚动RowSet：</p><pre class="oac_no_warn" dir="ltr">/ ** *向前滚动，并按照获取顺序打印empno。* / ...rowset.setCommand（“SELECT empno，ename，sal FROM emp”）; rowset.execute（）; ...//转到rowset的第一行rowset.beforeFirst（）; while（rowset.next（））System.out.println（“empno：”+ rowset.getInt（1））;</pre><p>在前面的代码中，通过<code class="codeph">beforeFirst</code>方法将光标位置初始化为RowSet的第一行之前的位置。使用<code class="codeph">next</code>方法在向前方向检索行。
                     </p>
                     <p>以下代码说明了如何以相反方向滚动RowSet：</p><pre class="oac_no_warn" dir="ltr">/ ** *向后滚动，并按照提取的相反顺序打印empno。* / //转到rowset的最后一行rowset.afterLast（）; while（rowset.previous（））System.out.println（“empno：”+ rowset.getInt（1））;</pre><p>在前面的代码中，光标位置初始化为<code class="codeph">RowSet</code>的最后一行之后的位置。使用<code class="codeph">previous</code>一个<code class="codeph">RowSet</code>方法以反方向检索行。
                     </p>
                     <p>行集功能支持插入，更新和删除行，因为它们位于结果集功能中。为了使Row Set可更新，您必须调用<code class="codeph">setReadOnly(false)</code>和<code class="codeph">acceptChanges</code>方法。
                     </p>
                     <p>以下代码说明了在行集的第五个位置插入行：</p><pre class="oac_no_warn" dir="ltr">.../ ** *使rowset可更新* / rowset.setReadOnly（false）; / ** *在行集的第5个位置插入一行。* / //将光标移动到行集中的第5个位置if（rowset.absolute（5））{rowset.moveToInsertRow（）; rowset.updateInt（1,193）; rowset.updateString（2，“Smith”）; rowset.updateInt（3,7200）; //在rowset中插入一行rowset.insertRow（）; //将RowSet中的数据与数据库中的数据同步。rowset.acceptChanges（）; } ...
</pre><p>在前面的代码中，使用参数<code class="codeph">5</code>对<code class="codeph">absolute</code>方法的调用将光标移动到RowSet的第五个位置，并且对<code class="codeph">moveToInsertRow</code>方法的调用创建了一个用于将新行插入RowSet的位置。<code class="codeph">update</code> <span class="italic"><code class="codeph">XXX</code></span>方法用于更新新创建的行。更新行的所有列时，将<code class="codeph">insertRow</code>以更新RowSet。更改通过<code class="codeph">acceptChanges</code>方法提交。
                     </p>
                  </div>
               </div>
            </div><a id="JJDBC28637"></a><a id="JJDBC28636"></a><div class="props_rev_3"><a id="GUID-4B46C980-D32F-474D-8742-52A238CC1D3B" name="GUID-4B46C980-D32F-474D-8742-52A238CC1D3B"></a><h3 id="JJDBC-GUID-4B46C980-D32F-474D-8742-52A238CC1D3B" class="sect3"><span class="enumeration_section">18.2</span>关于CachedRowSet</h3>
               <div>
                  <p>CachedRowSet是一个RowSet，其中行被缓存并且RowSet断开连接，也就是说，它不维护与数据库的活动连接。<code class="codeph">oracle.jdbc.rowset.OracleCachedRowSet</code>类是CachedRowSet的Oracle实现。它可以与标准参考实现互操作。该<code class="codeph">OracleCachedRowSet</code>在类<code class="codeph">ojdbc6.jar</code>和<code class="codeph">ojdbc7.jar</code>文件实现了标准JSR-114接口<code class="codeph">javax.sql.rowset.CachedRowSet</code> 。
                  </p>
                  <p>在以下代码中，将创建<code class="codeph">OracleCachedRowSet</code>对象，并将<code class="codeph">RowSet</code>对象的连接URL，用户名，密码和SQL查询设置为属性。使用<code class="codeph">execute</code>方法填充<code class="codeph">RowSet</code>对象。处理完<code class="codeph">execute</code>方法后， <code class="codeph">RowSet</code>对象可以用作<code class="codeph">java.sql.ResultSet</code>对象，用于检索，滚动，插入，删除或更新数据。
                  </p><pre class="oac_no_warn" dir="ltr">...RowSet rowset = new OracleCachedRowSet（）; rowset.setUrl（ “JDBC：预言：OCI：@”）; rowset.setUsername（ “HR”）; rowset.setPassword（ “HR”）; rowset.setCommand（“SELECT employee_id，first_name，last_name，salary FROM employees”）; rowset.execute（）; while（rowset.next（））{System.out.println（“employee_id：”+ rowset.getInt（1））; System.out.println（“first_name：”+ rowset.getString（2））; System.out.println（“last_name：”+ rowset.getString（3））; System.out.println（“sal：”+ rowset.getInt（4））; } ...
</pre><p>要使用查询填充<code class="codeph">CachedRowSet</code>对象，请完成以下步骤：</p>
                  <ol>
                     <li>
                        <p>实例化<code class="codeph">OracleCachedRowSet</code> 。
                        </p>
                     </li>
                     <li>
                        <p>设置<code class="codeph">Url</code> ，它是连接URL， <code class="codeph">Username</code> ， <code class="codeph">Password</code>和<code class="codeph">Command</code> ，它是查询字符串， <code class="codeph">RowSet</code>对象的属性。您也可以设置连接类型，但它是可选的。
                        </p>
                     </li>
                     <li>
                        <p>调用<code class="codeph">execute</code>方法来填充<code class="codeph">CachedRowSet</code>对象。调用<code class="codeph">execute</code>会将查询集作为此RowSet上的属性运行。
                        </p>
                     </li>
                  </ol><pre class="oac_no_warn" dir="ltr">OracleCachedRowSet rowset = new OracleCachedRowSet（）; rowset.setUrl（“jdbc：oracle：oci：@”）; rowset.setUsername（“HR”）; rowset.setPassword（“hr”）; rowset.setCommand（“SELECT employee_id，first_name，last_name，salary FROM employees”）; rowset.execute（）;</pre><p>可以使用<code class="codeph">populate</code>方法使用现有<code class="codeph">ResultSet</code>对象填充<code class="codeph">CachedRowSet</code>对象。为此，请完成以下步骤：</p>
                  <ol>
                     <li>
                        <p>实例化<code class="codeph">OracleCachedRowSet</code> 。
                        </p>
                     </li>
                     <li>
                        <p>将已经可用的<code class="codeph">ResultSet</code>对象传递给<code class="codeph">populate</code>方法以填充<code class="codeph">RowSet</code>对象。
                        </p>
                     </li>
                  </ol><pre class="oac_no_warn" dir="ltr">//执行查询以获取ResultSet对象。ResultSet rset = pstmt.executeQuery（）; OracleCachedRowSet rowset = new OracleCachedRowSet（）; //将获取的ResultSet对象传递给populate方法//以填充rowset对象中的数据。rowset.populate（rset）;</pre><p>在前面的例子中， <code class="codeph">ResultSet</code>被通过运行查询获得的对象和检索到的<code class="codeph">ResultSet</code>对象被传递到<code class="codeph">populate</code>所述的方法<code class="codeph">CachedRowSet</code>对象来填充结果集到CachedRowSet的内容。
                  </p>
                  <div class="infoboxnote" id="GUID-4B46C980-D32F-474D-8742-52A238CC1D3B__GUID-2006538E-7221-4600-9D7C-4E5BA309CF12">
                     <p class="notep1">注意：</p>
                     <p>在使用预先存在的<code class="codeph">ResultSet</code>对象填充<code class="codeph">CachedRowSet</code>对象的情况下，无法设置连接属性，如事务隔离或结果集的并发模式，以及绑定属性，因为属性的连接或结果集已经创建了apply。
                     </p>
                  </div>
                  <p>以下代码说明了如何将<code class="codeph">OracleCachedRowSet</code>对象序列化为文件然后检索：</p><pre class="oac_no_warn" dir="ltr">//编写序列化的OracleCachedRowSet对象{FileOutputStream fileOutputStream = new FileOutputStream（“emp_tab.dmp”）; ObjectOutputStream ostream = new ObjectOutputStream（fileOutputStream）; ostream.writeObject（行集）; ostream.close（）; fileOutputStream.close（）; } //读取序列化的OracleCachedRowSet对象{FileInputStream fileInputStream = new FileInputStream（“emp_tab.dmp”）; ObjectInputStream istream = new ObjectInputStream（fileInputStream）; RowSet rowset1 =（RowSet）istream.readObject（）; istream.close（）; fileInputStream.close（）; }</pre><p>在上面的代码中， <code class="codeph">FileOutputStream</code>对象被打开一个<code class="codeph">emp_tab.dmp</code>文件，并在填充<code class="codeph">OracleCachedRowSet</code>对象是使用写入到文件<code class="codeph">ObjectOutputStream</code> 。使用<code class="codeph">FileInputStream</code>和<code class="codeph">ObjectInputStream</code>对象检索序列化的<code class="codeph">OracleCachedRowSet</code>对象。
                  </p>
                  <p><code class="codeph">OracleCachedRowSet</code>负责处理不可序列化的数据形式的序列化，如<code class="codeph">InputStream</code> ， <code class="codeph">OutputStream</code> ，二进制大对象（BLOB）和字符大对象（CLOB）。<code class="codeph">OracleCachedRowSets</code>还实现了自己的元数据，无需任何额外的服务器往返即可获得。以下代码说明了如何获取RowSet的元数据：</p><pre class="oac_no_warn" dir="ltr">...ResultSetMetaData metaData = rowset.getMetaData（）; int maxCol = metaData.getColumnCount（）; for（int i = 1; i &lt;= maxCol; ++ i）System.out.println（“Column（”+ i +“）”+ metaData.getColumnName（i））; ...
</pre><p>因为<code class="codeph">OracleCachedRowSet</code>类是可序列化的，所以它可以通过网络或Java虚拟机（JVM）之间传递，如<a id="d61846e798" class="indexterm-anchor"></a>远程方法调用（ <a id="d61846e801" class="indexterm-anchor"></a> RMI）。填充<code class="codeph">OracleCachedRowSet</code>类后，它可以在任何JVM或任何没有JDBC驱动程序的环境中移动。在RowSet中提交数据需要存在JDBC驱动程序。
                  </p>
                  <p>在服务器上执行检索数据并在<code class="codeph">OracleCachedRowSet</code>类中填充数据的完整过程，并使用RMI等适当的体系结构将填充的RowSet传递给客户端。 <a id="d61846e812" class="indexterm-anchor"></a>企业Java Bean（EJB）。客户端将能够执行所有操作，如在RowSet上检索，滚动，插入，更新和删除，而无需与数据库建立任何连接。每当将数据提交到数据库时，都会调用<code class="codeph">acceptChanges</code>方法，该方法将RowSet中的数据与数据库中的数据同步。此方法使用JDBC驱动程序，这需要JVM环境包含JDBC实现。这种架构适用于涉及像瘦客户机这样的瘦客户机的系统<a id="d61846e818" class="indexterm-anchor"></a>个人数字助理 （ <a id="d61846e821" class="indexterm-anchor"></a> PDA）。
                  </p>
                  <p>填充<code class="codeph">CachedRowSet</code>对象后，它可以用作<code class="codeph">ResultSet</code>对象或任何其他对象，可以使用RMI或任何其他合适的体系结构通过网络传递。
                  </p>
                  <p>CachedRowSet的其他一些关键功能如下：</p>
                  <ul style="list-style-type:disc">
                     <li>
                        <p>克隆一个RowSet</p>
                     </li>
                     <li>
                        <p>创建RowSet的副本</p>
                     </li>
                     <li>
                        <p>创建RowSet的共享副本</p>
                     </li>
                  </ul>
                  <div class="section">
                     <p class="subhead2" id="GUID-4B46C980-D32F-474D-8742-52A238CC1D3B__GUID-EF6D86C0-FDD1-42FE-A4ED-D71175CD4C18">CachedRowSet约束</p>
                  </div>
                  <!-- class="section" -->
                  <div class="section">
                     <p>除了序列化之外，适用于可更新结果集的所有约束都适用于此，因为<code class="codeph">OracleCachedRowSet</code>是可序列化的。SQL查询具有以下约束：</p>
                     <ul style="list-style-type:disc">
                        <li>
                           <p>仅引用数据库中的单个表</p>
                        </li>
                        <li>
                           <p>不包含连接操作</p>
                        </li>
                        <li>
                           <p>选择它引用的表的主键</p>
                        </li>
                     </ul>
                     <p>此外，如果要插入新行，SQL查询还应满足以下条件：</p>
                     <ul style="list-style-type:disc">
                        <li>
                           <p>选择基础表中的所有非可空列</p>
                        </li>
                        <li>
                           <p>选择所有没有默认值的列</p>
                           <div class="infoboxnote" id="GUID-4B46C980-D32F-474D-8742-52A238CC1D3B__GUID-2656B715-394E-452C-B5D3-59551D3B4873">
                              <p class="notep1">注意：</p>
                              <p><code class="codeph">CachedRowSet</code>无法容纳大量数据，因为所有数据都缓存在内存中。因此，Oracle建议不要将<code class="codeph">OracleCachedRowSet</code>与可能返回大量数据的查询一起使用。
                              </p>
                           </div>
                        </li>
                     </ul>
                     <p>在填充RowSet之后，无法设置连接属性（如事务隔离和结果集的并发模式），因为在从同一个数据中检索数据后，属性无法应用于连接。</p>
                  </div>
                  <!-- class="section" -->
               </div>
            </div><a id="JJDBC28639"></a><a id="JJDBC28638"></a><div class="props_rev_3"><a id="GUID-996D3872-FA2B-4BA5-99BA-62D5FB235583" name="GUID-996D3872-FA2B-4BA5-99BA-62D5FB235583"></a><h3 id="JJDBC-GUID-996D3872-FA2B-4BA5-99BA-62D5FB235583" class="sect3"><span class="enumeration_section">18.3</span>关于JdbcRowSet</h3>
               <div>
                  <p>JdbcRowSet是一个包装<code class="codeph">ResultSet</code>对象的RowSet。它是一个连接的RowSet，它以JavaBean接口的形式提供JDBC接口。JdbcRowSet的Oracle实现是<code class="codeph">oracle.jdbc.rowset.OracleJDBCRowSet</code> 。<code class="codeph">ojdbc6.jar</code>和<code class="codeph">ojdbc7.jar</code>的<code class="codeph">OracleJDBCRowSet</code>类实现了标准的JSR-114接口<code class="codeph">javax.sql.rowset.JdbcRowSet</code> 。
                  </p>
                  <p><a href="JDBC-Rowsets.html#GUID-996D3872-FA2B-4BA5-99BA-62D5FB235583__g631556" title="表">表18-1</a>显示了<code class="codeph">JdbcRowSet</code>接口与<code class="codeph">CachedRowSet</code>接口的不同之处。
                  </p>
                  <div class="tblformal" id="GUID-996D3872-FA2B-4BA5-99BA-62D5FB235583__g631556">
                     <p class="titleintable">表18-1 JDBC和缓存行集比较</p>
                     <table cellpadding="4" cellspacing="0" class="Formal" title="JDBC和缓存行集比较" width="100%" border="1" summary="table" frame="hsides" rules="rows">
                        <thead>
                           <tr align="left" valign="top">
                              <th align="left" valign="bottom" width="19%" id="d61846e959">行集类型</th>
                              <th align="left" valign="bottom" width="17%" id="d61846e962">序列化</th>
                              <th align="left" valign="bottom" width="15%" id="d61846e965">连接到数据库</th>
                              <th align="left" valign="bottom" width="14%" id="d61846e968">可以在JVM上移动</th>
                              <th align="left" valign="bottom" width="22%" id="d61846e971">将数据同步到数据库</th>
                              <th align="left" valign="bottom" width="14%" id="d61846e974">存在JDBC驱动程序</th>
                           </tr>
                        </thead>
                        <tbody>
                           <tr align="left" valign="top">
                              <td align="left" valign="top" width="19%" id="d61846e979" headers="d61846e959 ">
                                 <p>JDBC</p>
                              </td>
                              <td align="left" valign="top" width="17%" headers="d61846e979 d61846e962 ">
                                 <p>是</p>
                              </td>
                              <td align="left" valign="top" width="15%" headers="d61846e979 d61846e965 ">
                                 <p>是</p>
                              </td>
                              <td align="left" valign="top" width="14%" headers="d61846e979 d61846e968 ">
                                 <p>没有</p>
                              </td>
                              <td align="left" valign="top" width="22%" headers="d61846e979 d61846e971 ">
                                 <p>没有</p>
                              </td>
                              <td align="left" valign="top" width="14%" headers="d61846e979 d61846e974 ">
                                 <p>是</p>
                              </td>
                           </tr>
                           <tr align="left" valign="top">
                              <td align="left" valign="top" width="19%" id="d61846e998" headers="d61846e959 ">
                                 <p>缓存</p>
                              </td>
                              <td align="left" valign="top" width="17%" headers="d61846e998 d61846e962 ">
                                 <p>是</p>
                              </td>
                              <td align="left" valign="top" width="15%" headers="d61846e998 d61846e965 ">
                                 <p>没有</p>
                              </td>
                              <td align="left" valign="top" width="14%" headers="d61846e998 d61846e968 ">
                                 <p>是</p>
                              </td>
                              <td align="left" valign="top" width="22%" headers="d61846e998 d61846e971 ">
                                 <p>是</p>
                              </td>
                              <td align="left" valign="top" width="14%" headers="d61846e998 d61846e974 ">
                                 <p>没有</p>
                              </td>
                           </tr>
                        </tbody>
                     </table>
                  </div>
                  <!-- class="inftblhruleinformal" -->
                  <p>JdbcRowSet是一个连接的RowSet，它与数据库有实时连接，JdbcRowSet上的所有调用都被渗透到JDBC连接，语句或结果集中的映射调用。CachedRowSet与数据库打开没有任何连接。</p>
                  <p>与CachedRowSet不同，JdbcRowSet需要存在JDBC驱动程序，CachedRowSet在操作期间不需要JDBC驱动程序。但是，在RowSet的填充期间以及提交RowSet的更改时，JdbcRowSet和CachedRowSet都需要JDBC驱动程序。</p>
                  <p>以下代码说明了如何使用JdbcRowSet：</p><pre class="oac_no_warn" dir="ltr">...RowSet rowset = new OracleJDBCRowSet（）; rowset.setUrl（ “Java的：预言：OCI：@”）; rowset.setUsername（ “HR”）; rowset.setPassword（ “HR”）; rowset.setCommand（“SELECT empno，ename，sal FROM emp”）; rowset.execute（）; while（rowset.next（））{System.out.println（“empno：”+ rowset.getInt（1））; System.out.println（“ename：”+ rowset.getString（2））; System.out.println（“sal：”+ rowset.getInt（3））; } ...
</pre><p>在前面的示例中，连接URL，用户名，密码和SQL查询被设置为<code class="codeph">RowSet</code>对象的属性，使用<code class="codeph">execute</code>方法处理SQL查询，并通过遍历填充的数据来检索和打印行。 <code class="codeph">RowSet</code>对象。
                  </p>
               </div>
            </div><a id="JJDBC28640"></a><div class="props_rev_3"><a id="GUID-862F56C6-7874-4A18-8933-F487538D847D" name="GUID-862F56C6-7874-4A18-8933-F487538D847D"></a><h3 id="JJDBC-GUID-862F56C6-7874-4A18-8933-F487538D847D" class="sect3"><span class="enumeration_section">18.4</span>关于WebRowSet</h3>
               <div>
                  <p>WebRowSet是CachedRowSet的扩展。它表示一组提取的行或表格数据，这些数据可以在层和组件之间传递，使得不需要维护与数据源的活动连接。<code class="codeph">WebRowSet</code>接口以可扩展标记语言（XML）格式和断开连接的方式提供对结果集的生成和使用及其与数据源的同步的支持。这允许结果集跨层和Internet协议传送。
                  </p>
                  <p>WebRowSet的Oracle实现是<code class="codeph">oracle.jdbc.rowset.OracleWebRowSet</code> 。该类位于<code class="codeph">ojdbc6.jar</code>和<code class="codeph">ojdbc7.jar</code>文件中，实现了标准的JSR-114接口<code class="codeph">javax.sql.rowset.WebRowSet</code> 。该类还扩展了<code class="codeph">oracle.jdbc.rowset.OracleCachedRowSet</code>类。除了可用方法<code class="codeph">OracleCachedRowSet</code>中， <code class="codeph">OracleWebRowSet</code>类提供了以下方法：</p>
                  <ul style="list-style-type:disc">
                     <li><pre class="oac_no_warn" dir="ltr">public OracleWebRowSet（）抛出SQLException</pre><p>这是用于创建构造<code class="codeph">OracleWebRowSet</code>对象，其与用于所述默认值来初始化<code class="codeph">OracleCachedRowSet</code>对象，一个默认<code class="codeph">OracleWebRowSetXmlReader</code>和默认<code class="codeph">OracleWebRowSetXmlWriter</code> 。
                        </p>
                     </li>
                     <li><pre class="oac_no_warn" dir="ltr">public void writeXml（java.io。Writer writer）抛出SQLException public void writeXml（java.io。OutputStream ostream）抛出SQLException</pre><p>这些方法将<code class="codeph">OracleWebRowSet</code>对象以符合JSR-114 XML模式的XML格式写入提供的<code class="codeph">Writer</code>或<code class="codeph">OutputStream</code>对象。除了RowSet数据之外，还会写入RowSet的属性和元数据。
                        </p>
                     </li>
                     <li><pre class="oac_no_warn" dir="ltr">public void writeXml（ResultSet rset，java.io。Writer writer）抛出SQLException public void writeXml（ResultSet rset，java.io。OutputStream ostream）抛出SQLException</pre><p>这些方法创建一个<code class="codeph">OracleWebRowSet</code>对象，使用给定<code class="codeph">ResultSet</code>对象中的数据填充它，并将其以符合JSR-114 XML模式的XML格式写入提供的<code class="codeph">Writer</code>或<code class="codeph">OutputStream</code>对象。
                        </p>
                     </li>
                     <li><pre class="oac_no_warn" dir="ltr">public void readXml（java.io。读者阅读器）抛出SQLException public void readXml（java.io。InputStream istream）抛出SQLException</pre><p>这些方法读取<code class="codeph">OracleWebRowSet</code>根据其JSR-114的XML模式的XML格式对象，使用所提供的<code class="codeph">Reader</code>或<code class="codeph">InsputStream</code>对象。
                        </p>
                     </li>
                  </ul>
                  <p>Oracle WebRowSet实现支持Java API for XML Processing（JAXP）1.2。支持Simple API for XML（SAX）2.0和文档对象模型（DOM）符合JAXP的XML解析器。它遵循WebRowSet的当前JSR-114 W3C XML模式。</p>
                  <p>在调用方法之前，使用<code class="codeph">readXml(...)</code>方法的应用程序应设置以下两个标准JAXP系统属性之一：</p>
                  <ul style="list-style-type:disc">
                     <li>
                        <p><code class="codeph">javax.xml.parsers中。的SAXParserFactory</code></p>
                        <p>此属性适用于SAX解析器。</p>
                     </li>
                     <li>
                        <p><code class="codeph">javax.xml.parsers中。的DocumentBuilderFactory</code></p>
                        <p>此属性适用于DOM解析器。</p>
                     </li>
                  </ul>
                  <p>以下代码说明了使用<code class="codeph">OracleWebRowSet</code>进行XML格式的写入和读取：</p><pre class="oac_no_warn" dir="ltr">import java.sql。*; import java.io.*; import oracle.jdbc.rowset。*; ...String url =“jdbc：oracle：oci8：@”; Connection conn = DriverManager.getConnection（url，“HR”，“hr”）;语句stmt = conn.createStatement（）; ResultSet rset = stmt.executeQuery（“select * from employees”）; //创建一个OracleWebRowSet对象并使用ResultSet对象填充它OracleWebRowSet wset = new OracleWebRowSet（）; wset.populate（RSET）; try {//创建一个java.io.Writer对象FileWriter out = new FileWriter（“xml.out”）; //现在生成XML并将其写出wset.writeXml（out）; } catch（IOException exc）{System.out.println（“无法构造FileWriter”）; System.out.println（“生成的XML输出文件。”）; //创建一个新的OracleWebRowSet，用于从XML输入读取OracleWebRowSet wset2 = new OracleWebRowSet（）; //使用Oracle JAXP SAX解析器System.setProperty（“javax.xml.parsers。的SAXParserFactory “” oracle.xml.jaxp。JXSAXParserFactory“）; try {//使用前面的输出文件作为输入FileReader fr = new FileReader（”xml.out“）; //现在从FileReader读取XML流wset2.readXml（fr）;} catch（IOException exc） {System.out.println（“无法构造FileReader”）;} ...
</pre><div class="infoboxnote" id="GUID-862F56C6-7874-4A18-8933-F487538D847D__GUID-6F6A3496-50E1-4D5D-A2BE-132B004DC7F9">
                     <p class="notep1">注意：</p>
                     <p>上述代码使用Oracle SAX XML解析器，它支持模式验证。</p>
                  </div>
               </div>
            </div><a id="JJDBC28641"></a><div class="props_rev_3"><a id="GUID-8AA0A89C-3CC2-4872-8EFD-3A390E712A4D" name="GUID-8AA0A89C-3CC2-4872-8EFD-3A390E712A4D"></a><h3 id="JJDBC-GUID-8AA0A89C-3CC2-4872-8EFD-3A390E712A4D" class="sect3"><span class="enumeration_section">18.5</span>关于FilteredRowSet</h3>
               <div>
                  <p>FilteredRowSet是WebRowSet的扩展，为过滤其内容提供编程支持。这使您可以避免提供查询和所涉及的处理的开销。FilteredRowSet的Oracle实现是<code class="codeph">oracle.jdbc.rowset.OracleFilteredRowSet</code> 。<code class="codeph">ojdbc7.jar</code>文件中的<code class="codeph">OracleFilteredRowSet</code>类实现了标准的JSR-114接口<code class="codeph">javax.sql.rowset.FilteredRowSet</code> 。
                  </p>
                  <p><code class="codeph">OracleFilteredRowSet</code>类定义以下新方法：</p>
                  <ul style="list-style-type:disc">
                     <li><pre class="oac_no_warn" dir="ltr">public Predicate getFilter（）;</pre><p>此方法返回<code class="codeph">Predicate</code>对象，该对象定义<code class="codeph">OracleFilteredRowSet</code>对象上活动的过滤条件。
                        </p>
                     </li>
                     <li><pre class="oac_no_warn" dir="ltr">public void setFilter（Predicate p）抛出SQLException;</pre><p>此方法将<code class="codeph">Predicate</code>对象作为参数。<code class="codeph">Predicate</code>对象定义要应用于<code class="codeph">OracleFilteredRowSet</code>对象的过滤条件。这些方法抛出<code class="codeph">SQLException</code>异常。
                        </p>
                     </li>
                  </ul>
                  <div class="infoboxnote" id="GUID-8AA0A89C-3CC2-4872-8EFD-3A390E712A4D__GUID-56E125BB-76F2-4BAF-A510-4C6D63B2B1FA">
                     <p class="notep1">注意：</p>
                     <p>如果您使用<code class="codeph">classes12.jar</code>而不是<code class="codeph">ojdbc5.jar</code>和<code class="codeph">ojdbc6.jar</code>来使用FilteredRowSet功能，那么请使用<code class="codeph">OraclePredicate</code>而不是<code class="codeph">Predicate</code> 。<code class="codeph">oracle.jdbc.rowset.OraclePredicate</code>接口是Oracle特定的，相当于<code class="codeph">Predicate</code> 。当JSR-114程序包不可用时使用此接口。
                     </p>
                  </div>
                  <p><code class="codeph">OracleFilteredRowSet</code>对象上设置的谓词定义了一个过滤条件，该条件应用于对象中的所有行以获取可见行集。谓词还定义了插入，删除和修改行的标准。设置过滤条件充当<code class="codeph">OracleFilteredRowSet</code>对象的所有视图和更新的选通机制。任何更新违反过滤条件的<code class="codeph">OracleFilteredRowSet</code>对象的尝试<code class="codeph">OracleFilteredRowSet</code>引发<code class="codeph">SQLException</code>异常。
                  </p>
                  <p>可以通过应用新的<code class="codeph">Predicate</code>对象来修改在<code class="codeph">OracleFilteredRowSet</code>对象上设置的过滤条件。新条件立即应用于对象，所有进一步的视图和更新必须符合此新条件。仅当没有对<code class="codeph">OracleFilteredRowSet</code>对象的引用时，才能应用新的过滤条件。
                  </p>
                  <p>在删除过滤条件或应用新的过滤条件之前，不能修改超出对象上设置的过滤条件的行。此外，如果尝试持久保存对象，则只有属于过滤条件范围的行才会与数据源同步。</p>
                  <p>以下代码示例说明了OracleFilteredRowSet的用法。假设一个表<code class="codeph">test_table</code> ，包含两个<code class="codeph">NUMBER</code>列<code class="codeph">col1</code>和<code class="codeph">col2</code> 。代码从表中检索那些值为<code class="codeph">col1</code>值在<code class="codeph">50</code>到<code class="codeph">100</code>之间， <code class="codeph">col2</code>值在<code class="codeph">100</code>到<code class="codeph">200</code>之间的行。
                  </p>
                  <p>定义过滤条件的谓词如下：</p><pre class="oac_no_warn" dir="ltr">public class PredicateImpl实现Predicate {private int low []; private int high []; private int columnIndexes []; public PredicateImpl（int [] lo，int [] hi，int [] indices）{low = lo; high = hi; columnIndexes = indexes; public boolean evaluate（RowSet rs）{boolean result = true; for（int i = 0; i &lt;columnIndexes.length; i ++）{int columnValue = rs.getInt（columnIndexes [i]）; if（columnValue &lt;low [i] || columnValue&gt; high [i]）result = false;返回结果; } //其他两个评估（...）方法只返回true}</pre><p>上述代码中定义的谓词用于过滤<code class="codeph">OracleFilteredRowSet</code>对象中的内容，如下所示：</p><pre class="oac_no_warn" dir="ltr">...OracleFilteredRowSet ofrs = new OracleFilteredRowSet（）; int low [] = {50,100}; int high [] = {100,200}; int indexes [] = {1,2}; ofrs.setCommand（“select col1，col2 from test_table”）; //设置像usr / pwd这样的其他属性......ofrs.execute（）; ofrs.setPredicate（new PredicateImpl（low，high，indexes））; //这只会获得col1位于（50,100）且col2位于（100,200）而（ofrs.next（））{...}的行...
</pre></div>
            </div><a id="JJDBC28642"></a><div class="props_rev_3"><a id="GUID-60685532-AA0E-4692-A369-5F9D79AA9A72" name="GUID-60685532-AA0E-4692-A369-5F9D79AA9A72"></a><h3 id="JJDBC-GUID-60685532-AA0E-4692-A369-5F9D79AA9A72" class="sect3"><span class="enumeration_section">18.6</span>关于JoinRowSet</h3>
               <div>
                  <p>JoinRowSet是WebRowSet的扩展，由来自不同RowSet的相关数据组成。没有连接到数据源，没有标准方法在断开连接的RowSet之间建立SQL <code class="codeph">JOIN</code> 。JoinRowSet解决了这个问题。JoinRowSet的Oracle实现是<code class="codeph">oracle.jdbc.rowset.OracleJoinRowSet</code>类。该类位于<code class="codeph">ojdbc7.jar</code>文件中，实现了标准的JSR-114接口<code class="codeph">javax.sql.rowset.JoinRowSet</code> 。
                  </p>
                  <p>可以将任何数量的实现<code class="codeph">Joinable</code>接口的<code class="codeph">RowSet</code>对象添加到<code class="codeph">JoinRowSet</code>对象，前提是它们可以在SQL <code class="codeph">JOIN</code> 。所有五种类型的RowSet都支持<code class="codeph">Joinable</code>接口。<code class="codeph">Joinable</code>接口提供了用于指定将根据<code class="codeph">JOIN</code>执行的列的方法，即匹配列。
                  </p>
                  <div class="infoboxnote" id="GUID-60685532-AA0E-4692-A369-5F9D79AA9A72__GUID-E9279756-F192-42B9-AD5D-5563831B3545">
                     <p class="notep1">注意：</p>
                     <p>如果您使用<code class="codeph">classes12.jar</code>而不是<code class="codeph">ojdbc5.jar</code>和<code class="codeph">ojdbc6.jar</code>来获取JoinRowSet功能，那么请使用<code class="codeph">OracleJoinable</code>而不是<code class="codeph">Joinable</code> 。<code class="codeph">oracle.jdbc.rowset.OracleJoinable</code>接口是特定于Oracle的，与<code class="codeph">Joinable</code>等效。当JSR-114程序包不可用时使用此接口。
                     </p>
                  </div>
                  <p>可以通过以下方式指定匹配列：</p>
                  <ul style="list-style-type:disc">
                     <li>
                        <p>使用<code class="codeph">setMatchColumn</code>方法</p>
                        <p>此方法在<code class="codeph">Joinable</code>接口中定义。在将<code class="codeph">RowSet</code>对象添加到<code class="codeph">JoinRowSet</code>对象之前，它是唯一可用于设置匹配列的方法。此方法还可用于随时重置匹配列。
                        </p>
                     </li>
                     <li>
                        <p>使用<code class="codeph">addRowSet</code>方法</p>
                        <p>这是<code class="codeph">JoinRowSet</code>的重载方法。此方法的五个实现中的四个将匹配列作为参数。在将<code class="codeph">RowSet</code>对象添加到<code class="codeph">JoinRowSet</code>对象时，可以使用这四种方法设置或重置匹配列。
                        </p>
                     </li>
                  </ul>
                  <p>除了继承的方法， <code class="codeph">OracleJoinRowSet</code>还提供了以下方法：</p>
                  <ul style="list-style-type:disc">
                     <li><pre class="oac_no_warn" dir="ltr">public void addRowSet（Joinable joinable）抛出SQLException; public void addRowSet（RowSet rowSet，int i）抛出SQLException; public void addRowSet（RowSet rowSet，String s）抛出SQLException; public void addRowSet（RowSet arowSet []，int an []）抛出SQLException; public void addRowSet（RowSet arowSet []，String as []）抛出SQLException;</pre><p>这些方法用于将<code class="codeph">RowSet</code>对象添加到<code class="codeph">OracleJoinRowSet</code>对象。您可以传递一个或多个<code class="codeph">RowSet</code>对象以添加到<code class="codeph">OracleJoinRowSet</code>对象。您还可以传递一列或多列的名称或索引，这些列需要设置为匹配列。
                        </p>
                     </li>
                     <li><pre class="oac_no_warn" dir="ltr">public Collection getRowSets（）抛出SQLException;</pre><p>此方法检索添加到<code class="codeph">OracleJoinRowSet</code>对象的<code class="codeph">RowSet</code>对象。该方法返回一个<code class="codeph">java.util.包含<code class="codeph">RowSet</code>对象的Collection</code>对象。
                        </p>
                     </li>
                     <li><pre class="oac_no_warn" dir="ltr">public String [] getRowSetNames（）抛出SQLException;</pre><p>此方法返回一个String数组，其中包含添加到<code class="codeph">OracleJoinRowSet</code>对象的<code class="codeph">RowSet</code>对象的名称。
                        </p>
                     </li>
                     <li><pre class="oac_no_warn" dir="ltr">public boolean supportsCrossJoin（）; public boolean supportsFullJoin（）; public boolean supportsInnerJoin（）; public boolean supportsLeftOuterJoin（）; public boolean supportsRightOuterJoin（）;</pre><p>这些方法返回一个布尔值，指示<code class="codeph">OracleJoinRowSet</code>对象是否支持相应的<code class="codeph">JOIN</code>类型。
                        </p>
                     </li>
                     <li><pre class="oac_no_warn" dir="ltr">public void setJoinType（int i）抛出SQLException;</pre><p>此方法用于在<code class="codeph">OracleJoinRowSet</code>对象上设置<code class="codeph">JOIN</code>类型。它需要一个<code class="codeph">javax.sql.rowset.定义的整数常量<code class="codeph">javax.sql.rowset.JoinRowSet</code>接口，指定<code class="codeph">JOIN</code>类型。
                        </p>
                     </li>
                     <li><pre class="oac_no_warn" dir="ltr">public int getJoinType（）抛出SQLException;</pre><p>此方法返回一个整数值，该值指示在<code class="codeph">OracleJoinRowSet</code>对象上设置的<code class="codeph">JOIN</code>类型。此方法抛出<code class="codeph">SQLException</code>异常。
                        </p>
                     </li>
                     <li><pre class="oac_no_warn" dir="ltr">public CachedRowSet toCachedRowSet（）抛出SQLException;</pre><p>此方法创建一个<code class="codeph">CachedRowSet</code>对象，该对象包含<code class="codeph">OracleJoinRowSet</code>对象中的数据。
                        </p>
                     </li>
                     <li><pre class="oac_no_warn" dir="ltr">public String getWhereClause（）抛出SQLException;</pre><p>此方法返回一个String，其中包含<code class="codeph">OracleJoinRowSet</code>对象中使用的<code class="codeph">WHERE</code>子句的类似SQL的描述。此方法抛出<code class="codeph">SQLException</code>异常。
                        </p>
                     </li>
                  </ul>
                  <p>以下代码说明了如何使用<code class="codeph">OracleJoinRowSet</code>在两个RowSets上执行内部联接，这两个RowSet的数据来自两个不同的表。生成的RowSet包含数据，就好像它们是这两个表上的内连接的结果一样。假设有两个表，一个<code class="codeph">Order</code>表有两个<code class="codeph">NUMBER</code>列<code class="codeph">Order_id</code>和<code class="codeph">Person_id</code> ，一个<code class="codeph">Person</code>表有一个<code class="codeph">NUMBER</code>列<code class="codeph">Person_id</code>和一个<code class="codeph">VARCHAR2</code>列<code class="codeph">Name</code> 。
                  </p><pre class="oac_no_warn" dir="ltr">...//从表中保存数据的RowSet命令OracleCachedRowSet ocrsOrder = new OracleCachedRowSet（）; ...ocrsOrder.setCommand（“select order_id，person_id from order”）; ...//加入person_id列ocrsOrder.setMatchColumn（2）; ocrsOrder.execute（）; //创建JoinRowSet OracleJoinRowSet ojrs = new OracleJoinRowSet（）; ojrs.addRowSet（ocrsOrder）; // RowSet保存表中的数据Person OracleCachedRowSet ocrsPerson = new OracleCachedRowSet（）; ...ocrsPerson.setCommand（“select person_id，person from person”）; ...//不要使用setMatchColumn（）在此RowSet上设置匹配列。//使用addRowSet（）设置匹配列ocrsPerson.execute（）; //以另一种方式加入person_id列ojrs.addRowSet（ocrsPerson，1）; //现在我们可以像往常一样去参加JoinRowSet ojrs.beforeFirst（）; while（ojrs.next（））System.out.println（“order id =”+ ojrs.getInt（1）+“，”+“person id =”+ ojrs.getInt（2）+“，”+“person's name =“+ ojrs.getString（3））; ...
</pre></div>
            </div>
         </div>
      </article>
   </body>
</html>