<html lang="en-us" dir="ltr" xml:lang="en-us">
   <head>
      <meta http-equiv="Content-Type" content="text/html; charset=utf-8"></meta>
      <meta name="viewport" content="width=device-width, initial-scale=1"></meta>
      <meta http-equiv="X-UA-Compatible" content="IE=edge"></meta>
      <title>嵌入式SQL</title>
      <meta property="og:site_name" content="Oracle Help Center"></meta>
      <meta property="og:title" content="Programmer&#39;s Guide"></meta>
      <meta property="og:description" content=""></meta>
      <link rel="stylesheet" href="/sp_common/book-template/ohc-book-template/css/book.css"></link>
      <link rel="shortcut icon" href="/sp_common/book-template/ohc-common/img/favicon.ico"></link>
      <meta name="application-name" content="Programmer&#39;s Guide"></meta>
      <meta name="generator" content="DITA Open Toolkit version 1.8.5 (Mode = doc)"></meta>
      <meta name="plugin" content="SP_docbuilder HTML plugin release 18.2.2"></meta>
      <link rel="alternate" href="c-c-programmers-guide.pdf" title="PDF File" type="application/pdf"></link>
      <meta name="robots" content="all"></meta>
      <link rel="schema.dcterms" href="http://purl.org/dc/terms/"></link>
      <meta name="dcterms.created" content="2019-01-11T03:52:01-08:00"></meta>
      
      <meta name="dcterms.dateCopyrighted" content="1996, 2019"></meta>
      <meta name="dcterms.category" content="database"></meta>
      <meta name="dcterms.identifier" content="E96467-01"></meta>
      
      <meta name="dcterms.product" content="en/database/oracle/oracle-database/19"></meta>
      
      <link rel="prev" href="advanced-topics.html" title="Previous" type="text/html"></link>
      <link rel="next" href="embedded-PL-SQL.html" title="Next" type="text/html"></link>
      <script>
        document.write('<style type="text/css">');
        document.write('body > .noscript, body > .noscript ~ * { visibility: hidden; }');
        document.write('</style>');
     </script>
      <script src="/sp_common/book-template/requirejs/require.js" data-main="/sp_common/book-template/ohc-book-template/js/book-config"></script>
      <script>
            if (window.require === undefined) {
                document.write('<script data-main="sp_common/book-template/ohc-book-template/js/book-config" src="sp_common/book-template/requirejs/require.js"><\/script>');
                document.write('<link href="sp_common/book-template/ohc-book-template/css/book.css" rel="stylesheet"/>');
            }
        </script>
      <script type="application/json" id="ssot-metadata">{"primary":{"category":{"short_name":"database","element_name":"Database","display_in_url":true},"suite":{"short_name":"oracle","element_name":"Oracle","display_in_url":true},"product_group":{"short_name":"not-applicable","element_name":"Not applicable","display_in_url":false},"product":{"short_name":"oracle-database","element_name":"Oracle Database","display_in_url":true},"release":{"short_name":"19","element_name":"Release 19","display_in_url":true}}}</script>
      
    <meta name="dcterms.title" content="Pro*C/C++ Programmer&#39;s Guide"></meta>
    <meta name="dcterms.isVersionOf" content="LNPCC"></meta>
    <meta name="dcterms.release" content="Release 19"></meta>
  </head>
   <body dir="ltr">
      <div class="noscript alert alert-danger text-center" role="alert">
         <a href="advanced-topics.html" class="pull-left"><span class="glyphicon glyphicon-chevron-left" aria-hidden="true"></span>上一页</a> <a href="embedded-PL-SQL.html" class="pull-right">下一页<span class="glyphicon glyphicon-chevron-right" aria-hidden="true"></span></a> <span class="fa fa-exclamation-triangle" aria-hidden="true"></span>必须启用JavaScript才能正确显示此内容</div>
      <article>
         <header>
            <ol class="breadcrumb" vocab="http://schema.org/" typeof="BreadcrumbList">
               <li property="itemListElement" typeof="ListItem"><a href="index.html" property="item" typeof="WebPage"><span property="name">程序员指南</span></a></li>
               <li property="itemListElement" typeof="ListItem"><a href="introduction-and-concepts.html" property="item" typeof="WebPage"><span property="name">介绍和概念</span></a></li>
               <li class="active" property="itemListElement" typeof="ListItem">嵌入式SQL</li>
            </ol>
            <a id="GUID-C671CABF-202A-4503-A16B-DC78D3F1AB13" name="GUID-C671CABF-202A-4503-A16B-DC78D3F1AB13"></a><a id="LNPCC3339"></a>
            
            <h2 id="LNPCC-GUID-C671CABF-202A-4503-A16B-DC78D3F1AB13" class="sect2"><span class="enumeration_chapter">6</span>嵌入式SQL</h2>
         </header>
         <div class="ind">
            <div>
               <p>本章帮助您理解和应用嵌入式SQL编程的基本技术。本章包含以下主题：</p>
               <ul style="list-style-type:disc">
                  <li>
                     <p><a href="embedded-SQL.html#GUID-71AF7FEC-9236-4D73-BD1D-BFA8B4EA63C2">主机变量</a></p>
                  </li>
                  <li>
                     <p><a href="embedded-SQL.html#GUID-22C65C80-42A1-4C8B-B883-19EFDF7AA31C">指标变量</a></p>
                  </li>
                  <li>
                     <p><a href="embedded-SQL.html#GUID-431532CF-1652-4EB6-AD2A-7E695744FADE">基本SQL语句</a></p>
                  </li>
                  <li>
                     <p><a href="embedded-SQL.html#GUID-A44FA873-61D5-42AF-A93E-1CA2041D9A3D">DML返回条款</a></p>
                  </li>
                  <li>
                     <p><a href="embedded-SQL.html#GUID-E53CD1B7-9E49-44E0-89DA-9A567E7CD7A8">游标</a></p>
                  </li>
                  <li>
                     <p><a href="embedded-SQL.html#GUID-EE1C3E7B-AEE5-4514-9D57-36C71E35D829">可滚动游标</a></p>
                  </li>
                  <li>
                     <p><a href="embedded-SQL.html#GUID-F6C600D0-D49D-4C24-910E-A4153C8818CD">优化器提示</a></p>
                  </li>
                  <li>
                     <p><a href="embedded-SQL.html#GUID-BA6FB717-6577-45D7-87A9-ECC60FECD9AA">修复执行计划</a></p>
                  </li>
                  <li>
                     <p><a href="embedded-SQL.html#GUID-CB61E704-AA77-4F5F-BF67-A3E4F58C63C6">条款的当前条款</a></p>
                  </li>
                  <li>
                     <p><a href="embedded-SQL.html#GUID-6D0BC220-1DE8-49E9-AB54-F39182E33ECD">游标语句</a></p>
                  </li>
                  <li>
                     <p><a href="embedded-SQL.html#GUID-58F44B5B-4F08-4853-AF71-C2995F48E2ED">使用不可滚动游标的完整示例</a></p>
                  </li>
                  <li>
                     <p><a href="embedded-SQL.html#GUID-08073F0A-E663-4D3A-9DB4-92BF47CA6560">使用可滚动游标的完整示例</a> 
                     </p>
                  </li>
               </ul>
            </div><a id="LNPCC3340"></a><div class="props_rev_3"><a id="GUID-71AF7FEC-9236-4D73-BD1D-BFA8B4EA63C2" name="GUID-71AF7FEC-9236-4D73-BD1D-BFA8B4EA63C2"></a><h3 id="LNPCC-GUID-71AF7FEC-9236-4D73-BD1D-BFA8B4EA63C2" class="sect3"><span class="enumeration_section">6.1</span>主机变量</h3>
               <div>
                  <p>Oracle使用主机变量将数据和状态信息传递给您的程序;您的程序使用主机变量将数据传递给Oracle。 <a id="d30526e83" class="indexterm-anchor"></a> 
                  </p>
               </div><a id="LNPCC3341"></a><div class="props_rev_3"><a id="GUID-F292197E-ED6D-48E6-80E0-7E7161BE5E29" name="GUID-F292197E-ED6D-48E6-80E0-7E7161BE5E29"></a><h4 id="LNPCC-GUID-F292197E-ED6D-48E6-80E0-7E7161BE5E29" class="sect4"><span class="enumeration_section">6.1.1</span>输出与输入主机变量</h4>
                  <div>
                     <p>根据它们的使用方式，主变量称为输出或输入主变量。 <a id="d30526e99" class="indexterm-anchor"></a><a id="d30526e103" class="indexterm-anchor"></a> 
                     </p>
                     <p>SELECT或FETCH语句的INTO子句中的主机变量称为<span class="italic">输出</span>主机变量，因为它们包含Oracle输出的列值。Oracle将列值分配给INTO子句中的相应输出主机变量。 <a id="d30526e111" class="indexterm-anchor"></a><a id="d30526e115" class="indexterm-anchor"></a><a id="d30526e119" class="indexterm-anchor"></a> 
                     </p>
                     <p>SQL语句中的所有其他主机变量都称为<span class="italic">输入</span>主机变量，因为您的程序将其值输入到Oracle。例如，您在INSERT语句的VALUES子句和UPDATE语句的SET子句中使用输入主机变量。它们也用在WHERE，HAVING和FOR子句中。只要允许值或表达式，输入主变量就可以出现在SQL语句中。 <a id="d30526e129" class="indexterm-anchor"></a><a id="d30526e133" class="indexterm-anchor"></a><a id="d30526e137" class="indexterm-anchor"></a> 
                     </p>
                     <div class="infoboxnote" id="GUID-F292197E-ED6D-48E6-80E0-7E7161BE5E29__GUID-D9FEB047-E376-41FB-98AE-94C48AF75F02">
                        <p class="notep1">注意：</p>
                        <p>在ORDER BY子句中，您<span class="italic">可以</span>使用主机变量，但它被视为常量或文字，因此主机变量的内容无效。例如，SQL语句</p><pre class="oac_no_warn" dir="ltr">EXEC SQL SELECT ename，empno INTO：name，：number FROM emp ORDER BY：ord;</pre><p>似乎包含输入主机变量<span class="italic">：ord</span> 。但是，在这种情况下，host变量被视为常量，并且无论<span class="italic">ord</span>的值如何，都不会进行排序。
                        </p>
                     </div>
                     <p>您不能使用输入主机变量来提供SQL关键字或数据库对象的名称。因此，您不能在数据定义语句（如ALTER，CREATE和DROP）中使用输入主机变量。在以下示例中，DROP TABLE语句<span class="italic">无效</span> ： <a id="d30526e163" class="indexterm-anchor"></a><a id="d30526e167" class="indexterm-anchor"></a> 
                     </p><pre class="oac_no_warn" dir="ltr">char table_name [30]; printf（“表名？“）; gets（table_name）; EXEC SQL DROP TABLE：table_name;  - 不允许主机变量</pre><p>如果需要在运行时更改数据库对象名，请使用动态SQL。</p>
                     <p>在Oracle执行包含输入主机变量的SQL语句之前，程序必须为它们分配值。一个例子如下： <a id="d30526e178" class="indexterm-anchor"></a> 
                     </p><pre class="oac_no_warn" dir="ltr">int emp_number; char temp [20]; VARCHAR emp_name [20]; / *获取输入主变量的值* / printf（“员工编号？“）; gets（temp）; emp_number = atoi（temp）; printf（”员工姓名？“）; gets（emp_name.arr）; emp_name.len = strlen（emp_name.arr）; EXEC SQL INSERT INTO EMP（EMPNO，ENAME）VALUES（：emp_number，：emp_name）;</pre><p>请注意，INSERT语句的VALUES子句中的输入主机变量以冒号为前缀。</p>
                  </div>
                  <div>
                     <div class="relinfo">
                        <p><strong>相关话题</strong></p>
                        <ul>
                           <li><a href="Oracle-dynamic-SQL.html#GUID-3B9E253A-F03D-431D-A77E-84C02C43F494">Oracle动态SQL</a></li>
                        </ul>
                     </div>
                  </div>
                  
               </div>
            </div><a id="LNPCC3343"></a><a id="LNPCC3344"></a><a id="LNPCC3342"></a><div class="props_rev_3"><a id="GUID-22C65C80-42A1-4C8B-B883-19EFDF7AA31C" name="GUID-22C65C80-42A1-4C8B-B883-19EFDF7AA31C"></a><h3 id="LNPCC-GUID-22C65C80-42A1-4C8B-B883-19EFDF7AA31C" class="sect3"><span class="enumeration_section">6.2</span>指标变量</h3>
               <div>
                  <p>您可以将任何主机变量与可选的指示符变量相关联。每次在SQL语句中使用主机变量时，结果代码都存储在其关联的指示符变量中。因此，指标变量可让您监控主变量。 <a id="d30526e209" class="indexterm-anchor"></a><a id="d30526e213" class="indexterm-anchor"></a><a id="d30526e217" class="indexterm-anchor"></a><a id="d30526e221" class="indexterm-anchor"></a> 
                  </p>
                  <div class="infoboxnote" id="GUID-22C65C80-42A1-4C8B-B883-19EFDF7AA31C__GUID-2BA1EC06-94C1-4EB9-AA75-B3158A1C473D">
                     <p class="notep1">注意：</p>
                     <p>您不能在PL / SQL块中使用单个主机变量的多个指示符变量。这样做会导致“并非所有变量绑定”错误。</p>
                  </div>
                  <p>您可以在VALUES或SET子句中使用指示符变量为输入主变量分配NULL。使用INTO子句中的指示符变量来检测输出主机变量中的NULL或截断值。</p>
                  <div class="section">
                     <p class="subhead2" id="GUID-22C65C80-42A1-4C8B-B883-19EFDF7AA31C__GUID-FA5E61C6-5C4B-4E1D-8ECE-290AF3ED8F0F">在输入上</p>
                  </div>
                  <!-- class="section" -->
                  <div class="section">
                     <p>程序可以赋给指标变量的值具有以下含义：</p>
                     <div class="tblformal" id="GUID-22C65C80-42A1-4C8B-B883-19EFDF7AA31C__GUID-EC9F1503-AFEC-46E0-9500-33EF29B17CE3">
                        <table cellpadding="4" cellspacing="0" class="Formal" title="" width="100%" border="1" summary="Variables" frame="hsides" rules="rows">
                           <thead>
                              <tr align="left" valign="top">
                                 <th align="left" valign="bottom" width="29%" id="d30526e245">变量</th>
                                 <th align="left" valign="bottom" width="71%" id="d30526e248">描述</th>
                              </tr>
                           </thead>
                           <tbody>
                              <tr align="left" valign="top">
                                 <td align="left" valign="top" width="29%" id="d30526e253" headers="d30526e245 ">
                                    <p>-1</p>
                                 </td>
                                 <td align="left" valign="top" width="71%" headers="d30526e253 d30526e248 ">
                                    <p>Oracle将为列分配NULL，忽略主机变量的值。</p>
                                 </td>
                              </tr>
                              <tr align="left" valign="top">
                                 <td align="left" valign="top" width="29%" id="d30526e260" headers="d30526e245 ">
                                    <p>&gt; = 0</p>
                                 </td>
                                 <td align="left" valign="top" width="71%" headers="d30526e260 d30526e248 ">
                                    <p>Oracle会将主机变量的值分配给列。</p>
                                 </td>
                              </tr>
                           </tbody>
                        </table>
                     </div>
                     <!-- class="inftblhruleinformal" -->
                  </div>
                  <!-- class="section" -->
                  <div class="section">
                     <p class="subhead2" id="GUID-22C65C80-42A1-4C8B-B883-19EFDF7AA31C__GUID-A4ECAC5A-C258-4678-80FA-2DF8A151D754">关于输出</p>
                  </div>
                  <!-- class="section" -->
                  <div class="section">
                     <p>Oracle可以分配给指标变量的值具有以下含义：</p>
                     <div class="tblformal" id="GUID-22C65C80-42A1-4C8B-B883-19EFDF7AA31C__GUID-498465C5-100D-4E77-B258-4D650A0EFADD">
                        <table cellpadding="4" cellspacing="0" class="Formal" title="" width="100%" border="1" summary="variables" frame="hsides" rules="rows">
                           <thead>
                              <tr align="left" valign="top">
                                 <th align="left" valign="bottom" width="29%" id="d30526e280">变量</th>
                                 <th align="left" valign="bottom" width="71%" id="d30526e284">描述</th>
                              </tr>
                           </thead>
                           <tbody>
                              <tr align="left" valign="top">
                                 <td align="left" valign="top" width="29%" id="d30526e289" headers="d30526e280 ">
                                    <p>-1</p>
                                 </td>
                                 <td align="left" valign="top" width="71%" headers="d30526e289 d30526e284 ">
                                    <p>列值为NULL，因此宿主变量的值是不确定的。</p>
                                 </td>
                              </tr>
                              <tr align="left" valign="top">
                                 <td align="left" valign="top" width="29%" id="d30526e296" headers="d30526e280 ">
                                    <p>0</p>
                                 </td>
                                 <td align="left" valign="top" width="71%" headers="d30526e296 d30526e284 ">
                                    <p>Oracle为主变量分配了完整的列值。</p>
                                 </td>
                              </tr>
                              <tr align="left" valign="top">
                                 <td align="left" valign="top" width="29%" id="d30526e303" headers="d30526e280 ">
                                    <p>&gt; 0</p>
                                 </td>
                                 <td align="left" valign="top" width="71%" headers="d30526e303 d30526e284 ">
                                    <p>Oracle为主变量分配了截断的列值。指示符变量返回的整数是列值的原始长度，SQLCA中的SQLCODE设置为零。</p>
                                 </td>
                              </tr>
                              <tr align="left" valign="top">
                                 <td align="left" valign="top" width="29%" id="d30526e310" headers="d30526e280 ">
                                    <p>-2</p>
                                 </td>
                                 <td align="left" valign="top" width="71%" headers="d30526e310 d30526e284 ">
                                    <p>Oracle将截断的列变量分配给主变量，但无法确定原始列值（例如，LONG列）。</p>
                                 </td>
                              </tr>
                           </tbody>
                        </table>
                     </div>
                     <!-- class="inftblhruleinformal" -->
                     <p>请记住，指示符变量必须定义为2字节整数，并且在SQL语句中，必须以冒号为前缀，并且必须紧跟其主变量。 <a id="d30526e318" class="indexterm-anchor"></a><a id="d30526e322" class="indexterm-anchor"></a><a id="d30526e326" class="indexterm-anchor"></a><a id="d30526e330" class="indexterm-anchor"></a><a id="d30526e334" class="indexterm-anchor"></a> 
                     </p>
                  </div>
                  <!-- class="section" -->
               </div><a id="LNPCC3345"></a><div class="props_rev_3"><a id="GUID-C19A3CDD-92FE-4F00-AEBB-6F14C477BEB6" name="GUID-C19A3CDD-92FE-4F00-AEBB-6F14C477BEB6"></a><h4 id="LNPCC-GUID-C19A3CDD-92FE-4F00-AEBB-6F14C477BEB6" class="sect4"><span class="enumeration_section">6.2.1</span>插入NULL</h4>
                  <div>
                     <p>您可以使用指示符变量来INSERT NULL。在INSERT之前，对于要为NULL的每个列，将相应的指示符变量设置为-1，如以下示例所示： <a id="d30526e350" class="indexterm-anchor"></a><a id="d30526e354" class="indexterm-anchor"></a> 
                     </p><pre class="oac_no_warn" dir="ltr">设置ind_comm = -1; EXEC SQL INSERT INTO emp（empno，comm）VALUES（：emp_number，：commission：ind_comm）;</pre><p>指示符变量<span class="italic">ind_comm</span>指定将NULL存储在COMM列中。
                     </p>
                     <p>您可以改为对NULL进行硬编码，如下所示： <a id="d30526e368" class="indexterm-anchor"></a> 
                     </p><pre class="oac_no_warn" dir="ltr">EXEC SQL INSERT INTO emp（empno，comm）VALUES（：emp_number，NULL）;</pre><p>虽然这不太灵活，但可能更具可读性。通常，您有条件地插入NULL，如下一个示例所示：</p><pre class="oac_no_warn" dir="ltr">printf（“输入员工编号，如果不可用则输入0：”）; scanf（“％d”，＆emp_number）; if（emp_number == 0）ind_empnum = -1;否则ind_empnum = 0; EXEC SQL INSERT INTO emp（empno，sal）VALUES（：emp_number：ind_empnum，：salary）;</pre></div>
               </div><a id="LNPCC3346"></a><div class="props_rev_3"><a id="GUID-EAF89001-C305-40CB-AB3F-B2401E41F890" name="GUID-EAF89001-C305-40CB-AB3F-B2401E41F890"></a><h4 id="LNPCC-GUID-EAF89001-C305-40CB-AB3F-B2401E41F890" class="sect4"><span class="enumeration_section">6.2.2</span>返回NULL</h4>
                  <div>
                     <p>您还可以使用指示符变量来处理返回的NULL，如以下示例所示： <a id="d30526e390" class="indexterm-anchor"></a><a id="d30526e394" class="indexterm-anchor"></a> 
                     </p><pre class="oac_no_warn" dir="ltr">EXEC SQL SELECT ename，sal，comm INTO：emp_name，：salary，：commission：ind_comm FROM emp WHERE empno =：emp_number; if（ind_comm == -1）pay = salary; / *佣金为NULL;忽略它* /否支付=工资+佣金;</pre></div>
               </div><a id="LNPCC3347"></a><div class="props_rev_3"><a id="GUID-1560EFD0-EF58-45B1-AF97-4110307D7501" name="GUID-1560EFD0-EF58-45B1-AF97-4110307D7501"></a><h4 id="LNPCC-GUID-1560EFD0-EF58-45B1-AF97-4110307D7501" class="sect4"><span class="enumeration_section">6.2.3</span>获取NULL</h4>
                  <div>
                     <p>当DBMS = V7或DBMS = V8时，如果将SELECT或FETCH NULL转换为与指示符变量无关的主变量，Oracle会发出以下错误消息：</p><pre class="oac_no_warn" dir="ltr">ORA-01405：获取的列值为NULL</pre></div>
                  <div>
                     <div class="relinfo">
                        <p><strong>相关话题</strong></p>
                        <ul>
                           <li><a href="precompiler-options.html#GUID-D85972A8-FA08-4BBC-B543-3F0BADBA0236">DBMS</a></li>
                        </ul>
                     </div>
                  </div>
                  
               </div><a id="LNPCC3348"></a><div class="props_rev_3"><a id="GUID-0B9CE29C-E139-450D-9973-7A2B36B42928" name="GUID-0B9CE29C-E139-450D-9973-7A2B36B42928"></a><h4 id="LNPCC-GUID-0B9CE29C-E139-450D-9973-7A2B36B42928" class="sect4"><span class="enumeration_section">6.2.4</span>测试NULL</h4>
                  <div>
                     <p>您可以在WHERE子句中使用指示符变量来测试NULL，如以下示例所示：</p><pre class="oac_no_warn" dir="ltr">EXEC SQL SELECT ename，sal INTO：emp_name ,: salary FROM emp WHERE：commission INDICATOR：ind_comm IS NULL ...
</pre><p>但是，您不能使用关系运算符来将NULL彼此或与其他值进行比较。例如，如果COMM列包含一个或多个NULL，则以下SELECT语句将失败： <a id="d30526e439" class="indexterm-anchor"></a><a id="d30526e443" class="indexterm-anchor"></a><a id="d30526e447" class="indexterm-anchor"></a><a id="d30526e451" class="indexterm-anchor"></a> 
                     </p><pre class="oac_no_warn" dir="ltr">EXEC SQL SELECT ename，sal INTO：emp_name，：salary FROM emp WHERE comm =：commission;</pre><p>下一个示例显示了当一些值可能为NULL时如何比较相等的值：</p><pre class="oac_no_warn" dir="ltr">EXEC SQL SELECT ename，sal INTO：emp_name ,: salary FROM emp WHERE（comm =：commission）OR（（comm IS NULL）AND（：commission INDICATOR：ind_comm IS NULL））;</pre></div>
               </div><a id="LNPCC3349"></a><div class="props_rev_3"><a id="GUID-E43563FD-F158-4A46-8769-DF2214A08E70" name="GUID-E43563FD-F158-4A46-8769-DF2214A08E70"></a><h4 id="LNPCC-GUID-E43563FD-F158-4A46-8769-DF2214A08E70" class="sect4"><span class="enumeration_section">6.2.5</span>截断值</h4>
                  <div>
                     <p>当DBMS = V7或V8时，如果SELECT或FETCH将截断的列值转换为与指示符变量无关的主变量，则会生成警告而不是错误。<a id="d30526e473" class="indexterm-anchor"></a></p>
                  </div>
               </div>
            </div><a id="LNPCC3350"></a><div class="props_rev_3"><a id="GUID-431532CF-1652-4EB6-AD2A-7E695744FADE" name="GUID-431532CF-1652-4EB6-AD2A-7E695744FADE"></a><h3 id="LNPCC-GUID-431532CF-1652-4EB6-AD2A-7E695744FADE" class="sect3"><span class="enumeration_section">6.3</span>基本SQL语句</h3>
               <div>
                  <p>可执行的SQL语句使您可以查询，操作和控制Oracle数据，以及创建，定义和维护Oracle对象，例如表，视图和索引。本章重点介绍查询和操作数据的语句。 <a id="d30526e489" class="indexterm-anchor"></a> 
                  </p>
                  <p>在执行INSERT，UPDATE或DELETE等数据操作语句时，除了设置任何输入主机变量的值之外，唯一需要考虑的是语句是成功还是失败。要找到答案，您只需查看SQLCA即可。 （执行任何SQL语句都会设置SQLCA变量。）您可以通过以下两种方式办理登机手续： <a id="d30526e496" class="indexterm-anchor"></a> 
                  </p>
                  <ul style="list-style-type:disc">
                     <li>
                        <p>使用WHENEVER语句进行隐式检查</p>
                     </li>
                     <li>
                        <p>显式检查SQLCA变量</p>
                     </li>
                  </ul>
                  <p>但是，在执行SELECT语句（查询）时，还必须处理它返回的数据行。查询可分为以下几类： <a id="d30526e510" class="indexterm-anchor"></a> 
                  </p>
                  <ul style="list-style-type:disc">
                     <li>
                        <p>不返回任何行的查询（即仅检查是否存在）</p>
                     </li>
                     <li>
                        <p>仅返回一行的查询</p>
                     </li>
                     <li>
                        <p>返回多行的查询</p>
                     </li>
                  </ul>
                  <p>返回多行的查询需要显式声明游标或使用<span class="italic">主机数组</span> （主机变量声明为数组）。 <a id="d30526e530" class="indexterm-anchor"></a><a id="d30526e535" class="indexterm-anchor"></a> 
                  </p>
                  <div class="infoboxnote" id="GUID-431532CF-1652-4EB6-AD2A-7E695744FADE__GUID-1C5997BA-6EDD-45DA-BCD5-2509DB898D3A">
                     <p class="notep1">注意：</p>
                     <p>主机阵列允许您处理行的“批次”。</p>
                  </div>
                  <p>本章假定使用标量主变量。</p>
                  <p>以下嵌入式SQL语句允许您查询和操作Oracle数据：</p>
                  <div class="tblformal" id="GUID-431532CF-1652-4EB6-AD2A-7E695744FADE__GUID-27C40AE6-5BE6-4CAE-ADF1-DA5BD62841D4">
                     <table cellpadding="4" cellspacing="0" class="Formal" title="" width="100%" border="1" summary="Embedded SQL statements" frame="hsides" rules="rows">
                        <thead>
                           <tr align="left" valign="top">
                              <th align="left" valign="bottom" width="29%" id="d30526e555">嵌入式SQL语句</th>
                              <th align="left" valign="bottom" width="71%" id="d30526e558">描述</th>
                           </tr>
                        </thead>
                        <tbody>
                           <tr align="left" valign="top">
                              <td align="left" valign="top" width="29%" id="d30526e563" headers="d30526e555 ">
                                 <p>选择</p>
                              </td>
                              <td align="left" valign="top" width="71%" headers="d30526e563 d30526e558 ">
                                 <p>返回一个或多个表中的行。</p>
                              </td>
                           </tr>
                           <tr align="left" valign="top">
                              <td align="left" valign="top" width="29%" id="d30526e570" headers="d30526e555 ">
                                 <p>插入</p>
                              </td>
                              <td align="left" valign="top" width="71%" headers="d30526e570 d30526e558 ">
                                 <p>向表中添加新行。</p>
                              </td>
                           </tr>
                           <tr align="left" valign="top">
                              <td align="left" valign="top" width="29%" id="d30526e577" headers="d30526e555 ">
                                 <p>UPDATE</p>
                              </td>
                              <td align="left" valign="top" width="71%" headers="d30526e577 d30526e558 ">
                                 <p>修改表中的行。</p>
                              </td>
                           </tr>
                           <tr align="left" valign="top">
                              <td align="left" valign="top" width="29%" id="d30526e584" headers="d30526e555 ">
                                 <p>删除</p>
                              </td>
                              <td align="left" valign="top" width="71%" headers="d30526e584 d30526e558 ">
                                 <p>从表中删除不需要的行。</p>
                              </td>
                           </tr>
                        </tbody>
                     </table>
                  </div>
                  <!-- class="inftblhruleinformal" -->
                  <p>以下嵌入式SQL语句允许您定义和操作显式游标：</p>
                  <div class="tblformal" id="GUID-431532CF-1652-4EB6-AD2A-7E695744FADE__GUID-427C3849-3DED-42EA-A988-61E22AFACDE2">
                     <table cellpadding="4" cellspacing="0" class="Formal" title="" width="100%" border="1" summary="Embedded SQL statements" frame="hsides" rules="rows">
                        <thead>
                           <tr align="left" valign="top">
                              <th align="left" valign="bottom" width="29%" id="d30526e601">嵌入式SQL语句</th>
                              <th align="left" valign="bottom" width="71%" id="d30526e604">描述</th>
                           </tr>
                        </thead>
                        <tbody>
                           <tr align="left" valign="top">
                              <td align="left" valign="top" width="29%" id="d30526e609" headers="d30526e601 ">
                                 <p>宣布</p>
                              </td>
                              <td align="left" valign="top" width="71%" headers="d30526e609 d30526e604 ">
                                 <p>命名游标并将其与查询相关联。</p>
                              </td>
                           </tr>
                           <tr align="left" valign="top">
                              <td align="left" valign="top" width="29%" id="d30526e616" headers="d30526e601 ">
                                 <p>打开</p>
                              </td>
                              <td align="left" valign="top" width="71%" headers="d30526e616 d30526e604 ">
                                 <p>执行查询并标识活动集。</p>
                              </td>
                           </tr>
                           <tr align="left" valign="top">
                              <td align="left" valign="top" width="29%" id="d30526e623" headers="d30526e601 ">
                                 <p>取</p>
                              </td>
                              <td align="left" valign="top" width="71%" headers="d30526e623 d30526e604 ">
                                 <p>前进游标并逐个检索活动集中的每一行。</p>
                              </td>
                           </tr>
                           <tr align="left" valign="top">
                              <td align="left" valign="top" width="29%" id="d30526e630" headers="d30526e601 ">
                                 <p>关</p>
                              </td>
                              <td align="left" valign="top" width="71%" headers="d30526e630 d30526e604 ">
                                 <p>禁用游标（活动集变为未定义）。</p>
                              </td>
                           </tr>
                        </tbody>
                     </table>
                  </div>
                  <!-- class="inftblhruleinformal" -->
                  <p><a id="d30526e637" class="indexterm-anchor"></a>以下部分首先介绍如何编写INSERT，UPDATE，DELETE和单行SELECT语句的代码。然后，您将进入多行SELECT语句。
                  </p>
               </div>
               <div>
                  <div class="relinfo">
                     <p><strong>相关话题</strong></p>
                     <ul>
                        <li><a href="handling-run-time-errors.html#GUID-1ADFD2EB-B332-4362-9A85-F56FEDD4F72A">处理运行时错误</a></li>
                        <li><a href="host-arrays.html#GUID-6B57FBAE-0303-41B9-9056-5C20384442B7">主机阵列</a></li>
                        <li><a href="embedded-SQL-statements-and-directives.html#GUID-0ABBFB3E-F2BA-4906-8DEF-53EA78D758B5">嵌入式SQL语句和指令</a></li>
                        <li><a href="../sqlrf/index.html" target="_blank"><span><cite>Oracle数据库SQL语言参考</cite></span></a></li>
                     </ul>
                  </div>
               </div><a id="LNPCC3351"></a><div class="props_rev_3"><a id="GUID-F5BFD130-7C06-447A-965C-D0D76A9EDC21" name="GUID-F5BFD130-7C06-447A-965C-D0D76A9EDC21"></a><h4 id="LNPCC-GUID-F5BFD130-7C06-447A-965C-D0D76A9EDC21" class="sect4"><span class="enumeration_section">6.3.1</span> SELECT语句</h4>
                  <div>
                     <p>查询数据库是一种常见的SQL操作。要发出查询，请使用SELECT语句。在以下示例中，您将查询EMP表： <a id="d30526e679" class="indexterm-anchor"></a><a id="d30526e683" class="indexterm-anchor"></a><a id="d30526e687" class="indexterm-anchor"></a> 
                     </p><pre class="oac_no_warn" dir="ltr">EXEC SQL SELECT ename，job，sal + 2000 INTO：emp_name，：job_title，：salary FROM emp WHERE empno =：emp_number;</pre><p>关键字SELECT后面的列名和表达式构成<span class="italic">选择列表</span> 。我们示例中的选择列表包含三个项目。在WHERE子句（以及以下子句，如果存在）中指定的条件下，Oracle将列值返回到INTO子句中的主变量。 <a id="d30526e697" class="indexterm-anchor"></a><a id="d30526e701" class="indexterm-anchor"></a><a id="d30526e705" class="indexterm-anchor"></a><a id="d30526e709" class="indexterm-anchor"></a><a id="d30526e713" class="indexterm-anchor"></a> 
                     </p>
                     <p>选择列表中的项目数应该等于INTO子句中的主机变量数，因此可以存储每个返回的值。 <a id="d30526e720" class="indexterm-anchor"></a> 
                     </p>
                     <p>在最简单的情况下，当查询返回一行时，其形式如上一个示例所示。但是，如果查询可以返回多行，则必须使用游标对行进行FETCH或将它们选择为主机变量数组。游标和FETCH语句将在本章后面讨论。</p>
                     <p>如果编写查询只返回一行但实际上可能返回多行，则SELECT的结果是不确定的。这是否会导致错误取决于您指定SELECT_ERROR选项的方式。如果返回多行，则默认值YES会生成错误。 <a id="d30526e729" class="indexterm-anchor"></a><a id="d30526e733" class="indexterm-anchor"></a> 
                     </p>
                  </div>
                  <div>
                     <div class="relinfo">
                        <p><strong>相关话题</strong></p>
                        <ul>
                           <li><a href="embedded-PL-SQL.html#GUID-4C56DC0E-B857-405D-B88E-93B19DD9FCF2">主机阵列</a></li>
                        </ul>
                     </div>
                  </div>
                  <a id="LNPCC3352"></a><div class="props_rev_3"><a id="GUID-0E4E7CD9-6451-4C24-85E4-B7CF5E5AD592" name="GUID-0E4E7CD9-6451-4C24-85E4-B7CF5E5AD592"></a><h5 id="LNPCC-GUID-0E4E7CD9-6451-4C24-85E4-B7CF5E5AD592" class="sect5"><span class="enumeration_section">6.3.1.1</span>可用条款</h5>
                     <div>
                        <p>您可以使用以下所有标准SQL子句</p>
                        <p>SELECT语句： <a id="d30526e760" class="indexterm-anchor"></a> 
                        </p>
                        <ul style="list-style-type:disc">
                           <li>
                              <p>INTO</p>
                           </li>
                           <li>
                              <p>从</p>
                           </li>
                           <li>
                              <p>哪里</p>
                           </li>
                           <li>
                              <p>连接</p>
                           </li>
                           <li>
                              <p>从...开始</p>
                           </li>
                           <li>
                              <p>通过...分组</p>
                           </li>
                           <li>
                              <p>HAVING</p>
                           </li>
                           <li>
                              <p>订购</p>
                           </li>
                           <li>
                              <p>更新</p>
                           </li>
                        </ul>
                        <p>除INTO子句外，可以使用SQL * Plus以交互方式执行和测试嵌入式SELECT语句的文本。在SQL * Plus中，您使用替换变量或常量而不是输入主机变量。 <a id="d30526e795" class="indexterm-anchor"></a><a id="d30526e799" class="indexterm-anchor"></a> 
                        </p>
                     </div>
                  </div>
               </div><a id="LNPCC3353"></a><div class="props_rev_3"><a id="GUID-5EED62A3-6FEE-4B0C-A6B5-B65D9206C51B" name="GUID-5EED62A3-6FEE-4B0C-A6B5-B65D9206C51B"></a><h4 id="LNPCC-GUID-5EED62A3-6FEE-4B0C-A6B5-B65D9206C51B" class="sect4"><span class="enumeration_section">6.3.2</span> INSERT语句</h4>
                  <div>
                     <p>使用INSERT语句向表或视图添加行。在以下示例中，您向EMP表添加一行： <a id="d30526e816" class="indexterm-anchor"></a><a id="d30526e820" class="indexterm-anchor"></a> 
                     </p><pre class="oac_no_warn" dir="ltr">EXEC SQL INSERT INTO emp（empno，ename，sal，deptno）VALUES（：emp_number，：emp_name，：salary，：dept_number）;</pre><p>您在<span class="italic">列列表中</span>指定的每个列都必须属于INTO子句中指定的表。VALUES子句指定要插入的值行。值可以是常量，主变量，SQL表达式，SQL函数（如USER和SYSDATE）或用户定义的PL / SQL函数。
                     </p>
                     <p>VALUES子句中的值数必须等于列列表中的名称数。但是，如果VALUES子句包含表中每列的值（按表中定义的顺序），则可以省略列列表。<a id="d30526e834" class="indexterm-anchor"></a><a id="d30526e838" class="indexterm-anchor"></a><a id="d30526e842" class="indexterm-anchor"></a><a id="d30526e846" class="indexterm-anchor"></a><a id="d30526e850" class="indexterm-anchor"></a><a id="d30526e854" class="indexterm-anchor"></a><a id="d30526e858" class="indexterm-anchor"></a><a id="d30526e862" class="indexterm-anchor"></a></p>
                  </div>
                  <div>
                     <div class="relinfo">
                        <p><strong>相关话题</strong></p>
                        <ul>
                           <li><a href="embedded-SQL-statements-and-directives.html#GUID-EEF8462A-C5BE-46C8-AB35-700C748AAD96">INSERT（可执行嵌入式SQL）</a></li>
                        </ul>
                     </div>
                  </div>
                  <a id="LNPCC3354"></a><div class="props_rev_3"><a id="GUID-6C61194D-E824-47F8-B246-30C9045B815F" name="GUID-6C61194D-E824-47F8-B246-30C9045B815F"></a><h5 id="LNPCC-GUID-6C61194D-E824-47F8-B246-30C9045B815F" class="sect5"><span class="enumeration_section">6.3.2.1</span>关于使用子查询</h5>
                     <div>
                        <p><span class="italic">子查询</span>是嵌套的SELECT语句。子查询允许您进行多部分搜索。他们可以习惯<a id="d30526e889" class="indexterm-anchor"></a><a id="d30526e893" class="indexterm-anchor"></a> 
                        </p>
                        <ul style="list-style-type:disc">
                           <li>
                              <p>提供SELECT，UPDATE和DELETE语句的WHERE，HAVING和START WITH子句中的比较值</p>
                           </li>
                           <li>
                              <p>定义要由CREATE TABLE或INSERT语句插入的行集</p>
                           </li>
                           <li>
                              <p>定义UPDATE语句的SET子句的值</p>
                           </li>
                        </ul>
                        <p>以下示例使用INSERT语句中的子查询将行从一个表复制到另一个表： <a id="d30526e910" class="indexterm-anchor"></a><a id="d30526e914" class="indexterm-anchor"></a><a id="d30526e918" class="indexterm-anchor"></a> 
                        </p><pre class="oac_no_warn" dir="ltr">EXEC SQL INSERT INTO emp2（empno，ename，sal，deptno）SELECT empno，ename，sal，deptno FROM emp <a id="d30526e925" class="indexterm-anchor"></a><a id="d30526e929" class="indexterm-anchor"></a> WHERE job =：job_title;</pre><p>此INSERT语句使用子查询来获取中间结果。</p>
                     </div>
                  </div>
               </div><a id="LNPCC3355"></a><div class="props_rev_3"><a id="GUID-AA9A2949-19FA-44DD-865F-26B8371C35BF" name="GUID-AA9A2949-19FA-44DD-865F-26B8371C35BF"></a><h4 id="LNPCC-GUID-AA9A2949-19FA-44DD-865F-26B8371C35BF" class="sect4"><span class="enumeration_section">6.3.3</span>更新声明</h4>
                  <div>
                     <p>使用UPDATE语句更改表或视图中指定列的值。在以下示例中，我们更新<code class="codeph">EMP</code>表中的<code class="codeph">SAL</code>和<code class="codeph">COMM</code>列：</p><pre class="oac_no_warn" dir="ltr">EXEC SQL UPDATE emp SET sal =：salary，comm =：commission WHERE empno =：emp_number;</pre><p>使用可选的WHERE子句指定更新行的条件。 <a id="d30526e960" class="indexterm-anchor"></a><a id="d30526e964" class="indexterm-anchor"></a> 
                     </p>
                     <p>SET子句列出了必须为其提供值的一个或多个列的名称。您可以使用子查询来提供值，如以下示例所示： <a id="d30526e971" class="indexterm-anchor"></a><a id="d30526e975" class="indexterm-anchor"></a><a id="d30526e979" class="indexterm-anchor"></a><a id="d30526e983" class="indexterm-anchor"></a><a id="d30526e987" class="indexterm-anchor"></a><a id="d30526e991" class="indexterm-anchor"></a> 
                     </p><pre class="oac_no_warn" dir="ltr">EXEC SQL UPDATE emp SET sal =（SELECT AVG（sal）* 1.1 FROM emp WHERE deptno = 20）WHERE empno =：emp_number;</pre><p><a id="d30526e999" class="indexterm-anchor"></a> UPDATE语句有一个可选的<code class="codeph">returning clause</code> ，如INSERT和DELETE语句。只有在可选的WHERE条件之后才允许它。
                     </p>
                  </div>
                  <div>
                     <div class="relinfo">
                        <p><strong>相关话题</strong></p>
                        <ul>
                           <li><a href="embedded-SQL.html#GUID-F9163C22-9785-42F2-B3B5-24C2D90976DF">WHERE子句</a></li>
                           <li><a href="embedded-SQL-statements-and-directives.html#GUID-1B941180-02B8-483F-B2F9-4A7563494922">更新（可执行的嵌入式SQL）</a></li>
                        </ul>
                     </div>
                  </div>
                  
               </div><a id="LNPCC3356"></a><div class="props_rev_3"><a id="GUID-FF282C49-097A-468E-81B8-64D1B4C78D30" name="GUID-FF282C49-097A-468E-81B8-64D1B4C78D30"></a><h4 id="LNPCC-GUID-FF282C49-097A-468E-81B8-64D1B4C78D30" class="sect4"><span class="enumeration_section">6.3.4</span> DELETE语句</h4>
                  <div>
                     <p>使用DELETE语句从表或视图中删除行。在以下示例中，您将从EMP表中删除给定部门中的所有员工： <a id="d30526e1033" class="indexterm-anchor"></a><a id="d30526e1037" class="indexterm-anchor"></a> 
                     </p><pre class="oac_no_warn" dir="ltr">EXEC SQL DELETE FROM emp WHERE deptno =：dept_number;</pre><p>我们使用了可选的WHERE子句来指定删除行的条件。 <a id="d30526e1046" class="indexterm-anchor"></a><a id="d30526e1050" class="indexterm-anchor"></a>  
                     </p>
                     <p><a id="d30526e1056" class="indexterm-anchor"></a> <code class="codeph">returning clause</code>选项也可以在DELETE语句中使用。在可选的WHERE条件之后允许它。在前面的示例中，最好记录每个已删除员工的字段值。
                     </p>
                  </div>
                  <div>
                     <div class="relinfo">
                        <p><strong>相关话题</strong></p>
                        <ul>
                           <li><a href="embedded-SQL-statements-and-directives.html#GUID-3CBB8492-128D-4234-8172-FAB5B599A67E">DELETE（可执行嵌入式SQL）</a></li>
                        </ul>
                     </div>
                  </div>
                  
               </div><a id="LNPCC3357"></a><div class="props_rev_3"><a id="GUID-F9163C22-9785-42F2-B3B5-24C2D90976DF" name="GUID-F9163C22-9785-42F2-B3B5-24C2D90976DF"></a><h4 id="LNPCC-GUID-F9163C22-9785-42F2-B3B5-24C2D90976DF" class="sect4"><span class="enumeration_section">6.3.5</span> WHERE子句</h4>
                  <div>
                     <p>使用WHERE子句仅对表或视图中符合搜索条件的行进行SELECT，UPDATE或DELETE操作。WHERE子句<span class="italic">搜索条件</span>是一个布尔表达式，可以包括标量主变量，主机数组（不在SELECT语句中），子查询和用户定义的存储函数。 <a id="d30526e1088" class="indexterm-anchor"></a><a id="d30526e1092" class="indexterm-anchor"></a><a id="d30526e1096" class="indexterm-anchor"></a><a id="d30526e1100" class="indexterm-anchor"></a><a id="d30526e1104" class="indexterm-anchor"></a> 
                     </p>
                     <p>如果省略WHERE子句，则处理表或视图中的所有行。如果省略UPDATE或DELETE语句中的WHERE子句，Oracle <code class="codeph">sqlwarn[4]</code> SQLCA中的<code class="codeph">sqlwarn[4]</code>设置为“W”，以警告所有行都已处理。 <a id="d30526e1114" class="indexterm-anchor"></a> 
                     </p>
                  </div>
               </div>
            </div><a id="LNPCC3358"></a><div class="props_rev_3"><a id="GUID-A44FA873-61D5-42AF-A93E-1CA2041D9A3D" name="GUID-A44FA873-61D5-42AF-A93E-1CA2041D9A3D"></a><h3 id="LNPCC-GUID-A44FA873-61D5-42AF-A93E-1CA2041D9A3D" class="sect3"><span class="enumeration_section">6.4</span> DML返还条款</h3>
               <div>
                  <p>INSERT，UPDATE和DELETE语句可以有一个可选项<a id="d30526e1136" class="indexterm-anchor"></a> <span class="italic">DML</span> returns <span class="italic">子句</span> ，它将列值表达式<span class="italic">expr</span>返回到主变量<span class="italic">hv</span> ，带有主机指示变量<span class="italic">iv。</span> DML返回子句如下所示：</p><pre class="oac_no_warn" dir="ltr">{返回| RETURN} {expr [，expr]} INTO {：hv [[INDICATOR]：iv] [，：hv [[INDICATOR]：iv]]}</pre><p>表达式的数量必须等于主机变量的数量。此子句消除了在INSERT或UPDATE之后以及在您需要为应用程序记录该信息时在DELETE之前选择行的需要。<code class="codeph">returning clause</code>消除了低效的网络往返，额外处理和服务器内存。
                  </p>
                  <p>Oracle Dynamic SQL方法4不支持DML返回子句;但ANSI动态SQL方法4。ANSI DYNAMIC SQL不支持使用影响多行的DML返回子句的DML语句。</p>
               </div>
               <div>
                  <div class="relinfo">
                     <p><strong>相关话题</strong></p>
                     <ul>
                        <li><a href="ANSI-dynamic-SQL.html#GUID-BF450DA3-B05F-403E-B5DF-C967A20524BF">ANSI动态SQL</a></li>
                     </ul>
                  </div>
               </div>
               
            </div><a id="LNPCC3359"></a><div class="props_rev_3"><a id="GUID-E53CD1B7-9E49-44E0-89DA-9A567E7CD7A8" name="GUID-E53CD1B7-9E49-44E0-89DA-9A567E7CD7A8"></a><h3 id="LNPCC-GUID-E53CD1B7-9E49-44E0-89DA-9A567E7CD7A8" class="sect3"><span class="enumeration_section">6.5</span>游标</h3>
               <div>
                  <p>当查询返回多行时，您可以显式定义游标<a id="d30526e1181" class="indexterm-anchor"></a><a id="d30526e1185" class="indexterm-anchor"></a></p>
                  <ul style="list-style-type:disc">
                     <li>
                        <p>处理超出查询返回的第一行</p>
                     </li>
                     <li>
                        <p>跟踪当前正在处理的行</p>
                     </li>
                  </ul>
                  <p>或者，您可以使用主机阵列。</p>
                  <p>游标标识查询返回的行集中的当前行。这允许您的程序一次处理一行。以下语句允许您定义和操作游标： <a id="d30526e1200" class="indexterm-anchor"></a><a id="d30526e1204" class="indexterm-anchor"></a> 
                  </p>
                  <ul style="list-style-type:disc">
                     <li>
                        <p>DECLARE CURSOR</p>
                     </li>
                     <li>
                        <p>打开</p>
                     </li>
                     <li>
                        <p>取</p>
                     </li>
                     <li>
                        <p>关</p>
                     </li>
                  </ul>
                  <p>首先，使用DECLARE CURSOR语句命名游标并将其与查询相关联。 <a id="d30526e1224" class="indexterm-anchor"></a><a id="d30526e1228" class="indexterm-anchor"></a><a id="d30526e1232" class="indexterm-anchor"></a><a id="d30526e1236" class="indexterm-anchor"></a> 
                  </p>
                  <p>OPEN语句执行查询并标识满足查询搜索条件的所有行。这些行形成一个称为光标活动集的集合。打开游标后，您可以使用它来检索其关联查询返回的行。 <a id="d30526e1243" class="indexterm-anchor"></a><a id="d30526e1247" class="indexterm-anchor"></a> 
                  </p>
                  <p>逐个检索活动集的行（除非您使用主机数组）。您使用FETCH语句来检索活动集中的当前行。您可以重复执行FETCH，直到检索到所有行。 <a id="d30526e1254" class="indexterm-anchor"></a><a id="d30526e1258" class="indexterm-anchor"></a> 
                  </p>
                  <p>从活动集完成FETCHing行时，使用CLOSE语句禁用游标，并且活动集变为未定义。 <a id="d30526e1265" class="indexterm-anchor"></a><a id="d30526e1269" class="indexterm-anchor"></a> 
                  </p>
                  <p>以下部分介绍如何在应用程序中使用这些游标控制语句。</p>
               </div>
               <div>
                  <div class="relinfo">
                     <p><strong>相关话题</strong></p>
                     <ul>
                        <li><a href="embedded-PL-SQL.html#GUID-4C56DC0E-B857-405D-B88E-93B19DD9FCF2">主机阵列</a></li>
                     </ul>
                  </div>
               </div>
               <a id="LNPCC3360"></a><div class="props_rev_3"><a id="GUID-8B708FFD-6BAE-464E-A165-1DFB194B408C" name="GUID-8B708FFD-6BAE-464E-A165-1DFB194B408C"></a><h4 id="LNPCC-GUID-8B708FFD-6BAE-464E-A165-1DFB194B408C" class="sect4"><span class="enumeration_section">6.5.1</span> DECLARE CURSOR声明</h4>
                  <div>
                     <p>您可以使用DECLARE CURSOR语句通过为游标指定名称并将其与查询相关联来定义游标，如以下示例所示： <a id="d30526e1296" class="indexterm-anchor"></a><a id="d30526e1300" class="indexterm-anchor"></a><a id="d30526e1304" class="indexterm-anchor"></a> 
                     </p><pre class="oac_no_warn" dir="ltr">EXEC SQL DECLARE emp_cursor CURSOR FOR SELECT ename，empno，sal FROM emp WHERE deptno =：dept_number;</pre><p>游标名称是预编译器使用的标识符， <span class="italic">而不是</span>主机或程序变量，不应在声明部分中定义。因此，游标名称不能从一个预编译单元传递到另一个预编译单元。游标名称不能连字符。它们可以是任意长度，但只有前31个字符才有意义。对于ANSI兼容性，请使用不超过18个字符的游标名称。 <a id="d30526e1316" class="indexterm-anchor"></a><a id="d30526e1320" class="indexterm-anchor"></a> 
                     </p>
                     <p>提供预编译器选项CLOSE_ON_COMMIT以在命令行或配置文件中使用。当CLOSE_ON_COMMIT = YES时，任何未使用WITH HOLD子句声明的游标在COMMIT或ROLLBACK后关闭。<a id="d30526e1327" class="indexterm-anchor"></a><a id="d30526e1331" class="indexterm-anchor"></a></p>
                     <p>如果MODE的指定级别高于CLOSE_ON_COMMIT，则MODE优先。默认值为MODE = ORACLE，CLOSE_ON_COMMIT = NO。如果指定MODE = ANSI，则在COMMIT上将关闭不使用WITH HOLD子句的任何游标。应用程序将运行得更慢，因为游标已关闭并重新打开多次。当MODE = ANSI时设置CLOSE_ON_COMMIT = NO会导致性能提高。要查看MODE等宏选项如何影响微选项（如CLOSE_ON_COMMIT），请参阅<span class="q">“ <a href="precompiler-options.html#GUID-30E45A7E-6EDA-420E-BF53-9E52861BB708">选项值的优先顺序</a> ”</span> 。
                     </p>
                     <p>与游标关联的SELECT语句不能包含INTO子句。相反，INTO子句和输出主机变量列表是FETCH语句的一部分。 <a id="d30526e1344" class="indexterm-anchor"></a> 
                     </p>
                     <p>因为它是声明性的，所以DECLARE CURSOR语句必须在物理上（不仅仅是逻辑上）在引用游标的所有其他SQL语句之前。也就是说，不允许对游标的前向引用。在以下示例中，OPEN语句放错了位置： <a id="d30526e1351" class="indexterm-anchor"></a><a id="d30526e1355" class="indexterm-anchor"></a> 
                     </p><pre class="oac_no_warn" dir="ltr">...EXEC SQL OPEN emp_cursor; *  -  MISPLACED OPEN STATEMENT EXEC SQL DECLARE emp_cursor CURSOR FOR SELECT ename，empno，sal FROM emp WHERE ename =：emp_name;</pre><p>游标控制语句（DECLARE，OPEN，FETCH，CLOSE）必须全部出现在同一预编译单元中。例如，您不能在文件A中声明游标，然后在文件B中打开它。 <a id="d30526e1364" class="indexterm-anchor"></a><a id="d30526e1368" class="indexterm-anchor"></a> 
                     </p>
                     <p>您的宿主程序可以根据需要DECLARE尽可能多的游标。但是，在给定文件中，每个DECLARE语句都必须是唯一的。也就是说，您不能在一个预编译单元中使用相同的名称来声明两个游标，即使是跨块或过程也是如此，因为游标的范围在文件中是全局的。 <a id="d30526e1375" class="indexterm-anchor"></a><a id="d30526e1379" class="indexterm-anchor"></a> 
                     </p>
                     <p> <a id="d30526e1386" class="indexterm-anchor"></a>对于MODE = ANSI或CLOSE_ON_COMMIT = YES的用户，可以在DECLARE部分中使用WITH HOLD子句来覆盖由这两个选项定义的行为。设置这些选项后，将在发出COMMIT时关闭所有游标的行为。由于重新打开游标以继续处理的开销，这可能会对性能产生影响。仔细使用WITH HOLD可以加速在大多数方面需要符合ANSI标准的预编译程序。
                     </p>
                     <p>如果您将使用多个游标，则可能需要指定MAXOPENCURSORS选项。</p>
                  </div>
                  <div>
                     <div class="relinfo">
                        <p><strong>相关话题</strong></p>
                        <ul>
                           <li><a href="database-concepts.html#GUID-D244BF2E-4CC6-4353-9C8F-F7035DB2EE28">DECLARE CURSOR语句中的WITH HOLD子句</a></li>
                           <li><a href="precompiler-options.html#GUID-198ADD9B-90D5-4562-AD98-5BCF25216CF2">CLOSE_ON_COMMIT</a></li>
                           <li><a href="precompiler-options.html#GUID-FC726DCD-2AAE-4A4B-A293-C8C23382A9B5">预编译器选项</a></li>
                           <li><a href="performance-tuning.html#GUID-70BC5747-18C2-4017-AC44-500891008097">性能调优</a></li>
                        </ul>
                     </div>
                  </div>
                  
               </div><a id="LNPCC3361"></a><div class="props_rev_3"><a id="GUID-52B5D251-CEE1-44C8-A1CF-B52ABFF28460" name="GUID-52B5D251-CEE1-44C8-A1CF-B52ABFF28460"></a><h4 id="LNPCC-GUID-52B5D251-CEE1-44C8-A1CF-B52ABFF28460" class="sect4"><span class="enumeration_section">6.5.2</span> OPEN声明</h4>
                  <div>
                     <p>您使用OPEN语句来执行查询并识别活动集。在以下示例中，您将打开名为<span class="italic">emp_cursor</span>的游标： <a id="d30526e1436" class="indexterm-anchor"></a><a id="d30526e1440" class="indexterm-anchor"></a> 
                     </p><pre class="oac_no_warn" dir="ltr">EXEC SQL OPEN emp_cursor;</pre><p>OPEN将SQLCA中SQLERRD的第三个元素保留的行处理计数归零。但是，此时应用程序不会看到任何行。这由FETCH语句处理。</p>
                     <p>OPEN将光标定位在活动集的第一行之前。它还将SQLCA中SQLERRD的第三个元素保留的行处理计数归零。但是，此时实际上没有检索到任何行。这将由FETCH语句完成。 <a id="d30526e1451" class="indexterm-anchor"></a> 
                     </p>
                     <p>打开游标后，在重新打开游标之前，不会重新检查查询的输入主变量。因此，活动集不会改变。要更改活动集，必须重新打开光标。 <a id="d30526e1458" class="indexterm-anchor"></a><a id="d30526e1462" class="indexterm-anchor"></a> 
                     </p>
                     <p>通常，您应该在重新打开之前关闭游标。但是，如果指定MODE = ORACLE（默认值），则无需在重新打开游标之前关闭游标。这可以提高性能。</p>
                     <p>OPEN完成的工作量取决于三个预编译器选项的值：HOLD_CURSOR，RELEASE_CURSOR和MAXOPENCURSORS。</p>
                  </div>
                  <div>
                     <div class="relinfo">
                        <p><strong>相关话题</strong></p>
                        <ul>
                           <li><a href="precompiler-options.html#GUID-1FB02C5F-DCC0-453C-A6AB-246421712F74">关于使用预编译器选项</a></li>
                        </ul>
                     </div>
                  </div>
                  
               </div><a id="LNPCC3362"></a><div class="props_rev_3"><a id="GUID-7FF86597-BB63-40C2-BFE4-09C618672EBA" name="GUID-7FF86597-BB63-40C2-BFE4-09C618672EBA"></a><h4 id="LNPCC-GUID-7FF86597-BB63-40C2-BFE4-09C618672EBA" class="sect4"><span class="enumeration_section">6.5.3</span> FETCH声明</h4>
                  <div>
                     <p>您可以使用FETCH语句从活动集中检索行，并指定将包含结果的输出主机变量。回想一下，与游标关联的SELECT语句不能包含INTO子句。相反，INTO子句和输出主机变量列表是FETCH语句的一部分。在以下示例中，您将FETCH INTO三个主机变量： <a id="d30526e1491" class="indexterm-anchor"></a><a id="d30526e1495" class="indexterm-anchor"></a><a id="d30526e1499" class="indexterm-anchor"></a><a id="d30526e1503" class="indexterm-anchor"></a> 
                     </p><pre class="oac_no_warn" dir="ltr">EXEC SQL FETCH emp_cursor INTO：emp_name，：emp_number，：salary;</pre><p>游标必须先前已被DECLAREd和OPENed。第一次执行FETCH时，光标从活动集中的第一行之前移动到第一行。该行成为当前行。FETCH的每次后续执行都会将光标前进到活动集中的下一行，从而更改当前行。光标只能在活动集中向前移动。要返回已经被FETCHed的行，必须重新打开光标，然后在活动集的第一行再次开始。 <a id="d30526e1512" class="indexterm-anchor"></a><a id="d30526e1516" class="indexterm-anchor"></a><a id="d30526e1520" class="indexterm-anchor"></a><a id="d30526e1524" class="indexterm-anchor"></a> 
                     </p>
                     <p>如果要更改活动集，则必须将新值分配给与游标关联的查询中的输入主机变量，然后重新打开游标。当MODE = ANSI时，必须在重新打开之前关闭光标。 <a id="d30526e1531" class="indexterm-anchor"></a> 
                     </p>
                     <p>如下一个示例所示，您可以使用不同的输出主机变量集从同一个游标进行FETCH。但是，每个FETCH语句的INTO子句中的相应主机变量必须具有相同的数据类型。</p><pre class="oac_no_warn" dir="ltr">EXEC SQL DECLARE emp_cursor CURSOR FOR SELECT ename，sal FROM emp WHERE deptno = 20; ...EXEC SQL OPEN emp_cursor; EXEC SQL WHENEVER未找到GOTO ......for（;;）{EXEC SQL FETCH emp_cursor INTO：emp_name1，：salary1; EXEC SQL FETCH emp_cursor INTO：emp_name2，：salary2; EXEC SQL FETCH emp_cursor INTO：emp_name3，：salary3; ...}</pre><p>如果活动集为空或不包含更多行，则FETCH将“找不到数据”错误代码返回到SQLCA中的<span class="italic">sqlcode</span> ，或SQLCODE或SQLSTATE状态变量。输出主机变量的状态是不确定的。（在典型程序中，WHENEVER NOT FOUND语句检测到此错误。）要重用光标，必须重新打开它。 <a id="d30526e1545" class="indexterm-anchor"></a><a id="d30526e1549" class="indexterm-anchor"></a>  
                     </p>
                     <p>在以下条件下，游标上的FETCH是错误的：</p>
                     <ul style="list-style-type:disc">
                        <li>
                           <p>在打开光标之前</p>
                        </li>
                        <li>
                           <p>在“没有数据发现”的情况下</p>
                        </li>
                        <li>
                           <p>关闭它之后</p>
                        </li>
                     </ul>
                  </div>
               </div><a id="LNPCC3363"></a><div class="props_rev_3"><a id="GUID-F7148B26-C699-4924-8C18-A5451F199A11" name="GUID-F7148B26-C699-4924-8C18-A5451F199A11"></a><h4 id="LNPCC-GUID-F7148B26-C699-4924-8C18-A5451F199A11" class="sect4"><span class="enumeration_section">6.5.4</span> CLOSE声明</h4>
                  <div>
                     <p>当从活动集完成FETCHing行时，您关闭游标以释放通过打开游标获取的资源，例如存储。关闭游标时，将释放解析锁。释放的资源取决于您指定HOLD_CURSOR和RELEASE_CURSOR选项的方式。在以下示例中，您将关闭名为<span class="italic">emp_cursor</span>的游标： <a id="d30526e1580" class="indexterm-anchor"></a><a id="d30526e1584" class="indexterm-anchor"></a><a id="d30526e1588" class="indexterm-anchor"></a> 
                     </p><pre class="oac_no_warn" dir="ltr">EXEC SQL CLOSE emp_cursor;</pre><p>您无法从关闭的游标进行FETCH，因为其活动集未定义。如有必要，您可以重新打开游标（例如，输入主机变量的新值）。</p>
                     <p>当MODE = ORACLE时，发出COMMIT或ROLLBACK将关闭CURRENT OF子句中引用的游标。其他游标不受COMMIT或ROLLBACK的影响，如果打开，则保持打开状态。但是，当MODE = ANSI时，发出COMMIT或ROLLBACK会关闭<span class="italic">所有</span>显式游标。
                     </p>
                  </div>
                  <div>
                     <div class="relinfo">
                        <p><strong>相关话题</strong></p>
                        <ul>
                           <li><a href="database-concepts.html#GUID-54B5B0C8-CB28-4E84-A52C-F05CEBA92539">数据库概念</a></li>
                        </ul>
                     </div>
                  </div>
                  
               </div>
            </div><a id="LNPCC3364"></a><div class="props_rev_3"><a id="GUID-EE1C3E7B-AEE5-4514-9D57-36C71E35D829" name="GUID-EE1C3E7B-AEE5-4514-9D57-36C71E35D829"></a><h3 id="LNPCC-GUID-EE1C3E7B-AEE5-4514-9D57-36C71E35D829" class="sect3"><span class="enumeration_section">6.6可</span>滚动游标</h3>
               <div>
                  <p>可滚动游标是Oracle执行SQL语句并存储在执行期间处理的信息的工作区。</p>
                  <p>执行游标时，查询结果将放入一组称为结果集的行中。结果集可以按顺序或非顺序获取。非顺序结果集称为可滚动游标。</p>
                  <p>可滚动游标使用户能够以前向，后向和随机方式访问数据库结果集的行。这使程序能够获取结果集中的任何行。请参阅<span class="italic">Oracle调用接口程序员指南</span> 9.2.0版。
                  </p>
               </div><a id="LNPCC3365"></a><div class="props_rev_3"><a id="GUID-A492A864-B7B7-4154-A309-1759C16BFE57" name="GUID-A492A864-B7B7-4154-A309-1759C16BFE57"></a><h4 id="LNPCC-GUID-A492A864-B7B7-4154-A309-1759C16BFE57" class="sect4"><span class="enumeration_section">6.6.1</span>关于使用可滚动游标</h4>
                  <div>
                     <p>以下语句允许您定义和操作可滚动游标。</p>
                  </div><a id="LNPCC3366"></a><div class="props_rev_3"><a id="GUID-6454C7D0-C2B1-490E-A9EB-6C213E9824E8" name="GUID-6454C7D0-C2B1-490E-A9EB-6C213E9824E8"></a><h5 id="LNPCC-GUID-6454C7D0-C2B1-490E-A9EB-6C213E9824E8" class="sect5"><span class="enumeration_section">6.6.1.1</span> DECLARE SCROLL CURSOR</h5>
                     <div>
                        <p>您可以使用DECLARE &lt;游标名称&gt; SCROLL CURSOR语句来命名可滚动游标并将其与查询相关联。</p>
                     </div>
                  </div><a id="LNPCC3367"></a><div class="props_rev_3"><a id="GUID-DEAA1B55-99AF-4663-8D90-0030298737C5" name="GUID-DEAA1B55-99AF-4663-8D90-0030298737C5"></a><h5 id="LNPCC-GUID-DEAA1B55-99AF-4663-8D90-0030298737C5" class="sect5"><span class="enumeration_section">6.6.1.2</span>可滚动游标的OPEN</h5>
                     <div>
                        <p>您可以使用与不可滚动游标相同的方式使用OPEN语句。</p>
                     </div>
                  </div><a id="LNPCC3368"></a><div class="props_rev_3"><a id="GUID-4A83493B-A718-4D37-A1C5-35C0F1633B9F" name="GUID-4A83493B-A718-4D37-A1C5-35C0F1633B9F"></a><h5 id="LNPCC-GUID-4A83493B-A718-4D37-A1C5-35C0F1633B9F" class="sect5"><span class="enumeration_section">6.6.1.3</span>可滚动游标的FETCH</h5>
                     <div>
                        <p>您可以使用FETCH语句以随机方式获取所需的行。应用程序可以直接向上或向下获取行，第一行或最后一行，或以随机方式获取任何一行。</p>
                        <p>FETCH语句提供以下选项。</p>
                        <ol>
                           <li>
                              <p>FETCH FIRST</p>
                              <p>从结果集中获取第一行。</p>
                           </li>
                           <li>
                              <p>FETCH PRIOR</p>
                              <p>获取当前行之前的行。</p>
                           </li>
                           <li>
                              <p>FETCH NEXT</p>
                              <p>从当前位置获取下一行。这与不可滚动的游标FETCH相同。</p>
                           </li>
                           <li>
                              <p>FETCH LAST</p>
                              <p>从结果集中获取最后一行。</p>
                           </li>
                           <li>
                              <p>FETCH CURRENT</p>
                              <p>获取当前行。</p>
                           </li>
                           <li>
                              <p>FETCH RELATIVE <span class="italic">n</span> 
                              </p>
                              <p>取相对于当前行，其中<span class="italic">n</span>是偏移量的第<span class="italic">n</span>行。
                              </p>
                           </li>
                           <li>
                              <p>FETCH ABSOLUTE <span class="italic">n</span></p>
                              <p>获取第<span class="italic">n</span>行，其中<span class="italic">n</span>是结果集开头的偏移量。
                              </p>
                           </li>
                        </ol>
                        <p>以下示例描述如何从结果集中FETCH最后一条记录。</p><pre class="oac_no_warn" dir="ltr">EXEC SQL DECLARE emp_cursor用于SELECT ename的SCROLL CURSOR，sal FROM emp WHERE deptno = 20; ...EXEC SQL OPEN emp_cursor; EXEC SQL FETCH LAST emp_cursor INTO：emp_name，：sal; EXEC SQL CLOSE emp_cursor;</pre></div>
                  </div><a id="LNPCC3369"></a><div class="props_rev_3"><a id="GUID-6E4D1E96-351E-4CB8-8B96-45C98417C2F8" name="GUID-6E4D1E96-351E-4CB8-8B96-45C98417C2F8"></a><h5 id="LNPCC-GUID-6E4D1E96-351E-4CB8-8B96-45C98417C2F8" class="sect5"><span class="enumeration_section">6.6.1.4</span>关闭可滚动游标</h5>
                     <div>
                        <p>您可以使用CLOSE语句，方法与不可滚动游标的情况相同。</p>
                        <div class="infoboxnote" id="GUID-6E4D1E96-351E-4CB8-8B96-45C98417C2F8__GUID-C4852387-5ACD-4E60-B3B8-810B67DD23F5">
                           <p class="notep1">注意：</p>
                           <p>您不能将可滚动游标用于REF游标。</p>
                        </div>
                     </div>
                  </div>
               </div><a id="LNPCC3370"></a><div class="props_rev_3"><a id="GUID-7532E1DD-B2BF-4935-93AF-5413D02B2F54" name="GUID-7532E1DD-B2BF-4935-93AF-5413D02B2F54"></a><h4 id="LNPCC-GUID-7532E1DD-B2BF-4935-93AF-5413D02B2F54" class="sect4"><span class="enumeration_section">6.6.2</span> CLOSE_ON_COMMIT预编译器选项</h4>
                  <div>
                     <p>CLOSE_ON_COMMIT微预编译器选项提供了在执行COMMIT时选择是否关闭所有游标以及宏选项MODE = ANSI的功能。当MODE = ANSI时，CLOSE_ON_COMMIT具有默认值YES。显式设置CLOSE_ON_COMMIT = NO会带来更好的性能，因为执行COMMIT时不会关闭游标，无需重新打开游标并产生额外的解析。</p>
                  </div>
               </div><a id="LNPCC3371"></a><div class="props_rev_3"><a id="GUID-C8C8A9BF-DDC8-44D8-9DF8-87476A268EC9" name="GUID-C8C8A9BF-DDC8-44D8-9DF8-87476A268EC9"></a><h4 id="LNPCC-GUID-C8C8A9BF-DDC8-44D8-9DF8-87476A268EC9" class="sect4"><span class="enumeration_section">6.6.3</span> PREFETCH预编译器选项</h4>
                  <div>
                     <p>预编译器选项PREFETCH通过预取给定数量的行来允许更有效的查询。这减少了所需的服务器往返次数并减少了总体内存使用量。PREFETCH选项值设置的行数用于涉及显式游标的所有查询，受标准优先级规则的约束。在内联使用时，PREFETCH选项必须位于以下任何游标语句之前：</p>
                     <ul style="list-style-type:disc">
                        <li>
                           <p>EXEC SQL OPEN <span class="italic">游标</span></p>
                        </li>
                        <li>
                           <p>EXEC SQL OPEN <span class="italic">游标</span>使用<span class="italic">host_var_list</span></p>
                        </li>
                        <li>
                           <p>EXEC SQL OPEN <span class="italic">游标</span>使用DESCRIPTOR <span class="italic">desc_name</span></p>
                        </li>
                     </ul>
                     <p>执行OPEN时，PREFETCH的值给出执行查询时要预取的行数。您可以将值设置为0（无预取）到65535。默认值为1。</p>
                     <div class="infoboxnote" id="GUID-C8C8A9BF-DDC8-44D8-9DF8-87476A268EC9__GUID-2BAB62C1-9A91-4E6A-A386-2F31449220BD">
                        <p class="notep1">注意：</p>
                        <p>PREFETCH选项的默认值为1  - 每次往返返回一行。如果选择不使用PREFETCH选项，则必须使用命令行，通过将PREFETCH选项设置为0来显式禁用它。</p>
                        <p>检索LONG或LOB列时会自动禁用PREFETCH。</p>
                     </div>
                     <div class="infoboxnote" id="GUID-C8C8A9BF-DDC8-44D8-9DF8-87476A268EC9__GUID-5FFB8216-BFD9-4DBF-B4C7-20B5157537E6">
                        <p class="notep1">注意：</p>
                        <p>PREFETCH主要用于增强单行读取的性能。使用数组提取时，PREFETCH无效。</p>
                     </div>
                     <div class="infoboxnote" id="GUID-C8C8A9BF-DDC8-44D8-9DF8-87476A268EC9__GUID-48787400-709D-4AC6-AB88-26FC5FE6CDF2">
                        <p class="notep1">注意：</p>
                        <p>应明智地使用PREFETCH选项，并根据具体情况使用。选择适当的PREFETCH值，以优化特定FETCH语句的性能。要完成此操作，请使用内联预取选项而不是命令行预取选项。</p>
                     </div>
                     <div class="infoboxnote" id="GUID-C8C8A9BF-DDC8-44D8-9DF8-87476A268EC9__GUID-47928E09-90F6-4EC2-AD11-C5965F3B0ECD">
                        <p class="notep1">注意：</p>
                        <p>通过在FETCH语句中使用带有主变量的指示符变量，可以简化许多大型应用程序的性能。</p>
                        <p>要使预编译器应用程序在单行读取时使用PREFETCH选项获得最大优势，强烈建议您使用指示符变量。</p>
                     </div>
                  </div>
               </div>
            </div><a id="LNPCC3372"></a><div class="props_rev_3"><a id="GUID-F6C600D0-D49D-4C24-910E-A4153C8818CD" name="GUID-F6C600D0-D49D-4C24-910E-A4153C8818CD"></a><h3 id="LNPCC-GUID-F6C600D0-D49D-4C24-910E-A4153C8818CD" class="sect3"><span class="enumeration_section">6.7</span>优化器提示</h3>
               <div>
                  <p>Pro * C / C ++预编译器支持SQL语句中的优化器提示。<span class="italic">优化器提示</span>是对Oracle SQL优化器的建议，可以覆盖通常采用的优化方法。您可以使用提示来指定</p>
                  <ul style="list-style-type:disc">
                     <li>
                        <p>SQL语句的优化方法</p>
                     </li>
                     <li>
                        <p>每个引用表的访问路径</p>
                     </li>
                     <li>
                        <p>加入加入订单</p>
                     </li>
                     <li>
                        <p>用于连接表的方法</p>
                     </li>
                  </ul>
                  <p>提示允许您在基于规则和基于成本的优化之间进行选择。通过基于成本的优化，您可以使用进一步的提示来最大化吞吐量或响应时间。</p>
               </div><a id="LNPCC3373"></a><div class="props_rev_3"><a id="GUID-9A0463A4-8321-40DA-B6BB-78E0C1629E7C" name="GUID-9A0463A4-8321-40DA-B6BB-78E0C1629E7C"></a><h4 id="LNPCC-GUID-9A0463A4-8321-40DA-B6BB-78E0C1629E7C" class="sect4"><span class="enumeration_section">6.7.1</span>发布提示</h4>
                  <div>
                     <p>您可以在SELECT，DELETE或UPDATE命令之后立即在C或C ++样式注释中发出优化程序提示。您通过在注释开启器后面加上加号来指示注释包含一个或多个提示，在开启者和“+”之间不留空格。例如，以下语句使用ALL_ROWS提示让基于成本的方法优化语句以实现最佳吞吐量目标：</p><pre class="oac_no_warn" dir="ltr">EXEC SQL SELECT / * + ALL_ROWS（基于成本）* / empno，ename，sal，job INTO：emp_rec FROM emp WHERE deptno =：dept_number;</pre><p>如此语句所示，注释可以包含优化器提示以及其他注释。</p>
                  </div>
               </div>
            </div><a id="LNPCC3375"></a><a id="LNPCC3374"></a><div class="props_rev_3"><a id="GUID-BA6FB717-6577-45D7-87A9-ECC60FECD9AA" name="GUID-BA6FB717-6577-45D7-87A9-ECC60FECD9AA"></a><h3 id="LNPCC-GUID-BA6FB717-6577-45D7-87A9-ECC60FECD9AA" class="sect3"><span class="enumeration_section">6.8</span>修复执行计划</h3>
               <div>
                  <p>在一个环境中开发模块，然后集成并部署到另一个环境中的应用程序开发环境中，应用程序的性能会受到影响。有时，预编译器应用程序的性能会受到数据库环境变化的影响。这些可能包括优化程序统计信息的更改，优化程序设置的更改或影响内存结构大小的参数更改。</p>
                  <p>要在开发环境中修复Pro * C / C ++中使用的SQL的执行计划，您需要在预编译时使用Oracle的大纲功能。大纲实现为一组与SQL语句关联的优化程序提示。如果您为语句启用了大纲，Oracle会自动考虑存储的提示，并尝试根据这些提示生成执行计划。通过这种方式，您可以确保在将模块集成或部署到不同环境时不会影响性能。</p>
                  <p>您可以使用以下SQL语句在Pro * C / C ++中创建轮廓：</p>
                  <ul style="list-style-type:disc">
                     <li>
                        <p><code class="codeph">选择</code></p>
                     </li>
                     <li>
                        <p><code class="codeph">删除</code></p>
                     </li>
                     <li>
                        <p><code class="codeph">UPDATE</code></p>
                     </li>
                     <li>
                        <p><code class="codeph">插入 ...选择</code></p>
                     </li>
                     <li>
                        <p><code class="codeph">创建表...选择</code></p>
                     </li>
                  </ul>
                  <p>如果设置了outline选项，则预编译器会在成功预编译结束时生成两个文件，一个SQL文件和一个LOG文件。命令行选项<code class="codeph">outline</code>和<code class="codeph">outlnprefix</code>控制<code class="codeph">outline</code>的生成。
                  </p>
                  <p>每个生成的大纲名称都是唯一的由于应用程序中使用的文件名是唯一的，因此此信息用于生成大纲名称。此外，类别名称也是前缀。</p>
                  <div class="infoboxnote" id="GUID-BA6FB717-6577-45D7-87A9-ECC60FECD9AA__GUID-F13DF40D-4FCD-48ED-83E9-860AB54AA8BC">
                     <p class="notep1">警告：</p>
                     <p>Oracle仅允许128个字节的大纲名称。如果超出限制，预编译器将标记错误。您可以使用<code class="codeph">outlnprefix</code>选项限制大纲名称的长度。
                     </p>
                  </div>
                  <div class="example" id="GUID-BA6FB717-6577-45D7-87A9-ECC60FECD9AA__GUID-25EFF081-46E9-43CA-9BE0-D62B9BF457F2">
                     <p class="titleinexample">示例6-1生成包含轮廓的SQL文件</p>
                     <p>您需要使用outline选项预编译以下程序，以生成包含此程序中所有支持大纲的SQL语句的大纲的SQL文件。</p><pre class="oac_no_warn" dir="ltr">/ * * outlndemo.pc * *将为以下SQL操作创建轮廓，* 1。创建 ...SELECT * 2。插入 ...SELECT * 3。更新* 4。删除* 5。SELECT * / #include &lt;stdio.h&gt; #include &lt;string.h&gt; #include &lt;stdlib.h&gt; #include &lt;sqlda.h&gt; #include &lt;sqlcpr.h&gt; #include &lt;sqlca.h&gt; / *错误处理函数。* / void sql_error（char * msg）{exec sql每当sqlerror继续; printf（“\ n％s \ n”，msg）; printf（“％。70s \ n”，sqlca.sqlerrm.sqlerrmc）; exec sql rollback release;出口（EXIT_FAILURE）; } int main（）{varchar ename [10]; varchar job [9]; float sal，comm; exec sql begin declare section; char * uid =“scott / tiger”; exec sql end declare section; exeler sql每当sqlerror执行sql_error（“ORACLE error  -  \ n”）; exec sql connect：uid; exec sql insert into bonus select ename，job，sal，comm from emp where where'SALESMAN'; exec sql update bonus set sal = sal * 1.1其中sal &lt;1500; exec sql声明c1游标，用于选择ename，job，sal，comm来自sal的奖励顺序; exec sql open c1; printf（“更新的BONUS表的内容\ n \ n”）; printf（“ENAME JOB SALARY COMMISSION \ n \ n”）; exec sql什么都没找到做破坏; while（1）{exec sql fetch c1 into：ename，：job，：sal，：comm; ename.arr [ename.len] = '\ 0'; job.arr [job.len] = '\ 0'; printf（“％-9s％-9s％8.2f％8.2f \ n”，ename.arr，job.arr，sal，comm）; } exec sql close c1; exec sql什么都没找到做sql_error（“ORACLE error  -  \ n”）; exec sql从奖金中删除; exec sql create table outlndemo_tab as select empno，ename，sal from emp where deptno = 10; / *不会为此DDL语句创建大纲* / exec sql drop table outlndemo_tab; exec sql rollback工作版;出口（EXIT_SUCCESS）; }</pre></div>
                  <!-- class="example" -->
               </div><a id="LNPCC3377"></a><a id="LNPCC3376"></a><div class="props_rev_3"><a id="GUID-04D280DC-CE7E-4CC6-9D9A-98377F9ADFA2" name="GUID-04D280DC-CE7E-4CC6-9D9A-98377F9ADFA2"></a><h4 id="LNPCC-GUID-04D280DC-CE7E-4CC6-9D9A-98377F9ADFA2" class="sect4"><span class="enumeration_section">6.8.1</span> SQL文件</h4>
                  <div>
                     <p>生成的文件名具有以下格式：</p><pre class="oac_no_warn" dir="ltr">&lt;文件名&gt; _ &lt;文件类型&gt; .SQL</pre><p>在Pro * C中，对于文件“abc.pc”，生成的SQL文件将为abc_pc.sql。</p>
                     <div class="section">
                        <p class="subhead3" id="GUID-04D280DC-CE7E-4CC6-9D9A-98377F9ADFA2__GUID-43529950-B141-4772-BF1E-0F2AE68CBBE8">生成的文件格式</p>
                     </div>
                     <!-- class="section" -->
                     <div class="section">
                        <p>如果未使用outlnprefix选项，则用作大纲名称和注释的唯一标识符的格式为：</p><pre class="oac_no_warn" dir="ltr">&lt;category_name&gt; _ &lt;filename&gt; _ &lt;filetype&gt; _ &lt;序列号&gt;</pre><p>如果使用outlnprefix选项（outlnprefix = &lt;prefix_name&gt;），则用作大纲名称和注释的唯一标识符的格式为：</p><pre class="oac_no_warn" dir="ltr">&lt;prefix_name&gt; _ &lt;序列号&gt;</pre><p>如果outline = yes，这是默认类别，则&lt;category_name&gt;将为DEFAULT，大纲名称将为：</p><pre class="oac_no_warn" dir="ltr">DEFAULT_ &lt;文件名&gt; _ &lt;文件类型&gt; _ &lt;序列号&gt;</pre><p>要么</p><pre class="oac_no_warn" dir="ltr">&lt;prefix_name&gt; _ &lt;序列号&gt;</pre><p><code class="codeph">&lt;sequence no.&gt;</code>的允许范围是0000到9999。
                        </p>
                        <p>生成的预编译文件中的SQL将附加注释，因为它出现在该SQL的大纲中。</p>
                     </div>
                     <!-- class="section" -->
                  </div><a id="LNPCC3379"></a><a id="LNPCC3380"></a><a id="LNPCC3381"></a><a id="LNPCC3382"></a><a id="LNPCC3383"></a><a id="LNPCC3384"></a><a id="LNPCC3385"></a><a id="LNPCC3386"></a><a id="LNPCC3387"></a><a id="LNPCC3378"></a><div class="props_rev_3"><a id="GUID-1CDDA92A-367B-455A-90BB-4943AAA32D54" name="GUID-1CDDA92A-367B-455A-90BB-4943AAA32D54"></a><h5 id="LNPCC-GUID-1CDDA92A-367B-455A-90BB-4943AAA32D54" class="sect5"><span class="enumeration_section">6.8.1.1</span>示例</h5>
                     <div>
                        <p>请考虑以下示例。</p>
                        <div class="section">
                           <p class="subhead3" id="GUID-1CDDA92A-367B-455A-90BB-4943AAA32D54__GUID-05A02C02-F79C-43FE-9CA8-E80215C661B2">例1</p>
                        </div>
                        <!-- class="section" -->
                        <div class="section">
                           <p>如果abc.pc有语句</p><pre class="oac_no_warn" dir="ltr">EXEC SQL select * from emp其中empno =：var; EXEC SQL select * from dept;</pre><p>如果未使用outline = mycat1和outlnprefix，则：</p>
                        </div>
                        <!-- class="section" -->
                        <div class="section">
                           <p class="subhead3" id="GUID-1CDDA92A-367B-455A-90BB-4943AAA32D54__GUID-6ADBA2DA-7805-4814-B872-FF920B660730">abc_pc.sql的内容</p>
                        </div>
                        <!-- class="section" -->
                        <div class="section">
                           <p>在<code class="codeph">select * from emp where empno=:b1 /* mycat1_abc_pc_0000 */</code>为mycat1类别创建或替换大纲mycat1_abc_pc_0000， <code class="codeph">select * from emp where empno=:b1 /* mycat1_abc_pc_0000 */</code> <code class="codeph">;</code></p>
                           <p>在<code class="codeph">select * from dept /* mycat1_abc_pc_0001 */;</code>上为类别mycat1创建或替换大纲mycat1_abc_pc_0001 <code class="codeph">select * from dept /* mycat1_abc_pc_0001 */;</code></p>
                        </div>
                        <!-- class="section" -->
                        <div class="section">
                           <p class="subhead3" id="GUID-1CDDA92A-367B-455A-90BB-4943AAA32D54__GUID-7BC0DF8B-D9D8-42C9-9F21-78E131EF4804">abc.c的内容</p>
                        </div>
                        <!-- class="section" -->
                        <div class="section"><pre class="oac_no_warn" dir="ltr">sqlstm.stmt = select * from emp其中empno =：b1 / * mycat1_abc_pc_0000 * /; sqlstm.stmt = select * from dept / * mycat1_abc_pc_0001 * /;</pre></div>
                        <!-- class="section" -->
                        <div class="section">
                           <p class="subhead3" id="GUID-1CDDA92A-367B-455A-90BB-4943AAA32D54__GUID-C82E7C58-B085-4DCC-A53C-A331341F5357">例2</p>
                        </div>
                        <!-- class="section" -->
                        <div class="section">
                           <p>如果abc.pc有语句</p><pre class="oac_no_warn" dir="ltr">EXEC SQL select * from emp其中empno =：var; EXEC SQL select * from dept;</pre><p>如果outline = mycat1和outlnprefix = myprefix，则：</p>
                        </div>
                        <!-- class="section" -->
                        <div class="section">
                           <p class="subhead3" id="GUID-1CDDA92A-367B-455A-90BB-4943AAA32D54__GUID-04599602-B443-4E59-A730-AD674ED4D6A3">abc_pc.sql的内容</p>
                        </div>
                        <!-- class="section" -->
                        <div class="section">
                           <p>在<code class="codeph">select * from emp where empno=:b1 /* myprefix_0000 */;</code>为类别mycat1创建或替换大纲myprefix_0000， <code class="codeph">select * from emp where empno=:b1 /* myprefix_0000 */;</code></p>
                           <p>在<code class="codeph">select * from dept /* myprefix_0001 */;</code>上为类别mycat1创建或替换大纲myprefix_0001 <code class="codeph">select * from dept /* myprefix_0001 */;</code></p>
                        </div>
                        <!-- class="section" -->
                        <div class="section">
                           <p class="subhead3" id="GUID-1CDDA92A-367B-455A-90BB-4943AAA32D54__GUID-9FAB2A28-5418-4344-9C0B-7AA43149A0D9">abc.c的内容</p>
                        </div>
                        <!-- class="section" -->
                        <div class="section"><pre class="oac_no_warn" dir="ltr">sqlstm.stmt = select * from emp其中empno =：b1 / * myprefix_0000 * /; sqlstm.stmt = select * from dept / * myprefix_0001 * /;</pre></div>
                        <!-- class="section" -->
                        <div class="section">
                           <p class="subhead3" id="GUID-1CDDA92A-367B-455A-90BB-4943AAA32D54__GUID-B6AB7B18-54E2-4CEC-B436-047960CC2E5A">例3</p>
                        </div>
                        <!-- class="section" -->
                        <div class="section">
                           <p>如果abc.pc有语句</p><pre class="oac_no_warn" dir="ltr">EXEC SQL select * from emp其中empno =：var; EXEC SQL select * from dept;</pre><p>如果outline = yes和outlnprefix = myprefix，则：</p>
                        </div>
                        <!-- class="section" -->
                        <div class="section">
                           <p class="subhead3" id="GUID-1CDDA92A-367B-455A-90BB-4943AAA32D54__GUID-D49F0F6D-D470-431B-A6A1-15811B94A2D3">abc_pc.sql的内容</p>
                        </div>
                        <!-- class="section" -->
                        <div class="section">
                           <p>在<code class="codeph">select * from emp where empno=:b1 /* myprefix_0000 */;</code>创建或替换大纲myprefix_0000， <code class="codeph">select * from emp where empno=:b1 /* myprefix_0000 */;</code></p>
                           <p>在<code class="codeph">select * from dept /* myprefix_0001 */;</code>上创建或替换outline myprefix_0001 <code class="codeph">select * from dept /* myprefix_0001 */;</code></p>
                        </div>
                        <!-- class="section" -->
                        <div class="section">
                           <p class="subhead3" id="GUID-1CDDA92A-367B-455A-90BB-4943AAA32D54__GUID-6318BB75-3D9A-41BB-A1CD-9DC51FA5DFC1">abc.c的内容</p>
                        </div>
                        <!-- class="section" -->
                        <div class="section"><pre class="oac_no_warn" dir="ltr">sqlstm.stmt =“select * from emp where empno =：b1 / * myprefix_0000 * /; sqlstm.stmt =”select * from dept / * myprefix_0001 * /“;</pre></div>
                        <!-- class="section" -->
                     </div>
                  </div>
               </div><a id="LNPCC3389"></a><a id="LNPCC3390"></a><a id="LNPCC3388"></a><div class="props_rev_3"><a id="GUID-CAEDB406-ED5D-4A0A-A3FB-2A4AE1830414" name="GUID-CAEDB406-ED5D-4A0A-A3FB-2A4AE1830414"></a><h4 id="LNPCC-GUID-CAEDB406-ED5D-4A0A-A3FB-2A4AE1830414" class="sect4"><span class="enumeration_section">6。6。2</span>日志文件</h4>
                  <div>
                     <p>生成的文件名具有以下格式：</p><pre class="oac_no_warn" dir="ltr">&lt;文件名&gt; _ &lt;文件类型&gt; .log中</pre><p>在Pro * C中，对于文件“abc.pc”，生成的LOG文件将为abc_pc.log。</p>
                     <p>请考虑以下示例。</p>
                     <div class="section">
                        <p class="subhead3" id="GUID-CAEDB406-ED5D-4A0A-A3FB-2A4AE1830414__GUID-99308A40-BC12-43BE-B18E-7ACAAE88746B">例1</p>
                     </div>
                     <!-- class="section" -->
                     <div class="section">
                        <p>如果abc.pc有语句</p><pre class="oac_no_warn" dir="ltr">EXEC SQL select * from emp;</pre></div>
                     <!-- class="section" -->
                     <div class="section">
                        <p class="subhead3" id="GUID-CAEDB406-ED5D-4A0A-A3FB-2A4AE1830414__GUID-7A983199-20EF-4007-9EF3-2A5831CC8A96">abc_pc.log的内容</p>
                     </div>
                     <!-- class="section" -->
                     <div class="section"><pre class="oac_no_warn" dir="ltr">CATEGORY &lt;Category_name&gt;源SQL_0 SELECT * FROM emp OUTLINE NAME abc_pc_0000 OUTLINE SQL_0选择* from emp / * abc_pc_0000 * /</pre></div>
                     <!-- class="section" -->
                  </div>
               </div>
            </div><a id="LNPCC3391"></a><div class="props_rev_3"><a id="GUID-CB61E704-AA77-4F5F-BF67-A3E4F58C63C6" name="GUID-CB61E704-AA77-4F5F-BF67-A3E4F58C63C6"></a><h3 id="LNPCC-GUID-CB61E704-AA77-4F5F-BF67-A3E4F58C63C6" class="sect3"><span class="enumeration_section">6.9</span>当前条款</h3>
               <div>
                  <p>您可以在DELETE或UPDATE语句中使用CURRENT OF <span class="italic">cursor_name</span>子句来引用指定游标中的最新行FETCHed。光标必须打开并放在一行上。如果未执行FETCH或游标未打开，则CURRENT OF子句将导致错误并且不处理任何行。 <a id="d30526e2145" class="indexterm-anchor"></a><a id="d30526e2149" class="indexterm-anchor"></a> 
                  </p>
                  <p>当您DECLARE UPDATE或DELETE语句的CURRENT OF子句中引用的游标时，FOR UPDATE OF子句是可选的。CURRENT OF子句指示预编译器在必要时添加FOR UPDATE子句。</p>
                  <p>在以下示例中，您使用CURRENT OF子句来引用名为<span class="italic">emp_cursor</span>的游标中的最新行<span class="italic">FETCHed</span> ： <a id="d30526e2161" class="indexterm-anchor"></a> 
                  </p><pre class="oac_no_warn" dir="ltr">EXEC SQL DECLARE emp_cursor CURSOR FOR SELECT ename，sal FROM emp WHERE job ='CLERK'for saldate of sal; ...EXEC SQL OPEN emp_cursor; EXEC SQL WHENEVER未找到GOTO ......for（;;）{EXEC SQL FETCH emp_cursor INTO：emp_name，：salary; ...EXEC SQL UPDATE emp SET sal =：new_salary WHERE CURRENT OF emp_cursor; }</pre></div>
               <div>
                  <div class="relinfo">
                     <p><strong>相关话题</strong></p>
                     <ul>
                        <li><a href="database-concepts.html#GUID-B44AF482-9E22-4C39-AC53-D9C4E5F61D96">使用FOR UPDATE OF</a></li>
                     </ul>
                  </div>
               </div>
               <a id="LNPCC3392"></a><div class="props_rev_3"><a id="GUID-9CAF3199-6834-428D-BCD3-001292F465E2" name="GUID-9CAF3199-6834-428D-BCD3-001292F465E2"></a><h4 id="LNPCC-GUID-9CAF3199-6834-428D-BCD3-001292F465E2" class="sect4"><span class="enumeration_section">6.9.1</span>限制（更新）</h4>
                  <div>
                     <p>您不能在索引组织表上使用CURRENT OF子句。</p>
                     <p>显式FOR UPDATE OF子句或隐式FOR UPDATE子句获取独占行锁。所有行都在OPEN处锁定，而不是因为它们是FETCHed，并且在COMMIT或ROLLBACK时释放。因此，在COMMIT之后，您无法从FOR UPDATE游标进行FETCH。如果您尝试这样做，Oracle将返回1002错误代码。 <a id="d30526e2190" class="indexterm-anchor"></a><a id="d30526e2194" class="indexterm-anchor"></a> 
                     </p>
                     <p>此外，您不能将主机数组与CURRENT OF子句一起使用。有关替代方案，另请参阅<span class="q">“ <a href="host-arrays.html#GUID-DBA71301-C6C4-47C0-BAB5-1B6B221AB46E">关于模仿CURRENT OF</a> ”</span> 。
                     </p>
                     <p>此外，您不能在关联的FOR UPDATE OF子句中引用多个表，这意味着您无法与CURRENT OF子句进行连接。 <a id="d30526e2208" class="indexterm-anchor"></a> 
                     </p>
                     <p>最后，您不能将动态SQL与CURRENT OF子句一起使用。 <a id="d30526e2215" class="indexterm-anchor"></a> 
                     </p>
                  </div>
               </div>
            </div><a id="LNPCC3393"></a><div class="props_rev_3"><a id="GUID-6D0BC220-1DE8-49E9-AB54-F39182E33ECD" name="GUID-6D0BC220-1DE8-49E9-AB54-F39182E33ECD"></a><h3 id="LNPCC-GUID-6D0BC220-1DE8-49E9-AB54-F39182E33ECD" class="sect3"><span class="enumeration_section">6.10</span>游标语句</h3>
               <div>
                  <p>以下示例显示了应用程序中光标控制语句的典型顺序： <a id="d30526e2231" class="indexterm-anchor"></a> 
                  </p><pre class="oac_no_warn" dir="ltr">.../ *定义一个游标* / EXEC SQL DECLARE emp_cursor CURSOR FOR SELECT ename，job FROM emp WHERE empno =：emp_number FOR UPDATE OF job; / *打开游标并识别活动集* / EXEC SQL OPEN emp_cursor; / *如果最后一行已被提取则中断* / EXEC SQL WHENEVER NOT FOUND DO break; / *在循环中获取和处理数据* / for（;;）{EXEC SQL FETCH emp_cursor INTO：emp_name，：job_title; / *对FETCHed数据进行操作的可选主机语言语句* / EXEC SQL UPDATE emp SET job =：new_job_title WHERE CURRENT OF emp_cursor; } .../ *禁用游标* / EXEC SQL CLOSE emp_cursor; EXEC SQL COMMIT WORK RELEASE; ...</pre></div>
            </div><a id="LNPCC3394"></a><div class="props_rev_3"><a id="GUID-58F44B5B-4F08-4853-AF71-C2995F48E2ED" name="GUID-58F44B5B-4F08-4853-AF71-C2995F48E2ED"></a><h3 id="LNPCC-GUID-58F44B5B-4F08-4853-AF71-C2995F48E2ED" class="sect3"><span class="enumeration_section">6.11</span>使用不可滚动游标的完整示例</h3>
               <div>
                  <p>以下完整程序说明了游标和FETCH语句的使用。程序会提示输入部门编号，然后显示该部门中所有员工的姓名。</p>
                  <p>除最后一个之外的所有FETCH都返回一行，如果在FETCH期间没有检测到错误，则返回成功状态代码。最终的FETCH失败并将“无数据发现”Oracle错误代码返回给<span class="italic">sqlca.sqlcode</span> 。实际<code class="codeph">sqlerrd[2]</code>的累计行数在SQLCA的<code class="codeph">sqlerrd[2]</code>中找到。</p><pre class="oac_no_warn" dir="ltr">#include &lt;stdio.h&gt; / *声明主变量* / char userid [12] =“SCOTT / TIGER”; char emp_name [10]; int emp_number; int dept_number; char temp [32]; void sql_error（）; / *包括SQL通讯区* / #include &lt;sqlca.h&gt; main（）{emp_number = 7499; / *处理错误* / EXEC SQL WHENEVER SQLERROR执行sql_error（“Oracle错误”）; / *连接到Oracle * / EXEC SQL CONNECT：userid;的printf（ “连接\ n”）; / *声明一个游标* / EXEC SQL DECLARE emp_cursor CURSOR FOR SELECT ename FROM emp WHERE deptno =：dept_number; printf（“部门号码？“）; gets（temp）; dept_number = atoi（temp）; / *打开游标并识别活动集* / EXEC SQL OPEN emp_cursor; printf（”Employee Name \ n“）; printf（”----- -------- \ n“）; / *在没有更多数据的情况下在循环出口中获取和处理数据* / EXEC SQL WHENEVER NOT FOUND DO break; while（1）{EXEC SQL FETCH emp_cursor INTO：emp_name; printf（“％s \ n”，emp_name）;} EXEC SQL CLOSE emp_cursor; EXEC SQL COMMIT WORK RELEASE; exit（0）;} void sql_error（msg）char * msg; {char buf [500]; int buflen，msglen ; EXEC SQL WHENEVER SQLERROR CONTINUE; EXEC SQL ROLLBACK WORK RELEASE; buflen = sizeof（buf）; sqlglm（buf，＆buflen，＆msglen）; printf（“％s \ n”，msg）; printf（“％*。s \ n “，msglen，buf）; exit（1）;}</pre></div>
            </div><a id="LNPCC3395"></a><div class="props_rev_3"><a id="GUID-08073F0A-E663-4D3A-9DB4-92BF47CA6560" name="GUID-08073F0A-E663-4D3A-9DB4-92BF47CA6560"></a><h3 id="LNPCC-GUID-08073F0A-E663-4D3A-9DB4-92BF47CA6560" class="sect3"><span class="enumeration_section">6.12</span>使用可滚动游标的完整示例</h3>
               <div>
                  <p>以下程序说明了可滚动游标的使用以及FETCH语句使用的各种选项。</p><pre class="oac_no_warn" dir="ltr">#include &lt;stdio.h&gt; / *声明主变量* / char userid [12] =“SCOTT / TIGER”; char emp_name [10]; void sql_error（）; / *包括SQL通讯区* / #include &lt;sqlca.h&gt; main（）{/ *句柄错误* / EXEC SQL WHENEVER SQLERROR做sql_error（“Oracle错误”）; / *连接到Oracle * / EXEC SQL CONNECT：userid;的printf（ “连接\ n”）; / *声明一个可滚动的游标* / EXEC SQL DECLARE emp_cursor SCROLL CURSOR FOR SELECT ename FROM emp; / *打开游标并识别活动集* / EXEC SQL OPEN emp_cursor; / *获取最后一行* / EXEC SQL FETCH LAST emp_cursor INTO：emp_name; / *获取行号5 * / EXEC SQL FETCH ABSOLUTE 5 emp_cursor INTO：emp_name; / *获取行号10 * / EXEC SQL FETCH RELATIVE 5 emp_cursor INTO：emp_name; / *获取行号7 * / EXEC SQl FETCH RELATIVE -3 emp_cursor INTO：emp_name; / *获取第一行* / EXEC SQL FETCH FIRST emp_cursor INTO：emp_name; / *获取行号2 * / EXEC SQL FETCH my_cursor INTO：emp_name; / *获取行号3 * / EXEC SQL FETCH NEXT my_cursor INTO：emp_name; / *获取行号3 * / EXEC SQL FETCH CURRENT my_cursor INTO：emp_name; / *获取行号2 * / EXEC SQL FETCH PRIOR my_cursor INTO：emp_name; } void sql_error（msg）char * msg; {char buf [500]; int buflen，msglen; EXEC SQL WHENEVER SQLERROR CONTINUE; EXEC SQL ROLLBACK TRANSACTION; buflen = sizeof（buf）; sqlglm（buf，＆buflen，＆mesglen）;的printf（ “％S \ n” 个，MSG）;的printf（ “％* S \ n”。，msglen，BUF）;出口（1）; }</pre></div>
            </div><a id="LNPCC3396"></a><div class="props_rev_3"><a id="GUID-1A65920B-74ED-41FB-B120-C46A8EA86018" name="GUID-1A65920B-74ED-41FB-B120-C46A8EA86018"></a><h3 id="LNPCC-GUID-1A65920B-74ED-41FB-B120-C46A8EA86018" class="sect3"><span class="enumeration_section">6.13</span>定位更新</h3>
               <div>
                  <p>以下骨架示例演示使用通用ROWID定位更新。</p><pre class="oac_no_warn" dir="ltr">#include &lt;oci.h&gt; ...OCIRowid * urowid; ...EXEC SQL ALLOCATE：urowid; EXEC SQL DECLARE cur CURSOR FOR SELECT rowid，...来自my_table FOR更新...; EXEC SQL OPEN cur; EXEC SQL FETCH cur INTO：urowid，...; /* 处理数据 */ ...EXEC SQL UPDATE my_table SET ...当前的曲线; EXEC SQL CLOSE cur; EXEC SQL FREE：urowid; ...

</pre><p></p>
               </div>
               <div>
                  <div class="relinfo">
                     <p><strong>相关话题</strong></p>
                     <ul>
                        <li><a href="datatypes-and-host-variables.html#GUID-F78340AF-531F-4D1F-8D59-5C5860E7C367">通用ROWID</a></li>
                     </ul>
                  </div>
               </div>
               
            </div>
         </div>
      </article>
   </body>
</html>