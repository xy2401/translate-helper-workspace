<html lang="en-us" dir="ltr" xml:lang="en-us">
   <head>
      <meta http-equiv="Content-Type" content="text/html; charset=utf-8"></meta>
      <meta name="viewport" content="width=device-width, initial-scale=1"></meta>
      <meta http-equiv="X-UA-Compatible" content="IE=edge"></meta>
      <title>数据仓库逻辑设计</title>
      <meta property="og:site_name" content="Oracle Help Center"></meta>
      <meta property="og:title" content="Data Warehousing Guide"></meta>
      <meta property="og:description" content=""></meta>
      <link rel="stylesheet" href="/sp_common/book-template/ohc-book-template/css/book.css"></link>
      <link rel="shortcut icon" href="/sp_common/book-template/ohc-common/img/favicon.ico"></link>
      <meta name="application-name" content="Data Warehousing Guide"></meta>
      <meta name="generator" content="DITA Open Toolkit version 1.8.5 (Mode = doc)"></meta>
      <meta name="plugin" content="SP_docbuilder HTML plugin release 18.2.2"></meta>
      <link rel="alternate" href="database-data-warehousing-guide.pdf" title="PDF File" type="application/pdf"></link>
      <meta name="robots" content="all"></meta>
      <link rel="schema.dcterms" href="http://purl.org/dc/terms/"></link>
      <meta name="dcterms.created" content="2019-01-09T00:20:13-08:00"></meta>
      
      <meta name="dcterms.dateCopyrighted" content="2001, 2019"></meta>
      <meta name="dcterms.category" content="database"></meta>
      <meta name="dcterms.identifier" content="E96243-01"></meta>
      
      <meta name="dcterms.product" content="en/database/oracle/oracle-database/19"></meta>
      
      <link rel="prev" href="introduction-data-warehouse-concepts.html" title="Previous" type="text/html"></link>
      <link rel="next" href="data-warehouse-physical-design.html" title="Next" type="text/html"></link>
      <script>
        document.write('<style type="text/css">');
        document.write('body > .noscript, body > .noscript ~ * { visibility: hidden; }');
        document.write('</style>');
     </script>
      <script src="/sp_common/book-template/requirejs/require.js" data-main="/sp_common/book-template/ohc-book-template/js/book-config"></script>
      <script>
            if (window.require === undefined) {
                document.write('<script data-main="sp_common/book-template/ohc-book-template/js/book-config" src="sp_common/book-template/requirejs/require.js"><\/script>');
                document.write('<link href="sp_common/book-template/ohc-book-template/css/book.css" rel="stylesheet"/>');
            }
        </script>
      <script type="application/json" id="ssot-metadata">{"primary":{"category":{"short_name":"database","element_name":"Database","display_in_url":true},"suite":{"short_name":"oracle","element_name":"Oracle","display_in_url":true},"product_group":{"short_name":"not-applicable","element_name":"Not applicable","display_in_url":false},"product":{"short_name":"oracle-database","element_name":"Oracle Database","display_in_url":true},"release":{"short_name":"19","element_name":"Release 19","display_in_url":true}}}</script>
      
    <meta name="dcterms.title" content="Database Data Warehousing Guide"></meta>
    <meta name="dcterms.isVersionOf" content="DWHSG"></meta>
    <meta name="dcterms.release" content="Release 19"></meta>
  </head>
   <body dir="ltr">
      <div class="noscript alert alert-danger text-center" role="alert">
         <a href="introduction-data-warehouse-concepts.html" class="pull-left"><span class="glyphicon glyphicon-chevron-left" aria-hidden="true"></span>上一页</a> <a href="data-warehouse-physical-design.html" class="pull-right">下一页<span class="glyphicon glyphicon-chevron-right" aria-hidden="true"></span></a> <span class="fa fa-exclamation-triangle" aria-hidden="true"></span>必须启用JavaScript才能正确显示此内容</div>
      <article>
         <header>
            <ol class="breadcrumb" vocab="http://schema.org/" typeof="BreadcrumbList">
               <li property="itemListElement" typeof="ListItem"><a href="index.html" property="item" typeof="WebPage"><span property="name">数据仓库指南</span></a></li>
               <li property="itemListElement" typeof="ListItem"><a href="part-dw-fundamentals.html" property="item" typeof="WebPage"><span property="name">数据仓库 - 基础知识</span></a></li>
               <li class="active" property="itemListElement" typeof="ListItem">数据仓库逻辑设计</li>
            </ol>
            <a id="GUID-04B1A087-8893-43B6-ADB2-4E5E1CC2A6D3" name="GUID-04B1A087-8893-43B6-ADB2-4E5E1CC2A6D3"></a>
            
            <h2 id="DWHSG-GUID-04B1A087-8893-43B6-ADB2-4E5E1CC2A6D3" class="sect2"><span class="enumeration_chapter">2</span>数据仓库逻辑设计</h2>
         </header>
         <div class="ind">
            <div>
               <p>本章<a id="d7845e19" class="indexterm-anchor"></a><a id="d7845e23" class="indexterm-anchor"></a>解释了如何为数据仓库环境创建逻辑设计，并包括以下主题：</p>
               <ul style="list-style-type:disc">
                  <li>
                     <p><a href="data-warehouse-logical-design.html#GUID-48D381BE-15FD-4C92-B486-6071BEBD7801">逻辑与数据仓库中的物理设计</a></p>
                  </li>
                  <li>
                     <p><a href="data-warehouse-logical-design.html#GUID-EF70DDE8-FB91-4FCA-9F9E-397CA946148C">创建逻辑设计</a></p>
                  </li>
                  <li>
                     <p><a href="data-warehouse-logical-design.html#GUID-FD474327-4F5C-4D7E-AC7B-91739F229822">关于第三范式表格</a></p>
                  </li>
                  <li>
                     <p><a href="data-warehouse-logical-design.html#GUID-FB038EDB-47AB-4FF1-9826-E342BED572CF">关于Star Schemas</a></p>
                  </li>
                  <li>
                     <p><a href="data-warehouse-logical-design.html#GUID-43410030-C84A-4978-B286-6A3361D172FB" title="内存中列存储（IM列存储）是系统全局区域（SGA）的可选部分，它以压缩的列式格式存储表，表分区和其他数据库对象的副本，该格式针对快速扫描进行了优化。">使用内存中的列存储改进了分析</a></p>
                  </li>
                  <li>
                     <p><a href="data-warehouse-logical-design.html#GUID-BD54F705-627B-4460-AB83-AFA992D8798C">自动大表缓存提高内存并行查询的性能</a></p>
                  </li>
               </ul>
            </div><a id="DWHSG9226"></a><div class="props_rev_3"><a id="GUID-48D381BE-15FD-4C92-B486-6071BEBD7801" name="GUID-48D381BE-15FD-4C92-B486-6071BEBD7801"></a><h3 id="DWHSG-GUID-48D381BE-15FD-4C92-B486-6071BEBD7801" class="sect3"><span class="enumeration_section">2.1</span>逻辑与数据仓库中的物理设计</h3>
               <div>
                  <p>您的组织已决定构建企业数据仓库。您已定义业务需求并就业务目标的范围达成一致，并创建了概念设计。现在，您需要将需求转换为系统可交付成果。为此，您需要为数据仓库创建逻辑和物理设计。然后你定义：</p>
                  <ul style="list-style-type:disc">
                     <li>
                        <p>具体数据内容</p>
                     </li>
                     <li>
                        <p>数据组内和之间的关系</p>
                     </li>
                     <li>
                        <p>支持数据仓库的系统环境</p>
                     </li>
                     <li>
                        <p>需要进行数据转换</p>
                     </li>
                     <li>
                        <p>刷新数据的频率</p>
                     </li>
                  </ul>
                  <p>逻辑设计比物理设计更具概念性和抽象性。在逻辑设计中，您将查看对象之间的逻辑关系。在物理设计中，您将了解存储和检索对象以及从传输和备份/恢复角度处理对象的最有效方法。</p>
                  <p>根据最终用户的需求确定您的设计方向。最终用户通常希望执行分析并查看汇总数据，而不是单个事务。但是，最终用户在看到之前可能不知道他们需要什么。此外，精心规划的设计可随着用户需求的变化和发展而增长和变化。</p>
                  <p>从逻辑设计开始，您将关注信息需求并保存实现细节以供日后使用。</p>
               </div>
            </div><a id="DWHSG9227"></a><div class="props_rev_3"><a id="GUID-EF70DDE8-FB91-4FCA-9F9E-397CA946148C" name="GUID-EF70DDE8-FB91-4FCA-9F9E-397CA946148C"></a><h3 id="DWHSG-GUID-EF70DDE8-FB91-4FCA-9F9E-397CA946148C" class="sect3"><span class="enumeration_section">2.2</span>创建逻辑设计</h3>
               <div>
                  <p>逻辑设计是概念性的和抽象的。您还没有处理物理实现细节。您只需要定义所需的信息类型。</p>
                  <p>可用于建模组织逻辑信息需求的一种技术是实体关系建模。实体关系建模涉及识别重要事物（实体），这些事物的属性（属性）以及它们如何彼此相关（关系）。</p>
                  <p>逻辑设计过程涉及将数据排列成一系列称为实体和属性的逻辑关系。<a id="d7845e131" class="indexterm-anchor"></a>实体代表一大块信息。在关系数据库中，实体通常映射到表。<a id="d7845e134" class="indexterm-anchor"></a>属性是实体的组件，有助于定义实体的唯一性。在关系数据库中，属性映射到列。
                  </p>
                  <p>要确保数据一致，必须使用唯一<a id="d7845e139" class="indexterm-anchor"></a>身份标识。您可以在表格中添加唯一标识符，以便在相同项目出现在不同位置时区分它们。在物理设计中，这通常是主键。
                  </p>
                  <p>实体关系建模纯粹是逻辑上的，适用于OLTP和数据仓库系统。它也适用于数据仓库环境中的各种常见物理模式建模技术，即企业数据仓库环境中的标准化（3NF）模式，数据集市中的星型或雪花模式，或具有这两种经典建模技术组件的混合模式。 。</p>
                  <div class="infoboxnotealso" id="GUID-EF70DDE8-FB91-4FCA-9F9E-397CA946148C__GUID-CE0A1E37-859E-4388-8B99-887DD4ED3237">
                     <p class="notep1">也可以看看：</p>
                     <ul style="list-style-type:disc">
                        <li>
                           <p><a href="https://www.oracle.com/pls/topic/lookup?ctx=en/database/oracle/oracle-database/19/dwhsg&amp;id=ODIDG171" target="_blank"><span class="italic">Oracle融合中间件使用Oracle Data Integrator开发集成项目，以</span></a>获取有关ODI的更多详细信息</p>
                        </li>
                     </ul>
                  </div>
               </div><a id="DWHSG9290"></a><div class="props_rev_3"><a id="GUID-3507EE0E-F92E-4781-8341-549791A3EE7D" name="GUID-3507EE0E-F92E-4781-8341-549791A3EE7D"></a><h4 id="DWHSG-GUID-3507EE0E-F92E-4781-8341-549791A3EE7D" class="sect4"><span class="enumeration_section">2.2.1</span>什么是架构？
                  </h4>
                  <div>
                     <p>架构<a id="d7845e177" class="indexterm-anchor"></a><a id="d7845e181" class="indexterm-anchor"></a>是数据库对象的集合，包括表，视图，索引和同义词。您可以通过各种方式在为数据仓库设计的模式模型中排列模式对象。大多数数据仓库使用维度模型。
                     </p>
                     <p>源数据模型和用户需求可帮助您设计数据仓库模式。您有时可以从公司的企业数据模型中获取源模型，并从中反向设计数据仓库的逻辑数据模型。逻辑数据仓库模型的物理实现可能需要进行一些更改，以使其适应您的系统参数 - 计算机大小，用户数，存储容量，网络类型和软件。设计模式的关键部分是使用第三种普通形式，星形还是雪花模式，这些将在后面讨论。</p>
                  </div>
               </div>
            </div><a id="DWHSG9230"></a><a id="DWHSG9229"></a><div class="props_rev_3"><a id="GUID-FD474327-4F5C-4D7E-AC7B-91739F229822" name="GUID-FD474327-4F5C-4D7E-AC7B-91739F229822"></a><h3 id="DWHSG-GUID-FD474327-4F5C-4D7E-AC7B-91739F229822" class="sect3"><span class="enumeration_section">2.3</span>关于第三范式模式</h3>
               <div>
                  <p>第三常态对于m设计寻求最小化数据冗余并避免数据插入，更新和删除中的异常。3NF设计在在线事务处理（OLTP）系统中具有悠久的历史。插入，更新和删除数据时，OLTP系统必须最大限度地提高性能和准确性。交易必须尽快处理，否则业务可能无法处理事件流，可能会导致销售损失或产生其他成本。因此，3NF设计避免了冗余数据操作并最大限度地减少了表锁，这两者都会降低插入，更新和删除的速度。3NF设计也可以很好地从特定的应用需求中抽象出数据。如果将新类型的数据添加到环境中，则可以相对轻松地扩展数据模型，并且对现有应用程序的影响最小。同样，如果您要在数据仓库中执行全新类型的分析，精心设计的3NF模式将能够处理它们而无需重新设计数据结构.3NF设计具有很大的灵活性，但需要付出代价。3NF数据库使用很多表，这需要具有许多连接的复杂查询。对于以3NF格式构建的全规模企业模型，架构中通常会遇到超过一千个表。由于数据仓库中涉及的查询类型（通常需要访问许多表中的许多行），因此这种设计会产生理解和性能损失。对于查询构建器（无论是人工还是商业智能工具和应用程序）来说，当有大量可用表时，选择和连接给定数据所需的表可能很复杂。即使查询生成器很容易选择表，3NF模式通常也要求在单个查询中使用大量表。查询中的更多表意味着更多潜在的数据访问路径，这使得数据库查询优化器的工作更加困难。最终结果可能是查询性能较慢。
                  </p>
                  <p>3NF系统中查询性能低的问题不一定限于用于创建报告和分析的核心查询。它还可以显示在用户浏览数据子集以理解内容的简单任务中。同样，3NF模式的复杂性可能会影响生成用于约束查询和报告的数据选择列表。虽然这些可能看起来相对较小，但是这些过程的快速响应时间会对用户满意度产生很大影响。</p>
                  <p><a href="data-warehouse-logical-design.html#GUID-FD474327-4F5C-4D7E-AC7B-91739F229822__BABIFDDG">图2-1</a>显示了3NF Schema的一个小片段。请注意订单信息如何分解为订单和订单商品以避免冗余数据存储。表格之间关系的“乌鸦脚”标记表示实体之间的一对多关系。因此，一个订单可以具有多个订单商品，单个客户可以具有多个订单，并且可以在许多订单商品中找到单个产品。虽然此图显示了一个非常小的情况，但您可以看到最小化数据冗余会导致架构中的许多表。
                  </p>
                  <div class="figure" id="GUID-FD474327-4F5C-4D7E-AC7B-91739F229822__BABIFDDG">
                     <p class="titleinfigure">图2-1第三范式模式的片段</p><img src="img/dwhsg108.gif" alt="下面描述图2-1" title="下面描述图2-1" longdesc="img_text/dwhsg108.html"><br><a href="img_text/dwhsg108.html">“图2-1第三范式模式的片段”的描述</a></div>
                  <!-- class="figure" -->
                  <div class="infoboxnotealso" id="GUID-FD474327-4F5C-4D7E-AC7B-91739F229822__GUID-B3F28A2E-2AB2-48B8-9338-948A9A223EE9">
                     <p class="notep1">也可以看看：</p>
                     <p><a href="data-warehouse-logical-design.html#GUID-1952DCB5-D7BE-4D52-A264-A9BFC6AB2578">3NF模式的设计概念</a></p>
                  </div>
               </div><a id="DWHSG9231"></a><div class="props_rev_3"><a id="GUID-A5E3E278-E611-4AB1-BE17-C3AF0DF87A80" name="GUID-A5E3E278-E611-4AB1-BE17-C3AF0DF87A80"></a><h4 id="DWHSG-GUID-A5E3E278-E611-4AB1-BE17-C3AF0DF87A80" class="sect4"><span class="enumeration_section">2.3.1</span>关于规范化</h4>
                  <div>
                     <p>规范化是一个数据设计过程，其高级目标是将每个事实保持在一个位置，以避免数据冗余以及插入，更新和删除异常。有多个级别的规范化，本节描述了前三个。考虑到第三范式（3NF）项是多么基本，只看到如何达到3NF才有意义。</p>
                     <p>考虑一种跟踪销售情况的情况。您跟踪的核心实体是销售订单，其中每个销售订单包含有关所购买的每个项目的详细信息（称为行项目）：其名称，价格，数量等。该订单还包含客户的名称和地址等。有些订单有很多不同的订单项，有些订单只有一个。</p>
                     <p>在第一范式（1NF）中，没有重复的数据组，也没有重复的行。行和列（字段）的每个交集只包含一个值，并且没有包含相同事实的列组。为避免重复行，有一个主键。对于销售订单，在第一范式中，不显示表格的单个字段中的每个销售订单的多个行项目。此外，不会有多个列显示订单项。</p>
                     <p>然后是第二范式（2NF），其中设计是第一范式，每个非键列依赖于完整的主键。因此，行项目分为销售订单行项目表，其中每行代表一个订单的一个行项目。您可以查看订单项表，并查看所售商品的名称不依赖于订单项表的主键：销售商品是其自己的实体。因此，您将销售项目移动到显示项目名称的表中。每件商品的价格可能因订单而异（例如，由于折扣），因此这些价格保留在订单项表中。在销售订单的情况下，客户的名称和地址不依赖于销售订单的主键：客户是其自己的实体。因此，您将客户名称和地址列移动到他们自己的客户信息表中。</p>
                     <p>接下来是第三范式，其目标是确保不依赖于非关键属性。因此，目标是获取与行的主题（主键）不直接相关的列，并将它们放在自己的表中。因此，有关客户的详细信息（例如客户名称或客户城市）应放在单独的表中，然后将客户外键添加到订单表中。</p>
                     <p>2NF表与3NF表的不同之处的另一个例子是网球锦标赛的获胜者表，其中包含锦标赛，年份，获胜者和获胜者出生日期的列。在这种情况下，获胜者的出生日期很容易出现不一致，因为同一个人可能会在不同的记录中显示出生日期。避免这个潜在问题的方法是将桌子分成一个用于锦标赛获胜者，另一个用于玩家的出生日期。</p>
                  </div>
               </div><a id="DWHSG9311"></a><div class="props_rev_3"><a id="GUID-1952DCB5-D7BE-4D52-A264-A9BFC6AB2578" name="GUID-1952DCB5-D7BE-4D52-A264-A9BFC6AB2578"></a><h4 id="DWHSG-GUID-1952DCB5-D7BE-4D52-A264-A9BFC6AB2578" class="sect4"><span class="enumeration_section">2.3.2</span> 3NF模式的设计概念</h4>
                  <div>
                     <p>以下部分讨论使用3NF模式方法为数据仓库环境建模时的一些基本概念。目的不是讨论3NF建模（甚至更高级别的标准化）的理论基础，而是要强调与数据仓库相关的一些关键组件。</p>
                     <p>与数据仓库相关的一些关键3NF架构设计概念如下：</p>
                     <ul style="list-style-type:disc">
                        <li>
                           <p><a href="data-warehouse-logical-design.html#GUID-E185B06B-5008-40AC-8C8C-52F6E9AC01A2">识别候选主键</a></p>
                        </li>
                        <li>
                           <p><a href="data-warehouse-logical-design.html#GUID-AD7D5938-1B52-44A6-815E-D73834303871">外键关系与参照完整性约束</a></p>
                        </li>
                        <li>
                           <p><a href="data-warehouse-logical-design.html#GUID-75BD1411-C19C-436B-8FB9-47F3708272D9">非规范化</a></p>
                        </li>
                     </ul>
                  </div><a id="DWHSG9312"></a><div class="props_rev_3"><a id="GUID-E185B06B-5008-40AC-8C8C-52F6E9AC01A2" name="GUID-E185B06B-5008-40AC-8C8C-52F6E9AC01A2"></a><h5 id="DWHSG-GUID-E185B06B-5008-40AC-8C8C-52F6E9AC01A2" class="sect5"><span class="enumeration_section">2.3.2.1</span>识别候选主键</h5>
                     <div>
                        <p>主键是唯一标识表中特定记录的属性。可以通过单列或多列来标识主键。通常优选通过尽可能少的列实现唯一识别 - 理想情况下是一个或两个 - 并且使用最不可能不会更新或甚至批量更改的列。如果您的数据模型没有通过其属性导致简单的唯一标识，则需要太多属性来唯一标识单个记录，或者数据易于更改，强烈建议使用代理键。</p>
                        <p>具体来说，3NF模式依赖于正确和简单的唯一标识，因为查询往往具有许多表连接，并且需要唯一标识记录所需的所有列作为连接条件，以避免通过连接进行行重复。</p>
                     </div>
                  </div><a id="DWHSG9313"></a><div class="props_rev_3"><a id="GUID-AD7D5938-1B52-44A6-815E-D73834303871" name="GUID-AD7D5938-1B52-44A6-815E-D73834303871"></a><h5 id="DWHSG-GUID-AD7D5938-1B52-44A6-815E-D73834303871" class="sect5"><span class="enumeration_section">2.3.2.2</span>外键关系和参考完整性约束</h5>
                     <div>
                        <p>数据仓库环境中的3NF模式通常类似于其OLTP源系统的数据模型，其中数据实体之间的逻辑一致性通过主键表达和实施 - 外键关系，也称为父子关系。外键解析关系系统中的1对多关系并确保逻辑一致性：例如，您不能拥有没有订单标题的订单行项目，或者不能为不存在的部门工作的员工。</p>
                        <p>虽然这种引用总是在OLTP系统中实施，但数据仓库系统通常将它们实现为声明性的非强制条件，依赖于ETL过程来确保数据的一致性。应尽可能将外键和参照完整性约束定义为非强制条件，因为它可以实现更好的查询优化和基数估计。</p>
                     </div>
                  </div><a id="DWHSG9314"></a><div class="props_rev_3"><a id="GUID-75BD1411-C19C-436B-8FB9-47F3708272D9" name="GUID-75BD1411-C19C-436B-8FB9-47F3708272D9"></a><h5 id="DWHSG-GUID-75BD1411-C19C-436B-8FB9-47F3708272D9" class="sect5"><span class="enumeration_section">2.3.2.3</span>非规范化</h5>
                     <div>
                        <p>适当的规范化建模倾向于分解逻辑实体 - 例如客户。产品或订单 - 进入许多物理表，甚至可以检索需要加入许多表的感知简单信息。虽然从查询处理的角度来看这不是问题，但它可能给应用程序开发人员（用于编写代码）以及数据库（用于连接始终一起使用的信息）带来一些不必要的负担。在3NF数据仓库模型中看到一些合理的非规范化级别，以逻辑形式作为视图或通过略微非规范化的表格以物理形式出现这种情况并不罕见。</p>
                        <p>必须注意物理非规范化以保持主体中立的形状，从而保持3NF模式的物理实现的灵活性。</p>
                     </div>
                  </div>
               </div>
            </div><a id="DWHSG9233"></a><div class="props_rev_3"><a id="GUID-FB038EDB-47AB-4FF1-9826-E342BED572CF" name="GUID-FB038EDB-47AB-4FF1-9826-E342BED572CF"></a><h3 id="DWHSG-GUID-FB038EDB-47AB-4FF1-9826-E342BED572CF" class="sect3"><span class="enumeration_section">2.4</span>关于Star Schemas</h3>
               <div>
                  <p>星型模式通常存在于具有嵌入式逻辑或物理数据集市的数据仓库系统中。术语星型模式是另一种引用“维度建模”方法来定义数据模型的方法。维度建模的大多数描述都使用了Ralph Kimball的工作中提到的术语，Ralph Kimball是该领域的先驱顾问和作家。维度建模创建多个星型模式，每个模式基于业务流程，例如销售跟踪或货件。每个星型模式都可以被视为数据集市，可能只有20个数据集市可以满足企业的商业智能需求。与3NF设计相比，维度建模所涉及的表格数量很少。许多明星模式将有十几个表格。明星图式通过一致的维度和一致的事实编织在一起。因此，用户能够以最小的努力从多个星型模式获取数据。</p>
                  <p>星型模式的目标是结构简单性和高性能数据检索。由于现代大多数查询都是由报告工具和应用程序生成的，因此为工具和应用程序生成查询生成方便可靠至关重要。实际上，许多商业智能工具和应用程序的设计都期望可以使用星型模式表示。</p>
                  <p>与3NF描述相比，星型模式的讨论不像物理数据库那样抽象。这是由于维度建模对商业智能用户需求的务实强调。</p>
                  <p>请注意，维度建模风格与3NF方法的不同之处在于最小化数据冗余以及更新/插入/删除异常的风险。星型模式在其维度表中接受数据冗余（非规范化），以便于用户理解和更好的数据检索性能。对星型模式的一个常见批评是，与3NF设计相比，它们限制了分析的灵活性。然而，可以扩展精心设计的维度模型以实现新类型的分析，并且星型模式在大型企业中已经成功多年。</p>
                  <p>如前所述，数据仓库的现代方法不会使星型模式和3NF相互冲突。相反，使用这两种技术，具有3NF的基础层 -  3NF的企业数据仓库，充当基岩数据，以及星型模式作为访问和性能优化层的核心部分。</p>
                  <div class="section">
                     <div class="infoboxnotealso" id="GUID-FB038EDB-47AB-4FF1-9826-E342BED572CF__GUID-D40EA285-8F0E-4476-82F8-E1B2CE618747">
                        <p class="notep1">也可以看看：</p>
                        <ul style="list-style-type:disc">
                           <li>
                              <p><a href="data-warehouse-logical-design.html#GUID-0DC8D19D-E585-4B7A-B070-335C2BBA313F">关于星型模式中的事实和维度</a></p>
                           </li>
                           <li><a href="data-warehouse-logical-design.html#GUID-787CD3B1-0131-47F4-A904-4F7221A29448">星型模式中的设计概念</a></li>
                        </ul>
                     </div>
                  </div>
                  <!-- class="section" -->
               </div><a id="DWHSG9235"></a><a id="DWHSG9234"></a><div class="props_rev_3"><a id="GUID-0DC8D19D-E585-4B7A-B070-335C2BBA313F" name="GUID-0DC8D19D-E585-4B7A-B070-335C2BBA313F"></a><h4 id="DWHSG-GUID-0DC8D19D-E585-4B7A-B070-335C2BBA313F" class="sect4"><span class="enumeration_section">2.4.1</span>关于星型模式中的事实和维度</h4>
                  <div>
                     <p>星型模式将数据划分为事实和维度。事实是某些事件的测量，例如销售，通常是数字。维度是用于标识事实的类别，例如日期，位置和产品。</p>
                     <p>名称“星型模式”来自于模式图通常显示的事实<a id="d7845e446" class="indexterm-anchor"></a>中心事实表，其中的线条将其连接到维度表，因此图形印象类似于星形。<a href="data-warehouse-logical-design.html#GUID-0DC8D19D-E585-4B7A-B070-335C2BBA313F__BABEBJEF">图2-2</a>是一个简单示例，其中sales作为事实表，产品，时间，客户和渠道作为维度表。
                     </p>
                     <div class="figure" id="GUID-0DC8D19D-E585-4B7A-B070-335C2BBA313F__BABEBJEF">
                        <p class="titleinfigure">图2-2星型模式</p><img width="336" src="img/td007.gif" alt="下面是图2-2的描述" title="下面是图2-2的描述" longdesc="img_text/td007.html"><br><a href="img_text/td007.html">“图2-2星型模式”的描述</a></div>
                     <!-- class="figure" -->
                     <div class="infoboxnotealso" id="GUID-0DC8D19D-E585-4B7A-B070-335C2BBA313F__GUID-F5436257-7D99-45BF-9ECE-7F2640293B25">
                        <p class="notep1">也可以看看：</p>
                        <ul style="list-style-type:disc">
                           <li>
                              <p><a href="data-warehouse-logical-design.html#GUID-FCC59AA8-6E38-4371-8B37-2B7A14A46EEE">关于数据仓库中的事实表</a></p>
                           </li>
                           <li>
                              <p><a href="data-warehouse-logical-design.html#GUID-26B19D0E-0219-4D04-8D54-940BDF816AC1">关于数据仓库中的维度表</a></p>
                           </li>
                        </ul>
                     </div>
                  </div><a id="DWHSG9236"></a><div class="props_rev_3"><a id="GUID-FCC59AA8-6E38-4371-8B37-2B7A14A46EEE" name="GUID-FCC59AA8-6E38-4371-8B37-2B7A14A46EEE"></a><h5 id="DWHSG-GUID-FCC59AA8-6E38-4371-8B37-2B7A14A46EEE" class="sect5"><span class="enumeration_section">2.4.1.1</span>关于数据仓库中的事实表</h5>
                     <div>
                        <p>事实表有测量数据。它们有很多行但通常没有很多列。大型企业的事实表可以轻松容纳数十亿行。对于许多星型模式，事实表将占总存储空间的90％以上。事实表具有由模式的维度表的主键组成的复合键。</p>
                        <p>事实表包含详细级别的事实或已聚合的事实。包含聚合事实的事实表通常称为汇总表。事实表通常包含具有相同聚合级别的事实。虽然大多数事实都是添加剂，但它们也可以是半添加剂或非添加剂。添加事实可以通过简单的算术加法来聚合。一个常见的例子是销售。根本不添加非附加事实。一个例子是平均值。半加性事实可以沿着某些维度聚合而不是沿着其他维度聚合。这方面的一个例子是存储在物理仓库中的库存水平，您可以在仓库站点的维度上添加库存水平，但不能跨时间汇总。</p>
                        <p>在向事实表中的数据添加行方面，有三种主要方法：</p>
                        <ul style="list-style-type:disc">
                           <li>
                              <p>基于交易</p>
                              <p>显示事务中最精细级别详细信息的行。仅当针对给定维度值组合发生事务时才输入行。这是最常见的事实表类型。</p>
                           </li>
                           <li>
                              <p>定期快照</p>
                              <p>显示截至常规时间间隔结束时的数据，例如每日或每周。如果前一个时间段中存在快照行，则即使在最近的时间间隔内未发生与其相关的活动，也会在新时间段内为其输入一行。这种类型的事实表在复杂的业务流程中很有用，因为很难从单个事务行计算快照值。</p>
                           </li>
                           <li>
                              <p>累积快照</p>
                              <p>每次出现一个短期进程时显示一行。这些行包含多个日期，用于跟踪短期流程的主要里程碑。与其他两种类型的事实表不同，当跟踪的进程向前移动时，累积快照中的行会多次更新。</p>
                           </li>
                        </ul>
                     </div>
                  </div><a id="DWHSG9237"></a><div class="props_rev_3"><a id="GUID-26B19D0E-0219-4D04-8D54-940BDF816AC1" name="GUID-26B19D0E-0219-4D04-8D54-940BDF816AC1"></a><h5 id="DWHSG-GUID-26B19D0E-0219-4D04-8D54-940BDF816AC1" class="sect5"><span class="enumeration_section">2.4.1.2</span>关于数据仓库中的维度表</h5>
                     <div>
                        <p>维度表提供类别数据以提供事实数据的上下文。例如，销售数据的星型模式将包含产品，日期，销售地点，促销等维度表。维度表充当查找表或引用表，因为它们的信息允许您选择用于约束查询的值。许多维度表中的值可能不经常更改。例如，显示城市的地理区域可能相当静态。但是，当维度值发生变化时，快速可靠地更新维度值至关重要。当然，有些情况下数据仓库维度值经常变化。企业的客户维度肯定会经常更新和删除。</p>
                        <p>维度表的一个关键方面是它们提供的层次结构信息。维度数据通常具有最低细节级别的行以及聚合维度值的行。维表中的这些自然汇总或聚合称为层次结构，为分析增加了很大的价值。例如，如果要计算特定产品在其特定产品类别中所代表的销售份额，那么为产品聚合预定义的层次结构比指定每个产品类别的所有元素要容易得多，也更可靠。查询。由于层次结构信息非常有价值，因此通常会发现维度表中反映的多个层次结构。</p>
                        <p>维度表通常是文本和描述性的，您将使用它们的值作为查询生成的报告的行标题，列标题和页眉。虽然维度表的行数远远少于事实表，但它们可以非常宽，具有数十列。位置维度表可能具有指示其汇总层次结构的每个级别的列，并且可能会显示表中反映的多个层次结构。位置维度表可以包含其地理汇总列，例如街道地址，邮政编码，城市，州/省和国家/地区。同一个表可以包括为销售组织设置的汇总层次结构，其中包含销售区，销售区域，销售区域和特征的列。</p>
                        <div class="infoboxnotealso" id="GUID-26B19D0E-0219-4D04-8D54-940BDF816AC1__GUID-CFCF03B1-97E6-4929-81D0-6059E57DA38F">
                           <p class="notep1">也可以看看：</p>
                           <p> <a href="dimensions.html#GUID-106BE703-0D67-41F1-8CAC-6432B95FBF82">尺寸</a>有关<a href="dimensions.html#GUID-106BE703-0D67-41F1-8CAC-6432B95FBF82">尺寸</a>的更多信息</p>
                        </div>
                     </div>
                  </div>
               </div><a id="DWHSG9238"></a><div class="props_rev_3"><a id="GUID-787CD3B1-0131-47F4-A904-4F7221A29448" name="GUID-787CD3B1-0131-47F4-A904-4F7221A29448"></a><h4 id="DWHSG-GUID-787CD3B1-0131-47F4-A904-4F7221A29448" class="sect4"><span class="enumeration_section">2.4.2</span>星型模式中的设计概念</h4>
                  <div>
                     <p>在这里，我们将介绍星型模式中使用的一些关键术语。这绝不是一整套，但旨在突出一些值得您考虑的领域。</p>
                     <div class="section" id="GUID-787CD3B1-0131-47F4-A904-4F7221A29448__CIHCCIEF">
                        <p class="subhead3" id="GUID-787CD3B1-0131-47F4-A904-4F7221A29448__GUID-B126B71A-80D8-4717-82D3-A5C102B2B9FF">数据粮</p>
                        <p>设计模型时最重要的任务之一是考虑它将提供的详细程度，称为数据粒度。考虑一个销售模式：粮食是否非常精细，存储每个客户购买的每一件商品？或者它是粗粮，只存储每个商店每个产品的每日销售总额？在现代数据仓库中，非常强调提供最好的颗粒数据，因为这样可以获得最大的分析能力。维度建模专家通常建议每个事实表只存储一个谷物级别。在单粒度表中显示事实数据支持更可靠的查询和表维护，因为事实表中任何行的范围都不存在歧义。</p>
                     </div>
                     <!-- class="section" -->
                     <div class="section" id="GUID-787CD3B1-0131-47F4-A904-4F7221A29448__CIHICGJA">
                        <p class="subhead3" id="GUID-787CD3B1-0131-47F4-A904-4F7221A29448__GUID-AE989781-8DE7-4038-A6FA-6A18233E0E67">使用多个星型模式</p>
                        <p>因为星型模式设计方法旨在将数据分块到不同的进程中，所以当查询跨越多个模式时，您需要可靠且高效的方法来遍历模式。这种能力的一个术语是数据仓库总线架构。数据仓库总线架构可以通过一致的维度和一致的事实来实现。</p>
                     </div>
                     <!-- class="section" -->
                     <div class="section" id="GUID-787CD3B1-0131-47F4-A904-4F7221A29448__CIHHAGIB">
                        <p class="subhead3" id="GUID-787CD3B1-0131-47F4-A904-4F7221A29448__GUID-E958D393-CACD-4E33-AAFE-B2EFCC42DB19">符合尺寸</p>
                        <p>一致的尺寸意味着尺寸在各种星型图案中的设计相同。一致的维度在多个星上一致地使用相同的值，列名和数据类型。只要较短表中的行是较大表的真实子集，一致维度就不必在维度表的每个模式副本中包含相同数量的行。</p>
                     </div>
                     <!-- class="section" -->
                     <div class="section" id="GUID-787CD3B1-0131-47F4-A904-4F7221A29448__CIHEGEGE">
                        <p class="subhead3" id="GUID-787CD3B1-0131-47F4-A904-4F7221A29448__GUID-DC7F38AC-F5EF-41A1-968C-EA6117BB7DA7">一致的事实</p>
                        <p>如果多个事实表中的事实列具有完全相同的含义，则它们被视为符合事实。这些事实可以在计算中可靠地一起使用，即使它们来自不同的表格。符合要求的事实应具有相同的列名，以表明其符合的状态。不符合要求的事实应始终使用不同的名称来突出其不同的含义。</p>
                     </div>
                     <!-- class="section" -->
                     <div class="section" id="GUID-787CD3B1-0131-47F4-A904-4F7221A29448__CIHEIJJC">
                        <p class="subhead3" id="GUID-787CD3B1-0131-47F4-A904-4F7221A29448__GUID-6BE11CAB-499A-494F-AB56-C3F7BCAF40BF">代理键</p>
                        <p>对于维度表，建议使用代理或人工密钥，通常是顺序整数。通过使用代理键，数据与操作变化隔离。而且，紧凑的整数键可以允许比大而复杂的字母数字键更好的性能。</p>
                     </div>
                     <!-- class="section" -->
                     <div class="section">
                        <p class="subhead3" id="GUID-787CD3B1-0131-47F4-A904-4F7221A29448__GUID-9CDA668A-8912-488F-8D9C-2B4029B5A088">退化维度</p>
                        <p id="GUID-787CD3B1-0131-47F4-A904-4F7221A29448__CIHDFJEG">退化维度是事实表中的维度列，不会连接到维度表。它们通常是订单号和发票号等项目。当事实表的粒度处于订单行项目或单个事务的级别时，您将看到它们。</p>
                     </div>
                     <!-- class="section" -->
                     <div class="section" id="GUID-787CD3B1-0131-47F4-A904-4F7221A29448__CIHHIGFH">
                        <p class="subhead3" id="GUID-787CD3B1-0131-47F4-A904-4F7221A29448__GUID-CA40ACAC-B824-445E-AA56-4FD567B5746C">垃圾尺寸</p>
                        <p>垃圾维度是抽象维度表，用于保存事实表中的标志和代码的文本查找值。这些尺寸被称为垃圾，不是因为它们价值低，而是因为它们为了方便而装有各种各样的列，类似于家中“垃圾抽屉”的想法。垃圾维度表中每列的不同值（基数）的数量通常很小。</p>
                     </div>
                     <!-- class="section" -->
                     <div class="section" id="GUID-787CD3B1-0131-47F4-A904-4F7221A29448__CIHIFGHD">
                        <p class="subhead3" id="GUID-787CD3B1-0131-47F4-A904-4F7221A29448__GUID-39D088B4-9AD9-4317-B242-2D6A42FE8BA8">嵌入式层次结构</p>
                        <p>使用星型模式的经典维度建模主张每个表包含单个粒度的数据。但是，在某些情况下，设计人员会选择在表格中包含多个颗粒，这些通常表示汇总层次结构。例如，单个销售事实表可能包含事务级数据，然后是按产品的日级汇总，然后是按产品的月级汇总。在这种情况下，事实表将需要包含一个级别列，指示应用于每一行的层次结构级别，并且针对该表的查询将需要包括级别谓词。</p>
                     </div>
                     <!-- class="section" -->
                     <div class="section" id="GUID-787CD3B1-0131-47F4-A904-4F7221A29448__CIHFBFFH">
                        <p class="subhead3" id="GUID-787CD3B1-0131-47F4-A904-4F7221A29448__GUID-36FA5EB0-4F89-436F-95D4-A6BC8563BF24">无事实的事实表</p>
                        <p>无事实的事实表不包含销售价格或销售数量等措施。相反，无事实事实表的行用于显示未由其他事实表表示的事件。无事实表的另一种用途是作为“覆盖表”，其保存在给定情况下可能发生的所有可能事件，例如作为促销的一部分并且可能以促销价格出售的所有产品。</p>
                     </div>
                     <!-- class="section" -->
                     <div class="section" id="GUID-787CD3B1-0131-47F4-A904-4F7221A29448__CIHHHCGF">
                        <p class="subhead3" id="GUID-787CD3B1-0131-47F4-A904-4F7221A29448__GUID-B45F2AC4-B7F9-4C45-BDAB-620A3F445816">慢慢改变尺寸</p>
                        <p>数据仓库的一个确定性是数据分类的方式会发生变化。产品名称和类别名称将更改。商店的特征会发生变化。销售区域中包含的区域将发生变化。这些变化的时间和程度并不总是可预测的。如何处理这些缓慢变化的尺寸？星型模式主要以三种方式对待它们：</p>
                        <ul style="list-style-type:disc">
                           <li>
                              <p>输入1</p>
                              <p>更改的维度值将被覆盖，不会保留历史记录。这为基于时间的分析带来了问题。此外，它会使依赖于维度旧值的任何现有聚合无效。</p>
                           </li>
                           <li>
                              <p>类型2</p>
                              <p>当维度值更改时，将创建一个显示新值并具有新代理键的新维度行。您可以选择在我们的维度中包含日期列，以显示新行何时有效以及何时过期。不需要对事实表进行任何更改。</p>
                           </li>
                           <li>
                              <p>输入3</p>
                              <p>更改维值时，先前值存储在同一行的不同列中。如果要使用列的当前值和先前值比较结果，则可以轻松生成查询。</p>
                           </li>
                        </ul>
                        <p>在实践中，2型是缓慢变化尺寸的最常见治疗方法。</p>
                     </div>
                     <!-- class="section" -->
                  </div>
               </div><a id="DWHSG9250"></a><a id="DWHSG9249"></a><div class="props_rev_3"><a id="GUID-B88263A2-708E-4750-9CE5-273F03B233DD" name="GUID-B88263A2-708E-4750-9CE5-273F03B233DD"></a><h4 id="DWHSG-GUID-B88263A2-708E-4750-9CE5-273F03B233DD" class="sect4"><span class="enumeration_section">2.4.3</span>关于雪花模式</h4>
                  <div>
                     <p>雪花模式<a id="d7845e659" class="indexterm-anchor"></a>是一种比星型模式更复杂的数据仓库模型，它是一种星型模式。它被称为雪花模式，因为模式图类似于雪花。
                     </p>
                     <p>雪花模式规范化维度以消除冗余。也就是说，维度数据已被分组为多个表而不是一个大表。例如，星型模式中的产品维度表可以规范化为雪花模式中的<code class="codeph">products</code>表， <code class="codeph">product_category</code>表和<code class="codeph">product_manufacturer</code>表。虽然这节省了空间，但它增加了维度表的数量并需要更多的外键连接<a id="d7845e673" class="indexterm-anchor"></a> 。结果是更复杂的查询<a id="d7845e680" class="indexterm-anchor"></a><a id="d7845e684" class="indexterm-anchor"></a>并降低了查询性能。<a href="data-warehouse-logical-design.html#GUID-B88263A2-708E-4750-9CE5-273F03B233DD__BABCJCBB">图2-3</a>显示了雪花模式的图形表示。
                     </p>
                     <div class="figure" id="GUID-B88263A2-708E-4750-9CE5-273F03B233DD__BABCJCBB">
                        <p class="titleinfigure">图2-3雪花模式</p><img src="img/td008.gif" alt="下面是图2-3的描述" title="下面是图2-3的描述" longdesc="img_text/td008.html"><br><a href="img_text/td008.html">“图2-3雪花模式”的描述</a></div>
                     <!-- class="figure" -->
                  </div>
               </div>
            </div>
            <div class="sect2"><a id="GUID-43410030-C84A-4978-B286-6A3361D172FB" name="GUID-43410030-C84A-4978-B286-6A3361D172FB"></a><h3 id="DWHSG-GUID-43410030-C84A-4978-B286-6A3361D172FB" class="sect3"><span class="enumeration_section">2.5</span>使用内存中的列存储改进了分析</h3>
               <div>
                  <p>内存中列存储（IM列存储）是系统全局区域（SGA）的可选部分，它以压缩的列式格式存储表，表分区和其他数据库对象的副本，该格式针对快速扫描进行了优化。</p>
                  <p></p>
                  <p>柱状格式很容易适用于矢量处理，从而使聚合，连接和某些类型的数据检索比传统的磁盘格式更快。列式格式仅存在于内存中，不会替换磁盘或缓冲区高速缓存格式。相反，它补充了缓冲区缓存，并提供了独立于磁盘格式的表的附加事务一致副本。</p>
                  <p>传统分析具有某些限制或要求，需要对其进行管理才能获得分析查询的良好性能。您需要了解用户访问模式，然后自定义数据结构，以便为这些访问模式提供最佳性能。需要调整现有索引，物化视图和OLAP多维数据集。某些数据集市和报告数据库具有复杂的ETL，因此需要专门的调整。此外，您需要在对陈旧数据执行分析和减慢生产数据库上的OLTP操作之间取得平衡。</p>
                  <p>Oracle数据库中的Oracle内存中列存储（IM列存储）为即时查询和实时数据分析提供了改进的性能。实时事务数据库用于提供查询的即时答案，从而使您能够无缝地使用相同的数据库进行OLTP事务和数据仓库分析。</p>
                  <p>IM列存储与Oracle数据库无缝集成，在数据仓库环境中提供以下优势：</p>
                  <ul style="list-style-type:disc">
                     <li>
                        <p>改进了查询性能</p>
                        <ul style="list-style-type:disc">
                           <li>
                              <p>使用意外访问模式处理即席查询的速度更快</p>
                              <p>IM列存储提供了分析大量数据的快速吞吐量。查询表中列的子集可提供快速结果，因为只扫描特定数据分析任务所需的列。</p>
                           </li>
                           <li>
                              <p>使用SIMD矢量处理，扫描大量行以及使用运算符（如=，&lt;，&gt;和IN）的过滤器的应用速度更快</p>
                           </li>
                           <li>
                              <p></p>
                              <p>使用IM表达式存储经常评估的表达式可减少相同表达式的重复计算</p>
                           </li>
                           <li>
                              <p></p>
                              <p>使用IM虚拟列并将指定的虚拟列填充到IM列存储中可避免重复评估虚拟列</p>
                           </li>
                        </ul>
                     </li>
                     <li>
                        <p>使用bloom过滤器增强连接性能</p>
                        <p>当正在连接的表存储在IM列存储中时，某些类型的连接运行得更快。IM列存储利用具有散列连接的bloom过滤器，通过将小维度表上的谓词转换为大型事实表上的过滤器来加速连接。</p>
                     </li>
                     <li>
                        <p>使用<code class="codeph">VECTOR GROUP BY</code>转换和矢量数组处理进行高效聚合</p>
                        <p>聚合数据并将一个或多个相对较小的表连接到较大的表的查询（通常在星型查询中发生）运行得更快。优化程序将根据成本估算选择VECTOR GROUP BY。</p>
                     </li>
                     <li>
                        <p>减少存储空间并显着减少处理开销，因为使用IM列存储时需要更少的索引，物化视图和OLAP多维数据集。</p>
                     </li>
                  </ul>
                  <div class="infoboxnotealso" id="GUID-43410030-C84A-4978-B286-6A3361D172FB__GUID-34A0519B-5AF8-4C4E-BE5F-B1590D2C5D27">
                     <p class="notep1">也可以看看：</p>
                     <p>有关使用IM列存储的详细信息，请<a href="../inmem/optimizing-in-memory-aggregation.html#INMEM-GUID-2C4FA6C6-3DA8-4CEA-9EF0-294396D15077" target="_blank"><span><cite>参见“Oracle数据库内存指南”</cite></span></a></p>
                  </div>
               </div>
               <div class="sect3"><a id="GUID-5FFB571F-A173-4270-9451-AC677C963C37" name="GUID-5FFB571F-A173-4270-9451-AC677C963C37"></a><h4 id="DWHSG-GUID-5FFB571F-A173-4270-9451-AC677C963C37" class="sect4"><span class="enumeration_section">2.5.1</span>关于使用内存表达式提高查询性能</h4>
                  <div>
                     <p>使用内存中列存储（IM列存储）时，可以通过对经常计算的表达式使用内存表达式（IM表达式）来进一步增强查询性能。</p>
                     <p>数据仓库环境中的大多数查询都涉及查询大型数据集，并且计算密集，因为它们包含复杂的表达式或计算。IM表达式为包含经常评估的表达式的查询提供增强的性能。优化程序自动识别并记录表达式统计信息存储（ESS）中重复使用的表达式。在ESS中捕获的表达式是IM表达式的候选者。为了便于重用，IM表达式被实现并填充到IM列存储中的内存表达单元（IMEU）中。然后，数据库维护IM表达式，并确保它们与对这些表达式所基于的源列所做的任何修改一致。将IM表达式填充到IM列存储中可减少相同表达式的重复计算。</p>
                     <p>例如，总成本是价格和销售单位数量的乘积，是IM表达的候选者。如果没有IM表达式，则需要为每个查询以及查询返回的每一行重新计算总成本的值。使用IM表达式，可以实现这种经常评估的表达式并将其存储在IM列存储中。这消除了重复重新计算查询中使用的表达式的需要。Oracle数据库在运行时重写查询以使用存储在IM列存储中的表达式结果，从而提高查询性能。</p>
                     <p>初始化参数<code class="codeph">INMEMORY_EXPRESSIONS_USAGE</code>控制必须将哪些IM表达式填充到IM列存储中。<code class="codeph">DBMS_INMEMORY_ADMIN</code>包中的过程指定何时标识，填充和使用IM表达式。
                     </p>
                  </div>
                  <div>
                     <div class="relinfo">
                        <p><strong>相关话题</strong></p>
                        <ul>
                           <li><a href="../inmem/optimizing-in-memory-expressions.html#INMEM-GUID-5F82168D-A024-4F96-B3AF-7DA4C52908B8" target="_blank"><span><cite>Oracle数据库内存指南</cite></span></a></li>
                        </ul>
                     </div>
                  </div>
               </div>
               <div class="sect3"><a id="GUID-93074D67-C6EC-4BF1-B0E4-29EEE30F1694" name="GUID-93074D67-C6EC-4BF1-B0E4-29EEE30F1694"></a><h4 id="DWHSG-GUID-93074D67-C6EC-4BF1-B0E4-29EEE30F1694" class="sect4"><span class="enumeration_section">2.5.2</span>关于使用内存虚拟列提高查询性能</h4>
                  <div>
                     <p>使用内存中列存储（IM列存储）时，内存中虚拟列（IM虚拟列）使您可以通过将指定的虚拟列填充到IM列存储中来避免重复评估虚拟列。</p>
                     <p>虚拟列是用户创建的，命名表达式，Oracle将其视为常规列。例如，如果<code class="codeph">SALARY</code>表中包含列<code class="codeph">monthly_salary</code> ，您可以定义称为虚拟列<code class="codeph">annual_salary</code>作为<code class="codeph">monthly_salary</code> * 12。IM虚拟列是可以填充到IM列存储中的虚拟列。您可以将表中定义的全部或部分虚拟列填充到IM列存储中。在IM列存储中存储预先计算的虚拟列可以避免重复评估，从而提高查询性能。还可以使用诸如SIMD向量处理之类的内存技术来扫描和过滤虚拟列值。
                     </p>
                     <p>初始化参数<code class="codeph">INMEMORY_VIRTUAL_COLUMNS</code>确定是否必须为为IM列存储启用的表创建IM虚拟列。
                     </p>
                  </div>
                  <div>
                     <div class="relinfo">
                        <p><strong>相关话题</strong></p>
                        <ul>
                           <li><a href="../inmem/populating-objects-in-memory.html#INMEM-GUID-452D19AE-EB5F-44AC-A1AD-70CF10D2D347" target="_blank"><span><cite>Oracle数据库内存指南</cite></span></a></li>
                        </ul>
                     </div>
                  </div>
               </div>
               <div class="sect3"><a id="GUID-A764A973-A635-483C-8C6A-10B30AD4E3E6" name="GUID-A764A973-A635-483C-8C6A-10B30AD4E3E6"></a><h4 id="DWHSG-GUID-A764A973-A635-483C-8C6A-10B30AD4E3E6" class="sect4"><span class="enumeration_section">2.5.3</span>关于内存中列存储和自动数据优化</h4>
                  <div>
                     <p>自动数据优化（ADO）可用于管理内存中列存储（IM列存储）的内容。</p>
                     <p>通过有效管理IM列存储的内容，可以优化IM列存储提供的性能优势。必须保留最有益于存储在IM列存储中的对象。这需要持续监视IM列存储，以确定必须保留哪些对象以及必须从IM列存储中删除哪些对象。</p>
                     <p>自动数据优化（ADO）自动管理IM列存储内容。为IM列存储中的对象收集热图统计信息，这些统计信息用于确定最不活跃的对象和最活跃的对象。您可以定义ADO策略以指定何时有资格将对象移出IM列存储。</p>
                     <p></p>
                     <p>在数据仓库应用程序中，访问对象的频率通常会随着时间的推移而降低。因此，在首次将对象加载到数据仓库中时，会最频繁地访问对象，并且随后活动级别会降低。通过定义ADO策略可以增强数据仓库性能，这些策略可以移动最少访问IM列存储的对象。</p>
                  </div>
                  <div>
                     <div class="relinfo">
                        <p><strong>相关话题</strong></p>
                        <ul>
                           <li><a href="../inmem/configuring-memory-management.html#INMEM-GUID-895C9AF1-7FD3-47D2-B8E7-079A39A88068" target="_blank"><span><cite>Oracle数据库内存指南</cite></span></a></li>
                        </ul>
                     </div>
                  </div>
               </div>
            </div><a id="DWHSG9327"></a><div class="props_rev_3"><a id="GUID-BD54F705-627B-4460-AB83-AFA992D8798C" name="GUID-BD54F705-627B-4460-AB83-AFA992D8798C"></a><h3 id="DWHSG-GUID-BD54F705-627B-4460-AB83-AFA992D8798C" class="sect3"><span class="enumeration_section">2.6</span>自动大表缓存提高内存并行查询的性能</h3>
               <div>
                  <p>自动<a id="d7845e934" class="indexterm-anchor"></a>大表缓存增强了Oracle数据库的内存查询功能。当表不适合内存时，数据库根据访问模式决定要缓存哪些缓冲区。这为大型表提供了有效的缓存，即使它们不完全适合缓冲区缓存。
                  </p>
                  <p>缓冲区高速缓存的可选部分（称为大表高速缓存）用于存储表扫描的数据。大表缓存与缓冲区缓存集成，并使用基于温度的对象级替换算法来管理大表缓存内容。这与缓冲区高速缓存使用的基于访问的块级LRU算法不同。</p>
                  <div class="infoboxnote" id="GUID-BD54F705-627B-4460-AB83-AFA992D8798C__GUID-781FCD0A-43A3-48C8-81E4-DE5C22392116">
                     <p class="notep1">注意：</p>
                     <p>从Oracle Database 12 <span class="italic">c</span>第1版（12.1.0.2）开始，可以使用自动大表缓存功能。
                     </p>
                  </div>
                  <p>典型的数据仓库工作负载扫描多个表。如果这些表的组合大小大于缓冲区高速缓存的组合大小，则性能可能会受到影响。使用自动大表缓存，扫描的表存储在大表缓存中而不是缓冲区缓存中。大表缓存使用的基于温度的对象级替换算法可以通过以下方式为数据仓库工作负载提供增强的性能：</p>
                  <ul style="list-style-type:disc">
                     <li>
                        <p>有选择地缓存“热”对象</p>
                        <p>每次访问对象时，Oracle数据库都会增加该对象的温度。大表缓存中的对象只能由温度高于其自身温度的另一个对象替换。</p>
                     </li>
                     <li>
                        <p>避免颠簸</p>
                        <p>当对象无法完全缓存时，将缓存部分对象。</p>
                     </li>
                  </ul>
                  <p>在Oracle Real Application Clusters（Oracle RAC）环境中，仅支持并行查询的自动大表缓存。在单实例环境中，串行和并行查询都支持此功能。</p>
                  <p>要使用自动大表缓存，必须启用大表缓存。要对串行查询使用自动大表缓存，必须将<code class="codeph">DB_BIG_TABLE_CACHE_PERCENT_TARGET</code>初始化参数设置为非零值。要对并行查询使用自动大表缓存，必须将<code class="codeph">PARALLEL_DEGREE_POLICY</code>设置为<code class="codeph">AUTO</code>或<code class="codeph">ADAPTIVE</code>并将<code class="codeph">DB_BIG_TABLE_CACHE_PERCENT_TARGET</code>设置为非零值。
                  </p>
                  <div class="infoboxnotealso" id="GUID-BD54F705-627B-4460-AB83-AFA992D8798C__GUID-F6834BA7-D22E-4EE2-96C0-5F3D2C8A248A">
                     <p class="notep1">也可以看看：</p>
                     <p>有关大表缓存及其使用方法的详细信息<a href="../vldbg/inmemory-parallel-exec.html#VLDBG-GUID-A553169D-C6CD-443E-88C3-B746D5E32923" target="_blank"><span><cite>，请参见“Oracle数据库VLDB和分区指南”</cite></span></a></p>
                  </div>
               </div>
            </div>
         </div>
      </article>
   </body>
</html>