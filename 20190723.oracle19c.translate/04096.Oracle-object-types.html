<html lang="en-us" dir="ltr" xml:lang="en-us">
   <head>
      <meta http-equiv="Content-Type" content="text/html; charset=utf-8"></meta>
      <meta name="viewport" content="width=device-width, initial-scale=1"></meta>
      <meta http-equiv="X-UA-Compatible" content="IE=edge"></meta>
      <title>使用Oracle对象类型</title>
      <meta property="og:site_name" content="Oracle Help Center"></meta>
      <meta property="og:title" content="JDBC Developer&#39;s Guide"></meta>
      <meta property="og:description" content=""></meta>
      <link rel="stylesheet" href="/sp_common/book-template/ohc-book-template/css/book.css"></link>
      <link rel="shortcut icon" href="/sp_common/book-template/ohc-common/img/favicon.ico"></link>
      <meta name="application-name" content="JDBC Developer&#39;s Guide"></meta>
      <meta name="generator" content="DITA Open Toolkit version 1.8.5 (Mode = doc)"></meta>
      <meta name="plugin" content="SP_docbuilder HTML plugin release 18.2.2"></meta>
      <link rel="alternate" href="jdbc-developers-guide.pdf" title="PDF File" type="application/pdf"></link>
      <meta name="robots" content="all"></meta>
      <link rel="schema.dcterms" href="http://purl.org/dc/terms/"></link>
      <meta name="dcterms.created" content="2019-02-13T13:20:37-08:00"></meta>
      <meta name="dcterms.title" content="JDBC Developer&#39;s Guide"></meta>
      <meta name="dcterms.dateCopyrighted" content="1999, 2019"></meta>
      <meta name="dcterms.category" content="database"></meta>
      <meta name="dcterms.identifier" content="E96471-02"></meta>
      
      <meta name="dcterms.product" content="en/database/oracle/oracle-database/19"></meta>
      
      <link rel="prev" href="Java-streams-in-JDBC.html" title="Previous" type="text/html"></link>
      <link rel="next" href="LOBs-and-BFiles.html" title="Next" type="text/html"></link>
      <script>
        document.write('<style type="text/css">');
        document.write('body > .noscript, body > .noscript ~ * { visibility: hidden; }');
        document.write('</style>');
     </script>
      <script src="/sp_common/book-template/requirejs/require.js" data-main="/sp_common/book-template/ohc-book-template/js/book-config"></script>
      <script>
            if (window.require === undefined) {
                document.write('<script data-main="sp_common/book-template/ohc-book-template/js/book-config" src="sp_common/book-template/requirejs/require.js"><\/script>');
                document.write('<link href="sp_common/book-template/ohc-book-template/css/book.css" rel="stylesheet"/>');
            }
        </script>
      <script type="application/json" id="ssot-metadata">{"primary":{"category":{"short_name":"database","element_name":"Database","display_in_url":true},"suite":{"short_name":"oracle","element_name":"Oracle","display_in_url":true},"product_group":{"short_name":"not-applicable","element_name":"Not applicable","display_in_url":false},"product":{"short_name":"oracle-database","element_name":"Oracle Database","display_in_url":true},"release":{"short_name":"19","element_name":"Release 19","display_in_url":true}}}</script>
      
    <meta name="dcterms.isVersionOf" content="JJDBC"></meta>
    <meta name="dcterms.release" content="Release 19"></meta>
  </head>
   <body dir="ltr">
      <div class="noscript alert alert-danger text-center" role="alert">
         <a href="Java-streams-in-JDBC.html" class="pull-left"><span class="glyphicon glyphicon-chevron-left" aria-hidden="true"></span>上一页</a> <a href="LOBs-and-BFiles.html" class="pull-right">下一页<span class="glyphicon glyphicon-chevron-right" aria-hidden="true"></span></a> <span class="fa fa-exclamation-triangle" aria-hidden="true"></span>必须启用JavaScript才能正确显示此内容</div>
      <article>
         <header>
            <ol class="breadcrumb" vocab="http://schema.org/" typeof="BreadcrumbList">
               <li property="itemListElement" typeof="ListItem"><a href="index.html" property="item" typeof="WebPage"><span property="name">JDBC开发人员指南</span></a></li>
               <li property="itemListElement" typeof="ListItem"><a href="data-access-and-manipulation.html" property="item" typeof="WebPage"><span property="name">数据访问和操作</span></a></li>
               <li class="active" property="itemListElement" typeof="ListItem">使用Oracle对象类型</li>
            </ol>
            <a id="GUID-5905674A-A045-40B1-96DE-726761517D50" name="GUID-5905674A-A045-40B1-96DE-726761517D50"></a><a id="JJDBC28431"></a>
            
            <h2 id="JJDBC-GUID-5905674A-A045-40B1-96DE-726761517D50" class="sect2"><span class="enumeration_chapter">13</span>使用Oracle对象类型</h2>
         </header>
         <div class="ind">
            <div>
               <p><a id="d51198e21" class="indexterm-anchor"></a><a id="d51198e25" class="indexterm-anchor"></a>本章介绍了对用户定义的对象类型的Java数据库连接（JDBC）支持。它讨论了泛型弱类型<code class="codeph">oracle.sql.STRUCT</code>类，以及如何映射到实现JDBC标准<code class="codeph">SQLData</code>接口或Oracle特定<code class="codeph">OracleData</code>接口的自定义Java类。
               </p>
               <div class="infoboxnote" id="GUID-5905674A-A045-40B1-96DE-726761517D50__GUID-B1E97578-48C4-47BA-8F99-B23594622084">
                  <p class="notep1">注意：</p>
                  <p>从Oracle Database 12 <span class="italic">c</span>第1版（12.1）开始， <code class="codeph">oracle.sql.不推荐使用STRUCT</code>类，并将其替换为<code class="codeph">oracle.jdbc.OracleStruct</code>接口，它是<code class="codeph">oracle.jdbc</code>包的一部分。Oracle强烈建议您尽可能使用<code class="codeph">java.sql</code>包中提供的方法，以获得Oracle特定扩展的<code class="codeph">oracle.jdbc</code>包中提供的标准兼容性和方法。有关<code class="codeph">oracle.jdbc.更多信息，请参阅MoS Note 1364193.1 <code class="codeph">oracle.jdbc.OracleStruct</code>接口。
                  </p>
               </div>
               <p>涵盖以下主题：</p>
               <ul style="list-style-type:disc">
                  <li>
                     <p><a href="Oracle-object-types.html#GUID-D8784F68-C051-4068-9F34-23913C6733F7">关于映射Oracle对象</a></p>
                  </li>
                  <li>
                     <p><a href="Oracle-object-types.html#GUID-962C3E5C-1208-4A63-8130-6347ED9231C5">关于为Oracle Objects使用默认STRUCT类</a></p>
                  </li>
                  <li>
                     <p><a href="Oracle-object-types.html#GUID-0128E185-086F-41CD-BECC-63A42EBB142C">关于为Oracle Objects创建和使用自定义对象类</a></p>
                  </li>
                  <li>
                     <p><a href="Oracle-object-types.html#GUID-E47B8141-3C4C-44D5-BB5C-2F8E16DF5140">对象类型继承</a></p>
                  </li>
                  <li>
                     <p><a href="Oracle-object-types.html#GUID-4D737F6A-66F6-4C67-BC9A-233A89F75FFD">关于描述对象类型</a></p>
                  </li>
               </ul>
            </div>
            <div>
               <div class="relinfo">
                  <p><strong>相关话题</strong></p>
                  <ul>
                     <li><a href="JDBC-reference-information.html#GUID-E77C2AE8-E22B-48BF-A4CB-010CBC8FE7C2">关于使用PL / SQL类型</a></li>
                  </ul>
               </div>
            </div>
            <a id="JJDBC28432"></a><div class="props_rev_3"><a id="GUID-D8784F68-C051-4068-9F34-23913C6733F7" name="GUID-D8784F68-C051-4068-9F34-23913C6733F7"></a><h3 id="JJDBC-GUID-D8784F68-C051-4068-9F34-23913C6733F7" class="sect3"><span class="enumeration_section">13.1</span>关于映射Oracle对象</h3>
               <div>
                  <p><a id="d51198e132" class="indexterm-anchor"></a> Oracle对象类型为数据库中的复合数据结构提供支持。例如，你可以定义一个<code class="codeph">Person</code>具有的属性种类<code class="codeph">name</code>的<code class="codeph">CHAR</code>类型， <code class="codeph">phoneNumber</code>的<code class="codeph">CHAR</code>类型， <code class="codeph">employeeNumber</code>的<code class="codeph">NUMBER</code>类型。
                  </p>
                  <p>Oracle提供了它之间的紧密集成<a id="d51198e161" class="indexterm-anchor"></a> Oracle对象功能及其JDBC功能。您可以使用标准的通用JDBC类型映射到Oracle对象，也可以通过创建自定义Java类型定义类来自定义映射。
                  </p>
                  <div class="infoboxnote" id="GUID-D8784F68-C051-4068-9F34-23913C6733F7__GUID-B09543A0-045B-479D-9B64-428E41E216A2">
                     <p class="notep1">注意：</p>
                     <p>在本书中，您创建用于映射到Oracle对象的<span class="bold">Java类</span>将称为<span class="bold">自定义Java类，</span>或者更具体地说，称为<span class="bold">自</span> <span class="bold">定义对象类</span> 。这与<span class="bold">自定义引用类</span>相反，后者是映射到对象引用的Java类，而<span class="bold">自定义集合</span>类是映射到Oracle集合的Java类。
                     </p>
                  </div>
                  <p>自定义对象类可以实现标准JDBC接口或Oracle扩展接口来读取和写入数据。JDBC将Oracle对象实现为特定Java类的实例。使用JDBC访问Oracle对象的两个主要步骤是：</p>
                  <ol>
                     <li>
                        <p>为Oracle对象创建Java类</p>
                     </li>
                     <li>
                        <p>填充这些类。您有以下选择：</p>
                        <ul style="list-style-type:disc">
                           <li>
                              <p>让JDBC将对象实现为<code class="codeph">STRUCT</code>对象。
                              </p>
                           </li>
                           <li>
                              <p>明确指定Oracle对象和Java类之间的映射。</p>
                              <p>这包括为对象数据自定义Java类。然后，驱动程序必须能够填充您指定的自定义对象类的实例。这对Java类施加了一组约束。要满足这些约束，您可以定义类以实现JDBC标准<code class="codeph">java.sql.SQLData</code>接口或Oracle扩展<code class="codeph">oracle.jdbc.OracleData</code>接口。
                              </p>
                           </li>
                        </ul>
                     </li>
                  </ol>
                  <div class="infoboxnote" id="GUID-D8784F68-C051-4068-9F34-23913C6733F7__GUID-C5780BA8-94EA-4BF8-AA6D-635D3AD80796">
                     <p class="notep1">注意：</p>
                     <p>使用<code class="codeph">SQLData</code>接口时，必须使用Java类型映射来指定SQL-Java映射，除非弱类型的<code class="codeph">java.sql.Struct</code>对象就足够了。
                     </p>
                  </div>
               </div>
            </div><a id="JJDBC28433"></a><div class="props_rev_3"><a id="GUID-962C3E5C-1208-4A63-8130-6347ED9231C5" name="GUID-962C3E5C-1208-4A63-8130-6347ED9231C5"></a><h3 id="JJDBC-GUID-962C3E5C-1208-4A63-8130-6347ED9231C5" class="sect3"><span class="enumeration_section">13.2</span>关于使用Oracle Objects的默认STRUCT类</h3>
               <div>
                  <p>本节包括以下主题：</p>
                  <ul style="list-style-type:disc">
                     <li>
                        <p><a href="Oracle-object-types.html#GUID-21636EC9-B321-43A8-AAED-0329A8371D5C">使用Struct类的概述</a></p>
                     </li>
                     <li>
                        <p><a href="Oracle-object-types.html#GUID-13EB6E85-4356-4653-9822-855691AACC4A">检索STRUCT对象和属性</a></p>
                     </li>
                     <li>
                        <p><a href="Oracle-object-types.html#GUID-00F1EBB3-B60F-4897-BA00-4889A320B74B">关于创建STRUCT对象</a></p>
                     </li>
                     <li>
                        <p><a href="Oracle-object-types.html#GUID-CCEADA36-E70A-42A9-A55C-9D7BD1BBABBF">将STRUCT对象绑定到语句中</a></p>
                     </li>
                     <li>
                        <p><a href="Oracle-object-types.html#GUID-DB4B241E-7C22-4585-A42D-80097D5ADA74">STRUCT自动属性缓冲</a></p>
                     </li>
                  </ul>
               </div>
               <div class="props_rev_3"><a id="GUID-21636EC9-B321-43A8-AAED-0329A8371D5C" name="GUID-21636EC9-B321-43A8-AAED-0329A8371D5C"></a><h4 id="JJDBC-GUID-21636EC9-B321-43A8-AAED-0329A8371D5C" class="sect4"><span class="enumeration_section">13.2.1</span>使用Struct类的概述</h4>
                  <div>
                     <p>如果您选择不为您的SQL-Java映射提供自定义Java类<a id="d51198e291" class="indexterm-anchor"></a> Oracle对象，然后Oracle JDBC将对象实现为实现<code class="codeph">java.sql.的对象<code class="codeph">java.sql.Struct</code>界面。
                     </p>
                     <p>在不了解实际SQL类型的情况下，通常需要使用<code class="codeph">STRUCT</code>对象而不是自定义Java对象。例如，您的Java应用程序可能是一种在数据库中操纵任意对象数据的工具，而不是最终用户应用程序。您可以从数据库中选择数据到<code class="codeph">STRUCT</code>对象中，并创建<code class="codeph">STRUCT</code>对象以将数据插入数据库。<code class="codeph">STRUCT</code>对象完全保留数据，因为它们以SQL格式维护数据。在不需要特定于应用程序的表单中的信息的情况下，使用<code class="codeph">STRUCT</code>对象更有效，更精确。
                     </p>
                  </div>
               </div><a id="JJDBC28440"></a><a id="JJDBC28441"></a><a id="JJDBC28442"></a><a id="JJDBC28438"></a><div class="props_rev_3"><a id="GUID-13EB6E85-4356-4653-9822-855691AACC4A" name="GUID-13EB6E85-4356-4653-9822-855691AACC4A"></a><h4 id="JJDBC-GUID-13EB6E85-4356-4653-9822-855691AACC4A" class="sect4"><span class="enumeration_section">13.2.2</span>检索STRUCT对象和属性</h4>
                  <div>
                     <div class="section">
                        <p>本节讨论如何使用Oracle特定功能或JDBC 2.0标准功能检索和操作Oracle对象及其属性。</p>
                        <div class="infoboxnote" id="GUID-13EB6E85-4356-4653-9822-855691AACC4A__GUID-17EBE907-B787-44CB-B28D-A12B6F008756">
                           <p class="notep1">注意：</p>
                           <p>JDBC驱动无缝地处理嵌入的对象，也就是<code class="codeph">STRUCT</code>是的属性的对象<code class="codeph">STRUCT</code>目的，以同样的方式，它通常处理的对象。当JDBC驱动程序检索作为对象的属性时，它通过使用类型映射（如果可用）或使用默认映射遵循相同的转换规则。
                           </p>
                        </div>
                     </div>
                     <!-- class="section" -->
                     <div class="section">
                        <p class="subhead3" id="GUID-13EB6E85-4356-4653-9822-855691AACC4A__GUID-965D536C-AFEB-45FB-ABBF-FE15907496E3">将Oracle对象检索为java.sql。结构对象</p>
                     </div>
                     <!-- class="section" -->
                     <div class="section">
                        <p>或者，在前面的示例中，您可以使用标准JDBC功能（如<code class="codeph">getObject</code>从数据库中检索Oracle对象作为<code class="codeph">java.sql.的实例<code class="codeph">java.sql.Struct</code> 。<code class="codeph">getObject</code>方法返回<code class="codeph">java.lang.Object</code> ，因此，必须将方法的输出<code class="codeph">Struct</code>为<code class="codeph">Struct</code> 。例如：</p><pre class="oac_no_warn" dir="ltr">ResultSet rs = stmt.executeQuery（“SELECT * FROM struct_table”）; java.sql中。struct jdbcStruct =（java.sql。结构）rs.getObject（1）;</pre></div>
                     <!-- class="section" -->
                     <div class="section">
                        <p class="subhead3" id="GUID-13EB6E85-4356-4653-9822-855691AACC4A__GUID-86188575-F0AA-49E0-96D9-89FE34C79F42">将属性检索为oracle.sql类型</p>
                     </div>
                     <!-- class="section" -->
                     <div class="section">
                        <p>如果要从<code class="codeph">STRUCT</code>或<code class="codeph">Struct</code>实例检索Oracle对象属性为<code class="codeph">oracle.sql</code>类型，则使用<code class="codeph">oracle.sql</code>的<code class="codeph">getOracleAttributes</code>方法<code class="codeph">oracle.sql.STRUCT</code>类，如下：</p><pre class="oac_no_warn" dir="ltr">oracle.sql。Datum [] attrs = oracleSTRUCT.getOracleAttributes（）;</pre><p>要么：</p><pre class="oac_no_warn" dir="ltr">oracle.sql。Datum [] attrs =（（oracle.sql。STRUCT）jdbcStruct）.getOracleAttributes（）;</pre></div>
                     <!-- class="section" -->
                     <div class="section">
                        <p class="subhead3" id="GUID-13EB6E85-4356-4653-9822-855691AACC4A__GUID-F986D1A3-26E0-4C7C-9DEC-1D37A1AE7C62">将属性检索为标准Java类型</p>
                     </div>
                     <!-- class="section" -->
                     <div class="section">
                        <p>如果要从<code class="codeph">STRUCT</code>或<code class="codeph">Struct</code>实例检索Oracle对象属性作为标准Java类型，请使用标准<code class="codeph">getAttributes</code>方法：</p><pre class="oac_no_warn" dir="ltr">Object [] attrs = jdbcStruct.getAttributes（）;</pre><div class="infoboxnote" id="GUID-13EB6E85-4356-4653-9822-855691AACC4A__GUID-66694E99-A661-4419-B99A-CF44489256FA">
                           <p class="notep1">注意：</p>
                           <p>Oracle JDBC驱动程序缓存数组和结构描述符。这提供了巨大的性能优势。但是，这意味着如果更改数据库中结构类型的基础类型定义，则该结构类型的高速缓存描述符将变为陈旧，并且您的应用程序将收到<code class="codeph">SQLException</code>异常。
                           </p>
                        </div>
                     </div>
                     <!-- class="section" -->
                  </div>
               </div><a id="JJDBC28443"></a><div class="props_rev_3"><a id="GUID-00F1EBB3-B60F-4897-BA00-4889A320B74B" name="GUID-00F1EBB3-B60F-4897-BA00-4889A320B74B"></a><h4 id="JJDBC-GUID-00F1EBB3-B60F-4897-BA00-4889A320B74B" class="sect4"><span class="enumeration_section">13.2.3</span>关于创建STRUCT对象</h4>
                  <div>
                     <div class="section">
                        <p>有关创建STRUCT对象的信息，请参阅<span class="q">“ <a href="Oracle-extensions.html#GUID-DB1F687A-CF1C-4B3F-92C0-126DC782EF53">Package oracle.sql</a> ”</span> 。
                        </p>
                        <div class="infoboxnote" id="GUID-00F1EBB3-B60F-4897-BA00-4889A320B74B__GUID-4967F80C-4684-405E-8CC9-F463938E45AE">
                           <p class="notep1">注意：</p>
                           <p>如果您已从数据库中获取了相应SQL对象类型的<code class="codeph">STRUCT</code> ，那么获取<code class="codeph">STRUCT</code>描述符的最简单方法是在其中一个获取的<code class="codeph">STRUCT</code>对象上调用<code class="codeph">getDescriptor</code> 。任何一种SQL对象类型只需要一个<code class="codeph">STRUCT</code>描述符。
                           </p>
                        </div>
                     </div>
                     <!-- class="section" -->
                  </div>
               </div><a id="JJDBC28447"></a><div class="props_rev_3"><a id="GUID-CCEADA36-E70A-42A9-A55C-9D7BD1BBABBF" name="GUID-CCEADA36-E70A-42A9-A55C-9D7BD1BBABBF"></a><h4 id="JJDBC-GUID-CCEADA36-E70A-42A9-A55C-9D7BD1BBABBF" class="sect4"><span class="enumeration_section">13.2.4将</span> STRUCT对象绑定到语句中</h4>
                  <div>
                     <div class="section">
                        <p>绑定<code class="codeph">oracle.sql.STRUCT</code>对象为STRUCT</code>准备语句或可调用语句，您可以使用该标准<a id="d51198e512" class="indexterm-anchor"></a> <code class="codeph">setObject</code>方法（指定类型代码），或将语句对象<code class="codeph">setOracleObject</code>转换为Oracle语句类型并使用Oracle扩展<code class="codeph">setOracleObject</code>方法。例如：</p><pre class="oac_no_warn" dir="ltr">PreparedStatement ps = conn.prepareStatement（“ <span class="italic">text_of_prepared_statement</span> ”）; Struct mySTRUCT = conn.createStruct（...）; ps.setObject（1，mySTRUCT，Types。结构）;</pre><p>要么：</p><pre class="oac_no_warn" dir="ltr">PreparedStatement ps = conn.prepareStatement（“ <span class="italic">text_of_prepared_statement</span> ”）; Struct mySTRUCT = conn.createStruct（...）; （（OraclePreparedStatement）ps）.setOracleObject（1，mySTRUCT）;</pre></div>
                     <!-- class="section" -->
                  </div>
               </div><a id="JJDBC28448"></a><div class="props_rev_3"><a id="GUID-DB4B241E-7C22-4585-A42D-80097D5ADA74" name="GUID-DB4B241E-7C22-4585-A42D-80097D5ADA74"></a><h4 id="JJDBC-GUID-DB4B241E-7C22-4585-A42D-80097D5ADA74" class="sect4"><span class="enumeration_section">13.2.5</span> STRUCT自动属性缓冲</h4>
                  <div>
                     <p>Oracle JDBC驱动程序提供公共方法来启用和禁用<code class="codeph">STRUCT</code>属性的缓冲。
                     </p>
                     <div class="infoboxnote" id="GUID-DB4B241E-7C22-4585-A42D-80097D5ADA74__GUID-37E8CBAC-3A75-4F1D-9E94-EB78E733BBC2">
                        <p class="notep1">注意：</p>
                        <p>从Oracle Database 12 <span class="italic">c</span>第1版（12.1）开始， <code class="codeph">oracle.sql.不推荐使用STRUCT</code>类，并将其替换为<code class="codeph">oracle.jdbc.OracleStruct</code>接口，它是<code class="codeph">oracle.jdbc</code>包的一部分。Oracle强烈建议您尽可能使用<code class="codeph">java.sql</code>包中提供的方法，以获得Oracle特定扩展的<code class="codeph">oracle.jdbc</code>包中提供的标准兼容性和方法。有关<code class="codeph">oracle.jdbc.更多信息，请参阅MoS Note 1364193.1 <code class="codeph">oracle.jdbc.OracleStruct</code>接口。
                        </p>
                     </div>
                     <p><code class="codeph">oracle.sql.包含以下方法<code class="codeph">oracle.sql.STRUCT</code>类：</p>
                     <ul style="list-style-type:disc">
                        <li>
                           <p><code class="codeph">public void setAutoBuffering（boolean enable）</code></p>
                        </li>
                        <li>
                           <p><code class="codeph">public boolean getAutoBuffering（）</code></p>
                        </li>
                     </ul>
                     <p><code class="codeph">setAutoBuffering(boolean)</code>方法启用或禁用自动缓冲。<code class="codeph">getAutoBuffering</code>方法返回当前的自动缓冲模式。默认情况下，禁用自动缓冲。
                     </p>
                     <p>当<code class="codeph">getAttributes</code>和<code class="codeph">getArray</code>方法多次访问<code class="codeph">STRUCT</code>属性时，建议在JDBC应用程序中启用自动缓冲，假设<code class="codeph">ARRAY</code>数据能够适应Java虚拟机（JVM）内存而不会溢出。
                     </p>
                     <div class="infoboxnote" id="GUID-DB4B241E-7C22-4585-A42D-80097D5ADA74__GUID-73296BC2-A877-4697-9CCB-6B499027AE8F">
                        <p class="notep1">注意：</p>
                        <p>缓冲转换后的属性可能会导致JDBC应用程序消耗大量内存。</p>
                     </div>
                     <p>启用自动缓冲时， <code class="codeph">oracle.sql.STRUCT</code>对象保留所有转换属性的本地副本。保留此数据，以便后续访问此信息不需要通过数据格式转换过程。
                     </p>
                  </div>
                  <div>
                     <div class="relinfo">
                        <p><strong>相关话题</strong></p>
                        <ul>
                           <li><a href="Oracle-collections.html#GUID-33CC8F2C-4E73-412B-990E-D4293173E199">ARRAY自动元素缓冲</a></li>
                        </ul>
                     </div>
                  </div>
                  
               </div>
            </div><a id="JJDBC28449"></a><div class="props_rev_3"><a id="GUID-0128E185-086F-41CD-BECC-63A42EBB142C" name="GUID-0128E185-086F-41CD-BECC-63A42EBB142C"></a><h3 id="JJDBC-GUID-0128E185-086F-41CD-BECC-63A42EBB142C" class="sect3"><span class="enumeration_section">13.3</span>关于为Oracle Objects创建和使用自定义对象类</h3>
               <div>
                  <p>本节包括以下主题：</p>
                  <ul style="list-style-type:disc">
                     <li>
                        <p><a href="Oracle-object-types.html#GUID-CB167A20-2A94-4066-80CC-E5577698394E">创建和使用自定义对象类概述</a></p>
                     </li>
                     <li>
                        <p><a href="Oracle-object-types.html#GUID-47ED704C-6F0C-485F-B6F0-56C65BC17CA3">OracleData与SQLData的相对优势</a></p>
                     </li>
                     <li>
                        <p><a href="Oracle-object-types.html#GUID-87716972-5BD5-4116-B706-DC8C13663342">关于SQLData实现的类型映射</a></p>
                     </li>
                     <li>
                        <p><a href="Oracle-object-types.html#GUID-6C176486-2299-408A-86D7-29033E593210">关于为SQLData实现创建类型映射和定义映射</a></p>
                     </li>
                     <li>
                        <p><a href="Oracle-object-types.html#GUID-6D44496F-0CAA-4034-AF55-00B39DE4C6E3">关于使用SQLData实现读取和写入数据</a></p>
                     </li>
                     <li>
                        <p><a href="Oracle-object-types.html#GUID-EEF1A8CA-354D-430B-9153-171849DE2525">关于OracleData接口</a></p>
                     </li>
                     <li>
                        <p><a href="Oracle-object-types.html#GUID-7E84EDB6-A403-475D-875B-CAA151436AF7">关于使用OracleData实现读取和写入数据</a></p>
                     </li>
                     <li>
                        <p><a href="Oracle-object-types.html#GUID-1CC46DF9-95F1-4892-8C25-9B3BBD36CFFF">OracleData的其他用途</a></p>
                     </li>
                  </ul>
               </div>
               <div class="props_rev_3"><a id="GUID-CB167A20-2A94-4066-80CC-E5577698394E" name="GUID-CB167A20-2A94-4066-80CC-E5577698394E"></a><h4 id="JJDBC-GUID-CB167A20-2A94-4066-80CC-E5577698394E" class="sect4"><span class="enumeration_section">13.3.1</span>创建和使用自定义对象类概述</h4>
                  <div>
                     <p>如果你想创造<a id="d51198e727" class="indexterm-anchor"></a>你的自定义对象类<a id="d51198e732" class="indexterm-anchor"></a>在Oracle对象中，您必须在中定义条目<a id="d51198e737" class="indexterm-anchor"></a> type map，指定驱动程序为相应的Oracle对象实例化的自定义对象类。
                     </p>
                     <p>您还必须提供一种从Oracle对象及其属性数据创建和填充自定义对象类的实例的方法。驱动程序必须能够从自定义对象类读取并写入它。此外，自定义对象类可以提供<code class="codeph">get</code> <span class="italic"><code class="codeph">XXX</code></span>并<code class="codeph">set</code>与Oracle对象的属性对应的<span class="italic"><code class="codeph">XXX</code></span>方法，尽管这不是必需的。要创建和填充自定义类并提供这些读/写功能，您可以选择以下接口：</p>
                     <ul style="list-style-type:disc">
                        <li>
                           <p>JDBC标准<code class="codeph">SQLData</code>接口</p>
                        </li>
                        <li>
                           <p>Oracle提供的<code class="codeph">OracleData</code>和<code class="codeph">OracleDataFactory</code>接口</p>
                        </li>
                     </ul>
                     <p>您创建的自定义对象类必须实现其中一个接口。<code class="codeph">OracleData</code>接口还可用于实现与自定义对象类对应的自定义引用类。但是，如果您使用的是<code class="codeph">SQLData</code>接口，那么您只能在Java中使用弱引用类型，例如<code class="codeph">java.sql.Ref</code>或<code class="codeph">oracle.sql.REF</code> 。 <code class="codeph">SQLData</code>接口仅用于映射SQL对象。
                     </p>
                     <p>例如，假设您在数据库中有一个Oracle对象类型<code class="codeph">EMPLOYEE</code> ，它包含两个属性： <code class="codeph">Name</code> ，它是<code class="codeph">CHAR</code>类型， <code class="codeph">EmpNum</code>是<code class="codeph">NUMBER</code>类型。您可以使用类型映射来指定<code class="codeph">EMPLOYEE</code>对象应映射到您调用<code class="codeph">JEmployee</code>的自定义对象类。您可以在<code class="codeph">JEmployee</code>类中实现<code class="codeph">SQLData</code>或<code class="codeph">OracleData</code>接口。
                     </p>
                  </div>
                  <div>
                     <div class="relinfo">
                        <p><strong>相关话题</strong></p>
                        <ul>
                           <li><a href="Oracle-object-types.html#GUID-E47B8141-3C4C-44D5-BB5C-2F8E16DF5140">对象类型继承</a></li>
                        </ul>
                     </div>
                  </div>
                  
               </div><a id="JJDBC28451"></a><a id="JJDBC28452"></a><a id="JJDBC28450"></a><div class="props_rev_3"><a id="GUID-47ED704C-6F0C-485F-B6F0-56C65BC17CA3" name="GUID-47ED704C-6F0C-485F-B6F0-56C65BC17CA3"></a><h4 id="JJDBC-GUID-47ED704C-6F0C-485F-B6F0-56C65BC17CA3" class="sect4"><span class="enumeration_section">13.3.2</span> OracleData与SQLData的相对优势</h4>
                  <div>
                     <div class="section">
                        <p>在决定使用哪两个接口实现时，您需要考虑<code class="codeph">OracleData</code>和<code class="codeph">SQLData</code>的优点。
                        </p>
                        <p><code class="codeph">SQLData</code>接口仅用于映射SQL对象。<code class="codeph">OracleData</code>接口更加灵活，使您可以映射SQL对象以及要为其自定义处理的任何其他SQL类型。您可以从Oracle数据库中的任何数据类型创建<code class="codeph">OracleData</code>实现。例如，这对于在Java中序列化<code class="codeph">RAW</code>数据可能很有用。
                        </p>
                     </div>
                     <!-- class="section" -->
                     <div class="section">
                        <p class="subhead3" id="GUID-47ED704C-6F0C-485F-B6F0-56C65BC17CA3__GUID-EEB125BD-14AC-4D41-B839-8F08EAAA21C8">OracleData接口的优点</p>
                     </div>
                     <!-- class="section" -->
                     <div class="section">
                        <p><code class="codeph">OracleData</code>接口的优点是：</p>
                        <ul style="list-style-type:disc">
                           <li>
                              <p>它不需要Oracle对象的类型映射中的条目。</p>
                           </li>
                           <li>
                              <p>它具有Oracle扩展的意识。</p>
                           </li>
                           <li>
                              <p>您可以从<code class="codeph">oracle.sql.构造<code class="codeph">OracleData</code> <code class="codeph">oracle.sql.STRUCT</code> 。这样更有效，因为它避免了对本机Java类型的不必要的转换。
                              </p>
                           </li>
                           <li>
                              <p>您可以使用<code class="codeph">toJDBCObject</code>方法从<code class="codeph">OracleData</code>获取相应的JDBC对象。
                              </p>
                           </li>
                        </ul>
                     </div>
                     <!-- class="section" -->
                     <div class="section">
                        <p class="subhead3" id="GUID-47ED704C-6F0C-485F-B6F0-56C65BC17CA3__GUID-0F39D4D3-FD8B-4496-8E33-8427DC9B44F1">SQLData的优点</p>
                     </div>
                     <!-- class="section" -->
                     <div class="section">
                        <p><code class="codeph">SQLData</code>是一种使您的代码可移植的JDBC标准。
                        </p>
                     </div>
                     <!-- class="section" -->
                  </div>
               </div><a id="JJDBC28453"></a><div class="props_rev_3"><a id="GUID-87716972-5BD5-4116-B706-DC8C13663342" name="GUID-87716972-5BD5-4116-B706-DC8C13663342"></a><h4 id="JJDBC-GUID-87716972-5BD5-4116-B706-DC8C13663342" class="sect4"><span class="enumeration_section">13.3.3</span>关于SQLData实现的类型映射</h4>
                  <div>
                     <div class="section">
                        <p>如果在自定义对象类中使用<code class="codeph">SQLData</code>接口，则必须创建类型映射条目，以指定在将Oracle对象类型映射到Java时使用的自定义对象类。您可以使用连接对象的默认类型映射，也可以使用从结果集中检索数据时指定的类型映射。<code class="codeph">ResultSet</code>接口的<code class="codeph">getObject</code>方法具有一个签名，允许您指定类型映射。您可以使用以下任一方法：</p><pre class="oac_no_warn" dir="ltr">rs.getObject（int columnIndex）; rs.getObject（int columnIndex，Map map）;</pre><p>使用SQLData实现时，如果未包含类型映射条目，则该对象将映射到<code class="codeph">oracle.jdbc.默认情况下为OracleStruct</code>接口。相比之下， <code class="codeph">OracleData</code>实现具有自己的映射功能，因此不需要类型映射条目。使用<code class="codeph">OracleData</code>实现时，请使用Oracle <code class="codeph">getObject(int columnindex, OracleDataFactory factory)</code>方法。
                        </p>
                        <p>类型映射将Java类与Oracle对象的SQL类型名称相关联。这种一对一映射作为关键字 - 值对存储在散列表中。从Oracle对象读取数据时，JDBC驱动程序会考虑类型映射以确定使用哪个Java类来实现Oracle对象类型中的数据。将数据写入Oracle对象时，JDBC驱动程序通过调用<code class="codeph">SQLData</code>接口的<code class="codeph">getSQLTypeName</code>方法从Java类获取SQL类型名称。SQL和Java之间的实际转换由驱动程序执行。
                        </p>
                        <p>与Oracle对象对应的Java类的属性可以使用Java本机类型或Oracle本机类型来存储属性。</p>
                     </div>
                     <!-- class="section" -->
                  </div>
                  <div>
                     <div class="relinfo">
                        <p><strong>相关话题</strong></p>
                        <ul>
                           <li><a href="Oracle-object-types.html#GUID-0128E185-086F-41CD-BECC-63A42EBB142C">关于为Oracle Objects创建和使用自定义对象类</a></li>
                        </ul>
                     </div>
                  </div>
                  
               </div><a id="JJDBC28454"></a><div class="props_rev_3"><a id="GUID-6C176486-2299-408A-86D7-29033E593210" name="GUID-6C176486-2299-408A-86D7-29033E593210"></a><h4 id="JJDBC-GUID-6C176486-2299-408A-86D7-29033E593210" class="sect4"><span class="enumeration_section">13.3.4</span>关于为SQLData实现创建类型映射和定义映射</h4>
                  <div>
                     <p>本节包括以下主题：</p>
                     <ul style="list-style-type:disc">
                        <li>
                           <p><a href="Oracle-object-types.html#GUID-1F446706-91EA-4D67-9581-A0357DCCCFEC">创建类型映射和定义映射概述</a></p>
                        </li>
                        <li>
                           <p><a href="Oracle-object-types.html#GUID-BEC26079-81FA-4B26-B34D-40CA4EBD200C">将条目添加到现有类型映射</a></p>
                        </li>
                        <li>
                           <p><a href="Oracle-object-types.html#GUID-23CF44E8-F757-4F03-9719-16309C9F95BA">创建新类型地图</a></p>
                        </li>
                        <li>
                           <p><a href="Oracle-object-types.html#GUID-BE6AD090-BB22-404F-8003-37D7187764C0">关于物化类型映射中未指定的对象类型</a></p>
                        </li>
                     </ul>
                  </div>
                  <div class="props_rev_3"><a id="GUID-1F446706-91EA-4D67-9581-A0357DCCCFEC" name="GUID-1F446706-91EA-4D67-9581-A0357DCCCFEC"></a><h5 id="JJDBC-GUID-1F446706-91EA-4D67-9581-A0357DCCCFEC" class="sect5"><span class="enumeration_section">13.3.4.1</span>创建类型映射和定义映射概述</h5>
                     <div>
                        <p>使用<code class="codeph">SQLData</code>实现时，JDBC应用程序程序员负责提供类型映射，该映射必须是实现标准<code class="codeph">java.util.的类的实例<code class="codeph">java.util.Map</code>界面。
                        </p>
                        <p>您可以选择创建自己的类来完成此任务，但标准<code class="codeph">java.util.Hashtable</code>类符合要求。
                        </p>
                        <p>用于类型映射的<code class="codeph">Hashtable</code>和其他类实现了一个<code class="codeph">put</code>方法，该方法将关键字 - 值对作为输入，其中每个键是完全限定的SQL类型名称，相应的值是指定Java类的实例。
                        </p>
                        <p>类型映射与连接实例相关联。标准的<code class="codeph">java.sql.Connection</code>接口和Oracle特定的<code class="codeph">oracle.jdbc.OracleConnection</code>接口包含<code class="codeph">getTypeMap</code>方法。两者都返回一个<code class="codeph">Map</code>对象。
                        </p>
                     </div>
                  </div><a id="JJDBC28455"></a><div class="props_rev_3"><a id="GUID-BEC26079-81FA-4B26-B34D-40CA4EBD200C" name="GUID-BEC26079-81FA-4B26-B34D-40CA4EBD200C"></a><h5 id="JJDBC-GUID-BEC26079-81FA-4B26-B34D-40CA4EBD200C" class="sect5"><span class="enumeration_section">13.3.4.2</span>在现有类型映射中添加条目</h5>
                     <div>
                        <div class="section">
                           <p>首次建立连接实例时，默认类型映射为空。你必须填充它。</p>
                           <p>执行以下操作<a id="d51198e1125" class="indexterm-anchor"></a>将条目添加到现有类型映射的一般步骤：</p>
                        </div>
                        <!-- class="section" -->
                        <ol>
                           <li class="stepexpand"><span>使用<code class="codeph">OracleConnection</code>对象的<code class="codeph">getTypeMap</code>方法返回连接的类型映射对象。<code class="codeph">getTypeMap</code>方法返回<code class="codeph">java.util.Map</code>对象。例如，假设一个<code class="codeph">OracleConnection</code>实例<code class="codeph">oraconn</code> ：</span><div><pre class="oac_no_warn" dir="ltr">java.util中。映射myMap = oraconn.getTypeMap（）;</pre><div class="infoboxnote" id="GUID-BEC26079-81FA-4B26-B34D-40CA4EBD200C__GUID-1DAA090E-3F81-40DC-B8BD-81E9CC7D32FD">
                                    <p class="notep1">注意：</p>
                                    <p>如果尚未初始化<code class="codeph">OracleConnection</code>实例中的类型映射，则第一次调用<code class="codeph">getTypeMap</code>将返回一个空映射。
                                    </p>
                                 </div>
                              </div>
                           </li>
                           <li class="stepexpand"><span>使用类型映射的<code class="codeph">put</code>方法添加映射条目。<code class="codeph">put</code>方法有两个参数：SQL类型名称字符串和要映射到的指定Java类的实例。</span><div><pre class="oac_no_warn" dir="ltr">myMap.put（ <span class="italic">sqlTypeName</span> ， <span class="italic">classObject</span> ）;</pre><p><span class="italic"><code class="codeph">sqlTypeName</code></span>是一个字符串，表示数据库中SQL类型的完全限定名称。<span class="italic"><code class="codeph">classObject</code></span>是要将SQL类型映射到的Java类对象。使用<code class="codeph">Class.forName</code>方法获取类对象，如下所示：</p><pre class="oac_no_warn" dir="ltr">myMap.put（ <span class="italic">sqlTypeName</span> ，Class.forName（ <span class="italic">className</span> ））;</pre><p>例如，如果您在<code class="codeph">CORPORATE</code>数据库模式中定义了<code class="codeph">PERSON</code> SQL数据类型，则将其映射到使用以下语句定义为<code class="codeph">Person</code>的<code class="codeph">Person</code> Java类：</p><pre class="oac_no_warn" dir="ltr">myMap.put（“CORPORATE.PERSON”，Class.forName（“Person”））; oraconn.setTypeMap（newMap）;</pre><p>该映射有一个条目，用于将<code class="codeph">CORPORATE</code>数据库中的<code class="codeph">PERSON</code> SQL数据类型映射到<code class="codeph">Person</code> Java类。
                                 </p>
                                 <div class="infoboxnote" id="GUID-BEC26079-81FA-4B26-B34D-40CA4EBD200C__GUID-2228FA7B-0430-4F75-A8E7-67D4487ED960">
                                    <p class="notep1">注意：</p>
                                    <p>类型映射中的SQL类型名称必须全部为大写，因为这是Oracle数据库存储SQL名称的方式。</p>
                                 </div>
                              </div>
                           </li>
                        </ol>
                     </div>
                  </div><a id="JJDBC28456"></a><div class="props_rev_3"><a id="GUID-23CF44E8-F757-4F03-9719-16309C9F95BA" name="GUID-23CF44E8-F757-4F03-9719-16309C9F95BA"></a><h5 id="JJDBC-GUID-23CF44E8-F757-4F03-9719-16309C9F95BA" class="sect5"><span class="enumeration_section">13.3.4.3</span>创建新类型映射</h5>
                     <div>
                        <div class="section">
                           <p>演出<a id="d51198e1260" class="indexterm-anchor"></a>以下是创建新类型映射的一般步骤。此示例使用<code class="codeph">java.util.的实例<code class="codeph">java.util.Hashtable</code> ，扩展了<code class="codeph">java.util.Dictionary</code>和实现<code class="codeph">java.util.Map</code> 。
                           </p>
                        </div>
                        <!-- class="section" -->
                        <ol>
                           <li class="stepexpand"><span>创建一个新的类型映射对象。</span><div><pre class="oac_no_warn" dir="ltr">Hashtable newMap = new Hashtable（）;</pre></div>
                           </li>
                           <li class="stepexpand"><span>使用类型映射对象的<code class="codeph">put</code>方法向条目添加条目。例如，如果你有一个<code class="codeph">EMPLOYEE</code>在定义的SQL类型<code class="codeph">CORPORATE</code>数据库，则可以将其映射到<code class="codeph">Employee</code>通过定义的类对象<code class="codeph">Employee.java</code> ，如下所示：</span><div><pre class="oac_no_warn" dir="ltr">newMap.put（“CORPORATE.EMPLOYEE”，class.forName（“Employee”））;</pre></div>
                           </li>
                           <li class="stepexpand"><span>完成向地图添加条目后，必须使用<code class="codeph">OracleConnection</code>对象的<code class="codeph">setTypeMap</code>方法覆盖连接的现有类型映射。例如：</span><div><pre class="oac_no_warn" dir="ltr">oraconn.setTypeMap（newMap）;</pre><p>在这个例子中， <code class="codeph">setTypeMap</code>方法覆盖的原始地图<code class="codeph">oraconn</code>与连接对象<code class="codeph">newMap</code> 。
                                 </p>
                                 <div class="infoboxnote" id="GUID-23CF44E8-F757-4F03-9719-16309C9F95BA__GUID-6305D41E-7731-4A61-B3D5-C42DD64AC250">
                                    <p class="notep1">注意：</p>
                                    <p>当需要映射但未指定映射名称时，将使用连接实例的缺省类型映射，例如，对于未将映射指定为输入的结果集<code class="codeph">getObject</code>调用。
                                    </p>
                                 </div>
                              </div>
                           </li>
                        </ol>
                     </div>
                  </div><a id="JJDBC28457"></a><div class="props_rev_3"><a id="GUID-BE6AD090-BB22-404F-8003-37D7187764C0" name="GUID-BE6AD090-BB22-404F-8003-37D7187764C0"></a><h5 id="JJDBC-GUID-BE6AD090-BB22-404F-8003-37D7187764C0" class="sect5"><span class="enumeration_section">13.3.4.4</span>关于实现类型映射中未指定的实现对象类型</h5>
                     <div>
                        <div class="section">
                           <p>如果你不提供<a id="d51198e1356" class="indexterm-anchor"></a>使用<code class="codeph">getObject</code>调用时，使用适当的条目键入map，然后JDBC驱动程序将Oracle对象实现为<code class="codeph">oracle.jdbc.的实例<code class="codeph">oracle.jdbc.OracleStruct</code>接口。如果Oracle对象类型包含嵌入对象，并且它们不在类型映射中，则驱动程序将实现嵌入对象作为<code class="codeph">oracle.jdbc.实例<code class="codeph">oracle.jdbc.OracleStruct</code>也是如此。如果嵌入对象存在于类型映射中，则对<code class="codeph">getAttributes</code>方法的调用将返回嵌入对象作为类型映射中指定Java类的实例。
                           </p>
                        </div>
                        <!-- class="section" -->
                     </div>
                  </div>
               </div><a id="JJDBC28462"></a><a id="JJDBC28463"></a><a id="JJDBC28464"></a><a id="JJDBC28465"></a><a id="JJDBC28461"></a><div class="props_rev_3"><a id="GUID-6D44496F-0CAA-4034-AF55-00B39DE4C6E3" name="GUID-6D44496F-0CAA-4034-AF55-00B39DE4C6E3"></a><h4 id="JJDBC-GUID-6D44496F-0CAA-4034-AF55-00B39DE4C6E3" class="sect4"><span class="enumeration_section">13.3.5</span>关于使用SQLData实现读取和写入数据</h4>
                  <div>
                     <p>本节介绍如果相应的Java类实现<code class="codeph">SQLData</code>如何从Oracle对象读取数据或将数据写入Oracle对象。
                     </p>
                     <div class="section">
                        <p class="subhead3" id="GUID-6D44496F-0CAA-4034-AF55-00B39DE4C6E3__GUID-476CA319-2D38-4476-A1BF-F3AD10F02AF9">从结果集中读取SQLData对象</p>
                     </div>
                     <!-- class="section" -->
                     <div class="section">
                        <p>以下文字<a id="d51198e1410" class="indexterm-anchor"></a><a id="d51198e1414" class="indexterm-anchor"></a>总结了在为自定义对象类选择<code class="codeph">SQLData</code>实现时将数据从Oracle对象读取到Java应用程序的步骤。
                        </p>
                        <p>这些步骤假定您已经定义了Oracle对象类型，创建了相应的自定义对象类，更新了类型映射以定义Oracle对象和Java类之间的映射，并定义了语句对象<code class="codeph">stmt</code> 。
                        </p>
                        <ol>
                           <li>
                              <p>查询数据库以将Oracle对象读入JDBC结果集。</p><pre class="oac_no_warn" dir="ltr">ResultSet rs = stmt.executeQuery（“SELECT emp_col FROM personnel”）;</pre><p>该<code class="codeph">PERSONNEL</code>表中包含一列， <code class="codeph">EMP_COL</code> ，SQL类型的<code class="codeph">EMP_OBJECT</code> 。此类型的SQL类型在类型映射中定义，以映射到Java类<code class="codeph">Employee</code> 。
                              </p>
                           </li>
                           <li>
                              <p>使用Oracle结果集的<code class="codeph">getObject</code>方法，使用结果集的一行中的数据填充自定义对象类的实例。<code class="codeph">getObject</code>方法返回用户定义的<code class="codeph">SQLData</code>对象，因为类型映射包含<code class="codeph">Employee</code>的条目。
                              </p><pre class="oac_no_warn" dir="ltr">if（rs.next（））Employee emp =（Employee）rs.getObject（1）;</pre><p>请注意，如果类型映射没有该对象的条目，则<code class="codeph">getObject</code>方法将返回<code class="codeph">oracle.jdbc.OracleStruct</code>对象。将输出转换为类型<code class="codeph">OracleStruct</code>因为<code class="codeph">getObject</code>方法签名返回通用<code class="codeph">java.lang.Object</code>类型。
                              </p><pre class="oac_no_warn" dir="ltr">if（rs.next（））OracleStruct empstruct =（OracleStruct）rs.getObject（1）;</pre><p><code class="codeph">getObject</code>方法调用<code class="codeph">readSQL</code> ，而<code class="codeph">readSQL</code>又从<code class="codeph">SQLData</code>接口调用<code class="codeph">read</code> <span class="italic"><code class="codeph">XXX</code></span> 。
                              </p>
                              <div class="infoboxnote" id="GUID-6D44496F-0CAA-4034-AF55-00B39DE4C6E3__GUID-30A3BF58-2340-431B-AEFC-75010D0648DF">
                                 <p class="notep1">注意：</p>
                                 <p>如果要避免使用已定义的类型映射，请使用<code class="codeph">getSTRUCT</code>方法。即使类型映射中存在映射条目，此方法也始终返回<code class="codeph">STRUCT</code>对象。
                                 </p>
                              </div>
                           </li>
                           <li>
                              <p>如果已在自定义对象类中<code class="codeph">get</code>方法，则使用它们从对象属性中读取数据。例如，如果<code class="codeph">EMPLOYEE</code>具有属性<code class="codeph">EmpName</code>类型<code class="codeph">CHAR</code>和<code class="codeph">EmpNum</code>类型的<code class="codeph">NUMBER</code> ，然后提供一个<code class="codeph">getEmpName</code>返回的Java方法<code class="codeph">String</code>和一个<code class="codeph">getEmpNum</code>返回一个方法<code class="codeph">int</code>值。然后在Java应用程序中调用它们，如下所示：</p><pre class="oac_no_warn" dir="ltr">String empname = emp.getEmpName（）; int empnumber = emp.getEmpNum（）;</pre></li>
                        </ol>
                     </div>
                     <!-- class="section" -->
                     <div class="section">
                        <p class="subhead3" id="GUID-6D44496F-0CAA-4034-AF55-00B39DE4C6E3__GUID-1E26A487-4615-4918-BD0E-15ABA53237A2">从可调用语句OUT参数中检索SQLData对象</p>
                     </div>
                     <!-- class="section" -->
                     <div class="section">
                        <p>假设您有一个<code class="codeph">CallableStatement</code> PL / SQL函数<code class="codeph">GETEMPLOYEE</code>的<code class="codeph">CallableStatement</code>实例<code class="codeph">cs</code> 。该程序将员工编号传递给该功能。该函数返回相应的<code class="codeph">Employee</code>对象。要检索此对象，请执行以下操作：</p>
                        <ol>
                           <li>
                              <p>准备一个<code class="codeph">CallableStatement</code>来调用<code class="codeph">GETEMPLOYEE</code>函数，如下所示：</p><pre class="oac_no_warn" dir="ltr">CallableStatement ocs = conn.prepareCall（“{？=致电GETEMPLOYEE（？）}“）;</pre></li>
                           <li>
                              <p>声明<code class="codeph">empnumber</code>作为输入参数来<code class="codeph">GETEMPLOYEE</code> 。将<code class="codeph">SQLData</code>对象注册为<code class="codeph">OUT</code>参数，类型代码为<code class="codeph">OracleTypes.STRUCT</code> 。然后，运行该语句。这可以按如下方式完成：</p><pre class="oac_no_warn" dir="ltr">cs.setInt（2，empnumber）; cs.registerOutParameter（1，OracleTypes。STRUCT，“EMP_OBJECT”）; cs.execute（）;</pre></li>
                           <li>
                              <p>使用<code class="codeph">getObject</code>方法检索employee对象。
                              </p><pre class="oac_no_warn" dir="ltr">Employee emp =（Employee）cs.getObject（1）;</pre><p>如果没有类型映射条目，则<code class="codeph">getObject</code>方法将返回<code class="codeph">java.sql.Struct</code>对象。
                              </p><pre class="oac_no_warn" dir="ltr">Struct emp = cs.getObject（1）;</pre></li>
                        </ol>
                     </div>
                     <!-- class="section" -->
                     <div class="section">
                        <p class="subhead3" id="GUID-6D44496F-0CAA-4034-AF55-00B39DE4C6E3__GUID-9A998336-12A2-41F7-BFFD-5556D6626CF0">将SQLData对象作为IN参数传递给可调用语句</p>
                     </div>
                     <!-- class="section" -->
                     <div class="section">
                        <p>假设你有一个PL / SQL函数<code class="codeph">addEmployee(?)</code> 将<code class="codeph">Employee</code>对象作为<code class="codeph">IN</code>参数并将其添加到<code class="codeph">PERSONNEL</code>表。在此示例中， <code class="codeph">emp</code>是有效的<code class="codeph">Employee</code>对象。
                        </p>
                        <ol>
                           <li>
                              <p>准备一个<code class="codeph">CallableStatement</code>来调用<code class="codeph">addEmployee(?)</code> 功能。
                              </p><pre class="oac_no_warn" dir="ltr">CallableStatement cs = conn.prepareCall（“{call addEmployee（？）}“）;</pre></li>
                           <li>
                              <p>使用<code class="codeph">setObject</code>将<code class="codeph">emp</code>对象作为<code class="codeph">IN</code>参数传递给可调用语句。然后，调用该语句。
                              </p><pre class="oac_no_warn" dir="ltr">cs.setObject（1，emp）; cs.execute（）;</pre></li>
                        </ol>
                     </div>
                     <!-- class="section" -->
                     <div class="section">
                        <p class="subhead3" id="GUID-6D44496F-0CAA-4034-AF55-00B39DE4C6E3__GUID-5C497F9F-D471-4D32-B0B3-F5688A8A2756">使用SQLData实现将数据写入Oracle对象</p>
                     </div>
                     <!-- class="section" -->
                     <div class="section">
                        <p>该<a id="d51198e1670" class="indexterm-anchor"></a><a id="d51198e1674" class="indexterm-anchor"></a>下面的文本描述了在为自定义对象类选择<code class="codeph">SQLData</code>实现时，从Java应用程序向Oracle对象写入数据的步骤。
                        </p>
                        <p>此描述假定您已经定义了Oracle对象类型，创建了相应的Java类，并更新了类型映射以定义Oracle对象和Java类之间的映射。</p>
                        <ol>
                           <li>
                              <p>如果在自定义对象类中<code class="codeph">set</code>方法，则使用它们将应用程序中Java变量的数据写入Java数据类型对象的属性。
                              </p><pre class="oac_no_warn" dir="ltr">emp.setEmpName（empname）; emp.setEmpNum（empnumber）;</pre></li>
                           <li>
                              <p>使用Java数据类型对象中提供的数据，根据需要准备一个更新数据库表行中的Oracle对象的语句。</p><pre class="oac_no_warn" dir="ltr">PreparedStatement pstmt = conn.prepareStatement（“INSERT INTO PERSONNEL VALUES（？）“）;</pre></li>
                           <li>
                              <p>使用<code class="codeph">setObject</code>准备语句的<code class="codeph">setObject</code>方法将Java数据类型对象绑定到<code class="codeph">setObject</code>准备语句。
                              </p><pre class="oac_no_warn" dir="ltr">pstmt.setObject（1，emp）;</pre></li>
                           <li>
                              <p>运行更新数据库的语句。</p><pre class="oac_no_warn" dir="ltr">pstmt.executeUpdate（）;</pre></li>
                        </ol>
                     </div>
                     <!-- class="section" -->
                  </div>
               </div><a id="JJDBC28467"></a><a id="JJDBC28468"></a><a id="JJDBC28466"></a><div class="props_rev_3"><a id="GUID-EEF1A8CA-354D-430B-9153-171849DE2525" name="GUID-EEF1A8CA-354D-430B-9153-171849DE2525"></a><h4 id="JJDBC-GUID-EEF1A8CA-354D-430B-9153-171849DE2525" class="sect4"><span class="enumeration_section">13.3.6</span>关于OracleData接口</h4>
                  <div>
                     <p>您可以创建实现<code class="codeph">oracle.jdbc.的自定义对象类<code class="codeph">oracle.jdbc.OracleData</code>和<code class="codeph">oracle.jdbc.OracleDataFactory</code>接口使Oracle对象及其属性数据可供Java应用程序使用。<code class="codeph">OracleData</code>和<code class="codeph">OracleDataFactory</code>接口是特定于Oracle的，并不是JDBC标准的一部分。
                     </p>
                     <div class="infoboxnote" id="GUID-EEF1A8CA-354D-430B-9153-171849DE2525__GUID-3C9EAAEC-E81B-4A09-A970-B2894875ED1D">
                        <p class="notep1">注意：</p>
                        <p>从Oracle数据库12开始<span class="italic">c</span>解除1（12.1），所述<code class="codeph">OracleData</code>和<code class="codeph">OracleDataFactory</code>接口更换<code class="codeph">ORAData</code>和<code class="codeph">ORADataFactory</code>接口。
                        </p>
                     </div>
                     <div class="section">
                        <p class="subhead3" id="GUID-EEF1A8CA-354D-430B-9153-171849DE2525__GUID-21969CFF-8F45-4625-87B6-57E4CB97DFCC">了解OracleData接口功能</p>
                     </div>
                     <!-- class="section" -->
                     <div class="section">
                        <p><code class="codeph">OracleData</code>接口具有以下优点：</p>
                        <ul style="list-style-type:disc">
                           <li>
                              <p>它支持标准JDBC类型的Oracle扩展。</p>
                           </li>
                           <li>
                              <p>它不需要类型映射来指定要创建的Java自定义类的名称。</p>
                           </li>
                           <li>
                              <p>它提供了更好的性能。<code class="codeph">OracleData</code>直接与<code class="codeph">Datum</code>类型一起工作， <code class="codeph">Datum</code>类型是驱动程序用于保存Oracle对象的内部格式。
                              </p>
                           </li>
                        </ul>
                        <p><code class="codeph">OracleData</code>和<code class="codeph">OracleDataFactory</code>接口执行以下操作：</p>
                        <ul style="list-style-type:disc">
                           <li>
                              <p><code class="codeph">OracleData</code>类的<code class="codeph">toJDBCObject</code>方法将数据转换为<code class="codeph">oracle.jdbc.*</code>表示。
                              </p>
                           </li>
                           <li>
                              <p><code class="codeph">OracleDataFactory</code>指定一个等效于自定义对象类的构造函数的<code class="codeph">create</code>方法。它创建并返回一个<code class="codeph">OracleData</code>实例。JDBC驱动程序使用<code class="codeph">create</code>方法将自定义对象类的实例返回给Java应用程序。它需要<code class="codeph">java.lang.作为输入<code class="codeph">java.lang.Object</code>对象和一个整数，指示<code class="codeph">OracleTypes</code>类中指定的相应SQL类型代码。
                              </p>
                           </li>
                        </ul>
                        <p><code class="codeph">OracleData</code>和<code class="codeph">OracleDataFactory</code>具有以下定义：</p><pre class="oac_no_warn" dir="ltr">包oracle.jdbc; import java.sql。连接; import java.sql。的SQLException;公共接口OracleData {public Object toJDBCObject（Connection conn）抛出SQLException; }</pre><pre class="oac_no_warn" dir="ltr">包oracle.jdbc; import java.sql。的SQLException;公共接口OracleDataFactory {public OracleData create（Object jdbcValue，int sqlType）抛出SQLException; }</pre><p>其中<span class="italic"><code class="codeph">conn</code></span>表示Connection对象， <span class="italic"><code class="codeph">jdbcValue</code></span>表示<code class="codeph">java.lang.object</code>类型的对象，该对象用于初始化正在创建的Object， <span class="italic"><code class="codeph">sqlType</code></span>表示指定的<code class="codeph">Datum</code>对象的SQL类型。
                        </p>
                     </div>
                     <!-- class="section" -->
                     <div class="section">
                        <p class="subhead3" id="GUID-EEF1A8CA-354D-430B-9153-171849DE2525__GUID-4EE2EDCE-2552-44B5-8FE7-9883B853807F">检索和插入对象数据</p>
                     </div>
                     <!-- class="section" -->
                     <div class="section">
                        <p>JDBC驱动程序提供以下方法来检索和插入作为<code class="codeph">OracleData</code>实例的对象数据。
                        </p>
                        <p>您可以通过以下方式之一检索对象数据：</p>
                        <ul style="list-style-type:disc">
                           <li>
                              <p>使用Oracle特定的<code class="codeph">OracleResultSet</code>接口的以下<code class="codeph">getObject</code>方法：</p><pre class="oac_no_warn" dir="ltr">ors.getObject（int col_index，OracleDataFactory factory）;</pre><p>此方法将结果集中数据的列索引和<code class="codeph">OracleDataFactory</code>实例作为输入。例如，您可以在自定义对象类中实现<code class="codeph">getOracleDataFactory</code>方法，以生成要输入到<code class="codeph">getObject</code>方法的<code class="codeph">OracleDataFactory</code>实例。使用实现<code class="codeph">OracleData</code> Java类时，不需要类型映射。
                              </p>
                           </li>
                           <li>
                              <p>使用标准<a id="d51198e1908" class="indexterm-anchor"></a>由<code class="codeph">ResultSet</code>接口指定的<code class="codeph">getObject(</code> <span class="italic"><code class="codeph">index</code></span> <code class="codeph">,</code> <span class="italic"><code class="codeph">map</code></span> <code class="codeph">)</code>方法，用于检索作为<code class="codeph">OracleData</code>实例的数据。在这种情况下，您必须在类型映射中有一个条目，用于标识要用于给定对象类型的工厂类及其对应的SQL类型名称。
                              </p>
                           </li>
                        </ul>
                        <p>您可以通过以下方式之一插入对象数据：</p>
                        <ul style="list-style-type:disc">
                           <li>
                              <p>使用Oracle特定的<code class="codeph">OraclePreparedStatement</code>类的以下<code class="codeph">setObject</code>方法：</p><pre class="oac_no_warn" dir="ltr">setObject（int bind_index，Object custom_object）;</pre><p>此方法将绑定变量的参数索引和<code class="codeph">OracleData</code>的实例作为输入，作为包含变量的对象的名称。
                              </p>
                           </li>
                           <li>
                              <p>使用<code class="codeph">PreparedStatement</code>接口指定的标准<code class="codeph">setObject</code>方法。您还可以使用此方法以不同的形式插入<code class="codeph">OracleData</code>实例，而无需类型映射。
                              </p>
                           </li>
                        </ul>
                        <p>以下部分描述了<code class="codeph">getObject</code>和<code class="codeph">setObject</code>方法。
                        </p>
                        <p>要继续Oracle对象<code class="codeph">EMPLOYEE</code>的示例，您可能在Java应用程序中具有以下内容：</p><pre class="oac_no_warn" dir="ltr">OracleData obj = ors.getObject（1，Employee.getOracleDataFactory（））;</pre><p>在此示例中， <code class="codeph">ors</code>是<code class="codeph">OracleResultSet</code>接口的实例， <code class="codeph">getObject</code>是<code class="codeph">OracleResultSet</code>接口中用于检索<code class="codeph">OracleData</code>对象的方法，而<code class="codeph">EMPLOYEE</code>位于结果集的第1列中。<code class="codeph">static</code> <code class="codeph">Employee.getOracleDataFactory</code>方法将<code class="codeph">OracleDataFactory</code>返回给JDBC驱动程序。JDBC驱动程序将从此对象调用<code class="codeph">create(</code> ），并向您的Java应用程序返回一个<code class="codeph">Employee</code>类的实例，该类填充了结果集中的数据。
                        </p>
                        <div class="infoboxnote" id="GUID-EEF1A8CA-354D-430B-9153-171849DE2525__GUID-11BBA304-16B0-4DBA-B0D6-9ABA2B24703E">
                           <p class="notep1">注意：</p>
                           <ul style="list-style-type:disc">
                              <li>
                                 <p><code class="codeph">OracleData</code>和<code class="codeph">OracleDataFactory</code>被定义为单独的接口，以便不同的Java类可以根据需要实现它们。
                                 </p>
                              </li>
                              <li>
                                 <p>要使用<code class="codeph">OracleData</code>接口，您的自定义对象类必须导入<code class="codeph">oracle.jdbc.*</code> 。
                                 </p>
                              </li>
                           </ul>
                        </div>
                     </div>
                     <!-- class="section" -->
                  </div>
               </div><a id="JJDBC28470"></a><a id="JJDBC28471"></a><a id="JJDBC28469"></a><div class="props_rev_3"><a id="GUID-7E84EDB6-A403-475D-875B-CAA151436AF7" name="GUID-7E84EDB6-A403-475D-875B-CAA151436AF7"></a><h4 id="JJDBC-GUID-7E84EDB6-A403-475D-875B-CAA151436AF7" class="sect4"><span class="enumeration_section">13.3.7</span>关于使用OracleData实现读取和写入数据</h4>
                  <div>
                     <p>本节介绍如果相应的Java类实现<code class="codeph">OracleData</code>如何从Oracle对象读取数据或将数据写入Oracle对象。
                     </p>
                     <div class="section">
                        <p class="subhead3" id="GUID-7E84EDB6-A403-475D-875B-CAA151436AF7__GUID-B657E514-694F-49A2-BB60-18F520429B82">使用OracleData实现从Oracle对象读取数据</p>
                     </div>
                     <!-- class="section" -->
                     <div class="section">
                        <p>以下文字<a id="d51198e2067" class="indexterm-anchor"></a>总结了从Oracle对象读取数据到Java应用程序的步骤。无论是手动实现<code class="codeph">OracleData</code>还是使用Oracle JVM Web服务调用实用程序来生成自定义对象类，这些步骤都适用。
                        </p>
                        <p>这些步骤假定您已经定义了Oracle对象类型，创建了相应的自定义对象类，或者让Oracle JVM Web服务调用实用程序为您创建了它，并定义了语句对象<code class="codeph">stmt</code> 。
                        </p>
                        <ol>
                           <li>
                              <p>查询数据库以将Oracle对象读入结果集，并将其转换为Oracle结果集。</p><pre class="oac_no_warn" dir="ltr">OracleResultSet ors =（OracleResultSet）stmt.executeQuery（“SELECT Emp_col FROM PERSONNEL”）;</pre><p><code class="codeph">PERSONNEL</code>是一列表。列名是<code class="codeph">Emp_col</code>型<code class="codeph">Employee_object</code> 。
                              </p>
                           </li>
                           <li>
                              <p>使用Oracle结果集的<code class="codeph">getObject</code>方法，使用结果集的一行中的数据填充自定义对象类的实例。<code class="codeph">getObject</code>方法返回<code class="codeph">java.lang.Object</code>对象，可以转换为特定的自定义对象类。
                              </p><pre class="oac_no_warn" dir="ltr">if（ors.next（））Employee emp =（Employee）ors.getObject（1，Employee.getOracleDataFactory（））;</pre><p>要么：</p><pre class="oac_no_warn" dir="ltr">if（ors.next（））Object obj = ors.getObject（1，Employee.getOracleDataFactory（））;</pre><p>此示例假定<code class="codeph">Employee</code>是自定义对象类的名称， <code class="codeph">ors</code>是<code class="codeph">OracleResultSet</code>实例的名称。
                              </p>
                              <p>例如，如果对象的SQL类型名称是<code class="codeph">EMPLOYEE</code> ，那么相应的Java类是<code class="codeph">Employee</code> ，它将实现<code class="codeph">OracleData</code> 。相应的Factory类是<code class="codeph">EmployeeFactory</code> ，它将实现<code class="codeph">OracleDataFactory</code> 。
                              </p>
                              <p>使用此语句为类型映射声明<code class="codeph">EmployeeFactory</code>条目：</p><pre class="oac_no_warn" dir="ltr">map.put（“EMPLOYEE”，Class.forName（“EmployeeFactory”））;</pre><p>然后使用<code class="codeph">getObject</code>的形式指定地图对象：</p><pre class="oac_no_warn" dir="ltr">Employee emp =（Employee）rs.getObject（1，map）;</pre><p>如果连接的默认类型映射已有一个条目，该条目标识要用于给定对象类型的工厂类及其对应的SQL类型名称，则可以使用此形式的<code class="codeph">getObject</code> ：</p><pre class="oac_no_warn" dir="ltr">Employee emp =（Employee）rs.getObject（1）;</pre></li>
                           <li>
                              <p>如果已在自定义对象类中<code class="codeph">get</code>方法，则使用它们将对象属性中的数据读取到应用程序中的Java变量中。例如，如果<code class="codeph">EMPLOYEE</code>具有<code class="codeph">EmpName</code>类型<code class="codeph">CHAR</code>和<code class="codeph">EmpNum</code>类型的<code class="codeph">NUMBER</code> ，提供一种<code class="codeph">getEmpName</code>返回的Java方法<code class="codeph">String</code>和一个<code class="codeph">getEmpNum</code>返回一个整数方法。然后在Java应用程序中调用它们，如下所示：</p><pre class="oac_no_warn" dir="ltr">String empname = emp.getEmpName（）; int empnumber = emp.getEmpNum（）;</pre></li>
                        </ol>
                     </div>
                     <!-- class="section" -->
                     <div class="section">
                        <p class="subhead3" id="GUID-7E84EDB6-A403-475D-875B-CAA151436AF7__GUID-622829E2-D65F-4312-AABD-83CB892CE5BF">使用OracleData实现将数据写入Oracle对象</p>
                     </div>
                     <!-- class="section" -->
                     <div class="section">
                        <p>以下文字<a id="d51198e2204" class="indexterm-anchor"></a>总结了从Java应用程序向Oracle对象写入数据的步骤。无论是手动实现<code class="codeph">OracleData</code>还是使用Oracle JVM Web服务调用实用程序来生成自定义对象类，这些步骤都适用。
                        </p>
                        <p>这些步骤假定您已经定义了Oracle对象类型并创建了相应的自定义对象类。</p>
                        <div class="infoboxnote" id="GUID-7E84EDB6-A403-475D-875B-CAA151436AF7__GUID-B881DFAC-F842-49EB-B4AE-EB2A8C6178A1">
                           <p class="notep1">注意：</p>
                           <p>执行数据库<code class="codeph">INSERT</code>和<code class="codeph">UPDATE</code>操作时不使用类型映射。
                           </p>
                        </div>
                        <ol>
                           <li>
                              <p>如果在自定义对象类中<code class="codeph">set</code>方法，则使用它们将应用程序中Java变量的数据写入Java数据类型对象的属性。
                              </p><pre class="oac_no_warn" dir="ltr">emp.setEmpName（empname）; emp.setEmpNum（empnumber）;</pre></li>
                           <li>
                              <p>编写Oracle预准备语句，使用Java数据类型对象中提供的数据，根据需要更新数据库表行中的Oracle对象。</p><pre class="oac_no_warn" dir="ltr">OraclePreparedStatement opstmt = conn.prepareStatement（“UPDATE PERSONNEL SET Employee =？在哪里员工。EmpNum = 28959）;</pre><p>假设<code class="codeph">conn</code>是您的<code class="codeph">Connection</code>对象。
                              </p>
                           </li>
                           <li>
                              <p>使用<code class="codeph">OraclePreparedStatement</code>接口的<code class="codeph">setObject</code>方法将Java数据类型对象绑定到<code class="codeph">OraclePreparedStatement</code>准备语句。
                              </p><pre class="oac_no_warn" dir="ltr">opstmt.setObject（1，EMP）;</pre><p><code class="codeph">setObject</code>方法调用自定义对象类实例的<code class="codeph">toJDBCObject</code>方法来检索<code class="codeph">oracle.jdbc.可以写入数据库的OracleStruct</code>对象。
                              </p>
                              <div class="infoboxnote" id="GUID-7E84EDB6-A403-475D-875B-CAA151436AF7__GUID-CC5F882D-298E-40B1-8FC7-A1FB1F17F07A">
                                 <p class="notep1">注意：</p>
                                 <p>您可以将Java数据类型对象用作<code class="codeph">IN</code>或<code class="codeph">OUT</code>绑定变量。
                                 </p>
                              </div>
                           </li>
                        </ol>
                     </div>
                     <!-- class="section" -->
                  </div>
               </div><a id="JJDBC28472"></a><div class="props_rev_3"><a id="GUID-1CC46DF9-95F1-4892-8C25-9B3BBD36CFFF" name="GUID-1CC46DF9-95F1-4892-8C25-9B3BBD36CFFF"></a><h4 id="JJDBC-GUID-1CC46DF9-95F1-4892-8C25-9B3BBD36CFFF" class="sect4"><span class="enumeration_section">13.3.8</span> OracleData的其他用途</h4>
                  <div>
                     <div class="section">
                        <p><code class="codeph">OracleData</code>接口提供比<code class="codeph">SQLData</code>接口更多的灵活性。<code class="codeph">SQLData</code>接口旨在让您自定义仅将Oracle对象类型映射到您选择的Java类型。实现<code class="codeph">SQLData</code>接口允许JDBC驱动程序从原始SQL对象数据填充自定义Java类实例的字段，反之，在Java和SQL类型之间执行适当的转换后。
                        </p>
                        <p><code class="codeph">OracleData</code>接口不仅支持将Oracle对象类型自定义为Java类型。它允许您提供Java对象类型与<code class="codeph">oracle.sql</code>包支持的<span class="italic">任何</span> SQL类型之间的映射。
                        </p>
                        <p>您可能会发现提供自定义Java类来包装<code class="codeph">oracle.sql.*</code>类型，然后实现自定义转换或功能也很有用。以下是一些可能的情况：</p>
                        <ul style="list-style-type:disc">
                           <li>
                              <p>执行加密和解密或数据验证</p>
                           </li>
                           <li>
                              <p>执行已读取或正在写入的值的记录</p>
                           </li>
                           <li>
                              <p>将字符列（例如包含URL信息的字符字段）解析为较小的组件</p>
                           </li>
                           <li>
                              <p>将字符串映射到数字常量</p>
                           </li>
                           <li>
                              <p>将数据转换为更理想的Java格式，例如将<code class="codeph">DATE</code>字段映射到<code class="codeph">java.util.Date</code>格式</p>
                           </li>
                           <li>
                              <p>自定义数据表示，例如，表格列中的数据以英尺为单位，但您希望在选择后以米为单位表示</p>
                           </li>
                           <li>
                              <p>序列化和反序列化Java对象</p>
                           </li>
                        </ul>
                        <p>例如，使用<code class="codeph">OracleData</code>在SQL类型<code class="codeph">RAW</code>列中存储与数据库中的特定SQL对象类型不对应的Java对象的实例。 <code class="codeph">OracleDataFactory</code>的<code class="codeph">create</code>方法必须实现从<code class="codeph">oracle.sql.类型的对象转换<code class="codeph">oracle.sql.RAW</code>到所需的Java对象。<code class="codeph">OracleData</code>的<code class="codeph">toJDBCObject</code>方法必须实现从Java对象到<code class="codeph">oracle.sql.的转换<code class="codeph">oracle.sql.RAW</code>对象。您也可以使用Java序列化来实现此目的。
                        </p>
                        <p>检索后，JDBC驱动程序以<code class="codeph">oracle.sql.的形式透明地检索数据的原始字节<code class="codeph">oracle.sql.RAW</code>并调用<code class="codeph">OracleDataFactory</code>的<code class="codeph">create</code>方法来转换<code class="codeph">oracle.sql.RAW</code>对象到所需的Java类。
                        </p>
                        <p>将Java对象插入数据库时，只需将其绑定到<code class="codeph">RAW</code>类型的列即可存储它。驱动程序透明地调用<code class="codeph">OracleData</code> 。 <code class="codeph">toJDBCObject</code>方法将Java对象转换为<code class="codeph">oracle.sql.RAW</code>对象。然后将该对象存储在数据库中<code class="codeph">RAW</code>类型的列中。
                        </p>
                        <p>对<code class="codeph">OracleData</code>接口的支持也非常高效，因为转换旨在使用<code class="codeph">oracle.sql.*</code>格式，这些格式恰好是JDBC驱动程序使用的内部格式。此外，在使用实现<code class="codeph">OracleData</code> Java类时，不需要<code class="codeph">SQLData</code>接口所必需的类型映射。
                        </p>
                     </div>
                     <!-- class="section" -->
                  </div>
                  <div>
                     <div class="relinfo">
                        <p><strong>相关话题</strong></p>
                        <ul>
                           <li><a href="Oracle-object-types.html#GUID-EEF1A8CA-354D-430B-9153-171849DE2525">关于OracleData接口</a></li>
                        </ul>
                     </div>
                  </div>
                  
               </div>
            </div><a id="JJDBC28474"></a><div class="props_rev_3"><a id="GUID-E47B8141-3C4C-44D5-BB5C-2F8E16DF5140" name="GUID-E47B8141-3C4C-44D5-BB5C-2F8E16DF5140"></a><h3 id="JJDBC-GUID-E47B8141-3C4C-44D5-BB5C-2F8E16DF5140" class="sect3"><span class="enumeration_section">13.4</span>对象类型继承</h3>
               <div>
                  <p>对象类型继承允许通过扩展另一个对象类型来创建新的对象类型。然后，新对象类型是其扩展的对象类型的子类型。子类型自动继承超类型中定义的所有属性和方法。子类型可以添加属性和方法，并重载或覆盖从超类型继承的方法。</p>
                  <p>对象类型继承引入了<span class="bold">可替代性</span> 。可替代性声明的槽的保持类型的值的能力<code class="codeph">T</code>除了类型的任何亚型<code class="codeph">T</code> 。 Oracle JDBC驱动程序透明地处理可替代性。
                  </p>
                  <p>返回具有最特定类型的数据库对象，而不会丢失信息。例如，如果<code class="codeph">STUDENT_T</code>对象存储在<code class="codeph">PERSON_T</code>插槽中，则Oracle JDBC驱动程序将返回表示<code class="codeph">STUDENT_T</code>对象的Java对象。
                  </p>
                  <p>本节包括以下主题：</p>
                  <ul style="list-style-type:disc">
                     <li>
                        <p><a href="Oracle-object-types.html#GUID-27F2FE6B-DA9A-4551-94EF-EDEAC5CBD6FE">关于创建子类型</a></p>
                     </li>
                     <li>
                        <p><a href="Oracle-object-types.html#GUID-21A782F4-5EA3-42E0-8201-2636B97516C2">关于为子类型实现自定义类</a></p>
                     </li>
                     <li>
                        <p><a href="Oracle-object-types.html#GUID-9E0B6269-71FD-4F4C-83B5-D31D214655A0">关于检索子类型对象</a></p>
                     </li>
                     <li>
                        <p><a href="Oracle-object-types.html#GUID-EDEEF48A-DBEE-484D-BC65-577DD9665ACA">创建子类型对象</a></p>
                     </li>
                     <li>
                        <p><a href="Oracle-object-types.html#GUID-B7A9E9B9-ED8B-4EBA-94F1-C048876DB314">发送子类型对象</a></p>
                     </li>
                     <li>
                        <p><a href="Oracle-object-types.html#GUID-4D4E75B2-AFE4-4C34-BDCD-C06D0D27EAB2">访问子类型数据字段</a></p>
                     </li>
                     <li>
                        <p><a href="Oracle-object-types.html#GUID-E0C046C2-4F00-49EB-89B8-D2C147C5C75F">继承元数据方法</a></p>
                     </li>
                  </ul>
               </div><a id="JJDBC29174"></a><a id="JJDBC28475"></a><div class="props_rev_3"><a id="GUID-27F2FE6B-DA9A-4551-94EF-EDEAC5CBD6FE" name="GUID-27F2FE6B-DA9A-4551-94EF-EDEAC5CBD6FE"></a><h4 id="JJDBC-GUID-27F2FE6B-DA9A-4551-94EF-EDEAC5CBD6FE" class="sect4"><span class="enumeration_section">13.4.1</span>关于创建子类型</h4>
                  <div>
                     <p>如果要使Java类明确对应于Oracle对象类型，请创建自定义对象类。如果您有对象类型的层次结构，则可能需要相应的Java类层次结构。</p>
                     <p>在JDBC中创建数据库子类型的最常用方法是使用<code class="codeph">java.sql.的<code class="codeph">execute</code>方法运行SQL <code class="codeph">CREATE TYPE</code>命令<code class="codeph">java.sql.Statement</code>界面。例如，您要创建一个类型继承层次结构，如下图所示：</p>
                     <div class="figure" id="GUID-27F2FE6B-DA9A-4551-94EF-EDEAC5CBD6FE__BCEDBDFC">
                        <p class="titleinfigure">图13-1类型继承层次结构</p><img src="img/hierarchy.gif" alt="下面是图13-1的描述" title="下面是图13-1的描述" longdesc="img_text/hierarchy.html"><br><a href="img_text/hierarchy.html">“图13-1类型继承层次结构”的描述</a></div>
                     <!-- class="figure" -->
                     <p>这个的JDBC代码如下：</p><pre class="oac_no_warn" dir="ltr">Statement s = conn.createStatement（）; s.execute（“CREATE TYPE Person_T（SSN NUMBER，名称VARCHAR2（30），地址VARCHAR2（255））”）; s.execute（“CREATE TYPE Student_T UNDER Person_t（deptid NUMBER，major VARCHAR2（100））”）; s.execute（“CREATE TYPE PartTimeStudent_t UNDER Student_t（numHours NUMBER）”）;</pre><p>在下面的代码中，类型<code class="codeph">ST</code>的<code class="codeph">foo</code>成员过程被重载，成员过程<code class="codeph">print</code>覆盖它从类型<code class="codeph">T</code>继承的副本。</p><pre class="oac_no_warn" dir="ltr">创建类型T作为对象（...，成员程序foo（x NUMBER），成员程序打印（），...不是最终的;在T下创建类型ST（...，成员程序foo（x日期），&lt; - 重载“foo”覆盖成员程序打印（），&lt; - 覆盖“打印”静态功能栏（...）......）;</pre><p>一旦创建了子类型，它们就可以用作基表的两列以及对象类型的属性。</p>
                     <div class="infoboxnotealso" id="GUID-27F2FE6B-DA9A-4551-94EF-EDEAC5CBD6FE__GUID-678DBA14-0836-48A2-A65F-8BF46E46A64D">
                        <p class="notep1">也可以看看：</p>
                        <p><a href="../adobj/inheritance-in-sql-object-types.html#ADOBJ-GUID-D6D92FB6-7BC4-4EE6-A9EC-BC69C5BA5A56" target="_blank"><span><cite>Oracle数据库对象关系开发人员指南</cite></span></a></p>
                     </div>
                  </div>
               </div><a id="JJDBC28476"></a><div class="props_rev_3"><a id="GUID-21A782F4-5EA3-42E0-8201-2636B97516C2" name="GUID-21A782F4-5EA3-42E0-8201-2636B97516C2"></a><h4 id="JJDBC-GUID-21A782F4-5EA3-42E0-8201-2636B97516C2" class="sect4"><span class="enumeration_section">13.4.2</span>关于为子类型实现自定义类</h4>
                  <div>
                     <p>在大多数情况下，自定义Java类表示数据库对象类型。为子类型创建自定义Java类时，Java类可以镜像数据库对象类型层次结构。</p>
                     <p>您可以使用<code class="codeph">OracleData</code>或<code class="codeph">SQLData</code>解决方案创建类以映射到对象类型的层次结构。
                     </p>
                     <p>本节包括以下主题：</p>
                     <ul style="list-style-type:disc">
                        <li>
                           <p><a href="Oracle-object-types.html#GUID-EF78FF64-5B65-42F7-97B0-5CF233BF9DC8">关于将OracleData用于类型继承层次结构</a></p>
                        </li>
                        <li>
                           <p><a href="Oracle-object-types.html#GUID-26AC0C12-D473-4957-A9B1-D64DFD0EC71B">关于使用SQLData进行类型继承层次结构</a></p>
                        </li>
                     </ul>
                  </div><a id="JJDBC28478"></a><a id="JJDBC28479"></a><a id="JJDBC28480"></a><a id="JJDBC28477"></a><div class="props_rev_3"><a id="GUID-EF78FF64-5B65-42F7-97B0-5CF233BF9DC8" name="GUID-EF78FF64-5B65-42F7-97B0-5CF233BF9DC8"></a><h5 id="JJDBC-GUID-EF78FF64-5B65-42F7-97B0-5CF233BF9DC8" class="sect5"><span class="enumeration_section">13.4.2.1</span>关于使用OracleData进行类型继承层次结构</h5>
                     <div>
                        <p>Oracle建议使用自定义映射，其中Java类实现<code class="codeph">oracle.sql.OracleData</code>接口。<code class="codeph">OracleData</code>映射要求JDBC应用程序实现<code class="codeph">OracleData</code>和<code class="codeph">OracleDataFactory</code>接口。实现<code class="codeph">OracleDataFactory</code>接口的类包含一个生成对象的工厂方法。每个对象代表一个数据库对象。
                        </p>
                        <p>实现<code class="codeph">OracleData</code>接口的类的层次结构可以镜像数据库对象类型层次结构。例如，映射到<code class="codeph">PERSON_T</code>和<code class="codeph">STUDENT_T</code>的Java类如下：</p>
                        <div class="section">
                           <p class="subhead3" id="GUID-EF78FF64-5B65-42F7-97B0-5CF233BF9DC8__GUID-895805D9-7E10-4541-8C36-4A63263264A5">Person.java使用OracleData</p>
                        </div>
                        <!-- class="section" -->
                        <div class="section">
                           <p>实现<code class="codeph">OracleData</code>和<code class="codeph">OracleDataFactory</code>接口的<code class="codeph">Person.java</code>类的代码：</p><pre class="oac_no_warn" dir="ltr">public static OracleDataFactory getOracleDataFactory（）{return _personFactory; public Person（）{} public Person（NUMBER ssn，CHAR name，CHAR address）{this.ssn = ssn; this.name = name; this.address =地址; public Object toJDBCObject（OracleConnection c）抛出SQLException {Object [] attributes = {ssn，name，address}; Struct struct = c.createStruct（“HR.PERSON_T”，属性）;返回结构; public OracleData create（Object jdbcValue，int sqlType）抛出SQLException {if（d == null）返回null; Object [] attributes =（（STRUCT）d）.getOracleAttributes（）;返回new Person（（NUMBER）属性[0]，（CHAR）属性[1]，（CHAR）属性[2]）; }}</pre></div>
                        <!-- class="section" -->
                        <div class="section">
                           <p class="subhead3" id="GUID-EF78FF64-5B65-42F7-97B0-5CF233BF9DC8__GUID-A6BFBF89-1F2F-4B90-B2D9-B5DC48709AD1">Student.java扩展Person.java</p>
                        </div>
                        <!-- class="section" -->
                        <div class="section">
                           <p><code class="codeph">Student.java</code>类的代码，它扩展了<code class="codeph">Person.java</code>类：</p><pre class="oac_no_warn" dir="ltr">class Student extends Person {static final Student _studentFactory = new Student（）;公共号码;公共CHAR专业; public static OracleDataFactory getOracleDataFactory（）{return _studentFactory; public Student（）{} public Student（NUMBER ssn，CHAR name，CHAR address，NUMBER deptid，CHAR major）{super（ssn，name，address）; this.deptid = deptid; this.major = major; public Object toJDBCObject（OracleConnection c）抛出SQLException {Object [] attributes = {ssn，name，address，deptid，major}; Struct struct = c.createStruct（“HR.STUDENT_T”，attributes）;返回结构; public OracleData create（Object jdbcValue，int sqlType）抛出SQLException {if（d == null）返回null; Object [] attributes =（（STRUCT）d）.getOracleAttributes（）;返回new Student（（NUMBER）属性[0]，（CHAR）属性[1]，（CHAR）属性[2]，（NUMBER）属性[3]，（CHAR）属性[4]）; }}</pre><p>实现<code class="codeph">OracleData</code>接口的自定义类不必镜像数据库对象类型层次结构。例如，您可以在没有超类的情况下声明<code class="codeph">Student</code>类。在这种情况下， <code class="codeph">Student</code>将包含用于保存<code class="codeph">PERSON_T</code>的继承属性的字段以及<code class="codeph">STUDENT_T</code>声明的属性。</p>
                        </div>
                        <!-- class="section" -->
                        <div class="section">
                           <p class="subhead3" id="GUID-EF78FF64-5B65-42F7-97B0-5CF233BF9DC8__GUID-08E47E90-F85E-4424-BAF1-2860676E801C">OracleDataFactory实现</p>
                        </div>
                        <!-- class="section" -->
                        <div class="section">
                           <p>JDBC应用程序使用工厂类查询数据库以返回<code class="codeph">Person</code>或其子类的实例，如下例所示：</p><pre class="oac_no_warn" dir="ltr">ResultSet rset = stmt.executeQuery（“从tab1中选择人员”）; while（rset.next（））{rset.getOracleData（1，Person.getOracleDataFactory（））; ...}</pre><p>实现<code class="codeph">OracleDataFactory</code>接口的类应该能够生成关联的自定义对象类型的实例，以及任何子类型的实例，或者至少是您希望支持的所有类型的实例。
                           </p>
                           <p>在以下示例中， <code class="codeph">PersonFactory.getOracleDataFactory</code>方法返回一个工厂，该工厂可以通过返回<code class="codeph">person</code> ， <code class="codeph">student</code>或<code class="codeph">parttimestudent</code> Java实例来处理<code class="codeph">PERSON_T</code> ， <code class="codeph">STUDENT_T</code>和<code class="codeph">PARTTIMESTUDENT_T</code>对象。
                           </p><pre class="oac_no_warn" dir="ltr">class PersonFactory实现OracleDataFactory {static final PersonFactory _factory = new PersonFactory（）; public static OracleDataFactory getOracleDataFactory（）{return _factory; public OracleData create（Object jdbcValue，int sqlType）抛出SQLException {STRUCT s =（STRUCT）jdbcValue; if（s.getSQLTypeName（）。equals（“HR.PERSON_T”））返回Person.getOracleDataFactory（）。create（jdbcValue，sqlType）; else if（s.getSQLTypeName（）。equals（“HR.STUDENT_T”））return Student.getOracleDataFactory（）。create（jdbcValue，sqlType）; else if（s.getSQLTypeName（）。equals（“HR.PARTTIMESTUDENT_T”））返回ParttimeStudent.getOracleDataFactory（）。create（jdbcValue，sqlType）; else返回null; }}</pre><p>以下示例假定表<code class="codeph">tabl1</code> ，如下所示：</p><pre class="oac_no_warn" dir="ltr">CREATE TABLE tabl1（idx NUMBER，person PERSON_T）; INSERT INTO tabl1 VALUES（1，PERSON_T（1000，'HR'，'100 Oracle Parkway'））; INSERT INTO tabl1 VALUES（2，STUDENT_T（1001，'Peter'，'200 Oracle Parkway'，101，'CS'））; INSERT INTO tabl1 VALUES（3，PARTTIMESTUDENT_T（1002，'David'，'300 Oracle Parkway'，102，'EE'））;</pre></div>
                        <!-- class="section" -->
                     </div>
                  </div><a id="JJDBC28482"></a><a id="JJDBC28483"></a><a id="JJDBC28484"></a><a id="JJDBC28481"></a><div class="props_rev_3"><a id="GUID-26AC0C12-D473-4957-A9B1-D64DFD0EC71B" name="GUID-26AC0C12-D473-4957-A9B1-D64DFD0EC71B"></a><h5 id="JJDBC-GUID-26AC0C12-D473-4957-A9B1-D64DFD0EC71B" class="sect5"><span class="enumeration_section">13.4.2.2</span>关于使用<span class="enumeration_section">SQLData</span>进行类型继承层次结构</h5>
                     <div>
                        <p>实现<code class="codeph">java.sql.的自定义类<code class="codeph">java.sql.SQLData</code>接口可以镜像数据库对象类型层次结构。子类的<code class="codeph">readSQL</code>和<code class="codeph">writeSQL</code>方法通常在读取或写入子类属性之前调用相应的超类方法来读取或写入超类属性。例如，映射到<code class="codeph">PERSON_T</code>和<code class="codeph">STUDENT_T</code>的Java类如下：</p>
                        <div class="section">
                           <p class="subhead3" id="GUID-26AC0C12-D473-4957-A9B1-D64DFD0EC71B__GUID-AD3DE26D-3E19-4639-B695-79590722E8A3">Person.java使用SQLData</p>
                        </div>
                        <!-- class="section" -->
                        <div class="section">
                           <p><code class="codeph">Person.java</code>类的代码，它实现了<code class="codeph">SQLData</code>接口：</p><pre class="oac_no_warn" dir="ltr">import java.sql。*; public class Person实现SQLData {private String sql_type; public int ssn; public String name; public String address; public Person（）{} public String getSQLTypeName（）throws SQLException {return sql_type; public void readSQL（SQLInput stream，String typeName）抛出SQLException {sql_type = typeName; ssn = stream.readInt（）; name = stream.readString（）; address = stream.readString（）; public void writeSQL（SQLOutput stream）抛出SQLException {stream.writeInt（ssn）; stream.writeString（name）; stream.writeString（address）; }}</pre></div>
                        <!-- class="section" -->
                        <div class="section">
                           <p class="subhead3" id="GUID-26AC0C12-D473-4957-A9B1-D64DFD0EC71B__GUID-66BB23E1-9228-4ED2-B020-4FBBE13A36A9">Student.java扩展了Student.java</p>
                        </div>
                        <!-- class="section" -->
                        <div class="section">
                           <p><code class="codeph">Student.java</code>类的代码，它扩展了<code class="codeph">Person.java</code>类：</p><pre class="oac_no_warn" dir="ltr">import java.sql。*; public class Student extends Person {private String sql_type; public int deptid; public String major; public Student（）{super（）; public String getSQLTypeName（）抛出SQLException {return sql_type; public void readSQL（SQLInput stream，String typeName）抛出SQLException {super.readSQL（stream，typeName）; //读取超类型属性sql_type = typeName; deptid = stream.readInt（）; major = stream.readString（）; public void writeSQL（SQLOutput stream）抛出SQLException {super.writeSQL（stream）; //写supertype //属性stream.writeInt（deptid）; stream.writeString（major）; }}</pre><p>虽然不是必需的，但建议实现<code class="codeph">SQLData</code>接口的自定义类镜像数据库对象类型层次结构。例如，您可以在没有超类的情况下声明<code class="codeph">Student</code>类。在这种情况下， <code class="codeph">Student</code>将包含用于保存<code class="codeph">PERSON_T</code>的继承属性的字段以及<code class="codeph">STUDENT_T</code>声明的属性。</p>
                        </div>
                        <!-- class="section" -->
                        <div class="section">
                           <p class="subhead3" id="GUID-26AC0C12-D473-4957-A9B1-D64DFD0EC71B__GUID-EE80B9FE-3B3D-4194-A3EA-C1240387D7B1">Student.java使用SQLData</p>
                        </div>
                        <!-- class="section" -->
                        <div class="section">
                           <p><code class="codeph">Student.java</code>类的代码，它不扩展<code class="codeph">Person.java</code>类，但直接实现SQLData接口：</p><pre class="oac_no_warn" dir="ltr">import java.sql。*; public class Student实现SQLData {private String sql_type; public int ssn; public String name; public String address; public int deptid; public String major; public Student（）{} public String getSQLTypeName（）throws SQLException {return sql_type; public void readSQL（SQLInput stream，String typeName）抛出SQLException {sql_type = typeName; ssn = stream.readInt（）; name = stream.readString（）; address = stream.readString（）; deptid = stream.readInt（）; major = stream.readString（）; public void writeSQL（SQLOutput stream）抛出SQLException {stream.writeInt（ssn）; stream.writeString（name）; stream.writeString（address）; stream.writeInt（deptid）; stream.writeString（major）; }}</pre></div>
                        <!-- class="section" -->
                     </div>
                  </div>
               </div><a id="JJDBC28487"></a><a id="JJDBC28488"></a><a id="JJDBC28489"></a><a id="JJDBC28486"></a><div class="props_rev_3"><a id="GUID-9E0B6269-71FD-4F4C-83B5-D31D214655A0" name="GUID-9E0B6269-71FD-4F4C-83B5-D31D214655A0"></a><h4 id="JJDBC-GUID-9E0B6269-71FD-4F4C-83B5-D31D214655A0" class="sect4"><span class="enumeration_section">13.4.3</span>关于检索子类型对象</h4>
                  <div>
                     <p>在典型的JDBC应用程序中，子类型对象将作为以下之一返回：</p>
                     <ul style="list-style-type:disc">
                        <li>
                           <p>查询结果</p>
                        </li>
                        <li>
                           <p>PL / SQL <code class="codeph">OUT</code>参数</p>
                        </li>
                        <li>
                           <p>类型属性</p>
                        </li>
                     </ul>
                     <p>您可以使用默认映射或<code class="codeph">SQLData</code>映射或<code class="codeph">OracleData</code>映射来检索子类型。
                     </p>
                     <div class="section">
                        <p class="subhead3" id="GUID-9E0B6269-71FD-4F4C-83B5-D31D214655A0__GUID-942D43C1-39B4-4356-A2C5-3D1B1D9FCFDD">使用默认映射</p>
                     </div>
                     <!-- class="section" -->
                     <div class="section">
                        <p>默认情况下，数据库对象作为<code class="codeph">oracle.jdbc.的实例返回<code class="codeph">oracle.jdbc.OracleStruct</code>接口。此实例可以表示声明类型的声明类型或子类型的对象。如果<code class="codeph">OracleStruct</code>接口表示数据库中的子类型对象，则它包含其超类型的属性以及子类型中定义的属性。
                        </p>
                        <p>Oracle JDBC驱动程序以最特定的类型返回数据库对象。JDBC应用程序可以使用<code class="codeph">OracleStruct</code>接口的<code class="codeph">getSQLTypeName</code>方法来确定<code class="codeph">STRUCT</code>对象的SQL类型。以下代码显示了这一点：</p><pre class="oac_no_warn" dir="ltr">// tab1.person列可以存储PERSON_T，STUDENT_T和PARTIMESTUDENT_T对象ResultSet rset = stmt.executeQuery（“从tab1中选择人员”）; while（rset.next（））{oracle.sql。STRUCT s =（oracle.sql。STRUCT）rset.getObject（1）;如果（s！= null）System.out.println（s.getSQLTypeName（））; //打印出//可能是HR.PERSON_T，HR.STUDENT_T或HR.PARTTIMESTUDENT_T}的类型名称</pre></div>
                     <!-- class="section" -->
                     <div class="section">
                        <p class="subhead3" id="GUID-9E0B6269-71FD-4F4C-83B5-D31D214655A0__GUID-9CE4AA48-A012-4F10-8B67-9F6B78AD67E4">使用SQLData映射</p>
                     </div>
                     <!-- class="section" -->
                     <div class="section">
                        <p>使用<code class="codeph">SQLData</code>映射，JDBC驱动程序将数据库对象作为实现<code class="codeph">SQLData</code>接口的类的实例返回。
                        </p>
                        <p>要在检索数据库对象时使用<code class="codeph">SQLData</code>映射，请执行以下操作：</p>
                        <ol>
                           <li>
                              <p>实现为所需对象类型实现<code class="codeph">SQLData</code>接口的容器类。
                              </p>
                           </li>
                           <li>
                              <p>使用指定每个Oracle对象类型对应的自定义Java类型的条目填充连接类型映射。</p>
                           </li>
                           <li>
                              <p>使用<code class="codeph">getObject</code>方法访问SQL对象值。
                              </p>
                              <p>JDBC驱动程序检查类型映射以查找条目匹配。如果存在，则驱动程序将数据库对象作为实现<code class="codeph">SQLData</code>接口的类的实例返回。
                              </p>
                           </li>
                        </ol>
                        <p>以下代码显示了整个SQLData自定义映射过程：</p><pre class="oac_no_warn" dir="ltr">// JDBC应用程序开发人员为PERSON_T实现Person.java，为STUDENT_T //实现Student.java，为PARTTIMESTUDEN_T实现ParttimeStudent.java。连接conn = ...; //建立JDBC连接//获取连接类型映射java.util。Map map = conn.getTypeMap（）; //填充类型映射map.put（“HR.PERSON_T”，Class.forName（“Person”））; map.put（“HR.STUDENT_T”，Class.forName（“Student”））; map.put（“HR.PARTTIMESTUDENT_T”，Class.forName（“ParttimeStudent”））; // tab1.person列可以存储PERSON_T，STUDENT_T和PARTTIMESTUDENT_T对象ResultSet rset = stmt.executeQuery（“从tab1中选择人员”）; while（rset.next（））{//“s”是Person，Student或ParttimeStudent对象的实例s = rset.getObject（1）;如果（s！= null）{if（s instanceof Person）System.out.println（“This is a Person”）; else if（s instanceof Student）System.out.println（“This is a Student”）; else if（s instanceof ParttimeStudent）System.out.pritnln（“这是PartimeStudent”）; else System.out.println（“未知类型”）; }}</pre><p>JDBC驱动程序检查每次调用以下内容的连接类型映射：</p>
                        <ul style="list-style-type:disc">
                           <li>
                              <p><code class="codeph">java.sql. <code class="codeph">getObject</code>方法<code class="codeph">java.sql.ResultSet</code>和<code class="codeph">java.sql.CallableStatement</code>接口</p>
                           </li>
                           <li>
                              <p><code class="codeph">java.sql. <code class="codeph">getAttribute</code>方法<code class="codeph">java.sql.Struct</code>界面</p>
                           </li>
                           <li>
                              <p><code class="codeph">java.sql. <code class="codeph">getArray</code>方法<code class="codeph">java.sql.Array</code>接口</p>
                           </li>
                           <li>
                              <p><code class="codeph">oracle.sql. <code class="codeph">getValue</code>方法<code class="codeph">oracle.sql.REF</code>接口</p>
                           </li>
                        </ul>
                     </div>
                     <!-- class="section" -->
                     <div class="section">
                        <p class="subhead3" id="GUID-9E0B6269-71FD-4F4C-83B5-D31D214655A0__GUID-D9C1D077-F39C-4D37-9B04-46C16FFAF791">使用OracleData Mapping</p>
                     </div>
                     <!-- class="section" -->
                     <div class="section">
                        <p>使用<code class="codeph">OracleData</code>映射，JDBC驱动程序将数据库对象作为实现<code class="codeph">OracleData</code>接口的类的实例返回。
                        </p>
                        <p>需要通知Oracle JDBC驱动程序将Java类映射到Oracle对象类型。以下是通知Oracle JDBC驱动程序的两种方法：</p>
                        <ul style="list-style-type:disc">
                           <li>
                              <p>JDBC应用程序使用<code class="codeph">getObject(int idx, OracleDataFactory f)</code>方法来访问数据库对象。<code class="codeph">getObject</code>方法的第二个参数指定生成自定义类的工厂类的实例。该<code class="codeph">getObject</code>方法是可用的<code class="codeph">OracleResultSet</code>和<code class="codeph">OracleCallableStatement</code>接口。
                              </p>
                           </li>
                           <li>
                              <p>JDBC应用程序使用条目填充连接类型映射，这些条目指定每个Oracle对象类型对应的自定义Java类型。<code class="codeph">getObject</code>方法用于访问Oracle对象值。
                              </p>
                           </li>
                        </ul>
                        <p>第二种方法涉及使用标准的<code class="codeph">getObject</code>方法。以下代码示例演示了第一种方法：</p><pre class="oac_no_warn" dir="ltr">// tab1.person列可以存储PERSON_T和STUDENT_T对象ResultSet rset = stmt.executeQuery（“从tab1中选择人员”）; while（rset.next（））{Object s = rset.getObject（1，PersonFactory.getOracleDataFactory（））;如果（s！= null）{if（s instanceof Person）System.out.println（“This is a Person”）; else if（s instanceof Student）System.out.println（“This is a Student”）; else if（s instanceof ParttimeStudent）System.out.pritnln（“这是PartimeStudent”）; else System.out.println（“未知类型”）; }}</pre></div>
                     <!-- class="section" -->
                  </div>
               </div><a id="JJDBC28490"></a><div class="props_rev_3"><a id="GUID-EDEEF48A-DBEE-484D-BC65-577DD9665ACA" name="GUID-EDEEF48A-DBEE-484D-BC65-577DD9665ACA"></a><h4 id="JJDBC-GUID-EDEEF48A-DBEE-484D-BC65-577DD9665ACA" class="sect4"><span class="enumeration_section">13.4.4</span>创建子类型对象</h4>
                  <div>
                     <div class="section">
                        <p>在某些情况下，JDBC应用程序使用JDBC驱动程序创建数据库子类型对象。这些对象作为绑定变量发送到数据库，或用于在JDBC应用程序中交换信息。</p>
                        <p>通过自定义映射，JDBC应用程序可以根据您选择的方法创建基于<code class="codeph">SQLData</code>或基于<code class="codeph">OracleData</code>的对象，以表示数据库子类型对象。使用默认映射，JDBC应用程序创建<code class="codeph">STRUCT</code>对象以表示数据库子类型对象。从超类型继承的所有数据字段以及子类型中定义的所有字段都必须具有值。以下代码演示了这一点：</p><pre class="oac_no_warn" dir="ltr">Connection conn = ... //建立JDBC连接......Object [] attrs = {new Integer（1234），“HR”，“500 Oracle Parkway”，//在// PERSON_T new Integer（102）中定义的数据字段，“CS”，//在STUDENT_T中定义的数据字段新的整数（4）// // PARTTIMESTUDENT_T}中定义的数据字段; Struct s = conn.createStruct（“HR.PARTTIMESTUDENT”，attrs）;</pre><p>使用从<code class="codeph">PERSON_T</code>和<code class="codeph">STUDENT_T</code>继承的数据字段以及<code class="codeph">PARTTIMESTUDENT_T</code>定义的数据字段初始化<code class="codeph">s</code> 。</p>
                     </div>
                     <!-- class="section" -->
                  </div>
               </div><a id="JJDBC28491"></a><div class="props_rev_3"><a id="GUID-B7A9E9B9-ED8B-4EBA-94F1-C048876DB314" name="GUID-B7A9E9B9-ED8B-4EBA-94F1-C048876DB314"></a><h4 id="JJDBC-GUID-B7A9E9B9-ED8B-4EBA-94F1-C048876DB314" class="sect4"><span class="enumeration_section">13.4.5</span>发送子类型对象</h4>
                  <div>
                     <div class="section">
                        <p>在典型的JDBC应用程序中，表示数据库对象的Java对象将作为以下之一发送到数据库：</p>
                     </div>
                     <!-- class="section" -->
                     <div class="section">
                        <ul style="list-style-type:disc">
                           <li>
                              <p>数据操作语言（DML）绑定变量</p>
                           </li>
                           <li>
                              <p>PL / SQL <code class="codeph">IN</code>参数</p>
                           </li>
                           <li>
                              <p>对象类型属性值</p>
                           </li>
                        </ul>
                        <p>Java对象可以是<code class="codeph">STRUCT</code>类的实例，也可以是实现<code class="codeph">SQLData</code>或<code class="codeph">OracleData</code>接口的类的实例。Oracle JDBC驱动程序将Java对象转换为数据库SQL引擎可接受的线性化格式。绑定子类型对象与绑定标准对象相同。
                        </p>
                     </div>
                     <!-- class="section" -->
                  </div>
               </div><a id="JJDBC28493"></a><a id="JJDBC28494"></a><a id="JJDBC28492"></a><div class="props_rev_3"><a id="GUID-4D4E75B2-AFE4-4C34-BDCD-C06D0D27EAB2" name="GUID-4D4E75B2-AFE4-4C34-BDCD-C06D0D27EAB2"></a><h4 id="JJDBC-GUID-4D4E75B2-AFE4-4C34-BDCD-C06D0D27EAB2" class="sect4"><span class="enumeration_section">13.4.6</span>访问子类型数据字段</h4>
                  <div>
                     <div class="section">
                        <p>虽然访问子类型数据字段的逻辑是自定义类的一部分，但默认映射的逻辑在JDBC应用程序本身中定义。数据库对象作为<code class="codeph">oracle.jdbc.实例返回<code class="codeph">oracle.jdbc.OracleStruct</code>类。JDBC应用程序需要调用<code class="codeph">STRUCT</code>类中的以下访问方法之一来访问数据字段：</p>
                     </div>
                     <!-- class="section" -->
                     <div class="section">
                        <ul style="list-style-type:disc">
                           <li>
                              <p><code class="codeph">Object [] getAttribute（）</code></p>
                           </li>
                           <li>
                              <p><code class="codeph">oracle.sql。Datum [] getOracleAttribute（）</code></p>
                           </li>
                        </ul>
                     </div>
                     <!-- class="section" -->
                     <div class="section">
                        <p class="subhead3" id="GUID-4D4E75B2-AFE4-4C34-BDCD-C06D0D27EAB2__GUID-1750EBD8-BCF9-41F2-956F-E2B08202B3E5">getAttribute方法中的子类型数据字段</p>
                     </div>
                     <!-- class="section" -->
                     <div class="section">
                        <p><code class="codeph">java.sql.的<code class="codeph">getAttribute</code>方法<code class="codeph">java.sql.JDBC 2.0中使用Struct</code>接口来访问对象数据字段。此方法返回<code class="codeph">java.lang.Object</code>数组，其中每个数组元素表示一个对象属性。您可以通过在JDBC转换矩阵中引用相应的属性类型来确定单个元素类型。例如，SQL <code class="codeph">NUMBER</code>属性将转换为<code class="codeph">java.math.BigDecimal</code>对象。<code class="codeph">getAttribute</code>方法返回在对象类型的超类型中定义的所有数据字段以及在子类型中定义的数据字段。首先列出超类型数据字段，然后是子类型数据字段。
                        </p>
                     </div>
                     <!-- class="section" -->
                     <div class="section">
                        <p class="subhead3" id="GUID-4D4E75B2-AFE4-4C34-BDCD-C06D0D27EAB2__GUID-961E150A-E595-4827-B49C-2B5213D980B8">getOracleAttribute方法中的子类型数据字段</p>
                     </div>
                     <!-- class="section" -->
                     <div class="section">
                        <p><code class="codeph">getOracleAttribute</code>方法是Oracle扩展方法，比<code class="codeph">getAttribute</code>方法更有效。<code class="codeph">getOracleAttribute</code>方法返回<code class="codeph">oracle.sql.用于保存数据字段的Datum</code>数组。<code class="codeph">oracle.sql.每个元素<code class="codeph">oracle.sql.Datum</code>数组表示属性。您可以通过引用Oracle转换矩阵中的相应属性类型来确定单个元素类型。例如，SQL <code class="codeph">NUMBER</code>属性将转换为<code class="codeph">oracle.sql.NUMBER</code>对象。<code class="codeph">getOracleAttribute</code>方法返回在对象类型的超类型中定义的所有属性，以及在子类型中定义的属性。首先列出超类型数据字段，然后是子类型数据字段。
                        </p>
                        <p>以下代码显示了<code class="codeph">getAttribute</code>方法的用法：</p><pre class="oac_no_warn" dir="ltr">// tab1.person列可以存储PERSON_T，STUDENT_T和PARTIMESTUDENT_T对象ResultSet rset = stmt.executeQuery（“从tab1中选择人员”）; while（rset.next（））{oracle.sql。STRUCT s =（oracle.sql。STRUCT）rset.getObject（1）;如果（s！= null）{String sqlname = s.getSQLTypeName（）; <span class="bold">Object [] attrs = s.getAttribute（）;</span> if（sqlname.equals（“HR.PERSON”）{System.out.println（“ssn =”+（（BigDecimal）attrs [0]）。intValue（））; System.out.println（“name =”+ （（String）attrs [1]））; System.out.println（“address =”+（（String）attrs [2]））;} else if（sqlname.equals（“HR.STUDENT”））{System .out.println（“ssn =”+（（BigDecimal）attrs [0]）。intValue（））; System.out.println（“name =”+（（String）attrs [1]））; System.out .println（“address =”+（（String）attrs [2]））; System.out.println（“deptid =”+（（BigDecimal）attrs [3]）。intValue（））; System.out.println （“major =”+（（String）attrs [4]））;} else if（sqlname.equals（“HR.PARTTIMESTUDENT”））{System.out.println（“ssn =”+（（BigDecimal）attrs [ 0]）。intValue（））; System.out.println（“name =”+（（String）attrs [1]））; System.out.println（“address =”+（（String）attrs [2] ）;; System.out.println（“deptid =”+（（BigDecimal）attrs [3]）。intValue（））; System.out.println（“major =”+（（String）attrs [4]）） ; System.out.println（“numHours =”+（（BigDecimal）attrs [5]）。intValue（））;} else抛出新的异常（“无效的类型名称：”+ sqlname）;}} rset.close（） ; stmt.close（）; conn.close（）;</pre></div>
                     <!-- class="section" -->
                  </div>
               </div><a id="JJDBC28495"></a><div class="props_rev_3"><a id="GUID-E0C046C2-4F00-49EB-89B8-D2C147C5C75F" name="GUID-E0C046C2-4F00-49EB-89B8-D2C147C5C75F"></a><h4 id="JJDBC-GUID-E0C046C2-4F00-49EB-89B8-D2C147C5C75F" class="sect4"><span class="enumeration_section">13.4.7</span>继承元数据方法</h4>
                  <div>
                     <div class="section">
                        <p>Oracle JDBC驱动程序提供了一组元数据方法来访问继承属性。继承元数据方法在<code class="codeph">oracle.sql.中定义<code class="codeph">oracle.sql.StructDescriptor</code>和<code class="codeph">oracle.jdbc.StructMetaData</code>类。
                        </p>
                        <p><code class="codeph">StructMetaData</code>类为子类型属性提供继承元数据方法。<code class="codeph">StructDescriptor</code>类的<code class="codeph">getMetaData</code>方法返回该类型的<code class="codeph">StructMetaData</code>实例。<code class="codeph">StructMetaData</code>类包含以下继承元数据方法：</p>
                     </div>
                     <!-- class="section" -->
                  </div>
               </div>
            </div><a id="JJDBC28505"></a><div class="props_rev_3"><a id="GUID-4D737F6A-66F6-4C67-BC9A-233A89F75FFD" name="GUID-4D737F6A-66F6-4C67-BC9A-233A89F75FFD"></a><h3 id="JJDBC-GUID-4D737F6A-66F6-4C67-BC9A-233A89F75FFD" class="sect3"><span class="enumeration_section">13.5</span>关于描述对象类型</h3>
               <div>
                  <div class="section">
                     <p>Oracle JDBC包括检索有关其属性名称和类型的结构化对象类型的信息的功能。这在概念上类似于从结果集中检索有关其列名和类型的信息，并且实际上使用几乎相同的方法。</p>
                     <p>本节包括以下主题：</p>
                     <ul style="list-style-type:disc">
                        <li>
                           <p><a href="Oracle-object-types.html#GUID-BE316A98-BAAD-4B15-A8DA-D9E081E9F2D4">获取对象元数据的功能</a></p>
                        </li>
                        <li>
                           <p><a href="Oracle-object-types.html#GUID-1C6748F4-AC7D-4645-9A00-6F366C553B16">检索对象元数据</a></p>
                        </li>
                     </ul>
                  </div>
                  <!-- class="section" -->
               </div><a id="JJDBC28506"></a><div class="props_rev_3"><a id="GUID-BE316A98-BAAD-4B15-A8DA-D9E081E9F2D4" name="GUID-BE316A98-BAAD-4B15-A8DA-D9E081E9F2D4"></a><h4 id="JJDBC-GUID-BE316A98-BAAD-4B15-A8DA-D9E081E9F2D4" class="sect4"><span class="enumeration_section">13.5.1</span>获取对象元数据的功能</h4>
                  <div>
                     <div class="section">
                        <p><code class="codeph">oracle.sql.StructDescriptor</code>类包括检索有关结构化对象类型的元数据的功能。<code class="codeph">StructDescriptor</code>类具有<code class="codeph">getMetaData</code>方法，其功能与结果集对象中可用的标准<code class="codeph">getMetaData</code>方法相同。它返回一组属性信息，例如属性名称和类型。在<code class="codeph">StructDescriptor</code>对象上调用此方法以获取有关<code class="codeph">StructDescriptor</code>对象描述的Oracle对象类型的元数据。
                        </p>
                        <p><code class="codeph">StructDescriptor</code>类<code class="codeph">getMetaData</code>方法的签名与标准<code class="codeph">ResultSet</code>接口中为<code class="codeph">getMetaData</code>指定的签名相同。签名如下：</p><pre class="oac_no_warn" dir="ltr">ResultSetMetaData getMetaData（）抛出SQLException</pre><p>但是，此方法实际上返回<code class="codeph">oracle.jdbc.的实例<code class="codeph">oracle.jdbc.StructMetaData</code> ，一个以与标准<code class="codeph">java.sql.相同的方式支持结构化对象元数据的类<code class="codeph">java.sql.ResultSetMetaData</code>接口指定对结果集元数据的支持。
                        </p>
                        <p><code class="codeph">StructMetaData</code>也支持以下方法：</p><pre class="oac_no_warn" dir="ltr">String getOracleColumnClassName（int column）抛出SQLException</pre><p>此方法返回<code class="codeph">oracle.sql.的完全限定名称<code class="codeph">oracle.sql.如果<code class="codeph">OracleResultSet</code>接口<code class="codeph">getOracleObject</code>方法来检索指定属性的值，则生成其实例的Datum</code>子类。例如， <code class="codeph">oracle.sql.NUMBER</code> 。</p>
                        <p>要使用<code class="codeph">getOracleColumnClassName</code>方法，必须将<code class="codeph">getMetaData</code>方法返回的<code class="codeph">ResultSetMetaData</code>对象<code class="codeph">StructMetaData</code>为<code class="codeph">StructMetaData</code> 。
                        </p>
                        <ul style="list-style-type:disc">
                           <li>
                              <div class="infoboxnote" id="GUID-BE316A98-BAAD-4B15-A8DA-D9E081E9F2D4__GUID-DCCF7172-A7CE-4F5D-856E-112DB9A909BC">
                                 <p class="notep1">注意：</p>
                                 <p>在上述所有方法签名中， <code class="codeph">column</code>都是用词不当。如果为<code class="codeph">column</code>指定值4，则实际上是指对象的第四个属性。
                                 </p>
                              </div>
                           </li>
                        </ul>
                     </div>
                     <!-- class="section" -->
                  </div>
               </div><a id="JJDBC28508"></a><a id="JJDBC28507"></a><div class="props_rev_3"><a id="GUID-1C6748F4-AC7D-4645-9A00-6F366C553B16" name="GUID-1C6748F4-AC7D-4645-9A00-6F366C553B16"></a><h4 id="JJDBC-GUID-1C6748F4-AC7D-4645-9A00-6F366C553B16" class="sect4"><span class="enumeration_section">13.5.2</span>检索对象元数据</h4>
                  <div>
                     <div class="section">
                        <p>使用以下步骤获取有关结构化对象类型的元数据：</p>
                     </div>
                     <!-- class="section" -->
                     <ol>
                        <li class="stepexpand" id="GUID-1C6748F4-AC7D-4645-9A00-6F366C553B16__BABBJBEG"><span>创建或获取描述相关结构化对象类型的<code class="codeph">StructDescriptor</code>实例。</span></li>
                        <li class="stepexpand"><span>在<code class="codeph">StructDescriptor</code>实例上调用<code class="codeph">getMetaData</code>方法。</span></li>
                        <li class="stepexpand" id="GUID-1C6748F4-AC7D-4645-9A00-6F366C553B16__BABFDCJH"><span>根据需要调用元数据getter方法， <code class="codeph">getColumnName</code> ， <code class="codeph">getColumnType</code>和<code class="codeph">getColumnTypeName</code> 。</span><div>
                              <div class="infoboxnote" id="GUID-1C6748F4-AC7D-4645-9A00-6F366C553B16__GUID-4444BB26-A13D-4916-B727-4749B86F14A4">
                                 <p class="notep1">注意：</p>
                                 <p>如果其中一个结构化对象属性本身是结构化对象，请重复步骤1到3。</p>
                              </div>
                           </div>
                        </li>
                     </ol>
                     <div class="example" id="GUID-1C6748F4-AC7D-4645-9A00-6F366C553B16__GUID-2314DB02-7822-45AF-9391-1EF6AB365EB4">
                        <p class="titleinexample">例13-1例子</p>
                        <p>以下方法显示如何检索有关结构化对象类型的属性的信息。这包括创建<code class="codeph">StructDescriptor</code>实例的初始步骤。
                        </p><pre class="oac_no_warn" dir="ltr">// //打印出ADT的属性名称和类型// void getAttributeInfo（Connection conn，String type_name）抛出SQLException {</pre><pre class="oac_no_warn" dir="ltr">//获取类型描述符StructDescriptor desc = StructDescriptor.createDescriptor（type_name，conn）; //获取类型元数据ResultSetMetaData md = desc.getMetaData（）; //获取此类型的att＃int numAttrs = desc.length（）; //临时缓冲区字符串attr_name; int attr_type; String attr_typeName; System.out.println（“Attributes of”+ type_name +“：”）; for（int i = 0; i &lt;numAttrs; i ++）{attr_name = md.getColumnName（i + 1）; attr_type = md.getColumnType（i + 1）; System.out.println（“index”+（i + 1）+“name =”+ attr_name +“type =”+ attr_type）; //向下钻取嵌套对象if（attrType == OracleTypes。STRUCT）{attr_typeName = md.getColumnTypeName（i + 1）; //递归调用打印出嵌套对象元数据getAttributeInfo（conn，attr_typeName）; }}}</pre></div>
                     <!-- class="example" -->
                  </div>
               </div>
            </div>
         </div>
      </article>
   </body>
</html>