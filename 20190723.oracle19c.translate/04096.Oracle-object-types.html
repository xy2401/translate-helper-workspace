<!DOCTYPE html
  SYSTEM "about:legacy-compat">
<html xml:lang="en-us" lang="en-us">
   <head>
      <meta http-equiv="Content-Type" content="text/html; charset=utf-8">
      <meta name="viewport" content="width=device-width, initial-scale=1">
      <meta http-equiv="X-UA-Compatible" content="IE=edge">
      <title>Working with Oracle Object Types</title>
      <meta property="og:site_name" content="Oracle Help Center">
      <meta property="og:title" content="JDBC Developer's Guide">
      <meta property="og:description" content="">
      <link rel="stylesheet" href="/sp_common/book-template/ohc-book-template/css/book.css">
      <link rel="shortcut icon" href="/sp_common/book-template/ohc-common/img/favicon.ico">
      <meta name="application-name" content="JDBC Developer's Guide">
      <meta name="generator" content="DITA Open Toolkit version 1.8.5 (Mode = doc)">
      <meta name="plugin" content="SP_docbuilder HTML plugin release 18.2.2">
      <link rel="alternate" href="jdbc-developers-guide.pdf" title="PDF File" type="application/pdf">
      <meta name="robots" content="all">
      <link rel="schema.dcterms" href="http://purl.org/dc/terms/">
      <meta name="dcterms.created" content="2019-02-13T13:20:37-08:00">
      <meta name="dcterms.title" content="JDBC Developer's Guide">
      <meta name="dcterms.dateCopyrighted" content="1999, 2019">
      <meta name="dcterms.category" content="database">
      <meta name="dcterms.identifier" content="E96471-02">
      
      <meta name="dcterms.product" content="en/database/oracle/oracle-database/19">
      
      <link rel="prev" href="Java-streams-in-JDBC.html" title="Previous" type="text/html">
      <link rel="next" href="LOBs-and-BFiles.html" title="Next" type="text/html">
      <script>
        document.write('<style type="text/css">');
        document.write('body > .noscript, body > .noscript ~ * { visibility: hidden; }');
        document.write('</style>');
     </script>
      <script data-main="/sp_common/book-template/ohc-book-template/js/book-config" src="/sp_common/book-template/requirejs/require.js"></script>
      <script>
            if (window.require === undefined) {
                document.write('<script data-main="sp_common/book-template/ohc-book-template/js/book-config" src="sp_common/book-template/requirejs/require.js"><\/script>');
                document.write('<link href="sp_common/book-template/ohc-book-template/css/book.css" rel="stylesheet"/>');
            }
        </script>
      <script type="application/json" id="ssot-metadata">{"primary":{"category":{"short_name":"database","element_name":"Database","display_in_url":true},"suite":{"short_name":"oracle","element_name":"Oracle","display_in_url":true},"product_group":{"short_name":"not-applicable","element_name":"Not applicable","display_in_url":false},"product":{"short_name":"oracle-database","element_name":"Oracle Database","display_in_url":true},"release":{"short_name":"19","element_name":"Release 19","display_in_url":true}}}</script>
      
    <meta name="dcterms.isVersionOf" content="JJDBC">
    <meta name="dcterms.release" content="Release 19">
  </head>
   <body>
      <div class="noscript alert alert-danger text-center" role="alert">
         <a href="Java-streams-in-JDBC.html" class="pull-left"><span class="glyphicon glyphicon-chevron-left" aria-hidden="true"></span>Previous</a>
         <a href="LOBs-and-BFiles.html" class="pull-right">Next<span class="glyphicon glyphicon-chevron-right" aria-hidden="true"></span></a>
         <span class="fa fa-exclamation-triangle" aria-hidden="true"></span> JavaScript must be enabled to correctly display this content
        
      </div>
      <article>
         <header>
            <ol class="breadcrumb" vocab="http://schema.org/" typeof="BreadcrumbList">
               <li property="itemListElement" typeof="ListItem"><a href="index.html" property="item" typeof="WebPage"><span property="name">JDBC Developer's Guide</span></a></li>
               <li property="itemListElement" typeof="ListItem"><a href="data-access-and-manipulation.html" property="item" typeof="WebPage"><span property="name"> Data Access and Manipulation</span></a></li>
               <li class="active" property="itemListElement" typeof="ListItem"> Working with Oracle Object Types </li>
            </ol>
            <a id="GUID-5905674A-A045-40B1-96DE-726761517D50" name="GUID-5905674A-A045-40B1-96DE-726761517D50"></a><a id="JJDBC28431"></a>
            
            <h2 id="JJDBC-GUID-5905674A-A045-40B1-96DE-726761517D50" class="sect2"><span class="enumeration_chapter">13 </span> Working with Oracle Object Types 
            </h2>
         </header>
         <div class="ind">
            <div>
               <p><a id="d51198e21" class="indexterm-anchor"></a><a id="d51198e25" class="indexterm-anchor"></a>This chapter describes the Java Database Connectivity (JDBC) support for user-defined object types. It discusses functionality of the generic, weakly typed <code class="codeph">oracle.sql.STRUCT</code> class, as well as how to map to custom Java classes that implement either the JDBC standard <code class="codeph">SQLData</code> interface or the Oracle-specific <code class="codeph">OracleData</code> interface.
               </p>
               <div class="infoboxnote" id="GUID-5905674A-A045-40B1-96DE-726761517D50__GUID-B1E97578-48C4-47BA-8F99-B23594622084">
                  <p class="notep1">Note:</p>
                  <p>Starting from Oracle Database 12<span class="italic">c </span>Release 1 (12.1), the <code class="codeph">oracle.sql.STRUCT</code> class is deprecated and replaced with the <code class="codeph">oracle.jdbc.OracleStruct</code> interface, which is a part of the <code class="codeph">oracle.jdbc</code> package. Oracle strongly recommends you to use the methods available in the <code class="codeph">java.sql</code> package, where possible, for standard compatibility and methods available in the <code class="codeph">oracle.jdbc</code> package for Oracle specific extensions. Refer to MoS Note 1364193.1 for more information about the <code class="codeph">oracle.jdbc.OracleStruct</code> interface.
                  </p>
               </div>
               <p>The following topics are covered:</p>
               <ul style="list-style-type: disc;">
                  <li>
                     <p><a href="Oracle-object-types.html#GUID-D8784F68-C051-4068-9F34-23913C6733F7">About Mapping Oracle Objects</a></p>
                  </li>
                  <li>
                     <p><a href="Oracle-object-types.html#GUID-962C3E5C-1208-4A63-8130-6347ED9231C5">About Using the Default STRUCT Class for Oracle Objects</a></p>
                  </li>
                  <li>
                     <p><a href="Oracle-object-types.html#GUID-0128E185-086F-41CD-BECC-63A42EBB142C">About Creating and Using Custom Object Classes for Oracle Objects</a></p>
                  </li>
                  <li>
                     <p><a href="Oracle-object-types.html#GUID-E47B8141-3C4C-44D5-BB5C-2F8E16DF5140">Object-Type Inheritance</a></p>
                  </li>
                  <li>
                     <p><a href="Oracle-object-types.html#GUID-4D737F6A-66F6-4C67-BC9A-233A89F75FFD">About Describing an Object Type</a></p>
                  </li>
               </ul>
            </div>
            <div>
               <div class="relinfo">
                  <p><strong>Related Topics</strong></p>
                  <ul>
                     <li><a href="JDBC-reference-information.html#GUID-E77C2AE8-E22B-48BF-A4CB-010CBC8FE7C2">About Using PL/SQL Types</a></li>
                  </ul>
               </div>
            </div>
            <a id="JJDBC28432"></a><div class="props_rev_3"><a id="GUID-D8784F68-C051-4068-9F34-23913C6733F7" name="GUID-D8784F68-C051-4068-9F34-23913C6733F7"></a><h3 id="JJDBC-GUID-D8784F68-C051-4068-9F34-23913C6733F7" class="sect3"><span class="enumeration_section">13.1 </span>About Mapping Oracle Objects
               </h3>
               <div>
                  <p><a id="d51198e132" class="indexterm-anchor"></a>Oracle object types provide support for composite data structures in the database. For example, you can define a <code class="codeph">Person</code> type that has the attributes <code class="codeph">name</code> of <code class="codeph">CHAR</code> type, <code class="codeph">phoneNumber</code> of <code class="codeph">CHAR</code> type, and <code class="codeph">employeeNumber</code> of <code class="codeph">NUMBER</code> type.
                  </p>
                  <p>Oracle provides tight integration between its <a id="d51198e161" class="indexterm-anchor"></a>Oracle object features and its JDBC functionality. You can use a standard, generic JDBC type to map to Oracle objects, or you can customize the mapping by creating custom Java type definition classes.
                  </p>
                  <div class="infoboxnote" id="GUID-D8784F68-C051-4068-9F34-23913C6733F7__GUID-B09543A0-045B-479D-9B64-428E41E216A2">
                     <p class="notep1">Note:</p>
                     <p>In this book, Java classes that you create to map to Oracle objects will be referred to as <span class="bold">custom Java classes</span> or, more specifically, <span class="bold">custom object classes</span>. This is as opposed to <span class="bold">custom references classes</span>, which are Java classes that map to object references, and <span class="bold">custom collection classes</span>, which are Java classes that map to Oracle collections.
                     </p>
                  </div>
                  <p>Custom object classes can implement either a standard JDBC interface or an Oracle extension interface to read and write data. JDBC materializes Oracle objects as instances of particular Java classes. Two main steps in using JDBC to access Oracle objects are:</p>
                  <ol>
                     <li>
                        <p>Creating the Java classes for the Oracle objects</p>
                     </li>
                     <li>
                        <p>Populating these classes. You have the following options:</p>
                        <ul style="list-style-type: disc;">
                           <li>
                              <p>Let JDBC materialize the object as a <code class="codeph">STRUCT</code> object.
                              </p>
                           </li>
                           <li>
                              <p>Explicitly specify the mappings between Oracle objects and Java classes.</p>
                              <p>This includes customizing your Java classes for object data. The driver then must be able to populate instances of the custom object classes that you specify. This imposes a set of constraints on the Java classes. To satisfy these constraints, you can define your classes to implement either the JDBC standard <code class="codeph">java.sql.SQLData</code> interface or the Oracle extension <code class="codeph">oracle.jdbc.OracleData</code> interface.
                              </p>
                           </li>
                        </ul>
                     </li>
                  </ol>
                  <div class="infoboxnote" id="GUID-D8784F68-C051-4068-9F34-23913C6733F7__GUID-C5780BA8-94EA-4BF8-AA6D-635D3AD80796">
                     <p class="notep1">Note:</p>
                     <p>When you use the <code class="codeph">SQLData</code> interface, you must use a Java type map to specify your SQL-Java mapping, unless weakly typed <code class="codeph">java.sql.Struct</code> objects will suffice.
                     </p>
                  </div>
               </div>
            </div><a id="JJDBC28433"></a><div class="props_rev_3"><a id="GUID-962C3E5C-1208-4A63-8130-6347ED9231C5" name="GUID-962C3E5C-1208-4A63-8130-6347ED9231C5"></a><h3 id="JJDBC-GUID-962C3E5C-1208-4A63-8130-6347ED9231C5" class="sect3"><span class="enumeration_section">13.2 </span>About Using the Default STRUCT Class for Oracle Objects
               </h3>
               <div>
                  <p>This section covers the following topics:</p>
                  <ul style="list-style-type: disc;">
                     <li>
                        <p><a href="Oracle-object-types.html#GUID-21636EC9-B321-43A8-AAED-0329A8371D5C">Overview of Using the Struct Class</a></p>
                     </li>
                     <li>
                        <p><a href="Oracle-object-types.html#GUID-13EB6E85-4356-4653-9822-855691AACC4A">Retrieving STRUCT Objects and Attributes</a></p>
                     </li>
                     <li>
                        <p><a href="Oracle-object-types.html#GUID-00F1EBB3-B60F-4897-BA00-4889A320B74B">About Creating STRUCT Objects</a></p>
                     </li>
                     <li>
                        <p><a href="Oracle-object-types.html#GUID-CCEADA36-E70A-42A9-A55C-9D7BD1BBABBF">Binding STRUCT Objects into Statements</a></p>
                     </li>
                     <li>
                        <p><a href="Oracle-object-types.html#GUID-DB4B241E-7C22-4585-A42D-80097D5ADA74">STRUCT Automatic Attribute Buffering</a></p>
                     </li>
                  </ul>
               </div>
               <div class="props_rev_3"><a id="GUID-21636EC9-B321-43A8-AAED-0329A8371D5C" name="GUID-21636EC9-B321-43A8-AAED-0329A8371D5C"></a><h4 id="JJDBC-GUID-21636EC9-B321-43A8-AAED-0329A8371D5C" class="sect4"><span class="enumeration_section">13.2.1 </span>Overview of Using the Struct Class
                  </h4>
                  <div>
                     <p>If you choose not to supply a custom Java class for your SQL-Java mapping for an <a id="d51198e291" class="indexterm-anchor"></a>Oracle object, then Oracle JDBC materializes the object as an object that implements the <code class="codeph">java.sql.Struct</code> interface.
                     </p>
                     <p>You would typically want to use <code class="codeph">STRUCT</code> objects, instead of custom Java objects, in situations where you do not know the actual SQL type. For example, your Java application might be a tool to manipulate arbitrary object data within the database, as opposed to being an end-user application. You can select data from the database into <code class="codeph">STRUCT</code> objects and create <code class="codeph">STRUCT</code> objects for inserting data into the database. <code class="codeph">STRUCT</code> objects completely preserve data, because they maintain the data in SQL format. Using <code class="codeph">STRUCT</code> objects is more efficient and more precise in situations where you do not need the information in an application specific form.
                     </p>
                  </div>
               </div><a id="JJDBC28440"></a><a id="JJDBC28441"></a><a id="JJDBC28442"></a><a id="JJDBC28438"></a><div class="props_rev_3"><a id="GUID-13EB6E85-4356-4653-9822-855691AACC4A" name="GUID-13EB6E85-4356-4653-9822-855691AACC4A"></a><h4 id="JJDBC-GUID-13EB6E85-4356-4653-9822-855691AACC4A" class="sect4"><span class="enumeration_section">13.2.2 </span>Retrieving STRUCT Objects and Attributes
                  </h4>
                  <div>
                     <div class="section">
                        <p>This section discusses how to retrieve and manipulate Oracle objects and their attributes, using either Oracle-specific features or JDBC 2.0 standard features.</p>
                        <div class="infoboxnote" id="GUID-13EB6E85-4356-4653-9822-855691AACC4A__GUID-17EBE907-B787-44CB-B28D-A12B6F008756">
                           <p class="notep1">Note:</p>
                           <p>The JDBC driver seamlessly handles embedded objects, that is, <code class="codeph">STRUCT</code> objects that are attributes of <code class="codeph">STRUCT</code> objects, in the same way that it typically handles objects. When the JDBC driver retrieves an attribute that is an object, it follows the same rules of conversion by using the type map, if it is available, or by using default mapping.
                           </p>
                        </div>
                     </div>
                     <!-- class="section" -->
                     <div class="section">
                        <p class="subhead3" id="GUID-13EB6E85-4356-4653-9822-855691AACC4A__GUID-965D536C-AFEB-45FB-ABBF-FE15907496E3">Retrieving an Oracle Object as a java.sql.Struct Object</p>
                     </div>
                     <!-- class="section" -->
                     <div class="section">
                        <p>Alternatively, in the preceding example, you can use standard JDBC functionality, such as <code class="codeph">getObject</code>, to retrieve an Oracle object from the database as an instance of <code class="codeph">java.sql.Struct</code>. The <code class="codeph">getObject</code> method returns a <code class="codeph">java.lang.Object</code>, so, you must cast the output of the method to <code class="codeph">Struct</code>. For example:
                        </p><pre class="oac_no_warn" dir="ltr">ResultSet rs= stmt.executeQuery("SELECT * FROM struct_table");
java.sql.Struct jdbcStruct = (java.sql.Struct)rs.getObject(1);
</pre></div>
                     <!-- class="section" -->
                     <div class="section">
                        <p class="subhead3" id="GUID-13EB6E85-4356-4653-9822-855691AACC4A__GUID-86188575-F0AA-49E0-96D9-89FE34C79F42">Retrieving Attributes as oracle.sql Types</p>
                     </div>
                     <!-- class="section" -->
                     <div class="section">
                        <p>If you want to retrieve Oracle object attributes from a <code class="codeph">STRUCT</code> or <code class="codeph">Struct</code> instance as <code class="codeph">oracle.sql</code> types, then use the <code class="codeph">getOracleAttributes</code> method of the <code class="codeph">oracle.sql.STRUCT</code> class, as follows:
                        </p><pre class="oac_no_warn" dir="ltr">oracle.sql.Datum[] attrs = oracleSTRUCT.getOracleAttributes();
</pre><p>or:</p><pre class="oac_no_warn" dir="ltr">oracle.sql.Datum[] attrs = ((oracle.sql.STRUCT)jdbcStruct).getOracleAttributes();
</pre></div>
                     <!-- class="section" -->
                     <div class="section">
                        <p class="subhead3" id="GUID-13EB6E85-4356-4653-9822-855691AACC4A__GUID-F986D1A3-26E0-4C7C-9DEC-1D37A1AE7C62">Retrieving Attributes as Standard Java Types</p>
                     </div>
                     <!-- class="section" -->
                     <div class="section">
                        <p>If you want to retrieve Oracle object attributes as standard Java types from a <code class="codeph">STRUCT</code> or <code class="codeph">Struct</code> instance, use the standard <code class="codeph">getAttributes</code> method:
                        </p><pre class="oac_no_warn" dir="ltr">Object[] attrs = jdbcStruct.getAttributes();
</pre><div class="infoboxnote" id="GUID-13EB6E85-4356-4653-9822-855691AACC4A__GUID-66694E99-A661-4419-B99A-CF44489256FA">
                           <p class="notep1">Note:</p>
                           <p>Oracle JDBC drivers cache array and structure descriptors. This provides enormous performance benefits. However, it means that if you change the underlying type definition of a structure type in the database, the cached descriptor for that structure type will become stale and your application will receive a <code class="codeph">SQLException</code> exception.
                           </p>
                        </div>
                     </div>
                     <!-- class="section" -->
                  </div>
               </div><a id="JJDBC28443"></a><div class="props_rev_3"><a id="GUID-00F1EBB3-B60F-4897-BA00-4889A320B74B" name="GUID-00F1EBB3-B60F-4897-BA00-4889A320B74B"></a><h4 id="JJDBC-GUID-00F1EBB3-B60F-4897-BA00-4889A320B74B" class="sect4"><span class="enumeration_section">13.2.3 </span>About Creating STRUCT Objects
                  </h4>
                  <div>
                     <div class="section">
                        <p>For information about creating STRUCT objects, refer to <span class="q">"<a href="Oracle-extensions.html#GUID-DB1F687A-CF1C-4B3F-92C0-126DC782EF53">Package oracle.sql</a>"</span>.
                        </p>
                        <div class="infoboxnote" id="GUID-00F1EBB3-B60F-4897-BA00-4889A320B74B__GUID-4967F80C-4684-405E-8CC9-F463938E45AE">
                           <p class="notep1">Note:</p>
                           <p>If you have already fetched from the database a <code class="codeph">STRUCT</code> of the appropriate SQL object type, then the easiest way to get a <code class="codeph">STRUCT</code> descriptor is to call <code class="codeph">getDescriptor</code> on one of the fetched <code class="codeph">STRUCT</code> objects. Only one <code class="codeph">STRUCT</code> descriptor is needed for any one SQL object type.
                           </p>
                        </div>
                     </div>
                     <!-- class="section" -->
                  </div>
               </div><a id="JJDBC28447"></a><div class="props_rev_3"><a id="GUID-CCEADA36-E70A-42A9-A55C-9D7BD1BBABBF" name="GUID-CCEADA36-E70A-42A9-A55C-9D7BD1BBABBF"></a><h4 id="JJDBC-GUID-CCEADA36-E70A-42A9-A55C-9D7BD1BBABBF" class="sect4"><span class="enumeration_section">13.2.4 </span>Binding STRUCT Objects into Statements
                  </h4>
                  <div>
                     <div class="section">
                        <p>To bind an <code class="codeph">oracle.sql.STRUCT</code> object to a prepared statement or callable statement, you can either use the standard <a id="d51198e512" class="indexterm-anchor"></a><code class="codeph">setObject</code> method (specifying the type code), or cast the statement object to an Oracle statement type and use the Oracle extension <code class="codeph">setOracleObject</code> method. For example:
                        </p><pre class="oac_no_warn" dir="ltr">PreparedStatement ps= conn.prepareStatement("<span class="italic">text_of_prepared_statement</span>");
Struct mySTRUCT = conn.createStruct (...);
ps.setObject(1, mySTRUCT, Types.STRUCT);
</pre><p>or:</p><pre class="oac_no_warn" dir="ltr">PreparedStatement ps= conn.prepareStatement("<span class="italic">text_of_prepared_statement</span>");
Struct mySTRUCT = conn.createStruct (...);
((OraclePreparedStatement)ps).setOracleObject(1, mySTRUCT);</pre></div>
                     <!-- class="section" -->
                  </div>
               </div><a id="JJDBC28448"></a><div class="props_rev_3"><a id="GUID-DB4B241E-7C22-4585-A42D-80097D5ADA74" name="GUID-DB4B241E-7C22-4585-A42D-80097D5ADA74"></a><h4 id="JJDBC-GUID-DB4B241E-7C22-4585-A42D-80097D5ADA74" class="sect4"><span class="enumeration_section">13.2.5 </span>STRUCT Automatic Attribute Buffering
                  </h4>
                  <div>
                     <p>Oracle JDBC driver furnishes public methods to enable and disable buffering of <code class="codeph">STRUCT</code> attributes.
                     </p>
                     <div class="infoboxnote" id="GUID-DB4B241E-7C22-4585-A42D-80097D5ADA74__GUID-37E8CBAC-3A75-4F1D-9E94-EB78E733BBC2">
                        <p class="notep1">Note:</p>
                        <p>Starting from Oracle Database 12<span class="italic">c </span>Release 1 (12.1), the <code class="codeph">oracle.sql.STRUCT</code> class is deprecated and replaced with the <code class="codeph">oracle.jdbc.OracleStruct</code> interface, which is a part of the <code class="codeph">oracle.jdbc</code> package. Oracle strongly recommends you to use the methods available in the <code class="codeph">java.sql</code> package, where possible, for standard compatibility and methods available in the <code class="codeph">oracle.jdbc</code> package for Oracle specific extensions. Refer to MoS Note 1364193.1 for more information about the <code class="codeph">oracle.jdbc.OracleStruct</code> interface.
                        </p>
                     </div>
                     <p>The following methods are included with the <code class="codeph">oracle.sql.STRUCT</code> class:
                     </p>
                     <ul style="list-style-type: disc;">
                        <li>
                           <p><code class="codeph">public void setAutoBuffering(boolean enable)</code></p>
                        </li>
                        <li>
                           <p><code class="codeph">public boolean getAutoBuffering()</code></p>
                        </li>
                     </ul>
                     <p>The <code class="codeph">setAutoBuffering(boolean)</code> method enables or disables auto-buffering. The <code class="codeph">getAutoBuffering</code> method returns the current auto-buffering mode. By default, auto-buffering is disabled.
                     </p>
                     <p>It is advisable to enable auto-buffering in a JDBC application when the <code class="codeph">STRUCT</code> attributes are accessed more than once by the <code class="codeph">getAttributes</code> and <code class="codeph">getArray</code> methods, presuming the <code class="codeph">ARRAY</code> data is able to fit into the Java Virtual Machine (JVM) memory without overflow.
                     </p>
                     <div class="infoboxnote" id="GUID-DB4B241E-7C22-4585-A42D-80097D5ADA74__GUID-73296BC2-A877-4697-9CCB-6B499027AE8F">
                        <p class="notep1">Note:</p>
                        <p>Buffering the converted attributes may cause the JDBC application to consume a significant amount of memory.</p>
                     </div>
                     <p>When you enable auto-buffering, the <code class="codeph">oracle.sql.STRUCT</code> object keeps a local copy of all the converted attributes. This data is retained so that subsequent access of this information does not require going through the data format conversion process.
                     </p>
                  </div>
                  <div>
                     <div class="relinfo">
                        <p><strong>Related Topics</strong></p>
                        <ul>
                           <li><a href="Oracle-collections.html#GUID-33CC8F2C-4E73-412B-990E-D4293173E199">ARRAY Automatic Element Buffering</a></li>
                        </ul>
                     </div>
                  </div>
                  
               </div>
            </div><a id="JJDBC28449"></a><div class="props_rev_3"><a id="GUID-0128E185-086F-41CD-BECC-63A42EBB142C" name="GUID-0128E185-086F-41CD-BECC-63A42EBB142C"></a><h3 id="JJDBC-GUID-0128E185-086F-41CD-BECC-63A42EBB142C" class="sect3"><span class="enumeration_section">13.3 </span>About Creating and Using Custom Object Classes for Oracle Objects
               </h3>
               <div>
                  <p>This section covers the following topics:</p>
                  <ul style="list-style-type: disc;">
                     <li>
                        <p><a href="Oracle-object-types.html#GUID-CB167A20-2A94-4066-80CC-E5577698394E">Overview of Creating and Using Custom Object Classes</a></p>
                     </li>
                     <li>
                        <p><a href="Oracle-object-types.html#GUID-47ED704C-6F0C-485F-B6F0-56C65BC17CA3">Relative Advantages of OracleData versus SQLData</a></p>
                     </li>
                     <li>
                        <p><a href="Oracle-object-types.html#GUID-87716972-5BD5-4116-B706-DC8C13663342">About Type Maps for SQLData Implementations</a></p>
                     </li>
                     <li>
                        <p><a href="Oracle-object-types.html#GUID-6C176486-2299-408A-86D7-29033E593210">About Creating Type Map and Defining Mappings for a SQLData Implementation</a></p>
                     </li>
                     <li>
                        <p><a href="Oracle-object-types.html#GUID-6D44496F-0CAA-4034-AF55-00B39DE4C6E3">About Reading and Writing Data with a SQLData Implementation</a></p>
                     </li>
                     <li>
                        <p><a href="Oracle-object-types.html#GUID-EEF1A8CA-354D-430B-9153-171849DE2525">About the OracleData Interface</a></p>
                     </li>
                     <li>
                        <p><a href="Oracle-object-types.html#GUID-7E84EDB6-A403-475D-875B-CAA151436AF7">About Reading and Writing Data with an OracleData Implementation</a></p>
                     </li>
                     <li>
                        <p><a href="Oracle-object-types.html#GUID-1CC46DF9-95F1-4892-8C25-9B3BBD36CFFF">Additional Uses of OracleData</a></p>
                     </li>
                  </ul>
               </div>
               <div class="props_rev_3"><a id="GUID-CB167A20-2A94-4066-80CC-E5577698394E" name="GUID-CB167A20-2A94-4066-80CC-E5577698394E"></a><h4 id="JJDBC-GUID-CB167A20-2A94-4066-80CC-E5577698394E" class="sect4"><span class="enumeration_section">13.3.1 </span>Overview of Creating and Using Custom Object Classes
                  </h4>
                  <div>
                     <p>If you want to create <a id="d51198e727" class="indexterm-anchor"></a>custom object classes for your <a id="d51198e732" class="indexterm-anchor"></a>Oracle objects, then you must define entries in the <a id="d51198e737" class="indexterm-anchor"></a>type map that specify the custom object classes that the drivers instantiate for the corresponding Oracle objects.
                     </p>
                     <p>You must also provide a way to create and populate instances of the custom object class from the Oracle object and its attribute data. The driver must be able to read from a custom object class and write to it. In addition, the custom object class can provide <code class="codeph">get</code><span class="italic"><code class="codeph">XXX</code></span> and <code class="codeph">set</code><span class="italic"><code class="codeph">XXX</code></span> methods corresponding to the attributes of the Oracle object, although this is not necessary. To create and populate the custom classes and provide these read/write capabilities, you can choose between the following interfaces:
                     </p>
                     <ul style="list-style-type: disc;">
                        <li>
                           <p>The JDBC standard <code class="codeph">SQLData</code> interface
                           </p>
                        </li>
                        <li>
                           <p>The <code class="codeph">OracleData</code> and <code class="codeph">OracleDataFactory</code> interfaces provided by Oracle
                           </p>
                        </li>
                     </ul>
                     <p>The custom object class you create must implement one of these interfaces. The <code class="codeph">OracleData</code> interface can also be used to implement the custom reference class corresponding to the custom object class. However, if you are using the <code class="codeph">SQLData</code> interface, then you can use only weak reference types in Java, such as <code class="codeph">java.sql.Ref</code> or <code class="codeph">oracle.sql.REF</code>. The <code class="codeph">SQLData</code> interface is for mapping SQL objects only.
                     </p>
                     <p>As an example, assume you have an Oracle object type, <code class="codeph">EMPLOYEE</code>, in the database that consists of two attributes: <code class="codeph">Name</code>, which is of the <code class="codeph">CHAR</code> type and <code class="codeph">EmpNum</code>, which is of the <code class="codeph">NUMBER</code> type. You use the type map to specify that the <code class="codeph">EMPLOYEE</code> object should map to a custom object class that you call <code class="codeph">JEmployee</code>. You can implement either the <code class="codeph">SQLData</code> or <code class="codeph">OracleData</code> interface in the <code class="codeph">JEmployee</code> class.
                     </p>
                  </div>
                  <div>
                     <div class="relinfo">
                        <p><strong>Related Topics</strong></p>
                        <ul>
                           <li><a href="Oracle-object-types.html#GUID-E47B8141-3C4C-44D5-BB5C-2F8E16DF5140">Object-Type Inheritance</a></li>
                        </ul>
                     </div>
                  </div>
                  
               </div><a id="JJDBC28451"></a><a id="JJDBC28452"></a><a id="JJDBC28450"></a><div class="props_rev_3"><a id="GUID-47ED704C-6F0C-485F-B6F0-56C65BC17CA3" name="GUID-47ED704C-6F0C-485F-B6F0-56C65BC17CA3"></a><h4 id="JJDBC-GUID-47ED704C-6F0C-485F-B6F0-56C65BC17CA3" class="sect4"><span class="enumeration_section">13.3.2 </span>Relative Advantages of OracleData versus SQLData
                  </h4>
                  <div>
                     <div class="section">
                        <p>In deciding which of the two interface implementations to use, you need to consider the advantages of <code class="codeph">OracleData</code> and <code class="codeph">SQLData</code>.
                        </p>
                        <p>The <code class="codeph">SQLData</code> interface is for mapping SQL objects only. The <code class="codeph">OracleData</code> interface is more flexible, enabling you to map SQL objects as well as any other SQL type for which you want to customize processing. You can create an <code class="codeph">OracleData</code> implementation from any data type found in Oracle Database. This could be useful, for example, for serializing <code class="codeph">RAW</code> data in Java.
                        </p>
                     </div>
                     <!-- class="section" -->
                     <div class="section">
                        <p class="subhead3" id="GUID-47ED704C-6F0C-485F-B6F0-56C65BC17CA3__GUID-EEB125BD-14AC-4D41-B839-8F08EAAA21C8">Advantages of the  OracleData Interface</p>
                     </div>
                     <!-- class="section" -->
                     <div class="section">
                        <p>The advantages of the <code class="codeph">OracleData</code> interface are:
                        </p>
                        <ul style="list-style-type: disc;">
                           <li>
                              <p>It does not require an entry in the type map for the Oracle object.</p>
                           </li>
                           <li>
                              <p>It has awareness of Oracle extensions.</p>
                           </li>
                           <li>
                              <p>You can construct an <code class="codeph">OracleData</code> from an <code class="codeph">oracle.sql.STRUCT</code>. This is more efficient because it avoids unnecessary conversions to native Java types.
                              </p>
                           </li>
                           <li>
                              <p>You can obtain the corresponding JDBC object from <code class="codeph">OracleData</code>, using the <code class="codeph">toJDBCObject</code> method.
                              </p>
                           </li>
                        </ul>
                     </div>
                     <!-- class="section" -->
                     <div class="section">
                        <p class="subhead3" id="GUID-47ED704C-6F0C-485F-B6F0-56C65BC17CA3__GUID-0F39D4D3-FD8B-4496-8E33-8427DC9B44F1">Advantages of SQLData</p>
                     </div>
                     <!-- class="section" -->
                     <div class="section">
                        <p><code class="codeph">SQLData</code> is a JDBC standard that makes your code portable.
                        </p>
                     </div>
                     <!-- class="section" -->
                  </div>
               </div><a id="JJDBC28453"></a><div class="props_rev_3"><a id="GUID-87716972-5BD5-4116-B706-DC8C13663342" name="GUID-87716972-5BD5-4116-B706-DC8C13663342"></a><h4 id="JJDBC-GUID-87716972-5BD5-4116-B706-DC8C13663342" class="sect4"><span class="enumeration_section">13.3.3 </span>About Type Maps for SQLData Implementations
                  </h4>
                  <div>
                     <div class="section">
                        <p>If you use the <code class="codeph">SQLData</code> interface in a custom object class, then you must create type map entries that specify the custom object class to use in mapping the Oracle object type to Java. You can either use the default type map of the connection object or a type map that you specify when you retrieve the data from the result set. The <code class="codeph">getObject</code> method of the <code class="codeph">ResultSet</code> interface has a signature that lets you specify a type map. You can use either of the following:
                        </p><pre class="oac_no_warn" dir="ltr">rs.getObject(int columnIndex);

rs.getObject(int columnIndex, Map map);
</pre><p>When using a SQLData implementation, if you do not include a type map entry, then the object maps to the <code class="codeph">oracle.jdbc.OracleStruct</code> interface by default. <code class="codeph">OracleData</code> implementations, by contrast, have their own mapping functionality so that a type map entry is not required. When using an <code class="codeph">OracleData</code> implementation, use the Oracle <code class="codeph">getObject(int columnindex, OracleDataFactory factory)</code>method.
                        </p>
                        <p>The type map relates a Java class to the SQL type name of an Oracle object. This one-to-one mapping is stored in a hash table as a keyword-value pair. When you read data from an Oracle object, the JDBC driver considers the type map to determine which Java class to use to materialize the data from the Oracle object type. When you write data to an Oracle object, the JDBC driver gets the SQL type name from the Java class by calling the <code class="codeph">getSQLTypeName</code> method of the <code class="codeph">SQLData</code> interface. The actual conversion between SQL and Java is performed by the driver.
                        </p>
                        <p>The attributes of the Java class that corresponds to an Oracle object can use either Java native types or Oracle native types to store attributes. </p>
                     </div>
                     <!-- class="section" -->
                  </div>
                  <div>
                     <div class="relinfo">
                        <p><strong>Related Topics</strong></p>
                        <ul>
                           <li><a href="Oracle-object-types.html#GUID-0128E185-086F-41CD-BECC-63A42EBB142C">About Creating and Using Custom Object Classes for Oracle Objects</a></li>
                        </ul>
                     </div>
                  </div>
                  
               </div><a id="JJDBC28454"></a><div class="props_rev_3"><a id="GUID-6C176486-2299-408A-86D7-29033E593210" name="GUID-6C176486-2299-408A-86D7-29033E593210"></a><h4 id="JJDBC-GUID-6C176486-2299-408A-86D7-29033E593210" class="sect4"><span class="enumeration_section">13.3.4 </span>About Creating Type Map and Defining Mappings for a SQLData Implementation
                  </h4>
                  <div>
                     <p>This section covers the following topics:</p>
                     <ul style="list-style-type: disc;">
                        <li>
                           <p><a href="Oracle-object-types.html#GUID-1F446706-91EA-4D67-9581-A0357DCCCFEC">Overview of Creating a Type Map and Defining Mappings</a></p>
                        </li>
                        <li>
                           <p><a href="Oracle-object-types.html#GUID-BEC26079-81FA-4B26-B34D-40CA4EBD200C">Adding Entries to an Existing Type Map</a></p>
                        </li>
                        <li>
                           <p><a href="Oracle-object-types.html#GUID-23CF44E8-F757-4F03-9719-16309C9F95BA">Creating a New Type Map</a></p>
                        </li>
                        <li>
                           <p><a href="Oracle-object-types.html#GUID-BE6AD090-BB22-404F-8003-37D7187764C0">About Materializing Object Types not Specified in the Type Map</a></p>
                        </li>
                     </ul>
                  </div>
                  <div class="props_rev_3"><a id="GUID-1F446706-91EA-4D67-9581-A0357DCCCFEC" name="GUID-1F446706-91EA-4D67-9581-A0357DCCCFEC"></a><h5 id="JJDBC-GUID-1F446706-91EA-4D67-9581-A0357DCCCFEC" class="sect5"><span class="enumeration_section">13.3.4.1 </span>Overview of Creating a Type Map and Defining Mappings
                     </h5>
                     <div>
                        <p>When using a <code class="codeph">SQLData</code> implementation, the JDBC applications programmer is responsible for providing a type map, which must be an instance of a class that implements the standard <code class="codeph">java.util.Map</code> interface.
                        </p>
                        <p>You have the option of creating your own class to accomplish this, but the standard <code class="codeph">java.util.Hashtable</code> class meets the requirement.
                        </p>
                        <p><code class="codeph">Hashtable</code> and other classes used for type maps implement a <code class="codeph">put</code> method that takes keyword-value pairs as input, where each key is a fully qualified SQL type name and the corresponding value is an instance of a specified Java class.
                        </p>
                        <p>A type map is associated with a connection instance. The standard <code class="codeph">java.sql.Connection</code> interface and the Oracle-specific <code class="codeph">oracle.jdbc.OracleConnection</code> interface include a <code class="codeph">getTypeMap</code> method. Both return a <code class="codeph">Map</code> object.
                        </p>
                     </div>
                  </div><a id="JJDBC28455"></a><div class="props_rev_3"><a id="GUID-BEC26079-81FA-4B26-B34D-40CA4EBD200C" name="GUID-BEC26079-81FA-4B26-B34D-40CA4EBD200C"></a><h5 id="JJDBC-GUID-BEC26079-81FA-4B26-B34D-40CA4EBD200C" class="sect5"><span class="enumeration_section">13.3.4.2 </span>Adding Entries to an Existing Type Map
                     </h5>
                     <div>
                        <div class="section">
                           <p>When a connection instance is first established, the default type map is empty. You must populate it.</p>
                           <p>Perform the following <a id="d51198e1125" class="indexterm-anchor"></a>general steps to add entries to an existing type map:
                           </p>
                        </div>
                        <!-- class="section" -->
                        <ol>
                           <li class="stepexpand"><span>Use the <code class="codeph">getTypeMap</code> method of your <code class="codeph">OracleConnection</code> object to return the type map object of the connection. The <code class="codeph">getTypeMap</code> method returns a <code class="codeph">java.util.Map</code> object. For example, presuming an <code class="codeph">OracleConnection</code> instance <code class="codeph">oraconn</code>:</span><div><pre class="oac_no_warn" dir="ltr">java.util.Map myMap = oraconn.getTypeMap();
</pre><div class="infoboxnote" id="GUID-BEC26079-81FA-4B26-B34D-40CA4EBD200C__GUID-1DAA090E-3F81-40DC-B8BD-81E9CC7D32FD">
                                    <p class="notep1">Note:</p>
                                    <p>If the type map in the <code class="codeph">OracleConnection</code> instance has not been initialized, then the first call to <code class="codeph">getTypeMap</code> returns an empty map.
                                    </p>
                                 </div>
                              </div>
                           </li>
                           <li class="stepexpand"><span>Use the <code class="codeph">put</code> method of the type map to add map entries. The <code class="codeph">put</code> method takes two arguments: a SQL type name string and an instance of a specified Java class that you want to map to.</span><div><pre class="oac_no_warn" dir="ltr">myMap.put(<span class="italic">sqlTypeName</span>, <span class="italic">classObject</span>);
</pre><p>The <span class="italic"><code class="codeph">sqlTypeName</code></span> is a string that represents the fully qualified name of the SQL type in the database. The <span class="italic"><code class="codeph">classObject</code></span> is the Java class object to which you want to map the SQL type. Get the class object with the <code class="codeph">Class.forName</code> method, as follows:
                                 </p><pre class="oac_no_warn" dir="ltr">myMap.put(<span class="italic">sqlTypeName</span>, Class.forName(<span class="italic">className</span>));
</pre><p>For example, if you have a <code class="codeph">PERSON</code> SQL data type defined in the <code class="codeph">CORPORATE</code> database schema, then map it to a <code class="codeph">Person</code> Java class defined as <code class="codeph">Person</code> with this statement:
                                 </p><pre class="oac_no_warn" dir="ltr">myMap.put("CORPORATE.PERSON", Class.forName("Person"));
oraconn.setTypeMap(newMap);
 </pre><p>The map has an entry that maps the <code class="codeph">PERSON</code> SQL data type in the <code class="codeph">CORPORATE</code> database to the <code class="codeph">Person</code> Java class.
                                 </p>
                                 <div class="infoboxnote" id="GUID-BEC26079-81FA-4B26-B34D-40CA4EBD200C__GUID-2228FA7B-0430-4F75-A8E7-67D4487ED960">
                                    <p class="notep1">Note:</p>
                                    <p>SQL type names in the type map must be all uppercase, because that is how Oracle Database stores SQL names.</p>
                                 </div>
                              </div>
                           </li>
                        </ol>
                     </div>
                  </div><a id="JJDBC28456"></a><div class="props_rev_3"><a id="GUID-23CF44E8-F757-4F03-9719-16309C9F95BA" name="GUID-23CF44E8-F757-4F03-9719-16309C9F95BA"></a><h5 id="JJDBC-GUID-23CF44E8-F757-4F03-9719-16309C9F95BA" class="sect5"><span class="enumeration_section">13.3.4.3 </span>Creating a New Type Map
                     </h5>
                     <div>
                        <div class="section">
                           <p>Perform <a id="d51198e1260" class="indexterm-anchor"></a>the following general steps to create a new type map. This example uses an instance of <code class="codeph">java.util.Hashtable</code>, which extends <code class="codeph">java.util.Dictionary</code> and implements <code class="codeph">java.util.Map</code>.
                           </p>
                        </div>
                        <!-- class="section" -->
                        <ol>
                           <li class="stepexpand"><span>Create a new type map object.</span><div><pre class="oac_no_warn" dir="ltr">Hashtable newMap = new Hashtable();
</pre></div>
                           </li>
                           <li class="stepexpand"><span>Use the <code class="codeph">put</code> method of the type map object to add entries to the map. For example, if you have an <code class="codeph">EMPLOYEE</code> SQL type defined in the <code class="codeph">CORPORATE</code> database, then you can map it to an <code class="codeph">Employee</code> class object defined by <code class="codeph">Employee.java</code>, as follows:</span><div><pre class="oac_no_warn" dir="ltr">newMap.put("CORPORATE.EMPLOYEE", class.forName("Employee"));
</pre></div>
                           </li>
                           <li class="stepexpand"><span>When you finish adding entries to the map, you must use the <code class="codeph">setTypeMap</code> method of the <code class="codeph">OracleConnection</code> object to overwrite the existing type map of the connection. For example:</span><div><pre class="oac_no_warn" dir="ltr">oraconn.setTypeMap(newMap);
</pre><p>In this example, the <code class="codeph">setTypeMap</code> method overwrites the original map of the <code class="codeph">oraconn</code> connection object with <code class="codeph">newMap</code>.
                                 </p>
                                 <div class="infoboxnote" id="GUID-23CF44E8-F757-4F03-9719-16309C9F95BA__GUID-6305D41E-7731-4A61-B3D5-C42DD64AC250">
                                    <p class="notep1">Note:</p>
                                    <p>The default type map of a connection instance is used when mapping is required but no map name is specified, such as for a result set <code class="codeph">getObject</code> call that does not specify the map as input.
                                    </p>
                                 </div>
                              </div>
                           </li>
                        </ol>
                     </div>
                  </div><a id="JJDBC28457"></a><div class="props_rev_3"><a id="GUID-BE6AD090-BB22-404F-8003-37D7187764C0" name="GUID-BE6AD090-BB22-404F-8003-37D7187764C0"></a><h5 id="JJDBC-GUID-BE6AD090-BB22-404F-8003-37D7187764C0" class="sect5"><span class="enumeration_section">13.3.4.4 </span>About Materializing Object Types not Specified in the Type Map
                     </h5>
                     <div>
                        <div class="section">
                           <p>If you do not provide a <a id="d51198e1356" class="indexterm-anchor"></a>type map with an appropriate entry when using a <code class="codeph">getObject</code> call, then the JDBC driver will materialize an Oracle object as an instance of the <code class="codeph">oracle.jdbc.OracleStruct</code> interface. If the Oracle object type contains embedded objects and they are not present in the type map, then the driver will materialize the embedded objects as instances of <code class="codeph">oracle.jdbc.OracleStruct</code> as well. If the embedded objects are present in the type map, then a call to the <code class="codeph">getAttributes</code> method will return embedded objects as instances of the specified Java classes from the type map.
                           </p>
                        </div>
                        <!-- class="section" -->
                     </div>
                  </div>
               </div><a id="JJDBC28462"></a><a id="JJDBC28463"></a><a id="JJDBC28464"></a><a id="JJDBC28465"></a><a id="JJDBC28461"></a><div class="props_rev_3"><a id="GUID-6D44496F-0CAA-4034-AF55-00B39DE4C6E3" name="GUID-6D44496F-0CAA-4034-AF55-00B39DE4C6E3"></a><h4 id="JJDBC-GUID-6D44496F-0CAA-4034-AF55-00B39DE4C6E3" class="sect4"><span class="enumeration_section">13.3.5 </span>About Reading and Writing Data with a SQLData Implementation
                  </h4>
                  <div>
                     <p>This section describes how to read data from an Oracle object or write data to an Oracle object if your corresponding Java class implements <code class="codeph">SQLData</code>.
                     </p>
                     <div class="section">
                        <p class="subhead3" id="GUID-6D44496F-0CAA-4034-AF55-00B39DE4C6E3__GUID-476CA319-2D38-4476-A1BF-F3AD10F02AF9">Reading SQLData Objects from a Result Set</p>
                     </div>
                     <!-- class="section" -->
                     <div class="section">
                        <p>The following text <a id="d51198e1410" class="indexterm-anchor"></a><a id="d51198e1414" class="indexterm-anchor"></a>summarizes the steps to read data from an Oracle object into your Java application when you choose the <code class="codeph">SQLData</code> implementation for your custom object class.
                        </p>
                        <p>These steps assume you have already defined the Oracle object type, created the corresponding custom object class, updated the type map to define the mapping between the Oracle object and the Java class, and defined a statement object <code class="codeph">stmt</code>.
                        </p>
                        <ol>
                           <li>
                              <p>Query the database to read the Oracle object into a JDBC result set.</p><pre class="oac_no_warn" dir="ltr">ResultSet rs = stmt.executeQuery("SELECT emp_col FROM personnel");
</pre><p>The <code class="codeph">PERSONNEL</code> table contains one column, <code class="codeph">EMP_COL</code>, of SQL type <code class="codeph">EMP_OBJECT</code>. This SQL type is defined in the type map to map to the Java class <code class="codeph">Employee</code>.
                              </p>
                           </li>
                           <li>
                              <p>Use the <code class="codeph">getObject</code> method of Oracle result set to populate an instance of your custom object class with data from one row of the result set. The <code class="codeph">getObject</code> method returns the user-defined <code class="codeph">SQLData</code> object because the type map contains an entry for <code class="codeph">Employee</code>. 
                              </p><pre class="oac_no_warn" dir="ltr">if (rs.next())
   Employee emp = (Employee)rs.getObject(1);
</pre><p>Note that if the type map did not have an entry for the object, then the <code class="codeph">getObject</code> method will return an <code class="codeph">oracle.jdbc.OracleStruct</code> object. Cast the output to type <code class="codeph">OracleStruct</code> because the <code class="codeph">getObject</code> method signature returns the generic <code class="codeph">java.lang.Object</code> type.
                              </p><pre class="oac_no_warn" dir="ltr">if (rs.next())
   OracleStruct empstruct = (OracleStruct)rs.getObject(1);
</pre><p>The <code class="codeph">getObject</code> method calls <code class="codeph">readSQL</code>, which, in turn, calls <code class="codeph">read</code><span class="italic"><code class="codeph">XXX</code></span> from the <code class="codeph">SQLData</code> interface.
                              </p>
                              <div class="infoboxnote" id="GUID-6D44496F-0CAA-4034-AF55-00B39DE4C6E3__GUID-30A3BF58-2340-431B-AEFC-75010D0648DF">
                                 <p class="notep1">Note:</p>
                                 <p>If you want to avoid using the defined type map, then use the <code class="codeph">getSTRUCT</code> method. This method always returns a <code class="codeph">STRUCT</code> object, even if there is a mapping entry in the type map.
                                 </p>
                              </div>
                           </li>
                           <li>
                              <p>If you have <code class="codeph">get</code> methods in your custom object class, then use them to read data from your object attributes. For example, if <code class="codeph">EMPLOYEE</code> has the attributes <code class="codeph">EmpName</code> of type <code class="codeph">CHAR</code> and <code class="codeph">EmpNum</code> of type <code class="codeph">NUMBER</code>, then provide a <code class="codeph">getEmpName</code> method that returns a Java <code class="codeph">String</code> and a <code class="codeph">getEmpNum</code> method that returns an <code class="codeph">int</code> value. Then call them in your Java application, as follows:
                              </p><pre class="oac_no_warn" dir="ltr">String empname = emp.getEmpName();
int empnumber = emp.getEmpNum();
 </pre></li>
                        </ol>
                     </div>
                     <!-- class="section" -->
                     <div class="section">
                        <p class="subhead3" id="GUID-6D44496F-0CAA-4034-AF55-00B39DE4C6E3__GUID-1E26A487-4615-4918-BD0E-15ABA53237A2">Retrieving SQLData Objects from a Callable Statement OUT Parameter</p>
                     </div>
                     <!-- class="section" -->
                     <div class="section">
                        <p>Consider you have a <code class="codeph">CallableStatement</code> instance, <code class="codeph">cs</code>, that calls a PL/SQL function <code class="codeph">GETEMPLOYEE</code>. The program passes an employee number to the function. The function returns the corresponding <code class="codeph">Employee</code> object. To retrieve this object you do the following:
                        </p>
                        <ol>
                           <li>
                              <p>Prepare a <code class="codeph">CallableStatement</code> to call the <code class="codeph">GETEMPLOYEE</code> function, as follows:
                              </p><pre class="oac_no_warn" dir="ltr">CallableStatement ocs = conn.prepareCall("{ ? = call GETEMPLOYEE(?) }");
</pre></li>
                           <li>
                              <p>Declare the <code class="codeph">empnumber</code> as the input parameter to <code class="codeph">GETEMPLOYEE</code>. Register the <code class="codeph">SQLData</code> object as the <code class="codeph">OUT</code> parameter, with the type code <code class="codeph">OracleTypes.STRUCT</code>. Then, run the statement. This can be done as follows:
                              </p><pre class="oac_no_warn" dir="ltr">cs.setInt(2, empnumber); 
cs.registerOutParameter(1, OracleTypes.STRUCT, "EMP_OBJECT"); 
cs.execute(); 
</pre></li>
                           <li>
                              <p>Use the <code class="codeph">getObject</code> method to retrieve the employee object. 
                              </p><pre class="oac_no_warn" dir="ltr">Employee emp = (Employee)cs.getObject(1);
</pre><p>If there is no type map entry, then the <code class="codeph">getObject</code> method will return a <code class="codeph">java.sql.Struct</code> object.
                              </p><pre class="oac_no_warn" dir="ltr">Struct emp = cs.getObject(1);
</pre></li>
                        </ol>
                     </div>
                     <!-- class="section" -->
                     <div class="section">
                        <p class="subhead3" id="GUID-6D44496F-0CAA-4034-AF55-00B39DE4C6E3__GUID-9A998336-12A2-41F7-BFFD-5556D6626CF0">Passing SQLData Objects to a Callable Statement as an IN Parameter</p>
                     </div>
                     <!-- class="section" -->
                     <div class="section">
                        <p>Suppose you have a PL/SQL function <code class="codeph">addEmployee(?)</code> that takes an <code class="codeph">Employee</code> object as an <code class="codeph">IN</code> parameter and adds it to the <code class="codeph">PERSONNEL</code> table. In this example, <code class="codeph">emp</code> is a valid <code class="codeph">Employee</code> object. 
                        </p>
                        <ol>
                           <li>
                              <p>Prepare an <code class="codeph">CallableStatement</code> to call the <code class="codeph">addEmployee(?)</code> function.
                              </p><pre class="oac_no_warn" dir="ltr">CallableStatement cs = 
  conn.prepareCall("{ call addEmployee(?) }");
</pre></li>
                           <li>
                              <p>Use <code class="codeph">setObject</code> to pass the <code class="codeph">emp</code> object as an <code class="codeph">IN</code> parameter to the callable statement. Then, call the statement.
                              </p><pre class="oac_no_warn" dir="ltr">cs.setObject(1, emp); 
cs.execute();
</pre></li>
                        </ol>
                     </div>
                     <!-- class="section" -->
                     <div class="section">
                        <p class="subhead3" id="GUID-6D44496F-0CAA-4034-AF55-00B39DE4C6E3__GUID-5C497F9F-D471-4D32-B0B3-F5688A8A2756">Writing Data to an Oracle Object Using a SQLData Implementation</p>
                     </div>
                     <!-- class="section" -->
                     <div class="section">
                        <p>The <a id="d51198e1670" class="indexterm-anchor"></a><a id="d51198e1674" class="indexterm-anchor"></a>following text describes the steps in writing data to an Oracle object from your Java application when you choose the <code class="codeph">SQLData</code> implementation for your custom object class.
                        </p>
                        <p>This description assumes you have already defined the Oracle object type, created the corresponding Java class, and updated the type map to define the mapping between the Oracle object and the Java class.</p>
                        <ol>
                           <li>
                              <p>If you have <code class="codeph">set</code> methods in your custom object class, then use them to write data from Java variables in your application to attributes of your Java data type object. 
                              </p><pre class="oac_no_warn" dir="ltr">emp.setEmpName(empname);
emp.setEmpNum(empnumber);
</pre></li>
                           <li>
                              <p>Prepare a statement that updates an Oracle object in a row of a database table, as appropriate, using the data provided in your Java data type object.</p><pre class="oac_no_warn" dir="ltr">PreparedStatement pstmt = conn.prepareStatement
                          ("INSERT INTO PERSONNEL VALUES (?)");
</pre></li>
                           <li>
                              <p>Use the <code class="codeph">setObject</code> method of the prepared statement to bind your Java data type object to the prepared statement.
                              </p><pre class="oac_no_warn" dir="ltr">pstmt.setObject(1, emp);
</pre></li>
                           <li>
                              <p>Run the statement, which updates the database.</p><pre class="oac_no_warn" dir="ltr">pstmt.executeUpdate();
</pre></li>
                        </ol>
                     </div>
                     <!-- class="section" -->
                  </div>
               </div><a id="JJDBC28467"></a><a id="JJDBC28468"></a><a id="JJDBC28466"></a><div class="props_rev_3"><a id="GUID-EEF1A8CA-354D-430B-9153-171849DE2525" name="GUID-EEF1A8CA-354D-430B-9153-171849DE2525"></a><h4 id="JJDBC-GUID-EEF1A8CA-354D-430B-9153-171849DE2525" class="sect4"><span class="enumeration_section">13.3.6 </span>About the OracleData Interface
                  </h4>
                  <div>
                     <p>You can create a custom object class that implements the <code class="codeph">oracle.jdbc.OracleData</code> and the <code class="codeph">oracle.jdbc.OracleDataFactory</code> interfaces to make an Oracle object and its attribute data available to Java applications. The <code class="codeph">OracleData</code> and <code class="codeph">OracleDataFactory</code> interfaces are Oracle-specific and are not a part of the JDBC standard.
                     </p>
                     <div class="infoboxnote" id="GUID-EEF1A8CA-354D-430B-9153-171849DE2525__GUID-3C9EAAEC-E81B-4A09-A970-B2894875ED1D">
                        <p class="notep1">Note:</p>
                        <p>Starting from Oracle Database 12<span class="italic">c </span>Release 1 (12.1), the <code class="codeph">OracleData</code> and the <code class="codeph">OracleDataFactory</code> interfaces replace the <code class="codeph">ORAData</code> and the <code class="codeph">ORADataFactory</code> interfaces.
                        </p>
                     </div>
                     <div class="section">
                        <p class="subhead3" id="GUID-EEF1A8CA-354D-430B-9153-171849DE2525__GUID-21969CFF-8F45-4625-87B6-57E4CB97DFCC">Understanding the OracleData Interface Features</p>
                     </div>
                     <!-- class="section" -->
                     <div class="section">
                        <p>The <code class="codeph">OracleData</code> interface has the following advantages:
                        </p>
                        <ul style="list-style-type: disc;">
                           <li>
                              <p>It supports Oracle extensions to the standard JDBC types.</p>
                           </li>
                           <li>
                              <p>It does not require a type map to specify the names of the Java custom classes you want to create.</p>
                           </li>
                           <li>
                              <p>It provides better performance. <code class="codeph">OracleData</code> works directly with <code class="codeph">Datum</code> types, the internal format the driver uses to hold Oracle objects.
                              </p>
                           </li>
                        </ul>
                        <p>The <code class="codeph">OracleData</code> and the <code class="codeph">OracleDataFactory</code> interfaces perform the following:
                        </p>
                        <ul style="list-style-type: disc;">
                           <li>
                              <p>The <code class="codeph">toJDBCObject</code> method of the <code class="codeph">OracleData</code> class transforms the data into an <code class="codeph">oracle.jdbc.*</code> representation.
                              </p>
                           </li>
                           <li>
                              <p><code class="codeph">OracleDataFactory</code> specifies a <code class="codeph">create</code> method equivalent to a constructor for the custom object class. It creates and returns an <code class="codeph">OracleData</code> instance. The JDBC driver uses the <code class="codeph">create</code> method to return an instance of the custom object class to your Java application. It takes as input a <code class="codeph">java.lang.Object</code> object and an integer indicating the corresponding SQL type code as specified in the <code class="codeph">OracleTypes</code> class.
                              </p>
                           </li>
                        </ul>
                        <p><code class="codeph">OracleData</code> and <code class="codeph">OracleDataFactory</code> have the following definitions:
                        </p><pre class="oac_no_warn" dir="ltr">package oracle.jdbc;
import java.sql.Connection;
import java.sql.SQLException;
public interface OracleData 
{
   public Object toJDBCObject(Connection conn) throws SQLException;
}
</pre><pre class="oac_no_warn" dir="ltr">package oracle.jdbc;
import java.sql.SQLException;
public interface OracleDataFactory 
{
    public OracleData create(Object jdbcValue, int sqlType) throws SQLException;
  
}
</pre><p>Where <span class="italic"><code class="codeph">conn</code></span> represents the Connection object, <span class="italic"><code class="codeph">jdbcValue</code></span> represents an object of type <code class="codeph">java.lang.object</code> that is to be used to initialize the Object being created, and <span class="italic"><code class="codeph">sqlType</code></span> represents the SQL type of the specified <code class="codeph">Datum</code> object.
                        </p>
                     </div>
                     <!-- class="section" -->
                     <div class="section">
                        <p class="subhead3" id="GUID-EEF1A8CA-354D-430B-9153-171849DE2525__GUID-4EE2EDCE-2552-44B5-8FE7-9883B853807F">Retrieving and Inserting Object Data</p>
                     </div>
                     <!-- class="section" -->
                     <div class="section">
                        <p>The JDBC drivers provide the following methods to retrieve and insert object data as instances of <code class="codeph">OracleData</code>.
                        </p>
                        <p>You can retrieve the object data in one of the following ways:</p>
                        <ul style="list-style-type: disc;">
                           <li>
                              <p>Use the following <code class="codeph">getObject</code> method of the Oracle-specific <code class="codeph">OracleResultSet</code> interface:
                              </p><pre class="oac_no_warn" dir="ltr">ors.getObject(int col_index, OracleDataFactory factory
);
</pre><p>This method takes as input the column index of the data in your result set and an <code class="codeph">OracleDataFactory</code> instance. For example, you can implement a <code class="codeph">getOracleDataFactory</code> method in your custom object class to produce the <code class="codeph">OracleDataFactory</code> instance to input to the <code class="codeph">getObject</code> method. The type map is not required when using Java classes that implement <code class="codeph">OracleData</code>.
                              </p>
                           </li>
                           <li>
                              <p>Use the standard <a id="d51198e1908" class="indexterm-anchor"></a><code class="codeph">getObject(</code><span class="italic"><code class="codeph">index</code></span><code class="codeph">, </code><span class="italic"><code class="codeph">map</code></span><code class="codeph">)</code> method specified by the <code class="codeph">ResultSet</code> interface to retrieve data as instances of <code class="codeph">OracleData</code>. In this case, you must have an entry in the type map that identifies the factory class to be used for the given object type and its corresponding SQL type name.
                              </p>
                           </li>
                        </ul>
                        <p>You can insert object data in one of the following ways:</p>
                        <ul style="list-style-type: disc;">
                           <li>
                              <p>Use the following <code class="codeph">setObject</code> method of the Oracle-specific <code class="codeph">OraclePreparedStatement</code> class:
                              </p><pre class="oac_no_warn" dir="ltr">setObject(int bind_index, Object custom_object);
</pre><p>This method takes as input the parameter index of the bind variable and an instance of <code class="codeph">OracleData</code> as the name of the object containing the variable.
                              </p>
                           </li>
                           <li>
                              <p>Use the standard <code class="codeph">setObject</code> method specified by the <code class="codeph">PreparedStatement</code> interface. You can also use this method, in its different forms, to insert <code class="codeph">OracleData</code> instances without requiring a type map.
                              </p>
                           </li>
                        </ul>
                        <p>The following sections describe the <code class="codeph">getObject</code> and <code class="codeph">setObject</code> methods.
                        </p>
                        <p>To continue the example of an Oracle object <code class="codeph">EMPLOYEE</code>, you might have something like the following in your Java application:
                        </p><pre class="oac_no_warn" dir="ltr">OracleData obj = ors.getObject(1, Employee.getOracleDataFactory());
</pre><p>In this example, <code class="codeph">ors</code> is an instance of the <code class="codeph">OracleResultSet</code> interface, <code class="codeph">getObject</code> is a method in the <code class="codeph">OracleResultSet</code> interface used to retrieve an <code class="codeph">OracleData</code> object, and the <code class="codeph">EMPLOYEE</code> is in column 1 of the result set. The <code class="codeph">static</code> <code class="codeph">Employee.getOracleDataFactory</code> method will return an <code class="codeph">OracleDataFactory</code> to the JDBC driver. The JDBC driver will call <code class="codeph">create(</code>) from this object, returning to your Java application an instance of the <code class="codeph">Employee</code> class populated with data from the result set.
                        </p>
                        <div class="infoboxnote" id="GUID-EEF1A8CA-354D-430B-9153-171849DE2525__GUID-11BBA304-16B0-4DBA-B0D6-9ABA2B24703E">
                           <p class="notep1">Note:</p>
                           <ul style="list-style-type: disc;">
                              <li>
                                 <p><code class="codeph">OracleData</code> and <code class="codeph">OracleDataFactory</code> are defined as separate interfaces so that different Java classes can implement them if you wish.
                                 </p>
                              </li>
                              <li>
                                 <p>To use the <code class="codeph">OracleData</code> interface, your custom object classes must import <code class="codeph">oracle.jdbc.*</code>.
                                 </p>
                              </li>
                           </ul>
                        </div>
                     </div>
                     <!-- class="section" -->
                  </div>
               </div><a id="JJDBC28470"></a><a id="JJDBC28471"></a><a id="JJDBC28469"></a><div class="props_rev_3"><a id="GUID-7E84EDB6-A403-475D-875B-CAA151436AF7" name="GUID-7E84EDB6-A403-475D-875B-CAA151436AF7"></a><h4 id="JJDBC-GUID-7E84EDB6-A403-475D-875B-CAA151436AF7" class="sect4"><span class="enumeration_section">13.3.7 </span>About Reading and Writing Data with an OracleData Implementation
                  </h4>
                  <div>
                     <p>This section describes how to read data from an Oracle object or write data to an Oracle object if your corresponding Java class implements <code class="codeph">OracleData</code>.
                     </p>
                     <div class="section">
                        <p class="subhead3" id="GUID-7E84EDB6-A403-475D-875B-CAA151436AF7__GUID-B657E514-694F-49A2-BB60-18F520429B82">Reading Data from an Oracle Object Using an OracleData Implementation</p>
                     </div>
                     <!-- class="section" -->
                     <div class="section">
                        <p>The following text <a id="d51198e2067" class="indexterm-anchor"></a>summarizes the steps in reading data from an Oracle object into your Java application. These steps apply whether you implement <code class="codeph">OracleData</code> manually or use Oracle JVM Web Service Call-Out utility to produce your custom object classes.
                        </p>
                        <p>These steps assume you have already defined the Oracle object type, created the corresponding custom object class or had Oracle JVM Web Service Call-Out utility create it for you, and defined a statement object <code class="codeph">stmt</code>.
                        </p>
                        <ol>
                           <li>
                              <p>Query the database to read the Oracle object into a result set, casting it to an Oracle result set.</p><pre class="oac_no_warn" dir="ltr">OracleResultSet ors = (OracleResultSet)stmt.executeQuery
                      ("SELECT Emp_col FROM PERSONNEL");
</pre><p>Where <code class="codeph">PERSONNEL</code> is a one-column table. The column name is <code class="codeph">Emp_col</code> of type <code class="codeph">Employee_object</code>. 
                              </p>
                           </li>
                           <li>
                              <p>Use the <code class="codeph">getObject</code> method of Oracle result set to populate an instance of your custom object class with data from one row of the result set. The <code class="codeph">getObject</code> method returns a <code class="codeph">java.lang.Object</code> object, which you can cast to your specific custom object class.
                              </p><pre class="oac_no_warn" dir="ltr">if (ors.next())
   Employee emp = (Employee)ors.getObject(1, Employee.getOracleDataFactory());
</pre><p>or:</p><pre class="oac_no_warn" dir="ltr">if (ors.next())
   Object obj = ors.getObject(1, Employee.getOracleDataFactory());
</pre><p>This example assumes that <code class="codeph">Employee</code> is the name of your custom object class and <code class="codeph">ors</code> is the name of your <code class="codeph">OracleResultSet</code> instance. 
                              </p>
                              <p>For example, if the SQL type name for your object is <code class="codeph">EMPLOYEE</code>, then the corresponding Java class is <code class="codeph">Employee</code>, which will implement <code class="codeph">OracleData</code>. The corresponding Factory class is <code class="codeph">EmployeeFactory</code>, which will implement <code class="codeph">OracleDataFactory</code>. 
                              </p>
                              <p>Use this statement to declare the <code class="codeph">EmployeeFactory</code> entry for your type map:
                              </p><pre class="oac_no_warn" dir="ltr">map.put ("EMPLOYEE", Class.forName ("EmployeeFactory")); 
</pre><p>Then use the form of <code class="codeph">getObject</code> where you specify the map object:
                              </p><pre class="oac_no_warn" dir="ltr">Employee emp = (Employee) rs.getObject (1, map);
</pre><p>If the default type map of the connection already has an entry that identifies the factory class to be used for the given object type and its corresponding SQL type name, then you can use this form of <code class="codeph">getObject</code>:
                              </p><pre class="oac_no_warn" dir="ltr">Employee emp = (Employee) rs.getObject (1); 
</pre></li>
                           <li>
                              <p>If you have <code class="codeph">get</code> methods in your custom object class, then use them to read data from your object attributes into Java variables in your application. For example, if <code class="codeph">EMPLOYEE</code> has <code class="codeph">EmpName</code> of type <code class="codeph">CHAR</code> and <code class="codeph">EmpNum</code> of type <code class="codeph">NUMBER</code>, provide a <code class="codeph">getEmpName</code> method that returns a Java <code class="codeph">String</code> and a <code class="codeph">getEmpNum</code> method that returns an integer. Then call them in your Java application as follows:
                              </p><pre class="oac_no_warn" dir="ltr">String empname = emp.getEmpName();
int empnumber = emp.getEmpNum();
</pre></li>
                        </ol>
                     </div>
                     <!-- class="section" -->
                     <div class="section">
                        <p class="subhead3" id="GUID-7E84EDB6-A403-475D-875B-CAA151436AF7__GUID-622829E2-D65F-4312-AABD-83CB892CE5BF">Writing Data to an Oracle Object Using an OracleData Implementation</p>
                     </div>
                     <!-- class="section" -->
                     <div class="section">
                        <p>The following text <a id="d51198e2204" class="indexterm-anchor"></a>summarizes the steps in writing data to an Oracle object from your Java application. These steps apply whether you implement <code class="codeph">OracleData</code> manually or use Oracle JVM Web Service Call-Out utility to produce your custom object classes.
                        </p>
                        <p>These steps assume you have already defined the Oracle object type and created the corresponding custom object class.</p>
                        <div class="infoboxnote" id="GUID-7E84EDB6-A403-475D-875B-CAA151436AF7__GUID-B881DFAC-F842-49EB-B4AE-EB2A8C6178A1">
                           <p class="notep1">Note:</p>
                           <p>The type map is not used when you are performing database <code class="codeph">INSERT</code> and <code class="codeph">UPDATE</code> operations.
                           </p>
                        </div>
                        <ol>
                           <li>
                              <p>If you have <code class="codeph">set</code> methods in your custom object class, then use them to write data from Java variables in your application to attributes of your Java data type object. 
                              </p><pre class="oac_no_warn" dir="ltr">emp.setEmpName(empname);
emp.setEmpNum(empnumber);
</pre></li>
                           <li>
                              <p>Write an Oracle prepared statement that updates an Oracle object in a row of a database table, as appropriate, using the data provided in your Java data type object.</p><pre class="oac_no_warn" dir="ltr">OraclePreparedStatement opstmt = conn.prepareStatement
   ("UPDATE PERSONNEL SET Employee = ? WHERE Employee.EmpNum = 28959);
</pre><p>This assumes <code class="codeph">conn</code> is your <code class="codeph">Connection</code> object.
                              </p>
                           </li>
                           <li>
                              <p>Use the <code class="codeph">setObject</code> method of the <code class="codeph">OraclePreparedStatement</code> interface to bind your Java data type object to the prepared statement.
                              </p><pre class="oac_no_warn" dir="ltr">opstmt.setObject(1,emp);
</pre><p>The <code class="codeph">setObject</code> method calls the <code class="codeph">toJDBCObject</code> method of the custom object class instance to retrieve an <code class="codeph">oracle.jdbc.OracleStruct</code> object that can be written to the database.
                              </p>
                              <div class="infoboxnote" id="GUID-7E84EDB6-A403-475D-875B-CAA151436AF7__GUID-CC5F882D-298E-40B1-8FC7-A1FB1F17F07A">
                                 <p class="notep1">Note:</p>
                                 <p>You can use your Java data type objects as either <code class="codeph">IN</code> or <code class="codeph">OUT</code> bind variables.
                                 </p>
                              </div>
                           </li>
                        </ol>
                     </div>
                     <!-- class="section" -->
                  </div>
               </div><a id="JJDBC28472"></a><div class="props_rev_3"><a id="GUID-1CC46DF9-95F1-4892-8C25-9B3BBD36CFFF" name="GUID-1CC46DF9-95F1-4892-8C25-9B3BBD36CFFF"></a><h4 id="JJDBC-GUID-1CC46DF9-95F1-4892-8C25-9B3BBD36CFFF" class="sect4"><span class="enumeration_section">13.3.8 </span>Additional Uses of OracleData
                  </h4>
                  <div>
                     <div class="section">
                        <p>The <code class="codeph">OracleData</code> interface offers far more flexibility than the <code class="codeph">SQLData</code> interface. The <code class="codeph">SQLData</code> interface is designed to let you customize the mapping of only Oracle object types to Java types of your choice. Implementing the <code class="codeph">SQLData</code> interface lets the JDBC driver populate fields of a custom Java class instance from the original SQL object data, and the reverse, after performing the appropriate conversions between Java and SQL types. 
                        </p>
                        <p>The <code class="codeph">OracleData</code> interface goes beyond supporting the customization of Oracle object types to Java types. It lets you provide a mapping between Java object types and <span class="italic">any</span> SQL type supported by the <code class="codeph">oracle.sql</code> package. 
                        </p>
                        <p>You may find it useful to provide custom Java classes to wrap <code class="codeph">oracle.sql.*</code> types and then implement customized conversions or functionality as well. The following are some possible scenarios:
                        </p>
                        <ul style="list-style-type: disc;">
                           <li>
                              <p>Performing encryption and decryption or validation of data</p>
                           </li>
                           <li>
                              <p>Performing logging of values that have been read or are being written</p>
                           </li>
                           <li>
                              <p>Parsing character columns, such as character fields containing URL information, into smaller components</p>
                           </li>
                           <li>
                              <p>Mapping character strings into numeric constants</p>
                           </li>
                           <li>
                              <p>Making data into more desirable Java formats, such as mapping a <code class="codeph">DATE</code> field to <code class="codeph">java.util.Date</code> format
                              </p>
                           </li>
                           <li>
                              <p>Customizing data representation, for example, data in a table column is in feet but you want it represented in meters after it is selected</p>
                           </li>
                           <li>
                              <p>Serializing and deserializing Java objects</p>
                           </li>
                        </ul>
                        <p>For example, use <code class="codeph">OracleData</code> to store instances of Java objects that do not correspond to a particular SQL object type in the database in columns of SQL type <code class="codeph">RAW</code>. The <code class="codeph">create</code> method in <code class="codeph">OracleDataFactory</code> would have to implement a conversion from an object of type <code class="codeph">oracle.sql.RAW</code> to the desired Java object. The <code class="codeph">toJDBCObject</code> method in <code class="codeph">OracleData</code> would have to implement a conversion from the Java object to an <code class="codeph">oracle.sql.RAW</code> object. You can also achieve this using Java serialization.
                        </p>
                        <p>Upon retrieval, the JDBC driver transparently retrieves the raw bytes of data in the form of an <code class="codeph">oracle.sql.RAW</code> and calls the <code class="codeph">create</code> method of <code class="codeph">OracleDataFactory</code> to convert the <code class="codeph">oracle.sql.RAW</code> object to the desired Java class.
                        </p>
                        <p>When you insert the Java object into the database, you can simply bind it to a column of type <code class="codeph">RAW</code> to store it. The driver transparently calls the <code class="codeph">OracleData</code>.<code class="codeph">toJDBCObject</code> method to convert the Java object to an <code class="codeph">oracle.sql.RAW</code> object. This object is then stored in a column of type <code class="codeph">RAW</code> in the database. 
                        </p>
                        <p>Support for the <code class="codeph">OracleData</code> interfaces is also highly efficient because the conversions are designed to work using <code class="codeph">oracle.sql.*</code> formats, which happen to be the internal formats used by the JDBC drivers. Moreover, the type map, which is necessary for the <code class="codeph">SQLData</code> interface, is not required when using Java classes that implement <code class="codeph">OracleData</code>.
                        </p>
                     </div>
                     <!-- class="section" -->
                  </div>
                  <div>
                     <div class="relinfo">
                        <p><strong>Related Topics</strong></p>
                        <ul>
                           <li><a href="Oracle-object-types.html#GUID-EEF1A8CA-354D-430B-9153-171849DE2525">About the OracleData Interface</a></li>
                        </ul>
                     </div>
                  </div>
                  
               </div>
            </div><a id="JJDBC28474"></a><div class="props_rev_3"><a id="GUID-E47B8141-3C4C-44D5-BB5C-2F8E16DF5140" name="GUID-E47B8141-3C4C-44D5-BB5C-2F8E16DF5140"></a><h3 id="JJDBC-GUID-E47B8141-3C4C-44D5-BB5C-2F8E16DF5140" class="sect3"><span class="enumeration_section">13.4 </span>Object-Type Inheritance
               </h3>
               <div>
                  <p>Object-type inheritance allows a new object type to be created by extending another object type. The new object type is then a subtype of the object type from which it extends. The subtype automatically inherits all the attributes and methods defined in the supertype. The subtype can add attributes and methods and overload or override methods inherited from the supertype.</p>
                  <p>Object-type inheritance introduces <span class="bold">substitutability</span>. Substitutability is the ability of a slot declared to hold a value of type <code class="codeph">T</code> in addition to any subtype of type <code class="codeph">T</code>. Oracle JDBC drivers handle substitutability transparently.
                  </p>
                  <p>A database object is returned with its most specific type without losing information. For example, if the <code class="codeph">STUDENT_T</code> object is stored in a <code class="codeph">PERSON_T</code> slot, Oracle JDBC driver returns a Java object that represents the <code class="codeph">STUDENT_T</code> object.
                  </p>
                  <p>This section covers the following topics:</p>
                  <ul style="list-style-type: disc;">
                     <li>
                        <p><a href="Oracle-object-types.html#GUID-27F2FE6B-DA9A-4551-94EF-EDEAC5CBD6FE">About Creating Subtypes</a></p>
                     </li>
                     <li>
                        <p><a href="Oracle-object-types.html#GUID-21A782F4-5EA3-42E0-8201-2636B97516C2">About Implementing Customized Classes for Subtypes</a></p>
                     </li>
                     <li>
                        <p><a href="Oracle-object-types.html#GUID-9E0B6269-71FD-4F4C-83B5-D31D214655A0">About Retrieving Subtype Objects</a></p>
                     </li>
                     <li>
                        <p><a href="Oracle-object-types.html#GUID-EDEEF48A-DBEE-484D-BC65-577DD9665ACA">Creating Subtype Objects</a></p>
                     </li>
                     <li>
                        <p><a href="Oracle-object-types.html#GUID-B7A9E9B9-ED8B-4EBA-94F1-C048876DB314">Sending Subtype Objects</a></p>
                     </li>
                     <li>
                        <p><a href="Oracle-object-types.html#GUID-4D4E75B2-AFE4-4C34-BDCD-C06D0D27EAB2">Accessing Subtype Data Fields</a></p>
                     </li>
                     <li>
                        <p><a href="Oracle-object-types.html#GUID-E0C046C2-4F00-49EB-89B8-D2C147C5C75F">Inheritance Metadata Methods</a></p>
                     </li>
                  </ul>
               </div><a id="JJDBC29174"></a><a id="JJDBC28475"></a><div class="props_rev_3"><a id="GUID-27F2FE6B-DA9A-4551-94EF-EDEAC5CBD6FE" name="GUID-27F2FE6B-DA9A-4551-94EF-EDEAC5CBD6FE"></a><h4 id="JJDBC-GUID-27F2FE6B-DA9A-4551-94EF-EDEAC5CBD6FE" class="sect4"><span class="enumeration_section">13.4.1 </span>About Creating Subtypes
                  </h4>
                  <div>
                     <p>Create custom object classes if you want to have Java classes that explicitly correspond to the Oracle object types. If you have a hierarchy of object types, you may want a corresponding hierarchy of Java classes.</p>
                     <p>The most common way to create a database subtype in JDBC is to run a SQL <code class="codeph">CREATE TYPE</code> command using the <code class="codeph">execute</code> method of the <code class="codeph">java.sql.Statement</code> interface. For example, you want to create a type inheritance hierarchy as depicted in the following figure:
                     </p>
                     <div class="figure" id="GUID-27F2FE6B-DA9A-4551-94EF-EDEAC5CBD6FE__BCEDBDFC">
                        <p class="titleinfigure">Figure 13-1 Type Inheritance Hierarchy</p><img src="img/hierarchy.gif" alt="Description of Figure 13-1 follows" title="Description of Figure 13-1 follows" longdesc="img_text/hierarchy.html"><br><a href="img_text/hierarchy.html">Description of "Figure 13-1 Type Inheritance Hierarchy"</a></div>
                     <!-- class="figure" -->
                     <p>The JDBC code for this can be as follows:</p><pre class="oac_no_warn" dir="ltr">Statement s = conn.createStatement();
s.execute ("CREATE TYPE Person_T (SSN NUMBER, name VARCHAR2(30),
  address VARCHAR2(255))");
s.execute ("CREATE TYPE Student_T UNDER Person_t (deptid NUMBER,
  major VARCHAR2(100))");
s.execute ("CREATE TYPE PartTimeStudent_t UNDER Student_t (numHours NUMBER)");
</pre><p>In the following code, the <code class="codeph">foo</code> member procedure in type <code class="codeph">ST</code> is overloaded and the member procedure <code class="codeph">print</code> overwrites the copy it inherits from type <code class="codeph">T</code>.
                     </p><pre class="oac_no_warn" dir="ltr">CREATE TYPE T AS OBJECT (..., 
  MEMBER PROCEDURE foo(x NUMBER), 
  MEMBER PROCEDURE Print(), 
  ... 
  NOT FINAL; 

CREATE TYPE ST UNDER T (..., 
  MEMBER PROCEDURE foo(x DATE),         &lt;-- overload "foo" 
  OVERRIDING MEMBER PROCEDURE Print(),   &lt;-- override "print" 
  STATIC FUNCTION bar(...) ... 
  ... 
  );
</pre><p>Once the subtypes have been created, they can be used as both columns of a base table as well as attributes of an object type.</p>
                     <div class="infoboxnotealso" id="GUID-27F2FE6B-DA9A-4551-94EF-EDEAC5CBD6FE__GUID-678DBA14-0836-48A2-A65F-8BF46E46A64D">
                        <p class="notep1">See Also:</p>
                        <p><a href="../adobj/inheritance-in-sql-object-types.html#ADOBJ-GUID-D6D92FB6-7BC4-4EE6-A9EC-BC69C5BA5A56" target="_blank"><span><cite>Oracle Database Object-Relational Developer's Guide</cite></span></a></p>
                     </div>
                  </div>
               </div><a id="JJDBC28476"></a><div class="props_rev_3"><a id="GUID-21A782F4-5EA3-42E0-8201-2636B97516C2" name="GUID-21A782F4-5EA3-42E0-8201-2636B97516C2"></a><h4 id="JJDBC-GUID-21A782F4-5EA3-42E0-8201-2636B97516C2" class="sect4"><span class="enumeration_section">13.4.2 </span>About Implementing Customized Classes for Subtypes
                  </h4>
                  <div>
                     <p>In most cases, a customized Java class represents a database object type. When you create a customized Java class for a subtype, the Java class can either mirror the database object type hierarchy or not.</p>
                     <p>You can use either the <code class="codeph">OracleData</code> or <code class="codeph">SQLData</code> solution in creating classes to map to the hierarchy of object types.
                     </p>
                     <p>This section covers the following topics:</p>
                     <ul style="list-style-type: disc;">
                        <li>
                           <p><a href="Oracle-object-types.html#GUID-EF78FF64-5B65-42F7-97B0-5CF233BF9DC8">About Using OracleData for Type Inheritance Hierarchy</a></p>
                        </li>
                        <li>
                           <p><a href="Oracle-object-types.html#GUID-26AC0C12-D473-4957-A9B1-D64DFD0EC71B">About UsingSQLData for Type Inheritance Hierarchy</a></p>
                        </li>
                     </ul>
                  </div><a id="JJDBC28478"></a><a id="JJDBC28479"></a><a id="JJDBC28480"></a><a id="JJDBC28477"></a><div class="props_rev_3"><a id="GUID-EF78FF64-5B65-42F7-97B0-5CF233BF9DC8" name="GUID-EF78FF64-5B65-42F7-97B0-5CF233BF9DC8"></a><h5 id="JJDBC-GUID-EF78FF64-5B65-42F7-97B0-5CF233BF9DC8" class="sect5"><span class="enumeration_section">13.4.2.1 </span>About Using OracleData for Type Inheritance Hierarchy
                     </h5>
                     <div>
                        <p>Oracle recommends customized mappings, where Java classes implement the <code class="codeph">oracle.sql.OracleData</code> interface. <code class="codeph">OracleData</code> mapping requires the JDBC application to implement the <code class="codeph">OracleData</code> and <code class="codeph">OracleDataFactory</code> interfaces. The class implementing the <code class="codeph">OracleDataFactory</code> interface contains a factory method that produces objects. Each object represents a database object.
                        </p>
                        <p>The hierarchy of the class implementing the <code class="codeph">OracleData</code> interface can mirror the database object type hierarchy. For example, the Java classes mapping to <code class="codeph">PERSON_T</code> and <code class="codeph">STUDENT_T</code> are as follows:
                        </p>
                        <div class="section">
                           <p class="subhead3" id="GUID-EF78FF64-5B65-42F7-97B0-5CF233BF9DC8__GUID-895805D9-7E10-4541-8C36-4A63263264A5">Person.java using OracleData</p>
                        </div>
                        <!-- class="section" -->
                        <div class="section">
                           <p>Code for the <code class="codeph">Person.java</code> class which implements the <code class="codeph">OracleData</code> and <code class="codeph">OracleDataFactory</code> interfaces:
                           </p><pre class="oac_no_warn" dir="ltr">public static OracleDataFactory getOracleDataFactory() 
  { 
    return _personFactory; 
  } 
 
  public Person () {} 
 
  public Person(NUMBER ssn, CHAR name, CHAR address) 
  { 
    this.ssn = ssn; 
    this.name = name; 
    this.address = address; 
  } 
 
  public Object toJDBCObject(OracleConnection c) throws SQLException 
  { 
    Object [] attributes = { ssn, name, address };
 Struct struct = c.createStruct("HR.PERSON_T", attributes);
    return struct; 
  } 
 
  public OracleData create(Object jdbcValue, int sqlType) throws SQLException 
  { 
    if (d == null) return null; 
    Object [] attributes = ((STRUCT) d).getOracleAttributes(); 
    return new Person((NUMBER) attributes[0], 
                      (CHAR) attributes[1], 
                      (CHAR) attributes[2]); 
  } 
}
</pre></div>
                        <!-- class="section" -->
                        <div class="section">
                           <p class="subhead3" id="GUID-EF78FF64-5B65-42F7-97B0-5CF233BF9DC8__GUID-A6BFBF89-1F2F-4B90-B2D9-B5DC48709AD1">Student.java extending Person.java</p>
                        </div>
                        <!-- class="section" -->
                        <div class="section">
                           <p>Code for the <code class="codeph">Student.java</code> class, which extends the <code class="codeph">Person.java</code> class:
                           </p><pre class="oac_no_warn" dir="ltr">class Student extends Person 
{ 
  static final Student _studentFactory = new Student (); 
 
  public NUMBER deptid; 
  public CHAR major; 
 
  public static OracleDataFactory getOracleDataFactory() 
  { 
    return _studentFactory; 
  } 
 
  public Student () {} 
 
  public Student (NUMBER ssn, CHAR name, CHAR address, 
                  NUMBER deptid, CHAR major) 
  { 
    super (ssn, name, address); 
    this.deptid = deptid; 
    this.major = major; 
  } 
 
  public Object toJDBCObject(OracleConnection c) throws SQLException 
  { 
    Object [] attributes = { ssn, name, address, deptid, major };
    Struct struct = c.createStruct("HR.STUDENT_T", attributes);
    return struct; 
  } 
 
  public OracleData create(Object jdbcValue, int sqlType) throws SQLException 
  { 
    if (d == null) return null; 
    Object [] attributes = ((STRUCT) d).getOracleAttributes(); 
    return new Student((NUMBER) attributes[0], 
                       (CHAR) attributes[1], 
                       (CHAR) attributes[2], 
                       (NUMBER) attributes[3], 
                       (CHAR) attributes[4]); 
  } 
}
</pre><p>Customized classes that implement the <code class="codeph">OracleData</code> interface do not have to mirror the database object type hierarchy. For example, you could have declared the <code class="codeph">Student</code> class without a superclass. In this case, <code class="codeph">Student</code> would contain fields to hold the inherited attributes from <code class="codeph">PERSON_T</code> as well as the attributes declared by <code class="codeph">STUDENT_T</code>.
                           </p>
                        </div>
                        <!-- class="section" -->
                        <div class="section">
                           <p class="subhead3" id="GUID-EF78FF64-5B65-42F7-97B0-5CF233BF9DC8__GUID-08E47E90-F85E-4424-BAF1-2860676E801C">OracleDataFactory Implementation</p>
                        </div>
                        <!-- class="section" -->
                        <div class="section">
                           <p>The JDBC application uses the factory class in querying the database to return instances of <code class="codeph">Person</code> or its subclasses, as in the following example:
                           </p><pre class="oac_no_warn" dir="ltr">ResultSet rset = stmt.executeQuery ("select person from tab1"); 
while (rset.next()) 
{ 
  rset.getOracleData(1,Person.getOracleDataFactory());
  ... 
} 
</pre><p>A class implementing the <code class="codeph">OracleDataFactory</code> interface should be able to produce instances of the associated custom object type, as well as instances of any subtype, or at least all the types you expect to support.
                           </p>
                           <p>In the following example, the <code class="codeph">PersonFactory.getOracleDataFactory</code> method returns a factory that can handle <code class="codeph">PERSON_T</code>, <code class="codeph">STUDENT_T</code>, and <code class="codeph">PARTTIMESTUDENT_T</code> objects, by returning <code class="codeph">person</code>, <code class="codeph">student</code>, or <code class="codeph">parttimestudent</code> Java instances.
                           </p><pre class="oac_no_warn" dir="ltr">class PersonFactory implements OracleDataFactory 
{ 
  static final PersonFactory _factory = new PersonFactory (); 
 
  public static OracleDataFactory getOracleDataFactory() 
  { 
    return _factory; 
  } 
 
  public OracleData create(Object jdbcValue, int sqlType) throws SQLException 
  { 
    STRUCT s = (STRUCT) jdbcValue; 
    if (s.getSQLTypeName ().equals ("HR.PERSON_T")) 
      return Person.getOracleDataFactory ().create (jdbcValue, sqlType); 
    else if (s.getSQLTypeName ().equals ("HR.STUDENT_T")) 
      return Student.getOracleDataFactory ().create(jdbcValue, sqlType); 
    else if (s.getSQLTypeName ().equals ("HR.PARTTIMESTUDENT_T")) 
      return ParttimeStudent.getOracleDataFactory ().create(jdbcValue, sqlType); 
    else 
      return null; 
  } 
}
</pre><p>The following example assumes a table <code class="codeph">tabl1</code>, such as the following:
                           </p><pre class="oac_no_warn" dir="ltr">CREATE TABLE tabl1 (idx NUMBER, person PERSON_T); 
INSERT INTO tabl1 VALUES (1, PERSON_T (1000, 'HR', '100 Oracle Parkway')); 
INSERT INTO tabl1 VALUES (2, STUDENT_T (1001, 'Peter', '200 Oracle Parkway', 101, 'CS')); 
INSERT INTO tabl1 VALUES (3, PARTTIMESTUDENT_T (1002, 'David', '300 Oracle Parkway', 102, 'EE')); 
</pre></div>
                        <!-- class="section" -->
                     </div>
                  </div><a id="JJDBC28482"></a><a id="JJDBC28483"></a><a id="JJDBC28484"></a><a id="JJDBC28481"></a><div class="props_rev_3"><a id="GUID-26AC0C12-D473-4957-A9B1-D64DFD0EC71B" name="GUID-26AC0C12-D473-4957-A9B1-D64DFD0EC71B"></a><h5 id="JJDBC-GUID-26AC0C12-D473-4957-A9B1-D64DFD0EC71B" class="sect5"><span class="enumeration_section">13.4.2.2 </span>About UsingSQLData for Type Inheritance Hierarchy
                     </h5>
                     <div>
                        <p>The customized classes that implement the <code class="codeph">java.sql.SQLData</code> interface can mirror the database object type hierarchy. The <code class="codeph">readSQL</code> and <code class="codeph">writeSQL</code> methods of a subclass typically call the corresponding superclass methods to read or write the superclass attributes before reading or writing the subclass attributes. For example, the Java classes mapping to <code class="codeph">PERSON_T</code> and <code class="codeph">STUDENT_T</code> are as follows:
                        </p>
                        <div class="section">
                           <p class="subhead3" id="GUID-26AC0C12-D473-4957-A9B1-D64DFD0EC71B__GUID-AD3DE26D-3E19-4639-B695-79590722E8A3">Person.java using SQLData</p>
                        </div>
                        <!-- class="section" -->
                        <div class="section">
                           <p>Code for the <code class="codeph">Person.java</code> class, which implements the <code class="codeph">SQLData</code> interface:
                           </p><pre class="oac_no_warn" dir="ltr">import java.sql.*; 

public class Person implements SQLData 
{ 
  private String sql_type; 
  public int ssn; 
  public String name; 
  public String address; 

  public Person () {} 

  public String getSQLTypeName() throws SQLException { return sql_type; } 

  public void readSQL(SQLInput stream, String typeName) throws SQLException 
  { 
    sql_type = typeName; 
    ssn = stream.readInt(); 
    name = stream.readString(); 
    address = stream.readString(); 
  } 

  public void writeSQL(SQLOutput stream) throws SQLException 
  { 
    stream.writeInt (ssn); 
    stream.writeString (name); 
    stream.writeString (address); 
  } 
}
</pre></div>
                        <!-- class="section" -->
                        <div class="section">
                           <p class="subhead3" id="GUID-26AC0C12-D473-4957-A9B1-D64DFD0EC71B__GUID-66BB23E1-9228-4ED2-B020-4FBBE13A36A9">Student.java extending Student.java</p>
                        </div>
                        <!-- class="section" -->
                        <div class="section">
                           <p>Code for the <code class="codeph">Student.java</code> class, which extends the <code class="codeph">Person.java</code> class:
                           </p><pre class="oac_no_warn" dir="ltr">import java.sql.*; 

public class Student extends Person 
{ 
  private String sql_type; 
  public int deptid; 
  public String major; 

  public Student () { super(); } 

  public String getSQLTypeName() throws SQLException { return sql_type; } 

  public void readSQL(SQLInput stream, String typeName) throws SQLException 
  { 
    super.readSQL (stream, typeName);    // read supertype attributes 
    sql_type = typeName;
    deptid = stream.readInt(); 
    major = stream.readString(); 
  } 

  public void writeSQL(SQLOutput stream) throws SQLException 
  { 
    super.writeSQL (stream);        // write supertype
                                         // attributes 
    stream.writeInt (deptid); 
    stream.writeString (major); 
  } 
}
</pre><p>Although not required, it is recommended that the customized classes, which implement the <code class="codeph">SQLData</code> interface, mirror the database object type hierarchy. For example, you could have declared the <code class="codeph">Student</code> class without a superclass. In this case, <code class="codeph">Student</code> would contain fields to hold the inherited attributes from <code class="codeph">PERSON_T</code> as well as the attributes declared by <code class="codeph">STUDENT_T</code>.
                           </p>
                        </div>
                        <!-- class="section" -->
                        <div class="section">
                           <p class="subhead3" id="GUID-26AC0C12-D473-4957-A9B1-D64DFD0EC71B__GUID-EE80B9FE-3B3D-4194-A3EA-C1240387D7B1">Student.java using SQLData</p>
                        </div>
                        <!-- class="section" -->
                        <div class="section">
                           <p>Code for the <code class="codeph">Student.java</code> class, which does not extend the <code class="codeph">Person.java</code> class, but implements the SQLData interface directly:
                           </p><pre class="oac_no_warn" dir="ltr">import java.sql.*; 

public class Student implements SQLData 
{ 
  private String sql_type; 

  public int ssn; 
  public String name; 
  public String address; 
  public int deptid; 
  public String major; 

  public Student () {} 

  public String getSQLTypeName() throws SQLException { return sql_type; } 

  public void readSQL(SQLInput stream, String typeName) throws SQLException 
  { 
    sql_type = typeName; 
    ssn = stream.readInt(); 
    name = stream.readString(); 
    address = stream.readString(); 
    deptid = stream.readInt(); 
    major = stream.readString(); 
  } 

  public void writeSQL(SQLOutput stream) throws SQLException 
  { 
    stream.writeInt (ssn); 
    stream.writeString (name); 
    stream.writeString (address); 
    stream.writeInt (deptid); 
    stream.writeString (major); 
  } 
}
</pre></div>
                        <!-- class="section" -->
                     </div>
                  </div>
               </div><a id="JJDBC28487"></a><a id="JJDBC28488"></a><a id="JJDBC28489"></a><a id="JJDBC28486"></a><div class="props_rev_3"><a id="GUID-9E0B6269-71FD-4F4C-83B5-D31D214655A0" name="GUID-9E0B6269-71FD-4F4C-83B5-D31D214655A0"></a><h4 id="JJDBC-GUID-9E0B6269-71FD-4F4C-83B5-D31D214655A0" class="sect4"><span class="enumeration_section">13.4.3 </span>About Retrieving Subtype Objects
                  </h4>
                  <div>
                     <p>In a typical JDBC application, a subtype object is returned as one of the following:</p>
                     <ul style="list-style-type: disc;">
                        <li>
                           <p>A query result</p>
                        </li>
                        <li>
                           <p>A PL/SQL <code class="codeph">OUT</code> parameter
                           </p>
                        </li>
                        <li>
                           <p>A type attribute</p>
                        </li>
                     </ul>
                     <p>You can use either the default mapping or the <code class="codeph">SQLData</code> mapping or the <code class="codeph">OracleData</code> mapping to retrieve a subtype.
                     </p>
                     <div class="section">
                        <p class="subhead3" id="GUID-9E0B6269-71FD-4F4C-83B5-D31D214655A0__GUID-942D43C1-39B4-4356-A2C5-3D1B1D9FCFDD">Using Default Mapping</p>
                     </div>
                     <!-- class="section" -->
                     <div class="section">
                        <p>By default, a database object is returned as an instance of the <code class="codeph">oracle.jdbc.OracleStruct</code> interface. This instance may represent an object of either the declared type or subtype of the declared type. If the <code class="codeph">OracleStruct</code> interface represents a subtype object in the database, then it contains the attributes of its supertype as well as those defined in the subtype.
                        </p>
                        <p>Oracle JDBC driver returns database objects in their most specific type. The JDBC application can use the <code class="codeph">getSQLTypeName</code> method of the <code class="codeph">OracleStruct</code> interface to determine the SQL type of the <code class="codeph">STRUCT</code> object. The following code shows this:
                        </p><pre class="oac_no_warn" dir="ltr">// tab1.person column can store PERSON_T, STUDENT_T and PARTIMESTUDENT_T objects 
ResultSet rset = stmt.executeQuery ("select person from tab1"); 
while (rset.next()) 
{ 
  oracle.sql.STRUCT s = (oracle.sql.STRUCT) rset.getObject(1); 
  if (s != null) 
    System.out.println (s.getSQLTypeName());    // print out the type name which 
    // may be HR.PERSON_T, HR.STUDENT_T or HR.PARTTIMESTUDENT_T
}
</pre></div>
                     <!-- class="section" -->
                     <div class="section">
                        <p class="subhead3" id="GUID-9E0B6269-71FD-4F4C-83B5-D31D214655A0__GUID-9CE4AA48-A012-4F10-8B67-9F6B78AD67E4">Using SQLData Mapping</p>
                     </div>
                     <!-- class="section" -->
                     <div class="section">
                        <p>With <code class="codeph">SQLData</code> mapping, the JDBC driver returns the database object as an instance of the class implementing the <code class="codeph">SQLData</code> interface.
                        </p>
                        <p>To use <code class="codeph">SQLData</code> mapping in retrieving database objects, do the following:
                        </p>
                        <ol>
                           <li>
                              <p>Implement the container classes that implement the <code class="codeph">SQLData</code> interface for the desired object types.
                              </p>
                           </li>
                           <li>
                              <p>Populate the connection type map with entries that specify what custom Java type corresponds to each Oracle object type.</p>
                           </li>
                           <li>
                              <p>Use the <code class="codeph">getObject</code> method to access the SQL object values.
                              </p>
                              <p>The JDBC driver checks the type map for an entry match. If one exists, then the driver returns the database object as an instance of the class implementing the <code class="codeph">SQLData</code> interface.
                              </p>
                           </li>
                        </ol>
                        <p>The following code shows the whole SQLData customized mapping process:</p><pre class="oac_no_warn" dir="ltr">// The JDBC application developer implements Person.java for PERSON_T, 
// Student.java for STUDENT_T 
// and ParttimeStudent.java for PARTTIMESTUDEN_T. 

Connection conn = ...;  // make a JDBC connection 

// obtains the connection typemap 
java.util.Map map = conn.getTypeMap (); 

// populate the type map 
map.put ("HR.PERSON_T", Class.forName ("Person")); 
map.put ("HR.STUDENT_T", Class.forName ("Student")); 
map.put ("HR.PARTTIMESTUDENT_T", Class.forName ("ParttimeStudent")); 

// tab1.person column can store PERSON_T, STUDENT_T and PARTTIMESTUDENT_T objects 
ResultSet rset = stmt.executeQuery ("select person from tab1"); 
while (rset.next()) 
{ 
  // "s" is instance of Person, Student or ParttimeStudent 
  Object s = rset.getObject(1); 

  if (s != null) 
  { 
    if (s instanceof Person) 
      System.out.println ("This is a Person"); 
    else if (s instanceof Student) 
      System.out.println ("This is a Student"); 
    else if (s instanceof ParttimeStudent) 
      System.out.pritnln ("This is a PartimeStudent"); 
    else 
      System.out.println ("Unknown type"); 
  } 
}
</pre><p>The JDBC drivers check the connection type map for each call to the following:</p>
                        <ul style="list-style-type: disc;">
                           <li>
                              <p><code class="codeph">getObject</code> method of the <code class="codeph">java.sql.ResultSet</code> and <code class="codeph">java.sql.CallableStatement</code> interfaces
                              </p>
                           </li>
                           <li>
                              <p><code class="codeph">getAttribute</code> method of the <code class="codeph">java.sql.Struct</code> interface
                              </p>
                           </li>
                           <li>
                              <p><code class="codeph">getArray</code> method of the <code class="codeph">java.sql.Array</code> interface
                              </p>
                           </li>
                           <li>
                              <p><code class="codeph">getValue</code> method of the <code class="codeph">oracle.sql.REF</code> interface
                              </p>
                           </li>
                        </ul>
                     </div>
                     <!-- class="section" -->
                     <div class="section">
                        <p class="subhead3" id="GUID-9E0B6269-71FD-4F4C-83B5-D31D214655A0__GUID-D9C1D077-F39C-4D37-9B04-46C16FFAF791">Using OracleData Mapping</p>
                     </div>
                     <!-- class="section" -->
                     <div class="section">
                        <p>With <code class="codeph">OracleData</code> mapping, the JDBC driver returns the database object as an instance of the class implementing the <code class="codeph">OracleData</code> interface.
                        </p>
                        <p>Oracle JDBC driver needs to be informed of what Java class is mapped to the Oracle object type. The following are the two ways to inform Oracle JDBC drivers:</p>
                        <ul style="list-style-type: disc;">
                           <li>
                              <p>The JDBC application uses the <code class="codeph">getObject(int idx, OracleDataFactory f)</code> method to access database objects. The second parameter of the <code class="codeph">getObject</code> method specifies an instance of the factory class that produces the customized class. The <code class="codeph">getObject</code> method is available in the <code class="codeph">OracleResultSet</code> and <code class="codeph">OracleCallableStatement</code> interfaces.
                              </p>
                           </li>
                           <li>
                              <p>The JDBC application populates the connection type map with entries that specify what custom Java type corresponds to each Oracle object type. The <code class="codeph">getObject</code> method is used to access the Oracle object values.
                              </p>
                           </li>
                        </ul>
                        <p>The second approach involves the use of the standard <code class="codeph">getObject</code> method. The following code example demonstrates the first approach:
                        </p><pre class="oac_no_warn" dir="ltr">// tab1.person column can store both PERSON_T and STUDENT_T objects 
ResultSet rset = stmt.executeQuery ("select person from tab1"); 
while (rset.next()) 
{ 
  Object s = rset.getObject(1, PersonFactory.getOracleDataFactory());
  if (s != null) 
  { 
    if (s instanceof Person) 
      System.out.println ("This is a Person"); 
    else if (s instanceof Student) 
      System.out.println ("This is a Student"); 
    else if (s instanceof ParttimeStudent) 
      System.out.pritnln ("This is a PartimeStudent"); 
    else 
      System.out.println ("Unknown type"); 
  } 
}
</pre></div>
                     <!-- class="section" -->
                  </div>
               </div><a id="JJDBC28490"></a><div class="props_rev_3"><a id="GUID-EDEEF48A-DBEE-484D-BC65-577DD9665ACA" name="GUID-EDEEF48A-DBEE-484D-BC65-577DD9665ACA"></a><h4 id="JJDBC-GUID-EDEEF48A-DBEE-484D-BC65-577DD9665ACA" class="sect4"><span class="enumeration_section">13.4.4 </span>Creating Subtype Objects
                  </h4>
                  <div>
                     <div class="section">
                        <p>There are cases where JDBC applications create database subtype objects with JDBC drivers. These objects are sent either to the database as bind variables or are used to exchange information within the JDBC application. </p>
                        <p>With customized mapping, the JDBC application creates either <code class="codeph">SQLData</code>-based or <code class="codeph">OracleData</code>-based objects, depending on the approach you choose, to represent database subtype objects. With default mapping, the JDBC application creates <code class="codeph">STRUCT</code> objects to represent database subtype objects. All the data fields inherited from the supertype as well as all the fields defined in the subtype must have values. The following code demonstrates this:
                        </p><pre class="oac_no_warn" dir="ltr">Connection conn = ...   // make a JDBC connection 
...
Object[] attrs = { 
  new Integer(1234), "HR", "500 Oracle Parkway", // data fields defined in
                                                    // PERSON_T 
  new Integer(102), "CS",                           // data fields defined in
                                                    // STUDENT_T 
  new Integer(4)                                    // data fields defined in
                                                    // PARTTIMESTUDENT_T 
}; 
Struct s = conn.createStruct("HR.PARTTIMESTUDENT", attrs);
</pre><p><code class="codeph">s</code> is initialized with data fields inherited from <code class="codeph">PERSON_T</code> and <code class="codeph">STUDENT_T</code>, and data fields defined in <code class="codeph">PARTTIMESTUDENT_T</code>.
                        </p>
                     </div>
                     <!-- class="section" -->
                  </div>
               </div><a id="JJDBC28491"></a><div class="props_rev_3"><a id="GUID-B7A9E9B9-ED8B-4EBA-94F1-C048876DB314" name="GUID-B7A9E9B9-ED8B-4EBA-94F1-C048876DB314"></a><h4 id="JJDBC-GUID-B7A9E9B9-ED8B-4EBA-94F1-C048876DB314" class="sect4"><span class="enumeration_section">13.4.5 </span>Sending Subtype Objects
                  </h4>
                  <div>
                     <div class="section">
                        <p>In a typical JDBC application, a Java object that represents a database object is sent to the databases as one of the following:</p>
                     </div>
                     <!-- class="section" -->
                     <div class="section">
                        <ul style="list-style-type: disc;">
                           <li>
                              <p>A data manipulation language (DML) bind variable</p>
                           </li>
                           <li>
                              <p>A PL/SQL <code class="codeph">IN</code> parameter
                              </p>
                           </li>
                           <li>
                              <p>An object type attribute value</p>
                           </li>
                        </ul>
                        <p>The Java object can be an instance of the <code class="codeph">STRUCT</code> class or an instance of the class implementing either the <code class="codeph">SQLData</code> or <code class="codeph">OracleData</code> interface. Oracle JDBC driver will convert the Java object into the linearized format acceptable to the database SQL engine. Binding a subtype object is the same as binding a standard object.
                        </p>
                     </div>
                     <!-- class="section" -->
                  </div>
               </div><a id="JJDBC28493"></a><a id="JJDBC28494"></a><a id="JJDBC28492"></a><div class="props_rev_3"><a id="GUID-4D4E75B2-AFE4-4C34-BDCD-C06D0D27EAB2" name="GUID-4D4E75B2-AFE4-4C34-BDCD-C06D0D27EAB2"></a><h4 id="JJDBC-GUID-4D4E75B2-AFE4-4C34-BDCD-C06D0D27EAB2" class="sect4"><span class="enumeration_section">13.4.6 </span>Accessing Subtype Data Fields
                  </h4>
                  <div>
                     <div class="section">
                        <p>While the logic to access subtype data fields is part of the customized class, this logic for default mapping is defined in the JDBC application itself. The database objects are returned as instances of the <code class="codeph">oracle.jdbc.OracleStruct</code> class. The JDBC application needs to call one of the following access methods in the <code class="codeph">STRUCT</code> class to access the data fields:
                        </p>
                     </div>
                     <!-- class="section" -->
                     <div class="section">
                        <ul style="list-style-type: disc;">
                           <li>
                              <p><code class="codeph">Object[] getAttribute()</code></p>
                           </li>
                           <li>
                              <p><code class="codeph">oracle.sql.Datum[] getOracleAttribute()</code></p>
                           </li>
                        </ul>
                     </div>
                     <!-- class="section" -->
                     <div class="section">
                        <p class="subhead3" id="GUID-4D4E75B2-AFE4-4C34-BDCD-C06D0D27EAB2__GUID-1750EBD8-BCF9-41F2-956F-E2B08202B3E5">Subtype Data Fields from the getAttribute Method</p>
                     </div>
                     <!-- class="section" -->
                     <div class="section">
                        <p>The <code class="codeph">getAttribute</code> method of the <code class="codeph">java.sql.Struct</code> interface is used in JDBC 2.0 to access object data fields. This method returns a <code class="codeph">java.lang.Object</code> array, where each array element represents an object attribute. You can determine the individual element type by referencing the corresponding attribute type in the JDBC conversion matrix. For example, a SQL <code class="codeph">NUMBER</code> attribute is converted to a <code class="codeph">java.math.BigDecimal</code> object. The <code class="codeph">getAttribute</code> method returns all the data fields defined in the supertype of the object type as well as data fields defined in the subtype. The supertype data fields are listed first followed by the subtype data fields.
                        </p>
                     </div>
                     <!-- class="section" -->
                     <div class="section">
                        <p class="subhead3" id="GUID-4D4E75B2-AFE4-4C34-BDCD-C06D0D27EAB2__GUID-961E150A-E595-4827-B49C-2B5213D980B8">Subtype Data Fields from the getOracleAttribute Method</p>
                     </div>
                     <!-- class="section" -->
                     <div class="section">
                        <p>The <code class="codeph">getOracleAttribute</code> method is an Oracle extension method and is more efficient than the <code class="codeph">getAttribute</code> method. The <code class="codeph">getOracleAttribute</code> method returns an <code class="codeph">oracle.sql.Datum</code> array to hold the data fields. Each element in the <code class="codeph">oracle.sql.Datum</code> array represents an attribute. You can determine the individual element type by referencing the corresponding attribute type in the Oracle conversion matrix. For example, a SQL <code class="codeph">NUMBER</code> attribute is converted to an <code class="codeph">oracle.sql.NUMBER</code> object. The <code class="codeph">getOracleAttribute</code> method returns all the attributes defined in the supertype of the object type, as well as attributes defined in the subtype. The supertype data fields are listed first followed by the subtype data fields.
                        </p>
                        <p>The following code shows the use of the <code class="codeph">getAttribute</code> method:
                        </p><pre class="oac_no_warn" dir="ltr">// tab1.person column can store PERSON_T, STUDENT_T and PARTIMESTUDENT_T objects 
ResultSet rset = stmt.executeQuery ("select person from tab1"); 
while (rset.next()) 
{ 
  oracle.sql.STRUCT s = (oracle.sql.STRUCT) rset.getObject(1); 
  if (s != null) 
  { 
    String sqlname = s.getSQLTypeName(); 

<span class="bold">    Object[] attrs = s.getAttribute(); </span>

    if (sqlname.equals ("HR.PERSON") 
    { 
      System.out.println ("ssn="+((BigDecimal)attrs[0]).intValue()); 
      System.out.println ("name="+((String)attrs[1])); 
      System.out.println ("address="+((String)attrs[2])); 
    } 
    else if (sqlname.equals ("HR.STUDENT")) 
    { 
      System.out.println ("ssn="+((BigDecimal)attrs[0]).intValue()); 
      System.out.println ("name="+((String)attrs[1])); 
      System.out.println ("address="+((String)attrs[2])); 
      System.out.println ("deptid="+((BigDecimal)attrs[3]).intValue()); 
      System.out.println ("major="+((String)attrs[4])); 
    } 
    else if (sqlname.equals ("HR.PARTTIMESTUDENT")) 
    { 
      System.out.println ("ssn="+((BigDecimal)attrs[0]).intValue()); 
      System.out.println ("name="+((String)attrs[1])); 
      System.out.println ("address="+((String)attrs[2])); 
      System.out.println ("deptid="+((BigDecimal)attrs[3]).intValue()); 
      System.out.println ("major="+((String)attrs[4])); 
      System.out.println ("numHours="+((BigDecimal)attrs[5]).intValue()); 
    } 
    else 
      throw new Exception ("Invalid type name: "+sqlname); 
  } 
} 
rset.close (); 
stmt.close (); 
conn.close ();
</pre></div>
                     <!-- class="section" -->
                  </div>
               </div><a id="JJDBC28495"></a><div class="props_rev_3"><a id="GUID-E0C046C2-4F00-49EB-89B8-D2C147C5C75F" name="GUID-E0C046C2-4F00-49EB-89B8-D2C147C5C75F"></a><h4 id="JJDBC-GUID-E0C046C2-4F00-49EB-89B8-D2C147C5C75F" class="sect4"><span class="enumeration_section">13.4.7 </span>Inheritance Metadata Methods
                  </h4>
                  <div>
                     <div class="section">
                        <p>Oracle JDBC drivers provide a set of metadata methods to access inheritance properties. The inheritance metadata methods are defined in the <code class="codeph">oracle.sql.StructDescriptor</code> and <code class="codeph">oracle.jdbc.StructMetaData</code> classes.
                        </p>
                        <p>The <code class="codeph">StructMetaData</code> class provides inheritance metadata methods for subtype attributes. The <code class="codeph">getMetaData</code> method of the <code class="codeph">StructDescriptor</code> class returns an instance of <code class="codeph">StructMetaData</code> of the type. The <code class="codeph">StructMetaData</code> class contains the following inheritance metadata methods:
                        </p>
                     </div>
                     <!-- class="section" -->
                  </div>
               </div>
            </div><a id="JJDBC28505"></a><div class="props_rev_3"><a id="GUID-4D737F6A-66F6-4C67-BC9A-233A89F75FFD" name="GUID-4D737F6A-66F6-4C67-BC9A-233A89F75FFD"></a><h3 id="JJDBC-GUID-4D737F6A-66F6-4C67-BC9A-233A89F75FFD" class="sect3"><span class="enumeration_section">13.5 </span>About Describing an Object Type
               </h3>
               <div>
                  <div class="section">
                     <p>Oracle JDBC includes functionality to retrieve information about a structured object type regarding its attribute names and types. This is similar conceptually to retrieving information from a result set about its column names and types, and in fact uses an almost identical method.</p>
                     <p>This section covers the following topics:</p>
                     <ul style="list-style-type: disc;">
                        <li>
                           <p><a href="Oracle-object-types.html#GUID-BE316A98-BAAD-4B15-A8DA-D9E081E9F2D4">Functionality for Getting Object Metadata</a></p>
                        </li>
                        <li>
                           <p><a href="Oracle-object-types.html#GUID-1C6748F4-AC7D-4645-9A00-6F366C553B16">Retrieving Object Metadata</a></p>
                        </li>
                     </ul>
                  </div>
                  <!-- class="section" -->
               </div><a id="JJDBC28506"></a><div class="props_rev_3"><a id="GUID-BE316A98-BAAD-4B15-A8DA-D9E081E9F2D4" name="GUID-BE316A98-BAAD-4B15-A8DA-D9E081E9F2D4"></a><h4 id="JJDBC-GUID-BE316A98-BAAD-4B15-A8DA-D9E081E9F2D4" class="sect4"><span class="enumeration_section">13.5.1 </span>Functionality for Getting Object Metadata
                  </h4>
                  <div>
                     <div class="section">
                        <p>The <code class="codeph">oracle.sql.StructDescriptor</code> class includes functionality to retrieve metadata about a structured object type. The <code class="codeph">StructDescriptor</code> class has a <code class="codeph">getMetaData</code> method with the same functionality as the standard <code class="codeph">getMetaData</code> method available in result set objects. It returns a set of attribute information, such as attribute names and types. Call this method on a <code class="codeph">StructDescriptor</code> object to get metadata about the Oracle object type that the <code class="codeph">StructDescriptor</code> object describes.
                        </p>
                        <p>The signature of the <code class="codeph">StructDescriptor</code> class <code class="codeph">getMetaData</code> method is the same as the signature specified for <code class="codeph">getMetaData</code> in the standard <code class="codeph">ResultSet</code> interface. The signature is as follows:
                        </p><pre class="oac_no_warn" dir="ltr">ResultSetMetaData getMetaData() throws SQLException
</pre><p>However, this method actually returns an instance of <code class="codeph">oracle.jdbc.StructMetaData</code>, a class that supports structured object metadata in the same way that the standard <code class="codeph">java.sql.ResultSetMetaData</code> interface specifies support for result set metadata.
                        </p>
                        <p>The following method is also supported by <code class="codeph">StructMetaData</code>:
                        </p><pre class="oac_no_warn" dir="ltr">String getOracleColumnClassName(int column) throws SQLException
</pre><p>This method returns the fully qualified name of the <code class="codeph">oracle.sql.Datum</code> subclass whose instances are manufactured if the <code class="codeph">OracleResultSet</code> interface <code class="codeph">getOracleObject</code> method is called to retrieve the value of the specified attribute. For example, <code class="codeph">oracle.sql.NUMBER</code>. 
                        </p>
                        <p>To use the <code class="codeph">getOracleColumnClassName</code> method, you must cast the <code class="codeph">ResultSetMetaData</code> object, which that was returned by the <code class="codeph">getMetaData</code> method, to <code class="codeph">StructMetaData</code>.
                        </p>
                        <ul style="list-style-type: disc;">
                           <li>
                              <div class="infoboxnote" id="GUID-BE316A98-BAAD-4B15-A8DA-D9E081E9F2D4__GUID-DCCF7172-A7CE-4F5D-856E-112DB9A909BC">
                                 <p class="notep1">Note:</p>
                                 <p>In all the preceding method signatures, <code class="codeph">column</code> is something of a misnomer. Where you specify a value of 4 for <code class="codeph">column</code>, you really refer to the fourth attribute of the object.
                                 </p>
                              </div>
                           </li>
                        </ul>
                     </div>
                     <!-- class="section" -->
                  </div>
               </div><a id="JJDBC28508"></a><a id="JJDBC28507"></a><div class="props_rev_3"><a id="GUID-1C6748F4-AC7D-4645-9A00-6F366C553B16" name="GUID-1C6748F4-AC7D-4645-9A00-6F366C553B16"></a><h4 id="JJDBC-GUID-1C6748F4-AC7D-4645-9A00-6F366C553B16" class="sect4"><span class="enumeration_section">13.5.2 </span>Retrieving Object Metadata
                  </h4>
                  <div>
                     <div class="section">
                        <p>Use the following steps to obtain metadata about a structured object type:</p>
                     </div>
                     <!-- class="section" -->
                     <ol>
                        <li class="stepexpand" id="GUID-1C6748F4-AC7D-4645-9A00-6F366C553B16__BABBJBEG"><span>Create or acquire a <code class="codeph">StructDescriptor</code> instance that describes the relevant structured object type.</span></li>
                        <li class="stepexpand"><span>Call the <code class="codeph">getMetaData</code> method on the <code class="codeph">StructDescriptor</code> instance.</span></li>
                        <li class="stepexpand" id="GUID-1C6748F4-AC7D-4645-9A00-6F366C553B16__BABFDCJH"><span>Call the metadata getter methods, <code class="codeph">getColumnName</code>, <code class="codeph">getColumnType</code>, and <code class="codeph">getColumnTypeName</code>, as desired.</span><div>
                              <div class="infoboxnote" id="GUID-1C6748F4-AC7D-4645-9A00-6F366C553B16__GUID-4444BB26-A13D-4916-B727-4749B86F14A4">
                                 <p class="notep1">Note:</p>
                                 <p>If one of the structured object attributes is itself a structured object, repeat steps 1 through 3.</p>
                              </div>
                           </div>
                        </li>
                     </ol>
                     <div class="example" id="GUID-1C6748F4-AC7D-4645-9A00-6F366C553B16__GUID-2314DB02-7822-45AF-9391-1EF6AB365EB4">
                        <p class="titleinexample">Example 13-1 Example</p>
                        <p>The following method shows how to retrieve information about the attributes of a structured object type. This includes the initial step of creating a <code class="codeph">StructDescriptor</code> instance.
                        </p><pre class="oac_no_warn" dir="ltr">// 
// Print out the ADT's attribute names and types 
// 
void getAttributeInfo (Connection conn, String type_name) throws SQLException 
{ </pre><pre class="oac_no_warn" dir="ltr">  // get the type descriptor 
  StructDescriptor desc = StructDescriptor.createDescriptor (type_name, conn); 

  // get type metadata 
  ResultSetMetaData md = desc.getMetaData (); 

  // get # of attrs of this type 
  int numAttrs = desc.length (); 

  // temporary buffers 
  String attr_name; 
  int attr_type; 
  String attr_typeName; 

  System.out.println ("Attributes of "+type_name+" :"); 
  for (int i=0; i&lt;numAttrs; i++) 
  { 
    attr_name = md.getColumnName (i+1); 
    attr_type = md.getColumnType (i+1); 
    System.out.println (" index"+(i+1)+" name="+attr_name+" type="+attr_type); 

    // drill down nested object 
    if (attrType == OracleTypes.STRUCT) 
    { 
      attr_typeName = md.getColumnTypeName (i+1); 

      // recursive calls to print out nested object metadata 
      getAttributeInfo (conn, attr_typeName); 
    } 
  } 
}</pre></div>
                     <!-- class="example" -->
                  </div>
               </div>
            </div>
         </div>
      </article>
   </body>
</html>