<html lang="en-us" dir="ltr" xml:lang="en-us">
   <head>
      <meta http-equiv="Content-Type" content="text/html; charset=utf-8"></meta>
      <meta name="viewport" content="width=device-width, initial-scale=1"></meta>
      <meta http-equiv="X-UA-Compatible" content="IE=edge"></meta>
      <meta name="abstract" content="This chapter discusses the Object Type Translator (OTT), which is used to map database object types and named collection types to C structs for use in OCI applications."></meta>
      <meta name="description" content="This chapter discusses the Object Type Translator (OTT), which is used to map database object types and named collection types to C structs for use in OCI applications."></meta>
      <title>将对象类型转换器与OCI一起使用</title>
      <meta property="og:site_name" content="Oracle Help Center"></meta>
      <meta property="og:title" content="Programmer&#39;s Guide"></meta>
      <meta property="og:description" content="This chapter discusses the Object Type Translator (OTT), which is used to map database object types and named collection types to C structs for use in OCI applications."></meta>
      <link rel="stylesheet" href="/sp_common/book-template/ohc-book-template/css/book.css"></link>
      <link rel="shortcut icon" href="/sp_common/book-template/ohc-common/img/favicon.ico"></link>
      <meta name="application-name" content="Programmer&#39;s Guide"></meta>
      <meta name="generator" content="DITA Open Toolkit version 1.8.5 (Mode = doc)"></meta>
      <meta name="plugin" content="SP_docbuilder HTML plugin release 18.2.2"></meta>
      <link rel="alternate" href="oracle-call-interface-programmers-guide.pdf" title="PDF File" type="application/pdf"></link>
      <meta name="robots" content="all"></meta>
      <link rel="schema.dcterms" href="http://purl.org/dc/terms/"></link>
      <meta name="dcterms.created" content="2019-01-14T08:46:00-08:00"></meta>
      
      <meta name="dcterms.dateCopyrighted" content="1996, 2019"></meta>
      <meta name="dcterms.category" content="database"></meta>
      <meta name="dcterms.identifier" content="E96204-01"></meta>
      
      <meta name="dcterms.product" content="en/database/oracle/oracle-database/19"></meta>
      
      <link rel="prev" href="oci-support-for-xml.html" title="Previous" type="text/html"></link>
      <link rel="next" href="database-access-c-api.html" title="Next" type="text/html"></link>
      <script>
        document.write('<style type="text/css">');
        document.write('body > .noscript, body > .noscript ~ * { visibility: hidden; }');
        document.write('</style>');
     </script>
      <script src="/sp_common/book-template/requirejs/require.js" data-main="/sp_common/book-template/ohc-book-template/js/book-config"></script>
      <script>
            if (window.require === undefined) {
                document.write('<script data-main="sp_common/book-template/ohc-book-template/js/book-config" src="sp_common/book-template/requirejs/require.js"><\/script>');
                document.write('<link href="sp_common/book-template/ohc-book-template/css/book.css" rel="stylesheet"/>');
            }
        </script>
      <script type="application/json" id="ssot-metadata">{"primary":{"category":{"short_name":"database","element_name":"Database","display_in_url":true},"suite":{"short_name":"oracle","element_name":"Oracle","display_in_url":true},"product_group":{"short_name":"not-applicable","element_name":"Not applicable","display_in_url":false},"product":{"short_name":"oracle-database","element_name":"Oracle Database","display_in_url":true},"release":{"short_name":"19","element_name":"Release 19","display_in_url":true}}}</script>
      
    <meta name="dcterms.title" content="Oracle Call Interface Programmer&#39;s Guide"></meta>
    <meta name="dcterms.isVersionOf" content="LNOCI"></meta>
    <meta name="dcterms.release" content="Release 19"></meta>
  </head>
   <body dir="ltr">
      <div class="noscript alert alert-danger text-center" role="alert">
         <a href="oci-support-for-xml.html" class="pull-left"><span class="glyphicon glyphicon-chevron-left" aria-hidden="true"></span>上一页</a> <a href="database-access-c-api.html" class="pull-right">下一页<span class="glyphicon glyphicon-chevron-right" aria-hidden="true"></span></a> <span class="fa fa-exclamation-triangle" aria-hidden="true"></span>必须启用JavaScript才能正确显示此内容</div>
      <article>
         <header>
            <ol class="breadcrumb" vocab="http://schema.org/" typeof="BreadcrumbList">
               <li property="itemListElement" typeof="ListItem"><a href="index.html" property="item" typeof="WebPage"><span property="name">程序员指南</span></a></li>
               <li class="active" property="itemListElement" typeof="ListItem">将对象类型转换器与OCI一起使用</li>
            </ol>
            <a id="GUID-3D22CA8E-BE01-492F-BA85-DDD0CD3F4890" name="GUID-3D22CA8E-BE01-492F-BA85-DDD0CD3F4890"></a><a id="LNOCI140"></a>
            
            <h2 id="LNOCI-GUID-3D22CA8E-BE01-492F-BA85-DDD0CD3F4890" class="sect2"><span class="enumeration_chapter">24</span>将对象类型转换器与OCI一起使用</h2>
         </header>
         <div class="ind">
            <div>
               <p>本章讨论了对象类型转换器（OTT），它用于将数据库对象类型和命名集合类型映射到C结构，以便在OCI应用程序中使用。</p>
               <p>本章包含以下主题：</p>
               <ul style="list-style-type:disc">
                  <li>
                     <p><a href="using-object-type-translator-in-oci.html#GUID-501C03B7-D4D8-4F88-B1B3-38B07B107862" title="对象类型转换器（OTT）有助于开发在Oracle数据库中使用用户定义类型的C语言应用程序。">什么是对象类型转换器？</a></p>
                  </li>
                  <li>
                     <p><a href="using-object-type-translator-in-oci.html#GUID-FB91284B-9AE7-44BD-98AE-74F5B489256F" title="在大多数操作系统上，在命令行上调用OTT。">OTT命令行</a></p>
                  </li>
                  <li>
                     <p><a href="using-object-type-translator-in-oci.html#GUID-7370C345-D500-4805-BDBC-B81BB1E42990" title="当OTT运行时，intype文件告诉OTT应该翻译哪些数据库类型。">Intype文件</a></p>
                  </li>
                  <li>
                     <p><a href="using-object-type-translator-in-oci.html#GUID-BB88D6B6-2048-4756-AD4E-EE1DEC3DF1C2" title="当OTT从数据库类型生成C结构时，该结构包含一个对应于对象类型的每个属性的元素。">OTT数据类型映射</a></p>
                  </li>
                  <li>
                     <p><a href="using-object-type-translator-in-oci.html#GUID-77133295-EB6F-4B0D-81BE-2B7C117123A0" title="outtype文件在OTT命令行上命名。">Outtype文件</a></p>
                  </li>
                  <li>
                     <p><a href="using-object-type-translator-in-oci.html#GUID-D35CDFD1-8F5A-46D2-BC52-FD6B4A4D4F25" title="访问Oracle服务器中对象的OCI应用程序可以使用由OTT生成的C头和实现文件。">关于在OCI应用程序中使用OTT</a></p>
                  </li>
                  <li>
                     <p><a href="using-object-type-translator-in-oci.html#GUID-92EAE0E0-102C-4995-AE0E-F65BB120B749" title="可以出现在OTT命令行或CONFIG文件中的参数控制OTT的行为。某些参数也可以出现在intype文件中。">OTT参考</a></p>
                  </li>
               </ul>
            </div><a id="LNOCI72773"></a><a id="LNOCI72774"></a><a id="LNOCI72775"></a><a id="LNOCI17041"></a><div class="props_rev_3"><a id="GUID-501C03B7-D4D8-4F88-B1B3-38B07B107862" name="GUID-501C03B7-D4D8-4F88-B1B3-38B07B107862"></a><h3 id="LNOCI-GUID-501C03B7-D4D8-4F88-B1B3-38B07B107862" class="sect3"><span class="enumeration_section">24.1</span>什么是对象类型转换器？
               </h3>
               <div>
                  <p>对象类型转换器（OTT）有助于开发在Oracle数据库中使用用户定义类型的C语言应用程序。</p>
                  <p>使用SQL <code class="codeph">CREATE TYPE</code>语句，您可以创建对象类型。这些类型的定义存储在数据库中，可用于创建数据库表。填充这些表后，OCI程序员可以访问存储在表中的对象。
                  </p>
                  <p>访问对象数据的应用程序必须能够以宿主语言格式表示数据。这是通过将对象类型表示为C结构来实现的。虽然程序员可以手动编写结构声明来表示数据库对象类型，但如果涉及许多类型，这可能非常耗时且容易出错。OTT通过自动生成适当的结构声明来消除对这种手动编码的需要。在OCI中，应用程序还必须调用OTT生成的初始化函数。</p>
                  <p>除了创建表示存储数据类型的结构之外，OTT还生成并行指示符结构，指示对象类型或其字段是否为<code class="codeph">NULL</code> 。</p>
                  <p>对象类型转换器（OTT）将对象类型和命名集合类型的数据库定义转换为可包含在OCI应用程序中的C结构声明。</p>
                  <p>您必须显式调用OTT才能将数据库类型转换为C表示形式。</p>
                  <p>在大多数操作系统上，在命令行上调用OTT。它将<span class="italic">intype文件</span>作为输入，它生成一个<span class="italic">outtype文件</span>和一个或多个C <span class="italic">头文件</span>以及一个可选的<span class="italic">实现文件</span> 。以下是调用OTT的命令示例：</p><pre class="oac_no_warn" dir="ltr">ott userid = scott intype = demoin.typ outtype = demoout.typ code = c hfile = demo.h \ initfile = demov.c</pre><p>此命令使OTT使用用户名<code class="codeph">scott</code>连接到数据库。提示用户输入密码。
                  </p>
                  <p>实现文件（ <code class="codeph">demov.c</code> ）包含初始化类型版本表的函数，其中包含有关已翻译的用户定义类型的信息。
                  </p>
                  <p>本章后面的部分将更详细地描述每个参数。</p>
                  <p>示例<code class="codeph">demoin.typ</code>文件：</p><pre class="oac_no_warn" dir="ltr">CASE = LOWER TYPE emptype</pre><p>示例<code class="codeph">demoout.typ</code>文件：</p><pre class="oac_no_warn" dir="ltr">CASE = LOWER TYPE SCOTT.EMPTYPE AS emptype VERSION =“$ 8.0”HFILE = demo.h</pre><p>在此示例中， <code class="codeph">demoin.typ</code>文件包含要转换的类型，前面是<code class="codeph">TYPE</code> （例如， <code class="codeph">TYPE emptype</code> ）。outtype文件的结构类似于intype文件，添加了OTT获取的信息。</p>
                  <p>OTT完成转换后，头文件包含intype文件中指定的每种类型的C结构表示，以及与每种类型对应的<code class="codeph">NULL</code>指示符结构。例如，假设intype文件中列出的雇员类型定义如<a href="using-object-type-translator-in-oci.html#GUID-501C03B7-D4D8-4F88-B1B3-38B07B107862__CIHHEFAF">例24-1</a>所示。
                  </p>
                  <p>然后由OTT（ <code class="codeph">demo.h</code> ）生成的头文件包括<a href="using-object-type-translator-in-oci.html#GUID-501C03B7-D4D8-4F88-B1B3-38B07B107862__CIHDJDHC">例24-2中</a>所示的声明。
                  </p>
                  <p><a href="using-object-type-translator-in-oci.html#GUID-501C03B7-D4D8-4F88-B1B3-38B07B107862__CIHFDHDC">例24-3</a>显示了该命令生成的示例实现文件（ <code class="codeph">demov.c</code> ）包含的内容。
                  </p>
                  <p>intype文件中的参数控制生成结构的方式。在此示例中，结构名称<code class="codeph">emptype</code>与数据库类型名称匹配<code class="codeph"> </code> <code class="codeph">emptype</code> 。结构名称是小写的，因为intype文件中的行<code class="codeph">CASE=lower</code> 。
                  </p>
                  <p>结构声明中出现的数据类型（例如， <code class="codeph">OCIString</code> ， <code class="codeph">OCIInd</code> ）是特殊数据类型。
                  </p>
                  <p>本章的其余部分讨论OTT与OCI的使用，后面是描述命令行语法，参数，intype文件结构，嵌套<code class="codeph">#include</code>文件生成，模式名称用法，默认名称映射和限制的参考部分。
                  </p>
                  <div class="example" id="GUID-501C03B7-D4D8-4F88-B1B3-38B07B107862__CIHHEFAF">
                     <p class="titleinexample">示例24-1 Intype文件中列出的Employee对象类型的定义</p><pre class="oac_no_warn" dir="ltr">CREATE TYPE emptype AS OBJECT（名称VARCHAR2（30），empno NUMBER，deptno NUMBER，hiredate DATE，salary NUMBER）;</pre></div>
                  <!-- class="example" -->
                  <div class="example" id="GUID-501C03B7-D4D8-4F88-B1B3-38B07B107862__CIHDJDHC">
                     <p class="titleinexample">例24-2生成的头文件demo.h的内容</p><pre class="oac_no_warn" dir="ltr">struct emptype {OCIString * name; OCINumber empno; OCINumber deptno; OCIDate雇用; OCINumber薪水; }; typedef struct emptype emptype; struct emptype_ind {OCIInd _atomic; OCIInd名称; OCIInd empno; OCIInd deptno; OCIInd雇用; OCIInd工资; }; typedef struct employee_ind employee_ind;</pre></div>
                  <!-- class="example" -->
                  <div class="example" id="GUID-501C03B7-D4D8-4F88-B1B3-38B07B107862__CIHFDHDC">
                     <p class="titleinexample">示例24-3 demov.c文件的内容</p><pre class="oac_no_warn" dir="ltr">#ifndef OCI_ORACLE #include &lt;oci.h&gt; #endif sword demov（OCIEnv * env，OCIError * err）{sword status = OCITypeVTInit（env，err）; if（status == OCI_SUCCESS）status = OCITypeVTInsert（env，err，“HR”，2，“EMPTYPE”，7，“$ 8.0”，4）;返回状态; }</pre></div>
                  <!-- class="example" -->
                  <div class="section">
                     <div class="p">本节包括以下主题：<ul style="list-style-type:disc">
                           <li>
                              <p><a href="using-object-type-translator-in-oci.html#GUID-9FFC30CB-6DAF-4EDC-97E8-761632468687" title="使用OTT的第一步是创建对象类型或命名集合类型并将它们存储在数据库中。">关于在数据库中创建类型</a></p>
                           </li>
                           <li>
                              <p><a href="using-object-type-translator-in-oci.html#GUID-5615BF04-C5D6-4148-893A-120318E1F4FE" title="下一步是调用OTT。可以在命令行或称为配置文件的文件中指定OTT参数。">关于调用OTT</a></p>
                           </li>
                        </ul>
                     </div>
                     <div class="infoboxnotealso" id="GUID-501C03B7-D4D8-4F88-B1B3-38B07B107862__GUID-C028C48B-7765-4CFA-83C0-5D12140747CC">
                        <p class="notep1">也可以看看：</p>
                        <p><a href="using-object-type-translator-in-oci.html#GUID-BB88D6B6-2048-4756-AD4E-EE1DEC3DF1C2" title="当OTT从数据库类型生成C结构时，该结构包含一个对应于对象类型的每个属性的元素。">OTT数据类型映射</a>以获取有关这些类型的更多信息</p>
                     </div>
                  </div>
                  <!-- class="section" -->
               </div><a id="LNOCI17042"></a><div class="props_rev_3"><a id="GUID-9FFC30CB-6DAF-4EDC-97E8-761632468687" name="GUID-9FFC30CB-6DAF-4EDC-97E8-761632468687"></a><h4 id="LNOCI-GUID-9FFC30CB-6DAF-4EDC-97E8-761632468687" class="sect4"><span class="enumeration_section">24.1.1</span>关于在数据库中创建类型</h4>
                  <div>
                     <p>使用OTT的第一步是创建对象类型或命名集合类型并将它们存储在数据库中。</p>
                     <p>这是通过使用SQL <code class="codeph">CREATE TYPE</code>语句完成的。
                     </p>
                     <div class="infoboxnotealso" id="GUID-9FFC30CB-6DAF-4EDC-97E8-761632468687__GUID-C9E4DB92-C2F3-4D4C-BF86-9C9139D96944">
                        <p class="notep1">也可以看看：</p>
                        <p>有关<code class="codeph">CREATE</code> <code class="codeph">TYPE</code>语句的信息，请参见Oracle数据库SQL语言参考</p>
                     </div>
                  </div>
               </div><a id="LNOCI17043"></a><div class="props_rev_3"><a id="GUID-5615BF04-C5D6-4148-893A-120318E1F4FE" name="GUID-5615BF04-C5D6-4148-893A-120318E1F4FE"></a><h4 id="LNOCI-GUID-5615BF04-C5D6-4148-893A-120318E1F4FE" class="sect4"><span class="enumeration_section">24.1.2</span>关于调用OTT</h4>
                  <div>
                     <p>下一步是调用OTT。可以在命令行或称为配置文件的文件中指定OTT参数。</p>
                     <p>也可以在intype文件中指定某些参数。</p>
                     <p>如果在多个位置指定了参数，则其在命令行上的值优先于其在intype文件中的值，该值优先于其在用户定义的配置文件中的值，该文件优先于默认值中的值。配置文件。</p>
                     <p>对于全局选项 - 即命令行上的选项或任何<code class="codeph">TYPE</code>语句之前的intype文件开头的选项 - 命令行上的值将覆盖intype文件中的值。（可以在intype文件中全局指定的选项是<code class="codeph">CASE,</code> <code class="codeph">CODE,</code> <code class="codeph">INITFILE</code>和<code class="codeph">INITFUNC</code> ，但不是<code class="codeph">HFILE</code> 。）但是， <code class="codeph">TYPE</code>规范中的intype文件中的任何内容仅适用于特定类型，并覆盖命令行上可能适用于该类型的任何内容。因此，如果输入<code class="codeph">TYPE person HFILE=ph</code> ，它仅适用于<code class="codeph">person</code>并覆盖命令行上的<code class="codeph">HFILE</code> 。该语句不被视为命令行参数。
                     </p>
                     <div class="p">本节包括以下主题：<ul style="list-style-type:disc">
                           <li>
                              <p><a href="using-object-type-translator-in-oci.html#GUID-28F71980-3820-4D7B-9F53-3CA0A7D43971" title="在命令行上设置的参数（也称为选项）会覆盖其他任何设置。">命令行</a></p>
                           </li>
                           <li>
                              <p><a href="using-object-type-translator-in-oci.html#GUID-F8079DB0-8300-487F-AE52-2DEE0EEFF97F" title="配置文件是包含OTT参数的文本文件。">配置文件</a></p>
                           </li>
                           <li>
                              <p><a href="using-object-type-translator-in-oci.html#GUID-FEA329A6-7313-4FBD-95EF-5DF0D0ACEA38" title="intype文件提供了要翻译的OTT的用户定义类型列表。">INTYPE文件</a></p>
                           </li>
                        </ul>
                     </div>
                  </div><a id="LNOCI17044"></a><div class="props_rev_3"><a id="GUID-28F71980-3820-4D7B-9F53-3CA0A7D43971" name="GUID-28F71980-3820-4D7B-9F53-3CA0A7D43971"></a><h5 id="LNOCI-GUID-28F71980-3820-4D7B-9F53-3CA0A7D43971" class="sect5"><span class="enumeration_section">24.1.2.1</span>命令行</h5>
                     <div>
                        <p>在命令行上设置的参数（也称为选项）会覆盖其他任何设置。</p>
                        <div class="infoboxnotealso" id="GUID-28F71980-3820-4D7B-9F53-3CA0A7D43971__GUID-5B0861D5-BAF3-476B-AE92-F1AF03D1521D">
                           <p class="notep1">也可以看看：</p>
                           <p><a href="using-object-type-translator-in-oci.html#GUID-FB91284B-9AE7-44BD-98AE-74F5B489256F" title="在大多数操作系统上，在命令行上调用OTT。">OTT命令行</a></p>
                        </div>
                     </div>
                  </div><a id="LNOCI17045"></a><div class="props_rev_3"><a id="GUID-F8079DB0-8300-487F-AE52-2DEE0EEFF97F" name="GUID-F8079DB0-8300-487F-AE52-2DEE0EEFF97F"></a><h5 id="LNOCI-GUID-F8079DB0-8300-487F-AE52-2DEE0EEFF97F" class="sect5"><span class="enumeration_section">24.1.2.2</span>配置文件</h5>
                     <div>
                        <p>配置文件是包含OTT参数的文本文件。</p>
                        <p>文件中的每个非空行包含一个参数及其关联的值。如果在一行上放置了多个参数，则仅使用第一个参数。配置文件的任何非空行都不允许使用空格。</p>
                        <p>可以在命令行上命名配置文件。此外，始终读取默认配置文件。此默认配置文件必须始终存在，但可以为空。默认配置文件的名称是<code class="codeph">ottcfg.cfg</code> ，文件的位置是特定于系统的。例如，在Solaris上，文件规范是<code class="codeph">$ORACLE_HOME/precomp/admin/ottcfg.cfg</code> 。有关详细信息，请参阅特定于操作系统的文档。
                        </p>
                     </div>
                  </div><a id="LNOCI17046"></a><div class="props_rev_3"><a id="GUID-FEA329A6-7313-4FBD-95EF-5DF0D0ACEA38" name="GUID-FEA329A6-7313-4FBD-95EF-5DF0D0ACEA38"></a><h5 id="LNOCI-GUID-FEA329A6-7313-4FBD-95EF-5DF0D0ACEA38" class="sect5"><span class="enumeration_section">24.1.2.3</span> INTYPE文件</h5>
                     <div>
                        <p>intype文件提供了要翻译的OTT的用户定义类型列表。</p>
                        <p>参数<code class="codeph">CASE, HFILE, INITFUNC</code>和<code class="codeph">INITFILE</code>可以出现在intype文件中。
                        </p>
                        <div class="infoboxnotealso" id="GUID-FEA329A6-7313-4FBD-95EF-5DF0D0ACEA38__GUID-7BEFFD40-B89C-4D43-A3B0-F7AD364A0476">
                           <p class="notep1">也可以看看：</p>
                           <p><a href="using-object-type-translator-in-oci.html#GUID-7370C345-D500-4805-BDBC-B81BB1E42990" title="当OTT运行时，intype文件告诉OTT应该翻译哪些数据库类型。">Intype文件</a> 
                           </p>
                        </div>
                     </div>
                  </div>
               </div>
            </div><a id="LNOCI17047"></a><div class="props_rev_3"><a id="GUID-FB91284B-9AE7-44BD-98AE-74F5B489256F" name="GUID-FB91284B-9AE7-44BD-98AE-74F5B489256F"></a><h3 id="LNOCI-GUID-FB91284B-9AE7-44BD-98AE-74F5B489256F" class="sect3"><span class="enumeration_section">24.2</span> OTT命令行</h3>
               <div>
                  <p>在大多数操作系统上，在命令行上调用OTT。</p>
                  <p>您可以指定输入和输出文件以及数据库连接信息等。请参阅特定于操作系统的文档以了解如何调用OTT。</p>
                  <p>本节包括以下主题： <a href="using-object-type-translator-in-oci.html#GUID-9BDD90C1-B5EC-47CD-AFBB-2EA5FD9A372C" title="演示如何从命令行调用OTT。">OTT命令行调用示例</a> 。
                  </p>
                  <div class="infoboxnotealso" id="GUID-FB91284B-9AE7-44BD-98AE-74F5B489256F__GUID-2F02D943-2E92-455C-BB36-5DC730562D17">
                     <p class="notep1">也可以看看：</p>
                     <p><a href="getting-started-with-oci-for-windows.html#GUID-0A924779-3CB5-421E-A02D-628022F92067" title="要利用对象，请对数据库运行对象类型转换程序（OTT）以生成包含C结构的头文件。">关于使用Windows的对象类型转换器</a></p>
                  </div>
               </div><a id="LNOCI72776"></a><a id="LNOCI17048"></a><div class="props_rev_3"><a id="GUID-9BDD90C1-B5EC-47CD-AFBB-2EA5FD9A372C" name="GUID-9BDD90C1-B5EC-47CD-AFBB-2EA5FD9A372C"></a><h4 id="LNOCI-GUID-9BDD90C1-B5EC-47CD-AFBB-2EA5FD9A372C" class="sect4"><span class="enumeration_section">24.2.1</span> OTT命令行调用示例</h4>
                  <div>
                     <p>演示如何从命令行调用OTT。</p>
                     <p><a href="using-object-type-translator-in-oci.html#GUID-9BDD90C1-B5EC-47CD-AFBB-2EA5FD9A372C__CIHBDJIB">例24-4</a>显示了如何从命令行调用OTT。
                     </p>
                     <div class="infoboxnote" id="GUID-9BDD90C1-B5EC-47CD-AFBB-2EA5FD9A372C__GUID-A23819BD-CBAE-4F76-A77A-25EA7400EE03">
                        <p class="notep1">注意：</p>
                        <p>等号（=）周围不允许有空格。</p>
                     </div>
                     <div class="example" id="GUID-9BDD90C1-B5EC-47CD-AFBB-2EA5FD9A372C__CIHBDJIB">
                        <p class="titleinexample">示例24-4从命令行调用OTT</p><pre class="oac_no_warn" dir="ltr">ott userid = bren intype = demoin.typ outtype = demoout.typ code = c \ hfile = demo.h initfile = demov.c</pre></div>
                     <!-- class="example" -->
                     <div class="section">
                        <p>以下部分描述了此示例中使用的命令行的元素。</p>
                        <div class="p">本节包括以下主题：<ul style="list-style-type:disc">
                              <li>
                                 <p><a href="using-object-type-translator-in-oci.html#GUID-62E1C317-8673-4F98-A875-6BCAE3047F91" title="导致OTT被调用。">OTT</a></p>
                              </li>
                              <li>
                                 <p><a href="using-object-type-translator-in-oci.html#GUID-B4DBF87C-6E35-44B7-A05C-DB9D479589C3" title="指定OTT使用的数据库连接信息。">用户身份</a></p>
                              </li>
                              <li>
                                 <p><a href="using-object-type-translator-in-oci.html#GUID-8B74A7CE-4B68-47F9-A73B-B14EB0CC16D1" title="指定使用的intype文件的名称。">输入法菜单</a></p>
                              </li>
                              <li>
                                 <p><a href="using-object-type-translator-in-oci.html#GUID-63C32F8A-1C45-44B0-8682-696BB9ED5550" title="指定outtype文件的名称。">OUTTYPE</a></p>
                              </li>
                              <li>
                                 <p><a href="using-object-type-translator-in-oci.html#GUID-E6904C65-3A81-4638-86F8-74C7944F9783" title="指定转换的目标语言。">码</a></p>
                              </li>
                              <li>
                                 <p><a href="using-object-type-translator-in-oci.html#GUID-8CBBEC6E-3417-45BE-A8D2-4E39CBB96B3A" title="指定应将生成的结构写入的C头文件的名称。">HFILE</a></p>
                              </li>
                              <li>
                                 <p><a href="using-object-type-translator-in-oci.html#GUID-D1F48B2D-717C-4840-A791-0DAB64EBAD95" title="指定要在其中写入类型初始化函数的C源文件的名称。">INITFILE</a></p>
                              </li>
                           </ul>
                        </div>
                        <div class="infoboxnotealso" id="GUID-9BDD90C1-B5EC-47CD-AFBB-2EA5FD9A372C__GUID-C479775E-EA22-4BB6-8B3D-F3AD8C93B55E">
                           <p class="notep1">也可以看看：</p>
                           <p><a href="using-object-type-translator-in-oci.html#GUID-92EAE0E0-102C-4995-AE0E-F65BB120B749" title="可以出现在OTT命令行或CONFIG文件中的参数控制OTT的行为。某些参数也可以出现在intype文件中。">OTT参考</a>有关各种OTT命令行选项的详细讨论</p>
                        </div>
                     </div>
                     <!-- class="section" -->
                  </div><a id="LNOCI17049"></a><div class="props_rev_3"><a id="GUID-62E1C317-8673-4F98-A875-6BCAE3047F91" name="GUID-62E1C317-8673-4F98-A875-6BCAE3047F91"></a><h5 id="LNOCI-GUID-62E1C317-8673-4F98-A875-6BCAE3047F91" class="sect5"><span class="enumeration_section">24.2.1.1</span> OTT</h5>
                     <div>
                        <p>导致OTT被调用。</p>
                        <p>它必须是命令行中的第一项。</p>
                     </div>
                  </div><a id="LNOCI17050"></a><div class="props_rev_3"><a id="GUID-B4DBF87C-6E35-44B7-A05C-DB9D479589C3" name="GUID-B4DBF87C-6E35-44B7-A05C-DB9D479589C3"></a><h5 id="LNOCI-GUID-B4DBF87C-6E35-44B7-A05C-DB9D479589C3" class="sect5"><span class="enumeration_section">24.2.1.2</span> USERID</h5>
                     <div>
                        <p>指定OTT使用的数据库连接信息。</p>
                        <p>在<a href="using-object-type-translator-in-oci.html#GUID-9BDD90C1-B5EC-47CD-AFBB-2EA5FD9A372C__CIHBDJIB">例24-4中</a> ，OTT尝试连接用户名<code class="codeph">bren</code> ，然后提示输入密码。
                        </p>
                     </div>
                  </div><a id="LNOCI17051"></a><div class="props_rev_3"><a id="GUID-8B74A7CE-4B68-47F9-A73B-B14EB0CC16D1" name="GUID-8B74A7CE-4B68-47F9-A73B-B14EB0CC16D1"></a><h5 id="LNOCI-GUID-8B74A7CE-4B68-47F9-A73B-B14EB0CC16D1" class="sect5"><span class="enumeration_section">24.2.1.3</span> INTYPE</h5>
                     <div>
                        <p>指定使用的intype文件的名称。</p>
                        <p>在<a href="using-object-type-translator-in-oci.html#GUID-9BDD90C1-B5EC-47CD-AFBB-2EA5FD9A372C__CIHBDJIB">例24-4中</a> ，intype文件的名称被指定为<code class="codeph">demoin.typ</code> 。
                        </p>
                     </div>
                  </div><a id="LNOCI17052"></a><div class="props_rev_3"><a id="GUID-63C32F8A-1C45-44B0-8682-696BB9ED5550" name="GUID-63C32F8A-1C45-44B0-8682-696BB9ED5550"></a><h5 id="LNOCI-GUID-63C32F8A-1C45-44B0-8682-696BB9ED5550" class="sect5"><span class="enumeration_section">24.2.1.4</span> OUTTYPE</h5>
                     <div>
                        <p>指定outtype文件的名称。</p>
                        <p>当OTT生成C头文件时，它还将有关已翻译类型的信息写入outtype文件。此文件包含每个要转换的类型的条目，包括其版本字符串以及写入其C表示的头文件。</p>
                        <p>在<a href="using-object-type-translator-in-oci.html#GUID-9BDD90C1-B5EC-47CD-AFBB-2EA5FD9A372C__CIHBDJIB">例24-4中</a> ，outtype文件的名称被指定为<code class="codeph">demoout.typ</code> 。
                        </p>
                        <div class="infoboxnote" id="GUID-63C32F8A-1C45-44B0-8682-696BB9ED5550__GUID-2DB9C848-B2A2-40FD-A6CD-B9650639EA47">
                           <p class="notep1">注意：</p>
                           <p>如果存在由outtype关键字指定的文件，则在OTT运行时会覆盖该文件。如果outtype文件的名称与intype文件的名称相同，则outtype信息将覆盖intype文件。</p>
                        </div>
                     </div>
                  </div><a id="LNOCI17053"></a><div class="props_rev_3"><a id="GUID-E6904C65-3A81-4638-86F8-74C7944F9783" name="GUID-E6904C65-3A81-4638-86F8-74C7944F9783"></a><h5 id="LNOCI-GUID-E6904C65-3A81-4638-86F8-74C7944F9783" class="sect5"><span class="enumeration_section">24.2.1.5</span>代码</h5>
                     <div>
                        <p>指定转换的目标语言。</p>
                        <p>可以使用以下选项：</p>
                        <ul style="list-style-type:disc">
                           <li>
                              <p>C（相当于ANSI_C）</p>
                           </li>
                           <li>
                              <p>ANSI_C（ANSI C）</p>
                           </li>
                           <li>
                              <p>KR_C（适用于Kernighan＆Ritchie C）</p>
                           </li>
                        </ul>
                        <p>目前没有默认选项，因此需要此参数。</p>
                        <p>两种C方言中的结构声明都是相同的。<code class="codeph">INITFILE</code>文件中定义的初始化函数中的<code class="codeph">INITFILE</code>取决于是否使用<code class="codeph">KR_C</code> 。如果未使用<code class="codeph">INITFILE</code>选项，则所有三个选项都是等效的。
                        </p>
                     </div>
                  </div><a id="LNOCI17054"></a><div class="props_rev_3"><a id="GUID-8CBBEC6E-3417-45BE-A8D2-4E39CBB96B3A" name="GUID-8CBBEC6E-3417-45BE-A8D2-4E39CBB96B3A"></a><h5 id="LNOCI-GUID-8CBBEC6E-3417-45BE-A8D2-4E39CBB96B3A" class="sect5"><span class="enumeration_section">24.2.1.6</span> HFILE</h5>
                     <div>
                        <p>指定应将生成的结构写入的C头文件的名称。</p>
                        <p>在<a href="using-object-type-translator-in-oci.html#GUID-9BDD90C1-B5EC-47CD-AFBB-2EA5FD9A372C__CIHBDJIB">例24-4中</a> ，生成的结构存储在名为<code class="codeph">demo.h</code>的文件中。
                        </p>
                        <div class="infoboxnote" id="GUID-8CBBEC6E-3417-45BE-A8D2-4E39CBB96B3A__GUID-036CF3B0-E596-43B5-B087-7529AAA173B8">
                           <p class="notep1">注意：</p>
                           <p>如果<code class="codeph">hfile</code>关键字指定的文件存在，则在OTT运行时会被覆盖，但有一个例外：如果OTT生成的文件内容与文件的先前内容相同，则OTT实际上不会写入文件。这样可以保留文件的修改时间，以便Linux和UNIX在其他操作系统上<code class="codeph">make</code>和类似的工具不会执行不必要的重新编译。
                           </p>
                        </div>
                     </div>
                  </div><a id="LNOCI17055"></a><div class="props_rev_3"><a id="GUID-D1F48B2D-717C-4840-A791-0DAB64EBAD95" name="GUID-D1F48B2D-717C-4840-A791-0DAB64EBAD95"></a><h5 id="LNOCI-GUID-D1F48B2D-717C-4840-A791-0DAB64EBAD95" class="sect5"><span class="enumeration_section">24.2.1.7</span> INITFILE</h5>
                     <div>
                        <p>指定要在其中写入类型初始化函数的C源文件的名称。</p>
                        <div class="infoboxnote" id="GUID-D1F48B2D-717C-4840-A791-0DAB64EBAD95__GUID-206CB695-4461-4C70-AE87-A9DF41B8FCA1">
                           <p class="notep1">注意：</p>
                           <p>如果<code class="codeph">initfile</code>关键字指定的文件存在，则在OTT运行时会被覆盖，但有一个例外：如果OTT生成的文件内容与文件的先前内容相同，则OTT实际上不会写入文件。这样可以保留文件的修改时间，以便Linux和UNIX在其他操作系统上<code class="codeph">make</code>和类似的工具不会执行不必要的重新编译。
                           </p>
                        </div>
                     </div>
                  </div>
               </div>
            </div><a id="LNOCI72777"></a><a id="LNOCI17056"></a><div class="props_rev_3"><a id="GUID-7370C345-D500-4805-BDBC-B81BB1E42990" name="GUID-7370C345-D500-4805-BDBC-B81BB1E42990"></a><h3 id="LNOCI-GUID-7370C345-D500-4805-BDBC-B81BB1E42990" class="sect3"><span class="enumeration_section">24.3</span> Intype文件</h3>
               <div>
                  <p>当OTT运行时，intype文件告诉OTT应该翻译哪些数据库类型。</p>
                  <p>它还可以控制生成的结构的命名。intype文件可以是用户创建的文件，也可以是先前调用OTT的outtype文件。如果未使用<code class="codeph">intype</code>参数，则转换OTT连接的架构中的所有类型。
                  </p>
                  <p><a href="using-object-type-translator-in-oci.html#GUID-7370C345-D500-4805-BDBC-B81BB1E42990__CIHJFADB">例24-5</a>显示了一个简单的用户创建的intype文件。
                  </p>
                  <p><a href="using-object-type-translator-in-oci.html#GUID-7370C345-D500-4805-BDBC-B81BB1E42990__CIHJFADB">实施例24-5</a>进一步描述如下。
                  </p>
                  <p>带有<code class="codeph">CASE</code>关键字的第一行表示生成的C标识符应为小写。但是，此<code class="codeph">CASE</code>选项仅适用于未在intype文件中明确提及的那些标识符。因此， <code class="codeph">employee</code>和<code class="codeph">ADDRESS</code>将始终分别导致C结构<code class="codeph">employee</code>和<code class="codeph">ADDRESS</code> 。这些结构的成员将以小写命名。
                  </p>
                  <p>在以<code class="codeph">TYPE</code>关键字开头的行中，指定应翻译数据库中的哪些类型：在本例中为<code class="codeph">employee, ADDRESS, item, Person</code>和<code class="codeph">PURCHASE_ORDER</code>类型。
                  </p>
                  <p><code class="codeph">TRANSLATE ...AS</code>关键字指定在将类型转换为C结构时应更改对象属性的名称。在这种情况下，员工类型的<code class="codeph">SALARY$</code>属性将转换为<code class="codeph">salary</code> 。
                  </p>
                  <p>最后一行中的<code class="codeph">AS</code>关键字指定在将对象类型转换为结构时应更改该对象类型的名称。在这种情况下， <code class="codeph">PURCHASE_ORDER</code>数据库类型将转换为名为<code class="codeph">p_o</code>的结构。
                  </p>
                  <p>如果<code class="codeph">AS</code>不用于转换类型或属性名称，则使用类型或属性的数据库名称作为C标识符名称，但会观察<code class="codeph">CASE</code>选项，以及无法映射到合法C标识符字符的任何字符被下划线取代。翻译类型或属性名称的原因包括：</p>
                  <ul style="list-style-type:disc">
                     <li>
                        <p>该名称包含字母，数字和下划线以外的字符</p>
                     </li>
                     <li>
                        <p>该名称与C关键字冲突。</p>
                     </li>
                     <li>
                        <p>类型名称与同一范围内的另一个标识符冲突。例如，如果程序使用来自不同模式的两个具有相同名称的类型，则会发生这种情况。</p>
                     </li>
                     <li>
                        <p>程序员喜欢不同的名字。</p>
                     </li>
                  </ul>
                  <p>OTT可能需要转换未在intype文件中列出的其他类型。这是因为OTT在执行转换之前分析intype文件中的类型依赖关系类型，并根据需要转换其他类型。例如，如果intype文件中未列出<code class="codeph">ADDRESS</code>类型，但<code class="codeph">"Person"</code>类型具有<code class="codeph">ADDRESS</code>类型的属性，则OTT仍会转换<code class="codeph">ADDRESS</code>因为需要定义<code class="codeph">"Person"</code>类型。
                  </p>
                  <p>如果指定<code class="codeph">FALSE</code>作为<code class="codeph">TRANSITIVE</code>参数的值，则OTT不会生成未在intype文件中指定的类型。
                  </p>
                  <p>正常的不区分大小写的SQL标识符可以在intype文件中以大写和小写的任意组合拼写，并且不包含在引号内。</p>
                  <p>使用引号（例如<code class="codeph">TYPE</code> <code class="codeph">"Person"</code> ）来引用以区分大小写的方式创建的SQL标识符（例如， <code class="codeph">CREATE TYPE "Person"</code> ）。如果SQL标识符在声明时被括在引号内，则它区分大小写。引号也可用于引用作为OTT保留字的SQL标识符（例如， <code class="codeph">TYPE "CASE"</code> ）。因此，当名称括在引号内时，如果SQL标识符是以不区分大小写的方式创建的（例如， <code class="codeph">CREATE TYPE Case</code> ），则引号中包含的名称必须为大写。如果使用OTT保留字来引用SQL标识符的名称但未包含在引号内，则OTT会在intype文件中报告语法错误。
                  </p>
                  <div class="example" id="GUID-7370C345-D500-4805-BDBC-B81BB1E42990__CIHJFADB">
                     <p class="titleinexample">示例24-5用户创建的Intype文件的内容</p><pre class="oac_no_warn" dir="ltr">CASE = LOWER TYPE员工TRANSLATE SALARY $ AS薪水DEPTNO AS部门类型地址类型项目类型“人员”TYPE PURCHASE_ORDER as p_o</pre></div>
                  <!-- class="example" -->
                  <div class="section">
                     <p class="subhead2" id="GUID-7370C345-D500-4805-BDBC-B81BB1E42990__GUID-163209A0-39D5-4E3D-B446-C99831286A46"></p>
                     <div class="infoboxnotealso" id="GUID-7370C345-D500-4805-BDBC-B81BB1E42990__GUID-EBD77606-514C-4557-B4FC-767449CC0E31">
                        <p class="notep1">也可以看看：</p>
                        <ul style="list-style-type:disc">
                           <li>
                              <p><a href="using-object-type-translator-in-oci.html#GUID-DCB134A7-4A0F-4C91-AE55-6C05959AA60D" title="该CASE参数影响OTT生成的某些C标识符的情况。">案件</a></p>
                           </li>
                           <li>
                              <p><a href="using-object-type-translator-in-oci.html#GUID-B4E872F1-7FF7-4E44-9480-56FF8567708C" title="intype和outtype文件列出OTT翻译的类型，并提供确定如何将类型或属性名称转换为合法C标识符所需的所有信息。">Intype文件的结构，</a>用于更详细地说明intype文件的结构和可用选项</p>
                           </li>
                        </ul>
                     </div>
                  </div>
                  <!-- class="section" -->
               </div>
            </div><a id="LNOCI72778"></a><a id="LNOCI72779"></a><a id="LNOCI17057"></a><div class="props_rev_3"><a id="GUID-BB88D6B6-2048-4756-AD4E-EE1DEC3DF1C2" name="GUID-BB88D6B6-2048-4756-AD4E-EE1DEC3DF1C2"></a><h3 id="LNOCI-GUID-BB88D6B6-2048-4756-AD4E-EE1DEC3DF1C2" class="sect3"><span class="enumeration_section">24.4</span> OTT数据类型映射</h3>
               <div>
                  <p>当OTT从数据库类型生成C结构时，该结构包含一个对应于对象类型的每个属性的元素。</p>
                  <p>属性的数据类型映射到Oracle的对象数据类型中使用的类型。Oracle数据库中的数据类型包括一组预定义的原始类型。这些数据类型用于创建用户定义的类型，例如对象类型和集合。</p>
                  <p>Oracle数据库还包括一组预定义类型，用于表示C结构中的对象类型属性。例如，考虑<a href="using-object-type-translator-in-oci.html#GUID-BB88D6B6-2048-4756-AD4E-EE1DEC3DF1C2__CIHIIIJA">例24-6中</a>的对象类型定义，以及<a href="using-object-type-translator-in-oci.html#GUID-BB88D6B6-2048-4756-AD4E-EE1DEC3DF1C2__CIHCCJFD">例24-7中</a>相应的OTT生成的结构声明。
                  </p>
                  <p>假设<code class="codeph">CASE=LOWER</code>且没有类型或属性名称的显式映射的OTT输出如<a href="using-object-type-translator-in-oci.html#GUID-BB88D6B6-2048-4756-AD4E-EE1DEC3DF1C2__CIHCCJFD">例24-7</a>所示。
                  </p>
                  <p>结构声明中的数据类型<code class="codeph">OCIString</code> ， <code class="codeph">OCINumber</code> ， <code class="codeph">OCIDate</code>和<code class="codeph">OCIInd</code>用于映射对象类型属性的数据类型。例如， <code class="codeph">empno</code>属性的<code class="codeph">NUMBER</code>数据类型映射到<code class="codeph">OCINumber</code>数据类型。这些数据类型也可以用作绑定和定义变量的类型。
                  </p>
                  <div class="example" id="GUID-BB88D6B6-2048-4756-AD4E-EE1DEC3DF1C2__CIHIIIJA">
                     <p class="titleinexample">示例24-6 Employee的对象类型定义</p><pre class="oac_no_warn" dir="ltr">CREATE TYPE employee AS OBJECT（名称VARCHAR2（30），empno NUMBER，deptno NUMBER，雇用日期，工资$ NUMBER）;</pre></div>
                  <!-- class="example" -->
                  <div class="example" id="GUID-BB88D6B6-2048-4756-AD4E-EE1DEC3DF1C2__CIHCCJFD">
                     <p class="titleinexample">例24-7 OTT生成的结构声明</p><pre class="oac_no_warn" dir="ltr">struct employee {OCIString * name; OCINumber empno; OCINumber deptno; OCIDate雇用; OCINumber salary_; }; typedef struct emp_type emp_type; struct employee_ind {OCIInd _atomic; OCIInd名称; OCIInd empno; OCIInd deptno; OCIInd雇用; OCIInd salary_; } typedef struct employee_ind employee_ind;</pre></div>
                  <!-- class="example" -->
                  <div class="section">
                     <div class="p">本节包括以下主题：<ul style="list-style-type:disc">
                           <li>
                              <p><a href="using-object-type-translator-in-oci.html#GUID-FC45BE3C-C48C-427C-A60B-7B7658A42AD6" title="本节介绍Oracle对象属性类型与OTT生成的C类型的映射关系。">关于将对象数据类型映射到C</a></p>
                           </li>
                           <li>
                              <p><a href="using-object-type-translator-in-oci.html#GUID-E0A4C79C-9500-49E0-99FD-6C5D85724D23" title="显示OTT在给定数据库类型时创建的各种类型映射。">OTT类型映射示例</a></p>
                           </li>
                           <li>
                              <p><a href="using-object-type-translator-in-oci.html#GUID-4B43CFE7-39AF-4F7D-A580-0C73B6DF242D" title="每当OTT生成一个C结构来表示数据库对象类型时，它也会生成相应的NULL指示符结构。">空指标结构</a></p>
                           </li>
                           <li>
                              <p><a href="using-object-type-translator-in-oci.html#GUID-4009C803-B151-4836-AF6F-741E9F072466" title="为了支持对象的类型继承，在声明新属性之前，OTT通过在封装结构中声明具有特殊名称“_super”的继承属性来生成表示对象子类型的C结构。">OTT支持类型继承</a></p>
                           </li>
                        </ul>
                     </div>
                     <div class="infoboxnotealso" id="GUID-BB88D6B6-2048-4756-AD4E-EE1DEC3DF1C2__GUID-9083A536-5160-462A-8691-217F93591593">
                        <p class="notep1">也可以看看：</p>
                        <p><a href="using-object-type-translator-in-oci.html#GUID-4B43CFE7-39AF-4F7D-A580-0C73B6DF242D" title="Each time OTT generates a C struct to represent a database object type, it also generates a corresponding NULL indicator struct.">空指示符结构</a>用于<a href="using-object-type-translator-in-oci.html#GUID-4B43CFE7-39AF-4F7D-A580-0C73B6DF242D" title="每当OTT生成一个C结构来表示数据库对象类型时，它也会生成相应的NULL指示符结构。">指示符结构</a>的解释（ <code class="codeph">struct employee_ind</code> ）</p>
                     </div>
                  </div>
                  <!-- class="section" -->
               </div><a id="LNOCI17059"></a><a id="LNOCI17058"></a><div class="props_rev_3"><a id="GUID-FC45BE3C-C48C-427C-A60B-7B7658A42AD6" name="GUID-FC45BE3C-C48C-427C-A60B-7B7658A42AD6"></a><h4 id="LNOCI-GUID-FC45BE3C-C48C-427C-A60B-7B7658A42AD6" class="sect4"><span class="enumeration_section">24.4.1</span>关于将对象数据类型映射到C</h4>
                  <div>
                     <p>本节介绍Oracle对象属性类型与OTT生成的C类型的映射关系。</p>
                     <p>前一节<a href="using-object-type-translator-in-oci.html#GUID-E0A4C79C-9500-49E0-99FD-6C5D85724D23" title="显示OTT在给定数据库类型时创建的各种类型映射。">OTT类型映射示例</a>包括许多这些不同映射的示例。<a href="using-object-type-translator-in-oci.html#GUID-FC45BE3C-C48C-427C-A60B-7B7658A42AD6__CIHEBCFC" title="该表有3列。第1列是对象属性类型，第2列是其对应的C映射，第3列是其对应的OCITypeCode值。">表24-1</a>列出了可以用作OTT生成的对象数据类型的属性类型的映射以及相应的OCI类型代码值。
                     </p>
                     <div class="tblformalwide" id="GUID-FC45BE3C-C48C-427C-A60B-7B7658A42AD6__CIHEBCFC">
                        <p class="titleintable">表24-1对象类型属性的对象数据类型映射</p>
                        <table cellpadding="4" cellspacing="0" class="FormalWide" title="对象类型属性的对象数据类型映射" width="100%" border="1" summary="This table has 3 columns. Column 1 is the object attribute type, column 2 is its corresponding C mapping, and column 3 is its corresponding OCITypeCode value." frame="hsides" rules="rows">
                           <thead>
                              <tr align="left" valign="top">
                                 <th align="left" valign="bottom" id="d173568e4352">对象属性类型</th>
                                 <th align="left" valign="bottom" id="d173568e4355">C映射</th>
                                 <th align="left" valign="bottom" id="d173568e4358">OCITypeCode值</th>
                              </tr>
                           </thead>
                           <tbody>
                              <tr align="left" valign="top">
                                 <td align="left" valign="top" id="d173568e4362" headers="d173568e4352 ">
                                    <p><span>BFILE</span></p>
                                 </td>
                                 <td align="left" valign="top" headers="d173568e4362 d173568e4355 ">
                                    <p>OCIBFileLocator *</p>
                                 </td>
                                 <td align="left" valign="top" headers="d173568e4362 d173568e4358 ">OCI_TYPECODE_BFILE</td>
                              </tr>
                              <tr align="left" valign="top">
                                 <td align="left" valign="top" id="d173568e4372" headers="d173568e4352 ">
                                    <p>BLOB</p>
                                 </td>
                                 <td align="left" valign="top" headers="d173568e4372 d173568e4355 ">
                                    <p>OCILobLocator *或OCIBlobLocator *</p>
                                 </td>
                                 <td align="left" valign="top" headers="d173568e4372 d173568e4358 ">OCI_TYPECODE_BLOB</td>
                              </tr>
                              <tr align="left" valign="top">
                                 <td align="left" valign="top" id="d173568e4381" headers="d173568e4352 ">
                                    <p>CHAR（N），CHARACTER（N），NCHAR（N）</p>
                                 </td>
                                 <td align="left" valign="top" headers="d173568e4381 d173568e4355 ">
                                    <p>OCIString *</p>
                                 </td>
                                 <td align="left" valign="top" headers="d173568e4381 d173568e4358 ">OCI_TYPECODE_CHAR（n），OCI_TYPECODE_NCHAR</td>
                              </tr>
                              <tr align="left" valign="top">
                                 <td align="left" valign="top" id="d173568e4390" headers="d173568e4352 ">
                                    <p>CLOB，NCLOB</p>
                                 </td>
                                 <td align="left" valign="top" headers="d173568e4390 d173568e4355 ">
                                    <p>OCILobLocator *或OCIClobLocator *</p>
                                 </td>
                                 <td align="left" valign="top" headers="d173568e4390 d173568e4358 ">OCI_TYPECODE_CLOB，OCI_TYPECODE_NCLOB</td>
                              </tr>
                              <tr align="left" valign="top">
                                 <td align="left" valign="top" id="d173568e4399" headers="d173568e4352 ">
                                    <p>日期</p>
                                 </td>
                                 <td align="left" valign="top" headers="d173568e4399 d173568e4355 ">
                                    <p>OCIDate</p>
                                 </td>
                                 <td align="left" valign="top" headers="d173568e4399 d173568e4358 ">OCI_TYPECODE_DATE</td>
                              </tr>
                              <tr align="left" valign="top">
                                 <td align="left" valign="top" id="d173568e4408" headers="d173568e4352 ">
                                    <p>ANSI日期</p>
                                 </td>
                                 <td align="left" valign="top" headers="d173568e4408 d173568e4355 ">
                                    <p>OCIDateTime *</p>
                                 </td>
                                 <td align="left" valign="top" headers="d173568e4408 d173568e4358 ">OCI_TYPECODE_TIMESTAMP</td>
                              </tr>
                              <tr align="left" valign="top">
                                 <td align="left" valign="top" id="d173568e4417" headers="d173568e4352 ">
                                    <p>TIMESTAMP，TIMESTAMP与时区，TIMESTAMP与当地时区</p>
                                 </td>
                                 <td align="left" valign="top" headers="d173568e4417 d173568e4355 ">
                                    <p>OCIDateTime *</p>
                                 </td>
                                 <td align="left" valign="top" headers="d173568e4417 d173568e4358 ">OCI_TYPECODE_TIMESTAMP，OCI_TYPECODE_TIMESTAMP_TZ，OCI_TYPECODE_TIMESTAMP_LTZ</td>
                              </tr>
                              <tr align="left" valign="top">
                                 <td align="left" valign="top" id="d173568e4426" headers="d173568e4352 ">
                                    <p>间隔年至月，间隔日至第二季</p>
                                 </td>
                                 <td align="left" valign="top" headers="d173568e4426 d173568e4355 ">
                                    <p>OCIInterval *</p>
                                 </td>
                                 <td align="left" valign="top" headers="d173568e4426 d173568e4358 ">OCI_TYPECODE_INTERVAL_YM，OCI_TYPECODE_INTERVAL_DS</td>
                              </tr>
                              <tr align="left" valign="top">
                                 <td align="left" valign="top" id="d173568e4435" headers="d173568e4352 ">
                                    <p>DEC，DEC（N），DEC（N，N）</p>
                                 </td>
                                 <td align="left" valign="top" headers="d173568e4435 d173568e4355 ">
                                    <p>OCINumber</p>
                                 </td>
                                 <td align="left" valign="top" headers="d173568e4435 d173568e4358 ">OCI_TYPECODE_DECIMAL（p）</td>
                              </tr>
                              <tr align="left" valign="top">
                                 <td align="left" valign="top" id="d173568e4444" headers="d173568e4352 ">
                                    <p>DECIMAL，DECIMAL（N），DECIMAL（N，N）</p>
                                 </td>
                                 <td align="left" valign="top" headers="d173568e4444 d173568e4355 ">
                                    <p>OCINumber</p>
                                 </td>
                                 <td align="left" valign="top" headers="d173568e4444 d173568e4358 ">OCI_TYPECODE_DECIMAL（p）</td>
                              </tr>
                              <tr align="left" valign="top">
                                 <td align="left" valign="top" id="d173568e4453" headers="d173568e4352 ">
                                    <p>FLOAT，FLOAT（N），双精度</p>
                                 </td>
                                 <td align="left" valign="top" headers="d173568e4453 d173568e4355 ">
                                    <p>OCINumber</p>
                                 </td>
                                 <td align="left" valign="top" headers="d173568e4453 d173568e4358 ">OCI_TYPECODE_FLOAT（b）</td>
                              </tr>
                              <tr align="left" valign="top">
                                 <td align="left" valign="top" id="d173568e4463" headers="d173568e4352 ">
                                    <p>BINARY_FLOAT</p>
                                 </td>
                                 <td align="left" valign="top" headers="d173568e4463 d173568e4355 ">
                                    <p>浮动</p>
                                 </td>
                                 <td align="left" valign="top" headers="d173568e4463 d173568e4358 ">OCI_TYPECODE_BFLOAT</td>
                              </tr>
                              <tr align="left" valign="top">
                                 <td align="left" valign="top" id="d173568e4472" headers="d173568e4352 ">
                                    <p>BINARY_DOUBLE</p>
                                 </td>
                                 <td align="left" valign="top" headers="d173568e4472 d173568e4355 ">
                                    <p>双</p>
                                 </td>
                                 <td align="left" valign="top" headers="d173568e4472 d173568e4358 ">OCI_TYPECODE_BDOUBLE</td>
                              </tr>
                              <tr align="left" valign="top">
                                 <td align="left" valign="top" id="d173568e4481" headers="d173568e4352 ">
                                    <p>INT，INTEGER，SMALLINT</p>
                                 </td>
                                 <td align="left" valign="top" headers="d173568e4481 d173568e4355 ">
                                    <p>OCINumber</p>
                                 </td>
                                 <td align="left" valign="top" headers="d173568e4481 d173568e4358 ">OCI_TYPECODE_INTEGER，OCI_TYPECODE_SMALLINT</td>
                              </tr>
                              <tr align="left" valign="top">
                                 <td align="left" valign="top" id="d173568e4490" headers="d173568e4352 ">
                                    <p>嵌套对象类型</p>
                                 </td>
                                 <td align="left" valign="top" headers="d173568e4490 d173568e4355 ">
                                    <p>嵌套对象类型的C名称</p>
                                 </td>
                                 <td align="left" valign="top" headers="d173568e4490 d173568e4358 ">OCI_TYPECODE_OBJECT</td>
                              </tr>
                              <tr align="left" valign="top">
                                 <td align="left" valign="top" id="d173568e4499" headers="d173568e4352 ">
                                    <p>嵌套表</p>
                                 </td>
                                 <td align="left" valign="top" headers="d173568e4499 d173568e4355 ">
                                    <p>OCITable *</p>
                                 </td>
                                 <td align="left" valign="top" headers="d173568e4499 d173568e4358 ">OCI_TYPECODE_TABLE</td>
                              </tr>
                              <tr align="left" valign="top">
                                 <td align="left" valign="top" id="d173568e4508" headers="d173568e4352 ">
                                    <p>NUMBER，NUMBER（N），NUMBER（N，N）</p>
                                 </td>
                                 <td align="left" valign="top" headers="d173568e4508 d173568e4355 ">
                                    <p>OCINumber</p>
                                 </td>
                                 <td align="left" valign="top" headers="d173568e4508 d173568e4358 ">OCI_TYPECODE_NUMBER（p，s）</td>
                              </tr>
                              <tr align="left" valign="top">
                                 <td align="left" valign="top" id="d173568e4517" headers="d173568e4352 ">
                                    <p>NUMERIC，NUMERIC（N），NUMERIC（N，N）</p>
                                 </td>
                                 <td align="left" valign="top" headers="d173568e4517 d173568e4355 ">
                                    <p>OCINumber</p>
                                 </td>
                                 <td align="left" valign="top" headers="d173568e4517 d173568e4358 ">OCI_TYPECODE_NUMBER（p，s）</td>
                              </tr>
                              <tr align="left" valign="top">
                                 <td align="left" valign="top" id="d173568e4526" headers="d173568e4352 ">
                                    <p>RAW（N）</p>
                                 </td>
                                 <td align="left" valign="top" headers="d173568e4526 d173568e4355 ">
                                    <p>OCIRaw *</p>
                                 </td>
                                 <td align="left" valign="top" headers="d173568e4526 d173568e4358 ">OCI_TYPECODE_RAW</td>
                              </tr>
                              <tr align="left" valign="top">
                                 <td align="left" valign="top" id="d173568e4535" headers="d173568e4352 ">
                                    <p>真实</p>
                                 </td>
                                 <td align="left" valign="top" headers="d173568e4535 d173568e4355 ">
                                    <p>OCINumber</p>
                                 </td>
                                 <td align="left" valign="top" headers="d173568e4535 d173568e4358 ">OCI_TYPECODE_REAL</td>
                              </tr>
                              <tr align="left" valign="top">
                                 <td align="left" valign="top" id="d173568e4544" headers="d173568e4352 ">
                                    <p>REF</p>
                                 </td>
                                 <td align="left" valign="top" headers="d173568e4544 d173568e4355 ">
                                    <p>OCIRef *</p>
                                 </td>
                                 <td align="left" valign="top" headers="d173568e4544 d173568e4358 ">OCI_TYPECODE_REF</td>
                              </tr>
                              <tr align="left" valign="top">
                                 <td align="left" valign="top" id="d173568e4553" headers="d173568e4352 ">
                                    <p>VARCHAR（N）</p>
                                 </td>
                                 <td align="left" valign="top" headers="d173568e4553 d173568e4355 ">
                                    <p>OCIString *</p>
                                 </td>
                                 <td align="left" valign="top" headers="d173568e4553 d173568e4358 ">OCI_TYPECODE_VARCHAR（n）</td>
                              </tr>
                              <tr align="left" valign="top">
                                 <td align="left" valign="top" id="d173568e4563" headers="d173568e4352 ">
                                    <p>VARCHAR2（N），NVARCHAR2（N）</p>
                                 </td>
                                 <td align="left" valign="top" headers="d173568e4563 d173568e4355 ">
                                    <p>OCIString *</p>
                                 </td>
                                 <td align="left" valign="top" headers="d173568e4563 d173568e4358 ">OCI_TYPECODE_VARCHAR2（n），OCI_TYPECODE_NVARCHAR2</td>
                              </tr>
                              <tr align="left" valign="top">
                                 <td align="left" valign="top" id="d173568e4572" headers="d173568e4352 ">
                                    <p><a id="d173568e4574" class="indexterm-anchor"></a> VARRAY</p>
                                 </td>
                                 <td align="left" valign="top" headers="d173568e4572 d173568e4355 ">
                                    <p>OCIArray *</p>
                                 </td>
                                 <td align="left" valign="top" headers="d173568e4572 d173568e4358 ">OCI_TYPECODE_VARRAY</td>
                              </tr>
                              <tr align="left" valign="top">
                                 <td align="left" valign="top" id="d173568e4585" headers="d173568e4352 ">集合</td>
                                 <td align="left" valign="top" headers="d173568e4585 d173568e4355 ">OCIColl *</td>
                                 <td align="left" valign="top" headers="d173568e4585 d173568e4358 ">OCI_TYPECODE_NAMEDCOLLECTION</td>
                              </tr>
                           </tbody>
                        </table>
                     </div>
                     <!-- class="inftblhruleinformal" -->
                     <div class="infoboxnote" id="GUID-FC45BE3C-C48C-427C-A60B-7B7658A42AD6__GUID-AAB83492-18E5-4E71-9438-042BD5D162F2">
                        <p class="notep1">注意：</p>
                        <p>对于<code class="codeph">REF</code> ， <code class="codeph">varray</code>和<code class="codeph">nested table</code>类型，OTT生成一个typedef。然后，在typedef中声明的类型将用作struct声明中数据成员的类型。有关示例，请参阅<a href="using-object-type-translator-in-oci.html#GUID-E0A4C79C-9500-49E0-99FD-6C5D85724D23" title="显示OTT在给定数据库类型时创建的各种类型映射。">OTT类型映射示例</a> 。
                        </p>
                     </div>
                     <p>如果对象类型包括的属性<code class="codeph">REF</code>或集合类型，对于一个typedef <code class="codeph">REF</code>首先产生或收集的类型。然后生成对应于对象类型的struct声明。该struct包含一个元素，其类型是指向<code class="codeph">REF</code>或集合类型的指针。
                     </p>
                     <p>如果对象类型包含其类型为另一种对象类型的属性，则OTT首先生成嵌套类型（如果<code class="codeph">TRANSITIVE=TRUE</code> ）。然后，它将对象类型属性映射到嵌套对象类型的嵌套结构。
                     </p>
                     <p>OTT映射非对象数据库属性类型的Oracle C数据类型是结构，除<code class="codeph">OCIDate</code> ，它们是不透明的。
                     </p>
                  </div>
               </div><a id="LNOCI72780"></a><a id="LNOCI72781"></a><a id="LNOCI17060"></a><div class="props_rev_3"><a id="GUID-E0A4C79C-9500-49E0-99FD-6C5D85724D23" name="GUID-E0A4C79C-9500-49E0-99FD-6C5D85724D23"></a><h4 id="LNOCI-GUID-E0A4C79C-9500-49E0-99FD-6C5D85724D23" class="sect4"><span class="enumeration_section">24.4.2</span> OTT类型映射示例</h4>
                  <div>
                     <p>显示OTT在给定数据库类型时创建的各种类型映射。</p>
                     <div class="section">
                        <p><a href="using-object-type-translator-in-oci.html#GUID-E0A4C79C-9500-49E0-99FD-6C5D85724D23__CIHCBFIH">例24-9</a>演示了给定<a href="using-object-type-translator-in-oci.html#GUID-E0A4C79C-9500-49E0-99FD-6C5D85724D23__CIHJBHGE">示例24-8中</a>所示的数据库类型时OTT创建的各种类型映射。
                        </p>
                        <p>intype文件包括以下内容：</p><pre class="oac_no_warn" dir="ltr">CASE = LOWER TYPE many_types</pre><p>OTT生成<a href="using-object-type-translator-in-oci.html#GUID-E0A4C79C-9500-49E0-99FD-6C5D85724D23__CIHCBFIH">例24-9中</a>所示的C结构。
                        </p>
                        <div class="infoboxnote" id="GUID-E0A4C79C-9500-49E0-99FD-6C5D85724D23__GUID-384C917E-F6D2-4DB2-BB0A-D1F7B1D3EE65">
                           <p class="notep1">注意：</p>
                           <p><a href="using-object-type-translator-in-oci.html#GUID-E0A4C79C-9500-49E0-99FD-6C5D85724D23__CIHCBFIH">例24-9</a>中提供了注释，以帮助解释结构。这些注释不是实际OTT输出的一部分。
                           </p>
                        </div>
                        <p>请注意，尽管在intype文件中仅列出了一个要翻译的项目，但是已翻译了两个对象类型和两个命名的集合类型。这是因为OTT参数<code class="codeph">TRANSITIVE</code>的默认值为<code class="codeph">TRUE</code> 。如该部分所述，当<code class="codeph">TRANSITIVE=TRUE</code> ，OTT自动翻译用作被翻译类型属性的任何类型，以完成所列类型的翻译。
                        </p>
                        <p>对于仅由对象类型属性中的指针或<code class="codeph">REF</code>访问的类型，情况并非如此。例如，尽管<code class="codeph">many_types</code>类型包含属性<code class="codeph">another_ref REF other_type</code> ，但未生成struct <code class="codeph">other_type</code>的声明。
                        </p>
                        <p>此示例还说明了typedef如何用于声明<code class="codeph">varray, nested table</code>和<code class="codeph">REF</code>类型。
                        </p>
                        <p>typedef出现在开头附近：</p><pre class="oac_no_warn" dir="ltr">typedef OCIRef many_types_ref; typedef OCIRef object_type_ref; typedef OCIArray my_varray; typedef OCITable my_table; typedef OCIRef other_type_ref;</pre><p>在struct <code class="codeph">many_types</code> ，声明了<code class="codeph">varray, nested table</code>和<code class="codeph">REF</code>属性：</p><pre class="oac_no_warn" dir="ltr">struct many_types {...other_type_ref * another_ref; many_types_ref * the_ref; my_varray * the_varray; my_table * the_table; ...}</pre></div>
                     <!-- class="section" -->
                     <div class="example" id="GUID-E0A4C79C-9500-49E0-99FD-6C5D85724D23__CIHJBHGE">
                        <p class="titleinexample">示例24-8 OTT类型映射示例的对象类型定义</p><pre class="oac_no_warn" dir="ltr">CREATE TYPE my_varray AS VARRAY（5）的整数; CREATE TYPE object_type AS OBJECT（object_name VARCHAR2（20））; CREATE TYPE my_table AS TABLE OF object_type; CREATE TYPE other_type AS OBJECT（object_number NUMBER）; CREATE TYPE many_types AS OBJECT（the_varchar VARCHAR2（30），the_char CHAR（3），the_blob BLOB，the_clob CLOB，the_object object_type，another_ref REF other_type，the_ref REF many_types，the_varray my_varray，the_table my_table，the_date DATE，the_num NUMBER，the_raw RAW（ 255））;</pre></div>
                     <!-- class="example" -->
                     <div class="example" id="GUID-E0A4C79C-9500-49E0-99FD-6C5D85724D23__CIHCBFIH">
                        <p class="titleinexample">例24-9 OTT根据对象类型定义创建的各种类型映射</p><pre class="oac_no_warn" dir="ltr">#ifndef MYFILENAME_ORACLE #define MYFILENAME_ORACLE #ifndef OCI_ORACLE #include &lt;oci.h&gt; #endif typedef OCIRef many_types_ref; typedef OCIRef object_type_ref; typedef OCIArray my_varray; / *用于many_types * / typedef OCITable my_table; / *用于many_types * / typedef OCIRef other_type_ref; struct object_type / *用于many_types * / {OCIString * object_name; }; typedef struct object_type object_type; struct object_type_ind / *指示符结构，用于* / {/ * object_types * / OCIInd _atomic; OCIInd object_name; }; typedef struct object_type_ind object_type_ind; struct many_types {OCIString * the_varchar; OCIString * the_char; OCIBlobLocator * the_blob; OCIClobLocator * the_clob; struct object_type the_object; other_type_ref * another_ref; many_types_ref * the_ref; my_varray * the_varray; my_table * the_table; OCIDate the_date; OCINumber the_num; OCIRaw * the_raw; }; typedef struct many_types many_types; struct many_types_ind / *指示符结构，用于* / {/ * many_types * / OCIInd _atomic; OCIInd the_varchar; OCIInd the_char; OCIInd the_blob; OCIInd the_clob; struct object_type_ind the_object; / *嵌套* / OCIInd another_ref; OCIInd the_ref; OCIInd the_varray; OCIInd the_table; OCIInd the_date; OCIInd the_num; OCIInd the_raw; }; typedef struct many_types_ind many_types_ind; ＃万一</pre></div>
                     <!-- class="example" -->
                     <div class="section">
                        <div class="infoboxnotealso" id="GUID-E0A4C79C-9500-49E0-99FD-6C5D85724D23__GUID-28A454D1-AA6C-4DA3-9948-80E0B018A3DB">
                           <p class="notep1">也可以看看：</p>
                           <p><a href="using-object-type-translator-in-oci.html#GUID-D52FC80C-CA51-4638-AEB8-8F112982DB31" title="TRANSITIVE参数的值为TRUE（默认值）或FALSE。">传递性</a></p>
                        </div>
                     </div>
                     <!-- class="section" -->
                  </div>
               </div><a id="LNOCI17061"></a><div class="props_rev_3"><a id="GUID-4B43CFE7-39AF-4F7D-A580-0C73B6DF242D" name="GUID-4B43CFE7-39AF-4F7D-A580-0C73B6DF242D"></a><h4 id="LNOCI-GUID-4B43CFE7-39AF-4F7D-A580-0C73B6DF242D" class="sect4"><span class="enumeration_section">24.4.3</span>空指示符结构</h4>
                  <div>
                     <p>每当OTT生成一个C结构来表示数据库对象类型时，它也会生成相应的<code class="codeph">NULL</code>指示符结构。
                     </p>
                     <p>当将对象类型选择到C结构中时，可以将<code class="codeph">NULL</code>指示符信息选择为并行结构。
                     </p>
                     <p>例如，在<a href="using-object-type-translator-in-oci.html#GUID-E0A4C79C-9500-49E0-99FD-6C5D85724D23__CIHCBFIH">例24-9</a>中生成了以下<code class="codeph">NULL</code>指示符结构。
                     </p><pre class="oac_no_warn" dir="ltr">struct many_types_ind {OCIInd _atomic; OCIInd the_varchar; OCIInd the_char; OCIInd the_blob; OCIInd the_clob; struct object_type_ind the_object; OCIInd another_ref; OCIInd the_ref; OCIInd the_varray; OCIInd the_table; OCIInd the_date; OCIInd the_num; OCIInd the_raw; }; typedef struct many_types_ind many_types_ind;</pre><p><code class="codeph">NULL</code>结构的布局很重要。struct（ <code class="codeph">_atomic</code> ）中的第一个元素是<span class="italic">原子空指示符</span> 。此值指示整个对象类型的<code class="codeph">NULL</code>状态。原子空指示符之后是对应于OTT生成的结构中表示对象类型的每个元素的指示符元素。
                     </p>
                     <p>请注意，当对象类型包含另一个对象类型作为其定义的一部分时（在前面的示例中，它是<code class="codeph">object_type</code>属性），该属性的指示符条目是与嵌套对象类型对应的<code class="codeph">NULL</code>指示符struct（ <code class="codeph">object_type_ind</code> ）（如果是<code class="codeph">TRANSITIVE=TRUE</code> ）。
                     </p>
                     <p><code class="codeph">varrays</code>和<code class="codeph">nested tables</code>包含其元素的<code class="codeph">NULL</code>信息。
                     </p>
                     <p><code class="codeph">NULL</code>指示符结构的所有其他元素的数据类型是<code class="codeph">OCIInd</code> 。</p>
                     <div class="infoboxnotealso" id="GUID-4B43CFE7-39AF-4F7D-A580-0C73B6DF242D__GUID-F10EF902-F6C8-467A-94B3-88B7CC65E800">
                        <p class="notep1">也可以看看：</p>
                        <p><a href="oci-object-relational-programming.html#GUID-D0FD9D2E-DAE1-4468-B90A-DE19B03CB0F3" title="如果数据库表的行中的列没有值，则该列称为NULL，或者包含NULL。">NULL指示器结构</a>有关原子无效的更多信息</p>
                     </div>
                  </div>
               </div><a id="LNOCI72782"></a><a id="LNOCI72783"></a><a id="LNOCI72784"></a><a id="LNOCI17062"></a><div class="props_rev_3"><a id="GUID-4009C803-B151-4836-AF6F-741E9F072466" name="GUID-4009C803-B151-4836-AF6F-741E9F072466"></a><h4 id="LNOCI-GUID-4009C803-B151-4836-AF6F-741E9F072466" class="sect4"><span class="enumeration_section">24.4.4</span>类型继承的OTT支持</h4>
                  <div>
                     <p>为了支持对象的类型继承，在声明新属性之前，OTT通过在封装结构中声明具有特殊名称“ <code class="codeph">_super</code> ”的继承属性来生成表示对象子类型的C结构。
                     </p>
                     <p>因此，对于从超类型继承的对象子类型，结构中的第一个元素名为“ <code class="codeph">_super</code> ”，后跟与子类型的每个属性对应的元素。名为“ <code class="codeph">_super</code> ”的元素的类型是超类型的名称。
                     </p>
                     <p>例如，假设您的类型为<code class="codeph">Person_t</code> ，子类型为<code class="codeph">Student_t</code> ，子类型为<code class="codeph">Employee_t</code> ，如<a href="using-object-type-translator-in-oci.html#GUID-4009C803-B151-4836-AF6F-741E9F072466__CIHDFCFH">例24-10</a>所示。
                     </p>
                     <p>假设您还有一个intype文件，其内容如<a href="using-object-type-translator-in-oci.html#GUID-4009C803-B151-4836-AF6F-741E9F072466__CIHBJEBC">例24-11</a>所示。
                     </p>
                     <p>然后，OTT为<code class="codeph">Person_t</code> ， <code class="codeph">Student_t</code>和<code class="codeph">Employee_t</code>生成C结构，并为其<code class="codeph">NULL</code>指示符结构生成，如<a href="using-object-type-translator-in-oci.html#GUID-4009C803-B151-4836-AF6F-741E9F072466__CIHCBDGA">例24-12</a>所示。
                     </p>
                     <p>前面的C映射约定允许从子类型的实例到C中的超类型的实例的简单向上转换以正常工作。例如：</p><pre class="oac_no_warn" dir="ltr">STUDENT_T * stu_ptr = some_ptr; / *一些STUDENT_T实例* / PERSON_T * pers_ptr =（PERSON_T *）stu_ptr; / * upcasting * /</pre><p><code class="codeph">NULL</code>指示符结构类似地生成。请注意，对于超类型<code class="codeph">Person_t</code> <code class="codeph">NULL</code>指示符结构，第一个元素是“ <code class="codeph">_atomic</code> ”，而对于子类型<code class="codeph">Employee_t</code>和<code class="codeph">Student_t</code> <code class="codeph">NULL</code>指示符结构，第一个元素是“ <code class="codeph">_super</code> ”（没有为子类型生成原子元素）。
                     </p>
                     <div class="example" id="GUID-4009C803-B151-4836-AF6F-741E9F072466__CIHDFCFH">
                        <p class="titleinexample">示例24-10对象类型和子类型定义</p><pre class="oac_no_warn" dir="ltr">CREATE TYPE Person_t AS OBJECT（ssn NUMBER，name VARCHAR2（30），address VARCHAR2（100））NOT FINAL; CREATE TYPE Student_t UNDER Person_t（deptid NUMBER，major VARCHAR2（30））NOT FINAL; CREATE TYPE Employee_t UNDER Person_t（empid NUMBER，mgr VARCHAR2（30））;</pre></div>
                     <!-- class="example" -->
                     <div class="example" id="GUID-4009C803-B151-4836-AF6F-741E9F072466__CIHBJEBC">
                        <p class="titleinexample">例24-11 Intype文件的内容</p><pre class="oac_no_warn" dir="ltr">案例=同一类型员工_T型学生_TTYPE PERSON_T</pre></div>
                     <!-- class="example" -->
                     <div class="example" id="GUID-4009C803-B151-4836-AF6F-741E9F072466__CIHCBDGA">
                        <p class="titleinexample">例24-12 OTT为类型和空指示符结构生成C结构</p><pre class="oac_no_warn" dir="ltr">#ifndef MYFILENAME_ORACLE #define MYFILENAME_ORACLE #ifndef OCI_ORACLE #include &lt;oci.h&gt; #endif typedef OCIRef EMPLOYEE_T_ref; typedef OCIRef STUDENT_T_ref; typedef OCIRef PERSON_T_ref; struct PERSON_T {OCINumber SSN; OCIString * NAME; OCIString * ADDRESS; }; typedef struct PERSON_T PERSON_T; struct PERSON_T_ind {OCIInd _atomic; OCIInd SSN; OCIInd NAME; OCIInd ADDRESS; }; typedef struct PERSON_T_ind PERSON_T_ind; struct EMPLOYEE_T {PERSON_T_ind; OCINumber EMPID; OCIString * MGR; }; typedef struct EMPLOYEE_T EMPLOYEE_T; struct EMPLOYEE_T_ind {PERSON_T _super; OCIInd EMPID; OCIInd MGR; }; typedef struct EMPLOYEE_T_ind EMPLOYEE_T_ind; struct STUDENT_T {PERSON_T _super; OCINumber DEPTID; OCIString * MAJOR; }; typedef struct STUDENT_T STUDENT_T; struct STUDENT_T_ind {PERSON_T _super; OCIInd DEPTID; OCIInd MAJOR; }; typedef struct STUDENT_T_ind STUDENT_T_ind; ＃万一</pre></div>
                     <!-- class="example" -->
                     <div class="section">
                        <p>本节包括以下主题：可<a href="using-object-type-translator-in-oci.html#GUID-82611BF8-CF4C-48F6-AF6E-E52B960DF36D" title="对于NOT FINAL类型的属性（可能是可替换的），embedded属性表示为指针。">替换对象属性</a> 。
                        </p>
                     </div>
                     <!-- class="section" -->
                  </div><a id="LNOCI17063"></a><div class="props_rev_3"><a id="GUID-82611BF8-CF4C-48F6-AF6E-E52B960DF36D" name="GUID-82611BF8-CF4C-48F6-AF6E-E52B960DF36D"></a><h5 id="LNOCI-GUID-82611BF8-CF4C-48F6-AF6E-E52B960DF36D" class="sect5"><span class="enumeration_section">24.4.4.1可</span>替换对象属性</h5>
                     <div>
                        <p>对于<code class="codeph">NOT FINAL</code>类型的属性（可能是可替换的），embedded属性表示为指针。
                        </p>
                        <p>考虑如下创建的<code class="codeph">Book_t</code>类型：</p><pre class="oac_no_warn" dir="ltr">CREATE TYPE Book_t AS OBJECT（标题VARCHAR2（30），作者Person_t / * substitutable * /）;</pre><p>OTT生成的相应C结构包含指向<code class="codeph">Person_t</code>的指针：</p><pre class="oac_no_warn" dir="ltr">struct Book_t {OCIString * title; Person_t *作者; / *指向Person_t struct * /}的指针</pre><p>与前一类型对应的<code class="codeph">NULL</code>指示符结构如下：</p><pre class="oac_no_warn" dir="ltr">struct Book_t_ind {OCIInd _atomic; OCIInd头衔; OCIInd作者; }</pre><p>请注意，可以从<code class="codeph">author</code>对象本身获取与<code class="codeph">author</code>属性对应的<code class="codeph">NULL</code>指示符结构。请参阅<code class="codeph">OCIObjectGetInd()</code> 。
                        </p>
                        <p>如果将类型定义为<code class="codeph">FINAL</code> ，则它不能具有任何子类型。因此， <code class="codeph">FINAL</code>类型的属性不可替代。在这种情况下，映射与以前一样：属性struct是内联的。现在，如果类型被更改并定义为<code class="codeph">NOT FINAL</code> ，则映射必须更改。通过再次运行OTT生成新映射。
                        </p>
                        <div class="infoboxnotealso" id="GUID-82611BF8-CF4C-48F6-AF6E-E52B960DF36D__GUID-3EE8E732-9958-42EC-8F25-6FC80A8BECE7">
                           <p class="notep1">也可以看看：</p>
                           <p><a href="oci-miscellaneous-object-functions.html#GUID-22B229C0-369E-453E-A8D6-C7F7DBB1E80C" title="检索独立实例的NULL指示符结构。">OCIObjectGetInd（）</a></p>
                        </div>
                     </div>
                  </div>
               </div>
            </div><a id="LNOCI72785"></a><a id="LNOCI72786"></a><a id="LNOCI17064"></a><div class="props_rev_3"><a id="GUID-77133295-EB6F-4B0D-81BE-2B7C117123A0" name="GUID-77133295-EB6F-4B0D-81BE-2B7C117123A0"></a><h3 id="LNOCI-GUID-77133295-EB6F-4B0D-81BE-2B7C117123A0" class="sect3"><span class="enumeration_section">24.5</span> Outtype文件</h3>
               <div>
                  <p>outtype文件在OTT命令行上命名。</p>
                  <p>当OTT生成C头文件时，它还会将转换结果写入outtype文件。此文件包含每个要转换的类型的条目，包括其版本字符串以及写入其C表示的头文件。</p>
                  <p>来自一个OTT运行的outtype文件可以用作后续OTT调用的intype文件。</p>
                  <p>例如，假设您有一个简单的intype文件，如<a href="using-object-type-translator-in-oci.html#GUID-77133295-EB6F-4B0D-81BE-2B7C117123A0__CIHBIJAH">例24-13</a>所示，它在<a href="using-object-type-translator-in-oci.html#GUID-7370C345-D500-4805-BDBC-B81BB1E42990__CIHJFADB">例24-5中使用</a> 。
                  </p>
                  <p>用户已选择为OTT生成的C标识符指定大小写，并提供了要翻译的类型列表。在其中两种类型中，指定了命名约定。</p>
                  <p><a href="using-object-type-translator-in-oci.html#GUID-77133295-EB6F-4B0D-81BE-2B7C117123A0__CIHFHCAJ">例24-14</a>显示了运行OTT后outtype文件的外观。</p>
                  <p>检查outtype文件的内容时，您可能会发现列出的类型未包含在intype规范中。例如，假设intype文件仅指定要按如下方式翻译<code class="codeph">person</code>类型：</p><pre class="oac_no_warn" dir="ltr">案例=较低级别的人</pre><p>但是，由于<code class="codeph">person</code>类型的定义包括<code class="codeph">address</code>类型的属性，因此outtype文件包括<code class="codeph">PERSON</code>和<code class="codeph">ADDRESS</code>条目。如果没有首先翻译<code class="codeph">address</code>则无法完全翻译<code class="codeph">person</code>类型。
                  </p>
                  <p>当参数<code class="codeph">TRANSITIVE</code>设置为<code class="codeph">TRUE</code> （默认值）时，OTT会在执行转换之前分析intype文件中的类型依赖关系类型，并根据需要转换其他类型。
                  </p>
                  <div class="example" id="GUID-77133295-EB6F-4B0D-81BE-2B7C117123A0__CIHBIJAH">
                     <p class="titleinexample">例24-13 Intype文件的内容</p><pre class="oac_no_warn" dir="ltr">CASE = LOWER TYPE员工TRANSLATE SALARY $ AS薪水DEPTNO AS部门类型地址类型项目类型“人员”TYPE PURCHASE_ORDER as p_o</pre></div>
                  <!-- class="example" -->
                  <div class="example" id="GUID-77133295-EB6F-4B0D-81BE-2B7C117123A0__CIHFHCAJ">
                     <p class="titleinexample">例24-14运行OTT后Outtype文件的内容</p><pre class="oac_no_warn" dir="ltr">CASE = LOWER TYPE EMPLOYEE AS员工VERSION =“$ 8.0”HFILE = demo.h TRANSLATE SALARY $ AS薪水DEPTNO AS部门类型地址作为地址VERSION =“$ 8.0”HFILE = demo.h类型项目为VERSION =“$ 8.0”HFILE = demo.h TYPE“Person”AS Person VERSION =“$ 8.0”HFILE = demo.h TYPE PURCHASE_ORDER as p_o VERSION =“$ 8.0”HFILE = demo.h</pre></div>
                  <!-- class="example" -->
               </div>
            </div><a id="LNOCI17066"></a><a id="LNOCI17065"></a><div class="props_rev_3"><a id="GUID-D35CDFD1-8F5A-46D2-BC52-FD6B4A4D4F25" name="GUID-D35CDFD1-8F5A-46D2-BC52-FD6B4A4D4F25"></a><h3 id="LNOCI-GUID-D35CDFD1-8F5A-46D2-BC52-FD6B4A4D4F25" class="sect3"><span class="enumeration_section">24.6</span>关于将OTT与OCI应用程序一起使用</h3>
               <div>
                  <p>访问Oracle服务器中对象的OCI应用程序可以使用由OTT生成的C头和实现文件。</p>
                  <p>头文件通过<code class="codeph">#include</code>语句合并到OCI代码中。
                  </p>
                  <p>一旦包含头文件，OCI应用程序就可以访问和操作主机语言格式的对象数据。</p>
                  <p><a href="using-object-type-translator-in-oci.html#GUID-D35CDFD1-8F5A-46D2-BC52-FD6B4A4D4F25__I434792">图24-1</a>显示了将OTT与OCI一起用于最简单的应用程序所涉及的步骤：</p>
                  <ol>
                     <li>
                        <p>SQL用于在数据库中创建类型定义。</p>
                     </li>
                     <li>
                        <p>OTT生成一个头文件，其中包含对象类型和命名集合类型的C表示。它还生成一个实现文件，以<code class="codeph">INITFILE</code>选项命名。
                        </p>
                     </li>
                     <li>
                        <p>该应用程序是写的。OCI应用程序中用户编写的代码声明并调用<code class="codeph">INITFUNC</code>函数。
                        </p>
                     </li>
                     <li>
                        <p>头文件包含在OCI源代码文件中。</p>
                     </li>
                     <li>
                        <p>OCI应用程序（包括OTT生成的实现文件）被编译并与OCI库链接。</p>
                     </li>
                     <li>
                        <p>OCI可执行文件是针对Oracle数据库运行的。</p>
                     </li>
                  </ol>
                  <div class="figure" id="GUID-D35CDFD1-8F5A-46D2-BC52-FD6B4A4D4F25__I434792">
                     <p class="titleinfigure">图24-1将OTT与OCI一起使用</p><img src="img/lnoci029.gif" alt="下面是图24-1的描述" title="下面是图24-1的描述" longdesc="img_text/lnoci029.html"><br><a href="img_text/lnoci029.html">“图24-1使用OTT和OCI”的描述</a></div>
                  <!-- class="figure" -->
                  <div class="p">本节包括以下主题：<ul style="list-style-type:disc">
                        <li>
                           <p><a href="using-object-type-translator-in-oci.html#GUID-A7FE645D-3408-4FDC-8A5C-0FDE1C51E037" title="在应用程序中，OCI程序可以使用声明为OTT生成的头文件中出现的类型的程序变量来执行绑定和定义操作。">关于使用OCI访问和操作对象</a></p>
                        </li>
                        <li>
                           <p><a href="using-object-type-translator-in-oci.html#GUID-D7512303-1266-40F5-838A-3F5895C229C5" title="如果请求，OTT会生成C初始化函数。初始化函数告诉环境，对于程序中使用的每个对象类型，使用哪种类型的类型。">调用初始化函数</a></p>
                        </li>
                        <li>
                           <p><a href="using-object-type-translator-in-oci.html#GUID-6C923475-9140-4A0B-9CC3-95764B7E3679" title="C初始化函数提供有关OTT处理的类型的版本信息。它向类型版本表添加每个OTT处理的对象数据类型的名称和版本标识符。">初始化函数的任务</a></p>
                        </li>
                     </ul>
                  </div>
               </div><a id="LNOCI17067"></a><div class="props_rev_3"><a id="GUID-A7FE645D-3408-4FDC-8A5C-0FDE1C51E037" name="GUID-A7FE645D-3408-4FDC-8A5C-0FDE1C51E037"></a><h4 id="LNOCI-GUID-A7FE645D-3408-4FDC-8A5C-0FDE1C51E037" class="sect4"><span class="enumeration_section">24.6.1</span>关于使用OCI访问和操作对象</h4>
                  <div>
                     <p>在应用程序中，OCI程序可以使用声明为OTT生成的头文件中出现的类型的程序变量来执行绑定和定义操作。</p>
                     <p>例如，应用程序可能使用SQL <code class="codeph">SELECT</code>语句将<code class="codeph">REF</code>提取到对象，然后使用适当的OCI函数固定该对象。固定对象后，可以使用其他OCI功能访问和操作其属性数据。
                     </p>
                     <p>OCI包括一组数据类型映射和操作函数，这些函数专门用于处理对象类型和命名集合类型的属性。</p>
                     <p>以下是可用功能的示例：</p>
                     <ul style="list-style-type:disc">
                        <li>
                           <p><code class="codeph">OCIStringSize()</code>获取<code class="codeph">OCIString</code>字符串的大小。
                           </p>
                        </li>
                        <li>
                           <p><code class="codeph">OCINumberAdd()</code>将两个<code class="codeph">OCINumber</code>编号一起添加。
                           </p>
                        </li>
                        <li>
                           <p><code class="codeph">OCILobIsEqual()</code>比较两个LOB定位器是否相等。
                           </p>
                        </li>
                        <li>
                           <p><code class="codeph">OCIRawPtr()</code>获取指向<code class="codeph">OCIRaw</code>原始数据类型的指针。
                           </p>
                        </li>
                        <li>
                           <p><code class="codeph">OCICollAppend()</code>将一个元素追加到集合类型（ <code class="codeph">OCIArray</code>或<code class="codeph">OCITable</code> ）。
                           </p>
                        </li>
                        <li>
                           <p><code class="codeph">OCITableFirst()</code>返回嵌套表（ <code class="codeph">OCITable</code> ）的第一个现有元素的索引。
                           </p>
                        </li>
                        <li>
                           <p><code class="codeph">OCIRefIsNull()</code>测试<code class="codeph">REF</code> （ <code class="codeph">OCIRef</code> ）是否为<code class="codeph">NULL</code> 。</p>
                        </li>
                     </ul>
                     <p>本指南的其他章节将详细介绍这些功能。</p>
                     <div class="infoboxnotealso" id="GUID-A7FE645D-3408-4FDC-8A5C-0FDE1C51E037__GUID-27A0ECF2-CFCE-4B83-9FCB-0262A95E8856">
                        <p class="notep1">也可以看看：</p>
                        <ul style="list-style-type:disc">
                           <li>
                              <p><a href="oci-string-functions.html#GUID-DBDAB2D9-4E78-4752-85B6-55D30CA6AF30" title="获取给定字符串的大小">OCIStringSize（）</a></p>
                           </li>
                           <li>
                              <p><a href="oci-NUMBER-functions.html#GUID-F3DC6DF6-9110-4BAC-AB97-DC604CA04BCD" title="将NUMBER添加到另一个NUMBER。">OCINumberAdd（）</a></p>
                           </li>
                           <li>
                              <p><a href="lob-functions.html#GUID-5142710F-03AD-43D5-BBAB-6732B874E52E" title="比较两个LOB或BFILE定位器是否相等。">OCILobIsEqual（）</a></p>
                           </li>
                           <li>
                              <p><a href="oci-raw-functions.html#GUID-B05C44C5-7168-438B-AC2A-BD3AD309AAEA" title="获取指向原始数据的指针。">OCIRawPtr（）</a></p>
                           </li>
                           <li>
                              <p><a href="oci-collection-and-iterator-functions.html#GUID-1F50303F-38EB-4CF5-A333-A75E01255585" title="将元素追加到集合的末尾。">OCICollAppend（）</a></p>
                           </li>
                           <li>
                              <p><a href="oci-table-functions.html#GUID-F4807159-0E8C-4204-AD4C-B08587D813F9" title="返回给定表中第一个现有元素的索引。">OCITableFirst（）</a></p>
                           </li>
                           <li>
                              <p><a href="oci-REF-functions.html#GUID-1DDD8B63-E9EE-46E7-866D-B8EB6355E339" title="测试REF是否为NULL。">OCIRefIsNull（）</a></p>
                           </li>
                        </ul>
                     </div>
                  </div>
               </div><a id="LNOCI72787"></a><a id="LNOCI72788"></a><a id="LNOCI72789"></a><a id="LNOCI17068"></a><div class="props_rev_3"><a id="GUID-D7512303-1266-40F5-838A-3F5895C229C5" name="GUID-D7512303-1266-40F5-838A-3F5895C229C5"></a><h4 id="LNOCI-GUID-D7512303-1266-40F5-838A-3F5895C229C5" class="sect4"><span class="enumeration_section">24.6.2</span>调用初始化函数</h4>
                  <div>
                     <p>如果请求，OTT会生成C初始化函数。初始化函数告诉环境，对于程序中使用的每个对象类型，使用哪种类型的类型。</p>
                     <div class="section">
                        <p>使用<code class="codeph">INITFUNC</code>选项调用OTT时，可以指定初始化函数的名称，也可以允许OTT根据包含该函数的实现文件（ <code class="codeph">INITFILE</code> ）的名称选择默认名称。
                        </p>
                        <p>初始化函数有两个参数;环境句柄指针和错误句柄指针。通常只有一个初始化函数，但这不是必需的。如果程序有几个需要不同类型的单独编译的部分，您可能需要为每个部分单独执行OTT，每个部分需要一个包含初始化函数的初始化文件。</p>
                        <p>在通过显式OCI对象调用（例如，通过调用<code class="codeph">OCIEnvCreate()</code> ）创建环境句柄之后，还必须显式调用初始化函数。必须为每个显式创建的环境句柄调用所有初始化函数。这使每个句柄都可以访问整个程序中使用的所有Oracle数据类型。
                        </p>
                        <p>如果嵌入式SQL语句（例如<code class="codeph">EXEC SQL CONTEXT USE</code>和<code class="codeph">EXEC SQL CONNECT</code> ）隐式创建了环境句柄，则会隐式初始化句柄，并且无需调用初始化函数。这仅在Pro * C / C ++与OCI应用程序结合时才有意义。
                        </p>
                        <p>以下示例显示了初始化函数。</p>
                        <p>假设您有一个intype文件<code class="codeph">ex2c.typ</code> ，其中包含<a href="using-object-type-translator-in-oci.html#GUID-D7512303-1266-40F5-838A-3F5895C229C5__CIHBJAIG">例24-15中</a>显示的内容。
                        </p>
                        <p>然后从命令行调用OTT并指定初始化函数，如<a href="using-object-type-translator-in-oci.html#GUID-D7512303-1266-40F5-838A-3F5895C229C5__CIHIJJHH">例24-16</a>所示。
                        </p>
                        <p>OTT使用<a href="using-object-type-translator-in-oci.html#GUID-D7512303-1266-40F5-838A-3F5895C229C5__CIHDFEGJ">例24-17中</a>显示的内容生成<code class="codeph">ex2cv.c</code>文件。
                        </p>
                        <p>函数<code class="codeph">ex2cv()</code>创建类型版本表并插入<code class="codeph">BREN.PERSON</code>和<code class="codeph">BREN.ADDRESS</code>类型。</p>
                        <p>如果程序显式创建环境句柄，则必须生成，编译和链接所有初始化函数，因为必须为每个显式创建的句柄调用它们。如果程序未显式创建任何环境句柄，则不需要初始化函数。</p>
                        <p>使用OTT生成的头文件的程序还必须使用同时生成的初始化函数。当OTT生成头文件并且在程序中显式创建环境句柄时，还必须编译实现文件并将其链接到可执行文件中。</p>
                     </div>
                     <!-- class="section" -->
                     <div class="example" id="GUID-D7512303-1266-40F5-838A-3F5895C229C5__CIHBJAIG">
                        <p class="titleinexample">例24-15名为ex2c.typ的Intype文件的内容</p><pre class="oac_no_warn" dir="ltr">TYPE BREN.PERSON TYPE BREN.ADDRESS</pre></div>
                     <!-- class="example" -->
                     <div class="example" id="GUID-D7512303-1266-40F5-838A-3F5895C229C5__CIHIJJHH">
                        <p class="titleinexample">例24-16调用OTT并指定初始化函数</p><pre class="oac_no_warn" dir="ltr">ott userid = bren intype = ex2c outtype = ex2co hfile = ex2ch.h initfile = ex2cv.c</pre></div>
                     <!-- class="example" -->
                     <div class="example" id="GUID-D7512303-1266-40F5-838A-3F5895C229C5__CIHDFEGJ">
                        <p class="titleinexample">例24-17 OTT生成文件的内容命名为ex2cv.c</p><pre class="oac_no_warn" dir="ltr">#ifndef OCI_ORACLE #include &lt;oci.h&gt; #endif sword ex2cv（OCIEnv * env，OCIError * err）{sword status = OCITypeVTInit（env，err）; if（status == OCI_SUCCESS）status = OCITypeVTInsert（env，err，“BREN”，5，“PERSON”，6，“$ 8.0”，4）; if（status == OCI_SUCCESS）status = OCITypeVTInsert（env，err，“BREN”，5，“ADDRESS”，7，“$ 8.0”，4）;返回状态; }</pre></div>
                     <!-- class="example" -->
                     <div class="section">
                        <div class="infoboxnotealso" id="GUID-D7512303-1266-40F5-838A-3F5895C229C5__GUID-F77C6D9E-BEE9-4773-BA6B-120D51D3B2D3">
                           <p class="notep1">也可以看看：</p>
                           <p><a href="connect-authorize-and-initialize-functions.html#GUID-16BDA1F1-7DAF-41CA-9EE1-C9A4CB467244" title="创建并初始化OCI函数的环境句柄。">OCIEnvCreate（）</a></p>
                        </div>
                     </div>
                     <!-- class="section" -->
                  </div>
               </div><a id="LNOCI17069"></a><div class="props_rev_3"><a id="GUID-6C923475-9140-4A0B-9CC3-95764B7E3679" name="GUID-6C923475-9140-4A0B-9CC3-95764B7E3679"></a><h4 id="LNOCI-GUID-6C923475-9140-4A0B-9CC3-95764B7E3679" class="sect4"><span class="enumeration_section">24.6.3</span>初始化函数的任务</h4>
                  <div>
                     <p>C初始化函数提供有关OTT处理的类型的版本信息。它向类型版本表添加每个OTT处理的对象数据类型的名称和版本标识符。</p>
                     <p>Oracle数据库类型管理器使用类型版本表来确定特定程序使用的类型的版本。OTT在不同时间生成的不同初始化函数可以向类型版本表添加一些相同的类型。当多次添加类型时，Oracle数据库会确保每次都注册相同版本的类型。</p>
                     <p>OCI程序员有责任为初始化函数声明函数原型，并调用该函数。</p>
                     <div class="infoboxnote" id="GUID-6C923475-9140-4A0B-9CC3-95764B7E3679__GUID-4432E9ED-3B18-49ED-8056-278C20A97B45">
                        <p class="notep1">注意：</p>
                        <p>在当前版本的Oracle数据库中，每种类型只有一个版本。仅为了与Oracle Database的未来版本兼容，才需要初始化类型版本表。</p>
                     </div>
                  </div>
               </div>
            </div><a id="LNOCI17070"></a><div class="props_rev_3"><a id="GUID-92EAE0E0-102C-4995-AE0E-F65BB120B749" name="GUID-92EAE0E0-102C-4995-AE0E-F65BB120B749"></a><h3 id="LNOCI-GUID-92EAE0E0-102C-4995-AE0E-F65BB120B749" class="sect3"><span class="enumeration_section">24.7</span> OTT参考</h3>
               <div>
                  <p>可以出现在OTT命令行或<code class="codeph">CONFIG</code>文件中的参数控制OTT的行为。某些参数也可以出现在intype文件中。
                  </p>
                  <div class="section">
                     <p></p>
                     <p>本节提供有关以下主题的详细信息：</p>
                     <ul style="list-style-type:disc">
                        <li>
                           <p><a href="using-object-type-translator-in-oci.html#GUID-28F6BA69-EB47-4A4F-9A4B-AA863EC19AEF" title="在显式调用OTT以将数据库类型转换为C结构时，将使用OTT命令行界面。">OTT命令行语法</a></p>
                        </li>
                        <li>
                           <p><a href="using-object-type-translator-in-oci.html#GUID-2E2FE6E6-1CE6-47C8-9709-D4E73458BFA1" title="USERID参数指定数据库用户名，密码和可选数据库名称（Oracle Net Services数据库规范字符串）。INTYPE参数指定从中读取对象类型规范列表的文件的名称。OTT翻译列表中的每种类型。OUTTYPE参数指定OTT为其处理的所有对象数据类型写入类型信息的文件的名称。这是OTT输出所需的主机语言，指定为CODE = C，CODE = KR_C或CODE = ANSI_C。 INITFILE参数指定要写入OTT生成的初始化文件的文件的名称。INITFUNC参数仅用于OCI程序。HFILE参数指定OTT要生成的包含（.h）文件的名称，该文件用于intype文件中提到的类型的声明，但其中未指定其包含文件。CONFIG参数指定OTT配置文件的名称，该文件列出了常用的参数规范。如果提供了ERRTYPE参数，OTT会将intype文件的列表写入ERRTYPE文件，以及所有信息和错误消息。该CASE参数影响OTT生成的某些C标识符的情况。 SCHEMA_NAMES参数提供控制，以在默认模式中使用outtype文件中的模式名称限定类型的数据库名称。TRANSITIVE参数的值为TRUE（默认值）或FALSE。对于URL参数，OTT使用JDBC（Java数据库连接），即用于连接数据库的Java接口。">OTT参数</a></p>
                        </li>
                        <li>
                           <p><a href="using-object-type-translator-in-oci.html#GUID-F440AB66-21CA-4199-B6C4-3E2020AE81C9" title="OTT参数可以出现在命令行，命令行中命名的CONFIG文件中，或两者都出现。">OTT参数可以出现的地方</a></p>
                        </li>
                        <li>
                           <p><a href="using-object-type-translator-in-oci.html#GUID-B4E872F1-7FF7-4E44-9480-56FF8567708C" title="intype和outtype文件列出OTT翻译的类型，并提供确定如何将类型或属性名称转换为合法C标识符所需的所有信息。">Intype文件的结构</a></p>
                        </li>
                        <li>
                           <p><a href="using-object-type-translator-in-oci.html#GUID-78BE8A56-DD08-42EF-8005-4A7923F84582" title="OTT生成的每个HFILE都使用#include指令包含其他必要文件和#define指令来定义根据文件名构造的符号，该符号可用于确定是否已包含HFILE。">嵌套包含文件生成</a></p>
                        </li>
                        <li>
                           <p><a href="using-object-type-translator-in-oci.html#GUID-43ADCF30-F829-4E8A-BB24-EC31A372CED6" title="SCHEMA_NAMES参数会影响OTT所连接的默认架构中的类型名称是否使用outtype文件中的架构名称进行限定。">SCHEMA_NAMES用法</a></p>
                        </li>
                        <li>
                           <p><a href="using-object-type-translator-in-oci.html#GUID-21CFD247-6655-4F3F-8322-E4344BF20318" title="当OTT为对象类型或属性创建C标识符名称时，它会将名称从数据库字符集转换为合法的C标识符。">默认名称映射</a></p>
                        </li>
                        <li>
                           <p><a href="using-object-type-translator-in-oci.html#GUID-6250D4A2-A45E-4CB0-8B4D-3ECC83D72C6F" title="目前，OTT通过比较用户在命令行或intype文件中提供的文件名来确定两个文件是否相同。">OTT对文件名比较的限制</a></p>
                        </li>
                        <li>
                           <p><a href="using-object-type-translator-in-oci.html#GUID-62F0809F-90E1-47BF-A005-01E48857902A" title="当前版本中Microsoft Windows上的OTT可执行文件是ott.bat，而不是早期版本中的ott.exe。">Microsoft Windows上的OTT命令</a></p>
                        </li>
                     </ul>
                     <p>本节使用以下约定来描述OTT语法：</p>
                     <ul style="list-style-type:disc">
                        <li>
                           <p>斜体字符串是由用户提供的变量或参数。</p>
                        </li>
                        <li>
                           <p>如图所示输入大写字符串，但大小写不重要。</p>
                        </li>
                        <li>
                           <p>OTT关键字在示例和标题中以小写等宽字体列出，但在文本中以大写字母打印以使它们更具特色。</p>
                        </li>
                        <li>
                           <p>方括号[...]包含可选项。</p>
                        </li>
                        <li>
                           <p>紧跟在项目之后的省略号（...）（或括在括号中的项目）意味着该项目可以重复任意次。</p>
                        </li>
                        <li>
                           <p>如图所示输入除前面描述的标点符号之外的标点符号。这些包括“。”，“@”等。</p>
                        </li>
                     </ul>
                  </div>
                  <!-- class="section" -->
               </div><a id="LNOCI17071"></a><div class="props_rev_3"><a id="GUID-28F6BA69-EB47-4A4F-9A4B-AA863EC19AEF" name="GUID-28F6BA69-EB47-4A4F-9A4B-AA863EC19AEF"></a><h4 id="LNOCI-GUID-28F6BA69-EB47-4A4F-9A4B-AA863EC19AEF" class="sect4"><span class="enumeration_section">24.7.1</span> OTT命令行语法</h4>
                  <div>
                     <p>在显式调用OTT以将数据库类型转换为C结构时，将使用OTT命令行界面。</p>
                     <div class="section">
                        <p>在开发使用对象的OCI应用程序时，始终需要这样做。</p>
                        <p>OTT命令行语句由关键字<code class="codeph">OTT</code> ，后跟OTT参数列表。
                        </p>
                        <p>可以出现在OTT命令行语句中的参数如下：</p><pre class="oac_no_warn" dir="ltr">[userid = <span class="italic">username / password [@db_name</span> ]] [intype = <span class="italic">filename</span> ] outtype = <span class="italic">filename</span> code = C | ANSI_C | KR_C [hfile = <span class="italic">filename</span> ] [errtype = <span class="italic">filename</span> ] [config = <span class="italic">filename</span> ] [initfile = <span class="italic">filename</span> ] [initfunc = <span class="italic">filename</span> ] [case = SAME | LOWER | UPPER | OPPOSITE] [schema_name = ALWAYS | IF_NEEDED | FROM_INTYPE] [transitive = TRUE | FALSE] [URL = <span class="italic">url</span> ]</pre><div class="infoboxnote" id="GUID-28F6BA69-EB47-4A4F-9A4B-AA863EC19AEF__GUID-28123C6E-8C06-45D1-9F5C-3C831244692E">
                           <p class="notep1">注意：</p>
                           <p>通常， <code class="codeph">ott</code>命令后面的参数顺序无关紧要。始终只需要<code class="codeph">OUTTYPE</code>和<code class="codeph">CODE</code>参数。
                           </p>
                        </div>
                        <p>几乎总是使用<code class="codeph">HFILE</code>参数。如果从命令行中省略， <code class="codeph">HFILE</code>必须为intype文件中的每个类型单独指定HFILE。如果OTT确定必须翻译未在intype文件中列出的类型，则报告错误。因此，仅当intype文件先前作为OTT outtype文件生成时，才能安全地省略<code class="codeph">HFILE</code>参数。
                        </p>
                        <p>如果省略intype文件，则翻译整个模式。OTT参数描述将在后面的章节中介绍。</p>
                        <p>以下是OTT命令行语句的示例（系统会提示您输入密码）：</p><pre class="oac_no_warn" dir="ltr">ott userid = marc intype = in.typ outtype = out.typ code = c hfile = demo.h \ errtype = demo.tls case = lower</pre><p>以下部分描述了每个OTT命令行参数。</p>
                        <div class="infoboxnotealso" id="GUID-28F6BA69-EB47-4A4F-9A4B-AA863EC19AEF__GUID-8F4FCD02-95DE-4D82-8A33-9FC949886E15">
                           <p class="notep1">也可以看看：</p>
                           <p><a href="using-object-type-translator-in-oci.html#GUID-2E2FE6E6-1CE6-47C8-9709-D4E73458BFA1" title="USERID参数指定数据库用户名，密码和可选数据库名称（Oracle Net Services数据库规范字符串）。INTYPE参数指定从中读取对象类型规范列表的文件的名称。OTT翻译列表中的每种类型。OUTTYPE参数指定OTT为其处理的所有对象数据类型写入类型信息的文件的名称。这是OTT输出所需的主机语言，指定为CODE = C，CODE = KR_C或CODE = ANSI_C。 INITFILE参数指定要写入OTT生成的初始化文件的文件的名称。INITFUNC参数仅用于OCI程序。HFILE参数指定OTT要生成的包含（.h）文件的名称，该文件用于intype文件中提到的类型的声明，但其中未指定其包含文件。CONFIG参数指定OTT配置文件的名称，该文件列出了常用的参数规范。如果提供了ERRTYPE参数，OTT会将intype文件的列表写入ERRTYPE文件，以及所有信息和错误消息。该CASE参数影响OTT生成的某些C标识符的情况。 SCHEMA_NAMES参数提供控制，以在默认模式中使用outtype文件中的模式名称限定类型的数据库名称。TRANSITIVE参数的值为TRUE（默认值）或FALSE。对于URL参数，OTT使用JDBC（Java数据库连接），即用于连接数据库的Java接口。">OTT参数</a></p>
                        </div>
                     </div>
                     <!-- class="section" -->
                  </div>
               </div><a id="LNOCI17072"></a><div class="props_rev_3"><a id="GUID-2E2FE6E6-1CE6-47C8-9709-D4E73458BFA1" name="GUID-2E2FE6E6-1CE6-47C8-9709-D4E73458BFA1"></a><h4 id="LNOCI-GUID-2E2FE6E6-1CE6-47C8-9709-D4E73458BFA1" class="sect4"><span class="enumeration_section">24.7.2</span> OTT参数</h4>
                  <div>
                     <div class="section">
                        <p>使用以下格式在OTT命令行上输入参数：</p><pre class="oac_no_warn" dir="ltr"><span class="italic">参数</span> = <span class="italic">值</span>
</pre><p>在此格式中， <code class="codeph">parameter</code>是文字参数字符串， <code class="codeph">value</code>是有效参数设置。文字参数字符串不区分大小写。
                        </p>
                        <p>使用空格或制表符分隔命令行参数。</p>
                        <p>参数也可以出现在配置文件中，但在这种情况下，行内不允许有空格，并且每个参数必须出现在单独的行中。此外，参数<code class="codeph">CASE,</code> <code class="codeph">HFILE,INITFUNC</code>和<code class="codeph">INITFILE</code>可以出现在intype文件中。
                        </p>
                        <div class="p">本节包括以下OTT参数：<ul style="list-style-type:disc">
                              <li>
                                 <p><a href="using-object-type-translator-in-oci.html#GUID-FE662479-DBB7-483C-8C0D-C3145FD74ED3" title="USERID参数指定数据库用户名，密码和可选数据库名称（Oracle Net Services数据库规范字符串）。">用户身份</a></p>
                              </li>
                              <li>
                                 <p><a href="using-object-type-translator-in-oci.html#GUID-19FD7F51-D387-4B70-A990-BBBE8F623FF5" title="INTYPE参数指定从中读取对象类型规范列表的文件的名称。OTT翻译列表中的每种类型。">输入法菜单</a></p>
                              </li>
                              <li>
                                 <p><a href="using-object-type-translator-in-oci.html#GUID-9847A850-7F84-475F-8133-C85EC228F994" title="OUTTYPE参数指定OTT为其处理的所有对象数据类型写入类型信息的文件的名称。">OUTTYPE</a></p>
                              </li>
                              <li>
                                 <p><a href="using-object-type-translator-in-oci.html#GUID-9A7D4CF9-47A6-46EE-84B6-0F9C2E7C897F" title="这是OTT输出所需的主机语言，指定为CODE = C，CODE = KR_C或CODE = ANSI_C。">码</a></p>
                              </li>
                              <li>
                                 <p><a href="using-object-type-translator-in-oci.html#GUID-11A774DB-FB73-42C6-8415-930DE6FF3FEB" title="INITFILE参数指定要写入OTT生成的初始化文件的文件的名称。">INITFILE</a></p>
                              </li>
                              <li>
                                 <p><a href="using-object-type-translator-in-oci.html#GUID-FBBE6A39-6C17-4E47-BEA8-E9465E8BB74A" title="INITFUNC参数仅用于OCI程序。">INITFUNC</a></p>
                              </li>
                              <li>
                                 <p><a href="using-object-type-translator-in-oci.html#GUID-5EAEA505-DA90-4F7D-BD27-8C2826AE2EE1" title="HFILE参数指定OTT要生成的包含（.h）文件的名称，该文件用于intype文件中提到的类型的声明，但其中未指定其包含文件。">HFILE</a></p>
                              </li>
                              <li>
                                 <p><a href="using-object-type-translator-in-oci.html#GUID-771EE821-4D7B-4101-8FA4-4A251800F725" title="CONFIG参数指定OTT配置文件的名称，该文件列出了常用的参数规范。">CONFIG</a></p>
                              </li>
                              <li>
                                 <p><a href="using-object-type-translator-in-oci.html#GUID-D2586D15-D06B-4D43-9780-1E135BE09EBF" title="如果提供了ERRTYPE参数，OTT会将intype文件的列表写入ERRTYPE文件，以及所有信息和错误消息。">ERRTYPE</a></p>
                              </li>
                              <li>
                                 <p><a href="using-object-type-translator-in-oci.html#GUID-DCB134A7-4A0F-4C91-AE55-6C05959AA60D" title="该CASE参数影响OTT生成的某些C标识符的情况。">案件</a></p>
                              </li>
                              <li>
                                 <p><a href="using-object-type-translator-in-oci.html#GUID-C585DAE6-D764-4986-A906-5CC3A2E1DAC5" title="SCHEMA_NAMES参数提供控制，以在默认模式中使用outtype文件中的模式名称限定类型的数据库名称。">SCHEMA_NAMES</a></p>
                              </li>
                              <li>
                                 <p><a href="using-object-type-translator-in-oci.html#GUID-D52FC80C-CA51-4638-AEB8-8F112982DB31" title="TRANSITIVE参数的值为TRUE（默认值）或FALSE。">传递性</a></p>
                              </li>
                              <li>
                                 <p><a href="using-object-type-translator-in-oci.html#GUID-FCB30650-BB50-4279-B8D8-ACFD7DB056E9" title="对于URL参数，OTT使用JDBC（Java数据库连接），Java接口用于连接数据库。">网址</a></p>
                              </li>
                           </ul>
                        </div>
                     </div>
                     <!-- class="section" -->
                  </div><a id="LNOCI17073"></a><div class="props_rev_3"><a id="GUID-FE662479-DBB7-483C-8C0D-C3145FD74ED3" name="GUID-FE662479-DBB7-483C-8C0D-C3145FD74ED3"></a><h5 id="LNOCI-GUID-FE662479-DBB7-483C-8C0D-C3145FD74ED3" class="sect5"><span class="enumeration_section">24.7.2.1</span> USERID</h5>
                     <div>
                        <p><code class="codeph">USERID</code>参数指定数据库用户名，密码和可选数据库名称（Oracle Net Services数据库规范字符串）。
                        </p>
                        <div class="section">
                           <p>如果省略数据库名称，则假定使用缺省数据库。该参数的语法是：</p><pre class="oac_no_warn" dir="ltr">userid = <span class="italic">用户名/密码[@db_name]</span>
</pre><p><code class="codeph">USERID</code>参数是可选的。如果省略，OTT会自动尝试以用户<code class="codeph">OPS$username</code>连接到默认数据库，其中<code class="codeph">username</code>是用户的操作系统用户名。如果这是第一个参数，则“ <code class="codeph">USERID=</code> ”并且可以省略密码和数据库名称，如下所示：</p><pre class="oac_no_warn" dir="ltr">ott <span class="italic">用户名...</span>
</pre><p>出于安全考虑，当您仅输入用户名时，系统会提示您输入其余条目。</p>
                           <p>将附加<code class="codeph">username</code>和<code class="codeph">db_name</code> （模式名称）组合，并将其用作<code class="codeph">OCIContextGetValue()</code>调用中的键，该调用在Oracle Database 12 <span class="italic">c</span>第1版（12.1）中支持最大长度为64个字节。在Oracle Database 12 <span class="italic">c</span>第2版（12.2）中，此最大长度扩展为支持243个字节，不包括句点（。）的1个字符。
                           </p>
                        </div>
                        <!-- class="section" -->
                     </div>
                  </div><a id="LNOCI17074"></a><div class="props_rev_3"><a id="GUID-19FD7F51-D387-4B70-A990-BBBE8F623FF5" name="GUID-19FD7F51-D387-4B70-A990-BBBE8F623FF5"></a><h5 id="LNOCI-GUID-19FD7F51-D387-4B70-A990-BBBE8F623FF5" class="sect5"><span class="enumeration_section">24.7.2.2</span> INTYPE</h5>
                     <div>
                        <p><code class="codeph">INTYPE</code>参数指定从中读取对象类型规范列表的文件的名称。OTT翻译列表中的每种类型。
                        </p>
                        <div class="section">
                           <p>此参数的语法是</p><pre class="oac_no_warn" dir="ltr">intype = <span class="italic">filename</span>
</pre><p>如果<code class="codeph">USERID</code>和<code class="codeph">INTYPE</code>是前两个参数，则可以省略“ <code class="codeph">INTYPE=</code> ”，并且省略“ <code class="codeph">USERID=</code> ”。如果未指定<code class="codeph">INTYPE</code>参数，则转换用户架构中的所有类型。
                           </p><pre class="oac_no_warn" dir="ltr">ott <span class="italic">用户名filename ...</span>
</pre><p>可以将intype文件视为类型声明的makefile。它列出了需要C struct声明的类型。</p>
                           <p>如果命令行或intype文件中的文件名不包含扩展名，则会添加特定于操作系统的扩展名，例如“ <code class="codeph">TYP</code> ”或“ <code class="codeph">.typ</code> ”。
                           </p>
                           <div class="infoboxnotealso" id="GUID-19FD7F51-D387-4B70-A990-BBBE8F623FF5__GUID-EF21D0CB-AB43-49C7-B4F0-2AAF658E6B5A">
                              <p class="notep1">也可以看看：</p>
                              <p> <a href="using-object-type-translator-in-oci.html#GUID-B4E872F1-7FF7-4E44-9480-56FF8567708C" title="The intype and outtype files list the types translated by OTT, and provide all the information needed to determine how a type or attribute name is translated to a legal C identifier.">Intype文件的结构，</a>用于描述<a href="using-object-type-translator-in-oci.html#GUID-B4E872F1-7FF7-4E44-9480-56FF8567708C" title="intype和outtype文件列出OTT翻译的类型，并提供确定如何将类型或属性名称转换为合法C标识符所需的所有信息。">intype文件</a>的格式</p>
                           </div>
                        </div>
                        <!-- class="section" -->
                     </div>
                  </div><a id="LNOCI17075"></a><div class="props_rev_3"><a id="GUID-9847A850-7F84-475F-8133-C85EC228F994" name="GUID-9847A850-7F84-475F-8133-C85EC228F994"></a><h5 id="LNOCI-GUID-9847A850-7F84-475F-8133-C85EC228F994" class="sect5"><span class="enumeration_section">24.7.2.3</span> OUTTYPE</h5>
                     <div>
                        <p><code class="codeph">OUTTYPE</code>参数指定OTT为其处理的所有对象数据类型写入类型信息的文件的名称。
                        </p>
                        <div class="section">
                           <p>这包括在intype文件中显式命名的所有类型，并且可以包含已翻译的其他类型，因为它们用于必须转换的其他类型的声明中（如果<code class="codeph">TRANSITIVE=TRUE</code> ）。在将来调用OTT时，此文件必须用作intype文件。</p><pre class="oac_no_warn" dir="ltr">outtype = <span class="italic">filename</span>
</pre><p>如果<code class="codeph">INTYPE</code>和<code class="codeph">OUTTYPE</code>参数引用同一文件，则新的<code class="codeph">INTYPE</code>参数信息将替换intype文件中的旧信息。这为在改变类型，生成类型声明，编辑源代码，预编译，编译和调试的循环中重复使用相同的intype文件提供了一种便捷的方法。
                           </p>
                           <p>必须指定参数<code class="codeph">OUTTYPE</code> 。
                           </p>
                           <p>如果命令行或outtype文件中的文件名不包含扩展名，则会添加特定于操作系统的扩展名，例如“ <code class="codeph">TYP</code> ”或“ <code class="codeph">.typ</code> ”。
                           </p>
                        </div>
                        <!-- class="section" -->
                     </div>
                  </div><a id="LNOCI17076"></a><div class="props_rev_3"><a id="GUID-9A7D4CF9-47A6-46EE-84B6-0F9C2E7C897F" name="GUID-9A7D4CF9-47A6-46EE-84B6-0F9C2E7C897F"></a><h5 id="LNOCI-GUID-9A7D4CF9-47A6-46EE-84B6-0F9C2E7C897F" class="sect5"><span class="enumeration_section">24.7.2.4</span>代码</h5>
                     <div>
                        <p>这是OTT输出所需的主机语言，指定为<code class="codeph">CODE=C, CODE=KR_C,</code>或<code class="codeph">CODE=ANSI_C</code> 。</p>
                        <div class="section">
                           <p>“ <code class="codeph">CODE=C</code> ”相当于“ <code class="codeph">CODE=ANSI_C</code> ”。
                           </p><pre class="oac_no_warn" dir="ltr">CODE <code class="codeph">=</code> C | KR_C | ANSI_C</pre><p>此参数没有默认值;必须提供。</p>
                        </div>
                        <!-- class="section" -->
                     </div>
                  </div><a id="LNOCI17077"></a><div class="props_rev_3"><a id="GUID-11A774DB-FB73-42C6-8415-930DE6FF3FEB" name="GUID-11A774DB-FB73-42C6-8415-930DE6FF3FEB"></a><h5 id="LNOCI-GUID-11A774DB-FB73-42C6-8415-930DE6FF3FEB" class="sect5"><span class="enumeration_section">24.7.2.5</span> INITFILE</h5>
                     <div>
                        <p><code class="codeph">INITFILE</code>参数指定要写入OTT生成的初始化文件的文件的名称。
                        </p>
                        <div class="section">
                           <p>如果省略此参数，则不会生成初始化函数。</p>
                           <p>对于Pro * C / C ++程序， <code class="codeph">INITFILE</code>不是必需的，因为SQLLIB运行时库执行必要的初始化。OCI程序用户必须编译和链接<code class="codeph">INITFILE</code>文件，并且必须在创建环境句柄时调用初始化文件函数。
                           </p>
                           <p>如果一个的文件名<code class="codeph">INITFILE</code>在命令行上或在法菜单文件不包括扩展名，一个特定于操作系统的扩展，例如“ <code class="codeph">C</code> ”或“ <code class="codeph">.c</code> ”被添加。
                           </p><pre class="oac_no_warn" dir="ltr">initfile = <span class="italic">filename</span></pre></div>
                        <!-- class="section" -->
                     </div>
                  </div><a id="LNOCI17078"></a><div class="props_rev_3"><a id="GUID-FBBE6A39-6C17-4E47-BEA8-E9465E8BB74A" name="GUID-FBBE6A39-6C17-4E47-BEA8-E9465E8BB74A"></a><h5 id="LNOCI-GUID-FBBE6A39-6C17-4E47-BEA8-E9465E8BB74A" class="sect5"><span class="enumeration_section">24.7.2.6</span> INITFUNC</h5>
                     <div>
                        <p><code class="codeph">INITFUNC</code>参数仅用于OCI程序。
                        </p>
                        <div class="section">
                           <p>它指定OTT生成的初始化函数的名称。如果省略此参数，则初始化函数的名称<code class="codeph">INITFILE</code>的名称<code class="codeph">INITFILE</code> 。</p><pre class="oac_no_warn" dir="ltr">initfunc = <span class="italic">filename</span></pre></div>
                        <!-- class="section" -->
                     </div>
                  </div><a id="LNOCI17079"></a><div class="props_rev_3"><a id="GUID-5EAEA505-DA90-4F7D-BD27-8C2826AE2EE1" name="GUID-5EAEA505-DA90-4F7D-BD27-8C2826AE2EE1"></a><h5 id="LNOCI-GUID-5EAEA505-DA90-4F7D-BD27-8C2826AE2EE1" class="sect5"><span class="enumeration_section">24.7.2.7</span> HFILE</h5>
                     <div>
                        <p><code class="codeph">HFILE</code>参数指定OTT要生成的包含（ <code class="codeph">.h</code> ）文件的名称，该文件用于intype文件中提到的类型的声明，但其中未指定其包含文件。
                        </p>
                        <div class="section">
                           <p>除非在intype文件中单独指定每种类型的包含文件，否则此参数是必需的。如果必须生成intype文件中未提及的类型，因为其他类型需要它，并且这些其他类型在两个或多个不同的文件中声明，并且<code class="codeph">TRANSITIVE=TRUE</code> ，则此参数也是必需的。</p>
                           <p>如果一个的文件名<code class="codeph">HFILE</code>在命令行上或在法菜单文件不包括扩展名，一个特定于操作系统的扩展，例如“ <code class="codeph">H</code> ”或“ <code class="codeph">.h</code> ”被添加。
                           </p><pre class="oac_no_warn" dir="ltr">hfile = <span class="italic">filename</span></pre></div>
                        <!-- class="section" -->
                     </div>
                  </div><a id="LNOCI17080"></a><div class="props_rev_3"><a id="GUID-771EE821-4D7B-4101-8FA4-4A251800F725" name="GUID-771EE821-4D7B-4101-8FA4-4A251800F725"></a><h5 id="LNOCI-GUID-771EE821-4D7B-4101-8FA4-4A251800F725" class="sect5"><span class="enumeration_section">24.7.2.8</span>配置</h5>
                     <div>
                        <p><code class="codeph">CONFIG</code>参数指定OTT配置文件的名称，该文件列出了常用的参数规范。
                        </p>
                        <div class="section">
                           <p>还从与操作系统相关的位置的系统配置文件中读取参数规范。所有剩余的参数规范必须出现在命令行或intype文件中。</p><pre class="oac_no_warn" dir="ltr">config = <span class="italic">filename</span> </pre><div class="infoboxnote" id="GUID-771EE821-4D7B-4101-8FA4-4A251800F725__GUID-DAD2C3E5-E5D0-483B-A703-A1E2938FA158">
                              <p class="notep1">注意：</p>
                              <p><code class="codeph">CONFIG</code>文件中不允许使用<code class="codeph">CONFIG</code>参数。
                              </p>
                           </div>
                        </div>
                        <!-- class="section" -->
                     </div>
                  </div><a id="LNOCI17081"></a><div class="props_rev_3"><a id="GUID-D2586D15-D06B-4D43-9780-1E135BE09EBF" name="GUID-D2586D15-D06B-4D43-9780-1E135BE09EBF"></a><h5 id="LNOCI-GUID-D2586D15-D06B-4D43-9780-1E135BE09EBF" class="sect5"><span class="enumeration_section">24.7.2.9</span> ERRTYPE</h5>
                     <div>
                        <p>如果提供了<code class="codeph">ERRTYPE</code>参数，OTT会将intype文件的列表写入<code class="codeph">ERRTYPE</code>文件，以及所有信息和错误消息。
                        </p>
                        <div class="section">
                           <p>无论是否指定了<code class="codeph">ERRTYPE</code>参数，都会将信息和错误消息发送到标准输出。
                           </p>
                           <p>实质上， <code class="codeph">ERRTYPE</code>文件是<code class="codeph">ERRTYPE</code>文件的副本，其中添加了错误消息。在大多数情况下，错误消息包含指向导致错误的文本的指针。
                           </p>
                           <p>如果一个的文件名<code class="codeph">ERRTYPE</code>在命令行上或在法菜单文件不包括扩展名，一个特定于操作系统的扩展，例如“ <code class="codeph">TLS</code> ”或“ <code class="codeph">.tls</code> ”被添加。
                           </p><pre class="oac_no_warn" dir="ltr">errtype = <span class="italic">文件名</span></pre></div>
                        <!-- class="section" -->
                     </div>
                  </div><a id="LNOCI17082"></a><div class="props_rev_3"><a id="GUID-DCB134A7-4A0F-4C91-AE55-6C05959AA60D" name="GUID-DCB134A7-4A0F-4C91-AE55-6C05959AA60D"></a><h5 id="LNOCI-GUID-DCB134A7-4A0F-4C91-AE55-6C05959AA60D" class="sect5"><span class="enumeration_section">24.7.2.10</span>案例</h5>
                     <div>
                        <p>该<code class="codeph">CASE</code>参数影响OTT生成的某些C标识符的情况。</p>
                        <div class="section">
                           <p><code class="codeph">CASE</code>的可能值是<code class="codeph">SAME, LOWER, UPPER</code>和<code class="codeph">OPPOSITE</code> 。如果<code class="codeph">CASE = SAME</code> ，则在将数据库类型和属性名称转换为C标识符时，不会更改字母大小写。如果<code class="codeph">CASE=LOWER</code> ，则所有大写字母都将转换为小写。如果<code class="codeph">CASE=UPPER</code> ，则所有小写字母都将转换为大写。如果<code class="codeph">CASE=OPPOSITE</code> ，则所有大写字母都将转换为小写，反之亦然。
                           </p><pre class="oac_no_warn" dir="ltr">CASE = [SAME | LOWER | UPPER | OPPOSITE]</pre><p>此选项仅影响intype文件中未提及的那些标识符（未明确列出的属性或类型）。在生成合法标识符后发生大小写转换。</p>
                           <p>请注意， <code class="codeph">INTYPE</code>参数选项中特别提到的类型的C结构标识符的情况与intype文件中的情况相同。例如，如果intype文件包含以下行：</p><pre class="oac_no_warn" dir="ltr">TYPE工人</pre><p>然后OTT生成以下行：</p><pre class="oac_no_warn" dir="ltr">struct Worker {...};</pre><p>但是，假设intype文件编写如下：</p><pre class="oac_no_warn" dir="ltr">类型wOrKeR</pre><p>然后OTT按照intype文件中指定的大小生成以下行。</p><pre class="oac_no_warn" dir="ltr">struct wOrKeR {...};</pre><p>如果<code class="codeph">CASE=SAME</code> ，则intype文件中未提及的不区分大小写的SQL标识符将以大写形式显示，如果<code class="codeph">CASE=OPPOSITE</code> ，则以小写形式显示。如果SQL标识符在声明时未用引号括起来，则它不区分大小写。
                           </p>
                        </div>
                        <!-- class="section" -->
                     </div>
                  </div><a id="LNOCI17083"></a><div class="props_rev_3"><a id="GUID-C585DAE6-D764-4986-A906-5CC3A2E1DAC5" name="GUID-C585DAE6-D764-4986-A906-5CC3A2E1DAC5"></a><h5 id="LNOCI-GUID-C585DAE6-D764-4986-A906-5CC3A2E1DAC5" class="sect5"><span class="enumeration_section">24.7.2.11</span> SCHEMA_NAMES</h5>
                     <div>
                        <p><code class="codeph">SCHEMA_NAMES</code>参数提供控制，以在默认模式中使用outtype文件中的模式名称限定类型的数据库名称。
                        </p>
                        <div class="section">
                           <p>OTT生成的outtype文件包含有关OTT处理的类型的信息，包括类型名称。</p>
                           <div class="infoboxnotealso" id="GUID-C585DAE6-D764-4986-A906-5CC3A2E1DAC5__GUID-63E5382F-0255-4F89-8A94-E92D951F7708">
                              <p class="notep1">也可以看看：</p>
                              <p><a href="using-object-type-translator-in-oci.html#GUID-43ADCF30-F829-4E8A-BB24-EC31A372CED6" title="SCHEMA_NAMES参数会影响OTT所连接的默认架构中的类型名称是否使用outtype文件中的架构名称进行限定。">SCHEMA_NAMES用法</a></p>
                           </div>
                        </div>
                        <!-- class="section" -->
                     </div>
                  </div><a id="LNOCI17084"></a><div class="props_rev_3"><a id="GUID-D52FC80C-CA51-4638-AEB8-8F112982DB31" name="GUID-D52FC80C-CA51-4638-AEB8-8F112982DB31"></a><h5 id="LNOCI-GUID-D52FC80C-CA51-4638-AEB8-8F112982DB31" class="sect5"><span class="enumeration_section">24.7.2.12传统</span></h5>
                     <div>
                        <p><code class="codeph">TRANSITIVE</code>参数的值为<code class="codeph">TRUE</code> （默认值）或<code class="codeph">FALSE</code> 。</p>
                        <div class="section">
                           <p>它指示是否要转换未在intype文件中明确列出的类型依赖项。</p>
                           <p>如果指定了<code class="codeph">TRANSITIVE=TRUE</code> ，则会生成其他类型所需但在intype文件中未提及的类型。
                           </p>
                           <p>如果指定了<code class="codeph">TRANSITIVE=FALSE</code> ，则不会生成intype文件中未提及的类型，即使它们被用作其他生成类型的属性类型也是如此。
                           </p>
                        </div>
                        <!-- class="section" -->
                     </div>
                  </div><a id="LNOCI17085"></a><div class="props_rev_3"><a id="GUID-FCB30650-BB50-4279-B8D8-ACFD7DB056E9" name="GUID-FCB30650-BB50-4279-B8D8-ACFD7DB056E9"></a><h5 id="LNOCI-GUID-FCB30650-BB50-4279-B8D8-ACFD7DB056E9" class="sect5"><span class="enumeration_section">24.7.2.13</span> URL</h5>
                     <div>
                        <p>对于<code class="codeph">URL</code>参数，OTT使用JDBC（Java数据库连接），Java接口用于连接数据库。
                        </p>
                        <div class="section">
                           <p>参数<code class="codeph">URL</code>的默认值为：</p><pre class="oac_no_warn" dir="ltr"><code class="codeph">URL</code> = <code class="codeph">jdbc:oracle:oci8:@</code>
</pre><p>OCI8驱动程序用于客户端使用Oracle数据库安装。</p>
                           <p>要指定JDBC Thin驱动程序（用于客户端使用而不安装Oracle数据库的Java驱动程序），请使用以下<code class="codeph">URL</code>参数语法：</p><pre class="oac_no_warn" dir="ltr">URL = jdbc：oracle：thin：@ <span class="italic">host：port：sid</span>
</pre><p><code class="codeph">host</code>是运行数据库的主机的名称， <code class="codeph">port</code>是端口号， <code class="codeph">sid</code>是Oracle SID。</p>
                        </div>
                        <!-- class="section" -->
                     </div>
                  </div>
               </div><a id="LNOCI17086"></a><div class="props_rev_3"><a id="GUID-F440AB66-21CA-4199-B6C4-3E2020AE81C9" name="GUID-F440AB66-21CA-4199-B6C4-3E2020AE81C9"></a><h4 id="LNOCI-GUID-F440AB66-21CA-4199-B6C4-3E2020AE81C9" class="sect4"><span class="enumeration_section">24.7.3</span>可以出现OTT参数的地方</h4>
                  <div>
                     <p>OTT参数可以出现在命令行，命令行中命名的<code class="codeph">CONFIG</code>文件中，或两者都出现。
                     </p>
                     <div class="section">
                        <p>intype文件中也允许使用某些参数。</p>
                        <p>OTT的调用如下：</p><pre class="oac_no_warn" dir="ltr">ott <span class="italic">用户名</span> / <span class="italic">密码</span>参数</pre><p>如果命令行中的某个参数如下，则从配置文件<code class="codeph">filename</code>中读取其他参数：</p><pre class="oac_no_warn" dir="ltr">config = <span class="italic">filename</span>
</pre><p>此外，还会从与操作系统相关的位置的默认配置文件中读取参数。此文件必须存在，但可以为空。配置文件中的参数必须在每行中出现一个，行上没有空格。</p>
                        <p>如果在没有任何参数的情况下执行OTT，则会显示在线参数引用。</p>
                        <p>要转换的OTT的类型在<code class="codeph">INTYPE</code>参数指定的文件中命名。参数<code class="codeph">CASE, INITFILE, INITFUNC</code>和<code class="codeph">HFILE</code>也可以出现在intype文件中。OTT生成的outtype文件包括<code class="codeph">CASE</code>参数，如果生成了初始化文件，则包含<code class="codeph">INITFILE</code>和<code class="codeph">INITFUNC</code>参数。outtype文件为每种类型单独指定<code class="codeph">HFILE</code> 。
                        </p>
                        <p>OTT命令的情况与操作系统有关。</p>
                     </div>
                     <!-- class="section" -->
                  </div>
               </div><a id="LNOCI17087"></a><div class="props_rev_3"><a id="GUID-B4E872F1-7FF7-4E44-9480-56FF8567708C" name="GUID-B4E872F1-7FF7-4E44-9480-56FF8567708C"></a><h4 id="LNOCI-GUID-B4E872F1-7FF7-4E44-9480-56FF8567708C" class="sect4"><span class="enumeration_section">24.7.4</span> Intype文件的结构</h4>
                  <div>
                     <p>intype和outtype文件列出OTT翻译的类型，并提供确定如何将类型或属性名称转换为合法C标识符所需的所有信息。</p>
                     <div class="section">
                        <p>这些文件包含一个或多个类型规范。这些文件还可以包含以下选项的规范：</p>
                        <ul style="list-style-type:disc">
                           <li>
                              <p><code class="codeph">案件</code></p>
                           </li>
                           <li>
                              <p><code class="codeph">HFILE</code></p>
                           </li>
                           <li>
                              <p><code class="codeph">INITFILE</code></p>
                           </li>
                           <li>
                              <p><code class="codeph">INITFUNC</code></p>
                           </li>
                        </ul>
                        <p>如果存在<code class="codeph">CASE, INITFILE</code>或<code class="codeph">INITFUNC</code>选项，则它们必须位于任何类型规范之前。如果这些选项同时出现在命令行和intype文件中，则使用命令行上的值。
                        </p>
                        <p>本节包括以下主题： <a href="using-object-type-translator-in-oci.html#GUID-73D009AC-93E6-4207-AC85-5950BB09F901" title="intype文件中的类型规范命名要转换的对象数据类型。">Intype文件类型规范</a> 。
                        </p>
                        <div class="infoboxnotealso" id="GUID-B4E872F1-7FF7-4E44-9480-56FF8567708C__GUID-1041F5C0-49D4-4F9E-830D-21A3171FAD3E">
                           <p class="notep1">也可以看看：</p>
                           <p><a href="using-object-type-translator-in-oci.html#GUID-77133295-EB6F-4B0D-81BE-2B7C117123A0" title="outtype文件在OTT命令行上命名。">Outtype File</a>用于简单用户定义的intype文件的示例，以及OTT从中生成的完整outtype文件</p>
                        </div>
                     </div>
                     <!-- class="section" -->
                  </div><a id="LNOCI17088"></a><div class="props_rev_3"><a id="GUID-73D009AC-93E6-4207-AC85-5950BB09F901" name="GUID-73D009AC-93E6-4207-AC85-5950BB09F901"></a><h5 id="LNOCI-GUID-73D009AC-93E6-4207-AC85-5950BB09F901" class="sect5"><span class="enumeration_section">24.7.4.1</span> Intype文件类型规范</h5>
                     <div>
                        <p>intype文件中的类型规范命名要转换的对象数据类型。</p>
                        <div class="section">
                           <p>outtype文件中的类型规范命名已翻译的对象数据类型。</p><pre class="oac_no_warn" dir="ltr">TYPE员工TRANSLATE SALARY $ AS薪水DEPTNO AS部门类型地址类型PURCHASE_ORDER作为p_o</pre><p>类型规范的结构如下，其中[]表示内部的可选输入：</p><pre class="oac_no_warn" dir="ltr">TYPE <span class="italic">type_name</span> [AS <span class="italic">type_identifier</span> ] [VERSION [=] <span class="italic">version_string</span> ] [HFILE [=] <span class="italic">hfile_name</span> ] [TRANSLATE { <span class="italic">member_name</span> [AS <span class="italic">identifier</span> ]} ...]
</pre><p><code class="codeph">type_name</code>的语法是：</p><pre class="oac_no_warn" dir="ltr">[ <span class="italic">schema_name</span> 。] <span class="italic">type_name</span>
</pre><p><code class="codeph">schema_name</code>是拥有给定对象数据类型的模式的名称， <code class="codeph">type_name</code>是该类型的名称。默认架构是运行OTT的用户的架构。默认数据库是本地数据库。
                           </p>
                           <p>类型规范的组件描述如下：</p>
                           <ul style="list-style-type:disc">
                              <li>
                                 <p><code class="codeph">type_name</code>是Oracle数据库对象数据类型的名称。
                                 </p>
                              </li>
                              <li>
                                 <p><code class="codeph">type_identifier</code>是用于表示类型的C标识符。如果省略<code class="codeph">type_identifier</code> ，则使用默认名称映射算法。
                                 </p>
                              </li>
                              <li>
                                 <p><code class="codeph">version_string</code>是上次调用OTT生成代码时使用的类型的版本字符串。版本字符串由OTT生成并写入outtype文件，当稍后执行OTT时，该文件可用作intype文件。版本字符串不会影响OTT的操作，但最终用于选择应在正在运行的程序中使用的对象数据类型的版本。
                                 </p>
                              </li>
                           </ul>
                           <ul style="list-style-type:disc">
                              <li>
                                 <p><code class="codeph">hfile_name</code>是头文件的名称，其中显示相应结构或类的声明。如果省略<code class="codeph">hfile_name</code> ，则在生成声明时使用命令行<code class="codeph">HFILE</code>参数指定的文件。
                                 </p>
                              </li>
                              <li>
                                 <p><code class="codeph">member_name</code>是要转换为<code class="codeph">identifier</code>的属性（数据成员）的名称。
                                 </p>
                              </li>
                              <li>
                                 <p><code class="codeph">identifier</code>是用于表示用户程序中的属性的C标识符。可以通过这种方式为任意数量的属性指定标识符。默认名称映射算法用于未提及的属性。
                                 </p>
                              </li>
                           </ul>
                           <p>由于以下两个原因之一，可能需要转换对象数据类型：</p>
                           <ul style="list-style-type:disc">
                              <li>
                                 <p>它出现在intype文件中。</p>
                              </li>
                              <li>
                                 <p>需要声明另一个必须翻译的类型，并且<code class="codeph">TRANSITIVE=TRUE</code> 。</p>
                              </li>
                           </ul>
                           <p>如果在一个文件中声明的类型需要未明确提及的类型，则OTT会将所需类型的转换写入与需要它的显式声明类型相同的文件。</p>
                           <p>如果在两个或多个不同文件中声明的类型需要未明确提及的类型，OTT会将所需类型的转换写入全局<code class="codeph">HFILE</code>文件。
                           </p>
                           <div class="infoboxnotealso" id="GUID-73D009AC-93E6-4207-AC85-5950BB09F901__GUID-54AB980B-8F85-4FE9-88AC-3DE0094DF17D">
                              <p class="notep1">也可以看看：</p>
                              <p><a href="using-object-type-translator-in-oci.html#GUID-21CFD247-6655-4F3F-8322-E4344BF20318" title="当OTT为对象类型或属性创建C标识符名称时，它会将名称从数据库字符集转换为合法的C标识符。">默认名称映射</a> ，以获取有关命名与<code class="codeph">version_string</code>组件相关的intype文件的更多信息。
                              </p>
                           </div>
                        </div>
                        <!-- class="section" -->
                     </div>
                  </div>
               </div><a id="LNOCI72790"></a><a id="LNOCI72791"></a><a id="LNOCI72792"></a><a id="LNOCI72793"></a><a id="LNOCI72794"></a><a id="LNOCI72795"></a><a id="LNOCI17089"></a><div class="props_rev_3"><a id="GUID-78BE8A56-DD08-42EF-8005-4A7923F84582" name="GUID-78BE8A56-DD08-42EF-8005-4A7923F84582"></a><h4 id="LNOCI-GUID-78BE8A56-DD08-42EF-8005-4A7923F84582" class="sect4"><span class="enumeration_section">24.7.5</span>嵌套包含的文件生成</h4>
                  <div>
                     <p>OTT生成的每个<code class="codeph">HFILE</code>使用<code class="codeph">#include</code>指令包含其他必要文件和<code class="codeph">#define</code>指令来定义根据文件名构造的符号，该符号可用于确定是否已包含<code class="codeph">HFILE</code> 。
                     </p>
                     <div class="section">
                        <p>例如，考虑一个具有<a href="using-object-type-translator-in-oci.html#GUID-78BE8A56-DD08-42EF-8005-4A7923F84582__CIHEJEGB">例24-18中</a>所示类型的数据库。
                        </p>
                        <p>intype文件内容如<a href="using-object-type-translator-in-oci.html#GUID-78BE8A56-DD08-42EF-8005-4A7923F84582__CIHDHGCG">例24-19</a>所示。
                        </p>
                        <p>如果使用<a href="using-object-type-translator-in-oci.html#GUID-78BE8A56-DD08-42EF-8005-4A7923F84582__CIHEIIFH">例24-20中</a>所示的命令调用OTT，则会生成<a href="using-object-type-translator-in-oci.html#GUID-78BE8A56-DD08-42EF-8005-4A7923F84582__CIHGGFJH">例24-21</a>和<a href="using-object-type-translator-in-oci.html#GUID-78BE8A56-DD08-42EF-8005-4A7923F84582__CIHGFIEC">例24-22中</a>所示的头文件。
                        </p>
                        <p><a href="using-object-type-translator-in-oci.html#GUID-78BE8A56-DD08-42EF-8005-4A7923F84582__CIHGGFJH">示例24-21中</a>显示了头文件<code class="codeph">tott95b.h</code>的内容。
                        </p>
                        <p>头文件tott95a.h的内容如<a href="using-object-type-translator-in-oci.html#GUID-78BE8A56-DD08-42EF-8005-4A7923F84582__CIHGFIEC">例24-22</a>所示。
                        </p>
                        <p>在<a href="using-object-type-translator-in-oci.html#GUID-78BE8A56-DD08-42EF-8005-4A7923F84582__CIHGGFJH">例24-21中</a> ，首先定义符号<code class="codeph">TOTT95B_ORACLE</code>以便程序员可以有条件地包含<code class="codeph">tott95b.h</code>而不必担心<code class="codeph">tott95b.h</code>是否依赖于使用该构造的include文件，如<a href="using-object-type-translator-in-oci.html#GUID-78BE8A56-DD08-42EF-8005-4A7923F84582__CIHEDJIA">例24-23</a>所示。
                        </p>
                        <p>使用这种技术，程序员可以从某个文件中包含<code class="codeph">tott95b.h</code> ，比如<code class="codeph">foo.h</code> ，而不必知道<code class="codeph">foo.h</code>包含的其他文件是否也包含<code class="codeph">tott95b.h</code> 。
                        </p>
                        <p>在定义符号<code class="codeph">TOTT95B_ORACLE</code> ，包含文件<code class="codeph">oci.h</code>OTT生成的每个<code class="codeph">HFILE</code>包含<code class="codeph">oci.h</code> ，它包含Pro * C / C ++或OCI程序员可以使用的类型和函数声明。这是OTT在<code class="codeph">#include</code>指令中使用尖括号的唯一情况。
                        </p>
                        <p>接下来，包含文件<code class="codeph">tott95a.h</code> 。包含此文件是因为它包含<code class="codeph">tott95b.h</code>所需的“ <code class="codeph">struct px1</code> ”声明。当用户的intype文件请求将类型声明写入多个文件时，OTT确定每个<code class="codeph">HFILE</code>必须包含哪些其他文件，并生成必要的<code class="codeph">#includes</code>指令。
                        </p>
                        <p>请注意，OTT在此<code class="codeph">#include</code>指令中使用引号。当编译包含<code class="codeph">tott95b.h</code>的程序时，搜索<code class="codeph">tott95a.h</code>从找到源程序的<code class="codeph">tott95a.h</code>开始，然后遵循实现定义的搜索规则。如果无法以这种方式找到<code class="codeph">tott95a.h</code> ，则应在intype文件中使用完整的文件名（例如，以/开头的Linux或UNIX绝对路径名）来指定<code class="codeph">tott95a.h</code>的位置。
                        </p>
                     </div>
                     <!-- class="section" -->
                     <div class="example" id="GUID-78BE8A56-DD08-42EF-8005-4A7923F84582__CIHEJEGB">
                        <p class="titleinexample">示例24-18对象类型定义以演示OTT如何生成包含文件</p><pre class="oac_no_warn" dir="ltr">create type px1 AS OBJECT（col1 number，col2 integer）;创建类型px2 AS OBJECT（col1 px1）;创建类型px3 AS OBJECT（col1 px1）;</pre></div>
                     <!-- class="example" -->
                     <div class="example" id="GUID-78BE8A56-DD08-42EF-8005-4A7923F84582__CIHDHGCG">
                        <p class="titleinexample">例24-19 Intype文件的内容</p><pre class="oac_no_warn" dir="ltr">CASE =低级类型pxl hfile tott95a.h类型px3 hfile tott95b.h</pre></div>
                     <!-- class="example" -->
                     <div class="example" id="GUID-78BE8A56-DD08-42EF-8005-4A7923F84582__CIHEIIFH">
                        <p class="titleinexample">示例24-20从命令行调用OTT</p><pre class="oac_no_warn" dir="ltr">ott scott tott95i.typ outtype = tott95o.typ code = c</pre></div>
                     <!-- class="example" -->
                     <div class="example" id="GUID-78BE8A56-DD08-42EF-8005-4A7923F84582__CIHGGFJH">
                        <p class="titleinexample">示例24-21头文件的内容tott95b.h</p><pre class="oac_no_warn" dir="ltr">#ifndef TOTT95B_ORACLE #define TOTT95B_ORACLE #ifndef OCI_ORACLE #include &lt;oci.h&gt; #endif #ifndef TOTT95A_ORACLE #include“tott95a.h”#endif typedef OCIRef px3_ref; struct px3 {struct px1 col1; }; typedef struct px3 px3; struct px3_ind {OCIInd _atomic; struct px1_ind col1}; typedef struct px3_ind px3_ind; ＃万一</pre></div>
                     <!-- class="example" -->
                     <div class="example" id="GUID-78BE8A56-DD08-42EF-8005-4A7923F84582__CIHGFIEC">
                        <p class="titleinexample">示例24-22头文件的内容tott95a.h</p><pre class="oac_no_warn" dir="ltr">#ifndef TOTT95A_ORACLE #define TOTT95A_ORACLE #ifndef OCI_ORACLE #include &lt;oci.h&gt; #endif typedef OCIRef px1_ref; struct px1 {OCINumber col1; OCINumber col2; } typedef struct px1 px1; struct px1_ind {OCIInd _atomic; OCIInd col1; OCIInd col2; } typedef struct px1_ind px1_ind; ＃万一</pre></div>
                     <!-- class="example" -->
                     <div class="example" id="GUID-78BE8A56-DD08-42EF-8005-4A7923F84582__CIHEDJIA">
                        <p class="titleinexample">示例24-23用于有条件地包含头文件tott95b.h的构造</p><pre class="oac_no_warn" dir="ltr">#ifndef TOTT95B_ORACLE #include“tott95b.h”#endif</pre></div>
                     <!-- class="example" -->
                  </div>
               </div><a id="LNOCI17090"></a><div class="props_rev_3"><a id="GUID-43ADCF30-F829-4E8A-BB24-EC31A372CED6" name="GUID-43ADCF30-F829-4E8A-BB24-EC31A372CED6"></a><h4 id="LNOCI-GUID-43ADCF30-F829-4E8A-BB24-EC31A372CED6" class="sect4"><span class="enumeration_section">24.7.6</span> SCHEMA_NAMES用法</h4>
                  <div>
                     <p><code class="codeph">SCHEMA_NAMES</code>参数会影响OTT所连接的默认架构中的类型名称是否使用outtype文件中的架构名称进行限定。
                     </p>
                     <div class="section">
                        <p>此参数会影响OTT所连接的默认架构中的类型名称是否使用outtype文件中的架构名称进行限定。</p>
                        <p>除默认架构之外的架构中的类型名称始终使用outtype文件中的架构名称进行限定。</p>
                        <p>模式名称或其缺席确定在程序执行期间在哪个模式中找到类型。</p>
                        <p>有三种设置：</p>
                        <ul style="list-style-type:disc">
                           <li>
                              <p><code class="codeph">schema_names=ALWAYS</code> （默认）</p>
                              <p>outtype文件中的所有类型名称都使用模式名称限定。</p>
                           </li>
                           <li>
                              <p><code class="codeph">schema_names = IF_NEEDED</code></p>
                              <p>outtype文件中属于默认架构的类型名称不使用架构名称限定。与往常一样，属于其他模式的类型名称使用模式名称限定。</p>
                           </li>
                           <li>
                              <p><code class="codeph">schema_names = FROM_INTYPE</code></p>
                              <p>intype文件中提到的类型在outtype文件中使用模式名称限定，当且仅当它在intype文件中使用模式名称限定时。默认模式中未在intype文件中提及但由于类型依赖性而必须生成的类型仅在OTT遇到的依赖于它的第一个类型使用模式名称编写时才使用模式名称编写。但是，不在OTT所连接的默认架构中的类型始终使用显式架构名称编写。</p>
                           </li>
                        </ul>
                        <p>OTT生成的outtype文件是Pro * C / C ++的输入参数。从Pro * C / C ++的角度来看，它是Pro * C / C ++ intype文件。此文件将数据库类型名称与C结构名称匹配。在运行时使用此信息以确保在结构中选择了正确的数据库类型。如果在outtype文件（Pro * C / C ++ intype文件）中出现带有模式名称的类型，则在程序执行期间会在命名模式中找到该类型。如果类型显示没有架构名称，则在程序连接的默认架构中找到类型，这可能与OTT使用的默认架构不同。</p>
                        <p>本节包括以下主题： <a href="using-object-type-translator-in-oci.html#GUID-739C795B-9AF2-4950-BEC3-A7D9E658EA17" title="显示使用SCHEMA_NAMES参数的示例。">示例：Schema_Names用法</a> 。
                        </p>
                     </div>
                     <!-- class="section" -->
                  </div><a id="LNOCI17091"></a><div class="props_rev_3"><a id="GUID-739C795B-9AF2-4950-BEC3-A7D9E658EA17" name="GUID-739C795B-9AF2-4950-BEC3-A7D9E658EA17"></a><h5 id="LNOCI-GUID-739C795B-9AF2-4950-BEC3-A7D9E658EA17" class="sect5"><span class="enumeration_section">24.7.6.1</span>示例：Schema_Names用法</h5>
                     <div>
                        <p>显示使用<code class="codeph">SCHEMA_NAMES</code>参数的示例。
                        </p>
                        <p>假设<code class="codeph">SCHEMA_NAMES</code>设置为<code class="codeph">FROM_INTYPE</code> ，intype文件如下所示：</p><pre class="oac_no_warn" dir="ltr">TYPE Person TYPE david。部门类型山姆。公司</pre><p>然后使用OTT生成的结构的Pro * C / C ++应用程序使用<code class="codeph">sam.类型<code class="codeph">sam.Company</code> ， <code class="codeph">david.Dept</code>和<code class="codeph">Person</code> 。使用<code class="codeph">Person</code>没有模式的名称指的是<code class="codeph">Person</code>在该申请被连接在模式类型。
                        </p>
                        <p>如果OTT和应用程序都连接到架构<code class="codeph">david</code> ，则应用程序使用相同的类型（ <code class="codeph">david.Person</code> ），其OTT使用。如果OTT连接到架构<code class="codeph">david</code>但应用程序连接到架构<code class="codeph">jana</code> ，则应用程序使用<code class="codeph">jana.类型<code class="codeph">jana.Person</code>仅当在架构<code class="codeph">david</code>和架构<code class="codeph">jana</code>执行了相同的“ <code class="codeph">CREATE TYPE Person</code> ”语句时，此行为才适用。
                        </p>
                        <p>相反，应用程序使用类型<code class="codeph">david.无论应用程序连接到哪个架构，都要Dept</code> 。如果这是您想要的行为，请确保在intype文件中包含带有类型名称的模式名称。
                        </p>
                        <p>在某些情况下，OTT会转换用户未明确命名的类型。例如，请考虑以下SQL声明：</p><pre class="oac_no_warn" dir="ltr">CREATE TYPE地址AS OBJECT（街道VARCHAR2（40），城市VARCHAR（30），州CHAR（2），zip_code CHAR（10））; CREATE TYPE Person AS OBJECT（名称CHAR（20），年龄NUMBER，地址ADDRESS）;</pre><p>现在假设OTT连接到schema <code class="codeph">david</code> ，指定了<code class="codeph">SCHEMA_NAMES=FROM_INTYPE</code> ，并且用户的intype文件包括TYPE <code class="codeph">Person</code>或TYPE <code class="codeph">david.Person</code>
                        </p>
                        <p>但是，intype文件没有提到类型<code class="codeph">david.Address</code> ，用作<code class="codeph">david.类型中的嵌套对象类型<code class="codeph">david.Person</code>如果“ <code class="codeph">TYPE david.Person</code> “出现在intype文件中，然后” <code class="codeph">TYPE david.Person</code> “和” <code class="codeph">TYPE david.Address</code> “出现在outtype文件中。如果intype文件中出现“ <code class="codeph">Type Person</code> ”，则outtype文件中会出现“ <code class="codeph">TYPE Person</code> ”和“ <code class="codeph">TYPE Address</code> ”。
                        </p>
                        <p>如果是<code class="codeph">david.Address</code>类型嵌入在由OTT翻译的几种类型中，但未在intype文件中明确提及，是否使用模式名称的决定是在OTT第一次遇到嵌入式<code class="codeph">david.时做出的<code class="codeph">david.Address</code>类型。如果由于某种原因，用户想要类型<code class="codeph">david.Address</code>有一个架构名称，但不希望类型<code class="codeph">Person</code>有一个，用户应明确指定输入法菜单文件如下：</p><pre class="oac_no_warn" dir="ltr">TYPE大卫。地址</pre><p>在通常情况下，每个类型都在单个模式中声明，用户最安全的方法是使用intype文件中的模式名称限定所有类型名称。</p>
                     </div>
                  </div>
               </div><a id="LNOCI17092"></a><div class="props_rev_3"><a id="GUID-21CFD247-6655-4F3F-8322-E4344BF20318" name="GUID-21CFD247-6655-4F3F-8322-E4344BF20318"></a><h4 id="LNOCI-GUID-21CFD247-6655-4F3F-8322-E4344BF20318" class="sect4"><span class="enumeration_section">24.7.7</span>默认名称映射</h4>
                  <div>
                     <p>当OTT为对象类型或属性创建C标识符名称时，它会将名称从数据库字符集转换为合法的C标识符。</p>
                     <p>首先，名称从数据库字符集转换为OTT使用的字符集。接下来，如果在intype文件中提供了结果名称的翻译，则使用该翻译。否则，OTT将字符逐字符转换为编译器字符集，并应用<code class="codeph">CASE</code>选项。以下更详细地描述该过程。
                     </p>
                     <p>当OTT读取数据库实体的名称时，该名称将自动从数据库字符集转换为OTT使用的字符集。为了使OTT成功读取数据库实体的名称，必须在OTT字符集中找到名称的所有字符，尽管字符在两个字符集中可以具有不同的编码。</p>
                     <p>保证OTT使用的字符集包含所有必需字符的最简单方法是使其与数据库字符集相同。但请注意，OTT字符集必须是编译器字符集的超集。也就是说，如果编译器字符集是7位ASCII，则OTT字符集必须包含7位ASCII作为子集，如果编译器字符集是7位EBCDIC，则OTT字符集必须包含7位EBCDIC作为一个子集。用户通过设置<code class="codeph">NLS_LANG</code>环境变量或某些其他特定于操作系统的机制来指定OTT使用的字符集。
                     </p>
                     <p>一旦OTT读取了数据库实体的名称，它就会将名称从OTT使用的字符集转换为编译器的字符集。如果名称的翻译出现在intype文件中，OTT将使用该翻译。</p>
                     <p>否则，OTT会尝试使用以下步骤翻译名称：</p>
                     <ol>
                        <li>
                           <p>如果OTT字符集是多字节字符集，则名称中具有单字节等效字符的所有多字节字符将转换为那些单字节等效字符。</p>
                        </li>
                        <li>
                           <p>名称从OTT字符集转换为编译器字符集。编译器字符集是单字节字符集，例如US7ASCII。</p>
                        </li>
                        <li>
                           <p>字母的大小是根据有效的<code class="codeph">CASE</code>选项设置的，并且任何在C标识符中不合法或在编译器字符集中没有翻译的字符都将被下划线替换。如果至少有一个字符被下划线替换，OTT会发出警告消息。如果名称中的所有字符都被下划线替换，OTT会给出错误消息。
                           </p>
                        </li>
                     </ol>
                     <p>逐个字符的名称转换不会改变编译器字符集中出现的下划线，数字或单字节字母，因此不会更改合法的C标识符。</p>
                     <p>例如，名称翻译可以将重音单字节字符（例如带有变音符号的“o”或带有重音符号的“a”翻译为“o”或“a”），并且可以将多字节字母翻译为其单字节等效字符。如果名称包含缺少单字节等效项的多字节字符，则名称转换通常会失败。在这种情况下，用户必须在intype文件中指定名称翻译。</p>
                     <p>OTT不检测由两个或多个数据库标识符映射到同一C名称引起的命名冲突，也不检测数据库标识符映射到C关键字的命名问题。</p>
                  </div>
               </div><a id="LNOCI17093"></a><div class="props_rev_3"><a id="GUID-6250D4A2-A45E-4CB0-8B4D-3ECC83D72C6F" name="GUID-6250D4A2-A45E-4CB0-8B4D-3ECC83D72C6F"></a><h4 id="LNOCI-GUID-6250D4A2-A45E-4CB0-8B4D-3ECC83D72C6F" class="sect4"><span class="enumeration_section">24.7.8</span> OTT对文件名比较的限制</h4>
                  <div>
                     <p>目前，OTT通过比较用户在命令行或intype文件中提供的文件名来确定两个文件是否相同。</p>
                     <p>但是当OTT需要知道两个文件名是否引用同一文件时，可能会出现一个潜在的问题。例如，如果OTT生成的文件<code class="codeph">foo.h</code>要求写入类型声明<code class="codeph">foo1.h</code> ，并写入到另一个类型声明<code class="codeph">/private/elias/foo1.h</code> ，OTT应该产生一个<code class="codeph">#include</code>指令，如果这两个文件是相同，如果文件不同，则有两个<code class="codeph">#includes</code>指令。但实际上，它会得出结论，这两个文件是不同的，并会生成两个<code class="codeph">#includes</code>指令，如下所示：</p><pre class="oac_no_warn" dir="ltr">#ifndef FOO1_ORACLE #include“foo1.h”#endif #ifndef FOO1_ORACLE #include“/private/elias/foo1.h”#endif</pre><p>如果<code class="codeph">foo1.h</code>和<code class="codeph">/private/elias/foo1.h</code>是不同的文件，则只包含第一个文件。如果<code class="codeph">foo1.h</code>和<code class="codeph">/private/elias/foo1.h</code>是同一个文件，则写入冗余的<code class="codeph">#include</code>指令。
                     </p>
                     <p>因此，如果在命令行或intype文件中多次提到文件，则每次提及该文件时应使用完全相同的文件名。</p>
                  </div>
               </div>
               <div class="props_rev_3"><a id="GUID-62F0809F-90E1-47BF-A005-01E48857902A" name="GUID-62F0809F-90E1-47BF-A005-01E48857902A"></a><h4 id="LNOCI-GUID-62F0809F-90E1-47BF-A005-01E48857902A" class="sect4"><span class="enumeration_section">24.7.9</span> Microsoft Windows上的OTT命令</h4>
                  <div>
                     <p>当前版本中Microsoft Windows上的OTT可执行文件是<code class="codeph">ott.bat</code> ，而不是早期版本中的<code class="codeph">ott.exe</code> 。
                     </p>
                     <p>这可能会破坏Windows批处理脚本，因为脚本在执行ott后立即退出。要解决此问题，应在Windows批处理脚本中按如下方式调用OTT：</p><pre class="oac_no_warn" dir="ltr">叫ott [参数]</pre><div class="infoboxnote" id="GUID-62F0809F-90E1-47BF-A005-01E48857902A__GUID-B56BED8A-1A9C-4AA1-8685-24583B80CDAA">
                        <p class="notep1">注意：</p>
                        <p>在修复脚本之前，可以使用<code class="codeph">ORACLE_HOME\precomp\admin\ott.exe</code>作为中间解决方案。但是，将来的版本中不会提供此中间解决方案。
                        </p>
                     </div>
                  </div>
               </div>
            </div>
         </div>
      </article>
   </body>
</html>