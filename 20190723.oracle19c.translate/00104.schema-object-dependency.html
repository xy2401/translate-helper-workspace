<html lang="en-us" dir="ltr" xml:lang="en-us">
   <head>
      <meta http-equiv="Content-Type" content="text/html; charset=utf-8"></meta>
      <meta name="viewport" content="width=device-width, initial-scale=1"></meta>
      <meta http-equiv="X-UA-Compatible" content="IE=edge"></meta>
      <title>了解架构对象依赖关系</title>
      <meta property="og:site_name" content="Oracle Help Center"></meta>
      <meta property="og:title" content="Database Development Guide"></meta>
      <meta property="og:description" content=""></meta>
      <link rel="stylesheet" href="/sp_common/book-template/ohc-book-template/css/book.css"></link>
      <link rel="shortcut icon" href="/sp_common/book-template/ohc-common/img/favicon.ico"></link>
      <meta name="application-name" content="Database Development Guide"></meta>
      <meta name="generator" content="DITA Open Toolkit version 1.8.5 (Mode = doc)"></meta>
      <meta name="plugin" content="SP_docbuilder HTML plugin release 18.2.2"></meta>
      <link rel="alternate" href="database-development-guide.pdf" title="PDF File" type="application/pdf"></link>
      <meta name="robots" content="all"></meta>
      <link rel="schema.dcterms" href="http://purl.org/dc/terms/"></link>
      <meta name="dcterms.created" content="2019-01-31T23:23:15-08:00"></meta>
      <meta name="dcterms.title" content="Database Development Guide"></meta>
      <meta name="dcterms.dateCopyrighted" content="1996, 2019"></meta>
      <meta name="dcterms.category" content="database"></meta>
      <meta name="dcterms.identifier" content="E96334-02"></meta>
      
      <meta name="dcterms.product" content="en/database/oracle/oracle-database/19"></meta>
      
      <link rel="prev" href="identity-code.html" title="Previous" type="text/html"></link>
      <link rel="next" href="editions.html" title="Next" type="text/html"></link>
      <script>
        document.write('<style type="text/css">');
        document.write('body > .noscript, body > .noscript ~ * { visibility: hidden; }');
        document.write('</style>');
     </script>
      <script src="/sp_common/book-template/requirejs/require.js" data-main="/sp_common/book-template/ohc-book-template/js/book-config"></script>
      <script>
            if (window.require === undefined) {
                document.write('<script data-main="sp_common/book-template/ohc-book-template/js/book-config" src="sp_common/book-template/requirejs/require.js"><\/script>');
                document.write('<link href="sp_common/book-template/ohc-book-template/css/book.css" rel="stylesheet"/>');
            }
        </script>
      <script type="application/json" id="ssot-metadata">{"primary":{"category":{"short_name":"database","element_name":"Database","display_in_url":true},"suite":{"short_name":"oracle","element_name":"Oracle","display_in_url":true},"product_group":{"short_name":"not-applicable","element_name":"Not applicable","display_in_url":false},"product":{"short_name":"oracle-database","element_name":"Oracle Database","display_in_url":true},"release":{"short_name":"19","element_name":"Release 19","display_in_url":true}}}</script>
      
    <meta name="dcterms.isVersionOf" content="ADFNS"></meta>
    <meta name="dcterms.release" content="Release 19"></meta>
  </head>
   <body dir="ltr">
      <div class="noscript alert alert-danger text-center" role="alert">
         <a href="identity-code.html" class="pull-left"><span class="glyphicon glyphicon-chevron-left" aria-hidden="true"></span>上一页</a> <a href="editions.html" class="pull-right">下一页<span class="glyphicon glyphicon-chevron-right" aria-hidden="true"></span></a> <span class="fa fa-exclamation-triangle" aria-hidden="true"></span>必须启用JavaScript才能正确显示此内容</div>
      <article>
         <header>
            <ol class="breadcrumb" vocab="http://schema.org/" typeof="BreadcrumbList">
               <li property="itemListElement" typeof="ListItem"><a href="index.html" property="item" typeof="WebPage"><span property="name">数据库开发指南</span></a></li>
               <li property="itemListElement" typeof="ListItem"><a href="advanced-part.html" property="item" typeof="WebPage"><span property="name">应用程序开发人员的高级主题</span></a></li>
               <li class="active" property="itemListElement" typeof="ListItem">了解架构对象依赖关系</li>
            </ol>
            <a id="GUID-488AF7D9-EDEB-4589-A503-FDE31CE55B60" name="GUID-488AF7D9-EDEB-4589-A503-FDE31CE55B60"></a><a id="ADFNS1265"></a><a id="ADFNS99967"></a>
            
            <h2 id="ADFNS-GUID-488AF7D9-EDEB-4589-A503-FDE31CE55B60" class="sect2"><span class="enumeration_chapter">26</span>了解架构对象依赖关系</h2>
         </header>
         <div class="ind"><script type="text/javascript">window.name='schema-object-dependency'</script><script type="text/javascript">
    function footdisplay(footnum,footnote) {
    var msg = window.open('about:blank', 'NewWindow' + footnum,
        'directories=no,height=100,location=no,menubar=no,resizable=yes,' +
        'scrollbars=yes,status=no,toolbar=no,width=598');
    msg.document.open('text/html');
    msg.document.write('<!DOCTYPE html ');
    msg.document.write('PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" ');
    msg.document.write('"http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">'); 
    msg.document.write('<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en-us" lang="en-us" dir="ltr"><head><title>');
   
    msg.document.write('Footnote&nbsp; ' + footnum);
    msg.document.write('<\/title><meta http-equiv="Content-Type" ');
    msg.document.write('content="text/html; charset=utf-8" />');
    msg.document.write('<meta http-equiv="Content-Script-Type" ');
    msg.document.write('content="text/javascript" />');
    msg.document.write('<style type="text/css"> <![CDATA[ ');
    msg.document.write('h1 {text-align: center; font-size: 14pt;}');
    msg.document.write('fieldset {border: none;}');
    msg.document.write('form {text-align: center;}');
    msg.document.write(' ]]u003e </style>');
    msg.document.write('<\/head><body><div id="footnote"><h1>Footnote&nbsp; ' + footnum + '<\/h1><p>');
    msg.document.write(footnote);
    msg.document.write('<\/p><form action="" method="post"><fieldset>');
    msg.document.write('<input type="button" value="OK" ');
    msg.document.write('onclick="window.close();" />');
    msg.document.write('<\/fieldset><\/form><\/div><\/body><\/html>');
    msg.document.close();
    setTimeout(function() {
        var height = msg.document.getElementById('footnote').offsetHeight;
        msg.resizeTo(598, height + 100);
    }
    , 100);
    msg.focus();
}
            </script><noscript>
               <p>此页面上的脚本内容仅用于导航目的，不会以任何方式更改内容。</p>
            </noscript>
            <div>
               <p>如果对象A的定义引用了对象B，那么A依赖于B.本章解释了模式对象之间的依赖关系，以及Oracle数据库如何自动跟踪和管理这些依赖关系。由于这种自动依赖关系管理，A从不使用过时的B版本，因此在更改B之后几乎不必显式重新编译A.</p>
               <div class="section">
                  <p class="subhead1" id="GUID-488AF7D9-EDEB-4589-A503-FDE31CE55B60__GUID-BA3EFC75-810E-4BC3-B809-DF6B35C67028">话题：</p>
               </div>
               <!-- class="section" -->
               <ul style="list-style-type:disc">
                  <li>
                     <p><a href="schema-object-dependency.html#GUID-68D487A4-6E48-4F48-8D97-AF560B93883E">架构对象依赖关系概述</a></p>
                  </li>
                  <li>
                     <p><a href="schema-object-dependency.html#GUID-59F717D6-1DD8-4D75-B14E-775E165BFE0A">查询对象依赖项</a></p>
                  </li>
                  <li>
                     <p><a href="schema-object-dependency.html#GUID-5795239E-C70B-424E-9757-710A37AD6F51">对象状态</a></p>
                  </li>
                  <li>
                     <p><a href="schema-object-dependency.html#GUID-AEC8DF50-2AC2-4697-8CA9-F13108FBB810">从属对象的无效</a></p>
                  </li>
                  <li>
                     <p><a href="schema-object-dependency.html#GUID-48B8583D-A1F9-4B09-AE64-A5116D50B34F">减少失效的指南</a></p>
                  </li>
                  <li>
                     <p><a href="schema-object-dependency.html#GUID-7FC0ABCA-52B1-4244-AD12-017F6E89AB99">对象重新验证</a></p>
                  </li>
                  <li>
                     <p><a href="schema-object-dependency.html#GUID-46C57DB9-847E-4709-9587-0673CCC5E5F0">架构范围中的名称解析</a></p>
                  </li>
                  <li>
                     <p><a href="schema-object-dependency.html#GUID-0E05699C-604F-41A5-B76E-7216CF25C913">本地依赖管理</a></p>
                  </li>
                  <li>
                     <p><a href="schema-object-dependency.html#GUID-D89D3306-9B7A-443F-BD64-81D4808E8EFC">远程依赖管理</a></p>
                  </li>
                  <li>
                     <p><a href="schema-object-dependency.html#GUID-B99E885E-900F-4F29-A188-A617A301FDCE">远程过程调用（RPC）依赖关系管理</a></p>
                  </li>
                  <li>
                     <p><a href="schema-object-dependency.html#GUID-FEDD8B95-890A-43B2-BB6D-C2D2C17E8278">共享SQL依赖关系管理</a></p>
                  </li>
               </ul>
            </div><a id="ADFNS887"></a><a id="ADFNS888"></a><a id="ADFNS889"></a><a id="ADFNS99966"></a><div class="props_rev_3"><a id="GUID-68D487A4-6E48-4F48-8D97-AF560B93883E" name="GUID-68D487A4-6E48-4F48-8D97-AF560B93883E"></a><h3 id="ADFNS-GUID-68D487A4-6E48-4F48-8D97-AF560B93883E" class="sect3">架构对象依赖关系概述</h3>
               <div>
                  <p>某些类型的模式对象可以在其定义中引用其他对象。例如，视图由引用表或其他视图的查询定义，子程序的主体可以包含引用其他对象的SQL语句。如果对象A的定义引用对象B，则A是<span class="bold">依赖对象</span> （B），B是<span class="bold">引用对象</span> （A）。
                  </p>
               </div>
               <div class="sect3"><a id="GUID-6909F672-2934-406C-91DB-1E003CCA35E3" name="GUID-6909F672-2934-406C-91DB-1E003CCA35E3"></a><h4 id="ADFNS-GUID-6909F672-2934-406C-91DB-1E003CCA35E3" class="sect4">示例：显示从属和引用的对象类型</h4>
                  <div>
                     <p><a href="schema-object-dependency.html#GUID-6909F672-2934-406C-91DB-1E003CCA35E3__BABJDJDE">例26-1</a>显示了如何在数据库中显示相关和引用的对象类型（如果以DBA身份登录）。
                     </p>
                     <div class="example" id="GUID-6909F672-2934-406C-91DB-1E003CCA35E3__BABJDJDE">
                        <p class="titleinexample">示例26-1显示从属和引用的对象类型</p>
                        <p>显示依赖对象类型：</p><pre class="oac_no_warn" dir="ltr">从DBA_DEPENDENCIES中选择DISTINCT类型按类型排序;</pre><p>结果：</p><pre class="oac_no_warn" dir="ltr">类型------------------尺寸评估字典功能索引类型JAVA类JAVA数据材料化视图操作员包装包装程序规则规则同步表触发器类型类型未定义视图XML模式22选中的行。
</pre><p>显示引用的对象类型：</p><pre class="oac_no_warn" dir="ltr">从DBA_DEPENDENCIES中选择DISTINCT REFERENCED_TYPE按REFERENCED_TYPE排序;</pre><p>结果：</p><pre class="oac_no_warn" dir="ltr">REFERENCED_TYPE ------------------评估环境功能索引INDEXTYPE JAVA类库操作员程序包程序序列同义表类型视图XML SCHEMA选择14行。
</pre><p>如果更改引用对象的定义，则依赖对象可能无法继续运行而不会出现错误，具体取决于更改的类型。例如，如果删除表，则不会使用基于删除表的视图。</p>
                     </div>
                     <!-- class="example" -->
                  </div>
               </div>
               <div class="sect3"><a id="GUID-C7E7C5EA-51C7-4C39-B290-CB37FB7F6642" name="GUID-C7E7C5EA-51C7-4C39-B290-CB37FB7F6642"></a><h4 id="ADFNS-GUID-C7E7C5EA-51C7-4C39-B290-CB37FB7F6642" class="sect4">示例：使某些依赖项无效的模式对象更改</h4>
                  <div>
                     <p>作为模式对象更改的一个示例，它使某些依赖项无效，但不考虑其他依赖项，请考虑以下示例中的两个视图，它们基于<code class="codeph">HR</code> 。 <code class="codeph">EMPLOYEES</code>表。
                     </p>
                     <p><a href="schema-object-dependency.html#GUID-C7E7C5EA-51C7-4C39-B290-CB37FB7F6642__BABJEGJA">例26-2</a>从<code class="codeph">EMPLOYEES</code>表创建了两个视图： <code class="codeph">SIXFIGURES</code> ，它选择表中的所有列，以及<code class="codeph">COMMISSIONED</code> ，它不包括<code class="codeph">EMAIL</code>列。如示例所示，更改<code class="codeph">EMAIL</code>列会使<code class="codeph">SIXFIGURES</code>无效，但不会使<code class="codeph">COMMISSIONED</code>无效。</p>
                     <div class="example" id="GUID-C7E7C5EA-51C7-4C39-B290-CB37FB7F6642__BABJEGJA">
                        <p class="titleinexample">示例26-2使某些依赖项无效的模式对象更改</p><pre class="oac_no_warn" dir="ltr">创建或替换视图六个数字AS SELECT * FROM employees WHERE salary&gt; = 100000;委托AS SELECT first_name，last_name，commission_pct FROM employees WHERE commission_pct&gt; 0.00;创建或替换VIEW</pre><p>SQL * Plus格式化命令：</p><pre class="oac_no_warn" dir="ltr">COLUMN object_name FORMAT A16</pre><p>查询：</p><pre class="oac_no_warn" dir="ltr">SELECT object_name，status FROM user_objects WHERE object_type ='VIEW'ORDER BY object_name;</pre><p>结果：</p><pre class="oac_no_warn" dir="ltr">OBJECT_NAME状态---------------- -------委托有效EMP_DETAILS_VIEW VALID SIXFIGURES INVALID选择了3行。
</pre><p>延长<code class="codeph">EMPLOYEES</code>表的<code class="codeph">EMAIL</code>列：</p><pre class="oac_no_warn" dir="ltr">ALTER TABLE员工MODIFY电子邮件VARCHAR2（ <span class="bold">100</span> ）;</pre><p>查询：</p><pre class="oac_no_warn" dir="ltr">SELECT object_name，status FROM user_objects WHERE object_type ='VIEW'ORDER BY object_name;</pre><p>结果：</p><pre class="oac_no_warn" dir="ltr">OBJECT_NAME状态---------------- -------委托有效EMP_DETAILS_VIEW无效六位数有效</pre></div>
                     <!-- class="example" -->
                  </div>
               </div>
               <div class="sect3"><a id="GUID-326F840E-2A72-4C0E-85E6-16BA983453FF" name="GUID-326F840E-2A72-4C0E-85E6-16BA983453FF"></a><h4 id="ADFNS-GUID-326F840E-2A72-4C0E-85E6-16BA983453FF" class="sect4">示例：取决于多个对象的视图</h4>
                  <div>
                     <p>视图取决于其查询中引用的每个对象。<a href="schema-object-dependency.html#GUID-326F840E-2A72-4C0E-85E6-16BA983453FF__CHDEECCI">例26-3中</a>的视图取决于表<code class="codeph">employees</code>和<code class="codeph">departments</code> 。
                     </p>
                     <div class="example" id="GUID-326F840E-2A72-4C0E-85E6-16BA983453FF__CHDEECCI">
                        <p class="titleinexample">示例26-3取决于多个对象的视图</p><pre class="oac_no_warn" dir="ltr">创建或替换视图v选择last_name，first_name，department_name FROM <span class="bold">employees</span> e， <span class="bold">departments</span> d WHERE e.department_id = d.department_id ORDER BY last_name;</pre><p>请注意以下事项：</p>
                        <ul style="list-style-type:disc">
                           <li>
                              <p><code class="codeph">CREATE</code>语句自动更新所有依赖项。
                              </p>
                           </li>
                           <li>
                              <p>动态SQL语句不会创建依赖项。例如，此语句不会对<code class="codeph">tab1</code>创建依赖关系：</p><pre class="oac_no_warn" dir="ltr">EXECUTE IMMEDIATE'SELECT * FROM tab1'</pre></li>
                        </ul>
                     </div>
                     <!-- class="example" -->
                  </div>
               </div>
            </div><a id="ADFNS99994"></a><div class="props_rev_3"><a id="GUID-59F717D6-1DD8-4D75-B14E-775E165BFE0A" name="GUID-59F717D6-1DD8-4D75-B14E-775E165BFE0A"></a><h3 id="ADFNS-GUID-59F717D6-1DD8-4D75-B14E-775E165BFE0A" class="sect3">查询对象依赖项</h3>
               <div>
                  <p>静态数据字典视图<code class="codeph">USER_DEPENDENCIES</code> ， <code class="codeph">ALL_DEPENDENCIES</code>和<code class="codeph">DBA_DEPENDENCIES</code>描述数据库对象之间的依赖关系。
                  </p>
                  <p>该<code class="codeph">utldtree.sql</code> SQL脚本创建视图<code class="codeph">DEPTREE</code> ，其中包含有关对象依赖关系树的信息，以及查看<code class="codeph">IDEPTREE</code> ，一个预先排序，漂亮地打印版本<code class="codeph">DEPTREE</code> 。</p>
                  <div class="infoboxnotealso" id="GUID-59F717D6-1DD8-4D75-B14E-775E165BFE0A__GUID-163B42C7-76DB-44CC-BB2C-3E02C027B1A5">
                     <p class="notep1">也可以看看：</p>
                     <p>有关<a href="https://www.oracle.com/pls/topic/lookup?ctx=en/database/oracle/oracle-database/19/adfns&amp;id=REFRN29083" target="_blank"><code class="codeph">DEPTREE</code></a> ， <a href="../refrn/DEPTREE.html#REFRN29083" target="_blank"><code class="codeph">IDEPTREE</code></a>和<a href="https://www.oracle.com/pls/topic/lookup?ctx=en/database/oracle/oracle-database/19/adfns&amp;id=REFRN-GUID-571DA1D1-5274-4763-99B4-B1FF60E79F9F" target="_blank"><code class="codeph">utldtree.sql</code></a>脚本的详细信息，请<a href="../refrn/DEPTREE.html#REFRN29083" target="_blank"><code class="codeph">IDEPTREE</code></a> <span class="italic">Oracle数据库参考</span></p>
                  </div>
               </div>
            </div><a id="ADFNS890"></a><a id="ADFNS99993"></a><div class="props_rev_3"><a id="GUID-5795239E-C70B-424E-9757-710A37AD6F51" name="GUID-5795239E-C70B-424E-9757-710A37AD6F51"></a><h3 id="ADFNS-GUID-5795239E-C70B-424E-9757-710A37AD6F51" class="sect3">对象状态</h3>
               <div>
                  <div class="section">
                     <p>每个数据库对象都具有<a href="schema-object-dependency.html#GUID-5795239E-C70B-424E-9757-710A37AD6F51__CHDHHDAG" title="此表汇总了数据库对象可以具有的状态值。">表26-1中</a>描述的状态值。
                     </p>
                  </div>
                  <!-- class="section" -->
                  <div class="tblformal" id="GUID-5795239E-C70B-424E-9757-710A37AD6F51__CHDHHDAG">
                     <p class="titleintable">表26-1数据库对象状态</p>
                     <table cellpadding="4" cellspacing="0" class="Formal" title="数据库对象状态" width="100%" border="1" summary="This table summarizes the status values that database objects can have." frame="hsides" rules="rows">
                        <thead>
                           <tr align="left" valign="top">
                              <th align="left" valign="bottom" width="26%" id="d156312e962">状态</th>
                              <th align="left" valign="bottom" width="74%" id="d156312e965">含义</th>
                           </tr>
                        </thead>
                        <tbody>
                           <tr align="left" valign="top">
                              <td align="left" valign="top" width="26%" id="d156312e970" headers="d156312e962 ">
                                 <p>有效</p>
                              </td>
                              <td align="left" valign="top" width="74%" headers="d156312e970 d156312e965 ">
                                 <p>使用数据字典中的当前定义成功编译了对象。</p>
                              </td>
                           </tr>
                           <tr align="left" valign="top">
                              <td align="left" valign="top" width="26%" id="d156312e977" headers="d156312e962 ">
                                 <p>编译错误</p>
                              </td>
                              <td align="left" valign="top" width="74%" headers="d156312e977 d156312e965 ">
                                 <p>最近编译对象的尝试产生了错误。</p>
                              </td>
                           </tr>
                           <tr align="left" valign="top">
                              <td align="left" valign="top" width="26%" id="d156312e984" headers="d156312e962 ">
                                 <p>无效</p>
                              </td>
                              <td align="left" valign="top" width="74%" headers="d156312e984 d156312e965 ">
                                 <p>该对象标记为无效，因为它引用的对象已更改。（只有依赖对象可能无效。）</p>
                              </td>
                           </tr>
                           <tr align="left" valign="top">
                              <td align="left" valign="top" width="26%" id="d156312e991" headers="d156312e962 ">
                                 <p>擅自</p>
                              </td>
                              <td align="left" valign="top" width="74%" headers="d156312e991 d156312e965 ">
                                 <p>已撤消对引用对象的访问权限。（只有依赖对象可能是未经授权的。）</p>
                              </td>
                           </tr>
                        </tbody>
                     </table>
                  </div>
                  <!-- class="inftblhruleinformal" -->
                  <div class="section">
                     <div class="infoboxnote" id="GUID-5795239E-C70B-424E-9757-710A37AD6F51__GUID-596615B0-B7AC-4074-9EB1-15FDB51322CB">
                        <p class="notep1">注意：</p>
                        <p>静态数据字典视图<code class="codeph">USER_OBJECTS</code> ， <code class="codeph">ALL_OBJECTS</code>和<code class="codeph">DBA_OBJECTS</code>不区分“Compiled with errors”，“Invalid”和“Unauthorized” - 它们将所有这些描述为<code class="codeph">INVALID</code> 。</p>
                     </div>
                  </div>
                  <!-- class="section" -->
               </div>
            </div><a id="ADFNS891"></a><a id="ADFNS1266"></a><a id="ADFNS99992"></a><div class="props_rev_3"><a id="GUID-AEC8DF50-2AC2-4697-8CA9-F13108FBB810" name="GUID-AEC8DF50-2AC2-4697-8CA9-F13108FBB810"></a><h3 id="ADFNS-GUID-AEC8DF50-2AC2-4697-8CA9-F13108FBB810" class="sect3">从属对象的无效</h3>
               <div>
                  <p>如果对象A依赖对象B，其取决于对象C上，则A是<span class="bold">直接依赖</span>的B，B是一个直接依赖的C，且A是一个<span class="bold">间接依赖性</span>的C.</p>
                  <p>直接依赖项仅通过对影响它们的引用对象的更改（对引用对象的签名的更改）无效。</p>
                  <p>间接依赖项可以通过对不影响它们的引用对象的更改而失效。如果对C的更改使B无效，则A（以及B的所有其他直接和间接依赖）无效。这称为<span class="bold">级联失效</span> 。
                  </p>
                  <p>使用<span class="bold">粗粒度失效时</span> ，更改引用对象的数据定义语言（DDL）语句会使其所有依赖项无效。
                  </p>
                  <p>通过<span class="bold">细粒度的失效</span> ，更改引用对象的DDL语句仅使这些语句中的任何一个为真的依赖项无效：</p>
                  <ul style="list-style-type:disc">
                     <li>
                        <p>依赖项依赖于DDL语句更改的引用对象的属性。</p>
                     </li>
                     <li>
                        <p>对于已更改的引用对象，已编译的依赖项元数据不再正确。</p>
                     </li>
                  </ul>
                  <p>例如，如果视图<code class="codeph">v</code>从表<code class="codeph">t</code>选择列<code class="codeph">c1</code>和<code class="codeph">c2</code> ，则仅更改<code class="codeph">t</code>列<code class="codeph">c3</code>的DDL语句不会使<code class="codeph">v</code>无效。</p>
                  <p>在这些条件下，DDL语句<code class="codeph">CREATE</code> <code class="codeph">OR</code> <code class="codeph">REPLACE</code> <span class="italic"><code class="codeph">object</code></span>无效：</p>
                  <ul style="list-style-type:disc">
                     <li>
                        <p><span class="italic"><code class="codeph">object</code></span>是PL / SQL对象，新的PL / SQL源文本与现有的PL / SQL源文本相同，与<span class="italic"><code class="codeph">object</code></span>一起存储的PL / SQL编译参数设置与会话环境中的相同。
                        </p>
                     </li>
                     <li>
                        <p><span class="italic"><code class="codeph">object</code></span>是同义词，语句不会更改目标对象。
                        </p>
                     </li>
                  </ul>
                  <p><a href="schema-object-dependency.html#GUID-AEC8DF50-2AC2-4697-8CA9-F13108FBB810__G1008856" title="第1列列出影响对象状态的操作，第2列显示对象的相应结果状态，第3列显示依赖对象的相应结果状态。">表26-2</a>左栏中的操作会导致细粒度失效，但右栏中的情况除外。右列中的案例以及<a href="schema-object-dependency.html#GUID-AEC8DF50-2AC2-4697-8CA9-F13108FBB810__G1008856" title="第1列列出影响对象状态的操作，第2列显示对象的相应结果状态，第3列显示依赖对象的相应结果状态。">表26-2中</a>未列出的所有操作都会导致粗粒度失效。
                  </p>
                  <div class="tblformal" id="GUID-AEC8DF50-2AC2-4697-8CA9-F13108FBB810__G1008856">
                     <p class="titleintable">表26-2导致细粒度无效的操作</p>
                     <table cellpadding="4" cellspacing="0" class="Formal" title="导致细粒度无效的操作" width="100%" border="1" summary="Column 1 lists operations that affect object status, column 2 shows the corresponding resulting status of the object,  and column 3 shows the corresponding resulting status of dependent objects." frame="hsides" rules="rows">
                        <thead>
                           <tr align="left" valign="top">
                              <th align="left" valign="bottom" width="52%" id="d156312e1267">手术</th>
                              <th align="left" valign="bottom" width="48%" id="d156312e1270">例外</th>
                           </tr>
                        </thead>
                        <tbody>
                           <tr align="left" valign="top">
                              <td align="left" valign="top" width="52%" id="d156312e1275" headers="d156312e1267 ">
                                 <p><code class="codeph">ALTER</code> <code class="codeph">TABLE</code> <span class="italic"><code class="codeph">table</code></span> <code class="codeph">ADD</code> <span class="italic"><code class="codeph">column</code></span></p>
                              </td>
                              <td align="left" valign="top" width="48%" headers="d156312e1275 d156312e1270 ">
                                 <ul style="list-style-type:disc">
                                    <li>
                                       <p>从属对象（视图除外）在<span class="italic"><code class="codeph">table</code></span>上使用<code class="codeph">SELECT</code> <code class="codeph">*</code> 。
                                       </p>
                                    </li>
                                    <li>
                                       <p>从属对象使用<span class="italic"><code class="codeph">table</code></span> <code class="codeph">%rowtype</code> 。
                                       </p>
                                    </li>
                                    <li>
                                       <p>从属对象在<span class="italic"><code class="codeph">table</code></span>上执行<code class="codeph">INSERT</code>而不指定列列表。
                                       </p>
                                    </li>
                                    <li>
                                       <p>包含连接的查询中的从属对象引用<span class="italic"><code class="codeph">table</code></span> 。
                                       </p>
                                    </li>
                                    <li>
                                       <p>引用PL / SQL变量的查询中的从属对象引用<span class="italic"><code class="codeph">table</code></span> 。
                                       </p>
                                    </li>
                                 </ul>
                              </td>
                           </tr>
                           <tr align="left" valign="top">
                              <td align="left" valign="top" width="52%" id="d156312e1342" headers="d156312e1267 ">
                                 <p><code class="codeph">ALTER</code> <code class="codeph">TABLE</code> <span class="italic"><code class="codeph">table</code></span> { <code class="codeph">MODIFY</code> | <code class="codeph">RENAME</code> | <code class="codeph">DROP</code> | <code class="codeph">SET</code> <code class="codeph">UNUSED</code> } <span class="italic"><code class="codeph">column</code></span></p>
                                 <p><code class="codeph">ALTER</code> <code class="codeph">TABLE</code> <span class="italic"><code class="codeph">table</code></span> <code class="codeph">DROP</code> <code class="codeph">CONSTRAINT</code> <span class="italic"><code class="codeph">not_null_constraint</code></span></p>
                              </td>
                              <td align="left" valign="top" width="48%" headers="d156312e1342 d156312e1270 ">
                                 <ul style="list-style-type:disc">
                                    <li>
                                       <p>从属对象直接引用<span class="italic"><code class="codeph">column</code></span> 。
                                       </p>
                                    </li>
                                    <li>
                                       <p>从属对象在<span class="italic"><code class="codeph">table</code></span>上使用<code class="codeph">SELECT</code> <code class="codeph">*</code> 。
                                       </p>
                                    </li>
                                    <li>
                                       <p>从属对象使用<span class="italic"><code class="codeph">table</code></span> <code class="codeph">%ROWTYPE</code> 。</p>
                                    </li>
                                    <li>
                                       <p>从属对象在<span class="italic"><code class="codeph">table</code></span>上执行<code class="codeph">INSERT</code>而不指定列列表。
                                       </p>
                                    </li>
                                    <li>
                                       <p>从属对象是一个依赖于整行的触发器（也就是说，它没有在其定义中指定列）。</p>
                                    </li>
                                    <li>
                                       <p>从属对象是一个依赖于已删除列右侧列的触发器。</p>
                                    </li>
                                 </ul>
                              </td>
                           </tr>
                           <tr align="left" valign="top">
                              <td align="left" valign="top" width="52%" id="d156312e1441" headers="d156312e1267 ">
                                 <p><code class="codeph">CREATE</code> <code class="codeph">OR</code> <code class="codeph">REPLACE</code> <code class="codeph">VIEW</code> <span class="italic"><code class="codeph">view</code></span></p>
                                 <p>在线表重新定义（ <code class="codeph">DBMS_REDEFINITION</code> ）</p>
                              </td>
                              <td align="left" valign="top" width="48%" headers="d156312e1441 d156312e1270 ">
                                 <p>新旧定义的列列表不同，其中至少有一个是真的：</p>
                                 <ul style="list-style-type:disc">
                                    <li>
                                       <p>在新视图或表定义中修改或删除的从属对象引用列。</p>
                                    </li>
                                    <li>
                                       <p>从属对象使用<span class="italic"><code class="codeph">view</code></span> <code class="codeph">%rowtype</code>或<span class="italic"><code class="codeph">table</code></span> <code class="codeph">%rowtype</code> 。
                                       </p>
                                    </li>
                                    <li>
                                       <p>从属对象在视图或表上执行<code class="codeph">INSERT</code>而不指定列列表。
                                       </p>
                                    </li>
                                    <li>
                                       <p>新视图定义在包含连接的查询中引入新列和依赖对象引用视图或表。</p>
                                    </li>
                                    <li>
                                       <p>新视图定义在引用PL / SQL变量的查询中引入新列和依赖对象引用视图或表。</p>
                                    </li>
                                    <li>
                                       <p><code class="codeph">RELIES</code> <code class="codeph">ON</code>子句中的从属对象引用视图或表。
                                       </p>
                                    </li>
                                 </ul>
                              </td>
                           </tr>
                           <tr align="left" valign="top">
                              <td align="left" valign="top" width="52%" id="d156312e1507" headers="d156312e1267 ">
                                 <p><code class="codeph">CREATE</code> <code class="codeph">OR</code> <code class="codeph">REPLACE</code> <code class="codeph">SYNONYM</code> <span class="italic"><code class="codeph">synonym</code></span></p>
                              </td>
                              <td align="left" valign="top" width="48%" headers="d156312e1507 d156312e1270 ">
                                 <ul style="list-style-type:disc">
                                    <li>
                                       <p>新旧<span class="italic"><code class="codeph">synonym</code></span>目标不同，一个不是表。
                                       </p>
                                    </li>
                                    <li>
                                       <p>旧的和新的<span class="italic"><code class="codeph">synonym</code></span>目标都是表，并且表具有不同的列列表或不同的权限授予。
                                       </p>
                                    </li>
                                    <li>
                                       <p>旧的和新的<span class="italic"><code class="codeph">synonym</code></span>目标都是表，依赖对象是引用参与旧目标上的唯一索引而不是新目标上的唯一索引的列的视图。
                                       </p>
                                    </li>
                                 </ul>
                              </td>
                           </tr>
                           <tr align="left" valign="top">
                              <td align="left" valign="top" width="52%" id="d156312e1548" headers="d156312e1267 ">
                                 <p><code class="codeph">DROP</code> <code class="codeph">INDEX</code></p>
                              </td>
                              <td align="left" valign="top" width="48%" headers="d156312e1548 d156312e1270 ">
                                 <ul style="list-style-type:disc">
                                    <li>
                                       <p>索引是基于函数的索引，依赖对象是一个触发器，它依赖于整个行或在创建基于函数的索引后添加到<span class="italic"><code class="codeph">table</code></span>的列。
                                       </p>
                                    </li>
                                    <li>
                                       <p>索引是唯一索引，从属对象是视图，视图引用参与唯一索引的列。</p>
                                    </li>
                                 </ul>
                              </td>
                           </tr>
                           <tr align="left" valign="top">
                              <td align="left" valign="top" width="52%" id="d156312e1568" headers="d156312e1267 ">
                                 <p><code class="codeph">CREATE</code> <code class="codeph">OR</code> <code class="codeph">REPLACE</code> <code class="codeph">{PROCEDURE|FUNCTION}</code></p>
                              </td>
                              <td align="left" valign="top" width="48%" headers="d156312e1568 d156312e1270 ">
                                 <p>呼叫签名更改。调用签名是参数列表（顺序，名称和参数类型），返回类型， <code class="codeph">ACCESSIBLE</code> <code class="codeph">BY</code>子句（“白名单”），纯度<a id="fn_1" name="fn_1" href="#fn_1" data="" purity="" refers="" to="" a="" set="" of="" rules="" for="" preventing="" side="" effects="" (such="" as="" unexpected="" changes)="" when="" invoking="" pl="" /sql="" functions="" within="" sql="" queries.="" package="" the="" in="" initialization="" block=")" ="" onclick="footdisplay(1, "><sup>足1</sup></a> ，确定性，并行性，流水线操作，以及（如果过程或函数在C或Java）实现属性。
                                 </p>
                              </td>
                           </tr>
                           <tr align="left" valign="top">
                              <td align="left" valign="top" width="52%" id="d156312e1600" headers="d156312e1267 ">
                                 <p><code class="codeph">CREATE</code> <code class="codeph">OR</code> <code class="codeph">REPLACE</code> <code class="codeph">PACKAGE</code></p>
                              </td>
                              <td align="left" valign="top" width="48%" headers="d156312e1600 d156312e1270 ">
                                 <ul style="list-style-type:disc">
                                    <li>
                                       <p><code class="codeph">ACCESSIBLE</code> <code class="codeph">BY</code>子句（“白名单”）更改。
                                       </p>
                                    </li>
                                    <li>
                                       <p>从属对象引用已删除或重命名的包项。</p>
                                    </li>
                                    <li>
                                       <p>从属对象引用其调用签名或入口点编号<a id="fn_2" name="fn_2" href="#fn_2" the="" entry-point="" number="" of="" a="" procedure="" or="" function="" is="" determined="" by="" its="" location="" in="" pl="" /sql="" package="" code.="" added="" to="" end="" given="" new="" number=")" ="" onclick="footdisplay(2, "><sup>Foot 2已</sup></a>更改的包过程或函数。
                                       </p>
                                       <p>如果引用的过程或函数具有多个重载候选项，则如果任何重载候选者的调用签名或入口点编号已更改，或者添加或删除了候选项，则从属对象将失效。</p>
                                    </li>
                                    <li>
                                       <p>从属对象引用其调用签名，行类型或入口点编号已更改的包光标。</p>
                                    </li>
                                    <li>
                                       <p>从属对象引用其定义已更改的包类型或子类型。</p>
                                    </li>
                                    <li>
                                       <p>从属对象引用其名称，数据类型，初始值或偏移号已更改的包变量或常量。</p>
                                    </li>
                                    <li>
                                       <p>包装纯度<sup>1</sup>改变了。
                                       </p>
                                    </li>
                                 </ul>
                              </td>
                           </tr>
                        </tbody>
                     </table>
                  </div>
                  <!-- class="inftblhruleinformal" -->
                  <p class="tablefootnote"><sup class="tablefootnote">脚注1</sup></p><p><span class="bold">纯度</span>是指在SQL查询中调用PL / SQL函数时用于防止副作用（例如意外数据更改）的一组规则。<span class="bold">包纯度</span>是指包初始化块中代码的纯度。
                     </p>
                  <p></p>
                  <p class="tablefootnote"><sup class="tablefootnote">脚注2</sup></p><p>过程或函数的<span class="bold">入口点编号</span>由其在PL / SQL包代码中的位置确定。添加到PL / SQL包末尾的过程或函数将获得一个新的入口点编号。
                     </p>
                  <p></p>
                  <div class="infoboxnote" id="GUID-AEC8DF50-2AC2-4697-8CA9-F13108FBB810__GUID-C3EC59D9-3545-43E3-83D9-CF2137C7FBE1">
                     <p class="notep1">注意：</p>
                     <p>只有在尝试引用它（在编译或执行期间）或在调用其中一个子程序之后，静态数据字典视图<code class="codeph">*_OBJECTS</code>和<code class="codeph">*_OBJECTS_AE</code>才会出现由<a href="schema-object-dependency.html#GUID-AEC8DF50-2AC2-4697-8CA9-F13108FBB810__G1008856" title="第1列列出影响对象状态的操作，第2列显示对象的相应结果状态，第3列显示依赖对象的相应结果状态。">表26-2</a>中的操作无效的依赖对象：</p>
                     <ul style="list-style-type:disc">
                        <li>
                           <p><code class="codeph">DBMS_UTILITY</code> 。 <code class="codeph">COMPILE_SCHEMA</code> 
                           </p>
                        </li>
                        <li>
                           <p>任何<code class="codeph">UTL_RECOMP</code>子程序</p>
                        </li>
                     </ul>
                  </div>
                  <div class="section">
                     <p class="subhead2" id="GUID-AEC8DF50-2AC2-4697-8CA9-F13108FBB810__GUID-CCB0D7FC-2163-4AF3-94B5-DEFAC540A840">话题：</p>
                  </div>
                  <!-- class="section" -->
                  <div class="section">
                     <ul style="list-style-type:disc">
                        <li>
                           <p><a href="schema-object-dependency.html#GUID-99888CC1-1F5F-41A3-8889-2D94F4CB03CA">会话状态和引用的包</a></p>
                        </li>
                        <li>
                           <p><a href="schema-object-dependency.html#GUID-88DA1853-BAF1-4A3F-AF25-657A2A37ABFE">安全授权</a></p>
                        </li>
                     </ul>
                     <div class="infoboxnotealso" id="GUID-AEC8DF50-2AC2-4697-8CA9-F13108FBB810__NOTE-13142-CB50CC2E">
                        <p class="notep1">也可以看看：</p>
                        <ul style="list-style-type:disc">
                           <li>
                              <p>有关PL / SQL编译参数设置的信息，请<a href="https://www.oracle.com/pls/topic/lookup?ctx=en/database/oracle/oracle-database/19/adfns&amp;id=LNPLS00103" target="_blank"><span class="italic">参见Oracle Database PL / SQL语言参考</span></a></p>
                           </li>
                           <li>
                              <p>有关<code class="codeph">DBMS_UTILITY</code>更多信息，请<a href="https://www.oracle.com/pls/topic/lookup?ctx=en/database/oracle/oracle-database/19/adfns&amp;id=ARPLS380" target="_blank"><span class="italic">参见Oracle Database PL / SQL包和类型参考</span></a> 。 <code class="codeph">COMPILE_SCHEMA</code> 
                              </p>
                           </li>
                           <li>
                              <p>有关<code class="codeph">UTL_RECOMP</code>子程序的更多信息，请<code class="codeph">UTL_RECOMP</code> <a href="../arpls/UTL_RECOMP.html#ARPLS380" target="_blank"><span class="italic">Oracle Database PL / SQL包和类型参考</span></a></p>
                           </li>
                        </ul>
                     </div>
                  </div>
                  <!-- class="section" -->
               </div><a id="ADFNS99991"></a><div class="props_rev_3"><a id="GUID-99888CC1-1F5F-41A3-8889-2D94F4CB03CA" name="GUID-99888CC1-1F5F-41A3-8889-2D94F4CB03CA"></a><h4 id="ADFNS-GUID-99888CC1-1F5F-41A3-8889-2D94F4CB03CA" class="sect4">会话状态和引用的包</h4>
                  <div>
                     <p>引用包构造的每个会话都有自己的包的实例化，包括任何公共和私有变量，游标和常量的持久状态。如果任何会话的实例化包随后被无效和重新生效，则会话的所有包实例化（包括状态）都可能丢失。</p>
                     <div class="infoboxnotealso" id="GUID-99888CC1-1F5F-41A3-8889-2D94F4CB03CA__GUID-9DF7D12C-19A0-4EA4-ACE5-FE2A2770DD64">
                        <p class="notep1">也可以看看：</p>
                        <ul style="list-style-type:disc">
                           <li>
                              <p>有关包实例化的信息，请<a href="../lnpls/plsql-packages.html#LNPLS99926" target="_blank"><span class="italic">参见Oracle Database PL / SQL语言参考</span></a></p>
                           </li>
                           <li>
                              <p>有关包状态的信息，请<a href="../lnpls/plsql-packages.html#LNPLS804" target="_blank"><span class="italic">参见Oracle Database PL / SQL语言参考</span></a></p>
                           </li>
                        </ul>
                     </div>
                  </div>
               </div><a id="ADFNS99990"></a><div class="props_rev_3"><a id="GUID-88DA1853-BAF1-4A3F-AF25-657A2A37ABFE" name="GUID-88DA1853-BAF1-4A3F-AF25-657A2A37ABFE"></a><h4 id="ADFNS-GUID-88DA1853-BAF1-4A3F-AF25-657A2A37ABFE" class="sect4">安全授权</h4>
                  <div>
                     <p>当向用户或<code class="codeph">PUBLIC</code>授予或撤消数据操作语言（DML）对象或系统特权时，Oracle数据库使所有所有者的依赖对象无效，以验证依赖对象的所有者是否继续具有所需的特权。所有引用的对象。
                     </p>
                  </div>
               </div>
            </div><a id="ADFNS99989"></a><div class="props_rev_3"><a id="GUID-48B8583D-A1F9-4B09-AE64-A5116D50B34F" name="GUID-48B8583D-A1F9-4B09-AE64-A5116D50B34F"></a><h3 id="ADFNS-GUID-48B8583D-A1F9-4B09-AE64-A5116D50B34F" class="sect3">减少失效的指南</h3>
               <div>
                  <p>要减少依赖对象的失效，请遵循以下准则：</p>
                  <ul style="list-style-type:disc">
                     <li>
                        <p><a href="schema-object-dependency.html#GUID-7D0D81FB-5764-467A-BE1D-FA7280C758EE">将项目添加到包的末尾</a></p>
                     </li>
                     <li>
                        <p><a href="schema-object-dependency.html#GUID-A4422004-08A7-4202-81D2-286121E5F31F">通过视图参考每个表</a></p>
                     </li>
                  </ul>
               </div><a id="ADFNS99988"></a><div class="props_rev_3"><a id="GUID-7D0D81FB-5764-467A-BE1D-FA7280C758EE" name="GUID-7D0D81FB-5764-467A-BE1D-FA7280C758EE"></a><h4 id="ADFNS-GUID-7D0D81FB-5764-467A-BE1D-FA7280C758EE" class="sect4">将项目添加到包的末尾</h4>
                  <div>
                     <p>将项添加到包时，将它们添加到包的末尾。这将保留现有顶级包项的入口点编号，防止其失效。</p>
                     <p>例如，考虑这个包：</p><pre class="oac_no_warn" dir="ltr">创建或替换包pkg1 AUTHID DEFINER是功能get_var RETURN VARCHAR2;结束; /</pre><p>将项添加到<code class="codeph">pkg1</code>的末尾，如下所示，不会使引用<code class="codeph">get_var</code>函数的依赖项无效：</p><pre class="oac_no_warn" dir="ltr">创建或替换包pkg1 AUTHID DEFINER是功能get_var RETURN VARCHAR2; <span class="bold">PROCEDURE set_var（v VARCHAR2）;</span>结束; /</pre><p>插入之间的项目<code class="codeph">get_var</code>函数和<code class="codeph">set_var</code>过程，如下，无效引用该家属<code class="codeph">set_var</code>功能：</p><pre class="oac_no_warn" dir="ltr">创建或替换包pkg1 AUTHID DEFINER是功能get_var RETURN VARCHAR2; <span class="bold">PROCEDURE assert_var（v VARCHAR2）;</span> PROCEDURE set_var（v VARCHAR2）;结束; /</pre></div>
               </div><a id="ADFNS99987"></a><div class="props_rev_3"><a id="GUID-A4422004-08A7-4202-81D2-286121E5F31F" name="GUID-A4422004-08A7-4202-81D2-286121E5F31F"></a><h4 id="ADFNS-GUID-A4422004-08A7-4202-81D2-286121E5F31F" class="sect4">通过视图参考每个表</h4>
                  <div>
                     <p>使用视图间接引用表，使您能够：</p>
                     <ul style="list-style-type:disc">
                        <li>
                           <p>向表中添加列而不使相关视图或从属PL / SQL对象失效</p>
                        </li>
                        <li>
                           <p>修改或删除视图未引用的列，而不使相关对象无效</p>
                        </li>
                     </ul>
                     <p>如果新的<code class="codeph">ROWTYPE</code>与旧的<code class="codeph">ROWTYPE</code>匹配，则语句<code class="codeph">CREATE</code> <code class="codeph">OR</code> <code class="codeph">REPLACE</code> <code class="codeph">VIEW</code>不会使现有视图或其依赖项无效。</p>
                  </div>
               </div>
            </div><a id="ADFNS1267"></a><a id="ADFNS99986"></a><div class="props_rev_3"><a id="GUID-7FC0ABCA-52B1-4244-AD12-017F6E89AB99" name="GUID-7FC0ABCA-52B1-4244-AD12-017F6E89AB99"></a><h3 id="ADFNS-GUID-7FC0ABCA-52B1-4244-AD12-017F6E89AB99" class="sect3">对象重新验证</h3>
               <div>
                  <p>引用时无效的对象必须在使用之前进行验证。引用对象时自动进行验证;它不需要明确的用户操作。</p>
                  <p>如果对象无效，则其状态将编译为错误，未经授权或无效。有关这些术语的定义，请参阅<a href="schema-object-dependency.html#GUID-5795239E-C70B-424E-9757-710A37AD6F51__CHDHHDAG" title="此表汇总了数据库对象可以具有的状态值。">表26-1</a> 。
                  </p>
                  <div class="section">
                     <p class="subhead2" id="GUID-7FC0ABCA-52B1-4244-AD12-017F6E89AB99__GUID-BD2CF25B-45D1-416B-B715-31EA7989EE3F">话题：</p>
                  </div>
                  <!-- class="section" -->
                  <div class="section">
                     <ul style="list-style-type:disc">
                        <li>
                           <p><a href="schema-object-dependency.html#GUID-5EE5D90E-49EC-4183-A6E2-FA5F2A21619A">对带有错误编译的对象进行重新验证</a></p>
                        </li>
                        <li>
                           <p><a href="schema-object-dependency.html#GUID-535A5C33-90D2-4F85-BDAC-732313AA622F">未经授权的对象的重新验证</a></p>
                        </li>
                        <li>
                           <p><a href="schema-object-dependency.html#GUID-562E4506-6F2C-4C07-BEBA-A67F605FF9DF">无效SQL对象的重新验证</a></p>
                        </li>
                        <li>
                           <p><a href="schema-object-dependency.html#GUID-10DF60EA-4AD7-424D-8A2C-43A2CA8B8BC8">重新验证无效的PL / SQL对象</a></p>
                        </li>
                     </ul>
                  </div>
                  <!-- class="section" -->
               </div><a id="ADFNS892"></a><div class="props_rev_3"><a id="GUID-5EE5D90E-49EC-4183-A6E2-FA5F2A21619A" name="GUID-5EE5D90E-49EC-4183-A6E2-FA5F2A21619A"></a><h4 id="ADFNS-GUID-5EE5D90E-49EC-4183-A6E2-FA5F2A21619A" class="sect4">对带有错误编译的对象进行重新验证</h4>
                  <div>
                     <p>编译器无法自动重新验证编译有错误的对象。编译器重新编译该对象，如果它重新编译没有错误，则重新验证它;否则，它仍然无效。</p>
                  </div>
               </div><a id="ADFNS893"></a><div class="props_rev_3"><a id="GUID-535A5C33-90D2-4F85-BDAC-732313AA622F" name="GUID-535A5C33-90D2-4F85-BDAC-732313AA622F"></a><h4 id="ADFNS-GUID-535A5C33-90D2-4F85-BDAC-732313AA622F" class="sect4">未经授权的对象的重新验证</h4>
                  <div>
                     <p>编译器检查未授权对象是否具有对其所有引用对象的访问权限。如果是这样，编译器将重新验证未授权的对象而不重新编译它。如果没有，编译器会发出相应的错误消息。</p>
                  </div>
               </div><a id="ADFNS894"></a><div class="props_rev_3"><a id="GUID-562E4506-6F2C-4C07-BEBA-A67F605FF9DF" name="GUID-562E4506-6F2C-4C07-BEBA-A67F605FF9DF"></a><h4 id="ADFNS-GUID-562E4506-6F2C-4C07-BEBA-A67F605FF9DF" class="sect4">无效SQL对象的重新验证</h4>
                  <div>
                     <p>SQL编译器重新编译无效对象。如果对象重新编译没有错误，则重新验证;否则，它仍然无效。</p>
                  </div>
               </div><a id="ADFNS895"></a><div class="props_rev_3"><a id="GUID-10DF60EA-4AD7-424D-8A2C-43A2CA8B8BC8" name="GUID-10DF60EA-4AD7-424D-8A2C-43A2CA8B8BC8"></a><h4 id="ADFNS-GUID-10DF60EA-4AD7-424D-8A2C-43A2CA8B8BC8" class="sect4">重新验证无效的PL / SQL对象</h4>
                  <div>
                     <p>对于无效的PL / SQL程序单元（过程，函数或程序包），PL / SQL编译器会检查是否有任何引用的对象以影响无效对象的方式更改。如果是这样，编译器将重新编译无效对象。如果对象重新编译没有错误，则重新验证;否则，它仍然无效。如果没有，编译器将重新验证无效对象而不重新编译它。</p>
                  </div>
               </div>
            </div><a id="ADFNS99985"></a><div class="props_rev_3"><a id="GUID-46C57DB9-847E-4709-9587-0673CCC5E5F0" name="GUID-46C57DB9-847E-4709-9587-0673CCC5E5F0"></a><h3 id="ADFNS-GUID-46C57DB9-847E-4709-9587-0673CCC5E5F0" class="sect3">架构范围中的名称解析</h3>
               <div>
                  <p>SQL语句中引用的对象名称包含一个或多个部分。片段以句点分隔 - 例如， <code class="codeph">hr</code> 。 <code class="codeph">employees</code> 。 <code class="codeph">department_id</code>有三个部分。
                  </p>
                  <p>Oracle数据库使用以下过程尝试解析对象名称。</p>
                  <div class="infoboxnote" id="GUID-46C57DB9-847E-4709-9587-0673CCC5E5F0__GUID-D81F71E0-4D79-48F9-8D2B-BBF551978B72">
                     <p class="notep1">注意：</p>
                     <p>要使过程成功，对象名称的所有部分必须在当前版本中可见。</p>
                  </div>
                  <ol>
                     <li>
                        <p>尝试限定对象名称的第一部分。</p>
                        <p>如果对象名称只有一个部分，则该部分是第一部分。否则，第一件是最左边一段左边的那块;例如，在<code class="codeph">hr</code> 。 <code class="codeph">employees</code> 。 <code class="codeph">department_id</code> ，第一件是<code class="codeph">hr</code> 。
                        </p>
                        <p>试图获得第一件作品的程序是：</p>
                        <ol type="a">
                           <li>
                              <p>如果对象名称是出现在<code class="codeph">SELECT</code>语句的<code class="codeph">FROM</code>子句中的表名，并且对象名称有多个部分，请转到步骤d。否则，请转到步骤b。
                              </p>
                              <p>在当前架构中搜索名称与第一块相匹配的对象。</p>
                              <p>如果找到，请转到步骤2。否则，请转到步骤c。</p>
                           </li>
                           <li id="GUID-46C57DB9-847E-4709-9587-0673CCC5E5F0__CHDIEDGI">
                              <p>搜索与第一部分匹配的公共同义词。</p>
                              <p>如果找到，请转到步骤2。否则，请转到步骤d。</p>
                           </li>
                           <li id="GUID-46C57DB9-847E-4709-9587-0673CCC5E5F0__CHDFBGIA">
                              <p>搜索名称与第一个部分匹配的模式。</p>
                              <p>如果找到，如果对象名称有第二个，请转到步骤e。否则，返回错误 - 对象名称无法限定。</p>
                           </li>
                           <li id="GUID-46C57DB9-847E-4709-9587-0673CCC5E5F0__BABEBBHJ">
                              <p>在步骤d中找到的模式中搜索名称与对象名称的第二部分匹配的表或SQL函数。</p>
                              <p>如果找到，请转到步骤2。否则，返回错误 - 对象名称无法限定。</p>
                              <div class="infoboxnote" id="GUID-46C57DB9-847E-4709-9587-0673CCC5E5F0__GUID-59BE832A-8670-4AD3-964E-73B34349A1B7">
                                 <p class="notep1">注意：</p>
                                 <p>在此步骤中找到的SQL函数已由步骤d中找到的模式重新定义。</p>
                              </div>
                           </li>
                        </ol>
                     </li>
                     <li id="GUID-46C57DB9-847E-4709-9587-0673CCC5E5F0__CHDBEBHE">
                        <p>架构对象已被限定。对象名称的任何剩余部分必须与此架构对象的有效部分匹配。</p>
                        <p>例如，如果对象名称是<code class="codeph">hr</code> 。 <code class="codeph">employees</code> 。 <code class="codeph">department_id</code> ， <code class="codeph">hr</code>被限定为模式。如果<code class="codeph">employees</code>被限定为表，则<code class="codeph">department_id</code>必须对应于该表的列。如果<code class="codeph">employees</code>被认定为包，则<code class="codeph">department_id</code>必须对应于该包的公共常量，变量，过程或函数。
                        </p>
                     </li>
                  </ol>
                  <p>由于Oracle数据库如何解析引用，因此对象可以依赖于其他对象的不存在。当依赖对象使用将在另一个对象存在时以不同方式解释的引用时，会发生这种情况。</p>
                  <div class="infoboxnotealso" id="GUID-46C57DB9-847E-4709-9587-0673CCC5E5F0__GUID-5C98AC16-6177-46EC-91AA-A53B412E508B">
                     <p class="notep1">也可以看看：</p>
                     <ul style="list-style-type:disc">
                        <li>
                           <p>有关SQL和PL / SQL中名称解析如何不同的信息，请<a href="../lnpls/plsql-name-resolution.html#LNPLS01703" target="_blank"><span class="italic">参见Oracle Database PL / SQL语言参考</span></a></p>
                        </li>
                        <li>
                           <p>有关分布式数据库系统中名称解析的信息，请参见<a href="../admin/distributed-database-concepts.html#ADMIN02803" target="_blank"><span class="italic">“Oracle数据库管理员指南”</span></a></p>
                        </li>
                        <li>
                           <p><a href="editions.html#GUID-42FA041C-5C7D-4C33-B1F8-188B2C784121">版本化和非编辑对象的名称解析</a></p>
                        </li>
                     </ul>
                  </div>
               </div>
            </div><a id="ADFNS99984"></a><div class="props_rev_3"><a id="GUID-0E05699C-604F-41A5-B76E-7216CF25C913" name="GUID-0E05699C-604F-41A5-B76E-7216CF25C913"></a><h3 id="ADFNS-GUID-0E05699C-604F-41A5-B76E-7216CF25C913" class="sect3">本地依赖管理</h3>
               <div>
                  <p>当Oracle数据库管理单个数据库中对象之间的<span class="bold">依赖关系</span>时，会发生<span class="bold">本地依赖关系管理</span> 。例如，过程中的语句可以引用同一数据库中的表。
                  </p>
               </div>
            </div><a id="ADFNS1268"></a><a id="ADFNS99983"></a><div class="props_rev_3"><a id="GUID-D89D3306-9B7A-443F-BD64-81D4808E8EFC" name="GUID-D89D3306-9B7A-443F-BD64-81D4808E8EFC"></a><h3 id="ADFNS-GUID-D89D3306-9B7A-443F-BD64-81D4808E8EFC" class="sect3">远程依赖管理</h3>
               <div>
                  <p>当Oracle数据库通过网络管理分布式环境中的<span class="bold">依赖关系</span>时，会发生<span class="bold">远程依赖关系管</span>例如，Oracle Forms触发器可以依赖于数据库中的模式对象。在分布式数据库中，本地视图可以引用远程表。
                  </p>
                  <p>Oracle数据库还管理分布式数据库依赖项。例如，Oracle Forms应用程序可能包含引用表的触发器。数据库系统必须考虑这些对象之间的依赖关系。Oracle数据库使用不同的机制来管理远程依赖项，具体取决于所涉及的对象。</p>
                  <div class="section">
                     <p class="subhead2" id="GUID-D89D3306-9B7A-443F-BD64-81D4808E8EFC__GUID-A08F82B0-FCCF-4A36-BD6F-A2F912A0F2AB">话题：</p>
                  </div>
                  <!-- class="section" -->
                  <div class="section">
                     <ul style="list-style-type:disc">
                        <li>
                           <p><a href="schema-object-dependency.html#GUID-5DDF2B74-A9B4-40D4-ABFE-175F11544F3D">本地和远程数据库程序之间的依赖关系</a></p>
                        </li>
                        <li>
                           <p><a href="schema-object-dependency.html#GUID-9560707C-6607-4E5E-841E-07BDDC218212">其他远程对象之间的依赖关系</a></p>
                        </li>
                        <li>
                           <p><a href="schema-object-dependency.html#GUID-5EF4E3BF-0206-47B7-8E31-A3B11D437356">应用程序的依赖性</a></p>
                        </li>
                     </ul>
                  </div>
                  <!-- class="section" -->
               </div><a id="ADFNS99982"></a><div class="props_rev_3"><a id="GUID-5DDF2B74-A9B4-40D4-ABFE-175F11544F3D" name="GUID-5DDF2B74-A9B4-40D4-ABFE-175F11544F3D"></a><h4 id="ADFNS-GUID-5DDF2B74-A9B4-40D4-ABFE-175F11544F3D" class="sect4">本地和远程数据库程序之间的依赖关系</h4>
                  <div>
                     <p>使用时间戳检查或签名检查来管理分布式数据库系统中的存储过程（包括函数，包和触发器）之间的依赖关系。</p>
                     <p>动态初始化参数<code class="codeph">REMOTE_DEPENDENCIES_MODE</code>确定时间戳或签名是否管理远程依赖项。
                     </p>
                     <div class="infoboxnotealso" id="GUID-5DDF2B74-A9B4-40D4-ABFE-175F11544F3D__GUID-434ECF95-6679-44DD-BAE9-F268503273FC">
                        <p class="notep1">也可以看看：</p>
                        <ul style="list-style-type:disc">
                           <li>
                              <p><a href="../lnpls/plsql-optimization-and-tuning.html#LNPLS912" target="_blank"><span class="italic">Oracle数据库PL / SQL语言参考</span></a></p>
                           </li>
                           <li>
                              <p><a href="schema-object-dependency.html#GUID-FDBE05D0-4742-40B1-943D-A3937B380BD7">时间戳依赖模式</a></p>
                           </li>
                           <li>
                              <p><a href="schema-object-dependency.html#GUID-6DB81CA9-0712-4627-9294-1EE21109D044">RPC签名依赖模式</a></p>
                           </li>
                        </ul>
                     </div>
                  </div>
               </div><a id="ADFNS99981"></a><div class="props_rev_3"><a id="GUID-9560707C-6607-4E5E-841E-07BDDC218212" name="GUID-9560707C-6607-4E5E-841E-07BDDC218212"></a><h4 id="ADFNS-GUID-9560707C-6607-4E5E-841E-07BDDC218212" class="sect4">其他远程对象之间的依赖关系</h4>
                  <div>
                     <p>Oracle数据库不管理除本地过程到远程过程依赖性之外的远程模式对象之间的依赖关系。</p>
                     <p>例如，假设本地视图由引用远程表的查询创建和定义。还假设本地过程包括引用同一远程表的SQL语句。之后，表的定义发生了变化。</p>
                     <p>因此，即使在更改表之后使用视图或过程，即使视图或过程现在在使用时返回错误，本地视图和过程也永远不会失效。在这种情况下，必须手动更改视图或过程，以便不返回错误。在这种情况下，缺乏依赖关系管理比依赖对象的不必要的重新编译更可取。</p>
                  </div>
               </div><a id="ADFNS99980"></a><div class="props_rev_3"><a id="GUID-5EF4E3BF-0206-47B7-8E31-A3B11D437356" name="GUID-5EF4E3BF-0206-47B7-8E31-A3B11D437356"></a><h4 id="ADFNS-GUID-5EF4E3BF-0206-47B7-8E31-A3B11D437356" class="sect4">应用程序的依赖性</h4>
                  <div>
                     <p>数据库应用程序中的代码可以引用连接数据库中的对象例如，Oracle调用接口（OCI）和预编译器应用程序可以提交匿名PL / SQL块。Oracle Forms应用程序中的触发器可以引用架构对象。</p>
                     <p>此类应用程序依赖于它们引用的架构对象。依赖性管理技术因开发环境而异。Oracle数据库不会自动跟踪应用程序依赖性。</p>
                     <div class="infoboxnotealso" id="GUID-5EF4E3BF-0206-47B7-8E31-A3B11D437356__GUID-07DA0932-4696-4E0B-8997-D865BBB8B3E7">
                        <p class="notep1">也可以看看：</p>
                        <p>有关管理数据库应用程序中的远程依赖项的更多信息，请参阅应用程序开发工具和操作系统的手册</p>
                     </div>
                  </div>
               </div>
            </div><a id="ADFNS1269"></a><a id="ADFNS99979"></a><div class="props_rev_3"><a id="GUID-B99E885E-900F-4F29-A188-A617A301FDCE" name="GUID-B99E885E-900F-4F29-A188-A617A301FDCE"></a><h3 id="ADFNS-GUID-B99E885E-900F-4F29-A188-A617A301FDCE" class="sect3">远程过程调用（RPC）依赖关系管理</h3>
               <div>
                  <p>当本地存储过程调用分布式数据库系统中的远程过程时，会发生<span class="bold">远程过程调用（RPC）依赖关系管理</span> 。动态初始化参数<code class="codeph">REMOTE_DEPENDENCIES_MODE</code>控制依赖模式。选择是时间戳依赖模式或RPC签名依赖模式。
                  </p>
                  <div class="section">
                     <p class="subhead2" id="GUID-B99E885E-900F-4F29-A188-A617A301FDCE__GUID-7E5426E0-3611-433B-B6B4-8413017A1B77">话题：</p>
                  </div>
                  <!-- class="section" -->
                  <div class="section">
                     <ul style="list-style-type:disc">
                        <li>
                           <p><a href="schema-object-dependency.html#GUID-FDBE05D0-4742-40B1-943D-A3937B380BD7">时间戳依赖模式</a></p>
                        </li>
                        <li>
                           <p><a href="schema-object-dependency.html#GUID-6DB81CA9-0712-4627-9294-1EE21109D044">RPC签名依赖模式</a></p>
                        </li>
                        <li>
                           <p><a href="schema-object-dependency.html#GUID-EC3E3CF1-03EF-40A0-86FF-78D19403DF1F">控制依赖模式</a></p>
                        </li>
                     </ul>
                  </div>
                  <!-- class="section" -->
               </div><a id="ADFNS99978"></a><div class="props_rev_3"><a id="GUID-FDBE05D0-4742-40B1-943D-A3937B380BD7" name="GUID-FDBE05D0-4742-40B1-943D-A3937B380BD7"></a><h4 id="ADFNS-GUID-FDBE05D0-4742-40B1-943D-A3937B380BD7" class="sect4">时间戳依赖模式</h4>
                  <div>
                     <p>无论何时编译过程，其<span class="bold">时间戳</span>都记录在数据字典中。时间戳显示创建，更改或替换过程的时间。
                     </p>
                     <p>编译过程包含有关其调用的每个远程过程的信息，包括模式，包名称，过程名称和远程过程的时间戳。</p>
                     <p>在时间戳依赖关系模式中，当本地存储过程调用远程过程时，Oracle数据库会将本地过程对远程过程的时间戳与远程过程的当前时间戳进行比较。如果两个时间戳匹配，则运行本地和远程过程。两者都没有重新编译。</p>
                     <p>如果两个时间戳不匹配，则本地过程无效并且将错误返回给调用环境。依赖于带有新时间戳的远程过程的所有其他本地过程也将失效。</p>
                     <p>当本地过程的主体中的语句调用远程过程时，会发生时间戳比较。因此，无效调用之前的本地过程中的语句可能会成功运行。无效调用后的语句不会运行。必须重新编译本地过程。</p>
                     <p>如果DML语句在无效调用之前，则只有当它们和无效调用位于同一PL / SQL块中时，它们才会回滚。例如， <code class="codeph">UPDATE</code>语句在此代码中回滚：</p><pre class="oac_no_warn" dir="ltr">开始</pre><pre class="oac_no_warn" dir="ltr">UPDATE表SET ...invalid_proc;承诺;</pre><pre class="oac_no_warn" dir="ltr">结束;</pre><p>但<code class="codeph">UPDATE</code>语句不会在此代码中回滚：</p><pre class="oac_no_warn" dir="ltr">UPDATE表SET ...EXECUTE invalid_proc;承诺;</pre><p>时间戳依赖模式的缺点是：</p>
                     <ul style="list-style-type:disc">
                        <li>
                           <p>网络中的从属对象通常会被不必要地重新编译，从而降低性能。</p>
                        </li>
                        <li>
                           <p>如果客户端应用程序使用PL / SQL，则此模式可能导致阻止应用程序在客户端运行的情况。</p>
                           <p>此类应用程序的一个示例是Oracle Forms。在安装期间，您必须重新编译Oracle Forms在客户端站点上使用的客户端PL / SQL过程。此外，如果客户端过程依赖于服务器过程，并且服务器过程发生更改或自动重新编译，则必须重新编译客户端PL / SQL过程。但是，客户端上没有可用的PL / SQL编译器。因此，客户端应用程序的开发人员必须将新版本的应用程序分发给所有客户。</p>
                        </li>
                     </ul>
                  </div>
               </div><a id="ADFNS1270"></a><a id="ADFNS99977"></a><div class="props_rev_3"><a id="GUID-6DB81CA9-0712-4627-9294-1EE21109D044" name="GUID-6DB81CA9-0712-4627-9294-1EE21109D044"></a><h4 id="ADFNS-GUID-6DB81CA9-0712-4627-9294-1EE21109D044" class="sect4">RPC签名依赖模式</h4>
                  <div>
                     <p>Oracle数据库提供<span class="bold">RPC签名</span>来处理远程依赖项。RPC签名不会影响本地依赖性，因为在本地环境中始终可以进行重新编译。
                     </p>
                     <p>RPC签名与每个编译的存储程序单元相关联。它通过以下特征识别单位：</p>
                     <ul style="list-style-type:disc">
                        <li>
                           <p>名称</p>
                        </li>
                        <li>
                           <p>参数数量</p>
                        </li>
                        <li>
                           <p>每个参数的数据类型类</p>
                        </li>
                        <li>
                           <p>每个参数的模式</p>
                        </li>
                        <li>
                           <p>返回值的数据类型类（对于函数）</p>
                        </li>
                     </ul>
                     <p>仅当至少一个前述特征发生更改时，RPC签名才会更改。</p>
                     <div class="infoboxnote" id="GUID-6DB81CA9-0712-4627-9294-1EE21109D044__GUID-AF0A1A70-0623-4563-913A-D54B7825C8DD">
                        <p class="notep1">注意：</p>
                        <p>RPC签名不包括<code class="codeph">DETERMINISTIC</code> ， <code class="codeph">PARALLEL_ENABLE</code>或纯度信息。如果远程系统上的功能更改了这些设置，则不会自动重新考虑基于它们的优化。因此，在SQL语句中调用远程函数或在基于函数的索引中使用它可能会导致不正确的查询结果。
                        </p>
                     </div>
                     <p>已编译的程序单元包含它调用的每个远程过程的RPC签名（以及远程过程的模式，包名称，过程名称和时间戳）。</p>
                     <p>在RPC签名依赖模式下，当本地程序单元调用远程程序单元中的子程序时，数据库忽略时间戳不匹配，并将本地单元对远程子程序的RPC签名与远程子程序的当前RPC签名进行比较子程序。如果RPC签名匹配，则调用成功;否则，数据库将错误返回给本地单元，并且本地单元无效。</p>
                     <p>例如，假设此过程<code class="codeph">get_emp_name</code>存储在Boston（ <code class="codeph">BOSTON_SERVER</code> ）的服务器上：</p><pre class="oac_no_warn" dir="ltr">创建或替换过程get_emp_name（emp_number IN NUMBER，hiredate OUT VARCHAR2，emp_name OUT VARCHAR2）AUTHID DEFINER AS BEGIN SELECT last_name，TO_CHAR（hire_date，'DD-MON-YY'）INTO emp_name，hiredate FROM employees WHERE employee_id = emp_number;结束; /</pre><p>在<code class="codeph">get_emp_name</code>上编译<code class="codeph">BOSTON_SERVER</code> ，Oracle数据库会记录其RPC签名及其时间戳。
                     </p>
                     <p>假设调用<code class="codeph">get_emp_name</code> PL / SQL过程<code class="codeph">print_name</code>位于加利福尼亚州的服务器上：</p><pre class="oac_no_warn" dir="ltr">创建或替换程序print_ename（emp_number IN NUMBER）AUTHID DEFINER AS hiredate VARCHAR2（12）; ename VARCHAR2（10）; BEGIN <span class="bold">get_emp_name @ BOSTON_SERVER（emp_number，hiredate，ename）;</span> DBMS_OUTPUT.PUT_LINE（ENAME）; DBMS_OUTPUT.PUT_LINE（HIREDATE）;结束; /</pre><p>在California服务器上编译<code class="codeph">print_name</code> ，数据库连接到Boston服务器，将<code class="codeph">get_emp_name</code>的RPC签名发送到California服务器，并将<code class="codeph">get_emp_name</code>的RPC签名记录在<code class="codeph">print_ename</code>的编译状态中。
                     </p>
                     <p>在运行时，当<code class="codeph">print_name</code>调用<code class="codeph">get_emp_name</code> ，数据库会将以<code class="codeph">print_ename</code>的已编译状态记录的<code class="codeph">get_emp_name</code>的RPC签名发送到Boston服务器。如果记录的RPC签名与Boston服务器上的<code class="codeph">get_emp_name</code>的当前RPC签名匹配，则调用成功;否则，数据库向<code class="codeph">print_name</code>返回一个错误，该错误无效。
                     </p>
                     <div class="section">
                        <p class="subhead3" id="GUID-6DB81CA9-0712-4627-9294-1EE21109D044__GUID-85F61907-9C29-45A9-A855-189CAD62F9DF">话题：</p>
                     </div>
                     <!-- class="section" -->
                     <div class="section">
                        <ul style="list-style-type:disc">
                           <li>
                              <p><a href="schema-object-dependency.html#GUID-4F745FCF-A34A-4967-B8E8-64BE0DA3E532">更改参数的名称和默认值</a></p>
                           </li>
                           <li>
                              <p><a href="schema-object-dependency.html#GUID-BC482BD0-D3EB-435F-A553-1131CA549E43">改变参数模式IN的规格</a></p>
                           </li>
                           <li>
                              <p><a href="schema-object-dependency.html#GUID-B6229DA4-45B0-49C3-9CBA-5EF2A1415906">改变子程序体</a></p>
                           </li>
                           <li>
                              <p><a href="schema-object-dependency.html#GUID-F1AEAA97-05B5-4B08-9233-D061E80000EB">更改数据类型的参数类</a></p>
                           </li>
                           <li>
                              <p><a href="schema-object-dependency.html#GUID-012C4634-98BF-455A-9A68-74736A640263">更改包类型</a></p>
                           </li>
                        </ul>
                     </div>
                     <!-- class="section" -->
                  </div><a id="ADFNS1271"></a><div class="props_rev_3"><a id="GUID-4F745FCF-A34A-4967-B8E8-64BE0DA3E532" name="GUID-4F745FCF-A34A-4967-B8E8-64BE0DA3E532"></a><h5 id="ADFNS-GUID-4F745FCF-A34A-4967-B8E8-64BE0DA3E532" class="sect5">更改参数的名称和默认值</h5>
                     <div>
                        <p>更改子程序参数的名称或默认值不会更改子程序的RPC签名。例如，过程<code class="codeph">P1</code>在这两个示例中具有相同的RPC签名：</p><pre class="oac_no_warn" dir="ltr">程序P1（ <span class="bold">Param1</span> IN NUMBER：= <span class="bold">100</span> ）;程序P1（ <span class="bold">Param2</span> IN NUMBER：= <span class="bold">200</span> ）;</pre><p>但是，如果您的应用程序要求调用者获取新的默认值，则必须重新编译调用的过程。</p>
                     </div>
                  </div><a id="ADFNS1272"></a><div class="props_rev_3"><a id="GUID-BC482BD0-D3EB-435F-A553-1131CA549E43" name="GUID-BC482BD0-D3EB-435F-A553-1131CA549E43"></a><h5 id="ADFNS-GUID-BC482BD0-D3EB-435F-A553-1131CA549E43" class="sect5">改变参数模式IN的规格</h5>
                     <div>
                        <p>由于子程序参数模式<code class="codeph">IN</code>是默认值，因此可以隐式或显式指定它。将其规范从隐式更改为显式，或相反，不会更改子程序的RPC签名。例如，过程<code class="codeph">P1</code>在这两个示例中具有相同的RPC签名：</p><pre class="oac_no_warn" dir="ltr">程序P1（Param1 NUMBER）; - 隐式规范PROCEDURE P1（Param1 <span class="bold">IN</span> NUMBER）; - 明确的规范</pre></div>
                  </div><a id="ADFNS1274"></a><a id="ADFNS1273"></a><div class="props_rev_3"><a id="GUID-B6229DA4-45B0-49C3-9CBA-5EF2A1415906" name="GUID-B6229DA4-45B0-49C3-9CBA-5EF2A1415906"></a><h5 id="ADFNS-GUID-B6229DA4-45B0-49C3-9CBA-5EF2A1415906" class="sect5">改变子程序体</h5>
                     <div>
                        <p>更改子程序的主体不会更改子程序的RPC签名。</p>
                        <p><a href="schema-object-dependency.html#GUID-B6229DA4-45B0-49C3-9CBA-5EF2A1415906__BABGFBHJ">例26-4</a>只改变了程序的主体<code class="codeph">get_hire_date</code> ;因此，它不会更改<code class="codeph">get_hire_date</code>的RPC签名。
                        </p>
                        <div class="example" id="GUID-B6229DA4-45B0-49C3-9CBA-5EF2A1415906__BABGFBHJ">
                           <p class="titleinexample">示例26-4更改过程主体get_hire_date</p><pre class="oac_no_warn" dir="ltr">创建或替换程序get_hire_date（emp_number IN NUMBER，hiredate OUT VARCHAR2，emp_name OUT VARCHAR2）AUTHID DEFINER as BEGIN SELECT last_name，TO_CHAR（hire_date，' <span class="bold">DD-MON-YY</span> '）INTO emp_name，hiredate FROM employees WHERE employee_id = emp_number;结束; /创建或替换过程get_hire_date（emp_number IN NUMBER，hiredate OUT VARCHAR2，emp_name OUT VARCHAR2）AUTHID DEFINER as BEGIN <span class="bold">- 更改日期格式模型</span> SELECT last_name，TO_CHAR（hire_date，' <span class="bold">DD / MON / YYYY</span> '）INTO emp_name，hiredate FROM employees WHERE employee_id = emp_number;结束; /</pre></div>
                        <!-- class="example" -->
                     </div>
                  </div><a id="ADFNS897"></a><a id="ADFNS1275"></a><a id="ADFNS99976"></a><div class="props_rev_3"><a id="GUID-F1AEAA97-05B5-4B08-9233-D061E80000EB" name="GUID-F1AEAA97-05B5-4B08-9233-D061E80000EB"></a><h5 id="ADFNS-GUID-F1AEAA97-05B5-4B08-9233-D061E80000EB" class="sect5">更改数据类型的参数类</h5>
                     <div>
                        <p>将参数的数据类型更改为同一类中的另一种数据类型不会更改RPC签名，但会将数据类型更改为另一个类中的数据类型。</p>
                        <p><a href="schema-object-dependency.html#GUID-F1AEAA97-05B5-4B08-9233-D061E80000EB__g4951307" title="此表总结了数据类型的类。">表26-3</a>列出了数据类型类以及组成它们的数据类型。<a href="schema-object-dependency.html#GUID-F1AEAA97-05B5-4B08-9233-D061E80000EB__g4951307" title="此表总结了数据类型的类。">表26-3中</a>未列出的数据类型（如<code class="codeph">NCHAR</code> ）不属于数据类型类。更改其类型始终会更改RPC签名。
                        </p>
                        <div class="tblformal" id="GUID-F1AEAA97-05B5-4B08-9233-D061E80000EB__g4951307">
                           <p class="titleintable">表26-3数据类型类</p>
                           <table cellpadding="4" cellspacing="0" class="Formal" title="数据类型类" width="100%" border="1" summary="This table summarizes the classes of datatypes." frame="hsides" rules="rows">
                              <thead>
                                 <tr align="left" valign="top">
                                    <th align="left" valign="bottom" width="22%" id="d156312e4667">数据类型类</th>
                                    <th align="left" valign="bottom" width="78%" id="d156312e4670">类中的数据类型</th>
                                 </tr>
                              </thead>
                              <tbody>
                                 <tr align="left" valign="top">
                                    <td align="left" valign="top" width="22%" id="d156312e4675" headers="d156312e4667 ">
                                       <p>字符</p>
                                    </td>
                                    <td align="left" valign="top" width="78%" headers="d156312e4675 d156312e4670 "><pre class="oac_no_warn" dir="ltr">CHAR CHARACTER</pre></td>
                                 </tr>
                                 <tr align="left" valign="top">
                                    <td align="left" valign="top" width="22%" id="d156312e4682" headers="d156312e4667 ">
                                       <p><code class="codeph">VARCHAR</code></p>
                                    </td>
                                    <td align="left" valign="top" width="78%" headers="d156312e4682 d156312e4670 "><pre class="oac_no_warn" dir="ltr">VARCHAR VARCHAR2 STRING LONG ROWID</pre></td>
                                 </tr>
                                 <tr align="left" valign="top">
                                    <td align="left" valign="top" width="22%" id="d156312e4690" headers="d156312e4667 ">
                                       <p>生的</p>
                                    </td>
                                    <td align="left" valign="top" width="78%" headers="d156312e4690 d156312e4670 "><pre class="oac_no_warn" dir="ltr">RAW LONG RAW</pre></td>
                                 </tr>
                                 <tr align="left" valign="top">
                                    <td align="left" valign="top" width="22%" id="d156312e4697" headers="d156312e4667 ">
                                       <p>整数</p>
                                    </td>
                                    <td align="left" valign="top" width="78%" headers="d156312e4697 d156312e4670 "><pre class="oac_no_warn" dir="ltr">BINARY_INTEGER PLS_INTEGER SIMPLE_INTEGER BOOLEAN NATURAL NATURALN POSITIVE POSITIVEN</pre></td>
                                 </tr>
                                 <tr align="left" valign="top">
                                    <td align="left" valign="top" width="22%" id="d156312e4704" headers="d156312e4667 ">
                                       <p>数</p>
                                    </td>
                                    <td align="left" valign="top" width="78%" headers="d156312e4704 d156312e4670 "><pre class="oac_no_warn" dir="ltr">NUMBER INT INTEGER SMALLINT DEC DECIMAL REAL FLOAT NUMERIC DOUBLE PRECISION</pre></td>
                                 </tr>
                                 <tr align="left" valign="top">
                                    <td align="left" valign="top" width="22%" id="d156312e4711" headers="d156312e4667 ">
                                       <p>约会时间</p>
                                    </td>
                                    <td align="left" valign="top" width="78%" headers="d156312e4711 d156312e4670 "><pre class="oac_no_warn" dir="ltr">日期TIMESTAMP TIMESTAMP与时区TIMESTAMP与当地时区间隔年至月间间隔至第二天</pre></td>
                                 </tr>
                              </tbody>
                           </table>
                        </div>
                        <!-- class="inftblhruleinformal" -->
                        <p><a href="schema-object-dependency.html#GUID-F1AEAA97-05B5-4B08-9233-D061E80000EB__BABGICDI">例26-5</a>将参数<code class="codeph">hiredate</code>的数据类型从<code class="codeph">VARCHAR2</code>更改为<code class="codeph">DATE</code> 。 <code class="codeph">VARCHAR2</code>和<code class="codeph">DATE</code>不在同一数据类型类中，因此过程<code class="codeph">get_hire_date</code>的RPC签名<code class="codeph">get_hire_date</code>更改。
                        </p>
                        <div class="example" id="GUID-F1AEAA97-05B5-4B08-9233-D061E80000EB__BABGICDI">
                           <p class="titleinexample">示例26-5更改get_hire_date参数的数据类型类</p><pre class="oac_no_warn" dir="ltr">创建或替换程序get_hire_date（emp_number IN NUMBER，Hiredate OUT <span class="bold">DATE</span> ，emp_name OUT VARCHAR2）AS BEGIN SELECT last_name，TO_CHAR（hire_date，'DD / MON / YYYY'）INTO emp_name，hiredate FROM employees WHERE employee_id = emp_number;结束; /</pre></div>
                        <!-- class="example" -->
                     </div>
                  </div><a id="ADFNS1276"></a><a id="ADFNS99973"></a><div class="props_rev_3"><a id="GUID-012C4634-98BF-455A-9A68-74736A640263" name="GUID-012C4634-98BF-455A-9A68-74736A640263"></a><h5 id="ADFNS-GUID-012C4634-98BF-455A-9A68-74736A640263" class="sect5">更改包类型</h5>
                     <div>
                        <p>更改包类型的名称或其内部组件的名称不会更改包的RPC签名。</p>
                        <p><a href="schema-object-dependency.html#GUID-012C4634-98BF-455A-9A68-74736A640263__BABFCGDJ">实施例26-6</a>定义的记录类型， <code class="codeph">emp_data_type</code> ，内包<code class="codeph">emp_package</code> 。接下来，它会更改记录字段的名称，但不会更改其类型。最后，它更改了类型的名称，但不更改其特征。包的RPC签名不会更改。
                        </p>
                        <div class="example" id="GUID-012C4634-98BF-455A-9A68-74736A640263__BABFCGDJ">
                           <p class="titleinexample">示例26-6更改包记录类型中字段的名称</p><pre class="oac_no_warn" dir="ltr">创建或替换包装emp_package AUTHID DEFINER类型为emp_data_type IS RECORD（ <span class="bold">emp_number NUMBER</span> ， <span class="bold">hiredate VARCHAR2（12）</span> ， <span class="bold">emp_name VARCHAR2（10）</span> ）; PROCEDURE get_emp_data（emp_data IN OUT emp_data_type）;结束; / CREATE OR REPLACE PACKAGE emp_package AUTHID DEFINER AS TYPE emp_data_type IS RECORD（ <span class="bold">emp_num NUMBER</span> ， <span class="bold">hire_dat VARCHAR2（12）</span> ， <span class="bold">empname VARCHAR2（10）</span> ）; PROCEDURE get_emp_data（emp_data IN OUT emp_data_type）;结束; / CREATE OR REPLACE PACKAGE emp_package AUTHID DEFINER AS TYPE <span class="bold">emp_data_record_type</span> IS RECORD（emp_num NUMBER，hire_dat VARCHAR2（12），empname VARCHAR2（10））; PROCEDURE get_emp_data（emp_data IN OUT <span class="bold">emp_data_record_type</span> ）;结束; /</pre></div>
                        <!-- class="example" -->
                     </div>
                  </div>
               </div><a id="ADFNS1277"></a><a id="ADFNS99972"></a><div class="props_rev_3"><a id="GUID-EC3E3CF1-03EF-40A0-86FF-78D19403DF1F" name="GUID-EC3E3CF1-03EF-40A0-86FF-78D19403DF1F"></a><h4 id="ADFNS-GUID-EC3E3CF1-03EF-40A0-86FF-78D19403DF1F" class="sect4">控制依赖模式</h4>
                  <div>
                     <div class="section">
                        <p>动态初始化参数<code class="codeph">REMOTE_DEPENDENCIES_MODE</code>控制依赖模式。如果初始化参数文件包含此规范，则仅使用时间戳来解析依赖关系（如果未动态显式覆盖它）：</p><pre class="oac_no_warn" dir="ltr">REMOTE_DEPENDENCIES_MODE = TIMESTAMP</pre><p>如果初始化参数文件包含此参数规范，则RPC签名用于解析依赖关系（如果未动态显式覆盖）：</p><pre class="oac_no_warn" dir="ltr">REMOTE_DEPENDENCIES_MODE =签名</pre><p>您可以使用DDL语句动态更改模式。例如，此示例更改当前会话的依赖项模式：</p><pre class="oac_no_warn" dir="ltr">ALTER SESSION SET REMOTE_DEPENDENCIES_MODE = {SIGNATURE | TIMESTAMP}</pre><p>此示例在启动后改变系统范围内的依赖模式：</p><pre class="oac_no_warn" dir="ltr">ALTER SYSTEM SET REMOTE_DEPENDENCIES_MODE = {SIGNATURE | TIMESTAMP}</pre><p>如果未在<code class="codeph">init.ora</code>参数文件中指定<code class="codeph">REMOTE_DEPENDENCIES_MODE</code>参数，或者使用<code class="codeph">ALTER</code> <code class="codeph">SESSION</code>或<code class="codeph">ALTER</code> <code class="codeph">SYSTEM</code>语句，则<code class="codeph">TIMESTAMP</code>是默认值。因此，除非您明确使用<code class="codeph">REMOTE_DEPENDENCIES_MODE</code>参数或相应的DDL语句，否则您的服务器将使用时间戳依赖关系模式运行。
                        </p>
                        <p>使用<code class="codeph">REMOTE_DEPENDENCIES_MODE</code> = <code class="codeph">SIGNATURE</code> ：</p>
                     </div>
                     <!-- class="section" -->
                     <div class="section">
                        <ul style="list-style-type:disc">
                           <li>
                              <p>如果更改远程过程的参数的初始值，则调用远程过程的本地过程不会失效。如果对远程过程的调用未提供参数，则使用初始值。在这种情况下，由于不会自动发生无效和重新编译，因此使用旧的初始值。要查看新的初始值，请手动重新编译调用过程。</p>
                           </li>
                           <li>
                              <p>如果在包中添加重载过程（与现有过程具有相同名称的过程），则调用远程过程的本地过程不会失效。如果结果是这种重载导致在时间戳模式下从本地过程重新绑定现有调用，则在RPC签名模式下不会发生此重新绑定，因为本地过程不会失效。您必须手动重新编译本地过程才能实现重新绑定。</p>
                           </li>
                           <li>
                              <p>如果更改现有包过程的参数类型以使新类型具有与旧类型相同的形状，则本地调用过程不会自动失效或重新编译。您必须手动重新编译调用过程以获取新类型的语义。</p>
                           </li>
                        </ul>
                     </div>
                     <!-- class="section" -->
                     <div class="section">
                        <p class="subhead3" id="GUID-EC3E3CF1-03EF-40A0-86FF-78D19403DF1F__GUID-138E02E7-E95C-4D9D-B23C-8EFB0C54F76C">话题：</p>
                     </div>
                     <!-- class="section" -->
                     <div class="section">
                        <ul style="list-style-type:disc">
                           <li>
                              <p><a href="schema-object-dependency.html#GUID-352768D5-D2F0-472D-92D8-10B1000857DC">依赖性解决方案</a></p>
                           </li>
                           <li>
                              <p><a href="schema-object-dependency.html#GUID-974AB35A-99A1-4011-9FBC-CB573297FB27">管理依赖关系的建议</a></p>
                           </li>
                        </ul>
                     </div>
                     <!-- class="section" -->
                  </div><a id="ADFNS99971"></a><div class="props_rev_3"><a id="GUID-352768D5-D2F0-472D-92D8-10B1000857DC" name="GUID-352768D5-D2F0-472D-92D8-10B1000857DC"></a><h5 id="ADFNS-GUID-352768D5-D2F0-472D-92D8-10B1000857DC" class="sect5">依赖性解决方案</h5>
                     <div>
                        <p>当<code class="codeph">REMOTE_DEPENDENCIES_MODE = TIMESTAMP</code> （默认值）时，程序单元之间的依赖关系通过比较运行时的时间戳来处理。如果被调用远程过程的时间戳与被调用过程的时间戳不匹配，则调用（从属）单元无效，必须重新编译。在这种情况下，如果没有本地PL / SQL编译器，则调用应用程序无法继续。
                        </p>
                        <p>在时间戳依赖关系模式中，不会比较RPC签名。如果存在本地PL / SQL编译器，则在运行调用过程时会自动重新编译。</p>
                        <p>当<code class="codeph">REMOTE_DEPENDENCIES_MODE = SIGNATURE</code> ，首先将呼叫单元中记录的时间戳与被叫远程单元中的当前时间戳进行比较。如果匹配，则呼叫继续。如果时间戳不匹配，则将调用子程序中记录的被调用远程子程序的RPC签名与被调用子程序的当前RPC签名进行比较。如果它们不匹配（使用<a href="schema-object-dependency.html#GUID-F1AEAA97-05B5-4B08-9233-D061E80000EB">更改数据类型参数类中</a>描述的条件），则会向调用会话返回错误。
                        </p>
                     </div>
                  </div><a id="ADFNS99970"></a><div class="props_rev_3"><a id="GUID-974AB35A-99A1-4011-9FBC-CB573297FB27" name="GUID-974AB35A-99A1-4011-9FBC-CB573297FB27"></a><h5 id="ADFNS-GUID-974AB35A-99A1-4011-9FBC-CB573297FB27" class="sect5">管理依赖关系的建议</h5>
                     <div>
                        <p>请遵循以下准则来设置<code class="codeph">REMOTE_DEPENDENCIES_MODE</code>参数：</p>
                        <ul style="list-style-type:disc">
                           <li>
                              <p>服务器端PL / SQL用户可以将参数设置为<code class="codeph">TIMESTAMP</code> （或者让它默认为该参数）以获得时间戳依赖模式。
                              </p>
                           </li>
                           <li>
                              <p>服务器端PL / SQL用户如果拥有分布式系统并且希望避免可能的不必要的重新编译，则可以使用RPC签名依赖模式。</p>
                           </li>
                           <li>
                              <p>客户端PL / SQL用户必须将参数设置为<code class="codeph">SIGNATURE</code> 。这允许：</p>
                              <ul style="list-style-type:disc">
                                 <li>
                                    <p>在客户端站点安装应用程序而无需重新编译过程。</p>
                                 </li>
                                 <li>
                                    <p>能够升级服务器，而不会遇到时间戳不匹配。</p>
                                 </li>
                              </ul>
                           </li>
                           <li>
                              <p>在服务器端使用RPC签名模式时，请在程序包规范中的过程（或函数）声明末尾添加过程。在声明列表中间添加过程可能会导致不必要的失效和重新编译相关过程。</p>
                           </li>
                        </ul>
                     </div>
                  </div>
               </div>
            </div><a id="ADFNS99969"></a><div class="props_rev_3"><a id="GUID-FEDD8B95-890A-43B2-BB6D-C2D2C17E8278" name="GUID-FEDD8B95-890A-43B2-BB6D-C2D2C17E8278"></a><h3 id="ADFNS-GUID-FEDD8B95-890A-43B2-BB6D-C2D2C17E8278" class="sect3">共享SQL依赖关系管理</h3>
               <div>
                  <p>除了管理模式对象之间的依赖关系之外，Oracle数据库还管理共享池中每个共享SQL区域的依赖关系。如果创建，更改或删除了表，视图，同义词或序列，或者重新编译过程或包规范，则所有相关的共享SQL区域都将失效。在随后执行与无效的共享SQL区域对应的游标时，Oracle数据库会重新分析SQL语句以重新生成共享SQL区域。</p>
               </div>
            </div>
         </div>
      </article>
   </body>
</html>