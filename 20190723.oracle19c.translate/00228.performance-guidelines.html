<html lang="en-us" dir="ltr" xml:lang="en-us">
   <head>
      <meta http-equiv="Content-Type" content="text/html; charset=utf-8"></meta>
      <meta name="viewport" content="width=device-width, initial-scale=1"></meta>
      <meta http-equiv="X-UA-Compatible" content="IE=edge"></meta>
      <title>绩效指南</title>
      <meta property="og:site_name" content="Oracle Help Center"></meta>
      <meta property="og:title" content="Database SecureFiles and Large Objects Developer&#39;s Guide"></meta>
      <meta property="og:description" content=""></meta>
      <link rel="stylesheet" href="/sp_common/book-template/ohc-book-template/css/book.css"></link>
      <link rel="shortcut icon" href="/sp_common/book-template/ohc-common/img/favicon.ico"></link>
      <meta name="application-name" content="Database SecureFiles and Large Objects Developer&#39;s Guide"></meta>
      <meta name="generator" content="DITA Open Toolkit version 1.8.5 (Mode = doc)"></meta>
      <meta name="plugin" content="SP_docbuilder HTML plugin release 18.2.2"></meta>
      <link rel="alternate" href="securefiles-and-large-objects-developers-guide.pdf" title="PDF File" type="application/pdf"></link>
      <meta name="robots" content="all"></meta>
      <link rel="schema.dcterms" href="http://purl.org/dc/terms/"></link>
      <meta name="dcterms.created" content="2019-02-12T02:58:18-08:00"></meta>
      
      <meta name="dcterms.dateCopyrighted" content="1996, 2019"></meta>
      <meta name="dcterms.category" content="database"></meta>
      <meta name="dcterms.identifier" content="E96333-01"></meta>
      
      <meta name="dcterms.product" content="en/database/oracle/oracle-database/19"></meta>
      
      <link rel="prev" href="advanced-design-considerations.html" title="Previous" type="text/html"></link>
      <link rel="next" href="LOB-administration.html" title="Next" type="text/html"></link>
      <script>
        document.write('<style type="text/css">');
        document.write('body > .noscript, body > .noscript ~ * { visibility: hidden; }');
        document.write('</style>');
     </script>
      <script src="/sp_common/book-template/requirejs/require.js" data-main="/sp_common/book-template/ohc-book-template/js/book-config"></script>
      <script>
            if (window.require === undefined) {
                document.write('<script data-main="sp_common/book-template/ohc-book-template/js/book-config" src="sp_common/book-template/requirejs/require.js"><\/script>');
                document.write('<link href="sp_common/book-template/ohc-book-template/css/book.css" rel="stylesheet"/>');
            }
        </script>
      <script type="application/json" id="ssot-metadata">{"primary":{"category":{"short_name":"database","element_name":"Database","display_in_url":true},"suite":{"short_name":"oracle","element_name":"Oracle","display_in_url":true},"product_group":{"short_name":"not-applicable","element_name":"Not applicable","display_in_url":false},"product":{"short_name":"oracle-database","element_name":"Oracle Database","display_in_url":true},"release":{"short_name":"19","element_name":"Release 19","display_in_url":true}}}</script>
      
    <meta name="dcterms.title" content="SecureFiles and Large Objects Developer&#39;s Guide"></meta>
    <meta name="dcterms.isVersionOf" content="ADLOB"></meta>
    <meta name="dcterms.release" content="Release 19"></meta>
  </head>
   <body dir="ltr">
      <div class="noscript alert alert-danger text-center" role="alert">
         <a href="advanced-design-considerations.html" class="pull-left"><span class="glyphicon glyphicon-chevron-left" aria-hidden="true"></span>上一页</a> <a href="LOB-administration.html" class="pull-right">下一页<span class="glyphicon glyphicon-chevron-right" aria-hidden="true"></span></a> <span class="fa fa-exclamation-triangle" aria-hidden="true"></span>必须启用JavaScript才能正确显示此内容</div>
      <article>
         <header>
            <ol class="breadcrumb" vocab="http://schema.org/" typeof="BreadcrumbList">
               <li property="itemListElement" typeof="ListItem"><a href="index.html" property="item" typeof="WebPage"><span property="name">Database SecureFiles和Large Objects Developer's Guide</span></a></li>
               <li property="itemListElement" typeof="ListItem"><a href="application-design-with-LOBs.html" property="item" typeof="WebPage"><span property="name">LOB的应用程序设计</span></a></li>
               <li class="active" property="itemListElement" typeof="ListItem">绩效指南</li>
            </ol>
            <a id="GUID-0EA0E7B7-96E6-4393-B2DA-1F2CA72A72B7" name="GUID-0EA0E7B7-96E6-4393-B2DA-1F2CA72A72B7"></a><a id="ADLOB45549"></a>
            
            <h2 id="ADLOB-GUID-0EA0E7B7-96E6-4393-B2DA-1F2CA72A72B7" class="sect2"><span class="enumeration_chapter">15</span>性能指南</h2>
         </header>
         <div class="ind">
            <div>
               <p>有使用LOB数据类型的应用程序的性能指南。</p>
               <ul style="list-style-type:disc">
                  <li>
                     <p><a href="performance-guidelines.html#GUID-8505852E-936B-477F-B958-14574BB6EDA4" title="LOB预取允许预览数据的初始部分或使用LOB定位器接口访问存储的数据Oracle数据库允许LOB使用数据接口进行读写操作，前提是LOB大小小于可用的缓冲区大小。">LOB性能指南</a></p>
                  </li>
                  <li>
                     <p><a href="performance-guidelines.html#GUID-40E8C7B6-701A-44B2-9295-B9108BF8F61F">在线程环境中将数据移动到LOB</a></p>
                  </li>
                  <li>
                     <p><a href="performance-guidelines.html#GUID-5B66CF22-D22C-4218-A8E5-0D97D88A30EE">LOB访问统计</a></p>
                  </li>
               </ul>
            </div><a id="ADLOB45550"></a><div class="props_rev_3"><a id="GUID-8505852E-936B-477F-B958-14574BB6EDA4" name="GUID-8505852E-936B-477F-B958-14574BB6EDA4"></a><h3 id="ADLOB-GUID-8505852E-936B-477F-B958-14574BB6EDA4" class="sect3">LOB性能指南</h3>
               <div>
                  <p>有各种性能指南适用于使用LOB数据类型的应用程序。</p>
               </div>
               <div>
                  <div class="relinfo">
                     <p><strong>相关话题</strong></p>
                     <ul>
                        <li><a href="performance-guidelines.html#GUID-786F32FA-CC8F-45FE-B589-52A3F954569C">所有LOB</a></li>
                        <li><a href="performance-guidelines.html#GUID-5B91B4C3-ADDE-4153-91FF-589692291A03">持久LOB</a></li>
                        <li><a href="performance-guidelines.html#GUID-4E9360AA-C610-4341-AAD3-9DCDF82CF085">临时LOB</a></li>
                     </ul>
                  </div>
               </div>
               <div class="sect3"><a id="GUID-786F32FA-CC8F-45FE-B589-52A3F954569C" name="GUID-786F32FA-CC8F-45FE-B589-52A3F954569C"></a><h4 id="ADLOB-GUID-786F32FA-CC8F-45FE-B589-52A3F954569C" class="sect4">所有LOB</h4>
                  <div>
                     <p></p>
                     <p>本节介绍使用LOB的准则。</p>
                  </div>
                  <div>
                     <div class="relinfo">
                        <p><strong>相关话题</strong></p>
                        <ul>
                           <li><a href="performance-guidelines.html#GUID-2959491E-25BA-4CE0-9930-7A5DDEB7A78D">块大小</a></li>
                           <li><a href="performance-guidelines.html#GUID-5B89B20C-B438-408B-A5F8-0C4FB447E254">LOB预取</a></li>
                           <li><a href="performance-guidelines.html#GUID-E6412006-5298-49B8-B4ED-AC63E31E735D">小LOB</a></li>
                           <li><a href="performance-guidelines.html#GUID-D513CBA3-ED2F-461B-AF20-CCF02E069429">大LOB</a></li>
                        </ul>
                     </div>
                  </div><a id="ADLOB45551"></a><div class="props_rev_3"><a id="GUID-2959491E-25BA-4CE0-9930-7A5DDEB7A78D" name="GUID-2959491E-25BA-4CE0-9930-7A5DDEB7A78D"></a><h5 id="ADLOB-GUID-2959491E-25BA-4CE0-9930-7A5DDEB7A78D" class="sect5">块大小</h5>
                     <div>
                        <p>块是一个或多个Oracle块。您可以在创建包含LOB的表时指定LOB的块大小。</p>
                        <p>这对应于Oracle数据库在访问或修改LOB值时使用的数据大小。块的一部分用于存储与系统相关的信息，其余部分用于存储LOB值。您正在使用的API具有一个函数，该函数返回LOB块中用于存储LOB值的空间量。在PL / SQL中使用<code class="codeph">DBMS_LOB.GETCHUNKSIZE</code> 。在OCI中，使用<code class="codeph">OCILobGetChunkSize()</code> 。对于SecureFiles，返回表空间块大小的可用数据区域。
                        </p>
                     </div>
                  </div>
                  <div class="sect4"><a id="GUID-5B89B20C-B438-408B-A5F8-0C4FB447E254" name="GUID-5B89B20C-B438-408B-A5F8-0C4FB447E254"></a><h5 id="ADLOB-GUID-5B89B20C-B438-408B-A5F8-0C4FB447E254" class="sect5">LOB预取</h5>
                     <div>
                        <p>LOB预取允许预览数据的初始部分或使用LOB定位器接口来访问存储的数据</p>
                        <p>LOB预取允许执行以下操作：</p>
                        <div class="p">
                           <ul style="list-style-type:disc">
                              <li>
                                 <p>预览数据的初始部分</p>
                              </li>
                              <li>
                                 <p>使用定位器界面访问存储的数据</p>
                              </li>
                           </ul>
                        </div>
                     </div>
                     <div>
                        <div class="relinfo">
                           <p><strong>相关话题</strong></p>
                           <ul>
                              <li><a href="overview-of-supplied-LOB-APIs.html#GUID-2DF37952-AD10-461B-8398-458EAE37BF47">预取LOB数据，长度和块大小</a></li>
                              <li><a href="overview-of-supplied-LOB-APIs.html#GUID-2F5DB980-31B8-4BCE-883C-C93135D8B6C7">预取LOB以提高性能</a></li>
                           </ul>
                        </div>
                     </div>
                  </div>
                  <div class="sect4"><a id="GUID-E6412006-5298-49B8-B4ED-AC63E31E735D" name="GUID-E6412006-5298-49B8-B4ED-AC63E31E735D"></a><h5 id="ADLOB-GUID-E6412006-5298-49B8-B4ED-AC63E31E735D" class="sect5">小LOB</h5>
                     <div>
                        <p>如果LOB大小小于可用缓冲区大小，Oracle数据库允许LOB使用数据接口进行读写操作。</p>
                        <p>如果LOB大小小于可用缓冲区大小，Oracle数据库允许LOB使用数据接口进行数据读写操作。</p>
                     </div>
                     <div>
                        <div class="relinfo">
                           <p><strong>相关话题</strong></p>
                           <ul>
                              <li><a href="data-interface-for-persistent-LOBs.html#GUID-4BFDD493-F3FE-451C-9B03-21669D635586">持久LOB的数据接口</a></li>
                           </ul>
                        </div>
                     </div>
                  </div>
                  <div class="sect4"><a id="GUID-D513CBA3-ED2F-461B-AF20-CCF02E069429" name="GUID-D513CBA3-ED2F-461B-AF20-CCF02E069429"></a><h5 id="ADLOB-GUID-D513CBA3-ED2F-461B-AF20-CCF02E069429" class="sect5">大LOB</h5>
                     <div>
                        <p></p>
                        <p>从Oracle Database 19c发行版开始，分段或回调机制可用于OCILobRead和OCILobWrite操作。</p>
                     </div>
                  </div>
               </div>
               <div class="sect3"><a id="GUID-5B91B4C3-ADDE-4153-91FF-589692291A03" name="GUID-5B91B4C3-ADDE-4153-91FF-589692291A03"></a><h4 id="ADLOB-GUID-5B91B4C3-ADDE-4153-91FF-589692291A03" class="sect4">持久LOB</h4>
                  <div></div>
                  <div>
                     <div class="relinfo">
                        <p><strong>相关话题</strong></p>
                        <ul>
                           <li><a href="performance-guidelines.html#GUID-05BECDAD-4166-4BEF-832D-47FA78BED2E7">Small BasicFiles LOB的性能指南</a></li>
                           <li><a href="performance-guidelines.html#GUID-D895BC0B-A450-4B58-B05C-8EC631F38455">BasicFiles LOB的一般性能指南</a></li>
                        </ul>
                     </div>
                  </div><a id="ADLOB45552"></a><div class="props_rev_3"><a id="GUID-05BECDAD-4166-4BEF-832D-47FA78BED2E7" name="GUID-05BECDAD-4166-4BEF-832D-47FA78BED2E7"></a><h5 id="ADLOB-GUID-05BECDAD-4166-4BEF-832D-47FA78BED2E7" class="sect5">Small BasicFiles LOB的性能指南</h5>
                     <div>
                        <p>如果数据库表中的大多数LOB的大小很小，请使用这些准则。</p>
                        <p>对于数据库表中8K字节或更少字节的LOB，只有少数行包含大于8K字节的LOB，请使用这些指南来最大化数据库性能：</p>
                        <ul style="list-style-type:disc">
                           <li>
                              <p>使用<code class="codeph">ENABLE STORAGE IN ROW</code> 。</p>
                           </li>
                           <li>
                              <p>将<code class="codeph">DB_BLOCK_SIZE</code>初始化参数设置为8K字节，并使用8K字节的块大小。
                              </p>
                           </li>
                           <li>
                              <div class="infoboxnotealso" id="GUID-05BECDAD-4166-4BEF-832D-47FA78BED2E7__NOTE-12332-DFE38D42">
                                 <p class="notep1">也可以看看：</p>
                                 <p><a href="LOB-storage-with-applications.html#GUID-517E1234-EFCD-4D16-B69B-23F72A18A77D">LOB存储参数</a>有关调整LOB段的其他参数（如<code class="codeph">CACHE,</code> <code class="codeph">PCTVERSION</code>和<code class="codeph">CHUNK</code>更多信息</p>
                              </div>
                           </li>
                        </ul>
                     </div>
                  </div><a id="ADLOB45553"></a><div class="props_rev_3"><a id="GUID-D895BC0B-A450-4B58-B05C-8EC631F38455" name="GUID-D895BC0B-A450-4B58-B05C-8EC631F38455"></a><h5 id="ADLOB-GUID-D895BC0B-A450-4B58-B05C-8EC631F38455" class="sect5">BasicFiles LOB的一般性能指南</h5>
                     <div>
                        <p>您可以使用BasicFiles LOB实现最高性能。</p>
                        <p>使用这些指南可以最大限度地提高BasicFiles LOB的性能：</p>
                        <ul style="list-style-type:disc">
                           <li>
                              <p>可能时，读/写<a id="d83472e780" class="indexterm-anchor"></a><a id="d83472e784" class="indexterm-anchor"></a><a id="d83472e786" class="indexterm-anchor"></a>一次大数据块：</p>
                              <p>由于LOB很大，您可以通过一次读取和写入大块LOB值来获得最佳性能。这在几个方面有所帮助：</p>
                              <ol>
                                 <li>
                                    <p>如果从客户端访问LOB并且客户端与服务器位于不同的节点，那么大的读/写会减少网络开销。</p>
                                 </li>
                                 <li>
                                    <p>如果使用<code class="codeph">NOCACHE</code>选项，则每次小的读/写都会产生I / O.读/写大量数据可减少I / O.</p>
                                 </li>
                                 <li>
                                    <p>写入LOB会创建新版本的LOB块。因此，一次写入少量数据会导致每个小写入的新版本的成本。如果启用了日志记录，则块也会存储在重做日志中。</p>
                                 </li>
                              </ol>
                           </li>
                           <li>
                              <p>将<code class="codeph">OCILobRead2()</code>和<code class="codeph">OCILobWrite2()</code>与回调一起使用：</p>
                              <p>这样数据就可以流入和流出LOB。确保在输入的<code class="codeph">amount</code>参数中设置整个写入的长度。只要有可能，读取和写入LOB <span class="italic">块</span>大小的<span class="italic">倍数</span> 。
                              </p>
                           </li>
                           <li>
                              <p>使用Checkout / Check-in Model进行LOB：</p>
                              <p>LOB针对以下操作进行了优化：</p>
                              <ul style="list-style-type:disc">
                                 <li>
                                    <p>SQL <code class="codeph">UPDATE</code>替换整个LOB值</p>
                                 </li>
                                 <li>
                                    <p>将整个LOB数据复制到客户端，修改客户端上的LOB数据，将整个LOB数据复制回数据库。这可以使用<code class="codeph">OCILobRead2</code> （）和<code class="codeph">OCILobWrite2</code> （）与流完成。
                                    </p>
                                 </li>
                              </ul>
                           </li>
                           <li>
                              <p>经常提交更改。</p>
                           </li>
                        </ul>
                     </div>
                  </div>
               </div><a id="ADLOB106"></a><a id="ADLOB105"></a><div class="props_rev_3"><a id="GUID-4E9360AA-C610-4341-AAD3-9DCDF82CF085" name="GUID-4E9360AA-C610-4341-AAD3-9DCDF82CF085"></a><h4 id="ADLOB-GUID-4E9360AA-C610-4341-AAD3-9DCDF82CF085" class="sect4">临时LOB</h4>
                  <div>
                     <p>除了关于LOB性能的<span class="q">“ <a href="performance-guidelines.html#GUID-8505852E-936B-477F-B958-14574BB6EDA4" title="LOB预取允许预览数据的初始部分或使用LOB定位器接口访问存储的数据Oracle数据库允许LOB使用数据接口进行读写操作，前提是LOB大小小于可用的缓冲区大小。">LOB性能指南</a> ”中</span>描述的指南之外，以下是使用临时LOB的一些指导原则：</p>
                     <ul style="list-style-type:disc">
                        <li>
                           <p>使用PGA内存来存储临时LOB以提高性能。</p>
                        </li>
                        <li>
                           <p>使用单独的临时表空间进行临时LOB存储，而不是使用默认系统表空间</p>
                           <p>这可以避免在将数据从持久LOB复制到临时LOB时发生设备争用。</p>
                           <p>如果在应用程序中使用新提供的增强型SQL语义功能，那么SQL和PL / SQL中会比以前静默创建更多临时LOB。确保用于存储这些临时LOB的<span class="italic"><span class="bold">临时表空间</span></span> <span class="italic"><span class="bold">足够大，</span></span>以便您的应用程序使用。特别是，当您使用以下内容时，将以静默方式创建这些临时LOB：</p>
                           <ul style="list-style-type:disc">
                              <li>
                                 <p>LOB上的SQL函数</p>
                              </li>
                              <li>
                                 <p>LOB上的PL / SQL内置字符函数</p>
                              </li>
                              <li>
                                 <p>从<code class="codeph">VARCHAR2</code> / <code class="codeph">RAW</code>到<code class="codeph">CLOB</code> s / <code class="codeph">BLOB</code>的变量赋值。
                                 </p>
                              </li>
                              <li>
                                 <p>执行<code class="codeph">LONG</code> to- <code class="codeph">LOB</code>迁移</p>
                              </li>
                           </ul>
                        </li>
                        <li>
                           <p>如果在LOB上使用SQL运算符，则PGA内存和临时表空间必须足够大，以容纳SQL运算符生成的临时LOB。</p>
                        </li>
                        <li>
                           <p>释放从SQL查询和PL / SQL程序返回的临时LOB</p>
                           <p>在PL / SQL，C（OCI），Java和其他编程接口中，SQL查询结果或PL / SQL程序执行返回临时LOB以进行LOB上的操作/函数调用。例如：</p><pre class="oac_no_warn" dir="ltr">SELECT substr（CLOB_Column，4001,32000）FROM ...
</pre><p>如果在PL / SQL中执行查询，则在PL / SQL程序块结束时自动释放返回的临时LOB。您还可以随时显式释放临时LOB。在OCI和Java中，必须显式释放返回的临时LOB。</p>
                           <p>如果没有正确释放从SQL查询返回的临时LOB，则会填充临时表空间，您可能会发现性能下降。</p>
                        </li>
                        <li>
                           <p>在PL / SQL中，使用<a id="d83472e990" class="indexterm-anchor"></a> NOCOPY尽可能通过引用传递临时LOB参数。
                           </p>
                           <div class="infoboxnotealso" id="GUID-4E9360AA-C610-4341-AAD3-9DCDF82CF085__NOTE-12223-DFE41FBA">
                              <p class="notep1">也可以看看：</p>
                              <p>有关通过引用和参数别名传递参数的更多信息，请<a href="../lnpls/overview.html#LNPLS-GUID-2FBCFBBE-6B42-4DB8-83F3-55B63B75B1EB" target="_blank"><span><cite>参见Oracle Database PL / SQL语言参考</cite></span></a></p>
                           </div>
                        </li>
                        <li>
                           <p>利用临时LOB上的缓冲区缓存。</p>
                           <p> <a id="d83472e1006" class="indexterm-anchor"></a><a id="d83472e1010" class="indexterm-anchor"></a><a id="d83472e1014" class="indexterm-anchor"></a>将CACHE参数设置为true创建的临时LOB在缓冲区缓存中移动。否则，临时LOB将直接从磁盘读取并直接写入磁盘。
                           </p>
                        </li>
                        <li>
                           <p>为获得最佳性能，临时LOB使用读取时的引用，写入语义上的复制。将临时LOB定位器分配给另一个定位器时，不会复制物理LOB数据。使用任一LOB定位符的后续READ操作指的是相同的物理LOB数据。在赋值后的第一个WRITE操作中，复制物理LOB数据以保留LOB值语义，即，确保每个定位符指向唯一的LOB值。此性能考虑主要适用于PL / SQL和OCI环境。</p>
                           <p>在PL / SQL中，有关读取，写入语义复制的参考说明如下：</p><pre class="oac_no_warn" dir="ltr">LOCATOR1 BLOB; LOCATOR2 BLOB; DBMS_LOB.CREATETEMPORARY（LOCATOR1，TRUE，DBMS_LOB.SESSION）; - 在此赋值操作中不复制LOB数据：LOCATOR2：= LOCATOR; - 这些读取操作引用相同的物理LOB副本：DBMS_LOB.READ（LOCATOR1，...）; DBMS_LOB.GETLENGTH（LOCATOR2，...）; -  LOB数据的物理副本在WRITE上进行：DBMS_LOB.WRITE（LOCATOR2，...）;</pre><p>在OCI中，为了确保LOB定位符和数据的值语义， <code class="codeph">OCILobLocatorAssign()</code>用于复制临时LOB定位符和LOB数据。<code class="codeph">OCILobLocatorAssign()</code>不会往返服务器。当LOB更新在与LOB更新API相同的往返中发生时，进行物理临时LOB复制，如下所示：</p><pre class="oac_no_warn" dir="ltr">OCILobLocator * LOC1; OCILobLocator * LOC2; OCILobCreateTemporary（...LOC1，......TRUE，OCI_DURATION_SESSION）; / *以下呼叫不会产生往返。* / OCILobLocatorAssign（...LOC1，LOC2）; / *读取操作指的是相同的物理LOB副本。* / OCILobRead2（...LOC1 ...）/ *为了制作* LOB数据的新副本并写入新的LOB副本，会产生一次往返。* / OCILobWrite2（...LOC1 ...）/ * LOC2看不到与LOC1相同的LOB数据。* / OCILobRead2（...LOC2 ...）

</pre><p>如果不打算使用LOB值语义，那么可以使用C指针来实现引用语义，如下所示：</p><pre class="oac_no_warn" dir="ltr">OCILobLocator * LOC1; OCILobLocator * LOC2; OCILobCreateTemporary（...LOC1，......TRUE，OCI_DURATION_SESSION）; / *指针被复制。LOC1和LOC2指的是相同的LOB数据。* / LOC2 = LOC1; / *写入LOC2。* / OCILobWrite2（...LOC2 ...）/ * LOC1看到对LOC2的更改。* / OCILobRead2（...LOC1 ...）
</pre></li>
                        <li>
                           <p>对临时LOB使用OCI_OBJECT模式</p>
                           <p>要提高LOB分配上临时LOB的性能， <code class="codeph">OCI_OBJECT</code>模式用于<code class="codeph">OCILobLocatorAssign()</code> 。在<code class="codeph">OCI_OBJECT</code>模式下，数据库尝试最小化要执行的深层副本的数量。因此，在<code class="codeph">OCI_OBJECT</code>模式下对源临时LOB完成<code class="codeph">OCILobLocatorAssign()</code>之后，源和目标定位器指向相同的LOB，直到通过任一LOB定位器进行任何修改。
                           </p>
                        </li>
                     </ul>
                  </div>
               </div>
            </div><a id="ADLOB45556"></a><a id="ADLOB45557"></a><a id="ADLOB45555"></a><div class="props_rev_3"><a id="GUID-40E8C7B6-701A-44B2-9295-B9108BF8F61F" name="GUID-40E8C7B6-701A-44B2-9295-B9108BF8F61F"></a><h3 id="ADLOB-GUID-40E8C7B6-701A-44B2-9295-B9108BF8F61F" class="sect3">在线程环境中将数据移动到LOB</h3>
               <div>
                  <p>您可以使用两种可能的过程将数据移动到线程环境中的LOB，其中一个应该避免。</p>
                  <div class="section">
                     <p class="subhead2" id="GUID-40E8C7B6-701A-44B2-9295-B9108BF8F61F__GUID-B179BBED-4F7E-4250-8778-12327443478A">推荐程序</p>
                  </div>
                  <!-- class="section" -->
                  <div class="section">
                     <div class="infoboxnote" id="GUID-40E8C7B6-701A-44B2-9295-B9108BF8F61F__GUID-262E3250-3717-41A1-88F6-76678921E716">
                        <p class="notep1">注意：</p>
                        <p></p>
                        <ul style="list-style-type:disc">
                           <li>
                              <p>在此过程中无需创建空LOB。</p>
                           </li>
                           <li>
                              <p>您可以使用<code class="codeph">RETURNING</code>子句作为<code class="codeph">INSERT/UPDATE</code>语句的一部分来返回锁定的LOB定位器。这消除了执行<code class="codeph">SELECT-FOR-UPDATE</code> ，如步骤3中所述。
                              </p>
                           </li>
                        </ul>
                     </div>
                     <p>建议的程序如下：</p>
                     <ol>
                        <li>
                           <p><code class="codeph">INSERT</code>一个空的LOB， <code class="codeph">RETURNING</code> LOB定位器。
                           </p>
                        </li>
                        <li>
                           <p>使用此定位器将数据移动到LOB中。</p>
                        </li>
                        <li>
                           <p><code class="codeph">COMMIT</code> 。这将释放ROW锁并使LOB数据持久化。
                           </p>
                        </li>
                     </ol>
                     <p>或者，您可以直接为LOB列或LOB属性插入超过4000个字节的数据。</p>
                  </div>
                  <!-- class="section" -->
                  <div class="section">
                     <p class="subhead2" id="GUID-40E8C7B6-701A-44B2-9295-B9108BF8F61F__GUID-B9DE57EA-9A65-4E80-9DB2-26F54460BF1E">避免的程序</p>
                  </div>
                  <!-- class="section" -->
                  <div class="section">
                     <p>以下序列在使用线程环境时需要新连接，会对性能产生负面影响，因此不建议：</p>
                     <ol>
                        <li>
                           <p>创建一个空（非<code class="codeph">NULL</code> ）LOB</p>
                        </li>
                        <li>
                           <p>使用空LOB执行<code class="codeph">INSERT</code></p>
                        </li>
                        <li>
                           <p>刚输入的行的<code class="codeph">SELECT-FOR-UPDATE</code></p>
                        </li>
                        <li>
                           <p>将数据移动到LOB中</p>
                        </li>
                        <li>
                           <p><code class="codeph">COMMIT</code> 。这将释放<code class="codeph">ROW</code>锁并使LOB数据持久化。
                           </p>
                        </li>
                     </ol>
                  </div>
                  <!-- class="section" -->
               </div>
            </div><a id="ADLOB0710"></a><div class="props_rev_3"><a id="GUID-5B66CF22-D22C-4218-A8E5-0D97D88A30EE" name="GUID-5B66CF22-D22C-4218-A8E5-0D97D88A30EE"></a><h3 id="ADLOB-GUID-5B66CF22-D22C-4218-A8E5-0D97D88A30EE" class="sect3">LOB访问统计</h3>
               <div>
                  <p>在Oracle Database <span class="italic">10g</span>第2版之后，用户可以使用三个特定于LOB的会话级统计信息：LOB读取，LOB写入和LOB写入未对齐。
                  </p>
                  <p>可以通过<code class="codeph">V$MYSTAT</code> ， <code class="codeph">V$SESSTAT</code>和<code class="codeph">V$SYSSTAT</code>动态性能视图访问会话统计<code class="codeph">V$SYSSTAT</code> 。要查询这些视图，必须为用户授予<code class="codeph">SELECT_CATALOG_ROLE</code> ， <code class="codeph">SELECT ON SYS.V_$MYSTAT</code>视图和<code class="codeph">SELECT ON SYS.V_$STATNAME</code>视图的<code class="codeph">SELECT ON SYS.V_$STATNAME</code> 。
                  </p>
                  <p><a id="d83472e1302" class="indexterm-anchor"></a><a id="d83472e1304" class="indexterm-anchor"></a><a id="d83472e1306" class="indexterm-anchor"></a> LOB读取定义为在会话/系统中执行的LOB API读取操作的数量。单个LOB API读取可以对应于多个物理/逻辑磁盘块读取。
                  </p>
                  <p>LOB写入定义为在会话/系统中执行的LOB API写入操作的数量。单个LOB API写入可以对应于多个物理/逻辑磁盘块写入。</p>
                  <p>LOB写入未对齐定义为LOB API写入操作的数量，其起始偏移量或缓冲区大小未与LOB的内部块大小对齐。与块边界对齐的写入是最有效的写入操作。LOB的内部块大小可通过LOB API获得（例如，使用PL / SQL，通过<code class="codeph">DBMS_LOB.GETCHUNKSIZE()</code> ）。
                  </p>
                  <p>以下简单示例演示了当用户对LOB执行读/写操作时如何更新LOB会话统计信息。</p>
                  <p>值得注意的是，会话统计信息跨操作聚合到会话中访问的所有LOB;统计信息不按对象分隔或分类（即表，列，段，对象编号等）。</p>
                  <p>在这些示例中，您为每次演示重新连接到数据库以清除<code class="codeph">V$MYSTAT</code> 。这使您可以查看lob统计信息如何针对您正在测试的特定操作进行更改，而不会对同一会话中的过去LOB操作产生潜在的模糊影响。
                  </p>
                  <div class="infoboxnote" id="GUID-5B66CF22-D22C-4218-A8E5-0D97D88A30EE__GUID-5FA04D0B-03B2-4E3F-A81D-3DB21C2485CA">
                     <p class="notep1">也可以看看：</p>
                     <p><a href="../refrn/statistics-descriptions.html#REFRN103" target="_blank"><span class="italic">Oracle数据库参考</span></a> ，附录E，“统计描述”</p>
                  </div>
               </div><a id="ADLOB45558"></a><div class="props_rev_3"><a id="GUID-C8AD5DF4-BA4F-411E-B2A7-B58C355F3790" name="GUID-C8AD5DF4-BA4F-411E-B2A7-B58C355F3790"></a><h4 id="ADLOB-GUID-C8AD5DF4-BA4F-411E-B2A7-B58C355F3790" class="sect4">检索LOB访问统计信息的示例</h4>
                  <div>
                     <div class="section">
                        <p>此示例演示检索LOB访问统计信息。</p><pre class="oac_no_warn" dir="ltr">rem rem设置用户rem CONNECT / AS SYSDBA; SET ECHO ON; GRANT SELECT_CATALOG_ROLE到pm; GRANT SELECT ON sys.v_ $ mystat TO pm; GRANT SELECT ON sys.v_ $ statname TO pm; rem rem为统计查询创建一个简化视图rem CONNECT pm; SET ECHO ON; DROP VIEW mylobstats; CREATE VIEW mylobstats AS SELECT SUBSTR（n.name，1,20）name，m.value value FROM v $ mystat m，v $ statname n WHERE m.statistic＃= n.statistic＃AND n.name LIKE'love％' ; rem rem创建一个测试表rem DROP TABLE t; CREATE TABLE t（i NUMBER，c CLOB）lob（c）STORE AS（在行中禁用存储）; rem rem填充一些数据rem rem这应该导致未对齐的写入，一个用于rem每行/ lob填充。rem CONNECT pm SELECT * FROM mylobstats;插入值（1，'a'）;插入值（2，rpad（'a'，4000，'a'））;承诺; SELECT * FROM mylobstats; rem rem获取lob长度rem rem计算lob长度不读取lob数据，读取/写入统计数据没有变化rem。rem CONNECT pm; SELECT * FROM mylobstats; SELECT LENGTH（c）FROM t; SELECT * FROM mylobstats; rem rem阅读lobs rem rem Lob读取执行，表中每个吊球一个。rem CONNECT pm; SELECT * FROM mylobstats; SELECT * FROM t; SELECT * FROM mylobstats; rem rem读取和操作lobs（通过临时lobs）rem rem使用复杂的操作符如“substr（）”会导致rem隐式创建和使用临时lobs。临时lobs的操作rem也更新了lob统计数据。rem CONNECT pm; SELECT * FROM mylobstats; SELECT substr（c，length（c），1）FROM t; SELECT substr（c，1,1）FROM t; SELECT * FROM mylobstats; rem rem执行一些对齐的覆盖rem rem只更新lob写入统计信息，因为写入的rem字节偏移量和写入的缓冲区rem的大小都在lob chunksize上对齐。rem CONNECT pm; SELECT * FROM mylobstats; DECLARE loc CLOB; buf LONG;块数; BEGIN SELECT c INTO loc FROM t WHERE i = 1 FOR UPDATE; chunk：= DBMS_LOB.GETCHUNKSIZE（loc）; buf：= rpad（'b'，chunk，'b'）; - 对齐的缓冲区长度和偏移量DBMS_LOB.WRITE（loc，chunk，1，buf）; DBMS_LOB.WRITE（loc，chunk，1 + chunk，buf）;承诺;结束; / SELECT * FROM mylobstats; rem rem执行一些未对齐的覆盖rem rem由于写字节偏移rem和缓冲区大小中的一个或两个与lob的chunksize不对齐，所以高速写入和高速未对齐的写入统计都会被更新。rem CONNECT pm; SELECT * FROM mylobstats; DECLARE loc CLOB; buf LONG; BEGIN SELECT c INTO loc FROM t WHERE i = 1 FOR UPDATE; buf：= rpad（'b'，DBMS_LOB.GETCHUNKSIZE（loc），'b'）; - 未对齐的缓冲区长度DBMS_LOB.WRITE（loc，DBMS_LOB.GETCHUNKSIZE（loc）-1,1，buf）; - 未对齐的起始偏移量DBMS_LOB.WRITE（loc，DBMS_LOB.GETCHUNKSIZE（loc），2，buf）; - 未对齐的缓冲区长度和起始偏移量DBMS_LOB.WRITE（loc，DBMS_LOB.GETCHUNKSIZE（loc）-1,2，buf）;承诺;结束; / SELECT * FROM mylobstats; DROP TABLE t; DROP VIEW mylobstats; CONNECT / AS SYSDBA REVOKE SELECT_CATALOG_ROLE FROM pm;在sys.v_ $ mystat FROM pm上进行REVOKE SELECT;在sys.v_ $ statname FROM pm上进行REVOKE SELECT;放弃;</pre></div>
                     <!-- class="section" -->
                  </div>
               </div>
            </div>
         </div>
      </article>
   </body>
</html>