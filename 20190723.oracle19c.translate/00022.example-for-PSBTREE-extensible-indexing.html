<html lang="en-us" dir="ltr" xml:lang="en-us">
   <head>
      <meta http-equiv="Content-Type" content="text/html; charset=utf-8"></meta>
      <meta name="viewport" content="width=device-width, initial-scale=1"></meta>
      <meta http-equiv="X-UA-Compatible" content="IE=edge"></meta>
      <title>PSBTREE：可扩展索引示例</title>
      <meta property="og:site_name" content="Oracle Help Center"></meta>
      <meta property="og:title" content="Data Cartridge Developer&#39;s Guide"></meta>
      <meta property="og:description" content=""></meta>
      <link rel="stylesheet" href="/sp_common/book-template/ohc-book-template/css/book.css"></link>
      <link rel="shortcut icon" href="/sp_common/book-template/ohc-common/img/favicon.ico"></link>
      <meta name="application-name" content="Data Cartridge Developer&#39;s Guide"></meta>
      <meta name="generator" content="DITA Open Toolkit version 1.8.5 (Mode = doc)"></meta>
      <meta name="plugin" content="SP_docbuilder HTML plugin release 18.2.2"></meta>
      <link rel="alternate" href="data-cartridge-developers-guide.pdf" title="PDF File" type="application/pdf"></link>
      <meta name="robots" content="all"></meta>
      <link rel="schema.dcterms" href="http://purl.org/dc/terms/"></link>
      <meta name="dcterms.created" content="2019-01-10T07:34:53-08:00"></meta>
      <meta name="dcterms.title" content="Data Cartridge Developer&#39;s Guide"></meta>
      <meta name="dcterms.dateCopyrighted" content="1996, 2019"></meta>
      <meta name="dcterms.category" content="database"></meta>
      <meta name="dcterms.identifier" content="E96431-01"></meta>
      
      <meta name="dcterms.product" content="en/database/oracle/oracle-database/19"></meta>
      
      <link rel="prev" href="example-for-power-demand-cartridge.html" title="Previous" type="text/html"></link>
      <link rel="next" href="example-for-pipelined-table-functions-interface-approach.html" title="Next" type="text/html"></link>
      <script>
        document.write('<style type="text/css">');
        document.write('body > .noscript, body > .noscript ~ * { visibility: hidden; }');
        document.write('</style>');
     </script>
      <script src="/sp_common/book-template/requirejs/require.js" data-main="/sp_common/book-template/ohc-book-template/js/book-config"></script>
      <script>
            if (window.require === undefined) {
                document.write('<script data-main="sp_common/book-template/ohc-book-template/js/book-config" src="sp_common/book-template/requirejs/require.js"><\/script>');
                document.write('<link href="sp_common/book-template/ohc-book-template/css/book.css" rel="stylesheet"/>');
            }
        </script>
      <script type="application/json" id="ssot-metadata">{"primary":{"category":{"short_name":"database","element_name":"Database","display_in_url":true},"suite":{"short_name":"oracle","element_name":"Oracle","display_in_url":true},"product_group":{"short_name":"not-applicable","element_name":"Not applicable","display_in_url":false},"product":{"short_name":"oracle-database","element_name":"Oracle Database","display_in_url":true},"release":{"short_name":"19","element_name":"Release 19","display_in_url":true}}}</script>
      
    <meta name="dcterms.isVersionOf" content="ADDCI"></meta>
    <meta name="dcterms.release" content="Release 19"></meta>
  </head>
   <body dir="ltr">
      <div class="noscript alert alert-danger text-center" role="alert">
         <a href="example-for-power-demand-cartridge.html" class="pull-left"><span class="glyphicon glyphicon-chevron-left" aria-hidden="true"></span>上一页</a> <a href="example-for-pipelined-table-functions-interface-approach.html" class="pull-right">下一页<span class="glyphicon glyphicon-chevron-right" aria-hidden="true"></span></a> <span class="fa fa-exclamation-triangle" aria-hidden="true"></span>必须启用JavaScript才能正确显示此内容</div>
      <article>
         <header>
            <ol class="breadcrumb" vocab="http://schema.org/" typeof="BreadcrumbList">
               <li property="itemListElement" typeof="ListItem"><a href="index.html" property="item" typeof="WebPage"><span property="name">数据盒式开发人员指南</span></a></li>
               <li property="itemListElement" typeof="ListItem"><a href="scenarios-and-examples.html" property="item" typeof="WebPage"><span property="name">场景和示例</span></a></li>
               <li class="active" property="itemListElement" typeof="ListItem">PSBTREE：可扩展索引示例</li>
            </ol>
            <a id="GUID-BCF6B1CB-56CD-458D-8D27-79281119E9CF" name="GUID-BCF6B1CB-56CD-458D-8D27-79281119E9CF"></a><a id="ADDCI3160"></a>
            
            <h2 id="ADDCI-GUID-BCF6B1CB-56CD-458D-8D27-79281119E9CF" class="sect2"><span class="enumeration_chapter">16</span> PSBTREE：可扩展索引示例</h2>
         </header>
         <div class="ind">
            <div>
               <p>这是一个可扩展索引的例子，用C语言实现<code class="codeph">ODCIIndex</code>接口例程。
               </p>
            </div><a id="ADDCI4877"></a><div class="props_rev_3"><a id="GUID-8EC65F3C-3BD1-4A8F-B270-39E6D7BFA31D" name="GUID-8EC65F3C-3BD1-4A8F-B270-39E6D7BFA31D"></a><h3 id="ADDCI-GUID-8EC65F3C-3BD1-4A8F-B270-39E6D7BFA31D" class="sect3"><span class="enumeration_section">16.1</span>关于PSBTREE示例</h3>
               <div>
                  <div class="section">
                     <p>考虑如何在C中实现可扩展索引接口例程。该示例的重点是所有实现共有的主题;它不会公开特定于域的详细信息。</p>
                     <p>该示例的代码位于demo目录中的<code class="codeph">extdemo6.sql</code>文件中。它通过添加indextype支持扩展了早期的示例（ <code class="codeph">extdemo2.sql</code> ，也在demo目录中） <a id="d56830e120" class="indexterm-anchor"></a>范围分区表上的本地域索引。
                     </p>
                  </div>
                  <!-- class="section" -->
               </div>
            </div><a id="ADDCI4878"></a><div class="props_rev_3"><a id="GUID-C41EDFE2-4E3F-4AED-8A60-B87FFB8100EE" name="GUID-C41EDFE2-4E3F-4AED-8A60-B87FFB8100EE"></a><h3 id="ADDCI-GUID-C41EDFE2-4E3F-4AED-8A60-B87FFB8100EE" class="sect3"><span class="enumeration_section">16.2</span>索引类型的设计</h3>
               <div>
                  <p>该<a id="d56830e178" class="indexterm-anchor"></a>这里实现的indextype，称为<code class="codeph">PSBtree,</code>就像b树索引一样运行。它支持三个用户定义的运算符： <code class="codeph">eq</code> （等于）， <code class="codeph">lt</code> （小于）和<code class="codeph">gt</code> （大于）。这些运算符在<code class="codeph">VARCHAR2</code>数据类型的操作数上运行。
                  </p>
                  <p>索引数据由<code class="codeph">&lt;key, rid&gt;</code>形式的记录组成，其中<code class="codeph">key</code>是索引列的值， <code class="codeph">rid</code>是相应行的行标识符。为了简化indextype的实现，索引数据存储在系统分区表中。
                  </p>
                  <p>当索引是系统管理的本地域索引时，将为每个分区创建系统分区表中的一个分区，以存储该分区的索引数据。因此，索引操作例程仅将<code class="codeph">PSBtree</code>操作<code class="codeph">PSBtree</code>为存储索引数据的表分区上的操作。
                  </p>
                  <p>当用户创建<code class="codeph">PSBtree</code>索引（本地索引）时，将创建<code class="codeph">n</code>表分区，其中包含索引列和<code class="codeph">rowid</code>列，其中<code class="codeph">n</code>是基表中的分区数。插入基表会导致适当插入受影响的索引表分区。删除和更新的处理方式类似。当基于用户定义的运算符（ <code class="codeph">gt</code> ， <code class="codeph">lt</code>和<code class="codeph">eq</code> ）查询<code class="codeph">PSBtree</code> ，针对索引表分区发出适当的查询以检索所有令人满意的行。发生适当的分区修剪，并且仅访问对应于相关或“有趣”分区的索引表分区。
                  </p>
               </div>
            </div><a id="ADDCI4879"></a><div class="props_rev_3"><a id="GUID-3F0EC8EC-1286-4F39-AF1B-931E2F9BE56F" name="GUID-3F0EC8EC-1286-4F39-AF1B-931E2F9BE56F"></a><h3 id="ADDCI-GUID-3F0EC8EC-1286-4F39-AF1B-931E2F9BE56F" class="sect3"><span class="enumeration_section">16.3</span>实施运营商</h3>
               <div>
                  <p><code class="codeph">PSBtree</code>索引类型支持三个运算符： <code class="codeph">eq</code> ， <code class="codeph">gt</code>和<code class="codeph">lt</code> 。每个操作员都有相应的功能实现。
                  </p>
               </div><a id="ADDCI4880"></a><div class="props_rev_3"><a id="GUID-72B9F965-1889-44D6-A0E7-27868DAAF155" name="GUID-72B9F965-1889-44D6-A0E7-27868DAAF155"></a><h4 id="ADDCI-GUID-72B9F965-1889-44D6-A0E7-27868DAAF155" class="sect4"><span class="enumeration_section">16.3.1</span>功能实现</h4>
                  <div>
                     <p>考虑比较运算符的功能实现。<a href="example-for-PSBTREE-extensible-indexing.html#GUID-7BE87A0B-B67C-4302-970D-A0765D06E29B">实现EQUALS运算符</a>部分解释了如何实现<code class="codeph">eq</code> （等于）， <a href="example-for-PSBTREE-extensible-indexing.html#GUID-9D34953A-1B52-47E5-88CE-95BD3629FDDF">实现</a>少量<a href="example-for-PSBTREE-extensible-indexing.html#GUID-9D34953A-1B52-47E5-88CE-95BD3629FDDF">运算符</a>部分解释了如何实现<code class="codeph">lt</code> （小于），并且<a href="example-for-PSBTREE-extensible-indexing.html#GUID-5AA6096E-0070-4A1D-BB89-8063B55FB242">实现GREAT THAN运算符</a>部分解释了如何实现<code class="codeph">gt</code> （大于）运算符。
                     </p>
                  </div><a id="CACFGDEF"></a><div class="props_rev_3"><a id="GUID-7BE87A0B-B67C-4302-970D-A0765D06E29B" name="GUID-7BE87A0B-B67C-4302-970D-A0765D06E29B"></a><h5 id="ADDCI-GUID-7BE87A0B-B67C-4302-970D-A0765D06E29B" class="sect5"><span class="enumeration_section">16.3.1.1</span>实现EQUALS运算符</h5>
                     <div>
                        <div class="section">
                           <p><code class="codeph">eq</code>的功能实现由函数（ <code class="codeph">bt_eq</code> ）提供，该函数接收两个<code class="codeph">VARCHAR2</code>参数，如果它们相等则返回<code class="codeph">1</code> ，否则返回<code class="codeph">0</code> 。
                           </p><pre class="oac_no_warn" dir="ltr">创建函数bt_eq（VARCHAR2，b VARCHAR2）如果a = b则返回返回数字，然后返回1; ELSE RETURN 0;万一;结束;</pre></div>
                        <!-- class="section" -->
                     </div>
                  </div><a id="CACBEEIH"></a><div class="props_rev_3"><a id="GUID-9D34953A-1B52-47E5-88CE-95BD3629FDDF" name="GUID-9D34953A-1B52-47E5-88CE-95BD3629FDDF"></a><h5 id="ADDCI-GUID-9D34953A-1B52-47E5-88CE-95BD3629FDDF" class="sect5"><span class="enumeration_section">16.3.1.2</span>实现<span class="enumeration_section">少于</span>运营商</h5>
                     <div>
                        <div class="section">
                           <p><code class="codeph">lt</code>的函数实现由函数（ <code class="codeph">bt_lt</code> ）提供，该函数接收两个<code class="codeph">VARCHAR2</code>参数，如果第一个参数小于第二个参数则返回<code class="codeph">1</code> ，否则返回<code class="codeph">0</code> 。
                           </p><pre class="oac_no_warn" dir="ltr">CREATE FUNCTION bt_lt（VARCHAR2，b VARCHAR2）如果a &lt;b则返回返回1; ELSE RETURN 0;万一;结束;</pre></div>
                        <!-- class="section" -->
                     </div>
                  </div><a id="CACDGGHF"></a><div class="props_rev_3"><a id="GUID-5AA6096E-0070-4A1D-BB89-8063B55FB242" name="GUID-5AA6096E-0070-4A1D-BB89-8063B55FB242"></a><h5 id="ADDCI-GUID-5AA6096E-0070-4A1D-BB89-8063B55FB242" class="sect5"><span class="enumeration_section">16.3.1.3</span>实施<span class="enumeration_section">大于</span>运营商</h5>
                     <div>
                        <div class="section">
                           <p><code class="codeph">gt</code>的功能实现由函数（ <code class="codeph">bt_gt</code> ）提供，该函数接收两个<code class="codeph">VARCHAR2</code>参数，如果第一个参数大于第二个参数则返回<code class="codeph">1</code> ，否则返回<code class="codeph">0</code> 。
                           </p><pre class="oac_no_warn" dir="ltr">创建功能bt_gt（一个VARCHAR2，b VARCHAR2）如果a&gt; b然后返回1，则返回数字为BEGIN; ELSE RETURN 0;万一;结束;</pre></div>
                        <!-- class="section" -->
                     </div>
                  </div>
               </div><a id="ADDCI4885"></a><a id="ADDCI4886"></a><a id="ADDCI4887"></a><a id="ADDCI4884"></a><div class="props_rev_3"><a id="GUID-F1A45ABC-3ED1-404A-93BA-57352F3E0C7B" name="GUID-F1A45ABC-3ED1-404A-93BA-57352F3E0C7B"></a><h4 id="ADDCI-GUID-F1A45ABC-3ED1-404A-93BA-57352F3E0C7B" class="sect4"><span class="enumeration_section">16.3.2</span>运营商</h4>
                  <div>
                     <p>要创建运算符，必须指定运算符的签名及其返回类型及其功能实现。<a href="example-for-PSBTREE-extensible-indexing.html#GUID-F1A45ABC-3ED1-404A-93BA-57352F3E0C7B__CACGHFEC">例16-1</a>显示了如何创建<code class="codeph">eq</code> （等于）， <a href="example-for-PSBTREE-extensible-indexing.html#GUID-F1A45ABC-3ED1-404A-93BA-57352F3E0C7B__CACDBEEI">例16-2</a>显示了如何创建<code class="codeph">lt</code> （小于）， <a href="example-for-PSBTREE-extensible-indexing.html#GUID-F1A45ABC-3ED1-404A-93BA-57352F3E0C7B__CACHCAHE">例16-3</a>显示了如何创建<code class="codeph">gt</code> （大于）运算符。
                     </p>
                     <div class="example" id="GUID-F1A45ABC-3ED1-404A-93BA-57352F3E0C7B__CACGHFEC">
                        <p class="titleinexample">例16-1创建EQUALS运算符</p><pre class="oac_no_warn" dir="ltr">CREATE OPERATOR eq BINDING（VARCHAR2，VARCHAR2）使用bt_eq返回数字;</pre></div>
                     <!-- class="example" -->
                     <div class="example" id="GUID-F1A45ABC-3ED1-404A-93BA-57352F3E0C7B__CACDBEEI">
                        <p class="titleinexample">例16-2创建少数运算符</p><pre class="oac_no_warn" dir="ltr">创建运算符lt BINDING（VARCHAR2，VARCHAR2）使用bt_lt返回数字;</pre></div>
                     <!-- class="example" -->
                     <div class="example" id="GUID-F1A45ABC-3ED1-404A-93BA-57352F3E0C7B__CACHCAHE">
                        <p class="titleinexample">示例16-3创建更大的运算符</p><pre class="oac_no_warn" dir="ltr">CREATE OPERATOR gt BINDING（VARCHAR2，VARCHAR2）使用bt_gt返回数字;</pre></div>
                     <!-- class="example" -->
                  </div>
               </div>
            </div><a id="ADDCI4888"></a><div class="props_rev_3"><a id="GUID-F76F035E-4432-4555-9039-2E66E064D67E" name="GUID-F76F035E-4432-4555-9039-2E66E064D67E"></a><h3 id="ADDCI-GUID-F76F035E-4432-4555-9039-2E66E064D67E" class="sect3"><span class="enumeration_section">16.4</span>实现ODCIIndex接口</h3>
               <div>
                  <p>要实现<code class="codeph">PSBTREE</code> ，您必须实现<code class="codeph">ODCIIndex</code> <span class="italic"><code class="codeph">XXX</code></span> <code class="codeph">()</code>例程。您可以使用Oracle支持的任何语言实现索引例程。本讨论使用C编程语言实现<a href="extensible-indexing-interface.html#GUID-28AC1C1B-6B6B-446F-A6C9-EEF4A4842D5F">ODCIGetInterfaces（）</a>例程。请注意，这些需要提前设置，例如为已编译的C代码创建库对象<code class="codeph">extdemo6l</code> 。
                  </p>
               </div><a id="ADDCI4890"></a><a id="ADDCI4889"></a><div class="props_rev_3"><a id="GUID-3EFF8FF0-A7EB-4BA8-9BFE-A3B25787BAC1" name="GUID-3EFF8FF0-A7EB-4BA8-9BFE-A3B25787BAC1"></a><h4 id="ADDCI-GUID-3EFF8FF0-A7EB-4BA8-9BFE-A3B25787BAC1" class="sect4"><span class="enumeration_section">16.4.1</span>定义PSBTREE的实现类型</h4>
                  <div>
                     <div class="section">
                        <p>定义实现<code class="codeph">ODCIIndex</code>接口例程的实现类型，如<a href="example-for-PSBTREE-extensible-indexing.html#GUID-3EFF8FF0-A7EB-4BA8-9BFE-A3B25787BAC1__CACCEJJA">例16-4所示</a> 。
                        </p>
                     </div>
                     <!-- class="section" -->
                     <div class="example" id="GUID-3EFF8FF0-A7EB-4BA8-9BFE-A3B25787BAC1__CACCEJJA">
                        <p class="titleinexample">示例16-4创建PSBTREE索引类型</p><pre class="oac_no_warn" dir="ltr">CREATE TYPE psbtree_im AUTHID CURRENT_USER AS OBJECT（scanctx RAW（4），STATIC FUNCTION ODCIGetInterfaces（ifclist OUT SYS.ODCIObjectList）返回编号，静态功能ODCIIndexCreate（ia SYS.ODCIIndexInfo，parms VARCHAR2，env SYS.ODCIEnv）返回编号，静态功能ODCIIndexAlter （ia sys。ODCIIndexInfo，parms IN OUT VARCHAR2，altopt number，env sys。ODCIEnv）返回编号，静态功能ODCIIndexDrop（ia SYS.ODCIIndexInfo，env SYS.ODCIEnv）返回编号，静态功能ODCIIndexExchangePartition（ia SYS.ODCIIndexInfo，ia1 SYS.ODCIIndexInfo，env SYS.ODCIEnv）返回编号，静态功能ODCIIndexUpdPartMetadata（ia sys 。ODCIIndexInfo，palist sys。ODCIPartInfoList，env sys。ODCIEnv）返回数字，静态函数ODCIIndexInsert（ia SYS.ODCIIndexInfo，rid VARCHAR2，newval VARCHAR2，env SYS.ODCIEnv）RETURN NUMBER，STATIC FUNCTION ODCIIndexDelete（ia SYS.ODCIIndexInfo，rid VARCHAR2，oldval VARCHAR2，env SYS.ODCIEnv）RETURN NUMBER ，STATIC FUNCTION ODCIIndexUpdate（ia SYS.ODCIIndexInfo，rid VARCHAR2，oldval VARCHAR2，newval VARCHAR2，env SYS.ODCIEnv）RETURN NUMBER，STATIC FUNCTION ODCIIndexStart（sctx IN OUT psbtree_im，ia SYS.ODCIIndexInfo，op SYS.ODCIPredInfo，qi sys。ODCIQueryInfo，strt number，stop number，cmpval VARCHAR2，env SYS.ODCIEnv）RETURN NUMBER，MEMBER FUNCTION ODCIIndexFetch（nrows NUMBER，rids OUT SYS.ODCIridlist，env SYS.ODCIEnv）RETURN NUMBER，MEMBER FUNCTION ODCIIndexClose（env SYS.ODCIEnv）RETURN NUMBER）; /显示错误</pre></div>
                     <!-- class="example" -->
                  </div>
               </div><a id="ADDCI4892"></a><a id="ADDCI4891"></a><div class="props_rev_3"><a id="GUID-2616416C-EC74-41FD-B435-7956E4CB49E8" name="GUID-2616416C-EC74-41FD-B435-7956E4CB49E8"></a><h4 id="ADDCI-GUID-2616416C-EC74-41FD-B435-7956E4CB49E8" class="sect4"><span class="enumeration_section">16.4.2</span>创建实现类型主体</h4>
                  <div>
                     <div class="section">
                        <p>定义实现类型主体，如<a href="example-for-PSBTREE-extensible-indexing.html#GUID-2616416C-EC74-41FD-B435-7956E4CB49E8__CACEJJHI">例16-5所示</a> 。
                        </p>
                     </div>
                     <!-- class="section" -->
                     <div class="example" id="GUID-2616416C-EC74-41FD-B435-7956E4CB49E8__CACEJJHI">
                        <p class="titleinexample">示例16-5为PBSTREE创建实现主体</p><pre class="oac_no_warn" dir="ltr">创建或替换类型身体psbtree_im IS</pre></div>
                     <!-- class="example" -->
                  </div>
               </div><a id="ADDCI4893"></a><div class="props_rev_3"><a id="GUID-385BF144-F676-468E-A9A6-7633E0939A1A" name="GUID-385BF144-F676-468E-A9A6-7633E0939A1A"></a><h4 id="ADDCI-GUID-385BF144-F676-468E-A9A6-7633E0939A1A" class="sect4"><span class="enumeration_section">16.4.3</span>在实现主体中定义PL / SQL例程</h4>
                  <div>
                     <div class="section">
                        <p>考虑如何在PL / SQL中实现索引定义例程。</p>
                     </div>
                     <!-- class="section" -->
                  </div><a id="ADDCI4894"></a><div class="props_rev_3"><a id="GUID-CD482284-5973-4954-9086-DAFD9E872FE7" name="GUID-CD482284-5973-4954-9086-DAFD9E872FE7"></a><h5 id="ADDCI-GUID-CD482284-5973-4954-9086-DAFD9E872FE7" class="sect5"><span class="enumeration_section">16.4.3.1</span>在PL / SQL中为<span class="enumeration_section">PBSTREE</span>实现ODCIGetInterfaces（）</h5>
                     <div>
                        <div class="section">
                           <p><a href="extensible-indexing-interface.html#GUID-28AC1C1B-6B6B-446F-A6C9-EEF4A4842D5F">ODCIGetInterfaces（）</a>例程通过其<code class="codeph">OUT</code>参数返回预期的接口名称。
                           </p><pre class="oac_no_warn" dir="ltr">静态功能ODCIGetInterfaces（ifclist OUT sys。ODCIObjectList）RETURN NUMBER是BEGIN ifclist：= sys。ODCIObjectList（SYS。ODCIObject（ 'SYS'， 'ODCIINDEX2'））;返回ODCIConst。成功; END ODCIGetInterfaces;</pre></div>
                        <!-- class="section" -->
                     </div>
                  </div><a id="CACGFBIH"></a><div class="props_rev_3"><a id="GUID-39085EE4-83FD-4EBF-9C01-B96EA74F7E83" name="GUID-39085EE4-83FD-4EBF-9C01-B96EA74F7E83"></a><h5 id="ADDCI-GUID-39085EE4-83FD-4EBF-9C01-B96EA74F7E83" class="sect5"><span class="enumeration_section">16.4.3.2</span>在PL / SQL中为<span class="enumeration_section">PBSTREE</span>实现ODCIIndexCreate（）</h5>
                     <div>
                        <div class="section">
                           <p><a href="extensible-indexing-interface.html#GUID-C14A0478-6EA1-4EAE-BAA6-AA59EE5D300C">ODCIIndexCreate（）</a>例程创建一个包含两列的系统分区索引存储表。第一列存储<code class="codeph">VARCHAR2</code>索引列值。该例程利用传入的信息来确定调用它的上下文。动态SQL用于执行动态构造的SQL语句。
                           </p><pre class="oac_no_warn" dir="ltr">静态功能ODCIIndexCreate（ias sys。ODCIIndexInfo，parms VARCHAR2，env sys。ODCIEnv）返回号码是我整数; stmt VARCHAR2（2000）; cursor cur1（ianame VARCHAR2）IS SELECT partition_name，参数FROM user_ind_partitions WHERE index_name = ianame ORDER BY partition_position; cursor cur2（ianame VARCHAR2）IS SELECT subpartition_name，parameters FROM user_ind_subpartitions WHERE index_name = ianame ORDER BY partition_position，subpartition_position; BEGIN stmt：=''; IF（env.CallProperty为null）那么stmt：='create table'|| IA。IndexSchema || '' || IA。IndexName || '_sbtree（f1 VARCHAR2（1000），f2 rowid）'; ELSIF（env.CallProperty = sys。ODCIConst。FirstCall）那么stmt：='';我：= 1; IF（bitand（ia。IndexInfoFlags，ODCIConst。CompPartn）= 0）那么对于cur1中的c1（ia。IndexName）LOOP IF（i&gt; 1）那么stmt：= stmt || '';万一; stmt：= stmt || '分区'|| c2.partition_name; i：= i + 1;结束循环; EL1 for cur1中的c1（ia。IndexName）LOOP IF（i&gt; 1）那么stmt：= stmt || '';万一; stmt：= stmt || '分区'|| c2.subpartition_name; i：= i + 1;结束循环;万一; stmt：='create table'|| IA。IndexSchema || '' || IA。IndexName || '_sbtree（f1 VARCHAR2（1000），f2 rowid）按系统'||分区'（'|| stmt ||'）'; ELSIF（env.CallProperty = sys。ODCIConst。FinalCall）那么stmt：='创建索引'|| IA。IndexSchema || '' || IA。IndexName || '_sbti on'|| IA。IndexSchema || '' || IA。IndexName || '_sbtree（f1）local';万一; DBMS_OUTPUT.PUT_LINE（ '创建'）; DBMS_OUTPUT.PUT_LINE（语句）; - 执行语句IF（（env.CallProperty为null）或（env.CallProperty = sys。ODCIConst。FirstCall）OR（env.CallProperty = sys。ODCIConst。FinalCall））然后执行立即stmt; IF（env.CallProperty为null）然后立即执行'insert into'|| IA。IndexSchema || '' || IA。IndexName || '_sbtree select'|| IA。IndexCols（1）。ColName || '，ROWID来自'|| IA。IndexCols（1）。TableSchema || '' || IA。IndexCols（1）。表名;立即执行'创建索引'|| IA。IndexSchema || ”。'|| IA。IndexName || '_sbti on'|| IA。IndexSchema || ”。'|| IA。IndexName || '_sbtree（f1）';万一;万一;返回ODCIConst。成功; END ODCIIndexCreate;</pre></div>
                        <!-- class="section" -->
                     </div>
                  </div><a id="CACDJCFF"></a><div class="props_rev_3"><a id="GUID-43232667-0102-4BCD-9C00-D106F8D049D2" name="GUID-43232667-0102-4BCD-9C00-D106F8D049D2"></a><h5 id="ADDCI-GUID-43232667-0102-4BCD-9C00-D106F8D049D2" class="sect5"><span class="enumeration_section">16.4.3.3</span>在PL / SQL中为<span class="enumeration_section">PBSTREE</span>实现ODCIIndexDrop（）</h5>
                     <div>
                        <div class="section">
                           <p><a href="extensible-indexing-interface.html#GUID-F128CB3B-6B3E-41C3-A623-67BCB5BC9292">ODCIIndexDrop（）</a>例程删除索引存储表。
                           </p><pre class="oac_no_warn" dir="ltr">静态功能ODCIIndexDrop（ia sys。ODCIIndexInfo，env sys。ODCIEnv）返回号码是stmt VARCHAR2（1000）; cnum INTEGER;垃圾INTEGER; BEGIN  - 构造sql语句stmt：=''; IF（env.CallProperty为null）那么stmt：='drop table'|| IA。IndexSchema || '' || IA。IndexName || '_sbtree'; DBMS_OUTPUT.PUT_LINE（ '删除'）; DBMS_OUTPUT.PUT_LINE（语句）;执行立即执行;万一;返回ODCIConst。成功; END ODCIIndexDrop;</pre></div>
                        <!-- class="section" -->
                     </div>
                  </div><a id="CACCCEAE"></a><div class="props_rev_3"><a id="GUID-E998D8C0-7AC7-45FB-9B1C-757C356BB878" name="GUID-E998D8C0-7AC7-45FB-9B1C-757C356BB878"></a><h5 id="ADDCI-GUID-E998D8C0-7AC7-45FB-9B1C-757C356BB878" class="sect5"><span class="enumeration_section">16.4.3.4</span>在PL / SQL中为<span class="enumeration_section">PSBTREE</span>实现ODCIIndexAlter（）</h5>
                     <div>
                        <div class="section">
                           <p><a href="extensible-indexing-interface.html#GUID-9DB1D609-69C3-483B-AA77-087AD51A3A55">ODCIIndexAlter（）</a>例程可以执行许多索引更改任务，例如重建和重命名索引。
                           </p><pre class="oac_no_warn" dir="ltr">静态功能ODCIIndexAlter（ia sys。ODCIIndexInfo，parms IN OUT VARCHAR2，altopt NUMBER，env sys。ODCIEnv）返回号码是stmt VARCHAR2（2000）; BEGIN stmt：=''; IF（altopt = ODCIConst。AlterIndexRebuild）那么（ia。IndexPartition为null）那么stmt：='insert into'|| IA。IndexSchema || '' || IA。IndexName || '_sbtree select'|| IA。IndexCols（1）。ColName || '，ROWID来自'|| IA。IndexCols（1）。ColName || '，ROWID来自'|| IA。IndexCols（1）。TableSchema || '' || IA。IndexCols（1）。表名; ELSIF（bitand（ia。IndexInfoFlags，ODCIConst。CompPartn）= 0）那么stmt：='insert into'|| IA。IndexSchema || '' || IA。IndexName || '_sbtree选择分区（'|| ia。IndexPartition || '）'|| IA。IndexCols（1）。ColName || '，ROWID来自'|| IA。IndexCols（1）。TableSchema || '' || IA。IndexCols（1）。TableName || '分区（'|| ia。IndexCols（1）。TablePartition || '）'; ELSE stmt：='insert into'|| IA。IndexSchema || '' || IA。IndexName || '_sbtree选择分区（'|| ia。IndexPartition || '）'|| IA。IndexCols（1）。ColName || '，ROWID来自'|| IA。IndexCols（1）。TableSChema || '' || IA。IndexCols（1）。TableName || 'subpartition（'|| ia。IndexCols（1）。TablePartition || '）';万一; ELSIF（altopt = ODCIConst。AlterIndexRename）那么（ia。IndexPartition不为null）那么stmt：='alter table'|| IA。IndexSchema || '' || IA。IndexName || '_sbtree重命名分区'|| IA。IndexPartition || '到'|| PARMS; ELSE stmt：='alter table'|| IA。IndexSchema || '' || IA。IndexName || '_sbtree重命名为'|| parms || '_sbtree';万一;万一; DBMS_OUTPUT.PUT_LINE（ '阿尔特'）; IF（（altopt = ODCIConst。AlterIndexRebuild）OR（altopt = ODCIConst。AlterIndexRename））那么dbms_output.put_line（stmt）;执行立即执行;万一;返回ODCIConst。成功; END ODCIIndexAlter;</pre></div>
                        <!-- class="section" -->
                     </div>
                  </div><a id="CACBFDJC"></a><div class="props_rev_3"><a id="GUID-DBE32065-CCF1-4A08-967C-38DF4A37B9CA" name="GUID-DBE32065-CCF1-4A08-967C-38DF4A37B9CA"></a><h5 id="ADDCI-GUID-DBE32065-CCF1-4A08-967C-38DF4A37B9CA" class="sect5"><span class="enumeration_section">16.4.3.5</span>在PL / SQL中为<span class="enumeration_section">PSBTREE</span>实现ODCIIndexUpdPartMetadata（）</h5>
                     <div>
                        <div class="section">
                           <p>为了处理分区维护操作，内核代表用户执行维护任务。indextype用于维护其元数据，应具有<a href="extensible-indexing-interface.html#GUID-C2C4DB40-106A-491C-B241-985B69DC2FE1">ODCIIndexUpdPartMetadata（）</a>例程。
                           </p><pre class="oac_no_warn" dir="ltr">静态功能ODCIIndexUpdPartMetadata（ia sys。ODCIIndexInfo，palist sys。ODCIPartInfoList，env sys。ODCIEnv）返回号码是col号码; BEGIN dbms_output.put_line（'ODCIUpdPartMetadata'）; SYS。ODCIIndexInfoDump（IA）; SYS。ODCIPartInfoListDump（palist）; SYS。ODCIEnvDump（ENV）;返回ODCIConst。成功; END ODCIIndexUpdPartMetadata;</pre></div>
                        <!-- class="section" -->
                     </div>
                  </div><a id="CACJCGBH"></a><div class="props_rev_3"><a id="GUID-395A7999-CD4F-4995-8455-F6D51D3710EF" name="GUID-395A7999-CD4F-4995-8455-F6D51D3710EF"></a><h5 id="ADDCI-GUID-395A7999-CD4F-4995-8455-F6D51D3710EF" class="sect5"><span class="enumeration_section">16.4.3.6</span>在PL / SQL中为<span class="enumeration_section">PSBTREE</span>实现ODCIIndexExchangePartition（）</h5>
                     <div>
                        <div class="section">
                           <p><a href="extensible-indexing-interface.html#GUID-7914F874-620F-48F1-ADDC-040CC82D46ED">ODCIIndexExchangePartition（）</a>与正在交换的索引分区交换索引存储表，以及全局域索引的索引存储表。
                           </p><pre class="oac_no_warn" dir="ltr">静态功能ODCIIndexExchangePartition（ia sys。ODCIIndexInfo，ia1 sys。ODCIIndexInfo，env sys。ODCIEnv）返回号码是stmt VARCHAR2（2000）; cnum INTEGER;垃圾INTEGER; BEGIN stmt：=''; dbms_output.put_line（'Exchange Partition'）; - 构造sql语句IF bitand（ia。IndexInfoFlags，ODCIConst。CompPartn）= 0 OR位和（ia。IndexInfoFlags，ODCIConst。SubPartn）= ODCIConst。SubPartn THEN  - 非复合分区或交换子分区stmt：='alter table'|| IA。IndexSchema || '' || IA。IndexName || '_sbtree exchange partition'|| IA。IndexPartition || 'with table'|| IA1。IndexSchema || '' || IA1。IndexName || '_sbtree'; DBMS_OUTPUT.PUT_LINE（语句）;执行立即执行; ELSE  - 复合分区交换stmt：='create table temp_exch（f1 VARCHAR2（1000），f2 rowid）'; DBMS_OUTPUT.PUT_LINE（语句）;执行立即执行; stmt：='alter table'|| IA。IndexSchema || '' || IA。IndexName || '_sbtree exchange partition'|| IA。IndexPartition || 'with table'|| 'temp_exch'; DBMS_OUTPUT.PUT_LINE（语句）;执行立即执行; stmt：='alter table'|| IA1。IndexSchema || '' || IA1。IndexName || '_sbtree exchange partition'|| IA1。IndexPartition || 'with table'|| 'temp_exch'; DBMS_OUTPUT.PUT_LINE（语句）;执行立即执行; stmt：='alter table'|| IA。IndexSchema || '' || IA。IndexName || '_sbtree exchange partition'|| IA。IndexPartition || 'with table'|| 'temp_exch'; DBMS_OUTPUT.PUT_LINE（语句）;执行立即执行; - 交换完成，删除时态表stmt：='drop table temp_exch'; DBMS_OUTPUT.PUT_LINE（语句）;执行立即执行;万一;返回ODCIConst。成功; END ODCIIndexExchangePartition;</pre></div>
                        <!-- class="section" -->
                     </div>
                  </div>
               </div><a id="ADDCI4900"></a><div class="props_rev_3"><a id="GUID-8B2FF627-9464-4AD9-9D0E-EFC637BB99B0" name="GUID-8B2FF627-9464-4AD9-9D0E-EFC637BB99B0"></a><h4 id="ADDCI-GUID-8B2FF627-9464-4AD9-9D0E-EFC637BB99B0" class="sect4"><span class="enumeration_section">16.4.4</span>注册ODCIIndex <span class="italic">XXX</span> （）方法的C实现</h4>
                  <div>
                     <div class="section">
                        <p>为已编译的C方法创建<code class="codeph">extdemo6l</code>库对象后，必须注册每个例程的实现。<a href="example-for-PSBTREE-extensible-indexing.html#GUID-D833A9A8-B063-48B6-8ACD-790C406FFDFB">注册ODCIIndexInsert（）</a>部分<a href="example-for-PSBTREE-extensible-indexing.html#GUID-D833A9A8-B063-48B6-8ACD-790C406FFDFB">的实现</a>演示了如何注册ODCIIndexInsert（）实现， <a href="example-for-PSBTREE-extensible-indexing.html#GUID-429B7A88-369D-46F3-8E27-035CA9EDEEB3">注册实现ODCIIndexDelete（）</a>部分注册ODCIIndexDelete（）实现， <a href="example-for-PSBTREE-extensible-indexing.html#GUID-20EAB399-76F5-4C79-AE81-63B8956504F7">注册实现ODCIIndexUpdate（）</a>部分注册ODCIIndexUpdate（）实现， <a href="example-for-PSBTREE-extensible-indexing.html#GUID-687358AC-BD5C-4C8B-84C8-1F7B285736E3">注册ODCIIndexStart（）</a>部分<a href="example-for-PSBTREE-extensible-indexing.html#GUID-687358AC-BD5C-4C8B-84C8-1F7B285736E3">的实现</a>注册ODCIIndexStart（）实现， <a href="example-for-PSBTREE-extensible-indexing.html#GUID-8B31366C-39CE-42CA-9A13-6AAE30180EFE">注册实现ODCIIndexFetch（）</a>部分注册ODCIIndexFetch（）实现，并<a href="example-for-PSBTREE-extensible-indexing.html#GUID-E3A862DE-F07C-4681-BBE4-8339AD0A4D32">注册实现ODCIIndexClose（）</a>部分注册ODCIIndexClose（）实现。
                        </p>
                     </div>
                     <!-- class="section" -->
                  </div><a id="CACGAHCG"></a><div class="props_rev_3"><a id="GUID-D833A9A8-B063-48B6-8ACD-790C406FFDFB" name="GUID-D833A9A8-B063-48B6-8ACD-790C406FFDFB"></a><h5 id="ADDCI-GUID-D833A9A8-B063-48B6-8ACD-790C406FFDFB" class="sect5"><span class="enumeration_section">16.4.4.1</span>注册ODCIIndexInsert（）的实现</h5>
                     <div>
                        <div class="section">
                           <p>注册<a href="extensible-indexing-interface.html#GUID-EF42025B-6DE2-4F2A-90EF-62775EE0EED6">ODCIIndexInsert（）</a>例程的实现。
                           </p><pre class="oac_no_warn" dir="ltr">静态函数ODCIIndexInsert（ia SYS.ODCIIndexInfo，rid VARCHAR2，newval VARCHAR2，env SYS.ODCIEnv）RETURN NUMBER AS EXTERNAL name“qxiqtbspi”library extdemo6l with context parameters（context，ia，ia indicator struct，rid，rid indicator，newval，newval indicator，env，env indicator struct，return OCINumber）;</pre></div>
                        <!-- class="section" -->
                     </div>
                  </div><a id="CACBHAHC"></a><div class="props_rev_3"><a id="GUID-429B7A88-369D-46F3-8E27-035CA9EDEEB3" name="GUID-429B7A88-369D-46F3-8E27-035CA9EDEEB3"></a><h5 id="ADDCI-GUID-429B7A88-369D-46F3-8E27-035CA9EDEEB3" class="sect5"><span class="enumeration_section">16.4.4.2</span>注册ODCIIndexDelete（）的实现</h5>
                     <div>
                        <div class="section">
                           <p>注册<a href="extensible-indexing-interface.html#GUID-4B2E080D-FE8B-4598-9084-56FBE255196B">ODCIIndexDelete（）</a>例程的实现。
                           </p><pre class="oac_no_warn" dir="ltr">静态函数ODCIIndexDelete（ia SYS.ODCIIndexInfo，rid VARCHAR2，oldval VARCHAR2，env SYS.ODCIEnv）RETURN NUMBER AS EXTERNAL name“qxiqtbspd”library extdemo6l with context parameters（context，ia，ia indicator struct，rid，rid indicator，oldval，oldval indicator，env，env indicator struct，return OCINumber）;</pre></div>
                        <!-- class="section" -->
                     </div>
                  </div><a id="CACBCCEH"></a><div class="props_rev_3"><a id="GUID-20EAB399-76F5-4C79-AE81-63B8956504F7" name="GUID-20EAB399-76F5-4C79-AE81-63B8956504F7"></a><h5 id="ADDCI-GUID-20EAB399-76F5-4C79-AE81-63B8956504F7" class="sect5"><span class="enumeration_section">16.4.4.3</span>注册ODCIIndexUpdate（）的实现</h5>
                     <div>
                        <div class="section">
                           <p>注册<a href="extensible-indexing-interface.html#GUID-CB42E738-EFD1-4053-9DDF-BEF455F92815">ODCIIndexUpdate（）</a>例程的实现。
                           </p><pre class="oac_no_warn" dir="ltr">静态函数ODCIIndexUpdate（ia SYS.ODCIIndexInfo，rid VARCHAR2，oldval VARCHAR2，newval VARCHAR2，env SYS.ODCIEnv）RETURN NUMBER AS EXTERNAL name“qxiqtbspu”library extdemo6l with context parameters（context，ia，ia indicator struct，rid，rid indicator， oldval，oldval指标，newval，newval指标，env，env指标结构，返回OCINumber）;</pre></div>
                        <!-- class="section" -->
                     </div>
                  </div><a id="CACJADGC"></a><div class="props_rev_3"><a id="GUID-687358AC-BD5C-4C8B-84C8-1F7B285736E3" name="GUID-687358AC-BD5C-4C8B-84C8-1F7B285736E3"></a><h5 id="ADDCI-GUID-687358AC-BD5C-4C8B-84C8-1F7B285736E3" class="sect5"><span class="enumeration_section">16.4.4.4</span>注册ODCIIndexStart（）的实现</h5>
                     <div>
                        <div class="section">
                           <p>注册<a href="extensible-indexing-interface.html#GUID-53F2321C-B0F8-4783-AC1B-056372A0C073">ODCIIndexStart（）</a>例程的实现。
                           </p><pre class="oac_no_warn" dir="ltr">静态函数ODCIIndexStart（sctx IN OUT psbtree_im，iS SYS.ODCIIndexInfo，op SYS.ODCIInredInfo，qi SYS.ODCIQueryInfo，strt NUMBER，stop NUMBER，cmpval VARCHAR2，env SYS.ODCIEnv）RETURN NUMBER AS EXTERNAL name“qxiqtbsps”library extdemo6l with context参数（context，sctx，sctx指标结构，ia，ia指标结构，op，op指标结构，qi，qi指标结构，strt，strt指标，止损，止损指标，cmpval，cmpval指标，env，env指标结构，返回OCINumber）;</pre></div>
                        <!-- class="section" -->
                     </div>
                  </div><a id="ADDCI4905"></a><div class="props_rev_3"><a id="GUID-8B31366C-39CE-42CA-9A13-6AAE30180EFE" name="GUID-8B31366C-39CE-42CA-9A13-6AAE30180EFE"></a><h5 id="ADDCI-GUID-8B31366C-39CE-42CA-9A13-6AAE30180EFE" class="sect5"><span class="enumeration_section">16.4.4.5</span>注册ODCIIndexFetch（）的实现</h5>
                     <div>
                        <div class="section">
                           <p>注册<a href="extensible-indexing-interface.html#GUID-BB601420-A858-46E3-A9AC-3433220D4F82">ODCIIndexFetch（）</a>例程的实现。
                           </p><pre class="oac_no_warn" dir="ltr">成员函数ODCIIndexFetch（nrows NUMBER，rids OUT SYS.ODCIRidList，env SYS.ODCIEnv）返回NUMBER作为EXTERNAL名称“qxiqtbspf”库extdemo6l，带有上下文参数（context，self，self indicator struct，nrows，nrows indicator，rids，rids indicator， env，env指标结构，返回OCINumber）;</pre></div>
                        <!-- class="section" -->
                     </div>
                  </div><a id="CACIDHBA"></a><div class="props_rev_3"><a id="GUID-E3A862DE-F07C-4681-BBE4-8339AD0A4D32" name="GUID-E3A862DE-F07C-4681-BBE4-8339AD0A4D32"></a><h5 id="ADDCI-GUID-E3A862DE-F07C-4681-BBE4-8339AD0A4D32" class="sect5"><span class="enumeration_section">16.4.4.6</span>注册ODCIIndexClose（）的实现</h5>
                     <div>
                        <div class="section">
                           <p>注册<a href="extensible-indexing-interface.html#GUID-2F49CDE4-C064-4644-948C-BBF014FDD8C8">ODCIIndexClose（）</a>例程的实现。
                           </p><pre class="oac_no_warn" dir="ltr">成员函数ODCIIndexClose（env SYS.ODCIEnv）返回数字作为外部名称“qxiqtbspc”库extdemo6l，带有上下文参数（context，self，self indicator struct，env，env indicator struct，return OCINumber）;</pre></div>
                        <!-- class="section" -->
                     </div>
                  </div>
               </div><a id="ADDCI4908"></a><a id="ADDCI4909"></a><a id="ADDCI4907"></a><div class="props_rev_3"><a id="GUID-23A0F15E-6AAC-49EB-9DF1-82F732C657CE" name="GUID-23A0F15E-6AAC-49EB-9DF1-82F732C657CE"></a><h4 id="ADDCI-GUID-23A0F15E-6AAC-49EB-9DF1-82F732C657CE" class="sect4"><span class="enumeration_section">16.4.5</span>在C实现中定义其他结构</h4>
                  <div>
                     <div class="section">
                        <p><code class="codeph">stuct</code> <code class="codeph">qxiqtim</code> ， <code class="codeph">struct qciqtin</code>和<code class="codeph">struct</code> <code class="codeph">qxiqtcx</code>用于映射对象类型及其<code class="codeph">null</code>值（在<a href="example-for-PSBTREE-extensible-indexing.html#GUID-23A0F15E-6AAC-49EB-9DF1-82F732C657CE__CACBHEBF">例16-6中</a>演示），以及在获取调用期间保持状态（在<a href="example-for-PSBTREE-extensible-indexing.html#GUID-23A0F15E-6AAC-49EB-9DF1-82F732C657CE__CACCIGGI">例16-7中</a>演示）。这些结构由<a href="example-for-PSBTREE-extensible-indexing.html#GUID-857BD94C-1C99-48ED-99A0-1A90D5793AF4">实施主体</a>中<a href="example-for-PSBTREE-extensible-indexing.html#GUID-857BD94C-1C99-48ED-99A0-1A90D5793AF4">定义C方法中</a>描述的方法使用。
                        </p>
                        <p>用于映射ODCI类型的C <code class="codeph">struct</code>在文件<code class="codeph">odci.h</code>中定义。例如，C <code class="codeph">struct</code> <code class="codeph">ODCIIndexInfo</code>是相应ODCI对象类型的映射。C <code class="codeph">struct</code> <code class="codeph">ODCIIndexInfo_ind</code>是<code class="codeph">null</code>对象的映射。
                        </p>
                     </div>
                     <!-- class="section" -->
                     <div class="example" id="GUID-23A0F15E-6AAC-49EB-9DF1-82F732C657CE__CACBHEBF">
                        <p class="titleinexample">示例16-6定义对象类型的映射及其空值</p>
                        <p>我们已经定义了一个C <code class="codeph">struct</code> <code class="codeph">qxiqtim</code>作为对象类型的映射。对于相应的<code class="codeph">null</code>对象，还有一个额外的C <code class="codeph">struct</code> <code class="codeph">qxiqtin</code> 。可以从对象类型转换器（OTT）生成对象类型的C <code class="codeph">struct</code>及其<code class="codeph">null</code>对象。
                        </p><pre class="oac_no_warn" dir="ltr">/ *索引实现类型是具有单个RAW属性*的对象类型，用于存储上下文键值。*实现类型的C映射：* / struct qxiqtim {OCIRaw * sctx_qxiqtim; }; typedef struct qxiqtim qxiqtim; struct qxiqtin {short atomic_qxiqtin; scind_qxiqtin; }; typedef struct qxiqtin qxiqtin;</pre></div>
                     <!-- class="example" -->
                     <div class="example" id="GUID-23A0F15E-6AAC-49EB-9DF1-82F732C657CE__CACCIGGI">
                        <p class="titleinexample">例16-7在获取呼叫期间保持扫描状态</p>
                        <p>有一组OCI句柄必须在获取调用期间缓存并检索。AC <code class="codeph">struct</code> <code class="codeph">qxiqtcx</code>定义为保存所有必要的扫描状态。此结构从<code class="codeph">OCI_DURATION_STATEMENT</code>内存中分配，以确保它持续到<code class="codeph">fetch</code>结束。在使用所需信息填充结构后，指向结构的指针将保存在OCI上下文中。上下文由通过调用OCI例程生成的4字节密钥标识。4字节密钥存储在扫描上下文中 - <code class="codeph">exiting</code> 。此对象将返回到Oracle服务器，并作为参数传递给下一个fetch调用。
                        </p><pre class="oac_no_warn" dir="ltr">/ *索引扫描上下文 - 应存储在“语句”持续时间内存*中，并由start，fetch和close例程使用。* / struct qxiqtcx {OCIStmt * stmthp; OCIDefine * defnp; OCIBind * bndp; char ridp [19]; }; typedef struct qxiqtcx qxiqtcx;</pre></div>
                     <!-- class="example" -->
                  </div>
               </div><a id="ADDCI4910"></a><div class="props_rev_3"><a id="GUID-857BD94C-1C99-48ED-99A0-1A90D5793AF4" name="GUID-857BD94C-1C99-48ED-99A0-1A90D5793AF4"></a><h4 id="ADDCI-GUID-857BD94C-1C99-48ED-99A0-1A90D5793AF4" class="sect4"><span class="enumeration_section">16.4.6</span>在实施机构中定义C方法</h4>
                  <div>
                     <p>考虑如何在C语言中实现PSBEETree方法。</p>
                  </div><a id="CACJIECE"></a><div class="props_rev_3"><a id="GUID-17BABF87-B59B-4434-B06D-CC5C3F168A5C" name="GUID-17BABF87-B59B-4434-B06D-CC5C3F168A5C"></a><h5 id="ADDCI-GUID-17BABF87-B59B-4434-B06D-CC5C3F168A5C" class="sect5"><span class="enumeration_section">16.4.6.1</span>在C中实现常见错误处理例程</h5>
                     <div>
                        <div class="section">
                           <p>此函数用于检查和处理来自所有<code class="codeph">OCI</code>例程的返回码。它会检查状态代码并在出现错误时引发异常。
                           </p><pre class="oac_no_warn" dir="ltr">static int qxiqtce（OCIExtProcContext * ctx，OCIError * errhp，sword status）{text errbuf [512]; sb4 errcode = 0; int errnum = 29400; / *选择一些oracle错误号* / int rc = 0; switch（status）{case OCI_SUCCESS：rc = 0;打破; case OCI_ERROR：（void）OCIErrorGet（（dvoid *）errhp，（ub4）1，（text *）NULL，＆errcode，errbuf，（ub4）sizeof（errbuf），OCI_HTYPE_ERROR）; / *引发异常* / OCIExtProcRaiseExcpWithMsg（ctx，errnum，errbuf，strlen（（char *）errbuf））; rc = 1;打破; default：（void）sprintf（（char *）errbuf，“Warning  -  some error \ n”）; / *引发异常* / OCIExtProcRaiseExcpWithMsg（ctx，errnum，errbuf，strlen（（char *）errbuf））; rc = 1;打破; } return（rc）; }</pre></div>
                        <!-- class="section" -->
                     </div>
                  </div><a id="CACJJDAC"></a><div class="props_rev_3"><a id="GUID-EA21F55B-FF07-49B2-B9BB-16E913AE9DDB" name="GUID-EA21F55B-FF07-49B2-B9BB-16E913AE9DDB"></a><h5 id="ADDCI-GUID-EA21F55B-FF07-49B2-B9BB-16E913AE9DDB" class="sect5"><span class="enumeration_section">16.4.6.2</span>实施ODCIIndexInsert（）在C PSBTREE</h5>
                     <div>
                        <div class="section">
                           <p>插入例程<a href="extensible-indexing-interface.html#GUID-EF42025B-6DE2-4F2A-90EF-62775EE0EED6">ODCIIndexInsert（）</a>解析并执行一个将新行插入索引表的语句。新行包含索引列的新值和作为参数传入的<code class="codeph">rowid</code> 。
                           </p><pre class="oac_no_warn" dir="ltr">OCINumber * qxiqtbspi（OCIExtProcContext * ctx，ODCIIndexInfo * ix，ODCIIndexInfo_ind * ix_ind，char * rid，short rid_ind，char * newval，short newval_ind，ODCIEnv * env，ODCIEnv_ind * env_ind）{OCIEnv * envhp =（OCIEnv *）0; / * env。 handle * / OCISvcCtx * svchp =（OCISvcCtx *）0; / * service handle * / OCIError * errhp =（OCIError *）0; / *错误句柄* / OCIStmt * stmthp =（OCIStmt *）0; / *语句句柄* / OCIBind * bndp =（OCIBind *）0; / * bind handle * / int retval =（int）ODCI_SUCCESS; / *从此函数返回* / OCINumber * rval =（OCINumber *）0; char insstmt [2000]; / * sql insert statement * / ODCIColInfo * colinfo; / * column info * / ODCIColInfo_ind * colinfo_ind; boolean exists = TRUE; unsigned int partiden; / * table partition iden * / unsigned int idxflag; / * index info flag / *首先为OCINumber分配内存* / rval =（OCINumber *）OCIExtProcAllocCallMemory（ctx，sizeof（OCINumber））; / *获取oci句柄* / if（qxiqtce（ctx，errhp，OCIExtProcGetEnv（ctx，＆envhp，＆svchp，＆errhp）））return（rval）; / *设置返回码* / if（qxiqtce（ctx，errhp，OCINumberFromInt（errhp，（dvoid *）＆retval，sizeof（retval），OCI_NUMBER_SIGNED，rval）））return（rval）; / *将idxflag从OCINumber转换为整数* / if（qxiqtce（ctx，errhp，OCINumberToInt（errhp，＆（ix-&gt; IndexInfoFlags），sizeof（idxflag），OCI_NUMBER_UNSIGNED，（void *）＆idxflag）））return（rval）; / ***************************** *构建插入声明* *************** *************** / if（（idxflag＆ODCI_INDEX_RANGE_PARTN）！= ODCI_INDEX_RANGE_PARTN）（void）sprintf（insstmt，“INSERT into％s。％s_sbtree values（：newval，：mrid）”，OCIStringPtr（envhp，ix-&gt; IndexSchema），OCIStringPtr（envhp，ix-&gt; IndexName））; else {if（qxiqtce（ctx，errhp，OCICollGetElem（envhp，errhp，（OCIColl *）ix-&gt; IndexCols，（sb4）0，＆exists，（void **）＆colinfo，（void **）＆colinfo_ind）））return（ RVAL）; （void）sprintf（insstmt，“INSERT into％s。％s_sbtree partition（DATAOBJ_TO_PARTITION（％s，：partiden））VALUES（：newval，：mrid）”，OCIStringPtr（envhp，ix-&gt; IndexSchema），OCIStringPtr（envhp， ix-&gt; IndexName），OCIStringPtr（envhp，colinfo-&gt; TableName））; } / *************************************** *解析并执行创建声明* ** ************************************** / / *分配stmt句柄* / if（qxiqtce（ ctx，errhp，OCIHandleAlloc（（dvoid *）envhp，（dvoid **）＆stmthp，（ub4）OCI_HTYPE_STMT，（size_t）0，（dvoid **）0）））return（rval）; / *准备语句* / if（qxiqtce（ctx，errhp，OCIStmtPrepare（stmthp，errhp，（text *）insstmt，（ub4）strlen（insstmt），OCI_NTV_SYNTAX，OCI_DEFAULT）））return（rval）; if（（idxflag＆ODCI_INDEX_RANGE_PARTN）== ODCI_INDEX_RANGE_PARTN）{/ *将partiden转换为OCINumber的整数* / if（qxiqtce（ctx，errhp，OCINumberToInt（errhp，＆（colinfo-&gt; TablePartitionIden），sizeof（partiden），OCI_NUMBER_UNSIGNED，（ void *）＆partiden）））return（rval）; / *为partiden设置绑定* / if（qxiqtce（ctx，errhp，OCIBindByName（stmthp，＆bndp，errhp，text *）“：partiden”，sizeof（“：partiden”） -  1，（dvoid *）＆partiden，（ sb4）（sizeof（partiden）），（ub2）SQLT_INT，（dvoid *）0，（ub2 *）0，（ub2 *）0，（ub4）0，（ub4 *）0，（ub4）OCI_DEFAULT）））返回（rval中）; } / *为newval设置绑定* / if（qxiqtce（ctx，errhp，OCIBindByName（stmthp，＆bndp，errhp，（text *）“：newval”，sizeof（“：newval”） -  1，（dvoid *）newval ，（sb4）（strlen（newval）+1），（ub2）SQLT_STR，（dvoid *）0，（ub2 *）0，（ub2 *）0，（ub4）0，（ub4 *）0，（ub4） OCI_DEFAULT）））return（rval）; / *为rid * / if设置绑定（qxiqtce（ctx，errhp，OCIBindByName（stmthp，＆bndp，errhp，（text *）“：mrid”，sizeof（“：mrid”） -  1，（dvoid *）rid， （sb4）（strlen（rid）+1），（ub2）SQLT_STR，（dvoid *）0，（ub2 *）0，（ub2 *）0，（ub4）0，（ub4 *）0，（ub4）OCI_DEFAULT ）））return（rval）; / *执行语句* / if（qxiqtce（ctx，errhp，OCIStmtExecute（svchp，stmthp，errhp，（ub4）1，（ub4）0，（OCISnapshot *）NULL，（OCISnapshot *）NULL，（ub4）OCI_DEFAULT）） ）return（rval）; / * free stmt handle * / if（qxiqtce（ctx，errhp，OCIHandleFree（（dvoid *）stmthp，（ub4）OCI_HTYPE_STMT）））return（rval）;返回（rval中）; }</pre></div>
                        <!-- class="section" -->
                     </div>
                  </div><a id="CACFICAJ"></a><div class="props_rev_3"><a id="GUID-501B8354-FB1F-4D7C-A8F4-3C6181F56A19" name="GUID-501B8354-FB1F-4D7C-A8F4-3C6181F56A19"></a><h5 id="ADDCI-GUID-501B8354-FB1F-4D7C-A8F4-3C6181F56A19" class="sect5"><span class="enumeration_section">16.4.6.3</span>实施ODCIIndexDelete（）在C PSBTREE</h5>
                     <div>
                        <div class="section">
                           <p>delete例程构造一个SQL语句，用于从索引表中删除与从基表中删除的行相对应的行。索引表中的行由<code class="codeph">rowid</code>的值标识，该值作为参数传递给此例程。
                           </p><pre class="oac_no_warn" dir="ltr">OCINumber * qxiqtbspd（OCIExtProcContext * ctx，ODCIIndexInfo * ix，ODCIIndexInfo_ind * ix_ind，char * rid，short rid_ind，char * oldval，short oldval_ind，ODCIEnv * env，ODCIEnv_ind * env_ind）{OCIEnv * envhp =（OCIEnv *）0; / * env。 handle * / OCISvcCtx * svchp =（OCISvcCtx *）0; / * service handle * / OCIError * errhp =（OCIError *）0; / *错误句柄* / OCIStmt * stmthp =（OCIStmt *）0; / *语句句柄* / OCIBind * bndp =（OCIBind *）0; / * bind handle * / int retval =（int）ODCI_SUCCESS; / *从此函数返回* / OCINumber * rval =（OCINumber *）0; char delstmt [2000]; / * sql delete statement * / ODCIColInfo * colinfo; / * column info * / ODCIColInfo_ind * colinfo_ind; boolean exists = TRUE; unsigned int partiden; / * table partition iden * / unsigned int idxflag; / * index info flag / *获取oci句柄* / if（qxiqtce（ctx，errhp，OCIExtProcGetEnv（ctx，＆envhp，＆svchp，＆errhp）））return（rval）; / *设置返回码* / rval =（OCINumber *）OCIExtProcAllocCallMemory（ctx，sizeof（OCINumber））; if（qxiqtce（ctx，errhp，OCINumberFromInt（errhp，（dvoid *）＆retval，sizeof（retval），OCI_NUMBER_SIGNED，rval）））return（rval）; / *将idxflag从OCINumber转换为整数* / if（qxiqtce（ctx，errhp，OCINumberToInt（errhp，＆（ix-&gt; IndexInfoFlags），sizeof（idxflag），OCI_NUMBER_UNSIGNED，（void *）＆idxflag）））return（rval）; / ***************************** *构建删除声明* *************** *************** / if（（idxflag＆ODCI_INDEX_RANGE_PARTN）！= ODCI_INDEX_RANGE_PARTN）（void）sprintf（delstmt，“DELETE FROM％s。％s_sbtree WHERE f2 =：rr”，OCIStringPtr（envhp，ix-&gt; IndexSchema），OCIStringPtr（envhp，ix-&gt; IndexName））; else {if（qxiqtce（ctx，errhp，OCICollGetElem（envhp，errhp，（OCIColl *）ix-&gt; IndexCols，（sb4）0，＆exists，（void **）＆colinfo，（void **）＆colinfo_ind）））return（ RVAL）; （void）sprintf（delstmt，“DELETE FROM％s。％s_sbtree partition（DATAOBJ_TO_PARTITION（％s，：partiden））WHERE f2 =：rr”，OCIStringPtr（envhp，ix-&gt; IndexSchema），OCIStringPtr（envhp，ix-&gt; IndexName），OCIStringPtr（envhp，colinfo-&gt; TableName））; } / *************************************** *解析并执行删除声明* ** ************************************** / / *分配stmt句柄* / if（qxiqtce（ ctx，errhp，OCIHandleAlloc（（dvoid *）envhp，（dvoid **）＆stmthp，（ub4）OCI_HTYPE_STMT，（size_t）0，（dvoid **）0）））return（rval）; / *准备语句* / if（qxiqtce（ctx，errhp，OCIStmtPrepare（stmthp，errhp，（text *）delstmt，（ub4）strlen（delstmt），OCI_NTV_SYNTAX，OCI_DEFAULT）））return（rval）; if（（idxflag＆ODCI_INDEX_RANGE_PARTN）== ODCI_INDEX_RANGE_PARTN）{/ *将partiden转换为OCINumber的整数* / if（qxiqtce（ctx，errhp，OCINumberToInt（errhp，＆（colinfo-&gt; TablePartitionIden），sizeof（partiden），OCI_NUMBER_UNSIGNED，（ void *）＆partiden）））return（rval）; / *为partiden设置绑定* / if（qxiqtce（ctx，errhp，OCIBindByName（stmthp，＆bndp，errhp，（text *）“：partiden”，sizeof（“：partiden”） -  1，（dvoid *）＆partiden， sb4）（sizeof（partiden）），（ub2）SQLT_INT，（dvoid *）0，（ub2 *）0，（ub2 *）0，（ub4）0，（ub4 *）0，（ub4）OCI_DEFAULT）））返回（rval中）;设置绑定为rid * / if（qxiqtce（ctx，errhp，OCIBindByName（stmthp，＆bndp，errhp，（text *）“：rr”，sizeof（“：rr”） -  1，（dvoid *）rid ，（sb4）（strlen（rid）+1），（ub2）SQLT_STR，（dvoid *）0，（ub2 *）0，（ub2 *）0，（ub4）0，（ub4 *）0，（ub4） OCI_DEFAULT）））return（rval）; / *执行语句* / if（qxiqtce（ctx，errhp，OCIStmtExecute（svchp，stmthp，errhp，（ub4）1，（ub4）0，（OCISnapshot *）NULL，（OCISnapshot *）NULL，（ub4）OCI_DEFAULT）） ）return（rval）; / * free stmt handle * / if（qxiqtce（ctx，errhp，OCIHandleFree（（dvoid *）stmthp，（ub4）OCI_HTYPE_STMT）））return（rval）;返回（rval中）; }</pre></div>
                        <!-- class="section" -->
                     </div>
                  </div>
                  <div class="props_rev_3"><a id="GUID-6974D2BC-6737-4E9E-A4FF-188142F339E9" name="GUID-6974D2BC-6737-4E9E-A4FF-188142F339E9"></a><h5 id="ADDCI-GUID-6974D2BC-6737-4E9E-A4FF-188142F339E9" class="sect5"><span class="enumeration_section">16.4.6.4</span>实施ODCIIndexUpdate（）为PSBTree用C</h5>
                     <div>
                        <div class="section">
                           <p>update例程构造一个SQL语句来更新索引表中与基表中正在更新的行相对应的行。索引表中的行由<code class="codeph">rowid</code>的值标识，该值作为参数传递给此例程。旧列值（ <code class="codeph">oldval</code> ）将替换为新值（ <code class="codeph">newval</code> ）。
                           </p><pre class="oac_no_warn" dir="ltr">OCINumber * qxiqtbspu（OCIExtProcContext * ctx，ODCIIndexInfo * ix，ODCIIndexInfo_ind * ix_ind，char * rid，short rid_ind，char * oldval，short oldval_ind，char * newval，short newval_ind，ODCIEnv * env，ODCIEnv_ind * env_ind）{OCIEnv * envhp = （OCIEnv *）0; / * env。 handle * / OCISvcCtx * svchp =（OCISvcCtx *）0; / * service handle * / OCIError * errhp =（OCIError *）0; / *错误句柄* / OCIStmt * stmthp =（OCIStmt *）0; / *语句句柄* / OCIBind * bndp =（OCIBind *）0; / * bind handle * / int retval =（int）ODCI_SUCCESS; / *从此函数返回* / OCINumber * rval =（OCINumber *）0; char updstmt [2000]; / * sql upate statement * / ODCIColInfo * colinfo; / * column info * / ODCIColInfo_ind * colinfo_ind; boolean exists = TRUE; unsigned int partiden; / * table partition iden * / unsigned int idxflag; / * index info flag / *获取oci句柄* / if（qxiqtce（ctx，errhp，OCIExtProcGetEnv（ctx，＆envhp，＆svchp，＆errhp）））return（rval）; / *设置返回码* / rval =（OCINumber *）OCIExtProcAllocCallMemory（ctx，sizeof（OCINumber））; if（qxiqtce（ctx，errhp，OCINumberFromInt（errhp，（dvoid *）＆retval，sizeof（retval），OCI_NUMBER_SIGNED，rval）））return（rval）; / *将idxflag从OCINumber转换为整数* / if（qxiqtce（ctx，errhp，OCINumberToInt（errhp，＆（ix-&gt; IndexInfoFlags），sizeof（idxflag），OCI_NUMBER_UNSIGNED，（void *）＆idxflag）））return（rval）; / ***************************** *构建更新声明* *************** *************** / if（（idxflag＆ODCI_INDEX_RANGE_PARTN）！= ODCI_INDEX_RANGE_PARTN）（void）sprintf（updstmt，“UPDATE％s。％s_sbtree SET f1 =：newval WHERE f2 =：rr”，OCIStringPtr（envhp，ix-&gt; IndexSchema），OCIStringPtr（envhp，ix-&gt; IndexName））; else {if（qxiqtce（ctx，errhp，OCICollGetElem（envhp，errhp，OCIColl *）ix-&gt; IndexCols，（sb4）0，＆exists，（void **）＆colinfo，（void **）＆colinfo_ind）））return（rval ）; （void）sprintf（updstmt，“UPDATE％s。％s_sbtree partition（DATAOBJ_TO_PARTITION（％s，：partiden））SET f1 =：newval WHERE f2 =：rr”，OCIStringPtr（envhp，ix-&gt; IndexSchema），OCIStringPtr（envhp ，ix-&gt; IndexName），OCIStringPtr（envhp，colinfo-&gt; TableName））; } / **************************************** *解析并执行创建声明* * *************************************** //分配stmt句柄* / if（qxiqtce （ctx，errhp，OCIHandleAlloc（（dvoid *）envhp，（dvoid **）＆stmthp，（ub4）OCI_HTYPE_STMT，（size_t）0，（dvoid **）0）））return（rval）; / *准备语句* / if（qxiqtce（ctx，errhp，OCIStmtPrepare（stmthp，errhp，（text *）updstmt，（ub4）strlen（updstmt），OCI_NTV_SYNTAX，OCI_DEFAULT）））return（rval）; if（（idxflag＆ODCI_INDEX_RANGE_PARTN）== ODCI_INDEX_RANGE_PARTN）{/ *将partiden转换为OCINumber的整数* / if（qxiqtce（ctx，errhp，OCINumberToInt（errhp，＆（colinfo-&gt; TablePartitionIden），sizeof（partiden），OCI_NUMBER_UNSIGNED，（ void *）＆partiden）））return（rval）; / *为partiden设置绑定* / if（qxiqtce（ctx，errhp，OCIBindByName（stmthp，＆bndp，errhp，（text *）“：partiden”，sizeof（“：partiden”） -  1，（dvoid *）＆partiden， （sb4）（sizeof（partiden）），（ub2）SQLT_INT，（dvoid *）0，（ub2 *）0，（ub2 *）0，（ub4）0，（ub4 *）0，（ub4）OCI_DEFAULT）） ）return（rval）; } / *为newval设置绑定* / if（qxiqtce（ctx，errhp，OCIBindByName（stmthp，＆bndp，errhp，（text *）“：newval”，sizeof（“：newval”） -  1，（dvoid *）newval ，（sb4）（strlen（newval）+1），（ub2）SQLT_STR，（dvoid *）0，（ub2 *）0，（ub2 *）0，（ub4）0，（ub4 *）0，（ub4） OCI_DEFAULT）））return（rval）; / *为rid * / if设置绑定（qxiqtce（ctx，errhp，OCIBindByName（stmthp，＆bndp，errhp，（text *）“：rr”，sizeof（“：rr”） -  1，（dvoid *）rid， （sb4）（strlen（rid）+1），（ub2）SQLT_STR，（dvoid *）0，（ub2 *）0，（ub2 *）0，（ub4）0，（ub4 *）0，（ub4）OCI_DEFAULT ）））return（rval）; / *执行语句* / if（qxiqtce（ctx，errhp，OCIStmtExecute（svchp，stmthp，errhp，（ub4）1，ub4）0，（OCISnapshot *）NULL，（OCISnapshot *）NULL，（ub4）OCI_DEFAULT）））返回（rval中）; / * free stmt handle * / if（qxiqtce（ctx，errhp，OCIHandleFree（（dvoid *）stmthp，（ub4）OCI_HTYPE_STMT）））return（rval）;返回（rval中）; }</pre></div>
                        <!-- class="section" -->
                     </div>
                  </div>
                  <div class="props_rev_3"><a id="GUID-7B9542BB-89EA-4069-8D0F-0E55B3187F83" name="GUID-7B9542BB-89EA-4069-8D0F-0E55B3187F83"></a><h5 id="ADDCI-GUID-7B9542BB-89EA-4069-8D0F-0E55B3187F83" class="sect5"><span class="enumeration_section">16.4.6.5</span>实施ODCIIndexStart（）在C PSBTREE</h5>
                     <div>
                        <div class="section">
                           <p>启动例程执行<code class="codeph">psbtree</code>索引扫描的设置。根据运算符谓词，其参数和返回值的边界的查询信息作为参数传递给此函数。索引扫描例程之间共享的扫描上下文是<code class="codeph">psbtree_im</code>类型的实例。
                           </p>
                           <p>此函数设置扫描索引表的游标。扫描检索索引表中满足指定谓词的行的存储rowid。索引表的谓词是基于作为参数传入的运算符谓词信息生成的。例如，如果运算符谓词的形式为<code class="codeph">eq(col, 'joe') = 1</code> ，则索引表上的谓词设置为<code class="codeph">f1 = 'joe'</code> 。
                           </p>
                           <p>该函数使用<code class="codeph">struct</code> s <code class="codeph">qxiqtim</code> ， <code class="codeph">qxiqtin</code>和<code class="codeph">qxiqtcx</code> ，它们在<a href="example-for-PSBTREE-extensible-indexing.html#GUID-23A0F15E-6AAC-49EB-9DF1-82F732C657CE__CACBHEBF">例16-6</a>和<a href="example-for-PSBTREE-extensible-indexing.html#GUID-23A0F15E-6AAC-49EB-9DF1-82F732C657CE__CACCIGGI">例16-7中</a>进行了演示。
                           </p><pre class="oac_no_warn" dir="ltr">OCINumber * qxiqtbsps（OCIExtProcContext * ctx，qxiqtim * sctx，qxiqtin * sctx_ind，ODCIIndexInfo * ix，ODCIIndexInfo_ind * ix_ind，ODCIPredInfo * pr，ODCIPredInfo_ind * pr_ind，ODCIQueryInfo * qy，ODCIQueryInfo_ind * qy_ind，OCINumber * strt，short strt_ind，OCINumber * stop ，short stop_ind，char * cmpval，short cmpval_ind，ODCIEnv * env，ODCIEnv_ind * env_ind）{sword status; OCIEnv * envhp =（OCIEnv *）0; / * env。 handle * / OCISvcCtx * svchp =（OCISvcCtx *）0; / * service handle * / OCIError * errhp =（OCIError *）0; / *错误句柄* / OCISession * usrhp =（OCISession *）0; / * user handle * / qxiqtcx * icx =（qxiqtcx *）0; / *要保存以供以后调用的状态* / int strtval; / * start bound * / int stopval; / * stop bound * / int errnum = 29400; / *选择一些oracle错误号* / char errmsg [512]; / *错误消息缓冲区* / size_t errmsglen; / *错误消息的长度* / char relop [3]; / *在sql stmt * / char selstmt中使用的关系运算符[2000]; / * sql select statement * / int retval =（int）ODCI_SUCCESS; / *从此函数返回* / OCINumber * rval =（OCINumber *）0; ub4键; / *键值设置在“sctx”* / ub1 * rkey; / *键检索上下文* / ub4 rkeylen; / *密钥长度* / ODCIColInfo * colinfo; / * column info * / ODCIColInfo_ind * colinfo_ind; boolean exists = TRUE; unsigned int partiden; / * table partition iden * / unsigned int idxflag; / * index info flag / *获取oci句柄* / if（qxiqtce（ctx，errhp，OCIExtProcGetEnv（ctx，＆envhp，＆svchp，＆errhp）））return（rval）; / *设置返回码* / rval =（OCINumber *）OCIExtProcAllocCallMemory（ctx，sizeof（OCINumber））; if（qxiqtce（ctx，errhp，OCINumberFromInt（errhp，（dvoid *）＆retval，sizeof（retval），OCI_NUMBER_SIGNED，rval）））return（rval）; / *获取用户句柄* / if（qxiqtce（ctx，errhp，OCIAttrGet（（dvoid *）svchp，（ub4）OCI_HTYPE_SVCCTX，（dvoid *）＆usrhp，（ub4 *）0，（ub4）OCI_ATTR_SESSION，errhp）））返回（rval中）; / ********************************************** / / *分配内存以保存索引扫描上下文* / / **************************************** ****** / if（sctx_ind  - &gt; atomic_qxiqtin == OCI_IND_NULL || sctx_ind  - &gt; scind_qxiqtin == OCI_IND_NULL）{if（qxiqtce（ctx，errhp，OCIMemoryAlloc（（dvoid *）usrhp，errhp，（dvoid **） ＆icx，OCI_DURATION_STATEMENT，（ub4）（sizeof（qxiqtcx）），OCI_MEMORY_CLEARED）））return（rval）; icx-&gt; stmthp =（OCIStmt *）0; icx-&gt; defnp =（OCIDefine *）0; icx-&gt; bndp =（OCIBind *）0; } else {/ ************************* // *检索扫描上下文* / / ************ ************* / rkey = OCIRawPtr（envhp，sctx-&gt; sctx_qxiqtim）; rkeylen = OCIRawSize（envhp，sctx-&gt; sctx_qxiqtim）; if（qxiqtce（ctx，errhp，OCIContextGetValue（（dvoid *）usrhp，errhp，rkey，（ub1）rkeylen，（dvoid **）＆（icx））））return（rval）; } / *********************************** //检查边界是否有效* / / * ********************************** / / *从oci号码转换为原始号码* / if（qxiqtce（ ctx，errhp，OCINumberToInt（errhp，strt，sizeof（strtval），OCI_NUMBER_SIGNED，（dvoid *）＆strtval）））return（rval）; if（qxiqtce（ctx，errhp，OCINumberToInt（errhp，stop，sizeof（stopval），OCI_NUMBER_SIGNED，（dvoid *）＆stopval）））return（rval）; / *验证strtval / stopval都是0或1 * / if（！（（（strtval == 0）&amp;&amp;（stopval == 0））|| （（strtval == 1）&amp;&amp;（stopval == 1））））{strcpy（errmsg，（char *）“sbtree operator的不正确谓词”）; errmsglen =（size_t）strlen（errmsg）; if（OCIExtProcRaiseExcpWithMsg（ctx，errnum，（text *）errmsg，errmsglen）！= OCIEXTPROC_SUCCESS）/ *此处使用墨盒错误服务* /;返回（rval中）; } / ********************************************* / / *生成要执行的SQL语句* / / **************************************** ***** / if（memcmp（（dvoid *）OCIStringPtr（envhp，pr-&gt; ObjectName），（dvoid *）“EQ”，2）== 0）if（strtval == 1）strcpy（relop，（ char *）“=”）; else strcpy（relop，（char *）“！=“）;否则if（memcmp（（dvoid *）OCIStringPtr（envhp，pr-&gt; ObjectName），（dvoid *）”LT“，2）== 0）if（strtval == 1）strcpy（relop，（char） *）“&lt;”）;否则strcpy（relop，（char *）“&gt; =”）;否则if（strtval == 1）strcpy（relop，（char *）“&gt;”）;否则strcpy（relop，（char） *）“&lt;=”）; / *将idxflag从OCINumber转换为整数* / if（qxiqtce（ctx，errhp，OCINumberToInt（errhp，＆（ix-&gt; IndexInfoFlags），sizeof（idxflag），OCI_NUMBER_UNSIGNED，（void *）＆idxflag ）））return（rval）; if（（idxflag＆ODCI_INDEX_RANGE_PARTN）！= ODCI_INDEX_RANGE_PARTN）（void）sprintf（selstmt，“从％s选择f2。％s_sbtree，其中f1％s：val”，OCIStringPtr（envhp，ix-&gt; IndexSchema），OCIStringPtr（envhp，ix-&gt; IndexName），relop）; else {if（qxiqtce（ctx，errhp，OCICollGetElem（envhp，errhp，OCIColl *）ix-&gt; IndexCols，（sb4）0，＆exists，（void **）＆colinfo，（void **）＆colinfo_ind）））return（rval ）; / *将partiden转换为OCINumber的整数* / if（qxiqtce（ctx，errhp，OCINumberToInt（errhp，＆（colinfo-&gt; TablePartitionIden），sizeof（partiden），OCI_NUMBER_UNSIGNED，（void *）＆partiden）））return（rval）; （void）sprintf（selstmt，“从％s。％s_sbtree分区选择f2（DATAOBJ_TO_PARTITION（％s，％d））其中f1％s：val”，OCIStringPtr（envhp，ix-&gt; IndexSchema），OCIStringPtr（envhp，ix - &gt; IndexName），OCIStringPtr（envhp，colinfo-&gt; TableName），partiden，relop）; } / *********************************** / / *解析，绑定，定义和执行* / / *********************************** / if（sctx_ind  - &gt; atomic_qxiqtin == OCI_IND_NULL || sctx_ind  - &gt; scind_qxiqtin == OCI_IND_NULL）{/ *分配stmt句柄* / if（qxiqtce（ctx，errhp，OCIHandleAlloc（（dvoid *）envhp，（dvoid **）＆（icx-&gt; stmthp），（ub4）OCI_HTYPE_STMT，（size_t） 0，（dvoid **）0）））return（rval）; } / *准备语句* / if（qxiqtce（ctx，errhp，OCIStmtPrepare（icx-&gt; stmthp，errhp，（text *）selstmt，（ub4）strlen（selstmt），OCI_NTV_SYNTAX，OCI_DEFAULT）））return（rval）; / *设置绑定比较值* / if（qxiqtce（ctx，errhp，OCIBindByName（icx-&gt; stmthp，＆（icx-&gt; bndp），errhp，（text *）“：val”，sizeof（“：val”） ）-1，（dvoid *）cmpval，（sb4）（strlen（cmpval）+1），（ub2）SQLT_STR，（dvoid *）0，（ub2 *）0，（ub2 *）0，（ub4）0， （ub4 *）0，（ub4）OCI_DEFAULT）））return（rval）; / *设置定义* / if（qxiqtce（ctx，errhp，OCIDefineByPos（icx-&gt; stmthp，＆（icx-&gt; defnp），errhp，（ub4）1，（dvoid *）（icx-&gt; ridp），（sb4 ）sizeof（icx-&gt; ridp），（ub2）SQLT_STR，（dvoid *）0，（ub2 *）0，（ub2 *）0，（ub4）OCI_DEFAULT）））return（rval）; / * execute * / if（qxiqtce（ctx，errhp，OCIStmtExecute（svchp，icx-&gt; stmthp，errhp，（ub4）0，（ub4）0，（OCISnapshot *）NULL，（OCISnapshot *）NULL，（ub4）OCI_DEFAULT ）））return（rval）; / ************************************ / / *设置要返回的索引上下文* / / * *********************************** / if（sctx_ind  - &gt; atomic_qxiqtin == OCI_IND_NULL || sctx_ind  - &gt; scind_qxiqtin == OCI_IND_NULL）{/ *生成一个键* / if（qxiqtce（ctx，errhp，OCIContextGenerateKey（（dvoid *）usrhp，errhp，＆key）））return（rval）; / *设置要保存在上下文中的结构的内存地址* / if（qxiqtce（ctx，errhp，OCIContextSetValue（（dvoid *）usrhp，errhp，OCI_DURATION_STATEMENT，（ub1 *）＆key，（ub1）sizeof（key） ，（dvoid *）icx）））return（rval）; / *语句持续时间内存分配键* / if（qxiqtce（ctx，errhp，OCIMemoryAlloc（（void *）usrhp，errhp，（void **）＆（sctx-&gt; sctx_qxiqtim），OCI_DURATION_STATEMENT，（sb4）（sizeof（key） ）+ sizeof（ub4）），OCI_MEMORY_CLEARED）））return（rval）; / *将键设置为“sctx”的成员* / if（qxiqtce（ctx，errhp，OCIRawAssignBytes（envhp，errhp，（ub1 *）＆key，ub4）sizeof（key），＆（sctx-&gt; sctx_qxiqtim））） ）return（rval）; sctx_ind-&gt; atomic_qxiqtin = OCI_IND_NOTNULL; sctx_ind-&gt; scind_qxiqtin = OCI_IND_NOTNULL;返回（rval中）; } return（rval）; }</pre></div>
                        <!-- class="section" -->
                     </div>
                  </div><a id="CACGCEBA"></a><div class="props_rev_3"><a id="GUID-9034448B-7A7C-4A11-A904-6E8954792162" name="GUID-9034448B-7A7C-4A11-A904-6E8954792162"></a><h5 id="ADDCI-GUID-9034448B-7A7C-4A11-A904-6E8954792162" class="sect5"><span class="enumeration_section">16.4.6.6</span>实施ODCIIndexFetch（）在C PSBTREE</h5>
                     <div>
                        <div class="section">
                           <p>由start程序设置的扫描上下文作为参数传递给fetch例程。此函数首先从扫描上下文中检索4字节密钥。扫描上下文的C映射是<code class="codeph">qxiqtim</code> （参见<a href="example-for-PSBTREE-extensible-indexing.html#GUID-23A0F15E-6AAC-49EB-9DF1-82F732C657CE__CACBHEBF">例16-6</a> ）。接下来，key用于查找OCI上下文。这给出了保存OCI句柄的<code class="codeph">qxiqtcx</code>结构的内存地址（参见<a href="example-for-PSBTREE-extensible-indexing.html#GUID-23A0F15E-6AAC-49EB-9DF1-82F732C657CE__CACCIGGI">例16-7</a> ）。
                           </p>
                           <p>此函数返回满足运算符谓词的下一批rowid。它使用<code class="codeph">nrows</code>参数的值作为批处理的大小。它从打开的游标重复获取rowid并填充<code class="codeph">rowid</code>列表。当批处理已满或没有剩余rowid时，该函数会将它们返回给Oracle服务器。
                           </p><pre class="oac_no_warn" dir="ltr">OCINumber * qxiqtbspf（OCIExtProcContext * ctx，qxiqtim * self，qxiqtin * self_ind，OCINumber * nrows，short nrows_ind，OCIArray ** rids，short * rids_ind，ODCIEnv * env，ODCIEnv_ind * env_ind）{sword status; OCIEnv * envhp =（OCIEnv *）0; / * env。 handle * / OCISvcCtx * svchp =（OCISvcCtx *）0; / * service handle * / OCIError * errhp =（OCIError *）0; / *错误句柄* / OCISession * usrhp =（OCISession *）0; / * user handle * / qxiqtcx * icx =（qxiqtcx *）0; / *状态保存以供以后调用* / int idx = 1; int nrowsval; OCIArray * ridarrp = * rids; / * rowid collection * / OCIString * ridstr =（OCIString *）0; int done = 0; int retval =（int）ODCI_SUCCESS; OCINumber * rval =（OCINumber *）0; ub1 *键; / *键检索上下文* / ub4 keylen; / *密钥长度* / / ******************* // *获取OCI句柄* / / ************** ***** / if（qxiqtce（ctx，errhp，OCIExtProcGetEnv（ctx，＆envhp，＆svchp，＆errhp）））return（rval）; / *设置返回码* / rval =（OCINumber *）OCIExtProcAllocCallMemory（ctx，sizeof（OCINumber））; if（qxiqtce（ctx，errhp，OCINumberFromInt（errhp，（dvoid *）＆retval，sizeof（retval），OCI_NUMBER_SIGNED，rval）））return（rval）; / *获取用户句柄* / if（qxiqtce（ctx，errhp，OCIAttrGet（（dvoid *）svchp，（ub4）OCI_HTYPE_SVCCTX，（dvoid *）＆usrhp，（ub4 *）0，（ub4）OCI_ATTR_SESSION，errhp）））返回（rval中）; / ******************************** / / *从密钥中检索上下文* / / ******* ************************* / key = OCIRawPtr（envhp，self-&gt; sctx_qxiqtim）; keylen = OCIRawSize（envhp，self-&gt; sctx_qxiqtim）; if（qxiqtce（ctx，errhp，OCIContextGetValue（（dvoid *）usrhp，errhp，key，（ub1）keylen，（dvoid **）＆（icx））））return（rval）; / *得到nrows * / if的值（qxiqtce（ctx，errhp，OCINumberToInt（errhp，nrows，sizeof（nrowsval），OCI_NUMBER_SIGNED，（dvoid *）＆nrowsval）））return（rval）; / **************** / / *获取rowid * / / **************** / while（！完成）{if（idx&gt; nrowsval）done = 1; else {status = OCIStmtFetch（icx-&gt; stmthp，errhp，（ub4）1，（ub2）0，（ub4）OCI_DEFAULT）; if（status == OCI_NO_DATA）{short col_ind = OCI_IND_NULL; / *必须创建虚拟oci字符串* / OCIStringAssignText（envhp，errhp，（text *）“dummy”，（ub2）5，＆ridstr）; / *将null元素追加到集合* / if（qxiqtce（ctx，errhp，OCICollAppend（envhp，errhp，（dvoid *）ridstr，（dvoid *）＆col_ind，（OCIColl *）ridarrp）））return（rval）; done = 1; } else if（status == OCI_SUCCESS）{OCIStringAssignText（envhp，errhp，（text *）icx-&gt; ridp，（ub2）18，OCIString **）＆ridstr）; / *将rowid附加到集合* / if（qxiqtce（ctx，errhp，OCICollAppend（envhp，errhp，（dvoid *）ridstr，（dvoid *）0，（OCIColl *）ridarrp）））return（rval）; IDX ++; } else if（qxiqtce（ctx，errhp，status））return（rval）; } / * free ridstr finally * / if（ridstr &amp;&amp;（qxiqtce（ctx，errhp，OCIStringResize（envhp，errhp，（ub4）0，＆ridstr））））return（rval）; * rids_ind = OCI_IND_NOTNULL;返回（rval中）; }</pre></div>
                        <!-- class="section" -->
                     </div>
                  </div><a id="CACBFHDA"></a><div class="props_rev_3"><a id="GUID-43F5A575-F265-43F0-A513-6495057E0BC4" name="GUID-43F5A575-F265-43F0-A513-6495057E0BC4"></a><h5 id="ADDCI-GUID-43F5A575-F265-43F0-A513-6495057E0BC4" class="sect5"><span class="enumeration_section">16.4.6.7</span>实施ODCIIndexClose（）在C PSBTREE</h5>
                     <div>
                        <div class="section">
                           <p>由start例程设置的扫描上下文作为参数传递给close例程。此函数首先从扫描上下文中检索4字节密钥。扫描上下文的C映射是<code class="codeph">qxiqtim</code> （参见<a href="example-for-PSBTREE-extensible-indexing.html#GUID-23A0F15E-6AAC-49EB-9DF1-82F732C657CE__CACBHEBF">例16-6</a> ）。接下来，基于密钥查找OCI上下文。这给出了保存OCI句柄的结构的内存地址，即<code class="codeph">qxiqtcx</code>结构（参见<a href="example-for-PSBTREE-extensible-indexing.html#GUID-23A0F15E-6AAC-49EB-9DF1-82F732C657CE__CACCIGGI">例16-7</a> ）。
                           </p>
                           <p>此函数关闭并释放所有OCI句柄。它还释放了在启动例程中分配的内存。</p><pre class="oac_no_warn" dir="ltr">OCINumber * qxiqtbspc（OCIExtProcContext * ctx，qxiqtim * self，qxiqtin * self_ind，ODCIEnv * env，ODCIEnv_ind * env_ind）{sword status; OCIEnv * envhp =（OCIEnv *）0; / * env。 handle * / OCISvcCtx * svchp =（OCISvcCtx *）0; / * service handle * / OCIError * errhp =（OCIError *）0; / *错误句柄* / OCISession * usrhp =（OCISession *）0; / * user handle * / qxiqtcx * icx =（qxiqtcx *）0; / *要保存以供以后调用的状态* / int retval =（int）ODCI_SUCCESS; OCINumber * rval =（OCINumber *）0; ub1 *键; / *键检索上下文* / ub4 keylen; / *密钥长度* / if（qxiqtce（ctx，errhp，OCIExtProcGetEnv（ctx，＆envhp，＆svchp，＆errhp）））return（rval）; / *设置返回码* / rval =（OCINumber *）OCIExtProcAllocCallMemory（ctx，sizeof（OCINumber））; if（qxiqtce（ctx，errhp，OCINumberFromInt（errhp，（dvoid *）＆retval，sizeof（retval），OCI_NUMBER_SIGNED，rval）））return（rval）; / *获取用户句柄* / if（qxiqtce（ctx，errhp，OCIAttrGet（（dvoid *）svchp，（ub4）OCI_HTYPE_SVCCTX，（dvoid *）＆usrhp，（ub4 *）0，（ub4）OCI_ATTR_SESSION，errhp）））返回（rval中）; / ******************************** / / *使用密钥检索上下文* / / ******* ************************* / key = OCIRawPtr（envhp，self-&gt; sctx_qxiqtim）; keylen = OCIRawSize（envhp，self-&gt; sctx_qxiqtim）; if（qxiqtce（ctx，errhp，OCIContextGetValue（（dvoid *）usrhp，errhp，key，（ub1）keylen，（dvoid **）＆（icx））））return（rval）; / *自由句柄和内存* / if（qxiqtce（ctx，errhp，OCIHandleFree（（dvoid *）icx-&gt; stmthp，（ub4）OCI_HTYPE_STMT）））return（rval）; if（qxiqtce（ctx，errhp，OCIMemoryFree（（dvoid *）usrhp，errhp，（dvoid *）icx）））return（rval）; / *释放为索引上下文分配的内存。* / if（qxiqtce（ctx，errhp，OCIContextClearValue（（dvoid *）usrhp，errhp，key，（ub1）keylen）））return（rval）;返回（rval中）; }</pre></div>
                        <!-- class="section" -->
                     </div>
                  </div>
               </div><a id="CACGICCC"></a><div class="props_rev_3"><a id="GUID-A0D7FF1A-BDBB-4675-AC9E-81429BCC2AE2" name="GUID-A0D7FF1A-BDBB-4675-AC9E-81429BCC2AE2"></a><h4 id="ADDCI-GUID-A0D7FF1A-BDBB-4675-AC9E-81429BCC2AE2" class="sect4"><span class="enumeration_section">16.4.7</span>为PSBTREE实现Indextype</h4>
                  <div>
                     <p>您应该创建indextype对象并指定它支持的运算符列表。此外，指定实现ODCIIndexXXX（）接口例程的实现类型的名称。</p><pre class="oac_no_warn" dir="ltr">CREATE INDEXTYPE psbtree FOR eq（VARCHAR2，VARCHAR2），lt（VARCHAR2，VARCHAR2），gt（VARCHAR2，VARCHAR2）使用psbtree_im与系统管理存储表的LOCAL RANGE PARTITION</pre></div>
               </div>
            </div><a id="ADDCI4920"></a><div class="props_rev_3"><a id="GUID-3D9A6C67-5E57-4AA1-A79D-DDE31EB0BD2F" name="GUID-3D9A6C67-5E57-4AA1-A79D-DDE31EB0BD2F"></a><h3 id="ADDCI-GUID-3D9A6C67-5E57-4AA1-A79D-DDE31EB0BD2F" class="sect3"><span class="enumeration_section">16.5</span>使用PSBTREE</h3>
               <div>
                  <p>接下来应该创建indextype对象并指定它支持的运算符列表。此外，指定实现<code class="codeph">ODCIIndex</code> <span class="italic"><code class="codeph">XXX</code></span> <code class="codeph">()</code>接口例程的实现类型的名称。此步骤在<a href="example-for-PSBTREE-extensible-indexing.html#GUID-A0D7FF1A-BDBB-4675-AC9E-81429BCC2AE2">实现PSBTREE的索引类型</a>部分中<a href="example-for-PSBTREE-extensible-indexing.html#GUID-A0D7FF1A-BDBB-4675-AC9E-81429BCC2AE2">进行了演示</a> 。
                  </p>
                  <p>一个典型的使用场景是创建一个范围分区表并填充它，如<a href="example-for-PSBTREE-extensible-indexing.html#GUID-0EEFEAA7-3D43-4EEC-8B20-5CD2A1E52EF2">为PSBTREE创建和</a>填充<a href="example-for-PSBTREE-extensible-indexing.html#GUID-0EEFEAA7-3D43-4EEC-8B20-5CD2A1E52EF2">分区表</a>部分所示。
                  </p>
                  <p>然后，您可以在列<code class="codeph">f2</code>上创建<code class="codeph">psbtree</code>索引。<code class="codeph">CREATE INDEX</code>语句指定应使用的<a href="example-for-PSBTREE-extensible-indexing.html#GUID-32F13F1C-CCB1-4A72-8330-454C3FE2CE4D">索引类型</a> ，如“在<a href="example-for-PSBTREE-extensible-indexing.html#GUID-32F13F1C-CCB1-4A72-8330-454C3FE2CE4D">列上创建PSBTREE索引”</a>部分所示。
                  </p>
                  <p>要执行使用其中一个<code class="codeph">psbtree</code>运算符的查询，请使用“ <a href="example-for-PSBTREE-extensible-indexing.html#GUID-F259EAA0-50E1-497F-BDA4-A409AE2D654C">查询”</a>部分中的“ <a href="example-for-PSBTREE-extensible-indexing.html#GUID-F259EAA0-50E1-497F-BDA4-A409AE2D654C">使用PSBTREE运算符”中</a>的代码。
                  </p>
               </div><a id="CACCEACF"></a><div class="props_rev_3"><a id="GUID-0EEFEAA7-3D43-4EEC-8B20-5CD2A1E52EF2" name="GUID-0EEFEAA7-3D43-4EEC-8B20-5CD2A1E52EF2"></a><h4 id="ADDCI-GUID-0EEFEAA7-3D43-4EEC-8B20-5CD2A1E52EF2" class="sect4"><span class="enumeration_section">16.5.1</span>为PSBTREE创建和填充分区表</h4>
                  <div>
                     <div class="section"><pre class="oac_no_warn" dir="ltr">创建表t1（f1 NUMBER，f2 VARCHAR2（200））按范围分区（f1）（分区p1值小于（101），分区p2值小于（201），分区p3值小于（301），分区p4值少于（401））;插入t1 VALUES（10，'aaaa'）;插入t1 VALUES（200，'bbbb'）;插入t1 VALUES（100，'cccc'）;插入t1 VALUES（300，'dddd'）;插入t1 VALUES（400，'eeee'）;承诺;</pre></div>
                     <!-- class="section" -->
                  </div>
               </div><a id="CACJJHIG"></a><div class="props_rev_3"><a id="GUID-32F13F1C-CCB1-4A72-8330-454C3FE2CE4D" name="GUID-32F13F1C-CCB1-4A72-8330-454C3FE2CE4D"></a><h4 id="ADDCI-GUID-32F13F1C-CCB1-4A72-8330-454C3FE2CE4D" class="sect4"><span class="enumeration_section">16.5.2</span>在列上创建PSBTREE索引</h4>
                  <div>
                     <div class="section"><pre class="oac_no_warn" dir="ltr">创建索引it1 ON t1（f2）iINDEXTYPE是psbtree LOCAL（PARTITION pe1 PARAMETERS（'test1'），PARTITION pe2，PARTITION pe3，PARTITION pe4 PARAMETERS（'test4'））PARAMETERS（'test'）;</pre></div>
                     <!-- class="section" -->
                  </div>
               </div><a id="CACHDCED"></a><div class="props_rev_3"><a id="GUID-F259EAA0-50E1-497F-BDA4-A409AE2D654C" name="GUID-F259EAA0-50E1-497F-BDA4-A409AE2D654C"></a><h4 id="ADDCI-GUID-F259EAA0-50E1-497F-BDA4-A409AE2D654C" class="sect4"><span class="enumeration_section">16.5.3</span>在查询中使用PSBTREE运算符</h4>
                  <div>
                     <div class="section"><pre class="oac_no_warn" dir="ltr">SELECT * FROMM t1 WHERE eq（f2，'dddd'）= 1 AND f1&gt; 101;</pre><p>此查询的解释计划输出应如下所示：</p><pre class="oac_no_warn" dir="ltr">操作选项PARTITION_START PARTITION_STOP ---------------------------------------------- ---------------------------------- SELECT STATEMENT PARTITION RANGE ITERATOR 2 4按当地索引ROWID 2 4域的表访问指数</pre></div>
                     <!-- class="section" -->
                  </div>
               </div>
            </div>
         </div>
      </article>
   </body>
</html>