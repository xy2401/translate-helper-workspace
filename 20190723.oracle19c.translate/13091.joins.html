<html lang="en-us" dir="ltr" xml:lang="en-us">
   <head>
      <meta http-equiv="Content-Type" content="text/html; charset=utf-8"></meta>
      <meta name="viewport" content="width=device-width, initial-scale=1"></meta>
      <meta http-equiv="X-UA-Compatible" content="IE=edge"></meta>
      <meta name="abstract" content="Oracle Database provides several optimizations for joining row sets."></meta>
      <meta name="description" content="Oracle Database provides several optimizations for joining row sets."></meta>
      <title>加盟</title>
      <meta property="og:site_name" content="Oracle Help Center"></meta>
      <meta property="og:title" content="SQL Tuning Guide"></meta>
      <meta property="og:description" content="Oracle Database provides several optimizations for joining row sets."></meta>
      <link rel="stylesheet" href="/sp_common/book-template/ohc-book-template/css/book.css"></link>
      <link rel="shortcut icon" href="/sp_common/book-template/ohc-common/img/favicon.ico"></link>
      <meta name="application-name" content="SQL Tuning Guide"></meta>
      <meta name="generator" content="DITA Open Toolkit version 1.8.5 (Mode = doc)"></meta>
      <meta name="plugin" content="SP_docbuilder HTML plugin release 18.2.2"></meta>
      <link rel="alternate" href="sql-tuning-guide.pdf" title="PDF File" type="application/pdf"></link>
      <meta name="robots" content="all"></meta>
      <link rel="schema.dcterms" href="http://purl.org/dc/terms/"></link>
      <meta name="dcterms.created" content="2019-01-31T14:57:08-08:00"></meta>
      <meta name="dcterms.title" content="SQL Tuning Guide"></meta>
      <meta name="dcterms.dateCopyrighted" content="2013, 2019"></meta>
      <meta name="dcterms.category" content="database"></meta>
      <meta name="dcterms.identifier" content="E96095-03"></meta>
      
      <meta name="dcterms.product" content="en/database/oracle/oracle-database/19"></meta>
      
      <link rel="prev" href="optimizer-access-paths.html" title="Previous" type="text/html"></link>
      <link rel="next" href="optimizer-statistics.html" title="Next" type="text/html"></link>
      <script>
        document.write('<style type="text/css">');
        document.write('body > .noscript, body > .noscript ~ * { visibility: hidden; }');
        document.write('</style>');
     </script>
      <script src="/sp_common/book-template/requirejs/require.js" data-main="/sp_common/book-template/ohc-book-template/js/book-config"></script>
      <script>
            if (window.require === undefined) {
                document.write('<script data-main="sp_common/book-template/ohc-book-template/js/book-config" src="sp_common/book-template/requirejs/require.js"><\/script>');
                document.write('<link href="sp_common/book-template/ohc-book-template/css/book.css" rel="stylesheet"/>');
            }
        </script>
      <script type="application/json" id="ssot-metadata">{"primary":{"category":{"short_name":"database","element_name":"Database","display_in_url":true},"suite":{"short_name":"oracle","element_name":"Oracle","display_in_url":true},"product_group":{"short_name":"not-applicable","element_name":"Not applicable","display_in_url":false},"product":{"short_name":"oracle-database","element_name":"Oracle Database","display_in_url":true},"release":{"short_name":"19","element_name":"Release 19","display_in_url":true}}}</script>
      
    <meta name="dcterms.isVersionOf" content="TGSQL"></meta>
    <meta name="dcterms.release" content="Release 19"></meta>
  </head>
   <body dir="ltr">
      <div class="noscript alert alert-danger text-center" role="alert">
         <a href="optimizer-access-paths.html" class="pull-left"><span class="glyphicon glyphicon-chevron-left" aria-hidden="true"></span>上一页</a> <a href="optimizer-statistics.html" class="pull-right">下一页<span class="glyphicon glyphicon-chevron-right" aria-hidden="true"></span></a> <span class="fa fa-exclamation-triangle" aria-hidden="true"></span>必须启用JavaScript才能正确显示此内容</div>
      <article>
         <header>
            <ol class="breadcrumb" vocab="http://schema.org/" typeof="BreadcrumbList">
               <li property="itemListElement" typeof="ListItem"><a href="index.html" property="item" typeof="WebPage"><span property="name">SQL调优指南</span></a></li>
               <li property="itemListElement" typeof="ListItem"><a href="sql-operators.html" property="item" typeof="WebPage"><span property="name">SQL运算符：访问路径和连接</span></a></li>
               <li class="active" property="itemListElement" typeof="ListItem">加盟</li>
            </ol>
            <a id="GUID-BD96F1B4-76D4-43DF-98B6-D07F46838C4A" name="GUID-BD96F1B4-76D4-43DF-98B6-D07F46838C4A"></a><a id="TGSQL242"></a>
            
            <h2 id="TGSQL-GUID-BD96F1B4-76D4-43DF-98B6-D07F46838C4A" class="sect2"><span class="enumeration_chapter">9</span>加入</h2>
         </header>
         <div class="ind">
            <div>
               <p>Oracle数据库为加入行集提供了多种优化。</p>
               <p>本章包含以下主题：</p>
            </div>
            <div>
               <ul class="ullinks">
                  <li class="ulchildlink"><a href="joins.html#GUID-F47AB553-07F0-42E8-BF55-C31DCD5AAC81">关于加入</a><br><strong class="term">连接</strong>组合恰好两个行源（例如表或视图）的输出，并返回一个行源。返回的行源是数据集。
                  </li>
                  <li class="ulchildlink"><a href="joins.html#GUID-54F957FB-3568-499A-BCD2-B242BFFF913D">加入方法</a><br>连接方法是连接两个行源的机制。
                  </li>
                  <li class="ulchildlink"><a href="joins.html#GUID-8E7760A6-48D6-4794-BF2F-290349C019B9">加入类型</a><br>连接类型由连接条件的类型确定。
                  </li>
                  <li class="ulchildlink"><a href="joins.html#GUID-C02C3673-75E2-4D92-AAEF-30AC58C32AD1">加入优化</a><br>连接优化使连接更有效。
                  </li>
               </ul>
               <div class="familylinks">
                  <div class="parentlink">
                     <p><strong>父主题：</strong> <a href="sql-operators.html#GUID-37BA8AC8-B8F5-402E-8398-552AFDACED8E" title="行源是执行计划中的步骤返回的一组行。SQL运算符作用于行源。">SQL运算符：访问路径和联接</a></p>
                  </div>
               </div>
            </div>
            <a id="TGSQL95231"></a><div class="props_rev_3"><a id="GUID-F47AB553-07F0-42E8-BF55-C31DCD5AAC81" name="GUID-F47AB553-07F0-42E8-BF55-C31DCD5AAC81"></a><h3 id="TGSQL-GUID-F47AB553-07F0-42E8-BF55-C31DCD5AAC81" class="sect3"><span class="enumeration_section">9.1</span>关于加入</h3>
               <div>
                  <p><strong class="term">连接</strong>组合恰好两个行源（例如表或视图）的输出，并返回一个行源。返回的行源是数据集。
                  </p>
                  <p>连接的特征是<code class="codeph">WHERE</code> （非ANSI）或<code class="codeph">FROM ...中的多个表<code class="codeph">FROM ...SQL语句的JOIN</code> （ANSI）子句。每当<code class="codeph">FROM</code>子句中存在多个表时，Oracle数据库就会执行连接。
                  </p>
                  <p><a href="glossary.html#GUID-F2A09892-D404-46BD-82B1-3DB0BC286FE2"><span class="xrefglossterm">连接条件</span></a>使用表达式比较两个行源。连接条件定义表之间的关系。如果语句未指定连接条件，则数据库执行笛卡尔连接，将一个表中的每一行与另一个表中的每一行相匹配。
                  </p>
                  <p>本节包含以下主题：</p>
               </div>
               <div>
                  <ul class="ullinks">
                     <li class="ulchildlink"><a href="joins.html#GUID-31B0F249-A5AA-41E9-AE98-A484FC5C487C">加入树木</a><br>通常，连接树表示为倒置树结构。
                     </li>
                     <li class="ulchildlink"><a href="joins.html#GUID-5435FC78-D572-4CEE-A733-CDB1DB8E544B">优化程序如何执行连接语句</a><br>数据库连接成对的行源。当<code class="codeph">FROM</code>子句中存在多个表时，优化器必须确定哪个连接操作对每个对最有效。
                     </li>
                     <li class="ulchildlink"><a href="joins.html#GUID-8621DCD7-6F70-4720-8049-BA630B58F26C">优化器如何为连接选择执行计划</a><br>确定连接顺序和方法时，优化器的目标是尽早减少行数，以便在整个SQL语句执行期间执行较少的工作。
                     </li>
                  </ul>
                  <div class="infoboxnotealso" id="GUID-F47AB553-07F0-42E8-BF55-C31DCD5AAC81__GUID-C7FD3549-3901-4564-AA97-5D665CFB40B8">
                     <p class="notep1">也可以看看：</p>
                     <ul style="list-style-type:disc">
                        <li>
                           <p><span class="q">“ <a href="joins.html#GUID-07D9388C-6DCB-4F88-BF59-AF223C10B8FC" title="当一个或多个表与语句中的任何其他表没有任何连接条件时，数据库使用笛卡尔连接。">笛卡尔加入</a> ”</span></p>
                        </li>
                        <li>
                           <p><a href="https://www.oracle.com/pls/topic/lookup?ctx=en/database/oracle/oracle-database/19/tgsql&amp;id=SQLRF30046" target="_blank"><span><cite>Oracle数据库SQL语言参考</cite></span></a> ，简要讨论Oracle SQL中的连接</p>
                        </li>
                     </ul>
                  </div>
                  <div class="familylinks">
                     <div class="parentlink">
                        <p><strong>父主题：</strong> <a href="joins.html#GUID-BD96F1B4-76D4-43DF-98B6-D07F46838C4A" title="Oracle数据库为加入行集提供了多种优化。">联接</a></p>
                     </div>
                  </div>
               </div>
               <a id="TGSQL95346"></a><a id="TGSQL95347"></a><a id="TGSQL95348"></a><a id="TGSQL95349"></a><a id="TGSQL95345"></a><div class="props_rev_3"><a id="GUID-31B0F249-A5AA-41E9-AE98-A484FC5C487C" name="GUID-31B0F249-A5AA-41E9-AE98-A484FC5C487C"></a><h4 id="TGSQL-GUID-31B0F249-A5AA-41E9-AE98-A484FC5C487C" class="sect4"><span class="enumeration_section">9.1.1</span>加入树木</h4>
                  <div>
                     <p>通常，连接树表示为倒置树结构。</p>
                     <p>如下图所示， <code class="codeph">table1</code>是左表， <code class="codeph">table2</code>是右表。优化器从左到右处理连接。例如，如果此图形描绘了嵌套循环连接，则<code class="codeph">table1</code>是外循环， <code class="codeph">table2</code>是内循环。
                     </p>
                     <div class="figure" id="GUID-31B0F249-A5AA-41E9-AE98-A484FC5C487C__BABEFJII">
                        <p class="titleinfigure">图9-1连接树</p><img src="img/tgsql_vm_086.png" alt="下面是图9-1的描述" title="下面是图9-1的描述" longdesc="img_text/tgsql_vm_086.html"><br><a href="img_text/tgsql_vm_086.html">“图9-1加入树”的描述</a></div>
                     <!-- class="figure" -->
                     <p>连接的输入可以是先前连接的结果集。如果连接树的每个内部节点的右子节点是表，则该树是<a href="glossary.html#GUID-5697281B-74F7-4AF2-A73F-3CC1A96EA947"><span class="xrefglossterm">左深连接树</span></a> ，如以下示例所示。大多数连接树都是深层连接。
                     </p>
                     <div class="figure" id="GUID-31B0F249-A5AA-41E9-AE98-A484FC5C487C__BABFJDCH">
                        <p class="titleinfigure">图9-2左深连接树</p><img src="img/tgsql_vm_087.png" alt="下面是图9-2的描述" title="下面是图9-2的描述" longdesc="img_text/tgsql_vm_087.html"><br><a href="img_text/tgsql_vm_087.html">“图9-2左深连接树”的描述</a></div>
                     <!-- class="figure" -->
                     <p>如果连接树的每个内部节点的左子节点是一个表，则该树称为<a href="glossary.html#GUID-E01EE140-6652-4697-B257-C07148045B25"><span class="xrefglossterm">右深连接树</span></a> ，如下图所示。
                     </p>
                     <div class="figure" id="GUID-31B0F249-A5AA-41E9-AE98-A484FC5C487C__BABHFGHB">
                        <p class="titleinfigure">图9-3右深连接树</p><img src="img/tgsql_vm_088.png" alt="下面是图9-3的描述" title="下面是图9-3的描述" longdesc="img_text/tgsql_vm_088.html"><br><a href="img_text/tgsql_vm_088.html">“图9-3右深连接树”的描述</a></div>
                     <!-- class="figure" -->
                     <p>如果连接树的内部节点的左子节点或右子节点可以是连接节点，则该树称为<a href="glossary.html#GUID-4E921FAD-0F1B-47E7-A1A4-EAAAD5E043AB"><span class="xrefglossterm">分组连接树</span></a> 。在以下示例中， <code class="codeph">table4</code>是连接节点的右子节点， <code class="codeph">table1</code>是连接节点的左子节点， <code class="codeph">table2</code>是节点的左子节点。
                     </p>
                     <div class="figure" id="GUID-31B0F249-A5AA-41E9-AE98-A484FC5C487C__BABCEGEI">
                        <p class="titleinfigure">图9-4丛林加入树</p><img src="img/tgsql_vm_089.png" alt="下面是图9-4的描述" title="下面是图9-4的描述" longdesc="img_text/tgsql_vm_089.html"><br><a href="img_text/tgsql_vm_089.html">“图9-4丛林加入树”的描述</a></div>
                     <!-- class="figure" -->
                     <p>在又一个变型中，连接的两个输入都是先前连接的结果。</p>
                  </div>
                  <div>
                     <div class="familylinks">
                        <div class="parentlink">
                           <p><strong>父主题：</strong> <a href="joins.html#GUID-F47AB553-07F0-42E8-BF55-C31DCD5AAC81" title="连接组合恰好两个行源（例如表或视图）的输出，并返回一个行源。返回的行源是数据集。">关于联接</a></p>
                        </div>
                     </div>
                  </div>
                  
               </div><a id="TGSQL94679"></a><div class="props_rev_3"><a id="GUID-5435FC78-D572-4CEE-A733-CDB1DB8E544B" name="GUID-5435FC78-D572-4CEE-A733-CDB1DB8E544B"></a><h4 id="TGSQL-GUID-5435FC78-D572-4CEE-A733-CDB1DB8E544B" class="sect4"><span class="enumeration_section">9.1.2</span>优化程序如何执行连接语句</h4>
                  <div>
                     <p>数据库连接成对的行源。当<code class="codeph">FROM</code>子句中存在多个表时，优化器必须确定哪个连接操作对每个对最有效。
                     </p>
                     <p>优化程序必须使相关的决策显示在下表中。</p>
                     <div class="tblformal" id="GUID-5435FC78-D572-4CEE-A733-CDB1DB8E544B__GUID-26201563-907F-4948-9AC3-BAFAAB89292C">
                        <p class="titleintable">表9-1加入操作</p>
                        <table cellpadding="4" cellspacing="0" class="Formal" title="加入运营" border="1" summary="This table describes operations that the optimizer uses to join tables." frame="hsides" rules="rows">
                           <thead>
                              <tr align="left" valign="top">
                                 <th align="left" valign="bottom" width="20%" id="d49855e667">手术</th>
                                 <th align="left" valign="bottom" width="20%" id="d49855e669">说明</th>
                                 <th align="left" valign="bottom" width="20%" id="d49855e671">了解更多</th>
                              </tr>
                           </thead>
                           <tbody>
                              <tr align="left" valign="top">
                                 <td align="left" valign="top" width="20%" id="d49855e675" headers="d49855e667 ">
                                    <p>访问路径</p>
                                 </td>
                                 <td align="left" valign="top" width="20%" headers="d49855e675 d49855e669 ">
                                    <p>对于简单语句，优化器必须选择<a href="glossary.html#GUID-22DF198C-4310-4307-BF29-DCE765725BD4"><span class="xrefglossterm">访问路径</span></a>以从join语句中的每个表中检索数据。例如，优化器可以在全表扫描或索引扫描之间进行选择。
                                    </p>
                                 </td>
                                 <td align="left" valign="top" width="20%" headers="d49855e675 d49855e671 ">
                                    <p><span class="q">“ <a href="optimizer-access-paths.html#GUID-00711237-35D3-4CFC-A234-59B3EC53DCD1" title="访问路径是查询用于从行源检索行的技术。">优化器访问路径</a> ”</span></p>
                                 </td>
                              </tr>
                              <tr align="left" valign="top">
                                 <td align="left" valign="top" width="20%" id="d49855e696" headers="d49855e667 ">
                                    <p>加入方法</p>
                                 </td>
                                 <td align="left" valign="top" width="20%" headers="d49855e696 d49855e669 ">
                                    <p>要连接每对行源，Oracle数据库必须决定如何执行此操作。“如何”是连接方法。可能的连接方法是嵌套循环，排序合并和散列连接。笛卡尔连接需要前面的连接方法之一。每种连接方法都有特定的情况，它比其他连接方法更合适。</p>
                                 </td>
                                 <td align="left" valign="top" width="20%" headers="d49855e696 d49855e671 "> 
                                    <p><span class="q">“ <a href="joins.html#GUID-54F957FB-3568-499A-BCD2-B242BFFF913D" title="连接方法是连接两个行源的机制。">加入方法</a> ”</span></p>
                                 </td>
                              </tr>
                              <tr align="left" valign="top">
                                 <td align="left" valign="top" width="20%" id="d49855e712" headers="d49855e667 ">
                                    <p>加入类型</p>
                                 </td>
                                 <td align="left" valign="top" width="20%" headers="d49855e712 d49855e669 ">
                                    <p>连接条件确定连接类型。例如，内部联接仅检索与连接条件匹配的行。外连接检索与连接条件不匹配的行。</p>
                                 </td>
                                 <td align="left" valign="top" width="20%" headers="d49855e712 d49855e671 "><span class="q">“ <a href="joins.html#GUID-8E7760A6-48D6-4794-BF2F-290349C019B9" title="连接类型由连接条件的类型确定。">加入类型</a> ”</span></td>
                              </tr>
                              <tr align="left" valign="top">
                                 <td align="left" valign="top" width="20%" id="d49855e726" headers="d49855e667 ">
                                    <p>加入订单</p>
                                 </td>
                                 <td align="left" valign="top" width="20%" headers="d49855e726 d49855e669 ">
                                    <p>要执行连接两个以上表的语句，Oracle数据库会连接两个表，然后将生成的行源连接到下一个表。此过程将继续，直到所有表都加入到结果中。例如，数据库连接两个表，然后将结果连接到第三个表，然后将此结果连接到第四个表，依此类推。</p>
                                 </td>
                                 <td align="left" valign="top" width="20%" headers="d49855e726 d49855e671 ">N / A</td>
                              </tr>
                           </tbody>
                        </table>
                     </div>
                     <!-- class="inftblhruleinformal" -->
                  </div>
                  <div>
                     <div class="familylinks">
                        <div class="parentlink">
                           <p><strong>父主题：</strong> <a href="joins.html#GUID-F47AB553-07F0-42E8-BF55-C31DCD5AAC81" title="连接组合恰好两个行源（例如表或视图）的输出，并返回一个行源。返回的行源是数据集。">关于联接</a></p>
                        </div>
                     </div>
                  </div>
                  
               </div><a id="TGSQL94680"></a><div class="props_rev_3"><a id="GUID-8621DCD7-6F70-4720-8049-BA630B58F26C" name="GUID-8621DCD7-6F70-4720-8049-BA630B58F26C"></a><h4 id="TGSQL-GUID-8621DCD7-6F70-4720-8049-BA630B58F26C" class="sect4"><span class="enumeration_section">9.1.3</span>优化器如何为连接选择执行计划</h4>
                  <div>
                     <p>确定连接顺序和方法时，优化器的目标是尽早减少行数，以便在整个SQL语句执行期间执行较少的工作。</p>
                     <p>优化程序根据可能的连接顺序，连接方法和可用访问路径生成一组执行计划。然后，优化器会估算每个计划的成本，并选择成本最低的计划。选择执行计划时，优化程序会考虑以下因素：</p>
                     <ul style="list-style-type:disc">
                        <li>
                           <p>优化器首先确定连接两个或多个表是否导致包含最多一行的行源。</p>
                           <p>优化器根据表上的<code class="codeph">UNIQUE</code>和<code class="codeph">PRIMARY KEY</code>约束识别这种情况。如果存在这种情况，则优化器将这些表首先放在连接顺序中。然后，优化器优化剩余表集的连接。
                           </p>
                        </li>
                        <li>
                           <p>对于具有<a href="glossary.html#GUID-733FE231-0E7E-41AD-B5E0-ACA84B92FC6F"><span class="xrefglossterm">外连接</span></a>条件的连接语句，具有外连接运算符的表通常位于连接顺序中条件中的另一个表之后。
                           </p>
                           <p>通常，尽管优化程序在某些情况下会覆盖此排序条件，但优化程序不会考虑违反此准则的连接顺序。类似地，当子查询已转换为<a href="glossary.html#GUID-4EF44AED-32FD-4FF4-9ECB-24F0011A667E"><span class="xrefglossterm">反</span></a> <a href="glossary.html#GUID-EA539BF9-F0F2-479B-90B5-1855CD8E34B9"><span class="xrefglossterm">连接</span></a>或<a href="glossary.html#GUID-EA539BF9-F0F2-479B-90B5-1855CD8E34B9"><span class="xrefglossterm">半连接时</span></a> ，子查询中的表必须位于它们所连接或关联的外部查询块中的那些表之后。但是，散列反连接和半连接在某些情况下能够覆盖此排序条件。
                           </p>
                        </li>
                     </ul>
                     <p>优化程序通过计算估计的I / O和CPU来估算查询计划的成本。这些I / O具有与之相关的特定成本：单个块I / O的成本，以及多块I / O的另一个成本。此外，不同的函数和表达式具有与之相关的CPU成本。优化程序使用这些度量标准确定查询计划的总成本。这些度量标准可能会受编译时许多初始化参数和会话设置的影响，例如<code class="codeph">DB_FILE_MULTI_BLOCK_READ_COUNT</code>设置，系统统计信息等。
                     </p>
                     <p>例如，优化程序通过以下方式估算成本：</p>
                     <ul style="list-style-type:disc">
                        <li>
                           <p><a href="glossary.html#GUID-51D8DCA1-3607-46E0-AD38-388EC50273D0"><span class="xrefglossterm">嵌套循环连接</span></a>的成本取决于将<a href="glossary.html#GUID-5BAB6F1F-5D4C-4EDA-8F59-D97A75D4254C"><span class="xrefglossterm">外部表的</span></a>每个选定行及其<a href="glossary.html#GUID-95EF749F-18E4-47A5-9B8F-AD39A722FAB4"><span class="xrefglossterm">内部表的</span></a>每个匹配行读入内存的成本。优化程序使用数据字典中的统计信息估算这些成本。
                           </p>
                        </li>
                        <li>
                           <p><a href="glossary.html#GUID-2A7F42FE-2859-4B9C-83AD-EFF8FFB4AB92"><span class="xrefglossterm">排序合并连接</span></a>的成本在很大程度上取决于将所有源读入内存并对其进行排序的成本。
                           </p>
                        </li>
                        <li>
                           <p><a href="glossary.html#GUID-FF45796B-8A90-45C6-8A40-0B308B72AF7C"><span class="xrefglossterm">散列连接</span></a>的成本在很大程度上取决于在<a href="glossary.html#GUID-FF45796B-8A90-45C6-8A40-0B308B72AF7C"><span class="xrefglossterm">连接的</span></a>一个输入侧构建散列表并使用连接另一侧的行来探测它的成本。
                           </p>
                        </li>
                     </ul>
                     <div class="example" id="GUID-8621DCD7-6F70-4720-8049-BA630B58F26C__GUID-DEB39775-CCE8-40FF-ADB4-77984F7B0B33">
                        <p class="titleinexample">示例9-1估计连接顺序和方法的成本</p>
                        <p>从概念上讲，优化器构造连接顺序和方法的矩阵以及与每个相关的成本。例如，优化器必须确定在查询中如何最好地连接<code class="codeph">date_dim</code>和<code class="codeph">lineorder</code>表。下表显示了方法和订单的可能变体以及每种方法的成本。在此示例中，嵌套循环以<code class="codeph">date_dim</code>的顺序<code class="codeph">date_dim</code> ， <code class="codeph">lineorder</code>具有最低的成本。
                        </p>
                        <div class="tblformal" id="GUID-8621DCD7-6F70-4720-8049-BA630B58F26C__GUID-A80577B8-94A1-45C0-8378-8FE440FBE1BD">
                           <p class="titleintable">表9-2 date_dim和lineorder表连接的示例成本</p>
                           <table cellpadding="4" cellspacing="0" class="Formal" title="加入date_dim和lineorder表的示例成本" width="100%" border="1" summary="Join methods and orders" frame="hsides" rules="rows">
                              <thead>
                                 <tr align="left" valign="top">
                                    <th align="left" valign="bottom" width="20%" id="d49855e980">加入方法</th>
                                    <th align="left" valign="bottom" width="20%" id="d49855e982">date_dim，lineorder的成本</th>
                                    <th align="left" valign="bottom" width="20%" id="d49855e984">lineorder的成本，date_dim</th>
                                 </tr>
                              </thead>
                              <tbody>
                                 <tr align="left" valign="top">
                                    <td align="left" valign="top" width="20%" id="d49855e988" headers="d49855e980 ">嵌套循环</td>
                                    <td align="left" valign="top" width="20%" headers="d49855e988 d49855e982 ">39480</td>
                                    <td align="left" valign="top" width="20%" headers="d49855e988 d49855e984 ">6187540</td>
                                 </tr>
                                 <tr align="left" valign="top">
                                    <td align="left" valign="top" width="20%" id="d49855e995" headers="d49855e980 ">哈希加入</td>
                                    <td align="left" valign="top" width="20%" headers="d49855e995 d49855e982 ">187528</td>
                                    <td align="left" valign="top" width="20%" headers="d49855e995 d49855e984 ">194909</td>
                                 </tr>
                                 <tr align="left" valign="top">
                                    <td align="left" valign="top" width="20%" id="d49855e1002" headers="d49855e980 ">合并排序</td>
                                    <td align="left" valign="top" width="20%" headers="d49855e1002 d49855e982 ">217129</td>
                                    <td align="left" valign="top" width="20%" headers="d49855e1002 d49855e984 ">217129</td>
                                 </tr>
                              </tbody>
                           </table>
                        </div>
                        <!-- class="inftblhruleinformal" -->
                     </div>
                     <!-- class="example" -->
                  </div>
                  <div>
                     <div class="infoboxnotealso" id="GUID-8621DCD7-6F70-4720-8049-BA630B58F26C__GUID-4C2292DA-1C6A-43EF-8CCE-45E0612529DE">
                        <p class="notep1">也可以看看：</p>
                        <ul style="list-style-type:disc">
                           <li>
                              <p><span class="q">“ <a href="optimizer-statistics-concepts.html#GUID-AEE74FB8-98BD-416B-8EA0-32CD605DF64E" title="优化程序成本模型依赖于收集的有关查询中涉及的对象的统计信息，以及运行查询的数据库和主机。">优化器统计简介</a> ”</span></p>
                           </li>
                           <li>
                              <p><span class="q">“ <a href="influencing-the-optimizer.html#GUID-8758EF88-1CC6-41BD-8581-246702414D1D" title="优化程序默认值适用于大多数操作，但不是全部。">影响优化程序</a> ”</span>以获取有关优化程序提示的更多信息</p>
                           </li>
                           <li>
                              <p><a href="https://www.oracle.com/pls/topic/lookup?ctx=en/database/oracle/oracle-database/19/tgsql&amp;id=REFRN10037" target="_blank"><span><cite>Oracle Database Reference</cite></span></a>了解<code class="codeph">DB_FILE_MULTIBLOCK_READ_COUNT</code></p>
                           </li>
                        </ul>
                     </div>
                     <div class="familylinks">
                        <div class="parentlink">
                           <p><strong>父主题：</strong> <a href="joins.html#GUID-F47AB553-07F0-42E8-BF55-C31DCD5AAC81" title="连接组合恰好两个行源（例如表或视图）的输出，并返回一个行源。返回的行源是数据集。">关于联接</a></p>
                        </div>
                     </div>
                  </div>
                  
               </div>
            </div><a id="TGSQL95333"></a><a id="TGSQL95232"></a><div class="props_rev_3"><a id="GUID-54F957FB-3568-499A-BCD2-B242BFFF913D" name="GUID-54F957FB-3568-499A-BCD2-B242BFFF913D"></a><h3 id="TGSQL-GUID-54F957FB-3568-499A-BCD2-B242BFFF913D" class="sect3"><span class="enumeration_section">9.2</span>加入方法</h3>
               <div>
                  <p>连接方法是连接两个行源的机制。</p>
                  <p>根据统计信息，优化程序选择具有最低估计成本的方法。<a href="joins.html#GUID-54F957FB-3568-499A-BCD2-B242BFFF913D__BABHDGDJ">如图9-5</a>所示，每个连接方法都有两个子节点：驱动（也称为<span class="italic">外部</span> ）行源和驱动到（也称为<span class="italic">内部</span> ）行源。
                  </p>
                  <div class="figure" id="GUID-54F957FB-3568-499A-BCD2-B242BFFF913D__BABHDGDJ">
                     <p class="titleinfigure">图9-5连接方法</p><img src="img/tgsql_vm_080.png" alt="下面是图9-5的描述" title="下面是图9-5的描述" longdesc="img_text/tgsql_vm_080.html"><br><a href="img_text/tgsql_vm_080.html">“图9-5加入方法”的说明</a></div>
                  <!-- class="figure" -->
                  <p>本节包含以下主题：</p>
               </div>
               <div>
                  <ul class="ullinks">
                     <li class="ulchildlink"><a href="joins.html#GUID-A2DA6A1E-6180-4AB9-A777-586AF3953D53">嵌套循环加入</a><br>嵌套循环将外部数据集连接到内部数据集。
                     </li>
                     <li class="ulchildlink"><a href="joins.html#GUID-91E61BDC-E5F2-49FA-99AE-DD88A2FBB4FB">哈希加入</a><br>数据库使用<strong class="term">散列连接</strong>来连接更大的数据集。
                     </li>
                     <li class="ulchildlink"><a href="joins.html#GUID-5FCD34FE-ED04-4AB2-BC90-9752FED94F4F">合并连接排序</a><br>排序合并连接是嵌套循环连接的变体。
                     </li>
                  </ul>
                  <div class="familylinks">
                     <div class="parentlink">
                        <p><strong>父主题：</strong> <a href="joins.html#GUID-BD96F1B4-76D4-43DF-98B6-D07F46838C4A" title="Oracle数据库为加入行集提供了多种优化。">联接</a></p>
                     </div>
                  </div>
               </div>
               <a id="TGSQL244"></a><div class="props_rev_3"><a id="GUID-A2DA6A1E-6180-4AB9-A777-586AF3953D53" name="GUID-A2DA6A1E-6180-4AB9-A777-586AF3953D53"></a><h4 id="TGSQL-GUID-A2DA6A1E-6180-4AB9-A777-586AF3953D53" class="sect4"><span class="enumeration_section">9.2.1</span>嵌套循环连接</h4>
                  <div>
                     <p>嵌套循环将外部数据集连接到内部数据集。</p>
                     <p>对于外部数据集中与单表谓词匹配的每一行，数据库将检索内部数据集中满足连接谓词的所有行。如果索引可用，则数据库可以使用它来访问rowid的内部数据集。</p>
                     <p>本节包含以下主题：</p>
                  </div>
                  <div>
                     <ul class="ullinks">
                        <li class="ulchildlink"><a href="joins.html#GUID-CEBC5D18-1857-4F6B-8FA7-B9EEA3442653">当优化器考虑嵌套循环连接时</a><br>当数据库连接小数据子集时，嵌套循环连接很有用，数据库连接大型数据集，优化器模式设置为<code class="codeph">FIRST_ROWS</code> ，或者连接条件是访问内部表的有效方法。
                        </li>
                        <li class="ulchildlink"><a href="joins.html#GUID-C3D5CEA4-0AF4-4E15-8167-6C5D065A95D3">嵌套循环如何加入工作</a><br>从概念上讲，嵌套循环相当于两个嵌套<code class="codeph">for</code>循环。
                        </li>
                        <li class="ulchildlink"><a href="joins.html#GUID-73806FB2-F507-4B4E-9797-FD0C7A252D49">嵌套嵌套循环</a><br>嵌套循环的外部循环本身可以是由不同嵌套循环生成的行源。
                        </li>
                        <li class="ulchildlink"><a href="joins.html#GUID-D83585A7-4ADB-48C9-958E-693374BF7A31">嵌套循环连接的当前实现</a><br><span>Oracle Database 11g</span>为嵌套循环引入了一种新的实现，可以减少物理I / O的总体延迟。</li>
                        <li class="ulchildlink"><a href="joins.html#GUID-025483CA-9FC7-40A1-B907-FDA2B0BCAF04">嵌套循环连接的原始实现</a><br>在当前版本中，嵌套循环的新的和原始的实现都是可能的。
                        </li>
                        <li class="ulchildlink"><a href="joins.html#GUID-97E2CC5B-F0F8-410D-AEBF-63EB18E562C7">嵌套循环控件</a><br>对于某些SQL语句，数据足够小，以便优化器更喜欢全表扫描和散列连接。但是，您可以使用指定的表作为内部表，添加<code class="codeph">USE_NL</code>提示以指示优化器将每个指定的表连接到具有嵌套循环连接的另一个行源。
                        </li>
                     </ul>
                     <div class="familylinks">
                        <div class="parentlink">
                           <p><strong>父主题：</strong> <a href="joins.html#GUID-54F957FB-3568-499A-BCD2-B242BFFF913D" title="连接方法是连接两个行源的机制。">加入方法</a></p>
                        </div>
                     </div>
                  </div>
                  <a id="TGSQL94684"></a><div class="props_rev_3"><a id="GUID-CEBC5D18-1857-4F6B-8FA7-B9EEA3442653" name="GUID-CEBC5D18-1857-4F6B-8FA7-B9EEA3442653"></a><h5 id="TGSQL-GUID-CEBC5D18-1857-4F6B-8FA7-B9EEA3442653" class="sect5"><span class="enumeration_section">9.2.1.1</span>当优化器考虑嵌套循环连接时</h5>
                     <div>
                        <p>当数据库连接小数据子集时，嵌套循环连接很有用，数据库连接大型数据集，优化器模式设置为<code class="codeph">FIRST_ROWS</code> ，或者连接条件是访问内部表的有效方法。
                        </p>
                        <div class="infoboxnote" id="GUID-CEBC5D18-1857-4F6B-8FA7-B9EEA3442653__GUID-A099DD62-0329-4A98-BAA6-962FCB87EB36">
                           <p class="notep1">注意：</p>
                           <p>连接期望的行数是驱动优化器决策的因素，而不是基础表的大小。例如，查询可能会连接每个十亿行的两个表，但由于这些过滤器，优化程序需要每行5行的数据集。</p>
                        </div>
                        <p>通常，嵌套循环连接在具有连接条件的索引的小表上最有效。如果行源只有一行，就像主键值上的等式查找一样（例如， <code class="codeph">WHERE employee_id=101</code> ），则连接是一个简单的查找。优化器总是首先尝试放置最小的行源，使其成为驱动表。
                        </p>
                        <p>各种因素进入优化器决策以使用嵌套循环。例如，数据库可以批量读取外部行源中的多行。根据检索的行数，优化器可以选择嵌套循环或散列连接到内部行源。例如，如果查询将<code class="codeph">departments</code>连接到驱动表<code class="codeph">employees</code> ，并且谓词指定了<code class="codeph">employees.last_name</code>的值，则数据库可能会读取<code class="codeph">last_name</code>上的索引中的足够条目以确定是否传递了内部阈值。如果未传递阈值，则优化器会选择嵌套循环连接到<code class="codeph">departments</code> ，如果传递阈值，则数据库执行散列连接，这意味着读取其余<code class="codeph">employees</code> ，将其散列到内存中，然后加入<code class="codeph">departments</code> 。
                        </p>
                        <p>如果内循环的访问路径不依赖于外循环，那么结果可以是笛卡尔积：对于外循环的每次迭代，内循环产生相同的行集。要避免此问题，请使用其他连接方法来连接两个独立的行源。</p>
                     </div>
                     <div>
                        <div class="infoboxnotealso" id="GUID-CEBC5D18-1857-4F6B-8FA7-B9EEA3442653__GUID-CCDCEB37-F4A2-41E6-88B7-347542DCB940">
                           <p class="notep1">也可以看看：</p>
                           <ul style="list-style-type:disc">
                              <li>
                                 <p><span class="q">“ <a href="influencing-the-optimizer.html#GUID-C1C85DEA-3583-40FE-B5BB-6AC8F76FFE34__BBAIEADC" title="此双列表描述了控制优化程序行为的初始化参数。第1列是参数。第2列描述了该参数。">表19-2</a> ”</span></p>
                              </li>
                              <li>
                                 <p><span class="q">“ <a href="query-optimizer-concepts.html#GUID-5A1EB094-1A9E-4B69-9BE5-39BDA2B3253C" title="自适应查询计划使优化器能够在执行期间为语句做出计划决策。">自适应查询计划</a> ”</span></p>
                              </li>
                           </ul>
                        </div>
                        <div class="familylinks">
                           <div class="parentlink">
                              <p><strong>父主题：</strong> <a href="joins.html#GUID-A2DA6A1E-6180-4AB9-A777-586AF3953D53" title="嵌套循环将外部数据集连接到内部数据集。">嵌套循环连接</a></p>
                           </div>
                        </div>
                     </div>
                     
                  </div><a id="TGSQL95233"></a><div class="props_rev_3"><a id="GUID-C3D5CEA4-0AF4-4E15-8167-6C5D065A95D3" name="GUID-C3D5CEA4-0AF4-4E15-8167-6C5D065A95D3"></a><h5 id="TGSQL-GUID-C3D5CEA4-0AF4-4E15-8167-6C5D065A95D3" class="sect5"><span class="enumeration_section">9.2.1.2</span>嵌套循环如何连接工作</h5>
                     <div>
                        <p>从概念上讲，嵌套循环相当于两个嵌套<code class="codeph">for</code>循环。
                        </p>
                        <p>例如，如果查询加入了<code class="codeph">employees</code>和<code class="codeph">departments</code> ，那么伪代码中的嵌套循环可能是：</p><pre class="pre codeblock"><code>FOR erow IN（选择*来自X = Y的员工）LOOP FOR drow IN（选择*来自erow匹配的部门）来自erow和drow的LOOP输出值END LOOP END LOOP</code></pre><p>对于外循环的每一行执行内循环。该<code class="codeph">employees</code>表是“外”的数据集，因为它是在外部<code class="codeph">for</code>循环。外表有时被称为驱动表。<code class="codeph">departments</code>表是“内部”数据集，因为它位于内部<code class="codeph">for</code>循环中。
                        </p>
                        <p>嵌套循环连接涉及以下基本步骤：</p>
                        <ol>
                           <li>
                              <p>优化器确定驱动行源并将其指定为外循环。</p>
                              <p>外部循环产生一组行以驱动连接条件。行源可以是使用索引扫描，全表扫描或任何其他生成行的操作访问的表。</p>
                              <p>内循环的迭代次数取决于外循环中检索的行数。例如，如果从外部表中检索10行，则数据库必须在内部表中执行10次查找。如果从外部表中检索10,000,000行，则数据库必须在内部表中执行10,000,000次查找。</p>
                           </li>
                           <li>
                              <p>优化器将另一个行源指定为内部循环。</p>
                              <p>外部循环出现在执行计划的内部循环之前，如下所示：</p><pre class="pre codeblock"><code>NESTED LOOPS <span class="italic">outer_loop</span> <span class="italic">inner_loop</span> 
</code></pre></li>
                           <li>
                              <p>对于来自客户端的每个获取请求，基本过程如下：</p>
                              <ol type="a">
                                 <li>
                                    <p>从外部行源获取一行</p>
                                 </li>
                                 <li>
                                    <p>探测内部行源以查找与谓词条件匹配的行</p>
                                 </li>
                                 <li>
                                    <p>重复上述步骤，直到获取请求获取所有行</p>
                                 </li>
                              </ol>
                              <p>有时，数据库会对rowid进行排序以获得更有效的缓冲区访问模式。</p>
                           </li>
                        </ol>
                     </div>
                     <div>
                        <div class="familylinks">
                           <div class="parentlink">
                              <p><strong>父主题：</strong> <a href="joins.html#GUID-A2DA6A1E-6180-4AB9-A777-586AF3953D53" title="嵌套循环将外部数据集连接到内部数据集。">嵌套循环连接</a></p>
                           </div>
                        </div>
                     </div>
                     
                  </div><a id="TGSQL95235"></a><a id="TGSQL95234"></a><div class="props_rev_3"><a id="GUID-73806FB2-F507-4B4E-9797-FD0C7A252D49" name="GUID-73806FB2-F507-4B4E-9797-FD0C7A252D49"></a><h5 id="TGSQL-GUID-73806FB2-F507-4B4E-9797-FD0C7A252D49" class="sect5"><span class="enumeration_section">9.2.1.3</span>嵌套嵌套循环</h5>
                     <div>
                        <p>嵌套循环的外部循环本身可以是由不同嵌套循环生成的行源。</p>
                        <p>数据库可以嵌套两个或多个外部循环，以根据需要连接多个表。每个循环都是一种数据访问方法。以下模板显示了数据库如何遍历三个嵌套循环：</p><pre class="pre codeblock"><code>SELECT STATEMENT NESTED LOOPS 3 NESTED LOOPS 2  - 行源变为外循环3.1 NESTED LOOPS 1  - 行源变为外循环2.1外循环1.1内循环1.2内循环2.2内循环3.2</code></pre><p>数据库按如下顺序对循环进行排序：</p>
                        <ol>
                           <li>
                              <p>数据库遍历<code class="codeph">NESTED LOOPS 1</code> ：</p><pre class="pre codeblock"><code>NESTED LOOPS 1外圈1.1内圈1.2</code></pre><p><code class="codeph">NESTED LOOP 1</code>的输出是行源。
                              </p>
                           </li>
                           <li>
                              <p>数据库使用<code class="codeph">NESTED LOOPS 1</code>生成的行源作为其外循环遍历<code class="codeph">NESTED LOOPS 2</code> ：</p><pre class="pre codeblock"><code>NESTED LOOPS 2 OUTER LOOP 2.1  - 由NESTED LOOPS 1 INNER LOOP 2.2生成的行源</code></pre><p><code class="codeph">NESTED LOOPS 2</code>的输出是另一个行源。
                              </p>
                           </li>
                           <li>
                              <p>数据库使用<code class="codeph">NESTED LOOPS 2</code>生成的行源作为其外循环遍历<code class="codeph">NESTED LOOPS 3</code> ：</p><pre class="pre codeblock"><code>NESTED LOOPS 3 OUTER LOOP 3.1  - 由NESTED LOOPS 2 INNER LOOP 3.2生成的行源</code></pre></li>
                        </ol>
                        <div class="example" id="GUID-73806FB2-F507-4B4E-9797-FD0C7A252D49__GUID-6BFCCF64-A370-435C-922D-AB5238017267">
                           <p class="titleinexample">例9-2嵌套嵌套循环连接</p>
                           <p>假设您加入<code class="codeph">employees</code>和<code class="codeph">departments</code>表，如下所示：</p><pre class="pre codeblock"><code>SELECT / * + ORDERED USE_NL（d）* / e.last_name，e.first_name，d.department_name FROM employees e，departments d WHERE e.department_id = d.department_id AND e.last_name like'A％';</code></pre><p>该计划显示优化器选择了两个嵌套循环（步骤1和步骤2）来访问数据：</p><pre class="pre codeblock"><code>SQL_ID ahuavfcv4tnz4，子编号0 ------------------------------------- SELECT / * + ORDERED USE_NL（ d）* / e.last_name，d.department_name FROM employees e，departments d WHERE e.department_id = d.department_id AND e.last_name like'A％'计划哈希值：1667998133 ----------- -------------------------------------------------- --------------------- | Id |操作|名称|行|字节|成本（％CPU）|时间| -------------------------------------------------- -------------------------------- | 0 |选择声明| | | | 5（100）| | | 1 | NESTED LOOPS | | | | | | | 2 | NESTED LOOPS | | 3 | 102 | 5（0）| 00:00:01 | | 3 |通过INDEX ROWID BATCHED表的访问权限员工| 3 | 54 | 2（0）| 00:00:01 | | * 4 | INDEX RANGE SCAN | EMP_NAME_IX | 3 | | 1（0）| 00:00:01 | | * 5 | INDEX UNIQUE SCAN | DEPT_ID_PK | 1 | | 0（0）| | | 6 |按INDEX ROWID表的访问权限|部门| 1 | 16 | 1（0）| 00:00:01 | -------------------------------------------------- --------------------------------谓词信息（由操作ID标识）：--------- ------------------------------------------ 4  -  access（“E”。 “LAST_NAME”喜欢'A％'）过滤器（“E”。“LAST_NAME”喜欢'A％'）5  - 访问（“E”。“DEPARTMENT_ID”=“D”。“DEPARTMENT_ID”）</code></pre><p>在此示例中，基本过程如下：</p>
                           <ol>
                              <li>
                                 <p>数据库开始迭代内部嵌套循环（步骤2），如下所示：</p>
                                 <ol type="a">
                                    <li>
                                       <p>数据库在<code class="codeph">emp_name_ix</code>搜索以<code class="codeph">A</code>开头的所有姓氏的rowid（步骤4）。
                                       </p>
                                       <p>例如：</p><pre class="pre codeblock"><code>Abel，employees_rowid Ande，employees_rowid Atkinson，employees_rowid Austin，employees_rowid</code></pre></li>
                                    <li>
                                       <p>使用上一步中的rowid，数据库从<code class="codeph">employees</code>表中检索一批行（步骤3）。例如：</p><pre class="pre codeblock"><code>Abel，Ellen，80 Abel，John，50岁</code></pre><p>这些行成为最内层嵌套循环的外部行源。</p>
                                       <p>批处理步骤通常是自适应执行计划的一部分。要确定嵌套循环是否优于散列连接，优化程序需要确定从行源返回的许多行。如果返回的行太多，则优化程序将切换到其他连接方法。</p>
                                    </li>
                                    <li>
                                       <p>对于外部行源中的每一行，数据库扫描<code class="codeph">dept_id_pk</code>索引以获取匹配部门ID的<code class="codeph">departments</code>中的rowid（步骤5），并将其连接到<code class="codeph">employees</code>行。例如：</p><pre class="pre codeblock"><code>Abel，Ellen，80岁，departments_rowid Ande，Sundar，80岁，departments_rowid Atkinson，Mozhe，50岁，departments_rowid Austin，David，60岁，departments_rowid</code></pre><p>这些行成为外部嵌套循环的外部行源（步骤1）。</p>
                                    </li>
                                 </ol>
                              </li>
                              <li>
                                 <p>数据库循环遍历外部嵌套循环，如下所示：</p>
                                 <ol type="a">
                                    <li>
                                       <p>数据库读取外部行源中的第一行。</p>
                                       <p>例如：</p><pre class="pre codeblock"><code>亚伯，艾伦，80，departments_rowid</code></pre></li>
                                    <li>
                                       <p>数据库使用<code class="codeph">departments</code> rowid从<code class="codeph">departments</code>检索相应的行（步骤6），然后连接结果以获取请求的值（步骤1）。
                                       </p>
                                       <p>例如：</p><pre class="pre codeblock"><code>亚伯，艾伦，80，销售</code></pre></li>
                                    <li>
                                       <p>数据库读取外部行源中的下一行，使用<code class="codeph">departments</code> rowid从<code class="codeph">departments</code>检索相应的行（步骤6），并循环遍历循环直到检索到所有行。
                                       </p>
                                       <p>结果集具有以下形式：</p><pre class="pre codeblock"><code>Abel，Ellen，80岁，销售Ande，Sundar，80岁，销售Atkinson，Mozhe，50岁，航运Austin，David，60岁，IT</code></pre></li>
                                 </ol>
                              </li>
                           </ol>
                        </div>
                        <!-- class="example" -->
                     </div>
                     <div>
                        <div class="familylinks">
                           <div class="parentlink">
                              <p><strong>父主题：</strong> <a href="joins.html#GUID-A2DA6A1E-6180-4AB9-A777-586AF3953D53" title="嵌套循环将外部数据集连接到内部数据集。">嵌套循环连接</a></p>
                           </div>
                        </div>
                     </div>
                     
                  </div><a id="TGSQL94683"></a><div class="props_rev_3"><a id="GUID-D83585A7-4ADB-48C9-958E-693374BF7A31" name="GUID-D83585A7-4ADB-48C9-958E-693374BF7A31"></a><h5 id="TGSQL-GUID-D83585A7-4ADB-48C9-958E-693374BF7A31" class="sect5"><span class="enumeration_section">9.2.1.4</span>嵌套循环连接的当前实现</h5>
                     <div>
                        <p><span>Oracle Database 11g</span>为嵌套循环引入了一种新的实现，可以减少物理I / O的总体延迟。</p>
                        <p>当索引或表块不在缓冲区高速缓存中并且需要处理连接时，需要物理I / O.数据库可以批处理多个物理I / O请求，并使用向量I / O（数组）处理它们，而不是一次处理一个。数据库将一个rowid数组发送到操作系统，该操作系统执行读取操作。</p>
                        <p>作为新实现的一部分，两个<code class="codeph">NESTED LOOPS</code>连接行源可能出现在执行计划中，其中只有一个出现在先前版本中。在这种情况下，Oracle数据库会分配一个<code class="codeph">NESTED LOOPS</code>连接行源来连接连接外侧的表中的值和内侧的索引。分配第二行源以连接第一个连接的结果，其中包括存储在索引中的rowid，以及连接内侧的表。
                        </p>
                        <p>考虑<span class="q">“ <a href="joins.html#GUID-025483CA-9FC7-40A1-B907-FDA2B0BCAF04" title="在当前版本中，嵌套循环的新的和原始的实现都是可能的。">嵌套循环连接的原始实现</a> ”中</span>的查询。在当前实现中，此查询的执行计划可能如下所示：</p><pre class="pre codeblock"><code>-------------------------------------------------- ----------------------------------- | Id |操作|名称|行|字节|成本％CPU |时间| -------------------------------------------------- ----------------------------------- | 0 |选择声明| | 19 | 722 | 3（0）| 00:00:01 | | 1 | NESTED LOOPS | | | | | | | 2 | NESTED LOOPS | | 19 | 722 | 3（0）| 00:00:01 | | * 3 |表访问完全|部门| 2 | 32 | 2（0）| 00:00:01 | | * 4 | INDEX RANGE SCAN | EMP_DEPARTMENT_IX | 10 | | 0（0）| 00:00:01 | | 5 |按INDEX ROWID表的访问权限|员工| 10 | 220 | 1（0）| 00:00:01 | -------------------------------------------------- -----------------------------------谓词信息（由操作ID标识）：------ --------------------------------------------- 3  -  filter（“ D“。”DEPARTMENT_NAME“='营销'或”D“。”DEPARTMENT_NAME“='销售'）4  - 访问（”E“。”DEPARTMENT_ID“=”D“。”DEPARTMENT_ID“）</code></pre><p>在这种情况下， <code class="codeph">hr.departments</code>表中的行形成内部嵌套循环的<code class="codeph">hr.departments</code>源（步骤3）（步骤2）。索引<code class="codeph">emp_department_ix</code>是内嵌套循环的<code class="codeph">emp_department_ix</code>源（步骤4）。内嵌套循环的结果形成外嵌套循环（第1行）的外行源（第2行）。<code class="codeph">hr.employees</code>表是外部嵌套循环的外部行源（第5行）。
                        </p>
                        <p>对于每个获取请求，基本过程如下：</p>
                        <ol>
                           <li>
                              <p>数据库遍历内部嵌套循环（步骤2）以获取fetch中请求的行：</p>
                              <ol type="a">
                                 <li>
                                    <p>数据库读取第一行<code class="codeph">departments</code>以获取名为<code class="codeph">Marketing</code>或<code class="codeph">Sales</code>部门的部门ID（步骤3）。例如：</p><pre class="pre codeblock"><code>市场营销，20</code></pre><p>该行集是外循环。数据库将数据缓存在PGA中。</p>
                                 </li>
                                 <li>
                                    <p>数据库扫描<code class="codeph">emp_department_ix</code> （ <code class="codeph">employees</code>表上的索引），以查找与此部门ID对应的<code class="codeph">employees</code> rowid（步骤4），然后加入结果（步骤2）。
                                    </p>
                                    <p>结果集具有以下形式：</p><pre class="pre codeblock"><code>营销，20，employees_rowid营销，20，employees_rowid营销，20，employees_rowid</code></pre></li>
                                 <li>
                                    <p>数据库读取下一行<code class="codeph">departments</code> ，扫描<code class="codeph">emp_department_ix</code>以查找与此部门ID对应的<code class="codeph">employees</code> rowid，然后遍历循环直到满足客户端请求。
                                    </p>
                                    <p>在此示例中，数据库仅迭代外部循环两次，因为<code class="codeph">departments</code>只有两行满足谓词过滤器。从概念上讲，结果集具有以下形式：</p><pre class="pre codeblock"><code>营销，20，employees_rowid营销，20，employees_rowid营销，20，employees_rowid。。。销售额，80，employees_rowid销售额，80，employees_rowid销售额，80，employees_rowid。。。
</code></pre><p>这些行成为外部嵌套循环的外部行源（步骤1）。此行集缓存在PGA中。</p>
                                 </li>
                              </ol>
                           </li>
                           <li>
                              <p>数据库组织上一步中获取的rowid，以便它可以更有效地在缓存中访问它们。</p>
                           </li>
                           <li>
                              <p>数据库开始迭代外部嵌套循环，如下所示：</p>
                              <ol type="a">
                                 <li>
                                    <p>数据库从上一步中获取的行集中检索第一行，如下例所示：</p><pre class="pre codeblock"><code>市场营销，20，employees_rowid</code></pre></li>
                                 <li>
                                    <p>使用rowid，数据库从<code class="codeph">employees</code>检索一行以获取请求的值（步骤1），如下例所示：</p><pre class="pre codeblock"><code>迈克尔，Hartstein，13000，市场营销</code></pre></li>
                                 <li>
                                    <p>数据库从行集中检索下一行，使用rowid探测匹配行的<code class="codeph">employees</code> ，并遍历循环直到检索到所有行。
                                    </p>
                                    <p>结果集具有以下形式：</p><pre class="pre codeblock"><code>Michael，Hartstein，13000，Marketing Pat，Fay，6000，Marketing John，Russell，14000，Sales Karen，Partners，13500，Sales Alberto，Errazuriz，12000，Sales。。。
</code></pre></li>
                              </ol>
                           </li>
                        </ol>
                        <p>在某些情况下，未分配第二个连接行源，执行计划与<span>Oracle Database 11g</span>之前的相同。以下列表描述了这种情况：</p>
                        <ul style="list-style-type:disc">
                           <li>
                              <p>从连接内侧所需的所有列都存在于索引中，并且不需要表访问。在这种情况下，Oracle数据库仅分配一个连接行源。</p>
                           </li>
                           <li>
                              <p>返回的行的顺序可能与<span>Oracle Database 12c</span>之前的版本中返回的顺序不同。因此，当Oracle数据库尝试保留行的特定顺序时，例如为了消除对<code class="codeph">ORDER BY</code>排序的需要，Oracle数据库可能会将原始实现用于嵌套循环连接。
                              </p>
                           </li>
                           <li>
                              <p><code class="codeph">OPTIMIZER_FEATURES_ENABLE</code>初始化参数设置为<span>Oracle Database 11g</span>之前的版本。在这种情况下，Oracle数据库使用嵌套循环连接的原始实现。
                              </p>
                           </li>
                        </ul>
                     </div>
                     <div>
                        <div class="familylinks">
                           <div class="parentlink">
                              <p><strong>父主题：</strong> <a href="joins.html#GUID-A2DA6A1E-6180-4AB9-A777-586AF3953D53" title="嵌套循环将外部数据集连接到内部数据集。">嵌套循环连接</a></p>
                           </div>
                        </div>
                     </div>
                     
                  </div><a id="TGSQL94681"></a><div class="props_rev_3"><a id="GUID-025483CA-9FC7-40A1-B907-FDA2B0BCAF04" name="GUID-025483CA-9FC7-40A1-B907-FDA2B0BCAF04"></a><h5 id="TGSQL-GUID-025483CA-9FC7-40A1-B907-FDA2B0BCAF04" class="sect5"><span class="enumeration_section">9.2.1.5</span>嵌套循环连接的原始实现</h5>
                     <div>
                        <p>在当前版本中，嵌套循环的新的和原始的实现都是可能的。</p>
                        <p>有关原始实现的示例，请考虑<code class="codeph">hr.employees</code>和<code class="codeph">hr.departments</code>表的以下连接：</p><pre class="pre codeblock"><code>SELECT e.first_name，e.last_name，e.salary，d.department_name FROM hr.employees e，hr.departments d WHERE d.department_name IN（'Marketing'，'Sales'）AND e.department_id = d.department_id;</code></pre><p>在Oracle Database <span class="italic">11g</span>之前的版本中，此查询的执行计划可能如下所示：</p><pre class="pre codeblock"><code>-------------------------------------------------- ---------------------------------------------- | Id |操作|名称|行|字节|成本（％CPU）|时间| -------------------------------------------------- ---------------------------------------------- | 0 |选择声明| | 19 | 722 | 3（0）| 00:00:01 | | 1 |按INDEX ROWID表的访问权限|员工| 10 | 220 | 1（0）| 00:00:01 | | 2 | NESTED LOOPS | | 19 | 722 | 3（0）| 00:00:01 | | * 3 |表访问完全|部门| 2 | 32 | 2（0）| 00:00:01 | | * 4 | INDEX RANGE SCAN | EMP_DEPARTMENT_IX | 10 | | 0（0）| 00:00:01 | -------------------------------------------------- ----------------------------------------------谓词信息（已确定通过操作ID）：--------------------------------------------- ------ 3  - 过滤器（“D”。“DEPARTMENT_NAME”='营销'或“D”。“DEPARTMENT_NAME”='销售'）4  - 访问（“E”。“DEPARTMENT_ID”=“D”。 “DEPARTMENT_ID”）</code></pre><p>对于每个获取请求，基本过程如下：</p>
                        <ol>
                           <li>
                              <p>数据库循环遍历循环以获取fetch中请求的行：</p>
                              <ol type="a">
                                 <li>
                                    <p>数据库读取第一行<code class="codeph">departments</code>以获取名为<code class="codeph">Marketing</code>或<code class="codeph">Sales</code>部门的部门ID（步骤3）。例如：</p><pre class="oac_no_warn" dir="ltr">市场营销，20</pre><p>该行集是外循环。数据库将行缓存在PGA中。</p>
                                 </li>
                                 <li>
                                    <p>数据库扫描<code class="codeph">emp_department_ix</code> ，它是<code class="codeph">employees.department_id</code>列的索引，用于查找与此部门ID对应的<code class="codeph">employees</code> rowid（步骤4），然后加入结果（步骤2）。
                                    </p>
                                    <p>从概念上讲，结果集具有以下形式：</p><pre class="pre codeblock"><code>营销，20， <span class="italic">employees_rowid</span>营销，20， <span class="italic">employees_rowid</span>营销，20， <span class="italic">employees_rowid</span>
</code></pre></li>
                                 <li>
                                    <p>数据库读取下一行<code class="codeph">departments</code> ，扫描<code class="codeph">emp_department_ix</code>以查找与此部门ID对应的<code class="codeph">employees</code> rowid，并遍历循环直到满足客户端请求。
                                    </p>
                                    <p>在此示例中，数据库仅迭代外部循环两次，因为<code class="codeph">departments</code>只有两行满足谓词过滤器。从概念上讲，结果集具有以下形式：</p><pre class="pre codeblock"><code>营销，20， <span class="italic">employees_rowid</span>营销，20， <span class="italic">employees_rowid</span>营销，20， <span class="italic">employees_rowid</span> 。。。销售额，80， <span class="italic">employees_rowid</span>销售额，80， <span class="italic">employees_rowid</span>销售额，80， <span class="italic">employees_rowid</span> 。。。
</code></pre></li>
                              </ol>
                           </li>
                           <li>
                              <p>根据具体情况，数据库可以组织上一步中获得的缓存rowid，以便它可以更有效地访问它们。</p>
                           </li>
                           <li>
                              <p>对于嵌套循环生成的结果集中的每个<code class="codeph">employees</code> rowid，数据库从<code class="codeph">employees</code>检索一行以获取请求的值（步骤1）。
                              </p>
                              <p>因此，基本过程是读取rowid并检索匹配的<code class="codeph">employees</code>行，读取下一个rowid并检索匹配的<code class="codeph">employees</code>行，依此类推。从概念上讲，结果集具有以下形式：</p><pre class="pre codeblock"><code>Michael，Hartstein，13000，Marketing Pat，Fay，6000，Marketing John，Russell，14000，Sales Karen，Partners，13500，Sales Alberto，Errazuriz，12000，Sales。。。</code></pre></li>
                        </ol>
                     </div>
                     <div>
                        <div class="familylinks">
                           <div class="parentlink">
                              <p><strong>父主题：</strong> <a href="joins.html#GUID-A2DA6A1E-6180-4AB9-A777-586AF3953D53" title="嵌套循环将外部数据集连接到内部数据集。">嵌套循环连接</a></p>
                           </div>
                        </div>
                     </div>
                     
                  </div><a id="TGSQL95236"></a><a id="TGSQL94685"></a><div class="props_rev_3"><a id="GUID-97E2CC5B-F0F8-410D-AEBF-63EB18E562C7" name="GUID-97E2CC5B-F0F8-410D-AEBF-63EB18E562C7"></a><h5 id="TGSQL-GUID-97E2CC5B-F0F8-410D-AEBF-63EB18E562C7" class="sect5"><span class="enumeration_section">9.2.1.6</span>嵌套循环控件</h5>
                     <div>
                        <p>对于某些SQL语句，数据足够小，以便优化器更喜欢全表扫描和散列连接。但是，您可以使用指定的表作为内部表，添加<code class="codeph">USE_NL</code>提示以指示优化器将每个指定的表连接到具有嵌套循环连接的另一个行源。
                        </p>
                        <p>相关提示<code class="codeph">USE_NL_WITH_INDEX( <span class="codeinlineitalic">table index</span> )</code>提示指示优化器使用指定表作为内部表将指定表连接到具有嵌套循环连接的另一行源。索引是可选的。如果未指定索引，则嵌套循环连接使用具有至少一个连接谓词的索引作为索引键。
                        </p>
                        <div class="example" id="GUID-97E2CC5B-F0F8-410D-AEBF-63EB18E562C7__GUID-E222ED08-1F53-4217-9D1B-0BCC3D224D13">
                           <p class="titleinexample">例9-3嵌套循环提示</p>
                           <p>假设优化器为以下查询选择散列连接：</p><pre class="pre codeblock"><code>SELECT e.last_name，d.department_name FROM employees e，departments d WHERE e.department_id = d.department_id;</code></pre><p>该计划如下：</p><pre class="pre codeblock"><code>-------------------------------------------------- ---------------------------- | Id |操作|名称|行|字节|成本（％CPU）|时间| -------------------------------------------------- ---------------------------- | 0 |选择声明| | | | 5（100）| | | * 1 | HASH JOIN | | 106 | 2862 | 5（20）| 00:00:01 | | 2 |表访问完全|部门| 27 | 432 | 2（0）| 00:00:01 | | 3 |表访问完全|员工| 107 | 1177 | 2（0）| 00:00:01 | -------------------------------------------------- ----------------------------</code></pre><p>要使用<code class="codeph">departments</code>作为内部表强制嵌套循环连接，请按以下查询添加<code class="codeph">USE_NL</code>提示：</p><pre class="pre codeblock"><code>SELECT / * + ORDERED USE_NL（d）* / e.last_name，d.department_name FROM employees e，departments d WHERE e.department_id = d.department_id;</code></pre><p>该计划如下：</p><pre class="pre codeblock"><code>-------------------------------------------------- ------------------------------ | Id |操作|名称|行|字节|成本（％CPU）|时间| -------------------------------------------------- ------------------------------ | 0 |选择声明| | | | 34（100）| | | 1 | NESTED LOOPS | | 106 | 2862 | 34（3）| 00:00:01 | | 2 |表访问完全|员工| 107 | 1177 | 2（0）| 00:00:01 | | * 3 |表访问完全|部门| 1 | 16 | 0（0）| | -------------------------------------------------- ------------------------------谓词信息（由操作ID标识）：----------- ---------------------------------------- 3  - 过滤器（“E”。“DEPARTMENT_ID “=” d”。 “DEPARTMENT_ID”）</code></pre><p>数据库获取结果集如下：</p>
                           <ol>
                              <li>
                                 <p>在嵌套循环中，数据库读取<code class="codeph">employees</code>以获取<code class="codeph">employees</code>的姓氏和部门ID（步骤2）。例如：</p><pre class="pre codeblock"><code>De Haan，90岁</code></pre></li>
                              <li>
                                 <p>对于在上一步骤中获得的行，数据库扫描<code class="codeph">departments</code>以查找与<code class="codeph">employees</code>部门ID匹配的部门名称（步骤3），并加入结果（步骤1）。例如：</p><pre class="pre codeblock"><code>De Haan，执行官</code></pre></li>
                              <li>
                                 <p>数据库检索<code class="codeph">employees</code>的下一行，从<code class="codeph">departments</code>检索匹配的行，然后重复此过程，直到检索到所有行。
                                 </p>
                                 <p>结果集具有以下形式：</p><pre class="pre codeblock"><code>De Haan，执行官Kochnar，执行Baer，公共关系之王，执行官。。。</code></pre></li>
                           </ol>
                        </div>
                        <!-- class="example" -->
                     </div>
                     <div>
                        <div class="infoboxnotealso" id="GUID-97E2CC5B-F0F8-410D-AEBF-63EB18E562C7__GUID-C588B1FC-8F6A-4DAC-BA80-55D695AD82C1">
                           <p class="notep1">也可以看看：</p>
                           <ul style="list-style-type:disc">
                              <li>
                                 <p><span class="q">“ <a href="influencing-the-optimizer.html#GUID-5976D09A-257A-49F3-94E0-247B1247270A" title="在某些情况下，您可以在SQL语句中指定连接顺序提示，以便它不会访问对结果没有影响的行。">加入订单提示指南</a> ”</span>以了解有关<code class="codeph">USE_NL</code>提示的更多信息</p>
                              </li>
                              <li>
                                 <p><a href="https://www.oracle.com/pls/topic/lookup?ctx=en/database/oracle/oracle-database/19/tgsql&amp;id=SQLRF50701" target="_blank"><span class="italic">Oracle数据库SQL语言参考</span></a> ，了解<code class="codeph">USE_NL</code>提示</p>
                              </li>
                           </ul>
                        </div>
                        <div class="familylinks">
                           <div class="parentlink">
                              <p><strong>父主题：</strong> <a href="joins.html#GUID-A2DA6A1E-6180-4AB9-A777-586AF3953D53" title="嵌套循环将外部数据集连接到内部数据集。">嵌套循环连接</a></p>
                           </div>
                        </div>
                     </div>
                     
                  </div>
               </div><a id="TGSQL245"></a><div class="props_rev_3"><a id="GUID-91E61BDC-E5F2-49FA-99AE-DD88A2FBB4FB" name="GUID-91E61BDC-E5F2-49FA-99AE-DD88A2FBB4FB"></a><h4 id="TGSQL-GUID-91E61BDC-E5F2-49FA-99AE-DD88A2FBB4FB" class="sect4"><span class="enumeration_section">9.2.2</span>哈希联接</h4>
                  <div>
                     <p>数据库使用<strong class="term">散列连接</strong>来连接更大的数据集。
                     </p>
                     <p>优化器使用两个数据集中较小的一个来在内存中的连接键上构建哈希表，使用确定性哈希函数指定哈希表中存储每一行的位置。然后，数据库扫描较大的数据集，探测哈希表以查找满足连接条件的行。</p>
                     <p>本节包含以下主题：</p>
                  </div>
                  <div>
                     <ul class="ullinks">
                        <li class="ulchildlink"><a href="joins.html#GUID-93D59774-BC0C-4BDF-88E3-0A2B346A0A62">当优化器考虑散列连接时</a><br>通常，当必须连接相对大量的数据时（或者必须连接大小的小表）时，优化器会考虑散列连接，并且连接是等同连接。
                        </li>
                        <li class="ulchildlink"><a href="joins.html#GUID-5A801568-F4E2-45C5-940B-55D23761BFD7">哈希如何加入工作</a><br>散列算法采用一组输入并应用确定性散列函数来生成介于1和<span class="italic">n</span>之间的散列值，其中<span class="italic">n</span>是散列表的大小。
                        </li>
                        <li class="ulchildlink"><a href="joins.html#GUID-0F295C4C-FF10-4BE8-BB0C-C8CD78545277">当Hash表不适合PGA时，Hash如何工作</a><br>当哈希表不完全适合PGA时，数据库必须使用不同的技术。在这种情况下，数据库使用临时空间来保存哈希表的部分（称为分区），有时还使用较大表的一部分来探测哈希表。
                        </li>
                        <li class="ulchildlink"><a href="joins.html#GUID-E8076180-ABDD-47F4-B6CB-DDDB6887B131">散列加入控件</a><br><code class="codeph">USE_HASH</code>提示指示优化器在将两个表连接在一起时使用散列连接。
                        </li>
                     </ul>
                     <div class="familylinks">
                        <div class="parentlink">
                           <p><strong>父主题：</strong> <a href="joins.html#GUID-54F957FB-3568-499A-BCD2-B242BFFF913D" title="连接方法是连接两个行源的机制。">加入方法</a></p>
                        </div>
                     </div>
                  </div>
                  <a id="TGSQL94687"></a><div class="props_rev_3"><a id="GUID-93D59774-BC0C-4BDF-88E3-0A2B346A0A62" name="GUID-93D59774-BC0C-4BDF-88E3-0A2B346A0A62"></a><h5 id="TGSQL-GUID-93D59774-BC0C-4BDF-88E3-0A2B346A0A62" class="sect5"><span class="enumeration_section">9.2.2.1</span>优化器考虑哈希联接时</h5>
                     <div>
                        <p>通常，当必须连接相对大量的数据时（或者必须连接大小的小表）时，优化器会考虑散列连接，并且连接是等同连接。</p>
                        <p>当较小的数据集适合内存时，散列连接最具成本效益。在这种情况下，成本仅限于两个数据集上的单个读取通过。</p>
                        <p>由于哈希表位于PGA中，因此Oracle数据库可以访问行而不锁定它们。该技术通过避免在数据库缓冲区高速缓存中重复锁存和读取块的必要性来减少逻辑I / O.</p>
                        <p>如果数据集不适合内存，则数据库对行源进行分区，并且连接按分区进行分区。这可以使用大量的排序区域内存，以及临时表空间的I / O.此方法仍然是最具成本效益的，尤其是当数据库使用并行查询服务器时。</p>
                     </div>
                     <div>
                        <div class="familylinks">
                           <div class="parentlink">
                              <p><strong>父主题：</strong> <a href="joins.html#GUID-91E61BDC-E5F2-49FA-99AE-DD88A2FBB4FB" title="数据库使用散列连接来连接更大的数据集。">哈希联接</a></p>
                           </div>
                        </div>
                     </div>
                     
                  </div><a id="TGSQL95237"></a><div class="props_rev_3"><a id="GUID-5A801568-F4E2-45C5-940B-55D23761BFD7" name="GUID-5A801568-F4E2-45C5-940B-55D23761BFD7"></a><h5 id="TGSQL-GUID-5A801568-F4E2-45C5-940B-55D23761BFD7" class="sect5"><span class="enumeration_section">9.2.2.2</span>哈希如何加入工作</h5>
                     <div>
                        <p>散列算法采用一组输入并应用确定性散列函数来生成介于1和<span class="italic">n</span>之间的散列值，其中<span class="italic">n</span>是散列表的大小。
                        </p>
                        <p>在散列连接中，输入值是连接键。输出值是数组中的索引（槽），即哈希表。</p>
                        <p>本节包含以下主题：</p>
                     </div>
                     <div>
                        <ul class="ullinks">
                           <li class="ulchildlink"><a href="joins.html#GUID-1E1D17CA-442F-4889-B83C-1A6C41540C91">哈希表</a><br>为了说<code class="codeph">hr.departments</code>表，假设数据库在<code class="codeph">departments</code>和<code class="codeph">employees</code>的连接中哈希<code class="codeph">hr.departments</code> 。连接键列是<code class="codeph">department_id</code> 。
                           </li>
                           <li class="ulchildlink"><a href="joins.html#GUID-9EE5CD4C-B90C-4E61-83DC-BD585D79635C">哈希加入：基本步骤</a><br>优化器使用较小的数据源在内存中的连接键上构建哈希表，然后扫描较大的表以查找连接的行。
                           </li>
                        </ul>
                        <div class="familylinks">
                           <div class="parentlink">
                              <p><strong>父主题：</strong> <a href="joins.html#GUID-91E61BDC-E5F2-49FA-99AE-DD88A2FBB4FB" title="数据库使用散列连接来连接更大的数据集。">哈希联接</a></p>
                           </div>
                        </div>
                     </div>
                     <a id="TGSQL95295"></a><div class="props_rev_3"><a id="GUID-1E1D17CA-442F-4889-B83C-1A6C41540C91" name="GUID-1E1D17CA-442F-4889-B83C-1A6C41540C91"></a><h6 id="TGSQL-GUID-1E1D17CA-442F-4889-B83C-1A6C41540C91" class="sect6"><span class="enumeration_section">9.2.2.2.1</span>哈希表</h6>
                        <div>
                           <p>为了说<code class="codeph">hr.departments</code>表，假设数据库在<code class="codeph">departments</code>和<code class="codeph">employees</code>的连接中哈希<code class="codeph">hr.departments</code> 。连接键列是<code class="codeph">department_id</code> 。
                           </p>
                           <p>前5行<code class="codeph">departments</code>如下：</p><pre class="pre codeblock"><code>SQL&gt; select * from rownum &lt;6; DEPARTMENT_ID DEPARTMENT_NAME MANAGER_ID LOCATION_ID ------------- ------------------------------ --- ------- ----------- 10管理200 1700 20市场营销201 1800 30采购114 1700 40人力资源203 2400 50运输121 1500</code></pre><p>数据库将哈希函数应用于表中的每个<code class="codeph">department_id</code> ，为每个<code class="codeph">department_id</code>生成哈希值。对于此图示，哈希表有5个插槽（可能有更多或更少）。因为<span class="italic">n</span>是<code class="codeph">5</code> ，所以可能的哈希值范围从<code class="codeph">1</code>到<code class="codeph">5</code> 。哈希函数可能会为部门ID生成以下值：</p><pre class="pre codeblock"><code>f（10）= 4 f（20）= 1 f（30）= 4 f（40）= 2 f（50）= 5</code></pre><p>请注意，哈希函数恰好为部门<code class="codeph">10</code>和<code class="codeph">30</code>生成相同的哈希值<code class="codeph">4</code> 。这称为<a href="glossary.html#GUID-1391B1A0-90E0-4E77-87F3-3703B434F194"><span class="xrefglossterm">哈希冲突</span></a> 。在这种情况下，数据库使用链接列表将部门<code class="codeph">10</code>和<code class="codeph">30</code>的记录放在同一个插槽中。从概念上讲，哈希表如下所示：</p><pre class="pre codeblock"><code>1 20，市场营销，201,1800 2 40，人力资源，203,2400 3 4 10，行政，200,1700  - &gt; 30，采购，114,1700 5 50，航运，121,1500</code></pre></div>
                        <div>
                           <div class="familylinks">
                              <div class="parentlink">
                                 <p><strong>父主题：</strong> <a href="joins.html#GUID-5A801568-F4E2-45C5-940B-55D23761BFD7" title="散列算法采用一组输入并应用确定性散列函数来生成介于1和n之间的散列值，其中n是散列表的大小。">哈希加入如何工作</a></p>
                              </div>
                           </div>
                        </div>
                        
                     </div><a id="TGSQL94688"></a><a id="TGSQL95296"></a><div class="props_rev_3"><a id="GUID-9EE5CD4C-B90C-4E61-83DC-BD585D79635C" name="GUID-9EE5CD4C-B90C-4E61-83DC-BD585D79635C"></a><h6 id="TGSQL-GUID-9EE5CD4C-B90C-4E61-83DC-BD585D79635C" class="sect6"><span class="enumeration_section">9.2.2.2.2</span>散列连接：基本步骤</h6>
                        <div>
                           <p>优化器使用较小的数据源在内存中的连接键上构建哈希表，然后扫描较大的表以查找连接的行。</p>
                           <p>基本步骤如下：</p>
                           <ol>
                              <li>
                                 <p>数据库执行称为<span class="bold">构建表</span>的较小数据集的完整扫描，然后将哈希函数应用于每行中的连接键，以在PGA中构建哈希表。</p>
                                 <p>在伪代码中，算法可能如下所示：</p><pre class="pre codeblock"><code>FOR small_table_row IN（SELECT * FROM small_table）LOOP slot_number：= HASH（small_table_row.join_key）; INSERT_HASH_TABLE（时隙号，small_table_row）;结束循环;</code></pre></li>
                              <li>
                                 <p>数据库使用成本最低的访问机制<span class="bold">探测</span>称为<span class="bold">探测表</span>的第二个数据集。
                                 </p>
                                 <p>通常，数据库会对较小和较大的数据集执行完整扫描。伪代码中的算法可能如下所示：</p><pre class="pre codeblock"><code>FOR large_table_row IN（SELECT * FROM large_table）LOOP slot_number：= HASH（large_table_row.join_key）; small_table_row = LOOKUP_HASH_TABLE（slot_number，large_table_row.join_key）; IF small_table_row FOUND THEN输出small_table_row + large_table_row;万一;结束循环;</code></pre><p>对于从较大数据集检索的每一行，数据库执行以下操作：</p>
                                 <ol type="a">
                                    <li>
                                       <p>将相同的散列函数应用于连接列或列以计算散列表中相关插槽的编号。</p>
                                       <p>例如，为了探测部门ID <code class="codeph">30</code>的哈希表，数据库将哈希函数应用于<code class="codeph">30</code> ，其产生哈希值<code class="codeph">4</code> 。
                                       </p>
                                    </li>
                                    <li>
                                       <p>探测哈希表以确定插槽中是否存在行。</p>
                                       <p>如果不存在任何行，则数据库将处理较大数据集中的下一行。如果存在行，则数据库继续执行下一步。</p>
                                    </li>
                                    <li>
                                       <p>检查连接列是否匹配。如果发生匹配，则数据库报告行或将它们传递给计划中的下一步，然后处理较大数据集中的下一行。</p>
                                       <p>如果哈希表槽中存在多行，则数据库将遍历链的行列表，检查每一行。例如，如果部门<code class="codeph">30</code>哈希到插槽<code class="codeph">4</code> ，则数据库检查每一行，直到找到<code class="codeph">30</code> 。
                                       </p>
                                    </li>
                                 </ol>
                              </li>
                           </ol>
                           <div class="example" id="GUID-9EE5CD4C-B90C-4E61-83DC-BD585D79635C__GUID-E62BDD95-89A0-43A4-91C6-526CA259F83A">
                              <p class="titleinexample">例9-4哈希联接</p>
                              <p>应用程序查询<code class="codeph">oe.orders</code>和<code class="codeph">oe.order_items</code>表，并加入<code class="codeph">order_id</code>列。
                              </p><pre class="pre codeblock"><code>SELECT o.customer_id，l.unit_price * l.quantity FROM orders o，order_items l WHERE l.order_id = o.order_id;</code></pre><p>执行计划如下：</p><pre class="pre codeblock"><code>-------------------------------------------------- ------------------------ | Id |操作|名称|行|字节|成本（％CPU）| -------------------------------------------------- ------------------------ | 0 |选择声明| | 665 | 13300 | 8（25）| | * 1 | HASH JOIN | | 665 | 13300 | 8（25）| | 2 |表访问完全|订单| 105 | 840 | 4（25）| | 3 |表访问完全| ORDER_ITEMS | 665 | 7980 | 4（25）| -------------------------------------------------- ------------------------谓词信息（由操作ID标识）：----------------- ---------------------------------- 1  -  access（“L”。“ORDER_ID”=“O”。 “ORDER_ID”）</code></pre><p>由于<code class="codeph">orders</code>表相对于<code class="codeph">order_items</code>表较小（大于6倍），因此数据库会对<code class="codeph">orders</code>哈希处理。在散列连接中，构建表的数据集始终首先出现在操作列表中（步骤2）。在步骤3中，数据库稍后执行较大<code class="codeph">order_items</code>的完整扫描，探测每行的哈希表。
                              </p>
                           </div>
                           <!-- class="example" -->
                        </div>
                        <div>
                           <div class="familylinks">
                              <div class="parentlink">
                                 <p><strong>父主题：</strong> <a href="joins.html#GUID-5A801568-F4E2-45C5-940B-55D23761BFD7" title="散列算法采用一组输入并应用确定性散列函数来生成介于1和n之间的散列值，其中n是散列表的大小。">哈希加入如何工作</a></p>
                              </div>
                           </div>
                        </div>
                        
                     </div>
                  </div><a id="TGSQL95238"></a><div class="props_rev_3"><a id="GUID-0F295C4C-FF10-4BE8-BB0C-C8CD78545277" name="GUID-0F295C4C-FF10-4BE8-BB0C-C8CD78545277"></a><h5 id="TGSQL-GUID-0F295C4C-FF10-4BE8-BB0C-C8CD78545277" class="sect5"><span class="enumeration_section">9.2.2.3</span>当Hash表不适合PGA时，散列连接如何工作</h5>
                     <div>
                        <p>当哈希表不完全适合PGA时，数据库必须使用不同的技术。在这种情况下，数据库使用临时空间来保存哈希表的部分（称为分区），有时还使用较大表的一部分来探测哈希表。</p>
                        <p>基本流程如下：</p>
                        <ol>
                           <li>
                              <p>数据库执行较小数据集的完整扫描，然后在PGA和磁盘上构建一个散列桶阵列。</p>
                              <p>当PGA哈希区域填满时，数据库会找到哈希表中的最大分区并将其写入磁盘上的临时空间。数据库存储属于磁盘上此磁盘分区的任何新行，以及PGA中的所有其他行。因此，散列表的一部分位于内存中，而部分散列表位于磁盘上。</p>
                           </li>
                           <li>
                              <p>数据库在读取其他数据集时进行第一次传递。</p>
                              <p>对于每一行，数据库执行以下操作：</p>
                              <ol type="a">
                                 <li>
                                    <p>将相同的哈希函数应用于连接列或列以计算相关哈希桶的数量。</p>
                                 </li>
                                 <li>
                                    <p>探测哈希表以确定<span class="italic">内存中存储</span>桶<span class="italic">中</span>是否存在行。
                                    </p>
                                    <p>如果散列值指向内存中的一行，则数据库完成连接并返回该行。但是，如果该值指向磁盘上的散列分区，则数据库将此行存储在临时表空间中，使用与原始数据集相同的分区方案。</p>
                                 </li>
                              </ol>
                           </li>
                           <li>
                              <p>数据库逐个读取每个磁盘上的临时分区</p>
                           </li>
                           <li>
                              <p>数据库将每个分区行连接到相应的磁盘上临时分区中的行。</p>
                           </li>
                        </ol>
                     </div>
                     <div>
                        <div class="familylinks">
                           <div class="parentlink">
                              <p><strong>父主题：</strong> <a href="joins.html#GUID-91E61BDC-E5F2-49FA-99AE-DD88A2FBB4FB" title="数据库使用散列连接来连接更大的数据集。">哈希联接</a></p>
                           </div>
                        </div>
                     </div>
                     
                  </div><a id="TGSQL94689"></a><div class="props_rev_3"><a id="GUID-E8076180-ABDD-47F4-B6CB-DDDB6887B131" name="GUID-E8076180-ABDD-47F4-B6CB-DDDB6887B131"></a><h5 id="TGSQL-GUID-E8076180-ABDD-47F4-B6CB-DDDB6887B131" class="sect5"><span class="enumeration_section">9.2.2.4</span>散列连接控件</h5>
                     <div>
                        <p><code class="codeph">USE_HASH</code>提示指示优化器在将两个表连接在一起时使用散列连接。
                        </p>
                     </div>
                     <div>
                        <div class="infoboxnotealso" id="GUID-E8076180-ABDD-47F4-B6CB-DDDB6887B131__GUID-EDCF636C-965A-4CDC-895A-F364D8AEC8FD">
                           <p class="notep1">也可以看看：</p>
                           <ul style="list-style-type:disc">
                              <li>
                                 <p><span class="q">“ <a href="influencing-the-optimizer.html#GUID-5976D09A-257A-49F3-94E0-247B1247270A" title="在某些情况下，您可以在SQL语句中指定连接顺序提示，以便它不会访问对结果没有影响的行。">加入订单提示指南</a> ”</span></p>
                              </li>
                              <li>
                                 <p><a href="https://www.oracle.com/pls/topic/lookup?ctx=en/database/oracle/oracle-database/19/tgsql&amp;id=SQLRF-GUID-FA1147B3-BCAA-41F9-B6A2-8DEDABF1C021" target="_blank"><span><cite>Oracle Database SQL语言参考</cite></span></a>了解<code class="codeph">USE_HASH</code></p>
                              </li>
                           </ul>
                        </div>
                        <div class="familylinks">
                           <div class="parentlink">
                              <p><strong>父主题：</strong> <a href="joins.html#GUID-91E61BDC-E5F2-49FA-99AE-DD88A2FBB4FB" title="数据库使用散列连接来连接更大的数据集。">哈希联接</a></p>
                           </div>
                        </div>
                     </div>
                     
                  </div>
               </div><a id="TGSQL94690"></a><div class="props_rev_3"><a id="GUID-5FCD34FE-ED04-4AB2-BC90-9752FED94F4F" name="GUID-5FCD34FE-ED04-4AB2-BC90-9752FED94F4F"></a><h4 id="TGSQL-GUID-5FCD34FE-ED04-4AB2-BC90-9752FED94F4F" class="sect4"><span class="enumeration_section">9.2.3</span>排序合并连接</h4>
                  <div>
                     <p>排序合并连接是嵌套循环连接的变体。</p>
                     <p>如果连接中的两个数据集尚未排序，则数据库会对它们进行排序。这些是<code class="codeph">SORT JOIN</code>操作。对于第一个数据集中的每一行，数据库探测第二个数据集以匹配行并将它们连接起来，并将其起始位置基于上一次迭代中的匹配。这是<code class="codeph">MERGE JOIN</code>操作。
                     </p>
                     <div class="figure" id="GUID-5FCD34FE-ED04-4AB2-BC90-9752FED94F4F__GUID-CD346B70-7D5C-47E9-AD77-13203BBEDD12">
                        <p class="titleinfigure">图9-6排序合并连接</p><img src="img/tgsql_vm_081.png" alt="下面是图9-6的描述" title="下面是图9-6的描述" longdesc="img_text/tgsql_vm_081.html"><br><a href="img_text/tgsql_vm_081.html">“图9-6排序合并连接”的描述</a></div>
                     <!-- class="figure" -->
                     <p>本节包含以下主题：</p>
                  </div>
                  <div>
                     <ul class="ullinks">
                        <li class="ulchildlink"><a href="joins.html#GUID-3F935776-FE28-4350-9FA4-E6B47489156E">当优化器考虑排序合并连接时</a><br>散列连接需要一个散列表和一个此表的探测，而排序合并连接需要两种排序。
                        </li>
                        <li class="ulchildlink"><a href="joins.html#GUID-D96D76E3-3DA4-4354-9617-7DE8AFE00227">Sort Merge如何加入工作</a><br>与嵌套循环连接一样，排序合并连接会读取两个数据集，但在它们尚未排序时对它们进行排序。对于第一个数据集中的每一行，数据库在第二个数据集中查找起始行，然后读取第二个数据集，直到找到不匹配的行。
                        </li>
                        <li class="ulchildlink"><a href="joins.html#GUID-F6BCB3C1-6EE6-4A84-8B3D-659CAF9CBF4F">排序合并连接控件</a><br><code class="codeph">USE_MERGE</code>提示指示优化器使用排序合并连接。
                        </li>
                     </ul>
                     <div class="familylinks">
                        <div class="parentlink">
                           <p><strong>父主题：</strong> <a href="joins.html#GUID-54F957FB-3568-499A-BCD2-B242BFFF913D" title="连接方法是连接两个行源的机制。">加入方法</a></p>
                        </div>
                     </div>
                  </div>
                  <a id="TGSQL94691"></a><div class="props_rev_3"><a id="GUID-3F935776-FE28-4350-9FA4-E6B47489156E" name="GUID-3F935776-FE28-4350-9FA4-E6B47489156E"></a><h5 id="TGSQL-GUID-3F935776-FE28-4350-9FA4-E6B47489156E" class="sect5"><span class="enumeration_section">9.2.3.1</span>当优化器考虑对合并连接进行排序时</h5>
                     <div>
                        <p>散列连接需要一个散列表和一个此表的探测，而排序合并连接需要两种排序。</p>
                        <p>当满足以下任一条件时，优化器可以选择散列连接上的排序合并连接来连接大量数据：</p>
                        <ul style="list-style-type:disc">
                           <li>
                              <p>两个表之间的连接条件不是等值连接，即使用不等式条件，例如<code class="codeph">&lt;</code> ， <code class="codeph">&lt;=</code> ， <code class="codeph">&gt;</code>或<code class="codeph">&gt;=</code> 。
                              </p>
                              <p>与排序合并相比，散列连接需要相等的条件。</p>
                           </li>
                           <li>
                              <p>由于其他操作需要排序，优化器发现使用排序合并更便宜。</p>
                              <p>如果存在索引，则数据库可以避免对第一个数据集进行排序。但是，无论索引如何，数据库始终会对第二个数据集进行排序。</p>
                           </li>
                        </ul>
                        <p>与嵌套循环连接相比，排序合并具有与散列连接相同的优点：数据库访问PGA中的行而不是SGA，从而通过避免重复锁存和读取数据库缓冲区高速缓存中的块来减少逻辑I / O.通常，散列连接比排序合并连接执行得更好，因为排序很昂贵。但是，排序合并连接与散列连接相比具有以下优点：</p>
                        <ul style="list-style-type:disc">
                           <li>
                              <p>在初始排序之后，优化合并阶段，从而更快地生成输出行。</p>
                           </li>
                           <li>
                              <p>当哈希表不完全适合内存时，排序合并比散列连接更具成本效益。</p>
                              <p>内存不足的散列连接需要将散列表和其他数据集复制到磁盘。在这种情况下，数据库可能必须多次从磁盘读取。在排序合并中，如果内存无法保存这两个数据集，则数据库会将它们都写入磁盘，但每次读取数据集的次数不会超过一次。</p>
                           </li>
                        </ul>
                     </div>
                     <div>
                        <div class="familylinks">
                           <div class="parentlink">
                              <p><strong>父主题：</strong> <a href="joins.html#GUID-5FCD34FE-ED04-4AB2-BC90-9752FED94F4F" title="排序合并连接是嵌套循环连接的变体。">对合并连接进行排序</a></p>
                           </div>
                        </div>
                     </div>
                     
                  </div><a id="TGSQL95310"></a><a id="TGSQL95311"></a><a id="TGSQL95309"></a><div class="props_rev_3"><a id="GUID-D96D76E3-3DA4-4354-9617-7DE8AFE00227" name="GUID-D96D76E3-3DA4-4354-9617-7DE8AFE00227"></a><h5 id="TGSQL-GUID-D96D76E3-3DA4-4354-9617-7DE8AFE00227" class="sect5"><span class="enumeration_section">9.2.3.2</span>排序合并连接的工作原理</h5>
                     <div>
                        <p>与嵌套循环连接一样，排序合并连接会读取两个数据集，但在它们尚未排序时对它们进行排序。对于第一个数据集中的每一行，数据库在第二个数据集中查找起始行，然后读取第二个数据集，直到找到不匹配的行。</p>
                        <p>在伪代码中，排序合并的高级算法可能如下所示：</p><pre class="pre codeblock"><code>READ data_set_1 SORT BY JOIN KEY to temp_ds1 READ data_set_2 SORT BY JOIN KEY TO temp_ds2 READ ds1_row FROM temp_ds1 READ ds2_row FROM temp_ds2 WHILE NOT eof ON temp_ds1，temp_ds2 LOOP IF（temp_ds1.key = temp_ds2.key）OUTPUT JOIN ds1_row，ds2_row ELSIF（temp_ds1 .key &lt;= temp_ds2.key）读取ds1_row FROM temp_ds1 ELSIF（temp_ds1.key =&gt; temp_ds2.key）读取ds2_row FROM temp_ds2 END LOOP</code></pre><p>例如，下表显示了两个数据集中的排序值： <code class="codeph">temp_ds1</code>和<code class="codeph">temp_ds2</code> 。
                        </p>
                        <div class="tblformal" id="GUID-D96D76E3-3DA4-4354-9617-7DE8AFE00227__GUID-9E542AC2-F6E6-4779-A47F-4C4335E341C9">
                           <p class="titleintable">表9-3排序数据集</p>
                           <table cellpadding="4" cellspacing="0" class="Formal" title="排序数据集" border="1" summary="The column temp_ds1 contains values 10, 20, 30, 40, 50, 60, and 70. The column temp_ds2 contains values 20, 20, 40, 40, 40, 40, 40, 60, 70, and 70." frame="hsides" rules="rows">
                              <thead>
                                 <tr align="left" valign="top">
                                    <th align="left" valign="bottom" width="20%" id="d49855e4345">temp_ds1</th>
                                    <th align="left" valign="bottom" width="20%" id="d49855e4347">temp_ds2</th>
                                 </tr>
                              </thead>
                              <tbody>
                                 <tr align="left" valign="top">
                                    <td align="left" valign="top" width="20%" id="d49855e4351" headers="d49855e4345 ">10</td>
                                    <td align="left" valign="top" width="20%" headers="d49855e4351 d49855e4347 ">20</td>
                                 </tr>
                                 <tr align="left" valign="top">
                                    <td align="left" valign="top" width="20%" id="d49855e4356" headers="d49855e4345 ">20</td>
                                    <td align="left" valign="top" width="20%" headers="d49855e4356 d49855e4347 ">20</td>
                                 </tr>
                                 <tr align="left" valign="top">
                                    <td align="left" valign="top" width="20%" id="d49855e4361" headers="d49855e4345 ">三十</td>
                                    <td align="left" valign="top" width="20%" headers="d49855e4361 d49855e4347 ">40</td>
                                 </tr>
                                 <tr align="left" valign="top">
                                    <td align="left" valign="top" width="20%" id="d49855e4366" headers="d49855e4345 ">40</td>
                                    <td align="left" valign="top" width="20%" headers="d49855e4366 d49855e4347 ">40</td>
                                 </tr>
                                 <tr align="left" valign="top">
                                    <td align="left" valign="top" width="20%" id="d49855e4371" headers="d49855e4345 ">50</td>
                                    <td align="left" valign="top" width="20%" headers="d49855e4371 d49855e4347 ">40</td>
                                 </tr>
                                 <tr align="left" valign="top">
                                    <td align="left" valign="top" width="20%" id="d49855e4376" headers="d49855e4345 ">60</td>
                                    <td align="left" valign="top" width="20%" headers="d49855e4376 d49855e4347 ">40</td>
                                 </tr>
                                 <tr align="left" valign="top">
                                    <td align="left" valign="top" width="20%" id="d49855e4381" headers="d49855e4345 ">70</td>
                                    <td align="left" valign="top" width="20%" headers="d49855e4381 d49855e4347 ">40</td>
                                 </tr>
                                 <tr align="left" valign="top">
                                    <td align="left" valign="top" width="20%" id="d49855e4386" headers="d49855e4345 ">。</td>
                                    <td align="left" valign="top" width="20%" headers="d49855e4386 d49855e4347 ">60</td>
                                 </tr>
                                 <tr align="left" valign="top">
                                    <td align="left" valign="top" width="20%" id="d49855e4391" headers="d49855e4345 ">。</td>
                                    <td align="left" valign="top" width="20%" headers="d49855e4391 d49855e4347 ">70</td>
                                 </tr>
                                 <tr align="left" valign="top">
                                    <td align="left" valign="top" width="20%" id="d49855e4396" headers="d49855e4345 ">。</td>
                                    <td align="left" valign="top" width="20%" headers="d49855e4396 d49855e4347 ">70</td>
                                 </tr>
                              </tbody>
                           </table>
                        </div>
                        <!-- class="inftblhruleinformal" -->
                        <p>如在下表中所示，该数据库通过读取开始<code class="codeph">10</code>在<code class="codeph">temp_ds1</code> ，然后读取在该第一值<code class="codeph">temp_ds2</code> 。因为<code class="codeph">20</code>在<code class="codeph">temp_ds2</code>高于<code class="codeph">10</code>在<code class="codeph">temp_ds1</code> ，数据库停止读取<code class="codeph">temp_ds2</code> 。
                        </p>
                        <div class="tblformal" id="GUID-D96D76E3-3DA4-4354-9617-7DE8AFE00227__GUID-F04E9A1A-AF41-48D2-ADB8-69F07269D163">
                           <p class="titleintable">表9-4 temp_ds1中从10开始</p>
                           <table cellpadding="4" cellspacing="0" class="Formal" title="在temp_ds1中从10开始" border="1" summary="The column temp_ds1 contains values 10, 20, 30, 40, 50, 60, and 70. The column temp_ds2 contains values 20, 20, 40, 40, 40, 40, 40, 60, 70, and 70. The database starts at 10 in temp_ds1, and at 20 in temp_ds2." frame="hsides" rules="rows">
                              <thead>
                                 <tr align="left" valign="top">
                                    <th align="left" valign="bottom" width="20%" id="d49855e4438">temp_ds1</th>
                                    <th align="left" valign="bottom" width="20%" id="d49855e4440">temp_ds2</th>
                                    <th align="left" valign="bottom" width="20%" id="d49855e4442">行动</th>
                                 </tr>
                              </thead>
                              <tbody>
                                 <tr align="left" valign="top">
                                    <td align="left" valign="top" width="20%" id="d49855e4446" headers="d49855e4438 ">10 [从这里开始]</td>
                                    <td align="left" valign="top" width="20%" headers="d49855e4446 d49855e4440 ">20 [从这里开始] [在这里停止]</td>
                                    <td align="left" valign="top" width="20%" headers="d49855e4446 d49855e4442 ">temp_ds2中的20在temp_ds1中大于10。停止。从temp_ds1中的下一行开始。</td>
                                 </tr>
                                 <tr align="left" valign="top">
                                    <td align="left" valign="top" width="20%" id="d49855e4453" headers="d49855e4438 ">20</td>
                                    <td align="left" valign="top" width="20%" headers="d49855e4453 d49855e4440 ">20</td>
                                    <td align="left" valign="top" width="20%" headers="d49855e4453 d49855e4442 "> </td>
                                 </tr>
                                 <tr align="left" valign="top">
                                    <td align="left" valign="top" width="20%" id="d49855e4459" headers="d49855e4438 ">三十</td>
                                    <td align="left" valign="top" width="20%" headers="d49855e4459 d49855e4440 ">40</td>
                                    <td align="left" valign="top" width="20%" headers="d49855e4459 d49855e4442 "> </td>
                                 </tr>
                                 <tr align="left" valign="top">
                                    <td align="left" valign="top" width="20%" id="d49855e4465" headers="d49855e4438 ">40</td>
                                    <td align="left" valign="top" width="20%" headers="d49855e4465 d49855e4440 ">40</td>
                                    <td align="left" valign="top" width="20%" headers="d49855e4465 d49855e4442 "> </td>
                                 </tr>
                                 <tr align="left" valign="top">
                                    <td align="left" valign="top" width="20%" id="d49855e4471" headers="d49855e4438 ">50</td>
                                    <td align="left" valign="top" width="20%" headers="d49855e4471 d49855e4440 ">40</td>
                                    <td align="left" valign="top" width="20%" headers="d49855e4471 d49855e4442 "> </td>
                                 </tr>
                                 <tr align="left" valign="top">
                                    <td align="left" valign="top" width="20%" id="d49855e4477" headers="d49855e4438 ">60</td>
                                    <td align="left" valign="top" width="20%" headers="d49855e4477 d49855e4440 ">40</td>
                                    <td align="left" valign="top" width="20%" headers="d49855e4477 d49855e4442 "> </td>
                                 </tr>
                                 <tr align="left" valign="top">
                                    <td align="left" valign="top" width="20%" id="d49855e4483" headers="d49855e4438 ">70</td>
                                    <td align="left" valign="top" width="20%" headers="d49855e4483 d49855e4440 ">40</td>
                                    <td align="left" valign="top" width="20%" headers="d49855e4483 d49855e4442 "> </td>
                                 </tr>
                                 <tr align="left" valign="top">
                                    <td align="left" valign="top" width="20%" id="d49855e4489" headers="d49855e4438 ">。</td>
                                    <td align="left" valign="top" width="20%" headers="d49855e4489 d49855e4440 ">60</td>
                                    <td align="left" valign="top" width="20%" headers="d49855e4489 d49855e4442 "> </td>
                                 </tr>
                                 <tr align="left" valign="top">
                                    <td align="left" valign="top" width="20%" id="d49855e4495" headers="d49855e4438 ">。</td>
                                    <td align="left" valign="top" width="20%" headers="d49855e4495 d49855e4440 ">70</td>
                                    <td align="left" valign="top" width="20%" headers="d49855e4495 d49855e4442 "> </td>
                                 </tr>
                                 <tr align="left" valign="top">
                                    <td align="left" valign="top" width="20%" id="d49855e4501" headers="d49855e4438 ">。</td>
                                    <td align="left" valign="top" width="20%" headers="d49855e4501 d49855e4440 ">70</td>
                                    <td align="left" valign="top" width="20%" headers="d49855e4501 d49855e4442 "> </td>
                                 </tr>
                              </tbody>
                           </table>
                        </div>
                        <!-- class="inftblhruleinformal" -->
                        <p>数据库继续执行<code class="codeph">temp_ds1</code>的下一个值，即<code class="codeph">20</code> 。数据库继续执行<code class="codeph">temp_ds2</code> ，如下表所示。
                        </p>
                        <div class="tblformal" id="GUID-D96D76E3-3DA4-4354-9617-7DE8AFE00227__GUID-123424C4-04EA-495B-9F26-3A11D9F706BD">
                           <p class="titleintable">表9-5 temp_ds1中从20开始</p>
                           <table cellpadding="4" cellspacing="0" class="Formal" title="从temp_ds1的20开始" border="1" summary="The column temp_ds1 contains values 10, 20, 30, 40, 50, 60, and 70. The column temp_ds2 contains values 20, 20, 40, 40, 40, 40, 40, 60, 70, and 70. The database starts at 20 in temp_ds1, and at 20 in temp_ds2." frame="hsides" rules="rows">
                              <thead>
                                 <tr align="left" valign="top">
                                    <th align="left" valign="bottom" width="20%" id="d49855e4528">temp_ds1</th>
                                    <th align="left" valign="bottom" width="20%" id="d49855e4530">temp_ds2</th>
                                    <th align="left" valign="bottom" width="20%" id="d49855e4532">行动</th>
                                 </tr>
                              </thead>
                              <tbody>
                                 <tr align="left" valign="top">
                                    <td align="left" valign="top" width="20%" id="d49855e4536" headers="d49855e4528 ">10</td>
                                    <td align="left" valign="top" width="20%" headers="d49855e4536 d49855e4530 ">20 [从这里开始]</td>
                                    <td align="left" valign="top" width="20%" headers="d49855e4536 d49855e4532 ">比赛。继续执行temp_ds2中的下一个值。</td>
                                 </tr>
                                 <tr align="left" valign="top">
                                    <td align="left" valign="top" width="20%" id="d49855e4543" headers="d49855e4528 ">20 [从这里开始]</td>
                                    <td align="left" valign="top" width="20%" headers="d49855e4543 d49855e4530 ">20</td>
                                    <td align="left" valign="top" width="20%" headers="d49855e4543 d49855e4532 ">比赛。继续执行temp_ds2中的下一个值。</td>
                                 </tr>
                                 <tr align="left" valign="top">
                                    <td align="left" valign="top" width="20%" id="d49855e4550" headers="d49855e4528 ">三十</td>
                                    <td align="left" valign="top" width="20%" headers="d49855e4550 d49855e4530 ">40 [到此处]</td>
                                    <td align="left" valign="top" width="20%" headers="d49855e4550 d49855e4532 ">temp_ds2中的40在temp_ds1中高于20。停止。从temp_ds1中的下一行开始。</td>
                                 </tr>
                                 <tr align="left" valign="top">
                                    <td align="left" valign="top" width="20%" id="d49855e4557" headers="d49855e4528 ">40</td>
                                    <td align="left" valign="top" width="20%" headers="d49855e4557 d49855e4530 ">40</td>
                                    <td align="left" valign="top" width="20%" headers="d49855e4557 d49855e4532 "> </td>
                                 </tr>
                                 <tr align="left" valign="top">
                                    <td align="left" valign="top" width="20%" id="d49855e4563" headers="d49855e4528 ">50</td>
                                    <td align="left" valign="top" width="20%" headers="d49855e4563 d49855e4530 ">40</td>
                                    <td align="left" valign="top" width="20%" headers="d49855e4563 d49855e4532 "> </td>
                                 </tr>
                                 <tr align="left" valign="top">
                                    <td align="left" valign="top" width="20%" id="d49855e4569" headers="d49855e4528 ">60</td>
                                    <td align="left" valign="top" width="20%" headers="d49855e4569 d49855e4530 ">40</td>
                                    <td align="left" valign="top" width="20%" headers="d49855e4569 d49855e4532 "> </td>
                                 </tr>
                                 <tr align="left" valign="top">
                                    <td align="left" valign="top" width="20%" id="d49855e4575" headers="d49855e4528 ">70</td>
                                    <td align="left" valign="top" width="20%" headers="d49855e4575 d49855e4530 ">40</td>
                                    <td align="left" valign="top" width="20%" headers="d49855e4575 d49855e4532 "> </td>
                                 </tr>
                                 <tr align="left" valign="top">
                                    <td align="left" valign="top" width="20%" id="d49855e4581" headers="d49855e4528 ">。</td>
                                    <td align="left" valign="top" width="20%" headers="d49855e4581 d49855e4530 ">60</td>
                                    <td align="left" valign="top" width="20%" headers="d49855e4581 d49855e4532 "> </td>
                                 </tr>
                                 <tr align="left" valign="top">
                                    <td align="left" valign="top" width="20%" id="d49855e4587" headers="d49855e4528 ">。</td>
                                    <td align="left" valign="top" width="20%" headers="d49855e4587 d49855e4530 ">70</td>
                                    <td align="left" valign="top" width="20%" headers="d49855e4587 d49855e4532 "> </td>
                                 </tr>
                                 <tr align="left" valign="top">
                                    <td align="left" valign="top" width="20%" id="d49855e4593" headers="d49855e4528 ">。</td>
                                    <td align="left" valign="top" width="20%" headers="d49855e4593 d49855e4530 ">70</td>
                                    <td align="left" valign="top" width="20%" headers="d49855e4593 d49855e4532 "> </td>
                                 </tr>
                              </tbody>
                           </table>
                        </div>
                        <!-- class="inftblhruleinformal" -->
                        <p>数据库进入<code class="codeph">temp_ds1</code>的下一行，即<code class="codeph">30</code> 。数据库从其最后一次匹配的编号开始，即<code class="codeph">20</code> ，然后通过<code class="codeph">temp_ds2</code>查找匹配，如下表所示。
                        </p>
                        <div class="tblformal" id="GUID-D96D76E3-3DA4-4354-9617-7DE8AFE00227__GUID-3FC1DA9C-FE2F-44BA-AEA3-26BC5C8F7685">
                           <p class="titleintable">表9-6 temp_ds1中从30开始</p>
                           <table cellpadding="4" cellspacing="0" class="Formal" title="在temp_ds1中从30开始" border="1" summary="The column temp_ds1 contains values 10, 20, 30, 40, 50, 60, and 70. The column temp_ds2 contains values 20, 20, 40, 40, 40, 40, 40, 60, 70, and 70. The database starts at 30 in temp_ds1, and at 20 in temp_ds2." frame="hsides" rules="rows">
                              <thead>
                                 <tr align="left" valign="top">
                                    <th align="left" valign="bottom" width="20%" id="d49855e4623">temp_ds1</th>
                                    <th align="left" valign="bottom" width="20%" id="d49855e4625">temp_ds2</th>
                                    <th align="left" valign="bottom" width="20%" id="d49855e4627">行动</th>
                                 </tr>
                              </thead>
                              <tbody>
                                 <tr align="left" valign="top">
                                    <td align="left" valign="top" width="20%" id="d49855e4631" headers="d49855e4623 ">10</td>
                                    <td align="left" valign="top" width="20%" headers="d49855e4631 d49855e4625 ">20</td>
                                    <td align="left" valign="top" width="20%" headers="d49855e4631 d49855e4627 "> </td>
                                 </tr>
                                 <tr align="left" valign="top">
                                    <td align="left" valign="top" width="20%" id="d49855e4637" headers="d49855e4623 ">20</td>
                                    <td align="left" valign="top" width="20%" headers="d49855e4637 d49855e4625 ">20 [最后一场比赛开始]</td>
                                    <td align="left" valign="top" width="20%" headers="d49855e4637 d49855e4627 ">temp_ds1中的20在temp_ds1中小于30。继续执行temp_ds2中的下一个值。</td>
                                 </tr>
                                 <tr align="left" valign="top">
                                    <td align="left" valign="top" width="20%" id="d49855e4644" headers="d49855e4623 ">30 [从这里开始]</td>
                                    <td align="left" valign="top" width="20%" headers="d49855e4644 d49855e4625 ">40 [到此处]</td>
                                    <td align="left" valign="top" width="20%" headers="d49855e4644 d49855e4627 ">temp_ds2中的40在temp_ds1中大于30。停止。从temp_ds1中的下一行开始。</td>
                                 </tr>
                                 <tr align="left" valign="top">
                                    <td align="left" valign="top" width="20%" id="d49855e4651" headers="d49855e4623 ">40</td>
                                    <td align="left" valign="top" width="20%" headers="d49855e4651 d49855e4625 ">40</td>
                                    <td align="left" valign="top" width="20%" headers="d49855e4651 d49855e4627 "> </td>
                                 </tr>
                                 <tr align="left" valign="top">
                                    <td align="left" valign="top" width="20%" id="d49855e4657" headers="d49855e4623 ">50</td>
                                    <td align="left" valign="top" width="20%" headers="d49855e4657 d49855e4625 ">40</td>
                                    <td align="left" valign="top" width="20%" headers="d49855e4657 d49855e4627 "> </td>
                                 </tr>
                                 <tr align="left" valign="top">
                                    <td align="left" valign="top" width="20%" id="d49855e4663" headers="d49855e4623 ">60</td>
                                    <td align="left" valign="top" width="20%" headers="d49855e4663 d49855e4625 ">40</td>
                                    <td align="left" valign="top" width="20%" headers="d49855e4663 d49855e4627 "> </td>
                                 </tr>
                                 <tr align="left" valign="top">
                                    <td align="left" valign="top" width="20%" id="d49855e4669" headers="d49855e4623 ">70</td>
                                    <td align="left" valign="top" width="20%" headers="d49855e4669 d49855e4625 ">40</td>
                                    <td align="left" valign="top" width="20%" headers="d49855e4669 d49855e4627 "> </td>
                                 </tr>
                                 <tr align="left" valign="top">
                                    <td align="left" valign="top" width="20%" id="d49855e4675" headers="d49855e4623 ">。</td>
                                    <td align="left" valign="top" width="20%" headers="d49855e4675 d49855e4625 ">60</td>
                                    <td align="left" valign="top" width="20%" headers="d49855e4675 d49855e4627 "> </td>
                                 </tr>
                                 <tr align="left" valign="top">
                                    <td align="left" valign="top" width="20%" id="d49855e4681" headers="d49855e4623 ">。</td>
                                    <td align="left" valign="top" width="20%" headers="d49855e4681 d49855e4625 ">70</td>
                                    <td align="left" valign="top" width="20%" headers="d49855e4681 d49855e4627 "> </td>
                                 </tr>
                                 <tr align="left" valign="top">
                                    <td align="left" valign="top" width="20%" id="d49855e4687" headers="d49855e4623 ">。</td>
                                    <td align="left" valign="top" width="20%" headers="d49855e4687 d49855e4625 ">70</td>
                                    <td align="left" valign="top" width="20%" headers="d49855e4687 d49855e4627 "> </td>
                                 </tr>
                              </tbody>
                           </table>
                        </div>
                        <!-- class="inftblhruleinformal" -->
                        <p>数据库进入<code class="codeph">temp_ds1</code>的下一行，即<code class="codeph">40</code> 。如下表所示，数据库从<code class="codeph">temp_ds2</code>最后一次匹配的编号开始，该编号为<code class="codeph">20</code> ，然后通过<code class="codeph">temp_ds2</code>查找匹配项。
                        </p>
                        <div class="tblformal" id="GUID-D96D76E3-3DA4-4354-9617-7DE8AFE00227__GUID-332A4FD0-3DF9-4A69-8B95-28E59AFE13A2">
                           <p class="titleintable">表9-7在temp_ds1中从40开始</p>
                           <table cellpadding="4" cellspacing="0" class="Formal" title="在temp_ds1中从40开始" border="1" summary="The column temp_ds1 contains values 10, 20, 30, 40, 50, 60, and 70. The column temp_ds2 contains values 20, 20, 40, 40, 40, 40, 40, 60, 70, and 70. The database starts at 40 in temp_ds1, and at 20 in temp_ds2." frame="hsides" rules="rows">
                              <thead>
                                 <tr align="left" valign="top">
                                    <th align="left" valign="bottom" width="20%" id="d49855e4721">temp_ds1</th>
                                    <th align="left" valign="bottom" width="20%" id="d49855e4723">temp_ds2</th>
                                    <th align="left" valign="bottom" width="20%" id="d49855e4725">行动</th>
                                 </tr>
                              </thead>
                              <tbody>
                                 <tr align="left" valign="top">
                                    <td align="left" valign="top" width="20%" id="d49855e4729" headers="d49855e4721 ">10</td>
                                    <td align="left" valign="top" width="20%" headers="d49855e4729 d49855e4723 ">20</td>
                                    <td align="left" valign="top" width="20%" headers="d49855e4729 d49855e4725 "> </td>
                                 </tr>
                                 <tr align="left" valign="top">
                                    <td align="left" valign="top" width="20%" id="d49855e4735" headers="d49855e4721 ">20</td>
                                    <td align="left" valign="top" width="20%" headers="d49855e4735 d49855e4723 ">20 [最后一场比赛开始]</td>
                                    <td align="left" valign="top" width="20%" headers="d49855e4735 d49855e4725 ">temp_ds1中的20在temp_ds1中小于40。继续执行temp_ds2中的下一个值。</td>
                                 </tr>
                                 <tr align="left" valign="top">
                                    <td align="left" valign="top" width="20%" id="d49855e4742" headers="d49855e4721 ">三十</td>
                                    <td align="left" valign="top" width="20%" headers="d49855e4742 d49855e4723 ">40</td>
                                    <td align="left" valign="top" width="20%" headers="d49855e4742 d49855e4725 ">比赛。继续执行temp_ds2中的下一个值。</td>
                                 </tr>
                                 <tr align="left" valign="top">
                                    <td align="left" valign="top" width="20%" id="d49855e4749" headers="d49855e4721 ">40 [从这里开始]</td>
                                    <td align="left" valign="top" width="20%" headers="d49855e4749 d49855e4723 ">40</td>
                                    <td align="left" valign="top" width="20%" headers="d49855e4749 d49855e4725 ">比赛。继续执行temp_ds2中的下一个值。</td>
                                 </tr>
                                 <tr align="left" valign="top">
                                    <td align="left" valign="top" width="20%" id="d49855e4756" headers="d49855e4721 ">50</td>
                                    <td align="left" valign="top" width="20%" headers="d49855e4756 d49855e4723 ">40</td>
                                    <td align="left" valign="top" width="20%" headers="d49855e4756 d49855e4725 ">比赛。继续执行temp_ds2中的下一个值。</td>
                                 </tr>
                                 <tr align="left" valign="top">
                                    <td align="left" valign="top" width="20%" id="d49855e4763" headers="d49855e4721 ">60</td>
                                    <td align="left" valign="top" width="20%" headers="d49855e4763 d49855e4723 ">40</td>
                                    <td align="left" valign="top" width="20%" headers="d49855e4763 d49855e4725 ">比赛。继续执行temp_ds2中的下一个值。</td>
                                 </tr>
                                 <tr align="left" valign="top">
                                    <td align="left" valign="top" width="20%" id="d49855e4770" headers="d49855e4721 ">70</td>
                                    <td align="left" valign="top" width="20%" headers="d49855e4770 d49855e4723 ">40</td>
                                    <td align="left" valign="top" width="20%" headers="d49855e4770 d49855e4725 ">比赛。继续执行temp_ds2中的下一个值。</td>
                                 </tr>
                                 <tr align="left" valign="top">
                                    <td align="left" valign="top" width="20%" id="d49855e4777" headers="d49855e4721 ">。</td>
                                    <td align="left" valign="top" width="20%" headers="d49855e4777 d49855e4723 ">60 [到此处]</td>
                                    <td align="left" valign="top" width="20%" headers="d49855e4777 d49855e4725 ">temp_ds2中的60在temp_ds1中高于40。停止。从temp_ds1中的下一行开始。</td>
                                 </tr>
                                 <tr align="left" valign="top">
                                    <td align="left" valign="top" width="20%" id="d49855e4784" headers="d49855e4721 ">。</td>
                                    <td align="left" valign="top" width="20%" headers="d49855e4784 d49855e4723 ">70</td>
                                    <td align="left" valign="top" width="20%" headers="d49855e4784 d49855e4725 "> </td>
                                 </tr>
                                 <tr align="left" valign="top">
                                    <td align="left" valign="top" width="20%" id="d49855e4790" headers="d49855e4721 ">。</td>
                                    <td align="left" valign="top" width="20%" headers="d49855e4790 d49855e4723 ">70</td>
                                    <td align="left" valign="top" width="20%" headers="d49855e4790 d49855e4725 "> </td>
                                 </tr>
                              </tbody>
                           </table>
                        </div>
                        <!-- class="inftblhruleinformal" -->
                        <p>数据库以这种方式继续，直到它匹配<code class="codeph">temp_ds2</code>的最后<code class="codeph">70</code> 。此方案演示，数据库，因为它通过读取<code class="codeph">temp_ds1</code> ，并不需要阅读每一行<code class="codeph">temp_ds2</code> 。这是嵌套循环连接的优势。
                        </p>
                        <div class="example" id="GUID-D96D76E3-3DA4-4354-9617-7DE8AFE00227__GUID-1CDCD0C9-4355-4238-91DB-F84D0720076C">
                           <p class="titleinexample">示例9-5使用索引对合并连接进行排序</p>
                           <p>以下查询连接<code class="codeph">department_id</code>列上的<code class="codeph">employees</code>和<code class="codeph">departments</code>表，按如下方式对<code class="codeph">department_id</code>上的行进行排序：</p><pre class="pre codeblock"><code>SELECT e.employee_id，e.last_name，e.first_name，e.department_id，d.department_name FROM employees e，departments d WHERE e.department_id = d.department_id ORDER BY department_id;</code></pre><p><code class="codeph">DBMS_XPLAN.DISPLAY_CURSOR</code>的查询显示该计划使用排序合并连接：</p><pre class="pre codeblock"><code>-------------------------------------------------- ------------------------------ | Id |操作|名称|行|字节|成本（％CPU）|时间| -------------------------------------------------- ------------------------------ | 0 |选择声明| | | | 5（100）| | | 1 | MERGE JOIN | | 106 | 4028 | 5（20）| 00:00:01 | | 2 |按INDEX ROWID表的访问权限|部门| 27 | 432 | 2（0）| 00:00:01 | | 3 | INDEX全扫描| DEPT_ID_PK | 27 | | 1（0）| 00:00:01 | | * 4 | SORT JOIN | | 107 | 2354 | 3（34）| 00:00:01 | | 5 |表访问完全|员工| 107 | 2354 | 2（0）| 00:00:01 | -------------------------------------------------- ------------------------------谓词信息（由操作ID标识）：----------- ---------------------------------------- 4  - 访问（“E”。“DEPARTMENT_ID “=”D“。”DEPARTMENT_ID“）过滤器（”E“。”DEPARTMENT_ID“=”D“。”DEPARTMENT_ID“）</code></pre><p>这两个数据集是<code class="codeph">departments</code>表和<code class="codeph">employees</code>表。由于索引按<code class="codeph">department_id</code>对<code class="codeph">departments</code>表进行排序，因此数据库可以读取此索引并避免排序（步骤3）。数据库只需要对<code class="codeph">employees</code>表进行排序（步骤4），这是CPU占用最多的操作。
                           </p>
                        </div>
                        <!-- class="example" -->
                        <div class="example" id="GUID-D96D76E3-3DA4-4354-9617-7DE8AFE00227__GUID-712E8248-5334-4494-857A-0431E1DCABD6">
                           <p class="titleinexample">示例9-6在没有索引的情况下排序合并连接</p>
                           <p>您可以加入<code class="codeph">department_id</code>列上的<code class="codeph">employees</code>和<code class="codeph">departments</code>表，按如下方式对<code class="codeph">department_id</code>上的行进行排序。在此示例中，您指定<code class="codeph">NO_INDEX</code>和<code class="codeph">USE_MERGE</code>以强制优化器选择排序合并：</p><pre class="pre codeblock"><code>SELECT / * + USE_MERGE（de）NO_INDEX（d）* / e.employee_id，e.last_name，e.first_name，e.department_id，d.department_name FROM employees e，departments d WHERE e.department_id = d.department_id ORDER BY department_id ;</code></pre><p><code class="codeph">DBMS_XPLAN.DISPLAY_CURSOR</code>的查询显示该计划使用排序合并连接：</p><pre class="pre codeblock"><code>-------------------------------------------------- ------------------------------ | ID |操作|名称|行|字节|成本（％CPU）|时间| -------------------------------------------------- ------------------------------ | 0 |选择声明| | | | 6（100）| | | 1 | MERGE JOIN | | 106 | 9540 | 6（34）| 00：00：01 | | 2 | SORT JOIN | | 27 | 567 | 3（34）| 00：00：01 | | 3 |表访问完全|部门| 27 | 567 | 2（0）| 00：00：01 | | * 4 | SORT JOIN | | 107 | 7383 | 3（34）| 00：00：01 | | 5 |表访问完全|员工| 107 | 7383 | 2（0）| 00：00：01 | -------------------------------------------------- ------------------------------谓词信息（由操作ID标识）：----------- ---------------------------------------- 4  - 访问（“E”。“DEPARTMENT_ID “=”D“。”DEPARTMENT_ID“）过滤器（”E“。”DEPARTMENT_ID“=”D“。”DEPARTMENT_ID“）</code></pre><p>由于忽略了<code class="codeph">departments.department_id</code>索引，优化器会执行排序，这会将步骤2和步骤3的组合成本增加67％（从<code class="codeph">3</code>到<code class="codeph">5</code> ）。
                           </p>
                        </div>
                        <!-- class="example" -->
                     </div>
                     <div>
                        <div class="familylinks">
                           <div class="parentlink">
                              <p><strong>父主题：</strong> <a href="joins.html#GUID-5FCD34FE-ED04-4AB2-BC90-9752FED94F4F" title="排序合并连接是嵌套循环连接的变体。">对合并连接进行排序</a></p>
                           </div>
                        </div>
                     </div>
                     
                  </div><a id="TGSQL94692"></a><div class="props_rev_3"><a id="GUID-F6BCB3C1-6EE6-4A84-8B3D-659CAF9CBF4F" name="GUID-F6BCB3C1-6EE6-4A84-8B3D-659CAF9CBF4F"></a><h5 id="TGSQL-GUID-F6BCB3C1-6EE6-4A84-8B3D-659CAF9CBF4F" class="sect5"><span class="enumeration_section">9.2.3.3</span>排序合并连接控件</h5>
                     <div>
                        <p><code class="codeph">USE_MERGE</code>提示指示优化器使用排序合并连接。
                        </p>
                        <p>在某些情况下，使用<code class="codeph">USE_MERGE</code>提示覆盖优化器可能是有意义的。例如，优化器可以在表上选择完整扫描，并避免在查询中进行排序操作。但是，成本增加是因为通过索引和单个块读取访问大表，而不是通过全表扫描更快地访问。
                        </p>
                     </div>
                     <div>
                        <div class="infoboxnotealso" id="GUID-F6BCB3C1-6EE6-4A84-8B3D-659CAF9CBF4F__GUID-EE214692-A01D-4BB9-B837-719BF382F8DC">
                           <p class="notep1">也可以看看：</p>
                           <p><a href="https://www.oracle.com/pls/topic/lookup?ctx=en/database/oracle/oracle-database/19/tgsql&amp;id=SQLRF50702" target="_blank"><span><cite>Oracle Database SQL语言参考</cite></span></a>了解<code class="codeph">USE_MERGE</code>提示</p>
                        </div>
                        <div class="familylinks">
                           <div class="parentlink">
                              <p><strong>父主题：</strong> <a href="joins.html#GUID-5FCD34FE-ED04-4AB2-BC90-9752FED94F4F" title="排序合并连接是嵌套循环连接的变体。">对合并连接进行排序</a></p>
                           </div>
                        </div>
                     </div>
                     
                  </div>
               </div>
            </div><a id="TGSQL95239"></a><div class="props_rev_3"><a id="GUID-8E7760A6-48D6-4794-BF2F-290349C019B9" name="GUID-8E7760A6-48D6-4794-BF2F-290349C019B9"></a><h3 id="TGSQL-GUID-8E7760A6-48D6-4794-BF2F-290349C019B9" class="sect3"><span class="enumeration_section">9.3</span>加入类型</h3>
               <div>
                  <p>连接类型由连接条件的类型确定。</p>
                  <p>本节包含以下主题：</p>
               </div>
               <div>
                  <ul class="ullinks">
                     <li class="ulchildlink"><a href="joins.html#GUID-F93F1CCA-BD59-4D75-BE42-0E958CDB6E51">内部联接</a><br><strong class="term">内连接</strong> （有时称为<span class="italic">简单连接</span> ）是仅返回满足连接条件的行的连接。内连接是equijoins或nonequijoins。
                     </li>
                     <li class="ulchildlink"><a href="joins.html#GUID-2174C4BA-C852-4050-9269-353A3B40B355">外连接</a><br><strong class="term">外部联接</strong>返回满足连接条件的所有行以及来自一个表的行，其他表中的行不满足条件。因此，外连接的结果集是内连接的超集。
                     </li>
                     <li class="ulchildlink"><a href="joins.html#GUID-816CED08-10A7-4B39-9790-E68996782847">半连接</a><br><strong class="term">半连接</strong>是两个数据集之间的连接，当子查询数据集中存在匹配的行时，它们从第一个集合返回一行。
                     </li>
                     <li class="ulchildlink"><a href="joins.html#GUID-084D65F8-0517-4B85-960F-F1CDEE69C693">Antijoins</a><br><strong class="term">反</strong>连接是两个数据集之间的连接，当子查询数据集中不存在匹配的行时，这两个数据集从第一个集合返回一行。
                     </li>
                     <li class="ulchildlink"><a href="joins.html#GUID-07D9388C-6DCB-4F88-BF59-AF223C10B8FC">笛卡尔联合</a><br>当一个或多个表与语句中的任何其他表没有任何连接条件时，数据库使用<strong class="term">笛卡尔连接</strong> 。
                     </li>
                  </ul>
                  <div class="familylinks">
                     <div class="parentlink">
                        <p><strong>父主题：</strong> <a href="joins.html#GUID-BD96F1B4-76D4-43DF-98B6-D07F46838C4A" title="Oracle数据库为加入行集提供了多种优化。">联接</a></p>
                     </div>
                  </div>
               </div>
               <a id="TGSQL95240"></a><div class="props_rev_3"><a id="GUID-F93F1CCA-BD59-4D75-BE42-0E958CDB6E51" name="GUID-F93F1CCA-BD59-4D75-BE42-0E958CDB6E51"></a><h4 id="TGSQL-GUID-F93F1CCA-BD59-4D75-BE42-0E958CDB6E51" class="sect4"><span class="enumeration_section">9.3.1</span>内部连接</h4>
                  <div>
                     <p><strong class="term">内连接</strong> （有时称为<span class="italic">简单连接</span> ）是仅返回满足连接条件的行的连接。内连接是equijoins或nonequijoins。
                     </p>
                     <p>本节包含以下主题：</p>
                  </div>
                  <div>
                     <ul class="ullinks">
                        <li class="ulchildlink"><a href="joins.html#GUID-90D3120E-1F5F-494C-9420-2E7F48337E3F">等值连接</a><br><span class="bold">等值连接</span>是一个内连接，其连接条件包含一个相等运算符。
                        </li>
                        <li class="ulchildlink"><a href="joins.html#GUID-C9653D35-455F-44C9-91F4-82B18478B43A">非等值联接</a><br>非<span class="bold">quijijoin</span>是一个内连接，其连接条件包含一个不是相等运算符的运算符。
                        </li>
                        <li class="ulchildlink"><a href="joins.html#GUID-24F34188-110F-4245-9DE7-43954092AFE0">乐队加入</a><br><strong class="term">带连接</strong>是一种特殊类型的非连接，其中一个数据集中的键值必须落在第二个数据集的指定范围（“带”）内。同一个表可以作为第一个和第二个数据集。
                        </li>
                     </ul>
                     <div class="familylinks">
                        <div class="parentlink">
                           <p><strong>父主题：</strong> <a href="joins.html#GUID-8E7760A6-48D6-4794-BF2F-290349C019B9" title="连接类型由连接条件的类型确定。">加入类型</a></p>
                        </div>
                     </div>
                  </div>
                  <a id="TGSQL95313"></a><div class="props_rev_3"><a id="GUID-90D3120E-1F5F-494C-9420-2E7F48337E3F" name="GUID-90D3120E-1F5F-494C-9420-2E7F48337E3F"></a><h5 id="TGSQL-GUID-90D3120E-1F5F-494C-9420-2E7F48337E3F" class="sect5"><span class="enumeration_section">9.3.1.1</span> Equijoins</h5>
                     <div>
                        <p><span class="bold">等值连接</span>是一个内连接，其连接条件包含一个相等运算符。
                        </p>
                        <p>以下示例是等值连接，因为连接条件仅包含相等运算符：</p><pre class="pre codeblock"><code>SELECT e.employee_id，e.last_name，d.department_name FROM employees e，departments d WHERE e.department_id = d.department_id;</code></pre><p>在前面的查询中，连接条件是<code class="codeph">e.department_id=d.department_id</code> 。如果<code class="codeph">employees</code>表中的行具有与<code class="codeph">departments</code>表中的行中的值匹配的部门ID，则数据库将返回已连接的结果;否则，数据库不会返回结果。
                        </p>
                     </div>
                     <div>
                        <div class="familylinks">
                           <div class="parentlink">
                              <p><strong>父主题：</strong> <a href="joins.html#GUID-F93F1CCA-BD59-4D75-BE42-0E958CDB6E51" title="内连接（有时称为简单连接）是仅返回满足连接条件的行的连接。内连接是equijoins或nonequijoins。">内部联接</a></p>
                           </div>
                        </div>
                     </div>
                     
                  </div><a id="TGSQL95314"></a><div class="props_rev_3"><a id="GUID-C9653D35-455F-44C9-91F4-82B18478B43A" name="GUID-C9653D35-455F-44C9-91F4-82B18478B43A"></a><h5 id="TGSQL-GUID-C9653D35-455F-44C9-91F4-82B18478B43A" class="sect5"><span class="enumeration_section">9.3.1.2</span>非<span class="enumeration_section">喹</span>喔啉</h5>
                     <div>
                        <p>非<span class="bold">quijijoin</span>是一个内连接，其连接条件包含一个不是相等运算符的运算符。
                        </p>
                        <p>以下查询列出了雇员176（因为他在2007年更换了工作而在<code class="codeph">job_history</code>列出）在公司工作时雇用日期发生的所有员工：</p><pre class="pre codeblock"><code>SELECT e.employee_id，e.first_name，e.last_name，e.hire_date FROM employees e，job_history h WHERE h.employee_id = 176 AND e.hire_date BETWEEN h.start_date AND h.end_date;</code></pre><p>在前面的示例中，加入<code class="codeph">employees</code>和<code class="codeph">job_history</code>的条件不包含相等运算符，因此它是一个非quijijin。非水蛭是相对罕见的。
                        </p>
                        <p>请注意，散列连接至少需要部分等值连接。以下SQL脚本包含等于连接条件（ <code class="codeph">e1.empno = e2.empno</code> ）和<code class="codeph">e1.empno = e2.empno</code>条件：</p><pre class="pre codeblock"><code>SET AUTOTRACE TRACEONLY EXPLAIN SELECT * from scott.emp e1 JOIN scott.emp e2 ON（e1.empno = e2.empno AND e1.hiredate BETWEEN e2.hiredate-1 AND e2.hiredate + 1）</code></pre><p>优化器为前面的查询选择散列连接，如以下计划所示：</p><pre class="pre codeblock"><code>执行计划------------------------------------------------ ----------计划哈希值：3638257876 ----------------------------------- ---------------------------------------- | Id |操作|名称|行|字节|成本（％CPU）|时间| -------------------------------------------------- ------------------------- | 0 |选择声明| | 1 | 174 | 5（20）| 00:00:01 | | * 1 | HASH JOIN | | 1 | 174 | 5（20）| 00:00:01 | | 2 |表访问完全| EMP | 14 | 1218 | 2（0）| 00:00:01 | | 3 |表访问完全| EMP | 14 | 1218 | 2（0）| 00:00:01 | -------------------------------------------------- -------------------------谓词信息（由操作ID标识）：---------------- ----------------------------------- 1  -  access（“E1”。“EMPNO”=“E2” 。“EMPNO”）过滤器（“E1”。“HIREDATE”&gt; = INTERNAL_FUNCTION（“E2”。“HIREDATE”） -  1和“E1”。“HIREDATE”&lt;= INTERNAL_FUNCTION（“E2”。“HIREDATE”）+ 1 ）</code></pre></div>
                     <div>
                        <div class="familylinks">
                           <div class="parentlink">
                              <p><strong>父主题：</strong> <a href="joins.html#GUID-F93F1CCA-BD59-4D75-BE42-0E958CDB6E51" title="内连接（有时称为简单连接）是仅返回满足连接条件的行的连接。内连接是equijoins或nonequijoins。">内部联接</a></p>
                           </div>
                        </div>
                     </div>
                     
                  </div>
                  <div class="sect4"><a id="GUID-24F34188-110F-4245-9DE7-43954092AFE0" name="GUID-24F34188-110F-4245-9DE7-43954092AFE0"></a><h5 id="TGSQL-GUID-24F34188-110F-4245-9DE7-43954092AFE0" class="sect5"><span class="enumeration_section">9.3.1.3</span>波段连接</h5>
                     <div>
                        <p><strong class="term">带连接</strong>是一种特殊类型的非连接，其中一个数据集中的键值必须落在第二个数据集的指定范围（“带”）内。同一个表可以作为第一个和第二个数据集。
                        </p>
                        <p>从<span>Oracle Database 12c</span>第2版（12.2）开始，数据库可以更有效地评估带连接。优化避免了对不在定义的频带之外的行进行不必要的扫描。
                        </p>
                        <p>优化程序使用成本估算来选择连接方法（散列，嵌套循环或排序合并）和并行数据分发方法。在大多数情况下，优化的性能可与equijoin相媲美。</p>
                        <p>以下示例查询员工的薪水比每位员工的薪水少100美元和100美元之间。因此，乐队的宽度为200美元。这些例子假设允许将每个雇员的工资与自己进行比较。以下查询包括部分示例输出：</p><pre class="pre codeblock"><code>SELECT e1.last_name || '薪水比'||低100到100之间e2.last_name AS“SALARY COMPARISON”来自员工e1，员工e2 WHERE e1.salary BETWEEN e2.salary  -  100 AND e2.salary + 100; SALARY COMPARISON ------------------------------------------------ ------------- King的工资在100比100和100以上的Kochhar之间的薪水比Kochhar Kochhar少100和100以上的工资比De Haan De Haan的工资少100和100以上Kochhar De Haan的薪水比100分和100分之间的薪水相差100多100比De Haan Russell的薪水在100比100和100之间，而Russell Partners的薪水比合伙人少100到100多...</code></pre><div class="example" id="GUID-24F34188-110F-4245-9DE7-43954092AFE0__GUID-829E275E-74C8-4440-80C2-5BA320FC05FA">
                           <p class="titleinexample">例9-7无带连接优化的查询</p>
                           <p>如果没有band join优化，数据库将使用以下查询计划：</p><pre class="pre codeblock"><code>------------------------------------------ PLAN_TABLE_OUTPUT ------- ----------------------------------- --------------- --------------------------- | Id |操作|名称| ------------------------------------------ | 0 |选择声明| | | 1 | MERGE JOIN | | | 2 | SORT JOIN | | | 3 |表访问完全|员工| | * 4 |过滤器| | | * 5 | SORT JOIN | | | 6 |表访问完全|员工| ------------------------------------------谓词信息（由操作ID标识） ：------------------------------------------------- -  4  - 过滤器（“E1”。“SAL”&lt;=“E2”。“SAL”+100）5  - 访问（INTERNAL_FUNCTION（“E1”。“SAL”）&gt; =“E2”。“SAL”-100 ）filter（INTERNAL_FUNCTION（“E1”。“SAL”）&gt; =“E2”。“SAL”-100）</code></pre><p>在此计划中，步骤2对<code class="codeph">e1</code>行源进行排序，步骤5对<code class="codeph">e2</code>行源进行排序。排序的行源如下表所示。
                           </p>
                           <div class="tblformal" id="GUID-24F34188-110F-4245-9DE7-43954092AFE0__GUID-645755EC-92B6-496B-A6AD-BAEAEC610B5B">
                              <p class="titleintable">表9-8已排序的行源</p>
                              <table cellpadding="4" cellspacing="0" class="Formal" title="排序行来源" border="1" summary="This 2 column table shows two sorted row sources." frame="hsides" rules="rows">
                                 <thead>
                                    <tr align="left" valign="top">
                                       <th align="left" valign="bottom" width="20%" id="d49855e5804">e1排序（计划的第2步）</th>
                                       <th align="left" valign="bottom" width="20%" id="d49855e5806">e2排序（计划的第5步）</th>
                                    </tr>
                                 </thead>
                                 <tbody>
                                    <tr align="left" valign="top">
                                       <td align="left" valign="top" width="20%" id="d49855e5810" headers="d49855e5804 ">24000（国王）</td>
                                       <td align="left" valign="top" width="20%" headers="d49855e5810 d49855e5806 ">24000（国王）</td>
                                    </tr>
                                    <tr align="left" valign="top">
                                       <td align="left" valign="top" width="20%" id="d49855e5815" headers="d49855e5804 ">17000（Kochhar）</td>
                                       <td align="left" valign="top" width="20%" headers="d49855e5815 d49855e5806 ">17000（Kochhar）</td>
                                    </tr>
                                    <tr align="left" valign="top">
                                       <td align="left" valign="top" width="20%" id="d49855e5820" headers="d49855e5804 ">17000（德汉）</td>
                                       <td align="left" valign="top" width="20%" headers="d49855e5820 d49855e5806 ">17000（德汉）</td>
                                    </tr>
                                    <tr align="left" valign="top">
                                       <td align="left" valign="top" width="20%" id="d49855e5825" headers="d49855e5804 ">14000（拉塞尔）</td>
                                       <td align="left" valign="top" width="20%" headers="d49855e5825 d49855e5806 ">14000（罗素）</td>
                                    </tr>
                                    <tr align="left" valign="top">
                                       <td align="left" valign="top" width="20%" id="d49855e5830" headers="d49855e5804 ">13500（合作伙伴）</td>
                                       <td align="left" valign="top" width="20%" headers="d49855e5830 d49855e5806 ">13500（合作伙伴）</td>
                                    </tr>
                                 </tbody>
                              </table>
                           </div>
                           <!-- class="inftblhruleinformal" -->
                           <p>连接开始于迭代排序的输入（ <code class="codeph">e1</code> ），该输入是连接的左分支，对应于计划的步骤2。原始查询包含两个谓词：</p>
                           <ul style="list-style-type:disc">
                              <li>
                                 <p><code class="codeph">e1.sal &gt;= e2.sal–100</code> ，这是Step 5过滤器</p>
                              </li>
                              <li>
                                 <p><code class="codeph">e1.sal &gt;= e2.sal+100</code> ，这是Step 4过滤器</p>
                              </li>
                           </ul>
                           <p>对于排序行<code class="codeph">e1</code>每次迭代，数据库遍历行源<code class="codeph">e2</code> ，根据步骤5过滤器<code class="codeph">e1.sal &gt;= e2.sal–100</code>检查每一行。如果该行通过了步骤5过滤器，则数据库将其发送到步骤4过滤器，然后继续针对步骤5过滤器测试<code class="codeph">e2</code>中的下一行。但是，如果一行未通过步骤5过滤器，则<code class="codeph">e2</code>的扫描停止，数据库继续进行下一次<code class="codeph">e1</code>迭代。
                           </p>
                           <p>下表显示了<code class="codeph">e1</code>的第一次迭代，它以数据集<code class="codeph">e1</code> <code class="codeph">24000 (King)</code>开头。数据库确定<code class="codeph">e2</code>中的第一行（ <code class="codeph">24000 (King)</code>通过了Step 5过滤器。然后数据库将该行发送到步骤4过滤器， <code class="codeph">e1.sal &lt;= w2.sal+100</code> ，它也通过。数据库将此行发送到<code class="codeph">MERGE</code>行源。接下来，数据库检查<code class="codeph">17000 (Kochhar)</code>与步骤5过滤器，它也通过。但是，该行未通过步骤4过滤器，并被丢弃。数据库继续针对步骤5过滤器测试<code class="codeph">17000 (De Haan)</code> 。
                           </p>
                           <div class="tblformal" id="GUID-24F34188-110F-4245-9DE7-43954092AFE0__GUID-D8F05E91-0510-47D4-9CA1-6BFF08BAB63A">
                              <p class="titleintable">表9-9 e1的第一次迭代：单独的SORT JOIN和FILTER</p>
                              <table cellpadding="4" cellspacing="0" class="Formal" title="第一次迭代e1：分离SORT JOIN和FILTER" border="1" summary="This 3 column table shows the how the database tests the predicates." frame="hsides" rules="rows">
                                 <thead>
                                    <tr align="left" valign="top">
                                       <th align="left" valign="bottom" width="20%" id="d49855e5912">扫描e2</th>
                                       <th align="left" valign="bottom" width="20%" id="d49855e5914">步骤5过滤（e1.sal&gt; = e2.sal-100）</th>
                                       <th align="left" valign="bottom" width="20%" id="d49855e5916">第4步过滤（e1.sal &lt;= e2.sal + 100）</th>
                                    </tr>
                                 </thead>
                                 <tbody>
                                    <tr align="left" valign="top">
                                       <td align="left" valign="top" width="20%" id="d49855e5920" headers="d49855e5912 ">24000（国王）</td>
                                       <td align="left" valign="top" width="20%" headers="d49855e5920 d49855e5914 ">通过，因为24000&gt; = 23900。发送到第4步过滤器。</td>
                                       <td align="left" valign="top" width="20%" headers="d49855e5920 d49855e5916 ">通过，因为24000 &lt;= 24100。返回合并的行。</td>
                                    </tr>
                                    <tr align="left" valign="top">
                                       <td align="left" valign="top" width="20%" id="d49855e5927" headers="d49855e5912 ">17000（Kochhar）</td>
                                       <td align="left" valign="top" width="20%" headers="d49855e5927 d49855e5914 ">通过，因为24000&gt; = 16900。发送到第4步过滤器。</td>
                                       <td align="left" valign="top" width="20%" headers="d49855e5927 d49855e5916 ">失败，因为24000 &lt;= 17100是错误的。丢弃行。扫描e2中的下一行。</td>
                                    </tr>
                                    <tr align="left" valign="top">
                                       <td align="left" valign="top" width="20%" id="d49855e5934" headers="d49855e5912 ">17000（德汉）</td>
                                       <td align="left" valign="top" width="20%" headers="d49855e5934 d49855e5914 ">通过，因为24000&gt; = 16900。发送到第4步过滤器。</td>
                                       <td align="left" valign="top" width="20%" headers="d49855e5934 d49855e5916 ">失败，因为24000 &lt;= 17100是错误的。丢弃行。扫描e2中的下一行。</td>
                                    </tr>
                                    <tr align="left" valign="top">
                                       <td align="left" valign="top" width="20%" id="d49855e5941" headers="d49855e5912 ">14000（罗素）</td>
                                       <td align="left" valign="top" width="20%" headers="d49855e5941 d49855e5914 ">通过，因为24000&gt; = 13900。发送到第4步过滤器。</td>
                                       <td align="left" valign="top" width="20%" headers="d49855e5941 d49855e5916 ">失败，因为24000 &lt;= 14100是错误的。丢弃行。扫描e2中的下一行。</td>
                                    </tr>
                                    <tr align="left" valign="top">
                                       <td align="left" valign="top" width="20%" id="d49855e5948" headers="d49855e5912 ">13500（合作伙伴）</td>
                                       <td align="left" valign="top" width="20%" headers="d49855e5948 d49855e5914 ">通过，因为24000&gt; = 13400。发送到第4步过滤器。</td>
                                       <td align="left" valign="top" width="20%" headers="d49855e5948 d49855e5916 ">失败，因为24000 &lt;= 13600是错误的。丢弃行。扫描e2中的下一行。</td>
                                    </tr>
                                 </tbody>
                              </table>
                           </div>
                           <!-- class="inftblhruleinformal" -->
                           <p>如上表所示，每个<code class="codeph">e2</code>行必须通过Step 5过滤器，因为<code class="codeph">e2</code>工资按降序排序。因此，步骤5过滤器始终将行发送到步骤4过滤器。由于<code class="codeph">e2</code>工资按降序排序，因此步骤4过滤器必然会以<code class="codeph">17000 (Kochhar)</code>开头的每一行失败。效率低下是因为数据库测试<code class="codeph">e2</code>中的每个后续行与步骤5过滤器（必须通过），然后针对必然失败的步骤4过滤器。
                           </p>
                        </div>
                        <!-- class="example" -->
                        <div class="example" id="GUID-24F34188-110F-4245-9DE7-43954092AFE0__GUID-842FE436-2DFC-41E7-B0E0-FD92374A44E7">
                           <p class="titleinexample">例9-8使用波段连接优化进行查询</p>
                           <p>从<span>Oracle Database 12c</span>第2版（12.2）开始，数据库使用以下计划优化波段连接，该计划没有单独的<code class="codeph">FILTER</code>操作：</p><pre class="pre codeblock"><code>------------------------------------------ PLAN_TABLE_OUTPUT ------- ----------------------------------- | Id |操作|名称| ------------------------------------------ | 0 |选择声明| | | 1 | MERGE JOIN | | | 2 | SORT JOIN | | | 3 |表访问完全|员工| | * 4 | SORT JOIN | | | 5 |表访问完全|员工| ------------------------------------------谓词信息（由操作ID标识） ：------------------------------------------------- -  4  - 访问（INTERNAL_FUNCTION（“E1”。“SALARY”）&gt; =“E2”。“SALARY”-100）过滤器（（“E1”。“SALARY”&lt;=“E2”。“SALARY”+100 AND INTERNAL_FUNCTION（ “E1”。 “工资”）&gt; = “E2”。 “工资” -100））</code></pre><p>不同之处在于，步骤4使用布尔<code class="codeph">AND</code>逻辑为两个谓词创建<span class="italic">单个</span>过滤器。而不是针对一个过滤器检查行，然后将其发送到不同的行源以检查第二个过滤器，数据库对一个过滤器执行一次检查。如果检查失败，则处理停止。
                           </p>
                           <p>在此示例中，查询开始<code class="codeph">e1</code>的第一次迭代，以<code class="codeph">24000 (King)</code>开头。下图表示范围。 <code class="codeph">e2</code>值低于23900且高于24100超出范围。
                           </p>
                           <div class="figure" id="GUID-24F34188-110F-4245-9DE7-43954092AFE0__GUID-87B05029-908E-40C2-A398-E60C92FF5FE1">
                              <p class="titleinfigure">图9-7 Band Join</p><img src="img/tgsql_vm_097.png" alt="下面是图9-7的描述" title="下面是图9-7的描述" longdesc="img_text/tgsql_vm_097.html"><br><a href="img_text/tgsql_vm_097.html">“图9-7波段加入”的描述</a></div>
                           <!-- class="figure" -->
                           <p>下表显示数据库针对Step 4过滤器测试<code class="codeph">e2</code>的第一行，即<code class="codeph">24000 (King)</code> 。该行传递测试，因此数据库发送要合并的行。<code class="codeph">e2</code>的下一行是<code class="codeph">17000 (Kochhar)</code> 。此行超出范围（波段），因此不满足过滤谓词，因此数据库在此迭代中停止测试<code class="codeph">e2</code>行。因为降序排序的数据库停止测试<code class="codeph">e2</code>确保在所有后续行<code class="codeph">e2</code>失败的过滤器测试。因此，数据库可以进行到<code class="codeph">e1</code>的第二次迭代。
                           </p>
                           <div class="tblformal" id="GUID-24F34188-110F-4245-9DE7-43954092AFE0__GUID-FFB9F10C-AB03-4AB5-8B2E-DD725B842FE0">
                              <p class="titleintable">表9-10 e1的第一次迭代：单个SORT JOIN</p>
                              <table cellpadding="4" cellspacing="0" class="Formal" title="第一次迭代e1：单SORT JOIN" border="1" summary="This 2 column table describes the processing a row source using a sort merge join." frame="hsides" rules="rows">
                                 <thead>
                                    <tr align="left" valign="top">
                                       <th align="left" valign="bottom" width="20%" id="d49855e6045">扫描e2</th>
                                       <th align="left" valign="bottom" width="20%" id="d49855e6047">过滤器4（e1.sal&gt; = e2.sal  -  100）AND（e1.sal &lt;= e2.sal + 100）</th>
                                    </tr>
                                 </thead>
                                 <tbody>
                                    <tr align="left" valign="top">
                                       <td align="left" valign="top" width="20%" id="d49855e6051" headers="d49855e6045 ">24000（国王）</td>
                                       <td align="left" valign="top" width="20%" headers="d49855e6051 d49855e6047 ">
                                          <p>通过测试，因为<code class="codeph">(24000 &gt;= 23900) AND (24000 &lt;= 24100)</code> 。
                                          </p>
                                          <p>发送行到<code class="codeph">MERGE</code> 。测试下一行。
                                          </p>
                                       </td>
                                    </tr>
                                    <tr align="left" valign="top">
                                       <td align="left" valign="top" width="20%" id="d49855e6065" headers="d49855e6045 ">17000（Kochhar）</td>
                                       <td align="left" valign="top" width="20%" headers="d49855e6065 d49855e6047 ">
                                          <p>失败测试，因为<code class="codeph">(24000 &gt;= 16900) AND (24000 &lt;= 17100)</code> 。
                                          </p>
                                          <p>停止扫描<code class="codeph">e2</code> 。开始<code class="codeph">e1</code>下一次迭代。
                                          </p>
                                       </td>
                                    </tr>
                                    <tr align="left" valign="top">
                                       <td align="left" valign="top" width="20%" id="d49855e6082" headers="d49855e6045 ">17000（德汉）</td>
                                       <td align="left" valign="top" width="20%" headers="d49855e6082 d49855e6047 ">N / A</td>
                                    </tr>
                                    <tr align="left" valign="top">
                                       <td align="left" valign="top" width="20%" id="d49855e6087" headers="d49855e6045 ">14000（罗素）</td>
                                       <td align="left" valign="top" width="20%" headers="d49855e6087 d49855e6047 ">N / A</td>
                                    </tr>
                                    <tr align="left" valign="top">
                                       <td align="left" valign="top" width="20%" id="d49855e6092" headers="d49855e6045 ">13500（合作伙伴）</td>
                                       <td align="left" valign="top" width="20%" headers="d49855e6092 d49855e6047 ">N / A</td>
                                    </tr>
                                 </tbody>
                              </table>
                           </div>
                           <!-- class="inftblhruleinformal" -->
                           <p>通过这种方式，带连接优化消除了不必要的处理。数据库仅扫描最少两行，而不是像未优化的情况一样扫描<code class="codeph">e2</code>中的每一行。
                           </p>
                        </div>
                        <!-- class="example" -->
                     </div>
                     <div>
                        <div class="familylinks">
                           <div class="parentlink">
                              <p><strong>父主题：</strong> <a href="joins.html#GUID-F93F1CCA-BD59-4D75-BE42-0E958CDB6E51" title="内连接（有时称为简单连接）是仅返回满足连接条件的行的连接。内连接是equijoins或nonequijoins。">内部联接</a></p>
                           </div>
                        </div>
                     </div>
                     
                  </div>
               </div><a id="TGSQL94989"></a><div class="props_rev_3"><a id="GUID-2174C4BA-C852-4050-9269-353A3B40B355" name="GUID-2174C4BA-C852-4050-9269-353A3B40B355"></a><h4 id="TGSQL-GUID-2174C4BA-C852-4050-9269-353A3B40B355" class="sect4"><span class="enumeration_section">9.3.2</span>外连接</h4>
                  <div>
                     <p><strong class="term">外部联接</strong>返回满足连接条件的所有行以及来自一个表的行，其他表中的行不满足条件。因此，外连接的结果集是内连接的超集。
                     </p>
                     <p>在ANSI语法中， <code class="codeph">OUTER JOIN</code>子句指定外部<code class="codeph">OUTER JOIN</code> 。在<code class="codeph">FROM</code>子句中， <a href="glossary.html#GUID-3171DB52-9306-4B3F-A30C-052CDD5EBB60"><span class="xrefglossterm">左表</span></a>显示在<code class="codeph">OUTER JOIN</code>关键字的左侧， <a href="glossary.html#GUID-462FD89A-89C8-4C2F-8376-EEADD7460082"><span class="xrefglossterm">右表</span></a>显示在这些关键字的右侧。左表也称为<span class="italic">外表</span> ，右表也称为<span class="italic">内表</span> 。例如，在以下语句中， <code class="codeph">employees</code>表是左表或外表：</p><pre class="pre codeblock"><code>SELECT employee_id，last_name，first_name FROM employees LEFT OUTER JOIN departments ON（employees.department_id = departments.departments_id）;</code></pre><p>外连接要求外连接工作台作为驱动工作台。在前面的示例中， <code class="codeph">employees</code>是驱动表，而<code class="codeph">departments</code>是驱动表。
                     </p>
                     <p>本节包含以下主题：</p>
                  </div>
                  <div>
                     <ul class="ullinks">
                        <li class="ulchildlink"><a href="joins.html#GUID-1ACFF09D-C8E1-4272-97B9-900D2053B91E">嵌套循环外连接</a><br>数据库使用此操作循环遍历两个表之间的外部联接。外连接返回外（保留）表行，即使内部（可选）表中没有相应的行也是如此。
                        </li>
                        <li class="ulchildlink"><a href="joins.html#GUID-278E01B5-9498-40EC-B0BD-CC415C18E078">哈希加入外连接</a><br>当数据量足够大以使散列连接有效时，优化程序使用散列连接来处理外连接，或者无法从外部表驱动到内部表。
                        </li>
                        <li class="ulchildlink"><a href="joins.html#GUID-538140BC-7F1D-43AE-AF4C-89539902B3FD">合并外部联接</a><br>当外连接无法从外（保留）表驱动到内（可选）表时，它不能使用散列连接或嵌套循环连接。
                        </li>
                        <li class="ulchildlink"><a href="joins.html#GUID-9FAA29BF-B7E3-48CE-9B27-4276195F24D0">完整的外部联接</a><br><strong class="term">完全外连接</strong>是左外连接和右外连接的组合。
                        </li>
                        <li class="ulchildlink"><a href="joins.html#GUID-C176D438-5532-4C3C-81E6-8C7EBAAED3DD">外连接左侧的多个表</a><br>在<span>Oracle Database 12c中</span> ，外连接表的左侧可能存在多个表。
                        </li>
                     </ul>
                     <div class="familylinks">
                        <div class="parentlink">
                           <p><strong>父主题：</strong> <a href="joins.html#GUID-8E7760A6-48D6-4794-BF2F-290349C019B9" title="连接类型由连接条件的类型确定。">加入类型</a></p>
                        </div>
                     </div>
                  </div>
                  <a id="TGSQL94990"></a><div class="props_rev_3"><a id="GUID-1ACFF09D-C8E1-4272-97B9-900D2053B91E" name="GUID-1ACFF09D-C8E1-4272-97B9-900D2053B91E"></a><h5 id="TGSQL-GUID-1ACFF09D-C8E1-4272-97B9-900D2053B91E" class="sect5"><span class="enumeration_section">9.3.2.1</span>嵌套循环外连接</h5>
                     <div>
                        <p>数据库使用此操作循环遍历两个表之间的外部联接。外连接返回外（保留）表行，即使内部（可选）表中没有相应的行也是如此。</p>
                        <p>在标准嵌套循环中，优化器选择表的顺序 - 这是驱动表，驱动表是基于成本的。但是，在嵌套循环外连接中，连接条件确定表的顺序。数据库使用外部保留行的表来驱动到内部表。</p>
                        <p>在以下情况下，优化程序使用嵌套循环连接来处理外连接：</p>
                        <ul style="list-style-type:disc">
                           <li>
                              <p>可以从外表驱动到内表。</p>
                           </li>
                           <li>
                              <p>数据量足够低，使嵌套循环方法有效。</p>
                           </li>
                        </ul>
                        <p>有关嵌套循环外连接的示例，可以将<code class="codeph">USE_NL</code>提示添加到<a href="joins.html#GUID-278E01B5-9498-40EC-B0BD-CC415C18E078__BABCIBBJ">示例9-9，</a>以指示优化程序使用嵌套循环。例如：</p><pre class="pre codeblock"><code>SELECT / * + USE_NL（co）* / cust_last_name，SUM（NVL2（o.customer_id，0,1））“计数”来自客户c，订单o WHERE c.credit_limit&gt; 1000 AND c.customer_id = o.customer_id（+ ）GROUP BY cust_last_name;</code></pre></div>
                     <div>
                        <div class="familylinks">
                           <div class="parentlink">
                              <p><strong>父主题：</strong> <a href="joins.html#GUID-2174C4BA-C852-4050-9269-353A3B40B355" title="外连接返回满足连接条件的所有行以及来自一个表的行，其他表中的行不满足条件。因此，外连接的结果集是内连接的超集。">外部联接</a></p>
                           </div>
                        </div>
                     </div>
                     
                  </div><a id="TGSQL94992"></a><a id="TGSQL94993"></a><a id="TGSQL94991"></a><div class="props_rev_3"><a id="GUID-278E01B5-9498-40EC-B0BD-CC415C18E078" name="GUID-278E01B5-9498-40EC-B0BD-CC415C18E078"></a><h5 id="TGSQL-GUID-278E01B5-9498-40EC-B0BD-CC415C18E078" class="sect5"><span class="enumeration_section">9.3.2.2</span>散列加入外连接</h5>
                     <div>
                        <p>当数据量足够大以使散列连接有效时，优化程序使用散列连接来处理外连接，或者无法从外部表驱动到内部表。</p>
                        <p>成本决定了表的顺序。外部表（包括保留的行）可用于构建哈希表，或者可用于探测哈希表。</p>
                        <div class="example" id="GUID-278E01B5-9498-40EC-B0BD-CC415C18E078__BABCIBBJ">
                           <p class="titleinexample">例9-9散列加入外连接</p>
                           <p>此示例显示典型的散列连接外连接查询及其执行计划。在此示例中，将查询信用限额大于1000的所有客户。需要外部联接，以便查询捕获没有订单的客户。</p>
                           <ul style="list-style-type:disc">
                              <li>
                                 <p>外表是<code class="codeph">customers</code> 。
                                 </p>
                              </li>
                              <li>
                                 <p>内表是<code class="codeph">orders</code> 。
                                 </p>
                              </li>
                              <li>
                                 <p>连接保留<code class="codeph">customers</code>行，包括那些没有<code class="codeph">orders</code>相应行的行。
                                 </p>
                              </li>
                           </ul>
                           <p>您可以使用<code class="codeph">NOT EXISTS</code>子查询返回行。但是，因为您正在查询表中的所有行，所以散列连接执行得更好（除非<code class="codeph">NOT EXISTS</code>子查询未嵌套）。
                           </p><pre class="pre codeblock"><code>SELECT cust_last_name，SUM（NVL2（o.customer_id，0,1））“Count”FROM customers c，orders o WHERE c.credit_limit&gt; 1000 AND c.customer_id = o.customer_id（+）GROUP BY cust_last_name; -------------------------------------------------- ------------------------------ | Id |操作|名称|行|字节|成本（％CPU）|时间| -------------------------------------------------- ------------------------------ PLAN_TABLE_OUTPUT ------------------- -------------------------------------------------- ----------- 0 |选择声明| | | | 7（100）| | | 1 | HASH GROUP BY | | 168 | 3192 | 7（29）| 00:00:01 | | * 2 | <span class="bold">HASH JOIN OUTER</span> | | 318 | 6042 | 6（17）| 00:00:01 | | * 3 |表访问完全|客户| 260 | 3900 | 3（0）| 00:00:01 | | * 4 |表访问完全|订单| 105 | 420 | 2（0）| 00:00:01 | -------------------------------------------------- ------------------------------谓词信息（由操作ID标识）：----------- ---------------------------------------- 2  -  access（“C”。“CUSTOMER_ID “=”O“。”CUSTOMER_ID“）PLAN_TABLE_OUTPUT --------------------------------------- ---------------------------------------- 3  - 过滤器（“C”。“CREDIT_LIMIT “&gt; 1000）4  - 过滤器（”O“。”CUSTOMER_ID“&gt; 0）</code></pre><p>查询查找满足各种条件的客户。当内部表列中没有找到任何相应的行时，外部<code class="codeph">NULL</code>为内部表列以及外部（保留）表行返回<code class="codeph">NULL</code> 。此操作查找没有任何<code class="codeph">orders</code>行的所有<code class="codeph">customers</code>行。
                           </p>
                           <p>在这种情况下，外连接条件如下：</p><pre class="pre codeblock"><code>customers.customer_id = orders.customer_id（+）</code></pre><p>这种情况的组成部分代表如下：</p>
                        </div>
                        <!-- class="example" -->
                        <div class="example" id="GUID-278E01B5-9498-40EC-B0BD-CC415C18E078__BABIDIAB">
                           <p class="titleinexample">示例9-10外部联接到多表视图</p>
                           <p>在此示例中，外部联接是一个多表视图。优化器无法像普通连接一样进入视图或推送谓词，因此它构建了视图的整个行集。</p><pre class="pre codeblock"><code>SELECT c.cust_last_name，sum（revenue）FROM customers c，v_orders o WHERE c.credit_limit&gt; 2000 AND o.customer_id（+）= c.customer_id GROUP BY c.cust_last_name; -------------------------------------------------- -------------------------- | Id |操作|名称|行|字节|成本（％CPU）| -------------------------------------------------- -------------------------- | 0 |选择声明| | 144 | 4608 | 16（32）| | 1 | HASH GROUP BY | | 144 | 4608 | 16（32）| | * 2 | HASH JOIN OUTER | | 663 | 21216 | 15（27）| | * 3 |表访问完全|客户| 195 | 2925 | 6（17）| | 4 |查看| V_ORDERS | 665 | 11305 | | | 5 | HASH GROUP BY | | 665 | 15960 | 9（34）| | * 6 | HASH JOIN | | 665 | 15960 | 8（25）| | * 7 |表访问完全|订单| 105 | 840 | 4（25）| | 8 |表访问完全| ORDER_ITEMS | 665 | 10640 | 4（25）| -------------------------------------------------- --------------------------谓词信息（由操作ID标识）：--------------- ------------------------------------ 2  -  access（“O”。“CUSTOMER_ID”（+） =“C”。“CUSTOMER_ID”）3  - 过滤器（“C”。“CREDIT_LIMIT”&gt; 2000）6  - 访问（“O”。“ORDER_ID”=“L”。“ORDER_ID”）7  - 过滤器（“O”） “CUSTOMER_ID”&gt; 0）</code></pre><p>视图定义如下：</p><pre class="pre codeblock"><code>创建或替换视图v_orders AS SELECT l.product_id，SUM（l.quantity * unit_price）revenue，o.order_id，o.customer_id FROM orders o，order_items l WHERE o.order_id = l.order_id GROUP BY l.product_id，o。 order_id，o.customer_id;</code></pre></div>
                        <!-- class="example" -->
                     </div>
                     <div>
                        <div class="familylinks">
                           <div class="parentlink">
                              <p><strong>父主题：</strong> <a href="joins.html#GUID-2174C4BA-C852-4050-9269-353A3B40B355" title="外连接返回满足连接条件的所有行以及来自一个表的行，其他表中的行不满足条件。因此，外连接的结果集是内连接的超集。">外部联接</a></p>
                           </div>
                        </div>
                     </div>
                     
                  </div><a id="TGSQL94994"></a><div class="props_rev_3"><a id="GUID-538140BC-7F1D-43AE-AF4C-89539902B3FD" name="GUID-538140BC-7F1D-43AE-AF4C-89539902B3FD"></a><h5 id="TGSQL-GUID-538140BC-7F1D-43AE-AF4C-89539902B3FD" class="sect5"><span class="enumeration_section">9.3.2.3</span>排序合并外连接</h5>
                     <div>
                        <p>当外连接无法从外（保留）表驱动到内（可选）表时，它不能使用散列连接或嵌套循环连接。</p>
                        <p>在这种情况下，它使用排序合并外连接。</p>
                        <p>在以下情况下，优化程序对外连接使用排序合并：</p>
                        <ul style="list-style-type:disc">
                           <li>
                              <p>嵌套循环连接效率低下。由于数据量的原因，嵌套循环连接可能效率低下。</p>
                           </li>
                           <li>
                              <p>优化器发现由于其他操作所需的排序，在散列连接上使用排序合并更便宜。</p>
                           </li>
                        </ul>
                     </div>
                     <div>
                        <div class="familylinks">
                           <div class="parentlink">
                              <p><strong>父主题：</strong> <a href="joins.html#GUID-2174C4BA-C852-4050-9269-353A3B40B355" title="外部联接返回满足连接条件的所有行以及来自一个表的行，其他表中的行不满足条件。因此，外连接的结果集是内连接的超集。">外部联接</a></p>
                           </div>
                        </div>
                     </div>
                     
                  </div><a id="TGSQL94996"></a><a id="TGSQL94997"></a><a id="TGSQL94995"></a><div class="props_rev_3"><a id="GUID-9FAA29BF-B7E3-48CE-9B27-4276195F24D0" name="GUID-9FAA29BF-B7E3-48CE-9B27-4276195F24D0"></a><h5 id="TGSQL-GUID-9FAA29BF-B7E3-48CE-9B27-4276195F24D0" class="sect5"><span class="enumeration_section">9.3.2.4</span>完全外连接</h5>
                     <div>
                        <p><strong class="term">完全外连接</strong>是左外连接和右外连接的组合。
                        </p>
                        <p>除了内部联接之外，两个表中尚未在内部联接的结果中返回的行将保留并使用空值进行扩展。换句话说，完全外部联接将表连接在一起，但在连接表中显示没有对应行的行。</p>
                        <div class="example" id="GUID-9FAA29BF-B7E3-48CE-9B27-4276195F24D0__BABCHEAG">
                           <p class="titleinexample">例9-11完全外连接</p>
                           <p>以下查询检索每个部门中的所有部门和所有员工，但还包括：</p>
                           <ul style="list-style-type:disc">
                              <li>
                                 <p>任何没有部门的员工</p>
                              </li>
                              <li>
                                 <p>没有员工的任何部门</p>
                              </li>
                           </ul><pre class="pre codeblock"><code>SELECT d.department_id，e.employee_id FROM employees e FULL OUTER JOIN departments d on e.department_id = d.department_id ORDER BY d.department_id;</code></pre><p>该语句产生以下输出：</p><pre class="pre codeblock"><code>DEPARTMENT_ID EMPLOYEE_ID ------------- ----------- 10 200 20 201 20 202 30 114 30 115 30 116 ...选择270 280 178 207 125行。
</code></pre></div>
                        <!-- class="example" -->
                        <div class="example" id="GUID-9FAA29BF-B7E3-48CE-9B27-4276195F24D0__BABIJCIF">
                           <p class="titleinexample">示例9-12完全外部联接的执行计划</p>
                           <p>从Oracle Database <span class="italic">11g开始</span> ，Oracle数据库会自动使用基于散列连接的本机执行方法来尽可能执行完全外连接。当数据库使用新方法执行完全外连接时，查询的执行计划包含<code class="codeph">HASH JOIN FULL OUTER</code> 。 <a href="joins.html#GUID-9FAA29BF-B7E3-48CE-9B27-4276195F24D0__BABCHEAG">例9-11中</a>的查询使用以下执行计划：</p><pre class="pre codeblock"><code>-------------------------------------------------- ------------------------------ | ID |操作|名称|行|字节|成本（％CPU）|时间| -------------------------------------------------- ------------------------------ | 0 |选择声明| | 122 | 4758 | 6（34）| 00：0 0:01 | | 1 |排序顺序| | 122 | 4758 | 6（34）| 00：0 0:01 | | 2 |查看| VW_FOJ_0 | 122 | 4758 | 5（20）| 00：0 0:01 | | * 3 | <span class="bold">HASH JOIN FULL OUTER</span> | | 122 | 1342 | 5（20）| 00：0 0:01 | | 4 | INDEX FAST FULL SCAN | DEPT_ID_PK | 27 | 108 | 2（0）| 00：0 0:01 | | 5 |表访问完全|员工| 107 | 749 | 2（0）| 00：0 0:01 | -------------------------------------------------- ------------------------------谓词信息（由操作ID标识）：----------- ---------------------------------------- 3  - 访问（“E”。“DEPARTMENT_ID “=” d”。 “DEPARTMENT_ID”）</code></pre><p><code class="codeph">HASH JOIN FULL OUTER</code>包含在前面的计划中（步骤3），表示查询使用散列全外连接执行方法。通常，当两个表之间的完全外连接条件是等值连接时，可以使用哈希全外连接执行方法，Oracle数据库会自动使用它。
                           </p>
                           <p>要指示优化器考虑使用散列全外连接执行方法，请应用<code class="codeph">NATIVE_FULL_OUTER_JOIN</code>提示。要指示优化器不要考虑使用散列全外连接执行方法，请应用<code class="codeph">NO_NATIVE_FULL_OUTER_JOIN</code>提示。<code class="codeph">NO_NATIVE_FULL_OUTER_JOIN</code>提示指示优化器在连接每个指定的表时排除本机执行方法。相反，完整外连接作为左外连接和反连接的并集执行。
                           </p>
                        </div>
                        <!-- class="example" -->
                     </div>
                     <div>
                        <div class="familylinks">
                           <div class="parentlink">
                              <p><strong>父主题：</strong> <a href="joins.html#GUID-2174C4BA-C852-4050-9269-353A3B40B355" title="外部联接返回满足连接条件的所有行以及来自一个表的行，其他表中的行不满足条件。因此，外连接的结果集是内连接的超集。">外部联接</a></p>
                           </div>
                        </div>
                     </div>
                     
                  </div><a id="TGSQL95113"></a><div class="props_rev_3"><a id="GUID-C176D438-5532-4C3C-81E6-8C7EBAAED3DD" name="GUID-C176D438-5532-4C3C-81E6-8C7EBAAED3DD"></a><h5 id="TGSQL-GUID-C176D438-5532-4C3C-81E6-8C7EBAAED3DD" class="sect5"><span class="enumeration_section">9.3.2.5</span>外部连接左侧的多个表</h5>
                     <div>
                        <p>在<span>Oracle Database 12c中</span> ，外连接表的左侧可能存在多个表。
                        </p>
                        <p>此增强功能使Oracle数据库能够合并包含多个表的视图，并显示在外部联接的左侧。在<span>Oracle Database 12c</span>之前的版本中，如下所示的查询无效，并将触发<code class="codeph">ORA-01417</code>错误消息：</p><pre class="pre codeblock"><code>SELECT t1.d，t3.c FROM t1，t2，t3 WHERE t1.z = t2.z AND t1.x = t3.x（+）AND t2.y = t3.y（+）;</code></pre><p>从<span>Oracle Database 12c开始</span> ，前面的查询有效。
                        </p>
                     </div>
                     <div>
                        <div class="familylinks">
                           <div class="parentlink">
                              <p><strong>父主题：</strong> <a href="joins.html#GUID-2174C4BA-C852-4050-9269-353A3B40B355" title="外部联接返回满足连接条件的所有行以及来自一个表的行，其他表中的行不满足条件。因此，外连接的结果集是内连接的超集。">外部联接</a></p>
                           </div>
                        </div>
                     </div>
                     
                  </div>
               </div><a id="TGSQL95241"></a><div class="props_rev_3"><a id="GUID-816CED08-10A7-4B39-9790-E68996782847" name="GUID-816CED08-10A7-4B39-9790-E68996782847"></a><h4 id="TGSQL-GUID-816CED08-10A7-4B39-9790-E68996782847" class="sect4"><span class="enumeration_section">9.3.3</span>半连接</h4>
                  <div>
                     <p><strong class="term">半连接</strong>是两个数据集之间的连接，当子查询数据集中存在匹配的行时，它们从第一个集合返回一行。
                     </p>
                     <p>数据库在第一次匹配时停止处理第二个数据集。因此，当第二数据集中的多行满足子查询标准时，优化不会复制第一数据集中的行。</p>
                     <div class="infoboxnote" id="GUID-816CED08-10A7-4B39-9790-E68996782847__GUID-BC796732-679A-4CC9-AFD2-750CCFE5F68E">
                        <p class="notep1">注意：</p>
                        <p>Semijoins和反连接被认为是连接类型，即使导致它们的SQL结构是子查询。它们是优化程序用于展平子查询结构的内部算法，以便可以以类似连接的方式解析它们。</p>
                     </div>
                     <p>本节包含以下主题：</p>
                  </div>
                  <div>
                     <ul class="ullinks">
                        <li class="ulchildlink"><a href="joins.html#GUID-44C2DD4F-8C1B-4EA5-867B-CF5A6B90A01B">当优化器考虑Semijoins时</a><br>当查询只需要确定是否存在匹配时，半连接可以避免返回大量行。
                        </li>
                        <li class="ulchildlink"><a href="joins.html#GUID-B3DE9781-0579-44D1-A7B5-3132504590E2">Semijoins如何运作</a><br>半连接优化的实现方式不同，具体取决于使用的连接类型。
                        </li>
                     </ul>
                     <div class="familylinks">
                        <div class="parentlink">
                           <p><strong>父主题：</strong> <a href="joins.html#GUID-8E7760A6-48D6-4794-BF2F-290349C019B9" title="连接类型由连接条件的类型确定。">加入类型</a></p>
                        </div>
                     </div>
                  </div>
                  <a id="TGSQL95315"></a><div class="props_rev_3"><a id="GUID-44C2DD4F-8C1B-4EA5-867B-CF5A6B90A01B" name="GUID-44C2DD4F-8C1B-4EA5-867B-CF5A6B90A01B"></a><h5 id="TGSQL-GUID-44C2DD4F-8C1B-4EA5-867B-CF5A6B90A01B" class="sect5"><span class="enumeration_section">9.3.3.1</span>当优化器考虑Semijoins时</h5>
                     <div>
                        <p>当查询只需要确定是否存在匹配时，半连接可以避免返回大量行。</p>
                        <p>对于大型数据集，此优化可以比嵌套循环连接节省大量时间，嵌套循环连接必须遍历内部查询为外部查询中的每一行返回的每条记录。优化器可以将半连接优化应用于嵌套循环连接，散列连接和排序合并连接。</p>
                        <p>优化器可以在以下情况下选择半连接：</p>
                        <ul style="list-style-type:disc">
                           <li>
                              <p>该语句使用<code class="codeph">IN</code>或<code class="codeph">EXISTS</code>子句。
                              </p>
                           </li>
                           <li>
                              <p>该语句在<code class="codeph">IN</code>或<code class="codeph">EXISTS</code>子句中包含子查询。
                              </p>
                           </li>
                           <li>
                              <p><code class="codeph">IN</code>或<code class="codeph">EXISTS</code>子句不包含在<code class="codeph">OR</code>分支中。
                              </p>
                           </li>
                        </ul>
                     </div>
                     <div>
                        <div class="familylinks">
                           <div class="parentlink">
                              <p><strong>父主题：</strong> <a href="joins.html#GUID-816CED08-10A7-4B39-9790-E68996782847" title="半连接是两个数据集之间的连接，当子查询数据集中存在匹配的行时，它们从第一个集合返回一行。">Semijoins</a></p>
                           </div>
                        </div>
                     </div>
                     
                  </div><a id="TGSQL95317"></a><a id="TGSQL95318"></a><a id="TGSQL95316"></a><div class="props_rev_3"><a id="GUID-B3DE9781-0579-44D1-A7B5-3132504590E2" name="GUID-B3DE9781-0579-44D1-A7B5-3132504590E2"></a><h5 id="TGSQL-GUID-B3DE9781-0579-44D1-A7B5-3132504590E2" class="sect5"><span class="enumeration_section">9.3.3.2</span>半连接如何工作</h5>
                     <div>
                        <p>半连接优化的实现方式不同，具体取决于使用的连接类型。</p>
                        <p>以下伪代码显示嵌套循环连接的半连接：</p><pre class="pre codeblock"><code>FOR ds1_row IN ds1 LOOP match：= false; FOR ds2_row IN ds2_subquery LOOP IF（ds1_row与ds2_row匹配）THEN match：= true; EXIT  - 当找到匹配时停止处理第二个数据组END IF END LOOP IF（match = true）那么返回ds1_row END IF END LOOP</code></pre><p>在前面的伪代码中， <code class="codeph">ds1</code>是第一个数据集， <code class="codeph">ds2_subquery</code>是子查询数据集。代码从第一个数据集中获取第一行，然后遍历子查询数据集以查找匹配项。代码一找到匹配就退出内部循环，然后开始处理第一个数据集中的下一行。
                        </p>
                        <div class="example" id="GUID-B3DE9781-0579-44D1-A7B5-3132504590E2__BABGCCDA">
                           <p class="titleinexample">例9-13使用WHERE EXISTS的半连接</p>
                           <p>以下查询使用<code class="codeph">WHERE EXISTS</code>子句仅列出包含员工的部门：</p><pre class="pre codeblock"><code>SELECT department_id，department_name FROM departments WHERE EXISTS（SELECT 1 FROM employees WHERE employees.department_id = departments.department_id）</code></pre><p>执行计划显示步骤1中的<code class="codeph">NESTED LOOPS SEMI</code>操作：</p><pre class="pre codeblock"><code>-------------------------------------------------- ------------------------------ | ID |操作|名称|行|字节|成本（％CPU）|时间| -------------------------------------------------- ------------------------------ | 0 |选择声明| | | | 2（100）| | | 1 | <span class="bold">NESTED LOOPS SEMI</span> | | 11 | 209 | 2（0）| 00:00:01 | | 2 |表访问完全|部门| 27 | 432 | 2（0）| 00:00:01 | | * 3 | INDEX RANGE SCAN | EMP_DEPARTMENT_IX | 44 | 132 | 0（0）| | -------------------------------------------------- ------------------------------</code></pre><p>对于形成外部循环的<code class="codeph">departments</code>每一行，数据库获取部门ID，然后探查<code class="codeph">employees.department_id</code>索引以匹配条目。从概念上讲，该指数如下：</p><pre class="pre codeblock"><code>10，rowid 10，rowid 10，rowid 10，rowid 30，rowid 30，rowid 30，rowid ......
</code></pre><p>如果<code class="codeph">departments</code>表中的第一个条目是department <code class="codeph">30</code> ，则数据库会对索引执行范围扫描，直到找到前<code class="codeph">30</code>条目，此时它将停止读取索引并从<code class="codeph">departments</code>返回匹配的行。如果外部循环中的下一行是部门<code class="codeph">20</code> ，则数据库扫描索引以查找<code class="codeph">20</code>条目，并且找不到任何匹配项，执行外部循环的下一次迭代。数据库以这种方式继续，直到返回所有匹配的行。
                           </p>
                        </div>
                        <!-- class="example" -->
                        <div class="example" id="GUID-B3DE9781-0579-44D1-A7B5-3132504590E2__GUID-44A64557-19FF-4B01-89BD-0CC6FFAA927C">
                           <p class="titleinexample">实施例9-14使用IN的半连接</p>
                           <p>以下查询使用<code class="codeph">IN</code>子句仅列出包含员工的部门：</p><pre class="pre codeblock"><code>SELECT department_id，department_name FROM departments WHERE department_id IN（SELECT department_id FROM employees）;</code></pre><p>执行计划显示步骤1中的<code class="codeph">NESTED LOOPS SEMI</code>操作：</p><pre class="pre codeblock"><code>-------------------------------------------------- ------------------------------ | ID |操作|名称|行|字节|成本（％CPU）|时间| -------------------------------------------------- ------------------------------ | 0 |选择声明| | | | 2（100）| | | 1 | <span class="bold">NESTED LOOPS SEMI</span> | | 11 | 209 | 2（0）| 00:00:01 | | 2 |表访问完全|部门| 27 | 432 | 2（0）| 00:00:01 | | * 3 | INDEX RANGE SCAN | EMP_DEPARTMENT_IX | 44 | 132 | 0（0）| | -------------------------------------------------- ------------------------------</code></pre><p>该计划与<a href="joins.html#GUID-B3DE9781-0579-44D1-A7B5-3132504590E2__BABGCCDA">例9-13中</a>的计划相同。
                           </p>
                        </div>
                        <!-- class="example" -->
                     </div>
                     <div>
                        <div class="familylinks">
                           <div class="parentlink">
                              <p><strong>父主题：</strong> <a href="joins.html#GUID-816CED08-10A7-4B39-9790-E68996782847" title="半连接是两个数据集之间的连接，当子查询数据集中存在匹配的行时，它们从第一个集合返回一行。">Semijoins</a></p>
                           </div>
                        </div>
                     </div>
                     
                  </div>
               </div><a id="TGSQL95320"></a><div class="props_rev_3"><a id="GUID-084D65F8-0517-4B85-960F-F1CDEE69C693" name="GUID-084D65F8-0517-4B85-960F-F1CDEE69C693"></a><h4 id="TGSQL-GUID-084D65F8-0517-4B85-960F-F1CDEE69C693" class="sect4"><span class="enumeration_section">9.3.4</span>反连接</h4>
                  <div>
                     <p><strong class="term">反</strong>连接是两个数据集之间的连接，当子查询数据集中不存在匹配的行时，这两个数据集从第一个集合返回一行。
                     </p>
                     <p>像半连接一样，反连接在找到第一个匹配时停止处理子查询数据集。与半连接不同，反连接仅在未找到匹配时返回一行。</p>
                     <p>本节包含以下主题：</p>
                  </div>
                  <div>
                     <ul class="ullinks">
                        <li class="ulchildlink"><a href="joins.html#GUID-4FBBDD86-2AC0-425F-B3A6-36E72A423876">当优化器考虑反连接时</a><br>当查询仅在匹配不存在时需要返回行时，反连接避免了不必要的处理。
                        </li>
                        <li class="ulchildlink"><a href="joins.html#GUID-D20C1B6F-9CFF-4F4A-87F3-D1A2BEEBEFF3">反连接是如何工作的</a><br>反连接优化的实现方式不同，具体取决于使用的连接类型。
                        </li>
                        <li class="ulchildlink"><a href="joins.html#GUID-78F90A8B-3638-47FF-AEFC-274790BE45D8">反连接如何处理空</a><br>对于半连接， <code class="codeph">IN</code>和<code class="codeph">EXISTS</code>在功能上是等同的。但是，由于空值， <code class="codeph">NOT IN</code>和<code class="codeph">NOT EXISTS</code>在功能上不等效。
                        </li>
                     </ul>
                     <div class="familylinks">
                        <div class="parentlink">
                           <p><strong>父主题：</strong> <a href="joins.html#GUID-8E7760A6-48D6-4794-BF2F-290349C019B9" title="连接类型由连接条件的类型确定。">加入类型</a></p>
                        </div>
                     </div>
                  </div>
                  <a id="TGSQL95321"></a><div class="props_rev_3"><a id="GUID-4FBBDD86-2AC0-425F-B3A6-36E72A423876" name="GUID-4FBBDD86-2AC0-425F-B3A6-36E72A423876"></a><h5 id="TGSQL-GUID-4FBBDD86-2AC0-425F-B3A6-36E72A423876" class="sect5"><span class="enumeration_section">9.3.4.1</span>优化器考虑反连接时</h5>
                     <div>
                        <p>当查询仅在匹配不存在时需要返回行时，反连接避免了不必要的处理。</p>
                        <p>对于大型数据集，此优化可以比嵌套循环连接节省大量时间。后一个连接必须遍历外部查询中每一行的内部查询返回的每个记录。优化器可以将反连接优化应用于嵌套循环连接，散列连接和排序合并连接。</p>
                        <p>优化器可以在以下情况下选择反连接：</p>
                        <ul style="list-style-type:disc">
                           <li>
                              <p>该语句使用<code class="codeph">NOT IN</code>或<code class="codeph">NOT EXISTS</code>子句。
                              </p>
                           </li>
                           <li>
                              <p>该语句在<code class="codeph">NOT IN</code>或<code class="codeph">NOT EXISTS</code>子句中有一个子查询。
                              </p>
                           </li>
                           <li>
                              <p><code class="codeph">OR</code> <code class="codeph">NOT IN</code>或<code class="codeph">NOT EXISTS</code>子句不包含在<code class="codeph">OR</code>分支中。
                              </p>
                           </li>
                           <li>
                              <p>该语句执行外连接并将<code class="codeph">IS NULL</code>条件应用于连接列，如以下示例所示：</p><pre class="pre codeblock"><code>SET AUTOTRACE TRACEONLY EXPLAIN SELECT emp。* FROM emp，dept WHERE emp.deptno = dept.deptno（+）AND dept.deptno IS NULL执行计划-------------------------- --------------------------------计划哈希值：1543991079 ------------- -------------------------------------------------- ------------ | Id |操作|名称|行|字节|成本（％CPU）|时间| -------------------------------------------------- ------------------------- | 0 |选择声明| | 14 | 1400 | 5（20）| 00:00:01 | | * 1 | HASH JOIN ANTI | | 14 | 1400 | 5（20）| 00:00:01 | | 2 |表访问完全| EMP | 14 | 1218 | 2（0）| 00:00:01 | | 3 |表访问完全| DEPT | 4 | 52 | 2（0）| 00:00:01 | -------------------------------------------------- -------------------------谓词信息（由操作ID标识）：---------------- ----------------------------------- 1  -  access（“EMP”。“DEPTNO”=“DEPT” 。“DEPTNO”）注意-----  - 使用的动态统计：动态采样（级别= 2）</code></pre></li>
                        </ul>
                     </div>
                     <div>
                        <div class="familylinks">
                           <div class="parentlink">
                              <p><strong>父主题：</strong> <a href="joins.html#GUID-084D65F8-0517-4B85-960F-F1CDEE69C693" title="反连接是两个数据集之间的连接，当子查询数据集中不存在匹配的行时，它们从第一个集合返回一行。">反连接</a></p>
                           </div>
                        </div>
                     </div>
                     
                  </div><a id="TGSQL95323"></a><a id="TGSQL95322"></a><div class="props_rev_3"><a id="GUID-D20C1B6F-9CFF-4F4A-87F3-D1A2BEEBEFF3" name="GUID-D20C1B6F-9CFF-4F4A-87F3-D1A2BEEBEFF3"></a><h5 id="TGSQL-GUID-D20C1B6F-9CFF-4F4A-87F3-D1A2BEEBEFF3" class="sect5"><span class="enumeration_section">9.3.4.2</span>反连接的工作原理</h5>
                     <div>
                        <p>反连接优化的实现方式不同，具体取决于使用的连接类型。</p>
                        <p>以下伪代码显示嵌套循环连接的反连接：</p><pre class="pre codeblock"><code>FOR ds1_row IN ds1 LOOP match：= true; FOR ds2_row IN ds2 LOOP IF（ds1_row与ds2_row匹配）THEN match：= false; EXIT  - 当找到匹配时停止处理第二个数据组END IF END LOOP IF（match = true）那么返回ds1_row END IF END LOOP</code></pre><p>在前面的伪代码中， <code class="codeph">ds1</code>是第一个数据集， <code class="codeph">ds2</code>是第二个数据集。代码从第一个数据集中获取第一行，然后遍历第二个数据集以查找匹配项。代码一找到匹配就退出内部循环，并开始处理第一个数据集中的下一行。
                        </p>
                        <div class="example" id="GUID-D20C1B6F-9CFF-4F4A-87F3-D1A2BEEBEFF3__GUID-303A36E3-2961-4385-9A5A-4A3B85482BDA">
                           <p class="titleinexample">例9-15使用WHERE EXISTS的半连接</p>
                           <p>以下查询使用<code class="codeph">WHERE EXISTS</code>子句仅列出包含员工的部门：</p><pre class="pre codeblock"><code>SELECT department_id，department_name FROM departments WHERE EXISTS（SELECT 1 FROM employees WHERE employees.department_id = departments.department_id）</code></pre><p>执行计划显示步骤1中的<code class="codeph">NESTED LOOPS SEMI</code>操作：</p><pre class="pre codeblock"><code>-------------------------------------------------- ------------------------------ | ID |操作|名称|行|字节|成本（％CPU）|时间| -------------------------------------------------- ------------------------------ | 0 |选择声明| | | | 2（100）| | | 1 | <span class="bold">NESTED LOOPS SEMI</span> | | 11 | 209 | 2（0）| 00:00:01 | | 2 |表访问完全|部门| 27 | 432 | 2（0）| 00:00:01 | | * 3 | INDEX RANGE SCAN | EMP_DEPARTMENT_IX | 44 | 132 | 0（0）| | -------------------------------------------------- ------------------------------</code></pre><p>对于形成外部循环的<code class="codeph">departments</code>每一行，数据库获取部门ID，然后探查<code class="codeph">employees.department_id</code>索引以匹配条目。从概念上讲，该指数如下：</p><pre class="pre codeblock"><code>10，rowid 10，rowid 10，rowid 10，rowid 30，rowid 30，rowid 30，rowid ......
</code></pre><p>如果<code class="codeph">departments</code>表中的第一个记录是部门<code class="codeph">30</code> ，则数据库会对索引执行范围扫描，直到找到前<code class="codeph">30</code>条目，此时它将停止读取索引并从<code class="codeph">departments</code>返回匹配的行。如果外部循环中的下一行是部门<code class="codeph">20</code> ，则数据库扫描索引以查找<code class="codeph">20</code>条目，并且找不到任何匹配项，执行外部循环的下一次迭代。数据库以这种方式继续，直到返回所有匹配的行。
                           </p>
                        </div>
                        <!-- class="example" -->
                     </div>
                     <div>
                        <div class="familylinks">
                           <div class="parentlink">
                              <p><strong>父主题：</strong> <a href="joins.html#GUID-084D65F8-0517-4B85-960F-F1CDEE69C693" title="反连接是两个数据集之间的连接，当子查询数据集中不存在匹配的行时，它们从第一个集合返回一行。">反连接</a></p>
                           </div>
                        </div>
                     </div>
                     
                  </div><a id="TGSQL95325"></a><a id="TGSQL95326"></a><a id="TGSQL95324"></a><div class="props_rev_3"><a id="GUID-78F90A8B-3638-47FF-AEFC-274790BE45D8" name="GUID-78F90A8B-3638-47FF-AEFC-274790BE45D8"></a><h5 id="TGSQL-GUID-78F90A8B-3638-47FF-AEFC-274790BE45D8" class="sect5"><span class="enumeration_section">9.3.4.3反连接</span>如何处理空值</h5>
                     <div>
                        <p>对于半连接， <code class="codeph">IN</code>和<code class="codeph">EXISTS</code>在功能上是等同的。但是，由于空值， <code class="codeph">NOT IN</code>和<code class="codeph">NOT EXISTS</code>在功能上不等效。
                        </p>
                        <p>如果将null值返回给<code class="codeph">NOT IN</code>运算符，则该语句不返回任何记录。要了解原因，请考虑以下<code class="codeph">WHERE</code>子句：</p><pre class="pre codeblock"><code>WHERE department_id NOT IN（null，10,20）</code></pre><p>数据库测试前面的表达式如下：</p><pre class="pre codeblock"><code>WHERE（department_id！= null）AND（department_id！= 10）AND（department_id！= 20）</code></pre><p>要使整个表达式<code class="codeph">true</code> ，每个条件必须为<code class="codeph">true</code> 。但是，null值无法与其他值进行比较，因此<code class="codeph">department_id !=null</code>条件不能为<code class="codeph">true</code> ，因此整个表达式始终为<code class="codeph">false</code> 。即使将null返回给<code class="codeph">NOT IN</code>运算符，以下技术也使语句能够返回记录：</p>
                        <ul style="list-style-type:disc">
                           <li>
                              <p>将<code class="codeph">NVL</code>函数应用于子查询返回的列。
                              </p>
                           </li>
                           <li>
                              <p>向子查询添加<code class="codeph">IS NOT NULL</code>谓词。
                              </p>
                           </li>
                           <li>
                              <p>实现<code class="codeph">NOT NULL</code>约束。
                              </p>
                           </li>
                        </ul>
                        <p>与<code class="codeph">NOT IN</code> ， <code class="codeph">NOT EXISTS</code>子句仅考虑返回匹配存在的谓词，并忽略由于空值而不匹配或无法确定的任何行。如果子查询中至少有一行与外部查询中的行匹配，则<code class="codeph">NOT EXISTS</code>返回<code class="codeph">false</code> 。如果没有元组匹配，则<code class="codeph">NOT EXISTS</code>返回<code class="codeph">true</code> 。子查询中存在空值不会影响匹配记录的搜索。
                        </p>
                        <p>在<span>Oracle Database 11g</span>之前的版本中，当子查询返回null时，优化器无法使用反连接优化。但是，从<span>Oracle Database 11g</span>开始，以下各节中描述的<code class="codeph">ANTI NA</code> （和<code class="codeph">ANTI SNA</code> ）优化使优化器即使在可能为空时也可以使用反连接。
                        </p>
                        <div class="example" id="GUID-78F90A8B-3638-47FF-AEFC-274790BE45D8__GUID-1069AEBC-187C-41B2-AC0C-A4793780B755">
                           <p class="titleinexample">例9-16使用NOT IN的反连接</p>
                           <p>假设用户使用<code class="codeph">NOT IN</code>子句发出以下查询以列出不包含员工的部门：</p><pre class="pre codeblock"><code>SELECT department_id，department_name FROM departments WHERE department_id NOT IN（SELECT department_id FROM employees）;</code></pre><p>即使多个部门不包含员工，上述查询也不返回任何行。由于<code class="codeph">employees.department_id</code>列可以为空，因此出现了用户不想要的结果。
                           </p>
                           <p>执行计划在步骤2中显示<code class="codeph">NESTED LOOPS ANTI SNA</code>操作：</p><pre class="pre codeblock"><code>-------------------------------------------------- ------------------------------ | ID |操作|名称|行|字节|成本（％CPU）|时间| -------------------------------------------------- ------------------------------ | 0 |选择声明| | | | 4（100）| | | * 1 |过滤器| | | | | | | 2 | <span class="bold">NESTED LOOPS ANTI SNA</span> | | 17 | 323 | 4（50）| 00:00:01 | | 3 |表访问完全|部门| 27 | 432 | 2（0）| 00:00:01 | | * 4 | INDEX RANGE SCAN | EMP_DEPARTMENT_IX | 41 | 123 | 0（0）| | | * 5 |表访问完全|员工| 1 | 3 | 2（0）| 00:00:01 | -------------------------------------------------- ------------------------------ PLAN_TABLE_OUTPUT ------------------- -------------------------------------------------- -----------谓词信息（由操作ID标识）：------------------------------ --------------------- 1  -  filter（IS NULL）4  -  access（“DEPARTMENT_ID”=“DEPARTMENT_ID”）5  -  filter（“DEPARTMENT_ID”为空）</code></pre><p><code class="codeph">ANTI SNA</code>代表“单一无效的反连接”。 <code class="codeph">ANTI NA</code>代表“null-aware antijoin”。 null-aware操作使优化器甚至可以在可空列上使用反连接优化。在早于<span>Oracle Database 11g的版本中</span> ，当可能为空时，数据库无法对<code class="codeph">NOT IN</code>查询执行反连接。
                           </p>
                           <p>假设用户通过对子查询应用<code class="codeph">IS NOT NULL</code>条件来重写查询：</p><pre class="pre codeblock"><code>SELECT department_id，department_name FROM departments WHERE department_id NOT IN（SELECT department_id FROM employees WHERE department_id IS NOT NULL）;</code></pre><p>前面的查询返回16行，这是预期的结果。计划中的步骤1显示标准的<code class="codeph">NESTED LOOPS ANTI</code>连接，而不是<code class="codeph">ANTI NA</code>或<code class="codeph">ANTI SNA</code>连接，因为子查询不能返回空值：</p><pre class="pre codeblock"><code>-------------------------------------------------- ------------------------------ | Id |操作|名称|行|字节|成本（％CPU）|时间| -------------------------------------------------- ------------------------------ | 0 |选择声明| | | | 2（100）| | | 1 | <span class="bold">NESTED LOOPS ANTI</span> | | 17 | 323 | 2（0）| 00:00:01 | | 2 |表访问完全|部门| 27 | 432 | 2（0）| 00:00:01 | | * 3 | INDEX RANGE SCAN | EMP_DEPARTMENT_IX | 41 | 123 | 0（0）| <span class="italic">| -------------------------------------------------- ------------------------------</span> PLAN_TABLE_OUTPUT ------------------- -------------------------------------------------- -----------谓词信息（由操作ID标识）：------------------------------ --------------------- 3  - 访问（“DEPARTMENT_ID”=“DEPARTMENT_ID”）过滤器（“DEPARTMENT_ID”不为空）</code></pre></div>
                        <!-- class="example" -->
                        <div class="example" id="GUID-78F90A8B-3638-47FF-AEFC-274790BE45D8__GUID-7F2A4EB0-C2CE-43D4-ADF4-CBFDA8BFB351">
                           <p class="titleinexample">例9-17使用NOT EXISTS的反连接</p>
                           <p>假设用户使用<code class="codeph">NOT EXISTS</code>子句发出以下查询，以列出不包含员工的部门：</p><pre class="pre codeblock"><code>SELECT department_id，department_name FROM departments d WHERE NOT EXISTS（SELECT FROM FROM FROM e WHERE e.department_id = d.department_id）</code></pre><p>前面的查询避免了<code class="codeph">NOT IN</code>子句的null问题。因此，即使<code class="codeph">employees.department_id</code>列可以为空，该语句也会返回所需的结果。
                           </p>
                           <p>执行计划的第1步显示了<code class="codeph">NESTED LOOPS ANTI</code>操作，而不是<code class="codeph">ANTI NA</code>变体，当可能为空时， <code class="codeph">NOT IN</code>是必需的：</p><pre class="pre codeblock"><code>-------------------------------------------------- ------------------------------ | ID |操作|名称|行|字节|成本（％CPU）|时间| -------------------------------------------------- ------------------------------ | 0 |选择声明| | | | 2（100）| | | 1 | NESTED LOOPS ANTI | | 17 | 323 | 2（0）| 00:00:01 | | 2 |表访问完全|部门| 27 | 432 | 2（0）| 00:00:01 | | * 3 | INDEX RANGE SCAN | EMP_DEPARTMENT_IX | 41 | 123 | 0（0）| | -------------------------------------------------- ------------------------------ PLAN_TABLE_OUTPUT ------------------- -------------------------------------------------- -----------谓词信息（由操作ID标识）：------------------------------ --------------------- 3  -  access（“E”。“DEPARTMENT_ID”=“D”。“DEPARTMENT_ID”）</code></pre></div>
                        <!-- class="example" -->
                     </div>
                     <div>
                        <div class="familylinks">
                           <div class="parentlink">
                              <p><strong>父主题：</strong> <a href="joins.html#GUID-084D65F8-0517-4B85-960F-F1CDEE69C693" title="反连接是两个数据集之间的连接，当子查询数据集中不存在匹配的行时，它们从第一个集合返回一行。">反连接</a></p>
                           </div>
                        </div>
                     </div>
                     
                  </div>
               </div><a id="TGSQL94986"></a><div class="props_rev_3"><a id="GUID-07D9388C-6DCB-4F88-BF59-AF223C10B8FC" name="GUID-07D9388C-6DCB-4F88-BF59-AF223C10B8FC"></a><h4 id="TGSQL-GUID-07D9388C-6DCB-4F88-BF59-AF223C10B8FC" class="sect4"><span class="enumeration_section">9.3.5</span>笛卡尔连接</h4>
                  <div>
                     <p>当一个或多个表与语句中的任何其他表没有任何连接条件时，数据库使用<strong class="term">笛卡尔连接</strong> 。
                     </p>
                     <p>优化器将来自一个数据源的每一行与来自另一个数据源的每一行连接起来，从而创建两组的笛卡尔积。因此，使用以下公式计算连接产生的总行数，其中<code class="codeph">rs1</code>是第一行集中的行数， <code class="codeph">rs2</code>是第二行集中的行数：</p><pre class="pre codeblock"><code>rs1 X rs2 =结果集中的总行数</code></pre><p>本节包含以下主题：</p>
                  </div>
                  <div>
                     <ul class="ullinks">
                        <li class="ulchildlink"><a href="joins.html#GUID-11E7100E-1316-4963-83C5-A85940BE9BB6">当优化器考虑笛卡尔连接时</a><br>优化程序仅在特定情况下对两个行源使用笛卡尔连接。
                        </li>
                        <li class="ulchildlink"><a href="joins.html#GUID-531732AA-D0B0-4DFA-A5B9-8EDC3359BE67">笛卡尔如何加入工作</a><br>笛卡尔连接使用嵌套的<code class="codeph">FOR</code>循环。
                        </li>
                        <li class="ulchildlink"><a href="joins.html#GUID-10F781A7-4372-4042-AACA-6F67580789E8">笛卡尔加入控制</a><br><code class="codeph">ORDERED</code>提示指示优化器按照它们在<code class="codeph">FROM</code>子句中出现的顺序连接表。通过强制两个没有直接连接的行源之间的连接，优化器必须执行笛卡尔连接。
                        </li>
                     </ul>
                     <div class="familylinks">
                        <div class="parentlink">
                           <p><strong>父主题：</strong> <a href="joins.html#GUID-8E7760A6-48D6-4794-BF2F-290349C019B9" title="连接类型由连接条件的类型确定。">加入类型</a></p>
                        </div>
                     </div>
                  </div>
                  <a id="TGSQL94987"></a><div class="props_rev_3"><a id="GUID-11E7100E-1316-4963-83C5-A85940BE9BB6" name="GUID-11E7100E-1316-4963-83C5-A85940BE9BB6"></a><h5 id="TGSQL-GUID-11E7100E-1316-4963-83C5-A85940BE9BB6" class="sect5"><span class="enumeration_section">9.3.5.1</span>当优化器考虑笛卡尔连接时</h5>
                     <div>
                        <p>优化程序仅在特定情况下对两个行源使用笛卡尔连接。</p>
                        <p>通常，情况是以下之一：</p>
                        <ul style="list-style-type:disc">
                           <li>
                              <p>没有连接条件。</p>
                              <p>在某些情况下，优化器可以在两个表之间选择一个公共<a href="glossary.html#GUID-73A2A2BA-68CB-4036-BB5C-3CBB5D799286"><span class="xrefglossterm">过滤条件</span></a>作为可能的连接条件。
                              </p>
                              <div class="infoboxnote" id="GUID-11E7100E-1316-4963-83C5-A85940BE9BB6__GUID-40D78C19-08DE-4B54-B787-4288929C179D">
                                 <p class="notep1">注意：</p>
                                 <p>如果在查询计划中出现笛卡尔联接，则可能是由于无意中省略了连接条件。通常，如果查询连接<span class="italic">n个</span>表，则需要<span class="italic">n</span> -1个连接条件以避免笛卡尔连接。
                                 </p>
                              </div>
                           </li>
                           <li>
                              <p>笛卡尔连接是一种有效的方法。</p>
                              <p>例如，优化器可能决定生成两个非常小的表的笛卡尔积，这两个表都连接到同一个大表。</p>
                           </li>
                           <li>
                              <p><code class="codeph">ORDERED</code>提示指定在指定连接表之前的表。
                              </p>
                           </li>
                        </ul>
                     </div>
                     <div>
                        <div class="familylinks">
                           <div class="parentlink">
                              <p><strong>父主题：</strong> <a href="joins.html#GUID-07D9388C-6DCB-4F88-BF59-AF223C10B8FC" title="当一个或多个表与语句中的任何其他表没有任何连接条件时，数据库使用笛卡尔连接。">笛卡尔连接</a></p>
                           </div>
                        </div>
                     </div>
                     
                  </div><a id="TGSQL95334"></a><a id="TGSQL95312"></a><div class="props_rev_3"><a id="GUID-531732AA-D0B0-4DFA-A5B9-8EDC3359BE67" name="GUID-531732AA-D0B0-4DFA-A5B9-8EDC3359BE67"></a><h5 id="TGSQL-GUID-531732AA-D0B0-4DFA-A5B9-8EDC3359BE67" class="sect5"><span class="enumeration_section">9.3.5.2</span>笛卡尔连接的工作原理</h5>
                     <div>
                        <p>笛卡尔连接使用嵌套的<code class="codeph">FOR</code>循环。
                        </p>
                        <p>在较高级别，笛卡尔连接的算法如下所示，其中<code class="codeph">ds1</code>通常是较小的数据集， <code class="codeph">ds2</code>是较大的数据集：</p><pre class="pre codeblock"><code>FOR ds1_row IN ds1 LOOP用于ds2_row IN ds2 LOOP输出ds1_row和ds2_row END LOOP END LOOP</code></pre><div class="example" id="GUID-531732AA-D0B0-4DFA-A5B9-8EDC3359BE67__GUID-54BCE493-6E47-4A9B-A816-6C5CB2A6A36D">
                           <p class="titleinexample">例9-18笛卡尔加入</p>
                           <p>在此示例中，用户打算执行<code class="codeph">employees</code>和<code class="codeph">departments</code>表的内部联接，但意外地忽略了联接条件：</p><pre class="pre codeblock"><code>SELECT e.last_name，d.department_name FROM employees e，departments d</code></pre><p>执行计划如下：</p><pre class="pre codeblock"><code>-------------------------------------------------- ------------------------------ | ID |操作|名称|行|字节|成本（％CPU）|时间| -------------------------------------------------- ------------------------------ | 0 |选择声明| | | | 11（100）| | | 1 | MERGE加入笛卡尔| | 2889 | 57780 | 11（0）| 00:00:01 | | 2 |表访问完全|部门| 27 | 324 | 2（0）| 00:00:01 | | 3 | BUFFER SORT | | 107 | 856 | 9（0）| 00:00:01 | | 4 | INDEX FAST FULL SCAN | EMP_NAME_IX | 107 | 856 | 0（0）| | -------------------------------------------------- ------------------------------</code></pre><p>在上一个计划的第1步中， <code class="codeph">CARTESIAN</code>关键字表示存在笛卡尔连接。行数（2889）是27和107的乘积。
                           </p>
                           <p>在步骤3中， <code class="codeph">BUFFER SORT</code>操作指示数据库正在将通过扫描<code class="codeph">emp_name_ix</code>获得的数据块从SGA复制到PGA。此策略避免对数据库缓冲区高速缓存中的相同块进行多次扫描，这将生成许多逻辑读取并允许资源争用。
                           </p>
                        </div>
                        <!-- class="example" -->
                     </div>
                     <div>
                        <div class="familylinks">
                           <div class="parentlink">
                              <p><strong>父主题：</strong> <a href="joins.html#GUID-07D9388C-6DCB-4F88-BF59-AF223C10B8FC" title="当一个或多个表与语句中的任何其他表没有任何连接条件时，数据库使用笛卡尔连接。">笛卡尔连接</a></p>
                           </div>
                        </div>
                     </div>
                     
                  </div><a id="TGSQL95335"></a><a id="TGSQL94988"></a><div class="props_rev_3"><a id="GUID-10F781A7-4372-4042-AACA-6F67580789E8" name="GUID-10F781A7-4372-4042-AACA-6F67580789E8"></a><h5 id="TGSQL-GUID-10F781A7-4372-4042-AACA-6F67580789E8" class="sect5"><span class="enumeration_section">9.3.5.3</span>笛卡尔连接控制</h5>
                     <div>
                        <p><code class="codeph">ORDERED</code>提示指示优化器按照它们在<code class="codeph">FROM</code>子句中出现的顺序连接表。通过强制两个没有直接连接的行源之间的连接，优化器必须执行笛卡尔连接。
                        </p>
                        <div class="example" id="GUID-10F781A7-4372-4042-AACA-6F67580789E8__GUID-AB86E0AE-4B94-422B-A3F0-AAC889EBE7B2">
                           <p class="titleinexample">例9-19 ORDERED提示</p>
                           <p>在以下示例中， <code class="codeph">ORDERED</code>提示指示优化器加入<code class="codeph">employees</code>和<code class="codeph">locations</code> ，但没有连接条件连接这两个行源：</p><pre class="pre codeblock"><code>SELECT / * + ORDERED * / e.last_name，d.department_name，l.country_id，l.state_province FROM employees e，locations l，departments d WHERE e.department_id = d.department_id AND d.location_id = l.location_id</code></pre><p>以下执行计划显示<code class="codeph">locations</code> （步骤6）和<code class="codeph">employees</code> （步骤4）之间的笛卡尔积（步骤3），然后将其连接到<code class="codeph">departments</code>表（步骤2）：</p><pre class="pre codeblock"><code>-------------------------------------------------- ------------------------------ | ID |操作|名称|行|字节|成本（％CPU）|时间| -------------------------------------------------- ------------------------------ | 0 |选择声明| | | | 37（100）| | | * 1 | HASH JOIN | | 106 | 4664 | 37（6）| 00:00:01 | | 2 |表访问完全|部门| 27 | 513 | 2（0）| 00:00:01 | | 3 | <span class="bold">MERGE加入笛卡尔</span> | | 2461 | 61525 | 34（3）| 00:00:01 | | 4 |表访问完全|员工| 107 | 1177 | 2（0）| 00:00:01 | | 5 | BUFFER SORT | | 23 | 322 | 32（4）| 00:00:01 | | 6 |表访问完全|地点| 23 | 322 | 0（0）| | -------------------------------------------------- ------------------------------</code></pre></div>
                        <!-- class="example" -->
                     </div>
                     <div>
                        <div class="infoboxnotealso" id="GUID-10F781A7-4372-4042-AACA-6F67580789E8__GUID-B23F120A-6C94-4F5F-8C71-825480526BC0">
                           <p class="notep1">也可以看看：</p>
                           <p><a href="https://www.oracle.com/pls/topic/lookup?ctx=en/database/oracle/oracle-database/19/tgsql&amp;id=SQLRF50601" target="_blank"><span><cite>Oracle Database SQL语言参考</cite></span></a>了解<code class="codeph">ORDERED</code>提示</p>
                        </div>
                        <div class="familylinks">
                           <div class="parentlink">
                              <p><strong>父主题：</strong> <a href="joins.html#GUID-07D9388C-6DCB-4F88-BF59-AF223C10B8FC" title="当一个或多个表与语句中的任何其他表没有任何连接条件时，数据库使用笛卡尔连接。">笛卡尔连接</a></p>
                           </div>
                        </div>
                     </div>
                     
                  </div>
               </div>
            </div><a id="TGSQL95297"></a><div class="props_rev_3"><a id="GUID-C02C3673-75E2-4D92-AAEF-30AC58C32AD1" name="GUID-C02C3673-75E2-4D92-AAEF-30AC58C32AD1"></a><h3 id="TGSQL-GUID-C02C3673-75E2-4D92-AAEF-30AC58C32AD1" class="sect3"><span class="enumeration_section">9.4</span>加入优化</h3>
               <div>
                  <p>连接优化使连接更有效。</p>
                  <p>本节介绍常见的连接优化：</p>
               </div>
               <div>
                  <ul class="ullinks">
                     <li class="ulchildlink"><a href="joins.html#GUID-C9E0663B-822E-4733-8016-E56A73D903F3">布隆过滤器</a><br><strong class="term">Bloom过滤器</strong>以其创建者Burton Bloom命名，是一种低内存数据结构，用于测试集合中的成员资格。
                     </li>
                     <li class="ulchildlink"><a href="joins.html#GUID-3932756E-EDFC-4D4D-93CD-9F9F2AE2C2D7">分区 - 明智的加入</a><br><strong class="term">分区连接</strong>是一种优化，它将两个表的大连接（其中一个必须在连接键上分区）划分为几个较小的连接。
                     </li>
                     <li class="ulchildlink"><a href="joins.html#GUID-D9A7B0F6-D2D4-4881-9A6C-8042DE627650">内存中加入组</a><br><span class="bold">连接组</span>是用户创建的对象，它列出了两个或多个可以有意义连接的列。
                     </li>
                  </ul>
                  <div class="familylinks">
                     <div class="parentlink">
                        <p><strong>父主题：</strong> <a href="joins.html#GUID-BD96F1B4-76D4-43DF-98B6-D07F46838C4A" title="Oracle数据库为加入行集提供了多种优化。">联接</a></p>
                     </div>
                  </div>
               </div>
               <a id="TGSQL95298"></a><div class="props_rev_3"><a id="GUID-C9E0663B-822E-4733-8016-E56A73D903F3" name="GUID-C9E0663B-822E-4733-8016-E56A73D903F3"></a><h4 id="TGSQL-GUID-C9E0663B-822E-4733-8016-E56A73D903F3" class="sect4"><span class="enumeration_section">9.4.1</span>布隆过滤器</h4>
                  <div>
                     <p><strong class="term">Bloom过滤器</strong>以其创建者Burton Bloom命名，是一种低内存数据结构，用于测试集合中的成员资格。
                     </p>
                     <p>Bloom过滤器正确指示元素何时不在集合中，但可能错误地指示元素何时在集合中。因此，假阴性是不可能的，但误报是可能的。</p>
                     <p>本节包含以下主题：</p>
                  </div>
                  <div>
                     <ul class="ullinks">
                        <li class="ulchildlink"><a href="joins.html#GUID-3B016FCE-13E4-43E3-884E-ED0B212FC9F5">布隆过滤器的目的</a><br>Bloom过滤器测试一组值以确定它们是否是另一组的成员。
                        </li>
                        <li class="ulchildlink"><a href="joins.html#GUID-D158E3CF-1B10-4391-A1C6-639216623A35">布隆过滤器的工作原理</a><br>Bloom过滤器使用位数组来指示包含在集合中。
                        </li>
                        <li class="ulchildlink"><a href="joins.html#GUID-BBC13BB9-9BDC-439C-9A05-974F0FAFFF0C">布隆过滤器控件</a><br>优化程序自动确定是否使用Bloom过滤器。
                        </li>
                        <li class="ulchildlink"><a href="joins.html#GUID-BB21BC10-031D-4E43-9774-92764BF84FA4">Bloom过滤元数据</a><br><code class="codeph">V$</code>视图包含有关Bloom过滤器的元数据。
                        </li>
                        <li class="ulchildlink"><a href="joins.html#GUID-8E7B4239-B6B2-423E-94D1-DED4338C0077">布隆过滤器：场景</a><br>在此示例中，并行查询将<code class="codeph">sales</code>事实表连接到<code class="codeph">products</code>和<code class="codeph">times</code>维度表，并在财务周<code class="codeph">18</code>上过滤。
                        </li>
                     </ul>
                     <div class="familylinks">
                        <div class="parentlink">
                           <p><strong>父主题：</strong> <a href="joins.html#GUID-C02C3673-75E2-4D92-AAEF-30AC58C32AD1" title="连接优化使连接更有效。">加入优化</a></p>
                        </div>
                     </div>
                  </div>
                  <a id="TGSQL95299"></a><div class="props_rev_3"><a id="GUID-3B016FCE-13E4-43E3-884E-ED0B212FC9F5" name="GUID-3B016FCE-13E4-43E3-884E-ED0B212FC9F5"></a><h5 id="TGSQL-GUID-3B016FCE-13E4-43E3-884E-ED0B212FC9F5" class="sect5"><span class="enumeration_section">9.4.1.1</span>布隆过滤器的用途</h5>
                     <div>
                        <p>Bloom过滤器测试一组值以确定它们是否是另一组的成员。</p>
                        <p>例如，一组是（10,20,30,40），第二组是（10,30,60,70）。Bloom过滤器可以确定<span class="italic">保证</span>从第一组中排除60和70，并且10和30 <span class="italic">可能是</span>成员。当存储过滤器所需的内存量相对于数据集中的数据量较小时，以及当预期大多数数据未通过成员资格测试时，Bloom过滤器尤其有用。</p>
                        <p>Oracle数据库使用Bloom过滤器来实现各种特定目标，包括：</p>
                        <ul style="list-style-type:disc">
                           <li>
                              <p>减少并行查询中传输到从属进程的数据量，尤其是当数据库丢弃大多数行时，因为它们不满足连接条件</p>
                           </li>
                           <li>
                              <p>在连接中构建分区访问列表时消除不需要的分区，称为<span class="italic">分区修剪</span></p>
                           </li>
                           <li>
                              <p>测试服务器结果缓存中是否存在数据，从而避免磁盘读取</p>
                           </li>
                           <li>
                              <p>过滤Exadata单元格中的成员，尤其是在星型模式中连接大型事实表和小维度表时</p>
                           </li>
                        </ul>
                        <p>布隆过滤器可以在并行和串行处理中进行。</p>
                     </div>
                     <div>
                        <div class="familylinks">
                           <div class="parentlink">
                              <p><strong>父主题：</strong> <a href="joins.html#GUID-C9E0663B-822E-4733-8016-E56A73D903F3" title="Bloom过滤器以其创建者Burton Bloom命名，是一种低内存数据结构，用于测试集合中的成员资格。">布隆过滤器</a></p>
                           </div>
                        </div>
                     </div>
                     
                  </div><a id="TGSQL95300"></a><div class="props_rev_3"><a id="GUID-D158E3CF-1B10-4391-A1C6-639216623A35" name="GUID-D158E3CF-1B10-4391-A1C6-639216623A35"></a><h5 id="TGSQL-GUID-D158E3CF-1B10-4391-A1C6-639216623A35" class="sect5"><span class="enumeration_section">9.4.1.2</span> Bloom过滤器的工作原理</h5>
                     <div>
                        <p>Bloom过滤器使用位数组来指示包含在集合中。</p>
                        <p>例如，数组中的8个元素（此示例中使用的任意数字）最初设置为<code class="codeph">0</code> ：</p><pre class="pre codeblock"><code>e1 e2 e3 e4 e5 e6 e7 e8 0 0 0 0 0 0 0 0</code></pre><p>该数组表示一组。为了表示此数组中的输入值<span class="italic">i</span> ，将三个单独的散列函数（三个是任意的）应用于<span class="italic">i</span> ，每个散列函数生成<code class="codeph">1</code>到<code class="codeph">8</code>之间的散列值：</p><pre class="pre codeblock"><code>f1（i）= h1 f2（i）= h2 f3（i）= h3</code></pre><p>例如，要将值<code class="codeph">17</code>存储在此数组中，散列函数将<span class="italic">i</span>设置为<code class="codeph">17</code> ，然后返回以下散列值：</p><pre class="pre codeblock"><code>f1（17）= 5 f2（17）= 3 f3（17）= 5</code></pre><p>在前面的示例中，两个哈希函数碰巧返回相同的值<code class="codeph">5</code> ，称为<span class="italic">哈希冲突</span> 。因为不同的散列值是<code class="codeph">5</code>和<code class="codeph">3</code> ，所以数组中的第5和第3个元素设置为<code class="codeph">1</code> ：</p><pre class="pre codeblock"><code>e1 e2 e3 e4 e5 e6 e7 e8 0 0 1 0 1 0 0 0</code></pre><p>在集合中测试<code class="codeph">17</code>的成员资格会逆转该过程。要测试集合是否<span class="italic">排除</span>值<code class="codeph">17</code> ，元素<code class="codeph">3</code>或元素<code class="codeph">5</code>必须包含<code class="codeph">0</code> 。如果任一元素中都存在<code class="codeph">0</code> ，则该集合不能包含<code class="codeph">17</code> 。不可能存在误报。
                        </p>
                        <p>要测试集合是否<span class="italic">包含</span> <code class="codeph">17</code> ，元素<code class="codeph">3</code>和元素<code class="codeph">5</code>必须包含<code class="codeph">1</code>值。但是，如果测试表明两个元素都为<code class="codeph">1</code> ，那么该集合仍然可能<span class="italic">不</span>包括<code class="codeph">17</code> 。误报是可能的。例如，以下数组可能表示值<code class="codeph">22</code> ，对于元素<code class="codeph">3</code>和元素<code class="codeph">5</code> ，它也都是<code class="codeph">1</code> ：</p><pre class="pre codeblock"><code>e1 e2 e3 e4 e5 e6 e7 e8 1 0 1 0 1 0 0 0</code></pre></div>
                     <div>
                        <div class="familylinks">
                           <div class="parentlink">
                              <p><strong>父主题：</strong> <a href="joins.html#GUID-C9E0663B-822E-4733-8016-E56A73D903F3" title="Bloom过滤器以其创建者Burton Bloom命名，是一种低内存数据结构，用于测试集合中的成员资格。">布隆过滤器</a></p>
                           </div>
                        </div>
                     </div>
                     
                  </div><a id="TGSQL95301"></a><div class="props_rev_3"><a id="GUID-BBC13BB9-9BDC-439C-9A05-974F0FAFFF0C" name="GUID-BBC13BB9-9BDC-439C-9A05-974F0FAFFF0C"></a><h5 id="TGSQL-GUID-BBC13BB9-9BDC-439C-9A05-974F0FAFFF0C" class="sect5"><span class="enumeration_section">9.4.1.3</span>布隆过滤器控件</h5>
                     <div>
                        <p>优化程序自动确定是否使用Bloom过滤器。</p>
                        <p>要覆盖优化程序决策，请使用提示<code class="codeph">PX_JOIN_FILTER</code>和<code class="codeph">NO_PX_JOIN_FILTER</code> 。</p>
                     </div>
                     <div>
                        <div class="infoboxnotealso" id="GUID-BBC13BB9-9BDC-439C-9A05-974F0FAFFF0C__GUID-B517338B-E99B-4E61-9BF3-64F800185636">
                           <p class="notep1">也可以看看：</p>
                           <p><a href="../sqlrf/Comments.html#SQLRF50585" target="_blank"><span><cite>Oracle数据库SQL语言参考，</cite></span></a>以了解有关bloom过滤器提示的更多信息</p>
                        </div>
                        <div class="familylinks">
                           <div class="parentlink">
                              <p><strong>父主题：</strong> <a href="joins.html#GUID-C9E0663B-822E-4733-8016-E56A73D903F3" title="Bloom过滤器以其创建者Burton Bloom命名，是一种低内存数据结构，用于测试集合中的成员资格。">布隆过滤器</a></p>
                           </div>
                        </div>
                     </div>
                     
                  </div><a id="TGSQL95302"></a><div class="props_rev_3"><a id="GUID-BB21BC10-031D-4E43-9774-92764BF84FA4" name="GUID-BB21BC10-031D-4E43-9774-92764BF84FA4"></a><h5 id="TGSQL-GUID-BB21BC10-031D-4E43-9774-92764BF84FA4" class="sect5"><span class="enumeration_section">9.4.1.4</span> Bloom过滤元数据</h5>
                     <div>
                        <p><code class="codeph">V$</code>视图包含有关Bloom过滤器的元数据。
                        </p>
                        <p>您可以查询以下视图：</p>
                        <ul style="list-style-type:disc">
                           <li>
                              <p><code class="codeph">V $ SQL_JOIN_FILTER</code></p>
                              <p>此视图显示活动Bloom过滤器筛选出的行数（ <code class="codeph">FILTERED</code>列）和测试（ <code class="codeph">PROBED</code>列）。
                              </p>
                           </li>
                           <li>
                              <p><code class="codeph">V $ PQ_TQSTAT</code></p>
                              <p>此视图显示在执行树的每个阶段通过每个并行执行服务器处理的行数。您可以使用它来监视Bloom过滤器在并行进程之间减少了多少数据传输。</p>
                           </li>
                        </ul>
                        <p>在执行计划中，Bloom过滤器由<code class="codeph">Operation</code>列中的关键字<code class="codeph">JOIN FILTER</code>和<code class="codeph">Name</code>列中的前缀<code class="codeph">:BF</code>指示，如以下计划片段的第9步中所示：</p><pre class="pre codeblock"><code>-------------------------------------------------- -------------------------- | Id |操作|名称| TQ | IN-OUT | PQ Distrib | -------------------------------------------------- -------------------------- ......| 9 | <span class="bold">加入过滤器创建</span> | <span class="bold">：BF0000</span> | Q1,03 | PCWP | |</code></pre><p>在计划的<code class="codeph">Predicate Information</code>部分中，包含以字符串<code class="codeph">SYS_OP_BLOOM_FILTER</code>开头的函数的过滤器表示使用布隆过滤器。
                        </p>
                     </div>
                     <div>
                        <div class="familylinks">
                           <div class="parentlink">
                              <p><strong>父主题：</strong> <a href="joins.html#GUID-C9E0663B-822E-4733-8016-E56A73D903F3" title="Bloom过滤器以其创建者Burton Bloom命名，是一种低内存数据结构，用于测试集合中的成员资格。">布隆过滤器</a></p>
                           </div>
                        </div>
                     </div>
                     
                  </div><a id="TGSQL95303"></a><div class="props_rev_3"><a id="GUID-8E7B4239-B6B2-423E-94D1-DED4338C0077" name="GUID-8E7B4239-B6B2-423E-94D1-DED4338C0077"></a><h5 id="TGSQL-GUID-8E7B4239-B6B2-423E-94D1-DED4338C0077" class="sect5"><span class="enumeration_section">9.4.1.5</span>布隆过滤器：场景</h5>
                     <div>
                        <p>在此示例中，并行查询将<code class="codeph">sales</code>事实表连接到<code class="codeph">products</code>和<code class="codeph">times</code>维度表，并在财务周<code class="codeph">18</code>上过滤。
                        </p><pre class="pre codeblock"><code>SELECT / * + parallel（s）* / p.prod_name，s.quantity_sold FROM sh.sales s，sh.products p，sh.times t WHERE s.prod_id = p.prod_id AND s.time_id = t.time_id AND t .fiscal_week_number = 18;</code></pre><p>查询<code class="codeph">DBMS_XPLAN.DISPLAY_CURSOR</code>提供以下输出：</p><pre class="pre codeblock"><code>SELECT * FROM TABLE（DBMS_XPLAN.DISPLAY_CURSOR（format =&gt;'BASIC，+ PARALLEL，+ PREDICATE'））;解释的SQL语句：------------------------ SELECT / * + parallel（s）* / p.prod_name，s.quantity_sold FROM sh.sales s ，sh.products p，sh.times t WHERE s.prod_id = p.prod_id AND s.time_id = t.time_id AND t.fiscal_week_number = 18计划哈希值：1183628457 ------------- -------------------------------------------------- ------------- | Id |操作|名称| TQ | IN-OUT | PQ Distrib | -------------------------------------------------- -------------------------- | 0 |选择声明| | | | | | 1 | PX COORDINATOR | | | | | | 2 | PX SEND QC（RANDOM）| ：TQ10003 | Q1,03 | P-&gt; S | QC（兰德）| | * 3 | HASH JOIN BUFFERED | | Q1,03 | PCWP | | | 4 | PX RECEIVE | | Q1,03 | PCWP | | | 5 | PX SEND BROADCAST | ：TQ10001 | Q1,01 | S-&gt; P |广播| | 6 | PX SELECTOR | | Q1,01 | SCWC | | | 7 |表访问完全|产品| Q1,01 | SCWP | | | * 8 | HASH JOIN | | Q1,03 | PCWP | | | 9 |加入过滤器创建| ：BF0000 | Q1,03 | PCWP | | | 10 | BUFFER SORT | | Q1,03 | PCWC | | | 11 | PX RECEIVE | | Q1,03 | PCWP | | | 12 | PX SEND HYBRID HASH | ：TQ10000 | | S-&gt; P | HYBRID HASH | | * 13 |表访问完全|时代| | | | | 14 | PX RECEIVE | | Q1,03 | PCWP | | | 15 | PX SEND HYBRID HASH | ：TQ10002 | Q1,02 | P-&gt; P | HYBRID HASH | | 16 |加入过滤器使用| ：BF0000 | Q1,02 | PCWP | | | 17 | PX BLOCK ITERATOR | | Q1,02 | PCWC | | | * 18 |表访问完全|销售| Q1,02 | PCWP | | -------------------------------------------------- --------------------------谓词信息（由操作ID标识）：--------------- ------------------------------------ 3  -  access（“S”。“PROD_ID”=“P “。”PROD_ID“）8  - 访问（”S“。”TIME_ID“=”T“。”TIME_ID“）13  - 过滤器（”T“。”FISCAL_WEEK_NUMBER“= 18）18  - 访问（：Z&gt; =：Z AND：Z &lt;=：Z）过滤器（SYS_OP_BLOOM_FILTER（：BF0000，“S”。“TIME_ID”））</code></pre><p>单个服务器进程扫描<code class="codeph">times</code>表（步骤13），然后使用混合散列分发方法的行发送到并行执行服务器（步骤12）。集合<code class="codeph">Q1,03</code>的过程创建<code class="codeph">Q1,03</code>过滤器（步骤9）。集合<code class="codeph">Q1,02</code>的过程并行扫描<code class="codeph">sales</code> （步骤18），然后使用布隆过滤器从<code class="codeph">sales</code>丢弃行（步骤16），然后使用混合散列分布将它们发送到集合<code class="codeph">Q1,03</code> （步骤15）。集合<code class="codeph">Q1,03</code>的进程散列将<code class="codeph">times</code>行连接到筛选的<code class="codeph">sales</code>行（步骤8）。集合<code class="codeph">Q1,01</code>的过程扫描<code class="codeph">products</code> （步骤7），然后将行发送到<code class="codeph">Q1,03</code> （步骤5）。最后， <code class="codeph">Q1,03</code>的进程将<code class="codeph">products</code>行连接到前一个散列连接生成的行（步骤3）。
                        </p>
                        <p>下图说明了基本过程。</p>
                        <div class="figure" id="GUID-8E7B4239-B6B2-423E-94D1-DED4338C0077__GUID-9F1299A0-1098-4E06-AA8A-E40E730B7BCF">
                           <p class="titleinfigure">图9-8 Bloom过滤器</p><img src="img/tgsql_vm_082.png" alt="下面是图9-8的描述" title="下面是图9-8的描述" longdesc="img_text/tgsql_vm_082.html"><br><a href="img_text/tgsql_vm_082.html">“图9-8布隆过滤器”的说明</a></div>
                        <!-- class="figure" -->
                     </div>
                     <div>
                        <div class="familylinks">
                           <div class="parentlink">
                              <p><strong>父主题：</strong> <a href="joins.html#GUID-C9E0663B-822E-4733-8016-E56A73D903F3" title="Bloom过滤器以其创建者Burton Bloom命名，是一种低内存数据结构，用于测试集合中的成员资格。">布隆过滤器</a></p>
                           </div>
                        </div>
                     </div>
                     
                  </div>
               </div><a id="TGSQL95336"></a><div class="props_rev_3"><a id="GUID-3932756E-EDFC-4D4D-93CD-9F9F2AE2C2D7" name="GUID-3932756E-EDFC-4D4D-93CD-9F9F2AE2C2D7"></a><h4 id="TGSQL-GUID-3932756E-EDFC-4D4D-93CD-9F9F2AE2C2D7" class="sect4"><span class="enumeration_section">9.4.2</span>分区 - 明智联接</h4>
                  <div>
                     <p><strong class="term">分区连接</strong>是一种优化，它将两个表的大连接（其中一个必须在连接键上分区）划分为几个较小的连接。
                     </p>
                     <p>分区智能联接是以下任一种：</p>
                     <ul style="list-style-type:disc">
                        <li>
                           <p>完全分区连接</p>
                           <p>两个表必须在其连接键上进行均分，或使用引用分区（即通过引用约束进行关联）。数据库将大型连接划分为两个连接表中两个分区之间的较小连接。</p>
                        </li>
                        <li>
                           <p>部分分区连接</p>
                           <p>在连接键上只分区了一个表。另一个表可能已分区，也可能未分区。</p>
                        </li>
                     </ul>
                     <p>本节包含以下主题：</p>
                  </div>
                  <div>
                     <ul class="ullinks">
                        <li class="ulchildlink"><a href="joins.html#GUID-F22AB852-6377-4DB9-BACC-8D024616DC1E">分区的目的 - 明智的联接</a><br>分区连接通过最小化并行执行连接时并行执行服务器之间交换的数据量来减少查询响应时间。
                        </li>
                        <li class="ulchildlink"><a href="joins.html#GUID-7DDACB80-9FFC-4B30-A80F-1C0615012C02">分区 - 智者如何加入工作</a><br>当数据库在<span class="italic">不</span>使用分区连接的<span class="italic">情况下</span>串行连接两个分区表时，单个服务器进程将执行连接。
                        </li>
                     </ul>
                     <div class="infoboxnotealso" id="GUID-3932756E-EDFC-4D4D-93CD-9F9F2AE2C2D7__GUID-9ECD4737-056A-4005-95EE-5734FCE8558B">
                        <p class="notep1">也可以看看：</p>
                        <p><a href="../vldbg/partition-wise-joins.html#VLDBG00402" target="_blank"><span><cite>Oracle Database VLDB和分区指南</cite></span></a>详细介绍了分区智能联接</p>
                     </div>
                     <div class="familylinks">
                        <div class="parentlink">
                           <p><strong>父主题：</strong> <a href="joins.html#GUID-C02C3673-75E2-4D92-AAEF-30AC58C32AD1" title="连接优化使连接更有效。">加入优化</a></p>
                        </div>
                     </div>
                  </div>
                  <a id="TGSQL95337"></a><div class="props_rev_3"><a id="GUID-F22AB852-6377-4DB9-BACC-8D024616DC1E" name="GUID-F22AB852-6377-4DB9-BACC-8D024616DC1E"></a><h5 id="TGSQL-GUID-F22AB852-6377-4DB9-BACC-8D024616DC1E" class="sect5"><span class="enumeration_section">9.4.2.1</span>分区 - 明智连接的目的</h5>
                     <div>
                        <p>分区连接通过最小化并行执行连接时并行执行服务器之间交换的数据量来减少查询响应时间。</p>
                        <p>该技术显着缩短了响应时间并改善了CPU和内存的使用。在Oracle Real Application Clusters（Oracle RAC）环境中，分区连接还可以避免或至少限制互连上的数据流量，这是实现大规模连接操作的良好可伸缩性的关键。</p>
                     </div>
                     <div>
                        <div class="familylinks">
                           <div class="parentlink">
                              <p><strong>父主题：</strong> <a href="joins.html#GUID-3932756E-EDFC-4D4D-93CD-9F9F2AE2C2D7" title="分区连接是一种优化，它将两个表的大连接（其中一个必须在连接键上分区）划分为几个较小的连接。">分区 - 明智联接</a></p>
                           </div>
                        </div>
                     </div>
                     
                  </div><a id="TGSQL95339"></a><a id="TGSQL95338"></a><div class="props_rev_3"><a id="GUID-7DDACB80-9FFC-4B30-A80F-1C0615012C02" name="GUID-7DDACB80-9FFC-4B30-A80F-1C0615012C02"></a><h5 id="TGSQL-GUID-7DDACB80-9FFC-4B30-A80F-1C0615012C02" class="sect5"><span class="enumeration_section">9.4.2.2</span>分区 - 智者如何加入工作</h5>
                     <div>
                        <p>当数据库在<span class="italic">不</span>使用分区连接的<span class="italic">情况下</span>串行连接两个分区表时，单个服务器进程将执行连接。
                        </p>
                        <p>在下图中，连接<span class="italic">不是</span>分区的，因为服务器进程将表<code class="codeph">t1</code>的每个分区连接到表<code class="codeph">t2</code>每个分区。
                        </p>
                        <div class="figure" id="GUID-7DDACB80-9FFC-4B30-A80F-1C0615012C02__BABBAGDD">
                           <p class="titleinfigure">图9-9不是分区的加入 - 明智的</p><img src="img/tgsql_vm_085.png" alt="下面是图9-9的描述" title="下面是图9-9的描述" longdesc="img_text/tgsql_vm_085.html"><br><a href="img_text/tgsql_vm_085.html">“图9-9不是分区 - 明智的加入”的描述</a></div>
                        <!-- class="figure" -->
                        <p>本节包含以下主题：</p>
                     </div>
                     <div>
                        <ul class="ullinks">
                           <li class="ulchildlink"><a href="joins.html#GUID-C3EAE02A-F6C6-4F7C-A368-F9F498738F76">如何完全分区 - 明智的加入工作</a><br>数据库以串行或并行方式执行完全分区连接。
                           </li>
                           <li class="ulchildlink"><a href="joins.html#GUID-DB0AC6E5-6E59-4B61-9C96-480A8C8FBFAC">部分分区 - 明智的加入如何工作</a><br>部分分区连接与其完全分区方式不同，必须并行执行。
                           </li>
                        </ul>
                        <div class="familylinks">
                           <div class="parentlink">
                              <p><strong>父主题：</strong> <a href="joins.html#GUID-3932756E-EDFC-4D4D-93CD-9F9F2AE2C2D7" title="分区连接是一种优化，它将两个表的大连接（其中一个必须在连接键上分区）划分为几个较小的连接。">分区 - 明智联接</a></p>
                           </div>
                        </div>
                     </div>
                     <a id="TGSQL95341"></a><a id="TGSQL95340"></a><div class="props_rev_3"><a id="GUID-C3EAE02A-F6C6-4F7C-A368-F9F498738F76" name="GUID-C3EAE02A-F6C6-4F7C-A368-F9F498738F76"></a><h6 id="TGSQL-GUID-C3EAE02A-F6C6-4F7C-A368-F9F498738F76" class="sect6"><span class="enumeration_section">9.4.2.2.1</span>完全分区 - 明智的连接如何工作</h6>
                        <div>
                           <p>数据库以串行或并行方式执行完全分区连接。</p>
                           <p>下图显示了并行执行的完全分区连接。在这种情况下，平行度的颗粒是分区。每个并行执行服务器成对加入分区。例如，第一并行执行服务器将<code class="codeph">t1</code>的第一分区连接到<code class="codeph">t2</code>的第一分区。然后并行执行协调器组装结果。
                           </p>
                           <div class="figure" id="GUID-C3EAE02A-F6C6-4F7C-A368-F9F498738F76__BABJAHAJ">
                              <p class="titleinfigure">图9-10完全分区 - 明智的并行连接</p><img src="img/tgsql_vm_084.png" alt="下面是图9-10的描述" title="下面是图9-10的描述" longdesc="img_text/tgsql_vm_084.html"><br><a href="img_text/tgsql_vm_084.html">“图9-10完全分区 - 明智并行连接”的描述</a></div>
                           <!-- class="figure" -->
                           <p>完全分区连接也可以将分区连接到子分区，这在表使用不同的分区方法时很有用。例如， <code class="codeph">customers</code>按哈希进行分区，但<code class="codeph">sales</code>按范围划分。如果通过散列对<code class="codeph">sales</code>进行子分区，则数据库可以在<code class="codeph">customers</code>的散列分区和<code class="codeph">sales</code>的散列子分区之间执行完全分区连接。
                           </p>
                           <p>在执行计划中，在连接之前存在分区操作表示存在完全分区连接，如下面的代码片段所示：</p><pre class="oac_no_warn" dir="ltr">| 8 | PX PARTITION HASH ALL | | * 9 | HASH JOIN |</pre></div>
                        <div>
                           <div class="infoboxnotealso" id="GUID-C3EAE02A-F6C6-4F7C-A368-F9F498738F76__GUID-C57A6C54-D985-48D9-97CE-4C0A57CE0C8D">
                              <p class="notep1">也可以看看：</p>
                              <p><a href="../vldbg/partition-wise-joins.html#VLDBG1241" target="_blank"><span class="italic">Oracle数据库VLDB和分区指南</span></a>详细介绍了完整的分区连接，并包含几个示例</p>
                           </div>
                           <div class="familylinks">
                              <div class="parentlink">
                                 <p><strong>父主题：</strong> <a href="joins.html#GUID-7DDACB80-9FFC-4B30-A80F-1C0615012C02" title="当数据库在不使用分区连接的情况下串行连接两个分区表时，单个服务器进程将执行连接。">分区 - 明智如何加入工作</a></p>
                              </div>
                           </div>
                        </div>
                        
                     </div><a id="TGSQL95343"></a><a id="TGSQL95342"></a><div class="props_rev_3"><a id="GUID-DB0AC6E5-6E59-4B61-9C96-480A8C8FBFAC" name="GUID-DB0AC6E5-6E59-4B61-9C96-480A8C8FBFAC"></a><h6 id="TGSQL-GUID-DB0AC6E5-6E59-4B61-9C96-480A8C8FBFAC" class="sect6"><span class="enumeration_section">9.4.2.2.2</span>部分分区 - 明智的加入如何工作</h6>
                        <div>
                           <p>部分分区连接与其完全分区方式不同，必须并行执行。</p>
                           <p>下图显示了<code class="codeph">t1</code> （已分区）和<code class="codeph">t2</code> （未分区）之间的部分分区连接。
                           </p>
                           <div class="figure" id="GUID-DB0AC6E5-6E59-4B61-9C96-480A8C8FBFAC__BABHJHEH">
                              <p class="titleinfigure">图9-11部分分区 - 明智的加入</p><img src="img/tgsql_vm_083.png" alt="下面是图9-11的描述" title="下面是图9-11的描述" longdesc="img_text/tgsql_vm_083.html"><br><a href="img_text/tgsql_vm_083.html">“图9-11部分分区 - 明智加入”的描述</a></div>
                           <!-- class="figure" -->
                           <p>由于<code class="codeph">t2</code>未分区，因此一组并行执行服务器必须根据需要从<code class="codeph">t2</code>生成分区。然后，一组不同的并行执行服务器将<code class="codeph">t1</code>分区连接到动态生成的分区。并行执行协调器组装结果。
                           </p>
                           <p>在执行计划中，操作<code class="codeph">PX SEND PARTITION (KEY)</code>表示部分分区连接，如下面的代码片段所示：</p><pre class="pre codeblock"><code>| 11 | PX SEND PARTITION（KEY）|</code></pre></div>
                        <div>
                           <div class="infoboxnotealso" id="GUID-DB0AC6E5-6E59-4B61-9C96-480A8C8FBFAC__GUID-C8433A1E-D755-425A-AF43-ABC094A3B9BC">
                              <p class="notep1">也可以看看：</p>
                              <p><a href="../vldbg/partition-wise-joins.html#VLDBG1247" target="_blank"><span><cite>Oracle数据库VLDB和分区指南</cite></span></a>详细介绍了完整的分区连接，并包含几个示例</p>
                           </div>
                           <div class="familylinks">
                              <div class="parentlink">
                                 <p><strong>父主题：</strong> <a href="joins.html#GUID-7DDACB80-9FFC-4B30-A80F-1C0615012C02" title="当数据库在不使用分区连接的情况下串行连接两个分区表时，单个服务器进程将执行连接。">分区 - 明智如何加入工作</a></p>
                              </div>
                           </div>
                        </div>
                        
                     </div>
                  </div>
               </div>
               <div class="sect3"><a id="GUID-D9A7B0F6-D2D4-4881-9A6C-8042DE627650" name="GUID-D9A7B0F6-D2D4-4881-9A6C-8042DE627650"></a><h4 id="TGSQL-GUID-D9A7B0F6-D2D4-4881-9A6C-8042DE627650" class="sect4"><span class="enumeration_section">9.4.3</span>内存中加入组</h4>
                  <div>
                     <p><span class="bold">连接组</span>是用户创建的对象，它列出了两个或多个可以有意义连接的列。
                     </p>
                     <p>在某些查询中，连接组消除了解压缩和散列列值的性能开销。加入组需要内存中列存储（IM列存储）。</p>
                  </div>
                  <div>
                     <div class="infoboxnotealso" id="GUID-D9A7B0F6-D2D4-4881-9A6C-8042DE627650__GUID-6C592E60-DE2D-4D83-B14A-9A48C67206C7">
                        <p class="notep1">也可以看看：</p>
                        <p><a href="https://www.oracle.com/pls/topic/lookup?ctx=en/database/oracle/oracle-database/19/tgsql&amp;id=INMEM-GUID-3E5491C4-B345-4A8E-8B1B-8DC150C8A797" target="_blank"><span><cite>Oracle Database In-Memory指南</cite></span></a> ，了解如何使用连接组优化内存中查询</p>
                     </div>
                     <div class="familylinks">
                        <div class="parentlink">
                           <p><strong>父主题：</strong> <a href="joins.html#GUID-C02C3673-75E2-4D92-AAEF-30AC58C32AD1" title="连接优化使连接更有效。">加入优化</a></p>
                        </div>
                     </div>
                  </div>
                  
               </div>
            </div>
         </div>
      </article>
   </body>
</html>