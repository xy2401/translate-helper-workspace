<html lang="en-us" dir="ltr" xml:lang="en-us">
   <head>
      <meta http-equiv="Content-Type" content="text/html; charset=utf-8"></meta>
      <meta name="viewport" content="width=device-width, initial-scale=1"></meta>
      <meta http-equiv="X-UA-Compatible" content="IE=edge"></meta>
      <meta name="abstract" content="SQL/JSON function json_table projects specific JSON data to columns of various SQL data types. You use it to map parts of a JSON document into the rows and columns of a new, virtual table, which you can also think of as an inline view."></meta>
      <meta name="description" content="SQL/JSON function json_table projects specific JSON data to columns of various SQL data types. You use it to map parts of a JSON document into the rows and columns of a new, virtual table, which you can also think of as an inline view."></meta>
      <title>SQL / JSON函数JSON_TABLE</title>
      <meta property="og:site_name" content="Oracle Help Center"></meta>
      <meta property="og:title" content="JSON Developer&#39;s Guide"></meta>
      <meta property="og:description" content="SQL/JSON function json_table projects specific JSON data to columns of various SQL data types. You use it to map parts of a JSON document into the rows and columns of a new, virtual table, which you can also think of as an inline view."></meta>
      <link rel="stylesheet" href="/sp_common/book-template/ohc-book-template/css/book.css"></link>
      <link rel="shortcut icon" href="/sp_common/book-template/ohc-common/img/favicon.ico"></link>
      <meta name="application-name" content="JSON Developer&#39;s Guide"></meta>
      <meta name="generator" content="DITA Open Toolkit version 1.8.5 (Mode = doc)"></meta>
      <meta name="plugin" content="SP_docbuilder HTML plugin release 18.2.2"></meta>
      <link rel="alternate" href="json-developers-guide.pdf" title="PDF File" type="application/pdf"></link>
      <meta name="robots" content="all"></meta>
      <link rel="schema.dcterms" href="http://purl.org/dc/terms/"></link>
      <meta name="dcterms.created" content="2019-02-22T10:58:31-08:00"></meta>
      <meta name="dcterms.title" content="JSON Developer&#39;s Guide"></meta>
      <meta name="dcterms.dateCopyrighted" content="2015, 2019"></meta>
      <meta name="dcterms.category" content="database"></meta>
      <meta name="dcterms.identifier" content="E96227-03"></meta>
      
      <meta name="dcterms.product" content="en/database/oracle/oracle-database/19"></meta>
      
      <link rel="prev" href="function-JSON_QUERY.html" title="Previous" type="text/html"></link>
      <link rel="next" href="oracle-sql-function-json_serialize.html" title="Next" type="text/html"></link>
      <script>
        document.write('<style type="text/css">');
        document.write('body > .noscript, body > .noscript ~ * { visibility: hidden; }');
        document.write('</style>');
     </script>
      <script src="/sp_common/book-template/requirejs/require.js" data-main="/sp_common/book-template/ohc-book-template/js/book-config"></script>
      <script>
            if (window.require === undefined) {
                document.write('<script data-main="sp_common/book-template/ohc-book-template/js/book-config" src="sp_common/book-template/requirejs/require.js"><\/script>');
                document.write('<link href="sp_common/book-template/ohc-book-template/css/book.css" rel="stylesheet"/>');
            }
        </script>
      <script type="application/json" id="ssot-metadata">{"primary":{"category":{"short_name":"database","element_name":"Database","display_in_url":true},"suite":{"short_name":"oracle","element_name":"Oracle","display_in_url":true},"product_group":{"short_name":"not-applicable","element_name":"Not applicable","display_in_url":false},"product":{"short_name":"oracle-database","element_name":"Oracle Database","display_in_url":true},"release":{"short_name":"19","element_name":"Release 19","display_in_url":true}}}</script>
      
    <meta name="dcterms.isVersionOf" content="ADJSN"></meta>
    <meta name="dcterms.release" content="Release 19"></meta>
  </head>
   <body dir="ltr">
      <div class="noscript alert alert-danger text-center" role="alert">
         <a href="function-JSON_QUERY.html" class="pull-left"><span class="glyphicon glyphicon-chevron-left" aria-hidden="true"></span>上一页</a> <a href="oracle-sql-function-json_serialize.html" class="pull-right">下一页<span class="glyphicon glyphicon-chevron-right" aria-hidden="true"></span></a> <span class="fa fa-exclamation-triangle" aria-hidden="true"></span>必须启用JavaScript才能正确显示此内容</div>
      <article>
         <header>
            <ol class="breadcrumb" vocab="http://schema.org/" typeof="BreadcrumbList">
               <li property="itemListElement" typeof="ListItem"><a href="index.html" property="item" typeof="WebPage"><span property="name">JSON开发人员指南</span></a></li>
               <li property="itemListElement" typeof="ListItem"><a href="query-json-data.html" property="item" typeof="WebPage"><span property="name">查询JSON数据</span></a></li>
               <li class="active" property="itemListElement" typeof="ListItem">SQL / JSON函数JSON_TABLE</li>
            </ol>
            <a id="GUID-0172660F-CE29-4765-BF2C-C405BDE8369A" name="GUID-0172660F-CE29-4765-BF2C-C405BDE8369A"></a>
            
            <h2 id="ADJSN-GUID-0172660F-CE29-4765-BF2C-C405BDE8369A" class="sect2"><span class="enumeration_chapter">18</span> SQL / JSON函数JSON_TABLE</h2>
         </header>
         <div class="ind">
            <div>
               <p>SQL / JSON函数<code class="codeph">json_table</code>将特定的JSON数据<code class="codeph">json_table</code>到各种SQL数据类型的列。您可以使用它将JSON文档的各个部分映射到新虚拟表的行和列中，您也可以将其视为内联视图。
               </p>
               <div class="section">
                  <p>然后，您可以将此虚拟表插入到预先存在的数据库表中，或者可以使用SQL在连接表达式中查询它。</p>
                  <p><code class="codeph">json_table</code>一个常见用途是创建JSON数据<span class="italic">视图</span> 。您可以像使用任何表或视图一样使用此类视图。这使得应用程序，工具和程序员可以在不考虑JSON或JSON路径表达式语法的情况下对JSON数据进行操作。
                  </p>
                  <p>有效地定义JSON数据视图会将一种<span class="italic">模式</span>映射到该数据上。此映射是<span class="italic">在事实之后</span> ：可以定义和创建基础JSON数据，而无需考虑架构或任何特定的使用模式。数据优先，架构稍后。
                  </p>
                  <p>这样的模式（映射）对可以存储在数据库中的JSON文档的类型没有限制（除了格式良好的JSON数据）。该视图仅公开符合定义视图的映射（模式）的数据。要更改架构，只需重新定义视图 - 无需重新组织基础JSON数据。</p>
                  <p>您在SQL <code class="codeph">FROM</code>子句中使用<code class="codeph">json_table</code> 。它是一个<strong class="term">行源</strong> ：它为<span class="italic">行路径表达式</span> （行模式）选择的每个JSON值生成一行虚拟表数据。每个生成的行的<span class="italic">列</span>由<code class="codeph">COLUMNS</code>子句的<span class="italic">列路径表达式</span>定义。
                  </p>
                  <p>通常， <code class="codeph">json_table</code>调用隐式地与<code class="codeph">FROM</code>列表中的源表横向连接，其中每个行包含一个JSON文档，该文档用作函数的输入。 <code class="codeph">json_table</code>生成零个或多个新行，通过根据输入文档计算行路径表达式来确定。
                  </p>
                  <p><code class="codeph">json_table</code>的第一个参数是一个SQL表达式。它可以是表或视图列值，PL / SQL变量或具有适当强制转换的绑定变量。计算表达式的结果用作评估行路径表达式的<span class="italic">上下文项</span> 。
                  </p>
                  <p><code class="codeph">json_table</code>的第二个参数是SQL / JSON行路径表达式，后跟用于处理行的可选错误子句和（必需） <code class="codeph">COLUMNS</code>子句，后者定义要创建的虚拟表的列。没有<code class="codeph">RETURNING</code>子句。
                  </p>
                  <p><code class="codeph">json_table</code>有两个级别的错误处理，对应于两个级别的路径表达式：行和列。如果存在，列错误处理程序将覆盖行级错误处理。两个级别的默认错误处理程序是<code class="codeph">NULL ON ERROR</code> 。</p>
                  <p>作为传递context-item参数和行路径表达式的替代方法，您可以使用简单的点符号语法。（您仍然可以使用错误子句，仍然需要<code class="codeph">COLUMNS</code>子句。）点表示法指定表或视图列以及指向目标JSON数据的简单路径。例如，这两个查询是等效的：</p><pre class="pre codeblock"><code>json_table（ <span class="bold">tj，'$。ShippingInstructions。电话[*]'</span> ...）json_table（ <span class="bold">tjShippingInstructions。电话[*]</span> ......）</code></pre><p>如果行路径表达式仅为<code class="codeph">'$'</code> （以整个文档为目标），则可以省略路径部分。这些查询是等效的：</p><pre class="pre codeblock"><code>json_table（ <span class="bold">tj，'$'</span> ...）json_table（ <span class="bold">tj</span> ...）</code></pre><p><a href="function-JSON_TABLE.html#GUID-0172660F-CE29-4765-BF2C-C405BDE8369A__GUID-5EBDDC3C-4D3F-412E-A127-9B0CEB97E7B1">例18-1</a>说明了使用简单点符号和使用更全面，更明确的符号之间的区别。
                  </p>
               </div>
               <!-- class="section" -->
               <div class="example" id="GUID-0172660F-CE29-4765-BF2C-C405BDE8369A__GUID-5EBDDC3C-4D3F-412E-A127-9B0CEB97E7B1">
                  <p class="titleinexample">示例18-1等效JSON_TABLE查询：简单和完整语法</p>
                  <p>此示例使用<code class="codeph">json_table</code>进行两次等效查询。第一个查询对目标行和列数据的表达式使用简单的点符号语法。第二个使用完整的语法。
                  </p>
                  <p>除了引用其SQL标识符的列<code class="codeph">Special Instructions</code> ，SQL列名实际上是大写的。（标识符<code class="codeph">Special Instructions</code>包含空格字符。）
                  </p>
                  <p>在第一个查询中，列名称与目标对象字段的名称完全相同，包括字母大小写。无论它们是否被引用，它们都被解释为区分大小写以建立默认路径（没有显式<code class="codeph">PATH</code>子句时使用的<code class="codeph">PATH</code> ）。
                  </p>
                  <p>第二个查询有：</p>
                  <ul style="list-style-type:disc">
                     <li>
                        <p>JSON列表达式和SQL / JSON行路径表达式的单独参数</p>
                     </li>
                     <li>
                        <p><code class="codeph">VARCHAR2(4000)</code>显式列数据类型<code class="codeph">VARCHAR2(4000)</code></p>
                     </li>
                     <li>
                        <p>带有SQL / JSON列路径表达式的显式<code class="codeph">PATH</code>子句，用于定位投影的对象字段</p>
                     </li>
                  </ul><pre class="pre codeblock"><code>SELECT jt。* FROM j_purchaseorder po，json_table（po.po_document COLUMNS（ <span class="bold">“Special Instructions”</span> ，NESTED LineItems [*] COLUMNS（ <span class="bold">ItemNumber</span> NUMBER， <span class="bold">Description</span> PATH Part。）。说明）））AS“JT”;</code></pre><pre class="pre codeblock"><code>SELECT jt。* FROM j_purchaseorder po，json_table（po.po_document <span class="bold">，</span> <span class="bold">'$'</span> COLUMNS（“Special Instructions” <span class="bold">VARCHAR2（4000）PATH'$。“特别说明”'</span> ，NESTED <span class="bold">PATH'$。LineItems [*]</span> 'COLUMNS（ItemNumber NUMBER <span class="bold">PATH'$。ItemNumber'</span> ，描述<span class="bold">VARCHAR（4000）</span> PATH'$。部分。描述'）））AS“JT”;</code></pre></div>
               <!-- class="example" -->
               <div class="section">
                  <div class="infoboxnotealso" id="GUID-0172660F-CE29-4765-BF2C-C405BDE8369A__GUID-10170DA4-D38A-4502-8DC3-58B1CB24AA1E">
                     <p class="notep1">也可以看看：</p>
                     <p>有关<code class="codeph">json_table</code>信息，请<code class="codeph">json_table</code> <a href="../sqlrf/JSON_TABLE.html#SQLRF56973" target="_blank"><span><cite>Oracle数据库SQL语言参考</cite></span></a></p>
                  </div>
               </div>
               <!-- class="section" -->
            </div>
            <div>
               <ul class="ullinks">
                  <li class="ulchildlink"><a href="function-JSON_TABLE.html#GUID-D870AAFF-58B0-4162-AC11-4DDC74B608A5">SQL NESTED子句而不是JSON_TABLE</a><br>在<code class="codeph">SELECT</code>子句中，您通常可以使用<code class="codeph">NESTED</code>子句而不是SQL / JSON函数<code class="codeph">json_table</code> 。这可能意味着更简单的查询表达式。当JSON列为<code class="codeph">NULL</code>时，它还具有包含非<code class="codeph">NULL</code>行的优点。</li>
                  <li class="ulchildlink"><a href="function-JSON_TABLE.html#GUID-142213E5-F856-458C-A71F-18524DEDF430">COLUMNS SQL / JSON函数JSON_TABLE的子句</a><br>SQL / JSON函数<code class="codeph">json_table</code>的强制<code class="codeph">COLUMNS</code>子句定义函数创建的虚拟表的列。
                  </li>
                  <li class="ulchildlink"><a href="function-JSON_TABLE.html#GUID-5CDC25A8-A516-44B8-9C8F-0CE666933903">JSON_TABLE概括了SQL / JSON查询函数和条件</a><br>SQL / JSON函数<code class="codeph">json_table</code>概括了SQL / JSON条件<code class="codeph">json_exists</code>和SQL / JSON函数<code class="codeph">json_value</code>和<code class="codeph">json_query</code> 。使用这些函数可以执行的所有操作都可以使用<code class="codeph">json_table</code> 。对于他们完成的工作，这些函数的语法比<code class="codeph">json_table</code>的语法更容易使用。
                  </li>
                  <li class="ulchildlink"><a href="function-JSON_TABLE.html#GUID-37CBD672-5B0A-4FAB-A3AF-144E76686BD5">将JSON_TABLE与JSON数组一起使用</a><br>JSON值可以是一个数组，也可以包含一个或多个数组，嵌套到其他JSON数组或对象中的任意数量的级别。您可以使用<code class="codeph">json_table</code> <code class="codeph">NESTED</code>路径子句来投影数组的特定元素。
                  </li>
                  <li class="ulchildlink"><a href="function-JSON_TABLE.html#GUID-BFA1FB9A-0F18-4ED2-B504-6855DC6705B5">使用JSON_TABLE创建JSON数据视图</a><br>为了提高查询性能，您可以使用SQL / JSON函数<code class="codeph">json_table</code>创建投影到列的JSON数据视图。为了进一步提高查询性能，您可以创建<span class="italic">物化视图</span>并将JSON数据<span class="italic">放在内存中</span> 。
                  </li>
               </ul>
               <div class="relinfo">
                  <p><strong>相关话题</strong></p>
                  <ul>
                     <li><a href="clauses-used-in-functions-and-conditions-for-json.html#GUID-55344240-B1F0-490A-89BF-1526FA0546D4" title="某些SQL查询函数和条件接受可选的错误子句，该子句指定处理由函数或条件引发的运行时错误。此处总结了此子句和默认行为（无错误子句）。">SQL查询函数和条件的错误子句</a></li>
                     <li><a href="function-JSON_QUERY.html#GUID-D64C7BE9-335D-449C-916D-1123539BF1FB" title="SQL / JSON函数json_query从JSON数据中选择一个或多个值，并返回表示JSON值的字符串（VARCHAR2，CLOB或BLOB实例）。因此，您可以使用json_query来检索JSON文档的片段。">SQL / JSON函数JSON_QUERY</a></li>
                  </ul>
               </div>
               <div class="familylinks">
                  <div class="parentlink">
                     <p><strong>父主题：</strong> <a href="query-json-data.html#GUID-119E5069-77F2-45DC-B6F0-A1B312945590" title="您可以使用简单的点表示法查询JSON数据，或者，对于更多功能，使用SQL / JSON函数和条件。您可以创建和查询数据指南，该指南汇总了一组JSON文档的结构和类型信息。">查询JSON数据</a></p>
                  </div>
               </div>
            </div>
            
            <div class="sect2"><a id="GUID-D870AAFF-58B0-4162-AC11-4DDC74B608A5" name="GUID-D870AAFF-58B0-4162-AC11-4DDC74B608A5"></a><h3 id="ADJSN-GUID-D870AAFF-58B0-4162-AC11-4DDC74B608A5" class="sect3"><span class="enumeration_section">18.1</span> SQL NESTED子句而不是JSON_TABLE</h3>
               <div>
                  <p>在<code class="codeph">SELECT</code>子句中，您通常可以使用<code class="codeph">NESTED</code>子句而不是SQL / JSON函数<code class="codeph">json_table</code> 。这可能意味着更简单的查询表达式。当JSON列为<code class="codeph">NULL</code>时，它还具有包含非<code class="codeph">NULL</code>行的优点。</p>
                  <p><code class="codeph">NESTED</code>子句是使用带有ANSI左外连接的<code class="codeph">json_table</code>的快捷方式。也就是说，这两个查询是等价的：</p><pre class="pre codeblock"><code>选择 ...来自mytable <span class="bold">NESTED</span> jcol COLUMNS（...）;</code></pre><pre class="pre codeblock"><code>选择 ...FROM mytable的<span class="bold">T1</span> <span class="bold">LEFT OUTER JOIN</span> <span class="bold"><span class="bold">json_table（T1。jcol</span></span>柱（...）
       <span class="bold">ON 1 = 1</span> ;</code></pre><p>使用带有<code class="codeph">json_table</code>的左外连接或使用<code class="codeph">NESTED</code>子句，允许选择结果包含具有关系列的行，其中没有对应的JSON列数据，即JSON列为<code class="codeph">NULL</code> 。两者之间唯一的语义差异是，如果使用<code class="codeph">NESTED</code>子句，则JSON列本身不包含在结果中。
                  </p>
                  <p><code class="codeph">NESTED</code>子句提供与<code class="codeph">json_table</code>相同的<code class="codeph">COLUMNS</code>子句，包括嵌套列的可能性。使用<code class="codeph">NESTED</code>优点是你不需要提供一个<code class="codeph">is json</code>检查约束（ <code class="codeph">json_table</code>需要简单的点表示法）或表别名，你不需要指定<code class="codeph">LEFT OUTER JOIN</code> 。 <code class="codeph">NESTED</code>子句语法更简单，它允许<code class="codeph">COLUMNS</code>子句的所有灵活性，并执行隐式左外连接。
                  </p>
                  <div class="example" id="GUID-D870AAFF-58B0-4162-AC11-4DDC74B608A5__GUID-4A73163A-D191-4798-8DD8-AC6F96B68D46">
                     <p class="titleinexample">示例18-2等效：使用LEFT OUTER JOIN的SQL NESTED和JSON_TABLE</p>
                     <p>这两个查询是等价的。一个使用带有显式<code class="codeph">LEFT OUTER JOIN</code> SQL / JSON函数<code class="codeph">json_table</code> 。另一个使用SQL <code class="codeph">NESTED</code>子句。
                     </p><pre class="pre codeblock"><code>SELECT id，requestor，type，“number”FROM j_purchaseorder <span class="bold">LEFT OUTER JOIN</span> <span class="bold">json_table</span> （po_document COLUMNS（Requestor，NESTED ShippingInstructions。电话[*] COLUMNS（类型，“数字”）））ON 1 = 1）; SELECT id，requestor，type，“number”FROM j_purchaseorder <span class="bold">NESTED</span> po_document COLUMNS（Requestor，NESTED ShippingInstructions。电话[*] COLUMNS（类型，“数字”）;</code></pre><p>两种情况下的输出相同：</p><pre class="pre codeblock"><code>7C3A54B183056369E0536DE05A0A15E4 Alexis Bull Office 909-555-7307 7C3A54B183056369E0536DE05A0A15E4 Alexis Bull Mobile 415-555-1234 7C3A54B183066369E0536DE05A0A15E4 Sarah Bell</code></pre><p>如果表<code class="codeph">j_purchaseorder</code>具有列<code class="codeph">id</code>和<code class="codeph">requestor</code>非<code class="codeph">NULL</code>值，但列<code class="codeph">po_document</code>值为<code class="codeph">NULL</code> ，那么该行将出现在两种情况下。但如果没有<code class="codeph">LEFT OUTER JOIN</code> ，它就不会出现在<code class="codeph">json_table</code>案例中。
                     </p>
                  </div>
                  <!-- class="example" -->
               </div>
               <div>
                  <div class="familylinks">
                     <div class="parentlink">
                        <p><strong>父主题：</strong> <a href="function-JSON_TABLE.html#GUID-0172660F-CE29-4765-BF2C-C405BDE8369A" title="SQL / JSON函数json_table将特定的JSON数据投影到各种SQL数据类型的列。您可以使用它将JSON文档的各个部分映射到新虚拟表的行和列中，您也可以将其视为内联视图。">SQL / JSON函数JSON_TABLE</a></p>
                     </div>
                  </div>
               </div>
               
            </div>
            <div class="sect2"><a id="GUID-142213E5-F856-458C-A71F-18524DEDF430" name="GUID-142213E5-F856-458C-A71F-18524DEDF430"></a><h3 id="ADJSN-GUID-142213E5-F856-458C-A71F-18524DEDF430" class="sect3"><span class="enumeration_section">18.2</span> SQL / JSON函数JSON_TABLE的COLUMNS子句</h3>
               <div>
                  <p>SQL / JSON函数<code class="codeph">json_table</code>的强制<code class="codeph">COLUMNS</code>子句定义函数创建的虚拟表的列。
                  </p>
                  <p>它由关键字<span class="bold"><code class="codeph">COLUMNS</code></span>后跟以下条目组成，括在括号中。除了可选的<code class="codeph">FOR ORDINALITY</code>条目之外， <code class="codeph">COLUMNS</code>子句中的每个条目都是<span class="italic">常规</span>列规范或<span class="italic">嵌套</span>列规范。
                  </p>
                  <ul id="GUID-142213E5-F856-458C-A71F-18524DEDF430__UL_SWL_J5V_SFB" style="list-style-type:disc">
                     <li>
                        <p><code class="codeph">COLUMNS</code>子句中的最多一个条目可以是列名，后跟关键字<span class="bold"><code class="codeph">FOR ORDINALITY</code></span> ，后者指定生成的行号列（SQL数据类型<code class="codeph">NUMBER</code> ）。这些数字以一个开头。例如：</p><pre class="pre codeblock"><code>COLUMNS（亚麻用于ORDINALITY，ProductID）</code></pre></li>
                     <li>
                        <p><strong class="term">常规列</strong>规范由列名称后跟列的可选标量数据类型组成，可以是SQL数据类型<code class="codeph">VARCHAR2</code> ， <code class="codeph">NUMBER</code> ， <code class="codeph">DATE</code> ， <code class="codeph">TIMESTAMP</code> ， <code class="codeph">TIMESTAMP WITH TIME ZONE</code>或<code class="codeph">SDO_GEOMETRY</code> （与<code class="codeph">RETURNING</code>子句的<code class="codeph">RETURNING</code>子句相同） <code class="codeph">json_value</code> ），后跟可选的value子句和可选的<code class="codeph">PATH</code>子句。默认数据类型为<code class="codeph">VARCHAR2(4000)</code> 。
                        </p>
                        <p>数据类型<code class="codeph">SDO_GEOMETRY</code>用于Oracle Spatial和Graph数据。特别是，这意味着您可以将<code class="codeph">json_table</code>与GeoJSON数据一起使用，GeoJSON数据是一种用于在JSON中编码地理数据的格式。</p>
                        <p>当列的返回数据类型为<code class="codeph">VARCHAR2( <span class="codeinlineitalic">N</span> )</code> ，Oracle通过在数据类型之后立即允许可选关键字<code class="codeph"><span class="bold">TRUNCATE</span></code>扩展SQL / JSON标准。当<code class="codeph">TRUNCATE</code>存在且要返回的值大于<code class="codeph"><span class="codeinlineitalic">N</span></code> ，该值将被截断 - 仅返回前<code class="codeph"><span class="codeinlineitalic">N</span></code>字符。如果缺少<code class="codeph">TRUNCATE</code> ，则将此情况视为错误，通常由错误子句或默认错误处理行为处理。
                        </p>
                     </li>
                     <li>
                        <p><strong class="term">嵌套列</strong>规范包含关键字<span class="bold"><code class="codeph">NESTED</code></span>后跟可选的<code class="codeph">PATH</code>关键字，SQL / JSON行路径表达式，然后是<code class="codeph">COLUMNS</code>子句。此<code class="codeph">COLUMNS</code>子句指定表示嵌套数据的列。此处使用的行路径表达式为指定的嵌套列提供了精炼的上下文：每个嵌套的列路径表达式都与行路径表达式相关。您可以将列子句嵌套到不同级别的数组中存在的项目值到同一行的列。
                        </p>
                        <p>任何级别的<code class="codeph">COLUMNS</code>子句（嵌套或非嵌套）具有相同的特征。换句话说， <code class="codeph">COLUMNS</code>子句是递归定义的。对于每个嵌套级（即，对于每个使用关键字<code class="codeph">NESTED</code> ），嵌套<code class="codeph">COLUMNS</code>子句说是的<strong class="term">子</strong> <code class="codeph">COLUMNS</code>子句在其内嵌套，这是它的<strong class="term">父</strong> 。具有相同父子句的两个或多个<code class="codeph">COLUMNS</code>子句是<strong class="term">兄弟姐妹</strong> 。
                        </p>
                        <p>由父和子<code class="codeph">COLUMNS</code>子句定义的虚拟表使用<span class="italic">外部</span>联接进行连接，父级是外部表。由兄弟<code class="codeph">COLUMNS</code>子句定义的虚拟列使用<code class="codeph">union</code>连接进行连接。
                        </p>
                        <p><a href="function-JSON_TABLE.html#GUID-0172660F-CE29-4765-BF2C-C405BDE8369A__GUID-5EBDDC3C-4D3F-412E-A127-9B0CEB97E7B1">例18-1</a>和<a href="function-JSON_TABLE.html#GUID-37CBD672-5B0A-4FAB-A3AF-144E76686BD5__CACGAJAG">例18-8</a>说明了嵌套列子句的使用。
                        </p>
                     </li>
                  </ul>
                  <p>常规列规范中唯一需要的是列名。通过指定标量数据类型，值处理或目标路径，更详细地定义列投影是可选的。</p>
                  <ul id="GUID-142213E5-F856-458C-A71F-18524DEDF430__UL_TWL_J5V_SFB" style="list-style-type:disc">
                     <li>
                        <p>可选的<strong class="term">value</strong>子句指定如何处理投射到列的数据：是否像<code class="codeph">json_value</code> ， <code class="codeph">json_exists</code>或<code class="codeph">json_query</code>那样处理它。此值处理包括返回数据类型，返回格式（漂亮或ASCII），包装和错误处理。
                        </p>
                        <p>默认情况下，投影数据的处理方式与<code class="codeph">json_value</code> 。如果使用关键字<span class="bold"><code class="codeph">EXISTS</code></span>那么它就像<code class="codeph">json_exists</code>一样处理。如果您使用关键字<span class="bold"><code class="codeph">FORMAT JSON</code></span>那么它就像<code class="codeph">json_query</code>一样处理。
                        </p>
                        <p>对于<code class="codeph">FORMAT JSON</code>您可以通过添加显式包装子句来覆盖默认包装行为。
                        </p>
                        <p>您可以通过添加适合它的显式错误子句来覆盖给定处理程序（ <code class="codeph">json_value</code> ， <code class="codeph">json_exists</code>或<code class="codeph">json_query</code> ）的默认错误处理。
                        </p>
                     </li>
                     <li>
                        <p>可选的<span class="bold"><code class="codeph">PATH</code></span>子句指定要用作列内容的行部分。关键字<code class="codeph">PATH</code>后面的列路径表达式与虚拟行提供的上下文项匹配。列路径表达式必须表示<span class="italic">相对</span>路径;它相对于行路径表达式指定的路径。
                        </p>
                        <p>如果<code class="codeph">PATH</code>子句不存在，那么行为与路径为<code class="codeph">'$. <span class="codeinlineitalic">&lt;column-name&gt;</span> '</code>的行为相同<code class="codeph">'$. <span class="codeinlineitalic">&lt;column-name&gt;</span> '</code> ，其中<code class="codeph"><span class="codeinlineitalic">&lt;column-name&gt;</span></code>是列名。也就是说，目标对象字段的名称隐式地作为列名称。为了<span class="italic">仅</span>指定目标字段，用于<code class="codeph"><span class="codeinlineitalic">&lt;column-name&gt;</span></code>的SQL标识符将<span class="italic">区分大小写</span> ，即使它未被引用。该列的SQL名称遵循通常的规则：如果它用双引号（ <code class="codeph">"</code> ）括起来，则使用的字母大小写很重要;否则，它不是（它被视为大写）。
                        </p>
                        <p>例如，这两个<code class="codeph">COLUMNS</code>子句是等效的。对于SQL，大小写<span class="italic">仅</span>适用于列<code class="codeph">Comments</code> 。
                        </p><pre class="pre codeblock"><code>COLUMNS（ProductId，数量NUMBER，“评论”）COLUMNS（ProductId VARCHAR2（4000）PATH'$。ProductId'，数量NUMBER PATH'$ .quantity'， <span class="bold">“</span>评论<span class="bold">”</span> VARCHAR2（4000）PATH'$。评论'）</code></pre><p><a href="function-JSON_TABLE.html#GUID-0172660F-CE29-4765-BF2C-C405BDE8369A__GUID-5EBDDC3C-4D3F-412E-A127-9B0CEB97E7B1">例18-1</a>给出了说明这一点的等效查询。
                        </p>
                     </li>
                  </ul>
                  <p>如果在给定的<code class="codeph">json_table</code>列规范中使用<code class="codeph"><span class="bold">FORMAT JSON</span></code> ，则在将JSON数据投影到列时使用<code class="codeph">json_query</code>语义。为列指定的数据类型可以是<code class="codeph">json_query</code>可以返回的任何SQL数据类型： <code class="codeph">VARCHAR2</code> ， <code class="codeph">CLOB</code>或<code class="codeph">BLOB</code> 。</p>
                  <p><code class="codeph"><span class="bold">json_query</span></code>语义意味着以下内容：</p>
                  <ul id="GUID-142213E5-F856-458C-A71F-18524DEDF430__UL_UWL_J5V_SFB" style="list-style-type:disc">
                     <li>
                        <p>预计的JSON数据总是格式良好。这包括确保字符串值中的非ASCII字符根据需要进行转义。例如，TAB字符（CHARACTER TABULATION，U + 0009）将转义为<code class="codeph">\t</code> 。
                        </p>
                     </li>
                     <li>
                        <p><code class="codeph">json_query</code>错误处理适用。
                        </p>
                     </li>
                     <li>
                        <p>您可以使用包装子句将多个JSON值投影为数组中的元素。</p>
                     </li>
                  </ul>
                  <p>如果在给定的<code class="codeph">json_table</code>列规范中<span class="italic">不</span>使用<code class="codeph">FORMAT JSON</code> ，则在投影JSON数据时使用<code class="codeph">json_value</code>语义。为列指定的数据类型可以是<code class="codeph">json_value</code>可以返回的任何SQL数据类型： <code class="codeph">VARCHAR2</code> ， <code class="codeph">NUMBER</code> ， <code class="codeph">DATE</code> ， <code class="codeph">TIMESTAMP</code> ， <code class="codeph">TIMESTAMP WITH TIME ZONE</code> ， <code class="codeph">SDO_GEOMETRY</code>或<code class="codeph">CLOB</code> 。 <code class="codeph">json_value</code>错误处理（并且您不能使用包装器子句）。
                  </p>
                  <p>例如，列在这里的值<code class="codeph">FirstName</code>投影直接使用<code class="codeph">json_value</code>语义和列的值<code class="codeph">Address</code>是使用投影为JSON字符串<code class="codeph">json_query</code>语义：</p><pre class="pre codeblock"><code>COLUMNS（FirstName，Address FORMAT JSON）</code></pre><p>当投影数据是JSON对象或数组时，通常使用<code class="codeph">FORMAT JSON</code> 。当投影数据是JSON标量时，通常不使用<code class="codeph">FORMAT JSON</code> 。
                  </p>
                  <div class="section"></div>
                  <!-- class="section" -->
               </div>
               <div>
                  <div class="relinfo">
                     <p><strong>相关话题</strong></p>
                     <ul>
                        <li><a href="clauses-used-in-functions-and-conditions-for-json.html#GUID-DE9F29D3-1C23-4271-9DCD-E585866576D2" title="SQL函数json_value，json_query，json_serialize和json_mergepatch接受一个可选的RETURNING子句，该子句指定函数返回的值的数据类型。此处描述了此子句和默认行为（无RETURNING子句）。">SQL查询函数的RETURNING子句</a></li>
                        <li><a href="clauses-used-in-functions-and-conditions-for-json.html#GUID-9079CD9C-3783-4857-9F6B-84D746C91317" title="SQL / JSON查询函数json_query和json_table接受一个可选的包装子句，它指定json_query返回的值的形式或用于json_table列中的数据。此处描述了此子句和默认行为（无包装子句）。提供了示例。">SQL / JSON查询函数的包装子句JSON_QUERY和JSON_TABLE</a></li>
                        <li><a href="clauses-used-in-functions-and-conditions-for-json.html#GUID-55344240-B1F0-490A-89BF-1526FA0546D4" title="某些SQL查询函数和条件接受可选的错误子句，该子句指定处理由函数或条件引发的运行时错误。此处总结了此子句和默认行为（无错误子句）。">SQL查询函数和条件的错误子句</a></li>
                        <li><a href="clauses-used-in-functions-and-conditions-for-json.html#GUID-3176ECEA-BBCE-4C7C-AB24-7FCE250B8443" title="SQL / JSON查询函数json_value，json_query和json_table接受可选的ON EMPTY子句，该子句指定在查询的数据中不存在目标JSON字段时要使用的处理。此处描述了此子句和默认行为（无ON EMPTY子句）。">SQL / JSON查询函数的空字段子句</a></li>
                        <li><a href="function-JSON_QUERY.html#GUID-D64C7BE9-335D-449C-916D-1123539BF1FB" title="SQL / JSON函数json_query从JSON数据中选择一个或多个值，并返回表示JSON值的字符串（VARCHAR2，CLOB或BLOB实例）。因此，您可以使用json_query来检索JSON文档的片段。">SQL / JSON函数JSON_QUERY</a></li>
                     </ul>
                  </div>
                  <div class="infoboxnotealso" id="GUID-142213E5-F856-458C-A71F-18524DEDF430__NOTE_BQD_TVV_SFB">
                     <p class="notep1">也可以看看：</p>
                     <ul id="GUID-142213E5-F856-458C-A71F-18524DEDF430__UL_AFJ_S5V_SFB" style="list-style-type:disc">
                        <li>
                           <p><a href="../sqlrf/JSON_TABLE.html#SQLRF56973" target="_blank"><span><cite>Oracle数据库SQL语言参考</cite></span></a></p>
                        </li>
                        <li>
                           <p>
                              <a href="../spatl/spatial-concepts.html#SPATL-GUID-D703DF4D-57D1-4990-8F53-CAAA9C8FCB2F" target="_blank"><span><cite>Oracle Spatial and Graph Developer's Guide</cite></span></a> ，了解有关使用Oracle Spatial和Graph数据的信息</p>
                        </li>
                        <li>
                           <p><a href="https://www.oracle.com/pls/topic/lookup?ctx=en/database/oracle/oracle-database/19/adjsn&amp;id=geojson_org" target="_blank">GeoJSON.org</a></p>
                        </li>
                     </ul>
                  </div>
                  <div class="familylinks">
                     <div class="parentlink">
                        <p><strong>父主题：</strong> <a href="function-JSON_TABLE.html#GUID-0172660F-CE29-4765-BF2C-C405BDE8369A" title="SQL / JSON函数json_table将特定的JSON数据投影到各种SQL数据类型的列。您可以使用它将JSON文档的各个部分映射到新虚拟表的行和列中，您也可以将其视为内联视图。">SQL / JSON函数JSON_TABLE</a></p>
                     </div>
                  </div>
               </div>
               
            </div><a id="ADXDB6289"></a><a id="ADXDB6290"></a><a id="ADXDB6288"></a><div class="props_rev_3"><a id="GUID-5CDC25A8-A516-44B8-9C8F-0CE666933903" name="GUID-5CDC25A8-A516-44B8-9C8F-0CE666933903"></a><h3 id="ADJSN-GUID-5CDC25A8-A516-44B8-9C8F-0CE666933903" class="sect3"><span class="enumeration_section">18.3</span> JSON_TABLE概括了SQL / JSON查询函数和条件</h3>
               <div>
                  <p>SQL / JSON函数<code class="codeph">json_table</code>概括了SQL / JSON条件<code class="codeph">json_exists</code>和SQL / JSON函数<code class="codeph">json_value</code>和<code class="codeph">json_query</code> 。使用这些函数可以执行的所有操作都可以使用<code class="codeph">json_table</code> 。对于他们完成的工作，这些函数的语法比<code class="codeph">json_table</code>的语法更容易使用。
                  </p>
                  <p>如果您不止一次或组合使用<code class="codeph">json_exists</code> ， <code class="codeph">json_value</code>或<code class="codeph">json_query</code>任何一个来访问相同的数据，那么单次调用<code class="codeph">json_table</code>带来数据仅被解析一次的优势。
                  </p>
                  <p>因此，优化器通常会自动将<code class="codeph">json_exists</code> ， <code class="codeph">json_value</code>和<code class="codeph">json_query</code> （任意组合）的多次调用重写为更少的<code class="codeph">json_table</code>调用，因此数据仅被解析一次。
                  </p>
                  <p><a href="function-JSON_TABLE.html#GUID-5CDC25A8-A516-44B8-9C8F-0CE666933903__CACFIBBE">例18-3</a>和<a href="function-JSON_TABLE.html#GUID-5CDC25A8-A516-44B8-9C8F-0CE666933903__CACBFFGE">例18-4</a>说明了这一点。它们各自选择请求者和列<code class="codeph">j_purchaseorder.po_document</code>每个对象使用的电话集。但是， <a href="function-JSON_TABLE.html#GUID-5CDC25A8-A516-44B8-9C8F-0CE666933903__CACBFFGE">例18-4</a>只解析该列一次，而不是四次。
                  </p>
                  <p>请注意以下与<a href="function-JSON_TABLE.html#GUID-5CDC25A8-A516-44B8-9C8F-0CE666933903__CACBFFGE">示例18-4相关的内容</a> ：</p>
                  <ul style="list-style-type:disc">
                     <li>
                        <p>就SQL而言，JSON值为<code class="codeph">null</code>是一个<span class="italic">值</span> ;它<span class="italic">不是</span> <code class="codeph">NULL</code> ，在SQL中表示缺少值（缺失，未知或不适用的数据）。在<a href="function-JSON_TABLE.html#GUID-5CDC25A8-A516-44B8-9C8F-0CE666933903__CACBFFGE">示例18-4中</a> ，如果对象属性<code class="codeph">zipCode</code>的JSON值为<code class="codeph">null</code>则返回SQL字符串<code class="codeph">'true'</code> 。
                        </p>
                     </li>
                     <li>
                        <p><code class="codeph">json_exists</code>是一个SQL <span class="italic">条件</span> ;您可以在SQL <code class="codeph">WHERE</code>子句， <code class="codeph">CASE</code>语句或检查约束中使用它。在<a href="function-JSON_TABLE.html#GUID-5CDC25A8-A516-44B8-9C8F-0CE666933903__CACFIBBE">例18-3中，</a>它用在<code class="codeph">WHERE</code>子句中。功能<code class="codeph">json_table</code>采用的语义<code class="codeph">json_exists</code>当您指定关键字隐含<code class="codeph">EXISTS</code> 。它必须在虚拟列中返回SQL <span class="italic">值</span> 。由于Oracle SQL没有布尔数据类型，因此使用SQL字符串<code class="codeph">'true'</code>或<code class="codeph">'false'</code>来表示布尔值。<a href="function-JSON_TABLE.html#GUID-5CDC25A8-A516-44B8-9C8F-0CE666933903__CACBFFGE">例18-4</a>就是这种情况： <code class="codeph">VARCHAR2</code>值存储在<code class="codeph">jt.has_zip</code>列中，然后显式测试它与文字SQL字符串<code class="codeph">'true'</code>相等性。
                        </p>
                     </li>
                     <li>
                        <p>JSON字段<code class="codeph">AllowPartialShipment</code>具有JSON布尔值。当<code class="codeph">json_value</code>应用于该值时，它将作为字符串返回。在<a href="function-JSON_TABLE.html#GUID-5CDC25A8-A516-44B8-9C8F-0CE666933903__CACBFFGE">例18-4中</a> ，数据类型<code class="codeph">VARCHAR2</code>用作列数据类型。函数<code class="codeph">json_table</code>隐式使用<code class="codeph">json_value</code>作为此列，将值作为<code class="codeph">VARCHAR2</code>值返回，然后根据文本SQL字符串<code class="codeph">'true'</code>测试该值。
                        </p>
                     </li>
                  </ul>
                  <div class="example" id="GUID-5CDC25A8-A516-44B8-9C8F-0CE666933903__CACFIBBE">
                     <p class="titleinexample">示例18-3多次访问JSON数据以提取数据</p><pre class="pre codeblock"><code>SELECT json_ <span class="bold">value</span> （po_document，'$。请求者'RETURNING VARCHAR2（32）），json_ <span class="bold">query</span> （po_document，'$。ShippingInstructions。电话'RETURNING VARCHAR2（100））FROM j_purchaseorder WHERE json_ <span class="bold">exists</span> （po_document，'$。ShippingInstructions。Address.zipCode'）和json_ <span class="bold">value</span> （po_document，'$。AllowPartialShipment'RETURNING VARCHAR2（5 CHAR））= <span class="bold">'true'</span> ;</code></pre></div>
                  <!-- class="example" -->
                  <div class="example" id="GUID-5CDC25A8-A516-44B8-9C8F-0CE666933903__CACBFFGE">
                     <p class="titleinexample">示例18-4使用JSON_TABLE提取没有多个Parses的数据</p><pre class="pre codeblock"><code>SELECT jt.requestor，jt.phones FROM j_purchaseorder，json_table（po_document，'$'COLUMNS（requestor VARCHAR2（32 CHAR）PATH'$。请求者'，电话VARCHAR2（100 CHAR）FORMAT JSON PATH'$。ShippingInstructions。电话'， <span class="bold">部分</span> <span class="bold">VARCHAR2</span> （5 CHAR）路径'$。AllowPartialShipment'， <span class="bold">has_zip</span> <span class="bold">VARCHAR2</span> （5 CHAR） <span class="bold">EXISTS</span> PATH'$。ShippingInstructions。Address.zipCode'））jt WHERE <span class="bold">jt.partial ='</span> <span class="bold">true'AND jt.has_zip ='true'</span> ;</code></pre></div>
                  <!-- class="example" -->
               </div>
               <div>
                  <div class="relinfo">
                     <p><strong>相关话题</strong></p>
                     <ul>
                        <li><a href="function-JSON_VALUE.html#GUID-FD4E6FFA-8865-4682-B66A-79F77CBACD50" title="JSON的布尔值为true和false。当SQL / JSON函数json_value计算SQL / JSON路径表达式并且结果为JSON true或false时，它可以作为BOOLEAN值返回到PL / SQL，或者可以作为VARCHAR2值&#39;true&#39;返回到SQL或&#39;假&#39;。">使用SQL / JSON函数JSON_VALUE使用布尔JSON值</a></li>
                     </ul>
                  </div>
                  <div class="familylinks">
                     <div class="parentlink">
                        <p><strong>父主题：</strong> <a href="function-JSON_TABLE.html#GUID-0172660F-CE29-4765-BF2C-C405BDE8369A" title="SQL / JSON函数json_table将特定的JSON数据投影到各种SQL数据类型的列。您可以使用它将JSON文档的各个部分映射到新虚拟表的行和列中，您也可以将其视为内联视图。">SQL / JSON函数JSON_TABLE</a></p>
                     </div>
                  </div>
               </div>
               
            </div><a id="ADXDB6386"></a><a id="ADXDB6387"></a><a id="ADXDB6388"></a><a id="ADXDB6389"></a><a id="ADXDB6390"></a><a id="ADXDB6291"></a><div class="props_rev_3"><a id="GUID-37CBD672-5B0A-4FAB-A3AF-144E76686BD5" name="GUID-37CBD672-5B0A-4FAB-A3AF-144E76686BD5"></a><h3 id="ADJSN-GUID-37CBD672-5B0A-4FAB-A3AF-144E76686BD5" class="sect3"><span class="enumeration_section">18.4</span>将JSON_TABLE与JSON数组一起使用</h3>
               <div>
                  <p>JSON值可以是一个数组，也可以包含一个或多个数组，嵌套到其他JSON数组或对象中的任意数量的级别。您可以使用<code class="codeph">json_table</code> <code class="codeph">NESTED</code>路径子句来投影数组的特定元素。
                  </p>
                  <div class="section">
                     <p><a href="function-JSON_TABLE.html#GUID-37CBD672-5B0A-4FAB-A3AF-144E76686BD5__CACGGBBF">例18-5</a>从列<code class="codeph">po_document</code>的JSON数据中<code class="codeph">po_document</code>请求者和关联的电话号码。整个JSON数组<code class="codeph">Phone</code>被投影为一列JSON数据<code class="codeph">ph_arr</code> 。要将此JSON数据格式化为<code class="codeph">VARCHAR2</code>列，需要使用关键字<code class="codeph">FORMAT JSON</code> 。
                     </p>
                     <p>如果您想要投影JSON数组<code class="codeph">Phone</code>的各个<span class="italic">元素</span>而不是整个数组，该怎么办？<a href="function-JSON_TABLE.html#GUID-37CBD672-5B0A-4FAB-A3AF-144E76686BD5__CACGABDC">例18-6</a>显示了一种方法，如果数组元素是您需要投影的唯一数据，则可以使用它。
                     </p>
                     <p>如果要同时投影请求者和相应的电话数据，则执行<a href="function-JSON_TABLE.html#GUID-37CBD672-5B0A-4FAB-A3AF-144E76686BD5__CACGABDC">例18-6</a>的行路径表达式（ <code class="codeph">$.Phone[*]</code> ）不合适：它仅针对阵列<code class="codeph">Phone</code>的（电话对象）元素。
                     </p>
                     <p><a href="function-JSON_TABLE.html#GUID-37CBD672-5B0A-4FAB-A3AF-144E76686BD5__CACCCGJC">例18-7</a>显示了两种方法：使用同时针对名称和整个手机数组的<span class="italic">行路径表达式</span> ，并使用以单个手机对象的字段<code class="codeph">type</code>和<code class="codeph">number</code>为目标的<span class="italic">列路径表达式</span> 。
                     </p>
                     <p>在<a href="function-JSON_TABLE.html#GUID-37CBD672-5B0A-4FAB-A3AF-144E76686BD5__CACCCGJC">示例18-7中，</a>如<a href="function-JSON_TABLE.html#GUID-37CBD672-5B0A-4FAB-A3AF-144E76686BD5__CACGGBBF">示例18-5中所示</a> ，需要关键字<code class="codeph">FORMAT JSON</code> ，因为生成的<code class="codeph">VARCHAR2</code>列包含JSON数据，即电话类型或电话号码的数组，每个电话具有一个数组元素。此外，与<a href="function-JSON_TABLE.html#GUID-37CBD672-5B0A-4FAB-A3AF-144E76686BD5__CACGGBBF">示例18-5</a>的情况不同，列<code class="codeph">phone_type</code>和列<code class="codeph">phone_num</code>需要包装子句，因为数组<code class="codeph">Phone</code>包含多个具有字段<code class="codeph">type</code>和<code class="codeph">number</code>对象。
                     </p>
                     <p>有时你可能不想要<a href="function-JSON_TABLE.html#GUID-37CBD672-5B0A-4FAB-A3AF-144E76686BD5__CACCCGJC">例18-7</a>的效果。例如，您可能需要一个包含单个电话号码（每个号码一行）的列，而不是包含电话号码的JSON数组的列（对于给定的采购订单，所有数字都为一行）。
                     </p>
                     <p>要获得该结果，您需要通过使用数组的<code class="codeph">json_table</code> <span class="bold"><code class="codeph">NESTED</code></span>路径子句告诉<code class="codeph">json_table</code>投影数组元素。实际上， <code class="codeph">NESTED</code>路径子句作为附加行源（行模式）起作用。<a href="function-JSON_TABLE.html#GUID-37CBD672-5B0A-4FAB-A3AF-144E76686BD5__CACGAJAG">例18-8</a>说明了这一点。
                     </p>
                     <p>您可以在给定的<code class="codeph">json_table</code>调用中使用任意数量的<code class="codeph">NESTED</code>关键字。
                     </p>
                     <p>在<a href="function-JSON_TABLE.html#GUID-37CBD672-5B0A-4FAB-A3AF-144E76686BD5__CACGAJAG">例18-8中</a> ，外部<code class="codeph">COLUMNS</code>子句是嵌套（内部） <code class="codeph">COLUMNS</code>子句的父级。定义的虚拟表使用外部联接进行连接，父子句定义的表是联接中的外部表。
                     </p>
                     <p>（如果第二列子句直接嵌套在同一父项下，则两个嵌套子句将是兄弟<code class="codeph">COLUMNS</code>子句。）
                     </p>
                  </div>
                  <!-- class="section" -->
                  <div class="section"></div>
                  <!-- class="section" -->
                  <div class="example" id="GUID-37CBD672-5B0A-4FAB-A3AF-144E76686BD5__CACGGBBF">
                     <p class="titleinexample">示例18-5将整个JSON数组投影为JSON数据</p><pre class="pre codeblock"><code>SELECT jt。* FROM j_purchaseorder，json_table（po_document，'$'COLUMNS（requestor VARCHAR2（32 CHAR）PATH'$。请求者'，ph_arr VARCHAR2（100 CHAR） <span class="bold">格式JSON</span> PATH'$。ShippingInstructions。<span class="bold">电话</span> '））AS“JT”;</code></pre></div>
                  <!-- class="example" -->
                  <div class="example" id="GUID-37CBD672-5B0A-4FAB-A3AF-144E76686BD5__CACGABDC">
                     <p class="titleinexample">示例18-6投影JSON数组的元素</p><pre class="pre codeblock"><code>SELECT jt。* FROM j_purchaseorder，json_table（po_document，'$。ShippingInstructions。<span class="bold">电话[*]</span> 'COLUMNS（phone_type VARCHAR2（10）PATH'$ .type'，phone_num VARCHAR2（20）PATH'$ .number'））AS“JT”; PHONE_TYPE PHONE_NUM ---------- --------- Office 909-555-7307 Mobile 415-555-1234</code></pre></div>
                  <!-- class="example" -->
                  <div class="example" id="GUID-37CBD672-5B0A-4FAB-A3AF-144E76686BD5__CACCCGJC">
                     <p class="titleinexample">示例18-7投影JSON数组的元素以及其他数据</p><pre class="pre codeblock"><code>SELECT jt。* FROM j_purchaseorder，json_table（po_document，'$'COLUMNS（requestor VARCHAR2（32 CHAR）PATH'$。请求者'，phone_type VARCHAR2（50 CHAR） <span class="bold">FORMAT JSON WITH WRAPPER</span> PATH'$。ShippingInstructions。<span class="bold">电话[*]</span> .type'，phone_num VARCHAR2（50 CHAR） <span class="bold">FORMAT JSON WITH WRAPPER</span> PATH'$。ShippingInstructions。<span class="bold">电话[*]</span> .number'））AS“JT”;请求者PHONE_TYPE PHONE_NUM --------- ---------- --------- Alexis Bull [“Office”，“Mobile”] [“909-555-7307” ，“415-555-1234”]</code></pre></div>
                  <!-- class="example" -->
                  <div class="example" id="GUID-37CBD672-5B0A-4FAB-A3AF-144E76686BD5__CACGAJAG">
                     <p class="titleinexample">例18-8 JSON_TABLE：使用NESTED投影数组元素</p>
                     <p>此示例显示了两个用于投影数组元素的等效查询。第一个查询对目标行和列数据的表达式使用简单的点符号语法。第二个使用完整的语法。</p>
                     <p>除了列<code class="codeph">number</code> ，其SQL标识符是引号（ <code class="codeph">"number"</code> ）之外，SQL列名实际上是大写的。（列<code class="codeph">number</code>是小写的。）
                     </p>
                     <p>在第一个查询中，列名称与目标字段名称完全相同，包括字母大小写。无论它们是否被引用，它们都被解释为区分大小以便建立正确的路径。</p>
                     <p>第二个查询有：</p>
                     <ul style="list-style-type:disc">
                        <li>
                           <p>JSON列表达式和SQL / JSON行路径表达式的单独参数</p>
                        </li>
                        <li>
                           <p><code class="codeph">VARCHAR2(4000)</code>显式列数据类型<code class="codeph">VARCHAR2(4000)</code></p>
                        </li>
                        <li>
                           <p>带有SQL / JSON列路径表达式的显式<code class="codeph">PATH</code>子句，用于定位投影的对象字段</p>
                        </li>
                     </ul><pre class="pre codeblock"><code>SELECT jt。* FROM j_purchaseorder po， <span class="bold">json_table</span> （po.po_document COLUMNS（Requestor， <span class="bold">NESTED</span> ShippingInstructions。<span class="bold">电话[*]</span> COLUMNS（类型， <span class="bold">“</span>数字<span class="bold">”</span> ）））AS“JT”;</code></pre><pre class="pre codeblock"><code>SELECT jt。* FROM j_purchaseorder po， <span class="bold">json_table</span> （po.po_document，'$'COLUMNS（Requestor VARCHAR2（4000）PATH'$。请求者'， <span class="bold">NESTED</span> PATH'$。ShippingInstructions。<span class="bold">电话[*]</span> 'COLUMNS（类型VARCHAR2（4000）PATH'$ .type'， <span class="bold">“</span> number <span class="bold">”</span> VARCHAR2（4000）PATH'$ .number'）））AS“JT”;</code></pre></div>
                  <!-- class="example" -->
               </div>
               <div>
                  <div class="relinfo">
                     <p><strong>相关话题</strong></p>
                     <ul>
                        <li><a href="function-JSON_TABLE.html#GUID-BFA1FB9A-0F18-4ED2-B504-6855DC6705B5" title="为了提高查询性能，您可以使用SQL / JSON函数json_table创建投影到列的JSON数据视图。为了进一步提高查询性能，您可以创建物化视图并将JSON数据放在内存中。">使用JSON_TABLE创建JSON数据视图</a></li>
                        <li><a href="function-JSON_TABLE.html#GUID-0172660F-CE29-4765-BF2C-C405BDE8369A" title="SQL / JSON函数json_table将特定的JSON数据投影到各种SQL数据类型的列。您可以使用它将JSON文档的各个部分映射到新虚拟表的行和列中，您也可以将其视为内联视图。">SQL / JSON函数JSON_TABLE</a></li>
                     </ul>
                  </div>
                  <div class="familylinks">
                     <div class="parentlink">
                        <p><strong>父主题：</strong> <a href="function-JSON_TABLE.html#GUID-0172660F-CE29-4765-BF2C-C405BDE8369A" title="SQL / JSON函数json_table将特定的JSON数据投影到各种SQL数据类型的列。您可以使用它将JSON文档的各个部分映射到新虚拟表的行和列中，您也可以将其视为内联视图。">SQL / JSON函数JSON_TABLE</a></p>
                     </div>
                  </div>
               </div>
               
            </div>
            <div class="sect2"><a id="GUID-BFA1FB9A-0F18-4ED2-B504-6855DC6705B5" name="GUID-BFA1FB9A-0F18-4ED2-B504-6855DC6705B5"></a><h3 id="ADJSN-GUID-BFA1FB9A-0F18-4ED2-B504-6855DC6705B5" class="sect3"><span class="enumeration_section">18.5</span>使用JSON_TABLE创建基于JSON数据的视图</h3>
               <div>
                  <p>为了提高查询性能，您可以使用SQL / JSON函数<code class="codeph">json_table</code>创建投影到列的JSON数据视图。为了进一步提高查询性能，您可以创建<span class="italic">物化视图</span>并将JSON数据<span class="italic">放在内存中</span> 。
                  </p>
                  <div class="section">
                     <p><a href="function-JSON_TABLE.html#GUID-BFA1FB9A-0F18-4ED2-B504-6855DC6705B5__CACBGFFH">例18-9</a>定义了JSON数据的视图。它使用<code class="codeph">NESTED</code>路径子句来投影数组<code class="codeph">LineItems</code>的元素。
                     </p>
                     <p><a href="function-JSON_TABLE.html#GUID-BFA1FB9A-0F18-4ED2-B504-6855DC6705B5__CREATINGAMATERIALIZEDVIEWOVERJSONDA-E3D169D5">例18-10</a>定义了一个物化视图，它具有与<a href="function-JSON_TABLE.html#GUID-BFA1FB9A-0F18-4ED2-B504-6855DC6705B5__CACBGFFH">例18-9</a>相同的数据和结构。您无法直接更新此类物化视图;您必须将其视为只读视图，并通过更新基表间接更新它。如果您尝试直接修改视图，则会引发错误。如果使用关键字<code class="codeph">REFRESH</code>和<code class="codeph">ON STATEMENT</code>创建<code class="codeph">REFRESH</code>视图，则每当更新基表时，视图都会自动更新。
                     </p>
                     <p><a href="function-JSON_TABLE.html#GUID-BFA1FB9A-0F18-4ED2-B504-6855DC6705B5__CACBGFFH">例18-9</a>和<a href="function-JSON_TABLE.html#GUID-BFA1FB9A-0F18-4ED2-B504-6855DC6705B5__CREATINGAMATERIALIZEDVIEWOVERJSONDA-E3D169D5">例18-10</a>之间的唯一区别是：</p>
                     <ul style="list-style-type:disc">
                        <li>
                           <p>使用关键字<code class="codeph">MATERIALIZED</code> 。</p>
                        </li>
                        <li>
                           <p><code class="codeph">BUILD IMMEDIATE</code>的使用。</p>
                        </li>
                        <li>
                           <p>使用<code class="codeph">REFRESH FAST ON STATEMENT WITH PRIMARY KEY</code>使用<code class="codeph">REFRESH FAST ON STATEMENT WITH PRIMARY KEY</code> 。</p>
                        </li>
                     </ul>
                     <p><code class="codeph">REFRESH FAST</code>的使用意味着物化视图将以递增方式刷新。为此，您必须使用<code class="codeph">WITH PRIMARY KEY</code>或<code class="codeph">WITH ROWID</code> （如果没有主键）。Oracle建议您为具有JSON列的表指定主键，并在根据它创建<code class="codeph">WITH PRIMARY KEY</code>化视图时使用<code class="codeph">WITH PRIMARY KEY</code> 。
                     </p>
                     <p>您可以使用<code class="codeph">ON COMMIT</code>代替<code class="codeph">ON STATEMENT</code>来创建视图。前者仅在提交表更新事务时才将视图与基表同步。在此之前，表格更改不会反映在视图中。如果使用<code class="codeph">ON STATEMENT</code>则在每个DML语句之后立即同步视图。这也意味着使用<code class="codeph">ON STATEMENT</code>创建的视图反映了您可能执行的任何回滚。（随后的<code class="codeph">COMMIT</code>语句结束事务，阻止回滚。）
                     </p>
                  </div>
                  <!-- class="section" -->
                  <div class="section">
                     <div class="infoboxnotealso" id="GUID-BFA1FB9A-0F18-4ED2-B504-6855DC6705B5__GUID-E21D6F51-8A85-4198-91B4-E7C5B5D4D5DE">
                        <p class="notep1">也可以看看：</p>
                        <p><a href="../dwhsg/refreshing-materialized-views.html#DWHSG-GUID-64068234-BDB0-4C12-AE70-75571046A586" target="_blank"><span><cite>Oracle数据库数据仓库指南</cite></span></a></p>
                     </div>
                  </div>
                  <!-- class="section" -->
                  <div class="example" id="GUID-BFA1FB9A-0F18-4ED2-B504-6855DC6705B5__CACBGFFH">
                     <p class="titleinexample">示例18-9通过JSON数据创建视图</p><pre class="pre codeblock"><code>创建或替换视图j_purchaseorder_detail_view AS SELECT jt。* FROM j_purchaseorder po，json_table（po.po_document，'$'COLUMNS（po_number NUMBER（10）PATH'$。PONumber'，引用VARCHAR2（30 CHAR）PATH'$。引用'，请求者VARCHAR2（128 CHAR）PATH'$。Requestor'，userid VARCHAR2（10 CHAR）PATH'$。用户'，costcenter VARCHAR2（16）PATH'$。CostCenter'，ship_to_name VARCHAR2（20 CHAR）PATH'$。ShippingInstructions.name'，ship_to_street VARCHAR2（32 CHAR）PATH'$。ShippingInstructions。Address.street'，ship_to_city VARCHAR2（32 CHAR）PATH'$。ShippingInstructions。Address.city'，ship_to_county VARCHAR2（32 CHAR）PATH'$。ShippingInstructions。Address.county'，ship_to_postcode VARCHAR2（10 CHAR）PATH'$。ShippingInstructions。Address.postcode'，ship_to_state VARCHAR2（2 CHAR）PATH'$。ShippingInstructions。Address.state'，ship_to_zip VARCHAR2（8 CHAR）PATH'$。ShippingInstructions。Address.zipCode'，ship_to_country VARCHAR2（32 CHAR）PATH'$。ShippingInstructions。Address.country'，ship_to_phone VARCHAR2（24 CHAR）PATH'$。ShippingInstructions。电话[0] .number'，NESTED PATH'$。LineItems [*]'COLUMNS（itemno NUMBER（38）PATH'$。ItemNumber'，description VARCHAR2（256 CHAR）PATH'$。部分。描述'，upc_code VARCHAR2（14 CHAR）PATH'$。部分。UPCCode'，数量NUMBER（12,4）PATH'$。数量'，unitprice NUMBER（14,2）PATH'$。部分。UnitPrice'）））jt;</code></pre></div>
                  <!-- class="example" -->
                  <div class="example" id="GUID-BFA1FB9A-0F18-4ED2-B504-6855DC6705B5__CREATINGAMATERIALIZEDVIEWOVERJSONDA-E3D169D5">
                     <p class="titleinexample">示例18-10通过JSON数据创建实体化视图</p><pre class="pre codeblock"><code>CREATE或<span class="bold">快速</span>更换<span class="bold">物化</span>视图j_purchaseorder_materialized_view <span class="bold">BUILD IMMEDIATE</span> <span class="bold">REFRESH与主键</span> SELECT JT <span class="bold">声明</span> 。* FROM j_purchaseorder po，json_table（po.po_document，'$'COLUMNS（po_number NUMBER（10）PATH'$。PONumber'，引用VARCHAR2（30 CHAR）PATH'$。引用'，请求者VARCHAR2（128 CHAR）PATH'$。Requestor'，userid VARCHAR2（10 CHAR）PATH'$。用户'，costcenter VARCHAR2（16）PATH'$。CostCenter'，ship_to_name VARCHAR2（20 CHAR）PATH'$。ShippingInstructions.name'，ship_to_street VARCHAR2（32 CHAR）PATH'$。ShippingInstructions。Address.street'，ship_to_city VARCHAR2（32 CHAR）PATH'$。ShippingInstructions。Address.city'，ship_to_county VARCHAR2（32 CHAR）PATH'$。ShippingInstructions。Address.county'，ship_to_postcode VARCHAR2（10 CHAR）PATH'$。ShippingInstructions。Address.postcode'，ship_to_state VARCHAR2（2 CHAR）PATH'$。ShippingInstructions。Address.state'，ship_to_zip VARCHAR2（8 CHAR）PATH'$。ShippingInstructions。Address.zipCode'，ship_to_country VARCHAR2（32 CHAR）PATH'$。ShippingInstructions。Address.country'，ship_to_phone VARCHAR2（24 CHAR）PATH'$。ShippingInstructions。电话[0] .number'，NESTED PATH'$。LineItems [*]'COLUMNS（itemno NUMBER（38）PATH'$。ItemNumber'，description VARCHAR2（256 CHAR）PATH'$。部分。描述'，upc_code VARCHAR2（14 CHAR）PATH'$。部分。UPCCode'，数量NUMBER（12,4）PATH'$。数量'，unitprice NUMBER（14,2）PATH'$。部分。UnitPrice'）））jt;</code></pre></div>
                  <!-- class="example" -->
               </div>
               <div>
                  <div class="relinfo">
                     <p><strong>相关话题</strong></p>
                     <ul>
                        <li><a href="function-JSON_TABLE.html#GUID-37CBD672-5B0A-4FAB-A3AF-144E76686BD5" title="JSON值可以是一个数组，也可以包含一个或多个数组，嵌套到其他JSON数组或对象中的任意数量的级别。您可以使用json_table NESTED路径子句来投影数组的特定元素。">将JSON_TABLE与JSON数组一起使用</a></li>
                        <li><a href="using-GeoJSON-geographic-data.html#GUID-2AD827B4-871E-4652-87F3-AC33FE7839AE" title="GeoJSON对象是表示地理数据的JSON对象。提供了创建GeoJSON数据，对其进行索引以及查询的示例。">使用GeoJSON地理数据</a></li>
                     </ul>
                  </div>
                  <div class="familylinks">
                     <div class="parentlink">
                        <p><strong>父主题：</strong> <a href="function-JSON_TABLE.html#GUID-0172660F-CE29-4765-BF2C-C405BDE8369A" title="SQL / JSON函数json_table将特定的JSON数据投影到各种SQL数据类型的列。您可以使用它将JSON文档的各个部分映射到新虚拟表的行和列中，您也可以将其视为内联视图。">SQL / JSON函数JSON_TABLE</a></p>
                     </div>
                  </div>
               </div>
               
            </div>
         </div>
      </article>
   </body>
</html>