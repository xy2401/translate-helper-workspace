<html lang="en-us" dir="ltr" xml:lang="en-us">
   <head>
      <meta http-equiv="Content-Type" content="text/html; charset=utf-8"></meta>
      <meta name="viewport" content="width=device-width, initial-scale=1"></meta>
      <meta http-equiv="X-UA-Compatible" content="IE=edge"></meta>
      <meta name="abstract" content="The IM column store periodically refreshes objects that have been modified. You can control this behavior using initialization parameters and the DBMS_INMEMORY package."></meta>
      <meta name="description" content="The IM column store periodically refreshes objects that have been modified. You can control this behavior using initialization parameters and the DBMS_INMEMORY package."></meta>
      <title>优化IM列存储的重新填充</title>
      <meta property="og:site_name" content="Oracle Help Center"></meta>
      <meta property="og:title" content="Database In-Memory Guide"></meta>
      <meta property="og:description" content="The IM column store periodically refreshes objects that have been modified. You can control this behavior using initialization parameters and the DBMS_INMEMORY package."></meta>
      <link rel="stylesheet" href="/sp_common/book-template/ohc-book-template/css/book.css"></link>
      <link rel="shortcut icon" href="/sp_common/book-template/ohc-common/img/favicon.ico"></link>
      <meta name="application-name" content="Database In-Memory Guide"></meta>
      <meta name="generator" content="DITA Open Toolkit version 1.8.5 (Mode = doc)"></meta>
      <meta name="plugin" content="SP_docbuilder HTML plugin release 18.2.2"></meta>
      <link rel="alternate" href="database-memory-guide.pdf" title="PDF File" type="application/pdf"></link>
      <meta name="robots" content="all"></meta>
      <link rel="schema.dcterms" href="http://purl.org/dc/terms/"></link>
      <meta name="dcterms.created" content="2019-04-22T09:02:38-07:00"></meta>
      <meta name="dcterms.title" content="Database In-Memory Guide"></meta>
      <meta name="dcterms.dateCopyrighted" content="2016, 2019"></meta>
      <meta name="dcterms.category" content="database"></meta>
      <meta name="dcterms.identifier" content="E96137-02"></meta>
      
      <meta name="dcterms.product" content="en/database/oracle/oracle-database/19"></meta>
      
      <link rel="prev" href="optimizing-in-memory-aggregation.html" title="Previous" type="text/html"></link>
      <link rel="next" href="high-availability-and-the-im-column-store.html" title="Next" type="text/html"></link>
      <script>
        document.write('<style type="text/css">');
        document.write('body > .noscript, body > .noscript ~ * { visibility: hidden; }');
        document.write('</style>');
     </script>
      <script src="/sp_common/book-template/requirejs/require.js" data-main="/sp_common/book-template/ohc-book-template/js/book-config"></script>
      <script>
            if (window.require === undefined) {
                document.write('<script data-main="sp_common/book-template/ohc-book-template/js/book-config" src="sp_common/book-template/requirejs/require.js"><\/script>');
                document.write('<link href="sp_common/book-template/ohc-book-template/css/book.css" rel="stylesheet"/>');
            }
        </script>
      <script type="application/json" id="ssot-metadata">{"primary":{"category":{"short_name":"database","element_name":"Database","display_in_url":true},"suite":{"short_name":"oracle","element_name":"Oracle","display_in_url":true},"product_group":{"short_name":"not-applicable","element_name":"Not applicable","display_in_url":false},"product":{"short_name":"oracle-database","element_name":"Oracle Database","display_in_url":true},"release":{"short_name":"19","element_name":"Release 19","display_in_url":true}}}</script>
      
    <meta name="dcterms.isVersionOf" content="INMEM"></meta>
    <meta name="dcterms.release" content="Release 19"></meta>
  </head>
   <body dir="ltr">
      <div class="noscript alert alert-danger text-center" role="alert">
         <a href="optimizing-in-memory-aggregation.html" class="pull-left"><span class="glyphicon glyphicon-chevron-left" aria-hidden="true"></span>上一页</a> <a href="high-availability-and-the-im-column-store.html" class="pull-right">下一页<span class="glyphicon glyphicon-chevron-right" aria-hidden="true"></span></a> <span class="fa fa-exclamation-triangle" aria-hidden="true"></span>必须启用JavaScript才能正确显示此内容</div>
      <article>
         <header>
            <ol class="breadcrumb" vocab="http://schema.org/" typeof="BreadcrumbList">
               <li property="itemListElement" typeof="ListItem"><a href="index.html" property="item" typeof="WebPage"><span property="name">数据库内存指南</span></a></li>
               <li property="itemListElement" typeof="ListItem"><a href="advanced-optimizations-for-in-memory-queries.html" property="item" typeof="WebPage"><span property="name">优化内存中查询</span></a></li>
               <li class="active" property="itemListElement" typeof="ListItem">优化IM列存储的重新填充</li>
            </ol>
            <a id="GUID-85AB84D5-1308-430A-BED2-281F3E9515B2" name="GUID-85AB84D5-1308-430A-BED2-281F3E9515B2"></a>
            
            <h2 id="INMEM-GUID-85AB84D5-1308-430A-BED2-281F3E9515B2" class="sect2"><span class="enumeration_chapter">10</span>优化IM列存储的重新填充</h2>
         </header>
         <div class="ind">
            <div>
               <p>IM列存储定期刷新已修改的对象。您可以使用初始化参数和<code class="codeph">DBMS_INMEMORY</code>包来控制此行为。
               </p>
               <p>本章包含以下主题：</p>
            </div>
            <div>
               <ul class="ullinks">
                  <li class="ulchildlink"><a href="repopulation-and-dml.html#GUID-857EFBD6-6D03-4543-9FAB-F66B5C16D0C7">关于IM列存储的重新填充</a><br>重大修改后自动刷新柱状数据称为<span class="bold">重新填充</span> 。
                  </li>
                  <li class="ulchildlink"><a href="repopulation-and-dml.html#GUID-ED2DDBF3-2279-4472-84F4-195C939435AC">数据加载如何与IM列存储一起使用</a><br>IM列存储使用不同的机制，具体取决于数据加载的类型：常规DML，直接路径加载和分区交换加载。
                  </li>
                  <li class="ulchildlink"><a href="repopulation-and-dml.html#GUID-333C0C67-1422-4391-BBCB-2A10DF8AC612">数据库重新填充IM列存储时</a><br>数据库根据内部算法自动重新填充IM列存储。您可以手动禁用重新填充，并影响其侵略性。
                  </li>
                  <li class="ulchildlink"><a href="repopulation-and-dml.html#GUID-3ACF448A-C685-432B-84E9-DB8719CF3359">重新填充IM列存储的控件</a><br>默认情况下会自动进行重新填充，但您可以控制其侵略性，或完全禁用它。
                  </li>
                  <li class="ulchildlink"><a href="repopulation-and-dml.html#GUID-0E33E887-A6D5-4D56-BFC5-43D3EDFE60D4">优化Trickle Repopulation：教程</a><br>在本教程中，您将增加可用于涓流重新填充的后台进程的百分比。
                  </li>
               </ul>
               <div class="familylinks">
                  <div class="parentlink">
                     <p><strong>父主题：</strong> <a href="advanced-optimizations-for-in-memory-queries.html#GUID-33034151-7BD7-4186-B336-C693FBB27634" title="本部分介绍如何使用内存表达式，连接组和内存中聚合来优化查询。它还解释了IM列存储如何重新填充已修改的数据。">优化内存中查询</a></p>
                  </div>
               </div>
            </div>
            
            <div class="props_rev_3"><a id="GUID-857EFBD6-6D03-4543-9FAB-F66B5C16D0C7" name="GUID-857EFBD6-6D03-4543-9FAB-F66B5C16D0C7"></a><h3 id="INMEM-GUID-857EFBD6-6D03-4543-9FAB-F66B5C16D0C7" class="sect3"><span class="enumeration_section">10.1</span>关于IM列存储的重新填充</h3>
               <div>
                  <p>重大修改后自动刷新柱状数据称为<span class="bold">重新填充</span> 。
                  </p>
                  <p>本节包含以下主题：</p>
               </div>
               <div>
                  <ul class="ullinks">
                     <li class="ulchildlink"><a href="repopulation-and-dml.html#GUID-35945277-B84B-45FB-A0A2-EFC0513702D2">行修改和事务日志</a><br>内存中压缩单元（IMCU）是一种只读结构，在内部表上发生DML时不会修改数据。
                     </li>
                     <li class="ulchildlink"><a href="repopulation-and-dml.html#GUID-7FD4FA4E-E752-4B62-8FC2-55A9CC31704A">自动重新填充</a><br>当IM列存储中的对象发生DML时，数据库会自动重新填充它们。
                     </li>
                     <li class="ulchildlink"><a href="repopulation-and-dml.html#GUID-8ECC0C1A-A42A-4FA5-9790-C0F54BFB6D25">外部表的手动重新填充</a><br>外部表不符合自动重新填充的条件。
                     </li>
                  </ul>
                  <div class="familylinks">
                     <div class="parentlink">
                        <p><strong>父主题：</strong> <a href="repopulation-and-dml.html#GUID-85AB84D5-1308-430A-BED2-281F3E9515B2" title="IM列存储定期刷新已修改的对象。您可以使用初始化参数和DBMS_INMEMORY包来控制此行为。">优化IM列存储的重新填充</a></p>
                     </div>
                  </div>
               </div>
               
               <div class="sect3"><a id="GUID-35945277-B84B-45FB-A0A2-EFC0513702D2" name="GUID-35945277-B84B-45FB-A0A2-EFC0513702D2"></a><h4 id="INMEM-GUID-35945277-B84B-45FB-A0A2-EFC0513702D2" class="sect4"><span class="enumeration_section">10.1.1</span>行修改和事务日志</h4>
                  <div>
                     <p>内存中压缩单元（IMCU）是一种只读结构，在内部表上发生DML时不会修改数据。</p>
                     <p>与每个IMCU相关联的<a href="glossary.html#GUID-2EE0FA0D-D987-4B05-A714-4F6D126868F1"><span class="xrefglossterm">快照元数据单元（SMU）</span></a>跟踪<a href="glossary.html#GUID-16BF775D-7A77-4F8C-94F2-D1EBF2D67D1B"><span class="xrefglossterm">事务日志中的</span></a>行修改。如果查询访问数据并发现已修改的行，则它可以从事务日志中获取相应的rowid，然后从缓冲区缓存中检索已修改的行。
                     </p>
                     <p>随着修改次数的增加，SMU的大小以及必须从事务日志或数据库缓冲区高速缓存中提取的数据量也会增加。为避免通过日记访问降低查询性能，后台进程会重新填充已修改的对象。</p>
                  </div>
                  <div>
                     <div class="familylinks">
                        <div class="parentlink">
                           <p><strong>父主题：</strong> <a href="repopulation-and-dml.html#GUID-857EFBD6-6D03-4543-9FAB-F66B5C16D0C7" title="重大修改后自动刷新柱状数据称为重新填充。">关于IM列存储的重新填充</a></p>
                        </div>
                     </div>
                  </div>
                  
               </div>
               <div class="sect3"><a id="GUID-7FD4FA4E-E752-4B62-8FC2-55A9CC31704A" name="GUID-7FD4FA4E-E752-4B62-8FC2-55A9CC31704A"></a><h4 id="INMEM-GUID-7FD4FA4E-E752-4B62-8FC2-55A9CC31704A" class="sect4"><span class="enumeration_section">10.1.2</span>自动重新填充</h4>
                  <div>
                     <p>当IM列存储中的对象发生DML时，数据库会自动重新填充它们。</p>
                     <p>自动重新填充采用以下形式：</p>
                     <ul style="list-style-type:disc">
                        <li>
                           <p><a href="glossary.html#GUID-6F8CD872-FBA2-4519-8204-66D3E45FA1C9"><span class="xrefglossterm">基于阈值的重新种群</span></a></p>
                           <p>此表单取决于IMCU的事务日志中过时条目的百分比。</p>
                        </li>
                        <li>
                           <p><a href="glossary.html#GUID-34CC73ED-D322-4628-AC54-3F51065E8BCE"><span class="xrefglossterm">涓流重新填充</span></a></p>
                           <p>即使尚未达到陈旧阈值，此表格也会通过定期刷新柱状数据来补充基于阈值的重新填充。</p>
                        </li>
                     </ul>
                     <p>在自动重新填充期间，可以使用传统的访问机制。始终可以从缓冲区缓存或磁盘访问数据。此外，IM列存储始终与磁盘上的数据在事务上保持一致。无论查询在何处访问数据，数据库始终返回一致的结果。</p>
                  </div>
                  <div>
                     <div class="infoboxnotealso" id="GUID-7FD4FA4E-E752-4B62-8FC2-55A9CC31704A__GUID-F81C7115-FC1F-44CF-8A3E-257A6409A095">
                        <p class="notep1">也可以看看：</p>
                        <ul style="list-style-type:disc">
                           <li>
                              <p><span class="q">“ <a href="in-memory-column-store-architecture.html#GUID-2CA38EA0-26A0-44E7-97AD-A4156964BDC1" title="每个SMU都包含一个事务日志。数据库使用事务日志来保持IMCU的事务一致性。">交易日报</a> ”</span></p>
                           </li>
                           <li>
                              <p><span class="q">“ <a href="in-memory-column-store-architecture.html#GUID-15B0EEBC-31F6-4192-957A-56D79B7E63E2" title="为了响应查询和DML，服务器进程扫描列数据并更新SMU元数据。后台进程将行数据从磁盘填充到IM列存储中。">内存中流程架构</a> ”</span></p>
                           </li>
                        </ul>
                     </div>
                     <div class="familylinks">
                        <div class="parentlink">
                           <p><strong>父主题：</strong> <a href="repopulation-and-dml.html#GUID-857EFBD6-6D03-4543-9FAB-F66B5C16D0C7" title="重大修改后自动刷新柱状数据称为重新填充。">关于IM列存储的重新填充</a></p>
                        </div>
                     </div>
                  </div>
                  
               </div>
               <div class="sect3"><a id="GUID-8ECC0C1A-A42A-4FA5-9790-C0F54BFB6D25" name="GUID-8ECC0C1A-A42A-4FA5-9790-C0F54BFB6D25"></a><h4 id="INMEM-GUID-8ECC0C1A-A42A-4FA5-9790-C0F54BFB6D25" class="sect4"><span class="enumeration_section">10.1.3</span>外部表的手动重新填充</h4>
                  <div>
                     <p>外部表不符合自动重新填充的条件。</p>
                     <p>IM列存储管理外部表与内部表不同。由于外部表是只读的，因此它们不会通过DML更新，因此不依赖于事务日志。因此，数据库不会自动重新填充外部表。但是，您可以使用<code class="codeph">DBMS_INMEMORY.REPOPULATE</code>手动刷新外部表。只有在IM列存储中完全填充表时，才支持外部表的内存中扫描。
                     </p>
                     <div class="infoboxnote" id="GUID-8ECC0C1A-A42A-4FA5-9790-C0F54BFB6D25__GUID-1AE27939-3B65-476A-8822-A52175C3FDA5">
                        <p class="notep1">注意：</p>
                        <p>查询内存外部表的会话必须将初始化参数<code class="codeph">QUERY_REWRITE_INTEGRITY</code>设置为<code class="codeph">stale_tolerated</code> 。如果修改了外部表，则IM列存储的结果未定义。
                        </p>
                     </div>
                  </div>
                  <div>
                     <div class="infoboxnotealso" id="GUID-8ECC0C1A-A42A-4FA5-9790-C0F54BFB6D25__GUID-F1C5A305-D9D5-4876-B332-28BF9D728198">
                        <p class="notep1">也可以看看：</p>
                        <ul style="list-style-type:disc">
                           <li>
                              <p><span class="q">“ <a href="populating-the-imcs-manually.html#GUID-F1B26BDD-614B-4E4C-A986-8977B4B27DF0" title="此示例填充具有INMEMORY选项的外部表。">使用DBMS_INMEMORY.POPULATE填充内存中的外部表：示例</a> ”</span></p>
                           </li>
                           <li>
                              <p><a href="../refrn/QUERY_REWRITE_INTEGRITY.html#REFRN-GUID-23655494-DF65-4F0E-A89F-8333222297F5" target="_blank"><span><cite>Oracle Database Reference</cite></span></a>了解有关<code class="codeph">QUERY_REWRITE_INTEGRITY</code>初始化参数的更多信息</p>
                           </li>
                        </ul>
                     </div>
                     <div class="familylinks">
                        <div class="parentlink">
                           <p><strong>父主题：</strong> <a href="repopulation-and-dml.html#GUID-857EFBD6-6D03-4543-9FAB-F66B5C16D0C7" title="重大修改后自动刷新柱状数据称为重新填充。">关于IM列存储的重新填充</a></p>
                        </div>
                     </div>
                  </div>
                  
               </div>
            </div>
            <div class="sect2"><a id="GUID-ED2DDBF3-2279-4472-84F4-195C939435AC" name="GUID-ED2DDBF3-2279-4472-84F4-195C939435AC"></a><h3 id="INMEM-GUID-ED2DDBF3-2279-4472-84F4-195C939435AC" class="sect3"><span class="enumeration_section">10.2</span>数据加载如何与IM列存储一起使用</h3>
               <div>
                  <p>IM列存储使用不同的机制，具体取决于数据加载的类型：常规DML，直接路径加载和分区交换加载。</p>
                  <p>本节包含以下主题：</p>
               </div>
               <div>
                  <ul class="ullinks">
                     <li class="ulchildlink"><a href="repopulation-and-dml.html#GUID-A556E5A1-020A-4511-8DE7-8D5119CFB452">常规DML如何与IM列存储一起使用</a><br>常规DML一次处理一行或一行数组，并在高水位线下方插入行。无论是否启用IM列存储，数据库都使用缓冲区缓存处理DML。
                     </li>
                     <li class="ulchildlink"><a href="repopulation-and-dml.html#GUID-A8AB9768-5695-44C7-8482-6BE18A415318">直接路径加载如何与IM列存储一起使用</a><br>直接路径加载是<code class="codeph">INSERT /*+APPEND*/</code>语句或SQL * Loader操作，其中<code class="codeph">DIRECT=true</code> 。
                     </li>
                     <li class="ulchildlink"><a href="repopulation-and-dml.html#GUID-B8D2EA63-7FC2-489A-BCD3-6A9D70480EEC">分区Exchange加载如何与IM列存储一起使用</a><br><span class="bold">分区交换负载</span>是一种交换分区表的技术。交换负载几乎是瞬时的，因为它修改元数据而不是数据。
                     </li>
                  </ul>
                  <div class="familylinks">
                     <div class="parentlink">
                        <p><strong>父主题：</strong> <a href="repopulation-and-dml.html#GUID-85AB84D5-1308-430A-BED2-281F3E9515B2" title="IM列存储定期刷新已修改的对象。您可以使用初始化参数和DBMS_INMEMORY包来控制此行为。">优化IM列存储的重新填充</a></p>
                     </div>
                  </div>
               </div>
               
               <div class="sect3"><a id="GUID-A556E5A1-020A-4511-8DE7-8D5119CFB452" name="GUID-A556E5A1-020A-4511-8DE7-8D5119CFB452"></a><h4 id="INMEM-GUID-A556E5A1-020A-4511-8DE7-8D5119CFB452" class="sect4"><span class="enumeration_section">10.2.1</span>常规DML如何与IM列存储一起使用</h4>
                  <div>
                     <p>常规DML一次处理一行或一行数组，并在高水位线下方插入行。无论是否启用IM列存储，数据库都使用缓冲区缓存处理DML。</p>
                     <p>IMCU是只读的。当语句修改IMCU中的行时，IM列存储将rowid记录在关联的SMU中。</p>
                     <p>当<a href="glossary.html#GUID-F4F8F39E-D4CA-461B-86B9-8E9EF9E3BD8F"><span class="xrefglossterm">列压缩单元（CU）</span></a>条目的值与其相应日记帐分录中的值不同时，它将变为陈旧。例如，交易可能会将员工的周薪从<code class="codeph">1000</code>更改为<code class="codeph">1200</code> ，但IMCU中的实际值仍为<code class="codeph">1000</code> 。事务日志记录过时行的rowid及其SCN。</p>
                     <div class="infoboxnote" id="GUID-A556E5A1-020A-4511-8DE7-8D5119CFB452__GUID-AAD389A8-F367-4FFE-B8EF-F852F1D8B40D">
                        <p class="notep1">注意：</p>
                        <p>事务日志不记录新值。相反，它将相应的行指示为特定SCN的陈旧。</p>
                     </div>
                     <p>本节包含以下主题：</p>
                  </div>
                  <div>
                     <ul class="ullinks">
                        <li class="ulchildlink"><a href="repopulation-and-dml.html#GUID-BB1D4D35-35AF-4C19-BDC0-B4AC37D2C32F">陈旧阈值</a><br>随着IMCU中陈旧条目的数量增加，IMCU扫描的速度降低。
                        </li>
                        <li class="ulchildlink"><a href="repopulation-and-dml.html#GUID-B3C7EF3A-4AD0-48D2-9E72-F4EAB8129DF1">双缓冲</a><br>在双缓冲中，后台进程通过将原始行与最新修改的行组合来创建新的IMCU版本。
                        </li>
                     </ul>
                     <div class="familylinks">
                        <div class="parentlink">
                           <p><strong>父主题：</strong> <a href="repopulation-and-dml.html#GUID-ED2DDBF3-2279-4472-84F4-195C939435AC" title="IM列存储使用不同的机制，具体取决于数据加载的类型：常规DML，直接路径加载和分区交换加载。">数据加载如何与IM列存储一起使用</a></p>
                        </div>
                     </div>
                  </div>
                  
                  <div class="sect4"><a id="GUID-BB1D4D35-35AF-4C19-BDC0-B4AC37D2C32F" name="GUID-BB1D4D35-35AF-4C19-BDC0-B4AC37D2C32F"></a><h5 id="INMEM-GUID-BB1D4D35-35AF-4C19-BDC0-B4AC37D2C32F" class="sect5"><span class="enumeration_section">10.2.1.1</span>陈旧性阈值</h5>
                     <div>
                        <p>随着IMCU中陈旧条目的数量增加，IMCU扫描的速度降低。</p>
                        <p>性能下降是因为数据库必须从缓冲区缓存或磁盘中获取已修改的行，而不是从IM列存储中获取。因此，当IMCU中的陈旧条目数达到内部<a href="glossary.html#GUID-78ED27B2-6946-4302-BDD2-3F8A4F0DA42C"><span class="xrefglossterm">过期阈值</span></a>时，Oracle数据库会重新填充IMCU。
                        </p>
                        <p>数据库使用启发式方法确定阈值，该启发式方法考虑IMCU访问的频率和过时行的数量。对于经常访问或具有较高百分比的过时行的IMCU，重新填充更频繁。</p>
                     </div>
                     <div>
                        <div class="infoboxnotealso" id="GUID-BB1D4D35-35AF-4C19-BDC0-B4AC37D2C32F__GUID-9AEE311F-DC8E-4FB2-853E-46CA64D7E66B">
                           <p class="notep1">也可以看看：</p>
                           <ul style="list-style-type:disc">
                              <li>
                                 <p><span class="q">“ <a href="in-memory-column-store-architecture.html#GUID-50A30EC3-1CD1-4BFC-9BD1-9AC55D0B4AAE" title="内存中压缩单元（IMCU）是一个压缩的只读存储单元，包含一列或多列的数据。">内存中压缩单元（IMCU）</a> ”</span></p>
                              </li>
                              <li>
                                 <p><a href="../cncpt/memory-architecture.html#GUID-4FF66585-E469-4631-9225-29D75594CD14" target="_blank"><span><cite>Oracle Database Concepts</cite></span></a>了解有关数据库缓冲区缓存的更多信息</p>
                              </li>
                           </ul>
                        </div>
                        <div class="familylinks">
                           <div class="parentlink">
                              <p><strong>父主题：</strong> <a href="repopulation-and-dml.html#GUID-A556E5A1-020A-4511-8DE7-8D5119CFB452" title="常规DML一次处理一行或一行数组，并在高水位线下方插入行。无论是否启用IM列存储，数据库都使用缓冲区缓存处理DML。">常规DML如何与IM列存储一起使用</a></p>
                           </div>
                        </div>
                     </div>
                     
                  </div>
                  <div class="sect4"><a id="GUID-B3C7EF3A-4AD0-48D2-9E72-F4EAB8129DF1" name="GUID-B3C7EF3A-4AD0-48D2-9E72-F4EAB8129DF1"></a><h5 id="INMEM-GUID-B3C7EF3A-4AD0-48D2-9E72-F4EAB8129DF1" class="sect5"><span class="enumeration_section">10.2.1.2</span>双缓冲</h5>
                     <div>
                        <p>在双缓冲中，后台进程通过将原始行与最新修改的行组合来创建新的IMCU版本。</p>
                        <p>当数据库开始<a href="glossary.html#GUID-6F8CD872-FBA2-4519-8204-66D3E45FA1C9"><span class="xrefglossterm">基于阈值的重新填充</span></a>或<a href="glossary.html#GUID-34CC73ED-D322-4628-AC54-3F51065E8BCE"><span class="xrefglossterm">涓流重新填充时</span></a> ，IM列存储使用双缓冲。如下图所示，IM列存储同时维护两个版本的IMCU，原始陈旧的IMCU仍可供查询访问。
                        </p>
                        <div class="figure" id="GUID-B3C7EF3A-4AD0-48D2-9E72-F4EAB8129DF1__GUID-7233CD1E-DD75-451F-BD5A-FA72CFAF5185">
                           <p class="titleinfigure">图10-1双缓冲</p><img src="img/inmem_3v_021.png" alt="下面是图10-1的描述" title="下面是图10-1的描述" longdesc="img_text/inmem_3v_021.html"><br><a href="img_text/inmem_3v_021.html">“图10-1双缓冲”的描述</a></div>
                        <!-- class="figure" -->
                        <p>双缓冲的基本步骤是：</p>
                        <ol>
                           <li>
                              <p>在原始SMU中，数据库将现有IMCU标记为特定SCN的原始版本。</p>
                           </li>
                           <li>
                              <p>后台进程通过将原始行与已修改行的最新版本组合来创建新版本的IMCU。</p>
                           </li>
                           <li>
                              <p>在新SMU的日志中，数据库跟踪在IMCU创建期间发生的DML操作。</p>
                           </li>
                        </ol>
                        <p>通过这种方式，原始IMCU保持在线状态。数据库会保留新旧IMCU版本，只要它们有用，或者直到IM列存储受到空间压力。</p>
                     </div>
                     <div>
                        <div class="familylinks">
                           <div class="parentlink">
                              <p><strong>父主题：</strong> <a href="repopulation-and-dml.html#GUID-A556E5A1-020A-4511-8DE7-8D5119CFB452" title="常规DML一次处理一行或一行数组，并在高水位线下方插入行。无论是否启用IM列存储，数据库都使用缓冲区缓存处理DML。">常规DML如何与IM列存储一起使用</a></p>
                           </div>
                        </div>
                     </div>
                     
                  </div>
               </div>
               <div class="sect3"><a id="GUID-A8AB9768-5695-44C7-8482-6BE18A415318" name="GUID-A8AB9768-5695-44C7-8482-6BE18A415318"></a><h4 id="INMEM-GUID-A8AB9768-5695-44C7-8482-6BE18A415318" class="sect4"><span class="enumeration_section">10.2.2</span>直接路径加载如何与IM列存储一起使用</h4>
                  <div>
                     <p>直接路径加载是<code class="codeph">INSERT /*+APPEND*/</code>语句或SQL * Loader操作，其中<code class="codeph">DIRECT=true</code> 。
                     </p>
                     <p>在直接路径加载中，数据库将格式化数据块直接写入数据文件，绕过数据库缓冲区高速缓存。数据库将数据附加到高水位线上方，高水位线是段中已用空间和未使用空间之间的边界。直接路径加载操作是“全有或全无”操作：操作要么插入所有数据，要么不插入数据。</p>
                     <div class="figure" id="GUID-A8AB9768-5695-44C7-8482-6BE18A415318__GUID-085E34DE-8B94-4EBE-83EC-2C60715B1DA5">
                        <p class="titleinfigure">图10-2直接路径载荷和高水位标记</p><img src="img/inmem_3v_024.png" alt="下面是图10-2的描述" title="下面是图10-2的描述" longdesc="img_text/inmem_3v_024.html"><br><a href="img_text/inmem_3v_024.html">“图10-2直接路径载荷和高水位标记”的描述</a></div>
                     <!-- class="figure" -->
                     <p>在IM列存储中填充段时，直接路径加载的工作方式如下：</p>
                     <ol>
                        <li>
                           <p>使用<code class="codeph">CREATE TABLE AS SELECT</code>或<code class="codeph">INSERT /*+APPEND*/</code>语句加载数据。只有当前会话才知道DML。</p>
                        </li>
                        <li>
                           <p>你提交声明。</p>
                        </li>
                        <li>
                           <p>高水位标记移动以包含新数据，该数据向IMCU发出数据丢失的警报。<code class="codeph">V$IM_SEGMENTS.BYTES_NOT_POPULATED</code>现在指示新插入数据的大小。
                           </p>
                        </li>
                        <li>
                           <p>IM列存储基于以下算法管理重新填充：</p>
                           <ul style="list-style-type:disc">
                              <li>
                                 <p>如果受影响的对象的<code class="codeph">PRIORITY</code>设置为<code class="codeph">NONE</code>以外的值，则数据库将重新填充数据。
                                 </p>
                              </li>
                              <li>
                                 <p>如果受影响的对象的<code class="codeph">PRIORITY</code>设置为<code class="codeph">NONE</code> ，则数据库将在下一次对象的完整扫描时重新填充。
                                 </p>
                              </li>
                           </ul>
                        </li>
                     </ol>
                  </div>
                  <div>
                     <div class="familylinks">
                        <div class="parentlink">
                           <p><strong>父主题：</strong> <a href="repopulation-and-dml.html#GUID-ED2DDBF3-2279-4472-84F4-195C939435AC" title="IM列存储使用不同的机制，具体取决于数据加载的类型：常规DML，直接路径加载和分区交换加载。">数据加载如何与IM列存储一起使用</a></p>
                        </div>
                     </div>
                  </div>
                  
               </div>
               <div class="sect3"><a id="GUID-B8D2EA63-7FC2-489A-BCD3-6A9D70480EEC" name="GUID-B8D2EA63-7FC2-489A-BCD3-6A9D70480EEC"></a><h4 id="INMEM-GUID-B8D2EA63-7FC2-489A-BCD3-6A9D70480EEC" class="sect4"><span class="enumeration_section">10.2.3</span>分区交换加载如何与IM列存储一起使用</h4>
                  <div>
                     <p><span class="bold">分区交换负载</span>是一种交换分区表的技术。交换负载几乎是瞬时的，因为它修改元数据而不是数据。
                     </p>
                     <p>要执行交换加载，请按照下列步骤操作：</p>
                     <ol>
                        <li>
                           <p>创建一个称为<span class="italic">源表</span>的非分区<span class="italic">表</span> 。
                           </p>
                        </li>
                        <li>
                           <p>将行加载到源表中。</p>
                        </li>
                        <li>
                           <p>使用表交换现有的表分区（称为<span class="italic">目标分区）</span> 。
                           </p>
                        </li>
                     </ol>
                     <p>要在交换后在IM列存储中填充目标分区，必须在交换<span class="italic">之前</span>在IM列存储中填充源表。可能存在以下情况，具体取决于是否填充了目标分区：</p>
                     <ul style="list-style-type:disc">
                        <li>
                           <p>在交换之前，目标分区不会填充在IM列存储中。例如，分区为空。</p>
                           <p>交换后，不再在IM列存储中填充源表。源IMCU现在与目标分区相关联。</p>
                        </li>
                        <li>
                           <p>在交换之前，目标分区将填充在IM列存储中。</p>
                           <p>在交换之后，源表仍然填充在IM列存储中。</p>
                        </li>
                     </ul>
                     <p></p>
                     <div class="example" id="GUID-B8D2EA63-7FC2-489A-BCD3-6A9D70480EEC__GUID-484DE42C-A3B5-4A32-AC11-8E4C8778AA57">
                        <p class="titleinexample">例10-1 INMEMORY分区交换负载</p>
                        <p>在此示例中，已分区的<code class="codeph">sales</code>表具有在表级别设置的<code class="codeph">INMEMORY</code>属性。此表中的所有非空分区当前都已填充。<code class="codeph">sales_p042616</code>分区当前为空。您的目标是使用文本文件中包含的数据填充空分区<code class="codeph">sales_p042616</code> 。下图说明了之前和之后的方案。
                        </p>
                        <div class="figure" id="GUID-B8D2EA63-7FC2-489A-BCD3-6A9D70480EEC__GUID-F41EB8FE-DADD-4125-9954-B00BB4331FE7">
                           <p class="titleinfigure">图10-3分区交换</p><img src="img/inmem_3v_023.png" alt="下面是图10-3的描述" title="下面是图10-3的描述" longdesc="img_text/inmem_3v_023.html"><br><a href="img_text/inmem_3v_023.html">“图10-3分区交换”的描述</a></div>
                        <!-- class="figure" -->
                        <p>要执行交换，请执行以下操作：</p>
                        <ol>
                           <li>
                              <p>使用<code class="codeph">CREATE TABLE ...创建外部表<code class="codeph">sales_tmp_ext</code> <code class="codeph">CREATE TABLE ...ORGANIZATION EXTERNAL</code>声明。
                              </p>
                              <p>外部表不驻留在数据库中，可以是提供访问驱动程序的任何格式。该表是只读的。</p>
                           </li>
                           <li>
                              <p>使用<code class="codeph">CREATE TABLE ...创建一个名为<code class="codeph">sales_tmp_ld</code>的非分区<code class="codeph">CREATE TABLE ...AS SELECT * FROM sales_tmp_ext</code> 。
                              </p>
                              <p><code class="codeph">sales_tmp_ld</code>表不是外部表，这意味着它将行存储在数据文件中。
                              </p>
                           </li>
                           <li>
                              <p>使用<code class="codeph">ALTER TABLE</code>语句在<code class="codeph">sales_tmp_ld</code>设置<code class="codeph">INMEMORY</code>属性。
                              </p>
                              <p><code class="codeph">sales_tmp_ld</code>表现在标记为<code class="codeph">INMEMORY</code> ，但尚未填充到IM列存储中。
                              </p>
                           </li>
                           <li>
                              <p>通过强制进行全表扫描，将<code class="codeph">sales_tmp_ld</code>填充到IM列存储中。
                              </p>
                              <p>例如，以下查询强制进行完整扫描：</p><pre class="pre codeblock"><code>SELECT / * + FULL（s）NO_PARALLEL * / COUNT（*）FROM sales_tmp_ld s;</code></pre></li>
                           <li>
                              <p>使用<code class="codeph">sales_tmp_ld</code>表交换<code class="codeph">sales_p042616</code>分区。
                              </p>
                              <p>例如，更改<code class="codeph">sales</code>表，如下所示：</p><pre class="pre codeblock"><code>ALTER TABLE sales EXCHANGE PARTITION sales_p042616 WITH TABLE sales_tmp_ld;</code></pre></li>
                        </ol>
                        <p>交换完成后，将在IM列存储中填充<code class="codeph">sales_p042616</code>分区，并且不再填充<code class="codeph">sales_tmp_ld</code> 。
                        </p>
                     </div>
                     <!-- class="example" -->
                  </div>
                  <div>
                     <div class="infoboxnotealso" id="GUID-B8D2EA63-7FC2-489A-BCD3-6A9D70480EEC__GUID-5663894F-4B95-4C78-B42C-C44BE9BDFE0E">
                        <p class="notep1">也可以看看：</p>
                        <p><a href="https://www.oracle.com/pls/topic/lookup?ctx=en/database/oracle/oracle-database/19/inmem&amp;id=GUID-2AF83B38-5895-495F-B3E5-6529A2660AE8" target="_blank"><span><cite>Oracle Database VLDB和分区指南</cite></span></a> ，了解有关分区交换负载的更多信息</p>
                     </div>
                     <div class="familylinks">
                        <div class="parentlink">
                           <p><strong>父主题：</strong> <a href="repopulation-and-dml.html#GUID-ED2DDBF3-2279-4472-84F4-195C939435AC" title="IM列存储使用不同的机制，具体取决于数据加载的类型：常规DML，直接路径加载和分区交换加载。">数据加载如何与IM列存储一起使用</a></p>
                        </div>
                     </div>
                  </div>
                  
               </div>
            </div>
            <div class="sect2"><a id="GUID-333C0C67-1422-4391-BBCB-2A10DF8AC612" name="GUID-333C0C67-1422-4391-BBCB-2A10DF8AC612"></a><h3 id="INMEM-GUID-333C0C67-1422-4391-BBCB-2A10DF8AC612" class="sect3"><span class="enumeration_section">10.3</span>数据库重新填充IM列存储时</h3>
               <div>
                  <p>数据库根据内部算法自动重新填充IM列存储。您可以手动禁用重新填充，并影响其侵略性。</p>
                  <div class="infoboxnote" id="GUID-333C0C67-1422-4391-BBCB-2A10DF8AC612__GUID-5F193EDB-0B33-43C3-BEF2-D4D83E9F6C79">
                     <p class="notep1">注意：</p>
                     <p>本节介绍自动重新填充。您可以使用<code class="codeph">DBMS_INMEMORY.REPOPULATE</code>过程手动强制重新填充。
                     </p>
                  </div>
                  <p>本节包含以下主题：</p>
               </div>
               <div>
                  <ul class="ullinks">
                     <li class="ulchildlink"><a href="repopulation-and-dml.html#GUID-F0D932EF-0D37-4DF9-99C5-ABBE7E354709">基于阈值和涓流的重新种群</a><br>自动重新填充有两种形式： <span class="bold">基于阈值的重新填充</span>和<span class="bold">涓流重新填充</span> 。
                     </li>
                     <li class="ulchildlink"><a href="repopulation-and-dml.html#GUID-3B9E3B8B-2AE9-469A-9DB9-367615A6FABC">影响人口增长的因素</a><br>触发重新填充的算法是内部的，取决于几个因素。
                     </li>
                  </ul>
                  <div class="infoboxnotealso" id="GUID-333C0C67-1422-4391-BBCB-2A10DF8AC612__GUID-251FFA5E-F965-4A78-89F3-B6D888294A1A">
                     <p class="notep1">也可以看看：</p>
                     <p><a href="https://www.oracle.com/pls/topic/lookup?ctx=en/database/oracle/oracle-database/19/inmem&amp;id=GUID-DE324946-9889-49A6-A379-4ACEEF99C184" target="_blank"><span><cite>Oracle Database PL / SQL包和类型参考，</cite></span></a>以了解<code class="codeph">DBMS_INMEMORY.REPOPULATE</code>过程</p>
                  </div>
                  <div class="familylinks">
                     <div class="parentlink">
                        <p><strong>父主题：</strong> <a href="repopulation-and-dml.html#GUID-85AB84D5-1308-430A-BED2-281F3E9515B2" title="IM列存储定期刷新已修改的对象。您可以使用初始化参数和DBMS_INMEMORY包来控制此行为。">优化IM列存储的重新填充</a></p>
                     </div>
                  </div>
               </div>
               
               <div class="sect3"><a id="GUID-F0D932EF-0D37-4DF9-99C5-ABBE7E354709" name="GUID-F0D932EF-0D37-4DF9-99C5-ABBE7E354709"></a><h4 id="INMEM-GUID-F0D932EF-0D37-4DF9-99C5-ABBE7E354709" class="sect4"><span class="enumeration_section">10.3.1</span>基于阈值和涓流的重新种群</h4>
                  <div>
                     <p>自动重新填充有两种形式： <span class="bold">基于阈值的重新填充</span>和<span class="bold">涓流重新填充</span> 。
                     </p>
                     <p>自动重新填充始终检查陈旧的日记帐分录并使用双缓冲。然而，人口增长有不同的触发因素：</p>
                     <ul style="list-style-type:disc">
                        <li>
                           <p>基于阈值的重新填充</p>
                           <p>当事务日志中记录的更改数达到内部<a href="glossary.html#GUID-78ED27B2-6946-4302-BDD2-3F8A4F0DA42C"><span class="xrefglossterm">过期阈值</span></a>时，数据库将重新填充IMCU。当<code class="codeph">INMEMORY_MAX_POPULATE_SERVERS</code>初始化参数设置为<code class="codeph">0</code>以外的值时，将自动执行基于阈值的重新填充。
                           </p>
                        </li>
                        <li>
                           <p>涓流重新繁殖</p>
                           <p>IMCO（内存协调器）后台进程定期检查是否存在过时行，然后将IMCU添加到重新填充队列。这种机制<span class="italic">不</span>依赖于满足过时阈值。<code class="codeph">INMEMORY_TRICKLE_REPOPULATE_SERVERS_PERCENT</code>初始化参数限制用于涓流重新填充的后台进程数。将此参数设置为<code class="codeph">0</code>将禁用涓流重新填充。
                           </p>
                        </li>
                     </ul>
                     <p>Trickle repopulation类似于Java垃圾收集。该机制的工作原理如下：</p>
                     <ol>
                        <li>
                           <p>IMCO醒来。</p>
                        </li>
                        <li>
                           <p>IMCO确定是否需要执行任何人口任务，包括与IMCU关联的<a href="glossary.html#GUID-16BF775D-7A77-4F8C-94F2-D1EBF2D67D1B"><span class="xrefglossterm">事务日志</span></a>中是否存在任何陈旧条目。</p>
                        </li>
                        <li>
                           <p>如果IMCO发现过时的条目，那么它会触发空间管理工作进程（W <span class="italic">nnn</span> ）来创建新版本的IMCU。</p>
                           <p>在创建IMCU期间，数据库会在事务日志中记录已修改行的rowid。</p>
                        </li>
                        <li>
                           <p>IMCO睡了两分钟，然后返回到步骤1。</p>
                        </li>
                     </ol>
                     <div class="figure" id="GUID-F0D932EF-0D37-4DF9-99C5-ABBE7E354709__GUID-491CFB3A-8653-404F-A02C-AE88BDE4D6CB">
                        <p class="titleinfigure">图10-4涓流重新填充</p><img src="img/inmem_3v_022.png" alt="下面是图10-4的描述" title="下面是图10-4的描述" longdesc="img_text/inmem_3v_022.html"><br><a href="img_text/inmem_3v_022.html">“图10-4涓流重新填充”的描述</a></div>
                     <!-- class="figure" -->
                     <p>例如，数据库可能每天忙碌8小时。大多数SMU包含少量事务日志条目（低于过期阈值）。当数据库安静时，IMCO唤醒，检查日志以确定哪些IMCU具有过时条目，然后使用涓流重新填充来刷新IMCU。</p>
                  </div>
                  <div>
                     <div class="infoboxnotealso" id="GUID-F0D932EF-0D37-4DF9-99C5-ABBE7E354709__GUID-DFD8C9ED-6998-439A-92EB-86AC81A98337">
                        <p class="notep1">也可以看看：</p>
                        <ul style="list-style-type:disc">
                           <li>
                              <p><span class="q">“ <a href="in-memory-column-store-architecture.html#GUID-15B0EEBC-31F6-4192-957A-56D79B7E63E2" title="为了响应查询和DML，服务器进程扫描列数据并更新SMU元数据。后台进程将行数据从磁盘填充到IM列存储中。">内存中流程架构</a> ”</span></p>
                           </li>
                           <li>
                              <p><span class="q">“ <a href="in-memory-column-store-architecture.html#GUID-2CA38EA0-26A0-44E7-97AD-A4156964BDC1" title="每个SMU都包含一个事务日志。数据库使用事务日志来保持IMCU的事务一致性。">交易日报</a> ”</span></p>
                           </li>
                           <li>
                              <p><a href="../refrn/background-processes.html#REFRN104" target="_blank"><span><cite>Oracle数据库参考</cite></span></a> ，了解内存中的后台进程</p>
                           </li>
                        </ul>
                     </div>
                     <div class="familylinks">
                        <div class="parentlink">
                           <p><strong>父主题：</strong> <a href="repopulation-and-dml.html#GUID-333C0C67-1422-4391-BBCB-2A10DF8AC612" title="数据库根据内部算法自动重新填充IM列存储。您可以手动禁用重新填充，并影响其侵略性。">数据库重新填充IM列存储时</a></p>
                        </div>
                     </div>
                  </div>
                  
               </div>
               <div class="sect3"><a id="GUID-3B9E3B8B-2AE9-469A-9DB9-367615A6FABC" name="GUID-3B9E3B8B-2AE9-469A-9DB9-367615A6FABC"></a><h4 id="INMEM-GUID-3B9E3B8B-2AE9-469A-9DB9-367615A6FABC" class="sect4"><span class="enumeration_section">10.3.2</span>影响人口增长的因素</h4>
                  <div>
                     <p>触发重新填充的算法是内部的，取决于几个因素。</p>
                     <p>影响人口增长的主要因素如下：</p>
                     <ul style="list-style-type:disc">
                        <li>
                           <p>DML的变化率</p>
                           <p>随着修改行数的增加，过时柱状数据的百分比增加。事务日志增长，增加了使用缓冲区缓存来满足查询的需求。</p>
                        </li>
                        <li>
                           <p>DML操作的类型</p>
                           <p>通常，插入比删除和更新具有更少的性能开销，因为插入通常会进入新的数据块。</p>
                        </li>
                        <li>
                           <p>数据块中已修改行的位置</p>
                           <p>分组在同一数据库块或表分区中的更改对分布在整个表中的更改的影响较小。对每个IMCU进行版本控制比对少量IMCU进行版本控制具有更大的影响。</p>
                        </li>
                        <li>
                           <p>压缩级别应用于<code class="codeph">INMEMORY</code>对象</p>
                           <p>由于<a href="glossary.html#GUID-D54C930C-1B27-40FC-9B15-25670A707365"><span class="xrefglossterm">双缓冲</span></a> ，具有较高压缩级别的表在重新填充期间会产生更多查询和DML开销。例如， <code class="codeph">MEMCOMPRESS FOR CAPACITY HIGH</code>比<code class="codeph">MEMCOMPRESS FOR DML</code>产生更多的开销。</p>
                        </li>
                        <li>
                           <p>活动工作进程数</p>
                           <p>随着工作进程数量的增加，更多工作并行发生。因此，人口增长率增加。</p>
                        </li>
                     </ul>
                  </div>
                  <div>
                     <div class="infoboxnotealso" id="GUID-3B9E3B8B-2AE9-469A-9DB9-367615A6FABC__GUID-5F7D7DD9-DAB8-42FE-8716-42ED56F3FBA4">
                        <p class="notep1">也可以看看：</p>
                        <ul style="list-style-type:disc">
                           <li>
                              <p><span class="q">“ <a href="populating-objects-in-memory.html#GUID-1965B8FE-B34E-42D9-9E97-45D6579162A4" title="根据您的要求，您可以在不同级别压缩内存中对象。">IM列存储压缩方法</a> ”</span></p>
                           </li>
                           <li>
                              <p><a href="https://www.oracle.com/pls/topic/lookup?ctx=en/database/oracle/oracle-database/19/inmem&amp;id=REFRN10358" target="_blank"><span><cite>Oracle数据库参考</cite></span></a> ，了解<code class="codeph">INMEMORY_TRICKLE_REPOPULATE_SERVERS_PERCENT</code>初始化参数</p>
                           </li>
                        </ul>
                     </div>
                     <div class="familylinks">
                        <div class="parentlink">
                           <p><strong>父主题：</strong> <a href="repopulation-and-dml.html#GUID-333C0C67-1422-4391-BBCB-2A10DF8AC612" title="数据库根据内部算法自动重新填充IM列存储。您可以手动禁用重新填充，并影响其侵略性。">数据库重新填充IM列存储时</a></p>
                        </div>
                     </div>
                  </div>
                  
               </div>
            </div>
            <div class="sect2"><a id="GUID-3ACF448A-C685-432B-84E9-DB8719CF3359" name="GUID-3ACF448A-C685-432B-84E9-DB8719CF3359"></a><h3 id="INMEM-GUID-3ACF448A-C685-432B-84E9-DB8719CF3359" class="sect3"><span class="enumeration_section">10.4</span> IM列存储重新填充的控制</h3>
               <div>
                  <p>默认情况下会自动进行重新填充，但您可以控制其侵略性，或完全禁用它。</p>
                  <div class="section">
                     <p class="subhead2" id="GUID-3ACF448A-C685-432B-84E9-DB8719CF3359__GUID-13FB3FD1-FA12-4EF4-90E1-ABD2AEA3119D">初始化参数</p>
                     <p>以下初始化参数会影响后台进程行为：</p>
                     <ul style="list-style-type:disc">
                        <li>
                           <p><code class="codeph">INMEMORY_MAX_POPULATE_SERVERS</code></p>
                           <p>此参数限制可用于填充和重新填充的最大W <span class="italic">nnn</span>过程数（基于阈值和涓流）。默认值是<code class="codeph">CPU_COUNT</code>一半。此参数充当限制，防止这些服务器进程重载数据库的其余部分。将此参数设置为<code class="codeph">0</code>将禁用填充和重新填充。
                           </p>
                           <div class="infoboxnote" id="GUID-3ACF448A-C685-432B-84E9-DB8719CF3359__GUID-3E7D6F30-3014-4BD9-BE08-04E5036761FC">
                              <p class="notep1">警告：</p>
                              <p>注意不要将此参数的值设置得太高。如果将其设置为接近核心数或更高，则没有CPU可用于系统的其余部分运行。</p>
                           </div>
                        </li>
                        <li>
                           <p><code class="codeph">INMEMORY_TRICKLE_REPOPULATE_SERVERS_PERCENT</code></p>
                           <p>此参数限制执行涓流重新填充的总人口和重新填充过程的百分比。其效果是限制在两分钟间隔内通过涓流再增殖重新填充的IMCU的数量。</p>
                           <p>此参数的值是<code class="codeph">INMEMORY_MAX_POPULATE_SERVERS</code>值的百分比。例如，如果<code class="codeph">INMEMORY_TRICKLE_REPOPULATE_SERVERS_PERCENT</code>为<code class="codeph">5</code> ％，并且<code class="codeph">INMEMORY_MAX_POPULATE_SERVERS</code>为<code class="codeph">20</code> ，则IM列存储使用平均1核（.05 * 20）进行涓流重新填充。
                           </p>
                           <p>要以增加的后台CPU为代价来提高吞吐量，请将此参数设置为更高的值，例如<code class="codeph">5</code>或<code class="codeph">10</code> 。不允许大于<code class="codeph">50</code>的值，因此至少有一半的<code class="codeph">INMEMORY_MAX_POPULATE_SERVERS</code>进程可用于其他任务。
                           </p>
                           <p>将此参数设置为<code class="codeph">0</code>将禁用涓流填充。
                           </p>
                        </li>
                     </ul>
                     <div class="infoboxnotealso" id="GUID-3ACF448A-C685-432B-84E9-DB8719CF3359__GUID-5990A616-9569-4695-8EFA-649CE8B27F3A">
                        <p class="notep1">也可以看看：</p>
                        <ul style="list-style-type:disc">
                           <li>
                              <p><a href="../refrn/INMEMORY_TRICKLE_REPOPULATE_SERVERS_PERCENT.html#GUID-499850D5-6418-4AD3-BEB5-865C4A165C39" target="_blank"><span><cite>Oracle数据库参考</cite></span></a>了解<code class="codeph">INMEMORY_TRICKLE_REPOPULATE_SERVERS_PERCENT</code></p>
                           </li>
                           <li>
                              <p><a href="../refrn/INMEMORY_MAX_POPULATE_SERVERS.html#GUID-3428C0FF-5AA9-491C-908E-F0BD88095A5A" target="_blank"><span><cite>Oracle数据库参考</cite></span></a>了解<code class="codeph">INMEMORY_MAX_POPULATE_SERVERS</code></p>
                           </li>
                        </ul>
                     </div>
                  </div>
                  <!-- class="section" -->
                  <div class="section">
                     <p class="subhead2" id="GUID-3ACF448A-C685-432B-84E9-DB8719CF3359__GUID-0F8F4F97-085D-411E-9C31-0FB7C8BC2893">DBMS_INMEMORY.REPOPULATE过程</p>
                     <p>要手动重新填充表，分区或子分区，请使用<code class="codeph">DBMS_INMEMORY.REPOPULATE</code>过程。只有当前在IM列存储中填充的对象才有资格进行重新填充。
                     </p>
                     <p><code class="codeph">force</code>参数可以使用以下值：</p>
                     <ul style="list-style-type:disc">
                        <li>
                           <p><code class="codeph">FALSE</code> - 数据库仅重新填充包含已修改行的IMCU。这是默认值。
                           </p>
                        </li>
                        <li>
                           <p><code class="codeph">TRUE</code> - 数据库删除该段，然后重建它。数据库递增统计信息并执行与初始填充相关的所有其他任务。
                           </p>
                        </li>
                     </ul>
                     <p>例如，IMCU 1包含行1到500,000，IMCU 2包含行500,001到1,000,000。语句修改行600,000。当<code class="codeph">force</code>为<code class="codeph">FALSE</code> ，数据库仅重新填充IMCU 2。当<code class="codeph">force</code>为<code class="codeph">TRUE</code> ，数据库将重新填充两个IMCU。
                     </p>
                     <p>进一步考虑<code class="codeph">INMEMORY_VIRTUAL_COLUMNS</code>初始化参数设置为<code class="codeph">ENABLE</code> ，并且应用程序创建新的虚拟列。当<code class="codeph">force</code>为<code class="codeph">FALSE</code> ，数据库仅使用新列重新填充IMCU 2。当<code class="codeph">force</code>为<code class="codeph">TRUE</code> ，数据库将使用新列重新填充两个IMCU。
                     </p>
                  </div>
                  <!-- class="section" -->
               </div>
               <div>
                  <div class="infoboxnotealso" id="GUID-3ACF448A-C685-432B-84E9-DB8719CF3359__GUID-679643C5-6077-4216-AE7C-59B51A133470">
                     <p class="notep1">也可以看看：</p>
                     <p><a href="https://www.oracle.com/pls/topic/lookup?ctx=en/database/oracle/oracle-database/19/inmem&amp;id=GUID-DE324946-9889-49A6-A379-4ACEEF99C184" target="_blank"><span><cite>Oracle Database PL / SQL包和类型参考，</cite></span></a>以了解有关<code class="codeph">DBMS_INMEMORY.REPOPULATE</code>更多信息</p>
                  </div>
                  <div class="familylinks">
                     <div class="parentlink">
                        <p><strong>父主题：</strong> <a href="repopulation-and-dml.html#GUID-85AB84D5-1308-430A-BED2-281F3E9515B2" title="IM列存储定期刷新已修改的对象。您可以使用初始化参数和DBMS_INMEMORY包来控制此行为。">优化IM列存储的重新填充</a></p>
                     </div>
                  </div>
               </div>
               
            </div>
            <div class="sect2"><a id="GUID-0E33E887-A6D5-4D56-BFC5-43D3EDFE60D4" name="GUID-0E33E887-A6D5-4D56-BFC5-43D3EDFE60D4"></a><h3 id="INMEM-GUID-0E33E887-A6D5-4D56-BFC5-43D3EDFE60D4" class="sect3"><span class="enumeration_section">10.5</span>优化Trickle Repopulation：教程</h3>
               <div>
                  <p>在本教程中，您将增加可用于涓流重新填充的后台进程的百分比。</p>
                  <div class="section">
                     <p class="subhead2" id="GUID-0E33E887-A6D5-4D56-BFC5-43D3EDFE60D4__GUID-48C488CF-84F4-4AE6-97DE-63301E8E7F92">假设</p>
                     <p>本教程假设以下内容：</p>
                     <ul style="list-style-type:disc">
                        <li>
                           <p>IM列存储已启用。</p>
                        </li>
                        <li>
                           <p>您希望将更多CPU用于执行涓流重新填充的空间管理工作进程（W <span class="italic">nnn</span> ）。
                           </p>
                        </li>
                        <li>
                           <p>数据库服务器有12个CPU核心。</p>
                        </li>
                     </ul>
                  </div>
                  <!-- class="section" -->
                  <div class="section">
                     <p class="subhead2" id="GUID-0E33E887-A6D5-4D56-BFC5-43D3EDFE60D4__GUID-75583E14-6AB2-4D56-8C9D-43B3873C9F5C">为了增加人口增长的积极性：</p>
                     <ol>
                        <li>
                           <p>在SQL * Plus或SQL Developer中，以具有管理权限的用户身份登录数据库。</p>
                        </li>
                        <li>
                           <p>显示与重新填充有关的初始化参数的设置（包括样品输出）：</p><pre class="pre codeblock"><code>SHOW PARAMETER POPULATE_SERVERS NAME TYPE VALUE ------------------------------------ -------- --- ----------- inmemory_max_populate_servers整数12 inmemory_trickle_repopulate_servers_percent整数1</code></pre><p>前面的输出表明12个核心可用于填充和重新填充任务。<code class="codeph">INMEMORY_TRICKLE_REPOPULATE_SERVERS_PERCENT</code>是<code class="codeph">INMEMORY_MAX_POPULATE_SERVERS</code>值的1％。在可用于填充和重新填充任务的服务器进程中，IM列存储可以使用最多.12 CPU核心（.01 * 12）进行涓流重新填充。
                           </p>
                        </li>
                        <li>
                           <p>将涓流重新填充最大值增加到<code class="codeph">INMEMORY_MAX_POPULATE_SERVERS</code>初始化参数值的25％。
                           </p>
                           <p>例如，使用以下语句：</p><pre class="pre codeblock"><code>ALTER SYSTEM SET INMEMORY_TRICKLE_REPOPULATE_SERVERS_PERCENT = 25;</code></pre><p>因此，IM列存储现在使用最多3个CPU核心（.25 * 12）进行涓流重新填充，总共12个可用于人口和重新填充工作。</p>
                        </li>
                     </ol>
                  </div>
                  <!-- class="section" -->
               </div>
               <div>
                  <div class="infoboxnotealso" id="GUID-0E33E887-A6D5-4D56-BFC5-43D3EDFE60D4__GUID-5990A616-9569-4695-8EFA-649CE8B27F3A">
                     <p class="notep1">也可以看看：</p>
                     <ul style="list-style-type:disc">
                        <li>
                           <p><a href="../refrn/INMEMORY_TRICKLE_REPOPULATE_SERVERS_PERCENT.html#GUID-499850D5-6418-4AD3-BEB5-865C4A165C39" target="_blank"><span><cite>Oracle数据库参考</cite></span></a>了解<code class="codeph">INMEMORY_TRICKLE_REPOPULATE_SERVERS_PERCENT</code></p>
                        </li>
                        <li>
                           <p><a href="../refrn/INMEMORY_MAX_POPULATE_SERVERS.html#GUID-3428C0FF-5AA9-491C-908E-F0BD88095A5A" target="_blank"><span><cite>Oracle数据库参考</cite></span></a>了解<code class="codeph">INMEMORY_MAX_POPULATE_SERVERS</code></p>
                        </li>
                     </ul>
                  </div>
                  <div class="familylinks">
                     <div class="parentlink">
                        <p><strong>父主题：</strong> <a href="repopulation-and-dml.html#GUID-85AB84D5-1308-430A-BED2-281F3E9515B2" title="IM列存储定期刷新已修改的对象。您可以使用初始化参数和DBMS_INMEMORY包来控制此行为。">优化IM列存储的重新填充</a></p>
                     </div>
                  </div>
               </div>
               
            </div>
         </div>
      </article>
   </body>
</html>