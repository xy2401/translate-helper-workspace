<html lang="en-us" dir="ltr" xml:lang="en-us">
   <head>
      <meta http-equiv="Content-Type" content="text/html; charset=utf-8"></meta>
      <meta name="viewport" content="width=device-width, initial-scale=1"></meta>
      <meta http-equiv="X-UA-Compatible" content="IE=edge"></meta>
      <meta name="abstract" content="This chapter describes high availability (HA) features in OCI."></meta>
      <meta name="description" content="This chapter describes high availability (HA) features in OCI."></meta>
      <title>OCI的高可用性</title>
      <meta property="og:site_name" content="Oracle Help Center"></meta>
      <meta property="og:title" content="Programmer&#39;s Guide"></meta>
      <meta property="og:description" content="This chapter describes high availability (HA) features in OCI."></meta>
      <link rel="stylesheet" href="/sp_common/book-template/ohc-book-template/css/book.css"></link>
      <link rel="shortcut icon" href="/sp_common/book-template/ohc-common/img/favicon.ico"></link>
      <meta name="application-name" content="Programmer&#39;s Guide"></meta>
      <meta name="generator" content="DITA Open Toolkit version 1.8.5 (Mode = doc)"></meta>
      <meta name="plugin" content="SP_docbuilder HTML plugin release 18.2.2"></meta>
      <link rel="alternate" href="oracle-call-interface-programmers-guide.pdf" title="PDF File" type="application/pdf"></link>
      <meta name="robots" content="all"></meta>
      <link rel="schema.dcterms" href="http://purl.org/dc/terms/"></link>
      <meta name="dcterms.created" content="2019-01-14T08:46:00-08:00"></meta>
      
      <meta name="dcterms.dateCopyrighted" content="1996, 2019"></meta>
      <meta name="dcterms.category" content="database"></meta>
      <meta name="dcterms.identifier" content="E96204-01"></meta>
      
      <meta name="dcterms.product" content="en/database/oracle/oracle-database/19"></meta>
      
      <link rel="prev" href="session-and-connection-pooling.html" title="Previous" type="text/html"></link>
      <link rel="next" href="notification-streams-advanced-queuing.html" title="Next" type="text/html"></link>
      <script>
        document.write('<style type="text/css">');
        document.write('body > .noscript, body > .noscript ~ * { visibility: hidden; }');
        document.write('</style>');
     </script>
      <script src="/sp_common/book-template/requirejs/require.js" data-main="/sp_common/book-template/ohc-book-template/js/book-config"></script>
      <script>
            if (window.require === undefined) {
                document.write('<script data-main="sp_common/book-template/ohc-book-template/js/book-config" src="sp_common/book-template/requirejs/require.js"><\/script>');
                document.write('<link href="sp_common/book-template/ohc-book-template/css/book.css" rel="stylesheet"/>');
            }
        </script>
      <script type="application/json" id="ssot-metadata">{"primary":{"category":{"short_name":"database","element_name":"Database","display_in_url":true},"suite":{"short_name":"oracle","element_name":"Oracle","display_in_url":true},"product_group":{"short_name":"not-applicable","element_name":"Not applicable","display_in_url":false},"product":{"short_name":"oracle-database","element_name":"Oracle Database","display_in_url":true},"release":{"short_name":"19","element_name":"Release 19","display_in_url":true}}}</script>
      
    <meta name="dcterms.title" content="Oracle Call Interface Programmer&#39;s Guide"></meta>
    <meta name="dcterms.isVersionOf" content="LNOCI"></meta>
    <meta name="dcterms.release" content="Release 19"></meta>
  </head>
   <body dir="ltr">
      <div class="noscript alert alert-danger text-center" role="alert">
         <a href="session-and-connection-pooling.html" class="pull-left"><span class="glyphicon glyphicon-chevron-left" aria-hidden="true"></span>上一页</a> <a href="notification-streams-advanced-queuing.html" class="pull-right">下一页<span class="glyphicon glyphicon-chevron-right" aria-hidden="true"></span></a> <span class="fa fa-exclamation-triangle" aria-hidden="true"></span>必须启用JavaScript才能正确显示此内容</div>
      <article>
         <header>
            <ol class="breadcrumb" vocab="http://schema.org/" typeof="BreadcrumbList">
               <li property="itemListElement" typeof="ListItem"><a href="index.html" property="item" typeof="WebPage"><span property="name">程序员指南</span></a></li>
               <li class="active" property="itemListElement" typeof="ListItem">OCI的高可用性</li>
            </ol>
            <a id="GUID-F9EC61C1-5892-41E3-A382-853E9A47789C" name="GUID-F9EC61C1-5892-41E3-A382-853E9A47789C"></a>
            
            <h2 id="LNOCI-GUID-F9EC61C1-5892-41E3-A382-853E9A47789C" class="sect2"><span class="enumeration_chapter">12</span> OCI的高可用性</h2>
         </header>
         <div class="ind">
            <div>
               <p>本章介绍OCI中的高可用性（HA）功能。</p>
               <div class="p">本章包括以下主题：<ul style="list-style-type:disc">
                     <li>
                        <p><a href="high-availability-in-oci.html#GUID-A8B79A40-C4AA-4FBA-8042-C70C8FD2D2EF" title="运行时连接负载平衡将工作请求路由到最能为工作提供服务的会话池中的会话。">运行时连接负载平衡</a></p>
                     </li>
                     <li>
                        <p><a href="high-availability-in-oci.html#GUID-EF4E3248-D4F9-4F06-ADC5-700A36AAE5E7" title="如果连接到Oracle RAC数据库的高可用性客户端出现数据库故障，请使用HA事件通知向客户端提供尽力而为的编程信号。">HA事件通知</a></p>
                     </li>
                     <li>
                        <p><a href="high-availability-in-oci.html#GUID-F7817CD2-4A2C-4D37-BD36-56DBABD4725F" title="透明应用程序故障转移（TAF）是一种客户端功能，旨在最大程度地减少由于实例或网络故障导致数据库连接失败时发生的对最终用户应用程序的中断。">OCI中的透明应用程序故障转移</a></p>
                     </li>
                     <li>
                        <p><a href="high-availability-in-oci.html#GUID-A675AF7B-6FF0-460D-A6E6-C15E7C328C8F" title="Transaction Guard在计划内或计划外中断的情况下引入了最多一次事务执行的概念，以帮助防止故障转移时的应用程序提交原始提交的重复提交。">OCI和交易卫士</a></p>
                     </li>
                     <li>
                        <p><a href="high-availability-in-oci.html#GUID-A8DD9422-2F82-42A9-9555-134296416E8F" title="应用程序连续性（AC）在计划内和计划外中断期间提供高可用性（HA）。Oracle数据库12c第2版（12.2）引入了对AC的OCI支持。">OCI和应用程序连续性</a></p>
                     </li>
                  </ul>
               </div>
            </div>
            <div class="props_rev_3"><a id="GUID-A8B79A40-C4AA-4FBA-8042-C70C8FD2D2EF" name="GUID-A8B79A40-C4AA-4FBA-8042-C70C8FD2D2EF"></a><h3 id="LNOCI-GUID-A8B79A40-C4AA-4FBA-8042-C70C8FD2D2EF" class="sect3"><span class="enumeration_section">12.1</span>运行时连接负载平衡</h3>
               <div>
                  <p>运行时连接负载平衡将工作请求路由到最能为工作提供服务的会话池中的会话。</p>
                  <p>它发生在应用程序从现有会话池中选择会话时，因此是非常频繁的活动。对于仅在一个实例上支持服务的会话池，池中的第一个可用会话就足够了。当池支持跨多个实例的服务时，需要跨实例分发工作请求，以便提供更好服务或具有更大容量的实例获得更多请求。</p>
                  <p>应用程序必须连接到Oracle RAC实例才能启用运行时连接负载平衡。此外，这些应用程序必须：</p>
                  <ul style="list-style-type:disc">
                     <li>
                        <p>在<code class="codeph">OCI_EVENTS</code>模式下初始化OCI环境</p>
                     </li>
                     <li>
                        <p>连接到启用了运行时连接负载平衡的服务（使用<code class="codeph">DBMS_SERVICE.MODIFY_SERVICE</code>过程根据需要设置<code class="codeph">GOAL</code>和<code class="codeph">CLB_GOAL</code> ）</p>
                     </li>
                     <li>
                        <p>链接线程库</p>
                     </li>
                  </ul>
                  <div class="infoboxnotealso" id="GUID-A8B79A40-C4AA-4FBA-8042-C70C8FD2D2EF__GUID-50651043-7613-4F36-95E2-4122F0E8CD32">
                     <p class="notep1">也可以看看：</p>
                     <ul style="list-style-type:disc">
                        <li>
                           <p>有关负载平衡建议的信息<a href="../racad/workload-management-with-dynamic-database-services.html#RACAD7302" target="_blank"><span><cite>，请参见“Oracle Real Application Clusters管理和部署指南”</cite></span></a></p>
                        </li>
                        <li>
                           <p><a href="../adfns/connection_strategies.html#ADFNS229" target="_blank"><span><cite>“Oracle数据库开发指南”</cite></span></a> ，了解有关为支持的接口启用和禁用运行时连接负载平衡以及接收负载平衡顾问FAN事件的信息</p>
                        </li>
                     </ul>
                  </div>
               </div>
            </div>
            <div class="props_rev_3"><a id="GUID-EF4E3248-D4F9-4F06-ADC5-700A36AAE5E7" name="GUID-EF4E3248-D4F9-4F06-ADC5-700A36AAE5E7"></a><h3 id="LNOCI-GUID-EF4E3248-D4F9-4F06-ADC5-700A36AAE5E7" class="sect3"><span class="enumeration_section">12.2</span> HA事件通知</h3>
               <div>
                  <p>如果连接到Oracle RAC数据库的高可用性客户端出现数据库故障，请使用HA事件通知向客户端提供尽力而为的编程信号。</p>
                  <p>假设用户使用Web浏览器登录访问后端数据库服务器的应用程序服务器。在用户已知故障之前，数据库实例的故障可能导致等待时间长达数分钟。HA事件通知提供了快速检测服务器实例故障，将其传达给客户端，关闭连接以及清除连接池中的空闲连接的能力。</p>
                  <p>对于连接到Oracle RAC数据库的高可用性客户端，如果数据库出现故障，您可以使用HA事件通知向客户端提供尽力而为的编程信号。客户端应用程序可以在环境句柄上注册回调，以表示对此信息的兴趣。当发生应用于此客户端建立的连接的重大故障事件时，将调用回调，其中包含有关事件（事件有效负载）的信息以及由于故障而断开连接的连接列表（服务器句柄）。</p>
                  <p>例如，考虑一个客户端应用程序，它具有两个到实例A的连接和两个到同一数据库的实例B的连接。如果实例A发生故障，则会向客户端发送事件通知，然后客户端断开与实例B的两个连接并调用已注册的回调。请注意，如果同一数据库的另一个实例C发生故障，则不会通知客户端（因为它不会影响任何客户端的连接）。</p>
                  <p>HA事件通知机制可在出现故障时改善应用程序的响应时间。在Oracle数据库10g第2版（10.2）中引入该机制之前，只有在TCP超时间隔到期后才会导致连接中断，这可能需要几分钟。通过HA事件通知，OCI会自动中断和清除独立，连接池和会话池连接，并在发生故障事件的几秒钟内调用应用程序回调。如果这些服务器句柄中的任何一个启用了TAF，则OCI也会自动启用故障转移。</p>
                  <p>在当前版本中，此功能取决于Oracle Notification Service（ONS）。它要求在数据库服务器上安装和配置Oracle Clusterware，以便客户端通过ONS接收HA通知。所有集群件安装（例如，Oracle Data Guard）都应具有相同的ONS端口。ONS不需要客户端配置。</p>
                  <div class="infoboxnote" id="GUID-EF4E3248-D4F9-4F06-ADC5-700A36AAE5E7__GUID-3B124258-ED11-4264-B861-1783110DF5A9">
                     <p class="notep1">注意：</p>
                     <p>客户端透明地从其连接的数据库获取ONS服务器信息。应用程序管理员可以使用部署配置文件<code class="codeph">oraaccess.xml</code>来扩充或覆盖该信息。
                     </p>
                  </div>
                  <p>应用程序必须连接到Oracle RAC实例才能启用HA事件通知。此外，这些应用程序必须：</p>
                  <ul style="list-style-type:disc">
                     <li>
                        <p>在<code class="codeph">OCI_EVENTS</code>模式下初始化OCI环境</p>
                     </li>
                     <li>
                        <p>连接到已启用通知的服务（使用<code class="codeph">DBMS_SERVICE.MODIFY_SERVICE</code>过程将<code class="codeph">AQ_HA_NOTIFICATIONS</code>设置为<code class="codeph">TRUE</code> ）</p>
                     </li>
                     <li>
                        <p>链接线程库</p>
                     </li>
                  </ul>
                  <p>然后，这些应用程序可以注册每当HA事件发生时调用的回调。</p>
                  <div class="p">本节包括以下主题：<ul style="list-style-type:disc">
                        <li>
                           <p><a href="high-availability-in-oci.html#GUID-7A565C79-9A70-459D-BD31-F94BA3E31CE0" title="OCIEvent句柄封装了事件有效负载的属性。">OCIEvent手柄</a></p>
                        </li>
                        <li>
                           <p><a href="high-availability-in-oci.html#GUID-F514FB5E-049B-4759-8E39-16853213F7C9" title="Oracle RAC实例中的连接池由连接到Oracle RAC的不同实例的连接池组成。">连接和会话池的OCI故障转移</a></p>
                        </li>
                        <li>
                           <p><a href="high-availability-in-oci.html#GUID-9588A120-E61E-4E87-85E8-1E6D9155B581" title="独立连接不需要特殊处理;连接到失败实例的所有此类连接将立即断开连接。">OCI独立连接故障转移</a></p>
                        </li>
                        <li>
                           <p><a href="high-availability-in-oci.html#GUID-889935A8-154F-460B-9050-1600C4B53EA7" title="显示OCIEventCallback类型的事件回调的签名。">事件回调</a></p>
                        </li>
                        <li>
                           <p><a href="high-availability-in-oci.html#GUID-4EDF9F6A-6210-4731-909A-838EC0E7BB2E" title="使用自定义池，您可以检索服务器句柄的标记信息，以便可以执行适当的清理。">自定义池：标记的服务器句柄</a></p>
                        </li>
                        <li>
                           <p><a href="high-availability-in-oci.html#GUID-D34432B4-2962-48A7-9D9C-789200091B43" title="如果连接启用或未启用TAF，则可以让应用程序调整其行为。">关于确定透明应用程序故障转移（TAF）功能</a></p>
                        </li>
                     </ul>
                  </div>
                  <div class="infoboxnotealso" id="GUID-EF4E3248-D4F9-4F06-ADC5-700A36AAE5E7__GUID-1F9FADDE-F254-4189-BACF-D2D94DC3B0B6">
                     <p class="notep1">也可以看看：</p>
                     <p><a href="build-and-configure-oci-applications.html#GUID-7F47F9F7-EF51-4D68-8B2A-2443C837710B" title="在sqlnet.ora和oraaccess.xml文件中同时设置等效参数时，oraaccess.xml文件设置优先于相应的sqlnet.ora文件设置。">关于客户端部署参数在oraaccess.xml中指定，</a>以获取有关<code class="codeph">oraaccess.xml</code>更多信息以及有关<code class="codeph">&lt;events&gt;</code> ， <code class="codeph">&lt;fan&gt;</code>和<code class="codeph">&lt;ons&gt;</code>下的参数的详细信息</p>
                  </div>
               </div>
               <div class="props_rev_3"><a id="GUID-7A565C79-9A70-459D-BD31-F94BA3E31CE0" name="GUID-7A565C79-9A70-459D-BD31-F94BA3E31CE0"></a><h4 id="LNOCI-GUID-7A565C79-9A70-459D-BD31-F94BA3E31CE0" class="sect4"><span class="enumeration_section">12.2.1</span> OCIEvent句柄</h4>
                  <div>
                     <p><code class="codeph">OCIEvent</code>句柄封装了事件有效负载的属性。
                     </p>
                     <p>OCI在调用事件回调之前隐式分配此句柄，事件回调可以通过调用<code class="codeph">OCIAttrGet()</code>来获取事件的只读属性。与这些属性关联的内存仅在事件回调期间有效。
                     </p>
                     <div class="infoboxnotealso" id="GUID-7A565C79-9A70-459D-BD31-F94BA3E31CE0__GUID-1B9666B6-1DDA-4C42-8026-351B232F60AD">
                        <p class="notep1">也可以看看：</p>
                        <ul style="list-style-type:disc">
                           <li>
                              <p><a href="handle-and-descriptor-attributes.html#GUID-0AE31265-370D-4373-82D6-837A7C8C8463" title="列出并描述事件句柄属性。">事件句柄属性</a></p>
                           </li>
                           <li>
                              <p><a href="handle-and-descriptor-functions.html#GUID-FA199A99-4D7A-42C2-BB0A-C20047B95DF9" title="获取句柄属性的值。">OCIAttrGet（）</a></p>
                           </li>
                        </ul>
                     </div>
                  </div>
               </div>
               <div class="props_rev_3"><a id="GUID-F514FB5E-049B-4759-8E39-16853213F7C9" name="GUID-F514FB5E-049B-4759-8E39-16853213F7C9"></a><h4 id="LNOCI-GUID-F514FB5E-049B-4759-8E39-16853213F7C9" class="sect4"><span class="enumeration_section">12.2.2</span>连接和会话池的OCI故障转移</h4>
                  <div>
                     <p>Oracle RAC实例中的连接池由连接到Oracle RAC的不同实例的连接池组成。</p>
                     <p>收到节点故障通知后，应清除连接到该特定实例的所有连接。对于正在使用的连接，OCI必须关闭连接：立即发生透明应用程序故障转移（TAF），并重新建立这些连接。必须清除空闲且在池的空闲列表中的连接，以便永远不会从池中将错误连接返回给用户。</p>
                     <p>为了适应自定义连接池，OCI提供了一个可以在环境句柄上注册的回调函数。如果已注册，则在发生HA事件时调用此回调。会话池的处理方式与连接池的处理方式相同。请注意，OCI连接池或会话池中的服务器句柄不会传递给回调。因此，在某些情况下，可以使用空的连接列表调用回调。</p>
                  </div>
               </div>
               <div class="props_rev_3"><a id="GUID-9588A120-E61E-4E87-85E8-1E6D9155B581" name="GUID-9588A120-E61E-4E87-85E8-1E6D9155B581"></a><h4 id="LNOCI-GUID-9588A120-E61E-4E87-85E8-1E6D9155B581" class="sect4"><span class="enumeration_section">12.2.3</span>独立连接的OCI故障转移</h4>
                  <div>
                     <p>独立连接不需要特殊处理;连接到失败实例的所有此类连接将立即断开连接。</p>
                     <p>对于空闲连接，当在后续OCI呼叫上使用连接时，TAF参与重新建立连接。在故障事件发生时使用的连接会立即中断，以便TAF可以开始。请注意，这也适用于连接和会话池的“使用中”连接。</p>
                  </div>
               </div>
               <div class="props_rev_3"><a id="GUID-889935A8-154F-460B-9050-1600C4B53EA7" name="GUID-889935A8-154F-460B-9050-1600C4B53EA7"></a><h4 id="LNOCI-GUID-889935A8-154F-460B-9050-1600C4B53EA7" class="sect4"><span class="enumeration_section">12.2.4</span>事件回调</h4>
                  <div>
                     <p>显示<code class="codeph">OCIEventCallback</code>类型的事件回调的<code class="codeph">OCIEventCallback</code> 。
                     </p>
                     <p>类型为<code class="codeph">OCIEventCallback</code>的事件回调具有以下签名：</p><pre class="oac_no_warn" dir="ltr">void evtcallback_fn（void * evtctx，OCIEvent * eventhp）;</pre><p>在此签名中， <code class="codeph">evtctx</code>是客户端上下文， <code class="codeph">OCIEvent</code>是一个对OCI库不透明的事件句柄。另一个输入参数是<code class="codeph">eventhp</code> ，即事件句柄（与事件关联的属性）。
                     </p>
                     <p>如果已注册，则为每个事件调用此函数一次。对于Oracle RAC HA事件，在受影响的连接断开连接后将调用此回调。以下环境句柄属性分别用于注册事件回调和上下文：</p>
                     <ul style="list-style-type:disc">
                        <li>
                           <p><code class="codeph">OCI_ATTR_EVTCBK</code>的数据类型为<code class="codeph">OCIEventCallback</code> <code class="codeph">*</code> 。它是只读的。
                           </p>
                        </li>
                        <li>
                           <p><code class="codeph">OCI_ATTR_EVTCTX</code>的数据类型为<code class="codeph">void</code> <code class="codeph">*</code> 。它也是只读的。
                           </p>
                        </li>
                     </ul><pre class="oac_no_warn" dir="ltr">text * myctx =“虚拟上下文”; / *虚拟上下文传递给回调fn * / .../ * OCI_ATTR_EVTCBK和OCI_ATTR_EVTCTX是只读的。* / OCIAttrSet（envhp，（ub4）OCI_HTYPE_ENV，（void *）evtcallback_fn，（ub4）0，（ub4）OCI_ATTR_EVTCBK，errhp）; OCIAttrSet（envhp，（ub4）OCI_HTYPE_ENV，（void *）myctx，（ub4）0，（ub4）OCI_ATTR_EVTCTX，errhp）; ...
</pre><p>在OCI事件回调中，受影响的服务器句柄列表封装在<code class="codeph">OCIEvent</code>句柄中。对于Oracle RAC HA DOWN事件，客户端应用程序可以通过使用具有属性类型<code class="codeph">OCI_ATTR_HA_SRVFIRST</code>和<code class="codeph">OCI_ATTR_HA_SRVNEXT</code> <code class="codeph">OCIAttrGet()</code>来迭代受事件影响的服务器句柄列表：</p><pre class="oac_no_warn" dir="ltr">OCIAttrGet（eventhp，OCI_HTYPE_EVENT，（void *）＆srvhp，（ub4 *）0，OCI_ATTR_HA_SRVFIRST，errhp）; / *或，* / OCIAttrGet（eventhp，OCI_HTYPE_EVENT，（void *）＆srvhp，（ub4 *）0，OCI_ATTR_HA_SRVNEXT，errhp）;</pre><p>使用属性<code class="codeph">OCI_ATTR_HA_SRVFIRST</code>调用时，此函数将检索受影响的服务器句柄列表中的第一个服务器句柄。使用属性<code class="codeph">OCI_ATTR_HA_SRVNEXT</code>调用时，此函数将检索列表中的下一个服务器句柄。当没有更多服务器句柄返回时，此函数返回<code class="codeph">OCI_NO_DATA</code>并且<code class="codeph">srvhp</code>是<code class="codeph">NULL</code>指针。
                     </p>
                     <p><code class="codeph">srvhp</code>是指向服务器句柄的输出指针，该句柄的连接因HA事件而关闭。 <code class="codeph">errhp</code>是填充的错误句柄。当没有更多受影响的服务器句柄要检索时，应用程序返回<code class="codeph">OCI_NO_DATA</code>错误。
                     </p>
                     <p>检索已受HA事件影响的服务器句柄列表时，请注意该连接已关闭且许多服务器句柄属性不再有效。而是使用服务器句柄的用户内存段来存储事件通知回调所需的任何每个连接属性。在释放服务器句柄之前，此内存仍然有效。</p>
                     <div class="infoboxnotealso" id="GUID-889935A8-154F-460B-9050-1600C4B53EA7__GUID-512ED298-0BDC-46CA-8748-FCE0D864A337">
                        <p class="notep1">也可以看看：</p>
                        <p><a href="handle-and-descriptor-functions.html#GUID-FA199A99-4D7A-42C2-BB0A-C20047B95DF9" title="获取句柄属性的值。">OCIAttrGet（）</a></p>
                     </div>
                  </div>
               </div>
               <div class="props_rev_3"><a id="GUID-4EDF9F6A-6210-4731-909A-838EC0E7BB2E" name="GUID-4EDF9F6A-6210-4731-909A-838EC0E7BB2E"></a><h4 id="LNOCI-GUID-4EDF9F6A-6210-4731-909A-838EC0E7BB2E" class="sect4"><span class="enumeration_section">12.2.5</span>自定义池：标记的服务器句柄</h4>
                  <div>
                     <p>使用自定义池，您可以检索服务器句柄的标记信息，以便可以执行适当的清理。</p>
                     <p>以下功能适用于自定义池：</p>
                     <ul style="list-style-type:disc">
                        <li>
                           <p>如果服务器句柄是代表自定义池创建的，则可以使用其父连接对象标记服务器句柄。使用<code class="codeph">OCIHandleAlloc()</code>的“user memory”参数请求为服务器句柄分配用户内存段。<code class="codeph">OCIHandleAlloc()</code>返回指向“用户存储器”段的指针。
                           </p>
                        </li>
                        <li>
                           <p>当HA事件发生并且检索到受影响的服务器句柄时，有一种方法可以检索服务器句柄的标记信息，以便可以执行适当的清理。属性<code class="codeph">OCI_ATTR_USER_MEMORY</code>用于检索指向句柄的用户内存段的指针。<code class="codeph">OCI_ATTR_USER_MEMORY</code>对所有用户分配的句柄有效。如果句柄分配了额外的内存，则此属性返回指向用户内存的指针。对于未分配额外内存的句柄，将返回<code class="codeph">NULL</code>指针。此属性是只读的，数据类型为<code class="codeph">void*</code> 。
                           </p>
                        </li>
                     </ul>
                     <div class="infoboxnote" id="GUID-4EDF9F6A-6210-4731-909A-838EC0E7BB2E__GUID-CECC5161-D15D-4AE2-91F9-E2FD8EB99A8F">
                        <p class="notep1">注意：</p>
                        <p>您可以自由定义服务器句柄的用户内存段的精确内容，以便在HA事件回调中促进清理活动（或者在需要时用于其他目的），因为OCI不以任何方式写入或读取此内存。通过服务器句柄上的<code class="codeph">OCIHandleFree()</code>调用释放用户内存段。
                        </p>
                     </div>
                     <p><a href="high-availability-in-oci.html#GUID-4EDF9F6A-6210-4731-909A-838EC0E7BB2E__CACCIFIF">例12-1</a>显示了事件通知的一个例子。
                     </p>
                     <div class="example" id="GUID-4EDF9F6A-6210-4731-909A-838EC0E7BB2E__CACCIFIF">
                        <p class="titleinexample">例12-1事件通知</p><pre class="oac_no_warn" dir="ltr">剑报; OCIServer * srvhp; struct myctx {void * parentConn_myctx; uword numval_myctx; }; typedef struct myctx myctx; myctx * myctxp; / *使用用户内存分配服务器句柄 -  10.2之前的功能* / if（retval = OCIHandleAlloc（envhp，（void **）＆srvhp，OCI_HTYPE_SERVER，（size_t）sizeof（myctx），（void **）＆myctxp）/ * handle error * / myctxp-&gt; parentConn_myctx = &lt;parent connection reference&gt;; / *在事件回调函数中，检索指向用户内存的指针* / evtcallback_fn（void * evtctx，OCIEvent * eventhp）{myctx * ctxp =（myctx *） evtctx; OCIServer * srvhp; OCIError * errhp; sb4 retcode; retcode = OCIAttrGet（eventhp，OCI_HTYPE_SERVER，＆srvhp，（ub4 *）0，OCI_ATTR_HA_SRVFIRST，errhp）; while（！retcode）/ * OCIAttrGet将返回OCI_NO_DATA，如果不再有srvhp * / {OCIAttrGet（（void *）srvhp，OCI_HTYPE_SERVER，（void *）＆ctxp，（ub4）0，（ub4）OCI_ATTR_USER_MEMORY，errhp）; / *从父连接对象中删除服务器句柄* / retcode = OCIAttrGet（eventhp，OCI_HTYPE_SERVER，＆srvhp，（ub4 *）0，OCI_ATTR_HA_SRVNEXT，errhp）; ...} ...}</pre><div class="infoboxnotealso" id="GUID-4EDF9F6A-6210-4731-909A-838EC0E7BB2E__GUID-1BF0FA44-60E1-411F-87C2-8DEC2078F8C3">
                           <p class="notep1">也可以看看：</p>
                           <ul style="list-style-type:disc">
                              <li>
                                 <p><a href="handle-and-descriptor-functions.html#GUID-C5BF55F7-A110-4CB5-9663-5056590F12B5" title="返回指向已分配和初始化句柄的指针。">OCIHandleAlloc（）</a></p>
                              </li>
                              <li>
                                 <p><a href="handle-and-descriptor-functions.html#GUID-E87E9F91-D3DC-4F35-BE7C-F1EFBFEEBA0A" title="显式释放句柄">OCIHandleFree（）</a></p>
                              </li>
                           </ul>
                        </div>
                     </div>
                     <!-- class="example" -->
                  </div>
               </div>
               <div class="props_rev_3"><a id="GUID-D34432B4-2962-48A7-9D9C-789200091B43" name="GUID-D34432B4-2962-48A7-9D9C-789200091B43"></a><h4 id="LNOCI-GUID-D34432B4-2962-48A7-9D9C-789200091B43" class="sect4"><span class="enumeration_section">12.2.6</span>关于确定透明应用程序故障转移（TAF）功能</h4>
                  <div>
                     <p>如果连接启用或未启用TAF，则可以让应用程序调整其行为。</p>
                     <p>使用<code class="codeph">OCIAttrGet()</code>如下确定服务器句柄是否启用TAF：</p><pre class="oac_no_warn" dir="ltr">boolean taf_capable; ...OCIAttrGet（srvhp，（ub4）OCI_HTYPE_SERVER，（void *）＆taf_capable，（ub4）sizeof（taf_capable），（ub4）OCI_ATTR_TAF_ENABLED，errhp）; ...
</pre><p>在此示例中， <code class="codeph">taf_capable</code>是一个<span>布尔变量</span> ，如果服务器句柄启用了TAF，则此调用设置为<code class="codeph">TRUE</code>否则设置为<code class="codeph">FALSE</code> ; <code class="codeph">srvhp</code>是输入目标服务器句柄; <code class="codeph">OCI_ATTR_TAF_ENABLED</code>是一个属性，它是一个指向<span>布尔</span>变量的指针，并且是只读的; <code class="codeph">errhp</code>是一个输入错误句柄。
                     </p>
                  </div>
               </div>
            </div>
            <div class="props_rev_3"><a id="GUID-F7817CD2-4A2C-4D37-BD36-56DBABD4725F" name="GUID-F7817CD2-4A2C-4D37-BD36-56DBABD4725F"></a><h3 id="LNOCI-GUID-F7817CD2-4A2C-4D37-BD36-56DBABD4725F" class="sect3"><span class="enumeration_section">12.3</span> OCI中的透明应用程序故障转移</h3>
               <div>
                  <p>透明应用程序故障转移（TAF）是一种客户端功能，旨在最大程度地减少由于实例或网络故障导致数据库连接失败时发生的对最终用户应用程序的中断。</p>
                  <p>TAF可以在各种系统配置上实施，包括Oracle Real Application Clusters（Oracle RAC）和Oracle Data Guard物理备用数据库。重启单个实例系统后也可以使用TAF（例如，在进行修复时）。</p>
                  <p>可以将TAF配置为还原数据库会话，也可以选择重播打开的查询。从Oracle数据库10g第2版（10.2）开始，应用程序尝试在故障尝试故障转移后尝试使用的所有语句。也就是说，尝试执行或获取其他语句就像失败时间语句一样使用TAF恢复。后续语句现在可能成功（而在过去它们失败），或者应用程序可能会收到与尝试的TAF恢复相对应的错误（例如<code class="codeph">ORA-25401</code> ）。
                  </p>
                  <div class="infoboxnote" id="GUID-F7817CD2-4A2C-4D37-BD36-56DBABD4725F__GUID-ECE2F46C-FE35-4806-873B-0E4A5F9DC5E3">
                     <p class="notep1">注意：</p>
                     <p>Oracle建议应用程序注册回调，因此当发生故障转移时，可以使用回调将会话还原到所需的状态。</p>
                  </div>
                  <div class="infoboxnote" id="GUID-F7817CD2-4A2C-4D37-BD36-56DBABD4725F__GUID-F4ECC2C1-0DBC-4EB2-A14F-C44453ECDFE4">
                     <p class="notep1">注意：</p>
                     <p>远程数据库链接或DML语句不支持TAF。</p>
                  </div>
                  <div class="p">本节包含以下主题：<ul style="list-style-type:disc">
                        <li>
                           <p><a href="high-availability-in-oci.html#GUID-B80BF32E-A4E5-4995-A5C6-0C53F823130F" title="可以在客户端和服务器端配置TAF。如果两者都配置，则服务器端设置优先。">关于配置透明应用程序故障转移</a></p>
                        </li>
                        <li>
                           <p><a href="high-availability-in-oci.html#GUID-0CBC5C17-608B-4C5D-9A88-37FBE27D8029" title="由于故障转移期间可能发生延迟，应用程序开发人员可能希望通知用户正在进行故障转移，并请求用户等待故障转移完成的通知。">OCI中的透明应用程序故障转移回调</a></p>
                        </li>
                        <li>
                           <p><a href="high-availability-in-oci.html#GUID-3C9922CC-3346-4C29-81F8-8E3CF7170CF6" title="描述TAF回调结构和参数。">透明应用程序故障转移回调结构和参数</a></p>
                        </li>
                        <li>
                           <p><a href="high-availability-in-oci.html#GUID-C3241340-0A2E-4D02-9981-A7F091051664" title="显示和描述用户定义的应用程序故障转移回调函数的基本结构。">故障转移回调结构和参数</a></p>
                        </li>
                        <li>
                           <p><a href="high-availability-in-oci.html#GUID-6DDC46DE-B960-4DD6-9B2F-DC4AA904A2F3" title="对于要使用的故障转移回调，它必须在服务器上下文句柄上注册。通过创建回调定义结构并将服务器句柄的OCI_ATTR_FOCBK属性设置为此结构来完成此注册。">故障转移回调注册</a></p>
                        </li>
                        <li>
                           <p><a href="high-availability-in-oci.html#GUID-860A2B81-F867-4345-96DE-F423753D1D91" title="显示几个故障转移回调示例。">故障转移回调示例</a></p>
                        </li>
                        <li>
                           <p><a href="high-availability-in-oci.html#GUID-8B99BA40-ABB5-4EA8-8820-FBAAA43CA4F8" title="故障转移尝试并不总是成功。如果尝试失败，则回调函数在fo_event参数中接收值OCI_FO_ABORT或OCI_FO_ERROR。">处理OCI_FO_ERROR</a></p>
                        </li>
                     </ul>
                  </div>
               </div>
               <div class="props_rev_3"><a id="GUID-B80BF32E-A4E5-4995-A5C6-0C53F823130F" name="GUID-B80BF32E-A4E5-4995-A5C6-0C53F823130F"></a><h4 id="LNOCI-GUID-B80BF32E-A4E5-4995-A5C6-0C53F823130F" class="sect4"><span class="enumeration_section">12.3.1</span>关于配置透明应用程序故障转移</h4>
                  <div>
                     <p>可以在客户端和服务器端配置TAF。如果两者都配置，则服务器端设置优先。</p>
                     <p>通过在连接描述符的<code class="codeph">CONNECT_DATA</code>部分中包含<code class="codeph">FAILOVER_MODE</code>参数，在客户端配置TAF。
                     </p>
                     <p>通过使用<code class="codeph">DBMS_SERVICE.MODIFY_SERVICE</code>打包过程修改目标服务，在服务器端配置TAF。
                     </p>
                     <p>故障转移的初始尝试可能并不总是成功。OCI提供了一种在尝试失败后重试故障转移的机制。</p>
                     <div class="infoboxnotealso" id="GUID-B80BF32E-A4E5-4995-A5C6-0C53F823130F__GUID-5399ECA3-3E96-456B-AB8A-58C06FF94417">
                        <p class="notep1">也可以看看：</p>
                        <ul style="list-style-type:disc">
                           <li>
                              <p>有关TAF客户端配置的更多信息，请参阅<a href="../netrf/local-naming-parameters-in-tns-ora-file.html#NETRF279" target="_blank"><span><cite>Oracle数据库网络服务参考</cite></span></a> （连接数据部分）</p>
                           </li>
                           <li>
                              <p>有关TAF（DBMS_SERVICE）服务器端配置的更多信息，请参阅<a href="../arpls/DBMS_SERVICE.html#ARPLS092" target="_blank"><span><cite>Oracle数据库PL / SQL包和类型参考</cite></span></a></p>
                           </li>
                        </ul>
                        <p> </p>
                     </div>
                  </div>
               </div>
               <div class="props_rev_3"><a id="GUID-0CBC5C17-608B-4C5D-9A88-37FBE27D8029" name="GUID-0CBC5C17-608B-4C5D-9A88-37FBE27D8029"></a><h4 id="LNOCI-GUID-0CBC5C17-608B-4C5D-9A88-37FBE27D8029" class="sect4"><span class="enumeration_section">12.3.2</span> OCI中的透明应用程序故障转移回调</h4>
                  <div>
                     <p>由于故障转移期间可能发生延迟，应用程序开发人员可能希望通知用户正在进行故障转移，并请求用户等待故障转移完成的通知。</p>
                     <p>此外，初始实例上的会话可能已收到一些<code class="codeph">ALTER</code> <code class="codeph">SESSION</code>命令。这些<code class="codeph">ALTER</code> <code class="codeph">SESSION</code>命令不会在第二个实例上自动重播。因此，开发人员可能希望在第二个实例上重放它们。还必须重新执行影响会话的<code class="codeph">OCIAttrSet()</code>调用。
                     </p>
                     <p>为了满足这些要求，应用程序开发人员可以注册故障转移回调函数。如果发生故障转移，则在重新建立用户会话时多次调用回调函数。</p>
                     <p>当数据库首次检测到实例连接丢失时，将首次调用回调函数。此回调旨在允许应用程序通知用户即将发生的延迟。如果故障转移成功，则在重新建立和使用连接时会发生对回调函数的第二次调用。</p>
                     <p>重新建立连接后，客户端可能希望重播<code class="codeph">ALTER</code> <code class="codeph">SESSION</code>命令并通知用户已发生故障转移。如果故障转移不成功，则调用回调以通知应用程序无法进行故障转移。此外，每次在新连接上重新验证主句柄之外的用户句柄时，都会调用回调。由于每个用户句柄代表服务器端会话，因此客户端可能希望重播该会话的<code class="codeph">ALTER</code> <code class="codeph">SESSION</code>命令。
                     </p>
                     <div class="infoboxnotealso" id="GUID-0CBC5C17-608B-4C5D-9A88-37FBE27D8029__GUID-3472650E-73ED-4D3C-AAB5-ECA412AFD7F0">
                        <p class="notep1">也可以看看：</p>
                        <ul style="list-style-type:disc">
                           <li>
                              <p><a href="handle-and-descriptor-functions.html#GUID-3741D7BD-7652-4D7A-8813-AC2AEA8D3B03" title="设置句柄或描述符的属性值。">OCIAttrSet（）</a></p>
                           </li>
                           <li>
                              <p><a href="high-availability-in-oci.html#GUID-8B99BA40-ABB5-4EA8-8820-FBAAA43CA4F8" title="故障转移尝试并不总是成功。如果尝试失败，则回调函数在fo_event参数中接收值OCI_FO_ABORT或OCI_FO_ERROR。">处理OCI_FO_ERROR</a>以获取有关此方案的更多信息</p>
                           </li>
                        </ul>
                        <p></p>
                     </div>
                  </div>
               </div>
               <div class="sect3"><a id="GUID-3C9922CC-3346-4C29-81F8-8E3CF7170CF6" name="GUID-3C9922CC-3346-4C29-81F8-8E3CF7170CF6"></a><h4 id="LNOCI-GUID-3C9922CC-3346-4C29-81F8-8E3CF7170CF6" class="sect4"><span class="enumeration_section">12.3.3</span>透明应用程序故障转移回调结构和参数</h4>
                  <div>
                     <p>描述TAF回调结构和参数。</p>
                     <p>透明应用程序故障转移（TAF）回调函数的基本结构如下：</p><pre class="oac_no_warn" dir="ltr">sb4 TAFcbk_fn（OCISvcCtx * svchp，OCIEnv * envhp，void * fo_ctx，ub4 fo_type，ub4 fo_event）;</pre><dl>
                        <dt class="dlterm"><a name="GUID-3C9922CC-3346-4C29-81F8-8E3CF7170CF6__GUID-D2B2B2EF-2CB2-422C-A086-3A0869BC79E2"><!-- --></a> svchp</dt>
                        <dd>
                           <p>服务上下文句柄。</p>
                        </dd>
                        <dt class="dlterm"><a name="GUID-3C9922CC-3346-4C29-81F8-8E3CF7170CF6__GUID-95AD87F7-0C9D-4B30-B3B8-E677F2AFA49B"><!-- --></a> envhp</dt>
                        <dd>
                           <p>OCI环境处理。</p>
                        </dd>
                        <dt class="dlterm"><a name="GUID-3C9922CC-3346-4C29-81F8-8E3CF7170CF6__GUID-C3669A54-4D7A-4E4C-ADD3-CC8DEF859713"><!-- --></a> fo_ctx</dt>
                        <dd>
                           <p>客户端上下文。这是指向客户端指定的内存的指针。在此区域中，客户可以保留任何必要的状态或上下文。</p>
                        </dd>
                        <dt class="dlterm"><a name="GUID-3C9922CC-3346-4C29-81F8-8E3CF7170CF6__GUID-CEC7681E-9839-416B-9CC3-BCAA294790B4"><!-- --></a> fo_type</dt>
                        <dd>
                           <div class="p">故障转移类型。这使回调知道客户端请求的故障转移类型。通常的值如下：<ul style="list-style-type:disc">
                                 <li>
                                    <p><code class="codeph">OCI_FO_SESSION</code>表示用户仅请求了会话故障转移。
                                    </p>
                                 </li>
                                 <li>
                                    <p><code class="codeph">OCI_FO_SELECT</code>表示用户也请求了选择故障转移。
                                    </p>
                                 </li>
                              </ul>
                           </div>
                        </dd>
                        <dt class="dlterm"><a name="GUID-3C9922CC-3346-4C29-81F8-8E3CF7170CF6__GUID-CEAF5918-C959-4396-949E-7BB327B85000"><!-- --></a> fo_event</dt>
                        <dd>
                           <div class="p">故障转移事件指示故障转移的当前状态。
                              <ul style="list-style-type:disc">
                                 <li>
                                    <p><code class="codeph">OCI_FO_BEGIN</code>表示故障转移已检测到连接丢失并且故障转移正在启动。
                                    </p>
                                 </li>
                                 <li>
                                    <p><code class="codeph">OCI_FO_END</code>表示成功完成故障转移。
                                    </p>
                                 </li>
                                 <li>
                                    <p><code class="codeph">OCI_FO_ABORT</code>表示故障转移不成功，并且没有重试选项。
                                    </p>
                                 </li>
                                 <li>
                                    <p><code class="codeph">OCI_FO_ERROR</code>还指示故障转移不成功，但它使应用程序有机会处理错误<code class="codeph">OCI_FO_ERROR</code>试故障转移。
                                    </p>
                                 </li>
                                 <li>
                                    <p><code class="codeph">OCI_FO_REAUTH</code>表示您有多个身份验证句柄，并且在原始身份验证后发生了故障转移。它表示用户句柄已重新进行身份验证。为了确定哪一个，应用程序检查服务上下文句柄<code class="codeph">svchp</code>的<code class="codeph">OCI_ATTR_SESSION</code>属性。
                                    </p>
                                 </li>
                              </ul>
                           </div>
                        </dd>
                     </dl>
                     <p>如果配置了应用程序连续性，则在成功重新连接，重新验证和确定机上事务的状态后，将使用<code class="codeph">OCI_FO_END</code>调用TAF回调。
                     </p>
                     <p>完成TAF回调后，如果存在打开的事务并且启用了OCI的应用程序连续性，OCI将返回错误。</p>
                  </div>
               </div>
               <div class="props_rev_3"><a id="GUID-C3241340-0A2E-4D02-9981-A7F091051664" name="GUID-C3241340-0A2E-4D02-9981-A7F091051664"></a><h4 id="LNOCI-GUID-C3241340-0A2E-4D02-9981-A7F091051664" class="sect4"><span class="enumeration_section">12.3.4</span>故障转移回调结构和参数</h4>
                  <div>
                     <p>显示和描述用户定义的应用程序故障转移回调函数的基本结构。</p>
                     <p>用户定义的应用程序故障转移回调函数的基本结构如下：</p><pre class="oac_no_warn" dir="ltr">sb4 appfocallback_fn（void * svchp，void * envhp，void * fo_ctx，ub4 fo_type，ub4 fo_event）;</pre><p>第9-31页的“故障转移回调示例”中提供了以下参数的示例：</p>
                     <dl>
                        <dt class="dlterm"><a name="GUID-C3241340-0A2E-4D02-9981-A7F091051664__GUID-BEA274C9-256A-4618-AF1E-8B752BA5FA54"><!-- --></a> svchp</dt>
                        <dd>
                           <p>第一个参数<code class="codeph">svchp</code>是服务上下文句柄。它的类型为<code class="codeph">void *</code> 。
                           </p>
                        </dd>
                        <dt class="dlterm"><a name="GUID-C3241340-0A2E-4D02-9981-A7F091051664__GUID-E0324FA7-6FDD-4AB3-A132-C3C6BB676F0E"><!-- --></a> envhp</dt>
                        <dd>
                           <p>第二个参数<code class="codeph">envhp</code>是OCI环境句柄。它的类型为<code class="codeph">void *</code> 。
                           </p>
                        </dd>
                        <dt class="dlterm"><a name="GUID-C3241340-0A2E-4D02-9981-A7F091051664__GUID-7BEAF6CC-5C8B-4669-B86E-AC9C71BAB580"><!-- --></a> fo_ctx</dt>
                        <dd>
                           <p>第三个参数<code class="codeph">fo_ctx</code>是客户端上下文。它是指向客户端指定的内存的指针。在此区域中，客户可以保留任何必要的状态或上下文。它作为<code class="codeph">void *</code>传递。
                           </p>
                        </dd>
                        <dt class="dlterm"><a name="GUID-C3241340-0A2E-4D02-9981-A7F091051664__GUID-F02332EE-B218-4728-BE16-CE8F7120B294"><!-- --></a> fo_type</dt>
                        <dd>
                           <p>第四个参数<code class="codeph">fo_type</code>是故障转移类型。这使回调知道客户端请求的故障转移类型。通常的值如下：</p>
                        </dd>
                     </dl>
                     <ul style="list-style-type:disc">
                        <li>
                           <p><code class="codeph">OCI_FO_SESSION</code>表示用户仅请求了会话故障转移。
                           </p>
                        </li>
                        <li>
                           <p><code class="codeph">OCI_FO_SELECT</code>表示用户也请求了选择故障转移。
                           </p>
                        </li>
                     </ul>
                     <dl>
                        <dt class="dlterm"><a name="GUID-C3241340-0A2E-4D02-9981-A7F091051664__GUID-B41E338F-B047-400E-B249-F54CD38EBD55"><!-- --></a> fo_event</dt>
                        <dd>
                           <p>最后一个参数是故障转移事件。这表明回调为什么要调用它。它有几个可能的值：</p>
                        </dd>
                     </dl>
                     <ul style="list-style-type:disc">
                        <li>
                           <p><code class="codeph">OCI_FO_BEGIN</code>表示故障转移已检测到连接丢失并且故障转移正在启动。
                           </p>
                        </li>
                        <li>
                           <p><code class="codeph">OCI_FO_END</code>表示成功完成故障转移。
                           </p>
                        </li>
                        <li>
                           <p><code class="codeph">OCI_FO_ABORT</code>表示故障转移不成功，并且没有重试选项。
                           </p>
                        </li>
                        <li>
                           <p><code class="codeph">OCI_FO_ERROR</code>还指示故障转移不成功，但它使应用程序有机会处理错误<code class="codeph">OCI_FO_ERROR</code>试故障转移。
                           </p>
                        </li>
                        <li>
                           <p><code class="codeph">OCI_FO_REAUTH</code>表示您有多个身份验证句柄，并且在原始身份验证后发生了故障转移。它表示用户句柄已重新进行身份验证。为了确定哪一个，应用程序检查服务上下文句柄的<code class="codeph">OCI_ATTR_SESSION</code>属性（这是第一个参数）。
                           </p>
                        </li>
                     </ul>
                  </div>
               </div>
               <div class="props_rev_3"><a id="GUID-6DDC46DE-B960-4DD6-9B2F-DC4AA904A2F3" name="GUID-6DDC46DE-B960-4DD6-9B2F-DC4AA904A2F3"></a><h4 id="LNOCI-GUID-6DDC46DE-B960-4DD6-9B2F-DC4AA904A2F3" class="sect4"><span class="enumeration_section">12.3.5</span>故障转移回叫注册</h4>
                  <div>
                     <p>对于要使用的故障转移回调，它必须在服务器上下文句柄上注册。通过创建回调定义结构并将服务器句柄的<code class="codeph">OCI_ATTR_FOCBK</code>属性设置<code class="codeph">OCI_ATTR_FOCBK</code>结构来完成此注册。
                     </p>
                     <p>回调定义结构必须是<code class="codeph">OCIFocbkStruct</code>类型。它有两个字段： <code class="codeph">callback_function</code> ，它包含要调用的函数的地址， <code class="codeph">fo_ctx</code> ，包含客户端上下文的地址。
                     </p>
                     <div class="infoboxnotealso" id="GUID-6DDC46DE-B960-4DD6-9B2F-DC4AA904A2F3__GUID-BBC89C26-CBD9-4036-B6B0-B436EC2662EC">
                        <p class="notep1">也可以看看：</p>
                        <p><a href="high-availability-in-oci.html#GUID-860A2B81-F867-4345-96DE-F423753D1D91__CACDAEEJ">例12-3</a>给出了回调注册的例子</p>
                     </div>
                  </div>
               </div>
               <div class="props_rev_3"><a id="GUID-860A2B81-F867-4345-96DE-F423753D1D91" name="GUID-860A2B81-F867-4345-96DE-F423753D1D91"></a><h4 id="LNOCI-GUID-860A2B81-F867-4345-96DE-F423753D1D91" class="sect4"><span class="enumeration_section">12.3.6</span>故障转移回调示例</h4>
                  <div>
                     <p>显示几个故障转移回调示例。</p>
                     <div class="section">
                        <p>本节显示了一个简单的用户定义的回调函数定义（参见<a href="high-availability-in-oci.html#GUID-860A2B81-F867-4345-96DE-F423753D1D91__CACJJHGH">例12-2</a> ），故障转移回调注册（参见<a href="high-availability-in-oci.html#GUID-860A2B81-F867-4345-96DE-F423753D1D91__CACDAEEJ">例12-3</a> ）和故障转移回调取消注册的<a href="high-availability-in-oci.html#GUID-860A2B81-F867-4345-96DE-F423753D1D91__CACDJGDG">示例</a> （参见<a href="high-availability-in-oci.html#GUID-860A2B81-F867-4345-96DE-F423753D1D91__CACDJGDG">例12-4</a> ）。
                        </p>
                     </div>
                     <!-- class="section" -->
                     <div class="example" id="GUID-860A2B81-F867-4345-96DE-F423753D1D91__CACJJHGH">
                        <p class="titleinexample">例12-2用户定义的故障转移回调函数定义</p><pre class="oac_no_warn" dir="ltr">sb4 callback_fn（svchp，envhp，fo_ctx，fo_type，fo_event）void * svchp; void * envhp; void * fo_ctx; ub4 fo_type; ub4 fo_event; {switch（fo_event）{case OCI_FO_BEGIN：{printf（“Failing Over ...请等待\ n“）; printf（”故障转移类型被发现是％s \ n“，（（fo_type == OCI_FO_SESSION）？“SESSION”:( fo_type == OCI_FO_SELECT）？“选择”：“未知！“））; printf（”故障转移上下文是：％s \ n“，（fo_ctx？（char *）fo_ctx：“NULL指针！“））; break;} case OCI_FO_ABORT：{printf（”Failover stopped。故障转移不会发生。\ n“）; break;} case OCI_FO_END：{printf（”Failover ended ... resuming services \ n“）; break;} case OCI_FO_REAUTH：{printf（”用户失败。恢复服务\ n“）; break;}默认值：{printf（”错误故障转移事件：％d。\ n“，fo_event）; break;}}返回0;}</pre></div>
                     <!-- class="example" -->
                     <div class="example" id="GUID-860A2B81-F867-4345-96DE-F423753D1D91__CACDAEEJ">
                        <p class="titleinexample">示例12-3故障转移回调注册</p><pre class="oac_no_warn" dir="ltr">int register_callback（srvh，errh）void * srvh; / *服务器句柄* / OCIError * errh; / *错误句柄* / {OCIFocbkStruct故障转移; / * failover回调结构* / /为上下文分配内存* / if（！（failover.fo_ctx =（void *）malloc（strlen（“my context。”）+ 1）））return（1）; / *初始化上下文。* / strcpy（（char *）failover.fo_ctx，“我的上下文。”）; failover.callback_function =＆callback_fn; / *做注册* / if（OCIAttrSet（srvh，（ub4）OCI_HTYPE_SERVER，（void *）＆failover，（ub4）0，（ub4）OCI_ATTR_FOCBK，errh）！= OCI_SUCCESS）return（2）; / *成功结论* / return（0）; }</pre></div>
                     <!-- class="example" -->
                     <div class="example" id="GUID-860A2B81-F867-4345-96DE-F423753D1D91__CACDJGDG">
                        <p class="titleinexample">示例12-4故障转移回调取消注册</p><pre class="oac_no_warn" dir="ltr">OCIFocbkStruct故障转移; / *故障转移回调结构* /剑状态; / *将故障转移上下文设置为null * / failover.fo_ctx = NULL; / *将故障转移回调设置为null * / failover.callback_function = NULL; / *取消注册回调* / status = OCIAttrSet（srvhp，（ub4）OCI_HTYPE_SERVER，（void *）＆failover，（ub4）0，（ub4）OCI_ATTR_FOCBK，errhp）;</pre></div>
                     <!-- class="example" -->
                  </div>
               </div>
               <div class="props_rev_3"><a id="GUID-8B99BA40-ABB5-4EA8-8820-FBAAA43CA4F8" name="GUID-8B99BA40-ABB5-4EA8-8820-FBAAA43CA4F8"></a><h4 id="LNOCI-GUID-8B99BA40-ABB5-4EA8-8820-FBAAA43CA4F8" class="sect4"><span class="enumeration_section">12.3.7</span>处理OCI_FO_ERROR</h4>
                  <div>
                     <p>故障转移尝试并不总是成功。如果尝试失败，则回调函数在<code class="codeph">fo_event</code>参数中接收值<code class="codeph">OCI_FO_ABORT</code>或<code class="codeph">OCI_FO_ERROR</code> 。
                     </p>
                     <div class="section">
                        <p>值<code class="codeph">OCI_FO_ABORT</code>表示故障转移不成功，并且无法进行进一步的故障转移尝试。但是， <code class="codeph">OCI_FO_ERROR</code>为回调函数提供了处理错误的机会。例如，回调可以选择等待指定的时间段，然后向OCI库指示它必须重新尝试故障转移。
                        </p>
                        <div class="infoboxnote" id="GUID-8B99BA40-ABB5-4EA8-8820-FBAAA43CA4F8__GUID-57E6B159-985F-486D-860A-BDBC85CA75F6">
                           <p class="notep1">注意：</p>
                           <p>此功能仅适用于与针对任何Oracle数据库服务器运行的8.0.5或更高版本OCI库链接的应用程序。</p>
                           <p>如果LOB列是选择列表的一部分，则故障转移不起作用。</p>
                        </div>
                        <p>考虑<a href="high-availability-in-oci.html#GUID-8B99BA40-ABB5-4EA8-8820-FBAAA43CA4F8__CACEHAGA" title="该表由2列描述。第1列是指定为时间线T0到T7的时间，第2列是每个时间轴时间发生的事件。">表12-1中列出</a>的事件的时间表。
                        </p>
                        <div class="tblformal" id="GUID-8B99BA40-ABB5-4EA8-8820-FBAAA43CA4F8__CACEHAGA">
                           <p class="titleintable">表12-1时间和事件</p>
                           <table cellpadding="4" cellspacing="0" class="Formal" title="时间和事件" width="100%" border="1" summary="This table is described by 2 columns. Column 1 is the time designated as a timeline T0 through T7 and column 2 is the event that occurs for each timeline time." frame="hsides" rules="rows">
                              <thead>
                                 <tr align="left" valign="top">
                                    <th align="left" valign="bottom" width="15%" id="d119972e4097">时间</th>
                                    <th align="left" valign="bottom" width="85%" id="d119972e4100">事件</th>
                                 </tr>
                              </thead>
                              <tbody>
                                 <tr align="left" valign="top">
                                    <td align="left" valign="top" width="15%" id="d119972e4105" headers="d119972e4097 ">
                                       <p>T0</p>
                                    </td>
                                    <td align="left" valign="top" width="85%" headers="d119972e4105 d119972e4100 ">
                                       <p>数据库失败（失败持续到T5）。</p>
                                    </td>
                                 </tr>
                                 <tr align="left" valign="top">
                                    <td align="left" valign="top" width="15%" id="d119972e4112" headers="d119972e4097 ">
                                       <p>T1</p>
                                    </td>
                                    <td align="left" valign="top" width="85%" headers="d119972e4112 d119972e4100 ">
                                       <p>故障转移由用户活动触发。</p>
                                    </td>
                                 </tr>
                                 <tr align="left" valign="top">
                                    <td align="left" valign="top" width="15%" id="d119972e4119" headers="d119972e4097 ">
                                       <p>T2</p>
                                    </td>
                                    <td align="left" valign="top" width="85%" headers="d119972e4119 d119972e4100 ">
                                       <p>用户尝试重新连接;尝试失败。</p>
                                    </td>
                                 </tr>
                                 <tr align="left" valign="top">
                                    <td align="left" valign="top" width="15%" id="d119972e4126" headers="d119972e4097 ">
                                       <p>T3</p>
                                    </td>
                                    <td align="left" valign="top" width="85%" headers="d119972e4126 d119972e4100 ">
                                       <p>使用<code class="codeph">OCI_FO_ERROR</code>调用故障转移回调。</p>
                                    </td>
                                 </tr>
                                 <tr align="left" valign="top">
                                    <td align="left" valign="top" width="15%" id="d119972e4136" headers="d119972e4097 ">
                                       <p>T4</p>
                                    </td>
                                    <td align="left" valign="top" width="85%" headers="d119972e4136 d119972e4100 ">
                                       <p>故障转移回调进入预定的睡眠时段。</p>
                                    </td>
                                 </tr>
                                 <tr align="left" valign="top">
                                    <td align="left" valign="top" width="15%" id="d119972e4143" headers="d119972e4097 ">
                                       <p>T5</p>
                                    </td>
                                    <td align="left" valign="top" width="85%" headers="d119972e4143 d119972e4100 ">
                                       <p>数据库再次恢复。</p>
                                    </td>
                                 </tr>
                                 <tr align="left" valign="top">
                                    <td align="left" valign="top" width="15%" id="d119972e4150" headers="d119972e4097 ">
                                       <p>T6</p>
                                    </td>
                                    <td align="left" valign="top" width="85%" headers="d119972e4150 d119972e4100 ">
                                       <p>故障转移回调会触发新的故障转移尝试;它很成功。</p>
                                    </td>
                                 </tr>
                                 <tr align="left" valign="top">
                                    <td align="left" valign="top" width="15%" id="d119972e4157" headers="d119972e4097 ">
                                       <p>T7</p>
                                    </td>
                                    <td align="left" valign="top" width="85%" headers="d119972e4157 d119972e4100 ">
                                       <p>用户成功重新连接。</p>
                                    </td>
                                 </tr>
                              </tbody>
                           </table>
                        </div>
                        <!-- class="inftblhruleinformal" -->
                        <p>回调函数通过从函数返回值<code class="codeph">OCI_FO_RETRY</code>来触发新的故障转移尝试。
                        </p>
                        <p><a href="high-availability-in-oci.html#GUID-8B99BA40-ABB5-4EA8-8820-FBAAA43CA4F8__CACFEBEJ">例12-5</a>显示了一个回调函数，您可以使用它来实现类似于前面描述的场景的故障转移策略。在这种情况下，故障转移回调进入一个休眠循环，然后重新尝试故障转移，直到它成功：</p>
                     </div>
                     <!-- class="section" -->
                     <div class="example" id="GUID-8B99BA40-ABB5-4EA8-8820-FBAAA43CA4F8__CACFEBEJ">
                        <p class="titleinexample">示例12-5实现故障转移策略的回调函数</p><pre class="oac_no_warn" dir="ltr">/ * ------------------------------------------------ -------------------- * / / *用户定义的故障转移回调* / / * ---------------- -------------------------------------------------- -  * / sb4 callback_fn（svchp，envhp，fo_ctx，fo_type，fo_event）void * svchp; void * envhp; void * fo_ctx; ub4 fo_type; ub4 fo_event; {OCIError * errhp; OCIHandleAlloc（envhp，（void **）＆errhp，（ub4）OCI_HTYPE_ERROR，（size_t）0，（void **）0）; switch（fo_event）{case OCI_FO_BEGIN：{printf（“Failing Over ...请等待\ n“）; printf（”故障转移类型被发现为％s \ n“，（（fo_type == OCI_FO_NONE）？“无”：（fo_type == OCI_FO_SESSION）？“SESSION”:( fo_type == OCI_FO_SELECT）？“SELECT”:( fo_type == OCI_FO_TXNAL）？“交易”：“未知！“））; printf（”故障转移上下文是：％s \ n“，（fo_ctx？（char *）fo_ctx：“NULL指针！“））; break;} case OCI_FO_ABORT：{printf（”Failover aborted。故障转移不会发生。\ n“）; break;} case OCI_FO_END：{printf（”\ n Failover ends ... resuming services \ n“）; break;} case OCI_FO_REAUTH：{printf（”用户失败。恢复服务\ n“）; break;} case OCI_FO_ERROR：{/ *这样的所有调用只能生成一行。换行符*将在fo_end时间放置。* / printf（“故障转移错误已获取。正在睡觉......“）; sleep（3）; printf（”Retrying。“）; return（OCI_FO_RETRY）; break;} default：{printf（”Bad Failover Event：％d。\ n“，fo_event）; break; } return 0;}</pre></div>
                     <!-- class="example" -->
                  </div>
               </div>
            </div>
            <div class="props_rev_3"><a id="GUID-A675AF7B-6FF0-460D-A6E6-C15E7C328C8F" name="GUID-A675AF7B-6FF0-460D-A6E6-C15E7C328C8F"></a><h3 id="LNOCI-GUID-A675AF7B-6FF0-460D-A6E6-C15E7C328C8F" class="sect3"><span class="enumeration_section">12.4</span> OCI和交易卫士</h3>
               <div>
                  <p>Transaction Guard在计划内或计划外中断的情况下引入了最多一次事务执行的概念，以帮助防止故障转移时的应用程序提交原始提交的重复提交。</p>
                  <p></p>
                  <p>当应用程序使用此服务打开与数据库的连接时，逻辑事务ID（LTXID）将在身份验证时生成并存储在会话句柄中。这是一个全局唯一的ID，它从应用程序的角度标识数据库事务。当发生中断时，使用Transaction Guard的应用程序可以从先前失败的会话句柄中检索LTXID，并使用它来确定在会话失败之前处于活动状态的事务的结果。如果确定LTXID未使用，则应用程序可以通过首先使用检索到的LTXID阻止原始提交来重放未提交的事务。如果确定使用LTXID，则提交事务并将结果返回给应用程序。</p>
                  <p>Transaction Guard是支持JDBC Type 4（Oracle Thin），OCI，OCCI和Oracle Data Provider for .NET（ODP.NET）驱动程序的开发人员API。对于OCI，当编写应用程序以支持Transaction Guard时，在中断时，OCI客户端驱动程序通过使用<code class="codeph">OCI_ATTR_LTXID</code>会话句柄属性调用<code class="codeph">OCI_ATTR_GET()</code>来从先前失败的会话句柄获取并检索LTXID。
                  </p>
                  <p>本节包括以下主题： <a href="high-availability-in-oci.html#GUID-6A12DE3A-479A-4D06-8305-AA450BFF6B23" title="本节介绍开发使用Transaction Guard的OCI用户应用程序。">开发使用Transaction Guard的应用程序</a> 。
                  </p>
                  <div class="infoboxnotealso" id="GUID-A675AF7B-6FF0-460D-A6E6-C15E7C328C8F__GUID-E3CF22A9-BA3E-4F88-87D2-C7DF883994E7">
                     <p class="notep1">也可以看看：</p>
                     <p><a href="../adfns/transaction-guard.html#ADFNS8000" target="_blank"><span><cite>“Oracle数据库开发指南”，</cite></span></a>以获取有关使用Transaction Guard的章节中的信息，以获取Transaction Guard的概述，支持的事务类型，不受支持的事务类型以及使用Transaction Guard的数据库配置信息。
                     </p>
                  </div>
               </div>
               <div class="props_rev_3"><a id="GUID-6A12DE3A-479A-4D06-8305-AA450BFF6B23" name="GUID-6A12DE3A-479A-4D06-8305-AA450BFF6B23"></a><h4 id="LNOCI-GUID-6A12DE3A-479A-4D06-8305-AA450BFF6B23" class="sect4"><span class="enumeration_section">12.4.1</span>开发使用Transaction Guard的应用程序</h4>
                  <div>
                     <p>本节介绍开发使用Transaction Guard的OCI用户应用程序。</p>
                     <div class="section">
                        <p>有关使用Transaction Guard开发应用程序的更多详细信息，请参阅“ <a href="../adfns/transaction-guard.html#ADFNS8000" target="_blank"><span><cite>Oracle数据库开发指南”中</cite></span></a>有关使用Transaction Guard的章节。
                        </p>
                        <p>对于使用Transaction Guard以便能够为OCI的会话进行故障转移的第三方或用户应用程序，它必须包括几个主要步骤：</p>
                     </div>
                     <!-- class="section" -->
                     <ol>
                        <li class="stepexpand"><span>验证是否为连接启用了透明应用程序故障转移（TAF）。不要尝试在启用TAF的连接上显式使用Transaction Guard，因为TAF将自动检查<code class="codeph">LTXID</code> 。</span></li>
                        <li class="stepexpand"><span>在收到错误，判断错误是否是可恢复的错误- <code class="codeph">OCI_ATTR_ERROR_IS_RECOVERABLE</code>上<code class="codeph">OCI_ERROR</code>手柄。如果错误可恢复，则继续执行步骤<a href="high-availability-in-oci.html#GUID-6A12DE3A-479A-4D06-8305-AA450BFF6B23__CACFHAAG">3</a> 。</span><div>
                              <div class="infoboxnote" id="GUID-6A12DE3A-479A-4D06-8305-AA450BFF6B23__GUID-DFBE8124-9838-4780-9E59-E7F81EB3CE57">
                                 <p class="notep1">注意：</p>
                                 <p>如果连接没有遇到可恢复的错误，请勿尝试使用LTXID检查事务结果。</p>
                              </div>
                           </div>
                        </li>
                        <li class="stepexpand" id="GUID-6A12DE3A-479A-4D06-8305-AA450BFF6B23__CACFHAAG"><span>通过使用OCI_ATTR_GET（）从用户会话句柄获取OCI_ATTR_LTXID，检索与失败会话关联的LTXID。</span></li>
                        <li class="stepexpand"><span>重新连接到数据库。</span><div>
                              <div class="infoboxnote" id="GUID-6A12DE3A-479A-4D06-8305-AA450BFF6B23__GUID-82ABA5C6-B605-44B2-AD42-9FC952306A5B">
                                 <p class="notep1">注意：</p>
                                 <p>新会话将具有新的LTXID，但在检查原始会话的状态时您将不需要它。</p>
                              </div>
                           </div>
                        </li>
                        <li class="stepexpand"><span>使用从<code class="codeph">OCI_ATTR_GET()</code>调用获得的<code class="codeph">OCI_ATTR_GET()</code>调用<code class="codeph">DBMS_APP_CONT.GET_LTXID_OUTCOME</code> PL / SQL过程。如果尚未使用LTXID，则故障转移会话的原始LTXID将标记为强制。返回状态告诉驱动程序最后一个事务是<code class="codeph">COMMITTED (TRUE/FALSE)</code>还是<code class="codeph">USER_CALL_COMPLETED (TRUE/FALSE)</code> 。</span></li>
                        <li class="stepexpand"><span>应用程序可以重播未提交的事务或将结果返回给用户。如果重放本身导致中断，则重放会话的LTXID用于<code class="codeph">DBMS_APP_CONT.GET_LTXID_OUTCOME</code>过程。</span></li>
                     </ol>
                     <div class="section">
                        <div class="p">有关Transaction Guard用法和示例，请参阅以下部分：<ul style="list-style-type:disc">
                              <li>
                                 <p><a href="high-availability-in-oci.html#GUID-10A6CFB0-E480-48FE-B3A2-BB5AE6F88DF0" title="显示使用伪代码的Transaction Guard的典型用法。">典型的交易保护用法</a></p>
                              </li>
                              <li>
                                 <p><a href="high-availability-in-oci.html#GUID-671647AA-875B-45B6-BAA8-311B3E007EB9" title="显示Transaction Guard演示程序。">交易警卫示例</a></p>
                              </li>
                           </ul>
                        </div>
                     </div>
                     <!-- class="section" -->
                  </div>
                  <div class="props_rev_3"><a id="GUID-10A6CFB0-E480-48FE-B3A2-BB5AE6F88DF0" name="GUID-10A6CFB0-E480-48FE-B3A2-BB5AE6F88DF0"></a><h5 id="LNOCI-GUID-10A6CFB0-E480-48FE-B3A2-BB5AE6F88DF0" class="sect5"><span class="enumeration_section">12.4.1.1</span>典型的事务处理防护用法</h5>
                     <div>
                        <p>显示使用伪代码的Transaction Guard的典型用法。</p>
                        <p>以下伪代码显示了Transaction Guard的典型用法：</p>
                        <ol>
                           <li>
                              <p>收到FAN down事件（或可恢复的错误）</p>
                           </li>
                           <li>
                              <p>FAN中止死亡会议</p>
                           </li>
                           <li>
                              <p>使用服务器句柄上的<code class="codeph">OCI_ATTR_TAF_ENABLED</code>属性调用<code class="codeph">OCIAttrGet()</code> 。如果值为<code class="codeph">TRUE</code> ，则停止。如果值为<code class="codeph">FALSE</code> ，请继续执行下一步。
                              </p>
                           </li>
                           <li>
                              <p>如果是可恢复的错误，对OCI（ <code class="codeph">OCI_ATTR_ERROR_IS_RECOVERABLE</code>上<code class="codeph">OCI_ERROR</code>手柄）：</p>
                              <ol type="a">
                                 <li>
                                    <p>通过使用<code class="codeph">OCI_ATTR_LTXID</code>会话句柄属性调用<code class="codeph">OCIAttrGet()</code>来检索与会话句柄关联的LTXID，从死会话中获取最后一个LTXID</p>
                                 </li>
                                 <li>
                                    <p>获得一个新的会话</p>
                                 </li>
                                 <li>
                                    <p>使用最后一个LTXID调用<code class="codeph">DBMS_APP_CONT.GET_LTXID_OUTCOME</code>以获取返回状态</p>
                                 </li>
                              </ol>
                           </li>
                           <li>
                              <p>如果返回状态是：</p>
                              <ol type="a">
                                 <li>
                                    <p><code class="codeph">COMMITTED</code>和<code class="codeph">USER_CALL_COMPLETED</code> 
                                    </p>
                                    <p>然后返回结果。</p>
                                 </li>
                                 <li>
                                    <p><code class="codeph">ELSEIF COMMITTED</code>而<code class="codeph">NOT USER_CALL_COMPLETED</code> 
                                    </p>
                                    <p>然后返回带有警告的结果（带有详细信息，例如输出绑定或行计数未返回）。</p>
                                 </li>
                                 <li>
                                    <p><code class="codeph">ELSEIF未承诺</code> 
                                    </p>
                                    <p>重新提交事务或一系列调用或两者，或将错误返回给用户。</p>
                                 </li>
                              </ol>
                           </li>
                        </ol>
                        <div class="infoboxnotealso" id="GUID-10A6CFB0-E480-48FE-B3A2-BB5AE6F88DF0__GUID-0C2AAC04-96F7-42F7-9374-B15025B62630">
                           <p class="notep1">也可以看看：</p>
                           <p><a href="handle-and-descriptor-functions.html#GUID-FA199A99-4D7A-42C2-BB0A-C20047B95DF9" title="获取句柄属性的值。">OCIAttrGet（）</a></p>
                        </div>
                     </div>
                  </div>
                  <div class="props_rev_3"><a id="GUID-671647AA-875B-45B6-BAA8-311B3E007EB9" name="GUID-671647AA-875B-45B6-BAA8-311B3E007EB9"></a><h5 id="LNOCI-GUID-671647AA-875B-45B6-BAA8-311B3E007EB9" class="sect5"><span class="enumeration_section">12.4.1.2</span>交易保护示例</h5>
                     <div>
                        <p>显示Transaction Guard演示程序。</p>
                        <div class="section">
                           <p><a href="high-availability-in-oci.html#GUID-671647AA-875B-45B6-BAA8-311B3E007EB9__CACJFEEC">例12-6</a>是一个OCI Transaction Guard演示程序（ <code class="codeph">cdemotg.c</code> ），它演示了：</p>
                        </div>
                        <!-- class="section" -->
                        <div class="section">
                           <ul style="list-style-type:disc">
                              <li>
                                 <p>使用属性<code class="codeph">OCI_ATTR_ERROR_IS_RECOVERABLE</code> 。发生错误时，程序会检查错误是否可恢复。
                                 </p>
                              </li>
                              <li>
                                 <p>使用打包的过程<code class="codeph">DBMS_APP_CONT.GET_LTXID_OUTCOME</code> 。如果错误是可恢复的，程序将调用<code class="codeph">DBMS_APP_CONT.GET_LTXID_OUTCOME</code>以确定活动事务的状态。
                                 </p>
                              </li>
                           </ul>
                           <p>如果事务尚未提交，则程序重新执行失败的事务。</p>
                           <div class="infoboxnote" id="GUID-671647AA-875B-45B6-BAA8-311B3E007EB9__GUID-42DD9B5E-8641-4B24-A9DD-1CA396998A6B">
                              <p class="notep1">注意：</p>
                              <p>此程序不会修改会话状态，如NLS参数等。执行此操作的程序可能需要在错误后从池中获取新会话后重新执行此类命令。</p>
                           </div>
                        </div>
                        <!-- class="section" -->
                        <div class="example" id="GUID-671647AA-875B-45B6-BAA8-311B3E007EB9__CACJFEEC">
                           <p class="titleinexample">例12-6交易保护演示程序</p><pre class="oac_no_warn" dir="ltr">* / #ifndef OCISP_ORACLE #include &lt;cdemosp.h&gt; #endif / *最大线程数* / #define MAXTHREAD 1 static ub4 sessMin = 1; static ub4 sessMax = 9; static ub4 sessIncr = 2; static OCIError * errhp; static OCIEnv * envhp; static OCISPool * poolhp =（OCISPool *）0; static int employeeNum [MAXTHREAD]; static OraText * poolName; static ub4 poolNameLen; static CONST OraText * database =（text *）“ltxid_service”; static CONST OraText * appusername =（text *）“scott”; static CONST OraText * apppassword =（text *）“tiger”; static CONST char getLtxid [] =（“BEGIN <span class="bold">DBMS_APP_CONT.GET_LTXID_OUTCOME</span> （”“：ltxid，：committed，：callComplete）; END;”）; static CONST char insertst1 [] =（“INSERT INTO EMP（ENAME，EMPNO）值”（'NAME1'，1000）“）; static void checkerr（OCIError * errhp，剑状态）; static void threadFunction（dvoid * arg）; int main（void）{int i = 0;剑lstat; int timeout = 1; OCIEnvCreate（＆envhp，OCI_THREADED，（dvoid *）0，NULL，NULL，NULL，0，（dvoid *）0）; （void）OCIHandleAlloc（（dvoid *）envhp，（dvoid **）＆errhp，OCI_HTYPE_ERROR，（size_t）0，（dvoid **）0）; （void）OCIHandleAlloc（（dvoid *）envhp，（dvoid **）＆poolhp，OCI_HTYPE_SPOOL，（size_t）0，（dvoid **）0）; / *创建会话池* / checkerr（errhp，OCIAttrSet（（dvoid *）poolhp，（ub4）OCI_HTYPE_SPOOL，（dvoid *）＆timeout，（ub4）0，OCI_ATTR_SPOOL_TIMEOUT，errhp））; if（lstat = OCISessionPoolCreate（envhp，errhp，poolhp，（OraText **）＆poolName，（ub4 *）＆poolNameLen，database，（ub4）strlen（（const char *）database），sessMin，sessMax，sessIncr，（OraText *） appusername，（ub4）strlen（（const char *）appusername），（OraText *）apppassword，（ub4）strlen（（const char *）apppassword），OCI_SPC_STMTCACHE | OCI_SPC_HOMOGENEOUS））{checkerr（errhp，lstat）; } printf（“Session Pool Created \ n”）; / *使用会话池的多个线程* / {OCIThreadId * thrid [MAXTHREAD]; OCIThreadHandle * thrhp [MAXTHREAD]; OCIThreadProcessInit（）; checkerr（errhp，OCIThreadInit（envhp，errhp））; for（i = 0; i &lt;MAXTHREAD; ++ i）{checkerr（errhp，OCIThreadIdInit（envhp，errhp，＆thrid [i]））; checkerr（errhp，OCIThreadHndInit（envhp，errhp，＆thrhp [i]））; } for（i = 0; i &lt;MAXTHREAD; ++ i）{employeeNum [i] = i; / *插入EMP表* / checkerr（errhp，OCIThreadCreate（envhp，errhp，threadFunction，（dvoid *）＆employeeNum [i]，thrid [i]，thrhp [i]））; } for（i = 0; i &lt;MAXTHREAD; ++ i）{checkerr（errhp，OCIThreadJoin（envhp，errhp，thrhp [i]））; checkerr（errhp，OCIThreadClose（envhp，errhp，thrhp [i]））; checkerr（errhp，OCIThreadIdDestroy（envhp，errhp，＆（thrid [i]）））; checkerr（errhp，OCIThreadHndDestroy（envhp，errhp，＆（thrhp [i]）））; } checkerr（errhp，OCIThreadTerm（envhp，errhp））; } / *所有的线程都是完整的* / lstat = OCISessionPoolDestroy（poolhp，errhp，OCI_DEFAULT）; printf（“Session Pool Destroyed \ n”）;如果（lstat！= OCI_SUCCESS）checkerr（errhp，lstat）; checkerr（errhp，OCIHandleFree（（dvoid *）poolhp，OCI_HTYPE_SPOOL））; checkerr（errhp，OCIHandleFree（（dvoid *）errhp，OCI_HTYPE_ERROR））;返回0; } / * end of main（）* / / *将记录插入EMP表* / static void threadFunction（dvoid * arg）{int empno = *（int *）arg; OCISvcCtx * svchp =（OCISvcCtx *）0; OCISvcCtx * svchp2 =（OCISvcCtx *）0; OCISession * embUsrhp =（OCISession *）0; OCIBind * bnd1p，* bnd2p，* bnd3p; OCIStmt * stmthp =（OCIStmt *）0; OCIStmt * getLtxidStm =（OCIStmt *）0; OCIError * errhp2 =（OCIError *）0; OCIAuthInfo * authp =（OCIAuthInfo *）0;剑lstat;文字名称[10]; boolean callCompl，committed，isRecoverable; ub1 * myLtxid; ub4 myLtxidLen; ub4 numAttempts = 0; （void）OCIHandleAlloc（（dvoid *）envhp，（dvoid **）＆errhp2，OCI_HTYPE_ERROR，（size_t）0，（dvoid **）0）; lstat = OCIHandleAlloc（（dvoid *）envhp，（dvoid **）＆authp，（ub4）OCI_HTYPE_AUTHINFO，（size_t）0，（dvoid **）0）; if（lstat）checkerr（errhp2，lstat）; checkerr（errhp2，OCIAttrSet（（dvoid *）authp，（ub4）OCI_HTYPE_AUTHINFO，（dvoid *）appusername，（ub4）strlen（（char *）appusername），（ub4）OCI_ATTR_USERNAME，errhp2））; checkerr（errhp2，OCIAttrSet（（dvoid *）authp，（ub4）OCI_HTYPE_AUTHINFO，（dvoid *）apppassword，（ub4）strlen（（char *）apppassword），（ub4）OCI_ATTR_PASSWORD，errhp2））; restart：if（lstat = OCISessionGet（envhp，errhp2，＆svchp，authp，（OraText *）poolName，（ub4）strlen（（char *）poolName），NULL，0，NULL，NULL，NULL，OCI_SESSGET_SPOOL））{checkerr（ errhp2，LSTAT）;如果我们需要调用* get_ltxid_outcome来确定事务状态，则保存来自会话的ltxid。* / checkerr（errhp2，OCIAttrGet（svchp，OCI_HTYPE_SVCCTX，（dvoid *）＆embUsrhp，（ub4 *）0，（ub4）OCI_ATTR_SESSION，errhp2））; checkerr（errhp2，OCIAttrGet（embUsrhp，OCI_HTYPE_SESSION，（dvoid *）＆myLtxid，（ub4 *）＆myLtxidLen，（ub4）OCI_ATTR_LTXID，errhp2））; / * * / checkerr（errhp2，OCIStmtPrepare2（svchp，＆stmthp，errhp2，（CONST OraText *）insertst1，（ub4）sizeof（insertst1），（const oratext *）0，（ub4）0，OCI_NTV_SYNTAX，OCI_DEFAULT））;如果（！numAttempts）{char input [1]; printf（“现在杀死SCOTT的会话。完成后按ENTER键\ n“）;得到（输入）;} lstat = OCIStmtExecute（svchp，stmthp，errhp2，（ub4）1，（ub4）0，（OCISnapshot *）0，（OCISnapshot *）0，OCI_DEFAULT）; if（lstat == OCI_ERROR）{checkerr（errhp2，OCIAttrGet（errhp2，OCI_HTYPE_ERROR，（dvoid *）＆isRecoverable，（ub4 *）0，（ub4） <span class="bold">OCI_ATTR_ERROR_IS_RECOVERABLE</span> ，errhp2））; if（isRecoverable）{printf（“发生可恢复的错误）检查事务状态。\ n“）; / *获取另一个用于get_ltxid_outcome调用的会话* / if（lstat = OCISessionGet（envhp，errhp2，＆svchp2，authp，（OraText *）poolName，（ub4）strlen（（char） *）poolName），NULL，0，NULL，NULL，NULL，OCI_SESSGET_SPOOL））{checkerr（errhp2，lstat）;} checkerr（errhp2，OCIStmtPrepare2（svchp2，＆getLtxidStm，errhp2，（CONST OraText *）getLtxid，（ub4）sizeof （getLtxid），（const oratext *）0，（ub4）0，OCI_NTV_SYNTAX，OCI_DEFAULT））; checkerr（errhp，OCIBindByPos（getLtxidStm，＆bnd1p，errhp，1，（dvoid *）myLtxid，（sword）myLtxidLen，SQLT_BIN，（ dvoid *）0，（ub2 *）0，（ub2 *）0，（ub4）0，（ub4 *）0，OCI_DEF AULT））; checkerr（errhp，OCIBindByPos（getLtxidStm，＆bnd2p，errhp，2，（dvoid *）＆committed，（sword）sizeof（已提交），SQLT_BOL，（dvoid *）0，（ub2 *）0，（ub2 *）0，（ub4 ）0，（ub4 *）0，OCI_DEFAULT））; checkerr（errhp，OCIBindByPos（getLtxidStm，＆bnd3p，errhp，3，（dvoid *）＆callCompl，（sword）sizeof（callCompl），SQLT_BOL，（dvoid *）0，（ub2 *）0，（ub2 *）0，（ub4 ）0，（ub4 *）0，OCI_DEFAULT））; checkerr（errhp2，OCIStmtExecute（svchp2，getLtxidStm，errhp2，（ub4）1，（ub4）0，（OCISnapshot *）0，（OCISnapshot *）0，OCI_DEFAULT））; checkerr（errhp2，OCISessionRelease（svchp2，errhp2，NULL，0，OCI_DEFAULT））; if（committed &amp;&amp; callCompl）printf（“Insert successfully commited \ n”）;否则如果（！已提交）{printf（“事务未提交;重新执行上一次事务\ n”）; numAttempts ++; / *由于存在中断，请不要将此会话返回到池* / checkerr（errhp2，OCISessionRelease（svchp，errhp2，NULL，0，OCI_SESSRLS_DROPSESS））; svchp =（OCISvcCtx *）0;转到重启; } else {checkerr（errhp2，OCITransCommit（svchp，errhp2，（ub4）0））; printf（“事务已成功提交\ n”）; } if（stmthp）checkerr（errhp2，OCIStmtRelease（（dvoid *）stmthp，errhp2，（void *）0,0，OCI_DEFAULT））; if（getLtxidStm）checkerr（errhp2，OCIStmtRelease（（dvoid *）getLtxidStm，errhp2，（void *）0,0，OCI_DEFAULT））; if（svchp）checkerr（errhp2，OCISessionRelease（svchp，errhp2，NULL，0，OCI_DEFAULT））; OCIHandleFree（（dvoid *）authp，OCI_HTYPE_AUTHINFO）; OCIHandleFree（（dvoid *）errhp2，OCI_HTYPE_ERROR）; } / * threadFunction的结尾（dvoid *）* / / *此函数打印错误* / void checkerr（errhp，status）OCIError * errhp;剑的地位; {text errbuf [512]; sb4 errcode = 0; switch（status）{case OCI_SUCCESS：break; case OCI_SUCCESS_WITH_INFO：（void）printf（“Error  -  OCI_SUCCESS_WITH_INFO \ n”）;打破; case OCI_NEED_DATA：（void）printf（“Error  -  OCI_NEED_DATA \ n”）;打破; case OCI_NO_DATA：（void）printf（“Error  -  OCI_NODATA \ n”）;打破; case OCI_ERROR：（void）OCIErrorGet（（dvoid *）errhp，（ub4）1，（text *）NULL，＆errcode，errbuf，（ub4）sizeof（errbuf），OCI_HTYPE_ERROR）; （void）printf（“Error  - ％。* s \ n”，512，errbuf）;打破; case OCI_INVALID_HANDLE：（void）printf（“Error  -  OCI_INVALID_HANDLE \ n”）;打破; case OCI_STILL_EXECUTING：（void）printf（“Error  -  OCI_STILL_EXECUTE \ n”）;打破; case OCI_CONTINUE：（void）printf（“Error  -  OCI_CONTINUE \ n”）;打破;默认值：break; }}</pre></div>
                        <!-- class="example" -->
                     </div>
                  </div>
               </div>
            </div>
            <div class="props_rev_3"><a id="GUID-A8DD9422-2F82-42A9-9555-134296416E8F" name="GUID-A8DD9422-2F82-42A9-9555-134296416E8F"></a><h3 id="LNOCI-GUID-A8DD9422-2F82-42A9-9555-134296416E8F" class="sect3"><span class="enumeration_section">12.5</span> OCI和应用程序连续性</h3>
               <div>
                  <p>应用程序连续性（AC）在计划内和计划外中断期间提供高可用性（HA）。Oracle数据库12 <span class="italic">c</span>第2版（12.2）引入了对AC的OCI支持。
                  </p>
                  <p>AC在运行Oracle RAC，Oracle RAC One或Active Data Guard实例或站点故障转移的HA环境中屏蔽硬件，软件，网络，存储错误和超时。AC为SQL * Plus，Tuxedo，WebLogic Server和JDBC Type 4（Oracle Thin），OCI和Oracle Data Provider for .NET（ODP.NET）驱动程序提供支持。</p>
                  <p>对于使用OCI会话池的应用程序的计划中断，OCI会话池检测连接何时受到<code class="codeph">PLANNED DOWN</code>事件的影响，并在连接返回池时终止连接。对于不使用OCI会话池的应用程序的计划中断，OCI应用程序会检测连接是否受到计划关闭事件的影响。在任何一种情况下，OCI都隐式确定DML重放何时是安全的，并且应用程序在关闭事件后看到的错误更少。
                  </p>
                  <p>由于计划外中断，OCI使用Transaction Guard，它使OCI应用程序能够通过在发生可恢复错误后恢复正在进行的事务来可靠地确定事务的结果。这种支持意味着在中断期间完成应用程序请求只会在恢复数据库连接和会话状态时产生轻微延迟。如果AC可以确定在原始执行期间未提交事务，则AC仅尝试重放正在进行的事务。</p>
                  <p>对于OCI的AC支持，Oracle建议您使用OCI会话池或Tuxedo。</p>
                  <div class="p">本节包括以下主题：<ul style="list-style-type:disc">
                        <li>
                           <p><a href="high-availability-in-oci.html#GUID-BC59C816-621E-496D-8CC6-23176518BE75" title="Oracle Database 18c版本18.1增加了对Application Continuity的更多支持。">关于添加的应用程序连续性支持</a></p>
                        </li>
                        <li>
                           <p><a href="high-availability-in-oci.html#GUID-E3D181AA-0346-4DF6-B154-DA43EE56EC1E" title="在发生可恢复的错误之后，数据库会话从一个数据库实例故障转移到另一个数据库实例。">发生可恢复错误后会发生什么</a></p>
                        </li>
                        <li>
                           <p><a href="high-availability-in-oci.html#GUID-B291B826-C3EE-4A34-92CD-4F4CECC5D730" title="成功的驱动程序重放要求故障转移后事务的客户端可见效果与初始提交相同。">成功重播的标准</a></p>
                        </li>
                        <li>
                           <p><a href="high-availability-in-oci.html#GUID-6936353C-3193-4052-AD34-D062FFF56B71" title="列出在下一个应用程序请求开始之前隐式禁用OCI中的应用程序连续性的因素。">什么因素阻碍了OCI中的应用程序连续性</a></p>
                        </li>
                        <li>
                           <p><a href="high-availability-in-oci.html#GUID-D40FACA1-FBE1-4540-B3C1-8E772404E655" title="什么原因导致重播失败。">重播失败</a></p>
                        </li>
                        <li>
                           <p><a href="high-availability-in-oci.html#GUID-6DACCD89-3CDE-42F5-882F-CB146E73A581" title="是什么决定了应用程序连续性在OCI中的有效性。">什么时候应用程序连续性最有效</a></p>
                        </li>
                     </ul>
                  </div>
                  <div class="infoboxnotealso" id="GUID-A8DD9422-2F82-42A9-9555-134296416E8F__GUID-EB448EFF-AE3D-494C-B870-2DA307C92E20">
                     <p class="notep1">也可以看看：</p>
                     <ul style="list-style-type:disc">
                        <li>
                           <p><a href="../racad/workload-management-with-dynamic-database-services.html#RACAD-GUID-87EDF90F-1776-474A-AD9C-93F9CBE6CB31" target="_blank"><span><cite>“Oracle Real Application Clusters管理和部署指南”</cite></span></a> ，了解有关为Application Continuity和Transaction Guard创建服务的信息。
                           </p>
                        </li>
                     </ul>
                  </div>
               </div>
               <div class="sect3"><a id="GUID-BC59C816-621E-496D-8CC6-23176518BE75" name="GUID-BC59C816-621E-496D-8CC6-23176518BE75"></a><h4 id="LNOCI-GUID-BC59C816-621E-496D-8CC6-23176518BE75" class="sect4"><span class="enumeration_section">12.5.1</span>关于增加对应用程序连续性的支持</h4>
                  <div>
                     <p>Oracle Database 18c版本18.1增加了对Application Continuity的更多支持。</p>
                     <div class="p">从Oracle Database 18c版本18.1开始，为Application Continuity添加了以下支持：<ul style="list-style-type:disc">
                           <li>
                              <p>为OCI动态绑定添加了支持，并为数字，字符和日期/时间类型定义。这意味着扩展了以下OCI API以支持应用程序连续性： <code class="codeph">OCIBindDynamic()</code>和<code class="codeph">OCIDefineDynamic()</code> 。
                              </p>
                           </li>
                           <li>
                              <p>添加了对绑定和定义对象的支持。这意味着扩展了以下OCI API以支持应用程序连续性： <code class="codeph">OCIBindObject()</code> ， <code class="codeph">OCIDefineObject()</code>和<code class="codeph">OCITypeByName()</code> 。
                              </p>
                           </li>
                           <li>
                              <p>在执行LOB调用期间，Application Continuity现在通过重新启动由中断中断的LOB调用来支持处理连接失败。</p>
                           </li>
                           <li>
                              <p>OCI现在支持<code class="codeph">AUTO</code>的新应用程序连续性<code class="codeph">FAILOVER_TYPE</code> ，如果已知会话状态在显式请求边界处可恢复，则它仅尝试进行故障转移。
                              </p>
                           </li>
                        </ul> 
                     </div>
                  </div>
               </div>
               <div class="props_rev_3"><a id="GUID-E3D181AA-0346-4DF6-B154-DA43EE56EC1E" name="GUID-E3D181AA-0346-4DF6-B154-DA43EE56EC1E"></a><h4 id="LNOCI-GUID-E3D181AA-0346-4DF6-B154-DA43EE56EC1E" class="sect4"><span class="enumeration_section">12.5.2</span>发生可恢复错误后会发生什么</h4>
                  <div>
                     <p>在发生可恢复的错误之后，数据库会话从一个数据库实例故障转移到另一个数据库实例。</p>
                     <p>新实例可能是同一Oracle RAC集群的一部分，也可能是在站点发生故障后作为主数据库启动的Oracle Data Guard备用数据库。在透明应用程序故障转移（TAF）成功重新连接并重新进行身份验证后，OCI中的应用程序连续性将重放与失败会话关联的呼叫历史记录，包括所有SQL和PL / SQL语句。重播在单个会话上运行，不会尝试将重新提交活动与任何其他数据库会话同步。仅当事务重放的客户端可见结果与原始提交相同时，重播才会成功。</p>
                  </div>
               </div>
               <div class="props_rev_3"><a id="GUID-B291B826-C3EE-4A34-92CD-4F4CECC5D730" name="GUID-B291B826-C3EE-4A34-92CD-4F4CECC5D730"></a><h4 id="LNOCI-GUID-B291B826-C3EE-4A34-92CD-4F4CECC5D730" class="sect4"><span class="enumeration_section">12.5.3</span>成功重播的标准</h4>
                  <div>
                     <p>成功的驱动程序重放要求故障转移后事务的客户端可见效果与初始提交相同。</p>
                     <p>以下标准表明了这一成功：</p>
                     <ul style="list-style-type:disc">
                        <li>
                           <p>返回代码和错误消息文本必须相同。</p>
                        </li>
                        <li>
                           <p>结果集必须相同。define数据必须相同，并且必须以相同的顺序返回行。</p>
                        </li>
                        <li>
                           <p>处理的行数必须相同。例如，故障转移后更新语句必须更新与原始更新语句相同的行数。</p>
                        </li>
                        <li>
                           <p>新连接的会话状态与原始连接的会话状态匹配。</p>
                        </li>
                     </ul>
                     <p>有关这些条件的信息，请参阅“ <a href="../racad/ensuring-application-continuity.html#RACAD-GUID-BD699AEB-9F85-42A8-8687-5A979918938D" target="_blank"><span><cite>Oracle Real Application Clusters管理和部署指南”</cite></span></a> 。
                     </p>
                     <div class="section">
                        <p class="subhead3" id="GUID-B291B826-C3EE-4A34-92CD-4F4CECC5D730__GUID-067C96FD-AB0D-45CB-A6F4-416CB1D5A52A">可变数据的稳定性和应用连续性</p>
                        <p>当可变对象的值从一次执行变为下一次执行时，其数据被认为是可变的，因此保证不可重放。序列是这种可变数据的一个例子。</p>
                        <p>为了提高DML重放的成功率，有必要使用初始提交时使用的值重放涉及可变数据的DML。如果未保留原始值，并且如果将这些可变对象的不同值返回给客户端，则会拒绝重放，因为客户端会看到不同的结果。</p>
                        <p>目前为<code class="codeph">SYSDATE</code> ， <code class="codeph">SYSTIMESTAMP</code> ， <code class="codeph">SYS_GUID</code>和<code class="codeph"><span class="codeinlineitalic">sequence .</span>提供了对保持可变对象值的支持<code class="codeph"><span class="codeinlineitalic">sequence</span> .NEXTVAL</code> 。</p>
                        <div class="infoboxnotealso" id="GUID-B291B826-C3EE-4A34-92CD-4F4CECC5D730__GUID-B3DAD364-9822-4E00-965C-23F36E142B47">
                           <p class="notep1">也可以看看：</p>
                           <p>有关可变对象和应用程序连续性的更多信息，请参见<a href="../racad/ensuring-application-continuity.html#RACAD-GUID-E4A114A2-EA77-4037-A62A-BDFCF1E6D072" target="_blank"><span><cite>“Oracle Real Application Clusters管理和部署指南”</cite></span></a> 。
                           </p>
                        </div>
                     </div>
                     <!-- class="section" -->
                  </div>
               </div>
               <div class="props_rev_3"><a id="GUID-6936353C-3193-4052-AD34-D062FFF56B71" name="GUID-6936353C-3193-4052-AD34-D062FFF56B71"></a><h4 id="LNOCI-GUID-6936353C-3193-4052-AD34-D062FFF56B71" class="sect4"><span class="enumeration_section">12.5.4</span>什么因素阻碍了OCI中的应用程序连续性</h4>
                  <div>
                     <p>列出在下一个应用程序请求开始之前隐式禁用OCI中的应用程序连续性的因素。</p>
                     <p>以下情况隐式禁用OCI中的应用程序连续性，直到下一个应用程序请求开始：</p>
                     <ul style="list-style-type:disc">
                        <li>
                           <p>服务器检测到与重播不一致的条件。例如，对于<code class="codeph">SESSION_STATE_CONSISTENCY=DYNAMIC</code>如果PL / SQL匿名块具有嵌入的顶级<code class="codeph">COMMIT</code>语句（自治事务不被视为顶级），则驱动程序隐式禁用OCI中的应用程序连续性。</p>
                        </li>
                        <li>
                           <p>应用程序调用OCI中的Application Continuity不支持的OCI功能。</p>
                        </li>
                     </ul>
                     <p>应用程序可以通过调用<code class="codeph">OCIRequestDisableReplay()</code>在OCI中显式禁用应用程序连续性。
                     </p>
                  </div>
               </div>
               <div class="props_rev_3"><a id="GUID-D40FACA1-FBE1-4540-B3C1-8E772404E655" name="GUID-D40FACA1-FBE1-4540-B3C1-8E772404E655"></a><h4 id="LNOCI-GUID-D40FACA1-FBE1-4540-B3C1-8E772404E655" class="sect4"><span class="enumeration_section">12.5.5</span>重播失败</h4>
                  <div>
                     <p>什么原因导致重播失败。</p>
                     <p>当OCI中的应用程序连续性重放事务时，以下情况将导致重播失败：</p>
                     <ul style="list-style-type:disc">
                        <li>
                           <p>在重放时遇到<code class="codeph">COMMIT</code>语句</p>
                        </li>
                        <li>
                           <p>重播结果与初始提交的交易不一致</p>
                        </li>
                        <li>
                           <p>如果超出内部重播重试限制，则在重播期间存在可恢复的错误</p>
                        </li>
                        <li>
                           <p>使用<code class="codeph">OCIStmtPrepare()</code>应用程序返回以下错误： <code class="codeph">Error - ORA-25412: transaction replay disabled by call to OCIStmtPrepare</code> 。使用<code class="codeph">OCIStmtPrepare2()</code>调用来支持在HA基础结构中使用Application Continuity。
                           </p>
                        </li>
                     </ul>
                     <p>如果Application Continuity无法成功重播失败的事务，则会返回错误。其他诊断信息将记录在客户端跟踪文件中，以指示重放失败的原因。</p>
                  </div>
               </div>
               <div class="props_rev_3"><a id="GUID-6DACCD89-3CDE-42F5-882F-CB146E73A581" name="GUID-6DACCD89-3CDE-42F5-882F-CB146E73A581"></a><h4 id="LNOCI-GUID-6DACCD89-3CDE-42F5-882F-CB146E73A581" class="sect4"><span class="enumeration_section">12.5.6</span>应用程序连续性何时最有效</h4>
                  <div>
                     <p>是什么决定了应用程序连续性在OCI中的有效性。</p>
                     <p>在以下条件下，OCI中的应用连续性最有效：</p>
                     <ul style="list-style-type:disc">
                        <li>
                           <p>数据库服务指定<code class="codeph">COMMIT_OUTCOME</code>属性，并配置透明应用程序故障转移（TAF）。
                           </p>
                        </li>
                        <li>
                           <p>应用程序能够显式地（通过调用<code class="codeph">OCIRequestBegin()</code>和<code class="codeph">OCIRequestEnd()</code> ）或通过使用OCI会话池隐式标记应用程序请求的开始和结束。
                           </p>
                        </li>
                        <li>
                           <p>应用程序请求最多包含一个在请求结束时提交的数据库事务。</p>
                        </li>
                        <li>
                           <div class="p">如果应用程序在服务器，PL / SQL或Java中执行PL / SQL或Java：<ul style="list-style-type:disc">
                                 <li>
                                    <p>没有嵌入的<code class="codeph">COMMIT</code>语句</p>
                                 </li>
                                 <li>
                                    <p>不设置在PL / SQL或Java完成后预期会保留的任何状态（例如，包变量）。</p>
                                 </li>
                              </ul>
                           </div>
                        </li>
                        <li>
                           <p>TAF回调不会保留打开的数据库事务。</p>
                        </li>
                     </ul>
                     <div class="p">本节包括以下主题：<ul style="list-style-type:disc">
                           <li>
                              <p><a href="high-availability-in-oci.html#GUID-D30079AC-4E59-4CC3-86E8-6487A4891BA2" title="描述如果发生中断，OCI中的应用程序连续性可以进行故障转移时的哪些功能。">当OCI中的应用程序连续性可以故障转移时</a></p>
                           </li>
                           <li>
                              <p><a href="high-availability-in-oci.html#GUID-8B38BDC1-A606-4893-A18F-CF1712DE29B2" title="OCI中的Application Continuity不支持哪些结构。">OCI中的应用程序连续性不支持这些构造</a></p>
                           </li>
                           <li>
                              <p><a href="high-availability-in-oci.html#GUID-B54C508E-60E7-4053-BD7F-95272F8EDE35" title="一旦重建会话并恢复数据库状态，OCI中的应用程序连续性将在可恢复错误后重放原始PL / SQL和SQL语句。重播留下了两次看到的副作用，这可能是也可能不是。">应用程序连续性可能产生的副作用</a></p>
                           </li>
                        </ul>
                     </div>
                  </div>
                  <div class="sect4"><a id="GUID-D30079AC-4E59-4CC3-86E8-6487A4891BA2" name="GUID-D30079AC-4E59-4CC3-86E8-6487A4891BA2"></a><h5 id="LNOCI-GUID-D30079AC-4E59-4CC3-86E8-6487A4891BA2" class="sect5"><span class="enumeration_section">12.5.6.1</span> OCI中的应用程序连续性可以故障<span class="enumeration_section">转移</span></h5>
                     <div>
                        <p>描述如果发生中断，OCI中的应用程序连续性可以进行故障转移时的哪些功能。</p>
                        <div class="p">如果在以下某个功能期间发生中断，则OCI中的应用程序连续性可以进行故障转移：<ul style="list-style-type:disc">
                              <li>
                                 <p><code class="codeph">OCILobAppend（）</code></p>
                              </li>
                              <li>
                                 <p><code class="codeph">OCILobArrayRead（）</code></p>
                              </li>
                              <li>
                                 <p><code class="codeph">OCILobArrayWrite（）</code></p>
                              </li>
                              <li>
                                 <p><code class="codeph">OCILobAssign（）</code></p>
                              </li>
                              <li>
                                 <p><code class="codeph">OCILobCharSetForm（）</code></p>
                              </li>
                              <li>
                                 <p><code class="codeph">OCILobClose（）</code></p>
                              </li>
                              <li>
                                 <p><code class="codeph">OCILobCopy2（）</code></p>
                              </li>
                              <li>
                                 <p><code class="codeph">OCILobCreateTemporary（）</code></p>
                              </li>
                              <li>
                                 <p><code class="codeph">OCILobDisableBuffering（）</code></p>
                              </li>
                              <li>
                                 <p><code class="codeph">OCILobEnableBuffering（）</code></p>
                              </li>
                              <li>
                                 <p><code class="codeph">OCILobFileClose（）</code></p>
                              </li>
                              <li>
                                 <p><code class="codeph">OCILobFileCloseAll（）</code></p>
                              </li>
                              <li>
                                 <p><code class="codeph">OCILobFileGetName（）</code></p>
                              </li>
                              <li>
                                 <p><code class="codeph">OCILobFileIsOpen（）</code></p>
                              </li>
                              <li>
                                 <p><code class="codeph">OCILobFileOpen（）</code></p>
                              </li>
                              <li>
                                 <p><code class="codeph">OCILobFileSetName（）</code></p>
                              </li>
                              <li>
                                 <p><code class="codeph">OCILobFlushBuffer（）</code></p>
                              </li>
                              <li>
                                 <p><code class="codeph">OCILobFreeTemporary（）</code></p>
                              </li>
                              <li>
                                 <p><code class="codeph">OCILobGetChunkSize（）</code></p>
                              </li>
                              <li>
                                 <p><code class="codeph">OCILobGetLength（）</code></p>
                              </li>
                              <li>
                                 <p><code class="codeph">OCILobGetLength2（）</code></p>
                              </li>
                              <li>
                                 <p><code class="codeph">OCILobGetStorageLimit（）</code></p>
                              </li>
                              <li>
                                 <p><code class="codeph">OCILobIsEqual（）</code></p>
                              </li>
                              <li>
                                 <p><code class="codeph">OCILobIsOpen（）</code></p>
                              </li>
                              <li>
                                 <p><code class="codeph">OCILobIsTemporary（）</code></p>
                              </li>
                              <li>
                                 <p><code class="codeph">OCILobLoadFromFile（）</code></p>
                              </li>
                              <li>
                                 <p><code class="codeph">OCILobLoadFromFile2（）</code></p>
                              </li>
                              <li>
                                 <p><code class="codeph">OCILobLocatorAssign（）</code></p>
                              </li>
                              <li>
                                 <p><code class="codeph">OCILobLocatorIsInit（）</code></p>
                              </li>
                              <li>
                                 <p><code class="codeph">OCILobOpen（）</code></p>
                              </li>
                              <li>
                                 <p><code class="codeph">OCILobRead（）</code></p>
                              </li>
                              <li>
                                 <p><code class="codeph">OCILobRead2（）</code></p>
                              </li>
                              <li>
                                 <p><code class="codeph">OCILobTrim（）</code></p>
                              </li>
                              <li>
                                 <p><code class="codeph">OCILobTrim2（）</code></p>
                              </li>
                              <li>
                                 <p><code class="codeph">OCILobWriteAppend（）</code></p>
                              </li>
                              <li>
                                 <p><code class="codeph">OCILobWriteAppend2（）</code></p>
                              </li>
                              <li>
                                 <p><code class="codeph">OCILobWrite（）</code></p>
                              </li>
                              <li>
                                 <p><code class="codeph">OCILobWrite2（）</code></p>
                              </li>
                              <li>
                                 <p><code class="codeph">OCIPing（）</code></p>
                              </li>
                              <li>
                                 <p><code class="codeph">OCIStmtExecute（）</code></p>
                              </li>
                              <li>
                                 <p><code class="codeph">OCIStmtFetch（）</code> 
                                 </p>
                              </li>
                              <li>
                                 <p><code class="codeph">OCIStmtFetch2（）</code></p>
                              </li>
                              <li>
                                 <p><code class="codeph">OCISessionEnd（）</code></p>
                              </li>
                              <li>
                                 <p><code class="codeph">OCITransCommit（）</code></p>
                              </li>
                              <li>
                                 <p><code class="codeph">OCITransRollback（）</code></p>
                              </li>
                           </ul>
                        </div>
                     </div>
                  </div>
                  <div class="props_rev_3"><a id="GUID-8B38BDC1-A606-4893-A18F-CF1712DE29B2" name="GUID-8B38BDC1-A606-4893-A18F-CF1712DE29B2"></a><h5 id="LNOCI-GUID-8B38BDC1-A606-4893-A18F-CF1712DE29B2" class="sect5"><span class="enumeration_section">12.5.6.2</span> OCI中的应用程序连续性不支持这些构造</h5>
                     <div>
                        <p>OCI中的Application Continuity不支持哪些结构。</p>
                        <p>OCI中的应用程序连续性不支持以下构造：</p>
                        <ul style="list-style-type:disc">
                           <li>
                              <p>XA交易</p>
                           </li>
                           <li>
                              <p>带有嵌入式<code class="codeph">COMMIT</code>语句的PL / SQL块</p>
                           </li>
                           <li>
                              <p>出列立即模式的AQ出队（deqopt.visibility）</p>
                           </li>
                           <li>
                              <p>流绑定或定义基于描述符的类型，例如对象或lob定位器</p>
                           </li>
                           <li>
                              <p>功能<code class="codeph">OCIStmtPrepare()</code></p>
                           </li>
                           <li>
                              <p>已注册的<code class="codeph">OCI_CBTYPE_ENTRY</code>类型的OCI回调，它不返回<code class="codeph">OCI_CONTINUE</code></p>
                           </li>
                           <li>
                              <p><code class="codeph">COMMIT NOWAIT</code>声明</p>
                           </li>
                           <li>
                              <p>DCL命令</p>
                           </li>
                        </ul>
                     </div>
                  </div>
                  <div class="props_rev_3"><a id="GUID-B54C508E-60E7-4053-BD7F-95272F8EDE35" name="GUID-B54C508E-60E7-4053-BD7F-95272F8EDE35"></a><h5 id="LNOCI-GUID-B54C508E-60E7-4053-BD7F-95272F8EDE35" class="sect5"><span class="enumeration_section">12.5.6.3</span>应用程序连续性可能产生的副作用</h5>
                     <div>
                        <p>一旦重建会话并恢复数据库状态，OCI中的应用程序连续性将在可恢复错误后重放原始PL / SQL和SQL语句。重播留下了两次看到的副作用，这可能是也可能不是。</p>
                        <p>应用程序了解这些副作用并确定重复执行是否可接受非常重要。如果不可接受，则应用程序必须采取措施以适应或减轻重播的影响。例如，通过调用<code class="codeph">OCIRequestDisableReplay()</code> 。
                        </p>
                        <div class="infoboxnotealso" id="GUID-B54C508E-60E7-4053-BD7F-95272F8EDE35__GUID-74A846EB-F08C-48A9-9B33-7F917E67CB00">
                           <p class="notep1">也可以看看：</p>
                           <p><a href="../racad/ensuring-application-continuity.html#RACAD-GUID-A250F3F8-D681-4F44-8969-7A8434E065DD" target="_blank"><span><cite>“Oracle Real Application Clusters管理和部署指南”</cite></span></a> ，以获取有关创建副作用的操作示例的更多信息。
                           </p>
                        </div>
                     </div>
                  </div>
               </div>
            </div>
         </div>
      </article>
   </body>
</html>