<!DOCTYPE html
  SYSTEM "about:legacy-compat">
<html xml:lang="en-us" lang="en-us">
   <head>
      <meta http-equiv="Content-Type" content="text/html; charset=utf-8">
      <meta name="viewport" content="width=device-width, initial-scale=1">
      <meta http-equiv="X-UA-Compatible" content="IE=edge">
      <meta name="abstract" content="This chapter describes high availability (HA) features in OCI.">
      <meta name="description" content="This chapter describes high availability (HA) features in OCI.">
      <title>High Availability in OCI</title>
      <meta property="og:site_name" content="Oracle Help Center">
      <meta property="og:title" content="Programmer's Guide">
      <meta property="og:description" content="This chapter describes high availability (HA) features in OCI.">
      <link rel="stylesheet" href="/sp_common/book-template/ohc-book-template/css/book.css">
      <link rel="shortcut icon" href="/sp_common/book-template/ohc-common/img/favicon.ico">
      <meta name="application-name" content="Programmer's Guide">
      <meta name="generator" content="DITA Open Toolkit version 1.8.5 (Mode = doc)">
      <meta name="plugin" content="SP_docbuilder HTML plugin release 18.2.2">
      <link rel="alternate" href="oracle-call-interface-programmers-guide.pdf" title="PDF File" type="application/pdf">
      <meta name="robots" content="all">
      <link rel="schema.dcterms" href="http://purl.org/dc/terms/">
      <meta name="dcterms.created" content="2019-01-14T08:46:00-08:00">
      
      <meta name="dcterms.dateCopyrighted" content="1996, 2019">
      <meta name="dcterms.category" content="database">
      <meta name="dcterms.identifier" content="E96204-01">
      
      <meta name="dcterms.product" content="en/database/oracle/oracle-database/19">
      
      <link rel="prev" href="session-and-connection-pooling.html" title="Previous" type="text/html">
      <link rel="next" href="notification-streams-advanced-queuing.html" title="Next" type="text/html">
      <script>
        document.write('<style type="text/css">');
        document.write('body > .noscript, body > .noscript ~ * { visibility: hidden; }');
        document.write('</style>');
     </script>
      <script data-main="/sp_common/book-template/ohc-book-template/js/book-config" src="/sp_common/book-template/requirejs/require.js"></script>
      <script>
            if (window.require === undefined) {
                document.write('<script data-main="sp_common/book-template/ohc-book-template/js/book-config" src="sp_common/book-template/requirejs/require.js"><\/script>');
                document.write('<link href="sp_common/book-template/ohc-book-template/css/book.css" rel="stylesheet"/>');
            }
        </script>
      <script type="application/json" id="ssot-metadata">{"primary":{"category":{"short_name":"database","element_name":"Database","display_in_url":true},"suite":{"short_name":"oracle","element_name":"Oracle","display_in_url":true},"product_group":{"short_name":"not-applicable","element_name":"Not applicable","display_in_url":false},"product":{"short_name":"oracle-database","element_name":"Oracle Database","display_in_url":true},"release":{"short_name":"19","element_name":"Release 19","display_in_url":true}}}</script>
      
    <meta name="dcterms.title" content="Oracle Call Interface Programmer's Guide">
    <meta name="dcterms.isVersionOf" content="LNOCI">
    <meta name="dcterms.release" content="Release 19">
  </head>
   <body>
      <div class="noscript alert alert-danger text-center" role="alert">
         <a href="session-and-connection-pooling.html" class="pull-left"><span class="glyphicon glyphicon-chevron-left" aria-hidden="true"></span>Previous</a>
         <a href="notification-streams-advanced-queuing.html" class="pull-right">Next<span class="glyphicon glyphicon-chevron-right" aria-hidden="true"></span></a>
         <span class="fa fa-exclamation-triangle" aria-hidden="true"></span> JavaScript must be enabled to correctly display this content
        
      </div>
      <article>
         <header>
            <ol class="breadcrumb" vocab="http://schema.org/" typeof="BreadcrumbList">
               <li property="itemListElement" typeof="ListItem"><a href="index.html" property="item" typeof="WebPage"><span property="name">Programmer's Guide</span></a></li>
               <li class="active" property="itemListElement" typeof="ListItem">High Availability in OCI</li>
            </ol>
            <a id="GUID-F9EC61C1-5892-41E3-A382-853E9A47789C" name="GUID-F9EC61C1-5892-41E3-A382-853E9A47789C"></a>
            
            <h2 id="LNOCI-GUID-F9EC61C1-5892-41E3-A382-853E9A47789C" class="sect2"><span class="enumeration_chapter">12 </span>High Availability in OCI
            </h2>
         </header>
         <div class="ind">
            <div>
               <p>This chapter describes high availability (HA) features in OCI.</p>
               <div class="p">This chapter includes the following topics:
                  <ul style="list-style-type: disc;">
                     <li>
                        <p><a href="high-availability-in-oci.html#GUID-A8B79A40-C4AA-4FBA-8042-C70C8FD2D2EF" title="Runtime connection load balancing routes work requests to sessions in a session pool that best serve the work.">Runtime Connection Load Balancing</a></p>
                     </li>
                     <li>
                        <p><a href="high-availability-in-oci.html#GUID-EF4E3248-D4F9-4F06-ADC5-700A36AAE5E7" title="Use HA event notification to provide a best-effort programmatic signal to the client if there is a database failure for high availability clients connected to an Oracle RAC database.">HA Event Notification</a></p>
                     </li>
                     <li>
                        <p><a href="high-availability-in-oci.html#GUID-F7817CD2-4A2C-4D37-BD36-56DBABD4725F" title="Transparent application failover (TAF) is a client-side feature designed to minimize disruptions to end-user applications that occur when database connectivity fails because of instance or network failure.">Transparent Application Failover in OCI</a></p>
                     </li>
                     <li>
                        <p><a href="high-availability-in-oci.html#GUID-A675AF7B-6FF0-460D-A6E6-C15E7C328C8F" title="Transaction Guard introduces the concept of at-most-once transaction execution in case of a planned or unplanned outage to help prevent an application upon failover from submitting a duplicate submission of an original submission.">OCI and Transaction Guard</a></p>
                     </li>
                     <li>
                        <p><a href="high-availability-in-oci.html#GUID-A8DD9422-2F82-42A9-9555-134296416E8F" title="Application Continuity (AC) gives High Availability (HA) during planned and unplanned outages. OCI support for AC was introduced with Oracle Database 12c Release 2 (12.2).">OCI and Application Continuity</a></p>
                     </li>
                  </ul>
               </div>
            </div>
            <div class="props_rev_3"><a id="GUID-A8B79A40-C4AA-4FBA-8042-C70C8FD2D2EF" name="GUID-A8B79A40-C4AA-4FBA-8042-C70C8FD2D2EF"></a><h3 id="LNOCI-GUID-A8B79A40-C4AA-4FBA-8042-C70C8FD2D2EF" class="sect3"><span class="enumeration_section">12.1 </span>Runtime Connection Load Balancing
               </h3>
               <div>
                  <p>Runtime connection load balancing routes work requests to sessions in a session pool that best serve the work.</p>
                  <p>It occurs when an application selects a session from an existing session pool and thus is a very frequent activity. For session pools that support services at one instance only, the first available session in the pool is adequate. When the pool supports services that span multiple instances, there is a need to distribute the work requests across instances so that the instances that are providing better service or have greater capacity get more requests.</p>
                  <p>Applications must connect to an Oracle RAC instance to enable runtime connection load balancing. Furthermore, these applications must: </p>
                  <ul style="list-style-type: disc;">
                     <li>
                        <p>Initialize the OCI Environment in <code class="codeph">OCI_EVENTS</code> mode
                        </p>
                     </li>
                     <li>
                        <p>Connect to a service that has runtime connection load balancing enabled (use the <code class="codeph">DBMS_SERVICE.MODIFY_SERVICE</code> procedure to set <code class="codeph">GOAL</code> and <code class="codeph">CLB_GOAL</code> as appropriate)
                        </p>
                     </li>
                     <li>
                        <p>Link with a thread library</p>
                     </li>
                  </ul>
                  <div class="infoboxnotealso" id="GUID-A8B79A40-C4AA-4FBA-8042-C70C8FD2D2EF__GUID-50651043-7613-4F36-95E2-4122F0E8CD32">
                     <p class="notep1">See Also:</p>
                     <ul style="list-style-type: disc;">
                        <li>
                           <p><a href="../racad/workload-management-with-dynamic-database-services.html#RACAD7302" target="_blank"><span><cite>Oracle Real Application Clusters Administration and Deployment Guide</cite></span></a> for information about load balancing advisory
                           </p>
                        </li>
                        <li>
                           <p><a href="../adfns/connection_strategies.html#ADFNS229" target="_blank"><span><cite>Oracle Database Development Guide</cite></span></a> for information about enabling and disabling runtime connection load balancing for the supported interfaces, and receiving load balancing advisory FAN events
                           </p>
                        </li>
                     </ul>
                  </div>
               </div>
            </div>
            <div class="props_rev_3"><a id="GUID-EF4E3248-D4F9-4F06-ADC5-700A36AAE5E7" name="GUID-EF4E3248-D4F9-4F06-ADC5-700A36AAE5E7"></a><h3 id="LNOCI-GUID-EF4E3248-D4F9-4F06-ADC5-700A36AAE5E7" class="sect3"><span class="enumeration_section">12.2 </span>HA Event Notification
               </h3>
               <div>
                  <p>Use HA event notification to provide a best-effort programmatic signal to the client if there is a database failure for high availability clients connected to an Oracle RAC database. </p>
                  <p>Suppose that a user employs a web browser to log in to an application server that accesses a back-end database server. Failure of the database instance can result in a wait that can be up to minutes in duration before the failure is known to the user. The ability to quickly detect failures of server instances, communicate this to the client, close connections, and clean up idle connections in connection pools is provided by HA event notification.</p>
                  <p>For high availability clients connected to an Oracle RAC database, you can use HA event notification to provide a best-effort programmatic signal to the client if there is a database failure. Client applications can register a callback on the environment handle to signal interest in this information. When a significant failure event occurs that applies to a connection made by this client, the callback is invoked, with information concerning the event (the event payload) and a list of connections (server handles) that were disconnected because of the failure.</p>
                  <p>For example, consider a client application that has two connections to instance A and two connections to instance B of the same database. If instance A goes down, a notification of the event is sent to the client, which then disconnects the two connections to instance B and invokes the registered callback. Note that if another instance C of the same database goes down, the client is not notified (because it does not affect any of the client's connections).</p>
                  <p>The HA event notification mechanism improves the response time of the application in the presence of failure. Before the mechanism was introduced in Oracle Database 10g Release 2 (10.2), a failure would result in the connection being broken only after the TCP timeout interval expired, which could take minutes. With HA event notification, the standalone, connection pool, and session pool connections are automatically broken and cleaned up by OCI, and the application callback is invoked within seconds of the failure event. If any of these server handles are TAF-enabled, failover is also automatically engaged by OCI.</p>
                  <p>In the current release, this functionality depends on Oracle Notification Service (ONS). It requires Oracle Clusterware to be installed and configured on the database server for the clients to receive the HA notifications through ONS. All clusterware installations (for example, Oracle Data Guard) should have the same ONS port. There is no client configuration required for ONS.</p>
                  <div class="infoboxnote" id="GUID-EF4E3248-D4F9-4F06-ADC5-700A36AAE5E7__GUID-3B124258-ED11-4264-B861-1783110DF5A9">
                     <p class="notep1">Note:</p>
                     <p>The client transparently gets the ONS server information from the database to which it connects. The application administrator can augment or override that information using the deployment configuration file <code class="codeph">oraaccess.xml</code>. 
                     </p>
                  </div>
                  <p>Applications must connect to an Oracle RAC instance to enable HA event notification. Furthermore, these applications must: </p>
                  <ul style="list-style-type: disc;">
                     <li>
                        <p>Initialize the OCI Environment in <code class="codeph">OCI_EVENTS</code> mode
                        </p>
                     </li>
                     <li>
                        <p>Connect to a service that has notifications enabled (use the <code class="codeph">DBMS_SERVICE.MODIFY_SERVICE</code> procedure to set <code class="codeph">AQ_HA_NOTIFICATIONS</code> to <code class="codeph">TRUE</code>)
                        </p>
                     </li>
                     <li>
                        <p>Link with a thread library</p>
                     </li>
                  </ul>
                  <p>Then these applications can register a callback that is invoked whenever an HA event occurs.</p>
                  <div class="p">This section includes the following topics:
                     <ul style="list-style-type: disc;">
                        <li>
                           <p><a href="high-availability-in-oci.html#GUID-7A565C79-9A70-459D-BD31-F94BA3E31CE0" title="The OCIEvent handle encapsulates the attributes from the event payload.">OCIEvent Handle</a></p>
                        </li>
                        <li>
                           <p><a href="high-availability-in-oci.html#GUID-F514FB5E-049B-4759-8E39-16853213F7C9" title="A connection pool in an instance of Oracle RAC consists of a pool of connections connected to different instances of Oracle RAC.">OCI Failover for Connection and Session Pools</a></p>
                        </li>
                        <li>
                           <p><a href="high-availability-in-oci.html#GUID-9588A120-E61E-4E87-85E8-1E6D9155B581" title="No special handling is required for independent connections; all such connections that are connected to failed instances are immediately disconnected.">OCI Failover for Independent Connections</a></p>
                        </li>
                        <li>
                           <p><a href="high-availability-in-oci.html#GUID-889935A8-154F-460B-9050-1600C4B53EA7" title="Shows the signature of the event callback of type OCIEventCallback.">Event Callback</a></p>
                        </li>
                        <li>
                           <p><a href="high-availability-in-oci.html#GUID-4EDF9F6A-6210-4731-909A-838EC0E7BB2E" title="Using custom pools, you can retrieve the server handle’s tag information so appropriate cleanup can be performed.">Custom Pooling: Tagged Server Handles</a></p>
                        </li>
                        <li>
                           <p><a href="high-availability-in-oci.html#GUID-D34432B4-2962-48A7-9D9C-789200091B43" title="You can have the application adjust its behavior if a connection is or is not TAF-enabled.">About Determining Transparent Application Failover (TAF) Capabilities</a></p>
                        </li>
                     </ul>
                  </div>
                  <div class="infoboxnotealso" id="GUID-EF4E3248-D4F9-4F06-ADC5-700A36AAE5E7__GUID-1F9FADDE-F254-4189-BACF-D2D94DC3B0B6">
                     <p class="notep1">See Also:</p>
                     <p><a href="build-and-configure-oci-applications.html#GUID-7F47F9F7-EF51-4D68-8B2A-2443C837710B" title="When equivalent parameters are set both in the sqlnet.ora and oraaccess.xml files, the oraaccess.xml file setting takes precedence over the corresponding sqlnet.ora file setting.">About Client-Side Deployment Parameters Specified in oraaccess.xml</a> for more information about <code class="codeph">oraaccess.xml</code> and details about the parameters under <code class="codeph">&lt;events&gt;</code>, <code class="codeph">&lt;fan&gt;</code> and <code class="codeph">&lt;ons&gt;</code></p>
                  </div>
               </div>
               <div class="props_rev_3"><a id="GUID-7A565C79-9A70-459D-BD31-F94BA3E31CE0" name="GUID-7A565C79-9A70-459D-BD31-F94BA3E31CE0"></a><h4 id="LNOCI-GUID-7A565C79-9A70-459D-BD31-F94BA3E31CE0" class="sect4"><span class="enumeration_section">12.2.1 </span>OCIEvent Handle
                  </h4>
                  <div>
                     <p>The <code class="codeph">OCIEvent</code> handle encapsulates the attributes from the event payload.
                     </p>
                     <p>OCI implicitly allocates this handle before calling the event callback, which can obtain the read-only attributes of the event by calling <code class="codeph">OCIAttrGet()</code>. Memory associated with these attributes is only valid for the duration of the event callback.
                     </p>
                     <div class="infoboxnotealso" id="GUID-7A565C79-9A70-459D-BD31-F94BA3E31CE0__GUID-1B9666B6-1DDA-4C42-8026-351B232F60AD">
                        <p class="notep1">See Also:</p>
                        <ul style="list-style-type: disc;">
                           <li>
                              <p><a href="handle-and-descriptor-attributes.html#GUID-0AE31265-370D-4373-82D6-837A7C8C8463" title="Lists and describes event handle attributes.">Event Handle Attributes</a></p>
                           </li>
                           <li>
                              <p><a href="handle-and-descriptor-functions.html#GUID-FA199A99-4D7A-42C2-BB0A-C20047B95DF9" title="Gets the value of an attribute of a handle.">OCIAttrGet()</a></p>
                           </li>
                        </ul>
                     </div>
                  </div>
               </div>
               <div class="props_rev_3"><a id="GUID-F514FB5E-049B-4759-8E39-16853213F7C9" name="GUID-F514FB5E-049B-4759-8E39-16853213F7C9"></a><h4 id="LNOCI-GUID-F514FB5E-049B-4759-8E39-16853213F7C9" class="sect4"><span class="enumeration_section">12.2.2 </span>OCI Failover for Connection and Session Pools
                  </h4>
                  <div>
                     <p>A connection pool in an instance of Oracle RAC consists of a pool of connections connected to different instances of Oracle RAC.</p>
                     <p>Upon receiving the node failure notification, all the connections connected to that particular instance should be cleaned up. For the connections that are in use, OCI must close the connections: transparent application failover (TAF) occurs immediately, and those connections are reestablished. The connections that are idle and in the free list of the pool must be purged, so that a bad connection is never returned to the user from the pool.</p>
                     <p>To accommodate custom connection pools, OCI provides a callback function that can be registered on the environment handle. If registered, this callback is invoked when an HA event occurs. Session pools are treated the same way as connection pools. Note that server handles from OCI connection pools or session pools are not passed to the callback. Hence in some cases, the callback could be called with an empty list of connections.</p>
                  </div>
               </div>
               <div class="props_rev_3"><a id="GUID-9588A120-E61E-4E87-85E8-1E6D9155B581" name="GUID-9588A120-E61E-4E87-85E8-1E6D9155B581"></a><h4 id="LNOCI-GUID-9588A120-E61E-4E87-85E8-1E6D9155B581" class="sect4"><span class="enumeration_section">12.2.3 </span>OCI Failover for Independent Connections
                  </h4>
                  <div>
                     <p>No special handling is required for independent connections; all such connections that are connected to failed instances are immediately disconnected.</p>
                     <p>For idle connections, TAF is engaged to reestablish the connection when the connection is used on a subsequent OCI call. Connections that are in use at the time of the failure event are broken out immediately, so that TAF can begin. Note that this applies for the "in-use" connections of connection and session pools also.</p>
                  </div>
               </div>
               <div class="props_rev_3"><a id="GUID-889935A8-154F-460B-9050-1600C4B53EA7" name="GUID-889935A8-154F-460B-9050-1600C4B53EA7"></a><h4 id="LNOCI-GUID-889935A8-154F-460B-9050-1600C4B53EA7" class="sect4"><span class="enumeration_section">12.2.4 </span>Event Callback
                  </h4>
                  <div>
                     <p>Shows the signature of the  event callback of type <code class="codeph">OCIEventCallback</code>.
                     </p>
                     <p>The event callback, of type <code class="codeph">OCIEventCallback</code>, has the following signature: 
                     </p><pre class="oac_no_warn" dir="ltr">void evtcallback_fn (void      *evtctx,
                     OCIEvent  *eventhp );
</pre><p>In this signature <code class="codeph">evtctx</code> is the client context, and <code class="codeph">OCIEvent</code> is an event handle that is opaque to the OCI library. The other input argument is <code class="codeph">eventhp</code>, the event handle (the attributes associated with an event).
                     </p>
                     <p>If registered, this function is called once for each event. For Oracle RAC HA events, this callback is invoked after the affected connections have been disconnected. The following environment handle attributes are used to register an event callback and context, respectively:</p>
                     <ul style="list-style-type: disc;">
                        <li>
                           <p><code class="codeph">OCI_ATTR_EVTCBK</code> is of data type <code class="codeph">OCIEventCallback</code> <code class="codeph">*</code>. It is read-only.
                           </p>
                        </li>
                        <li>
                           <p><code class="codeph">OCI_ATTR_EVTCTX</code> is of data type <code class="codeph">void</code> <code class="codeph">*</code>. It is also read-only.
                           </p>
                        </li>
                     </ul><pre class="oac_no_warn" dir="ltr">text *myctx = "dummy context"; /* dummy context passed to callback fn */
...
/* OCI_ATTR_EVTCBK and OCI_ATTR_EVTCTX are read-only. */
OCIAttrSet(envhp, (ub4) OCI_HTYPE_ENV, (void *) evtcallback_fn,
           (ub4) 0, (ub4) OCI_ATTR_EVTCBK, errhp);
OCIAttrSet(envhp, (ub4) OCI_HTYPE_ENV, (void *) myctx,
           (ub4) 0, (ub4) OCI_ATTR_EVTCTX, errhp);
...
</pre><p>Within the OCI event callback, the list of affected server handles is encapsulated in the <code class="codeph">OCIEvent</code> handle. For Oracle RAC HA DOWN events, client applications can iterate over a list of server handles that are affected by the event by using <code class="codeph">OCIAttrGet()</code> with attribute types <code class="codeph">OCI_ATTR_HA_SRVFIRST</code> and <code class="codeph">OCI_ATTR_HA_SRVNEXT</code>: 
                     </p><pre class="oac_no_warn" dir="ltr">OCIAttrGet(eventhp, OCI_HTYPE_EVENT, (void *)&amp;srvhp, (ub4 *)0,
           OCI_ATTR_HA_SRVFIRST, errhp); 
/* or, */
OCIAttrGet(eventhp, OCI_HTYPE_EVENT, (void *)&amp;srvhp, (ub4 *)0,
           OCI_ATTR_HA_SRVNEXT, errhp);
</pre><p>When called with attribute <code class="codeph">OCI_ATTR_HA_SRVFIRST</code>, this function retrieves the first server handle in the list of server handles affected. When called with attribute <code class="codeph">OCI_ATTR_HA_SRVNEXT</code>, this function retrieves the next server handle in the list. This function returns <code class="codeph">OCI_NO_DATA</code> and <code class="codeph">srvhp</code> is a <code class="codeph">NULL</code> pointer, when there are no more server handles to return.
                     </p>
                     <p><code class="codeph">srvhp</code> is an output pointer to a server handle whose connection has been closed because of an HA event. <code class="codeph">errhp</code> is an error handle to populate. The application returns an <code class="codeph">OCI_NO_DATA</code> error when there are no more affected server handles to retrieve.
                     </p>
                     <p>When retrieving the list of server handles that have been affected by an HA event, be aware that the connection has already been closed and many server handle attributes are no longer valid. Instead, use the user memory segment of the server handle to store any per-connection attributes required by the event notification callback. This memory remains valid until the server handle is freed.</p>
                     <div class="infoboxnotealso" id="GUID-889935A8-154F-460B-9050-1600C4B53EA7__GUID-512ED298-0BDC-46CA-8748-FCE0D864A337">
                        <p class="notep1">See Also:</p>
                        <p><a href="handle-and-descriptor-functions.html#GUID-FA199A99-4D7A-42C2-BB0A-C20047B95DF9" title="Gets the value of an attribute of a handle.">OCIAttrGet()</a></p>
                     </div>
                  </div>
               </div>
               <div class="props_rev_3"><a id="GUID-4EDF9F6A-6210-4731-909A-838EC0E7BB2E" name="GUID-4EDF9F6A-6210-4731-909A-838EC0E7BB2E"></a><h4 id="LNOCI-GUID-4EDF9F6A-6210-4731-909A-838EC0E7BB2E" class="sect4"><span class="enumeration_section">12.2.5 </span>Custom Pooling: Tagged Server Handles
                  </h4>
                  <div>
                     <p>Using custom pools, you can retrieve the server handle’s tag information so appropriate cleanup can be performed.</p>
                     <p>The following features apply to custom pools:</p>
                     <ul style="list-style-type: disc;">
                        <li>
                           <p>You can tag a server handle with its parent connection object if it is created on behalf of a custom pool. Use the "user memory" parameters of <code class="codeph">OCIHandleAlloc()</code> to request that the server handle be allocated with a user memory segment. A pointer to the "user memory" segment is returned by <code class="codeph">OCIHandleAlloc()</code>.
                           </p>
                        </li>
                        <li>
                           <p>When an HA event occurs and an affected server handle has been retrieved, there is a means to retrieve the server handle's tag information so appropriate cleanup can be performed. The attribute <code class="codeph">OCI_ATTR_USER_MEMORY</code> is used to retrieve a pointer to a handle's user memory segment. <code class="codeph">OCI_ATTR_USER_MEMORY</code> is valid for all user-allocated handles. If the handle was allocated with extra memory, this attribute returns a pointer to the user memory. A <code class="codeph">NULL</code> pointer is returned for those handles not allocated with extra memory. This attribute is read-only and is of data type <code class="codeph">void*</code>.
                           </p>
                        </li>
                     </ul>
                     <div class="infoboxnote" id="GUID-4EDF9F6A-6210-4731-909A-838EC0E7BB2E__GUID-CECC5161-D15D-4AE2-91F9-E2FD8EB99A8F">
                        <p class="notep1">Note:</p>
                        <p>You are free to define the precise contents of the server handle's user memory segment to facilitate cleanup activities from within the HA event callback (or for other purposes if needed) because OCI does not write or read from this memory in any way. The user memory segment is freed with the <code class="codeph">OCIHandleFree()</code> call on the server handle.
                        </p>
                     </div>
                     <p><a href="high-availability-in-oci.html#GUID-4EDF9F6A-6210-4731-909A-838EC0E7BB2E__CACCIFIF">Example 12-1</a> shows an example of event notification.
                     </p>
                     <div class="example" id="GUID-4EDF9F6A-6210-4731-909A-838EC0E7BB2E__CACCIFIF">
                        <p class="titleinexample">Example 12-1 Event Notification</p><pre class="oac_no_warn" dir="ltr">sword retval;
OCIServer *srvhp;
struct myctx {
   void *parentConn_myctx;
   uword numval_myctx;
};
typedef struct myctx myctx; 
myctx  *myctxp;
/* Allocate a server handle with user memory - pre 10.2 functionality */
if (retval = OCIHandleAlloc(envhp, (void **)&amp;srvhp, OCI_HTYPE_SERVER,
                            (size_t)sizeof(myctx), (void **)&amp;myctxp)
/* handle error */
myctxp-&gt;parentConn_myctx = &lt;parent connection reference&gt;;
 
/* In an event callback function, retrieve the pointer to the user memory */
evtcallback_fn(void *evtctx, OCIEvent *eventhp)
{ 
  myctx *ctxp = (myctx *)evtctx;
  OCIServer *srvhp;
  OCIError *errhp;
  sb4       retcode;
  retcode = OCIAttrGet(eventhp, OCI_HTYPE_SERVER, &amp;srvhp, (ub4 *)0,
                       OCI_ATTR_HA_SRVFIRST, errhp); 
  while (!retcode) /* OCIAttrGet will return OCI_NO_DATA if no more srvhp */ 
  {  
     OCIAttrGet((void *)srvhp, OCI_HTYPE_SERVER, (void *)&amp;ctxp,
                (ub4)0, (ub4)OCI_ATTR_USER_MEMORY, errhp);
           /* Remove the server handle from the parent connection object */
     retcode = OCIAttrGet(eventhp, OCI_HTYPE_SERVER, &amp;srvhp, (ub4 *)0,
                          OCI_ATTR_HA_SRVNEXT, errhp);
...
  }
...
}
</pre><div class="infoboxnotealso" id="GUID-4EDF9F6A-6210-4731-909A-838EC0E7BB2E__GUID-1BF0FA44-60E1-411F-87C2-8DEC2078F8C3">
                           <p class="notep1">See Also:</p>
                           <ul style="list-style-type: disc;">
                              <li>
                                 <p><a href="handle-and-descriptor-functions.html#GUID-C5BF55F7-A110-4CB5-9663-5056590F12B5" title="Returns a pointer to an allocated and initialized handle.">OCIHandleAlloc()</a></p>
                              </li>
                              <li>
                                 <p><a href="handle-and-descriptor-functions.html#GUID-E87E9F91-D3DC-4F35-BE7C-F1EFBFEEBA0A" title="Explicitly deallocates a handle">OCIHandleFree()</a></p>
                              </li>
                           </ul>
                        </div>
                     </div>
                     <!-- class="example" -->
                  </div>
               </div>
               <div class="props_rev_3"><a id="GUID-D34432B4-2962-48A7-9D9C-789200091B43" name="GUID-D34432B4-2962-48A7-9D9C-789200091B43"></a><h4 id="LNOCI-GUID-D34432B4-2962-48A7-9D9C-789200091B43" class="sect4"><span class="enumeration_section">12.2.6 </span>About Determining Transparent Application Failover (TAF) Capabilities
                  </h4>
                  <div>
                     <p>You can have the application adjust its behavior if a connection is or is not TAF-enabled.</p>
                     <p>Use <code class="codeph">OCIAttrGet()</code> as follows to determine if a server handle is TAF-enabled:
                     </p><pre class="oac_no_warn" dir="ltr">boolean taf_capable;
...
OCIAttrGet(srvhp, (ub4) OCI_HTYPE_SERVER, (void *) &amp;taf_capable, 
           (ub4) sizeof(taf_capable), (ub4)OCI_ATTR_TAF_ENABLED, errhp);
...
</pre><p>In this example, <code class="codeph">taf_capable</code> is a <span>Boolean variable</span>, which this call sets to <code class="codeph">TRUE</code> if the server handle is TAF-enabled, and <code class="codeph">FALSE</code> if not; <code class="codeph">srvhp</code> is an input target server handle; <code class="codeph">OCI_ATTR_TAF_ENABLED</code> is an attribute that is a pointer to a <span>Boolean</span> variable and is read-only; <code class="codeph">errhp</code> is an input error handle.
                     </p>
                  </div>
               </div>
            </div>
            <div class="props_rev_3"><a id="GUID-F7817CD2-4A2C-4D37-BD36-56DBABD4725F" name="GUID-F7817CD2-4A2C-4D37-BD36-56DBABD4725F"></a><h3 id="LNOCI-GUID-F7817CD2-4A2C-4D37-BD36-56DBABD4725F" class="sect3"><span class="enumeration_section">12.3 </span>Transparent Application Failover in OCI
               </h3>
               <div>
                  <p>Transparent application failover (TAF) is a client-side feature designed to minimize disruptions to end-user applications that occur when database connectivity fails because of instance or network failure.</p>
                  <p>TAF can be implemented on a variety of system configurations including Oracle Real Application Clusters (Oracle RAC) and Oracle Data Guard physical standby databases. TAF can also be used after restarting a single instance system (for example, when repairs are made).</p>
                  <p>TAF can be configured to restore database sessions and optionally, to replay open queries. Starting with Oracle Database 10g Release 2 (10.2) all statements that an application attempts to use after a failure attempt failover. That is, an attempt to execute or fetch against other statements engages TAF recovery just as for the failure-time statement. Subsequent statements may now succeed (whereas in the past they failed), or the application may receive errors corresponding to an attempted TAF recovery (such as <code class="codeph">ORA-25401</code>).
                  </p>
                  <div class="infoboxnote" id="GUID-F7817CD2-4A2C-4D37-BD36-56DBABD4725F__GUID-ECE2F46C-FE35-4806-873B-0E4A5F9DC5E3">
                     <p class="notep1">Note:</p>
                     <p>Oracle recommends for applications to register a callback, so when failover happens, the callback can be used to restore the session to the desired state.</p>
                  </div>
                  <div class="infoboxnote" id="GUID-F7817CD2-4A2C-4D37-BD36-56DBABD4725F__GUID-F4ECC2C1-0DBC-4EB2-A14F-C44453ECDFE4">
                     <p class="notep1">Note:</p>
                     <p>TAF is not supported for remote database links or for DML statements.</p>
                  </div>
                  <div class="p">This section contains the following topics:
                     <ul style="list-style-type: disc;">
                        <li>
                           <p><a href="high-availability-in-oci.html#GUID-B80BF32E-A4E5-4995-A5C6-0C53F823130F" title="TAF can be configured on both the client side and the server side. If both are configured, server-side settings take precedence.">About Configuring Transparent Application Failover</a></p>
                        </li>
                        <li>
                           <p><a href="high-availability-in-oci.html#GUID-0CBC5C17-608B-4C5D-9A88-37FBE27D8029" title="Because of the delay that can occur during failover, the application developer may want to inform the user that failover is in progress, and request that the user wait for notification that failover is complete.">Transparent Application Failover Callbacks in OCI</a></p>
                        </li>
                        <li>
                           <p><a href="high-availability-in-oci.html#GUID-3C9922CC-3346-4C29-81F8-8E3CF7170CF6" title="Describes the TAF Callback structure and parameters.">Transparent Application Failover Callback Structure and Parameters</a></p>
                        </li>
                        <li>
                           <p><a href="high-availability-in-oci.html#GUID-C3241340-0A2E-4D02-9981-A7F091051664" title="Shows and describes the basic structure of a user-defined application failover callback function.">Failover Callback Structure and Parameters</a></p>
                        </li>
                        <li>
                           <p><a href="high-availability-in-oci.html#GUID-6DDC46DE-B960-4DD6-9B2F-DC4AA904A2F3" title="For the failover callback to be used, it must be registered on the server context handle. This registration is done by creating a callback definition structure and setting the OCI_ATTR_FOCBK attribute of the server handle to this structure.">Failover Callback Registration</a></p>
                        </li>
                        <li>
                           <p><a href="high-availability-in-oci.html#GUID-860A2B81-F867-4345-96DE-F423753D1D91" title="Shows several failover callback examples.">Failover Callback Example</a></p>
                        </li>
                        <li>
                           <p><a href="high-availability-in-oci.html#GUID-8B99BA40-ABB5-4EA8-8820-FBAAA43CA4F8" title="A failover attempt is not always successful. If the attempt fails, the callback function receives a value of OCI_FO_ABORT or OCI_FO_ERROR in the fo_event parameter.">Handling OCI_FO_ERROR</a></p>
                        </li>
                     </ul>
                  </div>
               </div>
               <div class="props_rev_3"><a id="GUID-B80BF32E-A4E5-4995-A5C6-0C53F823130F" name="GUID-B80BF32E-A4E5-4995-A5C6-0C53F823130F"></a><h4 id="LNOCI-GUID-B80BF32E-A4E5-4995-A5C6-0C53F823130F" class="sect4"><span class="enumeration_section">12.3.1 </span>About Configuring Transparent Application Failover
                  </h4>
                  <div>
                     <p>TAF can be configured on both the client side and the server side. If both are configured, server-side settings take precedence.</p>
                     <p>Configure TAF on the client side by including the <code class="codeph">FAILOVER_MODE</code> parameter in the <code class="codeph">CONNECT_DATA</code> portion of a connect descriptor. 
                     </p>
                     <p>Configure TAF on the server side by modifying the target service with the <code class="codeph">DBMS_SERVICE.MODIFY_SERVICE</code> packaged procedure.
                     </p>
                     <p>An initial attempt at failover may not always succeed. OCI provides a mechanism for retrying failover after an unsuccessful attempt. </p>
                     <div class="infoboxnotealso" id="GUID-B80BF32E-A4E5-4995-A5C6-0C53F823130F__GUID-5399ECA3-3E96-456B-AB8A-58C06FF94417">
                        <p class="notep1">See Also:</p>
                        <ul style="list-style-type: disc;">
                           <li>
                              <p><a href="../netrf/local-naming-parameters-in-tns-ora-file.html#NETRF279" target="_blank"><span><cite>Oracle Database Net Services Reference</cite></span></a> for more information about client-side configuration of TAF (Connect Data Section)
                              </p>
                           </li>
                           <li>
                              <p><a href="../arpls/DBMS_SERVICE.html#ARPLS092" target="_blank"><span><cite>Oracle Database PL/SQL Packages and Types Reference</cite></span></a> for more information about the server-side configuration of TAF (DBMS_SERVICE)
                              </p>
                           </li>
                        </ul>
                        <p> </p>
                     </div>
                  </div>
               </div>
               <div class="props_rev_3"><a id="GUID-0CBC5C17-608B-4C5D-9A88-37FBE27D8029" name="GUID-0CBC5C17-608B-4C5D-9A88-37FBE27D8029"></a><h4 id="LNOCI-GUID-0CBC5C17-608B-4C5D-9A88-37FBE27D8029" class="sect4"><span class="enumeration_section">12.3.2 </span>Transparent Application Failover Callbacks in OCI
                  </h4>
                  <div>
                     <p>Because of the delay that can occur during failover, the application developer may want to inform the user that failover is in progress, and request that the user wait for notification that failover is complete. </p>
                     <p>Additionally, the session on the initial instance may have received some <code class="codeph">ALTER</code> <code class="codeph">SESSION</code> commands. These <code class="codeph">ALTER</code> <code class="codeph">SESSION</code> commands are not automatically replayed on the second instance. Consequently, the developer may want to replay them on the second instance. <code class="codeph">OCIAttrSet()</code> calls that affect the session must also be reexecuted.
                     </p>
                     <p>To accommodate these requirements, the application developer can register a failover callback function. If failover occurs, the callback function is invoked several times while reestablishing the user's session.</p>
                     <p>The first call to the callback function occurs when the database first detects an instance connection loss. This callback is intended to allow the application to inform the user of an upcoming delay. If failover is successful, a second call to the callback function occurs when the connection is reestablished and usable.</p>
                     <p>Once the connection has been reestablished, the client may want to replay <code class="codeph">ALTER</code> <code class="codeph">SESSION</code> commands and inform the user that failover has happened. If failover is unsuccessful, then the callback is called to inform the application that failover cannot occur. Additionally, the callback is called each time a user handle besides the primary handle is reauthenticated on the new connection. Because each user handle represents a server-side session, the client may want to replay <code class="codeph">ALTER</code> <code class="codeph">SESSION</code> commands for that session.
                     </p>
                     <div class="infoboxnotealso" id="GUID-0CBC5C17-608B-4C5D-9A88-37FBE27D8029__GUID-3472650E-73ED-4D3C-AAB5-ECA412AFD7F0">
                        <p class="notep1">See Also:</p>
                        <ul style="list-style-type: disc;">
                           <li>
                              <p><a href="handle-and-descriptor-functions.html#GUID-3741D7BD-7652-4D7A-8813-AC2AEA8D3B03" title="Sets the value of an attribute of a handle or a descriptor.">OCIAttrSet()</a></p>
                           </li>
                           <li>
                              <p><a href="high-availability-in-oci.html#GUID-8B99BA40-ABB5-4EA8-8820-FBAAA43CA4F8" title="A failover attempt is not always successful. If the attempt fails, the callback function receives a value of OCI_FO_ABORT or OCI_FO_ERROR in the fo_event parameter.">Handling OCI_FO_ERROR</a> for more information about this scenario
                              </p>
                           </li>
                        </ul>
                        <p></p>
                     </div>
                  </div>
               </div>
               <div class="sect3"><a id="GUID-3C9922CC-3346-4C29-81F8-8E3CF7170CF6" name="GUID-3C9922CC-3346-4C29-81F8-8E3CF7170CF6"></a><h4 id="LNOCI-GUID-3C9922CC-3346-4C29-81F8-8E3CF7170CF6" class="sect4"><span class="enumeration_section">12.3.3 </span>Transparent Application Failover Callback Structure and Parameters
                  </h4>
                  <div>
                     <p>Describes the TAF Callback structure and parameters.</p>
                     <p>The basic structure of a Transparent Application Failover (TAF) callback function is as follows:</p><pre class="oac_no_warn" dir="ltr">sb4  TAFcbk_fn(OCISvcCtx *svchp, 
               OCIEnv    *envhp, 
               void      *fo_ctx, 
               ub4        fo_type, 
               ub4        fo_event);
</pre><dl>
                        <dt class="dlterm"><a name="GUID-3C9922CC-3346-4C29-81F8-8E3CF7170CF6__GUID-D2B2B2EF-2CB2-422C-A086-3A0869BC79E2">
                              <!-- --></a>svchp
                        </dt>
                        <dd>
                           <p>The service context handle.</p>
                        </dd>
                        <dt class="dlterm"><a name="GUID-3C9922CC-3346-4C29-81F8-8E3CF7170CF6__GUID-95AD87F7-0C9D-4B30-B3B8-E677F2AFA49B">
                              <!-- --></a>envhp
                        </dt>
                        <dd>
                           <p>The OCI environment handle.</p>
                        </dd>
                        <dt class="dlterm"><a name="GUID-3C9922CC-3346-4C29-81F8-8E3CF7170CF6__GUID-C3669A54-4D7A-4E4C-ADD3-CC8DEF859713">
                              <!-- --></a>fo_ctx
                        </dt>
                        <dd>
                           <p>The client context. This is a pointer to memory specified by the client. In this area the client can keep any necessary state or context.</p>
                        </dd>
                        <dt class="dlterm"><a name="GUID-3C9922CC-3346-4C29-81F8-8E3CF7170CF6__GUID-CEC7681E-9839-416B-9CC3-BCAA294790B4">
                              <!-- --></a>fo_type
                        </dt>
                        <dd>
                           <div class="p"> The failover type. This lets the callback know what type of failover the client has requested. The usual values are as follows: 
                              <ul style="list-style-type: disc;">
                                 <li>
                                    <p><code class="codeph">OCI_FO_SESSION</code> indicates that the user has requested only session failover.
                                    </p>
                                 </li>
                                 <li>
                                    <p><code class="codeph">OCI_FO_SELECT</code> indicates that the user has requested select failover as well.
                                    </p>
                                 </li>
                              </ul>
                           </div>
                        </dd>
                        <dt class="dlterm"><a name="GUID-3C9922CC-3346-4C29-81F8-8E3CF7170CF6__GUID-CEAF5918-C959-4396-949E-7BB327B85000">
                              <!-- --></a>fo_event
                        </dt>
                        <dd>
                           <div class="p"> The failover event indicates the current status of the failover.
                              <ul style="list-style-type: disc;">
                                 <li>
                                    <p><code class="codeph">OCI_FO_BEGIN</code> indicates that failover has detected a lost connection and failover is starting.
                                    </p>
                                 </li>
                                 <li>
                                    <p><code class="codeph">OCI_FO_END</code> indicates successful completion of failover. 
                                    </p>
                                 </li>
                                 <li>
                                    <p><code class="codeph">OCI_FO_ABORT</code> indicates that failover was unsuccessful, and there is no option of retrying.
                                    </p>
                                 </li>
                                 <li>
                                    <p><code class="codeph">OCI_FO_ERROR</code> also indicates that failover was unsuccessful, but it gives the application the opportunity to handle the error and retry failover. 
                                    </p>
                                 </li>
                                 <li>
                                    <p><code class="codeph">OCI_FO_REAUTH</code> indicates that you have multiple authentication handles and failover has occurred after the original authentication. It indicates that a user handle has been reauthenticated. To determine which one, the application checks the <code class="codeph">OCI_ATTR_SESSION</code> attribute of the service context handle <code class="codeph">svchp</code>.
                                    </p>
                                 </li>
                              </ul>
                           </div>
                        </dd>
                     </dl>
                     <p>If Application Continuity is configured, the TAF callback is called with <code class="codeph">OCI_FO_END</code> after successfully re-connecting, re-authenicating, and determining the status of the inflight transaction.
                     </p>
                     <p>Upon completion of the TAF callback, OCI returns an error if an open transaction is present and Application Continuity for OCI is enabled.</p>
                  </div>
               </div>
               <div class="props_rev_3"><a id="GUID-C3241340-0A2E-4D02-9981-A7F091051664" name="GUID-C3241340-0A2E-4D02-9981-A7F091051664"></a><h4 id="LNOCI-GUID-C3241340-0A2E-4D02-9981-A7F091051664" class="sect4"><span class="enumeration_section">12.3.4 </span>Failover Callback Structure and Parameters
                  </h4>
                  <div>
                     <p>Shows and describes the basic structure of a user-defined application failover callback function.</p>
                     <p>The basic structure of a user-defined application failover callback function is as follows:</p><pre class="oac_no_warn" dir="ltr">sb4 appfocallback_fn ( void       * svchp, 
                       void       * envhp, 
                       void       * fo_ctx, 
                       ub4        fo_type, 
                       ub4        fo_event );
</pre><p>An example is provided in "Failover Callback Example" on page&nbsp;9‐31 for the following parameters:</p>
                     <dl>
                        <dt class="dlterm"><a name="GUID-C3241340-0A2E-4D02-9981-A7F091051664__GUID-BEA274C9-256A-4618-AF1E-8B752BA5FA54">
                              <!-- --></a>svchp
                        </dt>
                        <dd>
                           <p>The first parameter, <code class="codeph">svchp</code>, is the service context handle. It is of type <code class="codeph">void *</code>.
                           </p>
                        </dd>
                        <dt class="dlterm"><a name="GUID-C3241340-0A2E-4D02-9981-A7F091051664__GUID-E0324FA7-6FDD-4AB3-A132-C3C6BB676F0E">
                              <!-- --></a>envhp
                        </dt>
                        <dd>
                           <p>The second parameter, <code class="codeph">envhp</code>, is the OCI environment handle. It is of type <code class="codeph">void *</code>. 
                           </p>
                        </dd>
                        <dt class="dlterm"><a name="GUID-C3241340-0A2E-4D02-9981-A7F091051664__GUID-7BEAF6CC-5C8B-4669-B86E-AC9C71BAB580">
                              <!-- --></a>fo_ctx
                        </dt>
                        <dd>
                           <p>The third parameter, <code class="codeph">fo_ctx</code>, is a client context. It is a pointer to memory specified by the client. In this area the client can keep any necessary state or context. It is passed as a <code class="codeph">void *</code>.
                           </p>
                        </dd>
                        <dt class="dlterm"><a name="GUID-C3241340-0A2E-4D02-9981-A7F091051664__GUID-F02332EE-B218-4728-BE16-CE8F7120B294">
                              <!-- --></a>fo_type
                        </dt>
                        <dd>
                           <p>The fourth parameter, <code class="codeph">fo_type</code>, is the failover type. This lets the callback know what type of failover the client has requested. The usual values are as follows: 
                           </p>
                        </dd>
                     </dl>
                     <ul style="list-style-type: disc;">
                        <li>
                           <p><code class="codeph">OCI_FO_SESSION</code> indicates that the user has requested only session failover.
                           </p>
                        </li>
                        <li>
                           <p><code class="codeph">OCI_FO_SELECT</code> indicates that the user has requested select failover as well.
                           </p>
                        </li>
                     </ul>
                     <dl>
                        <dt class="dlterm"><a name="GUID-C3241340-0A2E-4D02-9981-A7F091051664__GUID-B41E338F-B047-400E-B249-F54CD38EBD55">
                              <!-- --></a>fo_event
                        </dt>
                        <dd>
                           <p>The last parameter is the failover event. This indicates to the callback why it is being called. It has several possible values:</p>
                        </dd>
                     </dl>
                     <ul style="list-style-type: disc;">
                        <li>
                           <p><code class="codeph">OCI_FO_BEGIN</code> indicates that failover has detected a lost connection and failover is starting.
                           </p>
                        </li>
                        <li>
                           <p><code class="codeph">OCI_FO_END</code> indicates successful completion of failover. 
                           </p>
                        </li>
                        <li>
                           <p><code class="codeph">OCI_FO_ABORT</code> indicates that failover was unsuccessful, and there is no option of retrying.
                           </p>
                        </li>
                        <li>
                           <p><code class="codeph">OCI_FO_ERROR</code> also indicates that failover was unsuccessful, but it gives the application the opportunity to handle the error and retry failover. 
                           </p>
                        </li>
                        <li>
                           <p><code class="codeph">OCI_FO_REAUTH</code> indicates that you have multiple authentication handles and failover has occurred after the original authentication. It indicates that a user handle has been reauthenticated. To determine which one, the application checks the <code class="codeph">OCI_ATTR_SESSION</code> attribute of the service context handle (which is the first parameter).
                           </p>
                        </li>
                     </ul>
                  </div>
               </div>
               <div class="props_rev_3"><a id="GUID-6DDC46DE-B960-4DD6-9B2F-DC4AA904A2F3" name="GUID-6DDC46DE-B960-4DD6-9B2F-DC4AA904A2F3"></a><h4 id="LNOCI-GUID-6DDC46DE-B960-4DD6-9B2F-DC4AA904A2F3" class="sect4"><span class="enumeration_section">12.3.5 </span>Failover Callback Registration
                  </h4>
                  <div>
                     <p>For the failover callback to be used, it must be registered on the server context handle. This registration is done by creating a callback definition structure and setting the <code class="codeph">OCI_ATTR_FOCBK</code> attribute of the server handle to this structure. 
                     </p>
                     <p>The callback definition structure must be of type <code class="codeph">OCIFocbkStruct</code>. It has two fields: <code class="codeph">callback_function</code>, which contains the address of the function to call, and <code class="codeph">fo_ctx</code>, which contains the address of the client context. 
                     </p>
                     <div class="infoboxnotealso" id="GUID-6DDC46DE-B960-4DD6-9B2F-DC4AA904A2F3__GUID-BBC89C26-CBD9-4036-B6B0-B436EC2662EC">
                        <p class="notep1">See Also:</p>
                        <p><a href="high-availability-in-oci.html#GUID-860A2B81-F867-4345-96DE-F423753D1D91__CACDAEEJ">Example 12-3</a> for an example of callback registration
                        </p>
                     </div>
                  </div>
               </div>
               <div class="props_rev_3"><a id="GUID-860A2B81-F867-4345-96DE-F423753D1D91" name="GUID-860A2B81-F867-4345-96DE-F423753D1D91"></a><h4 id="LNOCI-GUID-860A2B81-F867-4345-96DE-F423753D1D91" class="sect4"><span class="enumeration_section">12.3.6 </span>Failover Callback Example
                  </h4>
                  <div>
                     <p>Shows several failover callback examples.</p>
                     <div class="section">
                        <p>This section shows an example of a simple user-defined callback function definition (see <a href="high-availability-in-oci.html#GUID-860A2B81-F867-4345-96DE-F423753D1D91__CACJJHGH">Example 12-2</a>), failover callback registration (see <a href="high-availability-in-oci.html#GUID-860A2B81-F867-4345-96DE-F423753D1D91__CACDAEEJ">Example 12-3</a>), and failover callback unregistration (see <a href="high-availability-in-oci.html#GUID-860A2B81-F867-4345-96DE-F423753D1D91__CACDJGDG">Example 12-4</a>).
                        </p>
                     </div>
                     <!-- class="section" -->
                     <div class="example" id="GUID-860A2B81-F867-4345-96DE-F423753D1D91__CACJJHGH">
                        <p class="titleinexample">Example 12-2 User-Defined Failover Callback Function Definition</p><pre class="oac_no_warn" dir="ltr">sb4  callback_fn(svchp, envhp, fo_ctx, fo_type, fo_event)
void * svchp;
void * envhp;
void *fo_ctx;
ub4 fo_type;
ub4 fo_event;
{
switch (fo_event) 
   {
   case OCI_FO_BEGIN:
   {
     printf(" Failing Over ... Please stand by \n");
     printf(" Failover type was found to be %s \n",
                     ((fo_type==OCI_FO_SESSION) ? "SESSION" 
                     :(fo_type==OCI_FO_SELECT) ? "SELECT"
                     : "UNKNOWN!")); 
     printf(" Failover Context is :%s\n", 
                    (fo_ctx?(char *)fo_ctx:"NULL POINTER!"));
     break;
   }
   case OCI_FO_ABORT:
   {
     printf(" Failover stopped. Failover will not occur.\n");
     break;
   }
   case    OCI_FO_END:
   {
       printf(" Failover ended ...resuming services\n");
     break;
   }
   case OCI_FO_REAUTH:
   {
       printf(" Failed over user. Resuming services\n");
     break;
   }
   default:
   {
     printf("Bad Failover Event: %d.\n",  fo_event);
     break;
   }
   }
   return 0;
}</pre></div>
                     <!-- class="example" -->
                     <div class="example" id="GUID-860A2B81-F867-4345-96DE-F423753D1D91__CACDAEEJ">
                        <p class="titleinexample">Example 12-3 Failover Callback Registration</p><pre class="oac_no_warn" dir="ltr">int register_callback(srvh, errh)
void *srvh; /* the server handle */
OCIError *errh; /* the error handle */
{
  OCIFocbkStruct failover;                 /*  failover callback structure */
  /* allocate memory for context */
  if (!(failover.fo_ctx = (void *)malloc(strlen("my context.")+1)))
     return(1);
  /* initialize the context. */
  strcpy((char *)failover.fo_ctx, "my context.");
  failover.callback_function = &amp;callback_fn;
  /* do the registration */
  if (OCIAttrSet(srvh, (ub4) OCI_HTYPE_SERVER,
                (void *) &amp;failover, (ub4) 0,
                (ub4) OCI_ATTR_FOCBK, errh)  != OCI_SUCCESS)
     return(2);
  /* successful conclusion */
  return (0);
}
</pre></div>
                     <!-- class="example" -->
                     <div class="example" id="GUID-860A2B81-F867-4345-96DE-F423753D1D91__CACDJGDG">
                        <p class="titleinexample">Example 12-4 Failover Callback Unregistration</p><pre class="oac_no_warn" dir="ltr">OCIFocbkStruct failover;   /*  failover callback structure */
sword status;
 
  /* set the failover context to null */
  failover.fo_ctx = NULL; 
  /* set the failover callback to null */ 
  failover.callback_function = NULL; 
  /* unregister the callback */
  status = OCIAttrSet(srvhp, (ub4) OCI_HTYPE_SERVER,
                      (void *) &amp;failover, (ub4) 0,
                      (ub4) OCI_ATTR_FOCBK, errhp);
</pre></div>
                     <!-- class="example" -->
                  </div>
               </div>
               <div class="props_rev_3"><a id="GUID-8B99BA40-ABB5-4EA8-8820-FBAAA43CA4F8" name="GUID-8B99BA40-ABB5-4EA8-8820-FBAAA43CA4F8"></a><h4 id="LNOCI-GUID-8B99BA40-ABB5-4EA8-8820-FBAAA43CA4F8" class="sect4"><span class="enumeration_section">12.3.7 </span>Handling OCI_FO_ERROR
                  </h4>
                  <div>
                     <p>A failover attempt is not always successful. If the attempt fails, the callback function receives a value of <code class="codeph">OCI_FO_ABORT</code> or <code class="codeph">OCI_FO_ERROR</code> in the <code class="codeph">fo_event</code> parameter. 
                     </p>
                     <div class="section">
                        <p>A value of <code class="codeph">OCI_FO_ABORT</code> indicates that failover was unsuccessful, and no further failover attempts are possible. <code class="codeph">OCI_FO_ERROR</code>, however, provides the callback function with the opportunity to handle the error. For example, the callback may choose to wait a specified period of time and then indicate to the OCI library that it must reattempt failover.
                        </p>
                        <div class="infoboxnote" id="GUID-8B99BA40-ABB5-4EA8-8820-FBAAA43CA4F8__GUID-57E6B159-985F-486D-860A-BDBC85CA75F6">
                           <p class="notep1">Note:</p>
                           <p>This functionality is only available to applications linked with the 8.0.5 or later OCI libraries running against any Oracle Database server.</p>
                           <p>Failover does not work if a LOB column is part of the select list.</p>
                        </div>
                        <p>Consider the timeline of events presented in <a href="high-availability-in-oci.html#GUID-8B99BA40-ABB5-4EA8-8820-FBAAA43CA4F8__CACEHAGA" title="This table is described by 2 columns. Column 1 is the time designated as a timeline T0 through T7 and column 2 is the event that occurs for each timeline time.">Table 12-1</a>.
                        </p>
                        <div class="tblformal" id="GUID-8B99BA40-ABB5-4EA8-8820-FBAAA43CA4F8__CACEHAGA">
                           <p class="titleintable">Table 12-1 Time and Event</p>
                           <table cellpadding="4" cellspacing="0" class="Formal" title="Time and Event" summary="This table is described by 2 columns. Column 1 is the time designated as a timeline T0 through T7 and column 2 is the event that occurs for each timeline time." width="100%" frame="hsides" border="1" rules="rows">
                              <thead>
                                 <tr align="left" valign="top">
                                    <th align="left" valign="bottom" width="15%" id="d119972e4097">Time</th>
                                    <th align="left" valign="bottom" width="85%" id="d119972e4100">Event</th>
                                 </tr>
                              </thead>
                              <tbody>
                                 <tr align="left" valign="top">
                                    <td align="left" valign="top" width="15%" id="d119972e4105" headers="d119972e4097 ">
                                       <p>T0</p>
                                    </td>
                                    <td align="left" valign="top" width="85%" headers="d119972e4105 d119972e4100 ">
                                       <p>Database fails (failure lasts until T5).</p>
                                    </td>
                                 </tr>
                                 <tr align="left" valign="top">
                                    <td align="left" valign="top" width="15%" id="d119972e4112" headers="d119972e4097 ">
                                       <p>T1</p>
                                    </td>
                                    <td align="left" valign="top" width="85%" headers="d119972e4112 d119972e4100 ">
                                       <p>Failover is triggered by user activity.</p>
                                    </td>
                                 </tr>
                                 <tr align="left" valign="top">
                                    <td align="left" valign="top" width="15%" id="d119972e4119" headers="d119972e4097 ">
                                       <p>T2</p>
                                    </td>
                                    <td align="left" valign="top" width="85%" headers="d119972e4119 d119972e4100 ">
                                       <p>User attempts to reconnect; attempt fails.</p>
                                    </td>
                                 </tr>
                                 <tr align="left" valign="top">
                                    <td align="left" valign="top" width="15%" id="d119972e4126" headers="d119972e4097 ">
                                       <p>T3</p>
                                    </td>
                                    <td align="left" valign="top" width="85%" headers="d119972e4126 d119972e4100 ">
                                       <p>Failover callback is invoked with <code class="codeph">OCI_FO_ERROR</code>.
                                       </p>
                                    </td>
                                 </tr>
                                 <tr align="left" valign="top">
                                    <td align="left" valign="top" width="15%" id="d119972e4136" headers="d119972e4097 ">
                                       <p>T4</p>
                                    </td>
                                    <td align="left" valign="top" width="85%" headers="d119972e4136 d119972e4100 ">
                                       <p>Failover callback enters a predetermined sleep period.</p>
                                    </td>
                                 </tr>
                                 <tr align="left" valign="top">
                                    <td align="left" valign="top" width="15%" id="d119972e4143" headers="d119972e4097 ">
                                       <p>T5</p>
                                    </td>
                                    <td align="left" valign="top" width="85%" headers="d119972e4143 d119972e4100 ">
                                       <p>Database comes back up again.</p>
                                    </td>
                                 </tr>
                                 <tr align="left" valign="top">
                                    <td align="left" valign="top" width="15%" id="d119972e4150" headers="d119972e4097 ">
                                       <p>T6</p>
                                    </td>
                                    <td align="left" valign="top" width="85%" headers="d119972e4150 d119972e4100 ">
                                       <p>Failover callback triggers a new failover attempt; it is successful.</p>
                                    </td>
                                 </tr>
                                 <tr align="left" valign="top">
                                    <td align="left" valign="top" width="15%" id="d119972e4157" headers="d119972e4097 ">
                                       <p>T7</p>
                                    </td>
                                    <td align="left" valign="top" width="85%" headers="d119972e4157 d119972e4100 ">
                                       <p>User successfully reconnects.</p>
                                    </td>
                                 </tr>
                              </tbody>
                           </table>
                        </div>
                        <!-- class="inftblhruleinformal" -->
                        <p>The callback function triggers the new failover attempt by returning a value of <code class="codeph">OCI_FO_RETRY</code> from the function.
                        </p>
                        <p><a href="high-availability-in-oci.html#GUID-8B99BA40-ABB5-4EA8-8820-FBAAA43CA4F8__CACFEBEJ">Example 12-5</a> shows a callback function that you can use to implement the failover strategy similar to the scenario described earlier. In this case, the failover callback enters a loop in which it sleeps and then reattempts failover until it is successful:
                        </p>
                     </div>
                     <!-- class="section" -->
                     <div class="example" id="GUID-8B99BA40-ABB5-4EA8-8820-FBAAA43CA4F8__CACFEBEJ">
                        <p class="titleinexample">Example 12-5 Callback Function That Implements a Failover Strategy</p><pre class="oac_no_warn" dir="ltr">/*--------------------------------------------------------------------*/
/* the user-defined failover callback  */
/*--------------------------------------------------------------------*/
sb4  callback_fn(svchp, envhp, fo_ctx, fo_type, fo_event )
void * svchp;
void * envhp;
void *fo_ctx;
ub4 fo_type;
ub4 fo_event;
{
   OCIError *errhp;
   OCIHandleAlloc(envhp, (void **)&amp;errhp, (ub4) OCI_HTYPE_ERROR,
              (size_t) 0, (void **) 0);
   switch (fo_event) 
   {
   case OCI_FO_BEGIN:
   {
     printf(" Failing Over ... Please stand by \n");
     printf(" Failover type was found to be %s \n",
            ((fo_type==OCI_FO_NONE) ? "NONE"
             :(fo_type==OCI_FO_SESSION) ? "SESSION" 
             :(fo_type==OCI_FO_SELECT) ? "SELECT"
             :(fo_type==OCI_FO_TXNAL) ? "TRANSACTION"
             : "UNKNOWN!")); 
     printf(" Failover Context is :%s\n", 
            (fo_ctx?(char *)fo_ctx:"NULL POINTER!"));
     break;
   }
   case OCI_FO_ABORT:
   {
     printf(" Failover aborted. Failover will not occur.\n");
     break;
   }
   case    OCI_FO_END:
   { 
       printf("\n Failover ended ...resuming services\n");
     break;
   }
   case OCI_FO_REAUTH:
   { 
       printf(" Failed over user. Resuming services\n");
     break;
   }
   case OCI_FO_ERROR:
   {
     /* all invocations of this can only generate one line. The newline
      * will be put at fo_end time.
      */
     printf(" Failover error gotten. Sleeping...");
     sleep(3);
     printf("Retrying. ");
     return (OCI_FO_RETRY);
     break;
   }
   default:
   {
     printf("Bad Failover Event: %d.\n",  fo_event);
     break;
   }
   }
   return 0;
}
</pre></div>
                     <!-- class="example" -->
                  </div>
               </div>
            </div>
            <div class="props_rev_3"><a id="GUID-A675AF7B-6FF0-460D-A6E6-C15E7C328C8F" name="GUID-A675AF7B-6FF0-460D-A6E6-C15E7C328C8F"></a><h3 id="LNOCI-GUID-A675AF7B-6FF0-460D-A6E6-C15E7C328C8F" class="sect3"><span class="enumeration_section">12.4 </span>OCI and Transaction Guard
               </h3>
               <div>
                  <p>Transaction Guard introduces the concept of at-most-once transaction execution in case of a planned or unplanned outage to help prevent an application upon failover from submitting a duplicate submission of an original submission.</p>
                  <p></p>
                  <p>When an application opens a connection to the database using this service, the logical transaction ID (LTXID) is generated at authentication and stored in the session handle. This is a globally unique ID that identifies the database transaction from the application perspective. When there is an outage, an application using Transaction Guard can retrieve the LTXID from the previous failed session's handle and use it to determine the outcome of the transaction that was active prior to the session failure. If the LTXID is determined to be unused, then the application can replay an uncommitted transaction by first blocking the original submission using the retrieved LTXID. If the LTXID is determined to be used, then the transaction is committed and the result is returned to the application.</p>
                  <p>Transaction Guard is a developer API supported for JDBC Type 4 (Oracle Thin), OCI, OCCI, and Oracle Data Provider for .NET (ODP.NET) drivers. For OCI, when an application is written to support Transaction Guard, upon an outage, the OCI client driver acquires and retrieves the LTXID from the previous failed session's handle by calling <code class="codeph">OCI_ATTR_GET()</code> using the <code class="codeph">OCI_ATTR_LTXID</code> session handle attribute. 
                  </p>
                  <p>This section includes the following topic: <a href="high-availability-in-oci.html#GUID-6A12DE3A-479A-4D06-8305-AA450BFF6B23" title="This section describes developing OCI user applications that use Transaction Guard.">Developing Applications that Use Transaction Guard</a>.
                  </p>
                  <div class="infoboxnotealso" id="GUID-A675AF7B-6FF0-460D-A6E6-C15E7C328C8F__GUID-E3CF22A9-BA3E-4F88-87D2-C7DF883994E7">
                     <p class="notep1">See Also:</p>
                     <p><a href="../adfns/transaction-guard.html#ADFNS8000" target="_blank"><span><cite>Oracle Database Development Guide</cite></span></a> for information in the chapter about using Transaction Guard in for an overview of Transaction Guard, supported transaction types, transaction types that are not supported, and database configuration information for using Transaction Guard.
                     </p>
                  </div>
               </div>
               <div class="props_rev_3"><a id="GUID-6A12DE3A-479A-4D06-8305-AA450BFF6B23" name="GUID-6A12DE3A-479A-4D06-8305-AA450BFF6B23"></a><h4 id="LNOCI-GUID-6A12DE3A-479A-4D06-8305-AA450BFF6B23" class="sect4"><span class="enumeration_section">12.4.1 </span>Developing Applications that Use Transaction Guard
                  </h4>
                  <div>
                     <p>This section describes developing OCI user applications that use Transaction Guard. </p>
                     <div class="section">
                        <p>See the chapter about using Transaction Guard in <a href="../adfns/transaction-guard.html#ADFNS8000" target="_blank"><span><cite>Oracle Database Development Guide</cite></span></a> for more detailed information about developing applications using Transaction Guard.
                        </p>
                        <p>For the third-party or user application to use Transaction Guard in order to be able to fail over a session for OCI, it must include several major steps:</p>
                     </div>
                     <!-- class="section" -->
                     <ol>
                        <li class="stepexpand"><span>Verify if Transparent Application Failover (TAF) is enabled for the connection. Do not attempt to explicitly use Transaction Guard on a TAF-enabled connection, as TAF will automatically check the <code class="codeph">LTXID</code>.</span></li>
                        <li class="stepexpand"><span>On receipt of an error, determine whether the error is a recoverable error - <code class="codeph">OCI_ATTR_ERROR_IS_RECOVERABLE</code> on <code class="codeph">OCI_ERROR</code> handle. If the error is recoverable, then continue to Step <a href="high-availability-in-oci.html#GUID-6A12DE3A-479A-4D06-8305-AA450BFF6B23__CACFHAAG">3</a>. </span><div>
                              <div class="infoboxnote" id="GUID-6A12DE3A-479A-4D06-8305-AA450BFF6B23__GUID-DFBE8124-9838-4780-9E59-E7F81EB3CE57">
                                 <p class="notep1">Note:</p>
                                 <p>Do not attempt to use the LTXID to check transaction outcome if the connection has not suffered a recoverable error. </p>
                              </div>
                           </div>
                        </li>
                        <li class="stepexpand" id="GUID-6A12DE3A-479A-4D06-8305-AA450BFF6B23__CACFHAAG"><span>Retrieve the LTXID associated with the failed session by using OCI_ATTR_GET() to get the OCI_ATTR_LTXID from the user session handle. </span></li>
                        <li class="stepexpand"><span>Reconnect to the database.</span><div>
                              <div class="infoboxnote" id="GUID-6A12DE3A-479A-4D06-8305-AA450BFF6B23__GUID-82ABA5C6-B605-44B2-AD42-9FC952306A5B">
                                 <p class="notep1">Note:</p>
                                 <p>The new session will have a new LTXID, but you will not need it when checking the status of the original session. </p>
                              </div>
                           </div>
                        </li>
                        <li class="stepexpand"><span>Invoke the <code class="codeph">DBMS_APP_CONT.GET_LTXID_OUTCOME</code> PL/SQL procedure with the LTXID obtained from the <code class="codeph">OCI_ATTR_GET()</code> call. The original LTXID of the failed-over session is marked as forced if that LTXID has not been used. The return state tells the driver if the last transaction was <code class="codeph">COMMITTED (TRUE/FALSE)</code> and <code class="codeph">USER_CALL_COMPLETED (TRUE/FALSE)</code>.</span></li>
                        <li class="stepexpand"><span>The application can replay an uncommitted transaction or return the result to the user. If the replay itself incurs an outage, then the LTXID for the replaying session is used for the <code class="codeph">DBMS_APP_CONT.GET_LTXID_OUTCOME</code> procedure.</span></li>
                     </ol>
                     <div class="section">
                        <div class="p">See the following sections for Transaction Guard usage and examples:
                           <ul style="list-style-type: disc;">
                              <li>
                                 <p><a href="high-availability-in-oci.html#GUID-10A6CFB0-E480-48FE-B3A2-BB5AE6F88DF0" title="Shows typical usage of Transaction Guard using pseudocode.">Typical Transaction Guard Usage</a></p>
                              </li>
                              <li>
                                 <p><a href="high-availability-in-oci.html#GUID-671647AA-875B-45B6-BAA8-311B3E007EB9" title="Shows a Transaction Guard demo program.">Transaction Guard Examples</a></p>
                              </li>
                           </ul>
                        </div>
                     </div>
                     <!-- class="section" -->
                  </div>
                  <div class="props_rev_3"><a id="GUID-10A6CFB0-E480-48FE-B3A2-BB5AE6F88DF0" name="GUID-10A6CFB0-E480-48FE-B3A2-BB5AE6F88DF0"></a><h5 id="LNOCI-GUID-10A6CFB0-E480-48FE-B3A2-BB5AE6F88DF0" class="sect5"><span class="enumeration_section">12.4.1.1 </span>Typical Transaction Guard Usage
                     </h5>
                     <div>
                        <p>Shows typical usage of Transaction Guard using pseudocode.</p>
                        <p>The following pseudocode shows a typical usage of Transaction Guard:</p>
                        <ol>
                           <li>
                              <p>Receive a FAN down event (or recoverable error)</p>
                           </li>
                           <li>
                              <p>FAN aborts the dead session</p>
                           </li>
                           <li>
                              <p>Call <code class="codeph">OCIAttrGet()</code> using the <code class="codeph">OCI_ATTR_TAF_ENABLED</code> attribute on the server handle. If the value is <code class="codeph">TRUE</code>, stop. If the value is <code class="codeph">FALSE</code>, proceed to the next step.
                              </p>
                           </li>
                           <li>
                              <p>If it is a recoverable error, for OCI (<code class="codeph">OCI_ATTR_ERROR_IS_RECOVERABLE</code> on <code class="codeph">OCI_ERROR</code> handle):
                              </p>
                              <ol type="a">
                                 <li>
                                    <p>Get the last LTXID from the dead session by calling <code class="codeph">OCIAttrGet()</code> using the <code class="codeph">OCI_ATTR_LTXID</code> session handle attribute to retrieve the LTXID associated with the session's handle
                                    </p>
                                 </li>
                                 <li>
                                    <p>Obtain a new session </p>
                                 </li>
                                 <li>
                                    <p>Call <code class="codeph">DBMS_APP_CONT.GET_LTXID_OUTCOME</code> with the last LTXID to get the return state
                                    </p>
                                 </li>
                              </ol>
                           </li>
                           <li>
                              <p>If the return state is: </p>
                              <ol type="a">
                                 <li>
                                    <p><code class="codeph">COMMITTED</code> and <code class="codeph">USER_CALL_COMPLETED</code> 
                                    </p>
                                    <p>Then return the result.</p>
                                 </li>
                                 <li>
                                    <p><code class="codeph">ELSEIF COMMITTED</code> and <code class="codeph">NOT USER_CALL_COMPLETED</code> 
                                    </p>
                                    <p>Then return the result with a warning (with details, such as out binds or row count was not returned).</p>
                                 </li>
                                 <li>
                                    <p><code class="codeph">ELSEIF NOT COMMITTED</code> 
                                    </p>
                                    <p>Resubmit the transaction or series of calls or both, or return error to user.</p>
                                 </li>
                              </ol>
                           </li>
                        </ol>
                        <div class="infoboxnotealso" id="GUID-10A6CFB0-E480-48FE-B3A2-BB5AE6F88DF0__GUID-0C2AAC04-96F7-42F7-9374-B15025B62630">
                           <p class="notep1">See Also:</p>
                           <p><a href="handle-and-descriptor-functions.html#GUID-FA199A99-4D7A-42C2-BB0A-C20047B95DF9" title="Gets the value of an attribute of a handle.">OCIAttrGet()</a></p>
                        </div>
                     </div>
                  </div>
                  <div class="props_rev_3"><a id="GUID-671647AA-875B-45B6-BAA8-311B3E007EB9" name="GUID-671647AA-875B-45B6-BAA8-311B3E007EB9"></a><h5 id="LNOCI-GUID-671647AA-875B-45B6-BAA8-311B3E007EB9" class="sect5"><span class="enumeration_section">12.4.1.2 </span>Transaction Guard Examples
                     </h5>
                     <div>
                        <p>Shows a Transaction Guard demo program.</p>
                        <div class="section">
                           <p><a href="high-availability-in-oci.html#GUID-671647AA-875B-45B6-BAA8-311B3E007EB9__CACJFEEC">Example 12-6</a> is an OCI Transaction Guard demo program (<code class="codeph">cdemotg.c</code>) that demonstrates: 
                           </p>
                        </div>
                        <!-- class="section" -->
                        <div class="section">
                           <ul style="list-style-type: disc;">
                              <li>
                                 <p>Use of the attribute <code class="codeph">OCI_ATTR_ERROR_IS_RECOVERABLE</code>. When an error occurs, the program checks if the error is recoverable.
                                 </p>
                              </li>
                              <li>
                                 <p>Use of the packaged procedure <code class="codeph">DBMS_APP_CONT.GET_LTXID_OUTCOME</code>. If the error is recoverable, the program calls <code class="codeph">DBMS_APP_CONT.GET_LTXID_OUTCOME</code> to determine the status of the active transaction.
                                 </p>
                              </li>
                           </ul>
                           <p>If the transaction has not committed, the program re-executes the failed transaction.</p>
                           <div class="infoboxnote" id="GUID-671647AA-875B-45B6-BAA8-311B3E007EB9__GUID-42DD9B5E-8641-4B24-A9DD-1CA396998A6B">
                              <p class="notep1">Note:</p>
                              <p>This program does not modify the session state such as NLS parameters, and so forth. Programs that do so may need to reexecute such commands after obtaining a new session from the pool following the error.</p>
                           </div>
                        </div>
                        <!-- class="section" -->
                        <div class="example" id="GUID-671647AA-875B-45B6-BAA8-311B3E007EB9__CACJFEEC">
                           <p class="titleinexample">Example 12-6 Transaction Guard Demo Program</p><pre class="oac_no_warn" dir="ltr">*/
 
#ifndef OCISP_ORACLE
# include &lt;cdemosp.h&gt; 
#endif
 
/* Maximum Number of threads  */ 
#define MAXTHREAD 1
static ub4 sessMin = 1;
static ub4 sessMax = 9;
static ub4 sessIncr = 2;
 
static OCIError   *errhp;
static OCIEnv     *envhp;
static OCISPool   *poolhp=(OCISPool *) 0;
static int employeeNum[MAXTHREAD];
 
static OraText *poolName;
static ub4 poolNameLen;
static CONST OraText *database = (text *)"ltxid_service";
static CONST OraText *appusername =(text *)"scott";
static CONST OraText *apppassword =(text *)"tiger";
 
static CONST char getLtxid[]= 
  ("BEGIN <span class="bold">DBMS_APP_CONT.GET_LTXID_OUTCOME</span> ("
   ":ltxid,:committed,:callComplete); END;");
 
static CONST char insertst1[] = 
  ("INSERT INTO EMP(ENAME, EMPNO) values ('NAME1', 1000)");
 
static void checkerr (OCIError *errhp, sword status);
static void threadFunction (dvoid *arg);
 
int main(void)
{
  int i = 0;
  sword lstat;
  int timeout =1;
  OCIEnvCreate (&amp;envhp, OCI_THREADED, (dvoid *)0,  NULL,
                NULL, NULL, 0, (dvoid *)0);
 
  (void) OCIHandleAlloc((dvoid *) envhp, (dvoid **) &amp;errhp, OCI_HTYPE_ERROR,
                        (size_t) 0, (dvoid **) 0);
 
  (void) OCIHandleAlloc((dvoid *) envhp, (dvoid **) &amp;poolhp, OCI_HTYPE_SPOOL,
                        (size_t) 0, (dvoid **) 0);
 
  /* Create the session pool */
  checkerr(errhp, OCIAttrSet((dvoid *) poolhp,
           (ub4) OCI_HTYPE_SPOOL, (dvoid *) &amp;timeout, (ub4)0, 
           OCI_ATTR_SPOOL_TIMEOUT, errhp));
 
  if (lstat = OCISessionPoolCreate(envhp, errhp,poolhp, (OraText **)&amp;poolName, 
              (ub4 *)&amp;poolNameLen, database, 
              (ub4)strlen((const char *)database),
              sessMin, sessMax, sessIncr,
              (OraText *)appusername,
              (ub4)strlen((const char *)appusername),
              (OraText *)apppassword,
              (ub4)strlen((const char *)apppassword),
              OCI_SPC_STMTCACHE|OCI_SPC_HOMOGENEOUS))
  {
    checkerr(errhp,lstat);
  }
 
  printf("Session Pool Created \n");
 
  /* Multiple threads using the session pool */
  {
    OCIThreadId *thrid[MAXTHREAD];
    OCIThreadHandle *thrhp[MAXTHREAD];
 
    OCIThreadProcessInit ();
    checkerr (errhp, OCIThreadInit (envhp, errhp));
    for (i = 0; i &lt; MAXTHREAD; ++i)
    {
      checkerr (errhp, OCIThreadIdInit (envhp, errhp, &amp;thrid[i]));
      checkerr (errhp, OCIThreadHndInit (envhp, errhp, &amp;thrhp[i]));
    }
    for (i = 0; i &lt; MAXTHREAD; ++i)
    {
      employeeNum[i]=i;
      /* Inserting into EMP table */
      checkerr (errhp, OCIThreadCreate (envhp, errhp, threadFunction,
                (dvoid *) &amp;employeeNum[i], thrid[i], thrhp[i]));
    }
    for (i = 0; i &lt; MAXTHREAD; ++i)
    {
      checkerr (errhp, OCIThreadJoin (envhp, errhp, thrhp[i]));
      checkerr (errhp, OCIThreadClose (envhp, errhp, thrhp[i]));
      checkerr (errhp, OCIThreadIdDestroy (envhp, errhp, &amp;(thrid[i])));
      checkerr (errhp, OCIThreadHndDestroy (envhp, errhp, &amp;(thrhp[i])));
    }
    checkerr (errhp, OCIThreadTerm (envhp, errhp));
  } /* ALL THE THREADS ARE COMPLETE */
  lstat =  OCISessionPoolDestroy(poolhp, errhp, OCI_DEFAULT);
 
  printf("Session Pool Destroyed \n");
  
  if (lstat != OCI_SUCCESS)
    checkerr(errhp, lstat);
    
  checkerr(errhp, OCIHandleFree((dvoid *)poolhp, OCI_HTYPE_SPOOL));
    
  checkerr(errhp, OCIHandleFree((dvoid *)errhp, OCI_HTYPE_ERROR));
  return 0;
 
} /* end of main () */
 
/* Inserts records into EMP table */ 
static void threadFunction (dvoid *arg)
{
  int empno = *(int *)arg;
  OCISvcCtx *svchp = (OCISvcCtx *) 0;
  OCISvcCtx *svchp2 = (OCISvcCtx *) 0;
  OCISession *embUsrhp = (OCISession *)0;
  OCIBind *bnd1p, *bnd2p, *bnd3p;
 
  OCIStmt *stmthp = (OCIStmt *)0;
  OCIStmt *getLtxidStm = (OCIStmt *)0;
  OCIError  *errhp2 = (OCIError *) 0;
  OCIAuthInfo *authp = (OCIAuthInfo *)0;
  sword lstat;
  text name[10];
 
  boolean callCompl, committed, isRecoverable;
  ub1 *myLtxid;
  ub4  myLtxidLen;
 
  ub4 numAttempts = 0;
 
  (void) OCIHandleAlloc((dvoid *) envhp, (dvoid **) &amp;errhp2, OCI_HTYPE_ERROR,
                     (size_t) 0, (dvoid **) 0);
 
  lstat =  OCIHandleAlloc((dvoid *) envhp,
                          (dvoid **)&amp;authp, (ub4) OCI_HTYPE_AUTHINFO,
                          (size_t) 0, (dvoid **) 0);
  if (lstat)
    checkerr(errhp2, lstat);
 
  checkerr(errhp2, OCIAttrSet((dvoid *) authp,(ub4) OCI_HTYPE_AUTHINFO, 
           (dvoid *) appusername, (ub4) strlen((char *)appusername),
           (ub4) OCI_ATTR_USERNAME, errhp2));
 
  checkerr(errhp2,OCIAttrSet((dvoid *) authp,(ub4) OCI_HTYPE_AUTHINFO, 
           (dvoid *) apppassword, (ub4) strlen((char *)apppassword),
           (ub4) OCI_ATTR_PASSWORD, errhp2));
 
restart:
  if  (lstat = OCISessionGet(envhp, errhp2, &amp;svchp, authp,
               (OraText *)poolName, (ub4)strlen((char *)poolName), NULL, 
               0, NULL, NULL, NULL, OCI_SESSGET_SPOOL))
  {
    checkerr(errhp2,lstat);
  } 
  
  /* save the ltxid from the session in case we need to call
   *  get_ltxid_outcome to determine the transaction status.
   */
  checkerr(errhp2, OCIAttrGet(svchp, OCI_HTYPE_SVCCTX,
                              (dvoid *)&amp;embUsrhp, (ub4 *)0,
                              (ub4)OCI_ATTR_SESSION, errhp2));
  checkerr(errhp2, OCIAttrGet(embUsrhp, OCI_HTYPE_SESSION,
                              (dvoid *)&amp;myLtxid, (ub4 *)&amp;myLtxidLen,
                              (ub4)OCI_ATTR_LTXID, errhp2));
  
 
  /* */
  checkerr(errhp2, OCIStmtPrepare2(svchp, &amp;stmthp, errhp2, 
                                   (CONST OraText *)insertst1, 
                                   (ub4)sizeof(insertst1),
                                   (const oratext *)0, (ub4)0,
                                   OCI_NTV_SYNTAX, OCI_DEFAULT));
 
  if (!numAttempts)
  {
    char input[1];
 
    printf("Kill SCOTT's session now. Press ENTER when complete\n");
    gets(input);
  }
  lstat = OCIStmtExecute (svchp, stmthp, errhp2, (ub4)1, (ub4)0,
                          (OCISnapshot *)0, (OCISnapshot *)0, 
                          OCI_DEFAULT );
  if (lstat == OCI_ERROR)
  {
    checkerr(errhp2, OCIAttrGet(errhp2, OCI_HTYPE_ERROR,
                                (dvoid *)&amp;isRecoverable, (ub4 *)0,
                                (ub4)<span class="bold">OCI_ATTR_ERROR_IS_RECOVERABLE</span>, errhp2));
    if (isRecoverable)
    {
 
      printf("Recoverable error occurred; checking transaction status.\n");
      /* get another session to use for the get_ltxid_outcome call */
      if  (lstat = OCISessionGet(envhp, errhp2, &amp;svchp2, authp,
                                 (OraText *)poolName, 
                                 (ub4)strlen((char *)poolName), NULL, 
                                 0, NULL, NULL, NULL, OCI_SESSGET_SPOOL))
      {
        checkerr(errhp2,lstat);
      } 
      
      checkerr(errhp2,OCIStmtPrepare2(svchp2,&amp;getLtxidStm, errhp2, 
                                      (CONST OraText *)getLtxid,
                                      (ub4)sizeof(getLtxid),
                                      (const oratext *)0, (ub4)0,
                                      OCI_NTV_SYNTAX, OCI_DEFAULT));
      checkerr(errhp, OCIBindByPos(getLtxidStm, &amp;bnd1p, errhp, 1,
                                   (dvoid *) myLtxid, (sword)myLtxidLen,
                                   SQLT_BIN, (dvoid *)0,
                                   (ub2 *) 0, (ub2 *) 0, (ub4) 0, (ub4 *) 0,
                                   OCI_DEFAULT));
      checkerr(errhp, OCIBindByPos(getLtxidStm, &amp;bnd2p, errhp, 2,
                                   (dvoid *) &amp;committed, 
                                   (sword)sizeof(committed),
                                   SQLT_BOL, (dvoid *)0,
                                   (ub2 *) 0, (ub2 *) 0, (ub4) 0, (ub4 *) 0,
                                   OCI_DEFAULT));
      checkerr(errhp, OCIBindByPos(getLtxidStm, &amp;bnd3p, errhp, 3,
                                   (dvoid *) &amp;callCompl, 
                                   (sword)sizeof(callCompl),
                                   SQLT_BOL, (dvoid *)0,
                                   (ub2 *) 0, (ub2 *) 0, (ub4) 0, (ub4 *) 0,
                                   OCI_DEFAULT));
      
      checkerr(errhp2,OCIStmtExecute(svchp2, getLtxidStm, errhp2, 
                                     (ub4)1, (ub4)0,
                                     (OCISnapshot *)0, (OCISnapshot *)0, 
                                     OCI_DEFAULT ));
      checkerr(errhp2, OCISessionRelease(svchp2, errhp2, 
                                         NULL, 0, OCI_DEFAULT));
      if (committed &amp;&amp; callCompl)
        printf("Insert successfully commited \n");
      else if (!committed)
      {
        printf("Transaction did not commit; re-executing last transaction\n");
        numAttempts++;
 
        /* As there was an outage, do not return this session to the pool */
        checkerr(errhp2, 
                 OCISessionRelease(svchp, errhp2, 
                                   NULL, 0, OCI_SESSRLS_DROPSESS));
        svchp = (OCISvcCtx *)0;
        goto restart;
      }
    }
  }
  else
  {
    checkerr(errhp2, OCITransCommit(svchp,errhp2,(ub4)0));
    printf("Transaction committed successfully\n");
  }
  if (stmthp)
    checkerr(errhp2, OCIStmtRelease((dvoid *) stmthp, errhp2,
                                    (void *)0, 0, OCI_DEFAULT));
  if (getLtxidStm)
    checkerr(errhp2, OCIStmtRelease((dvoid *) getLtxidStm, errhp2,
                                    (void *)0, 0, OCI_DEFAULT));
 
  if (svchp)
    checkerr(errhp2, OCISessionRelease(svchp, errhp2, NULL, 0, OCI_DEFAULT));
  OCIHandleFree((dvoid *)authp, OCI_HTYPE_AUTHINFO);
  OCIHandleFree((dvoid *)errhp2, OCI_HTYPE_ERROR);
 
} /* end of threadFunction (dvoid *) */
 
/* This function prints the error */
void checkerr(errhp, status)
OCIError *errhp;
sword status;
{
  text errbuf[512];
  sb4 errcode = 0;
 
  switch (status)
  {
  case OCI_SUCCESS:
    break;
  case OCI_SUCCESS_WITH_INFO:
    (void) printf("Error - OCI_SUCCESS_WITH_INFO\n");
    break;
  case OCI_NEED_DATA:
    (void) printf("Error - OCI_NEED_DATA\n");
    break;
  case OCI_NO_DATA:
    (void) printf("Error - OCI_NODATA\n");
    break;
  case OCI_ERROR:
    (void) OCIErrorGet((dvoid *)errhp, (ub4) 1, (text *) NULL, &amp;errcode,
                       errbuf, (ub4) sizeof(errbuf), OCI_HTYPE_ERROR);
    (void) printf("Error - %.*s\n", 512, errbuf);
    break;
  case OCI_INVALID_HANDLE:
    (void) printf("Error - OCI_INVALID_HANDLE\n");
    break;
  case OCI_STILL_EXECUTING:
    (void) printf("Error - OCI_STILL_EXECUTE\n");
    break;
  case OCI_CONTINUE:
    (void) printf("Error - OCI_CONTINUE\n");
    break;
  default:
    break;
  }
}
</pre></div>
                        <!-- class="example" -->
                     </div>
                  </div>
               </div>
            </div>
            <div class="props_rev_3"><a id="GUID-A8DD9422-2F82-42A9-9555-134296416E8F" name="GUID-A8DD9422-2F82-42A9-9555-134296416E8F"></a><h3 id="LNOCI-GUID-A8DD9422-2F82-42A9-9555-134296416E8F" class="sect3"><span class="enumeration_section">12.5 </span>OCI and Application Continuity
               </h3>
               <div>
                  <p>Application Continuity (AC) gives High Availability (HA) during planned and unplanned outages. OCI support for AC was introduced with Oracle Database 12<span class="italic">c</span> Release 2 (12.2).
                  </p>
                  <p>AC masks hardware, software, network, storage errors, and timeouts in a HA environment running either Oracle RAC, Oracle RAC One, or Active Data Guard for instance or site failover. AC provides support for SQL*Plus, Tuxedo, WebLogic Server, and JDBC Type 4 (Oracle Thin), OCI, and Oracle Data Provider for .NET (ODP.NET) drivers.</p>
                  <p>With planned outages for applications that use the OCI session pool, the OCI session pool detects when a connection has been affected by a <code class="codeph">PLANNED DOWN</code> event and terminates the connection when it is returned to the pool. In planned outages for applications that do not use the OCI session pool, an OCI application detects when a connection has been impacted by a planned shutdown event. In either case, OCI implicitly determines when DML replay is safe and applications see fewer errors following a shutdown event.
                  </p>
                  <p>With unplanned outages, OCI uses Transaction Guard, which enables an OCI application to reliably determine the outcome of a transaction by recovering an in-flight transaction after a recoverable error occurs. This support means the completion of application requests during outages incurs only a minor delay while restoring database connectivity and session state. AC only attempts to replay an in-flight transaction if it can determine the transaction did not commit during original execution.</p>
                  <p>For AC support for OCI, Oracle recommends you use an OCI session pool or Tuxedo.</p>
                  <div class="p">This section includes the following topics:
                     <ul style="list-style-type: disc;">
                        <li>
                           <p><a href="high-availability-in-oci.html#GUID-BC59C816-621E-496D-8CC6-23176518BE75" title="Oracle Database release 18c, version 18.1 adds more support for Application Continuity.">About Added Support for Application Continuity</a></p>
                        </li>
                        <li>
                           <p><a href="high-availability-in-oci.html#GUID-E3D181AA-0346-4DF6-B154-DA43EE56EC1E" title="Following a recoverable error, database sessions fail over from one database instance to another database instance.">What Happens Following a Recoverable Error</a></p>
                        </li>
                        <li>
                           <p><a href="high-availability-in-oci.html#GUID-B291B826-C3EE-4A34-92CD-4F4CECC5D730" title="Successful driver replay requires that the client-visible effects of a post-failover transaction be identical to the initial submission.">Criteria for Successful Replay</a></p>
                        </li>
                        <li>
                           <p><a href="high-availability-in-oci.html#GUID-6936353C-3193-4052-AD34-D062FFF56B71" title="Lists the factors that implicitly disables Application Continuity in OCI until the start of the next application request.">What Factors Disable Application Continuity in OCI</a></p>
                        </li>
                        <li>
                           <p><a href="high-availability-in-oci.html#GUID-D40FACA1-FBE1-4540-B3C1-8E772404E655" title="What causes replay to fail.">Failed Replay</a></p>
                        </li>
                        <li>
                           <p><a href="high-availability-in-oci.html#GUID-6DACCD89-3CDE-42F5-882F-CB146E73A581" title="What determines the effectiveness of Application Continuity in OCI.">When Is Application Continuity Most Effective</a></p>
                        </li>
                     </ul>
                  </div>
                  <div class="infoboxnotealso" id="GUID-A8DD9422-2F82-42A9-9555-134296416E8F__GUID-EB448EFF-AE3D-494C-B870-2DA307C92E20">
                     <p class="notep1">See Also:</p>
                     <ul style="list-style-type: disc;">
                        <li>
                           <p><a href="../racad/workload-management-with-dynamic-database-services.html#RACAD-GUID-87EDF90F-1776-474A-AD9C-93F9CBE6CB31" target="_blank"><span><cite>Oracle Real Application Clusters Administration and Deployment Guide</cite></span></a> for information about creating services for Application Continuity and Transaction Guard.
                           </p>
                        </li>
                     </ul>
                  </div>
               </div>
               <div class="sect3"><a id="GUID-BC59C816-621E-496D-8CC6-23176518BE75" name="GUID-BC59C816-621E-496D-8CC6-23176518BE75"></a><h4 id="LNOCI-GUID-BC59C816-621E-496D-8CC6-23176518BE75" class="sect4"><span class="enumeration_section">12.5.1 </span>About Added Support for Application Continuity
                  </h4>
                  <div>
                     <p>Oracle Database release 18c, version 18.1 adds more support for Application Continuity.</p>
                     <div class="p">Beginning with Oracle Database release 18c, version 18.1, the following support is added for Application Continuity:
                        <ul style="list-style-type: disc;">
                           <li>
                              <p>Support is added for OCI dynamic binds and defines for numeric, character, and date/time types. This means the following OCI APIs are extended to support Application Continuity: <code class="codeph">OCIBindDynamic()</code> and <code class="codeph">OCIDefineDynamic()</code>.
                              </p>
                           </li>
                           <li>
                              <p>Support is added for binding and defining objects. This means the following OCI APIs are extended to support Application Continuity: <code class="codeph">OCIBindObject()</code>, <code class="codeph">OCIDefineObject()</code>, and <code class="codeph">OCITypeByName()</code>.
                              </p>
                           </li>
                           <li>
                              <p>During execution of LOB calls, Application Continuity now supports the handling of connection failure by restarting LOB calls that were interrupted by an outage.</p>
                           </li>
                           <li>
                              <p>OCI now supports the new Application Continuity <code class="codeph">FAILOVER_TYPE</code> of <code class="codeph">AUTO</code>, which only attempts to fail over if the session state is known to be restorable at the explicit request boundary.
                              </p>
                           </li>
                        </ul> 
                     </div>
                  </div>
               </div>
               <div class="props_rev_3"><a id="GUID-E3D181AA-0346-4DF6-B154-DA43EE56EC1E" name="GUID-E3D181AA-0346-4DF6-B154-DA43EE56EC1E"></a><h4 id="LNOCI-GUID-E3D181AA-0346-4DF6-B154-DA43EE56EC1E" class="sect4"><span class="enumeration_section">12.5.2 </span>What Happens Following a Recoverable Error
                  </h4>
                  <div>
                     <p>Following a recoverable error, database sessions fail over from one database instance to another database instance. </p>
                     <p>The new instance may be part of the same Oracle RAC cluster, or an Oracle Data Guard standby database that has been brought up as a primary database following a site failure. After transparent application failover (TAF) successfully reconnects and reauthenticates, Application Continuity in OCI replays the call history associated with the failed session, including all SQL and PL/SQL statements. Replay operates on a single session and does not attempt to synchronize the re-submission activity with any other database session. Replay is successful only if the client-visible results of transaction replay are identical to the original submission.</p>
                  </div>
               </div>
               <div class="props_rev_3"><a id="GUID-B291B826-C3EE-4A34-92CD-4F4CECC5D730" name="GUID-B291B826-C3EE-4A34-92CD-4F4CECC5D730"></a><h4 id="LNOCI-GUID-B291B826-C3EE-4A34-92CD-4F4CECC5D730" class="sect4"><span class="enumeration_section">12.5.3 </span>Criteria for Successful Replay
                  </h4>
                  <div>
                     <p>Successful driver replay requires that the client-visible effects of a post-failover transaction be identical to the initial submission.</p>
                     <p>This success is indicated by the following criteria:</p>
                     <ul style="list-style-type: disc;">
                        <li>
                           <p>Return codes and error message text must be identical.</p>
                        </li>
                        <li>
                           <p>Result sets must be identical. The define data must be identical and the rows must be returned in the same order.</p>
                        </li>
                        <li>
                           <p>The rows processed count must be identical. For example, a post-failover update statement must update the same number of rows as the original update statement.</p>
                        </li>
                        <li>
                           <p>Session state for the new connection matches session state from the original connection. </p>
                        </li>
                     </ul>
                     <p>See <a href="../racad/ensuring-application-continuity.html#RACAD-GUID-BD699AEB-9F85-42A8-8687-5A979918938D" target="_blank"><span><cite>Oracle Real Application Clusters Administration and Deployment Guide</cite></span></a> for information about these criteria.
                     </p>
                     <div class="section">
                        <p class="subhead3" id="GUID-B291B826-C3EE-4A34-92CD-4F4CECC5D730__GUID-067C96FD-AB0D-45CB-A6F4-416CB1D5A52A">Stability of Mutable Data and Application Continuity</p>
                        <p>When values change from one execution to the next for a mutable object, its data is considered to be mutable and is thus guaranteed to be non-replayable. Sequences are an example of this mutable data. </p>
                        <p>To improve the success rate for DML replay, it is necessary to replay DML involving mutable data with the values used at initial submission. If the original values are not kept and if different values for these mutable objects are returned to the client, replay is rejected because the client sees different results. </p>
                        <p>Support for keeping mutable object values is currently provided for <code class="codeph">SYSDATE</code>, <code class="codeph">SYSTIMESTAMP</code>, <code class="codeph">SYS_GUID</code>, and <code class="codeph"><span class="codeinlineitalic">sequence</span>.NEXTVAL</code>.
                        </p>
                        <div class="infoboxnotealso" id="GUID-B291B826-C3EE-4A34-92CD-4F4CECC5D730__GUID-B3DAD364-9822-4E00-965C-23F36E142B47">
                           <p class="notep1">See Also:</p>
                           <p><a href="../racad/ensuring-application-continuity.html#RACAD-GUID-E4A114A2-EA77-4037-A62A-BDFCF1E6D072" target="_blank"><span><cite>Oracle Real Application Clusters Administration and Deployment Guide</cite></span></a> for more information about mutable objects and Application Continuity.
                           </p>
                        </div>
                     </div>
                     <!-- class="section" -->
                  </div>
               </div>
               <div class="props_rev_3"><a id="GUID-6936353C-3193-4052-AD34-D062FFF56B71" name="GUID-6936353C-3193-4052-AD34-D062FFF56B71"></a><h4 id="LNOCI-GUID-6936353C-3193-4052-AD34-D062FFF56B71" class="sect4"><span class="enumeration_section">12.5.4 </span>What Factors Disable Application Continuity in OCI
                  </h4>
                  <div>
                     <p>Lists the factors that implicitly disables Application Continuity in OCI until the start of the next application request.</p>
                     <p>The following situations implicitly disables Application Continuity in OCI until the start of the next application request:</p>
                     <ul style="list-style-type: disc;">
                        <li>
                           <p>The server detects a condition that is not consistent with replay. For example, for <code class="codeph">SESSION_STATE_CONSISTENCY=DYNAMIC</code> if a PL/SQL anonymous block has an embedded top level <code class="codeph">COMMIT</code> statement (autonomous transactions are not considered top level), the driver implicitly disables Application Continuity in OCI.
                           </p>
                        </li>
                        <li>
                           <p>The application calls an OCI function that is not supported by Application Continuity in OCI.</p>
                        </li>
                     </ul>
                     <p>The application can explicitly disable Application Continuity in OCI by calling <code class="codeph">OCIRequestDisableReplay()</code>.
                     </p>
                  </div>
               </div>
               <div class="props_rev_3"><a id="GUID-D40FACA1-FBE1-4540-B3C1-8E772404E655" name="GUID-D40FACA1-FBE1-4540-B3C1-8E772404E655"></a><h4 id="LNOCI-GUID-D40FACA1-FBE1-4540-B3C1-8E772404E655" class="sect4"><span class="enumeration_section">12.5.5 </span>Failed Replay
                  </h4>
                  <div>
                     <p>What causes replay to fail.</p>
                     <p>When Application Continuity in OCI replays a transaction, the following situations will cause replay to fail:</p>
                     <ul style="list-style-type: disc;">
                        <li>
                           <p>Encountering a <code class="codeph">COMMIT</code> statement at replay time
                           </p>
                        </li>
                        <li>
                           <p>Replay results are not consistent with the initial submission of the transaction</p>
                        </li>
                        <li>
                           <p>Presence of a recoverable error during replay if the internal replay retries limit is exceeded</p>
                        </li>
                        <li>
                           <p>Applications that use <code class="codeph">OCIStmtPrepare()</code> return the following error: <code class="codeph">Error - ORA-25412: transaction replay disabled by call to OCIStmtPrepare</code>. Use the <code class="codeph">OCIStmtPrepare2()</code> call to support the use of Application Continuity in an HA infrastructure.
                           </p>
                        </li>
                     </ul>
                     <p>Application Continuity returns an error if it cannot successfully replay a failed transaction. Additional diagnostic information will be logged in the client-side trace file to indicate the reason for the replay failure.</p>
                  </div>
               </div>
               <div class="props_rev_3"><a id="GUID-6DACCD89-3CDE-42F5-882F-CB146E73A581" name="GUID-6DACCD89-3CDE-42F5-882F-CB146E73A581"></a><h4 id="LNOCI-GUID-6DACCD89-3CDE-42F5-882F-CB146E73A581" class="sect4"><span class="enumeration_section">12.5.6 </span>When Is Application Continuity Most Effective
                  </h4>
                  <div>
                     <p>What determines the effectiveness of Application Continuity in OCI.</p>
                     <p>Application Continuity in OCI is most effective under the following conditions:</p>
                     <ul style="list-style-type: disc;">
                        <li>
                           <p>The database service specifies the <code class="codeph">COMMIT_OUTCOME</code> attribute and transparent application failover (TAF) is configured.
                           </p>
                        </li>
                        <li>
                           <p>An application is able to mark the beginning and end of an application request, either explicitly (calling <code class="codeph">OCIRequestBegin()</code> and <code class="codeph">OCIRequestEnd()</code>) or implicitly through use of an OCI session pool.
                           </p>
                        </li>
                        <li>
                           <p>An application request contains at most one database transaction that is committed at the end of the request.</p>
                        </li>
                        <li>
                           <div class="p">If the application executes PL/SQL or Java in the server, that PL/SQL or Java: 
                              <ul style="list-style-type: disc;">
                                 <li>
                                    <p>Does not have embedded <code class="codeph">COMMIT</code> statements
                                    </p>
                                 </li>
                                 <li>
                                    <p>Does not set any state (for example, package variables) that is expected to persist after the PL/SQL or Java completes.</p>
                                 </li>
                              </ul>
                           </div>
                        </li>
                        <li>
                           <p>The TAF callback does not leave an open database transaction.</p>
                        </li>
                     </ul>
                     <div class="p">This section includes the following topics:
                        <ul style="list-style-type: disc;">
                           <li>
                              <p><a href="high-availability-in-oci.html#GUID-D30079AC-4E59-4CC3-86E8-6487A4891BA2" title="Describes with which functions when Application Continuity in OCI can fail over if an outage occurs.">When Application Continuity in OCI Can Fail Over</a></p>
                           </li>
                           <li>
                              <p><a href="high-availability-in-oci.html#GUID-8B38BDC1-A606-4893-A18F-CF1712DE29B2" title="What constructs are not supported by Application Continuity in OCI.">Application Continuity in OCI Does Not Support These Constructs</a></p>
                           </li>
                           <li>
                              <p><a href="high-availability-in-oci.html#GUID-B54C508E-60E7-4053-BD7F-95272F8EDE35" title="Application Continuity in OCI replays the original PL/SQL and SQL statements following a recoverable error once a session is rebuilt and the database state is restored. The replay leaves side-effects that are seen twice, which may or may not be desirable.">Possible Side Effects of Application Continuity</a></p>
                           </li>
                        </ul>
                     </div>
                  </div>
                  <div class="sect4"><a id="GUID-D30079AC-4E59-4CC3-86E8-6487A4891BA2" name="GUID-D30079AC-4E59-4CC3-86E8-6487A4891BA2"></a><h5 id="LNOCI-GUID-D30079AC-4E59-4CC3-86E8-6487A4891BA2" class="sect5"><span class="enumeration_section">12.5.6.1 </span>When Application Continuity in OCI Can Fail Over
                     </h5>
                     <div>
                        <p>Describes with which functions when Application Continuity in OCI can fail over if an outage occurs.</p>
                        <div class="p">Application Continuity in OCI can fail over if an outage occurs during one of the following functions:
                           <ul style="list-style-type: disc;">
                              <li>
                                 <p><code class="codeph">OCILobAppend()</code></p>
                              </li>
                              <li>
                                 <p><code class="codeph">OCILobArrayRead()</code></p>
                              </li>
                              <li>
                                 <p><code class="codeph">OCILobArrayWrite()</code></p>
                              </li>
                              <li>
                                 <p><code class="codeph">OCILobAssign()</code></p>
                              </li>
                              <li>
                                 <p><code class="codeph">OCILobCharSetForm()</code></p>
                              </li>
                              <li>
                                 <p><code class="codeph">OCILobClose()</code></p>
                              </li>
                              <li>
                                 <p><code class="codeph">OCILobCopy2()</code></p>
                              </li>
                              <li>
                                 <p><code class="codeph">OCILobCreateTemporary()</code></p>
                              </li>
                              <li>
                                 <p><code class="codeph">OCILobDisableBuffering()</code></p>
                              </li>
                              <li>
                                 <p><code class="codeph">OCILobEnableBuffering()</code></p>
                              </li>
                              <li>
                                 <p><code class="codeph">OCILobFileClose()</code></p>
                              </li>
                              <li>
                                 <p><code class="codeph">OCILobFileCloseAll()</code></p>
                              </li>
                              <li>
                                 <p><code class="codeph">OCILobFileGetName()</code></p>
                              </li>
                              <li>
                                 <p><code class="codeph">OCILobFileIsOpen()</code></p>
                              </li>
                              <li>
                                 <p><code class="codeph">OCILobFileOpen()</code></p>
                              </li>
                              <li>
                                 <p><code class="codeph">OCILobFileSetName()</code></p>
                              </li>
                              <li>
                                 <p><code class="codeph">OCILobFlushBuffer()</code></p>
                              </li>
                              <li>
                                 <p><code class="codeph">OCILobFreeTemporary()</code></p>
                              </li>
                              <li>
                                 <p><code class="codeph">OCILobGetChunkSize()</code></p>
                              </li>
                              <li>
                                 <p><code class="codeph">OCILobGetLength()</code></p>
                              </li>
                              <li>
                                 <p><code class="codeph">OCILobGetLength2()</code></p>
                              </li>
                              <li>
                                 <p><code class="codeph">OCILobGetStorageLimit()</code></p>
                              </li>
                              <li>
                                 <p><code class="codeph">OCILobIsEqual()</code></p>
                              </li>
                              <li>
                                 <p><code class="codeph">OCILobIsOpen()</code></p>
                              </li>
                              <li>
                                 <p><code class="codeph">OCILobIsTemporary()</code></p>
                              </li>
                              <li>
                                 <p><code class="codeph">OCILobLoadFromFile()</code></p>
                              </li>
                              <li>
                                 <p><code class="codeph">OCILobLoadFromFile2()</code></p>
                              </li>
                              <li>
                                 <p><code class="codeph">OCILobLocatorAssign()</code></p>
                              </li>
                              <li>
                                 <p><code class="codeph">OCILobLocatorIsInit()</code></p>
                              </li>
                              <li>
                                 <p><code class="codeph">OCILobOpen()</code></p>
                              </li>
                              <li>
                                 <p><code class="codeph">OCILobRead()</code></p>
                              </li>
                              <li>
                                 <p><code class="codeph">OCILobRead2()</code></p>
                              </li>
                              <li>
                                 <p><code class="codeph">OCILobTrim()</code></p>
                              </li>
                              <li>
                                 <p><code class="codeph">OCILobTrim2()</code></p>
                              </li>
                              <li>
                                 <p><code class="codeph">OCILobWriteAppend()</code></p>
                              </li>
                              <li>
                                 <p><code class="codeph">OCILobWriteAppend2()</code></p>
                              </li>
                              <li>
                                 <p><code class="codeph">OCILobWrite()</code></p>
                              </li>
                              <li>
                                 <p><code class="codeph">OCILobWrite2()</code></p>
                              </li>
                              <li>
                                 <p><code class="codeph">OCIPing()</code></p>
                              </li>
                              <li>
                                 <p><code class="codeph">OCIStmtExecute()</code></p>
                              </li>
                              <li>
                                 <p><code class="codeph">OCIStmtFetch()</code> 
                                 </p>
                              </li>
                              <li>
                                 <p><code class="codeph">OCIStmtFetch2()</code></p>
                              </li>
                              <li>
                                 <p><code class="codeph">OCISessionEnd()</code></p>
                              </li>
                              <li>
                                 <p><code class="codeph">OCITransCommit()</code></p>
                              </li>
                              <li>
                                 <p><code class="codeph">OCITransRollback()</code></p>
                              </li>
                           </ul>
                        </div>
                     </div>
                  </div>
                  <div class="props_rev_3"><a id="GUID-8B38BDC1-A606-4893-A18F-CF1712DE29B2" name="GUID-8B38BDC1-A606-4893-A18F-CF1712DE29B2"></a><h5 id="LNOCI-GUID-8B38BDC1-A606-4893-A18F-CF1712DE29B2" class="sect5"><span class="enumeration_section">12.5.6.2 </span>Application Continuity in OCI Does Not Support These Constructs
                     </h5>
                     <div>
                        <p>What constructs are not supported by Application Continuity in OCI.</p>
                        <p>Application Continuity in OCI does not support the following constructs:</p>
                        <ul style="list-style-type: disc;">
                           <li>
                              <p>XA Transactions </p>
                           </li>
                           <li>
                              <p>PL/SQL blocks with embedded <code class="codeph">COMMIT</code> statements
                              </p>
                           </li>
                           <li>
                              <p>AQ Dequeue in dequeue immediate mode (deqopt.visibility)</p>
                           </li>
                           <li>
                              <p>Streaming binds or defines of descriptor-based types such as objects or lob locators</p>
                           </li>
                           <li>
                              <p>Function <code class="codeph">OCIStmtPrepare()</code></p>
                           </li>
                           <li>
                              <p>Registered OCI callbacks of type <code class="codeph">OCI_CBTYPE_ENTRY</code> that do not return <code class="codeph">OCI_CONTINUE</code></p>
                           </li>
                           <li>
                              <p><code class="codeph">COMMIT NOWAIT</code> statement
                              </p>
                           </li>
                           <li>
                              <p>DCL commands</p>
                           </li>
                        </ul>
                     </div>
                  </div>
                  <div class="props_rev_3"><a id="GUID-B54C508E-60E7-4053-BD7F-95272F8EDE35" name="GUID-B54C508E-60E7-4053-BD7F-95272F8EDE35"></a><h5 id="LNOCI-GUID-B54C508E-60E7-4053-BD7F-95272F8EDE35" class="sect5"><span class="enumeration_section">12.5.6.3 </span>Possible Side Effects of Application Continuity
                     </h5>
                     <div>
                        <p>Application Continuity in OCI replays the original PL/SQL and SQL statements following a recoverable error once a session is rebuilt and the database state is restored. The replay leaves side-effects that are seen twice, which may or may not be desirable.</p>
                        <p>It is important that applications understand these side-effects and decide whether duplicate execution is acceptable. If it is not acceptable, then the application must take action to accommodate or mitigate the effects of replay. For example, by calling <code class="codeph">OCIRequestDisableReplay()</code>.
                        </p>
                        <div class="infoboxnotealso" id="GUID-B54C508E-60E7-4053-BD7F-95272F8EDE35__GUID-74A846EB-F08C-48A9-9B33-7F917E67CB00">
                           <p class="notep1">See Also:</p>
                           <p><a href="../racad/ensuring-application-continuity.html#RACAD-GUID-A250F3F8-D681-4F44-8969-7A8434E065DD" target="_blank"><span><cite>Oracle Real Application Clusters Administration and Deployment Guide</cite></span></a> for more information about examples of actions that create side effects.
                           </p>
                        </div>
                     </div>
                  </div>
               </div>
            </div>
         </div>
      </article>
   </body>
</html>