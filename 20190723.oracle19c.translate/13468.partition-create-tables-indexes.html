<html lang="en-us" dir="ltr" xml:lang="en-us">
   <head>
      <meta http-equiv="Content-Type" content="text/html; charset=utf-8"></meta>
      <meta name="viewport" content="width=device-width, initial-scale=1"></meta>
      <meta http-equiv="X-UA-Compatible" content="IE=edge"></meta>
      <meta name="abstract" content="Creating a partitioned table or index is very similar to creating a nonpartitioned table or index."></meta>
      <meta name="description" content="Creating a partitioned table or index is very similar to creating a nonpartitioned table or index."></meta>
      <title>创建表和索引时指定分区</title>
      <meta property="og:site_name" content="Oracle Help Center"></meta>
      <meta property="og:title" content="VLDB and Partitioning Guide"></meta>
      <meta property="og:description" content="Creating a partitioned table or index is very similar to creating a nonpartitioned table or index."></meta>
      <link rel="stylesheet" href="/sp_common/book-template/ohc-book-template/css/book.css"></link>
      <link rel="shortcut icon" href="/sp_common/book-template/ohc-common/img/favicon.ico"></link>
      <meta name="application-name" content="VLDB and Partitioning Guide"></meta>
      <meta name="generator" content="DITA Open Toolkit version 1.8.5 (Mode = doc)"></meta>
      <meta name="plugin" content="SP_docbuilder HTML plugin release 18.2.2"></meta>
      <link rel="alternate" href="vldb-and-partitioning-guide.pdf" title="PDF File" type="application/pdf"></link>
      <meta name="robots" content="all"></meta>
      <link rel="schema.dcterms" href="http://purl.org/dc/terms/"></link>
      <meta name="dcterms.created" content="2019-04-23T18:05:22-07:00"></meta>
      <meta name="dcterms.title" content="VLDB and Partitioning Guide"></meta>
      <meta name="dcterms.dateCopyrighted" content="2008, 2019"></meta>
      <meta name="dcterms.category" content="database"></meta>
      <meta name="dcterms.identifier" content="E96199-03"></meta>
      
      <meta name="dcterms.product" content="en/database/oracle/oracle-database/19"></meta>
      
      <link rel="prev" href="partition-admin.html" title="Previous" type="text/html"></link>
      <link rel="next" href="create-composite-partition-table.html" title="Next" type="text/html"></link>
      <script>
        document.write('<style type="text/css">');
        document.write('body > .noscript, body > .noscript ~ * { visibility: hidden; }');
        document.write('</style>');
     </script>
      <script src="/sp_common/book-template/requirejs/require.js" data-main="/sp_common/book-template/ohc-book-template/js/book-config"></script>
      <script>
            if (window.require === undefined) {
                document.write('<script data-main="sp_common/book-template/ohc-book-template/js/book-config" src="sp_common/book-template/requirejs/require.js"><\/script>');
                document.write('<link href="sp_common/book-template/ohc-book-template/css/book.css" rel="stylesheet"/>');
            }
        </script>
      <script type="application/json" id="ssot-metadata">{"primary":{"category":{"short_name":"database","element_name":"Database","display_in_url":true},"suite":{"short_name":"oracle","element_name":"Oracle","display_in_url":true},"product_group":{"short_name":"not-applicable","element_name":"Not applicable","display_in_url":false},"product":{"short_name":"oracle-database","element_name":"Oracle Database","display_in_url":true},"release":{"short_name":"19","element_name":"Release 19","display_in_url":true}}}</script>
      
    <meta name="dcterms.isVersionOf" content="VLDBG"></meta>
    <meta name="dcterms.release" content="Release 19"></meta>
  </head>
   <body dir="ltr">
      <div class="noscript alert alert-danger text-center" role="alert">
         <a href="partition-admin.html" class="pull-left"><span class="glyphicon glyphicon-chevron-left" aria-hidden="true"></span>上一页</a> <a href="create-composite-partition-table.html" class="pull-right">下一页<span class="glyphicon glyphicon-chevron-right" aria-hidden="true"></span></a> <span class="fa fa-exclamation-triangle" aria-hidden="true"></span>必须启用JavaScript才能正确显示此内容</div>
      <article>
         <header>
            <ol class="breadcrumb" vocab="http://schema.org/" typeof="BreadcrumbList">
               <li property="itemListElement" typeof="ListItem"><a href="index.html" property="item" typeof="WebPage"><span property="name">VLDB和分区指南</span></a></li>
               <li property="itemListElement" typeof="ListItem"><a href="partition-admin.html" property="item" typeof="WebPage"><span property="name">分区管理</span></a></li>
               <li class="active" property="itemListElement" typeof="ListItem">创建表和索引时指定分区</li>
            </ol>
            <a id="GUID-0CAB4231-E7DB-4245-9C43-C9CA352EC298" name="GUID-0CAB4231-E7DB-4245-9C43-C9CA352EC298"></a><a id="VLDBG1084"></a>
            
            <h2 id="VLDBG-GUID-0CAB4231-E7DB-4245-9C43-C9CA352EC298" class="sect2">创建表和索引时指定分区</h2>
         </header>
         <div class="ind">
            <div>
               <p>创建分区表或索引与创建非分区表或索引非常相似。</p>
               <p>创建分区表或索引时，在<code class="codeph">CREATE TABLE</code>语句中包含分区子句。您包含的分区子句和子条款取决于您要实现的分区类型。
               </p>
               <p>可以在常规（堆组织）表和索引组织表上进行分区，但包含<code class="codeph">LONG</code>或<code class="codeph">LONG RAW</code>列的表除外。您可以在分区表上创建非分区全局索引，范围或散列分区全局索引以及本地索引。
               </p>
               <p>创建（或更改）分区表时，可以指定行移动子句（ <code class="codeph">ENABLE ROW MOVEMENT</code>或<code class="codeph">DISABLE ROW MOVEMENT</code> ）。如果更新了密钥，则此子句可以启用或禁用将行迁移到新分区。默认为<code class="codeph">DISABLE ROW MOVEMENT</code> 。</p>
               <p>对于单级分区表或复合分区表的子分区，最多可以指定1024K-1个分区。</p>
               <p>创建自动列表复合分区表和间隔子分区可以节省空间，因为这些方法仅在存在数据时创建子分区。在按需创建新分区时延迟创建子分区可确保仅在插入第一个匹配行时创建子分区段。</p>
               <p>以下主题提供了为各种类型的分区表和索引创建分区的详细信息和示例：</p>
               <ul style="list-style-type:disc">
                  <li>
                     <p><a href="partition-create-tables-indexes.html#GUID-9FCAFF8C-0AA9-49F1-A7B8-7611C8AF56DD" title="CREATE TABLE语句的PARTITION BY RANGE子句指定要对表或索引进行范围分区。">关于创建范围分区表和全局索引</a></p>
                  </li>
                  <li>
                     <p><a href="partition-create-tables-indexes.html#GUID-F83CB777-F92C-43AB-A20D-EB2BCC82C32C" title="CREATE TABLE语句的INTERVAL子句为表建立间隔分区。">创建范围 - 间隔 - 分区表</a></p>
                  </li>
                  <li>
                     <p><a href="partition-create-tables-indexes.html#GUID-BF3F38E1-62BB-4EE3-86C1-A2EF8A258B1F" title="CREATE TABLE语句的PARTITION BY HASH子句标识该表是要进行散列分区的。">关于创建哈希分区表和全局索引</a></p>
                  </li>
                  <li>
                     <p><a href="partition-create-tables-indexes.html#GUID-17243D8E-03EA-44E7-AC0B-6525F14C784A" title="创建列表分区的语义与创建范围分区的语义非常相似。">关于创建列表分区表</a></p>
                  </li>
                  <li>
                     <p><a href="partition-create-tables-indexes.html#GUID-00923EB3-05F6-41F7-8437-E42FC9BD9571" title="要创建引用分区表，请在CREATE TABLE语句中指定PARTITION BY REFERENCE子句。">创建参考分区表</a></p>
                  </li>
                  <li>
                     <p><a href="partition-create-tables-indexes.html#GUID-52397EF9-EC3B-4E80-8211-77E683263530" title="您可以将间隔分区表用作父表以进行引用分区。将记录插入引用分区表时，将创建与父表中的间隔分区对应的引用分区表中的分区。">创建间隔引用分区表</a></p>
                  </li>
                  <li>
                     <p><a href="partition-create-tables-indexes.html#GUID-01B3A14E-BC74-49D2-B719-B2D8B7692C97" title="您可以使用带有INMEMORY子句的内存中列存储创建分区表。">使用具有分区的内存中列存储创建表</a></p>
                  </li>
                  <li>
                     <p><a href="partition-create-tables-indexes.html#GUID-9D7149B6-A2FF-47CA-8F00-47CBFD33F82B" title="您可以将表，分区和子分区设置为只读状态，以保护数据免受任何用户或触发器的无意DML操作。">使用只读分区或子分区创建表</a></p>
                  </li>
                  <li>
                     <p><a href="partition-create-tables-indexes.html#GUID-09CFA3CD-66B7-4CDF-A086-6958D113BDD1" title="您可以为外部表创建分区。">创建分区外部表</a></p>
                  </li>
                  <li>
                     <p><a href="partition-create-tables-indexes.html#GUID-5C34BF3F-B728-47C7-B656-AE4FA9FFE2C3" title="对于范围分区和散列分区表，最多可以指定16个分区键列。">指定键列上的分区</a></p>
                  </li>
                  <li>
                     <p><a href="partition-create-tables-indexes.html#GUID-AF6D08D7-5E0F-4E08-B682-74CCCAEC64D1" title="通过分区，可以将虚拟列用作任何常规列。">使用基于虚拟列的分区</a></p>
                  </li>
                  <li>
                     <p><a href="partition-create-tables-indexes.html#GUID-7D211E4B-FFFD-4146-9010-20ED1232FF2C" title="对于堆组织分区表，您可以使用表压缩来压缩部分或全部分区。">将表压缩与分区表一起使用</a></p>
                  </li>
                  <li>
                     <p><a href="partition-create-tables-indexes.html#GUID-0C13E8A8-568B-4A60-8A46-F1120D193EFE" title="您可以使用键压缩来压缩B树索引的部分或全部分区。">使用带分区索引的密钥压缩</a></p>
                  </li>
                  <li>
                     <p><a href="partition-create-tables-indexes.html#GUID-548F1C63-0948-4B6E-95F9-6DCC7F5A9F95" title="本主题介绍了使用段进行分区。">使用段指定分区</a></p>
                  </li>
                  <li>
                     <p><a href="partition-create-tables-indexes.html#GUID-46136CB9-ED71-4150-96F2-D50121F0BCF0" title="对于索引组织表，您可以使用范围，列表或散列分区方法。">创建索引组织表时指定分区</a></p>
                  </li>
                  <li>
                     <p><a href="partition-create-tables-indexes.html#GUID-24050391-B7C5-4AE2-86D4-B5438412C3F6" title="在具有不同块大小的表空间的数据库中创建分区对象时要小心。">多个块大小的分区限制</a></p>
                  </li>
                  <li>
                     <p><a href="partition-create-tables-indexes.html#GUID-7F8EBE79-9FF2-4B2D-9764-C11263FA550F" title="使用XMLType或对象表和列时的分区遵循分区的基本规则。">XMLType和对象中的集合分区</a></p>
                  </li>
               </ul>
               <div class="infoboxnotealso" id="GUID-0CAB4231-E7DB-4245-9C43-C9CA352EC298__GUID-AD219F34-4542-416E-8CF7-02076E1EC690">
                  <p class="notep1">也可以看看：</p>
                  <p></p>
                  <ul style="list-style-type:disc">
                     <li>
                        <p>有关管理表的信息，请参见<a href="../admin/managing-tables.html#ADMIN015" target="_blank"><span class="italic">“Oracle数据库管理员指南”</span></a></p>
                     </li>
                     <li>
                        <p><a href="../sqlrf/CREATE-TABLE.html#SQLRF01402" target="_blank"><span class="italic">Oracle数据库SQL语言参考</span></a> ，用于创建和更改分区表和索引的分区子句的确切语法，对其使用的任何限制以及创建和更改表所需的特定权限</p>
                     </li>
                     <li>
                        <p><a href="../adlob/LOB-storage-with-applications.html#ADLOB45309" target="_blank"><span class="italic">Oracle Database SecureFiles和Large Objects Developer's Guide，</span></a>用于创建包含具有<code class="codeph">LOB</code>或其他对象存储为<code class="codeph">LOB</code>的列的分区表的信息</p>
                     </li>
                     <li>
                        <p><a href="../adobj/advanced-topics-for-oracle-objects.html#ADOBJ006" target="_blank"><span class="italic">Oracle数据库对象关系开发人员指南</span></a> ，了解有关使用对象类型，嵌套表或VARRAY创建表的特定信息</p>
                     </li>
                  </ul>
               </div>
            </div><a id="VLDBG1085"></a><div class="props_rev_3"><a id="GUID-9FCAFF8C-0AA9-49F1-A7B8-7611C8AF56DD" name="GUID-9FCAFF8C-0AA9-49F1-A7B8-7611C8AF56DD"></a><h3 id="VLDBG-GUID-9FCAFF8C-0AA9-49F1-A7B8-7611C8AF56DD" class="sect3">关于创建范围分区表和全局索引</h3>
               <div>
                  <p><code class="codeph">CREATE TABLE</code>语句的<code class="codeph">PARTITION BY RANGE</code>子句指定要对表或索引进行范围分区。
                  </p>
                  <p><code class="codeph">PARTITION</code>子句标识各个分区范围， <code class="codeph">PARTITION</code>子句的可选子条款可以指定特定于分区段的物理属性和其他属性。如果未在分区级别覆盖，则分区将继承其基础表的属性。
                  </p>
                  <p>讨论了以下主题：</p>
                  <ul style="list-style-type:disc">
                     <li>
                        <p><a href="partition-create-tables-indexes.html#GUID-F0BCECA4-A485-4DA2-863A-6DB7C064059C" title="使用CREATE TABLE语句的PARTITION BY RANGE子句创建范围分区表。">创建范围分区表</a></p>
                     </li>
                     <li>
                        <p><a href="partition-create-tables-indexes.html#GUID-66D19C36-C512-48DE-88B4-AFC6CCACDFEB" title="使用属性和存储参数，可以为创建范围分区表添加更多复杂性。">创建更复杂的范围分区表</a></p>
                     </li>
                     <li>
                        <p><a href="partition-create-tables-indexes.html#GUID-4EEB5C77-4D02-430D-9AC2-10D377A06A15" title="创建范围分区全局索引的规则与创建范围分区表的规则类似。">创建范围分区的全局索引</a></p>
                     </li>
                  </ul>
               </div><a id="VLDBG14039"></a><a id="VLDBG1086"></a><div class="props_rev_3"><a id="GUID-F0BCECA4-A485-4DA2-863A-6DB7C064059C" name="GUID-F0BCECA4-A485-4DA2-863A-6DB7C064059C"></a><h4 id="VLDBG-GUID-F0BCECA4-A485-4DA2-863A-6DB7C064059C" class="sect4">创建范围分区表</h4>
                  <div>
                     <p>使用<code class="codeph">CREATE TABLE</code>语句的<code class="codeph">PARTITION BY RANGE</code>子句创建范围分区表。
                     </p>
                     <div class="section">
                        <p><a href="partition-create-tables-indexes.html#GUID-F0BCECA4-A485-4DA2-863A-6DB7C064059C__CHDJDFAF">示例4-1</a>创建了一个包含四个分区的表，每个分区用于销售的四分之一。 <code class="codeph">time_id</code>是<span class="bold">分区列</span> ，而其值构成特定行的<span class="bold">分区键</span> 。<code class="codeph">VALUES LESS THAN</code>子句确定<span class="bold">分区绑定</span> ：具有分区键值的行（其比例小于该子句指定的有序值列表）存储在分区中。每个分区都有一个名称（ <code class="codeph">sales_q1_2006</code> ， <code class="codeph">sales_q2_2006</code> ， <code class="codeph">sales_q3_2006</code> ， <code class="codeph">sales_q4_2006</code> ），每个分区都包含在一个单独的表空间（ <code class="codeph">tsa</code> ， <code class="codeph">tsb</code> ， <code class="codeph">tsc</code> ， <code class="codeph">tsd</code> ）中。具有<code class="codeph">time_id=17-MAR-2006</code>行将存储在分区<code class="codeph">sales_q1_2006</code> 。
                        </p>
                        <div class="infoboxnote" id="GUID-F0BCECA4-A485-4DA2-863A-6DB7C064059C__GUID-B00F4F06-149E-42ED-B36D-AED85F2A3575">
                           <p class="notep1">实时SQL：</p>
                           <p>在Oracle Live SQL上查看并运行Oracle Live SQL的相关示例<a href="https://livesql.oracle.com/apex/livesql/docs/vldbg/partitioning/range-partitioning-example.html" target="_blank"><span class="italic">：创建范围分区表</span></a> 。
                           </p>
                        </div>
                     </div>
                     <!-- class="section" -->
                     <div class="example" id="GUID-F0BCECA4-A485-4DA2-863A-6DB7C064059C__CHDJDFAF">
                        <p class="titleinexample">示例4-1创建范围分区表</p><pre class="oac_no_warn" dir="ltr">CREATE TABLE销售（prod_id NUMBER（6），cust_id NUMBER，time_id DATE，channel_id CHAR（1），promo_id NUMBER（6），quantity_sold NUMBER（3），amount_sold NUMBER（10,2））PARTITION BY RANGE（time_id）（PARTITION sales_q1_2006价值不到（截止日期（'01-APR-2006'，'dd-MON-yyyy'））TABLESPACE tsa，PARTITION sales_q2_2006价值不到（截止日期为（'01 -JUL-2006'，'dd-MON-yyyy'） ））TABLESPACE tsb，PARTITION sales_q3_2006价值不到（截止日期（'01 -OCT-2006'，'dd-MON-yyyy'））TABLESPACE tsc，PARTITION sales_q4_2006价值不到（截止日期（'01 -JAN-2007'，'） dd-MON-yyyy'））TABLESPACE tsd）;</pre></div>
                     <!-- class="example" -->
                  </div>
               </div><a id="VLDBG14040"></a><div class="props_rev_3"><a id="GUID-66D19C36-C512-48DE-88B4-AFC6CCACDFEB" name="GUID-66D19C36-C512-48DE-88B4-AFC6CCACDFEB"></a><h4 id="VLDBG-GUID-66D19C36-C512-48DE-88B4-AFC6CCACDFEB" class="sect4">创建更复杂的范围分区表</h4>
                  <div>
                     <p>使用属性和存储参数，可以为创建范围分区表添加更多复杂性。</p>
                     <div class="section">
                        <p>在<a href="partition-create-tables-indexes.html#GUID-66D19C36-C512-48DE-88B4-AFC6CCACDFEB__CHDCEIJJ">示例4-2中</a> ，在表级指定了存储参数和<code class="codeph">LOGGING</code>属性。这些替换了表自身从表空间级别继承的相应默认值，并由范围分区继承。但是，由于第一季度的业务很少，因此分区<code class="codeph">sales_q1_2006</code>的存储属性<code class="codeph">sales_q1_2006</code>小。指定<code class="codeph">ENABLE ROW MOVEMENT</code>子句以允许在对键值进行更新时将行自动迁移到新分区，从而将行放在不同的分区中。
                        </p>
                     </div>
                     <!-- class="section" -->
                     <div class="example" id="GUID-66D19C36-C512-48DE-88B4-AFC6CCACDFEB__CHDCEIJJ">
                        <p class="titleinexample">示例4-2使用LOGGING和ENABLE ROW MOVEMENT创建范围分区表</p><pre class="oac_no_warn" dir="ltr">CREATE TABLE销售（prod_id NUMBER（6），cust_id NUMBER，time_id DATE，channel_id CHAR（1），promo_id NUMBER（6），quantity_sold NUMBER（3），amount_sold NUMBER（10,2））存储（初始100K下一个50K）记录按范围划分（time_id）（PARTITION sales_q1_2006值不到（截止日期（'01-APR-2006'，'dd-MON-yyyy'））TABLESPACE tsa存储（初始20K，下一个10K），PARTITION sales_q2_2006价值低于（截至7月） '01 -JUL-2006'，'dd-MON-yyyy'））TABLESPACE tsb，PARTITION sales_q3_2006价值不到（截止日期（'01 -OCT-2006'，'dd-MON-yyyy'））TABLESPACE tsc，PARTITION sales_q4_2006价值不到（截止日期（'01 -JAN-2007'，'dd-MON-yyyy'））TABLESPACE tsd）启用行动;</pre></div>
                     <!-- class="example" -->
                  </div>
               </div><a id="VLDBG14041"></a><a id="VLDBG1087"></a><div class="props_rev_3"><a id="GUID-4EEB5C77-4D02-430D-9AC2-10D377A06A15" name="GUID-4EEB5C77-4D02-430D-9AC2-10D377A06A15"></a><h4 id="VLDBG-GUID-4EEB5C77-4D02-430D-9AC2-10D377A06A15" class="sect4">创建范围分区的全局索引</h4>
                  <div>
                     <p>创建范围分区全局索引的规则与创建范围分区表的规则类似。</p>
                     <div class="section">
                        <p><a href="partition-create-tables-indexes.html#GUID-4EEB5C77-4D02-430D-9AC2-10D377A06A15__CHDHGFAG">示例4-3</a>在<code class="codeph">sale_month</code>为前面示例中创建的表创建了范围分区的全局索引。每个索引分区都已命名，但存储在索引的默认表空间中。
                        </p>
                     </div>
                     <!-- class="section" -->
                     <div class="example" id="GUID-4EEB5C77-4D02-430D-9AC2-10D377A06A15__CHDHGFAG">
                        <p class="titleinexample">示例4-3创建范围分区的全局索引表</p><pre class="oac_no_warn" dir="ltr">CREATE INDEX amount_sold_ix ON sales（amount_sold）GLOBAL PARTITION BY RANGE（sale_month）（PARTITION p_100值小于（100），PARTITION p_1000值小于（1000），PARTITION p_10000值小于（10000），分区p_100000值小于（100） ），PARTITION p_1000000值小于（1000000），PARTITION p_greater_than_1000000值小于（maxvalue））;</pre><div class="infoboxnote" id="GUID-4EEB5C77-4D02-430D-9AC2-10D377A06A15__GUID-E6F43B9E-0D69-4CCF-913A-74A5C4F7067F">
                           <p class="notep1">注意：</p>
                           <p>如果您的企业具有使用不同字符集的数据库，则在对字符列进行分区时要小心，因为字符的排序顺序在所有字符集中都不相同。有关更多信息，请参阅“ <a href="../nlspg/overview-of-globalization-support.html#NLSPG001" target="_blank"><span><cite>Oracle数据库全球化支持指南”</cite></span></a></p>
                        </div>
                     </div>
                     <!-- class="example" -->
                  </div>
               </div>
            </div><a id="VLDBG14042"></a><a id="VLDBG1088"></a><div class="props_rev_3"><a id="GUID-F83CB777-F92C-43AB-A20D-EB2BCC82C32C" name="GUID-F83CB777-F92C-43AB-A20D-EB2BCC82C32C"></a><h3 id="VLDBG-GUID-F83CB777-F92C-43AB-A20D-EB2BCC82C32C" class="sect3">创建范围 - 间隔 - 分区表</h3>
               <div>
                  <p><code class="codeph">CREATE TABLE</code>语句的<code class="codeph">INTERVAL</code>子句为<code class="codeph">CREATE TABLE</code>建立间隔分区。
                  </p>
                  <div class="section">
                     <p>您必须使用<code class="codeph">PARTITION</code>子句指定至少一个范围分区。范围分区键值确定范围分区的高值（称为转换点），数据库自动为该转换点之外的数据创建间隔分区。每个间隔分区的下边界是前一个范围或间隔分区的非包含上边界。
                     </p>
                     <p>例如，如果创建具有月间隔的间隔分区表且转换点位于2010年1月1日，则2010年1月间隔的下边界为2010年1月1日。无论2010年6月的分区是否先前创建，2010年7月间隔的下限是2010年7月1日。但请注意，使用分区的上限或下限超出为存储设置的范围的日期会导致错误。例如， <code class="codeph">TO_DATE('9999-12-01', 'YYYY-MM-DD')</code>导致上限为10000-01-01，如果10000超出合法范围，则不能存储。
                     </p>
                     <p>可选的<code class="codeph">STORE IN</code>子句允许您指定一个或多个表空间，数据库使用循环算法为随后创建的间隔分区将间隔分区数据存储到该表空间中。
                     </p>
                     <p>对于间隔分区，您只能指定一个分区键列，并且数据类型是受限制的。</p>
                     <p>以下示例指定具有不同间隔宽度的四个分区。它还指定在2010年1月1日的转换点之上，创建间隔宽度为一个月的分区。分区<code class="codeph">p3</code>上限表示转变点。 <code class="codeph">p3</code>及其下面的所有分区（本例中为<code class="codeph">p0</code> ， <code class="codeph">p1</code>和<code class="codeph">p2</code> ）都在范围部分，而它上面的所有分区都属于区间部分。
                     </p><pre class="oac_no_warn" dir="ltr">CREATE TABLE interval_sales（prod_id NUMBER（6），cust_id NUMBER，time_id DATE，channel_id CHAR（1），promo_id NUMBER（6），quantity_sold NUMBER（3），amount_sold NUMBER（10,2））PARTITION BY RANGE（time_id）INTERVAL（ NUMTOYMINTERVAL（1，'月'））（分区p0值不到（截止日期为（'1-1-2008'，'DD-MM-YYYY'）），分区p1值不到（截止到7月1日） '，'DD-MM-YYYY'）），PARTITION p2值不到（7月7日（'1-7-2009'，'DD-MM-YYYY'）），分区p3值不到（7月1日（'1-1） -2010'，'DD-MM-YYYY'）））;</pre></div>
                  <!-- class="section" -->
                  <div class="section">
                     <div class="infoboxnotealso" id="GUID-F83CB777-F92C-43AB-A20D-EB2BCC82C32C__REFERTOORACLEDATABASESQLLANGUAGEREF-517317B9">
                        <p class="notep1">也可以看看：</p>
                        <p><a href="../sqlrf/CREATE-TABLE.html#SQLRF01402" target="_blank"><span><cite>Oracle数据库SQL语言参考，</cite></span></a>用于限制分区键，创建和更改分区表和索引的分区子句的确切语法，对其使用的任何限制以及创建和更改表所需的特定权限。
                        </p>
                     </div>
                  </div>
                  <!-- class="section" -->
               </div>
            </div><a id="VLDBG1089"></a><div class="props_rev_3"><a id="GUID-BF3F38E1-62BB-4EE3-86C1-A2EF8A258B1F" name="GUID-BF3F38E1-62BB-4EE3-86C1-A2EF8A258B1F"></a><h3 id="VLDBG-GUID-BF3F38E1-62BB-4EE3-86C1-A2EF8A258B1F" class="sect3">关于创建哈希分区表和全局索引</h3>
               <div>
                  <p><code class="codeph">CREATE TABLE</code>语句的<code class="codeph">PARTITION BY HASH</code>子句标识该表是要进行散列分区的。
                  </p>
                  <p>然后可以使用<code class="codeph">PARTITIONS</code>子句指定要创建的分区数，也可以选择指定要存储它们的表空间。或者，您可以使用<code class="codeph">PARTITION</code>子句来命名各个分区及其表空间。
                  </p>
                  <p>您可以为散列分区指定的唯一属性是<code class="codeph">TABLESPACE</code> 。表的所有散列分区必须共享相同的段属性（ <code class="codeph">TABLESPACE</code>除外），这些属性是从表级继承的。
                  </p>
                  <p>讨论了以下主题：</p>
                  <ul style="list-style-type:disc">
                     <li>
                        <p><a href="partition-create-tables-indexes.html#GUID-04E6C6EF-CE27-4DE9-B5B1-D23010E4A356" title="本主题中的示例显示如何创建散列分区表。">创建哈希分区表</a></p>
                     </li>
                     <li>
                        <p><a href="partition-create-tables-indexes.html#GUID-A8991A7A-CEC0-4C6D-A886-17E0554BB3C6" title="散列分区全局索引可以提高索引的性能，其中索引中的少量叶块在多用户OLTP环境中具有高争用。">创建哈希分区全局索引</a></p>
                     </li>
                  </ul>
               </div><a id="VLDBG1090"></a><div class="props_rev_3"><a id="GUID-04E6C6EF-CE27-4DE9-B5B1-D23010E4A356" name="GUID-04E6C6EF-CE27-4DE9-B5B1-D23010E4A356"></a><h4 id="VLDBG-GUID-04E6C6EF-CE27-4DE9-B5B1-D23010E4A356" class="sect4">创建哈希分区表</h4>
                  <div>
                     <p>本主题中的示例显示如何创建散列分区表。</p>
                     <div class="section">
                        <p>分区列是<code class="codeph">id</code> ，创建四个分区和分配的系统生成的名称，并且它们被放置在4个命名表空间（ <code class="codeph">gear1</code> ， <code class="codeph">gear2</code> ， <code class="codeph">gear3</code> ， <code class="codeph">gear4</code> ）。
                        </p><pre class="oac_no_warn" dir="ltr">CREATE TABLE scubagear（id NUMBER，名称VARCHAR2（60））PARTITION BY HASH（id）PARTITIONS 4 STORE IN（gear1，gear2，gear3，gear4）;</pre><p>在以下示例中，在创建散列分区表时指定了分区数，但是为它们分配了系统生成的名称，并将它们存储在表的缺省表空间中。</p><pre class="oac_no_warn" dir="ltr">CREATE TABLE departments_hash（department_id NUMBER（4）NOT NULL，department_name VARCHAR2（30））PARTITION BY HASH（department_id）PARTITIONS 16;</pre><p>在以下示例中，指定了各个分区的名称以及它们将驻留的表空间。每个散列分区（段）的初始扩展区大小也在表级明确声明，并且所有分区都继承此属性。</p><pre class="oac_no_warn" dir="ltr">CREATE TABLE departments_hash（department_id NUMBER（4）NOT NULL，department_name VARCHAR2（30））STASHAGE（INTITIAL 10K）HASH分区（department_id）（PARTITION p1 TABLESPACE ts1，PARTITION p2 TABLESPACE ts2，PARTITION p3 TABLESPACE ts1，PARTITION p4 TABLESPACE ts3） ;</pre><p>如果为此表创建本地索引，则数据库将构造索引，以使其与基础表进行均分配置。数据库还确保在对基础表执行维护操作时自动维护索引。以下是在表上创建本地索引的示例：</p><pre class="oac_no_warn" dir="ltr">CREATE INDEX loc_dept_ix ON departments_hash（department_id）LOCAL;</pre><p>您可以选择命名要存储本地索引分区的哈希分区和表空间，但如果不这样做，则数据库使用相应基本分区的名称作为索引分区名称，并存储索引分区在与表分区相同的表空间中。</p>
                        <div class="infoboxnotealso" id="GUID-04E6C6EF-CE27-4DE9-B5B1-D23010E4A356__GUID-12B53A6F-B60C-4C28-9AD9-F155A747524E">
                           <p class="notep1">也可以看看：</p>
                           <p><a href="partition-create-tables-indexes.html#GUID-5C34BF3F-B728-47C7-B656-AE4FA9FFE2C3" title="对于范围分区和散列分区表，最多可以指定16个分区键列。">在键列上指定分区以</a>获取有关键列分区的更多信息</p>
                        </div>
                     </div>
                     <!-- class="section" -->
                  </div>
               </div><a id="VLDBG14044"></a><a id="VLDBG1091"></a><div class="props_rev_3"><a id="GUID-A8991A7A-CEC0-4C6D-A886-17E0554BB3C6" name="GUID-A8991A7A-CEC0-4C6D-A886-17E0554BB3C6"></a><h4 id="VLDBG-GUID-A8991A7A-CEC0-4C6D-A886-17E0554BB3C6" class="sect4">创建哈希分区全局索引</h4>
                  <div>
                     <p>散列分区全局索引可以提高索引的性能，其中索引中的少量叶块在多用户OLTP环境中具有高争用。</p>
                     <div class="section">
                        <p>散列分区全局索引还可以限制索引偏斜对单调增加列值的影响。涉及索引分区键的相等性和<code class="codeph">IN</code>谓词的查询可以有效地使用散列分区的全局索引。
                        </p>
                        <p>创建散列分区全局索引的语法类似于用于散列分区表的语法。例如， <a href="partition-create-tables-indexes.html#GUID-A8991A7A-CEC0-4C6D-A886-17E0554BB3C6__CHDBDJGC">示例4-4中</a>的语句创建了一个散列分区的全局索引：</p>
                     </div>
                     <!-- class="section" -->
                     <div class="example" id="GUID-A8991A7A-CEC0-4C6D-A886-17E0554BB3C6__CHDBDJGC">
                        <p class="titleinexample">示例4-4创建散列分区全局索引</p><pre class="oac_no_warn" dir="ltr">CREATE INDEX hgidx ON tab（c1，c2，c3）HASH的全局分区（c1，c2）（PARPTION p1 TABLESPACE tbs_1，PARTITION p2 TABLESPACE tbs_2，PARTITION p3 TABLESPACE tbs_3，PARTITION p4 TABLESPACE tbs_4）;</pre></div>
                     <!-- class="example" -->
                  </div>
               </div>
            </div><a id="VLDBG1092"></a><div class="props_rev_3"><a id="GUID-17243D8E-03EA-44E7-AC0B-6525F14C784A" name="GUID-17243D8E-03EA-44E7-AC0B-6525F14C784A"></a><h3 id="VLDBG-GUID-17243D8E-03EA-44E7-AC0B-6525F14C784A" class="sect3">关于创建列表分区表</h3>
               <div>
                  <p>创建列表分区的语义与创建范围分区的语义非常相似。</p>
                  <p>但是，要创建列表分区，请在<code class="codeph">CREATE TABLE</code>语句中指定<code class="codeph">PARTITION BY LIST</code>子句， <code class="codeph">PARTITION</code>子句指定文字值列表，这些列值是限定要包含在分区中的行的分区列的离散值。对于列表分区，分区键可以是表中的一个或多个列名。
                  </p>
                  <p>只有列表分区可用，您可以使用关键字<code class="codeph">DEFAULT</code>来描述分区的值列表。这标识了一个分区，该分区适应不映射到任何其他分区的行。
                  </p>
                  <p>与范围分区一样， <code class="codeph">PARTITION</code>子句的可选子条款可以指定特定于分区段的物理属性和其他属性。如果未在分区级别覆盖，则分区将继承其父表的属性。
                  </p>
                  <p>讨论了以下主题：</p>
                  <ul style="list-style-type:disc">
                     <li>
                        <p><a href="partition-create-tables-indexes.html#GUID-D3E92FD8-5FE4-4CEA-9CB8-CC9277A74429" title="本主题中的示例显示如何创建列表分区表。">创建列表分区表</a></p>
                     </li>
                     <li>
                        <p><a href="partition-create-tables-indexes.html#GUID-8928C3B0-2F83-4213-B765-EFBBF0372F64" title="与范围分区不同，使用列表分区，分区之间没有明显的顺序感。">使用默认分区创建列表分区表</a></p>
                     </li>
                     <li>
                        <p><a href="partition-create-tables-indexes.html#GUID-12150FFB-48E4-4169-9EBE-64974C1CEF2A" title="自动列表分区方法允许按需创建列表分区。">创建自动列表分区表</a></p>
                     </li>
                     <li>
                        <p><a href="partition-create-tables-indexes.html#GUID-6A4131B1-BBDF-4230-B88C-80BC91A0C861" title="通过多列列表分区，您可以根据多列的列表值对表进行分区。">创建多列列表分区表</a></p>
                     </li>
                  </ul>
               </div><a id="VLDBG14045"></a><div class="props_rev_3"><a id="GUID-D3E92FD8-5FE4-4CEA-9CB8-CC9277A74429" name="GUID-D3E92FD8-5FE4-4CEA-9CB8-CC9277A74429"></a><h4 id="VLDBG-GUID-D3E92FD8-5FE4-4CEA-9CB8-CC9277A74429" class="sect4">创建列表分区表</h4>
                  <div>
                     <p>本主题中的示例显示如何创建列表分区表。</p>
                     <div class="section">
                        <p><a href="partition-create-tables-indexes.html#GUID-D3E92FD8-5FE4-4CEA-9CB8-CC9277A74429__CHDDEBEB">例4-5</a>创建了表<code class="codeph">q1_sales_by_region</code> ，该表由包含US状态组的区域划分。通过检查行的分区列的值是否与描述该分区的值列表中的值匹配，将行映射到分区。例如，以下列表描述了如何将一些示例行插入表中。
                        </p>
                     </div>
                     <!-- class="section" -->
                     <div class="section">
                        <ul style="list-style-type:disc">
                           <li>
                              <p>（10，'accounting'，100，'WA'）映射到分区<code class="codeph">q1_northwest</code></p>
                           </li>
                           <li>
                              <p>（20，'R＆D'，150，'或'）映射到分区<code class="codeph">q1_northwest</code></p>
                           </li>
                           <li>
                              <p>（30，'sales'，100，'FL'）映射到分区<code class="codeph">q1_southeast</code></p>
                           </li>
                           <li>
                              <p>（40，'HR'，10，'TX'）映射到分区<code class="codeph">q1_southwest</code></p>
                           </li>
                           <li>
                              <p>（50，'systems engineering'，10，'CA'）不映射到表中的任何分区并引发错误</p>
                           </li>
                        </ul>
                        <div class="infoboxnote" id="GUID-D3E92FD8-5FE4-4CEA-9CB8-CC9277A74429__VIEWANDRUNARELATEDEXAMPLEONORACLELI-2CE1B406">
                           <p class="notep1">实时SQL：</p>
                           <p>在Oracle Live SQL上查看和运行Oracle Live SQL的相关示例<a href="https://livesql.oracle.com/apex/livesql/docs/vldbg/partitioning/list-partitioning-example.html" target="_blank"><span class="italic">：创建列表分区表</span></a> 。
                           </p>
                        </div>
                     </div>
                     <!-- class="section" -->
                     <div class="example" id="GUID-D3E92FD8-5FE4-4CEA-9CB8-CC9277A74429__CHDDEBEB">
                        <p class="titleinexample">示例4-5创建列表分区表</p><pre class="oac_no_warn" dir="ltr">CREATE TABLE q1_sales_by_region（deptno number，deptname varchar2（20），quarterly_sales number（10,2），state varchar2（2））PARTITION BY LIST（state）（PARTITION q1_northwest VALUES（'OR'，'WA'），PARTITION q1_southwest VALUES （'AZ'，'UT'，'NM'），PARTITION q1_northeast VALUES（'NY'，'VM'，'NJ'），PARTITION q1_southeast VALUES（'FL'，'GA'），PARTITION q1_northcentral VALUES（'SD '，'WI'），PARTITION q1_southcentral VALUES（'OK'，'TX'））;</pre></div>
                     <!-- class="example" -->
                  </div>
               </div><a id="VLDBG14046"></a><div class="props_rev_3"><a id="GUID-8928C3B0-2F83-4213-B765-EFBBF0372F64" name="GUID-8928C3B0-2F83-4213-B765-EFBBF0372F64"></a><h4 id="VLDBG-GUID-8928C3B0-2F83-4213-B765-EFBBF0372F64" class="sect4">使用默认分区创建列表分区表</h4>
                  <div>
                     <p>与范围分区不同，使用列表分区，分区之间没有明显的顺序感。</p>
                     <div class="section">
                        <p>您还可以指定一个<span class="bold">默认分区</span> ，将未映射到任何其他分区的行映射到该分区。如果在前面的示例中指定了默认分区，则状态CA将映射到该分区。
                        </p>
                        <p><a href="partition-create-tables-indexes.html#GUID-8928C3B0-2F83-4213-B765-EFBBF0372F64__CHDDDCFI">示例4-6</a>创建表<code class="codeph">sales_by_region</code>并使用list方法对其进行分区。前两个<code class="codeph">PARTITION</code>子句指定物理属性，它们覆盖表级默认值。其余的<code class="codeph">PARTITION</code>子句不指定属性，这些分区从表级默认值继承其物理属性。还指定了默认分区。
                        </p>
                     </div>
                     <!-- class="section" -->
                     <div class="example" id="GUID-8928C3B0-2F83-4213-B765-EFBBF0372F64__CHDDDCFI">
                        <p class="titleinexample">示例4-6使用默认分区创建列表分区表</p><pre class="oac_no_warn" dir="ltr">CREATE TABLE sales_by_region（项目＃INTEGER，qty INTEGER，store_name VARCHAR（30），state_code VARCHAR（2），sale_date DATE）存储（初始10K下一个20K）TABLESPACE tbs5按列表分区（state_code）（PARTITION region_east VALUES（'MA'， 'NY'，'CT'，'NH'，'ME'，'MD'，'VA'，'PA'，'NJ'）存储（初始8M）TABLESPACE tbs8，PARTITION region_west VALUES（'CA'，'AZ '，'NM'，'OR'，'WA'，'UT'，'NV'，'CO'）NOLOGGING，PARTITION region_south VALUES（'TX'，'KY'，'TN'，'LA'，'MS '，'AR'，'AL'，'GA'），PARTITION region_central VALUES（'OH'，'ND'，'SD'，'MO'，'IL'，'MI'，'IA'），PARTITION region_null VALUES（NULL），PARTITION region_unknown VALUES（DEFAULT））;</pre></div>
                     <!-- class="example" -->
                  </div>
               </div>
               <div class="sect3"><a id="GUID-12150FFB-48E4-4169-9EBE-64974C1CEF2A" name="GUID-12150FFB-48E4-4169-9EBE-64974C1CEF2A"></a><h4 id="VLDBG-GUID-12150FFB-48E4-4169-9EBE-64974C1CEF2A" class="sect4">创建自动列表分区表</h4>
                  <div>
                     <p>自动列表分区方法允许按需创建列表分区。</p>
                     <p>自动列表分区表类似于常规列表分区表，但该分区表更易于管理。您可以仅使用已知的分区键值创建自动列表分区表。当数据加载到表中时，如果加载的分区键值与任何现有分区不对应，则数据库会自动创建新分区。由于分区是按需自动创建的，因此自动列表分区方法在概念上与现有的间隔分区方法类似。</p>
                     <p>除非您可以调整数据，否则对值非常频繁更改的数据类型的自动列表分区不太适合此方法。例如，当格式未被剥离时，具有日期值的<code class="codeph">SALES_DATE</code>字段将每秒增加。每个<code class="codeph">SALES_DATE</code>值，例如<code class="codeph">05-22-2016 08:00:00</code> <code class="codeph">05-22-2016 08:00:01</code>等，都会生成自己的分区。为避免创建大量分区，您必须了解要输入的数据并进行相应调整。例如，您可以将<code class="codeph">SALES_DATE</code>日期值截断为一天或某个其他时间段，具体取决于所需的分区数。
                     </p>
                     <p><code class="codeph">CREATE</code>和<code class="codeph">ALTER</code> <code class="codeph">TABLE</code> SQL语句使用附加子句进行更新，以指定<code class="codeph">AUTOMATIC</code>或<code class="codeph">MANUAL</code>列表分区。自动列表分区表在创建时必须至少有一个分区。由于为新的和未知的分区键值自动创建了新分区，因此自动列表分区不能具有<code class="codeph">DEFAULT</code>分区。
                     </p>
                     <p>您可以检查<code class="codeph">*_PART_TABLES</code>视图的<code class="codeph">AUTOLIST</code>列以确定表是否是自动列表分区的。
                     </p>
                     <div class="infoboxnote" id="GUID-12150FFB-48E4-4169-9EBE-64974C1CEF2A__GUID-B828C1EE-AE53-46B8-BDD4-408F90C7D893">
                        <p class="notep1">实时SQL：</p>
                        <p>在Oracle Live SQL上查看并运行Oracle Live SQL的相关示例<a href="https://livesql.oracle.com/apex/livesql/docs/vldbg/partitioning/create-auto-list-partition.html" target="_blank"><span class="italic">：创建自动列表分区表</span></a> 。
                        </p>
                     </div>
                     <p><a href="partition-create-tables-indexes.html#GUID-12150FFB-48E4-4169-9EBE-64974C1CEF2A__GUID-E760B49A-61B0-4A02-8020-6A26B8540915">示例4-7</a>是使用<code class="codeph">AUTOMATIC</code>关键字在<code class="codeph">sales_state</code>字段上进行自动列表分区的<code class="codeph">CREATE</code> <code class="codeph">TABLE</code>语句的示例。CREATE TABLE SQL语句根据需要创建至少一个分区。插入其他行时，添加新的<code class="codeph">sales_state</code>值时，分区数会增加。
                     </p>
                     <div class="example" id="GUID-12150FFB-48E4-4169-9EBE-64974C1CEF2A__GUID-E760B49A-61B0-4A02-8020-6A26B8540915">
                        <p class="titleinexample">示例4-7创建自动列表分区表</p><pre class="oac_no_warn" dir="ltr">CREATE TABLE sales_auto_list（salesman_id NUMBER（5）NOT NULL，salesman_name VARCHAR2（30），sales_state VARCHAR2（20）NOT NULL，sales_amount NUMBER（10），sales_date DATE NOT NULL）按列表分区（sales_state）AUTOMATIC（PARTITION P_CAL VALUES（'加利福尼亚州））; SELECT TABLE_NAME，PARTITIONING_TYPE，AUTOLIST，PARTITION_COUNT来自USER_PART_TABLES WHERE TABLE_NAME ='SALES_AUTO_LIST'; TABLE_NAME PARTITIONING_TYPE AUTOLIST PARTITION_COUNT ---------------- ----------------- -------- ----- ---------- SALES_AUTO_LIST列表是1 SELECT TABLE_NAME，PARTITION_NAME，HIGH_VALUE来自USER_TAB_PARTITIONS，其中TABLE_NAME ='SALES_AUTO_LIST'; TABLE_NAME PARTITION_NAME HIGH_VALUE ---------------- --------------- ---------------- SALES_AUTO_LIST P_CAL'加利福尼亚'插入SALES_AUTO_LIST VALUES（021，'Mary Smith'，'FLORIDA'，41000，TO_DATE（'21 -DEC-2018'，'DD-MON-YYYY'））;插入1行。插入SALES_AUTO_LIST VALUES（032，'Luis Vargas'，'MICHIGAN'，42000，TO_DATE（'31 -DEC-2018'，'DD-MON-YYYY'））;插入1行。SELECT TABLE_NAME，PARTITIONING_TYPE，AUTOLIST，PARTITION_COUNT来自USER_PART_TABLES WHERE TABLE_NAME ='SALES_AUTO_LIST'; TABLE_NAME PARTITIONING_TYPE AUTOLIST PARTITION_COUNT ---------------- ----------------- -------- ----- ---------- SALES_AUTO_LIST列表是3插入SALES_AUTO_LIST VALUES（015，'Simone Blair'，'CALIFORNIA'，45000，TO_DATE（'11 -JAN-2019'，'DD-MON-YYYY'） ）;插入1行。插入SALES_AUTO_LIST VALUES（015，'Simone Blair'，'OREGON'，38000，TO_DATE（'18 -JAN-2019'，'DD-MON-YYYY'））;插入1行。SELECT TABLE_NAME，PARTITIONING_TYPE，AUTOLIST，PARTITION_COUNT来自USER_PART_TABLES WHERE TABLE_NAME ='SALES_AUTO_LIST'; TABLE_NAME PARTITIONING_TYPE AUTOLIST PARTITION_COUNT ---------------- ----------------- -------- ----- ---------- SALES_AUTO_LIST列表是4 SELECT TABLE_NAME，PARTITION_NAME，HIGH_VALUE来自USER_TAB_PARTITIONS，其中TABLE_NAME ='SALES_AUTO_LIST'; TABLE_NAME PARTITION_NAME HIGH_VALUE ---------------- --------------- ---------------- SALES_AUTO_LIST P_CAL'CALIFORNIA'SALES_AUTO_LIST SYS_P478'FLORIDA'SALES_AUTO_LIST SYS_P479'MICHIGAN'SALES_AUTO_LIST SYS_P480'ORGON'</pre></div>
                     <!-- class="example" -->
                     <div class="section">
                        <div class="infoboxnotealso" id="GUID-12150FFB-48E4-4169-9EBE-64974C1CEF2A__ORACLEDATABASEREFERENCEFORINFORMATI-F796E84D">
                           <p class="notep1">也可以看看：</p>
                           <p>有关<code class="codeph">*_PART_TABLES</code>视图的信息，请<code class="codeph">*_PART_TABLES</code> <a href="../refrn/static-data-dictionary-views-4.html#REFRN-GUID-2E7FFA31-6241-474E-BA88-5EB5B8F69245" target="_blank"><span><cite>Oracle数据库参考</cite></span></a></p>
                        </div>
                     </div>
                     <!-- class="section" -->
                  </div>
               </div>
               <div class="sect3"><a id="GUID-6A4131B1-BBDF-4230-B88C-80BC91A0C861" name="GUID-6A4131B1-BBDF-4230-B88C-80BC91A0C861"></a><h4 id="VLDBG-GUID-6A4131B1-BBDF-4230-B88C-80BC91A0C861" class="sect4">创建多列列表分区表</h4>
                  <div>
                     <p>通过多列列表分区，您可以根据多列的列表值对表进行分区。</p>
                     <p>与单列列表分区类似，各个分区可以包含包含值列表的集合。</p>
                     <p>在表的多个列上使用<code class="codeph">PARTITION</code> <code class="codeph">BY</code> <code class="codeph">LIST</code>子句在表上支持多列列表分区。例如：</p><pre class="oac_no_warn" dir="ltr">PARTITION BY LIST（ <span class="italic">列1，</span> <span class="italic">列2）</span></pre><p>多列列表分区表只能有一个<code class="codeph">DEFAULT</code>分区。
                     </p>
                     <div class="infoboxnote" id="GUID-6A4131B1-BBDF-4230-B88C-80BC91A0C861__GUID-3CC99AFB-C31B-4245-877F-A0F18709C850">
                        <p class="notep1">实时SQL：</p>
                        <p>在Oracle Live SQL上查看和运行Oracle Live SQL的相关示例<a href="https://livesql.oracle.com/apex/livesql/docs/vldbg/partitioning/create-multicolumn-list.html" target="_blank"><span class="italic">：创建多列列表分区表</span></a> 。
                        </p>
                     </div>
                     <p>以下是在<code class="codeph">state</code>和<code class="codeph">channel</code>列上使用多列分区的<code class="codeph">CREATE TABLE</code>语句的示例。
                     </p>
                     <div class="example" id="GUID-6A4131B1-BBDF-4230-B88C-80BC91A0C861__GUID-60D85149-EBDE-46F5-B33F-FA65A59898C5">
                        <p class="titleinexample">示例4-8创建多列列表分区表</p><pre class="oac_no_warn" dir="ltr">CREATE TABLE sales_by_region_and_channel（dept_number NUMBER NOT NULL，dept_name VARCHAR2（20），quarterly_sales NUMBER（10,2），state VARCHAR2（2），channel VARCHAR2（1））PARTITION BY LIST（state，channel）（PARTITION annual_west_direct VALUES（（' OR'，'D'），（'UT'，'D'），（'WA'，'D'）），PARTITION annual_west_indirect VALUES（（'OR'，'I'），（'UT'，'I '），（'WA'，'I'）），PARTITION annual_south_direct VALUES（（'AZ'，'D'），（'TX'，'D'），（'GA'，'D'）），PARTITION annual_south_indirect VALUES（（'AZ'，'I'），（'TX'，'I'），（'GA'，'I'）），PARTITION annual_east_direct VALUES（（'PA'，'D'），（' NC'，'D'），（'MA'，'D'）），PARTITION annual_east_indirect VALUES（（'PA'，'I'），（'NC'，'I'），（'MA'，'I '）），PARTITION annual_north_direct VALUES（（'MN'，'D'），（'WI'，'D'），（'MI'，'D'）），PARTITION annual_north_indirect VALUES（（'MN'，'I '），（'WI'，'我'），（'MI'，'我'）），PARTITION annual_ny_direct VALUES（'NY'，'D'），PARTITION annual_ny_indirect VALUES（'NY'，'I'）， PARTITION annual_ca_direct VALUES（'CA'，'D'），PARTITION annual_ca_indirect VALUES（'CA'，'I'），PARTITION rest VA LUES（DEFAULT））; SELECT PARTITION_NAME，HIGH_VALUE来自USER_TAB_PARTITIONS，其中TABLE_NAME ='SALES_BY_REGION_AND_CHANNEL'; PARTITION_NAME HIGH_VALUE --------------------- --------------------------- ---------------- REST DEFAULT YEARLY_CA_DIRECT（'CA'，'D'）YEARLY_CA_INDIRECT（'CA'，'I'）YEARLY_EAST_DIRECT（'PA'，'D'），（ 'NC'，'D'），（'MA'，'D'）YEARLY_EAST_INDIRECT（'PA'，'I'），（'NC'，'I'），（'MA'，'I'）YEARLY_NORTH_DIRECT（ 'MN'，'D'），（'WI'，'D'），（'MI'，'D'）YEARLY_NORTH_INDIRECT（'MN'，'I'），（'WI'，'I'），（ 'MI'，'我'）YEARLY_NY_DIRECT（'NY'，'D'）YEARLY_NY_INDIRECT（'NY'，'I'）YEARLY_SOUTH_DIRECT（'AZ'，'D'），（'TX'，'D'），（ 'GA'，'D'）YEARLY_SOUTH_INDIRECT（'AZ'，'I'），（'TX'，'I'），（'GA'，'I'）YEARLY_WEST_DIRECT（'OR'，'D'），（ 'UT'，'D'），（'WA'，'D'）YEARLY_WEST_INDIRECT（'OR'，'I'），（'UT'，'I'），（'WA'，'I'）13行选择。插入SALES_BY_REGION_AND_CHANNEL VALUES（005，'AUTO DIRECT'，701000，'或'，'D'）;插入SALES_BY_REGION_AND_CHANNEL VALUES（006，'AUTO INDIRECT'，1201000，'OR'，'I'）;插入SALES_BY_REGION_AND_CHANNEL VALUES（005，'AUTO DIRECT'，625000，'WA'，'D'）;插入SALES_BY_REGION_AND_CHANNEL VALUES（006，'AUTO INDIRECT'，945000，'WA'，'I'）;插入SALES_BY_REGION_AND_CHANNEL VALUES（005，'AUTO DIRECT'，595000，'UT'，'D'）;插入SALES_BY_REGION_AND_CHANNEL VALUES（006，'AUTO INDIRECT'，825000，'UT'，'I'）;插入SALES_BY_REGION_AND_CHANNEL VALUES（003，'AUTO DIRECT'，1950000，'CA'，'D'）;插入SALES_BY_REGION_AND_CHANNEL VALUES（004，'AUTO INDIRECT'，5725000，'CA'，'I'）;插入SALES_BY_REGION_AND_CHANNEL VALUES（010，'AUTO DIRECT'，925000，'IL'，'D'）;插入SALES_BY_REGION_AND_CHANNEL VALUES（010，'AUTO INDIRECT'，3250000，'IL'，'I'）;从SALES_BY_REGION_AND_CHANNEL PARTITION（annual_west_direct）中选择DEPT_NUMBER，DEPT_NAME，QUARTERLY_SALES，STATE，CHANNEL; DEPT_NUMBER DEPT_NAME QUARTERLY_SALES ST C ----------- -------------------- -------------- -   -   -  5 AUTO DIRECT 701000或D 5 AUTO DIRECT 625000 WA D 5 AUTO DIRECT 595000 UT D SELECT DEPT_NUMBER，DEPT_NAME，QUARTERLY_SALES，STATE，CHANNEL from SALES_BY_REGION_AND_CHANNEL PARTITION（annual_west_indirect）; DEPT_NUMBER DEPT_NAME QUARTERLY_SALES ST C ----------- -------------------- -------------- -   -   -  6 AUTO INDIRECT 1201000或I 6 AUTO INDIRECT 945000 WA I 6 AUTO INDIRECT 825000 UT我从SALES_BY_REGION_AND_CHANNEL PARTITION（annual_ca_direct）中选择DEPT_NUMBER，DEPT_NAME，QUARTERLY_SALES，STATE，CHANNEL; DEPT_NUMBER DEPT_NAME QUARTERLY_SALES ST C ----------- -------------------- -------------- -   -   -  3 AUTO DIRECT 1950000 CA D SELECT DEPT_NUMBER，DEPT_NAME，QUARTERLY_SALES，STATE，CHANNEL FROM SALES_BY_REGION_AND_CHANNEL PARTITION（annual_ca_indirect）; DEPT_NUMBER DEPT_NAME QUARTERLY_SALES ST C ----------- -------------------- -------------- -   -   -  4 AUTO INDIRECT 5725000 CA我从SALES_BY_REGION_AND_CHANNEL PARTITION中选择DEPT_NUMBER，DEPT_NAME，QUARTERLY_SALES，STATE，CHANNEL（休息）; DEPT_NUMBER DEPT_NAME QUARTERLY_SALES ST C ----------- -------------------- -------------- -   -   -  10 AUTO DIRECT 925000 IL D 10 AUTO INDIRECT 3250000 IL I</pre></div>
                     <!-- class="example" -->
                  </div>
               </div>
            </div><a id="VLDBG14047"></a><a id="VLDBG1093"></a><div class="props_rev_3"><a id="GUID-00923EB3-05F6-41F7-8437-E42FC9BD9571" name="GUID-00923EB3-05F6-41F7-8437-E42FC9BD9571"></a><h3 id="VLDBG-GUID-00923EB3-05F6-41F7-8437-E42FC9BD9571" class="sect3">创建参考分区表</h3>
               <div>
                  <p>要创建引用分区表，请在<code class="codeph">CREATE TABLE</code>语句中指定<code class="codeph">PARTITION BY REFERENCE</code>子句。
                  </p>
                  <div class="section">
                     <p><code class="codeph">PARTITION BY REFERENCE</code>子句指定引用约束的名称，此约束成为分区引用约束，该约束用作表中引用分区的基础。必须启用并强制执行引用约束。
                     </p>
                     <p>与其他分区表一样，您可以指定对象级缺省属性，也可以选择指定基于每个分区覆盖对象级缺省值的分区描述符。</p>
                     <p><a href="partition-create-tables-indexes.html#GUID-00923EB3-05F6-41F7-8437-E42FC9BD9571__CHDHJCFD">例4-9</a>创建了一个在<code class="codeph">order_date</code>上进行范围分区的父表<code class="codeph">orders</code> 。使用四个分区<code class="codeph">Q1_2005</code> ， <code class="codeph">Q2_2005</code> ， <code class="codeph">Q3_2005</code>和<code class="codeph">Q4_2005</code>创建<code class="codeph">order_items</code>分区子表<code class="codeph">order_items</code> ，其中每个分区包含与相应父分区中的订单相对应的<code class="codeph">order_items</code>行。
                     </p>
                     <p>如果提供了分区描述符，则所描述的分区数必须与引用表中的分区或子分区数完全相等。如果父表是复合分区表，则该表对其父表的每个子分区都有一个分区;否则该表为其父分区的每个分区都有一个分区。</p>
                     <p>无法为引用分区表的分区指定分区边界。</p>
                     <p>可以命名引用分区表的分区。如果未明确命名分区，则它将从父表中的相应分区继承其名称，除非此继承名称与现有显式名称冲突。在这种情况下，分区具有系统生成的名称。</p>
                     <p>如果没有为引用分区表的分区指定显式表空间，则引用分区表的分区与父表的相应分区并置。</p>
                  </div>
                  <!-- class="section" -->
                  <div class="example" id="GUID-00923EB3-05F6-41F7-8437-E42FC9BD9571__CHDHJCFD">
                     <p class="titleinexample">示例4-9创建引用分区表</p><pre class="oac_no_warn" dir="ltr">CREATE TABLE订单（order_id NUMBER（12），order_date DATE，order_mode VARCHAR2（8），customer_id NUMBER（6），order_status NUMBER（2），order_total NUMBER（8,2），sales_rep_id NUMBER（6），promotion_id NUMBER（6） ，CONSTRAINT orders_pk PRIMARY KEY（order_id））PAR BY BY RANGE（order_date）（PARTITION Q1_2005价值不到（截止日期（'01-APR-2005'，'DD-MON-YYYY'）），PARTITION Q2_2005价值不到（截至4月） '01 -JUL-2005'，'DD-MON-YYYY'）），分区Q3_2005价值不到（截止日期（'01 -OCT-2005'，'DD-MON-YYYY'）），分区Q4_2005价值低于（ TO_DATE（'01 -JAN-2006'，'DD-MON-YYYY'）））; CREATE TABLE order_items（order_id NUMBER（12）NOT NULL，line_item_id NUMBER（3）NOT NULL，product_id NUMBER（6）NOT NULL，unit_price NUMBER（8,2），Quantity NUMBER（8），CONSTRAINT order_items_fk FOREIGN KEY（order_id）REFERENCES orders（order_id））PARTITION BY REFERENCE（order_items_fk）;</pre></div>
                  <!-- class="example" -->
               </div>
            </div><a id="VLDBG14103"></a><div class="props_rev_3"><a id="GUID-52397EF9-EC3B-4E80-8211-77E683263530" name="GUID-52397EF9-EC3B-4E80-8211-77E683263530"></a><h3 id="VLDBG-GUID-52397EF9-EC3B-4E80-8211-77E683263530" class="sect3">创建间隔引用分区表</h3>
               <div>
                  <p>您可以将间隔分区表用作父表以进行引用分区。将记录插入引用分区表时，将创建与父表中的间隔分区对应的引用分区表中的分区。</p>
                  <div class="section">
                     <p>在子表中创建间隔分区时，分区名称将从关联的父表片段继承。如果子表具有表级缺省表空间，则它将用作新间隔分区的表空间;否则，表空间继承自父表片段。</p>
                     <p>引用分区表不允许使用SQL <code class="codeph">ALTER</code> <code class="codeph">TABLE</code> <code class="codeph">SET</code> <code class="codeph">INTERVAL</code>语句，但可以在具有引用分区子项的表上运行。特别是， <code class="codeph">ALTER</code> <code class="codeph">TABLE</code> <code class="codeph">SET</code> <code class="codeph">INTERVAL</code>从目标表中删除interval属性，并将任何interval-reference子项转换为普通的reference-partitioned表。此外，SQL <code class="codeph">ALTER</code> <code class="codeph">TABLE</code> <code class="codeph">SET</code> <code class="codeph">STORE</code> <code class="codeph">IN</code>语句不允许用于引用分区表，但可以在具有引用分区子项的表上运行。
                     </p>
                     <p>将间隔分区转换为父表中的常规分区的操作（例如间隔分区上的<code class="codeph">ALTER</code> <code class="codeph">TABLE</code> <code class="codeph">SPLIT</code> <code class="codeph">PARTITION</code>在子表中构造相应的转换，并根据需要在子表中创建分区。
                     </p>
                     <p>例如，以下SQL语句在父表中提供三个间隔分区，在子表中不提供：</p><pre class="oac_no_warn" dir="ltr">CREATE TABLE par（pk INT CONSTRAINT par_pk PRIMARY KEY，i INT）按范围划分（i）间隔（10）（分区p1值小于（10））; CREATE TABLE chi（fk INT NOT NULL，i INT，CONSTRAINT chi_fk FOREIGN KEY（fk）REFERENCES par（pk））PARFERTION BY REFERENCE（chi_fk）;插入标准值（15,15）;插入标准值（25,25）;插入标准值（35,35）;</pre><p>您可以使用<code class="codeph">USER_TAB_PARTITIONS</code>视图显示有关分区的信息：</p><pre class="oac_no_warn" dir="ltr">SELECT table_name，partition_position，high_value，interval FROM USER_TAB_PARTITIONS WHERE table_name IN（'PAR'，'CHI'）ORDER BY 1,2; TABLE_NAME PARTITION_POSITION HIGH_VALUE INT ---------------- ------------------ ----------  -  -  CHI 1 NO PAR 1 10 NO PAR 2 20 YES PAR 3 30 YES PAR 4 40 YES</pre><p>如果在父表中拆分间隔分区，则会将一些间隔分区转换为层次结构中所有表的常规分区，从而在该过程的子表中创建常规分区。例如：</p><pre class="oac_no_warn" dir="ltr">ALTER TABLE par SPLIT PARTITION FOR（25）AT（25）INTO（分区x，分区y）; SELECT table_name，partition_position，high_value，interval FROM USER_TAB_PARTITIONS WHERE table_name IN（'PAR'，'CHI'）ORDER BY 1,2; TABLE_NAME PARTITION_POSITION HIGH_VALUE INT ---------------- ------------------ ----------  -  -  CHI 1 NO CHI 2 NO CHI 3 NO CHI 4 NO PAR 1 10 NO PAR 2 20 NO PAR 3 25 NO PAR 4 30 NO PAR 5 40 YES</pre><p>间隔引用功能要求将数据库兼容级别（Oracle Database <code class="codeph">COMPATIBLE</code>初始化参数设置）设置为大于或等于<code class="codeph">12.0.0.0</code> 。
                     </p>
                  </div>
                  <!-- class="section" -->
               </div>
            </div><a id="VLDBG14226"></a><div class="props_rev_3"><a id="GUID-01B3A14E-BC74-49D2-B719-B2D8B7692C97" name="GUID-01B3A14E-BC74-49D2-B719-B2D8B7692C97"></a><h3 id="VLDBG-GUID-01B3A14E-BC74-49D2-B719-B2D8B7692C97" class="sect3">使用具有分区的内存中列存储创建表</h3>
               <div>
                  <p>您可以使用带有<code class="codeph">INMEMORY</code>子句的内存中列存储创建分区表。
                  </p>
                  <div class="section">
                     <p>以下示例指定使用带有<code class="codeph">CREATE</code> <code class="codeph">TABLE</code> SQL语句的分区子句的<code class="codeph">INMEMORY</code>子句将各个分区加载到内存中列存储中。
                     </p><pre class="oac_no_warn" dir="ltr">CREATE TABLE list_customers（customer_id NUMBER（6），cust_first_name VARCHAR2（20），cust_last_name VARCHAR2（20），cust_address CUST_ADDRESS_TYP，nls_territory VARCHAR2（30），cust_email VARCHAR2（40））PARTITION BY LIST（nls_territory）（PARTITION asia VALUES（'CHINA '，'泰国'）INMEMORY MEMCOMPRESS容量高，分区欧洲价值（'德国'，'意大利'，'瑞士'）INMEMORY MEMCOMPRESS容量低，分区西部价值（'美国'）内存容量低，分区东价值（'印度'）INMEMORY MEMCOMPRESS容量高，分区休息值（默认）;</pre><div class="infoboxnotealso" id="GUID-01B3A14E-BC74-49D2-B719-B2D8B7692C97__GUID-1EA9A1CE-138A-4737-B6B4-7EC1981FB8BF">
                        <p class="notep1">也可以看看：</p>
                        <ul style="list-style-type:disc">
                           <li>
                              <p>有关内存中列存储的概述信息，请<a href="../inmem/intro-to-in-memory-column-store.html#INMEM-GUID-BFA53515-7643-41E5-A296-654AB4A9F9E7" target="_blank"><span><cite>参见“Oracle数据库内存指南”</cite></span></a></p>
                           </li>
                           <li><a href="../inmem/populating-objects-in-memory.html#INMEM-GUID-C5F856BF-70E3-41C6-A1BA-1E94D7D230B8" target="_blank"><span><cite>“Oracle数据库内存指南”</cite></span></a> ，了解有关在内存中列存储和ADO支持中启用填充对象的信息</li>
                           <li>
                              <p>有关与内存中列存储相关的SQL语法的信息，请<a href="../sqlrf/CREATE-TABLE.html#SQLRF01402" target="_blank"><span><cite>参见Oracle数据库SQL语言参考</cite></span></a></p>
                           </li>
                        </ul>
                     </div>
                  </div>
                  <!-- class="section" -->
               </div>
            </div>
            <div class="sect2"><a id="GUID-9D7149B6-A2FF-47CA-8F00-47CBFD33F82B" name="GUID-9D7149B6-A2FF-47CA-8F00-47CBFD33F82B"></a><h3 id="VLDBG-GUID-9D7149B6-A2FF-47CA-8F00-47CBFD33F82B" class="sect3">使用只读分区或子分区创建表</h3>
               <div>
                  <p>您可以将表，分区和子分区设置为只读状态，以保护数据免受任何用户或触发器的无意DML操作。</p>
                  <p>任何更新设置为只读的分区或子分区中的数据的尝试都会导致错误，而更新分区或设置为读写的子分区中的数据会成功。</p>
                  <p><code class="codeph">CREATE</code> <code class="codeph">TABLE</code>和<code class="codeph">ALTER</code> <code class="codeph">TABLE</code> SQL语句为分区和子分区提供只读子句。只读子句的值可以是<code class="codeph">READ</code> <code class="codeph">ONLY</code>或<code class="codeph">READ</code> <code class="codeph">WRITE</code> 。 <code class="codeph">READ</code> <code class="codeph">WRITE</code>是默认值。除非为分区或子分区显式设置了只读子句，否则只读子句的更高级别设置将应用于分区和子分区。
                  </p>
                  <p>以下是创建具有只读和读写状态的复合范围列表分区表的示例。<code class="codeph">orders_read_write_only</code>显式指定为<code class="codeph">READ</code> <code class="codeph">WRITE</code> ，因此表的默认属性为read write。分区<code class="codeph">order_p1</code>的默认属性被指定为只读，因此子分区<code class="codeph">ord_p1_northwest</code>和<code class="codeph">order_p1_southwest</code>从分区<code class="codeph">order_p1</code>继承只读状态。子<code class="codeph">ord_p2_southwest</code>和<code class="codeph">order_p3_northwest</code>被明确指定为只读，覆盖默认的读写状态。
                  </p>
                  <div class="example" id="GUID-9D7149B6-A2FF-47CA-8F00-47CBFD33F82B__GUID-E77AF727-D094-4A67-9AF6-73D2EB373E16">
                     <p class="titleinexample">示例4-10创建具有只读和读写分区的表</p><pre class="oac_no_warn" dir="ltr">CREATE TABLE orders_read_write_only（order_id NUMBER（12），order_date DATE CONSTRAINT order_date_nn NOT NULL，state VARCHAR2（2））READ WRITE PARTITION BY RANGE（order_date）SUBPARTITION BY LIST（状态）（PARTITION order_p1 VALUES比（TO_DATE（'01 -DEC） -2015'，'DD-MON-YYYY'））只读（SUBPARTITION order_p1_northwest VALUES（'OR'，'WA'），SUBPARTITION order_p1_southwest VALUES（'AZ'，'UT'，'NM'）），PARTITION order_p2 VALUES （少于（'01 -MAR-2016'，'DD-MON-YYYY'））（SUBPARTITION order_p2_northwest VALUES（'OR'，'WA'），SUBPARTITION order_p2_southwest VALUES（'AZ'，'UT'，'NM） '）READ ONLY），PARTITION order_p3值不到（TO_DATE（'01 -JUL-2016'，'DD-MON-YYYY'））（SUBPARTITION order_p3_northwest VALUES（'OR'，'WA'）READ ONLY，SUBPARTITION order_p3_southwest VALUES （'AZ'，'UT'，'NM'）））;</pre></div>
                  <!-- class="example" -->
                  <div class="section">
                     <p>您可以通过检查只读状态<code class="codeph">DEF_READ_ONLY</code>的列<code class="codeph">*_PART_TABLES</code>来看， <code class="codeph">READ_ONLY</code>的列<code class="codeph">*_TAB_PARTITIONS</code>视图和<code class="codeph">READ_ONLY</code>的列<code class="codeph">*_TAB_SUBPARTITIONS</code>视图。请注意，只有物理段，用于单级分区的分区和用于复合分区的子分区具有状态。所有其他级别都是合乎逻辑的，只有默认状态。
                     </p><pre class="oac_no_warn" dir="ltr">SQL&gt; SELECT PARTITION_NAME，READ_ONLY FROM USER_TAB_PARTITIONS WHERE TABLE_NAME ='ORDERS_READ_WRITE_ONLY'; PARTITION_NAME READ ------------------------------- ---- ORDER_P1 YES ORDER_P2 NONE ORDER_P3 NONE SQL&gt; SELECT PARTITION_NAME，SUBPARTITION_NAME， READ_ONLY FROM USER_TAB_SUBPARTITIONS WHERE TABLE_NAME ='ORDERS_READ_WRITE_ONLY'; PARTITION_NAME SUBPARTITION_NAME REA ------------------------------ ----------------- ------------ --- ORDER_P1 ORDER_P1_NORTHWEST YES ORDER_P1 ORDER_P1_SOUTHWEST YES ORDER_P2 ORDER_P2_NORTHWEST NO ORDER_P2 ORDER_P2_SOUTHWEST YES ORDER_P3 ORDER_P3_NORTHWEST YES ORDER_P3 ORDER_P3_SOUTHWEST NO</pre><div class="infoboxnotealso" id="GUID-9D7149B6-A2FF-47CA-8F00-47CBFD33F82B__ORACLEDATABASEREFERENCEFORINFORMATI-F3FBC646">
                        <p class="notep1">也可以看看：</p>
                        <p><a href="../refrn/static-data-dictionary-views-5.html#REFRN-GUID-22FAAA6B-2181-47AE-8A10-6CF968B52CA4" target="_blank"><span><cite>Oracle数据库参考</cite></span></a>有关<code class="codeph">*_PART_TABLES</code> ， <code class="codeph">*_TAB_PARTITIONS</code>和<code class="codeph">*_TAB_SUBPARTITIONS</code>视图的信息</p>
                     </div>
                  </div>
                  <!-- class="section" -->
               </div>
            </div>
            <div class="sect2"><a id="GUID-09CFA3CD-66B7-4CDF-A086-6958D113BDD1" name="GUID-09CFA3CD-66B7-4CDF-A086-6958D113BDD1"></a><h3 id="VLDBG-GUID-09CFA3CD-66B7-4CDF-A086-6958D113BDD1" class="sect3">创建分区外部表</h3>
               <div>
                  <p>您可以为外部表创建分区。</p>
                  <p>组织外部子句将表标识为外部表，后跟外部表的规范和访问参数。而参数，如默认目录;可以在分区或子分区级别上覆盖，外部表类型及其访问参数是表级属性，适用于所有分区或子分区。</p>
                  <p><a href="partition-create-tables-indexes.html#GUID-09CFA3CD-66B7-4CDF-A086-6958D113BDD1__GUID-385BCC5F-77CA-4579-8C7C-0E964DB65AB6">例4-11</a>中创建的表有三个分区，用于从不同位置访问的外部数据。分区<code class="codeph">p1</code>存储位于表的默认目录中的California的客户数据。分区<code class="codeph">p2</code>指向存储华盛顿数据的文件。分区<code class="codeph">p3</code>没有文件描述符且为空。
                  </p>
                  <div class="example" id="GUID-09CFA3CD-66B7-4CDF-A086-6958D113BDD1__GUID-385BCC5F-77CA-4579-8C7C-0E964DB65AB6">
                     <p class="titleinexample">示例4-11创建分区外部表</p><pre class="oac_no_warn" dir="ltr">CREATE TABLE销售（loc_id号，prod_id号，cust_id号，amount_sold号，quantity_sold号）ORGANIZATION EXTERNAL（类型oracle_loader DEFAULT目录load_d1访问参数（记录由NEWLINE CHARACTERSET US7ASCII NOBADFILE LOGFILE删除记录：'sales.log'FIELDS TERMINATED BY“， “））拒绝限制无限制分区（loc_id）（分区p1值小于（1000）位置（'california.txt'），分区p2值小于（2000）默认目录load_d2 LOCATION（'washington.txt'），分区p3值低于（3000））;</pre></div>
                  <!-- class="example" -->
                  <div class="section">
                     <div class="infoboxnotealso" id="GUID-09CFA3CD-66B7-4CDF-A086-6958D113BDD1__ORACLEDATABASEADMINISTRATORSGUIDEFO-330DF498">
                        <p class="notep1">也可以看看：</p>
                        <p>有关分区外部表的信息，请参见<a href="../admin/managing-tables.html#ADMIN-GUID-2A801016-0399-4925-AD1B-A02683E81B59" target="_blank"><span><cite>“Oracle数据库管理员指南”</cite></span></a></p>
                     </div>
                  </div>
                  <!-- class="section" -->
               </div>
            </div><a id="VLDBG00301"></a><div class="props_rev_3"><a id="GUID-5C34BF3F-B728-47C7-B656-AE4FA9FFE2C3" name="GUID-5C34BF3F-B728-47C7-B656-AE4FA9FFE2C3"></a><h3 id="VLDBG-GUID-5C34BF3F-B728-47C7-B656-AE4FA9FFE2C3" class="sect3">指定键列上的分区</h3>
               <div>
                  <p>对于范围分区和散列分区表，最多可以指定16个分区键列。</p>
                  <p>当分区键由多个列组成时，使用多列分区，后续列定义比前面的列更高的粒度。最常见的情况是分解的<code class="codeph">DATE</code>或<code class="codeph">TIMESTAMP</code>键，由分隔的列组成，包括年，月和日。
                  </p>
                  <p>在评估多列分区键时，仅当第一个值不能唯一标识单个目标分区时，数据库才使用第二个值，并且仅当第一个值和第二个值未确定正确的分区时才使用第三个值，依此类推。仅当分区绑定与该值完全匹配且为下一个分区定义了相同的绑定时，值才能确定正确的分区。只有当所有先前的第（n-1）的多列键的值完全匹配分区的第（n-1）边界的<sup>第</sup> <span class="italic">n</span>列进行了研究。例如，仅当第一列与分区边界值完全匹配时，才会评估第二列。如果所有列值都与分区的所有绑定值完全匹配，则数据库会确定该行不适合此分区，并将下一个分区视为匹配项。
                  </p>
                  <p>对于非确定性边界定义（具有至少一列的相同值的连续分区），分区边界值变为包含值，表示“小于或等于”边界。这与确定性边界形成对比，其中值始终被视为“小于”边界。</p>
                  <p>讨论了以下主题：</p>
                  <ul style="list-style-type:disc">
                     <li>
                        <p><a href="partition-create-tables-indexes.html#GUID-814DE2FF-7147-42DE-9CAF-5E019BAB8C18" title="本主题中的示例显示如何按日期创建多列范围分区表。">按日期创建多列范围分区表</a></p>
                     </li>
                     <li>
                        <p><a href="partition-create-tables-indexes.html#GUID-2E03ED66-312F-422A-9352-2128B34DEE8E" title="本主题中的示例显示如何创建多列范围分区表以强制执行大小相等的分区。">创建多列范围分区表以实施等分区</a></p>
                     </li>
                  </ul>
               </div><a id="VLDBG14059"></a><div class="props_rev_3"><a id="GUID-814DE2FF-7147-42DE-9CAF-5E019BAB8C18" name="GUID-814DE2FF-7147-42DE-9CAF-5E019BAB8C18"></a><h4 id="VLDBG-GUID-814DE2FF-7147-42DE-9CAF-5E019BAB8C18" class="sect4">按日期创建多列范围分区表</h4>
                  <div>
                     <p>本主题中的示例显示如何按日期创建多列范围分区表。</p>
                     <div class="section">
                        <p><a href="partition-create-tables-indexes.html#GUID-814DE2FF-7147-42DE-9CAF-5E019BAB8C18__CHDEJJFJ">示例4-12</a>说明了多列范围分区表的列评估，将实际<code class="codeph">DATE</code>信息存储在三个单独的列中： <code class="codeph">year</code> ， <code class="codeph">month</code>和<code class="codeph">day</code> 。分区粒度是日历季度。正在评估的分区表创建如下：</p>
                        <p>12-DEC-2000的年值满足第一个分区， <code class="codeph">before2001</code> ，因此不需要进一步评估：</p><pre class="oac_no_warn" dir="ltr">SELECT * FROM sales_demo PARTITION（before2001）;年月日AMOUNT_SOLD ---------- ---------- ---------- ----------- 2000 12 12 1000</pre><p>17-MAR-2001的信息存储在分区<code class="codeph">q1_2001</code> 。第一个分区键列<code class="codeph">year</code>本身并不确定正确的分区，因此必须评估第二个分区键列<code class="codeph">month</code> 。
                        </p><pre class="oac_no_warn" dir="ltr">SELECT * FROM sales_demo PARTITION（q1_2001）;年月日AMOUNT_SOLD ---------- ---------- ---------- ----------- 2001 3 17 2000</pre><p>遵循与先前记录相同的确定规则，第二列， <code class="codeph">month</code> ，将分区<code class="codeph">q4_2001</code>确定为1-NOV-2001的正确分区：</p><pre class="oac_no_warn" dir="ltr">SELECT * FROM sales_demo PARTITION（q4_2001）;年月日AMOUNT_SOLD ---------- ---------- ---------- ----------- 2001 11 1 5000</pre><p>01-JAN-2002的分区是通过仅评估<code class="codeph">year</code>列来确定的，该列表示<code class="codeph">future</code>分区：</p><pre class="oac_no_warn" dir="ltr">SELECT * FROM sales_demo PARTITION（future）;年月日AMOUNT_SOLD ---------- ---------- ---------- ----------- 2002 1 1 4000</pre><p>如果数据库在分区键列中遇到<code class="codeph">MAXVALUE</code> ，则后续列的所有其他值将变得无关紧要。也就是说，前面例子中分区<code class="codeph">future</code>的定义，其边界为（ <code class="codeph">MAXVALUE</code> ，0）等于（ <code class="codeph">MAXVALUE</code> ，100）的边界或（ <code class="codeph">MAXVALUE</code> ， <code class="codeph">MAXVALUE</code> ）的边界。
                        </p>
                     </div>
                     <!-- class="section" -->
                     <div class="example" id="GUID-814DE2FF-7147-42DE-9CAF-5E019BAB8C18__CHDEJJFJ">
                        <p class="titleinexample">示例4-12创建多列范围分区表</p><pre class="oac_no_warn" dir="ltr">CREATE TABLE sales_demo（年份NUMBER，月份NUMBER，日期NUMBER，amount_sold NUMBER）按范围划分（年，月）（2001年之前的分数值（2001,1），分区q1_2001值小于（2001,4），分区q2_2001值少于（2001,7），分区q3_2001的值小于（2001,10），分区q4_2001的值小于（2002,1），分区的未来价值低于（MAXVALUE，0））; REM 12-DEC-2000 INSERT INTO sales_demo VALUES（2000,12,12,1000）; REM 17-MAR-2001 INSERT INTO sales_demo VALUES（2001,3,17,2000）; REM 1-NOV-2001 INSERT INTO sales_demo VALUES（2001,11,1,5000）; REM 1-JAN-2002 INSERT INTO sales_demo VALUES（2002,1,1,4000）;</pre></div>
                     <!-- class="example" -->
                  </div>
               </div>
               <div class="props_rev_3"><a id="GUID-2E03ED66-312F-422A-9352-2128B34DEE8E" name="GUID-2E03ED66-312F-422A-9352-2128B34DEE8E"></a><h4 id="VLDBG-GUID-2E03ED66-312F-422A-9352-2128B34DEE8E" class="sect4">创建多列范围分区表以实施等分区</h4>
                  <div>
                     <p>本主题中的示例显示如何创建多列范围分区表以强制执行大小相等的分区。</p>
                     <div class="section">
                        <p>以下示例说明了对表<code class="codeph">supplier_parts</code>使用多列分区方法，存储有关哪些供应商提供哪些部件的信息。要在相同大小的分区中分发数据，仅基于<code class="codeph">supplier_id</code>对表进行分区是不够的，因为某些供应商可能提供数十万个部件，而其他供应商仅提供少量特殊部件。相反，您在（ <code class="codeph">supplier_id</code> ， <code class="codeph">partnum</code> ）上对表进行分区以手动强制执行相等大小的分区。
                        </p>
                        <p>无论<code class="codeph">partnum</code>值如何， <code class="codeph">supplier_id</code> &lt;10的每一行都存储在分区<code class="codeph">p1</code> 。仅当<code class="codeph">supplier_id</code> = 10时才评估列<code class="codeph">partnum</code> ，并且当<code class="codeph">partnum</code> &gt; = 200时，相应的行将插入到分区<code class="codeph">p1</code> ， <code class="codeph">p2</code>或甚至<code class="codeph">p3</code> 。要为<code class="codeph">supplier_parts</code>范围实现大小相等的分区，您可以选择复合范围 - 散列分区表，由<code class="codeph">supplier_id</code>分区的范围，由<code class="codeph">partnum</code>分区的<code class="codeph">partnum</code> 。
                        </p>
                        <p>为多列分区表定义分区边界必须遵守某些规则。例如，考虑一个在三个列<code class="codeph">a</code> ， <code class="codeph">b</code>和<code class="codeph">c</code>上进行范围分区的表。各个分区的范围值表示如下：</p><pre class="oac_no_warn" dir="ltr">P0（a0，b0，c0）P1（a1，b1，c1）P2（a2，b2，c2）......Pn（an，bn，cn）</pre><p>您为每个分区提供的范围值必须遵循以下规则：</p>
                     </div>
                     <!-- class="section" -->
                     <div class="section">
                        <ul style="list-style-type:disc">
                           <li>
                              <p><code class="codeph">a0</code>必须小于或等于<code class="codeph">a1</code> ， <code class="codeph">a1</code>必须小于或等于<code class="codeph">a2</code> ，依此类推。
                              </p>
                           </li>
                           <li>
                              <p>如果<code class="codeph">a0</code> = <code class="codeph">a1</code> ，则<code class="codeph">b0</code>必须小于或等于<code class="codeph">b1</code> 。如果<code class="codeph">a0</code> &lt; <code class="codeph">a1</code> ，那么<code class="codeph">b0</code>和<code class="codeph">b1</code>可以有任何值。如果<code class="codeph">a0</code> = <code class="codeph">a1</code>且<code class="codeph">b0</code> = <code class="codeph">b1</code> ，则<code class="codeph">c0</code>必须小于或等于<code class="codeph">c1</code> 。如果<code class="codeph">b0</code> &lt; <code class="codeph">b1</code> ，那么<code class="codeph">c0</code>和<code class="codeph">c1</code>可以有任何值，依此类推。
                              </p>
                           </li>
                           <li>
                              <p>如果<code class="codeph">a1</code> = <code class="codeph">a2</code> ，则<code class="codeph">b1</code>必须小于或等于<code class="codeph">b2</code> 。如果<code class="codeph">a1</code> &lt; <code class="codeph">a2</code> ，则<code class="codeph">b1</code>和<code class="codeph">b2</code>可以具有任何值。如果<code class="codeph">a1</code> = <code class="codeph">a2</code>且<code class="codeph">b1</code> = <code class="codeph">b2</code> ，则<code class="codeph">c1</code>必须小于或等于<code class="codeph">c2</code> 。如果<code class="codeph">b1</code> &lt; <code class="codeph">b2</code> ，那么<code class="codeph">c1</code>和<code class="codeph">c2</code>可以有任何值，依此类推。
                              </p>
                           </li>
                        </ul>
                     </div>
                     <!-- class="section" -->
                     <div class="section"><pre class="oac_no_warn" dir="ltr">CREATE TABLE supplier_parts（supplier_id NUMBER，partnum NUMBER，price NUMBER）PARTITION BY RANGE（supplier_id，partnum）（PARTITION p1值小于（10,100），PARTITION p2值小于（10,200），PARTITION p3 VALUES小于（MAXVALUE，MAXVALUE） ）;</pre><p>表格中插入以下三条记录：</p><pre class="oac_no_warn" dir="ltr">INSERT INTO supplier_parts VALUES（5,5,1000）; INSERT INTO supplier_parts VALUES（5,150,1000）; INSERT INTO supplier_parts VALUES（10,100,1000）;</pre><p>前两个记录插入到分区<code class="codeph">p1</code> ，由<code class="codeph">supplier_id</code>唯一标识。但是，第三条记录被插入到分区<code class="codeph">p2</code> ;它严格匹配分区<code class="codeph">p1</code>所有范围边界值，因此数据库会考虑以下分区进行匹配。<code class="codeph">partnum</code>的值满足&lt;200的标准，因此将其插入到分区<code class="codeph">p2</code> 。
                        </p><pre class="oac_no_warn" dir="ltr">SELECT * FROM supplier_parts PARTITION（p1）; SUPPLIER_ID PARTNUM PRICE ----------- ---------- ---------- 5 5 1000 5 150 1000 SELECT * FROM supplier_parts PARTITION（p2）; SUPPLIER_ID PARTNUM价格----------- ---------- ---------- 10 100 1000</pre></div>
                     <!-- class="section" -->
                  </div>
               </div>
            </div><a id="VLDBG14060"></a><a id="VLDBG1109"></a><div class="props_rev_3"><a id="GUID-AF6D08D7-5E0F-4E08-B682-74CCCAEC64D1" name="GUID-AF6D08D7-5E0F-4E08-B682-74CCCAEC64D1"></a><h3 id="VLDBG-GUID-AF6D08D7-5E0F-4E08-B682-74CCCAEC64D1" class="sect3">使用基于虚拟列的分区</h3>
               <div>
                  <p>通过分区，可以将虚拟列用作任何常规列。</p>
                  <div class="section">
                     <p>使用虚拟列时支持所有分区方法，包括间隔分区和复合分区的所有不同组合。用作分区列的虚拟列不能使用对PL / SQL函数的调用。</p>
                     <p>以下示例使用子分区键的虚拟列显示按范围范围分区的<code class="codeph">sales</code>表。虚拟列通过乘以<code class="codeph">amount_sold</code>和<code class="codeph">quantity_sold</code>来计算销售的总价值。如示例所示，虚拟列也支持行移动。如果启用了行移动，则如果虚拟列的计算结果为属于另一个分区的值，则行会从一个分区迁移到另一个分区。
                     </p><pre class="oac_no_warn" dir="ltr">CREATE TABLE sales（prod_id NUMBER（6）NOT NULL，cust_id NUMBER NOT NULL，time_id DATE NOT NULL，channel_id CHAR（1）NOT NULL，promo_id NUMBER（6）NOT NULL，quantity_sold NUMBER（3）NOT NULL，amount_sold NUMBER（10 ，2）NOT NULL，total_amount AS（quantity_sold * amount_sold））PARTITION BY RANGE（time_id）INTERVAL（NUMTOYMINTERVAL（1，'MONTH'））按范围（total_amount）SUBPARTITION模板的子实数（子实体p_small值小于（1000），SUBPARTITION p_medium价值低于（5000），SubPARTITION p_large VALUE少于（10000），SubPARTITION p_extreme VALUES少于（MAXVALUE））（PARTITION sales_before_2007价值不到（7月1日'，'-JAN-2007'，'dd-MON-yyyy'） ）））使行运动平行运行;</pre></div>
                  <!-- class="section" -->
                  <div class="section">
                     <div class="infoboxnotealso" id="GUID-AF6D08D7-5E0F-4E08-B682-74CCCAEC64D1__GUID-8BC1241A-8B3A-45F6-B6BA-97369A497149">
                        <p class="notep1">也可以看看：</p>
                        <p>有关如何创建虚拟列的语法，请参阅<a href="../sqlrf/Pseudocolumns.html#SQLRF0025" target="_blank"><span><cite>Oracle数据库SQL语言参考</cite></span></a></p>
                     </div>
                  </div>
                  <!-- class="section" -->
               </div>
            </div><a id="VLDBG14061"></a><a id="VLDBG1110"></a><div class="props_rev_3"><a id="GUID-7D211E4B-FFFD-4146-9010-20ED1232FF2C" name="GUID-7D211E4B-FFFD-4146-9010-20ED1232FF2C"></a><h3 id="VLDBG-GUID-7D211E4B-FFFD-4146-9010-20ED1232FF2C" class="sect3">将表压缩与分区表一起使用</h3>
               <div>
                  <p>对于堆组织分区表，您可以使用表压缩来压缩部分或全部分区。</p>
                  <div class="section">
                     <p>可以为表空间，表或表的分区声明compression属性。每当未指定compress属性时，它就像任何其他存储属性一样继承。</p>
                     <p><a href="partition-create-tables-indexes.html#GUID-7D211E4B-FFFD-4146-9010-20ED1232FF2C__CHDCCFGE">示例4-13</a>创建了一个范围分区表，其中包含一个压缩分区<code class="codeph">costs_old</code> 。表和所有其他分区的compression属性继承自表空间级别。
                     </p>
                  </div>
                  <!-- class="section" -->
                  <div class="example" id="GUID-7D211E4B-FFFD-4146-9010-20ED1232FF2C__CHDCCFGE">
                     <p class="titleinexample">示例4-13使用压缩分区创建范围分区表</p><pre class="oac_no_warn" dir="ltr">CREATE TABLE costs_demo（prod_id NUMBER（6），time_id DATE，unit_cost NUMBER（10,2），unit_price NUMBER（10,2））PARTITION BY RANGE（time_id）（PARTITION costs_old VALUES少于（TO_DATE（'01 -JAN-2003） '，'DD-MON-YYYY'））COMPRESS，PARTITION costs_q1_2003价值不到（截止日期（'01-APR-2003'，'DD-MON-YYYY'）），PARTITION costs_q2_2003价值不到（截止到4月1日） JUN-2003'，'DD-MON-YYYY'）），PARTITION cost_recent VALUES少于（MAXVALUE））;</pre></div>
                  <!-- class="example" -->
               </div>
            </div><a id="VLDBG1111"></a><div class="props_rev_3"><a id="GUID-0C13E8A8-568B-4A60-8A46-F1120D193EFE" name="GUID-0C13E8A8-568B-4A60-8A46-F1120D193EFE"></a><h3 id="VLDBG-GUID-0C13E8A8-568B-4A60-8A46-F1120D193EFE" class="sect3">使用带分区索引的密钥压缩</h3>
               <div>
                  <p>您可以使用键压缩来压缩B树索引的部分或全部分区。</p>
                  <div class="section">
                     <p>密钥压缩仅适用于B树索引。默认情况下，位图索引以压缩方式存储。使用密钥压缩的索引消除了重复出现的键列前缀值，从而节省了空间和I / O.</p>
                     <p>以下示例创建一个本地分区索引，其中包含除最近一个压缩之外的所有分区：</p><pre class="oac_no_warn" dir="ltr">CREATE INDEX i_cost1 ON costs_demo（prod_id）COMPRESS LOCAL（PARTITION costs_old，PARTITION costs_q1_2003，PARTITION costs_q2_2003，PARTITION costs_recent NOCOMPRESS）;</pre><p>您不能为索引子分区明确指定<code class="codeph">COMPRESS</code> （或<code class="codeph">NOCOMPRESS</code> ）。给定分区的所有索引子分区都从父分区继承密钥压缩设置。
                     </p>
                     <p>要修改给定分区的所有子分区的密钥压缩属性，必须首先发出<code class="codeph">ALTER INDEX...MODIFY PARTITION</code>语句，然后重建所有子分区。<code class="codeph">MODIFY PARTITION</code>子句将所有索引子分区标记为<code class="codeph">UNUSABLE</code> 。</p>
                  </div>
                  <!-- class="section" -->
               </div>
            </div><a id="VLDBG14062"></a><div class="props_rev_3"><a id="GUID-548F1C63-0948-4B6E-95F9-6DCC7F5A9F95" name="GUID-548F1C63-0948-4B6E-95F9-6DCC7F5A9F95"></a><h3 id="VLDBG-GUID-548F1C63-0948-4B6E-95F9-6DCC7F5A9F95" class="sect3">使用段指定分区</h3>
               <div>
                  <p>本主题介绍了使用段进行分区。</p>
                  <p>这些主题讨论了使用分段分段时的功能。</p>
                  <ul style="list-style-type:disc">
                     <li>
                        <p><a href="partition-create-tables-indexes.html#GUID-DF75897A-DF8D-4AF3-AECF-748D60A94949" title="您可以在创建分区表时推迟创建段，直到将第一行插入分区。">分区的延迟段创建</a></p>
                     </li>
                     <li>
                        <p><a href="partition-create-tables-indexes.html#GUID-4EBDF098-A3DB-44DF-8B0C-CE24246EBE64" title="您可以使用DBMS_SPACE_ADMIN.DROP_EMPTY_SEGMENTS过程删除表和表片段中的空段。">截断空的段</a></p>
                     </li>
                     <li>
                        <p><a href="partition-create-tables-indexes.html#GUID-FCAD2073-5AF3-42A6-8485-A5D4F9A814C3" title="您可以使用DBMS_SPACE_ADMIN包中的MATERIALIZE_DEFERRED_SEGMENTS过程为具有延迟段属性的表的表和从属对象创建段。">按需创建细分的维护程序</a></p>
                     </li>
                  </ul>
               </div><a id="VLDBG14063"></a><div class="props_rev_3"><a id="GUID-DF75897A-DF8D-4AF3-AECF-748D60A94949" name="GUID-DF75897A-DF8D-4AF3-AECF-748D60A94949"></a><h4 id="VLDBG-GUID-DF75897A-DF8D-4AF3-AECF-748D60A94949" class="sect4">分区的延迟段创建</h4>
                  <div>
                     <p>您可以在创建分区表时推迟创建段，直到将第一行插入分区。</p>
                     <p>插入第一行时，将为基表分区，LOB列，所有全局索引和本地索引分区创建段。可以通过以下方式控制延迟段创建：</p>
                     <ul style="list-style-type:disc">
                        <li>
                           <p>在初始化参数文件中将<code class="codeph">DEFERRED_SEGMENT_CREATION</code>初始化参数设置为<code class="codeph">TRUE</code>或<code class="codeph">FALSE</code> 。
                           </p>
                        </li>
                        <li>
                           <p>使用<code class="codeph">ALTER</code> <code class="codeph">SESSION</code>或<code class="codeph">ALTER</code> <code class="codeph">SYSTEM</code> SQL语句将初始化参数<code class="codeph">DEFERRED_SEGMENT_CREATION</code>设置为<code class="codeph">TRUE</code>或<code class="codeph">FALSE</code> 。
                           </p>
                        </li>
                        <li>
                           <p>在发出<code class="codeph">CREATE</code> <code class="codeph">TABLE</code> SQL语句时，使用partition子句指定关键字<code class="codeph">SEGMENT</code> <code class="codeph">CREATION</code> <code class="codeph">IMMEDIATE</code>或<code class="codeph">SEGMENT</code> <code class="codeph">CREATION</code> <code class="codeph">DEFERRED</code> 。
                           </p>
                        </li>
                     </ul>
                     <p>您可以使用<code class="codeph">ALTER</code> <code class="codeph">TABLE</code> <code class="codeph">MODIFY</code> <code class="codeph">PARTITION</code> <code class="codeph">ALLOCATE</code> <code class="codeph">EXTENT</code> SQL语句强制为现有创建的分区创建段。此语句分配的范围超过<code class="codeph">CREATE</code> <code class="codeph">TABLE</code>期间指定的初始范围数。</p>
                     <p>延迟段创建不支持可序列化事务。将数据插入到没有创建段的空表中，或者插入到没有段的间隔分区表的分区中，可能会导致错误。</p>
                     <div class="infoboxnotealso" id="GUID-DF75897A-DF8D-4AF3-AECF-748D60A94949__GUID-EC48DB23-C4C8-4DF5-878E-4B6305B3FF46">
                        <p class="notep1">也可以看看：</p>
                        <ul style="list-style-type:disc">
                           <li>
                              <p>有关<code class="codeph">DEFERRED_SEGMENT_CREATION</code>初始化参数的详细信息，请<a href="../refrn/DEFERRED_SEGMENT_CREATION.html#REFRN10307" target="_blank"><span><cite>参见Oracle数据库参考</cite></span></a></p>
                           </li>
                           <li>
                              <p>有关<code class="codeph">ALTER</code> <code class="codeph">SESSION</code>和<code class="codeph">ALTER</code> <code class="codeph">SYSTEM</code> SQL语句的更多信息，请<a href="../sqlrf/ALTER-SESSION.html#SQLRF00901" target="_blank"><span><cite>参见Oracle数据库SQL语言参考</cite></span></a></p>
                           </li>
                           <li>
                              <p><a href="../sqlrf/CREATE-TABLE.html#SQLRF01402" target="_blank"><span><cite>Oracle数据库SQL语言参考</cite></span></a>有关关键字<code class="codeph">SEGMENT</code> <code class="codeph">CREATION</code> <code class="codeph">IMMEDIATE</code>和<code class="codeph">SEGMENT</code> <code class="codeph">CREATION</code> <code class="codeph">DEFERRED</code> <code class="codeph">CREATE</code> <code class="codeph">TABLE</code> SQL语句的更多信息</p>
                           </li>
                        </ul>
                     </div>
                  </div>
               </div><a id="VLDBG14064"></a><div class="props_rev_3"><a id="GUID-4EBDF098-A3DB-44DF-8B0C-CE24246EBE64" name="GUID-4EBDF098-A3DB-44DF-8B0C-CE24246EBE64"></a><h4 id="VLDBG-GUID-4EBDF098-A3DB-44DF-8B0C-CE24246EBE64" class="sect4">截断空的段</h4>
                  <div>
                     <p>您可以使用<code class="codeph">DBMS_SPACE_ADMIN.DROP_EMPTY_SEGMENTS</code>过程删除表和表片段中的空段。
                     </p>
                     <p>此外，如果分区或子分区具有段，则如果使用<code class="codeph">ALTER</code> <code class="codeph">TABLE</code> <code class="codeph">TRUNCATE</code> <code class="codeph">PARTITION</code> SQL语句指定了<code class="codeph">DROP</code> <code class="codeph">ALL</code> <code class="codeph">STORAGE</code>子句，则truncate功能将删除该段。
                     </p>
                     <div class="infoboxnotealso" id="GUID-4EBDF098-A3DB-44DF-8B0C-CE24246EBE64__GUID-CEE48B80-2BEE-4F30-9BA7-1C02CE8537B5">
                        <p class="notep1">也可以看看：</p>
                        <p></p>
                        <ul style="list-style-type:disc">
                           <li>
                              <p>有关<code class="codeph">DBMS_SPACE_ADMIN</code>包的更多信息，请<code class="codeph">DBMS_SPACE_ADMIN</code> <a href="../arpls/DBMS_SPACE_ADMIN.html#ARPLS057" target="_blank"><span><cite>Oracle Database PL / SQL包和类型参考</cite></span></a></p>
                           </li>
                           <li>
                              <p>有关<code class="codeph">ALTER</code> <code class="codeph">TABLE</code>的<code class="codeph">DROP</code> <code class="codeph">ALL</code> <code class="codeph">STORAGE</code>子句的更多信息，请<a href="../sqlrf/ALTER-TABLE.html#SQLRF01001" target="_blank"><span><cite>参见Oracle数据库SQL语言参考</cite></span></a></p>
                           </li>
                        </ul>
                     </div>
                  </div>
               </div><a id="VLDBG14065"></a><div class="props_rev_3"><a id="GUID-FCAD2073-5AF3-42A6-8485-A5D4F9A814C3" name="GUID-FCAD2073-5AF3-42A6-8485-A5D4F9A814C3"></a><h4 id="VLDBG-GUID-FCAD2073-5AF3-42A6-8485-A5D4F9A814C3" class="sect4">按需创建细分的维护程序</h4>
                  <div>
                     <p>您可以使用<code class="codeph">DBMS_SPACE_ADMIN</code>包中的<code class="codeph">MATERIALIZE_DEFERRED_SEGMENTS</code>过程为具有延迟段属性的表的表和从属对象创建段。
                     </p>
                     <p>您还可以使用<code class="codeph">DBMS_SPACE_ADMIN.MATERIALIZE_DEFERRED_SEGMENTS</code>过程强制为现有创建的表和表片段创建段。<code class="codeph">MATERIALIZE_DEFERRED_SEGMENTS</code>过程与<code class="codeph">ALTER</code> <code class="codeph">TABLE</code> <code class="codeph">MODIFY</code> <code class="codeph">PARTITION</code> <code class="codeph">ALLOCATE</code> <code class="codeph">EXTENT</code> SQL语句不同，因为它不为表或表片段分配一个额外的范围。
                     </p>
                     <div class="infoboxnotealso" id="GUID-FCAD2073-5AF3-42A6-8485-A5D4F9A814C3__GUID-1AF3F5F9-6484-4072-838E-75E08BCD7416">
                        <p class="notep1">也可以看看：</p>
                        <ul style="list-style-type:disc">
                           <li>
                              <p>有关<code class="codeph">DBMS_SPACE_ADMIN</code>包的更多信息，请<code class="codeph">DBMS_SPACE_ADMIN</code> <a href="../arpls/DBMS_SPACE_ADMIN.html#ARPLS057" target="_blank"><span><cite>Oracle Database PL / SQL包和类型参考</cite></span></a></p>
                           </li>
                        </ul>
                     </div>
                  </div>
               </div>
            </div><a id="VLDBG1112"></a><div class="props_rev_3"><a id="GUID-46136CB9-ED71-4150-96F2-D50121F0BCF0" name="GUID-46136CB9-ED71-4150-96F2-D50121F0BCF0"></a><h3 id="VLDBG-GUID-46136CB9-ED71-4150-96F2-D50121F0BCF0" class="sect3">创建索引组织表时指定分区</h3>
               <div>
                  <p>对于索引组织表，您可以使用范围，列表或散列分区方法。</p>
                  <p>创建分区索引组织表的语义类似于具有这些差异的常规表的语义：</p>
                  <ul style="list-style-type:disc">
                     <li>
                        <p>创建表时，根据需要指定<code class="codeph">ORGANIZATION INDEX</code>子句和<code class="codeph">INCLUDING</code>和<code class="codeph">OVERFLOW</code>子句。
                        </p>
                     </li>
                     <li>
                        <p><code class="codeph">PARTITION</code>子句可以具有<code class="codeph">OVERFLOW</code>子条款，允许您在分区级别指定溢出段的属性。
                        </p>
                     </li>
                  </ul>
                  <p>指定<code class="codeph">OVERFLOW</code>子句会导致溢出数据段本身与主键索引段均分。因此，对于具有溢出的分区索引组织表，每个分区具有索引段和溢出数据段。
                  </p>
                  <p>对于索引组织表，分区列集必须是主键列的子集。由于索引组织表的行存储在表的主键索引中，因此分区标准会影响可用性。通过选择分区键作为主键的子集，插入操作必须仅验证单个分区中主键的唯一性，从而保持分区独立性。</p>
                  <p>对索引组织表的二级索引的支持类似于对常规表的支持。由于二级索引的逻辑性质，索引组织表上的全局索引仍可用于某些操作，对于常规表，这些操作将标记为<code class="codeph">UNUSABLE</code> 。
                  </p>
                  <p>讨论了以下主题：</p>
                  <ul style="list-style-type:disc">
                     <li>
                        <p><a href="partition-create-tables-indexes.html#GUID-A944913C-82F4-4A66-A208-E696C374AB1B" title="您可以使用range方法对索引组织表及其二级索引进行分区。">创建范围分区索引组织表</a></p>
                     </li>
                     <li>
                        <p><a href="partition-create-tables-indexes.html#GUID-ACA2C4B5-6C3D-4503-BFF1-927F89831CD3" title="分区索引组织表的另一个选项是使用哈希方法。">创建哈希分区索引组织表</a></p>
                     </li>
                     <li>
                        <p><a href="partition-create-tables-indexes.html#GUID-77B812A7-6427-429A-8AA7-099EB631FBF8" title="分区索引组织表的另一个选项是使用list方法。">创建列表分区索引组织表</a></p>
                     </li>
                  </ul>
                  <div class="infoboxnotealso" id="GUID-46136CB9-ED71-4150-96F2-D50121F0BCF0__GUID-DEC0E597-32ED-4BDE-9ED4-61B9FFE41A8A">
                     <p class="notep1">也可以看看：</p>
                     <p></p>
                     <ul style="list-style-type:disc">
                        <li>
                           <p><a href="maintenance-partition-tables-indexes.html#GUID-A226B597-BCF1-49E2-8284-739A99D3F9ED" title="可以对分区表和索引执行各种维护操作。">分区表和索引</a>的维护操作，以获取有关索引组织表的维护操作的信息</p>
                        </li>
                        <li>
                           <p>有关管理索引组织表的详细信息，请参见<a href="../admin/managing-tables.html#ADMIN01506" target="_blank"><span><cite>“Oracle数据库管理员指南”</cite></span></a></p>
                        </li>
                        <li>
                           <p>有关索引组织表的更多信息，请参阅<a href="../cncpt/indexes-and-index-organized-tables.html#CNCPT911" target="_blank"><span><cite>Oracle数据库概念</cite></span></a></p>
                        </li>
                     </ul>
                  </div>
               </div><a id="VLDBG14066"></a><a id="VLDBG1113"></a><div class="props_rev_3"><a id="GUID-A944913C-82F4-4A66-A208-E696C374AB1B" name="GUID-A944913C-82F4-4A66-A208-E696C374AB1B"></a><h4 id="VLDBG-GUID-A944913C-82F4-4A66-A208-E696C374AB1B" class="sect4">创建范围分区索引组织表</h4>
                  <div>
                     <p>您可以使用range方法对索引组织表及其二级索引进行分区。</p>
                     <div class="section">
                        <p>在<a href="partition-create-tables-indexes.html#GUID-A944913C-82F4-4A66-A208-E696C374AB1B__CHDJCEAJ">示例4-14中</a> ，创建了范围分区的索引组织表<code class="codeph">sales</code> 。<code class="codeph">INCLUDING</code>子句指定<code class="codeph">week_no</code>之后的所有列都要存储在溢出段中。每个分区都有一个溢出段，所有溢出段都存储在同一个表空间（ <code class="codeph">overflow_here</code> ）中。可选地，可以在单个分区级别指定<code class="codeph">OVERFLOW TABLESPACE</code> ，在这种情况下，部分或全部溢出段可以具有单独的<code class="codeph">TABLESPACE</code>属性。
                        </p>
                     </div>
                     <!-- class="section" -->
                     <div class="example" id="GUID-A944913C-82F4-4A66-A208-E696C374AB1B__CHDJCEAJ">
                        <p class="titleinexample">示例4-14创建范围分区的索引组织表</p><pre class="oac_no_warn" dir="ltr">CREATE TABLE销售（acct_no NUMBER（5），acct_name CHAR（30），amount_of_sale NUMBER（6），week_no INTEGER，sale_details VARCHAR2（1000），PRIMARY KEY（acct_no，acct_name，week_no））包含week_no OVERFLOW TABLESPACE的组织索引overflow_here PARTITION BY RANGE（week_no）（分区值小于（5）TABLESPACE ts1，分区值小于（9）TABLESPACE ts2 OVERFLOW TABLESPACE overflow_ts2，...分区值小于（MAXVALUE）TABLESPACE ts13）;</pre></div>
                     <!-- class="example" -->
                  </div>
               </div><a id="VLDBG14067"></a><a id="VLDBG1114"></a><div class="props_rev_3"><a id="GUID-ACA2C4B5-6C3D-4503-BFF1-927F89831CD3" name="GUID-ACA2C4B5-6C3D-4503-BFF1-927F89831CD3"></a><h4 id="VLDBG-GUID-ACA2C4B5-6C3D-4503-BFF1-927F89831CD3" class="sect4">创建哈希分区索引组织表</h4>
                  <div>
                     <p>分区索引组织表的另一个选项是使用哈希方法。</p>
                     <div class="section">
                        <p>在<a href="partition-create-tables-indexes.html#GUID-ACA2C4B5-6C3D-4503-BFF1-927F89831CD3__CHDDCFHH">例4-15中</a> ， <code class="codeph">sales</code>索引组织表由哈希方法分区。
                        </p>
                        <div class="infoboxnote" id="GUID-ACA2C4B5-6C3D-4503-BFF1-927F89831CD3__GUID-83DE597B-EA0A-4415-8F3D-DE32854629FF">
                           <p class="notep1">注意：</p>
                           <p>精心设计的散列函数旨在以均衡的方式在分区之间分配行。因此，更新行的主键列很可能会将该行移动到不同的分区。Oracle建议您在创建具有可更改分区键的散列分区索引组织表时显式指定<code class="codeph">ENABLE ROW MOVEMENT</code>子句。默认情况下，禁用<code class="codeph">ENABLE ROW MOVEMENT</code> 。
                           </p>
                        </div>
                     </div>
                     <!-- class="section" -->
                     <div class="example" id="GUID-ACA2C4B5-6C3D-4503-BFF1-927F89831CD3__CHDDCFHH">
                        <p class="titleinexample">示例4-15创建散列分区索引组织表</p><pre class="oac_no_warn" dir="ltr">CREATE TABLE销售（acct_no NUMBER（5），acct_name CHAR（30），amount_of_sale NUMBER（6），week_no INTEGER，sale_details VARCHAR2（1000），PRIMARY KEY（acct_no，acct_name，week_no））组织索引包括week_no HASH的OVERFLOW PARTITION（ week_no）PARTITIONS 16 STORE IN（ts1，ts2，ts3，ts4）OVERFLOW STORE IN（ts3，ts6，ts9）;</pre></div>
                     <!-- class="example" -->
                  </div>
               </div><a id="VLDBG14068"></a><a id="VLDBG1115"></a><div class="props_rev_3"><a id="GUID-77B812A7-6427-429A-8AA7-099EB631FBF8" name="GUID-77B812A7-6427-429A-8AA7-099EB631FBF8"></a><h4 id="VLDBG-GUID-77B812A7-6427-429A-8AA7-099EB631FBF8" class="sect4">创建列表分区索引组织表</h4>
                  <div>
                     <p>分区索引组织表的另一个选项是使用list方法。</p>
                     <div class="section">
                        <p>在<a href="partition-create-tables-indexes.html#GUID-77B812A7-6427-429A-8AA7-099EB631FBF8__CHDEAGIJ">示例4-16中</a> ，按列表方法对<code class="codeph">sales</code>索引组织表进行分区。
                        </p>
                     </div>
                     <!-- class="section" -->
                     <div class="example" id="GUID-77B812A7-6427-429A-8AA7-099EB631FBF8__CHDEAGIJ">
                        <p class="titleinexample">示例4-16创建列表分区的索引组织表</p><pre class="oac_no_warn" dir="ltr">CREATE TABLE销售（acct_no NUMBER（5），acct_name CHAR（30），amount_of_sale NUMBER（6），week_no INTEGER，sale_details VARCHAR2（1000），PRIMARY KEY（acct_no，acct_name，week_no））包含week_no OVERFLOW TABLESPACE ts1 PARTITION BY的组织索引列表（week_no）（分区值（1,2,3,4）TABLESPACE ts2，分区值（5,6,7,8）表格ts3溢出表格ts4，分区值（默认）表格ts5）;</pre></div>
                     <!-- class="example" -->
                  </div>
               </div>
            </div><a id="VLDBG00306"></a><div class="props_rev_3"><a id="GUID-24050391-B7C5-4AE2-86D4-B5438412C3F6" name="GUID-24050391-B7C5-4AE2-86D4-B5438412C3F6"></a><h3 id="VLDBG-GUID-24050391-B7C5-4AE2-86D4-B5438412C3F6" class="sect3">多个块大小的分区限制</h3>
               <div>
                  <p>在具有不同块大小的表空间的数据库中创建分区对象时要小心。</p>
                  <p>在这样的表空间中存储分区对象受到一些限制。具体来说，以下实体的所有分区必须驻留在相同块大小的表空间中：</p>
                  <ul style="list-style-type:disc">
                     <li>
                        <p>常规表格</p>
                     </li>
                     <li>
                        <p>索引</p>
                     </li>
                     <li>
                        <p>索引组织表的主键索引段</p>
                     </li>
                     <li>
                        <p>索引组织表的溢出段</p>
                     </li>
                     <li>
                        <p><code class="codeph">LOB</code>列存储在行外</p>
                     </li>
                  </ul>
                  <p>因此：</p>
                  <ul style="list-style-type:disc">
                     <li>
                        <p>对于每个传统表，该表的所有分区必须存储在具有相同块大小的表空间中。</p>
                     </li>
                     <li>
                        <p>对于每个索引组织表，所有主键索引分区必须驻留在相同块大小的表空间中，并且该表的所有溢出分区必须驻留在具有相同块大小的表空间中。但是，索引分区和溢出分区可以驻留在不同块大小的表空间中。</p>
                     </li>
                     <li>
                        <p>对于每个索引（全局或本地），该索引的每个分区必须驻留在相同块大小的表空间中。但是，在同一对象上定义的不同索引的分区可以驻留在不同块大小的表空间中。</p>
                     </li>
                     <li>
                        <p>对于每个<code class="codeph">LOB</code>列，该列的每个分区必须存储在具有相等块大小的表空间中。但是，不同的<code class="codeph">LOB</code>列可以存储在不同块大小的表空间中。
                        </p>
                     </li>
                  </ul>
                  <p>创建或更改分区表或索引时，为每个实体的分区和子分区<span class="italic">显式指定的</span>所有表空间必须具有相同的块大小。如果<span class="italic">没有</span>为实体<span class="italic">显式指定</span>表空间存储，则默认情况下数据库使用的表空间必须具有相同的块大小。因此，您必须了解分区对象的每个级别的默认表空间。
                  </p>
               </div>
            </div><a id="VLDBG14069"></a><a id="VLDBG1116"></a><div class="props_rev_3"><a id="GUID-7F8EBE79-9FF2-4B2D-9764-C11263FA550F" name="GUID-7F8EBE79-9FF2-4B2D-9764-C11263FA550F"></a><h3 id="VLDBG-GUID-7F8EBE79-9FF2-4B2D-9764-C11263FA550F" class="sect3">XMLType和对象中的集合分区</h3>
               <div>
                  <p>使用<code class="codeph">XMLType</code>或对象表和列时的分区遵循分区的基本规则。
                  </p>
                  <div class="section">
                     <p>出于本讨论的目的，术语<span class="italic">集合</span> <span class="italic">表</span>用于以下两类：（1） <code class="codeph">XMLType</code>表或列内的有序集合表，以及（2）对象表或列内的嵌套表。
                     </p>
                     <p>分区收集表时，Oracle数据库使用基表的分区方案。此外，在对基表进行分区时，会自动对集合表进行分区。针对分区嵌套表的DML的行为方式与引用分区表的方式类似。</p>
                     <p></p>
                     <p>Oracle数据库提供了一个<code class="codeph">LOCAL</code>关键字，用于为Collection Table分配一个分区基表。这是此版本中的默认行为。早期版本中的默认设置不是将Collection Table与分区基表进行均分。现在，您必须指定<code class="codeph">GLOBAL</code>关键字以存储带有分区基表的未分区Collection表。
                     </p>
                     <p>支持外线（OOL）表分区。但是，您无法创建具有外联表的同一XML架构的两个表。此限制意味着无法对具有OOL表的模式执行交换分区，因为不可能有两个具有相同模式的表。</p>
                     <p>以下示例中的语句创建嵌套表分区。</p><pre class="oac_no_warn" dir="ltr">CREATE TABLE print_media_part（product_id NUMBER（6），ad_id NUMBER（6），ad_composite BLOB，ad_sourcetext CLOB，ad_finaltext CLOB，ad_fltextn NCLOB，ad_textdocs_ntab TEXTDOC_TAB，ad_photo BLOB，ad_graphic BFILE，ad_header ADHEADER_TYP）NESTED TABLE ad_textdocs_ntab STORE AS textdoc_nt PARTITION BY RANGE（ product_id）（PARPTION p1值小于（100），分区p2值小于（200））;</pre></div>
                  <!-- class="section" -->
                  <div class="section">
                     <div class="infoboxnotealso" id="GUID-7F8EBE79-9FF2-4B2D-9764-C11263FA550F__GUID-1F17EF1E-E5CF-438E-A8AD-E448E0D42922">
                        <p class="notep1">也可以看看：</p>
                        <ul style="list-style-type:disc">
                           <li>
                              <p><a href="partition-create-tables-indexes.html#GUID-4FE08BA2-9EE6-4987-BC31-1381B77B47E8" title="分区是否包含集合表不会显着影响您执行分区维护操作（PMO）的能力。">在包含集合表的</a> <a href="partition-create-tables-indexes.html#GUID-66FDEA3D-8076-44D9-8FD2-B6CA7D79F9AA" title="对于二进制XML表，XMLIndex使用范围，散列，列表，间隔和引用分区的基表进行分配。">分区上执行PMO以及为二进制XML表分区XMLIndex以</a>获取其他相关示例</p>
                           </li>
                           <li>
                              <p><a href="partition-pruning.html#GUID-88E16CEE-3CB1-4AD6-82B3-62B86B899A01" title="集合表可以限制优化程序执行修剪的能力。">集合表，</a>用于针对分区嵌套表发出查询并使用<code class="codeph">EXPLAIN</code> <code class="codeph">PLAN</code>提高性能的示例</p>
                           </li>
                           <li>
                              <p><a href="evolve-nopartition-table.html#GUID-6054142E-207A-4DF0-A62A-4C1A94DD36C4" title="您可以将非分区表更改为分区表。">将非分区表更改为分区表，</a>以获取有关使用联机重定义将现有非分区集合表转换为分区表的信息</p>
                           </li>
                           <li>
                              <p>有关<code class="codeph">CREATE</code> <code class="codeph">TABLE</code>语法的详细信息，请<a href="../sqlrf/CREATE-TABLE.html#SQLRF01402" target="_blank"><span><cite>参见Oracle数据库SQL语言参考</cite></span></a></p>
                           </li>
                        </ul>
                     </div>
                  </div>
                  <!-- class="section" -->
               </div><a id="VLDBG1117"></a><div class="props_rev_3"><a id="GUID-4FE08BA2-9EE6-4987-BC31-1381B77B47E8" name="GUID-4FE08BA2-9EE6-4987-BC31-1381B77B47E8"></a><h4 id="VLDBG-GUID-4FE08BA2-9EE6-4987-BC31-1381B77B47E8" class="sect4">在包含集合表的分区上执行PMO</h4>
                  <div>
                     <p>分区是否包含集合表不会显着影响您执行分区维护操作（PMO）的能力。</p>
                     <p>通常，Collection Tables上的维护操作在基表上执行。以下示例说明了基于前面嵌套表分区的典型<code class="codeph">ADD</code> <code class="codeph">PARTITION</code>操作：</p><pre class="oac_no_warn" dir="ltr">ALTER TABLE print_media_part添加分区p4值小于（400）LOB（ad_photo，ad_composite）STORE AS（TABLESPACE omf_ts1）LOB（ad_sourcetext，ad_finaltext）STORE AS（TABLESPACE omf_ts1）NESTED TABLE ad_textdocs_ntab STORE AS nt_p3;</pre><p>嵌套表存储列<code class="codeph">ad_textdocs_ntab</code>的存储表名为<code class="codeph">nt_p3</code>并从表级缺省值继承所有其他属性，然后从表空间缺省值继承。
                     </p>
                     <p>您必须直接在与集合列对应的存储表上调用以下分区维护操作：</p>
                     <ul style="list-style-type:disc">
                        <li>
                           <p>修改分区</p>
                        </li>
                        <li>
                           <p>移动分区</p>
                        </li>
                        <li>
                           <p>重命名分区</p>
                        </li>
                        <li>
                           <p>修改分区的默认属性</p>
                        </li>
                     </ul>
                     <div class="infoboxnotealso" id="GUID-4FE08BA2-9EE6-4987-BC31-1381B77B47E8__GUID-881AC37F-ED50-4CDF-A23C-2618A07B2BB2">
                        <p class="notep1">也可以看看：</p>
                        <ul style="list-style-type:disc">
                           <li>
                              <p>适用于<code class="codeph">ADD</code> <code class="codeph">PARTITION</code>语法的<a href="../sqlrf/ALTER-TABLE.html#SQLRF01001" target="_blank"><span><cite>Oracle数据库SQL语言参考</cite></span></a></p>
                           </li>
                           <li>
                              <p><a href="maintenance-partition-can-be-performed.html#GUID-79391819-DCEF-46AC-977D-199BD2044DA2" title="可以对分区，子分区和索引分区执行各种维护操作。">分区上支持</a>的维护操作，以获取可在分区表和组合分区表上执行的分区维护操作的列表</p>
                           </li>
                        </ul>
                        <p></p>
                     </div>
                  </div>
               </div><a id="VLDBG14104"></a><div class="props_rev_3"><a id="GUID-66FDEA3D-8076-44D9-8FD2-B6CA7D79F9AA" name="GUID-66FDEA3D-8076-44D9-8FD2-B6CA7D79F9AA"></a><h4 id="VLDBG-GUID-66FDEA3D-8076-44D9-8FD2-B6CA7D79F9AA" class="sect4">二进制XML表的XMLIndex分区</h4>
                  <div>
                     <p>对于二进制XML表，XMLIndex使用范围，散列，列表，间隔和引用分区的基表进行分配。</p>
                     <div class="section">
                        <p>在以下示例中，将在范围分区表上创建XMLIndex。</p><pre class="oac_no_warn" dir="ltr">CREATE TABLE purchase_order（id NUMBER，doc XMLTYPE）PARTITION BY RANGE（id）（PARTITION p1值小于（10），PARTITION p2 VALUES小于（MAXVALUE））; CREATE INDEX purchase_order_idx ON purchase_order（doc）INDEXTYPE IS XDB.XMLINDEX LOCAL;</pre><div class="infoboxnotealso" id="GUID-66FDEA3D-8076-44D9-8FD2-B6CA7D79F9AA__GUID-2FE00C53-0CD4-4D2D-ADE5-1BA21334FC0D">
                           <p class="notep1">也可以看看：</p>
                           <ul style="list-style-type:disc">
                              <li>
                                 <p><a href="../addci/introduction-to-data-cartridges.html#ADDCI110" target="_blank"><span><cite>Oracle数据库数据盒开发人员指南</cite></span></a> ，了解有关Oracle XML DB的信息以及用于二进制XML表的XMLIndex分区</p>
                              </li>
                              <li>
                                 <p>有关XMLIndex的信息，请参阅<a href="../adxdb/indexes-for-XMLType-data.html#ADXDB0500" target="_blank"><span class="italic">Oracle XML DB Developer's Guide</span></a></p>
                              </li>
                              <li>
                                 <p>有关分区XMLType表和列的信息，请参见<a href="../adxdb/XML-Schema-and-query-object-relational-storage.html#ADXDB4630" target="_blank"><span class="italic">Oracle XML DB Developer's Guide</span></a></p>
                              </li>
                           </ul>
                        </div>
                     </div>
                     <!-- class="section" -->
                  </div>
               </div>
            </div>
         </div>
      </article>
   </body>
</html>