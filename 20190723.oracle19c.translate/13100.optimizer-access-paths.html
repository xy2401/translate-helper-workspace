<!DOCTYPE html
  SYSTEM "about:legacy-compat">
<html xml:lang="en-us" lang="en-us">
   <head>
      <meta http-equiv="Content-Type" content="text/html; charset=utf-8">
      <meta name="viewport" content="width=device-width, initial-scale=1">
      <meta http-equiv="X-UA-Compatible" content="IE=edge">
      <meta name="abstract" content="An access path is a technique used by a query to retrieve rows from a row source.">
      <meta name="description" content="An access path is a technique used by a query to retrieve rows from a row source.">
      <title>Optimizer Access Paths</title>
      <meta property="og:site_name" content="Oracle Help Center">
      <meta property="og:title" content="SQL Tuning Guide">
      <meta property="og:description" content="An access path is a technique used by a query to retrieve rows from a row source.">
      <link rel="stylesheet" href="/sp_common/book-template/ohc-book-template/css/book.css">
      <link rel="shortcut icon" href="/sp_common/book-template/ohc-common/img/favicon.ico">
      <meta name="application-name" content="SQL Tuning Guide">
      <meta name="generator" content="DITA Open Toolkit version 1.8.5 (Mode = doc)">
      <meta name="plugin" content="SP_docbuilder HTML plugin release 18.2.2">
      <link rel="alternate" href="sql-tuning-guide.pdf" title="PDF File" type="application/pdf">
      <meta name="robots" content="all">
      <link rel="schema.dcterms" href="http://purl.org/dc/terms/">
      <meta name="dcterms.created" content="2019-01-31T14:57:08-08:00">
      <meta name="dcterms.title" content="SQL Tuning Guide">
      <meta name="dcterms.dateCopyrighted" content="2013, 2019">
      <meta name="dcterms.category" content="database">
      <meta name="dcterms.identifier" content="E96095-03">
      
      <meta name="dcterms.product" content="en/database/oracle/oracle-database/19">
      
      <link rel="prev" href="sql-operators.html" title="Previous" type="text/html">
      <link rel="next" href="joins.html" title="Next" type="text/html">
      <script>
        document.write('<style type="text/css">');
        document.write('body > .noscript, body > .noscript ~ * { visibility: hidden; }');
        document.write('</style>');
     </script>
      <script data-main="/sp_common/book-template/ohc-book-template/js/book-config" src="/sp_common/book-template/requirejs/require.js"></script>
      <script>
            if (window.require === undefined) {
                document.write('<script data-main="sp_common/book-template/ohc-book-template/js/book-config" src="sp_common/book-template/requirejs/require.js"><\/script>');
                document.write('<link href="sp_common/book-template/ohc-book-template/css/book.css" rel="stylesheet"/>');
            }
        </script>
      <script type="application/json" id="ssot-metadata">{"primary":{"category":{"short_name":"database","element_name":"Database","display_in_url":true},"suite":{"short_name":"oracle","element_name":"Oracle","display_in_url":true},"product_group":{"short_name":"not-applicable","element_name":"Not applicable","display_in_url":false},"product":{"short_name":"oracle-database","element_name":"Oracle Database","display_in_url":true},"release":{"short_name":"19","element_name":"Release 19","display_in_url":true}}}</script>
      
    <meta name="dcterms.isVersionOf" content="TGSQL">
    <meta name="dcterms.release" content="Release 19">
  </head>
   <body>
      <div class="noscript alert alert-danger text-center" role="alert">
         <a href="sql-operators.html" class="pull-left"><span class="glyphicon glyphicon-chevron-left" aria-hidden="true"></span>Previous</a>
         <a href="joins.html" class="pull-right">Next<span class="glyphicon glyphicon-chevron-right" aria-hidden="true"></span></a>
         <span class="fa fa-exclamation-triangle" aria-hidden="true"></span> JavaScript must be enabled to correctly display this content
        
      </div>
      <article>
         <header>
            <ol class="breadcrumb" vocab="http://schema.org/" typeof="BreadcrumbList">
               <li property="itemListElement" typeof="ListItem"><a href="index.html" property="item" typeof="WebPage"><span property="name">SQL Tuning Guide</span></a></li>
               <li property="itemListElement" typeof="ListItem"><a href="sql-operators.html" property="item" typeof="WebPage"><span property="name">SQL Operators: Access Paths and Joins</span></a></li>
               <li class="active" property="itemListElement" typeof="ListItem">Optimizer Access Paths</li>
            </ol>
            <a id="GUID-00711237-35D3-4CFC-A234-59B3EC53DCD1" name="GUID-00711237-35D3-4CFC-A234-59B3EC53DCD1"></a><a id="TGSQL228"></a>
            
            <h2 id="TGSQL-GUID-00711237-35D3-4CFC-A234-59B3EC53DCD1" class="sect2"><span class="enumeration_chapter">8 </span>Optimizer Access Paths
            </h2>
         </header>
         <div class="ind">
            <div>
               <p>An <strong class="term">access path</strong> is a technique used by a query to retrieve rows from a row source.
               </p>
               <p>This chapter contains the following topics:</p>
            </div>
            <div>
               <ul class="ullinks">
                  <li class="ulchildlink"><a href="optimizer-access-paths.html#GUID-CDC8B946-2375-4E5F-B50E-DE1E79EAE4CD">Introduction to Access Paths</a><br>A <strong class="term">row source</strong> is a set of rows returned by a step in an execution plan. A row source can be a table, view, or result of a join or grouping operation. 
                  </li>
                  <li class="ulchildlink"><a href="optimizer-access-paths.html#GUID-5594AB70-F3C1-49BA-88ED-0B2011791365">Table Access Paths</a><br>A table is the basic unit of data organization in an Oracle database. 
                  </li>
                  <li class="ulchildlink"><a href="optimizer-access-paths.html#GUID-B33945C3-CCC0-4D35-AF62-DB80FD4256A6">B-Tree Index Access Paths</a><br>An <strong class="term">index</strong> is an optional structure, associated with a table or table cluster, that can sometimes speed data access.
                  </li>
                  <li class="ulchildlink"><a href="optimizer-access-paths.html#GUID-B5E41901-933E-4A31-B5D6-9771FD435EC0">Bitmap Index Access Paths</a><br>Bitmap indexes combine the indexed data with a rowid range.
                  </li>
                  <li class="ulchildlink"><a href="optimizer-access-paths.html#GUID-4D114CC6-15A8-4CE0-A826-4E53DFD184CA">Table Cluster Access Paths</a><br>A <strong class="term">table cluster</strong> is a group of tables that share common columns and store related data in the same blocks. When tables are clustered, a single data block can contain rows from multiple tables.
                  </li>
               </ul>
               <div class="familylinks">
                  <div class="parentlink">
                     <p><strong>Parent topic:</strong> <a href="sql-operators.html#GUID-37BA8AC8-B8F5-402E-8398-552AFDACED8E" title="A row source is a set of rows returned by a step in the execution plan. A SQL operator acts on a row source.">SQL Operators: Access Paths and Joins</a></p>
                  </div>
               </div>
            </div>
            <a id="TGSQL94943"></a><a id="TGSQL229"></a><div class="props_rev_3"><a id="GUID-CDC8B946-2375-4E5F-B50E-DE1E79EAE4CD" name="GUID-CDC8B946-2375-4E5F-B50E-DE1E79EAE4CD"></a><h3 id="TGSQL-GUID-CDC8B946-2375-4E5F-B50E-DE1E79EAE4CD" class="sect3"><span class="enumeration_section">8.1 </span>Introduction to Access Paths
               </h3>
               <div>
                  <p>A <strong class="term">row source</strong> is a set of rows returned by a step in an execution plan. A row source can be a table, view, or result of a join or grouping operation. 
                  </p>
                  <p>A unary operation such as an <a href="glossary.html#GUID-22DF198C-4310-4307-BF29-DCE765725BD4"><span class="xrefglossterm">access path</span></a>, which is a technique used by a query to retrieve rows from a row source, accepts a single row source as input. For example, a full table scan is the retrieval of rows of a single row source. In contrast, a join is binary and receives inputs from exactly two row sources
                  </p>
                  <p>The database uses different access paths for different relational data structures. The following table summarizes common access paths for the major data structures.</p>
                  <div class="tblformalwide" id="GUID-CDC8B946-2375-4E5F-B50E-DE1E79EAE4CD__CHDBEIFB">
                     <p class="titleintable">Table 8-1 Data Structures and Access Paths</p>
                     <table cellpadding="4" cellspacing="0" class="FormalWide" title="Data Structures and Access Paths" summary="Access paths" width="100%" frame="hsides" border="1" rules="rows">
                        <thead>
                           <tr align="left" valign="top">
                              <th align="left" valign="bottom" width="27%" id="d37861e302">Access Path</th>
                              <th align="left" valign="bottom" width="18%" id="d37861e305">Heap-Organized Tables</th>
                              <th align="left" valign="bottom" width="18%" id="d37861e308">B-Tree Indexes and IOTs</th>
                              <th align="left" valign="bottom" width="18%" id="d37861e311">Bitmap Indexes</th>
                              <th align="left" valign="bottom" width="18%" id="d37861e314">Table Clusters</th>
                           </tr>
                        </thead>
                        <tbody>
                           <tr align="left" valign="top">
                              <td align="left" valign="top" width="27%" id="d37861e319" headers="d37861e302 ">
                                 <p><a href="optimizer-access-paths.html#GUID-461E7071-2229-4F60-82E6-BC4F6FC8D23B" title="A full table scan reads all rows from a table, and then filters out those rows that do not meet the selection criteria.">Full Table Scans</a></p>
                              </td>
                              <td align="left" valign="top" width="18%" headers="d37861e319 d37861e305 ">
                                 <p>x</p>
                              </td>
                              <td align="left" valign="top" width="18%" headers="d37861e319 d37861e308 ">
                                 <p></p>
                              </td>
                              <td align="left" valign="top" width="18%" headers="d37861e319 d37861e311 ">
                                 <p></p>
                              </td>
                              <td align="left" valign="top" width="18%" headers="d37861e319 d37861e314 ">
                                 <p></p>
                              </td>
                           </tr>
                           <tr align="left" valign="top">
                              <td align="left" valign="top" width="27%" id="d37861e339" headers="d37861e302 ">
                                 <p><a href="optimizer-access-paths.html#GUID-4180BA97-3E2C-41F9-B282-4FB3FF9532CB" title="A rowid is an internal representation of the storage location of data.">Table Access by Rowid</a></p>
                              </td>
                              <td align="left" valign="top" width="18%" headers="d37861e339 d37861e305 ">
                                 <p>x</p>
                              </td>
                              <td align="left" valign="top" width="18%" headers="d37861e339 d37861e308 ">
                                 <p></p>
                              </td>
                              <td align="left" valign="top" width="18%" headers="d37861e339 d37861e311 ">
                                 <p></p>
                              </td>
                              <td align="left" valign="top" width="18%" headers="d37861e339 d37861e314 ">
                                 <p></p>
                              </td>
                           </tr>
                           <tr align="left" valign="top">
                              <td align="left" valign="top" width="27%" id="d37861e359" headers="d37861e302 ">
                                 <p><a href="optimizer-access-paths.html#GUID-720EA54F-AB65-4379-99A3-CAE166590127" title="A sample table scan retrieves a random sample of data from a simple table or a complex SELECT statement, such as a statement involving joins and views.">Sample Table Scans</a></p>
                              </td>
                              <td align="left" valign="top" width="18%" headers="d37861e359 d37861e305 ">
                                 <p>x</p>
                              </td>
                              <td align="left" valign="top" width="18%" headers="d37861e359 d37861e308 ">
                                 <p></p>
                              </td>
                              <td align="left" valign="top" width="18%" headers="d37861e359 d37861e311 ">
                                 <p></p>
                              </td>
                              <td align="left" valign="top" width="18%" headers="d37861e359 d37861e314 ">
                                 <p></p>
                              </td>
                           </tr>
                           <tr align="left" valign="top">
                              <td align="left" valign="top" width="27%" id="d37861e382" headers="d37861e302 ">
                                 <p><a href="optimizer-access-paths.html#GUID-273588A7-A8E9-4E1E-BE35-060073533B47" title="An index unique scan returns at most 1 rowid.">Index Unique Scans</a></p>
                              </td>
                              <td align="left" valign="top" width="18%" headers="d37861e382 d37861e305 ">
                                 <p></p>
                              </td>
                              <td align="left" valign="top" width="18%" headers="d37861e382 d37861e308 ">
                                 <p>x</p>
                              </td>
                              <td align="left" valign="top" width="18%" headers="d37861e382 d37861e311 ">
                                 <p></p>
                              </td>
                              <td align="left" valign="top" width="18%" headers="d37861e382 d37861e314 ">
                                 <p></p>
                              </td>
                           </tr>
                           <tr align="left" valign="top">
                              <td align="left" valign="top" width="27%" id="d37861e402" headers="d37861e302 ">
                                 <p><a href="optimizer-access-paths.html#GUID-E2353939-DFBD-444A-94BC-2497E2A418D1" title="An index range scan is an ordered scan of values.">Index Range Scans</a></p>
                              </td>
                              <td align="left" valign="top" width="18%" headers="d37861e402 d37861e305 ">
                                 <p></p>
                              </td>
                              <td align="left" valign="top" width="18%" headers="d37861e402 d37861e308 ">
                                 <p>x</p>
                              </td>
                              <td align="left" valign="top" width="18%" headers="d37861e402 d37861e311 ">
                                 <p></p>
                              </td>
                              <td align="left" valign="top" width="18%" headers="d37861e402 d37861e314 ">
                                 <p></p>
                              </td>
                           </tr>
                           <tr align="left" valign="top">
                              <td align="left" valign="top" width="27%" id="d37861e422" headers="d37861e302 ">
                                 <p><a href="optimizer-access-paths.html#GUID-3D9D3DBD-CF89-4320-8C5E-6BE6A127AC39" title="An index full scan reads the entire index in order. An index full scan can eliminate a separate sorting operation because the data in the index is ordered by index key.">Index Full Scans</a></p>
                              </td>
                              <td align="left" valign="top" width="18%" headers="d37861e422 d37861e305 ">
                                 <p></p>
                              </td>
                              <td align="left" valign="top" width="18%" headers="d37861e422 d37861e308 ">
                                 <p>x</p>
                              </td>
                              <td align="left" valign="top" width="18%" headers="d37861e422 d37861e311 ">
                                 <p></p>
                              </td>
                              <td align="left" valign="top" width="18%" headers="d37861e422 d37861e314 ">
                                 <p></p>
                              </td>
                           </tr>
                           <tr align="left" valign="top">
                              <td align="left" valign="top" width="27%" id="d37861e442" headers="d37861e302 ">
                                 <p><a href="optimizer-access-paths.html#GUID-A2F2A81F-4626-45A1-B2A6-D46107E74C3C" title="An index fast full scan reads the index blocks in unsorted order, as they exist on disk. This scan does not use the index to probe the table, but reads the index instead of the table, essentially using the index itself as a table.">Index Fast Full Scans</a></p>
                              </td>
                              <td align="left" valign="top" width="18%" headers="d37861e442 d37861e305 ">
                                 <p></p>
                              </td>
                              <td align="left" valign="top" width="18%" headers="d37861e442 d37861e308 ">
                                 <p>x</p>
                              </td>
                              <td align="left" valign="top" width="18%" headers="d37861e442 d37861e311 ">
                                 <p></p>
                              </td>
                              <td align="left" valign="top" width="18%" headers="d37861e442 d37861e314 ">
                                 <p></p>
                              </td>
                           </tr>
                           <tr align="left" valign="top">
                              <td align="left" valign="top" width="27%" id="d37861e462" headers="d37861e302 ">
                                 <p><a href="optimizer-access-paths.html#GUID-B7C62F0F-EB7C-422C-919D-D86456A74A60" title="An index skip scan occurs when the initial column of a composite index is "skipped" or not specified in the query.">Index Skip Scans</a></p>
                              </td>
                              <td align="left" valign="top" width="18%" headers="d37861e462 d37861e305 ">
                                 <p></p>
                              </td>
                              <td align="left" valign="top" width="18%" headers="d37861e462 d37861e308 ">
                                 <p>x</p>
                              </td>
                              <td align="left" valign="top" width="18%" headers="d37861e462 d37861e311 ">
                                 <p></p>
                              </td>
                              <td align="left" valign="top" width="18%" headers="d37861e462 d37861e314 ">
                                 <p></p>
                              </td>
                           </tr>
                           <tr align="left" valign="top">
                              <td align="left" valign="top" width="27%" id="d37861e482" headers="d37861e302 ">
                                 <p><a href="optimizer-access-paths.html#GUID-21258F63-7506-4019-9FB4-323E9D2DE087" title="An index join scan is a hash join of multiple indexes that together return all columns requested by a query. The database does not need to access the table because all data is retrieved from the indexes.">Index Join Scans</a></p>
                              </td>
                              <td align="left" valign="top" width="18%" headers="d37861e482 d37861e305 ">
                                 <p></p>
                              </td>
                              <td align="left" valign="top" width="18%" headers="d37861e482 d37861e308 ">
                                 <p>x</p>
                              </td>
                              <td align="left" valign="top" width="18%" headers="d37861e482 d37861e311 ">
                                 <p></p>
                              </td>
                              <td align="left" valign="top" width="18%" headers="d37861e482 d37861e314 ">
                                 <p></p>
                              </td>
                           </tr>
                           <tr align="left" valign="top">
                              <td align="left" valign="top" width="27%" id="d37861e499" headers="d37861e302 ">
                                 <p><a href="optimizer-access-paths.html#GUID-E8F4A411-10BE-4D5E-9207-0D5F8E61A8E0" title="This type of access path uses a bitmap index to look up a single key value.">Bitmap Index Single Value</a></p>
                              </td>
                              <td align="left" valign="top" width="18%" headers="d37861e499 d37861e305 ">
                                 <p></p>
                              </td>
                              <td align="left" valign="top" width="18%" headers="d37861e499 d37861e308 ">
                                 <p></p>
                              </td>
                              <td align="left" valign="top" width="18%" headers="d37861e499 d37861e311 ">
                                 <p>x</p>
                              </td>
                              <td align="left" valign="top" width="18%" headers="d37861e499 d37861e314 ">
                                 <p></p>
                              </td>
                           </tr>
                           <tr align="left" valign="top">
                              <td align="left" valign="top" width="27%" id="d37861e516" headers="d37861e302 ">
                                 <p><a href="optimizer-access-paths.html#GUID-9123D7CE-90DC-4C96-AB4F-49FD0227C40B" title="This type of access path uses a bitmap index to look up a range of values.">Bitmap Index Range Scans</a></p>
                              </td>
                              <td align="left" valign="top" width="18%" headers="d37861e516 d37861e305 ">
                                 <p></p>
                              </td>
                              <td align="left" valign="top" width="18%" headers="d37861e516 d37861e308 ">
                                 <p></p>
                              </td>
                              <td align="left" valign="top" width="18%" headers="d37861e516 d37861e311 ">
                                 <p>x</p>
                              </td>
                              <td align="left" valign="top" width="18%" headers="d37861e516 d37861e314 ">
                                 <p></p>
                              </td>
                           </tr>
                           <tr align="left" valign="top">
                              <td align="left" valign="top" width="27%" id="d37861e534" headers="d37861e302 ">
                                 <p><a href="optimizer-access-paths.html#GUID-2FDE5904-B0BC-44DA-829B-94C89FA77D71" title="This access path merges multiple bitmaps, and returns a single bitmap as a result.">Bitmap Merge</a></p>
                              </td>
                              <td align="left" valign="top" width="18%" headers="d37861e534 d37861e305 ">
                                 <p></p>
                              </td>
                              <td align="left" valign="top" width="18%" headers="d37861e534 d37861e308 ">
                                 <p></p>
                              </td>
                              <td align="left" valign="top" width="18%" headers="d37861e534 d37861e311 ">
                                 <p>x</p>
                              </td>
                              <td align="left" valign="top" width="18%" headers="d37861e534 d37861e314 ">
                                 <p></p>
                              </td>
                           </tr>
                           <tr align="left" valign="top">
                              <td align="left" valign="top" width="27%" id="d37861e551" headers="d37861e302 ">
                                 <p>Bitmap Index Range Scans</p>
                              </td>
                              <td align="left" valign="top" width="18%" headers="d37861e551 d37861e305 ">
                                 <p></p>
                              </td>
                              <td align="left" valign="top" width="18%" headers="d37861e551 d37861e308 ">
                                 <p></p>
                              </td>
                              <td align="left" valign="top" width="18%" headers="d37861e551 d37861e311 ">
                                 <p>x</p>
                              </td>
                              <td align="left" valign="top" width="18%" headers="d37861e551 d37861e314 ">
                                 <p></p>
                              </td>
                           </tr>
                           <tr align="left" valign="top">
                              <td align="left" valign="top" width="27%" id="d37861e564" headers="d37861e302 ">
                                 <p><a href="optimizer-access-paths.html#GUID-DB9438B3-6FA1-4EE9-A782-3DD271A59285" title="An index cluster is a table cluster that uses an index to locate data.">Cluster Scans</a></p>
                              </td>
                              <td align="left" valign="top" width="18%" headers="d37861e564 d37861e305 ">
                                 <p></p>
                              </td>
                              <td align="left" valign="top" width="18%" headers="d37861e564 d37861e308 ">
                                 <p></p>
                              </td>
                              <td align="left" valign="top" width="18%" headers="d37861e564 d37861e311 ">
                                 <p></p>
                              </td>
                              <td align="left" valign="top" width="18%" headers="d37861e564 d37861e314 ">
                                 <p>x</p>
                              </td>
                           </tr>
                           <tr align="left" valign="top">
                              <td align="left" valign="top" width="27%" id="d37861e584" headers="d37861e302 ">
                                 <p><a href="optimizer-access-paths.html#GUID-8CBC58C9-A82E-4A2A-B2C1-5A728C4F4726" title="A hash cluster is like an indexed cluster, except the index key is replaced with a hash function. No separate cluster index exists.">Hash Scans</a></p>
                              </td>
                              <td align="left" valign="top" width="18%" headers="d37861e584 d37861e305 ">
                                 <p></p>
                              </td>
                              <td align="left" valign="top" width="18%" headers="d37861e584 d37861e308 ">
                                 <p></p>
                              </td>
                              <td align="left" valign="top" width="18%" headers="d37861e584 d37861e311 ">
                                 <p></p>
                              </td>
                              <td align="left" valign="top" width="18%" headers="d37861e584 d37861e314 ">
                                 <p>x</p>
                              </td>
                           </tr>
                        </tbody>
                     </table>
                  </div>
                  <!-- class="inftblhruleinformal" -->
                  <p>The optimizer considers different possible execution plans, and then assigns each plan a <a href="glossary.html#GUID-7FCF0F80-65B5-4F76-A521-91ABD109DA17"><span class="xrefglossterm">cost</span></a>. The optimizer chooses the plan with the lowest cost. In general, index access paths are more efficient for statements that retrieve a small subset of table rows, whereas full table scans are more efficient when accessing a large portion of a table.
                  </p>
               </div>
               <div>
                  <div class="infoboxnotealso" id="GUID-CDC8B946-2375-4E5F-B50E-DE1E79EAE4CD__GUID-D7E0ABDA-3F46-4FA9-912F-1A82B9DF0B7E">
                     <p class="notep1">See Also:</p>
                     <ul style="list-style-type: disc;">
                        <li>
                           <p><span class="q">"<a href="joins.html#GUID-BD96F1B4-76D4-43DF-98B6-D07F46838C4A" title="Oracle Database provides several optimizations for joining row sets.">Joins</a>"</span></p>
                        </li>
                        <li>
                           <p><span class="q">"<a href="query-optimizer-concepts.html#GUID-B743F9BE-9971-4CD1-8C0C-0EAF7C80E5F2" title="Query optimization is the process of choosing the most efficient means of executing a SQL statement.">Cost-Based Optimization</a>"</span></p>
                        </li>
                        <li>
                           <p><a href="../cncpt/oracle-relational-structures.html#CNCPT88798" target="_blank"><span><cite>Oracle Database Concepts</cite></span></a> for an overview of these structures
                           </p>
                        </li>
                     </ul>
                  </div>
                  <div class="familylinks">
                     <div class="parentlink">
                        <p><strong>Parent topic:</strong> <a href="optimizer-access-paths.html#GUID-00711237-35D3-4CFC-A234-59B3EC53DCD1" title="An access path is a technique used by a query to retrieve rows from a row source.">Optimizer Access Paths</a></p>
                     </div>
                  </div>
               </div>
               
            </div><a id="TGSQL230"></a><div class="props_rev_3"><a id="GUID-5594AB70-F3C1-49BA-88ED-0B2011791365" name="GUID-5594AB70-F3C1-49BA-88ED-0B2011791365"></a><h3 id="TGSQL-GUID-5594AB70-F3C1-49BA-88ED-0B2011791365" class="sect3"><span class="enumeration_section">8.2 </span>Table Access Paths
               </h3>
               <div>
                  <p>A table is the basic unit of data organization in an Oracle database. </p>
                  <p>Relational tables are the most common table type. Relational tables have with the following organizational characteristics:</p>
                  <ul style="list-style-type: disc;">
                     <li>
                        <p>A <a href="glossary.html#GUID-04AD2CD1-66B1-4CFF-93EA-4ACAABAF18F3"><span class="xrefglossterm">heap-organized table</span></a> does not store rows in any particular order. 
                        </p>
                     </li>
                     <li>
                        <p>An <a href="glossary.html#GUID-B4FADC41-B1BD-48E6-BCB6-D0D3E34928B1"><span class="xrefglossterm">index-organized table</span></a> orders rows according to the primary key values.
                        </p>
                     </li>
                     <li>
                        <p>An <a href="glossary.html#GUID-02DC6035-1B32-4E92-8961-9DA5457A9EC8"><span class="xrefglossterm">external table</span></a> is a read-only table whose metadata is stored in the database but whose data is stored outside the database.
                        </p>
                     </li>
                  </ul>
                  <p>This section explains optimizer access paths for heap-organized tables, and contains the following topics:</p>
               </div>
               <div>
                  <ul class="ullinks">
                     <li class="ulchildlink"><a href="optimizer-access-paths.html#GUID-53905BCD-3EAD-4B44-8CCC-C442A80647E8">About Heap-Organized Table Access</a><br>By default, a table is organized as a heap, which means that the database places rows where they fit best rather than in a user-specified order. 
                     </li>
                     <li class="ulchildlink"><a href="optimizer-access-paths.html#GUID-461E7071-2229-4F60-82E6-BC4F6FC8D23B">Full Table Scans</a><br>A <strong class="term">full table scan</strong> reads all rows from a table, and then filters out those rows that do not meet the selection criteria.
                     </li>
                     <li class="ulchildlink"><a href="optimizer-access-paths.html#GUID-4180BA97-3E2C-41F9-B282-4FB3FF9532CB">Table Access by Rowid</a><br>A <strong class="term">rowid</strong> is an internal representation of the storage location of data.
                     </li>
                     <li class="ulchildlink"><a href="optimizer-access-paths.html#GUID-720EA54F-AB65-4379-99A3-CAE166590127">Sample Table Scans</a><br>A <strong class="term">sample table scan</strong> retrieves a random sample of data from a simple table or a complex <code class="codeph">SELECT</code> statement, such as a statement involving joins and views.
                     </li>
                     <li class="ulchildlink"><a href="optimizer-access-paths.html#GUID-E699E03C-2689-4B56-B303-8E8529C5D99E">In-Memory Table Scans</a><br>An <strong class="term">In-Memory scan</strong> retrieves rows from the In-Memory Column Store (IM column store). 
                     </li>
                  </ul>
                  <div class="infoboxnotealso" id="GUID-5594AB70-F3C1-49BA-88ED-0B2011791365__GUID-9C775604-EBBA-4AAF-88AB-A4B677BEC52D">
                     <p class="notep1">See Also:</p>
                     <ul style="list-style-type: disc;">
                        <li>
                           <p><a href="https://www.oracle.com/pls/topic/lookup?ctx=en/database/oracle/oracle-database/19/tgsql&amp;id=CNCPT211" target="_blank"><span><cite>Oracle Database Concepts</cite></span></a> for an overview of tables
                           </p>
                        </li>
                        <li>
                           <p><a href="https://www.oracle.com/pls/topic/lookup?ctx=en/database/oracle/oracle-database/19/tgsql&amp;id=ADMIN015" target="_blank"><span><cite>Oracle Database Administrator’s Guide</cite></span></a> to learn how to manage tables
                           </p>
                        </li>
                     </ul>
                  </div>
                  <div class="familylinks">
                     <div class="parentlink">
                        <p><strong>Parent topic:</strong> <a href="optimizer-access-paths.html#GUID-00711237-35D3-4CFC-A234-59B3EC53DCD1" title="An access path is a technique used by a query to retrieve rows from a row source.">Optimizer Access Paths</a></p>
                     </div>
                  </div>
               </div>
               <a id="TGSQL95143"></a><div class="props_rev_3"><a id="GUID-53905BCD-3EAD-4B44-8CCC-C442A80647E8" name="GUID-53905BCD-3EAD-4B44-8CCC-C442A80647E8"></a><h4 id="TGSQL-GUID-53905BCD-3EAD-4B44-8CCC-C442A80647E8" class="sect4"><span class="enumeration_section">8.2.1 </span>About Heap-Organized Table Access
                  </h4>
                  <div>
                     <p>By default, a table is organized as a heap, which means that the database places rows where they fit best rather than in a user-specified order. </p>
                     <p>As users add rows, the database places the rows in the first available free space in the data segment. Rows are not guaranteed to be retrieved in the order in which they were inserted.</p>
                     <p>This section contains the following topics:</p>
                  </div>
                  <div>
                     <ul class="ullinks">
                        <li class="ulchildlink"><a href="optimizer-access-paths.html#GUID-EA472E2B-C155-4510-80AA-3E033C7C74AA">Row Storage in Data Blocks and Segments: A Primer</a><br>The database stores rows in data blocks. In tables, the database can write a row anywhere in the bottom part of the block. Oracle Database uses the block overhead, which contains the row directory and table directory, to manage the block itself.
                        </li>
                        <li class="ulchildlink"><a href="optimizer-access-paths.html#GUID-4D0E9BF1-2A89-4CB4-A165-936C656BD48E">Importance of Rowids for Row Access</a><br>Every row in a heap-organized table has a rowid unique to this table that corresponds to the physical address of a row piece. A rowid is a 10-byte physical address of a row.
                        </li>
                        <li class="ulchildlink"><a href="optimizer-access-paths.html#GUID-1F4CDA9A-7419-44F6-89E0-395C92285015">Direct Path Reads</a><br>In a <strong class="term">direct path read</strong>, the database reads buffers from disk directly into the PGA, bypassing the SGA entirely. 
                        </li>
                     </ul>
                     <div class="familylinks">
                        <div class="parentlink">
                           <p><strong>Parent topic:</strong> <a href="optimizer-access-paths.html#GUID-5594AB70-F3C1-49BA-88ED-0B2011791365" title="A table is the basic unit of data organization in an Oracle database.">Table Access Paths</a></p>
                        </div>
                     </div>
                  </div>
                  <a id="TGSQL95144"></a><div class="props_rev_3"><a id="GUID-EA472E2B-C155-4510-80AA-3E033C7C74AA" name="GUID-EA472E2B-C155-4510-80AA-3E033C7C74AA"></a><h5 id="TGSQL-GUID-EA472E2B-C155-4510-80AA-3E033C7C74AA" class="sect5"><span class="enumeration_section">8.2.1.1 </span>Row Storage in Data Blocks and Segments: A Primer
                     </h5>
                     <div>
                        <p>The database stores rows in data blocks. In tables, the database can write a row anywhere in the bottom part of the block. Oracle Database uses the block overhead, which contains the row directory and table directory, to manage the block itself.</p>
                        <p>An extent is made up of logically contiguous data blocks. The blocks may not be physically contiguous on disk. A segment is a set of extents that contains all the data for a logical storage structure within a tablespace. For example, Oracle Database allocates one or more extents to form the data segment for a table. The database also allocates one or more extents to form the index segment for a table.</p>
                        <p>By default, the database uses automatic segment space management (ASSM) for permanent, locally managed tablespaces. When a session first inserts data into a table, the database formats a bitmap block. The bitmap tracks the blocks in the segment. The database uses the bitmap to find free blocks and then formats each block before writing to it. ASSM spread out inserts among blocks to avoid concurrency issues.</p>
                        <p>The high water mark (HWM) is the point in a segment beyond which data blocks are unformatted and have never been used. Below the HWM, a block may be formatted and written to, formatted and empty, or unformatted. The low high water mark (low HWM) marks the point below which all blocks are known to be formatted because they either contain data or formerly contained data. </p>
                        <p>During a full table scan, the database reads all blocks up to the low HWM, which are known to be formatted, and then reads the segment bitmap to determine which blocks between the HWM and low HWM are formatted and safe to read. The database knows not to read past the HWM because these blocks are unformatted.</p>
                     </div>
                     <div>
                        <div class="infoboxnotealso" id="GUID-EA472E2B-C155-4510-80AA-3E033C7C74AA__GUID-F33A8345-E61E-4739-BDB0-C19185340131">
                           <p class="notep1">See Also:</p>
                           <p><a href="../cncpt/logical-storage-structures.html#CNCPT302" target="_blank"><span><cite>Oracle Database Concepts</cite></span></a> to learn about data block storage
                           </p>
                        </div>
                        <div class="familylinks">
                           <div class="parentlink">
                              <p><strong>Parent topic:</strong> <a href="optimizer-access-paths.html#GUID-53905BCD-3EAD-4B44-8CCC-C442A80647E8" title="By default, a table is organized as a heap, which means that the database places rows where they fit best rather than in a user-specified order.">About Heap-Organized Table Access</a></p>
                           </div>
                        </div>
                     </div>
                     
                  </div><a id="TGSQL95145"></a><div class="props_rev_3"><a id="GUID-4D0E9BF1-2A89-4CB4-A165-936C656BD48E" name="GUID-4D0E9BF1-2A89-4CB4-A165-936C656BD48E"></a><h5 id="TGSQL-GUID-4D0E9BF1-2A89-4CB4-A165-936C656BD48E" class="sect5"><span class="enumeration_section">8.2.1.2 </span>Importance of Rowids for Row Access
                     </h5>
                     <div>
                        <p>Every row in a heap-organized table has a rowid unique to this table that corresponds to the physical address of a row piece. A rowid is a 10-byte physical address of a row.</p>
                        <p>The rowid points to a specific file, block, and row number. For example, in the rowid <code class="codeph">AAAPecAAFAAAABSAAA</code>, the final <code class="codeph">AAA</code> represents the row number. The row number is an index into a row directory entry. The row directory entry contains a pointer to the location of the row on the block.
                        </p>
                        <p>The database can sometimes move a row in the bottom part of the block. For example, if row movement is enabled, then the row can move because of partition key updates, Flashback Table operations, shrink table operations, and so on. If the database moves a row within a block, then the database updates the row directory entry to modify the pointer. The rowid stays constant.</p>
                        <p>Oracle Database uses rowids internally for the construction of indexes. For example, each key in a B-tree index is associated with a rowid that points to the address of the associated row. Physical rowids provide the fastest possible access to a table row, enabling the database to retrieve a row in as little as a single I/O.</p>
                     </div>
                     <div>
                        <div class="infoboxnotealso" id="GUID-4D0E9BF1-2A89-4CB4-A165-936C656BD48E__GUID-E04D4DBA-8362-4E07-A538-C177E0E8CDD8">
                           <p class="notep1">See Also:</p>
                           <p><a href="../cncpt/tables-and-table-clusters.html#CNCPT1130" target="_blank"><span><cite>Oracle Database Concepts</cite></span></a> to learn about rowids
                           </p>
                        </div>
                        <div class="familylinks">
                           <div class="parentlink">
                              <p><strong>Parent topic:</strong> <a href="optimizer-access-paths.html#GUID-53905BCD-3EAD-4B44-8CCC-C442A80647E8" title="By default, a table is organized as a heap, which means that the database places rows where they fit best rather than in a user-specified order.">About Heap-Organized Table Access</a></p>
                           </div>
                        </div>
                     </div>
                     
                  </div><a id="TGSQL95147"></a><a id="TGSQL95146"></a><div class="props_rev_3"><a id="GUID-1F4CDA9A-7419-44F6-89E0-395C92285015" name="GUID-1F4CDA9A-7419-44F6-89E0-395C92285015"></a><h5 id="TGSQL-GUID-1F4CDA9A-7419-44F6-89E0-395C92285015" class="sect5"><span class="enumeration_section">8.2.1.3 </span>Direct Path Reads
                     </h5>
                     <div>
                        <p>In a <strong class="term">direct path read</strong>, the database reads buffers from disk directly into the PGA, bypassing the SGA entirely. 
                        </p>
                        <p>The following figure shows the difference between scattered and sequential reads, which store buffers in the SGA, and direct path reads.</p>
                        <div class="figure" id="GUID-1F4CDA9A-7419-44F6-89E0-395C92285015__CHDBIAGB">
                           <p class="titleinfigure">Figure 8-1 Direct Path Reads</p><img src="img/pfgrf210.png" alt="Description of Figure 8-1 follows" title="Description of Figure 8-1 follows" longdesc="img_text/pfgrf210.html"><br><a href="img_text/pfgrf210.html">Description of "Figure 8-1 Direct Path Reads"</a></div>
                        <!-- class="figure" -->
                        <p>Situations in which Oracle Database may perform direct path reads include:</p>
                        <ul style="list-style-type: disc;">
                           <li>
                              <p>Execution of a <code class="codeph">CREATE TABLE AS SELECT</code> statement
                              </p>
                           </li>
                           <li>
                              <p>Execution of an <code class="codeph">ALTER REBUILD</code> or <code class="codeph">ALTER MOVE</code> statement
                              </p>
                           </li>
                           <li>
                              <p>Reads from a temporary tablespace</p>
                           </li>
                           <li>
                              <p>Parallel queries</p>
                           </li>
                           <li>
                              <p>Reads from a LOB segment</p>
                           </li>
                        </ul>
                     </div>
                     <div>
                        <div class="infoboxnotealso" id="GUID-1F4CDA9A-7419-44F6-89E0-395C92285015__GUID-6DE2D59E-00C7-435C-8B62-4653039FA16C">
                           <p class="notep1">See Also:</p>
                           <p><a href="https://www.oracle.com/pls/topic/lookup?ctx=en/database/oracle/oracle-database/19/tgsql&amp;id=TGDBA-GUID-2833BD11-FDF6-4134-A0DD-62E8CB32AE2C" target="_blank"><span><cite>Oracle Database Performance Tuning Guide</cite></span></a> to learn about wait events for direct path reads
                           </p>
                        </div>
                        <div class="familylinks">
                           <div class="parentlink">
                              <p><strong>Parent topic:</strong> <a href="optimizer-access-paths.html#GUID-53905BCD-3EAD-4B44-8CCC-C442A80647E8" title="By default, a table is organized as a heap, which means that the database places rows where they fit best rather than in a user-specified order.">About Heap-Organized Table Access</a></p>
                           </div>
                        </div>
                     </div>
                     
                  </div>
               </div><a id="TGSQL231"></a><div class="props_rev_3"><a id="GUID-461E7071-2229-4F60-82E6-BC4F6FC8D23B" name="GUID-461E7071-2229-4F60-82E6-BC4F6FC8D23B"></a><h4 id="TGSQL-GUID-461E7071-2229-4F60-82E6-BC4F6FC8D23B" class="sect4"><span class="enumeration_section">8.2.2 </span>Full Table Scans
                  </h4>
                  <div>
                     <p>A <strong class="term">full table scan</strong> reads all rows from a table, and then filters out those rows that do not meet the selection criteria.
                     </p>
                     <p>This section contains the following topics:</p>
                  </div>
                  <div>
                     <ul class="ullinks">
                        <li class="ulchildlink"><a href="optimizer-access-paths.html#GUID-0AC1AB0B-D0E6-4F77-823A-7CB56E375C32">When the Optimizer Considers a Full Table Scan</a><br>In general, the optimizer chooses a full table scan when it cannot use a different access path, or another usable access path is higher cost.
                        </li>
                        <li class="ulchildlink"><a href="optimizer-access-paths.html#GUID-EA237A0C-5C39-4797-89F9-2F38566B10D8">How a Full Table Scan Works</a><br>In a full table scan, the database sequentially reads every formatted block under the high water mark. The database reads each block only once. 
                        </li>
                        <li class="ulchildlink"><a href="optimizer-access-paths.html#GUID-56D159A8-DA06-4777-8407-625AC9ED1122">Full Table Scan: Example</a><br>This example scans the <code class="codeph">hr.employees</code> table.
                        </li>
                     </ul>
                     <div class="familylinks">
                        <div class="parentlink">
                           <p><strong>Parent topic:</strong> <a href="optimizer-access-paths.html#GUID-5594AB70-F3C1-49BA-88ED-0B2011791365" title="A table is the basic unit of data organization in an Oracle database.">Table Access Paths</a></p>
                        </div>
                     </div>
                  </div>
                  <a id="TGSQL94944"></a><div class="props_rev_3"><a id="GUID-0AC1AB0B-D0E6-4F77-823A-7CB56E375C32" name="GUID-0AC1AB0B-D0E6-4F77-823A-7CB56E375C32"></a><h5 id="TGSQL-GUID-0AC1AB0B-D0E6-4F77-823A-7CB56E375C32" class="sect5"><span class="enumeration_section">8.2.2.1 </span>When the Optimizer Considers a Full Table Scan
                     </h5>
                     <div>
                        <p>In general, the optimizer chooses a full table scan when it cannot use a different access path, or another usable access path is higher cost.</p>
                        <p>The following table shows typical reasons for choosing a full table scan.</p>
                        <div class="tblformal" id="GUID-0AC1AB0B-D0E6-4F77-823A-7CB56E375C32__GUID-249DD13F-8CFA-4F2A-A330-1DD717F6D2EC">
                           <p class="titleintable">Table 8-2 Typical Reasons for a Full Table Scan</p>
                           <table cellpadding="4" cellspacing="0" class="Formal" title="Typical Reasons for a Full Table Scan" summary="This table lists some of the reasons for a full table scan. The table contains links for more information." frame="hsides" border="1" rules="rows">
                              <thead>
                                 <tr align="left" valign="top">
                                    <th align="left" valign="bottom" width="20%" id="d37861e1710">Reason</th>
                                    <th align="left" valign="bottom" width="20%" id="d37861e1712">Explanation</th>
                                    <th align="left" valign="bottom" width="20%" id="d37861e1714">To Learn More</th>
                                 </tr>
                              </thead>
                              <tbody>
                                 <tr align="left" valign="top">
                                    <td align="left" valign="top" width="20%" id="d37861e1718" headers="d37861e1710 ">
                                       <p>No index exists.</p>
                                    </td>
                                    <td align="left" valign="top" width="20%" headers="d37861e1718 d37861e1712 ">
                                       <p>If no index exists, then the optimizer uses a full table scan.</p>
                                    </td>
                                    <td align="left" valign="top" width="20%" headers="d37861e1718 d37861e1714 ">
                                       <p><a href="../cncpt/indexes-and-index-organized-tables.html#CNCPT-GUID-DE7A95BC-6E4A-47EA-9FC5-B85B54F8CF41" target="_blank"><span><cite>Oracle Database Concepts</cite></span></a></p>
                                    </td>
                                 </tr>
                                 <tr align="left" valign="top">
                                    <td align="left" valign="top" width="20%" id="d37861e1732" headers="d37861e1710 ">
                                       <p>The query predicate applies a function to the indexed column.</p>
                                    </td>
                                    <td align="left" valign="top" width="20%" headers="d37861e1732 d37861e1712 ">
                                       <p>Unless the index is a function-based index, the database indexes the values of the column, not the values of the column with the function applied. A typical application-level mistake is to index a character column, such as <code class="codeph">char_col</code>, and then query the column using syntax such as <code class="codeph">WHERE char_col=1</code>. The database implicitly applies a <code class="codeph">TO_NUMBER</code> function to the constant number <code class="codeph">1</code>, which prevents use of the index.
                                       </p>
                                    </td>
                                    <td align="left" valign="top" width="20%" headers="d37861e1732 d37861e1714 ">
                                       <p><a href="../adfns/indexes.html#GUID-44AD4D28-A056-4977-B2F7-AC1BC50EDC87" target="_blank"><span><cite>Oracle Database Development Guide</cite></span></a></p>
                                    </td>
                                 </tr>
                                 <tr align="left" valign="top">
                                    <td align="left" valign="top" width="20%" id="d37861e1758" headers="d37861e1710 ">
                                       <p>A <code class="codeph">SELECT COUNT(*)</code> query is issued, and an index exists, but the indexed column contains nulls. 
                                       </p>
                                    </td>
                                    <td align="left" valign="top" width="20%" headers="d37861e1758 d37861e1712 ">
                                       <p>The optimizer cannot use the index to count the number of table rows because the index cannot contain null entries.</p>
                                    </td>
                                    <td align="left" valign="top" width="20%" headers="d37861e1758 d37861e1714 "><span class="q">"<a href="optimizer-access-paths.html#GUID-AD533A0C-E46F-4FB0-8C34-881A0E30E93A" title="B-tree indexes never store completely null keys, which is important for how the optimizer chooses access paths. A consequence of this rule is that single-column B-tree indexes never store nulls.">B-Tree Indexes and Nulls</a>"</span></td>
                                 </tr>
                                 <tr align="left" valign="top">
                                    <td align="left" valign="top" width="20%" id="d37861e1775" headers="d37861e1710 ">
                                       <p>The query predicate does not use the leading edge of a B-tree index.</p>
                                    </td>
                                    <td align="left" valign="top" width="20%" headers="d37861e1775 d37861e1712 ">
                                       <p>For example, an index might exist on <code class="codeph">employees(first_name,last_name)</code>. If a user issues a query with the predicate <code class="codeph">WHERE last_name='KING'</code>, then the optimizer may not choose an index because column <code class="codeph">first_name</code> is not in the predicate. However, in this situation the optimizer may choose to use an index skip scan.
                                       </p>
                                    </td>
                                    <td align="left" valign="top" width="20%" headers="d37861e1775 d37861e1714 "><span class="q">"<a href="optimizer-access-paths.html#GUID-B7C62F0F-EB7C-422C-919D-D86456A74A60" title="An index skip scan occurs when the initial column of a composite index is "skipped" or not specified in the query.">Index Skip Scans</a>"</span></td>
                                 </tr>
                                 <tr align="left" valign="top">
                                    <td align="left" valign="top" width="20%" id="d37861e1801" headers="d37861e1710 ">
                                       <p>The query is <a href="glossary.html#GUID-EFB55786-83D3-4DFF-A534-052B0BF3BA62"><span class="xrefglossterm">unselective</span></a>.
                                       </p>
                                    </td>
                                    <td align="left" valign="top" width="20%" headers="d37861e1801 d37861e1712 ">
                                       <p>If the optimizer determines that the query requires most of the blocks in the table, then it uses a full table scan, even though indexes are available. Full table scans can use larger I/O calls. Making fewer large I/O calls is cheaper than making many smaller calls.</p>
                                    </td>
                                    <td align="left" valign="top" width="20%" headers="d37861e1801 d37861e1714 ">
                                       <p><span class="q">"<a href="query-optimizer-concepts.html#GUID-60B12417-9E06-4F3F-B796-DF86549A5B21" title="The selectivity represents a fraction of rows from a row set.">Selectivity</a>"</span></p>
                                    </td>
                                 </tr>
                                 <tr align="left" valign="top">
                                    <td align="left" valign="top" width="20%" id="d37861e1822" headers="d37861e1710 ">
                                       <p>The table statistics are stale.</p>
                                    </td>
                                    <td align="left" valign="top" width="20%" headers="d37861e1822 d37861e1712 ">
                                       <p>For example, a table was small, but now has grown large. If the table statistics are stale and do not reflect the current size of the table, then the optimizer does not know that an index is now most efficient than a full table scan.</p>
                                    </td>
                                    <td align="left" valign="top" width="20%" headers="d37861e1822 d37861e1714 "><span class="q">"<a href="optimizer-statistics-concepts.html#GUID-AEE74FB8-98BD-416B-8EA0-32CD605DF64E" title="The optimizer cost model relies on statistics collected about the objects involved in a query, and the database and host where the query runs.">Introduction to Optimizer Statistics</a>"</span></td>
                                 </tr>
                                 <tr align="left" valign="top">
                                    <td align="left" valign="top" width="20%" id="d37861e1839" headers="d37861e1710 ">
                                       <p>The table is small.</p>
                                    </td>
                                    <td align="left" valign="top" width="20%" headers="d37861e1839 d37861e1712 ">
                                       <p>If a table contains fewer than <span class="italic">n</span> blocks under the high water mark, where <span class="italic">n</span> equals the setting for the <code class="codeph">DB_FILE_MULTIBLOCK_READ_COUNT</code> initialization parameter, then a full table scan may be cheaper than an index range scan. The scan may be less expensive regardless of the fraction of tables being accessed or indexes present.
                                       </p>
                                    </td>
                                    <td align="left" valign="top" width="20%" headers="d37861e1839 d37861e1714 ">
                                       <p><a href="../refrn/DB_FILE_MULTIBLOCK_READ_COUNT.html#REFRN-GUID-69E45087-14DF-492B-B55A-8F2E936947A5" target="_blank"><span><cite>Oracle Database Reference</cite></span></a> 
                                       </p>
                                    </td>
                                 </tr>
                                 <tr align="left" valign="top">
                                    <td align="left" valign="top" width="20%" id="d37861e1863" headers="d37861e1710 ">
                                       <p>The table has a high degree of parallelism.</p>
                                    </td>
                                    <td align="left" valign="top" width="20%" headers="d37861e1863 d37861e1712 ">
                                       <p>A high degree of parallelism for a table skews the optimizer toward full table scans over range scans. Query the value in the <code class="codeph">ALL_TABLES.DEGREE</code> column to determine the degree of parallelism.
                                       </p>
                                    </td>
                                    <td align="left" valign="top" width="20%" headers="d37861e1863 d37861e1714 ">
                                       <p><a href="../refrn/ALL_TABLES.html#REFRN-GUID-6823CD28-0681-468E-950B-966C6F71325D" target="_blank"><span><cite>Oracle Database Reference</cite></span></a></p>
                                    </td>
                                 </tr>
                                 <tr align="left" valign="top">
                                    <td align="left" valign="top" width="20%" id="d37861e1880" headers="d37861e1710 ">
                                       <p>The query uses a full table scan hint.</p>
                                    </td>
                                    <td align="left" valign="top" width="20%" headers="d37861e1880 d37861e1712 ">
                                       <p>The hint <code class="codeph">FULL(<span class="codeinlineitalic"><code class="codeph">table</code></span> <span class="codeinlineitalic"><code class="codeph">alias</code></span>)</code> instructs the optimizer to use a full table scan.
                                       </p>
                                    </td>
                                    <td align="left" valign="top" width="20%" headers="d37861e1880 d37861e1714 ">
                                       <p><a href="../sqlrf/Comments.html#SQLRF-GUID-581F6C91-1395-4ED0-81DE-59AE168FE183" target="_blank"><span><cite>Oracle Database SQL Language Reference</cite></span></a></p>
                                    </td>
                                 </tr>
                              </tbody>
                           </table>
                        </div>
                        <!-- class="inftblhruleinformal" -->
                     </div>
                     <div>
                        <div class="familylinks">
                           <div class="parentlink">
                              <p><strong>Parent topic:</strong> <a href="optimizer-access-paths.html#GUID-461E7071-2229-4F60-82E6-BC4F6FC8D23B" title="A full table scan reads all rows from a table, and then filters out those rows that do not meet the selection criteria.">Full Table Scans</a></p>
                           </div>
                        </div>
                     </div>
                     
                  </div><a id="TGSQL94945"></a><div class="props_rev_3"><a id="GUID-EA237A0C-5C39-4797-89F9-2F38566B10D8" name="GUID-EA237A0C-5C39-4797-89F9-2F38566B10D8"></a><h5 id="TGSQL-GUID-EA237A0C-5C39-4797-89F9-2F38566B10D8" class="sect5"><span class="enumeration_section">8.2.2.2 </span>How a Full Table Scan Works
                     </h5>
                     <div>
                        <p>In a full table scan, the database sequentially reads every formatted block under the high water mark. The database reads each block only once. </p>
                        <p>The following graphic depicts a scan of a table segment, showing how the scan skips unformatted blocks below the high water mark.</p>
                        <div class="figure" id="GUID-EA237A0C-5C39-4797-89F9-2F38566B10D8__GUID-90C91871-1DAC-49F4-B385-66955E3CB781">
                           <p class="titleinfigure">Figure 8-2 High Water Mark</p><img src="img/cncpt371.png" alt="Description of Figure 8-2 follows" title="Description of Figure 8-2 follows" longdesc="img_text/cncpt371.html"><br><a href="img_text/cncpt371.html">Description of "Figure 8-2 High Water Mark"</a></div>
                        <!-- class="figure" -->
                        <p>Because the blocks are adjacent, the database can speed up the scan by making I/O calls larger than a single block, known as a <a href="glossary.html#GUID-D02974BC-8CD2-4BEC-8B9A-3C7D44D90324"><span class="xrefglossterm">multiblock read</span></a>. The size of a read call ranges from one block to the number of blocks specified by the <code class="codeph">DB_FILE_MULTIBLOCK_READ_COUNT</code> initialization parameter. For example, setting this parameter to <code class="codeph">4</code> instructs the database to read up to 4 blocks in a single call.
                        </p>
                        <p>The algorithms for caching blocks during full table scans are complex. For example, the database caches blocks differently depending on whether tables are small or large.</p>
                     </div>
                     <div>
                        <div class="infoboxnotealso" id="GUID-EA237A0C-5C39-4797-89F9-2F38566B10D8__GUID-7E023923-3585-4111-9DCE-FA63202646F6">
                           <p class="notep1">See Also:</p>
                           <ul style="list-style-type: disc;">
                              <li>
                                 <p><span class="q">"<a href="influencing-the-optimizer.html#GUID-C1C85DEA-3583-40FE-B5BB-6AC8F76FFE34__BBAIEADC" title="This two-column table describes initialization parameters that control optimizer behavior. Column 1 is the parameter. Column 2 describes that parameter.">Table 19-2</a>"</span></p>
                              </li>
                              <li>
                                 <p><a href="../cncpt/memory-architecture.html#CNCPT1224" target="_blank"><span><cite>Oracle Database Concepts</cite></span></a> for an overview of the default caching mode
                                 </p>
                              </li>
                              <li>
                                 <p><a href="../refrn/DB_FILE_MULTIBLOCK_READ_COUNT.html#REFRN10037" target="_blank"><span><cite>Oracle Database Reference</cite></span></a> to learn about the <code class="codeph">DB_FILE_MULTIBLOCK_READ_COUNT</code> initialization parameter
                                 </p>
                              </li>
                           </ul>
                        </div>
                        <div class="familylinks">
                           <div class="parentlink">
                              <p><strong>Parent topic:</strong> <a href="optimizer-access-paths.html#GUID-461E7071-2229-4F60-82E6-BC4F6FC8D23B" title="A full table scan reads all rows from a table, and then filters out those rows that do not meet the selection criteria.">Full Table Scans</a></p>
                           </div>
                        </div>
                     </div>
                     
                  </div><a id="TGSQL94947"></a><a id="TGSQL94946"></a><div class="props_rev_3"><a id="GUID-56D159A8-DA06-4777-8407-625AC9ED1122" name="GUID-56D159A8-DA06-4777-8407-625AC9ED1122"></a><h5 id="TGSQL-GUID-56D159A8-DA06-4777-8407-625AC9ED1122" class="sect5"><span class="enumeration_section">8.2.2.3 </span>Full Table Scan: Example
                     </h5>
                     <div>
                        <p>This example scans the <code class="codeph">hr.employees</code> table.
                        </p>
                        <p>The following statement queries monthly salaries over $4000:</p><pre class="pre codeblock"><code>SELECT salary 
FROM   hr.employees 
WHERE  salary &gt; 4000;
</code></pre><div class="example" id="GUID-56D159A8-DA06-4777-8407-625AC9ED1122__CHDEHBCE">
                           <p class="titleinexample">Example 8-1 Full Table Scan</p>
                           <p>The following plan was retrieved using the <code class="codeph">DBMS_XPLAN.DISPLAY_CURSOR</code> function. Because no index exists on the <code class="codeph">salary</code> column, the optimizer cannot use an index range scan, and so uses a full table scan.
                           </p><pre class="pre codeblock"><code>SQL_ID  54c20f3udfnws, child number 0
-------------------------------------
select salary from hr.employees where salary &gt; 4000
 
Plan hash value: 3476115102
 
-------------------------------------------------------------------------------
| Id  | Operation         | Name      | Rows  | Bytes | Cost (%CPU)| Time     |
-------------------------------------------------------------------------------
|   0 | SELECT STATEMENT  |           |       |       |     3 (100)|          |
|*  1 |  <span class="bold">TABLE ACCESS FULL</span>| EMPLOYEES |    98 |  6762 |     3   (0)| 00:00:01 |
-------------------------------------------------------------------------------
 
Predicate Information (identified by operation id):
---------------------------------------------------
 
   1 - filter("SALARY"&gt;4000)</code></pre></div>
                        <!-- class="example" -->
                     </div>
                     <div>
                        <div class="familylinks">
                           <div class="parentlink">
                              <p><strong>Parent topic:</strong> <a href="optimizer-access-paths.html#GUID-461E7071-2229-4F60-82E6-BC4F6FC8D23B" title="A full table scan reads all rows from a table, and then filters out those rows that do not meet the selection criteria.">Full Table Scans</a></p>
                           </div>
                        </div>
                     </div>
                     
                  </div>
               </div><a id="TGSQL232"></a><div class="props_rev_3"><a id="GUID-4180BA97-3E2C-41F9-B282-4FB3FF9532CB" name="GUID-4180BA97-3E2C-41F9-B282-4FB3FF9532CB"></a><h4 id="TGSQL-GUID-4180BA97-3E2C-41F9-B282-4FB3FF9532CB" class="sect4"><span class="enumeration_section">8.2.3 </span>Table Access by Rowid
                  </h4>
                  <div>
                     <p>A <strong class="term">rowid</strong> is an internal representation of the storage location of data.
                     </p>
                     <p>The rowid of a row specifies the data file and data block containing the row and the location of the row in that block. Locating a row by specifying its rowid is the fastest way to retrieve a single row because it specifies the exact location of the row in the database.</p>
                     <div class="infoboxnote" id="GUID-4180BA97-3E2C-41F9-B282-4FB3FF9532CB__GUID-13A8A764-EC23-43C9-A26B-33F23EEF82C8">
                        <p class="notep1">Note:</p>
                        <p>Rowids can change between versions. Accessing data based on position is not recommended because rows can move.</p>
                     </div>
                     <p>This section contains the following topics:</p>
                  </div>
                  <div>
                     <ul class="ullinks">
                        <li class="ulchildlink"><a href="optimizer-access-paths.html#GUID-7A2735CC-278A-44AE-A643-670EC859466F">When the Optimizer Chooses Table Access by Rowid</a><br>In most cases, the database accesses a table by rowid after a scan of one or more indexes. 
                        </li>
                        <li class="ulchildlink"><a href="optimizer-access-paths.html#GUID-1E815B8C-990A-4FAE-B87A-0A62D1CA2D32">How Table Access by Rowid Works</a><br>To access a table by rowid, the database performs multiple steps.
                        </li>
                        <li class="ulchildlink"><a href="optimizer-access-paths.html#GUID-7953EB83-0BBA-4700-993A-49C9B5FD254A">Table Access by Rowid: Example</a><br>This example demonstrates rowid access of the <code class="codeph">hr.employees</code> table.
                        </li>
                     </ul>
                     <div class="infoboxnotealso" id="GUID-4180BA97-3E2C-41F9-B282-4FB3FF9532CB__GUID-6F8A8AB2-A4CD-42A6-A6A4-E8815B52A9F9">
                        <p class="notep1">See Also:</p>
                        <p><a href="../adfns/sql-data-types.html#GUID-E8E35A33-F4CF-49CB-B2F2-45754F1082DA" target="_blank"><span><cite>Oracle Database Development Guide</cite></span></a> to learn more about rowids
                        </p>
                     </div>
                     <div class="familylinks">
                        <div class="parentlink">
                           <p><strong>Parent topic:</strong> <a href="optimizer-access-paths.html#GUID-5594AB70-F3C1-49BA-88ED-0B2011791365" title="A table is the basic unit of data organization in an Oracle database.">Table Access Paths</a></p>
                        </div>
                     </div>
                  </div>
                  <a id="TGSQL95148"></a><div class="props_rev_3"><a id="GUID-7A2735CC-278A-44AE-A643-670EC859466F" name="GUID-7A2735CC-278A-44AE-A643-670EC859466F"></a><h5 id="TGSQL-GUID-7A2735CC-278A-44AE-A643-670EC859466F" class="sect5"><span class="enumeration_section">8.2.3.1 </span>When the Optimizer Chooses Table Access by Rowid
                     </h5>
                     <div>
                        <p>In most cases, the database accesses a table by rowid after a scan of one or more indexes. </p>
                        <p>However, table access by rowid need not follow every index scan. If the index contains all needed columns, then access by rowid might not occur.</p>
                     </div>
                     <div>
                        <div class="familylinks">
                           <div class="parentlink">
                              <p><strong>Parent topic:</strong> <a href="optimizer-access-paths.html#GUID-4180BA97-3E2C-41F9-B282-4FB3FF9532CB" title="A rowid is an internal representation of the storage location of data.">Table Access by Rowid</a></p>
                           </div>
                        </div>
                     </div>
                     
                  </div><a id="TGSQL95149"></a><div class="props_rev_3"><a id="GUID-1E815B8C-990A-4FAE-B87A-0A62D1CA2D32" name="GUID-1E815B8C-990A-4FAE-B87A-0A62D1CA2D32"></a><h5 id="TGSQL-GUID-1E815B8C-990A-4FAE-B87A-0A62D1CA2D32" class="sect5"><span class="enumeration_section">8.2.3.2 </span>How Table Access by Rowid Works
                     </h5>
                     <div>
                        <p>To access a table by rowid, the database performs multiple steps.</p>
                        <p>The database does the following:</p>
                        <ol>
                           <li>
                              <p>Obtains the rowids of the selected rows, either from the statement <code class="codeph">WHERE</code> clause or through an index scan of one or more indexes
                              </p>
                              <p>Table access may be needed for columns in the statement not present in the index.</p>
                           </li>
                           <li>
                              <p>Locates each selected row in the table based on its rowid</p>
                           </li>
                        </ol>
                     </div>
                     <div>
                        <div class="familylinks">
                           <div class="parentlink">
                              <p><strong>Parent topic:</strong> <a href="optimizer-access-paths.html#GUID-4180BA97-3E2C-41F9-B282-4FB3FF9532CB" title="A rowid is an internal representation of the storage location of data.">Table Access by Rowid</a></p>
                           </div>
                        </div>
                     </div>
                     
                  </div><a id="TGSQL95150"></a><div class="props_rev_3"><a id="GUID-7953EB83-0BBA-4700-993A-49C9B5FD254A" name="GUID-7953EB83-0BBA-4700-993A-49C9B5FD254A"></a><h5 id="TGSQL-GUID-7953EB83-0BBA-4700-993A-49C9B5FD254A" class="sect5"><span class="enumeration_section">8.2.3.3 </span>Table Access by Rowid: Example
                     </h5>
                     <div>
                        <p>This example demonstrates rowid access of the <code class="codeph">hr.employees</code> table.
                        </p>
                        <p>Assume that you run the following query:</p><pre class="pre codeblock"><code>SELECT * 
FROM   employees 
WHERE  employee_id &gt; 190;
</code></pre><p>Step 2 of the following plan shows a range scan of the <code class="codeph">emp_emp_id_pk</code> index on the <code class="codeph">hr.employees</code> table. The database uses the rowids obtained from the index to find the corresponding rows from the <code class="codeph">employees</code> table, and then retrieve them. The <code class="codeph">BATCHED</code> access shown in Step 1 means that the database retrieves a few rowids from the index, and then attempts to access rows in block order to improve the clustering and reduce the number of times that the database must access a block.
                        </p><pre class="pre codeblock"><code>--------------------------------------------------------------------------------
|Id| Operation                           | Name     |Rows|Bytes|Cost(%CPU)|Time|
--------------------------------------------------------------------------------
| 0| SELECT STATEMENT                    |             |  |    |2(100)|        |
| 1|  <span class="bold">TABLE ACCESS BY INDEX ROWID</span> <span class="bold">BATCHED</span>|EMPLOYEES    |16|1104|2  (0)|00:00:01|
|*2|   INDEX RANGE SCAN                  |EMP_EMP_ID_PK|16|    |1  (0)|00:00:01|
--------------------------------------------------------------------------------
 
Predicate Information (identified by operation id):
---------------------------------------------------
 
   2 - access("EMPLOYEE_ID"&gt;190)</code></pre></div>
                     <div>
                        <div class="familylinks">
                           <div class="parentlink">
                              <p><strong>Parent topic:</strong> <a href="optimizer-access-paths.html#GUID-4180BA97-3E2C-41F9-B282-4FB3FF9532CB" title="A rowid is an internal representation of the storage location of data.">Table Access by Rowid</a></p>
                           </div>
                        </div>
                     </div>
                     
                  </div>
               </div><a id="TGSQL233"></a><div class="props_rev_3"><a id="GUID-720EA54F-AB65-4379-99A3-CAE166590127" name="GUID-720EA54F-AB65-4379-99A3-CAE166590127"></a><h4 id="TGSQL-GUID-720EA54F-AB65-4379-99A3-CAE166590127" class="sect4"><span class="enumeration_section">8.2.4 </span>Sample Table Scans
                  </h4>
                  <div>
                     <p>A <strong class="term">sample table scan</strong> retrieves a random sample of data from a simple table or a complex <code class="codeph">SELECT</code> statement, such as a statement involving joins and views.
                     </p>
                     <p>This section contains the following topics:</p>
                  </div>
                  <div>
                     <ul class="ullinks">
                        <li class="ulchildlink"><a href="optimizer-access-paths.html#GUID-45CFAC71-059A-4F01-ADE4-DA1D6335519C">When the Optimizer Chooses a Sample Table Scan</a><br>The database uses a sample table scan when a statement <code class="codeph">FROM</code> clause includes the <code class="codeph">SAMPLE</code> keyword.
                        </li>
                        <li class="ulchildlink"><a href="optimizer-access-paths.html#GUID-6A457780-7495-472A-8DA1-9151370D2E64">Sample Table Scans: Example</a><br>This example uses a sample table scan to access 1% of the <code class="codeph">employees</code> table, sampling by blocks instead of rows.
                        </li>
                     </ul>
                     <div class="familylinks">
                        <div class="parentlink">
                           <p><strong>Parent topic:</strong> <a href="optimizer-access-paths.html#GUID-5594AB70-F3C1-49BA-88ED-0B2011791365" title="A table is the basic unit of data organization in an Oracle database.">Table Access Paths</a></p>
                        </div>
                     </div>
                  </div>
                  <a id="TGSQL95151"></a><div class="props_rev_3"><a id="GUID-45CFAC71-059A-4F01-ADE4-DA1D6335519C" name="GUID-45CFAC71-059A-4F01-ADE4-DA1D6335519C"></a><h5 id="TGSQL-GUID-45CFAC71-059A-4F01-ADE4-DA1D6335519C" class="sect5"><span class="enumeration_section">8.2.4.1 </span>When the Optimizer Chooses a Sample Table Scan
                     </h5>
                     <div>
                        <p>The database uses a sample table scan when a statement <code class="codeph">FROM</code> clause includes the <code class="codeph">SAMPLE</code> keyword.
                        </p>
                        <p>The <code class="codeph">SAMPLE</code> clause has the following forms:
                        </p>
                        <ul style="list-style-type: disc;">
                           <li>
                              <p><code class="codeph">SAMPLE</code> <code class="codeph">(</code><span class="italic"><code class="codeph">sample_percent</code></span><code class="codeph">)</code></p>
                              <p>The database reads a specified percentage of rows in the table to perform a sample table scan.</p>
                           </li>
                           <li>
                              <p><code class="codeph">SAMPLE BLOCK</code> <code class="codeph">(</code><span class="italic"><code class="codeph">sample_percent</code></span><code class="codeph">)</code></p>
                              <p>The database reads a specified percentage of table blocks to perform a sample table scan.</p>
                           </li>
                        </ul>
                        <p>The <span class="italic">sample_percent</span> specifies the percentage of the total row or block count to include in the sample. The value must be in the range <code class="codeph">.000001</code> up to, but not including, <code class="codeph">100</code>. This percentage indicates the probability of each row, or each cluster of rows in block sampling, being selected for the sample. It does not mean that the database retrieves exactly <span class="italic">sample_percent</span> of the rows.
                        </p>
                        <div class="infoboxnote" id="GUID-45CFAC71-059A-4F01-ADE4-DA1D6335519C__GUID-ABE26BAF-7F15-4228-B4D8-A2BA5062202C">
                           <p class="notep1">Note:</p>
                           <p>Block sampling is possible only during full table scans or index fast full scans. If a more efficient execution path exists, then the database does not sample blocks. To guarantee block sampling for a specific table or index, use the <code class="codeph">FULL</code> or <code class="codeph">INDEX_FFS</code> hint.
                           </p>
                        </div>
                     </div>
                     <div>
                        <div class="infoboxnotealso" id="GUID-45CFAC71-059A-4F01-ADE4-DA1D6335519C__GUID-B0C84EF2-C915-4560-BF4B-6687BCA1B8DC">
                           <p class="notep1">See Also:</p>
                           <ul style="list-style-type: disc;">
                              <li>
                                 <p><span class="q">"<a href="influencing-the-optimizer.html#GUID-C558F7CF-446E-4078-B045-0B3BB026CB3C" title="Optimizer hints are special comments in a SQL statement that pass instructions to the optimizer.">Influencing the Optimizer with Hints</a>"</span></p>
                              </li>
                              <li>
                                 <p><a href="https://www.oracle.com/pls/topic/lookup?ctx=en/database/oracle/oracle-database/19/tgsql&amp;id=SQLRF55293" target="_blank"><span><cite>Oracle Database SQL Language Reference</cite></span></a> to learn about the <code class="codeph">SAMPLE</code> clause
                                 </p>
                              </li>
                           </ul>
                        </div>
                        <div class="familylinks">
                           <div class="parentlink">
                              <p><strong>Parent topic:</strong> <a href="optimizer-access-paths.html#GUID-720EA54F-AB65-4379-99A3-CAE166590127" title="A sample table scan retrieves a random sample of data from a simple table or a complex SELECT statement, such as a statement involving joins and views.">Sample Table Scans</a></p>
                           </div>
                        </div>
                     </div>
                     
                  </div><a id="TGSQL94668"></a><a id="TGSQL95152"></a><div class="props_rev_3"><a id="GUID-6A457780-7495-472A-8DA1-9151370D2E64" name="GUID-6A457780-7495-472A-8DA1-9151370D2E64"></a><h5 id="TGSQL-GUID-6A457780-7495-472A-8DA1-9151370D2E64" class="sect5"><span class="enumeration_section">8.2.4.2 </span>Sample Table Scans: Example
                     </h5>
                     <div>
                        <p>This example uses a sample table scan to access 1% of the <code class="codeph">employees</code> table, sampling by blocks instead of rows.
                        </p>
                        <div class="example" id="GUID-6A457780-7495-472A-8DA1-9151370D2E64__CHDDGGEF">
                           <p class="titleinexample">Example 8-2 Sample Table Scan</p><pre class="pre codeblock"><code>SELECT * FROM hr.employees SAMPLE BLOCK (1); 
</code></pre><p>The <code class="codeph">EXPLAIN PLAN</code> output for this statement might look as follows: 
                           </p><pre class="pre codeblock"><code>-------------------------------------------------------------------------
| Id  | Operation            |  Name       | Rows  | Bytes | Cost (%CPU)|
-------------------------------------------------------------------------
|   0 | SELECT STATEMENT     |             |     1 |    68 |     3  (34)|
|   1 |  TABLE ACCESS SAMPLE | EMPLOYEES   |     1 |    68 |     3  (34)|
-------------------------------------------------------------------------</code></pre></div>
                        <!-- class="example" -->
                     </div>
                     <div>
                        <div class="familylinks">
                           <div class="parentlink">
                              <p><strong>Parent topic:</strong> <a href="optimizer-access-paths.html#GUID-720EA54F-AB65-4379-99A3-CAE166590127" title="A sample table scan retrieves a random sample of data from a simple table or a complex SELECT statement, such as a statement involving joins and views.">Sample Table Scans</a></p>
                           </div>
                        </div>
                     </div>
                     
                  </div>
               </div><a id="TGSQL95355"></a><div class="props_rev_3"><a id="GUID-E699E03C-2689-4B56-B303-8E8529C5D99E" name="GUID-E699E03C-2689-4B56-B303-8E8529C5D99E"></a><h4 id="TGSQL-GUID-E699E03C-2689-4B56-B303-8E8529C5D99E" class="sect4"><span class="enumeration_section">8.2.5 </span>In-Memory Table Scans
                  </h4>
                  <div>
                     <p>An <strong class="term">In-Memory scan</strong> retrieves rows from the In-Memory Column Store (IM column store). 
                     </p>
                     <p>The IM column store is an optional SGA area that stores copies of tables and partitions in a special columnar format optimized for rapid scans.</p>
                     <p>This section contains the following topics:</p>
                  </div>
                  <div>
                     <ul class="ullinks">
                        <li class="ulchildlink"><a href="optimizer-access-paths.html#GUID-ED1C6A45-3417-4BD1-AA4F-E6434C96FD9C">When the Optimizer Chooses an In-Memory Table Scan</a><br>The optimizer cost model is aware of the content of the IM column store. 
                        </li>
                        <li class="ulchildlink"><a href="optimizer-access-paths.html#GUID-3A5C7459-14CB-4558-914D-4C1279A34648">In-Memory Query Controls</a><br>You can control In-Memory queries using initialization parameters.
                        </li>
                        <li class="ulchildlink"><a href="optimizer-access-paths.html#GUID-3175639B-34B2-4441-A9A6-33996ED6D1C6">In-Memory Table Scans: Example</a><br>This example shows an execution plan that includes the <code class="codeph">TABLE ACCESS INMEMORY</code> operation.
                        </li>
                     </ul>
                     <div class="infoboxnotealso" id="GUID-E699E03C-2689-4B56-B303-8E8529C5D99E__GUID-AE3608EF-11BB-4293-B6B8-7DD07F65929F">
                        <p class="notep1">See Also:</p>
                        <p><a href="https://www.oracle.com/pls/topic/lookup?ctx=en/database/oracle/oracle-database/19/tgsql&amp;id=INMEM-GUID-BFA53515-7643-41E5-A296-654AB4A9F9E7" target="_blank"><span><cite>Oracle Database In-Memory Guide</cite></span></a> for an introduction to the IM column store
                        </p>
                     </div>
                     <div class="familylinks">
                        <div class="parentlink">
                           <p><strong>Parent topic:</strong> <a href="optimizer-access-paths.html#GUID-5594AB70-F3C1-49BA-88ED-0B2011791365" title="A table is the basic unit of data organization in an Oracle database.">Table Access Paths</a></p>
                        </div>
                     </div>
                  </div>
                  <a id="TGSQL95356"></a><div class="props_rev_3"><a id="GUID-ED1C6A45-3417-4BD1-AA4F-E6434C96FD9C" name="GUID-ED1C6A45-3417-4BD1-AA4F-E6434C96FD9C"></a><h5 id="TGSQL-GUID-ED1C6A45-3417-4BD1-AA4F-E6434C96FD9C" class="sect5"><span class="enumeration_section">8.2.5.1 </span>When the Optimizer Chooses an In-Memory Table Scan
                     </h5>
                     <div>
                        <p>The optimizer cost model is aware of the content of the IM column store. </p>
                        <p>When a user executes a query that references a table in the IM column store, the optimizer calculates the cost of all possible access methods—including the In-Memory table scan—and selects the access method with the lowest cost.</p>
                     </div>
                     <div>
                        <div class="familylinks">
                           <div class="parentlink">
                              <p><strong>Parent topic:</strong> <a href="optimizer-access-paths.html#GUID-E699E03C-2689-4B56-B303-8E8529C5D99E" title="An In-Memory scan retrieves rows from the In-Memory Column Store (IM column store).">In-Memory Table Scans</a></p>
                           </div>
                        </div>
                     </div>
                     
                  </div><a id="TGSQL95357"></a><div class="props_rev_3"><a id="GUID-3A5C7459-14CB-4558-914D-4C1279A34648" name="GUID-3A5C7459-14CB-4558-914D-4C1279A34648"></a><h5 id="TGSQL-GUID-3A5C7459-14CB-4558-914D-4C1279A34648" class="sect5"><span class="enumeration_section">8.2.5.2 </span>In-Memory Query Controls
                     </h5>
                     <div>
                        <p>You can control In-Memory queries using initialization parameters.</p>
                        <p>The following database initialization parameters affect the In-Memory features:</p>
                        <ul style="list-style-type: disc;">
                           <li>
                              <p><code class="codeph">INMEMORY_QUERY</code></p>
                              <p>This parameter enables or disables In-Memory queries for the database at the session or system level. This parameter is helpful when you want to test workloads with and without the use of the IM column store.</p>
                           </li>
                           <li>
                              <p><code class="codeph">OPTIMIZER_INMEMORY_AWARE</code></p>
                              <p>This parameter enables (<code class="codeph">TRUE</code>) or disables (<code class="codeph">FALSE</code>) all of the In-Memory enhancements made to the optimizer cost model, table expansion, bloom filters, and so on. Setting the parameter to <code class="codeph">FALSE</code> causes the optimizer to ignore the In-Memory property of tables during the optimization of SQL statements.
                              </p>
                           </li>
                           <li>
                              <p><code class="codeph">OPTIMIZER_FEATURES_ENABLE</code></p>
                              <p>When set to values lower than <code class="codeph">12.1.0.2</code>, this parameter has the same effect as setting <code class="codeph">OPTIMIZER_INMEMORY_AWARE</code> to <code class="codeph">FALSE</code>. 
                              </p>
                           </li>
                        </ul>
                        <p>To enable or disable In-Memory queries, you can specify the <code class="codeph">INMEMORY</code> or <code class="codeph">NO_INMEMORY</code> hints, which are the per-query equivalent of the <code class="codeph">INMEMORY_QUERY</code> initialization parameter. If a SQL statement uses the <code class="codeph">INMEMORY</code> hint, but the object it references is not already loaded in the IM column store, then the database does not wait for the object to be populated in the IM column store before executing the statement. However, initial access of the object triggers the object population in the IM column store.
                        </p>
                     </div>
                     <div>
                        <div class="infoboxnotealso" id="GUID-3A5C7459-14CB-4558-914D-4C1279A34648__GUID-51B104BF-4927-4799-B015-C2F0B493DD21">
                           <p class="notep1">See Also:</p>
                           <ul style="list-style-type: disc;">
                              <li>
                                 <p><a href="https://www.oracle.com/pls/topic/lookup?ctx=en/database/oracle/oracle-database/19/tgsql&amp;id=REFRN10351" target="_blank"><span><cite>Oracle Database Reference</cite></span></a> to learn more about the <code class="codeph">INMEMORY_QUERY</code>, <code class="codeph">OPTIMIZER_INMEMORY_AWARE</code>, and <code class="codeph">OPTIMIZER_FEATURES_ENABLE</code> initialization parameters
                                 </p>
                              </li>
                              <li>
                                 <p><a href="https://www.oracle.com/pls/topic/lookup?ctx=en/database/oracle/oracle-database/19/tgsql&amp;id=SQLRF56788" target="_blank"><span><cite>Oracle Database SQL Language Reference</cite></span></a> to learn more about the <code class="codeph">INMEMORY</code> hints
                                 </p>
                              </li>
                           </ul>
                        </div>
                        <div class="familylinks">
                           <div class="parentlink">
                              <p><strong>Parent topic:</strong> <a href="optimizer-access-paths.html#GUID-E699E03C-2689-4B56-B303-8E8529C5D99E" title="An In-Memory scan retrieves rows from the In-Memory Column Store (IM column store).">In-Memory Table Scans</a></p>
                           </div>
                        </div>
                     </div>
                     
                  </div><a id="TGSQL95359"></a><a id="TGSQL95358"></a><div class="props_rev_3"><a id="GUID-3175639B-34B2-4441-A9A6-33996ED6D1C6" name="GUID-3175639B-34B2-4441-A9A6-33996ED6D1C6"></a><h5 id="TGSQL-GUID-3175639B-34B2-4441-A9A6-33996ED6D1C6" class="sect5"><span class="enumeration_section">8.2.5.3 </span>In-Memory Table Scans: Example
                     </h5>
                     <div>
                        <p>This example shows an execution plan that includes the <code class="codeph">TABLE ACCESS INMEMORY</code> operation.
                        </p>
                        <p>The following example shows a query of the <code class="codeph">oe.product_information</code> table, which has been altered with the <code class="codeph">INMEMORY HIGH</code> option.
                        </p>
                        <div class="example" id="GUID-3175639B-34B2-4441-A9A6-33996ED6D1C6__CHDEHBHD">
                           <p class="titleinexample">Example 8-3 In-Memory Table Scan</p><pre class="pre codeblock"><code>SELECT * 
FROM   oe.product_information
WHERE  list_price &gt; 10 
ORDER BY product_id
</code></pre><p>The plan for this statement might look as follows, with the <code class="codeph">INMEMORY</code> keyword in Step 2 indicating that some or all of the object was accessed from the IM column store:
                           </p><pre class="pre codeblock"><code>SQL&gt; SELECT * FROM TABLE(DBMS_XPLAN.DISPLAY_CURSOR);

SQL_ID  2mb4h57x8pabw, child number 0
-------------------------------------
select * from oe.product_information where list_price &gt; 10 order byproduct_id

Plan hash value: 2256295385
--------------------------------------------------------------------------------------------
|Id| Operation                   | Name                |Rows|Bytes |TempSpc|Cost(%CPU)|Time|
--------------------------------------------------------------------------------------------
| 0| SELECT STATEMENT            |                     |    |      |     |21 (100)|        |
| 1|  SORT ORDER BY              |                     | 285| 62415|82000|21   (5)|00:00:01|
|*2|   <span class="bold">TABLE ACCESS INMEMORY FULL</span>| PRODUCT_INFORMATION | 285| 62415|     | 5   (0)|00:00:01|
--------------------------------------------------------------------------------------------

Predicate Information (identified by operation id):
---------------------------------------------------
   2 - inmemory("LIST_PRICE"&gt;10)
       filter("LIST_PRICE"&gt;10)</code></pre></div>
                        <!-- class="example" -->
                     </div>
                     <div>
                        <div class="familylinks">
                           <div class="parentlink">
                              <p><strong>Parent topic:</strong> <a href="optimizer-access-paths.html#GUID-E699E03C-2689-4B56-B303-8E8529C5D99E" title="An In-Memory scan retrieves rows from the In-Memory Column Store (IM column store).">In-Memory Table Scans</a></p>
                           </div>
                        </div>
                     </div>
                     
                  </div>
               </div>
            </div><a id="TGSQL234"></a><div class="props_rev_3"><a id="GUID-B33945C3-CCC0-4D35-AF62-DB80FD4256A6" name="GUID-B33945C3-CCC0-4D35-AF62-DB80FD4256A6"></a><h3 id="TGSQL-GUID-B33945C3-CCC0-4D35-AF62-DB80FD4256A6" class="sect3"><span class="enumeration_section">8.3 </span>B-Tree Index Access Paths
               </h3>
               <div>
                  <p>An <strong class="term">index</strong> is an optional structure, associated with a table or table cluster, that can sometimes speed data access.
                  </p>
                  <p>By creating an index on one or more columns of a table, you gain the ability in some cases to retrieve a small set of randomly distributed rows from the table. Indexes are one of many means of reducing disk I/O.</p>
                  <p>This section contains the following topics:</p>
               </div>
               <div>
                  <ul class="ullinks">
                     <li class="ulchildlink"><a href="optimizer-access-paths.html#GUID-8BE7E6B2-C8C2-494C-9AE8-8EA252622F7C">About B-Tree Index Access</a><br>B-trees, short for <span class="italic">balanced trees</span>, are the most common type of database index. 
                     </li>
                     <li class="ulchildlink"><a href="optimizer-access-paths.html#GUID-273588A7-A8E9-4E1E-BE35-060073533B47">Index Unique Scans</a><br>An <strong class="term">index unique scan</strong> returns at most 1 rowid.
                     </li>
                     <li class="ulchildlink"><a href="optimizer-access-paths.html#GUID-E2353939-DFBD-444A-94BC-2497E2A418D1">Index Range Scans</a><br>An <strong class="term">index range scan</strong> is an ordered scan of values.
                     </li>
                     <li class="ulchildlink"><a href="optimizer-access-paths.html#GUID-3D9D3DBD-CF89-4320-8C5E-6BE6A127AC39">Index Full Scans</a><br>An <strong class="term">index full scan</strong> reads the entire index in order. An index full scan can eliminate a separate sorting operation because the data in the index is ordered by index key. 
                     </li>
                     <li class="ulchildlink"><a href="optimizer-access-paths.html#GUID-A2F2A81F-4626-45A1-B2A6-D46107E74C3C">Index Fast Full Scans</a><br>An <strong class="term">index fast full scan</strong> reads the index blocks in unsorted order, as they exist on disk. This scan does not use the index to probe the table, but reads the index instead of the table, essentially using the index itself as a table.
                     </li>
                     <li class="ulchildlink"><a href="optimizer-access-paths.html#GUID-B7C62F0F-EB7C-422C-919D-D86456A74A60">Index Skip Scans</a><br>An <strong class="term">index skip scan</strong> occurs when the initial column of a composite index is "skipped" or not specified in the query.
                     </li>
                     <li class="ulchildlink"><a href="optimizer-access-paths.html#GUID-21258F63-7506-4019-9FB4-323E9D2DE087">Index Join Scans</a><br>An index join scan is a hash join of multiple indexes that together return all columns requested by a query. The database does not need to access the table because all data is retrieved from the indexes.
                     </li>
                  </ul>
                  <div class="infoboxnotealso" id="GUID-B33945C3-CCC0-4D35-AF62-DB80FD4256A6__GUID-C8024B4D-F55F-4F8B-ACFE-EF6953A6C4DA">
                     <p class="notep1">See Also:</p>
                     <ul style="list-style-type: disc;">
                        <li>
                           <p><a href="https://www.oracle.com/pls/topic/lookup?ctx=en/database/oracle/oracle-database/19/tgsql&amp;id=CNCPT1170" target="_blank"><span><cite>Oracle Database Concepts</cite></span></a> for an overview of indexes
                           </p>
                        </li>
                        <li>
                           <p><a href="../admin/managing-indexes.html#ADMIN016" target="_blank"><span><cite>Oracle Database Administrator’s Guide</cite></span></a> to learn more about automatic and manual index creation
                           </p>
                        </li>
                     </ul>
                  </div>
                  <div class="familylinks">
                     <div class="parentlink">
                        <p><strong>Parent topic:</strong> <a href="optimizer-access-paths.html#GUID-00711237-35D3-4CFC-A234-59B3EC53DCD1" title="An access path is a technique used by a query to retrieve rows from a row source.">Optimizer Access Paths</a></p>
                     </div>
                  </div>
               </div>
               <a id="TGSQL95153"></a><div class="props_rev_3"><a id="GUID-8BE7E6B2-C8C2-494C-9AE8-8EA252622F7C" name="GUID-8BE7E6B2-C8C2-494C-9AE8-8EA252622F7C"></a><h4 id="TGSQL-GUID-8BE7E6B2-C8C2-494C-9AE8-8EA252622F7C" class="sect4"><span class="enumeration_section">8.3.1 </span>About B-Tree Index Access
                  </h4>
                  <div>
                     <p>B-trees, short for <span class="italic">balanced trees</span>, are the most common type of database index. 
                     </p>
                     <p>A <a href="glossary.html#GUID-17862722-BD0C-42A4-A669-1FC18F0EA0C9"><span class="xrefglossterm">B-tree index</span></a> is an ordered list of values divided into ranges. By associating a key with a row or range of rows, B-trees provide excellent retrieval performance for a wide range of queries, including exact match and range searches.
                     </p>
                     <p>This section contains the following topics:</p>
                  </div>
                  <div>
                     <ul class="ullinks">
                        <li class="ulchildlink"><a href="optimizer-access-paths.html#GUID-D25B037E-044A-4172-9305-EC06DB0ED30C">B-Tree Index Structure</a><br>A B-tree index has two types of blocks: branch blocks for searching and leaf blocks that store values. 
                        </li>
                        <li class="ulchildlink"><a href="optimizer-access-paths.html#GUID-A5337544-10FC-42A4-99E7-988493E21688">How Index Storage Affects Index Scans</a><br>Bitmap index blocks can appear anywhere in the index segment.
                        </li>
                        <li class="ulchildlink"><a href="optimizer-access-paths.html#GUID-17F4E96E-B649-4A55-9A7C-87D8B57A557C">Unique and Nonunique Indexes</a><br>In a nonunique index, the database stores the rowid by appending it to the key as an extra column. The entry adds a length byte to make the key unique. 
                        </li>
                        <li class="ulchildlink"><a href="optimizer-access-paths.html#GUID-AD533A0C-E46F-4FB0-8C34-881A0E30E93A">B-Tree Indexes and Nulls</a><br>B-tree indexes never store completely null keys, which is important for how the optimizer chooses access paths. A consequence of this rule is that single-column B-tree indexes never store nulls.
                        </li>
                     </ul>
                     <div class="familylinks">
                        <div class="parentlink">
                           <p><strong>Parent topic:</strong> <a href="optimizer-access-paths.html#GUID-B33945C3-CCC0-4D35-AF62-DB80FD4256A6" title="An index is an optional structure, associated with a table or table cluster, that can sometimes speed data access.">B-Tree Index Access Paths</a></p>
                        </div>
                     </div>
                  </div>
                  <a id="TGSQL95154"></a><div class="props_rev_3"><a id="GUID-D25B037E-044A-4172-9305-EC06DB0ED30C" name="GUID-D25B037E-044A-4172-9305-EC06DB0ED30C"></a><h5 id="TGSQL-GUID-D25B037E-044A-4172-9305-EC06DB0ED30C" class="sect5"><span class="enumeration_section">8.3.1.1 </span>B-Tree Index Structure
                     </h5>
                     <div>
                        <p>A B-tree index has two types of blocks: branch blocks for searching and leaf blocks that store values. </p>
                        <p>The following graphic illustrates the logical structure of a B-tree index. Branch blocks store the minimum key prefix needed to make a branching decision between two keys. The leaf blocks contain every indexed data value and a corresponding rowid used to locate the actual row. Each index entry is sorted by (key, rowid). The leaf blocks are doubly linked.</p>
                        <div class="figure" id="GUID-D25B037E-044A-4172-9305-EC06DB0ED30C__CHDJJDIG">
                           <p class="titleinfigure">Figure 8-3 B-Tree Index Structure</p><img src="img/cncpt244.gif" alt="Description of Figure 8-3 follows" title="Description of Figure 8-3 follows" longdesc="img_text/cncpt244.html"><br><a href="img_text/cncpt244.html">Description of "Figure 8-3 B-Tree Index Structure"</a></div>
                        <!-- class="figure" -->
                     </div>
                     <div>
                        <div class="familylinks">
                           <div class="parentlink">
                              <p><strong>Parent topic:</strong> <a href="optimizer-access-paths.html#GUID-8BE7E6B2-C8C2-494C-9AE8-8EA252622F7C" title="B-trees, short for balanced trees, are the most common type of database index.">About B-Tree Index Access</a></p>
                           </div>
                        </div>
                     </div>
                     
                  </div><a id="TGSQL95155"></a><div class="props_rev_3"><a id="GUID-A5337544-10FC-42A4-99E7-988493E21688" name="GUID-A5337544-10FC-42A4-99E7-988493E21688"></a><h5 id="TGSQL-GUID-A5337544-10FC-42A4-99E7-988493E21688" class="sect5"><span class="enumeration_section">8.3.1.2 </span>How Index Storage Affects Index Scans
                     </h5>
                     <div>
                        <p>Bitmap index blocks can appear anywhere in the index segment.</p>
                        <p><a href="optimizer-access-paths.html#GUID-D25B037E-044A-4172-9305-EC06DB0ED30C__CHDJJDIG">Figure 8-3</a> shows the leaf blocks as adjacent to each other. For example, the <code class="codeph">1-10</code> block is next to and before the <code class="codeph">11-19</code> block. This sequencing illustrates the linked lists that connect the index entries. However, index blocks need not be stored in order within an <span class="italic">index segment</span>. For example, the <code class="codeph">246-250</code> block could appear anywhere in the segment, including directly before the <code class="codeph">1-10</code> block. For this reason, ordered index scans must perform single-block I/O. The database must read an index block to determine which index block it must read next.
                        </p>
                        <p>The index block body stores the index entries in a heap, just like table rows. For example, if the value <code class="codeph">10</code> is inserted first into a table, then the index entry with key <code class="codeph">10</code> might be inserted at the bottom of the index block. If <code class="codeph">0</code> is inserted next into the table, then the index entry for key <code class="codeph">0</code> might be inserted on top of the entry for <code class="codeph">10</code>. Thus, the index entries in the block <span class="italic">body</span> are not stored in key order. However, within the index block, the row header stores records in key order. For example, the first record in the header points to the index entry with key <code class="codeph">0</code>, and so on sequentially up to the record that points to the index entry with key <code class="codeph">10</code>. Thus, index scans can read the row header to determine where to begin and end range scans, avoiding the necessity of reading every entry in the block.
                        </p>
                     </div>
                     <div>
                        <div class="infoboxnotealso" id="GUID-A5337544-10FC-42A4-99E7-988493E21688__GUID-62381F81-A5C7-40CA-9733-3B10B4730931">
                           <p class="notep1">See Also:</p>
                           <p><a href="../cncpt/logical-storage-structures.html#CNCPT89223" target="_blank"><span><cite>Oracle Database Concepts</cite></span></a> to learn about index blocks
                           </p>
                        </div>
                        <div class="familylinks">
                           <div class="parentlink">
                              <p><strong>Parent topic:</strong> <a href="optimizer-access-paths.html#GUID-8BE7E6B2-C8C2-494C-9AE8-8EA252622F7C" title="B-trees, short for balanced trees, are the most common type of database index.">About B-Tree Index Access</a></p>
                           </div>
                        </div>
                     </div>
                     
                  </div><a id="TGSQL95156"></a><div class="props_rev_3"><a id="GUID-17F4E96E-B649-4A55-9A7C-87D8B57A557C" name="GUID-17F4E96E-B649-4A55-9A7C-87D8B57A557C"></a><h5 id="TGSQL-GUID-17F4E96E-B649-4A55-9A7C-87D8B57A557C" class="sect5"><span class="enumeration_section">8.3.1.3 </span>Unique and Nonunique Indexes
                     </h5>
                     <div>
                        <p>In a nonunique index, the database stores the rowid by appending it to the key as an extra column. The entry adds a length byte to make the key unique. </p>
                        <p>For example, the first index key in the nonunique index shown in <a href="optimizer-access-paths.html#GUID-D25B037E-044A-4172-9305-EC06DB0ED30C__CHDJJDIG">Figure 8-3</a> is the pair <code class="codeph">0<span class="codeinlineitalic">,rowid</span></code> and not simply <code class="codeph">0</code>. The database sorts the data by index key values and then by rowid ascending. For example, the entries are sorted as follows:
                        </p><pre class="pre codeblock"><code>0,AAAPvCAAFAAAAFaAA<span class="bold">a</span>
0,AAAPvCAAFAAAAFaAA<span class="bold">g</span>
0,AAAPvCAAFAAAAFaAA<span class="bold">l</span>
2,AAAPvCAAFAAAAFaAA<span class="bold">m</span>
</code></pre><p>In a unique index, the index key does not include the rowid. The database sorts the data only by the index key values, such as <code class="codeph">0</code>, <code class="codeph">1</code>, <code class="codeph">2</code>, and so on.
                        </p>
                     </div>
                     <div>
                        <div class="infoboxnotealso" id="GUID-17F4E96E-B649-4A55-9A7C-87D8B57A557C__GUID-6D8540D0-5BDE-4F69-A884-A91413C01967">
                           <p class="notep1">See Also:</p>
                           <p><a href="../cncpt/indexes-and-index-organized-tables.html#CNCPT1157" target="_blank"><span><cite>Oracle Database Concepts</cite></span></a> for an overview of unique and nonunique indexes
                           </p>
                        </div>
                        <div class="familylinks">
                           <div class="parentlink">
                              <p><strong>Parent topic:</strong> <a href="optimizer-access-paths.html#GUID-8BE7E6B2-C8C2-494C-9AE8-8EA252622F7C" title="B-trees, short for balanced trees, are the most common type of database index.">About B-Tree Index Access</a></p>
                           </div>
                        </div>
                     </div>
                     
                  </div><a id="TGSQL95157"></a><div class="props_rev_3"><a id="GUID-AD533A0C-E46F-4FB0-8C34-881A0E30E93A" name="GUID-AD533A0C-E46F-4FB0-8C34-881A0E30E93A"></a><h5 id="TGSQL-GUID-AD533A0C-E46F-4FB0-8C34-881A0E30E93A" class="sect5"><span class="enumeration_section">8.3.1.4 </span>B-Tree Indexes and Nulls
                     </h5>
                     <div>
                        <p>B-tree indexes never store completely null keys, which is important for how the optimizer chooses access paths. A consequence of this rule is that single-column B-tree indexes never store nulls.</p>
                        <p>An example helps illustrate. The <code class="codeph">hr.employees</code> table has a primary key index on <code class="codeph">employee_id</code>, and a unique index on <code class="codeph">department_id</code>. The <code class="codeph">department_id</code> column can contain nulls, making it a <span class="italic">nullable column</span>, but the <code class="codeph">employee_id</code> column cannot.
                        </p><pre class="pre codeblock"><code>SQL&gt; SELECT COUNT(*) FROM employees WHERE department_id IS NULL;
 
  COUNT(*)
----------
         1
 
SQL&gt; SELECT COUNT(*) FROM employees WHERE employee_id IS NULL;
 
  COUNT(*)
----------
         0
</code></pre><p>The following example shows that the optimizer chooses a full table scan for a query of all department IDs in <code class="codeph">hr.employees</code>. The optimizer cannot use the index on <code class="codeph">employees.department_id</code> because the index is not guaranteed to include entries for every row in the table.
                        </p><pre class="pre codeblock"><code>SQL&gt; EXPLAIN PLAN FOR SELECT department_id FROM employees;
 
Explained.
 
SQL&gt; SELECT PLAN_TABLE_OUTPUT FROM TABLE(DBMS_XPLAN.DISPLAY());
 
PLAN_TABLE_OUTPUT
--------------------------------------------------------------------------------
Plan hash value: 3476115102
 
-------------------------------------------------------------------------------
| Id  | Operation         | Name      | Rows  | Bytes | Cost (%CPU)| Time     |
-------------------------------------------------------------------------------
|   0 | SELECT STATEMENT  |           |   107 |   321 |     2   (0)| 00:00:01 |
|   1 |  TABLE ACCESS FULL| EMPLOYEES |   107 |   321 |     2   (0)| 00:00:01 |
-------------------------------------------------------------------------------
 
8 rows selected.
</code></pre><p>The following example shows the optimizer can use the index on <code class="codeph">department_id</code> for a query of a specific department ID because all non-null rows are indexed.
                        </p><pre class="pre codeblock"><code>SQL&gt; EXPLAIN PLAN FOR SELECT department_id FROM employees WHERE department_id=10;
 
Explained.
 
SQL&gt; SELECT PLAN_TABLE_OUTPUT FROM TABLE(DBMS_XPLAN.DISPLAY());
 
PLAN_TABLE_OUTPUT
--------------------------------------------------------------------------------
Plan hash value: 67425611
 
--------------------------------------------------------------------------------
| Id| Operation        | Name              | Rows |Bytes| Cost (%CPU)| Time    |
--------------------------------------------------------------------------------
 
PLAN_TABLE_OUTPUT
--------------------------------------------------------------------------------
| 0 | SELECT STATEMENT |                   |   1 |   3 |     1   (0)| 00:0 0:01|
|*1 |  INDEX RANGE SCAN| EMP_DEPARTMENT_IX |   1 |   3 |     1   (0)| 00:0 0:01|
--------------------------------------------------------------------------------
 
Predicate Information (identified by operation id):
 
PLAN_TABLE_OUTPUT
-------------------------------------------------------------------------------- 
   1 - access("DEPARTMENT_ID"=10)
</code></pre><p>The following example shows that the optimizer chooses an index scan when the predicate excludes null values:</p><pre class="pre codeblock"><code>SQL&gt; EXPLAIN PLAN FOR SELECT department_id FROM employees 
WHERE department_id IS NOT NULL;

Explained.

SQL&gt; SELECT PLAN_TABLE_OUTPUT FROM TABLE(DBMS_XPLAN.DISPLAY());
 
PLAN_TABLE_OUTPUT
--------------------------------------------------------------------------------
Plan hash value: 1590637672
 
--------------------------------------------------------------------------------
| Id| Operation        | Name              | Rows|Bytes| Cost (%CPU)| Time     |
-------------------------------------------------------------------------------- 
| 0 | SELECT STATEMENT |                   | 106 | 318 |    1   (0)| 00:0 0:01 |
|*1 |  INDEX FULL SCAN | EMP_DEPARTMENT_IX | 106 | 318 |    1   (0)| 00:0 0:01 |
--------------------------------------------------------------------------------
 
Predicate Information (identified by operation id):
 
PLAN_TABLE_OUTPUT
--------------------------------------------------------------------------------
 
   1 - filter("DEPARTMENT_ID" IS NOT NULL)</code></pre></div>
                     <div>
                        <div class="familylinks">
                           <div class="parentlink">
                              <p><strong>Parent topic:</strong> <a href="optimizer-access-paths.html#GUID-8BE7E6B2-C8C2-494C-9AE8-8EA252622F7C" title="B-trees, short for balanced trees, are the most common type of database index.">About B-Tree Index Access</a></p>
                           </div>
                        </div>
                     </div>
                     
                  </div>
               </div><a id="TGSQL235"></a><div class="props_rev_3"><a id="GUID-273588A7-A8E9-4E1E-BE35-060073533B47" name="GUID-273588A7-A8E9-4E1E-BE35-060073533B47"></a><h4 id="TGSQL-GUID-273588A7-A8E9-4E1E-BE35-060073533B47" class="sect4"><span class="enumeration_section">8.3.2 </span>Index Unique Scans
                  </h4>
                  <div>
                     <p>An <strong class="term">index unique scan</strong> returns at most 1 rowid.
                     </p>
                     <p>This section contains the following topics:</p>
                  </div>
                  <div>
                     <ul class="ullinks">
                        <li class="ulchildlink"><a href="optimizer-access-paths.html#GUID-EB831554-3F2E-4538-91DC-90FF27DF054E">When the Optimizer Considers Index Unique Scans</a><br>An index unique scan requires an equality predicate.
                        </li>
                        <li class="ulchildlink"><a href="optimizer-access-paths.html#GUID-CF0FFA06-7599-4293-8F7D-A9F12647218D">How Index Unique Scans Work</a><br>The scan searches the index in order for the specified key. An index unique scan stops processing as soon as it finds the first record because no second record is possible. The database obtains the rowid from the index entry, and then retrieves the row specified by the rowid.
                        </li>
                        <li class="ulchildlink"><a href="optimizer-access-paths.html#GUID-D7A22ABD-88A4-4B9F-BAEA-D47E5DA8AA56">Index Unique Scans: Example</a><br>This example uses a unique scan to retrieve a row from the <code class="codeph">products</code> table.
                        </li>
                     </ul>
                     <div class="familylinks">
                        <div class="parentlink">
                           <p><strong>Parent topic:</strong> <a href="optimizer-access-paths.html#GUID-B33945C3-CCC0-4D35-AF62-DB80FD4256A6" title="An index is an optional structure, associated with a table or table cluster, that can sometimes speed data access.">B-Tree Index Access Paths</a></p>
                        </div>
                     </div>
                  </div>
                  <a id="TGSQL94669"></a><div class="props_rev_3"><a id="GUID-EB831554-3F2E-4538-91DC-90FF27DF054E" name="GUID-EB831554-3F2E-4538-91DC-90FF27DF054E"></a><h5 id="TGSQL-GUID-EB831554-3F2E-4538-91DC-90FF27DF054E" class="sect5"><span class="enumeration_section">8.3.2.1 </span>When the Optimizer Considers Index Unique Scans
                     </h5>
                     <div>
                        <p>An index unique scan requires an equality predicate.</p>
                        <p>Specifically, the database performs a unique scan only when a query predicate references all columns in a unique index key using an equality operator, such as <code class="codeph">WHERE prod_id=10</code>.
                        </p>
                        <p>A unique or primary key constraint is insufficient by itself to produce an index unique scan because a non-unique index on the column may already exist. Consider the following example, which creates the <code class="codeph">t_table</code> table and then creates a non-unique index on <code class="codeph">numcol</code>:
                        </p><pre class="pre codeblock"><code>SQL&gt; CREATE TABLE t_table(numcol INT);
SQL&gt; CREATE INDEX t_table_idx ON t_table(numcol);
SQL&gt; SELECT UNIQUENESS FROM USER_INDEXES WHERE INDEX_NAME = 'T_TABLE_IDX';

UNIQUENES
---------
NONUNIQUE
</code></pre><p>The following code creates a primary key constraint on a column with a non-unique index, resulting in an index range scan rather than an index unique scan:</p><pre class="pre codeblock"><code>SQL&gt; ALTER TABLE t_table ADD CONSTRAINT t_table_pk PRIMARY KEY(numcol);
SQL&gt; SET AUTOTRACE TRACEONLY EXPLAIN
SQL&gt; SELECT * FROM t_table WHERE numcol = 1;
 
Execution Plan
----------------------------------------------------------
Plan hash value: 868081059
 
--------------------------------------------------------------------------------
| Id  | Operation        | Name        | Rows  | Bytes | Cost (%CPU)| Time     |
--------------------------------------------------------------------------------
|   0 | SELECT STATEMENT |             |     1 |    13 |     1   (0)| 00:00:01 |
|*  1 |  <span class="bold">INDEX RANGE SCAN</span>| T_TABLE_IDX |     1 |    13 |     1   (0)| 00:00:01 |
--------------------------------------------------------------------------------
 
Predicate Information (identified by operation id):
---------------------------------------------------
    1 - access("NUMCOL"=1)
 </code></pre><p>You can use the <code class="codeph">INDEX(</code><span class="italic"><code class="codeph">alias index_name</code></span><code class="codeph">)</code> hint to specify the index to use, but not a specific type of index access path.
                        </p>
                     </div>
                     <div>
                        <div class="infoboxnotealso" id="GUID-EB831554-3F2E-4538-91DC-90FF27DF054E__GUID-D499F130-647A-4E26-8359-11A25DCA65B4">
                           <p class="notep1">See Also:</p>
                           <p></p>
                           <ul style="list-style-type: disc;">
                              <li>
                                 <p><a href="../cncpt/tables-and-table-clusters.html#CNCPT010" target="_blank"><span><cite>Oracle Database Concepts</cite></span></a><span class="italic"> </span>for more details on index structures and for detailed information on how a B-tree is searched
                                 </p>
                              </li>
                              <li>
                                 <p><a href="../sqlrf/Comments.html#SQLRF50409" target="_blank"><span><cite>Oracle Database SQL Language Reference</cite></span></a> to learn more about the <code class="codeph">INDEX</code> hint
                                 </p>
                              </li>
                           </ul>
                        </div>
                        <div class="familylinks">
                           <div class="parentlink">
                              <p><strong>Parent topic:</strong> <a href="optimizer-access-paths.html#GUID-273588A7-A8E9-4E1E-BE35-060073533B47" title="An index unique scan returns at most 1 rowid.">Index Unique Scans</a></p>
                           </div>
                        </div>
                     </div>
                     
                  </div><a id="TGSQL95159"></a><a id="TGSQL95158"></a><div class="props_rev_3"><a id="GUID-CF0FFA06-7599-4293-8F7D-A9F12647218D" name="GUID-CF0FFA06-7599-4293-8F7D-A9F12647218D"></a><h5 id="TGSQL-GUID-CF0FFA06-7599-4293-8F7D-A9F12647218D" class="sect5"><span class="enumeration_section">8.3.2.2 </span>How Index Unique Scans Work
                     </h5>
                     <div>
                        <p>The scan searches the index in order for the specified key. An index unique scan stops processing as soon as it finds the first record because no second record is possible. The database obtains the rowid from the index entry, and then retrieves the row specified by the rowid.</p>
                        <p>The following figure illustrates an index unique scan. The statement requests the record for product ID <code class="codeph">19</code> in the <code class="codeph">prod_id</code> column, which has a primary key index.
                        </p>
                        <div class="figure" id="GUID-CF0FFA06-7599-4293-8F7D-A9F12647218D__CHDBGECB">
                           <p class="titleinfigure">Figure 8-4 Index Unique Scan</p><img src="img/cncpt372.png" alt="Description of Figure 8-4 follows" title="Description of Figure 8-4 follows" longdesc="img_text/cncpt372.html"><br><a href="img_text/cncpt372.html">Description of "Figure 8-4 Index Unique Scan"</a></div>
                        <!-- class="figure" -->
                     </div>
                     <div>
                        <div class="familylinks">
                           <div class="parentlink">
                              <p><strong>Parent topic:</strong> <a href="optimizer-access-paths.html#GUID-273588A7-A8E9-4E1E-BE35-060073533B47" title="An index unique scan returns at most 1 rowid.">Index Unique Scans</a></p>
                           </div>
                        </div>
                     </div>
                     
                  </div><a id="TGSQL95160"></a><a id="TGSQL94670"></a><div class="props_rev_3"><a id="GUID-D7A22ABD-88A4-4B9F-BAEA-D47E5DA8AA56" name="GUID-D7A22ABD-88A4-4B9F-BAEA-D47E5DA8AA56"></a><h5 id="TGSQL-GUID-D7A22ABD-88A4-4B9F-BAEA-D47E5DA8AA56" class="sect5"><span class="enumeration_section">8.3.2.3 </span>Index Unique Scans: Example
                     </h5>
                     <div>
                        <p>This example uses a unique scan to retrieve a row from the <code class="codeph">products</code> table.
                        </p>
                        <div class="example" id="GUID-D7A22ABD-88A4-4B9F-BAEA-D47E5DA8AA56__CHDHFIEG">
                           <p>The following statement queries the record for product <code class="codeph">19</code> in the <code class="codeph">sh.products</code> table:
                           </p><pre class="pre codeblock"><code>SELECT * 
FROM   sh.products 
WHERE  prod_id = 19;
</code></pre><p>Because a primary key index exists on the <code class="codeph">products.prod_id</code> column, and the <code class="codeph">WHERE</code> clause references all of the columns using an equality operator, the optimizer chooses a unique scan:
                           </p><pre class="pre codeblock"><code>SQL_ID  3ptq5tsd5vb3d, child number 0
-------------------------------------
select * from sh.products where prod_id = 19
 
Plan hash value: 4047888317
 
--------------------------------------------------------------------------------
| Id| Operation                   | Name        |Rows|Bytes|Cost (%CPU)|Time   |
--------------------------------------------------------------------------------
|  0| SELECT STATEMENT            |             |    |     |  1 (100)|         |
|  1|  TABLE ACCESS BY INDEX ROWID| PRODUCTS    |  1 | 173 |  1   (0)| 00:00:01|
|* 2|   <span class="bold">INDEX UNIQUE SCAN</span>         | PRODUCTS_PK |  1 |     |  0   (0)|         |
--------------------------------------------------------------------------------
 
Predicate Information (identified by operation id):
---------------------------------------------------
 
   2 - access("PROD_ID"=19)</code></pre></div>
                        <!-- class="example" -->
                     </div>
                     <div>
                        <div class="familylinks">
                           <div class="parentlink">
                              <p><strong>Parent topic:</strong> <a href="optimizer-access-paths.html#GUID-273588A7-A8E9-4E1E-BE35-060073533B47" title="An index unique scan returns at most 1 rowid.">Index Unique Scans</a></p>
                           </div>
                        </div>
                     </div>
                     
                  </div>
               </div><a id="TGSQL236"></a><div class="props_rev_3"><a id="GUID-E2353939-DFBD-444A-94BC-2497E2A418D1" name="GUID-E2353939-DFBD-444A-94BC-2497E2A418D1"></a><h4 id="TGSQL-GUID-E2353939-DFBD-444A-94BC-2497E2A418D1" class="sect4"><span class="enumeration_section">8.3.3 </span>Index Range Scans
                  </h4>
                  <div>
                     <p>An <strong class="term">index range scan</strong> is an ordered scan of values.
                     </p>
                     <p> The range in the scan can be bounded on both sides, or unbounded on one or both sides. The optimizer typically chooses a range scan for queries with high <a href="glossary.html#GUID-36E411B8-9558-4655-844A-B2EC45FDDFA7"><span class="xrefglossterm">selectivity</span></a>.
                     </p>
                     <p>By default, the database stores indexes in ascending order, and scans them in the same order. For example, a query with the predicate <code class="codeph">department_id &gt;= 20</code> uses a range scan to return rows sorted by index keys <code class="codeph">20</code>, <code class="codeph">30</code>, <code class="codeph">40</code>, and so on. If multiple index entries have identical keys, then the database returns them in ascending order by rowid, so that <code class="codeph">0,AAAPvCAAFAAAAFaAAa</code> is followed by <code class="codeph">0,AAAPvCAAFAAAAFaAAg</code>, and so on.
                     </p>
                     <p>An <a href="glossary.html#GUID-9F69618A-2844-4912-A972-B42D2DC01DE5"><span class="xrefglossterm">index range scan descending</span></a> is identical to an index range scan except that the database returns rows in descending order. Usually, the database uses a descending scan when ordering data in a descending order, or when seeking a value less than a specified value.
                     </p>
                     <p>This section contains the following topics:</p>
                  </div>
                  <div>
                     <ul class="ullinks">
                        <li class="ulchildlink"><a href="optimizer-access-paths.html#GUID-C385AF64-F467-499B-95C8-0E3AB5681D5F">When the Optimizer Considers Index Range Scans</a><br>For an index range scan, multiple values must be possible for the index key.
                        </li>
                        <li class="ulchildlink"><a href="optimizer-access-paths.html#GUID-47C03736-2240-47DE-A78A-E21A8DABAC45">How Index Range Scans Work</a><br>During an index range scan, Oracle Database proceeds from root to branch.
                        </li>
                        <li class="ulchildlink"><a href="optimizer-access-paths.html#GUID-603B2A7A-5EED-47B1-A407-128E2E80979D">Index Range Scan: Example</a><br>This example retrieves a set of values from the <code class="codeph">employees</code> table using an index range scan.
                        </li>
                        <li class="ulchildlink"><a href="optimizer-access-paths.html#GUID-1853B7EE-53A0-484F-8290-BEF4E299CDA7">Index Range Scan Descending: Example</a><br>This example uses an index to retrieve rows from the <code class="codeph">employees</code> table in sorted order.
                        </li>
                     </ul>
                     <div class="familylinks">
                        <div class="parentlink">
                           <p><strong>Parent topic:</strong> <a href="optimizer-access-paths.html#GUID-B33945C3-CCC0-4D35-AF62-DB80FD4256A6" title="An index is an optional structure, associated with a table or table cluster, that can sometimes speed data access.">B-Tree Index Access Paths</a></p>
                        </div>
                     </div>
                  </div>
                  <a id="TGSQL94672"></a><div class="props_rev_3"><a id="GUID-C385AF64-F467-499B-95C8-0E3AB5681D5F" name="GUID-C385AF64-F467-499B-95C8-0E3AB5681D5F"></a><h5 id="TGSQL-GUID-C385AF64-F467-499B-95C8-0E3AB5681D5F" class="sect5"><span class="enumeration_section">8.3.3.1 </span>When the Optimizer Considers Index Range Scans
                     </h5>
                     <div>
                        <p>For an index range scan, multiple values must be possible for the index key.</p>
                        <p>Specifically, the optimizer considers index range scans in the following circumstances:</p>
                        <ul style="list-style-type: disc;">
                           <li>
                              <p>One or more leading columns of an index are specified in conditions.</p>
                              <p>A condition specifies a combination of one or more expressions and logical (Boolean) operators and returns a value of <code class="codeph">TRUE</code>, <code class="codeph">FALSE</code>, or <code class="codeph">UNKNOWN</code>. Examples of conditions include:
                              </p>
                              <ul style="list-style-type: disc;">
                                 <li>
                                    <p><code class="codeph">department_id = :id</code></p>
                                 </li>
                                 <li>
                                    <p><code class="codeph">department_id &lt; :id</code></p>
                                 </li>
                                 <li>
                                    <p><code class="codeph">department_id &gt; :id</code></p>
                                 </li>
                                 <li>
                                    <p><code class="codeph">AND </code>combination of the preceding conditions for leading columns in the index, such as <code class="codeph">department_id &gt; :low AND department_id &lt; :hi</code>.
                                    </p>
                                    <div class="infoboxnote" id="GUID-C385AF64-F467-499B-95C8-0E3AB5681D5F__GUID-182C7C9D-3469-40C0-AE75-23FF9175DE22">
                                       <p class="notep1">Note:</p>
                                       <p>For the optimizer to consider a range scan, wild-card searches of the form <code class="codeph">col1 LIKE '%ASD'</code> must not be in a leading position.
                                       </p>
                                    </div>
                                 </li>
                              </ul>
                           </li>
                           <li>
                              <p>0, 1, or more values are possible for an index key.</p>
                           </li>
                        </ul>
                        <div class="infobox-tip" id="GUID-C385AF64-F467-499B-95C8-0E3AB5681D5F__GUID-7F126297-53DE-4238-B495-9F8FE767CA86">
                           <p class="notep1">Tip:</p>
                           <p>If you require sorted data, then use the <code class="codeph">ORDER</code> <code class="codeph">BY</code> clause, and do not rely on an index. If an index can satisfy an <code class="codeph">ORDER</code> <code class="codeph">BY</code> clause, then the optimizer uses this option and thereby avoids a sort.
                           </p>
                        </div>
                        <p>The optimizer considers an index range scan descending when an index can satisfy an <code class="codeph">ORDER BY DESCENDING</code> clause.
                        </p>
                        <p>If the optimizer chooses a full table scan or another index, then a hint may be required to force this access path. The <code class="codeph">INDEX(</code><span class="italic"><code class="codeph">tbl_alias</code></span> <span class="italic"><code class="codeph">ix_name</code></span><code class="codeph">)</code> and <code class="codeph">INDEX_DESC(</code><span class="italic"><code class="codeph">tbl_alias</code></span> <span class="italic"><code class="codeph">ix_name</code></span><code class="codeph">)</code> hints instruct the optimizer to use a specific index.
                        </p>
                     </div>
                     <div>
                        <div class="infoboxnotealso" id="GUID-C385AF64-F467-499B-95C8-0E3AB5681D5F__GUID-A2602786-0A40-4184-9BED-677D1D74F2AA">
                           <p class="notep1">See Also:</p>
                           <p><a href="../sqlrf/Comments.html#SQLRF50405" target="_blank"><span><cite>Oracle Database SQL Language Reference</cite></span></a> to learn more about the <code class="codeph">INDEX</code> and <code class="codeph">INDEX_DESC</code> hints
                           </p>
                        </div>
                        <div class="familylinks">
                           <div class="parentlink">
                              <p><strong>Parent topic:</strong> <a href="optimizer-access-paths.html#GUID-E2353939-DFBD-444A-94BC-2497E2A418D1" title="An index range scan is an ordered scan of values.">Index Range Scans</a></p>
                           </div>
                        </div>
                     </div>
                     
                  </div><a id="TGSQL95162"></a><a id="TGSQL95161"></a><div class="props_rev_3"><a id="GUID-47C03736-2240-47DE-A78A-E21A8DABAC45" name="GUID-47C03736-2240-47DE-A78A-E21A8DABAC45"></a><h5 id="TGSQL-GUID-47C03736-2240-47DE-A78A-E21A8DABAC45" class="sect5"><span class="enumeration_section">8.3.3.2 </span>How Index Range Scans Work
                     </h5>
                     <div>
                        <p>During an index range scan, Oracle Database proceeds from root to branch.</p>
                        <p>In general, the scan algorithm is as follows:</p>
                        <ol>
                           <li>
                              <p>Read the root block.</p>
                           </li>
                           <li>
                              <p>Read the branch block.</p>
                           </li>
                           <li>
                              <p>Alternate the following steps until all data is retrieved:</p>
                              <ol type="a">
                                 <li>
                                    <p>Read a leaf block to obtain a rowid.</p>
                                 </li>
                                 <li>
                                    <p>Read a table block to retrieve a row.</p>
                                 </li>
                              </ol>
                              <div class="infoboxnote" id="GUID-47C03736-2240-47DE-A78A-E21A8DABAC45__GUID-F8CFEBB2-393F-42CA-B17D-7C903F3A4E06">
                                 <p class="notep1">Note:</p>
                                 <p>In some cases, an index scan reads a set of index blocks, sorts the rowids, and then reads a set of table blocks.</p>
                              </div>
                           </li>
                        </ol>
                        <p>Thus, to scan the index, the database moves backward or forward through the leaf blocks. For example, a scan for IDs between 20 and 40 locates the first leaf block that has the lowest key value that is 20 or greater. The scan proceeds horizontally through the linked list of leaf nodes until it finds a value greater than 40, and then stops. </p>
                        <p>The following figure illustrates an index range scan using ascending order. A statement requests the <code class="codeph">employees</code> records with the value <code class="codeph">20</code> in the <code class="codeph">department_id</code> column, which has a nonunique index. In this example, 2 index entries for department <code class="codeph">20</code> exist.
                        </p>
                        <div class="figure" id="GUID-47C03736-2240-47DE-A78A-E21A8DABAC45__CHDGAAJA">
                           <p class="titleinfigure">Figure 8-5 Index Range Scan</p><img src="img/cncpt373.png" alt="Description of Figure 8-5 follows" title="Description of Figure 8-5 follows" longdesc="img_text/cncpt373.html"><br><a href="img_text/cncpt373.html">Description of "Figure 8-5 Index Range Scan"</a></div>
                        <!-- class="figure" -->
                     </div>
                     <div>
                        <div class="familylinks">
                           <div class="parentlink">
                              <p><strong>Parent topic:</strong> <a href="optimizer-access-paths.html#GUID-E2353939-DFBD-444A-94BC-2497E2A418D1" title="An index range scan is an ordered scan of values.">Index Range Scans</a></p>
                           </div>
                        </div>
                     </div>
                     
                  </div><a id="TGSQL94671"></a><a id="TGSQL95163"></a><div class="props_rev_3"><a id="GUID-603B2A7A-5EED-47B1-A407-128E2E80979D" name="GUID-603B2A7A-5EED-47B1-A407-128E2E80979D"></a><h5 id="TGSQL-GUID-603B2A7A-5EED-47B1-A407-128E2E80979D" class="sect5"><span class="enumeration_section">8.3.3.3 </span>Index Range Scan: Example
                     </h5>
                     <div>
                        <p>This example retrieves a set of values from the <code class="codeph">employees</code> table using an index range scan.
                        </p>
                        <div class="example" id="GUID-603B2A7A-5EED-47B1-A407-128E2E80979D__CHDEJAED">
                           <p>The following statement queries the records for employees in department <code class="codeph">20</code> with salaries greater than <code class="codeph">1000</code>:
                           </p><pre class="pre codeblock"><code>SELECT * 
FROM   employees 
WHERE  department_id = 20
AND    salary &gt; 1000;
</code></pre><p>The preceding query has low cardinality (returns few rows), so the query uses the index on the <code class="codeph">department_id</code> column. The database scans the index, fetches the records from the employees table, and then applies the <code class="codeph">salary &gt; 1000</code> filter to these fetched records to generate the result.
                           </p><pre class="pre codeblock"><code>SQL_ID  brt5abvbxw9tq, child number 0
-------------------------------------
SELECT * FROM   employees WHERE  department_id = 20 AND    salary &gt; 1000
 
Plan hash value: 2799965532
 
-------------------------------------------------------------------------------------------
|Id | Operation                           | Name             |Rows|Bytes|Cost(%CPU)| Time |
-------------------------------------------------------------------------------------------
| 0 | SELECT STATEMENT                    |                  |    |     | 2 (100)|        |
|*1 |  TABLE ACCESS BY INDEX ROWID BATCHED| EMPLOYEES        |  2 | 138 | 2   (0)|00:00:01|
|*2 |   <span class="bold">INDEX RANGE SCAN</span>                  | EMP_DEPARTMENT_IX|  2 |     | 1   (0)|00:00:01|
-------------------------------------------------------------------------------------------
 
Predicate Information (identified by operation id):
---------------------------------------------------
 
   1 - filter("SALARY"&gt;1000)
   2 - access("DEPARTMENT_ID"=20)</code></pre></div>
                        <!-- class="example" -->
                     </div>
                     <div>
                        <div class="familylinks">
                           <div class="parentlink">
                              <p><strong>Parent topic:</strong> <a href="optimizer-access-paths.html#GUID-E2353939-DFBD-444A-94BC-2497E2A418D1" title="An index range scan is an ordered scan of values.">Index Range Scans</a></p>
                           </div>
                        </div>
                     </div>
                     
                  </div><a id="TGSQL95165"></a><a id="TGSQL95164"></a><div class="props_rev_3"><a id="GUID-1853B7EE-53A0-484F-8290-BEF4E299CDA7" name="GUID-1853B7EE-53A0-484F-8290-BEF4E299CDA7"></a><h5 id="TGSQL-GUID-1853B7EE-53A0-484F-8290-BEF4E299CDA7" class="sect5"><span class="enumeration_section">8.3.3.4 </span>Index Range Scan Descending: Example
                     </h5>
                     <div>
                        <p>This example uses an index to retrieve rows from the <code class="codeph">employees</code> table in sorted order.
                        </p>
                        <div class="example" id="GUID-1853B7EE-53A0-484F-8290-BEF4E299CDA7__CHDDADJG">
                           <p>The following statement queries the records for employees in department <code class="codeph">20</code> in descending order:
                           </p><pre class="pre codeblock"><code>SELECT *
FROM   employees
WHERE  department_id &lt; 20
ORDER BY department_id DESC;
</code></pre><p>This preceding query has low cardinality, so the query uses the index on the <code class="codeph">department_id</code> column. 
                           </p><pre class="pre codeblock"><code>SQL_ID  8182ndfj1ttj6, child number 0
-------------------------------------
SELECT * FROM   employees WHERE  department_id &lt; 20 ORDER BY department_id DESC
 
Plan hash value: 1681890450
--------------------------------------------------------------------------------
|Id| Operation                    | Name           |Rows|Bytes|Cost(%CPU)|Time |
--------------------------------------------------------------------------------
| 0| SELECT STATEMENT             |                   |  |   | 2 (100)|        |
| 1|  TABLE ACCESS BY INDEX ROWID | EMPLOYEES         | 2|138| 2   (0)|00:00:01|
|*2|   <span class="bold">INDEX RANGE SCAN DESCENDING</span>| EMP_DEPARTMENT_IX | 2|   | 1   (0)|00:00:01|
--------------------------------------------------------------------------------
 
Predicate Information (identified by operation id):
---------------------------------------------------
 
   2 - access("DEPARTMENT_ID"&lt;20)</code></pre><p>The database locates the first index leaf block that contains the highest key value that is <code class="codeph">20</code> or less. The scan then proceeds horizontally to the left through the linked list of leaf nodes. The database obtains the rowid from each index entry, and then retrieves the row specified by the rowid.
                           </p>
                        </div>
                        <!-- class="example" -->
                     </div>
                     <div>
                        <div class="familylinks">
                           <div class="parentlink">
                              <p><strong>Parent topic:</strong> <a href="optimizer-access-paths.html#GUID-E2353939-DFBD-444A-94BC-2497E2A418D1" title="An index range scan is an ordered scan of values.">Index Range Scans</a></p>
                           </div>
                        </div>
                     </div>
                     
                  </div>
               </div><a id="TGSQL237"></a><div class="props_rev_3"><a id="GUID-3D9D3DBD-CF89-4320-8C5E-6BE6A127AC39" name="GUID-3D9D3DBD-CF89-4320-8C5E-6BE6A127AC39"></a><h4 id="TGSQL-GUID-3D9D3DBD-CF89-4320-8C5E-6BE6A127AC39" class="sect4"><span class="enumeration_section">8.3.4 </span>Index Full Scans
                  </h4>
                  <div>
                     <p>An <strong class="term">index full scan</strong> reads the entire index in order. An index full scan can eliminate a separate sorting operation because the data in the index is ordered by index key. 
                     </p>
                     <p>This section contains the following topics:</p>
                  </div>
                  <div>
                     <ul class="ullinks">
                        <li class="ulchildlink"><a href="optimizer-access-paths.html#GUID-52A41C2C-8E99-4375-9C0F-D80472C041E5">When the Optimizer Considers Index Full Scans</a><br>The optimizer considers an index full scan in a variety of situations.
                        </li>
                        <li class="ulchildlink"><a href="optimizer-access-paths.html#GUID-0C1D3987-9F2B-4C40-A66B-76DF05B3EBD5">How Index Full Scans Work</a><br>The database reads the root block, and then navigates down the left hand side of the index (or right if doing a descending full scan) until it reaches a leaf block. 
                        </li>
                        <li class="ulchildlink"><a href="optimizer-access-paths.html#GUID-12DF3C19-E795-447B-8E06-7DC2258F9586">Index Full Scans: Example</a><br>This example uses an index full scan to satisfy a query with an <code class="codeph">ORDER BY</code> clause.
                        </li>
                     </ul>
                     <div class="familylinks">
                        <div class="parentlink">
                           <p><strong>Parent topic:</strong> <a href="optimizer-access-paths.html#GUID-B33945C3-CCC0-4D35-AF62-DB80FD4256A6" title="An index is an optional structure, associated with a table or table cluster, that can sometimes speed data access.">B-Tree Index Access Paths</a></p>
                        </div>
                     </div>
                  </div>
                  <a id="TGSQL95166"></a><div class="props_rev_3"><a id="GUID-52A41C2C-8E99-4375-9C0F-D80472C041E5" name="GUID-52A41C2C-8E99-4375-9C0F-D80472C041E5"></a><h5 id="TGSQL-GUID-52A41C2C-8E99-4375-9C0F-D80472C041E5" class="sect5"><span class="enumeration_section">8.3.4.1 </span>When the Optimizer Considers Index Full Scans
                     </h5>
                     <div>
                        <p>The optimizer considers an index full scan in a variety of situations.</p>
                        <p>The situations include the following:</p>
                        <ul style="list-style-type: disc;">
                           <li>
                              <p>A predicate references a column in the index. This column need not be the leading column.</p>
                           </li>
                           <li>
                              <p>No predicate is specified, but all of the following conditions are met:</p>
                              <ul style="list-style-type: disc;">
                                 <li>
                                    <p>All columns in the table and in the query are in the index.</p>
                                 </li>
                                 <li>
                                    <p>At least one indexed column is not null.</p>
                                 </li>
                              </ul>
                           </li>
                           <li>
                              <p>A query includes an <code class="codeph">ORDER BY</code> on indexed non-nullable columns.
                              </p>
                           </li>
                        </ul>
                     </div>
                     <div>
                        <div class="familylinks">
                           <div class="parentlink">
                              <p><strong>Parent topic:</strong> <a href="optimizer-access-paths.html#GUID-3D9D3DBD-CF89-4320-8C5E-6BE6A127AC39" title="An index full scan reads the entire index in order. An index full scan can eliminate a separate sorting operation because the data in the index is ordered by index key.">Index Full Scans</a></p>
                           </div>
                        </div>
                     </div>
                     
                  </div><a id="TGSQL95168"></a><a id="TGSQL95167"></a><div class="props_rev_3"><a id="GUID-0C1D3987-9F2B-4C40-A66B-76DF05B3EBD5" name="GUID-0C1D3987-9F2B-4C40-A66B-76DF05B3EBD5"></a><h5 id="TGSQL-GUID-0C1D3987-9F2B-4C40-A66B-76DF05B3EBD5" class="sect5"><span class="enumeration_section">8.3.4.2 </span>How Index Full Scans Work
                     </h5>
                     <div>
                        <p>The database reads the root block, and then navigates down the left hand side of the index (or right if doing a descending full scan) until it reaches a leaf block. </p>
                        <p>Then the database reaches a leaf block, the scan proceeds across the bottom of the index, one block at a time, in sorted order. The database uses single-block I/O rather than multiblock I/O.</p>
                        <p>The following graphic illustrates an index full scan. A statement requests the <code class="codeph">departments</code> records ordered by <code class="codeph">department_id</code>.
                        </p>
                        <div class="figure" id="GUID-0C1D3987-9F2B-4C40-A66B-76DF05B3EBD5__CHDGJBJD">
                           <p class="titleinfigure">Figure 8-6 Index Full Scan</p><img src="img/cncpt374.png" alt="Description of Figure 8-6 follows" title="Description of Figure 8-6 follows" longdesc="img_text/cncpt374.html"><br><a href="img_text/cncpt374.html">Description of "Figure 8-6 Index Full Scan"</a></div>
                        <!-- class="figure" -->
                     </div>
                     <div>
                        <div class="familylinks">
                           <div class="parentlink">
                              <p><strong>Parent topic:</strong> <a href="optimizer-access-paths.html#GUID-3D9D3DBD-CF89-4320-8C5E-6BE6A127AC39" title="An index full scan reads the entire index in order. An index full scan can eliminate a separate sorting operation because the data in the index is ordered by index key.">Index Full Scans</a></p>
                           </div>
                        </div>
                     </div>
                     
                  </div><a id="TGSQL95170"></a><a id="TGSQL95169"></a><div class="props_rev_3"><a id="GUID-12DF3C19-E795-447B-8E06-7DC2258F9586" name="GUID-12DF3C19-E795-447B-8E06-7DC2258F9586"></a><h5 id="TGSQL-GUID-12DF3C19-E795-447B-8E06-7DC2258F9586" class="sect5"><span class="enumeration_section">8.3.4.3 </span>Index Full Scans: Example
                     </h5>
                     <div>
                        <p>This example uses an index full scan to satisfy a query with an <code class="codeph">ORDER BY</code> clause.
                        </p>
                        <div class="example" id="GUID-12DF3C19-E795-447B-8E06-7DC2258F9586__CHDDADAG">
                           <p>The following statement queries the ID and name for departments in order of department ID:</p><pre class="pre codeblock"><code>SELECT department_id, department_name
FROM   departments
ORDER BY department_id;
</code></pre><p>The following plan shows that the optimizer chose an index full scan:</p><pre class="pre codeblock"><code>SQL_ID  94t4a20h8what, child number 0
-------------------------------------
select department_id, department_name from departments order by department_id

Plan hash value: 4179022242

--------------------------------------------------------------------------------
|Id | Operation                   | Name        |Rows|Bytes|Cost(%CPU)|Time    |
--------------------------------------------------------------------------------
| 0 | SELECT STATEMENT            |             |    |     | 2 (100)|          |
| 1 |  TABLE ACCESS BY INDEX ROWID| DEPARTMENTS | 27 | 432 | 2   (0)| 00:00:01 |
| 2 |   <span class="bold">INDEX FULL SCAN</span>           | DEPT_ID_PK  | 27 |     | 1   (0)| 00:00:01 |
--------------------------------------------------------------------------------</code></pre><p>The database locates the first index leaf block, and then proceeds horizontally to the right through the linked list of leaf nodes. For each index entry, the database obtains the rowid from the entry, and then retrieves the table row specified by the rowid. Because the index is sorted on <code class="codeph">department_id</code>, the database avoids a separate operation to sort the retrieved rows.
                           </p>
                        </div>
                        <!-- class="example" -->
                     </div>
                     <div>
                        <div class="familylinks">
                           <div class="parentlink">
                              <p><strong>Parent topic:</strong> <a href="optimizer-access-paths.html#GUID-3D9D3DBD-CF89-4320-8C5E-6BE6A127AC39" title="An index full scan reads the entire index in order. An index full scan can eliminate a separate sorting operation because the data in the index is ordered by index key.">Index Full Scans</a></p>
                           </div>
                        </div>
                     </div>
                     
                  </div>
               </div><a id="TGSQL95171"></a><div class="props_rev_3"><a id="GUID-A2F2A81F-4626-45A1-B2A6-D46107E74C3C" name="GUID-A2F2A81F-4626-45A1-B2A6-D46107E74C3C"></a><h4 id="TGSQL-GUID-A2F2A81F-4626-45A1-B2A6-D46107E74C3C" class="sect4"><span class="enumeration_section">8.3.5 </span>Index Fast Full Scans
                  </h4>
                  <div>
                     <p>An <strong class="term">index fast full scan</strong> reads the index blocks in unsorted order, as they exist on disk. This scan does not use the index to probe the table, but reads the index instead of the table, essentially using the index itself as a table.
                     </p>
                     <p>This section contains the following topics:</p>
                  </div>
                  <div>
                     <ul class="ullinks">
                        <li class="ulchildlink"><a href="optimizer-access-paths.html#GUID-24D48935-F1B7-4D63-8DE1-0C107A17074F">When the Optimizer Considers Index Fast Full Scans</a><br>The optimizer considers this scan when a query only accesses attributes in the index. 
                        </li>
                        <li class="ulchildlink"><a href="optimizer-access-paths.html#GUID-9E1210BD-B37E-4255-BBDB-5D533BC2372F">How Index Fast Full Scans Work</a><br>The database uses multiblock I/O to read the root block and all of the leaf and branch blocks. The databases ignores the branch and root blocks and reads the index entries on the leaf blocks.
                        </li>
                        <li class="ulchildlink"><a href="optimizer-access-paths.html#GUID-09D080C6-0A1D-4282-AD08-C931B1F7B3B3">Index Fast Full Scans: Example</a><br>This examples uses a fast full index scan as a result of an optimizer hint.
                        </li>
                     </ul>
                     <div class="familylinks">
                        <div class="parentlink">
                           <p><strong>Parent topic:</strong> <a href="optimizer-access-paths.html#GUID-B33945C3-CCC0-4D35-AF62-DB80FD4256A6" title="An index is an optional structure, associated with a table or table cluster, that can sometimes speed data access.">B-Tree Index Access Paths</a></p>
                        </div>
                     </div>
                  </div>
                  <a id="TGSQL95172"></a><div class="props_rev_3"><a id="GUID-24D48935-F1B7-4D63-8DE1-0C107A17074F" name="GUID-24D48935-F1B7-4D63-8DE1-0C107A17074F"></a><h5 id="TGSQL-GUID-24D48935-F1B7-4D63-8DE1-0C107A17074F" class="sect5"><span class="enumeration_section">8.3.5.1 </span>When the Optimizer Considers Index Fast Full Scans
                     </h5>
                     <div>
                        <p>The optimizer considers this scan when a query only accesses attributes in the index. </p>
                        <div class="infoboxnote" id="GUID-24D48935-F1B7-4D63-8DE1-0C107A17074F__GUID-812B9ACE-9A8F-42E8-A7CE-B8777BB03C84">
                           <p class="notep1">Note:</p>
                           <p>Unlike a full scan, a fast full scan cannot eliminate a sort operation because it does not read the index in order.</p>
                        </div>
                        <p>The <code class="codeph">INDEX_FFS(<span class="codeinlineitalic">table_name</span><span class="codeinlineitalic"> index_name</span>)</code> hint forces a fast full index scan.
                        </p>
                     </div>
                     <div>
                        <div class="infoboxnotealso" id="GUID-24D48935-F1B7-4D63-8DE1-0C107A17074F__GUID-35BCFDE1-FE37-4A1C-AEE7-CD22000A6BC6">
                           <p class="notep1">See Also:</p>
                           <p><a href="https://www.oracle.com/pls/topic/lookup?ctx=en/database/oracle/oracle-database/19/tgsql&amp;id=SQLRF50409" target="_blank"><span><cite>Oracle Database SQL Language Reference</cite></span></a> to learn more about the <code class="codeph">INDEX</code> hint
                           </p>
                        </div>
                        <div class="familylinks">
                           <div class="parentlink">
                              <p><strong>Parent topic:</strong> <a href="optimizer-access-paths.html#GUID-A2F2A81F-4626-45A1-B2A6-D46107E74C3C" title="An index fast full scan reads the index blocks in unsorted order, as they exist on disk. This scan does not use the index to probe the table, but reads the index instead of the table, essentially using the index itself as a table.">Index Fast Full Scans</a></p>
                           </div>
                        </div>
                     </div>
                     
                  </div><a id="TGSQL95173"></a><div class="props_rev_3"><a id="GUID-9E1210BD-B37E-4255-BBDB-5D533BC2372F" name="GUID-9E1210BD-B37E-4255-BBDB-5D533BC2372F"></a><h5 id="TGSQL-GUID-9E1210BD-B37E-4255-BBDB-5D533BC2372F" class="sect5"><span class="enumeration_section">8.3.5.2 </span>How Index Fast Full Scans Work
                     </h5>
                     <div>
                        <p>The database uses multiblock I/O to read the root block and all of the leaf and branch blocks. The databases ignores the branch and root blocks and reads the index entries on the leaf blocks.</p>
                     </div>
                     <div>
                        <div class="familylinks">
                           <div class="parentlink">
                              <p><strong>Parent topic:</strong> <a href="optimizer-access-paths.html#GUID-A2F2A81F-4626-45A1-B2A6-D46107E74C3C" title="An index fast full scan reads the index blocks in unsorted order, as they exist on disk. This scan does not use the index to probe the table, but reads the index instead of the table, essentially using the index itself as a table.">Index Fast Full Scans</a></p>
                           </div>
                        </div>
                     </div>
                     
                  </div><a id="TGSQL95175"></a><a id="TGSQL95174"></a><div class="props_rev_3"><a id="GUID-09D080C6-0A1D-4282-AD08-C931B1F7B3B3" name="GUID-09D080C6-0A1D-4282-AD08-C931B1F7B3B3"></a><h5 id="TGSQL-GUID-09D080C6-0A1D-4282-AD08-C931B1F7B3B3" class="sect5"><span class="enumeration_section">8.3.5.3 </span>Index Fast Full Scans: Example
                     </h5>
                     <div>
                        <p>This examples uses a fast full index scan as a result of an optimizer hint.</p>
                        <div class="example" id="GUID-09D080C6-0A1D-4282-AD08-C931B1F7B3B3__CHDGDGJI">
                           <p>The following statement queries the ID and name for departments in order of department ID:</p><pre class="pre codeblock"><code>SELECT /*+ INDEX_FFS(departments dept_id_pk) */ COUNT(*)
FROM   departments;
</code></pre><p>The following plan shows that the optimizer chose a fast full index scan:</p><pre class="pre codeblock"><code>SQL_ID  fu0k5nvx7sftm, child number 0
-------------------------------------
select /*+ index_ffs(departments dept_id_pk) */ count(*) from departments

Plan hash value: 3940160378
--------------------------------------------------------------------------
| Id | Operation             | Name       | Rows  |Cost (%CPU)| Time     |
--------------------------------------------------------------------------
|  0 | SELECT STATEMENT      |            |       |    2 (100)|          |
|  1 |  SORT AGGREGATE       |            |     1 |           |          |
|  2 |   <span class="bold">INDEX FAST FULL SCAN</span>| DEPT_ID_PK |    27 |    2   (0)| 00:00:01 |
--------------------------------------------------------------------------</code></pre></div>
                        <!-- class="example" -->
                     </div>
                     <div>
                        <div class="familylinks">
                           <div class="parentlink">
                              <p><strong>Parent topic:</strong> <a href="optimizer-access-paths.html#GUID-A2F2A81F-4626-45A1-B2A6-D46107E74C3C" title="An index fast full scan reads the index blocks in unsorted order, as they exist on disk. This scan does not use the index to probe the table, but reads the index instead of the table, essentially using the index itself as a table.">Index Fast Full Scans</a></p>
                           </div>
                        </div>
                     </div>
                     
                  </div>
               </div><a id="TGSQL238"></a><div class="props_rev_3"><a id="GUID-B7C62F0F-EB7C-422C-919D-D86456A74A60" name="GUID-B7C62F0F-EB7C-422C-919D-D86456A74A60"></a><h4 id="TGSQL-GUID-B7C62F0F-EB7C-422C-919D-D86456A74A60" class="sect4"><span class="enumeration_section">8.3.6 </span>Index Skip Scans
                  </h4>
                  <div>
                     <p>An <strong class="term">index skip scan</strong> occurs when the initial column of a composite index is "skipped" or not specified in the query.
                     </p>
                     <p>This section contains the following topics:</p>
                  </div>
                  <div>
                     <ul class="ullinks">
                        <li class="ulchildlink"><a href="optimizer-access-paths.html#GUID-F5ABAAFD-44F7-4BA1-A778-01FCE9816E12">When the Optimizer Considers Index Skips Scans</a><br>Often, skip scanning index blocks is faster than scanning table blocks, and faster than performing full index scans.
                        </li>
                        <li class="ulchildlink"><a href="optimizer-access-paths.html#GUID-C463F5CF-0514-4C51-972A-FA0A5CFA05C8">How Index Skip Scans Work</a><br>An index skip scan logically splits a composite index into smaller subindexes.
                        </li>
                        <li class="ulchildlink"><a href="optimizer-access-paths.html#GUID-3587E79B-7733-42FC-8A9D-419F5DB1EB4B">Index Skip Scans: Example</a><br>This example uses an index skip scan to satisfy a query of the <code class="codeph">sh.customers</code> table.
                        </li>
                     </ul>
                     <div class="infoboxnotealso" id="GUID-B7C62F0F-EB7C-422C-919D-D86456A74A60__GUID-B6019142-B537-495C-83D5-23469C3AF6F8">
                        <p class="notep1">See Also:</p>
                        <p><a href="https://www.oracle.com/pls/topic/lookup?ctx=en/database/oracle/oracle-database/19/tgsql&amp;id=CNCPT88842" target="_blank"><span><cite>Oracle Database Concepts</cite></span></a></p>
                     </div>
                     <div class="familylinks">
                        <div class="parentlink">
                           <p><strong>Parent topic:</strong> <a href="optimizer-access-paths.html#GUID-B33945C3-CCC0-4D35-AF62-DB80FD4256A6" title="An index is an optional structure, associated with a table or table cluster, that can sometimes speed data access.">B-Tree Index Access Paths</a></p>
                        </div>
                     </div>
                  </div>
                  <a id="TGSQL95176"></a><div class="props_rev_3"><a id="GUID-F5ABAAFD-44F7-4BA1-A778-01FCE9816E12" name="GUID-F5ABAAFD-44F7-4BA1-A778-01FCE9816E12"></a><h5 id="TGSQL-GUID-F5ABAAFD-44F7-4BA1-A778-01FCE9816E12" class="sect5"><span class="enumeration_section">8.3.6.1 </span>When the Optimizer Considers Index Skips Scans
                     </h5>
                     <div>
                        <p>Often, skip scanning index blocks is faster than scanning table blocks, and faster than performing full index scans.</p>
                        <p>The optimizer considers a skip scan when the following criteria are met:</p>
                        <ul style="list-style-type: disc;">
                           <li>
                              <p>The leading column of a composite index is not specified in the query predicate.</p>
                              <p>For example, the query predicate does not reference the <code class="codeph">cust_gender</code> column, and the composite index key is <code class="codeph">(cust_gender,cust_email)</code>.
                              </p>
                           </li>
                           <li>
                              <p>Few distinct values exist in the leading column of the composite index, but many distinct values exist in the nonleading key of the index.</p>
                              <p>For example, if the composite index key is <code class="codeph">(cust_gender,cust_email)</code>, then the <code class="codeph">cust_gender</code> column has only two distinct values, but <code class="codeph">cust_email</code> has thousands.
                              </p>
                           </li>
                        </ul>
                     </div>
                     <div>
                        <div class="familylinks">
                           <div class="parentlink">
                              <p><strong>Parent topic:</strong> <a href="optimizer-access-paths.html#GUID-B7C62F0F-EB7C-422C-919D-D86456A74A60" title="An index skip scan occurs when the initial column of a composite index is "skipped" or not specified in the query.">Index Skip Scans</a></p>
                           </div>
                        </div>
                     </div>
                     
                  </div><a id="TGSQL95177"></a><div class="props_rev_3"><a id="GUID-C463F5CF-0514-4C51-972A-FA0A5CFA05C8" name="GUID-C463F5CF-0514-4C51-972A-FA0A5CFA05C8"></a><h5 id="TGSQL-GUID-C463F5CF-0514-4C51-972A-FA0A5CFA05C8" class="sect5"><span class="enumeration_section">8.3.6.2 </span>How Index Skip Scans Work
                     </h5>
                     <div>
                        <p>An index skip scan logically splits a composite index into smaller subindexes.</p>
                        <p>The number of distinct values in the leading columns of the index determines the number of logical subindexes. The lower the number, the fewer logical subindexes the optimizer must create, and the more efficient the scan becomes. The scan reads each logical index separately, and "skips" index blocks that do not meet the filter condition on the non-leading column.</p>
                     </div>
                     <div>
                        <div class="familylinks">
                           <div class="parentlink">
                              <p><strong>Parent topic:</strong> <a href="optimizer-access-paths.html#GUID-B7C62F0F-EB7C-422C-919D-D86456A74A60" title="An index skip scan occurs when the initial column of a composite index is "skipped" or not specified in the query.">Index Skip Scans</a></p>
                           </div>
                        </div>
                     </div>
                     
                  </div><a id="TGSQL95179"></a><a id="TGSQL95178"></a><div class="props_rev_3"><a id="GUID-3587E79B-7733-42FC-8A9D-419F5DB1EB4B" name="GUID-3587E79B-7733-42FC-8A9D-419F5DB1EB4B"></a><h5 id="TGSQL-GUID-3587E79B-7733-42FC-8A9D-419F5DB1EB4B" class="sect5"><span class="enumeration_section">8.3.6.3 </span>Index Skip Scans: Example
                     </h5>
                     <div>
                        <p>This example uses an index skip scan to satisfy a query of the <code class="codeph">sh.customers</code> table.
                        </p>
                        <div class="example" id="GUID-3587E79B-7733-42FC-8A9D-419F5DB1EB4B__GUID-39E305BD-26C0-46BB-9378-8F584A97EAF1">
                           <p>The <code class="codeph">customers</code> table contains a column <code class="codeph">cust_gender</code> whose values are either <code class="codeph">M</code> or <code class="codeph">F</code>. While logged in to the database as user <code class="codeph">sh</code>, you create a composite index on the columns (<code class="codeph">cust_gender, cust_email</code>) as follows:
                           </p><pre class="pre codeblock"><code>CREATE INDEX cust_gender_email_ix
  ON sh.customers (cust_gender, cust_email);
</code></pre><p>Conceptually, a portion of the index might look as follows, with the gender value of <code class="codeph">F</code> or <code class="codeph">M</code> as the leading edge of the index.
                           </p><pre class="pre codeblock"><code>F,Wolf@company.example.com,rowid
F,Wolsey@company.example.com,rowid
F,Wood@company.example.com,rowid
F,Woodman@company.example.com,rowid
F,Yang@company.example.com,rowid
F,Zimmerman@company.example.com,rowid
M,Abbassi@company.example.com,rowid
M,Abbey@company.example.com,rowid</code></pre><p>You run the following query for a customer in the <code class="codeph">sh.customers</code> table:
                           </p><pre class="pre codeblock"><code>SELECT * 
FROM   sh.customers 
WHERE  cust_email = 'Abbey@company.example.com';
</code></pre><p>The database can use a skip scan of the <code class="codeph">customers_gender_email</code> index even though <code class="codeph">cust_gender</code> is not specified in the <code class="codeph">WHERE</code> clause. In the sample index, the leading column <code class="codeph">cust_gender</code> has two possible values: <code class="codeph">F</code> and <code class="codeph">M</code>. The database logically splits the index into two. One subindex has the key <code class="codeph">F</code>, with entries in the following form:
                           </p><pre class="pre codeblock"><code>F,Wolf@company.example.com,rowid
F,Wolsey@company.example.com,rowid
F,Wood@company.example.com,rowid
F,Woodman@company.example.com,rowid
F,Yang@company.example.com,rowid
F,Zimmerman@company.example.com,rowid
</code></pre><p>The second subindex has the key <code class="codeph">M</code>, with entries in the following form:
                           </p><pre class="pre codeblock"><code>M,Abbassi@company.example.com,rowid
M,Abbey@company.example.com,rowid
</code></pre><p>When searching for the record for the customer whose email is <code class="codeph">Abbey@company.example.com</code>, the database searches the subindex with the leading value <code class="codeph">F</code> first, and then searches the subindex with the leading value <code class="codeph">M</code>. Conceptually, the database processes the query as follows:
                           </p><pre class="pre codeblock"><code>( SELECT * 
  FROM   sh.customers 
  WHERE  cust_gender = '<span class="bold">F</span>' 
  AND    cust_email = 'Abbey@company.example.com' )
UNION ALL
( SELECT * 
  FROM   sh.customers 
  WHERE  cust_gender = '<span class="bold">M</span>'
  AND    cust_email = 'Abbey@company.example.com' )
</code></pre><p>The plan for the query is as follows:</p><pre class="pre codeblock"><code>SQL_ID  d7a6xurcnx2dj, child number 0
-------------------------------------
SELECT * FROM   sh.customers WHERE  cust_email = 'Abbey@company.example.com'
 
Plan hash value: 797907791
 
-----------------------------------------------------------------------------------------
|Id| Operation                          | Name               |Rows|Bytes|Cost(%CPU)|Time|
-----------------------------------------------------------------------------------------
| 0|SELECT STATEMENT                    |                      |  |    |10(100)|        |
| 1| TABLE ACCESS BY INDEX ROWID BATCHED| CUSTOMERS            |33|6237|  10(0)|00:00:01|
|*2|  <span class="bold">INDEX SKIP SCAN</span>                   | CUST_GENDER_EMAIL_IX |33|    |   4(0)|00:00:01|
-----------------------------------------------------------------------------------------
 
Predicate Information (identified by operation id):
---------------------------------------------------
 
   2 - access("CUST_EMAIL"='Abbey@company.example.com')
       filter("CUST_EMAIL"='Abbey@company.example.com')</code></pre></div>
                        <!-- class="example" -->
                     </div>
                     <div>
                        <div class="infoboxnotealso" id="GUID-3587E79B-7733-42FC-8A9D-419F5DB1EB4B__GUID-0C8F7940-0687-489D-A6D9-884D6C130B74">
                           <p class="notep1">See Also:</p>
                           <p><a href="https://www.oracle.com/pls/topic/lookup?ctx=en/database/oracle/oracle-database/19/tgsql&amp;id=CNCPT88842" target="_blank"><span><cite>Oracle Database Concepts</cite></span></a> to learn more about skip scans
                           </p>
                        </div>
                        <div class="familylinks">
                           <div class="parentlink">
                              <p><strong>Parent topic:</strong> <a href="optimizer-access-paths.html#GUID-B7C62F0F-EB7C-422C-919D-D86456A74A60" title="An index skip scan occurs when the initial column of a composite index is "skipped" or not specified in the query.">Index Skip Scans</a></p>
                           </div>
                        </div>
                     </div>
                     
                  </div>
               </div><a id="TGSQL95180"></a><div class="props_rev_3"><a id="GUID-21258F63-7506-4019-9FB4-323E9D2DE087" name="GUID-21258F63-7506-4019-9FB4-323E9D2DE087"></a><h4 id="TGSQL-GUID-21258F63-7506-4019-9FB4-323E9D2DE087" class="sect4"><span class="enumeration_section">8.3.7 </span>Index Join Scans
                  </h4>
                  <div>
                     <p>An index join scan is a hash join of multiple indexes that together return all columns requested by a query. The database does not need to access the table because all data is retrieved from the indexes.</p>
                     <p>This section contains the following topics:</p>
                  </div>
                  <div>
                     <ul class="ullinks">
                        <li class="ulchildlink"><a href="optimizer-access-paths.html#GUID-EA936820-BBAC-4DB1-A3F8-050AC81A24E6">When the Optimizer Considers Index Join Scans</a><br>In some cases, avoiding table access is the most cost efficient option.
                        </li>
                        <li class="ulchildlink"><a href="optimizer-access-paths.html#GUID-0F989C52-262C-4237-9DE1-E14D7CF8EE1D">How Index Join Scans Work</a><br>An index join involves scanning multiple indexes, and then using a hash join on the rowids obtained from these scans to return the rows. 
                        </li>
                        <li class="ulchildlink"><a href="optimizer-access-paths.html#GUID-5472D2AD-8141-4017-B828-EE1050BA24CF">Index Join Scans: Example</a><br>This example queries the last name and email for employees whose last name begins with <code class="codeph">A</code>, specifying an index join.
                        </li>
                     </ul>
                     <div class="familylinks">
                        <div class="parentlink">
                           <p><strong>Parent topic:</strong> <a href="optimizer-access-paths.html#GUID-B33945C3-CCC0-4D35-AF62-DB80FD4256A6" title="An index is an optional structure, associated with a table or table cluster, that can sometimes speed data access.">B-Tree Index Access Paths</a></p>
                        </div>
                     </div>
                  </div>
                  <a id="TGSQL95181"></a><div class="props_rev_3"><a id="GUID-EA936820-BBAC-4DB1-A3F8-050AC81A24E6" name="GUID-EA936820-BBAC-4DB1-A3F8-050AC81A24E6"></a><h5 id="TGSQL-GUID-EA936820-BBAC-4DB1-A3F8-050AC81A24E6" class="sect5"><span class="enumeration_section">8.3.7.1 </span>When the Optimizer Considers Index Join Scans
                     </h5>
                     <div>
                        <p>In some cases, avoiding table access is the most cost efficient option.</p>
                        <p>The optimizer considers an index join in the following circumstances:</p>
                        <ul style="list-style-type: disc;">
                           <li>
                              <p>A hash join of multiple indexes retrieves all data requested by the query, without requiring table access.</p>
                           </li>
                           <li>
                              <p>The cost of retrieving rows from the table is higher than reading the indexes without retrieving rows from the table. An index join is often expensive. For example, when scanning two indexes and joining them, it is often less costly to choose the most selective index, and then probe the table.</p>
                           </li>
                        </ul>
                        <p>You can specify an index join with the <code class="codeph">INDEX_JOIN(<span class="codeinlineitalic">table_name</span>)</code> hint.
                        </p>
                     </div>
                     <div>
                        <div class="infoboxnotealso" id="GUID-EA936820-BBAC-4DB1-A3F8-050AC81A24E6__GUID-4DAC1F16-8846-49F5-8AFE-B3670B3A8DDF">
                           <p class="notep1">See Also:</p>
                           <p><a href="https://www.oracle.com/pls/topic/lookup?ctx=en/database/oracle/oracle-database/19/tgsql&amp;id=SQLRF50408" target="_blank"><span><cite>Oracle Database SQL Language Reference</cite></span></a></p>
                        </div>
                        <div class="familylinks">
                           <div class="parentlink">
                              <p><strong>Parent topic:</strong> <a href="optimizer-access-paths.html#GUID-21258F63-7506-4019-9FB4-323E9D2DE087" title="An index join scan is a hash join of multiple indexes that together return all columns requested by a query. The database does not need to access the table because all data is retrieved from the indexes.">Index Join Scans</a></p>
                           </div>
                        </div>
                     </div>
                     
                  </div><a id="TGSQL95182"></a><div class="props_rev_3"><a id="GUID-0F989C52-262C-4237-9DE1-E14D7CF8EE1D" name="GUID-0F989C52-262C-4237-9DE1-E14D7CF8EE1D"></a><h5 id="TGSQL-GUID-0F989C52-262C-4237-9DE1-E14D7CF8EE1D" class="sect5"><span class="enumeration_section">8.3.7.2 </span>How Index Join Scans Work
                     </h5>
                     <div>
                        <p>An index join involves scanning multiple indexes, and then using a hash join on the rowids obtained from these scans to return the rows. </p>
                        <p>In an index join scan, table access is always avoided. For example, the process for joining two indexes on a single table is as follows:</p>
                        <ol>
                           <li>
                              <p>Scan the first index to retrieve rowids.</p>
                           </li>
                           <li>
                              <p>Scan the second index to retrieve rowids.</p>
                           </li>
                           <li>
                              <p>Perform a hash join by rowid to obtain the rows.</p>
                           </li>
                        </ol>
                     </div>
                     <div>
                        <div class="familylinks">
                           <div class="parentlink">
                              <p><strong>Parent topic:</strong> <a href="optimizer-access-paths.html#GUID-21258F63-7506-4019-9FB4-323E9D2DE087" title="An index join scan is a hash join of multiple indexes that together return all columns requested by a query. The database does not need to access the table because all data is retrieved from the indexes.">Index Join Scans</a></p>
                           </div>
                        </div>
                     </div>
                     
                  </div><a id="TGSQL95184"></a><a id="TGSQL95183"></a><div class="props_rev_3"><a id="GUID-5472D2AD-8141-4017-B828-EE1050BA24CF" name="GUID-5472D2AD-8141-4017-B828-EE1050BA24CF"></a><h5 id="TGSQL-GUID-5472D2AD-8141-4017-B828-EE1050BA24CF" class="sect5"><span class="enumeration_section">8.3.7.3 </span>Index Join Scans: Example
                     </h5>
                     <div>
                        <p>This example queries the last name and email for employees whose last name begins with <code class="codeph">A</code>, specifying an index join.
                        </p><pre class="pre codeblock"><code>SELECT /*+ INDEX_JOIN(employees) */ last_name, email
FROM   employees
WHERE  last_name like 'A%';
</code></pre><p>Separate indexes exist on the <code class="codeph">(last_name,first_name)</code> and <code class="codeph">email</code> columns. Part of the <code class="codeph">emp_name_ix</code> index might look as follows:
                        </p><pre class="pre codeblock"><code>Banda,Amit,AAAVgdAALAAAABSABD
Bates,Elizabeth,AAAVgdAALAAAABSABI
Bell,Sarah,AAAVgdAALAAAABSABc
Bernstein,David,AAAVgdAALAAAABSAAz
Bissot,Laura,AAAVgdAALAAAABSAAd
Bloom,Harrison,AAAVgdAALAAAABSABF
Bull,Alexis,AAAVgdAALAAAABSABV
</code></pre><p>The first part of the <code class="codeph">emp_email_uk</code> index might look as follows:
                        </p><pre class="pre codeblock"><code>ABANDA,AAAVgdAALAAAABSABD
ABULL,AAAVgdAALAAAABSABV
ACABRIO,AAAVgdAALAAAABSABX
AERRAZUR,AAAVgdAALAAAABSAAv
AFRIPP,AAAVgdAALAAAABSAAV
AHUNOLD,AAAVgdAALAAAABSAAD
AHUTTON,AAAVgdAALAAAABSABL
</code></pre><p>The following example retrieves the plan using the <code class="codeph">DBMS_XPLAN.DISPLAY_CURSOR</code> function. The database retrieves all rowids in the <code class="codeph">emp_email_uk</code> index, and then retrieves rowids in <code class="codeph">emp_name_ix</code> for last names that begin with <code class="codeph">A</code>. The database uses a hash join to search both sets of rowids for matches. For example, rowid <code class="codeph">AAAVgdAALAAAABSABD</code> occurs in both sets of rowids, so the database probes the <code class="codeph">employees</code> table for the record corresponding to this rowid.
                        </p>
                        <div class="example" id="GUID-5472D2AD-8141-4017-B828-EE1050BA24CF__CHDDFCIB">
                           <p class="titleinexample">Example 8-4 Index Join Scan</p><pre class="pre codeblock"><code>SQL_ID  d2djchyc9hmrz, child number 0
-------------------------------------
SELECT /*+ INDEX_JOIN(employees) */ last_name, email FROM   employees
WHERE  last_name like 'A%'

Plan hash value: 3719800892
-------------------------------------------------------------------------------------------
| Id  | Operation              | Name             | Rows  | Bytes | Cost (%CPU)| Time     |
-------------------------------------------------------------------------------------------
|   0 | SELECT STATEMENT       |                  |       |       |     3 (100)|          |
|*  1 |  VIEW                  | index$_join$_001 |     3 |    48 |     3  (34)| 00:00:01 |
|*  2 |   <span class="bold">HASH JOIN</span>            |                  |       |       |            |          |
|*  3 |    <span class="bold">INDEX RANGE SCAN</span>    | EMP_NAME_IX      |     3 |    48 |     1   (0)| 00:00:01 |
|   4 |    <span class="bold">INDEX FAST FULL SCAN</span>| EMP_EMAIL_UK     |     3 |    48 |     1   (0)| 00:00:01 |
-------------------------------------------------------------------------------------------

Predicate Information (identified by operation id):
---------------------------------------------------
   1 - filter("LAST_NAME" LIKE 'A%')
   2 - access(ROWID=ROWID)
   3 - access("LAST_NAME" LIKE 'A%')</code></pre></div>
                        <!-- class="example" -->
                     </div>
                     <div>
                        <div class="familylinks">
                           <div class="parentlink">
                              <p><strong>Parent topic:</strong> <a href="optimizer-access-paths.html#GUID-21258F63-7506-4019-9FB4-323E9D2DE087" title="An index join scan is a hash join of multiple indexes that together return all columns requested by a query. The database does not need to access the table because all data is retrieved from the indexes.">Index Join Scans</a></p>
                           </div>
                        </div>
                     </div>
                     
                  </div>
               </div>
            </div><a id="TGSQL240"></a><div class="props_rev_3"><a id="GUID-B5E41901-933E-4A31-B5D6-9771FD435EC0" name="GUID-B5E41901-933E-4A31-B5D6-9771FD435EC0"></a><h3 id="TGSQL-GUID-B5E41901-933E-4A31-B5D6-9771FD435EC0" class="sect3"><span class="enumeration_section">8.4 </span>Bitmap Index Access Paths
               </h3>
               <div>
                  <p>Bitmap indexes combine the indexed data with a rowid range.</p>
                  <p>This section explains how bitmap indexes, and describes some of the more common bitmap index access paths:</p>
               </div>
               <div>
                  <ul class="ullinks">
                     <li class="ulchildlink"><a href="optimizer-access-paths.html#GUID-CD3D7579-3E44-4383-8056-B11B805A437F">About Bitmap Index Access</a><br>In a conventional B-tree index, one index entry points to a single row. In a bitmap index, the key is the combination of the indexed data and the rowid range.
                     </li>
                     <li class="ulchildlink"><a href="optimizer-access-paths.html#GUID-2939D4FD-ECC4-48FB-9AD7-CD844CC71786">Bitmap Conversion to Rowid</a><br>A bitmap conversion translates between an entry in the bitmap and a row in a table. The conversion can go from entry to row (<code class="codeph">TO ROWID</code>), or from row to entry (<code class="codeph">FROM ROWID</code>).
                     </li>
                     <li class="ulchildlink"><a href="optimizer-access-paths.html#GUID-E8F4A411-10BE-4D5E-9207-0D5F8E61A8E0">Bitmap Index Single Value</a><br>This type of access path uses a bitmap index to look up a single key value.
                     </li>
                     <li class="ulchildlink"><a href="optimizer-access-paths.html#GUID-9123D7CE-90DC-4C96-AB4F-49FD0227C40B">Bitmap Index Range Scans</a><br>This type of access path uses a bitmap index to look up a range of values.
                     </li>
                     <li class="ulchildlink"><a href="optimizer-access-paths.html#GUID-2FDE5904-B0BC-44DA-829B-94C89FA77D71">Bitmap Merge</a><br>This access path merges multiple bitmaps, and returns a single bitmap as a result.
                     </li>
                  </ul>
                  <div class="familylinks">
                     <div class="parentlink">
                        <p><strong>Parent topic:</strong> <a href="optimizer-access-paths.html#GUID-00711237-35D3-4CFC-A234-59B3EC53DCD1" title="An access path is a technique used by a query to retrieve rows from a row source.">Optimizer Access Paths</a></p>
                     </div>
                  </div>
               </div>
               <a id="TGSQL95195"></a><div class="props_rev_3"><a id="GUID-CD3D7579-3E44-4383-8056-B11B805A437F" name="GUID-CD3D7579-3E44-4383-8056-B11B805A437F"></a><h4 id="TGSQL-GUID-CD3D7579-3E44-4383-8056-B11B805A437F" class="sect4"><span class="enumeration_section">8.4.1 </span>About Bitmap Index Access
                  </h4>
                  <div>
                     <p>In a conventional B-tree index, one index entry points to a single row. In a bitmap index, the key is the combination of the indexed data and the rowid range.</p>
                     <p>The database stores at least one bitmap for each index key. Each value in the bitmap, which is a series of <code class="codeph">1</code> and <code class="codeph">0</code> values, points to a row within a rowid range. Thus, in a bitmap index, one index entry points to a set of rows rather than a single row.
                     </p>
                     <p>This section contains the following topics:</p>
                  </div>
                  <div>
                     <ul class="ullinks">
                        <li class="ulchildlink"><a href="optimizer-access-paths.html#GUID-610AE791-0125-4927-A795-2730541C1D06">Differences Between Bitmap and B-Tree Indexes</a><br>A bitmap index uses a different key from a B-tree index, but is stored in a B-tree structure.
                        </li>
                        <li class="ulchildlink"><a href="optimizer-access-paths.html#GUID-90B6A8AF-BB62-454B-92AF-AB9E01D93C4D">Purpose of Bitmap Indexes</a><br>Bitmap indexes are typically suitable for infrequently modified data with a low or medium number of distinct values (NDV).
                        </li>
                        <li class="ulchildlink"><a href="optimizer-access-paths.html#GUID-0604FCDA-473B-432F-B1B2-8F766D377D63">Bitmaps and Rowids</a><br>For a particular value in a bitmap, the value is <code class="codeph">1</code> if the row values match the bitmap condition, and <code class="codeph">0</code> if it does not. Based on these values, the database uses an internal algorithm to map bitmaps onto rowids.
                        </li>
                        <li class="ulchildlink"><a href="optimizer-access-paths.html#GUID-1F859889-14BC-4F0B-90CE-8682737FB46F">Bitmap Join Indexes</a><br>A <span class="bold">bitmap join index</span> is a bitmap index for the join of two or more tables.
                        </li>
                        <li class="ulchildlink"><a href="optimizer-access-paths.html#GUID-BD3F4C5B-E1A6-4444-AA74-87BE752B096E">Bitmap Storage</a><br>A bitmap index resides in a B-tree structure, using branch blocks and leaf blocks just as in a B-tree. 
                        </li>
                     </ul>
                     <div class="familylinks">
                        <div class="parentlink">
                           <p><strong>Parent topic:</strong> <a href="optimizer-access-paths.html#GUID-B5E41901-933E-4A31-B5D6-9771FD435EC0" title="Bitmap indexes combine the indexed data with a rowid range.">Bitmap Index Access Paths</a></p>
                        </div>
                     </div>
                  </div>
                  <a id="TGSQL95196"></a><div class="props_rev_3"><a id="GUID-610AE791-0125-4927-A795-2730541C1D06" name="GUID-610AE791-0125-4927-A795-2730541C1D06"></a><h5 id="TGSQL-GUID-610AE791-0125-4927-A795-2730541C1D06" class="sect5"><span class="enumeration_section">8.4.1.1 </span>Differences Between Bitmap and B-Tree Indexes
                     </h5>
                     <div>
                        <p>A bitmap index uses a different key from a B-tree index, but is stored in a B-tree structure.</p>
                        <p>The following table shows the differences among types of index entries.</p>
                        <div class="tblformalwide" id="GUID-610AE791-0125-4927-A795-2730541C1D06__CHDEEGHB">
                           <p class="titleintable">Table 8-3 Index Entries for B-Trees and Bitmaps</p>
                           <table cellpadding="4" cellspacing="0" class="FormalWide" title="Index Entries for B-Trees and Bitmaps" summary="Entries for Bitmap Indexes" width="100%" frame="hsides" border="1" rules="rows">
                              <thead>
                                 <tr align="left" valign="top">
                                    <th align="left" valign="bottom" width="17%" id="d37861e9198">Index Entry</th>
                                    <th align="left" valign="bottom" width="21%" id="d37861e9201">Key</th>
                                    <th align="left" valign="bottom" width="10%" id="d37861e9204">Data</th>
                                    <th align="left" valign="bottom" width="52%" id="d37861e9207">Example</th>
                                 </tr>
                              </thead>
                              <tbody>
                                 <tr align="left" valign="top">
                                    <td align="left" valign="top" width="17%" id="d37861e9212" headers="d37861e9198 ">
                                       <p>Unique B-tree</p>
                                    </td>
                                    <td align="left" valign="top" width="21%" headers="d37861e9212 d37861e9201 ">
                                       <p>Indexed data only</p>
                                    </td>
                                    <td align="left" valign="top" width="10%" headers="d37861e9212 d37861e9204 ">
                                       <p>Rowid</p>
                                    </td>
                                    <td align="left" valign="top" width="52%" headers="d37861e9212 d37861e9207 ">
                                       <p>In an entry of the index on the <code class="codeph">employees.employee_id</code> column, employee ID <code class="codeph">101</code> is the key, and the rowid <code class="codeph">AAAPvCAAFAAAAFaAAa</code> is the data:
                                       </p><pre class="pre codeblock"><code>101,AAAPvCAAFAAAAFaAAa</code></pre></td>
                                 </tr>
                                 <tr align="left" valign="top">
                                    <td align="left" valign="top" width="17%" id="d37861e9236" headers="d37861e9198 ">
                                       <p>Nonunique B-tree</p>
                                    </td>
                                    <td align="left" valign="top" width="21%" headers="d37861e9236 d37861e9201 ">
                                       <p>Indexed data combined with rowid</p>
                                    </td>
                                    <td align="left" valign="top" width="10%" headers="d37861e9236 d37861e9204 ">
                                       <p>None</p>
                                    </td>
                                    <td align="left" valign="top" width="52%" headers="d37861e9236 d37861e9207 ">
                                       <p>In an entry of the index on the <code class="codeph">employees.last_name</code> column, the name and rowid combination <code class="codeph">Smith,AAAPvCAAFAAAAFaAAa</code> is the key, and there is no data:
                                       </p><pre class="pre codeblock"><code>Smith,AAAPvCAAFAAAAFaAAa</code></pre></td>
                                 </tr>
                                 <tr align="left" valign="top">
                                    <td align="left" valign="top" width="17%" id="d37861e9257" headers="d37861e9198 ">
                                       <p>Bitmap</p>
                                    </td>
                                    <td align="left" valign="top" width="21%" headers="d37861e9257 d37861e9201 ">
                                       <p>Indexed data combined with rowid range</p>
                                    </td>
                                    <td align="left" valign="top" width="10%" headers="d37861e9257 d37861e9204 ">
                                       <p>Bitmap</p>
                                    </td>
                                    <td align="left" valign="top" width="52%" headers="d37861e9257 d37861e9207 ">
                                       <p>In an entry of the index on the <code class="codeph">customers.cust_gender</code> column, the <code class="codeph">M,</code><span class="italic"><code class="codeph">low-rowid,high-rowid</code></span> part is the key, and the series of <code class="codeph">1</code> and <code class="codeph">0</code> values is the data:
                                       </p><pre class="pre codeblock"><code>M,<span class="italic">low-rowid</span>,<span class="italic">high-rowid</span>,1000101010101010</code></pre></td>
                                 </tr>
                              </tbody>
                           </table>
                        </div>
                        <!-- class="inftblhruleinformal" -->
                        <p>The database stores a bitmap index in a B-tree structure. The database can search the B-tree quickly on the first part of the key, which is the set of attributes on which the index is defined, and then obtain the corresponding rowid range and bitmap.</p>
                     </div>
                     <div>
                        <div class="infoboxnotealso" id="GUID-610AE791-0125-4927-A795-2730541C1D06__GUID-6C1D765C-4454-4C79-B37A-5B638919744A">
                           <p class="notep1">See Also:</p>
                           <ul style="list-style-type: disc;">
                              <li>
                                 <p><span class="q">"<a href="optimizer-access-paths.html#GUID-BD3F4C5B-E1A6-4444-AA74-87BE752B096E" title="A bitmap index resides in a B-tree structure, using branch blocks and leaf blocks just as in a B-tree.">Bitmap Storage</a>"</span></p>
                              </li>
                              <li>
                                 <p><a href="https://www.oracle.com/pls/topic/lookup?ctx=en/database/oracle/oracle-database/19/tgsql&amp;id=CNCPT1182" target="_blank"><span><cite>Oracle Database Concepts</cite></span></a> for an overview of bitmap indexes
                                 </p>
                              </li>
                              <li>
                                 <p><a href="https://www.oracle.com/pls/topic/lookup?ctx=en/database/oracle/oracle-database/19/tgsql&amp;id=GUID-76BAA645-A219-4FF5-AFD4-B6FA8C1473FB" target="_blank"><span><cite>Oracle Database Data Warehousing Guide</cite></span></a> for more information about bitmap indexes
                                 </p>
                              </li>
                           </ul>
                        </div>
                        <div class="familylinks">
                           <div class="parentlink">
                              <p><strong>Parent topic:</strong> <a href="optimizer-access-paths.html#GUID-CD3D7579-3E44-4383-8056-B11B805A437F" title="In a conventional B-tree index, one index entry points to a single row. In a bitmap index, the key is the combination of the indexed data and the rowid range.">About Bitmap Index Access</a></p>
                           </div>
                        </div>
                     </div>
                     
                  </div><a id="TGSQL95197"></a><div class="props_rev_3"><a id="GUID-90B6A8AF-BB62-454B-92AF-AB9E01D93C4D" name="GUID-90B6A8AF-BB62-454B-92AF-AB9E01D93C4D"></a><h5 id="TGSQL-GUID-90B6A8AF-BB62-454B-92AF-AB9E01D93C4D" class="sect5"><span class="enumeration_section">8.4.1.2 </span>Purpose of Bitmap Indexes
                     </h5>
                     <div>
                        <p>Bitmap indexes are typically suitable for infrequently modified data with a low or medium number of distinct values (NDV).</p>
                        <p>In general, B-tree indexes are suitable for columns with high NDV and frequent DML activity. For example, the optimizer might choose a B-tree index for a query of a <code class="codeph">sales.amount</code> column that returns few rows. In contrast, the <code class="codeph">customers.state</code> and <code class="codeph">customers.county</code> columns are candidates for bitmap indexes because they have few distinct values, are infrequently updated, and can benefit from efficient <code class="codeph">AND</code> and <code class="codeph">OR</code> operations.
                        </p>
                        <p>Bitmap indexes are a useful way to speed ad hoc queries in a data warehouse. They are fundamental to star transformations. Specifically, bitmap indexes are useful in queries that contain the following:</p>
                        <ul style="list-style-type: disc;">
                           <li>
                              <p>Multiple conditions in the <code class="codeph">WHERE</code> clause
                              </p>
                              <p>Before the table itself is accessed, the database filters out rows that satisfy some, but not all, conditions.</p>
                           </li>
                           <li>
                              <p><code class="codeph">AND</code>, <code class="codeph">OR</code>, and <code class="codeph">NOT</code> operations on columns with low or medium NDV
                              </p>
                              <p>Combining bitmap indexes makes these operations more efficient. The database can merge bitmaps from bitmap indexes very quickly. For example, if bitmap indexes exist on the <code class="codeph">customers.state</code> and <code class="codeph">customers.county</code> columns, then these indexes can enormously improve the performance of the following query:
                              </p><pre class="pre codeblock"><code>SELECT * 
FROM   customers 
WHERE  state = 'CA' 
AND    county = 'San Mateo'</code></pre><p>The database can convert <code class="codeph">1</code> values in the merged bitmap into rowids efficiently.
                              </p>
                           </li>
                           <li>
                              <p>The <code class="codeph">COUNT</code> function
                              </p>
                              <p>The database can scan the bitmap index without needing to scan the table.</p>
                           </li>
                           <li>
                              <p>Predicates that select for null values</p>
                              <p>Unlike B-tree indexes, bitmap indexes can contain nulls. Queries that count the number of nulls in a column can use the bitmap index without scanning the table.</p>
                           </li>
                           <li>
                              <p>Columns that do not experience heavy DML</p>
                              <p>The reason is that one index key points to many rows. If a session modifies the indexed data, then the database cannot lock a single bit in the bitmap: rather, the database locks the entire index <span class="italic">entry</span>, which in practice locks the rows pointed to by the bitmap. For example, if the county of residence for a specific customer changes from <code class="codeph">San Mateo</code> to <code class="codeph">Alameda</code>, then the database must get exclusive access to the <code class="codeph">San Mateo</code> index entry and <code class="codeph">Alameda</code> index entry in the bitmap. Rows containing these two values cannot be modified until <code class="codeph">COMMIT</code>.
                              </p>
                           </li>
                        </ul>
                     </div>
                     <div>
                        <div class="infoboxnotealso" id="GUID-90B6A8AF-BB62-454B-92AF-AB9E01D93C4D__GUID-6D7F343E-4B8E-43A3-98E6-D2B4862F37CC">
                           <p class="notep1">See Also:</p>
                           <ul style="list-style-type: disc;">
                              <li>
                                 <p><span class="q">"<a href="query-transformations.html#GUID-EA178F1F-7564-4621-B884-19A202943421" title="Star transformation is an optimizer transformation that avoids full table scans of fact tables in a star schema.">Star Transformation</a>"</span></p>
                              </li>
                              <li>
                                 <p><a href="https://www.oracle.com/pls/topic/lookup?ctx=en/database/oracle/oracle-database/19/tgsql&amp;id=SQLRF00624" target="_blank"><span><cite>Oracle Database SQL Language Reference</cite></span></a> to learn about the <code class="codeph">COUNT</code> function
                                 </p>
                              </li>
                           </ul>
                        </div>
                        <div class="familylinks">
                           <div class="parentlink">
                              <p><strong>Parent topic:</strong> <a href="optimizer-access-paths.html#GUID-CD3D7579-3E44-4383-8056-B11B805A437F" title="In a conventional B-tree index, one index entry points to a single row. In a bitmap index, the key is the combination of the indexed data and the rowid range.">About Bitmap Index Access</a></p>
                           </div>
                        </div>
                     </div>
                     
                  </div><a id="TGSQL95199"></a><a id="TGSQL95198"></a><div class="props_rev_3"><a id="GUID-0604FCDA-473B-432F-B1B2-8F766D377D63" name="GUID-0604FCDA-473B-432F-B1B2-8F766D377D63"></a><h5 id="TGSQL-GUID-0604FCDA-473B-432F-B1B2-8F766D377D63" class="sect5"><span class="enumeration_section">8.4.1.3 </span>Bitmaps and Rowids
                     </h5>
                     <div>
                        <p>For a particular value in a bitmap, the value is <code class="codeph">1</code> if the row values match the bitmap condition, and <code class="codeph">0</code> if it does not. Based on these values, the database uses an internal algorithm to map bitmaps onto rowids.
                        </p>
                        <p>The bitmap entry contains the indexed value, the rowid range (start and end rowids), and a bitmap. Each <code class="codeph">0</code> or <code class="codeph">1</code> value in the bitmap is an offset into the rowid range, and maps to a potential row in the table, even if the row does not exist. Because the number of possible rows in a block is predetermined, the database can use the range endpoints to determine the rowid of an arbitrary row in the range.
                        </p>
                        <div class="infoboxnote" id="GUID-0604FCDA-473B-432F-B1B2-8F766D377D63__GUID-21088835-E1F4-4DE4-9D9D-60F96974B9CA">
                           <p class="notep1">Note:</p>
                           <p>The Hakan factor is an optimization used by the bitmap index algorithms to limit the number of rows that Oracle Database assumes can be stored in a single block. By artificially limiting the number of rows, the database reduces the size of the bitmaps.</p>
                        </div>
                        <p><a href="optimizer-access-paths.html#GUID-0604FCDA-473B-432F-B1B2-8F766D377D63__CHDJHDHC" title="Sample bitmap for bitmap index">Table 8-4</a> shows part of a sample bitmap for the <code class="codeph">sh.customers.cust_marital_status</code> column, which is nullable. The actual index has 12 distinct values. Only 3 are shown in the sample: null, <code class="codeph">married</code>, and <code class="codeph">single</code>.
                        </p>
                        <div class="tblformal" id="GUID-0604FCDA-473B-432F-B1B2-8F766D377D63__CHDJHDHC">
                           <p class="titleintable">Table 8-4 Bitmap Index Entries</p>
                           <table cellpadding="4" cellspacing="0" class="Formal" title="Bitmap Index Entries" summary="Sample bitmap for bitmap index" width="100%" frame="hsides" border="1" rules="rows">
                              <thead>
                                 <tr align="left" valign="top">
                                    <th align="left" valign="bottom" width="16%" id="d37861e9725">Column Value for cust_marital_status</th>
                                    <th align="left" valign="bottom" width="13%" id="d37861e9728">Start Rowid in Range</th>
                                    <th align="left" valign="bottom" width="13%" id="d37861e9731">End Rowid in Range</th>
                                    <th align="left" valign="bottom" width="10%" id="d37861e9734">1st Row in Range </th>
                                    <th align="left" valign="bottom" width="10%" id="d37861e9737">2nd Row in Range</th>
                                    <th align="left" valign="bottom" width="10%" id="d37861e9740">3rd Row in Range</th>
                                    <th align="left" valign="bottom" width="10%" id="d37861e9743">4th Row in Range</th>
                                    <th align="left" valign="bottom" width="10%" id="d37861e9746">5th Row in Range</th>
                                    <th align="left" valign="bottom" width="10%" id="d37861e9749">6th Row in Range</th>
                                 </tr>
                              </thead>
                              <tbody>
                                 <tr align="left" valign="top">
                                    <td align="left" valign="top" width="16%" id="d37861e9754" headers="d37861e9725 ">
                                       <p>(null)</p>
                                    </td>
                                    <td align="left" valign="top" width="13%" headers="d37861e9754 d37861e9728 ">
                                       <p><code class="codeph">AAA ...</code></p>
                                    </td>
                                    <td align="left" valign="top" width="13%" headers="d37861e9754 d37861e9731 ">
                                       <p><code class="codeph">CCC ...</code></p>
                                    </td>
                                    <td align="left" valign="top" width="10%" headers="d37861e9754 d37861e9734 ">
                                       <p>0</p>
                                    </td>
                                    <td align="left" valign="top" width="10%" headers="d37861e9754 d37861e9737 ">
                                       <p>0</p>
                                    </td>
                                    <td align="left" valign="top" width="10%" headers="d37861e9754 d37861e9740 ">
                                       <p>0</p>
                                    </td>
                                    <td align="left" valign="top" width="10%" headers="d37861e9754 d37861e9743 ">
                                       <p>0</p>
                                    </td>
                                    <td align="left" valign="top" width="10%" headers="d37861e9754 d37861e9746 ">
                                       <p>0</p>
                                    </td>
                                    <td align="left" valign="top" width="10%" headers="d37861e9754 d37861e9749 ">
                                       <p>1</p>
                                    </td>
                                 </tr>
                                 <tr align="left" valign="top">
                                    <td align="left" valign="top" width="16%" id="d37861e9784" headers="d37861e9725 ">
                                       <p><code class="codeph">married</code></p>
                                    </td>
                                    <td align="left" valign="top" width="13%" headers="d37861e9784 d37861e9728 ">
                                       <p><code class="codeph">AAA ...</code></p>
                                    </td>
                                    <td align="left" valign="top" width="13%" headers="d37861e9784 d37861e9731 ">
                                       <p><code class="codeph">CCC ...</code></p>
                                    </td>
                                    <td align="left" valign="top" width="10%" headers="d37861e9784 d37861e9734 ">
                                       <p>1</p>
                                    </td>
                                    <td align="left" valign="top" width="10%" headers="d37861e9784 d37861e9737 ">
                                       <p>0</p>
                                    </td>
                                    <td align="left" valign="top" width="10%" headers="d37861e9784 d37861e9740 ">
                                       <p>1</p>
                                    </td>
                                    <td align="left" valign="top" width="10%" headers="d37861e9784 d37861e9743 ">
                                       <p>1</p>
                                    </td>
                                    <td align="left" valign="top" width="10%" headers="d37861e9784 d37861e9746 ">
                                       <p>1</p>
                                    </td>
                                    <td align="left" valign="top" width="10%" headers="d37861e9784 d37861e9749 ">
                                       <p>0</p>
                                    </td>
                                 </tr>
                                 <tr align="left" valign="top">
                                    <td align="left" valign="top" width="16%" id="d37861e9815" headers="d37861e9725 ">
                                       <p><code class="codeph">single</code></p>
                                    </td>
                                    <td align="left" valign="top" width="13%" headers="d37861e9815 d37861e9728 ">
                                       <p><code class="codeph">AAA ...</code></p>
                                    </td>
                                    <td align="left" valign="top" width="13%" headers="d37861e9815 d37861e9731 ">
                                       <p><code class="codeph">CCC ...</code></p>
                                    </td>
                                    <td align="left" valign="top" width="10%" headers="d37861e9815 d37861e9734 ">
                                       <p>0</p>
                                    </td>
                                    <td align="left" valign="top" width="10%" headers="d37861e9815 d37861e9737 ">
                                       <p>1</p>
                                    </td>
                                    <td align="left" valign="top" width="10%" headers="d37861e9815 d37861e9740 ">
                                       <p>0</p>
                                    </td>
                                    <td align="left" valign="top" width="10%" headers="d37861e9815 d37861e9743 ">
                                       <p>0</p>
                                    </td>
                                    <td align="left" valign="top" width="10%" headers="d37861e9815 d37861e9746 ">
                                       <p>0</p>
                                    </td>
                                    <td align="left" valign="top" width="10%" headers="d37861e9815 d37861e9749 ">
                                       <p>0</p>
                                    </td>
                                 </tr>
                                 <tr align="left" valign="top">
                                    <td align="left" valign="top" width="16%" id="d37861e9846" headers="d37861e9725 ">
                                       <p><code class="codeph">single</code></p>
                                    </td>
                                    <td align="left" valign="top" width="13%" headers="d37861e9846 d37861e9728 ">
                                       <p><code class="codeph">DDD ...</code></p>
                                    </td>
                                    <td align="left" valign="top" width="13%" headers="d37861e9846 d37861e9731 ">
                                       <p><code class="codeph">EEE ...</code></p>
                                    </td>
                                    <td align="left" valign="top" width="10%" headers="d37861e9846 d37861e9734 ">
                                       <p>1</p>
                                    </td>
                                    <td align="left" valign="top" width="10%" headers="d37861e9846 d37861e9737 ">
                                       <p>0</p>
                                    </td>
                                    <td align="left" valign="top" width="10%" headers="d37861e9846 d37861e9740 ">
                                       <p>1</p>
                                    </td>
                                    <td align="left" valign="top" width="10%" headers="d37861e9846 d37861e9743 ">
                                       <p>0</p>
                                    </td>
                                    <td align="left" valign="top" width="10%" headers="d37861e9846 d37861e9746 ">
                                       <p>1</p>
                                    </td>
                                    <td align="left" valign="top" width="10%" headers="d37861e9846 d37861e9749 ">
                                       <p>1</p>
                                    </td>
                                 </tr>
                              </tbody>
                           </table>
                        </div>
                        <!-- class="inftblhruleinformal" -->
                        <p>As shown in <a href="optimizer-access-paths.html#GUID-0604FCDA-473B-432F-B1B2-8F766D377D63__CHDJHDHC" title="Sample bitmap for bitmap index">Table 8-4</a>, bitmap indexes can include keys that consist entirely of null values, unlike B-tree indexes. In <a href="optimizer-access-paths.html#GUID-0604FCDA-473B-432F-B1B2-8F766D377D63__CHDJHDHC" title="Sample bitmap for bitmap index">Table 8-4</a>, the null has a value of <code class="codeph">1</code> for the 6th row in the range, which means that the <code class="codeph">cust_marital_status</code> value is null for the 6th row in the range. Indexing nulls can be useful for some SQL statements, such as queries with the aggregate function <code class="codeph">COUNT</code>.
                        </p>
                     </div>
                     <div>
                        <div class="infoboxnotealso" id="GUID-0604FCDA-473B-432F-B1B2-8F766D377D63__GUID-41AE5B01-1926-4AA8-875C-6CD172F4D6A7">
                           <p class="notep1">See Also:</p>
                           <p><a href="https://www.oracle.com/pls/topic/lookup?ctx=en/database/oracle/oracle-database/19/tgsql&amp;id=CNCPT89008" target="_blank"><span class="italic">Oracle Database Concepts</span></a> to learn about rowid formats
                           </p>
                        </div>
                        <div class="familylinks">
                           <div class="parentlink">
                              <p><strong>Parent topic:</strong> <a href="optimizer-access-paths.html#GUID-CD3D7579-3E44-4383-8056-B11B805A437F" title="In a conventional B-tree index, one index entry points to a single row. In a bitmap index, the key is the combination of the indexed data and the rowid range.">About Bitmap Index Access</a></p>
                           </div>
                        </div>
                     </div>
                     
                  </div><a id="TGSQL95200"></a><div class="props_rev_3"><a id="GUID-1F859889-14BC-4F0B-90CE-8682737FB46F" name="GUID-1F859889-14BC-4F0B-90CE-8682737FB46F"></a><h5 id="TGSQL-GUID-1F859889-14BC-4F0B-90CE-8682737FB46F" class="sect5"><span class="enumeration_section">8.4.1.4 </span>Bitmap Join Indexes
                     </h5>
                     <div>
                        <p>A <span class="bold">bitmap join index</span> is a bitmap index for the join of two or more tables.
                        </p>
                        <p>The optimizer can use a bitmap join index to reduce or eliminate the volume of data that must be joined during plan execution. Bitmap join indexes can be much more efficient in storage than materialized join views.</p>
                        <p>The following example creates a bitmap index on the <code class="codeph">sh.sales</code> and <code class="codeph">sh.customers</code> tables:
                        </p><pre class="pre codeblock"><code>CREATE BITMAP INDEX cust_sales_bji ON sales(c.cust_city) 
  FROM sales s, customers c 
  WHERE c.cust_id = s.cust_id LOCAL;
</code></pre><p>The <code class="codeph">FROM</code> and <code class="codeph">WHERE</code> clause in the preceding <code class="codeph">CREATE</code> statement represent the join condition between the tables. The <code class="codeph">customers.cust_city</code> column is the index key. 
                        </p>
                        <p>Each key value in the index represents a possible city in the <code class="codeph">customers</code> table. Conceptually, key values for the index might look as follows, with one bitmap associated with each key value:
                        </p><pre class="pre codeblock"><code>San Francisco   0 0 0 1 0 1 0 0 0 1 0 0 0 0 0 . . .
San Mateo       0 1 0 0 0 0 0 0 1 0 0 0 0 0 1 . . .
Smithville      1 0 0 0 1 0 0 1 0 0 1 0 1 0 0 . . .
.
.
.
</code></pre><p>Each bit in a bitmap corresponds to one row in the <code class="codeph">sales</code> table. In the <code class="codeph">Smithville</code> key, the value <code class="codeph">1</code> means that the first row in the <code class="codeph">sales</code> table corresponds to a product sold to a Smithville customer, whereas the value <code class="codeph">0</code> means that the second row corresponds to a product not sold to a Smithville customer.
                        </p>
                        <p>Consider the following query of the number of separate sales to Smithville customers:</p><pre class="pre codeblock"><code>SELECT COUNT (*)
FROM   sales s, customers c
WHERE  c.cust_id = s.cust_id
AND    c.cust_city = 'Smithville';
</code></pre><p>The following plan shows that the database reads the <code class="codeph">Smithville</code> bitmap to derive the number of Smithville sales (Step 4), thereby avoiding a join of the <code class="codeph">customers</code> and <code class="codeph">sales</code> tables. 
                        </p><pre class="pre codeblock"><code>SQL_ID  57s100mh142wy, child number 0
-------------------------------------
SELECT COUNT (*) FROM sales s, customers c WHERE c.cust_id = s.cust_id 
AND c.cust_city = 'Smithville'
 
Plan hash value: 3663491772
 
------------------------------------------------------------------------------------
|Id| Operation                    | Name |Rows|Bytes|Cost (%CPU)| Time|Pstart|Pstop|
------------------------------------------------------------------------------------
| 0| SELECT STATEMENT             |              |     |    |29 (100)|        | |  |
| 1|  SORT AGGREGATE              |              |   1 |   5|        |        | |  |
| 2|   PARTITION RANGE ALL        |              | 1708|8540|29   (0)|00:00:01|1|28|
| 3|    BITMAP CONVERSION COUNT   |              | 1708|8540|29   (0)|00:00:01| |  |
|*4|     <span class="bold">BITMAP INDEX SINGLE VALUE</span>|CUST_SALES_BJI|     |    |        |        |1|28|
------------------------------------------------------------------------------------
 
Predicate Information (identified by operation id):
---------------------------------------------------
 
   4 - access("S"."SYS_NC00008$"='Smithville')</code></pre></div>
                     <div>
                        <div class="infoboxnotealso" id="GUID-1F859889-14BC-4F0B-90CE-8682737FB46F__GUID-C7EE0996-76FF-4B00-9B4B-DF7FC6232398">
                           <p class="notep1">See Also:</p>
                           <p><a href="https://www.oracle.com/pls/topic/lookup?ctx=en/database/oracle/oracle-database/19/tgsql&amp;id=SQLRF01209" target="_blank"><span><cite>Oracle Database Concepts</cite></span></a> to learn about the <code class="codeph">CREATE INDEX</code> statement
                           </p>
                        </div>
                        <div class="familylinks">
                           <div class="parentlink">
                              <p><strong>Parent topic:</strong> <a href="optimizer-access-paths.html#GUID-CD3D7579-3E44-4383-8056-B11B805A437F" title="In a conventional B-tree index, one index entry points to a single row. In a bitmap index, the key is the combination of the indexed data and the rowid range.">About Bitmap Index Access</a></p>
                           </div>
                        </div>
                     </div>
                     
                  </div><a id="TGSQL95201"></a><div class="props_rev_3"><a id="GUID-BD3F4C5B-E1A6-4444-AA74-87BE752B096E" name="GUID-BD3F4C5B-E1A6-4444-AA74-87BE752B096E"></a><h5 id="TGSQL-GUID-BD3F4C5B-E1A6-4444-AA74-87BE752B096E" class="sect5"><span class="enumeration_section">8.4.1.5 </span>Bitmap Storage
                     </h5>
                     <div>
                        <p>A bitmap index resides in a B-tree structure, using branch blocks and leaf blocks just as in a B-tree. </p>
                        <p>For example, if the <code class="codeph">customers.cust_marital_status</code> column has 12 distinct values, then one branch block might point to the keys <code class="codeph">married,<span class="codeinlineitalic">rowid-range</span></code> and <code class="codeph">single,<span class="codeinlineitalic">rowid-range</span></code>, another branch block might point to the <code class="codeph">widowed,<span class="codeinlineitalic">rowid-range</span></code> key, and so on. Alternatively, a single branch block could point to a leaf block containing all 12 distinct keys.
                        </p>
                        <p>Each indexed column value may have one or more bitmap pieces, each with its own rowid range occupying a contiguous set of rows in one or more extents. The database can use a <a href="glossary.html#GUID-45DDE193-8222-4A79-B126-151C2D640A3E"><span class="xrefglossterm">bitmap piece</span></a> to break up an index entry that is large relative to the size of a block. For example, the database could break a single index entry into three pieces, with the first two pieces in separate blocks in the same extent, and the last piece in a separate block in a different extent.
                        </p>
                        <p>To conserve space, Oracle Database can compression consecutive ranges of <code class="codeph">0</code> values.
                        </p>
                     </div>
                     <div>
                        <div class="familylinks">
                           <div class="parentlink">
                              <p><strong>Parent topic:</strong> <a href="optimizer-access-paths.html#GUID-CD3D7579-3E44-4383-8056-B11B805A437F" title="In a conventional B-tree index, one index entry points to a single row. In a bitmap index, the key is the combination of the indexed data and the rowid range.">About Bitmap Index Access</a></p>
                           </div>
                        </div>
                     </div>
                     
                  </div>
               </div><a id="TGSQL95202"></a><div class="props_rev_3"><a id="GUID-2939D4FD-ECC4-48FB-9AD7-CD844CC71786" name="GUID-2939D4FD-ECC4-48FB-9AD7-CD844CC71786"></a><h4 id="TGSQL-GUID-2939D4FD-ECC4-48FB-9AD7-CD844CC71786" class="sect4"><span class="enumeration_section">8.4.2 </span>Bitmap Conversion to Rowid
                  </h4>
                  <div>
                     <p>A bitmap conversion translates between an entry in the bitmap and a row in a table. The conversion can go from entry to row (<code class="codeph">TO ROWID</code>), or from row to entry (<code class="codeph">FROM ROWID</code>).
                     </p>
                     <p>This section contains the following topics:</p>
                  </div>
                  <div>
                     <ul class="ullinks">
                        <li class="ulchildlink"><a href="optimizer-access-paths.html#GUID-E66932B7-A092-49AB-ADAE-66B24A32B222">When the Optimizer Chooses Bitmap Conversion to Rowid</a><br>The optimizer uses a conversion whenever it retrieves a row from a table using a bitmap index entry.
                        </li>
                        <li class="ulchildlink"><a href="optimizer-access-paths.html#GUID-44784FBB-AE07-4A57-B5C3-E558F05EDCFB">How Bitmap Conversion to Rowid Works</a><br>Conceptually, a bitmap can be represented as table.
                        </li>
                        <li class="ulchildlink"><a href="optimizer-access-paths.html#GUID-3F77355A-BF28-46CF-85A8-6F694348958A">Bitmap Conversion to Rowid: Example</a><br>In this example, the optimizer chooses a bitmap conversion operation to satisfy a query using a range predicate.
                        </li>
                     </ul>
                     <div class="familylinks">
                        <div class="parentlink">
                           <p><strong>Parent topic:</strong> <a href="optimizer-access-paths.html#GUID-B5E41901-933E-4A31-B5D6-9771FD435EC0" title="Bitmap indexes combine the indexed data with a rowid range.">Bitmap Index Access Paths</a></p>
                        </div>
                     </div>
                  </div>
                  <a id="TGSQL95203"></a><div class="props_rev_3"><a id="GUID-E66932B7-A092-49AB-ADAE-66B24A32B222" name="GUID-E66932B7-A092-49AB-ADAE-66B24A32B222"></a><h5 id="TGSQL-GUID-E66932B7-A092-49AB-ADAE-66B24A32B222" class="sect5"><span class="enumeration_section">8.4.2.1 </span>When the Optimizer Chooses Bitmap Conversion to Rowid
                     </h5>
                     <div>
                        <p>The optimizer uses a conversion whenever it retrieves a row from a table using a bitmap index entry.</p>
                     </div>
                     <div>
                        <div class="familylinks">
                           <div class="parentlink">
                              <p><strong>Parent topic:</strong> <a href="optimizer-access-paths.html#GUID-2939D4FD-ECC4-48FB-9AD7-CD844CC71786" title="A bitmap conversion translates between an entry in the bitmap and a row in a table. The conversion can go from entry to row (TO ROWID), or from row to entry (FROM ROWID).">Bitmap Conversion to Rowid</a></p>
                           </div>
                        </div>
                     </div>
                     
                  </div><a id="TGSQL95204"></a><div class="props_rev_3"><a id="GUID-44784FBB-AE07-4A57-B5C3-E558F05EDCFB" name="GUID-44784FBB-AE07-4A57-B5C3-E558F05EDCFB"></a><h5 id="TGSQL-GUID-44784FBB-AE07-4A57-B5C3-E558F05EDCFB" class="sect5"><span class="enumeration_section">8.4.2.2 </span>How Bitmap Conversion to Rowid Works
                     </h5>
                     <div>
                        <p>Conceptually, a bitmap can be represented as table.</p>
                        <p>For example, <a href="optimizer-access-paths.html#GUID-0604FCDA-473B-432F-B1B2-8F766D377D63__CHDJHDHC" title="Sample bitmap for bitmap index">Table 8-4</a> represents the bitmap as a table with <code class="codeph">customers</code> row numbers as columns and <code class="codeph">cust_marital_status</code> values as rows. Each field in <a href="optimizer-access-paths.html#GUID-0604FCDA-473B-432F-B1B2-8F766D377D63__CHDJHDHC" title="Sample bitmap for bitmap index">Table 8-4</a> has the value <code class="codeph">1</code> or <code class="codeph">0</code>, and represents a column value in a row. Conceptually, the bitmap conversion uses an internal algorithm that says, "Field <span class="italic">F</span> in the bitmap corresponds to the <span class="italic">N</span>th row of the <span class="italic">M</span>th block of the table," or "The <span class="italic">N</span>th row of the <span class="italic">M</span>th block in the table corresponds to field <span class="italic">F</span> in the bitmap."
                        </p>
                     </div>
                     <div>
                        <div class="familylinks">
                           <div class="parentlink">
                              <p><strong>Parent topic:</strong> <a href="optimizer-access-paths.html#GUID-2939D4FD-ECC4-48FB-9AD7-CD844CC71786" title="A bitmap conversion translates between an entry in the bitmap and a row in a table. The conversion can go from entry to row (TO ROWID), or from row to entry (FROM ROWID).">Bitmap Conversion to Rowid</a></p>
                           </div>
                        </div>
                     </div>
                     
                  </div><a id="TGSQL95205"></a><div class="props_rev_3"><a id="GUID-3F77355A-BF28-46CF-85A8-6F694348958A" name="GUID-3F77355A-BF28-46CF-85A8-6F694348958A"></a><h5 id="TGSQL-GUID-3F77355A-BF28-46CF-85A8-6F694348958A" class="sect5"><span class="enumeration_section">8.4.2.3 </span>Bitmap Conversion to Rowid: Example
                     </h5>
                     <div>
                        <p>In this example, the optimizer chooses a bitmap conversion operation to satisfy a query using a range predicate.</p>
                        <p>A query of the <code class="codeph">sh.customers</code> table selects the names of all customers born before 1918:
                        </p><pre class="pre codeblock"><code>SELECT cust_last_name, cust_first_name
FROM   customers
WHERE  cust_year_of_birth &lt; 1918;
</code></pre><p>The following plan shows that the database uses a range scan to find all key values less than <code class="codeph">1918</code> (Step 3), converts the <code class="codeph">1</code> values in the bitmap to rowids (Step 2), and then uses the rowids to obtain the rows from the <code class="codeph">customers</code> table (Step 1):
                        </p><pre class="pre codeblock"><code>---------------------------------------------------------------------------------------------
|Id| Operation                           | Name             |Rows|Bytes|Cost(%CPU)| Time    |
---------------------------------------------------------------------------------------------
| 0| SELECT STATEMENT                    |                  |    |     |421 (100)|          |
| 1|  TABLE ACCESS BY INDEX ROWID BATCHED| CUSTOMERS        |3604|68476|421   (1)| 00:00:01 |
| 2|   <span class="bold">BITMAP CONVERSION TO ROWIDS</span>       |                  |    |     |         |          |
|*3|    BITMAP INDEX RANGE SCAN          | CUSTOMERS_YOB_BIX|    |     |         |          |
---------------------------------------------------------------------------------------------

Predicate Information (identified by operation id):
---------------------------------------------------
   3 - access("CUST_YEAR_OF_BIRTH"&lt;1918)
       filter("CUST_YEAR_OF_BIRTH"&lt;1918)</code></pre></div>
                     <div>
                        <div class="familylinks">
                           <div class="parentlink">
                              <p><strong>Parent topic:</strong> <a href="optimizer-access-paths.html#GUID-2939D4FD-ECC4-48FB-9AD7-CD844CC71786" title="A bitmap conversion translates between an entry in the bitmap and a row in a table. The conversion can go from entry to row (TO ROWID), or from row to entry (FROM ROWID).">Bitmap Conversion to Rowid</a></p>
                           </div>
                        </div>
                     </div>
                     
                  </div>
               </div><a id="TGSQL95206"></a><div class="props_rev_3"><a id="GUID-E8F4A411-10BE-4D5E-9207-0D5F8E61A8E0" name="GUID-E8F4A411-10BE-4D5E-9207-0D5F8E61A8E0"></a><h4 id="TGSQL-GUID-E8F4A411-10BE-4D5E-9207-0D5F8E61A8E0" class="sect4"><span class="enumeration_section">8.4.3 </span>Bitmap Index Single Value
                  </h4>
                  <div>
                     <p>This type of access path uses a bitmap index to look up a single key value.</p>
                     <p>This section contains the following topics:</p>
                  </div>
                  <div>
                     <ul class="ullinks">
                        <li class="ulchildlink"><a href="optimizer-access-paths.html#GUID-86B195AF-AC56-4694-B015-D12D24B66927">When the Optimizer Considers Bitmap Index Single Value</a><br>The optimizer considers this access path when the predicate contains an equality operator.
                        </li>
                        <li class="ulchildlink"><a href="optimizer-access-paths.html#GUID-FFD27025-9841-4ECC-8E07-46380340CA45">How Bitmap Index Single Value Works</a><br>The query scans a single bitmap for positions containing a <code class="codeph">1</code> value. The database converts the <code class="codeph">1</code> values into rowids, and then uses the rowids to find the rows.
                        </li>
                        <li class="ulchildlink"><a href="optimizer-access-paths.html#GUID-CE4D999C-F694-4E5C-B54C-1919F80734B8">Bitmap Index Single Value: Example</a><br>In this example, the optimizer chooses a bitmap index single value operation to satisfy a query that uses an equality predicate.
                        </li>
                     </ul>
                     <div class="familylinks">
                        <div class="parentlink">
                           <p><strong>Parent topic:</strong> <a href="optimizer-access-paths.html#GUID-B5E41901-933E-4A31-B5D6-9771FD435EC0" title="Bitmap indexes combine the indexed data with a rowid range.">Bitmap Index Access Paths</a></p>
                        </div>
                     </div>
                  </div>
                  <a id="TGSQL95207"></a><div class="props_rev_3"><a id="GUID-86B195AF-AC56-4694-B015-D12D24B66927" name="GUID-86B195AF-AC56-4694-B015-D12D24B66927"></a><h5 id="TGSQL-GUID-86B195AF-AC56-4694-B015-D12D24B66927" class="sect5"><span class="enumeration_section">8.4.3.1 </span>When the Optimizer Considers Bitmap Index Single Value
                     </h5>
                     <div>
                        <p>The optimizer considers this access path when the predicate contains an equality operator.</p>
                     </div>
                     <div>
                        <div class="familylinks">
                           <div class="parentlink">
                              <p><strong>Parent topic:</strong> <a href="optimizer-access-paths.html#GUID-E8F4A411-10BE-4D5E-9207-0D5F8E61A8E0" title="This type of access path uses a bitmap index to look up a single key value.">Bitmap Index Single Value</a></p>
                           </div>
                        </div>
                     </div>
                     
                  </div><a id="TGSQL95208"></a><div class="props_rev_3"><a id="GUID-FFD27025-9841-4ECC-8E07-46380340CA45" name="GUID-FFD27025-9841-4ECC-8E07-46380340CA45"></a><h5 id="TGSQL-GUID-FFD27025-9841-4ECC-8E07-46380340CA45" class="sect5"><span class="enumeration_section">8.4.3.2 </span>How Bitmap Index Single Value Works
                     </h5>
                     <div>
                        <p>The query scans a single bitmap for positions containing a <code class="codeph">1</code> value. The database converts the <code class="codeph">1</code> values into rowids, and then uses the rowids to find the rows.
                        </p>
                        <p>The database only needs to process a single bitmap. For example, the following table represents the bitmap index (in two bitmap pieces) for the value <code class="codeph">widowed</code> in the <code class="codeph">sh.customers.cust_marital_status</code> column. To satisfy a query of customers with the status <code class="codeph">widowed</code>, the database can search for each <code class="codeph">1</code> value in the <code class="codeph">widowed</code> bitmap and find the rowid of the corresponding row.
                        </p>
                        <div class="tblformal" id="GUID-FFD27025-9841-4ECC-8E07-46380340CA45__GUID-EE599145-CB9F-4A23-B61C-EC903C5F7F71">
                           <p class="titleintable">Table 8-5 Bitmap Index Entries</p>
                           <table cellpadding="4" cellspacing="0" class="Formal" title="Bitmap Index Entries" summary="Sample bitmap for bitmap index" width="100%" frame="hsides" border="1" rules="rows">
                              <thead>
                                 <tr align="left" valign="top">
                                    <th align="left" valign="bottom" width="14%" id="d37861e11230">Column Value</th>
                                    <th align="left" valign="bottom" width="14%" id="d37861e11233">Start Rowid in Range</th>
                                    <th align="left" valign="bottom" width="13%" id="d37861e11236">End Rowid in Range</th>
                                    <th align="left" valign="bottom" width="10%" id="d37861e11239">1st Row in Range </th>
                                    <th align="left" valign="bottom" width="10%" id="d37861e11242">2nd Row in Range</th>
                                    <th align="left" valign="bottom" width="10%" id="d37861e11245">3rd Row in Range</th>
                                    <th align="left" valign="bottom" width="10%" id="d37861e11248">4th Row in Range</th>
                                    <th align="left" valign="bottom" width="10%" id="d37861e11251">5th Row in Range</th>
                                    <th align="left" valign="bottom" width="10%" id="d37861e11254">6th Row in Range</th>
                                 </tr>
                              </thead>
                              <tbody>
                                 <tr align="left" valign="top">
                                    <td align="left" valign="top" width="14%" id="d37861e11259" headers="d37861e11230 ">
                                       <p><code class="codeph">widowed</code></p>
                                    </td>
                                    <td align="left" valign="top" width="14%" headers="d37861e11259 d37861e11233 ">
                                       <p><code class="codeph">AAA ...</code></p>
                                    </td>
                                    <td align="left" valign="top" width="13%" headers="d37861e11259 d37861e11236 ">
                                       <p><code class="codeph">CCC ...</code></p>
                                    </td>
                                    <td align="left" valign="top" width="10%" headers="d37861e11259 d37861e11239 ">
                                       <p>0</p>
                                    </td>
                                    <td align="left" valign="top" width="10%" headers="d37861e11259 d37861e11242 ">
                                       <p>1</p>
                                    </td>
                                    <td align="left" valign="top" width="10%" headers="d37861e11259 d37861e11245 ">
                                       <p>0</p>
                                    </td>
                                    <td align="left" valign="top" width="10%" headers="d37861e11259 d37861e11248 ">
                                       <p>0</p>
                                    </td>
                                    <td align="left" valign="top" width="10%" headers="d37861e11259 d37861e11251 ">
                                       <p>0</p>
                                    </td>
                                    <td align="left" valign="top" width="10%" headers="d37861e11259 d37861e11254 ">
                                       <p>0</p>
                                    </td>
                                 </tr>
                                 <tr align="left" valign="top">
                                    <td align="left" valign="top" width="14%" id="d37861e11290" headers="d37861e11230 ">
                                       <p><code class="codeph">widowed</code></p>
                                    </td>
                                    <td align="left" valign="top" width="14%" headers="d37861e11290 d37861e11233 ">
                                       <p><code class="codeph">DDD ...</code></p>
                                    </td>
                                    <td align="left" valign="top" width="13%" headers="d37861e11290 d37861e11236 ">
                                       <p><code class="codeph">EEE ...</code></p>
                                    </td>
                                    <td align="left" valign="top" width="10%" headers="d37861e11290 d37861e11239 ">
                                       <p>1</p>
                                    </td>
                                    <td align="left" valign="top" width="10%" headers="d37861e11290 d37861e11242 ">
                                       <p>0</p>
                                    </td>
                                    <td align="left" valign="top" width="10%" headers="d37861e11290 d37861e11245 ">
                                       <p>1</p>
                                    </td>
                                    <td align="left" valign="top" width="10%" headers="d37861e11290 d37861e11248 ">
                                       <p>0</p>
                                    </td>
                                    <td align="left" valign="top" width="10%" headers="d37861e11290 d37861e11251 ">
                                       <p>1</p>
                                    </td>
                                    <td align="left" valign="top" width="10%" headers="d37861e11290 d37861e11254 ">
                                       <p>1</p>
                                    </td>
                                 </tr>
                              </tbody>
                           </table>
                        </div>
                        <!-- class="inftblhruleinformal" -->
                     </div>
                     <div>
                        <div class="familylinks">
                           <div class="parentlink">
                              <p><strong>Parent topic:</strong> <a href="optimizer-access-paths.html#GUID-E8F4A411-10BE-4D5E-9207-0D5F8E61A8E0" title="This type of access path uses a bitmap index to look up a single key value.">Bitmap Index Single Value</a></p>
                           </div>
                        </div>
                     </div>
                     
                  </div><a id="TGSQL95209"></a><div class="props_rev_3"><a id="GUID-CE4D999C-F694-4E5C-B54C-1919F80734B8" name="GUID-CE4D999C-F694-4E5C-B54C-1919F80734B8"></a><h5 id="TGSQL-GUID-CE4D999C-F694-4E5C-B54C-1919F80734B8" class="sect5"><span class="enumeration_section">8.4.3.3 </span>Bitmap Index Single Value: Example
                     </h5>
                     <div>
                        <p>In this example, the optimizer chooses a bitmap index single value operation to satisfy a query that uses an equality predicate.</p>
                        <p>A query of the <code class="codeph">sh.customers</code> table selects all widowed customers:
                        </p><pre class="pre codeblock"><code>SELECT * 
FROM   customers 
WHERE  cust_marital_status = 'Widowed';
</code></pre><p>The following plan shows that the database reads the entry with the <code class="codeph">Widowed</code> key in the <code class="codeph">customers</code> bitmap index (Step 3), converts the <code class="codeph">1</code> values in the bitmap to rowids (Step 2), and then uses the rowids to obtain the rows from the <code class="codeph">customers</code> table (Step 1):
                        </p><pre class="pre codeblock"><code>SQL_ID  ff5an2xsn086h, child number 0
-------------------------------------
SELECT * FROM customers WHERE cust_marital_status = 'Widowed'
 
Plan hash value: 2579015045
---------------------------------------------------------------------------------------------
|Id| Operation                           | Name                |Rows|Bytes|Cost (%CPU)| Time|
---------------------------------------------------------------------------------------------
| 0| SELECT STATEMENT                    |                     |    |    |412 (100)|        |
| 1|  TABLE ACCESS BY INDEX ROWID BATCHED|CUSTOMERS            |3461|638K|412   (2)|00:00:01|
| 2|   BITMAP CONVERSION TO ROWIDS       |                     |    |    |         |        |
|*3|    <span class="bold">BITMAP INDEX SINGLE VALUE</span>        |CUSTOMERS_MARITAL_BIX|    |    |         |        |
---------------------------------------------------------------------------------------------
 
Predicate Information (identified by operation id):
---------------------------------------------------
 
   3 - access("CUST_MARITAL_STATUS"='Widowed')</code></pre></div>
                     <div>
                        <div class="familylinks">
                           <div class="parentlink">
                              <p><strong>Parent topic:</strong> <a href="optimizer-access-paths.html#GUID-E8F4A411-10BE-4D5E-9207-0D5F8E61A8E0" title="This type of access path uses a bitmap index to look up a single key value.">Bitmap Index Single Value</a></p>
                           </div>
                        </div>
                     </div>
                     
                  </div>
               </div><a id="TGSQL95210"></a><div class="props_rev_3"><a id="GUID-9123D7CE-90DC-4C96-AB4F-49FD0227C40B" name="GUID-9123D7CE-90DC-4C96-AB4F-49FD0227C40B"></a><h4 id="TGSQL-GUID-9123D7CE-90DC-4C96-AB4F-49FD0227C40B" class="sect4"><span class="enumeration_section">8.4.4 </span>Bitmap Index Range Scans
                  </h4>
                  <div>
                     <p>This type of access path uses a bitmap index to look up a range of values.</p>
                     <p>This section contains the following topics:</p>
                  </div>
                  <div>
                     <ul class="ullinks">
                        <li class="ulchildlink"><a href="optimizer-access-paths.html#GUID-4F1E2861-F76D-4760-B43E-C12252017D8C">When the Optimizer Considers Bitmap Index Range Scans</a><br>The optimizer considers this access path when the predicate selects a range of values.
                        </li>
                        <li class="ulchildlink"><a href="optimizer-access-paths.html#GUID-B3D5EDB0-CD7B-4FE7-93B6-C348743CE95C">How Bitmap Index Range Scans Work</a><br>This scan works similarly to a B-tree range scan.
                        </li>
                        <li class="ulchildlink"><a href="optimizer-access-paths.html#GUID-CE4551F6-D694-4C4A-8606-9544278D3867">Bitmap Index Range Scans: Example</a><br>This example uses a range scan to select customers born before a single year.
                        </li>
                     </ul>
                     <div class="familylinks">
                        <div class="parentlink">
                           <p><strong>Parent topic:</strong> <a href="optimizer-access-paths.html#GUID-B5E41901-933E-4A31-B5D6-9771FD435EC0" title="Bitmap indexes combine the indexed data with a rowid range.">Bitmap Index Access Paths</a></p>
                        </div>
                     </div>
                  </div>
                  <a id="TGSQL95211"></a><div class="props_rev_3"><a id="GUID-4F1E2861-F76D-4760-B43E-C12252017D8C" name="GUID-4F1E2861-F76D-4760-B43E-C12252017D8C"></a><h5 id="TGSQL-GUID-4F1E2861-F76D-4760-B43E-C12252017D8C" class="sect5"><span class="enumeration_section">8.4.4.1 </span>When the Optimizer Considers Bitmap Index Range Scans
                     </h5>
                     <div>
                        <p>The optimizer considers this access path when the predicate selects a range of values.</p>
                        <p>The range in the scan can be bounded on both sides, or unbounded on one or both sides. The optimizer typically chooses a range scan for selective queries.</p>
                     </div>
                     <div>
                        <div class="infoboxnotealso" id="GUID-4F1E2861-F76D-4760-B43E-C12252017D8C__GUID-CE2AE938-47E7-422D-8BFA-E5FBAF94F75A">
                           <p class="notep1">See Also:</p>
                           <p><span class="q">"<a href="optimizer-access-paths.html#GUID-E2353939-DFBD-444A-94BC-2497E2A418D1" title="An index range scan is an ordered scan of values.">Index Range Scans</a>"</span></p>
                        </div>
                        <div class="familylinks">
                           <div class="parentlink">
                              <p><strong>Parent topic:</strong> <a href="optimizer-access-paths.html#GUID-9123D7CE-90DC-4C96-AB4F-49FD0227C40B" title="This type of access path uses a bitmap index to look up a range of values.">Bitmap Index Range Scans</a></p>
                           </div>
                        </div>
                     </div>
                     
                  </div><a id="TGSQL95212"></a><div class="props_rev_3"><a id="GUID-B3D5EDB0-CD7B-4FE7-93B6-C348743CE95C" name="GUID-B3D5EDB0-CD7B-4FE7-93B6-C348743CE95C"></a><h5 id="TGSQL-GUID-B3D5EDB0-CD7B-4FE7-93B6-C348743CE95C" class="sect5"><span class="enumeration_section">8.4.4.2 </span>How Bitmap Index Range Scans Work
                     </h5>
                     <div>
                        <p>This scan works similarly to a B-tree range scan.</p>
                        <p>For example, the following table represents three values in the bitmap index for the <code class="codeph">sh.customers.cust_year_of_birth</code> column. If a query requests all customers born before 1917, then the database can scan this index for values lower than <code class="codeph">1917</code>, and then obtain the rowids for rows that have a <code class="codeph">1</code>.
                        </p>
                        <div class="tblformal" id="GUID-B3D5EDB0-CD7B-4FE7-93B6-C348743CE95C__GUID-E7AF2B63-9386-4F3D-9325-726F8A285944">
                           <p class="titleintable">Table 8-6 Bitmap Index Entries</p>
                           <table cellpadding="4" cellspacing="0" class="Formal" title="Bitmap Index Entries" summary="Sample bitmap for bitmap index" width="100%" frame="hsides" border="1" rules="rows">
                              <thead>
                                 <tr align="left" valign="top">
                                    <th align="left" valign="bottom" width="14%" id="d37861e11871">Column Value</th>
                                    <th align="left" valign="bottom" width="14%" id="d37861e11874">Start Rowid in Range</th>
                                    <th align="left" valign="bottom" width="13%" id="d37861e11877">End Rowid in Range</th>
                                    <th align="left" valign="bottom" width="10%" id="d37861e11880">1st Row in Range </th>
                                    <th align="left" valign="bottom" width="10%" id="d37861e11883">2nd Row in Range</th>
                                    <th align="left" valign="bottom" width="10%" id="d37861e11886">3rd Row in Range</th>
                                    <th align="left" valign="bottom" width="10%" id="d37861e11889">4th Row in Range</th>
                                    <th align="left" valign="bottom" width="10%" id="d37861e11892">5th Row in Range</th>
                                    <th align="left" valign="bottom" width="10%" id="d37861e11895">6th Row in Range</th>
                                 </tr>
                              </thead>
                              <tbody>
                                 <tr align="left" valign="top">
                                    <td align="left" valign="top" width="14%" id="d37861e11900" headers="d37861e11871 ">
                                       <p><code class="codeph">1913</code></p>
                                    </td>
                                    <td align="left" valign="top" width="14%" headers="d37861e11900 d37861e11874 ">
                                       <p><code class="codeph">AAA ...</code></p>
                                    </td>
                                    <td align="left" valign="top" width="13%" headers="d37861e11900 d37861e11877 ">
                                       <p><code class="codeph">CCC ...</code></p>
                                    </td>
                                    <td align="left" valign="top" width="10%" headers="d37861e11900 d37861e11880 ">
                                       <p>0</p>
                                    </td>
                                    <td align="left" valign="top" width="10%" headers="d37861e11900 d37861e11883 ">
                                       <p>0</p>
                                    </td>
                                    <td align="left" valign="top" width="10%" headers="d37861e11900 d37861e11886 ">
                                       <p>0</p>
                                    </td>
                                    <td align="left" valign="top" width="10%" headers="d37861e11900 d37861e11889 ">
                                       <p>0</p>
                                    </td>
                                    <td align="left" valign="top" width="10%" headers="d37861e11900 d37861e11892 ">
                                       <p>0</p>
                                    </td>
                                    <td align="left" valign="top" width="10%" headers="d37861e11900 d37861e11895 ">
                                       <p>1</p>
                                    </td>
                                 </tr>
                                 <tr align="left" valign="top">
                                    <td align="left" valign="top" width="14%" id="d37861e11931" headers="d37861e11871 ">
                                       <p><code class="codeph">1917</code></p>
                                    </td>
                                    <td align="left" valign="top" width="14%" headers="d37861e11931 d37861e11874 ">
                                       <p><code class="codeph">AAA ...</code></p>
                                    </td>
                                    <td align="left" valign="top" width="13%" headers="d37861e11931 d37861e11877 ">
                                       <p><code class="codeph">CCC ...</code></p>
                                    </td>
                                    <td align="left" valign="top" width="10%" headers="d37861e11931 d37861e11880 ">
                                       <p>1</p>
                                    </td>
                                    <td align="left" valign="top" width="10%" headers="d37861e11931 d37861e11883 ">
                                       <p>0</p>
                                    </td>
                                    <td align="left" valign="top" width="10%" headers="d37861e11931 d37861e11886 ">
                                       <p>1</p>
                                    </td>
                                    <td align="left" valign="top" width="10%" headers="d37861e11931 d37861e11889 ">
                                       <p>1</p>
                                    </td>
                                    <td align="left" valign="top" width="10%" headers="d37861e11931 d37861e11892 ">
                                       <p>1</p>
                                    </td>
                                    <td align="left" valign="top" width="10%" headers="d37861e11931 d37861e11895 ">
                                       <p>0</p>
                                    </td>
                                 </tr>
                                 <tr align="left" valign="top">
                                    <td align="left" valign="top" width="14%" id="d37861e11962" headers="d37861e11871 ">
                                       <p><code class="codeph">1918</code></p>
                                    </td>
                                    <td align="left" valign="top" width="14%" headers="d37861e11962 d37861e11874 ">
                                       <p><code class="codeph">AAA ...</code></p>
                                    </td>
                                    <td align="left" valign="top" width="13%" headers="d37861e11962 d37861e11877 ">
                                       <p><code class="codeph">CCC ...</code></p>
                                    </td>
                                    <td align="left" valign="top" width="10%" headers="d37861e11962 d37861e11880 ">
                                       <p>0</p>
                                    </td>
                                    <td align="left" valign="top" width="10%" headers="d37861e11962 d37861e11883 ">
                                       <p>1</p>
                                    </td>
                                    <td align="left" valign="top" width="10%" headers="d37861e11962 d37861e11886 ">
                                       <p>0</p>
                                    </td>
                                    <td align="left" valign="top" width="10%" headers="d37861e11962 d37861e11889 ">
                                       <p>0</p>
                                    </td>
                                    <td align="left" valign="top" width="10%" headers="d37861e11962 d37861e11892 ">
                                       <p>0</p>
                                    </td>
                                    <td align="left" valign="top" width="10%" headers="d37861e11962 d37861e11895 ">
                                       <p>0</p>
                                    </td>
                                 </tr>
                                 <tr align="left" valign="top">
                                    <td align="left" valign="top" width="14%" id="d37861e11993" headers="d37861e11871 ">
                                       <p><code class="codeph">1918</code></p>
                                    </td>
                                    <td align="left" valign="top" width="14%" headers="d37861e11993 d37861e11874 ">
                                       <p><code class="codeph">DDD ...</code></p>
                                    </td>
                                    <td align="left" valign="top" width="13%" headers="d37861e11993 d37861e11877 ">
                                       <p><code class="codeph">EEE ...</code></p>
                                    </td>
                                    <td align="left" valign="top" width="10%" headers="d37861e11993 d37861e11880 ">
                                       <p>1</p>
                                    </td>
                                    <td align="left" valign="top" width="10%" headers="d37861e11993 d37861e11883 ">
                                       <p>0</p>
                                    </td>
                                    <td align="left" valign="top" width="10%" headers="d37861e11993 d37861e11886 ">
                                       <p>1</p>
                                    </td>
                                    <td align="left" valign="top" width="10%" headers="d37861e11993 d37861e11889 ">
                                       <p>0</p>
                                    </td>
                                    <td align="left" valign="top" width="10%" headers="d37861e11993 d37861e11892 ">
                                       <p>1</p>
                                    </td>
                                    <td align="left" valign="top" width="10%" headers="d37861e11993 d37861e11895 ">
                                       <p>1</p>
                                    </td>
                                 </tr>
                              </tbody>
                           </table>
                        </div>
                        <!-- class="inftblhruleinformal" -->
                     </div>
                     <div>
                        <div class="infoboxnotealso" id="GUID-B3D5EDB0-CD7B-4FE7-93B6-C348743CE95C__GUID-11E57EB9-3050-483B-81F5-E8F4BF935E24">
                           <p class="notep1">See Also:</p>
                           <p><span class="q">"<a href="optimizer-access-paths.html#GUID-E2353939-DFBD-444A-94BC-2497E2A418D1" title="An index range scan is an ordered scan of values.">Index Range Scans</a>"</span></p>
                        </div>
                        <div class="familylinks">
                           <div class="parentlink">
                              <p><strong>Parent topic:</strong> <a href="optimizer-access-paths.html#GUID-9123D7CE-90DC-4C96-AB4F-49FD0227C40B" title="This type of access path uses a bitmap index to look up a range of values.">Bitmap Index Range Scans</a></p>
                           </div>
                        </div>
                     </div>
                     
                  </div><a id="TGSQL95213"></a><div class="props_rev_3"><a id="GUID-CE4551F6-D694-4C4A-8606-9544278D3867" name="GUID-CE4551F6-D694-4C4A-8606-9544278D3867"></a><h5 id="TGSQL-GUID-CE4551F6-D694-4C4A-8606-9544278D3867" class="sect5"><span class="enumeration_section">8.4.4.3 </span>Bitmap Index Range Scans: Example
                     </h5>
                     <div>
                        <p>This example uses a range scan to select customers born before a single year.</p>
                        <p>A query of the <code class="codeph">sh.customers</code> table selects the names of customers born before 1918:
                        </p><pre class="pre codeblock"><code>SELECT cust_last_name, cust_first_name
FROM   customers
WHERE  cust_year_of_birth &lt; 1918
</code></pre><p>The following plan shows that the database obtains all bitmaps for <code class="codeph">cust_year_of_birth</code> keys lower than <code class="codeph">1918</code> (Step 3), converts the bitmaps to rowids (Step 2), and then fetches the rows (Step 1):
                        </p><pre class="pre codeblock"><code>SQL_ID  672z2h9rawyjg, child number 0
-------------------------------------
SELECT cust_last_name, cust_first_name FROM   customers WHERE
cust_year_of_birth &lt; 1918

Plan hash value: 4198466611
---------------------------------------------------------------------------------------------
|Id| Operation                           | Name              |Rows|Bytes|Cost(%CPU)|Time    |
---------------------------------------------------------------------------------------------
| 0| SELECT STATEMENT                    |                   |    |     |421 (100)|         |
| 1|  TABLE ACCESS BY INDEX ROWID BATCHED| CUSTOMERS         |3604|68476|421   (1)|00:00:01 |
| 2|   BITMAP CONVERSION TO ROWIDS       |                   |    |     |         |         |
|*3|    <span class="bold">BITMAP INDEX RANGE SCAN</span>          | CUSTOMERS_YOB_BIX |    |     |         |         |
---------------------------------------------------------------------------------------------

Predicate Information (identified by operation id):
---------------------------------------------------
   3 - access("CUST_YEAR_OF_BIRTH"&lt;1918)
       filter("CUST_YEAR_OF_BIRTH"&lt;1918)</code></pre></div>
                     <div>
                        <div class="familylinks">
                           <div class="parentlink">
                              <p><strong>Parent topic:</strong> <a href="optimizer-access-paths.html#GUID-9123D7CE-90DC-4C96-AB4F-49FD0227C40B" title="This type of access path uses a bitmap index to look up a range of values.">Bitmap Index Range Scans</a></p>
                           </div>
                        </div>
                     </div>
                     
                  </div>
               </div><a id="TGSQL95214"></a><div class="props_rev_3"><a id="GUID-2FDE5904-B0BC-44DA-829B-94C89FA77D71" name="GUID-2FDE5904-B0BC-44DA-829B-94C89FA77D71"></a><h4 id="TGSQL-GUID-2FDE5904-B0BC-44DA-829B-94C89FA77D71" class="sect4"><span class="enumeration_section">8.4.5 </span>Bitmap Merge
                  </h4>
                  <div>
                     <p>This access path merges multiple bitmaps, and returns a single bitmap as a result.</p>
                     <p>A bitmap merge is indicated by the <code class="codeph">BITMAP MERGE</code> operation in an execution plan.
                     </p>
                     <p>This section contains the following topics:</p>
                  </div>
                  <div>
                     <ul class="ullinks">
                        <li class="ulchildlink"><a href="optimizer-access-paths.html#GUID-BAFC38D5-C3A8-4100-A0E0-E4E0BF0413BA">When the Optimizer Considers Bitmap Merge</a><br>The optimizer typically uses a bitmap merge to combine bitmaps generated from a bitmap index range scan.
                        </li>
                        <li class="ulchildlink"><a href="optimizer-access-paths.html#GUID-2B852AE5-DB31-42F6-A39D-DF058D5A8204">How Bitmap Merge Works</a><br>A merge uses a Boolean <code class="codeph">OR</code> operation between two bitmaps. The resulting bitmap selects all rows from the first bitmap, plus all rows from every subsequent bitmap.
                        </li>
                        <li class="ulchildlink"><a href="optimizer-access-paths.html#GUID-8CB7829F-D612-41D0-9870-1C40DF73C71B">Bitmap Merge: Example</a><br>This example shows how the database merges bitmaps to optimize a query using a range predicate.
                        </li>
                     </ul>
                     <div class="familylinks">
                        <div class="parentlink">
                           <p><strong>Parent topic:</strong> <a href="optimizer-access-paths.html#GUID-B5E41901-933E-4A31-B5D6-9771FD435EC0" title="Bitmap indexes combine the indexed data with a rowid range.">Bitmap Index Access Paths</a></p>
                        </div>
                     </div>
                  </div>
                  <a id="TGSQL95215"></a><div class="props_rev_3"><a id="GUID-BAFC38D5-C3A8-4100-A0E0-E4E0BF0413BA" name="GUID-BAFC38D5-C3A8-4100-A0E0-E4E0BF0413BA"></a><h5 id="TGSQL-GUID-BAFC38D5-C3A8-4100-A0E0-E4E0BF0413BA" class="sect5"><span class="enumeration_section">8.4.5.1 </span>When the Optimizer Considers Bitmap Merge
                     </h5>
                     <div>
                        <p>The optimizer typically uses a bitmap merge to combine bitmaps generated from a bitmap index range scan.</p>
                     </div>
                     <div>
                        <div class="familylinks">
                           <div class="parentlink">
                              <p><strong>Parent topic:</strong> <a href="optimizer-access-paths.html#GUID-2FDE5904-B0BC-44DA-829B-94C89FA77D71" title="This access path merges multiple bitmaps, and returns a single bitmap as a result.">Bitmap Merge</a></p>
                           </div>
                        </div>
                     </div>
                     
                  </div><a id="TGSQL95216"></a><div class="props_rev_3"><a id="GUID-2B852AE5-DB31-42F6-A39D-DF058D5A8204" name="GUID-2B852AE5-DB31-42F6-A39D-DF058D5A8204"></a><h5 id="TGSQL-GUID-2B852AE5-DB31-42F6-A39D-DF058D5A8204" class="sect5"><span class="enumeration_section">8.4.5.2 </span>How Bitmap Merge Works
                     </h5>
                     <div>
                        <p>A merge uses a Boolean <code class="codeph">OR</code> operation between two bitmaps. The resulting bitmap selects all rows from the first bitmap, plus all rows from every subsequent bitmap.
                        </p>
                        <p>A query might select all customers born before 1918. The following example shows sample bitmaps for three <code class="codeph">customers.cust_year_of_birth</code> keys: <code class="codeph">1917</code>, <code class="codeph">1916</code>, and <code class="codeph">1915</code>. If any position in any bitmap has a <code class="codeph">1</code>, then the merged bitmap has a <code class="codeph">1</code> in the same position. Otherwise, the merged bitmap has a <code class="codeph">0</code>.
                        </p><pre class="pre codeblock"><code>1917     1 0 1 0 0 0 0 0 0 0 0 0 0 1
1916     0 1 0 0 0 0 0 0 0 0 0 0 0 0
1915     0 0 0 0 0 0 0 0 1 0 0 0 0 0
------------------------------------
merged:  1 1 1 0 0 0 0 0 1 0 0 0 0 1</code></pre><p>The <code class="codeph">1</code> values in resulting bitmap correspond to rows that contain the values <code class="codeph">1915</code>, <code class="codeph">1916</code>, or <code class="codeph">1917</code>.
                        </p>
                     </div>
                     <div>
                        <div class="familylinks">
                           <div class="parentlink">
                              <p><strong>Parent topic:</strong> <a href="optimizer-access-paths.html#GUID-2FDE5904-B0BC-44DA-829B-94C89FA77D71" title="This access path merges multiple bitmaps, and returns a single bitmap as a result.">Bitmap Merge</a></p>
                           </div>
                        </div>
                     </div>
                     
                  </div><a id="TGSQL95217"></a><div class="props_rev_3"><a id="GUID-8CB7829F-D612-41D0-9870-1C40DF73C71B" name="GUID-8CB7829F-D612-41D0-9870-1C40DF73C71B"></a><h5 id="TGSQL-GUID-8CB7829F-D612-41D0-9870-1C40DF73C71B" class="sect5"><span class="enumeration_section">8.4.5.3 </span>Bitmap Merge: Example
                     </h5>
                     <div>
                        <p>This example shows how the database merges bitmaps to optimize a query using a range predicate.</p>
                        <p>A query of the <code class="codeph">sh.customers</code> table selects the names of female customers born before 1918:
                        </p><pre class="pre codeblock"><code>SELECT cust_last_name, cust_first_name
FROM   customers
WHERE  cust_gender = 'F'
AND    cust_year_of_birth &lt; 1918
</code></pre><p>The following plan shows that the database obtains all bitmaps for <code class="codeph">cust_year_of_birth</code> keys lower than <code class="codeph">1918</code> (Step 6), and then merges these bitmaps using <code class="codeph">OR</code> logic to create a single bitmap (Step 5). The database obtains a single bitmap for the <code class="codeph">cust_gender</code> key of <code class="codeph">F</code> (Step 4), and then performs an <code class="codeph">AND</code> operation on these two bitmaps. The result is a single bitmap that contains <code class="codeph">1</code> values for the requested rows (Step 3).
                        </p><pre class="pre codeblock"><code>SQL_ID  1xf59h179zdg2, child number 0
-------------------------------------
select cust_last_name, cust_first_name from customers where cust_gender
= 'F' and cust_year_of_birth &lt; 1918

Plan hash value: 49820847
---------------------------------------------------------------------------------------------
|Id| Operation                           | Name               |Rows|Bytes|Cost(%CPU)| Time  |
---------------------------------------------------------------------------------------------
| 0| SELECT STATEMENT                    |                    |    |     |288 (100)|        |
| 1|  TABLE ACCESS BY INDEX ROWID BATCHED|CUSTOMERS           |1802|37842|288   (1)|00:00:01|
| 2|   BITMAP CONVERSION TO ROWIDS       |                    |    |     |         |        |
| 3|    BITMAP AND                       |                    |    |     |         |        |
|*4|     BITMAP INDEX SINGLE VALUE       |CUSTOMERS_GENDER_BIX|    |     |         |        |
| 5|     <span class="bold">BITMAP MERGE</span>                    |                    |    |     |         |        |
|*6|      BITMAP INDEX RANGE SCAN        |CUSTOMERS_YOB_BIX   |    |     |         |        |
---------------------------------------------------------------------------------------------

Predicate Information (identified by operation id):
---------------------------------------------------
   4 - access("CUST_GENDER"='F')
   6 - access("CUST_YEAR_OF_BIRTH"&lt;1918)
       filter("CUST_YEAR_OF_BIRTH"&lt;1918)</code></pre></div>
                     <div>
                        <div class="familylinks">
                           <div class="parentlink">
                              <p><strong>Parent topic:</strong> <a href="optimizer-access-paths.html#GUID-2FDE5904-B0BC-44DA-829B-94C89FA77D71" title="This access path merges multiple bitmaps, and returns a single bitmap as a result.">Bitmap Merge</a></p>
                           </div>
                        </div>
                     </div>
                     
                  </div>
               </div>
            </div><a id="TGSQL241"></a><div class="props_rev_3"><a id="GUID-4D114CC6-15A8-4CE0-A826-4E53DFD184CA" name="GUID-4D114CC6-15A8-4CE0-A826-4E53DFD184CA"></a><h3 id="TGSQL-GUID-4D114CC6-15A8-4CE0-A826-4E53DFD184CA" class="sect3"><span class="enumeration_section">8.5 </span>Table Cluster Access Paths
               </h3>
               <div>
                  <p>A <strong class="term">table cluster</strong> is a group of tables that share common columns and store related data in the same blocks. When tables are clustered, a single data block can contain rows from multiple tables.
                  </p>
                  <p>This section contains the following topics:</p>
               </div>
               <div>
                  <ul class="ullinks">
                     <li class="ulchildlink"><a href="optimizer-access-paths.html#GUID-DB9438B3-6FA1-4EE9-A782-3DD271A59285">Cluster Scans</a><br>An <strong class="term">index cluster</strong> is a table cluster that uses an index to locate data. 
                     </li>
                     <li class="ulchildlink"><a href="optimizer-access-paths.html#GUID-8CBC58C9-A82E-4A2A-B2C1-5A728C4F4726">Hash Scans</a><br>A <strong class="term">hash cluster</strong> is like an indexed cluster, except the index key is replaced with a hash function. No separate cluster index exists. 
                     </li>
                  </ul>
                  <div class="infoboxnotealso" id="GUID-4D114CC6-15A8-4CE0-A826-4E53DFD184CA__GUID-F322E91E-7FAB-4F14-BDAC-CC6DBFE3712D">
                     <p class="notep1">See Also:</p>
                     <p><a href="https://www.oracle.com/pls/topic/lookup?ctx=en/database/oracle/oracle-database/19/tgsql&amp;id=CNCPT608" target="_blank"><span><cite>Oracle Database Concepts</cite></span></a> for an overview of table clusters
                     </p>
                  </div>
                  <div class="familylinks">
                     <div class="parentlink">
                        <p><strong>Parent topic:</strong> <a href="optimizer-access-paths.html#GUID-00711237-35D3-4CFC-A234-59B3EC53DCD1" title="An access path is a technique used by a query to retrieve rows from a row source.">Optimizer Access Paths</a></p>
                     </div>
                  </div>
               </div>
               <a id="TGSQL94952"></a><div class="props_rev_3"><a id="GUID-DB9438B3-6FA1-4EE9-A782-3DD271A59285" name="GUID-DB9438B3-6FA1-4EE9-A782-3DD271A59285"></a><h4 id="TGSQL-GUID-DB9438B3-6FA1-4EE9-A782-3DD271A59285" class="sect4"><span class="enumeration_section">8.5.1 </span>Cluster Scans
                  </h4>
                  <div>
                     <p>An <strong class="term">index cluster</strong> is a table cluster that uses an index to locate data. 
                     </p>
                     <p>The cluster index is a B-tree index on the cluster key. A <a href="glossary.html#GUID-301F9394-3C59-4DCB-94F2-3DC2B2E0508A"><span class="xrefglossterm">cluster scan</span></a> retrieves all rows that have the same cluster key value from a table stored in an indexed cluster.
                     </p>
                     <p>This section contains the following topics:</p>
                  </div>
                  <div>
                     <ul class="ullinks">
                        <li class="ulchildlink"><a href="optimizer-access-paths.html#GUID-9B933E68-BBA0-49B7-9AC4-F58868E5180D">When the Optimizer Considers Cluster Scans</a><br>The database considers a cluster scan when a query accesses a table in an indexed cluster.
                        </li>
                        <li class="ulchildlink"><a href="optimizer-access-paths.html#GUID-859E935C-C9B0-43C7-A955-6A943037D533">How a Cluster Scan Works</a><br>In an indexed cluster, the database stores all rows with the same cluster key value in the same data block.
                        </li>
                        <li class="ulchildlink"><a href="optimizer-access-paths.html#GUID-332A32EF-65E6-4BB0-AB2D-4F0EEEE73C85">Cluster Scans: Example</a><br>This example clusters the <code class="codeph">employees</code> and <code class="codeph">departments</code> tables on the <code class="codeph">department_id</code> column, and then queries the cluster for a single department.
                        </li>
                     </ul>
                     <div class="familylinks">
                        <div class="parentlink">
                           <p><strong>Parent topic:</strong> <a href="optimizer-access-paths.html#GUID-4D114CC6-15A8-4CE0-A826-4E53DFD184CA" title="A table cluster is a group of tables that share common columns and store related data in the same blocks. When tables are clustered, a single data block can contain rows from multiple tables.">Table Cluster Access Paths</a></p>
                        </div>
                     </div>
                  </div>
                  <a id="TGSQL95218"></a><div class="props_rev_3"><a id="GUID-9B933E68-BBA0-49B7-9AC4-F58868E5180D" name="GUID-9B933E68-BBA0-49B7-9AC4-F58868E5180D"></a><h5 id="TGSQL-GUID-9B933E68-BBA0-49B7-9AC4-F58868E5180D" class="sect5"><span class="enumeration_section">8.5.1.1 </span>When the Optimizer Considers Cluster Scans
                     </h5>
                     <div>
                        <p>The database considers a cluster scan when a query accesses a table in an indexed cluster.</p>
                     </div>
                     <div>
                        <div class="familylinks">
                           <div class="parentlink">
                              <p><strong>Parent topic:</strong> <a href="optimizer-access-paths.html#GUID-DB9438B3-6FA1-4EE9-A782-3DD271A59285" title="An index cluster is a table cluster that uses an index to locate data.">Cluster Scans</a></p>
                           </div>
                        </div>
                     </div>
                     
                  </div><a id="TGSQL95219"></a><div class="props_rev_3"><a id="GUID-859E935C-C9B0-43C7-A955-6A943037D533" name="GUID-859E935C-C9B0-43C7-A955-6A943037D533"></a><h5 id="TGSQL-GUID-859E935C-C9B0-43C7-A955-6A943037D533" class="sect5"><span class="enumeration_section">8.5.1.2 </span>How a Cluster Scan Works
                     </h5>
                     <div>
                        <p>In an indexed cluster, the database stores all rows with the same cluster key value in the same data block.</p>
                        <p>For example, if the <code class="codeph">hr.employees2</code> and <code class="codeph">hr.departments2</code> tables are clustered in <code class="codeph">emp_dept_cluster</code>, and if the cluster key is <code class="codeph">department_id</code>, then the database stores all employees in department <code class="codeph">10</code> in the same block, all employees in department <code class="codeph">20</code> in the same block, and so on.
                        </p>
                        <p>The B-tree cluster index associates the cluster key value with the database block address (DBA) of the block containing the data. For example, the index entry for key <code class="codeph">30</code> shows the address of the block that contains rows for employees in department <code class="codeph">30</code>:
                        </p><pre class="pre codeblock"><code>30,AADAAAA9d
</code></pre><p>When a user requests rows in the cluster, the database scans the index to obtain the DBAs of the blocks containing the rows. Oracle Database then locates the rows based on these DBAs.</p>
                     </div>
                     <div>
                        <div class="familylinks">
                           <div class="parentlink">
                              <p><strong>Parent topic:</strong> <a href="optimizer-access-paths.html#GUID-DB9438B3-6FA1-4EE9-A782-3DD271A59285" title="An index cluster is a table cluster that uses an index to locate data.">Cluster Scans</a></p>
                           </div>
                        </div>
                     </div>
                     
                  </div><a id="TGSQL95220"></a><div class="props_rev_3"><a id="GUID-332A32EF-65E6-4BB0-AB2D-4F0EEEE73C85" name="GUID-332A32EF-65E6-4BB0-AB2D-4F0EEEE73C85"></a><h5 id="TGSQL-GUID-332A32EF-65E6-4BB0-AB2D-4F0EEEE73C85" class="sect5"><span class="enumeration_section">8.5.1.3 </span>Cluster Scans: Example
                     </h5>
                     <div>
                        <p>This example clusters the <code class="codeph">employees</code> and <code class="codeph">departments</code> tables on the <code class="codeph">department_id</code> column, and then queries the cluster for a single department.
                        </p>
                        <div class="example" id="GUID-332A32EF-65E6-4BB0-AB2D-4F0EEEE73C85__GUID-7E093173-F973-4E5F-8538-DDEA47F8673E">
                           <p>As user <code class="codeph">hr</code>, you create a table cluster, cluster index, and tables in the cluster as follows:
                           </p><pre class="pre codeblock"><code>CREATE CLUSTER employees_departments_cluster
   (department_id NUMBER(4)) SIZE 512;

CREATE INDEX idx_emp_dept_cluster
   ON CLUSTER employees_departments_cluster;

CREATE TABLE employees2
   CLUSTER employees_departments_cluster (department_id)
   AS SELECT * FROM employees;
 CREATE TABLE departments2
   CLUSTER employees_departments_cluster (department_id)
   AS SELECT * FROM departments;
</code></pre><p>You query the employees in department <code class="codeph">30</code> as follows:
                           </p><pre class="pre codeblock"><code>SELECT * 
FROM   employees2 
WHERE  department_id = 30;</code></pre><p>To perform the scan, Oracle Database first obtains the rowid of the row describing department 30 by scanning the cluster index (Step 2). Oracle Database then locates the rows in <code class="codeph">employees2</code> using this rowid (Step 1).
                           </p><pre class="pre codeblock"><code>SQL_ID  b7xk1jzuwdc6t, child number 0
-------------------------------------
SELECT * FROM employees2 WHERE department_id = 30

Plan hash value: 49826199

--------------------------------------------------------------------------------
|Id| Operation            | Name               |Rows|Bytes|Cost(%CPU)| Time    |
--------------------------------------------------------------------------------
| 0| SELECT STATEMENT     |                    |    |     |   2 (100)|         |
| 1|  <span class="bold">TABLE ACCESS CLUSTER</span>| EMPLOYEES2         |  6 | 798 |   2   (0)| 00:00:01|
|*2|   INDEX UNIQUE SCAN  |IDX_EMP_DEPT_CLUSTER|  1 |     |   1   (0)| 00:00:01|
--------------------------------------------------------------------------------

Predicate Information (identified by operation id):
---------------------------------------------------

   2 - access("DEPARTMENT_ID"=30)</code></pre></div>
                        <!-- class="example" -->
                     </div>
                     <div>
                        <div class="infoboxnotealso" id="GUID-332A32EF-65E6-4BB0-AB2D-4F0EEEE73C85__GUID-89394692-C8BA-487E-82F9-601D0ACB0E2E">
                           <p class="notep1">See Also:</p>
                           <p><a href="https://www.oracle.com/pls/topic/lookup?ctx=en/database/oracle/oracle-database/19/tgsql&amp;id=CNCPT-GUID-CC31365B-83B0-4E09-A047-BF1B79AC887A" target="_blank"><span><cite>Oracle Database Concepts</cite></span></a> to learn about indexed clusters
                           </p>
                        </div>
                        <div class="familylinks">
                           <div class="parentlink">
                              <p><strong>Parent topic:</strong> <a href="optimizer-access-paths.html#GUID-DB9438B3-6FA1-4EE9-A782-3DD271A59285" title="An index cluster is a table cluster that uses an index to locate data.">Cluster Scans</a></p>
                           </div>
                        </div>
                     </div>
                     
                  </div>
               </div><a id="TGSQL94953"></a><div class="props_rev_3"><a id="GUID-8CBC58C9-A82E-4A2A-B2C1-5A728C4F4726" name="GUID-8CBC58C9-A82E-4A2A-B2C1-5A728C4F4726"></a><h4 id="TGSQL-GUID-8CBC58C9-A82E-4A2A-B2C1-5A728C4F4726" class="sect4"><span class="enumeration_section">8.5.2 </span>Hash Scans
                  </h4>
                  <div>
                     <p>A <strong class="term">hash cluster</strong> is like an indexed cluster, except the index key is replaced with a hash function. No separate cluster index exists. 
                     </p>
                     <p>In a hash cluster, the data <span class="italic">is</span> the index. The database uses a <a href="glossary.html#GUID-E5F097BA-06BA-403C-B2AE-34523D906F54"><span class="xrefglossterm">hash scan</span></a> to locate rows in a hash cluster based on a hash value.
                     </p>
                     <p>This section contains the following topics:</p>
                  </div>
                  <div>
                     <ul class="ullinks">
                        <li class="ulchildlink"><a href="optimizer-access-paths.html#GUID-FC77D13B-2B4B-49E3-9410-663E74CE447E">When the Optimizer Considers a Hash Scan</a><br>The database considers a hash scan when a query accesses a table in a hash cluster.
                        </li>
                        <li class="ulchildlink"><a href="optimizer-access-paths.html#GUID-02CB3D17-75A4-4371-BB1D-C9921C185365">How a Hash Scan Works</a><br>In a hash cluster, all rows with the same hash value are stored in the same data block.
                        </li>
                        <li class="ulchildlink"><a href="optimizer-access-paths.html#GUID-55B33C65-DE90-4943-9F17-5CC372FF6387">Hash Scans: Example</a><br>This example hashes the <code class="codeph">employees</code> and <code class="codeph">departments</code> tables on the <code class="codeph">department_id</code> column, and then queries the cluster for a single department.
                        </li>
                     </ul>
                     <div class="familylinks">
                        <div class="parentlink">
                           <p><strong>Parent topic:</strong> <a href="optimizer-access-paths.html#GUID-4D114CC6-15A8-4CE0-A826-4E53DFD184CA" title="A table cluster is a group of tables that share common columns and store related data in the same blocks. When tables are clustered, a single data block can contain rows from multiple tables.">Table Cluster Access Paths</a></p>
                        </div>
                     </div>
                  </div>
                  <a id="TGSQL95221"></a><div class="props_rev_3"><a id="GUID-FC77D13B-2B4B-49E3-9410-663E74CE447E" name="GUID-FC77D13B-2B4B-49E3-9410-663E74CE447E"></a><h5 id="TGSQL-GUID-FC77D13B-2B4B-49E3-9410-663E74CE447E" class="sect5"><span class="enumeration_section">8.5.2.1 </span>When the Optimizer Considers a Hash Scan
                     </h5>
                     <div>
                        <p>The database considers a hash scan when a query accesses a table in a hash cluster.</p>
                     </div>
                     <div>
                        <div class="familylinks">
                           <div class="parentlink">
                              <p><strong>Parent topic:</strong> <a href="optimizer-access-paths.html#GUID-8CBC58C9-A82E-4A2A-B2C1-5A728C4F4726" title="A hash cluster is like an indexed cluster, except the index key is replaced with a hash function. No separate cluster index exists.">Hash Scans</a></p>
                           </div>
                        </div>
                     </div>
                     
                  </div><a id="TGSQL95222"></a><div class="props_rev_3"><a id="GUID-02CB3D17-75A4-4371-BB1D-C9921C185365" name="GUID-02CB3D17-75A4-4371-BB1D-C9921C185365"></a><h5 id="TGSQL-GUID-02CB3D17-75A4-4371-BB1D-C9921C185365" class="sect5"><span class="enumeration_section">8.5.2.2 </span>How a Hash Scan Works
                     </h5>
                     <div>
                        <p>In a hash cluster, all rows with the same hash value are stored in the same data block.</p>
                        <p>To perform a hash scan of the cluster, Oracle Database first obtains the hash value by applying a hash function to a cluster key value specified by the statement. Oracle Database then scans the data blocks containing rows with this hash value.</p>
                     </div>
                     <div>
                        <div class="familylinks">
                           <div class="parentlink">
                              <p><strong>Parent topic:</strong> <a href="optimizer-access-paths.html#GUID-8CBC58C9-A82E-4A2A-B2C1-5A728C4F4726" title="A hash cluster is like an indexed cluster, except the index key is replaced with a hash function. No separate cluster index exists.">Hash Scans</a></p>
                           </div>
                        </div>
                     </div>
                     
                  </div><a id="TGSQL95223"></a><div class="props_rev_3"><a id="GUID-55B33C65-DE90-4943-9F17-5CC372FF6387" name="GUID-55B33C65-DE90-4943-9F17-5CC372FF6387"></a><h5 id="TGSQL-GUID-55B33C65-DE90-4943-9F17-5CC372FF6387" class="sect5"><span class="enumeration_section">8.5.2.3 </span>Hash Scans: Example
                     </h5>
                     <div>
                        <p>This example hashes the <code class="codeph">employees</code> and <code class="codeph">departments</code> tables on the <code class="codeph">department_id</code> column, and then queries the cluster for a single department.
                        </p>
                        <div class="example" id="GUID-55B33C65-DE90-4943-9F17-5CC372FF6387__GUID-9B480918-3DC5-40DD-88AF-88AEC39C554A">
                           <p>You create a hash cluster and tables in the cluster as follows:</p><pre class="pre codeblock"><code>CREATE CLUSTER employees_departments_cluster
   (department_id NUMBER(4)) SIZE 8192 HASHKEYS 100;
 
CREATE TABLE employees2
   CLUSTER employees_departments_cluster (department_id) 
   AS SELECT * FROM employees;
 
CREATE TABLE departments2 
   CLUSTER employees_departments_cluster (department_id) 
   AS SELECT * FROM departments;
</code></pre><p>You query the employees in department <code class="codeph">30</code> as follows:
                           </p><pre class="pre codeblock"><code>SELECT *
FROM   employees2
WHERE  department_id = 30
</code></pre><p>To perform a hash scan, Oracle Database first obtains the hash value by applying a hash function to the key value <code class="codeph">30</code>, and then uses this hash value to scan the data blocks and retrieve the rows (Step 1).
                           </p><pre class="pre codeblock"><code>SQL_ID  919x7hyyxr6p4, child number 0
-------------------------------------
SELECT * FROM employees2 WHERE department_id = 30

Plan hash value: 2399378016

----------------------------------------------------------------
| Id  | Operation         | Name       | Rows  | Bytes | Cost  |
----------------------------------------------------------------
|   0 | SELECT STATEMENT  |            |       |       |     1 |
|*  1 |  <span class="bold">TABLE ACCESS HASH</span>| EMPLOYEES2 |    10 |  1330 |       |
----------------------------------------------------------------

Predicate Information (identified by operation id):
---------------------------------------------------

   1 - access("DEPARTMENT_ID"=30)</code></pre></div>
                        <!-- class="example" -->
                     </div>
                     <div>
                        <div class="infoboxnotealso" id="GUID-55B33C65-DE90-4943-9F17-5CC372FF6387__GUID-65718A84-FFAE-4F21-904A-296D78454964">
                           <p class="notep1">See Also:</p>
                           <p><a href="https://www.oracle.com/pls/topic/lookup?ctx=en/database/oracle/oracle-database/19/tgsql&amp;id=CNCPT609" target="_blank"><span><cite>Oracle Database Concepts</cite></span></a> to learn about hash clusters
                           </p>
                        </div>
                        <div class="familylinks">
                           <div class="parentlink">
                              <p><strong>Parent topic:</strong> <a href="optimizer-access-paths.html#GUID-8CBC58C9-A82E-4A2A-B2C1-5A728C4F4726" title="A hash cluster is like an indexed cluster, except the index key is replaced with a hash function. No separate cluster index exists.">Hash Scans</a></p>
                           </div>
                        </div>
                     </div>
                     
                  </div>
               </div>
            </div>
         </div>
      </article>
   </body>
</html>