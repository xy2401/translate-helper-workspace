<html lang="en-us" dir="ltr" xml:lang="en-us">
   <head>
      <meta http-equiv="Content-Type" content="text/html; charset=utf-8"></meta>
      <meta name="viewport" content="width=device-width, initial-scale=1"></meta>
      <meta http-equiv="X-UA-Compatible" content="IE=edge"></meta>
      <title>使用C ++访问Oracle数据库</title>
      <meta property="og:site_name" content="Oracle Help Center"></meta>
      <meta property="og:title" content="Programmer&#39;s Guide "></meta>
      <meta property="og:description" content=""></meta>
      <link rel="stylesheet" href="/sp_common/book-template/ohc-book-template/css/book.css"></link>
      <link rel="shortcut icon" href="/sp_common/book-template/ohc-common/img/favicon.ico"></link>
      <meta name="application-name" content="Programmer&#39;s Guide"></meta>
      <meta name="generator" content="DITA Open Toolkit version 1.8.5 (Mode = doc)"></meta>
      <meta name="plugin" content="SP_docbuilder HTML plugin release 18.2.2"></meta>
      <link rel="alternate" href="oracle-c-call-interface-programmers-guide.pdf" title="PDF File" type="application/pdf"></link>
      <meta name="robots" content="all"></meta>
      <link rel="schema.dcterms" href="http://purl.org/dc/terms/"></link>
      <meta name="dcterms.created" content="2019-03-06T02:31:59-08:00"></meta>
      
      <meta name="dcterms.dateCopyrighted" content="1999, 2019"></meta>
      <meta name="dcterms.category" content="database"></meta>
      <meta name="dcterms.identifier" content="E96205-02"></meta>
      
      <meta name="dcterms.product" content="en/database/oracle/oracle-database/19"></meta>
      
      <link rel="prev" href="installation-and-upgrading.html" title="Previous" type="text/html"></link>
      <link rel="next" href="object-programming.html" title="Next" type="text/html"></link>
      <script>
        document.write('<style type="text/css">');
        document.write('body > .noscript, body > .noscript ~ * { visibility: hidden; }');
        document.write('</style>');
     </script>
      <script src="/sp_common/book-template/requirejs/require.js" data-main="/sp_common/book-template/ohc-book-template/js/book-config"></script>
      <script>
            if (window.require === undefined) {
                document.write('<script data-main="sp_common/book-template/ohc-book-template/js/book-config" src="sp_common/book-template/requirejs/require.js"><\/script>');
                document.write('<link href="sp_common/book-template/ohc-book-template/css/book.css" rel="stylesheet"/>');
            }
        </script>
      <script type="application/json" id="ssot-metadata">{"primary":{"category":{"short_name":"database","element_name":"Database","display_in_url":true},"suite":{"short_name":"oracle","element_name":"Oracle","display_in_url":true},"product_group":{"short_name":"not-applicable","element_name":"Not applicable","display_in_url":false},"product":{"short_name":"oracle-database","element_name":"Oracle Database","display_in_url":true},"release":{"short_name":"19","element_name":"Release 19","display_in_url":true}}}</script>
      
    <meta name="dcterms.title" content="Oracle C++ Call Interface Programmer&#39;s Guide"></meta>
    <meta name="dcterms.isVersionOf" content="LNCPP"></meta>
    <meta name="dcterms.release" content="Release 19"></meta>
  </head>
   <body dir="ltr">
      <div class="noscript alert alert-danger text-center" role="alert">
         <a href="installation-and-upgrading.html" class="pull-left"><span class="glyphicon glyphicon-chevron-left" aria-hidden="true"></span>上一页</a> <a href="object-programming.html" class="pull-right">下一页<span class="glyphicon glyphicon-chevron-right" aria-hidden="true"></span></a> <span class="fa fa-exclamation-triangle" aria-hidden="true"></span>必须启用JavaScript才能正确显示此内容</div>
      <article>
         <header>
            <ol class="breadcrumb" vocab="http://schema.org/" typeof="BreadcrumbList">
               <li property="itemListElement" typeof="ListItem"><a href="index.html" property="item" typeof="WebPage"><span property="name">程序员指南</span></a></li>
               <li class="active" property="itemListElement" typeof="ListItem">使用C ++访问Oracle数据库</li>
            </ol>
            <a id="GUID-3BE057FD-2205-4009-9710-FFDC601F438B" name="GUID-3BE057FD-2205-4009-9710-FFDC601F438B"></a><a id="LNCPP003"></a>
            
            <h2 id="LNCPP-GUID-3BE057FD-2205-4009-9710-FFDC601F438B" class="sect2"><span class="enumeration_chapter">3</span>使用C ++访问Oracle数据库</h2>
         </header>
         <div class="ind">
            <div>
               <p>本章介绍使用Oracle C ++调用接口（OCCI）开发C ++应用程序以处理存储在关系数据库中的数据的基础知识。</p>
               <p>本章包含以下主题：</p>
               <ul style="list-style-type:disc">
                  <li>
                     <p><a href="accessing-oracle-database-using-cplusplus.html#GUID-465F8EBD-89FD-48B7-94D2-33B186C7CE0D">关于连接到数据库</a></p>
                  </li>
                  <li>
                     <p><a href="accessing-oracle-database-using-cplusplus.html#GUID-753C36CE-E6A0-4F0D-B85E-C253EB916C8D">关于池连接</a></p>
                  </li>
                  <li>
                     <p><a href="accessing-oracle-database-using-cplusplus.html#GUID-7B55181E-FC07-4E3D-B91C-25E4288D4B7B">关于执行SQL DDL和DML语句</a></p>
                  </li>
                  <li>
                     <p><a href="accessing-oracle-database-using-cplusplus.html#GUID-5FCD0807-65BA-4490-B8F2-E14B24F90D06">关于OCCI环境中的SQL语句类型</a></p>
                  </li>
                  <li>
                     <p><a href="accessing-oracle-database-using-cplusplus.html#GUID-DC29C08B-E6F6-405D-8B4D-2E4E9D50E196">关于执行SQL查询</a></p>
                  </li>
                  <li>
                     <p><a href="accessing-oracle-database-using-cplusplus.html#GUID-62119016-0948-4EB3-A7E1-402C2572B5ED">关于动态执行语句</a></p>
                  </li>
                  <li>
                     <p><a href="accessing-oracle-database-using-cplusplus.html#GUID-BCA292AC-120C-437E-ADC7-B880CBB6351F">关于使用较大的行数和错误代码范围数据类型</a></p>
                  </li>
                  <li>
                     <p><a href="accessing-oracle-database-using-cplusplus.html#GUID-C8520AA3-6F82-4F91-BDA5-829F2A6A799D">关于提交交易</a></p>
                  </li>
                  <li>
                     <p><a href="accessing-oracle-database-using-cplusplus.html#GUID-4F6F6E83-B68E-42C0-92CE-1A2DBB95C0D8">缓存语句</a></p>
                  </li>
                  <li>
                     <p><a href="accessing-oracle-database-using-cplusplus.html#GUID-92553E64-8CDF-42EA-B74B-0277C009E4C2">关于处理异常</a></p>
                  </li>
               </ul>
            </div><a id="LNCPP0031"></a><div class="props_rev_3"><a id="GUID-465F8EBD-89FD-48B7-94D2-33B186C7CE0D" name="GUID-465F8EBD-89FD-48B7-94D2-33B186C7CE0D"></a><h3 id="LNCPP-GUID-465F8EBD-89FD-48B7-94D2-33B186C7CE0D" class="sect3"><span class="enumeration_section">3.1</span>关于连接数据库</h3>
               <div>
                  <p>应用程序如何连接到数据库有几种不同的选项。</p>
                  <div class="p">本节包括以下主题：<ul style="list-style-type:disc">
                        <li>
                           <p><a href="accessing-oracle-database-using-cplusplus.html#GUID-1ADC00D1-514D-45F9-9544-A76D1DAD4926">创建和终止环境</a></p>
                        </li>
                        <li>
                           <p><a href="accessing-oracle-database-using-cplusplus.html#GUID-9BB9D062-473B-40FD-A416-A41C6DDBCD21">打开和关闭连接</a></p>
                        </li>
                        <li>
                           <p><a href="accessing-oracle-database-using-cplusplus.html#GUID-7356DB72-558F-40BD-98D8-1A08D21FB792">关于可插拔数据库的支持</a></p>
                        </li>
                     </ul>
                  </div>
               </div><a id="LNCPP20105"></a><a id="LNCPP20106"></a><a id="LNCPP20107"></a><a id="LNCPP00311"></a><div class="props_rev_3"><a id="GUID-1ADC00D1-514D-45F9-9544-A76D1DAD4926" name="GUID-1ADC00D1-514D-45F9-9544-A76D1DAD4926"></a><h4 id="LNCPP-GUID-1ADC00D1-514D-45F9-9544-A76D1DAD4926" class="sect4"><span class="enumeration_section">3.1.1</span>创建和终止环境</h4>
                  <div>
                     <div class="section">
                        <p>所有OCCI处理都在<code class="codeph">Environment</code>类中进行。OCCI环境提供应用程序模式和用户指定的内存管理功能。<a href="accessing-oracle-database-using-cplusplus.html#GUID-1ADC00D1-514D-45F9-9544-A76D1DAD4926__CHDGHBEF">示例3-1</a>说明了如何创建OCCI环境。
                        </p>
                        <p>必须显式终止使用<code class="codeph">create</code> <span class="italic"><code class="codeph">xxx</code></span> <code class="codeph">()</code>方法（连接，连接池，语句）创建的所有OCCI对象。适当时，还必须明确终止环境。<a href="accessing-oracle-database-using-cplusplus.html#GUID-1ADC00D1-514D-45F9-9544-A76D1DAD4926__CHDJFFII">例3-2</a>显示了如何终止OCCI环境。
                        </p>
                        <p>此外，OCCI环境的范围应大于在该环境中创建的以下对象类型的范围： <code class="codeph">Agent</code> ， <code class="codeph">Bytes</code> ， <code class="codeph">Date</code> ， <code class="codeph">Message</code> ， <code class="codeph">IntervalDS</code> ， <code class="codeph">IntervalYM</code> ， <code class="codeph">Subscription</code>和<code class="codeph">Timestamp</code> 。此规则不适用于<code class="codeph">BFile</code> ， <code class="codeph">Blob</code>和<code class="codeph">Clob</code>对象，如<a href="accessing-oracle-database-using-cplusplus.html#GUID-1ADC00D1-514D-45F9-9544-A76D1DAD4926__CHDJJEHF">示例3-3所示</a> 。
                        </p>
                        <p>如果应用程序需要访问全局范围内的对象（例如静态变量或全局变量），则必须在终止环境之前将这些对象设置为<code class="codeph">NULL</code> 。在前面的示例中，如果<code class="codeph">b</code>是全局变量，则必须在<code class="codeph">terminateEnvironment()</code>调用之前进行<code class="codeph">b.setNull()</code> <code class="codeph">terminateEnvironment()</code>调用。
                        </p>
                        <p>你可以使用<a id="d12382e367" class="indexterm-anchor"></a><a id="d12382e371" class="indexterm-anchor"></a> <code class="codeph">createEnvironment()</code>方法的mode参数，用于指定您的应用程序：</p>
                     </div>
                     <!-- class="section" -->
                     <div class="section">
                        <ul style="list-style-type:disc">
                           <li>
                              <p>在线程环境中运行（ <code class="codeph">THREADED_MUTEXED</code>或<code class="codeph">THREADED_UNMUTEXED</code> ）</p>
                           </li>
                           <li>
                              <p>使用对象（ <code class="codeph">OBJECT</code> ）</p>
                           </li>
                        </ul>
                        <p>可以在每个环境中独立设置模式。</p>
                     </div>
                     <!-- class="section" -->
                     <div class="example" id="GUID-1ADC00D1-514D-45F9-9544-A76D1DAD4926__CHDGHBEF">
                        <p class="titleinexample">示例3-1如何创建OCCI环境</p><pre class="oac_no_warn" dir="ltr">Environment * env = Environment :: createEnvironment（）;</pre></div>
                     <!-- class="example" -->
                     <div class="example" id="GUID-1ADC00D1-514D-45F9-9544-A76D1DAD4926__CHDJFFII">
                        <p class="titleinexample">示例3-2如何终止OCCI环境</p><pre class="oac_no_warn" dir="ltr">环境:: terminateEnvironment（ENV）;</pre></div>
                     <!-- class="example" -->
                     <div class="example" id="GUID-1ADC00D1-514D-45F9-9544-A76D1DAD4926__CHDJJEHF">
                        <p class="titleinexample">示例3-3如何使用Blob对象使用环境范围</p><pre class="oac_no_warn" dir="ltr">常量<a id="d12382e413" class="indexterm-anchor"></a> string userName =“HR”; const string password =“ <span class="italic">password</span> ”; const string connectString =“”; Environment * env = Environment :: createEnvironment（）; {Connection * conn = env-&gt; createConnection（userName，password，connectString）; Statement * stmt = conn-&gt; createStatement（“SELECT blobcol FROM mytable”）; ResultSet * rs = stmt-&gt; executeQuery（）; RS-&gt;下（）; Blob b = rs-&gt; getBlob（1）; cout &lt;&lt;“BLOB的长度：”&lt;&lt; b.length（）; ...stmt-&gt; closeResultSet（RS）; conn-&gt; terminateStatement（语句）; env-&gt; terminateConnection（conn）;在} Environment :: terminateEnvironment（env）;</pre></div>
                     <!-- class="example" -->
                  </div>
               </div><a id="LNCPP20108"></a><a id="LNCPP20109"></a><a id="LNCPP00312"></a><div class="props_rev_3"><a id="GUID-9BB9D062-473B-40FD-A416-A41C6DDBCD21" name="GUID-9BB9D062-473B-40FD-A416-A41C6DDBCD21"></a><h4 id="LNCPP-GUID-9BB9D062-473B-40FD-A416-A41C6DDBCD21" class="sect4"><span class="enumeration_section">3.1.2</span>打开和关闭连接</h4>
                  <div>
                     <div class="section">
                        <p><code class="codeph">Environment</code>类是用于创建<code class="codeph">Connection</code>对象的工厂类。首先创建一个<code class="codeph">Environment</code>实例，然后使用它来使用户能够通过<code class="codeph">createConnection()</code>方法连接到数据库。
                        </p>
                        <p><a href="accessing-oracle-database-using-cplusplus.html#GUID-9BB9D062-473B-40FD-A416-A41C6DDBCD21__CHDIAIEJ">示例3-4</a>创建一个环境实例，然后使用它为具有适当密码的数据库用户<code class="codeph">HR</code>创建数据库连接。
                        </p>
                        <p>必须使用以下代码示例中显示的<code class="codeph">terminateConnection()</code>方法在工作会话结束时显式关闭连接。此外，应明确终止OCCI环境。
                        </p>
                        <p>您应该记住，在<code class="codeph">Connection</code>实例中创建或命名的所有对象（ <code class="codeph">Ref</code> s， <code class="codeph">Bfile</code> ， <code class="codeph">Producer</code> ， <code class="codeph">Consumer</code> s等）必须在该实例的内部范围内;必须在<code class="codeph">Connection</code>终止之前显式终止这些对象的范围。<a href="accessing-oracle-database-using-cplusplus.html#GUID-9BB9D062-473B-40FD-A416-A41C6DDBCD21__CHDDCJEG">示例3-5</a>演示了如何终止连接和环境。
                        </p>
                     </div>
                     <!-- class="section" -->
                     <div class="example" id="GUID-9BB9D062-473B-40FD-A416-A41C6DDBCD21__CHDIAIEJ">
                        <p class="titleinexample">示例3-4如何创建环境然后连接到数据库</p><pre class="oac_no_warn" dir="ltr">环境* env = Env ironment :: createEnvironment（）; Connecti on * conn = env-&gt; createConnection（“HR”，“ <span class="italic">password</span> ”）;</pre></div>
                     <!-- class="example" -->
                     <div class="example" id="GUID-9BB9D062-473B-40FD-A416-A41C6DDBCD21__CHDDCJEG">
                        <p class="titleinexample">示例3-5如何终止与数据库和环境的连接</p><pre class="oac_no_warn" dir="ltr">env-&gt; terminate Connection（conn）; Env ironment :: terminateEnvironment（env）;</pre></div>
                     <!-- class="example" -->
                  </div>
               </div>
               <div class="props_rev_3"><a id="GUID-7356DB72-558F-40BD-98D8-1A08D21FB792" name="GUID-7356DB72-558F-40BD-98D8-1A08D21FB792"></a><h4 id="LNCPP-GUID-7356DB72-558F-40BD-98D8-1A08D21FB792" class="sect4"><span class="enumeration_section">3.1.3</span>关于可插拔数据库的支持</h4>
                  <div>
                     <p>多租户架构使Oracle数据库能够包含一个可移植的模式，模式对象和非复制对象集合，这些对象在Oracle客户端中显示为单独的数据库。多租户容器数据库（CDB）是包含一个或多个可插拔数据库（PDB）的Oracle数据库。</p>
                     <p>OCCI客户端可以使用已将可插拔数据库属性设置为相关PDB的服务连接到PDB。</p>
                     <div class="infoboxnote" id="GUID-7356DB72-558F-40BD-98D8-1A08D21FB792__GUID-0E02B107-3070-4D21-AC0E-906D1957CBC3">
                        <p class="notep1">看到：</p>
                        <p>有关PDB的详细信息以及有关配置连接到各种PDB的服务的更多详细信息，请参见<a href="https://www.oracle.com/pls/topic/lookup?ctx=en/database/oracle/oracle-database/19/lncpp&amp;id=ADMIN13974" target="_blank"><span><cite>“Oracle数据库管理员指南”</cite></span></a></p>
                     </div>
                     <div class="infoboxnote" id="GUID-7356DB72-558F-40BD-98D8-1A08D21FB792__GUID-93379121-0D0D-42D7-8935-A6E175F89E3B">
                        <p class="notep1">看到：</p>
                        <p><a href="../lnoci/index.html" target="_blank"><span><cite>Oracle Call Interface Programmer's Guide</cite></span></a> ，了解有关使用PDB时的限制的信息</p>
                     </div>
                  </div>
               </div>
            </div><a id="LNCPP0032"></a><div class="props_rev_3"><a id="GUID-753C36CE-E6A0-4F0D-B85E-C253EB916C8D" name="GUID-753C36CE-E6A0-4F0D-B85E-C253EB916C8D"></a><h3 id="LNCPP-GUID-753C36CE-E6A0-4F0D-B85E-C253EB916C8D" class="sect3"><span class="enumeration_section">3.2</span>关于池连接</h3>
               <div>
                  <p>本节讨论如何使用OCCI的连接池功能。涵盖的信息包括以下主题：</p>
                  <ul style="list-style-type:disc">
                     <li>
                        <p><a href="accessing-oracle-database-using-cplusplus.html#GUID-DA56C76B-148B-438C-9987-3969FD727B07">关于使用连接池</a></p>
                     </li>
                     <li>
                        <p><a href="accessing-oracle-database-using-cplusplus.html#GUID-3F1B3810-8FE3-46EB-92D0-49C077B92261">使用无状态连接池</a></p>
                     </li>
                  </ul>
                  <p>两者之间的主要区别在于<code class="codeph">StatelessConnectionPool</code>用于不依赖于状态考虑的应用程序;这些应用程序可以通过使用预先认证的连接获得性能改进。
                  </p>
               </div><a id="LNCPP00321"></a><div class="props_rev_3"><a id="GUID-DA56C76B-148B-438C-9987-3969FD727B07" name="GUID-DA56C76B-148B-438C-9987-3969FD727B07"></a><h4 id="LNCPP-GUID-DA56C76B-148B-438C-9987-3969FD727B07" class="sect4"><span class="enumeration_section">3.2.1</span>关于使用连接池</h4>
                  <div>
                     <p>对于许多中间层应用程序，应为大量线程启用与数据库的连接。因为每个线程存在的时间相对较短，所以为每个线程打开与数据库的连接将是低效的连接使用，并且会导致性能低下。</p>
                     <p>通过使用<span class="bold">连接池</span>功能，您的应用程序可以创建一小组可用于大量线程的连接，从而使您可以非常有效地使用数据库资源。
                     </p>
                     <div class="p">本节包括以下主题：<ul style="list-style-type:disc">
                           <li>
                              <p><a href="accessing-oracle-database-using-cplusplus.html#GUID-899EABA2-7C2D-4110-82B7-B9DC5431EFE0">创建连接池</a></p>
                           </li>
                           <li>
                              <p><a href="accessing-oracle-database-using-cplusplus.html#GUID-41067AB9-4C0B-4A53-BC31-5AB0101BB9D1">创建代理连接</a></p>
                           </li>
                        </ul>
                     </div>
                  </div><a id="LNCPP20110"></a><a id="LNCPP20111"></a><a id="LNCPP03211"></a><div class="props_rev_3"><a id="GUID-899EABA2-7C2D-4110-82B7-B9DC5431EFE0" name="GUID-899EABA2-7C2D-4110-82B7-B9DC5431EFE0"></a><h5 id="LNCPP-GUID-899EABA2-7C2D-4110-82B7-B9DC5431EFE0" class="sect5"><span class="enumeration_section">3.2.1.1</span>创建连接池</h5>
                     <div>
                        <div class="section">
                           <p>要创建连接池，请使用<a href="environment-class.html#GUID-8F76AF49-C633-47AA-AE17-0859D4239B74">createConnectionPool（）</a>方法，如<a href="accessing-oracle-database-using-cplusplus.html#GUID-899EABA2-7C2D-4110-82B7-B9DC5431EFE0__CHDHIHFG">例3-6所示</a> 。
                           </p>
                           <p><a href="accessing-oracle-database-using-cplusplus.html#GUID-899EABA2-7C2D-4110-82B7-B9DC5431EFE0__CHDHIHFG">例3-6</a>中使用了以下参数：</p>
                        </div>
                        <!-- class="section" -->
                        <div class="section">
                           <ul style="list-style-type:disc">
                              <li>
                                 <p><code class="codeph">poolUserName</code> ：连接池的所有者</p>
                              </li>
                              <li>
                                 <p><code class="codeph">poolPassword</code> ：访问连接池的密码</p>
                              </li>
                              <li>
                                 <p><code class="codeph">connectString</code> ：指定连接池所关联的数据库服务器的数据库名称</p>
                              </li>
                              <li>
                                 <p><code class="codeph">minConn</code> ：创建连接池时要打开的最小连接数</p>
                              </li>
                              <li>
                                 <p><code class="codeph">maxConn</code> ：连接池可以维护的最大连接数。当连接池中的最大连接数已打开且所有连接都忙时，除非在连接池上调用<code class="codeph">setErrorOnBusy()</code> ，否则需要连接的OCCI方法调用将等待直至获得连接</p>
                              </li>
                              <li>
                                 <p><code class="codeph">incrConn</code> ：当所有连接都忙且呼叫需要连接时要打开的额外连接数。仅当打开的连接总数小于可在该连接池中打开的最大连接数时，才会实施此增量。
                                 </p>
                              </li>
                           </ul>
                           <p><a href="accessing-oracle-database-using-cplusplus.html#GUID-899EABA2-7C2D-4110-82B7-B9DC5431EFE0__CHDIHAEH">示例3-7</a>演示了如何创建连接池。
                           </p>
                           <p>您还可以动态配置所有这些属性。这使您可以设计一个具有读取当前负载（打开的连接数和繁忙连接数）的灵活性的应用程序，并适当地调整这些属性。此外，您可以使用<code class="codeph">setTimeOut()</code>方法将超出指定时间的空闲连接超时。OCCI定期终止空闲连接以保持最佳数量的开放连接。
                           </p>
                           <p>一个环境必须只有一个连接池没有限制。在单个OCCI环境中可以有多个连接池，这些连接池可以连接到相同或不同的数据库。这对需要负载平衡的应用程序很有用。</p>
                        </div>
                        <!-- class="section" -->
                        <div class="example" id="GUID-899EABA2-7C2D-4110-82B7-B9DC5431EFE0__CHDHIHFG">
                           <p class="titleinexample">示例3-6 createConnectionPool（）方法</p><pre class="oac_no_warn" dir="ltr">虚拟ConnectionPool * createConnectionPool（const string＆poolUserName，const string＆poolPassword，const string＆connectString =“”，unsigned int minConn = 0，unsigned int maxConn = 1，unsigned int incrConn = 1）= 0;</pre></div>
                        <!-- class="example" -->
                        <div class="example" id="GUID-899EABA2-7C2D-4110-82B7-B9DC5431EFE0__CHDIHAEH">
                           <p class="titleinexample">示例3-7如何创建连接池</p><pre class="oac_no_warn" dir="ltr">const string connectString =“”; unsigned int maxConn = 5; unsigned int minConn = 3; unsigned int incrConn = 2; ConnectionPool * connPool = env-&gt; createConnectionPool（poolUserName，poolPassword，connectString，minConn，maxConn，incrConn）;</pre></div>
                        <!-- class="example" -->
                     </div>
                  </div><a id="LNCPP20112"></a><a id="LNCPP03212"></a><div class="props_rev_3"><a id="GUID-41067AB9-4C0B-4A53-BC31-5AB0101BB9D1" name="GUID-41067AB9-4C0B-4A53-BC31-5AB0101BB9D1"></a><h5 id="LNCPP-GUID-41067AB9-4C0B-4A53-BC31-5AB0101BB9D1" class="sect5"><span class="enumeration_section">3.2.1.2</span>创建代理连接</h5>
                     <div>
                        <div class="section">
                           <p>如果您授权连接池用户充当其他连接的代理，则无需密码即可登录在连接池中使用连接的数据库用户。</p>
                           <p>可以使用以下两个版本的<a href="connectionpool-class.html#GUID-4B59CF6F-4184-4B20-A675-32B9351B51B1">createProxyConnection（）</a>方法创建代理连接，如<a href="accessing-oracle-database-using-cplusplus.html#GUID-41067AB9-4C0B-4A53-BC31-5AB0101BB9D1__CHDGAHDH">示例3-8所示</a> 。
                           </p>
                           <p>要么</p><pre class="oac_no_warn" dir="ltr">ConnectionPool-&gt; createProxyConnection（const string＆username，string roles []，int numRoles，Connection :: ProxyType proxyType = Connection :: PROXY_DEFAULT）;</pre><p>以前的方法示例中使用以下参数：</p>
                        </div>
                        <!-- class="section" -->
                        <div class="section">
                           <ul style="list-style-type:disc">
                              <li>
                                 <p><code class="codeph">roles[]</code> ：roles数组指定在为客户端激活代理连接后要激活的角色列表</p>
                              </li>
                              <li>
                                 <p><code class="codeph">Connection::ProxyType proxyType = Connection::PROXY_DEFAULT</code> ：枚举<code class="codeph">Connection::ProxyType</code>列出了表示实现代理身份验证的各种方法的常量。<code class="codeph">PROXY_DEFAULT</code>用于指示<code class="codeph">name</code>表示数据库用户名，是当前支持的唯一代理身份验证模式。
                                 </p>
                              </li>
                           </ul>
                        </div>
                        <!-- class="section" -->
                        <div class="example" id="GUID-41067AB9-4C0B-4A53-BC31-5AB0101BB9D1__CHDGAHDH">
                           <p class="titleinexample">示例3-8 createProxyConnection（）方法</p><pre class="oac_no_warn" dir="ltr">ConnectionPool-&gt; createProxyConnection（const string＆username，Connection :: ProxyType proxyType = Connection :: PROXY_DEFAULT）;</pre></div>
                        <!-- class="example" -->
                     </div>
                  </div>
               </div><a id="LNCPP20113"></a><a id="LNCPP20114"></a><a id="LNCPP20115"></a><a id="LNCPP03222"></a><div class="props_rev_2"><a id="GUID-3F1B3810-8FE3-46EB-92D0-49C077B92261" name="GUID-3F1B3810-8FE3-46EB-92D0-49C077B92261"></a><h4 id="LNCPP-GUID-3F1B3810-8FE3-46EB-92D0-49C077B92261" class="sect4"><span class="enumeration_section">3.2.2</span>使用无状态连接池</h4>
                  <div>
                     <div class="section">
                        <p>无状态连接池专门设计用于需要短连接时间且不处理状态注意事项的应用程序。无状态连接池的主要优点是提高了性能，因为消除了耗时的连接和身份验证协议。</p>
                        <p>无状态连接池创建并维护一组可由多个线程使用的无状态，经过身份验证的数据库连接。一旦线程使用其连接完成，它应该将连接释放回池。如果没有可用的连接，则生成新的连接。因此，池中的连接数可以动态增加。</p>
                        <p>池中的某些连接可能会使用特定属性进行标记。用户可以请求默认连接，设置某些属性，例如全球化支持设置，然后标记它并将其返回到池中。当需要具有相同属性的连接时，可以对具有相同标记的连接进行请求，并且可以重用具有相同标记的池中的多个连接之一。可以更改或重置连接上的标记。</p>
                        <p>还可以通过Stateless Connection Pooling接口创建和维护代理连接。</p>
                        <p>无状态连接池通过多路复用连接来提高中间层应用程序的可伸缩性。但是，来自<code class="codeph">StatelessConnectionPool</code>连接不应用于长事务，因为长时间保持连接会导致并发性降低。
                        </p>
                        <div class="infoboxnote" id="GUID-3F1B3810-8FE3-46EB-92D0-49C077B92261__GUID-CCE9501A-97C6-43EF-8D0C-C71059D846DC">
                           <p class="notep1">注意：</p>
                           <ul style="list-style-type:disc">
                              <li>
                                 <p>OCCI不检查连接标签对的正确性。您有责任确保具有不同客户端属性的连接不具有相同的标记。</p>
                              </li>
                              <li>
                                 <p>在将连接释放回池之前，您的应用程序应提交或回滚任何打开的事务。如果不这样做，Oracle会在释放连接时自动<span class="italic">提交</span>任何打开的事务。
                                 </p>
                              </li>
                           </ul>
                        </div>
                        <p>有两种类型的无状态连接池：</p>
                     </div>
                     <!-- class="section" -->
                     <div class="section">
                        <ul style="list-style-type:disc">
                           <li>
                              <p><span class="bold">同构池</span>是使用在创建池时提供的用户名和密码对所有连接进行身份验证的池。因此，所有连接都具有相同的身份验证上下文此类池中不允许代理连接。
                              </p>
                           </li>
                           <li>
                              <p><span class="bold">异构池中</span>的不同用户名可以对不同的连接进行身份验证。代理连接也可以存在于异构池中，前提是在服务器上授予创建它们的必要权限。此外，异构池支持外部身份验证。
                              </p>
                           </li>
                        </ul>
                        <p><a href="accessing-oracle-database-using-cplusplus.html#GUID-3F1B3810-8FE3-46EB-92D0-49C077B92261__CHDDEGEJ">示例3-9</a>说明了连接池的基本使用方案。<a href="accessing-oracle-database-using-cplusplus.html#GUID-3F1B3810-8FE3-46EB-92D0-49C077B92261__BAGBAFDC">示例3-10</a>显示了创建和使用同构无状态连接池的使用方案，而<a href="accessing-oracle-database-using-cplusplus.html#GUID-3F1B3810-8FE3-46EB-92D0-49C077B92261__BAGIBIDA">示例3-11</a>介绍了异构池的使用。
                        </p>
                     </div>
                     <!-- class="section" -->
                     <div class="example" id="GUID-3F1B3810-8FE3-46EB-92D0-49C077B92261__CHDDEGEJ">
                        <p class="titleinexample">示例3-9如何使用StatelessConnectionPool</p>
                        <p>由于池大小是动态的，因此响应用户需求的变化，最多可达到指定的最大连接数。假设使用以下参数创建无状态连接池：</p>
                        <ul style="list-style-type:disc">
                           <li>
                              <p><code class="codeph">minConn = 5</code></p>
                           </li>
                           <li>
                              <p><code class="codeph">incrConn = 2</code></p>
                           </li>
                           <li>
                              <p><code class="codeph">maxConn = 10</code></p>
                           </li>
                        </ul>
                        <p>创建池时会打开五个连接：</p>
                        <ul style="list-style-type:disc">
                           <li>
                              <p><code class="codeph">openConn = 5</code></p>
                           </li>
                        </ul>
                        <p>使用<code class="codeph">get[AnyTagged][Proxy]Connection()</code>方法，用户使用所有5个打开的连接：</p>
                        <ul style="list-style-type:disc">
                           <li>
                              <p><code class="codeph">openConn = 5</code></p>
                           </li>
                           <li>
                              <p><code class="codeph">busyConn = 5</code></p>
                           </li>
                        </ul>
                        <p>当用户想要另一个连接时，池会打开<code class="codeph">2</code>新连接并将其中一个连接返回给用户。
                        </p>
                        <ul style="list-style-type:disc">
                           <li>
                              <p><code class="codeph">openConn = 7</code></p>
                           </li>
                           <li>
                              <p><code class="codeph">busyConn = 6</code></p>
                           </li>
                        </ul>
                        <p>可以合并的连接数的上限是在创建池时指定的<code class="codeph">maxConn</code> 。
                        </p>
                        <p>用户还可以在使用<code class="codeph">setPoolSize()</code>方法调用创建池后修改池参数。
                        </p>
                        <p>如果创建了一个异类池， <code class="codeph">incrConn</code>和<code class="codeph">minConn</code>参数被忽略。
                        </p>
                     </div>
                     <!-- class="example" -->
                     <div class="example" id="GUID-3F1B3810-8FE3-46EB-92D0-49C077B92261__BAGBAFDC">
                        <p class="titleinexample">示例3-10如何创建和使用同构无状态连接池</p>
                        <p>要创建同构无状态连接池，请遵循以下基本步骤和伪代码命令：</p>
                        <ol>
                           <li>
                              <p>使用<a href="environment-class.html#GUID-0CC9175A-255B-49ED-A23B-5BE924603BE7">createStatelessConnectionPool（）</a>调用在<code class="codeph">Environment</code>的<code class="codeph">HOMOGENEOUS</code>模式下创建无状态连接池。
                              </p><pre class="oac_no_warn" dir="ltr">StatelessConnectionPool * scp = env-&gt; createStatelessConnectionPool（username，passwd，connectString，maxCon，minCon，incrCon，StatelessConnectionPool :: HOMOGENEOUS）;</pre></li>
                           <li>
                              <p>通过调用<a href="statelessconnectionpool-class.html#GUID-7B51A18D-4F2E-4049-92D5-31B5ED8204A0">getConnection（）</a>方法从池中获取新的或现有的连接。
                              </p><pre class="oac_no_warn" dir="ltr">Connection * conn = scp-&gt; getConnection（tag）;</pre><p>在执行此调用期间，将在池中搜索具有匹配标记的连接。如果存在这样的连接，则将其返回给用户。否则，将返回由池用户名和密码验证的未标记连接。</p>
                              <p>或者，您可以使用<a href="statelessconnectionpool-class.html#GUID-DC82EBB7-AAA0-4CD2-A691-E9E10E14749C">getAnyTaggedConnection（）</a>调用获取连接。如果匹配的标记或<code class="codeph">NULL</code>标记连接都不可用，它将返回具有不匹配标记的连接。您应该验证<code class="codeph">Connection</code>上的<a href="connection-class.html#GUID-21110CE0-E633-4D0A-AE7D-1B55C794320F">getTag（）</a>调用返回的标记。
                              </p><pre class="oac_no_warn" dir="ltr">Connection * conn = scp-&gt; getAnyTaggedConnection（tag）; string tag = conn-&gt; getTag（）;</pre></li>
                           <li>
                              <p>使用连接。</p>
                           </li>
                           <li>
                              <p>通过<a href="statelessconnectionpool-class.html#GUID-E2C3EF92-6DDA-4C2F-8F93-A344AF875E3B">releaseConnection（）</a>调用释放与<code class="codeph">StatelessConnectionPool</code>的连接。
                              </p><pre class="oac_no_warn" dir="ltr">scp-&gt; releaseConnection（conn，tag）;</pre><p>空标记<code class="codeph">""</code>取消标记<code class="codeph">Connection</code> 。
                              </p>
                              <p>您可以选择在<a href="statelessconnectionpool-class.html#GUID-7B51A18D-4F2E-4049-92D5-31B5ED8204A0">getConnection（）</a>调用中使用相同的<code class="codeph">tag</code>参数值从<code class="codeph">StatelessConnectionPool</code>检索连接。
                              </p><pre class="oac_no_warn" dir="ltr">Connection * conn = scp-&gt; getConnection（tag）;</pre><p>您可能希望使用<a href="environment-class.html#GUID-C0C20A14-2404-4091-AF1B-C49BC3B98EAF">terminateConnection（）</a>调用将其销毁<code class="codeph">StatelessConnectionPool,</code>而不是将<code class="codeph">Connection</code>返回到<code class="codeph">StatelessConnectionPool,</code> 。
                              </p><pre class="oac_no_warn" dir="ltr">scp-&gt; terminateConnection（conn）;在</pre></li>
                           <li>
                              <p>通过<code class="codeph">Environment</code>对象上的<a href="environment-class.html#GUID-995DD530-7CE2-4E10-BFE8-405F2A233CF8">terminateStatelessConnectionPool（）</a>调用来销毁池。
                              </p><pre class="oac_no_warn" dir="ltr">env-&gt; terminateStatelessConnectionPool（SCP）;</pre></li>
                        </ol>
                     </div>
                     <!-- class="example" -->
                     <div class="example" id="GUID-3F1B3810-8FE3-46EB-92D0-49C077B92261__BAGIBIDA">
                        <p class="titleinexample">示例3-11如何创建和使用异构无状态连接池</p>
                        <p>要创建异构无状态连接池，请遵循以下基本步骤和伪代码命令：</p>
                        <ol>
                           <li>
                              <p>使用<a href="environment-class.html#GUID-0CC9175A-255B-49ED-A23B-5BE924603BE7">createStatelessConnectionPool（）</a>调用在<code class="codeph">Environment</code>的<code class="codeph">HETEROGENEOUS</code>模式下创建无状态连接池。
                              </p><pre class="oac_no_warn" dir="ltr">StatelessConnectionPool * scp = env-&gt; createStatelessConnectionPool（username，passwd，connectString，maxCon，minCon，incrCon，StatelessConnectionPool :: HETEROGENEOUS）;</pre><p>如果要启用外部身份验证，还必须在<a href="environment-class.html#GUID-0CC9175A-255B-49ED-A23B-5BE924603BE7">createStatelessConnectionPool（）</a>调用中激活<code class="codeph">USES_EXT_AUTH</code>模式。
                              </p><pre class="oac_no_warn" dir="ltr">StatelessConnectionPool * scp = env-&gt; createStatelessConnectionPool（username，passwd，connectString，maxCon，minCon，incrCon，StatelessConnectionPool :: PoolType（StatelessConnectionPool :: USES_EXT_AUTH | StatelessConnectionPool :: HETEROGENEOUS））;</pre></li>
                           <li>
                              <p>通过调用为异构池选项重载的<code class="codeph">StatelessConnectionPool</code>的<a href="statelessconnectionpool-class.html#GUID-7B51A18D-4F2E-4049-92D5-31B5ED8204A0">getConnection（）</a>方法，从池中获取新的或现有的连接。
                              </p><pre class="oac_no_warn" dir="ltr">Connection * conn = scp-&gt; getConnection（username，passwd，tag）;</pre><p>在执行此调用期间，将在异构池中搜索与匹配标记的连接。如果存在这样的连接，则将其返回给用户。否则，将返回具有<code class="codeph">NULL</code>标记的经过适当身份验证的无标记连接。
                              </p>
                              <p>或者，您可以获取已为异构池重载的<a href="statelessconnectionpool-class.html#GUID-DC82EBB7-AAA0-4CD2-A691-E9E10E14749C">getAnyTaggedConnection（）</a>调用的连接。如果匹配的标记或<code class="codeph">NULL</code>标记连接都不可用，它将返回具有不匹配标记的连接。您应该验证<code class="codeph">Connection</code>上的<a href="connection-class.html#GUID-21110CE0-E633-4D0A-AE7D-1B55C794320F">getTag（）</a>调用返回的标记。
                              </p><pre class="oac_no_warn" dir="ltr">Connection * conn = scp-&gt; getAnyTaggedConnection（username，passwd，tag）; string tag = conn-&gt; getTag（）;</pre><p>你也可以使用通过代理连接<a href="statelessconnectionpool-class.html#GUID-5B45961F-C1D6-4CF5-920F-71785A1218C8">getProxyConnection（）</a>或<a href="statelessconnectionpool-class.html#GUID-E66E8CD9-1A9C-4099-BAB3-9078F677392A">getAnyTaggedProxyConnection（）</a>的调用<code class="codeph">StatelessConnectionPool</code> 。
                              </p><pre class="oac_no_warn" dir="ltr">Connection * pconn = scp-&gt; getProxyConnection（proxyName，roles {}，nuRoles，tag，proxyType）; Connection * pconn = scp-&gt; getAnyTaggedProxyConnection（proxyName，tag，proxyType）;</pre><p>如果池支持外部身份验证，请使用以下<a href="statelessconnectionpool-class.html#GUID-7B51A18D-4F2E-4049-92D5-31B5ED8204A0">getConnection（）</a>调用：</p><pre class="oac_no_warn" dir="ltr">Connection * conn = scp-&gt; getConnection（）;</pre></li>
                           <li>
                              <p>使用连接。</p>
                           </li>
                           <li>
                              <p>通过<a href="statelessconnectionpool-class.html#GUID-E2C3EF92-6DDA-4C2F-8F93-A344AF875E3B">releaseConnection（）</a>调用释放与<code class="codeph">StatelessConnectionPool</code>的连接。
                              </p><pre class="oac_no_warn" dir="ltr">scp-&gt; releaseConnection（conn，tag）;</pre><p>空标记<code class="codeph">""</code>取消标记<code class="codeph">Connection</code> 。
                              </p>
                              <p>您可以选择在<a href="statelessconnectionpool-class.html#GUID-7B51A18D-4F2E-4049-92D5-31B5ED8204A0">getConnection（）</a>调用中使用相同的<code class="codeph">tag</code>参数值从<code class="codeph">StatelessConnectionPool</code>检索连接。
                              </p><pre class="oac_no_warn" dir="ltr">Connection * conn = scp-&gt; getConnection（tag）;</pre><p>您可能希望使用<a href="environment-class.html#GUID-C0C20A14-2404-4091-AF1B-C49BC3B98EAF">terminateConnection（）</a>调用将其销毁<code class="codeph">StatelessConnectionPool,</code>而不是将<code class="codeph">Connection</code>返回到<code class="codeph">StatelessConnectionPool,</code> 。
                              </p><pre class="oac_no_warn" dir="ltr">scp-&gt; terminateConnection（conn）;在</pre></li>
                           <li>
                              <p>通过<code class="codeph">Environment</code>对象上的<a href="environment-class.html#GUID-995DD530-7CE2-4E10-BFE8-405F2A233CF8">terminateStatelessConnectionPool（）</a>调用来销毁池。
                              </p><pre class="oac_no_warn" dir="ltr">env-&gt; terminateStatelessConnectionPool（SCP）;</pre></li>
                        </ol>
                     </div>
                     <!-- class="example" -->
                  </div>
               </div><a id="LNCPP00323"></a><div class="props_rev_3"><a id="GUID-15EB97EF-D72B-4F4A-8AAB-87928AACE008" name="GUID-15EB97EF-D72B-4F4A-8AAB-87928AACE008"></a><h4 id="LNCPP-GUID-15EB97EF-D72B-4F4A-8AAB-87928AACE008" class="sect4"><span class="enumeration_section">3.2.3</span>关于数据库驻留连接池</h4>
                  <div>
                     <p>企业级应用程序通常必须处理大量并发用户会话，这些会话实现为与数据库的持久连接。创建和管理这些连接的内存开销对数据库的性能有重大影响。</p>
                     <p>数据库驻留连接池通过提供用于处理大量应用程序连接的专用服务器池来解决持久连接过多的问题，从而使数据库能够扩展到数万个并发连接。它显着减少了数据库层的内存占用，并提高了数据库和中间层的可伸缩性。数据库驻留连接池专为具有多进程应用程序服务器和多个中间层的体系结构而设计，这些中间层无法容纳中间层中的连接池。</p>
                     <p>数据库驻留连接池结构紧密遵循用于连接到Oracle数据库实例的默认专用模型;但是，它消除了为每个连接分配特定服务器的开销。在服务器层上，大多数连接在任何给定时间都处于非活动状态，并且每个连接都消耗内存。因此，支持高连接量的数据库系统面临快速耗尽所有可用内存的风险。数据库驻留连接池允许连接使用专用服务器，该服务器结合了Oracle服务器进程和用户会话。一旦连接变为非活动状态，它就会将其资源返回到池中，供类似的连接使用。</p>
                     <p>在能够进行全面连接池的多线程中间层中，未使用的连接问题有些不同。随着中间层数的增加，每个中间层私下拥有与数据库的多个连接;这些连接不能与其他中间层共享。在数据库上定位连接池可以实现跨类似客户端的连接共享。</p>
                     <p>数据库驻留连接池支持基于密码的身份验证，语句缓存，标记和<a href="../racad/ensuring-application-continuity.html#RACAD7128" target="_blank">快速应用程序通知</a> 。您还可以将客户端无状态连接池与数据库驻留连接池一起使用。
                     </p>
                     <p>请注意，从数据库驻留连接池保持连接的客户端持久连接到后台连接代理进程。Connection Broker实现池功能并将入站客户端连接多路复用到专用服务器进程池。不使用连接池的客户端使用专用服务器进程。</p>
                     <div class="infoboxnotealso" id="GUID-15EB97EF-D72B-4F4A-8AAB-87928AACE008__GUID-DEB63D2B-7C2C-4113-B787-498C493D2D4E">
                        <p class="notep1">也可以看看：</p>
                        <ul style="list-style-type:disc">
                           <li>
                              <p>有关Database Resident Connection Pooling体系结构的详细信息，请参阅<a href="../cncpt/application-and-networking-architecture.html#CNCPT1896" target="_blank"><span><cite>Oracle数据库概念</cite></span></a></p>
                           </li>
                           <li>
                              <p>有关配置数据库驻留连接池的详细信息，请参见<a href="../admin/managing-processes.html#ADMIN00502" target="_blank"><span><cite>“Oracle数据库管理员指南”</cite></span></a></p>
                           </li>
                           <li>
                              <p><code class="codeph">DBMS_CONNECTION_POOL</code>包的<a href="../arpls/DBMS_CONNECTION_POOL.html#ARPLS215" target="_blank"><span><cite>Oracle Database PL / SQL包和类型参考</cite></span></a></p>
                           </li>
                        </ul>
                     </div>
                     <div class="p">本节包括以下主题：<ul style="list-style-type:disc">
                           <li>
                              <p><a href="accessing-oracle-database-using-cplusplus.html#GUID-4F3E90C4-99DA-4CC0-82DD-E01FAD961E5E">管理数据库驻留连接池</a></p>
                           </li>
                           <li>
                              <p><a href="accessing-oracle-database-using-cplusplus.html#GUID-1488702A-7B56-49EE-8741-50F252217AA3">使用数据库驻留连接池</a></p>
                           </li>
                        </ul>
                     </div>
                  </div><a id="LNCPP20116"></a><a id="LNCPP03231"></a><div class="props_rev_3"><a id="GUID-4F3E90C4-99DA-4CC0-82DD-E01FAD961E5E" name="GUID-4F3E90C4-99DA-4CC0-82DD-E01FAD961E5E"></a><h5 id="LNCPP-GUID-4F3E90C4-99DA-4CC0-82DD-E01FAD961E5E" class="sect5"><span class="enumeration_section">3.2.3.1</span>管理数据库驻留连接池</h5>
                     <div>
                        <div class="section">
                           <p>要实现数据库驻留连接池，必须首先由具有<code class="codeph">SYSDBA</code>权限的用户在系统上启用它。有关启动和维护数据库驻留连接池所需的步骤，请参阅<a href="accessing-oracle-database-using-cplusplus.html#GUID-4F3E90C4-99DA-4CC0-82DD-E01FAD961E5E__CHDGIHID">示例3-12</a> 。
                           </p>
                           <p>请注意，在Oracle RAC配置中，数据库驻留连接池在所有已配置的节点上启动。如果池未停止，则启动配置在实例重新启动时保持不变：池在实例启动时自动启动。</p>
                        </div>
                        <!-- class="section" -->
                        <div class="example" id="GUID-4F3E90C4-99DA-4CC0-82DD-E01FAD961E5E__CHDGIHID">
                           <p class="titleinexample">示例3-12如何管理数据库驻留连接池</p>
                           <p>具有<code class="codeph">SYSDBA</code>权限的用户必须执行后续步骤。
                           </p>
                           <ol>
                              <li>
                                 <p>连接到数据库。</p><pre class="oac_no_warn" dir="ltr">SQLPLUS / AS SYSDBA</pre></li>
                              <li>
                                 <p>[可选]配置数据库驻留连接池的参数。池的默认值按以下方式设置：</p><pre class="oac_no_warn" dir="ltr">DBMS_CONNECTION_POOL.CONFIGURE_POOL（'SYS_DEFAULT_CONNECTION_POOL'，MIN =&gt; 10，MAX =&gt; 200）;</pre></li>
                              <li>
                                 <p>[可选]更改数据库驻留连接池的特定参数，而不影响其他参数。</p><pre class="oac_no_warn" dir="ltr">DBMS_CONNECTION_POOL.ALTER_PARAM（'SYS_DEFAULT_CONNECTION_POOL'，'INACTIVITY_TIMEOUT'，10）;</pre></li>
                              <li>
                                 <p>启动连接池。完成此步骤后，连接池可供所有合格的客户端使用。</p><pre class="oac_no_warn" dir="ltr">DBMS_CONNECTION_POOL.START_POOL（'SYS_DEFAULT_CONNECTION_POOL'）;</pre></li>
                              <li>
                                 <p>[可选]更改数据库驻留连接池的参数。</p><pre class="oac_no_warn" dir="ltr">DBMS_CONNECTION_POOL.ALTER_PARAM（'SYS_DEFAULT_CONNECTION_POOL'，'MAXSIZE'，20）;</pre></li>
                              <li>
                                 <p>[可选]连接池的配置可以重置为默认值。</p><pre class="oac_no_warn" dir="ltr">DBMS_CONNECTION_POOL.RESTORE_DEFAULTS（'SYS_DEFAULT_CONNECTION_POOL'）;</pre></li>
                              <li>
                                 <p>停下游泳池。请注意，池信息是持久性的：停止池不会破坏池名称和配置参数。</p><pre class="oac_no_warn" dir="ltr">DBMS_CONNECTION_POOL.STOP_POOL（）;</pre></li>
                           </ol>
                        </div>
                        <!-- class="example" -->
                     </div>
                  </div><a id="LNCPP20117"></a><a id="LNCPP20118"></a><a id="LNCPP03232"></a><div class="props_rev_3"><a id="GUID-1488702A-7B56-49EE-8741-50F252217AA3" name="GUID-1488702A-7B56-49EE-8741-50F252217AA3"></a><h5 id="LNCPP-GUID-1488702A-7B56-49EE-8741-50F252217AA3" class="sect5"><span class="enumeration_section">3.2.3.2</span>使用数据库驻留连接池</h5>
                     <div>
                        <div class="section">
                           <p>要使用数据库驻留连接池，必须指定连接类和连接纯度。如果应用程序请求不能被先前连接状态污染的连接，则必须将纯度指定为<code class="codeph">NEW</code> ;如果来自不同地理区域设置的客户端共享同一数据库实例，Oracle建议使用此方法。当应用程序可以使用以前使用的连接时，纯度应设置为<code class="codeph">SELF</code> 。结合连接类和纯度规范，您还可以使用特定于应用程序的标记来选择以前使用的具有所需状态的连接。如<a href="accessing-oracle-database-using-cplusplus.html#GUID-4F3E90C4-99DA-4CC0-82DD-E01FAD961E5E__CHDGIHID">示例3-12所示</a> ，缺省连接池名称为<code class="codeph">SYS_DEFAULT_CONNECTION_POOL.</code></p>
                           <p>此功能通过添加指定连接类和纯度的参数来重载<a href="statelessconnectionpool-class.html#GUID-C0591485-F818-4AC0-9875-ED245BDABCA6">StatelessConnectionPool类</a>和<a href="environment-class.html#GUID-98598A9C-BED1-46CF-9A10-4F2A56B74BF9">环境类</a>接口以检索连接（ <code class="codeph">getConnection()</code>和<code class="codeph">getProxyConnection()</code> ）。客户端连接池外部的每个连接请求都具有默认纯度<code class="codeph">NEW</code> 。客户端连接池内的连接请求的默认纯度为<code class="codeph">SELF</code> 。</p>
                        </div>
                        <!-- class="section" -->
                        <div class="example" id="GUID-1488702A-7B56-49EE-8741-50F252217AA3__GUID-3C7D3A5B-329F-4C85-B8BE-4793751DAC52">
                           <p class="titleinexample">示例3-13如何从数据库驻留连接池获取连接</p><pre class="oac_no_warn" dir="ltr">conn1 = env-&gt; createConnection（/ * username * /“hr”，/ * password * /“ <span class="italic">password</span> ”，/ * database * /“inst1_cmon”， <span class="bold">/ * connection class * /“TESTCC”，/ * purity * / Connection ：：自）;</span> stmt1 = conn1-&gt; createStatement（“从emp中选择count（*）”）; RS = stmt1-&gt;的executeQuery（）; while（rs-&gt; next（））{int num = rs-&gt; getInt（1）; sprintf（（char *）tmp，“％d”，num）; cout &lt;&lt; tmp &lt;&lt; endl; } stmt1-&gt; closeResultSet（rs）; conn1-&gt; terminateStatement（stmt1）; env-&gt; terminateConnection（conn1连接）;</pre></div>
                        <!-- class="example" -->
                        <div class="example" id="GUID-1488702A-7B56-49EE-8741-50F252217AA3__GUID-F5CB8D95-DA46-4B8C-A64A-DB8321671190">
                           <p class="titleinexample">示例3-14使用客户端池和服务器端池</p><pre class="oac_no_warn" dir="ltr">StatelessConnectionPool * scPool; OCCIConnection * conn1，* conn2; scPool = env-&gt; createStatelessConnectionPool（poolUserName，poolPassword，connectString，maxConn，minConn，incrConn，StatelessConnectionPool :: HOMOGENEOUS）; conn1 = scPool-&gt; getConnection（ <span class="bold">/ *连接类名* /“TESTCC”，</span> <span class="bold">/ * Purity * / Connection :: SELF）;</span> / *或，对于代理连接* / conn2 = scPool-&gt; getProxyConnection（ <span class="bold">/ * username * /“HR_PROXY”，</span> <span class="bold">/ * Connection class * /“TESTCC”，/ * Purity * / Connection :: SELF）;</span> / *或，用于获取标记连接* / conn3 = scPool-&gt; getConnection（ <span class="bold">/ * connection class * /“TESTCC”，</span> <span class="bold">/ * purity * / Connection :: SELF，</span> <span class="bold">/ * tag * /“TESTTAG”）;</span> / *释放标记连接目前已完成* / scPool-&gt; releaseConnection（conn3，“TESTTAG”）; / *指定纯度为新* / conn4 = scPool-&gt; getConnection（ <span class="bold">/ *连接类* /“TESTCC”，/ *纯度为* *</span> <span class="bold">Connection :: NEW）;</span> / *使用用户名和密码获取连接* / conn5 = scPool-&gt; getConnection（ <span class="bold">用户名，密码，“TESTCC”，Connection :: SELF）;</span> / *在请求连接时使用角色* / conn6 = scPool-&gt; getProxyConnection（用户名，角色，nRoles， <span class="bold">“TESTCC”，</span> <span class="bold">Connection :: SELF）;</span> .../ *其他代码按原样继续...为了清晰起见* / ...stmt1 = conn1-&gt; createStatement（“INSERT INTO emp values（：c1，：c2）”）; stmt1-&gt; setInt（1，thrid）; stmt1-&gt; setString（2，“Test”）; int count = stmt1-&gt; executeUpdate（）; conn1-&gt;提交（）; conn1-&gt; terminateStatement（stmt1）; / *释放连接* / scPool-&gt; releaseConnection（conn1）; ...env-&gt; terminateStatelessConnectionPool（scPool）;</pre></div>
                        <!-- class="example" -->
                     </div>
                  </div>
               </div>
            </div><a id="LNCPP0033"></a><div class="props_rev_3"><a id="GUID-7B55181E-FC07-4E3D-B91C-25E4288D4B7B" name="GUID-7B55181E-FC07-4E3D-B91C-25E4288D4B7B"></a><h3 id="LNCPP-GUID-7B55181E-FC07-4E3D-B91C-25E4288D4B7B" class="sect3"><span class="enumeration_section">3.3</span>关于执行SQL DDL和DML语句</h3>
               <div>
                  <p>SQL是用于处理关系数据库的行业语言。在OCCI中，您可以通过<code class="codeph">Statement</code>类执行SQL命令。
                  </p>
                  <div class="p">本节包括以下主题：<ul style="list-style-type:disc">
                        <li>
                           <p><a href="accessing-oracle-database-using-cplusplus.html#GUID-F273EF54-652C-4905-A60D-2368ADE31C81">创建语句对象</a></p>
                        </li>
                        <li>
                           <p><a href="accessing-oracle-database-using-cplusplus.html#GUID-AB1BCABD-588C-4A0B-865F-A974599B71A4">创建执行SQL命令的语句对象</a></p>
                        </li>
                        <li>
                           <p><a href="accessing-oracle-database-using-cplusplus.html#GUID-246BBE34-DB77-413A-9556-997B1C10AFE0">重用Statement对象</a></p>
                        </li>
                        <li>
                           <p><a href="accessing-oracle-database-using-cplusplus.html#GUID-3F97B062-194B-4197-93D0-2F2DFCCF9420">终止语句对象</a></p>
                        </li>
                     </ul>
                  </div>
               </div><a id="LNCPP20119"></a><a id="LNCPP00331"></a><div class="props_rev_3"><a id="GUID-F273EF54-652C-4905-A60D-2368ADE31C81" name="GUID-F273EF54-652C-4905-A60D-2368ADE31C81"></a><h4 id="LNCPP-GUID-F273EF54-652C-4905-A60D-2368ADE31C81" class="sect4"><span class="enumeration_section">3.3.1</span>创建语句对象</h4>
                  <div>
                     <div class="section">
                        <p>要创建<code class="codeph">Statement</code>对象，请调用<code class="codeph">Connection</code>对象的<code class="codeph">createStatement()</code>方法，如<a href="accessing-oracle-database-using-cplusplus.html#GUID-F273EF54-652C-4905-A60D-2368ADE31C81__CHDGABGG">例3-15所示</a> ，</p>
                     </div>
                     <!-- class="section" -->
                     <div class="example" id="GUID-F273EF54-652C-4905-A60D-2368ADE31C81__CHDGABGG">
                        <p class="titleinexample">示例3-15如何创建语句</p><pre class="oac_no_warn" dir="ltr">Statement * stmt = conn-&gt; cr eateStatement（）;</pre></div>
                     <!-- class="example" -->
                  </div>
               </div><a id="LNCPP00332"></a><div class="props_rev_3"><a id="GUID-AB1BCABD-588C-4A0B-865F-A974599B71A4" name="GUID-AB1BCABD-588C-4A0B-865F-A974599B71A4"></a><h4 id="LNCPP-GUID-AB1BCABD-588C-4A0B-865F-A974599B71A4" class="sect4"><span class="enumeration_section">3.3.2</span>创建执行SQL命令的语句对象</h4>
                  <div>
                     <div class="section">
                        <p>一旦你创建了一个<code class="codeph">Statement</code>的对象，通过调用执行SQL命令<a href="statement-class.html#GUID-9D152584-D72E-42AE-A3CC-3C6A4F35C11B">的execute（） ，</a> <a href="statement-class.html#GUID-307FAD33-F491-494B-A485-BE266506A83E">executeUpdate的（） ，</a> <a href="statement-class.html#GUID-84576A04-DE27-49E8-ADA2-1F8D26730FC6">executeArrayUpdate（） ，</a>或<a href="statement-class.html#GUID-4F93A82F-9769-49C7-85D1-C30BA5E91A98">的executeQuery（）</a>的方法上<code class="codeph">Statement</code>的对象。这些方法用于以下目的：</p>
                     </div>
                     <!-- class="section" -->
                     <div class="section">
                        <ul style="list-style-type:disc">
                           <li>
                              <p><a href="statement-class.html#GUID-9D152584-D72E-42AE-A3CC-3C6A4F35C11B">execute（）</a>执行所有非特定的语句类型</p>
                           </li>
                           <li>
                              <p><a href="statement-class.html#GUID-307FAD33-F491-494B-A485-BE266506A83E">executeUpdate（）</a>执行DML和DDL语句</p>
                           </li>
                           <li>
                              <p><a href="statement-class.html#GUID-84576A04-DE27-49E8-ADA2-1F8D26730FC6">executeArrayUpdate（）</a>执行多个DML语句</p>
                           </li>
                           <li>
                              <p><a href="statement-class.html#GUID-4F93A82F-9769-49C7-85D1-C30BA5E91A98">executeQuery（）</a>执行查询</p>
                           </li>
                        </ul>
                        <div class="p">本节包括以下主题：<ul style="list-style-type:disc">
                              <li>
                                 <p><a href="accessing-oracle-database-using-cplusplus.html#GUID-815B3C03-E11C-4C2D-AED1-8BB50D97A0D6">创建数据库表</a></p>
                              </li>
                              <li>
                                 <p><a href="accessing-oracle-database-using-cplusplus.html#GUID-54F4E6DF-F94C-43D9-83B3-AC631F2EDDF1">将值插入数据库表</a></p>
                              </li>
                           </ul>
                        </div>
                     </div>
                     <!-- class="section" -->
                  </div><a id="LNCPP20120"></a><a id="LNCPP03221"></a><div class="props_rev_3"><a id="GUID-815B3C03-E11C-4C2D-AED1-8BB50D97A0D6" name="GUID-815B3C03-E11C-4C2D-AED1-8BB50D97A0D6"></a><h5 id="LNCPP-GUID-815B3C03-E11C-4C2D-AED1-8BB50D97A0D6" class="sect5"><span class="enumeration_section">3.3.2.1</span>创建数据库表</h5>
                     <div>
                        <div class="section">
                           <p><a href="accessing-oracle-database-using-cplusplus.html#GUID-815B3C03-E11C-4C2D-AED1-8BB50D97A0D6__CHDBIFIA">示例3-16</a>演示了如何使用<a href="statement-class.html#GUID-307FAD33-F491-494B-A485-BE266506A83E">executeUpdate（）</a>方法创建数据库表。
                           </p>
                        </div>
                        <!-- class="section" -->
                        <div class="example" id="GUID-815B3C03-E11C-4C2D-AED1-8BB50D97A0D6__CHDBIFIA">
                           <p class="titleinexample">示例3-16如何使用executeUpdate（）方法创建数据库表</p><pre class="oac_no_warn" dir="ltr">stmt-&gt; executeUpdate（“CREATE TABLE shopping_basket（item_number VARCHAR2（30），quantity NUMBER（3））”）;</pre></div>
                        <!-- class="example" -->
                     </div>
                  </div><a id="LNCPP20121"></a><a id="LNCPP03223"></a><div class="props_rev_3"><a id="GUID-54F4E6DF-F94C-43D9-83B3-AC631F2EDDF1" name="GUID-54F4E6DF-F94C-43D9-83B3-AC631F2EDDF1"></a><h5 id="LNCPP-GUID-54F4E6DF-F94C-43D9-83B3-AC631F2EDDF1" class="sect5"><span class="enumeration_section">3.3.2.2</span>将值插入数据库表</h5>
                     <div>
                        <div class="section">
                           <p>同样，您可以通过调用<a href="statement-class.html#GUID-307FAD33-F491-494B-A485-BE266506A83E">executeUpdate（）</a>方法来执行SQL <code class="codeph">INSERT</code>语句，如<a href="accessing-oracle-database-using-cplusplus.html#GUID-54F4E6DF-F94C-43D9-83B3-AC631F2EDDF1__CHDCIBJA">例3-17所示</a> 。
                           </p>
                           <p><a href="statement-class.html#GUID-307FAD33-F491-494B-A485-BE266506A83E">executeUpdate（）</a>方法返回受SQL语句影响的行数。
                           </p>
                           <div class="infoboxnotealso" id="GUID-54F4E6DF-F94C-43D9-83B3-AC631F2EDDF1__GUID-2CA1D3F4-F5B1-498C-B145-C872D9BA8DBB">
                              <p class="notep1">也可以看看：</p>
                              <p><code class="codeph">$</code> <span class="italic"><code class="codeph">ORACLE_HOME</code></span> <code class="codeph">/rdbms/demo</code>用于演示如何对表行执行插入，选择，更新和删除操作的代码示例。
                              </p>
                           </div>
                        </div>
                        <!-- class="section" -->
                        <div class="example" id="GUID-54F4E6DF-F94C-43D9-83B3-AC631F2EDDF1__CHDCIBJA">
                           <p class="titleinexample">示例3-17如何使用executeUpdate（）方法添加记录</p><pre class="oac_no_warn" dir="ltr">stmt-&gt; executeUpdate（“INSERT INTO shopping_basket VALUES（'MANGO'，3）”）;</pre></div>
                        <!-- class="example" -->
                     </div>
                  </div>
               </div><a id="LNCPP20122"></a><a id="LNCPP20123"></a><a id="LNCPP00333"></a><div class="props_rev_3"><a id="GUID-246BBE34-DB77-413A-9556-997B1C10AFE0" name="GUID-246BBE34-DB77-413A-9556-997B1C10AFE0"></a><h4 id="LNCPP-GUID-246BBE34-DB77-413A-9556-997B1C10AFE0" class="sect4"><span class="enumeration_section">3.3.3</span>重用Statement对象</h4>
                  <div>
                     <div class="section">
                        <p>您可以重复使用<code class="codeph">Statement</code>对象多次执行SQL语句。要使用不同的参数重复执行相同的语句，您应该通过<code class="codeph">Statement</code>对象的<a href="statement-class.html#GUID-66171CB8-85E3-46FB-93D7-FAF6712C704F">setSQL（）</a>方法指定语句，如<a href="accessing-oracle-database-using-cplusplus.html#GUID-246BBE34-DB77-413A-9556-997B1C10AFE0__CHDFFFDA">例3-18所示</a> 。
                        </p>
                        <p>您现在可以根据需要多次执行此<code class="codeph">INSERT</code>语句。如果稍后要执行不同的SQL语句，则只需重置语句对象，如<a href="accessing-oracle-database-using-cplusplus.html#GUID-246BBE34-DB77-413A-9556-997B1C10AFE0__CHDFGCJC">例3-19所示</a> 。
                        </p>
                        <p>通过使用<a href="statement-class.html#GUID-66171CB8-85E3-46FB-93D7-FAF6712C704F">setSQL（）</a>方法，OCCI语句对象及其关联资源不会被不必要地分配或释放。要随时检索当前语句对象的内容，请使用<a href="statement-class.html#GUID-5F0F10E4-426A-4BBF-BA15-EDEF12E03196">getSQL（）</a>方法。
                        </p>
                     </div>
                     <!-- class="section" -->
                     <div class="example" id="GUID-246BBE34-DB77-413A-9556-997B1C10AFE0__CHDFFFDA">
                        <p class="titleinexample">示例3-18如何使用setSQL（）方法指定SQL语句</p><pre class="oac_no_warn" dir="ltr">stmt-&gt; setSQL（“INSERT INTO shopping_basket VALUES（：1，：2）”）;</pre></div>
                     <!-- class="example" -->
                     <div class="example" id="GUID-246BBE34-DB77-413A-9556-997B1C10AFE0__CHDFGCJC">
                        <p class="titleinexample">示例3-19如何使用setSQL（）方法重置SQL语句</p><pre class="oac_no_warn" dir="ltr">stmt-&gt; setSQL（“SELECT * FROM shopping_basket WHERE quantity&gt; =：1”）;</pre></div>
                     <!-- class="example" -->
                  </div>
               </div><a id="LNCPP20124"></a><a id="LNCPP00334"></a><div class="props_rev_3"><a id="GUID-3F97B062-194B-4197-93D0-2F2DFCCF9420" name="GUID-3F97B062-194B-4197-93D0-2F2DFCCF9420"></a><h4 id="LNCPP-GUID-3F97B062-194B-4197-93D0-2F2DFCCF9420" class="sect4"><span class="enumeration_section">3.3.4</span>终止语句对象</h4>
                  <div>
                     <div class="section">
                        <p>您应该使用<a href="connection-class.html#GUID-DC3E71A2-9BD4-418D-96AD-CBE05EE9B2BE">terminateStatement（）</a>方法显式地终止和释放<code class="codeph">Statement</code>对象，如<a href="accessing-oracle-database-using-cplusplus.html#GUID-3F97B062-194B-4197-93D0-2F2DFCCF9420__CHDDDDCF">例3-20所示</a> 。
                        </p>
                     </div>
                     <!-- class="section" -->
                     <div class="example" id="GUID-3F97B062-194B-4197-93D0-2F2DFCCF9420__CHDDDDCF">
                        <p class="titleinexample">示例3-20如何使用terminateStatement（）方法终止语句</p><pre class="oac_no_warn" dir="ltr">Connection :: conn-&gt; terminateStatement（Statement * stmt）;</pre></div>
                     <!-- class="example" -->
                  </div>
               </div>
            </div><a id="LNCPP0034"></a><div class="props_rev_3"><a id="GUID-5FCD0807-65BA-4490-B8F2-E14B24F90D06" name="GUID-5FCD0807-65BA-4490-B8F2-E14B24F90D06"></a><h3 id="LNCPP-GUID-5FCD0807-65BA-4490-B8F2-E14B24F90D06" class="sect3"><span class="enumeration_section">3.4</span>关于OCCI环境中的SQL语句类型</h3>
               <div>
                  <p>OCCI环境中有三种类型的SQL语句：</p>
                  <ul style="list-style-type:disc">
                     <li>
                        <p><a href="accessing-oracle-database-using-cplusplus.html#GUID-3CABD2B8-EE57-4A0A-9053-FB0F40D86A35">关于标准语句</a>使用具有指定值的SQL命令</p>
                     </li>
                     <li>
                        <p><a href="accessing-oracle-database-using-cplusplus.html#GUID-D31E2668-AB49-4D40-808E-74112228E7FB">使用参数化语句</a>具有参数或绑定变量</p>
                     </li>
                     <li>
                        <p><a href="accessing-oracle-database-using-cplusplus.html#GUID-E990D01D-F951-4B70-9C1A-E963455DFCFA">使用可调用语句</a>调用存储的PL / SQL过程和函数</p>
                     </li>
                  </ul>
                  <p><a href="statement-class.html#GUID-DF0FF9BE-6EF5-4D2A-A45D-A6F2FDF6133D">Statement类</a>的方法细分为适用于所有语句，参数化语句和可调用语句的方法。标准语句是参数化语句的超集，参数化语句是可调用语句的超集。
                  </p>
                  <div class="p">本节还包括以下主题：<ul style="list-style-type:disc">
                        <li>
                           <p><a href="accessing-oracle-database-using-cplusplus.html#GUID-DC387A25-350D-4DB5-9CC4-B33B75CBDB50">关于流式读取和写入</a></p>
                        </li>
                        <li>
                           <p><a href="accessing-oracle-database-using-cplusplus.html#GUID-79E65C52-8D1F-4A3F-8E20-3E80EE758495">关于迭代修改行</a></p>
                        </li>
                     </ul>
                  </div>
               </div><a id="LNCPP00341"></a><div class="props_rev_3"><a id="GUID-3CABD2B8-EE57-4A0A-9053-FB0F40D86A35" name="GUID-3CABD2B8-EE57-4A0A-9053-FB0F40D86A35"></a><h4 id="LNCPP-GUID-3CABD2B8-EE57-4A0A-9053-FB0F40D86A35" class="sect4"><span class="enumeration_section">3.4.1</span>关于标准声明</h4>
                  <div>
                     <p><a href="accessing-oracle-database-using-cplusplus.html#GUID-815B3C03-E11C-4C2D-AED1-8BB50D97A0D6__CHDBIFIA">示例3-16</a>和<a href="accessing-oracle-database-using-cplusplus.html#GUID-54F4E6DF-F94C-43D9-83B3-AC631F2EDDF1__CHDCIBJA">示例3-17都</a>演示了<strong class="term">标准</strong> <strong class="term">语句</strong> ，您必须在其中显式定义语句的值。在<a href="accessing-oracle-database-using-cplusplus.html#GUID-815B3C03-E11C-4C2D-AED1-8BB50D97A0D6__CHDBIFIA">示例3-16中</a> ， <code class="codeph">CREATE</code> <code class="codeph">TABLE</code>语句指定表<code class="codeph">shopping_basket</code>的名称。在<a href="accessing-oracle-database-using-cplusplus.html#GUID-54F4E6DF-F94C-43D9-83B3-AC631F2EDDF1__CHDCIBJA">例3-17中</a> ， <code class="codeph">INSERT</code>语句规定了插入表中的值<code class="codeph">('MANGO', 3)</code> 。
                     </p>
                  </div>
               </div><a id="LNCPP20125"></a><a id="LNCPP00342"></a><div class="props_rev_3"><a id="GUID-D31E2668-AB49-4D40-808E-74112228E7FB" name="GUID-D31E2668-AB49-4D40-808E-74112228E7FB"></a><h4 id="LNCPP-GUID-D31E2668-AB49-4D40-808E-74112228E7FB" class="sect4"><span class="enumeration_section">3.4.2</span>使用参数化语句</h4>
                  <div>
                     <div class="section">
                        <p>通过为语句的输入变量设置占位符，可以使用不同的参数执行相同的语句。这些语句称为<span class="bold">参数化语句，</span>因为它们可以接受来自用户或程序的参数输入。
                        </p>
                        <p>如果要使用不同的参数执行<code class="codeph">INSERT</code>语句，则必须首先通过<code class="codeph">Statement</code>对象的<a href="statement-class.html#GUID-66171CB8-85E3-46FB-93D7-FAF6712C704F">setSQL（）</a>方法指定语句，如<a href="accessing-oracle-database-using-cplusplus.html#GUID-246BBE34-DB77-413A-9556-997B1C10AFE0__CHDFFFDA">例3-18所示</a> 。
                        </p>
                        <p>然后调用<code class="codeph">set</code> <span class="italic"><code class="codeph">xxx</code></span> <code class="codeph">()</code>方法来指定参数，其中<span class="italic"><code class="codeph">xxx</code></span>代表参数的类型。如果语句对象的值为<code class="codeph">"INSERT INTO shopping_basket VALUES(:1,:2)"</code> ，如<a href="accessing-oracle-database-using-cplusplus.html#GUID-246BBE34-DB77-413A-9556-997B1C10AFE0__CHDFFFDA">例3-18中</a>所指定，则可以使用<a href="accessing-oracle-database-using-cplusplus.html#GUID-D31E2668-AB49-4D40-808E-74112228E7FB__CHDIBFJF">例3-21中</a>的代码调用<a href="statement-class.html#GUID-652E17A0-8A89-4721-98E2-D5CC5508A590">setString（）</a>方法和<a href="statement-class.html#GUID-5BB80D38-DE07-4FAD-8835-1EAA5023EFDF">setInt （）</a>方法将这些类型的值输入到第一个和第二个参数中，并使用<a href="statement-class.html#GUID-307FAD33-F491-494B-A485-BE266506A83E">executeUpdate（）</a>方法将新行插入表中。您可以通过重新设置参数并再次调用<a href="statement-class.html#GUID-307FAD33-F491-494B-A485-BE266506A83E">executeUpdate（）</a>方法来重用语句对象。如果应用程序重复执行相同的语句，则应避免更改输入参数类型，因为这会启动重新绑定操作，并会影响应用程序性能。
                        </p>
                     </div>
                     <!-- class="section" -->
                     <div class="example" id="GUID-D31E2668-AB49-4D40-808E-74112228E7FB__CHDIBFJF">
                        <p class="titleinexample">示例3-21如何使用setxxx（）方法设置单个列值</p><pre class="oac_no_warn" dir="ltr">stmt-&gt; setString（1，“Banana”）; //第一个参数stmt-&gt; setInt（2,5）的值; //第二个参数的值stmt-&gt; executeUpdate（）; //执行语句...stmt-&gt; setString（1，“Apple”）; //第一个参数的值stmt-&gt; setInt（2,9）; //第二个参数的值stmt-&gt; executeUpdate（）; //执行语句</pre></div>
                     <!-- class="example" -->
                  </div>
               </div><a id="LNCPP20126"></a><a id="LNCPP20127"></a><a id="LNCPP00343"></a><div class="props_rev_3"><a id="GUID-E990D01D-F951-4B70-9C1A-E963455DFCFA" name="GUID-E990D01D-F951-4B70-9C1A-E963455DFCFA"></a><h4 id="LNCPP-GUID-E990D01D-F951-4B70-9C1A-E963455DFCFA" class="sect4"><span class="enumeration_section">3.4.3</span>使用可调用语句</h4>
                  <div>
                     <div class="section">
                        <p>正如其名称所示，PL / SQL存储过程是存储在数据库服务器上以供应用程序重用的过程。在OCCI中， <span class="bold">可调用语句</span>是对包含其他SQL语句的过程的调用。
                        </p>
                        <p>如果要调用过程<code class="codeph">countGroceries()</code> ，它返回指定类型的水果的数量，则必须首先通过<code class="codeph">set</code> <span class="italic"><code class="codeph">XXX</code></span> <code class="codeph">()</code>指定PL / SQL存储过程的输入参数<code class="codeph"> </code> <code class="codeph">Statement</code>类的方法，如<a href="accessing-oracle-database-using-cplusplus.html#GUID-E990D01D-F951-4B70-9C1A-E963455DFCFA__CHDJAABG">例3-22所示</a> 。
                        </p>
                        <p>但是，在调用存储过程之前，必须通过调用<a href="statement-class.html#GUID-E41CF1DF-5F0D-4151-A0C2-C1864696A9B1">registerOutParam（）</a>方法指定任何<code class="codeph">OUT</code>参数的类型和大小，如<a href="accessing-oracle-database-using-cplusplus.html#GUID-E990D01D-F951-4B70-9C1A-E963455DFCFA__CHDCFGBA">例3-23所示</a> 。对于<code class="codeph">IN/OUT</code>参数，使用<code class="codeph">set</code> <span class="italic"><code class="codeph">XXX</code></span> <code class="codeph">()</code>方法传入参数，并<code class="codeph">get</code> <span class="italic"><code class="codeph">XXX</code></span> <code class="codeph">()</code>方法以检索结果。
                        </p>
                        <p>您现在通过调用过程来执行该语句：</p><pre class="oac_no_warn" dir="ltr">stmt-&gt;的executeUpdate（）; //调用程序</pre><p>最后，通过调用相关的<code class="codeph">get</code> <span class="italic">xxx（）</span>方法获取输出参数：</p><pre class="oac_no_warn" dir="ltr">quantity = stmt-&gt; getInt（2）; //获取第二个（OUT）参数的值</pre></div>
                     <!-- class="section" -->
                     <div class="example" id="GUID-E990D01D-F951-4B70-9C1A-E963455DFCFA__CHDJAABG">
                        <p class="titleinexample">示例3-22如何指定PL / SQL存储过程的IN参数</p><pre class="oac_no_warn" dir="ltr">stmt-&gt; setSQL（“BEGIN countGroceries（：1，：2）; END：”）;数量; stmt-&gt; setString（1，“Apple”）; //指定过程的第一个（IN）参数</pre></div>
                     <!-- class="example" -->
                     <div class="example" id="GUID-E990D01D-F951-4B70-9C1A-E963455DFCFA__CHDCFGBA">
                        <p class="titleinexample">示例3-23如何指定PL / SQL存储过程的OUT参数</p><pre class="oac_no_warn" dir="ltr">stmt-&gt; registerOutParam（2，Type :: OCCIINT，sizeof（quantity））; //指定第二个（OUT）参数的类型和大小</pre></div>
                     <!-- class="example" -->
                     <div class="section">本节包括以下主题： <a href="accessing-oracle-database-using-cplusplus.html#GUID-FCF9173E-E216-47ED-A7F5-AD8940B28D2F">使用使用数组参数的可调用语句</a> 。
                     </div>
                     <!-- class="section" -->
                  </div><a id="LNCPP03431"></a><div class="props_rev_3"><a id="GUID-FCF9173E-E216-47ED-A7F5-AD8940B28D2F" name="GUID-FCF9173E-E216-47ED-A7F5-AD8940B28D2F"></a><h5 id="LNCPP-GUID-FCF9173E-E216-47ED-A7F5-AD8940B28D2F" class="sect5"><span class="enumeration_section">3.4.3.1</span>使用使用数组参数的可调用语句</h5>
                     <div>
                        <div class="section">
                           <p>通过可调用语句执行的PL / SQL存储过程可以将值数组作为参数。通过<code class="codeph">setDataBufferArray()</code>方法指定数组中元素的数量和数组中元素的维数。
                           </p>
                           <p>以下示例显示了<code class="codeph">setDataBufferArray()</code>方法：</p><pre class="oac_no_warn" dir="ltr">void setDataBufferArray（unsigned int paramIndex，void * buffer，Type type，ub4 arraySize，ub4 * arrayLength，sb4 elementSize，ub2 * elementLength，sb2 * ind = NULL，ub2 * rc = NULL）;</pre><p>以前的方法示例中使用以下参数：</p>
                        </div>
                        <!-- class="section" -->
                        <div class="section">
                           <ul style="list-style-type:disc">
                              <li>
                                 <p><code class="codeph">paramIndex</code> ：参数号</p>
                              </li>
                              <li>
                                 <p><code class="codeph">buffer</code> ：包含值数组的数据缓冲区</p>
                              </li>
                              <li>
                                 <p><code class="codeph">Type</code> ：数据缓冲区中的数据类型</p>
                              </li>
                              <li>
                                 <p><code class="codeph">arraySize</code> ：数组中的最大元素数</p>
                              </li>
                              <li>
                                 <p><code class="codeph">arrayLength</code> ：数组中的元素数</p>
                              </li>
                              <li>
                                 <p><code class="codeph">elementSize</code> ：数组中当前元素的大小</p>
                              </li>
                              <li>
                                 <p><code class="codeph">elementLength</code> ：指向长度数组的指针。 <code class="codeph">elementLength[i]</code>具有数组第<code class="codeph">i</code>个元素的当前长度</p>
                              </li>
                              <li>
                                 <p><code class="codeph">ind</code> ：指标信息</p>
                              </li>
                              <li>
                                 <p><code class="codeph">rc</code> ：返回代码</p>
                              </li>
                           </ul>
                        </div>
                        <!-- class="section" -->
                     </div>
                  </div>
               </div><a id="LNCPP00344"></a><div class="props_rev_3"><a id="GUID-DC387A25-350D-4DB5-9CC4-B33B75CBDB50" name="GUID-DC387A25-350D-4DB5-9CC4-B33B75CBDB50"></a><h4 id="LNCPP-GUID-DC387A25-350D-4DB5-9CC4-B33B75CBDB50" class="sect4"><span class="enumeration_section">3.4.4</span>关于流式读取和写入</h4>
                  <div>
                     <p>OCCI支持通过将数据分成一系列小块来插入和检索非常大的列的流接口。这种方法最大限度地减少了客户端内存需求。此流接口可以与参数化语句（如<code class="codeph">SELECT</code>和各种DML命令）一起使用，也可以与PL / SQL块中的可调用语句一起使用。流支持的数据类型是<code class="codeph">BLOB</code> ， <code class="codeph">CLOB</code> ， <code class="codeph">LONG</code> ， <code class="codeph">LONG RAW</code> ， <code class="codeph">RAW</code>和<code class="codeph">VARCHAR2</code> 。
                     </p>
                     <p>流数据有三种：</p>
                     <ul style="list-style-type:disc">
                        <li>
                           <p><span class="bold">可写</span>流对应于<code class="codeph">SELECT</code> / DML语句中的绑定变量或可调用语句中的<code class="codeph">IN</code>参数。
                           </p>
                        </li>
                        <li>
                           <p><span class="bold">可读</span>流对应于<code class="codeph">SELECT</code>语句中的<span class="bold">读取</span>列值或可调用语句中的<code class="codeph">OUT</code>参数。
                           </p>
                        </li>
                        <li>
                           <p><span class="bold">双向</span>流对应于<code class="codeph">IN/OUT</code>绑定变量。
                           </p>
                        </li>
                     </ul>
                     <p><a href="stream-class.html#GUID-9B333B43-7008-4514-BF03-F1339179E2C7">Stream Class的</a>方法支持流接口。
                     </p>
                     <p><a href="statement-class.html#GUID-DF0FF9BE-6EF5-4D2A-A45D-A6F2FDF6133D">Statement类</a>的<a href="statement-class.html#GUID-D99B6E90-5DA2-4101-A0F3-91D218683777">getStream（）</a>方法返回一个流对象，该对象支持读写DML和可调用语句：</p>
                     <ul style="list-style-type:disc">
                        <li>
                           <p>对于写入，它将数据传递给绑定变量或<code class="codeph">IN</code>或<code class="codeph">IN/OUT</code>参数</p>
                        </li>
                        <li>
                           <p>对于读取，它从<code class="codeph">OUT</code>或<code class="codeph">IN/OUT</code>参数中获取数据</p>
                        </li>
                     </ul>
                     <p><a href="resultset-class.html#GUID-9E0C0A68-57B7-4C77-8865-A306BF6953CA">ResultSet类</a>的<a href="resultset-class.html#GUID-5055E584-52FC-4BEC-A52D-6790ED9A523F">getStream（）</a>方法返回可用于读取数据的流对象。
                     </p>
                     <p>这些类的<code class="codeph">status()</code>方法确定流操作的状态。
                     </p>
                     <div class="p">本节包括以下主题：<ul style="list-style-type:disc">
                           <li>
                              <p><a href="accessing-oracle-database-using-cplusplus.html#GUID-88199E10-D687-44E2-B3FC-1B1324D68335">在流模式下绑定数据; SELECT / DML和PL / SQL</a></p>
                           </li>
                           <li>
                              <p><a href="accessing-oracle-database-using-cplusplus.html#GUID-C17118B3-59DD-489F-A292-C2DDDD607FB0">在流模式下获取数据：PL / SQL</a></p>
                           </li>
                           <li>
                              <p><a href="accessing-oracle-database-using-cplusplus.html#GUID-6D262A73-DAA3-479D-9EC4-5ED8B82B3BA2">关于以流模式获取数据：ResultSet</a></p>
                           </li>
                           <li>
                              <p><a href="accessing-oracle-database-using-cplusplus.html#GUID-CC19B035-40E3-43B4-BB41-66AE471CB7B3">使用多个流</a></p>
                           </li>
                        </ul>
                     </div>
                  </div><a id="LNCPP20128"></a><a id="LNCPP03441"></a><div class="props_rev_3"><a id="GUID-88199E10-D687-44E2-B3FC-1B1324D68335" name="GUID-88199E10-D687-44E2-B3FC-1B1324D68335"></a><h5 id="LNCPP-GUID-88199E10-D687-44E2-B3FC-1B1324D68335" class="sect5"><span class="enumeration_section">3.4.4.1</span>在流模式下绑定数据; SELECT / DML和PL / SQL</h5>
                     <div>
                        <div class="section">
                           <p>要以流模式绑定数据，请按照下列步骤操作并查看<a href="accessing-oracle-database-using-cplusplus.html#GUID-88199E10-D687-44E2-B3FC-1B1324D68335__BAGGDACI">示例3-24</a> ：</p>
                        </div>
                        <!-- class="section" -->
                        <ol>
                           <li class="stepexpand"><span>使用适当的绑定占位符创建<code class="codeph">SELECT</code> / <code class="codeph">DML</code>或PL / SQL语句。</span></li>
                           <li class="stepexpand"><span>为流模式中使用的每个绑定位置调用<a href="statement-class.html#GUID-DF0FF9BE-6EF5-4D2A-A45D-A6F2FDF6133D">Statement类</a>的<a href="statement-class.html#GUID-B92321AB-D8AD-4094-B2D8-36BB374BE18C">setBinaryStreamMode（）</a>或<a href="statement-class.html#GUID-A3F073E3-722C-4C36-9C9C-EBEA96299D53">setCharacterStreamMode（）</a>方法。如果绑定位置是PL / SQL <code class="codeph">IN</code>或<code class="codeph">IN/OUT</code>参数类型，请通过调用这些方法的三参数版本并将<code class="codeph">inArg</code>参数设置为<code class="codeph">TRUE</code>来指示此情况。</span><div>
                                 <div class="infoboxnote" id="GUID-88199E10-D687-44E2-B3FC-1B1324D68335__GUID-6AC1D6C4-F54B-4AFC-BB77-4FF957F2597D">
                                    <p class="notep1">注意：</p>
                                    <p>对于<code class="codeph">setBinaryStreamMode()</code> ， <code class="codeph">size</code>参数限制为32KB（32,768字节）。
                                    </p>
                                 </div>
                              </div>
                           </li>
                           <li class="stepexpand"><span>执行声明; <a href="statement-class.html#GUID-DF0FF9BE-6EF5-4D2A-A45D-A6F2FDF6133D">Statement类</a>的<a href="statement-class.html#GUID-85F54A05-AD0A-45D2-BECB-EFE513B7F835">status（）</a>方法返回<code class="codeph">NEEDS_STREAM_DATA</code> 。</span></li>
                           <li class="stepexpand"><span>通过<a href="statement-class.html#GUID-DF0FF9BE-6EF5-4D2A-A45D-A6F2FDF6133D">Statement类</a>的<a href="statement-class.html#GUID-D99B6E90-5DA2-4101-A0F3-91D218683777">getStream（）</a>方法获取流对象。</span></li>
                           <li class="stepexpand"><span>使用<a href="stream-class.html#GUID-9B333B43-7008-4514-BF03-F1339179E2C7">Stream Class的</a> <a href="stream-class.html#GUID-61FAB7F9-9A86-4F0B-90DD-D271BB4DCF52">writeBuffer（）</a>和<a href="stream-class.html#GUID-CF06FE24-740C-4798-99F2-F4BB77C67852">writeLastBuffer（）</a>方法来写入数据。</span></li>
                           <li class="stepexpand"><span>使用<a href="statement-class.html#GUID-DF0FF9BE-6EF5-4D2A-A45D-A6F2FDF6133D">Statement类的</a> <a href="statement-class.html#GUID-2222AA0C-EDDB-47C3-8944-EBC62A49709C">closeStream（）</a>方法关闭流。</span></li>
                           <li class="stepexpand"><span>关闭所有流后， <a href="statement-class.html#GUID-DF0FF9BE-6EF5-4D2A-A45D-A6F2FDF6133D">Statement类</a>的<a href="statement-class.html#GUID-85F54A05-AD0A-45D2-BECB-EFE513B7F835">status（）</a>方法将更改为适当的值，例如<code class="codeph">UPDATE_COUNT_AVAILABLE</code> 。</span></li>
                        </ol>
                        <div class="example" id="GUID-88199E10-D687-44E2-B3FC-1B1324D68335__BAGGDACI">
                           <p class="titleinexample">示例3-24如何在流模式下绑定数据</p><pre class="oac_no_warn" dir="ltr">Statement * stmt = conn-&gt; createStatement（“Insert into testtab（longcol）values（：1）”）; // longcol是LONG类型列stmt-&gt; setCharacterStreamMode（1,100000）; stmt-&gt;的executeUpdate（）; Stream * instream = stmt-&gt; getStream（1）; char buffer [1000]; instream-&gt; writeBuffer（buffer，len）; //写数据instream-&gt; writeLastBuffer（buffer，len）; // repeat stmt-&gt; closeStream（instream）; // stmt-&gt; status（）是// UPDATE_COUNT_AVAILABLE语句* stmt = conn-&gt; createStatement（“BEGIN testproc（：1）; END;”）; //如果testproc的参数类型是IN或IN / OUT，则传递TRUE到// setCharacterStreamMode或setBinaryStreamMode stmt-&gt; setBinaryStreamMode（1,32768，TRUE）;</pre></div>
                        <!-- class="example" -->
                     </div>
                  </div><a id="LNCPP20129"></a><a id="LNCPP03442"></a><div class="props_rev_3"><a id="GUID-C17118B3-59DD-489F-A292-C2DDDD607FB0" name="GUID-C17118B3-59DD-489F-A292-C2DDDD607FB0"></a><h5 id="LNCPP-GUID-C17118B3-59DD-489F-A292-C2DDDD607FB0" class="sect5"><span class="enumeration_section">3.4.4.2</span>以流模式获取数据：PL / SQL</h5>
                     <div>
                        <div class="section">
                           <p>要从流模式获取数据，请按照下列步骤操作并查看<a href="accessing-oracle-database-using-cplusplus.html#GUID-C17118B3-59DD-489F-A292-C2DDDD607FB0__BAGJGHAG">示例3-25</a> ：</p>
                        </div>
                        <!-- class="section" -->
                        <ol>
                           <li><span>使用适当的绑定占位符创建<code class="codeph">SELECT</code> / DML语句。</span></li>
                           <li><span>对于从流模式中检索数据的每个绑定位置，调用<a href="statement-class.html#GUID-DF0FF9BE-6EF5-4D2A-A45D-A6F2FDF6133D">Statement类</a>的<a href="statement-class.html#GUID-B92321AB-D8AD-4094-B2D8-36BB374BE18C">setBinaryStreamMode（）</a>或<a href="statement-class.html#GUID-A3F073E3-722C-4C36-9C9C-EBEA96299D53">setCharacterStreamMode（）</a>方法。</span></li>
                           <li><span>执行声明; <a href="statement-class.html#GUID-DF0FF9BE-6EF5-4D2A-A45D-A6F2FDF6133D">Statement类</a>的<a href="statement-class.html#GUID-85F54A05-AD0A-45D2-BECB-EFE513B7F835">status（）</a>方法返回<code class="codeph">STREAM_DATA_AVAILABLE</code> 。</span></li>
                           <li><span>通过<a href="statement-class.html#GUID-DF0FF9BE-6EF5-4D2A-A45D-A6F2FDF6133D">Statement类</a>的<a href="statement-class.html#GUID-D99B6E90-5DA2-4101-A0F3-91D218683777">getStream（）</a>方法获取流对象。</span></li>
                           <li><span>使用<a href="stream-class.html#GUID-9B333B43-7008-4514-BF03-F1339179E2C7">Stream Class的</a> <a href="stream-class.html#GUID-1A9A6E1E-8B17-4070-AFA5-612DE8209DB8">readBuffer（）</a>和<a href="stream-class.html#GUID-19B29E0B-E2AD-4BB4-9FE1-CD49FA5DCFE4">readLastBuffer（）</a>方法读取数据。</span></li>
                           <li><span>使用<a href="statement-class.html#GUID-DF0FF9BE-6EF5-4D2A-A45D-A6F2FDF6133D">Statement类的</a> <a href="statement-class.html#GUID-2222AA0C-EDDB-47C3-8944-EBC62A49709C">closeStream（）</a>方法关闭流。</span></li>
                        </ol>
                        <div class="example" id="GUID-C17118B3-59DD-489F-A292-C2DDDD607FB0__BAGJGHAG">
                           <p class="titleinexample">例3-25如何使用PL / SQL在流模式下获取数据</p><pre class="oac_no_warn" dir="ltr">Statement * stmt = conn-&gt; createStatement（“BEGIN testproc（：1）; END;”）; //参数1是OUT类型stmt-&gt; setCharacterStreamMode（1,100000）; stmt-&gt;执行（）; Stream * outarg = stmt-&gt; getStream（1）; //使用Stream :: readBuffer / readLastBuffer来读取数据</pre></div>
                        <!-- class="example" -->
                     </div>
                  </div><a id="LNCPP03443"></a><div class="props_rev_3"><a id="GUID-6D262A73-DAA3-479D-9EC4-5ED8B82B3BA2" name="GUID-6D262A73-DAA3-479D-9EC4-5ED8B82B3BA2"></a><h5 id="LNCPP-GUID-6D262A73-DAA3-479D-9EC4-5ED8B82B3BA2" class="sect5"><span class="enumeration_section">3.4.4.3</span>关于以流模式获取数据：ResultSet</h5>
                     <div>
                        <p><a href="accessing-oracle-database-using-cplusplus.html#GUID-DC29C08B-E6F6-405D-8B4D-2E4E9D50E196">关于执行SQL查询</a>和<a href="accessing-oracle-database-using-cplusplus.html#GUID-47F74FAE-3146-489E-BBA2-8E80FA365999__BAGBHIFE">示例3-28</a>提供了有关如何将流接口与结果集一起使用的说明。
                        </p>
                     </div>
                  </div><a id="LNCPP20130"></a><a id="LNCPP03444"></a><div class="props_rev_3"><a id="GUID-CC19B035-40E3-43B4-BB41-66AE471CB7B3" name="GUID-CC19B035-40E3-43B4-BB41-66AE471CB7B3"></a><h5 id="LNCPP-GUID-CC19B035-40E3-43B4-BB41-66AE471CB7B3" class="sect5"><span class="enumeration_section">3.4.4.4</span>使用多个流</h5>
                     <div>
                        <div class="section">
                           <p>如果必须使用多个读写流，则必须确保在读取或写入另一个流之前完成对一个流的读取或写入。为了确定流位置，使用<a href="statement-class.html#GUID-AC5614B4-B212-4E2D-89A3-B2778BDB2DA2">getCurrentStreamParam（）</a>的方法<a href="statement-class.html#GUID-DF0FF9BE-6EF5-4D2A-A45D-A6F2FDF6133D">声明类</a>或<a href="resultset-class.html#GUID-0D0F917A-2726-4217-98E7-5D03849B343D">getCurrentStreamColumn（）</a>的方法的<a href="resultset-class.html#GUID-9E0C0A68-57B7-4C77-8865-A306BF6953CA">结果集类</a> 。如果流中的数据可供读取，则<a href="stream-class.html#GUID-9B333B43-7008-4514-BF03-F1339179E2C7">Stream Class</a>的<a href="stream-class.html#GUID-74E67E7D-863F-4894-A8AF-78F9B2BA9AE1">status（）</a>方法返回<code class="codeph">READY_FOR_READ</code>如果已读取所有数据，则返回<code class="codeph">INACTIVE</code> ，如<a href="stream-class.html#GUID-9B333B43-7008-4514-BF03-F1339179E2C7__BBADBFFD" title="第一列列出类使用的属性，第二列描述每个属性可用的选项">表13-45所示</a> 。然后，应用程序可以读取下一个流列。<a href="accessing-oracle-database-using-cplusplus.html#GUID-CC19B035-40E3-43B4-BB41-66AE471CB7B3__CHDDIJDJ">例3-26</a>演示了如何使用两个并发流进行读写。请注意，在同一<code class="codeph">Statement</code>和<code class="codeph">ResultSet</code>对象中不能将这些流接口与<code class="codeph">setDataBuffer()</code>方法一起使用。
                           </p>
                           <div class="infoboxnotealso" id="GUID-CC19B035-40E3-43B4-BB41-66AE471CB7B3__GUID-7997BF5F-4231-4F96-8CA7-E48502EAC7D3">
                              <p class="notep1">也可以看看：</p>
                              <p><span class="q">“ <a href="optimizing-performance-of-cplusplus-applications.html#GUID-96783A66-4018-4CC4-9D9A-36075BB3FF1A">关于应用程序管理数据缓冲</a> ”</span> 
                              </p>
                           </div>
                        </div>
                        <!-- class="section" -->
                        <div class="example" id="GUID-CC19B035-40E3-43B4-BB41-66AE471CB7B3__CHDDIJDJ">
                           <p class="titleinexample">示例3-26如何使用多个流进行读写操作</p><pre class="oac_no_warn" dir="ltr">Statement * stmt = conn-&gt; createStatement（“插入testtab（longcol1，longcol2）值（：1，：2）”）; // longcol1和longcol2是在流模式下插入的2列stmt-&gt; setBinaryStreamMode（1,100000）; stmt-&gt; setBinaryStreamMode（2,32768）; stmt-&gt;的executeUpdate（）; Stream * col1 = stmt-&gt; getStream（1）; Stream * col2 = stmt-&gt; getStream（2）; col1-&gt; writeBuffer（buffer，len）; // first stream ... //完成写入coll stream col1-&gt; writeLastBuffer（buffer，len）; //完成第一个流并移动到col2 col2-&gt; writeBuffer（buffer，len）; //第二个流//读取多个流stmt = conn-&gt; createStatement（“从testtab中选择longcol1，longcol2”）; ResultSet * rs = stmt-&gt; executeQuery（）; rs-&gt; setBinaryStreamMode（1,100000）; rs-&gt; setBinaryStreamMode（2,100000）; while（rs-&gt; next（））{Stream * s1 = rs-&gt; getStream（1）while（s1-&gt; status（）== Stream :: READY_FOR_READ）{s1-&gt; readBuffer（buffer，size）; // process} //第一个流列完成rs-&gt; closeStream（s1）; //移动到下一列。 rs-&gt; getCurrentStreamColumn（）返回2 Stream * s2 = rs-&gt; getStream（2）while（s2-&gt; status（）== Stream :: READY_FOR_READ）{s2-&gt; readBuffer（buffer，size）; // process} //关闭流rs-&gt; closeStream（s2）; }</pre></div>
                        <!-- class="example" -->
                     </div>
                  </div>
               </div><a id="LNCPP00345"></a><div class="props_rev_3"><a id="GUID-79E65C52-8D1F-4A3F-8E20-3E80EE758495" name="GUID-79E65C52-8D1F-4A3F-8E20-3E80EE758495"></a><h4 id="LNCPP-GUID-79E65C52-8D1F-4A3F-8E20-3E80EE758495" class="sect4"><span class="enumeration_section">3.4.5</span>关于迭代修改行</h4>
                  <div>
                     <p>虽然您可以为每一行重复发出<code class="codeph">executeUpdate</code>方法，但OCCI提供了一种有效的机制，可以在单个网络往返中为多行发送数据。使用<code class="codeph">Statement</code>类的<code class="codeph">addIteration()</code>方法执行批处理操作，以便在每次迭代时修改不同的行。
                     </p>
                     <p>要迭代地执行<code class="codeph">INSERT</code> ， <code class="codeph">UPDATE</code>和<code class="codeph">DELETE</code>操作，您必须：</p>
                     <ul style="list-style-type:disc">
                        <li>
                           <p>设置最大迭代次数</p>
                        </li>
                        <li>
                           <p>设置可变长度参数的最大参数大小</p>
                        </li>
                     </ul>
                     <div class="p">本节包括以下主题：<ul style="list-style-type:disc">
                           <li>
                              <p><a href="accessing-oracle-database-using-cplusplus.html#GUID-2CD56A59-32F8-4AA0-B03F-93184EC37F7D">设置最大迭代次数</a></p>
                           </li>
                           <li>
                              <p><a href="accessing-oracle-database-using-cplusplus.html#GUID-E097944D-E06E-491B-A242-618272C82D0A">设置最大参数大小</a></p>
                           </li>
                           <li>
                              <p><a href="accessing-oracle-database-using-cplusplus.html#GUID-4D26DA49-36B8-4018-973A-6961932A968F">执行迭代操作</a></p>
                           </li>
                        </ul>
                     </div>
                  </div><a id="LNCPP03451"></a><div class="props_rev_3"><a id="GUID-2CD56A59-32F8-4AA0-B03F-93184EC37F7D" name="GUID-2CD56A59-32F8-4AA0-B03F-93184EC37F7D"></a><h5 id="LNCPP-GUID-2CD56A59-32F8-4AA0-B03F-93184EC37F7D" class="sect5"><span class="enumeration_section">3.4.5.1</span>设置最大迭代次数</h5>
                     <div>
                        <div class="section">
                           <p>对于迭代执行，首先通过调用<code class="codeph">setMaxIterations()</code>方法指定将对语句执行的最大迭代次数：</p><pre class="oac_no_warn" dir="ltr">Statement-&gt; setMaxIterations（int maxIterations）;</pre><p>您可以通过调用<code class="codeph">getMaxIterations()</code>方法来检索当前的最大迭代设置。
                           </p>
                        </div>
                        <!-- class="section" -->
                     </div>
                  </div><a id="LNCPP03452"></a><div class="props_rev_3"><a id="GUID-E097944D-E06E-491B-A242-618272C82D0A" name="GUID-E097944D-E06E-491B-A242-618272C82D0A"></a><h5 id="LNCPP-GUID-E097944D-E06E-491B-A242-618272C82D0A" class="sect5"><span class="enumeration_section">3.4.5.2</span>设置最大参数大小</h5>
                     <div>
                        <div class="section">
                           <p>如果迭代执行涉及可变长度数据类型（如<code class="codeph">string</code>和<code class="codeph">Bytes</code> ，则必须设置最大参数大小，以便OCCI可以分配最大大小缓冲区：</p><pre class="oac_no_warn" dir="ltr">Statement-&gt; setMaxParamSize（int parameterIndex，int maxParamSize）;</pre><p>您不必为固定长度数据类型（例如<code class="codeph">Number</code>和<code class="codeph">Date</code> ）或使用<code class="codeph">setDataBuffer()</code>方法的参数设置最大参数大小。
                           </p>
                           <p>您可以通过调用<code class="codeph">getMaxParamSize()</code>方法来检索当前的最大参数大小设置。
                           </p>
                        </div>
                        <!-- class="section" -->
                     </div>
                  </div><a id="LNCPP21895"></a><a id="LNCPP03453"></a><div class="props_rev_3"><a id="GUID-4D26DA49-36B8-4018-973A-6961932A968F" name="GUID-4D26DA49-36B8-4018-973A-6961932A968F"></a><h5 id="LNCPP-GUID-4D26DA49-36B8-4018-973A-6961932A968F" class="sect5"><span class="enumeration_section">3.4.5.3</span>执行迭代操作</h5>
                     <div>
                        <div class="section">
                           <p>一旦设置了最大迭代次数和（如果需要）最大参数大小，使用参数化语句的迭代执行很简单，如<a href="accessing-oracle-database-using-cplusplus.html#GUID-4D26DA49-36B8-4018-973A-6961932A968F__CHDHIFJJ">例3-27</a>所示。
                           </p>
                           <p>迭代执行仅设计用于使用标准或参数化语句的<code class="codeph">INSERT</code> ， <code class="codeph">UPDATE</code>和<code class="codeph">DELETE</code>操作。它不能用于可调用的语句和查询。请注意，迭代之间无法更改数据类型。例如，如果对参数<code class="codeph">1</code>使用<code class="codeph">setInt()</code> ，那么在以后的迭代中不能将<code class="codeph">setString()</code>用于相同的参数</p>
                           <p>如示例所示，在每次迭代之后调用<code class="codeph">addIteration()</code>方法，除了last之外，之后调用<code class="codeph">executeUpdate()</code>方法。当然，如果你没有第二行要插入，那么你就不必调用<code class="codeph">addIteration()</code>方法或者对<code class="codeph">set</code> <span class="italic">xxx</span> <code class="codeph">()</code>方法进行后续调用。
                           </p>
                           <p>为了获得<a href="accessing-oracle-database-using-cplusplus.html#GUID-4D26DA49-36B8-4018-973A-6961932A968F__CHDHIFJJ">示例3-27中</a> DML执行中每次迭代所影响的行数，请使用<a href="statement-class.html#GUID-7B2D97C2-E94C-4763-AB93-CADE12F31B5D">setRowCountsOption（）</a>启用该功能，然后使用<a href="statement-class.html#GUID-D56FE118-7929-429C-BF3A-DE4032A7C53A">getDMLRowCounts（）</a>返回行数的向量。对于受影响的总行数，可以使用<a href="statement-class.html#GUID-307FAD33-F491-494B-A485-BE266506A83E">executeUpdate（）</a>的返回值，或调用<a href="statement-class.html#GUID-1C75EC79-01FD-405A-B08E-C53046DF27FA">getUb8RowCount（）</a> 。
                           </p>
                        </div>
                        <!-- class="section" -->
                        <div class="example" id="GUID-4D26DA49-36B8-4018-973A-6961932A968F__CHDHIFJJ">
                           <p class="titleinexample">例3-27如何执行迭代操作</p><pre class="oac_no_warn" dir="ltr">stmt-&gt; setSQL（“INSERT INTO basket_tab VALUES（：1，：2）”）; stmt-&gt; setString（1，“Apples”）; //第一行stmt-&gt; setInt（2,6）的第一个参数的值; //第一行的第二个参数的值stmt-&gt; addIteration（）; //添加迭代stmt-&gt; setString（1，“Oranges”）; //第二行stmt-&gt; setInt（1,4）的第一个参数的值; //第二行stmt-&gt; executeUpdate（）的第二个参数的值; //执行语句</pre></div>
                        <!-- class="example" -->
                     </div>
                  </div>
               </div>
            </div><a id="LNCPP0035"></a><div class="props_rev_3"><a id="GUID-DC29C08B-E6F6-405D-8B4D-2E4E9D50E196" name="GUID-DC29C08B-E6F6-405D-8B4D-2E4E9D50E196"></a><h3 id="LNCPP-GUID-DC29C08B-E6F6-405D-8B4D-2E4E9D50E196" class="sect3"><span class="enumeration_section">3.5</span>关于执行SQL查询</h3>
               <div>
                  <p>SQL查询语句允许应用程序根据指定的约束从数据库请求信息。查询返回结果集。</p>
                  <div class="p">本节包括以下主题：<ul style="list-style-type:disc">
                        <li>
                           <p><a href="accessing-oracle-database-using-cplusplus.html#GUID-47F74FAE-3146-489E-BBA2-8E80FA365999">使用结果集</a></p>
                        </li>
                        <li>
                           <p><a href="accessing-oracle-database-using-cplusplus.html#GUID-EA2E84D1-8438-4743-B658-F657657A9A3D">关于指定查询</a></p>
                        </li>
                        <li>
                           <p><a href="accessing-oracle-database-using-cplusplus.html#GUID-0364D959-7F21-4474-B77A-E6A6B1BF7B9E">关于通过设置预取计数来优化性能</a></p>
                        </li>
                     </ul>
                  </div>
               </div><a id="LNCPP20131"></a><a id="LNCPP00351"></a><div class="props_rev_3"><a id="GUID-47F74FAE-3146-489E-BBA2-8E80FA365999" name="GUID-47F74FAE-3146-489E-BBA2-8E80FA365999"></a><h4 id="LNCPP-GUID-47F74FAE-3146-489E-BBA2-8E80FA365999" class="sect4"><span class="enumeration_section">3.5.1</span>使用结果集</h4>
                  <div>
                     <div class="section">
                        <p>执行数据库查询会将查询结果放入一组称为结果集的行中。在OCCI中，SQL <code class="codeph">SELECT</code>语句由<code class="codeph">Statement</code>类的<code class="codeph">executeQuery</code>方法执行。此方法返回表示查询结果的<code class="codeph">ResultSet</code>对象。
                        </p><pre class="oac_no_warn" dir="ltr">ResultSet * rs = stmt-&gt; executeQuery（“SELECT * FROM basket_tab”）;</pre><p>获得结果集中的数据后，即可对其执行操作。例如，假设您要打印此表的内容。<code class="codeph">ResultSet</code>的<code class="codeph">next()</code>方法用于获取数据， <code class="codeph">get</code> <span class="italic">xxx</span> <code class="codeph">()</code>方法用于检索结果集的各个列，如以下代码示例所示：</p><pre class="oac_no_warn" dir="ltr">cout &lt;&lt;“篮子有：”&lt;&lt; endl; while（rs-&gt; next（））{string fruit = rs-&gt; getString（1）; //将第一列作为字符串输入int quantity = rs-&gt; getInt（2）; //将第二列作为int cout &lt;&lt; quantity &lt;&lt;“”&lt;&lt; fruit &lt;&lt; endl; }</pre><p><code class="codeph">ResultSet</code>类的<code class="codeph">next()</code>和<code class="codeph">status()</code>方法返回<code class="codeph">Status</code> ，如<a href="resultset-class.html#GUID-9E0C0A68-57B7-4C77-8865-A306BF6953CA__BBABCCHB" title="第一列列出类使用的属性，第二列描述每个属性可用的选项">表13-38中</a>所定义。
                        </p>
                        <p>如果数据可用于当前行，则状态为<code class="codeph">DATA_AVAILABLE</code> 。读取完所有数据后，状态将更改为<code class="codeph">END_OF_FETCH</code> 。如果要读取任何输出流，则状态为<code class="codeph">STREAM_DATA_AVAILABLE</code> ，直到成功读取所有流数据。
                        </p>
                        <p><a href="accessing-oracle-database-using-cplusplus.html#GUID-47F74FAE-3146-489E-BBA2-8E80FA365999__BAGBHIFE">示例3-28</a>说明了如何将流数据提取到结果集中，而<span class="q">“ <a href="accessing-oracle-database-using-cplusplus.html#GUID-DC387A25-350D-4DB5-9CC4-B33B75CBDB50">关于流式读取和写入</a> ”部分</span>提供了一般背景。
                        </p>
                     </div>
                     <!-- class="section" -->
                     <div class="example" id="GUID-47F74FAE-3146-489E-BBA2-8E80FA365999__BAGBHIFE">
                        <p class="titleinexample">示例3-28如何使用ResultSet以流模式获取数据</p><pre class="oac_no_warn" dir="ltr">char buffer [4096]; ResultSet * rs = stmt-&gt; executeQuery（“SELECT col1，col2 FROM tab1 WHERE col1 = 11”）; rs-&gt; setCharacterStreamMode（2,10000）; while（rs-&gt; next（））{unsigned int length = 0; unsigned int size = 500; Stream * stream = rs-&gt; getStream（2）; while（stream-&gt; status（）== Stream :: READY_FOR_READ）{length + = stream-&gt; readBuffer（buffer + length，size）; } cout &lt;&lt;“读”&lt;&lt; length &lt;&lt;“字节进入缓冲区”&lt;&lt; endl; }</pre></div>
                     <!-- class="example" -->
                  </div>
               </div><a id="LNCPP00352"></a><div class="props_rev_3"><a id="GUID-EA2E84D1-8438-4743-B658-F657657A9A3D" name="GUID-EA2E84D1-8438-4743-B658-F657657A9A3D"></a><h4 id="LNCPP-GUID-EA2E84D1-8438-4743-B658-F657657A9A3D" class="sect4"><span class="enumeration_section">3.5.2</span>关于指定查询</h4>
                  <div>
                     <p><code class="codeph">IN</code>绑定变量可以与查询一起使用，以在查询的<code class="codeph">WHERE</code>子句中指定约束。例如，以下程序仅打印最小数量为<code class="codeph">4</code> ：</p><pre class="oac_no_warn" dir="ltr">stmt-&gt; setSQL（“SELECT * FROM basket_tab WHERE quantity&gt; =：1”）; int minimumQuantity = 4; stmt-&gt; setInt（1，minimumQuantity）; //设置第一个参数ResultSet * rs = stmt-&gt; executeQuery（）; cout &lt;&lt;“篮子有：”&lt;&lt; endl; while（rs-&gt; next（））cout &lt;&lt; rs-&gt; getInt（2）&lt;&lt;“”&lt;&lt; rs-&gt; getString（1）&lt;&lt; endl;</pre></div>
               </div><a id="LNCPP00353"></a><div class="props_rev_3"><a id="GUID-0364D959-7F21-4474-B77A-E6A6B1BF7B9E" name="GUID-0364D959-7F21-4474-B77A-E6A6B1BF7B9E"></a><h4 id="LNCPP-GUID-0364D959-7F21-4474-B77A-E6A6B1BF7B9E" class="sect4"><span class="enumeration_section">3.5.3</span>关于通过设置预取计数来优化性能</h4>
                  <div>
                     <p>虽然<code class="codeph">ResultSet</code>方法一次检索一行数据，但实际从服务器获取数据不需要为查询的每一行进行网络往返。为了最大限度地提高性能，您可以在每次往返服务器的过程中设置要预取的行数。
                     </p>
                     <p>您可以通过设置要通过<code class="codeph">setPrefetchRowCount(</code> <code class="codeph">)</code>方法预取的行数，或通过设置用于通过<code class="codeph">setPrefetchMemorySize()</code>方法预取的内存大小来实现此目的。
                     </p>
                     <p>如果设置这两个属性，则会预取指定的行数，除非首先达到指定的内存限制。如果首先达到指定的内存限制，则预取将返回与调用<code class="codeph">setPrefetchMemorySize()</code>方法定义的内存空间中的行数相同的行数。
                     </p>
                     <p>默认情况下，打开预取并且数据库始终提取额外的行。要关闭预取，请将预取行数和内存大小都设置为<code class="codeph">0</code> 。
                     </p>
                     <p>如果<code class="codeph">LONG</code> ，LOB或Opaque Type列（例如<code class="codeph">XMLType</code> ）是查询的一部分，则预取不起作用。
                     </p>
                  </div>
               </div>
            </div><a id="LNCPP0036"></a><div class="props_rev_3"><a id="GUID-62119016-0948-4EB3-A7E1-402C2572B5ED" name="GUID-62119016-0948-4EB3-A7E1-402C2572B5ED"></a><h3 id="LNCPP-GUID-62119016-0948-4EB3-A7E1-402C2572B5ED" class="sect3"><span class="enumeration_section">3.6</span>关于动态执行语句</h3>
               <div>
                  <p>当您知道必须执行DML操作时，可以使用<code class="codeph">executeUpdate</code>方法。同样，当您知道必须执行查询时，可以使用<code class="codeph">executeQuery()</code>方法。
                  </p>
                  <p>如果您的应用程序必须允许动态事件，并且您无法确定在运行时必须执行哪个语句，则OCCI提供<code class="codeph">execute()</code>方法。调用<code class="codeph">execute()</code>方法将返回以下状态之一：</p>
                  <ul style="list-style-type:disc">
                     <li>
                        <p><a href="accessing-oracle-database-using-cplusplus.html#GUID-D18CABE4-2486-4D88-B00A-E1172D451DD6">措手不及</a></p>
                     </li>
                     <li>
                        <p><a href="accessing-oracle-database-using-cplusplus.html#GUID-F0822D85-F125-4D08-AFBA-CDE80CC711C0">备</a></p>
                     </li>
                     <li>
                        <p><a href="accessing-oracle-database-using-cplusplus.html#GUID-27463640-48B4-4366-82C6-1720D9ECD129">RESULT_SET_AVAILABLE</a></p>
                     </li>
                     <li>
                        <p><a href="accessing-oracle-database-using-cplusplus.html#GUID-18A7FA96-1320-4A1F-AEFA-4481BD9D8399">UPDATE_COUNT_AVAILABLE</a></p>
                     </li>
                     <li>
                        <p><a href="accessing-oracle-database-using-cplusplus.html#GUID-A2492224-A20F-4303-A669-490DAB19109D">NEEDS_STREAM_DATA</a></p>
                     </li>
                     <li>
                        <p><a href="accessing-oracle-database-using-cplusplus.html#GUID-CD441DFF-0A4C-4E89-B83E-7B2A51D626FE">STREAM_DATA_AVAILABLE</a></p>
                     </li>
                  </ul>
                  <p>在调用<code class="codeph">execute()</code>方法时返回其中一个状态，您可以使用<code class="codeph">status()</code>方法进一步“询问”该语句。
                  </p><pre class="oac_no_warn" dir="ltr">语句stmt = conn-&gt; createStatement（）; Statement :: Status status = stmt-&gt; status（）; //状态为UNPREPARED stmt-&gt; setSQL（“select * from emp”）; status = stmt-&gt; status（）; //状态为PREPARED</pre><p>如果使用SQL字符串创建语句对象，则会以<code class="codeph">PREPARED</code>状态创建它。例如：</p><pre class="oac_no_warn" dir="ltr">语句stmt = conn-&gt; createStatement（“insert into foo（id）values（99）”）; Statement :: Status status = stmt-&gt; status（）; // status为PREPARED status = stmt-&gt; execute（）; //状态为UPDATE_COUNT_AVAILABLE</pre><p>在Statement上设置另一个SQL语句时，状态将更改为<code class="codeph">PREPARED</code> 。例如：</p><pre class="oac_no_warn" dir="ltr">stmt-&gt; setSQL（“select * from emp”）; //状态为PREPARED status = stmt-&gt; execute（）; //状态为RESULT_SET_AVAILABLE</pre><p>本节包括以下主题： <a href="accessing-oracle-database-using-cplusplus.html#GUID-88F58FD7-36B6-4A79-8AF7-0082DF96675A">关于语句状态定义</a> 。
                  </p>
               </div><a id="LNCPP00361"></a><div class="props_rev_3"><a id="GUID-88F58FD7-36B6-4A79-8AF7-0082DF96675A" name="GUID-88F58FD7-36B6-4A79-8AF7-0082DF96675A"></a><h4 id="LNCPP-GUID-88F58FD7-36B6-4A79-8AF7-0082DF96675A" class="sect4"><span class="enumeration_section">3.6.1</span>关于语句状态定义</h4>
                  <div>
                     <p>本节介绍与语句对象相关的<code class="codeph">Status</code>的可能值：</p>
                     <ul style="list-style-type:disc">
                        <li>
                           <p><a href="accessing-oracle-database-using-cplusplus.html#GUID-D18CABE4-2486-4D88-B00A-E1172D451DD6">措手不及</a></p>
                        </li>
                        <li>
                           <p><a href="accessing-oracle-database-using-cplusplus.html#GUID-F0822D85-F125-4D08-AFBA-CDE80CC711C0">备</a></p>
                        </li>
                        <li>
                           <p><a href="accessing-oracle-database-using-cplusplus.html#GUID-27463640-48B4-4366-82C6-1720D9ECD129">RESULT_SET_AVAILABLE</a></p>
                        </li>
                        <li>
                           <p><a href="accessing-oracle-database-using-cplusplus.html#GUID-18A7FA96-1320-4A1F-AEFA-4481BD9D8399">UPDATE_COUNT_AVAILABLE</a></p>
                        </li>
                        <li>
                           <p><a href="accessing-oracle-database-using-cplusplus.html#GUID-A2492224-A20F-4303-A669-490DAB19109D">NEEDS_STREAM_DATA</a></p>
                        </li>
                        <li>
                           <p><a href="accessing-oracle-database-using-cplusplus.html#GUID-CD441DFF-0A4C-4E89-B83E-7B2A51D626FE">STREAM_DATA_AVAILABLE</a></p>
                        </li>
                     </ul>
                  </div><a id="LNCPP20132"></a><div class="props_rev_3"><a id="GUID-D18CABE4-2486-4D88-B00A-E1172D451DD6" name="GUID-D18CABE4-2486-4D88-B00A-E1172D451DD6"></a><h5 id="LNCPP-GUID-D18CABE4-2486-4D88-B00A-E1172D451DD6" class="sect5"><span class="enumeration_section">3.6.1.1</span> UNPREPARED</h5>
                     <div>
                        <p>如果尚未使用<code class="codeph">setSQL()</code>方法将SQL字符串属性设置为语句对象，则该语句处于<code class="codeph">UNPREPARED</code>状态。
                        </p><pre class="oac_no_warn" dir="ltr">语句stmt = conn-&gt; createStatement（）; Statement :: Status status = stmt-&gt; status（）; //状态为UNPREPARED</pre></div>
                  </div><a id="LNCPP20133"></a><div class="props_rev_3"><a id="GUID-F0822D85-F125-4D08-AFBA-CDE80CC711C0" name="GUID-F0822D85-F125-4D08-AFBA-CDE80CC711C0"></a><h5 id="LNCPP-GUID-F0822D85-F125-4D08-AFBA-CDE80CC711C0" class="sect5"><span class="enumeration_section">3.6.1.2</span>准备</h5>
                     <div>
                        <p>如果使用SQL字符串创建Statement，则会以<code class="codeph">PREPARED</code>状态创建它。例如：</p><pre class="oac_no_warn" dir="ltr">语句stmt = conn-&gt; createStatement（“INSERT INTO demo_tab（id）VALUES（99）”）; Statement :: Status status = stmt-&gt; status（）; //状态为PREPARED</pre><p>在<code class="codeph">Statement</code>上设置另一个SQL语句会将状态更改为<code class="codeph">PREPARED</code> 。例如：</p><pre class="oac_no_warn" dir="ltr">status = stmt-&gt; execute（）; // status是UPDATE_COUNT_AVAILABLE stmt-&gt; setSQL（“SELECT * FROM demo_tab”）; //状态为PREPARED</pre></div>
                  </div><a id="LNCPP20134"></a><div class="props_rev_3"><a id="GUID-27463640-48B4-4366-82C6-1720D9ECD129" name="GUID-27463640-48B4-4366-82C6-1720D9ECD129"></a><h5 id="LNCPP-GUID-27463640-48B4-4366-82C6-1720D9ECD129" class="sect5"><span class="enumeration_section">3.6.1.3</span> RESULT_SET_AVAILABLE</h5>
                     <div>
                        <p>状态为<code class="codeph">RESULT_SET_AVAILABLE</code>表示已执行正确配置的查询，并且可通过结果集访问结果。
                        </p>
                        <p>将语句对象设置为查询时，它是<code class="codeph">PREPARED</code> 。执行查询后，语句将更改为<code class="codeph">RESULT_SET_AVAILABLE</code> 。例如：</p><pre class="oac_no_warn" dir="ltr">stmt-&gt; setSQL（“SELECT * from EMP”）; //状态为PREPARED status = stmt-&gt; execute（）; //状态为RESULT_SET_AVAILABLE</pre><p>要访问结果集中的数据，请发出以下语句：</p><pre class="oac_no_warn" dir="ltr">ResultSet * rs = Statement-&gt; getResultSet（）;</pre></div>
                  </div><a id="LNCPP20135"></a><div class="props_rev_3"><a id="GUID-18A7FA96-1320-4A1F-AEFA-4481BD9D8399" name="GUID-18A7FA96-1320-4A1F-AEFA-4481BD9D8399"></a><h5 id="LNCPP-GUID-18A7FA96-1320-4A1F-AEFA-4481BD9D8399" class="sect5"><span class="enumeration_section">3.6.1.4</span> UPDATE_COUNT_AVAILABLE</h5>
                     <div>
                        <p>执行<code class="codeph">PREPARED</code>状态的DDL或DML语句时，其状态将更改为<code class="codeph">UPDATE_COUNT_AVAILABLE</code> ，如以下代码示例所示：</p><pre class="oac_no_warn" dir="ltr">语句stmt = conn-&gt; createStatement（“INSERT INTO demo_tab（id）VALUES（99）”）; Statemnt :: Status status = stmt-&gt; status（）; //状态为PREPARED status = stmt-&gt; execute（）; //状态为UPDATE_COUNT_AVAILABLE</pre><p>此状态是指受执行语句影响的行数。它表明：</p>
                        <ul style="list-style-type:disc">
                           <li>
                              <p>该声明不包括任何输入或输出流。</p>
                           </li>
                           <li>
                              <p>该语句不是查询，而是DDL或DML语句。</p>
                           </li>
                        </ul>
                        <p>您可以通过发出以下语句来获取受影响的行数：</p><pre class="oac_no_warn" dir="ltr">stmt-&gt; getUb8RowCount（）;</pre><p>请注意，DDL语句导致更新计数为零（ <code class="codeph">0</code> ）。类似地，不满足任何匹配条件的更新也会产生零（ <code class="codeph">0</code> ）计数。在这种情况下，您无法确定已从报告的状态执行的语句类型。
                        </p>
                     </div>
                  </div><a id="LNCPP20136"></a><div class="props_rev_3"><a id="GUID-A2492224-A20F-4303-A669-490DAB19109D" name="GUID-A2492224-A20F-4303-A669-490DAB19109D"></a><h5 id="LNCPP-GUID-A2492224-A20F-4303-A669-490DAB19109D" class="sect5"><span class="enumeration_section">3.6.1.5</span> NEEDS_STREAM_DATA</h5>
                     <div>
                        <p>如果要写入任何输出流，则在完全提供所有流数据之前，执行不会完成。在这种情况下，状态更改为<code class="codeph">NEEDS_STREAM_DATA</code>以指示必须写入流。写入流后，调用<a href="statement-class.html#GUID-85F54A05-AD0A-45D2-BECB-EFE513B7F835">status（）</a>方法以查明是否应写入更多流数据，或者执行是否已完成。
                        </p>
                        <p>如果您的语句包含多个流参数，请使用<a href="statement-class.html#GUID-AC5614B4-B212-4E2D-89A3-B2778BDB2DA2">getCurrentStreamParam（）</a>方法来发现必须写入哪个参数。
                        </p>
                        <p>如果执行迭代或数组执行，则<a href="statement-class.html#GUID-D8885EEE-58EE-4886-8B99-1DB718318314">getCurrentStreamIteration（）</a>方法会显示要写入数据的迭代。
                        </p>
                        <p>处理完所有流数据后，状态将更改为<code class="codeph">RESULT_SET_AVAILABLE</code>或<code class="codeph">UPDATE_COUNT_AVAILABLE</code> 。</p>
                     </div>
                  </div><a id="LNCPP20137"></a><div class="props_rev_3"><a id="GUID-CD441DFF-0A4C-4E89-B83E-7B2A51D626FE" name="GUID-CD441DFF-0A4C-4E89-B83E-7B2A51D626FE"></a><h5 id="LNCPP-GUID-CD441DFF-0A4C-4E89-B83E-7B2A51D626FE" class="sect5"><span class="enumeration_section">3.6.1.6</span> STREAM_DATA_AVAILABLE</h5>
                     <div>
                        <p>此状态表示应用程序需要在执行完成之前在<code class="codeph">OUT</code>或<code class="codeph">IN/OUT</code>参数中读取一些流数据。读取流后，调用<code class="codeph">status</code>方法以查明是否应读取更多流数据，或者执行是否已完成。
                        </p>
                        <p>如果您的语句包含多个流参数，请使用<code class="codeph">getCurrentStreamParam()</code>方法来发现必须读取的参数。
                        </p>
                        <p>如果您正在执行迭代或数组执行，则<code class="codeph">getCurrentStreamIteration()</code>方法会显示要从哪个迭代读取数据。
                        </p>
                        <p>处理完所有流数据后，状态将更改为<code class="codeph">UPDATE_COUNT_REMOVE_AVAILABLE</code> 。</p>
                        <p><code class="codeph">ResultSet</code>类还具有可读流，其操作类似于<code class="codeph">Statement</code>类的可读流。
                        </p>
                     </div>
                  </div>
               </div>
            </div><a id="LNCPP21923"></a><div class="props_rev_3"><a id="GUID-BCA292AC-120C-437E-ADC7-B880CBB6351F" name="GUID-BCA292AC-120C-437E-ADC7-B880CBB6351F"></a><h3 id="LNCPP-GUID-BCA292AC-120C-437E-ADC7-B880CBB6351F" class="sect3"><span class="enumeration_section">3.7</span>关于使用较大的行数和错误代码范围数据类型</h3>
               <div>
                  <p>从Oracle Database Release 12 <span class="italic">c开始</span> ，Oracle C ++调用接口支持更大的行数和错误代码范围数据类型。返回较大行数的方法是<a href="statement-class.html#GUID-DF0FF9BE-6EF5-4D2A-A45D-A6F2FDF6133D">Statement Class中的</a> <a href="statement-class.html#GUID-1C75EC79-01FD-405A-B08E-C53046DF27FA">getUb8RowCount（）</a> 。
                  </p>
                  <p>这有两个好处：</p>
                  <ul style="list-style-type:disc">
                     <li>
                        <p>运行影响超过UB4MAXVAL行的语句的应用程序现在可以看到受影响的行数的精确值。</p>
                     </li>
                     <li>
                        <p>从Oracle Database Release 12 <span class="italic">c</span>开始，Oracle数据库可以正确地向应用程序客户端返回较新的错误代码（ <code class="codeph">ORA-65535</code>以上）。较旧的客户端收到一条信息性消息，指示错误代码溢出。
                        </p>
                     </li>
                  </ul>
                  <p>本节包含以下主题：</p>
                  <ul style="list-style-type:disc">
                     <li>
                        <p><span class="q">“ <a href="accessing-oracle-database-using-cplusplus.html#GUID-02FDE14F-C37B-4608-907B-59D9A54D4B2A">在SELECT操作中使用更大的行数</a> ”</span></p>
                     </li>
                     <li>
                        <p><span class="q">“ <a href="accessing-oracle-database-using-cplusplus.html#GUID-F48CAD33-8692-4226-8434-D786E346A50E">在INSERT，UPDATE和DELETE操作中使用更大的行数</a> ”</span></p>
                     </li>
                  </ul>
               </div><a id="LNCPP21925"></a><a id="LNCPP21926"></a><a id="LNCPP21927"></a><a id="LNCPP21924"></a><div class="props_rev_3"><a id="GUID-02FDE14F-C37B-4608-907B-59D9A54D4B2A" name="GUID-02FDE14F-C37B-4608-907B-59D9A54D4B2A"></a><h4 id="LNCPP-GUID-02FDE14F-C37B-4608-907B-59D9A54D4B2A" class="sect4"><span class="enumeration_section">3.7.1</span>在SELECT操作中使用较大的行数</h4>
                  <div>
                     <div class="section">
                        <p>方法<a href="statement-class.html#GUID-1C75EC79-01FD-405A-B08E-C53046DF27FA">getUb8RowCount（）</a>返回执行<code class="codeph">SELECT</code>语句后处理的行数，为<code class="codeph">ub8</code>类型。本节中的示例说明了如何在各种<code class="codeph">SELECT</code>方案中使用<a href="statement-class.html#GUID-1C75EC79-01FD-405A-B08E-C53046DF27FA">getUb8RowCount（）</a> 。
                        </p>
                     </div>
                     <!-- class="section" -->
                     <div class="section">
                        <ul style="list-style-type:disc">
                           <li>
                              <p>在<a href="accessing-oracle-database-using-cplusplus.html#GUID-02FDE14F-C37B-4608-907B-59D9A54D4B2A__BGBIGEEC">例3-29中</a>最简单的场景中，受影响的行数与获取的行数相同。
                              </p>
                           </li>
                           <li>
                              <p>设置prefetch选项后，如<a href="accessing-oracle-database-using-cplusplus.html#GUID-02FDE14F-C37B-4608-907B-59D9A54D4B2A__BGBBEJHJ">例3-30所示</a> ，它包括预取的行数。
                              </p>
                           </li>
                           <li>
                              <p>通过调用<a href="statement-class.html#GUID-064167EB-D6AC-4107-B3E5-B5881C48A28B">setDataBuffer（）</a>接口在<a href="accessing-oracle-database-using-cplusplus.html#GUID-02FDE14F-C37B-4608-907B-59D9A54D4B2A__BGBFEFGC">示例3-31中</a>使用数组提取机制时， <a href="statement-class.html#GUID-1C75EC79-01FD-405A-B08E-C53046DF27FA">getUb8RowCount（）</a>返回提取到用户缓冲区中的总行数，与prefetch选项无关。
                              </p>
                           </li>
                        </ul>
                     </div>
                     <!-- class="section" -->
                     <div class="example" id="GUID-02FDE14F-C37B-4608-907B-59D9A54D4B2A__BGBIGEEC">
                        <p class="titleinexample">例3-29使用getUb8RowCount（）进行SELECT;简单</p>
                        <p>受影响的行数是已提取的行数。</p><pre class="oac_no_warn" dir="ltr">oraub8 largeRowCount = 0; Statement * stmt = conn-&gt; createStatement（“SELECT salary FROM employees”）; ResultSet * rs = stmt-&gt; executeQuery（）; RS-&gt;下（）; largeRowCount = stmt-&gt; getUb8RowCount（）;</pre></div>
                     <!-- class="example" -->
                     <div class="example" id="GUID-02FDE14F-C37B-4608-907B-59D9A54D4B2A__BGBBEJHJ">
                        <p class="titleinexample">例3-30使用getUb8RowCount（）进行SELECT;预取</p>
                        <p>这里受影响的行数与先前迭代中获取的行数相同，加上<code class="codeph">next()</code>调用中预取的行数。
                        </p><pre class="oac_no_warn" dir="ltr">oraub8 largeRowCount = 0; Statement * stmt = conn-&gt; createStatement（“SELECT salary FROM employees”）; stmt  - &gt; setPrefetchRowCount（prefetch_count）; ResultSet * rs = stmt-&gt; executeQuery（）; RS-&gt;下（）; largeRowCount = stmt-&gt; getUb8RowCount（）;</pre></div>
                     <!-- class="example" -->
                     <div class="example" id="GUID-02FDE14F-C37B-4608-907B-59D9A54D4B2A__BGBFEFGC">
                        <p class="titleinexample">例3-31使用getUb8RowCount（）进行SELECT;使用预取的数组提取</p>
                        <p>这里受影响的行数（ <code class="codeph">largeRowCount</code>值）是在先前迭代中提取到用户缓冲区的行数加上在<code class="codeph">next(max)</code>或<code class="codeph">next()</code>调用中获取的行数。它独立于预取的值。
                        </p><pre class="oac_no_warn" dir="ltr">oraub8 largeRowCount = 0; Statement * stmt = conn-&gt; createStatement（“SELECT col1 FROM table1”）; int max = 20; int prefetch_count = 10; ub2 lengthC1 [max]; ub4 c1 [max]; for（i = 0; i &lt;max; ++ i）{c1 [i] = 0; lengthC1 [i] = sizeof（c1 [i]）; } stmt  - &gt; setPrefetchRowCount（prefetch_count）; ResultSet * rs = stmt-&gt; executeQuery（）; rs-&gt; setDataBuffer（1，c1，OCCIINT，sizeof（ub4），lengthC1）; RS-&gt;下一个（最大值）; largeRowCount = stmt-&gt; getUb8RowCount（）;</pre></div>
                     <!-- class="example" -->
                  </div>
               </div><a id="LNCPP21929"></a><a id="LNCPP21930"></a><a id="LNCPP21931"></a><a id="LNCPP21928"></a><div class="props_rev_3"><a id="GUID-F48CAD33-8692-4226-8434-D786E346A50E" name="GUID-F48CAD33-8692-4226-8434-D786E346A50E"></a><h4 id="LNCPP-GUID-F48CAD33-8692-4226-8434-D786E346A50E" class="sect4"><span class="enumeration_section">3.7.2</span>在INSERT，UPDATE和DELETE操作中使用较大的行数</h4>
                  <div>
                     <div class="section">
                        <p>对于<code class="codeph">INSERT</code> ， <code class="codeph">UPDATE</code>和<code class="codeph">DELETE</code>语句，方法<a href="statement-class.html#GUID-1C75EC79-01FD-405A-B08E-C53046DF27FA">getUb8RowCount（）</a>返回最近语句处理的行数。
                        </p>
                     </div>
                     <!-- class="section" -->
                     <div class="example" id="GUID-F48CAD33-8692-4226-8434-D786E346A50E__GUID-9CE4D2E2-82E3-4B06-930C-C284E89A7C48">
                        <p class="titleinexample">例3-32使用getUb8RowCount（）进行INSERT;简单</p>
                        <p><code class="codeph">largeRowCount</code>的值是插入的行数，即<code class="codeph">1</code> 。
                        </p><pre class="oac_no_warn" dir="ltr">oraub8 largeRowCount = 0; Statement * stmt = conn-&gt; createStatement（“INSERT INTO table1 values（：1）”）; stmt-&gt; setNumber（1,100）; stmt-&gt;的executeUpdate（）; largeRowCount = stmt-&gt; getUb8RowCount（）;</pre></div>
                     <!-- class="example" -->
                     <div class="example" id="GUID-F48CAD33-8692-4226-8434-D786E346A50E__GUID-CDFF446C-E50C-4166-A636-EA291C4B2977">
                        <p class="titleinexample">例3-33使用getUb8RowCount（）INSERT;迭代</p>
                        <p>这里<code class="codeph">largeRowCount</code>的值等于<code class="codeph">max</code> 。
                        </p><pre class="oac_no_warn" dir="ltr">int max; oraub8 largeRowCount = 0; Statement * stmt = conn-&gt; createStatement（“INSERT INTO table1 values（：1）”）; stmt-&gt; setMaxIterations（max）; for（i = 0; i &lt;max-1; i ++）{stmt-&gt; setNumber（1,100）; stmt-&gt; addIteration（）; } stmt-&gt; setNumber（1,100）; stmt-&gt;的executeUpdate（）; largeRowCount = stmt-&gt; getUb8RowCount（）;</pre></div>
                     <!-- class="example" -->
                     <div class="example" id="GUID-F48CAD33-8692-4226-8434-D786E346A50E__GUID-E581F223-CFAC-48EB-BCC1-48ED3EA21C02">
                        <p class="titleinexample">例3-34使用getUb8RowCount（）更新UPDATE</p>
                        <p>这里<code class="codeph">largeRowCount</code>的值是更新的行数。
                        </p><pre class="oac_no_warn" dir="ltr">oraub8 largeRowCount = 0; Statement * stmt = conn-&gt; createStatement（“UPDATE table1 SET COL1 = COL1 + 100 WHERE COL1 =：1”）; stmt-&gt; setNumber（1,200）; stmt-&gt;的executeUpdate（）; largeRowCount = stmt-&gt; getUb8RowCount（）;</pre></div>
                     <!-- class="example" -->
                  </div>
               </div>
            </div><a id="LNCPP0037"></a><div class="props_rev_3"><a id="GUID-C8520AA3-6F82-4F91-BDA5-829F2A6A799D" name="GUID-C8520AA3-6F82-4F91-BDA5-829F2A6A799D"></a><h3 id="LNCPP-GUID-C8520AA3-6F82-4F91-BDA5-829F2A6A799D" class="sect3"><span class="enumeration_section">3.8</span>关于提交交易</h3>
               <div>
                  <p>所有SQL DML语句都在事务的上下文中执行。应用程序通过提交事务或通过执行回滚撤消它们，使这些语句所做的更改成为永久更改。虽然可以使用<code class="codeph">executeUpdate()</code>方法执行SQL <code class="codeph">COMMIT</code>和<code class="codeph">ROLLBACK</code>语句，但您也可以调用<code class="codeph">Connection::commit()</code>和<code class="codeph">Connection::rollback()</code>方法。
                  </p>
                  <p>如果您希望立即提交DML更改，可以通过发出以下语句来打开<code class="codeph">Statement</code>类的自动提交模式：</p><pre class="oac_no_warn" dir="ltr">声明::的setAutoCommit（TRUE）;</pre><p>一旦自动提交生效，每个更改将自动成为永久更改。这类似于在每次执行后立即发出提交。</p>
                  <p>要返回默认模式，请自动提交，发出以下语句：</p><pre class="oac_no_warn" dir="ltr">声明::的setAutoCommit（FALSE）;</pre></div>
            </div><a id="LNCPP20138"></a><a id="LNCPP20139"></a><a id="LNCPP0038"></a><div class="props_rev_3"><a id="GUID-4F6F6E83-B68E-42C0-92CE-1A2DBB95C0D8" name="GUID-4F6F6E83-B68E-42C0-92CE-1A2DBB95C0D8"></a><h3 id="LNCPP-GUID-4F6F6E83-B68E-42C0-92CE-1A2DBB95C0D8" class="sect3"><span class="enumeration_section">3.9</span>缓存语句</h3>
               <div>
                  <div class="section">
                     <p>语句缓存功能可在会话中建立和管理语句缓存。它通过在服务器端有效地使用准备好的游标并消除重复的语句解析来提高应用程序的性能和可伸缩性。</p>
                     <p>语句缓存可以与连接和会话池一起使用，也可以不使用连接池。有关典型使用方案，请查看<a href="accessing-oracle-database-using-cplusplus.html#GUID-4F6F6E83-B68E-42C0-92CE-1A2DBB95C0D8__BAGDAIFH">示例3-35</a>和<a href="accessing-oracle-database-using-cplusplus.html#GUID-4F6F6E83-B68E-42C0-92CE-1A2DBB95C0D8__CHDGGCDG">示例3-36</a> 。
                     </p>
                  </div>
                  <!-- class="section" -->
                  <div class="example" id="GUID-4F6F6E83-B68E-42C0-92CE-1A2DBB95C0D8__BAGDAIFH">
                     <p class="titleinexample">示例3-35没有连接池的语句缓存</p>
                     <p>这些步骤和附带的伪代码实现了语句缓存功能，而不使用连接池：</p>
                     <ol>
                        <li>
                           <p>通过在<code class="codeph">Environment</code>对象上进行<a href="environment-class.html#GUID-A2D499B0-5494-48F0-AFBE-974351E3C9DA">createConnection（）</a>调用来创建<code class="codeph">Connection</code> 。
                           </p><pre class="oac_no_warn" dir="ltr">Connection * conn = env-&gt; createConnection（username，password，connecstr）;</pre></li>
                        <li>
                           <p>通过在<a href="connection-class.html#GUID-68836B2A-7F4E-4140-AEDD-3822F012AB94">setStmtCacheSize（）</a>调用中使用非零<code class="codeph">size</code>参数在<code class="codeph">Connection</code>对象上启用语句高速缓存。
                           </p><pre class="oac_no_warn" dir="ltr">conn-&gt; setStmtCacheSize（10）;</pre><p>对<a href="connection-class.html#GUID-58BEA22D-4153-45A9-A4D4-85073E3D11E3">getStmtCacheSize（）的</a>后续调用将确定缓存的大小，而<a href="connection-class.html#GUID-68836B2A-7F4E-4140-AEDD-3822F012AB94">setStmtCacheSize（）</a>调用将更改语句高速缓存的<code class="codeph">size</code> ，或者如果<code class="codeph">size</code>参数设置为零，则禁用语句高速缓存。
                           </p>
                        </li>
                        <li>
                           <p>通过对<code class="codeph">Connection</code>对象进行<a href="connection-class.html#GUID-8A15A5D0-7B8D-41FD-8A4C-68C92ECB998A">createStatement（）</a>调用来创建<code class="codeph">Statement</code> ;如果它在缓存中，则返回<code class="codeph">Statement</code> ，或者为用户创建带有<code class="codeph">NULL</code>标记的新<code class="codeph">Statement</code> 。
                           </p><pre class="oac_no_warn" dir="ltr">Statement * stmt = conn-&gt; createStatement（sql）;</pre><p>要检索以前缓存的标记语句，请使用<a href="connection-class.html#GUID-8A15A5D0-7B8D-41FD-8A4C-68C92ECB998A">createStatement（）</a>方法的替代形式：</p><pre class="oac_no_warn" dir="ltr">Statement * stmt = conn-&gt; createStatement（sql，tag）;</pre></li>
                        <li>
                           <p>使用该语句执行SQL命令并获取结果。</p>
                        </li>
                        <li>
                           <p>将语句返回缓存。</p><pre class="oac_no_warn" dir="ltr">conn-&gt; terminateStatement（stmt，tag）;</pre><p>如果您不想缓存此语句，请使用<a href="statement-class.html#GUID-B8A0A8B5-BE7C-421E-923D-C1C0438540ED">disableCaching（）</a>调用和<a href="connection-class.html#GUID-DC3E71A2-9BD4-418D-96AD-CBE05EE9B2BE">terminateStatement（）中</a>的替换：</p><pre class="oac_no_warn" dir="ltr">stmt-&gt; disableCaching（）; conn-&gt; terminateStatement（语句）;</pre><p>如果必须验证语句是否已缓存，请在<code class="codeph">Connection</code>对象上发出<a href="connection-class.html#GUID-43B40857-C45D-4FEE-8BD8-20E009961C68">isCached（）</a>调用。
                           </p>
                           <p>您可以选择在发布时标记语句，然后将其重用于具有相同标记的另一个语句。标签用于搜索缓存。标记为<code class="codeph">NULL</code>的未标记语句是标记语句的特例。如果两个语句的标记不同，并且只标记其中一个语句，则认为它们不同。
                           </p>
                        </li>
                        <li>
                           <p>终止连接。</p>
                        </li>
                     </ol>
                  </div>
                  <!-- class="example" -->
                  <div class="example" id="GUID-4F6F6E83-B68E-42C0-92CE-1A2DBB95C0D8__CHDGGCDG">
                     <p class="titleinexample">示例3-36使用连接池进行语句缓存</p>
                     <p>这些步骤和附带的伪代码使用连接池实现语句缓存功能。</p>
                     <p>仅对<code class="codeph">setStmtCacheSize()</code>调用后创建的连接启用语句高速缓存。
                     </p>
                     <p>如果未在池级别启用语句cac.hing，则仍可以为池中的各个连接实现它。</p>
                     <ol>
                        <li>
                           <p>通过调用<code class="codeph">Environment</code>对象的<a href="environment-class.html#GUID-8F76AF49-C633-47AA-AE17-0859D4239B74">createConnectionPool（）</a>来创建<code class="codeph">ConnectionPool</code> 。
                           </p><pre class="oac_no_warn" dir="ltr">ConnectionPool * conPool = env-&gt; createConnectionPool（username，password，connecstr，minConn，maxConn，incrConn）;</pre><p>如果使用<code class="codeph">StatelessConnectionPool</code> ，则调用<a href="environment-class.html#GUID-0CC9175A-255B-49ED-A23B-5BE924603BE7">createStatelessConnectionPool（）</a> 。<code class="codeph">ConnectionPool</code>和<code class="codeph">StatelessConnectionPool</code>对象的后续操作相同。
                           </p><pre class="oac_no_warn" dir="ltr">Stateless ConnectionPool * conPool = env-&gt; createStatelessConnectionPool（username，password，connecstr，minConn，maxConn，incrConn，mode）;</pre></li>
                        <li>
                           <p>启用所有语句缓存<code class="codeph">Connection</code>在S <code class="codeph">ConnectionPool</code>用非零<code class="codeph">size</code>的参数<a href="connection-class.html#GUID-68836B2A-7F4E-4140-AEDD-3822F012AB94">setStmtCacheSize（）</a>调用。
                           </p><pre class="oac_no_warn" dir="ltr">conPool-&gt; setStmtCacheSize（10）;</pre><p>对<a href="connection-class.html#GUID-58BEA22D-4153-45A9-A4D4-85073E3D11E3">getStmtCacheSize（）的</a>后续调用将确定缓存的大小，而<a href="connection-class.html#GUID-68836B2A-7F4E-4140-AEDD-3822F012AB94">setStmtCacheSize（）</a>调用将更改语句高速缓存的<code class="codeph">size</code> ，或者如果<code class="codeph">size</code>参数设置为零，则禁用语句高速缓存。
                           </p>
                        </li>
                        <li>
                           <p>得到一个<code class="codeph">Connection</code>通过使从池中<a href="connectionpool-class.html#GUID-BBFDE876-7B7B-44BC-8542-DBD2D901349D">的createConnection（）</a>的调用上的<code class="codeph">ConnectionPool</code>对象;如果它在缓存中，则返回<code class="codeph">Statement</code> ，或者为用户创建带有<code class="codeph">NULL</code>标记的新<code class="codeph">Statement</code> 。
                           </p><pre class="oac_no_warn" dir="ltr">Connection * conn = conPool-&gt; createConnection（username，password，connecstr）;</pre><p>要检索以前缓存的标记语句，请使用<a href="connection-class.html#GUID-8A15A5D0-7B8D-41FD-8A4C-68C92ECB998A">createStatement（）</a>方法的替代形式：</p><pre class="oac_no_warn" dir="ltr">Statement * stmt = conn-&gt; createStatement（sql，tag）;</pre></li>
                        <li>
                           <p>通过对<code class="codeph">Connection</code>对象进行<a href="connection-class.html#GUID-8A15A5D0-7B8D-41FD-8A4C-68C92ECB998A">createStatement（）</a>调用来创建<code class="codeph">Statement</code> ;如果它在缓存中，则返回<code class="codeph">Statement</code> ，或者为用户创建带有<code class="codeph">NULL</code>标记的新<code class="codeph">Statement</code> 。
                           </p><pre class="oac_no_warn" dir="ltr">Statement * stmt = conn-&gt; createStatement（sql）;</pre><p>要检索以前缓存的标记语句，请使用<a href="connection-class.html#GUID-8A15A5D0-7B8D-41FD-8A4C-68C92ECB998A">createStatement（）</a>方法的替代形式：</p><pre class="oac_no_warn" dir="ltr">Statement * stmt = conn-&gt; createStatement（sql，tag）;</pre></li>
                        <li>
                           <p>使用该语句执行SQL命令并获取结果。</p>
                        </li>
                        <li>
                           <p>将语句返回缓存。</p><pre class="oac_no_warn" dir="ltr">conn-&gt; terminateStatement（stmt，tag）;</pre><p>如果您不想缓存此语句，请使用<a href="statement-class.html#GUID-B8A0A8B5-BE7C-421E-923D-C1C0438540ED">disableCaching（）</a>调用和<a href="connection-class.html#GUID-DC3E71A2-9BD4-418D-96AD-CBE05EE9B2BE">terminateStatement（）中</a>的替换：</p><pre class="oac_no_warn" dir="ltr">stmt-&gt; disableCaching（）; conn-&gt; terminateStatement（语句）;</pre><p>如果必须验证语句是否已缓存，请在<code class="codeph">Connection</code>对象上发出<a href="connection-class.html#GUID-43B40857-C45D-4FEE-8BD8-20E009961C68">isCached（）</a>调用。
                           </p>
                        </li>
                        <li>
                           <p>释放连接<a href="connectionpool-class.html#GUID-B4659D71-9402-4BE9-A8E8-E0730B7313F0">terminateConnection（）</a> 。
                           </p><pre class="oac_no_warn" dir="ltr">conPool-&gt; terminateConnection（conn）;在</pre></li>
                     </ol>
                  </div>
                  <!-- class="example" -->
               </div>
            </div><a id="LNCPP0039"></a><div class="props_rev_3"><a id="GUID-92553E64-8CDF-42EA-B74B-0277C009E4C2" name="GUID-92553E64-8CDF-42EA-B74B-0277C009E4C2"></a><h3 id="LNCPP-GUID-92553E64-8CDF-42EA-B74B-0277C009E4C2" class="sect3"><span class="enumeration_section">3.10</span>关于处理异常</h3>
               <div>
                  <p>如果不成功，每个OCCI方法都可以生成异常。此异常的类型为<code class="codeph">SQLException</code> 。OCCI使用C ++标准模板库（STL），因此OCCI方法也可以抛出STL可以抛出的任何异常。
                  </p>
                  <p>STL异常派生自标准异常类。<code class="codeph">exception::what()</code>方法返回指向错误文本的指针。在catch块期间，错误文本保证有效</p>
                  <p><code class="codeph">SQLException</code>类包含Oracle特定的错误号和消息。它派生自标准异常类，因此它也可以通过使用<code class="codeph">exception::what()</code>方法获取错误文本。
                  </p>
                  <p>此外， <code class="codeph">SQLException</code>类有两个可用于获取错误信息的方法。<code class="codeph">getErrorCode()</code>方法返回Oracle错误号。可以通过<code class="codeph">getMessage()</code>方法获取<code class="codeph">exception::what()</code>返回的相同错误文本。<code class="codeph">getMessage()</code>方法返回一个STL字符串，以便可以像任何其他STL字符串一样进行复制。
                  </p>
                  <p>根据您的错误处理策略，您可以选择以不同于标准异常的方式处理OCCI异常，或者您可以选择不区分这两者。</p>
                  <p>如果您认为区分OCCI异常和标准异常并不重要，则catch块可能类似于以下内容：</p><pre class="oac_no_warn" dir="ltr">catch（exception＆excp）{cerr &lt;&lt; excp.what（）&lt;&lt; endl; }</pre><p>如果您决定以不同于标准异常的方式处理OCCI异常，则catch块可能如下所示：</p><pre class="oac_no_warn" dir="ltr">catch（SQLException＆sqlExcp）{cerr &lt;&lt; sqlExcp.getErrorCode &lt;&lt;“：”&lt;&lt; sqlExcp.getErrorMessage（）&lt;&lt; endl; } catch（exception＆excp）{cerr &lt;&lt; excp.what（）&lt;&lt; endl; }</pre><p>在前面的catch块中，第一个块捕获SQL异常，第二个块捕获非SQL异常。如果要反转这两个块的顺序，则永远不会捕获SQL异常。由于<code class="codeph">SQLException</code>是从标准异常派生的，因此标准异常catch块也会处理SQL异常。
                  </p>
                  <div class="infoboxnotealso" id="GUID-92553E64-8CDF-42EA-B74B-0277C009E4C2__GUID-AEE17C39-C1A7-4112-B4E1-6899AB7148DF">
                     <p class="notep1">也可以看看：</p>
                     <ul style="list-style-type:disc">
                        <li>
                           <p>用于处理批量更新期间出现的错误的特殊功能的说明，在<span class="q">“</span> <a href="optimizing-performance-of-cplusplus-applications.html#GUID-0901F6D0-F5DE-462A-A367-EE2C2AA55698" title="Traffic Director Mode中的Oracle Connection Manager是一个放置在支持的数据库客户端和数据库实例之间的代理。">优化C ++应用程序的性能</a> <span class="q">”</span>中的<span class="q">“ <a href="optimizing-performance-of-cplusplus-applications.html#GUID-B406B496-9395-4D76-899F-71E414B68FB9">逐步修改行</a> ”</span>一节中进行了描述</p>
                        </li>
                        <li>
                           <p>有关Oracle错误消息的详细信息，请参阅<a href="../errmg/index.html" target="_blank"><span><cite>Oracle数据库错误消息参考</cite></span></a>
                           </p>
                        </li>
                     </ul>
                  </div>
                  <p>本节包括以下主题： <a href="accessing-oracle-database-using-cplusplus.html#GUID-F4FDE43D-3D59-4115-93B9-FEE01CD86059">关于处理空和截断数据</a> 。
                  </p>
               </div><a id="LNCPP20140"></a><a id="LNCPP20141"></a><a id="LNCPP20142"></a><a id="LNCPP00391"></a><div class="props_rev_3"><a id="GUID-F4FDE43D-3D59-4115-93B9-FEE01CD86059" name="GUID-F4FDE43D-3D59-4115-93B9-FEE01CD86059"></a><h4 id="LNCPP-GUID-F4FDE43D-3D59-4115-93B9-FEE01CD86059" class="sect4"><span class="enumeration_section">3.10.1</span>关于处理空和截断数据</h4>
                  <div>
                     <p>通常，当使用<code class="codeph">ResultSet</code>类或<code class="codeph">Statement</code>类的<code class="codeph">get</code> <span class="italic"><code class="codeph">xxx</code></span> <code class="codeph">()</code>方法检索的数据值为<code class="codeph">NULL</code>或截断时，OCCI不会导致异常。但是，可以通过调用<code class="codeph">setErrorOnNull()</code>方法或<code class="codeph">setErrorOnTruncate()</code>方法来更改此行为。如果使用<code class="codeph">causeException=TRUE</code>调用<code class="codeph">setError</code> <span class="italic"><code class="codeph">xxx</code></span> <code class="codeph">()</code>方法，则在数据值为<code class="codeph">NULL</code>或截断时引发<code class="codeph">SQLException</code> 。
                     </p>
                     <p>默认行为不是引发<code class="codeph">SQLException</code> 。列或参数值也可以为<code class="codeph">NULL</code> ，由对<code class="codeph">ResultSet</code>或<code class="codeph">Statement</code>对象的<code class="codeph">isNull()</code>调用返回<code class="codeph">TRUE</code> ：</p><pre class="oac_no_warn" dir="ltr">RS-&gt; ISNULL（columnIndex）; stmt-&gt; ISNULL（paramIndex）;</pre><p>如果列或参数值被截断，它也返回<code class="codeph">TRUE</code> ，由<code class="codeph">ResultSet</code>或<code class="codeph">Statement</code>对象上的<code class="codeph">isTruncated()</code>调用确定：</p><pre class="oac_no_warn" dir="ltr">RS-&gt; isTruncated（columnIndex）; stmt-&gt; isTruncated（paramIndex）;</pre><p>对于通过<code class="codeph">setDataBuffer()</code>方法和<code class="codeph">setDataBufferArray()</code>方法检索的数据，异常处理行为由指标变量的存在与否以及返回代码变量控制，如<a href="accessing-oracle-database-using-cplusplus.html#GUID-F4FDE43D-3D59-4115-93B9-FEE01CD86059__G1023705" title="第1列列出了是否提供的返回码，第2列是未提供的指示符变量，列出了返回的错误，第3列是提供的指示符变量，列出了返回的错误。">表3-1</a> ， <a href="accessing-oracle-database-using-cplusplus.html#GUID-F4FDE43D-3D59-4115-93B9-FEE01CD86059__G1023721" title="第1列列出了是否提供的返回码，第2列是未提供的指示符变量，列出了返回的错误，第3列是提供的指示符变量，列出了返回的错误。">表3-2</a>和<a href="accessing-oracle-database-using-cplusplus.html#GUID-F4FDE43D-3D59-4115-93B9-FEE01CD86059__G1023603" title="第1列列出了是否提供的返回码，第2列是未提供的指示符变量，列出了返回的错误，第3列是提供的指示符变量，列出了返回的错误。">表3-3所示。</a> 。
                     </p>
                     <div class="tblformal" id="GUID-F4FDE43D-3D59-4115-93B9-FEE01CD86059__G1023705">
                        <p class="titleintable">表3-1正常数据 - 非空和未截断</p>
                        <table cellpadding="4" cellspacing="0" class="Formal" title="正常数据 - 不是空的而不是截断的" width="100%" border="1" summary="Column 1 lists the return code whether it is provided or not, column 2 is the indicator variable is not provided and lists the error returned, and column 3 is the indicator variable is provided and lists the error returned." frame="hsides" rules="rows">
                           <thead>
                              <tr align="left" valign="top">
                                 <th align="left" valign="bottom" width="30%" id="d12382e6837">退货代码</th>
                                 <th align="left" valign="bottom" width="33%" id="d12382e6840">指标 - 未提供</th>
                                 <th align="left" valign="bottom" width="38%" id="d12382e6844">指标 - 已提供</th>
                              </tr>
                           </thead>
                           <tbody>
                              <tr align="left" valign="top">
                                 <td align="left" valign="top" width="30%" id="d12382e6850" headers="d12382e6837 ">
                                    <p><span class="bold">不提供</span></p>
                                 </td>
                                 <td align="left" valign="top" width="33%" headers="d12382e6850 d12382e6840 "><pre class="oac_no_warn" dir="ltr">错误= 0</pre></td>
                                 <td align="left" valign="top" width="38%" headers="d12382e6850 d12382e6844 "><pre class="oac_no_warn" dir="ltr">error = 0指标= 0</pre></td>
                              </tr>
                              <tr align="left" valign="top">
                                 <td align="left" valign="top" width="30%" id="d12382e6861" headers="d12382e6837 ">
                                    <p><span class="bold">提供</span></p>
                                 </td>
                                 <td align="left" valign="top" width="33%" headers="d12382e6861 d12382e6840 "><pre class="oac_no_warn" dir="ltr">error = 0返回码= 0</pre></td>
                                 <td align="left" valign="top" width="38%" headers="d12382e6861 d12382e6844 "><pre class="oac_no_warn" dir="ltr">error = 0 indicator = 0返回码= 0</pre></td>
                              </tr>
                           </tbody>
                        </table>
                     </div>
                     <!-- class="inftblhruleinformal" -->
                     <div class="tblformal" id="GUID-F4FDE43D-3D59-4115-93B9-FEE01CD86059__G1023721">
                        <p class="titleintable">表3-2空数据</p>
                        <table cellpadding="4" cellspacing="0" class="Formal" title="空数据" width="100%" border="1" summary="Column 1 lists the return code whether it is provided or not, column 2 is the indicator variable is not provided and lists the error returned, and column 3 is the indicator variable is provided and lists the error returned." frame="hsides" rules="rows">
                           <thead>
                              <tr align="left" valign="top">
                                 <th align="left" valign="bottom" width="30%" id="d12382e6882">退货代码</th>
                                 <th align="left" valign="bottom" width="33%" id="d12382e6885">指标 - 未提供</th>
                                 <th align="left" valign="bottom" width="38%" id="d12382e6889">指标 - 已提供</th>
                              </tr>
                           </thead>
                           <tbody>
                              <tr align="left" valign="top">
                                 <td align="left" valign="top" width="30%" id="d12382e6895" headers="d12382e6882 ">
                                    <p><span class="bold">不提供</span></p>
                                 </td>
                                 <td align="left" valign="top" width="33%" headers="d12382e6895 d12382e6885 "><pre class="oac_no_warn" dir="ltr">SQLException错误= 1405</pre></td>
                                 <td align="left" valign="top" width="38%" headers="d12382e6895 d12382e6889 "><pre class="oac_no_warn" dir="ltr">error = 0指标= -1</pre></td>
                              </tr>
                              <tr align="left" valign="top">
                                 <td align="left" valign="top" width="30%" id="d12382e6906" headers="d12382e6882 ">
                                    <p><span class="bold">提供</span></p>
                                 </td>
                                 <td align="left" valign="top" width="33%" headers="d12382e6906 d12382e6885 "><pre class="oac_no_warn" dir="ltr">SQLException错误= 1405返回码= 1405</pre></td>
                                 <td align="left" valign="top" width="38%" headers="d12382e6906 d12382e6889 "><pre class="oac_no_warn" dir="ltr">error = 0指示符= -1返回代码= 1405</pre></td>
                              </tr>
                           </tbody>
                        </table>
                     </div>
                     <!-- class="inftblhruleinformal" -->
                     <div class="tblformal" id="GUID-F4FDE43D-3D59-4115-93B9-FEE01CD86059__G1023603">
                        <p class="titleintable">表3-3截断数据</p>
                        <table cellpadding="4" cellspacing="0" class="Formal" title="截断数据" width="100%" border="1" summary="Column 1 lists the return code whether it is provided or not, column 2 is the indicator variable is not provided and lists the error returned, and column 3 is the indicator variable is provided and lists the error returned." frame="hsides" rules="rows">
                           <thead>
                              <tr align="left" valign="top">
                                 <th align="left" valign="bottom" width="30%" id="d12382e6927">退货代码</th>
                                 <th align="left" valign="bottom" width="33%" id="d12382e6930">指标 - 未提供</th>
                                 <th align="left" valign="bottom" width="38%" id="d12382e6934">指标 - 已提供</th>
                              </tr>
                           </thead>
                           <tbody>
                              <tr align="left" valign="top">
                                 <td align="left" valign="top" width="30%" id="d12382e6940" headers="d12382e6927 ">
                                    <p><span class="bold">不提供</span></p>
                                 </td>
                                 <td align="left" valign="top" width="33%" headers="d12382e6940 d12382e6930 "><pre class="oac_no_warn" dir="ltr">SQLException错误= 1406</pre></td>
                                 <td align="left" valign="top" width="38%" headers="d12382e6940 d12382e6934 "><pre class="oac_no_warn" dir="ltr">SQLException error = 1406 indicator = data_len</pre></td>
                              </tr>
                              <tr align="left" valign="top">
                                 <td align="left" valign="top" width="30%" id="d12382e6951" headers="d12382e6927 ">
                                    <p><span class="bold">提供</span></p>
                                 </td>
                                 <td align="left" valign="top" width="33%" headers="d12382e6951 d12382e6930 "><pre class="oac_no_warn" dir="ltr">错误= 24345返回代码= 1405</pre></td>
                                 <td align="left" valign="top" width="38%" headers="d12382e6951 d12382e6934 "><pre class="oac_no_warn" dir="ltr">error = 24345 indicator = data_len返回码= 1406</pre></td>
                              </tr>
                           </tbody>
                        </table>
                     </div>
                     <!-- class="inftblhruleinformal" -->
                     <p>在<a href="accessing-oracle-database-using-cplusplus.html#GUID-F4FDE43D-3D59-4115-93B9-FEE01CD86059__G1023603" title="第1列列出了是否提供的返回码，第2列是未提供的指示符变量，列出了返回的错误，第3列是提供的指示符变量，列出了返回的错误。">表3-3中</a> ， <code class="codeph">data_len</code>是如果此长度小于或等于<code class="codeph">SB2MAXVAL</code> ，则已截断的数据的实际长度。否则，指标设置为<code class="codeph">-2</code> 。
                     </p>
                  </div>
               </div>
            </div>
         </div>
      </article>
   </body>
</html>