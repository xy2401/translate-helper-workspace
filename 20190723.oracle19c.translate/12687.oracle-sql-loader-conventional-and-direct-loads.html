<html lang="en-us" dir="ltr" xml:lang="en-us">
   <head>
      <meta http-equiv="Content-Type" content="text/html; charset=utf-8"></meta>
      <meta name="viewport" content="width=device-width, initial-scale=1"></meta>
      <meta http-equiv="X-UA-Compatible" content="IE=edge"></meta>
      <meta name="abstract" content="SQL*Loader provides a conventional path load method and a direct path load method."></meta>
      <meta name="description" content="SQL*Loader provides a conventional path load method and a direct path load method."></meta>
      <title>常规和直接路径负载</title>
      <meta property="og:site_name" content="Oracle Help Center"></meta>
      <meta property="og:title" content="Utilities "></meta>
      <meta property="og:description" content="SQL*Loader provides a conventional path load method and a direct path load method."></meta>
      <link rel="stylesheet" href="/sp_common/book-template/ohc-book-template/css/book.css"></link>
      <link rel="shortcut icon" href="/sp_common/book-template/ohc-common/img/favicon.ico"></link>
      <meta name="application-name" content="Utilities"></meta>
      <meta name="generator" content="DITA Open Toolkit version 1.8.5 (Mode = doc)"></meta>
      <meta name="plugin" content="SP_docbuilder HTML plugin release 18.2.2"></meta>
      <link rel="alternate" href="database-utilities.pdf" title="PDF File" type="application/pdf"></link>
      <meta name="robots" content="all"></meta>
      <link rel="schema.dcterms" href="http://purl.org/dc/terms/"></link>
      <meta name="dcterms.created" content="2019-04-23T19:07:17-07:00"></meta>
      
      <meta name="dcterms.dateCopyrighted" content="2002, 2019"></meta>
      <meta name="dcterms.category" content="database"></meta>
      <meta name="dcterms.identifier" content="E96081-02"></meta>
      
      <meta name="dcterms.product" content="en/database/oracle/oracle-database/19"></meta>
      
      <link rel="prev" href="loading-objects-oracle-sql-loader.html" title="Previous" type="text/html"></link>
      <link rel="next" href="oracle-sql-loader-express-mode.html" title="Next" type="text/html"></link>
      <script>
        document.write('<style type="text/css">');
        document.write('body > .noscript, body > .noscript ~ * { visibility: hidden; }');
        document.write('</style>');
     </script>
      <script src="/sp_common/book-template/requirejs/require.js" data-main="/sp_common/book-template/ohc-book-template/js/book-config"></script>
      <script>
            if (window.require === undefined) {
                document.write('<script data-main="sp_common/book-template/ohc-book-template/js/book-config" src="sp_common/book-template/requirejs/require.js"><\/script>');
                document.write('<link href="sp_common/book-template/ohc-book-template/css/book.css" rel="stylesheet"/>');
            }
        </script>
      <script type="application/json" id="ssot-metadata">{"primary":{"category":{"short_name":"database","element_name":"Database","display_in_url":true},"suite":{"short_name":"oracle","element_name":"Oracle","display_in_url":true},"product_group":{"short_name":"not-applicable","element_name":"Not applicable","display_in_url":false},"product":{"short_name":"oracle-database","element_name":"Oracle Database","display_in_url":true},"release":{"short_name":"19","element_name":"Release 19","display_in_url":true}}}</script>
      
    <meta name="dcterms.title" content="Database Utilities"></meta>
    <meta name="dcterms.isVersionOf" content="SUTIL"></meta>
    <meta name="dcterms.release" content="Release 19"></meta>
  </head>
   <body dir="ltr">
      <div class="noscript alert alert-danger text-center" role="alert">
         <a href="loading-objects-oracle-sql-loader.html" class="pull-left"><span class="glyphicon glyphicon-chevron-left" aria-hidden="true"></span>上一页</a> <a href="oracle-sql-loader-express-mode.html" class="pull-right">下一页<span class="glyphicon glyphicon-chevron-right" aria-hidden="true"></span></a> <span class="fa fa-exclamation-triangle" aria-hidden="true"></span>必须启用JavaScript才能正确显示此内容</div>
      <article>
         <header>
            <ol class="breadcrumb" vocab="http://schema.org/" typeof="BreadcrumbList">
               <li property="itemListElement" typeof="ListItem"><a href="index.html" property="item" typeof="WebPage"><span property="name">公用事业</span></a></li>
               <li property="itemListElement" typeof="ListItem"><a href="oracle-sql-loader.html" property="item" typeof="WebPage"><span property="name">使用SQL * Loader</span></a></li>
               <li class="active" property="itemListElement" typeof="ListItem">常规和直接路径负载</li>
            </ol>
            <a id="GUID-321928FB-C86C-4F1F-9250-05111A988B7B" name="GUID-321928FB-C86C-4F1F-9250-05111A988B7B"></a><a id="SUTIL009"></a>
            
            <h2 id="SUTIL-GUID-321928FB-C86C-4F1F-9250-05111A988B7B" class="sect2"><span class="enumeration_chapter">12</span>传统和直接路径负载</h2>
         </header>
         <div class="ind">
            <div>
               <p>SQL * Loader提供了传统的路径加载方法和直接路径加载方法。</p>
               <p>以下主题提供了有关每种方法的更多信息：</p>
               <p>有关使用直接路径加载方法的示例，请参阅案例研究6，使用直接路径加载方法加载数据。其他情况使用传统的路径加载方法。（有关如何访问<a href="oracle-sql-loader-concepts.html#GUID-96DDFFBB-7BFD-4370-A43C-0211A24FA323" title="SQL*Loader features are illustrated in a variety of case studies.">案例研究</a>的信息，请参阅<a href="oracle-sql-loader-concepts.html#GUID-96DDFFBB-7BFD-4370-A43C-0211A24FA323" title="SQL * Loader功能在各种案例研究中有所说明。">SQL * Loader案例</a>研究。）
               </p>
            </div>
            <div>
               <ul class="ullinks">
                  <li class="ulchildlink"><a href="oracle-sql-loader-conventional-and-direct-loads.html#GUID-9787AA3E-1640-4039-BB98-8374BE3553A2">数据加载方法</a><br>SQL * Loader可以使用约定路径加载或直接路径加载来加载数据。
                  </li>
                  <li class="ulchildlink"><a href="oracle-sql-loader-conventional-and-direct-loads.html#GUID-495C502D-4A1F-47B3-9E4D-F6F997EDAC4C">常规路径负载</a><br>常规路径加载（默认）使用SQL <code class="codeph">INSERT</code>语句和绑定数组缓冲区将数据加载到数据库表中。
                  </li>
                  <li class="ulchildlink"><a href="oracle-sql-loader-conventional-and-direct-loads.html#GUID-26686C49-D768-4F55-8AED-771B9A8C6552">直接路径加载</a><br>直接路径加载使用直接路径API将要加载的数据传递到服务器中的加载引擎。
                  </li>
                  <li class="ulchildlink"><a href="oracle-sql-loader-conventional-and-direct-loads.html#GUID-1F89DC04-53CE-41FD-A2B4-1BBB3459C9F2">使用直接路径加载</a><br>本节介绍如何使用SQL * Loader直接路径加载方法。
                  </li>
                  <li class="ulchildlink"><a href="oracle-sql-loader-conventional-and-direct-loads.html#GUID-C9F61197-5786-402B-A592-02515AA30FFF">优化直接路径负载的性能</a><br>您可以控制直接路径加载期间使用的时间和临时存储。
                  </li>
                  <li class="ulchildlink"><a href="oracle-sql-loader-conventional-and-direct-loads.html#GUID-DD798855-A0A3-4676-800A-984FE8F7FDAF">优化多CPU系统的直接路径负载</a><br>如果要在多CPU系统上执行直接路径加载，则SQL * Loader默认使用多线程。在这种情况下，多CPU系统被定义为具有两个或更多CPU的单个系统。
                  </li>
                  <li class="ulchildlink"><a href="oracle-sql-loader-conventional-and-direct-loads.html#GUID-DD1AA9FC-B775-42E2-9BD9-5E43056A1418">避免索引维护</a><br>对于常规路径和直接路径，SQL * Loader维护表的所有现有索引。
                  </li>
                  <li class="ulchildlink"><a href="oracle-sql-loader-conventional-and-direct-loads.html#GUID-973925DA-8F86-49C1-A707-4564DC3B57AE">直接路径加载，完整性约束和触发器</a><br>使用传统的路径加载方法，使用标准SQL <code class="codeph">INSERT</code>语句插入行数组;自动应用完整性约束和插入触发器。
                  </li>
                  <li class="ulchildlink"><a href="oracle-sql-loader-conventional-and-direct-loads.html#GUID-ECBC6D01-4273-4102-983A-2139C5FB2887">并行数据加载模型</a><br>本主题描述并行数据加载模型。
                  </li>
                  <li class="ulchildlink"><a href="oracle-sql-loader-conventional-and-direct-loads.html#GUID-D2838CE7-9E98-42FD-A5B0-FACEB40AD98C">一般绩效改进提示</a><br>本主题描述了一般性能改进的提示。
                  </li>
               </ul>
               <div class="familylinks">
                  <div class="parentlink">
                     <p><strong>父主题：</strong> <a href="oracle-sql-loader.html#GUID-8D037494-07FA-4226-B507-E1B2ED10C144">SQL * Loader</a></p>
                  </div>
               </div>
            </div>
            <a id="SUTIL3404"></a><a id="SUTIL1283"></a><div class="props_rev_3"><a id="GUID-9787AA3E-1640-4039-BB98-8374BE3553A2" name="GUID-9787AA3E-1640-4039-BB98-8374BE3553A2"></a><h3 id="SUTIL-GUID-9787AA3E-1640-4039-BB98-8374BE3553A2" class="sect3"><span class="enumeration_section">12.1</span>数据加载方法</h3>
               <div>
                  <p>SQL * Loader可以使用约定路径加载或直接路径加载来加载数据。</p>
                  <p>传统的路径加载执行SQL <code class="codeph">INSERT</code>语句以填充Oracle数据库中的表。直接路径加载通过格式化Oracle数据块并将数据块直接写入数据库文件来消除大部分Oracle数据库开销。直接加载不会与其他用户竞争数据库资源，因此它通常可以以接近磁盘的速度加载数据。
                  </p>
                  <p>要加载的表必须已存在于数据库中。SQL * Loader从不创建表。它加载已包含数据或为空的现有表。</p>
                  <p>加载需要以下权限：</p>
                  <ul style="list-style-type:disc">
                     <li>
                        <p>您必须对要加载的表具有<code class="codeph">INSERT</code>权限。
                        </p>
                     </li>
                     <li>
                        <p>在使用<code class="codeph">REPLACE</code>或<code class="codeph">TRUNCATE</code>选项清空表中的旧数据之前，必须对要加载的表具有<code class="codeph">DELETE</code>权限，然后才能在其位置加载新数据。
                        </p>
                     </li>
                  </ul>
               </div>
               <div>
                  <ul class="ullinks">
                     <li class="ulchildlink"><a href="oracle-sql-loader-conventional-and-direct-loads.html#GUID-628A6D43-DA99-4677-9B88-445928933246">加载ROWID列</a><br>在常规路径和直接路径中，您可以为<code class="codeph">ROWID</code>列指定文本值。
                     </li>
                  </ul>
                  <div class="infoboxnotealso" id="GUID-9787AA3E-1640-4039-BB98-8374BE3553A2__GUID-E702EDA9-D948-4E03-BE20-AA052B1B312D">
                     <p class="notep1">也可以看看：</p>
                     <p><a href="oracle-sql-loader-conventional-and-direct-loads.html#GUID-495C502D-4A1F-47B3-9E4D-F6F997EDAC4C" title="常规路径加载（默认）使用SQL INSERT语句和绑定数组缓冲区将数据加载到数据库表中。">常规路径负载</a></p>
                     <p><a href="oracle-sql-loader-conventional-and-direct-loads.html#GUID-26686C49-D768-4F55-8AED-771B9A8C6552" title="直接路径加载使用直接路径API将要加载的数据传递到服务器中的加载引擎。">直接路径加载</a></p>
                  </div>
                  <div class="familylinks">
                     <div class="parentlink">
                        <p><strong>父主题：</strong> <a href="oracle-sql-loader-conventional-and-direct-loads.html#GUID-321928FB-C86C-4F1F-9250-05111A988B7B" title="SQL * Loader提供了传统的路径加载方法和直接路径加载方法。">常规路径加载和直接路径加载</a></p>
                     </div>
                  </div>
               </div>
               <a id="SUTIL1284"></a><div class="props_rev_3"><a id="GUID-628A6D43-DA99-4677-9B88-445928933246" name="GUID-628A6D43-DA99-4677-9B88-445928933246"></a><h4 id="SUTIL-GUID-628A6D43-DA99-4677-9B88-445928933246" class="sect4"><span class="enumeration_section">12.1.1</span>加载ROWID列</h4>
                  <div>
                     <p>在常规路径和直接路径中，您可以为<code class="codeph">ROWID</code>列指定文本值。
                     </p>
                     <p>这与执行<code class="codeph">SELECT</code> <code class="codeph">ROWID</code> <code class="codeph">FROM</code> <code class="codeph">table_name</code>操作时获得的文本相同。<code class="codeph">ROWID</code>字符串解释<code class="codeph">ROWID</code>转换为表中列的<code class="codeph">ROWID</code>类型。
                     </p>
                  </div>
                  <div>
                     <div class="familylinks">
                        <div class="parentlink">
                           <p><strong>父主题：</strong> <a href="oracle-sql-loader-conventional-and-direct-loads.html#GUID-9787AA3E-1640-4039-BB98-8374BE3553A2" title="SQL * Loader可以使用约定路径加载或直接路径加载来加载数据。">数据加载方法</a></p>
                        </div>
                     </div>
                  </div>
                  
               </div>
            </div><a id="SUTIL1285"></a><div class="props_rev_3"><a id="GUID-495C502D-4A1F-47B3-9E4D-F6F997EDAC4C" name="GUID-495C502D-4A1F-47B3-9E4D-F6F997EDAC4C"></a><h3 id="SUTIL-GUID-495C502D-4A1F-47B3-9E4D-F6F997EDAC4C" class="sect3"><span class="enumeration_section">12.2</span>常规路径负载</h3>
               <div>
                  <p>常规路径加载（默认）使用SQL <code class="codeph">INSERT</code>语句和绑定数组缓冲区将数据加载到数据库表中。
                  </p>
                  <p>当SQL * Loader执行传统路径加载时，它与缓冲区资源的所有其他进程同等竞争。这可以显着减慢负载。在生成SQL语句，传递到Oracle数据库并执行时，会添加额外的开销。</p>
                  <p>Oracle数据库查找部分填充的块并尝试在每个插入上填充它们。尽管在正常使用期间是合适的，但这可以显着减缓批量负荷</p>
               </div>
               <div>
                  <ul class="ullinks">
                     <li class="ulchildlink"><a href="oracle-sql-loader-conventional-and-direct-loads.html#GUID-E05BB042-29A4-4861-9E21-C72D558E0C7B">单个分区的常规路径负载</a><br>SQL * Loader使用<code class="codeph">INSERT</code>语句的分区扩展语法。
                     </li>
                     <li class="ulchildlink"><a href="oracle-sql-loader-conventional-and-direct-loads.html#GUID-A8911483-65C5-4348-886C-1C607CACA486">何时使用常规路径加载</a><br>如何确定何时应使用常规路径负载而不是直接路径负载。
                     </li>
                  </ul>
                  <div class="infoboxnotealso" id="GUID-495C502D-4A1F-47B3-9E4D-F6F997EDAC4C__GUID-217E8FAE-0918-4C27-8FF8-EABC6C77FC37">
                     <p class="notep1">也可以看看：</p>
                     <p><a href="oracle-sql-loader-control-file-contents.html#GUID-80B5F24F-9FCE-4502-B8BD-2260F25036F0" title="在传统的路径加载中，在将绑定数组中的所有数据加载到所有表中之后提交数据。">已停止的常规路径载荷</a></p>
                  </div>
                  <div class="familylinks">
                     <div class="parentlink">
                        <p><strong>父主题：</strong> <a href="oracle-sql-loader-conventional-and-direct-loads.html#GUID-321928FB-C86C-4F1F-9250-05111A988B7B" title="SQL * Loader提供了传统的路径加载方法和直接路径加载方法。">常规路径加载和直接路径加载</a></p>
                     </div>
                  </div>
               </div>
               <a id="SUTIL1286"></a><div class="props_rev_3"><a id="GUID-E05BB042-29A4-4861-9E21-C72D558E0C7B" name="GUID-E05BB042-29A4-4861-9E21-C72D558E0C7B"></a><h4 id="SUTIL-GUID-E05BB042-29A4-4861-9E21-C72D558E0C7B" class="sect4"><span class="enumeration_section">12.2.1</span>单个分区的常规路径负载</h4>
                  <div>
                     <p>SQL * Loader使用<code class="codeph">INSERT</code>语句的分区扩展语法。
                     </p>
                     <p>根据定义，传统的路径加载使用SQL <code class="codeph">INSERT</code>语句。在单个分区的传统路径加载期间，SQL * Loader使用<code class="codeph">INSERT</code>语句的分区扩展语法，该语法具有以下形式：</p><pre class="oac_no_warn" dir="ltr">插入表格T分区（P）值...</pre><p>Oracle内核的SQL层确定正在插入的行是否映射到指定的分区。如果该行未映射到该分区，则该行将被拒绝，并且SQL * Loader日志文件将记录相应的错误消息。</p>
                  </div>
                  <div>
                     <div class="familylinks">
                        <div class="parentlink">
                           <p><strong>父主题：</strong> <a href="oracle-sql-loader-conventional-and-direct-loads.html#GUID-495C502D-4A1F-47B3-9E4D-F6F997EDAC4C" title="常规路径加载（默认）使用SQL INSERT语句和绑定数组缓冲区将数据加载到数据库表中。">常规路径加载</a></p>
                        </div>
                     </div>
                  </div>
                  
               </div><a id="SUTIL1287"></a><div class="props_rev_3"><a id="GUID-A8911483-65C5-4348-886C-1C607CACA486" name="GUID-A8911483-65C5-4348-886C-1C607CACA486"></a><h4 id="SUTIL-GUID-A8911483-65C5-4348-886C-1C607CACA486" class="sect4"><span class="enumeration_section">12.2.2</span>何时使用常规路径负载</h4>
                  <div>
                     <p>如何确定何时应使用常规路径负载而不是直接路径负载。</p>
                     <p>如果加载速度对您来说最重要，那么您应该使用直接路径加载，因为它比传统路径加载更快。但是，对直接路径负载的某些限制可能需要您使用传统的路径负载。在以下情况下应使用常规路径负载：</p>
                     <ul style="list-style-type:disc">
                        <li>
                           <p>在与负载同时访问索引表时，或者在与负载同时对非索引表应用插入或更新时</p>
                           <p>要使用直接路径加载（并行加载除外），SQL * Loader必须具有对表的独占写访问权以及对任何索引的独占读/写访问权。</p>
                        </li>
                        <li>
                           <p>将数据加载到群集表时</p>
                           <p>直接路径加载不支持加载群集表。</p>
                        </li>
                        <li>
                           <p>将相对较少的行加载到大型索引表中时</p>
                           <p>在直接路径加载期间，现有索引在与新索引键合并时将被复制。如果现有索引非常大并且新键的数量非常小，则索引复制时间可以抵消直接路径加载所节省的时间。</p>
                        </li>
                        <li>
                           <p>将相对较少数量的行加载到具有引用和列检查完整性约束的大型表中时</p>
                           <p>由于这些约束无法应用于直接路径上加载的行，因此在加载期间会禁用它们。然后在加载完成时将它们应用于整个表。成本可能超过非常大的表和少量新行的节省。</p>
                        </li>
                        <li>
                           <p>加载记录时，您希望确保在以下任何情况下拒绝记录：</p>
                           <ul style="list-style-type:disc">
                              <li>
                                 <p>如果记录在插入时导致Oracle错误</p>
                              </li>
                              <li>
                                 <p>如果记录格式不正确，则SQL * Loader无法找到字段边界</p>
                              </li>
                              <li>
                                 <p>如果记录违反约束或尝试使唯一索引非唯一</p>
                              </li>
                           </ul>
                        </li>
                     </ul>
                  </div>
                  <div>
                     <div class="familylinks">
                        <div class="parentlink">
                           <p><strong>父主题：</strong> <a href="oracle-sql-loader-conventional-and-direct-loads.html#GUID-495C502D-4A1F-47B3-9E4D-F6F997EDAC4C" title="常规路径加载（默认）使用SQL INSERT语句和绑定数组缓冲区将数据加载到数据库表中。">常规路径加载</a></p>
                        </div>
                     </div>
                  </div>
                  
               </div>
            </div><a id="SUTIL1288"></a><div class="props_rev_3"><a id="GUID-26686C49-D768-4F55-8AED-771B9A8C6552" name="GUID-26686C49-D768-4F55-8AED-771B9A8C6552"></a><h3 id="SUTIL-GUID-26686C49-D768-4F55-8AED-771B9A8C6552" class="sect3"><span class="enumeration_section">12.3</span>直接路径负载</h3>
               <div>
                  <p>直接路径加载使用直接路径API将要加载的数据传递到服务器中的加载引擎。</p>
                  <p>直接路径加载使用直接路径API将要加载的数据传递到服务器中的加载引擎，而不是填充绑定数组缓冲区并使用SQL <code class="codeph">INSERT</code>语句将其传递到Oracle数据库。加载引擎根据传递给它的数据构建列数组结构。
                  </p>
                  <p>直接路径加载引擎使用列数组结构来格式化Oracle数据块并构建索引键。新格式化的数据库块直接写入数据库（如果主机平台支持异步I / O，则使用异步写入每个I / O请求多个块）。</p>
                  <p>在内部，多个缓冲区用于格式化的块。在填充一个缓冲区时，如果主机平台上有异步I / O，则正在写入一个或多个缓冲区。使用I / O重叠计算可提高负载性能。</p>
               </div>
               <div>
                  <ul class="ullinks">
                     <li class="ulchildlink"><a href="oracle-sql-loader-conventional-and-direct-loads.html#GUID-70EC05F4-1301-4CF3-A4DE-24011AC3F2A9">直接路径加载期间的数据转换</a><br>在直接路径加载期间，数据转换发生在客户端而不是服务器端。
                     </li>
                     <li class="ulchildlink"><a href="oracle-sql-loader-conventional-and-direct-loads.html#GUID-777AE140-80AE-4A7F-B521-BF64A9E035F9">分区或子分区表的直接路径负载</a><br>加载分区或子分区表时，SQL * Loader会对行进行分区并维护索引（也可以对其进行分区）。
                     </li>
                     <li class="ulchildlink"><a href="oracle-sql-loader-conventional-and-direct-loads.html#GUID-85756D79-AA1E-444C-936E-2EB8A10BEFD9">单个分区或子分区的直接路径负载</a><br>在单个分区的直接路径加载期间，SQL * Loader使用<code class="codeph">LOAD</code>语句的分区扩展语法。
                     </li>
                     <li class="ulchildlink"><a href="oracle-sql-loader-conventional-and-direct-loads.html#GUID-67BAC65B-C80B-4E19-9AA3-00FBBDAC45F5">直接路径负载的优点</a><br>本主题描述使用直接路径加载的优点。
                     </li>
                     <li class="ulchildlink"><a href="oracle-sql-loader-conventional-and-direct-loads.html#GUID-993D209A-23CC-466D-B8C7-D508C17C921A">使用直接路径加载的限制</a><br>使用直接路径加载存在限制。
                     </li>
                     <li class="ulchildlink"><a href="oracle-sql-loader-conventional-and-direct-loads.html#GUID-D9FFC2FB-796A-4CE9-AB35-91FAC0F88703">单分区直接路径负载的限制</a><br>单个分区的直接路径负载存在限制。
                     </li>
                     <li class="ulchildlink"><a href="oracle-sql-loader-conventional-and-direct-loads.html#GUID-7F0A089C-C98D-4B3B-9701-E1A3517C14DB">何时使用直接路径加载</a><br>如何确定是否应使用直接路径加载。
                     </li>
                     <li class="ulchildlink"><a href="oracle-sql-loader-conventional-and-direct-loads.html#GUID-54CA4890-5AC9-42F5-A9C7-9691E3565447">完整性约束</a><br>在直接路径加载期间强制执行所有完整性约束，但不一定是同时。
                     </li>
                     <li class="ulchildlink"><a href="oracle-sql-loader-conventional-and-direct-loads.html#GUID-F991A526-09DC-4FE8-AFC4-4722A067FB8B">直接路径上的字段默认值</a><br>使用直接路径加载时，数据库中定义的默认列规范不可用。
                     </li>
                     <li class="ulchildlink"><a href="oracle-sql-loader-conventional-and-direct-loads.html#GUID-286C5734-EA71-4D76-A8A9-D1A4EC7E7F08">加载到同义词</a><br>您可以在直接路径加载期间将数据加载到表的同义词中，但同义词必须直接指向表或简单表上的视图。
                     </li>
                  </ul>
                  <div class="infoboxnotealso" id="GUID-26686C49-D768-4F55-8AED-771B9A8C6552__GUID-8AF64859-21A2-4C25-9269-D38C287D47C2">
                     <p class="notep1">也可以看看：</p>
                     <p><a href="oracle-sql-loader-control-file-contents.html#GUID-7A1B84EC-5BCD-4601-9C4A-654F1987D94F" title="在直接路径负载中，停止负载的行为取决于负载停止的原因。">已停产的直接路径负载</a></p>
                  </div>
                  <div class="familylinks">
                     <div class="parentlink">
                        <p><strong>父主题：</strong> <a href="oracle-sql-loader-conventional-and-direct-loads.html#GUID-321928FB-C86C-4F1F-9250-05111A988B7B" title="SQL * Loader提供了传统的路径加载方法和直接路径加载方法。">常规路径加载和直接路径加载</a></p>
                     </div>
                  </div>
               </div>
               <a id="SUTIL3405"></a><a id="SUTIL3406"></a><a id="SUTIL1289"></a><div class="props_rev_3"><a id="GUID-70EC05F4-1301-4CF3-A4DE-24011AC3F2A9" name="GUID-70EC05F4-1301-4CF3-A4DE-24011AC3F2A9"></a><h4 id="SUTIL-GUID-70EC05F4-1301-4CF3-A4DE-24011AC3F2A9" class="sect4"><span class="enumeration_section">12.3.1</span>直接路径加载期间的数据转换</h4>
                  <div>
                     <p>在直接路径加载期间，数据转换发生在客户端而不是服务器端。</p>
                     <p>这意味着将不使用初始化参数文件（服务器端语言句柄）中的NLS参数。要覆盖此行为，可以在SQL * Loader控制文件中指定格式掩码，该掩码等效于初始化参数文件中NLS参数的设置，或者设置相应的环境变量。例如，要指定字段的日期格式，可以在SQL * Loader控制文件中设置日期格式，如<a href="oracle-sql-loader-conventional-and-direct-loads.html#GUID-70EC05F4-1301-4CF3-A4DE-24011AC3F2A9__I1011154">例12-1</a>所示，或者设置<code class="codeph">NLS_DATE_FORMAT</code>环境变量，如<a href="oracle-sql-loader-conventional-and-direct-loads.html#GUID-70EC05F4-1301-4CF3-A4DE-24011AC3F2A9__I1011158">例12-2</a>所示。
                     </p>
                     <div class="example" id="GUID-70EC05F4-1301-4CF3-A4DE-24011AC3F2A9__I1011154">
                        <p class="titleinexample">示例12-1在SQL * Loader控制文件中设置日期格式</p><pre class="oac_no_warn" dir="ltr">LOAD DATA INFILE'Data.dat'INSERT INTO TABLE emp FIELDS TERMINATED by“|” （EMPNO NUMBER（4）NOT NULL，ENAME CHAR（10），JOB CHAR（9），MGR NUMBER（4），HIREDATE DATE'YYYYMMDD'，SAL号码（7,2），COMM COMMBER（7,2），DEPTNO 2号） ）</pre></div>
                     <!-- class="example" -->
                     <div class="example" id="GUID-70EC05F4-1301-4CF3-A4DE-24011AC3F2A9__I1011158">
                        <p class="titleinexample">示例12-2设置NLS_DATE_FORMAT环境变量</p>
                        <p>在UNIX Bourne或Korn shell上：</p><pre class="oac_no_warn" dir="ltr">％NLS_DATE_FORMAT ='YYYYMMDD'％导出NLS_DATE_FORMAT</pre><p>在UNIX csh上：</p><pre class="oac_no_warn" dir="ltr">％setenv NLS_DATE_FORMAT ='YYYYMMDD'</pre></div>
                     <!-- class="example" -->
                  </div>
                  <div>
                     <div class="familylinks">
                        <div class="parentlink">
                           <p><strong>父主题：</strong> <a href="oracle-sql-loader-conventional-and-direct-loads.html#GUID-26686C49-D768-4F55-8AED-771B9A8C6552" title="直接路径加载使用直接路径API将要加载的数据传递到服务器中的加载引擎。">直接路径加载</a></p>
                        </div>
                     </div>
                  </div>
                  
               </div><a id="SUTIL1290"></a><div class="props_rev_3"><a id="GUID-777AE140-80AE-4A7F-B521-BF64A9E035F9" name="GUID-777AE140-80AE-4A7F-B521-BF64A9E035F9"></a><h4 id="SUTIL-GUID-777AE140-80AE-4A7F-B521-BF64A9E035F9" class="sect4"><span class="enumeration_section">12.3.2</span>分区或子分区表的直接路径负载</h4>
                  <div>
                     <p>加载分区或子分区表时，SQL * Loader会对行进行分区并维护索引（也可以对其进行分区）。</p>
                     <p>请注意，对于具有许多分区或子分区的表，分区或子分区表的直接路径加载可能非常耗费资源。</p>
                     <div class="infoboxnote" id="GUID-777AE140-80AE-4A7F-B521-BF64A9E035F9__GUID-0E01F7EC-7E2F-4869-A7DA-8DD6EFEBE2CB">
                        <p class="notep1">注意：</p>
                        <p>如果要对多个分区执行直接路径加载并发生空间错误，则会将负载回滚到上一个提交点。如果没有提交点，则回滚整个负载。这可确保在将空间错误写入其他分区后不会遇到任何数据。</p>
                        <p>您可以使用<code class="codeph">ROWS</code>参数指定提交点的频率。如果未指定<code class="codeph">ROWS</code>参数，则回滚整个负载。
                        </p>
                     </div>
                  </div>
                  <div>
                     <div class="familylinks">
                        <div class="parentlink">
                           <p><strong>父主题：</strong> <a href="oracle-sql-loader-conventional-and-direct-loads.html#GUID-26686C49-D768-4F55-8AED-771B9A8C6552" title="直接路径加载使用直接路径API将要加载的数据传递到服务器中的加载引擎。">直接路径加载</a></p>
                        </div>
                     </div>
                  </div>
                  
               </div><a id="SUTIL1291"></a><div class="props_rev_3"><a id="GUID-85756D79-AA1E-444C-936E-2EB8A10BEFD9" name="GUID-85756D79-AA1E-444C-936E-2EB8A10BEFD9"></a><h4 id="SUTIL-GUID-85756D79-AA1E-444C-936E-2EB8A10BEFD9" class="sect4"><span class="enumeration_section">12.3.3</span>单个分区或子分区的直接路径负载</h4>
                  <div>
                     <p>在单个分区的直接路径加载期间，SQL * Loader使用<code class="codeph">LOAD</code>语句的分区扩展语法。
                     </p>
                     <p>加载分区或子分区表的单个分区时，SQL * Loader会对行进行分区，并拒绝任何未映射到SQL * Loader控制文件中指定的分区或子分区的行。与加载的数据分区或子分区对应的本地索引分区由SQL * Loader维护。不在单个分区或子分区直接路径加载上维护全局索引。在单个分区的直接路径加载期间，SQL * Loader使用<code class="codeph">LOAD</code>语句的分区扩展语法，该语法具有以下任一形式：</p><pre class="oac_no_warn" dir="ltr">加载表T分区（P）值...加载表T SUBPARTITION（P）VALUES ......
</pre><p>在加载分区或子分区表的分区时，还允许您对表中的其他分区执行DML操作，并直接路径加载。</p>
                     <p>虽然直接路径加载可以最大限度地减少数据库处理，但是在加载的开始和结束时需要多次调用Oracle数据库来分别初始化和完成加载。此外，在加载初始化期间需要某些DML锁，并在加载完成时释放。在加载期间发生以下操作：构建索引键并将其放入排序中，并且空间管理例程用于在需要时获取新范围并调整上边界（高水位线） <span class="italic"> </span>用于数据保存点。有关调整上边界的信息，请参阅<a href="oracle-sql-loader-conventional-and-direct-loads.html#GUID-0E890CF3-C315-4FA5-AB8C-0ABD92084CA0" title="您可以使用数据保存来防止由于实例故障而导致的数据丢失。">使用数据保存以防止数据丢失</a> 。
                     </p>
                  </div>
                  <div>
                     <div class="familylinks">
                        <div class="parentlink">
                           <p><strong>父主题：</strong> <a href="oracle-sql-loader-conventional-and-direct-loads.html#GUID-26686C49-D768-4F55-8AED-771B9A8C6552" title="直接路径加载使用直接路径API将要加载的数据传递到服务器中的加载引擎。">直接路径加载</a></p>
                        </div>
                     </div>
                  </div>
                  
               </div><a id="SUTIL1292"></a><div class="props_rev_3"><a id="GUID-67BAC65B-C80B-4E19-9AA3-00FBBDAC45F5" name="GUID-67BAC65B-C80B-4E19-9AA3-00FBBDAC45F5"></a><h4 id="SUTIL-GUID-67BAC65B-C80B-4E19-9AA3-00FBBDAC45F5" class="sect4"><span class="enumeration_section">12.3.4</span>直接路径负载的优点</h4>
                  <div>
                     <p>本主题描述使用直接路径加载的优点。</p>
                     <p>由于以下原因，直接路径负载比传统路径更快：</p>
                     <ul style="list-style-type:disc">
                        <li>
                           <p>不使用部分块，因此不需要读取它们，并且执行的写入更少。</p>
                        </li>
                        <li>
                           <p>SQL * Loader不需要执行任何SQL <code class="codeph">INSERT</code>语句;因此，Oracle数据库上的处理负载减少了。
                           </p>
                        </li>
                        <li>
                           <p>直接路径加载调用Oracle在加载开始时锁定表和索引，并在加载完成时释放它们。传统的路径加载为每个行数组调用Oracle一次以处理SQL <code class="codeph">INSERT</code>语句。
                           </p>
                        </li>
                        <li>
                           <p>直接路径加载使用多块异步I / O来写入数据库文件。</p>
                        </li>
                        <li>
                           <p>在直接路径加载期间，进程执行自己的写入I / O，而不是使用Oracle的缓冲区高速缓存。这最大限度地减少了与其他Oracle用户的争用。</p>
                        </li>
                        <li>
                           <p>直接路径加载期间可用的已排序索引选项使您可以使用系统或安装本机的高性能排序例程来预先排序数据。</p>
                        </li>
                        <li>
                           <p>当要加载的表为空时，预分类选项会消除索引构建的排序和合并阶段。索引在数据到达时填写。</p>
                        </li>
                        <li>
                           <p>在直接路径加载期间，防止实例失败不需要重做日志文件条目。因此，在以下情况下记录负载时无需时间：</p>
                           <ul style="list-style-type:disc">
                              <li>
                                 <p>Oracle数据库启用了SQL <code class="codeph">NOARCHIVELOG</code>参数</p>
                              </li>
                              <li>
                                 <p>SQL * Loader <code class="codeph">UNRECOVERABLE</code>子句已启用</p>
                              </li>
                              <li>
                                 <p>正在加载的对象具有SQL <code class="codeph">NOLOGGING</code>参数集</p>
                              </li>
                           </ul>
                           <p>请参阅<a href="oracle-sql-loader-conventional-and-direct-loads.html#GUID-E1B67691-A33E-4B27-8A5A-A18B3E12D69C" title="由于SQL * Loader直接写入数据库文件，因此如果重新启动实例，则插入到最后一次数据保存的所有行将自动出现在数据库文件中。">实例恢复和直接路径加载</a> 。
                           </p>
                        </li>
                     </ul>
                  </div>
                  <div>
                     <div class="familylinks">
                        <div class="parentlink">
                           <p><strong>父主题：</strong> <a href="oracle-sql-loader-conventional-and-direct-loads.html#GUID-26686C49-D768-4F55-8AED-771B9A8C6552" title="直接路径加载使用直接路径API将要加载的数据传递到服务器中的加载引擎。">直接路径加载</a></p>
                        </div>
                     </div>
                  </div>
                  
               </div><a id="SUTIL1293"></a><div class="props_rev_3"><a id="GUID-993D209A-23CC-466D-B8C7-D508C17C921A" name="GUID-993D209A-23CC-466D-B8C7-D508C17C921A"></a><h4 id="SUTIL-GUID-993D209A-23CC-466D-B8C7-D508C17C921A" class="sect4"><span class="enumeration_section">12.3.5</span>使用直接路径加载的限制</h4>
                  <div>
                     <p>使用直接路径加载存在限制。</p>
                     <div class="section">
                        <p>您必须满足以下条件才能使用直接路径加载方法：</p>
                        <ul style="list-style-type:disc">
                           <li>
                              <p>要加载的表无法进行聚类。</p>
                           </li>
                           <li>
                              <p>要加载的表不能在INSERT上激活Oracle虚拟专用数据库（VPD）策略。</p>
                           </li>
                           <li>
                              <p>要加载的细分不能有任何待处理的活动事务。</p>
                              <p>要检查此情况，请使用Oracle Enterprise Manager命令<code class="codeph">MONITOR</code> <code class="codeph">TABLE</code>查找要加载的表的对象ID。然后使用命令<code class="codeph">MONITOR</code> <code class="codeph">LOCK</code>查看表上是否有任何锁定。
                              </p>
                           </li>
                           <li>
                              <p>对于早于Oracle9 <span class="italic">i</span>的数据库版本，只有在客户端和服务器是同一版本时，才能执行SQL * Loader直接路径加载。这也意味着您无法将Oracle9 <span class="italic">i</span>数据的直接路径加载到早期版本的数据库中。例如，您不能使用直接路径加载将数据从版本9.0.1数据库加载到版本8.1.7数据库中。
                              </p>
                              <p>从Oracle9 <span class="italic">i</span>开始，当客户端和服务器是不同的版本时，您可以执行SQL * Loader直接路径加载。但是，两个版本必须至少为9.0.1版本，客户端版本必须与服务器版本相同或更低。例如，您可以从版本9.0.1数据库执行直接路径加载到版本9.2数据库。但是，您无法使用直接路径加载将数据从10.0.0版的数据库加载到9.2版数据库中。
                              </p>
                           </li>
                        </ul>
                        <p>以下功能不适用于直接路径加载：</p>
                        <ul style="list-style-type:disc">
                           <li>
                              <p>加载<code class="codeph">BFILE</code>列</p>
                           </li>
                           <li>
                              <p>在加载过程中使用<code class="codeph">CREATE SEQUENCE</code> 。这是因为在直接路径加载中，没有生成SQL来获取下一个值，因为直接路径不生成<code class="codeph">INSERT</code>语句。
                              </p>
                           </li>
                        </ul>
                     </div>
                     <!-- class="section" -->
                  </div>
                  <div>
                     <div class="familylinks">
                        <div class="parentlink">
                           <p><strong>父主题：</strong> <a href="oracle-sql-loader-conventional-and-direct-loads.html#GUID-26686C49-D768-4F55-8AED-771B9A8C6552" title="直接路径加载使用直接路径API将要加载的数据传递到服务器中的加载引擎。">直接路径加载</a></p>
                        </div>
                     </div>
                  </div>
                  
               </div><a id="SUTIL1294"></a><div class="props_rev_3"><a id="GUID-D9FFC2FB-796A-4CE9-AB35-91FAC0F88703" name="GUID-D9FFC2FB-796A-4CE9-AB35-91FAC0F88703"></a><h4 id="SUTIL-GUID-D9FFC2FB-796A-4CE9-AB35-91FAC0F88703" class="sect4"><span class="enumeration_section">12.3.6</span>单个分区的直接路径负载限制</h4>
                  <div>
                     <p>单个分区的直接路径负载存在限制。</p>
                     <div class="section">
                        <p>除了之前列出的限制之外，加载单个分区还有以下限制：</p>
                        <ul style="list-style-type:disc">
                           <li>
                              <p>分区所属的表不能在其上定义任何全局索引。</p>
                           </li>
                           <li>
                              <p>不允许对分区所属的表启用引用和检查约束。</p>
                           </li>
                           <li>
                              <p>不允许启用触发器。</p>
                           </li>
                        </ul>
                     </div>
                     <!-- class="section" -->
                  </div>
                  <div>
                     <div class="familylinks">
                        <div class="parentlink">
                           <p><strong>父主题：</strong> <a href="oracle-sql-loader-conventional-and-direct-loads.html#GUID-26686C49-D768-4F55-8AED-771B9A8C6552" title="直接路径加载使用直接路径API将要加载的数据传递到服务器中的加载引擎。">直接路径加载</a></p>
                        </div>
                     </div>
                  </div>
                  
               </div><a id="SUTIL1295"></a><div class="props_rev_3"><a id="GUID-7F0A089C-C98D-4B3B-9701-E1A3517C14DB" name="GUID-7F0A089C-C98D-4B3B-9701-E1A3517C14DB"></a><h4 id="SUTIL-GUID-7F0A089C-C98D-4B3B-9701-E1A3517C14DB" class="sect4"><span class="enumeration_section">12.3.7</span>何时使用直接路径加载</h4>
                  <div>
                     <p>如何确定是否应使用直接路径加载。</p>
                     <p>如果以前的限制都不适用，则应在以下情况下使用直接路径加载：<span class="bold"></span></p>
                     <ul style="list-style-type:disc">
                        <li>
                           <p>您需要快速加载大量数据。直接路径加载可以快速加载和索引大量数据。它还可以将数据加载到空表或非空表中。</p>
                        </li>
                        <li>
                           <p>您希望并行加载数据以获得最佳性能。请参见<a href="oracle-sql-loader-conventional-and-direct-loads.html#GUID-ECBC6D01-4273-4102-983A-2139C5FB2887" title="本主题描述并行数据加载模型。">并行数据加载模型</a> 。
                           </p>
                        </li>
                     </ul>
                  </div>
                  <div>
                     <div class="familylinks">
                        <div class="parentlink">
                           <p><strong>父主题：</strong> <a href="oracle-sql-loader-conventional-and-direct-loads.html#GUID-26686C49-D768-4F55-8AED-771B9A8C6552" title="直接路径加载使用直接路径API将要加载的数据传递到服务器中的加载引擎。">直接路径加载</a></p>
                        </div>
                     </div>
                  </div>
                  
               </div><a id="SUTIL1296"></a><div class="props_rev_3"><a id="GUID-54CA4890-5AC9-42F5-A9C7-9691E3565447" name="GUID-54CA4890-5AC9-42F5-A9C7-9691E3565447"></a><h4 id="SUTIL-GUID-54CA4890-5AC9-42F5-A9C7-9691E3565447" class="sect4"><span class="enumeration_section">12.3.8</span>完整性约束</h4>
                  <div>
                     <p>在直接路径加载期间强制执行所有完整性约束，但不一定是同时。</p>
                     <p>在加载期间强制执行<code class="codeph">NOT</code> <code class="codeph">NULL</code>约束。拒绝这些约束的记录将被拒绝。
                     </p>
                     <p>在加载期间和加载后都强制执行<code class="codeph">UNIQUE</code>约束。不会拒绝违反<code class="codeph">UNIQUE</code>约束的记录（当检测到约束违规时，记录在内存中不可用）。
                     </p>
                     <p>依赖于其他行或表的完整性约束（例如引用约束）在直接路径加载之前被禁用，并且必须在之后重新启用。如果指定了<code class="codeph">REENABLE</code> ，则SQL * Loader可以在加载结束时自动重新启用它们。重新启用约束后，将检查整个表。在指定的错误日志中报告未通过此检查的任何行。请参阅<a href="oracle-sql-loader-conventional-and-direct-loads.html#GUID-973925DA-8F86-49C1-A707-4564DC3B57AE" title="使用传统的路径加载方法，使用标准SQL INSERT语句插入行数组;自动应用完整性约束和插入触发器。">直接路径载荷_完整性约束_和触发器</a> 。
                     </p>
                  </div>
                  <div>
                     <div class="familylinks">
                        <div class="parentlink">
                           <p><strong>父主题：</strong> <a href="oracle-sql-loader-conventional-and-direct-loads.html#GUID-26686C49-D768-4F55-8AED-771B9A8C6552" title="直接路径加载使用直接路径API将要加载的数据传递到服务器中的加载引擎。">直接路径加载</a></p>
                        </div>
                     </div>
                  </div>
                  
               </div><a id="SUTIL1297"></a><div class="props_rev_3"><a id="GUID-F991A526-09DC-4FE8-AFC4-4722A067FB8B" name="GUID-F991A526-09DC-4FE8-AFC4-4722A067FB8B"></a><h4 id="SUTIL-GUID-F991A526-09DC-4FE8-AFC4-4722A067FB8B" class="sect4"><span class="enumeration_section">12.3.9</span>直接路径上的字段默认值</h4>
                  <div>
                     <p>使用直接路径加载时，数据库中定义的默认列规范不可用。</p>
                     <p>必须使用<code class="codeph">DEFAULTIF</code>子句指定需要默认值的字段。如果未指定<code class="codeph">DEFAULTIF</code>子句且该字段为<code class="codeph">NULL</code> ，则会将空值插入数据库。
                     </p>
                  </div>
                  <div>
                     <div class="familylinks">
                        <div class="parentlink">
                           <p><strong>父主题：</strong> <a href="oracle-sql-loader-conventional-and-direct-loads.html#GUID-26686C49-D768-4F55-8AED-771B9A8C6552" title="直接路径加载使用直接路径API将要加载的数据传递到服务器中的加载引擎。">直接路径加载</a></p>
                        </div>
                     </div>
                  </div>
                  
               </div><a id="SUTIL1298"></a><div class="props_rev_3"><a id="GUID-286C5734-EA71-4D76-A8A9-D1A4EC7E7F08" name="GUID-286C5734-EA71-4D76-A8A9-D1A4EC7E7F08"></a><h4 id="SUTIL-GUID-286C5734-EA71-4D76-A8A9-D1A4EC7E7F08" class="sect4"><span class="enumeration_section">12.3.10</span>加载到同义词</h4>
                  <div>
                     <p>您可以在直接路径加载期间将数据加载到表的同义词中，但同义词必须直接指向表或简单表上的视图。</p>
                     <div class="section">
                        <p>请注意以下限制：</p>
                        <ul style="list-style-type:disc">
                           <li>
                              <p>如果视图位于具有用户定义类型或XML数据的表上，则不能使用直接路径模式。</p>
                           </li>
                           <li>
                              <p>在直接路径模式下，无法使用包含SQL表达式的SQL * Loader控件文件加载视图。</p>
                           </li>
                        </ul>
                     </div>
                     <!-- class="section" -->
                  </div>
                  <div>
                     <div class="familylinks">
                        <div class="parentlink">
                           <p><strong>父主题：</strong> <a href="oracle-sql-loader-conventional-and-direct-loads.html#GUID-26686C49-D768-4F55-8AED-771B9A8C6552" title="直接路径加载使用直接路径API将要加载的数据传递到服务器中的加载引擎。">直接路径加载</a></p>
                        </div>
                     </div>
                  </div>
                  
               </div>
            </div><a id="SUTIL1299"></a><div class="props_rev_3"><a id="GUID-1F89DC04-53CE-41FD-A2B4-1BBB3459C9F2" name="GUID-1F89DC04-53CE-41FD-A2B4-1BBB3459C9F2"></a><h3 id="SUTIL-GUID-1F89DC04-53CE-41FD-A2B4-1BBB3459C9F2" class="sect3"><span class="enumeration_section">12.4</span>使用直接路径加载</h3>
               <div>
                  <p>本节介绍如何使用SQL * Loader直接路径加载方法。</p>
                  <p>它包含以下部分：</p>
               </div>
               <div>
                  <ul class="ullinks">
                     <li class="ulchildlink"><a href="oracle-sql-loader-conventional-and-direct-loads.html#GUID-E52F2F36-2CE9-4254-9A03-D0406EC621C1">设置直接路径加载</a><br>要为直接路径加载准备数据库，必须运行安装脚本<code class="codeph">catldr</code> 。 <code class="codeph">sql</code> ，创建必要的视图。
                     </li>
                     <li class="ulchildlink"><a href="oracle-sql-loader-conventional-and-direct-loads.html#GUID-A491440D-63A4-4781-9292-B822DDDF9BF3">指定直接路径加载</a><br>要在直接路径加载模式下启动SQL * Loader，请在命令行或参数文件中将<code class="codeph">DIRECT</code>参数设置为<code class="codeph">TRUE</code> 。
                     </li>
                     <li class="ulchildlink"><a href="oracle-sql-loader-conventional-and-direct-loads.html#GUID-81C3D461-09BA-4CAB-AB06-B2C7D51780EF">建立索引</a><br>您可以使用临时存储来提高直接路径负载的性能。格式化每个块后，新索引键将放入排序（临时）段。
                     </li>
                     <li class="ulchildlink"><a href="oracle-sql-loader-conventional-and-direct-loads.html#GUID-C44AADF7-777D-4847-A5ED-75E36B40D0EB">索引处于不可用状态</a><br>当加载的数据段比索引它的索引段更新时，SQL * Loader将索引保留为Index Unusable状态。
                     </li>
                     <li class="ulchildlink"><a href="oracle-sql-loader-conventional-and-direct-loads.html#GUID-0E890CF3-C315-4FA5-AB8C-0ABD92084CA0">使用数据保存以防止数据丢失</a><br>您可以使用数据保存来防止由于实例故障而导致的数据丢失。
                     </li>
                     <li class="ulchildlink"><a href="oracle-sql-loader-conventional-and-direct-loads.html#GUID-4DB99887-0E58-476A-9A81-4E865DF62C42">直接路径加载期间的数据恢复</a><br>使用直接路径加载方法时，SQL * Loader提供对数据恢复的完全支持。
                     </li>
                     <li class="ulchildlink"><a href="oracle-sql-loader-conventional-and-direct-loads.html#GUID-88000EF3-410E-49BC-931B-690B3444610A">加载长数据字段</a><br>可以使用LOB在直接路径上加载比SQL * Loader的最大缓冲区大小更长的数据。
                     </li>
                     <li class="ulchildlink"><a href="oracle-sql-loader-conventional-and-direct-loads.html#GUID-41D6AC8D-D076-4924-B2AB-916F38B755EF">审核使用直接路径模式的SQL * Loader操作</a><br>您可以对SQL * Loader直接路径加载执行审计，以监视和记录选定的用户数据库操作。
                     </li>
                  </ul>
                  <div class="familylinks">
                     <div class="parentlink">
                        <p><strong>父主题：</strong> <a href="oracle-sql-loader-conventional-and-direct-loads.html#GUID-321928FB-C86C-4F1F-9250-05111A988B7B" title="SQL * Loader提供了传统的路径加载方法和直接路径加载方法。">常规路径加载和直接路径加载</a></p>
                     </div>
                  </div>
               </div>
               <a id="SUTIL1300"></a><div class="props_rev_3"><a id="GUID-E52F2F36-2CE9-4254-9A03-D0406EC621C1" name="GUID-E52F2F36-2CE9-4254-9A03-D0406EC621C1"></a><h4 id="SUTIL-GUID-E52F2F36-2CE9-4254-9A03-D0406EC621C1" class="sect4"><span class="enumeration_section">12.4.1</span>设置直接路径负载</h4>
                  <div>
                     <p>要为直接路径加载准备数据库，必须运行安装脚本<code class="codeph">catldr</code> 。 <code class="codeph">sql</code> ，创建必要的视图。
                     </p>
                     <div class="section">
                        <p>您只需为计划直接加载的每个数据库运行此脚本一次。如果您知道将要进行直接加载，则可以在数据库安装期间运行此脚本。</p>
                     </div>
                     <!-- class="section" -->
                  </div>
                  <div>
                     <div class="familylinks">
                        <div class="parentlink">
                           <p><strong>父主题：</strong> <a href="oracle-sql-loader-conventional-and-direct-loads.html#GUID-1F89DC04-53CE-41FD-A2B4-1BBB3459C9F2" title="本节介绍如何使用SQL * Loader直接路径加载方法。">使用直接路径加载</a></p>
                        </div>
                     </div>
                  </div>
                  
               </div><a id="SUTIL1301"></a><div class="props_rev_3"><a id="GUID-A491440D-63A4-4781-9292-B822DDDF9BF3" name="GUID-A491440D-63A4-4781-9292-B822DDDF9BF3"></a><h4 id="SUTIL-GUID-A491440D-63A4-4781-9292-B822DDDF9BF3" class="sect4"><span class="enumeration_section">12.4.2</span>指定直接路径负载</h4>
                  <div>
                     <p>要在直接路径加载模式下启动SQL * Loader，请在命令行或参数文件中将<code class="codeph">DIRECT</code>参数设置为<code class="codeph">TRUE</code> 。
                     </p>
                     <div class="section">
                        <p>例如，格式为：</p><pre class="oac_no_warn" dir="ltr">DIRECT = TRUE</pre></div>
                     <!-- class="section" -->
                  </div>
                  <div>
                     <div class="infoboxnotealso" id="GUID-A491440D-63A4-4781-9292-B822DDDF9BF3__GUID-97AA6BE3-D7A4-4247-99BD-AEDBA2212DC4">
                        <p class="notep1">也可以看看：</p>
                        <p></p>
                        <ul style="list-style-type:disc">
                           <li>
                              <p><a href="oracle-sql-loader-conventional-and-direct-loads.html#GUID-C9F61197-5786-402B-A592-02515AA30FFF" title="您可以控制直接路径加载期间使用的时间和临时存储。">优化直接路径负载的性能，</a>以获取有关可用于优化直接路径负载性能的参数的信息</p>
                           </li>
                           <li>
                              <p>如果在多CPU系统或跨系统执行直接路径加载，则<a href="oracle-sql-loader-conventional-and-direct-loads.html#GUID-DD798855-A0A3-4676-800A-984FE8F7FDAF" title="如果要在多CPU系统上执行直接路径加载，则SQL * Loader默认使用多线程。在这种情况下，多CPU系统被定义为具有两个或更多CPU的单个系统。">优化多CPU系统上</a>的直接路径负载</p>
                           </li>
                        </ul>
                     </div>
                     <div class="familylinks">
                        <div class="parentlink">
                           <p><strong>父主题：</strong> <a href="oracle-sql-loader-conventional-and-direct-loads.html#GUID-1F89DC04-53CE-41FD-A2B4-1BBB3459C9F2" title="本节介绍如何使用SQL * Loader直接路径加载方法。">使用直接路径加载</a></p>
                        </div>
                     </div>
                  </div>
                  
               </div><a id="SUTIL1302"></a><div class="props_rev_3"><a id="GUID-81C3D461-09BA-4CAB-AB06-B2C7D51780EF" name="GUID-81C3D461-09BA-4CAB-AB06-B2C7D51780EF"></a><h4 id="SUTIL-GUID-81C3D461-09BA-4CAB-AB06-B2C7D51780EF" class="sect4"><span class="enumeration_section">12.4.3</span>建立索引</h4>
                  <div>
                     <p>您可以使用临时存储来提高直接路径负载的性能。格式化每个块后，新索引键将放入排序（临时）段。</p>
                     <p>在加载完成时合并旧索引和新键以创建新索引。旧索引，排序（临时）段和新索引段都需要存储，直到合并完成。然后删除旧索引和临时段。</p>
                     <p>在传统的路径加载期间，每次插入行时都会更新索引。此方法不需要临时存储空间，但会增加处理时间。</p>
                  </div>
                  <div>
                     <ul class="ullinks">
                        <li class="ulchildlink"><a href="oracle-sql-loader-conventional-and-direct-loads.html#GUID-1A3DD268-4111-49C2-B0E8-9AE76FAC3685">提高绩效</a><br>要提高内存有限的系统的性能，请使用<code class="codeph">SINGLEROW</code>参数。
                        </li>
                        <li class="ulchildlink"><a href="oracle-sql-loader-conventional-and-direct-loads.html#GUID-CD74D1FF-E22E-4158-B10D-A06B01018488">临时段存储要求</a><br>估计临时段存储要求的数量。
                        </li>
                     </ul>
                     <div class="familylinks">
                        <div class="parentlink">
                           <p><strong>父主题：</strong> <a href="oracle-sql-loader-conventional-and-direct-loads.html#GUID-1F89DC04-53CE-41FD-A2B4-1BBB3459C9F2" title="本节介绍如何使用SQL * Loader直接路径加载方法。">使用直接路径加载</a></p>
                        </div>
                     </div>
                  </div>
                  <a id="SUTIL1303"></a><div class="props_rev_3"><a id="GUID-1A3DD268-4111-49C2-B0E8-9AE76FAC3685" name="GUID-1A3DD268-4111-49C2-B0E8-9AE76FAC3685"></a><h5 id="SUTIL-GUID-1A3DD268-4111-49C2-B0E8-9AE76FAC3685" class="sect5"><span class="enumeration_section">12.4.3.1</span>提高绩效</h5>
                     <div>
                        <p>要提高内存有限的系统的性能，请使用<code class="codeph">SINGLEROW</code>参数。
                        </p>
                        <p>有关更多信息，请参阅<a href="oracle-sql-loader-control-file-contents.html#GUID-95669C8F-F9A1-4CE4-A83E-DE636E12AE37">SINGLEROW选项</a> 。
                        </p>
                        <div class="infoboxnote" id="GUID-1A3DD268-4111-49C2-B0E8-9AE76FAC3685__GUID-B4E6339E-56DD-4679-875A-F31F4E9C515D">
                           <p class="notep1">注意：</p>
                           <p>如果在直接加载期间，您已指定要预先排序数据并且现有索引为空，则不需要临时段，并且不会发生合并 - 将键直接放入索引中。有关详细信息，请参阅<a href="oracle-sql-loader-conventional-and-direct-loads.html#GUID-C9F61197-5786-402B-A592-02515AA30FFF" title="您可以控制直接路径加载期间使用的时间和临时存储。">优化直接路径负载的性能</a> 。
                           </p>
                        </div>
                        <p>当构建多个索引时，除了旧索引之外，对应于每个索引的临时段同时存在。然后将新密钥与旧索引合并，一次一个索引。在创建每个新索引时，将删除旧索引和相应的临时段。</p>
                     </div>
                     <div>
                        <div class="infoboxnotealso" id="GUID-1A3DD268-4111-49C2-B0E8-9AE76FAC3685__GUID-61EFF2A1-51AD-4102-821E-1A2AD28C77D8">
                           <p class="notep1">也可以看看：</p>
                           <p>有关如何估计索引大小和设置存储参数的信息，请参见<a href="../admin/managing-indexes.html#ADMIN11716" target="_blank"><span class="italic">“Oracle数据库管理员指南”</span></a></p>
                        </div>
                        <div class="familylinks">
                           <div class="parentlink">
                              <p><strong>父主题：</strong> <a href="oracle-sql-loader-conventional-and-direct-loads.html#GUID-81C3D461-09BA-4CAB-AB06-B2C7D51780EF" title="您可以使用临时存储来提高直接路径负载的性能。格式化每个块后，新索引键将放入排序（临时）段。">构建索引</a></p>
                           </div>
                        </div>
                     </div>
                     
                  </div><a id="SUTIL1304"></a><div class="props_rev_3"><a id="GUID-CD74D1FF-E22E-4158-B10D-A06B01018488" name="GUID-CD74D1FF-E22E-4158-B10D-A06B01018488"></a><h5 id="SUTIL-GUID-CD74D1FF-E22E-4158-B10D-A06B01018488" class="sect5"><span class="enumeration_section">12.4.3.2</span>临时段存储要求</h5>
                     <div>
                        <p>估计临时段存储要求的数量。</p>
                        <div class="section">
                           <p>要估计存储新索引键所需的临时段空间量（以字节为单位），请使用以下公式：</p><pre class="oac_no_warn" dir="ltr">1.3 * key_storage</pre><p>在此公式中，密钥存储定义如下：</p><pre class="oac_no_warn" dir="ltr">key_storage =（number_of_rows）*（10 + sum_of_column_sizes + number_of_columns）</pre><p>此公式中包含的列是索引中的列。每列有一个长度字节，每行10个字节用于<code class="codeph">ROWID</code>和额外开销。
                           </p>
                           <p>常数1.3反映了排序所需的额外空间的平均数量。此值适用于大多数随机排序的数据。如果数据以完全相反的顺序到达，那么排序需要两倍的密钥存储空间，并且该常量的值将是2.0。那是最糟糕的情况。</p>
                           <p>如果数据已完全排序，则只需要足够的空间来存储索引条目，并且此常量的值将为1.0。有关详细信息，请参阅<a href="oracle-sql-loader-conventional-and-direct-loads.html#GUID-571EC032-0C25-483A-BC0D-2C27A7B64D64" title="您可以通过在索引列上预分配数据来提高直接路径加载的性能。">预分类数据以获得更快的索引</a> 。
                           </p>
                        </div>
                        <!-- class="section" -->
                     </div>
                     <div>
                        <div class="familylinks">
                           <div class="parentlink">
                              <p><strong>父主题：</strong> <a href="oracle-sql-loader-conventional-and-direct-loads.html#GUID-81C3D461-09BA-4CAB-AB06-B2C7D51780EF" title="您可以使用临时存储来提高直接路径负载的性能。格式化每个块后，新索引键将放入排序（临时）段。">构建索引</a></p>
                           </div>
                        </div>
                     </div>
                     
                  </div>
               </div><a id="SUTIL1305"></a><div class="props_rev_3"><a id="GUID-C44AADF7-777D-4847-A5ED-75E36B40D0EB" name="GUID-C44AADF7-777D-4847-A5ED-75E36B40D0EB"></a><h4 id="SUTIL-GUID-C44AADF7-777D-4847-A5ED-75E36B40D0EB" class="sect4"><span class="enumeration_section">12.4.4</span>处于不可用状态的索引</h4>
                  <div>
                     <p>当加载的数据段比索引它的索引段更新时，SQL * Loader将索引保留为Index Unusable状态。</p>
                     <p>尝试使用处于Index Unusable状态的索引的任何SQL语句都会返回错误。以下条件导致直接路径加载以使索引不可用状态中的分区索引的索引或分区保留：</p>
                     <ul style="list-style-type:disc">
                        <li>
                           <p>SQL * Loader用尽索引空间，无法更新索引。</p>
                        </li>
                        <li>
                           <p>数据不是<code class="codeph">SORTED</code> <code class="codeph">INDEXES</code>子句指定的顺序。
                           </p>
                        </li>
                        <li>
                           <p>实例失败，或者构建索引时Oracle影子进程失败。</p>
                        </li>
                        <li>
                           <p>唯一索引中有重复的键。</p>
                        </li>
                        <li>
                           <p>正在使用数据保存点，并且在发生数据保存点后，加载失败或由键盘中断终止。</p>
                        </li>
                     </ul>
                     <p>要确定索引是否处于Index Unusable状态，您可以执行简单查询：</p><pre class="oac_no_warn" dir="ltr">SELECT INDEX_NAME，STATUS FROM USER_INDEXES WHERE TABLE_NAME ='tablename';</pre><p>如果您不是表的所有者，则搜索<code class="codeph">ALL_INDEXES</code>或<code class="codeph">DBA_INDEXES</code>而不是<code class="codeph">USER_INDEXES</code> 。</p>
                     <p>要确定索引分区是否处于不可用状态，您可以执行以下查询：</p><pre class="oac_no_warn" dir="ltr">选择INDEX_NAME，PARTITION_NAME，状态来自USER_IND_PARTITIONS状态！='有效';</pre><p>如果您不是表的所有者，则搜索<code class="codeph">ALL_IND_PARTITIONS</code>和<code class="codeph">DBA_IND_PARTITIONS</code>而不是<code class="codeph">USER_IND_PARTITIONS</code> 。</p>
                  </div>
                  <div>
                     <div class="familylinks">
                        <div class="parentlink">
                           <p><strong>父主题：</strong> <a href="oracle-sql-loader-conventional-and-direct-loads.html#GUID-1F89DC04-53CE-41FD-A2B4-1BBB3459C9F2" title="本节介绍如何使用SQL * Loader直接路径加载方法。">使用直接路径加载</a></p>
                        </div>
                     </div>
                  </div>
                  
               </div><a id="SUTIL1306"></a><div class="props_rev_3"><a id="GUID-0E890CF3-C315-4FA5-AB8C-0ABD92084CA0" name="GUID-0E890CF3-C315-4FA5-AB8C-0ABD92084CA0"></a><h4 id="SUTIL-GUID-0E890CF3-C315-4FA5-AB8C-0ABD92084CA0" class="sect4"><span class="enumeration_section">12.4.5</span>使用数据保存以防止数据丢失</h4>
                  <div>
                     <p>您可以使用数据保存来防止由于实例故障而导致的数据丢失。</p>
                     <div class="section">
                        <p>加载到最后一个保存点的所有数据都受到保护，不会出现实例故障。要在实例失败后继续加载，请确定在失败之前处理输入文件中的行数，然后使用<code class="codeph">SKIP</code>参数跳过这些已处理的行。
                        </p>
                        <p>如果表上有任何索引，请在继续加载之前删除它们，然后在加载后重新创建它们。有关介质和实例恢复的详细信息，请参阅<a href="oracle-sql-loader-conventional-and-direct-loads.html#GUID-4DB99887-0E58-476A-9A81-4E865DF62C42" title="使用直接路径加载方法时，SQL * Loader提供对数据恢复的完全支持。">直接路径加载期间的数据恢复</a> 。
                        </p>
                        <div class="infoboxnote" id="GUID-0E890CF3-C315-4FA5-AB8C-0ABD92084CA0__GUID-B3827D27-45C5-45E8-890D-E910D44DB78A">
                           <p class="notep1">注意：</p>
                           <p>索引不受数据保存的保护，因为SQL * Loader在数据加载完成之前不会构建索引。（在加载期间构建索引的唯一时间是将预分类数据加载到空表中，但这些索引也不受保护。）</p>
                        </div>
                     </div>
                     <!-- class="section" -->
                  </div>
                  <div>
                     <ul class="ullinks">
                        <li class="ulchildlink"><a href="oracle-sql-loader-conventional-and-direct-loads.html#GUID-CE79B0B3-10BB-417E-87DB-361428DC73F6">使用ROWS参数</a><br><code class="codeph">ROWS</code>参数确定在直接路径加载期间何时发生数据保存。
                        </li>
                        <li class="ulchildlink"><a href="oracle-sql-loader-conventional-and-direct-loads.html#GUID-2562DE31-8745-40B0-AF3B-90048E5146A8">数据保存与提交</a><br>在传统的加载中， <code class="codeph">ROWS</code>是在提交操作之前要读取的行数。直接加载数据保存类似于传统的加载提交，但它并不相同。
                        </li>
                     </ul>
                     <div class="familylinks">
                        <div class="parentlink">
                           <p><strong>父主题：</strong> <a href="oracle-sql-loader-conventional-and-direct-loads.html#GUID-1F89DC04-53CE-41FD-A2B4-1BBB3459C9F2" title="本节介绍如何使用SQL * Loader直接路径加载方法。">使用直接路径加载</a></p>
                        </div>
                     </div>
                  </div>
                  <a id="SUTIL1307"></a><div class="props_rev_3"><a id="GUID-CE79B0B3-10BB-417E-87DB-361428DC73F6" name="GUID-CE79B0B3-10BB-417E-87DB-361428DC73F6"></a><h5 id="SUTIL-GUID-CE79B0B3-10BB-417E-87DB-361428DC73F6" class="sect5"><span class="enumeration_section">12.4.5.1</span>使用ROWS参数</h5>
                     <div>
                        <p><code class="codeph">ROWS</code>参数确定在直接路径加载期间何时发生数据保存。
                        </p>
                        <p>为<code class="codeph">ROWS</code>指定的值是您希望SQL * Loader在将插入保存到数据库之前从输入文件中读取的行数。
                        </p>
                        <p>数据保存是一项昂贵的操作。应将<code class="codeph">ROWS</code>的值设置得足够高，以便每15分钟或更长时间进行一次数据保存。目的是为在长时间运行的直接路径负载期间发生实例故障时丢失的工作量提供上限（高水位线）。将<code class="codeph">ROWS</code>的值设置为较小的数会会对性能和数据块空间利用率产生负面影响。
                        </p>
                     </div>
                     <div>
                        <div class="familylinks">
                           <div class="parentlink">
                              <p><strong>父主题：</strong> <a href="oracle-sql-loader-conventional-and-direct-loads.html#GUID-0E890CF3-C315-4FA5-AB8C-0ABD92084CA0" title="您可以使用数据保存来防止由于实例故障而导致的数据丢失。">使用数据保存来防止数据丢失</a></p>
                           </div>
                        </div>
                     </div>
                     
                  </div><a id="SUTIL1308"></a><div class="props_rev_3"><a id="GUID-2562DE31-8745-40B0-AF3B-90048E5146A8" name="GUID-2562DE31-8745-40B0-AF3B-90048E5146A8"></a><h5 id="SUTIL-GUID-2562DE31-8745-40B0-AF3B-90048E5146A8" class="sect5"><span class="enumeration_section">12.4.5.2</span>数据保存与提交</h5>
                     <div>
                        <p>在传统的加载中， <code class="codeph">ROWS</code>是在提交操作之前要读取的行数。直接加载数据保存类似于传统的加载提交，但它并不相同。
                        </p>
                        <p>相似之处如下：</p>
                        <ul style="list-style-type:disc">
                           <li>
                              <p>数据保存将使行对其他用户可见。</p>
                           </li>
                           <li>
                              <p>数据保存后无法回滚行。</p>
                           </li>
                        </ul>
                        <p>主要区别在于，在直接路径加载数据保存中，索引将无法使用（在索引不可用状态下），直到加载完成。</p>
                     </div>
                     <div>
                        <div class="familylinks">
                           <div class="parentlink">
                              <p><strong>父主题：</strong> <a href="oracle-sql-loader-conventional-and-direct-loads.html#GUID-0E890CF3-C315-4FA5-AB8C-0ABD92084CA0" title="您可以使用数据保存来防止由于实例故障而导致的数据丢失。">使用数据保存来防止数据丢失</a></p>
                           </div>
                        </div>
                     </div>
                     
                  </div>
               </div><a id="SUTIL1309"></a><div class="props_rev_3"><a id="GUID-4DB99887-0E58-476A-9A81-4E865DF62C42" name="GUID-4DB99887-0E58-476A-9A81-4E865DF62C42"></a><h4 id="SUTIL-GUID-4DB99887-0E58-476A-9A81-4E865DF62C42" class="sect4"><span class="enumeration_section">12.4.6</span>直接路径加载期间的数据恢复</h4>
                  <div>
                     <p>使用直接路径加载方法时，SQL * Loader提供对数据恢复的完全支持。</p>
                     <p>有两种主要的恢复类型：</p>
                     <ul style="list-style-type:disc">
                        <li>
                           <p>媒体 - 从丢失数据库文件中恢复。丢失数据库文件后，必须以<code class="codeph">ARCHIVELOG</code>模式运行才能恢复。
                           </p>
                        </li>
                        <li>
                           <p>实例 - 从内存数据发生更改但由于在写入磁盘之前发生故障而丢失的系统故障中恢复。即使未归档重做日志，Oracle数据库也可以始终从实例故障中恢复。</p>
                        </li>
                     </ul>
                  </div>
                  <div>
                     <ul class="ullinks">
                        <li class="ulchildlink"><a href="oracle-sql-loader-conventional-and-direct-loads.html#GUID-EEE35D01-3975-4AEA-AC7F-C2E6554B2EDB">介质恢复和直接路径加载</a><br>如果启用了重做日志文件存档（您在<code class="codeph">ARCHIVELOG</code>模式下运行），则SQL * Loader会在使用直接路径时记录已加载的数据，从而使介质恢复成为可能。
                        </li>
                        <li class="ulchildlink"><a href="oracle-sql-loader-conventional-and-direct-loads.html#GUID-E1B67691-A33E-4B27-8A5A-A18B3E12D69C">实例恢复和直接路径加载</a><br>由于SQL * Loader直接写入数据库文件，因此如果重新启动实例，则插入到最后一次数据保存的所有行将自动出现在数据库文件中。
                        </li>
                     </ul>
                     <div class="familylinks">
                        <div class="parentlink">
                           <p><strong>父主题：</strong> <a href="oracle-sql-loader-conventional-and-direct-loads.html#GUID-1F89DC04-53CE-41FD-A2B4-1BBB3459C9F2" title="本节介绍如何使用SQL * Loader直接路径加载方法。">使用直接路径加载</a></p>
                        </div>
                     </div>
                  </div>
                  <a id="SUTIL1310"></a><div class="props_rev_3"><a id="GUID-EEE35D01-3975-4AEA-AC7F-C2E6554B2EDB" name="GUID-EEE35D01-3975-4AEA-AC7F-C2E6554B2EDB"></a><h5 id="SUTIL-GUID-EEE35D01-3975-4AEA-AC7F-C2E6554B2EDB" class="sect5"><span class="enumeration_section">12.4.6.1</span>介质恢复和直接路径加载</h5>
                     <div>
                        <p>如果启用了重做日志文件存档（您在<code class="codeph">ARCHIVELOG</code>模式下运行），则SQL * Loader会在使用直接路径时记录已加载的数据，从而使介质恢复成为可能。
                        </p>
                        <div class="section">
                           <p>如果未启用重做日志存档（您在<code class="codeph">NOARCHIVELOG</code>模式下运行），则无法进行介质恢复。
                           </p>
                           <p>要恢复在加载时丢失的数据库文件，请使用与恢复使用常规路径加载的数据相同的方法：</p>
                        </div>
                        <!-- class="section" -->
                        <ol>
                           <li class="stepexpand"><span>还原受影响的数据库文件的最新备份。</span></li>
                           <li class="stepexpand"><span>使用RMAN <code class="codeph">RECOVER</code>命令恢复表空间。</span><div>
                                 <div class="infoboxnotealso" id="GUID-EEE35D01-3975-4AEA-AC7F-C2E6554B2EDB__GUID-E282037F-0970-4F72-9132-41C4DFDFC905">
                                    <p class="notep1">也可以看看：</p>
                                    <p>有关使用RMAN恢复表空间的详细信息，请参见<a href="../bradv/rman-complete-database-recovery.html#BRADV89773" target="_blank"><span class="italic">“Oracle数据库备份和恢复用户指南”</span></a></p>
                                 </div>
                              </div>
                           </li>
                        </ol>
                     </div>
                     <div>
                        <div class="familylinks">
                           <div class="parentlink">
                              <p><strong>父主题：</strong> <a href="oracle-sql-loader-conventional-and-direct-loads.html#GUID-4DB99887-0E58-476A-9A81-4E865DF62C42" title="使用直接路径加载方法时，SQL * Loader提供对数据恢复的完全支持。">直接路径加载期间的数据恢复</a></p>
                           </div>
                        </div>
                     </div>
                     
                  </div><a id="SUTIL1311"></a><div class="props_rev_3"><a id="GUID-E1B67691-A33E-4B27-8A5A-A18B3E12D69C" name="GUID-E1B67691-A33E-4B27-8A5A-A18B3E12D69C"></a><h5 id="SUTIL-GUID-E1B67691-A33E-4B27-8A5A-A18B3E12D69C" class="sect5"><span class="enumeration_section">12.4.6.2</span>实例恢复和直接路径加载</h5>
                     <div>
                        <p>由于SQL * Loader直接写入数据库文件，因此如果重新启动实例，则插入到最后一次数据保存的所有行将自动出现在数据库文件中。</p>
                        <p>无需在重做日志文件中记录更改以使实例恢复成为可能。</p>
                        <p>如果发生实例故障，则正在构建的索引可能处于Index Unusable状态。必须先重建不可用的索引，然后才能使用表或分区。见<a href="oracle-sql-loader-conventional-and-direct-loads.html#GUID-C44AADF7-777D-4847-A5ED-75E36B40D0EB" title="当加载的数据段比索引它的索引段更新时，SQL * Loader将索引保留为Index Unusable状态。">处于不可用状态左指标</a>有关如何确定一个指数在指数不可用的状态被留下的信息。
                        </p>
                     </div>
                     <div>
                        <div class="familylinks">
                           <div class="parentlink">
                              <p><strong>父主题：</strong> <a href="oracle-sql-loader-conventional-and-direct-loads.html#GUID-4DB99887-0E58-476A-9A81-4E865DF62C42" title="使用直接路径加载方法时，SQL * Loader提供对数据恢复的完全支持。">直接路径加载期间的数据恢复</a></p>
                           </div>
                        </div>
                     </div>
                     
                  </div>
               </div><a id="SUTIL1312"></a><div class="props_rev_3"><a id="GUID-88000EF3-410E-49BC-931B-690B3444610A" name="GUID-88000EF3-410E-49BC-931B-690B3444610A"></a><h4 id="SUTIL-GUID-88000EF3-410E-49BC-931B-690B3444610A" class="sect4"><span class="enumeration_section">12.4.7</span>加载长数据字段</h4>
                  <div>
                     <p>可以使用LOB在直接路径上加载比SQL * Loader的最大缓冲区大小更长的数据。</p>
                     <p>使用大的<code class="codeph">STREAMSIZE</code>值时，可以提高性能。
                     </p>
                     <div class="infoboxnotealso" id="GUID-88000EF3-410E-49BC-931B-690B3444610A__GUID-A98737A3-F239-4D42-97C9-E3ADEDBDC616">
                        <p class="notep1">也可以看看：</p>
                        <p></p>
                        <ul style="list-style-type:disc">
                           <li>
                              <p><a href="loading-objects-oracle-sql-loader.html#GUID-3637F462-436A-4F6B-B243-03FB3177CA80" title="该部分描述了加载LOB。">加载LOB</a></p>
                           </li>
                           <li>
                              <p><a href="oracle-sql-loader-conventional-and-direct-loads.html#GUID-CEBD2E84-5348-46B5-AAAD-0790109F6741" title="列数组行数确定在构建流缓冲区之前加载的行数。Ť">指定列数组行数和流缓冲区大小</a></p>
                           </li>
                        </ul>
                     </div>
                     <p>您还可以使用<code class="codeph">PIECED</code>参数加载长度超过最大缓冲区大小的数据，如下一节所述，但Oracle强烈建议您改为使用LOB。
                     </p>
                  </div>
                  <div>
                     <ul class="ullinks">
                        <li class="ulchildlink"><a href="oracle-sql-loader-conventional-and-direct-loads.html#GUID-FAEDD181-CFD9-40D8-9CB4-165C13063BBE">正在加载数据作为PIECED</a><br>如果数据位于逻辑记录的最后一列，则<code class="codeph">PIECED</code>参数可用于按部分加载数据。
                        </li>
                     </ul>
                     <div class="familylinks">
                        <div class="parentlink">
                           <p><strong>父主题：</strong> <a href="oracle-sql-loader-conventional-and-direct-loads.html#GUID-1F89DC04-53CE-41FD-A2B4-1BBB3459C9F2" title="本节介绍如何使用SQL * Loader直接路径加载方法。">使用直接路径加载</a></p>
                        </div>
                     </div>
                  </div>
                  <a id="SUTIL1313"></a><div class="props_rev_3"><a id="GUID-FAEDD181-CFD9-40D8-9CB4-165C13063BBE" name="GUID-FAEDD181-CFD9-40D8-9CB4-165C13063BBE"></a><h5 id="SUTIL-GUID-FAEDD181-CFD9-40D8-9CB4-165C13063BBE" class="sect5"><span class="enumeration_section">12.4.7.1将</span>数据加载为PIECED</h5>
                     <div>
                        <p>如果数据位于逻辑记录的最后一列，则<code class="codeph">PIECED</code>参数可用于按部分加载数据。
                        </p>
                        <p>将列声明为<code class="codeph">PIECED</code>通知直接路径加载器<code class="codeph">LONG</code>字段可能跨多个物理记录（片段）分割。在这种情况下，SQL * Loader处理物理记录中的每个<code class="codeph">LONG</code>字段。在处理记录之前读取所有部分。SQL * Loader在存储之前不会尝试实现<code class="codeph">LONG</code>字段;但是，在处理记录之前会读取所有部分。
                        </p>
                        <p>将列声明为<code class="codeph">PIECED</code>时，以下限制适用：</p>
                        <ul style="list-style-type:disc">
                           <li>
                              <p>此选项仅在直接路径上有效。</p>
                           </li>
                           <li>
                              <p>每个表只能有一个字段可以<code class="codeph">PIECED</code> 。</p>
                           </li>
                           <li>
                              <p><code class="codeph">PIECED</code>字段必须是逻辑记录中的最后一个字段。
                              </p>
                           </li>
                           <li>
                              <p><code class="codeph">PIECED</code>字段不能用于任何<code class="codeph">WHEN</code> ， <code class="codeph">NULLIF</code>或<code class="codeph">DEFAULTIF</code>子句。
                              </p>
                           </li>
                           <li>
                              <p>逻辑记录中的<code class="codeph">PIECED</code>字段区域不得与任何其他字段的区域重叠。
                              </p>
                           </li>
                           <li>
                              <p><code class="codeph">PIECED</code>对应的数据库列可能不是索引的一部分。
                              </p>
                           </li>
                           <li>
                              <p>如果包含<code class="codeph">PIECED</code>字段，则可能无法从错误文件加载被拒绝的记录。
                              </p>
                              <p>例如， <code class="codeph">PIECED</code>字段可以跨越三个记录。SQL * Loader从第一个记录加载该块，然后为第二个缓冲区重用缓冲区。加载第二个片段后，缓冲区将重新用于第三个记录。如果发现错误，则只有第三条记录放在坏文件中，因为缓冲区中不再存在前两条记录。结果，坏文件中的记录无效。
                              </p>
                           </li>
                        </ul>
                     </div>
                     <div>
                        <div class="familylinks">
                           <div class="parentlink">
                              <p><strong>父主题：</strong> <a href="oracle-sql-loader-conventional-and-direct-loads.html#GUID-88000EF3-410E-49BC-931B-690B3444610A" title="可以使用LOB在直接路径上加载比SQL * Loader的最大缓冲区大小更长的数据。">加载长数据字段</a></p>
                           </div>
                        </div>
                     </div>
                     
                  </div>
               </div><a id="SUTIL3947"></a><div class="props_rev_3"><a id="GUID-41D6AC8D-D076-4924-B2AB-916F38B755EF" name="GUID-41D6AC8D-D076-4924-B2AB-916F38B755EF"></a><h4 id="SUTIL-GUID-41D6AC8D-D076-4924-B2AB-916F38B755EF" class="sect4"><span class="enumeration_section">12.4.8</span>审核使用直接路径模式的SQL * Loader操作</h4>
                  <div>
                     <p>您可以对SQL * Loader直接路径加载执行审计，以监视和记录选定的用户数据库操作。</p>
                     <div class="section">
                        <p>SQL * Loader使用统一审计，其中所有审计记录集中在一个地方。</p>
                        <p>要设置统一审核，您需要创建统一的审核策略或更改现有策略。审核策略是一组命名的审核设置，使您可以审核数据库中用户行为的特定方面。要创建策略，请使用SQL <code class="codeph">CREATE AUDIT POLICY</code>语句。
                        </p>
                        <p>创建审核策略后，分别使用<code class="codeph">AUDIT</code>和<code class="codeph">NOAUDIT</code> SQL语句启用和禁用策略。
                        </p>
                     </div>
                     <!-- class="section" -->
                  </div>
                  <div>
                     <div class="infoboxnotealso" id="GUID-41D6AC8D-D076-4924-B2AB-916F38B755EF__GUID-321AE549-3D5C-482F-8582-A20DC43AC52F">
                        <p class="notep1">也可以看看：</p>
                        <p></p>
                        <ul style="list-style-type:disc">
                           <li>
                              <p>有关SQL <code class="codeph">CREATE AUDIT POLICY, ALTER AUDIT POLICY,AUDIT,</code>和<code class="codeph">NOAUDIT</code>语句的更多信息，请<a href="../sqlrf/CREATE-AUDIT-POLICY-Unified-Auditing.html#SQLRF56055" target="_blank"><span class="italic">参见Oracle数据库SQL语言参考</span></a></p>
                           </li>
                           <li>
                              <p>有关在Oracle数据库中使用审计的详细信息，请参见<a href="https://www.oracle.com/pls/topic/lookup?ctx=en/database/oracle/oracle-database/19/sutil&amp;id=DBSEG120" target="_blank"><span class="italic">“Oracle数据库安全指南”</span></a></p>
                           </li>
                        </ul>
                     </div>
                     <div class="familylinks">
                        <div class="parentlink">
                           <p><strong>父主题：</strong> <a href="oracle-sql-loader-conventional-and-direct-loads.html#GUID-1F89DC04-53CE-41FD-A2B4-1BBB3459C9F2" title="本节介绍如何使用SQL * Loader直接路径加载方法。">使用直接路径加载</a></p>
                        </div>
                     </div>
                  </div>
                  
               </div>
            </div><a id="SUTIL1314"></a><div class="props_rev_3"><a id="GUID-C9F61197-5786-402B-A592-02515AA30FFF" name="GUID-C9F61197-5786-402B-A592-02515AA30FFF"></a><h3 id="SUTIL-GUID-C9F61197-5786-402B-A592-02515AA30FFF" class="sect3"><span class="enumeration_section">12.5</span>优化直接路径负载的性能</h3>
               <div>
                  <p>您可以控制直接路径加载期间使用的时间和临时存储。</p>
                  <p>尽量减少时间：</p>
                  <ul style="list-style-type:disc">
                     <li>
                        <p>预分配存储空间</p>
                     </li>
                     <li>
                        <p>预先输出数据</p>
                     </li>
                     <li>
                        <p>执行不频繁的数据保存</p>
                     </li>
                     <li>
                        <p>尽量减少重做日志的使用</p>
                     </li>
                     <li>
                        <p>指定列数组行的数量和流缓冲区的大小</p>
                     </li>
                     <li>
                        <p>指定日期缓存值</p>
                     </li>
                     <li>
                        <p>设置<code class="codeph">DB_UNRECOVERABLE_SCN_TRACKING=FALSE</code> 。通过定期存储最后一次直接写入的SCN和时间，在控制文件中跟踪不可恢复（nologging）直接写入。如果对控制文件的这些更新对性能产生负面影响，则将<code class="codeph">DB_UNRECOVERABLE_SCN_TRACKING</code>参数设置为<code class="codeph">FALSE</code>可能会提高性能。
                        </p>
                     </li>
                  </ul>
                  <p>为了减少空间：</p>
                  <ul style="list-style-type:disc">
                     <li>
                        <p>在加载前对数据进行排序时，需要最大临时存储空间的索引上的数据排序</p>
                     </li>
                     <li>
                        <p>在负载期间避免索引维护</p>
                     </li>
                  </ul>
               </div>
               <div>
                  <ul class="ullinks">
                     <li class="ulchildlink"><a href="oracle-sql-loader-conventional-and-direct-loads.html#GUID-8A0852AD-A7A7-4FB6-B1A1-6F4E8B46BAB2">预分配存储以加快加载速度</a><br>如果需要，SQL * Loader会自动将扩展区添加到表中，但此过程需要时间。为了更快地加载到新表中，请在创建表时分配所需的扩展区。
                     </li>
                     <li class="ulchildlink"><a href="oracle-sql-loader-conventional-and-direct-loads.html#GUID-571EC032-0C25-483A-BC0D-2C27A7B64D64">预先分配数据以加快索引速度</a><br>您可以通过在索引列上预分配数据来提高直接路径加载的性能。
                     </li>
                     <li class="ulchildlink"><a href="oracle-sql-loader-conventional-and-direct-loads.html#GUID-A2FC1A81-CFC0-410E-92FE-F3B4C07E36CE">不频繁的数据保存</a><br>由于较小的<code class="codeph">ROWS</code>值而导致的频繁数据保存会对直接路径负载的性能产生不利影响。
                     </li>
                     <li class="ulchildlink"><a href="oracle-sql-loader-conventional-and-direct-loads.html#GUID-4F224723-D836-4713-9BEE-E7B88424EB8A">尽量减少重做日志的使用</a><br>一种显着加速直接加载的方法是尽量减少重做日志的使用。
                     </li>
                     <li class="ulchildlink"><a href="oracle-sql-loader-conventional-and-direct-loads.html#GUID-CEBD2E84-5348-46B5-AAAD-0790109F6741">指定列数组行数和流缓冲区大小</a><br>列数组行数确定在构建流缓冲区之前加载的行数。Ť</li>
                     <li class="ulchildlink"><a href="oracle-sql-loader-conventional-and-direct-loads.html#GUID-B1815406-BBA4-4769-AFFE-E1FCBA10779F">为DATE_CACHE指定值</a><br>如果要执行直接路径加载，其中多次加载相同的日期或时间戳值，则总加载时间的大部分可能最终用于转换日期和时间戳数据。
                     </li>
                  </ul>
                  <div class="familylinks">
                     <div class="parentlink">
                        <p><strong>父主题：</strong> <a href="oracle-sql-loader-conventional-and-direct-loads.html#GUID-321928FB-C86C-4F1F-9250-05111A988B7B" title="SQL * Loader提供了传统的路径加载方法和直接路径加载方法。">常规路径加载和直接路径加载</a></p>
                     </div>
                  </div>
               </div>
               <a id="SUTIL1315"></a><div class="props_rev_3"><a id="GUID-8A0852AD-A7A7-4FB6-B1A1-6F4E8B46BAB2" name="GUID-8A0852AD-A7A7-4FB6-B1A1-6F4E8B46BAB2"></a><h4 id="SUTIL-GUID-8A0852AD-A7A7-4FB6-B1A1-6F4E8B46BAB2" class="sect4"><span class="enumeration_section">12.5.1</span>预分配存储以加快加载速度</h4>
                  <div>
                     <p>如果需要，SQL * Loader会自动将扩展区添加到表中，但此过程需要时间。为了更快地加载到新表中，请在创建表时分配所需的扩展区。</p>
                     <div class="section">
                        <p>要计算表所需的空间，请参阅“ <a href="../admin/managing-tables.html#ADMIN11631" target="_blank"><span class="italic">Oracle数据库管理员指南”中</span></a>有关管理数据库文件的信息<a href="../admin/managing-tables.html#ADMIN11631" target="_blank"><span class="italic">。</span></a> 然后使用SQL <code class="codeph">CREATE</code> <code class="codeph">TABLE</code>语句中的<code class="codeph">INITIAL</code>或<code class="codeph">MINEXTENTS</code>子句来分配所需的空间。
                        </p>
                        <p>另一种方法是将范围大小设置得足够大，以便扩展分配很少。</p>
                     </div>
                     <!-- class="section" -->
                  </div>
                  <div>
                     <div class="familylinks">
                        <div class="parentlink">
                           <p><strong>父主题：</strong> <a href="oracle-sql-loader-conventional-and-direct-loads.html#GUID-C9F61197-5786-402B-A592-02515AA30FFF" title="您可以控制直接路径加载期间使用的时间和临时存储。">优化直接路径加载的性能</a></p>
                        </div>
                     </div>
                  </div>
                  
               </div><a id="SUTIL1316"></a><div class="props_rev_3"><a id="GUID-571EC032-0C25-483A-BC0D-2C27A7B64D64" name="GUID-571EC032-0C25-483A-BC0D-2C27A7B64D64"></a><h4 id="SUTIL-GUID-571EC032-0C25-483A-BC0D-2C27A7B64D64" class="sect4"><span class="enumeration_section">12.5.2</span>预先分配数据以加快索引速度</h4>
                  <div>
                     <p>您可以通过在索引列上预分配数据来提高直接路径加载的性能。</p>
                     <p>预分配可最大限度地减少负载期间的临时存储要求。预分类还使您能够利用针对您的操作系统或应用程序优化的高性能排序例程。<span class="bold"></span></p>
                     <p>如果数据是预先排序的并且现有索引不为空，则预分类最小化新密钥所需的临时段空间量。排序例程将每个新密钥附加到密钥列表。</p>
                     <p>不需要额外的空间进行排序，只需要空间用于键。要计算所需的存储量，请使用1.0的排序因子而不是1.3。有关估计存储要求的详细信息，请参阅<a href="oracle-sql-loader-conventional-and-direct-loads.html#GUID-CD74D1FF-E22E-4158-B10D-A06B01018488" title="估计临时段存储要求的数量。">临时段存储要求</a> 。
                     </p>
                     <p>如果指定了预分类并且现有索引为空，则实现最大效率。新密钥只是插入索引中。不存在与空的旧索引同时存在的临时段和新索引，而是仅存在新索引。因此，不需要临时存储，节省了时间。</p>
                  </div>
                  <div>
                     <ul class="ullinks">
                        <li class="ulchildlink"><a href="oracle-sql-loader-conventional-and-direct-loads.html#GUID-65D50809-CCB9-41BB-A72E-AFDF625234E5">分类索引条款</a><br><code class="codeph">SORTED</code> <code class="codeph">INDEXES</code>子句标识数据预分类的索引。
                        </li>
                        <li class="ulchildlink"><a href="oracle-sql-loader-conventional-and-direct-loads.html#GUID-B1099A14-206F-4667-A451-1E030B21C288">未分类的数据</a><br>如果在<code class="codeph">SORTED</code> <code class="codeph">INDEXES</code>子句中指定索引，并且未对该索引排序数据，则索引将在加载结束时保持索引不可用状态。
                        </li>
                        <li class="ulchildlink"><a href="oracle-sql-loader-conventional-and-direct-loads.html#GUID-2AA59065-1131-4D5F-8535-456DF5CFEFE6">多列索引</a><br>如果在<code class="codeph">SORTED</code> <code class="codeph">INDEXES</code>子句中指定多列索引，则应对数据进行排序，使其首先在索引的第一列中排序，然后在索引的第二列中排序，依此类推。
                        </li>
                        <li class="ulchildlink"><a href="oracle-sql-loader-conventional-and-direct-loads.html#GUID-EB69C930-C47B-4DA0-BB77-8A2A786FEC25">选择最佳排序顺序</a><br>为了获得直接路径加载的最佳整体性能，您应该根据需要最多临时段空间的索引预先排序数据。
                        </li>
                     </ul>
                     <div class="familylinks">
                        <div class="parentlink">
                           <p><strong>父主题：</strong> <a href="oracle-sql-loader-conventional-and-direct-loads.html#GUID-C9F61197-5786-402B-A592-02515AA30FFF" title="您可以控制直接路径加载期间使用的时间和临时存储。">优化直接路径加载的性能</a></p>
                        </div>
                     </div>
                  </div>
                  <a id="SUTIL1317"></a><div class="props_rev_3"><a id="GUID-65D50809-CCB9-41BB-A72E-AFDF625234E5" name="GUID-65D50809-CCB9-41BB-A72E-AFDF625234E5"></a><h5 id="SUTIL-GUID-65D50809-CCB9-41BB-A72E-AFDF625234E5" class="sect5"><span class="enumeration_section">12.5.2.1分类索引</span>条款</h5>
                     <div>
                        <p><code class="codeph">SORTED</code> <code class="codeph">INDEXES</code>子句标识数据预分类的索引。
                        </p>
                        <p>该子句仅允许直接路径加载。有关示例，请参阅案例研究6，使用直接路径加载方法加载数据。（有关如何访问<a href="oracle-sql-loader-concepts.html#GUID-96DDFFBB-7BFD-4370-A43C-0211A24FA323" title="SQL*Loader features are illustrated in a variety of case studies.">案例研究</a>的信息，请参阅<a href="oracle-sql-loader-concepts.html#GUID-96DDFFBB-7BFD-4370-A43C-0211A24FA323" title="SQL * Loader功能在各种案例研究中有所说明。">SQL * Loader案例</a>研究。）
                        </p>
                        <p>通常，您只在<code class="codeph">SORTED</code> <code class="codeph">INDEXES</code>子句中指定一个索引，因为为一个索引排序的数据通常不是另一个索引的正确顺序。但是，当多个索引的数据顺序相同时，可以立即指定所有索引。
                        </p>
                        <p>必须在开始直接路径加载之前创建<code class="codeph">SORTED</code> <code class="codeph">INDEXES</code>子句中列出的所有索引。
                        </p>
                     </div>
                     <div>
                        <div class="familylinks">
                           <div class="parentlink">
                              <p><strong>父主题：</strong> <a href="oracle-sql-loader-conventional-and-direct-loads.html#GUID-571EC032-0C25-483A-BC0D-2C27A7B64D64" title="您可以通过在索引列上预分配数据来提高直接路径加载的性能。">为更快的索引预分类数据</a></p>
                           </div>
                        </div>
                     </div>
                     
                  </div><a id="SUTIL1318"></a><div class="props_rev_3"><a id="GUID-B1099A14-206F-4667-A451-1E030B21C288" name="GUID-B1099A14-206F-4667-A451-1E030B21C288"></a><h5 id="SUTIL-GUID-B1099A14-206F-4667-A451-1E030B21C288" class="sect5"><span class="enumeration_section">12.5.2.2</span>未<span class="enumeration_section">排序的</span>数据</h5>
                     <div>
                        <p>如果在<code class="codeph">SORTED</code> <code class="codeph">INDEXES</code>子句中指定索引，并且未对该索引排序数据，则索引将在加载结束时保持索引不可用状态。
                        </p>
                        <p>数据存在，但任何使用索引的尝试都会导致错误。必须在加载后重建任何保留在Index Unusable状态的索引。</p>
                     </div>
                     <div>
                        <div class="familylinks">
                           <div class="parentlink">
                              <p><strong>父主题：</strong> <a href="oracle-sql-loader-conventional-and-direct-loads.html#GUID-571EC032-0C25-483A-BC0D-2C27A7B64D64" title="您可以通过在索引列上预分配数据来提高直接路径加载的性能。">为更快的索引预分类数据</a></p>
                           </div>
                        </div>
                     </div>
                     
                  </div><a id="SUTIL1319"></a><div class="props_rev_3"><a id="GUID-2AA59065-1131-4D5F-8535-456DF5CFEFE6" name="GUID-2AA59065-1131-4D5F-8535-456DF5CFEFE6"></a><h5 id="SUTIL-GUID-2AA59065-1131-4D5F-8535-456DF5CFEFE6" class="sect5"><span class="enumeration_section">12.5.2.3</span>多列索引</h5>
                     <div>
                        <p>如果在<code class="codeph">SORTED</code> <code class="codeph">INDEXES</code>子句中指定多列索引，则应对数据进行排序，使其首先在索引的第一列中排序，然后在索引的第二列中排序，依此类推。
                        </p>
                        <p>例如，如果索引的第一列是city，第二列是姓氏;那么数据应按每个城市的名称排序，如下表所示：</p><pre class="oac_no_warn" dir="ltr">Albuquerque Adams Albuquerque Hartstein Albuquerque Klein ......波士顿安德鲁斯波士顿Bobrowski波士顿海格姆......</pre></div>
                     <div>
                        <div class="familylinks">
                           <div class="parentlink">
                              <p><strong>父主题：</strong> <a href="oracle-sql-loader-conventional-and-direct-loads.html#GUID-571EC032-0C25-483A-BC0D-2C27A7B64D64" title="您可以通过在索引列上预分配数据来提高直接路径加载的性能。">为更快的索引预分类数据</a></p>
                           </div>
                        </div>
                     </div>
                     
                  </div><a id="SUTIL1320"></a><div class="props_rev_3"><a id="GUID-EB69C930-C47B-4DA0-BB77-8A2A786FEC25" name="GUID-EB69C930-C47B-4DA0-BB77-8A2A786FEC25"></a><h5 id="SUTIL-GUID-EB69C930-C47B-4DA0-BB77-8A2A786FEC25" class="sect5"><span class="enumeration_section">12.5.2.4</span>选择最佳排序顺序</h5>
                     <div>
                        <p>为了获得直接路径加载的最佳整体性能，您应该根据需要最多临时段空间的索引预先排序数据。</p>
                        <div class="section">
                           <p>例如，如果主键是一个数字列，并且辅助键由三个文本列组成，则可以通过在辅助键上预分配来最小化排序时间和存储要求。</p>
                           <p>要确定需要最多存储空间的索引，请使用以下过程：</p>
                        </div>
                        <!-- class="section" -->
                        <ol>
                           <li><span>对于每个索引，请添加该索引中所有列的宽度。</span></li>
                           <li><span>对于单表加载，选择具有最大总宽度的索引。</span></li>
                           <li><span>对于多表加载中的每个表，请标识具有最大总宽度的索引。如果要将相同数量的行加载到每个表中，则再次选择具有最大总宽度的索引。通常，每个表中都会加载相同数量的行。</span></li>
                           <li><span>如果要在多表加载中将不同数量的行加载到索引表中，则将步骤3中标识的每个索引的宽度乘以要加载到该索引中的行数，然后选择索引结果最好。</span></li>
                        </ol>
                     </div>
                     <div>
                        <div class="familylinks">
                           <div class="parentlink">
                              <p><strong>父主题：</strong> <a href="oracle-sql-loader-conventional-and-direct-loads.html#GUID-571EC032-0C25-483A-BC0D-2C27A7B64D64" title="您可以通过在索引列上预分配数据来提高直接路径加载的性能。">为更快的索引预分类数据</a></p>
                           </div>
                        </div>
                     </div>
                     
                  </div>
               </div><a id="SUTIL1321"></a><div class="props_rev_3"><a id="GUID-A2FC1A81-CFC0-410E-92FE-F3B4C07E36CE" name="GUID-A2FC1A81-CFC0-410E-92FE-F3B4C07E36CE"></a><h4 id="SUTIL-GUID-A2FC1A81-CFC0-410E-92FE-F3B4C07E36CE" class="sect4"><span class="enumeration_section">12.5.3</span>不频繁的数据保存</h4>
                  <div>
                     <p>由于较小的<code class="codeph">ROWS</code>值而导致的频繁数据保存会对直接路径负载的性能产生不利影响。
                     </p>
                     <p>较小的<code class="codeph">ROWS</code>值也会导致数据块空间浪费，因为即使数据块未满，也不会在保存后写入最后一个数据块。
                     </p>
                     <p>由于直接路径负载可以比传统负载快许多倍，因此直接负载的<code class="codeph">ROWS</code>值应远高于传统负载。
                     </p>
                     <p>在数据保存期间，加载将停止，直到成功写入所有SQL * Loader的缓冲区。您应该选择与安全性一致的<code class="codeph">ROWS</code>的最大值。通过加载几千行来确定加载行的平均时间是个好主意。然后，您可以使用该值为<code class="codeph">ROWS</code>选择一个好的值。</p>
                     <p>例如，如果您可以每分钟加载20,000行，并且您不希望在中断后重复超过10分钟的工作，则将<code class="codeph">ROWS</code>设置为200,000（20,000行/分钟* 10分钟）。
                     </p>
                  </div>
                  <div>
                     <div class="familylinks">
                        <div class="parentlink">
                           <p><strong>父主题：</strong> <a href="oracle-sql-loader-conventional-and-direct-loads.html#GUID-C9F61197-5786-402B-A592-02515AA30FFF" title="您可以控制直接路径加载期间使用的时间和临时存储。">优化直接路径加载的性能</a></p>
                        </div>
                     </div>
                  </div>
                  
               </div><a id="SUTIL1322"></a><div class="props_rev_3"><a id="GUID-4F224723-D836-4713-9BEE-E7B88424EB8A" name="GUID-4F224723-D836-4713-9BEE-E7B88424EB8A"></a><h4 id="SUTIL-GUID-4F224723-D836-4713-9BEE-E7B88424EB8A" class="sect4"><span class="enumeration_section">12.5.4</span>尽量减少重做日志的使用</h4>
                  <div>
                     <p>一种显着加速直接加载的方法是尽量减少重做日志的使用。</p>
                     <p>有三种方法可以做到这一点。您可以禁用存档，可以指定加载不可恢复，也可以为要加载的对象设置SQL <code class="codeph">NOLOGGING</code>参数。本节讨论所有方法。
                     </p>
                  </div>
                  <div>
                     <ul class="ullinks">
                        <li class="ulchildlink"><a href="oracle-sql-loader-conventional-and-direct-loads.html#GUID-36F7E175-8B08-4F9F-8998-954ADDE4B0B3">禁用存档</a><br>如果禁用存档，则直接路径加载不会生成完整图像重做。
                        </li>
                        <li class="ulchildlink"><a href="oracle-sql-loader-conventional-and-direct-loads.html#GUID-75EE26ED-6B2F-4A44-AC72-2AF0D326131B">指定SQL * Loader UNRECOVERABLE子句</a><br>要在重做日志文件中节省时间和空间，请在加载数据时使用控制文件中的SQL * Loader <code class="codeph">UNRECOVERABLE</code>子句。
                        </li>
                        <li class="ulchildlink"><a href="oracle-sql-loader-conventional-and-direct-loads.html#GUID-C6F49A28-3318-4173-8488-81DF6F83D5E0">设置SQL NOLOGGING参数</a><br>如果数据或索引段设置了SQL <code class="codeph">NOLOGGING</code>参数，则会对该段禁用完整映像重做日志记录（生成无效重做）。
                        </li>
                     </ul>
                     <div class="familylinks">
                        <div class="parentlink">
                           <p><strong>父主题：</strong> <a href="oracle-sql-loader-conventional-and-direct-loads.html#GUID-C9F61197-5786-402B-A592-02515AA30FFF" title="您可以控制直接路径加载期间使用的时间和临时存储。">优化直接路径加载的性能</a></p>
                        </div>
                     </div>
                  </div>
                  <a id="SUTIL1323"></a><div class="props_rev_3"><a id="GUID-36F7E175-8B08-4F9F-8998-954ADDE4B0B3" name="GUID-36F7E175-8B08-4F9F-8998-954ADDE4B0B3"></a><h5 id="SUTIL-GUID-36F7E175-8B08-4F9F-8998-954ADDE4B0B3" class="sect5"><span class="enumeration_section">12.5.4.1</span>禁用存档</h5>
                     <div>
                        <p>如果禁用存档，则直接路径加载不会生成完整图像重做。</p>
                        <div class="section">
                           <p>使用SQL <code class="codeph">ARCHIVELOG</code>和<code class="codeph">NOARCHIVELOG</code>参数设置存档模式。有关存档的详细信息，请参见“ <a href="../admin/managing-archived-redo-log-files.html#ADMIN008" target="_blank"><span class="italic">Oracle数据库管理员指南”</span></a> 。
                           </p>
                        </div>
                        <!-- class="section" -->
                     </div>
                     <div>
                        <div class="familylinks">
                           <div class="parentlink">
                              <p><strong>父主题：</strong> <a href="oracle-sql-loader-conventional-and-direct-loads.html#GUID-4F224723-D836-4713-9BEE-E7B88424EB8A" title="一种显着加速直接加载的方法是尽量减少重做日志的使用。">最小化重做日志的使用</a></p>
                           </div>
                        </div>
                     </div>
                     
                  </div><a id="SUTIL1324"></a><div class="props_rev_3"><a id="GUID-75EE26ED-6B2F-4A44-AC72-2AF0D326131B" name="GUID-75EE26ED-6B2F-4A44-AC72-2AF0D326131B"></a><h5 id="SUTIL-GUID-75EE26ED-6B2F-4A44-AC72-2AF0D326131B" class="sect5"><span class="enumeration_section">12.5.4.2</span>指定SQL * Loader UNRECOVERABLE子句</h5>
                     <div>
                        <p>要在重做日志文件中节省时间和空间，请在加载数据时使用控制文件中的SQL * Loader <code class="codeph">UNRECOVERABLE</code>子句。
                        </p>
                        <p>不可恢复的负载不会在重做日志文件中记录加载的数据;相反，它会生成无效重做。</p>
                        <p><code class="codeph">UNRECOVERABLE</code>子句适用于加载会话期间加载的所有对象（数据和索引段）。因此，虽然可以继续记录其他用户的数据库更改，但已禁用已加载表的介质恢复。
                        </p>
                        <div class="infoboxnote" id="GUID-75EE26ED-6B2F-4A44-AC72-2AF0D326131B__GUID-2BF5E01B-6E3D-418E-875F-A6829FE89791">
                           <p class="notep1">注意：</p>
                           <p>由于未记录数据加载，因此您可能希望在加载后备份数据。</p>
                        </div>
                        <p>如果对使用<code class="codeph">UNRECOVERABLE</code>子句加载的数据进行介质恢复，则加载的数据块将标记为逻辑损坏。
                        </p>
                        <p>要恢复数据，请删除并重新创建数据。在加载后立即进行备份是个好主意，以保留其他不可恢复的数据。</p>
                        <p>默认情况下，直接路径加载是<code class="codeph">RECOVERABLE</code> 。</p>
                        <p>以下是在控制文件中指定<code class="codeph">UNRECOVERABLE</code>子句的示例：</p><pre class="oac_no_warn" dir="ltr">UNRECOVERABLE LOAD DATA INFILE'meample.dat'INTO TABLE emp（ename VARCHAR2（10），empno NUMBER（4））;</pre></div>
                     <div>
                        <div class="familylinks">
                           <div class="parentlink">
                              <p><strong>父主题：</strong> <a href="oracle-sql-loader-conventional-and-direct-loads.html#GUID-4F224723-D836-4713-9BEE-E7B88424EB8A" title="一种显着加速直接加载的方法是尽量减少重做日志的使用。">最小化重做日志的使用</a></p>
                           </div>
                        </div>
                     </div>
                     
                  </div><a id="SUTIL1325"></a><div class="props_rev_3"><a id="GUID-C6F49A28-3318-4173-8488-81DF6F83D5E0" name="GUID-C6F49A28-3318-4173-8488-81DF6F83D5E0"></a><h5 id="SUTIL-GUID-C6F49A28-3318-4173-8488-81DF6F83D5E0" class="sect5"><span class="enumeration_section">12.5.4.3</span>设置SQL NOLOGGING参数</h5>
                     <div>
                        <p>如果数据或索引段设置了SQL <code class="codeph">NOLOGGING</code>参数，则会对该段禁用完整映像重做日志记录（生成无效重做）。
                        </p>
                        <p>使用<code class="codeph">NOLOGGING</code>参数可以更好地控制未记录的对象。
                        </p>
                     </div>
                     <div>
                        <div class="familylinks">
                           <div class="parentlink">
                              <p><strong>父主题：</strong> <a href="oracle-sql-loader-conventional-and-direct-loads.html#GUID-4F224723-D836-4713-9BEE-E7B88424EB8A" title="一种显着加速直接加载的方法是尽量减少重做日志的使用。">最小化重做日志的使用</a></p>
                           </div>
                        </div>
                     </div>
                     
                  </div>
               </div><a id="SUTIL1326"></a><div class="props_rev_3"><a id="GUID-CEBD2E84-5348-46B5-AAAD-0790109F6741" name="GUID-CEBD2E84-5348-46B5-AAAD-0790109F6741"></a><h4 id="SUTIL-GUID-CEBD2E84-5348-46B5-AAAD-0790109F6741" class="sect4"><span class="enumeration_section">12.5.5</span>指定列阵列行数和流缓冲区大小</h4>
                  <div>
                     <p>列数组行数确定在构建流缓冲区之前加载的行数。Ť</p>
                     <div class="section">
                        <p><code class="codeph">STREAMSIZE</code>参数指定从客户端发送到服务器的数据流的大小（以字节为单位）。
                        </p>
                        <p>使用<code class="codeph">COLUMNARRAYROWS</code>参数指定列数组行数的值。请注意，使用直接路径加载<code class="codeph">VARRAY</code>时， <code class="codeph">COLUMNARRAYROWS</code>参数默认为100以避免客户端对象缓存抖动。
                        </p>
                        <p>使用<code class="codeph">STREAMSIZE</code>参数指定直接路径流缓冲区的大小。
                        </p>
                        <p>这些参数的最佳值因系统，输入数据类型和使用的Oracle列数据类型而异。当您为特定配置使用最佳值时，SQL * Loader日志文件中的已用时间应该会减少。</p>
                        <div class="infoboxnote" id="GUID-CEBD2E84-5348-46B5-AAAD-0790109F6741__GUID-F15FC938-E4DF-437C-ABC4-5F92A6448D25">
                           <p class="notep1">注意：</p>
                           <p>您应该监视进程分页活动，因为如果分页过多，那么性能可能会显着降低。您可能需要降低<code class="codeph">READSIZE</code> ， <code class="codeph">STREAMSIZE</code>和<code class="codeph">COLUMNARRAYROWS</code>的值，以避免过多的分页。
                           </p>
                        </div>
                        <p>在多CPU系统上执行直接路径加载时，指定列数组行数和流缓冲区大小特别有用。</p>
                     </div>
                     <!-- class="section" -->
                  </div>
                  <div>
                     <div class="infoboxnotealso" id="GUID-CEBD2E84-5348-46B5-AAAD-0790109F6741__GUID-D91A4DAE-6CA5-47D4-8014-C3FBC94C4638">
                        <p class="notep1">也可以看看：</p>
                        <p></p>
                        <ul style="list-style-type:disc">
                           <li>
                              <p><a href="oracle-sql-loader-conventional-and-direct-loads.html#GUID-DD798855-A0A3-4676-800A-984FE8F7FDAF" title="如果要在多CPU系统上执行直接路径加载，则SQL * Loader默认使用多线程。在这种情况下，多CPU系统被定义为具有两个或更多CPU的单个系统。">优化多CPU系统的直接路径负载</a></p>
                           </li>
                           <li>
                              <p><a href="oracle-sql-loader-commands.html#GUID-7FD5293A-B69A-4873-A030-694B7C36C3B2" title="SQL * Loader的COLUMNARRAYROWS命令行参数指定要为直接路径列数组分配的行数。">COLUMNARRAYROWS</a></p>
                           </li>
                           <li>
                              <p><a href="oracle-sql-loader-commands.html#GUID-20075E73-BF09-4740-BFEC-24A051FEF9F2" title="STREAMSIZE SQL * Loader命令行参数指定从客户端发送到服务器的数据流的大小（以字节为单位）。">streamsize可</a></p>
                           </li>
                        </ul>
                     </div>
                     <div class="familylinks">
                        <div class="parentlink">
                           <p><strong>父主题：</strong> <a href="oracle-sql-loader-conventional-and-direct-loads.html#GUID-C9F61197-5786-402B-A592-02515AA30FFF" title="您可以控制直接路径加载期间使用的时间和临时存储。">优化直接路径加载的性能</a></p>
                        </div>
                     </div>
                  </div>
                  
               </div><a id="SUTIL1327"></a><div class="props_rev_3"><a id="GUID-B1815406-BBA4-4769-AFFE-E1FCBA10779F" name="GUID-B1815406-BBA4-4769-AFFE-E1FCBA10779F"></a><h4 id="SUTIL-GUID-B1815406-BBA4-4769-AFFE-E1FCBA10779F" class="sect4"><span class="enumeration_section">12.5.6</span>为DATE_CACHE指定值</h4>
                  <div>
                     <p>如果要执行直接路径加载，其中多次加载相同的日期或时间戳值，则总加载时间的大部分可能最终用于转换日期和时间戳数据。</p>
                     <p>如果正在加载多个日期列，则尤其如此。在这种情况下，可以通过使用SQL * Loader日期缓存来提高性能。</p>
                     <p>当输入数据中存在许多重复值时，日期缓存会减少完成的日期转换次数。它使您可以指定加载期间预期的唯一日期数。</p>
                     <p>默认情况下启用日期缓存。要完全禁用日期缓存，请将其设置为0。</p>
                     <p>默认日期缓存大小为1000个元素。如果使用默认值并且加载的唯一输入值的数量超过1000，则会自动禁用该表的日期缓存。这可以防止可能影响性能的过多和不必要的查找时间。但是，如果不是使用默认值，而是为日期缓存指定非零值并超出该值，则<span class="italic">不会</span>禁用日期缓存。相反，使用适当的转换例程显式转换超过最大值的任何输入数据。
                     </p>
                     <p>日期缓存只能与一个表关联。不能跨表格进行日期缓存共享。仅当满足以下所有条件时，才会为表创建日期缓存：</p>
                     <ul style="list-style-type:disc">
                        <li>
                           <p><code class="codeph">DATE_CACHE</code>参数未设置为0</p>
                        </li>
                        <li>
                           <p>正在加载一个或多个日期值，时间戳值或两者，这些值需要数据类型转换才能存储在表中</p>
                        </li>
                        <li>
                           <p>负载是直接路径负载</p>
                        </li>
                     </ul>
                     <p>日期缓存统计信息将写入日志文件。您可以使用这些统计信息来提高直接路径负载性能，如下所示：</p>
                     <ul style="list-style-type:disc">
                        <li>
                           <p>如果高速缓存条目的数量小于高速缓存大小并且没有高速缓存未命中，则可以安全地将高速缓存大小设置为较小的值。</p>
                        </li>
                        <li>
                           <p>如果高速缓存命中数（具有重复值的条目）很小并且高速缓存未命中数很大，则应该增加高速缓存大小。请注意，如果缓存大小增加太多，则可能会导致其他问题，例如过度分页或内存使用过多。</p>
                        </li>
                        <li>
                           <p>如果大多数输入日期值是唯一的，则日期缓存不会增强性能，因此不应使用。</p>
                           <div class="infoboxnote" id="GUID-B1815406-BBA4-4769-AFFE-E1FCBA10779F__GUID-79158801-E9E7-403B-9F65-448A65BD6D24">
                              <p class="notep1">注意：</p>
                              <p>如果缓存在默认情况下处于活动状态并且由于超出了最大值而被禁用，则日期缓存统计信息<span class="italic">不会</span>写入SQL * Loader日志文件。
                              </p>
                           </div>
                        </li>
                     </ul>
                     <p>如果增加高速缓存大小不会提高性能，则还原为默认行为或将高速缓存大小设置为0。整体性能改进还取决于正在加载的其他列的数据类型。对于加载的日期列总数与加载的其他类型数据相比较大的情况，改进将更大。</p>
                  </div>
                  <div>
                     <div class="infoboxnotealso" id="GUID-B1815406-BBA4-4769-AFFE-E1FCBA10779F__GUID-1D7E1515-96EA-4D36-82BC-F17233A7D990">
                        <p class="notep1">也可以看看：</p>
                        <p><a href="oracle-sql-loader-commands.html#GUID-4EB08318-8317-476C-B03E-7D6F64922663" title="SQL * Loader的DATE_CACHE命令行参数指定日期缓存大小（在条目中）。">DATE_CACHE</a></p>
                     </div>
                     <div class="familylinks">
                        <div class="parentlink">
                           <p><strong>父主题：</strong> <a href="oracle-sql-loader-conventional-and-direct-loads.html#GUID-C9F61197-5786-402B-A592-02515AA30FFF" title="您可以控制直接路径加载期间使用的时间和临时存储。">优化直接路径加载的性能</a></p>
                        </div>
                     </div>
                  </div>
                  
               </div>
            </div><a id="SUTIL1328"></a><div class="props_rev_3"><a id="GUID-DD798855-A0A3-4676-800A-984FE8F7FDAF" name="GUID-DD798855-A0A3-4676-800A-984FE8F7FDAF"></a><h3 id="SUTIL-GUID-DD798855-A0A3-4676-800A-984FE8F7FDAF" class="sect3"><span class="enumeration_section">12.6</span>优化多CPU系统的直接路径负载</h3>
               <div>
                  <p>如果要在多CPU系统上执行直接路径加载，则SQL * Loader默认使用多线程。在这种情况下，多CPU系统被定义为具有两个或更多CPU的单个系统。</p>
                  <p>多线程加载意味着在可能的情况下，并行执行列数组到流缓冲区的转换和流缓冲区加载。此优化最适用于：</p>
                  <ul style="list-style-type:disc">
                     <li>
                        <p>列数组足够大，可以为负载生成多个直接路径流缓冲区</p>
                     </li>
                     <li>
                        <p>从输入字段数据类型到Oracle列数据类型需要进行数据转换</p>
                        <p>转换与流缓冲器加载并行执行。</p>
                     </li>
                  </ul>
                  <p>此进程的状态记录在SQL * Loader日志文件中，如以下日志示例部分所示：</p><pre class="oac_no_warn" dir="ltr">由SQL * Loader主线程加载的总流缓冲区数：47由SQL * Loader加载线程加载的总流缓冲区：180列数组行：1000个流缓冲区字节：256000</pre><p>在此示例中，SQL * Loader加载线程已卸载SQL * Loader主线程，允许主线程构建下一个流缓冲区，而加载线程在服务器上加载当前流。</p>
                  <p>目标是让加载线程尽可能多地执行流缓冲区加载。这可以通过增加列数组行数，减小流缓冲区大小或两者来实现。您可以监视SQL * Loader日志文件中的已用时间，以确定您的更改是否具有所需的效果。有关更多信息，请参阅<a href="oracle-sql-loader-conventional-and-direct-loads.html#GUID-CEBD2E84-5348-46B5-AAAD-0790109F6741" title="列数组行数确定在构建流缓冲区之前加载的行数。Ť">指定列阵列行数和流缓冲区大小</a> 。
                  </p>
                  <p>在单CPU系统上，默认情况下会关闭优化。当服务器在另一个系统上时，如果手动打开多线程，性能可能会提高。</p>
                  <p>要打开或关闭多线程选项，请在SQL * Loader命令行中使用<code class="codeph">MULTITHREADING</code>参数，或在SQL * Loader控制文件中指定它。
                  </p>
               </div>
               <div>
                  <div class="infoboxnotealso" id="GUID-DD798855-A0A3-4676-800A-984FE8F7FDAF__GUID-EE0D340E-0017-48FA-A4EC-F842CCD67F74">
                     <p class="notep1">也可以看看：</p>
                     <p>有关直接路径加载概念的更多信息，请参阅<a href="../lnoci/direct-path-load-interface.html#LNOCI16907" target="_blank"><span class="italic">“Oracle调用接口程序员指南”</span></a></p>
                  </div>
                  <div class="familylinks">
                     <div class="parentlink">
                        <p><strong>父主题：</strong> <a href="oracle-sql-loader-conventional-and-direct-loads.html#GUID-321928FB-C86C-4F1F-9250-05111A988B7B" title="SQL * Loader提供了传统的路径加载方法和直接路径加载方法。">常规路径加载和直接路径加载</a></p>
                     </div>
                  </div>
               </div>
               
            </div><a id="SUTIL1329"></a><div class="props_rev_3"><a id="GUID-DD1AA9FC-B775-42E2-9BD9-5E43056A1418" name="GUID-DD1AA9FC-B775-42E2-9BD9-5E43056A1418"></a><h3 id="SUTIL-GUID-DD1AA9FC-B775-42E2-9BD9-5E43056A1418" class="sect3"><span class="enumeration_section">12.7</span>避免索引维护</h3>
               <div>
                  <p>对于常规路径和直接路径，SQL * Loader维护表的所有现有索引。</p>
                  <div class="section">
                     <p>要避免索引维护，请使用以下方法之一：</p>
                  </div>
                  <!-- class="section" -->
                  <div class="section">
                     <ul style="list-style-type:disc">
                        <li>
                           <p>在开始加载之前删除索引。</p>
                        </li>
                        <li>
                           <p>在开始加载之前将所选索引或索引分区标记为Index Unusable，并使用<code class="codeph">SKIP_UNUSABLE_INDEXES</code>参数。
                           </p>
                        </li>
                        <li>
                           <p>使用<code class="codeph">SKIP_INDEX_MAINTENANCE</code>参数（仅限直接路径，请谨慎使用）。
                           </p>
                        </li>
                     </ul>
                     <p>通过避免索引维护，您可以通过以下方式最小化直接路径加载期间所需的空间量：</p>
                     <ul style="list-style-type:disc">
                        <li>
                           <p>您可以一次构建一个索引，从而减少每个索引所需的排序（临时）段空间量。</p>
                        </li>
                        <li>
                           <p>构建索引时只存在一个索引段，而不是当新键合并到旧索引以生成新索引时临时存在的三个段。</p>
                        </li>
                     </ul>
                     <p>当要加载的行数与表的大小相比较大时，避免索引维护是非常合理的。但是，如果将相对较少的行添加到大型表中，则索引索引所需的时间可能过长。在这种情况下，通常最好使用传统的路径加载方法，或使用SQL * Loader的<code class="codeph">SINGLEROW</code>参数。有关更多信息，请参阅<a href="oracle-sql-loader-control-file-contents.html#GUID-95669C8F-F9A1-4CE4-A83E-DE636E12AE37">SINGLEROW选项</a> 。
                     </p>
                  </div>
                  <!-- class="section" -->
               </div>
               <div>
                  <div class="familylinks">
                     <div class="parentlink">
                        <p><strong>父主题：</strong> <a href="oracle-sql-loader-conventional-and-direct-loads.html#GUID-321928FB-C86C-4F1F-9250-05111A988B7B" title="SQL * Loader提供了传统的路径加载方法和直接路径加载方法。">常规路径加载和直接路径加载</a></p>
                     </div>
                  </div>
               </div>
               
            </div><a id="SUTIL1330"></a><div class="props_rev_3"><a id="GUID-973925DA-8F86-49C1-A707-4564DC3B57AE" name="GUID-973925DA-8F86-49C1-A707-4564DC3B57AE"></a><h3 id="SUTIL-GUID-973925DA-8F86-49C1-A707-4564DC3B57AE" class="sect3"><span class="enumeration_section">12.8</span>直接路径加载，完整性约束和触发器</h3>
               <div>
                  <p>使用传统的路径加载方法，使用标准SQL <code class="codeph">INSERT</code>语句插入行数组;自动应用完整性约束和插入触发器。
                  </p>
                  <p>但是当您使用直接路径加载数据时，SQL * Loader会禁用某些完整性约束和所有数据库触发器。本节讨论使用直接路径加载对这些功能的影响。</p>
               </div>
               <div>
                  <ul class="ullinks">
                     <li class="ulchildlink"><a href="oracle-sql-loader-conventional-and-direct-loads.html#GUID-7E492DDC-BED3-4926-A3A1-20FC324CA100">完整性约束</a><br>在直接路径加载期间，会自动禁用某些完整性约束。
                     </li>
                     <li class="ulchildlink"><a href="oracle-sql-loader-conventional-and-direct-loads.html#GUID-B5EA310B-FFB7-4CF0-8A2D-78E5E11EBC87">数据库插入触发器</a><br>直接路径加载开始时，表插入触发器也会被禁用。
                     </li>
                     <li class="ulchildlink"><a href="oracle-sql-loader-conventional-and-direct-loads.html#GUID-CDCE5FE6-09FB-489C-B4F5-C2D45D0FFA6F">永久禁用触发器和约束</a><br>SQL * Loader需要获取要加载的表上的多个锁以禁用触发器和约束。
                     </li>
                     <li class="ulchildlink"><a href="oracle-sql-loader-conventional-and-direct-loads.html#GUID-4686510F-DDCB-472D-BBDE-E8248452F46C">通过并行常规路径加载提高性能</a><br>如果触发器或完整性约束造成问题，但您希望加载速度更快，则应考虑使用并发传统路径加载。
                     </li>
                  </ul>
                  <div class="familylinks">
                     <div class="parentlink">
                        <p><strong>父主题：</strong> <a href="oracle-sql-loader-conventional-and-direct-loads.html#GUID-321928FB-C86C-4F1F-9250-05111A988B7B" title="SQL * Loader提供了传统的路径加载方法和直接路径加载方法。">常规路径加载和直接路径加载</a></p>
                     </div>
                  </div>
               </div>
               <a id="SUTIL1331"></a><div class="props_rev_3"><a id="GUID-7E492DDC-BED3-4926-A3A1-20FC324CA100" name="GUID-7E492DDC-BED3-4926-A3A1-20FC324CA100"></a><h4 id="SUTIL-GUID-7E492DDC-BED3-4926-A3A1-20FC324CA100" class="sect4"><span class="enumeration_section">12.8.1</span>完整性约束</h4>
                  <div>
                     <p>在直接路径加载期间，会自动禁用某些完整性约束。</p>
                     <p>其他人不是。有关约束的说明，请参阅“ <a href="https://www.oracle.com/pls/topic/lookup?ctx=en/database/oracle/oracle-database/19/sutil&amp;id=ADFNS004" target="_blank"><span class="italic">Oracle数据库开发指南”中</span></a>有关维护数据完整性的信息<a href="https://www.oracle.com/pls/topic/lookup?ctx=en/database/oracle/oracle-database/19/sutil&amp;id=ADFNS004" target="_blank"><span class="italic">。</span></a></p>
                  </div>
                  <div>
                     <ul class="ullinks">
                        <li class="ulchildlink"><a href="oracle-sql-loader-conventional-and-direct-loads.html#GUID-7E25B949-757E-4924-AF51-2CB3BB1EFB24">启用约束</a><br>在直接路径加载期间，某些约束仍然有效。
                        </li>
                        <li class="ulchildlink"><a href="oracle-sql-loader-conventional-and-direct-loads.html#GUID-20F804EE-5015-4899-9A64-64254BC9FDC1">禁用约束</a><br>在直接路径加载期间，禁用某些约束。
                        </li>
                        <li class="ulchildlink"><a href="oracle-sql-loader-conventional-and-direct-loads.html#GUID-B42C86CD-A41C-4F75-B8D6-6F9C8155E074">重新启用约束</a><br>加载完成后，如果指定了<code class="codeph">REENABLE</code>子句， <code class="codeph">REENABLE</code>自动重新启用完整性约束。
                        </li>
                     </ul>
                     <div class="familylinks">
                        <div class="parentlink">
                           <p><strong>父主题：</strong> <a href="oracle-sql-loader-conventional-and-direct-loads.html#GUID-973925DA-8F86-49C1-A707-4564DC3B57AE" title="使用传统的路径加载方法，使用标准SQL INSERT语句插入行数组;自动应用完整性约束和插入触发器。">直接路径加载，完整性约束和触发器</a></p>
                        </div>
                     </div>
                  </div>
                  <a id="SUTIL1332"></a><div class="props_rev_3"><a id="GUID-7E25B949-757E-4924-AF51-2CB3BB1EFB24" name="GUID-7E25B949-757E-4924-AF51-2CB3BB1EFB24"></a><h5 id="SUTIL-GUID-7E25B949-757E-4924-AF51-2CB3BB1EFB24" class="sect5"><span class="enumeration_section">12.8.1.1</span>启用约束</h5>
                     <div>
                        <p>在直接路径加载期间，某些约束仍然有效。</p>
                        <p>在直接路径加载期间，保持启用的约束如下：</p>
                        <ul style="list-style-type:disc">
                           <li>
                              <p><code class="codeph">NOT</code> <code class="codeph">NULL</code></p>
                           </li>
                           <li>
                              <p><code class="codeph">独特</code></p>
                           </li>
                           <li>
                              <p><code class="codeph">PRIMARY</code> <code class="codeph">KEY</code> （非空列的唯一约束）</p>
                           </li>
                        </ul>
                        <p>在列数组构建时检查<code class="codeph">NOT</code> <code class="codeph">NULL</code>约束。任何违反<code class="codeph">NOT</code> <code class="codeph">NULL</code>约束的行都将被拒绝。
                        </p>
                        <p>尽管在直接路径加载期间仍保持启用<code class="codeph">UNIQUE</code>约束，但仍然会加载违反这些约束的任何行（这与拒绝这些行的传统路径不同）。在直接路径加载结束时重建索引时，将验证<code class="codeph">UNIQUE</code>约束，如果检测到违规，则索引将保持索引不可用状态。请参见<a href="oracle-sql-loader-conventional-and-direct-loads.html#GUID-C44AADF7-777D-4847-A5ED-75E36B40D0EB" title="当加载的数据段比索引它的索引段更新时，SQL * Loader将索引保留为Index Unusable状态。">不可用状态下的索引</a> 。
                        </p>
                     </div>
                     <div>
                        <div class="familylinks">
                           <div class="parentlink">
                              <p><strong>父主题：</strong> <a href="oracle-sql-loader-conventional-and-direct-loads.html#GUID-7E492DDC-BED3-4926-A3A1-20FC324CA100" title="在直接路径加载期间，会自动禁用某些完整性约束。">完整性约束</a></p>
                           </div>
                        </div>
                     </div>
                     
                  </div><a id="SUTIL1333"></a><div class="props_rev_3"><a id="GUID-20F804EE-5015-4899-9A64-64254BC9FDC1" name="GUID-20F804EE-5015-4899-9A64-64254BC9FDC1"></a><h5 id="SUTIL-GUID-20F804EE-5015-4899-9A64-64254BC9FDC1" class="sect5"><span class="enumeration_section">12.8.1.2</span>禁用约束</h5>
                     <div>
                        <p>在直接路径加载期间，禁用某些约束。</p>
                        <p>在直接路径加载期间，默认情况下会自动禁用以下约束：</p>
                        <ul style="list-style-type:disc">
                           <li>
                              <p><code class="codeph">CHECK</code>约束</p>
                           </li>
                           <li>
                              <p>参考约束（ <code class="codeph">FOREIGN</code> <code class="codeph">KEY</code> ）</p>
                           </li>
                        </ul>
                        <p>您可以通过指定<code class="codeph">EVALUATE CHECK_CONSTRAINTS</code>子句来覆盖自动禁用<code class="codeph">CHECK</code>约束。然后，SQL * Loader将在直接路径加载期间评估<code class="codeph">CHECK</code>约束。任何违反<code class="codeph">CHECK</code>约束的行都将被拒绝。以下示例显示在SQL * Loader控制文件中使用<code class="codeph">EVALUATE</code> <code class="codeph">CHECK_CONSTRAINTS</code>子句：</p><pre class="oac_no_warn" dir="ltr">加载数据INFILE *附加到表格中评估CHECK_CONSTRAINTS字段由'，''选择性地包围'''（c1 CHAR（10），c2）BEGINDATA Jones，10 Smith，20 Brown，30 Taylor，40</pre></div>
                     <div>
                        <div class="familylinks">
                           <div class="parentlink">
                              <p><strong>父主题：</strong> <a href="oracle-sql-loader-conventional-and-direct-loads.html#GUID-7E492DDC-BED3-4926-A3A1-20FC324CA100" title="在直接路径加载期间，会自动禁用某些完整性约束。">完整性约束</a></p>
                           </div>
                        </div>
                     </div>
                     
                  </div><a id="SUTIL1334"></a><div class="props_rev_3"><a id="GUID-B42C86CD-A41C-4F75-B8D6-6F9C8155E074" name="GUID-B42C86CD-A41C-4F75-B8D6-6F9C8155E074"></a><h5 id="SUTIL-GUID-B42C86CD-A41C-4F75-B8D6-6F9C8155E074" class="sect5"><span class="enumeration_section">12.8.1.3</span>重新启用约束</h5>
                     <div>
                        <p>加载完成后，如果指定了<code class="codeph">REENABLE</code>子句， <code class="codeph">REENABLE</code>自动重新启用完整性约束。
                        </p>
                        <p><code class="codeph">REENABLE</code>子句的语法如下：</p>
                        <div class="figure" id="GUID-B42C86CD-A41C-4F75-B8D6-6F9C8155E074__GUID-8490F2F8-7131-4060-9251-F0DD82E46CBA"><img src="img/into_table4.gif" width="555" alt="下面是into_table4.eps的描述" title="下面是into_table4.eps的描述" longdesc="img_text/into_table4.html"><br><a href="img_text/into_table4.html">插图描述into_table4.eps</a></div>
                        <!-- class="figure" -->
                        <div class="figure" id="GUID-B42C86CD-A41C-4F75-B8D6-6F9C8155E074__GUID-19A2BEA2-9C32-42C9-88FC-FD637C7C066D"><img src="img/into_table5.gif" width="340" alt="下面是into_table5.eps的描述" title="下面是into_table5.eps的描述" longdesc="img_text/into_table5.html"><br><a href="img_text/into_table5.html">插图描述into_table5.eps</a></div>
                        <!-- class="figure" -->
                        <p>提供可选参数<code class="codeph">DISABLED_CONSTRAINTS</code>是为了提高可读性。如果包含<code class="codeph">EXCEPTIONS</code>子句，则该表必须已存在且您必须能够插入其中。此表包含违反其中一个完整性约束的所有行的<code class="codeph">ROWID</code> 。它还包含违反的约束的名称。有关如何创建例外表的说明，请参见<a href="https://www.oracle.com/pls/topic/lookup?ctx=en/database/oracle/oracle-database/19/sutil&amp;id=SQLRF52228" target="_blank"><span class="italic">Oracle数据库SQL语言参考</span></a> 。
                        </p>
                        <p>SQL * Loader日志文件描述了已禁用的约束，已重新启用的约束以及阻止重新启用或验证每个约束的错误（如果有）。它还包含为每个已加载的表指定的例外表的名称。</p>
                        <p>如果未使用<code class="codeph">REENABLE</code>子句，则必须手动重新启用约束，此时将验证表中的所有行。如果Oracle数据库在新数据中发现任何错误，则会生成错误消息。违规约束的名称和坏数据的ROWID放在异常表中（如果指定了一个）。
                        </p>
                        <p>如果使用<code class="codeph">REENABLE</code>子句，则SQL * Loader会自动重新启用约束并验证所有新行。如果在新数据中未发现任何错误，则SQL * Loader会自动将约束标记为已验证。如果在新数据<span class="italic">中</span>发现任何错误，则会将错误消息写入日志文件，SQL * Loader会将约束的状态标记为<code class="codeph">ENABLE</code> <code class="codeph">NOVALIDATE</code> 。违规约束的名称和坏数据的ROWID放在异常表中（如果指定了一个）。
                        </p>
                        <div class="infoboxnote" id="GUID-B42C86CD-A41C-4F75-B8D6-6F9C8155E074__GUID-9D991006-93D7-4122-B7A9-718F40F2962C">
                           <p class="notep1">注意：</p>
                           <p>通常，当表约束保留在<code class="codeph">ENABLE</code> <code class="codeph">NOVALIDATE</code>状态时，可以将新数据插入表中，但不能插入新的无效数据。但是，SQL * Loader直接路径加载不会强制执行此规则。因此，如果使用无效数据执行后续直接路径加载，则将插入无效数据，但是将发生与先前描述的相同的错误报告和异常表处理。在这种情况下，如果在每次加载之前未清除异常表，则异常表可能包含重复的条目。通过执行如下查询，可以轻松过滤重复条目：</p><pre class="oac_no_warn" dir="ltr">SELECT UNIQUE * FROM exceptions_table;</pre></div>
                        <div class="infoboxnote" id="GUID-B42C86CD-A41C-4F75-B8D6-6F9C8155E074__GUID-4085A320-8151-462F-A35E-3BC71FBE0B5B">
                           <p class="notep1">注意：</p>
                           <p>因为必须为整个表重新验证参照完整性，所以当要将少量行加载到非常大的表中时，可以通过使用传统路径而不是直接路径来提高性能。</p>
                        </div>
                     </div>
                     <div>
                        <div class="familylinks">
                           <div class="parentlink">
                              <p><strong>父主题：</strong> <a href="oracle-sql-loader-conventional-and-direct-loads.html#GUID-7E492DDC-BED3-4926-A3A1-20FC324CA100" title="在直接路径加载期间，会自动禁用某些完整性约束。">完整性约束</a></p>
                           </div>
                        </div>
                     </div>
                     
                  </div>
               </div><a id="SUTIL1335"></a><div class="props_rev_3"><a id="GUID-B5EA310B-FFB7-4CF0-8A2D-78E5E11EBC87" name="GUID-B5EA310B-FFB7-4CF0-8A2D-78E5E11EBC87"></a><h4 id="SUTIL-GUID-B5EA310B-FFB7-4CF0-8A2D-78E5E11EBC87" class="sect4"><span class="enumeration_section">12.8.2</span>数据库插入触发器</h4>
                  <div>
                     <p>直接路径加载开始时，表插入触发器也会被禁用。</p>
                     <p>加载行并重建索引后，将自动重新启用已禁用的所有触发器。日志文件列出了为加载禁用的所有触发器。重新启用触发器不应该有任何错误。</p>
                     <p>与完整性约束不同，插入触发器在启用时不会重新应用于整个表。因此，插入触发器<span class="italic">不会</span>针对直接路径上加载的任何行触发。使用直接路径时，应用程序必须确保对新行执行与插入触发器关联的任何行为。
                     </p>
                  </div>
                  <div>
                     <ul class="ullinks">
                        <li class="ulchildlink"><a href="oracle-sql-loader-conventional-and-direct-loads.html#GUID-BC7676C1-E9DA-41B0-A993-A53E0D9C9A0D">用完整性约束替换插入触发器</a><br>应用程序通常使用插入触发器来实现完整性约
                        </li>
                        <li class="ulchildlink"><a href="oracle-sql-loader-conventional-and-direct-loads.html#GUID-86536F29-ECAF-4E2A-B298-4047B7F99743">无法使用自动约束时</a><br>有时，插入触发器不能替换为Oracle的自动完整性约束。
                        </li>
                        <li class="ulchildlink"><a href="oracle-sql-loader-conventional-and-direct-loads.html#GUID-554DE348-8135-4E16-B483-111323535BC7">制备</a><br>在使用任何一种方法之前，必须准备好表格。
                        </li>
                        <li class="ulchildlink"><a href="oracle-sql-loader-conventional-and-direct-loads.html#GUID-A6733492-77CB-4C8E-93E8-5DA86AFE5612">使用更新触发器</a><br>通常，您可以使用数据库更新触发器来复制插入触发器的效果。
                        </li>
                        <li class="ulchildlink"><a href="oracle-sql-loader-conventional-and-direct-loads.html#GUID-98C5B698-141D-449B-9938-CAA935D8B7EC">复制例外情况的影响</a><br>如果插入触发器可以引发异常，则需要更多工作来复制其效果。
                        </li>
                        <li class="ulchildlink"><a href="oracle-sql-loader-conventional-and-direct-loads.html#GUID-D9C8570B-CB5D-4566-A016-48256BE904CC">使用存储过程</a><br>本主题描述使用存储过程。
                        </li>
                     </ul>
                     <div class="familylinks">
                        <div class="parentlink">
                           <p><strong>父主题：</strong> <a href="oracle-sql-loader-conventional-and-direct-loads.html#GUID-973925DA-8F86-49C1-A707-4564DC3B57AE" title="使用传统的路径加载方法，使用标准SQL INSERT语句插入行数组;自动应用完整性约束和插入触发器。">直接路径加载，完整性约束和触发器</a></p>
                        </div>
                     </div>
                  </div>
                  <a id="SUTIL1336"></a><div class="props_rev_3"><a id="GUID-BC7676C1-E9DA-41B0-A993-A53E0D9C9A0D" name="GUID-BC7676C1-E9DA-41B0-A993-A53E0D9C9A0D"></a><h5 id="SUTIL-GUID-BC7676C1-E9DA-41B0-A993-A53E0D9C9A0D" class="sect5"><span class="enumeration_section">12.8.2.1</span>使用完整性约束替换插入触发器</h5>
                     <div>
                        <p>应用程序通常使用插入触发器来实现完整性约</p>
                        <div class="section">
                           <p>这些应用程序插入的大多数触发器都很简单，可以用Oracle的自动完整性约束替换它们。</p>
                        </div>
                        <!-- class="section" -->
                     </div>
                     <div>
                        <div class="familylinks">
                           <div class="parentlink">
                              <p><strong>父主题：</strong> <a href="oracle-sql-loader-conventional-and-direct-loads.html#GUID-B5EA310B-FFB7-4CF0-8A2D-78E5E11EBC87" title="直接路径加载开始时，表插入触发器也会被禁用。">数据库插入触发器</a></p>
                           </div>
                        </div>
                     </div>
                     
                  </div><a id="SUTIL1337"></a><div class="props_rev_3"><a id="GUID-86536F29-ECAF-4E2A-B298-4047B7F99743" name="GUID-86536F29-ECAF-4E2A-B298-4047B7F99743"></a><h5 id="SUTIL-GUID-86536F29-ECAF-4E2A-B298-4047B7F99743" class="sect5"><span class="enumeration_section">12.8.2.2</span>无法使用自动约束时</h5>
                     <div>
                        <p>有时，插入触发器不能替换为Oracle的自动完整性约束。</p>
                        <p>例如，如果使用插入触发器中的表查找实现完整性检查，则不能使用自动检查约束，因为自动约束只能引用当前行中的常量和列。本节介绍了两种复制此类触发器效果的方法。</p>
                     </div>
                     <div>
                        <div class="familylinks">
                           <div class="parentlink">
                              <p><strong>父主题：</strong> <a href="oracle-sql-loader-conventional-and-direct-loads.html#GUID-B5EA310B-FFB7-4CF0-8A2D-78E5E11EBC87" title="直接路径加载开始时，表插入触发器也会被禁用。">数据库插入触发器</a></p>
                           </div>
                        </div>
                     </div>
                     
                  </div><a id="SUTIL1338"></a><div class="props_rev_3"><a id="GUID-554DE348-8135-4E16-B483-111323535BC7" name="GUID-554DE348-8135-4E16-B483-111323535BC7"></a><h5 id="SUTIL-GUID-554DE348-8135-4E16-B483-111323535BC7" class="sect5"><span class="enumeration_section">12.8.2.3</span>准备</h5>
                     <div>
                        <p>在使用任何一种方法之前，必须准备好表格。</p>
                        <div class="section">
                           <p>使用以下一般准则来准备表格：</p>
                        </div>
                        <!-- class="section" -->
                        <ol>
                           <li><span>在加载之前，向表中添加一个1字节或1个字符的列，将行标记为“旧数据”或“新数据”。</span></li>
                           <li><span>让此列的null值表示“旧数据”，因为空列不占用空间。</span></li>
                           <li><span>加载时，使用SQL * Loader的<code class="codeph">CONSTANT</code>参数将所有已加载的行标记为“新数据”。</span></li>
                        </ol>
                        <div class="section">
                           <p>执行此过程后，将识别所有新加载的行，从而可以对新数据进行操作而不会影响旧行。</p>
                        </div>
                        <!-- class="section" -->
                     </div>
                     <div>
                        <div class="familylinks">
                           <div class="parentlink">
                              <p><strong>父主题：</strong> <a href="oracle-sql-loader-conventional-and-direct-loads.html#GUID-B5EA310B-FFB7-4CF0-8A2D-78E5E11EBC87" title="直接路径加载开始时，表插入触发器也会被禁用。">数据库插入触发器</a></p>
                           </div>
                        </div>
                     </div>
                     
                  </div><a id="SUTIL1339"></a><div class="props_rev_3"><a id="GUID-A6733492-77CB-4C8E-93E8-5DA86AFE5612" name="GUID-A6733492-77CB-4C8E-93E8-5DA86AFE5612"></a><h5 id="SUTIL-GUID-A6733492-77CB-4C8E-93E8-5DA86AFE5612" class="sect5"><span class="enumeration_section">12.8.2.4</span>使用更新触发器</h5>
                     <div>
                        <p>通常，您可以使用数据库更新触发器来复制插入触发器的效果。</p>
                        <div class="section">
                           <p>这种方法最简单。只要插入触发器不引发任何异常，就可以使用它。</p>
                        </div>
                        <!-- class="section" -->
                        <ol>
                           <li class="stepexpand"><span>创建一个更新触发器，复制插入触发器的效果。</span><div>
                                 <p>复制触发器。将所有出现的<code class="codeph">"</code> <span class="italic"><code class="codeph">new</code></span> <code class="codeph">.column_name"</code>更改为<code class="codeph">"</code> <span class="italic"><code class="codeph">old</code></span> <code class="codeph">.column_name"</code> 。
                                 </p>
                              </div>
                           </li>
                           <li class="stepexpand"><span>将当前更新触发器（如果存在）替换为新触发器。</span></li>
                           <li class="stepexpand"><span>更新表，将“new data”标志更改为null，从而触发更新触发器。</span></li>
                           <li class="stepexpand"><span>恢复原始更新触发器（如果有）。</span></li>
                        </ol>
                        <div class="section">
                           <p>根据触发器的行为，可能需要在此操作期间对表具有独占更新访问权限，以便其他用户不会无意中将触发器应用于他们修改的行。</p>
                        </div>
                        <!-- class="section" -->
                     </div>
                     <div>
                        <div class="familylinks">
                           <div class="parentlink">
                              <p><strong>父主题：</strong> <a href="oracle-sql-loader-conventional-and-direct-loads.html#GUID-B5EA310B-FFB7-4CF0-8A2D-78E5E11EBC87" title="直接路径加载开始时，表插入触发器也会被禁用。">数据库插入触发器</a></p>
                           </div>
                        </div>
                     </div>
                     
                  </div><a id="SUTIL1340"></a><div class="props_rev_3"><a id="GUID-98C5B698-141D-449B-9938-CAA935D8B7EC" name="GUID-98C5B698-141D-449B-9938-CAA935D8B7EC"></a><h5 id="SUTIL-GUID-98C5B698-141D-449B-9938-CAA935D8B7EC" class="sect5"><span class="enumeration_section">12.8.2.5</span>复制例外情况的影响</h5>
                     <div>
                        <p>如果插入触发器可以引发异常，则需要更多工作来复制其效果。</p>
                        <p>引发异常会阻止该行插入表中。要使用更新触发器复制该效果，必须将已加载的行标记为删除。</p>
                        <p>“新数据”列不能用作删除标志，因为更新触发器无法修改导致其触发的列。因此必须在表中添加另一列。此列标记要删除的行。空值表示该行有效。每当插入触发器引发异常时，更新触发器都可以通过在附加列中设置标志将该行标记为无效。</p>
                        <p>总之，当插入触发器可以引发异常条件时，可以通过更新触发器复制其效果，前提是：</p>
                        <ul style="list-style-type:disc">
                           <li>
                              <p>两列（通常为null）将添加到表中</p>
                           </li>
                           <li>
                              <p>该表可以独家更新（如有必要）</p>
                           </li>
                        </ul>
                     </div>
                     <div>
                        <div class="familylinks">
                           <div class="parentlink">
                              <p><strong>父主题：</strong> <a href="oracle-sql-loader-conventional-and-direct-loads.html#GUID-B5EA310B-FFB7-4CF0-8A2D-78E5E11EBC87" title="直接路径加载开始时，表插入触发器也会被禁用。">数据库插入触发器</a></p>
                           </div>
                        </div>
                     </div>
                     
                  </div><a id="SUTIL1341"></a><div class="props_rev_3"><a id="GUID-D9C8570B-CB5D-4566-A016-48256BE904CC" name="GUID-D9C8570B-CB5D-4566-A016-48256BE904CC"></a><h5 id="SUTIL-GUID-D9C8570B-CB5D-4566-A016-48256BE904CC" class="sect5"><span class="enumeration_section">12.8.2.6</span>使用存储过程</h5>
                     <div>
                        <p>本主题描述使用存储过程。</p>
                        <div class="section">
                           <p>以下过程始终有效，但实现起来比较复杂。插入触发器引发异常时可以使用它。它不需要第二个额外的列;并且，因为它不替换更新触发器，所以可以在不对表进行独占访问的情况下使用它。</p>
                           <ol>
                              <li>
                                 <p>执行以下操作以创建复制插入触发器的效果的存储过程：</p>
                                 <ol type="a">
                                    <li>
                                       <p>声明表的游标，选择所有新行。</p>
                                    </li>
                                    <li>
                                       <p>在处理循环中打开游标并一次一个地获取行。</p>
                                    </li>
                                    <li>
                                       <p>执行插入触发器中包含的操作。</p>
                                    </li>
                                    <li>
                                       <p>如果操作成功，则将“new data”标志更改为null。</p>
                                    </li>
                                    <li>
                                       <p>如果操作失败，则将“新数据”标志更改为“错误数据”。</p>
                                    </li>
                                 </ol>
                              </li>
                              <li>
                                 <p>使用SQL * Plus等管理工具执行存储过程。</p>
                              </li>
                              <li>
                                 <p>运行该过程后，检查表中是否有标记为“错误数据”的行。</p>
                              </li>
                              <li>
                                 <p>更新或删除错误的行。</p>
                              </li>
                              <li>
                                 <p>重新启用插入触发器。</p>
                              </li>
                           </ol>
                        </div>
                        <!-- class="section" -->
                     </div>
                     <div>
                        <div class="familylinks">
                           <div class="parentlink">
                              <p><strong>父主题：</strong> <a href="oracle-sql-loader-conventional-and-direct-loads.html#GUID-B5EA310B-FFB7-4CF0-8A2D-78E5E11EBC87" title="直接路径加载开始时，表插入触发器也会被禁用。">数据库插入触发器</a></p>
                           </div>
                        </div>
                     </div>
                     
                  </div>
               </div><a id="SUTIL1342"></a><div class="props_rev_3"><a id="GUID-CDCE5FE6-09FB-489C-B4F5-C2D45D0FFA6F" name="GUID-CDCE5FE6-09FB-489C-B4F5-C2D45D0FFA6F"></a><h4 id="SUTIL-GUID-CDCE5FE6-09FB-489C-B4F5-C2D45D0FFA6F" class="sect4"><span class="enumeration_section">12.8.3</span>永久禁用触发器和约束</h4>
                  <div>
                     <p>SQL * Loader需要获取要加载的表上的多个锁以禁用触发器和约束。</p>
                     <p>如果竞争进程在SQL * Loader尝试为该表禁用它们的同时启用触发器或约束，则SQL * Loader可能无法获取对表的独占访问权。</p>
                     <p>SQL * Loader尝试尽可能优雅地处理这种情况。它会在退出之前尝试重新启用已禁用的触发器和约束。但是，同样的表锁定问题使SQL * Loader无法继续运行，这也可能使SQL * Loader无法完成启用触发器和约束。在这种情况下，触发器和约束将保持禁用状态，直到手动启用它们。</p>
                     <p>虽然这种情况不太可能发生，但这是可能的。防止它的最佳方法是确保没有正在运行的应用程序可以在直接加载过程中启用表的触发器或约束。</p>
                     <p>如果由于未能获得正确的锁而终止直接加载，则仔细检查日志。它将显示已禁用的每个触发器和约束，并且每次尝试重新启用它们。应使用<a href="../sqlrf/ALTER-TABLE.html#SQLRF53523" target="_blank"><span class="italic">Oracle数据库SQL语言参考中</span></a>描述的<code class="codeph">ALTER</code> <code class="codeph">TABLE</code>语句的<code class="codeph">ENABLE</code>子句手动启用SQL * Loader未重新启用的任何触发器或约束<span class="italic">。</span></p>
                  </div>
                  <div>
                     <div class="familylinks">
                        <div class="parentlink">
                           <p><strong>父主题：</strong> <a href="oracle-sql-loader-conventional-and-direct-loads.html#GUID-973925DA-8F86-49C1-A707-4564DC3B57AE" title="使用传统的路径加载方法，使用标准SQL INSERT语句插入行数组;自动应用完整性约束和插入触发器。">直接路径加载，完整性约束和触发器</a></p>
                        </div>
                     </div>
                  </div>
                  
               </div><a id="SUTIL1343"></a><div class="props_rev_3"><a id="GUID-4686510F-DDCB-472D-BBDE-E8248452F46C" name="GUID-4686510F-DDCB-472D-BBDE-E8248452F46C"></a><h4 id="SUTIL-GUID-4686510F-DDCB-472D-BBDE-E8248452F46C" class="sect4"><span class="enumeration_section">12.8.4</span>使用并行常规路径负载提高性能</h4>
                  <div>
                     <p>如果触发器或完整性约束造成问题，但您希望加载速度更快，则应考虑使用并发传统路径加载。</p>
                     <p>也就是说，使用在多CPU系统上并发执行的多个加载会话。将输入数据文件拆分为逻辑记录边界上的单独文件，然后使用传统的路径加载会话加载每个此类输入数据文件。生成的负载具有以下属性：</p>
                     <ul style="list-style-type:disc">
                        <li>
                           <p>它比多CPU系统上的单个传统负载更快，但可能没有直接负载快。</p>
                        </li>
                        <li>
                           <p>触发触发，完整性约束应用于已加载的行，并使用标准DML执行逻辑维护索引。</p>
                        </li>
                     </ul>
                  </div>
                  <div>
                     <div class="familylinks">
                        <div class="parentlink">
                           <p><strong>父主题：</strong> <a href="oracle-sql-loader-conventional-and-direct-loads.html#GUID-973925DA-8F86-49C1-A707-4564DC3B57AE" title="使用传统的路径加载方法，使用标准SQL INSERT语句插入行数组;自动应用完整性约束和插入触发器。">直接路径加载，完整性约束和触发器</a></p>
                        </div>
                     </div>
                  </div>
                  
               </div>
            </div><a id="SUTIL1344"></a><div class="props_rev_3"><a id="GUID-ECBC6D01-4273-4102-983A-2139C5FB2887" name="GUID-ECBC6D01-4273-4102-983A-2139C5FB2887"></a><h3 id="SUTIL-GUID-ECBC6D01-4273-4102-983A-2139C5FB2887" class="sect3"><span class="enumeration_section">12.9</span>并行数据加载模型</h3>
               <div>
                  <p>本主题描述并行数据加载模型。</p>
                  <p>本节讨论三种基本的并发模型，您可以使用这些模型来最小化数据加载所需的时间：</p>
                  <ul style="list-style-type:disc">
                     <li>
                        <p>并发传统路径负载</p>
                     </li>
                     <li>
                        <p>使用直接路径加载方法进行跨段并发</p>
                     </li>
                     <li>
                        <p>使用直接路径加载方法的内部段并发</p>
                     </li>
                  </ul>
               </div>
               <div>
                  <ul class="ullinks">
                     <li class="ulchildlink"><a href="oracle-sql-loader-conventional-and-direct-loads.html#GUID-3BCEDA27-5150-48A7-B814-980D1804C2AC">并行常规路径加载</a><br>本主题描述使用并发传统路径加载。
                     </li>
                     <li class="ulchildlink"><a href="oracle-sql-loader-conventional-and-direct-loads.html#GUID-E766E9DD-344D-4B3B-80DC-8397BF8EF58D">具有直接路径的段间并发</a><br>段间并发可用于并发加载不同的对象。
                     </li>
                     <li class="ulchildlink"><a href="oracle-sql-loader-conventional-and-direct-loads.html#GUID-22CCC6F3-8862-4F8D-BECF-C0BCE1F25669">直接路径的内部段并发</a><br>SQL * Loader允许多个并发会话执行直接路径加载到同一个表或分区表的同一分区。
                     </li>
                     <li class="ulchildlink"><a href="oracle-sql-loader-conventional-and-direct-loads.html#GUID-E017C707-5C79-4B4D-A5BA-1FCF403BC24B">并行直接路径加载的限制</a><br>对并行直接路径加载强制实施限制。
                     </li>
                     <li class="ulchildlink"><a href="oracle-sql-loader-conventional-and-direct-loads.html#GUID-41EE1642-2A28-49F1-92C0-6327FDFA167B">启动多个SQL *加载程序会话</a><br>每个SQL * Loader会话都将不同的数据文件作为输入。在同一个表上执行直接加载的所有会话中，必须将<code class="codeph">PARALLEL</code>设置为<code class="codeph">TRUE</code> 。</li>
                     <li class="ulchildlink"><a href="oracle-sql-loader-conventional-and-direct-loads.html#GUID-077F71AE-FB17-4233-B35F-ED611930C9BD">并行直接路径加载的参数</a><br>执行并行直接路径加载时，可以使用选项指定要由加载程序分配的临时段的属性。
                     </li>
                     <li class="ulchildlink"><a href="oracle-sql-loader-conventional-and-direct-loads.html#GUID-E2A3A8A3-78FF-45B6-90C0-14211621E77C">并行直接路径加载后启用约束</a><br>所有数据加载完成后，必须手动启用约束和触发器。
                     </li>
                     <li class="ulchildlink"><a href="oracle-sql-loader-conventional-and-direct-loads.html#GUID-AFEA0C77-BA3D-4E2D-B4C2-76468FC54AAD">PRIMARY KEY和UNIQUE KEY约束</a><br>本主题描述使用PRIMARY KEY和UNIQUE KEY约束。
                     </li>
                  </ul>
                  <div class="familylinks">
                     <div class="parentlink">
                        <p><strong>父主题：</strong> <a href="oracle-sql-loader-conventional-and-direct-loads.html#GUID-321928FB-C86C-4F1F-9250-05111A988B7B" title="SQL * Loader提供了传统的路径加载方法和直接路径加载方法。">常规路径加载和直接路径加载</a></p>
                     </div>
                  </div>
               </div>
               <a id="SUTIL1345"></a><div class="props_rev_3"><a id="GUID-3BCEDA27-5150-48A7-B814-980D1804C2AC" name="GUID-3BCEDA27-5150-48A7-B814-980D1804C2AC"></a><h4 id="SUTIL-GUID-3BCEDA27-5150-48A7-B814-980D1804C2AC" class="sect4"><span class="enumeration_section">12.9.1</span>并发常规路径负载</h4>
                  <div>
                     <p>本主题描述使用并发传统路径加载。</p>
                     <p>在使用并发常规路径负载<a href="oracle-sql-loader-conventional-and-direct-loads.html#GUID-4686510F-DDCB-472D-BBDE-E8248452F46C" title="如果触发器或完整性约束造成问题，但您希望加载速度更快，则应考虑使用并发传统路径加载。">提高性能中</a>讨论了使用多个并发执行的路径加载会话，您可以使用此技术同时加载相同或不同的对象而不受任何限制。
                     </p>
                  </div>
                  <div>
                     <div class="familylinks">
                        <div class="parentlink">
                           <p><strong>父主题：</strong> <a href="oracle-sql-loader-conventional-and-direct-loads.html#GUID-ECBC6D01-4273-4102-983A-2139C5FB2887" title="本主题描述并行数据加载模型。">并行数据加载模型</a></p>
                        </div>
                     </div>
                  </div>
                  
               </div><a id="SUTIL1346"></a><div class="props_rev_3"><a id="GUID-E766E9DD-344D-4B3B-80DC-8397BF8EF58D" name="GUID-E766E9DD-344D-4B3B-80DC-8397BF8EF58D"></a><h4 id="SUTIL-GUID-E766E9DD-344D-4B3B-80DC-8397BF8EF58D" class="sect4"><span class="enumeration_section">12.9.2</span>具有直接路径的段间并发</h4>
                  <div>
                     <p>段间并发可用于并发加载不同的对象。</p>
                     <div class="section">
                        <p>您可以将此技术应用于不同表的并发直接路径加载，或同一表的不同分区的并发直接路径加载。</p>
                        <p>在直接路径加载单个分区时，请考虑以下各项：</p>
                        <ul style="list-style-type:disc">
                           <li>
                              <p>负载可以维护本地索引。</p>
                           </li>
                           <li>
                              <p>负载无法维护全局索引。</p>
                           </li>
                           <li>
                              <p>必须禁用参照完整性和<code class="codeph">CHECK</code>约束。
                              </p>
                           </li>
                           <li>
                              <p>必须禁用触发器。</p>
                           </li>
                           <li>
                              <p>输入数据应该被分区（否则许多记录将被拒绝，这会对性能产生负面影响）。</p>
                           </li>
                        </ul>
                     </div>
                     <!-- class="section" -->
                  </div>
                  <div>
                     <div class="familylinks">
                        <div class="parentlink">
                           <p><strong>父主题：</strong> <a href="oracle-sql-loader-conventional-and-direct-loads.html#GUID-ECBC6D01-4273-4102-983A-2139C5FB2887" title="本主题描述并行数据加载模型。">并行数据加载模型</a></p>
                        </div>
                     </div>
                  </div>
                  
               </div><a id="SUTIL1347"></a><div class="props_rev_3"><a id="GUID-22CCC6F3-8862-4F8D-BECF-C0BCE1F25669" name="GUID-22CCC6F3-8862-4F8D-BECF-C0BCE1F25669"></a><h4 id="SUTIL-GUID-22CCC6F3-8862-4F8D-BECF-C0BCE1F25669" class="sect4"><span class="enumeration_section">12.9.3</span>使用直接路径的段内并发</h4>
                  <div>
                     <p>SQL * Loader允许多个并发会话执行直接路径加载到同一个表或分区表的同一分区。</p>
                     <div class="section">
                        <p>在给定系统上的可用资源的情况下，多个SQL * Loader会话可提高直接路径加载的性能。</p>
                        <p>通过将<code class="codeph">DIRECT</code>和<code class="codeph">PARALLEL</code>参数都设置为<code class="codeph">TRUE</code>来启用此数据加载方法，并且通常将其称为并行直接路径加载。 <span class="italic"></span> 
                        </p>
                        <p>重要的是要意识到并行性是用户管理的。将<code class="codeph">PARALLEL</code>参数设置为<code class="codeph">TRUE</code>仅允许多个并发直接路径加载会话。
                        </p>
                     </div>
                     <!-- class="section" -->
                  </div>
                  <div>
                     <div class="familylinks">
                        <div class="parentlink">
                           <p><strong>父主题：</strong> <a href="oracle-sql-loader-conventional-and-direct-loads.html#GUID-ECBC6D01-4273-4102-983A-2139C5FB2887" title="本主题描述并行数据加载模型。">并行数据加载模型</a></p>
                        </div>
                     </div>
                  </div>
                  
               </div><a id="SUTIL1348"></a><div class="props_rev_3"><a id="GUID-E017C707-5C79-4B4D-A5BA-1FCF403BC24B" name="GUID-E017C707-5C79-4B4D-A5BA-1FCF403BC24B"></a><h4 id="SUTIL-GUID-E017C707-5C79-4B4D-A5BA-1FCF403BC24B" class="sect4"><span class="enumeration_section">12.9.4</span>并行直接路径加载的限制</h4>
                  <div>
                     <p>对并行直接路径加载强制实施限制。</p>
                     <div class="section">
                        <p>对并行直接路径加载强制执行以下限制：</p>
                        <ul style="list-style-type:disc">
                           <li>
                              <p>负载不能维护本地索引或全局索引。</p>
                           </li>
                           <li>
                              <p>只能附加行。无法使用<code class="codeph">REPLACE</code> ， <code class="codeph">TRUNCATE</code>和<code class="codeph">INSERT</code> （这是由于各个负载未协调）。如果必须在并行加载之前截断表，则必须手动执行。
                              </p>
                           </li>
                        </ul>
                        <p>此外，必须在并行直接路径加载时禁用以下对象。您不必采取任何操作来禁用它们。SQL * Loader在加载开始之前禁用它们，并在加载完成后重新启用它们：</p>
                        <ul style="list-style-type:disc">
                           <li>
                              <p>参照完整性约束</p>
                           </li>
                           <li>
                              <p>触发器</p>
                           </li>
                           <li>
                              <p>除非使用<code class="codeph">ENABLE_CHECK_CONSTRAINTS</code>控制文件选项，否则<code class="codeph">ENABLE_CHECK_CONSTRAINTS</code>检查约束</p>
                           </li>
                        </ul>
                        <p>如果将并行直接路径负载应用于单个分区，则应首先对数据进行分区（否则，由于分区不匹配导致的记录拒绝开销会降低负载）。</p>
                     </div>
                     <!-- class="section" -->
                  </div>
                  <div>
                     <div class="familylinks">
                        <div class="parentlink">
                           <p><strong>父主题：</strong> <a href="oracle-sql-loader-conventional-and-direct-loads.html#GUID-ECBC6D01-4273-4102-983A-2139C5FB2887" title="本主题描述并行数据加载模型。">并行数据加载模型</a></p>
                        </div>
                     </div>
                  </div>
                  
               </div><a id="SUTIL1349"></a><div class="props_rev_3"><a id="GUID-41EE1642-2A28-49F1-92C0-6327FDFA167B" name="GUID-41EE1642-2A28-49F1-92C0-6327FDFA167B"></a><h4 id="SUTIL-GUID-41EE1642-2A28-49F1-92C0-6327FDFA167B" class="sect4"><span class="enumeration_section">12.9.5</span>启动多个SQL *加载程序会话</h4>
                  <div>
                     <p>每个SQL * Loader会话都将不同的数据文件作为输入。在同一个表上执行直接加载的所有会话中，必须将<code class="codeph">PARALLEL</code>设置为<code class="codeph">TRUE</code> 。</p>
                     <div class="section">
                        <p>语法是：</p>
                        <div class="figure" id="GUID-41EE1642-2A28-49F1-92C0-6327FDFA167B__GUID-8E81E515-708B-457D-A9DC-E0D44073B2A2"><img src="img/parallel.gif" width="191" alt="parallel.eps的描述如下" title="parallel.eps的描述如下" longdesc="img_text/parallel.html"><br><a href="img_text/parallel.html">parallel.eps插图的描述</a></div>
                        <!-- class="figure" -->
                        <p>可以在命令行或参数文件中指定<code class="codeph">PARALLEL</code> 。它也可以在控制文件中使用<code class="codeph">OPTIONS</code>子句指定。
                        </p>
                        <p>例如，要在同一个表上启动三个SQL * Loader直接路径加载会话，您将在操作系统提示符下执行以下每个命令。输入每个命令后，系统将提示您输入密码。</p><pre class="oac_no_warn" dir="ltr">sqlldr USERID = scott CONTROL = load1.ctl DIRECT = TRUE PARALLEL = TRUE sqlldr USERID = scott CONTROL = load2.ctl DIRECT = TRUE PARALLEL = TRUE sqlldr USERID = scott CONTROL = load3.ctl DIRECT = TRUE PARALLEL = TRUE</pre><p>以前的命令必须在单独的会话中执行，或者如果在操作系统上允许，则作为单独的后台作业执行。请注意使用多个控制文件。这使您可以灵活地指定用于直接路径加载的文件。</p>
                        <div class="infoboxnote" id="GUID-41EE1642-2A28-49F1-92C0-6327FDFA167B__GUID-71DD4120-C95E-4F36-88C6-221D27476BCF">
                           <p class="notep1">注意：</p>
                           <p>并行加载期间不保留索引。加载完成后，必须手动创建或重新创建任何索引。您可以使用并行索引创建或并行索引重建功能来加速并行加载后构建大型索引。</p>
                        </div>
                        <p>执行并行加载时，SQL * Loader会为每个并发会话创建临时段，然后在完成时合并段。然后，从合并创建的段将添加到该段的高水位线上方的数据库中的现有段。在与SQL * Loader会话的其他扩展区组合之前，每个加载器会话的每个段使用的最后一个扩展区都会被修剪掉任何可用空间。</p>
                     </div>
                     <!-- class="section" -->
                  </div>
                  <div>
                     <div class="familylinks">
                        <div class="parentlink">
                           <p><strong>父主题：</strong> <a href="oracle-sql-loader-conventional-and-direct-loads.html#GUID-ECBC6D01-4273-4102-983A-2139C5FB2887" title="本主题描述并行数据加载模型。">并行数据加载模型</a></p>
                        </div>
                     </div>
                  </div>
                  
               </div><a id="SUTIL1350"></a><div class="props_rev_3"><a id="GUID-077F71AE-FB17-4233-B35F-ED611930C9BD" name="GUID-077F71AE-FB17-4233-B35F-ED611930C9BD"></a><h4 id="SUTIL-GUID-077F71AE-FB17-4233-B35F-ED611930C9BD" class="sect4"><span class="enumeration_section">12.9.6</span>并行直接路径加载的参数</h4>
                  <div>
                     <p>执行并行直接路径加载时，可以使用选项指定要由加载程序分配的临时段的属性。</p>
                     <p>这些选项使用<code class="codeph">FILE</code>和<code class="codeph">STORAGE</code>参数指定。这些参数仅对并行负载有效。
                     </p>
                  </div>
                  <div>
                     <ul class="ullinks">
                        <li class="ulchildlink"><a href="oracle-sql-loader-conventional-and-direct-loads.html#GUID-2C0957F1-1565-4BF4-B8B7-0EC428364F64">使用FILE参数指定临时段</a><br>为了实现最大I / O吞吐量，Oracle建议每个并发直接路径加载会话使用位于不同磁盘上的文件。
                        </li>
                     </ul>
                     <div class="familylinks">
                        <div class="parentlink">
                           <p><strong>父主题：</strong> <a href="oracle-sql-loader-conventional-and-direct-loads.html#GUID-ECBC6D01-4273-4102-983A-2139C5FB2887" title="本主题描述并行数据加载模型。">并行数据加载模型</a></p>
                        </div>
                     </div>
                  </div>
                  <a id="SUTIL1351"></a><div class="props_rev_3"><a id="GUID-2C0957F1-1565-4BF4-B8B7-0EC428364F64" name="GUID-2C0957F1-1565-4BF4-B8B7-0EC428364F64"></a><h5 id="SUTIL-GUID-2C0957F1-1565-4BF4-B8B7-0EC428364F64" class="sect5"><span class="enumeration_section">12.9.6.1</span>使用FILE参数指定临时段</h5>
                     <div>
                        <p>为了实现最大I / O吞吐量，Oracle建议每个并发直接路径加载会话使用位于不同磁盘上的文件。</p>
                        <div class="section">
                           <p>在SQL * Loader控制文件中，使用<code class="codeph">OPTIONS</code>子句的<code class="codeph">FILE</code>参数指定要加载的对象（表或分区）的表空间中任何有效数据文件的文件名。
                           </p>
                           <p>例如：</p><pre class="oac_no_warn" dir="ltr">LOAD DATA INFILE'load1.dat'INSERT INTO TABLE emp OPTIONS（FILE ='/ dat / data1.dat'）（empno POSITION（01:04）INTEGER EXTERNAL NULLIF empno = BLANKS ...
</pre><p>您还可以在每个并发SQL * Loader会话的命令行上指定<code class="codeph">FILE</code>参数，但随后它将全局应用于使用该会话加载的所有对象。
                           </p>
                        </div>
                        <!-- class="section" -->
                     </div>
                     <div>
                        <ul class="ullinks">
                           <li class="ulchildlink"><a href="oracle-sql-loader-conventional-and-direct-loads.html#GUID-E6F2E3CA-752D-4F64-A2F6-6C1A3392CC33">使用FILE参数</a><br>本主题介绍如何使用FILE参数。
                           </li>
                           <li class="ulchildlink"><a href="oracle-sql-loader-conventional-and-direct-loads.html#GUID-1CCB7222-4167-4F10-B944-A7D3557B58DA">使用STORAGE参数</a><br>您可以使用<code class="codeph">STORAGE</code>参数指定为并行直接路径加载分配的临时段的存储属性。
                           </li>
                        </ul>
                        <div class="familylinks">
                           <div class="parentlink">
                              <p><strong>父主题：</strong> <a href="oracle-sql-loader-conventional-and-direct-loads.html#GUID-077F71AE-FB17-4233-B35F-ED611930C9BD" title="执行并行直接路径加载时，可以使用选项指定要由加载程序分配的临时段的属性。">并行直接路径加载的参数</a></p>
                           </div>
                        </div>
                     </div>
                     <a id="SUTIL1352"></a><div class="props_rev_3"><a id="GUID-E6F2E3CA-752D-4F64-A2F6-6C1A3392CC33" name="GUID-E6F2E3CA-752D-4F64-A2F6-6C1A3392CC33"></a><h6 id="SUTIL-GUID-E6F2E3CA-752D-4F64-A2F6-6C1A3392CC33" class="sect6"><span class="enumeration_section">12.9.6.1.1</span>使用FILE参数</h6>
                        <div>
                           <p>本主题介绍如何使用FILE参数。</p>
                           <div class="section">
                              <p>Oracle数据库中的<code class="codeph">FILE</code>参数对并行直接路径加载具有以下限制：</p>
                              <ul style="list-style-type:disc">
                                 <li>
                                    <p><span class="bold">对于非分区表：</span>指定的文件必须位于正在加载的表的表空间中。
                                    </p>
                                 </li>
                                 <li>
                                    <p><span class="bold">对于分区表，单分区加载：</span>指定的文件必须位于正在加载的分区的表空间中。
                                    </p>
                                 </li>
                                 <li>
                                    <p><span class="bold">对于分区表，全表加载：</span>指定的文件必须位于正在加载的所有分区的表空间中;也就是说，所有分区必须位于同一个表空间中。
                                    </p>
                                 </li>
                              </ul>
                           </div>
                           <!-- class="section" -->
                        </div>
                        <div>
                           <div class="familylinks">
                              <div class="parentlink">
                                 <p><strong>父主题：</strong> <a href="oracle-sql-loader-conventional-and-direct-loads.html#GUID-2C0957F1-1565-4BF4-B8B7-0EC428364F64" title="为了实现最大I / O吞吐量，Oracle建议每个并发直接路径加载会话使用位于不同磁盘上的文件。">使用FILE参数指定临时段</a></p>
                              </div>
                           </div>
                        </div>
                        
                     </div><a id="SUTIL1353"></a><div class="props_rev_3"><a id="GUID-1CCB7222-4167-4F10-B944-A7D3557B58DA" name="GUID-1CCB7222-4167-4F10-B944-A7D3557B58DA"></a><h6 id="SUTIL-GUID-1CCB7222-4167-4F10-B944-A7D3557B58DA" class="sect6"><span class="enumeration_section">12.9.6.1.2</span>使用STORAGE参数</h6>
                        <div>
                           <p>您可以使用<code class="codeph">STORAGE</code>参数指定为并行直接路径加载分配的临时段的存储属性。
                           </p>
                           <p>如果未使用<code class="codeph">STORAGE</code>参数，则使用包含正在加载的对象（表，分区）的段的存储属性。此外，如果未指定<code class="codeph">STORAGE</code>参数，则SQL * Loader对<code class="codeph">EXTENTS</code>使用默认值2 KB。</p>
                           <p>例如，以下<code class="codeph">OPTIONS</code>子句可用于指定<code class="codeph">STORAGE</code>参数：</p><pre class="oac_no_warn" dir="ltr">选项（存储=（初始100M下一个100M PCTINCREASE 0））</pre><p>您只能在SQL * Loader控制文件中使用<code class="codeph">STORAGE</code>参数，而不能在命令行中使用。使用<code class="codeph">STORAGE</code>参数指定除<code class="codeph">PCTINCREASE</code> 0以外的任何内容，强烈建议不要使用<code class="codeph">INITIAL</code>或<code class="codeph">NEXT</code>值，并且可以静默忽略。
                           </p>
                        </div>
                        <div>
                           <div class="familylinks">
                              <div class="parentlink">
                                 <p><strong>父主题：</strong> <a href="oracle-sql-loader-conventional-and-direct-loads.html#GUID-2C0957F1-1565-4BF4-B8B7-0EC428364F64" title="为了实现最大I / O吞吐量，Oracle建议每个并发直接路径加载会话使用位于不同磁盘上的文件。">使用FILE参数指定临时段</a></p>
                              </div>
                           </div>
                        </div>
                        
                     </div>
                  </div>
               </div><a id="SUTIL1354"></a><div class="props_rev_3"><a id="GUID-E2A3A8A3-78FF-45B6-90C0-14211621E77C" name="GUID-E2A3A8A3-78FF-45B6-90C0-14211621E77C"></a><h4 id="SUTIL-GUID-E2A3A8A3-78FF-45B6-90C0-14211621E77C" class="sect4"><span class="enumeration_section">12.9.7</span>在并行直接路径加载后启用约束</h4>
                  <div>
                     <p>所有数据加载完成后，必须手动启用约束和触发器。</p>
                     <p>因为每个SQL * Loader会话可以在直接路径加载后尝试重新启用对表的约束，所以存在一个会话可能在另一个会话完成加载数据之前尝试重新启用约束的危险。在这种情况下，完成加载的第一个会话将无法启用约束，因为其余会话拥有表上的共享锁。</p>
                     <p>由于存在直接路径加载后可能无法重新启用某些约束的危险，因此应在完成加载后检查约束的状态，以确保正确启用它。</p>
                  </div>
                  <div>
                     <div class="familylinks">
                        <div class="parentlink">
                           <p><strong>父主题：</strong> <a href="oracle-sql-loader-conventional-and-direct-loads.html#GUID-ECBC6D01-4273-4102-983A-2139C5FB2887" title="本主题描述并行数据加载模型。">并行数据加载模型</a></p>
                        </div>
                     </div>
                  </div>
                  
               </div><a id="SUTIL1355"></a><div class="props_rev_3"><a id="GUID-AFEA0C77-BA3D-4E2D-B4C2-76468FC54AAD" name="GUID-AFEA0C77-BA3D-4E2D-B4C2-76468FC54AAD"></a><h4 id="SUTIL-GUID-AFEA0C77-BA3D-4E2D-B4C2-76468FC54AAD" class="sect4"><span class="enumeration_section">12.9.8</span> PRIMARY KEY和UNIQUE KEY约束</h4>
                  <div>
                     <p>本主题描述使用PRIMARY KEY和UNIQUE KEY约束。</p>
                     <p><code class="codeph">PRIMARY</code> <code class="codeph">KEY</code>和<code class="codeph">UNIQUE</code> <code class="codeph">KEY</code>约束在启用时会在表上创建索引，如果表非常大，则在直接路径加载会话之后可能需要很长时间才能启用。您应该考虑在加载后手动启用这些约束（而不是指定自动启用功能）。这使您可以并行手动创建所需的索引，以便在启用约束之前节省时间。
                     </p>
                  </div>
                  <div>
                     <div class="familylinks">
                        <div class="parentlink">
                           <p><strong>父主题：</strong> <a href="oracle-sql-loader-conventional-and-direct-loads.html#GUID-ECBC6D01-4273-4102-983A-2139C5FB2887" title="本主题描述并行数据加载模型。">并行数据加载模型</a></p>
                        </div>
                     </div>
                  </div>
                  
               </div>
            </div><a id="SUTIL1356"></a><div class="props_rev_3"><a id="GUID-D2838CE7-9E98-42FD-A5B0-FACEB40AD98C" name="GUID-D2838CE7-9E98-42FD-A5B0-FACEB40AD98C"></a><h3 id="SUTIL-GUID-D2838CE7-9E98-42FD-A5B0-FACEB40AD98C" class="sect3"><span class="enumeration_section">12.10</span>一般绩效改进提示</h3>
               <div>
                  <p>本主题描述了一般性能改进的提示。</p>
                  <div class="section">
                     <p>如果您可以控制要加载的数据的格式，则可以使用以下提示来提高加载性能：</p>
                     <ul style="list-style-type:disc">
                        <li>
                           <p>使逻辑记录处理高效。</p>
                           <ul style="list-style-type:disc">
                              <li>
                                 <p>使用物理记录与逻辑记录的一对一映射（避免使用<code class="codeph">CONTINUEIF</code>和<code class="codeph">CONCATENATE</code> ）。
                                 </p>
                              </li>
                              <li>
                                 <p>使软件可以轻松识别物理记录边界。使用文件处理选项字符串<code class="codeph">"FIX nnn"</code>或<code class="codeph">"VAR"</code> 。如果使用默认（流模式），则在大多数平台（例如，UNIX和NT）上，加载程序必须扫描每个物理记录以查找记录终止符（换行符）。
                                 </p>
                              </li>
                           </ul>
                        </li>
                        <li>
                           <p>使现场设置高效。字段设置是将数据文件中的字段映射到正在加载的表中的相应列的过程。映射功能由控制文件中字段的描述控制。字段设置（以及数据转换）是大多数负载的CPU周期的最大消费者。</p>
                           <ul style="list-style-type:disc">
                              <li>
                                 <p>避免划定字段;使用位置字段。如果使用分隔字段，则加载程序必须扫描输入数据以查找分隔符。如果使用位置字段，则字段设置将变为简单的指针算法（非常快）。</p>
                              </li>
                              <li>
                                 <p>如果不需要，请不要修剪空格（使用<code class="codeph">PRESERVE</code> <code class="codeph">BLANKS</code> ）。
                                 </p>
                              </li>
                           </ul>
                        </li>
                        <li>
                           <p>使转化更有效率。SQL * Loader为您执行字符集转换和数据类型转换。当然，最快的转换是没有转换。</p>
                           <ul style="list-style-type:disc">
                              <li>
                                 <p>如果可以，请使用单字节字符集。</p>
                              </li>
                              <li>
                                 <p>如果可以，请避免字符集转换。SQL * Loader支持四个字符集：</p>
                                 <ul style="list-style-type:disc">
                                    <li>
                                       <p>客户端字符集（客户端<code class="codeph">sqlldr</code>进程的<code class="codeph">NLS_LANG</code> ）</p>
                                    </li>
                                    <li>
                                       <p>数据文件字符集（通常与客户端字符集相同）</p>
                                    </li>
                                    <li>
                                       <p>数据库字符集</p>
                                    </li>
                                    <li>
                                       <p>数据库国家字符集</p>
                                    </li>
                                 </ul>
                                 <p>如果所有字符集都相同，则优化性能。对于直接路径加载，最好是数据文件字符集和数据库字符集相同。如果字符集相同，则不分配字符集转换缓冲区。</p>
                              </li>
                           </ul>
                        </li>
                        <li>
                           <p>使用直接路径加载。</p>
                        </li>
                        <li>
                           <p>使用<code class="codeph">SORTED</code> <code class="codeph">INDEXES</code>子句。
                           </p>
                        </li>
                        <li>
                           <p>避免不必要的<code class="codeph">NULLIF</code>和<code class="codeph">DEFAULTIF</code>子句。必须在每个列上评估每个子句，该列对于每个加载的行都有与之关联的子句。
                           </p>
                        </li>
                        <li>
                           <p>尽可能使用并行直接路径加载和并行索引创建。</p>
                        </li>
                        <li>
                           <p>当<code class="codeph">CONCATENATE</code>子句和<code class="codeph">COLUMNARRAYROWS</code>子句具有较大的值时，请注意对性能的影响。请参阅<a href="oracle-sql-loader-control-file-contents.html#GUID-2F2DCBD4-CEEB-4479-AF6E-38F0BAF4499E" title="如果希望SQL * Loader始终组合相同数量的物理记录以形成一个逻辑记录，请使用CONCATENATE。">使用CONCATENATE汇编逻辑记录</a> 。
                           </p>
                        </li>
                     </ul>
                  </div>
                  <!-- class="section" -->
               </div>
               <div>
                  <div class="familylinks">
                     <div class="parentlink">
                        <p><strong>父主题：</strong> <a href="oracle-sql-loader-conventional-and-direct-loads.html#GUID-321928FB-C86C-4F1F-9250-05111A988B7B" title="SQL * Loader提供了传统的路径加载方法和直接路径加载方法。">常规路径加载和直接路径加载</a></p>
                     </div>
                  </div>
               </div>
               
            </div>
         </div>
      </article>
   </body>
</html>