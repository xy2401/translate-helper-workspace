<html lang="en-us" dir="ltr" xml:lang="en-us">
   <head>
      <meta http-equiv="Content-Type" content="text/html; charset=utf-8"></meta>
      <meta name="viewport" content="width=device-width, initial-scale=1"></meta>
      <meta http-equiv="X-UA-Compatible" content="IE=edge"></meta>
      <meta name="abstract" content="Topics here cover how to use the Extensible Markup Language (XML) schema processor for Java."></meta>
      <meta name="description" content="Topics here cover how to use the Extensible Markup Language (XML) schema processor for Java."></meta>
      <title>使用XML Schema Processor for Java</title>
      <meta property="og:site_name" content="Oracle Help Center"></meta>
      <meta property="og:title" content="Programmer&#39;s Guide"></meta>
      <meta property="og:description" content="Topics here cover how to use the Extensible Markup Language (XML) schema processor for Java."></meta>
      <link rel="stylesheet" href="/sp_common/book-template/ohc-book-template/css/book.css"></link>
      <link rel="shortcut icon" href="/sp_common/book-template/ohc-common/img/favicon.ico"></link>
      <meta name="application-name" content="Programmer&#39;s Guide"></meta>
      <meta name="generator" content="DITA Open Toolkit version 1.8.5 (Mode = doc)"></meta>
      <meta name="plugin" content="SP_docbuilder HTML plugin release 18.2.2"></meta>
      <link rel="alternate" href="xml-developers-kit-programmers-guide.pdf" title="PDF File" type="application/pdf"></link>
      <meta name="robots" content="all"></meta>
      <link rel="schema.dcterms" href="http://purl.org/dc/terms/"></link>
      <meta name="dcterms.created" content="2019-01-11T05:58:48-08:00"></meta>
      
      <meta name="dcterms.dateCopyrighted" content="2001, 2019"></meta>
      <meta name="dcterms.category" content="database"></meta>
      <meta name="dcterms.identifier" content="E96292-01"></meta>
      
      <meta name="dcterms.product" content="en/database/oracle/oracle-database/19"></meta>
      
      <link rel="prev" href="using-xquery-API-for-Java-to-access-XML-DB.html" title="Previous" type="text/html"></link>
      <link rel="next" href="using-JAXB-class-generator.html" title="Next" type="text/html"></link>
      <script>
        document.write('<style type="text/css">');
        document.write('body > .noscript, body > .noscript ~ * { visibility: hidden; }');
        document.write('</style>');
     </script>
      <script src="/sp_common/book-template/requirejs/require.js" data-main="/sp_common/book-template/ohc-book-template/js/book-config"></script>
      <script>
            if (window.require === undefined) {
                document.write('<script data-main="sp_common/book-template/ohc-book-template/js/book-config" src="sp_common/book-template/requirejs/require.js"><\/script>');
                document.write('<link href="sp_common/book-template/ohc-book-template/css/book.css" rel="stylesheet"/>');
            }
        </script>
      <script type="application/json" id="ssot-metadata">{"primary":{"category":{"short_name":"database","element_name":"Database","display_in_url":true},"suite":{"short_name":"oracle","element_name":"Oracle","display_in_url":true},"product_group":{"short_name":"not-applicable","element_name":"Not applicable","display_in_url":false},"product":{"short_name":"oracle-database","element_name":"Oracle Database","display_in_url":true},"release":{"short_name":"19","element_name":"Release 19","display_in_url":true}}}</script>
      
    <meta name="dcterms.title" content="XML Developers Kit Programmers Guide"></meta>
    <meta name="dcterms.isVersionOf" content="ADXDK"></meta>
    <meta name="dcterms.release" content="Release 19"></meta>
  </head>
   <body dir="ltr">
      <div class="noscript alert alert-danger text-center" role="alert">
         <a href="using-xquery-API-for-Java-to-access-XML-DB.html" class="pull-left"><span class="glyphicon glyphicon-chevron-left" aria-hidden="true"></span>上一页</a> <a href="using-JAXB-class-generator.html" class="pull-right">下一页<span class="glyphicon glyphicon-chevron-right" aria-hidden="true"></span></a> <span class="fa fa-exclamation-triangle" aria-hidden="true"></span>必须启用JavaScript才能正确显示此内容</div>
      <article>
         <header>
            <ol class="breadcrumb" vocab="http://schema.org/" typeof="BreadcrumbList">
               <li property="itemListElement" typeof="ListItem"><a href="index.html" property="item" typeof="WebPage"><span property="name">程序员指南</span></a></li>
               <li property="itemListElement" typeof="ListItem"><a href="XDK-for-Java.html" property="item" typeof="WebPage"><span property="name">Oracle XML Developer's Kit for Java</span></a></li>
               <li class="active" property="itemListElement" typeof="ListItem">使用XML Schema Processor for Java</li>
            </ol>
            <a id="GUID-F41C7DA2-A3DF-463B-A08C-24E8F0621450" name="GUID-F41C7DA2-A3DF-463B-A08C-24E8F0621450"></a><a id="ADXDK993"></a><a id="ADXDK5000"></a>
            
            <h2 id="ADXDK-GUID-F41C7DA2-A3DF-463B-A08C-24E8F0621450" class="sect2"><span class="enumeration_chapter">17</span>使用XML Schema Processor for Java</h2>
         </header>
         <div class="ind">
            <div>
               <p>这里的主题介绍了如何使用Java的可扩展标记语言（XML）模式处理器。</p>
               <div class="section"> </div>
               <!-- class="section" -->
            </div><a id="ADXDK994"></a><a id="ADXDK19254"></a><div class="props_rev_3"><a id="GUID-AEB7C697-2E71-4AC1-8DFB-EB6531552A50" name="GUID-AEB7C697-2E71-4AC1-8DFB-EB6531552A50"></a><h3 id="ADXDK-GUID-AEB7C697-2E71-4AC1-8DFB-EB6531552A50" class="sect3">XML验证简介</h3>
               <div>
                  <p>主题涵盖了XML验证的不同技术。</p>
                  <div class="section"> </div>
                  <!-- class="section" -->
               </div><a id="ADXDK19255"></a><div class="props_rev_3"><a id="GUID-D28C9F71-7B8B-4508-808B-C6A96F1DDE4A" name="GUID-D28C9F71-7B8B-4508-808B-C6A96F1DDE4A"></a><h4 id="ADXDK-GUID-D28C9F71-7B8B-4508-808B-C6A96F1DDE4A" class="sect4">使用Java Schema Processor for Java的先决条件</h4>
                  <div>
                     <p>涵盖了使用XML模式处理器的先决条件。</p>
                     <p>本节假定您具备这些技术的工作知识：</p>
                     <ul style="list-style-type:disc">
                        <li>
                           <p><a href="glossary.html#GUID-F2AC11F4-F0D2-4EFB-B28B-8114CC0D7C38"><span class="xrefglossterm">文档类型定义（DTD）</span></a> 。XML文档类型定义（DTD）定义XML文档的合法结构。
                           </p>
                        </li>
                        <li>
                           <p><a href="glossary.html#GUID-B1E6F2C9-39D7-42D5-817B-6210231ABF97" title="XML Schema语言也称为XML Schema，是一种W3C建议，用于在XML文档中使用简单数据类型和复杂结构。它解决了目前DTD中缺乏的领域，包括数据类型的定义和验证。"><span class="xrefglossterm">XML Schema语言</span></a> 。XML Schema定义XML文档的法律结构。
                           </p>
                        </li>
                     </ul>
                     <p>要了解有关这些技术的更多信息，请参阅<a href="preface.html#GUID-2CD1F6B6-C8EC-42E3-97F2-589AABF9AFFB" title="列出了与此文档相关的Oracle资源。">相关文档中</a>的XML资源。
                     </p>
                  </div>
               </div><a id="ADXDK19256"></a><div class="props_rev_3"><a id="GUID-2CE6171F-CBF0-439A-AC05-84C27B4F0D72" name="GUID-2CE6171F-CBF0-439A-AC05-84C27B4F0D72"></a><h4 id="ADXDK-GUID-2CE6171F-CBF0-439A-AC05-84C27B4F0D72" class="sect4">用于Java的XML模式处理器的标准和规范</h4>
                  <div>
                     <p>XML Schema是万维网联盟（W3C）标准。</p>
                     <p>Oracle XML Schema处理器支持W3C XML Schema规范：</p>
                     <ul style="list-style-type:disc">
                        <li>
                           <p><a href="https://www.oracle.com/pls/topic/lookup?ctx=en/database/oracle/oracle-database/19/adxdk&amp;id=w3_org_tr_xschema0_primer" target="_blank"><span class="italic">XML Schema第0部分：入门</span></a> 
                           </p>
                        </li>
                        <li>
                           <p><a href="https://www.oracle.com/pls/topic/lookup?ctx=en/database/oracle/oracle-database/19/adxdk&amp;id=w3_org_tr_xschema1_struct" target="_blank"><span class="italic">XML Schema第1部分：结构</span></a></p>
                        </li>
                        <li>
                           <p><a href="https://www.oracle.com/pls/topic/lookup?ctx=en/database/oracle/oracle-database/19/adxdk&amp;id=w3_org_tr_xschema2_types" target="_blank"><span class="italic">XML Schema第2部分：数据类型</span></a></p>
                        </li>
                     </ul>
                  </div>
                  <div>
                     <div class="relinfo">
                        <p><strong>相关话题</strong></p>
                        <ul>
                           <li><a href="XDK-standards.html#GUID-795A483B-12AC-4F6D-A606-6BE9DA963F0F" title="描述了Oracle XML Developer&#39;s Kit（XDK）标准。">Oracle XML Developer的套件标准</a></li>
                        </ul>
                     </div>
                  </div>
                  
               </div><a id="ADXDK19257"></a><div class="props_rev_3"><a id="GUID-C8292C78-3BDC-4D6E-A97A-B820220A10FA" name="GUID-C8292C78-3BDC-4D6E-A97A-B820220A10FA"></a><h4 id="ADXDK-GUID-C8292C78-3BDC-4D6E-A97A-B820220A10FA" class="sect4">使用DTD进行XML验证</h4>
                  <div>
                     <p>文档类型定义（DTD）最初是为SGML开发的。 XML DTD是SGML中可用的子集，它提供了一种声明XML标记约束的机制。XML DTD支持以下规范：</p>
                     <ul style="list-style-type:disc">
                        <li>
                           <p>XML文档中可以包含哪些元素。</p>
                        </li>
                        <li>
                           <p>XML元素的内容模型，即元素是仅包含数据还是具有一组定义其结构的子元素。DTD可以定义子元素是可选的还是必需的，以及它是否只能出现一次或多次。</p>
                        </li>
                        <li>
                           <p>XML元素的属性。DTD还可以指定属性是可选的还是必需的。</p>
                        </li>
                        <li>
                           <p>在XML文档中合法的实体。</p>
                        </li>
                     </ul>
                     <p>XML DTD本身不是用XML编写的，而是一种与上下文无关的语法，用于定义XML文档的结构。您可以在XML文档本身或XML文档的单独文件中声明DTD。</p>
                     <p>验证是根据其关联的DTD验证XML文档的过程，确保结构，元素的使用和属性的使用与DTD中的定义一致。因此，处理XML文档的应用程序可以假定数据与定义匹配。</p>
                     <p>使用XDK，您可以编写包含验证XML解析器的应用程序;也就是说，一个程序根据DTD解析和验证XML文档。根据其实现，验证解析器可以：</p>
                     <ul style="list-style-type:disc">
                        <li>
                           <p>在遇到错误时停止处理，或继续。</p>
                        </li>
                        <li>
                           <p>在报告发生时报告警告和错误，或在处理结束时报告摘要形式。</p>
                        </li>
                        <li>
                           <p>启用或禁用验证模式</p>
                           <p>大多数处理器可以启用或禁用验证模式，但它们仍然必须处理实体定义和DTD的其他构造。</p>
                        </li>
                     </ul>
                  </div><a id="ADXDK19259"></a><a id="ADXDK19260"></a><a id="ADXDK19258"></a><div class="props_rev_3"><a id="GUID-BD98BC10-64C1-435A-903D-9D80D69D1C1D" name="GUID-BD98BC10-64C1-435A-903D-9D80D69D1C1D"></a><h5 id="ADXDK-GUID-BD98BC10-64C1-435A-903D-9D80D69D1C1D" class="sect5">XDK中的DTD样本</h5>
                     <div>
                        <p>显示了一个示例DTD，以及符合该DTD的示例XML文档。</p>
                        <p><a href="using-XML-schema-processor-for-Java.html#GUID-BD98BC10-64C1-435A-903D-9D80D69D1C1D__CIHDHBEE">例17-1</a>显示了名为<code class="codeph">family.dtd</code>的DTD的内容，该DTD位于<code class="codeph">$ORACLE_HOME/xdk/demo/java/parser/common/</code> 。<code class="codeph">&lt;ELEMENT&gt;</code>标签指定文档中元素的合法命名和结构，而<code class="codeph">&lt;ATTLIST&gt;</code>标签指定元素的合法属性。
                        </p>
                        <p><a href="using-XML-schema-processor-for-Java.html#GUID-BD98BC10-64C1-435A-903D-9D80D69D1C1D__CIHCDDBD">例17-2</a>显示了名为<code class="codeph">family.xml</code>的XML文档的内容，该文档也位于<code class="codeph">$ORACLE_HOME/xdk/demo/java/parser/common/</code> 。<code class="codeph">&lt;!<code class="codeph">family.xml</code> DOCTYPE&gt;</code>元素指定此XML文档符合名为<code class="codeph">family.dtd</code>的外部DTD。
                        </p>
                        <div class="example" id="GUID-BD98BC10-64C1-435A-903D-9D80D69D1C1D__CIHDHBEE">
                           <p class="titleinexample">例17-1 family.dtd</p><pre class="oac_no_warn" dir="ltr">&lt;？xml version =“1.0”encoding =“UTF-8”？&gt; &lt;！ELEMENT家族（会员*）&gt; &lt;！ATTLIST家族姓氏CDATA #REQUIRED&gt; &lt;！ELEMENT成员（#PCDATA）&gt; &lt;！ATTLIST会员会员ID #REQUIRED&gt; &lt;！ATTLIST成员爸爸IDREF #IMPLIED&gt; &lt;！ATTLIST成员妈妈IDREF #IMPLIED&gt;</pre></div>
                        <!-- class="example" -->
                        <div class="example" id="GUID-BD98BC10-64C1-435A-903D-9D80D69D1C1D__CIHCDDBD">
                           <p class="titleinexample">例17-2 family.xml</p><pre class="oac_no_warn" dir="ltr">&lt;？xml version =“1.0”standalone =“no”？&gt; &lt;！DOCTYPE系列SYSTEM“family.dtd”&gt; &lt;family lastname =“Smith”&gt; &lt;member memberid =“m1”&gt; Sarah &lt;/ member&gt; &lt;member memberid =“m2”&gt; Bob &lt;/ member&gt; &lt;member memberid =“m3” mom =“m1”dad =“m2”&gt; Joanne &lt;/ member&gt; &lt;member memberid =“m4”mom =“m1”dad =“m2”&gt; Jim &lt;/ member&gt; &lt;/ family&gt;</pre></div>
                        <!-- class="example" -->
                     </div>
                  </div>
               </div><a id="ADXDK19261"></a><div class="props_rev_3"><a id="GUID-674379DA-81FD-43CD-9C8B-998B70A11103" name="GUID-674379DA-81FD-43CD-9C8B-998B70A11103"></a><h4 id="ADXDK-GUID-674379DA-81FD-43CD-9C8B-998B70A11103" class="sect4">使用XML模式进行XML验证</h4>
                  <div>
                     <p>介绍了涉及使用XML模式进行验证的概念。</p>
                     <p><a href="glossary.html#GUID-B1E6F2C9-39D7-42D5-817B-6210231ABF97" title="XML Schema语言也称为XML Schema，是一种W3C建议，用于在XML文档中使用简单数据类型和复杂结构。它解决了目前DTD中缺乏的领域，包括数据类型的定义和验证。"><span class="xrefglossterm">XML Schema语言</span></a> （也称为<a href="glossary.html#GUID-8FD3F1F2-EA9C-4AED-955B-FE1570ABECDE" title="相当于XML Schema语言。"><span class="xrefglossterm">XML Schema Definition</span></a> ）是由W3C创建的，它使用XML语法来描述XML文档的内容和结构。<a href="glossary.html#GUID-085CAB85-F0BC-4D3B-A282-21E17B0BC9B3" title="用XML Schema语言编写的文档。"><span class="xrefglossterm">XML模式</span></a>是用XML模式语言编写的XML文档。XML模式文档包含描述输入XML文档结构的规则，称为<a href="glossary.html#GUID-C0B7CAC1-AB51-490D-AA39-ED961BB623CD" title="根据XML模式验证的XML文档。如果实例文档符合模式的规则，则认为它是有效的。"><span class="xrefglossterm">实例文档</span></a> 。当且仅当实例文档符合XML模式的规则时，实例文档才有效。
                     </p>
                     <p>XML Schema语言定义了以下内容：</p>
                     <ul style="list-style-type:disc">
                        <li>
                           <p>实例文档中哪些元素和属性是合法的</p>
                        </li>
                        <li>
                           <p>哪些元素可以是其他元素的子元素</p>
                        </li>
                        <li>
                           <p>子元素的顺序和数量</p>
                        </li>
                        <li>
                           <p>元素和属性的数据类型</p>
                        </li>
                        <li>
                           <p>元素和属性的默认值和固定值</p>
                        </li>
                     </ul>
                     <p>验证XML解析器尝试确定实例文档是否符合其关联XML模式的规则。使用XDK，您可以编写一个执行此模式验证的验证解析器。根据其实现，验证解析器可以：</p>
                     <ul style="list-style-type:disc">
                        <li>
                           <p>在遇到错误时停止处理，或继续。</p>
                        </li>
                        <li>
                           <p>在报告发生时报告警告和错误，或在处理结束时报告摘要形式。</p>
                        </li>
                     </ul>
                     <p>处理器必须考虑实体定义以及实例文档中包含的DTD中定义的其他构造。XML Schema语言没有定义当实例文档同时包含XML模式和DTD时必须发生的事情。因此，在这种情况下应用程序的行为取决于实现。</p>
                  </div><a id="ADXDK19263"></a><a id="ADXDK19264"></a><a id="ADXDK19262"></a><div class="props_rev_3"><a id="GUID-E2B411D7-FE12-4E41-B9D8-201FF4D473F3" name="GUID-E2B411D7-FE12-4E41-B9D8-201FF4D473F3"></a><h5 id="ADXDK-GUID-E2B411D7-FE12-4E41-B9D8-201FF4D473F3" class="sect5">XDK中的XML模式示例</h5>
                     <div>
                        <p>将显示一个示例XML文档，其中包含一个购买报告，该报告描述了在不同区域中订购的零件。该文档位于<code class="codeph">$ORACLE_HOME/xdk/demo/java/schema/report.xml</code> 。还显示了可用于验证<code class="codeph">report.xml</code>的XML模式文档<code class="codeph">report.xsd</code> 。
                        </p>
                        <p>除其他外，XML模式定义实例文档中合法的元素的名称以及元素可以包含的数据类型。</p>
                        <div class="example" id="GUID-E2B411D7-FE12-4E41-B9D8-201FF4D473F3__BABHGCFC">
                           <p class="titleinexample">例17-3 report.xml</p><pre class="pre codeblock"><code>&lt;purchaseReport xmlns =“http://www.example.com/Report”xmlns：xsi =“http://www.w3.org/2001/XMLSchema-instance”xsi：schemaLocation =“http：//www.example .com / Report report.xsd“period =”P3M“periodEnding =”1999-12-31“&gt; &lt;regions&gt; &lt;zip code =”95819“&gt; &lt;part number =”872-AA“quantity =”1“/&gt; &lt;part number =“926-AA”quantity =“1”/&gt; &lt;part number =“833-AA”quantity =“1”/&gt; &lt;part number =“455-BX”quantity =“1”/&gt; &lt;/ zip&gt; &lt;zip code =“63143”&gt; &lt;part number =“455-BX”quantity =“4”/&gt; &lt;/ zip&gt; &lt;/ regions&gt; &lt;parts&gt; &lt;part number =“872-AA”&gt;割草机&lt;/ part&gt; &lt;part number =“926-AA”&gt;婴儿监视器&lt;/ part&gt; &lt;part number =“833-AA”&gt; Lapis项链&lt;/ part&gt; &lt;part number =“455-BX”&gt;坚固的货架&lt;/ part&gt; &lt;/ parts&gt; &lt;/ purchaseReport&gt;</code></pre></div>
                        <!-- class="example" -->
                        <div class="example" id="GUID-E2B411D7-FE12-4E41-B9D8-201FF4D473F3__BABFDAEI">
                           <p class="titleinexample">例17-4 report.xsd</p><pre class="pre codeblock"><code>&lt;schema targetNamespace =“http://www.example.com/Report”xmlns =“http://www.w3.org/2001/XMLSchema”xmlns：r =“http://www.example.com/Report “elementFormDefault =”qualified“&gt; &lt;annotation&gt; &lt;documentation xml：lang =”en“&gt; Example.com版权所有2000 Example.com的报告架构。版权所有。&lt;/ documentation&gt; &lt;/ annotation&gt; &lt;element name =“purchaseReport”&gt; &lt;complexType&gt; &lt;sequence&gt; &lt;element name =“regions”type =“r：RegionsType”&gt; &lt;keyref name =“dummy2”refer =“r：pNumKey “&gt; &lt;selector xpath =”r：zip / r：part“/&gt; &lt;field xpath =”@ number“/&gt; &lt;/ keyref&gt; &lt;/ element&gt; &lt;element name =”parts“type =”r：PartsType“/ &gt; &lt;/ sequence&gt; &lt;attribute name =“period”type =“duration”/&gt; &lt;attribute name =“periodEnding”type =“date”/&gt; &lt;/ complexType&gt; &lt;unique name =“dummy1”&gt; &lt;selector xpath =“ r：regions / r：zip“/&gt; &lt;field xpath =”@ code“/&gt; &lt;/ unique&gt; &lt;key name =”pNumKey“&gt; &lt;selector xpath =”r：parts / r：part“/&gt; &lt;field xpath =“@ number”/&gt; &lt;/ key&gt; &lt;/ element&gt; &lt;complexType name =“RegionsType”&gt; &lt;sequence&gt; &lt;element name =“zip”maxOccurs =“unbounded”&gt; &lt;complexType&gt; &lt;sequence&gt; &lt;element name =“ part“maxOccurs =”unbounded“&gt; &lt;complexType&gt; &lt;complexContent&gt; &lt;restriction base =”anyType“&gt; &lt;attribute name =”number“type =”r：SKU“/&gt; &lt;attribute name =”quantity“type =”positiveInteger“ /&gt; &lt;/ restriction&gt; &lt;/ complexContent&gt; &lt;/ complexType&gt; &lt;/ element&gt; &lt;/ sequence&gt; &lt;attribute name =“c ode“type =”positiveInteger“/&gt; &lt;/ complexType&gt; &lt;/ element&gt; &lt;/ sequence&gt; &lt;/ complexType&gt; &lt;simpleType name =”SKU“&gt; &lt;restriction base =”string“&gt; &lt;pattern value =”\ d {3 }  -  [AZ] {2}“/&gt; &lt;/ restriction&gt; &lt;/ simpleType&gt; &lt;complexType name =”PartsType“&gt; &lt;sequence&gt; &lt;element name =”part“maxOccurs =”unbounded“&gt; &lt;complexType&gt; &lt;simpleContent&gt; &lt; extension base =“string”&gt; &lt;attribute name =“number”type =“r：SKU”/&gt; &lt;/ extension&gt; &lt;/ simpleContent&gt; &lt;/ complexType&gt; &lt;/ element&gt; &lt;/ sequence&gt; &lt;/ complexType&gt; &lt;/ schema &gt;</code></pre></div>
                        <!-- class="example" -->
                     </div>
                  </div>
               </div><a id="ADXDK19266"></a><a id="ADXDK19265"></a><div class="props_rev_3"><a id="GUID-1794D1E8-94A0-41EB-B8A5-E7927FAC4BE9" name="GUID-1794D1E8-94A0-41EB-B8A5-E7927FAC4BE9"></a><h4 id="ADXDK-GUID-1794D1E8-94A0-41EB-B8A5-E7927FAC4BE9" class="sect4">XML模式和DTD之间的差异</h4>
                  <div>
                     <p>XML Schema语言包含DTD规范的大部分功能。XML模式与DTD具有类似的用途，但在指定文档约束时更灵活。</p>
                     <p><a href="using-XML-schema-processor-for-Java.html#GUID-1794D1E8-94A0-41EB-B8A5-E7927FAC4BE9__CIHDIBAB" title="此表比较了XML Schema语言和DTD的功能">表17-1</a>比较了两种验证机制之间的一些功能。
                     </p>
                     <div class="tblformal" id="GUID-1794D1E8-94A0-41EB-B8A5-E7927FAC4BE9__CIHDIBAB">
                        <p class="titleintable">表17-1 XML Schema和DTD之间的功能比较</p>
                        <table cellpadding="4" cellspacing="0" class="Formal" title="XML Schema与DTD的特性比较" width="100%" border="1" summary="This table compares the features of the XML Schema language and DTDs" frame="hsides" rules="rows">
                           <thead>
                              <tr align="left" valign="top">
                                 <th align="left" valign="bottom" width="37%" id="d63446e943">特征</th>
                                 <th align="left" valign="bottom" width="22%" id="d63446e946">XML Schema</th>
                                 <th align="left" valign="bottom" width="41%" id="d63446e949">DTD</th>
                              </tr>
                           </thead>
                           <tbody>
                              <tr align="left" valign="top">
                                 <td align="left" valign="top" width="37%" id="d63446e954" headers="d63446e943 ">
                                    <p>元素嵌套</p>
                                 </td>
                                 <td align="left" valign="top" width="22%" headers="d63446e954 d63446e946 ">
                                    <p>X</p>
                                 </td>
                                 <td align="left" valign="top" width="41%" headers="d63446e954 d63446e949 ">
                                    <p>X</p>
                                 </td>
                              </tr>
                              <tr align="left" valign="top">
                                 <td align="left" valign="top" width="37%" id="d63446e964" headers="d63446e943 ">
                                    <p>元素出现约束</p>
                                 </td>
                                 <td align="left" valign="top" width="22%" headers="d63446e964 d63446e946 ">
                                    <p>X</p>
                                 </td>
                                 <td align="left" valign="top" width="41%" headers="d63446e964 d63446e949 ">
                                    <p>X</p>
                                 </td>
                              </tr>
                              <tr align="left" valign="top">
                                 <td align="left" valign="top" width="37%" id="d63446e974" headers="d63446e943 ">
                                    <p>允许的属性</p>
                                 </td>
                                 <td align="left" valign="top" width="22%" headers="d63446e974 d63446e946 ">
                                    <p>X</p>
                                 </td>
                                 <td align="left" valign="top" width="41%" headers="d63446e974 d63446e949 ">
                                    <p>X</p>
                                 </td>
                              </tr>
                              <tr align="left" valign="top">
                                 <td align="left" valign="top" width="37%" id="d63446e984" headers="d63446e943 ">
                                    <p>属性类型和默认值</p>
                                 </td>
                                 <td align="left" valign="top" width="22%" headers="d63446e984 d63446e946 ">
                                    <p>X</p>
                                 </td>
                                 <td align="left" valign="top" width="41%" headers="d63446e984 d63446e949 ">
                                    <p>X</p>
                                 </td>
                              </tr>
                              <tr align="left" valign="top">
                                 <td align="left" valign="top" width="37%" id="d63446e994" headers="d63446e943 ">
                                    <p>用XML编写</p>
                                 </td>
                                 <td align="left" valign="top" width="22%" headers="d63446e994 d63446e946 ">
                                    <p>X</p>
                                 </td>
                                 <td align="left" valign="top" width="41%" headers="d63446e994 d63446e949 ">
                                    <p></p>
                                 </td>
                              </tr>
                              <tr align="left" valign="top">
                                 <td align="left" valign="top" width="37%" id="d63446e1003" headers="d63446e943 ">
                                    <p>命名空间支持</p>
                                 </td>
                                 <td align="left" valign="top" width="22%" headers="d63446e1003 d63446e946 ">
                                    <p>X</p>
                                 </td>
                                 <td align="left" valign="top" width="41%" headers="d63446e1003 d63446e949 ">
                                    <p></p>
                                 </td>
                              </tr>
                              <tr align="left" valign="top">
                                 <td align="left" valign="top" width="37%" id="d63446e1012" headers="d63446e943 ">
                                    <p>内置数据类型</p>
                                 </td>
                                 <td align="left" valign="top" width="22%" headers="d63446e1012 d63446e946 ">
                                    <p>X</p>
                                 </td>
                                 <td align="left" valign="top" width="41%" headers="d63446e1012 d63446e949 ">
                                    <p></p>
                                 </td>
                              </tr>
                              <tr align="left" valign="top">
                                 <td align="left" valign="top" width="37%" id="d63446e1021" headers="d63446e943 ">
                                    <p>用户定义的数据类型</p>
                                 </td>
                                 <td align="left" valign="top" width="22%" headers="d63446e1021 d63446e946 ">
                                    <p>X</p>
                                 </td>
                                 <td align="left" valign="top" width="41%" headers="d63446e1021 d63446e949 ">
                                    <p></p>
                                 </td>
                              </tr>
                              <tr align="left" valign="top">
                                 <td align="left" valign="top" width="37%" id="d63446e1030" headers="d63446e943 ">
                                    <p>包含/进口</p>
                                 </td>
                                 <td align="left" valign="top" width="22%" headers="d63446e1030 d63446e946 ">
                                    <p>X</p>
                                 </td>
                                 <td align="left" valign="top" width="41%" headers="d63446e1030 d63446e949 ">
                                    <p></p>
                                 </td>
                              </tr>
                              <tr align="left" valign="top">
                                 <td align="left" valign="top" width="37%" id="d63446e1039" headers="d63446e943 ">
                                    <p>细化（继承）</p>
                                 </td>
                                 <td align="left" valign="top" width="22%" headers="d63446e1039 d63446e946 ">
                                    <p>X</p>
                                 </td>
                                 <td align="left" valign="top" width="41%" headers="d63446e1039 d63446e949 ">
                                    <p></p>
                                 </td>
                              </tr>
                           </tbody>
                        </table>
                     </div>
                     <!-- class="inftblhruleinformal" -->
                     <p>这些原因可能是选择XML模式验证而不是DTD验证最有说服力的原因：</p>
                     <ul style="list-style-type:disc">
                        <li>
                           <p>XML Schema语言使您可以定义元素和属性<span class="italic">内容</span>的规则。您可以使用数据类型实现对内容的控制。使用XML Schema数据类型，您可以更轻松地执行以下操作：</p>
                           <ul style="list-style-type:disc">
                              <li>
                                 <p>声明哪些元素包含哪些类型的数据，例如，一个元素中的正整数和另一个元素中的年份</p>
                              </li>
                              <li>
                                 <p>处理从数据库获得的数据</p>
                              </li>
                              <li>
                                 <p>定义数据限制，例如，10到20之间的数字</p>
                              </li>
                              <li>
                                 <p>定义数据格式，例如MM-DD-YYYY形式的日期</p>
                              </li>
                              <li>
                                 <p>在不同数据类型之间转换数据，例如，字符串到日期</p>
                              </li>
                           </ul>
                        </li>
                        <li>
                           <p>与DTD语法不同，用XML Schema语言编写的文档本身是用XML编写的。因此，您可以执行以下操作：</p>
                           <ul style="list-style-type:disc">
                              <li>
                                 <p>使用XML解析器来解析XML模式</p>
                              </li>
                              <li>
                                 <p>使用XML文档对象模型（DOM）处理XML模式</p>
                              </li>
                              <li>
                                 <p>使用可扩展样式表语言转换（XSLT）转换XML文档</p>
                              </li>
                              <li>
                                 <p>在其他XML模式中重用XML模式</p>
                              </li>
                              <li>
                                 <p>通过添加元素和属性来扩展XML架构</p>
                              </li>
                              <li>
                                 <p>引用同一文档中的多个XML模式</p>
                              </li>
                           </ul>
                        </li>
                     </ul>
                  </div>
               </div>
            </div><a id="ADXDK19267"></a><div class="props_rev_3"><a id="GUID-D9E0C12D-122D-4183-A4AB-8BE7F476ABF8" name="GUID-D9E0C12D-122D-4183-A4AB-8BE7F476ABF8"></a><h3 id="ADXDK-GUID-D9E0C12D-122D-4183-A4AB-8BE7F476ABF8" class="sect3">使用XML架构处理器：概述</h3>
               <div>
                  <p>Oracle XML Schema处理器是一个基于SAX的XML模式验证器，可用于根据XML模式验证实例文档。处理器支持语言示例（LAX）和严格验证。</p>
                  <p>您可以通过以下方式使用处理器：</p>
                  <ul style="list-style-type:disc">
                     <li>
                        <p>在XML解析器中启用它</p>
                     </li>
                     <li>
                        <p>与DOM树一起使用它来验证整个或部分XML文档</p>
                     </li>
                     <li>
                        <p>将它用作处理管道中的组件（如内容处理程序）</p>
                     </li>
                  </ul>
                  <p>您可以根据需要以不同方式配置架构处理器。例如，您可以：</p>
                  <ul style="list-style-type:disc">
                     <li>
                        <p>使用固定的XML架构或基于实例文档中的<code class="codeph">schemaLocation</code>属性自动构建架构。
                        </p>
                     </li>
                     <li>
                        <p>设置<code class="codeph">XMLError</code>和<code class="codeph">entityResolver</code>以更好地控制验证过程。
                        </p>
                     </li>
                     <li>
                        <p>确定要验证的实例文档的数量。您可以使用<a href="XML-parsing-for-Java.html#GUID-2DA498AD-B22B-4C66-AE90-5EB37EB105E7__G1043218" title="此表显示可在XDK解析器中使用的setValidationMode（）标志。模式名称，Java中的模式值和描述是列。">表12-1中</a>指定的任何验证模式。您还可以将一种元素指定为验证的根。
                        </p>
                     </li>
                  </ul>
               </div><a id="ADXDK19269"></a><a id="ADXDK19270"></a><a id="ADXDK19268"></a><div class="props_rev_3"><a id="GUID-66EB1648-53B0-4026-8139-EC9EED8A16E6" name="GUID-66EB1648-53B0-4026-8139-EC9EED8A16E6"></a><h4 id="ADXDK-GUID-66EB1648-53B0-4026-8139-EC9EED8A16E6" class="sect4">使用Java Schema Processor for Java：基本过程</h4>
                  <div>
                     <p>描述了对处理XML模式的应用程序很重要的XDK包。</p>
                     <p>这些是处理XML模式的应用程序的重要包：</p>
                     <ul style="list-style-type:disc">
                        <li>
                           <p><code class="codeph">oracle.xml.parser.v2</code> ，提供用于XML解析的API</p>
                        </li>
                        <li>
                           <p><code class="codeph">oracle.xml.parser.schema</code> ，提供用于XML Schema处理的API</p>
                        </li>
                     </ul>
                     <p><a href="using-XML-schema-processor-for-Java.html#GUID-66EB1648-53B0-4026-8139-EC9EED8A16E6__CHDHIJJE" title="该表描述了oracle.xml.parser.schema类。">表17-2</a>中描述了<code class="codeph">oracle.xml.parser.schema</code>包中最重要的类。这些构成了大多数XML模式应用程序的核心。
                     </p>
                     <div class="tblformalwide" id="GUID-66EB1648-53B0-4026-8139-EC9EED8A16E6__CHDHIJJE">
                        <p class="titleintable">表17-2 oracle.xml.parser.schema类</p>
                        <table cellpadding="4" cellspacing="0" class="FormalWide" title="oracle.xml.parser.schema类" width="100%" border="1" summary="This table describes the oracle.xml.parser.schema classes." frame="hsides" rules="rows">
                           <thead>
                              <tr align="left" valign="top">
                                 <th align="left" valign="bottom" width="22%" id="d63446e1325">类/接口</th>
                                 <th align="left" valign="bottom" width="29%" id="d63446e1328">描述</th>
                                 <th align="left" valign="bottom" width="49%" id="d63446e1331">方法</th>
                              </tr>
                           </thead>
                           <tbody>
                              <tr align="left" valign="top">
                                 <td align="left" valign="top" width="22%" id="d63446e1336" headers="d63446e1325 ">
                                    <p><code class="codeph">XMLSchema</code>类</p>
                                 </td>
                                 <td align="left" valign="top" width="29%" headers="d63446e1336 d63446e1328 ">
                                    <p>表示XML Schema组件模型。<code class="codeph">XMLSchema</code>对象是属于不同目标命名空间的一组<code class="codeph">XMLSchemaNodes</code> 。<code class="codeph">XSDValidator</code>类使用<code class="codeph">XMLSchema</code>进行模式验证或元数据。
                                    </p>
                                 </td>
                                 <td align="left" valign="top" width="49%" headers="d63446e1336 d63446e1331 ">
                                    <p>主要方法是：</p>
                                    <ul style="list-style-type:disc">
                                       <li>
                                          <p><code class="codeph">get</code> <code class="codeph">getElement()</code>和<code class="codeph">getSchemaTargetNS()</code>获取有关XML模式的信息</p>
                                       </li>
                                       <li>
                                          <p><code class="codeph">printSchema()</code>输出有关XML模式的信息</p>
                                       </li>
                                    </ul>
                                 </td>
                              </tr>
                              <tr align="left" valign="top">
                                 <td align="left" valign="top" width="22%" id="d63446e1377" headers="d63446e1325 ">
                                    <p><code class="codeph">XMLSchemaNode</code>类</p>
                                 </td>
                                 <td align="left" valign="top" width="29%" headers="d63446e1377 d63446e1328 ">
                                    <p>表示目标命名空间中的模式组件，包括类型定义，元素和属性说明以及组和属性组定义。</p>
                                 </td>
                                 <td align="left" valign="top" width="49%" headers="d63446e1377 d63446e1331 ">
                                    <p>主要方法是<code class="codeph">get</code>方法，如<code class="codeph">getElementSet()</code>和<code class="codeph">getAttributeDeclarations()</code>获取XML模式的组件。
                                    </p>
                                 </td>
                              </tr>
                              <tr align="left" valign="top">
                                 <td align="left" valign="top" width="22%" id="d63446e1398" headers="d63446e1325 ">
                                    <p><code class="codeph">XSDBuilder</code>类</p>
                                 </td>
                                 <td align="left" valign="top" width="29%" headers="d63446e1398 d63446e1328 ">
                                    <p>从XML模式文档构建<code class="codeph">XMLSchema</code>对象。<code class="codeph">XMLSchema</code>对象是与顶级模式声明和定义相对应的一组对象（信息集项）。模式文档经过XML解析并转换为DOM树。
                                    </p>
                                 </td>
                                 <td align="left" valign="top" width="49%" headers="d63446e1398 d63446e1331 ">
                                    <p>主要方法是：</p>
                                    <ul style="list-style-type:disc">
                                       <li>
                                          <p><code class="codeph">build()</code>创建一个<code class="codeph">XMLSchema</code>对象。
                                          </p>
                                       </li>
                                       <li>
                                          <p><code class="codeph">getObject()</code>返回<code class="codeph">XMLSchema</code>对象。
                                          </p>
                                       </li>
                                       <li>
                                          <p><code class="codeph">setEntityResolver()</code>设置<code class="codeph">EntityResolver</code>以解析导入和包含。
                                          </p>
                                       </li>
                                    </ul>
                                 </td>
                              </tr>
                              <tr align="left" valign="top">
                                 <td align="left" valign="top" width="22%" id="d63446e1441" headers="d63446e1325 ">
                                    <p><code class="codeph">XSDValidator</code>类</p>
                                 </td>
                                 <td align="left" valign="top" width="29%" headers="d63446e1441 d63446e1328 ">
                                    <p>根据XML模式验证实例XML文档。注册时， <code class="codeph">XSDValidator</code>对象作为<code class="codeph">XMLParser</code>和<code class="codeph">XMLDocument</code>事件处理程序之间的管道节点插入。
                                    </p>
                                 </td>
                                 <td align="left" valign="top" width="49%" headers="d63446e1441 d63446e1331 ">
                                    <p>主要方法是：</p>
                                    <ul style="list-style-type:disc">
                                       <li>
                                          <p><code class="codeph">get</code> <code class="codeph">getCurrentMode()</code>和<code class="codeph">getElementDeclaration()</code></p>
                                       </li>
                                       <li>
                                          <p><code class="codeph">set</code> <code class="codeph">setXMLProperty()</code>和<code class="codeph">setDocumentLocator()</code></p>
                                       </li>
                                       <li>
                                          <p><code class="codeph">startDocument()</code>接收文档开头的通知。
                                          </p>
                                       </li>
                                       <li>
                                          <p><code class="codeph">startElement()</code>接收元素开头的通知。
                                          </p>
                                       </li>
                                    </ul>
                                 </td>
                              </tr>
                           </tbody>
                        </table>
                     </div>
                     <!-- class="inftblhruleinformal" -->
                     <p><a href="using-XML-schema-processor-for-Java.html#GUID-66EB1648-53B0-4026-8139-EC9EED8A16E6__I1012436">图17-1</a>描述了使用XML Schema processor for Java验证实例文档的基本过程。
                     </p>
                     <div class="figure" id="GUID-66EB1648-53B0-4026-8139-EC9EED8A16E6__I1012436">
                        <p class="titleinfigure">图17-1 Java的XML模式处理器</p><img src="img/adxdk105.gif" width="419" alt="下面是图17-1的描述" title="下面是图17-1的描述" longdesc="img_text/adxdk105.html"><br><a href="img_text/adxdk105.html">“图17-1 Java的XML模式处理器”的描述</a></div>
                     <!-- class="figure" -->
                     <p>XML Schema处理器执行以下主要任务：</p>
                     <ol>
                        <li>
                           <p>构建器（ <code class="codeph">XSDBuilder</code>对象）从输入XML架构文档中组装XML架构。虽然实例文档和模式不需要特定地作为操作系统上的文件存在，但它们通常被称为文件。它们可以作为字节流，数据库记录中的字段或XML Infoset“信息项”的集合存在。</p>
                           <p>此任务涉及将架构文档解析为对象。构建器显式或隐式创建架构对象：</p>
                           <ul style="list-style-type:disc">
                              <li>
                                 <p>在显式模式下，在调用处理器时传入XML模式。<a href="using-XML-schema-processor-for-Java.html#GUID-EAAAB139-E5FE-434E-A310-2E13099B1FF8" title="$ ORACLE_HOME / xdk / demo / java / schema / XSDSetSchema.java显示了如何显式验证XML模式。验证模式是显式的，因为您使用XSDBuilder类来指定用于验证的模式：未在实例文档中指定模式，如在隐式验证中。">针对外部引用的XML模式进行验证</a>说明了如何在显式模式下构建模式对象。
                                 </p>
                              </li>
                              <li>
                                 <p>在隐式模式下，在调用处理器时不传递XML模式，因为模式在实例文档内部引用。<a href="using-XML-schema-processor-for-Java.html#GUID-5B182AA2-84E3-416A-837A-6563B2F948D5" title="$ ORACLE_HOME / xdk / demo / java / schema / XSDSample.java显示了如何针对隐式XML模式进行验证。验证模式是隐式的，因为XML模式在实例文档本身中被引用。">针对内部引用的XML模式进行验证</a>说明了如何以隐式模式创建模式对象。
                                 </p>
                              </li>
                           </ul>
                        </li>
                        <li>
                           <p>XML模式验证程序使用模式对象来验证实例文档。此任务包含以下步骤：</p>
                           <ol type="a">
                              <li>
                                 <p>Simple API for XML（SAX）解析器将实例文档解析为SAX事件，并将其传递给验证器。</p>
                              </li>
                              <li>
                                 <p>验证器接收SAX事件作为输入，并根据模式对象验证它们，如果找到无效的XML组件则发送错误消息。</p>
                                 <p><a href="XML-parsing-for-Java.html#GUID-2DA498AD-B22B-4C66-AE90-5EB37EB105E7" title="要解析XML文档，请调用parse（）方法。通常，您将调用与parse（）方法关联的初始化和终止方法。">XML Parser</a>中的验证描述了验证实例文档时可以使用的验证模式。如果未使用<code class="codeph">XSDBuilder</code>类显式设置验证模式，则实例文档必须具有指向模式文件的正确<code class="codeph">xsi:schemaLocation</code>属性。否则，程序不会执行验证。如果处理器遇到错误，则会生成错误消息。
                                 </p>
                              </li>
                              <li>
                                 <p>验证器将输入SAX事件，默认值或后架构验证信息发送到DOM构建器或应用程序。</p>
                              </li>
                           </ol>
                        </li>
                     </ol>
                     <div class="infoboxnotealso" id="GUID-66EB1648-53B0-4026-8139-EC9EED8A16E6__GUID-79CE7578-8DAB-49AF-88FC-70B09FD34EF9">
                        <p class="notep1">也可以看看：</p>
                        <ul style="list-style-type:disc">
                           <li>
                              <p><a href="../jaxml/index.html" target="_blank"><span><cite>Oracle Database XML Java API参考</cite></span></a> ，了解<code class="codeph">XSDBuilder</code> ， <code class="codeph">DOMParser</code>和<code class="codeph">SAXParser</code>类</p>
                           </li>
                           <li>
                              <p><a href="using-XML-schema-processor-for-Java.html#GUID-F41C7DA2-A3DF-463B-A08C-24E8F0621450" title="这里的主题介绍了如何使用Java的可扩展标记语言（XML）模式处理器。">使用XML Schema Processor for Java</a>了解XDK SAX和DOM解析器</p>
                           </li>
                        </ul>
                     </div>
                  </div>
               </div><a id="ADXDK19272"></a><a id="ADXDK19271"></a><div class="props_rev_3"><a id="GUID-1794B57C-BD9A-4322-B136-B07B950EC479" name="GUID-1794B57C-BD9A-4322-B136-B07B950EC479"></a><h4 id="ADXDK-GUID-1794B57C-BD9A-4322-B136-B07B950EC479" class="sect4">运行XML架构处理器演示程序</h4>
                  <div>
                     <p>用于Java的XML Schema处理器的演示程序包含在<code class="codeph">$ORACLE_HOME/xdk/demo/java/schema</code> 。
                     </p>
                     <div class="section">
                        <p><a href="using-XML-schema-processor-for-Java.html#GUID-1794B57C-BD9A-4322-B136-B07B950EC479__CIHIEEDI" title="此表描述了可用于测试XML架构处理器的XML文件和程序。文件和描述是列。">表17-3</a>介绍了可用于测试XML架构处理器的XML文件和程序。
                        </p>
                        <div class="tblformalwide" id="GUID-1794B57C-BD9A-4322-B136-B07B950EC479__CIHIEEDI">
                           <p class="titleintable">表17-3 XML架构示例文件</p>
                           <table cellpadding="4" cellspacing="0" class="FormalWide" title="XML模式示例文件" width="100%" border="1" summary="This table describes the XML files and programs that you can use to test the XML Schema processor. File and Description are the Columns." frame="hsides" rules="rows">
                              <thead>
                                 <tr align="left" valign="top">
                                    <th align="left" valign="bottom" width="19%" id="d63446e1704">文件</th>
                                    <th align="left" valign="bottom" width="81%" id="d63446e1707">描述</th>
                                 </tr>
                              </thead>
                              <tbody>
                                 <tr align="left" valign="top">
                                    <td align="left" valign="top" width="19%" id="d63446e1712" headers="d63446e1704 "><pre class="oac_no_warn" dir="ltr">cat.xsd</pre></td>
                                    <td align="left" valign="top" width="81%" headers="d63446e1712 d63446e1707 ">
                                       <p><code class="codeph">XSDSetSchema.java</code>程序用于验证<code class="codeph">catalogue.xml</code>示例XML架构。<code class="codeph">cat.xsd</code>模式指定书籍目录的结构。
                                       </p>
                                    </td>
                                 </tr>
                                 <tr align="left" valign="top">
                                    <td align="left" valign="top" width="19%" id="d63446e1728" headers="d63446e1704 "><pre class="oac_no_warn" dir="ltr">catalogue.xml</pre></td>
                                    <td align="left" valign="top" width="81%" headers="d63446e1728 d63446e1707 ">
                                       <p><code class="codeph">XSDSetSchema.java</code>程序用于针对<code class="codeph">cat.xsd</code>架构验证的示例实例文档。
                                       </p>
                                    </td>
                                 </tr>
                                 <tr align="left" valign="top">
                                    <td align="left" valign="top" width="19%" id="d63446e1741" headers="d63446e1704 "><pre class="oac_no_warn" dir="ltr">catalogue_e.xml</pre></td>
                                    <td align="left" valign="top" width="81%" headers="d63446e1741 d63446e1707 ">
                                       <p><code class="codeph">XSDSample.java</code>程序使用的示例实例文档。当程序尝试针对<code class="codeph">cat.xsd</code>架构验证此文档时，它会生成架构错误。
                                       </p>
                                    </td>
                                 </tr>
                                 <tr align="left" valign="top">
                                    <td align="left" valign="top" width="19%" id="d63446e1754" headers="d63446e1704 "><pre class="oac_no_warn" dir="ltr">DTD2Schema.java</pre></td>
                                    <td align="left" valign="top" width="81%" headers="d63446e1754 d63446e1707 ">
                                       <p>此示例程序将DTD（第一个参数）转换为XML架构，并使用它来验证XML文件（第二个参数）。</p>
                                    </td>
                                 </tr>
                                 <tr align="left" valign="top">
                                    <td align="left" valign="top" width="19%" id="d63446e1761" headers="d63446e1704 "><pre class="oac_no_warn" dir="ltr">embeded_xsql.xsd</pre></td>
                                    <td align="left" valign="top" width="81%" headers="d63446e1761 d63446e1707 ">
                                       <p><code class="codeph">XSDLax.java.</code>使用的XML模式<code class="codeph">XSDLax.java.</code> 该模式定义了XSQL页面的结构。
                                       </p>
                                    </td>
                                 </tr>
                                 <tr align="left" valign="top">
                                    <td align="left" valign="top" width="19%" id="d63446e1771" headers="d63446e1704 "><pre class="oac_no_warn" dir="ltr">embeded_xsql.xml</pre></td>
                                    <td align="left" valign="top" width="81%" headers="d63446e1771 d63446e1707 ">
                                       <p><code class="codeph">XSDLax.java</code>使用的实例文档。
                                       </p>
                                    </td>
                                 </tr>
                                 <tr align="left" valign="top">
                                    <td align="left" valign="top" width="19%" id="d63446e1781" headers="d63446e1704 "><pre class="oac_no_warn" dir="ltr">juicer1.xml</pre></td>
                                    <td align="left" valign="top" width="81%" headers="d63446e1781 d63446e1707 ">
                                       <p>用于<code class="codeph">xsdproperty.java</code>示例XML文档。定义此文档的XML模式是<code class="codeph">juicer1.xsd</code> 。
                                       </p>
                                    </td>
                                 </tr>
                                 <tr align="left" valign="top">
                                    <td align="left" valign="top" width="19%" id="d63446e1794" headers="d63446e1704 "><pre class="oac_no_warn" dir="ltr">juicer1.xsd</pre></td>
                                    <td align="left" valign="top" width="81%" headers="d63446e1794 d63446e1707 ">
                                       <p>用于<code class="codeph">xsdproperty.java</code>示例XML架构。此XML架构定义了<code class="codeph">juicer1.xml</code> 。
                                       </p>
                                    </td>
                                 </tr>
                                 <tr align="left" valign="top">
                                    <td align="left" valign="top" width="19%" id="d63446e1807" headers="d63446e1704 "><pre class="oac_no_warn" dir="ltr">juicer2.xml</pre></td>
                                    <td align="left" valign="top" width="81%" headers="d63446e1807 d63446e1707 ">
                                       <p>用于<code class="codeph">xsdproperty.java</code>示例XML文档。定义此文档的XML模式是<code class="codeph">juicer2.xsd</code> 。
                                       </p>
                                    </td>
                                 </tr>
                                 <tr align="left" valign="top">
                                    <td align="left" valign="top" width="19%" id="d63446e1820" headers="d63446e1704 "><pre class="oac_no_warn" dir="ltr">juicer2.xsd</pre></td>
                                    <td align="left" valign="top" width="81%" headers="d63446e1820 d63446e1707 ">
                                       <p>用于<code class="codeph">xsdproperty.java</code>示例XML文档。此XML架构定义了<code class="codeph">juicer2.xml</code> 。
                                       </p>
                                    </td>
                                 </tr>
                                 <tr align="left" valign="top">
                                    <td align="left" valign="top" width="19%" id="d63446e1833" headers="d63446e1704 "><pre class="oac_no_warn" dir="ltr">report.xml将</pre></td>
                                    <td align="left" valign="top" width="81%" headers="d63446e1833 d63446e1707 ">
                                       <p><code class="codeph">XSDSetSchema.java</code>用于根据XML模式<code class="codeph">report.xsd</code>验证的示例XML文件。
                                       </p>
                                    </td>
                                 </tr>
                                 <tr align="left" valign="top">
                                    <td align="left" valign="top" width="19%" id="d63446e1847" headers="d63446e1704 "><pre class="oac_no_warn" dir="ltr">report.xsd</pre></td>
                                    <td align="left" valign="top" width="81%" headers="d63446e1847 d63446e1707 ">
                                       <p><code class="codeph">XSDSetSchema.java</code>程序使用的示例XML架构，用于验证<code class="codeph">report.xml</code>的内容。<code class="codeph">report.xsd</code>模式指定采购订单的结构。
                                       </p>
                                    </td>
                                 </tr>
                                 <tr align="left" valign="top">
                                    <td align="left" valign="top" width="19%" id="d63446e1863" headers="d63446e1704 "><pre class="oac_no_warn" dir="ltr">report_e.xml</pre></td>
                                    <td align="left" valign="top" width="81%" headers="d63446e1863 d63446e1707 ">
                                       <p>当程序使用<code class="codeph">XSDSample.java</code>验证此示例XML文件时，它会生成XML Schema错误。
                                       </p>
                                    </td>
                                 </tr>
                                 <tr align="left" valign="top">
                                    <td align="left" valign="top" width="19%" id="d63446e1873" headers="d63446e1704 "><pre class="oac_no_warn" dir="ltr">xsddom.java</pre></td>
                                    <td align="left" valign="top" width="81%" headers="d63446e1873 d63446e1707 ">
                                       <p>此程序显示如何通过获取文档的DOM表示并使用<code class="codeph">XSDValidator</code>对象来验证它来验证实例文档。
                                       </p>
                                    </td>
                                 </tr>
                                 <tr align="left" valign="top">
                                    <td align="left" valign="top" width="19%" id="d63446e1883" headers="d63446e1704 "><pre class="oac_no_warn" dir="ltr">xsdent.java</pre></td>
                                    <td align="left" valign="top" width="81%" headers="d63446e1883 d63446e1707 ">
                                       <p>此程序通过将<code class="codeph">SchemaLocation</code>属性中引用的模式重定向到本地版本来验证XML文档。
                                       </p>
                                    </td>
                                 </tr>
                                 <tr align="left" valign="top">
                                    <td align="left" valign="top" width="19%" id="d63446e1893" headers="d63446e1704 "><pre class="oac_no_warn" dir="ltr">xsdent.xml</pre></td>
                                    <td align="left" valign="top" width="81%" headers="d63446e1893 d63446e1707 ">
                                       <p>该XML文档描述了一本书。该文件用作<code class="codeph">xsdent.java</code>的输入。
                                       </p>
                                    </td>
                                 </tr>
                                 <tr align="left" valign="top">
                                    <td align="left" valign="top" width="19%" id="d63446e1903" headers="d63446e1704 "><pre class="oac_no_warn" dir="ltr">xsdent.xsd</pre></td>
                                    <td align="left" valign="top" width="81%" headers="d63446e1903 d63446e1707 ">
                                       <p>此XML架构文档定义<code class="codeph">xsdent.xml</code>的规则。架构文档包含设置为<code class="codeph">xsdent-1.xsd</code>的<code class="codeph">schemaLocation</code>属性。
                                       </p>
                                    </td>
                                 </tr>
                                 <tr align="left" valign="top">
                                    <td align="left" valign="top" width="19%" id="d63446e1919" headers="d63446e1704 "><pre class="oac_no_warn" dir="ltr">xsdent-1.xsd</pre></td>
                                    <td align="left" valign="top" width="81%" headers="d63446e1919 d63446e1707 ">
                                       <p><code class="codeph">xsdent.xsd</code> <code class="codeph">schemaLocation</code>属性引用的XML模式文档。
                                       </p>
                                    </td>
                                 </tr>
                                 <tr align="left" valign="top">
                                    <td align="left" valign="top" width="19%" id="d63446e1932" headers="d63446e1704 "><pre class="oac_no_warn" dir="ltr">xsdproperty.java</pre></td>
                                    <td align="left" valign="top" width="81%" headers="d63446e1932 d63446e1707 ">
                                       <p>此演示演示如何配置XML架构处理器以基于复杂类型或元素声明验证XML文档。</p>
                                    </td>
                                 </tr>
                                 <tr align="left" valign="top">
                                    <td align="left" valign="top" width="19%" id="d63446e1939" headers="d63446e1704 "><pre class="oac_no_warn" dir="ltr">xsdsax.java</pre></td>
                                    <td align="left" valign="top" width="81%" headers="d63446e1939 d63446e1707 ">
                                       <p>此演示演示如何验证作为SAX流接收的XML文档。</p>
                                    </td>
                                 </tr>
                                 <tr align="left" valign="top">
                                    <td align="left" valign="top" width="19%" id="d63446e1946" headers="d63446e1704 "><pre class="oac_no_warn" dir="ltr">XSDLax.java</pre></td>
                                    <td align="left" valign="top" width="81%" headers="d63446e1946 d63446e1707 ">
                                       <p>此演示与<code class="codeph">XSDSetSchema.java</code>相同，但为LAX验证设置<code class="codeph">SCHEMA_LAX_VALIDATION</code>标志。
                                       </p>
                                    </td>
                                 </tr>
                                 <tr align="left" valign="top">
                                    <td align="left" valign="top" width="19%" id="d63446e1959" headers="d63446e1704 "><pre class="oac_no_warn" dir="ltr">XSDSample.java</pre></td>
                                    <td align="left" valign="top" width="81%" headers="d63446e1959 d63446e1707 ">
                                       <p>此程序是一个示例驱动程序，可用于处理XML实例文档。</p>
                                    </td>
                                 </tr>
                                 <tr align="left" valign="top">
                                    <td align="left" valign="top" width="19%" id="d63446e1967" headers="d63446e1704 "><pre class="oac_no_warn" dir="ltr">XSDSetSchema.java</pre></td>
                                    <td align="left" valign="top" width="81%" headers="d63446e1967 d63446e1707 ">
                                       <p>此程序是通过覆盖<code class="codeph">schemaLocation</code>来处理XML实例文档的示例驱动程序。该程序使用<code class="codeph">cat.xsd</code>的XML Schema规范来验证<code class="codeph">catalogue.xml</code>的内容。
                                       </p>
                                    </td>
                                 </tr>
                              </tbody>
                           </table>
                        </div>
                        <!-- class="inftblhruleinformal" -->
                        <p>有关如何编译和运行示例程序的文档位于同一目录的<code class="codeph">README</code>中。基本步骤是：</p>
                     </div>
                     <!-- class="section" -->
                     <ol>
                        <li class="stepexpand"><span>转到<code class="codeph">$ORACLE_HOME/xdk/demo/java/schema</code>目录（UNIX）或<code class="codeph">%ORACLE_HOME%\xdk\demo\java\schema</code>目录（Windows）。</span></li>
                        <li class="stepexpand"><span>在命令行运行<code class="codeph">make</code> （UNIX）或<code class="codeph">Make.bat</code> （Windows）。</span></li>
                        <li class="stepexpand"><span>将<code class="codeph">xmlparserv2.jar</code> ， <code class="codeph">xschema.jar</code>和当前目录添加到<code class="codeph">CLASSPATH</code> 。这些JAR文件位于<code class="codeph">$ORACLE_HOME/lib</code> （UNIX）和<code class="codeph">%ORACLE_HOME%\lib</code> （Windows）中。例如，您可以在UNIX上使用<code class="codeph">tcsh</code> shell设置<code class="codeph">CLASSPATH</code> ：</span><div><pre class="oac_no_warn" dir="ltr">setenv CLASSPATH“$ CLASSPATH”：$ ORACLE_HOME / lib / xmlparserv2.jar：$ ORACLE_HOME / lib / schema.jar：。</pre><div class="infoboxnote" id="GUID-1794B57C-BD9A-4322-B136-B07B950EC479__GUID-FF593407-5EB2-4FAC-93BA-E6344D752FF5">
                                 <p class="notep1">注意：</p>
                                 <p>XML Schema处理器需要JDK 1.2或更高版本，并且可以在任何支持Java 1.2的操作系统上使用。</p>
                              </div>
                           </div>
                        </li>
                        <li class="stepexpand"><span>使用目录中包含的XML文件运行示例程序：</span><div>
                              <ul style="list-style-type:disc">
                                 <li>
                                    <p>这些示例使用<code class="codeph">report.xsd</code>验证的内容<code class="codeph">report.xml</code> ：</p><pre class="oac_no_warn" dir="ltr">java XSDSample report.xml java XSDSetSchema report.xsd report.xml</pre></li>
                                 <li>
                                    <p>此示例在Lax模式下验证实例文档：</p><pre class="oac_no_warn" dir="ltr">java XSDLax embeded_xsql.xsd embeded_xsql.xml</pre></li>
                                 <li>
                                    <p>这些示例使用<code class="codeph">cat.xsd</code>来验证<code class="codeph">catalogue.xml</code>的内容：</p><pre class="oac_no_warn" dir="ltr">java XSDSample catalogue.xml java XSDSetSchema cat.xsd catalogue.xml</pre></li>
                                 <li>
                                    <p>这些示例生成错误消息：</p><pre class="oac_no_warn" dir="ltr">java XSDSample catalogue_e.xml java XSDSample report_e.xml</pre></li>
                                 <li>
                                    <p>此示例使用<code class="codeph">xsdent.xsd</code>的<code class="codeph">schemaLocation</code>属性将XML架构重定向到<code class="codeph">xsdent-1.xsd</code>以进行验证：</p><pre class="oac_no_warn" dir="ltr">java xsdent xsdent.xml xsdent.xsd</pre></li>
                                 <li>
                                    <p>本实施例中从生成SAX流<code class="codeph">report.xml</code>和验证它针对所定义的XML模式<code class="codeph">report.xsd</code> ：</p><pre class="oac_no_warn" dir="ltr">java xsdsax report.xsd report.xml</pre></li>
                                 <li>
                                    <p>本例创建的DOM表示<code class="codeph">report.xml</code>和验证它针对所定义的XML模式<code class="codeph">report.xsd</code> ：</p><pre class="oac_no_warn" dir="ltr">java xsddom report.xsd report.xml</pre></li>
                                 <li>
                                    <p>这些示例配置从元素声明或复杂类型定义开始的验证：</p><pre class="oac_no_warn" dir="ltr">java xsdproperty juicer1.xml juicer1.xsd http://www.juicers.org \ juicersType false&gt; juicersType.out java xsdproperty juicer2.xml juicer2.xsd http://www.juicers.org \ Juicers true&gt; juicers_e.out</pre></li>
                                 <li>
                                    <p>此示例将DTD（ <code class="codeph">dtd2schema.dtd</code> ）转换为XML架构，并使用它来验证实例文档（ <code class="codeph">dtd2schema.xml</code> ）：</p><pre class="oac_no_warn" dir="ltr">java DTD2Schema dtd2schema.dtd dtd2schema.xml</pre></li>
                              </ul>
                           </div>
                        </li>
                     </ol>
                  </div>
               </div><a id="ADXDK19273"></a><div class="props_rev_3"><a id="GUID-47B783B4-29F5-4AE7-AD61-96207DC548D0" name="GUID-47B783B4-29F5-4AE7-AD61-96207DC548D0"></a><h4 id="ADXDK-GUID-47B783B4-29F5-4AE7-AD61-96207DC548D0" class="sect4">使用XML Schema Processor命令行实用程序</h4>
                  <div>
                     <p>您可以使用XML解析器命令行实用程序（ <code class="codeph">oraxml</code> ）来针对XML模式和DTD验证实例文档。
                     </p>
                     <div class="section">
                        <div class="infoboxnotealso" id="GUID-47B783B4-29F5-4AE7-AD61-96207DC548D0__GUID-C586B6FC-60E7-4CCF-AC3B-E18751B87AAF">
                           <p class="notep1">也可以看看：</p>
                           <p><a href="XML-parsing-for-Java.html#GUID-204C527C-DED2-4FBA-861E-3378370529ED" title="oraxml实用程序位于$ ORACLE_HOME / bin（UNIX）或％ORACLE_HOME％\ bin（Windows）中，是一个解析XML文档的命令行界面。它检查结构良好和有效性。">使用Java XML Parser命令行实用程序（oraxml）</a>获取有关如何运行<code class="codeph">oraxml</code> 。
                           </p>
                        </div>
                     </div>
                     <!-- class="section" -->
                  </div><a id="ADXDK19275"></a><a id="ADXDK19274"></a><div class="props_rev_3"><a id="GUID-223D5EB3-013F-4DA7-97A3-090847AA2C2C" name="GUID-223D5EB3-013F-4DA7-97A3-090847AA2C2C"></a><h5 id="ADXDK-GUID-223D5EB3-013F-4DA7-97A3-090847AA2C2C" class="sect5">使用oraxml验证模式</h5>
                     <div>
                        <p>示例显示了如何通过在命令行上调用<code class="codeph">oraxml</code>来针对XML模式<code class="codeph">report.xsd</code>验证文档<code class="codeph">report.xml</code> 。
                        </p>
                        <div class="example" id="GUID-223D5EB3-013F-4DA7-97A3-090847AA2C2C__CIHGACIE">
                           <p class="titleinexample">示例17-5使用oraxml验证模式</p>
                           <p>在<code class="codeph">$ORACLE_HOME/xdk/demo/java/schema</code>目录中调用此命令：</p><pre class="pre codeblock"><code>oraxml -schema -enc report.xml</code></pre><p>预期的产出是：</p><pre class="pre codeblock"><code>输入文件的编码：UTF-8使用Schema验证模式解析输入XML文件时没有错误。</code></pre></div>
                        <!-- class="example" -->
                     </div>
                  </div><a id="ADXDK19277"></a><a id="ADXDK19276"></a><div class="props_rev_3"><a id="GUID-0B1E253D-80F0-4B66-A9B5-F86AAFF2BBEA" name="GUID-0B1E253D-80F0-4B66-A9B5-F86AAFF2BBEA"></a><h5 id="ADXDK-GUID-0B1E253D-80F0-4B66-A9B5-F86AAFF2BBEA" class="sect5">使用oraxml验证DTD</h5>
                     <div>
                        <p>示例显示如何通过在命令行上调用<code class="codeph">oraxml</code>来针对DTD <code class="codeph">family.dtd</code>验证文档<code class="codeph">family.xml</code> 。
                        </p>
                        <div class="example" id="GUID-0B1E253D-80F0-4B66-A9B5-F86AAFF2BBEA__CIHJDDBC">
                           <p class="titleinexample">示例17-6使用oraxml验证DTD</p>
                           <p>在<code class="codeph">$ORACLE_HOME/xdk/demo/java/parser/common</code>目录中调用此命令：</p><pre class="pre codeblock"><code>oraxml -dtd -enc family.xml</code></pre><p>预期的产出是：</p><pre class="pre codeblock"><code>输入文件的编码：UTF-8使用DTD验证模式解析输入XML文件时没有错误。</code></pre></div>
                        <!-- class="example" -->
                     </div>
                  </div>
               </div>
            </div><a id="ADXDK995"></a><a id="ADXDK19278"></a><div class="props_rev_3"><a id="GUID-61216843-3968-49AB-8323-5774A7ABA2D7" name="GUID-61216843-3968-49AB-8323-5774A7ABA2D7"></a><h3 id="ADXDK-GUID-61216843-3968-49AB-8323-5774A7ABA2D7" class="sect3">使用XML模式验证XML</h3>
               <div>
                  <p>主题涵盖了使用XML模式验证XML文档的各种方法。</p>
                  <div class="section"> </div>
                  <!-- class="section" -->
               </div><a id="ADXDK19279"></a><div class="props_rev_3"><a id="GUID-5B182AA2-84E3-416A-837A-6563B2F948D5" name="GUID-5B182AA2-84E3-416A-837A-6563B2F948D5"></a><h4 id="ADXDK-GUID-5B182AA2-84E3-416A-837A-6563B2F948D5" class="sect4">验证内部引用的XML模式</h4>
                  <div>
                     <p><code class="codeph">$ORACLE_HOME/xdk/demo/java/schema/XSDSample.java</code>显示了如何针对隐式XML模式进行验证。验证模式是隐式的，因为XML模式在实例文档本身中被引用。
                     </p>
                     <div class="section">
                        <p>按照本节中的步骤编写使用<code class="codeph">setValidationMode()</code>方法的程序<code class="codeph">oracle.xml.parser.v2.</code><code class="codeph">DOMParser</code>类：</p>
                     </div>
                     <!-- class="section" -->
                     <ol>
                        <li class="stepexpand"><span>创建DOM解析器以用于验证实例文档。来自<code class="codeph">XSDSample.java</code>此代码片段显示了如何创建<code class="codeph">DOMParser</code>对象：</span><div><pre class="oac_no_warn" dir="ltr">public class XSDSample {public static void main（String [] args）抛出异常{if（args.length！= 1）{System.out.println（“用法：java XSDSample &lt;文件名&gt;”）;返回; } process（args [0]）; public static void process（String xmlURI）throws Exception {DOMParser dp = new DOMParser（）; URL url = createURL（xmlURI）; ...} ...}</pre><p><code class="codeph">createURL()</code>是一个帮助器方法，它从作为参数传递给程序的文件名构造URL。
                              </p>
                           </div>
                        </li>
                        <li class="stepexpand"><span>使用<code class="codeph">DOMParser.setValidationMode()</code>方法设置验证DOM解析器的验证模式。例如， <code class="codeph">XSDSample.java</code>显示了如何指定XML模式验证：</span><div><pre class="oac_no_warn" dir="ltr">dp.setValidationMode（XMLParser的。SCHEMA_VALIDATION）; dp.setPreserveWhitespace（真）;</pre></div>
                        </li>
                        <li class="stepexpand"><span>使用<code class="codeph">DOMParser.setErrorStream()</code>方法设置输出错误流。例如， <code class="codeph">XSDSample.java</code>为DOM解析器对象设置错误流：</span><div><pre class="oac_no_warn" dir="ltr">dp.setErrorStream（System.out）;</pre></div>
                        </li>
                        <li class="stepexpand"><span>使用<code class="codeph">DOMParser.parse()</code>方法验证实例文档。您不必显式创建XML架构对象，因为架构由实例文档在内部引用。例如， <code class="codeph">XSDSample.java</code>验证实例文档：</span><div><pre class="oac_no_warn" dir="ltr">尝试{System.out.println（“Parsing”+ xmlURI）; dp.parse（URL）; System.out.println（“输入文件&lt;”+ xmlURI +“&gt;解析没有错误”）; } catch（XMLParseException pe）{System.out.println（“Parser Exception：”+ pe.getMessage（））; } catch（Exception e）{System.out.println（“NonParserException：”+ e.getMessage（））; }</pre></div>
                        </li>
                     </ol>
                  </div>
               </div><a id="ADXDK19280"></a><div class="props_rev_3"><a id="GUID-EAAAB139-E5FE-434E-A310-2E13099B1FF8" name="GUID-EAAAB139-E5FE-434E-A310-2E13099B1FF8"></a><h4 id="ADXDK-GUID-EAAAB139-E5FE-434E-A310-2E13099B1FF8" class="sect4">验证外部引用的XML模式</h4>
                  <div>
                     <p><code class="codeph">$ORACLE_HOME/xdk/demo/java/schema/XSDSetSchema.java</code>显示了如何显式验证XML模式。验证模式是显式的，因为您使用<code class="codeph">XSDBuilder</code>类来指定用于验证的模式：未在实例文档中指定模式，如在隐式验证中。
                     </p>
                     <div class="section">
                        <p></p>
                        <p>按照本节中的基本步骤编写使用<code class="codeph">oracle.xml.parser.schema.的<code class="codeph">build()</code>方法的Java程序<code class="codeph">oracle.xml.parser.schema.XSDBuilder</code>类：</p>
                     </div>
                     <!-- class="section" -->
                     <ol>
                        <li class="stepexpand"><span>使用<code class="codeph">XSDBuilder.build()</code>方法从XML模式文档构建XML模式对象。来自<code class="codeph">XSDSetSchema.java</code>此代码片段显示了如何创建对象：</span><div><pre class="oac_no_warn" dir="ltr">public class XSDSetSchema {public static void main（String [] args）抛出异常{if（args.length！= 2）{System.out.println（“用法：java XSDSample &lt;schema_file&gt; &lt;xml_file&gt;”）;返回; XSDBuilder builder = new XSDBuilder（）; URL url = createURL（args [0]）; //构建XML模式对象XMLSchema schemadoc =（XMLSchema）builder.build（url）;过程（args [1]，schemadoc）; }。 。 。
</pre><p><code class="codeph">createURL()</code>方法是一个辅助方法，它根据命令行中指定的模式文档文件名构造URL。
                              </p>
                           </div>
                        </li>
                        <li class="stepexpand"><span>创建DOM解析器以用于验证实例文档。<code class="codeph">XSDSetSchema.java</code>中的此代码显示了如何将实例文档文件名和XML模式对象传递给<code class="codeph">process()</code>方法：</span><div><pre class="oac_no_warn" dir="ltr">public static void process（String xmlURI，XMLSchema schemadoc）throws Exception {DOMParser dp = new DOMParser（）; URL url = createURL（xmlURI）; 。 。 。
</pre></div>
                        </li>
                        <li class="stepexpand"><span>使用<code class="codeph">DOMParser.setXMLSchema()</code>方法指定要用于验证的模式对象。在隐式验证模式下，此步骤不是必需的，因为实例文档已经引用了模式。例如， <code class="codeph">XSDSetSchema.java</code>指定架构：</span><div><pre class="oac_no_warn" dir="ltr">dp.setXMLSchema（schemadoc）;</pre></div>
                        </li>
                        <li class="stepexpand"><span>使用<code class="codeph">DOMParser.setValidationMode()</code>方法设置DOM解析器对象的验证模式。例如， <code class="codeph">XSDSample.java</code>显示了如何指定XML模式验证：</span><div><pre class="oac_no_warn" dir="ltr">dp.setValidationMode（XMLParser的。SCHEMA_VALIDATION）; dp.setPreserveWhitespace（真）;</pre></div>
                        </li>
                        <li class="stepexpand"><span>使用<code class="codeph">DOMParser.setErrorStream()</code>方法设置解析器的输出错误流。例如， <code class="codeph">XSDSetSchema.java</code>设置它：</span><div><pre class="oac_no_warn" dir="ltr">dp.setErrorStream（System.out）;</pre></div>
                        </li>
                        <li class="stepexpand"><span>使用<code class="codeph">DOMParser.parse()</code>方法针对XML模式验证实例文档。例如， <code class="codeph">XSDSetSchema.java</code>包含以下代码：</span><div><pre class="oac_no_warn" dir="ltr">尝试{System.out.println（“Parsing”+ xmlURI）; dp.parse（url）; System.out.println（“输入文件&lt;”+ xmlURI +“&gt;解析没有错误”）; } catch（XMLParseException pe）{System.out.println（“Parser Exception：”+ pe.getMessage（））; } catch（Exception e）{System.out.println（“NonParserException：”+ e.getMessage（））; }</pre></div>
                        </li>
                     </ol>
                  </div>
               </div><a id="ADXDK19281"></a><div class="props_rev_3"><a id="GUID-AFB85EDC-550E-41D9-8754-9F916E44301E" name="GUID-AFB85EDC-550E-41D9-8754-9F916E44301E"></a><h4 id="ADXDK-GUID-AFB85EDC-550E-41D9-8754-9F916E44301E" class="sect4">验证XML文档的子部分</h4>
                  <div>
                     <p>在LAX模式下，您可以验证XML文档的各个部分，而无需验证所有部分。LAX解析验证在关联的XML模式中声明的文档中的元素。如果实例文档不包含模式中声明的元素，则处理器不会认为该实例文档无效。</p>
                     <div class="section">
                        <p></p>
                        <p>通过使用LAX模式，您只能为要验证的XML部分定义模式。<code class="codeph">$ORACLE_HOME/xdk/demo/java/schema/XSDLax.java</code>程序显示了如何使用LAX验证。该程序遵循<a href="using-XML-schema-processor-for-Java.html#GUID-EAAAB139-E5FE-434E-A310-2E13099B1FF8" title="$ ORACLE_HOME / xdk / demo / java / schema / XSDSetSchema.java显示了如何显式验证XML模式。验证模式是显式的，因为您使用XSDBuilder类来指定用于验证的模式：未在实例文档中指定模式，如在隐式验证中。">验证外部引用的XML模式中</a>描述的基本步骤：</p>
                     </div>
                     <!-- class="section" -->
                     <ol>
                        <li><span>从用户指定的XML模式文档构建XML模式对象。</span></li>
                        <li><span>创建DOM解析器以用于验证实例文档。</span></li>
                        <li><span>指定用于验证的XML架构。</span></li>
                        <li><span>设置DOM解析器对象的验证模式。</span></li>
                        <li><span>设置解析器的输出错误流。</span></li>
                        <li><span>通过调用<code class="codeph">DOMParser.parse()</code>针对XML模式验证实例文档。</span></li>
                     </ol>
                     <div class="section">
                        <p>要启用LAX验证，程序<code class="codeph">SCHEMA_LAX_VALIDATION</code>解析器中的验证模式设置为<code class="codeph">SCHEMA_LAX_VALIDATION</code>而不是<code class="codeph">SCHEMA_VALIDATION</code> 。来自<code class="codeph">XSDLax.java</code>代码片段显示了这种技术：</p><pre class="oac_no_warn" dir="ltr">dp.setXMLSchema（schemadoc）; dp.setValidationMode（XMLParser的。SCHEMA_LAX_VALIDATION）; dp.setPreserveWhitespace（true）; 。 。 。
</pre><p>您可以通过运行示例程序来测试LAX验证：</p><pre class="oac_no_warn" dir="ltr">java XSDLax embeded_xsql.xsd embeded_xsql.xml</pre></div>
                     <!-- class="section" -->
                  </div>
               </div><a id="ADXDK19282"></a><div class="props_rev_3"><a id="GUID-C1C29EFC-2A5F-4D5E-8A45-E8E1A47720A3" name="GUID-C1C29EFC-2A5F-4D5E-8A45-E8E1A47720A3"></a><h4 id="ADXDK-GUID-C1C29EFC-2A5F-4D5E-8A45-E8E1A47720A3" class="sect4">从SAX流验证XML</h4>
                  <div>
                     <p><code class="codeph">$ORACLE_HOME/xdk/demo/java/schema/xsdsax.java</code>显示如何验证作为SAX流接收的XML文档。您实例化<code class="codeph">XSDValidator</code>并将其作为内容处理程序注册到SAX解析器。
                     </p>
                     <div class="section">
                        <p>按照本节中的步骤编写从SAX流验证XML的程序：</p>
                     </div>
                     <!-- class="section" -->
                     <ol>
                        <li class="stepexpand"><span>通过调用<code class="codeph">XSDBuilder.build()</code>方法，从用户指定的XML模式文档构建XML模式对象。此代码片段显示了如何创建对象：</span><div><pre class="oac_no_warn" dir="ltr">XSDBuilder builder = new XSDBuilder（）; URL url = XMLUtil.createURL（args [0]）; //构建XML模式对象XMLSchema schemadoc =（XMLSchema）builder.build（url）;过程（args [1]，schemadoc）; 。 。 。
</pre><p><code class="codeph">createURL()</code>是一个帮助器方法，它根据命令行中指定的文件名构造URL。
                              </p>
                           </div>
                        </li>
                        <li class="stepexpand"><span>创建一个SAX解析器（ <code class="codeph">SAXParser</code>对象）以用于验证实例文档。来自<code class="codeph">saxxsd.java</code>代码片段将句柄传递给XML文档和模式文档到<code class="codeph">process()</code>方法：</span><div><pre class="oac_no_warn" dir="ltr">process（args [1]，schemadoc）; ... public static void process（String xmlURI，XMLSchema schemadoc）throws Exception {SAXParser dp = new SAXParser（）; ...
</pre></div>
                        </li>
                        <li class="stepexpand"><span>配置SAX解析器。此代码片段使用<code class="codeph">XSDBuilder.setValidationMode()</code>方法设置SAX解析器对象的验证模式：</span><div><pre class="oac_no_warn" dir="ltr">dp.setPreserveWhitespace（true）; dp.setValidationMode（XMLParser的。非验证）;</pre></div>
                        </li>
                        <li class="stepexpand"><span>创建并配置验证器（ <code class="codeph">XSDValidator</code>对象）。此代码片段显示了此技术：</span><div><pre class="oac_no_warn" dir="ltr">XMLError错误; ...错误=新XMLError（）; ...XSDValidator validator = new XSDValidator（）; ...validator.setError（ERR）;</pre></div>
                        </li>
                        <li class="stepexpand"><span>通过调用<code class="codeph">XSDBuilder.setXMLProperty()</code>方法指定要用于验证的XML模式。第一个参数是属性的名称，它是<code class="codeph">fixedSchema</code> ，第二个参数是对XML模式对象的引用。此代码片段显示了此技术：</span><div><pre class="oac_no_warn" dir="ltr">validator.setXMLProperty（XSDNode。FIXED_SCHEMA，schemadoc）; ...
</pre></div>
                        </li>
                        <li class="stepexpand"><span>将验证器注册为解析器的SAX内容处理程序。此代码片段显示了此技术：</span><div><pre class="oac_no_warn" dir="ltr">dp.setContentHandler（验证器）; ...
</pre></div>
                        </li>
                        <li class="stepexpand"><span>通过调用<code class="codeph">SAXParser.parse()</code>方法，针对XML模式验证实例文档。此代码片段显示了此技术：</span><div><pre class="oac_no_warn" dir="ltr">dp.parse（url）;</pre></div>
                        </li>
                     </ol>
                  </div>
               </div><a id="ADXDK19283"></a><div class="props_rev_3"><a id="GUID-38EF516D-CB44-4857-9EEF-17ECE082068E" name="GUID-38EF516D-CB44-4857-9EEF-17ECE082068E"></a><h4 id="ADXDK-GUID-38EF516D-CB44-4857-9EEF-17ECE082068E" class="sect4">从DOM验证XML</h4>
                  <div>
                     <p><code class="codeph">$ORACLE_HOME/xdk/demo/java/schema/xsddom.java</code>显示如何通过获取文档的DOM表示并使用<code class="codeph">XSDValidator</code>对象来验证它来验证实例文档。
                     </p>
                     <div class="section">
                        <p><code class="codeph">xsddom.java</code>程序遵循以下步骤：</p>
                     </div>
                     <!-- class="section" -->
                     <ol>
                        <li class="stepexpand"><span>通过调用<code class="codeph">XSDBuilder.build()</code>方法，从用户指定的XML模式文档构建XML模式对象。此代码片段显示了如何创建对象：</span><div><pre class="oac_no_warn" dir="ltr">XSDBuilder builder = new XSDBuilder（）; URL url = XMLUtil.createURL（args [0]）; XMLSchema schemadoc =（XMLSchema）builder.build（url）;过程（args [1]，schemadoc）;</pre><p><code class="codeph">createURL()</code>是一个帮助器方法，它根据命令行中指定的文件名构造URL。
                              </p>
                           </div>
                        </li>
                        <li class="stepexpand"><span>创建DOM解析器（ <code class="codeph">DOMParser</code>对象）以用于验证实例文档。来自<code class="codeph">domxsd.java</code>代码片段将句柄传递给XML文档和模式文档到<code class="codeph">process()</code>方法：</span><div><pre class="oac_no_warn" dir="ltr">process（args [1]，schemadoc）; ... public static void process（String xmlURI，XMLSchema schemadoc）throws Exception {DOMParser dp = new DOMParser（）; 。 。 。
</pre></div>
                        </li>
                        <li class="stepexpand"><span>配置DOM解析器。此代码片段使用<code class="codeph">DOMParser.setValidationMode()</code>方法设置解析器对象的验证模式：</span><div><pre class="oac_no_warn" dir="ltr">dp.setPreserveWhitespace（true）; dp.setValidationMode（XMLParser的。非验证）; dp.setErrorStream（System.out）;</pre></div>
                        </li>
                        <li class="stepexpand"><span>解析实例文档。此代码片段显示了此技术：</span><div><pre class="oac_no_warn" dir="ltr">dp.parse（url）;</pre></div>
                        </li>
                        <li class="stepexpand"><span>获取输入文档的DOM表示。此代码片段显示了此技术：</span><div><pre class="oac_no_warn" dir="ltr">XMLDocument doc = dp.getDocument（）;</pre></div>
                        </li>
                        <li class="stepexpand"><span>创建并配置验证器（ <code class="codeph">XSDValidator</code>对象）。此代码片段显示了此技术：</span><div><pre class="oac_no_warn" dir="ltr">XMLError错误; ...错误=新XMLError（）; ...XSDValidator validator = new XSDValidator（）; ...validator.setError（ERR）;</pre></div>
                        </li>
                        <li class="stepexpand"><span>通过调用<code class="codeph">XSDBuilder.setXMLProperty()</code>方法指定要用于验证的模式对象。第一个参数是属性的名称，在此示例中为<code class="codeph">fixedSchema</code> ，第二个参数是对架构对象的引用。此代码片段显示了此技术：</span><div><pre class="oac_no_warn" dir="ltr">validator.setXMLProperty（XSDNode。FIXED_SCHEMA，schemadoc）; 。 。 。
</pre></div>
                        </li>
                        <li class="stepexpand"><span>获取DOM树的根元素（ <code class="codeph">XMLElement</code> ）并进行验证。此代码片段显示了此技术：</span><div><pre class="oac_no_warn" dir="ltr">XMLElement root =（XMLElement）doc.getDocumentElement（）; XMLElement copy =（XMLElement）root.validateContent（validator，true）; copy.print（System.out的）;</pre></div>
                        </li>
                     </ol>
                  </div>
               </div><a id="ADXDK19284"></a><div class="props_rev_3"><a id="GUID-49EE75AF-E9AE-48A7-A331-7707A12A947C" name="GUID-49EE75AF-E9AE-48A7-A331-7707A12A947C"></a><h4 id="ADXDK-GUID-49EE75AF-E9AE-48A7-A331-7707A12A947C" class="sect4">从设计类型和元素验证XML</h4>
                  <div>
                     <p><code class="codeph">$ORACLE_HOME/xdk/demo/java/schema/xsdproperty.java</code>显示了如何配置XML Schema处理器以基于复杂类型或元素声明验证XML文档。
                     </p>
                     <div class="section">
                        <p><code class="codeph">xsdproperty.java</code>程序遵循以下步骤：</p>
                        <ol>
                           <li>
                              <p>为实例文档名称，XML模式名称，根节点名称空间，根节点本地名称以及元素或复杂类型的规范创建<code class="codeph">String</code>对象（“true”表示根节点是元素声明）。此代码片段显示了此技术：</p><pre class="oac_no_warn" dir="ltr">String xmlfile = args [0]; String xsdfile = args [1]; ...String ns = args [2]; //根节点的命名空间String nm = args [3]; //根节点的本地名称String el = args [4]; //如果根节点是元素声明，则为true;否则，根节点是复杂类型</pre></li>
                           <li>
                              <p>创建XSD构建器并使用它来创建架构对象。此代码片段显示了此技术：</p><pre class="oac_no_warn" dir="ltr">XSDBuilder builder = new XSDBuilder（）; URL url = XMLUtil.createURL（xsdfile）; XMLSchema架构; ...schema =（XMLSchema）builder.build（url）;</pre></li>
                           <li>
                              <p>获取节点。根据节点是元素声明还是复杂类型调用不同的方法：</p>
                              <ul style="list-style-type:disc">
                                 <li>
                                    <p>如果节点是元素声明，则将本地名称和命名空间传递给架构对象的<code class="codeph">getElement()</code>方法。
                                    </p>
                                 </li>
                                 <li>
                                    <p>如果节点是元素声明，则将命名空间，本地名称和根复合体类型传递给架构对象的<code class="codeph">getType()</code>方法。
                                    </p>
                                 </li>
                              </ul>
                              <p><code class="codeph">xsdproperty.java</code>使用此控件结构：</p><pre class="oac_no_warn" dir="ltr">QxName qname = new QxName（ns，nm）; ...XSDNode nd; ...if（el.equals（“true”））{nd = schema.getElement（ns，nm）; / *过程......* /} else {nd = schema.getType（ns，nm，XSDNode。类型）; / *过程......* /}</pre></li>
                           <li>
                              <p>获取节点后，创建一个新的解析器并将模式设置为解析器以启用模式验证。此代码片段显示了此技术：</p><pre class="oac_no_warn" dir="ltr">DOMParser dp = new DOMParser（）; URL url = XMLUtil.createURL（xmlURI）;</pre></li>
                           <li>
                              <p>在解析器上设置属性，然后解析URL。调用<code class="codeph">schemaValidatorProperty()</code>方法：</p>
                              <ol type="a">
                                 <li>
                                    <p>将解析器上的根元素或类型属性设置为完全限定名称。</p>
                                    <p>对于顶级元素声明，请将属性名称设置为<code class="codeph">XSDNode.ROOT_ELEMENT</code>和<code class="codeph">QName</code>的值，由<code class="codeph">process1()</code>方法显示。
                                    </p>
                                    <p>对于顶级类型定义，请将属性名称设置为<code class="codeph">XSDNode.ROOT_TYPE</code>和<code class="codeph">QName</code>的值，由<code class="codeph">process2()</code>方法显示。
                                    </p>
                                 </li>
                                 <li>
                                    <p>将解析器上的根节点属性设置为元素或复杂类型节点。</p>
                                    <p>对于元素节点，将属性名称设置为<code class="codeph">XSDNode.ROOT_NODE</code>和<code class="codeph">XSDElement</code>节点的值，如<code class="codeph">XSDElement</code> <code class="codeph">process3()</code>方法所示。
                                    </p>
                                    <p>对于类型节点，将属性名称设置为<code class="codeph">XSDNode.ROOT_NODE</code>和<code class="codeph">XSDComplexType</code>节点的值，如<code class="codeph">XSDComplexType</code> <code class="codeph">process3()</code>方法所示。
                                    </p>
                                 </li>
                              </ol>
                              <p>此代码片段显示了方法调用的顺序：</p><pre class="oac_no_warn" dir="ltr">if（el.equals（“true”））{nd = schema.getElement（ns，nm）; process1（xmlfile，schema，qname）; process3（xmlfile，schema，nd）; } else {nd = schema.getType（ns，nm，XSDNode。类型）; process2（xmlfile，schema，qname）; process3（xmlfile，schema，nd）; }</pre><p>处理方法实施：</p><pre class="oac_no_warn" dir="ltr">static void process1（String xmlURI，XMLSchema schema，QxName qname）抛出异常{/ * create parser ...* / dp.setXMLSchema（schema）; dp.setSchemaValidatorProperty（XSDNode。ROOT_ELEMENT，qname）; dp.setPreserveWhitespace（true）; dp.setErrorStream（System.out）; dp.parse（url）; ...static void process2（String xmlURI，XMLSchema schema，QxName qname）抛出异常{/ * create parser ...* / dp.setXMLSchema（schema）; dp.setSchemaValidatorProperty（XSDNode。ROOT_TYPE，qname）; dp.setPreserveWhitespace（true）; dp.setErrorStream（System.out）; dp.parse（url）; ...static void process3（String xmlURI，XMLSchema schema，XSDNode node）抛出Exception {/ * create parser ...* / dp.setXMLSchema（schema）; dp.setSchemaValidatorProperty（XSDNode。ROOT_NODE，节点）; dp.setPreserveWhitespace（true）; dp.setErrorStream（System.out）; dp.parse（url）; ...}</pre></li>
                        </ol>
                     </div>
                     <!-- class="section" -->
                  </div>
               </div>
            </div><a id="ADXDK996"></a><a id="ADXDK19286"></a><div class="props_rev_3"><a id="GUID-654F9D12-EC32-464B-9465-06ECB9213829" name="GUID-654F9D12-EC32-464B-9465-06ECB9213829"></a><h3 id="ADXDK-GUID-654F9D12-EC32-464B-9465-06ECB9213829" class="sect3">使用XML模式进行编程的技巧和技巧</h3>
               <div>
                  <p>主题包括覆盖模式位置和将DTD转换为XML模式。</p>
                  <div class="section"> </div>
                  <!-- class="section" -->
               </div><a id="ADXDK19287"></a><div class="props_rev_3"><a id="GUID-FB1780C6-0CD0-4393-AEDD-0294701BEE9D" name="GUID-FB1780C6-0CD0-4393-AEDD-0294701BEE9D"></a><h4 id="ADXDK-GUID-FB1780C6-0CD0-4393-AEDD-0294701BEE9D" class="sect4">使用实体解析器覆盖架构位置</h4>
                  <div>
                     <p>当<code class="codeph">XSDBuilder</code>构建模式时，可能需要包含或导入在<code class="codeph">schemaLocation</code>属性中指定为URL的其他模式。在某些情况下，您可能希望覆盖<code class="codeph">&lt;import&gt;</code>指定的架构位置，并为构建器提供所需的架构文档。
                     </p>
                     <div class="section">
                        <p><a href="using-XML-schema-processor-for-Java.html#GUID-1794B57C-BD9A-4322-B136-B07B950EC479__CIHIEEDI" title="此表描述了可用于测试XML架构处理器的XML文件和程序。文件和描述是列。">表17-3</a>中描述的<code class="codeph">xsdent.java</code>演示显示了需要导入指定为<code class="codeph">schemaLocation</code>的模式的情况。<code class="codeph">xsdent.xml</code>文件中的document元素包含以下属性：</p><pre class="oac_no_warn" dir="ltr">xsi：schemaLocation =“http://www.example.com/BookCatalogue xsdent.xsd”&gt;</pre><p><code class="codeph">xsdent.xsd</code>文档包含以下元素：</p><pre class="oac_no_warn" dir="ltr">&lt;schema xmlns =“http://www.w3.org/2001/XMLSchema"targetNamespace =”http://www.example.com/BookCatalogue“xmlns：catd =”http://www.example.com/Digest “xmlns：cat =”http://www.example.com/BookCatalogue“elementFormDefault =”qualified“&gt; &lt;import namespace =”http://www.example.com/Digest“schemaLocation =”xsdent-1.xsd“ /&gt;</pre><p>作为想要覆盖<code class="codeph">&lt;import&gt;</code>指定的模式位置并向构建器提供所需模式文档的示例，假设您已从外部Web站点下载了模式文档并将其存储在数据库中。在这种情况下，您可以在<code class="codeph">XSDBuilder</code>设置实体解析程序。<code class="codeph">XSDBuilder</code>将架构位置传递给解析器，解析器将<code class="codeph">InputStream</code> ， <code class="codeph">Reader</code>或<code class="codeph">URL</code>作为<code class="codeph">InputSource</code> 。构建器可以从<code class="codeph">InputSource</code>读取架构文档。
                        </p>
                        <p><code class="codeph">xsdent.java</code>程序显示了如何使用实体解析器覆盖架构位置。您必须实现<code class="codeph">EntityResolver</code>接口，实例化实体解析程序，并在XML模式构建器中进行设置。在演示代码中， <code class="codeph">sampleEntityResolver1</code>将<code class="codeph">InputSource</code>作为<code class="codeph">InputStream</code>返回，而<code class="codeph">sampleEntityResolver2</code>将<code class="codeph">InputSource</code>作为<code class="codeph">URL</code>返回。</p>
                        <p>请遵循以下基本步骤：</p>
                     </div>
                     <!-- class="section" -->
                     <ol>
                        <li class="stepexpand"><span>创建新的XML架构生成器：</span><div><pre class="oac_no_warn" dir="ltr">XSDBuilder builder = new XSDBuilder（）;</pre></div>
                        </li>
                        <li class="stepexpand"><span>将构建器设置为实体解析器。实体解析器是实现<code class="codeph">EntityResolver</code>接口的类。解析器的目的是使XML阅读器在包含它们之前拦截任何外部实体。此代码片段创建实体解析器并在构建器中设置它：</span><div><pre class="oac_no_warn" dir="ltr">builder.setEntityResolver（new sampleEntityResolver1（））;</pre><p><code class="codeph">sampleEntityResolver1</code>类实现<code class="codeph">resolveEntity()</code>方法。您可以使用此方法将外部系统标识符重定向到本地URI。源代码是：</p><pre class="oac_no_warn" dir="ltr">class sampleEntityResolver1实现EntityResolver {public InputSource resolveEntity（String targetNS，String systemId）抛出SAXException，IOException {//根据targetNS＆systemId InputSource mySource = null执行任何验证检查; URL u = XMLUtil.createURL（systemId）; //使用InputStream作为输入创建输入源mySource = new InputSource（u.openStream（））; mySource.setSystemId（的systenId）;返回mySource; }}</pre><p><code class="codeph">sampleEntityResolver1</code>类使用流初始化<code class="codeph">InputSource</code> 。
                              </p>
                           </div>
                        </li>
                        <li class="stepexpand"><span>构建XML架构对象。此代码显示了此技术：</span><div><pre class="oac_no_warn" dir="ltr">schemadoc = builder.build（url）;</pre></div>
                        </li>
                        <li class="stepexpand"><span>根据XML模式验证实例文档。该程序执行此语句：</span><div><pre class="oac_no_warn" dir="ltr">进程（xmlfile，schemadoc）;</pre><p><code class="codeph">process()</code>方法创建一个DOM解析器，对其进行配置，并调用<code class="codeph">parse()</code>方法。该方法实施：</p><pre class="oac_no_warn" dir="ltr">public static void process（String xmlURI，Object schemadoc）throws Exception {DOMParser dp = new DOMParser（）; URL url = XMLUtil.createURL（xmlURI）; dp.setXMLSchema（schemadoc）; dp.setValidationMode（XMLParser的。SCHEMA_VALIDATION）; dp.setPreserveWhitespace（true）; dp.setErrorStream（System.out）;试试{dp.parse（url）; ...}</pre></div>
                        </li>
                     </ol>
                  </div>
               </div><a id="ADXDK19288"></a><div class="props_rev_3"><a id="GUID-BC0B8A74-265E-4EBF-B012-923DA614F744" name="GUID-BC0B8A74-265E-4EBF-B012-923DA614F744"></a><h4 id="ADXDK-GUID-BC0B8A74-265E-4EBF-B012-923DA614F744" class="sect4">将DTD转换为XML模式</h4>
                  <div>
                     <p>由于XML Schema语言的强大功能和灵活性，您可能希望将现有DTD转换为XML架构文档。您可以使用XDK执行此转换。</p>
                     <div class="section">
                        <p><code class="codeph">$ORACLE_HOME/xdk/demo/java/schema/DTD2Schema.java</code>程序显示了如何转换DTD。你可以测试一下程序：</p><pre class="oac_no_warn" dir="ltr">java DTD2Schema dtd2schema.dtd dtd2schema.xml</pre><p>按照以下基本步骤将DTD转换为XML架构文档：</p>
                     </div>
                     <!-- class="section" -->
                     <ol>
                        <li class="stepexpand"><span>使用<code class="codeph">DOMParser.parseDTD()</code>方法解析DTD。<code class="codeph">DTD2Schema.java</code>中的此代码片段显示了如何创建DTD对象：</span><div><pre class="oac_no_warn" dir="ltr">XSDBuilder builder = new XSDBuilder（）; URL dtdURL = createURL（args [0]）; DTD dtd = getDTD（dtdURL，“abc”）;</pre><p>实现了<code class="codeph">getDTD()</code>方法：</p><pre class="oac_no_warn" dir="ltr">private static DTD getDTD（URL dtdURL，String rootName）throws Exception {DOMParser parser = new DOMParser（）; DTD dtd; parser.setValidationMode（真）; parser.setErrorStream（System.out的）; parser.showWarnings（真）; parser.parseDTD（dtdURL，rootName）; dtd =（DTD）parser.getDoctype（）;返回dtd; }</pre></div>
                        </li>
                        <li class="stepexpand"><span>使用<code class="codeph">DTD.convertDTD2Sdhema()</code>方法将DTD转换为XML模式DOM树。<code class="codeph">DTD2Schema.java</code>中的这段代码片段显示了这种技术：</span><div><pre class="oac_no_warn" dir="ltr">XMLDocument dtddoc = dtd.convertDTD2Schema（）;</pre></div>
                        </li>
                        <li class="stepexpand"><span>使用<code class="codeph">XMLDocument.print()</code>方法将XML模式DOM树写入输出流。<code class="codeph">DTD2Schema.java</code>中的这段代码片段显示了这种技术：</span><div><pre class="oac_no_warn" dir="ltr">FileOutputStream fos = new FileOutputStream（“dtd2schema.xsd.out”）; dtddoc.print（FOS）;</pre></div>
                        </li>
                        <li class="stepexpand"><span>使用<code class="codeph">XSDBuilder.build()</code>方法从架构DOM树创建XML架构对象。<code class="codeph">DTD2Schema.java</code>中的这段代码片段显示了这种技术：</span><div><pre class="oac_no_warn" dir="ltr">XMLSchema schemadoc =（XMLSchema）builder.build（dtddoc，null）;</pre></div>
                        </li>
                        <li class="stepexpand"><span>使用<code class="codeph">DOMParser.parse()</code>方法针对XML模式验证实例文档。<code class="codeph">DTD2Schema.java</code>中的这段代码片段显示了这种技术：</span><div><pre class="oac_no_warn" dir="ltr">validate（args [1]，schemadoc）;</pre><p><code class="codeph">validate()</code>方法已实现：</p><pre class="oac_no_warn" dir="ltr">DOMParser dp = new DOMParser（）; URL url = createURL（xmlURI）; dp.setXMLSchema（schemadoc）; dp.setValidationMode（XMLParser的。SCHEMA_VALIDATION）; dp.setPreserveWhitespace（true）; dp.setErrorStream（System.out）;尝试{System.out.println（“Parsing”+ xmlURI）; dp.parse（url）; System.out.println（“输入文件&lt;”+ xmlURI +“&gt;解析没有错误”）; } ...</pre></div>
                        </li>
                     </ol>
                  </div>
               </div>
            </div>
         </div>
      </article>
   </body>
</html>