<html lang="en-us" dir="ltr" xml:lang="en-us">
   <head>
      <meta http-equiv="Content-Type" content="text/html; charset=utf-8"></meta>
      <meta name="viewport" content="width=device-width, initial-scale=1"></meta>
      <meta http-equiv="X-UA-Compatible" content="IE=edge"></meta>
      <meta name="abstract" content="An explanation is given of how to use the Extensible Markup Language (XML) SQL Utility (XSU)."></meta>
      <meta name="description" content="An explanation is given of how to use the Extensible Markup Language (XML) SQL Utility (XSU)."></meta>
      <title>使用XML SQL实用程序</title>
      <meta property="og:site_name" content="Oracle Help Center"></meta>
      <meta property="og:title" content="Programmer&#39;s Guide"></meta>
      <meta property="og:description" content="An explanation is given of how to use the Extensible Markup Language (XML) SQL Utility (XSU)."></meta>
      <link rel="stylesheet" href="/sp_common/book-template/ohc-book-template/css/book.css"></link>
      <link rel="shortcut icon" href="/sp_common/book-template/ohc-common/img/favicon.ico"></link>
      <meta name="application-name" content="Programmer&#39;s Guide"></meta>
      <meta name="generator" content="DITA Open Toolkit version 1.8.5 (Mode = doc)"></meta>
      <meta name="plugin" content="SP_docbuilder HTML plugin release 18.2.2"></meta>
      <link rel="alternate" href="xml-developers-kit-programmers-guide.pdf" title="PDF File" type="application/pdf"></link>
      <meta name="robots" content="all"></meta>
      <link rel="schema.dcterms" href="http://purl.org/dc/terms/"></link>
      <meta name="dcterms.created" content="2019-01-11T05:58:48-08:00"></meta>
      
      <meta name="dcterms.dateCopyrighted" content="2001, 2019"></meta>
      <meta name="dcterms.category" content="database"></meta>
      <meta name="dcterms.identifier" content="E96292-01"></meta>
      
      <meta name="dcterms.product" content="en/database/oracle/oracle-database/19"></meta>
      
      <link rel="prev" href="determining-XML-differences-using-Java.html" title="Previous" type="text/html"></link>
      <link rel="next" href="using-TransX-utility.html" title="Next" type="text/html"></link>
      <script>
        document.write('<style type="text/css">');
        document.write('body > .noscript, body > .noscript ~ * { visibility: hidden; }');
        document.write('</style>');
     </script>
      <script src="/sp_common/book-template/requirejs/require.js" data-main="/sp_common/book-template/ohc-book-template/js/book-config"></script>
      <script>
            if (window.require === undefined) {
                document.write('<script data-main="sp_common/book-template/ohc-book-template/js/book-config" src="sp_common/book-template/requirejs/require.js"><\/script>');
                document.write('<link href="sp_common/book-template/ohc-book-template/css/book.css" rel="stylesheet"/>');
            }
        </script>
      <script type="application/json" id="ssot-metadata">{"primary":{"category":{"short_name":"database","element_name":"Database","display_in_url":true},"suite":{"short_name":"oracle","element_name":"Oracle","display_in_url":true},"product_group":{"short_name":"not-applicable","element_name":"Not applicable","display_in_url":false},"product":{"short_name":"oracle-database","element_name":"Oracle Database","display_in_url":true},"release":{"short_name":"19","element_name":"Release 19","display_in_url":true}}}</script>
      
    <meta name="dcterms.title" content="XML Developers Kit Programmers Guide"></meta>
    <meta name="dcterms.isVersionOf" content="ADXDK"></meta>
    <meta name="dcterms.release" content="Release 19"></meta>
  </head>
   <body dir="ltr">
      <div class="noscript alert alert-danger text-center" role="alert">
         <a href="determining-XML-differences-using-Java.html" class="pull-left"><span class="glyphicon glyphicon-chevron-left" aria-hidden="true"></span>上一页</a> <a href="using-TransX-utility.html" class="pull-right">下一页<span class="glyphicon glyphicon-chevron-right" aria-hidden="true"></span></a> <span class="fa fa-exclamation-triangle" aria-hidden="true"></span>必须启用JavaScript才能正确显示此内容</div>
      <article>
         <header>
            <ol class="breadcrumb" vocab="http://schema.org/" typeof="BreadcrumbList">
               <li property="itemListElement" typeof="ListItem"><a href="index.html" property="item" typeof="WebPage"><span property="name">程序员指南</span></a></li>
               <li property="itemListElement" typeof="ListItem"><a href="XDK-for-Java.html" property="item" typeof="WebPage"><span property="name">Oracle XML Developer's Kit for Java</span></a></li>
               <li class="active" property="itemListElement" typeof="ListItem">使用XML SQL实用程序</li>
            </ol>
            <a id="GUID-4C9A3F2F-A2A7-4CBF-BCD4-FD667D559945" name="GUID-4C9A3F2F-A2A7-4CBF-BCD4-FD667D559945"></a><a id="ADXDK1007"></a><a id="ADXDK070"></a>
            
            <h2 id="ADXDK-GUID-4C9A3F2F-A2A7-4CBF-BCD4-FD667D559945" class="sect2"><span class="enumeration_chapter">21</span>使用XML SQL实用程序</h2>
         </header>
         <div class="ind">
            <div>
               <p>解释了如何使用可扩展标记语言（XML）SQL实用程序（XSU）。</p>
               <div class="section"> </div>
               <!-- class="section" -->
            </div><a id="ADXDK1008"></a><a id="ADXDK19392"></a><div class="props_rev_3"><a id="GUID-B8EF3AD4-E94A-487D-969F-2C1B2E095687" name="GUID-B8EF3AD4-E94A-487D-969F-2C1B2E095687"></a><h3 id="ADXDK-GUID-B8EF3AD4-E94A-487D-969F-2C1B2E095687" class="sect3">XML SQL实用程序（XSU）简介</h3>
               <div>
                  <p>XML SQL实用程序（XSU）是Oracle XML Developer's Kit（XDK）组件，允许您使用Oracle SQL语句传输XML数据。</p>
                  <p></p>
                  <p>您可以使用<a href="glossary.html#GUID-A564495D-ED7B-4F52-8FCA-944CF3BB274D"><span class="xrefglossterm">XML SQL Utility（XSU）</span></a>执行以下任务：</p>
                  <ul style="list-style-type:disc">
                     <li>
                        <p>将对象关系数据库表或视图中的数据转换为XML。 XSU可以查询数据库并将结果集作为XML文档返回。</p>
                     </li>
                     <li>
                        <p>从XML文档中提取数据并使用规范映射将数据插入表或视图中，或者更新或删除相应列或属性的值。</p>
                     </li>
                  </ul>
                  <div class="section"> </div>
                  <!-- class="section" -->
               </div><a id="ADXDK19393"></a><div class="props_rev_3"><a id="GUID-AE298459-AB63-4B8E-8D3F-07AB9114DA77" name="GUID-AE298459-AB63-4B8E-8D3F-07AB9114DA77"></a><h4 id="ADXDK-GUID-AE298459-AB63-4B8E-8D3F-07AB9114DA77" class="sect4">使用XML SQL实用程序（XSU）的先决条件</h4>
                  <div>
                     <p>涵盖了使用XML SQL实用程序（XSU）的先决条件。</p>
                     <p>本节假定您熟悉这些技术：</p>
                     <ul style="list-style-type:disc">
                        <li>
                           <p>Oracle数据库结构化查询语言（SQL）。XSU通过<code class="codeph">SELECT</code>语句和数据操作语言（DML）将XML传输到数据库或从数据库传输XML。
                           </p>
                        </li>
                        <li>
                           <p>程序语言/结构化查询语言（PL / SQL）。XDK为XSU提供了一个镜像Java API的PL / SQL应用程序编程接口（API）。</p>
                        </li>
                        <li>
                           <p><a href="glossary.html#GUID-6ABA93DA-F986-43F2-97D2-23AA0EA6455C"><span class="xrefglossterm">Java数据库连接（JDBC）</span></a> 。使用XSU与数据库之间传输XML的Java应用程序需要JDBC连接。
                           </p>
                        </li>
                     </ul>
                  </div>
               </div><a id="ADXDK19394"></a><div class="props_rev_3"><a id="GUID-8D708D9D-F93B-46A2-B96A-7458A2F6C36B" name="GUID-8D708D9D-F93B-46A2-B96A-7458A2F6C36B"></a><h4 id="ADXDK-GUID-8D708D9D-F93B-46A2-B96A-7458A2F6C36B" class="sect4">XSU功能</h4>
                  <div>
                     <p>描述了XML SQL Utility（XSU）提供的主要功能。</p>
                     <p>XSU：</p>
                     <ul style="list-style-type:disc">
                        <li>
                           <p>动态生成文档类型定义（DTD）或XML模式。</p>
                        </li>
                        <li>
                           <p>在其字符串或文档对象模型（DOM）表示中生成XML文档。</p>
                        </li>
                        <li>
                           <p>在生成期间执行简单转换，例如修改每个<code class="codeph">&lt;ROW&gt;</code>元素的默认标记名称。您还可以根据需要注册XSU应用于生成的XML文档的XSL转换。
                           </p>
                        </li>
                        <li>
                           <p>生成XML作为Simple API for XML（SAX2）回调的流。</p>
                        </li>
                        <li>
                           <p>在生成期间支持XML属性，这使您可以指定特定列或列组映射到XML属性而不是XML元素。</p>
                        </li>
                        <li>
                           <p>允许SQL-to-XML-tag转义。有时列名称不是有效的XML标记名称。要避免此问题，您可以为所有列名称添加别名，也可以启用标记转义。</p>
                        </li>
                        <li>
                           <p>支持对象或表中的<code class="codeph">XMLType</code>列。
                           </p>
                        </li>
                        <li>
                           <p>将XML插入关系数据库表或视图中。当给定XML文档时，XSU还可以更新或删除数据库对象中的记录。</p>
                        </li>
                     </ul>
                  </div>
               </div><a id="ADXDK19395"></a><div class="props_rev_3"><a id="GUID-1805B089-C277-4899-9C31-FF44C6866FEF" name="GUID-1805B089-C277-4899-9C31-FF44C6866FEF"></a><h4 id="ADXDK-GUID-1805B089-C277-4899-9C31-FF44C6866FEF" class="sect4">XSU限制</h4>
                  <div>
                     <p>描述了使用XSU的一些限制。</p>
                     <ul style="list-style-type:disc">
                        <li>
                           <p>XSU只能将数据存储在一个表中。但是，您可以跨表格存储XML，方法是使用Oracle可扩展样式表语言转换（XSLT）处理器将文档转换为多个文档并单独插入。您还可以在多个表上定义视图，并在视图中执行插入操作。如果视图是不可更新的（由于复杂的连接），那么您可以在视图上使用<code class="codeph">INSTEAD</code> <code class="codeph">OF</code>触发器来执行插入。
                           </p>
                        </li>
                        <li>
                           <p>您不能使用XSU将存储在属性中的XML数据加载到数据库模式中，但您可以使用XSLT转换将属性更改为元素。</p>
                        </li>
                        <li>
                           <p>默认情况下，XSU区分大小写。您可以使用正确的大小写，也可以指定忽略该大小写。</p>
                        </li>
                        <li>
                           <p>XSU无法从输入DTD生成关系数据库模式。</p>
                        </li>
                        <li>
                           <p>不支持使用XSU插入<code class="codeph">XMLType</code>表。支持<code class="codeph">XMLType</code>列。
                           </p>
                        </li>
                     </ul>
                  </div>
               </div>
            </div><a id="ADXDK1009"></a><a id="ADXDK19396"></a><div class="props_rev_3"><a id="GUID-D3D785EB-E345-4F37-B7A7-7462BAA0F247" name="GUID-D3D785EB-E345-4F37-B7A7-7462BAA0F247"></a><h3 id="ADXDK-GUID-D3D785EB-E345-4F37-B7A7-7462BAA0F247" class="sect3">使用XML SQL实用程序：概述</h3>
               <div>
                  <p>这里的主题包括基本的XSU使用，安装XSU，运行XSU演示程序以及使用XSU命令行实用程序。</p>
                  <div class="section"> </div>
                  <!-- class="section" -->
               </div><a id="ADXDK19397"></a><div class="props_rev_3"><a id="GUID-0DD4527B-DA4B-404D-B52C-15027C8C22BF" name="GUID-0DD4527B-DA4B-404D-B52C-15027C8C22BF"></a><h4 id="ADXDK-GUID-0DD4527B-DA4B-404D-B52C-15027C8C22BF" class="sect4">使用XSU：基本过程</h4>
                  <div>
                     <p>描述了使用XSU的基本过程。</p>
                     <div class="section">
                        <p>可以通过包含<code class="codeph">OracleXMLSave</code>包中的Java类<code class="codeph">OracleXML</code> <code class="codeph">Query</code>和<code class="codeph">OracleXMLSave</code>访问<code class="codeph">oracle.xml.sql.query</code> 。使用类<code class="codeph">OracleXMLQuery</code>生成从关系数据和XML类<code class="codeph">OracleXMLSave</code>执行DML。</p>
                        <p>您可以编写以下类型的XSU应用程序：</p>
                        <ul style="list-style-type:disc">
                           <li>
                              <p>在数据库内运行并访问内部XSU Java API的Java程序</p>
                           </li>
                           <li>
                              <p>在客户端上运行并访问客户端XSU Java API的Java程序</p>
                           </li>
                           <li>
                              <p>通过PL / SQL包访问XSU的PL / SQL程序</p>
                           </li>
                        </ul>
                     </div>
                     <!-- class="section" -->
                  </div><a id="ADXDK19399"></a><a id="ADXDK19398"></a><div class="props_rev_3"><a id="GUID-1B9C1372-3D9D-4628-8426-5C715225D616" name="GUID-1B9C1372-3D9D-4628-8426-5C715225D616"></a><h5 id="ADXDK-GUID-1B9C1372-3D9D-4628-8426-5C715225D616" class="sect5">使用XSU Java API生成XML：基本过程</h5>
                     <div>
                        <p><code class="codeph">OracleXMLQuery</code>类构成了XSU Java API的XML生成部分。</p>
                        <div class="section">
                           <p> <a href="using-XML-SQL-utility.html#GUID-1B9C1372-3D9D-4628-8426-5C715225D616__BABJAEAE">图21-1</a>显示了使用XSU生成XML的基本过程。</p>
                           <p><a href="using-XML-SQL-utility.html#GUID-1B9C1372-3D9D-4628-8426-5C715225D616__BABJAEAE">图21-1</a>中的基本步骤是：</p>
                           <div class="figure" id="GUID-1B9C1372-3D9D-4628-8426-5C715225D616__BABJAEAE">
                              <p class="titleinfigure">图21-1使用XSU生成XML</p><img src="img/adxdk032.gif" width="600" alt="下面是图21-1的描述" title="下面是图21-1的描述" longdesc="img_text/adxdk032.html"><br><a href="img_text/adxdk032.html">“图21-1使用XSU生成XML”的说明</a></div>
                           <!-- class="figure" -->
                        </div>
                        <!-- class="section" -->
                        <ol>
                           <li class="stepexpand"><span>创建与数据库的JDBC连接。通常，您与<code class="codeph">DriverManager</code>类建立连接，该类管理一组JDBC驱动程序。加载JDBC驱动程序后，调用<code class="codeph">getConnection()</code> 。当找到正确的驱动程序时，此方法返回表示数据库会话的<code class="codeph">Connection</code>对象。所有SQL语句都在此会话的上下文中执行。</span><div>
                                 <p>你有这些选择：</p>
                                 <ul style="list-style-type:disc">
                                    <li>
                                       <p>使用JDBC Oracle调用接口（OCI）驱动程序创建连接。此代码片段显示了此技术：</p><pre class="oac_no_warn" dir="ltr">//导入Oracle驱动程序类import oracle.jdbc。*; //加载Oracle JDBC驱动程序DriverManager.registerDriver（new oracle.jdbc。一个OracleDriver（））; //创建连接Connection conn = DriverManager.getConnection（“jdbc：oracle：oci：@”，“hr”，“ <span class="italic">password</span> ”）;</pre><p>上面的示例使用JDBC OCI驱动程序的默认连接。</p>
                                    </li>
                                 </ul>
                                 <ul style="list-style-type:disc">
                                    <li>
                                       <p>使用JDBC瘦驱动程序创建连接。瘦驱动程序是用纯Java编写的，可以从任何Java程序调用。此代码片段显示了此技术：</p><pre class="oac_no_warn" dir="ltr">Connection conn = DriverManager.getConnection（“jdbc：oracle：thin：@ dlsun489：1521：ORCL”，“hr”，“ <span class="italic">password</span> ”）;</pre><p>瘦驱动程序需要主机名（ <code class="codeph">dlsun489</code> ），端口号（1521）和Oracle系统标识符（SID） <code class="codeph">ORCL</code> 。数据库必须具有活动的传输控制协议/ Internet协议（TCP / IP）侦听器。
                                       </p>
                                    </li>
                                    <li>
                                       <p>使用服务器端内部JDBC驱动程序使用的默认连接。此驱动程序在默认会话和默认事务上下文中运行。您已连接到数据库;您的SQL操作是默认事务的一部分。因此，您不必注册驱动程序。创建<code class="codeph">Connection</code>对象：</p><pre class="oac_no_warn" dir="ltr">连接conn = new oracle.jdbc。OracleDriver（）。defaultConnection（）;</pre></li>
                                 </ul>
                                 <div class="infoboxnote" id="GUID-1B9C1372-3D9D-4628-8426-5C715225D616__GUID-66AED7BB-EAD2-4B70-AD5E-F296DF002103">
                                    <p class="notep1">注意：</p>
                                    <p><code class="codeph">OracleXMLDataSetExtJdbc</code>仅用于Oracle JDBC，而<code class="codeph">OracleXMLDataSetGenJdbc</code>用于非Oracle JDBC。这些类位于oracle.xml.sql.dataset包中。
                                    </p>
                                 </div>
                              </div>
                           </li>
                           <li class="stepexpand"><span>创建XML查询对象并为其分配SQL查询。您可以通过将SQL查询传递给构造函数来创建<code class="codeph">OracleXMLQuery</code>类实例，如以下示例所示：</span><div><pre class="oac_no_warn" dir="ltr">OracleXMLQuery qry = new OracleXMLQuery（conn，“SELECT * from EMPLOYEES”）;</pre></div>
                           </li>
                           <li class="stepexpand"><span>通过调用<code class="codeph">OracleXMLQuery</code>方法配置XML查询对象。此示例指定结果集中只包含20行：</span><div><pre class="oac_no_warn" dir="ltr">xmlQry.setMaxRows（20）;</pre></div>
                           </li>
                           <li class="stepexpand"><span>通过调用<code class="codeph">OracleXMLQuery</code>方法返回DOM对象或字符串。例如，获取DOM对象：</span><div><pre class="oac_no_warn" dir="ltr">XMLDocument domDoc =（XMLDocument）qry.getXMLDOM（）;</pre><p>获取一个字符串对象：</p><pre class="oac_no_warn" dir="ltr">String xmlString = qry.getXMLString（）;</pre></div>
                           </li>
                           <li class="stepexpand"><span>根据需要对字符串或DOM执行其他处理。</span><div>
                                 <div class="infoboxnotealso" id="GUID-1B9C1372-3D9D-4628-8426-5C715225D616__GUID-F77748C1-6B42-4BDC-8F91-042959F91653">
                                    <p class="notep1">也可以看看：</p>
                                    <ul style="list-style-type:disc">
                                       <li>
                                          <p><a href="../jjdev/Java-introduction.html#JJDEV01000" target="_blank"><span><cite>Oracle数据库Java开发人员指南</cite></span></a> ，了解Oracle JDBC</p>
                                       </li>
                                       <li>
                                          <p><a href="../jaxml/index.html" target="_blank"><span><cite>Oracle Database XML Java API参考</cite></span></a> ，了解<code class="codeph">OracleXMLQuery</code>方法</p>
                                       </li>
                                    </ul>
                                 </div>
                              </div>
                           </li>
                        </ol>
                     </div>
                  </div><a id="ADXDK19401"></a><a id="ADXDK19400"></a><div class="props_rev_3"><a id="GUID-24C29C76-152A-4609-AB5A-2C1DC2986CCB" name="GUID-24C29C76-152A-4609-AB5A-2C1DC2986CCB"></a><h5 id="ADXDK-GUID-24C29C76-152A-4609-AB5A-2C1DC2986CCB" class="sect5">使用XSU Java API执行DML：基本过程</h5>
                     <div>
                        <p>使用<code class="codeph">OracleXMLSave</code>类在数据库中插入，更新和删除XML。
                        </p>
                        <div class="section">
                           <p><a href="using-XML-SQL-utility.html#GUID-24C29C76-152A-4609-AB5A-2C1DC2986CCB__BABCEFEJ">图21-2</a>显示了基本过程。
                           </p>
                           <div class="figure" id="GUID-24C29C76-152A-4609-AB5A-2C1DC2986CCB__BABCEFEJ">
                              <p class="titleinfigure">图21-2使用XSU在数据库中存储XML</p><img src="img/adxdk013.gif" width="516" alt="下面是图21-2的描述" title="下面是图21-2的描述" longdesc="img_text/adxdk013.html"><br><a href="img_text/adxdk013.html">“图21-2使用XSU在数据库中存储XML”的描述</a></div>
                           <!-- class="figure" -->
                           <p><a href="using-XML-SQL-utility.html#GUID-24C29C76-152A-4609-AB5A-2C1DC2986CCB__BABCEFEJ">图21-2</a>中的基本步骤是：</p>
                           <ol>
                              <li>
                                 <p>创建与数据库的JDBC连接。此步骤<a href="using-XML-SQL-utility.html#GUID-1B9C1372-3D9D-4628-8426-5C715225D616" title="Class OracleXMLQuery makes up the XML generation part of the XSU Java API.">与使用XSU Java API生成XML中</a>描述的第一步相同<a href="using-XML-SQL-utility.html#GUID-1B9C1372-3D9D-4628-8426-5C715225D616" title="OracleXMLQuery类构成了XSU Java API的XML生成部分。">：基本过程</a> 。
                                 </p>
                              </li>
                              <li>
                                 <p>创建一个XML保存对象，并为其分配一个表，在该表上执行DML。将表或视图名称传递给构造函数，如以下示例所示：</p><pre class="oac_no_warn" dir="ltr">OracleXMLSave sav = new OracleXMLSave（conn，“employees”）;</pre></li>
                              <li>
                                 <p>指定主键列。例如，此代码指定<code class="codeph">employee_id</code>是键列：</p><pre class="oac_no_warn" dir="ltr">String [] keyColNames = new String [1]; keyColNames [0] =“EMPLOYEE_ID”; sav.setKeyColumnList（keyColNames）;</pre></li>
                              <li>
                                 <p>通过调用<code class="codeph">OracleXMLSave</code>方法配置XML保存对象。此示例指定<code class="codeph">salary</code>和<code class="codeph">job_id</code>列的更新：</p><pre class="oac_no_warn" dir="ltr">String [] updateColNames = new String [2]; updateColNames [0] =“SALARY”; updateColNames [1] =“JOB_ID”; sav.setUpdateColumnList（updateColNames）; //设置要更新的列</pre></li>
                              <li>
                                 <p>在<code class="codeph">OracleXMLSave</code>对象上调用<code class="codeph">insertXML()</code> ， <code class="codeph">updateXML()</code>或<code class="codeph">deleteXML()</code>方法。此示例显示更新：</p><pre class="oac_no_warn" dir="ltr">//假设用户传入此XML文档作为第一个参数sav.updateXML（sav.getURL（argv [0]））;</pre><p>执行DML时，XSU执行以下任务：</p>
                                 <ol type="a">
                                    <li>
                                       <p>解析输入XML文档。</p>
                                    </li>
                                    <li>
                                       <p>将元素名称与目标表或视图中的列名匹配。</p>
                                    </li>
                                    <li>
                                       <p>将元素转换为SQL类型并将它们绑定到适当的语句。</p>
                                    </li>
                                 </ol>
                              </li>
                              <li>
                                 <p>关闭<code class="codeph">OracleXMLSave</code>对象并释放与其关联的所有上下文，如以下示例所示：</p><pre class="oac_no_warn" dir="ltr">sav.close（）;</pre><div class="infoboxnotealso" id="GUID-24C29C76-152A-4609-AB5A-2C1DC2986CCB__GUID-0CA94A29-CD03-4C25-A2E6-EF3D4DEB4A80">
                                    <p class="notep1">也可以看看：</p>
                                    <ul style="list-style-type:disc">
                                       <li>
                                          <p><a href="../jjdev/Java-introduction.html#JJDEV01000" target="_blank"><span><cite>Oracle数据库Java开发人员指南</cite></span></a> ，了解JDBC</p>
                                       </li>
                                       <li>
                                          <p><a href="../jaxml/index.html" target="_blank"><span><cite>Oracle Database XML Java API参考</cite></span></a> ，了解<code class="codeph">OracleXMLSave</code></p>
                                       </li>
                                    </ul>
                                 </div>
                              </li>
                           </ol>
                        </div>
                        <!-- class="section" -->
                     </div>
                  </div>
               </div><a id="ADXDK19404"></a><div class="props_rev_3"><a id="GUID-2BEECD17-A1B8-40F0-9363-CED111CAE8A2" name="GUID-2BEECD17-A1B8-40F0-9363-CED111CAE8A2"></a><h4 id="ADXDK-GUID-2BEECD17-A1B8-40F0-9363-CED111CAE8A2" class="sect4">安装XSU</h4>
                  <div>
                     <p>XSU作为Oracle数据库的一部分以及其他XDK实用程序包含在内。</p>
                     <div class="section">
                        <p><a href="getting-started-with-XDK-for-Java.html#GUID-D26168D9-2F21-4B5A-9F7B-F1D4B66F0EB4" title="描述了使用Java Development Kit（JDK）时XDK对Java组件的依赖性。">XDK for Java组件依赖关系</a>描述了XSU组件和依赖关系。
                        </p>
                        <p>默认情况下，Oracle Universal Installer会在磁盘上安装XSU并将其加载到数据库中。无需用户干预。如果在安装Oracle时未在数据库中加载XSU，则可以按如下方式手动安装XSU：</p>
                     </div>
                     <!-- class="section" -->
                     <ol>
                        <li><span>确保已安装Oracle XML DB（默认情况下，它是作为Oracle数据库的一部分安装的）。</span></li>
                        <li><span>将<code class="codeph">xsu12.jar</code>文件加载到数据库中。<a href="getting-started-with-XDK-for-Java.html#GUID-D26168D9-2F21-4B5A-9F7B-F1D4B66F0EB4__BACCJCEA" title="组件，库和Notes是列。">表11-1中</a>描述了此JAR文件，该文件依赖于<code class="codeph">xdb.jar</code>进行<code class="codeph">XMLType</code>访问。</span></li>
                        <li><span>运行<code class="codeph">$ORACLE_HOME/rdbms/admin/dbmsxsu.sql</code>脚本。此SQL脚本构建XSU PL / SQL API。</span></li>
                     </ol>
                     <div class="section">
                        <p>如<a href="using-XML-SQL-utility.html#GUID-0DD4527B-DA4B-404D-B52C-15027C8C22BF" title="描述了使用XSU的基本过程。">使用XSU：Basic Process中所述</a> ，您不必将XSU加载到数据库中即可使用它。XSU可以驻留在支持Java的任何层中。
                        </p> 
                     </div>
                     <!-- class="section" -->
                  </div><a id="ADXDK19406"></a><a id="ADXDK19405"></a><div class="props_rev_3"><a id="GUID-87BA0272-6037-4262-98DA-6BB40FAF2BAF" name="GUID-87BA0272-6037-4262-98DA-6BB40FAF2BAF"></a><h5 id="ADXDK-GUID-87BA0272-6037-4262-98DA-6BB40FAF2BAF" class="sect5">数据库中的XSU</h5>
                     <div>
                        <p>显示了使用数据库中安装的XSU库的应用程序的典型体系结构。</p>
                        <p><a href="using-XML-SQL-utility.html#GUID-87BA0272-6037-4262-98DA-6BB40FAF2BAF__BABFHEJD">图21-3</a>说明了这种典型架构。从数据库中运行的XSU生成的XML可以放在数据库中的高级队列中，以排队到其他系统或客户端。您通过数据库中的存储过程或通过Web服务器或应用程序服务器在外部交付XML。
                        </p>
                        <p>在<a href="using-XML-SQL-utility.html#GUID-87BA0272-6037-4262-98DA-6BB40FAF2BAF__BABFHEJD">图21-3中，</a>所有行都是双向的。由于XSU可以生成和保存数据，因此资源可以将XML传送到在数据库内运行的XSU，然后可以将其插入相应的数据库表中。
                        </p>
                        <div class="figure" id="GUID-87BA0272-6037-4262-98DA-6BB40FAF2BAF__BABFHEJD">
                           <p class="titleinfigure">图21-3在数据库中运行XSU</p><img src="img/adxdk018.gif" width="600" alt="下面是图21-3的描述" title="下面是图21-3的描述" longdesc="img_text/adxdk018.html"><br><a href="img_text/adxdk018.html">“图21-3在数据库中运行XSU”的描述</a></div>
                        <!-- class="figure" -->
                     </div>
                  </div><a id="ADXDK19408"></a><a id="ADXDK19407"></a><div class="props_rev_3"><a id="GUID-E7494F31-25A2-49A9-9631-24F872DAC692" name="GUID-E7494F31-25A2-49A9-9631-24F872DAC692"></a><h5 id="ADXDK-GUID-E7494F31-25A2-49A9-9631-24F872DAC692" class="sect5">应用程序服务器中的XSU</h5>
                     <div>
                        <p>您可以在应用程序服务器中运行XSU。</p>
                        <p>您的应用程序体系结构可能需要中间层的应用程序服务器。应用程序层可以是支持Java程序的数据库或应用程序服务器。</p>
                        <p>您可以出于各种原因从SQL查询或<code class="codeph">ResultSets</code>中生成中间层的XML，例如，在中间层中集成不同的JDBC数据源。在这种情况下，您可以在中间层安装XSU，从而使您的Java程序能够通过其Java API使用XSU。</p>
                        <p><a href="using-XML-SQL-utility.html#GUID-E7494F31-25A2-49A9-9631-24F872DAC692__BABIGADF">图21-4</a>显示了在中间层运行XSU的典型体系结构。在中间层，来自JDBC源的数据由XSU转换为XML，然后发送到Web服务器或其他系统。同样，该过程是双向的，这意味着可以使用XSU将数据放回JDBC源（数据库表或视图）。如果将数据库用作应用程序服务器，则可以使用PL / SQL前端而不是Java。
                        </p>
                        <div class="figure" id="GUID-E7494F31-25A2-49A9-9631-24F872DAC692__BABIGADF">
                           <p class="titleinfigure">图21-4在中间层运行XSU</p><img src="img/adxdk019.gif" width="592" alt="下面是图21-4的描述" title="下面是图21-4的描述" longdesc="img_text/adxdk019.html"><br><a href="img_text/adxdk019.html">“图21-4在中间层运行XSU”的描述</a></div>
                        <!-- class="figure" -->
                     </div>
                  </div><a id="ADXDK19410"></a><a id="ADXDK19409"></a><div class="props_rev_3"><a id="GUID-AB070D7C-D012-4B0B-8DF9-4ABA55EB6026" name="GUID-AB070D7C-D012-4B0B-8DF9-4ABA55EB6026"></a><h5 id="ADXDK-GUID-AB070D7C-D012-4B0B-8DF9-4ABA55EB6026" class="sect5">Web服务器中的XSU</h5>
                     <div>
                        <p>您可以在Web服务器中运行XSU，因为Web服务器支持Java servlet。</p>
                        <p><a href="using-XML-SQL-utility.html#GUID-AB070D7C-D012-4B0B-8DF9-4ABA55EB6026__BABEHFAH">图21-5</a>显示了在Web服务器中运行的<a href="using-XML-SQL-utility.html#GUID-AB070D7C-D012-4B0B-8DF9-4ABA55EB6026__BABEHFAH">XSU</a> 。
                        </p>
                        <div class="figure" id="GUID-AB070D7C-D012-4B0B-8DF9-4ABA55EB6026__BABEHFAH">
                           <p class="titleinfigure">图21-5在Web服务器中运行XSU</p><img src="img/adxdk020.gif" width="600" alt="下面是图21-5的描述" title="下面是图21-5的描述" longdesc="img_text/adxdk020.html"><br><a href="img_text/adxdk020.html">“图21-5在Web服务器中运行XSU”的说明</a></div>
                        <!-- class="figure" -->
                        <p>您可以编写使用XSU的Java servlet。 XSQL Servlet是Oracle提供的标准servlet。它建立在XSU之上，为XSU功能提供了类似模板的界面。要在Web服务器中执行XML处理并避免复杂的servlet编程，可以使用XSQL Servlet。</p>
                        <div class="infoboxnotealso" id="GUID-AB070D7C-D012-4B0B-8DF9-4ABA55EB6026__GUID-8F34D0AF-4079-4B84-91FE-CE242F74ED93">
                           <p class="notep1">也可以看看：</p>
                           <ul style="list-style-type:disc">
                              <li>
                                 <p><a href="../adxdb/generation-of-XML-data-from-relational-data.html#ADXDB1600" target="_blank"><span><cite>Oracle XML DB Developer's Guide</cite></span></a> ，特别是关于生成XML的章节，以及使用XSU和<code class="codeph">XMLType</code>示例</p>
                              </li>
                              <li>
                                 <p><a href="../jaxml/index.html" target="_blank"><span><cite>Oracle Database XML Java API参考</cite></span></a> ，了解<code class="codeph">OracleXMLQuery</code>和<code class="codeph">OracleXMLSave</code>类</p>
                              </li>
                              <li>
                                 <p><a href="using-XSQL-pages-publishing-framework.html#GUID-A1834D2F-B962-4881-AE7A-F323FF11384D" title="下面介绍如何使用XSQL页面发布框架的基本功能。">使用XSQL Pages Publishing Framework</a>了解XSQL Servlet</p>
                              </li>
                           </ul>
                        </div>
                     </div>
                  </div>
               </div><a id="ADXDK19412"></a><a id="ADXDK19411"></a><div class="props_rev_3"><a id="GUID-DBFFD584-82E8-45F8-82F0-E1BFFE6BC162" name="GUID-DBFFD584-82E8-45F8-82F0-E1BFFE6BC162"></a><h4 id="ADXDK-GUID-DBFFD584-82E8-45F8-82F0-E1BFFE6BC162" class="sect4">运行XSU演示程序</h4>
                  <div>
                     <p><code class="codeph">$ORACLE_HOME/xdk/demo/java/xsu</code>演示程序包含在<code class="codeph">$ORACLE_HOME/xdk/demo/java/xsu</code> 。
                     </p>
                     <div class="section">
                        <p><a href="using-XML-SQL-utility.html#GUID-DBFFD584-82E8-45F8-82F0-E1BFFE6BC162__BABICEIE" title="此表描述了可用于测试XSU的XML文件和程序。文件和描述是列。">表21-1</a>介绍了可用于测试XSU的XML文件和程序。</p>
                        <div class="tblformalwide" id="GUID-DBFFD584-82E8-45F8-82F0-E1BFFE6BC162__BABICEIE">
                           <p class="titleintable">表21-1 XSU示例文件</p>
                           <table cellpadding="4" cellspacing="0" class="FormalWide" title="XSU示例文件" width="100%" border="1" summary="This table describes the XML files and programs that you can use to test XSU. File and Description are the Columns." frame="hsides" rules="rows">
                              <thead>
                                 <tr align="left" valign="top">
                                    <th align="left" valign="bottom" width="33%" id="d77774e1636">文件</th>
                                    <th align="left" valign="bottom" width="67%" id="d77774e1639">描述</th>
                                 </tr>
                              </thead>
                              <tbody>
                                 <tr align="left" valign="top">
                                    <td align="left" valign="top" width="33%" id="d77774e1644" headers="d77774e1636 ">
                                       <p><code class="codeph">createObjRelSchema.sql</code></p>
                                    </td>
                                    <td align="left" valign="top" width="67%" headers="d77774e1644 d77774e1639 ">
                                       <p>一个SQL脚本，用于设置对象关系模式并填充它。请参阅<a href="using-XML-SQL-utility.html#GUID-A0899DAA-0B1D-482C-99E6-E995F2B535C8" title="XSU可以从对象关系模式生成XML文档。">针对对象关系模式的XML映射</a> 。
                                       </p>
                                    </td>
                                 </tr>
                                 <tr align="left" valign="top">
                                    <td align="left" valign="top" width="33%" id="d77774e1658" headers="d77774e1636 ">
                                       <p><code class="codeph">createObjRelSchema2.sql</code></p>
                                    </td>
                                    <td align="left" valign="top" width="67%" headers="d77774e1658 d77774e1639 ">
                                       <p>一个SQL脚本，用于设置对象关系模式并填充它。请参阅<a href="using-XML-SQL-utility.html#GUID-9BD36D83-085B-418B-AA50-1A01E3322D41" title="您可以通过更改SQL查询或数据库架构来执行源自定义。">更改数据库架构或SQL查询</a> 。
                                       </p>
                                    </td>
                                 </tr>
                                 <tr align="left" valign="top">
                                    <td align="left" valign="top" width="33%" id="d77774e1672" headers="d77774e1636 ">
                                       <p><code class="codeph">createRelSchema.sql</code></p>
                                    </td>
                                    <td align="left" valign="top" width="67%" headers="d77774e1672 d77774e1639 ">
                                       <p>一个SQL脚本，用于创建关系表，然后创建一个包含客户对象的客户视图。请参阅<a href="using-XML-SQL-utility.html#GUID-9BD36D83-085B-418B-AA50-1A01E3322D41" title="您可以通过更改SQL查询或数据库架构来执行源自定义。">更改数据库架构或SQL查询</a> 。
                                       </p>
                                    </td>
                                 </tr>
                                 <tr align="left" valign="top">
                                    <td align="left" valign="top" width="33%" id="d77774e1686" headers="d77774e1636 ">
                                       <p><code class="codeph">customer.xml</code></p>
                                    </td>
                                    <td align="left" valign="top" width="67%" headers="d77774e1686 d77774e1639 ">
                                       <p>描述客户的XML文档。请参阅<a href="using-XML-SQL-utility.html#GUID-9BD36D83-085B-418B-AA50-1A01E3322D41" title="您可以通过更改SQL查询或数据库架构来执行源自定义。">更改数据库架构或SQL查询</a> 。
                                       </p>
                                    </td>
                                 </tr>
                                 <tr align="left" valign="top">
                                    <td align="left" valign="top" width="33%" id="d77774e1700" headers="d77774e1636 ">
                                       <p><code class="codeph">domTest.java</code></p>
                                    </td>
                                    <td align="left" valign="top" width="67%" headers="d77774e1700 d77774e1639 ">
                                       <p>生成DOM树然后按文档顺序遍历它的程序，逐个打印节点。请参阅<a href="using-XML-SQL-utility.html#GUID-3839ED46-BD8B-4069-972A-DEBB031C6F57" title="要从XSU生成的XML生成DOM树，您可以直接从XSU请求DOM文档。此技术节省了创建XML文档的字符串表示的开销，然后解析它以生成DOM树。">使用OracleXMLQuery生成DOM树</a> 。
                                       </p>
                                    </td>
                                 </tr>
                                 <tr align="left" valign="top">
                                    <td align="left" valign="top" width="33%" id="d77774e1714" headers="d77774e1636 ">
                                       <p><code class="codeph">index.txt</code></p>
                                    </td>
                                    <td align="left" valign="top" width="67%" headers="d77774e1714 d77774e1639 ">
                                       <p>描述演示目录中程序的自述文件。</p>
                                    </td>
                                 </tr>
                                 <tr align="left" valign="top">
                                    <td align="left" valign="top" width="33%" id="d77774e1722" headers="d77774e1636 ">
                                       <p><code class="codeph">mapColumnToAtt.sql</code></p>
                                    </td>
                                    <td align="left" valign="top" width="67%" headers="d77774e1722 d77774e1639 ">
                                       <p>SQL脚本，查询<code class="codeph">employees</code>表，绘制<code class="codeph">employee_id</code>作为XML属性。请参阅<a href="using-XML-SQL-utility.html#GUID-9BD36D83-085B-418B-AA50-1A01E3322D41" title="您可以通过更改SQL查询或数据库架构来执行源自定义。">更改数据库架构或SQL查询</a> 。
                                       </p>
                                    </td>
                                 </tr>
                                 <tr align="left" valign="top">
                                    <td align="left" valign="top" width="33%" id="d77774e1742" headers="d77774e1636 ">
                                       <p><code class="codeph">new_emp.xml</code></p>
                                    </td>
                                    <td align="left" valign="top" width="67%" headers="d77774e1742 d77774e1639 ">
                                       <p>描述新员工的XML文档。请参阅<a href="using-XML-SQL-utility.html#GUID-D005B919-A669-4BF9-A22A-2F75ECE3B82D" title="描述了textInsert程序。">运行testInsert程序</a> 。
                                       </p>
                                    </td>
                                 </tr>
                                 <tr align="left" valign="top">
                                    <td align="left" valign="top" width="33%" id="d77774e1759" headers="d77774e1636 ">
                                       <p><code class="codeph">new_emp2.xml</code></p>
                                    </td>
                                    <td align="left" valign="top" width="67%" headers="d77774e1759 d77774e1639 ">
                                       <p>描述新员工的XML文档。请参阅<a href="using-XML-SQL-utility.html#GUID-ACDEFAC1-46BE-4363-90C4-027897AD1AD9" title="描述了testInsertSubset程序。">运行testInsertSubset程序</a> 。
                                       </p>
                                    </td>
                                 </tr>
                                 <tr align="left" valign="top">
                                    <td align="left" valign="top" width="33%" id="d77774e1776" headers="d77774e1636 ">
                                       <p><code class="codeph">noRowsTest.java</code></p>
                                    </td>
                                    <td align="left" valign="top" width="67%" headers="d77774e1776 d77774e1639 ">
                                       <p>在没有更多行时抛出异常的程序。请参阅<a href="using-XML-SQL-utility.html#GUID-4F096761-00BB-4A94-9368-F91C7ACA9D2C" title="当没有要处理的行时，XSU返回一个空字符串。但是，每次没有更多行时，您可以抛出异常，以便程序可以使用异常处理程序处理此异常。">提出无行例外</a> 。
                                       </p>
                                    </td>
                                 </tr>
                                 <tr align="left" valign="top">
                                    <td align="left" valign="top" width="33%" id="d77774e1793" headers="d77774e1636 ">
                                       <p><code class="codeph">pageTest.java</code></p>
                                    </td>
                                    <td align="left" valign="top" width="67%" headers="d77774e1793 d77774e1639 ">
                                       <p>一个程序，它使用JDBC <code class="codeph">ResultSet</code>生成一页XML。请参阅<a href="using-XML-SQL-utility.html#GUID-788FD888-45E4-4B7F-91CD-0151398196CF" title="您可能希望执行查询，然后从结果集中检索上一页结果。要启用滚动，请实例化Oracle.jdbc。ResultSet类。您可以使用ResultSet对象在结果集中来回移动，并使用XSU每次生成XML。">生成可滚动结果集</a> 。
                                       </p>
                                    </td>
                                 </tr>
                                 <tr align="left" valign="top">
                                    <td align="left" valign="top" width="33%" id="d77774e1817" headers="d77774e1636 ">
                                       <p><code class="codeph">paginateResults.java</code></p>
                                    </td>
                                    <td align="left" valign="top" width="67%" headers="d77774e1817 d77774e1639 ">
                                       <p>生成分页结果的XML页面的程序。请参阅<a href="using-XML-SQL-utility.html#GUID-790B346F-11A5-493A-B34A-E972069F95EC" title="paginateResults.java程序显示了如何生成分页结果的XML页面。输出XML仅显示hr表的20行。">使用OracleXMLQuery分页结果：示例</a> 。
                                       </p>
                                    </td>
                                 </tr>
                                 <tr align="left" valign="top">
                                    <td align="left" valign="top" width="33%" id="d77774e1837" headers="d77774e1636 ">
                                       <p><code class="codeph">refCurTest.java</code></p>
                                    </td>
                                    <td align="left" valign="top" width="67%" headers="d77774e1837 d77774e1639 ">
                                       <p>一种程序，它根据<code class="codeph">testRefCur</code>函数中定义的SQL查询的结果生成XML。请参阅<a href="using-XML-SQL-utility.html#GUID-B77E1941-0B4C-4B73-8EBC-25357E3DA75C" title="您可以初始化CallableStatement对象，执行返回游标变量的PL / SQL函数，获取OracleResultSet对象，并将其发送到OracleXMLQuery对象以获取所需的XML数据。">从游标对象生成XML</a> 。
                                       </p>
                                    </td>
                                 </tr>
                                 <tr align="left" valign="top">
                                    <td align="left" valign="top" width="33%" id="d77774e1863" headers="d77774e1636 ">
                                       <p><code class="codeph">samp1.java</code></p>
                                    </td>
                                    <td align="left" valign="top" width="67%" headers="d77774e1863 d77774e1639 ">
                                       <p>查询<code class="codeph">scott.emp</code>表的程序，然后从查询结果中生成XML文档。
                                       </p>
                                    </td>
                                 </tr>
                                 <tr align="left" valign="top">
                                    <td align="left" valign="top" width="33%" id="d77774e1874" headers="d77774e1636 ">
                                       <p><code class="codeph">samp10.java</code></p>
                                    </td>
                                    <td align="left" valign="top" width="67%" headers="d77774e1874 d77774e1639 ">
                                       <p>该插入的程序<code class="codeph">sampdoc.xml</code>到<code class="codeph">xmltest_tab1</code>表。
                                       </p>
                                    </td>
                                 </tr>
                                 <tr align="left" valign="top">
                                    <td align="left" valign="top" width="33%" id="d77774e1888" headers="d77774e1636 ">
                                       <p><code class="codeph">samp2.java</code></p>
                                    </td>
                                    <td align="left" valign="top" width="67%" headers="d77774e1888 d77774e1639 ">
                                       <p>查询<code class="codeph">scott.emp</code>表的程序，然后从查询结果中生成XML文档。该程序演示了如何自定义生成的XML文档。
                                       </p>
                                    </td>
                                 </tr>
                                 <tr align="left" valign="top">
                                    <td align="left" valign="top" width="33%" id="d77774e1899" headers="d77774e1636 ">
                                       <p><code class="codeph">sampdoc.xml</code></p>
                                    </td>
                                    <td align="left" valign="top" width="67%" headers="d77774e1899 d77774e1639 ">
                                       <p><code class="codeph">samp10.java</code>插入数据库的示例XML数据文档。
                                       </p>
                                    </td>
                                 </tr>
                                 <tr align="left" valign="top">
                                    <td align="left" valign="top" width="33%" id="d77774e1910" headers="d77774e1636 ">
                                       <p><code class="codeph">samps.sql</code></p>
                                    </td>
                                    <td align="left" valign="top" width="67%" headers="d77774e1910 d77774e1639 ">
                                       <p>SQL脚本，创建<code class="codeph">xmltest_tab1</code>通过使用表<code class="codeph">samp10.java</code> 。
                                       </p>
                                    </td>
                                 </tr>
                                 <tr align="left" valign="top">
                                    <td align="left" valign="top" width="33%" id="d77774e1924" headers="d77774e1636 ">
                                       <p><code class="codeph">testDeleteKey.java</code></p>
                                    </td>
                                    <td align="left" valign="top" width="67%" headers="d77774e1924 d77774e1639 ">
                                       <p>一个程序，用于限制用于标识行的元素数，通过缓存<code class="codeph">DELETE</code>语句和批处理事务来提高性能。请参阅<a href="using-XML-SQL-utility.html#GUID-2D3D2A64-0291-4D19-9783-4BD518C8E95D" title="要仅将键值用作DELETE语句的谓词，请调用OracleXMLSave.setKeyColumnList（）方法。此方法限制用于标识行的元素数，这有利于通过缓存DELETE语句和批处理事务来提高性能。testDeleteKey.java程序显示了这种技术。">使用OracleXMLSave按键删除</a> 。
                                       </p>
                                    </td>
                                 </tr>
                                 <tr align="left" valign="top">
                                    <td align="left" valign="top" width="33%" id="d77774e1953" headers="d77774e1636 ">
                                       <p><code class="codeph">testDeleteRow.java</code></p>
                                    </td>
                                    <td align="left" valign="top" width="67%" headers="d77774e1953 d77774e1639 ">
                                       <p>接受XML文档文件名作为输入的程序，并删除与文档中的元素对应的行。请参见<a href="using-XML-SQL-utility.html#GUID-FD22DD32-C1F3-475E-8F5C-A735E2DC6FFE" title="testDeleteRow.java演示程序接受XML文档文件名作为输入，并删除与文档中元素对应的行。">使用OracleXMLSave按行删除</a> 。
                                       </p>
                                    </td>
                                 </tr>
                                 <tr align="left" valign="top">
                                    <td align="left" valign="top" width="33%" id="d77774e1970" headers="d77774e1636 ">
                                       <p><code class="codeph">testException.java</code></p>
                                    </td>
                                    <td align="left" valign="top" width="67%" headers="d77774e1970 d77774e1639 ">
                                       <p>显示的示例程序抛出运行时异常，然后通过调用<code class="codeph">Exception.getParentException()</code>获取父异常。请参阅<a href="using-XML-SQL-utility.html#GUID-3184503E-9C0D-4DFF-984E-5D1C6512AA42" title="testException.java演示程序抛出运行时异常，然后通过调用Exception.getParentException（）获取父异常。">获取父级例外</a> 。
                                       </p>
                                    </td>
                                 </tr>
                                 <tr align="left" valign="top">
                                    <td align="left" valign="top" width="33%" id="d77774e1993" headers="d77774e1636 ">
                                       <p><code class="codeph">testInsert.java</code></p>
                                    </td>
                                    <td align="left" valign="top" width="67%" headers="d77774e1993 d77774e1639 ">
                                       <p>一种Java程序，它将XML值插入<code class="codeph">hr.employees</code>表的所有列。请参阅<a href="using-XML-SQL-utility.html#GUID-FBDEFAFC-567F-48C5-85F1-B33680A85CA0" title="testInsert.java演示程序将XML值插入hr.employees表的所有列。">使用OracleXMLSave将XML插入所有列</a> 。
                                       </p>
                                    </td>
                                 </tr>
                                 <tr align="left" valign="top">
                                    <td align="left" valign="top" width="33%" id="d77774e2017" headers="d77774e1636 ">
                                       <p><code class="codeph">testInsertSubset.java</code></p>
                                    </td>
                                    <td align="left" valign="top" width="67%" headers="d77774e2017 d77774e1639 ">
                                       <p>显示的程序将XML数据插入到列的子集中。请参阅<a href="using-XML-SQL-utility.html#GUID-220FC06C-0D3F-427D-ACEC-B37753B43189" title="在某些情况下，您可能不希望将值插入所有列。例如，您获得的值组可能不是完整集，要求您对其余列使用触发器或默认值。">使用OracleXMLSave将XML插入到列的子集中</a> 。
                                       </p>
                                    </td>
                                 </tr>
                                 <tr align="left" valign="top">
                                    <td align="left" valign="top" width="33%" id="d77774e2031" headers="d77774e1636 ">
                                       <p><code class="codeph">testRef.sql</code></p>
                                    </td>
                                    <td align="left" valign="top" width="67%" headers="d77774e2031 d77774e1639 ">
                                       <p>一个PL / SQL脚本，它创建一个定义REF游标并返回它的函数。每次调用<code class="codeph">testRefCur</code>函数时，它都会打开<code class="codeph">SELECT</code>查询的游标对象并返回该游标实例。请参阅<a href="using-XML-SQL-utility.html#GUID-B77E1941-0B4C-4B73-8EBC-25357E3DA75C" title="您可以初始化CallableStatement对象，执行返回游标变量的PL / SQL函数，获取OracleResultSet对象，并将其发送到OracleXMLQuery对象以获取所需的XML数据。">从游标对象生成XML</a> 。
                                       </p>
                                    </td>
                                 </tr>
                                 <tr align="left" valign="top">
                                    <td align="left" valign="top" width="33%" id="d77774e2060" headers="d77774e1636 ">
                                       <p><code class="codeph">testUpdate.java</code></p>
                                    </td>
                                    <td align="left" valign="top" width="67%" headers="d77774e2060 d77774e1639 ">
                                       <p>通过调用<code class="codeph">OracleXMLSave.setKeyColumnList()</code>方法更新<code class="codeph">hr.employees</code>表的示例程序。请参阅<a href="using-XML-SQL-utility.html#GUID-646799B4-73D6-4AD1-94F1-E614343D65F6" title="示例显示如何更新表或视图中的字段。您提供表或视图名称和XML文档。XSU解析文档（如果给出了字符串）并创建一个或多个UPDATE语句，它将所有值绑定到该语句中。">使用OracleXMLSave更新行</a> 。
                                       </p>
                                    </td>
                                 </tr>
                                 <tr align="left" valign="top">
                                    <td align="left" valign="top" width="33%" id="d77774e2083" headers="d77774e1636 ">
                                       <p><code class="codeph">testUpdateList.java</code></p>
                                    </td>
                                    <td align="left" valign="top" width="67%" headers="d77774e2083 d77774e1639 ">
                                       <p>假设您只想更新每个员工的薪水和职称，并忽略其他信息。如果您知道要更新的所有元素对于XML文档中的所有<code class="codeph">ROW</code>元素都是相同的，那么您可以使用<code class="codeph">OracleXMLSave.setUpdateColumnNames()</code>方法来指定列。请参阅<a href="using-XML-SQL-utility.html#GUID-BF4F12F6-1EC7-4B6D-BEEC-A9D9D5816D8B">使用OracleXMLSave更新列列表</a> 。
                                       </p>
                                    </td>
                                 </tr>
                                 <tr align="left" valign="top">
                                    <td align="left" valign="top" width="33%" id="d77774e2102" headers="d77774e1636 ">
                                       <p><code class="codeph">testXMLSQL.java</code></p>
                                    </td>
                                    <td align="left" valign="top" width="67%" headers="d77774e2102 d77774e1639 ">
                                       <p>使用XSU生成XML作为<code class="codeph">String</code>对象的示例程序。该程序查询<code class="codeph">hr.employees</code>表并将结果集打印到标准输出。请参阅<a href="using-XML-SQL-utility.html#GUID-40A59B26-5039-45FB-BCC0-6C886C573E80" title="testXMLSQL.java演示程序使用XSU生成XML作为String对象。程序查询表hr.employees并将结果集打印到标准输出。">使用OracleXMLQuery生成字符串</a> 。
                                       </p>
                                    </td>
                                 </tr>
                                 <tr align="left" valign="top">
                                    <td align="left" valign="top" width="33%" id="d77774e2131" headers="d77774e1636 ">
                                       <p><code class="codeph">upd_emp.xml</code></p>
                                    </td>
                                    <td align="left" valign="top" width="67%" headers="d77774e2131 d77774e1639 ">
                                       <p>包含一系列员工的更新薪水和其他信息的XML文档。请参阅<a href="using-XML-SQL-utility.html#GUID-E1F2B493-A35D-4069-AE61-310538FA2FF0" title="描述了testUpdate程序。">运行testUpdate程序</a> 。
                                       </p>
                                    </td>
                                 </tr>
                                 <tr align="left" valign="top">
                                    <td align="left" valign="top" width="33%" id="d77774e2148" headers="d77774e1636 ">
                                       <p><code class="codeph">upd_emp2.xml</code></p>
                                    </td>
                                    <td align="left" valign="top" width="67%" headers="d77774e2148 d77774e1639 ">
                                       <p>包含一系列员工的更新薪水和其他信息的XML文档。请参阅<a href="using-XML-SQL-utility.html#GUID-E1F2B493-A35D-4069-AE61-310538FA2FF0" title="描述了testUpdate程序。">运行testUpdate程序</a> 。
                                       </p>
                                    </td>
                                 </tr>
                                 <tr align="left" valign="top">
                                    <td align="left" valign="top" width="33%" id="d77774e2165" headers="d77774e1636 ">
                                       <p><code class="codeph">updateEmployee.sql</code></p>
                                    </td>
                                    <td align="left" valign="top" width="67%" headers="d77774e2165 d77774e1639 ">
                                       <p>包含两名员工的新数据的XML文档。请参阅<a href="using-XML-SQL-utility.html#GUID-F631E856-2DF4-4926-90AA-BFF97840F90F" title="描述了testUpdateList程序。">运行testUpdateList程序</a> 。
                                       </p>
                                    </td>
                                 </tr>
                              </tbody>
                           </table>
                        </div>
                        <!-- class="inftblhruleinformal" -->
                        <p>运行演示的步骤如下：</p>
                     </div>
                     <!-- class="section" -->
                     <ol>
                        <li class="stepexpand"><span>切换到<code class="codeph">$ORACLE_HOME/xdk/demo/java/xsu</code>目录（UNIX）或<code class="codeph">%ORACLE_HOME%\xdk\demo\java\xsu</code>目录（Windows）。</span></li>
                        <li class="stepexpand"><span>确保按照<a href="getting-started-with-XDK-for-Java.html#GUID-EA5DB831-1D91-453A-AF7B-7B55343B1720" title="You can set up the XDK for Java environment using either an environment variable or a command-line option.">设置XDK for Java环境中的</a>描述<a href="getting-started-with-XDK-for-Java.html#GUID-EA5DB831-1D91-453A-AF7B-7B55343B1720" title="您可以使用环境变量或命令行选项设置XDK for Java环境。">设置</a>环境变量。特别是，确保Java类路径包含<code class="codeph">xsu12.jar</code>和JDBC的<code class="codeph">ojdbc6.jar</code> （Java 1.6）。如果使用UTF-8，ISO8859-1或JA16SJIS以外的多字节字符集，则将<code class="codeph">orai18n.jar</code>放在类路径中，以便JDBC可以将输入文件的字符集转换为数据库字符集。</span></li>
                        <li class="stepexpand"><span>编译Java程序，如下例所示：</span><div><pre class="oac_no_warn" dir="ltr">javac samp1.java samp2.java samp10.java</pre></div>
                        </li>
                        <li class="stepexpand"><span>以用户<code class="codeph">hr</code>连接到数据库并运行SQL脚本<code class="codeph">createRelSchema</code> ：</span><div><pre class="oac_no_warn" dir="ltr">CONNECT hr @ $ ORACLE_HOME / xdk / demo / java / xsu / createRelSchema</pre></div>
                        </li>
                     </ol>
                     <div class="section">
                        <p>这些部分详细介绍了XSU演示。</p>
                     </div>
                     <!-- class="section" -->
                  </div>
               </div><a id="ADXDK19414"></a><a id="ADXDK19415"></a><a id="ADXDK19413"></a><div class="props_rev_3"><a id="GUID-939256D1-157F-4736-B74D-3288C60A3069" name="GUID-939256D1-157F-4736-B74D-3288C60A3069"></a><h4 id="ADXDK-GUID-939256D1-157F-4736-B74D-3288C60A3069" class="sect4">使用XSU命令行实用程序</h4>
                  <div>
                     <p>XDK包含XSU的命令行Java接口。 XSU命令行选项通过Java类<code class="codeph">OracleXML</code> 。</p>
                     <div class="section">
                        <p>要使用此API，请确保按照<a href="getting-started-with-XDK-for-Java.html#GUID-EA5DB831-1D91-453A-AF7B-7B55343B1720" title="You can set up the XDK for Java environment using either an environment variable or a command-line option.">设置XDK for Java环境</a>中的说明<a href="getting-started-with-XDK-for-Java.html#GUID-EA5DB831-1D91-453A-AF7B-7B55343B1720" title="您可以使用环境变量或命令行选项设置XDK for Java环境。">设置</a> Java类路径。
                        </p>
                        <p>要将XSU的使用信息打印到标准输出，请运行以下命令：</p><pre class="oac_no_warn" dir="ltr">java OracleXML</pre><p>要使用<code class="codeph">putXML</code> ，请使用<code class="codeph">getXML</code>或<code class="codeph">putXML</code>参数调用它：</p><pre class="oac_no_warn" dir="ltr">java OracleXML getXML <span class="italic"><code class="codeph">options</code></span> java OracleXML putXML <span class="italic"><code class="codeph">options</code></span>
</pre><p><a href="using-XML-SQL-utility.html#GUID-939256D1-157F-4736-B74D-3288C60A3069__BABGDFFJ" title="此表描述了getXML选项。">表21-2</a>介绍了<code class="codeph">getXML</code>选项。
                        </p>
                        <div class="tblformalwide" id="GUID-939256D1-157F-4736-B74D-3288C60A3069__BABGDFFJ">
                           <p class="titleintable">表21-2 getXML选项</p>
                           <table cellpadding="4" cellspacing="0" class="FormalWide" title="getXML选项" width="100%" border="1" summary="This table describes the getXML options." frame="hsides" rules="rows">
                              <thead>
                                 <tr align="left" valign="top">
                                    <th align="left" valign="bottom" width="38%" id="d77774e2365">getXML选项</th>
                                    <th align="left" valign="bottom" width="62%" id="d77774e2368">描述</th>
                                 </tr>
                              </thead>
                              <tbody>
                                 <tr align="left" valign="top">
                                    <td align="left" valign="top" width="38%" id="d77774e2373" headers="d77774e2365 ">
                                       <p><code class="codeph">-user</code> <span class="italic"><code class="codeph">username</code></span> / <code class="codeph">-user</code> <span class="italic"><code class="codeph">username</code></span> / <span class="italic"><code class="codeph">password"</code></span></p>
                                    </td>
                                    <td align="left" valign="top" width="62%" headers="d77774e2373 d77774e2368 ">
                                       <p>指定连接到数据库的用户名和密码。还指定了连接字符串。您可以将用户名和密码指定为连接字符串的一部分。</p>
                                    </td>
                                 </tr>
                                 <tr align="left" valign="top">
                                    <td align="left" valign="top" width="38%" id="d77774e2389" headers="d77774e2365 ">
                                       <p><code class="codeph">-conn</code> <span class="italic"><code class="codeph">"JDBC_connect_string"</code></span></p>
                                    </td>
                                    <td align="left" valign="top" width="62%" headers="d77774e2389 d77774e2368 ">
                                       <p>指定JDBC数据库连接字符串。默认情况下，连接字符串为：“ <code class="codeph">jdbc:oracle:oci:@</code> ”。
                                       </p>
                                    </td>
                                 </tr>
                                 <tr align="left" valign="top">
                                    <td align="left" valign="top" width="38%" id="d77774e2404" headers="d77774e2365 ">
                                       <p><code class="codeph">-withDTD</code></p>
                                    </td>
                                    <td align="left" valign="top" width="62%" headers="d77774e2404 d77774e2368 ">
                                       <p>指示XSU与XML文档一起生成DTD。</p>
                                    </td>
                                 </tr>
                                 <tr align="left" valign="top">
                                    <td align="left" valign="top" width="38%" id="d77774e2412" headers="d77774e2365 ">
                                       <p><code class="codeph">-withSchema</code></p>
                                    </td>
                                    <td align="left" valign="top" width="62%" headers="d77774e2412 d77774e2368 ">
                                       <p>指示XSU与XML文档一起生成模式。</p>
                                    </td>
                                 </tr>
                                 <tr align="left" valign="top">
                                    <td align="left" valign="top" width="38%" id="d77774e2420" headers="d77774e2365 ">
                                       <p><code class="codeph">-rowsetTag</code> <span class="italic"><code class="codeph">tag_name</code></span></p>
                                    </td>
                                    <td align="left" valign="top" width="62%" headers="d77774e2420 d77774e2368 ">
                                       <p>指定rowset标记，该标记是包含与查询返回的记录对应的所有XML元素的标记。默认的rowset标记是<code class="codeph">&lt;ROWSET&gt;</code> 。如果为rowset指定空字符串（“”），则XSU将省略rowset元素。
                                       </p>
                                    </td>
                                 </tr>
                                 <tr align="left" valign="top">
                                    <td align="left" valign="top" width="38%" id="d77774e2435" headers="d77774e2365 ">
                                       <p><code class="codeph">-rowTag</code> <span class="italic"><code class="codeph">tag_name</code></span></p>
                                    </td>
                                    <td align="left" valign="top" width="62%" headers="d77774e2435 d77774e2368 ">
                                       <p>指定包含与数据库行对应的数据的行标记。默认行标记为<code class="codeph">&lt;ROW&gt;</code> 。如果为行标记指定空字符串（“”），则XSU将省略行标记。
                                       </p>
                                    </td>
                                 </tr>
                                 <tr align="left" valign="top">
                                    <td align="left" valign="top" width="38%" id="d77774e2450" headers="d77774e2365 ">
                                       <p><code class="codeph">-rowIdAttr</code> <span class="italic"><code class="codeph">row_id_attribute_name</code></span></p>
                                    </td>
                                    <td align="left" valign="top" width="62%" headers="d77774e2450 d77774e2368 ">
                                       <p>命名<code class="codeph">ROW</code>元素的属性，以跟踪<code class="codeph">rows</code>的基数。默认情况下，此属性为<code class="codeph">num</code> 。如果指定空字符串作为<code class="codeph">rowID</code>属性，则<code class="codeph">rowID</code>将省略该属性。
                                       </p>
                                    </td>
                                 </tr>
                                 <tr align="left" valign="top">
                                    <td align="left" valign="top" width="38%" id="d77774e2474" headers="d77774e2365 ">
                                       <p>- <code class="codeph">rowIdColumn</code> <span class="italic"><code class="codeph">row_Id_column_name</code></span></p>
                                    </td>
                                    <td align="left" valign="top" width="62%" headers="d77774e2474 d77774e2368 ">
                                       <p>指定将查询中的标量列的值用作<code class="codeph">rowID</code>属性的值。
                                       </p>
                                    </td>
                                 </tr>
                                 <tr align="left" valign="top">
                                    <td align="left" valign="top" width="38%" id="d77774e2490" headers="d77774e2365 ">
                                       <p><code class="codeph">-collectionIdAttr</code> <span class="italic"><code class="codeph">collect_id_attr_name</code></span></p>
                                    </td>
                                    <td align="left" valign="top" width="62%" headers="d77774e2490 d77774e2368 ">
                                       <p>命名XML列表元素的属性，该元素跟踪列表元素的基数。生成的XML列表对应于游标查询或集合。如果指定空字符串（“”）作为<code class="codeph">rowID</code>属性，则<code class="codeph">rowID</code>将省略该属性。
                                       </p>
                                    </td>
                                 </tr>
                                 <tr align="left" valign="top">
                                    <td align="left" valign="top" width="38%" id="d77774e2505" headers="d77774e2365 ">
                                       <p><code class="codeph">-useTypeForCollElemTag</code></p>
                                    </td>
                                    <td align="left" valign="top" width="62%" headers="d77774e2505 d77774e2368 ">
                                       <p>指定column-element标记的用法类型名称。默认情况下<code class="codeph">column-name_item</code>使用<code class="codeph">column-name_item</code> 。
                                       </p>
                                    </td>
                                 </tr>
                                 <tr align="left" valign="top">
                                    <td align="left" valign="top" width="38%" id="d77774e2516" headers="d77774e2365 ">
                                       <p><code class="codeph">-useNullAttrId</code></p>
                                    </td>
                                    <td align="left" valign="top" width="62%" headers="d77774e2516 d77774e2368 ">
                                       <p>指定属性<code class="codeph">NULL (TRUE/FALSE)</code>以指示元素的<code class="codeph">NULL (TRUE/FALSE)</code> 。
                                       </p>
                                    </td>
                                 </tr>
                                 <tr align="left" valign="top">
                                    <td align="left" valign="top" width="38%" id="d77774e2528" headers="d77774e2365 ">
                                       <p><code class="codeph">-styleSheet</code> <span class="italic"><code class="codeph">stylesheet_URI</code></span></p>
                                    </td>
                                    <td align="left" valign="top" width="62%" headers="d77774e2528 d77774e2368 ">
                                       <p>指定XML处理指令中的样式表。</p>
                                    </td>
                                 </tr>
                                 <tr align="left" valign="top">
                                    <td align="left" valign="top" width="38%" id="d77774e2540" headers="d77774e2365 ">
                                       <p><code class="codeph">-stylesheetType</code> <span class="italic"><code class="codeph">stylesheet_type</code></span></p>
                                    </td>
                                    <td align="left" valign="top" width="62%" headers="d77774e2540 d77774e2368 ">
                                       <p>指定XML处理指令中的样式表类型。</p>
                                    </td>
                                 </tr>
                                 <tr align="left" valign="top">
                                    <td align="left" valign="top" width="38%" id="d77774e2552" headers="d77774e2365 ">
                                       <p><code class="codeph">-setXSLT</code> <span class="italic"><code class="codeph">URI</code></span></p>
                                    </td>
                                    <td align="left" valign="top" width="62%" headers="d77774e2552 d77774e2368 ">
                                       <p>指定要应用于XML文档的XSLT样式表。</p>
                                    </td>
                                 </tr>
                                 <tr align="left" valign="top">
                                    <td align="left" valign="top" width="38%" id="d77774e2563" headers="d77774e2365 ">
                                       <p><code class="codeph">-setXSLTRef</code> <span class="italic"><code class="codeph">URI</code></span></p>
                                    </td>
                                    <td align="left" valign="top" width="62%" headers="d77774e2563 d77774e2368 ">
                                       <p>设置XSLT外部实体引用。</p>
                                    </td>
                                 </tr>
                                 <tr align="left" valign="top">
                                    <td align="left" valign="top" width="38%" id="d77774e2575" headers="d77774e2365 ">
                                       <p><code class="codeph">-useLowerCase | -useUpperCase</code></p>
                                    </td>
                                    <td align="left" valign="top" width="62%" headers="d77774e2575 d77774e2368 ">
                                       <p>生成小写或大写标记名称。缺省值是匹配生成标记的SQL对象名称的大小写。</p>
                                    </td>
                                 </tr>
                                 <tr align="left" valign="top">
                                    <td align="left" valign="top" width="38%" id="d77774e2583" headers="d77774e2365 ">
                                       <p><code class="codeph">-withEscaping</code></p>
                                    </td>
                                    <td align="left" valign="top" width="62%" headers="d77774e2583 d77774e2368 ">
                                       <p>指定处理SQL对象名称中合法但在XML标记中非法的字符。如果遇到这样的字符，那么它将被转义，以便它不会抛出异常。</p>
                                    </td>
                                 </tr>
                                 <tr align="left" valign="top">
                                    <td align="left" valign="top" width="38%" id="d77774e2591" headers="d77774e2365 ">
                                       <p><code class="codeph">-errorTag</code> <span class="italic"><code class="codeph">error tag_name</code></span> <code class="codeph">-errorTag</code></p>
                                    </td>
                                    <td align="left" valign="top" width="62%" headers="d77774e2591 d77774e2368 ">
                                       <p>指定用于包含格式为XML的错误消息的标记。</p>
                                    </td>
                                 </tr>
                                 <tr align="left" valign="top">
                                    <td align="left" valign="top" width="38%" id="d77774e2603" headers="d77774e2365 ">
                                       <p><code class="codeph">-raiseException</code></p>
                                    </td>
                                    <td align="left" valign="top" width="62%" headers="d77774e2603 d77774e2368 ">
                                       <p>指定XSU必须抛出Java异常。默认情况下，XSU会捕获任何错误并产生XML错误。</p>
                                    </td>
                                 </tr>
                                 <tr align="left" valign="top">
                                    <td align="left" valign="top" width="38%" id="d77774e2611" headers="d77774e2365 ">
                                       <p><code class="codeph">-raiseNoRowsException</code></p>
                                    </td>
                                    <td align="left" valign="top" width="62%" headers="d77774e2611 d77774e2368 ">
                                       <p>如果没有返回任何行，则引发异常。</p>
                                    </td>
                                 </tr>
                                 <tr align="left" valign="top">
                                    <td align="left" valign="top" width="38%" id="d77774e2619" headers="d77774e2365 ">
                                       <p><code class="codeph">-useStrictLegalXMLCharCheck</code></p>
                                    </td>
                                    <td align="left" valign="top" width="62%" headers="d77774e2619 d77774e2368 ">
                                       <p>对输入数据执行严格检查。</p>
                                    </td>
                                 </tr>
                                 <tr align="left" valign="top">
                                    <td align="left" valign="top" width="38%" id="d77774e2627" headers="d77774e2365 ">
                                       <p><code class="codeph">-maxRows</code> <span class="italic"><code class="codeph">maximum_rows</code></span></p>
                                    </td>
                                    <td align="left" valign="top" width="62%" headers="d77774e2627 d77774e2368 ">
                                       <p>指定要检索并转换为XML的最大行数。</p>
                                    </td>
                                 </tr>
                                 <tr align="left" valign="top">
                                    <td align="left" valign="top" width="38%" id="d77774e2640" headers="d77774e2365 ">
                                       <p><code class="codeph">-skipRows</code> <span class="italic"><code class="codeph">number_of_rows_to_skip</code></span></p>
                                    </td>
                                    <td align="left" valign="top" width="62%" headers="d77774e2640 d77774e2368 ">
                                       <p>指定要跳过的行数。</p>
                                    </td>
                                 </tr>
                                 <tr align="left" valign="top">
                                    <td align="left" valign="top" width="38%" id="d77774e2651" headers="d77774e2365 ">
                                       <p><code class="codeph">-encoding</code> <span class="italic"><code class="codeph">encoding_name</code></span></p>
                                    </td>
                                    <td align="left" valign="top" width="62%" headers="d77774e2651 d77774e2368 ">
                                       <p>指定生成的XML的字符集编码。</p>
                                    </td>
                                 </tr>
                                 <tr align="left" valign="top">
                                    <td align="left" valign="top" width="38%" id="d77774e2663" headers="d77774e2365 ">
                                       <p><code class="codeph">-dateFormat</code> <span class="italic"><code class="codeph">date_format</code></span></p>
                                    </td>
                                    <td align="left" valign="top" width="62%" headers="d77774e2663 d77774e2368 ">
                                       <p>指定XML文档中日期值的日期格式。</p>
                                    </td>
                                 </tr>
                                 <tr align="left" valign="top">
                                    <td align="left" valign="top" width="38%" id="d77774e2675" headers="d77774e2365 ">
                                       <p><code class="codeph">-fileName</code> <span class="italic"><code class="codeph">SQL_query_fileName</code></span> | <span class="italic"><code class="codeph">SQL_query</code></span></p>
                                    </td>
                                    <td align="left" valign="top" width="62%" headers="d77774e2675 d77774e2368 ">
                                       <p>指定包含查询或查询本身的文件名。</p>
                                    </td>
                                 </tr>
                              </tbody>
                           </table>
                        </div>
                        <!-- class="inftblhruleinformal" -->
                        <p><a href="using-XML-SQL-utility.html#GUID-939256D1-157F-4736-B74D-3288C60A3069__BABEFCDB" title="putXML选项和描述是列。">表21-3</a>描述了<code class="codeph">putXML</code>选项。
                        </p>
                        <div class="tblformalwide" id="GUID-939256D1-157F-4736-B74D-3288C60A3069__BABEFCDB">
                           <p class="titleintable">表21-3 putXML选项</p>
                           <table cellpadding="4" cellspacing="0" class="FormalWide" title="putXML选项" width="100%" border="1" summary="putXML Option and Description are the columns." frame="hsides" rules="rows">
                              <thead>
                                 <tr align="left" valign="top">
                                    <th align="left" valign="bottom" width="38%" id="d77774e2709">putXML选项</th>
                                    <th align="left" valign="bottom" width="62%" id="d77774e2712">描述</th>
                                 </tr>
                              </thead>
                              <tbody>
                                 <tr align="left" valign="top">
                                    <td align="left" valign="top" width="38%" id="d77774e2717" headers="d77774e2709 ">
                                       <p><code class="codeph">-user "</code> <span class="italic"><code class="codeph">username</code></span> / <code class="codeph">-user "</code> <span class="italic"><code class="codeph">username</code></span> / <span class="italic"><code class="codeph">password"</code></span></p>
                                    </td>
                                    <td align="left" valign="top" width="62%" headers="d77774e2717 d77774e2712 ">
                                       <p>指定连接到数据库的用户名和密码。还指定了连接字符串。您可以将用户名和密码指定为连接字符串的一部分。</p>
                                    </td>
                                 </tr>
                                 <tr align="left" valign="top">
                                    <td align="left" valign="top" width="38%" id="d77774e2732" headers="d77774e2709 ">
                                       <p><code class="codeph">-conn</code> <span class="italic"><code class="codeph">"JDBC_connect_string"</code></span></p>
                                    </td>
                                    <td align="left" valign="top" width="62%" headers="d77774e2732 d77774e2712 ">
                                       <p>指定JDBC数据库连接字符串。默认情况下，连接字符串为：“ <code class="codeph">jdbc:oracle:oci:@</code> ”。
                                       </p>
                                    </td>
                                 </tr>
                                 <tr align="left" valign="top">
                                    <td align="left" valign="top" width="38%" id="d77774e2747" headers="d77774e2709 ">
                                       <p><code class="codeph">-batchSize</code> <span class="italic"><code class="codeph">batching_size</code></span></p>
                                    </td>
                                    <td align="left" valign="top" width="62%" headers="d77774e2747 d77774e2712 ">
                                       <p>指定批处理大小，该批处理大小控制批处理并插入到数据库的单个行中以提高性能的行数。</p>
                                    </td>
                                 </tr>
                                 <tr align="left" valign="top">
                                    <td align="left" valign="top" width="38%" id="d77774e2759" headers="d77774e2709 ">
                                       <p><code class="codeph">-commitBatch</code> <span class="italic"><code class="codeph">commit_size</code></span></p>
                                    </td>
                                    <td align="left" valign="top" width="62%" headers="d77774e2759 d77774e2712 ">
                                       <p>指定要在其后执行提交的插入记录数。如果自动提交为<code class="codeph">TRUE</code> （默认值），则设置<code class="codeph">commitBatch</code>没有任何后果。
                                       </p>
                                    </td>
                                 </tr>
                                 <tr align="left" valign="top">
                                    <td align="left" valign="top" width="38%" id="d77774e2777" headers="d77774e2709 ">
                                       <p><code class="codeph">-rowTag</code> <span class="italic"><code class="codeph">tag_name</code></span></p>
                                    </td>
                                    <td align="left" valign="top" width="62%" headers="d77774e2777 d77774e2712 ">
                                       <p>指定<code class="codeph">row</code>标记，该标记是用于包含与数据库行对应的数据的标记。默认行标记为<code class="codeph">&lt;ROW&gt;</code> 。如果为行标记指定空字符串，则XSU将省略行标记。
                                       </p>
                                    </td>
                                 </tr>
                                 <tr align="left" valign="top">
                                    <td align="left" valign="top" width="38%" id="d77774e2795" headers="d77774e2709 ">
                                       <p><code class="codeph">-dateFormat</code> <span class="italic"><code class="codeph">date_format</code></span></p>
                                    </td>
                                    <td align="left" valign="top" width="62%" headers="d77774e2795 d77774e2712 ">
                                       <p>指定XML文档中日期值的日期格式。</p>
                                    </td>
                                 </tr>
                                 <tr align="left" valign="top">
                                    <td align="left" valign="top" width="38%" id="d77774e2807" headers="d77774e2709 ">
                                       <p><code class="codeph">-withEscaping</code></p>
                                    </td>
                                    <td align="left" valign="top" width="62%" headers="d77774e2807 d77774e2712 ">
                                       <p>如果在生成doc时使用SQL到XML名称转义，则打开反向映射。</p>
                                    </td>
                                 </tr>
                                 <tr align="left" valign="top">
                                    <td align="left" valign="top" width="38%" id="d77774e2815" headers="d77774e2709 ">
                                       <p><code class="codeph">-ignoreCase</code></p>
                                    </td>
                                    <td align="left" valign="top" width="62%" headers="d77774e2815 d77774e2712 ">
                                       <p>使列名称的匹配与标记名称不区分大小写。例如，如果启用了<code class="codeph">ignoreCase</code> ，则<code class="codeph">EmpNo</code>与<code class="codeph">EMPNO</code>匹配。
                                       </p>
                                    </td>
                                 </tr>
                                 <tr align="left" valign="top">
                                    <td align="left" valign="top" width="38%" id="d77774e2832" headers="d77774e2709 ">
                                       <p><code class="codeph">-preserveWhitespace</code></p>
                                    </td>
                                    <td align="left" valign="top" width="62%" headers="d77774e2832 d77774e2712 ">
                                       <p>保留插入的XML文档中的空白区域。</p>
                                    </td>
                                 </tr>
                                 <tr align="left" valign="top">
                                    <td align="left" valign="top" width="38%" id="d77774e2840" headers="d77774e2709 ">
                                       <p><code class="codeph">-setXSLT</code> <span class="italic"><code class="codeph">URI</code></span></p>
                                    </td>
                                    <td align="left" valign="top" width="62%" headers="d77774e2840 d77774e2712 ">
                                       <p>指定在插入之前应用于XML文档的XSLT。</p>
                                    </td>
                                 </tr>
                                 <tr align="left" valign="top">
                                    <td align="left" valign="top" width="38%" id="d77774e2851" headers="d77774e2709 ">
                                       <p><code class="codeph">-setXSLTRef</code> <span class="italic"><code class="codeph">URI</code></span></p>
                                    </td>
                                    <td align="left" valign="top" width="62%" headers="d77774e2851 d77774e2712 ">
                                       <p>设置XSLT外部实体引用。</p>
                                    </td>
                                 </tr>
                                 <tr align="left" valign="top">
                                    <td align="left" valign="top" width="38%" id="d77774e2864" headers="d77774e2709 ">
                                       <p><code class="codeph">-fileName</code> <span class="italic"><code class="codeph">file_name</code></span> | <code class="codeph">-URL</code> <span class="italic"><code class="codeph">URL</code></span> | <code class="codeph">-xmlDoc</code> <span class="italic"><code class="codeph">xml_document</code></span></p>
                                    </td>
                                    <td align="left" valign="top" width="62%" headers="d77774e2864 d77774e2712 ">
                                       <p>指定要插入的XML文档：本地文件，URL或XML文档作为命令行上的字符串。</p>
                                    </td>
                                 </tr>
                                 <tr align="left" valign="top">
                                    <td align="left" valign="top" width="38%" id="d77774e2889" headers="d77774e2709 ">
                                       <p><span class="italic"><code class="codeph">TABLE_NAME</code></span></p>
                                    </td>
                                    <td align="left" valign="top" width="62%" headers="d77774e2889 d77774e2712 ">
                                       <p>指定要将值放入的表的名称。</p>
                                    </td>
                                 </tr>
                              </tbody>
                           </table>
                        </div>
                        <!-- class="inftblhruleinformal" -->
                     </div>
                     <!-- class="section" -->
                  </div><a id="ADXDK19416"></a><div class="props_rev_3"><a id="GUID-174D770C-41CE-48E3-A55D-1ADFEF0E6465" name="GUID-174D770C-41CE-48E3-A55D-1ADFEF0E6465"></a><h5 id="ADXDK-GUID-174D770C-41CE-48E3-A55D-1ADFEF0E6465" class="sect5">使用XSU命令行实用程序生成XML</h5>
                     <div>
                        <p>要从数据库模式生成XML，请使用<code class="codeph">getXML</code>参数。
                        </p>
                        <div class="section">
                           <p>例如，要通过查询<code class="codeph">hr</code>模式中的<code class="codeph">employees</code>表来生成XML文档，可以使用以下语法：</p><pre class="oac_no_warn" dir="ltr">java OracleXML getXML -user“hr / <span class="italic">password</span> ”“SELECT * FROM employees”</pre><p>上述命令执行以下任务：</p>
                        </div>
                        <!-- class="section" -->
                        <ol>
                           <li><span>连接到当前的默认数据库</span></li>
                           <li><span>执行指定的<code class="codeph">SELECT</code>查询</span></li>
                           <li><span>将SQL结果集转换为XML</span></li>
                           <li><span>将XML打印到标准输出</span></li>
                        </ol>
                        <div class="section">
                           <p><code class="codeph">getXML</code>参数支持多种选项，如<a href="using-XML-SQL-utility.html#GUID-939256D1-157F-4736-B74D-3288C60A3069__BABGDFFJ" title="此表描述了getXML选项。">表21-2所示</a> 。
                           </p>
                        </div>
                        <!-- class="section" -->
                     </div>
                  </div><a id="ADXDK071"></a><div class="props_rev_3"><a id="GUID-02BD7152-7DDE-4525-81B5-9DA84AD57113" name="GUID-02BD7152-7DDE-4525-81B5-9DA84AD57113"></a><h5 id="ADXDK-GUID-02BD7152-7DDE-4525-81B5-9DA84AD57113" class="sect5">使用XSU命令行实用程序生成XMLType数据</h5>
                     <div>
                        <p>您可以使用XSU从具有<code class="codeph">XMLType</code>列的表生成XML。
                        </p>
                        <div class="section">
                           <p>假设您运行演示脚本<code class="codeph">setup_xmltype.sql</code>来创建和填充<code class="codeph">parts</code>表。您可以使用XSU从此表生成XML：</p><pre class="oac_no_warn" dir="ltr">java OracleXML getXML -user“hr / <span class="italic">password</span> ”-rowTag“Part”“SELECT * FROM parts”</pre><p>命令的输出如下所示：</p><pre class="pre codeblock"><code>&lt;？xml版本='1.0'？&gt; &lt;ROWSET&gt; &lt;Part num =“1”&gt; &lt;PARTNO&gt; 1735 &lt;/ PARTNO&gt; &lt;PARTNAME&gt; Gizmo &lt;/ PARTNAME&gt; &lt;PARTDESC&gt; &lt;Description&gt; &lt;Title&gt; Gizmo的描述&lt;/ Title&gt; &lt;作者&gt; John Smith &lt;/ Author&gt; &lt;Body&gt; &lt;b&gt; Gizmo &lt;/ b&gt;是&lt;i&gt; grand &lt;/ i&gt;。&lt;/ Body&gt; &lt;/ Description&gt; &lt;/ PARTDESC&gt; &lt;/ Part&gt; &lt;/ ROWSET&gt;</code></pre></div>
                        <!-- class="section" -->
                     </div>
                  </div><a id="ADXDK19417"></a><div class="props_rev_3"><a id="GUID-760FF626-748B-4216-B8BC-EF8CC1A2B89A" name="GUID-760FF626-748B-4216-B8BC-EF8CC1A2B89A"></a><h5 id="ADXDK-GUID-760FF626-748B-4216-B8BC-EF8CC1A2B89A" class="sect5">使用XSU命令行实用程序执行DML</h5>
                     <div>
                        <p>示例显示如何将XML文档插入数据库表。</p>
                        <div class="section">
                           <p>要将名为<code class="codeph">new_employees.xml</code>的XML文档插入<code class="codeph">hr.employees</code>表，请使用以下语法：</p><pre class="oac_no_warn" dir="ltr">java OracleXML putXML -user“hr / <span class="italic">password</span> ”-fileName“new_employees.xml”员工</pre><p>上述命令执行以下任务：</p>
                        </div>
                        <!-- class="section" -->
                        <ol>
                           <li><span>以<code class="codeph">hr</code>为单位连接到当前数据库</span></li>
                           <li><span>读取名为<code class="codeph">new_emp.xml</code>的XML文档</span></li>
                           <li><span>解析XML文档，将标记与列名匹配</span></li>
                           <li><span>将值适当地插入<code class="codeph">employees</code>表中</span></li>
                        </ol>
                        <div class="section">
                           <p><code class="codeph">getXML</code>参数支持多种选项，如<a href="using-XML-SQL-utility.html#GUID-939256D1-157F-4736-B74D-3288C60A3069__BABGDFFJ" title="此表描述了getXML选项。">表21-2所示</a> 。
                           </p>
                        </div>
                        <!-- class="section" -->
                     </div>
                  </div>
               </div>
            </div><a id="ADXDK1010"></a><a id="ADXDK19418"></a><div class="props_rev_3"><a id="GUID-4922BDF4-3588-4348-9509-16BB8AB1A691" name="GUID-4922BDF4-3588-4348-9509-16BB8AB1A691"></a><h3 id="ADXDK-GUID-4922BDF4-3588-4348-9509-16BB8AB1A691" class="sect3">使用XSU Java API进行编程</h3>
               <div>
                  <p>这里的主题包括使用OracleXMLQuery和OracleXMLSave执行各种操作，以及处理XSU Java异常。</p>
                  <div class="section"> </div>
                  <!-- class="section" -->
               </div><a id="ADXDK19419"></a><div class="props_rev_3"><a id="GUID-40A59B26-5039-45FB-BCC0-6C886C573E80" name="GUID-40A59B26-5039-45FB-BCC0-6C886C573E80"></a><h4 id="ADXDK-GUID-40A59B26-5039-45FB-BCC0-6C886C573E80" class="sect4">使用OracleXMLQuery生成字符串</h4>
                  <div>
                     <p><code class="codeph">testXMLSQL.java</code>演示程序使用<code class="codeph">testXMLSQL.java</code>生成XML作为<code class="codeph">String</code>对象。程序查询表<code class="codeph">hr.employees</code>并将结果集打印到标准输出。
                     </p>
                     <div class="section">
                        <p><code class="codeph">testXMLSQL.java</code>程序遵循以下步骤：</p>
                     </div>
                     <!-- class="section" -->
                     <ol>
                        <li class="stepexpand"><span>注册JDBC驱动程序并创建数据库连接。此代码片段使用OCI JDBC驱动程序并使用用户名<code class="codeph">hr</code>连接：</span><div><pre class="oac_no_warn" dir="ltr">import oracle.jdbc。*; ...连接conn = getConnection（“hr”，“ <span class="italic">password</span> ”）; ...private static Connection getConnection（String username，String password）throws SQLException {//注册JDBC驱动程序DriverManager.registerDriver（new oracle.jdbc。一个OracleDriver（））; //使用OCI驱动程序创建连接Connection conn = DriverManager.getConnection（“jdbc：oracle：oci：@”，username，password）;返回; }</pre></div>
                        </li>
                        <li class="stepexpand"><span>创建XML查询对象并使用SQL查询对其进行初始化。此代码片段使用<code class="codeph">hr.employees</code>上的<code class="codeph">SELECT</code>语句初始化对象：</span><div><pre class="oac_no_warn" dir="ltr">OracleXMLQuery qry = new OracleXMLQuery（conn，“SELECT * FROM employees”）;</pre></div>
                        </li>
                        <li class="stepexpand"><span>将查询结果集作为<code class="codeph">String</code>对象获取。<code class="codeph">getXMLString()</code>方法将构造函数中指定的对象关系数据转换为XML文档。此示例显示了此技术：</span><div><pre class="oac_no_warn" dir="ltr">String str = qry.getXMLString（）;</pre></div>
                        </li>
                        <li class="stepexpand"><span>关闭查询对象以释放任何资源，如以下代码所示：</span><div><pre class="oac_no_warn" dir="ltr">qry.close（）;</pre></div>
                        </li>
                     </ol>
                  </div><a id="ADXDK19420"></a><div class="props_rev_3"><a id="GUID-EDD35813-2EC5-485F-9FF9-A62E6524F4B4" name="GUID-EDD35813-2EC5-485F-9FF9-A62E6524F4B4"></a><h5 id="ADXDK-GUID-EDD35813-2EC5-485F-9FF9-A62E6524F4B4" class="sect5">运行testXMLSQL程序</h5>
                     <div>
                        <p>描述了<code class="codeph">testXMLSQL</code>程序。
                        </p>
                        <div class="section">
                           <p>要运行<code class="codeph">testXMLSQL.java</code>程序，请执行以下步骤：</p>
                        </div>
                        <!-- class="section" -->
                        <ol>
                           <li><span>用<code class="codeph">javac</code>编译<code class="codeph">testXMLSQL.java</code> 。</span></li>
                           <li><span>在命令行上执行<code class="codeph">java testXMLSQL</code> 。</span></li>
                        </ol>
                        <div class="section">
                           <p>您必须具有指向此目录的<code class="codeph">CLASSPATH</code>才能使Java可执行文件找到该类。或者，使用可视Java工具（如Oracle JDeveloper）来编译和运行此程序。运行时，该程序将XML文件打印到屏幕上。此代码显示了一些输出的示例输出：</p><pre class="oac_no_warn" dir="ltr">&lt;？xml版本='1.0'？&gt; &lt;ROWSET&gt; &lt;ROW num =“1”&gt; &lt;EMPLOYEE_ID&gt; 100 &lt;/ EMPLOYEE_ID&gt; &lt;FIRST_NAME&gt; Steven &lt;/ FIRST_NAME&gt; &lt;LAST_NAME&gt; King &lt;/ LAST_NAME&gt; &lt;EMAIL&gt; SKING &lt;/ EMAIL&gt; &lt;PHONE_NUMBER&gt; 515.123.4567 &lt;/ PHONE_NUMBER&gt; &lt;HIRE_DATE&gt; 6/17/1987 0：0：0 &lt;/ HIRE_DATE&gt; &lt;JOB_ID&gt; AD_PRES &lt;/ JOB_ID&gt; &lt;SALARY&gt; 24000 &lt;/ SALARY&gt; &lt;DEPARTMENT_ID&gt; 90 &lt;/ DEPARTMENT_ID&gt; &lt;/ ROW&gt; &lt; ！ -  ROW num =“2”到num =“107”......  - &gt; &lt;/ ROWSET&gt;</pre></div>
                        <!-- class="section" -->
                     </div>
                  </div>
               </div><a id="ADXDK19421"></a><div class="props_rev_3"><a id="GUID-3839ED46-BD8B-4069-972A-DEBB031C6F57" name="GUID-3839ED46-BD8B-4069-972A-DEBB031C6F57"></a><h4 id="ADXDK-GUID-3839ED46-BD8B-4069-972A-DEBB031C6F57" class="sect4">使用OracleXMLQuery生成DOM树</h4>
                  <div>
                     <p>要从XSU生成的XML生成DOM树，您可以直接从XSU请求DOM文档。此技术节省了创建XML文档的字符串表示的开销，然后解析它以生成DOM树。</p>
                     <div class="section">
                        <p>XSU调用Oracle XML解析器从数据值构造DOM树。<code class="codeph">domTest.java</code>演示程序生成一个DOM树，然后按文档顺序遍历它，逐个打印节点。
                        </p>
                        <p>在前两个步骤<code class="codeph">domTest.java</code>程序是一样的，在<code class="codeph">testXMLSQL.java</code>中描述的程序<a href="using-XML-SQL-utility.html#GUID-40A59B26-5039-45FB-BCC0-6C886C573E80" title="testXMLSQL.java演示程序使用XSU生成XML作为String对象。程序查询表hr.employees并将结果集打印到标准输出。">生成与OracleXMLQuery字符串</a> 。该计划如下：</p>
                     </div>
                     <!-- class="section" -->
                     <ol>
                        <li class="stepexpand"><span>通过调用<code class="codeph">getXMLDOM()</code>方法获取DOM。以下示例显示了此技术：</span><div><pre class="oac_no_warn" dir="ltr">XMLDocument domDoc =（XMLDocument）qry.getXMLDOM（）;</pre></div>
                        </li>
                        <li class="stepexpand"><span>打印DOM树。以下代码打印到标准输出：</span><div><pre class="oac_no_warn" dir="ltr">domDoc.print（System.out的）;</pre><p>您还可以创建一个<code class="codeph">StringWriter</code>并将其包装在<code class="codeph">PrintWriter</code> ：</p><pre class="oac_no_warn" dir="ltr">StringWriter s = new StringWriter（10000）; domDoc.print（new PrintWriter（s））; System.out.println（“字符串版本---&gt; \ n”+ s.toString（））;</pre></div>
                        </li>
                     </ol>
                     <div class="section">
                        <p>编译程序后，从命令行运行它：</p><pre class="oac_no_warn" dir="ltr">java domTest</pre></div>
                     <!-- class="section" -->
                  </div>
               </div><a id="ADXDK1011"></a><a id="ADXDK19422"></a><div class="props_rev_3"><a id="GUID-0C64EE95-DAF1-4A51-B35E-C1C0C10C96C5" name="GUID-0C64EE95-DAF1-4A51-B35E-C1C0C10C96C5"></a><h4 id="ADXDK-GUID-0C64EE95-DAF1-4A51-B35E-C1C0C10C96C5" class="sect4">使用OracleXMLQuery分页结果</h4>
                  <div>
                     <p>这里的主题包括限制结果集中的行，在用户会话期间保持对象打开，以及使用<code class="codeph">OracleXMLQuery</code>结果进行分页。
                     </p>
                     <div class="section"> </div>
                     <!-- class="section" -->
                  </div><a id="ADXDK19424"></a><a id="ADXDK19423"></a><div class="props_rev_3"><a id="GUID-F777424E-1212-4F8E-A134-3CD61A07DDB0" name="GUID-F777424E-1212-4F8E-A134-3CD61A07DDB0"></a><h5 id="ADXDK-GUID-F777424E-1212-4F8E-A134-3CD61A07DDB0" class="sect5">限制结果集中的行数</h5>
                     <div>
                        <p>描述了限制结果集中的行数的不同方式。</p>
                        <div class="section">
                           <p>在<code class="codeph">testXMLSQL.java</code>和<code class="codeph">domTest.java</code> ， <code class="codeph">domTest.java</code>从查询返回的所有行生成XML。假设您查询包含1000行的表，但一次只需要100行。一种方法是执行一个查询以获取前100行，另一个查询获得接下来的100行，依此类推。使用此技术，您无法跳过查询的前五行，然后生成结果。要避免这些问题，请使用以下Java方法：</p>
                        </div>
                        <!-- class="section" -->
                        <div class="section">
                           <ul style="list-style-type:disc">
                              <li>
                                 <p>在开始生成结果之前， <code class="codeph">OracleXMLSave.setSkipRows()</code>强制XSU跳过所需的行数。与此方法等效的命令行是<code class="codeph">-skipRows</code>参数。
                                 </p>
                              </li>
                              <li>
                                 <p><code class="codeph">OracleXMLSave.setMaxRows()</code>限制转换为XML的行数。与此方法等效的命令行是<code class="codeph">-maxRows</code>参数。
                                 </p>
                              </li>
                           </ul>
                           <p><a href="using-XML-SQL-utility.html#GUID-F777424E-1212-4F8E-A134-3CD61A07DDB0__BABHCFIG">例21-1</a>将<code class="codeph">skipRows</code>设置为值<code class="codeph">5</code> ，将<code class="codeph">maxRows</code>设置为值<code class="codeph">1</code> ，这会导致XSU跳过前5行，然后在查询<code class="codeph">hr.employees</code>表时为下一行生成XML。
                           </p>
                           <p>下面显示了示例输出（仅返回查询结果集的第6行）：</p><pre class="oac_no_warn" dir="ltr">&lt;？xml版本='1.0'？&gt; &lt;ROWSET&gt; &lt;ROW num =“6”&gt; &lt;EMPLOYEE_ID&gt; 105 &lt;/ EMPLOYEE_ID&gt; &lt;FIRST_NAME&gt; David &lt;/ FIRST_NAME&gt; &lt;LAST_NAME&gt; Austin &lt;/ LAST_NAME&gt; &lt;EMAIL&gt; DAUSTIN &lt;/ EMAIL&gt; &lt;PHONE_NUMBER&gt; 590.423.4569 &lt;/ PHONE_NUMBER&gt; &lt;HIRE_DATE&gt; 6/25/1997 0：0：0 &lt;/ HIRE_DATE&gt; &lt;JOB_ID&gt; IT_PROG &lt;/ JOB_ID&gt; &lt;SALARY&gt; 4800 &lt;/ SALARY&gt; &lt;MANAGER_ID&gt; 103 &lt;/ MANAGER_ID&gt; &lt;DEPARTMENT_ID&gt; 60 &lt; / DEPARTMENT_ID&gt; &lt;/ ROW&gt; &lt;/ ROWSET&gt;</pre></div>
                        <!-- class="section" -->
                        <div class="example" id="GUID-F777424E-1212-4F8E-A134-3CD61A07DDB0__BABHCFIG">
                           <p class="titleinexample">示例21-1在命令行上指定skipRows和maxRows</p><pre class="oac_no_warn" dir="ltr">java OracleXML getXML -user“hr / <span class="italic">password</span> ”-skipRows 5 -maxRows 1 \“SELECT * FROM employees”</pre></div>
                        <!-- class="example" -->
                     </div>
                  </div><a id="ADXDK19425"></a><div class="props_rev_3"><a id="GUID-9CECA907-B96B-4165-B774-9D9F777C6DBB" name="GUID-9CECA907-B96B-4165-B774-9D9F777C6DBB"></a><h5 id="ADXDK-GUID-9CECA907-B96B-4165-B774-9D9F777C6DBB" class="sect5">保持对象在用户会话的持续时间内打开</h5>
                     <div>
                        <p>在某些情况下，您可能希望在用户会话期间保持查询对象处于打开状态。您可以使用<code class="codeph">maxRows()</code>方法和<code class="codeph">keepObjectOpen()</code>方法处理此类情况。
                        </p>
                        <div class="section">
                           <p>考虑一个分页搜索结果的网络搜索引擎。第一页列出了10个结果，下一页列出了10个结果，依此类推。要使用XSU执行此任务，请一次请求10行并保持<code class="codeph">ResultSet</code>打开，以便下次向XSU请求更多结果时，它将从上一代完成的位置开始生成。如果<code class="codeph">OracleXMLQuery</code>从SQL查询字符串创建结果集，那么它通常会在内部关闭<code class="codeph">ResultSet</code>因为它假定不再需要更多结果。因此，您必须调用<code class="codeph">keepObjectOpen()</code>以使游标保持活动状态。
                           </p>
                           <p>需要打开查询对象的另一种情况是行中的行数或列数非常大。在这种情况下，您可以生成多个小文档而不是一个大文档。</p>
                        </div>
                        <!-- class="section" -->
                     </div>
                     <div>
                        <div class="relinfo">
                           <p><strong>相关话题</strong></p>
                           <ul>
                              <li><a href="using-XML-SQL-utility.html#GUID-790B346F-11A5-493A-B34A-E972069F95EC" title="paginateResults.java程序显示了如何生成分页结果的XML页面。输出XML仅显示hr表的20行。">使用OracleXMLQuery分页结果：示例</a></li>
                           </ul>
                        </div>
                     </div>
                     
                  </div><a id="ADXDK19426"></a><div class="props_rev_3"><a id="GUID-790B346F-11A5-493A-B34A-E972069F95EC" name="GUID-790B346F-11A5-493A-B34A-E972069F95EC"></a><h5 id="ADXDK-GUID-790B346F-11A5-493A-B34A-E972069F95EC" class="sect5">使用OracleXMLQuery分页结果：示例</h5>
                     <div>
                        <p><code class="codeph">paginateResults.java</code>程序显示了如何生成分页结果的XML页面。输出XML仅显示<code class="codeph">hr</code>表的20行。
                        </p>
                        <div class="section">
                           <p><code class="codeph">paginateResults.java</code>程序显示了如何生成分页结果的XML页面。输出XML仅显示<code class="codeph">hr</code>表的20行。
                           </p>
                           <p>创建连接的<code class="codeph">paginateResults.java</code>程序的第一步与<code class="codeph">testXMLSQL.java</code>的相同。该计划继续如下：</p>
                        </div>
                        <!-- class="section" -->
                        <ol>
                           <li class="stepexpand"><span>创建一个SQL语句对象并使用SQL查询对其进行初始化。以下代码片段在<code class="codeph">java.sql.设置了两个选项<code class="codeph">java.sql.ResultSet</code> ：</span><div><pre class="oac_no_warn" dir="ltr">语句stmt = conn.createStatement（ResultSet。TYPE_SCROLL_SENSITIVE，ResultSet。CONCUR_READ_ONLY）;</pre></div>
                           </li>
                           <li class="stepexpand"><span>将查询创建为字符串并通过调用<code class="codeph">Statement.executeQuery()</code>执行它。返回对象的类型为<code class="codeph">ResultSet</code> 。以下示例显示了此技术：</span><div><pre class="oac_no_warn" dir="ltr">String sCmd =“SELECT first_name，last_name FROM hr.employees”; ResultSet rs = stmt.executeQuery（sCmd）;</pre></div>
                           </li>
                           <li class="stepexpand"><span>创建查询对象，如下面的代码所示：</span><div><pre class="oac_no_warn" dir="ltr">OracleXMLQuery xmlQry = new OracleXMLQuery（conn，rs）;</pre></div>
                           </li>
                           <li class="stepexpand"><span>配置查询对象。以下代码指定查询对象在会话期间打开。它还将返回的行数限制为20：</span><div><pre class="oac_no_warn" dir="ltr">xmlQry.keepObjectOpen（真）; xmlQry.setRowsetTag（ “ROWSET”）; xmlQry.setRowTag（ “ROW”）; xmlQry.setMaxRows（20）;</pre></div>
                           </li>
                           <li class="stepexpand"><span>以<code class="codeph">String</code>检索结果并打印：</span><div><pre class="oac_no_warn" dir="ltr">String sXML = xmlQry.getXMLString（）;的System.out.println（sXML）;</pre></div>
                           </li>
                        </ol>
                        <div class="section">
                           <p>编译程序后，从命令行运行它：</p><pre class="oac_no_warn" dir="ltr">java paginateResults</pre></div>
                        <!-- class="section" -->
                     </div>
                  </div>
               </div><a id="ADXDK19427"></a><div class="props_rev_3"><a id="GUID-788FD888-45E4-4B7F-91CD-0151398196CF" name="GUID-788FD888-45E4-4B7F-91CD-0151398196CF"></a><h4 id="ADXDK-GUID-788FD888-45E4-4B7F-91CD-0151398196CF" class="sect4">生成可滚动结果集</h4>
                  <div>
                     <p>您可能希望执行查询，然后从结果集中检索上一页结果。要启用滚动，请实例化<code class="codeph">Oracle.jdbc.ResultSet</code>类。您可以使用<code class="codeph">ResultSet</code>对象在结果集中来回移动，并使用XSU每次生成XML。
                     </p>
                     <div class="section">
                        <p><code class="codeph">pageTest.java</code>程序显示了如何使用JDBC <code class="codeph">ResultSet</code>生成一个页面XML。在未由XSU直接处理的情况下（例如，在设置批量大小和绑定值时），可能需要使用<code class="codeph">ResultSet</code> 。
                        </p>
                        <p><code class="codeph">pageTest.java</code>程序创建一个<code class="codeph">pageTest</code>对象并使用SQL查询对其进行初始化。<code class="codeph">pageTest</code>对象的构造函数执行以下步骤：</p>
                     </div>
                     <!-- class="section" -->
                     <ol>
                        <li class="stepexpand"><span>通过调用<code class="codeph">paginateResults.java</code>定义的相同<code class="codeph">getConnection()</code>方法来创建JDBC连接：</span><div><pre class="oac_no_warn" dir="ltr">连接conn; ...conn = getConnection（“hr”，“ <span class="italic">password</span> ”）;</pre></div>
                        </li>
                        <li class="stepexpand"><span>创建一个声明：</span><div><pre class="oac_no_warn" dir="ltr">声明stmt; ...stmt = conn.createStatement（）;</pre></div>
                        </li>
                        <li class="stepexpand"><span>执行传递给构造函数的查询以获取可滚动的结果集。以下代码显示了此技术：</span><div><pre class="oac_no_warn" dir="ltr">ResultSet rset = stmt.executeQuery（sqlQuery）;</pre></div>
                        </li>
                        <li class="stepexpand"><span>通过将对连接和结果集对象的引用传递给构造函数来创建查询对象。以下代码片段显示了此技术：</span><div><pre class="oac_no_warn" dir="ltr">OracleXMLQuery qry; ...qry = new OracleXMLQuery（conn，rset）;</pre></div>
                        </li>
                        <li class="stepexpand"><span>配置查询对象。以下代码片段指定查询对象保持打开状态，并在没有更多行时引发异常：</span><div><pre class="oac_no_warn" dir="ltr">qry.keepObjectOpen（真）; qry.setRaiseNoRowsException（真）; qry.setRaiseException（真）;</pre></div>
                        </li>
                        <li class="stepexpand"><span>通过向查询对象传递字符串<code class="codeph">"SELECT * FROM employees"</code>创建查询对象后，程序将循环遍历结果集。<code class="codeph">getResult()</code>方法接收指定集合的起始行和结束行的整数值。它通过计算这些值的差异来设置要检索的最大行数，然后将结果作为字符串检索。以下<code class="codeph">while</code>循环一次检索并打印十行：</span><div><pre class="oac_no_warn" dir="ltr">int i = 0; while（（str = test.getResult（i，i + 10））！= null）{System.out.println（str）; i + = 10; }</pre></div>
                        </li>
                     </ol>
                     <div class="section">
                        <p>编译程序后，从命令行运行它：</p><pre class="oac_no_warn" dir="ltr">java pageTest</pre></div>
                     <!-- class="section" -->
                  </div>
               </div><a id="ADXDK19428"></a><div class="props_rev_3"><a id="GUID-B77E1941-0B4C-4B73-8EBC-25357E3DA75C" name="GUID-B77E1941-0B4C-4B73-8EBC-25357E3DA75C"></a><h4 id="ADXDK-GUID-B77E1941-0B4C-4B73-8EBC-25357E3DA75C" class="sect4">从游标对象生成XML</h4>
                  <div>
                     <p>您可以初始化<code class="codeph">CallableStatement</code>对象，执行返回游标变量的PL / SQL函数，获取<code class="codeph">OracleResultSet</code>对象，并将其发送到<code class="codeph">OracleXMLQuery</code>对象以获取所需的XML数据。
                     </p>
                     <div class="section">
                        <p><code class="codeph">OracleXMLQuery</code>类仅为查询字符串或<code class="codeph">ResultSet</code>对象提供XML转换。如果您的程序使用返回<code class="codeph">REF</code>游标的PL / SQL过程，那么如何执行转换？您可以使用<a href="using-XML-SQL-utility.html#GUID-788FD888-45E4-4B7F-91CD-0151398196CF" title="您可能希望执行查询，然后从结果集中检索上一页结果。要启用滚动，请实例化Oracle.jdbc。ResultSet类。您可以使用ResultSet对象在结果集中来回移动，并使用XSU每次生成XML。">生成可滚动结果</a>集中描述的<code class="codeph">ResultSet</code>转换机制。
                        </p>
                        <p><code class="codeph">REF</code>游标是PL / SQL中游标对象的引用。这些游标对象是SQL语句，程序可以通过它来迭代以获取一组值。游标对象在Java世界中转换为<code class="codeph">OracleResultSet</code>对象。在Java程序中，您可以初始化<code class="codeph">CallableStatement</code>对象，执行返回游标变量的PL / SQL函数，获取<code class="codeph">OracleResultSet</code>对象，然后将其发送到<code class="codeph">OracleXMLQuery</code>对象以获取所需的XML。</p>
                        <p>考虑<code class="codeph">testRef.sql</code>脚本中定义的<code class="codeph">testRef</code> PL / SQL包。它创建了一个定义<code class="codeph">REF</code>游标并返回它的函数。每次<code class="codeph">testRefCur</code> PL / SQL函数时，它都会打开<code class="codeph">SELECT</code>查询的游标对象并返回该游标实例。要将对象转换为XML，请执行以下操作：</p>
                     </div>
                     <!-- class="section" -->
                     <ol>
                        <li><span>运行<code class="codeph">testRef.sql</code>脚本以在<code class="codeph">hr</code>模式中创建<code class="codeph">testRef</code>包。</span></li>
                        <li><span>编译并运行<code class="codeph">refCurTest.java</code>程序，以根据<code class="codeph">testRefCur</code>函数中定义的SQL查询的结果生成XML。</span></li>
                     </ol>
                     <div class="section">
                        <p>要应用样式表，可以使用<code class="codeph">applyStylesheet</code> <span class="italic"> </span>命令，强制在生成输出之前应用样式表。
                        </p>
                     </div>
                     <!-- class="section" -->
                  </div>
               </div><a id="ADXDK19429"></a><div class="props_rev_3"><a id="GUID-555483DC-5765-4E8B-B99A-96832941FB54" name="GUID-555483DC-5765-4E8B-B99A-96832941FB54"></a><h4 id="ADXDK-GUID-555483DC-5765-4E8B-B99A-96832941FB54" class="sect4">使用OracleXMLSave插入行</h4>
                  <div>
                     <p>要将文档插入表或视图，请提供表或视图名称和文档。XSU解析文档并创建一个<code class="codeph">INSERT</code>语句，它将值绑定到该语句中。默认情况下，XSU将值插入表或视图的所有列。
                     </p>
                     <div class="section">
                        <p>缺少的元素被视为<code class="codeph">NULL</code>值。以下示例显示如何存储从表中的<code class="codeph">hr.employees</code>表生成的XML文档。
                        </p>
                     </div>
                     <!-- class="section" -->
                  </div><a id="ADXDK19430"></a><div class="props_rev_3"><a id="GUID-FBDEFAFC-567F-48C5-85F1-B33680A85CA0" name="GUID-FBDEFAFC-567F-48C5-85F1-B33680A85CA0"></a><h5 id="ADXDK-GUID-FBDEFAFC-567F-48C5-85F1-B33680A85CA0" class="sect5">使用OracleXMLSave将XML插入到所有列中</h5>
                     <div>
                        <p><code class="codeph">testInsert.java</code>演示程序将XML值插入<code class="codeph">hr.employees</code>表的所有列。
                        </p>
                        <div class="section">
                           <p></p>
                           <p>该计划遵循以下步骤：</p>
                        </div>
                        <!-- class="section" -->
                        <ol>
                           <li class="stepexpand"><span>创建JDBC OCI连接。该程序调用本章前面示例使用的相同<code class="codeph">getConnection()</code>方法：</span><div><pre class="oac_no_warn" dir="ltr">连接conn = getConnection（“hr”，“ <span class="italic">password</span> ”）;</pre></div>
                           </li>
                           <li class="stepexpand"><span>创建XML保存对象。您可以通过将它的初始化对象<code class="codeph">Connection</code>参考，并要在其上执行DML的表的名称。以下示例显示了此技术：</span><div><pre class="oac_no_warn" dir="ltr">OracleXMLSave sav = new OracleXMLSave（conn，“employees”）;</pre></div>
                           </li>
                           <li class="stepexpand"><span>将输入XML文档中的数据插入<code class="codeph">hr.employees</code>表。以下代码片段根据命令行中指定的文档文件名创建URL：</span><div><pre class="oac_no_warn" dir="ltr">sav.insertXML（sav.getURL（argv的[0]））;</pre></div>
                           </li>
                           <li class="stepexpand"><span>关闭XML保存对象：</span><div><pre class="oac_no_warn" dir="ltr">sav.close（）;</pre></div>
                           </li>
                        </ol>
                     </div><a id="ADXDK19431"></a><div class="props_rev_3"><a id="GUID-D005B919-A669-4BF9-A22A-2F75ECE3B82D" name="GUID-D005B919-A669-4BF9-A22A-2F75ECE3B82D"></a><h6 id="ADXDK-GUID-D005B919-A669-4BF9-A22A-2F75ECE3B82D" class="sect6">运行testInsert程序</h6>
                        <div>
                           <p>描述了<code class="codeph">textInsert</code>程序。
                           </p>
                           <div class="section">
                              <p>假设您编写<code class="codeph">new_emp.xml</code>文档来描述员工ID为7369的新员工Janet Smith。您将文件名<code class="codeph">new_emp.xml</code>作为参数传递给<code class="codeph">testInsert</code>程序：</p><pre class="oac_no_warn" dir="ltr">java testInsert“new_emp.xml”</pre><p>该程序在<code class="codeph">employees</code>表中插入一个新行，该行包含指定列的值。行元素中的任何缺少元素都被视为<code class="codeph">NULL</code> 。</p>
                              <p>运行该程序会生成此表单的<code class="codeph">INSERT</code>语句：</p><pre class="oac_no_warn" dir="ltr">INSERT INTO hr.employees（employee_id，first_name，last_name，email，phone_number，hire_date，salary，commission_pct，manager_id，department_id）VALUES（？，？，？，？，？，？，？，？，？，？）;</pre><p>XSU匹配输入XML文档中与列名匹配的元素标记并绑定其值。</p>
                           </div>
                           <!-- class="section" -->
                        </div>
                     </div>
                  </div><a id="ADXDK19432"></a><div class="props_rev_3"><a id="GUID-220FC06C-0D3F-427D-ACEC-B37753B43189" name="GUID-220FC06C-0D3F-427D-ACEC-B37753B43189"></a><h5 id="ADXDK-GUID-220FC06C-0D3F-427D-ACEC-B37753B43189" class="sect5">使用OracleXMLSave将XML插入到列的子集中</h5>
                     <div>
                        <p>在某些情况下，您可能不希望将值插入所有列。例如，您获得的值组可能不是完整集，要求您对其余列使用触发器或默认值。</p>
                        <div class="section">
                           <p><code class="codeph">testInsertSubset.java</code>演示程序显示了如何处理这种情况。它遵循以下步骤：</p>
                        </div>
                        <!-- class="section" -->
                        <ol>
                           <li class="stepexpand"><span>创建JDBC OCI连接。该程序调用本章前面示例使用的相同<code class="codeph">getConnection()</code>方法：</span><div><pre class="oac_no_warn" dir="ltr">连接conn = getConnection（“hr”，“ <span class="italic">password</span> ”）;</pre></div>
                           </li>
                           <li class="stepexpand"><span>创建XML保存对象。通过传递<code class="codeph">Connection</code>引用和要在其上执行DML的表的名称来初始化对象。以下示例显示了此技术：</span><div><pre class="oac_no_warn" dir="ltr">OracleXMLSave sav = new OracleXMLSave（conn，“employees”）;</pre></div>
                           </li>
                           <li class="stepexpand"><span>创建一个字符串数组。数组的每个元素都必须包含插入值的列的名称。以下代码片段指定了五列的名称：</span><div><pre class="oac_no_warn" dir="ltr">String [] colNames = new String [5]; colNames [0] =“EMPLOYEE_ID”; colNames [1] =“LAST_NAME”; colNames [2] =“EMAIL”; colNames [3] =“JOB_ID”; colNames [4] =“HIRE_DATE”;</pre></div>
                           </li>
                           <li class="stepexpand"><span>配置XML保存对象以更新指定的列。以下语句将对数组的引用传递给<code class="codeph">OracleXMLSave.setUpdateColumnList()</code>方法：</span><div><pre class="oac_no_warn" dir="ltr">sav.setUpdateColumnList（colNames）;</pre></div>
                           </li>
                           <li class="stepexpand"><span>将输入XML文档中的数据插入<code class="codeph">hr.employees</code>表。以下代码片段根据命令行中指定的文档文件名创建URL：</span><div><pre class="oac_no_warn" dir="ltr">sav.insertXML（sav.getURL（argv的[0]））;</pre></div>
                           </li>
                           <li class="stepexpand"><span>关闭XML保存对象：</span><div><pre class="oac_no_warn" dir="ltr">sav.close（）;</pre></div>
                           </li>
                        </ol>
                     </div><a id="ADXDK19433"></a><div class="props_rev_3"><a id="GUID-ACDEFAC1-46BE-4363-90C4-027897AD1AD9" name="GUID-ACDEFAC1-46BE-4363-90C4-027897AD1AD9"></a><h6 id="ADXDK-GUID-ACDEFAC1-46BE-4363-90C4-027897AD1AD9" class="sect6">运行testInsertSubset程序</h6>
                        <div>
                           <p>描述了<code class="codeph">testInsertSubset</code>程序。
                           </p>
                           <div class="section">
                              <p>假设您使用<code class="codeph">new_emp2.xml</code>文档来存储员工ID为7400的新员工Adams的数据。您将<code class="codeph">new_emp2.xml</code>作为参数传递给<code class="codeph">testInsert</code>程序：</p><pre class="oac_no_warn" dir="ltr">java testInsert new_emp2.xml</pre><p>程序忽略输入文件中未指定的列的值。它为输入中的每个<code class="codeph">ROW</code>元素执行<code class="codeph">INSERT</code> ，并默认批处理<code class="codeph">INSERT</code>语句。
                              </p>
                              <p>该程序生成此<code class="codeph">INSERT</code>语句：</p><pre class="oac_no_warn" dir="ltr">INSERT INTO hr.employees（employee_id，last_name，email，job_id，hire_date）VALUES（？，？，？，？，？）;</pre></div>
                           <!-- class="section" -->
                        </div>
                     </div>
                  </div>
               </div><a id="ADXDK19434"></a><div class="props_rev_3"><a id="GUID-646799B4-73D6-4AD1-94F1-E614343D65F6" name="GUID-646799B4-73D6-4AD1-94F1-E614343D65F6"></a><h4 id="ADXDK-GUID-646799B4-73D6-4AD1-94F1-E614343D65F6" class="sect4">使用OracleXMLSave更新行</h4>
                  <div>
                     <p>示例显示如何更新表或视图中的字段。您提供表或视图名称和XML文档。XSU解析文档（如果给出了字符串）并创建一个或多个<code class="codeph">UPDATE</code>语句，它将所有值绑定到该语句中。
                     </p>
                     <div class="section">
                        <p>以下示例使用XML文档来更新表<code class="codeph">hr.employees</code> 。
                        </p>
                     </div>
                     <!-- class="section" -->
                  </div><a id="ADXDK19435"></a><div class="props_rev_3"><a id="GUID-06AF6382-FDFC-4FC1-A65B-C0C66F658175" name="GUID-06AF6382-FDFC-4FC1-A65B-C0C66F658175"></a><h5 id="ADXDK-GUID-06AF6382-FDFC-4FC1-A65B-C0C66F658175" class="sect5">使用OracleXMLSave更新密钥列</h5>
                     <div>
                        <p>演示程序<code class="codeph">testUpdate.java</code>调用方法<code class="codeph">OracleXMLSave.setKeyColumnList()</code>来更新表<code class="codeph">hr.employees</code> 。
                        </p>
                        <div class="section">
                           <p><code class="codeph">testUpdate.java</code>遵循以下步骤：</p>
                        </div>
                        <!-- class="section" -->
                        <ol>
                           <li class="stepexpand"><span>创建JDBC OCI连接。该程序调用本章前面示例使用的相同<code class="codeph">getConnection()</code>方法：</span><div><pre class="oac_no_warn" dir="ltr">连接conn = getConnection（“hr”，“ <span class="italic">password</span> ”）;</pre></div>
                           </li>
                           <li class="stepexpand"><span>创建XML保存对象。您可以通过将它的初始化对象<code class="codeph">Connection</code>参考，并要在其上执行DML的表的名称。以下示例显示了此技术：</span><div><pre class="oac_no_warn" dir="ltr">OracleXMLSave sav = new OracleXMLSave（conn，“employees”）;</pre></div>
                           </li>
                           <li class="stepexpand"><span>创建单元素<code class="codeph">String</code>数组以保存要更新的表中主键列的名称。以下代码片段指定<code class="codeph">employee_id</code>列的名称：</span><div><pre class="oac_no_warn" dir="ltr">String [] keyColNames = new String [1]; colNames [0] =“EMPLOYEE_ID”;</pre></div>
                           </li>
                           <li class="stepexpand"><span>将XML保存对象设置为数组中指定的主键。以下语句将对<code class="codeph">keyColNames</code>数组的引用传递给<code class="codeph">OracleXMLSave.setKeyColumnList()</code>方法：</span><div><pre class="oac_no_warn" dir="ltr">sav.setKeyColumnList（keyColNames）;</pre></div>
                           </li>
                           <li class="stepexpand"><span>更新输入XML文档中指定的行。以下语句根据命令行中指定的文件名创建URL：</span><div><pre class="oac_no_warn" dir="ltr">sav.updateXML（sav.getURL（argv的[0]））;</pre></div>
                           </li>
                           <li class="stepexpand"><span>关闭XML保存对象：</span><div><pre class="oac_no_warn" dir="ltr">sav.close（）;</pre></div>
                           </li>
                        </ol>
                     </div><a id="ADXDK19437"></a><a id="ADXDK19436"></a><div class="props_rev_3"><a id="GUID-E1F2B493-A35D-4069-AE61-310538FA2FF0" name="GUID-E1F2B493-A35D-4069-AE61-310538FA2FF0"></a><h6 id="ADXDK-GUID-E1F2B493-A35D-4069-AE61-310538FA2FF0" class="sect6">运行testUpdate程序</h6>
                        <div>
                           <p>描述了<code class="codeph">testUpdate</code>程序。
                           </p>
                           <div class="section">
                              <p>您可以使用XSU更新表中的指定字段。<a href="using-XML-SQL-utility.html#GUID-E1F2B493-A35D-4069-AE61-310538FA2FF0__BABJCJDJ">例21-2</a>显示了<code class="codeph">upd_emp.xml</code> ，其中包含您刚刚添加的两名员工7369和7400的更新薪水和其他信息。
                              </p>
                              <p>对于更新，请在XDU中提供<code class="codeph">UPDATE</code>语句的<code class="codeph">WHERE</code>子句中的键列名列表。在<code class="codeph">hr.employees</code>表中， <code class="codeph">employee_id</code>列是键。
                              </p>
                              <p>将文件名<code class="codeph">upd_emp.xml</code>作为参数传递给前面的程序：</p><pre class="oac_no_warn" dir="ltr">java testUpdate upd_emp.xml</pre><p>该程序生成两个<code class="codeph">UPDATE</code>语句。对于第一个<code class="codeph">ROW</code>元素，程序生成一个<code class="codeph">UPDATE</code>语句来更新<code class="codeph">SALARY</code>字段：</p><pre class="oac_no_warn" dir="ltr">UPDATE hr.employees SET salary = 3250 WHERE employee_id = 7400;</pre><p>对于第二个<code class="codeph">ROW</code>元素，程序生成此语句：</p><pre class="oac_no_warn" dir="ltr">UPDATE hr.employees SET job_id ='SA_REP'AND MANAGER_ID = 145 WHERE employee_id = 7369;</pre></div>
                           <!-- class="section" -->
                           <div class="example" id="GUID-E1F2B493-A35D-4069-AE61-310538FA2FF0__BABJCJDJ">
                              <p class="titleinexample">例21-2 upd_emp.xml</p><pre class="oac_no_warn" dir="ltr">&lt;？xml版本='1.0'？&gt; &lt;ROWSET&gt; &lt;ROW num =“1”&gt; &lt;EMPLOYEE_ID&gt; 7400 &lt;/ EMPLOYEE_ID&gt; &lt;SALARY&gt; 3250 &lt;/ SALARY&gt; &lt;/ ROW&gt; &lt;ROW num =“2”&gt; &lt;EMPLOYEE_ID&gt; 7369 &lt;/ EMPLOYEE_ID&gt; &lt;JOB_ID &gt; SA_REP &lt;/ JOB_ID&gt; &lt;MANAGER_ID&gt; 145 &lt;/ MANAGER_ID&gt; &lt;/ ROW&gt; &lt;！ - 附加行...  - &gt; &lt;/ ROWSET&gt;</pre></div>
                           <!-- class="example" -->
                        </div>
                     </div>
                  </div><a id="ADXDK19438"></a><div class="props_rev_3"><a id="GUID-BF4F12F6-1EC7-4B6D-BEEC-A9D9D5816D8B" name="GUID-BF4F12F6-1EC7-4B6D-BEEC-A9D9D5816D8B"></a><h5 id="ADXDK-GUID-BF4F12F6-1EC7-4B6D-BEEC-A9D9D5816D8B" class="sect5">使用OracleXMLSave更新列列表</h5>
                     <div>
                        <p></p>
                        <div class="section">
                           <p>通过指定列列表，可以仅使用XML文档中的元素子集更新表。这很快，因为XSU使用相同的<code class="codeph">UPDATE</code>语句，并为所有<code class="codeph">ROW</code>元素使用绑定变量。可以忽略文档中的其他标记。
                           </p>
                           <div class="infoboxnote" id="GUID-BF4F12F6-1EC7-4B6D-BEEC-A9D9D5816D8B__GUID-5E0033C1-2F3C-4CAA-BBBE-A9E65CDB0A5B">
                              <p class="notep1">注意：</p>
                              <p>指定要更新的列的列表时，如果缺少与更新列对应的元素，则XSU将其视为<code class="codeph">NULL</code> 。</p>
                           </div>
                           <p>假设您要更新每个员工的薪水和职位，并忽略其他数据。如果您知道要更新的所有元素对于XML文档中的所有<code class="codeph">ROW</code>元素都是相同的，那么您可以使用<code class="codeph">OracleXMLSave.setUpdateColumnNames()</code>方法来指定列。<code class="codeph">testUpdateList.java</code>程序显示了这种技术。
                           </p>
                           <p><code class="codeph">testUpdateList.java</code>程序遵循以下步骤：</p>
                        </div>
                        <!-- class="section" -->
                        <ol>
                           <li class="stepexpand"><span>创建JDBC OCI连接。该程序调用本章前面示例使用的相同<code class="codeph">getConnection()</code>方法：</span><div><pre class="oac_no_warn" dir="ltr">连接conn = getConnection（“hr”，“ <span class="italic">password</span> ”）;</pre></div>
                           </li>
                           <li class="stepexpand"><span>创建XML保存对象。您可以通过将它的初始化对象<code class="codeph">Connection</code>参考，并要在其上执行DML的表的名称。以下示例显示了此技术：</span><div><pre class="oac_no_warn" dir="ltr">OracleXMLSave sav = new OracleXMLSave（conn，“employees”）;</pre></div>
                           </li>
                           <li class="stepexpand"><span>创建一个<code class="codeph">String</code>类型的数组，以保存要更新的表中主键列的名称。该数组只包含一个元素，该元素是要更新的表中主键列的名称。以下代码片段指定<code class="codeph">employee_id</code>列的名称：</span><div><pre class="oac_no_warn" dir="ltr">String [] colNames = new String [1]; colNames [0] =“EMPLOYEE_ID”;</pre></div>
                           </li>
                           <li class="stepexpand"><span>将XML保存对象设置为数组中指定的主键。以下语句将对<code class="codeph">colNames</code>数组的引用传递给<code class="codeph">OracleXMLSave.setKeyColumnList()</code>方法：</span><div><pre class="oac_no_warn" dir="ltr">sav.setKeyColumnList（keyColNames）;</pre></div>
                           </li>
                           <li class="stepexpand"><span>创建<code class="codeph">String</code>类型的<code class="codeph">String</code>以保存要更新的列的名称。以下代码片段指定<code class="codeph">employee_id</code>列的名称：</span><div><pre class="oac_no_warn" dir="ltr">String [] updateColNames = new String [2]; updateColNames [0] =“SALARY”; updateColNames [1] =“JOB_ID”;</pre></div>
                           </li>
                           <li class="stepexpand"><span>将XML保存对象设置为要更新的列的列表。以下语句执行此任务：</span><div><pre class="oac_no_warn" dir="ltr">sav.setUpdateColumnList（updateColNames）;</pre></div>
                           </li>
                           <li class="stepexpand"><span>更新输入XML文档中指定的行。以下代码片段根据命令行中指定的文件名创建URL：</span><div><pre class="oac_no_warn" dir="ltr">sav.updateXML（sav.getURL（argv的[0]））;</pre></div>
                           </li>
                           <li class="stepexpand"><span>关闭XML保存对象：</span><div><pre class="oac_no_warn" dir="ltr">sav.close（）;</pre></div>
                           </li>
                        </ol>
                     </div><a id="ADXDK19439"></a><div class="props_rev_3"><a id="GUID-F631E856-2DF4-4926-90AA-BFF97840F90F" name="GUID-F631E856-2DF4-4926-90AA-BFF97840F90F"></a><h6 id="ADXDK-GUID-F631E856-2DF4-4926-90AA-BFF97840F90F" class="sect6">运行testUpdateList程序</h6>
                        <div>
                           <p>描述了<code class="codeph">testUpdateList</code>程序。
                           </p>
                           <div class="section">
                              <p>假设您使用示例XML文档<code class="codeph">upd_emp2.xml</code>为员工ID为100的员工Steven King和员工标识符（ID）为206的William Gietz存储新数据。您将<code class="codeph">upd_emp2.xml</code>作为参数传递给<code class="codeph">testUpdateList</code>程序：</p><pre class="oac_no_warn" dir="ltr">java testUpdateList upd_emp2.xml</pre><p>在此示例中，程序生成两个<code class="codeph">UPDATE</code>语句。对于第一个<code class="codeph">ROW</code>元素，程序生成以下语句：</p><pre class="oac_no_warn" dir="ltr">UPDATE hr.employees SET salary = 8350 AND job_id ='AC_ACCOUNT'WHER employee_id = 100;</pre><p>对于第二个<code class="codeph">ROW</code>元素，程序生成此语句：</p><pre class="oac_no_warn" dir="ltr">UPDATE hr.employees SET salary = 25000 AND job_id ='AD_PRES'WHERER employee_id = 206;</pre></div>
                           <!-- class="section" -->
                        </div>
                     </div>
                  </div>
               </div><a id="ADXDK19440"></a><div class="props_rev_3"><a id="GUID-2E4CC584-0613-4BC2-9C9B-252AE6A91A84" name="GUID-2E4CC584-0613-4BC2-9C9B-252AE6A91A84"></a><h4 id="ADXDK-GUID-2E4CC584-0613-4BC2-9C9B-252AE6A91A84" class="sect4">使用XSU删除行</h4>
                  <div>
                     <p>从XML文档中删除时，可以指定键列的列表。XSU在<code class="codeph">DELETE</code>语句的<code class="codeph">WHERE</code>子句中使用这些列。如果您不提供键列名，则XSU会为XML文档的每个<code class="codeph">ROW</code>元素创建一个新的<code class="codeph">DELETE</code>语句。
                     </p>
                     <div class="section">
                        <p><code class="codeph">DELETE</code>语句的<code class="codeph">WHERE</code>子句中的列列表与<code class="codeph">ROW</code>元素中的列匹配。
                        </p>
                     </div>
                     <!-- class="section" -->
                  </div><a id="ADXDK19441"></a><div class="props_rev_3"><a id="GUID-FD22DD32-C1F3-475E-8F5C-A735E2DC6FFE" name="GUID-FD22DD32-C1F3-475E-8F5C-A735E2DC6FFE"></a><h5 id="ADXDK-GUID-FD22DD32-C1F3-475E-8F5C-A735E2DC6FFE" class="sect5">使用OracleXMLSave按行删除</h5>
                     <div>
                        <p><code class="codeph">testDeleteRow.java</code>演示程序接受XML文档文件名作为输入，并删除与文档中元素对应的行。
                        </p>
                        <div class="section">
                           <p><code class="codeph">testDeleteRow.java</code>程序遵循以下步骤：</p>
                        </div>
                        <!-- class="section" -->
                        <ol>
                           <li class="stepexpand"><span>创建JDBC OCI连接。该程序调用本章前面示例使用的相同<code class="codeph">getConnection()</code>方法：</span><div><pre class="oac_no_warn" dir="ltr">连接conn = getConnection（“hr”，“ <span class="italic">password</span> ”）;</pre></div>
                           </li>
                           <li class="stepexpand"><span>创建XML保存对象。您可以通过将它的初始化对象<code class="codeph">Connection</code>参考，并要在其上执行DML的表的名称。以下示例显示了此技术：</span><div><pre class="oac_no_warn" dir="ltr">OracleXMLSave sav = new OracleXMLSave（conn，“employees”）;</pre></div>
                           </li>
                           <li class="stepexpand"><span>删除输入XML文档中指定的行。以下代码片段根据命令行中指定的文件名创建URL：</span><div><pre class="oac_no_warn" dir="ltr">sav.deleteXML（sav.getURL（argv的[0]））;</pre></div>
                           </li>
                           <li class="stepexpand"><span>关闭XML保存对象：</span><div><pre class="oac_no_warn" dir="ltr">sav.close（）;</pre></div>
                           </li>
                        </ol>
                     </div><a id="ADXDK19442"></a><div class="props_rev_3"><a id="GUID-C40831D5-A4B1-47EF-90E4-7C5859D9DBFC" name="GUID-C40831D5-A4B1-47EF-90E4-7C5859D9DBFC"></a><h6 id="ADXDK-GUID-C40831D5-A4B1-47EF-90E4-7C5859D9DBFC" class="sect6">运行testDelete程序</h6>
                        <div>
                           <p>描述了<code class="codeph">testDelete</code>程序。
                           </p>
                           <div class="section">
                              <p>本节说明如何删除在<a href="using-XML-SQL-utility.html#GUID-555483DC-5765-4E8B-B99A-96832941FB54" title="要将文档插入表或视图，请提供表或视图名称和文档。XSU解析文档并创建一个INSERT语句，它将值绑定到该语句中。默认情况下，XSU将值插入表或视图的所有列。">使用OracleXMLSave插入行中</a>添加的员工7400和7369。
                              </p>
                              <p>要使此示例正常工作，请连接到数据库并禁用<code class="codeph">hr.job_history</code>表上的约束：</p><pre class="oac_no_warn" dir="ltr">CONNECT hr ALTER TABLE job_history DISABLE CONSTRAINT JHIST_EMP_FK;出口</pre><p>现在将<code class="codeph">upd_emp.xml</code>传递给<code class="codeph">testDeleteRow</code>程序：</p><pre class="oac_no_warn" dir="ltr">java testDeleteRow upd_emp.xml</pre><p>该程序根据XML文档中每个<code class="codeph">ROW</code>元素中存在的标记名称形成<code class="codeph">DELETE</code>语句。它执行以下语句：</p><pre class="oac_no_warn" dir="ltr">DELETE FROM hr.employees WHERE salary = 3250 AND employee_id = 7400; DELETE FROM hr.employees WHERE job_id ='SA_REP'AND MANAGER_ID = 145 AND employee_id = 7369;</pre></div>
                           <!-- class="section" -->
                        </div>
                     </div>
                  </div><a id="ADXDK19443"></a><div class="props_rev_3"><a id="GUID-2D3D2A64-0291-4D19-9783-4BD518C8E95D" name="GUID-2D3D2A64-0291-4D19-9783-4BD518C8E95D"></a><h5 id="ADXDK-GUID-2D3D2A64-0291-4D19-9783-4BD518C8E95D" class="sect5">使用OracleXMLSave按键删除</h5>
                     <div>
                        <p>要仅将键值用作<code class="codeph">DELETE</code>语句的谓词，请调用<code class="codeph">OracleXMLSave.setKeyColumnList()</code>方法。此方法限制用于标识行的元素数，这有利于通过缓存<code class="codeph">DELETE</code>语句和批处理事务来提高性能。<code class="codeph">testDeleteKey.java</code>程序显示了这种技术。
                        </p>
                        <div class="section">
                           <p><code class="codeph">testDeleteKey.java</code>程序遵循以下步骤：</p>
                        </div>
                        <!-- class="section" -->
                        <ol>
                           <li class="stepexpand"><span>创建JDBC OCI连接。该程序调用本章前面示例使用的相同<code class="codeph">getConnection()</code>方法：</span><div><pre class="oac_no_warn" dir="ltr">连接conn = getConnection（“hr”，“ <span class="italic">password</span> ”）;</pre></div>
                           </li>
                           <li class="stepexpand"><span>创建XML保存对象。您可以通过将它的初始化对象<code class="codeph">Connection</code>参考，并要在其上执行DML的表的名称。以下示例显示了此技术：</span><div><pre class="oac_no_warn" dir="ltr">OracleXMLSave sav = new OracleXMLSave（conn，“employees”）;</pre></div>
                           </li>
                           <li class="stepexpand"><span>创建一个<code class="codeph">String</code>类型的数组，以保存表中主键列的名称。该数组只包含一个元素。以下代码片段指定<code class="codeph">employee_id</code>列的名称：</span><div><pre class="oac_no_warn" dir="ltr">String [] colNames = new String [1]; colNames [0] =“EMPLOYEE_ID”;</pre></div>
                           </li>
                           <li class="stepexpand"><span>将XML保存对象设置为数组中指定的主键。以下语句将对<code class="codeph">colNames</code>数组的引用传递给<code class="codeph">OracleXMLSave.setKeyColumnList()</code>方法：</span><div><pre class="oac_no_warn" dir="ltr">sav.setKeyColumnList（keyColNames）;</pre></div>
                           </li>
                           <li class="stepexpand"><span>删除输入XML文档中指定的行。以下代码片段根据命令行中指定的文件名创建URL：</span><div><pre class="oac_no_warn" dir="ltr">sav.deleteXML（sav.getURL（argv的[0]））;</pre></div>
                           </li>
                           <li class="stepexpand"><span>关闭XML保存对象：</span><div><pre class="oac_no_warn" dir="ltr">sav.close（）;</pre></div>
                           </li>
                        </ol>
                     </div><a id="ADXDK19444"></a><div class="props_rev_3"><a id="GUID-079034DA-8188-4CA1-99DB-519BC2269DCD" name="GUID-079034DA-8188-4CA1-99DB-519BC2269DCD"></a><h6 id="ADXDK-GUID-079034DA-8188-4CA1-99DB-519BC2269DCD" class="sect6">运行testDeleteKey程序</h6>
                        <div>
                           <p>描述了<code class="codeph">testDeleteKey</code>程序。
                           </p>
                           <div class="section">
                              <p>本节说明如何删除在<a href="using-XML-SQL-utility.html#GUID-06AF6382-FDFC-4FC1-A65B-C0C66F658175" title="演示程序testUpdate.java调用方法OracleXMLSave.setKeyColumnList（）来更新表hr.employees。">使用OracleXMLSave更新密钥列时</a>添加的员工7400和7369。如果您在上一个示例中删除了这些员工，则可以将它们添加回<code class="codeph">employees</code>表：</p><pre class="oac_no_warn" dir="ltr">java testInsert new_emp.xml java testInsert new_emp2.xml</pre><p>通过将相同的<code class="codeph">upd_emp.xml</code>文档传递给<code class="codeph">testDeleteRow</code>程序来删除员工7400和7369：</p><pre class="oac_no_warn" dir="ltr">java testDeleteKey upd_emp.xml</pre><p>该程序形成了这个单独生成的<code class="codeph">DELETE</code>语句：</p><pre class="oac_no_warn" dir="ltr">DELETE FROM hr.employees WHERE employee_id =？;</pre><p>程序执行这些<code class="codeph">DELETE</code>语句，每个员工一个：</p><pre class="oac_no_warn" dir="ltr">DELETE FROM hr.employees WHERE employee_id = 7400; DELETE FROM hr.employees WHERE employee_id = 7369;</pre></div>
                           <!-- class="section" -->
                        </div>
                     </div>
                  </div>
               </div><a id="ADXDK19445"></a><div class="props_rev_3"><a id="GUID-6A0346A5-E903-4819-A4CA-BCC00EBA732A" name="GUID-6A0346A5-E903-4819-A4CA-BCC00EBA732A"></a><h4 id="ADXDK-GUID-6A0346A5-E903-4819-A4CA-BCC00EBA732A" class="sect4">处理XSU Java异常</h4>
                  <div>
                     <p>XSU捕获处理期间发生的所有异常并抛出<code class="codeph">oracle.xml.sql.OracleXMLSQLException</code> ，这是一个通用的运行时异常。如果调用程序仍然可以执行适当的操作，则无需捕获此异常。异常类提供了获取错误消息和任何父异常的方法。
                     </p>
                     <div class="section"></div>
                     <!-- class="section" -->
                  </div><a id="ADXDK19446"></a><div class="props_rev_3"><a id="GUID-3184503E-9C0D-4DFF-984E-5D1C6512AA42" name="GUID-3184503E-9C0D-4DFF-984E-5D1C6512AA42"></a><h5 id="ADXDK-GUID-3184503E-9C0D-4DFF-984E-5D1C6512AA42" class="sect5">获得父母例外</h5>
                     <div>
                        <p><code class="codeph">testException.java</code>演示程序抛出运行时异常，然后通过调用<code class="codeph">Exception.getParentException()</code>获取父异常。
                        </p>
                        <p>运行该程序会生成以下错误消息：</p><pre class="oac_no_warn" dir="ltr">捕获SQL异常：ORA-00904：“SD”：标识符无效</pre></div>
                  </div><a id="ADXDK19447"></a><div class="props_rev_3"><a id="GUID-4F096761-00BB-4A94-9368-F91C7ACA9D2C" name="GUID-4F096761-00BB-4A94-9368-F91C7ACA9D2C"></a><h5 id="ADXDK-GUID-4F096761-00BB-4A94-9368-F91C7ACA9D2C" class="sect5">提出无行例外</h5>
                     <div>
                        <p>当没有要处理的行时，XSU返回一个<code class="codeph">null</code>字符串。但是，每次没有更多行时，您可以抛出异常，以便程序可以使用异常处理程序处理此异常。
                        </p>
                        <div class="section">
                           <p>当程序调用<code class="codeph">OracleXMLQuery.setRaiseNoRowsException()</code> ，XSU会引发<code class="codeph">oracle.xml.sql.每当没有要为输出生成的行时， OracleXMLSQLNoRowsException</code> 。这是运行时异常，无需捕获。
                           </p>
                           <p>该<code class="codeph">noRowsTest.java</code>演示程序实例化<code class="codeph">pageTest</code>中定义的类<code class="codeph">pageTest.java</code> 。检查终止的条件从检查结果是否为<code class="codeph">null</code>来更改为异常处理程序。
                           </p>
                           <p><code class="codeph">noRowsTest.java</code>程序创建一个<code class="codeph">pageTest</code>对象，并使用SQL查询对其进行初始化。该计划如下：</p>
                        </div>
                        <!-- class="section" -->
                        <ol>
                           <li class="stepexpand"><span>配置查询对象或引发无行异常。以下代码片段显示了此技术：</span><div><pre class="oac_no_warn" dir="ltr">pageTest test = new pageTest（“SELECT * from employees”）; ...test.qry.setRaiseNoRowsException（真）;</pre></div>
                           </li>
                           <li class="stepexpand"><span>无限循环遍历结果集，一次检索十行。当没有可用的行时，程序会抛出异常。以下代码片段调用<code class="codeph">pageTest.nextPage()</code> ，它一次滚动结果集十行：</span><div><pre class="oac_no_warn" dir="ltr">try {while（true）System.out.println（test.nextPage（））; }</pre></div>
                           </li>
                           <li class="stepexpand"><span>捕获无行异常并打印“END OF OUTPUT”。以下代码显示了此技术：</span><div><pre class="oac_no_warn" dir="ltr">赶上（oracle.xml.sql。OracleXMLSQLNoRowsException e）{System.out.println（“END OF OUTPUT”）;试试{test.close（）; } catch（Exception ae）{ae.printStackTrace（System.out）; }}</pre></div>
                           </li>
                        </ol>
                        <div class="section">
                           <p>编译程序后，从命令行运行它：</p><pre class="oac_no_warn" dir="ltr">java noRowsTest</pre></div>
                        <!-- class="section" -->
                     </div>
                  </div>
               </div>
            </div><a id="ADXDK1013"></a><a id="ADXDK19475"></a><div class="sect2"><a id="GUID-33F51125-6078-4BC0-83BA-A529E2C47724" name="GUID-33F51125-6078-4BC0-83BA-A529E2C47724"></a><h3 id="ADXDK-GUID-33F51125-6078-4BC0-83BA-A529E2C47724" class="sect3">使用XSU进行编程的技巧和技巧</h3>
               <div>
                  <p>本节提供使用XSU编写程序的提示和技巧。</p>
                  <div class="section"> </div>
                  <!-- class="section" -->
               </div><a id="ADXDK1014"></a><a id="ADXDK19476"></a><div class="props_rev_3"><a id="GUID-84D83A32-328E-440D-A7F1-244803CAE38E" name="GUID-84D83A32-328E-440D-A7F1-244803CAE38E"></a><h4 id="ADXDK-GUID-84D83A32-328E-440D-A7F1-244803CAE38E" class="sect4">XSU如何在SQL和XML之间进行映射</h4>
                  <div>
                     <p>描述了SQL和XML之间的映射。</p>
                     <p>表的基本组件是列，而XML文档的基本组件是元素和属性。表如何映射到XML文档？例如，如果<code class="codeph">hr.employees</code>表有一个名为<code class="codeph">last_name</code>的列，那么这个结构如何用XML表示：作为具有<code class="codeph">last_name</code>属性的<code class="codeph">&lt;EMPLOYEES&gt;</code>元素或作为不同根元素中的<code class="codeph">&lt;LAST_NAME&gt;</code>元素？本节通过描述SQL如何映射到XML以及相反的方式来回答这些问题。
                     </p>
                     <div class="section"> </div>
                     <!-- class="section" -->
                  </div><a id="ADXDK19477"></a><div class="props_rev_3"><a id="GUID-15AC5AA9-6628-44A3-BF97-B0C0EBD81976" name="GUID-15AC5AA9-6628-44A3-BF97-B0C0EBD81976"></a><h5 id="ADXDK-GUID-15AC5AA9-6628-44A3-BF97-B0C0EBD81976" class="sect5">默认的SQL到XML映射</h5>
                     <div>
                        <p>描述了SQL数据到XML数据的默认映射。</p>
                        <p>要将<code class="codeph">hr.employees</code>表的某些列中的数据显示为XML文档，请在命令行运行<code class="codeph">hr.employees</code> ：</p><pre class="oac_no_warn" dir="ltr">java OracleXML getXML -user“hr / <span class="italic">password</span> ”-withschema \“SELECT employee_id，last_name，hire_date FROM employees”</pre><p>XSU基于输入查询输出XML文档。文档的根元素是<code class="codeph">&lt;DOCUMENT&gt;</code> 。以下显示了示例输出，其中多余的行被注释替换：</p><pre class="oac_no_warn" dir="ltr">&lt;？xml版本='1.0'？&gt; &lt;DOCUMENT xmlns：xsd =“http://www.w3.org/2001/XMLSchema”&gt; &lt;xsd：schema xmlns：xsd =“http://www.w3.org/2001/XMLSchema”&gt; &lt;！ -  -  schema元素的子元素...  - &gt; &lt;/ xsd：schema&gt; &lt;ROWSET xmlns：xsi =“http://www.w3.org/2001/XMLSchema-instance”xsi：noNamespaceSchemaLocation =“＃/ DOCUMENT / xsd ：schema [not（@targetNamespace）]“&gt; &lt;ROW num =”1“&gt; &lt;EMPLOYEE_ID&gt; 100 &lt;/ EMPLOYEE_ID&gt; &lt;LAST_NAME&gt; King &lt;/ LAST_NAME&gt; &lt;HIRE_DATE&gt; 6/17/1987 0：0：0 &lt;/ HIRE_DATE&gt; &lt;/ ROW&gt; &lt;！ - 附加行...  - &gt; &lt;/ ROWSET&gt; &lt;/ DOCUMENT&gt;</pre><p>在生成的XML中，SQL查询返回的行是<code class="codeph">&lt;ROWSET&gt;</code>元素的子元素。XML文档具有以下功能：</p>
                        <ul style="list-style-type:disc">
                           <li>
                              <p><code class="codeph">&lt;ROWSET&gt;</code>元素具有零个或多个<code class="codeph">&lt;ROW&gt;</code>子元素，对应于返回的行数。如果查询没有生成任何行，则不包含<code class="codeph">&lt;ROW&gt;</code>元素;如果查询生成一行，则包含一个<code class="codeph">&lt;ROW&gt;</code>元素，依此类推。
                              </p>
                           </li>
                           <li>
                              <p>每个<code class="codeph">&lt;ROW&gt;</code>元素都包含一个表行的数据。具体来说，每个<code class="codeph">&lt;ROW&gt;</code>元素都有一个或多个子元素，其名称和内容与<code class="codeph">SELECT</code>语句中指定的数据库列相同。
                              </p>
                           </li>
                        </ul>
                     </div><a id="ADXDK19479"></a><a id="ADXDK19478"></a><div class="props_rev_3"><a id="GUID-A0899DAA-0B1D-482C-99E6-E995F2B535C8" name="GUID-A0899DAA-0B1D-482C-99E6-E995F2B535C8"></a><h6 id="ADXDK-GUID-A0899DAA-0B1D-482C-99E6-E995F2B535C8" class="sect6">针对对象关系模式的XML映射</h6>
                        <div>
                           <p>XSU可以从对象关系模式生成XML文档。</p>
                           <p>在SQL * Plus中运行<code class="codeph">createObjRelSchema.sql</code>脚本以设置和填充对象关系模式。该模式包含一个<code class="codeph">dept1</code>表，其中有两列使用用户定义的类型。
                           </p>
                           <p>您可以通过<code class="codeph">dept1</code>调用<code class="codeph">dept1</code>来查询<code class="codeph">dept1</code>表：</p><pre class="oac_no_warn" dir="ltr">％java OracleXML getXML -user“hr / <span class="italic">password</span> ”-withschema“SELECT * FROM dept1”</pre><p>XSU返回<a href="using-XML-SQL-utility.html#GUID-A0899DAA-0B1D-482C-99E6-E995F2B535C8__BABBHAFE">示例21-3中</a>显示的XML文档，该文档已更改，以便将多余的行替换为注释。
                           </p>
                           <p>与前面的示例一样，映射是规范的，即<code class="codeph">&lt;ROWSET&gt;</code>包含<code class="codeph">&lt;ROW&gt;</code>子元素，后者又包含与<code class="codeph">dept1</code>的列对应的子元素。例如， <code class="codeph">&lt;DEPTNAME&gt;</code>元素对应于<code class="codeph">dept1.deptname</code>列。与标量类型列对应的元素包含列中的数据。
                           </p>
                           <div class="example" id="GUID-A0899DAA-0B1D-482C-99E6-E995F2B535C8__BABBHAFE">
                              <p class="titleinexample">例21-3 XSU生成的样本文档</p><pre class="oac_no_warn" dir="ltr">&lt;？xml版本='1.0'？&gt; &lt;DOCUMENT xmlns：xsd =“http://www.w3.org/2001/XMLSchema”&gt; &lt;schema targetNamespace =“http://xmlns.oracle.com/xdb/SYSTEM”xmlns =“http：// www .w3.org / 2001 / XMLSchema“xmlns：SYSTEM =”http://xmlns.oracle.com/xdb/SYSTEM“&gt; &lt;！ - 架构元素的子代...  - &gt; &lt;/ xsd：schema&gt; &lt; ROWSET xmlns：xsi =“http://www.w3.org/2001/XMLSchema-instance”xsi：noNamespaceSchemaLocation =“＃/ DOCUMENT / xsd：schema [not（@targetNamespace）]”&gt; &lt;ROW num =“1” &gt; &lt;DEPTNO&gt; 120 &lt;/ DEPTNO&gt; &lt;DEPTNAME&gt;库房&lt;/ DEPTNAME&gt; &lt;DEPTADDR&gt; &lt;STREET&gt; 2004 Charade Rd &lt;/ STREET&gt; &lt;CITY&gt;西雅图&lt;/ CITY&gt; &lt;STATE&gt; WA &lt;/ STATE&gt; &lt;ZIP&gt; 98199 &lt;/ ZIP&gt; &lt;/ DEPTADDR&gt; &lt;EMPLIST&gt; &lt;EMPLIST_ITEM&gt; &lt;EMPLOYEE_ID&gt; 1 &lt;/ EMPLOYEE_ID&gt; &lt;LAST_NAME&gt; Mehta &lt;/ LAST_NAME&gt; &lt;SALARY&gt; 6000 &lt;/ SALARY&gt; &lt;EMPLOYEE_ADDRESS&gt; &lt;STREET&gt; 500 Main Road &lt;/ STREET &gt; &lt;CITY&gt;西雅图&lt;/ CITY&gt; &lt;STATE&gt; WA &lt;/ STATE&gt; &lt;ZIP&gt; 98199 &lt;/ ZIP&gt; &lt;/ EMPLOYEE_ADDRESS&gt; &lt;/ EMPLIST_ITEM&gt; &lt;/ EMPLIST&gt; &lt;/ ROW&gt; &lt;/ ROWSET&gt; &lt;/ DOCUMENT&gt;</pre></div>
                           <!-- class="example" -->
                        </div>
                     </div><a id="ADXDK19480"></a><div class="props_rev_3"><a id="GUID-99C85F15-FAEA-4A8D-954B-0F0283819DF4" name="GUID-99C85F15-FAEA-4A8D-954B-0F0283819DF4"></a><h6 id="ADXDK-GUID-99C85F15-FAEA-4A8D-954B-0F0283819DF4" class="sect6">复杂类型列到XML的默认映射</h6>
                        <div>
                           <p>描述了复杂类型列到XML数据的默认映射。</p>
                           <p>对应于复杂类型列的元素，情况更复杂。在<a href="using-XML-SQL-utility.html#GUID-A0899DAA-0B1D-482C-99E6-E995F2B535C8__BABBHAFE">例21-3中</a> ， <code class="codeph">&lt;DEPTADDR&gt;</code>对应于<code class="codeph">dept1.deptAddr</code>列，该列是对象类型<code class="codeph">AddressType</code> 。因此， <code class="codeph">&lt;DEPTADDR&gt;</code>包含与<code class="codeph">AddressType</code>类型中指定的属性对应的子元素。<code class="codeph">AddressType</code>属性<code class="codeph">street</code>对应于子XML元素<code class="codeph">&lt;STREET&gt;</code>等等。这些子元素可以包含它们自己的数据或子元素，具体取决于它们对应的属性是简单类型还是复杂类型。
                           </p>
                        </div>
                     </div><a id="ADXDK19481"></a><div class="props_rev_3"><a id="GUID-0ECE1E50-CF88-4E63-87E4-C2C6CA856178" name="GUID-0ECE1E50-CF88-4E63-87E4-C2C6CA856178"></a><h6 id="ADXDK-GUID-0ECE1E50-CF88-4E63-87E4-C2C6CA856178" class="sect6">集合到XML的默认映射</h6>
                        <div>
                           <p>描述了数据库集合到XML数据的默认映射。</p>
                           <p>在处理与数据库集合相对应的元素时，情况也不同。在<a href="using-XML-SQL-utility.html#GUID-A0899DAA-0B1D-482C-99E6-E995F2B535C8__BABBHAFE">例21-3中</a> ， <code class="codeph">&lt;EMPLIST&gt;</code>元素对应于<code class="codeph">EmployeeListType</code>类型的<code class="codeph">emplist</code>列。因此， <code class="codeph">&lt;EMPLIST&gt;</code>元素包含的列表<code class="codeph">&lt;EMPLIST_ITEM&gt;</code>元素，每个元素对应于所述集合的元素。注意：</p>
                           <ul style="list-style-type:disc">
                              <li>
                                 <p><code class="codeph">&lt;ROW&gt;</code>元素包含基数属性<code class="codeph">num</code> 。
                                 </p>
                              </li>
                              <li>
                                 <p>如果特定列或属性值为<code class="codeph">NULL</code> ，则对于该行，将省略相应的XML元素。
                                 </p>
                              </li>
                              <li>
                                 <p>如果顶级标量列名称以at符号（ <code class="codeph">@</code> ）开头，则该列将映射到XML属性而不是XML元素。
                                 </p>
                              </li>
                           </ul>
                        </div>
                     </div>
                  </div><a id="ADXDK19482"></a><div class="props_rev_3"><a id="GUID-F74783F7-7230-49F0-BE0E-83F04B5C7A37" name="GUID-F74783F7-7230-49F0-BE0E-83F04B5C7A37"></a><h5 id="ADXDK-GUID-F74783F7-7230-49F0-BE0E-83F04B5C7A37" class="sect5">默认的XML到SQL映射</h5>
                     <div>
                        <p>描述了XML数据到SQL数据的默认映射。</p>
                        <p>XML到SQL映射是SQL到XML映射的反向。使用XSU将XML映射到SQL时，请考虑这些差异：</p>
                        <ul style="list-style-type:disc">
                           <li>
                              <p>将XML转换为SQL时，XSU会忽略XML属性。因此，实际上没有XML属性到SQL的映射。</p>
                           </li>
                           <li>
                              <p>将SQL转换为XML时，XSU会对SQL查询创建的单个<code class="codeph">ResultSet</code>执行映射。查询可以跨多个数据库表或视图。将XML转换为SQL时，请注意：</p>
                              <ul style="list-style-type:disc">
                                 <li>
                                    <p>要将一个XML文档插入多个表或视图，必须在目标模式上创建对象关系视图。</p>
                                 </li>
                                 <li>
                                    <p>如果视图不可更新，则可以使用<code class="codeph">INSTEAD OF INSERT</code>触发器。
                                    </p>
                                 </li>
                              </ul>
                           </li>
                        </ul>
                        <p>如果XML文档未完美映射到目标数据库模式，则可以执行以下操作：</p>
                        <ul style="list-style-type:disc">
                           <li>
                              <p>修改目标。在目标模式上创建对象关系视图，并使视图成为新目标。</p>
                           </li>
                           <li>
                              <p>使用XSLT修改XML文档以转换XML文档。您可以使用XSU注册XSLT样式表，以便在尝试任何映射之前自动转换传入的XML。</p>
                           </li>
                           <li>
                              <p>修改XSU的XML到SQL映射。您可以指示XSU对XML元素与数据库列或属性执行不区分大小写的匹配。例如，您可以指示XSU执行此操作：</p>
                              <ul style="list-style-type:disc">
                                 <li>
                                    <p>使用与数据库行对应的元素的名称而不是<code class="codeph">ROW</code> 。</p>
                                 </li>
                                 <li>
                                    <p>指定在XML文档中解析日期时要使用的日期格式。</p>
                                 </li>
                              </ul>
                           </li>
                        </ul>
                     </div>
                  </div><a id="ADXDK19483"></a><div class="props_rev_3"><a id="GUID-9E8CFEF1-E081-4D54-A397-06823C55F39E" name="GUID-9E8CFEF1-E081-4D54-A397-06823C55F39E"></a><h5 id="ADXDK-GUID-9E8CFEF1-E081-4D54-A397-06823C55F39E" class="sect5">自定义生成的XML</h5>
                     <div>
                        <p>在某些情况下，您可能需要生成具有特定结构的XML。由于所需的结构可能与生成的XML文档的默认结构不同，因此您需要在此过程中具有一定的灵活性。</p>
                        <div class="section"> </div>
                        <!-- class="section" -->
                     </div><a id="ADXDK19485"></a><a id="ADXDK19486"></a><a id="ADXDK19484"></a><div class="props_rev_3"><a id="GUID-9BD36D83-085B-418B-AA50-1A01E3322D41" name="GUID-9BD36D83-085B-418B-AA50-1A01E3322D41"></a><h6 id="ADXDK-GUID-9BD36D83-085B-418B-AA50-1A01E3322D41" class="sect6">更改数据库架构或SQL查询</h6>
                        <div>
                           <p>您可以通过更改SQL查询或数据库架构来执行源自定义。</p>
                           <div class="section">
                              <p>最简单和最强大的源自定义包括：</p>
                           </div>
                           <!-- class="section" -->
                           <div class="section">
                              <ul style="list-style-type:disc">
                                 <li>
                                    <p>在数据库模式中，创建一个映射到所需XML文档结构的对象关系视图。</p>
                                 </li>
                                 <li>
                                    <p>在您的查询中，执行以下操作：</p>
                                    <ul style="list-style-type:disc">
                                       <li>
                                          <p>使用游标子查询或cast-multiset构造在来自平面模式的XML文档中创建嵌套。</p>
                                       </li>
                                       <li>
                                          <p>别名列和属性名称以获取所需的XML元素名称。</p>
                                       </li>
                                       <li>
                                          <p>别名顶级标量类型列，其标识符以at符号（@）开头，以使它们映射到XML属性而不是XML元素。例如，执行这些语句会生成一个XML文档，其中<code class="codeph">&lt;ROW&gt;</code>元素具有属性<code class="codeph">empno</code> ：</p><pre class="oac_no_warn" dir="ltr">SELECT employee_name AS“@empno”，...来自员工;</pre></li>
                                    </ul>
                                 </li>
                              </ul>
                              <p>考虑<a href="using-XML-SQL-utility.html#GUID-9BD36D83-085B-418B-AA50-1A01E3322D41__BABCIAJB">例21-4中</a>显示的<code class="codeph">customer.xml</code>文档。
                              </p>
                              <p>假设您必须设计一组数据库表来存储此数据。由于XML嵌套多个级别，因此可以使用对象关系数据库模式，该模式将规范映射到前面的XML文档。在SQL * Plus中运行<code class="codeph">createObjRelSchema2.sql</code>脚本以创建此类数据库模式。
                              </p>
                              <p>您可以将<code class="codeph">customer.xml</code>文档中的数据加载到脚本创建的<code class="codeph">customer_tab</code>表中。从命令行调用XSU for Java：</p><pre class="oac_no_warn" dir="ltr">java OracleXML putXML -user“hr / <span class="italic">password</span> ”-fileName customer.xml customer_tab</pre><p>要将<code class="codeph">customer.xml</code>加载到非对象关系的数据库模式中，可以在标准关系模式之上的视图中创建对象。例如，您可以创建包含必要列的关系表，然后创建一个包含客户对象的客户视图，如<a href="using-XML-SQL-utility.html#GUID-9BD36D83-085B-418B-AA50-1A01E3322D41__BABBCCEG">示例21-5</a>中的<code class="codeph">createRelSchema.sql</code>脚本所示。
                              </p>
                              <p>您可以将数据加载到<code class="codeph">customer_view</code> ：</p><pre class="oac_no_warn" dir="ltr">java OracleXML putXML -user“hr / <span class="italic">password</span> ”-fileName customer.xml customer_view</pre><p>或者，您可以使用XSLT展平XML，然后将其直接插入关系模式。但是，这是最不推荐的选项。</p>
                              <p>要将特定列或一组列映射到XML属性而不是XML元素，可以为列名创建别名，并在此别名的名称前添加at符号（@）。例如，您可以使用<code class="codeph">mapColumnToAtt.sql</code>脚本查询<code class="codeph">hr.employees</code>表，将<code class="codeph">employee_id</code>呈现为XML属性。
                              </p>
                              <p>您可以从命令行运行<code class="codeph">mapColumnToAtt.sql</code>脚本：</p><pre class="oac_no_warn" dir="ltr">java OracleXML getXML -user“hr / <span class="italic">password</span> ”-fileName“mapColumnToAtt.sql”</pre><div class="infoboxnote" id="GUID-9BD36D83-085B-418B-AA50-1A01E3322D41__GUID-7F410CB4-C4B1-4A73-A6EA-0BDEEA414ED8">
                                 <p class="notep1">注意：</p>
                                 <p>所有属性必须出现<span class="italic">在</span>任何非属性<span class="italic">之前</span> 。
                                 </p>
                              </div>
                           </div>
                           <!-- class="section" -->
                           <div class="example" id="GUID-9BD36D83-085B-418B-AA50-1A01E3322D41__BABCIAJB">
                              <p class="titleinexample">例21-4 customer.xml</p><pre class="oac_no_warn" dir="ltr">&lt;？xml版本=“1.0”？&gt; &lt;ROWSET&gt; &lt;ROW num =“1”&gt; &lt;CUSTOMER&gt; &lt;CUSTOMERID&gt; 1044 &lt;/ CUSTOMERID&gt; &lt;FIRSTNAME&gt; Paul &lt;/ FIRSTNAME&gt; &lt;LASTNAME&gt; Astoria &lt;/ LASTNAME&gt; &lt;HOMEADDRESS&gt; &lt;STREET&gt; 123 Cherry Lane &lt;/街道&gt; &lt;CITY&gt; SF &lt;/ CITY&gt; &lt;STATE&gt; CA &lt;/ STATE&gt; &lt;ZIP&gt; 94132 &lt;/ ZIP&gt; &lt;/ HOMEADDRESS&gt; &lt;/ CUSTOMER&gt; &lt;/ ROW&gt; &lt;/ ROWSET&gt;</pre></div>
                           <!-- class="example" -->
                           <div class="example" id="GUID-9BD36D83-085B-418B-AA50-1A01E3322D41__BABBCCEG">
                              <p class="titleinexample">例21-5 createRelSchema.sql</p><pre class="oac_no_warn" dir="ltr">CREATE TABLE hr.cust_tab（customerid NUMBER（10），firstname VARCHAR2（20），lastname VARCHAR2（20），street VARCHAR2（40），city VARCHAR2（20），state VARCHAR2（20），zip VARCHAR2（20））; CREATE VIEW customer_view AS SELECT customer_type（customerid，firstname，lastname，address_type（street，city，state，zip））customer FROM cust_tab;</pre></div>
                           <!-- class="example" -->
                        </div>
                     </div><a id="ADXDK19487"></a><div class="props_rev_3"><a id="GUID-F32325DC-C31E-4EEC-B778-F960E9AB606C" name="GUID-F32325DC-C31E-4EEC-B778-F960E9AB606C"></a><h6 id="ADXDK-GUID-F32325DC-C31E-4EEC-B778-F960E9AB606C" class="sect6">修改XSU</h6>
                        <div>
                           <p>XSU允许您修改用于将SQL数据转换为XML的规则。</p>
                           <p>将SQL映射到XML时，可以进行以下任何更改：</p>
                           <ul style="list-style-type:disc">
                              <li>
                                 <p>更改或省略<code class="codeph">&lt;ROWSET&gt;</code>或<code class="codeph">&lt;ROW&gt;</code>标记。
                                 </p>
                              </li>
                              <li>
                                 <p>更改或省略属性<code class="codeph">num</code> ，它是<code class="codeph">&lt;ROW&gt;</code>元素的基数属性。
                                 </p>
                              </li>
                              <li>
                                 <p>指定生成的XML元素名称的大小写。</p>
                              </li>
                              <li>
                                 <p>指定与集合元素对应的XML元素必须具有基数属性。</p>
                              </li>
                              <li>
                                 <p>在XML文档中指定日期的格式。</p>
                              </li>
                              <li>
                                 <p>指定必须使用nullness属性指示XML文档中的空值，而不是省略该元素。</p>
                              </li>
                           </ul>
                        </div>
                     </div>
                  </div>
               </div><a id="ADXDK19488"></a><div class="props_rev_3"><a id="GUID-67C89C5D-ACB8-4DC0-850B-64A3DEA2BC07" name="GUID-67C89C5D-ACB8-4DC0-850B-64A3DEA2BC07"></a><h4 id="ADXDK-GUID-67C89C5D-ACB8-4DC0-850B-64A3DEA2BC07" class="sect4">XSU如何处理SQL语句</h4>
                  <div>
                     <p>描述了XSU如何处理SQL语句。</p>
                  </div><a id="ADXDK19489"></a><div class="props_rev_3"><a id="GUID-96EB8765-1F41-4E7E-9E9A-0E6864CB795A" name="GUID-96EB8765-1F41-4E7E-9E9A-0E6864CB795A"></a><h5 id="ADXDK-GUID-96EB8765-1F41-4E7E-9E9A-0E6864CB795A" class="sect5">XSU如何查询数据库</h5>
                     <div>
                        <p>XSU执行SQL查询并从数据库中检索<code class="codeph">ResultSet</code> 。然后，XSU获取并分析有关<code class="codeph">ResultSet</code>元数据。
                        </p>
                        <p>使用<a href="using-XML-SQL-utility.html#GUID-15AC5AA9-6628-44A3-BF97-B0C0EBD81976" title="The default mapping of SQL data to XML data is described.">Default SQL-to-XML Mapping中</a>描述的<a href="using-XML-SQL-utility.html#GUID-15AC5AA9-6628-44A3-BF97-B0C0EBD81976" title="描述了SQL数据到XML数据的默认映射。">映射</a> ，XSU处理SQL结果集并将其转换为XML文档。
                        </p>
                        <p>XSU无法处理某些类型的查询，尤其是在<code class="codeph">SELECT</code>子句中将<code class="codeph">LONG</code>或<code class="codeph">LONG RAW</code>类型的列与<code class="codeph">CURSOR()</code>表达式混合的查询。<code class="codeph">LONG</code>和<code class="codeph">LONG RAW</code>是JDBC作为流访问并且不推荐使用它们的数据类型的两个示例。如果将这些列迁移到<code class="codeph">CLOBs</code> ，则查询会成功。
                        </p>
                     </div>
                  </div><a id="ADXDK19490"></a><div class="props_rev_3"><a id="GUID-A8CBE301-616E-42E7-949E-D4E7EF61ED84" name="GUID-A8CBE301-616E-42E7-949E-D4E7EF61ED84"></a><h5 id="ADXDK-GUID-A8CBE301-616E-42E7-949E-D4E7EF61ED84" class="sect5">XSU如何插入行</h5>
                     <div>
                        <p>描述了在将XML文档插入表或视图时XSU执行的步骤。</p>
                        <p>将XML文档的内容插入表或视图时，XSU执行以下操作：</p>
                        <ol>
                           <li>
                              <p>检索有关目标表或视图的元数据。</p>
                           </li>
                           <li>
                              <p>根据元数据生成SQL <code class="codeph">INSERT</code>语句。例如，假设目标表是<code class="codeph">dept1</code> ，而XML文档是从<code class="codeph">dept1</code>生成的。XSU生成此<code class="codeph">INSERT</code>语句：</p><pre class="oac_no_warn" dir="ltr">INSERT INTO dept1（deptno，deptname，deptaddr，emplist）VALUES（？，？，？，？）
</pre></li>
                           <li>
                              <p>解析XML文档，并为每条记录将适当的值绑定到适当的列或属性。例如，它绑定<code class="codeph">INSERT</code>语句的值：</p><pre class="oac_no_warn" dir="ltr">deptno &lt; -  100 deptname &lt; -  SPORTS deptaddr &lt; -  AddressType（'100 Redwood Shores Pkwy'，'Redwood Shores'，'CA'，'94065'）emplist &lt; -  EmployeeListType（EmployeeType（7369，'John'，100000，AddressType（ '300 Embarcadero'，'Palo Alto'，'CA'，'94056'），...）
</pre></li>
                           <li>
                              <p>执行声明。您可以优化<code class="codeph">INSERT</code>处理以批量插入并批量提交。
                              </p>
                           </li>
                        </ol>
                     </div>
                     <div>
                        <div class="relinfo">
                           <p><strong>相关话题</strong></p>
                           <ul>
                              <li><a href="using-XML-SQL-utility.html#GUID-15AC5AA9-6628-44A3-BF97-B0C0EBD81976" title="描述了SQL数据到XML数据的默认映射。">默认的SQL到XML映射</a></li>
                           </ul>
                        </div>
                        <div class="infoboxnotealso" id="GUID-A8CBE301-616E-42E7-949E-D4E7EF61ED84__GUID-5A066F06-FFDD-4845-BF8C-0D942E8D1EF9">
                           <p class="notep1">也可以看看：</p>
                           <p><a href="using-XML-SQL-utility.html#GUID-555483DC-5765-4E8B-B99A-96832941FB54" title="要将文档插入表或视图，请提供表或视图名称和文档。XSU解析文档并创建一个INSERT语句，它将值绑定到该语句中。默认情况下，XSU将值插入表或视图的所有列。">使用OracleXMLSave插入行以</a>获取有关批处理的更多详细信息</p>
                        </div>
                     </div>
                     
                  </div><a id="ADXDK19491"></a><div class="props_rev_3"><a id="GUID-ED1B2C18-4548-4AEB-B94D-3610375D9A2E" name="GUID-ED1B2C18-4548-4AEB-B94D-3610375D9A2E"></a><h5 id="ADXDK-GUID-ED1B2C18-4548-4AEB-B94D-3610375D9A2E" class="sect5">XSU如何更新行</h5>
                     <div>
                        <p>更新和删除语句与插入的不同之处在于它们可能会影响数据库表中的多个行。</p>
                        <p>对于插入，如果表中没有触发器或约束，则XML文档的每个<code class="codeph">&lt;ROW&gt;</code>元素最多只能影响表中的一行。通过更新和删除，如果匹配的列不是表中的键列，则XML元素可以匹配多个行。
                        </p>
                        <p>对于update语句，您必须提供XSU必须标识要更新的行的键列的列表。例如，假设您有一个包含此片段的XML文档：</p><pre class="pre codeblock"><code>&lt;ROWSET&gt; &lt;ROW num =“1”&gt; &lt;DEPTNO&gt; 100 &lt;/ DEPTNO&gt; &lt;DEPTNAME&gt; SportsDept &lt;/ DEPTNAME&gt; &lt;/ ROW&gt; &lt;/ ROWSET&gt;</code></pre><p>您想要将<code class="codeph">DEPTNAME</code>值从<code class="codeph">Sports</code>更改为<code class="codeph">SportsDept</code> 。如果您将<code class="codeph">DEPTNO</code>作为键列提供，则XSU会生成此<code class="codeph">UPDATE</code>语句：</p><pre class="pre codeblock"><code>UPDATE dept1 SET deptname =？在哪里deptno =？
</code></pre><p>XSU以这种方式绑定值：</p><pre class="pre codeblock"><code>deptno &lt; -  100 deptname &lt; -  SportsDept</code></pre><p>对于更新，您还可以选择仅更新一组列，而不是更新XML文档中存在的所有元素。</p>
                     </div>
                     <div>
                        <div class="relinfo">
                           <p><strong>相关话题</strong></p>
                           <ul>
                              <li><a href="using-XML-SQL-utility.html#GUID-646799B4-73D6-4AD1-94F1-E614343D65F6" title="示例显示如何更新表或视图中的字段。您提供表或视图名称和XML文档。XSU解析文档（如果给出了字符串）并创建一个或多个UPDATE语句，它将所有值绑定到该语句中。">使用OracleXMLSave更新行</a></li>
                           </ul>
                        </div>
                     </div>
                     
                  </div><a id="ADXDK19492"></a><div class="props_rev_3"><a id="GUID-1333299E-2764-42FC-ACBF-FD1AC00BCF4B" name="GUID-1333299E-2764-42FC-ACBF-FD1AC00BCF4B"></a><h5 id="ADXDK-GUID-1333299E-2764-42FC-ACBF-FD1AC00BCF4B" class="sect5">XSU如何删除行</h5>
                     <div>
                        <p>对于行删除，您可以选择提供一组键列，以便XSU可以识别要删除的行。如果未提供一组键列，则<code class="codeph">DELETE</code>语句将尝试匹配文档中的所有列。
                        </p>
                        <p>假设您将此文档传递给XSU：</p><pre class="pre codeblock"><code>&lt;ROWSET&gt; &lt;ROW num =“1”&gt; &lt;DEPTNO&gt; 100 &lt;/ DEPTNO&gt; &lt;DEPTNAME&gt;体育&lt;/ DEPTNAME&gt; &lt;DEPTADDR&gt; &lt;STREET&gt; 100 Redwood Shores Pkwy &lt;/ STREET&gt; &lt;CITY&gt; Redwood Shores &lt;/ CITY&gt; &lt;STATE&gt; CA &lt;/ STATE&gt; &lt;ZIP&gt; 94065 &lt;/ ZIP&gt; &lt;/ DEPTADDR&gt; &lt;/ ROW&gt; &lt;！ - 其他行...  - &gt; &lt;/ ROWSET&gt;</code></pre><p>XSU为每个<code class="codeph">ROW</code>元素构建一个<code class="codeph">DELETE</code>语句：</p><pre class="pre codeblock"><code>DELETE FROM dept1 WHERE deptno =？和deptname =？和deptaddr =？
</code></pre><p>绑定是：</p><pre class="pre codeblock"><code>deptno &lt; -  100 deptname &lt; -  sports deptaddr &lt; -  addresstype（'100 redwood shores pkwy'，'redwood city'，'ca'，'94065'）</code></pre></div>
                     <div>
                        <div class="relinfo">
                           <p><strong>相关话题</strong></p>
                           <ul>
                              <li><a href="using-XML-SQL-utility.html#GUID-2E4CC584-0613-4BC2-9C9B-252AE6A91A84" title="从XML文档中删除时，可以指定键列的列表。XSU在DELETE语句的WHERE子句中使用这些列。如果您不提供键列名，则XSU会为XML文档的每个ROW元素创建一个新的DELETE语句。">使用XSU删除行</a></li>
                           </ul>
                        </div>
                     </div>
                     
                  </div><a id="ADXDK19493"></a><div class="props_rev_3"><a id="GUID-F30015F9-A177-4E4A-A9B5-7540DE85906C" name="GUID-F30015F9-A177-4E4A-A9B5-7540DE85906C"></a><h5 id="ADXDK-GUID-F30015F9-A177-4E4A-A9B5-7540DE85906C" class="sect5">XSU如何在DML之后提交</h5>
                     <div>
                        <p>默认情况下，XSU不执行显式提交。如果启用了<code class="codeph">AUTOCOMMIT</code> ，这是JDBC连接的默认设置，则在每批语句执行后，XSU执行<code class="codeph">COMMIT</code> 。</p>
                        <p>您可以通过关闭<code class="codeph">AUTOCOMMIT</code>然后使用<code class="codeph">setCommitBatch</code>指定<code class="codeph">setCommitBatch</code>提交之前的语句执行次数来覆盖此行为。如果发生错误，则XSU将回滚到目标表在调用XSU之前所处的状态，或者在当前调用XSU期间最后一次提交之后的状态。</p>
                     </div>
                  </div>
               </div>
            </div>
         </div>
      </article>
   </body>
</html>