<html lang="en-us" dir="ltr" xml:lang="en-us">
   <head>
      <meta http-equiv="Content-Type" content="text/html; charset=utf-8"></meta>
      <meta name="viewport" content="width=device-width, initial-scale=1"></meta>
      <meta http-equiv="X-UA-Compatible" content="IE=edge"></meta>
      <meta name="abstract" content="You can use SQL to query property graph data in Oracle Spatial and Graph."></meta>
      <meta name="description" content="You can use SQL to query property graph data in Oracle Spatial and Graph."></meta>
      <title>基于SQL的属性图查询和分析</title>
      <meta property="og:site_name" content="Oracle Help Center"></meta>
      <meta property="og:title" content="Property Graph Developer’s Guide"></meta>
      <meta property="og:description" content="You can use SQL to query property graph data in Oracle Spatial and Graph."></meta>
      <link rel="stylesheet" href="/sp_common/book-template/ohc-book-template/css/book.css"></link>
      <link rel="shortcut icon" href="/sp_common/book-template/ohc-common/img/favicon.ico"></link>
      <meta name="application-name" content="Property Graph Developer’s Guide"></meta>
      <meta name="generator" content="DITA Open Toolkit version 1.8.5 (Mode = doc)"></meta>
      <meta name="plugin" content="SP_docbuilder HTML plugin release 18.2.2"></meta>
      <link rel="alternate" href="spatial-and-graph-property-graph-developers-guide.pdf" title="PDF File" type="application/pdf"></link>
      <meta name="robots" content="all"></meta>
      <link rel="schema.dcterms" href="http://purl.org/dc/terms/"></link>
      <meta name="dcterms.created" content="2019-01-10T15:23:57-08:00"></meta>
      
      <meta name="dcterms.dateCopyrighted" content="2016, 2019"></meta>
      <meta name="dcterms.category" content="database"></meta>
      <meta name="dcterms.identifier" content="E94800-01"></meta>
      
      <meta name="dcterms.product" content="en/database/oracle/oracle-database/19"></meta>
      
      <link rel="prev" href="using-inmemory-analyst-oracle-database.html" title="Previous" type="text/html"></link>
      <link rel="next" href="OPG_APIS-reference.html" title="Next" type="text/html"></link>
      <script>
        document.write('<style type="text/css">');
        document.write('body > .noscript, body > .noscript ~ * { visibility: hidden; }');
        document.write('</style>');
     </script>
      <script src="/sp_common/book-template/requirejs/require.js" data-main="/sp_common/book-template/ohc-book-template/js/book-config"></script>
      <script>
            if (window.require === undefined) {
                document.write('<script data-main="sp_common/book-template/ohc-book-template/js/book-config" src="sp_common/book-template/requirejs/require.js"><\/script>');
                document.write('<link href="sp_common/book-template/ohc-book-template/css/book.css" rel="stylesheet"/>');
            }
        </script>
      <script type="application/json" id="ssot-metadata">{"primary":{"category":{"short_name":"database","element_name":"Database","display_in_url":true},"suite":{"short_name":"oracle","element_name":"Oracle","display_in_url":true},"product_group":{"short_name":"not-applicable","element_name":"Not applicable","display_in_url":false},"product":{"short_name":"oracle-database","element_name":"Oracle Database","display_in_url":true},"release":{"short_name":"19","element_name":"Release 19","display_in_url":true}}}</script>
      
    <meta name="dcterms.title" content="Spatial and Graph Property Graph Developer&#39;s Guide"></meta>
    <meta name="dcterms.isVersionOf" content="SPGDG"></meta>
    <meta name="dcterms.release" content="Release 19"></meta>
  </head>
   <body dir="ltr">
      <div class="noscript alert alert-danger text-center" role="alert">
         <a href="using-inmemory-analyst-oracle-database.html" class="pull-left"><span class="glyphicon glyphicon-chevron-left" aria-hidden="true"></span>上一页</a> <a href="OPG_APIS-reference.html" class="pull-right">下一页<span class="glyphicon glyphicon-chevron-right" aria-hidden="true"></span></a> <span class="fa fa-exclamation-triangle" aria-hidden="true"></span>必须启用JavaScript才能正确显示此内容</div>
      <article>
         <header>
            <ol class="breadcrumb" vocab="http://schema.org/" typeof="BreadcrumbList">
               <li property="itemListElement" typeof="ListItem"><a href="index.html" property="item" typeof="WebPage"><span property="name">Property Graph开发人员指南</span></a></li>
               <li class="active" property="itemListElement" typeof="ListItem">基于SQL的属性图查询和分析</li>
            </ol>
            <a id="GUID-C5CC6650-0375-4F32-8317-BAF859C1909C" name="GUID-C5CC6650-0375-4F32-8317-BAF859C1909C"></a>
            
            <h2 id="SPGDG-GUID-C5CC6650-0375-4F32-8317-BAF859C1909C" class="sect2"><span class="enumeration_chapter">4</span>基于SQL的属性图查询和分析</h2>
         </header>
         <div class="ind">
            <div>
               <p>您可以使用SQL在Oracle Spatial and Graph中查询属性图数据。</p>
               <p>对于Oracle Spatial and Graph中的属性图支持，所有顶点和边数据都以Oracle数据库中的关系形式保存。有关Oracle Spatial和Graph属性图模式对象的详细信息，请参阅<a href="using-property-graphs-oracle-database.html#GUID-728A5FBC-998C-4675-9C0A-31C9195B737D" title="属性图PL / SQL和Java API使用特殊的Oracle数据库模式对象。">Oracle数据库的属性图模式对象</a> 。
               </p>
               <p>本章提供了使用SQL实现的典型图形查询的示例。受众包括DBA以及了解SQL语法和属性图模式对象的应用程序开发人员。</p>
               <p>使用SQL直接查询属性图的好处包括：</p>
               <ul style="list-style-type:disc">
                  <li>
                     <p>无需将数据引入Oracle数据库之外。</p>
                  </li>
               </ul>
               <ul style="list-style-type:disc">
                  <li>
                     <p>您可以利用Oracle数据库提供的经过行业验证的SQL引擎。</p>
                  </li>
               </ul>
               <ul style="list-style-type:disc">
                  <li>
                     <p>您可以轻松地将属性图数据与其他数据类型（关系，JSON，XML等）连接或集成。</p>
                  </li>
               </ul>
               <ul style="list-style-type:disc">
                  <li>
                     <p>您可以利用现有的Oracle SQL调优和数据库管理工具以及用户界面。</p>
                  </li>
               </ul>
               <p>这些示例假定在当前模式中存在名为<code class="codeph"><span class="bold">connections</span></code>的属性图。SQL查询和示例输出仅用于说明目的，您的输出可能会有所不同，具体取决于<code class="codeph">connections</code>图中的数据。在一些示例中，输出被重新格式化以便于阅读。
               </p>
            </div>
            <div>
               <ul class="ullinks">
                  <li class="ulchildlink"><a href="sql-based-property-graph-query-analytics.html#GUID-DA3E5ADB-5851-4686-8418-EFF473794846">简单属性图查询</a><br>本主题中的示例查询图的顶点，边和属性。
                  </li>
                  <li class="ulchildlink"><a href="sql-based-property-graph-query-analytics.html#GUID-A96D9A39-60CB-4E89-B5C5-EEC8E811C734">属性图上的文本查询</a><br>如果属性（顶点属性或边属性）的值包含自由文本，则可能有助于在V列上创建Oracle Text索引。
                  </li>
                  <li class="ulchildlink"><a href="sql-based-property-graph-query-analytics.html#GUID-7B2B2D5C-A561-4ECD-B690-ABA795E07BDA">导航和图形模式匹配</a><br>使用图形数据模型的一个主要好处是，您可以轻松地在建模为顶点的实体（人物，电影，产品，服务，事件等）之间进行导航，遵循建模为边缘的链接和关系。此外，可以定义图匹配模板来执行诸如检测模式，聚合个体和分析趋势之类的事情。
                  </li>
                  <li class="ulchildlink"><a href="sql-based-property-graph-query-analytics.html#GUID-81370EE3-3917-4CA6-BB22-F7AA434EDB09">导航选项：CONNECT BY和并行递归</a><br>CONNECT BY子句和并行递归提供高级导航和查询的选项。
                  </li>
                  <li class="ulchildlink"><a href="sql-based-property-graph-query-analytics.html#GUID-3F810D6C-CC45-4612-ADAB-C1B2B9873734">枢</a><br>PIVOT子句允许您动态地向表中添加列以创建新表。
                  </li>
                  <li class="ulchildlink"><a href="sql-based-property-graph-query-analytics.html#GUID-01E928F5-C8E1-4109-A63E-257B1F4AEDC6">基于SQL的属性图分析</a><br>除了内存分析师提供的分析功能外，Oracle Spatial and Graph中的属性图功能还支持几种基于SQL的本机属性图分析。
                  </li>
                  <li class="ulchildlink"><a href="sql-based-property-graph-query-analytics.html#GUID-301FF092-1A07-43D2-91E5-0C5AFF3467CC">属性图查询语言（PGQL）</a><br>PGQL是针对包括由<span class="italic">边</span>连接到其它节点<span class="italic">的节点</span> ，其中的每一个可具有与其相关联的键-值对（属性）的属性的图形数据结构类似于SQL的查询语言。
                  </li>
                  <li class="ulchildlink"><a href="sql-based-property-graph-query-analytics.html#GUID-94F08780-EC3D-4F9B-985F-49984939E61C">直接针对Oracle数据库执行PGQL查询</a><br>本主题说明如何直接对Oracle数据库中的图形执行PGQL查询（而不是内存中）。
                  </li>
               </ul>
            </div>
            
            <div class="props_rev_3"><a id="GUID-DA3E5ADB-5851-4686-8418-EFF473794846" name="GUID-DA3E5ADB-5851-4686-8418-EFF473794846"></a><h3 id="SPGDG-GUID-DA3E5ADB-5851-4686-8418-EFF473794846" class="sect3"><span class="enumeration_section">4.1</span>简单属性图查询</h3>
               <div>
                  <p>本主题中的示例查询图的顶点，边和属性。</p>
                  <div class="example" id="GUID-DA3E5ADB-5851-4686-8418-EFF473794846__FINDAVERTEXWITHASPECIFIEDVERTEXID-0857F724">
                     <p class="titleinexample">示例4-1查找具有指定顶点ID的顶点</p>
                     <p>此示例在<code class="codeph">connections</code>图中查找顶点ID为1的顶点。
                     </p><pre class="pre codeblock"><code>SQL&gt; select vid，k，v，vn，vt来自connectionsVT $，其中vid = 1;</code></pre><p>输出可能如下：</p><pre class="oac_no_warn" dir="ltr">1个国家美国1名Barack Obama 1职业美利坚合众国第44任总统......
</pre></div>
                  <!-- class="example" -->
                  <div class="example" id="GUID-DA3E5ADB-5851-4686-8418-EFF473794846__FINDANEDGEWITHASPECIFIEDEDGEID-0857FB2C">
                     <p class="titleinexample">示例4-2查找具有指定边缘ID的边</p>
                     <p>此示例在<code class="codeph">connections</code>图中查找边ID为100的边。
                     </p><pre class="pre codeblock"><code>SQL&gt;从connectionsGE $中选择eid，svid，dvid，k，t，v，vn，vt，其中eid = 1000;</code></pre><p>输出可能如下：</p><pre class="oac_no_warn" dir="ltr">1000 1 2重量3 1 1</pre><p>在前面的输出中，edge属性的K是“weight”，值的类型ID是3，表示浮点值。</p>
                  </div>
                  <!-- class="example" -->
                  <div class="example" id="GUID-DA3E5ADB-5851-4686-8418-EFF473794846__PERFORMSIMPLECOUNTING-085800A7">
                     <p class="titleinexample">例4-3执行简单计数</p>
                     <p>此示例在<code class="codeph">connections</code>图中执行简单计数。
                     </p><pre class="pre codeblock"><code>SQL&gt;  - 获取所有顶点的K / V对的总数SQL&gt; select / * + parallel * / count（1）from connectionsVT $; 299 SQL&gt;  - 获取所有边的K / V对的总数SQL&gt; select / * + parallel（8）* / count（1）from connectionsGE $; 164 SQL&gt;  - 从connectionsVT $中获取顶点的总数SQL&gt; select / * + parallel * / count（distinct vid）; 78 SQL&gt;  - 从connectionsGE $中获取边的总数SQL&gt; select / * + parallel * / count（distinct eid）; 164</code></pre></div>
                  <!-- class="example" -->
                  <div class="example" id="GUID-DA3E5ADB-5851-4686-8418-EFF473794846__GETTHESETOFPROPERTYKEYSUSED-0858058D">
                     <p class="titleinexample">示例4-4获取使用的属性键集</p>
                     <p>此示例获取用于<code class="codeph">connections</code>图顶点的属性键集。
                     </p><pre class="pre codeblock"><code>SQL&gt; select / * + parallel * / distinct k来自connectionsVT $;公司展示职业类型团队宗教刑事指控音乐流派类型名称角色政党国家13行选择。SQL&gt;  - 获取用于边缘的属性键集合SQL&gt; select / * + parallel * / distinct k from connectionsGE $;重量</code></pre></div>
                  <!-- class="example" -->
                  <div class="example" id="GUID-DA3E5ADB-5851-4686-8418-EFF473794846__FINDVERTICESWITHAVALUE-085809A2">
                     <p class="titleinexample">示例4-5查找具有值的顶点</p>
                     <p>此示例查找具有String类型（任何属性）的值的顶点，其中和值包含a，e，i，o或u的两个相邻出现，而不管大小写。 <code class="codeph">connections</code>图。
                     </p><pre class="pre codeblock"><code>SQL&gt; select来自connectionsVT $的vid，t，k，v，其中t = 1和regexp_like（v，'（[aeiou]）\ 1'，'i'）; 6 1名Jordan Peele 6 1名表示Key和Peele 54 1名John Green ...
</code></pre><p>通常很难将B-Tree索引用于前面的查询类型，因为很难事先知道将使用哪种正则表达式。对于上述查询，您可能会获得以下执行计划。请注意，优化程序会选择全表扫描。</p><pre class="oac_no_warn" dir="ltr">-------------------------------------------------- -------------------------------------------------- -------------------------------- | Id |操作|名称|行|字节|成本（％CPU）|时间| Pstart时| Pstop | TQ | IN-OUT | PQ Distrib | -------------------------------------------------- -------------------------------------------------- -------------------------------- | 0 |选择声明| | 15 | 795 | 28（0）| 00:00:01 | | | | | | | 1 | PX COORDINATOR | | | | | | | | | | | | 2 | PX SEND QC（RANDOM）| ：TQ10000 | 15 | 795 | 28（0）| 00:00:01 | | | Q1,00 | P-&gt; S | QC（兰德）| | 3 | PX BLOCK ITERATOR | | 15 | 795 | 28（0）| 00:00:01 | 1 | 8 | Q1,00 | PCWC | | | * 4 | <span class="bold">表访问完全</span> | CONNECTIONSVT $ | 15 | 795 | 28（0）| 00:00:01 | 1 | 8 | Q1,00 | PCWP | | -------------------------------------------------- -------------------------------------------------- --------------------------------谓词信息（由操作ID标识）：--------- ------------------------------------------ 4  -  filter（INTERNAL_FUNCTION（“V “）AND REGEXP_LIKE（”V“，U'（[aeiou]）\ 005C1'，'i'）和”T“= 1 AND INTERNAL_FUNCTION（”K“））注-----  - 平行度为2因为表属性</pre><p>如果Oracle Database In-Memory选项可用且内存足够，则可以帮助将表（完整表或一组相关列）放入内存中。实现这一目标的一种方法如下：</p><pre class="pre codeblock"><code>SQL&gt; alter table connectionsVT $ inmemory;表改变了。
</code></pre><p>现在，输入包含正则表达式的相同SQL会显示执行“TABLE ACCESS INMEMORY FULL”的计划。</p><pre class="oac_no_warn" dir="ltr">-------------------------------------------------- -------------------------------------------------- ---------------------------------------- | Id |操作|名称|行|字节|成本（％CPU）|时间| Pstart时| Pstop | TQ | IN-OUT | PQ Distrib | -------------------------------------------------- -------------------------------------------------- ----------------------------------------- | 0 |选择声明| | 15 | 795 | 28（0）| 00:00:01 | | | | | | | 1 | PX COORDINATOR | | | | | | | | | | | | 2 | PX SEND QC（RANDOM）| ：TQ10000 | 15 | 795 | 28（0）| 00:00:01 | | | Q1,00 | P-&gt; S | QC（兰德）| | 3 | PX BLOCK ITERATOR | | 15 | 795 | 28（0）| 00:00:01 | 1 | 8 | Q1,00 | PCWC | | | * 4 | <span class="bold">表访问INMEMORY FULL</span> | CONNECTIONSVT $ | 15 | 795 | 28（0）| 00:00:01 | 1 | 8 | Q1,00 | PCWP | | -------------------------------------------------- -------------------------------------------------- -----------------------------------------谓词信息（由操作ID标识）： -------------------------------------------------- -  4  - 滤波器（INTERNAL_FUNCTION（“V”）AND REGEXP_LIKE（“V”，U'（[aeiou]）\ 005C1'，'i'）和“T”= 1 AND INTERNAL_FUNCTION（“K”））注 - ---  - 由于表属性，并行度为2</pre></div>
                  <!-- class="example" -->
               </div>
               <div>
                  <div class="familylinks">
                     <div class="parentlink">
                        <p><strong>父主题：</strong> <a href="sql-based-property-graph-query-analytics.html#GUID-C5CC6650-0375-4F32-8317-BAF859C1909C" title="您可以使用SQL在Oracle Spatial and Graph中查询属性图数据。">基于SQL的属性图查询和分析</a></p>
                     </div>
                  </div>
               </div>
               
            </div>
            <div class="props_rev_3"><a id="GUID-A96D9A39-60CB-4E89-B5C5-EEC8E811C734" name="GUID-A96D9A39-60CB-4E89-B5C5-EEC8E811C734"></a><h3 id="SPGDG-GUID-A96D9A39-60CB-4E89-B5C5-EEC8E811C734" class="sect3"><span class="enumeration_section">4.2</span>属性图上的文本查询</h3>
               <div>
                  <p>如果属性（顶点属性或边属性）的值包含自由文本，则可能有助于在V列上创建Oracle Text索引。</p>
                  <p>Oracle Text可以处理直接存储在数据库中的文本。文本可以是短字符串（例如名称或地址），也可以是完整文档。这些文档可以是各种文本格式。</p>
                  <p>文本也可以是许多不同的语言。Oracle Text可以处理任何以空格分隔的语言（包括希腊语或西里尔语等字符集）。此外，Oracle Text能够处理中文，日文和韩文的图形语言）</p>
                  <p>由于属性图功能使用NVARCHAR类型列来更好地支持Unicode，因此<span class="bold"><span class="italic">强烈建议</span></span>将UTF8（AL32UTF8）用作数据库字符集。
                  </p>
                  <p>要在顶点表（或边表）上创建Oracle Text索引，需要ALTER SESSION权限。例如：</p><pre class="pre codeblock"><code>SQL&gt;将alter session授予&lt;YOUR_USER_SCHEMA_HERE&gt;;</code></pre><p>如果需要自定义，还要在CTX_DDL上授予EXECUTE特权：</p><pre class="pre codeblock"><code>SQL&gt;将ctx_ddl上的execute赋予&lt;YOUR_USER_SCHEMA_HERE&gt;;</code></pre><p>以下显示了向SCOTT授予这些权限的一些示例语句。</p><pre class="pre codeblock"><code>SQL&gt; conn / as sysdba已连接。SQL&gt;  - 这是一个PDB设置 -  SQL&gt; alter session set container = orcl;会话改变了。SQL&gt;将ctx_ddl上的执行授予scott;格兰特成功了。SQL&gt;将alter session授予scott;格兰特成功了。
</code></pre><div class="example" id="GUID-A96D9A39-60CB-4E89-B5C5-EEC8E811C734__GUID-66A640E6-CE39-4297-BED9-0C4D05C028C2">
                     <p class="titleinexample">示例4-6 <span class="bold">创建文本索引</span></p>
                     <p>此示例在SCOTT模式中的连接图的顶点表（V列）上创建Oracle Text索引。请注意，与Apache Lucene或Apache SolrCloud提供的文本索引功能不同，此处创建的Oracle Text索引适用于<span class="bold"><span class="italic">所有</span></span>属性键，而不仅仅是属性键的一个或子集。此外，如果向图中添加了新属性，并且属性值为String数据类型，则它将自动包含在同一文本索引中。
                     </p>
                     <p>该示例使用MDSYS拥有的OPG_AUTO_LEXER词法分析器。</p><pre class="pre codeblock"><code>SQL&gt; execute opg_apis.create_vertices_text_idx（'scott'，'connections'，pref_owner =&gt;'MDSYS'，lexer =&gt;'OPG_AUTO_LEXER'，dop =&gt; 2）;</code></pre><p>如果需要自定义，可以使用ctx_ddl.create_preference API。例如：</p><pre class="pre codeblock"><code>SQL&gt;  - 以下要求对CTX_DDL SQL&gt; exec ctx_ddl.create_preference（'SCOTT.OPG_AUTO_LEXER'，'AUTO_LEXER'）的访问权限; PL / SQL过程成功完成。SQL&gt; execute opg_apis.create_vertices_text_idx（'scott'，'connections'，pref_owner =&gt;'scott'，lexer =&gt;'OPG_AUTO_LEXER'，dop =&gt; 2）; PL / SQL过程成功完成。
</code></pre><p>您现在可以使用Oracle Text提供的一组丰富的函数来执行对图元素的查询。</p>
                     <div class="infoboxnote" id="GUID-A96D9A39-60CB-4E89-B5C5-EEC8E811C734__GUID-0E694C49-E268-441E-B753-B5284CD9B1D1">
                        <p class="notep1">注意：</p>
                        <p>如果您不再需要Oracle Text索引，则可以使用drop_vertices_text_idx或opg_apis.drop_edges_text_idx API删除它。以下语句删除SCOTT所拥有的名为<code class="codeph">connections</code>的图的顶点和边的文本索引：</p><pre class="pre codeblock"><code>SQL&gt; exec opg_apis.drop_vertices_text_Idx（'scott'，'connections'）; SQL&gt; exec opg_apis.drop_edges_text_Idx（'scott'，'connections'）;</code></pre></div>
                  </div>
                  <!-- class="example" -->
                  <div class="example" id="GUID-A96D9A39-60CB-4E89-B5C5-EEC8E811C734__GUID-7359CE86-2325-4159-9CBE-9D0B5B5F2405">
                     <p class="titleinexample">示例4-7查找具有属性值的顶点</p>
                     <p>以下示例查找具有包含关键字“Obama”的属性值（字符串类型）的顶点。</p><pre class="pre codeblock"><code>SQL&gt;选择vid，k，t，v来自connectionsVT $，其中t = 1并且包含（v，'Obama'，1）&gt; 0 order by score（1）desc;</code></pre><p>前面语句中的输出和SQL执行计划可能如下所示。请注意，DOMAIN INDEX在执行计划中显示为操作。</p><pre class="oac_no_warn" dir="ltr">1名称1巴拉克奥巴马执行计划------------------------------------------- ---------------计划哈希值：1619508090 ------------------------------ -------------------------------------------------- --------------------------------------- | Id |操作|名称|行|字节|成本（％CPU）|时间| Pstart时| Pstop | -------------------------------------------------- -------------------------------------------------- ------------------- | 0 |选择声明| | 1 | 56 | 5（20）| 00:00:01 | | | | 1 |排序顺序| | 1 | 56 | 5（20）| 00:00:01 | | | | * 2 |通过全局索引ROWID表的访问权限CONNECTIONSVT $ | 1 | 56 | 4（0）| 00:00:01 | ROWID | ROWID | | * 3 | <span class="bold">DOMAIN INDEX</span> | CONNECTIONSXTV $ | | | 4（0）| 00:00:01 | | | -------------------------------------------------- -------------------------------------------------- -------------------谓词信息（由操作ID标识）：---------------------- ----------------------------- 2  -  filter（“T”= 1 AND INTERNAL_FUNCTION（“K”）AND INTERNAL_FUNCTION（“V “））3  - 访问（”CTXSYS“。”CONTAINS“（”V“，”奥巴马“，1）&gt; 0）</pre></div>
                  <!-- class="example" -->
                  <div class="example" id="GUID-A96D9A39-60CB-4E89-B5C5-EEC8E811C734__GUID-7982C91F-7911-43D3-A2E5-39D5428082D5">
                     <p class="titleinexample">例4-8模糊匹配</p>
                     <p>下面的示例查找具有属性值（字符串类型）的顶点，该属性值包含“ameriian”的变体（本例中有意拼写错误）使用模糊匹配。</p><pre class="pre codeblock"><code>SQL&gt; select Vid，k，t，v from connectionsVT $ where contains（v， <span class="bold">'fuzzy</span> （ameriian ,,, weight）'，1）&gt; 0 order by score（1）desc;</code></pre><p>前面语句中的输出和SQL执行计划可能如下所示。</p><pre class="oac_no_warn" dir="ltr">8角色1美国商人9角色1美国商人4角色1美国经济学家6角色1美国喜剧演员7角色1美国喜剧演员1职业1美国第44任总统6排选。执行计划------------------------------------------------ ----------计划哈希值：1619508090 ----------------------------------- -------------------------------------------------- ---------------------------------- | Id |操作|名称|行|字节|成本（％CPU）|时间| Pstart时| Pstop | -------------------------------------------------- -------------------------------------------------- ------------------- | 0 |选择声明| | 1 | 56 | 5（20）| 00:00:01 | | | | 1 |排序顺序| | 1 | 56 | 5（20）| 00:00:01 | | | | * 2 |通过全局索引ROWID表的访问权限CONNECTIONSVT $ | 1 | 56 | 4（0）| 00:00:01 | ROWID | ROWID | | * 3 | DOMAIN INDEX | CONNECTIONSXTV $ | | | 4（0）| 00:00:01 | | | -------------------------------------------------- -------------------------------------------------- -------------------谓词信息（由操作ID标识）：---------------------- ----------------------------- 2  -  filter（INTERNAL_FUNCTION（“K”）AND INTERNAL_FUNCTION（“V”））</pre></div>
                  <!-- class="example" -->
                  <div class="example" id="GUID-A96D9A39-60CB-4E89-B5C5-EEC8E811C734__GUID-80227A76-367F-4735-A49A-94D8C45D704E">
                     <p class="titleinexample">示例4-9查询松弛</p>
                     <p>以下示例是一个复杂的Oracle Text查询，它实现了<span class="bold">查询放宽</span> ，使您能够首先执行查询的最严格版本，逐步放宽查询，直到获得所需的匹配数。通过对包含多个字符串的查询使用查询松弛，您可以为确定“最佳”匹配提供指导，以使这些匹配在结果中出现得比其他潜在匹配更早。
                     </p>
                     <p>此示例搜索具有查询松弛序列的“美国演员”。</p><pre class="pre codeblock"><code>SQL&gt; select来自connectionsVT $的vid，k，t，v其中<span class="bold">CONTAINS</span> （v，'&lt;query&gt; &lt;textquery lang =“ENGLISH”grammar =“CONTEXT”&gt; <span class="bold">&lt;progression&gt; &lt;seq&gt; {american} {actor} &lt;/ seq &gt; &lt;seq&gt; {american} NEAR {actor} &lt;/ seq&gt; &lt;seq&gt; {american} AND {actor} &lt;/ seq&gt; &lt;seq&gt; {american} ACCUM {actor} &lt;/ seq&gt; &lt;/ progression&gt; &lt;/ textquery &gt;</span> &lt;score datatype =“INTEGER”algorithm =“COUNT”/&gt; &lt;/ query&gt;'）&gt; 0;</code></pre><p>前面语句中的输出和SQL执行计划可能如下所示。</p><pre class="oac_no_warn" dir="ltr">7角色1美国喜剧演员6角色1美国喜剧演员44职业1演员8角色1美国商人53职业1演员电影制片人52职业1演员4角色1美国经济学家47职业1演员9角色1美国商人9行选择。执行计划------------------------------------------------ ----------计划哈希值：2158361449 ----------------------------------- -------------------------------------------------- --------------------------------- | Id |操作|名称|行|字节|成本（％CPU）|时间| Pstart时| Pstop | -------------------------------------------------- -------------------------------------------------- ------------------ | 0 |选择声明| | 1 | 56 | 4（0）| 00:00:01 | | | | * 1 |通过全局索引ROWID表的访问权限CONNECTIONSVT $ | 1 | 56 | 4（0）| 00:00:01 | ROWID | ROWID | | * 2 | DOMAIN INDEX | CONNECTIONSXTV $ | | | 4（0）| 00:00:01 | | | -------------------------------------------------- -------------------------------------------------- ------------------谓词信息（由操作ID标识）：----------------------- ---------------------------- 1  -  filter（INTERNAL_FUNCTION（“K”）AND INTERNAL_FUNCTION（“V”））2  -  access（ “CTXSYS”。“CONTAINS”（“V”，“&lt;query&gt; &lt;textquery lang =”ENGLISH“grammar =”CONTEXT“&gt; &lt;progression&gt; &lt;seq&gt; {american} {actor} &lt;/ seq&gt; &lt;seq&gt; {american } NEAR {actor} &lt;/ seq&gt; &lt;seq&gt; {american} AND {actor} &lt;/ seq&gt; &lt;seq&gt; {american} ACCUM {actor} &lt;/ seq&gt; &lt;/ progression&gt; &lt;/ textquery&gt; &lt;score datatype =“ INTEGER“algorithm =”COUNT“/&gt; &lt;/ query&gt;'）&gt; 0）</pre></div>
                  <!-- class="example" -->
                  <div class="example" id="GUID-A96D9A39-60CB-4E89-B5C5-EEC8E811C734__GUID-901379A5-6980-47A3-B55A-15B29B3E5344">
                     <p class="titleinexample">示例4-10查找边缘</p>
                     <p>与顶点一样，您可以在属性图的边表（GE $）的V列上创建Oracle Text索引。以下示例使用MDSYS拥有的OPG_AUTO_LEXER词法分析器。</p><pre class="pre codeblock"><code>SQL&gt; exec opg_apis.create_edges_text_idx（'scott'，'connections'，pref_owner =&gt;'mdsys'，lexer =&gt;'OPG_AUTO_LEXER'，dop =&gt; 4）;</code></pre><p>如果需要自定义，请使用ctx_ddl.create_preference API。</p>
                  </div>
                  <!-- class="example" -->
               </div>
               <div>
                  <div class="familylinks">
                     <div class="parentlink">
                        <p><strong>父主题：</strong> <a href="sql-based-property-graph-query-analytics.html#GUID-C5CC6650-0375-4F32-8317-BAF859C1909C" title="您可以使用SQL在Oracle Spatial and Graph中查询属性图数据。">基于SQL的属性图查询和分析</a></p>
                     </div>
                  </div>
               </div>
               
            </div>
            <div class="props_rev_3"><a id="GUID-7B2B2D5C-A561-4ECD-B690-ABA795E07BDA" name="GUID-7B2B2D5C-A561-4ECD-B690-ABA795E07BDA"></a><h3 id="SPGDG-GUID-7B2B2D5C-A561-4ECD-B690-ABA795E07BDA" class="sect3"><span class="enumeration_section">4.3</span>导航和图形模式匹配</h3>
               <div>
                  <p>使用图形数据模型的一个主要好处是，您可以轻松地在建模为顶点的实体（人物，电影，产品，服务，事件等）之间进行导航，遵循建模为边缘的链接和关系。此外，可以定义图匹配模板来执行诸如检测模式，聚合个体和分析趋势之类的事情。</p>
                  <p>本主题使用名为connections的示例属性图提供图形导航和模式匹配示例。大多数SQL语句都相对简单，但它们可以用作构建块来实现更复杂的需求。通常最好从简单的东西开始，逐步增加复杂性。</p>
                  <div class="example" id="GUID-7B2B2D5C-A561-4ECD-B690-ABA795E07BDA__WHOAREAPERSONSCOLLABORATORS-3728428C">
                     <p class="titleinexample">例4-11谁是一个人的合作者？</p>
                     <p>以下SQL ststement查找ID为1的顶点与之协作的所有实体。为简单起见，它<span class="bold">仅</span>考虑传出关系。
                     </p><pre class="pre codeblock"><code>SQL&gt;从connectionsGE $中选择dvid，el，k，vn，v，其中svid = 1，el ='collaborates';</code></pre><div class="infoboxnote" id="GUID-7B2B2D5C-A561-4ECD-B690-ABA795E07BDA__GUID-E9C22EA0-FA62-4D83-9F63-2A5C9565F5B7">
                        <p class="notep1">注意：</p>
                        <p>要查找感兴趣的特定顶点ID，可以使用关键字或模糊匹配在属性图上执行文本查询。（有关详细信息和示例，请参阅<a href="sql-based-property-graph-query-analytics.html#GUID-A96D9A39-60CB-4E89-B5C5-EEC8E811C734" title="如果属性（顶点属性或边属性）的值包含自由文本，则可能有助于在V列上创建Oracle Text索引。">属性图上的文本查询</a> 。）
                        </p>
                     </div>
                     <p>前面的示例的输出和执行计划可以如下。</p><pre class="oac_no_warn" dir="ltr">2合作重量1 1 21合作重量1 1 22合作重量1 1 ....26合作重量1 1 10行选择。-------------------------------------------------- -------------------------------------------------- -------------------------------------------------- ------- | Id |操作|名称|行|字节|成本（％CPU）|时间| Pstart时| Pstop | TQ | IN-OUT | PQ Distrib | -------------------------------------------------- -------------------------------------------------- -------------------------------------------------- ------- | 0 |选择声明| | 10 | 460 | 2（0）| 00:00:01 | | | | | | | 1 | PX COORDINATOR | | | | | | | | | | | | 2 | PX SEND QC（RANDOM）| ：TQ10000 | 10 | 460 | 2（0）| 00:00:01 | | | Q1,00 | P-&gt; S | QC（兰德）| | 3 | PX PARTITION HASH ALL | | 10 | 460 | 2（0）| 00:00:01 | 1 | 8 | Q1,00 | PCWC | | | * 4 |按本地索引ROWID批量表的访问权限| CONNECTIONSGE $ | 10 | 460 | 2（0）| 00:00:01 | 1 | 8 | Q1,00 | PCWP | | | * 5 | INDEX RANGE SCAN | CONNECTIONSXSE $ | 20 | | 1（0）| 00:00:01 | 1 | 8 | Q1,00 | PCWP | | -------------------------------------------------- -------------------------------------------------- -------------------------------------------------- -------谓词信息（由操作ID标识）：---------------------------------- ----------------- 4  - 过滤器（INTERNAL_FUNCTION（“EL”）和“EL”= U'collaborates'和INTERNAL_FUNCTION（“K”）和INTERNAL_FUNCTION（“V”） ）5  - 访问（“SVID”= 1）</pre></div>
                  <!-- class="example" -->
                  <div class="example" id="GUID-7B2B2D5C-A561-4ECD-B690-ABA795E07BDA__GUID-78270F51-B255-4B34-BEBB-FB231FC2094F">
                     <p class="titleinexample">例4-12谁是一个人的合作者，他们的职业是什么？</p>
                     <p>以下SQL语句查找ID为1的顶点的协作者，以及每个协作者的占用情况。需要使用顶点表（VT $）进行连接。</p><pre class="pre codeblock"><code>SQL&gt; select connections dvid，vertices.v from connectionsGE $，connectionsVT $ vertices where svid = 1 and el ='collaborates'和dvid = vertices.vid and vertices.k ='occupation';</code></pre><p>前面的示例的输出和执行计划可以如下。</p><pre class="oac_no_warn" dir="ltr">21第67届美国国务卿22日第68任美国国务卿23日财政长官28日第7任伊朗总统19名来自纽约的初级美国参议员......-------------------------------------------------- -------------------------------------------------- -------------------------------------------------- -------- | Id |操作|名称|行|字节|成本（％CPU）|时间| Pstart时| Pstop | TQ | IN-OUT | PQ Distrib | -------------------------------------------------- -------------------------------------------------- -------------------------------------------------- -------- | 0 |选择声明| | 7 | 525 | 7（0）| 00:00:01 | | | | | | | 1 | PX COORDINATOR | | | | | | | | | | | | 2 | PX SEND QC（RANDOM）| ：TQ10000 | 7 | 525 | 7（0）| 00:00:01 | | | Q1,00 | P-&gt; S | QC（兰德）| | 3 | NESTED LOOPS | | 7 | 525 | 7（0）| 00:00:01 | | | Q1,00 | PCWP | | | 4 | PX PARTITION HASH ALL | | 10 | 250 | 2（0）| 00:00:01 | 1 | 8 | Q1,00 | PCWC | | | * 5 |按本地索引ROWID批量表的访问权限| CONNECTIONSGE $ | 10 | 250 | 2（0）| 00:00:01 | 1 | 8 | Q1,00 | PCWP | | | * 6 | INDEX RANGE SCAN | CONNECTIONSXSE $ | 20 | | 1（0）| 00:00:01 | 1 | 8 | Q1,00 | PCWP | | | 7 | PARASHTION HASH ITERATOR | | 1 | | 0（0）| 00:00:01 | KEY | KEY | Q1,00 | PCWP | | | * 8 |通过LOCAL INDEX ROWID表的访问权限CONNECTIONSVT $ | | | | | KEY | KEY | Q1,00 | PCWP | | | * 9 | INDEX UNIQUE SCAN | CONNECTIONSXQV $ | 1 | | 0（0）| 00:00:01 | KEY | KEY | Q1,00 | PCWP | | -------------------------------------------------- -------------------------------------------------- -------------------------------------------------- --------谓词信息（由操作ID标识）：--------------------------------- ------------------ 5  - 过滤器（INTERNAL_FUNCTION（“EL”）和“EL”= U'collaborates'）6  - 访问（“SVID”= 1）8  - filter（INTERNAL_FUNCTION（“VERTICES”。“V”））9  - 访问（“DVID”=“VERTICES”。“VID”和“VERTICES”。“K”= U'occupation'）过滤器（INTERNAL_FUNCTION（“VERTICES”。 “K”））</pre></div>
                  <!-- class="example" -->
                  <div class="example" id="GUID-7B2B2D5C-A561-4ECD-B690-ABA795E07BDA__GUID-BAEE2D4E-8A3E-44E9-B715-98F3A5C10894">
                     <p class="titleinexample">例4-13找出一个人的敌人并按他们的国家聚集他们</p>
                     <p>下面的SQL语句发现敌人（也就是那些与<code class="codeph">feuds</code>关系）与ID为1的顶点，并通过他们的国家聚集他们。需要使用顶点表（VT $）进行连接。
                     </p><pre class="pre codeblock"><code>SQL&gt; select vertices.v，count（1）from connectionsGE $，connectionsVT $ vertices其中svid = 1和el ='feuds'和dvid = vertices.vid和vertices.k ='country'group by vertices.v;</code></pre><p>示例的输出和执行计划可能如下所示。在这种情况下，ID为1的顶点在美国有3个敌人，在俄罗斯有1个敌人。</p><pre class="oac_no_warn" dir="ltr">美国3俄罗斯1 --------------------------------------------- -------------------------------------------------- -------------------------------------------------- ----------------- | Id |操作|名称|行|字节|成本（％CPU）|时间| Pstart时| Pstop | TQ | IN-OUT | PQ Distrib | -------------------------------------------------- -------------------------------------------------- -------------------------------------------------- ------------ | 0 |选择声明| | 5 | 375 | 5（20）| 00:00:01 | | | | | | | 1 | PX COORDINATOR | | | | | | | | | | | | 2 | PX SEND QC（RANDOM）| ：TQ10001 | 5 | 375 | 5（20）| 00:00:01 | | | Q1,01 | P-&gt; S | QC（兰德）| | 3 | HASH GROUP BY | | 5 | 375 | 5（20）| 00:00:01 | | | Q1,01 | PCWP | | | 4 | PX RECEIVE | | 5 | 375 | 5（20）| 00:00:01 | | | Q1,01 | PCWP | | | 5 | PX SEND HASH | ：TQ10000 | 5 | 375 | 5（20）| 00:00:01 | | | Q1,00 | P-&gt; P |哈希| | 6 | HASH GROUP BY | | 5 | 375 | 5（20）| 00:00:01 | | | Q1,00 | PCWP | | | 7 | NESTED LOOPS | | 5 | 375 | 4（0）| 00:00:01 | | | Q1,00 | PCWP | | | 8 | PX PARTITION HASH ALL | | 5 | 125 | 2（0）| 00:00:01 | 1 | 8 | Q1,00 | PCWC | | | * 9 |按本地索引ROWID批量表的访问权限| CONNECTIONSGE $ | 5 | 125 | 2（0）| 00:00:01 | 1 | 8 | Q1,00 | PCWP | | | * 10 | INDEX RANGE SCAN | CONNECTIONSXSE $ | 20 | | 1（0）| 00:00:01 | 1 | 8 | Q1,00 | PCWP | | | 11 | PARASHTION HASH ITERATOR | | 1 | | 0（0）| 00:00:01 | KEY | KEY | Q1,00 | PCWP | | | * 12 |通过LOCAL INDEX ROWID表的访问权限CONNECTIONSVT $ | | | | | KEY | KEY | Q1,00 | PCWP | | | * 13 | INDEX UNIQUE SCAN | CONNECTIONSXQV $ | 1 | | 0（0）| 00:00:01 | KEY | KEY | Q1,00 | PCWP | | -------------------------------------------------- -------------------------------------------------- -------------------------------------------------- ------------谓词信息（由操作ID标识）：----------------------------- ---------------------- 9  - 过滤器（INTERNAL_FUNCTION（“EL”）和“EL”= U'feuds'）10  - 访问（“SVID”= 1）12  - 滤波器（INTERNAL_FUNCTION（“VERTICES”。“V”））13  - 访问（“DVID”=“VERTICES”。“VID”和“VERTICES”。“K”= U'country'）滤波器（INTERNAL_FUNCTION（ “VERTICES”， “K”））</pre></div>
                  <!-- class="example" -->
                  <div class="example" id="GUID-7B2B2D5C-A561-4ECD-B690-ABA795E07BDA__GUID-6C71C301-6678-478B-AD45-15CAF8CA2C51">
                     <p class="titleinexample">示例4-14查找人员的协作者，并对其进行聚合和排序</p>
                     <p>以下SQL语句查找ID为1的顶点的协作者，按国家/地区聚合它们，并按升序对它们进行排序。</p><pre class="pre codeblock"><code>SQL&gt; select vertices.v，count（1）from connectionsGE $，connectionsVT $ vertices其中svid = 1和el ='collaborates'和dvid = vertices.vid和vertices.k ='country'group by vertices.v order by count （1）asc;</code></pre><p>示例输出和执行计划可以如下。在这种情况下，ID为1的顶点在美国拥有最多的协作者。</p><pre class="oac_no_warn" dir="ltr">德国1日本1伊朗1美国7 ----------------------------------------- -------------------------------------------------- -------------------------------------------------- ------------------------ | Id |操作|名称|行|字节|成本（％CPU）|时间| Pstart时| Pstop | TQ | IN-OUT | PQ Distrib | -------------------------------------------------- -------------------------------------------------- -------------------------------------------------- --------------- | 0 |选择声明| | 10 | 750 | 9（23）| 00:00:01 | | | | | | | 1 | PX COORDINATOR | | | | | | | | | | | | 2 | PX SEND QC（订购）| ：TQ10002 | 10 | 750 | 9（23）| 00:00:01 | | | Q1,02 | P-&gt; S | QC（订单）| | 3 |排序顺序| | 10 | 750 | 9（23）| 00:00:01 | | | Q1,02 | PCWP | | | 4 | PX RECEIVE | | 10 | 750 | 9（23）| 00:00:01 | | | Q1,02 | PCWP | | | 5 | PX SEND RANGE | ：TQ10001 | 10 | 750 | 9（23）| 00:00:01 | | | Q1,01 | P-&gt; P |范围| | 6 | HASH GROUP BY | | 10 | 750 | 9（23）| 00:00:01 | | | Q1,01 | PCWP | | | 7 | PX RECEIVE | | 10 | 750 | 9（23）| 00:00:01 | | | Q1,01 | PCWP | | | 8 | PX SEND HASH | ：TQ10000 | 10 | 750 | 9（23）| 00:00:01 | | | Q1,00 | P-&gt; P |哈希| | 9 | HASH GROUP BY | | 10 | 750 | 9（23）| 00:00:01 | | | Q1,00 | PCWP | | | 10 | NESTED LOOPS | | 10 | 750 | 7（0）| 00:00:01 | | | Q1,00 | PCWP | | | 11 | PX PARTITION HASH ALL | | 10 | 250 | 2（0）| 00:00:01 | 1 | 8 | Q1,00 | PCWC | | | * 12 |按本地索引ROWID批量表的访问权限| CONNECTIONSGE $ | 10 | 250 | 2（0）| 00:00:01 | 1 | 8 | Q1,00 | PCWP | | | * 13 | INDEX RANGE SCAN | CONNECTIONSXSE $ | 20 | | 1（0）| 00:00:01 | 1 | 8 | Q1,00 | PCWP | | | 14 | PARASHTION HASH ITERATOR | | 1 | | 0（0）| 00:00:01 | KEY | KEY | Q1,00 | PCWP | | | * 15 |通过LOCAL INDEX ROWID表的访问权限CONNECTIONSVT $ | | | | | KEY | KEY | Q1,00 | PCWP | | | * 16 | INDEX UNIQUE SCAN | CONNECTIONSXQV $ | 1 | | 0（0）| 00:00:01 | KEY | KEY | Q1,00 | PCWP | | -------------------------------------------------- -------------------------------------------------- -------------------------------------------------- ---------------谓词信息（由操作ID标识）：-------------------------- ------------------------- 12  - 过滤器（INTERNAL_FUNCTION（“EL”）和“EL”= U'collaborates'）13  - 访问（“ SVID“= 1）15  - 过滤器（INTERNAL_FUNCTION（”VERTICES“。”V“））16  - 访问（”DVID“=”VERTICES“。”VID“和”VERTICES“。”K“= U'country'）过滤器（INTERNAL_FUNCTION（ “VERTICES”。 “K”））</pre></div>
                  <!-- class="example" -->
               </div>
               <div>
                  <div class="familylinks">
                     <div class="parentlink">
                        <p><strong>父主题：</strong> <a href="sql-based-property-graph-query-analytics.html#GUID-C5CC6650-0375-4F32-8317-BAF859C1909C" title="您可以使用SQL在Oracle Spatial and Graph中查询属性图数据。">基于SQL的属性图查询和分析</a></p>
                     </div>
                  </div>
               </div>
               
            </div>
            <div class="props_rev_3"><a id="GUID-81370EE3-3917-4CA6-BB22-F7AA434EDB09" name="GUID-81370EE3-3917-4CA6-BB22-F7AA434EDB09"></a><h3 id="SPGDG-GUID-81370EE3-3917-4CA6-BB22-F7AA434EDB09" class="sect3"><span class="enumeration_section">4.4</span>导航选项：CONNECT BY和并行递归</h3>
               <div>
                  <p>CONNECT BY子句和并行递归提供高级导航和查询的选项。</p>
                  <ul style="list-style-type:disc">
                     <li>
                        <p>CONNECT BY允许您按层次结构顺序导航和查找匹配项。要跟随传出边缘，您可以使用先前的dvid = svid来指导导航。</p>
                     </li>
                     <li>
                        <p>并行递归使您可以执行导航，达到指定数量的跳数。</p>
                     </li>
                  </ul>
                  <p>这些示例使用名为connections的属性图。</p>
                  <div class="example" id="GUID-81370EE3-3917-4CA6-BB22-F7AA434EDB09__WHOAREAPERSONSCOLLABORATORS-37415127">
                     <p class="titleinexample">例4-15连接</p>
                     <p>以下SQL语句遵循传出边缘1个跃点。</p><pre class="pre codeblock"><code>SQL&gt;从连接中选择G.dvidGE $ G以svid = 1开头<span class="bold">连接</span> nocycle之前dvid = svid和<span class="bold">level &lt;= 1</span> ;</code></pre><p>前面的示例的输出和执行计划可以如下。</p><pre class="oac_no_warn" dir="ltr">2 3 4 5 6 7 8 9 10 ...-------------------------------------------------- -------------------------------------------------- -------------------------------------- | Id |操作|名称|行|字节|成本（％CPU）|时间| Pstart时| Pstop | TQ | IN-OUT | PQ Distrib | -------------------------------------------------- -------------------------------------------------- -------------------------------------- | 0 |选择声明| | 7 | 273 | 3（67）| 00:00:01 | | | | | | | * 1 |与过滤连接| | | | | | | | | | | | 2 | PX COORDINATOR | | | | | | | | | | | | 3 | PX SEND QC（RANDOM）| ：TQ10000 | 2 | 12 | 0（0）| 00:00:01 | | | Q1,00 | P-&gt; S | QC（兰德）| | 4 | PX PARTITION HASH ALL | | 2 | 12 | 0（0）| 00:00:01 | 1 | 8 | Q1,00 | PCWC | | | * 5 | INDEX RANGE SCAN | CONNECTIONSXSE $ | 2 | 12 | 0（0）| 00:00:01 | 1 | 8 | Q1,00 | PCWP | | | * 6 |过滤器| | | | | | | | | | | | 7 | NESTED LOOPS | | 5 | 95 | 1（0）| 00:00:01 | | | | | | | 8 |连接泵| | | | | | | | | | | | 9 | PARTITION HASH ALL | | 2 | 12 | 0（0）| 00:00:01 | 1 | 8 | | | | | * 10 | INDEX RANGE SCAN | CONNECTIONSXSE $ | 2 | 12 | 0（0）| 00:00:01 | 1 | 8 | | | | -------------------------------------------------- -------------------------------------------------- --------------------------------------谓词信息（由操作ID识别）：--- ------------------------------------------------ 1  - 访问（“SVID”= PRIOR“DVID”）过滤器（LEVEL &lt;= 2）5  - 访问（“SVID”= 1）6  - 过滤器（LEVEL &lt;= 2）10  - 访问（“connect $ _by $ _pump $ _002” 。“previous dvid”=“SVID”）</pre><p>要从1跳扩展到多跳，请将前面示例中的1更改为另一个整数。例如，要将其更改为2跃点，请指定： <code class="codeph">level &lt;= 2</code></p>
                  </div>
                  <!-- class="example" -->
                  <div class="example" id="GUID-81370EE3-3917-4CA6-BB22-F7AA434EDB09__GUID-C848A824-CDA0-4758-B46D-467E3F9E7C54">
                     <p class="titleinexample">例4-16并行递归</p>
                     <p>以下SQL语句使用递归内WITH子句执行导航最多4个跳跃以外，一个利用递归定义图形扩展： <code class="codeph">g_exp</code>引用<code class="codeph">g_exp</code>在查询，以及定义递归。该示例还使用PARALLEL优化程序提示进行并行执行。
                     </p><pre class="pre codeblock"><code>SQL&gt; WITH <span class="bold">g_exp</span> （svid，dvid，depth）as（选择svid作为svid，dvid作为dvid，0作为来自connectionsGE $的深度，其中svid = 1 union all选择g2.svid，g1.dvid，g2.depth + 1来自<span class="bold">g_exp</span> g2，connectionsGE $ g1其中g2.dvid = g1.svid和g2.depth &lt;= 3）选择/ * + parallel（4）* / dvid，深度来自g_exp，其中svid = 1;</code></pre><p>示例的输出和执行计划可能如下所示。请注意，执行时选择了<code class="codeph">CURSOR DURATION MEMORY</code> ，表示图形扩展将中间数据存储在内存中。
                     </p><pre class="oac_no_warn" dir="ltr">22 4 25 4 24 4 1 4 23 4 33 4 22 4 22 4 ......执行计划------------------------------------------------ -------------------------------------------------- -------------------------------------------------- -------------------- | Id |操作|名称|行|字节|成本（％CPU）|时间| Pstart时| Pstop | TQ | IN-OUT | PQ Distrib | -------------------------------------------------- -------------------------------------------------- -------------------------------------------------- ------------------ | 0 |选择声明| | 801 | 31239 | 147（0）| 00:00:01 | | | | | | | 1 | TEMP TABLE TRANSFORMATION | | | | | | | | | | | | 2 | LOAD AS SELECT（ <span class="bold">CURSOR DURATION MEMORY</span> ）| SYS_TEMP_0FD9D6614_11CB2D2 | | | | | | | | | | | 3 | UNION ALL（回程）第一个| | | | | | | | | | | | 4 | PX COORDINATOR | | | | | | | | | | | | 5 | PX SEND QC（RANDOM）| ：TQ20000 | 2 | 12 | 0（0）| 00:00:01 | | | Q2,00 | P-&gt; S | QC（兰德）| | 6 | LOAD AS SELECT（CURSOR DURATION MEMORY）| SYS_TEMP_0FD9D6614_11CB2D2 | | | | | | | Q2,00 | PCWP | | | 7 | PX PARTITION HASH ALL | | 2 | 12 | 0（0）| 00:00:01 | 1 | 8 | Q2,00 | PCWC | | | * 8 | INDEX RANGE SCAN | CONNECTIONSXSE $ | 2 | 12 | 0（0）| 00:00:01 | 1 | 8 | Q2,00 | PCWP | | | 9 | PX COORDINATOR | | | | | | | | | | | | 10 | PX SEND QC（RANDOM）| ：TQ10000 | 799 | 12M | 12（0）| 00:00:01 | | | Q1,00 | P-&gt; S | QC（兰德）| | 11 | LOAD AS SELECT（CURSOR DURATION MEMORY）| SYS_TEMP_0FD9D6614_11CB2D2 | | | | | | | Q1,00 | PCWP | | | * 12 | HASH JOIN | | 799 | 12M | 12（0）| 00:00:01 | | | Q1,00 | PCWP | | | 13 | BUFFER SORT（REUSE）| | | | | | | | Q1,00 | PCWP | | | 14 | PARTITION HASH ALL | | 164 | 984 | 2（0）| 00:00:01 | 1 | 8 | Q1,00 | PCWC | | | 15 | INDEX FAST FULL SCAN | CONNECTIONSXDE $ | 164 | 984 | 2（0）| 00:00:01 | 1 | 8 | Q1,00 | PCWP | | | 16 | PX BLOCK ITERATOR | | | | | | | | Q1,00 | PCWC | | | * 17 |表访问完全| SYS_TEMP_0FD9D6614_11CB2D2 | | | | | | | Q1,00 | PCWP | | | 18 | PX COORDINATOR | | | | | | | | | | | | 19 | PX SEND QC（RANDOM）| ：TQ30000 | 801 | 31239 | 135（0）| 00:00:01 | | | Q3,00 | P-&gt; S | QC（兰德）| | * 20 |查看| | 801 | 31239 | 135（0）| 00:00:01 | | | Q3,00 | PCWP | | | 21 | PX BLOCK ITERATOR | | 801 | 12M | 135（0）| 00:00:01 | | | Q3,00 | PCWC | | | 22 |表访问完全| SYS_TEMP_0FD9D6614_11CB2D2 | 801 | 12M | 135（0）| 00:00:01 | | | Q3,00 | PCWP | | -------------------------------------------------- -------------------------------------------------- -------------------------------------------------- ------------------谓词信息（由操作ID标识）：----------------------- ---------------------------- 8  -  access（“SVID”= 1）12  -  access（“G2”。“DVID”= “G1”。“SVID”）17  - 过滤器（“G2”。“INTERNAL_ITERS $”= LEVEL和“G2”。“DEPTH”&lt;= 3）20  - 过滤器（“SVID”= 1）</pre></div>
                  <!-- class="example" -->
               </div>
               <div>
                  <div class="familylinks">
                     <div class="parentlink">
                        <p><strong>父主题：</strong> <a href="sql-based-property-graph-query-analytics.html#GUID-C5CC6650-0375-4F32-8317-BAF859C1909C" title="您可以使用SQL在Oracle Spatial and Graph中查询属性图数据。">基于SQL的属性图查询和分析</a></p>
                     </div>
                  </div>
               </div>
               
            </div>
            <div class="props_rev_3"><a id="GUID-3F810D6C-CC45-4612-ADAB-C1B2B9873734" name="GUID-3F810D6C-CC45-4612-ADAB-C1B2B9873734"></a><h3 id="SPGDG-GUID-3F810D6C-CC45-4612-ADAB-C1B2B9873734" class="sect3"><span class="enumeration_section">4.5</span>枢轴</h3>
               <div>
                  <p>PIVOT子句允许您动态地向表中添加列以创建新表。</p>
                  <p>属性图的模式设计（VT $和GE $）是窄的（“瘦”）而不是宽（“胖”）。这意味着如果顶点或边具有多个属性，那么将使用多行而不是多列来存储这些属性键，值，数据类型等。这种设计非常灵活，您可以动态添加属性，而无需担心添加太多列甚至达到表可能具有的列数的物理最大限制。但是，对于某些应用程序，如果属性稍微均匀，您可能更喜欢使用宽表。</p>
                  <div class="example" id="GUID-3F810D6C-CC45-4612-ADAB-C1B2B9873734__PARALLELRECURSION-3744C9CA">
                     <p class="titleinexample">例4-17 Pivot</p>
                     <p>以下CREATE TABLE ...AS SELECT语句使用PIVOT添加四列：'company'，'occupation'，'name'和'religion'。</p><pre class="pre codeblock"><code>SQL&gt; CREATE TABLE表pg_wide与G AS一样（从connectionsVT $中选择vid，k，t，v）从G pivot选择*（min（v）为k in（'company'，'occup'，'name'，'宗教'））;表创建。
</code></pre><p>以下DESCRIBE语句显示了新表的定义，包括添加的四个列。（为了便于阅读，输出被重新格式化。）</p><pre class="pre codeblock"><code>SQL&gt; DESCRIBE pg_wide;名字空？输入------------------------------------------------- -  -------- -------------------- VID NOT NULL NUMBER T NUMBER（38）'company'NVARCHAR2（15000）'职业'NVARCHAR2 （15000）'名字'NVARCHAR2（15000）'宗教'NVARCHAR2（15000）</code></pre></div>
                  <!-- class="example" -->
               </div>
               <div>
                  <div class="familylinks">
                     <div class="parentlink">
                        <p><strong>父主题：</strong> <a href="sql-based-property-graph-query-analytics.html#GUID-C5CC6650-0375-4F32-8317-BAF859C1909C" title="您可以使用SQL在Oracle Spatial and Graph中查询属性图数据。">基于SQL的属性图查询和分析</a></p>
                     </div>
                  </div>
               </div>
               
            </div>
            <div class="props_rev_3"><a id="GUID-01E928F5-C8E1-4109-A63E-257B1F4AEDC6" name="GUID-01E928F5-C8E1-4109-A63E-257B1F4AEDC6"></a><h3 id="SPGDG-GUID-01E928F5-C8E1-4109-A63E-257B1F4AEDC6" class="sect3"><span class="enumeration_section">4.6</span>基于SQL的属性图分析</h3>
               <div>
                  <p>除了内存分析师提供的分析功能外，Oracle Spatial and Graph中的属性图功能还支持几种基于SQL的本机属性图分析。</p>
                  <p>基于SQL的分析的好处是：</p>
                  <ul style="list-style-type:disc">
                     <li>
                        <p>更容易分析不适合物理内存的较大图形</p>
                     </li>
                     <li>
                        <p>更便宜的分析，因为没有图表数据传输到数据库之外</p>
                     </li>
                     <li>
                        <p>使用属性图数据库的当前状态进行更好的分析</p>
                     </li>
                     <li>
                        <p>通过消除将内存中图形与图形数据库中的最新更新同步的步骤进行更简单的分析</p>
                     </li>
                  </ul>
                  <p>但是，当图形（或子图形）适合内存时，内存分析程序提供的运行分析通常比使用基于SQL的分析提供更好的性能。</p>
                  <p>由于许多分析实现需要使用中间数据结构，因此大多数基于SQL（和PL / SQL）的分析API都具有工作表（wt）的参数。典型的流程包括以下步骤：</p>
                  <ol>
                     <li>
                        <p>准备工作台。</p>
                     </li>
                     <li>
                        <p>执行分析（一个或多个呼叫）。</p>
                     </li>
                     <li>
                        <p>执行清理</p>
                     </li>
                  </ol>
                  <p>以下子主题提供了一些常见类型的属性图分析的基于SQL的示例。</p>
               </div>
               <div>
                  <ul class="ullinks">
                     <li class="ulchildlink"><a href="sql-based-property-graph-query-analytics.html#GUID-1A615347-46A0-4D93-8A65-B25113403DC8">最短路径示例</a><br></li>
                     <li class="ulchildlink"><a href="sql-based-property-graph-query-analytics.html#GUID-43991EC5-DB08-4597-A81F-B0FBCD412CA4">协作过滤概述和示例</a><br></li>
                  </ul>
                  <div class="familylinks">
                     <div class="parentlink">
                        <p><strong>父主题：</strong> <a href="sql-based-property-graph-query-analytics.html#GUID-C5CC6650-0375-4F32-8317-BAF859C1909C" title="您可以使用SQL在Oracle Spatial and Graph中查询属性图数据。">基于SQL的属性图查询和分析</a></p>
                     </div>
                  </div>
               </div>
               
               <div class="props_rev_3"><a id="GUID-1A615347-46A0-4D93-8A65-B25113403DC8" name="GUID-1A615347-46A0-4D93-8A65-B25113403DC8"></a><h4 id="SPGDG-GUID-1A615347-46A0-4D93-8A65-B25113403DC8" class="sect4"><span class="enumeration_section">4.6.1</span>最短路径示例</h4>
                  <div>
                     <p>以下示例演示了基于SQL的最短路径分析。</p>
                     <div class="example" id="GUID-1A615347-46A0-4D93-8A65-B25113403DC8__SHORTESTPATH-2BED45B2">
                        <p class="titleinexample">例4-18最短路径设置和计算</p>
                        <p>例如，考虑最短路径。在内部，Oracle数据库使用双向Dijkstra算法。以下代码段显示了整个准备，执行和清理工作流程。</p><pre class="pre codeblock"><code>在DECLARE wt1 varchar2（100）上设置serveroutput; - 中间工作台n号; path varchar2（1000）; weight varchar2（1000）; BEGIN  - 准备opg_apis.find_sp_prep（'connectionsGE $'，wt1）; dbms_output.put_line（'工作表名'|| wt1）; - 计算opg_apis.find_sp（'connectionsGE $'，1， - 开始顶点ID 53， - 目标顶点ID wt1， - 工作表（用于Dijkstra扩展）dop =&gt; 1， - 并行度stats_freq =&gt; 1000， - 频率收集统计信息path_output =&gt;路径， - 最短路径（一系列顶点）weights_output =&gt;权重， - 边缘权重选项=&gt; null）; dbms_output.put_line（'path'|| path）; dbms_output.put_line（'weights'|| weights）; - 清理（在这里注释掉;参见示例后的文字） -  opg_apis.find_sp_cleanup（'connectionsGE $'，wt1）;结束; /</code></pre><p>此示例可能会产生以下输出。请注意，如果<span class="bold"><span class="italic">未提供</span></span>工作表名称，则准备步骤将自动生成临时表名并创建它。由于临时工作表名称使用会话ID，因此输出可能会有所不同。
                        </p><pre class="oac_no_warn" dir="ltr">工作表名称“CONNECTIONSGE $$ TWFS12”路径1 3 52 53权重4 3 1 1 1 PL / SQL过程成功完成。
</pre><p>如果您想知道工作表的定义，那么跳过清理阶段（如前面的示例所示，该示例注释了对<code class="codeph">find_sp_cleanup</code>的调用）。计算完成后，您可以描述工作表。
                        </p><pre class="pre codeblock"><code>SQL&gt;描述“CONNECTIONSGE $$ TWFS12”名称是否为空？键入--------- -------- ---------------------------- NID NUMBER D2S NUMBER P2S号码D2T号码P2T号码F号码（38）B号码（38）</code></pre><p>对于想要尝试不同表创建选项的高级用户，例如使用内存或高级压缩，您可以预先创建前面的工作表并将名称传递给。</p>
                     </div>
                     <!-- class="example" -->
                     <div class="example" id="GUID-1A615347-46A0-4D93-8A65-B25113403DC8__CREATEWORKINGTABLEANDPERFORMANALYTI-2BED4E8B">
                        <p class="titleinexample">示例4-19最短路径：创建工作表并执行分析</p>
                        <p>以下语句显示了一些高级选项，首先创建具有相同列结构和启用基本压缩的工作表，然后将其传递给基于SQL的计算。该代码使用CREATE TABLE压缩和内存中选项优化中间表以进行计算。</p><pre class="pre codeblock"><code>创建表格连接<span class="bold">$ MY_EXP</span> （NID NUMBER，D2S NUMBER，P2S NUMBER，D2T NUMBER，P2T NUMBER，F NUMBER（38），B NUMBER（38）） <span class="bold">压缩</span> nologging; DECLARE wt1 varchar2（100）：=' <span class="bold">connections $ MY_EXP</span> '; n号; path varchar2（1000）; weight varchar2（1000）; BEGIN dbms_output.put_line（'工作表名'|| wt1）; - 计算opg_apis.find_sp（'connectionsGE $'，1,53，wt1，dop =&gt; 1，stats_freq =&gt; 1000，path_output =&gt; path，weights_output =&gt; weights，options =&gt; null）; dbms_output.put_line（'path'|| path）; dbms_output.put_line（'weights'|| weights）; - 清理 -  opg_apis.find_sp_cleanup（'connectionsGE $'，wt1）;结束; /</code></pre><p>在计算结束时，如果工作表尚未被删除或截断，您可以检查工作表的内容，如下所示。请注意，工作表结构可能因版本而异。</p><pre class="pre codeblock"><code>SQL&gt; select * from connections $ MY_EXP; NID D2S P2S D2T P2T FB ---------- ---------- ---------- ---------- ---- ------ ---------- ---------- 1 0 1.000E + 100 1 -1 53 1.000E + 100 0 -1 1 54 1.000E + 100 1 53 -1 1 52 1.000E + 100 1 53 -1 1 5 1 1 1.000E + 100 0 -1 26 1 1 1.000E + 100 0 -1 8 1000 1 1.000E + 100 0 -1 3 1 1 2 52 0 0 15 1 1 1.000E + 100 0 -1 21 1 1 1.000E + 100 0 -1 19 1 1 1.000E + 100 0 -1 ...
</code></pre></div>
                     <!-- class="example" -->
                     <div class="example" id="GUID-1A615347-46A0-4D93-8A65-B25113403DC8__MULTIPLECALLSTOSAMEGRAPH-2BED5961">
                        <p class="titleinexample">示例4-20最短路径：对同一图执行多次调用</p>
                        <p>要对同一图表执行多次调用，只<span class="italic">需要调用</span>一个准备步骤。以下显示了在同一图中计算多对顶点的最短路径的示例。
                        </p><pre class="pre codeblock"><code>DECLARE wt1 varchar2（100）; - 中间工作台n号; path varchar2（1000）; weight varchar2（1000）; BEGIN  - 准备opg_apis.find_sp_prep（'connectionsGE $'，wt1）; dbms_output.put_line（'工作表名'|| wt1）; <span class="bold">- 找到从顶点1到顶点53的最短路径</span> opg_apis.find_sp（'connectionsGE $'，1,53，wt1，dop =&gt; 1，stats_freq =&gt; 1000，path_output =&gt; path，weights_output =&gt; weights，options =&gt; null ）; dbms_output.put_line（'path'|| path）; dbms_output.put_line（'weights'|| weights）; <span class="bold">- 找到从顶点2到顶点36的最短路径</span> opg_apis.find_sp（'connectionsGE $'，2,36，wt1，dop =&gt; 1，stats_freq =&gt; 1000，path_output =&gt; path，weights_output =&gt; weights，options =&gt; null ）; dbms_output.put_line（'path'|| path）; dbms_output.put_line（'weights'|| weights）; <span class="bold">- 找到从顶点30到顶点4的最短路径</span> opg_apis.find_sp（'connectionsGE $'，30,4，wt1，dop =&gt; 1，stats_freq =&gt; 1000，path_output =&gt; path，weights_output =&gt; weights，options =&gt; null ）; dbms_output.put_line（'path'|| path）; dbms_output.put_line（'weights'|| weights）; - 清理opg_apis.find_sp_cleanup（'connectionsGE $'，wt1）;结束; /</code></pre><p>示例的输出可以如下：已经为所提供的多对顶点找到了三条最短路径。</p><pre class="oac_no_warn" dir="ltr">工作表名称“CONNECTIONSGE $$ TWFS12”路径1 3 52 53权重4 3 1 1 1路径2 36权重2 1 1路径30 21 1 4权重4 3 1 1 1 PL / SQL过程成功完成。
</pre></div>
                     <!-- class="example" -->
                  </div>
                  <div>
                     <div class="familylinks">
                        <div class="parentlink">
                           <p><strong>父主题：</strong> <a href="sql-based-property-graph-query-analytics.html#GUID-01E928F5-C8E1-4109-A63E-257B1F4AEDC6" title="除了内存分析师提供的分析功能外，Oracle Spatial and Graph中的属性图功能还支持几种基于SQL的本机属性图分析。">基于SQL的属性图分析</a></p>
                        </div>
                     </div>
                  </div>
                  
               </div>
               <div class="props_rev_3"><a id="GUID-43991EC5-DB08-4597-A81F-B0FBCD412CA4" name="GUID-43991EC5-DB08-4597-A81F-B0FBCD412CA4"></a><h4 id="SPGDG-GUID-43991EC5-DB08-4597-A81F-B0FBCD412CA4" class="sect4"><span class="enumeration_section">4.6.2</span>协作过滤概述和示例</h4>
                  <div>
                     <p><a href="http://recommender-systems.org/collaborative-filtering/" target="_blank">协作过滤</a> （也称为社交过滤）通过使用其他人的建议来过滤信息。协作过滤广泛用于建议基于具有相似偏好的其他人购买的购买的系统。
                     </p>
                     <p>以下示例演示了基于SQL的协作过滤分析。</p>
                     <div class="example" id="GUID-43991EC5-DB08-4597-A81F-B0FBCD412CA4__SHORTESTPATH-2BED9144">
                        <p class="titleinexample">例4-21 <span class="bold">协作过滤设置和计算</span></p>
                        <p>此示例显示如何使用基于SQL的协同过滤，特别是使用矩阵分解向客户推荐电话品牌。此示例假定数据库中存在名为“PHONES”的图形。此示例图表包含客户和项目顶点，以及带有“评级”标签的边，该标签将一些客户顶点链接到其他某些项顶点。评级标签的数值对应于指定给指定产品（边缘IN顶点）的特定客户（边缘OUT顶点）的评级。</p>
                        <p>下图显示了此图表。</p>
                        <div class="figure" id="GUID-43991EC5-DB08-4597-A81F-B0FBCD412CA4__GUID-1493488D-3D02-4A36-BD86-A7F6C8783845">
                           <p class="titleinfigure">图4-1协同过滤的电话图</p><img src="img/collaborative-filtering.jpg" alt="下面是图4-1的描述" title="下面是图4-1的描述" longdesc="img_text/collaborative-filtering.html"><br><a href="img_text/collaborative-filtering.html">“图4-1协作过滤的电话图”的说明</a></div>
                        <!-- class="figure" -->以下代码显示了运行基于SQL的协同过滤算法的端到端流程，该算法在内部使用矩阵分解算法。<pre class="pre codeblock"><code>在DECLARE上设置serveroutput wt_l varchar2（32）; - 工作表wt_r varchar2（32）; wt_l1 varchar2（32）; wt_r1 varchar2（32）; wt_i varchar2（32）; wt_ld varchar2（32）; wt_rd varchar2（32）; edge_tab_name varchar2（32）：='phonesge $'; edge_label varchar2（32）：='rating'; rating_property varchar2（32）：='';迭代整数：= 100; min_error数字：= 0.001; k整数：= 5; learning_rate数：= 0.001; decrease_rate数：= 0.95;正则数：= 0.02; dop数：= 2; tablespace varchar2（32）：= null; options varchar2（32）：= null; BEGIN  - 准备opg_apis.cf_prep（edge_tab_name，wt_l，wt_r，wt_l1，wt_r1，wt_i，wt_ld，wt_rd）; dbms_output.put_line（'working table wt_l'|| wt_l）; dbms_output.put_line（'working table wt_r'|| wt_r）; dbms_output.put_line（'working table wt_l1'|| wt_l1）; dbms_output.put_line（'working table wt_r1'|| wt_r1）; dbms_output.put_line（'working table wt_i'|| wt_i）; dbms_output.put_line（'working table wt_ld'|| wt_ld）; dbms_output.put_line（'working table wt_rd'|| wt_rd）; - 计算opg_apis.cf（edge_tab_name，edge_label，rating_property，iterations，min_error，k，learning_rate，decrease_rate，regularization，dop，wt_l，wt_r，wt_l1，wt_r1，wt_i，wt_ld，wt_rd，tablespace，options）;结束; /</code></pre>该流程首先创建临时工作表，然后将其传递给计算。在计算结束时，该示例可以产生以下输出。请注意，如果<span class="bold">未提供</span>工作表名称，则准备步骤将自动生成临时表名并创建它。由于临时工作表名称使用会话ID，因此输出可能会有所不同。<pre class="oac_no_warn" dir="ltr">工作台wt_l“PHONESGE $$ CFL57”工作台wt_r“PHONESGE $$ CFR57”工作台wt_l1“PHONESGE $$ CFL157”工作台wt_r1“PHONESGE $$ CFR157”工作台wt_i“PHONESGE $$ CFI57”工作台wt_ld“PHONESGE $$ CFLD57“工作表wt_rd”PHONESGE $$ CFRD57“PL / SQL程序已成功完成。
</pre></div>
                     <!-- class="example" -->
                     <div class="example" id="GUID-43991EC5-DB08-4597-A81F-B0FBCD412CA4__COLLABORATIVEFILTERINGVALIDATINGTHE-2BEE2C60">
                        <p class="titleinexample">示例4-22协作过滤：验证中间错误</p>
                        <p>在每次计算结束时，只要工作表中的数据尚未被删除，您就可以使用以下查询检查算法的当前错误。以下SQL查询说明了如何获取协作过滤算法的当前运行的中间错误。</p><pre class="pre codeblock"><code>SELECT / * + parallel（48）* / SQRT（SUM（（w1-w2）*（w1-w2）+ &lt;regularrization&gt; / 2 *（err_reg_l + err_reg_r）））AS err FROM &lt;wt_i&gt;;</code></pre><p>请注意，应根据运行<a href="OPG_APIS-reference.html#GUID-94F53C56-F77A-41A2-BF2A-AAB359D88170">OPG_APIS.CF</a>算法时使用的值替换正则化参数和工作表名称（参数<code class="codeph">wt_i</code> ）。在前面的例子中，将<code class="codeph">&lt;regularization&gt;</code>替换为0.02，将<code class="codeph">&lt;wt_i&gt;</code>替换为“PHONESGE $$ CFI149”，如下所示：</p><pre class="pre codeblock"><code>SELECT / * + parallel（48）* / SQRT（SUM（（w1-w2）*（w1-w2）+ 0.02 / 2 *（err_reg_l + err_reg_r）））错误来自“PHONESGE $$ CFI149”;</code></pre><p>此查询可能会产生以下输出。</p><pre class="oac_no_warn" dir="ltr">ERR ---------- 4.82163662</pre><p>f当前错误的值太高或者如果从协同过滤的矩阵分解结果中获得的预测尚不可用，则可以通过重用工作表和到目前为止所取得的进展来运行算法的更多迭代。以下示例显示如何使用基于SQL的协作过滤进行预测。</p>
                     </div>
                     <!-- class="example" -->
                     <div class="example" id="GUID-43991EC5-DB08-4597-A81F-B0FBCD412CA4__COLLABORATIVEFILTERINGMAKINGPREDICT-2BEDD5F3">
                        <p class="titleinexample">示例4-23协作过滤：进行预测</p>
                        <p>协同过滤算法的结果存储在表<code class="codeph">wt_l</code>和<code class="codeph">wt_r</code> ，这是矩阵乘积的两个因子。在进行协同过滤的预测时，应使用这些矩阵因子。
                        </p>
                        <p>在算法的典型流程中，可以使用两个矩阵因子在调用<a href="OPG_APIS-reference.html#GUID-5DCE3ADF-B40B-4483-969A-7141D37656E6">OPG_APIS.CF_CLEANUP</a>过程之前进行预测，或者可以将它们复制并保存到其他表中以供以后使用。以下示例演示了后一种情况：</p><pre class="pre codeblock"><code>DECLARE wt_l varchar2（32）; - 工作表wt_r varchar2（32）; wt_l1 varchar2（32）; wt_r1 varchar2（32）; wt_i varchar2（32）; wt_ld varchar2（32）; wt_rd varchar2（32）; edge_tab_name varchar2（32）：='phonesge $'; edge_label varchar2（32）：='rating'; rating_property varchar2（32）：='';迭代整数：= 100; min_error数字：= 0.001; k整数：= 5; learning_rate数：= 0.001; decrease_rate数：= 0.95;正则数：= 0.02; dop数：= 2; tablespace varchar2（32）：= null; options varchar2（32）：= null; BEGIN  - 准备opg_apis.cf_prep（edge_tab_name，wt_l，wt_r，wt_l1，wt_r1，wt_i，wt_ld，wt_rd）; - 计算opg_apis.cf（edge_tab_name，edge_label，rating_property，iterations，min_error，k，learning_rate，decrease_rate，regularization，dop，wt_l，wt_r，wt_l1，wt_r1，wt_i，wt_ld，wt_rd，tablespace，options）; - 只保存这两个表以便以后预测EXECUTE IMMEDIATE'CREATE TABLE customer_mat AS SELECT * FROM'|| wt_l; EXECUTE IMMEDIATE'CREATE TABLE item_mat AS SELECT * FROM'|| wt_r; - 清理opg_apis.cf_cleanup（'phonesge $'，wt_l，wt_r，wt_l1，wt_r1，wt_i，wt_ld，wt_rd）;结束; /</code></pre><p>此示例将仅生成以下输出。</p><pre class="oac_no_warn" dir="ltr">PL / SQL过程成功完成。</pre><p>现在矩阵因子保存在表customer_mat和item_mat中，您可以使用以下查询来检查实际值之间的“错误”（差异）（之前存在于图中的值为“评级”）和估计值预测（某个客户行和项目列中矩阵乘法的结果）。</p>
                        <p>请注意，以下查询是使用顶点表上的连接自定义的，以便返回顶点的NVARCHAR属性（例如，name属性）而不是数字ID。此查询将返回每个客户顶点到图中每个项顶点的所有预测。</p><pre class="pre codeblock"><code>SELECT / * + parallel（48）* / MIN（vertex1.v）AS customer，MIN（vertex2.v）AS item，MIN（edges.vn）AS real，SUM（lv * rv）AS预测从PHONESGE $ edge， CUSTOMER_MAT l，ITEM_MAT r，PHONESVT $ vertex1，PHONESVT $ vertex2 WHERE lk = rk AND lc = edges.svid（+）AND rp = edges.dvid（+）AND lc = vertex1.vid AND rp = vertex2.vid GROUP BY lc ，rp ORDER BY lc，rp  - 这个order by子句是可选的;</code></pre><p>此查询可能会生成类似于以下内容的输出（为简洁起见，省略了一些行）。</p><pre class="oac_no_warn" dir="ltr">CUSTOMER ITEM REAL PREDICTED ---------------------------------------------- -  Adam Apple 5 3.67375703 Adam Blackberry 3.66079652 Adam Danger 2.77049596 Adam Ericsson 4.21764858 Adam Figo 3.10631337 Adam Google 4 4.42429022 Adam Huawei 3 3.4289115 Ben Apple 2.82127589 Ben Blackberry 2 2.81132282 Ben Danger 3 2.12761307 Ben Ericsson 3 3.2389595 Ben Figo 2.38550534 Ben Google 3.39765075 Ben Huawei 2.63324582 ...Don Apple 1.3777496 Don Blackberry 1 1.37288909 Don Danger 1 1.03900439 Don Ericsson 1.58172236 Don Figo 1 1.16494421 Don Google 1.65921807 Don Huawei 1 1.28592648 Erik Apple 3 2.80809351 Erik Blackberry 3 2.79818695 Erik Danger 2.11767182 Erik Ericsson 3 3.2238255 Erik Figo 2.3743591 Erik Google 3 3.38177526 Erik Huawei 3 2.62094201</pre><p>如果您只想检查某些行以确定预测结果是否准备好，或者应该运行更多的算法迭代，则可以将先前的查询包装在外部查询中。以下示例将仅选择前11个结果。</p><pre class="pre codeblock"><code>SELECT / * + parallel（48）* / * FROM（SELECT / * + parallel（48）* / MIN（vertex1.v）AS customer，MIN（vertex2.v）AS item，MIN（edges.vn）AS real， SUM（lv * rv）AS预测从PHONESGE $ edge，CUSTOMER_MAT l，ITEM_MAT r，PHONESVT $ vertex1，PHONESVT $ vertex2 WHERE lk = rk AND lc = edges.svid（+）AND rp = edges.dvid（+）AND lc = vertex1.vid AND rp = vertex2.vid GROUP BY lc，rp ORDER BY lc，rp）WHERE rownum &lt;= 11;</code></pre><p>此查询可能会生成类似于以下内容的输出。</p><pre class="oac_no_warn" dir="ltr">CUSTOMER ITEM REAL PREDICTED ---------------------------------------------- -  Adam Apple 5 3.67375703 Adam Blackberry 3.66079652 Adam Danger 2.77049596 Adam Ericsson 4.21764858 Adam Figo 3.10631337 Adam Google 4 4.42429022 Adam Huawei 3 3.4289115 Ben Apple 2.82127589 Ben Blackberry 2 2.81132282 Ben Danger 3 2.12761307 Ben Ericsson 3 3.2389595</pre><p>要获得特定顶点（客户，项目或两者）的预测，可以使用所需的ID值限制查询。例如，要获取顶点1（客户）和顶点105（项目）的预测值，可以使用以下查询。</p><pre class="pre codeblock"><code>SELECT / * + parallel（48）* / MIN（vertex1.v）AS customer，MIN（vertex2.v）AS item，MIN（edges.vn）AS real，SUM（lv * rv）AS预测从PHONESGE $ edge， CUSTOMER_MAT l，ITEM_MAT r，PHONESVT $ vertex1，PHONESVT $ vertex2 WHERE lk = rk AND lc = edges.svid（+）AND rp = edges.dvid（+）AND lc = vertex1.vid AND vertex1.vid = 1 / *删除得到项105的所有预测* / AND rp = vertex2.vid AND vertex2.vid = 105 / *删除以获取客户1的所有预测* / / *删除两行以获得所有预测* / GROUP BY lc，rp ORDER BY lc，rp;</code></pre><p>此查询可能会生成类似于以下内容的输出。</p><pre class="oac_no_warn" dir="ltr">CUSTOMER ITEM REAL PREDICTED ---------------------------------------------- -  Adam Ericsson 4.21764858</pre></div>
                     <!-- class="example" -->
                  </div>
                  <div>
                     <div class="familylinks">
                        <div class="parentlink">
                           <p><strong>父主题：</strong> <a href="sql-based-property-graph-query-analytics.html#GUID-01E928F5-C8E1-4109-A63E-257B1F4AEDC6" title="除了内存分析师提供的分析功能外，Oracle Spatial and Graph中的属性图功能还支持几种基于SQL的本机属性图分析。">基于SQL的属性图分析</a></p>
                        </div>
                     </div>
                  </div>
                  
               </div>
            </div>
            <div class="props_rev_3"><a id="GUID-301FF092-1A07-43D2-91E5-0C5AFF3467CC" name="GUID-301FF092-1A07-43D2-91E5-0C5AFF3467CC"></a><h3 id="SPGDG-GUID-301FF092-1A07-43D2-91E5-0C5AFF3467CC" class="sect3"><span class="enumeration_section">4.7</span>属性图查询语言（PGQL）</h3>
               <div>
                  <p>PGQL是针对包括由<span class="italic">边</span>连接到其它节点<span class="italic">的节点</span> ，其中的每一个可具有与其相关联的键-值对（属性）的属性的图形数据结构类似于SQL的查询语言。
                  </p>
                  <p>该语言基于<span class="italic">图形模式匹配</span>的概念，允许您指定与数据图中的顶点和边缘匹配的模式。
                  </p>
                  <p>Oracle Spatial and Graph属性图支持提供了两种通过Java API执行Property Graph Query Language（PGQL）查询的方法：</p>
                  <ul style="list-style-type:disc">
                     <li>
                        <p>使用<code class="codeph">oracle.pgx.api</code> Java包查询已加载到内存分析程序（PGX）的图形的内存中快照，如<a href="using-inmemory-analyst-oracle-database.html#GUID-C80502F2-67B0-42B3-B80F-6DA297EA655C" title="Oracle Spatial and Graph的内存分析器功能支持一组分析功能。">使用内存分析程序（PGX）中所述</a> 。
                        </p>
                     </li>
                     <li>
                        <p>使用<code class="codeph">oracle.pg.rdbms</code> Java包直接查询存储在Oracle数据库中的图形数据，如<a href="sql-based-property-graph-query-analytics.html#GUID-94F08780-EC3D-4F9B-985F-49984939E61C" title="本主题说明如何直接对Oracle数据库中的图形执行PGQL查询（而不是内存中）。">直接针对Oracle数据库执行PGQL查询中</a>所述。
                        </p>
                     </li>
                  </ul>
               </div>
               <div>
                  <ul class="ullinks">
                     <li class="ulchildlink"><a href="sql-based-property-graph-query-analytics.html#GUID-E7491A7F-44F6-459C-AC28-1AE20074E1B9">PGQL的拓扑约束</a><br></li>
                     <li class="ulchildlink"><a href="sql-based-property-graph-query-analytics.html#GUID-AFBD9879-6198-413B-ADA3-B70B2EC178D8">PGQL的约束是定向的</a><br></li>
                     <li class="ulchildlink"><a href="sql-based-property-graph-query-analytics.html#GUID-8BD36D93-1B37-4E5C-A469-D489F69C0F34">使用PGQL的顶点和边缘标签</a><br></li>
                     <li class="ulchildlink"><a href="sql-based-property-graph-query-analytics.html#GUID-A218D733-6A70-4DB7-9827-27C74D446655">使用PGQL进行常规路径查询</a><br></li>
                     <li class="ulchildlink"><a href="sql-based-property-graph-query-analytics.html#GUID-14A728FA-8F95-425B-A498-B8BA364B9734">使用PGQL进行聚合和排序</a><br></li>
                  </ul>
                  <div class="relinfo">
                     <p><strong>相关话题</strong></p>
                     <ul>
                        <li><a href="https://docs.oracle.com/cd/E56133_01/latest/reference/pgql-specification.html" target="_blank">PGQL规范</a></li>
                     </ul>
                  </div>
                  <div class="familylinks">
                     <div class="parentlink">
                        <p><strong>父主题：</strong> <a href="sql-based-property-graph-query-analytics.html#GUID-C5CC6650-0375-4F32-8317-BAF859C1909C" title="您可以使用SQL在Oracle Spatial and Graph中查询属性图数据。">基于SQL的属性图查询和分析</a></p>
                     </div>
                  </div>
               </div>
               
               <div class="props_rev_3"><a id="GUID-E7491A7F-44F6-459C-AC28-1AE20074E1B9" name="GUID-E7491A7F-44F6-459C-AC28-1AE20074E1B9"></a><h4 id="SPGDG-GUID-E7491A7F-44F6-459C-AC28-1AE20074E1B9" class="sect4"><span class="enumeration_section">4.7.1</span> PGQL的拓扑约束</h4>
                  <div>
                     <p>模式匹配是使用<span class="italic">拓扑约束</span>完成的， <span class="italic">拓扑约束</span>描述了图中节点之间的连接模式。值约束（类似于它们的SQL等价物）允许您通过指定这些连接和节点必须具有的属性来进一步约束匹配。
                     </p>
                     <p>例如，假设计算机网络上的TCP / IP连接图，并且您想要检测某人登录到一台计算机的情况，从那里登录到另一台计算机，再从那里登录到另一台计算机。您可以像这样查询该模式：</p><pre class="pre codeblock"><code>SELECT host1.id（），host2.id（），host3.id（）WHERE / *选择要返回的内容* /（host1） -  [c1 WITH toPort = 22 and opened = true]  - &gt;（host2）/ * topology必须匹配此模式* /  -  [connection2 WITH toPort = 22 and opened = true]  - &gt;（host3），connection1.bytes&gt; 300，/ *交换有意义的数据量* / connection2.bytes&gt; 300，connection1.start &lt; connection2.start，/ *第一个* / connection2.start + connection2.duration &lt;connection1.start + connection1.duration的时间范围内的第二个连接GROUP BY host1.id（），host2.id（），host3.id（） / *聚合多个匹配连接* / ORDER BY DESC（connection1.when）/ *按时间顺序反向排序* /</code></pre></div>
                  <div>
                     <div class="familylinks">
                        <div class="parentlink">
                           <p><strong>父主题：</strong> <a href="sql-based-property-graph-query-analytics.html#GUID-301FF092-1A07-43D2-91E5-0C5AFF3467CC" title="PGQL是属性图数据结构的类似SQL的查询语言，它由通过边连接到其他节点的节点组成，每个节点都可以具有与之关联的键值对（属性）。">属性图查询语言（PGQL）</a></p>
                        </div>
                     </div>
                  </div>
                  
               </div>
               <div class="props_rev_3"><a id="GUID-AFBD9879-6198-413B-ADA3-B70B2EC178D8" name="GUID-AFBD9879-6198-413B-ADA3-B70B2EC178D8"></a><h4 id="SPGDG-GUID-AFBD9879-6198-413B-ADA3-B70B2EC178D8" class="sect4"><span class="enumeration_section">4.7.2</span>约束与PGQL是方向性的</h4>
                  <div>
                     <p>拓扑约束具有方向，如图中的边。因此， <code class="codeph">(a) &lt;-[]- (b)</code>指定<span class="italic">b的边缘指向a的情况</span> ，而<code class="codeph">(a) -[]-&gt; (b)</code>指向相反方向的边缘。
                     </p>
                     <p>以下示例找到了比两者都老的四月和克里斯的普通朋友。</p><pre class="pre codeblock"><code>SELECT friend.name，friend.dob WHERE / *注意下面的箭头方向* /（p1：person WITH name ='April'） -  [：likes]  - &gt;（朋友）&lt; -  [：likes]  - （p2：person WITH name ='Chris'），friend.dob&gt; p1.dob AND friend.dob&gt; p2.dob ORDER BY friend.dob DESC</code></pre></div>
                  <div>
                     <div class="familylinks">
                        <div class="parentlink">
                           <p><strong>父主题：</strong> <a href="sql-based-property-graph-query-analytics.html#GUID-301FF092-1A07-43D2-91E5-0C5AFF3467CC" title="PGQL是属性图数据结构的类似SQL的查询语言，它由通过边连接到其他节点的节点组成，每个节点都可以具有与之关联的键值对（属性）。">属性图查询语言（PGQL）</a></p>
                        </div>
                     </div>
                  </div>
                  
               </div>
               <div class="props_rev_3"><a id="GUID-8BD36D93-1B37-4E5C-A469-D489F69C0F34" name="GUID-8BD36D93-1B37-4E5C-A469-D489F69C0F34"></a><h4 id="SPGDG-GUID-8BD36D93-1B37-4E5C-A469-D489F69C0F34" class="sect4"><span class="enumeration_section">4.7.3</span>使用PGQL的顶点和边缘标签</h4>
                  <div>
                     <p>标签是一种将类型信息附加到图形中的边和节点的方法，并且可以在图形中的约束中使用，其中并非所有节点都表示相同的事物。例如：</p><pre class="pre codeblock"><code>SELECT p WHERE（p：person） -  [e：likes]  - &gt;（m：电影标题='星球大战'），（p） -  [e：赞]  - &gt;（m：电影标题='阿凡达' ）</code></pre></div>
                  <div>
                     <div class="familylinks">
                        <div class="parentlink">
                           <p><strong>父主题：</strong> <a href="sql-based-property-graph-query-analytics.html#GUID-301FF092-1A07-43D2-91E5-0C5AFF3467CC" title="PGQL是属性图数据结构的类似SQL的查询语言，它由通过边连接到其他节点的节点组成，每个节点都可以具有与之关联的键值对（属性）。">属性图查询语言（PGQL）</a></p>
                        </div>
                     </div>
                  </div>
                  
               </div>
               <div class="props_rev_3"><a id="GUID-A218D733-6A70-4DB7-9827-27C74D446655" name="GUID-A218D733-6A70-4DB7-9827-27C74D446655"></a><h4 id="SPGDG-GUID-A218D733-6A70-4DB7-9827-27C74D446655" class="sect4"><span class="enumeration_section">4.7.4</span>使用PGQL的常规路径查询</h4>
                  <div>
                     <p>常规路径查询允许重用模式。以下示例查找Mario和Luigi的所有常见祖先。</p><pre class="pre codeblock"><code>PATH has_parent：=（） -  [：has_father | has_mother]  - &gt;（）SELECT ancestor.name WHERE（：Person with name ='Mario'） -  /：has_parent * /  - &gt;（祖先：Person），（：Person WITH name ='Luigi'） -  /：has_parent * /  - &gt;（祖先）</code></pre><p>前面的路径规范还显示了匿名约束的使用，因为不需要为不会在其他约束或查询结果中使用的中间边或节点定义名称。匿名元素可以有约束，例如<code class="codeph">[:has_father|has_mother]</code> ：边缘不会获得变量名称（因为它不会在其他地方引用），但是它受到约束。
                     </p>
                  </div>
                  <div>
                     <div class="familylinks">
                        <div class="parentlink">
                           <p><strong>父主题：</strong> <a href="sql-based-property-graph-query-analytics.html#GUID-301FF092-1A07-43D2-91E5-0C5AFF3467CC" title="PGQL是属性图数据结构的类似SQL的查询语言，它由通过边连接到其他节点的节点组成，每个节点都可以具有与之关联的键值对（属性）。">属性图查询语言（PGQL）</a></p>
                        </div>
                     </div>
                  </div>
                  
               </div>
               <div class="props_rev_3"><a id="GUID-14A728FA-8F95-425B-A498-B8BA364B9734" name="GUID-14A728FA-8F95-425B-A498-B8BA364B9734"></a><h4 id="SPGDG-GUID-14A728FA-8F95-425B-A498-B8BA364B9734" class="sect4"><span class="enumeration_section">4.7.5</span>使用PGQL进行聚合和排序</h4>
                  <div>
                     <p>与SQL一样，PGQL支持以下内容：</p>
                     <ul style="list-style-type:disc">
                        <li>
                           <p>GROUP BY创建解决方案组</p>
                        </li>
                        <li>
                           <p>MIN，MAX，SUM和AVG聚合</p>
                        </li>
                        <li>
                           <p>ORDER BY对结果进行排序</p>
                        </li>
                     </ul>
                     <p>对于许多其他熟悉的SQL结构。</p>
                  </div>
                  <div>
                     <div class="familylinks">
                        <div class="parentlink">
                           <p><strong>父主题：</strong> <a href="sql-based-property-graph-query-analytics.html#GUID-301FF092-1A07-43D2-91E5-0C5AFF3467CC" title="PGQL是属性图数据结构的类似SQL的查询语言，它由通过边连接到其他节点的节点组成，每个节点都可以具有与之关联的键值对（属性）。">属性图查询语言（PGQL）</a></p>
                        </div>
                     </div>
                  </div>
                  
               </div>
            </div>
            <div class="props_rev_3"><a id="GUID-94F08780-EC3D-4F9B-985F-49984939E61C" name="GUID-94F08780-EC3D-4F9B-985F-49984939E61C"></a><h3 id="SPGDG-GUID-94F08780-EC3D-4F9B-985F-49984939E61C" class="sect3"><span class="enumeration_section">4.8</span>直接针对Oracle数据库执行PGQL查询</h3>
               <div>
                  <p>本主题说明如何直接对Oracle数据库中的图形执行PGQL查询（而不是内存中）。</p>
                  <p>可以对存储在Oracle数据库中的磁盘驻留属性图数据执行属性图查询语言（PGQL）查询。图数据访问层（DAL）提供用于执行PGQL查询的Java API。DAL中的逻辑将提交的PGQL查询转换为等效的SQL查询，并在数据库服务器上执行生成的SQL。然后，DAL使用方便的PGQL结果集API包装SQL查询结果。此PGQL查询执行流程如下图所示。</p>
                  <div class="figure" id="GUID-94F08780-EC3D-4F9B-985F-49984939E61C__GUID-27DB13E6-7444-45A3-8D7F-C5417C9E3E20">
                     <p class="titleinfigure">图4-2图数据访问层（DAL）</p><img src="img/graph_dal.jpg" alt="下面是图4-2的描述" title="下面是图4-2的描述" longdesc="img_text/graph_dal.html"><br><a href="img_text/graph_dal.html">“图4-2图形数据访问层（DAL）”的描述</a></div>
                  <!-- class="figure" -->
                  <p>基本执行流程是：</p>
                  <ol>
                     <li>
                        <p>PGQL查询通过Java API提交给DAL。</p>
                     </li>
                     <li>
                        <p>PGQL查询在DAL中转换为SQL。</p>
                     </li>
                     <li>
                        <p>已翻译的SQL由JDBC提交到Oracle数据库。</p>
                     </li>
                     <li>
                        <p>SQL结果集包装为PGQL结果集并返回给调用者。</p>
                     </li>
                  </ol>
                  <p>直接对存储在Oracle数据库中的属性图数据执行PGQL查询的能力提供了几个好处。</p>
                  <ul style="list-style-type:disc">
                     <li>
                        <p>PGQL提供了一种更自然的表达图形查询的方式，而不是手动编写到查询模式表的SQL，包括VT $，GE $和GT $。</p>
                     </li>
                     <li>
                        <p>PGQL查询可以在不需要将图形数据的快照加载到PGX中的情况下执行，因此无需担心频繁更新的图形数据的陈旧性。</p>
                     </li>
                     <li>
                        <p>PGQL查询可以针对太大而无法容纳在内存中的图形数据执行。</p>
                     </li>
                     <li>
                        <p>可靠且可扩展的Oracle SQL引擎可用于执行PGQL查询。</p>
                     </li>
                     <li>
                        <p>用于管理，监视和调优Oracle数据库的成熟工具可用于调优和监视PGQL查询。</p>
                     </li>
                  </ul>
               </div>
               <div>
                  <ul class="ullinks">
                     <li class="ulchildlink"><a href="sql-based-property-graph-query-analytics.html#GUID-D2FC29F7-B4C7-407D-BE73-784E593DC73C">PGQL功能支持</a><br></li>
                     <li class="ulchildlink"><a href="sql-based-property-graph-query-analytics.html#GUID-296732FE-D57B-41B5-937B-078E234422CC">使用oracle.pg.rdbms Java包执行PGQL查询</a><br></li>
                     <li class="ulchildlink"><a href="sql-based-property-graph-query-analytics.html#GUID-BAD8CE60-CDF7-4FCF-987C-90658D78BDEA">PGQL查询的性能注意事项</a><br></li>
                  </ul>
                  <div class="familylinks">
                     <div class="parentlink">
                        <p><strong>父主题：</strong> <a href="sql-based-property-graph-query-analytics.html#GUID-C5CC6650-0375-4F32-8317-BAF859C1909C" title="您可以使用SQL在Oracle Spatial and Graph中查询属性图数据。">基于SQL的属性图查询和分析</a></p>
                     </div>
                  </div>
               </div>
               
               <div class="props_rev_3"><a id="GUID-D2FC29F7-B4C7-407D-BE73-784E593DC73C" name="GUID-D2FC29F7-B4C7-407D-BE73-784E593DC73C"></a><h4 id="SPGDG-GUID-D2FC29F7-B4C7-407D-BE73-784E593DC73C" class="sect4"><span class="enumeration_section">4.8.1</span>支持PGQL功能</h4>
                  <div>
                     <p><a href="sql-based-property-graph-query-analytics.html#GUID-301FF092-1A07-43D2-91E5-0C5AFF3467CC" title="PGQL是属性图数据结构的类似SQL的查询语言，它由通过边连接到其他节点的节点组成，每个节点都可以具有与之关联的键值对（属性）。">PGQL</a>是一种类似SQL的查询语言，用于查询属性图数据。它基于图模式匹配的概念，允许您指定拓扑约束，路径，过滤器，排序和聚合等。
                     </p>
                     <p><code class="codeph">oracle.pg.rdbms</code>包中定义的<code class="codeph">oracle.pg.rdbms</code> Java API支持PGQL 1.1规范，但有一些例外。PGQL 1.1规范可以在这里找到（ <a href="http://pgql-lang.org/spec/1.1/" target="_blank">http://pgql-lang.org/spec/1.1/</a> ）。</p>
                     <p>不支持PGQL 1.1的以下功能。</p>
                     <ul id="GUID-D2FC29F7-B4C7-407D-BE73-784E593DC73C__UL_OSV_DJ5_DGB" style="list-style-type:disc">
                        <li>FROM子句 - 一次只能查询一个图表</li>
                        <li>未定向的查询边缘</li>
                        <li>TIME AND TIME WITH TIME ZONE数据类型</li>
                        <li>IS NULL和IS NOT NULL测试</li>
                     </ul>
                     <p>支持以下PGQL 1.1增强功能。</p>
                     <ul id="GUID-D2FC29F7-B4C7-407D-BE73-784E593DC73C__UL_PSV_DJ5_DGB" style="list-style-type:disc">
                        <li>包含内置功能</li>
                     </ul>
                     <p>此外，PGQL 1.1的以下功能需要特别考虑。</p>
                  </div>
                  <div>
                     <ul class="ullinks">
                        <li class="ulchildlink"><a href="sql-based-property-graph-query-analytics.html#GUID-5754F6E9-B08E-40A5-BBE7-D35393A6562E">时间类型</a><br></li>
                        <li class="ulchildlink"><a href="sql-based-property-graph-query-analytics.html#GUID-368FDAFB-9183-463B-A623-2D473F64779C">类型铸造</a><br></li>
                        <li class="ulchildlink"><a href="sql-based-property-graph-query-analytics.html#GUID-D50795B1-079B-4A0F-99C6-5157F28D941A">缺少属性</a><br></li>
                        <li class="ulchildlink"><a href="sql-based-property-graph-query-analytics.html#GUID-0DE03EC7-2D45-4B5F-B940-0F86CE51CC1A">包含内置功能</a><br></li>
                     </ul>
                     <div class="familylinks">
                        <div class="parentlink">
                           <p><strong>父主题：</strong> <a href="sql-based-property-graph-query-analytics.html#GUID-94F08780-EC3D-4F9B-985F-49984939E61C" title="本主题说明如何直接对Oracle数据库中的图形执行PGQL查询（而不是内存中）。">直接针对Oracle数据库执行PGQL查询</a></p>
                        </div>
                     </div>
                  </div>
                  
                  <div class="props_rev_3"><a id="GUID-5754F6E9-B08E-40A5-BBE7-D35393A6562E" name="GUID-5754F6E9-B08E-40A5-BBE7-D35393A6562E"></a><h5 id="SPGDG-GUID-5754F6E9-B08E-40A5-BBE7-D35393A6562E" class="sect5"><span class="enumeration_section">4.8.1.1</span>时间类型</h5>
                     <div>
                        <p>PGQL查询支持时态类型DATE，TIMESTAMP和TIMESTAMP WITH TIMEZONE。</p>
                        <p>所有这些值类型都使用Oracle SQL TIMESTAMP WITH TIME ZONE类型在内部表示。通过假设UTC + 0时区中的最早时间（例如，2000-01-01变为2000-01-01 00：00：00.00 + 00:00），DATE值自动转换为TIMESTAMP WITH TIME ZONE。假设UTC + 0时区（例如，2000-01-01 12：00：00.00变为2000-01-01 12：00：00.00 + 00:00），TIMESTAMP值将自动转换为TIMESTAMP WITH TIME ZONE。</p>
                        <p>时间常量在PGQL查询中编写如下。</p>
                        <ul style="list-style-type:disc">
                           <li>
                              <p>日期'YYYY-MM-DD'</p>
                           </li>
                           <li>
                              <p>TIMESTAMP'YYYY-MM-DD HH24：MI：SS.FF'</p>
                           </li>
                           <li>
                              <p>TIMESTAMP与TIMEZONE'YYYY-MM-DD HH24：MI：SS.FFTZH：TZM'</p>
                           </li>
                        </ul>
                        <p>一些例子是DATE'2000-01-01'，TIMESTAMP'2000-01-01 14：01：45.23'，TIMESTAMP WITH TIMEZONE'2000-01-01 13：00：00.00-05：00'，TIMESTAMP WITH TIMEZONE '2000-01-01 13：00：00.00 + 01:00'。</p>
                        <p>另外，可以通过将字符串值转换为时间类型来获得时间值。支持的字符串格式为：</p>
                        <ul style="list-style-type:disc">
                           <li>
                              <p>日期'YYYY-MM-DD'</p>
                           </li>
                           <li>
                              <p>TIMESTAMP'YYYY-MM-DD HH24：MI：SS.FF'和'YYYY-MM-DD“T”HH24：MI：SS.FF'</p>
                           </li>
                           <li>
                              <p>TIMESTAMP与TIMEZONE'YYYY-MM-DD HH24：MI：SS.FFTZH：TZM'和'YYYY-MM-DD“T”HH24：MI：SS.FFTZH：TZM'。</p>
                           </li>
                        </ul>
                        <p>一些例子是CAST（'2005-02-04'AS DATE），CAST（'1990-01-01 12：00：00.00'AS TIMESTAMP），CAST（'1985-01-01T14：05：05.00-08：00 '作为带时区的时间表）。</p>
                        <p>从<code class="codeph">ResultSet</code>对象<code class="codeph">ResultSet</code>结果时， <code class="codeph">getObject</code>返回<code class="codeph">java.sql.时间类型的Timestamp</code>对象。
                        </p>
                        <p>绑定变量只能用于PGQL中的TIMESTAMP WITH TIMEZONE时间类型，以及带有<code class="codeph">java.sql.的<code class="codeph">setTimestamp</code>方法<code class="codeph">java.sql.作为输入的Timestamp</code>对象用于设置绑定值。作为一种更简单的替代方法，您可以在CAST语句中使用字符串绑定变量来绑定时态值（例如， <code class="codeph">CAST (?AS TIMESTAMP WITH TIMEZONE)</code>后跟<code class="codeph">setString(1, "1985-01-01T14:05:05.00-08:00")</code> ）。有关<a href="sql-based-property-graph-query-analytics.html#GUID-E9657B9D-B648-484F-9572-7DDD7F038871">绑定变量</a>的更多信息，另请参阅<a href="sql-based-property-graph-query-analytics.html#GUID-E9657B9D-B648-484F-9572-7DDD7F038871">在PGQL查询中使用绑定</a>变量。
                        </p>
                     </div>
                     <div>
                        <div class="familylinks">
                           <div class="parentlink">
                              <p><strong>父主题：</strong> <a href="sql-based-property-graph-query-analytics.html#GUID-D2FC29F7-B4C7-407D-BE73-784E593DC73C">支持PGQL功能</a></p>
                           </div>
                        </div>
                     </div>
                     
                  </div>
                  <div class="props_rev_3"><a id="GUID-368FDAFB-9183-463B-A623-2D473F64779C" name="GUID-368FDAFB-9183-463B-A623-2D473F64779C"></a><h5 id="SPGDG-GUID-368FDAFB-9183-463B-A623-2D473F64779C" class="sect5"><span class="enumeration_section">4.8.1.2</span>类型铸造</h5>
                     <div>
                        <p>PGQL支持类型转换，具有SQL样式的CAST（VALUE AS DATATYPE）语法，例如CAST（'25'AS INT），CAST（10 AS STRING），CAST（'2005-02-04'AS DATE）， CAST（e.weight AS STRING）。下表总结了支持的转换操作。Y表示支持转换，N表示不支持。对无效值（例如，CAST（'xyz'AS INT））或不支持的转换（例如，CAST（10 AS TIMESTAMP））的转换操作返回NULL而不是引发SQL异常。</p>
                        <div class="tblformal" id="GUID-368FDAFB-9183-463B-A623-2D473F64779C__GUID-4CD1D278-C765-4AFD-988F-44F8143AE00F">
                           <p class="titleintable">表4-1 PGQL中的类型转换支持（从和到类型）</p>
                           <table cellpadding="4" cellspacing="0" class="Formal" title="PGQL中的类型转换支持（从和到类型）" border="1" summary="10–column table representing a matrix of “to” and “from” types, where a Y in a cell indicates that casting from the specific data type to the specific daya type is supported, and an N indicates that casting is not supported." frame="hsides" rules="rows">
                              <thead>
                                 <tr align="left" valign="top">
                                    <th align="left" valign="bottom" width="20%" id="d22162e2064">“输入</th>
                                    <th align="left" valign="bottom" width="20%" id="d22162e2067">来自STRING</th>
                                    <th align="left" valign="bottom" width="20%" id="d22162e2070">来自INT</th>
                                    <th align="left" valign="bottom" width="20%" id="d22162e2073">来自LONG</th>
                                    <th align="left" valign="bottom" width="20%" id="d22162e2076">来自FLOAT</th>
                                    <th align="left" valign="bottom" width="20%" id="d22162e2079">来自DOUBLE</th>
                                    <th align="left" valign="bottom" width="20%" id="d22162e2082">来自BOOLEAN</th>
                                    <th align="left" valign="bottom" width="20%" id="d22162e2085">从日期</th>
                                    <th align="left" valign="bottom" width="20%" id="d22162e2088">来自TIMESTAMP</th>
                                    <th align="left" valign="bottom" width="20%" id="d22162e2091">来自TIMESTAMP WITH TIMEZONE</th>
                                 </tr>
                              </thead>
                              <tbody>
                                 <tr align="left" valign="top">
                                    <td rowspan="1" colspan="1" align="left" valign="top" id="d22162e2097" headers="d22162e2064 ">
                                       <p>到STRING</p>
                                    </td>
                                    <td rowspan="1" colspan="1" align="left" valign="top" headers="d22162e2097 d22162e2067 ">
                                       <p>ÿ</p>
                                    </td>
                                    <td rowspan="1" colspan="1" align="left" valign="top" headers="d22162e2097 d22162e2070 ">
                                       <p>ÿ</p>
                                    </td>
                                    <td rowspan="1" colspan="1" align="left" valign="top" headers="d22162e2097 d22162e2073 ">
                                       <p>ÿ</p>
                                    </td>
                                    <td rowspan="1" colspan="1" align="left" valign="top" headers="d22162e2097 d22162e2076 ">
                                       <p>ÿ</p>
                                    </td>
                                    <td rowspan="1" colspan="1" align="left" valign="top" headers="d22162e2097 d22162e2079 ">
                                       <p>ÿ</p>
                                    </td>
                                    <td rowspan="1" colspan="1" align="left" valign="top" headers="d22162e2097 d22162e2082 ">
                                       <p>ÿ</p>
                                    </td>
                                    <td rowspan="1" colspan="1" align="left" valign="top" headers="d22162e2097 d22162e2085 ">
                                       <p>ÿ</p>
                                    </td>
                                    <td rowspan="1" colspan="1" align="left" valign="top" headers="d22162e2097 d22162e2088 ">
                                       <p>ÿ</p>
                                    </td>
                                    <td rowspan="1" colspan="1" align="left" valign="top" headers="d22162e2097 d22162e2091 ">
                                       <p>ÿ</p>
                                    </td>
                                 </tr>
                                 <tr align="left" valign="top">
                                    <td rowspan="1" colspan="1" align="left" valign="top" id="d22162e2128" headers="d22162e2064 ">
                                       <p>到INT</p>
                                    </td>
                                    <td rowspan="1" colspan="1" align="left" valign="top" headers="d22162e2128 d22162e2067 ">
                                       <p>ÿ</p>
                                    </td>
                                    <td rowspan="1" colspan="1" align="left" valign="top" headers="d22162e2128 d22162e2070 ">
                                       <p>ÿ</p>
                                    </td>
                                    <td rowspan="1" colspan="1" align="left" valign="top" headers="d22162e2128 d22162e2073 ">
                                       <p>ÿ</p>
                                    </td>
                                    <td rowspan="1" colspan="1" align="left" valign="top" headers="d22162e2128 d22162e2076 ">
                                       <p>ÿ</p>
                                    </td>
                                    <td rowspan="1" colspan="1" align="left" valign="top" headers="d22162e2128 d22162e2079 ">
                                       <p>ÿ</p>
                                    </td>
                                    <td rowspan="1" colspan="1" align="left" valign="top" headers="d22162e2128 d22162e2082 ">
                                       <p>ÿ</p>
                                    </td>
                                    <td rowspan="1" colspan="1" align="left" valign="top" headers="d22162e2128 d22162e2085 ">
                                       <p>ñ</p>
                                    </td>
                                    <td rowspan="1" colspan="1" align="left" valign="top" headers="d22162e2128 d22162e2088 ">
                                       <p>ñ</p>
                                    </td>
                                    <td rowspan="1" colspan="1" align="left" valign="top" headers="d22162e2128 d22162e2091 ">
                                       <p>ñ</p>
                                    </td>
                                 </tr>
                                 <tr align="left" valign="top">
                                    <td rowspan="1" colspan="1" align="left" valign="top" id="d22162e2159" headers="d22162e2064 ">
                                       <p>到了</p>
                                    </td>
                                    <td rowspan="1" colspan="1" align="left" valign="top" headers="d22162e2159 d22162e2067 ">
                                       <p>ÿ</p>
                                    </td>
                                    <td rowspan="1" colspan="1" align="left" valign="top" headers="d22162e2159 d22162e2070 ">
                                       <p>ÿ</p>
                                    </td>
                                    <td rowspan="1" colspan="1" align="left" valign="top" headers="d22162e2159 d22162e2073 ">
                                       <p>ÿ</p>
                                    </td>
                                    <td rowspan="1" colspan="1" align="left" valign="top" headers="d22162e2159 d22162e2076 ">
                                       <p>ÿ</p>
                                    </td>
                                    <td rowspan="1" colspan="1" align="left" valign="top" headers="d22162e2159 d22162e2079 ">
                                       <p>ÿ</p>
                                    </td>
                                    <td rowspan="1" colspan="1" align="left" valign="top" headers="d22162e2159 d22162e2082 ">
                                       <p>ÿ</p>
                                    </td>
                                    <td rowspan="1" colspan="1" align="left" valign="top" headers="d22162e2159 d22162e2085 ">
                                       <p>ñ</p>
                                    </td>
                                    <td rowspan="1" colspan="1" align="left" valign="top" headers="d22162e2159 d22162e2088 ">
                                       <p>ñ</p>
                                    </td>
                                    <td rowspan="1" colspan="1" align="left" valign="top" headers="d22162e2159 d22162e2091 ">
                                       <p>ñ</p>
                                    </td>
                                 </tr>
                                 <tr align="left" valign="top">
                                    <td rowspan="1" colspan="1" align="left" valign="top" id="d22162e2190" headers="d22162e2064 ">
                                       <p>漂浮</p>
                                    </td>
                                    <td rowspan="1" colspan="1" align="left" valign="top" headers="d22162e2190 d22162e2067 ">
                                       <p>ÿ</p>
                                    </td>
                                    <td rowspan="1" colspan="1" align="left" valign="top" headers="d22162e2190 d22162e2070 ">
                                       <p>ÿ</p>
                                    </td>
                                    <td rowspan="1" colspan="1" align="left" valign="top" headers="d22162e2190 d22162e2073 ">
                                       <p>ÿ</p>
                                    </td>
                                    <td rowspan="1" colspan="1" align="left" valign="top" headers="d22162e2190 d22162e2076 ">
                                       <p>ÿ</p>
                                    </td>
                                    <td rowspan="1" colspan="1" align="left" valign="top" headers="d22162e2190 d22162e2079 ">
                                       <p>ÿ</p>
                                    </td>
                                    <td rowspan="1" colspan="1" align="left" valign="top" headers="d22162e2190 d22162e2082 ">
                                       <p>ÿ</p>
                                    </td>
                                    <td rowspan="1" colspan="1" align="left" valign="top" headers="d22162e2190 d22162e2085 ">
                                       <p>ñ</p>
                                    </td>
                                    <td rowspan="1" colspan="1" align="left" valign="top" headers="d22162e2190 d22162e2088 ">
                                       <p>ñ</p>
                                    </td>
                                    <td rowspan="1" colspan="1" align="left" valign="top" headers="d22162e2190 d22162e2091 ">
                                       <p>ñ</p>
                                    </td>
                                 </tr>
                                 <tr align="left" valign="top">
                                    <td rowspan="1" colspan="1" align="left" valign="top" id="d22162e2221" headers="d22162e2064 ">
                                       <p>双倍</p>
                                    </td>
                                    <td rowspan="1" colspan="1" align="left" valign="top" headers="d22162e2221 d22162e2067 ">
                                       <p>ÿ</p>
                                    </td>
                                    <td rowspan="1" colspan="1" align="left" valign="top" headers="d22162e2221 d22162e2070 ">
                                       <p>ÿ</p>
                                    </td>
                                    <td rowspan="1" colspan="1" align="left" valign="top" headers="d22162e2221 d22162e2073 ">
                                       <p>ÿ</p>
                                    </td>
                                    <td rowspan="1" colspan="1" align="left" valign="top" headers="d22162e2221 d22162e2076 ">
                                       <p>ÿ</p>
                                    </td>
                                    <td rowspan="1" colspan="1" align="left" valign="top" headers="d22162e2221 d22162e2079 ">
                                       <p>ÿ</p>
                                    </td>
                                    <td rowspan="1" colspan="1" align="left" valign="top" headers="d22162e2221 d22162e2082 ">
                                       <p>ÿ</p>
                                    </td>
                                    <td rowspan="1" colspan="1" align="left" valign="top" headers="d22162e2221 d22162e2085 ">
                                       <p>ñ</p>
                                    </td>
                                    <td rowspan="1" colspan="1" align="left" valign="top" headers="d22162e2221 d22162e2088 ">
                                       <p>ñ</p>
                                    </td>
                                    <td rowspan="1" colspan="1" align="left" valign="top" headers="d22162e2221 d22162e2091 ">
                                       <p>ñ</p>
                                    </td>
                                 </tr>
                                 <tr align="left" valign="top">
                                    <td rowspan="1" colspan="1" align="left" valign="top" id="d22162e2252" headers="d22162e2064 ">
                                       <p>到BOOLEAN</p>
                                    </td>
                                    <td rowspan="1" colspan="1" align="left" valign="top" headers="d22162e2252 d22162e2067 ">
                                       <p>ÿ</p>
                                    </td>
                                    <td rowspan="1" colspan="1" align="left" valign="top" headers="d22162e2252 d22162e2070 ">
                                       <p>ÿ</p>
                                    </td>
                                    <td rowspan="1" colspan="1" align="left" valign="top" headers="d22162e2252 d22162e2073 ">
                                       <p>ÿ</p>
                                    </td>
                                    <td rowspan="1" colspan="1" align="left" valign="top" headers="d22162e2252 d22162e2076 ">
                                       <p>ÿ</p>
                                    </td>
                                    <td rowspan="1" colspan="1" align="left" valign="top" headers="d22162e2252 d22162e2079 ">
                                       <p>ÿ</p>
                                    </td>
                                    <td rowspan="1" colspan="1" align="left" valign="top" headers="d22162e2252 d22162e2082 ">
                                       <p>ÿ</p>
                                    </td>
                                    <td rowspan="1" colspan="1" align="left" valign="top" headers="d22162e2252 d22162e2085 ">
                                       <p>ñ</p>
                                    </td>
                                    <td rowspan="1" colspan="1" align="left" valign="top" headers="d22162e2252 d22162e2088 ">
                                       <p>ñ</p>
                                    </td>
                                    <td rowspan="1" colspan="1" align="left" valign="top" headers="d22162e2252 d22162e2091 ">
                                       <p>ñ</p>
                                    </td>
                                 </tr>
                                 <tr align="left" valign="top">
                                    <td rowspan="1" colspan="1" align="left" valign="top" id="d22162e2283" headers="d22162e2064 ">
                                       <p>至今</p>
                                    </td>
                                    <td rowspan="1" colspan="1" align="left" valign="top" headers="d22162e2283 d22162e2067 ">
                                       <p>ÿ</p>
                                    </td>
                                    <td rowspan="1" colspan="1" align="left" valign="top" headers="d22162e2283 d22162e2070 ">
                                       <p>ñ</p>
                                    </td>
                                    <td rowspan="1" colspan="1" align="left" valign="top" headers="d22162e2283 d22162e2073 ">
                                       <p>ñ</p>
                                    </td>
                                    <td rowspan="1" colspan="1" align="left" valign="top" headers="d22162e2283 d22162e2076 ">
                                       <p>ñ</p>
                                    </td>
                                    <td rowspan="1" colspan="1" align="left" valign="top" headers="d22162e2283 d22162e2079 ">
                                       <p>ñ</p>
                                    </td>
                                    <td rowspan="1" colspan="1" align="left" valign="top" headers="d22162e2283 d22162e2082 ">
                                       <p>ñ</p>
                                    </td>
                                    <td rowspan="1" colspan="1" align="left" valign="top" headers="d22162e2283 d22162e2085 ">
                                       <p>ÿ</p>
                                    </td>
                                    <td rowspan="1" colspan="1" align="left" valign="top" headers="d22162e2283 d22162e2088 ">
                                       <p>ÿ</p>
                                    </td>
                                    <td rowspan="1" colspan="1" align="left" valign="top" headers="d22162e2283 d22162e2091 ">
                                       <p>ÿ</p>
                                    </td>
                                 </tr>
                                 <tr align="left" valign="top">
                                    <td rowspan="1" colspan="1" align="left" valign="top" id="d22162e2314" headers="d22162e2064 ">
                                       <p>到TIMESTAMP</p>
                                    </td>
                                    <td rowspan="1" colspan="1" align="left" valign="top" headers="d22162e2314 d22162e2067 ">
                                       <p>ÿ</p>
                                    </td>
                                    <td rowspan="1" colspan="1" align="left" valign="top" headers="d22162e2314 d22162e2070 ">
                                       <p>ñ</p>
                                    </td>
                                    <td rowspan="1" colspan="1" align="left" valign="top" headers="d22162e2314 d22162e2073 ">
                                       <p>ñ</p>
                                    </td>
                                    <td rowspan="1" colspan="1" align="left" valign="top" headers="d22162e2314 d22162e2076 ">
                                       <p>ñ</p>
                                    </td>
                                    <td rowspan="1" colspan="1" align="left" valign="top" headers="d22162e2314 d22162e2079 ">
                                       <p>ñ</p>
                                    </td>
                                    <td rowspan="1" colspan="1" align="left" valign="top" headers="d22162e2314 d22162e2082 ">
                                       <p>ñ</p>
                                    </td>
                                    <td rowspan="1" colspan="1" align="left" valign="top" headers="d22162e2314 d22162e2085 ">
                                       <p>ÿ</p>
                                    </td>
                                    <td rowspan="1" colspan="1" align="left" valign="top" headers="d22162e2314 d22162e2088 ">
                                       <p>ÿ</p>
                                    </td>
                                    <td rowspan="1" colspan="1" align="left" valign="top" headers="d22162e2314 d22162e2091 ">
                                       <p>ÿ</p>
                                    </td>
                                 </tr>
                                 <tr align="left" valign="top">
                                    <td rowspan="1" colspan="1" align="left" valign="top" id="d22162e2345" headers="d22162e2064 ">
                                       <p>TIMESTAMP WITH TIMEZONE</p>
                                    </td>
                                    <td rowspan="1" colspan="1" align="left" valign="top" headers="d22162e2345 d22162e2067 ">
                                       <p>ÿ</p>
                                    </td>
                                    <td rowspan="1" colspan="1" align="left" valign="top" headers="d22162e2345 d22162e2070 ">
                                       <p>ñ</p>
                                    </td>
                                    <td rowspan="1" colspan="1" align="left" valign="top" headers="d22162e2345 d22162e2073 ">
                                       <p>ñ</p>
                                    </td>
                                    <td rowspan="1" colspan="1" align="left" valign="top" headers="d22162e2345 d22162e2076 ">
                                       <p>ñ</p>
                                    </td>
                                    <td rowspan="1" colspan="1" align="left" valign="top" headers="d22162e2345 d22162e2079 ">
                                       <p>ñ</p>
                                    </td>
                                    <td rowspan="1" colspan="1" align="left" valign="top" headers="d22162e2345 d22162e2082 ">
                                       <p>ñ</p>
                                    </td>
                                    <td rowspan="1" colspan="1" align="left" valign="top" headers="d22162e2345 d22162e2085 ">
                                       <p>ÿ</p>
                                    </td>
                                    <td rowspan="1" colspan="1" align="left" valign="top" headers="d22162e2345 d22162e2088 ">
                                       <p>ÿ</p>
                                    </td>
                                    <td rowspan="1" colspan="1" align="left" valign="top" headers="d22162e2345 d22162e2091 ">
                                       <p>ÿ</p>
                                    </td>
                                 </tr>
                              </tbody>
                           </table>
                        </div>
                        <!-- class="inftblhruleinformal" -->
                        <p>使用类型转换的示例查询是：</p><pre class="pre codeblock"><code>SELECT e.name，CAST（e.birthDate AS STRING）AS dob WHERE（e），e.birthDate &lt;CAST（'1980-01-01'AS DATE）</code></pre></div>
                     <div>
                        <div class="familylinks">
                           <div class="parentlink">
                              <p><strong>父主题：</strong> <a href="sql-based-property-graph-query-analytics.html#GUID-D2FC29F7-B4C7-407D-BE73-784E593DC73C">支持PGQL功能</a></p>
                           </div>
                        </div>
                     </div>
                     
                  </div>
                  <div class="props_rev_3"><a id="GUID-D50795B1-079B-4A0F-99C6-5157F28D941A" name="GUID-D50795B1-079B-4A0F-99C6-5157F28D941A"></a><h5 id="SPGDG-GUID-D50795B1-079B-4A0F-99C6-5157F28D941A" class="sect5"><span class="enumeration_section">4.8.1.3</span>缺少属性</h5>
                     <div>
                        <p>当顶点或边缺少从PGQL查询投影的属性时，包含该顶点或边的结果行将从查询结果中排除，而不是包含在NULL值中。</p>
                        <p>例如，以下查询：</p><pre class="pre codeblock"><code>SELECT v.name MATCH（v）</code></pre><p>将从查询结果中排除缺少<code class="codeph">name</code>属性的所有顶点。
                        </p>
                     </div>
                     <div>
                        <div class="familylinks">
                           <div class="parentlink">
                              <p><strong>父主题：</strong> <a href="sql-based-property-graph-query-analytics.html#GUID-D2FC29F7-B4C7-407D-BE73-784E593DC73C">支持PGQL功能</a></p>
                           </div>
                        </div>
                     </div>
                     
                  </div>
                  <div class="props_rev_3"><a id="GUID-0DE03EC7-2D45-4B5F-B940-0F86CE51CC1A" name="GUID-0DE03EC7-2D45-4B5F-B940-0F86CE51CC1A"></a><h5 id="SPGDG-GUID-0DE03EC7-2D45-4B5F-B940-0F86CE51CC1A" class="sect5"><span class="enumeration_section">4.8.1.4包含</span>内置函数</h5>
                     <div>
                        <p>支持CONTAINS内置函数。它与顶点和边缘属性上的Oracle Text索引结合使用。如果值与Oracle Text搜索字符串匹配，则CONTAINS返回<code class="codeph">true</code>如果值不匹配，则返回<code class="codeph">false</code> 。
                        </p>
                        <p>示例查询是：</p><pre class="pre codeblock"><code>SELECT v.name WHERE（v），CONTAINS（v.abstract，'Oracle'）</code></pre><p>有关<a href="sql-based-property-graph-query-analytics.html#GUID-6C522195-4D93-4EC3-943A-CBD8D3B22F24">使用PGQL的全文索引</a>的详细信息，另请参阅<a href="sql-based-property-graph-query-analytics.html#GUID-6C522195-4D93-4EC3-943A-CBD8D3B22F24">将文本索引与PGQL查询</a>一起使用。</p>
                     </div>
                     <div>
                        <div class="familylinks">
                           <div class="parentlink">
                              <p><strong>父主题：</strong> <a href="sql-based-property-graph-query-analytics.html#GUID-D2FC29F7-B4C7-407D-BE73-784E593DC73C">支持PGQL功能</a></p>
                           </div>
                        </div>
                     </div>
                     
                  </div>
               </div>
               <div class="props_rev_3"><a id="GUID-296732FE-D57B-41B5-937B-078E234422CC" name="GUID-296732FE-D57B-41B5-937B-078E234422CC"></a><h4 id="SPGDG-GUID-296732FE-D57B-41B5-937B-078E234422CC" class="sect4"><span class="enumeration_section">4.8.2</span>使用oracle.pg.rdbms Java包执行PGQL查询</h4>
                  <div>
                     <p>Oracle Spatial and Graph属性图支持在<code class="codeph">oracle.pg.rdbms</code>包中提供了一个Java API，用于对Oracle Database执行PGQL查询。本节通过一系列示例说明如何使用Java API。
                     </p>
                     <div class="infoboxnote" id="GUID-296732FE-D57B-41B5-937B-078E234422CC__GUID-14C35ED2-4F82-4173-869B-5E9363E7BAB6">
                        <p class="notep1">注意：</p>
                        <p>从版本19c开始， <code class="codeph">oracle.pg.rdbms.不推荐使用OraclePgqlResultSet</code>接口，将来的版本将删除它。而是使用标准化的接口<code class="codeph">oracle.pgql.lang.ResultSet</code>从PGQL结果集中检索值。
                        </p>
                        <p>这两个接口之间的一个区别是<code class="codeph">oracle.pgql.lang.ResultSet</code>不提供API来检索顶点和边缘对象。使用这些接口的现有代码应更改为项目ID，而不是<code class="codeph">OracleVertex</code>和<code class="codeph">OracleEdge</code>对象。您可以通过调用<code class="codeph">OracleVertex.getInstance()</code>或<code class="codeph">OracleEdge.getInstance()</code>从投影的ID值中获取<code class="codeph">OracleVertex</code>或<code class="codeph">OracleEdge</code>对象。（例如，请参见<a href="sql-based-property-graph-query-analytics.html#GUID-4B12B361-A502-4B39-9267-E457C2F14D74__PGQLEXAMPLE12.JAVA-1F6E0823">例4-37</a> 。）
                        </p>
                     </div>
                     <p>要使用PGQL查询功能，请将以下类导入Java程序：</p><pre class="pre codeblock"><code>import oracle.pg.rdbms。*; import oracle.pgql.lang。PgqlException; import oracle.pgql.lang。ResultSet的;</code></pre><p>Oracle平面文件格式中的以下<code class="codeph">test_graph</code>数据集将用于后面的子主题中的示例中。数据集包括顶点文件（ <code class="codeph">test_graph.opv</code> ）和边缘文件（ <code class="codeph">test_graph.ope</code> ）</p>
                     <p><code class="codeph">test_graph <span class="bold">.opv</span></code> ：</p><pre class="oac_no_warn" dir="ltr">2，fname，1，Ray ,, 2，lname，1，Green ,, 2，mval，5 ,,, 1985-01-01T12：00：00.000Z 2，年龄，2，，41，0，bval，6 ，Y ,, 0，fname，1，Bill ,, 0，lname，1，Brown ,, 0，mval，1，y ,, 0，age，2，，40，1，bval，6，Y ,, 1 ，fname，1，John ,, 1，lname，1，Black ,, 1，mval，2，，27，1，age，2，，30,3，bval，6，N ,, 3，fname，1， Susan ,, 3，lname，1，Blue ,, 3，mval，6，N ,, 3，年龄，2，35，</pre><p><code class="codeph">test_graph <span class="bold">.ope</span></code> ：</p><pre class="oac_no_warn" dir="ltr">4,0,1，know，mval，1，Y ,, 4,0,1，know，firstMetIn，1，MI ,, 4,0,1，know，since，5 ,,, 1990-01-01T12： 00：00.000Z 16,0,1，friendOf，strength，2，，6,7,1,0，know，mval，5 ,,, 2003-01-01T12：00：00.000Z 7,1,0，know ，firstMetIn，1，GA ,, 7,1,0，知道，因为，5 ,,, 2000-01-01T12：00：00.000Z 17,1,0，friendOf，strength，2，，7,9,1 ，3，知道，mval，6，N ,, 9,1,3，知道，firstMetIn，1，SC ,, 9,1,3，知道，因为，5 ,,, 2005-01-01T12：00：00.000 Z 10,2,0，知道，mval，1，N ,, 10,2,0，知道，firstMetIn，1，TX ,, 10,2,0，知道，因为，5 ,,, 1997-01-01T12 ：00：00.000Z 12,2,3，know，mval，3，342.5,12,2,3，know，firstMetIn，1，TX ,, 12,2,3，know，since，5 ,,, 2011 -01-01T12：00：00.000Z 19,2,3，friendOf，strength，2,4，14,3,1，know，mval，1，a，14,3,1，knows，firstMetIn，1 ，CA ,, 14,3,1，知道，因为，5 ,,, 2010-01-01T12：00：00.000Z 15,3,2，知道，mval，1，z ,, 15,3,2，知道，firstMetIn，1，CA ,, 15,3,2，知道，因为，5 ,,, 2004-01-01T12：00：00.000Z 5,0,2，知道，mval，2，，23，5,0 ，2，知道，firstMetIn，1，OH ,, 5,0,2，知道，因为，5 ,,, 2002-01-01T12：00：00.000Z 6,0,3，know，mval，3，，159.7 ，6,0,3，知道，firstMetIn，1，IN ,, 6,0,3，知道s，since，5 ,,, 1994-01-01T12：00：00.000Z 8,1,2，know，mval，6，Y ,, 8,1,2，know，firstMetIn，1，FL ,, 8， 1,2，知道，因为，5 ,,, 1999-01-01T12：00：00.000Z 18,1,3，朋友，力量，2，5，11,2,1，知道，mval，2 ,, 1001,11,2,1，知道，firstMetIn，1，OK ,, 11,2,1，知道，因为，5 ,,, 2003-01-01T12：00：00.000Z 13,3,0，知道，mval ，5 ,,, 2001-01-01T12：00：00.000Z 13,3,0，know，firstMetIn，1，CA ,, 13,3,0，know，since，5 ,,, 2006-01-01T12： 00：00.000Z 20,3,1，朋友，力量，2，3，</pre></div>
                  <div>
                     <ul class="ullinks">
                        <li class="ulchildlink"><a href="sql-based-property-graph-query-analytics.html#GUID-120AA4F5-7263-4B51-9E7A-46712FD985A9">基本查询执行</a><br></li>
                        <li class="ulchildlink"><a href="sql-based-property-graph-query-analytics.html#GUID-E9657B9D-B648-484F-9572-7DDD7F038871">在PGQL查询中使用绑定变量</a><br></li>
                        <li class="ulchildlink"><a href="sql-based-property-graph-query-analytics.html#GUID-6C522195-4D93-4EC3-943A-CBD8D3B22F24">使用带有PGQL查询的文本索引</a><br></li>
                        <li class="ulchildlink"><a href="sql-based-property-graph-query-analytics.html#GUID-7642327B-B973-4C48-90B1-1447F3D57CA5">获取PGQL查询的SQL转换</a><br></li>
                        <li class="ulchildlink"><a href="sql-based-property-graph-query-analytics.html#GUID-E9CC82C3-BD5A-4581-AE26-2432D6929D44">PGQL翻译和执行的附加选项</a><br></li>
                        <li class="ulchildlink"><a href="sql-based-property-graph-query-analytics.html#GUID-623F91CC-1686-4D95-B69F-FA7F81352A90">查询另一个用户的属性图</a><br></li>
                        <li class="ulchildlink"><a href="sql-based-property-graph-query-analytics.html#GUID-EECCE896-473F-46DD-8805-9BF696DF60AF">使用PGQL的查询优化器提示</a><br></li>
                     </ul>
                     <div class="familylinks">
                        <div class="parentlink">
                           <p><strong>父主题：</strong> <a href="sql-based-property-graph-query-analytics.html#GUID-94F08780-EC3D-4F9B-985F-49984939E61C" title="本主题说明如何直接对Oracle数据库中的图形执行PGQL查询（而不是内存中）。">直接针对Oracle数据库执行PGQL查询</a></p>
                        </div>
                     </div>
                  </div>
                  
                  <div class="props_rev_3"><a id="GUID-120AA4F5-7263-4B51-9E7A-46712FD985A9" name="GUID-120AA4F5-7263-4B51-9E7A-46712FD985A9"></a><h5 id="SPGDG-GUID-120AA4F5-7263-4B51-9E7A-46712FD985A9" class="sect5"><span class="enumeration_section">4.8.2.1</span>基本查询执行</h5>
                     <div>
                        <p>两个主要的Java接口， <code class="codeph">OraclePgqlStatement</code>和<code class="codeph">oracle.pgql.lang.ResultSet</code>用于PGQL执行。本主题包括几个基本查询执行的示例。
                        </p>
                        <div class="example" id="GUID-120AA4F5-7263-4B51-9E7A-46712FD985A9__GUID-E3C78120-0F0F-4530-AFAE-4ADEEAD64126">
                           <p class="titleinexample">例4-24 PgqlExample1.java</p>
                           <p><code class="codeph">PgqlExample1.java</code>显示了执行PGQL查询并迭代查询结果的示例。<code class="codeph">OraclePgqlExecutionFactory</code>用于获得一个<code class="codeph">OraclePgqlStatement</code>从<code class="codeph">OraclePropertyGraph</code>对象。接下来，它调用<code class="codeph">OraclePgqlStatement</code>的<code class="codeph">executeQuery</code>方法，该方法返回一个<code class="codeph">oracle.pgql.lang.ResultSet</code>对象。<code class="codeph">ResultSet</code>提供了一个用于使用与<code class="codeph">java.sql.非常相似的查询结果的接口<code class="codeph">java.sql.ResultSet</code>接口。
                           </p>
                           <p><code class="codeph">oracle.pgql.lang。ResultSet</code>提供了一个<code class="codeph">next()</code>方法，用于遍历查询结果，并提供<code class="codeph">close()</code>方法，以便在应用程序读取查询结果后释放资源。此外， <code class="codeph">ResultSet</code>为String，Integer，Long，Float，Double，Boolean，LocalDateTime，OffsetDateTime提供了getter，它为任何类型的值提供了通用的<code class="codeph">getObject()</code>方法。
                           </p>
                           <p>在使用查询结果后，应关闭<code class="codeph">ResultSet</code>和<code class="codeph">OraclePgqlStatement</code>对象。
                           </p><pre class="pre codeblock"><code>import oracle.pg.rdbms。*;导入oracle.pg.common。*; import oracle.pgql.lang。PgqlException; import oracle.pgql.lang。ResultSet的; import java.util。*; import java.text。*; / ** *此示例显示如何对存储在Oracle数据库中的磁盘驻留* PG数据执行基本PGQL查询，并迭代结果。* / public class PgqlExample1 {public static void main（String [] szArgs）throws Exception {int iArgIdx = 0; String szHost = szArgs [iArgIdx ++]; String szPort = szArgs [iArgIdx ++]; String szSID = szArgs [iArgIdx ++]; String szUser = szArgs [iArgIdx ++]; String szPassword = szArgs [iArgIdx ++]; String szGraph = szArgs [iArgIdx ++]; String szVertexFile = szArgs [iArgIdx ++]; String szEdgeFile = szArgs [iArgIdx ++]; Oracle oracle = null; OraclePropertyGraph opg = null; OraclePgqlStatement ops = null; ResultSet rs = null; try {//创建与Oracle的连接oracle = new Oracle（“jdbc：oracle：thin：@”+ szHost +“：”+ szPort +“：”+ szSID，szUser，szPassword）; //创建属性图opg = OraclePropertyGraph.getInstance（oracle，szGraph）; //清除所有现有数据opg.clearRepository（）; //加载数据OraclePropertyGraphDataLoader opgLoader = OraclePropertyGraphDataLoader.getInstance（）; opgLoader.loadData（opg，szVertexFile，szEdgeFile，1）; //创建OraclePgqlStatement ops = OraclePgqlExecutionFactory.createStatement（opg）; //执行查询以获取ResultSet对象字符串pgql =“SELECT v.fname AS fname，v.lname AS lname，v.mval AS mval”+“MATCH（v）”; rs = ops.executeQuery（pgql，/ *查询字符串* /“”/ * options * /）; //使用oracle.pgql.lang使用结果集。ResultSet接口SimpleDateFormat sdf = new SimpleDateFormat（“yyyy-MM-dd'T'HH：mm：ss。SSSXXX“）; while（rs.next（））{// get fname String fname = rs.getString（1）; // get lname String lname = rs.getString（2）; // get mval Object mval = rs。 getObject（3）; String mStr =“”; if（mval instanceof java.lang。字符串）{mStr =“STRING：”+ mval.toString（）; } else if（mval instanceof java.lang。整数）{mStr =“INTEGER：”+ mval.toString（）; } else if（mval instanceof java.lang。长）{mStr =“LONG：”+ mval.toString（）; } else if（mval instanceof java.lang。Float）{mStr =“FLOAT：”+ mval.toString（）; } else if（mval instanceof java.lang。Double）{mStr =“DOUBLE：”+ mval.toString（）; } else if（mval instanceof java.sql。时间戳）{mStr =“DATE：”+ sdf.format（（Date）mval）; } else if（mval instanceof java.lang。Boolean）{mStr =“BOOLEAN：”+ mval.toString（）; System.out.println（“[fname =”+ fname +“，lname =”+ lname +“，mval =”+ mStr +“]”）;最后{//关闭结果集if（rs！）= null）{rs.close（）; } //关闭语句if（ops！= null）{ops.close（）; } //关闭属性图if（opg！= null）{opg.shutdown（）; } //关闭oracle if（oracle！= null）{oracle.dispose（）; }}}}</code></pre><p><code class="codeph">PgqlExample1.java</code>给出了下面的输出<code class="codeph">test_graph</code> 。
                           </p><pre class="oac_no_warn" dir="ltr">[fname = Susan，lname = Blue，mval = BOOLEAN：false] [fname = Bill，lname = Brown，mval = STRING：y] [fname = Ray，lname = Green，mval = DATE：1985-01-01T04：00 ：00.000-08：00] [fname = John，lname = Black，mval = INTEGER：27]</pre></div>
                        <!-- class="example" -->
                        <div class="example" id="GUID-120AA4F5-7263-4B51-9E7A-46712FD985A9__GUID-D3262532-7CA1-4045-A7FC-DC20171912CA">
                           <p class="titleinexample">例4-25 PgqlExample2.java</p>
                           <p><code class="codeph">PgqlExample2.java</code>显示带有边缘属性的时间过滤器的PGQL查询。
                           </p><pre class="pre codeblock"><code>import oracle.pg.rdbms。*;导入oracle.pg.common。*; import oracle.pgql.lang。PgqlException; import oracle.pgql.lang。ResultSet的; import java.util。*; import java.text。*; / ** *此示例显示如何使用临时边缘*属性过滤器对存储在Oracle Database *中的磁盘驻留PG数据执行PGQL查询，并迭代结果。* / public class PgqlExample2 {public static void main（String [] szArgs）throws Exception {int iArgIdx = 0; String szHost = szArgs [iArgIdx ++]; String szPort = szArgs [iArgIdx ++]; String szSID = szArgs [iArgIdx ++]; String szUser = szArgs [iArgIdx ++]; String szPassword = szArgs [iArgIdx ++]; String szGraph = szArgs [iArgIdx ++]; String szVertexFile = szArgs [iArgIdx ++]; String szEdgeFile = szArgs [iArgIdx ++]; Oracle oracle = null; OraclePropertyGraph opg = null; OraclePgqlStatement ops = null; ResultSet rs = null; try {//创建与Oracle的连接oracle = new Oracle（“jdbc：oracle：thin：@”+ szHost +“：”+ szPort +“：”+ szSID，szUser，szPassword）; //创建属性图opg = OraclePropertyGraph.getInstance（oracle，szGraph）; //清除所有现有数据opg.clearRepository（）; //加载数据OraclePropertyGraphDataLoader opgLoader = OraclePropertyGraphDataLoader.getInstance（）; opgLoader.loadData（opg，szVertexFile，szEdgeFile，1）; //创建OraclePgqlStatement ops = OraclePgqlExecutionFactory.createStatement（opg）; //执行查询以获取ResultSet对象字符串pgql =“SELECT v.fname AS n1，v2.fname AS n2，e.firstMetIn AS loc”+“MATCH（v） -  [e：knows]  - &gt;（v2）” +“WHERE e.since&gt; TIMESTAMP'2000-01-01 00：00：00.00 + 00:00'”; rs = ops.executeQuery（pgql，“”）; //打印结果printResults（rs，3）; } finally {//关闭结果集if（rs！= null）{rs.close（）; } //关闭语句if（ops！= null）{ops.close（）; } //关闭属性图if（opg！= null）{opg.shutdown（）; } //关闭oracle if（oracle！= null）{oracle.dispose（）; / ** *打印PGQL ResultSet * / static void printResults（ResultSet rs，int numCols）throws Exception {StringBuffer buff = new StringBuffer（“”）; SimpleDateFormat sdf = new SimpleDateFormat（“yyyy-MM-dd'T'HH：mm：ss。SSSXXX“）; while（rs.next（））{buff.append（”[“）; for（int i = 1; i &lt;= numCols; i ++）{//使用泛型getObject来处理所有类型Object mval = rs .getObject（i）; String mStr =“”; if（mval instanceof java.lang。字符串）{mStr =“STRING：”+ mval.toString（）; } else if（mval instanceof java.lang。整数）{mStr =“INTEGER：”+ mval.toString（）; } else if（mval instanceof java.lang。长）{mStr =“LONG：”+ mval.toString（）; } else if（mval instanceof java.lang。Float）{mStr =“FLOAT：”+ mval.toString（）; } else if（mval instanceof java.lang。Double）{mStr =“DOUBLE：”+ mval.toString（）; } else if（mval instanceof java.sql。时间戳）{mStr =“DATE：”+ sdf.format（（Date）mval）; } else if（mval instanceof java.lang。Boolean）{mStr =“BOOLEAN：”+ mval.toString（）; } if（i&gt; 1）{buff.append（“，\ t”）; } buff.append（mStr）; } buff.append（“] \ n”）; System.out.println（buff.toString（））; }}</code></pre><p><code class="codeph">PgqlExample2.java</code>给出了下面的输出<code class="codeph">test_graph</code> 。
                           </p><pre class="oac_no_warn" dir="ltr">[STRING：Ray，STRING：约翰，STRING：好的] [STRING：Bill，STRING：Ray，STRING：OH] [STRING：Susan，STRING：Bill，STRING：CA] [STRING：John，STRING：Susan，STRING： SC] [STRING：Ray，STRING：Susan，STRING：TX] [STRING：John，STRING：Bill，STRING：GA] [STRING：Susan，STRING：John，STRING：CA] [STRING：Susan，STRING：Ray， STRING：CA]</pre></div>
                        <!-- class="example" -->
                        <div class="example" id="GUID-120AA4F5-7263-4B51-9E7A-46712FD985A9__GUID-D87D64CE-29BD-497D-A13A-2B9C51ECDA48">
                           <p class="titleinexample">例4-26 PgqlExample3.java</p>
                           <p><code class="codeph">PgqlExample3.java</code>显示带有分组和聚合的PGQL查询。
                           </p><pre class="pre codeblock"><code>import oracle.pg.rdbms。*;导入oracle.pg.common。*; import oracle.pgql.lang。PgqlException; import oracle.pgql.lang。ResultSet的; import java.util。*; import java.text。*; / ** *此示例显示如何使用聚合*对存储在Oracle数据库中的磁盘驻留PG数据执行PGQL查询，并通过结果迭代*。* / public class PgqlExample3 {public static void main（String [] szArgs）throws Exception {int iArgIdx = 0; String szHost = szArgs [iArgIdx ++]; String szPort = szArgs [iArgIdx ++]; String szSID = szArgs [iArgIdx ++]; String szUser = szArgs [iArgIdx ++]; String szPassword = szArgs [iArgIdx ++]; String szGraph = szArgs [iArgIdx ++]; String szVertexFile = szArgs [iArgIdx ++]; String szEdgeFile = szArgs [iArgIdx ++]; Oracle oracle = null; OraclePropertyGraph opg = null; OraclePgqlStatement ops = null; ResultSet rs = null; try {//创建与Oracle的连接oracle = new Oracle（“jdbc：oracle：thin：@”+ szHost +“：”+ szPort +“：”+ szSID，szUser，szPassword）; //创建属性图opg = OraclePropertyGraph.getInstance（oracle，szGraph）; //清除所有现有数据opg.clearRepository（）; //加载数据OraclePropertyGraphDataLoader opgLoader = OraclePropertyGraphDataLoader.getInstance（）; opgLoader.loadData（opg，szVertexFile，szEdgeFile，1）; //创建OraclePgqlStatement ops = OraclePgqlExecutionFactory.createStatement（opg）; //执行查询以获取ResultSet对象字符串pgql =“SELECT v.fname AS fname，COUNT（v2）AS friendCnt”+“MATCH（v） -  [e：friendOf]  - &gt;（v2）”+“GROUP BY v “+”ORDER BY friendCnt DESC“; rs = ops.executeQuery（pgql，“”）; //打印结果printResults（rs，2）; } finally {//关闭结果集if（rs！= null）{rs.close（）; } //关闭语句if（ops！= null）{ops.close（）; } //关闭属性图if（opg！= null）{opg.shutdown（）; } //关闭oracle if（oracle！= null）{oracle.dispose（）; / ** *打印PGQL ResultSet * / static void printResults（ResultSet rs，int numCols）throws Exception {StringBuffer buff = new StringBuffer（“”）; SimpleDateFormat sdf = new SimpleDateFormat（“yyyy-MM-dd'T'HH：mm：ss。SSSXXX“）; while（rs.next（））{buff.append（”[“）; for（int i = 1; i &lt;= numCols; i ++）{//使用泛型getObject来处理所有类型Object mval = rs .getObject（i）; String mStr =“”; if（mval instanceof java.lang。字符串）{mStr =“STRING：”+ mval.toString（）; } else if（mval instanceof java.lang。整数）{mStr =“INTEGER：”+ mval.toString（）; } else if（mval instanceof java.lang。长）{mStr =“LONG：”+ mval.toString（）; } else if（mval instanceof java.lang。Float）{mStr =“FLOAT：”+ mval.toString（）; } else if（mval instanceof java.lang。Double）{mStr =“DOUBLE：”+ mval.toString（）; } else if（mval instanceof java.sql。时间戳）{mStr =“DATE：”+ sdf.format（（Date）mval）; } else if（mval instanceof java.lang。Boolean）{mStr =“BOOLEAN：”+ mval.toString（）; } if（i&gt; 1）{buff.append（“，\ t”）; } buff.append（mStr）; } buff.append（“] \ n”）; System.out.println（buff.toString（））; }}</code></pre><p><code class="codeph">PgqlExample3.java</code>给出了下面的输出<code class="codeph">test_graph</code> 。
                           </p><pre class="oac_no_warn" dir="ltr">[STRING：John，LONG：2] [STRING：Bill，LONG：1] [STRING：Ray，LONG：1] [STRING：Susan，LONG：1]</pre></div>
                        <!-- class="example" -->
                        <div class="example" id="GUID-120AA4F5-7263-4B51-9E7A-46712FD985A9__PGQLEXAMPLE4.JAVA-1EEA3A59">
                           <p class="titleinexample">例4-27 PgqlExample4.java</p>
                           <p><code class="codeph">PgqlExample4.java</code>显示PGQL路径查询。
                           </p><pre class="pre codeblock"><code>import oracle.pg.rdbms。*;导入oracle.pg.common。*; import oracle.pgql.lang。PgqlException; import oracle.pgql.lang。ResultSet的; import java.util。*; import java.text。*; / ** *此示例显示如何在PGQL中对存储在Oracle数据库中的*磁盘驻留PG数据执行路径查询，并迭代*通过结果。* / public class PgqlExample4 {public static void main（String [] szArgs）throws Exception {int iArgIdx = 0; String szHost = szArgs [iArgIdx ++]; String szPort = szArgs [iArgIdx ++]; String szSID = szArgs [iArgIdx ++]; String szUser = szArgs [iArgIdx ++]; String szPassword = szArgs [iArgIdx ++]; String szGraph = szArgs [iArgIdx ++]; String szVertexFile = szArgs [iArgIdx ++]; String szEdgeFile = szArgs [iArgIdx ++]; Oracle oracle = null; OraclePropertyGraph opg = null; OraclePgqlStatement ops = null; ResultSet rs = null; try {//创建与Oracle的连接oracle = new Oracle（“jdbc：oracle：thin：@”+ szHost +“：”+ szPort +“：”+ szSID，szUser，szPassword）; //创建属性图opg = OraclePropertyGraph.getInstance（oracle，szGraph）; //清除所有现有数据opg.clearRepository（）; //加载数据OraclePropertyGraphDataLoader opgLoader = OraclePropertyGraphDataLoader.getInstance（）; opgLoader.loadData（opg，szVertexFile，szEdgeFile，1）; //创建OraclePgqlStatement ops = OraclePgqlExecutionFactory.createStatement（opg）; //执行查询以获取ResultSet对象字符串pgql =“PATH fof AS（） -  [：friendOf | knows]  - &gt;（）”+“SELECT v2.fname AS friend”+“MATCH（v） -  /：fof * /  - &gt;（v2）“+”WHERE v.fname ='John'AND v！= v2“; rs = ops.executeQuery（pgql，”“）; //打印结果printResults（rs，1）;} finally {//关闭结果集if（rs！= null）{rs.close（）; } //关闭语句if（ops！= null）{ops.close（）; } //关闭属性图if（opg！= null）{opg.shutdown（）; } //关闭oracle if（oracle！= null）{oracle.dispose（）; / ** *打印PGQL ResultSet * / static void printResults（ResultSet rs，int numCols）throws Exception {StringBuffer buff = new StringBuffer（“”）; SimpleDateFormat sdf = new SimpleDateFormat（“yyyy-MM-dd'T'HH：mm：ss。SSSXXX“）; while（rs.next（））{buff.append（”[“）; for（int i = 1; i &lt;= numCols; i ++）{//使用泛型getObject来处理所有类型Object mval = rs .getObject（i）; String mStr =“”; if（mval instanceof java.lang。字符串）{mStr =“STRING：”+ mval.toString（）; } else if（mval instanceof java.lang。整数）{mStr =“INTEGER：”+ mval.toString（）; } else if（mval instanceof java.lang。长）{mStr =“LONG：”+ mval.toString（）; } else if（mval instanceof java.lang。Float）{mStr =“FLOAT：”+ mval.toString（）; } else if（mval instanceof java.lang。Double）{mStr =“DOUBLE：”+ mval.toString（）; } else if（mval instanceof java.sql。时间戳）{mStr =“DATE：”+ sdf.format（（Date）mval）; } else if（mval instanceof java.lang。Boolean）{mStr =“BOOLEAN：”+ mval.toString（）; } if（i&gt; 1）{buff.append（“，\ t”）; } buff.append（mStr）; } buff.append（“] \ n”）; System.out.println（buff.toString（））; }}</code></pre><p><code class="codeph">PgqlExample4.java</code>给出了下面的输出<code class="codeph">test_graph</code> 。
                           </p><pre class="oac_no_warn" dir="ltr">[[STRING：Susan] [STRING：Bill] [STRING：Ray]</pre></div>
                        <!-- class="example" -->
                     </div>
                     <div>
                        <div class="familylinks">
                           <div class="parentlink">
                              <p><strong>父主题：</strong> <a href="sql-based-property-graph-query-analytics.html#GUID-296732FE-D57B-41B5-937B-078E234422CC">使用oracle.pg.rdbms Java包执行PGQL查询</a></p>
                           </div>
                        </div>
                     </div>
                     
                  </div>
                  <div class="props_rev_3"><a id="GUID-E9657B9D-B648-484F-9572-7DDD7F038871" name="GUID-E9657B9D-B648-484F-9572-7DDD7F038871"></a><h5 id="SPGDG-GUID-E9657B9D-B648-484F-9572-7DDD7F038871" class="sect5"><span class="enumeration_section">4.8.2.2</span>在PGQL查询中使用绑定变量</h5>
                     <div>
                        <p>绑定变量可用于PGQL查询，以获得更好的性能和更高的安全性。PGQL查询中的常量标量值可以用绑定变量替换。绑定变量用'？'表示'（问号）。请考虑以下两个查询选择年龄超过常量年龄的人的查询。</p><pre class="pre codeblock"><code>//年龄大于30岁的人SELECT v.fname AS fname，v.lname AS lname，v.age AS age MATCH（v）WHERE v.age&gt; 30 // 40岁以上的人SELECT v.fname AS fname，v.lname AS lname，v.age AS age MATCH（v）WHERE v.age&gt; 40</code></pre><p>这些查询的SQL转换将以与年龄过滤器类似的方式使用常量30和40。数据库将对每个查询执行硬解析。这种硬分析时间通常可以超过简单查询的执行时间。</p>
                        <p>您可以使用绑定变量替换每个查询中的常量，如下所示。</p><pre class="pre codeblock"><code>SELECT v.fname AS fname，v.lname AS lname，v.age AS age MATCH（v）WHERE v.age&gt;？
</code></pre><p>这将允许SQL引擎为此查询创建通用游标，可以将其重用于不同的年龄值。因此，不再需要硬解析来针对不同的年龄值执行此查询，并且每个查询的解析时间将大大减少。</p>
                        <p>此外，在PGQL查询中使用绑定变量的应用程序比使用字符串连接在PGQL查询中嵌入常量值的应用程序更不容易受到注入攻击。</p>
                        <p>有关游标共享和绑定变量的更多信息，另请参见“ <span class="italic"><a href="../tgsql/improving-rwp-cursor-sharing.html#TGSQL848" target="_blank">Oracle数据库SQL调整指南”</a></span> 。
                        </p>
                        <p><code class="codeph">OraclePgqlPreparedStatement</code>接口可用于使用绑定变量执行查询，如<code class="codeph">PgqlExample5.java</code>所示。<code class="codeph">OraclePgqlPreparedStatement</code>为不同的值类型提供了几种set方法，可用于设置查询执行的值。
                        </p>
                        <p>PGQL中的绑定变量有一些限制。绑定变量只能用于常量属性值。也就是说，顶点和边不能用绑定变量替换。此外，一旦将特定绑定变量设置为类型，就不能将其设置为其他类型。例如，如果对<code class="codeph">OraclePgqlPreparedStatement</code>执行<code class="codeph">setInt(1, 30)</code> <code class="codeph">OraclePgqlPreparedStatement</code> ，则无法在同一<code class="codeph">OraclePgqlPreparedStatement</code>上调用<code class="codeph">setString(1, "abc")</code> 。
                        </p>
                        <div class="example" id="GUID-E9657B9D-B648-484F-9572-7DDD7F038871__PGQLEXAMPLE1.JAVA-1EEBCB49">
                           <p class="titleinexample">例4-28 PgqlExample5.java</p>
                           <p><code class="codeph">PgqlExample5.java</code>显示了如何将绑定变量与PGQL查询一起使用。
                           </p><pre class="pre codeblock"><code>import oracle.pg.rdbms。*;导入oracle.pg.common。*; import oracle.pgql.lang。PgqlException; import oracle.pgql.lang。ResultSet的; import java.util。*; import java.text。*; / ** *此示例显示如何将绑定变量与PGQL查询一起使用。* / public class PgqlExample5 {public static void main（String [] szArgs）throws Exception {int iArgIdx = 0; String szHost = szArgs [iArgIdx ++]; String szPort = szArgs [iArgIdx ++]; String szSID = szArgs [iArgIdx ++]; String szUser = szArgs [iArgIdx ++]; String szPassword = szArgs [iArgIdx ++]; String szGraph = szArgs [iArgIdx ++]; String szVertexFile = szArgs [iArgIdx ++]; String szEdgeFile = szArgs [iArgIdx ++]; Oracle oracle = null; OraclePropertyGraph opg = null; OraclePgqlPreparedStatement opps = null; ResultSet rs = null; try {//创建与Oracle的连接oracle = new Oracle（“jdbc：oracle：thin：@”+ szHost +“：”+ szPort +“：”+ szSID，szUser，szPassword）; //创建属性图opg = OraclePropertyGraph.getInstance（oracle，szGraph）; //清除所有现有数据opg.clearRepository（）; //加载数据OraclePropertyGraphDataLoader opgLoader = OraclePropertyGraphDataLoader.getInstance（）; opgLoader.loadData（opg，szVertexFile，szEdgeFile，1）; //使用绑定变量查询字符串（用？表示）String pgql =“SELECT v.fname AS fname，v.lname AS lname，v.age AS age”+“MATCH（v）”+“WHERE v.age&gt;？“; //创建OraclePgqlPreparedStatement opps = OraclePgqlExecutionFactory.prepareStatement（opg，pgql）; //将过滤器值设置为30 opps.setInt（1,30）; //执行查询rs = opps.executeQuery（”“）; //打印查询结果System.out.println（“ -  v.age&gt; 30的值------------------”）; printResults（rs，3）; //关闭结果集rs.close（）; //将过滤器值设置为40 opps.setInt（1,40）; //执行查询rs = opps.executeQuery（“”）; //打印查询结果System.out.println（“ -  v.age的值&gt; 40 ------------------“）; printResults（rs，3）; //关闭结果集rs.close（）;} finally {//关闭结果集if（rs！= null）{rs.close（）; } //关闭语句if（opps！= null）{opps.close（）; } //关闭属性图if（opg！= null）{opg.shutdown（）; } //关闭oracle if（oracle！= null）{oracle.dispose（）; / ** *打印PGQL ResultSet * / static void printResults（ResultSet rs，int numCols）throws Exception {StringBuffer buff = new StringBuffer（“”）; SimpleDateFormat sdf = new SimpleDateFormat（“yyyy-MM-dd'T'HH：mm：ss。SSSXXX“）; while（rs.next（））{buff.append（”[“）; for（int i = 1; i &lt;= numCols; i ++）{//使用泛型getObject来处理所有类型Object mval = rs .getObject（i）; String mStr =“”; if（mval instanceof java.lang。字符串）{mStr =“STRING：”+ mval.toString（）; } else if（mval instanceof java.lang。整数）{mStr =“INTEGER：”+ mval.toString（）; } else if（mval instanceof java.lang。长）{mStr =“LONG：”+ mval.toString（）; } else if（mval instanceof java.lang。Float）{mStr =“FLOAT：”+ mval.toString（）; } else if（mval instanceof java.lang。Double）{mStr =“DOUBLE：”+ mval.toString（）; } else if（mval instanceof java.sql。时间戳）{mStr =“DATE：”+ sdf.format（（Date）mval）; } else if（mval instanceof java.lang。Boolean）{mStr =“BOOLEAN：”+ mval.toString（）; } if（i&gt; 1）{buff.append（“，\ t”）; } buff.append（mStr）; } buff.append（“] \ n”）; System.out.println（buff.toString（））; }}</code></pre><p><code class="codeph">PgqlExample5.java</code>有以下输出<code class="codeph">test_graph</code> 。
                           </p><pre class="oac_no_warn" dir="ltr">-  v.age&gt; 30的值---------------- [STRING：Susan，STRING：Blue，INTEGER：35] [STRING：Bill，STRING：Brown，INTEGER ：40] [STRING：Ray，STRING：Green，INTEGER：41]  -  v.age的值&gt; 40 ------------------ [STRING：Ray，STRING：绿色，整数：41]</pre></div>
                        <!-- class="example" -->
                        <div class="example" id="GUID-E9657B9D-B648-484F-9572-7DDD7F038871__PGQLEXAMPLE2.JAVA-1EEBD858">
                           <p class="titleinexample">例4-29 PgqlExample6.java</p>
                           <p><code class="codeph">PgqlExample6.java</code>显示带有两个绑定变量的查询：一个String变量和一个Timestamp变量。
                           </p><pre class="pre codeblock"><code>import oracle.pg.rdbms。*;导入oracle.pg.common。*; import oracle.pgql.lang。PgqlException; import oracle.pgql.lang。ResultSet的; import java.util。*; import java.text。*; import java.sql。*; import java.time。*; import java.time.format。*; / ** *此示例显示如何将多个绑定变量与PGQL查询一起使用。* / public class PgqlExample6 {public static void main（String [] szArgs）throws Exception {int iArgIdx = 0; String szHost = szArgs [iArgIdx ++]; String szPort = szArgs [iArgIdx ++]; String szSID = szArgs [iArgIdx ++]; String szUser = szArgs [iArgIdx ++]; String szPassword = szArgs [iArgIdx ++]; String szGraph = szArgs [iArgIdx ++]; String szVertexFile = szArgs [iArgIdx ++]; String szEdgeFile = szArgs [iArgIdx ++]; Oracle oracle = null; OraclePropertyGraph opg = null; OraclePgqlPreparedStatement opps = null; ResultSet rs = null; try {//创建与Oracle的连接oracle = new Oracle（“jdbc：oracle：thin：@”+ szHost +“：”+ szPort +“：”+ szSID，szUser，szPassword）; //创建属性图opg = OraclePropertyGraph.getInstance（oracle，szGraph）; //清除所有现有数据opg.clearRepository（）; //加载数据OraclePropertyGraphDataLoader opgLoader = OraclePropertyGraphDataLoader.getInstance（）; opgLoader.loadData（opg，szVertexFile，szEdgeFile，1）; //具有多个绑定变量的查询字符串字符串pgql =“SELECT v1.fname AS fname1，v2.fname AS fname2”+“MATCH（v1） -  [e：knows]  - &gt;（v2）”+“WHERE e.since &lt; ？和e.firstMetIn =？“; //创建OraclePgqlPreparedStatement opps = OraclePgqlExecutionFactory.prepareStatement（opg，pgql）; //设置e.since &lt;2006-01-01T12：00：00.00Z时间戳t = Timestamp.valueOf（OffsetDateTime.parse（”2006-01“） -01T12：00：01.00Z“）atZoneSameInstant（ZoneOffset。UTC）.toLocalDateTime（））; opps.setTimestamp（1，t）; //设置e.firstMetIn ='CA'opps.setString（2，“CA”）; //执行查询rs = opps.executeQuery（“”）; //打印查询结果System.out.println（“ -  e.since &lt;2006-01-01T12：00：01.00Z和e.firstMetIn ='CA' - ”的值;）; printResults（rs，2）; //关闭结果集rs.close（）; //设置e.since &lt;2000-01-01T12：00：00.00Z t = Timestamp.valueOf（OffsetDateTime.parse（“2000-01-01T12：00：00.00Z”）。atZoneSameInstant（ZoneOffset。UTC）.toLocalDateTime（））; opps.setTimestamp（1，t）; //设置e.firstMetIn ='TX'opps.setString（2，“TX”）; //执行查询rs = opps.executeQuery（“”）; //打印查询结果System.out.println（“ -  e.since &lt;2000-01-01T12：00：00.00Z和e.firstMetIn ='TX' - ”的值;）; printResults（rs，2）; //关闭结果集rs.close（）; } finally {//关闭结果集if（rs！= null）{rs.close（）; } //关闭语句if（opps！= null）{opps.close（）; } //关闭属性图if（opg！= null）{opg.shutdown（）; } //关闭oracle if（oracle！= null）{oracle.dispose（）; / ** *打印PGQL ResultSet * / static void printResults（ResultSet rs，int numCols）throws Exception {StringBuffer buff = new StringBuffer（“”）; SimpleDateFormat sdf = new SimpleDateFormat（“yyyy-MM-dd'T'HH：mm：ss。SSSXXX“）; while（rs.next（））{buff.append（”[“）; for（int i = 1; i &lt;= numCols; i ++）{//使用泛型getObject来处理所有类型Object mval = rs .getObject（i）; String mStr =“”; if（mval instanceof java.lang。字符串）{mStr =“STRING：”+ mval.toString（）; } else if（mval instanceof java.lang。整数）{mStr =“INTEGER：”+ mval.toString（）; } else if（mval instanceof java.lang。长）{mStr =“LONG：”+ mval.toString（）; } else if（mval instanceof java.lang。Float）{mStr =“FLOAT：”+ mval.toString（）; } else if（mval instanceof java.lang。Double）{mStr =“DOUBLE：”+ mval.toString（）; } else if（mval instanceof java.sql。时间戳）{mStr =“DATE：”+ sdf.format（（java.util。日期）MVAL）; } else if（mval instanceof java.lang。Boolean）{mStr =“BOOLEAN：”+ mval.toString（）; } if（i&gt; 1）{buff.append（“，\ t”）; } buff.append（mStr）; } buff.append（“] \ n”）; System.out.println（buff.toString（））; }}</code></pre><p><code class="codeph">PgqlExample6.java</code>给出了下面的输出<code class="codeph">test_graph</code> 。
                           </p><pre class="oac_no_warn" dir="ltr">-  e.since &lt;2006-01-01T12：00：01.00Z和e.firstMetIn ='CA'的值 -  [STRING：Susan，STRING：Bill] [STRING：Susan，STRING：Ray]  - 值e.since &lt;2000-01-01T12：00：00.00Z和e.firstMetIn ='TX' -  [STRING：Ray，STRING：Bill]</pre></div>
                        <!-- class="example" -->
                     </div>
                     <div>
                        <div class="familylinks">
                           <div class="parentlink">
                              <p><strong>父主题：</strong> <a href="sql-based-property-graph-query-analytics.html#GUID-296732FE-D57B-41B5-937B-078E234422CC">使用oracle.pg.rdbms Java包执行PGQL查询</a></p>
                           </div>
                        </div>
                     </div>
                     
                  </div>
                  <div class="props_rev_3"><a id="GUID-6C522195-4D93-4EC3-943A-CBD8D3B22F24" name="GUID-6C522195-4D93-4EC3-943A-CBD8D3B22F24"></a><h5 id="SPGDG-GUID-6C522195-4D93-4EC3-943A-CBD8D3B22F24" class="sect5"><span class="enumeration_section">4.8.2.3</span>使用带有PGQL查询的文本索引</h5>
                     <div>
                        <p>针对Oracle数据库执行的PGQL查询可以使用为顶点和边缘属性创建的Oracle Text索引。创建文本索引后，可以使用CONTAINS运算符执行全文搜索。CONTAINS有两个参数：顶点或边属性，以及Oracle Text搜索字符串。可以使用任何有效的Oracle Text搜索字符串，包括通配符，词干和soundex等高级功能。</p>
                        <div class="example" id="GUID-6C522195-4D93-4EC3-943A-CBD8D3B22F24__PGQLEXAMPLE5.JAVA-1EF822A7">
                           <p class="titleinexample">例4-30 PgqlExample7.java</p>
                           <p><code class="codeph">PgqlExample7.java</code>显示了如何执行CONTAINS查询。
                           </p><pre class="pre codeblock"><code>import oracle.pg.rdbms。*;导入oracle.pg.common。*; import oracle.pgql.lang。PgqlException; import oracle.pgql.lang。ResultSet的; import java.util。*; import java.text。*; import java.sql。*; import java.time。*; import java.time.format。*; / ** *此示例显示如何将Oracle Text索引与PGQL查询一起使用。* / public class PgqlExample7 {public static void main（String [] szArgs）throws Exception {int iArgIdx = 0; String szHost = szArgs [iArgIdx ++]; String szPort = szArgs [iArgIdx ++]; String szSID = szArgs [iArgIdx ++]; String szUser = szArgs [iArgIdx ++]; String szPassword = szArgs [iArgIdx ++]; String szGraph = szArgs [iArgIdx ++]; String szVertexFile = szArgs [iArgIdx ++]; String szEdgeFile = szArgs [iArgIdx ++]; Oracle oracle = null; OraclePropertyGraph opg = null; OraclePgqlPreparedStatement opps = null; ResultSet rs = null; try {//创建与Oracle的连接oracle = new Oracle（“jdbc：oracle：thin：@”+ szHost +“：”+ szPort +“：”+ szSID，szUser，szPassword）; //创建属性图//首先尝试删除属性图尝试{OraclePropertyGraphUtils.dropPropertyGraph（oracle，szGraph）; } catch（SQLException ex）{/ *什么都不做* /; } //获取属性图实例opg = OraclePropertyGraph.getInstance（oracle，szGraph）; //加载数据OraclePropertyGraphDataLoader opgLoader = OraclePropertyGraphDataLoader.getInstance（）; opgLoader.loadData（opg，szVertexFile，szEdgeFile，1）; //使用SQL API创建文本索引CallableStatement cs = null; //顶点上的文本索引cs = oracle.getConnection（）。prepareCall（“begin opg_apis.create_vertices_text_idx（：1，：2）; end;”）; cs.setString（1，szUser）; cs.setString（2，szGraph）; cs.execute（）; cs.close（）; //边上的文本索引cs = oracle.getConnection（）。prepareCall（“begin opg_apis.create_edges_text_idx（：1，：2）; end;”）; cs.setString（1，szUser）; cs.setString（2，szGraph）; cs.execute（）; cs.close（）; //在顶点属性上使用CONTAINS文本搜索运算符进行查询//查找具有以'B'开头的lname属性值的所有顶点字符串pgql =“SELECT v.fname AS fname，v.lname AS lname”+“MATCH（v） “+”WHERE CONTAINS（v.lname，'B％'）“; //创建OraclePgqlStatement opps = OraclePgqlExecutionFactory.prepareStatement（opg，pgql）; //执行查询rs = opps.executeQuery（“”）; //打印结果System.out.println（“ -  Vertex Property Query ---------------”）; printResults（rs，2）; //关闭结果集和准备好的语句rs.close（）; opps.close（）; //使用边缘属性上的CONTAINS文本搜索运算符进行查询//使用以'A'结尾的firstMetIn属性值查找所有已知边缘pgql =“SELECT v1.fname AS fname1，v2.fname AS fname2，e.firstMetIn AS loc” +“MATCH（v1） -  [e：know]  - &gt;（v2）”+“WHERE CONTAINS（e.firstMetIn，'％A'）”; //创建OraclePgqlStatement opps = OraclePgqlExecutionFactory.prepareStatement（opg，pgql）; //执行查询rs = opps.executeQuery（“”）; //打印结果System.out.println（“ -  Edge Property Query -----------------”）; printResults（rs，3）; //关闭结果集和语句rs.close（）; opps.close（）; } finally {//关闭结果集if（rs！= null）{rs.close（）; } //关闭语句if（opps！= null）{opps.close（）; } //关闭属性图if（opg！= null）{opg.shutdown（）; } //关闭oracle if（oracle！= null）{oracle.dispose（）; / ** *打印PGQL ResultSet * / static void printResults（ResultSet rs，int numCols）throws Exception {StringBuffer buff = new StringBuffer（“”）; SimpleDateFormat sdf = new SimpleDateFormat（“yyyy-MM-dd'T'HH：mm：ss。SSSXXX“）; while（rs.next（））{buff.append（”[“）; for（int i = 1; i &lt;= numCols; i ++）{//使用泛型getObject来处理所有类型Object mval = rs .getObject（i）; String mStr =“”; if（mval instanceof java.lang。字符串）{mStr =“STRING：”+ mval.toString（）; } else if（mval instanceof java.lang。整数）{mStr =“INTEGER：”+ mval.toString（）; } else if（mval instanceof java.lang。长）{mStr =“LONG：”+ mval.toString（）; } else if（mval instanceof java.lang。Float）{mStr =“FLOAT：”+ mval.toString（）; } else if（mval instanceof java.lang。Double）{mStr =“DOUBLE：”+ mval.toString（）; } else if（mval instanceof java.sql。时间戳）{mStr =“DATE：”+ sdf.format（（java.util。日期）MVAL）; } else if（mval instanceof java.lang。Boolean）{mStr =“BOOLEAN：”+ mval.toString（）; } if（i&gt; 1）{buff.append（“，\ t”）; } buff.append（mStr）; } buff.append（“] \ n”）; System.out.println（buff.toString（））; }}</code></pre><p><code class="codeph">PgqlExample7.java</code>有以下输出<code class="codeph">test_graph</code> 。
                           </p><pre class="oac_no_warn" dir="ltr">- 顶点属性查询--------------- [STRING：Susan，STRING：Blue] [STRING：Bill，STRING：Brown] [STRING：John，STRING：Black]  -  Edge财产查询----------------- [STRING：Susan，STRING：Bill，STRING：CA] [STRING：John，STRING：Bill，STRING：GA] [STRING：Susan， STRING：John，STRING：CA] [STRING：Susan，STRING：Ray，STRING：CA]</pre></div>
                        <!-- class="example" -->
                     </div>
                     <div>
                        <div class="familylinks">
                           <div class="parentlink">
                              <p><strong>父主题：</strong> <a href="sql-based-property-graph-query-analytics.html#GUID-296732FE-D57B-41B5-937B-078E234422CC">使用oracle.pg.rdbms Java包执行PGQL查询</a></p>
                           </div>
                        </div>
                     </div>
                     
                  </div>
                  <div class="props_rev_3"><a id="GUID-7642327B-B973-4C48-90B1-1447F3D57CA5" name="GUID-7642327B-B973-4C48-90B1-1447F3D57CA5"></a><h5 id="SPGDG-GUID-7642327B-B973-4C48-90B1-1447F3D57CA5" class="sect5"><span class="enumeration_section">4.8.2.4</span>获取PGQL查询的SQL转换</h5>
                     <div>
                        <p>您可以通过<code class="codeph">OraclePgqlStatement</code>和<code class="codeph">OraclePgqlPreparedStatement</code>方法获取PGQL查询的SQL转换。PGQL查询的原始SQL可能有用，原因如下：</p>
                        <ul style="list-style-type:disc">
                           <li>
                              <p>您可以使用其他基于SQL的工具或接口（例如，SQL Plus或SQL Developer）直接对数据库执行SQL。</p>
                           </li>
                           <li>
                              <p>您可以自定义和调整生成的SQL以优化性能或满足应用程序的特定要求。</p>
                           </li>
                           <li>
                              <p>您可以构建一个更大的SQL查询，将PGQL子查询与存储在Oracle数据库中的其他数据（例如关系表，空间数据和JSON数据）连接起来。</p>
                           </li>
                        </ul>
                        <div class="example" id="GUID-7642327B-B973-4C48-90B1-1447F3D57CA5__PGQLEXAMPLE7.JAVA-1EF8E84B">
                           <p class="titleinexample">例4-31 PgqlExample8.java</p>
                           <p><code class="codeph">PgqlExample8.java</code>显示了如何获取PGQL查询的原始SQL转换。<code class="codeph">OraclePgqlStatement</code>的<code class="codeph">translateQuery</code>方法返回一个<code class="codeph">OraclePgqlSqlTrans</code>对象，该对象包含有关查询返回列和SQL转换本身的信息。
                           </p>
                           <p>转换的SQL返回不同的列，具体取决于从PGQL查询投射的“逻辑”对象或值的类型。PGQL中投影的顶点或边在投影的SQL中有两个相应的列：</p>
                           <ul style="list-style-type:disc">
                              <li>
                                 <p>$ IT：id类型 -  NVARCHAR（1）：顶点为'V'，边为'E'</p>
                              </li>
                              <li>
                                 <p>$ ID：顶点或边缘标识符 -  NUMBER：与VT $和GE $表中的VID或EID列相同的内容</p>
                              </li>
                           </ul>
                           <p>PGQL中投射的属性值或常量标量值在已翻译的SQL中有四个相应的列：</p>
                           <ul style="list-style-type:disc">
                              <li>
                                 <p>$ T：值类型 -  NUMBER：与VT $和GE $表中的T列相同的内容</p>
                              </li>
                              <li>
                                 <p>$ V：value  -  NVARCHAR2（15000）：与VT $和GE $表中的V列相同的内容</p>
                              </li>
                              <li>
                                 <p>$ VN：数字值 -  NUMBER：与VT $和GE $表中的VN列相同的内容</p>
                              </li>
                              <li>
                                 <p>$ VT：时间值 -  TIMESTAMP WITH TIME ZONE：与VT $和GE $表中的VT列相同的内容</p>
                              </li>
                           </ul><pre class="pre codeblock"><code>import oracle.pg.rdbms。*;导入oracle.pg.common。*; import java.util。*; import java.text。*; import java.sql。*; import java.time。*; import java.time.format。*; / ** *此示例显示如何获取PGQL查询的SQL转换。* / public class PgqlExample8 {public static void main（String [] szArgs）throws Exception {int iArgIdx = 0; String szHost = szArgs [iArgIdx ++]; String szPort = szArgs [iArgIdx ++]; String szSID = szArgs [iArgIdx ++]; String szUser = szArgs [iArgIdx ++]; String szPassword = szArgs [iArgIdx ++]; String szGraph = szArgs [iArgIdx ++]; String szVertexFile = szArgs [iArgIdx ++]; String szEdgeFile = szArgs [iArgIdx ++]; Oracle oracle = null; OraclePropertyGraph opg = null; OraclePgqlStatement ops = null; try {//创建与Oracle的连接oracle = new Oracle（“jdbc：oracle：thin：@”+ szHost +“：”+ szPort +“：”+ szSID，szUser，szPassword）; //创建属性图opg = OraclePropertyGraph.getInstance（oracle，szGraph）; //清除所有现有数据opg.clearRepository（）; //加载数据OraclePropertyGraphDataLoader opgLoader = OraclePropertyGraphDataLoader.getInstance（）; opgLoader.loadData（opg，szVertexFile，szEdgeFile，1）; //要翻译的PGQL查询字符串pgql =“SELECT v1，v1.fname AS fname1，e，e.since AS as”+“MATCH（v1） -  [e：knows]  - &gt;（v2）”; //创建OraclePgqlStatement ops = OraclePgqlExecutionFactory.createStatement（opg）; //获取SQL翻译OraclePgqlSqlTrans sqlTrans = ops.translateQuery（pgql，“”）; //获取返回列描述OraclePgqlColumnDescriptor [] cols = sqlTrans.getReturnTypes（）; //打印列描述System.out.println（“ -  Return Columns -----------------------”）; printReturnCols（COLS）; //打印SQL翻译System.out.println（“ -  SQL Translation ----------------------”）;的System.out.println（sqlTrans.getSqlTranslation（））; } finally {//关闭语句if（ops！= null）{ops.close（）; } //关闭属性图if（opg！= null）{opg.shutdown（）; } //关闭oracle if（oracle！= null）{oracle.dispose（）; / ** *打印SQL转换的返回列* / static void printReturnCols（OraclePgqlColumnDescriptor [] cols）throws Exception {StringBuffer buff = new StringBuffer（“”）; for（int i = 0; i &lt;cols.length; i ++）{String colName = cols [i] .getColName（）; OraclePgqlColumnDescriptor。输入colType = cols [i] .getColType（）; int offset = cols [i] .getSqlOffset（）; String readableType =“”; switch（colType）{case VERTEX：readableType =“VERTEX”;打破; case EDGE：readableType =“EDGE”;打破; case VALUE：readableType =“VALUE”;打破; } buff.append（“colName = [”+ colName +“] colType = [”+ readableType +“] offset = [”+ offset +“] \ n”）; System.out.println（buff.toString（））; }}</code></pre><p><code class="codeph">PgqlExample8.java</code>有以下输出<code class="codeph">test_graph</code> 。
                           </p><pre class="oac_no_warn" dir="ltr">- 返回列----------------------- colName = [v1] colType = [VERTEX] offset = [1] colName = [fname1] colType = [ VALUE] offset = [3] colName = [e] colType = [EDGE] offset = [7] colName = [since] colType = [VALUE] offset = [9]  -  SQL翻译--------- ------------- SELECT n'V'AS“v1 $ IT”，T0 $ 0。SVID为“v1 $ ID”，T0 $ 1。T AS“fname1 $ T”，T0 $ 1。V AS“fname1 $ V”，T0 $ 1。VN AS“fname1 $ VN”，T0 $ 1。VT AS“fname1 $ VT”，n'E'AS“e $ IT”，T0 $ 0。EID为“e $ ID”，T0 $ 0。T AS“自$ T”，T0 $ 0。V AS“自$ V”，T0 $ 0。VN AS“自$ VN起”，T0 $ 0。VT AS“自$ VT”起“SCOTT”。GRAPH1GE $ T0 $ 0，“SCOTT”。GRAPH1VT $ T0 $ 1 WHERE T0 $ 0。K = n'since'和T0 $ 1。K = n'fname'和T0 $ 0。SVID = T0 $ 1VID AND（T0 $ 0。EL = n'knows'AND T0 $ 0。EL不是空的）</pre></div>
                        <!-- class="example" -->
                        <div class="example" id="GUID-7642327B-B973-4C48-90B1-1447F3D57CA5__GUID-FB87DBB1-292F-4B0E-807E-BC6209FE4631">
                           <p class="titleinexample">例4-32 PgqlExample9.java</p>
                           <p>您还可以使用绑定变量获取PGQL查询的SQL转换。在这种情况下，相应的SQL转换也将包含绑定变量。<code class="codeph">OraclePgqlSqlTrans</code>接口有一个<code class="codeph">getSqlBvList</code>方法，该方法返回应绑定到SQL查询的有序Java对象列表（列表中的第一个对象应设置在位置1，第二个应设置在位置2，依此类推）。
                           </p>
                           <p><code class="codeph">PgqlExample9.java</code>显示了如何使用绑定变量获取和执行PGQL查询的SQL。
                           </p><pre class="pre codeblock"><code>import oracle.pg.rdbms。*;导入oracle.pg.common。*; import java.util。*; import java.text。*; import java.sql。*; import java.time。*; import java.time.format。*; / ** *此示例显示如何获取和执行使用绑定变量的* PGQL查询的SQL转换。* / public class PgqlExample9 {public static void main（String [] szArgs）throws Exception {int iArgIdx = 0; String szHost = szArgs [iArgIdx ++]; String szPort = szArgs [iArgIdx ++]; String szSID = szArgs [iArgIdx ++]; String szUser = szArgs [iArgIdx ++]; String szPassword = szArgs [iArgIdx ++]; String szGraph = szArgs [iArgIdx ++]; String szVertexFile = szArgs [iArgIdx ++]; String szEdgeFile = szArgs [iArgIdx ++]; Oracle oracle = null; OraclePropertyGraph opg = null; OraclePgqlPreparedStatement opps = null; PreparedStatement ps = null; try {//创建与Oracle的连接oracle = new Oracle（“jdbc：oracle：thin：@”+ szHost +“：”+ szPort +“：”+ szSID，szUser，szPassword）; //创建属性图opg = OraclePropertyGraph.getInstance（oracle，szGraph）; //清除所有现有数据opg.clearRepository（）; //加载数据OraclePropertyGraphDataLoader opgLoader = OraclePropertyGraphDataLoader.getInstance（）; opgLoader.loadData（opg，szVertexFile，szEdgeFile，1）; //执行查询以获取ResultSet对象String pgql =“SELECT v1，v1.fname AS fname1，v1.age AS age，？as constVal“+”MATCH（v1）“+”WHERE v1.fname =？或者v1.age &lt;？“; //创建OraclePgqlStatement opps = OraclePgqlExecutionFactory.prepareStatement（opg，pgql）; //设置绑定值opps.setDouble（1，2.05d）; opps.setString（2，”Bill“）; opps.setInt（3， 35）; //获取SQL转换OraclePgqlSqlTrans sqlTrans = opps.translateQuery（“”）; //获取SQL字符串字符串sqlStr = sqlTrans.getSqlTranslation（）; //获取返回列描述OraclePgqlColumnDescriptor [] cols = sqlTrans.getReturnTypes （）; //获取绑定值List &lt;Object&gt; bindVals = sqlTrans.getSqlBvList（）; //打印列描述System.out.println（“ - 返回列------------- ----------“）; printReturnCols（cols）; //打印SQL翻译System.out.println（” -  SQL翻译---------------- ------“）; System.out.println（sqlStr）; //打印绑定值System.out.println（”\ n--绑定值-------------- ------------“）; for（Object obj：bindVals）{System.out.println（obj.toString（））;} //执行查询//获取PreparedStatement ps = oracle.getConnection （）.prepareStatement（“选择COUNT（*）FROM（“+ sqlStr +”）“）; //设置绑定值并执行PreparedStatement executePs（ps，bindVals）; //在PGQL PreparedStatement中设置新的绑定值opps.setDouble（1,3.02d）; opps.setString（2，“Ray”）; opps.setInt（3,30）; //打印绑定值bindVals = sqlTrans.getSqlBvList（）; System.out.println（“\ n-- Bind Values --------------------------”）; for（Object obj：bindVals）{System.out.println（obj.toString（））;使用新的绑定值executePs（ps，bindVals）执行PreparedStatement; } finally {//关闭SQL语句if（ps！= null）{ps.close（）; } //关闭语句if（opps！= null）{opps.close（）; } //关闭属性图if（opg！= null）{opg.shutdown（）; } //关闭oracle if（oracle！= null）{oracle.dispose（）; / * *使用输入绑定值执行SQL PreparedStatement * / static void executeP（PreparedStatement ps，List &lt;Object&gt; bindVals）抛出异常{ResultSet rs = null; try {//为（int idx = 0; idx &lt;bindVals.size（）; idx ++）设置绑定值{Object o = bindVals.get（idx）; // String if（o instanceof java.lang。字符串）{ps.setNString（idx + 1，（String）o）; } //其他if（o instanceof java.lang。整数）{ps.setInt（idx + 1，（（Integer）o）.intValue（））; } // if else if（o instanceof java.lang。长）{ps.setLong（idx + 1，（（Long）o）。longValue（））; } //浮动其他if（o instanceof java.lang。Float）{ps.setFloat（idx + 1，（（Float）o）.floatValue（））; } // if else else if（o instanceof java.lang。Double）{ps.setDouble（idx + 1，（（Double）o）.doubleValue（））; } //其他时间戳if（o instanceof java.sql。时间戳）{ps.setTimestamp（idx + 1，（Timestamp）o）; } else {ps.setString（idx + 1，bindVals.get（idx）.toString（））; //执行查询rs = ps.executeQuery（）; if（rs.next（））{System.out.println（“\ n--执行查询：结果有”+ rs.getInt（1）+“rows  - ”）;终于{//关闭SQL ResultSet if（rs！）= null）{rs.close（）; / ** *打印SQL转换的返回列* / static void printReturnCols（OraclePgqlColumnDescriptor [] cols）throws Exception {StringBuffer buff = new StringBuffer（“”）; for（int i = 0; i &lt;cols.length; i ++）{String colName = cols [i] .getColName（）; OraclePgqlColumnDescriptor。输入colType = cols [i] .getColType（）; int offset = cols [i] .getSqlOffset（）; String readableType =“”; switch（colType）{case VERTEX：readableType =“VERTEX”;打破; case EDGE：readableType =“EDGE”;打破; case VALUE：readableType =“VALUE”;打破; } buff.append（“colName = [”+ colName +“] colType = [”+ readableType +“] offset = [”+ offset +“] \ n”）; System.out.println（buff.toString（））; }}</code></pre><p><code class="codeph">PgqlExample9.java</code>有以下输出<code class="codeph">test_graph</code> 。
                           </p><pre class="oac_no_warn" dir="ltr">-   - 返回列----------------------- colName = [v1] colType = [VERTEX] offset = [1] colName = [fname1] colType = [VALUE] offset = [3] colName = [age] colType = [VALUE] offset = [7] colName = [constVal] colType = [VALUE] offset = [11]  -  SQL翻译-------- -------------- SELECT n'V'AS“v1 $ IT”，T0 $ 0。VID为“v1 $ ID”，T0 $ 0。T AS“fname1 $ T”，T0 $ 0。V AS“fname1 $ V”，T0 $ 0。VN AS“fname1 $ VN”，T0 $ 0。VT AS“fname1 $ VT”，T0 $ 1。T AS“年龄$ T”，T0 $ 1。V AS“年龄$ V”，T0 $ 1。VN AS“年龄$ VN”，T0 $ 1。VT AS“age $ VT”，4 AS“constVal $ T”，to_nchar（？，'TM9'，'NLS_Numeric_Characters =''。，'''）AS“constVal $ V”,?AS“constVal $ VN”，to_timestamp_tz（null）AS“constVal $ VT”FROM“SCOTT”。GRAPH1VT $ T0 $ 0，“SCOTT”。GRAPH1VT $ T0 $ 1 WHERE T0 $ 0。K = n'fname'和T0 $ 1。K = n'age'和T0 $ 0。VID = T0 $ 1VID AND（（T0 $ 0。T = 1和T0 $ 0。V =？）或者T0 $ 1。VN &lt;？）- 绑定值-------------------------- 2.05 2.05 Bill 35  - 执行查询：结果有2行 -   - 绑定值 - ------------------------- 3.02 3.02 Ray 30  - 执行查询：结果有1行 -</pre></div>
                        <!-- class="example" -->
                     </div>
                     <div>
                        <div class="familylinks">
                           <div class="parentlink">
                              <p><strong>父主题：</strong> <a href="sql-based-property-graph-query-analytics.html#GUID-296732FE-D57B-41B5-937B-078E234422CC">使用oracle.pg.rdbms Java包执行PGQL查询</a></p>
                           </div>
                        </div>
                     </div>
                     
                  </div>
                  <div class="props_rev_3"><a id="GUID-E9CC82C3-BD5A-4581-AE26-2432D6929D44" name="GUID-E9CC82C3-BD5A-4581-AE26-2432D6929D44"></a><h5 id="SPGDG-GUID-E9CC82C3-BD5A-4581-AE26-2432D6929D44" class="sect5"><span class="enumeration_section">4.8.2.5</span> PGQL转换和执行的附加选项</h5>
                     <div>
                        <p>有几个选项可用于影响PGQL查询转换和执行。以下是设置查询选项的主要方法：</p>
                        <ul style="list-style-type:disc">
                           <li>
                              <p>通过<code class="codeph">executeQuery</code>和<code class="codeph">translateQuery</code>显式参数</p>
                           </li>
                           <li>
                              <p>通过<code class="codeph">executeQuery</code>和<code class="codeph">translateQuery</code>的<code class="codeph">options</code>字符串参数中的标志</p>
                           </li>
                           <li>
                              <p>通过Java JVM参数。</p>
                           </li>
                        </ul>
                        <p>下表总结了PGQL转换和执行的可用查询参数。</p>
                        <div class="tblformal" id="GUID-E9CC82C3-BD5A-4581-AE26-2432D6929D44__GUID-ACDAC2C0-469A-470F-945B-78A010DE939F">
                           <p class="titleintable">表4-2 PGQL转换和执行选项</p>
                           <table cellpadding="4" cellspacing="0" class="Formal" title="PGQL翻译和执行选项" border="1" summary="Five-column table: column 1 is Option, column 2 is Default, column 3 is Explicit Argument, column 4 is Options Flag, and column 5 is JVM argument." frame="hsides" rules="rows">
                              <thead>
                                 <tr align="left" valign="top">
                                    <th align="left" valign="bottom" width="20%" id="d22162e3317">选项</th>
                                    <th align="left" valign="bottom" width="20%" id="d22162e3320">默认</th>
                                    <th align="left" valign="bottom" width="20%" id="d22162e3323">显示争论</th>
                                    <th align="left" valign="bottom" width="20%" id="d22162e3326">选项标志</th>
                                    <th align="left" valign="bottom" width="20%" id="d22162e3329">JVM参数</th>
                                 </tr>
                              </thead>
                              <tbody>
                                 <tr align="left" valign="top">
                                    <td rowspan="1" colspan="1" align="left" valign="top" id="d22162e3334" headers="d22162e3317 ">
                                       <p>并行度</p>
                                    </td>
                                    <td rowspan="1" colspan="1" align="left" valign="top" headers="d22162e3334 d22162e3320 ">
                                       <p>1</p>
                                    </td>
                                    <td rowspan="1" colspan="1" align="left" valign="top" headers="d22162e3334 d22162e3323 ">
                                       <p>平行</p>
                                    </td>
                                    <td rowspan="1" colspan="1" align="left" valign="top" headers="d22162e3334 d22162e3326 ">
                                       <p>没有</p>
                                    </td>
                                    <td rowspan="1" colspan="1" align="left" valign="top" headers="d22162e3334 d22162e3329 ">
                                       <p>没有</p>
                                    </td>
                                 </tr>
                                 <tr align="left" valign="top">
                                    <td rowspan="1" colspan="1" align="left" valign="top" id="d22162e3350" headers="d22162e3317 ">
                                       <p>超时</p>
                                    </td>
                                    <td rowspan="1" colspan="1" align="left" valign="top" headers="d22162e3350 d22162e3320 ">
                                       <p>无限</p>
                                    </td>
                                    <td rowspan="1" colspan="1" align="left" valign="top" headers="d22162e3350 d22162e3323 ">
                                       <p>超时</p>
                                    </td>
                                    <td rowspan="1" colspan="1" align="left" valign="top" headers="d22162e3350 d22162e3326 ">
                                       <p>没有</p>
                                    </td>
                                    <td rowspan="1" colspan="1" align="left" valign="top" headers="d22162e3350 d22162e3329 ">
                                       <p>没有</p>
                                    </td>
                                 </tr>
                                 <tr align="left" valign="top">
                                    <td rowspan="1" colspan="1" align="left" valign="top" id="d22162e3366" headers="d22162e3317 ">
                                       <p>动态采样</p>
                                    </td>
                                    <td rowspan="1" colspan="1" align="left" valign="top" headers="d22162e3366 d22162e3320 ">
                                       <p>2</p>
                                    </td>
                                    <td rowspan="1" colspan="1" align="left" valign="top" headers="d22162e3366 d22162e3323 ">
                                       <p>dynamicSampling</p>
                                    </td>
                                    <td rowspan="1" colspan="1" align="left" valign="top" headers="d22162e3366 d22162e3326 ">
                                       <p>没有</p>
                                    </td>
                                    <td rowspan="1" colspan="1" align="left" valign="top" headers="d22162e3366 d22162e3329 ">
                                       <p>没有</p>
                                    </td>
                                 </tr>
                                 <tr align="left" valign="top">
                                    <td rowspan="1" colspan="1" align="left" valign="top" id="d22162e3382" headers="d22162e3317 ">
                                       <p>最大结果数</p>
                                    </td>
                                    <td rowspan="1" colspan="1" align="left" valign="top" headers="d22162e3382 d22162e3320 ">
                                       <p>无限</p>
                                    </td>
                                    <td rowspan="1" colspan="1" align="left" valign="top" headers="d22162e3382 d22162e3323 ">
                                       <p>的maxResults</p>
                                    </td>
                                    <td rowspan="1" colspan="1" align="left" valign="top" headers="d22162e3382 d22162e3326 ">
                                       <p>没有</p>
                                    </td>
                                    <td rowspan="1" colspan="1" align="left" valign="top" headers="d22162e3382 d22162e3329 ">
                                       <p>没有</p>
                                    </td>
                                 </tr>
                                 <tr align="left" valign="top">
                                    <td rowspan="1" colspan="1" align="left" valign="top" id="d22162e3398" headers="d22162e3317 ">
                                       <p>GT $表用法</p>
                                    </td>
                                    <td rowspan="1" colspan="1" align="left" valign="top" headers="d22162e3398 d22162e3320 ">
                                       <p>离</p>
                                    </td>
                                    <td rowspan="1" colspan="1" align="left" valign="top" headers="d22162e3398 d22162e3323 ">
                                       <p>没有</p>
                                    </td>
                                    <td rowspan="1" colspan="1" align="left" valign="top" headers="d22162e3398 d22162e3326 ">
                                       <p>USE_GT_TAB = T</p>
                                    </td>
                                    <td rowspan="1" colspan="1" align="left" valign="top" headers="d22162e3398 d22162e3329 ">
                                       <p>-Doracle.pg.rdbms.pgql.useGtTab =真</p>
                                    </td>
                                 </tr>
                                 <tr align="left" valign="top">
                                    <td rowspan="1" colspan="1" align="left" valign="top" id="d22162e3414" headers="d22162e3317 ">
                                       <p>CONNECT BY用法</p>
                                    </td>
                                    <td rowspan="1" colspan="1" align="left" valign="top" headers="d22162e3414 d22162e3320 ">
                                       <p>离</p>
                                    </td>
                                    <td rowspan="1" colspan="1" align="left" valign="top" headers="d22162e3414 d22162e3323 ">
                                       <p>没有</p>
                                    </td>
                                    <td rowspan="1" colspan="1" align="left" valign="top" headers="d22162e3414 d22162e3326 ">
                                       <p>USE_RW = F</p>
                                    </td>
                                    <td rowspan="1" colspan="1" align="left" valign="top" headers="d22162e3414 d22162e3329 ">
                                       <p>-Doracle.pg.rdbms.pgql.useRW = FALSE</p>
                                    </td>
                                 </tr>
                                 <tr align="left" valign="top">
                                    <td rowspan="1" colspan="1" align="left" valign="top" id="d22162e3430" headers="d22162e3317 ">
                                       <p>不同的递归使用</p>
                                    </td>
                                    <td rowspan="1" colspan="1" align="left" valign="top" headers="d22162e3430 d22162e3320 ">
                                       <p>离</p>
                                    </td>
                                    <td rowspan="1" colspan="1" align="left" valign="top" headers="d22162e3430 d22162e3323 ">
                                       <p>没有</p>
                                    </td>
                                    <td rowspan="1" colspan="1" align="left" valign="top" headers="d22162e3430 d22162e3326 ">
                                       <p>USE_DIST_RW = T</p>
                                    </td>
                                    <td rowspan="1" colspan="1" align="left" valign="top" headers="d22162e3430 d22162e3329 ">
                                       <p>-Doracle.pg.rdbms.pgql.useDistRW =真</p>
                                    </td>
                                 </tr>
                                 <tr align="left" valign="top">
                                    <td rowspan="1" colspan="1" align="left" valign="top" id="d22162e3446" headers="d22162e3317 ">
                                       <p>最大路径长度</p>
                                    </td>
                                    <td rowspan="1" colspan="1" align="left" valign="top" headers="d22162e3446 d22162e3320 ">
                                       <p>无限</p>
                                    </td>
                                    <td rowspan="1" colspan="1" align="left" valign="top" headers="d22162e3446 d22162e3323 ">
                                       <p>没有</p>
                                    </td>
                                    <td rowspan="1" colspan="1" align="left" valign="top" headers="d22162e3446 d22162e3326 ">
                                       <p>MAX_PATH_LEN =正</p>
                                    </td>
                                    <td rowspan="1" colspan="1" align="left" valign="top" headers="d22162e3446 d22162e3329 ">
                                       <p>-Doracle.pg.rdbms.pgql.maxPathLen =正</p>
                                    </td>
                                 </tr>
                                 <tr align="left" valign="top">
                                    <td rowspan="1" colspan="1" align="left" valign="top" id="d22162e3462" headers="d22162e3317 ">
                                       <p>设置部分</p>
                                    </td>
                                    <td rowspan="1" colspan="1" align="left" valign="top" headers="d22162e3462 d22162e3320 ">
                                       <p>假</p>
                                    </td>
                                    <td rowspan="1" colspan="1" align="left" valign="top" headers="d22162e3462 d22162e3323 ">
                                       <p>没有</p>
                                    </td>
                                    <td rowspan="1" colspan="1" align="left" valign="top" headers="d22162e3462 d22162e3326 ">
                                       <p>EDGE_SET_PARTIAL = T</p>
                                    </td>
                                    <td rowspan="1" colspan="1" align="left" valign="top" headers="d22162e3462 d22162e3329 ">
                                       <p>-Doracle.pg.rdbms.pgql.edgeSetPartial =真</p>
                                    </td>
                                 </tr>
                              </tbody>
                           </table>
                        </div>
                        <!-- class="inftblhruleinformal" -->
                     </div>
                     <div>
                        <ul class="ullinks">
                           <li class="ulchildlink"><a href="sql-based-property-graph-query-analytics.html#GUID-099CB0E0-DFE4-4CEF-AA37-08D96FADA3DF">由显式参数控制的查询选项</a><br></li>
                           <li class="ulchildlink"><a href="sql-based-property-graph-query-analytics.html#GUID-AC37DA9D-7178-4BDA-B21F-FC18EB27A290">使用GT $ Skeleton表</a><br></li>
                           <li class="ulchildlink"><a href="sql-based-property-graph-query-analytics.html#GUID-3369EA15-739E-4B44-9178-AFC79A33031C">路径查询选项</a><br></li>
                           <li class="ulchildlink"><a href="sql-based-property-graph-query-analytics.html#GUID-4B12B361-A502-4B39-9267-E457C2F14D74">部分对象构造的选项</a><br></li>
                        </ul>
                        <div class="familylinks">
                           <div class="parentlink">
                              <p><strong>父主题：</strong> <a href="sql-based-property-graph-query-analytics.html#GUID-296732FE-D57B-41B5-937B-078E234422CC">使用oracle.pg.rdbms Java包执行PGQL查询</a></p>
                           </div>
                        </div>
                     </div>
                     
                     <div class="props_rev_3"><a id="GUID-099CB0E0-DFE4-4CEF-AA37-08D96FADA3DF" name="GUID-099CB0E0-DFE4-4CEF-AA37-08D96FADA3DF"></a><h6 id="SPGDG-GUID-099CB0E0-DFE4-4CEF-AA37-08D96FADA3DF" class="sect6"><span class="enumeration_section">4.8.2.5.1</span>由显式参数控制的查询选项</h6>
                        <div>
                           <p>某些查询选项由Java API中的方法的显式参数控制。</p>
                           <ul style="list-style-type:disc">
                              <li>
                                 <p><code class="codeph">OraclePgqlStatement</code>的<code class="codeph">executeQuery</code>方法具有以秒为单位的超时，并行度，查询标识符（保留供将来使用），优化器动态采样和最大结果数的显式参数。
                                 </p>
                              </li>
                              <li>
                                 <p><code class="codeph">translateQuery</code>方法具有并行度，优化器动态采样和最大结果数的显式参数。<code class="codeph">OraclePgqlPreparedStatement</code>还为<code class="codeph">executeQuery</code>和<code class="codeph">translateQuery</code>提供了相同的附加参数。
                                 </p>
                              </li>
                           </ul>
                           <div class="example" id="GUID-099CB0E0-DFE4-4CEF-AA37-08D96FADA3DF__GUID-DFAD9D28-0130-430E-ACE4-6B5481407EC5">
                              <p class="titleinexample">例4-33 PgqlExample10.java</p>
                              <p><code class="codeph">PgqlExample10.java</code>显示PGQL查询执行，其他选项由显式参数控制。
                              </p><pre class="pre codeblock"><code>import oracle.pg.rdbms。*;导入oracle.pg.common。*; import oracle.pgql.lang。PgqlException; import oracle.pgql.lang。ResultSet的; import java.util。*; import java.text。*; / ** *此示例显示如何使用各种选项执行PGQL查询。* / public class PgqlExample10 {public static void main（String [] szArgs）throws Exception {int iArgIdx = 0; String szHost = szArgs [iArgIdx ++]; String szPort = szArgs [iArgIdx ++]; String szSID = szArgs [iArgIdx ++]; String szUser = szArgs [iArgIdx ++]; String szPassword = szArgs [iArgIdx ++]; String szGraph = szArgs [iArgIdx ++]; String szVertexFile = szArgs [iArgIdx ++]; String szEdgeFile = szArgs [iArgIdx ++]; Oracle oracle = null; OraclePropertyGraph opg = null; OraclePgqlStatement ops = null; ResultSet rs = null; try {//创建与Oracle的连接oracle = new Oracle（“jdbc：oracle：thin：@”+ szHost +“：”+ szPort +“：”+ szSID，szUser，szPassword）; //创建属性图opg = OraclePropertyGraph.getInstance（oracle，szGraph）; //清除所有现有数据opg.clearRepository（）; //加载数据OraclePropertyGraphDataLoader opgLoader = OraclePropertyGraphDataLoader.getInstance（）; opgLoader.loadData（opg，szVertexFile，szEdgeFile，1）; //创建OraclePgqlStatement ops = OraclePgqlExecutionFactory.createStatement（opg）; //执行查询以获取ResultSet对象字符串pgql =“SELECT v1.fname AS fname1，v2.fname AS fname2”+“MATCH（v1） -  [：friendOf]  - &gt;（v2）”; rs = ops.executeQuery（pgql / *查询字符串* /，100 / *超时（秒）：0表示默认值，表示没有超时* /，2 / * parallel：1是默认值* /，1001 / *查询ID：0是默认* /，6 / *动态采样：2是默认值* /，50 / *最大结果：-1是默认值，表示无限制* /，“”/ *选项* /）; //打印查询结果printResults（rs，2）; } finally {//关闭结果集if（rs！= null）{rs.close（）; } //关闭语句if（ops！= null）{ops.close（）; } //关闭属性图if（opg！= null）{opg.shutdown（）; } //关闭oracle if（oracle！= null）{oracle.dispose（）; / ** *打印PGQL ResultSet * / static void printResults（ResultSet rs，int numCols）throws Exception {StringBuffer buff = new StringBuffer（“”）; SimpleDateFormat sdf = new SimpleDateFormat（“yyyy-MM-dd'T'HH：mm：ss。SSSXXX“）; while（rs.next（））{buff.append（”[“）; for（int i = 1; i &lt;= numCols; i ++）{//使用泛型getObject来处理所有类型Object mval = rs .getObject（i）; String mStr =“”; if（mval instanceof java.lang。字符串）{mStr =“STRING：”+ mval.toString（）; } else if（mval instanceof java.lang。整数）{mStr =“INTEGER：”+ mval.toString（）; } else if（mval instanceof java.lang。长）{mStr =“LONG：”+ mval.toString（）; } else if（mval instanceof java.lang。Float）{mStr =“FLOAT：”+ mval.toString（）; } else if（mval instanceof java.lang。Double）{mStr =“DOUBLE：”+ mval.toString（）; } else if（mval instanceof java.sql。时间戳）{mStr =“DATE：”+ sdf.format（（Date）mval）; } else if（mval instanceof java.lang。Boolean）{mStr =“BOOLEAN：”+ mval.toString（）; } if（i&gt; 1）{buff.append（“，\ t”）; } buff.append（mStr）; } buff.append（“] \ n”）; System.out.println（buff.toString（））; }}</code></pre><p><code class="codeph">PgqlExample10.java</code>给出了下面的输出<code class="codeph">test_graph</code> 。
                              </p><pre class="oac_no_warn" dir="ltr">[STRING：John，STRING：Bill] [STRING：John，STRING：Susan] [STRING：Ray，STRING：Susan] [STRING：Susan，STRING：John] [STRING：Bill，STRING：John]</pre></div>
                           <!-- class="example" -->
                        </div>
                        <div>
                           <div class="familylinks">
                              <div class="parentlink">
                                 <p><strong>父主题：</strong> <a href="sql-based-property-graph-query-analytics.html#GUID-E9CC82C3-BD5A-4581-AE26-2432D6929D44">PGQL转换和执行的其他选项</a></p>
                              </div>
                           </div>
                        </div>
                        
                     </div>
                     <div class="props_rev_3"><a id="GUID-AC37DA9D-7178-4BDA-B21F-FC18EB27A290" name="GUID-AC37DA9D-7178-4BDA-B21F-FC18EB27A290"></a><h6 id="SPGDG-GUID-AC37DA9D-7178-4BDA-B21F-FC18EB27A290" class="sect6"><span class="enumeration_section">4.8.2.5.2</span>使用GT $骨架表</h6>
                        <div>
                           <p>属性图关系模式定义了一个GT $骨架表，无论边有多少属性，它都会为图中的每条边存储一行。默认情况下不会填充此框架表，但如果填充它，PGQL查询执行可以利用GT $表并避免在许多情况下对GE $表进行排序操作，从而显着提高性能。</p>
                           <p>您可以将<code class="codeph">"USE_GT_TAB=T"</code>添加到<code class="codeph">executeQuery</code>和<code class="codeph">translateQuery</code>的<code class="codeph">options</code>参数中，或者在Java命令行中使用<code class="codeph">-Doracle.pg.rdbms.pgql.useGtTab=true</code>来打开GT $表使用情况。
                           </p>
                           <div class="example" id="GUID-AC37DA9D-7178-4BDA-B21F-FC18EB27A290__PGQLEXAMPLE11.JAVA-1F029EA0">
                              <p class="titleinexample">例4-34 PgqlExample11.java</p>
                              <p><code class="codeph">PgqlExample11.java</code>显示使用GT $骨架表的查询。
                              </p><pre class="pre codeblock"><code>import oracle.pg.rdbms。*;导入oracle.pg.common。*; import java.util。*; import java.text。*; import java.sql。*; import java.time。*; import java.time.format。*; / ** *此示例显示如何使用GT $框架表来更快地执行* PGQL查询。* / public class PgqlExample11 {public static void main（String [] szArgs）throws Exception {int iArgIdx = 0; String szHost = szArgs [iArgIdx ++]; String szPort = szArgs [iArgIdx ++]; String szSID = szArgs [iArgIdx ++]; String szUser = szArgs [iArgIdx ++]; String szPassword = szArgs [iArgIdx ++]; String szGraph = szArgs [iArgIdx ++]; String szVertexFile = szArgs [iArgIdx ++]; String szEdgeFile = szArgs [iArgIdx ++]; Oracle oracle = null; OraclePropertyGraph opg = null; OraclePgqlStatement ops = null; try {//创建与Oracle的连接oracle = new Oracle（“jdbc：oracle：thin：@”+ szHost +“：”+ szPort +“：”+ szSID，szUser，szPassword）; //创建属性图opg = OraclePropertyGraph.getInstance（oracle，szGraph）; //清除所有现有数据opg.clearRepository（）; //用不同的边填充GT $骨架表CallableStatement cs = null; cs = oracle.getConnection（）。prepareCall（“begin opg_graphop.populate_skeleton_tab（：1，：2）; end;”）; cs.setString（1，szGraph）; cs.setInt（2,1）; cs.execute（）; cs.close（）; //加载数据OraclePropertyGraphDataLoader opgLoader = OraclePropertyGraphDataLoader.getInstance（）; opgLoader.loadData（opg，szVertexFile，szEdgeFile，1）; //执行查询以获取ResultSet对象String pgql =“SELECT id（v1），id（v2）”+“MATCH（v1） -  [knows]  - &gt;（v2）”; //创建OraclePgqlStatement ops = OraclePgqlExecutionFactory.createStatement（opg）; //获取没有GT表的SQL转换OraclePgqlSqlTrans sqlTrans = ops.translateQuery（pgql，“”）; //打印SQL翻译System.out.println（“ - 没有GT表的SQL翻译----------------------”）;的System.out.println（sqlTrans.getSqlTranslation（））; //使用GT表获取SQL转换sqlTrans = ops.translateQuery（pgql，“USE_GT_TAB = T”）; //打印SQL翻译System.out.println（“ - 使用GT表进行SQL翻译-------------------------”）;的System.out.println（sqlTrans.getSqlTranslation（））; } finally {//关闭语句if（ops！= null）{ops.close（）; } //关闭属性图if（opg！= null）{opg.shutdown（）; } //关闭oracle if（oracle！= null）{oracle.dispose（）; }}}}</code></pre><p><code class="codeph">PgqlExample11.java</code>给出了下面的输出<code class="codeph">test_graph</code> 。
                              </p><pre class="oac_no_warn" dir="ltr">- <span class="bold"><span class="italic">没有GT表的</span></span> SQL转换---------------------- SELECT 7 AS“id（v1）$ T”，to_nchar（T0 $ 0。SVID，'TM9'，'NLS_Numeric_Characters =''。，'''）AS“id（v1）$ V”，T0 $ 0。SVID为“id（v1）$ VN”，to_timestamp_tz（null）AS“id（v1）$ VT”，7 AS“id（v2）$ T”，to_nchar（T0 $ 0。DVID，'TM9'，'NLS_Numeric_Characters =''。，'''）AS“id（v2）$ V”，T0 $ 0。DVID AS“id（v2）$ VN”，to_timestamp_tz（null）AS“id（v2）$ VT” <span class="bold">FROM（SELECT DISTINCT EID，SVID，DVID，EL FROM“SCOTT”。GRAPH1GE $）T0 $ 0</span> - <span class="bold"><span class="italic">使用GT表进行</span></span> SQL转换------------------------- SELECT 7 AS“id（v1）$ T”，to_nchar （T0 $ 0SVID，'TM9'，'NLS_Numeric_Characters =''。，'''）AS“id（v1）$ V”，T0 $ 0。SVID为“id（v1）$ VN”，to_timestamp_tz（null）AS“id（v1）$ VT”，7 AS“id（v2）$ T”，to_nchar（T0 $ 0。DVID，'TM9'，'NLS_Numeric_Characters =''。，'''）AS“id（v2）$ V”，T0 $ 0。DVID AS“id（v2）$ VN”，to_timestamp_tz（null）AS“id（v2）$ VT” <span class="bold">FROM“SCOTT”。GRAPH1GT $ T0 $ 0</span>
</pre></div>
                           <!-- class="example" -->
                        </div>
                        <div>
                           <div class="familylinks">
                              <div class="parentlink">
                                 <p><strong>父主题：</strong> <a href="sql-based-property-graph-query-analytics.html#GUID-E9CC82C3-BD5A-4581-AE26-2432D6929D44">PGQL转换和执行的其他选项</a></p>
                              </div>
                           </div>
                        </div>
                        
                     </div>
                     <div class="props_rev_3"><a id="GUID-3369EA15-739E-4B44-9178-AFC79A33031C" name="GUID-3369EA15-739E-4B44-9178-AFC79A33031C"></a><h6 id="SPGDG-GUID-3369EA15-739E-4B44-9178-AFC79A33031C" class="sect6"><span class="enumeration_section">4.8.2.5.3</span>路径查询选项</h6>
                        <div>
                           <p>有一些选项可用于在PGQL中执行路径查询。 Oracle SQL中有两种基本的评估方法：CONNECT BY或递归的WITH子句。递归WITH是默认的评估方法。此外，您可以进一步修改递归WITH评估方法，以在查询评估的递归步骤中包含DISTINCT修饰符。在每个步骤计算不同的顶点有助于防止高度连接的图形中的组合爆炸。默认情况下不添加DISTINCT修饰符，因为它需要数据库中的特定参数设置（ <code class="codeph">"_recursive_with_control"=8</code> ）。
                           </p>
                           <p>您还可以控制搜索的路径的最大长度。在这种情况下，路径长度定义为评估*和+运算符时允许的重复次数。默认的最大长度不受限制。</p>
                           <p>路径评估选项总结如下。</p>
                           <ul style="list-style-type:disc">
                              <li>
                                 <p><span class="bold">CONNECT BY：</span>要使用CONNECT BY，请在<code class="codeph">options</code>参数中指定<code class="codeph">'USE_RW=F'</code> ，或在Java命令行中指定<code class="codeph">-Doracle.pg.rdbms.pgql.useRW=false</code> 。
                                 </p>
                              </li>
                              <li>
                                 <p><span class="bold">递归中的不同修饰符：</span>要在递归步骤中使用DISTINCT修饰符，首先在数据库会话中设置<code class="codeph">"_recursive_with_control"=8</code> ，然后在<code class="codeph">options</code>参数中指定<code class="codeph">'USE_DIST_RW=T</code> ”或指定<code class="codeph">-Doracle.pg.rdbms.pgql.useDistRW=true</code> Java命令行中的<code class="codeph">-Doracle.pg.rdbms.pgql.useDistRW=true</code> 。如果在会话中<code class="codeph">"_recursive_with_control"</code>尚未设置为8，您将在recursive WITH子句的递归分支中遇到ORA-32486：不支持的操作。
                                 </p>
                              </li>
                              <li>
                                 <p><span class="bold">路径长度限制：</span>要在评估*和+到n时限制最大重复次数，请在查询<code class="codeph">options</code>参数中指定<code class="codeph">'MAX_PATH_LEN=n'</code> ，或在Java命令行中指定<code class="codeph">-Doracle.pg.rdbms.pgql.maxPathLen=n</code> 。
                                 </p>
                              </li>
                           </ul>
                           <div class="example" id="GUID-3369EA15-739E-4B44-9178-AFC79A33031C__PGQLEXAMPLE11.JAVA-1F029478">
                              <p class="titleinexample">例4-35 PgqlExample12.java</p>
                              <p><code class="codeph">PgqlExample12.java</code>显示各种选项下的路径查询转换。
                              </p><pre class="pre codeblock"><code>import oracle.pg.rdbms。*;导入oracle.pg.common。*; import java.util。*; import java.text。*; import java.sql。*; import java.time。*; import java.time.format。*; / ** *此示例显示如何在PGQL路径查询中使用各种选项。* / public class PgqlExample12 {public static void main（String [] szArgs）throws Exception {int iArgIdx = 0; String szHost = szArgs [iArgIdx ++]; String szPort = szArgs [iArgIdx ++]; String szSID = szArgs [iArgIdx ++]; String szUser = szArgs [iArgIdx ++]; String szPassword = szArgs [iArgIdx ++]; String szGraph = szArgs [iArgIdx ++]; String szVertexFile = szArgs [iArgIdx ++]; String szEdgeFile = szArgs [iArgIdx ++]; Oracle oracle = null; OraclePropertyGraph opg = null; OraclePgqlStatement ops = null; try {//创建与Oracle的连接oracle = new Oracle（“jdbc：oracle：thin：@”+ szHost +“：”+ szPort +“：”+ szSID，szUser，szPassword）; //创建属性图opg = OraclePropertyGraph.getInstance（oracle，szGraph）; //清除所有现有数据opg.clearRepository（）; //加载数据OraclePropertyGraphDataLoader opgLoader = OraclePropertyGraphDataLoader.getInstance（）; opgLoader.loadData（opg，szVertexFile，szEdgeFile，1）; //设置“_recursive_with_control”= 8以启用不同的优化//使用Statement stmt = oracle.getConnection（）进行递归优化.createStatement（）; stmt.executeUpdate（“alter session set \”_ recursive_with_control \“= 8”）; stmt.close（）; //用不同的边填充GT $骨架表CallableStatement cs = null; cs = oracle.getConnection（）。prepareCall（“begin opg_graphop.populate_skeleton_tab（：1，：2）; end;”）; cs.setString（1，szGraph）; cs.setInt（2,1）; cs.execute（）; cs.close（）; //路径查询说明选项字符串pgql =“PATH fof AS（） -  [：friendOf]  - &gt;（）”+“SELECT id（v1），id（v2）”+“MATCH（v1） -  /：fof * /  - &gt;（v2）“+”WHERE id（v1）= 2“; //创建OraclePgqlStatement ops = OraclePgqlExecutionFactory.createStatement（opg）; //使用默认值获取SQL转换 - 非不同递归使用OraclePgqlSqlTrans sqlTrans = ops.translateQuery（pgql / *查询字符串* /，2 / * parallel：默认为1 * /，2 / *动态采样：默认为2 * / ，-1 / * max results：-1表示无限制* /，“USE_GT_TAB = T”/ * options * /）; System.out.println（“ - 默认路径转换--------------------”）;的System.out.println（sqlTrans.getSqlTranslation（）+ “\ n”）; //使用DISTINCT可达性优化获得SQL转换sqlTrans = ops.translateQuery（pgql / *查询字符串* /，2 / * parallel：默认为1 * /，2 / *动态采样：默认为2 * /， -  1 / *最大结果：-1表示没有限制* /，“USE_DIST_RW = T USE_GT_TAB = T”/ * options * /）; System.out.println（“ -  DISTINCT RW Path Translation --------------------”）;的System.out.println（sqlTrans.getSqlTranslation（）+ “\ n”）; //使用CONNECT BY获取SQL转换sqlTrans = ops.translateQuery（pgql / *查询字符串* /，2 / * parallel：默认为1 * /，2 / *动态采样：默认为2 * /， -  1 / * max结果：-1表示没有限制* /，“USE_RW = F USE_GT_TAB = T”/ * options * /）; System.out.println（“ -  CONNECT BY Path Translation --------------------”）;的System.out.println（sqlTrans.getSqlTranslation（）+ “\ n”）; } finally {//关闭语句if（ops！= null）{ops.close（）; } //关闭属性图if（opg！= null）{opg.shutdown（）; } //关闭oracle if（oracle！= null）{oracle.dispose（）; }}}}</code></pre><p><code class="codeph">PgqlExample12.java</code>给出了下面的输出<code class="codeph">test_graph</code> 。
                              </p><pre class="oac_no_warn" dir="ltr">- 默认路径转换-------------------- SELECT / * + PARALLEL（2）* / * FROM（SELECT 7 AS“id（v1）$ T”， TO_NCHAR（T0 $ 0SVID，'TM9'，'NLS_Numeric_Characters =''。，'''）AS“id（v1）$ V”，T0 $ 0。SVID为“id（v1）$ VN”，to_timestamp_tz（null）AS“id（v1）$ VT”，7 AS“id（v2）$ T”，to_nchar（T0 $ 0。DVID，'TM9'，'NLS_Numeric_Characters =''。，'''）AS“id（v2）$ V”，T0 $ 0。DVID AS“id（v2）$ VN”，to_timestamp_tz（null）AS“id（v2）$ VT”FROM（/ * Path [* / SELECT DISTINCT SVID，DVID FROM（SELECT 2 AS SVID，2 AS DVID FROM SYS。 DUAL UNION ALL SELECT SVID，DVID FROM（WITH RW（ROOT，DVID）AS（SELECT ROOT，DVID FROM（SELECT SVID ROOT，DVID FROM（SELECT T0 $ 0。SVID为SVID，T0 $ 0。DVID AS DVID FROM“SCOTT”。GRAPH1GT $ T0 $ 0 WHERE T0 $ 0。SVID = 2 AND（T0 $ 0。EL = n'friendOf'AND T0 $ 0。EL IS NOT NULL）））UNION ALL SELECT RW.ROOT，R.DVID FROM（SELECT T0 $ 0。SVID为SVID，T0 $ 0。DVID AS DVID FROM“SCOTT”。GRAPH1GT $ T0 $ 0 WHERE（T0 $ 0。EL = n'friendOf'AND T0 $ 0。EL IS NOT NULL））R，RW WHERE RW.DVID = R.SVID）CYCLE DVID SET cycle_col TO 1 DEFAULT 0 SELECT ROOT SVID，DVID FROM RW））/ *] Path * /）T0 $ 0 WHERE T0 $ 0。SVID = 2） -  DISTINCT RW路径转换-------------------- SELECT / * + PARALLEL（2）* / * FROM（SELECT 7 AS“id（v1 ）$ T“，to_nchar（T0 $ 0。SVID，'TM9'，'NLS_Numeric_Characters =''。，'''）AS“id（v1）$ V”，T0 $ 0。SVID为“id（v1）$ VN”，to_timestamp_tz（null）AS“id（v1）$ VT”，7 AS“id（v2）$ T”，to_nchar（T0 $ 0。DVID，'TM9'，'NLS_Numeric_Characters =''。，'''）AS“id（v2）$ V”，T0 $ 0。DVID AS“id（v2）$ VN”，to_timestamp_tz（null）AS“id（v2）$ VT”FROM（/ * Path [* / SELECT DISTINCT SVID，DVID FROM（SELECT 2 AS SVID，2 AS DVID FROM SYS。 DUAL UNION ALL SELECT SVID，DVID FROM（WITH RW（ROOT，DVID）AS（SELECT ROOT，DVID FROM（SELECT SVID ROOT，DVID FROM（SELECT T0 $ 0。SVID为SVID，T0 $ 0。DVID AS DVID FROM“SCOTT”。GRAPH1GT $ T0 $ 0 WHERE T0 $ 0。SVID = 2 AND（T0 $ 0。EL = n'friendOf'AND T0 $ 0。EL IS NOT NULL）））UNION ALL SELECT DISTINCT RW.ROOT，R.DVID FROM（SELECT T0 $ 0。SVID为SVID，T0 $ 0。DVID AS DVID FROM“SCOTT”。GRAPH1GT $ T0 $ 0 WHERE（T0 $ 0。EL = n'friendOf'AND T0 $ 0。EL IS NOT NULL））R，RW WHERE RW.DVID = R.SVID）CYCLE DVID SET cycle_col TO 1 DEFAULT 0 SELECT ROOT SVID，DVID FROM RW））/ *] Path * /）T0 $ 0 WHERE T0 $ 0。SVID = 2） - 通过路径转换连接-------------------- SELECT / * + PARALLEL（2）* / * FROM（SELECT 7 AS“id（v1 ）$ T“，to_nchar（T0 $ 0。SVID，'TM9'，'NLS_Numeric_Characters =''。，'''）AS“id（v1）$ V”，T0 $ 0。SVID为“id（v1）$ VN”，to_timestamp_tz（null）AS“id（v1）$ VT”，7 AS“id（v2）$ T”，to_nchar（T0 $ 0。DVID，'TM9'，'NLS_Numeric_Characters =''。，'''）AS“id（v2）$ V”，T0 $ 0。DVID AS“id（v2）$ VN”，to_timestamp_tz（null）AS“id（v2）$ VT”FROM（/ * Path [* / SELECT DISTINCT SVID，DVID FROM（SELECT 2 AS SVID，2 AS DVID FROM SYS。 DUAL UNION ALL SELECT SVID，DVID FROM（SELECT CONNECT_BY_ROOT T0 $ 0。SVID为SVID，T0 $ 0。DVID AS DVID FROM（选择T0 $ 0。SVID为SVID，T0 $ 0。DVID AS DVID FROM“SCOTT”。GRAPH1GT $ T0 $ 0 WHERE（T0 $ 0。EL = n'friendOf'AND T0 $ 0。EL不是空））T0 $ 0以T0 $ 0开始。SVID = 2连接NOCYCLE PRIOR DVID = SVID））/ *]路径* /）T0 $ 0 WHERE T0 $ 0。SVID = 2）</pre><p>具有默认递归WITH策略的第一个查询的查询计划应类似于以下内容。</p><pre class="oac_no_warn" dir="ltr">- 默认RW ---------------------------------------------- ----------------------------------------- | Id |操作|名称| -------------------------------------------------- ------------------------------------- | 0 |选择声明| | | 1 | TEMP TABLE TRANSFORMATION | | | 2 | LOAD AS SELECT（CURSOR DURATION MEMORY）| SYS_TEMP_0FD9D6642_133DFF | | 3 | UNION ALL（回程）第一个| | | 4 | PX COORDINATOR | | | 5 | PX SEND QC（RANDOM）| ：TQ20000 | | 6 | LOAD AS SELECT（CURSOR DURATION MEMORY）| SYS_TEMP_0FD9D6642_133DFF | | 7 | PX BLOCK ITERATOR | | | * 8 |表访问完全| GRAPH1GT $ | | 9 | PX COORDINATOR | | | 10 | PX SEND QC（RANDOM）| ：TQ10000 | | 11 | LOAD AS SELECT（CURSOR DURATION MEMORY）| SYS_TEMP_0FD9D6642_133DFF | | 12 | NESTED LOOPS | | | 13 | PX BLOCK ITERATOR | | | * 14 |表访问完全| SYS_TEMP_0FD9D6642_133DFF | | 15 | PARTITION HASH ALL | | | * 16 |按本地索引ROWID批量表的访问权限| GRAPH1GT $ | | * 17 | INDEX RANGE SCAN | GRAPH1XSG $ | | 18 | PX COORDINATOR | | | 19 | PX SEND QC（RANDOM）| ：TQ30001 | | 20 |查看| | | 21 | HASH UNIQUE | | | 22 | PX RECEIVE | | | 23 | PX SEND HASH | ：TQ30000 | | 24 | HASH UNIQUE | | | 25 |查看| | | 26 | UNION-ALL | | | 27 | PX SELECTOR | | | 28 |快速双| | | 29 |查看| | | * 30 |查看| | | 31 | PX BLOCK ITERATOR | | | 32 |表访问完全| SYS_TEMP_0FD9D6642_133DFF | -------------------------------------------------- -------------------------------------</pre><p>在递归步骤中添加DISTINCT修饰符的第二个查询的查询计划应类似于以下内容。</p><pre class="oac_no_warn" dir="ltr">-------------------------------------------------- -------------------------------------------- | Id |操作|名称| -------------------------------------------------- -------------------------------------------- | 0 |选择声明| | | 1 | TEMP TABLE TRANSFORMATION | | | 2 | LOAD AS SELECT（CURSOR DURATION MEMORY）| SYS_TEMP_0FD9D663B_133DFF | | 3 | UNION ALL（回程）第一个| | | 4 | PX COORDINATOR | | | 5 | PX SEND QC（RANDOM）| ：TQ20000 | | 6 | LOAD AS SELECT（CURSOR DURATION MEMORY）| SYS_TEMP_0FD9D663B_133DFF | | 7 | PX BLOCK ITERATOR | | | * 8 |表访问完全| GRAPH1GT $ | | 9 | PX COORDINATOR | | | 10 | PX SEND QC（RANDOM）| ：TQ10001 | | 11 | LOAD AS SELECT（CURSOR DURATION MEMORY）| SYS_TEMP_0FD9D663B_133DFF | | 12 | SORT GROUP BY | | | 13 | PX RECEIVE | | | 14 | PX SEND HASH | ：TQ10000 | | 15 | SORT GROUP BY | | | 16 | NESTED LOOPS | | | 17 | PX BLOCK ITERATOR | | | * 18 |表访问完全| SYS_TEMP_0FD9D663B_133DFF | | 19 | PARTITION HASH ALL | | | * 20 |按本地索引ROWID批量表的访问权限| GRAPH1GT $ | | * 21 | INDEX RANGE SCAN | GRAPH1XSG $ | | 22 | PX COORDINATOR | | | 23 | PX SEND QC（RANDOM）| ：TQ30001 | | 24 |查看| | | 25 | HASH UNIQUE | | | 26 | PX RECEIVE | | | 27 | PX SEND HASH | ：TQ30000 | | 28 | HASH UNIQUE | | | 29 |查看| | | 30 | UNION-ALL | | | 31 | PX SELECTOR | | | 32 |快速双| | | 33 |查看| | | * 34 |查看| | | 35 | PX BLOCK ITERATOR | | | 36 |表访问完全| SYS_TEMP_0FD9D663B_133DFF | -------------------------------------------------- --------------------------------------------</pre><p>使用CONNECTY BY的第三个查询的查询计划应类似于以下内容。</p><pre class="oac_no_warn" dir="ltr">-------------------------------------------------- ---------------- | Id |操作|名称| -------------------------------------------------- ---------------- | 0 |选择声明| | | 1 |查看| | | 2 | HASH UNIQUE | | | 3 |查看| | | 4 | UNION-ALL | | | 5 |快速双| | | * 6 |查看| | | * 7 |没有过滤与START-WITH连接| | 8 | PX COORDINATOR | | | 9 | PX SEND QC（RANDOM）| ：TQ10000 | | 10 | PX BLOCK ITERATOR | | | * 11 |表访问完全| GRAPH1GT $ | -------------------------------------------------- ----------------</pre></div>
                           <!-- class="example" -->
                           <div class="example" id="GUID-3369EA15-739E-4B44-9178-AFC79A33031C__GUID-9AA83DA5-6785-4C18-81EF-CED895052476">
                              <p class="titleinexample">例4-36 PgqlExample13.java</p>
                              <p><code class="codeph">PgqlExample13.java</code>显示了如何在路径查询评估期间设置长度限制。
                              </p><pre class="pre codeblock"><code>import oracle.pg.rdbms。*;导入oracle.pg.common。*; import oracle.pgql.lang。PgqlException; import oracle.pgql.lang。ResultSet的; import java.util。*; import java.text。*; import java.sql。*; import java.time。*; import java.time.format。*; / ** *此示例显示如何使用* PGQL路径查询的最大路径长度选项。* / public class PgqlExample13 {public static void main（String [] szArgs）throws Exception {int iArgIdx = 0; String szHost = szArgs [iArgIdx ++]; String szPort = szArgs [iArgIdx ++]; String szSID = szArgs [iArgIdx ++]; String szUser = szArgs [iArgIdx ++]; String szPassword = szArgs [iArgIdx ++]; String szGraph = szArgs [iArgIdx ++]; String szVertexFile = szArgs [iArgIdx ++]; String szEdgeFile = szArgs [iArgIdx ++]; Oracle oracle = null; OraclePropertyGraph opg = null; OraclePgqlStatement ops = null; ResultSet rs = null; try {//创建与Oracle的连接oracle = new Oracle（“jdbc：oracle：thin：@”+ szHost +“：”+ szPort +“：”+ szSID，szUser，szPassword）; //创建属性图opg = OraclePropertyGraph.getInstance（oracle，szGraph）; //清除所有现有数据opg.clearRepository（）; //加载数据OraclePropertyGraphDataLoader opgLoader = OraclePropertyGraphDataLoader.getInstance（）; opgLoader.loadData（opg，szVertexFile，szEdgeFile，1）; //路径查询说明选项字符串pgql =“PATH fof AS（） -  [：friendOf]  - &gt;（）”+“SELECT v1.fname AS fname1，v2.fname AS fname2”+“MATCH（v1） -  /： fof * /  - &gt;（v2）“+”WHERE v1.fname ='Ray'“; //创建OraclePgqlStatement ops = OraclePgqlExecutionFactory.createStatement（opg）; //执行1-hop rs = ops.executeQuery（pgql，“MAX_PATH_LEN = 1”）的查询; //打印结果System.out.println（“ -  1-hop ----------------的结果”）; printResults（rs，2）; //关闭结果集rs.close（）; //执行2-hop rs = ops.executeQuery（pgql，“MAX_PATH_LEN = 2”）的查询; //打印结果System.out.println（“ -  2-hop ----------------的结果”）; printResults（rs，2）; //关闭结果集rs.close（）; //执行3跳的查询rs = ops.executeQuery（pgql，“MAX_PATH_LEN = 3”）; //打印结果System.out.println（“ -  3-hop ----------------的结果”）; printResults（rs，2）; //关闭结果集rs.close（）; } finally {//关闭结果集if（rs！= null）{rs.close（）; } //关闭语句if（ops！= null）{ops.close（）; } //关闭属性图if（opg！= null）{opg.shutdown（）; } //关闭oracle if（oracle！= null）{oracle.dispose（）; / ** *打印PGQL ResultSet * / static void printResults（ResultSet rs，int numCols）throws Exception {StringBuffer buff = new StringBuffer（“”）; SimpleDateFormat sdf = new SimpleDateFormat（“yyyy-MM-dd'T'HH：mm：ss。SSSXXX“）; while（rs.next（））{buff.append（”[“）; for（int i = 1; i &lt;= numCols; i ++）{//使用泛型getObject来处理所有类型Object mval = rs .getObject（i）; String mStr =“”; if（mval instanceof java.lang。字符串）{mStr =“STRING：”+ mval.toString（）; } else if（mval instanceof java.lang。整数）{mStr =“INTEGER：”+ mval.toString（）; } else if（mval instanceof java.lang。长）{mStr =“LONG：”+ mval.toString（）; } else if（mval instanceof java.lang。Float）{mStr =“FLOAT：”+ mval.toString（）; } else if（mval instanceof java.lang。Double）{mStr =“DOUBLE：”+ mval.toString（）; } else if（mval instanceof java.sql。时间戳）{mStr =“DATE：”+ sdf.format（（java.util。日期）MVAL）; } else if（mval instanceof java.lang。Boolean）{mStr =“BOOLEAN：”+ mval.toString（）; } if（i&gt; 1）{buff.append（“，\ t”）; } buff.append（mStr）; } buff.append（“] \ n”）; System.out.println（buff.toString（））; }}</code></pre><p><code class="codeph">PgqlExample13.java</code>有以下输出<code class="codeph">test_graph</code> 。
                              </p><pre class="oac_no_warn" dir="ltr">- 单跳结果---------------- [STRING：Ray，STRING：Ray] [STRING：Ray，STRING：Susan]  -  2跳的结果 - -------------- [STRING：Ray，STRING：Susan] [STRING：Ray，STRING：Ray] [STRING：Ray，STRING：John]  -  3跳的结果 - -------------- [STRING：Ray，STRING：Susan] [STRING：Ray，STRING：Bill] [STRING：Ray，STRING：Ray] [STRING：Ray，STRING：John]</pre></div>
                           <!-- class="example" -->
                        </div>
                        <div>
                           <div class="familylinks">
                              <div class="parentlink">
                                 <p><strong>父主题：</strong> <a href="sql-based-property-graph-query-analytics.html#GUID-E9CC82C3-BD5A-4581-AE26-2432D6929D44">PGQL转换和执行的其他选项</a></p>
                              </div>
                           </div>
                        </div>
                        
                     </div>
                     <div class="props_rev_3"><a id="GUID-4B12B361-A502-4B39-9267-E457C2F14D74" name="GUID-4B12B361-A502-4B39-9267-E457C2F14D74"></a><h6 id="SPGDG-GUID-4B12B361-A502-4B39-9267-E457C2F14D74" class="sect6"><span class="enumeration_section">4.8.2.5.4</span>部分对象构造的选项</h6>
                        <div>
                           <p>从查询结果中读取边时，将开始和结束顶点添加到任何本地缓存时有两种可能的行为：</p>
                           <ul style="list-style-type:disc">
                              <li>
                                 <p>仅添加可从边缘本身获得的顶点ID。为了提高效率，此选项是默认选项。</p>
                              </li>
                              <li>
                                 <p>添加顶点ID，并检索开始和结束顶点的所有属性。对于此行为，您可以在从PGQL查询结果集构造的每个<code class="codeph">OracleVertex</code>对象上调用<code class="codeph">setPartial(true)</code> 。
                                 </p>
                              </li>
                           </ul>
                           <div class="example" id="GUID-4B12B361-A502-4B39-9267-E457C2F14D74__PGQLEXAMPLE12.JAVA-1F6E0823">
                              <p class="titleinexample">例4-37 PgqlExample14.java</p>
                              <p><code class="codeph">PgqlExample14.java</code>说明了这种行为差异。该程序首先执行查询以检索所有边，这会导致将事件顶点添加到本地缓存。第二个查询检索所有顶点。然后程序打印每个<code class="codeph">OracleVertex</code>对象以显示已加载的属性。
                              </p><pre class="pre codeblock"><code>import oracle.pg.rdbms。*;导入oracle.pg.common。*; import oracle.pgql.lang。PgqlException; import oracle.pgql.lang。ResultSet的; import java.util。*; import java.text。*; import java.sql。*; import java.time。*; import java.time.format。*; / ** *此示例显示了从PGQL查询结果创建的OracleVertex对象*的setPartial（true）行为。* / public class PgqlExample14 {public static void main（String [] szArgs）throws Exception {int iArgIdx = 0; String szHost = szArgs [iArgIdx ++]; String szPort = szArgs [iArgIdx ++]; String szSID = szArgs [iArgIdx ++]; String szUser = szArgs [iArgIdx ++]; String szPassword = szArgs [iArgIdx ++]; String szGraph = szArgs [iArgIdx ++]; String szVertexFile = szArgs [iArgIdx ++]; String szEdgeFile = szArgs [iArgIdx ++]; Oracle oracle = null; OraclePropertyGraph opg = null; OraclePgqlStatement ops = null; ResultSet rs = null; try {//创建与Oracle的连接oracle = new Oracle（“jdbc：oracle：thin：@”+ szHost +“：”+ szPort +“：”+ szSID，szUser，szPassword）; //创建属性图opg = OraclePropertyGraph.getInstance（oracle，szGraph）; //清除所有现有数据opg.clearRepository（）; //加载数据OraclePropertyGraphDataLoader opgLoader = OraclePropertyGraphDataLoader.getInstance（）; opgLoader.loadData（opg，szVertexFile，szEdgeFile，1）; //查询说明set partial String pgql =“SELECT id（e），label（e）”+“MATCH（v1） -  [e：knows]  - &gt;（v2）”; //创建OraclePgqlStatement ops = OraclePgqlExecutionFactory.createStatement（opg）; //执行1-hop rs = ops.executeQuery（pgql，“”）的查询; //打印结果System.out.println（“ - 边缘查询的结果-----------------”）; printResults（rs，2）; //关闭结果集rs.close（）; //查询以检索顶点pgql =“SELECT id（v）”+“MATCH（v）”; //获取结果中的每个顶点对象并使用toString（）进行打印rs = ops.executeQuery（pgql，“”）; //遍历结果System.out.println（“ - 从顶点查询中检索的顶点对象 - ”）; while（rs.next（））{Long vid = rs.getLong（1）; OracleVertex v = OracleVertex.getInstance（opg，vid）;的System.out.println（v.toString（））; } // close结果集rs.close（）; //执行相同的查询但为每个顶点调用setPartial（true）rs = ops.executeQuery（pgql，“”）; System.out.println（“ - 使用setPartial从顶点查询中检索的顶点对象（true） - ”）; while（rs.next（））{Long vid = rs.getLong（1）; OracleVertex v = OracleVertex.getInstance（opg，vid）; v.setPartial（真）;的System.out.println（v.toString（））; } // close结果集rs.close（）; } finally {//关闭结果集if（rs！= null）{rs.close（）; } //关闭语句if（ops！= null）{ops.close（）; } //关闭属性图if（opg！= null）{opg.shutdown（）; } //关闭oracle if（oracle！= null）{oracle.dispose（）; / ** *打印PGQL ResultSet * / static void printResults（ResultSet rs，int numCols）throws Exception {StringBuffer buff = new StringBuffer（“”）; SimpleDateFormat sdf = new SimpleDateFormat（“yyyy-MM-dd'T'HH：mm：ss。SSSXXX“）; while（rs.next（））{buff.append（”[“）; for（int i = 1; i &lt;= numCols; i ++）{//使用泛型getObject来处理所有类型Object mval = rs .getObject（i）; String mStr =“”; if（mval instanceof java.lang。字符串）{mStr =“STRING：”+ mval.toString（）; } else if（mval instanceof java.lang。整数）{mStr =“INTEGER：”+ mval.toString（）; } else if（mval instanceof java.lang。长）{mStr =“LONG：”+ mval.toString（）; } else if（mval instanceof java.lang。Float）{mStr =“FLOAT：”+ mval.toString（）; } else if（mval instanceof java.lang。Double）{mStr =“DOUBLE：”+ mval.toString（）; } else if（mval instanceof java.sql。时间戳）{mStr =“DATE：”+ sdf.format（（java.util。日期）MVAL）; } else if（mval instanceof java.lang。Boolean）{mStr =“BOOLEAN：”+ mval.toString（）; } if（i&gt; 1）{buff.append（“，\ t”）; } buff.append（mStr）; } buff.append（“] \ n”）; System.out.println（buff.toString（））; }}</code></pre><p><code class="codeph">PgqlExample14.java</code>的输出是：</p><pre class="oac_no_warn" dir="ltr">- 边缘查询的结果----------------- [LONG：11，STRING：know] [LONG：6，STRING：know] [LONG：10，STRING：knows] [长：5，STRING：知道] [LONG：4，STRING：知道] [LONG：13，STRING：知道] [LONG：12，STRING：知道] [LONG：9，STRING：know] [LONG：8， STRING：知道] [LONG：15，STRING：know] [LONG：7，STRING：know] [LONG：14，STRING：knows]  - 从顶点查询中检索的顶点对象 - 顶点ID 3 [NULL] {}顶点ID 0 [NULL] {}顶点ID 2 [NULL] {}顶点ID 1 [NULL] {}  - 使用setPartial从顶点查询中检索的顶点对象（true） - 顶点ID 3 [NULL] {bval：bol：false ，fname：str：Susan，lname：str：Blue，mval：bol：false，age：int：35} Vertex ID 0 [NULL] {bval：bol：true，fname：str：Bill，lname：str：Brown， mval：str：y，age：int：40} Vertex ID 2 [NULL] {fname：str：Ray，lname：str：Green，mval：dat：1985-01-01 04：00：00.0，age：int： 41}顶点ID 1 [NULL] {bval：bol：true，fname：str：John，lname：str：黑色，mval：int：27，年龄：int：30}</pre></div>
                           <!-- class="example" -->
                        </div>
                        <div>
                           <div class="familylinks">
                              <div class="parentlink">
                                 <p><strong>父主题：</strong> <a href="sql-based-property-graph-query-analytics.html#GUID-E9CC82C3-BD5A-4581-AE26-2432D6929D44">PGQL转换和执行的其他选项</a></p>
                              </div>
                           </div>
                        </div>
                        
                     </div>
                  </div>
                  <div class="props_rev_3"><a id="GUID-623F91CC-1686-4D95-B69F-FA7F81352A90" name="GUID-623F91CC-1686-4D95-B69F-FA7F81352A90"></a><h5 id="SPGDG-GUID-623F91CC-1686-4D95-B69F-FA7F81352A90" class="sect5"><span class="enumeration_section">4.8.2.6</span>查询其他用户的属性图</h5>
                     <div>
                        <p>如果已在数据库中授予适当的权限，则可以查询其他用户的属性图数据。例如，要在SCOTT的模式中查询GRAPH1，您必须具有SCOTT.GRAPH1GE $和SCOTT.GRAPH1VT $的READ权限，并且如果要使用<code class="codeph">USE_GT_TAB=T</code>选项查询，则还必须具有SCOTT.GRAPH1GT $的READ权限。
                        </p>
                        <div class="example" id="GUID-623F91CC-1686-4D95-B69F-FA7F81352A90__PGQLEXAMPLE14.JAVA-1F6F3261">
                           <p class="titleinexample">例4-38 PgqlExample15.java</p>
                           <p><code class="codeph">PgqlExample15.java</code>显示了另一个用户如何在SCOTT的模式中查询图形。
                           </p><pre class="pre codeblock"><code>import oracle.pg.rdbms。*;导入oracle.pg.common。*; import oracle.pgql.lang。PgqlException; import oracle.pgql.lang。ResultSet的; import java.util。*; import java.text。*; / ** *此示例显示如何查询位于另一个用户的*架构中的属性图。需要对其他用户的*属性图的GE $，VT $和GT $表的READ权限以避免ORA-00942：表或视图不存在。* / public class PgqlExample15 {public static void main（String [] szArgs）throws Exception {int iArgIdx = 0; String szHost = szArgs [iArgIdx ++]; String szPort = szArgs [iArgIdx ++]; String szSID = szArgs [iArgIdx ++]; String szUser = szArgs [iArgIdx ++]; String szPassword = szArgs [iArgIdx ++]; String szGraph = szArgs [iArgIdx ++]; String szVertexFile = szArgs [iArgIdx ++]; String szEdgeFile = szArgs [iArgIdx ++]; Oracle oracle = null; OraclePropertyGraph opg = null; OraclePgqlStatement ops = null; ResultSet rs = null; try {//创建与Oracle的连接oracle = new Oracle（“jdbc：oracle：thin：@”+ szHost +“：”+ szPort +“：”+ szSID，szUser，szPassword）; //为Scott的图形获取属性图实例opg = OraclePropertyGraph.getInstance（oracle，“SCOTT”，szGraph，1,1，null，null）; //创建OraclePgqlStatement ops = OraclePgqlExecutionFactory.createStatement（opg）; //执行查询以获取ResultSet对象字符串pgql =“SELECT v.fname AS fname，v.lname AS lname”+“MATCH（v）”; rs = ops.executeQuery（pgql，“”）; //打印查询结果printResults（rs，2）; } finally {//关闭结果集if（rs！= null）{rs.close（）; } //关闭语句if（ops！= null）{ops.close（）; } //关闭oracle if（oracle！= null）{oracle.dispose（）; / ** *打印PGQL ResultSet * / static void printResults（ResultSet rs，int numCols）throws Exception {StringBuffer buff = new StringBuffer（“”）; SimpleDateFormat sdf = new SimpleDateFormat（“yyyy-MM-dd'T'HH：mm：ss。SSSXXX“）; while（rs.next（））{buff.append（”[“）; for（int i = 1; i &lt;= numCols; i ++）{//使用泛型getObject来处理所有类型Object mval = rs .getObject（i）; String mStr =“”; if（mval instanceof java.lang。字符串）{mStr =“STRING：”+ mval.toString（）; } else if（mval instanceof java.lang。整数）{mStr =“INTEGER：”+ mval.toString（）; } else if（mval instanceof java.lang。长）{mStr =“LONG：”+ mval.toString（）; } else if（mval instanceof java.lang。Float）{mStr =“FLOAT：”+ mval.toString（）; } else if（mval instanceof java.lang。Double）{mStr =“DOUBLE：”+ mval.toString（）; } else if（mval instanceof java.sql。时间戳）{mStr =“DATE：”+ sdf.format（（java.util。日期）MVAL）; } else if（mval instanceof java.lang。Boolean）{mStr =“BOOLEAN：”+ mval.toString（）; } if（i&gt; 1）{buff.append（“，\ t”）; } buff.append（mStr）; } buff.append（“] \ n”）; System.out.println（buff.toString（））; }}</code></pre><p>以下SQL语句创建数据库用户USER2并授予必要的权限。您还可以使用<code class="codeph">OraclePropertyGraph.grantAccess</code> Java API来实现相同的效果。
                           </p><pre class="oac_no_warn" dir="ltr">SQL&gt;将connection，resource，unlimited tablespace授予user2标识的user2;格兰特成功了。SQL&gt;将scott.graph1vt $读取到user2;格兰特成功了。SQL&gt;将scott.graph1ge $读取到user2;格兰特成功了。SQL&gt;将scott.graph1gt $读取到user2;格兰特成功了。
</pre><p>输出为<code class="codeph">PgqlExample15.java</code>为<code class="codeph">test_graph</code>数据时连接到数据库中作为USER2是设定如下。请注意，在运行<code class="codeph">PgqlExample15</code>之前， <code class="codeph">test_graph</code>应该已由用户SCOTT加载为<code class="codeph">PgqlExample15</code> 。
                           </p><pre class="oac_no_warn" dir="ltr">[STRING：Susan，STRING：Blue] [STRING：Bill，STRING：Brown] [STRING：Ray，STRING：Green] [STRING：John，STRING：Black]</pre></div>
                        <!-- class="example" -->
                     </div>
                     <div>
                        <div class="familylinks">
                           <div class="parentlink">
                              <p><strong>父主题：</strong> <a href="sql-based-property-graph-query-analytics.html#GUID-296732FE-D57B-41B5-937B-078E234422CC">使用oracle.pg.rdbms Java包执行PGQL查询</a></p>
                           </div>
                        </div>
                     </div>
                     
                  </div>
                  <div class="props_rev_3"><a id="GUID-EECCE896-473F-46DD-8805-9BF696DF60AF" name="GUID-EECCE896-473F-46DD-8805-9BF696DF60AF"></a><h5 id="SPGDG-GUID-EECCE896-473F-46DD-8805-9BF696DF60AF" class="sect5"><span class="enumeration_section">4.8.2.7</span>使用<span class="enumeration_section">PGQL的</span>查询优化器提示</h5>
                     <div>
                        <p>Java API允许在执行PGQL查询时影响连接类型的查询优化器提示。<code class="codeph">OraclePgqlStatement</code>和<code class="codeph">OraclePgqlPreparedStatement</code>的<code class="codeph">executeQuery</code>和<code class="codeph">translateQuery</code>方法接受options参数中的以下字符串，以影响相应SQL查询的查询计划。
                        </p>
                        <ul style="list-style-type:disc">
                           <li>
                              <p>ALL_EDGE_NL  - 对涉及$ GE和$ GT表的所有连接使用嵌套循环连接。</p>
                           </li>
                           <li>
                              <p>ALL_EDGE_HASH  - 对涉及$ GE和$ GT表的所有连接使用HASH连接。</p>
                           </li>
                           <li>
                              <p>ALL_VERTEX_NL  - 对涉及$ VT表的所有连接使用嵌套循环连接。</p>
                           </li>
                           <li>
                              <p>ALL_VERTEX_HASH  - 对涉及$ VT表的所有连接使用HASH连接。</p>
                           </li>
                        </ul>
                        <div class="example" id="GUID-EECCE896-473F-46DD-8805-9BF696DF60AF__PGQLEXAMPLE15.JAVA-1F6FFA62">
                           <p class="titleinexample">例4-39 PgqlExample16.java</p>
                           <p><code class="codeph">PgqlExample16.java</code>显示了如何使用优化程序提示来影响用于图遍历的连接。
                           </p><pre class="pre codeblock"><code>import oracle.pg.rdbms。*;导入oracle.pg.common。*; import java.util。*; import java.text。*; import java.sql。*; import java.time。*; import java.time.format。*; / ** *此示例显示如何在PGQL查询中使用查询优化器提示。* / public class PgqlExample16 {public static void main（String [] szArgs）throws Exception {int iArgIdx = 0; String szHost = szArgs [iArgIdx ++]; String szPort = szArgs [iArgIdx ++]; String szSID = szArgs [iArgIdx ++]; String szUser = szArgs [iArgIdx ++]; String szPassword = szArgs [iArgIdx ++]; String szGraph = szArgs [iArgIdx ++]; String szVertexFile = szArgs [iArgIdx ++]; String szEdgeFile = szArgs [iArgIdx ++]; Oracle oracle = null; OraclePropertyGraph opg = null; OraclePgqlStatement ops = null; try {//创建与Oracle的连接oracle = new Oracle（“jdbc：oracle：thin：@”+ szHost +“：”+ szPort +“：”+ szSID，szUser，szPassword）; //创建属性图opg = OraclePropertyGraph.getInstance（oracle，szGraph）; //清除所有现有数据opg.clearRepository（）; //加载数据OraclePropertyGraphDataLoader opgLoader = OraclePropertyGraphDataLoader.getInstance（）; opgLoader.loadData（opg，szVertexFile，szEdgeFile，1）; //用不同的边填充GT $骨架表CallableStatement cs = null; cs = oracle.getConnection（）。prepareCall（“begin opg_graphop.populate_skeleton_tab（：1，：2）; end;”）; cs.setString（1，szGraph）; cs.setInt（2,1）; cs.execute（）; cs.close（）; //用于说明连接提示的查询字符串pgql =“SELECT id（v1），id（v4）”+“MATCH（v1） -  [：friendOf]  - &gt;（v2） -  [：friendOf]  - &gt;（v3） -  [ ：friendOf]  - &gt;（V4）“; //创建OraclePgqlStatement ops = OraclePgqlExecutionFactory.createStatement（opg）; //使用散列连接提示进行SQL转换提示OraclePgqlSqlTrans sqlTrans = ops.translateQuery（pgql / * query string * /，“USE_GT_TAB = T ALL_EDGE_HASH”/ * options * /）; // print SQL translation System.out.println（“ - 用ALL_EDGE_HASH查询--------------------”）;的System.out.println（sqlTrans.getSqlTranslation（）+ “\ n”）; //使用嵌套循环连接提示SQL转换sqlTrans = ops.translateQuery（pgql / *查询字符串* /，“USE_GT_TAB = T ALL_EDGE_NL”/ * options * /）; // print SQL translation System.out.println（“ - 用ALL_EDGE_NL查询---------------------”）;的System.out.println（sqlTrans.getSqlTranslation（）+ “\ n”）; } finally {//关闭语句if（ops！= null）{ops.close（）; } //关闭属性图if（opg！= null）{opg.shutdown（）; } //关闭oracle if（oracle！= null）{oracle.dispose（）; }}}}</code></pre><p><code class="codeph">PgqlExample16.java</code> for <code class="codeph">test_graph</code>的输出是：</p><pre class="oac_no_warn" dir="ltr">- 使用ALL_EDGE_HASH查询-------------------- SELECT / * + USE_HASH（T0 $ 0 T0 $ 1 T0 $ 2）* / 7 AS“id（v1）$ T” ，to_nchar（T0 $ 0。SVID，'TM9'，'NLS_Numeric_Characters =''。，'''）AS“id（v1）$ V”，T0 $ 0。SVID为“id（v1）$ VN”，to_timestamp_tz（null）AS“id（v1）$ VT”，7 AS“id（v4）$ T”，to_nchar（T0 $ 2。DVID，'TM9'，'NLS_Numeric_Characters =''。，'''）AS“id（v4）$ V”，T0 $ 2。DVID AS“id（v4）$ VN”，to_timestamp_tz（null）AS“id（v4）$ VT”FROM“SCOTT”。GRAPH1GT $ T0 $ 0，“SCOTT”。GRAPH1GT $ T0 $ 1，“SCOTT”。GRAPH1GT $ T0 $ 2 WHERE T0 $ 0。DVID = T0 $ 1SVID和T0 $ 1。DVID = T0港币$ 16。SVID和（T0 $ 0。EL = n'friendOf'AND T0 $ 0。EL不是空）和（T0 $ 1。EL = n'friendOf'和T0 $ 1。EL不是空）和（T0 $ 2。EL = n'friendOf'和T0 $ 2。EL IS NOT NULL） - 使用ALL_EDGE_NL查询--------------------- SELECT / * + USE_NL（T0 $ 0 T0 $ 1 T0 $ 2）* / 7 AS“id （v1）$ T“，to_nchar（T0 $ 0。SVID，'TM9'，'NLS_Numeric_Characters =''。，'''）AS“id（v1）$ V”，T0 $ 0。SVID为“id（v1）$ VN”，to_timestamp_tz（null）AS“id（v1）$ VT”，7 AS“id（v4）$ T”，to_nchar（T0 $ 2。DVID，'TM9'，'NLS_Numeric_Characters =''。，'''）AS“id（v4）$ V”，T0 $ 2。DVID AS“id（v4）$ VN”，to_timestamp_tz（null）AS“id（v4）$ VT”FROM“SCOTT”。GRAPH1GT $ T0 $ 0，“SCOTT”。GRAPH1GT $ T0 $ 1，“SCOTT”。GRAPH1GT $ T0 $ 2 WHERE T0 $ 0。DVID = T0 $ 1SVID和T0 $ 1。DVID = T0港币$ 16。SVID和（T0 $ 0。EL = n'friendOf'AND T0 $ 0。EL不是空）和（T0 $ 1。EL = n'friendOf'和T0 $ 1。EL不是空）和（T0 $ 2。EL = n'friendOf'和T0 $ 2。EL不是空的）</pre><p>使用ALL_EDGE_HASH的第一个查询的查询计划应类似于以下内容。</p><pre class="oac_no_warn" dir="ltr">------------------------------------------ | Id |操作|名称| ------------------------------------------ | 0 |选择声明| | | * 1 | HASH JOIN | | | 2 | PARTITION HASH ALL | | | * 3 |表访问完全| GRAPH1GT $ | | * 4 | HASH JOIN | | | 5 | PARTITION HASH ALL | | | * 6 |表访问完全| GRAPH1GT $ | | 7 | PARTITION HASH ALL | | | * 8 |表访问完全| GRAPH1GT $ | ------------------------------------------</pre><p>使用ALL_EDGE_NL的第二个查询的查询计划应类似于以下内容。</p><pre class="oac_no_warn" dir="ltr">------------------------------------------ | Id |操作|名称| ------------------------------------------ | 0 |选择声明| | | 1 | NESTED LOOPS | | | 2 | NESTED LOOPS | | | 3 | PARTITION HASH ALL | | | * 4 |表访问完全| GRAPH1GT $ | | 5 | PARTITION HASH ALL | | | * 6 |表访问完全| GRAPH1GT $ | | 7 | PARTITION HASH ALL | | | * 8 |表访问完全| GRAPH1GT $ | ------------------------------------------</pre></div>
                        <!-- class="example" -->
                     </div>
                     <div>
                        <div class="familylinks">
                           <div class="parentlink">
                              <p><strong>父主题：</strong> <a href="sql-based-property-graph-query-analytics.html#GUID-296732FE-D57B-41B5-937B-078E234422CC">使用oracle.pg.rdbms Java包执行PGQL查询</a></p>
                           </div>
                        </div>
                     </div>
                     
                  </div>
               </div>
               <div class="props_rev_3"><a id="GUID-BAD8CE60-CDF7-4FCF-987C-90658D78BDEA" name="GUID-BAD8CE60-CDF7-4FCF-987C-90658D78BDEA"></a><h4 id="SPGDG-GUID-BAD8CE60-CDF7-4FCF-987C-90658D78BDEA" class="sect4"><span class="enumeration_section">4.8.3</span> PGQL查询的性能注意事项</h4>
                  <div>
                     <p>许多因素会影响Oracle数据库中PGQL查询的性能。以下是一些推荐的查询性能实践。</p>
                     <ul style="list-style-type:disc">
                        <li>
                           <p><a href="sql-based-property-graph-query-analytics.html#GUID-BAD8CE60-CDF7-4FCF-987C-90658D78BDEA__QUERYOPTIMIZERSTATISTICS-2194DC83">查询优化器统计信息</a></p>
                        </li>
                        <li>
                           <p><a href="sql-based-property-graph-query-analytics.html#GUID-BAD8CE60-CDF7-4FCF-987C-90658D78BDEA__GTSKELETONTABLE-2197E2BC">GT $骷髅表</a></p>
                        </li>
                        <li>
                           <p><a href="sql-based-property-graph-query-analytics.html#GUID-BAD8CE60-CDF7-4FCF-987C-90658D78BDEA__PARALLELQUERYEXECUTION-2197EB29">并行查询执行</a></p>
                        </li>
                        <li>
                           <p><a href="sql-based-property-graph-query-analytics.html#GUID-BAD8CE60-CDF7-4FCF-987C-90658D78BDEA__OPTIMIZERDYNAMICSAMPLING-2197EE4E">优化器动态采样</a></p>
                        </li>
                        <li>
                           <p><a href="sql-based-property-graph-query-analytics.html#GUID-BAD8CE60-CDF7-4FCF-987C-90658D78BDEA__BINDVARIABLES-2197F1B6">绑定变量</a></p>
                        </li>
                        <li>
                           <p><a href="sql-based-property-graph-query-analytics.html#GUID-BAD8CE60-CDF7-4FCF-987C-90658D78BDEA__PATHQUERIES-2197F62C">路径查询</a></p>
                        </li>
                     </ul>
                     <div class="section" id="GUID-BAD8CE60-CDF7-4FCF-987C-90658D78BDEA__QUERYOPTIMIZERSTATISTICS-2194DC83">
                        <p class="subhead3" id="GUID-BAD8CE60-CDF7-4FCF-987C-90658D78BDEA__GUID-87F800CE-8910-4269-88C2-DBBE572DA3EC">查询优化器统计信息</p>
                        <p>良好，最新的查询优化器统计信息对于查询性能至关重要。确保在对属性图数据进行任何重大更新后运行<a href="OPG_APIS-reference.html#GUID-7B1D9A79-CFFA-46A1-AB96-F9E9AE1497D4">OPG_APIS.ANALYZE_PG</a> 。
                        </p>
                     </div>
                     <!-- class="section" -->
                     <div class="section" id="GUID-BAD8CE60-CDF7-4FCF-987C-90658D78BDEA__GTSKELETONTABLE-2197E2BC">
                        <p class="subhead3" id="GUID-BAD8CE60-CDF7-4FCF-987C-90658D78BDEA__GTSKELETONTABLE-2197E570">GT $骷髅表</p>
                        <p>如果没有填充GT $框架表，许多查询可能需要几种GE $ edge属性表来评估图遍历。只要有可能，您应该在运行PGQL查询之前填充GT $ skeleton表，以避免这些昂贵的排序操作。</p>
                     </div>
                     <!-- class="section" -->
                     <div class="section" id="GUID-BAD8CE60-CDF7-4FCF-987C-90658D78BDEA__PARALLELQUERYEXECUTION-2197EB29">
                        <p class="subhead3" id="GUID-BAD8CE60-CDF7-4FCF-987C-90658D78BDEA__PARALLELQUERYEXECUTION-2197EC8A">并行查询执行</p>
                        <p>使用并行查询执行来利用Oracle的并行SQL引擎。并行执行通常比串行执行提供显着的加速。对于使用递归WITH策略计算的路径查询，并行执行尤其重要。</p>
                        <p>有关并行查询执行的更多信息，另请参见“ <a href="../vldbg/using-parallel.html#VLDBG010" target="_blank"><span class="italic">Oracle数据库VLDB和分区指南”</span></a> 。
                        </p>
                     </div>
                     <!-- class="section" -->
                     <div class="section" id="GUID-BAD8CE60-CDF7-4FCF-987C-90658D78BDEA__OPTIMIZERDYNAMICSAMPLING-2197EE4E">
                        <p class="subhead3" id="GUID-BAD8CE60-CDF7-4FCF-987C-90658D78BDEA__OPTIMIZERDYNAMICSAMPLING-2197F03A">优化器动态采样</p>
                        <p>由于图数据模型固有的灵活性，静态信息可能并不总是产生最佳查询计划。在这种情况下，查询优化器可以使用动态采样在运行时对数据进行采样，以获得更好的查询计划。采样的数据量由使用的动态采样级别控制。动态采样级别范围为0到11。最佳使用级别取决于特定数据集和工作负载，但2级（默认），6或11级通常会产生良好结果。</p>
                        <p>另请参见“ <span class="italic">Oracle数据库SQL调优指南”</span>中的<a href="../tgsql/optimizer-statistics-concepts.html#TGSQL341" target="_blank">Supplemantal Dynamic Statistics</a> 。
                        </p>
                     </div>
                     <!-- class="section" -->
                     <div class="section" id="GUID-BAD8CE60-CDF7-4FCF-987C-90658D78BDEA__BINDVARIABLES-2197F1B6">
                        <p class="subhead3" id="GUID-BAD8CE60-CDF7-4FCF-987C-90658D78BDEA__BINDVARIABLES-2197F44F">绑定变量</p>
                        <p>尽可能使用绑定变量作为常量。使用绑定变量可以极大地缩短查询编译时间，从而显着提高查询工作负载的吞吐量，查询只在使用的常量值中有所不同。此外，使用绑定变量的查询不太容易受到注入攻击。</p>
                     </div>
                     <!-- class="section" -->
                     <div class="section" id="GUID-BAD8CE60-CDF7-4FCF-987C-90658D78BDEA__PATHQUERIES-2197F62C">
                        <p class="subhead3" id="GUID-BAD8CE60-CDF7-4FCF-987C-90658D78BDEA__PATHQUERIES-2197F90B">路径查询</p>
                        <p>PGQL中使用<code class="codeph">+</code> （加号）或<code class="codeph">*</code> （星号）运算符搜索任意长度路径的路径查询由于其高计算复杂性而需要特别考虑。您应该使用并行执行并使用DISTINCT选项进行递归WITH（USE_DIST_RW = T）以获得最佳性能。此外，对于大型高度连接的图形，最好使用MAX_PATH_LEN = <span class="italic">n</span>将递归步骤的重复次数限制为合理的数量。一个好的策略可以从一个小的重复限制开始，并迭代地增加限制以找到越来越多的结果。
                        </p>
                     </div>
                     <!-- class="section" -->
                  </div>
                  <div>
                     <div class="familylinks">
                        <div class="parentlink">
                           <p><strong>父主题：</strong> <a href="sql-based-property-graph-query-analytics.html#GUID-94F08780-EC3D-4F9B-985F-49984939E61C" title="本主题说明如何直接对Oracle数据库中的图形执行PGQL查询（而不是内存中）。">直接针对Oracle数据库执行PGQL查询</a></p>
                        </div>
                     </div>
                  </div>
                  
               </div>
            </div>
         </div>
      </article>
   </body>
</html>