<html lang="en-us" dir="ltr" xml:lang="en-us">
   <head>
      <meta http-equiv="Content-Type" content="text/html; charset=utf-8"></meta>
      <meta name="viewport" content="width=device-width, initial-scale=1"></meta>
      <meta http-equiv="X-UA-Compatible" content="IE=edge"></meta>
      <title>用于分析和报告的SQL</title>
      <meta property="og:site_name" content="Oracle Help Center"></meta>
      <meta property="og:title" content="Data Warehousing Guide"></meta>
      <meta property="og:description" content=""></meta>
      <link rel="stylesheet" href="/sp_common/book-template/ohc-book-template/css/book.css"></link>
      <link rel="shortcut icon" href="/sp_common/book-template/ohc-common/img/favicon.ico"></link>
      <meta name="application-name" content="Data Warehousing Guide"></meta>
      <meta name="generator" content="DITA Open Toolkit version 1.8.5 (Mode = doc)"></meta>
      <meta name="plugin" content="SP_docbuilder HTML plugin release 18.2.2"></meta>
      <link rel="alternate" href="database-data-warehousing-guide.pdf" title="PDF File" type="application/pdf"></link>
      <meta name="robots" content="all"></meta>
      <link rel="schema.dcterms" href="http://purl.org/dc/terms/"></link>
      <meta name="dcterms.created" content="2019-01-09T00:20:13-08:00"></meta>
      
      <meta name="dcterms.dateCopyrighted" content="2001, 2019"></meta>
      <meta name="dcterms.category" content="database"></meta>
      <meta name="dcterms.identifier" content="E96243-01"></meta>
      
      <meta name="dcterms.product" content="en/database/oracle/oracle-database/19"></meta>
      
      <link rel="prev" href="part-relational-analytics.html" title="Previous" type="text/html"></link>
      <link rel="next" href="sql-aggregation-data-warehouses.html" title="Next" type="text/html"></link>
      <script>
        document.write('<style type="text/css">');
        document.write('body > .noscript, body > .noscript ~ * { visibility: hidden; }');
        document.write('</style>');
     </script>
      <script src="/sp_common/book-template/requirejs/require.js" data-main="/sp_common/book-template/ohc-book-template/js/book-config"></script>
      <script>
            if (window.require === undefined) {
                document.write('<script data-main="sp_common/book-template/ohc-book-template/js/book-config" src="sp_common/book-template/requirejs/require.js"><\/script>');
                document.write('<link href="sp_common/book-template/ohc-book-template/css/book.css" rel="stylesheet"/>');
            }
        </script>
      <script type="application/json" id="ssot-metadata">{"primary":{"category":{"short_name":"database","element_name":"Database","display_in_url":true},"suite":{"short_name":"oracle","element_name":"Oracle","display_in_url":true},"product_group":{"short_name":"not-applicable","element_name":"Not applicable","display_in_url":false},"product":{"short_name":"oracle-database","element_name":"Oracle Database","display_in_url":true},"release":{"short_name":"19","element_name":"Release 19","display_in_url":true}}}</script>
      
    <meta name="dcterms.title" content="Database Data Warehousing Guide"></meta>
    <meta name="dcterms.isVersionOf" content="DWHSG"></meta>
    <meta name="dcterms.release" content="Release 19"></meta>
  </head>
   <body dir="ltr">
      <div class="noscript alert alert-danger text-center" role="alert">
         <a href="part-relational-analytics.html" class="pull-left"><span class="glyphicon glyphicon-chevron-left" aria-hidden="true"></span>上一页</a> <a href="sql-aggregation-data-warehouses.html" class="pull-right">下一页<span class="glyphicon glyphicon-chevron-right" aria-hidden="true"></span></a> <span class="fa fa-exclamation-triangle" aria-hidden="true"></span>必须启用JavaScript才能正确显示此内容</div>
      <article>
         <header>
            <ol class="breadcrumb" vocab="http://schema.org/" typeof="BreadcrumbList">
               <li property="itemListElement" typeof="ListItem"><a href="index.html" property="item" typeof="WebPage"><span property="name">数据仓库指南</span></a></li>
               <li property="itemListElement" typeof="ListItem"><a href="part-relational-analytics.html" property="item" typeof="WebPage"><span property="name">关系分析</span></a></li>
               <li class="active" property="itemListElement" typeof="ListItem">用于分析和报告的SQL</li>
            </ol>
            <a id="GUID-20EFBF1E-F79D-4E4A-906C-6E496EECA684" name="GUID-20EFBF1E-F79D-4E4A-906C-6E496EECA684"></a>
            
            <h2 id="DWHSG-GUID-20EFBF1E-F79D-4E4A-906C-6E496EECA684" class="sect2"><span class="enumeration_chapter">19</span>用于分析和报告的SQL</h2>
         </header>
         <div class="ind">
            <div>
               <p>以下主题提供有关Oracle中分析SQL功能和技术的信息。虽然这些主题是以数据仓库的形式呈现的，但它们适用于任何需要分析和报告的活动。</p>
               <ul style="list-style-type:disc">
                  <li>
                     <p><a href="sql-analysis-reporting-data-warehouses.html#GUID-B2D2866D-F7B6-4234-8D10-24EC71270D9D">用于分析和报告的SQL概述</a></p>
                  </li>
                  <li>
                     <p><a href="sql-analysis-reporting-data-warehouses.html#GUID-64CE26C0-43A0-4733-ADF6-7C0F186C6F64">排名，窗口和报告功能</a></p>
                  </li>
                  <li>
                     <p><a href="sql-analysis-reporting-data-warehouses.html#GUID-7070D54B-AB82-4FDC-8A38-28D6F4CA5525" title="使用返回近似结果的SQL函数计算近似聚合。它们主要用于数据探索查询，其中不需要精确值，并且可以接受近似值。LISTAGG函数根据ORDER BY子句对每个组中的数据进行排序，然后连接度量列的值。Oracle数据库提供了一组返回近似百分位数结果的SQL函数。这些功能可用于监控质量，跟踪社交媒体活动，监控性能以及搜索数据集中的异常值。">用于分析的高级聚合</a></p>
                  </li>
                  <li>
                     <p><a href="sql-analysis-reporting-data-warehouses.html#GUID-05BB22CD-0F53-4C90-AE84-CE3F88DBD591">透视操作</a></p>
                  </li>
                  <li>
                     <p><a href="sql-analysis-reporting-data-warehouses.html#GUID-01B5DD6F-C039-4223-B017-263F7788C4FA">报告的数据密集化</a></p>
                  </li>
                  <li>
                     <p><a href="sql-analysis-reporting-data-warehouses.html#GUID-759F5F20-D45B-443F-9464-E71A4B70AF1B">密集数据的时间序列计算</a></p>
                  </li>
                  <li>
                     <p><a href="sql-analysis-reporting-data-warehouses.html#GUID-2F10D9C8-C6D6-47F2-9DDF-4146539655F3">杂项分析和报告功能</a></p>
                  </li>
                  <li>
                     <p><a href="sql-analysis-reporting-data-warehouses.html#GUID-3412F450-D7EB-4DC8-8888-60CABF592AD4">限制SQL行</a></p>
                  </li>
               </ul>
            </div><a id="DWHSG8660"></a><a id="DWHSG8661"></a><a id="DWHSG8662"></a><a id="DWHSG8659"></a><div class="props_rev_3"><a id="GUID-B2D2866D-F7B6-4234-8D10-24EC71270D9D" name="GUID-B2D2866D-F7B6-4234-8D10-24EC71270D9D"></a><h3 id="DWHSG-GUID-B2D2866D-F7B6-4234-8D10-24EC71270D9D" class="sect3"><span class="enumeration_section">19.1</span>用于分析和报告的SQL概述</h3>
               <div>
                  <p>Oracle数据库提供了大量分析SQL函数。这些分析函数使您能够计算：</p>
                  <ul style="list-style-type:disc">
                     <li>
                        <p>排名和百分位数</p>
                     </li>
                     <li>
                        <p>移动窗口计算</p>
                     </li>
                     <li>
                        <p>滞后/线索分析</p>
                     </li>
                     <li>
                        <p>第一个/最后一个分析</p>
                     </li>
                     <li>
                        <p>线性回归统计</p>
                     </li>
                  </ul>
                  <p>排名函数包括累积分布，百分比排名和N-tiles。移动窗口计算允许您查找移动和累积聚合，例如总和和平均值。延迟/线索分析可实现直接行间引用，因此您可以计算周期间变化。通过第一个/最后一个分析，您可以查找有序组中的第一个或最后一个值。</p>
                  <p>其他对分析和报告有价值的SQL元素包括<code class="codeph">CASE</code>表达式和分区外连接。<code class="codeph">CASE</code>表达式在许多情况下提供if-then逻辑。分区外连接是ANSI外连接语法的变体，允许用户选择性地加密某些维度，同时保持其他维度稀疏。这允许报告工具有选择地加密尺寸，例如，在其交叉表格报告中出现的尺寸，同时保持其他尺寸稀疏。
                  </p>
                  <p>为了提高性能，可以并行化分析函数：多个进程可以同时执行所有这些语句。这些功能使计算更容易，更高效，从而提高了数据库性能，可扩展性和简单性。</p>
                  <p>分析函数分类如<a href="sql-analysis-reporting-data-warehouses.html#GUID-B2D2866D-F7B6-4234-8D10-24EC71270D9D__GUID-78CBF9F4-47A8-4D1F-BB4B-0078C78BFDAB" title="分析函数及其用途">表19-1中所述</a> 。
                  </p>
                  <div class="tblformal" id="GUID-B2D2866D-F7B6-4234-8D10-24EC71270D9D__GUID-78CBF9F4-47A8-4D1F-BB4B-0078C78BFDAB">
                     <p class="titleintable">表19-1 <span class="italic" id="GUID-B2D2866D-F7B6-4234-8D10-24EC71270D9D__I1014372"><span class="bold">分析函数及其用途</span></span></p>
                     <table cellpadding="4" cellspacing="0" class="Formal" title="分析函数及其用途" width="100%" border="1" summary="Analytic Functions and Their Uses" frame="hsides" rules="rows">
                        <thead>
                           <tr align="left" valign="top">
                              <th align="left" valign="bottom" width="20%" id="d65966e143">类型</th>
                              <th align="left" valign="bottom" width="80%" id="d65966e146">用于</th>
                           </tr>
                        </thead>
                        <tbody>
                           <tr align="left" valign="top">
                              <td align="left" valign="top" width="20%" id="d65966e151" headers="d65966e143 ">
                                 <p>排行</p>
                              </td>
                              <td align="left" valign="top" width="80%" headers="d65966e151 d65966e146 ">
                                 <p>计算结果集中值的等级，百分位数和n-tiles。</p>
                              </td>
                           </tr>
                           <tr align="left" valign="top">
                              <td align="left" valign="top" width="20%" id="d65966e158" headers="d65966e143 ">
                                 <p>窗</p>
                              </td>
                              <td align="left" valign="top" width="80%" headers="d65966e158 d65966e146 ">
                                 <p>计算累积和移动聚合。使用这些函数： <code class="codeph">SUM</code> ， <code class="codeph">AVG</code> ， <code class="codeph">MIN</code> ， <code class="codeph">MAX</code> ， <code class="codeph">COUNT</code> ， <code class="codeph">VARIANCE</code> ， <code class="codeph">STDDEV</code> ， <code class="codeph">FIRST_VALUE</code> ， <code class="codeph">LAST_VALUE</code>和新的统计函数。请注意，窗口函数不支持<code class="codeph">DISTINCT</code>关键字， <code class="codeph">MAX</code>和<code class="codeph">MIN</code>除外。</p>
                              </td>
                           </tr>
                           <tr align="left" valign="top">
                              <td align="left" valign="top" width="20%" id="d65966e203" headers="d65966e143 ">
                                 <p>报告</p>
                              </td>
                              <td align="left" valign="top" width="80%" headers="d65966e203 d65966e146 ">
                                 <p>计算股票，例如市场份额。使用这些函数： <code class="codeph">SUM</code> ， <code class="codeph">AVG</code> ， <code class="codeph">MIN</code> ， <code class="codeph">MAX</code> ， <code class="codeph">COUNT</code> （带/不带<code class="codeph">DISTINCT</code> ）， <code class="codeph">VARIANCE</code> ， <code class="codeph">STDDEV</code> ， <code class="codeph">RATIO_TO_REPORT</code>和新的统计函数。请注意， <code class="codeph">DISTINCT</code>关键字可用于那些在聚合模式下支持<code class="codeph">DISTINCT</code>报告功能。
                                 </p>
                              </td>
                           </tr>
                           <tr align="left" valign="top">
                              <td align="left" valign="top" width="20%" id="d65966e244" headers="d65966e143 ">
                                 <p><code class="codeph">LAG</code> / <code class="codeph">LEAD</code></p>
                              </td>
                              <td align="left" valign="top" width="80%" headers="d65966e244 d65966e146 ">
                                 <p>在一行中查找当前行中指定行数的值。</p>
                              </td>
                           </tr>
                           <tr align="left" valign="top">
                              <td align="left" valign="top" width="20%" id="d65966e255" headers="d65966e143 ">
                                 <p><code class="codeph">FIRST</code> / <code class="codeph">LAST</code></p>
                              </td>
                              <td align="left" valign="top" width="80%" headers="d65966e255 d65966e146 ">
                                 <p>有序组中的第一个或最后一个值。</p>
                              </td>
                           </tr>
                           <tr align="left" valign="top">
                              <td align="left" valign="top" width="20%" id="d65966e266" headers="d65966e143 ">
                                 <p>线性回归</p>
                              </td>
                              <td align="left" valign="top" width="80%" headers="d65966e266 d65966e146 ">
                                 <p>计算线性回归和其他统计数据（斜率，截距等）。</p>
                              </td>
                           </tr>
                           <tr align="left" valign="top">
                              <td align="left" valign="top" width="20%" id="d65966e273" headers="d65966e143 ">
                                 <p>反百分位数</p>
                              </td>
                              <td align="left" valign="top" width="80%" headers="d65966e273 d65966e146 ">
                                 <p>数据集中与指定百分位数对应的值。</p>
                              </td>
                           </tr>
                           <tr align="left" valign="top">
                              <td align="left" valign="top" width="20%" id="d65966e280" headers="d65966e143 ">
                                 <p>假设排名和分布</p>
                              </td>
                              <td align="left" valign="top" width="80%" headers="d65966e280 d65966e146 ">
                                 <p>插入到指定数据集中的行所具有的等级或百分位数。</p>
                              </td>
                           </tr>
                        </tbody>
                     </table>
                  </div>
                  <!-- class="inftblhruleinformal" -->
                  <p>要执行这些操作，分析函数会向SQL处理添加几个新元素。这些元素构建在现有SQL上，以允许灵活而强大的计算表达式。除了少数例外，分析函数具有这些附加元素。处理流程<a href="sql-analysis-reporting-data-warehouses.html#GUID-B2D2866D-F7B6-4234-8D10-24EC71270D9D__I1014377">如图19-1所示</a> 。
                  </p>
                  <div class="figure" id="GUID-B2D2866D-F7B6-4234-8D10-24EC71270D9D__I1014377">
                     <p class="titleinfigure">图19-1处理顺序</p><img src="img/dwhsg021.gif" alt="下面是图19-1的描述" title="下面是图19-1的描述" longdesc="img_text/dwhsg021.html"><br><a href="img_text/dwhsg021.html">“图19-1处理顺序”的描述</a></div>
                  <!-- class="figure" -->
                  <p>重要的<a id="d65966e297" class="indexterm-anchor"></a>分析函数中使用的概念是：</p>
                  <ul style="list-style-type:disc">
                     <li>
                        <p>处理订单</p>
                        <p>使用分析函数的查询处理分三个阶段进行。首先，执行所有连接， <code class="codeph">WHERE</code> ， <code class="codeph">GROUP</code> <code class="codeph">BY</code>和<code class="codeph">HAVING</code>子句。其次，结果集可用于分析函数，并进行所有计算。第三，如果查询的末尾有<code class="codeph">ORDER</code> <code class="codeph">BY</code>子句，则处理<code class="codeph">ORDER</code> <code class="codeph">BY</code>以允许精确的输出排序。处理顺序<a href="sql-analysis-reporting-data-warehouses.html#GUID-B2D2866D-F7B6-4234-8D10-24EC71270D9D__I1014377">如图19-1</a>所示。
                        </p>
                     </li>
                     <li>
                        <p>结果集分区</p>
                        <p>分析函数允许用户将查询结果集划分为称为分区的行组。请注意，与分析函数一起使用的术语<span class="bold">分区</span>与表分区功能无关。在本章中，术语分区仅指与分析函数相关的含义。分区是在使用<code class="codeph">GROUP</code> <code class="codeph">BY</code>子句定义的组之后创建的，因此它们可用于任何聚合结果，例如总和和平均值。分区划分可以基于任何期望的列或表达。查询结果集可以被划分为仅包含所有行的一个分区，几个大分区或者每个仅包含几行的许多小分区。
                        </p>
                     </li>
                     <li>
                        <p>窗口</p>
                        <p>对于分区中的每一行，您可以定义数据的滑动窗口。此窗口确定用于执行当前行计算的行范围。窗口大小可以基于物理行数或逻辑间隔（例如时间）。窗口有一个起始行和一个结束行。根据其定义，窗口可以在一端或两端移动。例如，为累积和函数定义的窗口将其起始行固定在其分区的第一行，并且其结束行将从起始点一直滑动到分区的最后一行。相反，为移动平均线定义的窗口将使其起点和终点都滑动，以便它们保持恒定的物理或逻辑范围。</p>
                        <p>窗口可以设置为分区中的所有行，也可以设置为分区中一行的滑动窗口。当窗口靠近边框时，该函数仅返回可用行的结果，而不是警告您结果不是您想要的结果。</p>
                        <p>使用窗口函数时，当前行包含在计算过程中，因此您只应在处理<span class="italic">n个</span>项目时指定（ <span class="italic">n</span> -1）。
                        </p>
                     </li>
                     <li>
                        <p>当前行</p>
                        <p>使用分析函数执行的每个计算都基于分区中的当前行。当前行用作确定窗口开始和结束的参考点。例如，可以使用保存当前行，前六行和后六行的窗口来定义居中移动平均值计算。这将创建一个13行的滑动窗口， <a href="sql-analysis-reporting-data-warehouses.html#GUID-B2D2866D-F7B6-4234-8D10-24EC71270D9D__I1006330">如图19-2</a>所示。
                        </p>
                     </li>
                  </ul>
                  <div class="figure" id="GUID-B2D2866D-F7B6-4234-8D10-24EC71270D9D__I1006330">
                     <p class="titleinfigure">图19-2滑动窗口示例</p><img src="img/dwhsg022.gif" alt="下面是图19-2的描述" title="下面是图19-2的描述" longdesc="img_text/dwhsg022.html"><br><a href="img_text/dwhsg022.html">“图19-2滑动窗口示例”的描述</a></div>
                  <!-- class="figure" -->
               </div>
            </div><a id="DWHSG0201"></a><div class="props_rev_3"><a id="GUID-64CE26C0-43A0-4733-ADF6-7C0F186C6F64" name="GUID-64CE26C0-43A0-4733-ADF6-7C0F186C6F64"></a><h3 id="DWHSG-GUID-64CE26C0-43A0-4733-ADF6-7C0F186C6F64" class="sect3"><span class="enumeration_section">19.2</span>排名，窗口和报告功能</h3>
               <div>
                  <p>本节说明了排名，窗口和报告的基本分析功能。它包含以下主题：</p>
                  <ul style="list-style-type:disc">
                     <li>
                        <p><a href="sql-analysis-reporting-data-warehouses.html#GUID-130370E5-9F75-42C5-9BC5-EEFF71C18F09">排名功能</a></p>
                     </li>
                     <li>
                        <p><a href="sql-analysis-reporting-data-warehouses.html#GUID-2877E1A5-9F11-47F1-A5ED-D7D5C7DED90A">窗口函数</a></p>
                     </li>
                     <li>
                        <p><a href="sql-analysis-reporting-data-warehouses.html#GUID-C934D977-6661-4697-8CB8-5ED82DB72E5A">报告功能</a></p>
                     </li>
                     <li>
                        <p><a href="sql-analysis-reporting-data-warehouses.html#GUID-4A7CC941-78D4-4A1C-98EC-DA548E1FD394">LAG / LEAD功能</a></p>
                     </li>
                     <li>
                        <p><a href="sql-analysis-reporting-data-warehouses.html#GUID-B1E8AB97-FFF6-4C5A-BB3C-D54780536C86">FIRST_VALUE_ LAST_VALUE_和NTH_VALUE函数</a></p>
                     </li>
                  </ul>
               </div><a id="DWHSG8663"></a><div class="props_rev_3"><a id="GUID-130370E5-9F75-42C5-9BC5-EEFF71C18F09" name="GUID-130370E5-9F75-42C5-9BC5-EEFF71C18F09"></a><h4 id="DWHSG-GUID-130370E5-9F75-42C5-9BC5-EEFF71C18F09" class="sect4"><span class="enumeration_section">19.2.1</span>排名函数</h4>
                  <div>
                     <p><a id="d65966e446" class="indexterm-anchor"></a><a id="d65966e450" class="indexterm-anchor"></a>排名函数基于一组度量的值来计算与数据集中的其他记录相比的记录的等级。排名功能的类型是：</p>
                     <ul style="list-style-type:disc">
                        <li>
                           <p><a href="sql-analysis-reporting-data-warehouses.html#GUID-1D8E3429-735B-409C-BD16-54004964D89B">RANK和DENSE_RANK函数</a></p>
                        </li>
                        <li>
                           <p><a href="sql-analysis-reporting-data-warehouses.html#GUID-42E2699D-F7C5-4D99-8224-154F3A892633">底部N排名函数</a></p>
                        </li>
                        <li>
                           <p><a href="sql-analysis-reporting-data-warehouses.html#GUID-D79F0C6D-74B6-4EC6-9612-4D3ACB6DED43">CUME_DIST功能</a></p>
                        </li>
                        <li>
                           <p><a href="sql-analysis-reporting-data-warehouses.html#GUID-76DD07EA-4C7D-496C-8567-42781568AEE5">PERCENT_RANK函数</a></p>
                        </li>
                        <li>
                           <p><a href="sql-analysis-reporting-data-warehouses.html#GUID-E1759E5F-4349-4092-BD4C-52238E400AF0">NTILE功能</a></p>
                        </li>
                        <li>
                           <p><a href="sql-analysis-reporting-data-warehouses.html#GUID-9003C56A-2B70-4E26-BCC1-ACF623FAE13E">ROW_NUMBER函数</a></p>
                        </li>
                     </ul>
                  </div><a id="DWHSG8664"></a><div class="props_rev_3"><a id="GUID-1D8E3429-735B-409C-BD16-54004964D89B" name="GUID-1D8E3429-735B-409C-BD16-54004964D89B"></a><h5 id="DWHSG-GUID-1D8E3429-735B-409C-BD16-54004964D89B" class="sect5"><span class="enumeration_section">19.2.1.1</span> RANK和DENSE_RANK函数</h5>
                     <div>
                        <div class="section">
                           <p><a id="d65966e506" class="indexterm-anchor"></a><a id="d65966e508" class="indexterm-anchor"></a><a id="d65966e510" class="indexterm-anchor"></a><a id="d65966e514" class="indexterm-anchor"></a> <code class="codeph">RANK</code>和<code class="codeph">DENSE_RANK</code>功能允许您对组中的项目进行排名，例如，查找去年在加利福尼亚销售的前三种产品。执行排名有两个函数，如以下语法所示：</p><pre class="oac_no_warn" dir="ltr">RANK（）OVER（[query_partition_clause] order_by_clause）DENSE_RANK（）OVER（[query_partition_clause] order_by_clause）</pre><p><code class="codeph">RANK</code>和<code class="codeph">DENSE_RANK</code>之间的区别在于，当存在关联时， <code class="codeph">DENSE_RANK</code>在排序顺序中不留下间隙。也就是说，如果你使用<code class="codeph">DENSE_RANK</code>对比赛进行排名并且有三个人<code class="codeph">DENSE_RANK</code>第二名，那么你会说三个人排在第二位，而下一个人排在第三位。<code class="codeph">RANK</code>功能也会让三个人排在第二位，但下一个人排在第五位。
                           </p>
                           <p>以下是关于<code class="codeph">RANK</code>一些相关观点：</p>
                           <ul style="list-style-type:disc">
                              <li>
                                 <p>升序是默认排序顺序，您可能希望将其更改为降序。</p>
                              </li>
                              <li>
                                 <p>可选<code class="codeph">PARTITION</code> <code class="codeph">BY</code>子句中的表达式将查询结果集划分为<code class="codeph">RANK</code>函数运行的组。也就是说，只要组发生变化， <code class="codeph">RANK</code>就会重置。实际上， <code class="codeph">PARTITION</code> <code class="codeph">BY</code>子句的值表达式定义了重置边界。
                                 </p>
                              </li>
                              <li>
                                 <p>如果缺少<code class="codeph">PARTITION</code> <code class="codeph">BY</code>子句，则会在整个查询结果集上计算排名。
                                 </p>
                              </li>
                              <li>
                                 <p><code class="codeph">ORDER</code> <code class="codeph">BY</code>子句指定完成排名的度量（&lt; <code class="codeph">value</code> <code class="codeph">expression</code> &gt;），并定义行在每个组（或分区）中的排序顺序。一旦数据在每个分区内排序，就会从1开始给每行排名。
                                 </p>
                              </li>
                              <li>
                                 <p><code class="codeph">NULLS</code> <code class="codeph">FIRST</code> | <code class="codeph">NULLS</code> <code class="codeph">LAST</code>子句指示有序序列中<code class="codeph">NULLs</code>的位置，序列中的第一个或最后一个。序列的顺序将使<code class="codeph">NULLs</code>相对于非<code class="codeph">NULL</code>值比较高或低。如果序列按升序排列，那么<code class="codeph">NULLS</code> <code class="codeph">FIRST</code>意味着<code class="codeph">NULLs</code>小于所有其他非<code class="codeph">NULL</code>值， <code class="codeph">NULLS</code> <code class="codeph">LAST</code>意味着它们大于非<code class="codeph">NULL</code>值。降序排序相反。请参阅<span class="q">“ <a href="sql-analysis-reporting-data-warehouses.html#GUID-AFB87EF9-3BF0-4C29-B5C0-6C5F0561263C">示例：排序函数中的NULL处理</a> ”中的<a href="sql-analysis-reporting-data-warehouses.html#GUID-AFB87EF9-3BF0-4C29-B5C0-6C5F0561263C">示例</a></span> 。
                                 </p>
                              </li>
                              <li>
                                 <p>如果<code class="codeph">NULLS</code> <code class="codeph">FIRST</code> |省略了<code class="codeph">NULLS</code> <code class="codeph">LAST</code>子句，然后空值的排序取决于<code class="codeph">ASC</code>或<code class="codeph">DESC</code>参数。空值被认为大于任何其他值。如果排序顺序是<code class="codeph">ASC</code> ，则最后出现空值;否则将首先出现空值。空值被认为等于其他空值，因此，呈现空值的顺序是非确定性的。
                                 </p>
                              </li>
                           </ul>
                        </div>
                        <!-- class="section" -->
                     </div><a id="DWHSG8666"></a><a id="DWHSG8665"></a><div class="props_rev_3"><a id="GUID-35EB8A7E-04F3-4D0E-B550-B18CCEAB8590" name="GUID-35EB8A7E-04F3-4D0E-B550-B18CCEAB8590"></a><h6 id="DWHSG-GUID-35EB8A7E-04F3-4D0E-B550-B18CCEAB8590" class="sect6"><span class="enumeration_section">19.2.1.1.1</span> RANK和DENSE_RANK函数中的排序顺序</h6>
                        <div>
                           <div class="section">
                              <p>以下示例显示了<code class="codeph">[ASC | DESC]</code> RANK的<code class="codeph">[ASC | DESC]</code>选项改变了排名顺序。
                              </p>
                           </div>
                           <!-- class="section" -->
                           <div class="example" id="GUID-35EB8A7E-04F3-4D0E-B550-B18CCEAB8590__GUID-3C35A049-B98F-4BF0-86DA-C103988CB83F">
                              <p class="titleinexample">例19-1排名顺序</p><pre class="oac_no_warn" dir="ltr">SELECT channel_desc，TO_CHAR（SUM（amount_sold），'9,999,999,999'）SALES $，RANK（）OVER（ORDER BY SUM（amount_sold））AS default_rank，RANK（）OVER（ORDER BY SUM（amount_sold）DESC NULLS LAST）AS custom_rank FROM sales，products，customers，times，channels，countries WHERE sales.prod_id = products.prod_id AND sales.cust_id = customers.cust_id AND customers.country_id = countries.country_id AND sales.time_id = times.time_id AND sales.channel_id = channels。 channel_id AND times.calendar_month_desc IN（'2000-09'，'2000-10'）AND country_iso_code ='US'GROUP BY channel_desc; CHANNEL_DESC SALES $ DEFAULT_RANK CUSTOM_RANK -------------------- -------------- ----------- -  -----------直接销售1,320,497 3 1合作伙伴800,871 2 2互联网261,278 1 3</pre><p>虽然此结果中的数据按度量<code class="codeph">SALES$</code>排序，但一般而言， <code class="codeph">RANK</code>函数无法保证数据将按度量排序。如果希望在结果中的<code class="codeph">SALES$</code>上对数据进行排序，则必须在<code class="codeph">SELECT</code>语句的末尾使用<code class="codeph">ORDER</code> <code class="codeph">BY</code>子句显式指定它。
                              </p>
                           </div>
                           <!-- class="example" -->
                        </div>
                     </div><a id="DWHSG8668"></a><a id="DWHSG8667"></a><div class="props_rev_3"><a id="GUID-40784EB2-5A76-466A-A364-F19417DFBD7A" name="GUID-40784EB2-5A76-466A-A364-F19417DFBD7A"></a><h6 id="DWHSG-GUID-40784EB2-5A76-466A-A364-F19417DFBD7A" class="sect6"><span class="enumeration_section">19.2.1.1.2</span>多个表达式的排名</h6>
                        <div>
                           <div class="section">
                              <p>排名函数必须解决集合中值之间的联系。如果第一个表达式无法解析关系，则第二个表达式用于解析关系等。例如，这是一个查询，根据他们的美元销售情况，在两个月内对三个销售渠道进行排名，打破与单位销售的关系。（注意， <code class="codeph">TRUNC</code>函数仅用于为此查询创建tie值。）
                              </p>
                           </div>
                           <!-- class="section" -->
                           <div class="example" id="GUID-40784EB2-5A76-466A-A364-F19417DFBD7A__GUID-DD89B75F-DA9F-499E-9890-F415D288E662">
                              <p class="titleinexample">例19-2多个表达式的排名</p><pre class="oac_no_warn" dir="ltr">SELECT channel_desc，calendar_month_desc，TO_CHAR（TRUNC（SUM（amount_sold）， -  5），'9,999,999,999'）SALES $，TO_CHAR（SUM（quantity_sold），'9,999,999,999'）SALES_Count，RANK（）OVER（ORDER BY TRUNC（SUM（amount_sold） ），-5）DESC，SUM（quantity_sold）DESC）AS col_rank FROM销售，产品，客户，时间，渠道WHERE sales.prod_id = products.prod_id AND sales.cust_id = customers.cust_id AND sales.time_id = times.time_id AND sales.channel_id = channels.channel_id AND times.calendar_month_desc IN（'2000-09'，'2000-10'）AND channels.channel_desc &lt;&gt;'Tele Sales'GROUP BY channel_desc，calendar_month_desc; CHANNEL_DESC日历销售$ SALES_COUNT COL_RANK -------------------- -------- --------------- ------------ ---------直接销售2000-10 1,200,000 12,584 1直接销售2000-09 1,200,000 11,995 2合作伙伴2000-10 600,000 7,508 3合作伙伴2000-09 600,000 6,165 4 Internet 2000-09 200,000 1,887 5 Internet 2000-10 200,000 1,450 6</pre><p><code class="codeph">sales_count</code>列打破三对值的关系。
                              </p>
                              <p>如果您只想查看此查询的前五个结果，则可以添加<code class="codeph">ORDER</code> <code class="codeph">BY</code> <code class="codeph">COL_RANK</code> <code class="codeph">FETCH</code> <code class="codeph">FIRST</code> <code class="codeph">5</code> <code class="codeph">ROWS</code> <code class="codeph">ONLY</code>语句。有关详细信息，请参阅<span class="q">“ <a href="sql-analysis-reporting-data-warehouses.html#GUID-3412F450-D7EB-4DC8-8888-60CABF592AD4">限制SQL行</a> ”</span> 。
                              </p>
                           </div>
                           <!-- class="example" -->
                        </div>
                     </div><a id="DWHSG8670"></a><a id="DWHSG8669"></a><div class="props_rev_3"><a id="GUID-1E41897A-E0D6-42C1-B9EE-0657DE198BF4" name="GUID-1E41897A-E0D6-42C1-B9EE-0657DE198BF4"></a><h6 id="DWHSG-GUID-1E41897A-E0D6-42C1-B9EE-0657DE198BF4" class="sect6"><span class="enumeration_section">19.2.1.1.3</span>示例：RANK和DENSE_RANK之间的差异</h6>
                        <div>
                           <p><code class="codeph">RANK</code>和<code class="codeph">DENSE_RANK</code>函数之间的区别如<a href="sql-analysis-reporting-data-warehouses.html#GUID-1E41897A-E0D6-42C1-B9EE-0657DE198BF4__BCFCJCEA">例19-3所示</a> 。
                           </p>
                           <div class="example" id="GUID-1E41897A-E0D6-42C1-B9EE-0657DE198BF4__BCFCJCEA">
                              <p class="titleinexample">例19-3 RANK和DENSE_RANK</p><pre class="oac_no_warn" dir="ltr">SELECT channel_desc，calendar_month_desc，TO_CHAR（TRUNC（SUM（amount_sold）， -  5），'9,999,999,999'）SALES $，RANK（）OVER（ORTER BY TRUNC（SUM（amount_sold）， -  5）DESC）AS RANK，DENSE_RANK（） OVER（ORTER BY TRUNC（SUM（amount_sold）， -  5）DESC）AS DENSE_RANK来自销售，产品，客户，时间，渠道WHERE sales.prod_id = products.prod_id AND sales.cust_id = customers.cust_id AND sales.time_id = times .time_id AND sales.channel_id = channels.channel_id AND times.calendar_month_desc IN（'2000-09'，'2000-10'）AND channels.channel_desc &lt;&gt;'Tele Sales'GROUP BY channel_desc，calendar_month_desc; CHANNEL_DESC CALENDAR SALES $ RANK DENSE_RANK -------------------- -------- --------------- ------- ----------直销2000-09 1,200,000 1 1直接销售2000-10 1,200,000 1 1合作伙伴2000-09 600,000 3 2合作伙伴2000-10 600,000 3 2 Internet 2000- 09 200,000 5 3 Internet 2000-10 200,000 5 3</pre><p>注意，在<code class="codeph">DENSE_RANK</code>的情况下，最大秩值给出数据集中的不同值的数量。
                              </p>
                           </div>
                           <!-- class="example" -->
                        </div>
                     </div><a id="DWHSG8672"></a><a id="DWHSG8673"></a><a id="DWHSG8671"></a><div class="props_rev_3"><a id="GUID-D85A27E1-2515-4480-B7D1-883A144C3468" name="GUID-D85A27E1-2515-4480-B7D1-883A144C3468"></a><h6 id="DWHSG-GUID-D85A27E1-2515-4480-B7D1-883A144C3468" class="sect6"><span class="enumeration_section">19.2.1.1.4</span>组内排名：示例</h6>
                        <div>
                           <div class="section">
                              <p><code class="codeph">RANK</code>功能可以在组内操作，也就是说，只要组发生变化，就会重置秩。这是通过<code class="codeph">PARTITION</code> <code class="codeph">BY</code>子句完成的。<code class="codeph">PARTITION</code> <code class="codeph">BY</code>子句中的组表达式将数据集划分为<code class="codeph">RANK</code>操作的组。例如，要按每个渠道的美元销售额对产品进行排名，您可以发出以下声明。
                              </p>
                           </div>
                           <!-- class="section" -->
                           <div class="example" id="GUID-D85A27E1-2515-4480-B7D1-883A144C3468__GUID-21C56C7D-A2CB-403C-ACF5-E235D5783051">
                              <p class="titleinexample">例19-4每组排名例1</p><pre class="oac_no_warn" dir="ltr">SELECT channel_desc，calendar_month_desc，TO_CHAR（SUM（amount_sold），'9,999,999,999'）SALES $，RANK（）OVER（PARTITION BY channel_desc ORDER BY SUM（amount_sold）DESC）AS RANK_BY_CHANNEL FROM销售，产品，客户，时间，渠道WHERE销售。 prod_id = products.prod_id AND sales.cust_id = customers.cust_id AND sales.time_id = times.time_id AND sales.channel_id = channels.channel_id AND times.calendar_month_desc IN（'2000-08'，'2000-09'，'2000- 10'，'2000-11'）AND channels.channel_desc IN（'Direct Sales'，'Internet'）GROUP BY channel_desc，calendar_month_desc; CHANNEL_DESC CALENDAR SALES $ RANK_BY_CHANNEL -------------------- -------- -------------- --- ------------直销2000-08 1,236,104 1直销2000-10 1,225,584 2直接销售2000-09 1,217,808 3直销2000-11 1,115,239 4 Internet 2000-11 284,742 1 Internet 2000-10 239,236 2 Internet 2000-09 228,241 3 Internet 2000-08 215,107 4 8行选择。
</pre><p>单个查询块可以包含多个排名函数，每个排序函数将数据分成不同的组（即，在不同的边界上重置）。这些团体可以互相排斥。以下查询根据每个月内的美元销售额（ <code class="codeph">rank_of_product_per_region</code> ）和每个渠道（ <code class="codeph">rank_of_product_total</code> ）对产品进行排名。
                              </p>
                           </div>
                           <!-- class="example" -->
                           <div class="example" id="GUID-D85A27E1-2515-4480-B7D1-883A144C3468__GUID-39EB856D-533D-497B-8006-FE7B21C46F54">
                              <p class="titleinexample">例19-5每组排名例2</p><pre class="oac_no_warn" dir="ltr">SELECT channel_desc，calendar_month_desc，TO_CHAR（SUM（amount_sold），'9,999,999,999'）SALES $，RANK（）OVER（PARTITION BY calendar_month_desc ORDER BY SUM（amount_sold）DESC）AS RANK_WITHIN_MONTH，RANK（）OVER（PARTITION BY channel_desc ORDER BY SUM（ amount_sold）DESC）AS RANK_WITHIN_CHANNEL来自销售，产品，客户，时间，渠道，国家/地区WHERE sales.prod_id = products.prod_id AND sales.cust_id = customers.cust_id AND customers.country_id = countries.country_id AND sales.time_id = times.time_id AND sales.channel_id = channels.channel_id AND times.calendar_month_desc IN（'2000-08'，'2000-09'，'2000-10'，'2000-11'）AND channels.channel_desc IN（'Direct Sales'，'互联网'）GROUP BY channel_desc，calendar_month_desc; CHANNEL_DESC日历销售额$ RANK_WITHIN_MONTH RANK_WITHIN_CHANNEL ------------- -------- --------- -------------- --- -------------------直销2000-08 1,236,104 1 1 Internet 2000-08 215,107 2 4直销2000-09 1,217,808 1 3 Internet 2000-09 228,241 2 3直接销售2000-10 1,225,584 1 2 Internet 2000-10 239,236 2 2直接销售2000-11 1,115,239 1 4 Internet 2000-11 284,742 2 1</pre></div>
                           <!-- class="example" -->
                        </div>
                     </div><a id="DWHSG8674"></a><div class="props_rev_3"><a id="GUID-610A2C96-DC26-4C5F-9F66-9B4537ED3F5E" name="GUID-610A2C96-DC26-4C5F-9F66-9B4537ED3F5E"></a><h6 id="DWHSG-GUID-610A2C96-DC26-4C5F-9F66-9B4537ED3F5E" class="sect6"><span class="enumeration_section">19.2.1.1.5</span>示例：每个多维数据集和汇总组排名</h6>
                        <div>
                           <div class="section">
                              <p>例如，可以根据<code class="codeph">CUBE</code> ， <code class="codeph">ROLLUP</code>或<code class="codeph">GROUPING</code> <code class="codeph">SETS</code>运算符提供的分组重置分析函数<code class="codeph">RANK</code> 。将排名分配给由<code class="codeph">CUBE</code> ， <code class="codeph">ROLLUP</code>和<code class="codeph">GROUPING</code> <code class="codeph">SETS</code>查询创建的组很有用。有关<code class="codeph">GROUPING</code>函数的详细信息，请参阅<a href="sql-aggregation-data-warehouses.html#GUID-E051A04E-0C53-491D-9B16-B71BA00B80C2">SQL for Data Warehouses中的聚合</a> 。
                              </p>
                              <p>示例<code class="codeph">CUBE</code>和<code class="codeph">ROLLUP</code>查询如下：</p>
                              <p></p><pre class="pre codeblock"><code>SELECT channel_desc，country_iso_code，SUM（amount_sold）SALES $，RANK（）OVER（PARINGTION BY GROUPING_ID（channel_desc，country_iso_code）ORDER BY SUM（amount_sold）DESC）AS RANK_PER_GROUP FROM sales，customers，times，channels，countries WHERE sales.time_id = times.time_id AND sales.cust_id = customers.cust_id AND countries.country_id = customers.country_id AND sales.channel_id = channels.channel_id AND channels.channel_desc IN（'Direct Sales'，'Internet'）AND times.calendar_month_desc ='2000- 07'AND country_iso_code IN（'GB'，'US'，'JP'）GROUP BY cube（channel_desc，country_iso_code）; CHANNEL_DESC CO SALES $ RANK_PER_GROUP --------------  -  ------------- --------------直销US 616539.04 1直接销售GB 83869.96 2 Internet US 82595.71 3直接销售JP 79047.78 4 Internet JP 7103.39 5 Internet GB 6477.98 6直接销售779456.78 1 Internet 96177.08 2 US 699134.75 1 GB 90347.94 2 JP 86151.17 3 875633.86 1</code></pre></div>
                           <!-- class="section" -->
                        </div>
                     </div><a id="DWHSG8675"></a><div class="props_rev_3"><a id="GUID-AFB87EF9-3BF0-4C29-B5C0-6C5F0561263C" name="GUID-AFB87EF9-3BF0-4C29-B5C0-6C5F0561263C"></a><h6 id="DWHSG-GUID-AFB87EF9-3BF0-4C29-B5C0-6C5F0561263C" class="sect6"><span class="enumeration_section">19.2.1.1.6</span>示例：排序函数中NULL的处理</h6>
                        <div>
                           <div class="section">
                              <p><code class="codeph">NULLs</code>被视为普通值。此外，对于秩计算，假设<code class="codeph">NULL</code>值等于另一个<code class="codeph">NULL</code>值。取决于<code class="codeph">ASC</code> | <code class="codeph">DESC</code>选项提供了措施和<code class="codeph">NULLS</code> <code class="codeph">FIRST</code> | <code class="codeph">NULLS</code> <code class="codeph">LAST</code>子句， <code class="codeph">NULLs</code>将排序低或高，因此，适当地给予排名。以下示例显示了<code class="codeph">NULLs</code>在不同情况下的排名方式：</p><pre class="oac_no_warn" dir="ltr">SELECT times.time_id time，sold，RANK（）OVER（ORDER BY（已售出）DESC NULLS LAST）AS NLAST_DESC，RANK（）OVER（ORDER BY（已售出）DESC NULLS FIRST）AS NFIRST_DESC，RANK（）OVER（ORDER BY（ ASC NULLS FIRST）作为NFIRST，RANK（）OVER（订购者（已售出）ASC NULLS LAST）作为NLAST FROM（从销售，产品，客户，国家/地区销售的SELECT time_id，SUM（sales.amount_sold）WHERE sales.prod_id = products.prod_id AND customers.country_id = countries.country_id AND sales.cust_id = customers.cust_id AND prod_name IN（'Envoy Ambassador'，'Mouse Pad'）AND country_iso_code ='GB'GROUP BY time_id）v，次WHERE v.time_id （+）= times.time_id AND calendar_year = 1999 AND calendar_month_number = 1 ORDER BY已售出DESC NULLS LAST;时间卖出NLAST_DESC NFIRST_DESC NFIRST NLAST --------- ---------- ---------- ----------- ---- ------ ---------- 25-JAN-99 3097.32 1 18 31 14 17-JAN-99 1791.77 2 19 30 13 30-JAN-99 127.69 3 20 29 12 28-JAN- 99 120.34 4 21 28 11 23-JAN-99 86.12 5 22 27 10 20-JAN-99 79.07 6 23 26 9 13-JAN-99 56.1 7 24 25 8 07-JAN-99 42.97 8 25 24 7 08-JAN- 99 33.81 9 26 23 6 10-JAN-99 22.76 10 27 21 4 02-JAN-99 22.76 10 27 21 4 26-JAN-99 19.84 12 29 20 3 16-JAN-99 11.27 13 30 19 2 14-JAN- 99 9.52 14 31 18 1 09-JAN-99 15 1 1 15 12-JAN-99 15 1 1 15 31-JAN-99 15 1 1 15 11-JAN-99 15 1 1 15 19-JAN-99 15 1 1 15 03-JAN-99 15 1 1 15 15-JAN-99 15 1 1 15 21-JAN-99 15 1 1 15 24-JAN-99 15 1 1 15 04-JAN-99 15 1 1 15 06-JAN- 99 15 1 1 15 27-JAN-99 15 1 1 15 18-JAN-99 15 1 1 15 01-JAN-99 15 1 1 15 22-JAN-99 15 1 1 15 29-JAN-99 15 1 1 15 05-JAN-99 15 1 1 15</pre></div>
                           <!-- class="section" -->
                        </div>
                     </div>
                  </div>
                  <div class="sect4"><a id="GUID-9C786E96-2DA7-4430-BD9A-77C4C65854CF" name="GUID-9C786E96-2DA7-4430-BD9A-77C4C65854CF"></a><h5 id="DWHSG-GUID-9C786E96-2DA7-4430-BD9A-77C4C65854CF" class="sect5"><span class="enumeration_section">19.2.1.2</span> APPROX_RANK函数</h5>
                     <div>
                        <div class="section">
                           <p><code class="codeph">APPROX_RANK</code>函数返回一组值中的近似值。
                           </p>
                           <p>此函数采用可选的<code class="codeph">PARTITION BY</code>子句，后跟强制<code class="codeph">ORDER BY ...DESC</code>条款。<code class="codeph">PARTITION BY</code>键必须是<code class="codeph">GROUP BY</code>键的子集。<code class="codeph">ORDER BY</code>子句必须包含<code class="codeph">APPROX_COUNT</code>或<code class="codeph">APPROX_SUM</code> 。</p>
                           <p><code class="codeph">APPROX_RANK</code>函数具有以下语法：</p><pre class="pre codeblock"><code>SELECT expr_1 [，expr_2，... expr_j]，APPROX _ *（expr_k）agg_1 [，APPROX _ *（expr_l）agg_2 ...] FROM <span class="italic">table_name</span> WHERE ... GROUP BY expr_1 [，expr_2，... expr_j]具有APPROX_RANK（PARTITION BY partition_by_clause ORDER BY APPROX_ * （expr_k）DESC）&lt;= N1 [AND APPROX_RANK（PARTITION BY partition_by_clause ORDER BY APPROX _ *（expr_l）DESC）&lt;= N2 ...）];</code></pre><p>在以下示例中，查询返回每个部门的前10个总薪水中的作业。对于每份工作，还给出了总薪水和排名：</p><pre class="pre codeblock"><code>SELECT deptno，job，APPROX_SUM（sal），APPROX_RANK（PARTITION BY deptno ORDER BY APPROX_SUM（sal）DESC）rk FROM emp GROUP BY deptno，job具有APPROX_RANK（PAREDTION BY deptno ORDER BY APPROX_SUM（sal）DESC）&lt;= 10; DEPTNO JOB APPROX_SUM（SAL）RK ---------- --------- --------------- --------- -  10秘书1300 3 10经理2450 2 10总裁5000 1 20秘书1900 3 20经理2975 2 20分析师6000 1 30秘书950 3 30经理2850 2 30 SALESMAN 5600 1</code></pre><p>在下面的示例中，查询返回的工作在总薪水方面位居前2位，在按部门持有职位的员工数量方面排名前3位：</p><pre class="pre codeblock"><code>SELECT deptno，job，APPROX_SUM（sal），APPROX_COUNT（*）FROM emp GROUP BY deptno，作业具有APPROX_RANK（PAREDTION BY deptno ORDER BY APPROX_SUM（sal）DESC）&lt;= 2 AND APPROX_RANK（PAREDTION BY deptno ORDER BY APPROX_COUNT（*） DESC）&lt;= 3; DEPTNO JOB APPROX_SUM（SAL）APPROX_COUNT（*）---------- --------- --------------- ------ --------- 10 MANAGER 2450 1 10总统5000 1 20经理2975 1 20分析师6000 2 30经理2850 1 30 SALESMAN 5600 4</code></pre><p>以下示例使用<code class="codeph">MAX_ERROR</code>属性报告近似聚合的<code class="codeph">MAX_ERROR</code> ：</p><pre class="pre codeblock"><code>SELECT deptno，job，APPROX_SUM（sal）sum_sal，APPROX_SUM（sal，'MAX_ERROR'）sum_sal_err FROM emp GROUP BY deptno，job具有APPROX_RANK（PAREDTION BY deptno ORDER BY APPROX_SUM（sal）DESC）&lt;= 2; DEPTNO JOB SUM_SAL SUM_SAL_ERR ---------- --------- ---------- ----------- 10 MANAGER 2450 0 10总统5000 0 20 MANAGER 2975 0 20 ANALYST 6000 0 30 MANAGER 2850 0 30 SALESMAN 5600 0</code></pre><div class="infoboxnotealso" id="GUID-9C786E96-2DA7-4430-BD9A-77C4C65854CF__GUID-7FB9B89F-6829-4833-BE3A-37CCDC084C47">
                              <p class="notep1">也可以看看：</p>
                              <ul style="list-style-type:disc">
                                 <li>
                                    <p><a href="../sqlrf/APPROX_RANK.html#SQLRF-GUID-4F20978C-3188-4225-863D-0F7A25FD78FD" target="_blank"><span><cite>Oracle数据库SQL语言参考</cite></span></a></p>
                                 </li>
                              </ul>
                           </div>
                        </div>
                        <!-- class="section" -->
                     </div>
                  </div><a id="DWHSG8676"></a><div class="props_rev_3"><a id="GUID-42E2699D-F7C5-4D99-8224-154F3A892633" name="GUID-42E2699D-F7C5-4D99-8224-154F3A892633"></a><h5 id="DWHSG-GUID-42E2699D-F7C5-4D99-8224-154F3A892633" class="sect5"><span class="enumeration_section">19.2.1.3</span>底部N排名函数</h5>
                     <div>
                        <div class="section">
                           <p>除了排名表达式中的排序序列之外，底部N类似于顶部N.使用前面的示例，您可以命令<code class="codeph">SUM(s_amount)</code>升序而不是降序。
                           </p>
                        </div>
                        <!-- class="section" -->
                     </div>
                  </div><a id="DWHSG8677"></a><div class="props_rev_3"><a id="GUID-D79F0C6D-74B6-4EC6-9612-4D3ACB6DED43" name="GUID-D79F0C6D-74B6-4EC6-9612-4D3ACB6DED43"></a><h5 id="DWHSG-GUID-D79F0C6D-74B6-4EC6-9612-4D3ACB6DED43" class="sect5"><span class="enumeration_section">19.2.1.4</span> CUME_DIST函数</h5>
                     <div>
                        <div class="section">
                           <p><a id="d65966e1170" class="indexterm-anchor"></a><a id="d65966e1172" class="indexterm-anchor"></a> <code class="codeph">CUME_DIST</code>函数（在某些统计书籍中定义为百分位数的倒数）计算指定值相对于一组值的位置。订单可以是升序或降序。升序是默认值。<code class="codeph">CUME_DIST</code>的值范围是从大于0到1。要计算大小为N的集合S中值x的<code class="codeph">CUME_DIST</code> ，请使用以下公式：</p><pre class="oac_no_warn" dir="ltr">CUME_DIST（x）= S之前的值的数量，包括指定顺序中的x / N.</pre><p>它的语法是：</p><pre class="oac_no_warn" dir="ltr">CUME_DIST（）OVER（[query_partition_clause] order_by_clause）</pre><p><code class="codeph">CUME_DIST</code>函数中各种选项的语义类似于<code class="codeph">RANK</code>函数中的语义。默认顺序为升序，表示最低值获得最低<code class="codeph">CUME_DIST</code> （因为所有其他值的顺序都晚于此值）。<code class="codeph">NULLs</code>的处理方式与<code class="codeph">RANK</code>函数中的相同。它们被计入分子和分母，因为它们被视为非<code class="codeph">NULL</code>值。以下示例查找每个月内按渠道的销售累计分布：</p><pre class="oac_no_warn" dir="ltr">SELECT calendar_month_desc AS MONTH，channel_desc，TO_CHAR（SUM（amount_sold），'9,999,999,999'）SALES $，CUME_DIST（）OVER（PARTITION BY calendar_month_desc ORDER BY SUM（amount_sold））AS CUME_DIST_BY_CHANNEL FROM销售，产品，客户，时间，渠道销售额.prod_id = products.prod_id AND sales.cust_id = customers.cust_id AND sales.time_id = times.time_id AND sales.channel_id = channels.channel_id AND times.calendar_month_desc IN（'2000-09'，'2000-07'，'2000 -08'）GROUP BY calendar_month_desc，channel_desc; MONTH CHANNEL_DESC SALES $ CUME_DIST_BY_CHANNEL -------- -------------------- -------------- --- ----------------- 2000-07 Internet 140,423 .333333333 2000-07 Partners 611,064 .666666667 2000-07 Direct Sales 1,145,275 1 2000-08 Internet 215,107 .333333333 2000-08 Partners 661,045 .666666667 2000-08直接销售1,236,104 1 2000-09 Internet 228,241 .333333333 2000-09合作伙伴666,172 .666666667 2000-09直销1,217,808 1</pre></div>
                        <!-- class="section" -->
                     </div>
                  </div><a id="DWHSG8678"></a><div class="props_rev_3"><a id="GUID-76DD07EA-4C7D-496C-8567-42781568AEE5" name="GUID-76DD07EA-4C7D-496C-8567-42781568AEE5"></a><h5 id="DWHSG-GUID-76DD07EA-4C7D-496C-8567-42781568AEE5" class="sect5"><span class="enumeration_section">19.2.1.5</span> PERCENT_RANK函数</h5>
                     <div>
                        <div class="section">
                           <p><code class="codeph">PERCENT_RANK</code>类似于<code class="codeph">CUME_DIST</code> ，但它在分子中使用等级值而不是行计数。因此，它返回值相对于一组值的百分比排名。该功能在许多流行的电子表格中都可用。行的<code class="codeph">PERCENT_RANK</code>计算如下：</p><pre class="oac_no_warn" dir="ltr">（其分区中的行的等级 -  1）/（分区中的行数 -  1）</pre><p><code class="codeph">PERCENT_RANK</code>返回0到1范围内的值。等级为1的行的<code class="codeph">PERCENT_RANK</code>为零。它的语法是：</p><pre class="oac_no_warn" dir="ltr">PERCENT_RANK（）OVER（[query_partition_clause] order_by_clause）</pre></div>
                        <!-- class="section" -->
                     </div>
                  </div><a id="DWHSG8679"></a><div class="props_rev_3"><a id="GUID-E1759E5F-4349-4092-BD4C-52238E400AF0" name="GUID-E1759E5F-4349-4092-BD4C-52238E400AF0"></a><h5 id="DWHSG-GUID-E1759E5F-4349-4092-BD4C-52238E400AF0" class="sect5"><span class="enumeration_section">19.2.1.6</span> NTILE功能</h5>
                     <div>
                        <div class="section">
                           <p><code class="codeph">NTILE</code>允许轻松计算三分位数，四分位数，十分位数和其他常见的汇总统计数据。此函数将有序分区划分为指定数量的称为<span class="bold">存储桶</span>的组，并为分区中的每一行分配存储桶编号。<code class="codeph">NTILE</code>是一个非常有用的计算，因为它允许用户将数据集划分为四分之三，三分和其他分组。
                           </p>
                           <p>计算存储桶以使每个存储桶具有与其分配的行数完全相同的行数，或者最多比其他存储桶多1行。例如，如果一个分区中有100行，并且要求带有四个桶的<code class="codeph">NTILE</code>函数，则25行将被赋值为1，25行将具有值2，依此类推。这些铲斗称为等高铲斗。
                           </p>
                           <p>如果分区中的行数没有均匀地（没有余数）划分为桶的数量，则为每个桶分配的行数最多相差一个。额外的行将从最低的桶号开始为每个桶分配一个。例如，如果分区中有103行具有<code class="codeph">NTILE(5)</code>功能，则前21行将在第一个桶中，下一个21在第二个桶中，下一个21在第三个桶中，下一个20在第四个桶中，最后20个在第五个桶中。
                           </p>
                           <p><code class="codeph">NTILE</code>函数具有以下语法：</p><pre class="oac_no_warn" dir="ltr">NTILE（expr）OVER（[query_partition_clause] order_by_clause）</pre><p>在此， <code class="codeph">NTILE(N)</code>中的<code class="codeph">NTILE(N)</code>可以是常数（例如，5）或表达式。
                           </p>
                           <p>此函数与<code class="codeph">RANK</code>和<code class="codeph">CUME_DIST</code> ，每组计算都有一个<code class="codeph">PARTITION</code> <code class="codeph">BY</code>子句，一个用于指定度量及其排序顺序的<code class="codeph">ORDER</code> <code class="codeph">BY</code>子句，以及<code class="codeph">NULLS</code> <code class="codeph">FIRST</code> | <code class="codeph">NULLS</code> <code class="codeph">LAST</code>子句的具体处理<code class="codeph">NULLs</code> 。例如，以下是将每个月的销售总额分配到四个存储桶之一的示例：</p><pre class="oac_no_warn" dir="ltr">SELECT calendar_month_desc AS MONTH，TO_CHAR（SUM（amount_sold），'9,999,999,999'）SALES $，NTILE（4）OVER（ORDER BY SUM（amount_sold））AS TILE4 FROM销售，产品，客户，时间，渠道WHERE sales.prod_id =产品.prod_id AND sales.cust_id = customers.cust_id AND sales.time_id = times.time_id AND sales.channel_id = channels.channel_id AND times.calendar_year = 2000 AND prod_category ='Electronics'GROUP BY calendar_month_desc; MONTH SALES $ TILE4 -------- -------------- ---------- 2000-02 242,416 1 2000-01 257,286 1 2000-03 280,011 1 2000-06 315,951 2 2000-05 316,824 2 2000-04 318,106 2 2000-07 433,824 3 2000-08 477,833 3 2000-12 553,534 3 2000-10 652,225 4 2000-11 661,147 4 2000-09 691,449 4</pre><p>必须完全指定<code class="codeph">NTILE</code> <code class="codeph">ORDER</code> <code class="codeph">BY</code>语句才能产生可重现的结果。相等的值可以分布在相邻的桶中。要确保确定性结果，您必须使用唯一键进行排序。
                           </p>
                        </div>
                        <!-- class="section" -->
                     </div>
                  </div><a id="DWHSG8681"></a><a id="DWHSG8680"></a><div class="props_rev_3"><a id="GUID-9003C56A-2B70-4E26-BCC1-ACF623FAE13E" name="GUID-9003C56A-2B70-4E26-BCC1-ACF623FAE13E"></a><h5 id="DWHSG-GUID-9003C56A-2B70-4E26-BCC1-ACF623FAE13E" class="sect5"><span class="enumeration_section">19.2.1.7</span> ROW_NUMBER函数</h5>
                     <div>
                        <div class="section">
                           <p><a id="d65966e1382" class="indexterm-anchor"></a><a id="d65966e1384" class="indexterm-anchor"></a> <code class="codeph">ROW_NUMBER</code>函数为分区中的每一行分配一个唯一的编号（按顺序，从1开始，由<code class="codeph">ORDER</code> <code class="codeph">BY</code>定义）。它具有以下语法：</p><pre class="oac_no_warn" dir="ltr">ROW_NUMBER（）OVER（[query_partition_clause] order_by_clause）</pre></div>
                        <!-- class="section" -->
                        <div class="example" id="GUID-9003C56A-2B70-4E26-BCC1-ACF623FAE13E__GUID-39C2514C-3DDB-4ED9-802E-A48EE051C008">
                           <p class="titleinexample">例19-6 ROW_NUMBER</p><pre class="oac_no_warn" dir="ltr">SELECT channel_desc，calendar_month_desc，TO_CHAR（TRUNC（SUM（amount_sold）， -  5），'9,999,999,999'）SALES $，ROW_NUMBER（）OVER（ORTER BY TRUNC（SUM（amount_sold）， -  6）DESC）AS ROW_NUMBER FROM sales，products ，客户，时间，渠道WHERE sales.prod_id = products.prod_id AND sales.cust_id = customers.cust_id AND sales.time_id = times.time_id AND sales.channel_id = channels.channel_id AND times.calendar_month_desc IN（'2001-09'， '2001-10'）GROUP BY channel_desc，calendar_month_desc; CHANNEL_DESC日历销售额$ ROW_NUMBER -------------------- -------- -------------- --- -------直接销售2001-10 1,000,000 1直接销售2001-09 1,100,000 2互联网2001-09 500,000 3合作伙伴2001-09 600,000 4合作伙伴2001-10 600,000 5互联网2001-10 700,000 6</pre><p>请注意，这些结果中有三对平局值。与<code class="codeph">NTILE</code>一样， <code class="codeph">ROW_NUMBER</code>是一个非确定性函数，因此每个绑定值都可以切换其行号。要确保确定性结果，您必须使用唯一键进行排序。在大多数情况下，这将需要向查询添加新的tie breaker列并在<code class="codeph">ORDER</code> <code class="codeph">BY</code>规范中使用它。
                           </p>
                        </div>
                        <!-- class="example" -->
                     </div>
                  </div>
               </div><a id="DWHSG0202"></a><div class="props_rev_3"><a id="GUID-2877E1A5-9F11-47F1-A5ED-D7D5C7DED90A" name="GUID-2877E1A5-9F11-47F1-A5ED-D7D5C7DED90A"></a><h4 id="DWHSG-GUID-2877E1A5-9F11-47F1-A5ED-D7D5C7DED90A" class="sect4"><span class="enumeration_section">19.2.2</span>窗口函数</h4>
                  <div>
                     <div class="section">
                        <p><a id="d65966e1441" class="indexterm-anchor"></a><a id="d65966e1445" class="indexterm-anchor"></a>窗口函数可用于计算累积，移动和居中聚合。它们为表中的每一行返回一个值，该值取决于相应窗口中的其他行。使用窗口聚合函数，您可以计算<code class="codeph">SUM</code> ， <code class="codeph">AVERAGE</code> ， <code class="codeph">COUNT</code> ， <code class="codeph">MAX</code> ， <code class="codeph">MIN</code>和更多函数的移动和累积版本。它们只能在查询的<code class="codeph">SELECT</code>和<code class="codeph">ORDER</code> <code class="codeph">BY</code>子句中使用。窗口化聚合函数包括方便的<code class="codeph">FIRST_VALUE</code> ，它返回窗口中的第一个值;和<code class="codeph">LAST_VALUE</code> ，返回窗口中的最后一个值。这些函数提供对没有自连接的表的多个行的访问。窗口函数的语法是：</p><pre class="oac_no_warn" dir="ltr">analytic_function（[arguments]）OVER（analytic_clause）其中analytic_clause = [query_partition_clause] [order_by_clause [windowing_clause]]和query_partition_clause = PARTITION BY {value_expr [，value_expr] ...}和windowing_clause = {ROWS | RANGE} {BETWEEN {UNBOUNDED PRECEDING |当前行| value_expr {PRECEDING |跟随}}和{UNBOUNDED以下|当前行| value_expr {PRECEDING |以下}} | {UNBOUNDED PRECEDING |当前行| value_expr PRECEDING}}</pre><p>请注意，窗口函数不支持<code class="codeph">DISTINCT</code>关键字， <code class="codeph">MAX</code>和<code class="codeph">MIN</code>除外。</p>
                        <div class="infoboxnotealso" id="GUID-2877E1A5-9F11-47F1-A5ED-D7D5C7DED90A__GUID-9F0A2D2B-E079-4A21-8026-53C1AA023739">
                           <p class="notep1">也可以看看：</p>
                           <p>有关语法和限制的更多信息，请<a href="../sqlrf/Aggregate-Functions.html#SQLRF20035" target="_blank"><span class="italic">参见Oracle数据库SQL语言参考</span></a></p>
                        </div>
                        <p>本节包含以下主题：</p>
                        <ul style="list-style-type:disc">
                           <li>
                              <p><a href="sql-analysis-reporting-data-warehouses.html#GUID-9560E5D5-DC77-4BAD-B880-4890651B9FCB">关于处理NULL作为窗口函数的输入</a></p>
                           </li>
                           <li>
                              <p><a href="sql-analysis-reporting-data-warehouses.html#GUID-33B4DE75-D7F8-4AE1-9F2E-C2846F72CC1E">具有逻辑偏移的窗口函数</a></p>
                           </li>
                           <li>
                              <p><a href="sql-analysis-reporting-data-warehouses.html#GUID-DB530439-EC98-4F18-A08B-EA372D788CBE">集中聚合函数</a></p>
                           </li>
                           <li>
                              <p><a href="sql-analysis-reporting-data-warehouses.html#GUID-66DA756D-0112-4FC6-8229-AE139EF0B07B">在重复存在的情况下窗口化聚合函数</a></p>
                           </li>
                           <li>
                              <p><a href="sql-analysis-reporting-data-warehouses.html#GUID-D5B46A71-26DA-4E3A-B289-944DED263A62">每行不同的窗口大小</a></p>
                           </li>
                           <li>
                              <p><a href="sql-analysis-reporting-data-warehouses.html#GUID-D6AC065D-670A-40E8-8DA0-E90A7307CFC2">具有物理偏移的窗口聚合函数</a></p>
                           </li>
                           <li>
                              <p><a href="sql-analysis-reporting-data-warehouses.html#GUID-9CEE2551-7E43-472E-9B68-89E738F42C0A">具有窗口函数的并行分区智能操作</a></p>
                           </li>
                        </ul>
                     </div>
                     <!-- class="section" -->
                  </div><a id="DWHSG8682"></a><div class="props_rev_3"><a id="GUID-9560E5D5-DC77-4BAD-B880-4890651B9FCB" name="GUID-9560E5D5-DC77-4BAD-B880-4890651B9FCB"></a><h5 id="DWHSG-GUID-9560E5D5-DC77-4BAD-B880-4890651B9FCB" class="sect5"><span class="enumeration_section">19.2.2.1</span>关于将NULL作为窗函数输入的处理</h5>
                     <div>
                        <p>Window函数的<code class="codeph">NULL</code>语义匹配SQL聚合函数的<code class="codeph">NULL</code>语义。其他语义可以通过用户定义的函数获得，或者通过在窗口函数中使用<code class="codeph">DECODE</code>或<code class="codeph">CASE</code>表达式来获得。
                        </p>
                     </div>
                  </div><a id="DWHSG8684"></a><a id="DWHSG8685"></a><a id="DWHSG8683"></a><div class="props_rev_3"><a id="GUID-33B4DE75-D7F8-4AE1-9F2E-C2846F72CC1E" name="GUID-33B4DE75-D7F8-4AE1-9F2E-C2846F72CC1E"></a><h5 id="DWHSG-GUID-33B4DE75-D7F8-4AE1-9F2E-C2846F72CC1E" class="sect5"><span class="enumeration_section">19.2.2.2</span>具有逻辑偏移的窗口函数</h5>
                     <div>
                        <div class="section">
                           <p>逻辑偏移量可以使用<code class="codeph">RANGE 10 PRECEDING</code>等常量，或者求值为常量的表达式，或者<code class="codeph">RANGE</code> <code class="codeph">INTERVAL</code> <code class="codeph">N</code> <code class="codeph">DAY</code> / <code class="codeph">MONTH</code> / <code class="codeph">YEAR</code> <code class="codeph">PRECEDING</code>等区间规范，或者求值为间隔的表达式来指定。
                           </p>
                           <p>对于逻辑偏移，函数中的<code class="codeph">ORDER</code> <code class="codeph">BY</code>表达式列表中只能有一个表达式，如果offset是数字，则类型与<code class="codeph">NUMERIC</code>兼容;如果指定了间隔，则类型为<code class="codeph">DATE</code> 。
                           </p>
                           <p>使用<code class="codeph">RANGE</code>关键字的分析函数如果指定这两个窗口中的任何一个，则可以在其<code class="codeph">ORDER</code> <code class="codeph">BY</code>子句中使用多个排序键：</p>
                        </div>
                        <!-- class="section" -->
                        <div class="section">
                           <ul style="list-style-type:disc">
                              <li>
                                 <p><code class="codeph">RANGE</code> <code class="codeph">BETWEEN</code> <code class="codeph">UNBOUNDED</code> <code class="codeph">PRECEDING</code> <code class="codeph">AND</code> <code class="codeph">CURRENT</code> <code class="codeph">ROW</code> 。其简短形式是<code class="codeph">RANGE</code> <code class="codeph">UNBOUNDED</code> <code class="codeph">PRECEDING</code> ，也可以使用。
                                 </p>
                              </li>
                              <li>
                                 <p><code class="codeph">RANGE</code> <code class="codeph">BETWEEN</code> <code class="codeph">CURRENT</code> <code class="codeph">ROW</code> <code class="codeph">AND</code> <code class="codeph">UNBOUNDED</code> <code class="codeph">FOLLOWING</code> 。</p>
                              </li>
                           </ul>
                           <p>不满足这些条件的窗口边界在分析函数的<code class="codeph">ORDER</code> <code class="codeph">BY</code>子句中只能有一个排序键。
                           </p>
                        </div>
                        <!-- class="section" -->
                        <div class="example" id="GUID-33B4DE75-D7F8-4AE1-9F2E-C2846F72CC1E__GUID-4CB0EE02-AA9F-42D9-8F1B-2CD477496CD9">
                           <p class="titleinexample">例19-7累积聚合函数</p>
                           <p>以下是2000年按季度按客户ID累计<code class="codeph">amount_sold</code>的示例：</p><pre class="oac_no_warn" dir="ltr">SELECT c.cust_id，t.calendar_quarter_desc，TO_CHAR（SUM（amount_sold），'9,999,999,999.99'）AS Q_SALES，TO_CHAR（SUM（SUM（amount_sold））OVER（由c.cust_id分类，顺序为c.cust_id，t.calendar_quarter_desc ROWS UNBOUNDED PRECEDING），'9,999,999,999.99'）AS CUM_SALES FROM sales s，times t，customers c WHERE s.time_id = t.time_id AND s.cust_id = c.cust_id AND t.calendar_year = 2000 AND c.cust_id IN（2595,9646， 11111）GROUP BY c.cust_id，t.calendar_quarter_desc ORDER BY c.cust_id，t.calendar_quarter_desc; CUST_ID CALENDA Q_SALES CUM_SALES ---------- ------- ----------------- ------------ ----- 2595 2000-01 659.92 659.92 2595 2000-02 224.79 884.71 2595 2000-03 313.90 1,198.61 2595 2000-04 6,015.08 7,213.69 9646 2000-01 1,337.09 1,337.09 9646 2000-02 185.67 1,522.76 9646 2000-03 203.86 1,726.62 9646 2000- 04 458.29 2,184.91 11111 2000-01 43.18 43.18 11111 2000-02 33.33 76.51 11111 2000-03 579.73 656.24 11111 2000-04 307.58 963.82</pre><p>在此示例中，分析函数<code class="codeph">SUM</code>为每一行定义一个窗口，该窗口从分区的开头（ <code class="codeph">UNBOUNDED</code> <code class="codeph">PRECEDING</code> ）开始，默认情况下在当前行结束。
                           </p>
                           <p>嵌套<code class="codeph">SUM</code>因为你执行的是s的需要在这个例子中<code class="codeph">SUM</code>在这本身就是一种价值<code class="codeph">SUM</code> 。嵌套聚合在分析聚合函数中经常使用。
                           </p>
                        </div>
                        <!-- class="example" -->
                        <div class="example" id="GUID-33B4DE75-D7F8-4AE1-9F2E-C2846F72CC1E__GUID-3AEC98E2-1872-4B74-A755-B6E1AFCB6AA1">
                           <p class="titleinexample">例19-8移动聚合函数</p>
                           <p>此基于时间的窗口示例显示，对于一个客户，当前月份和前两个月的销售移动平均值：</p><pre class="oac_no_warn" dir="ltr">SELECT c.cust_id，t.calendar_month_desc，TO_CHAR（SUM（amount_sold），'9,999,999,999'）AS SALES，TO_CHAR（AVG（SUM（amount_sold））OVER（ORDER BY c.cust_id，t.calendar_month_desc ROWS 2 PRECEDING），'9,999,999,999 '）AS MOVING_3_MONTH_AVG FROM sales s，times t，customers c WHERE s.time_id = t.time_id AND s.cust_id = c.cust_id AND t.calendar_year = 1999 AND c.cust_id IN（6510）GROUP BY c.cust_id，t .calendar_month_desc ORDER BY c.cust_id，t.calendar_month_desc; CUST_ID CALENDAR SALES MOVING_3_MONTH ---------- -------- -------------- -------------- 6510 1999-04 125 125 6510 1999-05 3,395 1,760 6510 1999-06 4,080 2,533 6510 1999-07 6,435 4,637 6510 1999-08 5,105 5,207 6510 1999-09 4,676 5,405 6510 1999-10 5,109 4,963 6510 1999-11 802 3,529</pre><p>请注意，输出数据中三个月移动平均值计算的前两行基于比指定的小的间隔大小，因为窗口计算无法超过查询检索的数据。您必须考虑在结果集边界处找到的不同窗口大小。换句话说，您可能需要修改查询以准确包含所需内容。</p>
                        </div>
                        <!-- class="example" -->
                     </div>
                  </div><a id="DWHSG8687"></a><a id="DWHSG8686"></a><div class="props_rev_3"><a id="GUID-DB530439-EC98-4F18-A08B-EA372D788CBE" name="GUID-DB530439-EC98-4F18-A08B-EA372D788CBE"></a><h5 id="DWHSG-GUID-DB530439-EC98-4F18-A08B-EA372D788CBE" class="sect5"><span class="enumeration_section">19.2.2.3</span>中心聚合函数</h5>
                     <div>
                        <div class="section">
                           <p>计算以当前行为中心的窗口集合函数非常简单。这个例子为所有客户计算了1999年12月底一周的销售中心移动平均值。它找到当前行之前一天和当前行之后一天（包括当前行）的销售总额的平均值。</p>
                        </div>
                        <!-- class="section" -->
                        <div class="example" id="GUID-DB530439-EC98-4F18-A08B-EA372D788CBE__GUID-36104FDE-9CB2-431A-8C00-50C6AAFCCEF5">
                           <p class="titleinexample">例19-9中心聚合</p><pre class="oac_no_warn" dir="ltr">SELECT t.time_id，TO_CHAR（SUM（amount_sold），'9,999,999,999'）AS SALES，TO_CHAR（AVG（SUM（amount_sold））OVER（按顺序排列t.time_id区间'1'日前一天和间隔'1'日之后），'9,999,999,999'）AS CENTERED_3_DAY_AVG FROM sales s，times t WHERE s.time_id = t.time_id AND t.calendar_week_number IN（51）AND calendar_year = 1999 GROUP BY t.time_id ORDER BY t.time_id; TIME_ID SALES CENTERED_3_DAY --------- -------------- -------------- 20-DEC-99 134,337 106,676 21-DEC -99 79,015 102,539 22-DEC-99 94,264 85,342 23-DEC-99 82,746 93,322 24-DEC-99 102,957 82,937 25-DEC-99 63,107 87,062 26-DEC-99 95,123 79,115</pre><p>输出数据中每个产品的居中移动平均值计算的起始行和结束行仅基于两天，因为窗口计算无法超过查询检索的数据。与前面的示例一样，您必须考虑在结果集的边界处找到的不同窗口大小：可能需要调整查询。</p>
                        </div>
                        <!-- class="example" -->
                     </div>
                  </div><a id="DWHSG8689"></a><a id="DWHSG8688"></a><div class="props_rev_3"><a id="GUID-66DA756D-0112-4FC6-8229-AE139EF0B07B" name="GUID-66DA756D-0112-4FC6-8229-AE139EF0B07B"></a><h5 id="DWHSG-GUID-66DA756D-0112-4FC6-8229-AE139EF0B07B" class="sect5"><span class="enumeration_section">19.2.2.4</span>在重复存在的情况下窗口化聚合函数</h5>
                     <div>
                        <div class="section">
                           <p>以下示例说明了窗口聚合函数如何在存在重复时计算值，即，为单个排序值返回多行时。该查询检索在指定时间范围内销售给多个客户的数量。（虽然使用内联视图来定义基础数据集，但它没有特殊意义，可以忽略。）该查询定义了一个移动窗口，该窗口从当前行的日期开始运行到10天之前。请注意， <code class="codeph">RANGE</code>关键字用于定义此示例的窗口子句。这意味着窗口可以为该范围中的每个值保留许多行。在这种情况下，有三对具有重复日期值的行。
                           </p>
                        </div>
                        <!-- class="section" -->
                        <div class="example" id="GUID-66DA756D-0112-4FC6-8229-AE139EF0B07B__GUID-AB01C7FE-431C-430F-9376-A5BFDB442CFE">
                           <p class="titleinexample">示例19-10使用逻辑偏移量窗口化聚合函数</p><pre class="oac_no_warn" dir="ltr">SELECT time_id，daily_sum，SUM（daily_sum）OVER（ORTER BY time_id在间隔'10'天前和当前行之间的范围）AS current_group_sum FROM（SELECT time_id，channel_id，SUM（s.quantity_sold）AS daily_sum FROM customers c，sales s，国家/地区：c.cust_id = s.cust_id和c.country_id = countries.country_id AND s.cust_id IN（638,634,753,440）AND s.time_id BETWEEN '01 -MAY-00'和'13 -MAY-00 'GROUP BY time_id，channel_id）; TIME_ID DAILY_SUM CURRENT_GROUP_SUM --------- ---------- ----------------- 06-MAY-00 7 7 / * 7 * / 10-MAY-00 1 9 / * 7 +（1 + 1）* / 10-MAY-00 1 9 / * 7 +（1 + 1）* / 11-MAY-00 2 15 / * 7 +（1 +1）+（2 + 4）* / 11-MAY-00 4 15 / * 7 +（1 + 1）+（2 + 4）* / 12-MAY-00 1 16 / * 7 +（1 + 1 ）+（2 + 4）+ 1 * / 13-MAY-00 2 23 / * 7 +（1 + 1）+（2 + 4）+ 1 +（5 + 2）* / 13-MAY-00 5 23 / * 7 +（1 + 1）+（2 + 4）+ 1 +（5 + 2）* /</pre><p>在此示例的输出中，除5月6日和5月12日之外的所有日期都返回两行。检查输出右侧的注释数字，以查看值的计算方式。请注意，括号中的每个组表示一天返回的值。</p>
                           <p>请注意，此示例仅在您使用<code class="codeph">RANGE</code>关键字而不是<code class="codeph">ROWS</code>关键字时适用。同样重要的是要记住，使用<code class="codeph">RANGE</code> ，您只能在分析函数的<code class="codeph">ORDER</code> <code class="codeph">BY</code>子句中使用1 <code class="codeph">ORDER</code> <code class="codeph">BY</code>表达式。使用<code class="codeph">ROWS</code>关键字，可以在分析函数的<code class="codeph">ORDER</code> <code class="codeph">BY</code>子句中使用多个order by表达式。
                           </p>
                        </div>
                        <!-- class="example" -->
                     </div>
                  </div><a id="DWHSG8690"></a><div class="props_rev_3"><a id="GUID-D5B46A71-26DA-4E3A-B289-944DED263A62" name="GUID-D5B46A71-26DA-4E3A-B289-944DED263A62"></a><h5 id="DWHSG-GUID-D5B46A71-26DA-4E3A-B289-944DED263A62" class="sect5"><span class="enumeration_section">19.2.2.5</span>每行的窗口大小不同</h5>
                     <div>
                        <div class="section">
                           <p>在某些情况下，根据指定的条件改变每行窗口的大小是有用的。例如，您可能希望在某些日期使窗口更大，而对其他日期则更小。假设您想要计算三个工作日内股票价格的移动平均线。如果所有工作日的每天都有相同的行数，并且不存储非工作日，则可以使用物理窗口功能。但是，如果未满足条件，您仍可以通过在窗口大小参数中使用表达式来计算移动平均值。</p>
                           <p>窗口大小规范中的表达式可以在几个不同的源中进行。表达式可以是对表中列的引用，例如时间表。它也可以是一个函数，它根据当前行中的值返回窗口的适当边界。假设股票价格数据库的以下声明在其<code class="codeph">RANGE</code>子句中使用用户定义的函数来设置窗口大小：</p><pre class="oac_no_warn" dir="ltr">SELECT t_timekey，AVG（stock_price）OVER（ORDER BY t_timekey RANGE fn（t_timekey）PRECEDING）av_price FROM stock，time WHERE st_timekey = t_timekey ORDER BY t_timekey;</pre><p>在此语句中， <code class="codeph">t_timekey</code>是一个日期字段。这里， <span class="italic">fn</span>可以是PL / SQL函数，具有以下规范：</p>
                           <p><code class="codeph">fn(t_timekey)</code>返回</p>
                        </div>
                        <!-- class="section" -->
                        <div class="section">
                           <ul style="list-style-type:disc">
                              <li>
                                 <p>4如果<code class="codeph">t_timekey</code>是星期一，星期二</p>
                              </li>
                              <li>
                                 <p>2否则</p>
                              </li>
                              <li>
                                 <p>如果前几天的任何一天是假期，它会适当调整计数。</p>
                              </li>
                           </ul>
                           <p>请注意，当使用日期列上具有<code class="codeph">ORDER</code> <code class="codeph">BY</code>的窗口函数中的数字指定窗口时，它将转换为表示天数。你也可以使用区间文字转换函数，如<code class="codeph">NUMTODSINTERVAL(fn(t_timekey), 'DAY')</code>而不仅仅是<code class="codeph">fn(t_timekey)</code>来表示同样的事情。您还可以编写一个返回<code class="codeph">INTERVAL</code>数据类型值的PL / SQL函数。
                           </p>
                        </div>
                        <!-- class="section" -->
                     </div>
                  </div><a id="DWHSG8692"></a><a id="DWHSG8691"></a><div class="props_rev_3"><a id="GUID-D6AC065D-670A-40E8-8DA0-E90A7307CFC2" name="GUID-D6AC065D-670A-40E8-8DA0-E90A7307CFC2"></a><h5 id="DWHSG-GUID-D6AC065D-670A-40E8-8DA0-E90A7307CFC2" class="sect5"><span class="enumeration_section">19.2.2.6</span>使用物理偏移量窗口化聚合函数</h5>
                     <div>
                        <div class="section">
                           <p>对于以行表示的窗口，排序表达式应该是唯一的，以产生确定性结果。例如，以下查询不是确定性的，因为<code class="codeph">time_id</code>在此结果集中不是唯一的。
                           </p>
                        </div>
                        <!-- class="section" -->
                        <div class="example" id="GUID-D6AC065D-670A-40E8-8DA0-E90A7307CFC2__GUID-AC76735B-6017-4C4E-AA59-791D20DC0215">
                           <p class="titleinexample">例19-11使用物理偏移量窗口化聚合函数</p><pre class="oac_no_warn" dir="ltr">SELECT t.time_id，TO_CHAR（amount_sold，'9,999,999,999'）AS INDIV_SALE，TO_CHAR（SUM（amount_sold）OVER（PARTITION BY t.time_id ORDER BY t.time_id ROWS UNBOUNDED PRECEDING），'9,999,999,999'）AS CUM_SALES FROM sales s，times客户c WHERE s.time_id = t.time_id AND s.cust_id = c.cust_id AND t.time_id IN（TO_DATE（'11 -DEC-1999'），TO_DATE（'12 -DEC-1999'））AND c .cust_id BETWEEN 6500和6600 ORDER BY t.time_id; TIME_ID INDIV_SALE CUM_SALES --------- ---------- --------- 12-DEC-99 23 23 12-DEC-99 9 32 12-DEC-99 14 46 12-DEC-99 24 70 12-DEC-99 19 89</pre><p>处理此问题的一种方法是将<code class="codeph">prod_id</code>列添加到结果集并在<code class="codeph">time_id</code>和<code class="codeph">prod_id</code>上进行<code class="codeph">time_id</code> 。
                           </p>
                        </div>
                        <!-- class="example" -->
                     </div>
                  </div>
                  <div class="sect4"><a id="GUID-9CEE2551-7E43-472E-9B68-89E738F42C0A" name="GUID-9CEE2551-7E43-472E-9B68-89E738F42C0A"></a><h5 id="DWHSG-GUID-9CEE2551-7E43-472E-9B68-89E738F42C0A" class="sect5"><span class="enumeration_section">19.2.2.7</span>具有窗口函数的并行分区 - 明智操作</h5>
                     <div>
                        <p>SQL窗口函数可以有一个查询分区子句，它可以根据子句中使用的表达式将查询结果分成组。对于分区表上的并行查询，如果满足此类操作的要求，则子句定义的分区可用于执行分区操作。这样可以在分区表上实现更快的SQL窗口查询。</p>
                        <div class="infoboxnotealso" id="GUID-9CEE2551-7E43-472E-9B68-89E738F42C0A__GUID-601B0A51-7A31-4498-AED7-86946C886A0D">
                           <p class="notep1">也可以看看：</p>
                           <p><a href="../vldbg/partition-wise-joins.html#VLDBG-GUID-7C28CD29-5189-4A53-9691-380E13515015" target="_blank"><span class="italic">Oracle数据库VLDB和分区指南</span></a></p>
                        </div>
                     </div>
                  </div>
               </div><a id="DWHSG8693"></a><a id="DWHSG0203"></a><div class="props_rev_3"><a id="GUID-C934D977-6661-4697-8CB8-5ED82DB72E5A" name="GUID-C934D977-6661-4697-8CB8-5ED82DB72E5A"></a><h4 id="DWHSG-GUID-C934D977-6661-4697-8CB8-5ED82DB72E5A" class="sect4"><span class="enumeration_section">19.2.3</span>报告功能</h4>
                  <div>
                     <p><a id="d65966e2019" class="indexterm-anchor"></a><a id="d65966e2021" class="indexterm-anchor"></a>处理完查询后，可以在分区内轻松计算聚合值（如结果行数或列中的平均值），并使其可用于其他报告功能。报告聚合函数为分区中的每一行返回相同的聚合值。它们对<code class="codeph">NULLs</code>行为与SQL聚合函数相同。语法是：</p><pre class="oac_no_warn" dir="ltr">{SUM | AVG | MAX | MIN | COUNT | STDDEV |方差......}（[ALL | DISTINCT] { <span class="italic">value expression1</span> [，...]| *}）OVER（[PARTITION BY <span class="italic">value expression2</span> [，...]]）
</pre><p>此外，以下条件适用：</p>
                     <ul style="list-style-type:disc">
                        <li>
                           <p>仅在<code class="codeph">COUNT(*)</code>允许使用星号<code class="codeph">COUNT(*)</code></p>
                        </li>
                        <li>
                           <p>仅当相应的聚合函数允许时才支持<code class="codeph">DISTINCT</code> 。
                           </p>
                        </li>
                        <li>
                           <p><span class="italic"><code class="codeph">value expression1</code></span>和<span class="italic"><code class="codeph">value expression2</code></span>可以是涉及列引用或聚合的任何有效表达式。
                           </p>
                        </li>
                        <li>
                           <p><code class="codeph">PARTITION</code> <code class="codeph">BY</code>子句定义将在其上计算窗口函数的组。如果不存在<code class="codeph">PARTITION</code> <code class="codeph">BY</code>子句，则在整个查询结果集上计算函数。
                           </p>
                        </li>
                     </ul>
                     <div class="infoboxnotealso" id="GUID-C934D977-6661-4697-8CB8-5ED82DB72E5A__GUID-C88C8282-58FB-4D9C-AC63-33B2EAABEF71">
                        <p class="notep1">也可以看看：</p>
                        <p><a href="sql-analysis-reporting-data-warehouses.html#GUID-C545E24F-B162-45CC-8042-B2ACED4E1FD7">RATIO_TO_REPORT功能</a></p>
                     </div>
                     <p>报告功能只能出现在<code class="codeph">SELECT</code>子句或<code class="codeph">ORDER</code> <code class="codeph">BY</code>子句中。报告功能的主要好处是能够在单个查询块中进行多次数据传递并加快查询性能。诸如“计算销售额超过城市销售额10％的销售人员数量”的查询不需要在单独的查询块之间进行连接。
                     </p>
                     <p>例如，考虑问题“对于每个产品类别，找到它具有最大销售额的区域”。使用<code class="codeph">MAX</code>报告聚合函数的等效SQL查询将是：</p><pre class="oac_no_warn" dir="ltr">SELECT prod_category，country_region，sales FROM（SELECT SUBSTR（p.prod_category，1,8）AS prod_category，co.country_region，SUM（amount_sold）AS sales，MAX（SUM（amount_sold））OVER（PARTITION BY prod_category）AS MAX_REG_SALES FROM sales s，customers c，countries co，products p WHERE s.cust_id = c.cust_id AND c.country_id = co.country_id AND s.prod_id = p.prod_id AND s.time_id = TO_DATE（'11 -OCT-2001'）GROUP BY prod_category，country_region）WHERE sales = MAX_REG_SALES;</pre><p>报告聚合函数<code class="codeph">MAX(SUM(amount_sold))</code>的内部查询返回：</p><pre class="oac_no_warn" dir="ltr">PROD_CAT COUNTRY_REGION SALES MAX_REG_SALES -------- -------------------- ---------- -------- ----- Electron Americas 581.92 581.92 Hardware Americas 925.93 925.93 Peripher Americas 3084.48 4290.38 Peripher Asia 2616.51 4290.38 Peripher Europe 4290.38 4290.38 Peripher Oceania 940.43 4290.38 Software Americas 4445.7 4445.7 Software Asia 1408.19 4445.7 Software Europe 3288.83 4445.7 Software Oceania 890.25 4445.7</pre><p>完整的查询结果是：</p><pre class="oac_no_warn" dir="ltr">PROD_CAT COUNTRY_REGION SALES -------- -------------------- ---------- Electron Americas 581.92 Hardware Americas 925.93 Peripher Europe 4290.38软件美洲4445.7</pre><div class="example" id="GUID-C934D977-6661-4697-8CB8-5ED82DB72E5A__GUID-C64EE719-E3B7-4EEF-83C0-989BDD402B84">
                        <p class="titleinexample">示例19-12报告聚合示例</p>
                        <p>通过报告聚合与嵌套查询相结合，您可以有效地回答复杂查询。例如，如果您想了解最重要的产品子类别中最畅销的产品，该怎么办？以下是一个查询，该查询查找每个产品子类别的5个畅销产品，这些产品在其产品类别中占销售额的20％以上：</p><pre class="oac_no_warn" dir="ltr">SELECT SUBSTR（prod_category，1,8）AS CATEG，prod_subcategory，prod_id，SALES FROM（SELECT p.prod_category，p.prod_subcategory，p.prod_id，SUM（amount_sold）AS SALES，SUM（SUM（amount_sold））OVER（PARTITION BY） p.prod_category）AS CAT_SALES，SUM（SUM（amount_sold））OVER（PARTITION BY p.prod_subcategory）AS SUBCAT_SALES，RANK（）OVER（PARPTION BY p.prod_subcategory ORDER BY SUM（amount_sold））AS RANK_IN_LINE FROM sales s，customers c ，countries co，products p WHERE s.cust_id = c.cust_id AND c.country_id = co.country_id AND s.prod_id = p.prod_id AND s.time_id = to_DATE（'11 -OCT-2000'）GROUP BY p.prod_category ，p.prod_subcategory，p.prod_id ORDER BY prod_category，prod_subcategory）WHERE SUBCAT_SALES&gt; 0.2 * CAT_SALES AND RANK_IN_LINE &lt;= 5;</pre></div>
                     <!-- class="example" -->
                  </div><a id="DWHSG8695"></a><a id="DWHSG8694"></a><div class="props_rev_3"><a id="GUID-C545E24F-B162-45CC-8042-B2ACED4E1FD7" name="GUID-C545E24F-B162-45CC-8042-B2ACED4E1FD7"></a><h5 id="DWHSG-GUID-C545E24F-B162-45CC-8042-B2ACED4E1FD7" class="sect5"><span class="enumeration_section">19.2.3.1</span> RATIO_TO_REPORT功能</h5>
                     <div>
                        <div class="section">
                           <p><a id="d65966e2140" class="indexterm-anchor"></a><a id="d65966e2142" class="indexterm-anchor"></a> <code class="codeph">RATIO_TO_REPORT</code>函数计算值与一组值之和的比率。如果表达式<code class="codeph">value</code> <code class="codeph">expression</code>计算结果为<code class="codeph">NULL</code> ，则<code class="codeph">RATIO_TO_REPORT</code>也会计算为<code class="codeph">NULL</code> ，但它会被视为零，用于计算分母的值的总和。它的语法是：</p><pre class="oac_no_warn" dir="ltr">RATIO_TO_REPORT（expr）OVER（[query_partition_clause]）</pre><p>在此，以下内容适用：</p>
                           <ul style="list-style-type:disc">
                              <li>
                                 <p><code class="codeph">expr</code>可以是涉及列引用或聚合的任何有效表达式。
                                 </p>
                              </li>
                              <li>
                                 <p><code class="codeph">PARTITION</code> <code class="codeph">BY</code>子句定义要在其上计算<code class="codeph">RATIO_TO_REPORT</code>函数的组。如果不存在<code class="codeph">PARTITION</code> <code class="codeph">BY</code>子句，则在整个查询结果集上计算函数。
                                 </p>
                              </li>
                           </ul>
                        </div>
                        <!-- class="section" -->
                        <div class="example" id="GUID-C545E24F-B162-45CC-8042-B2ACED4E1FD7__GUID-4421F058-F21E-4714-941B-9E5C2D9B177E">
                           <p class="titleinexample">例19-13 RATIO_TO_REPORT</p>
                           <p>要计算每个渠道的销售额<code class="codeph">RATIO_TO_REPORT</code> ，您可以使用以下语法：</p><pre class="oac_no_warn" dir="ltr">SELECT ch.channel_desc，TO_CHAR（SUM（amount_sold），'9,999,999'）AS SALES，TO_CHAR（SUM（SUM（amount_sold））OVER（），'9,999,999'）AS TOTAL_SALES，TO_CHAR（RATIO_TO_REPORT（SUM（amount_sold））OVER（ ），'9.999'）AS RATIO_TO_REPORT FROM sales s，channels ch WHERE s.channel_id = ch.channel_id AND s.time_id = to_DATE（'11 -OCT-2000'）GROUP BY ch.channel_desc; CHANNEL_DESC SALES TOTAL_SALE RATIO_ -------------------- ---------- ---------- ------直接销售14,447 23,183 .623互联网345 23,183 .015合作伙伴8,391 23,183 .362</pre></div>
                        <!-- class="example" -->
                     </div>
                  </div>
               </div><a id="DWHSG0204"></a><div class="props_rev_3"><a id="GUID-4A7CC941-78D4-4A1C-98EC-DA548E1FD394" name="GUID-4A7CC941-78D4-4A1C-98EC-DA548E1FD394"></a><h4 id="DWHSG-GUID-4A7CC941-78D4-4A1C-98EC-DA548E1FD394" class="sect4"><span class="enumeration_section">19.2.4</span> LAG / LEAD功能</h4>
                  <div>
                     <p><a id="d65966e2225" class="indexterm-anchor"></a><a id="d65966e2227" class="indexterm-anchor"></a>当可以可靠地知道行的相对位置时， <code class="codeph">LAG</code>和<code class="codeph">LEAD</code>函数可用于比较值。它们通过指定将目标行与当前行分开的行数来工作。由于这些函数可以在没有自连接的情况下同时访问表的多个行，因此可以提高处理速度。<code class="codeph">LAG</code>函数提供对当前位置之前的给定偏移处的行的访问，并且<code class="codeph">LEAD</code>功能提供对当前位置之后的给定偏移处的行的访问。 <span class="q">“ <a href="sql-analysis-reporting-data-warehouses.html#GUID-51BE374A-F4C8-4A36-AE01-AF1CB6F0B596">LAG / LEAD语法</a> ”</span>描述了这些函数的语法。
                     </p>
                     <p><code class="codeph">LAG</code>和<code class="codeph">LEAD</code>函数可以被认为与<code class="codeph">NTH_VALUE</code>函数相关并简化了<code class="codeph">NTH_VALUE</code>函数。使用<code class="codeph">LAG</code>和<code class="codeph">LEAD</code> ，您只能从指定物理偏移量的行中检索值。如果这不够，可以使用<code class="codeph">NTH_VALUE</code> ，这使您可以根据所谓的逻辑偏移或相对位置从行中检索值。您可以将<code class="codeph">IGNORE</code> <code class="codeph">NULLS</code>选项与<code class="codeph">NTH_VALUE</code>函数一起使用，以使其更有用，因为您可以根据特定条件指定条件并过滤掉行。请参见<a href="sql-analysis-reporting-data-warehouses.html#GUID-F543EB05-02DC-403F-ACDE-BCE72E5DA189__BCFIBFFI">例19-17</a> ，其中过滤掉数量小于8的行。这不能用<code class="codeph">LAG</code>或<code class="codeph">LEAD</code> ，因为你不知<code class="codeph">LEAD</code>的偏移量。
                     </p>
                     <p>有关更多信息，请参见<span class="q">“ <a href="sql-analysis-reporting-data-warehouses.html#GUID-F543EB05-02DC-403F-ACDE-BCE72E5DA189">NTH_VALUE函数</a> ”</span>和<a href="../sqlrf/NTH_VALUE.html#SQLRF30031" target="_blank"><span class="italic">Oracle数据库SQL语言参考</span></a> 。
                     </p>
                  </div><a id="DWHSG8697"></a><a id="DWHSG8698"></a><a id="DWHSG8696"></a><div class="props_rev_3"><a id="GUID-51BE374A-F4C8-4A36-AE01-AF1CB6F0B596" name="GUID-51BE374A-F4C8-4A36-AE01-AF1CB6F0B596"></a><h5 id="DWHSG-GUID-51BE374A-F4C8-4A36-AE01-AF1CB6F0B596" class="sect5"><span class="enumeration_section">19.2.4.1</span> LAG / LEAD语法</h5>
                     <div>
                        <div class="section">
                           <p>这些函数具有以下语法：</p><pre class="oac_no_warn" dir="ltr">{LAG | LEAD}（value_expr [，offset] [，默认]）[尊重NULLS | IGNORE NULLS] OVER（[query_partition_clause] order_by_clause）</pre><p><span class="italic"><code class="codeph">offset</code></span>是一个可选参数，默认为1. <span class="italic"><code class="codeph">default</code></span>是一个可选参数，如果<span class="italic"><code class="codeph">offset</code></span>超出表或分区的范围，则返回的值。如果指定了<code class="codeph">IGNORE</code> <code class="codeph">NULLS</code> ，则在忽略具有NULL的行之后，返回的值将来自指定滞后或前导偏移的行。
                           </p>
                        </div>
                        <!-- class="section" -->
                        <div class="example" id="GUID-51BE374A-F4C8-4A36-AE01-AF1CB6F0B596__GUID-871C606E-C50E-4F91-8CCC-1CCE83C8FAA6">
                           <p class="titleinexample">实施例19-14 LAG / LEAD</p>
                           <p>此示例说明了使用<code class="codeph">LAG</code>和<code class="codeph">LEAD</code>的典型案例：</p><pre class="oac_no_warn" dir="ltr">SELECT time_id，TO_CHAR（SUM（amount_sold），'9,999,999'）AS SALES，TO_CHAR（LAG（SUM（amount_sold），1）OVER（ORDER BY time_id），'9,999,999'）AS LAG1，TO_CHAR（LEAD（SUM（amount_sold）） ，1）OVER（ORDER BY time_id），'9,999,999'）AS LEAD1 FROM sales WHERE time_id&gt; = TO_DATE（'10 -OCT-2000'）AND time_id &lt;= TO_DATE（'14 -OCT-2000'）GROUP BY time_id; TIME_ID SALES LAG1 LEAD1 --------- ---------- ---------- ---------- 10-OCT-00 238,479 23,183 11-OCT-00 23,183 238,479 24,616 12-OCT-00 24,616 23,183 76,516 13-OCT-00 76,516 24,616 29,795 14-OCT-00 29,795 76,516</pre></div>
                        <!-- class="example" -->
                        <div class="section">
                           <p>有关如何使用<code class="codeph">LAG</code> / <code class="codeph">LEAD</code>函数对稀疏数据进行逐周期比较查询的信息，请参阅<span class="q">“ <a href="sql-analysis-reporting-data-warehouses.html#GUID-01B5DD6F-C039-4223-B017-263F7788C4FA">报告数据密度</a> ”</span> 。
                           </p>
                        </div>
                        <!-- class="section" -->
                        <div class="example" id="GUID-51BE374A-F4C8-4A36-AE01-AF1CB6F0B596__GUID-9B4F20D0-83E1-42BA-8EE9-9C6491921C0D">
                           <p class="titleinexample">实施例19-15使用IGNORE NULLS的LAG / LEAD</p>
                           <p>此示例说明了使用<code class="codeph">LAG</code>和<code class="codeph">LEAD</code>以及<code class="codeph">IGNORE</code> <code class="codeph">NULLS</code>选项的典型情况：</p><pre class="oac_no_warn" dir="ltr">SELECT prod_id，channel_id，SUM（quantity_sold）quantity，CASE WHEN SUM（quantity_sold）&lt;5000 THEN SUM（amount_sold）ELSE NULL END amount，LAG（CASE WHEN SUM（quantity_sold）&lt;5000 THEN SUM（amount_sold）ELSE NULL END）IGNORE NULLS OVER（由prod_id ORDER BY channel_id划分）延迟销售额WHERE prod_id IN（18,127,138）GROUP BY prod_id，channel_id; PROD_ID CHANNEL_ID QUANTITY AMOUNT LAG -------- ---------- -------- ----------- -------- -  18 2 2888 4420923.94 18 3 5615 4420923.94 18 4 1088 1545729.81 4420923.94 127 2 4508 274088.08 127 3 9626 274088.08 127 4 1850 173682.67 274088.08 138 2 1120 127390.3 138 3 3878 393111.15 127390.3 138 4 543 71203.21 393111.15选择了9行。</pre></div>
                        <!-- class="example" -->
                     </div>
                  </div>
               </div><a id="DWHSG8699"></a><div class="props_rev_3"><a id="GUID-B1E8AB97-FFF6-4C5A-BB3C-D54780536C86" name="GUID-B1E8AB97-FFF6-4C5A-BB3C-D54780536C86"></a><h4 id="DWHSG-GUID-B1E8AB97-FFF6-4C5A-BB3C-D54780536C86" class="sect4"><span class="enumeration_section">19.2.5</span> FIRST_VALUE，LAST_VALUE和NTH_VALUE函数</h4>
                  <div>
                     <p>本节说明了以下主题中描述的<code class="codeph">FIRST_VALUE</code> ， <code class="codeph">LAST_VALUE</code>和<code class="codeph">NTH_VALUE</code>函数：</p>
                     <ul style="list-style-type:disc">
                        <li>
                           <p><a href="sql-analysis-reporting-data-warehouses.html#GUID-57FA7976-535D-4AA4-8452-B580F1E1EDC9">FIRST_VALUE和LAST_VALUE函数</a></p>
                        </li>
                        <li>
                           <p><a href="sql-analysis-reporting-data-warehouses.html#GUID-F543EB05-02DC-403F-ACDE-BCE72E5DA189">NTH_VALUE函数</a></p>
                        </li>
                     </ul>
                  </div><a id="DWHSG8700"></a><a id="DWHSG02016"></a><div class="props_rev_3"><a id="GUID-57FA7976-535D-4AA4-8452-B580F1E1EDC9" name="GUID-57FA7976-535D-4AA4-8452-B580F1E1EDC9"></a><h5 id="DWHSG-GUID-57FA7976-535D-4AA4-8452-B580F1E1EDC9" class="sect5"><span class="enumeration_section">19.2.5.1</span> FIRST_VALUE和LAST_VALUE函数</h5>
                     <div>
                        <div class="section">
                           <p><code class="codeph">FIRST_VALUE</code>和<code class="codeph">LAST_VALUE</code> <a id="d65966e2465" class="indexterm-anchor"></a><a id="d65966e2467" class="indexterm-anchor"></a><a id="d65966e2469" class="indexterm-anchor"></a><a id="d65966e2473" class="indexterm-anchor"></a>函数允许您从窗口中选择第一行和最后一行。这些行特别有价值，因为它们通常用作计算中的基线。例如，如果分区按日订购销售数据，您可能会问“每天的销售额与该期间的第一个销售日（ <code class="codeph">FIRST_VALUE</code> ）相比多少？“</p>
                           <p>如果<code class="codeph">IGNORE</code> <code class="codeph">NULLS</code>选项与使用<code class="codeph">FIRST_VALUE</code> ，它返回集合中的第一个非空值，或<code class="codeph">NULL</code>如果所有值均为<code class="codeph">NULL</code> 。如果<code class="codeph">IGNORE</code> <code class="codeph">NULLS</code>是使用<code class="codeph">LAST_VALUE</code> ，它返回集合中的最后一个非空值，或<code class="codeph">NULL</code>如果所有值均为<code class="codeph">NULL</code> 。 <code class="codeph">IGNORE</code> <code class="codeph">NULLS</code>选项在正确填充库存表时特别有用。
                           </p>
                           <p>这些函数的语法如下：</p><pre class="oac_no_warn" dir="ltr">FIRST_VALUE | LAST_VALUE（&lt;expr&gt;）[尊重NULLS | IGNORE NULLS] OVER（分析条款）;</pre></div>
                        <!-- class="section" -->
                        <div class="example" id="GUID-57FA7976-535D-4AA4-8452-B580F1E1EDC9__GUID-4D7E3C21-F8EE-4CCE-88E3-474C66026470">
                           <p class="titleinexample">例19-16 FIRST_VALUE</p>
                           <p>此示例说明了使用带有<code class="codeph">FIRST_VALUE</code>的<code class="codeph">IGNORE</code> <code class="codeph">NULLS</code>选项：</p><pre class="oac_no_warn" dir="ltr">SELECT prod_id，channel_id，time_id，CASE WHEN MIN（amount_sold）&gt; 9.5 THEN MIN（amount_sold）ELSE NULL END amount_sold，FIRST_VALUE（CASE WHEN MIN（amount_sold）&gt; 9.5 THEN min（amount_sold）ELSE NULL END）IGNORE NULLS OVER（PARTITION BY prod_id ORDER BY channel_id DESC，time_id在无限制前进和无限下行之间的行.nv FROM sales WHERE prod_id = 115 AND time_id BETWEEN '18 -DEC-01'和'22 -DEC-01'GROUP BY prod_id，channel_id，time_id ORDER BY prod_id ; PROD_ID CHANNEL_ID TIME_ID AMOUNT_SOLD NV ---------- ---------- --------- ----------- ----- ----- 115 4 18-DEC-01 9.66 115 4 19-DEC-01 9.66 115 4 20-DEC-01 9.66 115 4 22-DEC-01 9.66 115 3 18-DEC-01 9.66 9.66 115 3 19- DEC-01 9.66 9.66 115 3 20-DEC-01 9.66 9.66 115 3 21-DEC-01 9.66 9.66 115 3 22-DEC-01 9.66 9.66 115 2 18-DEC-01 9.67 9.66 115 2 19-DEC-01 9.67 9.66 115 2 21-DEC-01 9.67 9.66 115 2 22-DEC-01 9.67 9.66选择13行。</pre></div>
                        <!-- class="example" -->
                     </div>
                  </div><a id="DWHSG8701"></a><a id="DWHSG02017"></a><div class="props_rev_3"><a id="GUID-F543EB05-02DC-403F-ACDE-BCE72E5DA189" name="GUID-F543EB05-02DC-403F-ACDE-BCE72E5DA189"></a><h5 id="DWHSG-GUID-F543EB05-02DC-403F-ACDE-BCE72E5DA189" class="sect5"><span class="enumeration_section">19.2.5.2</span> NTH_VALUE函数</h5>
                     <div>
                        <div class="section">
                           <p><code class="codeph">NTH_VALUE</code>函数可以让您从窗口中的任意行中查找列值。例如，当您想要在一年内检索公司股票的第5个最高收盘价时，可以使用此方法。
                           </p>
                           <p><code class="codeph">LAG</code>和<code class="codeph">LEAD</code>函数可以被认为与<code class="codeph">NTH_VALUE</code>函数相关并简化了<code class="codeph">NTH_VALUE</code>函数。使用<code class="codeph">LAG</code>和<code class="codeph">LEAD</code> ，您只能从指定物理偏移量的行中检索值。如果这不够，可以使用<code class="codeph">NTH_VALUE</code> ，这使您可以根据所谓的逻辑偏移或相对位置从行中检索值。您可以将<code class="codeph">IGNORE</code> <code class="codeph">NULLS</code>选项与<code class="codeph">NTH_VALUE</code> ， <code class="codeph">FIRST_VALUE</code>和<code class="codeph">LAST_VALUE</code>函数一起使用，以使其更强大，因为您可以根据特定条件指定条件并过滤掉行。请参见<a href="sql-analysis-reporting-data-warehouses.html#GUID-F543EB05-02DC-403F-ACDE-BCE72E5DA189__BCFIBFFI">例19-17</a> ，其中过滤掉数量小于8的行。这不能用<code class="codeph">LAG</code>或<code class="codeph">LEAD</code> ，因为你不知<code class="codeph">LEAD</code>的偏移量。
                           </p>
                           <p>有关更多信息，请参见<a href="../sqlrf/NTH_VALUE.html#SQLRF30031" target="_blank"><span class="italic">Oracle数据库SQL语言参考</span></a> 。
                           </p>
                           <p>此函数的语法如下：</p><pre class="oac_no_warn" dir="ltr">NTH_VALUE（&lt;expr&gt;，&lt;n expr&gt;）[FROM FIRST |从最后] [尊重NULLS | IGNORE NULLS] OVER（&lt;窗口规范&gt;）</pre><ul style="list-style-type:disc">
                              <li>
                                 <p><code class="codeph">expr</code>可以是列，常量，绑定变量或涉及它们的表达式。
                                 </p>
                              </li>
                              <li>
                                 <p><code class="codeph">n</code>可以是列，常量，绑定变量或涉及它们的表达式。
                                 </p>
                              </li>
                              <li>
                                 <p><code class="codeph">RESPECT</code> <code class="codeph">NULLS</code>是默认的NULL处理机制。它确定<code class="codeph">expr</code>空值是否包含在计算中或从计算中消除。默认值为<code class="codeph">RESPECT</code> <code class="codeph">NULLS</code> 。</p>
                              </li>
                              <li>
                                 <p><code class="codeph">FROM</code> <code class="codeph">FIRST</code>和<code class="codeph">FROM</code> <code class="codeph">LAST</code>选项确定偏移量<code class="codeph">n</code>是来自第一行还是最后一行。默认值为<code class="codeph">FROM</code> <code class="codeph">FIRST</code> 。</p>
                              </li>
                              <li>
                                 <p><code class="codeph">IGNORE</code> <code class="codeph">NULLS</code>使您可以跳过度量值中的NULL。
                                 </p>
                              </li>
                           </ul>
                        </div>
                        <!-- class="section" -->
                        <div class="example" id="GUID-F543EB05-02DC-403F-ACDE-BCE72E5DA189__BCFIBFFI">
                           <p class="titleinexample">例19-17 NTH_VALUE</p>
                           <p>以下示例为每个<code class="codeph">prod_id</code>按升序返回第二个<code class="codeph">channel_id</code>的<code class="codeph">amount_sold</code>值，范围在10到20之间：</p><pre class="oac_no_warn" dir="ltr">SELECT prod_id，channel_id，MIN（amount_sold），NTH_VALUE（MIN（amount_sold），2）OVER（按照prod_id ORDER BY channel_id在无限制前进和无限制下行之间行进）NV FROM sales WHERE prod_id BETWEEN 10 AND 20 GROUP BY prod_id，channel_id; PROD_ID CHANNEL_ID MIN（AMOUNT_SOLD）NV ---------- ---------- ---------------- ------- --- 13 2 907.34 906.2 13 3 906.2 906.2 13 4 842.21 906.2 14 2 1015.94 1036.72 14 3 1036.72 1036.72 14 4 935.79 1036.72 15 2 871.19 871.19 15 3 871.19 871.19 15 4 871.19 871.19 16 2 266.84 266.84 16 3 266.84 266.84 16 4 266.84 266.84 16 9 11.99 266.84 ......</pre></div>
                        <!-- class="example" -->
                     </div>
                  </div>
               </div>
            </div><a id="DWHSG02015"></a><div class="props_rev_3"><a id="GUID-7070D54B-AB82-4FDC-8A38-28D6F4CA5525" name="GUID-7070D54B-AB82-4FDC-8A38-28D6F4CA5525"></a><h3 id="DWHSG-GUID-7070D54B-AB82-4FDC-8A38-28D6F4CA5525" class="sect3"><span class="enumeration_section">19.3</span>用于分析的高级聚合</h3>
               <div>
                  <p></p>
                  <p>Oracle数据库提供了多个SQL函数来执行高级聚合。另外，对于某些确切的函数，提供了返回近似结果的相应函数。</p>
                  <p>本节说明了以下高级分析聚合函数：</p>
                  <ul style="list-style-type:disc">
                     <li>
                        <p><a href="sql-analysis-reporting-data-warehouses.html#GUID-6A387B85-B347-4065-8A48-8F3E4AA91F87" title="使用返回近似结果的SQL函数计算近似聚合。它们主要用于数据探索查询，其中不需要精确值，并且可以接受近似值。">关于近似聚合</a></p>
                     </li>
                     <li>
                        <p><a href="sql-analysis-reporting-data-warehouses.html#GUID-EDBADEC3-4DC5-4A3A-85EF-B64C45910B1D" title="LISTAGG函数根据ORDER BY子句对每个组中的数据进行排序，然后连接度量列的值。">LISTAGG功能</a></p>
                     </li>
                     <li>
                        <p><a href="sql-analysis-reporting-data-warehouses.html#GUID-A0B6B93C-F8CB-4BEC-9069-C75C1797D027">第一个/最后一个功能</a></p>
                     </li>
                     <li>
                        <p><a href="sql-analysis-reporting-data-warehouses.html#GUID-E93D95F0-867B-4387-8F31-0831D23953DB" title="Oracle数据库提供了一组返回近似百分位数结果的SQL函数。这些功能可用于监控质量，跟踪社交媒体活动，监控性能以及搜索数据集中的异常值。">反百分位函数</a></p>
                     </li>
                     <li>
                        <p><a href="sql-analysis-reporting-data-warehouses.html#GUID-76DADC19-5E66-4857-99F7-509836BA44D5">假设等级函数</a></p>
                     </li>
                     <li>
                        <p><a href="sql-analysis-reporting-data-warehouses.html#GUID-175A5046-3326-4CA8-AC55-FF6BF54A4A51">线性回归函数</a></p>
                     </li>
                     <li>
                        <p><a href="sql-analysis-reporting-data-warehouses.html#GUID-399DBC4B-0CE6-49F7-87F2-5E74D83A1DB0">关于统计汇总</a></p>
                     </li>
                     <li>
                        <p><a href="sql-analysis-reporting-data-warehouses.html#GUID-04FC38D9-D651-4558-99D3-830255C958AF">关于用户定义的聚合</a></p>
                     </li>
                  </ul>
               </div>
               <div class="sect3"><a id="GUID-6A387B85-B347-4065-8A48-8F3E4AA91F87" name="GUID-6A387B85-B347-4065-8A48-8F3E4AA91F87"></a><h4 id="DWHSG-GUID-6A387B85-B347-4065-8A48-8F3E4AA91F87" class="sect4"><span class="enumeration_section">19.3.1</span>关于近似聚合</h4>
                  <div>
                     <p>使用返回近似结果的SQL函数计算近似聚合。它们主要用于数据探索查询，其中不需要精确值，并且可以接受近似值。</p>
                     <p></p>
                     <p><code class="codeph">APPROX_COUNT_DISTINCT</code>函数返回包含指定表达式的不同值的近似行数。<code class="codeph">APPROX_COUNT_DISTINCT_DETAIL</code>和<code class="codeph">APPROX_COUNT_DISTINCT_AGG</code>函数使您能够计算指定分组中近似不同值计数的不同聚合级别。这些聚合的结果可以存储在表或物化视图中，以便进一步分析或回答用户查询。
                     </p>
                     <p><code class="codeph">APPROX_COUNT_DISTINCT_DETAIL</code>函数以二进制格式创建基本级摘要，其中包含<code class="codeph">WHERE</code>子句中列出的所有维的元组。所述<code class="codeph">APPROX_COUNT_DISTINCT_AGG</code>函数使用由所述产生的数据<code class="codeph">APPROX_COUNT_DISTINCT_DETAIL</code>函数提取二进制格式上级元组。这样可以避免重新运行原始计算（在本例中，使用<code class="codeph">APPROX_COUNT_DISTINCT</code>进行计算）。使用二进制格式的聚合数据使用<code class="codeph">TO_APPROX_COUNT_DISTINCT</code>转换为人类可读格式。</p>
                     <p><a href="sql-analysis-reporting-data-warehouses.html#GUID-6A387B85-B347-4065-8A48-8F3E4AA91F87__GUID-5992DC0F-3A6C-43DB-A0FB-F2C4E771407E">图19-3</a>描述了使用<code class="codeph">APPROX_COUNT_DISTINCT_DETAIL</code>获取每月销售的大致不同产品数量的示例。从<code class="codeph">my_sales</code>表中选择的销售数据按年和月汇总，并使用如下查询存储在<code class="codeph">SALES_APPROX_MONTH</code>表中：</p><pre class="pre codeblock"><code>INSERT INTO sales_approx_month（SELECT年，月，APPROX_COUNT_DISTINCT_DETAIL（prod_id）about_month FROM my_sales GROUP BY year，month）;</code></pre><p>请注意，存储在<code class="codeph">approx_month</code>中的值是二进制值。使用<code class="codeph">TO_APPROX_COUNT_DISTINCT</code>函数以人类可读的格式显示这些二进制值。要显示不同数量销售的产品，按年份和月份汇总，使用<code class="codeph">TO_APPROX_COUNT_DISTINCT</code>的功能<code class="codeph">approx_month</code>列。要显示按年汇总的数据，请对存储在<code class="codeph">approx_month</code>列中的数据使用<code class="codeph">TO_APPROX_COUNT_DISTINCT</code>函数和<code class="codeph">APPROX_COUNT_DISTINCT_AGG</code>函数。
                     </p>
                     <p></p>
                     <div class="figure" id="GUID-6A387B85-B347-4065-8A48-8F3E4AA91F87__GUID-5992DC0F-3A6C-43DB-A0FB-F2C4E771407E">
                        <p class="titleinfigure">图19-3使用SQL函数显示近似聚合</p><img src="img/dwhsg_3p_001.png" alt="下面是图19-3的描述" title="下面是图19-3的描述" longdesc="img_text/dwhsg_3p_001.html"><br><a href="img_text/dwhsg_3p_001.html">“图19-3使用SQL函数显示近似聚合”的描述</a></div>
                     <!-- class="figure" -->
                     <p>计算每年销售的不同产品的近似数量的另一种方法可以是使用<code class="codeph">APPROX_COUNT_DISTINCT_AGG</code>来聚合存储在<code class="codeph">SALES_APPROX_MONTH</code>表中的每月详细信息，并将结果存储在表或物化视图中。
                     </p>
                     <div class="section">
                        <p class="subhead3" id="GUID-6A387B85-B347-4065-8A48-8F3E4AA91F87__GUID-73F9427B-C7EF-4B31-8BAB-4EA4AB721849">返回近似百分位数结果的SQL函数的属性</p>
                        <p>提供近似百分位数结果的SQL函数包括<code class="codeph">APPROX_PERCENTILE</code> ， <code class="codeph">APPROX_PERCENTILE_DETAIL</code>和<code class="codeph">APPROX_PERCENTILE_AGG</code> 。这些函数具有以下附加属性：</p>
                        <ul style="list-style-type:disc">
                           <li>
                              <p><code class="codeph">ERROR_RATE</code></p>
                              <p>通过计算近似计算的误差率来指示插值百分位数值的准确性</p>
                           </li>
                           <li>
                              <p><code class="codeph">置信度</code></p>
                              <p>表示对错误率准确性的置信度（指定错误率时）</p>
                           </li>
                           <li>
                              <p><code class="codeph">确定性</code></p>
                              <p>控制用于计算近似值的算法</p>
                              <p>如果您需要一致且可重复的结果，请使用<code class="codeph">DETERMINISTIC</code> 。这通常是需要与其他用户共享结果的情况</p>
                           </li>
                        </ul>
                        <div class="infoboxnotealso" id="GUID-6A387B85-B347-4065-8A48-8F3E4AA91F87__GUID-63018AE7-1235-4BB7-8B93-160CB4D9C01B">
                           <p class="notep1">也可以看看：</p>
                           <ul style="list-style-type:disc">
                              <li>
                                 <p><a href="sql-analysis-reporting-data-warehouses.html#GUID-E8AF7908-979A-49F2-B845-D9A5010BE863" title="Oracle数据库提供了一组返回近似百分位数结果的SQL函数。这些功能可用于监控质量，跟踪社交媒体活动，监控性能以及搜索数据集中的异常值。">使用返回近似结果的百分位函数</a></p>
                              </li>
                              <li>
                                 <p><a href="../sqlrf/APPROX_COUNT_DISTINCT.html#SQLRF56900" target="_blank"><span><cite>Oracle数据库SQL语言参考中的</cite></span></a> <code class="codeph">APPROX_COUNT_DISTINCT</code></p>
                              </li>
                              <li>
                                 <p>有关函数和<code class="codeph">ERROR_RATE</code> ， <code class="codeph">CONFIDENCE</code>和<code class="codeph">DETERMINISTIC</code>属性的信息，请<code class="codeph">APPROX_COUNT_DISTINCT_DETAIL</code> <a href="../sqlrf/APPROX_COUNT_DISTINCT_DETAIL.html#SQLRF-GUID-8FBD2881-743D-425E-A104-472A720DEF50" target="_blank"><span><cite>Oracle数据库SQL语言参考中的</cite></span></a> <code class="codeph">APPROX_COUNT_DISTINCT_DETAIL</code></p>
                              </li>
                              <li>
                                 <p><a href="../sqlrf/APPROX_COUNT_DISTINCT_AGG.html#SQLRF-GUID-EEDA9388-A066-422A-B5C0-639A3076A10B" target="_blank"><span><cite>Oracle数据库SQL语言参考中的</cite></span></a> <code class="codeph">APPROX_COUNT_DISTINCT_AGG</code></p>
                              </li>
                              <li>
                                 <p><a href="../sqlrf/TO_APPROX_COUNT_DISTINCT.html#SQLRF-GUID-42A18FFB-C992-44A0-AC3E-F4BBF005846F" target="_blank"><span><cite>Oracle数据库SQL语言参考中的</cite></span></a> <code class="codeph">TO_APPROX_COUNT_DISTINCT</code></p>
                              </li>
                           </ul>
                        </div>
                     </div>
                     <!-- class="section" -->
                  </div>
               </div><a id="DWHSG8702"></a><div class="props_rev_3"><a id="GUID-EDBADEC3-4DC5-4A3A-85EF-B64C45910B1D" name="GUID-EDBADEC3-4DC5-4A3A-85EF-B64C45910B1D"></a><h4 id="DWHSG-GUID-EDBADEC3-4DC5-4A3A-85EF-B64C45910B1D" class="sect4"><span class="enumeration_section">19.3.2</span> LISTAGG功能</h4>
                  <div>
                     <p><code class="codeph">LISTAGG</code>函数根据<code class="codeph">ORDER</code> <code class="codeph">BY</code>子句对每个组中的数据进行<code class="codeph">ORDER</code> ，然后连接度量列的值。
                     </p>
                     <div class="section">
                        <p></p>
                        <p>在Oracle Database 12 <span class="italic">c</span> Release 2（12.2）之前的版本中，如果<code class="codeph">LISTAGG</code>函数返回的连接值超过返回数据类型支持的最大长度，则返回以下错误：</p><code class="codeph">ORA-01489：字符串连接的结果太长</code><p>从Oracle Database 12 <span class="italic">c</span>第2版（12.2）开始，您可以截断返回字符串以适应返回数据类型支持的最大长度，并显示截断文字以指示返回值被截断。在最后一个完整数据值之后执行截断，从而确保不显示不完整的数据值。
                        </p>
                        <p><code class="codeph">LISTAGG</code>函数的语法如下：</p><pre class="oac_no_warn" dir="ltr">LISTAGG（[ALL] [DISTINCT] &lt;measure_column&gt; [，&lt;delimiter&gt;] [ON OVERFLOW TRUNCATE [truncate_literal] | ON OVERFLOW ERROR [WITH | WITHOUT COUNT]]）WITHIN GROUP（ORDER BY &lt;oby_expression_list&gt;）</pre><p></p>
                        <p><code class="codeph">DISTINCT</code>从列表中删除重复的值。
                        </p>
                        <p><code class="codeph">measure_column</code>可以是列，常量，绑定变量或涉及它们的表达式。
                        </p>
                        <p>如果返回字符串不符合数据类型支持的最大长度，则可以显示错误或截断返回字符串并显示截断文字。默认值为<code class="codeph">ON OVERFLOW ERROR</code> ，在发生截断时显示错误。
                        </p>
                        <p><code class="codeph">truncate_literal</code>可以是<code class="codeph">NULL</code> ，字符串文字或常量表达式。它附加到值列表的末尾，在最后一个分隔符之后，当<code class="codeph">LISTAGG</code>返回的值大于返回数据类型支持的最大长度时。默认值是省略号（...）。
                        </p>
                        <p><code class="codeph">WITH COUNT</code>显示从<code class="codeph">LISTAGG</code>输出中截断的数据值的数量，因为超出了返回数据类型支持的最大长度。这是默认选项。当字符串被截断时，使用<code class="codeph">WITHOUT COUNT</code>忽略在<code class="codeph">LISTAGG</code>函数末尾显示计数。
                        </p>
                        <p><code class="codeph">delimiter</code>可以是<code class="codeph">NULL</code> （默认值），字符串文字，绑定变量或常量表达式。这是一个必需参数。如果未指定分隔符，则使用<code class="codeph">NULL</code>作为分隔符。
                        </p>
                        <p><code class="codeph">oby_expression_list</code>可以是具有可选排序选项的表达式列表，以按升序或降序排序（ <code class="codeph">ASC</code>或<code class="codeph">DESC</code> ），并控制NULL的排序顺序（ <code class="codeph">NULLS</code> <code class="codeph">FIRST</code>或<code class="codeph">NULLS</code> <code class="codeph">LAST</code> ）。<code class="codeph">ASCENDING</code>和<code class="codeph">NULLS</code> <code class="codeph">LAST</code>是默认值。
                        </p>
                        <div class="infoboxnotealso" id="GUID-EDBADEC3-4DC5-4A3A-85EF-B64C45910B1D__GUID-6A8C1DFE-398F-44D1-9BA4-73DD34C3EF06">
                           <p class="notep1">也可以看看：</p>
                           <p>有关<code class="codeph">VARCHAR2</code>数据类型支持的最大长度的信息，请<a href="../sqlrf/Data-Types.html#SQLRF50977" target="_blank"><span><cite>参见Oracle数据库SQL语言参考</cite></span></a></p>
                        </div>
                     </div>
                     <!-- class="section" -->
                  </div><a id="DWHSG8703"></a><a id="DWHSG8954"></a><div class="props_rev_3"><a id="GUID-7198204A-6134-478D-B582-D3F1DCB7FF43" name="GUID-7198204A-6134-478D-B582-D3F1DCB7FF43"></a><h5 id="DWHSG-GUID-7198204A-6134-478D-B582-D3F1DCB7FF43" class="sect5"><span class="enumeration_section">19.3.2.1</span> LISTAGG作为聚合</h5>
                     <div>
                        <p>您可以将<code class="codeph">LISTAGG</code>函数用作聚合。
                        </p>
                        <div class="example" id="GUID-7198204A-6134-478D-B582-D3F1DCB7FF43__GUID-B9BF97CF-C816-408B-924F-5DCD113759F0">
                           <p class="titleinexample">例19-18 LISTAGG作为聚合</p>
                           <p>以下示例说明如何使用<code class="codeph">LISTAGG</code>作为聚合。
                           </p><pre class="oac_no_warn" dir="ltr">SELECT prod_id，LISTAGG（cust_first_name ||''|| cust_last_name，';'）WITHIN GROUP（ORDER BY amount_sold DESC）cust_list FROM sales，customers WHERE sales.cust_id = customers.cust_id AND cust_gender ='M'AND cust_credit_limit = 15000 AND prod_id BETWEEN 15和18 AND channel_id = 2 AND time_id&gt; '01 -JAN-01'GROUP BY prod_id; PROD_ID CUST_LIST ------- ----------------------------------------- ------ 15希望哈伯; Roxanne Crocker; ...Mason Murray 16 Manvil Austin; Bud Pinkston; ...Helga Nickols 17 Opal Aaron; Thacher Rudder; ...Roxanne Crocker 18 Boyd Lin; Bud Pinkston; ...Erik准备好了</pre><p>输出已被修改以便于阅读。在这种情况下，省略号表示从输出中省略了最后一个客户名称之前的某些值。</p>
                        </div>
                        <!-- class="example" -->
                        <div class="example" id="GUID-7198204A-6134-478D-B582-D3F1DCB7FF43__GUID-38B6E5BF-7764-404A-8A62-CD056E27FDD1">
                           <p class="titleinexample">例19-19带有返回字符串的LISTAGG超过允许的最大长度</p>
                           <p></p>
                           <p>此示例对<code class="codeph">GROUP BY</code>子句指定的每个组中的数据进行<code class="codeph">cust_first_name</code> ，并连接<code class="codeph">cust_first_name</code>和<code class="codeph">cust_last_name</code>列中的值。如果连接名称列表超出<code class="codeph">VARCHAR2</code>数据类型支持的最大长度，则列表将截断为最后一个完整名称。在列表的末尾，附加溢出文字“...”，后跟被截断的值的数量。
                           </p><pre class="pre codeblock"><code>SELECT country_region，LISTAGG（s。CUST_FIRST_NAME ||” “||秒。CUST_LAST_NAME，';' ON COUNT）WITH WITH GROUP（ORDER BY s.cust_id）AS customer_names FROM countries c，customers s WHERE c.country_id = s.country_id GROUP BY c.country_region ORDER BY c.country_region; COUNTRY_REGION -------------------- CUSTOMER_NAMES ---------------------------- -------------------------------------------------- - 非洲Laurice Lincoln; Kirsten Newkirk; Verna Yarborough; Chloe Dwyer; Betty Sampler; Terry Hole; Waren Parkburg; Uwe Feldman; Douglas Hanson; Woodrow Lazar; Alfred Doctor; Stac。。Zwolinsky; Buzz Milenova; Abbie Venkayala COUNTRY_REGION -------------------- CUSTOMER_NAMES --------------------- -------------------------------------------------- --------- Americas Linette Ingram; Vida Puleo; Gertrude Atkins; Sibil Haul; Raina Cassidy; Kaula Daley; G abriela Sean; Dolores Moore; Erica Vandermark; Madallyn Ladd; Carolyn Hinkle; Leonora。。emphill; Urban Smyth; Murry Ivy; Steven Lauers; ......（21482）COUNTRY_REGION -------------------- CUSTOMER_NAMES -------------------------- -------------------------------------------------- ----亚洲Harriett Charles; Willa Fitz; Faith Fischer; Gay Nance; Maggie Cain; Neda Clatterbuck; Justa Killman; Penelope Oliver; Mandisa Grandy; Marette Overton; Astrid Rice; Poppy。。ob Gentile; Lynn Hardesty; Mabel Barajas; ......（1648）COUNTRY_REGION -------------------- CUSTOMER_NAMES -------------------------- -------------------------------------------------- ----欧洲Abigail Kessel; Anne Koch;别克Emmerson; Frank Hardy; Macklin Gowen; Rosamond Kride r; Raina Silverberg; Gloria Saintclair; Macy Littlefield; Yuri Finch; Bertilde Sexton。。el Floyd; Lincoln Sean; Morel Gregory; Kane Speer; ......（30284）COUNTRY_REGION -------------------- CUSTOMER_NAMES -------------------------- -------------------------------------------------- ----中东Dalila Rockwell; Alma Elliott; Cara Jeffreys; Joy Sandstrum; Elizabeth Barone; Whitby Burnns; Geoffrey Door; Austin Dutton; Tobin Newcomer; Blake Overton; Lona Kimball; Lo。。edy; Brandon Moy;悉尼Fenton COUNTRY_REGION -------------------- CUSTOMER_NAMES --------------------- -------------------------------------------------- --------- Oceania Fredericka Umstatt; Viola Nettles; Alyce Reagan; Catherine Odenwalld; Mauritia Linde green; Heidi Schmidt; Ray Wade; Cicily Graham; Myrtle Joseph; Joan Morales; Brenda Obr。。; Fredie Elgin; Gilchrist Lease; Guthrey Cain; ......（793）选择了6行。</code></pre></div>
                        <!-- class="example" -->
                        <div class="example" id="GUID-7198204A-6134-478D-B582-D3F1DCB7FF43__GUID-4F73EDD7-58B0-4C65-B789-84C79177CBDD">
                           <p class="titleinexample">示例19-20使用DISTINCT删除重复值的LISTAGG</p>
                           <p></p>
                           <p></p>
                           <p>此示例对<code class="codeph">GROUP BY</code>子句指定的每个组中的数据进行<code class="codeph">prod_cateogry</code> ，并连接<code class="codeph">prod_cateogry</code>和<code class="codeph">prod_desc</code>列中的值。如果连接名称列表超出<code class="codeph">VARCHAR2</code>数据类型支持的最大长度，则列表将截断为最后一个完整字符串。<code class="codeph">DISTINCT</code>关键字指定必须删除指定度量列中的重复值。
                           </p><pre class="pre codeblock"><code>SELECT cust_id，LISTAGG（DISTINCT prod_category ||'：'|| prod_desc，';'ON OVERFLOW TRUNCATE WITH COUNT）WITHIN GROUP（ORDER BY amount_sold）FROM sh.sales，sh.products WHERE sales.prod_id = products.prod_id AND amount_sold &gt; 200 AND products.prod_id BETWEEN 10和15 AND time_id&gt; '01 -JAN-01'GROUP BY cust_id;</code></pre></div>
                        <!-- class="example" -->
                     </div>
                  </div><a id="DWHSG8704"></a><a id="DWHSG8955"></a><div class="props_rev_3"><a id="GUID-B109E43C-63D9-4079-A24E-AB87DAED0262" name="GUID-B109E43C-63D9-4079-A24E-AB87DAED0262"></a><h5 id="DWHSG-GUID-B109E43C-63D9-4079-A24E-AB87DAED0262" class="sect5"><span class="enumeration_section">19.3.2.2</span> LISTAGG作为报告聚合</h5>
                     <div>
                        <p>您可以使用<code class="codeph">LISTAGG</code>功能作为报告聚合。
                        </p>
                        <div class="example" id="GUID-B109E43C-63D9-4079-A24E-AB87DAED0262__GUID-37B1F930-6441-4068-B1E4-95706D1496FD">
                           <p class="titleinexample">示例19-21 LISTAGG作为报告聚合</p>
                           <p>此示例说明了使用<code class="codeph">LISTAGG</code>作为报告聚合。它为每个时间段内的每个产品提取最低的单位成本。
                           </p><pre class="oac_no_warn" dir="ltr">连接sh / sh设置行120页20000列列表格式A40 SELECT time_id，prod_id，LISTAGG（MIN（unit_cost），';'）WITHIN GROUP（ORDER BY prod_id）OVER（PARTITION BY time_id）lowest_unit_cost FROM sh.sales_transactions_ext WHERE time_id BETWEEN '20 -DEC-01'和'22 -DEC-01'和prod_id在120和125 GROUP之间由time_id，prod_id; TIME_ID PROD_ID LOWEST_UNIT_COST --------- ---------- ---------------------------- ------- 20-DEC-01 121 9.11; 9.27; 15.84; 43.95 20-DEC-01 122 9.11; 9.27; 15.84; 43.95 20-DEC-01 123 9.11; 9.27; 15.84; 43.95 21-DEC- 01 120 9.11; 9.27 21-DEC-01 121 9.11; 9.27 22-DEC-01 120 9.11; 9.27; 15.84; 43.95; 16.06; 12.66 22-DEC-01 121 9.11; 9.27; 15.84; 43.95; 16.06; 12.66 22- DEC-01 122 9.11; 9.27; 15.84; 43.95; 16.06; 12.66 22-DEC-01 123 9.11; 9.27; 15.84; 43.95; 16.06; 12.66 22-DEC-01 124 9.11; 9.27; 15.84; 43.95; 16.06; 12.66 22 -DEC-01 125 9.11; 9.27; 15.84; 43.95; 16.06; 12.66</pre></div>
                        <!-- class="example" -->
                     </div>
                  </div>
               </div><a id="DWHSG0205"></a><div class="props_rev_3"><a id="GUID-A0B6B93C-F8CB-4BEC-9069-C75C1797D027" name="GUID-A0B6B93C-F8CB-4BEC-9069-C75C1797D027"></a><h4 id="DWHSG-GUID-A0B6B93C-F8CB-4BEC-9069-C75C1797D027" class="sect4"><span class="enumeration_section">19.3.3第</span>一个/最后一个功能</h4>
                  <div>
                     <div class="section">
                        <p><a id="d65966e3295" class="indexterm-anchor"></a><a id="d65966e3297" class="indexterm-anchor"></a> <code class="codeph">FIRST/LAST</code>聚合函数允许您对数据集进行排名，并使用其排名靠前或排名靠后的行。找到排名靠前或排名最低的行后，会将聚合函数应用于任何所需的列。也就是说， <code class="codeph">FIRST</code> / <code class="codeph">LAST</code>允许您对列A进行排名，但返回应用于列B的排名第一或排名最后的行的聚合结果。这很有价值，因为它避免了对自联接或子查询的需要，从而提高性能。这些函数的语法以常规聚合函数（ <code class="codeph">MIN</code> ， <code class="codeph">MAX</code> ， <code class="codeph">SUM</code> ， <code class="codeph">AVG</code> ， <code class="codeph">COUNT</code> ， <code class="codeph">VARIANCE</code> ， <code class="codeph">STDDEV</code> ）开始，每个组产生一个返回值。要指定使用的排名， <code class="codeph">FIRST</code> / <code class="codeph">LAST</code>函数会添加一个以<code class="codeph">KEEP</code>开头的新子句。</p>
                        <p>这些函数具有以下语法：</p><pre class="oac_no_warn" dir="ltr">aggregate_function KEEP（DENSE_RANK FIRST |最后一次按expr [DESC | ASC] [NULLS {FIRST | LAST}] [，expr [DESC | ASC] [NULLS {FIRST | LAST}]] ......）[OVER query_partitioning_clause]</pre><p>请注意， <code class="codeph">ORDER</code> <code class="codeph">BY</code>子句可以使用多个表达式。
                        </p>
                        <p>本节包含以下主题：</p>
                        <ul style="list-style-type:disc">
                           <li>
                              <p><a href="sql-analysis-reporting-data-warehouses.html#GUID-41554140-82EB-41C0-8FE1-D0C090715727">第一个/最后一个作为常规聚合</a></p>
                           </li>
                           <li>
                              <p><a href="sql-analysis-reporting-data-warehouses.html#GUID-0C122B2B-6D38-43A3-80CC-A9425A50946E">第一个/最后一个报告聚合</a></p>
                           </li>
                        </ul>
                     </div>
                     <!-- class="section" -->
                  </div><a id="DWHSG8706"></a><a id="DWHSG8705"></a><div class="props_rev_3"><a id="GUID-41554140-82EB-41C0-8FE1-D0C090715727" name="GUID-41554140-82EB-41C0-8FE1-D0C090715727"></a><h5 id="DWHSG-GUID-41554140-82EB-41C0-8FE1-D0C090715727" class="sect5"><span class="enumeration_section">19.3.3.1</span>作为常规聚合的第一个/最后一个</h5>
                     <div>
                        <p>您可以将<code class="codeph">FIRST</code> / <code class="codeph">LAST</code>系列聚合用作常规聚合函数。
                        </p>
                        <div class="example" id="GUID-41554140-82EB-41C0-8FE1-D0C090715727__i1007076">
                           <p class="titleinexample">例19-22第一个/最后一个例子1</p>
                           <p>以下查询可让我们比较产品的最低价格和定价。对于男士服装类别中的每个产品子类别，它返回以下内容：</p>
                           <ul style="list-style-type:disc">
                              <li>
                                 <p>最低价格的产品的价格</p>
                              </li>
                              <li>
                                 <p>最低价格</p>
                              </li>
                              <li>
                                 <p>最低价格最高的产品的价格</p>
                              </li>
                              <li>
                                 <p>最低的最低价格</p>
                              </li>
                           </ul><pre class="oac_no_warn" dir="ltr">SELECT prod_subcategory，MIN（prod_list_price）KEEP（DENSE_RANK FIRST ORDER BY（prod_min_price））AS LP_OF_LO_MINP，MIN（prod_min_price）AS LO_MINP，MAX（prod_list_price）KEEP（DENSE_RANK LAST ORDER BY（prod_min_price））AS LP_OF_HI_MINP，MAX（prod_min_price）AS HI_MINP FROM products WHERE prod_category ='Electronics'GROUP BY prod_subcategory; PROD_SUBCATEGORY LP_OF_LO_MINP LO_MINP LP_OF_HI_MINP HI_MINP ---------------- ------------- ------- --------- ---- ----------游戏机299.99 299.99 299.99 299.99家用音响499.99 499.99 599.99 599.99 Y盒配件7.99 7.99 20.99 20.99 Y盒游戏7.99 7.99 29.99 29.99</pre></div>
                        <!-- class="example" -->
                     </div>
                  </div><a id="DWHSG8708"></a><a id="DWHSG8707"></a><div class="props_rev_3"><a id="GUID-0C122B2B-6D38-43A3-80CC-A9425A50946E" name="GUID-0C122B2B-6D38-43A3-80CC-A9425A50946E"></a><h5 id="DWHSG-GUID-0C122B2B-6D38-43A3-80CC-A9425A50946E" class="sect5"><span class="enumeration_section">19.3.3.2</span>作为报告聚合的第一个/最后一个</h5>
                     <div>
                        <p>您还可以使用<code class="codeph">FIRST</code> / <code class="codeph">LAST</code>系列聚合作为报告聚合函数。一个例子是计算全年人头数增幅最大和最少的几个月。这些函数的语法类似于任何其他报告聚合的语法。
                        </p>
                        <p>考虑<a href="sql-analysis-reporting-data-warehouses.html#GUID-41554140-82EB-41C0-8FE1-D0C090715727__i1007076">例19-22</a>中<code class="codeph">FIRST/LAST</code>的例子。如果您想查找单个产品的清单价格并将其与子类别中具有最高和最低价格的产品的清单价格进行比较，该怎么办？
                        </p>
                        <p>以下查询允许我们使用<code class="codeph">FIRST/LAST</code>作为报告聚合来查找Documentation子类别的信息。
                        </p>
                        <div class="example" id="GUID-0C122B2B-6D38-43A3-80CC-A9425A50946E__GUID-F5C30676-A133-4E8D-9795-1E7006928695">
                           <p class="titleinexample">例19-23第一个/最后一例2</p><pre class="oac_no_warn" dir="ltr">SELECT prod_id，prod_list_price，MIN（prod_list_price）KEEP（DENSE_RANK FIRST ORDER BY（prod_min_price））OVER（PARTITION BY（prod_subcategory））AS LP_OF_LO_MINP，MAX（prod_list_price）KEEP（DENSE_RANK LAST BYDER BY（prod_min_price））OVER（PARTITION BY（prod_subcategory） ））AS LP_OF_HI_MINP FROM产品WHERE prod_subcategory ='文档'; PROD_ID PROD_LIST_PRICE LP_OF_LO_MINP LP_OF_HI_MINP ---------- --------------- ------------- -------- ----- 40 44.99 44.99 44.99 41 44.99 44.99 44.99 42 44.99 44.99 44.99 43 44.99 44.99 44.99 44 44.99 44.99 44.99 45 44.99 44.99 44.99</pre><p>使用<code class="codeph">FIRST</code>和<code class="codeph">LAST</code>函数作为报告聚合，可以轻松地将结果包含在计算中，例如“薪资作为最高薪水的百分比”。</p>
                        </div>
                        <!-- class="example" -->
                     </div>
                  </div>
               </div><a id="DWHSG0206"></a><div class="props_rev_3"><a id="GUID-E93D95F0-867B-4387-8F31-0831D23953DB" name="GUID-E93D95F0-867B-4387-8F31-0831D23953DB"></a><h4 id="DWHSG-GUID-E93D95F0-867B-4387-8F31-0831D23953DB" class="sect4"><span class="enumeration_section">19.3.4</span>反百分位函数</h4>
                  <div>
                     <div class="section">
                        <p>使用<code class="codeph">CUME_DIST</code>函数，您可以找到一组值的累积分布（百分位数）。然而，逆操作（找到什么值计算到某个百分位数）既不容易做也不有效计算。为了克服这个困难，引入了<code class="codeph">PERCENTILE_CONT</code>和<code class="codeph">PERCENTILE_DISC</code>函数。这些既可以用作窗口报告功能，也可以用作普通的聚合功能。
                        </p>
                        <p>这些函数需要一个排序规范和一个参数，该百分位值介于0和1之间。通过使用带有一个表达式的<code class="codeph">ORDER</code> <code class="codeph">BY</code>子句来处理排序规范。当用作普通聚合函数时，它为每个有序集返回单个值。
                        </p>
                        <p><code class="codeph">PERCENTILE_CONT</code>是通过插值计算的连续函数， <code class="codeph">PERCENTILE_DISC</code>是一个假定离散值的阶跃函数。与其他聚合一样， <code class="codeph">PERCENTILE_CONT</code>和<code class="codeph">PERCENTILE_DISC</code>对分组查询中的一组行进行操作，但有以下区别：</p>
                        <ul style="list-style-type:disc">
                           <li>
                              <p>它们需要0到1（含）之间的参数。超出此范围指定的参数会导致错误。应将此参数指定为计算为常量的表达式。</p>
                           </li>
                           <li>
                              <p>它们需要排序规范。此排序规范是带有单个表达式的<code class="codeph">ORDER</code> <code class="codeph">BY</code>子句。不允许使用多个表达式。
                              </p>
                           </li>
                        </ul>
                        <p></p>
                        <p>从Oracle Database 12 <span class="italic">c</span>第2版（12.2）开始，近似逆分布函数<code class="codeph">APPROX_PERCENTILE</code>返回一个近似插值，该值将根据排序规范落入该百分位数值。
                        </p>
                        <div class="infoboxnotealso" id="GUID-E93D95F0-867B-4387-8F31-0831D23953DB__GUID-CE08622C-9A48-4FC6-8366-24BD4AD7E21C">
                           <p class="notep1">也可以看看：</p>
                           <ul style="list-style-type:disc">
                              <li>
                                 <p><a href="sql-analysis-reporting-data-warehouses.html#GUID-D8F6C15D-6A66-468F-9496-78AFB40BBCD2">正常聚合语法</a></p>
                              </li>
                              <li>
                                 <p><a href="sql-analysis-reporting-data-warehouses.html#GUID-5E107F21-385F-43A2-9DC2-98E8D95B42D1">逆百分位示例基础</a></p>
                              </li>
                              <li>
                                 <p><a href="sql-analysis-reporting-data-warehouses.html#GUID-464D983C-761D-428F-8AA5-587FDE7F5B54">作为报告聚合</a></p>
                              </li>
                              <li>
                                 <p><a href="sql-analysis-reporting-data-warehouses.html#GUID-A5FA1D4D-1B5F-41CA-9384-649E4654523F">逆百分位函数的限制</a></p>
                              </li>
                              <li>
                                 <p><a href="sql-analysis-reporting-data-warehouses.html#GUID-E8AF7908-979A-49F2-B845-D9A5010BE863" title="Oracle数据库提供了一组返回近似百分位数结果的SQL函数。这些功能可用于监控质量，跟踪社交媒体活动，监控性能以及搜索数据集中的异常值。">使用返回近似结果的百分位函数</a></p>
                              </li>
                           </ul>
                        </div>
                     </div>
                     <!-- class="section" -->
                  </div><a id="DWHSG8709"></a><div class="props_rev_3"><a id="GUID-D8F6C15D-6A66-468F-9496-78AFB40BBCD2" name="GUID-D8F6C15D-6A66-468F-9496-78AFB40BBCD2"></a><h5 id="DWHSG-GUID-D8F6C15D-6A66-468F-9496-78AFB40BBCD2" class="sect5"><span class="enumeration_section">19.3.4.1</span>正常聚合语法</h5>
                     <div>
                        <div class="section"><pre class="oac_no_warn" dir="ltr">[PERCENTILE_CONT | PERCENTILE_DISC]（ <span class="italic">常量表达式</span> ）WITHIN GROUP（ORDER BY <span class="italic">单个表达式</span> [ASC | DESC] [NULLS FIRST | NULLS LAST]）</pre></div>
                        <!-- class="section" -->
                     </div>
                  </div><a id="DWHSG8710"></a><div class="props_rev_3"><a id="GUID-5E107F21-385F-43A2-9DC2-98E8D95B42D1" name="GUID-5E107F21-385F-43A2-9DC2-98E8D95B42D1"></a><h5 id="DWHSG-GUID-5E107F21-385F-43A2-9DC2-98E8D95B42D1" class="sect5"><span class="enumeration_section">19.3.4.2</span>反百分位示例基础</h5>
                     <div>
                        <p>使用以下查询返回本节示例中使用的17行数据：</p><pre class="oac_no_warn" dir="ltr">SELECT cust_id，cust_credit_limit，CUME_DIST（）OVER（ORDER BY cust_credit_limit）AS CUME_DIST FROM customers WHERE cust_city ='Marshal'; CUST_ID CUST_CREDIT_LIMIT CUME_DIST ---------- ----------------- ---------- 28344 1500 .173913043 8962 1500 .173913043 36651 1500 .173913043 32497 1500 .173913043 15192 3000 .347826087 102077 3000 .347826087 102343 3000 .347826087 8270 3000 .347826087 21380 5000 .52173913 13808 5000 .52173913 101784 5000 .52173913 30420 5000 .52173913 10346 7000 .652173913 31112 7000 .652173913 35266 7000 .652173913 3424 9000 .739130435 100977 9000 .739130435 103066 10000 .782608696 35225 11000 .956521739 14459 11000 .956521739 17268 11000 .956521739 100421 11000 .956521739 41496 15000 1</pre><p>通过扫描每组中的<code class="codeph">CUME_DIST</code>值来计算<code class="codeph">PERCENTILE_DISC</code> （ <code class="codeph">x</code> ），直到找到大于或等于<code class="codeph">x</code>的第一个值，其中<code class="codeph">x</code>是指定的百分位值。对于<code class="codeph">PERCENTILE_DISC(0.5)</code>的示例查询，结果为5,000，如下所示：</p><pre class="oac_no_warn" dir="ltr">SELECT PERCENTILE_DISC（0.5）WITHIN GROUP（ORDER BY cust_credit_limit）AS perc_disc，PERCENTILE_CONT（0.5）WITHIN GROUP（ORDER BY cust_credit_limit）AS perc_cont FROM customers WHERE cust_city ='Marshal'; PERC_DISC PERC_CONT --------- --------- 5000 5000</pre><p><code class="codeph">PERCENTILE_CONT</code>的结果是在排序后通过行之间的线性插值计算的。要计算<code class="codeph">PERCENTILE_CONT(x)</code> ，首先要计算行数= <code class="codeph">RN</code> =（1 + x *（n-1）），其中<span class="italic">n</span>是组中的行数， <span class="italic">x</span>是指定的百分位数值。通过行号<code class="codeph">CRN = CEIL(RN)</code>和<code class="codeph">FRN = FLOOR(RN)</code>行之间的线性插值来计算聚合函数的最终结果。
                        </p>
                        <p>最终结果是： <code class="codeph">PERCENTILE_CONT(X)</code> = if（ <code class="codeph">CRN = FRN = RN</code> ），则（来自<code class="codeph">RN</code>行的表达式值）else（ <code class="codeph">CRN - RN</code> ）*（ <code class="codeph">FRN</code>行的表达式值）+（ <code class="codeph">RN -FRN</code> ）*（ <code class="codeph">CRN</code>行的表达式值）。
                        </p>
                        <p>考虑前面的示例查询，您可以在其中计算<code class="codeph">PERCENTILE_CONT(0.5)</code> 。这里<span class="italic">n</span>是17。两个组的行号<code class="codeph">RN</code> =（1 + 0.5 *（n-1））= 9。将其放入公式中，（ <code class="codeph">FRN=CRN=9</code> ），您将从第9行返回值作为结果。
                        </p>
                        <p>另一个例子是，如果你想计算<code class="codeph">PERCENTILE_CONT</code> <code class="codeph">(0.66)</code> 。计算出的行数<code class="codeph">RN</code> =（1 + 0.66 *（ <code class="codeph">n</code> -1））=（1 + 0.66 * 16）= 11.67。<code class="codeph">PERCENTILE_CONT</code> （0.66）=（12-11.67）*（第11行的值）+（11.67-11）*（第12行的值）。这些结果是：</p><pre class="oac_no_warn" dir="ltr">SELECT PERCENTILE_DISC（0.66）WITHIN GROUP（ORDER BY cust_credit_limit）AS perc_disc，PERCENTILE_CONT（0.66）WITHIN GROUP（ORDER BY cust_credit_limit）AS perc_cont FROM customers WHERE cust_city ='Marshal'; PERC_DISC PERC_CONT ---------- ---------- 9000 8040</pre><p>反向百分位聚合函数可以像其他现有聚合函数一样出现在查询的<code class="codeph">HAVING</code>子句中。
                        </p>
                     </div>
                  </div><a id="DWHSG8711"></a><div class="props_rev_3"><a id="GUID-464D983C-761D-428F-8AA5-587FDE7F5B54" name="GUID-464D983C-761D-428F-8AA5-587FDE7F5B54"></a><h5 id="DWHSG-GUID-464D983C-761D-428F-8AA5-587FDE7F5B54" class="sect5"><span class="enumeration_section">19.3.4.3</span>作为报告聚合</h5>
                     <div>
                        <p>您还可以使用聚合函数<code class="codeph">PERCENTILE_CONT</code> ， <code class="codeph">PERCENTILE_DISC</code>作为报告聚合函数。当用作报告聚合函数时，语法类似于其他报告聚合的语法。
                        </p><pre class="oac_no_warn" dir="ltr">[PERCENTILE_CONT | PERCENTILE_DISC]（ <span class="italic">常量表达式</span> ）WITHIN GROUP（ORDER BY <span class="italic">单个顺序，由表达式</span> [ASC | DESC] [NULLS FIRST | NULLS LAST]）OVER（[PARTITION BY <span class="italic">value expression</span> [，...]]）</pre><p>此查询执行相同的计算（此结果集中的客户的信用额度中位数），但报告结果集中每一行的结果，如以下输出所示：</p><pre class="oac_no_warn" dir="ltr">SELECT cust_id，cust_credit_limit，PERCENTILE_DISC（0.5）WITHIN GROUP（ORDER BY cust_credit_limit）OVER（）AS perc_disc，PERCENTILE_CONT（0.5）WITHIN GROUP（ORDER BY cust_credit_limit）OVER（）AS perc_cont FROM customers WHERE cust_city ='Marshal'; CUST_ID CUST_CREDIT_LIMIT PERC_DISC PERC_CONT ---------- ----------------- ---------- --------- -  28344 1500 5000 5000 8962 1500 5000 5000 36651 1500 5000 5000 32497 1500 5000 5000 15192 3000 5000 5000 102077 3000 5000 5000 102343 3000 5000 5000 8270 3000 5000 5000 21380 5000 5000 5000 13808 5000 5000 5000 101784 5000 5000 5000 30420 5000 5000 5000 10346 7000 5000 5000 31112 7000 5000 5000 35266 7000 5000 5000 3424 9000 5000 5000 100977 9000 5000 5000 103066 10000 5000 5000 35225 11000 5000 5000 14459 11000 5000 5000 17268 11000 5000 5000 100421 11000 5000 5000 41496 15000 5000 5000</pre></div>
                  </div><a id="DWHSG8712"></a><div class="props_rev_3"><a id="GUID-A5FA1D4D-1B5F-41CA-9384-649E4654523F" name="GUID-A5FA1D4D-1B5F-41CA-9384-649E4654523F"></a><h5 id="DWHSG-GUID-A5FA1D4D-1B5F-41CA-9384-649E4654523F" class="sect5"><span class="enumeration_section">19.3.4.4</span>反百分位函数的限制</h5>
                     <div>
                        <div class="section">
                           <p>对于<code class="codeph">PERCENTILE_DISC</code> ， <code class="codeph">ORDER</code> <code class="codeph">BY</code>子句中的表达式可以是您可以排序的任何数据类型（数字，字符串，日期等）。但是， <code class="codeph">ORDER</code> <code class="codeph">BY</code>子句中的表达式必须是数字或日期时间类型（包括间隔），因为线性插值用于计算<code class="codeph">PERCENTILE_CONT</code> 。如果表达式为<code class="codeph">DATE</code>类型，则插值结果将四舍五入为该类型的最小单位。对于<code class="codeph">DATE</code>类型，插值将四舍五入到最接近的秒，对于最接近的秒（ <code class="codeph">INTERVAL</code> <code class="codeph">DAY</code> <code class="codeph">TO</code> <code class="codeph">SECOND</code> ）或月份（ <code class="codeph">INTERVAL</code> <code class="codeph">YEAR</code> <code class="codeph">TO</code> <code class="codeph">MONTH</code> ）的间隔类型。
                           </p>
                           <p>与其他聚合一样，逆百分位函数在评估结果时忽略<code class="codeph">NULLs</code> 。例如，当您想要查找集合中的中值时，Oracle数据库会忽略<code class="codeph">NULLs</code>并查找非空值中的中位数。您可以在<code class="codeph">ORDER</code> <code class="codeph">BY</code>子句中使用<code class="codeph">NULLS</code> <code class="codeph">FIRST</code> / <code class="codeph">NULLS</code> <code class="codeph">LAST</code>选项，但它们将被忽略，因为忽略<code class="codeph">NULLs</code> 。
                           </p>
                        </div>
                        <!-- class="section" -->
                     </div>
                  </div>
                  <div class="sect4"><a id="GUID-E8AF7908-979A-49F2-B845-D9A5010BE863" name="GUID-E8AF7908-979A-49F2-B845-D9A5010BE863"></a><h5 id="DWHSG-GUID-E8AF7908-979A-49F2-B845-D9A5010BE863" class="sect5"><span class="enumeration_section">19.3.4.5</span>使用返回近似结果的百分位函数</h5>
                     <div>
                        <p>Oracle数据库提供了一组返回近似百分位数结果的SQL函数。这些功能可用于监控质量，跟踪社交媒体活动，监控性能以及搜索数据集中的异常值。</p>
                        <div class="section">
                           <p></p>
                           <p>以下SQL函数计算并显示近似百分位数结果：</p>
                           <ul style="list-style-type:disc">
                              <li>
                                 <p><code class="codeph">APPROX_PERCENTILE</code></p>
                                 <p>返回一个近似插值，该值与排序规范相关的百分位数值。它可以比<code class="codeph">PERCENTILE_CONT</code>更快地处理大量数据，与精确结果的偏差可以忽略不计。
                                 </p>
                              </li>
                              <li>
                                 <p><code class="codeph">APPROX_PERCENTILE_DETAIL</code></p>
                                 <p>计算使用<code class="codeph">GROUP BY</code>子句指定的一<code class="codeph">GROUP BY</code>数据中的近似百分位信息（称为详细信息）。使用此函数创建的详细信息以二进制格式存储，并且由<code class="codeph">TO_APPROX_PERCENTILE</code>和<code class="codeph">APPROX_PERCENT_DETAIL_AGG</code>函数使用。
                                 </p>
                              </li>
                              <li>
                                 <p><code class="codeph">APPROX_PERCENTILE_AGG</code></p>
                                 <p>对使用<code class="codeph">APPROX_PERCENTILE_DETAIL</code>函数创建的详细信息执行聚合。
                                 </p>
                              </li>
                              <li>
                                 <p><code class="codeph">TO_APPROX_PECENTILE</code></p>
                                 <p>以人类可读的格式显示详细信息或聚合结果，这些结果以BLOB值的形式存储。</p>
                              </li>
                           </ul>
                           <p>详细信息和更高级别的聚合数据可以存储在表格或物化视图中以供进一步分析。</p>
                        </div>
                        <!-- class="section" -->
                        <div class="section">
                           <p class="subhead3" id="GUID-E8AF7908-979A-49F2-B845-D9A5010BE863__GUID-66E86D89-F287-45BC-AF2D-AE00B8A13E5A">示例：在国家或州内显示近似百分位销售数据</p>
                           <p>此示例使用<code class="codeph">APPROX_PERCENTILE_DETAIL</code>执行一次百分位数计算，将结果存储在表中，然后根据存储的数据执行近似聚合。<code class="codeph">TO_APPROX_PERCENTILE</code>函数用于以人类可读的格式显示百分位数计算的结果。
                           </p>
                        </div>
                        <!-- class="section" -->
                        <ol>
                           <li class="stepexpand"><span>使用<code class="codeph">APPROX_PERCENTILE_DETAIL</code>计算每个州的销售额的近似百分位数，并将结果存储在名为<code class="codeph">approx_sales_percentile_detail</code>的表中。</span><div><pre class="pre codeblock"><code>CREATE TABLE approx_sales_percentile_detail AS SELECT c.country_id country，c.cust_state_province state，approx_percentile_detail（amount_sold）detail FROM sales s，customers c WHERE s.cust_id = c.cust_id GROUP BY c.country_id，c.cust_state_province;</code></pre></div>
                           </li>
                           <li class="stepexpand"><span>使用<code class="codeph">TO_APPROX_PERCENTILE</code>查询存储在表中的详细信息和聚合值，并以人类可读的格式显示这些值。</span><div>
                                 <p>以下语句使用<code class="codeph">APPROX_PERCENTILE_AGG</code>函数进一步聚合存储在<code class="codeph">approx_sales_percentile_detail</code>表中的详细数据。<code class="codeph">TO_APPROX_PERCENTILE</code>函数以人类可读的格式显示聚合结果。
                                 </p><pre class="pre codeblock"><code>SELECT country，to_approx_percentile（approx_percentile_agg（detail），0.5）median_amt_sold FROM approx_sales_percentile_detail GROUP BY country ORDER BY country;国家MEDIAN_AMT_SOLD ---------- --------------- 52769 33.5 52770 35.92 52771 44.99 52772 35.55 52773 29.61 52774 35.55 52775 42.09 52776 34.67 52777 38.1 52778 38.35 52779 38.67 52782 36.89 52785 22.99 52786 44.99 52787 27.99 52788 27.13 52789 37.79 52790 33.69选择18排。

</code></pre></div>
                              <div>
                                 <div class="infoboxnotealso" id="GUID-E8AF7908-979A-49F2-B845-D9A5010BE863__GUID-E2296781-EA00-44B8-8EB4-B038FB4DC064">
                                    <p class="notep1">也可以看看：</p>
                                    <p><a href="../sqlrf/index.html" target="_blank"><span><cite>Oracle数据库SQL语言参考中的</cite></span></a> <code class="codeph">APROX_PERCENTILE</code> ， <code class="codeph">APPROX_PERCENTILE_DETAIL</code> ， <code class="codeph">APPROX_PERCENTILE_AGG</code>和<code class="codeph">TO_APPROX_PERCENTILE</code></p>
                                 </div>
                              </div>
                           </li>
                        </ol>
                     </div>
                  </div>
               </div><a id="DWHSG8713"></a><a id="DWHSG8714"></a><a id="DWHSG0207"></a><div class="props_rev_3"><a id="GUID-76DADC19-5E66-4857-99F7-509836BA44D5" name="GUID-76DADC19-5E66-4857-99F7-509836BA44D5"></a><h4 id="DWHSG-GUID-76DADC19-5E66-4857-99F7-509836BA44D5" class="sect4"><span class="enumeration_section">19.3.5</span>假设秩函数</h4>
                  <div>
                     <div class="section">
                        <p>这些功能<a id="d65966e4047" class="indexterm-anchor"></a>提供对假设分析有用的功能。作为一个例子，什么<span class="bold"> </span>如果行被假设插入到一组其他行中，那么它将是一行的排名？
                        </p>
                        <p>该聚合体系列采用假设行和有序行组的一个或多个参数，返回行的<code class="codeph">RANK</code> ， <code class="codeph">DENSE_RANK</code> ， <code class="codeph">PERCENT_RANK</code>或<code class="codeph">CUME_DIST</code> ，就好像它是假设插入到组中一样。
                        </p><pre class="oac_no_warn" dir="ltr">[排名| DENSE_RANK | PERCENT_RANK | CUME_DIST]（ <span class="italic">常量表达式</span> [，...]）WITHIN GROUP（ <span class="italic">按表达顺序排序</span> [ASC | DESC] [NULLS FIRST | NULLS LAST] [，...]）</pre><p>这里， <span class="italic"><code class="codeph">constant expression</code></span>是指一个求值为<span class="italic"><code class="codeph">constant expression</code></span> ，并且可能有多个这样的表达式作为参数传递给函数。<code class="codeph">ORDER</code> <code class="codeph">BY</code>子句可以包含一个或多个表达式，用于定义排名所基于的排序顺序。<code class="codeph">ASC</code> ， <code class="codeph">DESC</code> ， <code class="codeph">NULLS</code> <code class="codeph">FIRST</code> ， <code class="codeph">NULLS</code> <code class="codeph">LAST</code>选项将可用于<code class="codeph">ORDER</code> <code class="codeph">BY</code>中的每个表达式。</p>
                     </div>
                     <!-- class="section" -->
                     <div class="example" id="GUID-76DADC19-5E66-4857-99F7-509836BA44D5__GUID-7E70138E-5D8D-4BE2-BBFB-01ED1DDC026E">
                        <p class="titleinexample">实施例19-24假设等级和分布实施例1</p>
                        <p>使用本节中使用的<code class="codeph">products</code>表中的清单价格数据，您可以计算出价格为50美元的假想毛衣的<code class="codeph">RANK</code> ， <code class="codeph">PERCENT_RANK</code>和<code class="codeph">CUME_DIST</code> ，以了解它如何适合每个毛衣子类别。查询和结果是：</p><pre class="oac_no_warn" dir="ltr">SELECT cust_city，RANK（6000）WITHIN GROUP（ORDER BY CUST_CREDIT_LIMIT DESC）作为HRANK，TO_CHAR（PERCENT_RANK（6000）WITHIN GROUP（ORDER BY cust_credit_limit），'9.999'）AS HPERC_RANK，TO_CHAR（CUME_DIST（6000）WITHIN GROUP（ORDER BY cust_credit_limit），'9.999'）AS HCUME_DIST FROM customers WHERE cust_city LIKE'Fo％'GROUP BY cust_city; CUST_CITY HRANK HPERC_ HCUME_ ------------------------------ ---------- ------ ------ Fondettes 13 .455 .478 Fords Prairie 18 .320 .346 Forest City 47 .370 .378 Forest Heights 38 .456 .464 Forestville 58 .412 .418 Forrestcity 51 .438 .444 Fort Klamath 59 .356 .363威廉堡30 .500 .508 Foxborough 52 .414 .420</pre><p>与逆百分位聚合不同，假设排名和分布函数的排序规范中的<code class="codeph">ORDER</code> <code class="codeph">BY</code>子句可以采用多个表达式。<code class="codeph">ORDER</code> <code class="codeph">BY</code>子句中的参数数量和表达式应该相同，并且参数必须是与相应<code class="codeph">ORDER</code> <code class="codeph">BY</code>表达式相同或兼容类型的常量表达式。以下是在几个假设排名函数中使用两个参数的示例。
                        </p>
                     </div>
                     <!-- class="example" -->
                     <div class="example" id="GUID-76DADC19-5E66-4857-99F7-509836BA44D5__GUID-7B2C020A-84C3-4898-B527-E2F5692A717E">
                        <p class="titleinexample">实施例19-25假设等级和分布实施例2</p><pre class="oac_no_warn" dir="ltr">SELECT prod_subcategory，RANK（10,8）WITHIN GROUP（ORDER BY prod_list_price DESC，prod_min_price）AS HRANK，TO_CHAR（PERCENT_RANK（10,8）WITHIN GROUP（ORDER BY prod_list_price，prod_min_price），'9.999'）AS HPERC_RANK，TO_CHAR（CUME_DIST （10,8）WITHIN GROUP（ORDER BY prod_list_price，prod_min_price），'9.999'）AS HCUME_DIST FROM products WHERE prod_subcategory LIKE'Odableable％'GROUP BY prod_subcategory; PROD_SUBCATEGORY HRANK HPERC_ HCUME_ -------------------- ----- ------ ------可刻录光盘4 .571 .625可刻录DVD光盘5 .200 .333</pre><p>与其他聚合函数一样，这些函数可以出现在查询的<code class="codeph">HAVING</code>子句中。它们不能用作报告聚合函数或窗口聚合函数。
                        </p>
                     </div>
                     <!-- class="example" -->
                  </div>
               </div><a id="DWHSG0208"></a><div class="props_rev_3"><a id="GUID-175A5046-3326-4CA8-AC55-FF6BF54A4A51" name="GUID-175A5046-3326-4CA8-AC55-FF6BF54A4A51"></a><h4 id="DWHSG-GUID-175A5046-3326-4CA8-AC55-FF6BF54A4A51" class="sect4"><span class="enumeration_section">19.3.6</span>线性回归函数</h4>
                  <div>
                     <p><a id="d65966e4184" class="indexterm-anchor"></a><a id="d65966e4188" class="indexterm-anchor"></a>回归函数支持将普通最小二乘回归线拟合到一组数字对。您可以将它们用作聚合函数或窗口或报告函数。
                     </p>
                     <p>回归函数如下：</p>
                     <ul style="list-style-type:disc">
                        <li>
                           <p><a href="sql-analysis-reporting-data-warehouses.html#GUID-BDDB54D1-42A7-4BD1-A61E-621C4184BBD0">REGR_COUNT函数</a></p>
                        </li>
                        <li>
                           <p><a href="sql-analysis-reporting-data-warehouses.html#GUID-0C9A1E08-55A2-49BD-A9D6-4E88B9489070">REGR_AVGY和REGR_AVGX函数</a></p>
                        </li>
                        <li>
                           <p><a href="sql-analysis-reporting-data-warehouses.html#GUID-74BB2242-09FC-45C7-8882-33789DD671F1">REGR_SLOPE和REGR_INTERCEPT函数</a></p>
                        </li>
                        <li>
                           <p><a href="sql-analysis-reporting-data-warehouses.html#GUID-8B9FAFE5-4BE7-46B6-A26D-A953F3AED5D6">REGR_R2功能</a></p>
                        </li>
                        <li>
                           <p><a href="sql-analysis-reporting-data-warehouses.html#GUID-1A9FB0BB-F198-4688-A3BA-AF8FCDFDD43F">REGR_SXX，REGR_SYY和REGR_SXY函数</a></p>
                        </li>
                     </ul>
                     <p>在消除了<code class="codeph">e1</code>或<code class="codeph">e2</code>为空的所有对之后，Oracle将该函数应用于（ <code class="codeph">e1</code> ， <code class="codeph">e2</code> ）对的集合。 e1被解释为因变量的值（“y值”），并且<code class="codeph">e2</code>被解释为自变量的值（“x值”）。两个表达式都必须是数字。
                     </p>
                     <p>回归函数全部在单次通过数据期间同时计算。它们经常与<code class="codeph">COVAR_POP</code> ， <code class="codeph">COVAR_SAMP</code>和<code class="codeph">CORR</code>功能结合使用。
                     </p>
                     <div class="infoboxnotealso" id="GUID-175A5046-3326-4CA8-AC55-FF6BF54A4A51__GUID-D126A2D7-A814-4763-A66A-6B8FC0B9649E">
                        <p class="notep1">也可以看看：</p>
                        <ul style="list-style-type:disc">
                           <li>
                              <p><a href="sql-analysis-reporting-data-warehouses.html#GUID-D660FE5C-2850-445E-8408-695C9E2963A7">线性回归统计示例</a></p>
                           </li>
                           <li>
                              <p><a href="sql-analysis-reporting-data-warehouses.html#GUID-1818A747-1C36-4FBD-BE49-481917EF9835">线性回归计算示例</a></p>
                           </li>
                        </ul>
                     </div>
                  </div><a id="DWHSG8715"></a><div class="props_rev_3"><a id="GUID-BDDB54D1-42A7-4BD1-A61E-621C4184BBD0" name="GUID-BDDB54D1-42A7-4BD1-A61E-621C4184BBD0"></a><h5 id="DWHSG-GUID-BDDB54D1-42A7-4BD1-A61E-621C4184BBD0" class="sect5"><span class="enumeration_section">19.3.6.1</span> REGR_COUNT函数</h5>
                     <div>
                        <div class="section">
                           <p><code class="codeph">REGR_COUNT</code>返回用于拟合回归线的非空数字对的数量。如果应用于空集（或者如果没有（ <code class="codeph">e1</code> ， <code class="codeph">e2</code> ）对，其中<code class="codeph">e1</code>或<code class="codeph">e2</code>都不为空），则该函数返回0。
                           </p>
                        </div>
                        <!-- class="section" -->
                     </div>
                  </div><a id="DWHSG8716"></a><div class="props_rev_3"><a id="GUID-0C9A1E08-55A2-49BD-A9D6-4E88B9489070" name="GUID-0C9A1E08-55A2-49BD-A9D6-4E88B9489070"></a><h5 id="DWHSG-GUID-0C9A1E08-55A2-49BD-A9D6-4E88B9489070" class="sect5"><span class="enumeration_section">19.3.6.2</span> REGR_AVGY和REGR_AVGX函数</h5>
                     <div>
                        <div class="section">
                           <p><code class="codeph">REGR_AVGY</code>和<code class="codeph">REGR_AVGX</code>计算因变量的平均值和<code class="codeph">REGR_AVGX</code>的自变量。<code class="codeph">REGR_AVGY</code>在消除（ <code class="codeph">e1</code> ， <code class="codeph">e2</code> ）对之后计算其第一个参数（ <code class="codeph">e1</code> ）的平均值，其中<code class="codeph">e1</code>或<code class="codeph">e2</code>中的任何一个为空。类似地， <code class="codeph">REGR_AVGX</code>在消除空值后计算其第二个参数（ <code class="codeph">e2</code> ）的平均值。如果应用于空集，则两个函数都返回<code class="codeph">NULL</code> 。
                           </p>
                        </div>
                        <!-- class="section" -->
                     </div>
                  </div><a id="DWHSG8717"></a><div class="props_rev_3"><a id="GUID-74BB2242-09FC-45C7-8882-33789DD671F1" name="GUID-74BB2242-09FC-45C7-8882-33789DD671F1"></a><h5 id="DWHSG-GUID-74BB2242-09FC-45C7-8882-33789DD671F1" class="sect5"><span class="enumeration_section">19.3.6.3</span> REGR_SLOPE和REGR_INTERCEPT函数</h5>
                     <div>
                        <div class="section">
                           <p><a id="d65966e4374" class="indexterm-anchor"></a><a id="d65966e4376" class="indexterm-anchor"></a><a id="d65966e4378" class="indexterm-anchor"></a><a id="d65966e4382" class="indexterm-anchor"></a> <code class="codeph">REGR_SLOPE</code>函数计算拟合到非空（ <code class="codeph">e1</code> ， <code class="codeph">e2</code> ）对的回归线的斜率。
                           </p>
                           <p><code class="codeph">REGR_INTERCEPT</code>函数计算回归线的y轴截距。<code class="codeph">REGR_INTERCEPT</code>返回<code class="codeph">NULL</code>每当斜率或回归平均值是<code class="codeph">NULL</code> 。</p>
                        </div>
                        <!-- class="section" -->
                     </div>
                  </div><a id="DWHSG8718"></a><div class="props_rev_3"><a id="GUID-8B9FAFE5-4BE7-46B6-A26D-A953F3AED5D6" name="GUID-8B9FAFE5-4BE7-46B6-A26D-A953F3AED5D6"></a><h5 id="DWHSG-GUID-8B9FAFE5-4BE7-46B6-A26D-A953F3AED5D6" class="sect5"><span class="enumeration_section">19.3.6.4</span> REGR_R2功能</h5>
                     <div>
                        <div class="section">
                           <p><a id="d65966e4432" class="indexterm-anchor"></a> <code class="codeph">REGR_R2</code>函数计算<code class="codeph">REGR_R2</code>的确定系数（通常称为“R平方”或“拟合度”）。
                           </p>
                           <p>定义回归线时， <code class="codeph">REGR_R2</code>返回介于0和1之间的值（线的斜率不为空），否则返回<code class="codeph">NULL</code> 。值越接近1，回归线越适合数据。
                           </p>
                        </div>
                        <!-- class="section" -->
                     </div>
                  </div><a id="DWHSG8719"></a><div class="props_rev_3"><a id="GUID-1A9FB0BB-F198-4688-A3BA-AF8FCDFDD43F" name="GUID-1A9FB0BB-F198-4688-A3BA-AF8FCDFDD43F"></a><h5 id="DWHSG-GUID-1A9FB0BB-F198-4688-A3BA-AF8FCDFDD43F" class="sect5"><span class="enumeration_section">19.3.6.5</span> REGR_SXX，REGR_SYY和REGR_SXY函数</h5>
                     <div>
                        <div class="section">
                           <p><code class="codeph">REGR_SXX</code> ， <code class="codeph">REGR_SYY</code>和<code class="codeph">REGR_SXY</code>函数用于计算各种诊断统计数据以进行回归分析。在消除<code class="codeph">e1</code>或<code class="codeph">e2</code>为空的（ <code class="codeph">e1</code> ， <code class="codeph">e2</code> ）对之后，这些函数进行以下计算：</p><pre class="oac_no_warn" dir="ltr">REGR_SXX：REGR_COUNT（e1，e2）* VAR_POP（e2）REGR_SYY：REGR_COUNT（e1，e2）* VAR_POP（e1）REGR_SXY：REGR_COUNT（e1，e2）* COVAR_POP（e1，e2）</pre></div>
                        <!-- class="section" -->
                     </div>
                  </div><a id="DWHSG8721"></a><a id="DWHSG8720"></a><div class="props_rev_3"><a id="GUID-D660FE5C-2850-445E-8408-695C9E2963A7" name="GUID-D660FE5C-2850-445E-8408-695C9E2963A7"></a><h5 id="DWHSG-GUID-D660FE5C-2850-445E-8408-695C9E2963A7" class="sect5"><span class="enumeration_section">19.3.6.6</span>线性回归统计示例</h5>
                     <div>
                        <p><a href="sql-analysis-reporting-data-warehouses.html#GUID-D660FE5C-2850-445E-8408-695C9E2963A7__g1016125" title="常见诊断统计及其表达">表19-2</a>给出了伴随线性回归分析的一些常见诊断统计数据。请注意，Oracle允许您计算所有这些。
                        </p>
                        <div class="tblformalwide" id="GUID-D660FE5C-2850-445E-8408-695C9E2963A7__g1016125">
                           <p class="titleintable">表19-2常用诊断统计及其表达式</p>
                           <table cellpadding="4" cellspacing="0" class="FormalWide" title="常见诊断统计及其表达" width="100%" border="1" summary="Common Diagnostic Statistics and Their Expressions" frame="hsides" rules="rows">
                              <thead>
                                 <tr align="left" valign="top">
                                    <th align="left" valign="bottom" width="25%" id="d65966e4530">统计类型</th>
                                    <th align="left" valign="bottom" width="75%" id="d65966e4533">表达</th>
                                 </tr>
                              </thead>
                              <tbody>
                                 <tr align="left" valign="top">
                                    <td align="left" valign="top" width="25%" id="d65966e4538" headers="d65966e4530 ">
                                       <p>调整后的R2</p>
                                    </td>
                                    <td align="left" valign="top" width="75%" headers="d65966e4538 d65966e4533 ">
                                       <p><code class="codeph">1  - （（1  -  REGR_R2）*（（REGR_COUNT-1）/（REGR_COUNT-2）））</code></p>
                                    </td>
                                 </tr>
                                 <tr align="left" valign="top">
                                    <td align="left" valign="top" width="25%" id="d65966e4546" headers="d65966e4530 ">
                                       <p>标准错误</p>
                                    </td>
                                    <td align="left" valign="top" width="75%" headers="d65966e4546 d65966e4533 ">
                                       <p><code class="codeph">SQRT（（REGR_SYY-（POWER（REGR_SXY，2）/ REGR_SXX））/（REGR_COUNT-2））</code></p>
                                    </td>
                                 </tr>
                                 <tr align="left" valign="top">
                                    <td align="left" valign="top" width="25%" id="d65966e4554" headers="d65966e4530 ">
                                       <p>总平方和</p>
                                    </td>
                                    <td align="left" valign="top" width="75%" headers="d65966e4554 d65966e4533 ">
                                       <p><code class="codeph">REGR_SYY</code></p>
                                    </td>
                                 </tr>
                                 <tr align="left" valign="top">
                                    <td align="left" valign="top" width="25%" id="d65966e4562" headers="d65966e4530 ">
                                       <p>回归平方和</p>
                                    </td>
                                    <td align="left" valign="top" width="75%" headers="d65966e4562 d65966e4533 ">
                                       <p><code class="codeph">POWER（REGR_SXY，2）/ REGR_SXX</code></p>
                                    </td>
                                 </tr>
                                 <tr align="left" valign="top">
                                    <td align="left" valign="top" width="25%" id="d65966e4570" headers="d65966e4530 ">
                                       <p>剩余的平方和</p>
                                    </td>
                                    <td align="left" valign="top" width="75%" headers="d65966e4570 d65966e4533 ">
                                       <p><code class="codeph">REGR_SYY</code> - （ <code class="codeph">POWER(REGR_SXY,2)/REGR_SXX)</code></p>
                                    </td>
                                 </tr>
                                 <tr align="left" valign="top">
                                    <td align="left" valign="top" width="25%" id="d65966e4581" headers="d65966e4530 ">
                                       <p>t斜率统计量</p>
                                    </td>
                                    <td align="left" valign="top" width="75%" headers="d65966e4581 d65966e4533 ">
                                       <p><code class="codeph">REGR_SLOPE * SQRT(REGR_SXX)</code> /（标准错误）</p>
                                    </td>
                                 </tr>
                                 <tr align="left" valign="top">
                                    <td align="left" valign="top" width="25%" id="d65966e4590" headers="d65966e4530 ">
                                       <p>y截距的统计量</p>
                                    </td>
                                    <td align="left" valign="top" width="75%" headers="d65966e4590 d65966e4533 ">
                                       <p><code class="codeph">REGR_INTERCEPT</code> /（（标准错误）* <code class="codeph">SQRT((1/REGR_COUNT)+(POWER(REGR_AVGX,2)/REGR_SXX))</code></p>
                                    </td>
                                 </tr>
                              </tbody>
                           </table>
                        </div>
                        <!-- class="inftblhruleinformal" -->
                     </div>
                  </div><a id="DWHSG8722"></a><div class="props_rev_3"><a id="GUID-1818A747-1C36-4FBD-BE49-481917EF9835" name="GUID-1818A747-1C36-4FBD-BE49-481917EF9835"></a><h5 id="DWHSG-GUID-1818A747-1C36-4FBD-BE49-481917EF9835" class="sect5"><span class="enumeration_section">19.3.6.7</span>线性回归计算示例</h5>
                     <div>
                        <p>在此示例中，您计算一个普通最小二乘回归线，该回归线将产品的销售量表示为产品定价的线性函数。计算按销售渠道分组。值<code class="codeph">SLOPE</code> ， <code class="codeph">INTCPT</code> ， <code class="codeph">RSQR</code>分别是<code class="codeph">RSQR</code>的斜率，截距和确定系数。（整数）值<code class="codeph">COUNT</code>是每个渠道中的产品数量，销售数量和清单价格数据均可用。
                        </p><pre class="oac_no_warn" dir="ltr">SELECT s.channel_id，REGR_SLOPE（s.quantity_sold，p.prod_list_price）SLOPE，REGR_INTERCEPT（s.quantity_sold，p.prod_list_price）INTCPT，REGR_R2（s.quantity_sold，p.prod_list_price）RSQR，REGR_COUNT（s.quantity_sold，p.prod_list_price） ）COUNT，REGR_AVGX（s.quantity_sold，p.prod_list_price）AVGLISTP，REGR_AVGY（s.quantity_sold，p.prod_list_price）AVGQSOLD FROM sales s，products p WHERE s.prod_id = p.prod_id AND p.prod_category ='Electronics'AND s .time_id = to_DATE（'10 -OCT-2000'）GROUP BY s.channel_id; CHANNEL_ID SLOPE INTCPT RSQR COUNT AVGLISTP AVGQSOLD ---------- ---------- ---------- ---------- --- ------- ---------- ---------- 2 0 1 1 39 466.656667 1 3 0 1 1 60 459.99 1 4 0 1 1 19 526.305789 1</pre></div>
                  </div>
               </div><a id="DWHSG8723"></a><div class="props_rev_3"><a id="GUID-399DBC4B-0CE6-49F7-87F2-5E74D83A1DB0" name="GUID-399DBC4B-0CE6-49F7-87F2-5E74D83A1DB0"></a><h4 id="DWHSG-GUID-399DBC4B-0CE6-49F7-87F2-5E74D83A1DB0" class="sect4"><span class="enumeration_section">19.3.7</span>关于统计集合</h4>
                  <div>
                     <p>Oracle数据库提供了一组SQL统计函数和一个统计包<code class="codeph">DBMS_STAT_FUNCS</code> 。本节列出了一些新功能以及基本语法。
                     </p>
                     <p>有关语法和语义的<code class="codeph">DBMS_STAT_FUNCS</code>程序包和<a href="../sqlrf/GROUPING.html#SQLRF00647" target="_blank"><span class="italic">Oracle数据库SQL语言参考的</span></a>详细信息，请参阅<a href="../arpls/DBMS_STAT_FUNCS.html#ARPLS006" target="_blank"><span class="italic">Oracle数据库PL / SQL程序包和类型参考</span></a> 。
                     </p>
                     <p>本节包含以下主题：</p>
                     <ul style="list-style-type:disc">
                        <li>
                           <p><a href="sql-analysis-reporting-data-warehouses.html#GUID-43AE794B-06F5-407A-9E61-87BEFE58315A">描述性统计</a></p>
                        </li>
                        <li>
                           <p><a href="sql-analysis-reporting-data-warehouses.html#GUID-BCF2AB78-069B-4560-8942-F8217CE6CAC0">假设检验 - 参数检验</a></p>
                        </li>
                        <li>
                           <p><a href="sql-analysis-reporting-data-warehouses.html#GUID-A1A3BBD2-DDB3-49F9-A023-594F124D17BF">交叉统计</a></p>
                        </li>
                        <li>
                           <p><a href="sql-analysis-reporting-data-warehouses.html#GUID-D75213DB-43C9-403C-947B-54083FB1C303">假设检验 - 非参数检验</a></p>
                        </li>
                        <li>
                           <p><a href="sql-analysis-reporting-data-warehouses.html#GUID-7431A541-4F23-467A-9BB5-AD4D0930D950">非参数相关</a></p>
                        </li>
                     </ul>
                  </div><a id="DWHSG8724"></a><div class="props_rev_3"><a id="GUID-43AE794B-06F5-407A-9E61-87BEFE58315A" name="GUID-43AE794B-06F5-407A-9E61-87BEFE58315A"></a><h5 id="DWHSG-GUID-43AE794B-06F5-407A-9E61-87BEFE58315A" class="sect5"><span class="enumeration_section">19.3.7.1</span>描述性统计</h5>
                     <div>
                        <div class="section">
                           <p>您可以计算以下描述性统计信息：</p>
                           <ul style="list-style-type:disc">
                              <li>
                                 <p>数据集的中位数</p><pre class="oac_no_warn" dir="ltr">中位数（expr）[OVER（query_partition_clause）]</pre></li>
                              <li>
                                 <p>数据集的模式</p><pre class="oac_no_warn" dir="ltr">STATS_MODE（expr）</pre></li>
                           </ul>
                           <p></p>
                           <p>从Oracle Database 12 <span class="italic">c</span>第2版（12.2）开始，近似逆分布函数<code class="codeph">APPROX_MEDIAN</code>提供指定表达式的近似中值。
                           </p>
                           <div class="infoboxnotealso" id="GUID-43AE794B-06F5-407A-9E61-87BEFE58315A__GUID-AB4A1934-5CB9-45EF-B37C-55E995315DFC">
                              <p class="notep1">也可以看看：</p>
                              <p></p>
                              <p><a href="../sqlrf/APPROX_COUNT_DISTINCT.html#SQLRF-GUID-50055A05-0187-4481-AFE5-2414F7227713" target="_blank"><span><cite>Oracle数据库SQL语言参考</cite></span></a></p>
                           </div>
                        </div>
                        <!-- class="section" -->
                     </div>
                  </div><a id="DWHSG8725"></a><div class="props_rev_3"><a id="GUID-BCF2AB78-069B-4560-8942-F8217CE6CAC0" name="GUID-BCF2AB78-069B-4560-8942-F8217CE6CAC0"></a><h5 id="DWHSG-GUID-BCF2AB78-069B-4560-8942-F8217CE6CAC0" class="sect5"><span class="enumeration_section">19.3.7.2</span>假设检验 - 参数检验</h5>
                     <div>
                        <div class="section">
                           <p>您可以计算以下描述性统计信息：</p>
                           <ul style="list-style-type:disc">
                              <li>
                                 <p>单样本T检验</p><pre class="oac_no_warn" dir="ltr">STATS_T_TEST_ONE（expr1，expr2（常量）[，return_value]）</pre></li>
                              <li>
                                 <p>配对样本T检验</p><pre class="oac_no_warn" dir="ltr">STATS_T_TEST_PAIRED（expr1，expr2 [，return_value]）</pre></li>
                              <li>
                                 <p>独立样本T检验。汇总差异</p><pre class="oac_no_warn" dir="ltr">STATS_T_TEST_INDEP（expr1，expr2 [，return_value]）</pre></li>
                              <li>
                                 <p>独立样本T检验，未计算的差异</p><pre class="oac_no_warn" dir="ltr">STATS_T_TEST_INDEPU（expr1，expr2 [，return_value]）</pre></li>
                              <li>
                                 <p>F-Test</p><pre class="oac_no_warn" dir="ltr">STATS_F_TEST（expr1，expr2 [，return_value]）</pre></li>
                              <li>
                                 <p>单因素方差分析</p><pre class="oac_no_warn" dir="ltr">STATS_ONE_WAY_ANOVA（expr1，expr2 [，return_value]）</pre></li>
                           </ul>
                        </div>
                        <!-- class="section" -->
                     </div>
                  </div><a id="DWHSG8726"></a><div class="props_rev_3"><a id="GUID-A1A3BBD2-DDB3-49F9-A023-594F124D17BF" name="GUID-A1A3BBD2-DDB3-49F9-A023-594F124D17BF"></a><h5 id="DWHSG-GUID-A1A3BBD2-DDB3-49F9-A023-594F124D17BF" class="sect5"><span class="enumeration_section">19.3.7.3</span>交叉表统计</h5>
                     <div>
                        <div class="section">
                           <p>您可以使用以下语法计算交叉表统计信息：</p><pre class="oac_no_warn" dir="ltr">STATS_CROSSTAB（expr1，expr2 [，return_value]）</pre><p>可以返回以下任何一项：</p>
                           <ul style="list-style-type:disc">
                              <li>
                                 <p>观察到卡方值</p>
                              </li>
                              <li>
                                 <p>观察到的卡方的意义</p>
                              </li>
                              <li>
                                 <p>卡方的自由度</p>
                              </li>
                              <li>
                                 <p>Phi系数，Cramer的V统计量</p>
                              </li>
                              <li>
                                 <p>权变系数</p>
                              </li>
                              <li>
                                 <p>科恩的卡帕</p>
                              </li>
                           </ul>
                        </div>
                        <!-- class="section" -->
                     </div>
                  </div><a id="DWHSG8727"></a><div class="props_rev_3"><a id="GUID-D75213DB-43C9-403C-947B-54083FB1C303" name="GUID-D75213DB-43C9-403C-947B-54083FB1C303"></a><h5 id="DWHSG-GUID-D75213DB-43C9-403C-947B-54083FB1C303" class="sect5"><span class="enumeration_section">19.3.7.4</span>假设检验 - 非参数检验</h5>
                     <div>
                        <div class="section">
                           <p>您可以使用以下语法计算假设统计数据：</p><pre class="oac_no_warn" dir="ltr">STATS_BINOMIAL_TEST（expr1，expr2，p [，return_value]）</pre><ul style="list-style-type:disc">
                              <li>
                                 <p>二项式测试/ Wilcoxon签名等级测试</p><pre class="oac_no_warn" dir="ltr">STATS_WSR_TEST（expr1，expr2 [，return_value]）</pre></li>
                              <li>
                                 <p>曼 - 惠特尼试验</p><pre class="oac_no_warn" dir="ltr">STATS_MW_TEST（expr1，expr2 [，return_value]）</pre></li>
                              <li>
                                 <p>Kolmogorov-Smirnov测试</p><pre class="oac_no_warn" dir="ltr">STATS_KS_TEST（expr1，expr2 [，return_value]）</pre></li>
                           </ul>
                        </div>
                        <!-- class="section" -->
                     </div>
                  </div><a id="DWHSG8728"></a><div class="props_rev_3"><a id="GUID-7431A541-4F23-467A-9BB5-AD4D0930D950" name="GUID-7431A541-4F23-467A-9BB5-AD4D0930D950"></a><h5 id="DWHSG-GUID-7431A541-4F23-467A-9BB5-AD4D0930D950" class="sect5"><span class="enumeration_section">19.3.7.5</span>非参数相关</h5>
                     <div>
                        <div class="section">
                           <p>您可以计算以下参数统计信息：</p>
                           <ul style="list-style-type:disc">
                              <li>
                                 <p>斯皮尔曼的rho Coefficient</p><pre class="oac_no_warn" dir="ltr">CORR_S（expr1，expr2 [，return_value]）</pre></li>
                              <li>
                                 <p>肯德尔的tau-b系数</p><pre class="oac_no_warn" dir="ltr">CORR_K（expr1，expr2 [，return_value]）</pre></li>
                           </ul>
                           <p>除了这些函数之外，此版本还有一个PL / SQL包<code class="codeph">DBMS_STAT_FUNCS</code> 。它包含描述性统计功能<code class="codeph">SUMMARY</code>以及支持分配拟合的功能。<code class="codeph">SUMMARY</code>函数总结了具有各种描述性统计数据的表的数字列。五个分布拟合函数支持正态，均匀，Weibull，Poisson和指数分布。
                           </p>
                        </div>
                        <!-- class="section" -->
                     </div>
                  </div>
               </div><a id="DWHSG02011"></a><div class="props_rev_3"><a id="GUID-04FC38D9-D651-4558-99D3-830255C958AF" name="GUID-04FC38D9-D651-4558-99D3-830255C958AF"></a><h4 id="DWHSG-GUID-04FC38D9-D651-4558-99D3-830255C958AF" class="sect4"><span class="enumeration_section">19.3.8</span>关于用户定义的聚合</h4>
                  <div>
                     <p>Oracle提供了一种用于创建自己的函数的工具，称为用户定义的聚合函数。这些函数使用PL / SQL，Java和C等编程语言编写，可用作物化视图中的分析函数或聚合。有关语法和限制的详细信息，请参阅<a href="../addci/using-user-defined-aggregate-functions.html#ADDCI2120" target="_blank"><span class="italic">Oracle数据库数据盒开发人员指南</span></a> 。
                     </p>
                     <p>这些功能的优点是：</p>
                     <ul style="list-style-type:disc">
                        <li>
                           <p>可以使用完全过程语言对高度复杂的函数进行编程。</p>
                        </li>
                        <li>
                           <p>当用户定义的函数被编程用于并行处理时，比其他技术具有更高的可伸缩性。</p>
                        </li>
                        <li>
                           <p>可以处理对象数据类型。</p>
                        </li>
                     </ul>
                     <p>作为用户定义的聚合函数的简单示例，请考虑偏斜统计量。该计算测量数据集是否具有关于其均值的不平衡分布。它将告诉您分布的一个尾部是否明显大于另一个尾部。如果您创建了一个名为<code class="codeph">udskew</code>的用户定义聚合并将其应用于前一示例中的信用限额数据，则SQL语句和结果可能如下所示：</p><pre class="oac_no_warn" dir="ltr">SELECT USERDEF_SKEW（cust_credit_limit）FROM customers WHERE cust_city ='Marshal'; USERDEF_SKEW ============ 0.583891</pre><p>在构建用户定义的聚合函数之前，您应该考虑是否可以在常规SQL中满足您的需求。可以直接在SQL中进行许多复杂的计算，尤其是使用<code class="codeph">CASE</code>表达式。
                     </p>
                     <p>保持常规SQL将实现更简单的开发，并且许多查询操作已经在SQL中很好地并行化。即使是前面的例子，也可以使用标准的，虽然冗长的SQL来创建偏斜统计量。</p>
                  </div>
               </div>
            </div><a id="DWHSG0209"></a><div class="props_rev_3"><a id="GUID-05BB22CD-0F53-4C90-AE84-CE3F88DBD591" name="GUID-05BB22CD-0F53-4C90-AE84-CE3F88DBD591"></a><h3 id="DWHSG-GUID-05BB22CD-0F53-4C90-AE84-CE3F88DBD591" class="sect3"><span class="enumeration_section">19.4</span>透视操作</h3>
               <div>
                  <div class="section">
                     <p>如果以交叉形式呈现，商业智能查询返回的数据通常最有用。<code class="codeph">SELECT</code>语句的<code class="codeph">pivot_clause</code>允许您编写交叉制表查询，这些查询将行轮换为列，在轮换过程中聚合数据。透视是数据仓库中的关键技术。在其中，您将多行输入转换为数据仓库中较少且通常较宽的行。在透视时，将为透视列值列表中的每个项应用聚合运算符。数据透视表列不能包含任意表达式。如果需要在表达式上进行透视，则应在<code class="codeph">PIVOT</code>操作之前在视图中对表达式进行别名。基本语法如下：</p><pre class="oac_no_warn" dir="ltr">选择 ....FROM &lt;table-expr&gt; PIVOT（aggregate-function（&lt;column&gt;）AS &lt;alias&gt; FOR &lt;pivot-column&gt; IN（&lt;value1&gt;，&lt;value2&gt;，...，&lt;valuen&gt;））AS &lt;alias&gt; WHERE .....
</pre><p>有关<code class="codeph">pivot_clause</code>语法，请参见<a href="../sqlrf/SELECT.html#SQLRF01702" target="_blank"><span class="italic">Oracle数据库SQL语言参考</span></a> 。
                     </p>
                     <p>本节包含以下主题：</p>
                     <ul style="list-style-type:disc">
                        <li>
                           <p><a href="sql-analysis-reporting-data-warehouses.html#GUID-72A2DEB6-003B-4235-9E9B-A4290BBE20A1">创建用于透视示例的视图</a></p>
                        </li>
                        <li>
                           <p><a href="sql-analysis-reporting-data-warehouses.html#GUID-84C81897-0484-4F40-938B-D1D7F5EA4D97">透视示例</a></p>
                        </li>
                        <li>
                           <p><a href="sql-analysis-reporting-data-warehouses.html#GUID-BC68A3FF-165D-4711-A94E-6C953E96EF7E">透视多列</a></p>
                        </li>
                        <li>
                           <p><a href="sql-analysis-reporting-data-warehouses.html#GUID-6A8D63AC-5E88-47A8-B5A6-9318173F0206">透视：多个聚合</a></p>
                        </li>
                        <li>
                           <p><a href="sql-analysis-reporting-data-warehouses.html#GUID-3BBB2991-DC84-4BB1-B7DC-797F8817732C">区分PIVOT生成的空值和源数据中的空值</a></p>
                        </li>
                        <li>
                           <p><a href="sql-analysis-reporting-data-warehouses.html#GUID-C4AF4C41-55D1-402F-89C1-ED83C7986395">通配符和子查询使用XML操作进行透视</a></p>
                        </li>
                     </ul>
                  </div>
                  <!-- class="section" -->
               </div>
               <div class="props_rev_3"><a id="GUID-72A2DEB6-003B-4235-9E9B-A4290BBE20A1" name="GUID-72A2DEB6-003B-4235-9E9B-A4290BBE20A1"></a><h4 id="DWHSG-GUID-72A2DEB6-003B-4235-9E9B-A4290BBE20A1" class="sect4"><span class="enumeration_section">19.4.1</span>创建用于透视示例的视图</h4>
                  <div>
                     <div class="section">
                        <p>透视和非透视示例基于<code class="codeph">sales_view</code>视图。
                        </p>
                     </div>
                     <!-- class="section" -->
                     <div class="example" id="GUID-72A2DEB6-003B-4235-9E9B-A4290BBE20A1__CreatingTheSALES_VIEWViewForPivotin-0B828FA2">
                        <p class="titleinexample">示例19-26为透视示例创建SALES_VIEW视图</p>
                        <p>以下示例创建<code class="codeph">sales_view</code>视图，该视图用作说明透视使用的基础。
                        </p><pre class="oac_no_warn" dir="ltr">CREATE VIEW sales_view AS SELECT prod_name product，country_name country，channel_id channel，SUBSTR（calendar_quarter_desc，6,2）quarter，SUM（amount_sold）amount_sold，SUM（quantity_sold）quantity_sold FROM sales，times，customers，countries，products WHERE sales.time_id = times.time_id AND sales.prod_id = products.prod_id AND sales.cust_id = customers.cust_id AND customers.country_id = countries.country_id GROUP BY prod_name，country_name，channel_id，SUBSTR（calendar_quarter_desc，6,2）;</pre></div>
                     <!-- class="example" -->
                  </div>
               </div><a id="DWHSG8729"></a><div class="props_rev_3"><a id="GUID-84C81897-0484-4F40-938B-D1D7F5EA4D97" name="GUID-84C81897-0484-4F40-938B-D1D7F5EA4D97"></a><h4 id="DWHSG-GUID-84C81897-0484-4F40-938B-D1D7F5EA4D97" class="sect4"><span class="enumeration_section">19.4.2</span>透视示例</h4>
                  <div>
                     <div class="section">
                        <p>以下语句说明了如<a href="sql-analysis-reporting-data-warehouses.html#GUID-72A2DEB6-003B-4235-9E9B-A4290BBE20A1__CreatingTheSALES_VIEWViewForPivotin-0B828FA2">示例19-26中</a>所述创建的视图<code class="codeph">sales_view</code>的<code class="codeph">channel</code>列上的典型透视图：</p><pre class="oac_no_warn" dir="ltr">SELECT * FROM（SELECT product，channel，amount_sold FROM sales_view）S PIVOT（SUM（amount_sold）FOR CHANNEL IN（3 AS DIRECT_SALES，4 AS INTERNET_SALES，5 AS CATALOG_SALES，9 AS TELESALAL））按产品订购; PRODUCT DIRECT_SALES INTERNET_SALES CATALOG_SALES TELESALES ---------------------- ------------ ----------- --- ------------- --------- ...内部6X CD-ROM 229512.97 26249.55内部8X CD-ROM 286291.49 42809.44键盘腕托200959.84 38695.36 1522.73 ...
</pre><p>请注意，输出已创建四个新的<code class="codeph">DIRECT_SALES</code> ， <code class="codeph">DIRECT_SALES</code> ， <code class="codeph">INTERNET_SALES</code> ， <code class="codeph">CATALOG_SALES</code>和<code class="codeph">TELESALES</code> ，每个列对应一个透视值。输出是一个总和。如果未提供别名，则列标题将为<code class="codeph">IN</code> -list的值。
                        </p>
                     </div>
                     <!-- class="section" -->
                  </div>
               </div><a id="DWHSG8730"></a><div class="props_rev_3"><a id="GUID-BC68A3FF-165D-4711-A94E-6C953E96EF7E" name="GUID-BC68A3FF-165D-4711-A94E-6C953E96EF7E"></a><h4 id="DWHSG-GUID-BC68A3FF-165D-4711-A94E-6C953E96EF7E" class="sect4"><span class="enumeration_section">19.4.3</span>在多列上进行透视</h4>
                  <div>
                     <div class="section">
                        <p>您可以在多个列上进行旋转。以下语句说明了如<a href="sql-analysis-reporting-data-warehouses.html#GUID-72A2DEB6-003B-4235-9E9B-A4290BBE20A1__CreatingTheSALES_VIEWViewForPivotin-0B828FA2">示例19-26中</a>所述创建的视图<code class="codeph">sales_view</code>上的典型多列数据透视表：</p><pre class="oac_no_warn" dir="ltr">SELECT * FROM（SELECT product，channel，quarter，quantity_sold FROM sales_view）PIVOT（SUM（quantity_sold）FOR（channel，quarter）IN（（5，'02'）AS CATALOG_Q2，（4，'01'）AS INTERNET_Q1，（ 4，'04'）AS INTERNET_Q4，（2，'02'）AS PARTNERS_Q2，（9，'03'）AS TELE_Q3））; PRODUCT CATALOG_Q2 INTERNET_Q1 INTERNET_Q4 PARTNERS_Q2 TELE_Q3 ------- ---------- ----------- ----------- ----- ------ ------- ......反弹347 632 954 ......粉碎拳击129 280 560 ......漫画书英雄47 155 275 ...
</pre><p>请注意，此示例指定了一个多列<code class="codeph">IN</code> ，其列标题旨在匹配<code class="codeph">IN</code> -list成员。
                        </p>
                     </div>
                     <!-- class="section" -->
                  </div>
               </div><a id="DWHSG8731"></a><div class="props_rev_3"><a id="GUID-6A8D63AC-5E88-47A8-B5A6-9318173F0206" name="GUID-6A8D63AC-5E88-47A8-B5A6-9318173F0206"></a><h4 id="DWHSG-GUID-6A8D63AC-5E88-47A8-B5A6-9318173F0206" class="sect4"><span class="enumeration_section">19.4.4</span>透视：多个聚合</h4>
                  <div>
                     <div class="section">
                        <p>您可以使用多个聚合进行透视，如以下示例所示，该示例在<a href="sql-analysis-reporting-data-warehouses.html#GUID-72A2DEB6-003B-4235-9E9B-A4290BBE20A1__CreatingTheSALES_VIEWViewForPivotin-0B828FA2">示例19-26中</a>创建的<code class="codeph">sales_view</code>中聚合多个聚合：</p><pre class="oac_no_warn" dir="ltr">SELECT * FROM（SELECT product，channel，amount_sold，quantity_sold FROM sales_view）PIVOT（SUM（amount_sold）AS sums，SUM（quantity_sold）AS sumq FOR channel IN（5,4,2,9））ORDER BY product;</pre><pre class="oac_no_warn" dir="ltr">产品5_SUMS 5_SUMQ 4_SUMS 4_SUMQ 2_SUMS 2_SUMQ 9_SUMS 9_SUMQ ------------- ------ ------ ------ ------ ---- -  ------ ------ ------ O / S Doc Set English 142780.36 3081 381397.99 8044 6028.66 134 O / S Doc Set French 55503.58 1192 132000.77 2782 ...
 </pre><p>请注意，查询通过连接数据透视表值，下划线字符（_）和聚合列的别名来创建列标题。如果生成的列标题的长度超过列名的最大长度，则返回<code class="codeph">ORA-00918</code>错误。要避免此错误，请使用<code class="codeph">AS</code> <span class="italic"><code class="codeph">alias</code></span>为数据透视表列标题指定较短的列别名，聚合值列名称或两者。 <span class="q">“ <a href="sql-analysis-reporting-data-warehouses.html#GUID-BC68A3FF-165D-4711-A94E-6C953E96EF7E">在多个列上</a></span>进行透视<span class="q">”</span>演示了如何使用透视值的别名。
                        </p>
                        <div class="infoboxnotealso" id="GUID-6A8D63AC-5E88-47A8-B5A6-9318173F0206__GUID-6125A56E-0E36-4A6C-A15A-4AFCAA03AD02">
                           <p class="notep1">也可以看看：</p>
                           <p>有关列名最大长度的信息，请<span class="italic">参见“Oracle数据库SQL语言参考</span> ”</p>
                        </div>
                     </div>
                     <!-- class="section" -->
                  </div>
               </div><a id="DWHSG8732"></a><div class="props_rev_3"><a id="GUID-3BBB2991-DC84-4BB1-B7DC-797F8817732C" name="GUID-3BBB2991-DC84-4BB1-B7DC-797F8817732C"></a><h4 id="DWHSG-GUID-3BBB2991-DC84-4BB1-B7DC-797F8817732C" class="sect4"><span class="enumeration_section">19.4.5</span>在源数据中区分PIVOT生成的空值和空值</h4>
                  <div>
                     <p>您可以区分使用<code class="codeph">PIVOT</code>生成的空值和源数据中存在的空值。以下示例说明了<code class="codeph">PIVOT</code>生成的空值。
                     </p>
                     <p>以下查询返回具有5列的列，列<code class="codeph">prod_id</code>和数据透视结果列<code class="codeph">Q1</code> ， <code class="codeph">Q1_COUNT_TOTAL</code> ， <code class="codeph">Q2</code> ， <code class="codeph">Q2_COUNT_TOTAL</code> 。对于每个唯一值<code class="codeph">prod_id</code> ， <code class="codeph">Q1_COUNT_TOTAL</code>返回行的总数，其<code class="codeph">qtr</code>值<code class="codeph">Q1</code> ，即，和<code class="codeph">Q2_COUNT_TOTAL</code>返回行的总数，其<code class="codeph">qtr</code>值<code class="codeph">Q2</code> 。
                     </p>
                     <p>假设您有以下结构的表<code class="codeph">sales2</code> ：</p><pre class="oac_no_warn" dir="ltr">PROD_ID QTR AMOUNT_SOLD ------- --- ----------- 100 Q1 10 100 Q1 20 100 Q2 NULL 200 Q1 50 SELECT * FROM sales2 PIVOT（SUM（amount_sold），COUNT（*） ）AS count_total FOR qtr IN（'Q1'，'Q2'））; PROD_ID“Q1”“Q1_COUNT_TOTAL”“Q2”“Q2_COUNT_TOTAL”------- ---- ---------------- ---------  - --------------- 100 20 2 NULL &lt;1&gt; 1 200 50 1 NULL &lt;2&gt; 0</pre><p>由上可知，你知道， <code class="codeph">prod_id</code> 100，有2个销售行的季度<code class="codeph">Q1</code>和1个销售一行季度<code class="codeph">Q2</code> ;对于<code class="codeph">prod_id</code> 200，有1个销售一行季度<code class="codeph">Q1</code> ，并没有销售一行季度<code class="codeph">Q2</code> 。因此，在<code class="codeph">Q2_COUNT_TOTAL</code> ，您可以确定<code class="codeph">NULL&lt;1&gt;</code>来自原始表中度量为空值的行，而<code class="codeph">NULL&lt;2&gt;</code>是由于<code class="codeph">Q2</code> <code class="codeph">prod_id</code> 200的原始表中没有行。
                     </p>
                  </div>
               </div><a id="DWHSG8734"></a><div class="props_rev_3"><a id="GUID-C4AF4C41-55D1-402F-89C1-ED83C7986395" name="GUID-C4AF4C41-55D1-402F-89C1-ED83C7986395"></a><h4 id="DWHSG-GUID-C4AF4C41-55D1-402F-89C1-ED83C7986395" class="sect4"><span class="enumeration_section">19.4.6</span>使用XML操作的通配符和子查询</h4>
                  <div>
                     <p>如果要在透视列中使用通配符参数或子查询，可以使用<code class="codeph">PIVOT</code> XML语法执行此操作。使用<code class="codeph">PIVOT</code> XML，操作的输出是格式正确的XML。</p>
                     <p>以下示例说明如何使用通配符关键字<code class="codeph">ANY</code> 。它输出包含<code class="codeph">sales_view</code>所有通道值的<code class="codeph">sales_view</code> ：</p><pre class="oac_no_warn" dir="ltr">SELECT * FROM（SELECT product，channel，quantity_sold FROM sales_view）PIVOT XML（SUM（quantity_sold）FOR通道IN（ANY））;</pre><p>有关创建视图<code class="codeph">sales_view</code>的语法，请参见<a href="sql-analysis-reporting-data-warehouses.html#GUID-72A2DEB6-003B-4235-9E9B-A4290BBE20A1__CreatingTheSALES_VIEWViewForPivotin-0B828FA2">示例19-26</a> 。
                     </p>
                     <p>请注意，关键字<code class="codeph">ANY</code>仅在<code class="codeph">PIVOT</code>操作中作为XML操作的一部分提供。此输出包括数据集中存在通道的情况的数据。另请注意，聚合函数必须指定<code class="codeph">GROUP</code> <code class="codeph">BY</code>子句以返回多个值，但<code class="codeph">pivot_clause</code>不包含显式的<code class="codeph">GROUP</code> <code class="codeph">BY</code>子句。而是， <code class="codeph">pivot_clause</code>执行隐式<code class="codeph">GROUP</code> <code class="codeph">BY</code> 。</p>
                     <p>以下示例说明了如何使用子查询。它输出的XML包含所有通道值和每个通道对应的销售数据：</p><pre class="oac_no_warn" dir="ltr">SELECT * FROM（SELECT product，channel，quantity_sold FROM sales_view）PIVOT XML（SUM（quantity_sold）FOR通道IN（SELECT DISTINCT channel_id FROM CHANNELS））;</pre><p>输出将数据加密以包括每个产品的所有可能通道。</p>
                  </div>
               </div>
            </div><a id="DWHSG8733"></a><div class="props_rev_3"><a id="GUID-B0AC9284-DDC1-4EF7-84CD-A27DF7F8DD57" name="GUID-B0AC9284-DDC1-4EF7-84CD-A27DF7F8DD57"></a><h3 id="DWHSG-GUID-B0AC9284-DDC1-4EF7-84CD-A27DF7F8DD57" class="sect3"><span class="enumeration_section">19.5非</span>动作操作</h3>
               <div>
                  <div class="section">
                     <p>一个unpivot不会反转<code class="codeph">PIVOT</code>操作。相反，它将数据从列旋转为行。如果您正在使用透视数据，则<code class="codeph">UNPIVOT</code>操作无法撤消<code class="codeph">PIVOT</code>或任何其他方式所做的任何聚合。
                     </p>
                     <p>为了说明不透视，首先创建一个包含四列的透视表，每年四分之一。以下命令基于如<a href="sql-analysis-reporting-data-warehouses.html#GUID-72A2DEB6-003B-4235-9E9B-A4290BBE20A1__CreatingTheSALES_VIEWViewForPivotin-0B828FA2">示例19-26中</a>所述创建的视图<code class="codeph">sales_view</code>创建表：</p><pre class="oac_no_warn" dir="ltr">CREATE TABLE pivotedTable AS SELECT * FROM（SELECT product，quarter，quantity_sold，amount_sold FROM sales_view）PIVOT（SUM（quantity_sold）AS sumq，SUM（amount_sold）AS suma FOR季度IN（'01'AS Q1，'02'AS Q2， '03'为Q3，'04'为Q4））;</pre><p>表的内容类似于以下内容：</p><pre class="oac_no_warn" dir="ltr">SELECT * FROM pivotedTable ORDER BY产品;产品Q1_SUMQ Q1_SUMA Q2_SUMQ Q2_SUMA Q3_SUMQ Q3_SUMA Q4_SUMQ Q4_SUMA --------------- ------- ------- ------- ----- --- ------- -------- ------- --------- 1.44MB外部6098 58301.33 5112 49001.56 6050 56974.3 5848 55341.28 128MB内存1963 110763.63 2361 132123.12 3069 170710.4 2832 157736.6 17“LCD 1492 1812786.94 1387 1672389.06 1591 1859987.66 1540 1844008.11 ...
</pre><p>以下<code class="codeph">UNPIVOT</code>操作将四分之一列旋转为行。对于每个产品，将有四行，每季度一行。
                     </p><pre class="oac_no_warn" dir="ltr">SELECT产品，DECODE（季度，'Q1_SUMQ'，'Q1'，'Q2_SUMQ'，'Q2'，'Q3_SUMQ'，'Q3'，'Q4_SUMQ'，'Q4'）AS quarter，quantity_sold FROM pivotedTable UNPIVOT INCLUDE NULLS（quantity_sold FOR季度IN（Q1_SUMQ，Q2_SUMQ，Q3_SUMQ，Q4_SUMQ））ORDER BY产品，季度;产品QU QUANTITY_SOLD -------  -  ------------- 1.44MB外置3.5“软盘Q1 6098 1.44MB外置3.5”软盘Q2 5112 1.44MB外置3.5“软盘Q3 6050 1.44 MB外置3.5“软盘Q4 5848 128MB存储卡Q1 1963 128MB存储卡Q2 2361 128MB存储卡Q3 3069 128MB存储卡Q4 2832 ...
</pre><p>请注意在此示例中使用<code class="codeph">INCLUDE</code> <code class="codeph">NULLS</code> 。您也可以使用<code class="codeph">EXCLUDE</code> <code class="codeph">NULLS</code> ，这是默认设置。
                     </p>
                     <p>此外，您还可以使用两列进行取消操作，如下所示：</p><pre class="oac_no_warn" dir="ltr">SELECT product，quarter，quantity_sold，amount_sold FROM pivotedTable UNPIVOT INCLUDE NULLS（（quantity_sold，amount_sold）FOR季度IN（（Q1_SUMQ，Q1_SUMA）AS'Q1'，（Q2_SUMQ，Q2_SUMA）AS'Q2'，（Q3_SUMQ，Q3_SUMA）AS' Q3'，（Q4_SUMQ，Q4_SUMA）AS'Q4'））按产品订购，季度; PRODUCT QU QUANTITY_SOLD AMOUNT_SOLD -----------------------------  -  -------------  - ---------- 1.44MB外置3.5“软盘Q1 6098 58301.33 1.44MB外置3.5”软盘Q2 5112 49001.56 1.44MB外置3.5“软盘Q3 6050 56974.3 1.44MB外置3.5”软盘Q4 5848 55341.28 128MB存储卡Q1 1963 110763.63 128MB存储卡Q2 2361 132123.12 128MB存储卡Q3 3069 170710.4 128MB存储卡Q4 2832 157736.6</pre></div>
                  <!-- class="section" -->
               </div>
            </div><a id="DWHSG02013"></a><div class="props_rev_3"><a id="GUID-01B5DD6F-C039-4223-B017-263F7788C4FA" name="GUID-01B5DD6F-C039-4223-B017-263F7788C4FA"></a><h3 id="DWHSG-GUID-01B5DD6F-C039-4223-B017-263F7788C4FA" class="sect3"><span class="enumeration_section">19.6</span>报告的数据密集度</h3>
               <div>
                  <p>数据是<a id="d65966e5546" class="indexterm-anchor"></a><a id="d65966e5548" class="indexterm-anchor"></a><a id="d65966e5550" class="indexterm-anchor"></a>通常以稀疏形式存储。也就是说，如果给定的维度值组合不存在任何值，则事实表中不存在任何行。但是，您可能希望以密集形式查看数据，即使没有任何事实数据，也会显示所有维值组合的行。例如，如果某个产品在特定时间段内没有销售，您可能仍希望查看该时间段内的产品，其旁边的销售额为零。此外，当数据沿时间维度密集时，可以最容易地执行时间序列计算。这是因为密集数据将为每个周期填充一致的行数，这反过来使得使用具有物理偏移的分析窗口函数变得简单。数据密集化是将稀疏数据转换为密集形式的过程。
                  </p>
                  <p>要克服稀疏性问题，可以使用分区外部联接来填充时间序列或任何其他维度中的间隙。这种连接通过将外连接应用于查询中定义的每个逻辑分区来扩展传统的外连接语法。Oracle根据您在<code class="codeph">PARTITION</code> <code class="codeph">BY</code>子句中指定的表达式在逻辑上对查询中的行进行<code class="codeph">PARTITION</code> 。分区外连接的结果是逻辑分区表中每个分区的外连接的<code class="codeph">UNION</code> ，以及连接另一侧的表。
                  </p>
                  <p>请注意，您可以使用此类型的连接来填充任何维度中的间隙，而不仅仅是时间维度。这里的大多数示例都关注时间维度，因为它是最常用作比较基础的维度。</p>
                  <p>本节包含以下主题：</p>
                  <ul style="list-style-type:disc">
                     <li>
                        <p><a href="sql-analysis-reporting-data-warehouses.html#GUID-F0ADB2FE-730D-42D7-9FE4-9C80206E1F96">关于分区加入语法</a></p>
                     </li>
                     <li>
                        <p><a href="sql-analysis-reporting-data-warehouses.html#GUID-57532559-6AB4-45AB-A52D-4B6E3E12A4EE">稀疏数据样本</a></p>
                     </li>
                     <li>
                        <p><a href="sql-analysis-reporting-data-warehouses.html#GUID-A0114A13-F31D-4B41-8069-AB85A72957FC">填补数据空白</a></p>
                     </li>
                     <li>
                        <p><a href="sql-analysis-reporting-data-warehouses.html#GUID-89C96A7C-5A1E-41D4-A77E-97B8D7C4C8AD">填补两个方面的差距</a></p>
                     </li>
                     <li>
                        <p><a href="sql-analysis-reporting-data-warehouses.html#GUID-10D0FC5B-5E59-4F54-AB8F-B5CD4479BD70">填补库存表中的空白</a></p>
                     </li>
                     <li>
                        <p><a href="sql-analysis-reporting-data-warehouses.html#GUID-1778791F-C3CF-485D-8EEC-D861316828B7">计算数据值以填补空白</a></p>
                     </li>
                  </ul>
               </div><a id="DWHSG8735"></a><div class="props_rev_3"><a id="GUID-F0ADB2FE-730D-42D7-9FE4-9C80206E1F96" name="GUID-F0ADB2FE-730D-42D7-9FE4-9C80206E1F96"></a><h4 id="DWHSG-GUID-F0ADB2FE-730D-42D7-9FE4-9C80206E1F96" class="sect4"><span class="enumeration_section">19.6.1</span>关于分区连接语法</h4>
                  <div>
                     <p>分区外连接的语法使用短语<code class="codeph">PARTITION</code> <code class="codeph">BY</code>后跟表达式列表扩展SQL <code class="codeph">JOIN</code>子句。列表中的表达式指定应用外部联接的组。以下是通常用于分区外连接的两种语法形式：</p><pre class="oac_no_warn" dir="ltr">选择 .....FROM table_reference PARTITION BY（expr [，expr] ...）RIGHT OUTER JOIN table_reference SELECT .....FROM table_reference LEFT OUTER JOIN table_reference PARTITION BY {expr [，expr] ...）
</pre><p>请注意，分区外连接不支持<code class="codeph">FULL</code> <code class="codeph">OUTER</code> <code class="codeph">JOIN</code> 。
                     </p>
                  </div>
               </div><a id="DWHSG8736"></a><div class="props_rev_3"><a id="GUID-57532559-6AB4-45AB-A52D-4B6E3E12A4EE" name="GUID-57532559-6AB4-45AB-A52D-4B6E3E12A4EE"></a><h4 id="DWHSG-GUID-57532559-6AB4-45AB-A52D-4B6E3E12A4EE" class="sect4"><span class="enumeration_section">19.6.2</span>稀疏数据样本</h4>
                  <div>
                     <p>下面的示例显示了具有稀疏维度的典型情况，该示例计算2000年和2001年20-30周的产品Bounce的每周销售额和年初至今的销售额：</p><pre class="oac_no_warn" dir="ltr">SELECT SUBSTR（p。Prod_Name，1,15）Product_Name，t。Calendar_Year年，t。Calendar_Week_Number周，SUM（Amount_Sold）Sales FROM Sales s，Times t，Products t WHERE s。Time_id = t。Time_id和s。Prod_id = p。Prod_id和p。Prod_name IN（'Bounce'）和t。Calendar_Year IN（2000,2001）AND t。Calendar_Week_Number在20和30 GROUP之间。Prod_Name，t。Calendar_Year，t。Calendar_Week_Number; PRODUCT_NAME每周销售--------------- ---------- ---------- ----------反弹2000 20 801 Bounce 2000 21 4062.24 Bounce 2000 22 2043.16 Bounce 2000 23 2731.14 Bounce 2000 24 4419.36 Bounce 2000 27 2297.29 Bounce 2000 28 1443.13 Bounce 2000 29 1927.38 Bounce 2000 30 1927.38 Bounce 2001 20 1483.3 Bounce 2001 21 4184.49 Bounce 2001 22 2609.19 Bounce 2001 23 1416.95 Bounce 2001 24 3149.62 Bounce 2001 25 2645.98 Bounce 2001 27 2125.12 Bounce 2001 29 2467.92 Bounce 2001 30 2620.17</pre><p>在这个例子中，如果数据密集，你会期望22行数据（从2年开始每周11周）。但是，你只得到18行，因为2000年25周和26周失踪，2001年失去了26周和28周。</p>
                  </div>
               </div><a id="DWHSG8737"></a><div class="props_rev_3"><a id="GUID-A0114A13-F31D-4B41-8069-AB85A72957FC" name="GUID-A0114A13-F31D-4B41-8069-AB85A72957FC"></a><h4 id="DWHSG-GUID-A0114A13-F31D-4B41-8069-AB85A72957FC" class="sect4"><span class="enumeration_section">19.6.3</span>填补数据空白</h4>
                  <div>
                     <div class="section">
                        <p>您可以获取稀疏数据<a href="sql-analysis-reporting-data-warehouses.html#GUID-57532559-6AB4-45AB-A52D-4B6E3E12A4EE">样本中</a>显示的查询<a href="sql-analysis-reporting-data-warehouses.html#GUID-57532559-6AB4-45AB-A52D-4B6E3E12A4EE">的稀疏数据</a> ，并使用一组密集的时间数据执行分区外连接。在下面的查询，您的别名原始查询为<code class="codeph">v</code> ，你选择从数据<code class="codeph">times</code>表，您作为别名<code class="codeph">t</code> 。这里检索22行，因为系列中没有间隙。通过使用<code class="codeph">NVL</code>函数，四个添加的行每个都有0作为其Sales值设置为0。
                        </p><pre class="oac_no_warn" dir="ltr">SELECT Product_Name，t。年，t。周，NVL（销售，0）dense_sales FROM（SELECT SUBSTR（p。Prod_Name，1,15）Product_Name，t。Calendar_Year年，t。Calendar_Week_Number周，SUM（Amount_Sold）Sales FROM Sales s，Times t，Products t WHERE s。Time_id = t。Time_id和s。Prod_id = p。Prod_id和p。Prod_name IN（'Bounce'）和t。Calendar_Year IN（2000,2001）AND t。Calendar_Week_Number在20和30 GROUP之间。Prod_Name，t。Calendar_Year，t。Calendar_Week_Number）v PARTITION BY（v.Product_Name）RIGHT OUTER JOIN（SELECT DISTINCT Calendar_Week_Number Week，Calendar_Year Year FROM Times WHERE Calendar_Year IN（2000,2001）AND Calendar_Week_Number BETWEEN 20 AND 30）t ON（v.week = t.week AND v 。年= t。年）订购年，t.week;</pre><pre class="oac_no_warn" dir="ltr">PRODUCT_NAME YEAR WEEK DENSE_SALES --------------- ---------- ---------- ----------- Bounce 2000 20 801 Bounce 2000 21 4062.24 Bounce 2000 22 2043.16 Bounce 2000 23 2731.14 Bounce 2000 24 4419.36 Bounce 2000 25 0 Bounce 2000 26 0 Bounce 2000 27 2297.29 Bounce 2000 28 1443.13 Bounce 2000 29 1927.38 Bounce 2000 30 1927.38 Bounce 2001 20 1483.3 Bounce 2001 21 4184.49 Bounce 2001 22 2609.19 Bounce 2001 23 1416.95 Bounce 2001 24 3149.62 Bounce 2001 25 2645.98 Bounce 2001 26 0 Bounce 2001 27 2125.12 Bounce 2001 28 0 Bounce 2001 29 2467.92 Bounce 2001 30 2620.17</pre><p>请注意，在此查询中， <code class="codeph">WHERE</code>条件在时间维度的内联视图中放置了20到30周。引入它是为了保持结果集较小。
                        </p>
                     </div>
                     <!-- class="section" -->
                  </div>
               </div><a id="DWHSG8738"></a><div class="props_rev_3"><a id="GUID-89C96A7C-5A1E-41D4-A77E-97B8D7C4C8AD" name="GUID-89C96A7C-5A1E-41D4-A77E-97B8D7C4C8AD"></a><h4 id="DWHSG-GUID-89C96A7C-5A1E-41D4-A77E-97B8D7C4C8AD" class="sect4"><span class="enumeration_section">19.6.4</span>填充两个维度的间隙</h4>
                  <div>
                     <div class="section">
                        <p>N维数据通常显示为（n-2）页面维度的密集二维交叉表。这要求填写交叉表中出现的两个维度的所有维值。以下是另一个示例，其中分区外连接功能可用于填充两个维度上的间隙：</p><pre class="oac_no_warn" dir="ltr">WITH v1 AS（SELECT p.prod_id，country_id，calendar_year，SUM（quantity_sold）单位，SUM（amount_sold）销售额FROM销售额s，产品p，客户c，次数t WHERE s.prod_id in（147,148）AND t.time_id = s.time_id AND c.cust_id = s.cust_id AND p.prod_id = s.prod_id GROUP BY p.prod_id，country_id，calendar_year），v2 AS  - 用于密度化的国家（SELECT DISTINCT country_id FROM customers WHERE country_id IN（ 52782,52785,52786,52787,52788）），v3 AS  - 用于致密化的年份（SELECT DISTINCT calendar_year FROM times）SELECT v4.prod_id，v4.country_id，v3.calendar_year，units，sales FROM（SELECT prod_id，v2 .country_id，calendar_year，units，sales FROM v1 PARTITION BY（prod_id）RIGHT OUTER JOIN v2  - 在国家/地区收缩（v1.country_id = v2.country_id））v4 PARTITION BY（prod_id，country_id）RIGHT OUTER JOIN v3 --densifies on ON（v4.calendar_year = v3.calendar_year）ORDER BY 1,2,3;</pre><p>在此查询中， <code class="codeph">WITH</code>子查询因子子句<code class="codeph">v1</code>汇总了产品，国家和年级的销售数据。此结果很少，但用户可能希望查看每个产品的所有国家/地区年份组合。为实现此目的，您需要根据产品值获取<code class="codeph">v1</code>的每个分区，然后首先将其连接到国家/地区维度上。这将为我们提供每种产品的所有国家价值。然后，您获取该结果并将其分区为产品和国家/地区值，然后将其外部连接到时间维度上。这将为我们提供每个产品和国家/地区组合的所有时间值。
                        </p><pre class="oac_no_warn" dir="ltr">PROD_ID COUNTRY_ID CALENDAR_YEAR单位销售---------- ---------- ------------- ----------  - -------- 147 52782 1998 147 52782 1999 29 209.82 147 52782 2000 71 594.36 147 52782 2001 345 2754.42 147 52782 2002 147 52785 1998 1 7.99 147 52785 1999 147 52785 2000 147 52785 2001 147 52785 2002 147 52786 1998 1 7.99 147 52786 1999 147 52786 2000 2 15.98 147 52786 2001 147 52786 2002 147 52787 1998 147 52787 1999 147 52787 2000 147 52787 2001 147 52787 2002 147 52788 1998 147 52788 1999 147 52788 2000 1 7.99 147 52788 2001 147 52788 2002 148 52782 1998 139 4046.67 148 52782 1999 228 5362.57 148 52782 2000 251 5629.47 148 52782 2001 308 7138.98 148 52782 2002 148 52785 1998 148 52785 1999 148 52785 2000 148 52785 2001 148 52785 2002 148 52786 1998 148 52786 1999 148 52786 2000 148 52786 2001 148 52786 2002 148 52787 1998 148 52787 1999 148 52787 2000 148 52787 2001 148 52787 2002 148 52788 1998 4 117.23 148 52788 1999 148 52788 2000 148 52788 2001 148 52788 2002</pre></div>
                     <!-- class="section" -->
                  </div>
               </div><a id="DWHSG8739"></a><div class="props_rev_3"><a id="GUID-10D0FC5B-5E59-4F54-AB8F-B5CD4479BD70" name="GUID-10D0FC5B-5E59-4F54-AB8F-B5CD4479BD70"></a><h4 id="DWHSG-GUID-10D0FC5B-5E59-4F54-AB8F-B5CD4479BD70" class="sect4"><span class="enumeration_section">19.6.5</span>填写库存表中的空白</h4>
                  <div>
                     <div class="section">
                        <p>库存表通常跟踪各种产品可用的单位数量。这个表很稀疏：它只在有事件时为产品存储一行。对于销售表，事件是销售，对于库存表，事件是产品可用数量的变化。例如，请考虑以下库存表：</p><pre class="oac_no_warn" dir="ltr">CREATE TABLE invent_table（product VARCHAR2（10），time_id DATE，quant NUMBER）; INSERT INTO invent_table VALUES（'bottle'，TO_DATE（'01 / 04/01'，'DD / MM / YY'），10）; INSERT INTO invent_table VALUES（'bottle'，TO_DATE（'06 / 04/01'，'DD / MM / YY'），8）; INSERT INTO invent_table VALUES（'can'，TO_DATE（'01 / 04/01'，'DD / MM / YY'），15）; INSERT INTO invent_table VALUES（'can'，TO_DATE（'04 / 04/01'，'DD / MM / YY'），11）;</pre><p>库存表现在具有以下行：</p><pre class="oac_no_warn" dir="ltr">PRODUCT TIME_ID QUANT ---------- --------- ----- bottle 01-APR-01 10瓶06-APR-01 8罐01-APR-01 15罐04 -APR-01 11</pre><p>出于报告目的，用户可能希望以不同方式查看此库存数据。例如，他们可能希望查看每种产品的所有时间值。这可以使用分区外连接来完成。另外，对于新插入的缺失时间段行，用户可能希望从最近的现有时间段看到要承载的单位数量列的值。后者可以使用分析窗口函数<code class="codeph">LAST_VALUE</code>值来完成。这是查询和所需的输出：</p><pre class="oac_no_warn" dir="ltr">WITH v1 AS（SELECT time_id FROM times WHERE times.time_id BETWEEN TO_DATE（'01 / 04/01'，'DD / MM / YY'）和TO_DATE（'07 / 04/01'，'DD / MM / YY'） ）SELECT product，time_id，quant quantity，LAST_VALUE（quant IGNORE NULLS）OVER（PARTITION BY product ORDER BY time_id）repeated_quantity FROM（SELECT product，v1.time_id，quant FROM invent_table PARTITION BY（product）RIGHT OUTER JOIN v1 ON（v1。 time_id = invent_table.time_id））ORDER BY 1,2;</pre><p>内部查询在每个产品中按时计算分区外连接。内部查询会对时间维度上的数据进行加密（这意味着时间维度现在每周的每一天都有一行）。但是，测量列<code class="codeph">quantity</code>对于新添加的行将具有空值（请参阅以下结果中的列<code class="codeph">quantity</code>中的输出。
                        </p>
                        <p>外部查询使用分析函数<code class="codeph">LAST_VALUE</code> 。应用此功能按产品对数据进行分区，并在时间维度列（ <code class="codeph">time_id</code> ）上对数据进行<code class="codeph">time_id</code> 。对于每一行，此函数找到该窗口中的最后一个非空值由于选项<code class="codeph">IGNORE</code> <code class="codeph">NULLS</code> ，您可以都使用<code class="codeph">LAST_VALUE</code>和<code class="codeph">FIRST_VALUE</code> 。你看在列所需的输出<code class="codeph">repeated_quantity</code>在以下的输出：</p><pre class="oac_no_warn" dir="ltr">PRODUCT TIME_ID QUANTITY REPEATED_QUANTITY ---------- --------- -------- ----------------- bottle 01 -APR-01 10 10瓶02-APR-01 10瓶03-APR-01 10瓶04-APR-01 10瓶05-APR-01 10瓶06-APR-01 8 8瓶07-APR-01 8罐01-APR-01 15 15 can 02-APR-01 15 can 03-APR-01 15 can 04-APR-01 11 11 can 05-APR-01 11 can 06-APR-01 11 can 07-APR-01 11</pre></div>
                     <!-- class="section" -->
                  </div>
               </div><a id="DWHSG8740"></a><div class="props_rev_3"><a id="GUID-1778791F-C3CF-485D-8EEC-D861316828B7" name="GUID-1778791F-C3CF-485D-8EEC-D861316828B7"></a><h4 id="DWHSG-GUID-1778791F-C3CF-485D-8EEC-D861316828B7" class="sect4"><span class="enumeration_section">19.6.6</span>计算数据值以填补空白</h4>
                  <div>
                     <div class="section">
                        <p>例子<a id="d65966e5861" class="indexterm-anchor"></a>在“ <a href="sql-analysis-reporting-data-warehouses.html#GUID-A0114A13-F31D-4B41-8069-AB85A72957FC">填充数据空白”</a> ，“ <a href="sql-analysis-reporting-data-warehouses.html#GUID-89C96A7C-5A1E-41D4-A77E-97B8D7C4C8AD">填充两维</a> <a href="sql-analysis-reporting-data-warehouses.html#GUID-10D0FC5B-5E59-4F54-AB8F-B5CD4479BD70">空白”</a>和“ <a href="sql-analysis-reporting-data-warehouses.html#GUID-10D0FC5B-5E59-4F54-AB8F-B5CD4479BD70">填充库存表中的空白”部分中，</a>说明了如何使用分区外部连接填充一个或多个维度中的空白。但是，分区外连接生成的结果集对于未包含在<code class="codeph">PARTITION</code> <code class="codeph">BY</code>列表中的列具有空值。通常，这些是度量列。用户可以使用分析SQL函数将这些空值替换为非空值。
                        </p>
                        <p>例如，以下查询计算2000年产品64MB存储卡和DVD-R光盘（产品ID 122和136）的每月总计。它使用分区外连接来密集所有月份的数据。对于缺失的月份，它然后使用分析SQL函数<code class="codeph">AVG</code>计算销售额和单位，以计算产品销售月份的平均值。
                        </p>
                        <p>如果在SQL * Plus中工作，则以下两个命令将包含列标题以提高结果的可读性：</p><pre class="oac_no_warn" dir="ltr">col computed_units heading'Computed | _units'col computed_sales heading'Computed | _sales'WITH AS（SELECT substr（p.prod_name，1,12）prod_name，calendar_month_desc，SUM（quantity_sold）units，SUM（amount_sold）sales FROM sales s， products p，times t WHERE s.prod_id IN（122,136）AND calendar_year = 2000 AND t.time_id = s.time_id AND p.prod_id = s.prod_id GROUP BY p.prod_name，calendar_month_desc）SELECT v.prod_name，calendar_month_desc，units， sales，NVL（单位，AVG（单位）OVER（PARTITION BY v.prod_name））computed_units，NVL（sales，AVG（sales）OVER（PARTITION BY v.prod_name））computed_sales FROM（SELECT DISTINCT calendar_month_desc FROM times WHERE calendar_year = 2000 ）t LEFT OUTER JOIN V PARTITION BY（prod_name）USING（calendar_month_desc）;计算出的计算PROD_NAME日历单位销售_单位_sales ------------ -------- ---------- ----------  - ---------------- 64MB内存2000-01 112 4129.72 112 4129.72 64MB内存2000-02 190 7049 190 7049 64MB内存2000-03 47 1724.98 47 1724.98 64MB内存2000-04 20 739.4 20 739.4 64MB内存2000-05 47 1738.24 47 1738.24 64MB内存2000-06 20 739.4 20 739.4 64MB内存2000-07 72.6666667 2686.79 64MB内存2000-08 72.6666667 2686.79 64MB内存2000-09 72.6666667 2686.79 64MB内存2000-10 72.6666667 2686.79 64MB内存2000-11 72.6666667 2686.79 64MB内存2000-12 72.6666667 2686.79 DVD-R光盘，2000-01 167 3683.5 167 3683.5 DVD-R光盘，2000-02 152 3362.24 152 3362.24 DVD-R光盘，2000-03 188 4148.02 188 4148.02 DVD-R光盘，2000-04 144 3170.09 144 3170.09 DVD-R光盘，2000-05 189 4164.87 189 4164.87 DVD-R光盘，2000-06 145 3192.21 145 3192.21 DVD-R光盘，2000-07 124.25 2737.71 DVD-R光盘，2000-08 124.25 2737.71 DVD-R光盘，2000-09 1 18.91 1 18.91 DVD-R光盘，2000- 10 124.25 2737.71 DVD-R光盘，2000-11 124.25 2737.71 DVD-R光盘，2000-12 8 161.84 8 161.84</pre></div>
                     <!-- class="section" -->
                  </div>
               </div>
            </div><a id="DWHSG8741"></a><div class="props_rev_3"><a id="GUID-759F5F20-D45B-443F-9464-E71A4B70AF1B" name="GUID-759F5F20-D45B-443F-9464-E71A4B70AF1B"></a><h3 id="DWHSG-GUID-759F5F20-D45B-443F-9464-E71A4B70AF1B" class="sect3"><span class="enumeration_section">19.7</span>密集数据的时间序列计算</h3>
               <div>
                  <p>密度不仅仅用于报告目的。它还支持某些类型的计算，尤其是时间序列计算。当数据沿时间维度密集时，时间序列计算更容易。密集数据对于每个时间段具有一致的行数，这反过来使得使用具有物理偏移的分析窗函数变得简单。
                  </p>
                  <p>为了说明，我们首先以<span class="q">“ <a href="sql-analysis-reporting-data-warehouses.html#GUID-A0114A13-F31D-4B41-8069-AB85A72957FC">填补数据空白</a> ”</span>为例，让我们为该查询添加一个分析函数。在以下增强版中，您可以计算每周年度销售额和每周销售额。分区外连接在使时间序列密集时插入的<code class="codeph">NULL</code>值以通常的方式处理： <code class="codeph">SUM</code>函数将它们视为0。
                  </p><pre class="oac_no_warn" dir="ltr">SELECT Product_Name，t。年，t。周，NVL（销售，0）Current_sales，SUM（销售）OVER（PARTITION BY Product_Name，t.year ORDER BY t.week）Cumulative_sales FROM（SELECT SUBSTR（p。Prod_Name，1,15）Product_Name，t。Calendar_Year年，t。Calendar_Week_Number周，SUM（Amount_Sold）Sales FROM Sales s，Times t，Products t WHERE s。Time_id = t。Time_id和s。Prod_id = p。Prod_id和p。Prod_name IN（'Bounce'）和t。Calendar_Year IN（2000,2001）AND t。Calendar_Week_Number在20和30 GROUP之间。Prod_Name，t。Calendar_Year，t。Calendar_Week_Number）v PARTITION BY（v.Product_Name）RIGHT OUTER JOIN（SELECT DISTINCT Calendar_Week_Number Week，Calendar_Year Year FROM Times WHERE Calendar_Year in（2000,2001）AND Calendar_Week_Number BETWEEN 20 AND 30）t ON（v.week = t.week AND v 。年= t。年）订购年，t.week; PRODUCT_NAME一年一度CURRENT_SALES CUMULATIVE_SALES --------------- ---------- ---------- ---------- --- ---------------- Bounce 2000 20 801 801 Bounce 2000 21 4062.24 4863.24 Bounce 2000 22 2043.16 6906.4 Bounce 2000 23 2731.14 9637.54 Bounce 2000 24 4419.36 14056.9 Bounce 2000 25 0 14056.9 Bounce 2000 26 0 14056.9 Bounce 2000 27 2297.29 16354.19 Bounce 2000 28 1443.13 17797.32 Bounce 2000 29 1927.38 19724.7 Bounce 2000 30 1927.38 21652.08 Bounce 2001 20 1483.3 1483.3 Bounce 2001 21 4184.49 5667.79 Bounce 2001 22 2609.19 8276.98 Bounce 2001 23 1416.95 9693.93 Bounce 2001 24 3149.62 12843.55 Bounce 2001 25 2645.98 15489.53 Bounce 2001 26 0 15489.53 Bounce 2001 27 2125.12 17614.65 Bounce 2001 28 0 17614.65 Bounce 2001 29 2467.92 20082.57 Bounce 2001 30 2620.17 22702.74</pre><p>本节包含以下主题：</p>
                  <ul style="list-style-type:disc">
                     <li>
                        <p><a href="sql-analysis-reporting-data-warehouses.html#GUID-E32F35FA-1188-45EC-805D-3D934806911A">一个时间段的周期比较：示例</a></p>
                     </li>
                     <li>
                        <p><a href="sql-analysis-reporting-data-warehouses.html#GUID-69B7AAAA-3B15-464F-A177-3A1B5E9F6AEC">多个时间级别的周期比较：示例</a></p>
                     </li>
                     <li>
                        <p><a href="sql-analysis-reporting-data-warehouses.html#GUID-8BED5B1F-C20F-4215-B4A0-28DD1564CC3B">在维度中创建自定义成员：示例</a></p>
                     </li>
                  </ul>
               </div><a id="DWHSG8742"></a><div class="props_rev_3"><a id="GUID-E32F35FA-1188-45EC-805D-3D934806911A" name="GUID-E32F35FA-1188-45EC-805D-3D934806911A"></a><h4 id="DWHSG-GUID-E32F35FA-1188-45EC-805D-3D934806911A" class="sect4"><span class="enumeration_section">19.7.1</span>一个时间级别的周期比较：示例</h4>
                  <div>
                     <p>如何使用此功能比较各时间段的值？具体来说，您如何计算一周的销售额比较？以下查询在每一产品的同一行上返回2001年每周与2000年的年初至今销售额。</p>
                     <p>请注意，在此示例中，您将以<code class="codeph">WITH</code>子句开头。这提高了查询的可读性，让我们专注于分区外连接。如果在SQL * Plus中工作，则以下命令将包含列标题以提高结果的可读性：</p><pre class="oac_no_warn" dir="ltr">col Weekly_ytd_sales_prior_year标题'Weekly_ytd | _sales_ | prior_year'WITH v AS（SELECT SUBSTR（p。Prod_Name，1,6）Prod，t。Calendar_Year年，t。Calendar_Week_Number周，SUM（Amount_Sold）Sales FROM Sales s，Times t，Products t WHERE s。Time_id = t。Time_id和s。Prod_id = p。Prod_id和p。Prod_name in（'Y Box'）AND t。Calendar_Year in（2000,2001）AND t。Calendar_Week_Number BETWEEN 30和40 GROUP BY p。Prod_Name，t。Calendar_Year，t。Calendar_Week_Number）SELECT Prod，Year，Week，Sales，Weekly_ytd_sales，Weekly_ytd_sales_prior_year FROM（SELECT Prod，Year，Week，Sales，Weekly_ytd_sales，LAG（Weekly_ytd_sales，1）OVER（PAROTTION BY Prod，Week ORDER BY Year）Weekly_ytd_sales_prior_year FROM（SELECT v。 Prod Prod，t。年份，t。周周，NVL（v.Sales，0）销售，SUM（NVL（v.Sales，0））OVER（PARTITION BY v.Prod，t。年份订购时间t.week）weekly_ytd_sales FROM v PARTITION BY（v.Prod）RIGHT OUTER JOIN（SELECT DISTINCT Calendar_Week_Number Week，Calendar_Year Year FROM Times WHERE Calendar_Year IN（2000,2001））t ON（v.week = t.week AND v.Year = t。年））dense_sales）year_over_year_sales WHERE年= 2001年和周期间30和40年顺序为1,2,3; Weekly_ytd _sales_每年周期销售周年纪念日_YTD_SALES ------ ---------- ---------- ---------- ------ ---------- ---------- Y Box 2001 30 7877.45 7877.45 0 Y Box 2001 31 13082.46 20959.91 1537.35 Y Box 2001 32 11569.02 32528.93 9531.57 Y Box 2001 33 38081.97 70610.9 39048.69 Y Box 2001 34 33109.65 103720.55 69100.79 Y Box 2001 35 0 103720.55 71265.35 Y Box 2001 36 4169.3 107889.85 81156.29 Y Box 2001 37 24616.85 132506.7 95433.09 Y Box 2001 38 37739.65 170246.35 107726.96 Y Box 2001 39 284.95 170531.3 118817.4 Y Box 2001 40 10868.44 181399.74 120969.69</pre><p><code class="codeph">dense_sales</code>联视图<code class="codeph">dense_sales</code>的<code class="codeph">FROM</code>子句中，使用聚合视图<code class="codeph">v</code>和时间视图<code class="codeph">t</code>的分区外连接来沿时间维度填充销售数据中的间隙。然后，分析外连接的输出由分析函数<code class="codeph">SUM ...OVER</code>计算每周年初至今的销售额（ <code class="codeph">weekly_ytd_sales</code>列）。因此，视图<code class="codeph">dense_sales</code>计算<code class="codeph">dense_sales</code>的年初至今销售数据，包括聚合视图中缺少的那些数据。然后，内联视图<code class="codeph">year_over_year_sales</code>使用<code class="codeph">LAG</code>函数计算一年前的每周年度销售额。标记为<code class="codeph">weekly_ytd_sales_prior_year</code>的<code class="codeph">LAG</code>函数指定<code class="codeph">PARTITION</code> <code class="codeph">BY</code>子句，该子句将2000年和2001年的同一周的行配对到单个分区中。然后，您将偏移量1传递给<code class="codeph">LAG</code>函数，以获得上一年度的每周年度销售额。最外面的查询块从<code class="codeph">year_over_year_sales</code>选择条件为<code class="codeph">yr = 2001</code> ，因此查询为每个产品返回其在2001年和2000年的指定周中的每周年初至今销售额。
                     </p>
                  </div>
               </div><a id="DWHSG8743"></a><div class="props_rev_3"><a id="GUID-69B7AAAA-3B15-464F-A177-3A1B5E9F6AEC" name="GUID-69B7AAAA-3B15-464F-A177-3A1B5E9F6AEC"></a><h4 id="DWHSG-GUID-69B7AAAA-3B15-464F-A177-3A1B5E9F6AEC" class="sect4"><span class="enumeration_section">19.7.2</span>多个时间段的周期比较：示例</h4>
                  <div>
                     <p>虽然前面的示例向我们展示了为单个时间级别创建比较的方法，但在单个查询中处理多个时间级别会更有用。例如，您可以比较年度，季度，月份和日期级别的销售额与上一期间的比较。如何创建一个查询，对我们时间层次的所有级别的年初至今销售进行逐年比较？</p>
                     <p>您将执行几个步骤来执行此任务。目标是在日，周，月，季度和年级进行比较的单个查询。步骤如下：</p>
                     <ol>
                        <li>
                           <p>创建一个名为<code class="codeph">cube_prod_time</code>的视图，该视图包含跨<code class="codeph">times</code>和<code class="codeph">products</code>聚合的分层销售多维数据集。
                           </p>
                           <p>请参阅<span class="q">“ <a href="sql-analysis-reporting-data-warehouses.html#GUID-69B7AAAA-3B15-464F-A177-3A1B5E9F6AEC__CHDHGDJC">创建分层多维数据集视图</a> ”</span> 。
                           </p>
                        </li>
                        <li>
                           <p>创建时间维度的视图以用作多维数据集的边缘。包含完整日期集的时间边缘将被分区外部连接到视图<code class="codeph">cube_prod_time</code>的稀疏数据。
                           </p>
                           <p>请参阅<span class="q">“ <a href="sql-analysis-reporting-data-warehouses.html#GUID-69B7AAAA-3B15-464F-A177-3A1B5E9F6AEC__CHDFDIGG">创建视图edge_time，它是一组完整的日期值</a> ”</span> 。
                           </p>
                        </li>
                        <li>
                           <p>最后，为了获得最佳性能，请创建一个物化视图<code class="codeph">mv_prod_time</code> ，使用与<code class="codeph">cube_prod_time</code>相同的定义<code class="codeph">cube_prod_time</code> 。
                           </p>
                           <p>请参阅<span class="q">“ <a href="sql-analysis-reporting-data-warehouses.html#GUID-69B7AAAA-3B15-464F-A177-3A1B5E9F6AEC__CHDEHJHE">创建物化视图mv_prod_time以支持更快的性能</a> ”</span> 。
                           </p>
                        </li>
                        <li>
                           <p>创建比较查询。</p>
                           <p>请参阅<span class="q">“ <a href="sql-analysis-reporting-data-warehouses.html#GUID-69B7AAAA-3B15-464F-A177-3A1B5E9F6AEC__CHDIAIEB">创建比较查询</a> ”</span> 。
                           </p>
                        </li>
                     </ol>
                     <p>有关分层多维数据集的更多信息，请参阅<a href="sql-aggregation-data-warehouses.html#GUID-E051A04E-0C53-491D-9B16-B71BA00B80C2">数据仓库中的聚合SQL</a> 。物化视图在以下部分中定义。
                     </p>
                     <div class="section" id="GUID-69B7AAAA-3B15-464F-A177-3A1B5E9F6AEC__CHDHGDJC">
                        <p class="subhead3" id="GUID-69B7AAAA-3B15-464F-A177-3A1B5E9F6AEC__GUID-CBEA09EE-92DD-467F-BAD2-24703F456D9C">创建分层多维数据集视图</p>
                        <p>您的系统中可能已存在以下所示的物化视图;如果没有，立即创建它。如果您必须生成它，请注意您将查询限制为仅两个产品以缩短处理时间：</p><pre class="oac_no_warn" dir="ltr">创建或替换视图cube_prod_time AS SELECT（CASE WHEN（（GROUPING（calendar_year）= 0）AND（GROUPING（calendar_quarter_desc）= 1））那么（TO_CHAR（calendar_year）||'_ 0'）WHEN（（GROUPING（calendar_quarter_desc）= 0 ）AND（GROUPING（calendar_month_desc）= 1））那么（TO_CHAR（calendar_quarter_desc）||'_ 1'）WHEN（（GROUPING（calendar_month_desc）= 0）AND（GROUPING（t.time_id）= 1））那么（TO_CHAR（calendar_month_desc） ）||'_2'）ELSE（TO_CHAR（t.time_id）||'_ 3'）END）Hierarchical_Time，calendar_year year，calendar_quarter_desc quarter，calendar_month_desc month，t.time_id day，prod_category cat，prod_subcategory subcat，p.prod_id prod， GROUPING_ID（prod_category，prod_subcategory，p.prod_id，calendar_year，calendar_quarter_desc，calendar_month_desc，t.time_id）gid，GROUPING_ID（prod_category，prod_subcategory，p.prod_id）gid_p，GROUPING_ID（calendar_year，calendar_quarter_desc，calendar_month_desc，t.time_id）gid_t，SUM（ amount_sold）s_sold，COUNT（amount_sold）c_sold，COUNT（*）cnt来自SALES s，TIMES t，PRODUC TS p WHERE s.time_id = t.time_id AND p.prod_name IN（'Bounce'，'Y Box'）AND s.prod_id = p.prod_id GROUP BY ROLLUP（calendar_year，calendar_quarter_desc，calendar_month_desc，t.time_id），ROLLUP（ prod_category，prod_subcategory，p.prod_id）;</pre><p>由于此视图仅限于两个产品，因此它只返回超过2200行。请注意，列<code class="codeph">Hierarchical_Time</code>包含来自时间层次结构的所有级别的时间的字符串表示。用于<code class="codeph">Hierarchical_Time</code>列的<code class="codeph">CASE</code>表达式将标记（_0，_1，...）附加到每个日期字符串以表示值的时间级别。_0表示年级，_1表示季度，_2表示月份，_3表示日期。请注意， <code class="codeph">GROUP</code> <code class="codeph">BY</code>子句是一个连接的<code class="codeph">ROLLUP</code> ，它指定时间和产品维度的汇总层次结构。<code class="codeph">GROUP</code> <code class="codeph">BY</code>子句决定了分层多维数据集内容。
                        </p>
                     </div>
                     <!-- class="section" -->
                     <div class="section" id="GUID-69B7AAAA-3B15-464F-A177-3A1B5E9F6AEC__CHDFDIGG">
                        <p class="subhead3" id="GUID-69B7AAAA-3B15-464F-A177-3A1B5E9F6AEC__GUID-AF76D556-2DCE-4AAA-808F-AD9F8E322F6F">创建View edge_time，它是一组完整的日期值</p>
                        <p><code class="codeph">edge_time</code>是使用分区外连接填充分层多维数据集中的时间间隔的源。列<code class="codeph">Hierarchical_Time</code>在<code class="codeph">edge_time</code>将在分配与所述加入可以使用<code class="codeph">Hierarchical_Time</code>在视图列<code class="codeph">cube_prod_time</code> 。以下语句定义<code class="codeph">edge_time</code> ：</p><pre class="oac_no_warn" dir="ltr">创建或替换视图edge_time AS SELECT（CASE WHEN（（GROUPING（calendar_year）= 0）AND（GROUPING（calendar_quarter_desc）= 1））THEN（TO_CHAR（calendar_year）||'_ 0'）WHEN（（GROUPING（calendar_quarter_desc）= 0 ）AND（GROUPING（calendar_month_desc）= 1））然后（TO_CHAR（calendar_quarter_desc）||'_ 1'）WHEN（（GROUPING（calendar_month_desc）= 0）AND（GROUPING（time_id）= 1））THEN（TO_CHAR（calendar_month_desc）| |'_2'）ELSE（TO_CHAR（time_id）||'_ 3'）END）Hierarchical_Time，calendar_year yr，calendar_quarter_number qtr_num，calendar_quarter_desc qtr，calendar_month_number mon_num，calendar_month_desc mon，time_id  -  TRUNC（time_id，'YEAR'）+ 1 day_num， time_id日，GROUPING_ID（calendar_year，calendar_quarter_desc，calendar_month_desc，time_id）gid_t FROM TIMES GROUP BY ROLLUP（calendar_year，（calendar_quarter_desc，calendar_quarter_number），（calendar_month_desc，calendar_month_number），time_id）;</pre></div>
                     <!-- class="section" -->
                     <div class="section" id="GUID-69B7AAAA-3B15-464F-A177-3A1B5E9F6AEC__CHDEHJHE">
                        <p class="subhead3" id="GUID-69B7AAAA-3B15-464F-A177-3A1B5E9F6AEC__GUID-263611D5-6F53-4D83-AA6E-D7903366BB11">创建物化视图mv_prod_time以支持更快的性能</p>
                        <p>物化视图定义与<code class="codeph">cube_prod_time</code>定义的视图<code class="codeph">cube_prod_time</code>重复。因为它是重复查询， <code class="codeph">cube_prod_time</code>将重写对<code class="codeph">cube_prod_time</code>引用以使用<code class="codeph">mv_prod_time</code>化视图。您的系统中可能已存在以下物化;如果没有，立即创建它。如果必须生成它，请注意您将查询限制为仅两个产品以缩短处理时间。
                        </p><pre class="oac_no_warn" dir="ltr">创建物化视图mv_prod_time REFRESH完成按需选择（案例时（（GROUPING（calendar_year）= 0）AND（GROUPING（calendar_quarter_desc）= 1））那么（TO_CHAR（calendar_year）||'_ 0'）WHEN（（GROUPING（calendar_quarter_desc） ）= 0）AND（GROUPING（calendar_month_desc）= 1））那么（TO_CHAR（calendar_quarter_desc）||'_ 1'）WHEN（（GROUPING（calendar_month_desc）= 0）AND（GROUPING（t.time_id）= 1））那么（ TO_CHAR（calendar_month_desc）||'_ 2'）ELSE（TO_CHAR（t.time_id）||'_ 3'）END）Hierarchical_Time，calendar_year year，calendar_quarter_desc quarter，calendar_month_desc month，t.time_id day，prod_category cat，prod_subcategory subcat，p。 prod_id prod，GROUPING_ID（prod_category，prod_subcategory，p.prod_id，calendar_year，calendar_quarter_desc，calendar_month_desc，t.time_id）gid，GROUPING_ID（prod_category，prod_subcategory，p.prod_id）gid_p，GROUPING_ID（calendar_year，calendar_quarter_desc，calendar_month_desc，t.time_id）gid_t ，SUM（amount_sold）s_sold，COUNT（amount_sold）c_sold，COUNT（*）cnt FR OM SALES s，TIMES t，PRODUCTS p WHERE.time_id = t.time_id AND p.prod_name IN（'Bounce'，'Y Box'）AND s.prod_id = p.prod_id GROUP BY ROLLUP（calendar_year，calendar_quarter_desc，calendar_month_desc， t.time_id），ROLLUP（prod_category，prod_subcategory，p.prod_id）;</pre></div>
                     <!-- class="section" -->
                     <div class="section" id="GUID-69B7AAAA-3B15-464F-A177-3A1B5E9F6AEC__CHDIAIEB">
                        <p class="subhead3" id="GUID-69B7AAAA-3B15-464F-A177-3A1B5E9F6AEC__GUID-DB8AE6A9-3421-4C4A-BEF6-5F84ACA42484">创建比较查询</p>
                        <p>您现在已经为我们的比较查询设置了阶段。您可以在所有时间级别获得期间比较计算。它需要将分析函数应用于沿时间维度具有密集数据的分层多维数据集。</p>
                        <p>您可以为每个时间级别实现的一些计算是：</p>
                        <ul style="list-style-type:disc">
                           <li>
                              <p>各级时间段的前期销售额。</p>
                           </li>
                           <li>
                              <p>上期销售额的差异。</p>
                           </li>
                           <li>
                              <p>各个时期一年前同期的销售总额。</p>
                           </li>
                           <li>
                              <p>去年同期销售额出现差异。</p>
                           </li>
                        </ul>
                        <p>以下示例执行所有这四个计算。它使用视图<code class="codeph">cube_prod_time</code>和<code class="codeph">edge_time</code>的分区外连接来创建称为<code class="codeph">dense_cube_prod_time</code>的密集数据的内联视图。然后，查询以与前一个单级示例相同的方式使用<code class="codeph">LAG</code>函数。外部<code class="codeph">WHERE</code>子句指定三个级别的时间：2001年8月，整个月和整个2001年第三季度。请注意，结果的最后两行包含月份级别和季度级别聚合。请注意，要在使用SQL * Plus时更容易阅读结果，应使用以下命令调整列标题。命令将折叠列标题以减少行长度：</p><pre class="oac_no_warn" dir="ltr">col sales_prior_period标题'sales_prior | _period'col variance_prior_period标题'方差| _prior | _period'col sales_same_period_prior_year标题'sales_same | _period_prior | _year'col variance_same_period_p_year标题'方差| _same_period | _prior_year'</pre><p>以下是将当前销售额与之前和之前的销售额进行比较的查询：</p><pre class="oac_no_warn" dir="ltr">SELECT SUBSTR（prod，1,4）prod，SUBSTR（Hierarchical_Time，1,12）ht，sales，sales_prior_period，sales  -  sales_prior_period variance_prior_period，sales_same_period_prior_year，sales  -  sales_same_period_prior_year variance_same_period_p_year FROM（SELECT cat，subcat，prod，gid_p，gid_t，Hierarchical_Time ，yr，qtr，mon，day，sales，LAG（sales，1）OVER（由gid_p，cat，subcat，prod，gid_t ORDER BY yr，qtr，mon，day分区）sales_prior_period，LAG（sales，1）OVER（ PARTITION by gid_p，cat，subcat，prod，gid_t，qtr_num，mon_num，day_num ORDER BY yr）sales_same_period_prior_year FROM（SELECT c.gid，c.cat，c.subcat，c.prod，c.gid_p，t.gid_t，t .yr，t.qtr，t.qtr_num，t.mon，t.mon_num，t.day，t.day_num，t。Hierarchical_Time，NVL（s_sold，0）sales FROM cube_prod_time c PARTITION BY（gid_p，cat，subcat，prod）RIGHT OUTER JOIN edge_time t ON（c.gid_t = t.gid_t AND c。Hierarchical_Time = t。Hierarchical_Time））dense_cube_prod_time） - 并排当前和上年销售额WHERE prod IN（139）和gid_p = 0 AND --1产品和产品水平数据（（mon IN（'2001-08'）AND gid_t IN（0 ，1））OR  - 日和月数据（qtr IN（'2001-03'）和gid_t IN（3））） - 四分之一级数据ORDER BY日; variance sales_same variance sales_prior _prior _period_prior _same_period PROD HT SALES _period _period _year _prior_year ---- ------------ ---------- ---------- -  ---------- ------------- ------------ 139 01-AUG-01_3 0 0 0 0 0 139 02- AUG-01_3 1347.53 0 1347.53 0 1347.53 139 03-AUG-01_3 0 1347.53 -1347.53 42.36 -42.36 139 04-AUG-01_3 57.83 0 57.83 995.75 -937.92 139 05-AUG-01_3 0 57.83 -57.83 0 0 139 06-AUG- 01_3 0 0 0 0 0 139 07-AUG-01_3 134.81 0 134.81 880.27 -745.46 139 08-AUG-01_3 1289.89 134.81 1155.08 0 1289.89 139 09-AUG-01_3 0 1289.89 -1289.89 0 0 139 10-AUG-01_3 0 0 0 0 0 139 11-AUG-01_3 0 0 0 0 0 139 12-AUG-01_3 0 0 0 0 0 139 13-AUG-01_3 0 0 0 0 0 139 14-AUG-01_3 0 0 0 0 0 139 15-AUG -01_3 38.49 0 38.49 1104.55 -1066.06 139 16-AUG-01_3 0 38.49 -38.49 0 0 139 17-AUG-01_3 77.17 0 77.17 1052.03 -974.86 139 18-AUG-01_3 2467.54 77.17 2390.37 0 2467.54 139 19-AUG-01_3 0 2467.54 -2467.54 127.08 -127.08 139 20-AUG-01_3 0 0 0 0 0 139 21-AUG-01_3 0 0 0 0 0 139 22-AUG-01_3 0 0 0 0 0 139 2 3-AUG-01_3 1371.43 0 1371.43 0 1371.43 139 24-AUG-01_3 153.96 1371.43 -1217.47 2091.3 -1937.34 139 25-AUG-01_3 0 153.96 -153.96 0 0 139 26-AUG-01_3 0 0 0 0 0 139 27-AUG -01_3 1235.48 0 1235.48 0 1235.48 139 28-AUG-01_3 173.3 1235.48 -1062.18 2075.64 -1902.34 139 29-AUG-01_3 0 173.3 -173.3 0 0 139 30-AUG-01_3 0 0 0 0 0 139 31-AUG-01_3 0 0 0 0 0 139 2001-08_2 8347.43 7213.21 1134.22 8368.98 -21.55 139 2001-03_1 24356.8 28862.14 -4505.34 24168.99 187.81</pre><p>第一个<code class="codeph">LAG</code>函数（ <code class="codeph">sales_prior_period</code> ）对<code class="codeph">gid_p</code> ， <code class="codeph">cat</code> ， <code class="codeph">subcat</code> ， <code class="codeph">prod</code> ， <code class="codeph">gid_t</code>上的数据进行分区， <code class="codeph">subcat</code>所有时间维度列上的行进行<code class="codeph">subcat</code> 。它通过传递1的偏移量来获得前一时期的销售价值。第二个<code class="codeph">LAG</code>函数（ <code class="codeph">sales_same_period_prior_year</code> ）对其他列<code class="codeph">qtr_num</code> ， <code class="codeph">mon_num</code>和<code class="codeph">day_num</code>上的数据进行分区，并在<code class="codeph">yr</code>对其进行<code class="codeph">day_num</code> ，以便在偏移量为1的情况下，它可以计算同一时期的年前销售额。最外层的<code class="codeph">SELECT</code>子句计算方差。
                        </p>
                     </div>
                     <!-- class="section" -->
                  </div>
               </div><a id="DWHSG8744"></a><div class="props_rev_3"><a id="GUID-8BED5B1F-C20F-4215-B4A0-28DD1564CC3B" name="GUID-8BED5B1F-C20F-4215-B4A0-28DD1564CC3B"></a><h4 id="DWHSG-GUID-8BED5B1F-C20F-4215-B4A0-28DD1564CC3B" class="sect4"><span class="enumeration_section">19.7.3</span>在维度中创建自定义成员：示例</h4>
                  <div>
                     <div class="section">
                        <p>在许多分析SQL任务中，在维度中定义自定义成员很有帮助。例如，您可以为分析定义专门的时间段。您可以使用分区外部联接临时将成员添加到维度。请注意，新的SQL <code class="codeph">MODEL</code>子句适用于创建涉及维度中新成员的更复杂场景。有关此主题的更多信息，请参见<a href="sql-modeling-data-warehouses.html#GUID-538F78AA-9BF3-46F2-93D1-39A8739B3237">SQL for Modeling</a> 。
                        </p>
                        <p>作为任务的示例，如果要为<code class="codeph">time</code>维度定义新成员，该怎么办？您想在<code class="codeph">time</code>维度中创建月级别的第13个成员。第13个月定义为2001年每个季度第一个月每种产品的销售总和。
                        </p>
                        <p>该解决方案有两个步骤。请注意，您将使用前一示例中创建的视图和表来构建此解决方案。需要两个步骤。首先，创建一个视图，将新成员添加到适当的维度。视图使用<code class="codeph">UNION</code> <code class="codeph">ALL</code>操作添加新成员。要使用自定义成员进行查询，请使用<code class="codeph">CASE</code>表达式和分区外连接。
                        </p>
                        <p>我们使用以下视图创建<code class="codeph">time</code>维度的新成员：</p><pre class="oac_no_warn" dir="ltr">创建或替换视图time_c AS（SELECT * FROM edge_time UNION ALL SELECT'2001-13_2'，2001,5，'2001-05'，13，'2001-13'，null，null，8  -  &lt;gid_of_mon&gt; FROM DUAL ）;</pre><p>在此语句中，视图<code class="codeph">time_c</code>是通过执行<code class="codeph">edge_time</code>视图（在前面的示例中定义）和用户定义的第13个月的<code class="codeph">UNION</code> <code class="codeph">ALL</code>来定义的。选择<code class="codeph">gid_t</code>值为8以区分自定义成员和标准成员。<code class="codeph">UNION</code> <code class="codeph">ALL</code>通过从<code class="codeph">DUAL</code>表执行<code class="codeph">SELECT</code>来指定第13个月成员的属性。请注意，分组ID列<code class="codeph">gid_t</code>设置为8，季度编号设置为5。
                        </p>
                        <p>然后，第二步是使用查询的内联视图来执行<code class="codeph">cube_prod_time</code>与<code class="codeph">time_c</code>的分区外连接。此步骤在每个产品聚合级别创建第13个月的销售数据。在主查询中，分析函数<code class="codeph">SUM</code>与<code class="codeph">CASE</code>表达式一起用于计算第13个月，其定义为每个季度的第一个月的销售额的总和。
                        </p><pre class="oac_no_warn" dir="ltr">SELECT * FROM（SELECT SUBSTR（cat，1,12）cat，SUBSTR（subcat，1,12）subcat，prod，mon，mon_num，SUM（CASEN WHEN mon_num IN（1,4,7,10）THEN s_sold ELSE NULL END）OVER（由gid_p，prod，subcat，cat，yr划分）sales_month_13 FROM（SELECT c.gid，c.prod，c.subcat，c.cat，gid_p，t.gid_t，t.day，t.mon， t.mon_num，t.qtr，t.yr，NVL（s_sold，0）s_sold FROM cube_prod_time c PARTITION BY（gid_p，prod，subcat，cat）RIGHT OUTER JOIN time_c t ON（c.gid_t = t.gid_t AND c。Hierarchical_Time = t。Hierarchical_Time）））WHERE mon_num = 13; CAT SUBCAT PROD MON MON_NUM SALES_MONTH_13 ------------ ------------ ---------- --------- -------- --------------电子游戏机16 2001-13 13 762334.34电子Y盒游戏139 2001-13 13 75650.22电子游戏机2001-13 13 762334.34电子Y Box Games 2001-13 13 75650.22 Electronics 2001-13 13 837984.56 2001-13 13 837984.56</pre><p><code class="codeph">SUM</code>函数使用<code class="codeph">CASE</code>将数据限制在每年的第1,4,7和10个月。由于数据集很小，只有2个产品，结果的汇总值必然是较低级别聚合的重复。对于更实际的汇总值集，您可以在底层物化视图中包含来自游戏控制台和Y Box Games子类别的更多产品。
                        </p>
                     </div>
                     <!-- class="section" -->
                  </div>
               </div>
            </div><a id="DWHSG8745"></a><div class="props_rev_3"><a id="GUID-2F10D9C8-C6D6-47F2-9DDF-4146539655F3" name="GUID-2F10D9C8-C6D6-47F2-9DDF-4146539655F3"></a><h3 id="DWHSG-GUID-2F10D9C8-C6D6-47F2-9DDF-4146539655F3" class="sect3"><span class="enumeration_section">19.8</span>其他分析和报告功能</h3>
               <div>
                  <p>本节说明了以下其他分析功能：</p>
                  <ul style="list-style-type:disc">
                     <li>
                        <p><a href="sql-analysis-reporting-data-warehouses.html#GUID-91A27A23-A5E0-4CF7-8669-019146D22A4D">WIDTH_BUCKET功能</a></p>
                     </li>
                     <li>
                        <p><a href="sql-analysis-reporting-data-warehouses.html#GUID-5BCFC642-B308-40A4-A79E-9B336A07C97E">线性代数</a></p>
                     </li>
                     <li>
                        <p><a href="sql-analysis-reporting-data-warehouses.html#GUID-C3160877-BF50-41B2-8E8D-6643108EE866">案例表达</a></p>
                     </li>
                     <li>
                        <p><a href="sql-analysis-reporting-data-warehouses.html#GUID-7F0C0ABD-D7AF-4ABB-B740-3D0E89B4036D">SQL Analytics中的频繁项集</a></p>
                     </li>
                  </ul>
               </div><a id="DWHSG02010"></a><div class="props_rev_3"><a id="GUID-91A27A23-A5E0-4CF7-8669-019146D22A4D" name="GUID-91A27A23-A5E0-4CF7-8669-019146D22A4D"></a><h4 id="DWHSG-GUID-91A27A23-A5E0-4CF7-8669-019146D22A4D" class="sect4"><span class="enumeration_section">19.8.1</span> WIDTH_BUCKET功能</h4>
                  <div>
                     <div class="section">
                        <p>对于<a id="d65966e6465" class="indexterm-anchor"></a><a id="d65966e6467" class="indexterm-anchor"></a>在给定表达式中， <code class="codeph">WIDTH_BUCKET</code>函数返回存储桶编号，该编号在评估后将分配此表达式的结果。 <span class="q">“ <a href="sql-analysis-reporting-data-warehouses.html#GUID-E93DE771-5927-4265-9DE9-9B1A7AD8B523">WIDTH_BUCKET语法</a> ”</span>描述了<code class="codeph">WIDTH_BUCKET</code>语法。
                        </p>
                        <p>您可以使用此功能生成等宽直方图。等宽直方图将数据集划分为桶，其间隔大小（最高值到最低值）相等。每个存储桶保留的行数会有所不同。相关函数<code class="codeph">NTILE</code>创建了equiheight桶。
                        </p>
                        <p>只能为数字，日期或日期时间类型生成等宽直方图。所以前三个参数应该是所有数值表达式或所有日期表达式。不允许使用其他类型的表达式。如果第一个参数为<code class="codeph">NULL</code> ，则结果为<code class="codeph">NULL</code> 。如果第二个或第三个参数为<code class="codeph">NULL</code> ，则返回错误消息，因为<code class="codeph">NULL</code>值不能表示日期或数值维度中范围的任何终点（或任何点）。最后一个参数（桶数）应该是一个数值表达式，其值为正整数值; 0， <code class="codeph">NULL</code>或负值将导致错误。
                        </p>
                        <p>桶的编号从0到（ <code class="codeph">n</code> + 1）。Bucket 0保存的值小于最小值。Bucket（ <code class="codeph">n</code> + 1）保存大于或等于最大指定值的值的计数。
                        </p>
                     </div>
                     <!-- class="section" -->
                  </div><a id="DWHSG8747"></a><a id="DWHSG8748"></a><a id="DWHSG8746"></a><div class="props_rev_3"><a id="GUID-E93DE771-5927-4265-9DE9-9B1A7AD8B523" name="GUID-E93DE771-5927-4265-9DE9-9B1A7AD8B523"></a><h5 id="DWHSG-GUID-E93DE771-5927-4265-9DE9-9B1A7AD8B523" class="sect5"><span class="enumeration_section">19.8.1.1</span> WIDTH_BUCKET语法</h5>
                     <div>
                        <div class="section">
                           <p><code class="codeph">WIDTH_BUCKET</code>将四个表达式作为参数。第一个参数是等宽直方图所用的表达式。第二和第三参数是表示第一参数的可接受范围的端点的表达式。第四个参数表示桶的数量。
                           </p><pre class="oac_no_warn" dir="ltr">WIDTH_BUCKET（表达式，minval表达式，maxval表达式，num桶）</pre><p>请考虑来自表<code class="codeph">customers</code>的以下数据，其中显示了17位客户的信用额度。此数据在<a href="sql-analysis-reporting-data-warehouses.html#GUID-E93DE771-5927-4265-9DE9-9B1A7AD8B523__I1007460">例19-27中</a>显示的查询中收集。
                           </p><pre class="oac_no_warn" dir="ltr">CUST_ID CUST_CREDIT_LIMIT --------- ----------------- 10346 7000 35266 7000 41496 15000 35225 11000 3424 9000 28344 1500 31112 7000 8962 1500 15192 3000 21380 5000 36651 1500 30420 5000 8270 3000 17268 11000 14459 11000 13808 5000 32497 1500 100977 9000 102077 3000 103066 10000 101784 5000 100421 11000 102343 3000</pre><p>在表<code class="codeph">customers</code> ， <code class="codeph">cust_credit_limit</code>列包含介于1500和15000之间的值，您可以使用<code class="codeph">WIDTH_BUCKET (cust_credit_limit, 0, 20000, 4)</code>将值分配给四个等宽桶，编号为1到4。理想情况下，每个桶是实数行的闭合开放间隔，例如，桶号2被分配给5000.0000和9999.9999之间的分数...，有时表示为[5000,10000]，以指示5,000包含在区间中并且10,000不包括在内。为了适应[0,20,000]范围之外的值，将小于0的值分配给编号为0的指定下溢桶，将大于或等于20,000的值分配给编号为5的指定溢出桶（num桶）一般+ 1）。有关如何分配存储区的图形说明，请参<a href="sql-analysis-reporting-data-warehouses.html#GUID-E93DE771-5927-4265-9DE9-9B1A7AD8B523__I1007452">见图19-4</a> 。
                           </p>
                           <div class="figure" id="GUID-E93DE771-5927-4265-9DE9-9B1A7AD8B523__I1007452">
                              <p class="titleinfigure">图19-4铲斗分配</p><img src="img/dwhsg078.gif" alt="下面是图19-4的描述" title="下面是图19-4的描述" longdesc="img_text/dwhsg078.html"><br><a href="img_text/dwhsg078.html">“图19-4铲斗分配”的说明</a></div>
                           <!-- class="figure" -->
                           <p>可以以相反的顺序指定范围，例如， <code class="codeph">WIDTH_BUCKET</code> （ <code class="codeph">cust_credit_limit</code> ， <code class="codeph">20000</code> ， <code class="codeph">0</code> ， <code class="codeph">4</code> ）。当边界反转时，桶将是开闭的间隔。在这个例子中，斗式编号1是（ <code class="codeph">15000,20000</code> ]，斗，2是（ <code class="codeph">10000,15000</code> ]，和铲斗4号，是（ <code class="codeph">0</code> <code class="codeph">,5000</code> ]。溢出桶将编号为0（ <code class="codeph">20000</code> ，+ <code class="codeph">infinity</code> ），下溢桶将编号为5（ - <code class="codeph">infinity</code> ， <code class="codeph">0</code> ]。
                           </p>
                           <p>如果桶计数参数为0或负数，则会出错。</p>
                        </div>
                        <!-- class="section" -->
                        <div class="example" id="GUID-E93DE771-5927-4265-9DE9-9B1A7AD8B523__I1007460">
                           <p class="titleinexample">例19-27 WIDTH_BUCKET</p>
                           <p>对于以常规或相反顺序指定边界的两种情况，以下查询显示customers表中信用限额的存储桶编号。您使用0到20,000的范围。
                           </p><pre class="oac_no_warn" dir="ltr">SELECT cust_id，cust_credit_limit，WIDTH_BUCKET（cust_credit_limit，0,20000,4）AS WIDTH_BUCKET_UP，WIDTH_BUCKET（cust_credit_limit，20000,0,4）AS WIDTH_BUCKET_DOWN来自客户WHERE cust_city ='Marshal'; CUST_ID CUST_CREDIT_LIMIT WIDTH_BUCKET_UP WIDTH_BUCKET_DOWN ---------- ----------------- --------------- ---- ------------- 10346 7000 2 3 35266 7000 2 3 41496 15000 4 2 35225 11000 3 2 3424 9000 2 3 28344 1500 1 4 31112 7000 2 3 8962 1500 1 4 15192 3000 1 4 21380 5000 2 4 36651 1500 1 4 30420 5000 2 4 8270 3000 1 4 17268 11000 3 2 14459 11000 3 2 13808 5000 2 4 32497 1500 1 4 100977 9000 2 3 102077 3000 1 4 103066 10000 3 3 101784 5000 2 4 100421 11000 3 2 102343 3000 1 4</pre></div>
                        <!-- class="example" -->
                     </div>
                  </div>
               </div><a id="DWHSG8749"></a><a id="DWHSG02014"></a><div class="props_rev_3"><a id="GUID-5BCFC642-B308-40A4-A79E-9B336A07C97E" name="GUID-5BCFC642-B308-40A4-A79E-9B336A07C97E"></a><h4 id="DWHSG-GUID-5BCFC642-B308-40A4-A79E-9B336A07C97E" class="sect4"><span class="enumeration_section">19.8.2</span>线性代数</h4>
                  <div>
                     <p>线性代数是数学的一个分支，具有广泛的实际应用。许多领域都有可以使用线性代数表达的任务，以下是几个领域的一些例子：统计（多元线性回归和主成分分析），数据挖掘（聚类和分类），生物信息学（微阵列数据分析），运筹学（供应链和其他优化问题），计量经济学（消费者需求数据分析）和财务（资产配置问题）。线性代数的各种库可供任何人免费使用。Oracle的<code class="codeph">UTL_NLA</code>包公开了两个最流行和最强大的库BLAS和LAPACK的矩阵PL / SQL数据类型和包装PL / SQL子程序。</p>
                     <p>线性代数依赖于矩阵操作。过去在PL / SQL中执行矩阵操作需要基于PL / SQL的本机数据类型发明矩阵表示，然后从头开始编写矩阵操作例程。这需要大量的编程工作，并且所得到的实现的性能是有限的。如果开发人员选择将数据发送到外部包进行处理而不是创建自己的例程，那么来回传输数据可能非常耗时。使用<code class="codeph">UTL_NLA</code>包可以使数据保留在Oracle中，消除编程工作，并提供快速实现。
                     </p>
                     <div class="infoboxnotealso" id="GUID-5BCFC642-B308-40A4-A79E-9B336A07C97E__GUID-68F30956-1AC9-4DA4-B187-744DC1A99C32">
                        <p class="notep1">也可以看看：</p>
                        <p>有关使用<code class="codeph">UTL_NLA</code>包和线性代数的更多信息，请参阅<a href="../arpls/UTL_NLA.html#ARPLS224" target="_blank"><span class="italic">Oracle Database PL / SQL包和类型参考</span></a></p>
                     </div>
                     <div class="example" id="GUID-5BCFC642-B308-40A4-A79E-9B336A07C97E__GUID-F45C8C56-4CF1-4A28-AB28-2C5940AA8DDA">
                        <p class="titleinexample">例19-28线性代数</p>
                        <p>以下是Oracle线性代数支持如何用于业务分析的示例。它调用使用<code class="codeph">UTL_NLA</code>包构建的多元线性回归应用程序。多元回归应用程序在名为<code class="codeph">OLS_Regression</code>的对象中<code class="codeph">OLS_Regression</code> 。请注意，可以在<code class="codeph">$ORACLE_HOME/plsql/demo</code>找到OLS Regression对象的示例文件。
                        </p>
                        <p>考虑零售商分析其营销计划有效性的情景。它的每个商店都通过以下可能的程序分配其营销预算：媒体广告（ <code class="codeph">media</code> ），促销（ <code class="codeph">promo</code> ），折扣券（ <code class="codeph">disct</code> ）和直接邮寄（ <code class="codeph">dmail</code> ）。回归分析建立了一般商店在给定年份（ <code class="codeph">sales</code> ）的<code class="codeph">sales</code>与营销计划的四个组成部分的支出之间的线性关系。假设营销数据存储在下表中：</p><pre class="oac_no_warn" dir="ltr">sales_marketing_data（/ *商店信息* / store_no NUMBER，年份NUMBER，/ *销售收入（以美元计）* /销售额NUMBER，/ *销售额* / / *营销费用（以美元计）* /媒体号码，/ *媒体广告* /促销号码，/ *促销* / disct NUMBER，/ *折扣优惠券* / dmail NUMBER，/ *直接邮寄* /</pre><p>然后，您可以使用系数构建以下销售 - 营销线性模型：</p><pre class="oac_no_warn" dir="ltr">销售收入= a + b媒体建议+ c促销+ d折扣券+ e Direct Mailer</pre><p>此模型可以实现为以下视图，该视图引用OLS回归对象：</p><pre class="oac_no_warn" dir="ltr">创建或替换视图sales_marketing_model（年，ols）AS SELECT年份，OLS_Regression（/ * mean_y =&gt; * / AVG（销售额），/ * variance_y =&gt; * / var_pop（销售额），/ * MV均值向量=&gt; * / UTL_NLA_ARRAY_DBL （AVG（媒体），AVG（促销），AVG（disct），AVG（dmail）），/ * VCM方差协方差矩阵=&gt; * / UTL_NLA_ARRAY_DBL（var_pop（媒体），covar_pop（媒体，促销），covar_pop（媒体， disct），covar_pop（media，dmail），var_pop（promo），covar_pop（promo，disct），covar_pop（promo，dmail），var_pop（disct），covar_pop（disct，dmail），var_pop（dmail）），/ * CV covariance vector =&gt; * / UTL_NLA_ARRAY_DBL（covar_pop（sales，media），covar_pop（sales，promo），covar_pop（sales，disct），covar_pop（sales，dmail）））FROM sales_marketing_data GROUP BY year;</pre><p>使用此视图，营销计划经理可以执行分析，例如“这种销售营销模式对于2004年的数据是否合理？也就是说，多重相关是否大于某个可接受的值，比如0.9？“此类查询的SQL可能如下：</p><pre class="oac_no_warn" dir="ltr">SELECT model.ols.getCorrelation（1）AS“线性模型的适用性”FROM sales_marketing_model model WHERE year = 2004;</pre><p>您还可以解决诸如“2003年没有任何营销计划的商店的预期基线销售收入是多少？“或”2004年营销计划的哪个部分最有效？也就是说，一个美元的增加，哪个项目产生了最大的预期销售增长？“</p>
                     </div>
                     <!-- class="example" -->
                  </div>
               </div><a id="DWHSG8750"></a><a id="DWHSG8751"></a><a id="DWHSG02012"></a><div class="props_rev_3"><a id="GUID-C3160877-BF50-41B2-8E8D-6643108EE866" name="GUID-C3160877-BF50-41B2-8E8D-6643108EE866"></a><h4 id="DWHSG-GUID-C3160877-BF50-41B2-8E8D-6643108EE866" class="sect4"><span class="enumeration_section">19.8.3</span>案例表达</h4>
                  <div>
                     <div class="section">
                        <p><a id="d65966e6741" class="indexterm-anchor"></a> Oracle现在支持简单和搜索的<code class="codeph">CASE</code>语句。<code class="codeph">CASE</code>语句的目的与<code class="codeph">DECODE</code>语句类似，但它们提供了更大的灵活性和逻辑能力。它们比传统的<code class="codeph">DECODE</code>语句更容易阅读，并提供更好的性能。它们通常在将类别分类为年龄段（例如，20-29,30-39等）时使用。
                        </p>
                        <p>简单<code class="codeph">CASE</code>语句的语法是：</p><pre class="oac_no_warn" dir="ltr">CASE expr WHEN comparison_expr THEN return_expr [，WHEN comparison_expr THEN return_expr] ...[ELSE else_expr] END</pre><p>简单<code class="codeph">CASE</code>表达式测试<code class="codeph">expr</code>值是否等于<code class="codeph">comparison_expr</code> 。
                        </p>
                        <p>搜索的<code class="codeph">CASE</code>语句的语法是：</p><pre class="oac_no_warn" dir="ltr">条件何时返回return_expr [，WHEN条件那么return_expr] ......ELSE else_expr] END</pre><p>您可以在搜索的<code class="codeph">CASE</code>表达式中使用任何类型的条件，而不仅仅是相等性测试。</p>
                        <p>您只能指定65,535论点和每一个<code class="codeph">WHEN</code> ...<code class="codeph">THEN</code>对是两个参数。为避免超出此限制，可以嵌套<code class="codeph">CASE</code>表达式，以便<code class="codeph">return_expr</code>本身是<code class="codeph">CASE</code>表达式。
                        </p>
                        <div class="infoboxnotealso" id="GUID-C3160877-BF50-41B2-8E8D-6643108EE866__GUID-D93DA578-8726-4149-94EA-6B400089F7C0">
                           <p class="notep1">也可以看看：</p>
                           <p><span class="q">“ <a href="sql-analysis-reporting-data-warehouses.html#GUID-6FD860CC-5113-4D43-B3B7-B91B833AA51C">使用CASE语句创建直方图</a> ”</span>以获取有关使用<code class="codeph">CASE</code>创建直方图的信息</p>
                        </div>
                     </div>
                     <!-- class="section" -->
                     <div class="example" id="GUID-C3160877-BF50-41B2-8E8D-6643108EE866__GUID-B29C4700-0629-4862-BCE5-D83F7FC100FF">
                        <p class="titleinexample">例19-29案例</p>
                        <p>假设您想要找到公司所有员工的平均工资。如果员工的工资低于2000美元，您希望查询使用$ 2000。如果没有<code class="codeph">CASE</code>语句，您可以选择编写此查询，如下所示：</p><pre class="oac_no_warn" dir="ltr">SELECT AVG（foo（e.salary））FROM employees e;</pre><p>请注意，这是针对<code class="codeph">hr</code>示例模式运行的。在这里， <code class="codeph">foo</code>是一个函数，如果输入大于2000则返回其输入，否则返回2000。该查询具有性能影响，因为它需要为每一行调用一个函数。编写自定义函数也可以增加开发负载。
                        </p>
                        <p>在没有PL / SQL的数据库中使用<code class="codeph">CASE</code>表达式，可以将此查询重写为：</p><pre class="oac_no_warn" dir="ltr">SELECT AVG（案例，当e.salary&gt; 2000那么e.salary ELSE 2000结束）AS avg_sal_2k_floor FROM employees e;</pre><p>使用<code class="codeph">CASE</code>表达式可以避免开发自定义函数，也可以更快地执行。
                        </p>
                     </div>
                     <!-- class="example" -->
                     <div class="example" id="GUID-C3160877-BF50-41B2-8E8D-6643108EE866__GUID-2A4830C6-A96B-4043-A849-BBAE07F10F2E">
                        <p class="titleinexample">例19-30聚合独立子集的情况</p>
                        <p>在简单的<code class="codeph">GROUP</code> <code class="codeph">BY</code>不够用的<code class="codeph">CASE</code>在聚合函数内部使用<code class="codeph">CASE</code>是一种在多个数据子集上执行聚合的便捷方法。例如，前面的示例可能在其<code class="codeph">SELECT</code>列表中包含多个<code class="codeph">AVG</code>列，每个列都有自己的<code class="codeph">CASE</code>表达式。您可能有查询查找0-2000和2000-5000工资范围内所有员工的平均工资。它看起来像：</p><pre class="oac_no_warn" dir="ltr">选择AVG（例如当0和2000之间的时间，然后e.sal ELSE null END）avg2000，AVG（2001年之间的时间和5000年之后的情况，那么e.sal ELSE null END）avg5000 FROM emps e;</pre><p>虽然此查询将独立子集数据的聚合放入单独的列中，但通过将<code class="codeph">CASE</code>表达式添加到<code class="codeph">GROUP</code> <code class="codeph">BY</code>子句，可以将聚合显示为单个列的行。下一节将介绍使用<code class="codeph">CASE</code>创建直方图的两种方法的灵活性。</p>
                     </div>
                     <!-- class="example" -->
                  </div><a id="DWHSG8753"></a><a id="DWHSG8754"></a><a id="DWHSG8752"></a><div class="props_rev_3"><a id="GUID-6FD860CC-5113-4D43-B3B7-B91B833AA51C" name="GUID-6FD860CC-5113-4D43-B3B7-B91B833AA51C"></a><h5 id="DWHSG-GUID-6FD860CC-5113-4D43-B3B7-B91B833AA51C" class="sect5"><span class="enumeration_section">19.8.3.1</span>使用CASE语句创建直方图</h5>
                     <div>
                        <div class="section">
                           <p><a id="d65966e6907" class="indexterm-anchor"></a>当您想要获得具有用户定义的桶的直方图（桶的数量和每个桶的宽度）时，可以使用<code class="codeph">CASE</code>语句。以下是使用<code class="codeph">CASE</code>语句创建的直方图的两个示例。在第一个示例中，直方图总计显示在多个列中，并返回单个行。在第二个示例中，直方图显示为带有标签列和单个列的总计，并返回多行。
                           </p>
                        </div>
                        <!-- class="section" -->
                        <div class="example" id="GUID-6FD860CC-5113-4D43-B3B7-B91B833AA51C__GUID-7B021397-0A55-44AA-8028-DBA13EE68185">
                           <p class="titleinexample">实施例19-31直方图实施例1</p><pre class="oac_no_warn" dir="ltr">SELECT SUM（例如，当cust_credit_limit BETWEEN 0和3999，然后1 ELSE 0 END）作为“0-3999”，SUM（例如，当cust_credit_limit BETWEEN 4000和7999，那么1 ELSE 0 END）作为“4000-7999”，SUM（CASE WHEN cust_credit_limit介于8000和11999之间，然后1 ELSE 0 END）作为“8000-11999”，SUM（例如，当cust_credit_limit介于12000和16000之间，那么1 0结束时）作为“12000-16000”来自客户WHERE cust_city ='Marshal'; 0-3999 4000-7999 8000-11999 12000-16000 ---------- ---------- ---------- -------- --- 8 7 7 1</pre></div>
                        <!-- class="example" -->
                        <div class="example" id="GUID-6FD860CC-5113-4D43-B3B7-B91B833AA51C__GUID-980C277D-EE49-4759-B1F9-5F2F901ACF3A">
                           <p class="titleinexample">实施例19-32直方图实施例2</p><pre class="oac_no_warn" dir="ltr">SELECT（例如，当cust_credit_limit BETWEEN 0和3999那么'0  -  3999'当cust_credit_limit介于4000和7999之后'4000  -  7999'当cust_credit_limit介于8000和11999之间时'8000  -  11999'当cust_credit_limit介于12000和16000之间时那么'12000  -  16000 'END）作为BUCKET，COUNT（*）作为Count_in_Group FROM customers WHERE cust_city ='Marshal'GROUP BY（CASE WHEN cust_credit_limit BETWEEN 0 AND 3999 THEN'0  -  3999'When cust_credit_limit BETWEEN 4000 AND 7999 THEN'4000  -  7999'whit cust_credit_limit在8000和11999之间，然后'8000  -  11999'当cust_credit_limit介于12000和16000之间时，'12000  -  16000'结束）; BUCKET COUNT_IN_GROUP ------------- -------------- 0  -  3999 8 4000  -  7999 7 8000  -  11999 7 12000  -  16000 1</pre></div>
                        <!-- class="example" -->
                     </div>
                  </div>
               </div><a id="DWHSG8755"></a><div class="props_rev_3"><a id="GUID-7F0C0ABD-D7AF-4ABB-B740-3D0E89B4036D" name="GUID-7F0C0ABD-D7AF-4ABB-B740-3D0E89B4036D"></a><h4 id="DWHSG-GUID-7F0C0ABD-D7AF-4ABB-B740-3D0E89B4036D" class="sect4"><span class="enumeration_section">19.8.4</span> SQL Analytics中的频繁项集</h4>
                  <div>
                     <div class="section">
                        <p>代替<a id="d65966e6951" class="indexterm-anchor"></a><a id="d65966e6953" class="indexterm-anchor"></a>计算特定事件发生的频率（例如，某人在杂货店购买牛奶的频率），您可能会发现计算多个事件一起发生的频率很有用（例如，有人一起购买牛奶和谷物的频率）在杂货店）。您可以使用所谓的频繁项集来计算这些多个事件，顾名思义，这是一组项。项目集的一些示例可以是给定客户在杂货店的单次旅行中购买的所有产品（通常称为市场购物篮），用户在单个会话中访问的网页，或者给定的金融服务。客户利用。
                        </p>
                        <p>使用频繁项目集的实际动机是找到最常出现的项目集。如果您分析一家杂货店的销售点数据，您可能会发现牛奶和香蕉是最常买的一对商品。因此，频繁项目集已经在商业智能环境中使用多年，其中最常见的项目集用于零售行业的市场购物篮分析。频繁的项目集计算与数据库集成，在关系表之上运行并通过SQL访问。此集成提供以下主要优势：</p>
                        <ul style="list-style-type:disc">
                           <li>
                              <p>之前依赖于频繁项目集操作的应用程序现在可以从显着改进的性能以及更简单的实现中受益。</p>
                           </li>
                           <li>
                              <p>以前不使用频繁项目集的基于SQL的应用程序现在可以轻松扩展以利用此功能。</p>
                           </li>
                        </ul>
                        <p>使用PL / SQL包<code class="codeph">DBMS_FREQUENT_ITEMSETS</code>执行频繁的项目集分析。有关更多信息，请参见<a href="../arpls/DBMS_FREQUENT_ITEMSET.html#ARPLS007" target="_blank"><span class="italic">Oracle Database PL / SQL包和类型参考</span></a> 。此外，在<span class="q">“ <a href="advanced-analytical-sql-data-warehouses.html#GUID-2741CAB6-DFFB-4079-AAE3-583F6B756434">商业智能查询示例4：频繁项目集</a> ”中</span>有一个频繁项目集使用的<span class="q"><a href="advanced-analytical-sql-data-warehouses.html#GUID-2741CAB6-DFFB-4079-AAE3-583F6B756434">示例</a></span> 。
                        </p>
                     </div>
                     <!-- class="section" -->
                  </div>
               </div>
            </div><a id="DWHSG9189"></a><a id="DWHSG9190"></a><a id="DWHSG9188"></a><div class="props_rev_3"><a id="GUID-3412F450-D7EB-4DC8-8888-60CABF592AD4" name="GUID-3412F450-D7EB-4DC8-8888-60CABF592AD4"></a><h3 id="DWHSG-GUID-3412F450-D7EB-4DC8-8888-60CABF592AD4" class="sect3"><span class="enumeration_section">19.9</span>限制SQL行</h3>
               <div>
                  <p>您可以通过特定行数或百分比限制从SQL查询返回的行<a id="d65966e7017" class="indexterm-anchor"></a><a id="d65966e7019" class="indexterm-anchor"></a><a id="d65966e7021" class="indexterm-anchor"></a>的行。在某些情况下，您可能需要在返回的行数受限之前订购查询结果。首先对其行进行排序然后限制返回的行数的查询通常称为Top-N查询，它提供了一种直接创建报告的方式，或者仅提供基本问题的简单视图，例如“谁是最高的十个 - 付薪员工？“它对于提供用于浏览的数据集的前几行的用户界面也很有用。发出前N个查询时，您可能还需要指定偏移量：偏移量不包括查询结果集的前导行。然后，查询返回从偏移后的第一行开始的指定行数或百分比。偏移使您能够修改典型问题，因此有关薪酬最高的员工的问题可能会跳过前十名员工，并且只返回薪资排名中第十一到第二十名的员工。以类似的方式，您可以按工资查询员工，跳过前十名员工，然后返回剩余员工的前10％。
                  </p>
                  <p>使用<code class="codeph">ROW_NUMBER</code>窗口函数， <code class="codeph">ROWNUM</code>伪列和其他技术可以在一段时间内限制返回行的查询，但现在可以使用ANSI SQL标准语法<span class="italic">row_limiting_clause</span>更简单地<span class="italic">编写</span> 。使用此子句时，您可以通过在查询中包含<code class="codeph">ORDER</code> <code class="codeph">BY</code>子句来确保Top-N查询所需的确定性排序顺序。在<code class="codeph">ORDER</code> <code class="codeph">BY</code>子句之后， <span class="italic"><code class="codeph">row_limiting_clause</code></span>子句显示为<code class="codeph">SELECT</code>的最后一部分，并以关键字<code class="codeph">FETCH</code>或<code class="codeph">OFFSET</code>开头。其基本语法如下：</p><pre class="oac_no_warn" dir="ltr">[OFFSET偏移量{ROW | ROWS}] [FETCH {FIRST | NEXT} [{rowcount | ％PERCENT}] {ROW | ROWS} {仅限|与TIES}]</pre><p>以下各节说明了此语法。</p>
                  <div class="section">
                     <p class="subhead2" id="GUID-3412F450-D7EB-4DC8-8888-60CABF592AD4__GUID-764CA70A-69D8-43BF-A253-B6CFDBA24ACB">OFFSET</p>
                  </div>
                  <!-- class="section" -->
                  <div class="section">
                     <p>这指定了行限制开始之前要跳过的行数。 <span class="italic"><code class="codeph">offset</code></span>必须是一个数字。如果指定负数，则将offset视为0。如果指定<code class="codeph">NULL</code>或大于或等于查询返回的行数，则返回0行。如果<span class="italic"><code class="codeph">offset</code></span>包括分数，则截断小数部分。如果未指定此子句，则<span class="italic"><code class="codeph">offset</code></span>为0，行限制从第一行开始。为了提高可读性，Oracle提供了使用<code class="codeph">ROW</code>或<code class="codeph">ROWS</code>的选项 - 两者都是等效的。
                     </p>
                  </div>
                  <!-- class="section" -->
                  <div class="section">
                     <p class="subhead2" id="GUID-3412F450-D7EB-4DC8-8888-60CABF592AD4__GUID-707CE8FB-474B-4D33-89E4-9B995BFDB59C">取</p>
                  </div>
                  <!-- class="section" -->
                  <div class="section">
                     <p>这指定要返回的行数或行百分比。如果未指定此子句，则从<span class="italic"><code class="codeph">offset</code></span> + 1行开始返回所有行。如果使用<code class="codeph">WITH</code> <code class="codeph">TIES</code>关键字，则查询还将包括与最后一个限定行的排序键匹配的所有行。
                     </p>
                     <p>为了说明如何限制查询中返回的行数，请考虑以下语句：</p><pre class="oac_no_warn" dir="ltr">SELECT employee_id，last_name FROM employees ORDER BY employee_id FETCH FIRST 5 ROWS ONLY; EMPLOYEE_ID LAST_NAME ----------- ---------- 100 King 101 Kochhar 102 De Haan 103 Hunold 104 Ernst</pre><p>在此语句中，将返回具有最低<code class="codeph">employee_id</code>值的前5个员工。
                     </p>
                     <p>要返回下一组5名员工，请在语句中添加<code class="codeph">OFFSET</code> ：</p><pre class="oac_no_warn" dir="ltr">SELECT employee_id，last_name FROM employees ORDER BY employee_id OFFSET 5 ROWS FETCH NEXT 5 ROWS ONLY; EMPLOYEE_ID LAST_NAME ----------- ---------- 105 Austin 106 Pataballa 107 Lorentz 108 Greenberg 109 Faviet</pre><p>在本声明中， <code class="codeph">FETCH</code> <code class="codeph">FIRST</code>和<code class="codeph">FETCH</code> <code class="codeph">NEXT</code>是等效的，但是当使用<code class="codeph">OFFSET</code>时， <code class="codeph">FETCH</code> <code class="codeph">NEXT</code>更清晰。
                     </p>
                     <p>偏移量可以是更大的值，例如10，如以下语句中所示：</p><pre class="oac_no_warn" dir="ltr">SELECT employee_id，last_name FROM employees ORDER BY employee_id OFFSET 10 ROWS FETCH NEXT 5 ROWS ONLY; EMPLOYEE_ID LAST_NAME ----------- ---------- 110陈111 Sciarra 112 Urman 113 Popp 114 Raphaely</pre><p>您可以选择按百分比而不是固定数字返回值。为了说明这一点，以下声明返回了工资最低的5％的员工：</p><pre class="oac_no_warn" dir="ltr">SELECT employee_id，last_name，salary FROM employees ORDER BY salary FETCH FIRST 5 PERCENT ROWS; EMPLOYEE_ID LAST_NAME SALARY ----------- --------------------- ------ 132 Olson 2100 128 Markle 2200 136 Philtanker 2200 127兰德里2400 135 Gee 2400 119 Colmenares 2500</pre><p>在此结果集中，5％是六行。如果使用<code class="codeph">OFFSET</code> ，这很重要，因为百分比计算基于应用偏移之前的整个结果集。使用<code class="codeph">OFFSET</code>一个示例如下：</p><pre class="oac_no_warn" dir="ltr">SELECT employee_id，last_name，salary FROM employees ORDER BY salary，employee_id OFFSET 6 ROWS FETCH FIRST 5％NOW; EMPLOYEE_ID LAST_NAME SALARY ----------- --------------------- ------ 131 Marlow 2500 140 Patel 2500 144 Vargas 2500 182 Sullivan 2500 191 Perkins 2500 118 Himuro 2500</pre><p>此语句仍返回六行，但从结果集的第七行开始。添加到<code class="codeph">ORDER</code> <code class="codeph">BY</code>子句的附加<code class="codeph">employee_id</code>是为了保证确定性排序。
                     </p>
                     <p>您可以选择使用<code class="codeph">WITH</code> <code class="codeph">TIES</code>返回tie值。这将返回工资最低的5％，以及与最后一行获取的工资相同的所有额外员工：</p><pre class="oac_no_warn" dir="ltr">SELECT employee_id，last_name，salary FROM employees ORDER BY salary FETCH FIRST 5％RASSS WITH TIES; EMPLOYEE_ID LAST_NAME SALARY ----------- --------------------- ------ 132 Olson 2100 128 Markle 2200 136 Philtanker 2200 127兰德里2400 135 Gee 2400 119 Colmenares 2500 131 Marlow 2500 140 Patel 2500 144 Vargas 2500 182 Sullivan 2500 191 Perkins 2500</pre><p>您可以发出相同的查询，但使用以下语句跳过前5个值：</p><pre class="oac_no_warn" dir="ltr">SELECT employee_id，last_name，salary FROM employees ORDER BY salary OFFSET 5 ROWS FETCH FIRST 5％with TIES; EMPLOYEE_ID LAST_NAME SALARY ----------- --------------------- ------ 119 Colmenares 2500 131 Marlow 2500 140 Patel 2500 144 Vargas 2500 182 Sullivan 2500 191 Perkins 2500</pre></div>
                  <!-- class="section" -->
               </div><a id="DWHSG9191"></a><div class="props_rev_3"><a id="GUID-27A245ED-676B-4FC1-827B-B58020E234AA" name="GUID-27A245ED-676B-4FC1-827B-B58020E234AA"></a><h4 id="DWHSG-GUID-27A245ED-676B-4FC1-827B-B58020E234AA" class="sect4"><span class="enumeration_section">19.9.1</span> SQL行限制限制和注意事项</h4>
                  <div>
                     <div class="section">
                        <p><span class="italic"><code class="codeph">row_limiting_clause</code></span>子句受以下限制：</p>
                        <ul style="list-style-type:disc">
                           <li>
                              <p>您不能使用<span class="italic"><code class="codeph">for_update_clause</code></span>指定此子句。
                              </p>
                           </li>
                           <li>
                              <p>如果指定此子句，则选择列表不能包含序列伪列<code class="codeph">CURRVAL</code>或<code class="codeph">NEXTVAL</code> 。</p>
                           </li>
                           <li>
                              <p>如果定义查询包含此子句，则物化视图不符合增量刷新的条件。</p>
                           </li>
                        </ul>
                        <div class="infoboxnotealso" id="GUID-27A245ED-676B-4FC1-827B-B58020E234AA__GUID-98BF1BE4-0869-4AE5-A7D3-B94AB01827DB">
                           <p class="notep1">也可以看看：</p>
                           <p>有关语法和限制的更多信息，请<a href="../sqlrf/SELECT.html#SQLRF55644" target="_blank"><span class="italic">参见Oracle数据库SQL语言参考</span></a></p>
                        </div>
                     </div>
                     <!-- class="section" -->
                  </div>
               </div>
            </div>
         </div>
      </article>
   </body>
</html>