<html lang="en-us" dir="ltr" xml:lang="en-us">
   <head>
      <meta http-equiv="Content-Type" content="text/html; charset=utf-8"></meta>
      <meta name="viewport" content="width=device-width, initial-scale=1"></meta>
      <meta http-equiv="X-UA-Compatible" content="IE=edge"></meta>
      <meta name="abstract" content="Application Continuity is a feature that enables the replay, in a non-disruptive and rapid manner, of a request against the database after a recoverable error that makes the database session unavailable so an outage appears to the user as no more than a delayed execution of the request."></meta>
      <meta name="description" content="Application Continuity is a feature that enables the replay, in a non-disruptive and rapid manner, of a request against the database after a recoverable error that makes the database session unavailable so an outage appears to the user as no more than a delayed execution of the request."></meta>
      <title>确保应用程序的连续性</title>
      <meta property="og:site_name" content="Oracle Help Center"></meta>
      <meta property="og:title" content="Real Application Clusters Administration and Deployment Guide"></meta>
      <meta property="og:description" content="Application Continuity is a feature that enables the replay, in a non-disruptive and rapid manner, of a request against the database after a recoverable error that makes the database session unavailable so an outage appears to the user as no more than a delayed execution of the request."></meta>
      <link rel="stylesheet" href="/sp_common/book-template/ohc-book-template/css/book.css"></link>
      <link rel="shortcut icon" href="/sp_common/book-template/ohc-common/img/favicon.ico"></link>
      <meta name="application-name" content="Real Application Clusters Administration and Deployment Guide"></meta>
      <meta name="generator" content="DITA Open Toolkit version 1.8.5 (Mode = doc)"></meta>
      <meta name="plugin" content="SP_docbuilder HTML plugin release 18.2.2"></meta>
      <link rel="alternate" href="real-application-clusters-administration-and-deployment-guide.pdf" title="PDF File" type="application/pdf"></link>
      <meta name="robots" content="all"></meta>
      <link rel="schema.dcterms" href="http://purl.org/dc/terms/"></link>
      <meta name="dcterms.created" content="2019-04-25T14:02:30-07:00"></meta>
      <meta name="dcterms.title" content="Real Application Clusters Administration and Deployment Guide"></meta>
      <meta name="dcterms.dateCopyrighted" content="1999, 2019"></meta>
      <meta name="dcterms.category" content="database"></meta>
      <meta name="dcterms.identifier" content="E95728-03"></meta>
      
      <meta name="dcterms.product" content="en/database/oracle/oracle-database/19"></meta>
      
      <link rel="prev" href="workload-management-with-dynamic-database-services.html" title="Previous" type="text/html"></link>
      <link rel="next" href="configuring-recovery-manager-and-archiving.html" title="Next" type="text/html"></link>
      <script>
        document.write('<style type="text/css">');
        document.write('body > .noscript, body > .noscript ~ * { visibility: hidden; }');
        document.write('</style>');
     </script>
      <script src="/sp_common/book-template/requirejs/require.js" data-main="/sp_common/book-template/ohc-book-template/js/book-config"></script>
      <script>
            if (window.require === undefined) {
                document.write('<script data-main="sp_common/book-template/ohc-book-template/js/book-config" src="sp_common/book-template/requirejs/require.js"><\/script>');
                document.write('<link href="sp_common/book-template/ohc-book-template/css/book.css" rel="stylesheet"/>');
            }
        </script>
      <script type="application/json" id="ssot-metadata">{"primary":{"category":{"short_name":"database","element_name":"Database","display_in_url":true},"suite":{"short_name":"oracle","element_name":"Oracle","display_in_url":true},"product_group":{"short_name":"not-applicable","element_name":"Not applicable","display_in_url":false},"product":{"short_name":"oracle-database","element_name":"Oracle Database","display_in_url":true},"release":{"short_name":"19","element_name":"Release 19","display_in_url":true}}}</script>
      
    <meta name="dcterms.isVersionOf" content="RACAD"></meta>
    <meta name="dcterms.release" content="Release 19"></meta>
  </head>
   <body dir="ltr">
      <div class="noscript alert alert-danger text-center" role="alert">
         <a href="workload-management-with-dynamic-database-services.html" class="pull-left"><span class="glyphicon glyphicon-chevron-left" aria-hidden="true"></span>上一页</a> <a href="configuring-recovery-manager-and-archiving.html" class="pull-right">下一页<span class="glyphicon glyphicon-chevron-right" aria-hidden="true"></span></a> <span class="fa fa-exclamation-triangle" aria-hidden="true"></span>必须启用JavaScript才能正确显示此内容</div>
      <article>
         <header>
            <ol class="breadcrumb" vocab="http://schema.org/" typeof="BreadcrumbList">
               <li property="itemListElement" typeof="ListItem"><a href="index.html" property="item" typeof="WebPage"><span property="name">Real Application Clusters管理和部署指南</span></a></li>
               <li class="active" property="itemListElement" typeof="ListItem">确保应用程序的连续性</li>
            </ol>
            <a id="GUID-C1EF6BDA-5F90-448F-A1E2-DC15AD5CFE75" name="GUID-C1EF6BDA-5F90-448F-A1E2-DC15AD5CFE75"></a>
            
            <h2 id="RACAD-GUID-C1EF6BDA-5F90-448F-A1E2-DC15AD5CFE75" class="sect2"><span class="enumeration_chapter">6</span>确保应用程序的连续性</h2>
         </header>
         <div class="ind">
            <div>
               <p><span class="bold">应用程序连续性</span>是一种功能，可以在数据库会话不可用的可恢复错误之后以无中断和快速的方式重放对数据库的请求，从而使用户看到中断只是延迟执行请求。</p>
               <p>该请求可以包含事务和非事务性工作。成功重播后，应用程序可以在数据库会话停止的地方继续，而不是让用户产生疑问，不知道他们的资金转移，航班预订等发生了什么，并避免重启中间层服务器的需要当应用程序重新联机时从日志过载中恢复。通过应用程序连续性，可以通过屏蔽计划内和计划外的许多中断来提高最终用户体验，而无需应用程序开发人员尝试恢复请求。</p>
               <p>如果没有应用程序连续性，应用程序几乎不可能以安全的方式屏蔽中断，原因包括：</p>
               <ul style="list-style-type:disc">
                  <li>
                     <p>客户端的状态保持在当前时间，输入的数据，返回的数据和缓存的变量。</p>
                  </li>
                  <li>
                     <p>如果已发出<code class="codeph">COMMIT</code> ，则如果客户端或应用程序未收到<code class="codeph">COMMIT</code>失败消息，则无法检索该消息。
                     </p>
                  </li>
                  <li>
                     <p>在某个时间点检查不确定的tansaction的状态并不能保证它以后不会<code class="codeph">COMMIT</code> 。
                     </p>
                  </li>
                  <li>
                     <p>应用程序需要操作的非事务性数据库会话状态将丢失。</p>
                  </li>
                  <li>
                     <p>如果请求可以继续，则数据库和数据库会话必须处于正确状态。</p>
                  </li>
               </ul>
               <p>但是，通过应用程序连续性，Oracle数据库，Oracle驱动程序和Oracle连接池都可以协作以安全可靠的方式屏蔽许多中断。</p>
               <p>应用程序连续性通过尝试屏蔽可以屏蔽的中断来提高开发人员的工作效率。但是，应用程序仍必须包含针对这些情况的错误处理：</p>
               <ul style="list-style-type:disc">
                  <li>
                     <p><span class="italic">不可恢复的</span>错误，例如无效的输入数据。（应用程序连续性仅适用于可恢复的错误。）
                     </p>
                  </li>
                  <li>
                     <p>当重放遇到限制时可恢复的错误，例如在应用程序中使用具体类，或者当重放无法将客户端可见状态恢复到客户端可能已做出决策的状态时。</p>
                  </li>
               </ul>
               <p>Application Continuity在Oracle Database 12 <span class="italic">c</span> Release 1（12.1.0.1）中引入，增强了使用Oracle数据库的系统和应用程序的容错能力。
               </p>
               <p></p>
               <p>本章假定您熟悉使用应用程序连续性的技术或产品环境的主要相关概念和技术，例如Oracle WebLogic Server，Oracle RAC或Oracle Active Data Guard（Oracle ADG）。</p>
               <p>本章包括以下主题：</p>
               <ul style="list-style-type:disc">
                  <li>
                     <p><a href="ensuring-application-continuity.html#GUID-EB0E1525-D3B3-469C-BE22-A569C76864A6" title="Oracle RAC高可用性框架监视数据库及其服务，并使用快速应用程序通知（FAN）发送事件通知。">快速申请通知</a></p>
                  </li>
                  <li>
                     <p><a href="ensuring-application-continuity.html#GUID-27F35F42-080C-49F2-976E-DB073ACCBFEB" title="您可以将服务分配给管理员管理的Oracle RAC数据库中的一个或多个实例，也可以分配给策略管理的数据库中的服务器池。">管理意外中断</a></p>
                  </li>
                  <li>
                     <p><a href="ensuring-application-continuity.html#GUID-11B75A54-CEF7-4113-A72F-9E7AAFE61953" title="对于需要您隔离一个或多个实例或节点的修复，升级和更改，Oracle RAC提供了重定位，禁用和启用服务的接口，以最大限度地减少对应用程序用户的服务中断。">管理计划维护</a></p>
                  </li>
                  <li>
                     <p><a href="ensuring-application-continuity.html#GUID-BD699AEB-9F85-42A8-8687-5A979918938D" title="应用程序连续性通过还原数据库会话从应用程序和用户屏蔽许多可恢复的数据库中断（当重放成功时）：完整会话，包括所有状态，游标，变量和最后一个事务（如果有）。">关于应用程序连续性</a></p>
                  </li>
                  <li>
                     <p><a href="ensuring-application-continuity.html#GUID-91427DA2-2C5F-46E9-93D4-B5FF6427A69B" title="本节介绍Application Continuity的工作原理，以及如何在应用程序中使用它。">应用程序连续性操作和使用</a></p>
                  </li>
                  <li>
                     <p><a href="ensuring-application-continuity.html#GUID-A250F3F8-D681-4F44-8969-7A8434E065DD" title="当您将FAILOVER_TYPE设置为TRANSACTION时使用应用程序连续性时，将重播留下副作用的语句。">应用连续性的潜在副作用</a></p>
                  </li>
                  <li>
                     <p><a href="ensuring-application-continuity.html#GUID-2400FAAD-0BB2-48AF-B1F6-358EBA724028" title="使用应用程序连续性时，请注意这些限制和注意事项。">应用程序连续性的限制和其他注意事项</a></p>
                  </li>
                  <li>
                     <p><a href="ensuring-application-continuity.html#GUID-097A5067-8CCF-4FF0-B97B-BF109DFA1841" title="Transaction Guard可防止应用程序连续性重播的事务被多次应用。">用于改善客户端故障转移的事务防护</a></p>
                  </li>
                  <li>
                     <p><a href="ensuring-application-continuity.html#GUID-DEF850F6-27E9-428E-B8FC-530230D78AD2" title="当Oracle Net Services建立与实例的连接时，连接将保持打开状态，直到客户端关闭连接，实例关闭或发生故障。">使用TAF故障转移OCI客户端</a></p>
                  </li>
               </ul>
            </div><a id="RACAD7128"></a><div class="sect2"><a id="GUID-EB0E1525-D3B3-469C-BE22-A569C76864A6" name="GUID-EB0E1525-D3B3-469C-BE22-A569C76864A6"></a><h3 id="RACAD-GUID-EB0E1525-D3B3-469C-BE22-A569C76864A6" class="sect3">快速申请通知</h3>
               <div>
                  <p>Oracle RAC高可用性框架监视数据库及其服务，并使用快速应用程序通知（FAN）发送事件通知。</p>
                  <p>Oracle数据库专注于维护尽可能高的服务可用性。在Oracle RAC中，服务旨在通过一个或多个实例共享的负载持续可用。Oracle RAC高可用性框架通过使用Oracle Clusterware和资源配置文件来维护服务可用性。Oracle Clusterware根据业务规则和服务属性恢复和平衡服务。</p>
                  <p>本节包括以下主题：</p>
                  <ul style="list-style-type:disc">
                     <li>
                        <p><a href="ensuring-application-continuity.html#GUID-AC79F7FE-2446-4178-A699-3859FFA5651A" title="FAN在与数据库，节点和网络相关的中断后立即中断客户端。">快速应用程序通知概述</a></p>
                     </li>
                     <li>
                        <p><a href="ensuring-application-continuity.html#GUID-8856EACC-DB95-4F15-ABED-B20234F0678D" title="本节将FAN事件中提供的信息描述为标注程序。">快速应用程序通知高可用性事件</a></p>
                     </li>
                     <li>
                        <p><a href="ensuring-application-continuity.html#GUID-807BA413-6348-482D-A53C-462F5BBAE5A8">订阅高可用性事件</a></p>
                     </li>
                     <li>
                        <p><a href="ensuring-application-continuity.html#GUID-2024CEF8-F984-4377-9182-E17F738A4715" title="FAN标注是Oracle RAC在发生高可用性事件时立即执行的服务器端可执行文件。">使用快速应用程序通知标注</a></p>
                     </li>
                  </ul>
               </div>
               <div>
                  <div class="relinfo">
                     <p><strong>相关话题</strong></p>
                     <ul>
                        <li><a href="workload-management-with-dynamic-database-services.html#GUID-074729CB-8A91-419C-A6E1-3B9E4FD8D869" title="FAN的总体目标是实现应用程序的端到端，无人值守恢复以及基于实际事务性能的负载平衡。为通用连接池和Oracle WebLogic Server启用快速连接故障转移（FCF）Active GridLink for Oracle RAC支持使用FAN HA和负载平衡咨询事件。您可以为通用连接池或隐式连接缓存启用FCF。运行时连接负载平衡需要使用Oracle JDBC驱动程序和Oracle RAC数据库。重播数据源（oracle.jdbc.replay。OracleDataSource）是Application Continuity对Java要求的JDBC瘦数据源。Transaction Guard为应用程序提供协议和通用工具，以便在计划内和计划外中断时最多执行一次。从Oracle Database 12c开始，OCI会话池使应用程序的多个线程能够使用动态管理的一组预先创建的数据库会话。OCI支持FAN消息和Transaction Guard。FAN旨在快速通知基于OCI的应用程序在节点，数据库，实例，服务和公共网络级别的中断。ODP.NET连接池可以订阅FAN HA通知，指示节点，服务和服务成员何时关闭。连接到Oracle Database 12c及更高版本时，ODP.NET使用Oracle Notification Service而不是Advanced Queuing。ODP.NET支持FAN消息和Transaction Guard。FAN旨在快速通知基于ODP.NET的应用程序在节点，数据库，实例，服务和公共网络级别的中断。">为Oracle RAC启用客户端</a></li>
                     </ul>
                  </div>
               </div><a id="RACAD8845"></a><a id="RACAD7301"></a><div class="sect3"><a id="GUID-AC79F7FE-2446-4178-A699-3859FFA5651A" name="GUID-AC79F7FE-2446-4178-A699-3859FFA5651A"></a><h4 id="RACAD-GUID-AC79F7FE-2446-4178-A699-3859FFA5651A" class="sect4">快速应用程序通知概述</h4>
                  <div>
                     <p>FAN在与数据库，节点和网络相关的中断后立即中断客户端。</p>
                     <p>FAN对于在故障后立即使客户端脱离TCP / IP超时至关重要。当资源可用时，FAN会立即通知客户端并启动数据库会话耗尽，以便客户在计划维护期间不会遇到中断。FAN还包括通知包括服务状态变化的配置和服务级别信息。</p>
                     <p>Oracle客户端驱动程序和Oracle连接池响应FAN事件并立即采取措施。FAN UP和DOWN事件适用于服务，数据库，实例，网络和节点。</p>
                     <div class="infoboxnote" id="GUID-AC79F7FE-2446-4178-A699-3859FFA5651A__GUID-9B09D33B-6974-4139-9741-E48A1FB79AD2">
                        <p class="notep1">注意：</p>从Oracle Database <span class="italic">10g第</span> 2版（10.2）开始支持FAN。
                     </div>
                     <p>例如，Oracle连接池使用FAN接收非常快速的故障通知，平衡故障后的连接，并在故障组件修复后再次平衡连接。因此，当实例上的服务启动时，连接池会立即使用FAN事件将工作路由到该资源。当实例或节点上的服务失败时，连接池将使用FAN事件立即中断要恢复的应用程序。FAN对于防止应用程序挂起TCP / IP超时至关重要。</p>
                     <div class="section">
                        <p class="subhead3" id="GUID-AC79F7FE-2446-4178-A699-3859FFA5651A__GUID-E99B7177-5293-4C63-BE35-B973CA88355B">风扇的重要性</p>
                        <p>应用程序可以通过许多关键方式浪费时间</p>
                        <ul id="GUID-AC79F7FE-2446-4178-A699-3859FFA5651A__UL_RH3_SCK_LHB" style="list-style-type:disc">
                           <li>
                              <p>当节点在没有关闭套接字的情况下发生故障时等待TCP / IP超时，并在该IP地址关闭时为每个后续连接等待。</p>
                           </li>
                           <li>
                              <p>服务中断时尝试连接。</p>
                           </li>
                           <li>
                              <p>服务恢复时不连接。</p>
                           </li>
                           <li>
                              <p>在服务器关闭时处理客户端的最后结果。</p>
                           </li>
                           <li>
                              <p>试图在次优节点上执行工作。</p>
                           </li>
                        </ul>
                        <p>当节点在没有关闭套接字的情况下发生故障时，在I / O等待（读取或写入）中阻塞的所有会话都会等待<code class="codeph">tcp_keepalive</code> 。此等待状态是通过套接字连接的应用程序的典型条件。处理最后结果的会话甚至更糟，在请求下一个数据之前没有接收到中断。使用FAN事件可以消除等待TCP超时的应用程序，在发生故障后处理客户端上的最后结果所浪费的时间，以及浪费在慢，挂或死节点上执行工作的时间。
                        </p>
                        <p>对于群集配置更改，Oracle RAC高可用性框架会在群集中发生状态更改时立即发布FAN事件。应用程序可以接收FAN事件并立即做出反应，而不是等待应用程序对数据库超时并检测问题。使用FAN，即时终止正在进行的事务，并在实例失败时通知客户端。</p>
                        <p>FAN还发布负载平衡咨询事件。应用程序可以利用负载平衡咨询FAN事件将工作请求定向到当前提供最佳服务质量的群集中的实例。</p>
                        <p>Oracle Database 12 <span class="italic">c</span>发行版2（12.2）客户端驱动程序具有FAN感知功能，默认情况下启用FAN。这包括JDBC Thin驱动程序（12.2.0.1）和Oracle Data Provider for Net（ODP.NET）驱动程序。客户端驱动程序可以检测计划内和计划外的FAN事件，并在应用程序下执行操作。
                        </p>
                        <p>对于使用OCI或Pro *（而不使用OCI会话池或Tuxedo）的计划维护和应用程序，应用程序必须检查<code class="codeph">OCI_ATTR_SERVER_STATUS</code> 。当会话返回到您自己的连接池时，添加此检查，并定期进行空闲连接。
                        </p>
                        <p>在计划维护的FAN down事件之后，此属性设置为<code class="codeph">OCI_SERVER_NOT_CONNECTED</code> 。应用程序在读取此断开状态后关闭连接。在应用程序关闭之前，会话将保持打开状态以排除活动工作，从而提供无错误的故障转移。
                        </p>
                        <p id="GUID-AC79F7FE-2446-4178-A699-3859FFA5651A__YOUCANTAKEADVANTAGEOFFANEVENTSINTHE-3EFD813C">您可以通过以下方式利用FAN事件：</p>
                        <ul id="GUID-AC79F7FE-2446-4178-A699-3859FFA5651A__UL_G2K_WCK_LHB" style="list-style-type:disc">
                           <li id="GUID-AC79F7FE-2446-4178-A699-3859FFA5651A__BABDFDFJ">
                              <p>如果使用集成的Oracle客户端，应用程序可以使用FAN而无需进行编程更改。FAN事件的集成客户端包括Oracle JDBC通用连接池，ODP.NET连接池，OCI会话池，Oracle RAC的Oracle WebLogic Server Active Gridlink以及OCI和ODP.NET客户端。集成的Oracle客户端必须是Oracle Database <span class="italic">10g第</span> 2版（10.2）或更高版本才能利用FAN高可用性事件。池化客户端还可以利用负载平衡咨询FAN事件。
                              </p>
                           </li>
                           <li>
                              <p>您可以配置第三方应用程序容器（例如Apache Tomcat和WebSphere提供的容器），以使用通用连接池代替默认池提供的内置FAN支持，默认池被认证为第三方连接池-party Java应用程序服务器，包括Apache Tomcat和WebSphere。</p>
                           </li>
                           <li>
                              <p>通过使用标准接口测试从第三方应用程序服务器或自定义应用程序使用的第三方连接池<span class="italic">获取</span>或<span class="italic">释放的</span>连接，使用Oracle驱动程序的FAN感知功能。
                              </p>
                              <ul id="GUID-AC79F7FE-2446-4178-A699-3859FFA5651A__UL_H2K_WCK_LHB" style="list-style-type:disc">
                                 <li>
                                    <p>此解决方案通过使用标准TNS连接字符串应用于标准Java应用程序，并确保应用程序CLASSPATH上的<code class="codeph">ons.jar</code>和<code class="codeph">simpleFAN.jar</code>文件可用。</p>
                                 </li>
                                 <li>
                                    <p>对于OCI / OCCI驱动程序， <code class="codeph">OCI_ATTR_SERVER_STATUS</code>服务器上下文句柄属性对FAN事件敏感，并且如果连接受FAN事件影响，则返回<code class="codeph">OCI_SERVER_NOT_CONNECTED</code> 。
                                    </p>
                                 </li>
                              </ul>
                           </li>
                           <li>
                              <p>您可以在数据库层上使用服务器端标注实现FAN。</p>
                           </li>
                           <li>
                              <p>应用程序可以通过使用JDBC和Oracle RAC FAN应用程序编程接口（API）以编程方式使用FAN，或者使用OCI和ODP.NET回调来订阅FAN事件并在收到事件时运行事件处理操作。</p>
                           </li>
                        </ul>
                        <p>如果您使用前面列表的第一项中列出的集成客户端之一，则对于DOWN事件，应用程序的中断将最小化，因为支持FAN的客户端在重用之前终止与故障实例或节点的连接。可以允许完成活动工作，并且如果存在幸存的实例，则可以维持持续服务以用于正在进行的工作。终止实例或服务停止时活动的任何会话，并立即通知应用程序用户。如果启用了应用程序连续性，则可以保护不完整的事务。请求连接的应用程序用户仅定向到可用实例。</p>
                        <p>对于<code class="codeph">UP</code>事件，当启动服务和实例时，会创建新连接，以便应用程序可以立即利用额外的硬件资源或额外容量。
                        </p>
                        <div class="p">要利用驱动程序中的FAN感知功能，如上一个清单所述，需要以下内容：<ul id="GUID-AC79F7FE-2446-4178-A699-3859FFA5651A__UL_I2K_WCK_LHB" style="list-style-type:disc">
                              <li>
                                 <p>对于瘦Java驱动程序，从版本12.2开始，通过将<code class="codeph">ons.jar</code>和<code class="codeph">simpleFAN.jar</code>文件放在CLASSPATH上，并使用推荐的TNS格式（如<a href="ensuring-application-continuity.html#GUID-2DD974C8-94C2-446B-B2BD-81B8135A26C3__AUTOMATICCONFIGURATIONOFFAN-309F5DDA">例6-1</a>所示）自动启用FAN。使用推荐的TNS格式自动配置ONS。此外，使用Java瘦驱动程序，计划和未计划事件都支持FAN。对于意外中断，FAN中断立即生效。对于计划维护，请使用标准接口配置Java应用程序服务器或自定义池，以测试从第三方连接池<span class="italic">获取</span>或<span class="italic">释放的</span>连接。例如， <code class="codeph">TestConnectionsOnReserve</code> ， <code class="codeph">TestOnBorrow</code> ，或<code class="codeph">PreTest</code>连接，这取决于应用程序服务器上。
                                 </p>
                                 <p>使用此方法，在计划维护期间收到FAN事件时，快速连接故障转移会在测试时关闭会话，因为此时应用程序没有与数据库的连接，并且可以重试新连接。连接测试可以使用<code class="codeph">isValid</code> ， <code class="codeph">isClosed</code> ， <code class="codeph">isUsable</code> ， <code class="codeph">PingDatabase</code>或前面带有提示<code class="codeph">/*+ CLIENT_CONNECTION_VALIDATION */</code>的SQL语句。
                                 </p>
                              </li>
                              <li>
                                 <p>对于SQL测试，SQL语法必须以提示<code class="codeph">/*+ CLIENT_CONNECTION_VALIDATION */</code>开头。在SQL命令运行时，如果受到即将进行的计划维护的影响，驱动程序将耗尽连接。连接池，数据源以及程序化案例中的客户应用程序都必须准备好管理SQL命令运行时发生的可恢复错误，这通常会关闭物理连接。
                                 </p>
                                 <div class="infoboxnote" id="GUID-AC79F7FE-2446-4178-A699-3859FFA5651A__GUID-F74B8AF1-8272-432E-9FFA-0A3E5CD3240A">
                                    <p class="notep1">注意：</p>
                                    <p>SQL提示必须作为SQL字符串中的第一个非注释标记放置，以避免更改当前基于驱动程序的SQL解析。例如：</p><pre class="pre codeblock"><code>/ * + CLIENT_CONNECTION_VALIDATION * / SELECT 1 FROM DUAL;</code></pre></div>
                              </li>
                              <li>
                                 <p>在开发连接池时，第三方Java应用程序服务器和Java应用程序可以使用<code class="codeph">PooledConnection</code>标准接口。
                                 </p>
                              </li>
                              <li>
                                 <p>从OCI / OCCI驱动程序的11.2.0.3版本开始，当<code class="codeph">OCI_ATTR_SERVER_STATUS</code>服务器上下文句柄属性返回<code class="codeph">OCI_SERVER_NOT_CONNECTED</code> ，应用程序必须终止连接。计划维护工作将耗尽。驱动程序的12.2版本在收到计划的DOWN事件时也可以检测到<code class="codeph">OCISessionRelease</code>和<code class="codeph">OCIRequestEnd</code> 。
                                 </p>
                              </li>
                           </ul>
                        </div>
                        <p>FAN标注是服务器端脚本或可执行文件，它们在生成FAN事件时运行。您可以设计和构建标注以执行许多操作。例如：</p>
                        <ul id="GUID-AC79F7FE-2446-4178-A699-3859FFA5651A__UL_J2K_WCK_LHB" style="list-style-type:disc">
                           <li>
                              <p>记录状态信息</p>
                           </li>
                           <li>
                              <p>页面DBA或在资源无法启动时打开支持服务单</p>
                           </li>
                           <li>
                              <p>自动启动必须与服务位于同一位置的相关外部应用程序</p>
                           </li>
                           <li>
                              <p>当策略管理数据库的可用实例数减少时（例如，节点失败），更改资源计划或关闭服务</p>
                           </li>
                           <li>
                              <p>如果需要，自动将服务故障恢复到管理员管理的数据库的首选实例</p>
                           </li>
                        </ul>
                        <p>FAN事件使用Oracle Notification Service和Advanced Queuing发布，后者继续向后兼容以前的Oracle Database版本。发布机制自动配置为Oracle RAC安装的一部分。如果使用瘦Java JDBC连接，则可以通过从数据库连接获取数据库服务器Oracle Notification Service配置，自动为Oracle Notification Service配置客户端。无需在客户端上配置Oracle Notification Service。</p>
                        <p>Oracle Net Services侦听器和全局数据服务（GDS）与FAN事件集成在一起，使侦听器和GDS能够立即取消注册失败实例提供的服务，并避免错误地向失败的实例发送连接请求。</p>
                        <p>如果为服务指定连接负载平衡目标<code class="codeph">CLB_GOAL_SHORT</code> ，则侦听器在侦听器平衡连接负载时使用负载平衡<code class="codeph">CLB_GOAL_SHORT</code> 。启用负载平衡顾问时，用于侦听器的度量标准更精细。
                        </p>
                     </div>
                     <!-- class="section" -->
                  </div>
                  <div>
                     <div class="relinfo">
                        <p><strong>相关话题</strong></p>
                        <ul>
                           <li><a href="ensuring-application-continuity.html#GUID-2DD974C8-94C2-446B-B2BD-81B8135A26C3" title="在计划维护之前，在数据库实例上排空或故障转移数据库会话，以便不中断应用程序工作。从Oracle Database 18c开始，数据库本身会耗尽会话。">服务器在计划维护之前排空</a></li>
                        </ul>
                     </div>
                  </div>
               </div><a id="RACAD8300"></a><a id="RACAD7687"></a><a id="RACAD7688"></a><a id="RACAD7132"></a><div class="sect3"><a id="GUID-8856EACC-DB95-4F15-ABED-B20234F0678D" name="GUID-8856EACC-DB95-4F15-ABED-B20234F0678D"></a><h4 id="RACAD-GUID-8856EACC-DB95-4F15-ABED-B20234F0678D" class="sect4">快速应用程序通知高可用性事件</h4>
                  <div>
                     <p>本节将FAN事件中提供的信息描述为标注程序。</p>
                     <p>示例后面列出了FAN事件类型， <a href="ensuring-application-continuity.html#GUID-8856EACC-DB95-4F15-ABED-B20234F0678D__BABJHGIA" title="事件有效负载参数和描述">表6-1</a>描述了事件参数的名称 - 值对。当您通过标注接收FAN信息时，事件类型始终是第一个条目，如以下示例所示：</p><pre class="pre codeblock"><code>SERVICEMEMBER VERSION = 1.0 service = test.company.com database = ractest instance = ractest11 host = ractest1_host0343_1 status = up reason = FAILURE timestamp = 2018-05-08 22:06:02 timezone = -07：00 db_domain = company.com</code></pre><p>请注意，前面的示例显示为一行。</p>
                     <p>FAN事件类型包括：</p>
                     <ul class="simple" style="list-style-type:none;padding-left:0">
                        <li><code class="codeph">数据库</code></li>
                        <li><code class="codeph">INSTANCE</code></li>
                        <li><code class="codeph">节点</code></li>
                        <li><code class="codeph">服务</code></li>
                        <li><code class="codeph">SERVICEMEMBER</code></li>
                        <li><code class="codeph">SERVICEMETRICS</code></li>
                     </ul>
                     <p><code class="codeph">DATABASE</code>和<code class="codeph">INSTANCE</code>类型将默认数据库服务列为<code class="codeph">DB_UNIQUE_NAME</code> 。</p>
                     <p>除<code class="codeph">NODE</code>事件之外的所有事件都包含<code class="codeph">db_domain</code>字段。
                     </p>
                     <p><code class="codeph">SERVICEMETRICS</code>类型的事件是负载平衡咨询事件。
                     </p>
                     <p><span class="bold">另请参阅：</span> <a href="workload-management-with-dynamic-database-services.html#GUID-0EF444E4-6EC3-46A9-AF14-307995FEA664__BABHJDGB" title="事件有效负载参数和描述">表5-1</a> ，了解有关负载平衡事件的更多信息</p>
                     <div class="tblformal" id="GUID-8856EACC-DB95-4F15-ABED-B20234F0678D__BABJHGIA">
                        <p class="titleintable">表6-1事件参数名称 - 值对和描述</p>
                        <table cellpadding="4" cellspacing="0" class="Formal" title="事件参数名称 - 值对和描述" width="100%" border="1" summary="Event payload parameters and descriptions" frame="hsides" rules="rows">
                           <thead>
                              <tr align="left" valign="top">
                                 <th align="left" valign="bottom" width="29%" id="d23610e1084">参数</th>
                                 <th align="left" valign="bottom" width="71%" id="d23610e1087">描述</th>
                              </tr>
                           </thead>
                           <tbody>
                              <tr align="left" valign="top">
                                 <td align="left" valign="top" width="29%" id="d23610e1092" headers="d23610e1084 "><code class="codeph">版</code></td>
                                 <td align="left" valign="top" width="71%" headers="d23610e1092 d23610e1087 ">
                                    <p>事件记录的版本。用于标识版本更改。</p>
                                 </td>
                              </tr>
                              <tr align="left" valign="top">
                                 <td align="left" valign="top" width="29%" id="d23610e1099" headers="d23610e1084 "><code class="codeph">数据库</code></td>
                                 <td align="left" valign="top" width="71%" headers="d23610e1099 d23610e1087 ">
                                    <p>支持服务的数据库的唯一名称;匹配<code class="codeph">DB_UNIQUE_NAME</code>的初始化参数值，默认值为<code class="codeph">DB_NAME</code>初始化参数的值。
                                    </p>
                                 </td>
                              </tr>
                              <tr align="left" valign="top">
                                 <td align="left" valign="top" width="29%" id="d23610e1112" headers="d23610e1084 "><code class="codeph">例</code></td>
                                 <td align="left" valign="top" width="71%" headers="d23610e1112 d23610e1087 ">
                                    <p>支持该服务的实例的名称;匹配<code class="codeph">ORACLE_SID</code>值。
                                    </p>
                                 </td>
                              </tr>
                              <tr align="left" valign="top">
                                 <td align="left" valign="top" width="29%" id="d23610e1122" headers="d23610e1084 "><code class="codeph">主办</code></td>
                                 <td align="left" valign="top" width="71%" headers="d23610e1122 d23610e1087 ">
                                    <p>支持服务的节点的名称或已停止的节点;匹配群集同步服务（CSS）已知的节点名称。</p>
                                 </td>
                              </tr>
                              <tr align="left" valign="top">
                                 <td align="left" valign="top" width="29%" id="d23610e1129" headers="d23610e1084 "><code class="codeph">服务</code></td>
                                 <td align="left" valign="top" width="71%" headers="d23610e1129 d23610e1087 ">
                                    <p>服务名称;匹配<code class="codeph">DBA_SERVICES</code>列出的服务名称，并根据需要进行域限定。请参阅以下示例：</p><pre class="pre codeblock"><code>SERVICEMEMBER VERSION = 1.0 service = swingbench database = orcl instance = orcl_2 host = rwsbj13 status = up reason = USER card = 1 timestamp = 2018-05-29 17:26:37 timezone = -07：00 db_domain = SERVICEMEMBER VERSION = 1.0 service = swingbench.example.com database = orcl instance = orcl1 host = rwsbj09 status = up reason = USER card = 2 timestamp = 2018-05-03 17:29:28 timezone = -07：00 db_domain = example.com SERVICEMEMBER VERSION = 1.0 service = swingbench.example.com database = orcl instance = orcl2 host = rwsbj10 status = up reason = USER card = 1 timestamp = 2018-07-03 17:29:18 timezone = -07：00 db_domain = example.com</code></pre></td>
                              </tr>
                              <tr align="left" valign="top">
                                 <td align="left" valign="top" width="29%" id="d23610e1141" headers="d23610e1084 "><code class="codeph">状态</code></td>
                                 <td align="left" valign="top" width="71%" headers="d23610e1141 d23610e1087 ">
                                    <p><code class="codeph">NODEDOWN</code> <code class="codeph">UP</code> ， <code class="codeph">DOWN</code> ， <code class="codeph">NODEDOWN</code> （这仅适用于<code class="codeph">NODE</code>事件类型）， <code class="codeph">NOT_RESTARTING</code>和<code class="codeph">UNKNOWN</code> 。</p>
                                    <p><span class="bold">笔记：</span></p>
                                    <ul style="list-style-type:disc">
                                       <li>
                                          <p>节点关闭时，状态为<code class="codeph">NODEDOWN</code> ，而其他事件类型为<code class="codeph">DOWN</code> 。
                                          </p>
                                       </li>
                                       <li>
                                          <p>当<code class="codeph">STATUS=NODEDOWN</code>和<code class="codeph">REASON=MEMBER_LEAVE</code> ，节点发生故障并且不再是群集的一部分，或者用户已停止节点。
                                          </p>
                                       </li>
                                       <li>
                                          <p>当<code class="codeph">STATUS=NODEDOWN</code>和<code class="codeph">REASON=PUBLIC_NW_DOWN</code> ，节点已启动但无法访问，因为公共网络因故障或用户操作而关闭。
                                          </p>
                                       </li>
                                       <li>
                                          <p>Oracle Clusterware支持多个公共网络。FAN事件反映了这一事实。</p>
                                       </li>
                                    </ul>
                                 </td>
                              </tr>
                              <tr align="left" valign="top">
                                 <td align="left" valign="top" width="29%" id="d23610e1201" headers="d23610e1084 "><code class="codeph">原因</code></td>
                                 <td align="left" valign="top" width="71%" headers="d23610e1201 d23610e1087 ">
                                    <p><code class="codeph">AUTOSTART</code> ， <code class="codeph">BOOT</code> ， <code class="codeph">DEPENDENCY</code> ， <code class="codeph">FAILURE</code> ， <code class="codeph">MEMBER_LEAVE</code> ， <code class="codeph">PUBLIC_NW_DOWN</code> ， <code class="codeph">USER</code> 。</p>
                                    <p><span class="bold">笔记：</span></p>
                                    <ul style="list-style-type:disc">
                                       <li>
                                          <p>对于<code class="codeph">DATABASE</code>和<code class="codeph">SERVICE</code>事件类型， <code class="codeph">REASON=AUTOSTART</code> ，如果在节点启动时， <code class="codeph">AUTO_START</code>资源属性设置为还原，并且资源在节点启动之前处于脱机状态。
                                          </p>
                                       </li>
                                       <li>
                                          <p>对于<code class="codeph">DATABASE</code>和<code class="codeph">SERVICE</code>事件类型， <code class="codeph">REASON=BOOT</code> ，如果在节点启动时资源已启动，因为它在节点启动之前处于联机状态。
                                          </p>
                                       </li>
                                       <li>
                                          <p>对于SRVCTL和Oracle Enterprise Manager操作， <code class="codeph">REASON=USER</code>描述了诸如耗尽工作之类的操作的计划操作。
                                          </p>
                                       </li>
                                    </ul>
                                 </td>
                              </tr>
                              <tr align="left" valign="top">
                                 <td align="left" valign="top" width="29%" id="d23610e1266" headers="d23610e1084 "><code class="codeph">基数</code></td>
                                 <td align="left" valign="top" width="71%" headers="d23610e1266 d23610e1087 ">
                                    <p>当前活动的服务成员数量;包含在所有<code class="codeph">SERVICEMEMBER UP</code>事件中。
                                    </p>
                                    <p>以下是<code class="codeph">SERVICEMEMBER UP</code>事件的示例：</p><pre class="pre codeblock"><code>SERVICEMEMBER VERSION = 1.0 service = swingbench.example.com database = orcl instance = orcl_2 host = mjkbj09 status = up reason = USER card = 1 timestamp = 2018-07-12 14:46:46 timezone = -07：00 db_domain = example .COM</code></pre></td>
                              </tr>
                              <tr align="left" valign="top">
                                 <td align="left" valign="top" width="29%" id="d23610e1283" headers="d23610e1084 "><code class="codeph">化身</code></td>
                                 <td align="left" valign="top" width="71%" headers="d23610e1283 d23610e1087 ">
                                    <p>对于<code class="codeph">NODEDOWN</code>活动;新的集群化身。每次成员加入或离开集群时，此值都会更改。
                                    </p>
                                    <p>以下是<code class="codeph">NODEDOWN</code>事件的示例：</p><pre class="pre codeblock"><code>NODE VERSION = 1.0 host = stru09 incarn = 175615351 status = down reason = member_leave timestamp = 27-Jul-2018 14:49:32 timezone = -07：00</code></pre></td>
                              </tr>
                              <tr align="left" valign="top">
                                 <td align="left" valign="top" width="29%" id="d23610e1300" headers="d23610e1084 "><code class="codeph">时间戳</code></td>
                                 <td align="left" valign="top" width="71%" headers="d23610e1300 d23610e1087 ">
                                    <p>根据Oracle Clusterware发生事件的时间。</p>
                                 </td>
                              </tr>
                              <tr align="left" valign="top">
                                 <td align="left" valign="top" width="29%" id="d23610e1307" headers="d23610e1084 "><code class="codeph">时区</code></td>
                                 <td align="left" valign="top" width="71%" headers="d23610e1307 d23610e1087 ">
                                    <p>发生事件的Oracle Clusterware的时区，格式为GMT +/- hh：mm。</p>
                                 </td>
                              </tr>
                           </tbody>
                        </table>
                     </div>
                     <!-- class="inftblhruleinformal" -->
                     <p>某些FAN事件记录参数的值与<code class="codeph">SYS_CONTEXT</code>函数使用默认命名空间<code class="codeph">USERENV</code>返回的值相对应，如<a href="ensuring-application-continuity.html#GUID-8856EACC-DB95-4F15-ABED-B20234F0678D__BABFJDAI" title="FAN参数和匹配的Oracle数据库签名">表6-2</a>所示。
                     </p>
                     <div class="tblformal" id="GUID-8856EACC-DB95-4F15-ABED-B20234F0678D__BABFJDAI">
                        <p class="titleintable">表6-2 FAN参数和匹配会话信息</p>
                        <table cellpadding="4" cellspacing="0" class="Formal" title="FAN参数和匹配会话信息" width="100%" border="1" summary="FAN parameters and matching Oracle database signatures" frame="hsides" rules="rows">
                           <thead>
                              <tr align="left" valign="top">
                                 <th align="left" valign="bottom" width="29%" id="d23610e1337">风扇参数</th>
                                 <th align="left" valign="bottom" width="71%" id="d23610e1340">匹配会话信息</th>
                              </tr>
                           </thead>
                           <tbody>
                              <tr align="left" valign="top">
                                 <td align="left" valign="top" width="29%" id="d23610e1345" headers="d23610e1337 "><code class="codeph">服务</code></td>
                                 <td align="left" valign="top" width="71%" headers="d23610e1345 d23610e1340 "><code class="codeph">sys_context（'userenv'，'service_name'）</code></td>
                              </tr>
                              <tr align="left" valign="top">
                                 <td align="left" valign="top" width="29%" id="d23610e1352" headers="d23610e1337 "><code class="codeph">DATABASE_UNIQUE_NAME</code></td>
                                 <td align="left" valign="top" width="71%" headers="d23610e1352 d23610e1340 "><code class="codeph">sys_context（'userenv'，'db_unique_name'）</code></td>
                              </tr>
                              <tr align="left" valign="top">
                                 <td align="left" valign="top" width="29%" id="d23610e1359" headers="d23610e1337 "><code class="codeph">INSTANCE</code></td>
                                 <td align="left" valign="top" width="71%" headers="d23610e1359 d23610e1340 "><code class="codeph">sys_context（'userenv'，'instance_name'）</code></td>
                              </tr>
                              <tr align="left" valign="top">
                                 <td align="left" valign="top" width="29%" id="d23610e1366" headers="d23610e1337 "><code class="codeph">CLUSTER_NODE_NAME</code></td>
                                 <td align="left" valign="top" width="71%" headers="d23610e1366 d23610e1340 "><code class="codeph">sys_context（'userenv'，'server_host'）</code></td>
                              </tr>
                           </tbody>
                        </table>
                     </div>
                     <!-- class="inftblhruleinformal" -->
                  </div>
               </div><a id="RACAD8267"></a><div class="sect3"><a id="GUID-807BA413-6348-482D-A53C-462F5BBAE5A8" name="GUID-807BA413-6348-482D-A53C-462F5BBAE5A8"></a><h4 id="RACAD-GUID-807BA413-6348-482D-A53C-462F5BBAE5A8" class="sect4">订阅高可用性事件</h4>
                  <div>
                     <p>Oracle RAC使用FAN通知应用程序有关配置更改以及启用服务的每个实例提供的当前服务级别。如果您使用OCI客户端或ODP.NET客户端接收FAN事件，则必须通过使用带有<code class="codeph">-notification</code>参数的<code class="codeph">-notification</code>来启用该客户端使用的服务来访问警报通知队列。
                     </p>
                  </div>
               </div><a id="RACAD7133"></a><div class="sect3"><a id="GUID-2024CEF8-F984-4377-9182-E17F738A4715" name="GUID-2024CEF8-F984-4377-9182-E17F738A4715"></a><h4 id="RACAD-GUID-2024CEF8-F984-4377-9182-E17F738A4715" class="sect4">使用快速应用程序通知标注</h4>
                  <div>
                     <p>FAN标注是Oracle RAC在发生高可用性事件时立即执行的服务器端可执行文件。</p>
                     <p>在群集配置中发生事件时，您可以使用FAN标注自动执行活动，例如：</p>
                     <ul style="list-style-type:disc">
                        <li>
                           <p>打开故障跟踪票证</p>
                        </li>
                        <li>
                           <p>向寻呼机发送消息</p>
                        </li>
                        <li>
                           <p>发送电子邮件</p>
                        </li>
                        <li>
                           <p>启动和停止服务器端应用程序</p>
                        </li>
                        <li>
                           <p>通过记录每个事件发生时记录正常运行时间日志</p>
                        </li>
                        <li>
                           <p>高优先级服务联机时重定位低优先级服务</p>
                        </li>
                     </ul>
                     <p>要使用FAN标注，请在运行Oracle Clusterware的每个节点上的<code class="codeph"><span class="variable" translate="no">Grid_home</span> /racg/usrco</code>目录中放置一个可执行文件。可执行文件必须能够在从另一个程序调用时使用可选参数独立运行。以下是名为<code class="codeph">callout.sh</code>的可执行shell脚本示例，该脚本位于<code class="codeph"><span class="variable" translate="no">Grid_home</span> /racg/usrco</code>目录中：</p><pre class="pre codeblock"><code>＃！/ bin / bash FAN_LOGFILE = [ <span class="variable" translate="no">your_path_name</span> ] /admin/log/'hostname'_uptime'.log echo $ *“reported =”'date'&gt;&gt; $ FAN_LOGFILE＆</code></pre><p>前面的示例在日志文件中添加类似于以下的条目，每次生成FAN事件时，在shell脚本中由<code class="codeph">$FAN_LOGFILE</code>指示：</p><pre class="pre codeblock"><code>NODE VERSION = 1.0 host = sun880-2 incarn = 23 status = nodedown reason = public_nw_down timestamp = 08-Oct-2012 04:02:14 timezone = -08:00报道= Fri Oct 8 04:02:14 PDT 2012</code></pre><p>FAN事件记录的内容与登录到数据库的用户的当前会话相匹配，如<a href="ensuring-application-continuity.html#GUID-8856EACC-DB95-4F15-ABED-B20234F0678D__BABFJDAI" title="FAN参数和匹配的Oracle数据库签名">表6-2</a>所示。使用OCI连接句柄和描述符属性（使用<code class="codeph">OCIAttrGet()</code> ）也可以获得用户环境（ <code class="codeph">USERENV</code> ）信息。使用此信息对与FAN事件数据匹配的会话执行操作。
                     </p>
                     <div class="infoboxnotealso" id="GUID-2024CEF8-F984-4377-9182-E17F738A4715__GUID-B729C78F-470B-4107-8806-9C4586EDB569">
                        <p class="notep1">也可以看看：</p>
                        <p>有关标注和事件详细信息的信息，请<a href="ensuring-application-continuity.html#GUID-8856EACC-DB95-4F15-ABED-B20234F0678D__BABJHGIA" title="事件有效负载参数和描述">参见表6-1</a></p>
                     </div>
                     <p>通常，事件仅发布到发起事件的节点上的用户标注。例如，如果<code class="codeph">node1</code>上的数据库关闭，则callout仅发布到<code class="codeph">node1</code> 。唯一的例外是节点关闭和VIP关闭事件 - 这些事件将发布到所有节点，无论它们来自何处。
                     </p>
                  </div>
                  <div>
                     <div class="relinfo">
                        <p><strong>相关话题</strong></p>
                        <ul>
                           <li><a href="../lnoci/oci-programming-basics.html#LNOCI-GUID-4CFB8AF7-EF05-4E0F-847F-2D0710E552C5" target="_blank"><span><cite>Oracle调用接口程序员指南</cite></span></a></li>
                        </ul>
                     </div>
                  </div>
               </div>
            </div><a id="RACAD7130"></a><div class="sect2"><a id="GUID-27F35F42-080C-49F2-976E-DB073ACCBFEB" name="GUID-27F35F42-080C-49F2-976E-DB073ACCBFEB"></a><h3 id="RACAD-GUID-27F35F42-080C-49F2-976E-DB073ACCBFEB" class="sect3">管理意外中断</h3>
               <div>
                  <p>您可以将服务分配给管理员管理的Oracle RAC数据库中的一个或多个实例，也可以分配给策略管理的数据库中的服务器池。</p>
                  <p>如果Oracle RAC检测到中断，则Oracle Clusterware会隔离发生故障的组件并恢复相关组件。对于服务，如果故障组件是实例，则Oracle Clusterware会尝试维护服务的基数。如果服务定义允许故障转移并且这是维护基数所必需的，则会发生故障转移。</p>
                  <p>FAN事件可以在Oracle数据库体系结构中的各个级别发生，并通过Oracle Notification Service和Advanced Queuing发布，以便与以前的OCI客户端向后兼容。还可以编写FAN标注以在数据库服务器上执行以响应FAN事件。</p>
                  <div class="infoboxnote" id="GUID-27F35F42-080C-49F2-976E-DB073ACCBFEB__GUID-EFE0E6CE-5D0B-4A92-906A-8E3205E159A2">
                     <p class="notep1">注意：</p>
                     <p>Oracle数据库不保证订购时运行Oracle RAC标注。标注是异步运行的，它们受调度可变性的影响。</p>
                  </div>
                  <p>当故障节点停止服务时，FAN从幸存节点发布。提供服务的Oracle RAC环境中的实例的位置和数量对应用程序是透明的。重新启动和恢复是自动的，包括重新启动子系统，例如侦听器和Oracle自动存储管理（Oracle ASM）进程，而不仅仅是数据库。您可以使用FAN标注向故障管理系统报告故障并启动修复作业。</p>
                  <p>对于应用程序开发人员来说，屏蔽数据库会话（实例，节点，存储或网络或任何其他相关组件）的中断是一项复杂的任务，因此，错误和超时通常会暴露给最终用户，从而导致用户受挫，生产力下降，失去机会。FAN和应用程序连续性通过在中断后恢复受影响的数据库会话的飞行中工作来屏蔽用户和应用程序的中断。应用程序连续性在应用程序下执行此恢复，以便中断在应用程序中显示为稍微延迟执行请求。</p>
               </div>
               <div>
                  <div class="relinfo">
                     <p><strong>相关话题</strong></p>
                     <ul>
                        <li><a href="ensuring-application-continuity.html#GUID-BD699AEB-9F85-42A8-8687-5A979918938D" title="应用程序连续性通过还原数据库会话从应用程序和用户屏蔽许多可恢复的数据库中断（当重放成功时）：完整会话，包括所有状态，游标，变量和最后一个事务（如果有）。">关于应用程序连续性</a></li>
                        <li><a href="../netag/identifying-and-accessing-database.html#NETAG-GUID-50EEC5AA-38D5-49E3-84BB-2CF9A3B63E1F" target="_blank"><span><cite>Oracle数据库网络服务管理员指南</cite></span></a></li>
                     </ul>
                  </div>
               </div>
            </div><a id="RACAD8846"></a><a id="RACAD7131"></a><div class="sect2"><a id="GUID-11B75A54-CEF7-4113-A72F-9E7AAFE61953" name="GUID-11B75A54-CEF7-4113-A72F-9E7AAFE61953"></a><h3 id="RACAD-GUID-11B75A54-CEF7-4113-A72F-9E7AAFE61953" class="sect3">管理计划维护</h3>
               <div>
                  <p>对于需要您隔离一个或多个实例或节点的修复，升级和更改，Oracle RAC提供了重定位，禁用和启用服务的接口，以最大限度地减少对应用程序用户的服务中断。</p>
                  <p>重定位服务时，表明该服务应临时在另一个实例上运行。如果强行禁用某项服务，则该服务将在所有数据库实例上停止，并且不再可用。禁用的服务不会自动重启。停止或重新定位服务时，将使用计划的原因代码发布FAN，通常是<code class="codeph">reason=user</code> 。完成操作后，您可以将服务恢复为正常操作或启用该服务，然后重新启动它。当服务重新启动时，将使用<code class="codeph">UP</code>状态代码发布FAN。
                  </p>
                  <p>由于依赖性，如果手动关闭数据库，则该数据库的所有服务都将自动停止。如果希望在手动重新启动数据库时自动启动服务，则必须将服务的管理策略设置为自动。如果要仅关闭数据库的一个实例并且希望保持提供服务，则可以使用<code class="codeph">srvctl relocate service</code>或使用<code class="codeph">srvctl stop instance</code> ，这使服务能够根据自动进行故障转移。它的故障转移政策。
                  </p>
                  <p>在任何一种情况下，Oracle都建议在服务下运行的工作在请求边界处流失。排放间隔被指定为服务的属性，或者您可以在SRVCTL命令行上提供排放间隔。</p>
                  <p>本节包括以下主题：</p>
                  <ul style="list-style-type:disc">
                     <li>
                        <p><a href="ensuring-application-continuity.html#GUID-DA6B6272-C420-4A1F-BB5F-E9A81A5469D8" title="Oracle建议您在启用FAN的Oracle或非Oracle连接池的受控时间段内从实例中排出数据库会话，或者从数据库中的Oracle Database 18c本身开始。">在没有用户中断的情况下管理计划维护</a></p>
                     </li>
                     <li>
                        <p><a href="ensuring-application-continuity.html#GUID-D7D9D76F-22DF-4603-B7DC-8D7FC88F32E6" title="许多企业运行大量服务，无论是单个数据库或实例提供的许多服务，还是提供在同一节点上运行的一些服务的许多数据库。">管理维护服务组</a></p>
                     </li>
                     <li>
                        <p><a href="ensuring-application-continuity.html#GUID-2DD974C8-94C2-446B-B2BD-81B8135A26C3" title="在计划维护之前，在数据库实例上排空或故障转移数据库会话，以便不中断应用程序工作。从Oracle Database 18c开始，数据库本身会耗尽会话。">服务器在计划维护之前排空</a></p>
                     </li>
                  </ul>
               </div>
               <div>
                  <div class="relinfo">
                     <p><strong>相关话题</strong></p>
                     <ul>
                        <li><a href="workload-management-with-dynamic-database-services.html#GUID-0573F51A-7DF9-40AC-AE6A-0997F7EEEF3F">服务管理政策</a></li>
                     </ul>
                  </div>
               </div>
               <div class="sect3"><a id="GUID-DA6B6272-C420-4A1F-BB5F-E9A81A5469D8" name="GUID-DA6B6272-C420-4A1F-BB5F-E9A81A5469D8"></a><h4 id="RACAD-GUID-DA6B6272-C420-4A1F-BB5F-E9A81A5469D8" class="sect4">在没有用户中断的情况下管理计划维护</h4>
                  <div>
                     <p>Oracle建议您在启用FAN的Oracle或非Oracle连接池的受控时间段内从实例中排出数据库会话，或者从数据库中的Oracle Database 18c本身开始。</p>
                     <div class="section">
                        <p>排空数据库会话是在不中断应用程序的情况下迁移工作的最安全方法。当在连接测试和请求边界之外发生排水时，它是100％正确的。当现有工作完成并且新工作为另一个实例上的相同服务获取会话时，应用程序继续不中断，从而不会将错误返回给应用程序，并且不存在不正确的数据库会话状态的风险。对于连接测试，调用者期望收到好的或坏的返回代码并准备好处理结果，使检查连接测试成为一个广泛适用且非常强大的解决方案。</p>
                        <p>服务属性<code class="codeph">-drain_timeout</code>和<code class="codeph">-stopoption</code>控制排出时间段，然后控制服务如何管理在此时间段到期后尚未完成的会话。完成然后重新检入池或关闭的请求可以定向到不受计划维护影响的新位置。
                        </p>
                        <p>应用程序连续性提供额外的保护，为那些未在规定的排水时间内完成的请求提供持续服务。</p>
                        <p>使用配置了快速连接故障切换的任何FAN感知池（例如OCI会话池，Oracle通用连接池，Oracle WebLogic Server Active GridLink for Oracle RAC或ODP.NET），允许会话在收到计划的FAN后在<a href="glossary.html#GUID-9B4EED64-7F24-4363-ACFB-4859BDDF2034"><span class="xrefglossterm">请求</span></a>边界消耗<code class="codeph">DOWN</code>活动。
                        </p>
                        <p>因为并非每个应用程序都使用Oracle连接池，并且并非每个应用程序都支持FAN，所以从Oracle Database 18c开始，数据库会在计划维护期间检查会话，以寻找安全位置来停止会话，以便应用程序不会中断。停止服务后，数据库会查找可以关闭连接的安全位置。关闭连接后，数据库会清除会话。</p>
                        <p>在安全的地方停止会话使应用程序能够打开与其所需状态的新连接。排水会议可能需要一段时间才能完成每个会话。不要求立即关闭会话，而是必须在不向应用程序公开任何错误的安全位置进行关闭，并且最好在排出超时期限到期之前。</p>
                        <p>请求远比交易重要，因为它们可以完成已发布的工作。对于排除请求，Oracle通用连接池使用排除超时逐渐消耗，这可以防止在实例上的登录过载，通过在整个时间段内缓慢释放原始会话而不是一次性释放。渐进式排水的好处是不会干扰目标实例中正在进行的其他工作。</p>
                        <p><code class="codeph">DRAIN_TIMEOUT</code>和<code class="codeph">STOP_OPTION</code>都是服务属性，您可以在添加服务时定义或在创建后修改它。您还可以使用SRVCTL指定这些属性，SRVCTL将优先于服务上定义的属性。使用以下SRVCTL命令时，可以指定<code class="codeph">-drain_timeout</code>和<code class="codeph">-stopoption</code>参数：</p>
                        <ul style="list-style-type:disc">
                           <li>
                              <p><code class="codeph">srvctl添加服务</code></p>
                           </li>
                           <li>
                              <p><code class="codeph">srvctl修改服务</code></p>
                           </li>
                           <li>
                              <p><code class="codeph">srvctl重新定位服务</code></p>
                           </li>
                           <li>
                              <p><code class="codeph">srvctl停止服务</code></p>
                           </li>
                           <li>
                              <p><code class="codeph">srvctl停止数据库</code></p>
                           </li>
                           <li>
                              <p><code class="codeph">srvctl停止实例</code></p>
                           </li>
                        </ul>
                        <p>在没有用户中断的情况下管理计划维护：</p>
                     </div>
                     <!-- class="section" -->
                     <ol>
                        <li class="stepexpand"><span>使用SRVCTL重定位单个服务或未在所有节点上运行的服务。将<code class="codeph">-force</code>标志与先前列出的SRVCTL命令一起使用。如果在运行<code class="codeph">srvctl relocate service</code>或<code class="codeph">srvctl stop service</code>时在命令行上指定<code class="codeph">-stopoption</code>参数，则必须使用<code class="codeph">-force</code>标志。例如：</span><div><pre class="pre codeblock"><code>$ srvctl重定位服务-database mycdb01 -service myservice -drain_timeout 120 -stopoption IMMEDIATE -oldinst mycdb01_01 -force</code></pre><div class="p">上述命令将名为<code class="codeph">myservice01</code>的服务从名为<code class="codeph">mycdb01_01</code>的实例重<code class="codeph">mycdb01_01</code>到配置为运行它的任何实例。如果您未在命令行上指定目标，Oracle Clusterware会选择此实例，并等待两分钟（在此示例中）以消除任何活动会话，之后将强制断开<code class="codeph">mycdb01_01</code>上剩余的任何会话。连接池自动在请求边界释放连接。
                                 <div class="infoboxnote" id="GUID-DA6B6272-C420-4A1F-BB5F-E9A81A5469D8__GUID-5857741E-DF19-4759-88D0-57C26D012050">
                                    <p class="notep1">注意：</p>如果要重定位的服务是当前在所有节点上运行的统一服务，则上述命令将返回错误，除非服务未在所有实例上运行，在这种情况下，前面的命令示例将成功进行统一服务。
                                 </div>
                              </div>
                           </div>
                        </li>
                        <li class="stepexpand"><span>FAN计划的<code class="codeph">DOWN</code>事件立即清除连接池中的空闲会话，并标记在下次登记时释放的活动会话。这些FAN操作会从实例中消耗会话，而不会中断用户。</span><div>
                              <p>其他实例上的现有连接仍然可用，并且可以根据需要向这些实例打开新连接。</p>
                           </div>
                        </li>
                        <li class="stepexpand"><span>并非所有会话都会检查他们与池的连接。作为最佳实践，Oracle建议使用超时期限（通过设置<code class="codeph">-drain_timeout</code>参数），然后强制关闭实例或停止服务，逐出任何剩余的客户端连接。</span><div>
                              <div class="p">在排放间隔到期后，将实现<code class="codeph">-stopoption</code>参数，您可以根据服务或数据库对其进行定义，如下所示：<ul style="list-style-type:disc">
                                    <li>
                                       <p>停止服务（ <code class="codeph">svrctl stop service</code> ）时，可以使用<code class="codeph">-stopoption</code>参数指定以下停止选项<code class="codeph">-stopoption</code> ：TRANSACTIONAL或IMMEDIATE</p>
                                    </li>
                                    <li>
                                       <p>停止数据库（ <code class="codeph">svrctl stop database</code> ）时，可以使用<code class="codeph">-stopoption</code>参数指定以下停止选项<code class="codeph">-stopoption</code> ：NORMAL，TRANSACTIONAL，IMMEDIATE或ABORT</p>
                                    </li>
                                 </ul>
                              </div>
                              <div class="p">数据库停止选项与服务停止选项相关，如下所示：<ul class="simple" style="list-style-type:none;padding-left:0">
                                    <li>师大= NONE</li>
                                    <li>TRANSACTIONAL / TRANSACTIONAL LOCAL = TRANSACTIONAL</li>
                                    <li>IMMEDIATE / ABORT = IMMEDIATE</li>
                                 </ul>
                              </div>
                              <p>对于那些配置为使用应用程序连续性的服务，尝试在终止后恢复这些剩余会话，从而屏蔽用户和应用程序的中断。</p>
                              <p>如果您不希望Application Continuity尝试重播会话，请在SRVCTL命令行上指定<code class="codeph">-noreplay</code>标志。
                              </p>
                           </div>
                        </li>
                        <li class="stepexpand"><span>维护完成后，重新启动原始节点上的实例和服务。</span></li>
                        <li class="stepexpand"><span>服务的FAN <code class="codeph">UP</code>事件通知连接池新实例可供使用，允许在下一个请求边界的此实例上创建会话。</span></li>
                     </ol>
                  </div>
                  <div>
                     <div class="relinfo">
                        <p><strong>相关话题</strong></p>
                        <ul>
                           <li><a href="ensuring-application-continuity.html#GUID-BD699AEB-9F85-42A8-8687-5A979918938D">关于应用程序连续性</a></li>
                           <li><a href="ensuring-application-continuity.html#GUID-2DD974C8-94C2-446B-B2BD-81B8135A26C3" title="在计划维护之前，在数据库实例上排空或故障转移数据库会话，以便不中断应用程序工作。从Oracle Database 18c开始，数据库本身会耗尽会话。">服务器在计划维护之前排空</a></li>
                        </ul>
                     </div>
                  </div>
               </div>
               <div class="sect3"><a id="GUID-D7D9D76F-22DF-4603-B7DC-8D7FC88F32E6" name="GUID-D7D9D76F-22DF-4603-B7DC-8D7FC88F32E6"></a><h4 id="RACAD-GUID-D7D9D76F-22DF-4603-B7DC-8D7FC88F32E6" class="sect4">管理维护服务组</h4>
                  <div>
                     <p>许多企业运行大量服务，无论是单个数据库或实例提供的许多服务，还是提供在同一节点上运行的一些服务的许多数据库。</p>
                     <div class="section">您不再需要为每个单独的服务运行SRVCTL命令，但只需要为所有受影响的服务指定节点名称，数据库名称，可插入数据库名称或实例名称。</div>
                     <!-- class="section" -->
                     <div class="section"></div>
                     <!-- class="section" -->
                     <ul>
                        <li class="stepexpand"><span>例如，如果要停止在给定节点上运行的所有服务，则可以使用以下命令：</span><div><pre class="pre codeblock"><code>$ srvctl stop service -node racnode01 -drain_timeout 60 -stopoption IMMEDIATE</code></pre><p>该命令将停止在<code class="codeph">racnode01</code>运行的所有服务，允许的排放间隔为60秒。60秒后，立即停止任何剩余的会话。60秒的耗尽超时间隔将覆盖任何服务上的任何属性设置。
                              </p>
                              <div class="p">该命令也可以限定在节点上停止数据库，如下例所示：<pre class="pre codeblock"><code>$ srvctl stop instance -node racnode01 -drain_timeout 60 -stopoption TRANSACTIONAL LOCAL -failover -force</code></pre>指定<code class="codeph">-failover</code>参数时：<ul style="list-style-type:disc">
                                    <li>
                                       <p>如果可能，将重新定位所有服务，并遵循指定的排水超时间隔和停止选项。</p>
                                    </li>
                                    <li>
                                       <p>使用指定的stop选项停止任何无法进行故障转移的服务。</p>
                                    </li>
                                    <li>
                                       <p>等待排水超时间隔的长度，或者直到删除目标服务的所有会话，以较早者为准。</p>
                                    </li>
                                    <li>
                                       <p>所有实例都根据指定的停止选项停止。</p>
                                    </li>
                                 </ul>指定<code class="codeph">–stopoption TRANSACTIONAL LOCAL</code>参数时：<ul style="list-style-type:disc">
                                    <li>
                                       <p>剩余服务根据指定的排水超时间隔和停止选项停止。</p>
                                    </li>
                                    <li>
                                       <p>等待排水超时间隔的长度，或者直到删除目标服务的所有会话，以较早者为准。</p>
                                    </li>
                                    <li>
                                       <p>实例将停止使用<code class="codeph">TRANSACTIONAL LOCAL</code>停止选项。
                                       </p>
                                    </li>
                                 </ul>
                              </div>
                           </div>
                        </li>
                     </ul>
                     <div class="section">
                        <p>本节包括以下主题：</p>
                        <ul style="list-style-type:disc">
                           <li>
                              <p><a href="ensuring-application-continuity.html#GUID-9FCB5766-64EA-4FF7-9BAC-02266BCE97B3" title="您可以使用srvctl start service命令启动节点上的所有服务，数据库提供的所有服务，可插拔数据库提供的所有服务，或实例或给定服务器池中提供的所有服务。">启动服务</a></p>
                           </li>
                           <li>
                              <p><a href="ensuring-application-continuity.html#GUID-7B4774D3-EB0B-4C4E-B831-C4EB75B15AED" title="您可以使用SRVCTL来管理可插拔数据库上的服务。">可插拔数据库级操作</a></p>
                           </li>
                           <li>
                              <p><a href="ensuring-application-continuity.html#GUID-51D6BEA5-4C73-4BE4-A2A4-70C6B4356915" title="您可以使用srvctl relocate service命令将服务重定位到目标目标，该目标可以是实例，节点或数据库。">搬迁服务</a></p>
                           </li>
                           <li>
                              <p><a href="ensuring-application-continuity.html#GUID-9CEC40F3-CE0E-4A41-9687-EF6510E51C93" title="您可以使用srvctl stop service命令停止节点上的所有服务，数据库提供的所有服务，可插拔数据库提供的所有服务，或实例或给定服务器池中提供的所有服务。">停止服务</a></p>
                           </li>
                        </ul>
                     </div>
                     <!-- class="section" -->
                  </div>
                  <div class="sect4"><a id="GUID-9FCB5766-64EA-4FF7-9BAC-02266BCE97B3" name="GUID-9FCB5766-64EA-4FF7-9BAC-02266BCE97B3"></a><h5 id="RACAD-GUID-9FCB5766-64EA-4FF7-9BAC-02266BCE97B3" class="sect5">启动服务</h5>
                     <div>
                        <p>您可以使用<code class="codeph">srvctl start service</code>命令启动节点上的所有服务，数据库提供的所有服务，可插拔数据库提供的所有服务，或实例或给定服务器池中提供的所有服务。
                        </p>
                        <div class="section">您还可以向要启动的<code class="codeph">srvctl start service</code>命令提供服务列表（所有服务的子集）。此外，您可以为可以在特定节点上启动的所有服务提供节点限制（与数据库选项一起使用）。您可以通过指定<code class="codeph">-pq</code>参数来限制<code class="codeph">srvctl start service</code>命令以仅启动并行查询服务。
                        </div>
                        <!-- class="section" -->
                        <div class="section">以下示例说明了如何启动服务：</div>
                        <!-- class="section" -->
                        <ul>
                           <li class="stepexpand"><span>要启动单个可插拔数据库提供的所有服务：</span><div><pre class="pre codeblock"><code>$ srvctl启动服务-db myRACCDB01 -pdb myPDB01 -startoption OPEN</code></pre><p>要在给定数据库及其任何可插拔数据库上启动所有服务，请执行以下操作：</p><pre class="pre codeblock"><code>$ srvctl启动服务-db myRACDB</code></pre><p>要在给定数据库上启动服务列表，而不管它们与之关联的任何可插拔数据库：</p><pre class="pre codeblock"><code>$ srvctl启动服务-db myRACDB -service“myFirstService，mySecondService，myThirdService”</code></pre><p>要为可在给定节点上运行的数据库启动所有服务，请执行以下操作：</p><pre class="pre codeblock"><code>$ srvctl启动服务-d myRACDB -node racnode01</code></pre></div>
                           </li>
                        </ul>
                     </div>
                  </div>
                  <div class="sect4"><a id="GUID-7B4774D3-EB0B-4C4E-B831-C4EB75B15AED" name="GUID-7B4774D3-EB0B-4C4E-B831-C4EB75B15AED"></a><h5 id="RACAD-GUID-7B4774D3-EB0B-4C4E-B831-C4EB75B15AED" class="sect5">可插拔数据库级操作</h5>
                     <div>
                        <p>您可以使用SRVCTL来管理可插拔数据库上的服务。</p>
                        <ul>
                           <li class="stepexpand"><span>要为所有实例或单个实例启动可插拔数据库的所有服务：</span><div><pre class="pre codeblock"><code>$ srvctl start service -db <span class="variable" translate="no">db_name</span> -pdb <span class="variable" translate="no">pdb_name</span> [-instance <span class="variable" translate="no">instance_name</span> ]</code></pre></div>
                           </li>
                           <li class="stepexpand"><span>要为所有实例或单个实例停止可插拔数据库的所有服务：</span><div><pre class="pre codeblock"><code>$ srvctl stop service -db <span class="variable" translate="no">db_name</span> -pdb <span class="variable" translate="no">pdb_name</span> [-node <span class="variable" translate="no">node_name</span> | -instance <span class="variable" translate="no">inst_name</span> | -serverpool <span class="variable" translate="no">pool_name</span> ] [-stopoption <span class="variable" translate="no">stop_option</span> ] [-drain_timeout <span class="variable" translate="no">timeout</span> ] [-force [-noreplay]]</code></pre><div class="infoboxnote" id="GUID-7B4774D3-EB0B-4C4E-B831-C4EB75B15AED__GUID-F77A9401-3A39-4993-8B1D-9E1B7A751E44">
                                    <p class="notep1">注意：</p><code class="codeph">-pdb <span class="variable" translate="no">pdb_name</span></code>参数是可选的。如果省略可插入数据库名称，则会对整个容器数据库（此容器中的所有可插入数据库）执行操作。
                                 </div>
                              </div>
                           </li>
                        </ul>
                     </div>
                  </div>
                  <div class="sect4"><a id="GUID-51D6BEA5-4C73-4BE4-A2A4-70C6B4356915" name="GUID-51D6BEA5-4C73-4BE4-A2A4-70C6B4356915"></a><h5 id="RACAD-GUID-51D6BEA5-4C73-4BE4-A2A4-70C6B4356915" class="sect5">搬迁服务</h5>
                     <div>
                        <p>您可以使用<code class="codeph">srvctl relocate service</code>命令<code class="codeph">srvctl relocate service</code>重定位到目标目标，该目标可以是实例，节点或数据库。
                        </p>
                        <ul>
                           <li class="stepexpand"><span>在以下命令示例中，将从指定的数据库，可插入数据库，实例或节点重定位所有服务。如果目标可以支持该服务（如服务配置所定义），则服务将仅重定位。任何无法重新定位的服务都保留在原始位置。针对无法重新定位或已在新目标上运行的任何服务记录放置错误。未能重新定位的服务仍在原始位置运行，并且所有会话都保持活动状态。</span><div><pre class="pre codeblock"><code>$ srvctl重定位服务-database myRACCDB -oldinst RACCDB_01 -newinst RACCDB_03 -drain_timeout 30 -force</code></pre><p>要么</p><pre class="pre codeblock"><code>$ srvctl重定位服务-database myRACCDB -pdb myPDB01 -currentnode racnode01 -targetnode racnode02 -drain_timeout 30 -force -noreplay</code></pre><p>重定位操作在停止现有位置的服务之前在新位置启动服务。</p>
                              </div>
                           </li>
                           <li class="stepexpand"><span>如果未指定目标目标，则Oracle Clusterware将从指定的数据库，可插入数据库，实例或节点重定位所有服务或特定服务，如以下示例所示：</span><div><pre class="pre codeblock"><code>$ srvctl重定位服务-database myRACCDB -service“myService01，myService02”-drain_timeout 30 -force</code></pre><p>要么</p><pre class="pre codeblock"><code>$ srvctl重定位服务-database myRACCDB -pdb myPDB01 -drain_timeout 30 -force -noreplay</code></pre><p>如果没有可用的有效目标，则服务保留在原始位置，并且会话保持活动状态。您必须检查服务并停止它们，如果这是您想要做的。</p>
                              </div>
                           </li>
                        </ul>
                        <div class="section">重新定位服务时，它会在新位置开始，然后停在原始位置。Oracle Clusterware可以将该新实例或可插拔数据库作为依赖项启动。指定时， <code class="codeph">-drain_timeout</code>和<code class="codeph">-stopoption</code>参数将覆盖服务属性。
                        </div>
                        <!-- class="section" -->
                     </div>
                  </div>
                  <div class="sect4"><a id="GUID-9CEC40F3-CE0E-4A41-9687-EF6510E51C93" name="GUID-9CEC40F3-CE0E-4A41-9687-EF6510E51C93"></a><h5 id="RACAD-GUID-9CEC40F3-CE0E-4A41-9687-EF6510E51C93" class="sect5">停止服务</h5>
                     <div>
                        <p>您可以使用<code class="codeph">srvctl stop service</code>命令停止节点上的所有服务，数据库提供的所有服务，可插拔数据库提供的所有服务，或实例或给定服务器池中提供的所有服务。
                        </p>
                        <div class="section">您还可以提供要停止到<code class="codeph">srvctl stop service</code>命令的服务列表（所有服务的子集），还可以通过指定<code class="codeph">-pq</code>参数来限制<code class="codeph">srvctl stop service</code>命令以仅停止并行查询服务。
                        </div>
                        <!-- class="section" -->
                        <div class="section">以下示例说明了如何停止服务：</div>
                        <!-- class="section" -->
                        <ul>
                           <li class="stepexpand"><span>要停止单个可插拔数据库提供的所有服务：</span><div><pre class="pre codeblock"><code>$ srvctl stop service -db myRACCDB01 -pdb myPDB01 -drain_timeout 15 -stopoption TRANSACTIONAL</code></pre><p>要停止给定数据库及其任何可插拔数据库上的所有服务，请执行以下操作：</p><pre class="pre codeblock"><code>$ srvctl stop service -db myRACDB -drain_timeout 15 -stopoption IMMEDIATE</code></pre><p>要仅停止数据库提供的服务的子集：</p><pre class="pre codeblock"><code>$ srvctl stop service -db myRACDB -service“myFirstService，mySecondService，myThirdService”-drain_timeout 60 -stopoption IMMEDIATE</code></pre><div class="infoboxnote" id="GUID-9CEC40F3-CE0E-4A41-9687-EF6510E51C93__GUID-752D8114-7C0C-419D-8860-C70BBC91FBB9">
                                    <p class="notep1">注意：</p>如果使用<code class="codeph">–wait YES</code> SRVCTL命令行参数，则在整个排出超时间隔到期之前不会强制执行<code class="codeph">–stopoption</code>参数，即使所有会话在此间隔完成之前已退出。
                                 </div>
                              </div>
                           </li>
                        </ul>
                     </div>
                  </div>
               </div>
               <div class="sect3"><a id="GUID-2DD974C8-94C2-446B-B2BD-81B8135A26C3" name="GUID-2DD974C8-94C2-446B-B2BD-81B8135A26C3"></a><h4 id="RACAD-GUID-2DD974C8-94C2-446B-B2BD-81B8135A26C3" class="sect4">服务器在计划维护之前排空</h4>
                  <div>
                     <p>在计划维护之前，在数据库实例上排空或故障转移数据库会话，以便不中断应用程序工作。从Oracle Database 18c开始，数据库本身会耗尽会话。</p>
                     <p>准备计划维护时，必须停止或重定位使用服务器基础结构的服务。重新安置服务是在计划中断之前的一段时间内完成的，并且基于与每项服务相关的工作性质。</p>
                     <p>滚动计划维护的过程在维护之前将服务移动到另一个数据库实例，并通知客户端驱动程序，连接池，数据库实例本身以及维护正在等待的其他订户以及需要耗尽的内容（连接或使用此服务的会话）。一旦通知了耗尽，就会发送<span class="bold"><a href="glossary.html#GUID-D7C185C7-84A9-4935-AAB6-CADC23C705DE"><span class="xrefglossterm">快速应用程序通知（FAN）</span></a></span>事件，并且客户端池的行为与其他地方一样，此外，数据库开始搜索安全位置以释放连接，并在需要时迁移连接。
                     </p>
                     <p>移动或停止服务会触发订阅Oracle驱动程序和Oracle连接池接收的FAN通知。从Oracle Database 18c开始，FAN通知还会触发服务器上的会话耗尽。立即，该服务的新工作将被定向到该服务的另一个功能实例。现有会话在工作完成后标记为发布。当工作完成并且连接返回到连接池时，Oracle驱动程序或连接池将终止这些会话。</p>
                     <div class="section">
                        <p class="subhead3" id="GUID-2DD974C8-94C2-446B-B2BD-81B8135A26C3__GUID-857BEAB6-49F6-47B2-AC0F-938D78F00C02">在数据库中排除会话</p>
                        <p>对于OLTP应用程序，应用程序服务器和自定义应用程序，它们都有自己的借用和返回数据库会话的连接池，在不再借用数据库会话时可以安全地排空数据库会话。Oracle服务器基础结构关闭会话的最佳点是应用程序服务器测试该连接的有效性。当连接池管理器在借用和释放时测试连接的有效性时，不会向应用程序返回任何错误，并且还发现连接不再有效。</p>
                        <p>安全的地方是应用程序不受干扰的地方。在连接池的情况下，这意味着未借用（签入）的连接，并且在应用程序的情况下，同样适用于借用或返回连接的点。此时，所有工作都已完成或未开始。当可以对应用程序透明地恢复所有状态时，数据库还可以对连接进行故障转移。</p>
                        <div class="p">从Oracle Database 18c开始，数据库使用一组可扩展的规则和启发式方法来检测何时取消数据库会话。当开始排空时，数据库会话将持续存储在数据库中，直到满足规则。规则包括以下内容：<ul id="GUID-2DD974C8-94C2-446B-B2BD-81B8135A26C3__UL_WMF_D1B_LHB" style="list-style-type:disc">
                              <li>
                                 <p>标准应用程序服务器测试有效性</p>
                              </li>
                              <li>
                                 <p>自定义SQL测试的有效性</p>
                              </li>
                              <li>
                                 <p>请求边界生效，并且没有请求处于活动状态</p>
                              </li>
                              <li>
                                 <p>请求边界生效，当前请求已结束</p>
                              </li>
                              <li>
                                 <p>会话具有一个或多个可恢复的会话状态，并且可以在故障转移时重新创建</p>
                              </li>
                           </ul>
                           <div class="infoboxnote" id="GUID-2DD974C8-94C2-446B-B2BD-81B8135A26C3__GUID-95A4977F-FE60-4F16-92EF-CE4C119FF7CC">
                              <p class="notep1">注意：</p>要从Oracle Database 18c开始排除连接，请参阅<span class="q">“ <a href="ensuring-application-continuity.html#GUID-2DD974C8-94C2-446B-B2BD-81B8135A26C3__ADDINGDISABLINGENABLINGANDREMOVINGC-39545C9C">添加，禁用，启用和删除连接测试以在服务器中排空</a> ”</span> 。
                           </div>
                        </div>
                        <p>例如，在连接测试的情况下，应用程序服务器，池化应用程序，作业调度程序等的标准做法是在从连接池借用，返回池时以及批量提交时测试连接。在耗尽时，数据库拦截连接测试，关闭连接并返回测试的失败状态。发出连接测试的应用层准备好处理失败的返回状态，并且通常发出进一步的请求，以获得不同的连接。该应用程序没有受到干扰。</p>
                        <p>并非所有会话都可以耗尽，例如未将连接返回到池或未使用FAN时。如果启用了透明应用程序连续性或应用程序连续性，则服务器会检测应用程序连续性可以快速恢复会话的请求边界。服务器可以中断会话，应用程序连续性会在其他位置（例如，Oracle RAC集群中的另一台服务器）恢复，而不会中断。</p>
                        <p>对于不耗尽的数据库会话，数据库必须在可以替换会话时找到断点。在断点处，当状态已知且可恢复时，连接可以透明地进行故障转移。断点可以是事务边界，请求启动（beginRequest），在该请求中执行调用之前，以及模式，例如发出请求开始或结束的审计调用。只有当已知状态可恢复时，断点才适用。</p>
                        <div class="p">故障转移连接要求您启用应用程序连续性，透明应用程序连续性或透明应用程序故障转移（TAF），具体取决于您的应用程序。
                           <div class="infoboxnote" id="GUID-2DD974C8-94C2-446B-B2BD-81B8135A26C3__GUID-F5B0CE01-AB63-47F6-B1F0-D08CCCD9889C">
                              <p class="notep1">注意：</p>Oracle建议您使用Oracle连接池（如UCP或OCI会话池），因为这些连接池在提供连续可用性，负载平衡等方面具有显着优势。
                           </div>
                        </div>
                     </div>
                     <!-- class="section" -->
                     <div class="section" id="GUID-2DD974C8-94C2-446B-B2BD-81B8135A26C3__ADDINGDISABLINGENABLINGANDREMOVINGC-39545C9C">
                        <p class="subhead3" id="GUID-2DD974C8-94C2-446B-B2BD-81B8135A26C3__GUID-9CD32259-7682-4A61-941A-C3AE132FB8C0">添加，禁用，启用和删除连接测试以在服务器上排空</p>
                        <p>您可以将SQL连接测试添加到服务，可插拔数据库或非容器数据库。</p>
                        <div class="p">默认情况下，为每个数据库服务和可插入数据库服务添加了四个SQL连接测试，因此，如果应用程序在连接上使用以下SQL连接测试，则不需要添加它们：<pre class="pre codeblock"><code>SELECT 1 FROM DUAL; SELECT COUNT（*）FROM DUAL;选择1; BEGIN NULL; END;</code></pre></div>
                        <div class="p">
                           <ul style="list-style-type:disc">
                              <li>
                                 <div class="p">要为服务添加服务器端SQL连接测试，请使用类似于以下内容的SQL语句：<pre class="pre codeblock"><code>SQL&gt; execute dbms_app_cont_admin.add_sql_connection_test（'select double from double'，'sw_orcl'）;</code></pre></div>
                                 <div class="p">要为可插拔数据库或非容器数据库添加服务器端SQL连接测试，请登录到非容器数据库并使用类似于以下内容的SQL语句：<pre class="pre codeblock"><code>SQL&gt; execute dbms_app_cont_admin.add_sql_connection_test（'begin null; end;'）;</code></pre></div>
                                 <p>添加SQL连接测试后，默认情况下将启用它。</p>
                              </li>
                              <li>
                                 <div class="p">如果您不需要SQL连接测试，或者通过登录到可插拔数据库或非容器数据库并使用类似于以下内容的SQL语句，则可以禁用SQL连接测试：<pre class="pre codeblock"><code>SQL&gt; execute dbms_app_cont_admin.disable_connection_test（dbms_app_cont_admin.sql_test，'select dummy from dual'）;</code></pre></div>
                                 <p>默认情况下，ping测试和结束请求测试被禁用，但是如果要在启用它们后禁用它们，则可以使用以下任一SQL语句：</p>
                                 <div class="p">如果要禁用ping测试，请使用类似于以下内容的SQL语句：<pre class="pre codeblock"><code>SQL&gt; execute dbms_app_cont_admin.disable_connection_test（dbms_app_cont_admin.ping_test）;</code></pre></div>
                                 <div class="p">如果要禁用结束请求测试，请使用类似于以下内容的SQL语句：<pre class="pre codeblock"><code>SQL&gt; execute dbms_app_cont_admin.disable_connection_test（dbms_app_cont_admin.endrequest_test）;</code></pre></div>
                              </li>
                              <li>
                                 <div class="p">通过登录到可插拔数据库或非容器数据库并使用类似于以下内容的SQL语句禁用它后，可以启用SQL连接测试：<pre class="pre codeblock"><code>SQL&gt; execute dbms_app_cont_admin.enable_connection_test（dbms_app_cont_admin.sql_test，'select dummy from dual'）;</code></pre></div>
                                 <p>如果使用以下任一SQL语句禁用ping测试和结束请求测试，也可以启用它们：</p>
                                 <div class="p">如果要运行任何使用ping的测试，例如<code class="codeph">isValid</code> ， <code class="codeph">isUsable</code> ， <code class="codeph">OCIping</code>或<code class="codeph">connection.status</code> ，请使用类似于以下内容的SQL语句：<pre class="pre codeblock"><code>SQL&gt; execute dbms_app_cont_admin.enable_connection_test（dbms_app_cont_admin.ping_test）;</code></pre></div>
                                 <div class="p">如果要在请求结束时启用耗尽，请使用类似于以下内容的SQL语句：<pre class="pre codeblock"><code>SQL&gt; execute dbms_app_cont_admin.enable_connection_test（dbms_app_cont_admin.endrequest_test）;</code></pre></div>
                                 <div class="p">如果要在请求结束时禁用耗尽，请使用类似于以下内容的SQL语句：<pre class="pre codeblock"><code>SQL&gt; execute dbms_app_cont_admin.disable_connection_test（dbms_app_cont_admin.endrequest_test）;</code></pre></div>
                              </li>
                              <li>
                                 <div class="p">如果不需要，可以通过登录到可插拔数据库或非容器数据库并运行类似于以下内容的SQL语句来删除SQL连接测试：<pre class="pre codeblock"><code>SQL&gt; execute dbms_app_cont_admin.delete_sql_connection_test（'select'from dual'，'sw_orcl'）; SQL&gt; execute dbms_app_cont_admin.delete_sql_connection_test（'begin null; end;'）;</code></pre></div>
                              </li>
                           </ul>
                        </div>
                        <p>每个应用程序服务器都有一个功能，用于测试各自连接池中连接的有效性，这些连接池由配置属性或管理控制台设置。测试的目的是防止出现与应用程序的不可用连接，并且当检测到不可用的连接时，将其释放到池中时将其删除。</p>
                        <p>在各种应用程序服务器上，测试具有相似的名称。提供的测试使用各种方法，最常见的是SQL语句。Oracle建议Java应用程序服务器使用标准Java调用<code class="codeph">connection.isValid</code> 。从Oracle Database 18c开始，这些测试用于排空数据库。同样从Oracle Database 18c开始，数据库通过检查会话以获取安全排放点而不使用FAN来排空会话。
                        </p>
                        <p>下表描述了几种更常见的应用程序服务器可用的标准连接测试：</p>
                        <div class="tblformal" id="GUID-2DD974C8-94C2-446B-B2BD-81B8135A26C3__GUID-4ABEA3DB-9D80-4AEE-81FE-BCD95235E2FB">
                           <p class="titleintable">表6-3某些常见应用程序服务器的标准连接测试</p>
                           <table cellpadding="4" cellspacing="0" class="Formal" title="一些常见应用程序服务器的标准连接测试" border="1" summary="Describes several common application servers and their associated connection tests to a database." frame="hsides" rules="rows">
                              <thead>
                                 <tr align="left" valign="top">
                                    <th align="left" valign="bottom" width="20%" id="d23610e3779">Application Server</th>
                                    <th align="left" valign="bottom" width="20%" id="d23610e3781">连接测试到数据库</th>
                                 </tr>
                              </thead>
                              <tbody>
                                 <tr align="left" valign="top">
                                    <td align="left" valign="top" width="20%" id="d23610e3785" headers="d23610e3779 ">
                                       <p>Oracle WebLogic Server</p>
                                    </td>
                                    <td align="left" valign="top" width="20%" headers="d23610e3785 d23610e3781 ">
                                       <div class="p">提供的测试包括：<ul style="list-style-type:disc">
                                             <li>
                                                <div class="p"><pre class="pre codeblock"><code>dbms_app_cont_admin.enable_connection_test（dbms_app_cont_admin.sql_test，'从双选'1）;</code></pre></div>
                                             </li>
                                             <li>
                                                <p><code class="codeph">TestConnectionsonReserve</code> ：</p>
                                                <p><code class="codeph">isUsable</code> ， <code class="codeph">isValid</code>或<code class="codeph">PingDatabase</code></p>
                                             </li>
                                             <li>
                                                <p>用于服务器耗尽的<code class="codeph">TestConnectionsOnCreate</code> （SQL语法）：</p><pre class="pre codeblock"><code>从双重中选择1;</code></pre></li>
                                          </ul>
                                       </div>
                                    </td>
                                 </tr>
                                 <tr align="left" valign="top">
                                    <td align="left" valign="top" width="20%" id="d23610e3818" headers="d23610e3779 ">
                                       <p>Oracle WebLogic Server Active Gridlink</p>
                                    </td>
                                    <td align="left" valign="top" width="20%" headers="d23610e3818 d23610e3781 ">
                                       <div class="p">嵌入测试：<pre class="pre codeblock"><code>isUsable</code></pre></div>
                                    </td>
                                 </tr>
                                 <tr align="left" valign="top">
                                    <td align="left" valign="top" width="20%" id="d23610e3827" headers="d23610e3779 ">
                                       <p>IBM WebSphere</p>
                                    </td>
                                    <td align="left" valign="top" width="20%" headers="d23610e3827 d23610e3781 "><pre class="pre codeblock"><code>dbms_app_cont_admin.enable_connection_test（dbms_app_cont.sql_test，'从双选'1）;</code></pre><p>服务器耗尽的预测试连接（SQL语法）：</p><pre class="pre codeblock"><code>从双重中选择1;</code></pre></td>
                                 </tr>
                                 <tr align="left" valign="top">
                                    <td align="left" valign="top" width="20%" id="d23610e3838" headers="d23610e3779 ">
                                       <p>RedHat JBoss</p>
                                    </td>
                                    <td align="left" valign="top" width="20%" headers="d23610e3838 d23610e3781 ">
                                       <div class="p"><code class="codeph">check-valid-connection-sql</code> （SQL语法）：<pre class="pre codeblock"><code>dbms_session.enable_connection_test（dbms_session.sql_test，'select one from dual'）;</code></pre></div>
                                    </td>
                                 </tr>
                                 <tr align="left" valign="top">
                                    <td align="left" valign="top" width="20%" id="d23610e3849" headers="d23610e3779 ">
                                       <p>Apache Tomcat</p>
                                    </td>
                                    <td align="left" valign="top" width="20%" headers="d23610e3849 d23610e3781 ">
                                       <div class="p">有两个测试可用 - <code class="codeph">testOnBorrow</code>和<code class="codeph">testOnReturn</code> - 它们都使用SQL语法来测试与数据库的连接：<pre class="pre codeblock"><code>dbms_app_cont.enable_connection_test（dbms_app_cont.sql_test，'从双选'1）;</code></pre></div>
                                       <div class="p">应用服务器使用：<pre class="pre codeblock"><code>从双重中选择1;</code></pre></div>
                                    </td>
                                 </tr>
                              </tbody>
                           </table>
                        </div>
                        <!-- class="inftblhruleinformal" -->
                        <p>Oracle建议您使用以下格式来支持Oracle Notification Services（ONS）的自动配置，以便您可以接收FAN事件（通过ONS）：</p>
                     </div>
                     <!-- class="section" -->
                     <div class="example" id="GUID-2DD974C8-94C2-446B-B2BD-81B8135A26C3__AUTOMATICCONFIGURATIONOFFAN-309F5DDA">
                        <p class="titleinexample">例6-1 FAN的自动配置</p><pre class="pre codeblock"><code>alias =（DESCRIPTION =（CONNECT_TIMEOUT = 90）（RETRY_COUNT = 20）（RETRY_DELAY = 3）（TRANSPORT_CONNECT_TIMEOUT = 3）（ADDRESS_LIST =（LOAD_BALANCE = on）（ADDRESS =（PROTOCOL = TCP）（HOST =主扫描）（PORT） = 1521）））（ADDRESS_LIST =（LOAD_BALANCE = on）（ADDRESS =（PROTOCOL = TCP）（HOST =二次扫描）（PORT = 1521）））（CONNECT_DATA =（SERVICE_NAME = gold-cloud）））</code></pre></div>
                     <!-- class="example" -->
                  </div>
                  <div>
                     <div class="relinfo">
                        <p><strong>相关话题</strong></p>
                        <ul>
                           <li><a href="ensuring-application-continuity.html#GUID-DA6B6272-C420-4A1F-BB5F-E9A81A5469D8" title="Oracle建议您在启用FAN的Oracle或非Oracle连接池的受控时间段内从实例中排出数据库会话，或者从数据库中的Oracle Database 18c本身开始。">在没有用户中断的情况下管理计划维护</a></li>
                           <li><a href="ensuring-application-continuity.html#GUID-B2895452-68A1-45E5-A9A7-1888B7B10481" title="当计划内维护和计划外中断数据库透明时，应用程序可实现持续可用性。">透明的应用程序连续性</a></li>
                        </ul>
                     </div>
                  </div>
                  
               </div>
            </div><a id="ADFNS367"></a><a id="ADFNS1105"></a><div class="sect2"><a id="GUID-BD699AEB-9F85-42A8-8687-5A979918938D" name="GUID-BD699AEB-9F85-42A8-8687-5A979918938D"></a><h3 id="RACAD-GUID-BD699AEB-9F85-42A8-8687-5A979918938D" class="sect3">关于应用程序连续性</h3>
               <div>
                  <p>应用程序连续性通过还原数据库会话从应用程序和用户屏蔽许多可恢复的数据库中断（当重放成功时）：完整会话，包括所有状态，游标，变量和最后一个事务（如果有）。</p>
                  <p>应用程序连续性解决了应用程序尝试访问数据库时出现的问题，并且数据库实例由于计划外或计划中断（超时，网络中断，实例故障，修复，配置更改，修补程序应用等）而变得不可用。如果没有应用程序连续性，数据库恢复不会屏蔽应用程序和最终用户的中断。在这种情况下，开发人员和用户必须应对异常情况，并且用户可能不知道他们的资金转移，时间表，订单，账单支付等发生了什么。用户可能会丢失未提交数据的屏幕，并且必须再次登录并重新输入该数据。在最糟糕的情况下，管理员可能会被迫重新启动中间层以从绝大多数登录中恢复。</p>
                  <p>使用Application Continuity，如果数据库实例变得不可用，则Application Continuity尝试使用正确的状态重建会话和任何打开的事务;如果事务已提交且无需重新提交，则成功返回状态将返回给应用程序。如果重播成功，则请求可以安全地继续，而没有重复的风险。如果重播无法恢复应用程序已处理并可能做出决策的数据，则数据库拒绝重放，应用程序将收到原始错误。</p>
                  <p>Application Continuity执行正在进行的事务和数据库会话状态的恢复，同时确保Transaction Guard提供的事务幂等性。每个数据库会话都标记有逻辑事务ID（LTXID），因此数据库会识别每个重放是否已提交任何事务，如果它确实提交了任何事务，则工作是否也会运行完成。当Application Continuity尝试重放时，重放在应用程序中显示为延迟执行，或者应用程序接收原始事务的提交响应（如果最后一个事务在中断之前完成）。</p>
                  <p>Oracle RAC和Oracle Active Data Guard支持应用程序连续性。非统一数据库和Multitenant数据库都支持它（在可插拔数据库级别进行故障转移）。如果使用Oracle Active Data Guard，目前不支持Golden Gate，Logical Standby，第三方复制解决方案或DML重定向。</p>
               </div>
               <div>
                  <div class="relinfo">
                     <p><strong>相关话题</strong></p>
                     <ul>
                        <li><a href="ensuring-application-continuity.html#GUID-815F5DF2-6B6E-4E5B-922D-6FCAA4A0AD81">使用应用程序连续性的操作</a></li>
                     </ul>
                  </div>
               </div><a id="ADFNS386"></a><a id="ADFNS394"></a><a id="ADFNS395"></a><a id="ADFNS1072"></a><a id="ADFNS1087"></a><a id="ADFNS368"></a><div class="sect3"><a id="GUID-1BEE7C6A-8F21-47A1-8449-20E155ECBA02" name="GUID-1BEE7C6A-8F21-47A1-8449-20E155ECBA02"></a><h4 id="RACAD-GUID-1BEE7C6A-8F21-47A1-8449-20E155ECBA02" class="sect4">应用程序连续性的关键概念</h4>
                  <div>
                     <p>本节介绍使用应用程序连续性时必须了解的几个术语和概念。</p>
                     <p>本章中使用以下术语：</p>
                     <div class="section">
                        <p class="subhead3" id="GUID-1BEE7C6A-8F21-47A1-8449-20E155ECBA02__GUID-2AE51DC2-5EA7-406B-A5E0-099C2FB8634D">数据库请求</p>
                     </div>
                     <!-- class="section" -->
                     <p>数据库请求是从应用程序提交到数据库的工作单元，例如事务。请求通常对应于单个数据库连接上的单个Web请求的SQL和PL / SQL以及其他数据库调用，并且通常由签出和签入数据库连接的调用划分。连接池。</p>
                     <div class="section">
                        <p class="subhead3" id="GUID-1BEE7C6A-8F21-47A1-8449-20E155ECBA02__GUID-14412F7B-39A0-4F57-98BB-E351852F463E">可恢复的错误</p>
                     </div>
                     <!-- class="section" -->
                     <p>可恢复错误是由于外部系统故障而产生的错误，与正在执行的应用程序会话逻辑无关，例如连接丢失或无效。在前台，网络，节点，存储和数据库的计划内和计划外中断之后发生可恢复的错误。应用程序收到错误代码，该错误代码可能使应用程序不知道上次提交的操作的状态。应用程序连续性重新建立数据库会话，并重新提交可恢复错误类的待处理工作。</p>
                     <p>由于不可恢复的错误导致呼叫失败后，应用程序连续性不会重新提交工作。<span class="italic">不会</span>重放的不可恢复错误的示例是提交无效数据值。
                     </p>
                     <div class="section">
                        <p class="subhead3" id="GUID-1BEE7C6A-8F21-47A1-8449-20E155ECBA02__GUID-1D06B1CA-F9C7-4F95-8914-2AE22DC8EBC3">承诺结果</p>
                     </div>
                     <!-- class="section" -->
                     <p>通过更新事务表中的条目来提交事务。Oracle数据库生成与此更新对应的重做日志记录，并写出此重做日志记录。将此重做日志记录写入磁盘上的重做日志后，该事务将被视为在数据库中提交。从客户端的角度来看，当客户端收到在写入重做之后生成的Oracle消息（称为<span class="italic">提交结果</span> ）时，将认为事务已<span class="italic">提交</span> 。但是，如果已发出<code class="codeph">COMMIT</code> ，则如果客户端或应用程序未收到<code class="codeph">COMMIT</code>失败消息，则无法检索该消息。
                     </p>
                     <div class="section">
                        <p class="subhead3" id="GUID-1BEE7C6A-8F21-47A1-8449-20E155ECBA02__GUID-087DD9E8-FD26-4986-A5B8-A2930279277A">可变功能</p>
                     </div>
                     <!-- class="section" -->
                     <p>可变函数是非确定性函数，每次调用它们都可以获得新值，因此它们的结果可能会频繁变化。可变函数会导致重放问题，因为结果可能会在重放时发生变化。考虑<span class="italic">序列</span> <code class="codeph">.NEXTVAL</code>和<code class="codeph">SYSDATE</code> ，通常用于键值。如果主键是使用来自这些函数调用的值构建的，并且在以后的外键或其他绑定中使用，则在重放时必须返回相同的函数结果。
                     </p>
                     <p>Application Continuity在重放时提供可变对象值替换，以授予Oracle函数调用以提供不透明的绑定变量一致性。如果调用使用可变的数据库函数，包括<span class="italic">序列</span> <code class="codeph">.NEXTVAL</code> ， <code class="codeph">SYSDATE</code> ， <code class="codeph">SYSTIMESTAMP</code>和<code class="codeph">SYSGUID</code> ，保存从函数执行返回的原始值，并在重放时重新应用。
                     </p>
                     <div class="section">
                        <p class="subhead3" id="GUID-1BEE7C6A-8F21-47A1-8449-20E155ECBA02__GUID-2D99E158-84E7-4E72-ACA1-4AFED2BAE744">会话状态一致性</p>
                     </div>
                     <!-- class="section" -->
                     <p>执行<code class="codeph">COMMIT</code>语句后，如果该事务中的状态已更改，则无法重播事务以在会话丢失时重新建立该状态。配置应用程序连续性时，应用程序的分类取决于初始设置后的会话状态是静态还是动态（或使用<code class="codeph">AUTO</code>因此决策是自动的），因此在请求中继续通过<code class="codeph">COMMIT</code>操作是否正确。</p>
                     <ul style="list-style-type:disc">
                        <li>
                           <p>如果会话状态更改未通过初始化完全封装，则会话具有<span class="bold">动态</span>状态，并且FAILOVER_RESTORE或故障转移时的回调无法完全捕获会话状态。第一个事务完成后，将在内部禁用故障转移，直到下一个请求开始。会话状态可能在请求过程中发生变化。</p>
                        </li>
                        <li>
                           <p>如果所有会话状态更改（例如，NLS设置和PL / SQL包状态）作为初始化的一部分发生，则会话具有<span class="bold">静态</span> ，并且可以由<code class="codeph">FAILOVER_RESTORE</code>封装或在故障转移时的回调中封装。静态应用程序是那些能够在应用程序连续性之前使用透明应用程序故障转移（TAF）的应用程序。会话状态在请求过程中不会更改。 （如果可能，选择将会话状态一致性设置为<code class="codeph">AUTO</code> over <code class="codeph">STATIC</code>模式，因为自动模式比应用前连续性TAF模式更有效地清除和清除。）
                           </p>
                        </li>
                        <li>
                           <p>通过透明应用程序连续性，可以通过将会话状态一致性设置为<code class="codeph">AUTO</code>来管理状态（这是透明应用程序连续性的强制设置）。在故障转移时跟踪和验证这些会话状态。如果超出预设状态，您可以添加更多状态。
                           </p>
                        </li>
                     </ul>
                  </div>
               </div>
               <div class="sect3"><a id="GUID-B2895452-68A1-45E5-A9A7-1888B7B10481" name="GUID-B2895452-68A1-45E5-A9A7-1888B7B10481"></a><h4 id="RACAD-GUID-B2895452-68A1-45E5-A9A7-1888B7B10481" class="sect4">透明的应用程序连续性</h4>
                  <div>
                     <p>当计划内维护和计划外中断数据库透明时，应用程序可实现持续可用性。</p>
                     <p>透明应用程序连续性是应用程序连续性的一种功能模式，从Oracle RAC 18c开始，透明地跟踪和记录会话和事务状态，以便在可恢复的中断后恢复数据库会话。这是安全的，并且DBA无需了解应用程序或更改应用程序代码。透明度是通过使用状态跟踪基础结构来实现的，该基础结构将会话状态使用分类为应用程序发出用户调用。</p>
                     <p>您可以启用透明应用程序连续性作为默认设置，以在计划维护期间和发生意外中断时保护应用程序。对于计划维护，到达安全位置的数据库会话（例如连接测试或已知的可恢复点）将在数据库中耗尽。对于不耗尽的数据库会话，数据库确定数据库会话失败的位置，并调用Application Continuity来执行此操作。Application Continuity使用通用连接池隐藏基于Java的应用程序，OCI和ODP.NET应用程序（包括SQL * Plus，所有Oracle连接池，Tuxedo，WebLogic Server和第三方应用程序服务器）的计划外中断。</p>
                     <div class="p">通过透明的应用程序连续性，DBA不再需要了解应用程序以便：<ul style="list-style-type:disc">
                           <li>
                              <p>恢复预设状态</p>
                              <p>在运行时，透明应用程序连续性记录初始预设会话状态，监视其他状态，并记录足以检测受监视状态的故障转移时会话状态偏差的会话签名。在故障转移时，透明应用程序连续性会在重播开始之前恢复预设的会话状态，并在重放开始之前验证这些会话状态是否与原始状态完全匹配。这还允许使用应用程序连续性和其他机制（例如登录触发器，标签和连接回调）恢复的会话状态。如果状态超出预设状态，您将继续添加登录触发器，回叫或标签。</p>
                           </li>
                           <li>
                              <p>恢复会话时识别并禁用应用程序级别的副作用</p>
                              <p>在正常运行时，透明应用程序连续性检测副作用。副作用的类型区分在与应用程序的逻辑相关的那些和与数据库内务相关的内部的副作用之间。对于使用具有副作用的语句的应用程序，在语句运行时禁用捕获。新请求启动后，将自动重新启用捕获。</p>
                           </li>
                           <li>
                              <p>保留自有函数的可变值</p>
                              <p>可变函数是每次运行时都可以返回新值的函数。Oracle支持保留可变函数<code class="codeph">SYSDATE</code> ， <code class="codeph">SYSTIMESTAMP</code> ， <code class="codeph">SYS_GUID</code>和<code class="codeph">sequence.的原始结果<code class="codeph">sequence.NEXTVAL</code> 。如果未保留原始值，并且在重放时将不同的值返回给应用程序，则透明应用程序连续性拒绝重放。使用拨款来保存您的序列，日期和时间。当应用程序使用自己的架构时，您可以分配用于保留角色的授权，然后将此角色授予用户。
                              </p>
                           </li>
                           <li>
                              <p>对于使用带有JDBC瘦驱动程序的应用程序连续性（从Oracle数据库18c开始）和OCI和ODP.NET非托管提供程序（从Oracle Database 19c（19.3）开始）的应用程序，DBA不需要了解请求边界，而是在使用它们时，透明应用程序连续性利用它们。最佳做法是使用请求边界，因为并不总是能够识别可以插入请求边界的检查点。</p>
                              <p>Request Boundaries demark应用程序和应用程序服务器从其连接池借用和返回连接的位置。在没有请求边界的Oracle RAC 18c之前，较低层（例如数据库和驱动程序）无法了解应用程序和应用程序服务器如何管理其连接。几乎每个应用程序服务器和企业应用程序以及使用良好实践的自定义开发都会将其连接缓存在其层中以获得最佳性能。较低层无法看到如何处理和平衡连接。较低层只能看到用户对数据库的调用。</p>
                              <p>使用透明应用程序连续性，服务器和驱动程序正在跟踪事务和会话状态使用情况。这允许驱动程序检测并注入可能的请求边界。在可能的请求边界，没有对象打开，游标返回到驱动程序语句高速缓存，没有事务打开，并且已知会话状态是可恢复的。驱动程序要么关闭当前捕获并启动新捕获，要么在发生禁用事件时启用捕获。在下一次调用服务器时，服务器会验证并在适用的情况下创建一个请求边界，此时之前没有明确的边界。</p>
                           </li>
                        </ul>
                     </div>
                     <p>当您使用透明应用程序连续性Java（从Oracle数据库18c开始）和OCI和ODP.NET非托管提供程序（从Oracle Database 19c（19.3）开始）时，您的应用程序将体验到更低的资源使用和更快的恢复，因为这些语句没有贡献不记录状态，或者在不再需要时清除状态，并自动提前请求边界。</p>
                     <p>对于计划外中断，将针对导致可恢复错误的中断调用透明应用程序连续性，通常与底层软件，前台，硬件，通信，网络或存储层相关，从而隐藏应用程序和用户的大多数故障。</p>
                     <p><code class="codeph">FAILOVER_TYPE=AUTO</code>时启用透明应用程序连续性。</p>
                  </div>
                  <div class="sect4"><a id="GUID-6A1F70F3-9C40-4613-B4CB-577DD72092A9" name="GUID-6A1F70F3-9C40-4613-B4CB-577DD72092A9"></a><h5 id="RACAD-GUID-6A1F70F3-9C40-4613-B4CB-577DD72092A9" class="sect5">适用于各种应用的透明应用连续性</h5>
                     <div>
                        <p>透明应用程序连续性涵盖属于三个不同组的应用程序，由状态跟踪系统自动跟踪。</p>
                        <div class="p">各种应用程序具有以下类型：<ul style="list-style-type:disc">
                              <li>
                                 <p><span class="bold">请求边界</span> ：使用具有请求边界的容器的应用程序允许应用程序连续性管理显式边界之间的重放。
                                 </p>
                              </li>
                              <li>
                                 <p><span class="bold">数据库不可知</span> ：应用程序在连接建立时设置状态，不再次更改非事务性会话状态，或者很少更改它。对于这些应用程序，Application Continuity标识隐式边界。
                                 </p>
                              </li>
                              <li>
                                 <div class="p"><span class="bold">黑匣子</span> ：在运行时使用Oracle专有状态，更改状态或两者的应用程序。此类别进一步划分：<ul style="list-style-type:disc">
                                       <li>
                                          <p>短用户调用的应用程序，例如没有可见边界的OLTP</p>
                                       </li>
                                       <li>
                                          <p>具有长用户呼叫的应用程序，例如DSS，报告和仓库</p>
                                       </li>
                                    </ul>
                                 </div>
                              </li>
                           </ul>
                        </div>
                        <div class="section">
                           <p class="subhead3" id="GUID-6A1F70F3-9C40-4613-B4CB-577DD72092A9__GUID-501793CC-7D00-46C3-9B03-3BF97924A148">请求边界</p>
                           <p><a href="glossary.html#GUID-0ECAE9D3-2AFB-4E8F-BFF2-7E402E8E576A"><span class="xrefglossterm">请求边界</span></a>是标记数据库请求开始和结束的标记。从Oracle Database 12 <span class="italic">c第</span> 2版（12.2.0.1）开始，嵌入请求边界的连接池包括Oracle Universal Connection Pool，所有WebLogic服务器数据源，Tuxedo，Oracle Call Interface，ODP.NET Unmanaged Provider和标准第三方应用程序除了SQL * PLUS之外，使用Oracle Database 12 <span class="italic">c</span> JDBC驱动程序的<code class="codeph">PooledConnection</code>接口的服务器和独立Java池。</p>
                           <div class="p">当Oracle数据库知道请求边界时：<ul style="list-style-type:disc">
                                 <li>
                                    <p>数据库可以有效地处理Web请求，而不会产生任何性能开销，包括何时连接和释放连接，因此它可以复用，排空，重新平衡，脱离并允许请求内的复杂状态。没有请求边界，数据库的较低层不知道Web请求。随后，数据库依赖于Oracle客户端操作，咨询方法和启发式方法，例如快速连接故障转移，连接验证和状态建议。</p>
                                 </li>
                                 <li>
                                    <p>重播的长度仅限于初始状态，后面是该请求中的用户调用减去Application Continuity清除的那些。请求边界是控制重放长度的重要提示，也是计划维护（在请求结束时）流失的位置，以及计划维护的故障转移位置（在请求开始时）。</p>
                                 </li>
                                 <li>
                                    <p>使用Transparent Application Continuity for Java时，只需要第一个请求边界（仅适用于Oracle Database 18c）。</p>
                                 </li>
                                 <li>
                                    <p>使用Application Continuity for Java时，重播驱动程序会检测安全位置以自动向前移动请求边界。此功能仅适用于AUTO。</p>
                                 </li>
                                 <li>
                                    <p>使用设置请求边界的中间层容器部署的应用程序可以访问数据库服务器提供的全套透明功能。数据库检测客户端何时设置请求边界并使用边界标记排水，故障转移，浓度和吞吐量度量的安全点。</p>
                                 </li>
                              </ul>
                           </div>
                           <p>请求边界使应用程序能够使用请求中的所有复杂的非事务性会话状态。请求边界规范要求这些状态不依赖于边界。</p>
                        </div>
                        <!-- class="section" -->
                        <div class="section">
                           <p class="subhead3" id="GUID-6A1F70F3-9C40-4613-B4CB-577DD72092A9__GUID-39FCE964-8A33-4A42-B890-A5FE9FF1F4E7">与数据库无关的应用程序</p>
                           <p>与数据库无关的应用程序（没有请求边界的应用程序）设置简单的非事务状态，并且不使用任何Oracle专有功能或序列。这些应用程序通常在创建连接时设置状态一次，然后不再更改状态或不经常更改状态。此类应用程序包括那些使用不创建服务器端会话状态的匿名PL / SQL的应用程序。</p>
                           <p>对JDBC应用程序使用透明应用程序连续性时，状态分类用于查找在身份验证后启用和开始记录应用程序连续性的点，并在禁用事件禁用捕获后重新启用记录。只需要第一个请求边界，并且当存在请求边界时，使用它们。SQL * Plus不需要请求边界，它们是为ODP.NET，OCI会话池，Tuxedo和Oracle Universal Connection Pool嵌入的。</p>
                        </div>
                        <!-- class="section" -->
                     </div>
                  </div>
               </div>
            </div><a id="ADFNS356"></a><a id="ADFNS314"></a><div class="sect2"><a id="GUID-91427DA2-2C5F-46E9-93D4-B5FF6427A69B" name="GUID-91427DA2-2C5F-46E9-93D4-B5FF6427A69B"></a><h3 id="RACAD-GUID-91427DA2-2C5F-46E9-93D4-B5FF6427A69B" class="sect3">应用程序连续性操作和使用</h3>
               <div>
                  <p>本节介绍Application Continuity的工作原理，以及如何在应用程序中使用它。</p>
                  <p>本节包括以下主题：</p>
                  <ul style="list-style-type:disc">
                     <li>
                        <p><a href="ensuring-application-continuity.html#GUID-70D9CDC4-0C86-432B-A04E-1618AF5C35A4" title="如果发生可恢复的错误并且您启用了重播，则Application Continuity会尝试恢复数据库会话。">应用程序连续性如何适用于应用程序</a></p>
                     </li>
                     <li>
                        <p><a href="ensuring-application-continuity.html#GUID-815F5DF2-6B6E-4E5B-922D-6FCAA4A0AD81" title="使用Oracle集成堆栈时，应用程序连续性会屏蔽中断，很少或不会更改应用程序。">使用应用程序连续性的操作</a></p>
                     </li>
                     <li>
                        <p><a href="ensuring-application-continuity.html#GUID-E4A114A2-EA77-4037-A62A-BDFCF1E6D072" title="重放请求时，可变对象的默认和期望处理可能会有所不同。">可变功能和应用连续性</a></p>
                     </li>
                     <li>
                        <p><a href="ensuring-application-continuity.html#GUID-3EADEA74-3224-48B5-9376-ABE3B34429B0" title="要管理可变值，您需要授予某些特权。">管理可变值</a></p>
                     </li>
                     <li>
                        <p><a href="ensuring-application-continuity.html#GUID-987F5EE6-6C32-455A-AEF6-16066EE33F20" title="使用请求边界和保护级别的统计信息来监控覆盖级别。">保护级统计</a></p>
                     </li>
                     <li>
                        <p><a href="ensuring-application-continuity.html#GUID-D49C131A-5931-473E-A878-AF4B99E97F1D" title="会话状态一致性描述了在请求期间如何更改非事务状态。">会话状态一致性</a></p>
                     </li>
                  </ul>
               </div><a id="ADFNS1319"></a><a id="ADFNS1201"></a><div class="sect3"><a id="GUID-70D9CDC4-0C86-432B-A04E-1618AF5C35A4" name="GUID-70D9CDC4-0C86-432B-A04E-1618AF5C35A4"></a><h4 id="RACAD-GUID-70D9CDC4-0C86-432B-A04E-1618AF5C35A4" class="sect4">应用程序连续性如何适用于应用程序</h4>
                  <div>
                     <p>如果发生可恢复的错误并且您启用了重播，则Application Continuity会尝试恢复数据库会话。</p>
                     <p>下图是Application Continuity如何工作的图形表示。</p>
                     <div class="figure" id="GUID-70D9CDC4-0C86-432B-A04E-1618AF5C35A4__GUID-527F8D8A-F9F1-4798-9F1B-D49D7DE91105">
                        <p class="titleinfigure">图6-1应用程序连续性</p><img src="img/racad_040c.png" alt="下面是图6-1的描述" title="下面是图6-1的描述" longdesc="img_text/racad_040c.html"><br><a href="img_text/racad_040c.html">“图6-1应用连续性”的描述</a></div>
                     <!-- class="figure" -->
                     <div class="p">要尝试在发生可恢复的错误后恢复数据库会话，Application Continuity将执行以下步骤：<div class="infoboxnote" id="GUID-70D9CDC4-0C86-432B-A04E-1618AF5C35A4__GUID-4FA896D0-B444-4AE4-8352-53FD519F34FD">
                           <p class="notep1">注意：</p>恢复数据库会话的步骤适用于计划外和计划中断，但具体步骤因中断类型而异。
                        </div>
                     </div>
                     <ol>
                        <li>
                           <p>客户端应用程序发出请求，使用UCP将其传递到中间层（例如通用连接池（UCP），ODP.NET，WebLogic Server，OCI会话池，Tuxedo，JDBC和OCI驱动程序或第三方池），或使用JDBC重放驱动程序或OCI驱动程序直接访问数据库。</p>
                        </li>
                        <li>
                           <p>JDBC重放驱动程序或OCI驱动程序在请求中发出每个调用。</p>
                        </li>
                        <li>
                           <p>发生FAN意外计划或计划中断或可恢复错误。然后FAN / FCF中止死亡的物理会话。</p>
                        </li>
                        <li>
                           <p>应用程序连续性开始重播并执行以下操作：</p>
                           <ol type="a">
                              <li>
                                 <p>用新的干净会话替换死的物理会话。</p>
                              </li>
                              <li>
                                 <p>通过使用Transaction Guard准备重播，以确定正在进行的事务的结果（如果已打开）。</p>
                              </li>
                              <li>
                                 <p>如果<code class="codeph">FAILOVER_RESTORE=LEVEL1</code>或<code class="codeph">FAILOVER_TYPE=AUTO</code> ，则应用程序连续性将恢复公共初始会话状态。如果应用程序还设置回调中未由<code class="codeph">FAILOVER_RESTORE</code>提供的会话状态，则应用程序连续性使用标签回调或初始回调</p>
                              </li>
                              <li>
                                 <p>重建数据库会话，恢复事务和非事务状态，并在每个步骤验证客户端驱动程序看到的数据和消息与客户端可能已经看到并用于做出决策的数据和消息相同。</p>
                              </li>
                              <li>
                                 <p>结束重播并返回运行时模式。</p>
                              </li>
                              <li>
                                 <p>提交最后一次排队的电话。</p>
                                 <p>这是发现中断时的最后一次调用。在重放期间，只有此调用才能执行<code class="codeph">COMMIT</code> 。在重建会话中途的<code class="codeph">COMMIT</code>中止重放（不包括自治事务）。
                                 </p>
                              </li>
                           </ol>
                        </li>
                        <li>
                           <p>响应将返回给应用程序。</p>
                           <p>如果重播成功，则应用程序可以继续屏蔽问题。如果没有，那么应用程序必须处理原始错误。</p>
                        </li>
                     </ol>
                     <p>通信失败后应用程序连续性的行为取决于所涉及的Oracle产品和技术。例如：</p>
                     <ul style="list-style-type:disc">
                        <li>
                           <p>如果使用Oracle RAC或Oracle Active Data Guard场，则在另一个正在运行的实例上重新建立连接后，Application Continuity会尝试重建会话并重播最后一个事务（如果有一个正在进行中）。</p>
                        </li>
                        <li>
                           <p>如果您使用Oracle Active Data Guard并故障转移到备用站点，则应用程序连续性将连接到故障转移实例，并尝试重建会话并重播最后一个事务（如果事务正在进行中）。（如果Oracle Active Data Guard切换或故障转移丢失了数据，并且这不是具有已批准滞后的Oracle Active Data Guard读取器场，则应用程序连续性不会重播。）</p>
                        </li>
                        <li>
                           <p>如果您使用的是Oracle RAC或Oracle RAC One Node且未使用Oracle Active Data Guard，并且如果中断导致所有公共网络中断或导致数据库或数据库会话短暂关闭，则Application Continuity会尝试重建会话并且在恢复连接后重放最后一个事务（如果事务处于运行中）对数据库。</p>
                        </li>
                     </ul>
                  </div>
                  <div>
                     <div class="relinfo">
                        <p><strong>相关话题</strong></p>
                        <ul>
                           <li><a href="ensuring-application-continuity.html#GUID-61B6FEC5-90F0-4BE2-AC3B-37ECA6009545" title="对于计划维护，建议的方法是将Oracle连接池的请求与应用程序连续性一起用于那些未完成的请求。确实需要停止实例以切换到已修补的软件。">使用应用程序连续性进行计划维护</a></li>
                        </ul>
                     </div>
                  </div>
               </div><a id="ADFNS188"></a><a id="ADFNS1207"></a><div class="sect3"><a id="GUID-815F5DF2-6B6E-4E5B-922D-6FCAA4A0AD81" name="GUID-815F5DF2-6B6E-4E5B-922D-6FCAA4A0AD81"></a><h4 id="RACAD-GUID-815F5DF2-6B6E-4E5B-922D-6FCAA4A0AD81" class="sect4">使用应用程序连续性的操作</h4>
                  <div>
                     <p>使用Oracle集成堆栈时，应用程序连续性会屏蔽中断，很少或不会更改应用程序。</p>
                     <p>应用程序连续性可通过以下Oracle技术进行常规使用：</p>
                     <ul style="list-style-type:disc">
                        <li>
                           <p>ODP.NET，非托管驱动程序</p>
                        </li>
                        <li>
                           <p>OCI会话池</p>
                        </li>
                        <li>
                           <p>通用连接池</p>
                        </li>
                        <li>
                           <p>WebLogic Server</p>
                        </li>
                        <li>
                           <p>JDBC Thin Oracle重放驱动程序</p>
                        </li>
                        <li>
                           <p>Oracle Tuxedo</p>
                        </li>
                        <li>
                           <p>在SQL * Plus</p>
                        </li>
                        <li>
                           <p>具有通用连接池的第三方JDBC应用程序服务器</p>
                        </li>
                        <li>从Oracle Database 19c开始的具有透明应用程序连续性的基于OCI的应用程序（19.3）</li>
                     </ul>
                     <p>Application Continuity for Java嵌入在通用连接池，WebLogic数据源（包括非XA和XA数据源）中，并且可以与独立的瘦重放驱动程序一起使用（这是一个没有Oracle连接池的JDBC重放驱动程序，例如Apache Tomcat或自定义Java连接池）。OCI的应用程序连续性嵌入在SQL * Plus，OCI会话池中。Oracle Tuxedo用于非XA数据源，以及ODP.NET，非托管提供程序。借助透明应用程序连续性，JDBC应用程序可自动启用Oracle Database 18c，以及从Oracle Database 19c（19.3）开始的OCI应用程序。</p>
                     <p>应用程序连续性嵌入在Oracle连接池中。使用Oracle连接池时，会在签出和签入时隐式标记请求边界，从而界定每次重播的大小。使用第三方连接池时，如果使用Java，则使用UCP，或者可以添加JDK9标准中包含的请求边界。使用Transparent Application Continuity for Java时，只需要第一个请求边界。使用状态跟踪发现请求边界。使用Oracle Database 19c的OCI驱动程序，现在可以支持隐式边界，就像JDBC客户端驱动程序一样。</p>
                     <p>对于应用程序连续性的支持已集成到许多Oracle应用程序中，因此如果您设置与应用程序连续性相关的服务属性，则会自动使用此类应用程序中的功能。对于所有应用程序，请按照本节中描述的步骤操作。</p>
                     <p>确保应用程序透明重放的主要措施如下：</p>
                     <ol>
                        <li>
                           <p>仅在使用Java时，确定应用程序是否使用Oracle JDBC具体类。对于要使用的应用程序连续性，必须替换已弃用的具体类。</p>
                           <p>将<code class="codeph">-acchk</code>参数与ORAchk实用程序一起使用，以验证应用程序是否具有任何具体类。如果有任何不应重播的内容，请使用没有应用程序连续性的连接。（大多数应用程序都是可重播的。）
                           </p>
                           <div class="infoboxnotealso" id="GUID-815F5DF2-6B6E-4E5B-922D-6FCAA4A0AD81__GUID-FC2252A0-73F9-48C1-AE85-9E546E7D46B0">
                              <p class="notep1">也可以看看：</p>有关ORAchk的更多信息，请参见<span><cite>Oracle Autonomous Health Framework用户指南</cite></span></div>
                        </li>
                        <li>
                           <p>确保您具有必要的CPU和内存资源。</p>
                           <ul style="list-style-type:disc">
                              <li>
                                 <p><span class="bold">CPU</span> ：应用程序连续性在客户端和服务器端进行管理，并且需要最少的CPU开销来运行。
                                 </p>
                                 <p>在客户端，CPU用于构建代理对象和垃圾收集（GC）。</p>
                                 <p>在服务器上，CPU用于验证。对于具有当前Intel和SPARC芯片的平台，CPU开销会降低，其中硬件会协助验证。</p>
                              </li>
                              <li>
                                 <p><span class="bold">内存</span> ：使用应用程序连续性时，重放驱动程序需要比基本驱动程序更多的内存，因为调用将保留到请求结束。在请求结束时，调用将被释放到垃圾收集器。此操作与释放已关闭的调用的基本驱动程序不同。
                                 </p>
                                 <p>重放驱动程序的内存消耗取决于每个请求的调用次数。如果此数字很小，则重放驱动程序的内存消耗较少，并且与基本驱动程序相当。</p>
                                 <p>要获得最佳性能，必须为客户端上的<code class="codeph">-Xmx</code>和<code class="codeph">-Xms</code>参数设置相同的值。例如，如果有足够的内存，则为虚拟机（VM）分配4到8 GB（或更多）的内存，例如，通过将<code class="codeph">-Xms4g</code>设置为4 GB。如果<code class="codeph">-Xms</code>参数具有较低的值，则VM还使用操作系统中较低的值，并且性能可能会受到影响并且垃圾收集操作会增加。
                                 </p>
                              </li>
                           </ul>
                        </li>
                        <li>
                           <div class="p">确定应用程序是否借用并返回连接池中的连接，例如WebLogic Server池，通用连接池，OCI会话池，Oracle Tuxedo请求或ODP.NET连接池，每个请求，或者是否添加<code class="codeph">beginRequest</code>和<code class="codeph">endRequest</code> API到应用程序自己的连接池，仅识别Java的请求边界。
                              <div class="infoboxnote" id="GUID-815F5DF2-6B6E-4E5B-922D-6FCAA4A0AD81__GUID-14DBCF52-3324-488A-8433-B325A17C086B">
                                 <p class="notep1">重要：</p>不要在请求边界以外的任何地方使用<code class="codeph">beginRequest</code>和<code class="codeph">endRequest</code> Java API调用（从连接池中借用和返回连接）。 <code class="codeph">endRequest</code>表示请求已完成，并且它现在是无状态的。重播从下一个<code class="codeph">beginRequest</code>开始。如果存在先前状态，则必须使用<code class="codeph">FAILOVER_RESTORE</code>或回调重新建立。
                              </div>
                           </div>
                        </li>
                        <li>
                           <p>应用程序连续性重放请求中的所有状态。如果应用程序在自动售货连接之前设置状态，则需要<code class="codeph">FAILOVER_RESTORE</code>或回调。使用Oracle WebLogic Server或通用连接池时，请使用<code class="codeph">FAILOVER_RESTORE</code> ，连接标记或触发器。使用OCI会话池，Oracle Tuxedo或ODP.NET与Oracle Database 18c或更高版本的客户端时，请使用<code class="codeph">FAILOVER_RESTORE</code> ，并且仅在需要时才添加TAF回调。标签用于运行时和重放。
                           </p>
                        </li>
                        <li>
                           <p>确定应用程序是否需要，因此需要在故障转移期间配置保留<code class="codeph">SYSDATE</code> ， <code class="codeph">SYSTIMESTAMP</code>和<code class="codeph">SYS_GUID</code>以及序列的原始值。
                           </p>
                        </li>
                        <li>
                           <p>评估<code class="codeph">session_state_consistency</code>值的应用程序样式，并在服务上设置适当的值：</p>
                           <ul style="list-style-type:disc">
                              <li>
                                 <p>如果<code class="codeph">session_state_consistency</code>设置为<code class="codeph">AUTO</code> ，则Transparent Application Continuity会监视会话状态并决定要执行的操作。如果您不确定状态使用情况或知道状态可能在将来发生变化，请使用透明应用程序连续性。请参阅预设会话状态列表，因为您可能需要恢复其他预设状态。
                                 </p>
                              </li>
                              <li>
                                 <p>如果<code class="codeph">session_state_consistency</code>设置为<code class="codeph">DYNAMIC</code> ，则应用程序会在请求期间更改环境或设置。在第一个<code class="codeph">COMMIT</code>之后禁用重播，直到下一个请求开始。 <code class="codeph">DYNAMIC</code>是默认模式，适用于大多数应用程序。
                                 </p>
                              </li>
                              <li>
                                 <p>如果<code class="codeph">session_state_consistency</code>设置为<code class="codeph">STATIC</code> ，则应用程序在初始设置后<span class="italic">永远不会</span>更改会话状态。此模式对于不使用PL / SQL状态且不使用<code class="codeph">ALTER</code>部分通过事务的数据库无关应用程序是典型的。谨慎使用此模式，仅适用于“静态”应用程序。
                                 </p>
                              </li>
                           </ul>
                        </li>
                        <li>
                           <p>确定是否不应重播应用程序中的任何请求。</p>
                           <p>例如，可能需要对使用外部PL / SQL操作的请求禁用重播。</p>
                        </li>
                        <li>
                           <p>请遵循以下配置准则：</p>
                           <ul style="list-style-type:disc">
                              <li>
                                 <p>对于Java，请使用Oracle Database 12 <span class="italic">c</span>发行版1（12.1.0.1）或更高版本。对于基于OCI的应用程序，请使用Oracle Database 12 <span class="italic">c第</span> 2版（12.2）或更高版本。
                                 </p>
                              </li>
                              <li>
                                 <p>对于.NET应用程序，请使用ODP.NET，Unmanaged Driver 12.2或更高版本，连接到Oracle Database 12 <span class="italic">c</span>第2版（12.2）或更高版本。默认情况下，在此配置中为ODP.NET应用程序启用应用程序连续性。
                                 </p>
                              </li>
                              <li>
                                 <p>对于基于Java的应用程序，请使用通过JDBC Replay数据源配置的Universal Connection Pool 12.1（或更高版本）或WebLogic Server 12.1.2（或更高版本）;或者对于第三方应用程序（包括第三方JDBC池），请使用JDBC重播驱动程序。对于IBM WebSphere，Apache Tomcat，RedHat Spring和自定义Java解决方案，最有效的解决方案是使用UCP作为池化数据源。</p>
                                 <p>自定义Java池和独立Java应用程序也可以直接使用JDBC Replay数据源。使用自定义Java池和独立应用程序时，请添加<code class="codeph">beginRequest</code>和<code class="codeph">endRequest</code>调用。
                                 </p>
                              </li>
                              <li>
                                 <p>如果应用程序未从Oracle连接池借用和返回，则显式标记请求边界。例如，如果使用自定义JDBC池或其它池，然后调用<code class="codeph">beginRequest</code>在退房并要求<code class="codeph">endRequest</code>在办理登机手续。这些API还可用于没有连接池的独立JDBC应用程序。
                                 </p>
                              </li>
                              <li>
                                 <p>启用FAN以快速中断错误。这对于消除在故障转移开始之前发生的TCP挂起至关重要。在12.2中，FAN内置于JDBC和OCI驱动程序中，默认情况下为Java启用。</p>
                              </li>
                              <li>
                                 <p>使用数据库服务进行连接;永远不要使用SID或实例名称，也不要使用<code class="codeph">DB_NAME</code>或<code class="codeph">DB_UNIQUE_NAME</code>的管理服务。</p>
                              </li>
                              <li>
                                 <p>使用连接字符串设置新传入连接的重试次数以及这些重试之间的延迟。</p>
                              </li>
                              <li>
                                 <p>对于服务，将<code class="codeph">FAILOVER_TYPE</code>设置为<code class="codeph">TRANSACTION</code>以获取应用程序连续性的手动模式，或将<code class="codeph">FAILOVER_TYPE</code>设置为<code class="codeph">AUTO</code>以获得透明应用程序连续性。将<code class="codeph">COMMIT_OUTCOME</code>设置为<code class="codeph">TRUE</code> ，对于OCI FAN，将<code class="codeph">NOTIFICATION</code>设置为<code class="codeph">TRUE</code> 。 （可选）要查找要使用的最佳连接，请将<code class="codeph">GOAL</code>设置为<code class="codeph">SERVICE_TIME</code> ，将<code class="codeph">CLB_GOAL</code>为<code class="codeph">SHORT</code> 。</p>
                              </li>
                              <li>
                                 <div class="p">将Transaction Guard包<code class="codeph">DBMS_APP_CONT</code>权限授予使用Application Continuity进行故障转移的数据库用户，如下所示：<pre class="pre codeblock"><code>对DBMS_APP_CONT执行GRANT EXECUTE到<span class="variable" translate="no">user_name</span> ;</code></pre></div>
                              </li>
                              <li>
                                 <p>使用请求边界和保护级别的统计信息来监控覆盖级别。如果需要更多详细信息，请使用应用程序连续性检查覆盖率（使用ORAchk实用程序）报告受应用程序连续性完全保护的请求的百分比，以及那些未完全受保护的请求的位置。在部署之前和应用程序更改之后使用此覆盖检查。开发人员和管理人员将了解应用程序版本受底层基础架构故障的保护程度。如果出现问题，则可以在应用程序发布之前修复，或者在知道覆盖级别后放弃。</p>
                              </li>
                           </ul>
                        </li>
                     </ol>
                     <p>如果连接池或容器未使用Oracle连接池，则许多第三方Java应用程序完全支持使用通用连接池替换连接池。这包括IBM WebSphere和Apache Tomcat。或者 - 对于Java应用程序，只有应用程序可以添加自己的请求边界。</p>
                     <div class="infoboxnotealso" id="GUID-815F5DF2-6B6E-4E5B-922D-6FCAA4A0AD81__GUID-31BD3BFC-FB1E-4661-A9B8-DC495403EBCA">
                        <p class="notep1">也可以看看：</p>
                        <ul style="list-style-type:disc">
                           <li>
                              <p><span><cite>适用于.NET的Oracle数据提供程序开发人员指南（适用于Microsoft Windows）</cite></span> ，以获取有关.NET应用程序开
                              </p>
                           </li>
                           <li>
                              <p><span><cite>“Oracle数据库JDBC开发人员指南”</cite></span> ，了解有关开发包含Java应用程序连续性的应用程序的更多信息</p>
                           </li>
                        </ul>
                     </div>
                     <p>本节包括以下主题：</p>
                     <ul style="list-style-type:disc">
                        <li>
                           <p><a href="ensuring-application-continuity.html#GUID-FBFC3B38-30A4-43D8-976E-0C4EDABDCFBD" title="如果您使用的是Java，则必须使用oracle.jdbc.replay。OracleDataSourceImpl，oracle.jdbc.replay。OracleConnectionPoolDataSourceImpl或oracle.jdbc.replay.driver。OracleXADataSourceImpl数据源，用于获取JDBC连接。">配置Oracle应用程序连续性</a></p>
                        </li>
                        <li>
                           <p><a href="ensuring-application-continuity.html#GUID-27AE81B9-3ADB-4913-BAB3-BFD8C8244C91">配置Oracle数据库以实现应用程序连续性</a></p>
                        </li>
                        <li>
                           <p><a href="ensuring-application-continuity.html#GUID-0BEE4803-7485-437C-BDF7-C6C34F92D9B0" title="某些应用程序在允许应用程序使用连接之前为连接设置初始状态。">在应用程序连续性重播之前建立初始状态</a></p>
                        </li>
                        <li>
                           <p><a href="ensuring-application-continuity.html#GUID-2B3E23CC-A57D-4C62-B226-87E6C6A20874" title="默认情况下，当Application Continuity启动故障转移时，驱动程序会尝试在服务可用的实例上恢复正在进行的工作。">延迟应用程序连续性中的重新连接</a></p>
                        </li>
                        <li>
                           <p><a href="ensuring-application-continuity.html#GUID-61B6FEC5-90F0-4BE2-AC3B-37ECA6009545" title="对于计划维护，建议的方法是将Oracle连接池的请求与应用程序连续性一起用于那些未完成的请求。确实需要停止实例以切换到已修补的软件。">使用应用程序连续性进行计划维护</a></p>
                        </li>
                        <li>
                           <p><a href="ensuring-application-continuity.html#GUID-76D24524-AFCC-4BE0-8EFB-9C6C10F243E5" title="有时，应用程序连续性无效，因为已发出禁用调用。">没有应用程序连续性运行</a></p>
                        </li>
                        <li>
                           <p><a href="ensuring-application-continuity.html#GUID-696EB534-5B9C-49A9-902A-3F00169EC9AB" title="在可恢复的错误之后发生重播，但您可以禁用重播。">在应用程序连续性中禁用重播</a></p>
                        </li>
                        <li>
                           <p><a href="ensuring-application-continuity.html#GUID-9DD8DD6B-42E3-4248-ADA1-1763ABDA1302">在没有重播的情况下终止或断开会话</a></p>
                        </li>
                     </ul>
                  </div>
                  <div>
                     <div class="relinfo">
                        <p><strong>相关话题</strong></p>
                        <ul>
                           <li><a href="../atnms/orachk-and-exachk-command-line-options.html#ATNMS-GUID-87407F79-597D-453E-82DF-D870386829A9" target="_blank"><span><cite>Oracle自治健康框架用户指南</cite></span></a></li>
                           <li><a href="ensuring-application-continuity.html#GUID-B2895452-68A1-45E5-A9A7-1888B7B10481" title="当计划内维护和计划外中断数据库透明时，应用程序可实现持续可用性。">透明的应用程序连续性</a></li>
                           <li><a href="ensuring-application-continuity.html#GUID-E4A114A2-EA77-4037-A62A-BDFCF1E6D072">可变功能和应用连续性</a></li>
                           <li><a href="ensuring-application-continuity.html#GUID-D49C131A-5931-473E-A878-AF4B99E97F1D">会话状态一致性</a></li>
                           <li><a href="ensuring-application-continuity.html#GUID-FE576341-43A9-40EC-85EB-11A7CA9F5AE7">自动会话状态一致性</a></li>
                           <li><a href="ensuring-application-continuity.html#GUID-696EB534-5B9C-49A9-902A-3F00169EC9AB">在应用程序连续性中禁用重播</a></li>
                           <li><a href="https://www.oracle.com/pls/topic/lookup?ctx=en/database/oracle/oracle-database/19/racad&amp;id=ODPNT-GUID-265124E6-8B8A-4348-8602-F7CEEEEE5AEF" target="_blank"><span><cite>适用于Microsoft Windows的Oracle数据提供程序开发人员指南</cite></span></a></li>
                           <li><a href="../jjdbc/application-continuity.html#JJDBC-GUID-AAC6F9B7-9B4C-4098-B0D5-312BF9A13928" target="_blank"><span><cite>Oracle数据库JDBC开发人员指南</cite></span></a></li>
                           <li><a href="../jjucp/intro.html#JJUCP-GUID-82ACD002-4C5F-4BF7-99FF-46A2A97DD35D" target="_blank"><span><cite>Oracle通用连接池开发人员指南</cite></span></a></li>
                           <li><a href="https://www.oracle.com/pls/topic/lookup?ctx=en/database/oracle/oracle-database/19/racad&amp;id=OEXUG-GUID-54ACE4B5-3EDD-452A-B758-8793980B1D20" target="_blank"><span><cite>Oracle ORAchk和EXAchk用户指南</cite></span></a></li>
                        </ul>
                     </div>
                  </div><a id="ADFNS601"></a><div class="sect4"><a id="GUID-FBFC3B38-30A4-43D8-976E-0C4EDABDCFBD" name="GUID-FBFC3B38-30A4-43D8-976E-0C4EDABDCFBD"></a><h5 id="RACAD-GUID-FBFC3B38-30A4-43D8-976E-0C4EDABDCFBD" class="sect5">配置Oracle应用程序连续性</h5>
                     <div>
                        <p>如果您使用的是Java，则必须使用<code class="codeph">oracle.jdbc.replay.OracleDataSourceImpl</code> ， <code class="codeph">oracle.jdbc.replay.OracleConnectionPoolDataSourceImpl</code>或<code class="codeph">oracle.jdbc.replay.driver.OracleXADataSourceImpl</code>数据源，用于获取JDBC连接。
                        </p>
                        <p>这些数据源支持所有Oracle JDBC数据源的所有属性和配置参数，例如<code class="codeph">oracle.jdbc.pool.OracleDataSource</code> 。
                        </p>
                        <p>对于包括SQL * Plus和ODP.NET在内的基于OCI的应用程序，OCI驱动程序12.2及更高版本支持应用程序连续性。</p>
                        <p>使用连接URL时，您必须记住以下几点：</p>
                        <ul style="list-style-type:disc">
                           <li>
                              <p>如果数据库的<code class="codeph">REMOTE_LISTENER</code>设置与客户端<code class="codeph">ADDRESS_LIST</code>中的地址不匹配，则表示它未连接，表示<code class="codeph">services cannot be found</code> 。因此，数据库的<code class="codeph">REMOTE_LISTENER</code>设置<span class="italic">必须</span>与客户端<code class="codeph">ADDRESS_LIST</code>中的地址匹配：</p>
                              <ul style="list-style-type:disc">
                                 <li>
                                    <p>如果连接字符串使用SCAN名称，则必须将<code class="codeph">REMOTE_LISTENER</code>设置为SCAN名称。
                                    </p>
                                 </li>
                                 <li>
                                    <p>如果连接字符串使用主机VIP的<code class="codeph">ADDRESS_LIST</code> ，则必须将<code class="codeph">REMOTE_LISTENER</code>设置为包含所有SCAN VIP和所有主机VIP的地址列表</p>
                                 </li>
                              </ul>
                              <div class="infoboxnote" id="GUID-FBFC3B38-30A4-43D8-976E-0C4EDABDCFBD__GUID-ACE26216-269B-42BA-84CF-513190DBBB56">
                                 <p class="notep1">注意：</p>
                                 <p>使用SCAN实现位置独立性，以便在添加或删除节点时，或者在数据库更改为在不同节点上运行时，无需重新配置客户端。</p>
                              </div>
                           </li>
                           <li>
                              <p>在连接字符串中设置<code class="codeph">RETRY_COUNT</code> ， <code class="codeph">RETRY_DELAY</code> ， <code class="codeph">CONNECT_TIMEOUT</code>和<code class="codeph">TRANSPORT_CONNECT_TIMEOUT</code>参数。这些设置可以改善在运行时，重放时以及计划中断的工作流中获取新连接。
                              </p>
                              <p>该<code class="codeph">CONNECT_TIMEOUT</code>参数相当于<code class="codeph">SQLNET.OUTBOUND_CONNECT_TIMEOUT</code>在参数<code class="codeph">sqlnet.ora</code>文件，适用于完整的连接。<code class="codeph">TRANSPORT_CONNECT_TIMEOUT</code>参数适用于每个地址。
                              </p>
                              <p>将<code class="codeph">CONNECT_TIMEOUT</code>设置为较高的值以防止过多的登录。较低的值可能导致应用程序或服务器池的<span class="italic">登录风暴</span>取消和重试。不要将<code class="codeph">(RETRY_COUNT+1)*RETRY_DELAY</code>或<code class="codeph">CONNECT_TIMEOUT</code>大于响应时间SLA。应用程序必须在响应时间SLA内连接或接收错误。</p>
                              <p>这些是配置高可用性连接的一般建议。不要使用Easy Connect，因为它没有高可用性功能。</p>
                              <p>以下是TNS条目的示例。这是自动配置ONS（FAN的传输系统）所需的TNS格式。Oracle建议将FAN与应用程序连续性一起使用，以提供快速中断检测。</p><pre class="pre codeblock"><code>alias =（DESCRIPTION =（CONNECT_TIMEOUT = 120）（RETRY_COUNT = 20）（RETRY_DELAY = 3）（TRANSPORT_CONNECT_TIMEOUT = 3）（ADDRESS_LIST =（LOAD_BALANCE = on）（ADDRESS =（PROTOCOL = TCP）（HOST =主扫描）（PORT） = 1521）））（ADDRESS_LIST =（LOAD_BALANCE = on）（ADDRESS =（PROTOCOL = TCP）（HOST =二次扫描）（PORT = 1521）））（CONNECT_DATA =（SERVICE_NAME = gold-cloud）））</code></pre></li>
                        </ul>
                     </div>
                     <div>
                        <div class="relinfo">
                           <p><strong>相关话题</strong></p>
                           <ul>
                              <li><a href="../netrf/index.html" target="_blank"><span><cite>Oracle数据库网络服务参考</cite></span></a></li>
                              <li><a href="https://www.oracle.com/pls/topic/lookup?ctx=en/database/oracle/oracle-database/19/racad&amp;id=ODPNT-GUID-1308ACD5-025A-468E-834A-CAB59FE9BB59" target="_blank"><span><cite>适用于Microsoft Windows的Oracle数据提供程序开发人员指南</cite></span></a></li>
                           </ul>
                        </div>
                     </div>
                  </div><a id="ADFNS602"></a><div class="sect4"><a id="GUID-27AE81B9-3ADB-4913-BAB3-BFD8C8244C91" name="GUID-27AE81B9-3ADB-4913-BAB3-BFD8C8244C91"></a><h5 id="RACAD-GUID-27AE81B9-3ADB-4913-BAB3-BFD8C8244C91" class="sect5">配置Oracle数据库以实现应用程序连续性</h5>
                     <div>
                        <p>您的Oracle数据库配置必须包含以下内容才能使用应用程序连续性：</p>
                        <ul style="list-style-type:disc">
                           <li>
                              <p>如果您使用的是Oracle Real Application Clusters（Oracle RAC）或Oracle RAC One Node，Oracle Data Guard或Oracle Active Data Guard，请确保使用Oracle Notification Service（ONS）配置FAN以与Oracle Database 12 <span class="italic">c</span>池进行通信，驱动程序。
                              </p>
                           </li>
                           <li>
                              <p>在服务上设置服务属性以进行重放和负载平衡。例如，设置：</p>
                              <ul style="list-style-type:disc">
                                 <li>
                                    <p><code class="codeph">FAILOVER_TYPE = AUTO | TRANSACTION</code> ：对于透明应用程序连续性使用<code class="codeph">FAILOVER_TYPE=AUTO</code>或对手动应用程序连续性使用<code class="codeph">FAILOVER_TYPE=TRANSACTION</code> 。此属性为重播驱动程序和应用程序连续性启用重播功能。Oracle驱动程序跟踪数据库会话期间发出的所有可重放语句。如果所有语句都是可重放的，并且任何正在进行的事务未提交或会话正在进行对话，则Oracle会在计划内或计划外数据库中断后重播未提交的工作。此模式自动重新建立事务和非事务状态，无需其他应用程序步骤。
                                    </p>
                                 </li>
                                 <li>
                                    <p><code class="codeph">REPLAY_INITIATION_TIMEOUT = <span class="variable" translate="no">n</span></code> ：用于设置持续时间（以秒为单位），以允许重放开始（ <code class="codeph"><span class="variable" translate="no">n</span></code>的值可以是，例如， <code class="codeph">REPLAY_INITIATION_TIMEOUT = <span class="variable" translate="no">n</span></code>或1800，具体取决于您的需要）</p>
                                 </li>
                                 <li>
                                    <p><code class="codeph">FAILOVER_RETRIES = 30</code> ：用于指定每次重播的连接重试次数</p>
                                 </li>
                                 <li>
                                    <p><code class="codeph">FAILOVER_DELAY = 10</code> ：用于指定连接重试之间的延迟（以秒为单位）</p>
                                 </li>
                                 <li>
                                    <p><code class="codeph">GOAL = SERVICE_TIME</code> ：如果您使用的是Oracle RAC或Oracle全局数据服务，那么这是推荐的设置</p>
                                 </li>
                                 <li>
                                    <p><code class="codeph">CLB_GOAL = SHORT</code> ：如果您使用的是Oracle RAC或Oracle全局数据服务，那么这是推荐的设置</p>
                                 </li>
                                 <li>
                                    <p><code class="codeph">COMMIT_OUTCOME = TRUE</code> ：用于使用Transaction Guard</p>
                                 </li>
                                 <li>
                                    <p><code class="codeph">FAILOVER_RESTORE = AUTO | LEVEL1</code> ：使用<code class="codeph">FAILOVER_RESTORE=AUTO</code>表示透明应用程序连续性，使用<code class="codeph">FAILOVER_RESTORE=LEVEL1</code>表示手动应用程序连续性。在重播开始之前自动恢复在连接池上预设的客户端状态 - 包括AUTOCOMMIT状态（对于Java和SQL * Plus），NLS状态和TAGS（MODULE，ACTION，ECID，CLIENT_ID，CLIENT_INFO）状态。
                                    </p>
                                 </li>
                              </ul>
                           </li>
                           <li>
                              <div class="p">将Application Continuity包<code class="codeph">DBMS_APP_CONT</code>权限授予使用Application Continuity进行故障转移的数据库用户，如下所示：<pre class="pre codeblock"><code>对DBMS_APP_CONT执行GRANT EXECUTE到<span class="variable" translate="no">user_name</span> ;</code></pre></div>
                           </li>
                           <li>
                              <p><span class="italic">请勿使用</span>与<code class="codeph">DB_NAME</code>或<code class="codeph">DB_UNIQUE_NAME</code>对应的默认数据库服务。此外， <span class="italic">请勿使用</span>默认数据库服务实现高可用性，因为无法启用或禁用此服务，也无法在Oracle RAC上重定位或切换到Oracle Data Guard。此服务保留用于Oracle Enterprise Manager云控制（云控制）和DBA。
                              </p>
                           </li>
                        </ul>
                     </div>
                  </div><a id="ADFNS603"></a><div class="sect4"><a id="GUID-0BEE4803-7485-437C-BDF7-C6C34F92D9B0" name="GUID-0BEE4803-7485-437C-BDF7-C6C34F92D9B0"></a><h5 id="RACAD-GUID-0BEE4803-7485-437C-BDF7-C6C34F92D9B0" class="sect5">在应用程序连续性重播之前建立初始状态</h5>
                     <div>
                        <p>某些应用程序在允许应用程序使用连接之前为连接设置初始状态。</p>
                        <div class="p">应用程序连续性必须在重放开始之前建立此初始状态。对于这些应用程序， <code class="codeph">FAILOVER_RESTORE</code>恢复此处列出的常见状态。如果此处未列出应用程序预设的状态，并且应用程序需要初始状态，则必须添加其他回调。
                           <div class="infoboxnotealso" id="GUID-0BEE4803-7485-437C-BDF7-C6C34F92D9B0__GUID-B1EAA6A4-98BC-458A-85ED-96FE703AF42C">
                              <p class="notep1">也可以看看：</p>适用于您的平台的<span class="italic">Oracle Database发行说明</span> ，因为每个版本中都会恢复更多参数</div>
                        </div>
                        <p>可预设的状态示例包括：</p>
                        <ul style="list-style-type:disc">
                           <li>
                              <p>PL / SQL包状态</p>
                           </li>
                           <li>
                              <p>NLS设置</p>
                           </li>
                           <li>
                              <p>优化设置</p>
                           </li>
                        </ul>
                        <p>在请求期间，Application Continuity会重新建立请求的整个状态。此先决条件适用于Application Continuity开始重播之前的初始状态。</p>
                        <p>如果<code class="codeph">FAILOVER_RESTORE</code>恢复所有必需状态，则不需要回调，大多数应用程序都是如此。
                        </p>
                        <p>对于仅在请求开始时设置状态的应用程序，或者对于使用具有预设状态的连接获得性能优势的有状态应用程序，请选择以下选项之一：</p>
                        <ul style="list-style-type:disc">
                           <li>
                              <p><a href="ensuring-application-continuity.html#GUID-751D4D16-BE2C-44DC-9A7B-20348E4EC24B" title="将FAILOVER_RESTORE设置为LEVEL1（用于手动应用程序连续性）或AUTO（用于透明应用程序连续性）会在重放请求之前自动恢复常见状态初始设置。">FAILOVER_RESTORE = LEVEL1或AUTO</a> 
                              </p>
                           </li>
                           <li>
                              <p><a href="ensuring-application-continuity.html#GUID-D0D41855-712D-47DC-B282-07CD8E6B4B5D">FAILOVER_RESTORE =无和无回叫</a></p>
                           </li>
                           <li>
                              <p><a href="ensuring-application-continuity.html#GUID-746A88D5-2A2B-4AF9-BE91-229DE36378FB">连接标签</a></p>
                           </li>
                           <li>
                              <p><a href="ensuring-application-continuity.html#GUID-B54DA2D3-8B8C-45EB-9CC3-B9D44B448FC7">连接初始化回调</a></p>
                           </li>
                        </ul>
                     </div>
                     <div class="sect5"><a id="GUID-751D4D16-BE2C-44DC-9A7B-20348E4EC24B" name="GUID-751D4D16-BE2C-44DC-9A7B-20348E4EC24B"></a><h6 id="RACAD-GUID-751D4D16-BE2C-44DC-9A7B-20348E4EC24B" class="sect6">FAILOVER_RESTORE = LEVEL1或AUTO</h6>
                        <div>
                           <p>将<code class="codeph">FAILOVER_RESTORE</code>设置为<code class="codeph">LEVEL1</code> （用于手动应用程序连续性）或<code class="codeph">AUTO</code> （用于透明应用程序连续性）会在重放请求之前自动恢复常见状态初始设置。</p>
                           <p>Oracle建议为所有应用程序将<code class="codeph">FAILOVER_RESTORE</code>设置为<code class="codeph">LEVEL1</code>或<code class="codeph">AUTO</code> 。
                           </p>
                           <p>恢复的州包括以下内容：</p>
                           <ul style="list-style-type:disc">
                              <li>
                                 <p>NLS_CALENDAR</p>
                              </li>
                              <li>
                                 <p>NLS_CURRENCY</p>
                              </li>
                              <li>
                                 <p>NLS_DATE_FORMAT</p>
                              </li>
                              <li>
                                 <p>NLS_DATE_LANGUAGE</p>
                              </li>
                              <li>
                                 <p>NLS_DUAL_CURRENCY</p>
                              </li>
                              <li>
                                 <p>NLS_ISO_CURRENCY</p>
                              </li>
                              <li>
                                 <p>NLS_LANGUAGE</p>
                              </li>
                              <li>
                                 <p>NLS_LENGTH_SEMANTICS</p>
                              </li>
                              <li>
                                 <p>NLS_NCHAR_CONV_EXCP</p>
                              </li>
                              <li>
                                 <p>NLS_NUMERIC_CHARACTER</p>
                              </li>
                              <li>
                                 <p>NLS_SORT</p>
                              </li>
                              <li>
                                 <p>NLS_TERRITORY</p>
                              </li>
                              <li>
                                 <p>NLS_TIME_FORMAT</p>
                              </li>
                              <li>
                                 <p>NLS_TIME_TZ_FORMAT</p>
                              </li>
                              <li>
                                 <p>时区</p>
                              </li>
                              <li>
                                 <p>NLS_TIMESTAMP_FORMAT</p>
                              </li>
                              <li>
                                 <p>NLS_TIMESTAMP_TZ_FORMAT</p>
                              </li>
                              <li>
                                 <p>CURRENT_SCHEMA</p>
                              </li>
                              <li>
                                 <p>MODULE</p>
                              </li>
                              <li>
                                 <p>行动</p>
                              </li>
                              <li>
                                 <p>CLIENT_ID</p>
                              </li>
                              <li>
                                 <p>AUTOCOMMIT状态（适用于Java和SQL * Plus）</p>
                              </li>
                              <li>
                                 <p>集装箱（PDB）和服务</p>
                              </li>
                              <li>
                                 <p>ROLES（不包括安全角色，继续需要回电）</p>
                              </li>
                              <li>
                                 <p>ROW_ARCHIVAL</p>
                              </li>
                              <li>
                                 <p>版</p>
                              </li>
                              <li>
                                 <p>ERROR_ON_OVERLAP_TIME</p>
                              </li>
                              <li>
                                 <p>SQL_TRANSLATION_PROFILE</p>
                              </li>
                              <li>
                                 <p>CLIENT_INFO。 （JDBC）</p>
                              </li>
                           </ul>
                           <p>THIN驱动程序不支持以下内容，因此从自动恢复选项中排除：</p>
                           <ul style="list-style-type:disc">
                              <li>
                                 <p>NLS_COMP</p>
                              </li>
                              <li>
                                 <p>CALL_COLLECT_TIME</p>
                              </li>
                              <li>
                                 <p>CLIENT_INFO</p>
                              </li>
                           </ul>
                        </div>
                     </div><a id="ADFNS1088"></a><div class="sect5"><a id="GUID-D0D41855-712D-47DC-B282-07CD8E6B4B5D" name="GUID-D0D41855-712D-47DC-B282-07CD8E6B4B5D"></a><h6 id="RACAD-GUID-D0D41855-712D-47DC-B282-07CD8E6B4B5D" class="sect6">FAILOVER_RESTORE =无和无回叫</h6>
                        <div>
                           <p>在此方案中，适用于Oracle Database 18c之前的数据库和客户端，应用程序在从池中借用连接时不会采用任何状态，或使用UCP或WebLogic标签重新建立初始状态。</p>
                           <p>从Oracle Database 18c数据库和客户端开始，或者稍后，Oracle建议为所有应用程序将<code class="codeph">FAILOVER_RESTORE</code>设置为<code class="codeph">LEVEL1</code>或<code class="codeph">AUTO</code> 。
                           </p>
                        </div>
                     </div><a id="ADFNS1187"></a><div class="sect5"><a id="GUID-746A88D5-2A2B-4AF9-BE91-229DE36378FB" name="GUID-746A88D5-2A2B-4AF9-BE91-229DE36378FB"></a><h6 id="RACAD-GUID-746A88D5-2A2B-4AF9-BE91-229DE36378FB" class="sect6">连接标签</h6>
                        <div>
                           <p>Oracle建议使用连接标签（一种通用池功能）作为最佳实践。当存在连接标签时，应用程序连续性使用它。由于连接标签正在重新创建状态，因此可以将<code class="codeph">FAILOVER_RESTORE</code>设置为<code class="codeph">NONE</code> 。</p>
                           <p>此方案适用于通用连接池（UCP）和Oracle WebLogic服务器。可以修改应用程序以利用连接上的预设状态。连接标签API确定连接的匹配程度，并在借用连接时使用回调填充间隙。</p>
                        </div>
                        <div>
                           <div class="relinfo">
                              <p><strong>相关话题</strong></p>
                              <ul>
                                 <li><a href="../jjucp/application-continuity-using-ucp.html#JJUCP-GUID-83526888-0AA4-4112-B962-4057D64F192B" target="_blank"><span><cite>Oracle通用连接池开发人员指南</cite></span></a></li>
                              </ul>
                           </div>
                        </div>
                     </div><a id="ADFNS1289"></a><div class="sect5"><a id="GUID-B54DA2D3-8B8C-45EB-9CC3-B9D44B448FC7" name="GUID-B54DA2D3-8B8C-45EB-9CC3-B9D44B448FC7"></a><h6 id="RACAD-GUID-B54DA2D3-8B8C-45EB-9CC3-B9D44B448FC7" class="sect6">连接初始化回调</h6>
                        <div>
                           <p>在此方案中，重放驱动程序（JDBC或OCI）使用应用程序回调在运行时和重放期间设置会话的初始状态。JDBC重放驱动程序提供连接初始化回调接口以及在<code class="codeph">oracle.jdbc.replay.注册和取消注册连接初始化回调的方法<code class="codeph">oracle.jdbc.replay.OracleDataSource</code>接口。对于OCI和ODP.NET，请注册TAF回调。
                           </p>
                           <p>注册后，每次从池中借用连接时以及在可恢复错误后每次成功重新连接时都会执行初始化回调。（这对于JDBC / UCP初始化回调是正确的，对于TAF应该是相同的。）在运行时和重放期间使用相同的回调可确保在重放时建立相同的初始化，就像首次建立会话时一样。应用程序负责确保初始化操作与故障转移之前的原始连接上的初始化操作相同。如果回调调用失败，则在该连接上禁用重播。仅当应用程序未实现UCP和WebLogic连接标签时才使用连接初始化回调，并且通过为透明应用程序连续性设置<code class="codeph">FAILOVER_RESTORE=AUTO</code>或者为手动应用程序连续性设置<code class="codeph">FAILOVER_RESTORE=LEVEL1</code> ，无法自动恢复状态。
                           </p>
                        </div>
                     </div>
                  </div><a id="ADFNS1290"></a><div class="sect4"><a id="GUID-2B3E23CC-A57D-4C62-B226-87E6C6A20874" name="GUID-2B3E23CC-A57D-4C62-B226-87E6C6A20874"></a><h5 id="RACAD-GUID-2B3E23CC-A57D-4C62-B226-87E6C6A20874" class="sect5">延迟应用程序连续性中的重新连接</h5>
                     <div>
                        <p>默认情况下，当Application Continuity启动故障转移时，驱动程序会尝试在服务可用的实例上恢复正在进行的工作。</p>
                        <p>要恢复工作，驱动程序必须与实例建立良好的连接。如果在重新定位和发布服务之前必须重新启动数据库或实例，则重新连接可能需要一些时间。因此，必须延迟故障转移，直到服务从另一个实例或数据库可用。</p>
                        <p>您必须使用<code class="codeph">FAILOVER_RETRIES</code>和<code class="codeph">FAILOVER_DELAY</code>参数来管理连接和重新连接。这些参数可以与计划中断一起很好地工作，例如，可能使服务在几分钟内不可用的中断。设置<code class="codeph">FAILOVER_DELAY</code>和<code class="codeph">FAILOVER_RETRIES</code>参数时，首先检查<code class="codeph">REPLAY_INITIAITION_TIMEOUT</code>参数的值。此参数的默认值为900秒。<code class="codeph">FAILOVER_DELAY</code>参数的高值可能导致重放被取消。
                        </p>
                        <div class="tblformal" id="GUID-2B3E23CC-A57D-4C62-B226-87E6C6A20874__GUID-069AC3CE-3677-4259-B8CA-147CEAD00FAD">
                           <table cellpadding="4" cellspacing="0" class="Formal" title="" border="1" summary="Parameters for delaying failover" frame="hsides" rules="rows">
                              <thead>
                                 <tr align="left" valign="top">
                                    <th align="left" valign="bottom" width="33%" id="d23610e7372">参数名称</th>
                                    <th align="left" valign="bottom" width="33%" id="d23610e7375">可能的价值</th>
                                    <th align="left" valign="bottom" width="33%" id="d23610e7378">默认值</th>
                                 </tr>
                              </thead>
                              <tbody>
                                 <tr align="left" valign="top">
                                    <td align="left" valign="top" width="33%" id="d23610e7383" headers="d23610e7372 ">
                                       <p><code class="codeph">FAILOVER_RETRIES</code></p>
                                    </td>
                                    <td align="left" valign="top" width="33%" headers="d23610e7383 d23610e7375 ">
                                       <p>正整数为零或以上</p>
                                    </td>
                                    <td align="left" valign="top" width="33%" headers="d23610e7383 d23610e7378 ">
                                       <p>三十</p>
                                    </td>
                                 </tr>
                                 <tr align="left" valign="top">
                                    <td align="left" valign="top" width="33%" id="d23610e7394" headers="d23610e7372 ">
                                       <p><code class="codeph">FAILOVER_DELAY</code></p>
                                    </td>
                                    <td align="left" valign="top" width="33%" headers="d23610e7394 d23610e7375 ">
                                       <p>时间以秒为单位</p>
                                    </td>
                                    <td align="left" valign="top" width="33%" headers="d23610e7394 d23610e7378 ">
                                       <p>10</p>
                                    </td>
                                 </tr>
                              </tbody>
                           </table>
                        </div>
                        <!-- class="inftblhruleinformal" -->
                        <p>以下示例显示了各种故障转移方案：</p>
                        <ul style="list-style-type:disc">
                           <li>
                              <p><a href="ensuring-application-continuity.html#GUID-9DAE9270-A5BC-4A0F-9A55-D9DCFC0A9BF5" title="您可以在Oracle RAC上创建利用透明应用程序连续性或手动应用程序连续性的服务。">使用应用程序连续性在Oracle RAC上创建服务</a></p>
                           </li>
                           <li>
                              <p><a href="ensuring-application-continuity.html#GUID-1EAB6E4B-24DE-4D90-ABF8-682D1712E57F" title="如果您使用的是单实例数据库，则使用DBMS_SERVICE包来修改服务。">修改单实例数据库上的服务以使用应用程序连续性</a></p>
                           </li>
                        </ul>
                     </div><a id="ADFNS1344"></a><a id="ADFNS1395"></a><a id="ADFNS1291"></a><div class="sect5"><a id="GUID-9DAE9270-A5BC-4A0F-9A55-D9DCFC0A9BF5" name="GUID-9DAE9270-A5BC-4A0F-9A55-D9DCFC0A9BF5"></a><h6 id="RACAD-GUID-9DAE9270-A5BC-4A0F-9A55-D9DCFC0A9BF5" class="sect6">使用应用程序连续性在Oracle RAC上创建服务</h6>
                        <div>
                           <p>您可以在Oracle RAC上创建利用透明应用程序连续性或手动应用程序连续性的服务。</p>
                           <p>您可以创建使用透明应用程序连续性的服务，如下所示：</p>
                           <div class="p">对于策略管理的数据库：<pre class="pre codeblock"><code>$ srvctl add service -db codedb -service GOLD -serverpool ora。Srvpool -clbgoal SHORT -rlbgoal SERVICE_TIME -failover_restore AUTO -failoverretry 30 -failoverdelay 10 -commit_outcome TRUE -failovertype AUTO -replay_init_time 1800 -retention 86400 -notification TRUE</code></pre></div>
                           <div class="p">对于管理员管理的数据库：<pre class="pre codeblock"><code>$ srvctl add service -db codedb -service GOLD -preferred serv1 -available serv2 -clbgoal SHORT -rlbgoal SERVICE_TIME -failover_restore AUTO -failoverretry 30 -failoverdelay 10 -commit_outcome TRUE -failovertype AUTO -replay_init_time 1800 -retention 86400 -notification TRUE</code></pre></div>
                           <p>您可以创建使用手动应用程序连续性的服务，如下所示::</p>
                           <p>对于策略管理的数据库：</p><pre class="pre codeblock"><code>$ srvctl add service -db codedb -service GOLD -serverpool ora。Srvpool -clbgoal SHORT -rlbgoal SERVICE_TIME -failover_restore LEVEL1 -failoverretry 30 -failoverdelay 10 -commit_outcome TRUE -failovertype TRANSACTION -replay_init_time 1800 -retention 86400 -notification TRUE</code></pre><p>对于管理员管理的数据库：</p><pre class="pre codeblock"><code>$ srvctl add service -db codedb -service GOLD -preferred serv1 -available serv2 -clbgoal SHORT -rlbgoal SERVICE_TIME -failover_restore LEVEL1 -failoverretry 30 -failoverdelay 10 -commit_outcome TRUE -failovertype TRANSACTION -replay_init_time 1800 -retention 86400 -notification TRUE</code></pre></div>
                     </div><a id="ADFNS1396"></a><div class="sect5"><a id="GUID-1EAB6E4B-24DE-4D90-ABF8-682D1712E57F" name="GUID-1EAB6E4B-24DE-4D90-ABF8-682D1712E57F"></a><h6 id="RACAD-GUID-1EAB6E4B-24DE-4D90-ABF8-682D1712E57F" class="sect6">修改单实例数据库上的服务以使用应用程序连续性</h6>
                        <div>
                           <p>如果您使用的是单实例数据库，则使用<code class="codeph">DBMS_SERVICE</code>包来修改服务。
                           </p>
                           <div class="p">对于手动应用程序连续性：<pre class="pre codeblock"><code>DECLARE params dbms_service.svc_parameter_array; BEGIN params（'FAILOVER_TYPE'）：='TRANSACTION'; PARAMS（ 'REPLAY_INITIATION_TIMEOUT'）：= 1800; PARAMS（ 'RETENTION_TIMEOUT'）：= 86400; PARAMS（ 'FAILOVER_DELAY'）：= 10; PARAMS（ 'FAILOVER_RETRIES'）：= 30; PARAMS（ 'FAILOVER_RESTORE'）：= 'LEVEL1'; PARAMS（ 'commit_outcome'）：= '真'; PARAMS（ 'aq_ha_notifications'）：= '真'; dbms_service.modify_service（'[ <span class="variable" translate="no">your service</span> ]'，params）;结束; /</code></pre></div>
                           <div class="p">对于透明应用程序连续性：<pre class="pre codeblock"><code>DECLARE params dbms_service.svc_parameter_array; BEGIN params（'FAILOVER_TYPE'）：='AUTO'; PARAMS（ 'REPLAY_INITIATION_TIMEOUT'）：= 1800; PARAMS（ 'RETENTION_TIMEOUT'）：= 86400; PARAMS（ 'FAILOVER_DELAY'）：= 10; PARAMS（ 'FAILOVER_RETRIES'）：= 30; PARAMS（ 'FAILOVER_RESTORE'）：= 'AUTO'; PARAMS（ 'commit_outcome'）：= '真'; PARAMS（ 'aq_ha_notifications'）：= '真'; dbms_service.modify_service（'[your service]'，params）;结束; /</code></pre></div>
                        </div>
                     </div>
                  </div><a id="ADFNS1399"></a><div class="sect4"><a id="GUID-61B6FEC5-90F0-4BE2-AC3B-37ECA6009545" name="GUID-61B6FEC5-90F0-4BE2-AC3B-37ECA6009545"></a><h5 id="RACAD-GUID-61B6FEC5-90F0-4BE2-AC3B-37ECA6009545" class="sect5">使用应用程序连续性进行计划维护</h5>
                     <div>
                        <p>对于计划维护，建议的方法是将Oracle连接池的请求与应用程序连续性一起用于那些未完成的请求。确实需要停止实例以切换到已修补的软件。</p>
                        <p>当完成最小的恢复时，这对影响最小。</p>
                        <p>要将应用程序连续性用于计划维护：</p>
                        <ol>
                           <li>
                              <p>使用任何支持FAN的池，例如OCI，UCP，WebLogic Server或ODP.NET托管和非托管驱动程序。</p>
                              <div class="p">FAN计划的事件在请求边界消失。
                                 <div class="infoboxnote" id="GUID-61B6FEC5-90F0-4BE2-AC3B-37ECA6009545__GUID-D73D9638-50CC-49E0-95B0-0249F47813D3">
                                    <p class="notep1">注意：</p>ODP.NET托管驱动程序不支持应用程序连续性。
                                 </div>
                              </div>
                           </li>
                           <li>
                              <p>使用<code class="codeph">srvctl relocate service</code>命令从实例重新定位服务而不中断会话，或者对于统一服务，请在实例上使用<code class="codeph">srvctl stop service</code>命令（不要使用<code class="codeph">-force</code>参数）。
                              </p>
                              <p>FAN计划事件立即清除空闲会话，并标记在登记时（请求结束）释放的活动会话。这会从实例中消耗会话而不会中断工作。</p>
                           </li>
                           <li>
                              <p>如果并非所有会话都已签入并且已到达停止实例的时间，则停止实例（中止）。</p>
                              <p>对于启用了应用程序连续性的池（UCP，WebLogic，Tuxedo，ODP.NET和OCI）以及添加<code class="codeph">beginRequest</code> / <code class="codeph">endRequest</code>任何Java池，Application Continuity会尝试恢复剩余的会话。
                              </p>
                           </li>
                           <li>
                              <p>重新启动实例和服务。</p>
                              <p>启用运行时负载平衡后，会在下一个请求边界处将会话平衡回已还原的实例。</p>
                           </li>
                        </ol>
                     </div>
                  </div><a id="ADFNS357"></a><div class="sect4"><a id="GUID-76D24524-AFCC-4BE0-8EFB-9C6C10F243E5" name="GUID-76D24524-AFCC-4BE0-8EFB-9C6C10F243E5"></a><h5 id="RACAD-GUID-76D24524-AFCC-4BE0-8EFB-9C6C10F243E5" class="sect5">没有应用程序连续性运行</h5>
                     <div>
                        <p>有时，应用程序连续性无效，因为已发出禁用调用。</p>
                        <p>应用程序连续性在尚未启动或已禁用时无效。如果它已被禁用，它仍然是通过<code class="codeph">endRequest</code>调用。
                        </p>
                        <p>当服务性应用的连续性未启动<code class="codeph">FAILOVER_TYPE</code> <span class="italic">不</span>具备的值设置为<code class="codeph">TRANSACTION</code>或<code class="codeph">AUTO</code> 。对于计划维护，请事先将<code class="codeph">FAILOVER_TYPE</code>值设置为<code class="codeph">TRANSACTION</code>或<code class="codeph">AUTO</code> ;该设置适用于新连接，现有连接保留其原始服务值。
                        </p>
                        <p>发生以下任何情况时，将禁用当前请求的应用程序连续性：</p>
                        <ul style="list-style-type:disc">
                           <li>
                              <p>应用程序运行受应用程序连续性限制的语句（例如， <code class="codeph">ALTER SYSTEM</code> ）。
                              </p>
                           </li>
                           <li>
                              <p>使用<code class="codeph">disableReplay</code>显式禁用应用程序连续性。
                              </p>
                           </li>
                           <li>
                              <p>当服务参数<code class="codeph">session_state_consistency</code>设置为<code class="codeph">Dynamic</code> （默认情况下，不使用Transparent Application Continuity时）时，将发出<code class="codeph">COMMIT</code>语句。
                              </p>
                           </li>
                           <li>
                              <p>发出<code class="codeph">endRequest</code>语句，直到发出下一个<code class="codeph">beginRequest</code> 。
                              </p>
                           </li>
                           <li>
                              <p>会话终止或断开，并指定<code class="codeph">NOREPLAY</code>关键字。
                              </p>
                           </li>
                        </ul>
                     </div>
                     <div>
                        <div class="relinfo">
                           <p><strong>相关话题</strong></p>
                           <ul>
                              <li><a href="ensuring-application-continuity.html#GUID-B2895452-68A1-45E5-A9A7-1888B7B10481">透明的应用程序连续性</a></li>
                              <li><a href="ensuring-application-continuity.html#GUID-696EB534-5B9C-49A9-902A-3F00169EC9AB">在应用程序连续性中禁用重播</a></li>
                              <li><a href="ensuring-application-continuity.html#GUID-9DD8DD6B-42E3-4248-ADA1-1763ABDA1302">在没有重播的情况下终止或断开会话</a></li>
                           </ul>
                        </div>
                     </div>
                  </div><a id="ADFNS1400"></a><div class="sect4"><a id="GUID-696EB534-5B9C-49A9-902A-3F00169EC9AB" name="GUID-696EB534-5B9C-49A9-902A-3F00169EC9AB"></a><h5 id="RACAD-GUID-696EB534-5B9C-49A9-902A-3F00169EC9AB" class="sect5">在应用程序连续性中禁用重播</h5>
                     <div>
                        <p>在可恢复的错误之后发生重播，但您可以禁用重播。</p>
                        <p>如果应用程序具有应用程序不希望重复的请求，则应用程序可以连接到未启用应用程序连续性的服务，或者可以显式调用API以禁用这些请求的重放。如果使用透明应用程序连续性，则会自动检测和禁用副作用。您无需了解应用程序或禁用带副作用的请求。</p>
                        <p>使用手动应用程序连续性时，将重播所有呼叫。例如，如果应用程序使用<code class="codeph">UTL_SMTP</code> ，并且不希望重复消息，则应用程序可以使用与其他服务的连接，或者在Java上使用<code class="codeph">disableReplay</code> API，或者在OCI上使用<code class="codeph">OCIRequestDisableReplay</code> API。所有其他请求继续被重播。
                        </p>
                        <p>对于具有外部操作的应用程序（例如，自治事务或使用<code class="codeph">UTL_HTTP</code>发出SOA调用），如果在失败后重放这些外部操作时保留应用程序的正确性，则应用程序连续性仍保持透明。
                        </p>
                        <p>以下规则是通用的。它们适用于重播工作的所有应用程序，包括应用程序连续性和TAF（12.2及更高版本）。</p>
                        <ul style="list-style-type:disc">
                           <li>
                              <p><a href="ensuring-application-continuity.html#GUID-E77EF392-91A1-46D6-A710-FE28175410AA">应用程序调用自治事务，外部PL / SQL或不应重复的Java操作</a></p>
                           </li>
                           <li>
                              <p><a href="ensuring-application-continuity.html#GUID-A2918D8A-4FF5-49D9-9A22-4A293CFF53A7">应用程序同步独立会话</a></p>
                           </li>
                           <li>
                              <p><a href="ensuring-application-continuity.html#GUID-50D0AD4B-7918-4B12-AEFC-5EF5D4681A52">应用程序在执行逻辑中使用中间层的时间</a></p>
                           </li>
                           <li>
                              <p><a href="ensuring-application-continuity.html#GUID-1FA03CA0-C6F1-4047-B038-C40799EDCDC3">应用程序假设ROWIds不会更改</a></p>
                           </li>
                           <li>
                              <p><a href="ensuring-application-continuity.html#GUID-84B97C49-F683-4053-9C56-48FC1B69BE4F">应用程序假定位置值不会更改</a></p>
                           </li>
                        </ul>
                     </div>
                     <div>
                        <div class="relinfo">
                           <p><strong>相关话题</strong></p>
                           <ul>
                              <li><a href="ensuring-application-continuity.html#GUID-B2895452-68A1-45E5-A9A7-1888B7B10481">透明的应用程序连续性</a></li>
                              <li><a href="ensuring-application-continuity.html#GUID-A250F3F8-D681-4F44-8969-7A8434E065DD">应用连续性的潜在副作用</a></li>
                              <li><a href="ensuring-application-continuity.html#GUID-2400FAAD-0BB2-48AF-B1F6-358EBA724028">应用程序连续性的限制和其他注意事项</a></li>
                           </ul>
                        </div>
                     </div><a id="ADFNS1414"></a><div class="sect5"><a id="GUID-E77EF392-91A1-46D6-A710-FE28175410AA" name="GUID-E77EF392-91A1-46D6-A710-FE28175410AA"></a><h6 id="RACAD-GUID-E77EF392-91A1-46D6-A710-FE28175410AA" class="sect6">应用程序调用自治事务，外部PL / SQL或不应重复的Java操作</h6>
                        <div>
                           <p>自治事务，外部PL / SQL调用和Java标注可能具有与主事务分开的副作用，除非另行指定，否则将重播这些副作用。</p>
                           <p>与主事务分开的副作用示例包括写入外部表，发送电子邮件，从PL / SQL分配会话（包括调用UTL_HTTP，UTL_URL，UTL_FILE，UTL_FILE_TRANSFER，UTL_SMPT，UTL_TCP，UTL_MAIL，DBMS_PIPE或DBMS_ALERT）或Java（包括以<span class="italic">Process proc = rt.exec（命令）;</span> ）的形式执行shell脚本，传输文件和访问外部URL。诸如此类的行为会产生持久的副作用。PL / SQL消息传递和Java标注可能会留下持久的结果。例如，如果用户在没有提交的情况下中途离开某些工作并且会话超时或者用户发出Ctrl + C，则前台或组件会失败;主要交易回滚，同时可能已应用副作用。（有关副作用的更多信息，请参阅<a href="ensuring-application-continuity.html#GUID-A250F3F8-D681-4F44-8969-7A8434E065DD" title="当您将FAILOVER_TYPE设置为TRANSACTION时使用应用程序连续性时，将重播留下副作用的语句。">应用程序连续性的潜在副作用</a> 。）
                           </p>
                           <p>应用程序开发人员决定是否允许重放外部操作。示例包括使用<code class="codeph">UTL_HTTP</code>发出SOA调用，或使用<code class="codeph">UTL_SMTP</code>发送消息，或使用<code class="codeph">UTL_URL</code>访问网站。如果不能重播此类外部操作，请使用不带AC的连接，或使用其中一个禁用重播API。</p>
                        </div>
                     </div><a id="ADFNS1415"></a><div class="sect5"><a id="GUID-A2918D8A-4FF5-49D9-9A22-4A293CFF53A7" name="GUID-A2918D8A-4FF5-49D9-9A22-4A293CFF53A7"></a><h6 id="RACAD-GUID-A2918D8A-4FF5-49D9-9A22-4A293CFF53A7" class="sect6">应用程序同步独立会话</h6>
                        <div>
                           <p>如果应用程序使用在<code class="codeph">COMMIT</code> ， <code class="codeph">ROLLBACK</code>或会话丢失之前保持的易失实体同步独立会话，则不得将应用程序配置为重播。例如，应用程序可能会同步连接到多个数据源的多个会话，否则这些数据源将使用诸如数据库锁之类的资源相互依赖。如果应用程序仅序列化这些会话并了解任何会话可能会失败，则可以接受此同步。但是，如果应用程序假定一个数据源持有的锁或任何其他易失性资源意味着对来自其他连接的相同或单独数据源的数据进行独占访问，则在重放时该假设可能无效。
                           </p>
                           <p>在重放期间，客户端驱动程序不知道会话依赖于持有锁或其他易失性资源的一个会话。您还可以使用管道，缓冲队列，获取资源（例如信号量，设备或套接字）的存储过程来实现由故障丢失的同步。</p>
                        </div>
                     </div><a id="ADFNS1416"></a><div class="sect5"><a id="GUID-50D0AD4B-7918-4B12-AEFC-5EF5D4681A52" name="GUID-50D0AD4B-7918-4B12-AEFC-5EF5D4681A52"></a><h6 id="RACAD-GUID-50D0AD4B-7918-4B12-AEFC-5EF5D4681A52" class="sect6">应用程序在执行逻辑中使用中间层的时间</h6>
                        <div>
                           <p>如果应用程序使用中间层的挂钟作为执行逻辑的一部分，则不得将应用程序配置为重放。客户端驱动程序不重复中间层时间逻辑，但使用作为此逻辑的一部分执行的数据库调用。例如，使用中间层时间的应用程序可能会假定在时间T1执行的语句不会在时间T2重新执行，除非应用程序明确这样做。</p>
                        </div>
                     </div><a id="ADFNS1417"></a><div class="sect5"><a id="GUID-1FA03CA0-C6F1-4047-B038-C40799EDCDC3" name="GUID-1FA03CA0-C6F1-4047-B038-C40799EDCDC3"></a><h6 id="RACAD-GUID-1FA03CA0-C6F1-4047-B038-C40799EDCDC3" class="sect6">应用程序假设ROWIds不会更改</h6>
                        <div>
                           <p>如果应用程序缓存ROWID，则由于数据库更改，对这些ROWID的访问可能会失效。虽然ROWID唯一标识表中的行，但ROWID可能会在以下情况下更改其值：</p>
                           <ul style="list-style-type:disc">
                              <li>
                                 <p>基础表重组。</p>
                              </li>
                              <li>
                                 <p>在表上创建索引。</p>
                              </li>
                              <li>
                                 <p>基础表是分区的。</p>
                              </li>
                              <li>
                                 <p>迁移基础表。</p>
                              </li>
                              <li>
                                 <p>使用EXP / IMP / DUL导出和导入基础表。</p>
                              </li>
                              <li>
                                 <p>使用Golden Gate或Logical Standby或其他复制技术重建基础表。</p>
                              </li>
                              <li>
                                 <p>闪回或恢复基础表的数据库。</p>
                              </li>
                           </ul>
                           <p>一般而言，Oracle不建议应用程序存储ROWID供以后使用，因为相应的行可能不存在或包含完全不同的数据。请注意，ROWID不会阻止使用应用程序连续性。重播可以被拒绝。</p>
                        </div>
                     </div><a id="ADFNS1419"></a><a id="ADFNS1418"></a><div class="sect5"><a id="GUID-84B97C49-F683-4053-9C56-48FC1B69BE4F" name="GUID-84B97C49-F683-4053-9C56-48FC1B69BE4F"></a><h6 id="RACAD-GUID-84B97C49-F683-4053-9C56-48FC1B69BE4F" class="sect6">应用程序假定位置值不会更改</h6>
                        <div>
                           <p><code class="codeph">SYSCONTEXT</code>选项包括与位置无关的集，例如国家语言支持（NLS）设置， <code class="codeph">ISDBA</code> ， <code class="codeph">CLIENT_IDENTIFIER</code> ， <code class="codeph">MODULE</code>和<code class="codeph">ACTION</code> ，以及使用物理定位器的位置相关集。通常，除测试环境外，应用程序不使用物理标识符。如果在主线代码中使用物理定位器，则重放会找到不匹配并拒绝它。但是，在请求之间（在<code class="codeph">beginRequest</code>之前）或回调中使用物理定位器是可以接受的。一个常见问题是QA修改测试应用程序以选择<code class="codeph">V$INSTANCE</code> 。由于<code class="codeph">V$INSTANCE</code>可以更改，只将此检查放入回调或在客户端本地选择实例，而不是从数据库中选择。
                           </p>
                           <div class="section">
                              <p class="subhead3" id="GUID-84B97C49-F683-4053-9C56-48FC1B69BE4F__GUID-96478102-7E44-4BD6-9B2E-9CB78DAB15AB">例</p>
                           </div>
                           <!-- class="section" --><pre class="oac_no_warn" dir="ltr">select sys_context（'USERENV'，'DB_NAME'），sys_context（'USERENV'，'HOST'），sys_context（'USERENV'，'INSTANCE'），sys_context（'USERENV'，'IP_ADDRESS'），sys_context（'USERENV' ，'ISDBA'），sys_context（'USERENV'，'SESSIONID'），sys_context（'USERENV'，'TERMINAL'），sys_context（'USERENV'，'SID'）来自dual;</pre></div>
                     </div>
                  </div><a id="ADFNS1426"></a><div class="sect4"><a id="GUID-9DD8DD6B-42E3-4248-ADA1-1763ABDA1302" name="GUID-9DD8DD6B-42E3-4248-ADA1-1763ABDA1302"></a><h5 id="RACAD-GUID-9DD8DD6B-42E3-4248-ADA1-1763ABDA1302" class="sect5">在没有重播的情况下终止或断开会话</h5>
                     <div>
                        <p>如果配置了应用程序连续性，并且DBA使用<code class="codeph">ALTER SYSTEM KILL SESSION</code>或<code class="codeph">ALTER SYSTEM DISCONNECT SESSION</code>语句终止或断开会话，则默认情况下，Application Continuity会尝试恢复会话。但是，如果您<span class="italic">不</span>希望重播会话，请使用<code class="codeph">NOREPLAY</code>关键字，如下所示：</p><pre class="pre codeblock"><code>alter system kill <span class="variable" translate="no">sid, serial#, @inst</span> <span class="bold">inst'noreplay</span> ; alter system disconnect <span class="variable" translate="no">sid, serial#, @inst</span> <span class="bold">inst'noreplay</span> $ srvctl stop service -db orcl -instance orcl2 -drain_timeout 60 -stopoption immediate -force -noreplay $ srvctl stop service -db orcl -node myode3 -noreplay -drain_timeout 60  - stopoption immediate -force $ srvctl stop instance -node mynode3 -drain_timeout 60 -stopoption immediate -force -noreplay</code></pre><p>要终止在本地实例上运行的所有会话（而不是只有一个会话）并且不重放会话，您还可以使用<code class="codeph">DBMS_SERVICE.DISCONNECT_SESSION</code> PL / SQL过程并为<code class="codeph">disconnect_option</code>参数指定<code class="codeph">NOREPLAY</code> 。
                        </p>
                     </div>
                     <div>
                        <div class="relinfo">
                           <p><strong>相关话题</strong></p>
                           <ul>
                              <li><a href="../sqlrf/ALTER-SYSTEM.html#SQLRF-GUID-2C638517-D73A-41CA-9D8E-A62D1A0B7ADB" target="_blank">改变系统</a></li>
                              <li><a href="../arpls/DBMS_SERVICE.html#ARPLS-GUID-5A0BA1FD-2B7E-47A0-A26A-D51C6EAF4409" target="_blank">DBMS_SERVICE.DISCONNECT_SESSION</a></li>
                           </ul>
                        </div>
                     </div>
                  </div>
               </div><a id="ADFNS1204"></a><a id="ADFNS1203"></a><div class="sect3"><a id="GUID-E4A114A2-EA77-4037-A62A-BDFCF1E6D072" name="GUID-E4A114A2-EA77-4037-A62A-BDFCF1E6D072"></a><h4 id="RACAD-GUID-E4A114A2-EA77-4037-A62A-BDFCF1E6D072" class="sect4">可变功能和应用连续性</h4>
                  <div>
                     <p>重放请求时，可变对象的默认和期望处理可能会有所不同。</p>
                     <p><span class="bold">可变函数</span>是一种非确定性函数，每次调用它都可以获得一个新值。可变函数的一个示例是对<code class="codeph">SYSTIMESTAMP</code>函数的调用。使用Application Continuity的客户端应用程序可以确定在重放请求时是否保留可变函数的原始值。
                     </p>
                     <p>目前为<code class="codeph">SYSDATE</code> ， <code class="codeph">SYSTIMESTAMP</code> ， <code class="codeph">SYS_GUID</code>和<code class="codeph"><span class="variable" translate="no">sequence</span></code>提供了对保持可变函数值的支持<code class="codeph">.NEXTVAL</code> 。如果未保留原始值，并且如果将这些可变对象的不同值返回给客户端，则拒绝重放，因为客户端会观察到不同的结果。如果应用程序可以使用原始值，则使用所拥有序列的<code class="codeph">KEEP</code>子句和其他用户的<code class="codeph">GRANT KEEP</code>配置可变函数。（对于绑定变量的一致性，大多数应用程序需要保持重放的序列值。）
                     </p>
                     <div class="infoboxnote" id="GUID-E4A114A2-EA77-4037-A62A-BDFCF1E6D072__GUID-7BD2EFD7-32F3-4E48-9B7E-BDD987A2FA67">
                        <p class="notep1">注意：</p>仅对串行执行计划支持保持<code class="codeph">SYS_GUID</code>值。使用并行查询时，Application Continuity无法恢复<code class="codeph">SYS_GUID</code>原始值。</div>
                     <p><a href="ensuring-application-continuity.html#GUID-E4A114A2-EA77-4037-A62A-BDFCF1E6D072__BABHFHHB" title="在重放期间通过产品（称为产品1，产品2和产品3）处理可变功能的示例">表6-4</a>显示了在重放期间产品处理可变功能的示例。（实际实施取决于特定产品和版本。）
                     </p>
                     <div class="tblformal" id="GUID-E4A114A2-EA77-4037-A62A-BDFCF1E6D072__BABHFHHB">
                        <p class="titleintable">表6-4重播过程中产品对可变对象的处理示例</p>
                        <table cellpadding="4" cellspacing="0" class="Formal" title="在重放期间按产品处理可变对象的示例" width="100%" border="1" summary="Example treatment of mutable functions by products (called Product 1, Product 2, and Product 3) during replay" frame="hsides" rules="rows">
                           <thead>
                              <tr align="left" valign="top">
                                 <th align="left" valign="bottom" width="34%" id="d23610e9567">可变功能</th>
                                 <th align="left" valign="bottom" width="24%" id="d23610e9570">产品1</th>
                                 <th align="left" valign="bottom" width="21%" id="d23610e9573">产品2</th>
                                 <th align="left" valign="bottom" width="21%" id="d23610e9576">产品3</th>
                              </tr>
                           </thead>
                           <tbody>
                              <tr align="left" valign="top">
                                 <td align="left" valign="top" width="34%" id="d23610e9581" headers="d23610e9567 ">
                                    <p><code class="codeph">SYSDATE</code> ， <code class="codeph">SYSTIMESTAMP</code></p>
                                 </td>
                                 <td align="left" valign="top" width="24%" headers="d23610e9581 d23610e9570 ">
                                    <p>原版的</p>
                                 </td>
                                 <td align="left" valign="top" width="21%" headers="d23610e9581 d23610e9573 ">
                                    <p>原版的</p>
                                 </td>
                                 <td align="left" valign="top" width="21%" headers="d23610e9581 d23610e9576 ">
                                    <p>当前</p>
                                 </td>
                              </tr>
                              <tr align="left" valign="top">
                                 <td align="left" valign="top" width="34%" id="d23610e9598" headers="d23610e9567 ">
                                    <p>序列<code class="codeph">NEXTVAL</code>和<code class="codeph">CURRVAL</code></p>
                                 </td>
                                 <td align="left" valign="top" width="24%" headers="d23610e9598 d23610e9570 ">
                                    <p>原版的</p>
                                 </td>
                                 <td align="left" valign="top" width="21%" headers="d23610e9598 d23610e9573 ">
                                    <p>原版的</p>
                                 </td>
                                 <td align="left" valign="top" width="21%" headers="d23610e9598 d23610e9576 ">
                                    <p>（不适用）</p>
                                 </td>
                              </tr>
                              <tr align="left" valign="top">
                                 <td align="left" valign="top" width="34%" id="d23610e9616" headers="d23610e9567 ">
                                    <p><code class="codeph">SYS_GUID</code></p>
                                 </td>
                                 <td align="left" valign="top" width="24%" headers="d23610e9616 d23610e9570 ">
                                    <p>原版的</p>
                                 </td>
                                 <td align="left" valign="top" width="21%" headers="d23610e9616 d23610e9573 ">
                                    <p>（不适用）</p>
                                 </td>
                                 <td align="left" valign="top" width="21%" headers="d23610e9616 d23610e9576 ">
                                    <p>（不适用）</p>
                                 </td>
                              </tr>
                           </tbody>
                        </table>
                     </div>
                     <!-- class="inftblhruleinformal" -->
                     <p>允许应用程序连续性在重放时保留并使用原始函数结果：</p>
                     <ul style="list-style-type:disc">
                        <li>
                           <p>运行应用程序的数据库用户可能具有<code class="codeph">KEEP DATE TIME</code>和<code class="codeph">KEEP SYSGUID</code>权限，并且<code class="codeph">KEEP SEQUENCE</code>对象具有要保留其值的每个序列的特权。例如：</p><pre class="pre codeblock"><code>授予用户2的日期时间;授予用户2的SYSGUID;授予sales.seq1至user2的GRANT KEEP SEQUENCE;</code></pre><div class="infoboxnote" id="GUID-E4A114A2-EA77-4037-A62A-BDFCF1E6D072__GUID-4E323586-9AAA-42E4-B205-09FFB9328E87">
                              <p class="notep1">笔记：</p>
                              <ul style="list-style-type:disc">
                                 <li>
                                    <p><code class="codeph">GRANT ALL ON <span class="variable" translate="no">object</span></code> <span class="italic">不</span>包括（即不授予提供的访问权限） <code class="codeph">KEEP DATE TIME</code>和<code class="codeph">KEEP SYSGUID</code>权限以及<code class="codeph">KEEP SEQUENCE</code>对象权限。
                                    </p>
                                 </li>
                                 <li>
                                    <p>授予与可变功能相关的权限仅支持应用程序用户，并且每个应用程序用户仅授予必要的权限。</p>
                                 </li>
                                 <li>
                                    <p><span class="italic"><span class="bold">不要</span></span>授予DBA权限来运行您想要的应用程序的数据库用户重播启用。
                                    </p>
                                 </li>
                              </ul>
                           </div>
                        </li>
                        <li>
                           <p>应用程序中的序列可以使用<code class="codeph">KEEP</code>属性，该属性保留<code class="codeph"><span class="variable" translate="no">sequence</span></code>的原始值<code class="codeph">.序列所有者的NEXTVAL</code> ，以便在重放期间密钥匹配。大多数应用程序需要保持重放的序列值。以下示例为序列设置<code class="codeph">KEEP</code>属性（在本例中，执行语句的用户拥有该属性;对于其他<code class="codeph">GRANT KEEP SEQUENCE</code> ，使用<code class="codeph">GRANT KEEP SEQUENCE</code> ）：</p><pre class="pre codeblock"><code>SQL&gt; CREATE SEQUENCE my_seq KEEP; SQL&gt;  - 或者，如果序列已经存在但没有KEEP：SQL&gt; ALTER SEQUENCE my_seq KEEP;</code></pre><div class="infoboxnote" id="GUID-E4A114A2-EA77-4037-A62A-BDFCF1E6D072__GUID-E6BB8A33-1FD3-42CC-B379-9513EB15668D">
                              <p class="notep1">注意：</p>指定<code class="codeph">ALTER SEQUENCE ...KEEP/NOKEEP</code>适用于序列的所有者。它不会影响具有<code class="codeph">KEEP SEQUENCE</code>对象权限的其他用户（不是所有者）。如果您希望所有用户都使用<code class="codeph">NOKEEP</code> ，那么请确保<span class="italic">不要</span>将<code class="codeph">KEEP SEQUENCE</code>对象权限授予这些用户（或者如果已授予权限，则从每个用户撤消该权限）。
                           </div>
                        </li>
                        <li>
                           <p>为了在重放时保持函数结果（对于命名函数），DBA必须向调用该函数的用户授予<code class="codeph">KEEP</code>特权。此安全限制确保它对重播有效，以保存和恢复不属于该用户的代码的功能结果。
                           </p>
                        </li>
                     </ul>
                  </div>
                  <div>
                     <div class="relinfo">
                        <p><strong>相关话题</strong></p>
                        <ul>
                           <li><a href="ensuring-application-continuity.html#GUID-C8C97971-5440-49C8-BFA2-541AEDCD8853" title="这些注意事项适用于授予和撤销可变功能的权限。">Mutables赠款规则</a></li>
                           <li><a href="../sqlrf/ALTER-SEQUENCE.html#SQLRF-GUID-A6468B63-E7C9-4EF0-B048-82FE2449B26D" target="_blank">更改顺序</a></li>
                           <li><a href="https://www.oracle.com/pls/topic/lookup?ctx=en/database/oracle/oracle-database/19/racad&amp;id=SQLRF-GUID-20B4E2C0-A7F8-4BC8-A5E8-BE61BDC41AC3" target="_blank">GRANT</a></li>
                        </ul>
                     </div>
                  </div>
               </div>
               <div class="sect3"><a id="GUID-3EADEA74-3224-48B5-9376-ABE3B34429B0" name="GUID-3EADEA74-3224-48B5-9376-ABE3B34429B0"></a><h4 id="RACAD-GUID-3EADEA74-3224-48B5-9376-ABE3B34429B0" class="sect4">管理可变值</h4>
                  <p>要管理可变值，您需要授予某些特权。</p>
                  <div class="sect4"><a id="GUID-2DDC256E-A15F-406C-B292-CBD38D887128" name="GUID-2DDC256E-A15F-406C-B292-CBD38D887128"></a><h5 id="RACAD-GUID-2DDC256E-A15F-406C-B292-CBD38D887128" class="sect5">授予和撤销保留Mutable的权限</h5>
                     <div>
                        <p>要在重放时保持函数结果，必须为调用该函数的用户授予<code class="codeph">KEEP</code>特权。
                        </p>
                        <ul id="GUID-2DDC256E-A15F-406C-B292-CBD38D887128__STEPS-UNORDERED_AKH_RLJ_LHB">
                           <li class="stepexpand"><span>授予和撤销许可，以保持<a href="glossary.html#GUID-386FA371-4D78-40FD-9E7E-96EB59CCE2E3"><span class="xrefglossterm">mutables</span></a>为Oracle日期和<code class="codeph">SYS_GUID</code> ：</span><div><pre class="pre codeblock"><code>GRANT [KEEP DATE_TIME | KEEP SYS_GUID] ... [对<span class="variable" translate="no">USER</span> ] REVOKE [KEEP DATE_TIME | KEEP SYS_GUID] ... [来自<span class="variable" translate="no">USER</span> ]</code></pre><p>例如，对于可能的Oracle电子商务套件使用原始日期：</p><pre class="pre codeblock"><code>GRANT KEEP DATE_TIME，将SYS_GUID保持为[自定义用户]; GRANT KEEP DATE_TIME，将SYS_GUID保持为[apps user];</code></pre></div>
                           </li>
                        </ul>
                     </div>
                  </div>
                  <div class="sect4"><a id="GUID-1A1C0B10-CD5A-42F8-BE21-ED74B362E2CA" name="GUID-1A1C0B10-CD5A-42F8-BE21-ED74B362E2CA"></a><h5 id="RACAD-GUID-1A1C0B10-CD5A-42F8-BE21-ED74B362E2CA" class="sect5">授予为Oracle序列保留可变项的权限</h5>
                     <div>
                        <p>要保留<code class="codeph">sequence.nextval</code>的原始值以进行重放以使密钥匹配，您必须为序列授予权限。
                        </p>
                        <ul id="GUID-1A1C0B10-CD5A-42F8-BE21-ED74B362E2CA__STEPS-UNORDERED_AKH_RLJ_LHB">
                           <li class="stepexpand"><span>授予作为序列所有者的权限：</span><div><pre class="pre codeblock"><code>CREATE SEQUENCE [sequence object] [KEEP | NOKEEP]; ALTER SEQUENCE [序列对象] [KEEP | NOKEEP];</code></pre></div>
                           </li>
                           <li class="stepexpand"><span>使用序列授予和撤消其他人的权限：</span><div><pre class="pre codeblock"><code>GRANT KEEP序列... [给<span class="variable" translate="no">USER</span> ] [上<span class="variable" translate="no">sequence object</span> ]; REVOKE KEEP SEQUENCE ... [来自<span class="variable" translate="no">USER</span> ] [ <span class="variable" translate="no">sequence object</span> ];</code></pre><p>例如，对于可能的Oracle E-Business Suite使用原始序列值：</p><pre class="pre codeblock"><code>授予[ <span class="variable" translate="no">sequence object</span> ]上的[应用程序用户]保留序列; GRANT保持[ <span class="variable" translate="no">sequence object</span> ]上[自定义用户]的<span class="variable" translate="no">sequence object</span> ;</code></pre></div>
                           </li>
                        </ul>
                     </div>
                  </div>
                  <div class="sect4"><a id="GUID-C8C97971-5440-49C8-BFA2-541AEDCD8853" name="GUID-C8C97971-5440-49C8-BFA2-541AEDCD8853"></a><h5 id="RACAD-GUID-C8C97971-5440-49C8-BFA2-541AEDCD8853" class="sect5">Mutables赠款规则</h5>
                     <div>
                        <p>这些注意事项适用于授予和撤销可变功能的权限。</p>
                        <ul id="GUID-C8C97971-5440-49C8-BFA2-541AEDCD8853__UL_OCP_DNJ_LHB" style="list-style-type:disc">
                           <li>
                              <p>如果为用户授予对象的所有权限，则排除可变项。Mutables需要明确的拨款。Oracle不支持向Oracle数据库提供或创建的用户授予可变项，例如SYS，AUDSYS，GSMUSER和SYSTEM。</p>
                           </li>
                           <li>
                              <p>DBA角色包括可变权限。</p>
                           </li>
                           <li>
                              <p>如果用户已授予mutable，则在调用可变函数时，对象将继承可变访问（在<code class="codeph">SYS_GUID</code> ， <code class="codeph">SYSDATE</code>和<code class="codeph">SYSTIMESTAMP</code> ）。
                              </p>
                           </li>
                           <li>
                              <p>如果撤消序列对象上的mutable，则使用该对象的SQL或PL / SQL命令不允许对该序列进行可变的收集或应用。</p>
                           </li>
                           <li>
                              <p>如果在运行时和故障转移之间撤消授权，则不会应用收集的可变对象。</p>
                           </li>
                           <li>
                              <p>如果在运行时和故障转移之间授予授权，则不会收集可变项，因此不会应用任何可变项。</p>
                           </li>
                        </ul>
                     </div>
                  </div>
               </div>
               <div class="sect3"><a id="GUID-987F5EE6-6C32-455A-AEF6-16066EE33F20" name="GUID-987F5EE6-6C32-455A-AEF6-16066EE33F20"></a><h4 id="RACAD-GUID-987F5EE6-6C32-455A-AEF6-16066EE33F20" class="sect4">保护级统计</h4>
                  <div>
                     <p>使用请求边界和保护级别的统计信息来监控覆盖级别。</p>
                     <div class="p">Application Continuity从系统，会话和服务收集统计信息，使您能够监控保护级别。统计信息在V $ SESSTAT，V $ SYSSTAT中可用，并且在启用服务统计信息时，在V $ SERVICE_STATS中可用。这些统计信息保存在自动工作负载存储库中，可在自动工作负载存储库报告中使用。统计包括：<ul style="list-style-type:disc">
                           <li>
                              <p>请求每秒完成</p>
                           </li>
                           <li>
                              <p>用户在请求中调用</p>
                           </li>
                           <li>
                              <p>受保护的用户呼叫</p>
                           </li>
                        </ul>输出类似于以下内容：<pre class="pre codeblock"><code>统计每秒每秒的总数---------------------------------------- ---- ---- ------------- ---------累积请求177,406 49.2 5.0请求累计用户呼叫493,329 136.8 13.8累计用户呼叫保护493,329 136.8 13.8</code></pre></div>
                     <p>要启用保护级别统计信息，请使用<code class="codeph">(_request_boundaries = 3)</code> 。
                     </p>
                  </div>
               </div><a id="ADFNS1432"></a><a id="ADFNS358"></a><div class="sect3"><a id="GUID-D49C131A-5931-473E-A878-AF4B99E97F1D" name="GUID-D49C131A-5931-473E-A878-AF4B99E97F1D"></a><h4 id="RACAD-GUID-D49C131A-5931-473E-A878-AF4B99E97F1D" class="sect4">会话状态一致性</h4>
                  <div>
                     <p>会话状态一致性描述了在请求期间如何更改非事务状态。</p>
                     <p>Oracle建议您使用透明应用程序连续性将<code class="codeph">session_state_consistency</code>设置为<code class="codeph">AUTO</code> ，以跟踪和管理会话状态。如果选择使用透明应用程序连续性，则无需执行任何其他操作即可确保会话状态一致性。
                     </p>
                     <p>您可以将<code class="codeph">session_state_consistency</code>设置为<code class="codeph">DYNAMIC</code>或<code class="codeph">STATIC</code>以手动应用程序连续性。如果您完全了解应用程序，则将<code class="codeph">session_state_consistency</code>设置为<code class="codeph">DYNAMIC</code>或<code class="codeph">STATIC</code> ，并且预计应用程序不会从值集更改。
                     </p>
                     <p>会话状态的示例包括NLS设置，优化程序首选项，事件设置，PL / SQL全局变量，临时表，高级队列，LOB和结果缓存。如果非事务值在已提交的事务中更改，则使用默认值<code class="codeph">DYNAMIC</code> （ <code class="codeph">session_state_consistency</code>是服务级别属性，其默认值为<code class="codeph">DYNAMIC</code> ）。
                     </p>
                     <p>使用<code class="codeph">DYNAMIC</code>模式，在<code class="codeph">COMMIT</code>执行后，如果该事务中的状态已更改，则如果会话丢失，则无法重播事务以重新建立该状态。可以根据初始设置之后的会话状态是静态还是动态来对应用程序进行分类，从而继续通过<code class="codeph">COMMIT</code>操作是否正确。
                     </p>
                     <p><code class="codeph">DYNAMIC</code>模式适用于几乎所有应用程序。如果您不确定，请使用<code class="codeph">DYNAMIC</code>模式。如果您的客户或用户可以修改您的应用程序，则必须使用<code class="codeph">DYNAMIC</code>模式。
                     </p>
                     <div class="infoboxnote" id="GUID-D49C131A-5931-473E-A878-AF4B99E97F1D__GUID-19018A12-29A9-4884-8512-04B978B1C6CE">
                        <p class="notep1">注意：</p>对于长时间运行的无状态应用程序，将<code class="codeph">session_state_consistency</code>设置为<code class="codeph">AUTO</code>或<code class="codeph">STATIC</code> 。对于非无状态的应用程序，请勿将<code class="codeph">session_state_consistency</code>设置为<code class="codeph">STATIC</code> 。除非您需要手动应用程序连续性，否则Oracle建议将<code class="codeph">session_state_consistency</code>设置为<code class="codeph">AUTO</code> 。</div>
                     <p>本节包括以下主题：</p>
                     <ul style="list-style-type:disc">
                        <li>
                           <p><a href="ensuring-application-continuity.html#GUID-FE576341-43A9-40EC-85EB-11A7CA9F5AE7" title="将session_state_consistency设置为AUTO时，透明应用程序连续性会跟踪并记录会话和事务状态，以便在可恢复的中断后恢复数据库会话。将session_state_consistency设置为AUTO是Transparent Application Continuity允许的唯一值。">自动会话状态一致性</a></p>
                        </li>
                        <li>
                           <p><a href="ensuring-application-continuity.html#GUID-B5FD2E5A-69BE-4BAC-9143-D79BFC993833" title="如果FAILOVER_RESTORE未完全恢复会话状态值，或者通过添加初始化回调，则会话具有动态状态。">动态会话状态一致性</a></p>
                        </li>
                        <li>
                           <p><a href="ensuring-application-continuity.html#GUID-E980359F-C3EB-403C-9115-ECFE4B1D2AF0" title="静态模式用于长时间运行的无状态应用程序。不要将静态模式用于非无状态的应用程序。">静态会话状态一致性</a></p>
                        </li>
                     </ul>
                  </div>
                  <div class="sect4"><a id="GUID-FE576341-43A9-40EC-85EB-11A7CA9F5AE7" name="GUID-FE576341-43A9-40EC-85EB-11A7CA9F5AE7"></a><h5 id="RACAD-GUID-FE576341-43A9-40EC-85EB-11A7CA9F5AE7" class="sect5">自动会话状态一致性</h5>
                     <div>
                        <p>将<code class="codeph">session_state_consistency</code>设置为<code class="codeph">AUTO</code> ，透明应用程序连续性会跟踪并记录会话和事务状态，以便在可恢复的中断后恢复数据库会话。将<code class="codeph">session_state_consistency</code>设置为<code class="codeph">AUTO</code>是Transparent Application Continuity允许的唯一值。
                        </p>
                        <p>设置为<code class="codeph">AUTO</code> ，状态跟踪基础结构会在应用程序发出用户调用时对会话状态使用情况进行分类。跟踪会话状态被监视和验证。
                        </p>
                     </div>
                  </div><a id="ADFNS359"></a><a id="ADFNS1433"></a><div class="sect4"><a id="GUID-B5FD2E5A-69BE-4BAC-9143-D79BFC993833" name="GUID-B5FD2E5A-69BE-4BAC-9143-D79BFC993833"></a><h5 id="RACAD-GUID-B5FD2E5A-69BE-4BAC-9143-D79BFC993833" class="sect5">动态会话状态一致性</h5>
                     <div>
                        <p>如果FAILOVER_RESTORE未完全恢复会话状态值，或者通过添加初始化回调，则会话具有<span class="bold">动态</span>状态。
                        </p>
                        <p>第一个事务完成后，将在内部禁用故障转移，直到下一个请求开始。在<code class="codeph">Dynamic</code>会话状态一致性模式中，在请求期间发生状态更改，并在下一个请求开始时启用重播。</p>
                        <p>如果在事务执行期间非事务会话状态更改，则将会话状态一致性模式设置为<code class="codeph">Dynamic</code> 。可以在运行时更改的非事务会话状态的示例是<code class="codeph">ALTER</code> <code class="codeph">SESSION</code> ，PL / SQL全局变量， <code class="codeph">SYS_CONTEXT</code>和临时表内容。如果应用程序在事务和提交中更改非事务状态，则无法重播此状态，并且状态设置必须为<code class="codeph">Dynamic</code> 。使用<code class="codeph">Dynamic</code>模式进行应用程序连续性时，在<code class="codeph">COMMIT</code>禁用重播，直到下一个请求开始。<code class="codeph">Dynamic</code>是默认值。
                        </p>
                        <p>当会话状态一致性模式为<code class="codeph">Dynamic</code>时，非事务会话状态（NTSS）在请求期间发生更改。
                        </p>
                        <div class="p">重播（即应用程序连续性）在<code class="codeph">beginRequest</code>调用时启用，并在<code class="codeph">COMMIT</code> ， <code class="codeph">endRequest</code>调用或受限调用上禁用。以下是三种应用场景的步骤逻辑：<ul style="list-style-type:disc">
                              <li>
                                 <p>没有交易</p>
                              </li>
                              <li>
                                 <p>使用<code class="codeph">COMMIT</code>作为最后一个语句的事务</p>
                              </li>
                              <li>
                                 <p>具有嵌入式<code class="codeph">COMMIT</code>语句的事务</p>
                              </li>
                           </ul>
                        </div>
                        <p>对于<span class="bold">没有事务</span>的请求，逻辑步骤如下：</p>
                        <ol>
                           <li>
                              <p>查看。</p>
                           </li>
                           <li>
                              <p>开始请求并启用重播。</p>
                           </li>
                           <li>
                              <p>发出一个或多个<code class="codeph">SELECT</code>语句以及其他PL / SQL语句。
                              </p>
                           </li>
                           <li>
                              <p>其他行为。</p>
                           </li>
                           <li>
                              <p>报到。</p>
                           </li>
                           <li>
                              <p>结束请求并禁用重播。</p>
                           </li>
                        </ol>
                        <p>对于<span class="bold">使用COMMIT作为最后一个语句的事务</span>的请求，逻辑步骤如下：</p>
                        <ol>
                           <li>
                              <p>查看。</p>
                           </li>
                           <li>
                              <p>开始请求并启用重播。</p>
                           </li>
                           <li>
                              <p>发出一个或多个<code class="codeph">SELECT</code>语句以及其他PL / SQL语句。
                              </p>
                           </li>
                           <li>
                              <p>交易开始了。</p>
                           </li>
                           <li>
                              <p>其他行为。</p>
                           </li>
                           <li>
                              <p>提交（禁用重播）。</p>
                           </li>
                           <li>
                              <p>报到。</p>
                           </li>
                           <li>
                              <p>结束请求。</p>
                           </li>
                        </ol>
                        <p>对于<span class="bold">带有嵌入式COMMIT语句的事务</span>的请求，逻辑步骤如下：</p>
                        <ol>
                           <li>
                              <p>查看。</p>
                           </li>
                           <li>
                              <p>开始请求并启用重播。</p>
                           </li>
                           <li>
                              <p>发出一个或多个<code class="codeph">SELECT</code>语句以及其他PL / SQL语句。
                              </p>
                           </li>
                           <li>
                              <p>交易开始了。</p>
                           </li>
                           <li>
                              <p>其他行为。</p>
                           </li>
                           <li>
                              <p>提交（禁用重播）。</p>
                           </li>
                           <li>
                              <p>其他操作，其中Application Continuity未涵盖应用程序。</p>
                           </li>
                           <li>
                              <p>报到。</p>
                           </li>
                           <li>
                              <p>结束请求。</p>
                           </li>
                        </ol>
                     </div>
                  </div><a id="ADFNS1420"></a><a id="ADFNS360"></a><div class="sect4"><a id="GUID-E980359F-C3EB-403C-9115-ECFE4B1D2AF0" name="GUID-E980359F-C3EB-403C-9115-ECFE4B1D2AF0"></a><h5 id="RACAD-GUID-E980359F-C3EB-403C-9115-ECFE4B1D2AF0" class="sect5">静态会话状态一致性</h5>
                     <div>
                        <p><code class="codeph">Static</code>模式用于长时间运行的无状态应用程序。不要将<code class="codeph">Static</code>模式用于非无状态的应用程序。
                        </p>
                        <p>将会话状态一致性模式设置为<code class="codeph">Static</code> ，仅当所有非事务状态更改（例如NLS设置， <code class="codeph">SYS_CONTEXT</code> ，PL / SQL变量和优化程序首选项）被设置为每个请求初始化一次时，并且此会话状态是否为在交易期间不会改变。例如，当使用<code class="codeph">FAILOVER_RESTORE=LEVEL1</code> ，回调或标签时，或者在每次从池中结账时，可以在连接建立时为每个连接建立一次设置。
                        </p>
                        <p>将<code class="codeph">Static</code>模式用于应用程序连续性时，事务性故障转移将继续超出请求的第一个事务。这对于设置<code class="codeph">beginRequest</code>一次并运行长处理操作（如批处理作业和长报告）的应用程序非常有用。
                        </p>
                        <p>使用在事务中更改非事务状态的调用的应用程序不支持静态模式。此类电话的具体示例包括：</p>
                        <ul style="list-style-type:disc">
                           <li>
                              <p>PL / SQL子程序</p>
                           </li>
                           <li>
                              <p><code class="codeph">SYS_CONTEXT</code></p>
                           </li>
                           <li>
                              <p><code class="codeph">ALTER</code> <code class="codeph">SESSION</code></p>
                           </li>
                        </ul>
                        <p>请谨慎指定静态模式。仅当应用程序未更改事务内的非事务性会话状态时，才使用静态模式。将会话状态一致性模式声明为<code class="codeph">Static</code>表示在请求中的第一个<code class="codeph">COMMIT</code>之后继续安全。动态模式适用于大多数应用程序。<span class="italic">不要</span>使用静态模式下，如果用户或客户可以修改或定制应用程序。
                        </p>
                        <p>当会话状态一致性模式为<code class="codeph">Static</code>时，非事务性会话状态在请求期间保持不变（即，不更改）。
                        </p>
                        <p>重播（即，应用程序连续性）在<code class="codeph">beginRequest</code>调用时启用，并在受限调用， <code class="codeph">disableReplay</code>或<code class="codeph">OCIRequestDisableReplay</code>调用或<code class="codeph">OCIRequestDisableReplay</code>调用上<code class="codeph">endRequest</code> 。
                        </p>
                        <div class="p">以下是三种应用场景的步骤逻辑：<ul style="list-style-type:disc">
                              <li>
                                 <p>没有交易</p>
                              </li>
                              <li>
                                 <p>一个或多个事务，每个事务以<code class="codeph">COMMIT</code>结尾作为最后一个语句</p>
                              </li>
                              <li>
                                 <p>具有<code class="codeph">COMMIT</code>语句的事务，后跟具有禁用应用程序连续性的受限调用的事务</p>
                              </li>
                           </ul>
                        </div>
                        <p>对于<span class="bold">没有事务</span>的请求，逻辑步骤如下：</p>
                        <ol>
                           <li>
                              <p>查看。</p>
                           </li>
                           <li>
                              <p>开始请求并启用重播。</p>
                           </li>
                           <li>
                              <p>发出一个或多个<code class="codeph">SELECT</code>语句以及其他PL / SQL语句。
                              </p>
                           </li>
                           <li>
                              <p>其他行为。</p>
                           </li>
                           <li>
                              <p>报到。</p>
                           </li>
                           <li>
                              <p>结束请求并禁用重播。</p>
                           </li>
                        </ol>
                        <p>在<code class="codeph">endRequest</code> ，受限制的呼叫以及显式的<code class="codeph">disableReplay</code>或<code class="codeph">OCIRequestDisableReplay</code>调用中禁用重播。
                        </p>
                        <p>对于具有<span class="bold">一个或多个事务</span>的请求<span class="bold">（每个事务都使用COMMIT作为最后一个语句）</span> ，逻辑步骤如下：</p>
                        <ol>
                           <li>
                              <p>查看。</p>
                           </li>
                           <li>
                              <p>开始请求并启用重播。</p>
                           </li>
                           <li>
                              <p>发出一个或多个<code class="codeph">SELECT</code>语句以及其他PL / SQL语句。
                              </p>
                           </li>
                           <li>
                              <p>交易开始了。</p>
                           </li>
                           <li>
                              <p>交易提交。</p>
                           </li>
                           <li>
                              <p>交易被清除。</p>
                              <p>（对于每个附加事务，将发生步骤4到6。）</p>
                           </li>
                           <li>
                              <p>其他行为。</p>
                           </li>
                           <li>
                              <p>报到。</p>
                           </li>
                           <li>
                              <p>结束请求。</p>
                           </li>
                        </ol>
                        <p>在<code class="codeph">endRequest</code> ，受限制的呼叫以及显式的<code class="codeph">disableReplay</code>或<code class="codeph">OCIRequestDisableReplay</code>调用中禁用重播。
                        </p>
                        <p>对于<span class="bold">具有COMMIT的事务</span>的请求， <span class="bold">后跟具有受限调用的事务</span> ，逻辑步骤如下：</p>
                        <ol>
                           <li>
                              <p>查看。</p>
                           </li>
                           <li>
                              <p>开始请求并启用重播。</p>
                           </li>
                           <li>
                              <p>发出一个或多个<code class="codeph">SELECT</code>语句以及其他PL / SQL语句。
                              </p>
                           </li>
                           <li>
                              <p>交易开始了。</p>
                           </li>
                           <li>
                              <p>交易提交。</p>
                           </li>
                           <li>
                              <p>交易被清除。</p>
                           </li>
                           <li>
                              <p>第二笔交易开始了。</p>
                           </li>
                           <li>
                              <p>事务进行限制调用，导致应用程序连续性被禁用。</p>
                           </li>
                           <li>
                              <p>交易被清除。</p>
                           </li>
                           <li>
                              <p>其他行为</p>
                           </li>
                           <li>
                              <p>报到。</p>
                           </li>
                           <li>
                              <p>结束请求。</p>
                           </li>
                        </ol>
                        <p>在<code class="codeph">endRequest</code> ，受限制的呼叫以及显式的<code class="codeph">disableReplay</code>或<code class="codeph">OCIRequestDisableReplay</code>调用中禁用重播。
                        </p>
                     </div>
                     <div>
                        <div class="relinfo">
                           <p><strong>相关话题</strong></p>
                           <ul>
                              <li><a href="ensuring-application-continuity.html#GUID-751D4D16-BE2C-44DC-9A7B-20348E4EC24B" title="将FAILOVER_RESTORE设置为LEVEL1（用于手动应用程序连续性）或AUTO（用于透明应用程序连续性）会在重放请求之前自动恢复常见状态初始设置。">FAILOVER_RESTORE = LEVEL1或AUTO</a></li>
                           </ul>
                        </div>
                     </div>
                  </div>
               </div>
            </div><a id="ADFNS1205"></a><div class="sect2"><a id="GUID-A250F3F8-D681-4F44-8969-7A8434E065DD" name="GUID-A250F3F8-D681-4F44-8969-7A8434E065DD"></a><h3 id="RACAD-GUID-A250F3F8-D681-4F44-8969-7A8434E065DD" class="sect3">应用连续性的潜在副作用</h3>
               <div>
                  <p>当您将<code class="codeph">FAILOVER_TYPE</code>设置为<code class="codeph">TRANSACTION</code>时使用应用程序连续性时，将重播留下副作用的语句。
                  </p>
                  <div class="infoboxnote" id="GUID-A250F3F8-D681-4F44-8969-7A8434E065DD__GUID-4D50642E-BF16-44FD-9C42-CBBF75BEA4DE">
                     <p class="notep1">注意：</p>作为应用程序所有者，您可以选择禁用包含您不想重复的副作用的请求的重播。禁用副作用的最简单方法是使用透明应用程序连续性（将<code class="codeph">FAILOVER_TYPE</code>设置为<code class="codeph">AUTO</code> ，这会为您禁用副作用。
                  </div>
                  <p>应用程序连续性按时间顺序重放PL / SQL以恢复数据库状态。这用于重建会话，就像用户提交被延迟一样。大多数应用程序都希望重建完整状态，就像重复提交一样，例如编写报告或完成一些审核。但是，为构建状态而重放的操作可能包括一些您希望采取措施以适应或减轻重放影响的操作。某些应用程序选择禁用包含他们不想重复的调用的请求的重播。</p>
                  <p>产生副作用的操作示例包括：</p>
                  <ul style="list-style-type:disc">
                     <li>
                        <p><code class="codeph">DBMS_ALERT</code>调用（电子邮件或其他通知）</p>
                     </li>
                     <li>
                        <p><code class="codeph">DBMS_FILE_TRANSFER</code>调用（复制文件）</p>
                     </li>
                     <li>
                        <p><code class="codeph">DBMS_PIPE</code>和RPC调用（到外部源）</p>
                     </li>
                     <li>
                        <p><code class="codeph">UTL_FILE</code>调用（写文本文件）</p>
                     </li>
                     <li>
                        <p><code class="codeph">UTL_HTTP</code>调用（发出HTTP调用）</p>
                     </li>
                     <li>
                        <p><code class="codeph">UTL_MAIL</code>调用（发送电子邮件）</p>
                     </li>
                     <li>
                        <p><code class="codeph">UTL_SMTP</code>调用（发送SMTP消息）</p>
                     </li>
                     <li>
                        <p><code class="codeph">UTL_TCP</code>调用（发送TCP消息）</p>
                     </li>
                     <li>
                        <p><code class="codeph">UTL_URL</code>调用（访问URL）</p>
                     </li>
                  </ul>
                  <p>对于具有外部操作的应用程序（例如自主事务或使用<code class="codeph">UTL_HTTP</code>发出面向服务的应用程序（SOA）调用），当应用程序满足重放外部操作（例如重新发送电子邮件，审核和传输）时，应用程序连续性是透明的。文件。
                  </p>
               </div>
               <div>
                  <div class="relinfo">
                     <p><strong>相关话题</strong></p>
                     <ul>
                        <li><a href="ensuring-application-continuity.html#GUID-696EB534-5B9C-49A9-902A-3F00169EC9AB" title="在可恢复的错误之后发生重播，但您可以禁用重播。">在应用程序连续性中禁用重播</a></li>
                     </ul>
                  </div>
               </div>
            </div><a id="ADFNS1206"></a><div class="sect2"><a id="GUID-2400FAAD-0BB2-48AF-B1F6-358EBA724028" name="GUID-2400FAAD-0BB2-48AF-B1F6-358EBA724028"></a><h3 id="RACAD-GUID-2400FAAD-0BB2-48AF-B1F6-358EBA724028" class="sect3">应用程序连续性的限制和其他注意事项</h3>
               <div>
                  <p>使用应用程序连续性时，请注意这些限制和注意事项。</p>
                  <ul style="list-style-type:disc">
                     <li>
                        <div class="p">应用程序连续性不包括：<ul style="list-style-type:disc">
                              <li>
                                 <p>JDBC OCI驱动程序（类型2）</p>
                              </li>
                              <li>
                                 <p>ODP.NET，托管驱动程序</p>
                              </li>
                              <li>
                                 <p>OLE DB</p>
                              </li>
                              <li>
                                 <p>ODBC</p>
                              </li>
                           </ul>
                        </div>
                     </li>
                     <li>
                        <p>对于使用JDBC的应用程序，不支持<code class="codeph">oracle.sql</code>不推荐使用的具体类： <code class="codeph">BLOB</code> ， <code class="codeph">CLOB</code> ， <code class="codeph">BFILE</code> ， <code class="codeph">OPAQUE</code> ， <code class="codeph">ARRAY</code> ， <code class="codeph">STRUCT</code>或<code class="codeph">ORADATA</code> 。</p>
                     </li>
                     <li>
                        <p>对于流论证，重放是在“尽力而为”的基础上进行的。例如，如果应用程序使用的是物理地址，则地址已经中断，无法重新定位。例如，JDBC流设置器（例如<code class="codeph">setBinaryStream</code> ）会导致重放被禁用。
                        </p>
                     </li>
                     <li>
                        <p>重放目标数据库必须与源数据库位于同一数据库集群（Oracle RAC，Oracle Data Guard，Oracle Active Data Guard或Oracle Multitenant）中。</p>
                        <p>为了保护业务事务的完整性，如果目标是不同的数据库，或者它是相同的数据库或相同的可插拔数据库但是数据丢失，例如一个闪回，通过介质恢复未完全恢复，或打开，则应用程序连续性不会重放由Oracle Data Guard提前做好。</p>
                     </li>
                     <li>
                        <p>对于OCI和ODP.NET，在Oracle Database 12 <span class="italic">c第</span> 2版（12.2.0.1）中，OCI驱动程序上的应用程序连续性排除了ADT，提前队列和一些LOB API。这些排除项不适用于Java。
                        </p>
                     </li>
                     <li>
                        <p>如果启用了应用程序服务器级别的语句高速缓存（例如，WebLogic或第三方应用程序服务器语句高速缓存），则在使用重放时必须禁用此高速缓存。相反，请配置JDBC语句缓存，该缓存执行得更好，因为它针对JDBC和Oracle进行了优化，并且因为它支持应用程序连续性。使用<code class="codeph">oracle.jdbc.implicitstatementcachesize= <span class="variable" translate="no">nnn</span></code> 。
                        </p>
                     </li>
                     <li>
                        <p>从Oracle Database 12第2版（12.2）开始，Java和ODP.NET，非托管驱动程序的XA数据源支持重放。重播支持本地事务。使用两阶段时重播静默禁用。这使得Application Continuity能够与可升级的XA以及使用XA数据源且大多数不使用XA的应用程序一起工作。</p>
                     </li>
                     <li>
                        <p>如果请求发出<code class="codeph">ALTER SYSTEM</code>或<code class="codeph">ALTER DATABASE</code>语句，则禁用重播。
                        </p>
                     </li>
                     <li>
                        <p>对于被认为不安全重建会话的<code class="codeph">ALTER SESSION</code>语句，在请求级别禁用重播。这些包括用于设置支持级别事件以及禁用和启用<code class="codeph">COMMIT IN PROCEDURE</code>和<code class="codeph">GUARD</code>语句。</p>
                        <p>但是，重播支持应用程序级别的<code class="codeph">ALTER SESSION</code>语句。这些包括全球化支持（NLS）设置，存储和私有大纲，设置容器（CDB / PDB），SQL跟踪和PL / SQL警告的语句。
                        </p>
                     </li>
                     <li>
                        <p>如果您使用带有读/写数据库链接的Oracle Active Data Guard返回主数据库，则不支持重播。这是Transaction Guard的安全限制。</p>
                     </li>
                     <li>
                        <p>当这是语句级故障时，重放不适用于并行查询调用的失败。例如，在<code class="codeph">ORA-12805:parallel query server died unexpectedly</code>之后不会发生重放<code class="codeph">ORA-12805:parallel query server died unexpectedly</code>实例或节点故障或内存问题期间遇到的呼叫失败的错误。
                        </p>
                     </li>
                     <li>
                        <p>仅限Java，重播不支持DRCP。支持专用和共享服务器。</p>
                     </li>
                     <li>
                        <p>该请求使用2PC XA。从Oracle Database 12 <span class="italic">c第</span> 2版（12.2）开始，可升级XA和使用XA数据源支持应用程序连续性，而XA未使用。
                        </p>
                     </li>
                  </ul>
                  <div class="infoboxnote" id="GUID-2400FAAD-0BB2-48AF-B1F6-358EBA724028__GUID-1B619C90-0D61-4E64-B443-67E07D696EE2">
                     <p class="notep1">注意：</p>如果要通过拆分磁盘映像（例如，BCV）或通过克隆来创建数据库克隆，那么它是一个“不同”的数据库，以创建不是物理或Oracle Active Data Guard数据库的逻辑备用或逻辑副本，那么<code class="codeph">nid</code> <span class="italic"><span class="bold">必须</span></span>用于更改DBID以区分数据库。
                  </div>
               </div>
               <div>
                  <div class="relinfo">
                     <p><strong>相关话题</strong></p>
                     <ul>
                        <li><a href="../lnoci/high-availability-in-oci.html#LNOCI-GUID-D30079AC-4E59-4CC3-86E8-6487A4891BA2" target="_blank">当OCI中的应用程序连续性可以故障转移时</a></li>
                        <li><a href="https://support.oracle.com/rs?type=doc&amp;id=863800.1" target="_blank">如何使用NID实用程序更改DBID，DBNAME（My Oracle Support Doc ID 863800.1）</a></li>
                     </ul>
                  </div>
               </div>
            </div><a id="RACAD8423"></a><div class="sect2"><a id="GUID-097A5067-8CCF-4FF0-B97B-BF109DFA1841" name="GUID-097A5067-8CCF-4FF0-B97B-BF109DFA1841"></a><h3 id="RACAD-GUID-097A5067-8CCF-4FF0-B97B-BF109DFA1841" class="sect3">用于改善客户端故障转移的事务防护</h3>
               <div>
                  <p>Transaction Guard可防止应用程序连续性重播的事务被多次应用。</p>
                  <p>未能认识到最后一次提交已经提交，或者它将很快提交，或者最后一次提交尚未完成，对于应用程序来说是一个问题。它可能导致重新提交的用户或使用自己的重播的应用程序发出重复请求，重复已提交到数据库的更改以及其他形式的逻辑损坏。Transaction Guard可用于解决此问题。</p>
                  <p>Application Continuity自动启用和使用Transaction Guard，但您也可以单独启用Transaction Guard。如果应用程序已实现应用程序级重放，则需要将应用程序与Transaction Guard集成以提供幂等性。</p>
                  <p>在Oracle Database <span class="italic">12c中</span> ，Transaction Guard为应用程序提供了一个新的，完全集成的工具，用于以可扩展的方式自动，透明地实现幂等性。Transaction Guard使用逻辑事务ID（LTXID）来避免提交重复的事务。这被称为<span class="italic">交易幂等</span> 。LTXID在提交时仍然存在，并在回滚后重用。在正常运行时期间，LTXID会自动保存在客户端和服务器的会话中，以用于每个数据库事务。在提交时，LTXID作为提交事务的一部分被持久化，并且要使用的下一个LTXID被返回给客户端。
                  </p>
                  <div class="section">
                     <p class="subhead2" id="GUID-097A5067-8CCF-4FF0-B97B-BF109DFA1841__GUID-CE9857DD-5524-4704-B666-8936CFD0545F">XA事务的事务保护</p>
                     <p>Transaction Guard还支持基于XA的事务，这些事务是事务管理器的选项，例如Oracle WebLogic Server，Oracle Tuxedo和MicroSoft Transaction Server（通过Oracle ODP.NET公开给Oracle数据库）。</p>
                     <p>对于XA事务，Transaction Guard支持可在Oracle WebLogic Server上的XA事务可恢复中断后提供安全重放。通过添加XA支持，Oracle WebLogic Server可以使用Transaction Guard提供强制执行的幂等重放。</p>
                  </div>
                  <!-- class="section" -->
                  <div class="section">本节包括以下主题：<ul style="list-style-type:disc">
                        <li>
                           <p><a href="ensuring-application-continuity.html#GUID-E3DA6FA0-B139-4877-83A1-FDE559AD5DFE">Transaction Guard配置清单</a></p>
                        </li>
                        <li>
                           <p><a href="ensuring-application-continuity.html#GUID-E61555E3-B694-4F20-85BB-D4650ACBAEFE" title="要配置服务以使用Transaction Guard，请设置以下服务参数：">为Transaction Guard配置服务</a></p>
                        </li>
                        <li>
                           <p><a href="ensuring-application-continuity.html#GUID-DEF850F6-27E9-428E-B8FC-530230D78AD2" title="当Oracle Net Services建立与实例的连接时，连接将保持打开状态，直到客户端关闭连接，实例关闭或发生故障。">使用TAF故障转移OCI客户端</a></p>
                        </li>
                     </ul>
                  </div>
                  <!-- class="section" -->
               </div>
               <div>
                  <div class="relinfo">
                     <p><strong>相关话题</strong></p>
                     <ul>
                        <li><a href="https://www.oracle.com/pls/topic/lookup?ctx=en/database/oracle/oracle-database/19/racad&amp;id=ADFNS-GUID-0D79C66F-A106-412F-9EE6-7D43CBFE2AB5" target="_blank"><span><cite>Oracle数据库开发指南</cite></span></a></li>
                        <li><a href="../adfns/transaction-guard.html#ADFNS-GUID-6C5880E5-C45F-4858-A069-A28BB25FD1DB" target="_blank"><span><cite>Oracle数据库开发指南</cite></span></a></li>
                        <li><a href="../jjdbc/transaction-guard.html#JJDBC-GUID-6F363D40-9EEB-4D34-B085-B5BF4E988D38" target="_blank"><span><cite>Oracle数据库JDBC开发人员指南</cite></span></a></li>
                     </ul>
                  </div>
               </div><a id="RACAD8663"></a><div class="sect3"><a id="GUID-E3DA6FA0-B139-4877-83A1-FDE559AD5DFE" name="GUID-E3DA6FA0-B139-4877-83A1-FDE559AD5DFE"></a><h4 id="RACAD-GUID-E3DA6FA0-B139-4877-83A1-FDE559AD5DFE" class="sect4">Transaction Guard配置清单</h4>
                  <div>
                     <p>在为Transaction Guard配置服务之前，请使用以下配置清单：</p>
                     <ul style="list-style-type:disc">
                        <li>
                           <p>向将调用<code class="codeph">GET_LTXID_OUTCOME</code>的应用程序用户授予权限，如下所示：</p><pre class="oac_no_warn" dir="ltr">GRANT EXECUTE DBMS_APP_CONT到<span class="italic">user_name</span> ;</pre><div class="infoboxnote" id="GUID-E3DA6FA0-B139-4877-83A1-FDE559AD5DFE__GUID-4C5E8D1F-5F93-477D-86B2-886C227D5D18">
                              <p class="notep1">注意：</p>如果使用应用程序连续性，请<span class="italic">不要</span>运行此语句。
                           </div>
                        </li>
                        <li>
                           <p>找到并定义事务历史记录表以获得最佳性能。</p>
                           <p>该<a id="d23610e12617" class="indexterm-anchor"></a><a id="d23610e12619" class="indexterm-anchor"></a>默认情况下，在创建或升级Oracle数据库时，会在SYSAUX表空间中创建事务历史记录表（ <code class="codeph">LTXID_HIST</code> ）。使用最后一个分区的存储添加实例时，会添加新分区。如果事务历史记录表的位置不是性能的最佳位置，那么您可以将其移动到另一个表空间并在那里创建分区。例如，以下语句将事务历史记录表移动到名为FastPace的表空间：</p><pre class="oac_no_warn" dir="ltr">ALTER TABLE LTXID_TRANS移动分区LTXID_TRANS_1表空间FastPace存储（初始10G下10G minextents 1 maxextents 121）;</pre></li>
                        <li>
                           <p>设置<code class="codeph">-commit_outcome</code>和<code class="codeph">-retention</code>服务参数的值。
                           </p>
                        </li>
                        <li>
                           <p>如果您使用的是Oracle RAC，Oracle Data Guard或Oracle Active Data Guard，那么Oracle建议您使用FAN快速通知中断。</p>
                        </li>
                     </ul>
                  </div>
               </div><a id="RACAD8664"></a><div class="sect3"><a id="GUID-E61555E3-B694-4F20-85BB-D4650ACBAEFE" name="GUID-E61555E3-B694-4F20-85BB-D4650ACBAEFE"></a><h4 id="RACAD-GUID-E61555E3-B694-4F20-85BB-D4650ACBAEFE" class="sect4">为Transaction Guard配置服务</h4>
                  <div>
                     <p>要配置服务以使用Transaction Guard，请设置以下服务参数：</p>
                     <ul style="list-style-type:disc">
                        <li>
                           <p><span class="bold"><code class="codeph">-commit_outcome</code></span> ：将<code class="codeph">-commit_outcome</code>服务参数设置为<code class="codeph">TRUE</code> 。此服务参数确定在执行COMMIT并发生中断后是否可以访问事务<a href="glossary.html#GUID-86C1CD88-560A-46FD-80F8-BDA0340D7189"><span class="xrefglossterm">提交结果</span></a> 。虽然Oracle数据库始终使COMMIT持久，但Transaction Guard使COMMIT <span class="italic">的结果</span>持久，并且应用程序使用它来强制执行在中断之前执行的最后一个事务的状态。
                           </p>
                        </li>
                        <li>
                           <p><span class="bold"><code class="codeph">-retention</code></span> ：将<code class="codeph">-retention</code> service参数与<code class="codeph">-commit_outcome</code>一起<code class="codeph">-commit_outcome</code> 。此服务参数确定保留COMMIT结果的时间量（以秒为单位）。Oracle建议大多数安装使用默认值。
                           </p>
                        </li>
                     </ul>
                     <p>以下SRVCTL命令为Transaction Guard配置名为<code class="codeph">sales</code>的策略管理服务：</p><pre class="pre codeblock"><code>$ srvctl add service -db crm -service sales -serverpool spool_1 -commit_outcome TRUE -retention 86400 -notification TRUE</code></pre><p>以下SRVCTL命令为Transaction Guard配置名为<code class="codeph">sales</code>的管理员管理的服务：</p><pre class="pre codeblock"><code>$ srvctl add service -db crm -service sales -preferred crm_1，crm_2 -available crm_3，crm_4 -commit_outcome TRUE -retention 86400 -notification TRUE</code></pre><p>您还可以使用<code class="codeph">srvctl modify service</code>命令修改现有服务以为Transaction Guard配置它。
                     </p>
                     <div class="infoboxnote" id="GUID-E61555E3-B694-4F20-85BB-D4650ACBAEFE__GUID-7811D577-095C-4FBD-A325-FC0A47819792">
                        <p class="notep1">注意：</p>
                        <p>请勿使用缺省数据库服务，即名称设置为<code class="codeph">db_name</code>或<code class="codeph">db_unique_name</code> 。默认服务用于管理目的，与用户创建的服务不具有相同的属性。
                        </p>
                     </div>
                  </div>
                  <div>
                     <div class="relinfo">
                        <p><strong>相关话题</strong></p>
                        <ul>
                           <li><a href="server-control-utility-reference.html#GUID-EC1BA6D7-D538-4E11-9B31-C59389FDF93B" title="将服务添加到数据库并将其分配给实例。">srvctl添加服务</a></li>
                           <li><a href="server-control-utility-reference.html#GUID-DCA45A3F-78AD-4259-A8C3-8FCE49A0F4BC" title="修改服务配置。">srvctl修改服务</a></li>
                           <li><a href="ensuring-application-continuity.html#GUID-BD699AEB-9F85-42A8-8687-5A979918938D" title="应用程序连续性通过还原数据库会话从应用程序和用户屏蔽许多可恢复的数据库中断（当重放成功时）：完整会话，包括所有状态，游标，变量和最后一个事务（如果有）。">关于应用程序连续性</a></li>
                           <li><a href="../jjdbc/transaction-guard.html#JJDBC-GUID-DFD6DD11-127F-40F1-94CC-22AEC53BBFFF" target="_blank"><span><cite>Oracle数据库JDBC开发人员指南</cite></span></a></li>
                           <li><a href="../lnoci/high-availability-in-oci.html#LNOCI-GUID-6A12DE3A-479A-4D06-8305-AA450BFF6B23" target="_blank"><span><cite>Oracle调用接口程序员指南</cite></span></a></li>
                        </ul>
                     </div>
                  </div>
               </div>
            </div>
            <div class="sect2"><a id="GUID-DEF850F6-27E9-428E-B8FC-530230D78AD2" name="GUID-DEF850F6-27E9-428E-B8FC-530230D78AD2"></a><h3 id="RACAD-GUID-DEF850F6-27E9-428E-B8FC-530230D78AD2" class="sect3">使用TAF故障转移OCI客户端</h3>
               <div>
                  <p>当Oracle Net Services建立与实例的连接时，连接将保持打开状态，直到客户端关闭连接，实例关闭或发生故障。</p>
                  <p>如果为连接配置透明应用程序故障转移（TAF），则Oracle数据库会在发生中断时在正常运行的实例上重放会话。</p>
                  <p>故障转移完成后，TAF可以重新启动查询，但对于其他类型的事务，例如<code class="codeph">INSERT</code> ， <code class="codeph">UPDATE</code>或<code class="codeph">DELETE</code> ，应用程序必须回滚失败的事务并重新提交事务。如果未将<code class="codeph">FAILOVER_RESTORE</code>设置为<code class="codeph">LEVEL1</code>或<code class="codeph">AUTO</code>则还必须在发生故障转移后重新执行任何会话自定义，换句话说， <code class="codeph">ALTER SESSION</code>语句。但是，使用TAF时，即使工作负载随时间变化，也不会在正常处理期间移动连接。
                  </p>
                  <p>服务简化了TAF的部署。您可以为服务定义TAF策略，使用此服务的所有连接将自动启用TAF。这不需要任何客户端更改。服务上的TAF设置会覆盖客户端连接定义中的任何TAF设置。</p>
                  <p>您可以通过定义<code class="codeph">-failovermethod</code>和<code class="codeph">-failovertype</code>参数为服务的所有用户定义TAF策略。您可以通过设置失败的会话尝试重新连接到服务的次数以及在重新连接尝试之间使用<code class="codeph">-failoverretry</code>和<code class="codeph">-failoverdelay</code>参数分别等待多长时间来进一步定义TAF策略。
                  </p>
                  <p>要为服务定义TAF策略，请使用SRVCTL，如以下示例所示，其中服务名称为<code class="codeph">tafconn.example.com</code> ，数据库名称为CRM：</p><pre class="pre codeblock"><code>$ srvctl modify service -db crm -service tafconn.example.com -failovermethod BASIC -failovertype SELECT -failoverretry 10 -failoverdelay 30</code></pre><p>启用TAF的OCI应用程序应使用FAN高可用性事件进行快速连接故障转移。</p>
                  <div class="section">
                     <p class="subhead2" id="GUID-DEF850F6-27E9-428E-B8FC-530230D78AD2__GUID-63B12C8C-FC92-4D37-A887-D5722734FDAE">TAF支持Transaction Guard和FAILOVER_RESTORE</p>
                     <p>当您使用Transaction Guard时，TAF会为开发人员管理错误。当您同时使用TAF和Transaction Guard时，开发人员可以使用TAF错误回滚并安全地重新提交或返回未提交的事务（对于TAF错误代码ORA-25402，ORA-25408，ORA-25405）。</p>
                     <p>当您使用<code class="codeph">FAILOVER_RESTORE</code> ，TAF会自动恢复常见状态，从而避免了大多数应用程序需要回调。
                     </p>
                  </div>
                  <!-- class="section" -->
               </div>
               <div>
                  <div class="relinfo">
                     <p><strong>相关话题</strong></p>
                     <ul>
                        <li><a href="ensuring-application-continuity.html#GUID-751D4D16-BE2C-44DC-9A7B-20348E4EC24B" title="将FAILOVER_RESTORE设置为LEVEL1（用于手动应用程序连续性）或AUTO（用于透明应用程序连续性）会在重放请求之前自动恢复常见状态初始设置。">FAILOVER_RESTORE = LEVEL1或AUTO</a></li>
                     </ul>
                  </div>
               </div>
            </div>
         </div>
      </article>
   </body>
</html>