<!DOCTYPE html
  SYSTEM "about:legacy-compat">
<html xml:lang="en-us" lang="en-us">
   <head>
      <meta http-equiv="Content-Type" content="text/html; charset=utf-8">
      <meta name="viewport" content="width=device-width, initial-scale=1">
      <meta http-equiv="X-UA-Compatible" content="IE=edge">
      <meta name="abstract" content="Application Continuity is a feature that enables the replay, in a non-disruptive and rapid manner, of a request against the database after a recoverable error that makes the database session unavailable so an outage appears to the user as no more than a delayed execution of the request.">
      <meta name="description" content="Application Continuity is a feature that enables the replay, in a non-disruptive and rapid manner, of a request against the database after a recoverable error that makes the database session unavailable so an outage appears to the user as no more than a delayed execution of the request.">
      <title>Ensuring Application Continuity</title>
      <meta property="og:site_name" content="Oracle Help Center">
      <meta property="og:title" content="Real Application Clusters Administration and Deployment Guide">
      <meta property="og:description" content="Application Continuity is a feature that enables the replay, in a non-disruptive and rapid manner, of a request against the database after a recoverable error that makes the database session unavailable so an outage appears to the user as no more than a delayed execution of the request.">
      <link rel="stylesheet" href="/sp_common/book-template/ohc-book-template/css/book.css">
      <link rel="shortcut icon" href="/sp_common/book-template/ohc-common/img/favicon.ico">
      <meta name="application-name" content="Real Application Clusters Administration and Deployment Guide">
      <meta name="generator" content="DITA Open Toolkit version 1.8.5 (Mode = doc)">
      <meta name="plugin" content="SP_docbuilder HTML plugin release 18.2.2">
      <link rel="alternate" href="real-application-clusters-administration-and-deployment-guide.pdf" title="PDF File" type="application/pdf">
      <meta name="robots" content="all">
      <link rel="schema.dcterms" href="http://purl.org/dc/terms/">
      <meta name="dcterms.created" content="2019-04-25T14:02:30-07:00">
      <meta name="dcterms.title" content="Real Application Clusters Administration and Deployment Guide">
      <meta name="dcterms.dateCopyrighted" content="1999, 2019">
      <meta name="dcterms.category" content="database">
      <meta name="dcterms.identifier" content="E95728-03">
      
      <meta name="dcterms.product" content="en/database/oracle/oracle-database/19">
      
      <link rel="prev" href="workload-management-with-dynamic-database-services.html" title="Previous" type="text/html">
      <link rel="next" href="configuring-recovery-manager-and-archiving.html" title="Next" type="text/html">
      <script>
        document.write('<style type="text/css">');
        document.write('body > .noscript, body > .noscript ~ * { visibility: hidden; }');
        document.write('</style>');
     </script>
      <script data-main="/sp_common/book-template/ohc-book-template/js/book-config" src="/sp_common/book-template/requirejs/require.js"></script>
      <script>
            if (window.require === undefined) {
                document.write('<script data-main="sp_common/book-template/ohc-book-template/js/book-config" src="sp_common/book-template/requirejs/require.js"><\/script>');
                document.write('<link href="sp_common/book-template/ohc-book-template/css/book.css" rel="stylesheet"/>');
            }
        </script>
      <script type="application/json" id="ssot-metadata">{"primary":{"category":{"short_name":"database","element_name":"Database","display_in_url":true},"suite":{"short_name":"oracle","element_name":"Oracle","display_in_url":true},"product_group":{"short_name":"not-applicable","element_name":"Not applicable","display_in_url":false},"product":{"short_name":"oracle-database","element_name":"Oracle Database","display_in_url":true},"release":{"short_name":"19","element_name":"Release 19","display_in_url":true}}}</script>
      
    <meta name="dcterms.isVersionOf" content="RACAD">
    <meta name="dcterms.release" content="Release 19">
  </head>
   <body>
      <div class="noscript alert alert-danger text-center" role="alert">
         <a href="workload-management-with-dynamic-database-services.html" class="pull-left"><span class="glyphicon glyphicon-chevron-left" aria-hidden="true"></span>Previous</a>
         <a href="configuring-recovery-manager-and-archiving.html" class="pull-right">Next<span class="glyphicon glyphicon-chevron-right" aria-hidden="true"></span></a>
         <span class="fa fa-exclamation-triangle" aria-hidden="true"></span> JavaScript must be enabled to correctly display this content
        
      </div>
      <article>
         <header>
            <ol class="breadcrumb" vocab="http://schema.org/" typeof="BreadcrumbList">
               <li property="itemListElement" typeof="ListItem"><a href="index.html" property="item" typeof="WebPage"><span property="name">Real Application Clusters Administration and Deployment Guide</span></a></li>
               <li class="active" property="itemListElement" typeof="ListItem">Ensuring Application Continuity</li>
            </ol>
            <a id="GUID-C1EF6BDA-5F90-448F-A1E2-DC15AD5CFE75" name="GUID-C1EF6BDA-5F90-448F-A1E2-DC15AD5CFE75"></a>
            
            <h2 id="RACAD-GUID-C1EF6BDA-5F90-448F-A1E2-DC15AD5CFE75" class="sect2"><span class="enumeration_chapter">6 </span>Ensuring Application Continuity
            </h2>
         </header>
         <div class="ind">
            <div>
               <p><span class="bold">Application Continuity</span> is a feature that enables the replay, in a non-disruptive and rapid manner, of a request against the database after a recoverable error that makes the database session unavailable so an outage appears to the user as no more than a delayed execution of the request.
               </p>
               <p>The request can contain transactional and non-transactional work. After a successful replay, the application can continue where that database session left off, instead of having users left in doubt, not knowing what happened to their funds transfers, flight bookings, and so on, and avoiding the need to reboot mid-tier servers to recover from an overload of log ins when the application comes back online. With Application Continuity, the end-user experience is improved by masking many outages, planned and unplanned, without the application developer needing to attempt to recover the request.</p>
               <p>Without Application Continuity, it can be almost impossible for an application to mask outages in a safe way, for reasons that include the following:</p>
               <ul style="list-style-type: disc;">
                  <li>
                     <p>The state at the client remains at present time, with entered data, returned data, and variables cached.</p>
                  </li>
                  <li>
                     <p>If a <code class="codeph">COMMIT</code> has been issued, then the <code class="codeph">COMMIT</code> failure message cannot be retrieved if it is not received by the client or the application.
                     </p>
                  </li>
                  <li>
                     <p>Checking the status of an in-doubt tansaction at a point in time is no guarantee that it will not <code class="codeph">COMMIT</code> later.
                     </p>
                  </li>
                  <li>
                     <p>Non-transactional database session state that the application needs to operate is lost.</p>
                  </li>
                  <li>
                     <p>If the request can continue, the database and the database session must be in the right state.</p>
                  </li>
               </ul>
               <p>With Application Continuity, however, Oracle Database, the Oracle drivers, and the Oracle connection pools all collaborate to mask many outages in a safe and reliable way.</p>
               <p>Application Continuity improves developer productivity by attempting to mask outages that can be masked. However, applications still must include error handling for these cases:</p>
               <ul style="list-style-type: disc;">
                  <li>
                     <p><span class="italic">Nonrecoverable</span> errors, such as invalid input data. (Application Continuity applies only to recoverable errors.)
                     </p>
                  </li>
                  <li>
                     <p>Recoverable errors when replay has encountered a restriction, such as use of concrete classes in the application, or when replay has not been able to restore the client-visible state to that on which the client may have made decisions so far.</p>
                  </li>
               </ul>
               <p>Introduced in Oracle Database 12<span class="italic">c</span> Release 1 (12.1.0.1), Application Continuity strengthens the fault tolerance of systems and applications that use an Oracle database.
               </p>
               <p></p>
               <p>This chapter assumes that you are familiar with the major relevant concepts and techniques of the technology or product environment in which you are using Application Continuity, such as Oracle WebLogic Server, Oracle RAC, or Oracle Active Data Guard (Oracle ADG).</p>
               <p>This chapter includes the following topics:</p>
               <ul style="list-style-type: disc;">
                  <li>
                     <p><a href="ensuring-application-continuity.html#GUID-EB0E1525-D3B3-469C-BE22-A569C76864A6" title="The Oracle RAC high availability framework monitors a database and its services and sends event notifications using Fast Application Notification (FAN).">Fast Application Notification</a></p>
                  </li>
                  <li>
                     <p><a href="ensuring-application-continuity.html#GUID-27F35F42-080C-49F2-976E-DB073ACCBFEB" title="You can assign services to one or more instances in an administrator-managed Oracle RAC database or to server pools in a policy-managed database.">Managing Unplanned Outages</a></p>
                  </li>
                  <li>
                     <p><a href="ensuring-application-continuity.html#GUID-11B75A54-CEF7-4113-A72F-9E7AAFE61953" title="For repairs, upgrades, and changes that require you to isolate one or more instances or nodes, Oracle RAC provides interfaces that relocate, disable, and enable services to minimize service disruption to application users.">Managing Planned Maintenance</a></p>
                  </li>
                  <li>
                     <p><a href="ensuring-application-continuity.html#GUID-BD699AEB-9F85-42A8-8687-5A979918938D" title="Application Continuity masks many recoverable database outages (when replay is successful) from applications and users by restoring the database session: the full session, including all states, cursors, variables, and the last transaction if there is one.">About Application Continuity</a></p>
                  </li>
                  <li>
                     <p><a href="ensuring-application-continuity.html#GUID-91427DA2-2C5F-46E9-93D4-B5FF6427A69B" title="This section explains how Application Continuity works, and how you can use it in applications.">Application Continuity Operation and Usage</a></p>
                  </li>
                  <li>
                     <p><a href="ensuring-application-continuity.html#GUID-A250F3F8-D681-4F44-8969-7A8434E065DD" title="When you use Application Continuity with FAILOVER_TYPE set to TRANSACTION, statements that leave side effects are replayed.">Potential Side Effects of Application Continuity</a></p>
                  </li>
                  <li>
                     <p><a href="ensuring-application-continuity.html#GUID-2400FAAD-0BB2-48AF-B1F6-358EBA724028" title="Be aware of these restrictions and considerations when using Application Continuity.">Restrictions and Other Considerations for Application Continuity</a></p>
                  </li>
                  <li>
                     <p><a href="ensuring-application-continuity.html#GUID-097A5067-8CCF-4FF0-B97B-BF109DFA1841" title="Transaction Guard prevents a transaction being replayed by Application Continuity from being applied more than once.">Transaction Guard for Improving Client Failover</a></p>
                  </li>
                  <li>
                     <p><a href="ensuring-application-continuity.html#GUID-DEF850F6-27E9-428E-B8FC-530230D78AD2" title="When Oracle Net Services establishes a connection to an instance, the connection remains open until the client closes the connection, the instance is shutdown, or a failure occurs.">Failing Over OCI Clients with TAF</a></p>
                  </li>
               </ul>
            </div><a id="RACAD7128"></a><div class="sect2"><a id="GUID-EB0E1525-D3B3-469C-BE22-A569C76864A6" name="GUID-EB0E1525-D3B3-469C-BE22-A569C76864A6"></a><h3 id="RACAD-GUID-EB0E1525-D3B3-469C-BE22-A569C76864A6" class="sect3">Fast Application Notification</h3>
               <div>
                  <p>The Oracle RAC high availability framework monitors a database and its services and sends event notifications using Fast Application Notification (FAN).</p>
                  <p>Oracle Database focuses on maintaining the highest possible service availability. In Oracle RAC, services are designed to be continuously available with loads shared across one or more instances. The Oracle RAC high-availability framework maintains service availability by using Oracle Clusterware and resource profiles. Oracle Clusterware recovers and balances services according to business rules and the service attributes.</p>
                  <p>This section includes the following topics:</p>
                  <ul style="list-style-type: disc;">
                     <li>
                        <p><a href="ensuring-application-continuity.html#GUID-AC79F7FE-2446-4178-A699-3859FFA5651A" title="FAN provides immediate interrupt of clients following outages related to the database, nodes, and networks.">Overview of Fast Application Notification</a></p>
                     </li>
                     <li>
                        <p><a href="ensuring-application-continuity.html#GUID-8856EACC-DB95-4F15-ABED-B20234F0678D" title="This section describes the information delivered in the FAN event to a callout program.">Fast Application Notification High Availability Events</a></p>
                     </li>
                     <li>
                        <p><a href="ensuring-application-continuity.html#GUID-807BA413-6348-482D-A53C-462F5BBAE5A8">Subscription to High Availability Events</a></p>
                     </li>
                     <li>
                        <p><a href="ensuring-application-continuity.html#GUID-2024CEF8-F984-4377-9182-E17F738A4715" title="FAN callouts are server-side executables that Oracle RAC executes immediately when high availability events occur.">Using Fast Application Notification Callouts</a></p>
                     </li>
                  </ul>
               </div>
               <div>
                  <div class="relinfo">
                     <p><strong>Related Topics</strong></p>
                     <ul>
                        <li><a href="workload-management-with-dynamic-database-services.html#GUID-074729CB-8A91-419C-A6E1-3B9E4FD8D869" title="The overall goals of FAN are to enable end-to-end, lights-out recovery of applications and load balancing based on real transaction performance.Enabling Fast Connection Failover (FCF) for Universal Connection Pool and Oracle WebLogic Server Active GridLink for Oracle RAC enables the use of FAN HA and load balancing advisory events.You can enable FCF for Universal Connection Pool or Implicit Connection Cache.Run-time connection load balancing requires the use of an Oracle JDBC driver and an Oracle RAC database.The Replay data source (oracle.jdbc.replay.OracleDataSource) is a JDBC-thin data source that Application Continuity requires for Java.Transaction Guard provides a protocol and a generic tool for applications to use for at-most-once execution in case of planned and unplanned outages.As of Oracle Database 12c, OCI session pooling enables multiple threads of an application to use a dynamically managed set of pre-created database sessions.OCI supports FAN messages and Transaction Guard. FAN is designed to quickly notify an OCI-based application of outages at the node, database, instance, service, and public network levels.ODP.NET connection pools can subscribe to FAN HA notifications that indicate when nodes, services, and service members are down.When connecting to Oracle Database 12c and later, ODP.NET uses Oracle Notification Service, rather than Advanced Queuing.ODP.NET supports FAN messages and Transaction Guard. FAN is designed to quickly notify an ODP.NET-based application of outages at the node, database, instance, service, and public network levels.">Enabling Clients for Oracle RAC</a></li>
                     </ul>
                  </div>
               </div><a id="RACAD8845"></a><a id="RACAD7301"></a><div class="sect3"><a id="GUID-AC79F7FE-2446-4178-A699-3859FFA5651A" name="GUID-AC79F7FE-2446-4178-A699-3859FFA5651A"></a><h4 id="RACAD-GUID-AC79F7FE-2446-4178-A699-3859FFA5651A" class="sect4">Overview of Fast Application Notification</h4>
                  <div>
                     <p>FAN provides immediate interrupt of clients following outages related to the database, nodes, and networks.</p>
                     <p>FAN is essential to break clients out of TCP/IP timeouts immediately following failures. FAN notifies clients immediately when resources become available and initiates draining of database sessions so clients experience no outages during planned maintenance. FAN also includes notifying configuration- and service-level information that includes changes in service status.</p>
                     <p>The Oracle client drivers and Oracle connection pools respond to FAN events and take immediate action. FAN UP and DOWN events apply to services, databases, instances, networks, and nodes.</p>
                     <div class="infoboxnote" id="GUID-AC79F7FE-2446-4178-A699-3859FFA5651A__GUID-9B09D33B-6974-4139-9741-E48A1FB79AD2">
                        <p class="notep1">Note:</p>FAN is supported starting with Oracle Database 10<span class="italic">g</span> release 2 (10.2).
                     </div>
                     <p>Oracle connection pools, for example, use FAN to receive very fast notification of failures, to balance connections following failures, and to balance connections again after the failed components are repaired. So, when a service at an instance starts, the connection pool uses the FAN event to route work to that resource, immediately. When a service at an instance or node fails, the connection pool uses the FAN event to immediately interrupt applications to recover. FAN is essential to prevent applications from hanging on TCP/IP timeouts.</p>
                     <div class="section">
                        <p class="subhead3" id="GUID-AC79F7FE-2446-4178-A699-3859FFA5651A__GUID-E99B7177-5293-4C63-BE35-B973CA88355B">Importance of FAN</p>
                        <p>Applications can waste time in many critical ways:</p>
                        <ul style="list-style-type: disc;" id="GUID-AC79F7FE-2446-4178-A699-3859FFA5651A__UL_RH3_SCK_LHB">
                           <li>
                              <p>Waiting for TCP/IP timeouts when a node fails without closing sockets, and for every subsequent connection while that IP address is down.</p>
                           </li>
                           <li>
                              <p>Attempting to connect when services are down.</p>
                           </li>
                           <li>
                              <p>Not connecting when services resume.</p>
                           </li>
                           <li>
                              <p>Processing the last result at the client when the server goes down.</p>
                           </li>
                           <li>
                              <p>Attempting to execute work on sub-optimal nodes.</p>
                           </li>
                        </ul>
                        <p>When a node fails without closing sockets, all sessions that are blocked in an I/O wait (read or write) wait for <code class="codeph">tcp_keepalive</code>. This wait status is the typical condition for an application connected by a socket. Sessions processing the last result are even worse off, not receiving an interrupt until the next data is requested. Using FAN events eliminates applications waiting on TCP timeouts, time wasted processing the last result at the client after a failure has occurred, and time wasted executing work on slow, hung, or dead nodes.
                        </p>
                        <p>For cluster configuration changes, the Oracle RAC high availability framework publishes a FAN event immediately when a state change occurs in the cluster. Instead of waiting for the application to time out against the database and detect a problem, applications can receive FAN events and react immediately. With FAN, in-flight transactions are immediately terminated and the client notified when the instance fails.</p>
                        <p>FAN also publishes load balancing advisory events. Applications can take advantage of the load balancing advisory FAN events to direct work requests to the instance in the cluster that is currently providing the best service quality.</p>
                        <p>Oracle Database 12<span class="italic">c</span> release 2 (12.2) client drivers are FAN-aware, and FAN is enabled, by default. This includes the JDBC Thin driver (12.2.0.1) and Oracle Data Provider for Net (ODP.NET) drivers. A client driver can detect planned and unplanned FAN events and take action beneath the application.
                        </p>
                        <p>For planned maintenance and applications using OCI or Pro* (and not using the OCI session pool or Tuxedo), an application must check <code class="codeph">OCI_ATTR_SERVER_STATUS</code>. Add this check when sessions are returned to your own connection pool, and for idle connections, regularly.
                        </p>
                        <p>Following a FAN down event with planned maintenance, this attribute is set to <code class="codeph">OCI_SERVER_NOT_CONNECTED</code>. The application closes the connection after reading this disconnected status. The session remains open for draining of active work until the application closes, providing error-free failover.
                        </p>
                        <p id="GUID-AC79F7FE-2446-4178-A699-3859FFA5651A__YOUCANTAKEADVANTAGEOFFANEVENTSINTHE-3EFD813C">You can take advantage of FAN events in the following ways:</p>
                        <ul style="list-style-type: disc;" id="GUID-AC79F7FE-2446-4178-A699-3859FFA5651A__UL_G2K_WCK_LHB">
                           <li id="GUID-AC79F7FE-2446-4178-A699-3859FFA5651A__BABDFDFJ">
                              <p>Applications can use FAN without programmatic changes if you use an integrated Oracle client. The integrated clients for FAN events include Oracle JDBC Universal Connection Pool, ODP.NET connection pool, OCI session pool, Oracle WebLogic Server Active Gridlink for Oracle RAC, and OCI and ODP.NET clients. The integrated Oracle clients must be Oracle Database 10<span class="italic">g</span> release 2 (10.2) or later to take advantage of the FAN high-availability events. The pooled clients can also take advantage of the load balancing advisory FAN events.
                              </p>
                           </li>
                           <li>
                              <p>You can configure third-party application containers, such as those provided by Apache Tomcat and WebSphere, to use the built-in FAN support offered by using the Universal Connection Pool in place of the default pool, which is certified as a connection pool for third-party Java application servers including Apache Tomcat and WebSphere.</p>
                           </li>
                           <li>
                              <p>Use the FAN-aware capability of the Oracle drivers by using standard interfaces to test connections on <span class="italic">get</span> or <span class="italic">release</span> from the third-party connection pools in use by third-party application servers or custom applications.
                              </p>
                              <ul style="list-style-type: disc;" id="GUID-AC79F7FE-2446-4178-A699-3859FFA5651A__UL_H2K_WCK_LHB">
                                 <li>
                                    <p>This solution applies to standard Java applications through the use of the standard TNS connect string and ensures that the <code class="codeph">ons.jar</code> and <code class="codeph">simpleFAN.jar</code> files are available on the application CLASSPATH.
                                    </p>
                                 </li>
                                 <li>
                                    <p>For the OCI/OCCI driver, the <code class="codeph">OCI_ATTR_SERVER_STATUS</code> server context handle attribute is sensitive to FAN events and will return <code class="codeph">OCI_SERVER_NOT_CONNECTED</code> if the connection has been affected by a FAN event.
                                    </p>
                                 </li>
                              </ul>
                           </li>
                           <li>
                              <p>You can implement FAN with server-side callouts on your database tier.</p>
                           </li>
                           <li>
                              <p>Applications can use FAN programmatically by using the JDBC and Oracle RAC FAN application programming interface (API) or by using callbacks with OCI and ODP.NET to subscribe to FAN events and to run event handling actions upon the receipt of an event.</p>
                           </li>
                        </ul>
                        <p>If you use one of the integrated clients listed in the first item of the preceding list, then, for DOWN events, the disruption to the application is minimized because the FAN-aware client terminates the connections to the failed instance or node before they are reused. Active work can be allowed to complete and, if there is a surviving instance, then continuous service can be maintained for ongoing work. Any sessions active when the instance or service stops are terminated and the application user is immediately notified. Incomplete transactions can be protected by Application Continuity, if it is enabled. Application users who request connections are directed to available instances, only.</p>
                        <p>For <code class="codeph">UP</code> events, when services and instances are started, new connections are created so that the application can immediately take advantage of the extra hardware resources or additional capacity.
                        </p>
                        <div class="p">To take advantage of FAN-aware capabilities in the drivers, as mentioned in the previous list, the following is required:
                           <ul style="list-style-type: disc;" id="GUID-AC79F7FE-2446-4178-A699-3859FFA5651A__UL_I2K_WCK_LHB">
                              <li>
                                 <p>For the thin Java driver, beginning with release 12.2, FAN is automatically enabled by placing the <code class="codeph">ons.jar</code> and <code class="codeph">simpleFAN.jar</code> files on the CLASSPATH, and by using the recommended TNS format (as shown in <a href="ensuring-application-continuity.html#GUID-2DD974C8-94C2-446B-B2BD-81B8135A26C3__AUTOMATICCONFIGURATIONOFFAN-309F5DDA">Example 6-1</a>). Using the recommended TNS format automatically configures ONS. Also with the Java thin driver, FAN is supported for both planned and unplanned events. For unplanned outages, the FAN interrupt is immediate. For planned maintenance, configure the Java application servers or custom pools using standard interfaces to test connections on <span class="italic">get</span> or <span class="italic">release</span> from third-party connection pools. For example, <code class="codeph">TestConnectionsOnReserve</code>, <code class="codeph">TestOnBorrow</code>, or <code class="codeph">PreTest</code> connections, depending on the application server.
                                 </p>
                                 <p>With this approach, when a FAN event is received during planned maintenance, Fast Connection Failover closes sessions when they are tested, because the application does not have a connection to the database at this time, and can retry for a new connection. The connection tests may use <code class="codeph">isValid</code>, <code class="codeph">isClosed</code>, <code class="codeph">isUsable</code>, <code class="codeph">PingDatabase</code>, or a SQL statement that is preceded by the hint <code class="codeph">/*+ CLIENT_CONNECTION_VALIDATION */</code>.
                                 </p>
                              </li>
                              <li>
                                 <p>For a SQL test, the SQL syntax must begin with the hint <code class="codeph">/*+ CLIENT_CONNECTION_VALIDATION */</code>. At the time the SQL command runs, the driver will drain the connection, if it is affected by the upcoming planned maintenance. Connection pools, data sources, and, in the programmatic case, customer applications, must all be ready to manage the recoverable error that occurs when the SQL command runs, which usually closes the physical connection.
                                 </p>
                                 <div class="infoboxnote" id="GUID-AC79F7FE-2446-4178-A699-3859FFA5651A__GUID-F74B8AF1-8272-432E-9FFA-0A3E5CD3240A">
                                    <p class="notep1">Note:</p>
                                    <p>The SQL hint must be placed as the first non-comment token within the SQL string to avoid changing current, driver-based SQL parsing. For example:</p><pre class="pre codeblock"><code>/*+ CLIENT_CONNECTION_VALIDATION */ SELECT 1 FROM DUAL;</code></pre></div>
                              </li>
                              <li>
                                 <p>Third-party Java application servers and Java applications can use the <code class="codeph">PooledConnection</code> standard interface when developing connection pools.
                                 </p>
                              </li>
                              <li>
                                 <p>Beginning with the 11.2.0.3 release of the OCI/OCCI driver, when the <code class="codeph">OCI_ATTR_SERVER_STATUS</code> server context handle attribute returns <code class="codeph">OCI_SERVER_NOT_CONNECTED</code>, the application must terminate the connection. Work will be drained for planned maintenance. The 12.2 release of the driver can also detect <code class="codeph">OCISessionRelease</code> and <code class="codeph">OCIRequestEnd</code> when it receives a planned DOWN event.
                                 </p>
                              </li>
                           </ul>
                        </div>
                        <p>FAN callouts are server-side scripts or executables that run whenever a FAN event is generated. You can design and build callouts to do many things. For example:</p>
                        <ul style="list-style-type: disc;" id="GUID-AC79F7FE-2446-4178-A699-3859FFA5651A__UL_J2K_WCK_LHB">
                           <li>
                              <p>Log status information</p>
                           </li>
                           <li>
                              <p>Page DBAs or to open support tickets when resources fail to start</p>
                           </li>
                           <li>
                              <p>Automatically start dependent external applications that must be co-located with a service</p>
                           </li>
                           <li>
                              <p>Change resource plans or shut down services when the number of available instances for a policy-managed database decreases, for example, if nodes fail</p>
                           </li>
                           <li>
                              <p>Automate the fail back of a service to preferred instances for administrator-managed databases, if needed</p>
                           </li>
                        </ul>
                        <p>FAN events are published using Oracle Notification Service and Advanced Queuing, the latter being continued for backward compatibility to previous Oracle Database releases. The publication mechanisms are automatically configured as part of your Oracle RAC installation. If you are using thin Java JDBC connections, then the client can be automatically configured for Oracle Notification Service, by obtaining the database-server Oracle Notification Service configuration from the database connection. It is not necessary to configure Oracle Notification Service on the client.</p>
                        <p>Oracle Net Services listeners and Global Data Services (GDS) are integrated with FAN events, enabling the listener and GDS to immediately de-register services provided by the failed instance and to avoid erroneously sending connection requests to failed instances. </p>
                        <p>If you specify the connection load balancing goal <code class="codeph">CLB_GOAL_SHORT</code> for the service, then the listener uses the load balancing advisory when the listener balances the connection loads. When load balancing advisory is enabled, the metrics used for the listener are finer grained.
                        </p>
                     </div>
                     <!-- class="section" -->
                  </div>
                  <div>
                     <div class="relinfo">
                        <p><strong>Related Topics</strong></p>
                        <ul>
                           <li><a href="ensuring-application-continuity.html#GUID-2DD974C8-94C2-446B-B2BD-81B8135A26C3" title="Before planned maintenance, drain or fail over database sessions at the database instance so application work is not interrupted. Beginning with Oracle Database 18c, the database itself drains the sessions.">Server Draining Ahead of Planned Maintenance</a></li>
                        </ul>
                     </div>
                  </div>
               </div><a id="RACAD8300"></a><a id="RACAD7687"></a><a id="RACAD7688"></a><a id="RACAD7132"></a><div class="sect3"><a id="GUID-8856EACC-DB95-4F15-ABED-B20234F0678D" name="GUID-8856EACC-DB95-4F15-ABED-B20234F0678D"></a><h4 id="RACAD-GUID-8856EACC-DB95-4F15-ABED-B20234F0678D" class="sect4">Fast Application Notification High Availability Events</h4>
                  <div>
                     <p>This section describes the information delivered in the FAN event to a callout program.</p>
                     <p>FAN event types are listed following the example, and <a href="ensuring-application-continuity.html#GUID-8856EACC-DB95-4F15-ABED-B20234F0678D__BABJHGIA" title="Event payload parameters and descriptions">Table 6-1</a> describes name-value pairs for the event parameters. The event type is always the first entry when you receive FAN information through a callout, as in the following example:
                     </p><pre class="pre codeblock"><code>SERVICEMEMBER VERSION=1.0
   service=test.company.com database=ractest
   instance=ractest11 host=ractest1_host0343_1 status=up reason=FAILURE
   timestamp=2018-05-08 22:06:02 timezone=-07:00 db_domain=company.com
</code></pre><p>Note that the preceding example displays as one line.</p>
                     <p>FAN event types include:</p>
                     <ul class="simple" style="list-style-type: none;padding-left:0;">
                        <li><code class="codeph">DATABASE</code></li>
                        <li><code class="codeph">INSTANCE</code></li>
                        <li><code class="codeph">NODE</code></li>
                        <li><code class="codeph">SERVICE</code></li>
                        <li><code class="codeph">SERVICEMEMBER</code></li>
                        <li><code class="codeph">SERVICEMETRICS</code></li>
                     </ul>
                     <p>The <code class="codeph">DATABASE</code> and <code class="codeph">INSTANCE</code> types list the default database service as <code class="codeph">DB_UNIQUE_NAME</code>.
                     </p>
                     <p>All events except for <code class="codeph">NODE</code> events include a <code class="codeph">db_domain</code> field.
                     </p>
                     <p>Events of <code class="codeph">SERVICEMETRICS</code> type are load balancing advisory events.
                     </p>
                     <p><span class="bold">See Also:</span> <a href="workload-management-with-dynamic-database-services.html#GUID-0EF444E4-6EC3-46A9-AF14-307995FEA664__BABHJDGB" title="Event payload parameters and descriptions">Table 5-1</a> for more information about load balancing events
                     </p>
                     <div class="tblformal" id="GUID-8856EACC-DB95-4F15-ABED-B20234F0678D__BABJHGIA">
                        <p class="titleintable">Table 6-1 Event Parameter Name-Value Pairs and Descriptions</p>
                        <table cellpadding="4" cellspacing="0" class="Formal" title="Event Parameter Name-Value Pairs and Descriptions" summary="Event payload parameters and descriptions" width="100%" frame="hsides" border="1" rules="rows">
                           <thead>
                              <tr align="left" valign="top">
                                 <th align="left" valign="bottom" width="29%" id="d23610e1084">Parameter</th>
                                 <th align="left" valign="bottom" width="71%" id="d23610e1087">Description</th>
                              </tr>
                           </thead>
                           <tbody>
                              <tr align="left" valign="top">
                                 <td align="left" valign="top" width="29%" id="d23610e1092" headers="d23610e1084 "><code class="codeph">VERSION</code></td>
                                 <td align="left" valign="top" width="71%" headers="d23610e1092 d23610e1087 ">
                                    <p>Version of the event record. Used to identify release changes.</p>
                                 </td>
                              </tr>
                              <tr align="left" valign="top">
                                 <td align="left" valign="top" width="29%" id="d23610e1099" headers="d23610e1084 "><code class="codeph">database</code></td>
                                 <td align="left" valign="top" width="71%" headers="d23610e1099 d23610e1087 ">
                                    <p>The unique name of the database supporting the service; matches the initialization parameter value for <code class="codeph">DB_UNIQUE_NAME</code>, which defaults to the value of the <code class="codeph">DB_NAME</code> initialization parameter.
                                    </p>
                                 </td>
                              </tr>
                              <tr align="left" valign="top">
                                 <td align="left" valign="top" width="29%" id="d23610e1112" headers="d23610e1084 "><code class="codeph">instance</code></td>
                                 <td align="left" valign="top" width="71%" headers="d23610e1112 d23610e1087 ">
                                    <p>The name of the instance that supports the service; matches the <code class="codeph">ORACLE_SID</code> value.
                                    </p>
                                 </td>
                              </tr>
                              <tr align="left" valign="top">
                                 <td align="left" valign="top" width="29%" id="d23610e1122" headers="d23610e1084 "><code class="codeph">host</code></td>
                                 <td align="left" valign="top" width="71%" headers="d23610e1122 d23610e1087 ">
                                    <p>The name of the node that supports the service or the node that has stopped; matches the node name known to Cluster Synchronization Services (CSS).</p>
                                 </td>
                              </tr>
                              <tr align="left" valign="top">
                                 <td align="left" valign="top" width="29%" id="d23610e1129" headers="d23610e1084 "><code class="codeph">service</code></td>
                                 <td align="left" valign="top" width="71%" headers="d23610e1129 d23610e1087 ">
                                    <p>The service name; matches the name of the service as listed in <code class="codeph">DBA_SERVICES</code> and is domain-qualified as appropriate. Refer to the following examples:
                                    </p><pre class="pre codeblock"><code>SERVICEMEMBER VERSION=1.0 service=swingbench
 database=orcl instance=orcl_2 host=rwsbj13 status=up
 reason=USER card=1 timestamp=2018-05-29 17:26:37
 timezone=-07:00 db_domain=

SERVICEMEMBER VERSION=1.0 service=swingbench.example.com
 database=orcl instance=orcl1 host=rwsbj09 status=up
 reason=USER card=2 timestamp=2018-05-03 17:29:28
 timezone=-07:00 db_domain=example.com

SERVICEMEMBER VERSION=1.0 service=swingbench.example.com
 database=orcl instance=orcl2 host=rwsbj10 status=up
 reason=USER card=1 timestamp=2018-07-03 17:29:18
 timezone=-07:00 db_domain=example.com</code></pre></td>
                              </tr>
                              <tr align="left" valign="top">
                                 <td align="left" valign="top" width="29%" id="d23610e1141" headers="d23610e1084 "><code class="codeph">status</code></td>
                                 <td align="left" valign="top" width="71%" headers="d23610e1141 d23610e1087 ">
                                    <p>Values are <code class="codeph">UP</code>, <code class="codeph">DOWN</code>, <code class="codeph">NODEDOWN</code> (this only applies to the <code class="codeph">NODE</code> event type), <code class="codeph">NOT_RESTARTING</code>, and <code class="codeph">UNKNOWN</code>.
                                    </p>
                                    <p><span class="bold">Notes:</span></p>
                                    <ul style="list-style-type: disc;">
                                       <li>
                                          <p>When the node is down, the status is <code class="codeph">NODEDOWN</code>, as opposed to <code class="codeph">DOWN</code> for other event types.
                                          </p>
                                       </li>
                                       <li>
                                          <p>When <code class="codeph">STATUS=NODEDOWN</code> and <code class="codeph">REASON=MEMBER_LEAVE</code>, a node has failed and is no longer part of the cluster, or a user has stopped a node.
                                          </p>
                                       </li>
                                       <li>
                                          <p>When <code class="codeph">STATUS=NODEDOWN</code> and <code class="codeph">REASON=PUBLIC_NW_DOWN</code>, the node is up but it is unreachable because the public network is down because of either a failure or a user action.
                                          </p>
                                       </li>
                                       <li>
                                          <p>Multiple public networks are supported by Oracle Clusterware. The FAN event reflects this fact.</p>
                                       </li>
                                    </ul>
                                 </td>
                              </tr>
                              <tr align="left" valign="top">
                                 <td align="left" valign="top" width="29%" id="d23610e1201" headers="d23610e1084 "><code class="codeph">reason</code></td>
                                 <td align="left" valign="top" width="71%" headers="d23610e1201 d23610e1087 ">
                                    <p><code class="codeph">AUTOSTART</code>, <code class="codeph">BOOT</code>, <code class="codeph">DEPENDENCY</code>, <code class="codeph">FAILURE</code>, <code class="codeph">MEMBER_LEAVE</code>, <code class="codeph">PUBLIC_NW_DOWN</code>, <code class="codeph">USER</code>.
                                    </p>
                                    <p><span class="bold">Notes:</span></p>
                                    <ul style="list-style-type: disc;">
                                       <li>
                                          <p>For <code class="codeph">DATABASE</code> and <code class="codeph">SERVICE</code> event types, <code class="codeph">REASON=AUTOSTART</code> if, when the node started, the <code class="codeph">AUTO_START</code> resource attribute was set to restore, and the resource was offline before the node started.
                                          </p>
                                       </li>
                                       <li>
                                          <p>For <code class="codeph">DATABASE</code> and <code class="codeph">SERVICE</code> event types, <code class="codeph">REASON=BOOT</code> if, when the node started, the resource started because it was online before the node started.
                                          </p>
                                       </li>
                                       <li>
                                          <p>For SRVCTL and Oracle Enterprise Manager operations, <code class="codeph">REASON=USER</code> describes planned actions for such operations as draining work.
                                          </p>
                                       </li>
                                    </ul>
                                 </td>
                              </tr>
                              <tr align="left" valign="top">
                                 <td align="left" valign="top" width="29%" id="d23610e1266" headers="d23610e1084 "><code class="codeph">cardinality</code></td>
                                 <td align="left" valign="top" width="71%" headers="d23610e1266 d23610e1087 ">
                                    <p>The number of service members that are currently active; included in all <code class="codeph">SERVICEMEMBER UP</code> events.
                                    </p>
                                    <p>Following is an example of <code class="codeph">SERVICEMEMBER UP</code> event:
                                    </p><pre class="pre codeblock"><code>SERVICEMEMBER VERSION=1.0 service=swingbench.example.com
database=orcl instance=orcl_2 host=mjkbj09 status=up
reason=USER card=1 timestamp=2018-07-12 14:46:46  timezone=-07:00 db_domain=example.com</code></pre></td>
                              </tr>
                              <tr align="left" valign="top">
                                 <td align="left" valign="top" width="29%" id="d23610e1283" headers="d23610e1084 "><code class="codeph">incarnation</code></td>
                                 <td align="left" valign="top" width="71%" headers="d23610e1283 d23610e1087 ">
                                    <p>For <code class="codeph">NODEDOWN</code> events; the new cluster incarnation. This value changes each time a member joins or leaves the cluster.
                                    </p>
                                    <p>Following is an example of a <code class="codeph">NODEDOWN</code> event:
                                    </p><pre class="pre codeblock"><code>NODE VERSION=1.0 host=stru09 incarn=175615351 status=down
reason=member_leave timestamp=27-Jul-2018 14:49:32  timezone=-07:00</code></pre></td>
                              </tr>
                              <tr align="left" valign="top">
                                 <td align="left" valign="top" width="29%" id="d23610e1300" headers="d23610e1084 "><code class="codeph">timestamp</code></td>
                                 <td align="left" valign="top" width="71%" headers="d23610e1300 d23610e1087 ">
                                    <p>The time according to Oracle Clusterware that an event occurs.</p>
                                 </td>
                              </tr>
                              <tr align="left" valign="top">
                                 <td align="left" valign="top" width="29%" id="d23610e1307" headers="d23610e1084 "><code class="codeph">timezone</code></td>
                                 <td align="left" valign="top" width="71%" headers="d23610e1307 d23610e1087 ">
                                    <p>The time zone of Oracle Clusterware where the event occurred, given as GMT +/-hh:mm.</p>
                                 </td>
                              </tr>
                           </tbody>
                        </table>
                     </div>
                     <!-- class="inftblhruleinformal" -->
                     <p>Some of the FAN event record parameters have values that correspond to values returned by the <code class="codeph">SYS_CONTEXT</code> function using the default namespace <code class="codeph">USERENV</code>, as shown in <a href="ensuring-application-continuity.html#GUID-8856EACC-DB95-4F15-ABED-B20234F0678D__BABFJDAI" title="FAN parameters and matching Oracle database signatures">Table 6-2</a>.
                     </p>
                     <div class="tblformal" id="GUID-8856EACC-DB95-4F15-ABED-B20234F0678D__BABFJDAI">
                        <p class="titleintable">Table 6-2 FAN Parameters and Matching Session Information</p>
                        <table cellpadding="4" cellspacing="0" class="Formal" title="FAN Parameters and Matching Session Information" summary="FAN parameters and matching Oracle database signatures" width="100%" frame="hsides" border="1" rules="rows">
                           <thead>
                              <tr align="left" valign="top">
                                 <th align="left" valign="bottom" width="29%" id="d23610e1337">FAN Parameter</th>
                                 <th align="left" valign="bottom" width="71%" id="d23610e1340">Matching Session Information</th>
                              </tr>
                           </thead>
                           <tbody>
                              <tr align="left" valign="top">
                                 <td align="left" valign="top" width="29%" id="d23610e1345" headers="d23610e1337 "><code class="codeph">SERVICE</code></td>
                                 <td align="left" valign="top" width="71%" headers="d23610e1345 d23610e1340 "><code class="codeph">sys_context('userenv', 'service_name')</code></td>
                              </tr>
                              <tr align="left" valign="top">
                                 <td align="left" valign="top" width="29%" id="d23610e1352" headers="d23610e1337 "><code class="codeph">DATABASE_UNIQUE_NAME</code></td>
                                 <td align="left" valign="top" width="71%" headers="d23610e1352 d23610e1340 "><code class="codeph">sys_context('userenv', 'db_unique_name')</code></td>
                              </tr>
                              <tr align="left" valign="top">
                                 <td align="left" valign="top" width="29%" id="d23610e1359" headers="d23610e1337 "><code class="codeph">INSTANCE</code></td>
                                 <td align="left" valign="top" width="71%" headers="d23610e1359 d23610e1340 "><code class="codeph">sys_context('userenv', 'instance_name')</code></td>
                              </tr>
                              <tr align="left" valign="top">
                                 <td align="left" valign="top" width="29%" id="d23610e1366" headers="d23610e1337 "><code class="codeph">CLUSTER_NODE_NAME</code></td>
                                 <td align="left" valign="top" width="71%" headers="d23610e1366 d23610e1340 "><code class="codeph">sys_context('userenv', 'server_host')</code></td>
                              </tr>
                           </tbody>
                        </table>
                     </div>
                     <!-- class="inftblhruleinformal" -->
                  </div>
               </div><a id="RACAD8267"></a><div class="sect3"><a id="GUID-807BA413-6348-482D-A53C-462F5BBAE5A8" name="GUID-807BA413-6348-482D-A53C-462F5BBAE5A8"></a><h4 id="RACAD-GUID-807BA413-6348-482D-A53C-462F5BBAE5A8" class="sect4">Subscription to High Availability Events</h4>
                  <div>
                     <p>Oracle RAC uses FAN to notify applications about configuration changes and the current service level that is provided by each instance where the service is enabled. If you are using an OCI client or an ODP.NET client to receive FAN events, then you must enable the service used by that client to access the alert notification queue by using SRVCTL with the <code class="codeph">-notification</code> parameter.
                     </p>
                  </div>
               </div><a id="RACAD7133"></a><div class="sect3"><a id="GUID-2024CEF8-F984-4377-9182-E17F738A4715" name="GUID-2024CEF8-F984-4377-9182-E17F738A4715"></a><h4 id="RACAD-GUID-2024CEF8-F984-4377-9182-E17F738A4715" class="sect4">Using Fast Application Notification Callouts</h4>
                  <div>
                     <p>FAN callouts are server-side executables that Oracle RAC executes immediately when high availability events occur.</p>
                     <p>You can use FAN callouts to automate activities when events occur in a cluster configuration, such as:</p>
                     <ul style="list-style-type: disc;">
                        <li>
                           <p>Opening fault tracking tickets</p>
                        </li>
                        <li>
                           <p>Sending messages to pagers</p>
                        </li>
                        <li>
                           <p>Sending e-mail</p>
                        </li>
                        <li>
                           <p>Starting and stopping server-side applications</p>
                        </li>
                        <li>
                           <p>Maintaining an uptime log by logging each event as it occurs</p>
                        </li>
                        <li>
                           <p>Relocating low-priority services when high priority services come online</p>
                        </li>
                     </ul>
                     <p>To use FAN callouts, place an executable in the <code class="codeph"><span class="variable" translate="no">Grid_home</span>/racg/usrco</code> directory on every node that runs Oracle Clusterware. The executable must be able to run standalone when called, with optional arguments, from another program. The following is an example of an executable shell script, named <code class="codeph">callout.sh</code>, which is placed in the <code class="codeph"><span class="variable" translate="no">Grid_home</span>/racg/usrco</code> directory:
                     </p><pre class="pre codeblock"><code>#! /bin/bash
FAN_LOGFILE= [<span class="variable" translate="no">your_path_name</span>]/admin/log/'hostname'_uptime'.log
echo $* "reported="'date' &gt;&gt; $FAN_LOGFILE &amp;</code></pre><p>The previous example adds entries similar to the following in the log file, indicated by <code class="codeph">$FAN_LOGFILE</code> in the shell script, each time a FAN event is generated:
                     </p><pre class="pre codeblock"><code>NODE VERSION=1.0 host=sun880-2 incarn=23 status=nodedown reason=public_nw_down
timestamp=08-Oct-2012 04:02:14 timezone=-08:00 reported=Fri Oct 8 04:02:14 PDT 2012</code></pre><p>The contents of a FAN event record matches the current session of the user logged on to the database, as shown in <a href="ensuring-application-continuity.html#GUID-8856EACC-DB95-4F15-ABED-B20234F0678D__BABFJDAI" title="FAN parameters and matching Oracle database signatures">Table 6-2</a>. The user environment (<code class="codeph">USERENV</code>) information is also available using OCI connection handle and descriptor attributes (using <code class="codeph">OCIAttrGet()</code>). Use this information to take actions on sessions that match the FAN event data.
                     </p>
                     <div class="infoboxnotealso" id="GUID-2024CEF8-F984-4377-9182-E17F738A4715__GUID-B729C78F-470B-4107-8806-9C4586EDB569">
                        <p class="notep1">See Also:</p>
                        <p><a href="ensuring-application-continuity.html#GUID-8856EACC-DB95-4F15-ABED-B20234F0678D__BABJHGIA" title="Event payload parameters and descriptions">Table 6-1</a> for information about the callout and event details
                        </p>
                     </div>
                     <p>In general, events are only posted to user callouts on the node from which the event originated. For example, if the database on <code class="codeph">node1</code> goes down, then the callout is posted to <code class="codeph">node1</code>, only. The only exceptions to this are node down and VIP down eventsthese events are posted to all nodes, regardless of from where they originated.
                     </p>
                  </div>
                  <div>
                     <div class="relinfo">
                        <p><strong>Related Topics</strong></p>
                        <ul>
                           <li><a href="../lnoci/oci-programming-basics.html#LNOCI-GUID-4CFB8AF7-EF05-4E0F-847F-2D0710E552C5" target="_blank"><span><cite>Oracle Call Interface Programmer's Guide</cite></span></a></li>
                        </ul>
                     </div>
                  </div>
               </div>
            </div><a id="RACAD7130"></a><div class="sect2"><a id="GUID-27F35F42-080C-49F2-976E-DB073ACCBFEB" name="GUID-27F35F42-080C-49F2-976E-DB073ACCBFEB"></a><h3 id="RACAD-GUID-27F35F42-080C-49F2-976E-DB073ACCBFEB" class="sect3">Managing Unplanned Outages</h3>
               <div>
                  <p>You can assign services to one or more instances in an administrator-managed Oracle RAC database or to server pools in a policy-managed database.</p>
                  <p>If Oracle RAC detects an outage, then Oracle Clusterware isolates the failed component and recovers the dependent components. For services, if the failed component is an instance, then Oracle Clusterware attempts to maintain the cardinality of the service. If the service definition allows for failover and that is necessary to maintain cardinality, then failover occurs.</p>
                  <p>FAN events can occur at various levels within the Oracle Database architecture and are published through Oracle Notification Service and Advanced Queuing for backward compatibility with previous OCI clients. FAN callouts can also be written to execute on the database server in response to FAN events.</p>
                  <div class="infoboxnote" id="GUID-27F35F42-080C-49F2-976E-DB073ACCBFEB__GUID-EFE0E6CE-5D0B-4A92-906A-8E3205E159A2">
                     <p class="notep1">Note:</p>
                     <p>Oracle Database does not run Oracle RAC callouts with guaranteed ordering. Callouts are run asynchronously and they are subject to scheduling variability.</p>
                  </div>
                  <p>FAN is published from a surviving node when the failed node is out of service. The location and number of instances in an Oracle RAC environment that provide a service are transparent to applications. Restart and recovery are automatic, including the restarting of the subsystems, such as the listener and the Oracle Automatic Storage Management (Oracle ASM) processes, not just the database. You can use FAN callouts to report faults to your fault management system and to initiate repair jobs.</p>
                  <p>It is a complex task for application developers to mask outages of a database session (instance, node, storage or network, or any other related component) and, as a result, errors and timeouts are often exposed to the end users leading to user frustration, lost productivity, and lost opportunities. Together, FAN and Application Continuity mask outages from users and applications by recovering the in-flight work for impacted database sessions following outages. Application Continuity performs this recovery beneath the application so that the outage appears to the application as a slightly delayed execution of the request.</p>
               </div>
               <div>
                  <div class="relinfo">
                     <p><strong>Related Topics</strong></p>
                     <ul>
                        <li><a href="ensuring-application-continuity.html#GUID-BD699AEB-9F85-42A8-8687-5A979918938D" title="Application Continuity masks many recoverable database outages (when replay is successful) from applications and users by restoring the database session: the full session, including all states, cursors, variables, and the last transaction if there is one.">About Application Continuity</a></li>
                        <li><a href="../netag/identifying-and-accessing-database.html#NETAG-GUID-50EEC5AA-38D5-49E3-84BB-2CF9A3B63E1F" target="_blank"><span><cite>Oracle Database Net Services Administrator's Guide</cite></span></a></li>
                     </ul>
                  </div>
               </div>
            </div><a id="RACAD8846"></a><a id="RACAD7131"></a><div class="sect2"><a id="GUID-11B75A54-CEF7-4113-A72F-9E7AAFE61953" name="GUID-11B75A54-CEF7-4113-A72F-9E7AAFE61953"></a><h3 id="RACAD-GUID-11B75A54-CEF7-4113-A72F-9E7AAFE61953" class="sect3">Managing Planned Maintenance</h3>
               <div>
                  <p>For repairs, upgrades, and changes that require you to isolate one or more instances or nodes, Oracle RAC provides interfaces that relocate, disable, and enable services to minimize service disruption to application users.</p>
                  <p>When you relocate a service, you indicate the service should run on another instance temporarily. If you forcibly disable a service, then the service is stopped on all database instances and is no longer available. Disabled services are not restarted automatically. When a service is stopped or relocated, FAN is published with a planned reason code, typically <code class="codeph">reason=user</code>. Once you complete the operation, you can return the service to normal operation or enable the service and then restart it. When a service restarts, FAN is published with <code class="codeph">UP</code> status codes.
                  </p>
                  <p>Due to dependencies, if you manually shut down your database, then all of your services for that database automatically stop. If you want your services to automatically start when you manually restart the database, then you must set the management policy of the service to automatic. If you want to shut down only one instance of the database and you want the service to remain offered, then you can either relocate the service using <code class="codeph">srvctl relocate service</code> or stop the instance using <code class="codeph">srvctl stop instance</code>, which enables the service to automatically failover according to its failover policy.
                  </p>
                  <p>In either case, Oracle recommends that work running under the service drain at request boundaries. The drain interval is specified as an attribute of the service or you can provide a drain interval on the SRVCTL command line.</p>
                  <p>This section includes the following topics:</p>
                  <ul style="list-style-type: disc;">
                     <li>
                        <p><a href="ensuring-application-continuity.html#GUID-DA6B6272-C420-4A1F-BB5F-E9A81A5469D8" title="Oracle recommends that you drain database sessions from the instance over a controlled time period from FAN-enabled Oracle or non-Oracle connection pools, or, beginning with Oracle Database 18c at the database, itself.">Managing Planned Maintenance Without User Interruption</a></p>
                     </li>
                     <li>
                        <p><a href="ensuring-application-continuity.html#GUID-D7D9D76F-22DF-4603-B7DC-8D7FC88F32E6" title="Many enterprises run a large number of services, whether it be many services offered by a single database or instance, or many databases offering a few services running on the same node.">Managing a Group of Services for Maintenance</a></p>
                     </li>
                     <li>
                        <p><a href="ensuring-application-continuity.html#GUID-2DD974C8-94C2-446B-B2BD-81B8135A26C3" title="Before planned maintenance, drain or fail over database sessions at the database instance so application work is not interrupted. Beginning with Oracle Database 18c, the database itself drains the sessions.">Server Draining Ahead of Planned Maintenance</a></p>
                     </li>
                  </ul>
               </div>
               <div>
                  <div class="relinfo">
                     <p><strong>Related Topics</strong></p>
                     <ul>
                        <li><a href="workload-management-with-dynamic-database-services.html#GUID-0573F51A-7DF9-40AC-AE6A-0997F7EEEF3F">Service Management Policy</a></li>
                     </ul>
                  </div>
               </div>
               <div class="sect3"><a id="GUID-DA6B6272-C420-4A1F-BB5F-E9A81A5469D8" name="GUID-DA6B6272-C420-4A1F-BB5F-E9A81A5469D8"></a><h4 id="RACAD-GUID-DA6B6272-C420-4A1F-BB5F-E9A81A5469D8" class="sect4">Managing Planned Maintenance Without User Interruption</h4>
                  <div>
                     <p>Oracle recommends that you drain database sessions from the instance over a controlled time period from FAN-enabled Oracle or non-Oracle connection pools, or, beginning with Oracle Database 18c at the database, itself.</p>
                     <div class="section">
                        <p>Draining database sessions is the safest way to migrate work without interrupting applications. When draining occurs at connection tests and outside of request boundaries, it is 100% correct. Applications continue with no interruption as existing work completes and new work acquires a session for the same service functioning at another instance, resulting in no errors returned to applications and no risk of incorrect database session states. For connection tests, the caller expects to receive a good or bad return code and is ready to handle the result, making inspecting connection tests a widely applicable and very powerful solution.</p>
                        <p>The service attributes <code class="codeph">-drain_timeout</code> and <code class="codeph">-stopoption</code> control the drain time period, and then how the service manages sessions that have not completed once this time period expires. Requests that complete and then check back in to the pool or close, can be directed to a new location that is not affected by the planned maintenance.
                        </p>
                        <p>Application Continuity provides additional cover, giving continuous service for those requests that do not complete within the allotted drain time.</p>
                        <p>Using any FAN-aware pool with Fast Connection Failover configured (such as OCI session pools, Oracle Universal Connection Pool, Oracle WebLogic Server Active GridLink for Oracle RAC, or ODP.NET) allows sessions to drain at <a href="glossary.html#GUID-9B4EED64-7F24-4363-ACFB-4859BDDF2034"><span class="xrefglossterm">request	</span></a> boundaries after receipt of the FAN planned <code class="codeph">DOWN</code> event.
                        </p>
                        <p>Because not every application uses an Oracle connection pool and not every application is FAN-aware, beginning with Oracle Database 18c, the database inspects sessions during planned maintenance seeking safe places to stop a session so that the application is not disrupted. After stopping the service, the database looks for safe places where the connection can be closed. When the connection is closed, the database cleans up the session.</p>
                        <p>Stopping a session at a safe place enables the application to open a new connection with the states that it needs. Draining sessions may take a period of work to flow through each session. There is no requirement that closing a session is immediate, rather the close must occur at a safe place that exposes no errors to the application, and, preferably, before the drain timeout period has expired.</p>
                        <p>Requests are far more important than transactions because they enable the issued work to complete. For draining requests, the Oracle Universal Connection Pool uses the drain timeout to gradually drain, which prevents an overload of logins on the instances drained, by slowly releasing the original sessions across the time period rather than all at once. Gradual draining has the benefit of not disturbing the other work ongoing at the target instances.</p>
                        <p>Both <code class="codeph">DRAIN_TIMEOUT</code> and <code class="codeph">STOP_OPTION</code> are service attributes that you can define when you add the service or modify it after creation. You can also specify these attributes using SRVCTL, which will take precedence over what is defined on the service. You can specify the <code class="codeph">-drain_timeout</code> and <code class="codeph">-stopoption</code> parameters when using the following SRVCTL commands:
                        </p>
                        <ul style="list-style-type: disc;">
                           <li>
                              <p><code class="codeph">srvctl add service</code></p>
                           </li>
                           <li>
                              <p><code class="codeph">srvctl modify service</code></p>
                           </li>
                           <li>
                              <p><code class="codeph">srvctl relocate service</code></p>
                           </li>
                           <li>
                              <p><code class="codeph">srvctl stop service</code></p>
                           </li>
                           <li>
                              <p><code class="codeph">srvctl stop database</code></p>
                           </li>
                           <li>
                              <p><code class="codeph">srvctl stop instance</code></p>
                           </li>
                        </ul>
                        <p>To manage planned maintenance without user interruption:</p>
                     </div>
                     <!-- class="section" -->
                     <ol>
                        <li class="stepexpand"><span>Use SRVCTL to relocate a singleton service or a service not running on all nodes. Use the <code class="codeph">-force</code> flag with the previously listed SRVCTL commands. You must use the <code class="codeph">-force</code> flag if you specify the <code class="codeph">-stopoption</code> parameter on the command line when you run either <code class="codeph">srvctl relocate service</code> or <code class="codeph">srvctl stop service</code>. For example:</span><div><pre class="pre codeblock"><code>$ srvctl relocate service &#x2013;database mycdb01 &#x2013;service myservice &#x2013;drain_timeout 120
  &#x2013;stopoption IMMEDIATE &#x2013;oldinst mycdb01_01 -force</code></pre><div class="p">The preceding command relocates the service named <code class="codeph">myservice01</code> from the instance named <code class="codeph">mycdb01_01</code> to any instance on which it is configured to run. Oracle Clusterware chooses this instance if you do not specify a target on the command line, and waits two minutes (in this example) for any active sessions to drain, after which any sessions remaining on <code class="codeph">mycdb01_01</code> are forcibly disconnected. The connection pool automatically releases a connection at a request boundary.
                                 <div class="infoboxnote" id="GUID-DA6B6272-C420-4A1F-BB5F-E9A81A5469D8__GUID-5857741E-DF19-4759-88D0-57C26D012050">
                                    <p class="notep1">Note:</p>If the service you want to relocate is a uniform service that is currently running on all nodes, then the preceding command returns an error, unless the service is not up on all instances, in which case the preceding command example would succeed for a uniform service.
                                 </div>
                              </div>
                           </div>
                        </li>
                        <li class="stepexpand"><span>The FAN planned <code class="codeph">DOWN</code> event clears idle sessions from the connection pool immediately and marks active sessions to be released at the next check-in. These FAN actions drain the sessions from the instance without disrupting the users.</span><div>
                              <p>Existing connections on other instances remain usable, and new connections can be opened to these instances if needed.</p>
                           </div>
                        </li>
                        <li class="stepexpand"><span>Not all sessions, in all cases, will check their connections into the pool. Oracle recommends, as a best practice, to have a timeout period (by setting the <code class="codeph">-drain_timeout</code> parameter), after which the instance is forcibly shut down or the service stopped, evicting any remaining client connections.</span><div>
                              <div class="p">After the drain interval expires, the <code class="codeph">-stopoption</code> parameter is implemented, which you can define against a service or a database, as follows:
                                 <ul style="list-style-type: disc;">
                                    <li>
                                       <p>When stopping a service (<code class="codeph">svrctl stop service</code>), you can specify one of the following stop options using the <code class="codeph">-stopoption</code> parameter: TRANSACTIONAL or IMMEDIATE
                                       </p>
                                    </li>
                                    <li>
                                       <p>When stopping a database (<code class="codeph">svrctl stop database</code>), you can specify one of the following stop options using the <code class="codeph">-stopoption</code> parameter: NORMAL, TRANSACTIONAL, IMMEDIATE, or ABORT
                                       </p>
                                    </li>
                                 </ul>
                              </div>
                              <div class="p">The database stop options correlate to the service stop options, as follows:
                                 <ul class="simple" style="list-style-type: none;padding-left:0;">
                                    <li>NORMAL=NONE</li>
                                    <li>TRANSACTIONAL/TRANSACTIONAL LOCAL=TRANSACTIONAL</li>
                                    <li>IMMEDIATE/ABORT=IMMEDIATE</li>
                                 </ul>
                              </div>
                              <p>For those services that are configured to use Application Continuity, an attempt is made to recover these remaining sessions, after they are terminated, masking the outage from users and applications.</p>
                              <p>If you do not want Application Continuity to attempt to replay sessions, then specify the <code class="codeph">-noreplay</code> flag on the SRVCTL command line.
                              </p>
                           </div>
                        </li>
                        <li class="stepexpand"><span>Once maintenance is complete, restart the instance and the service on the original node.</span></li>
                        <li class="stepexpand"><span>The FAN <code class="codeph">UP</code> event for the service informs the connection pool that a new instance is available for use, allowing sessions to be created on this instance at next request boundaries.</span></li>
                     </ol>
                  </div>
                  <div>
                     <div class="relinfo">
                        <p><strong>Related Topics</strong></p>
                        <ul>
                           <li><a href="ensuring-application-continuity.html#GUID-BD699AEB-9F85-42A8-8687-5A979918938D">About Application Continuity</a></li>
                           <li><a href="ensuring-application-continuity.html#GUID-2DD974C8-94C2-446B-B2BD-81B8135A26C3" title="Before planned maintenance, drain or fail over database sessions at the database instance so application work is not interrupted. Beginning with Oracle Database 18c, the database itself drains the sessions.">Server Draining Ahead of Planned Maintenance</a></li>
                        </ul>
                     </div>
                  </div>
               </div>
               <div class="sect3"><a id="GUID-D7D9D76F-22DF-4603-B7DC-8D7FC88F32E6" name="GUID-D7D9D76F-22DF-4603-B7DC-8D7FC88F32E6"></a><h4 id="RACAD-GUID-D7D9D76F-22DF-4603-B7DC-8D7FC88F32E6" class="sect4">Managing a Group of Services for Maintenance</h4>
                  <div>
                     <p>Many enterprises run a large number of services, whether it be many services offered by a single database or instance, or many databases offering a few services running on the same node.</p>
                     <div class="section">You no longer need to run SRVCTL commands for each individual service but need only specify the node name, database name, pluggable database name, or the instance name for all affected services.</div>
                     <!-- class="section" -->
                     <div class="section"></div>
                     <!-- class="section" -->
                     <ul>
                        <li class="stepexpand"><span>For example, if you want to stop all of the services running on a given node, then you could use the following command:</span><div><pre class="pre codeblock"><code>$ srvctl stop service &#x2013;node racnode01 &#x2013;drain_timeout 60 &#x2013;stopoption IMMEDIATE</code></pre><p>The command stops all services running on <code class="codeph">racnode01</code>, allowing a drain interval of 60 seconds. After 60 seconds any remaining sessions are stopped immediately. The 60-second drain timeout interval overrides any attribute setting on any of the services.
                              </p>
                              <div class="p">The command could also be qualified to stop the databases on a node, as in the following example:<pre class="pre codeblock"><code>$ srvctl stop instance 	-node racnode01 -drain_timeout 60 &#x2013;stopoption TRANSACTIONAL
  LOCAL -failover &#x2013;force</code></pre>When you specify the <code class="codeph">-failover</code> parameter:
                                 <ul style="list-style-type: disc;">
                                    <li>
                                       <p>All services are relocated, if possible, respecting the drain timeout interval and the stop option specified.</p>
                                    </li>
                                    <li>
                                       <p>Any services that cannot be failed over are stopped, using the stop option specified.</p>
                                    </li>
                                    <li>
                                       <p>Wait for the length of the drain timeout interval or until all sessions for targeted services are removed, whichever is sooner.</p>
                                    </li>
                                    <li>
                                       <p>All instances stop according to the stop option specified.</p>
                                    </li>
                                 </ul>When you specify the <code class="codeph">&#x2013;stopoption TRANSACTIONAL LOCAL</code> parameter:
                                 <ul style="list-style-type: disc;">
                                    <li>
                                       <p>Remaining services stop according to the drain timeout interval and stop option specified.</p>
                                    </li>
                                    <li>
                                       <p>Wait for the length of the drain timeout interval or until all sessions for targeted services are removed, whichever is sooner.</p>
                                    </li>
                                    <li>
                                       <p>The instance stops using the <code class="codeph">TRANSACTIONAL LOCAL</code> stop option.
                                       </p>
                                    </li>
                                 </ul>
                              </div>
                           </div>
                        </li>
                     </ul>
                     <div class="section">
                        <p>This section includes the following topics:</p>
                        <ul style="list-style-type: disc;">
                           <li>
                              <p><a href="ensuring-application-continuity.html#GUID-9FCB5766-64EA-4FF7-9BAC-02266BCE97B3" title="You can use the srvctl start service command to start all services on a node, all services offered by a database, all services offered by a pluggable database, or all services offered on an instance or within a given server pool.">Starting Services</a></p>
                           </li>
                           <li>
                              <p><a href="ensuring-application-continuity.html#GUID-7B4774D3-EB0B-4C4E-B831-C4EB75B15AED" title="You can use SRVCTL to manage services on pluggable databases.">Pluggable Database-Level Operations</a></p>
                           </li>
                           <li>
                              <p><a href="ensuring-application-continuity.html#GUID-51D6BEA5-4C73-4BE4-A2A4-70C6B4356915" title="You can use the srvctl relocate service command to relocate services to a target destination, which can be an instance, a node, or a database.">Relocating Services</a></p>
                           </li>
                           <li>
                              <p><a href="ensuring-application-continuity.html#GUID-9CEC40F3-CE0E-4A41-9687-EF6510E51C93" title="You can use the srvctl stop service command to stop all services on a node, all services offered by a database, all services offered by a pluggable database, or all services offered on an instance or within a given server pool.">Stopping Services</a></p>
                           </li>
                        </ul>
                     </div>
                     <!-- class="section" -->
                  </div>
                  <div class="sect4"><a id="GUID-9FCB5766-64EA-4FF7-9BAC-02266BCE97B3" name="GUID-9FCB5766-64EA-4FF7-9BAC-02266BCE97B3"></a><h5 id="RACAD-GUID-9FCB5766-64EA-4FF7-9BAC-02266BCE97B3" class="sect5">Starting Services</h5>
                     <div>
                        <p>You can use the <code class="codeph">srvctl start service</code> command to start all services on a node, all services offered by a database, all services offered by a pluggable database, or all services offered on an instance or within a given server pool.
                        </p>
                        <div class="section">You can also supply a list of services (a subset of all services) to the <code class="codeph">srvctl start service</code> command that you want to start. Additionally, you can provide a node restriction, used in conjunction with the database option, for all services that can be started on a particular node. You can restrict the <code class="codeph">srvctl start service</code> command to start only the parallel query service by specifying the <code class="codeph">-pq</code> parameter.
                        </div>
                        <!-- class="section" -->
                        <div class="section">The following examples illustrate how you can start services:</div>
                        <!-- class="section" -->
                        <ul>
                           <li class="stepexpand"><span>To start all of the services offered by a single pluggable database:</span><div><pre class="pre codeblock"><code>$ srvctl start service &#x2013;db myRACCDB01 &#x2013;pdb myPDB01 &#x2013;startoption OPEN</code></pre><p>To start all services on a given database and any of its pluggable databases:</p><pre class="pre codeblock"><code>$ srvctl start service &#x2013;db myRACDB</code></pre><p>To start a list of services on a given database, regardless of any pluggable database with which they are associated:</p><pre class="pre codeblock"><code>$ srvctl start service &#x2013;db myRACDB &#x2013;service "myFirstService,mySecondService,myThirdService"</code></pre><p>To start all services for a database that can run on a given node:</p><pre class="pre codeblock"><code>$ srvctl start service &#x2013;d myRACDB &#x2013;node racnode01</code></pre></div>
                           </li>
                        </ul>
                     </div>
                  </div>
                  <div class="sect4"><a id="GUID-7B4774D3-EB0B-4C4E-B831-C4EB75B15AED" name="GUID-7B4774D3-EB0B-4C4E-B831-C4EB75B15AED"></a><h5 id="RACAD-GUID-7B4774D3-EB0B-4C4E-B831-C4EB75B15AED" class="sect5">Pluggable Database-Level Operations</h5>
                     <div>
                        <p>You can use SRVCTL to manage services on pluggable databases.</p>
                        <ul>
                           <li class="stepexpand"><span>To start all services for a pluggable database, for all instances or a single instance:</span><div><pre class="pre codeblock"><code>$ srvctl start service -db <span class="variable" translate="no">db_name</span> -pdb <span class="variable" translate="no">pdb_name</span> [-instance <span class="variable" translate="no">instance_name</span>]</code></pre></div>
                           </li>
                           <li class="stepexpand"><span>To stop all services for a pluggable database, for all instances or a single instance:</span><div><pre class="pre codeblock"><code>$ srvctl stop service -db <span class="variable" translate="no">db_name</span> -pdb <span class="variable" translate="no">pdb_name</span> [-node <span class="variable" translate="no">node_name</span> | -instance <span class="variable" translate="no">
   inst_name</span> | -serverpool <span class="variable" translate="no">pool_name</span>] [-stopoption <span class="variable" translate="no">stop_option</span>] [-drain_timeout <span class="variable" translate="no">timeout</span>]
   [-force [-noreplay]]</code></pre><div class="infoboxnote" id="GUID-7B4774D3-EB0B-4C4E-B831-C4EB75B15AED__GUID-F77A9401-3A39-4993-8B1D-9E1B7A751E44">
                                    <p class="notep1">Note:</p>The <code class="codeph">-pdb <span class="variable" translate="no">pdb_name</span></code> parameter is optional. If you omit the pluggable database name, then the operation occurs for the entire container database (all pluggable databases within this container).
                                 </div>
                              </div>
                           </li>
                        </ul>
                     </div>
                  </div>
                  <div class="sect4"><a id="GUID-51D6BEA5-4C73-4BE4-A2A4-70C6B4356915" name="GUID-51D6BEA5-4C73-4BE4-A2A4-70C6B4356915"></a><h5 id="RACAD-GUID-51D6BEA5-4C73-4BE4-A2A4-70C6B4356915" class="sect5">Relocating Services</h5>
                     <div>
                        <p>You can use the <code class="codeph">srvctl relocate service</code> command to relocate services to a target destination, which can be an instance, a node, or a database.
                        </p>
                        <ul>
                           <li class="stepexpand"><span>In the following command examples, all services are relocated from the named database, pluggable database, instance, or node. The services will only relocate if the target can support that service, as defined by the service configuration. Any services that cannot be relocated remain at the original location. A placement error is recorded against any services that could not be relocated, or were already running at the new target. Services that fail to relocate remain running at their original location, and any sessions remain active.</span><div><pre class="pre codeblock"><code>$ srvctl relocate service &#x2013;database myRACCDB &#x2013;oldinst RACCDB_01 &#x2013;newinst RACCDB_03
  -drain_timeout 30 -force</code></pre><p>or</p><pre class="pre codeblock"><code>$ srvctl relocate service &#x2013;database myRACCDB &#x2013;pdb myPDB01 &#x2013;currentnode racnode01
  &#x2013;targetnode racnode02 -drain_timeout 30 -force &#x2013;noreplay</code></pre><p>The relocate operation starts the service in the new location prior to stopping the service in its existing location.</p>
                              </div>
                           </li>
                           <li class="stepexpand"><span>If you do not specify a target destination, then Oracle Clusterware relocates all services or specific services from the specified database, pluggable database, instance, or node, as in the following examples:</span><div><pre class="pre codeblock"><code>$ srvctl relocate service &#x2013;database myRACCDB &#x2013;service "myService01,myService02"
  -drain_timeout 30 -force</code></pre><p>or</p><pre class="pre codeblock"><code>$ srvctl relocate service &#x2013;database myRACCDB &#x2013;pdb myPDB01 -drain_timeout 30
  -force &#x2013;noreplay</code></pre><p>If there is no valid target available, then the service remains at the original location and the sessions remain active. You must examine the services and stop them if that is what you want to do.</p>
                              </div>
                           </li>
                        </ul>
                        <div class="section">When you relocate a service, it starts at the new location before it stops at the original location. Oracle Clusterware can start that new instance or pluggable database as a dependency. When specified, the <code class="codeph">-drain_timeout</code> and <code class="codeph">-stopoption</code> parameters override the service attributes.
                        </div>
                        <!-- class="section" -->
                     </div>
                  </div>
                  <div class="sect4"><a id="GUID-9CEC40F3-CE0E-4A41-9687-EF6510E51C93" name="GUID-9CEC40F3-CE0E-4A41-9687-EF6510E51C93"></a><h5 id="RACAD-GUID-9CEC40F3-CE0E-4A41-9687-EF6510E51C93" class="sect5">Stopping Services</h5>
                     <div>
                        <p>You can use the <code class="codeph">srvctl stop service</code> command to stop all services on a node, all services offered by a database, all services offered by a pluggable database, or all services offered on an instance or within a given server pool.
                        </p>
                        <div class="section">You can also supply a list of services (a subset of all services) that you want to stop to the <code class="codeph">srvctl stop service</code> command, and you can also restrict the <code class="codeph">srvctl stop service</code> command to stop only the parallel query service by specifying the <code class="codeph">-pq</code> parameter.
                        </div>
                        <!-- class="section" -->
                        <div class="section">The following examples illustrate how you can stop services:</div>
                        <!-- class="section" -->
                        <ul>
                           <li class="stepexpand"><span>To stop all of the services offered by a single pluggable database:</span><div><pre class="pre codeblock"><code>$ srvctl stop service &#x2013;db myRACCDB01 &#x2013;pdb myPDB01 &#x2013;drain_timeout 15 &#x2013;stopoption TRANSACTIONAL</code></pre><p>To stop all services on a given database and any of its pluggable databases:</p><pre class="pre codeblock"><code>$ srvctl stop service &#x2013;db myRACDB &#x2013;drain_timeout 15 &#x2013;stopoption IMMEDIATE</code></pre><p>To stop only a subset of the services offered by a database:</p><pre class="pre codeblock"><code>$ srvctl stop service &#x2013;db myRACDB &#x2013;service "myFirstService,mySecondService,
  myThirdService" &#x2013;drain_timeout 60 &#x2013;stopoption IMMEDIATE</code></pre><div class="infoboxnote" id="GUID-9CEC40F3-CE0E-4A41-9687-EF6510E51C93__GUID-752D8114-7C0C-419D-8860-C70BBC91FBB9">
                                    <p class="notep1">Note:</p>If you use the <code class="codeph">&#x2013;wait YES</code> SRVCTL command line parameter, then the <code class="codeph">&#x2013;stopoption</code> parameter is not enforced until the entire drain timeout interval has expired, even if all of the sessions have exited prior to this interval completing.
                                 </div>
                              </div>
                           </li>
                        </ul>
                     </div>
                  </div>
               </div>
               <div class="sect3"><a id="GUID-2DD974C8-94C2-446B-B2BD-81B8135A26C3" name="GUID-2DD974C8-94C2-446B-B2BD-81B8135A26C3"></a><h4 id="RACAD-GUID-2DD974C8-94C2-446B-B2BD-81B8135A26C3" class="sect4">Server Draining Ahead of Planned Maintenance</h4>
                  <div>
                     <p>Before planned maintenance, drain or fail over database sessions at the database instance so application work is not interrupted. Beginning with Oracle Database 18c, the database itself drains the sessions.</p>
                     <p>When you prepare for planned maintenance, you must stop or relocate the services that are using the server infrastructure. Relocating services is done over a period of time prior to the planned outage and is based on the nature of work associated with each service.</p>
                     <p>The procedure for rolling planned maintenance moves services in advance of maintenance to another database instance, and notifies the client-side drivers, connections pools, the database instance itself, and other subscribers that maintenance is pending, and what needs to be drained (either connections or sessions using this service). Once notified of draining, a <span class="bold"><a href="glossary.html#GUID-D7C185C7-84A9-4935-AAB6-CADC23C705DE"><span class="xrefglossterm">Fast Application Notification (FAN)</span></a></span> event is sent and the client pools behave as described elsewhere, in addition, the database begins to search for safe places to release connections and, if needed, to migrate the connections.
                     </p>
                     <p>Moving or stopping a service triggers a FAN notification that is received by the subscribing Oracle drivers and Oracle connection pools. Starting with Oracle Database 18c, the FAN notification also triggers session draining at the server. Immediately, new work to that service is directed to another functioning instance of that service. Existing sessions are marked for release after their work completes. As work completes and the connections are returned to the connection pool, either the Oracle driver or the connection pool terminates these sessions.</p>
                     <div class="section">
                        <p class="subhead3" id="GUID-2DD974C8-94C2-446B-B2BD-81B8135A26C3__GUID-857BEAB6-49F6-47B2-AC0F-938D78F00C02">Draining Sessions at the Database</p>
                        <p>For OLTP applications, application servers, and custom applications, which all have their own connection pools that borrow and return database sessions, it is safe to drain a database session when it is no longer borrowed. The optimal point for the Oracle server infrastructure to close a session is when the application server tests the validity of that connection. No error is returned to the application when the connection pool manager tests the validity of connections when borrowing and releasing, and also finds that the connection is no longer valid.</p>
                        <p>A safe place is a point where an application is not disturbed. In the case of connection pools, that means connections that are not borrowed (checked-in), and, in the case of applications, the same applies at the point of borrowing or returning a connection. At this time, all work is either complete or not started. The database can also fail over connections when all states can be restored transparent to the application.</p>
                        <div class="p">Starting with Oracle Database 18c, the database uses an extensible set of rules and heuristics to detect when to take the database session away. When draining starts, the database session persists at the database until a rule is satisfied. The rules include the following:
                           <ul style="list-style-type: disc;" id="GUID-2DD974C8-94C2-446B-B2BD-81B8135A26C3__UL_WMF_D1B_LHB">
                              <li>
                                 <p>Standard application server tests for validity</p>
                              </li>
                              <li>
                                 <p>Custom SQL tests for validity</p>
                              </li>
                              <li>
                                 <p>Request boundaries are in effect and no request is active</p>
                              </li>
                              <li>
                                 <p>Request boundaries are in effect and the current request has ended</p>
                              </li>
                              <li>
                                 <p>The session has one or more session states that are recoverable, and can be recreated at failover</p>
                              </li>
                           </ul>
                           <div class="infoboxnote" id="GUID-2DD974C8-94C2-446B-B2BD-81B8135A26C3__GUID-95A4977F-FE60-4F16-92EF-CE4C119FF7CC">
                              <p class="notep1">Note:</p>To drain connections beginning with Oracle Database 18c, see <span class="q">"<a href="ensuring-application-continuity.html#GUID-2DD974C8-94C2-446B-B2BD-81B8135A26C3__ADDINGDISABLINGENABLINGANDREMOVINGC-39545C9C">Adding, Disabling, Enabling, and Removing Connection Tests for Draining at the Server</a>"</span>.
                           </div>
                        </div>
                        <p>In the case of connection tests, for example, it is standard practice for application servers, pooled applications, job schedulers, and others, to test connections when borrowed from connection pools, when returned to the pool, and at batch commits. When draining, the database intercepts the connection test, closes the connection and returns a failed status for the test. The application layer issuing the connection test is ready to handle a failed return status and, typically, issues a further request, to obtain a different connection. The application is not disturbed.</p>
                        <p>Not all sessions can be drained, such as when a connection is not returned to the pool or when FAN is not in use. If Transparent Application Continuity or Application Continuity is enabled, then the server detects request boundaries where Application Continuity can recover the session fast. The server can interrupt the session, which Application Continuity recovers elsewhere (such as, to another server in the Oracle RAC cluster) with no interruption.</p>
                        <p>For database sessions that do not drain, the database must find a break point when the session can be replaced. At a break point, a connection can be failed over transparently when states are known and recoverable. Break points can be transaction boundaries, a request starting (beginRequest), before calls are executed in that request, and patterns, such as an audit call that signals that a request is starting or ending. Break points apply only when states are known to be restorable.</p>
                        <div class="p">Failing over connections requires that you enable Application Continuity, Transparent Application Continuity, or transparent application failover (TAF), depending on your application.
                           <div class="infoboxnote" id="GUID-2DD974C8-94C2-446B-B2BD-81B8135A26C3__GUID-F5B0CE01-AB63-47F6-B1F0-D08CCCD9889C">
                              <p class="notep1">Note:</p>Oracle recommends that you use Oracle connection pools such as UCP or OCI Session Pool because these offer significant advantages in providing continuous availability, load balancing, and so on.
                           </div>
                        </div>
                     </div>
                     <!-- class="section" -->
                     <div class="section" id="GUID-2DD974C8-94C2-446B-B2BD-81B8135A26C3__ADDINGDISABLINGENABLINGANDREMOVINGC-39545C9C">
                        <p class="subhead3" id="GUID-2DD974C8-94C2-446B-B2BD-81B8135A26C3__GUID-9CD32259-7682-4A61-941A-C3AE132FB8C0">Adding, Disabling, Enabling, and Removing Connection Tests for Draining at the Server</p>
                        <p>You can add a SQL connection test to a service, a pluggable database, or non-container database.</p>
                        <div class="p">There are four SQL connection tests added for every database service and pluggable database service, by default, so, if an application uses these following SQL connection tests on the connection, then you do not to need to add them:<pre class="pre codeblock"><code>SELECT 1 FROM DUAL;
SELECT COUNT(*) FROM DUAL;
SELECT 1;
BEGIN NULL;END;</code></pre></div>
                        <div class="p">
                           <ul style="list-style-type: disc;">
                              <li>
                                 <div class="p">To add a server-side SQL connection test for a service, use a SQL statement similar to the following:<pre class="pre codeblock"><code>SQL&gt; execute dbms_app_cont_admin.add_sql_connection_test('select dummy from dual','sw_orcl');</code></pre></div>
                                 <div class="p">To add a server-side SQL connection test for a pluggable database or non-container database, log on to the non-container database and use a SQL statement similar to the following:<pre class="pre codeblock"><code>SQL&gt; execute dbms_app_cont_admin.add_sql_connection_test('begin null;end;');
</code></pre></div>
                                 <p>After you add the SQL connection test, it will be enabled by default.</p>
                              </li>
                              <li>
                                 <div class="p">You can disable a SQL connection test if you do not need it or it is not in use by logging on to a pluggable database or non-container database and using a SQL statement similar to the following:<pre class="pre codeblock"><code>SQL&gt; execute dbms_app_cont_admin.disable_connection_test(dbms_app_cont_admin.sql_test,'select dummy from dual');</code></pre></div>
                                 <p>By default, the ping test and end request test are disabled but, if you want to disable them after enabling them, then you can use either of the following SQL statements:</p>
                                 <div class="p">If you want to disable the ping test, then use a SQL statement similar to the following:<pre class="pre codeblock"><code>SQL&gt; execute dbms_app_cont_admin.disable_connection_test(dbms_app_cont_admin.ping_test);</code></pre></div>
                                 <div class="p">If you want to disable the end request test, then use a SQL statement similar to the following:<pre class="pre codeblock"><code>SQL&gt; execute dbms_app_cont_admin.disable_connection_test(dbms_app_cont_admin.endrequest_test);</code></pre></div>
                              </li>
                              <li>
                                 <div class="p">You can enable a SQL connection test after you disable it by logging on to the pluggable database or non-container database and using a SQL statement similar to the following:<pre class="pre codeblock"><code>SQL&gt; execute dbms_app_cont_admin.enable_connection_test(dbms_app_cont_admin.sql_test,'select dummy from dual');</code></pre></div>
                                 <p>You can also enable the ping test and end request test if they are disabled by using either of the following SQL statements:</p>
                                 <div class="p"> If you want to run any test that uses ping such as <code class="codeph">isValid</code>, <code class="codeph">isUsable</code>, <code class="codeph">OCIping</code>, or <code class="codeph">connection.status</code>, then use a SQL statement similar to the following:<pre class="pre codeblock"><code>SQL&gt; execute dbms_app_cont_admin.enable_connection_test(dbms_app_cont_admin.ping_test);</code></pre></div>
                                 <div class="p">If you want to enable draining at the end of a request, then use a SQL statement similar to the following:<pre class="pre codeblock"><code>SQL&gt; execute dbms_app_cont_admin.enable_connection_test(dbms_app_cont_admin.endrequest_test);</code></pre></div>
                                 <div class="p">If you want to disable draining on the end of a request, then use a SQL statement similar to the following:<pre class="pre codeblock"><code>SQL&gt; execute dbms_app_cont_admin.disable_connection_test(dbms_app_cont_admin.endrequest_test);</code></pre></div>
                              </li>
                              <li>
                                 <div class="p">You can remove a SQL connection test if it is not needed by logging on to the pluggable database or non-container database and running SQL statements similar to the following:<pre class="pre codeblock"><code>SQL&gt; execute dbms_app_cont_admin.delete_sql_connection_test('select dummy from dual','sw_orcl');
SQL&gt; execute dbms_app_cont_admin.delete_sql_connection_test('begin null;end;');</code></pre></div>
                              </li>
                           </ul>
                        </div>
                        <p>Every application server has a feature to test the validity of the connections in their respective connection pools, which is set either by a configuration property or at the administrative console. The purpose of the test is to prevent vending an unusable connection to an application, and when an unusable connection is detected, to remove it when released to the pool.</p>
                        <p>Across the various application servers, the tests have similar names. The tests offered use various approaches, the most common being a SQL statement. Oracle recommends that Java application servers use the standard Java call <code class="codeph">connection.isValid</code>. Beginning with Oracle Database 18c, these tests are used to drain the database. Also beginning with Oracle Database 18c, the database drains sessions without using FAN by inspecting sessions for safe draining points.
                        </p>
                        <p>The following table describes the standard connection tests available for several of the more common application servers:</p>
                        <div class="tblformal" id="GUID-2DD974C8-94C2-446B-B2BD-81B8135A26C3__GUID-4ABEA3DB-9D80-4AEE-81FE-BCD95235E2FB">
                           <p class="titleintable">Table 6-3 Standard Connection Tests for Some Common Application Servers</p>
                           <table cellpadding="4" cellspacing="0" class="Formal" title="Standard Connection Tests for Some Common Application Servers" summary="Describes several common application servers and their associated connection tests to a database." frame="hsides" border="1" rules="rows">
                              <thead>
                                 <tr align="left" valign="top">
                                    <th align="left" valign="bottom" width="20%" id="d23610e3779">Application Server</th>
                                    <th align="left" valign="bottom" width="20%" id="d23610e3781">Connection Test to Database</th>
                                 </tr>
                              </thead>
                              <tbody>
                                 <tr align="left" valign="top">
                                    <td align="left" valign="top" width="20%" id="d23610e3785" headers="d23610e3779 ">
                                       <p>Oracle WebLogic Server</p>
                                    </td>
                                    <td align="left" valign="top" width="20%" headers="d23610e3785 d23610e3781 ">
                                       <div class="p">The tests offered include:
                                          <ul style="list-style-type: disc;">
                                             <li>
                                                <div class="p"><pre class="pre codeblock"><code>dbms_app_cont_admin.enable_connection_test(dbms_app_cont_admin.sql_test,'select 1 from dual');</code></pre></div>
                                             </li>
                                             <li>
                                                <p><code class="codeph">TestConnectionsonReserve</code>:
                                                </p>
                                                <p><code class="codeph">isUsable</code>, <code class="codeph">isValid</code>, or <code class="codeph">PingDatabase</code></p>
                                             </li>
                                             <li>
                                                <p><code class="codeph">TestConnectionsOnCreate</code> (SQL syntax) for server draining:
                                                </p><pre class="pre codeblock"><code>Select 1 from dual;</code></pre></li>
                                          </ul>
                                       </div>
                                    </td>
                                 </tr>
                                 <tr align="left" valign="top">
                                    <td align="left" valign="top" width="20%" id="d23610e3818" headers="d23610e3779 ">
                                       <p>Oracle WebLogic Server Active Gridlink</p>
                                    </td>
                                    <td align="left" valign="top" width="20%" headers="d23610e3818 d23610e3781 ">
                                       <div class="p">The test is embedded:<pre class="pre codeblock"><code>isUsable</code></pre></div>
                                    </td>
                                 </tr>
                                 <tr align="left" valign="top">
                                    <td align="left" valign="top" width="20%" id="d23610e3827" headers="d23610e3779 ">
                                       <p>IBM WebSphere</p>
                                    </td>
                                    <td align="left" valign="top" width="20%" headers="d23610e3827 d23610e3781 "><pre class="pre codeblock"><code>dbms_app_cont_admin.enable_connection_test(dbms_app_cont.sql_test,'select 1 from dual');
</code></pre><p>Pretest connections (SQL syntax) for server draining:</p><pre class="pre codeblock"><code>Select 1 from dual;</code></pre></td>
                                 </tr>
                                 <tr align="left" valign="top">
                                    <td align="left" valign="top" width="20%" id="d23610e3838" headers="d23610e3779 ">
                                       <p>RedHat JBoss</p>
                                    </td>
                                    <td align="left" valign="top" width="20%" headers="d23610e3838 d23610e3781 ">
                                       <div class="p"><code class="codeph">check-valid-connection-sql</code> (SQL syntax):<pre class="pre codeblock"><code>dbms_session.enable_connection_test(dbms_session.sql_test,'select 1 from dual');</code></pre></div>
                                    </td>
                                 </tr>
                                 <tr align="left" valign="top">
                                    <td align="left" valign="top" width="20%" id="d23610e3849" headers="d23610e3779 ">
                                       <p>Apache Tomcat</p>
                                    </td>
                                    <td align="left" valign="top" width="20%" headers="d23610e3849 d23610e3781 ">
                                       <div class="p">There are two tests available<code class="codeph">testOnBorrow</code> and <code class="codeph">testOnReturn</code>and they both use SQL syntax to test the connection to the database:<pre class="pre codeblock"><code>dbms_app_cont.enable_connection_test(dbms_app_cont.sql_test,'select 1 from dual');</code></pre></div>
                                       <div class="p">Application server uses:<pre class="pre codeblock"><code>Select 1 from dual;</code></pre></div>
                                    </td>
                                 </tr>
                              </tbody>
                           </table>
                        </div>
                        <!-- class="inftblhruleinformal" -->
                        <p>Oracle recommends that you use the following format for supporting automatic configuration of Oracle Notification Services (ONS), so that you can receive FAN events (over ONS):</p>
                     </div>
                     <!-- class="section" -->
                     <div class="example" id="GUID-2DD974C8-94C2-446B-B2BD-81B8135A26C3__AUTOMATICCONFIGURATIONOFFAN-309F5DDA">
                        <p class="titleinexample">Example 6-1 Automatic Configuration of FAN</p><pre class="pre codeblock"><code>alias =(DESCRIPTION =
 (CONNECT_TIMEOUT=90)(RETRY_COUNT=20)(RETRY_DELAY=3)(TRANSPORT_CONNECT_TIMEOUT=3) 
   (ADDRESS_LIST =
   (LOAD_BALANCE=on)
   ( ADDRESS = (PROTOCOL = TCP)(HOST=primary-scan)(PORT=1521)))
   (ADDRESS_LIST =
   (LOAD_BALANCE=on)
   ( ADDRESS = (PROTOCOL = TCP)(HOST=secondary-scan)(PORT=1521)))
  (CONNECT_DATA=(SERVICE_NAME = gold-cloud)))
</code></pre></div>
                     <!-- class="example" -->
                  </div>
                  <div>
                     <div class="relinfo">
                        <p><strong>Related Topics</strong></p>
                        <ul>
                           <li><a href="ensuring-application-continuity.html#GUID-DA6B6272-C420-4A1F-BB5F-E9A81A5469D8" title="Oracle recommends that you drain database sessions from the instance over a controlled time period from FAN-enabled Oracle or non-Oracle connection pools, or, beginning with Oracle Database 18c at the database, itself.">Managing Planned Maintenance Without User Interruption</a></li>
                           <li><a href="ensuring-application-continuity.html#GUID-B2895452-68A1-45E5-A9A7-1888B7B10481" title="Applications achieve continuous availability when planned maintenance and unplanned outages of the database are transparent.">Transparent Application Continuity</a></li>
                        </ul>
                     </div>
                  </div>
                  
               </div>
            </div><a id="ADFNS367"></a><a id="ADFNS1105"></a><div class="sect2"><a id="GUID-BD699AEB-9F85-42A8-8687-5A979918938D" name="GUID-BD699AEB-9F85-42A8-8687-5A979918938D"></a><h3 id="RACAD-GUID-BD699AEB-9F85-42A8-8687-5A979918938D" class="sect3">About Application Continuity</h3>
               <div>
                  <p>Application Continuity masks many recoverable database outages (when replay is successful) from applications and users by restoring the database session: the full session, including all states, cursors, variables, and the last transaction if there is one.</p>
                  <p>Application Continuity addresses the problem that arises when an application is trying to access the database and the database instance becomes unavailable due to an unplanned or planned outage (timeout, network outage, instance failure, repair, configuration change, patch apply, and so on). Without Application Continuity in place, database recovery does not mask outages to applications and end users. In such scenarios, developers and users must cope with exception conditions, and users can be left not knowing what happened to their funds transfers, time sheets, orders, bill payments, and so on. Users might lose screens of uncommitted data, and must log in again and reenter that data. In the worst cases, the administrator might be forced to restart the middle tier to recover from an overwhelming number of logins.</p>
                  <p>With Application Continuity, if the database instance becomes unavailable, then Application Continuity attempts to rebuild the session and any open transactions using the correct states; and if the transaction committed and need not be resubmitted, then the successful return status is returned to the application. If replay is successful, then the request can continue safely without risk of duplication. If replay cannot restore data that the application has already processed and potentially made decisions on, then the database rejects the replay and the application receives the original error.</p>
                  <p>Application Continuity performs the recovery of in-flight transactions and database session state, while ensuring the transaction idempotence provided by Transaction Guard. Each database session is tagged with a logical transaction ID (LTXID), so the database recognizes whether each replay committed any transactions, and if it did commit any transactions, whether the work also ran to completion. While Application Continuity attempts to replay, the replay appears to the application as a delayed execution, or the application receives the commit response for the original transaction (if the last transaction had completed before the outage).</p>
                  <p>Application Continuity is supported for Oracle RAC and Oracle Active Data Guard. It is supported for both non-consolidated databases and Multitenant databases (with failover at the pluggable database level). It is not currently supported for Golden Gate, Logical Standby, third-party replication solutions, or DML redirection if using Oracle Active Data Guard.</p>
               </div>
               <div>
                  <div class="relinfo">
                     <p><strong>Related Topics</strong></p>
                     <ul>
                        <li><a href="ensuring-application-continuity.html#GUID-815F5DF2-6B6E-4E5B-922D-6FCAA4A0AD81">Actions for Using Application Continuity</a></li>
                     </ul>
                  </div>
               </div><a id="ADFNS386"></a><a id="ADFNS394"></a><a id="ADFNS395"></a><a id="ADFNS1072"></a><a id="ADFNS1087"></a><a id="ADFNS368"></a><div class="sect3"><a id="GUID-1BEE7C6A-8F21-47A1-8449-20E155ECBA02" name="GUID-1BEE7C6A-8F21-47A1-8449-20E155ECBA02"></a><h4 id="RACAD-GUID-1BEE7C6A-8F21-47A1-8449-20E155ECBA02" class="sect4">Key Concepts for Application Continuity</h4>
                  <div>
                     <p>This section describes several terms and concepts that you must understand to use Application Continuity.</p>
                     <p>The following terms are used throughout this chapter:</p>
                     <div class="section">
                        <p class="subhead3" id="GUID-1BEE7C6A-8F21-47A1-8449-20E155ECBA02__GUID-2AE51DC2-5EA7-406B-A5E0-099C2FB8634D">Database request</p>
                     </div>
                     <!-- class="section" -->
                     <p>A database request is a unit of work submitted to the database from the application, such as a transaction. A request typically corresponds to the SQL and PL/SQL, and other database calls, of a single web request on a single database connection, and it is generally demarcated by the calls made to check-out and check-in the database connection from a connection pool.</p>
                     <div class="section">
                        <p class="subhead3" id="GUID-1BEE7C6A-8F21-47A1-8449-20E155ECBA02__GUID-14412F7B-39A0-4F57-98BB-E351852F463E">Recoverable error</p>
                     </div>
                     <!-- class="section" -->
                     <p>A recoverable error is an error that arises due to an external system failure, independent of the application session logic that is executing, such as a lost or invalid connection. Recoverable errors occur following planned and unplanned outages of foregrounds, networks, nodes, storage, and databases. The application receives an error code that can leave the application not knowing the status of the last operation submitted. Application Continuity reestablishes database sessions and resubmits the pending work for the class of recoverable errors.</p>
                     <p>Application Continuity does not resubmit work following call failures due to nonrecoverable errors. An example of a nonrecoverable error that would <span class="italic">not</span> be replayed is submission of invalid data values.
                     </p>
                     <div class="section">
                        <p class="subhead3" id="GUID-1BEE7C6A-8F21-47A1-8449-20E155ECBA02__GUID-1D06B1CA-F9C7-4F95-8914-2AE22DC8EBC3">Commit outcome</p>
                     </div>
                     <!-- class="section" -->
                     <p>A transaction is committed by updating its entry in the transaction table. Oracle Database generates a redo-log record corresponding to this update and writes out this redo-log record. Once this redo-log record is written out to the redo log on disk, the transaction is considered committed at the database. From the client perspective, the transaction is considered committed when an Oracle message (called the <span class="italic">commit outcome</span>), generated after that redo is written, is received by the client. However, if a <code class="codeph">COMMIT</code> has been issued, then the <code class="codeph">COMMIT</code> failure message cannot be retrieved if it is not received by the client or the application.
                     </p>
                     <div class="section">
                        <p class="subhead3" id="GUID-1BEE7C6A-8F21-47A1-8449-20E155ECBA02__GUID-087DD9E8-FD26-4986-A5B8-A2930279277A">Mutable functions</p>
                     </div>
                     <!-- class="section" -->
                     <p>Mutable functions are non-deterministic functions that can obtain a new value every time they are called, and thus their results can change frequently. Mutable functions cause a problem for replay because the results can change at replay. Consider <span class="italic">sequence</span><code class="codeph">.NEXTVAL</code> and <code class="codeph">SYSDATE</code>, often used in key values. If a primary key is built with values from these function calls, and is used in later foreign keys or other binds, at replay the same function result must be returned.
                     </p>
                     <p>Application Continuity provides mutable object value replacement at replay for granted Oracle function calls to provide opaque bind-variable consistency. If the call uses database functions that are mutable, including<span class="italic"> sequence</span><code class="codeph">.NEXTVAL</code>, <code class="codeph">SYSDATE</code>, <code class="codeph">SYSTIMESTAMP</code>, and <code class="codeph">SYSGUID</code>, the original values returned from the function execution are saved and are reapplied at replay.
                     </p>
                     <div class="section">
                        <p class="subhead3" id="GUID-1BEE7C6A-8F21-47A1-8449-20E155ECBA02__GUID-2D99E158-84E7-4E72-ACA1-4AFED2BAE744">Session state consistency</p>
                     </div>
                     <!-- class="section" -->
                     <p>After a <code class="codeph">COMMIT</code> statement has executed, if state was changed in that transaction, it is not possible to replay the transaction to reestablish that state if the session is lost. When configuring Application Continuity, the applications are categorized depending on whether the session state after the initial setup is static or dynamic (or use <code class="codeph">AUTO</code> so the decision is automatic), and thus whether it is correct to continue past a <code class="codeph">COMMIT</code> operation within a request.
                     </p>
                     <ul style="list-style-type: disc;">
                        <li>
                           <p>A session has <span class="bold">dynamic</span> state if the session state changes are not fully encapsulated by the initialization, and cannot be fully captured by FAILOVER_RESTORE or in a callback at failover. After the first transaction completes, failover is internally disabled until the next request begins. Session state may change during the course of the request.
                           </p>
                        </li>
                        <li>
                           <p>A session has a <span class="bold">static</span> state if all session state changes (for example, NLS settings and PL/SQL package state) occur as part of initialization, and can be encapsulated by <code class="codeph">FAILOVER_RESTORE</code> or in a callback at failover. Static applications are those that were able to use Transparent Application Failover (TAF) before Application Continuity. Session state does not change during the course of the request. (Choose setting session state consistency to <code class="codeph">AUTO</code> over <code class="codeph">STATIC</code> mode, when possible, because auto mode purges and cleans more efficiently than the pre-Application Continuity TAF mode.)
                           </p>
                        </li>
                        <li>
                           <p>With Transparent Application Continuity, the state is managed for you by setting session state consistency to <code class="codeph">AUTO</code> (this is a mandatory setting for Transparent Application Continuity). These session states are tracked and verified at failover. You can add further states if outside the preset states.
                           </p>
                        </li>
                     </ul>
                  </div>
               </div>
               <div class="sect3"><a id="GUID-B2895452-68A1-45E5-A9A7-1888B7B10481" name="GUID-B2895452-68A1-45E5-A9A7-1888B7B10481"></a><h4 id="RACAD-GUID-B2895452-68A1-45E5-A9A7-1888B7B10481" class="sect4">Transparent Application Continuity</h4>
                  <div>
                     <p>Applications achieve continuous availability when planned maintenance and unplanned outages of the database are transparent.</p>
                     <p>Transparent Application Continuity is a functional mode of Application Continuity beginning with Oracle RAC 18c that transparently tracks and records session and transactional state so that a database session can be recovered following recoverable outages. This is done safely and with no need for a DBA to have any knowledge of the application or make application code changes. Transparency is achieved by using a state-tracking infrastructure that categorizes session state usage as an application issues user calls.</p>
                     <p>You can enable Transparent Application Continuity as default to protect applications during planned maintenance and when unplanned outages occur. For planned maintenance, database sessions that reach a safe place (such as a connection test or a known recoverable point) are drained at the database. For database sessions that do not drain, the database determines where to fail the database session over and invokes Application Continuity to do so. Application Continuity hides unplanned outages for Java-based applications, OCI and ODP.NET applications including SQL*Plus, all Oracle connection pools, Tuxedo, WebLogic Server, and third-party application servers using Universal Connection Pool.</p>
                     <div class="p">With Transparent Application Continuity, DBAs no longer need to have knowledge of an application to:
                        <ul style="list-style-type: disc;">
                           <li>
                              <p>Restore preset states</p>
                              <p>At run time, Transparent Application Continuity records the initial preset session states, monitors further states, and records session signatures sufficient to detect deviation in the state of a session at failover for monitored states. At failover, Transparent Application Continuity restores the preset session states before replay starts, and verifies that these session states fully match the original before replay starts. This also allows for session state that has been restored using both Application Continuity and other mechanisms, such as log-on triggers, labels, and connection call backs. You will continue to add log-on triggers, call backs, or labels if the state is outside the preset states.</p>
                           </li>
                           <li>
                              <p>Recognize and disable application-level side effects when recovering a session</p>
                              <p>During normal runtime, Transparent Application Continuity detects side effects. The type of side effect is distinguished between those that relate to an applications logic and those that are internal, relating to database housekeeping. For applications that use statements that have side effects, capture is disabled when the statement is running. Once a new request starts, capture is re-enabled automatically.</p>
                           </li>
                           <li>
                              <p>Keep mutable values for owned functions</p>
                              <p>Mutable functions are functions that can return a new value each time they are run. Oracle provides support for keeping the original results of mutable functions <code class="codeph">SYSDATE</code>, <code class="codeph">SYSTIMESTAMP</code>, <code class="codeph">SYS_GUID</code>, and <code class="codeph">sequence.NEXTVAL</code>. If the original values are not kept and if different values are returned to the application at replay, then Transparent Application Continuity rejects replay. Use grants to keep your sequences, dates, and times. When an application is using its own schema, you can assign the grants for keeping to a role and then grant this role to users.
                              </p>
                           </li>
                           <li>
                              <p>For applications using Application Continuity with JDBC thin driver (beginning with Oracle Database 18c) and OCI and ODP.NET Unmanaged Provider (beginning with Oracle Database 19c (19.3)), DBAs do not need to know about request boundaries but when they are in use, Transparent Application Continuity takes advantage of them. It is best practice that you use request boundaries because it is not always possible to identify a checkpoint where a request boundary can be inserted.</p>
                              <p>Request Boundaries demark where applications and application servers borrow and return connections from their connection pools. Until Oracle RAC 18c, without request boundaries, the lower layers, (such as the database and drivers) have no insight as to how the applications and application servers are managing their connections. Almost every application server and enterprise application, and custom development using good practices, caches their connections in their layer for best performance. The lower layers cannot see how the connections are being handled and balanced. The lower layer could only see user calls to the database.</p>
                              <p>Using Transparent Application Continuity, the server and the drivers are tracking transaction and session state usage. This allows the driver to detect and inject possible request boundaries. At a possible request boundary, no objects are open, cursors are returned to the driver statement cache, no transactions are open, and the session state is known to be restorable. The driver either closes the current capture and starts new, or enables capture if there had been a disabling event. On the next call to the server, the server verifies and, if applicable, creates a request boundary where there was previously no explicit boundary.</p>
                           </li>
                        </ul>
                     </div>
                     <p>When you use Transparent Application Continuity for Java (beginning with Oracle Database 18c) and OCI and ODP.NET Unmanaged Provider (beginning with Oracle Database 19c (19.3)), your applications will experience lower resource usage and faster recovery because statements that do not contribute to the state are not recorded, or they are purged when no longer needed, and request boundaries are advanced automatically.</p>
                     <p>For unplanned outages, Transparent Application Continuity is invoked for outages that result in recoverable errors, typically related to underlying software, foreground, hardware, communications, network, or storage layers, hiding most failures from applications and users.</p>
                     <p>Transparent Application Continuity is enabled when <code class="codeph">FAILOVER_TYPE=AUTO</code>.
                     </p>
                  </div>
                  <div class="sect4"><a id="GUID-6A1F70F3-9C40-4613-B4CB-577DD72092A9" name="GUID-6A1F70F3-9C40-4613-B4CB-577DD72092A9"></a><h5 id="RACAD-GUID-6A1F70F3-9C40-4613-B4CB-577DD72092A9" class="sect5">Transparent Application Continuity for Various Applications</h5>
                     <div>
                        <p>Transparent Application Continuity covers applications that belong to three different groups, automatically tracked by the state tracking system.</p>
                        <div class="p">The various applications are of the following types:
                           <ul style="list-style-type: disc;">
                              <li>
                                 <p><span class="bold">Request boundaries</span>: Applications that use containers with request boundaries allow Application Continuity to manage replay between explicit boundaries.
                                 </p>
                              </li>
                              <li>
                                 <p><span class="bold">Database agnostic</span>: Applications set a state at connection establishment and do not change non-transactional session states again, or change it rarely. For these applications, Application Continuity identifies implicit boundaries.
                                 </p>
                              </li>
                              <li>
                                 <div class="p"><span class="bold">Black Box</span>: Applications that are using either Oracle proprietary states, changing states, or both, at run time. This category is further divided:
                                    <ul style="list-style-type: disc;">
                                       <li>
                                          <p>Applications with short user calls, such as OLTP with no visible boundaries</p>
                                       </li>
                                       <li>
                                          <p>Applications with long user calls, such as DSS, reports, and warehouses</p>
                                       </li>
                                    </ul>
                                 </div>
                              </li>
                           </ul>
                        </div>
                        <div class="section">
                           <p class="subhead3" id="GUID-6A1F70F3-9C40-4613-B4CB-577DD72092A9__GUID-501793CC-7D00-46C3-9B03-3BF97924A148">Request Boundaries</p>
                           <p>A <a href="glossary.html#GUID-0ECAE9D3-2AFB-4E8F-BFF2-7E402E8E576A"><span class="xrefglossterm">request boundary</span></a> is a tag that marks the beginning and end of a database request. Beginning with Oracle Database 12<span class="italic">c</span> release 2 (12.2.0.1), connection pools that embed request boundaries include Oracle Universal Connection Pool, all WebLogic server data sources, Tuxedo, Oracle Call Interface, ODP.NET Unmanaged Provider, and standard third-party application servers and standalone Java pools that use the Oracle Database 12<span class="italic">c</span> JDBC drivers <code class="codeph">PooledConnection</code> interface, in addition to SQL*PLUS.
                           </p>
                           <div class="p">When an Oracle database is aware of request boundaries:
                              <ul style="list-style-type: disc;">
                                 <li>
                                    <p>The database can process web requests effectively and with no performance overhead, including when to attach and release connections, so it can multiplex, drain, rebalance, shed, and allow complex states inside requests. Without request boundaries, the lower layers of the database are not aware of web requests. Subsequently, the database relies on Oracle client actions, advisory methods and heuristics, such as fast connection failover, connection validation, and state advice.</p>
                                 </li>
                                 <li>
                                    <p>The length of replay is limited to the initial state followed by the user calls in that request less those that are purged by Application Continuity. Request boundaries are an important hint to control the length of replay, and also where to drain for planned maintenance (at the end of the request), and to where to fail over for planned maintenance (at the beginning of the request).</p>
                                 </li>
                                 <li>
                                    <p>When using Transparent Application Continuity for Java, only the first request boundary is required (only for Oracle Database 18c).</p>
                                 </li>
                                 <li>
                                    <p>When using Application Continuity for Java, the replay driver detects safe places to move the request boundaries forward automatically. This feature is only available with AUTO.</p>
                                 </li>
                                 <li>
                                    <p>Applications deployed using middle-tier containers that set request boundaries have access to the full set of transparency features that the database server provides. The database detects when a client sets request boundaries and uses the boundaries to mark safe points for draining, failover, concentration, and throughput measures.</p>
                                 </li>
                              </ul>
                           </div>
                           <p>Request boundaries enable an application to use all complex, non-transactional session states within a request. The request boundary specification requires that these states are not dependent across boundaries.</p>
                        </div>
                        <!-- class="section" -->
                        <div class="section">
                           <p class="subhead3" id="GUID-6A1F70F3-9C40-4613-B4CB-577DD72092A9__GUID-39FCE964-8A33-4A42-B890-A5FE9FF1F4E7">Database-agnostic Applications</p>
                           <p>Database-agnostic applications (applications with no request boundaries) set simple, non-transactional states and use none of the Oracle proprietary features or sequences. These applications often set state once when a connection is created and then do not change state again or change the state infrequently. This category of applications includes those applications that use anonymous PL/SQL that do not create server-side session state.</p>
                           <p>When using Transparent Application Continuity for JDBC applications, the state classification is used to find a point at which to enable and start recording for Application Continuity after authentication, and to re-enable recording after capture has been disabled by a disabling event. Only the first request boundary is required, and, when request boundaries are there, they are used. Request boundaries are not required for SQL*Plus, and they are embedded for ODP.NET, OCI session pool, Tuxedo, and Oracle Universal Connection Pool.</p>
                        </div>
                        <!-- class="section" -->
                     </div>
                  </div>
               </div>
            </div><a id="ADFNS356"></a><a id="ADFNS314"></a><div class="sect2"><a id="GUID-91427DA2-2C5F-46E9-93D4-B5FF6427A69B" name="GUID-91427DA2-2C5F-46E9-93D4-B5FF6427A69B"></a><h3 id="RACAD-GUID-91427DA2-2C5F-46E9-93D4-B5FF6427A69B" class="sect3">Application Continuity Operation and Usage</h3>
               <div>
                  <p>This section explains how Application Continuity works, and how you can use it in applications.</p>
                  <p>This section includes the following topics:</p>
                  <ul style="list-style-type: disc;">
                     <li>
                        <p><a href="ensuring-application-continuity.html#GUID-70D9CDC4-0C86-432B-A04E-1618AF5C35A4" title="If a recoverable error occurs and if you enabled replay, then Application Continuity attempts recovery of the database session.">How Application Continuity Works for Applications</a></p>
                     </li>
                     <li>
                        <p><a href="ensuring-application-continuity.html#GUID-815F5DF2-6B6E-4E5B-922D-6FCAA4A0AD81" title="Application Continuity masks outages with few or no application changes when you use the Oracle integrated stack.">Actions for Using Application Continuity</a></p>
                     </li>
                     <li>
                        <p><a href="ensuring-application-continuity.html#GUID-E4A114A2-EA77-4037-A62A-BDFCF1E6D072" title="When a request is replayed, the default and desired treatment of mutable objects can vary.">Mutable Functions and Application Continuity</a></p>
                     </li>
                     <li>
                        <p><a href="ensuring-application-continuity.html#GUID-3EADEA74-3224-48B5-9376-ABE3B34429B0" title="To manage mutable values you need to grant certain privileges.">Administering Mutable Values</a></p>
                     </li>
                     <li>
                        <p><a href="ensuring-application-continuity.html#GUID-987F5EE6-6C32-455A-AEF6-16066EE33F20" title="Use the statistics for request boundaries and protection level to monitor the level of coverage.">Protection-Level Statistics</a></p>
                     </li>
                     <li>
                        <p><a href="ensuring-application-continuity.html#GUID-D49C131A-5931-473E-A878-AF4B99E97F1D" title="Session state consistency describes how non-transactional state is changed during a request.">Session State Consistency</a></p>
                     </li>
                  </ul>
               </div><a id="ADFNS1319"></a><a id="ADFNS1201"></a><div class="sect3"><a id="GUID-70D9CDC4-0C86-432B-A04E-1618AF5C35A4" name="GUID-70D9CDC4-0C86-432B-A04E-1618AF5C35A4"></a><h4 id="RACAD-GUID-70D9CDC4-0C86-432B-A04E-1618AF5C35A4" class="sect4">How Application Continuity Works for Applications</h4>
                  <div>
                     <p>If a recoverable error occurs and if you enabled replay, then Application Continuity attempts recovery of the database session.</p>
                     <p>The following figure is a graphical representation of how Application Continuity works.</p>
                     <div class="figure" id="GUID-70D9CDC4-0C86-432B-A04E-1618AF5C35A4__GUID-527F8D8A-F9F1-4798-9F1B-D49D7DE91105">
                        <p class="titleinfigure">Figure 6-1 Application Continuity</p><img src="img/racad_040c.png" alt="Description of Figure 6-1 follows" title="Description of Figure 6-1 follows" longdesc="img_text/racad_040c.html"><br><a href="img_text/racad_040c.html">Description of "Figure 6-1 Application Continuity"</a></div>
                     <!-- class="figure" -->
                     <div class="p">To attempt to recover a database session following a recoverable error, Application Continuity performs the following steps:
                        <div class="infoboxnote" id="GUID-70D9CDC4-0C86-432B-A04E-1618AF5C35A4__GUID-4FA896D0-B444-4AE4-8352-53FD519F34FD">
                           <p class="notep1">Note:</p>The steps to recover a database session apply for both unplanned and planned outages, although specific steps vary depending on the type of outage.
                        </div>
                     </div>
                     <ol>
                        <li>
                           <p>The client application makes a request, which is passed to a middle tier (such as the Universal Connection Pool (UCP), ODP.NET, WebLogic Server, OCI session pool, Tuxedo, JDBC and OCI drivers, or third-party pool using UCP), or directly to the database using the JDBC replay driver or OCI driver.</p>
                        </li>
                        <li>
                           <p>The JDBC replay driver or OCI driver issues each call in the request.</p>
                        </li>
                        <li>
                           <p>A FAN unplanned or planned down interrupt or recoverable error occurs. FAN/FCF then aborts the dead physical session.</p>
                        </li>
                        <li>
                           <p>Application Continuity begins the replay and does the following:</p>
                           <ol type="a">
                              <li>
                                 <p>Replaces the dead physical session with a new clean session.</p>
                              </li>
                              <li>
                                 <p>Prepares for replay by using Transaction Guard to determine the outcome of the in-flight transaction, if one was open.</p>
                              </li>
                              <li>
                                 <p>If <code class="codeph">FAILOVER_RESTORE=LEVEL1</code> or <code class="codeph">FAILOVER_TYPE=AUTO</code>, then Application Continuity restores the common initial session state. Application Continuity uses a label callback or initial callback if an application also sets session states that are not provided by <code class="codeph">FAILOVER_RESTORE</code> in the callback
                                 </p>
                              </li>
                              <li>
                                 <p>Rebuilds the database session, recovering the transactional and non-transactional states, and validating at each step that the data and messages seen by the client driver are the same as those that the client may have seen and used to make a decision.</p>
                              </li>
                              <li>
                                 <p>Ends the replay and returns to runtime mode.</p>
                              </li>
                              <li>
                                 <p>Submits the last queued call.</p>
                                 <p>This is the last call made when the outage was discovered. During replay, only this call can execute a <code class="codeph">COMMIT</code>. A <code class="codeph">COMMIT</code> midway through rebuilding the session aborts replay (excluding autonomous transactions).
                                 </p>
                              </li>
                           </ol>
                        </li>
                        <li>
                           <p>The response is returned to the application.</p>
                           <p>If replay succeeded, then the application can continue with the problem masked. If not, then the application must handle the original error.</p>
                        </li>
                     </ol>
                     <p>The behavior of Application Continuity after a communication failure depends on the Oracle products and technologies involved. For example:</p>
                     <ul style="list-style-type: disc;">
                        <li>
                           <p>If you use Oracle RAC or an Oracle Active Data Guard farm, then, after the connection is reestablished on another running instance, Application Continuity attempts to rebuild the session and replay the last transaction if there is one in flight.</p>
                        </li>
                        <li>
                           <p>If you use Oracle Active Data Guard and fail over to a standby site, then Application Continuity connects to the failover instance and attempts to rebuild the session and replay the last transaction there, if a transaction was in-flight. (Application Continuity does not replay if the Oracle Active Data Guard switchover or failover has lost data, and if this is not an Oracle Active Data Guard reader farm with approved lags.)</p>
                        </li>
                        <li>
                           <p>If you are using Oracle RAC or Oracle RAC One Node and not using Oracle Active Data Guard, and if an outage causes a break in all public networks or causes the database or database session to shut down briefly, then Application Continuity attempts to rebuild the session and replay the last transaction (if a transaction was in flight) against the database after connectivity is restored.</p>
                        </li>
                     </ul>
                  </div>
                  <div>
                     <div class="relinfo">
                        <p><strong>Related Topics</strong></p>
                        <ul>
                           <li><a href="ensuring-application-continuity.html#GUID-61B6FEC5-90F0-4BE2-AC3B-37ECA6009545" title="For planned maintenance, the recommended approach is to drain requests from Oracle connection pools in combination with Application Continuity for those requests that do not complete. Instances do need to be stopped to switch over to the patched software.">Using Application Continuity for Planned Maintenance</a></li>
                        </ul>
                     </div>
                  </div>
               </div><a id="ADFNS188"></a><a id="ADFNS1207"></a><div class="sect3"><a id="GUID-815F5DF2-6B6E-4E5B-922D-6FCAA4A0AD81" name="GUID-815F5DF2-6B6E-4E5B-922D-6FCAA4A0AD81"></a><h4 id="RACAD-GUID-815F5DF2-6B6E-4E5B-922D-6FCAA4A0AD81" class="sect4">Actions for Using Application Continuity</h4>
                  <div>
                     <p>Application Continuity masks outages with few or no application changes when you use the Oracle integrated stack.</p>
                     <p>Application Continuity is available for general use with the following Oracle technologies:</p>
                     <ul style="list-style-type: disc;">
                        <li>
                           <p>ODP.NET, Unmanaged Driver</p>
                        </li>
                        <li>
                           <p>OCI Session Pool</p>
                        </li>
                        <li>
                           <p>Universal Connection Pool</p>
                        </li>
                        <li>
                           <p>WebLogic Server</p>
                        </li>
                        <li>
                           <p>JDBC Thin Oracle replay driver</p>
                        </li>
                        <li>
                           <p>Oracle Tuxedo</p>
                        </li>
                        <li>
                           <p>SQL*Plus</p>
                        </li>
                        <li>
                           <p>Third-party JDBC application servers with Universal Connection Pool</p>
                        </li>
                        <li>OCI-based applications with Transparent Application Continuity starting with Oracle Database 19c (19.3)</li>
                     </ul>
                     <p>Application Continuity for Java is embedded in the Universal Connection Pool, WebLogic data sources, including non-XA and XA data sources, and is available with the thin JDBC replay driver, standalone (which is a JDBC replay driver without Oracle connection pools, such as Apache Tomcat or a custom Java connection pool). Application Continuity for OCI is embedded in SQL*Plus, OCI Session Pool. Oracle Tuxedo for non XA data sources, and ODP.NET, Unmanaged Provider. With Transparent Application Continuity, JDBC applications auto enable starting with Oracle Database 18c, and OCI applications starting with Oracle Database 19c (19.3).</p>
                     <p>Application Continuity is embedded in Oracle connection pools. When you use the Oracle connection pools, request boundaries are implicitly marked at check-out and check-in, delimiting the size of each replay. When using third-party connection pools, use UCP if Java, or you can add request boundaries, which are included on the JDK9 standard. When using Transparent Application Continuity for Java, only the first request boundary is required. Request boundaries are discovered using state tracking. With the OCI driver for Oracle Database 19c, support is now available for implicit boundaries, as it is with JDBC client drivers.</p>
                     <p>Support for Application Continuity is integrated into many Oracle applications, so the features in such applications are used automatically if you set the Application Continuity-related service attributes. For all applications, follow the steps described in this section.</p>
                     <p>The main actions for ensuring transparent replay for an application are the following:</p>
                     <ol>
                        <li>
                           <p>Only if using Java, determine whether the application uses Oracle JDBC concrete classes. For Application Continuity to be used, the deprecated concrete classes must be replaced.</p>
                           <p>Use the <code class="codeph">-acchk</code> parameter with the ORAchk utility to verify whether an application has any concrete classes. Use a connection without Application Continuity if there is anything that should not be replayed. (Most applications will be replayable.)
                           </p>
                           <div class="infoboxnotealso" id="GUID-815F5DF2-6B6E-4E5B-922D-6FCAA4A0AD81__GUID-FC2252A0-73F9-48C1-AE85-9E546E7D46B0">
                              <p class="notep1">See Also:</p><span><cite>Oracle Autonomous Health Framework User's Guide</cite></span> for more information about ORAchk
                           </div>
                        </li>
                        <li>
                           <p>Ensure that you have the necessary CPU and memory resources.</p>
                           <ul style="list-style-type: disc;">
                              <li>
                                 <p><span class="bold">CPU</span>: Application Continuity is managed on the client and server sides and requires minimal CPU overhead to operate.
                                 </p>
                                 <p>At the client, CPU is used to build proxy objects and for garbage collection (GC).</p>
                                 <p>At the server, CPU is used for validation. CPU overhead is reduced for platforms with current Intel and SPARC chips where validation is assisted in the hardware.</p>
                              </li>
                              <li>
                                 <p><span class="bold">Memory</span>: When using Application Continuity, the replay driver requires more memory than the base driver because the calls are retained until the end of a request. At the end of the request, the calls are released to the garbage collector. This action differs from the base driver that releases closed calls.
                                 </p>
                                 <p>The memory consumption of the replay driver depends on the number of calls per request. If this number is small, then the memory consumption of the replay driver is less, and comparable to the base driver.</p>
                                 <p>To obtain the best performance, you must set the same value for both the <code class="codeph">-Xmx</code> and <code class="codeph">-Xms</code> parameters on the client. For example, if there is sufficient memory, then allocate 4 to 8 GB (or more) of memory for the Virtual Machine (VM), for example, by setting <code class="codeph">-Xms4g</code> for 4 GB. If the <code class="codeph">-Xms</code> parameter has a lower value, then the VM also uses a lower value from the operating system, and performance might suffer and garbage collection operations increase.
                                 </p>
                              </li>
                           </ul>
                        </li>
                        <li>
                           <div class="p">Determine whether the application borrows and returns connections from the connection pool, for example WebLogic Server Pool, Universal Connection Pool, OCI Session Pool, Oracle Tuxedo request, or ODP.NET connection pool, for each request, or whether to add <code class="codeph">beginRequest</code> and <code class="codeph">endRequest</code> APIs to the application's own connection pool to identify request boundaries for Java, only.
                              <div class="infoboxnote" id="GUID-815F5DF2-6B6E-4E5B-922D-6FCAA4A0AD81__GUID-14DBCF52-3324-488A-8433-B325A17C086B">
                                 <p class="notep1">Important:</p>Do not use the <code class="codeph">beginRequest</code> and <code class="codeph">endRequest</code> Java API calls anywhere other than at request boundaries (borrow and return connections from your connection pool). <code class="codeph">endRequest</code> indicates that the request is complete, and that it is now stateless. Replay starts from the next <code class="codeph">beginRequest</code>. If there is prior state, it must be reestablished using <code class="codeph">FAILOVER_RESTORE</code> or callback.
                              </div>
                           </div>
                        </li>
                        <li>
                           <p>Application Continuity replays all states in a request. If the application sets states before vending connections, <code class="codeph">FAILOVER_RESTORE</code> or a callback is needed. When using Oracle WebLogic Server or the Universal Connection Pool, use <code class="codeph">FAILOVER_RESTORE</code>, connection labeling, or triggers. When using OCI session pool, Oracle Tuxedo or ODP.NET with Oracle Database 18c, or later clients, use <code class="codeph">FAILOVER_RESTORE</code>, and only add the TAF callback if it is needed. The labeling is used for both runtime and replay.
                           </p>
                        </li>
                        <li>
                           <p>Determine whether the application requires, and therefore needs to configure keeping original values for, <code class="codeph">SYSDATE</code>, <code class="codeph">SYSTIMESTAMP</code>, and <code class="codeph">SYS_GUID</code> and sequences during failover.
                           </p>
                        </li>
                        <li>
                           <p>Assess the application style for the <code class="codeph">session_state_consistency</code> value, and set the appropriate value on the service:
                           </p>
                           <ul style="list-style-type: disc;">
                              <li>
                                 <p>If <code class="codeph">session_state_consistency</code> is set to <code class="codeph">AUTO</code>, then Transparent Application Continuity monitors the session state and decides what to do. If you are unsure about state usage or know that states can change in the future, then use Transparent Application Continuity. See the list of preset session states because you may need to restore additional preset states.
                                 </p>
                              </li>
                              <li>
                                 <p>If <code class="codeph">session_state_consistency</code> is set to <code class="codeph">DYNAMIC</code>, then the application changes the environment or settings during the request. Replay is disabled after the first <code class="codeph">COMMIT</code> until the beginning of the next request. <code class="codeph">DYNAMIC</code> is the default mode, appropriate for most applications.
                                 </p>
                              </li>
                              <li>
                                 <p>If <code class="codeph">session_state_consistency</code> is set to <code class="codeph">STATIC</code>, then the application <span class="italic">never</span> changes the session state after initial setup. This mode is typical for database agnostic applications that do not use PL/SQL state and do not use <code class="codeph">ALTER</code> part-way through transactions. Use this mode with caution, and only for "static" applications.
                                 </p>
                              </li>
                           </ul>
                        </li>
                        <li>
                           <p>Determine if any requests in the application should not be replayed.</p>
                           <p>For example, replay may need to be disabled for requests using external PL/SQL actions.</p>
                        </li>
                        <li>
                           <p>Follow these configuration guidelines:</p>
                           <ul style="list-style-type: disc;">
                              <li>
                                 <p>Use Oracle Database 12<span class="italic">c</span> release 1 (12.1.0.1), or later, for Java. Use Oracle Database 12<span class="italic">c</span> release 2 (12.2), or later, for OCI-based applications.
                                 </p>
                              </li>
                              <li>
                                 <p>For .NET applications, use ODP.NET, Unmanaged Driver 12.2, or later, connecting to an Oracle Database 12<span class="italic">c</span> Release 2 (12.2) or later. By default, Application Continuity is enabled for ODP.NET applications in this configuration.
                                 </p>
                              </li>
                              <li>
                                 <p>For Java-based applications, use Universal Connection Pool 12.1 (or later) or WebLogic Server 12.1.2 (or later) configured with the JDBC Replay data source; or for third party applications, including third party JDBC pools, use JDBC replay driver. For IBM WebSphere, Apache Tomcat, RedHat Spring, and custom Java solutions, the most effective solution is to use UCP as the pooled data source.</p>
                                 <p>Custom Java pools and standalone Java applications can also use the JDBC Replay data source directly. When using custom Java pools and standalone applications, add the <code class="codeph">beginRequest</code> and <code class="codeph">endRequest</code> calls.
                                 </p>
                              </li>
                              <li>
                                 <p>If the application does not borrow and return from the Oracle connection pools, explicitly mark request boundaries. For example, if using custom JDBC pools, or other pools, then call <code class="codeph">beginRequest</code> at check-out and call <code class="codeph">endRequest</code> at check-in. These APIs can also be used for standalone JDBC applications without a connection pool.
                                 </p>
                              </li>
                              <li>
                                 <p>Enable FAN for fast interrupt on errors. This is essential to eliminate a TCP hang occurring before the failover can start. In 12.2 FAN is built into the JDBC and OCI drivers and is on by default for Java.</p>
                              </li>
                              <li>
                                 <p>Use a database service to connect; never use a SID or an instance name, or the administration service that is the <code class="codeph">DB_NAME</code> or <code class="codeph">DB_UNIQUE_NAME</code>.
                                 </p>
                              </li>
                              <li>
                                 <p>Use a connection string that sets retries for new incoming connections and a delay between these retries.</p>
                              </li>
                              <li>
                                 <p>For the service, set <code class="codeph">FAILOVER_TYPE</code> to <code class="codeph">TRANSACTION</code> for the manual mode of Application Continuity or set <code class="codeph">FAILOVER_TYPE</code> to <code class="codeph">AUTO</code> for Transparent Application Continuity. Set <code class="codeph">COMMIT_OUTCOME</code> to <code class="codeph">TRUE</code> and, for OCI FAN, set <code class="codeph">NOTIFICATION</code> to <code class="codeph">TRUE</code>. Optionally to find the best connections to use, set <code class="codeph">GOAL</code> to <code class="codeph">SERVICE_TIME</code> and <code class="codeph">CLB_GOAL</code> to <code class="codeph">SHORT</code>.
                                 </p>
                              </li>
                              <li>
                                 <div class="p">Grant permission on the Transaction Guard package, <code class="codeph">DBMS_APP_CONT</code>, to the database users that fail over using Application Continuity, as follows:<pre class="pre codeblock"><code>GRANT EXECUTE ON DBMS_APP_CONT TO <span class="variable" translate="no">user_name</span>;</code></pre></div>
                              </li>
                              <li>
                                 <p>Use the statistics for request boundaries and protection level to monitor the level of coverage. If you need more details, then use Application Continuity Check Coverage (with the ORAchk utility) to report the percentage of requests that are fully protected by Application Continuity, and the location of those requests that are not fully protected. Use this coverage check before deployment and after application changes. Developers and management will know how well protected an application release is from failures of the underlying infrastructure. If there is a problem, then it can be fixed before the application is released, or waived knowing the level of coverage.</p>
                              </li>
                           </ul>
                        </li>
                     </ol>
                     <p>If a connection pool or container does not use an Oracle connection pool, then many third-party Java applications fully support replacing the connection pool with the Universal Connection Pool. This includes IBM WebSphere and Apache Tomcat. Alternativelyfor Java applications, onlyan application can add its own request boundaries.</p>
                     <div class="infoboxnotealso" id="GUID-815F5DF2-6B6E-4E5B-922D-6FCAA4A0AD81__GUID-31BD3BFC-FB1E-4661-A9B8-DC495403EBCA">
                        <p class="notep1">See Also:</p>
                        <ul style="list-style-type: disc;">
                           <li>
                              <p><span><cite>Oracle Data Provider for .NET Developer's Guide for Microsoft Windows</cite></span> for more information about .NET applications development.
                              </p>
                           </li>
                           <li>
                              <p><span><cite>Oracle Database JDBC Developers Guide</cite></span> for more information about developing applications that include Application Continuity for Java
                              </p>
                           </li>
                        </ul>
                     </div>
                     <p>This section includes the following topics:</p>
                     <ul style="list-style-type: disc;">
                        <li>
                           <p><a href="ensuring-application-continuity.html#GUID-FBFC3B38-30A4-43D8-976E-0C4EDABDCFBD" title="If you are using Java, then you must use the oracle.jdbc.replay.OracleDataSourceImpl, oracle.jdbc.replay.OracleConnectionPoolDataSourceImpl, or oracle.jdbc.replay.driver.OracleXADataSourceImpl data source to obtain JDBC connections.">Configuring Oracle Application Continuity</a></p>
                        </li>
                        <li>
                           <p><a href="ensuring-application-continuity.html#GUID-27AE81B9-3ADB-4913-BAB3-BFD8C8244C91">Configuring Oracle Database for Application Continuity</a></p>
                        </li>
                        <li>
                           <p><a href="ensuring-application-continuity.html#GUID-0BEE4803-7485-437C-BDF7-C6C34F92D9B0" title="Some applications set an initial state for the connection before allowing applications to use the connection.">Establishing the Initial State Before Application Continuity Replays</a></p>
                        </li>
                        <li>
                           <p><a href="ensuring-application-continuity.html#GUID-2B3E23CC-A57D-4C62-B226-87E6C6A20874" title="By default, when Application Continuity initiates a failover, the driver attempts to recover the in-flight work at an instance where the service is available.">Delaying the Reconnection in Application Continuity</a></p>
                        </li>
                        <li>
                           <p><a href="ensuring-application-continuity.html#GUID-61B6FEC5-90F0-4BE2-AC3B-37ECA6009545" title="For planned maintenance, the recommended approach is to drain requests from Oracle connection pools in combination with Application Continuity for those requests that do not complete. Instances do need to be stopped to switch over to the patched software.">Using Application Continuity for Planned Maintenance</a></p>
                        </li>
                        <li>
                           <p><a href="ensuring-application-continuity.html#GUID-76D24524-AFCC-4BE0-8EFB-9C6C10F243E5" title="Sometimes Application Continuity is not in effect because a disabling call has been issued.">Running Without Application Continuity</a></p>
                        </li>
                        <li>
                           <p><a href="ensuring-application-continuity.html#GUID-696EB534-5B9C-49A9-902A-3F00169EC9AB" title="Replay occurs following a recoverable error but you can disable replay.">Disabling Replay in Application Continuity</a></p>
                        </li>
                        <li>
                           <p><a href="ensuring-application-continuity.html#GUID-9DD8DD6B-42E3-4248-ADA1-1763ABDA1302">Terminating or Disconnecting a Session Without Replay</a></p>
                        </li>
                     </ul>
                  </div>
                  <div>
                     <div class="relinfo">
                        <p><strong>Related Topics</strong></p>
                        <ul>
                           <li><a href="../atnms/orachk-and-exachk-command-line-options.html#ATNMS-GUID-87407F79-597D-453E-82DF-D870386829A9" target="_blank"><span><cite>Oracle Autonomous Health Framework User's Guide</cite></span></a></li>
                           <li><a href="ensuring-application-continuity.html#GUID-B2895452-68A1-45E5-A9A7-1888B7B10481" title="Applications achieve continuous availability when planned maintenance and unplanned outages of the database are transparent.">Transparent Application Continuity</a></li>
                           <li><a href="ensuring-application-continuity.html#GUID-E4A114A2-EA77-4037-A62A-BDFCF1E6D072">Mutable Functions and Application Continuity</a></li>
                           <li><a href="ensuring-application-continuity.html#GUID-D49C131A-5931-473E-A878-AF4B99E97F1D">Session State Consistency</a></li>
                           <li><a href="ensuring-application-continuity.html#GUID-FE576341-43A9-40EC-85EB-11A7CA9F5AE7">Auto Session State Consistency</a></li>
                           <li><a href="ensuring-application-continuity.html#GUID-696EB534-5B9C-49A9-902A-3F00169EC9AB">Disabling Replay in Application Continuity</a></li>
                           <li><a href="https://www.oracle.com/pls/topic/lookup?ctx=en/database/oracle/oracle-database/19/racad&amp;id=ODPNT-GUID-265124E6-8B8A-4348-8602-F7CEEEEE5AEF" target="_blank"><span><cite>Oracle Data Provider for .NET Developer's Guide for Microsoft Windows</cite></span></a></li>
                           <li><a href="../jjdbc/application-continuity.html#JJDBC-GUID-AAC6F9B7-9B4C-4098-B0D5-312BF9A13928" target="_blank"><span><cite>Oracle Database JDBC Developers Guide</cite></span></a></li>
                           <li><a href="../jjucp/intro.html#JJUCP-GUID-82ACD002-4C5F-4BF7-99FF-46A2A97DD35D" target="_blank"><span><cite>Oracle Universal Connection Pool Developers Guide</cite></span></a></li>
                           <li><a href="https://www.oracle.com/pls/topic/lookup?ctx=en/database/oracle/oracle-database/19/racad&amp;id=OEXUG-GUID-54ACE4B5-3EDD-452A-B758-8793980B1D20" target="_blank"><span><cite>Oracle ORAchk and EXAchk Users Guide</cite></span></a></li>
                        </ul>
                     </div>
                  </div><a id="ADFNS601"></a><div class="sect4"><a id="GUID-FBFC3B38-30A4-43D8-976E-0C4EDABDCFBD" name="GUID-FBFC3B38-30A4-43D8-976E-0C4EDABDCFBD"></a><h5 id="RACAD-GUID-FBFC3B38-30A4-43D8-976E-0C4EDABDCFBD" class="sect5">Configuring Oracle Application Continuity</h5>
                     <div>
                        <p>If you are using Java, then you must use the <code class="codeph">oracle.jdbc.replay.OracleDataSourceImpl</code>, <code class="codeph">oracle.jdbc.replay.OracleConnectionPoolDataSourceImpl</code>, or <code class="codeph">oracle.jdbc.replay.driver.OracleXADataSourceImpl</code> data source to obtain JDBC connections.
                        </p>
                        <p>These data sources support all the properties and configuration parameters of all the Oracle JDBC data sources, for example, the <code class="codeph">oracle.jdbc.pool.OracleDataSource</code>.
                        </p>
                        <p>For OCI based applications including SQL*Plus and ODP.NET, the OCI driver 12.2, and later, supports Application Continuity.</p>
                        <p>You must remember the following points while using the connection URL:</p>
                        <ul style="list-style-type: disc;">
                           <li>
                              <p>If the <code class="codeph">REMOTE_LISTENER</code> setting for the database does not match the addresses in the <code class="codeph">ADDRESS_LIST</code> at the client, then it does not connect, showing <code class="codeph">services cannot be found</code>. So, the <code class="codeph">REMOTE_LISTENER</code> setting for the database <span class="italic">must</span> match the addresses in the <code class="codeph">ADDRESS_LIST</code> at the client:
                              </p>
                              <ul style="list-style-type: disc;">
                                 <li>
                                    <p>If the connect string uses the SCAN Name, then <code class="codeph">REMOTE_LISTENER</code> must be set to the SCAN name.
                                    </p>
                                 </li>
                                 <li>
                                    <p>If the connect string uses an <code class="codeph">ADDRESS_LIST</code> of host VIPs, then <code class="codeph">REMOTE_LISTENER</code> must be set to an address list that includes all SCAN VIPs and all host VIPs
                                    </p>
                                 </li>
                              </ul>
                              <div class="infoboxnote" id="GUID-FBFC3B38-30A4-43D8-976E-0C4EDABDCFBD__GUID-ACE26216-269B-42BA-84CF-513190DBBB56">
                                 <p class="notep1">Note:</p>
                                 <p>Use SCAN for location independence, so that you do not need to reconfigure the client when you add or delete nodes, or when databases change to running on different nodes.</p>
                              </div>
                           </li>
                           <li>
                              <p>Set <code class="codeph">RETRY_COUNT</code>, <code class="codeph">RETRY_DELAY</code>, <code class="codeph">CONNECT_TIMEOUT</code>, and <code class="codeph">TRANSPORT_CONNECT_TIMEOUT</code> parameters in the connection string. These settings improve acquiring new connections at runtime, at replay, and during work drains for planned outages.
                              </p>
                              <p>The <code class="codeph">CONNECT_TIMEOUT</code> parameter is equivalent to the <code class="codeph">SQLNET.OUTBOUND_CONNECT_TIMEOUT</code> parameter in the <code class="codeph">sqlnet.ora</code> file and applies to the full connection. The <code class="codeph">TRANSPORT_CONNECT_TIMEOUT</code> parameter applies per address.
                              </p>
                              <p>Set <code class="codeph">CONNECT_TIMEOUT</code> to a high value to prevent an overabundance of log ins. Low values can result in <span class="italic">log in storms</span> to the application or server pool cancelling and retrying. Do not set <code class="codeph">(RETRY_COUNT+1)*RETRY_DELAY</code> or <code class="codeph">CONNECT_TIMEOUT</code> larger than your response time SLA. The application must either connect or receive an error within the response time SLA.
                              </p>
                              <p>These are general recommendations for configuring the connections for high availability. Do not use Easy Connect because this has no high-availability capabilities.</p>
                              <p>Following is an example of TNS entry. This is the required TNS format for ONS (the transport system for FAN) to be auto configured. Oracle recommends using FAN with Application Continuity to provide fast outage detection.</p><pre class="pre codeblock"><code>alias =(DESCRIPTION =
     (CONNECT_TIMEOUT=120) (RETRY_COUNT=20)(RETRY_DELAY=3) (TRANSPORT_CONNECT_TIMEOUT=3)
      (ADDRESS_LIST =
            (LOAD_BALANCE=on)
            ( ADDRESS = (PROTOCOL = TCP)(HOST=primary-scan)(PORT=1521)))
      (ADDRESS_LIST =
            (LOAD_BALANCE=on)
            ( ADDRESS = (PROTOCOL = TCP)(HOST=secondary-scan)(PORT=1521)))
      (CONNECT_DATA=(SERVICE_NAME = gold-cloud)))</code></pre></li>
                        </ul>
                     </div>
                     <div>
                        <div class="relinfo">
                           <p><strong>Related Topics</strong></p>
                           <ul>
                              <li><a href="../netrf/index.html" target="_blank"><span><cite>Oracle Database Net Services Reference</cite></span></a></li>
                              <li><a href="https://www.oracle.com/pls/topic/lookup?ctx=en/database/oracle/oracle-database/19/racad&amp;id=ODPNT-GUID-1308ACD5-025A-468E-834A-CAB59FE9BB59" target="_blank"><span><cite>Oracle Data Provider for .NET Developer's Guide for Microsoft Windows</cite></span></a></li>
                           </ul>
                        </div>
                     </div>
                  </div><a id="ADFNS602"></a><div class="sect4"><a id="GUID-27AE81B9-3ADB-4913-BAB3-BFD8C8244C91" name="GUID-27AE81B9-3ADB-4913-BAB3-BFD8C8244C91"></a><h5 id="RACAD-GUID-27AE81B9-3ADB-4913-BAB3-BFD8C8244C91" class="sect5">Configuring Oracle Database for Application Continuity</h5>
                     <div>
                        <p>Your Oracle Database configuration must include the following to use Application Continuity:</p>
                        <ul style="list-style-type: disc;">
                           <li>
                              <p>If you are using Oracle Real Application Clusters (Oracle RAC) or Oracle RAC One Node, Oracle Data Guard, or Oracle Active Data Guard, then ensure that FAN is configured with Oracle Notification Service (ONS) to communicate with Oracle Database 12<span class="italic">c</span> pools and drivers.
                              </p>
                           </li>
                           <li>
                              <p>Set the service attributes on the service for replay and load balancing. For example, set:</p>
                              <ul style="list-style-type: disc;">
                                 <li>
                                    <p><code class="codeph">FAILOVER_TYPE = AUTO | TRANSACTION</code>: Use <code class="codeph">FAILOVER_TYPE=AUTO</code> for Transparent Application Continuity or <code class="codeph">FAILOVER_TYPE=TRANSACTION</code> for manual Application Continuity. This attribute enables the replay functionality for the replay drivers and Application Continuity. Oracle drivers keep track of all replayable statements issued during a database session. If all of the statements are replayable, and any in-flight transactions did not commit or the session is in conversation, then Oracle replays the uncommitted work following a planned or unplanned database outage. This mode re-establishes transactional and non-transaction states automatically with no additional application steps.
                                    </p>
                                 </li>
                                 <li>
                                    <p><code class="codeph">REPLAY_INITIATION_TIMEOUT = <span class="variable" translate="no">n</span></code>: For setting the duration, in seconds, to allow replay to start (where the value of <code class="codeph"><span class="variable" translate="no">n</span></code> can be, for example, 60, 300, 900, or 1800, depending on your needs)
                                    </p>
                                 </li>
                                 <li>
                                    <p><code class="codeph">FAILOVER_RETRIES = 30</code>: For specifying the number of connection retries for each replay
                                    </p>
                                 </li>
                                 <li>
                                    <p><code class="codeph">FAILOVER_DELAY = 10</code>: For specifying the delay in seconds between connection retries
                                    </p>
                                 </li>
                                 <li>
                                    <p><code class="codeph">GOAL = SERVICE_TIME</code>: If you are using Oracle RAC or Oracle Global Data Services, then this is a recommended setting
                                    </p>
                                 </li>
                                 <li>
                                    <p><code class="codeph">CLB_GOAL = SHORT</code>: If you are using Oracle RAC or Oracle Global Data Services, then this is a recommended setting
                                    </p>
                                 </li>
                                 <li>
                                    <p><code class="codeph">COMMIT_OUTCOME = TRUE</code>: For using Transaction Guard
                                    </p>
                                 </li>
                                 <li>
                                    <p><code class="codeph">FAILOVER_RESTORE = AUTO | LEVEL1</code>: Use <code class="codeph">FAILOVER_RESTORE=AUTO</code> for Transparent Application Continuity and <code class="codeph">FAILOVER_RESTORE=LEVEL1</code> for manual Application Continuity. To automatically restore client states that are preset on the connection pool before replay beginsincluding AUTOCOMMIT state (for Java and SQL*Plus), NLS states, and TAGS (MODULE, ACTION, ECID, CLIENT_ID, CLIENT_INFO) states.
                                    </p>
                                 </li>
                              </ul>
                           </li>
                           <li>
                              <div class="p">Grant permission on the Application Continuity package, <code class="codeph">DBMS_APP_CONT</code>, to the database users that fail over using Application Continuity, as follows:<pre class="pre codeblock"><code>GRANT EXECUTE ON DBMS_APP_CONT TO <span class="variable" translate="no">user_name</span>;</code></pre></div>
                           </li>
                           <li>
                              <p><span class="italic">Do not use</span> the default database service corresponding to the <code class="codeph">DB_NAME</code> or <code class="codeph">DB_UNIQUE_NAME</code>. Also, <span class="italic">do not use</span> the default database service for high availability, because this service cannot be enabled or disabled, and cannot be relocated on Oracle RAC or switched over to Oracle Data Guard. This service is reserved for Oracle Enterprise Manager Cloud Control (Cloud Control) and for DBAs.
                              </p>
                           </li>
                        </ul>
                     </div>
                  </div><a id="ADFNS603"></a><div class="sect4"><a id="GUID-0BEE4803-7485-437C-BDF7-C6C34F92D9B0" name="GUID-0BEE4803-7485-437C-BDF7-C6C34F92D9B0"></a><h5 id="RACAD-GUID-0BEE4803-7485-437C-BDF7-C6C34F92D9B0" class="sect5">Establishing the Initial State Before Application Continuity Replays</h5>
                     <div>
                        <p>Some applications set an initial state for the connection before allowing applications to use the connection.</p>
                        <div class="p">Application Continuity must establish this initial state before replay starts. For these applications, <code class="codeph">FAILOVER_RESTORE</code> restores common states listed here. If the states that the application presets are not listed here, and the application needs initial states, then you must add an additional callback.
                           <div class="infoboxnotealso" id="GUID-0BEE4803-7485-437C-BDF7-C6C34F92D9B0__GUID-B1EAA6A4-98BC-458A-85ED-96FE703AF42C">
                              <p class="notep1">See Also:</p><span class="italic">Oracle Database Release Notes</span> for your platform because more parameters are restored in each release
                           </div>
                        </div>
                        <p>Examples of states that can be preset include:</p>
                        <ul style="list-style-type: disc;">
                           <li>
                              <p>PL/SQL package state</p>
                           </li>
                           <li>
                              <p>NLS Setting</p>
                           </li>
                           <li>
                              <p>Optimizer setting</p>
                           </li>
                        </ul>
                        <p>During a request, Application Continuity reestablishes the entire state for the request. This pre-requisite is for the initial state before Application Continuity starts replaying.</p>
                        <p>A callback is not required if <code class="codeph">FAILOVER_RESTORE</code> restores all required states, which is the case for most applications.
                        </p>
                        <p>For applications that set state only at the beginning of a request, or for stateful applications that gain performance benefits from using connections with a preset state, choose one of these options:</p>
                        <ul style="list-style-type: disc;">
                           <li>
                              <p><a href="ensuring-application-continuity.html#GUID-751D4D16-BE2C-44DC-9A7B-20348E4EC24B" title="Setting FAILOVER_RESTORE to LEVEL1 (for manual Application Continuity) or AUTO (for Transparent Application Continuity) automatically restores common state initial settings before replaying the request.">FAILOVER_RESTORE = LEVEL1 or AUTO</a> 
                              </p>
                           </li>
                           <li>
                              <p><a href="ensuring-application-continuity.html#GUID-D0D41855-712D-47DC-B282-07CD8E6B4B5D">FAILOVER_RESTORE = NONE and No Callback</a></p>
                           </li>
                           <li>
                              <p><a href="ensuring-application-continuity.html#GUID-746A88D5-2A2B-4AF9-BE91-229DE36378FB">Connection Labeling</a></p>
                           </li>
                           <li>
                              <p><a href="ensuring-application-continuity.html#GUID-B54DA2D3-8B8C-45EB-9CC3-B9D44B448FC7">Connection Initialization Callback</a></p>
                           </li>
                        </ul>
                     </div>
                     <div class="sect5"><a id="GUID-751D4D16-BE2C-44DC-9A7B-20348E4EC24B" name="GUID-751D4D16-BE2C-44DC-9A7B-20348E4EC24B"></a><h6 id="RACAD-GUID-751D4D16-BE2C-44DC-9A7B-20348E4EC24B" class="sect6">FAILOVER_RESTORE = LEVEL1 or AUTO</h6>
                        <div>
                           <p>Setting <code class="codeph">FAILOVER_RESTORE</code> to <code class="codeph">LEVEL1</code> (for manual Application Continuity) or <code class="codeph">AUTO</code> (for Transparent Application Continuity) automatically restores common state initial settings before replaying the request.
                           </p>
                           <p>Oracle recommends setting <code class="codeph">FAILOVER_RESTORE</code> to <code class="codeph">LEVEL1</code> or <code class="codeph">AUTO</code> for all applications.
                           </p>
                           <p>The states restored include the following:</p>
                           <ul style="list-style-type: disc;">
                              <li>
                                 <p>NLS_CALENDAR</p>
                              </li>
                              <li>
                                 <p>NLS_CURRENCY </p>
                              </li>
                              <li>
                                 <p> NLS_DATE_FORMAT</p>
                              </li>
                              <li>
                                 <p> NLS_DATE_LANGUAGE</p>
                              </li>
                              <li>
                                 <p> NLS_DUAL_CURRENCY</p>
                              </li>
                              <li>
                                 <p> NLS_ISO_CURRENCY</p>
                              </li>
                              <li>
                                 <p> NLS_LANGUAGE</p>
                              </li>
                              <li>
                                 <p>NLS_LENGTH_SEMANTICS</p>
                              </li>
                              <li>
                                 <p>NLS_NCHAR_CONV_EXCP </p>
                              </li>
                              <li>
                                 <p>NLS_NUMERIC_CHARACTER</p>
                              </li>
                              <li>
                                 <p> NLS_SORT</p>
                              </li>
                              <li>
                                 <p>NLS_TERRITORY </p>
                              </li>
                              <li>
                                 <p>NLS_TIME_FORMAT </p>
                              </li>
                              <li>
                                 <p>NLS_TIME_TZ_FORMAT</p>
                              </li>
                              <li>
                                 <p>TIME_ZONE</p>
                              </li>
                              <li>
                                 <p>NLS_TIMESTAMP_FORMAT</p>
                              </li>
                              <li>
                                 <p>NLS_TIMESTAMP_TZ_FORMAT</p>
                              </li>
                              <li>
                                 <p>CURRENT_SCHEMA</p>
                              </li>
                              <li>
                                 <p>MODULE</p>
                              </li>
                              <li>
                                 <p>ACTION </p>
                              </li>
                              <li>
                                 <p> CLIENT_ID</p>
                              </li>
                              <li>
                                 <p>AUTOCOMMIT states (for Java and SQL*Plus)</p>
                              </li>
                              <li>
                                 <p>CONTAINER (PDB) and SERVICE</p>
                              </li>
                              <li>
                                 <p>ROLES (excludes secure roles, which continue to require a call back)</p>
                              </li>
                              <li>
                                 <p>ROW_ARCHIVAL</p>
                              </li>
                              <li>
                                 <p>EDITION</p>
                              </li>
                              <li>
                                 <p>ERROR_ON_OVERLAP_TIME</p>
                              </li>
                              <li>
                                 <p>SQL_TRANSLATION_PROFILE</p>
                              </li>
                              <li>
                                 <p>CLIENT_INFO. (JDBC)</p>
                              </li>
                           </ul>
                           <p>The following are not supported by the THIN driver, so are excluded from the auto-restoration option: </p>
                           <ul style="list-style-type: disc;">
                              <li>
                                 <p>NLS_COMP</p>
                              </li>
                              <li>
                                 <p>CALL_COLLECT_TIME</p>
                              </li>
                              <li>
                                 <p>CLIENT_INFO </p>
                              </li>
                           </ul>
                        </div>
                     </div><a id="ADFNS1088"></a><div class="sect5"><a id="GUID-D0D41855-712D-47DC-B282-07CD8E6B4B5D" name="GUID-D0D41855-712D-47DC-B282-07CD8E6B4B5D"></a><h6 id="RACAD-GUID-D0D41855-712D-47DC-B282-07CD8E6B4B5D" class="sect6">FAILOVER_RESTORE = NONE and No Callback</h6>
                        <div>
                           <p>In this scenario, which is applicable to databases and clients prior to Oracle Database 18c, the application does not assume any state when borrowing a connection from a pool, or uses UCP or WebLogic labels to reestablish the initial state.</p>
                           <p>Beginning with Oracle Database 18c databases and clients, or later, Oracle recommends setting <code class="codeph">FAILOVER_RESTORE</code> to <code class="codeph">LEVEL1</code> or <code class="codeph">AUTO</code> for all applications.
                           </p>
                        </div>
                     </div><a id="ADFNS1187"></a><div class="sect5"><a id="GUID-746A88D5-2A2B-4AF9-BE91-229DE36378FB" name="GUID-746A88D5-2A2B-4AF9-BE91-229DE36378FB"></a><h6 id="RACAD-GUID-746A88D5-2A2B-4AF9-BE91-229DE36378FB" class="sect6">Connection Labeling</h6>
                        <div>
                           <p>Oracle recommends using Connection Labeling, a generic pool feature, as a best practice. When Connection Labeling is present, Application Continuity uses it. Since the Connection Labeling is recreating the state, <code class="codeph">FAILOVER_RESTORE</code> can be set to <code class="codeph">NONE</code>.
                           </p>
                           <p>This scenario is applicable to Universal Connection Pool (UCP) and Oracle WebLogic server. The application can be modified to take advantage of the preset state on connections. Connection Labeling APIs determine how well a connection matches, and use a callback to populate the gap when a connection is borrowed.</p>
                        </div>
                        <div>
                           <div class="relinfo">
                              <p><strong>Related Topics</strong></p>
                              <ul>
                                 <li><a href="../jjucp/application-continuity-using-ucp.html#JJUCP-GUID-83526888-0AA4-4112-B962-4057D64F192B" target="_blank"><span><cite>Oracle Universal Connection Pool Developers Guide</cite></span></a></li>
                              </ul>
                           </div>
                        </div>
                     </div><a id="ADFNS1289"></a><div class="sect5"><a id="GUID-B54DA2D3-8B8C-45EB-9CC3-B9D44B448FC7" name="GUID-B54DA2D3-8B8C-45EB-9CC3-B9D44B448FC7"></a><h6 id="RACAD-GUID-B54DA2D3-8B8C-45EB-9CC3-B9D44B448FC7" class="sect6">Connection Initialization Callback</h6>
                        <div>
                           <p>In this scenario, the replaying driver (JDBC or OCI) uses an application callback to set the initial state of the session during runtime and replay. The JDBC replay driver provides a connection initialization callback interface and methods to register and unregister connection initialization callbacks in the <code class="codeph">oracle.jdbc.replay.OracleDataSource</code> interface.&nbsp;For OCI and ODP.NET, register the TAF callback.
                           </p>
                           <p>When registered, the initialization callback is executed every time a connection is borrowed from the pool and at each successful reconnection following a recoverable error. (This is true for the JDBC/UCP initialization callback and should be the same for TAF.) Using the same callback during both runtime and replay ensures that the same initialization is established at replay, as it was when the session was first established. An application is responsible for ensuring that the initialization actions are the same as that on the original connection before failover. If the callback invocation fails, then replay is disabled on that connection. Use the connection initialization callback only when the application has not implemented UCP and WebLogic Connection Labeling and the state cannot be restored automatically by setting either <code class="codeph">FAILOVER_RESTORE=AUTO</code> for Transparent Application Continuity or <code class="codeph">FAILOVER_RESTORE=LEVEL1</code> for manual Application Continuity.
                           </p>
                        </div>
                     </div>
                  </div><a id="ADFNS1290"></a><div class="sect4"><a id="GUID-2B3E23CC-A57D-4C62-B226-87E6C6A20874" name="GUID-2B3E23CC-A57D-4C62-B226-87E6C6A20874"></a><h5 id="RACAD-GUID-2B3E23CC-A57D-4C62-B226-87E6C6A20874" class="sect5">Delaying the Reconnection in Application Continuity</h5>
                     <div>
                        <p>By default, when Application Continuity initiates a failover, the driver attempts to recover the in-flight work at an instance where the service is available.</p>
                        <p>For recovering the work, the driver must establish a good connection with the instance. This reconnection can take some time if the database or the instance must be restarted before the service is relocated and published. So, the failover must be delayed until the service is available from another instance or database.</p>
                        <p>You must use the <code class="codeph">FAILOVER_RETRIES</code> and <code class="codeph">FAILOVER_DELAY</code> parameters to manage connecting and reconnecting. These parameters can work well in conjunction with a planned outage, for example, an outage that may make a service unavailable for several minutes. While setting the <code class="codeph">FAILOVER_DELAY</code> and <code class="codeph">FAILOVER_RETRIES</code> parameters, check the value of the <code class="codeph">REPLAY_INITIAITION_TIMEOUT</code> parameter first. The default value for this parameter is 900 seconds. A high value for the <code class="codeph">FAILOVER_DELAY</code> parameter can cause replay to be canceled.
                        </p>
                        <div class="tblformal" id="GUID-2B3E23CC-A57D-4C62-B226-87E6C6A20874__GUID-069AC3CE-3677-4259-B8CA-147CEAD00FAD">
                           <table cellpadding="4" cellspacing="0" class="Formal" title="" summary="Parameters for delaying failover" frame="hsides" border="1" rules="rows">
                              <thead>
                                 <tr align="left" valign="top">
                                    <th align="left" valign="bottom" width="33%" id="d23610e7372">Parameter Name</th>
                                    <th align="left" valign="bottom" width="33%" id="d23610e7375">Possible Value</th>
                                    <th align="left" valign="bottom" width="33%" id="d23610e7378">Default Value</th>
                                 </tr>
                              </thead>
                              <tbody>
                                 <tr align="left" valign="top">
                                    <td align="left" valign="top" width="33%" id="d23610e7383" headers="d23610e7372 ">
                                       <p><code class="codeph">FAILOVER_RETRIES</code></p>
                                    </td>
                                    <td align="left" valign="top" width="33%" headers="d23610e7383 d23610e7375 ">
                                       <p>Positive integer zero or above</p>
                                    </td>
                                    <td align="left" valign="top" width="33%" headers="d23610e7383 d23610e7378 ">
                                       <p>30</p>
                                    </td>
                                 </tr>
                                 <tr align="left" valign="top">
                                    <td align="left" valign="top" width="33%" id="d23610e7394" headers="d23610e7372 ">
                                       <p><code class="codeph">FAILOVER_DELAY</code></p>
                                    </td>
                                    <td align="left" valign="top" width="33%" headers="d23610e7394 d23610e7375 ">
                                       <p>Time in seconds</p>
                                    </td>
                                    <td align="left" valign="top" width="33%" headers="d23610e7394 d23610e7378 ">
                                       <p>10</p>
                                    </td>
                                 </tr>
                              </tbody>
                           </table>
                        </div>
                        <!-- class="inftblhruleinformal" -->
                        <p>The following examples show various failover scenarios:</p>
                        <ul style="list-style-type: disc;">
                           <li>
                              <p><a href="ensuring-application-continuity.html#GUID-9DAE9270-A5BC-4A0F-9A55-D9DCFC0A9BF5" title="You can create services on Oracle RAC that utilize Transparent Application Continuity or manual Application Continuity.">Creating Services on Oracle RAC with Application Continuity</a></p>
                           </li>
                           <li>
                              <p><a href="ensuring-application-continuity.html#GUID-1EAB6E4B-24DE-4D90-ABF8-682D1712E57F" title="If you are using a single-instance database, then use the DBMS_SERVICE package to modify services.">Modifying Services on Single-instance Databases to use Application Continuity</a></p>
                           </li>
                        </ul>
                     </div><a id="ADFNS1344"></a><a id="ADFNS1395"></a><a id="ADFNS1291"></a><div class="sect5"><a id="GUID-9DAE9270-A5BC-4A0F-9A55-D9DCFC0A9BF5" name="GUID-9DAE9270-A5BC-4A0F-9A55-D9DCFC0A9BF5"></a><h6 id="RACAD-GUID-9DAE9270-A5BC-4A0F-9A55-D9DCFC0A9BF5" class="sect6">Creating Services on Oracle RAC with Application Continuity</h6>
                        <div>
                           <p>You can create services on Oracle RAC that utilize Transparent Application Continuity or manual Application Continuity.</p>
                           <p>You can create services that use Transparent Application Continuity, as follows:</p>
                           <div class="p">For policy-managed databases:<pre class="pre codeblock"><code>$ srvctl add service -db codedb -service GOLD -serverpool ora.Srvpool -clbgoal SHORT
  -rlbgoal SERVICE_TIME -failover_restore AUTO -failoverretry 30 -failoverdelay 10
  -commit_outcome TRUE -failovertype AUTO -replay_init_time 1800 -retention 86400
  -notification TRUE</code></pre></div>
                           <div class="p">For administrator-managed databases:<pre class="pre codeblock"><code>$ srvctl add service -db codedb -service GOLD -preferred serv1 -available serv2 -clbgoal SHORT
  -rlbgoal SERVICE_TIME -failover_restore AUTO -failoverretry 30 -failoverdelay 10
  -commit_outcome TRUE -failovertype AUTO -replay_init_time 1800 -retention 86400
  -notification TRUE</code></pre></div>
                           <p>You can create services that use manual Application Continuity, as follows::</p>
                           <p>For policy-managed databases:</p><pre class="pre codeblock"><code>$ srvctl add service -db codedb -service GOLD -serverpool ora.Srvpool -clbgoal SHORT
  -rlbgoal SERVICE_TIME -failover_restore LEVEL1 -failoverretry 30 -failoverdelay 10
  -commit_outcome TRUE -failovertype TRANSACTION -replay_init_time 1800 -retention 86400
  -notification TRUE</code></pre><p>For administrator-managed databases:</p><pre class="pre codeblock"><code>$ srvctl add service -db codedb -service GOLD -preferred serv1 -available serv2  -clbgoal SHORT 
  -rlbgoal SERVICE_TIME -failover_restore LEVEL1 -failoverretry 30 -failoverdelay 10 -commit_outcome TRUE
  -failovertype TRANSACTION -replay_init_time 1800 -retention 86400 -notification TRUE</code></pre></div>
                     </div><a id="ADFNS1396"></a><div class="sect5"><a id="GUID-1EAB6E4B-24DE-4D90-ABF8-682D1712E57F" name="GUID-1EAB6E4B-24DE-4D90-ABF8-682D1712E57F"></a><h6 id="RACAD-GUID-1EAB6E4B-24DE-4D90-ABF8-682D1712E57F" class="sect6">Modifying Services on Single-instance Databases to use Application Continuity</h6>
                        <div>
                           <p>If you are using a single-instance database, then use the <code class="codeph">DBMS_SERVICE</code> package to modify services.
                           </p>
                           <div class="p">For manual Application Continuity:<pre class="pre codeblock"><code>DECLARE
params dbms_service.svc_parameter_array;
BEGIN
params('FAILOVER_TYPE'):='TRANSACTION';
params('REPLAY_INITIATION_TIMEOUT'):=1800;
params('RETENTION_TIMEOUT'):=86400;
params('FAILOVER_DELAY'):=10;
params('FAILOVER_RETRIES'):=30;
params('FAILOVER_RESTORE'):='LEVEL1';
params('commit_outcome'):='true';
params('aq_ha_notifications'):='true';
dbms_service.modify_service('[<span class="variable" translate="no">your service</span>]',params);
END;
/</code></pre></div>
                           <div class="p">For Transparent Application Continuity:<pre class="pre codeblock"><code>DECLARE
params dbms_service.svc_parameter_array;
BEGIN
params('FAILOVER_TYPE'):='AUTO';
params('REPLAY_INITIATION_TIMEOUT'):=1800;
params('RETENTION_TIMEOUT'):=86400;
params('FAILOVER_DELAY'):=10;
params('FAILOVER_RETRIES'):=30;
params('FAILOVER_RESTORE'):='AUTO';
params('commit_outcome'):='true';
params('aq_ha_notifications'):='true';
dbms_service.modify_service('[your service]',params);
END;
/</code></pre></div>
                        </div>
                     </div>
                  </div><a id="ADFNS1399"></a><div class="sect4"><a id="GUID-61B6FEC5-90F0-4BE2-AC3B-37ECA6009545" name="GUID-61B6FEC5-90F0-4BE2-AC3B-37ECA6009545"></a><h5 id="RACAD-GUID-61B6FEC5-90F0-4BE2-AC3B-37ECA6009545" class="sect5">Using Application Continuity for Planned Maintenance</h5>
                     <div>
                        <p>For planned maintenance, the recommended approach is to drain requests from Oracle connection pools in combination with Application Continuity for those requests that do not complete. Instances do need to be stopped to switch over to the patched software.</p>
                        <p>This has the least impact when there is minimal recovery to complete.</p>
                        <p>To use Application Continuity for planned maintenance:</p>
                        <ol>
                           <li>
                              <p>Use any FAN-aware pool, such as OCI, UCP, WebLogic Server, or ODP.NET Managed and Unmanaged Drivers.</p>
                              <div class="p">The FAN planned event drains at request boundaries.
                                 <div class="infoboxnote" id="GUID-61B6FEC5-90F0-4BE2-AC3B-37ECA6009545__GUID-D73D9638-50CC-49E0-95B0-0249F47813D3">
                                    <p class="notep1">Note:</p>ODP.NET Managed Driver does not support Application Continuity.
                                 </div>
                              </div>
                           </li>
                           <li>
                              <p>Use the <code class="codeph">srvctl relocate service</code> command to relocate the service from the instance without disrupting the sessions or, for a uniform service, use the <code class="codeph">srvctl stop service</code> command on the instance (do not use the <code class="codeph">-force</code> parameter).
                              </p>
                              <p>The FAN planned event clears the idle sessions immediately and marks the active sessions to be released at check-in (end of request). This drains the sessions from the instance without disrupting work.</p>
                           </li>
                           <li>
                              <p>If not all sessions have checked in and the time to stop the instance has been reached, then stop the instance (abort).</p>
                              <p>For Application Continuity-enabled pools (UCP, WebLogic, Tuxedo, ODP.NET, and OCI), and any Java pool that adds <code class="codeph">beginRequest</code>/<code class="codeph">endRequest</code> , Application Continuity attempts to recover those remaining sessions.
                              </p>
                           </li>
                           <li>
                              <p>Restart the instance and service.</p>
                              <p>Runtime load balancing, when enabled, balances the sessions back to the restored instance at the next request boundaries.</p>
                           </li>
                        </ol>
                     </div>
                  </div><a id="ADFNS357"></a><div class="sect4"><a id="GUID-76D24524-AFCC-4BE0-8EFB-9C6C10F243E5" name="GUID-76D24524-AFCC-4BE0-8EFB-9C6C10F243E5"></a><h5 id="RACAD-GUID-76D24524-AFCC-4BE0-8EFB-9C6C10F243E5" class="sect5">Running Without Application Continuity</h5>
                     <div>
                        <p>Sometimes Application Continuity is not in effect because a disabling call has been issued.</p>
                        <p>Application Continuity is not in effect when it has not been started or when it has been disabled. If it has been disabled, it remains so through to the <code class="codeph">endRequest</code> call.
                        </p>
                        <p>Application Continuity is not started when the service property <code class="codeph">FAILOVER_TYPE</code> does <span class="italic">not</span> have the value set to <code class="codeph">TRANSACTION</code> or <code class="codeph">AUTO</code>. For planned maintenance, set the <code class="codeph">FAILOVER_TYPE</code> value to <code class="codeph">TRANSACTION</code> or <code class="codeph">AUTO</code>, beforehand; the setting applies to new connections, and existing connections retain their original service value.
                        </p>
                        <p>Application Continuity is disabled for the current request when any of the following occurs:</p>
                        <ul style="list-style-type: disc;">
                           <li>
                              <p>The application runs a statement that is restricted for Application Continuity (for example, <code class="codeph">ALTER SYSTEM</code>).
                              </p>
                           </li>
                           <li>
                              <p>Application Continuity is explicitly disabled using <code class="codeph">disableReplay</code>.
                              </p>
                           </li>
                           <li>
                              <p>A <code class="codeph">COMMIT</code> statement is issued when the service parameter <code class="codeph">session_state_consistency</code> is set to <code class="codeph">Dynamic</code> (the default, when not using Transparent Application Continuity).
                              </p>
                           </li>
                           <li>
                              <p>An <code class="codeph">endRequest</code> statement is issued until the next <code class="codeph">beginRequest</code> is issued.
                              </p>
                           </li>
                           <li>
                              <p>The session is terminated or disconnected and the <code class="codeph">NOREPLAY</code> keyword is specified.
                              </p>
                           </li>
                        </ul>
                     </div>
                     <div>
                        <div class="relinfo">
                           <p><strong>Related Topics</strong></p>
                           <ul>
                              <li><a href="ensuring-application-continuity.html#GUID-B2895452-68A1-45E5-A9A7-1888B7B10481">Transparent Application Continuity</a></li>
                              <li><a href="ensuring-application-continuity.html#GUID-696EB534-5B9C-49A9-902A-3F00169EC9AB">Disabling Replay in Application Continuity</a></li>
                              <li><a href="ensuring-application-continuity.html#GUID-9DD8DD6B-42E3-4248-ADA1-1763ABDA1302">Terminating or Disconnecting a Session Without Replay</a></li>
                           </ul>
                        </div>
                     </div>
                  </div><a id="ADFNS1400"></a><div class="sect4"><a id="GUID-696EB534-5B9C-49A9-902A-3F00169EC9AB" name="GUID-696EB534-5B9C-49A9-902A-3F00169EC9AB"></a><h5 id="RACAD-GUID-696EB534-5B9C-49A9-902A-3F00169EC9AB" class="sect5">Disabling Replay in Application Continuity</h5>
                     <div>
                        <p>Replay occurs following a recoverable error but you can disable replay.</p>
                        <p>If an application has requests that the application does not want repeated, then the application can take a connection to a service that does not have Application Continuity enabled, or can explicitly call an API to disable replay for those requests. If you use Transparent Application Continuity, then side effects are detected and disabled automatically. You do not need to understand the application or to disable requests with side effects.</p>
                        <p>When using manual Application Continuity all calls are replayed. If an application uses <code class="codeph">UTL_SMTP</code>, for example, and does not want messages repeated, then the application could use a connection to a different service, or use the <code class="codeph">disableReplay</code> API on Java, or <code class="codeph">OCIRequestDisableReplay</code> API for OCI. All other requests continue to be replayed.
                        </p>
                        <p>For applications with external actions (for example, autonomous transactions or using <code class="codeph">UTL_HTTP</code> to issue an SOA call), Application Continuity remains transparent if the application's correctness is preserved when these external actions are replayed after a failure.
                        </p>
                        <p>The following rules are generic. They apply to all applications that replay work, including Application Continuity, and TAF (release 12.2 and after).</p>
                        <ul style="list-style-type: disc;">
                           <li>
                              <p><a href="ensuring-application-continuity.html#GUID-E77EF392-91A1-46D6-A710-FE28175410AA">Application Calls Autonomous Transactions, External PL/SQL, or Java Actions that Should Not Be Repeated</a></p>
                           </li>
                           <li>
                              <p><a href="ensuring-application-continuity.html#GUID-A2918D8A-4FF5-49D9-9A22-4A293CFF53A7">Application Synchronizes Independent Sessions</a></p>
                           </li>
                           <li>
                              <p><a href="ensuring-application-continuity.html#GUID-50D0AD4B-7918-4B12-AEFC-5EF5D4681A52">Application Uses Time at the Middle Tier in the Execution Logic</a></p>
                           </li>
                           <li>
                              <p><a href="ensuring-application-continuity.html#GUID-1FA03CA0-C6F1-4047-B038-C40799EDCDC3">Application Assumes that ROWIds Do Not Change</a></p>
                           </li>
                           <li>
                              <p><a href="ensuring-application-continuity.html#GUID-84B97C49-F683-4053-9C56-48FC1B69BE4F">Application Assumes that Location Values Do Not Change</a></p>
                           </li>
                        </ul>
                     </div>
                     <div>
                        <div class="relinfo">
                           <p><strong>Related Topics</strong></p>
                           <ul>
                              <li><a href="ensuring-application-continuity.html#GUID-B2895452-68A1-45E5-A9A7-1888B7B10481">Transparent Application Continuity</a></li>
                              <li><a href="ensuring-application-continuity.html#GUID-A250F3F8-D681-4F44-8969-7A8434E065DD">Potential Side Effects of Application Continuity</a></li>
                              <li><a href="ensuring-application-continuity.html#GUID-2400FAAD-0BB2-48AF-B1F6-358EBA724028">Restrictions and Other Considerations for Application Continuity</a></li>
                           </ul>
                        </div>
                     </div><a id="ADFNS1414"></a><div class="sect5"><a id="GUID-E77EF392-91A1-46D6-A710-FE28175410AA" name="GUID-E77EF392-91A1-46D6-A710-FE28175410AA"></a><h6 id="RACAD-GUID-E77EF392-91A1-46D6-A710-FE28175410AA" class="sect6">Application Calls Autonomous Transactions, External PL/SQL, or Java Actions that Should Not Be Repeated </h6>
                        <div>
                           <p>Autonomous transactions, external PL/SQL calls, and Java callouts can have side effects that are separate from the main transaction, and these side effects are replayed unless you specify otherwise.</p>
                           <p>Examples of side effects separate from the main transaction include writing to an external table, sending email, forking sessions out of PL/SQL (including calls to UTL_HTTP, UTL_URL, UTL_FILE, UTL_FILE_TRANSFER, UTL_SMPT, UTL_TCP, UTL_MAIL, DBMS_PIPE, or DBMS_ALERT) or Java (including executing a shell script in the form <span class="italic">Process proc = rt.exec(command);</span>), transferring files, and accessing external URLs. Actions such as these leave persistent side effects. PL/SQL messaging and Java callouts can leave persistent results behind. For example, if a user walks away part way through some work without committing and the session times out or the user issues Ctrl+C, the foreground or a component fails; the main transaction rolls back while the side effects may have been applied. (For more information about side effects, see <a href="ensuring-application-continuity.html#GUID-A250F3F8-D681-4F44-8969-7A8434E065DD" title="When you use Application Continuity with FAILOVER_TYPE set to TRANSACTION, statements that leave side effects are replayed.">Potential Side Effects of Application Continuity</a>.)
                           </p>
                           <p>Application developers decide whether to allow replay for external actions. Examples include using <code class="codeph">UTL_HTTP</code> to issue an SOA call, or <code class="codeph">UTL_SMTP</code> to send a message, or <code class="codeph">UTL_URL</code> to access a website. If such external actions must not be replayed, use a connection without AC, or use one of the disable Replay APIs.
                           </p>
                        </div>
                     </div><a id="ADFNS1415"></a><div class="sect5"><a id="GUID-A2918D8A-4FF5-49D9-9A22-4A293CFF53A7" name="GUID-A2918D8A-4FF5-49D9-9A22-4A293CFF53A7"></a><h6 id="RACAD-GUID-A2918D8A-4FF5-49D9-9A22-4A293CFF53A7" class="sect6">Application Synchronizes Independent Sessions</h6>
                        <div>
                           <p>You must not configure an application for replay if the application synchronizes independent sessions using volatile entities that are held until <code class="codeph">COMMIT</code>, <code class="codeph">ROLLBACK</code>, or session loss. For example, the application might synchronize multiple sessions connected to several data sources that are otherwise inter-dependent using resources such as a database lock. This synchronization may be acceptable if the application is only serializing these sessions and understands that any session may fail. However, if the application assumes that a lock or any other volatile resource held by one data source implies exclusive access to data on the same or a separate data source from other connections, then this assumption may be invalidated when replaying.
                           </p>
                           <p>During replay, the client driver is not aware that the sessions are dependent on one session holding a lock or other volatile resource. You can also use pipes, buffered queues, stored procedures taking a resource (such as a semaphore, device, or socket) to implement the synchronization that are lost by failures.</p>
                        </div>
                     </div><a id="ADFNS1416"></a><div class="sect5"><a id="GUID-50D0AD4B-7918-4B12-AEFC-5EF5D4681A52" name="GUID-50D0AD4B-7918-4B12-AEFC-5EF5D4681A52"></a><h6 id="RACAD-GUID-50D0AD4B-7918-4B12-AEFC-5EF5D4681A52" class="sect6">Application Uses Time at the Middle Tier in the Execution Logic</h6>
                        <div>
                           <p>You must not configure an application for replay if the application uses the wall clock at the middle tier as part of the execution logic. The client driver does not repeat the middle-tier time logic, but uses the database calls that execute as part of this logic. For example, an application using middle-tier time might assume that a statement executed at Time T1 is not reexecuted at Time T2, unless the application explicitly does so.</p>
                        </div>
                     </div><a id="ADFNS1417"></a><div class="sect5"><a id="GUID-1FA03CA0-C6F1-4047-B038-C40799EDCDC3" name="GUID-1FA03CA0-C6F1-4047-B038-C40799EDCDC3"></a><h6 id="RACAD-GUID-1FA03CA0-C6F1-4047-B038-C40799EDCDC3" class="sect6">Application Assumes that ROWIds Do Not Change</h6>
                        <div>
                           <p>If an application caches ROWIDs, then access to these ROWIDs might be invalidated due to database changes. Although a ROWID uniquely identifies a row in a table, a ROWID might change its value in the following situations:</p>
                           <ul style="list-style-type: disc;">
                              <li>
                                 <p>The underlying table is reorganized.</p>
                              </li>
                              <li>
                                 <p>An index is created on the table.</p>
                              </li>
                              <li>
                                 <p>The underlying table is partitioned.</p>
                              </li>
                              <li>
                                 <p>The underlying table is migrated.</p>
                              </li>
                              <li>
                                 <p>The underlying table is exported and imported using EXP/IMP/DUL.</p>
                              </li>
                              <li>
                                 <p>The underlying table is rebuilt using Golden Gate or Logical Standby or other replication technology.</p>
                              </li>
                              <li>
                                 <p>The database of the underlying table is flashed back or restored.</p>
                              </li>
                           </ul>
                           <p>Oracle does not recommend, in general, that an application store ROWIDs for later use because the corresponding row might either not exist or contain completely different data. Note that ROWIDs do not prevent using Application Continuity. Replays can be rejected.</p>
                        </div>
                     </div><a id="ADFNS1419"></a><a id="ADFNS1418"></a><div class="sect5"><a id="GUID-84B97C49-F683-4053-9C56-48FC1B69BE4F" name="GUID-84B97C49-F683-4053-9C56-48FC1B69BE4F"></a><h6 id="RACAD-GUID-84B97C49-F683-4053-9C56-48FC1B69BE4F" class="sect6">Application Assumes that Location Values Do Not Change</h6>
                        <div>
                           <p><code class="codeph">SYSCONTEXT</code> options comprise a location-independent set such as National Language Support (NLS) settings, <code class="codeph">ISDBA</code>, <code class="codeph">CLIENT_IDENTIFIER</code>, <code class="codeph">MODULE</code>, and <code class="codeph">ACTION</code>, and a location-dependent set that uses physical locators. Typically, an application does not use the physical identifiers, except in testing environments. If physical locators are used in mainline code, then the replay finds the mismatch and rejects it. However, it is acceptable to use physical locators between requests (before <code class="codeph">beginRequest</code>) or in callbacks. A common issue is for QA to modify test applications to select <code class="codeph">V$INSTANCE</code>. As <code class="codeph">V$INSTANCE</code> can change, only put this check in the callback or select the instance locally at the client and not from the database.
                           </p>
                           <div class="section">
                              <p class="subhead3" id="GUID-84B97C49-F683-4053-9C56-48FC1B69BE4F__GUID-96478102-7E44-4BD6-9B2E-9CB78DAB15AB">Example</p>
                           </div>
                           <!-- class="section" --><pre class="oac_no_warn" dir="ltr">select 
    sys_context('USERENV','DB_NAME') 
    ,sys_context('USERENV','HOST') 
    ,sys_context('USERENV','INSTANCE') 
    ,sys_context('USERENV','IP_ADDRESS') 
    ,sys_context('USERENV','ISDBA')  
    ,sys_context('USERENV','SESSIONID') 
    ,sys_context('USERENV','TERMINAL') 
    ,sys_context('USERENV','SID') 
from dual;</pre></div>
                     </div>
                  </div><a id="ADFNS1426"></a><div class="sect4"><a id="GUID-9DD8DD6B-42E3-4248-ADA1-1763ABDA1302" name="GUID-9DD8DD6B-42E3-4248-ADA1-1763ABDA1302"></a><h5 id="RACAD-GUID-9DD8DD6B-42E3-4248-ADA1-1763ABDA1302" class="sect5">Terminating or Disconnecting a Session Without Replay</h5>
                     <div>
                        <p>If Application Continuity is configured and if a DBA terminates or disconnects a session by using the <code class="codeph">ALTER SYSTEM KILL SESSION</code> or <code class="codeph">ALTER SYSTEM DISCONNECT SESSION</code> statement, then Application Continuity, by default attempts, to recover the session. However, if you <span class="italic">do not</span> want the session to be replayed, then use the <code class="codeph">NOREPLAY</code> keyword, as follows:
                        </p><pre class="pre codeblock"><code>
alter system kill session '<span class="variable" translate="no">sid, serial#, @inst</span>' <span class="bold">noreplay</span>;

alter system disconnect session '<span class="variable" translate="no">sid, serial#, @inst</span>' <span class="bold">noreplay</span>

$ srvctl stop service -db orcl -instance orcl2 &#x2013;drain_timeout 60 -stopoption immediate -force -noreplay

$ srvctl stop service -db orcl -node myode3 &#x2013;noreplay -drain_timeout 60 -stopoption immediate -force

$ srvctl stop instance -node mynode3 -drain_timeout 60 -stopoption immediate -force &#x2013;noreplay</code></pre><p>To terminate all sessions running on the local instance (rather that only one session) and not have the sessions replayed, you can also use the <code class="codeph">DBMS_SERVICE.DISCONNECT_SESSION</code> PL/SQL procedure and specify <code class="codeph">NOREPLAY</code> for the <code class="codeph">disconnect_option</code> parameter.
                        </p>
                     </div>
                     <div>
                        <div class="relinfo">
                           <p><strong>Related Topics</strong></p>
                           <ul>
                              <li><a href="../sqlrf/ALTER-SYSTEM.html#SQLRF-GUID-2C638517-D73A-41CA-9D8E-A62D1A0B7ADB" target="_blank">ALTER SYSTEM</a></li>
                              <li><a href="../arpls/DBMS_SERVICE.html#ARPLS-GUID-5A0BA1FD-2B7E-47A0-A26A-D51C6EAF4409" target="_blank">DBMS_SERVICE.DISCONNECT_SESSION</a></li>
                           </ul>
                        </div>
                     </div>
                  </div>
               </div><a id="ADFNS1204"></a><a id="ADFNS1203"></a><div class="sect3"><a id="GUID-E4A114A2-EA77-4037-A62A-BDFCF1E6D072" name="GUID-E4A114A2-EA77-4037-A62A-BDFCF1E6D072"></a><h4 id="RACAD-GUID-E4A114A2-EA77-4037-A62A-BDFCF1E6D072" class="sect4">Mutable Functions and Application Continuity</h4>
                  <div>
                     <p>When a request is replayed, the default and desired treatment of mutable objects can vary.</p>
                     <p>A <span class="bold">mutable function</span> is a non-deterministic function that can obtain a new value every time it is called. An example of a mutable function is a call to the <code class="codeph">SYSTIMESTAMP</code> function. Client applications using Application Continuity can determine whether to keep the original value for mutable functions if the request is replayed.
                     </p>
                     <p>Support for keeping mutable function values is currently provided for <code class="codeph">SYSDATE</code>, <code class="codeph">SYSTIMESTAMP</code>, <code class="codeph">SYS_GUID</code>, and <code class="codeph"><span class="variable" translate="no">sequence</span></code><code class="codeph">.NEXTVAL</code>. If the original values are not kept and if different values for these mutable objects are returned to the client, then replay is rejected because the client observes different results. If the application can use original values, then configure mutable functions using the <code class="codeph">KEEP</code> clause for owned sequences and <code class="codeph">GRANT KEEP</code> for other users. (Most applications need sequence values to be kept at replay, for bind variable consistency.)
                     </p>
                     <div class="infoboxnote" id="GUID-E4A114A2-EA77-4037-A62A-BDFCF1E6D072__GUID-7BD2EFD7-32F3-4E48-9B7E-BDD987A2FA67">
                        <p class="notep1">Note:</p>Keeping <code class="codeph">SYS_GUID</code> values is supported only for serial execution plans. When parallel query is used, Application Continuity is not able to restore original values for <code class="codeph">SYS_GUID</code>.
                     </div>
                     <p><a href="ensuring-application-continuity.html#GUID-E4A114A2-EA77-4037-A62A-BDFCF1E6D072__BABHFHHB" title="Example treatment of mutable functions by products (called Product 1, Product 2, and Product 3) during replay">Table 6-4</a> shows examples of the treatment of mutable functions by products during replay. (Actual implementation depends on specific products and releases.)
                     </p>
                     <div class="tblformal" id="GUID-E4A114A2-EA77-4037-A62A-BDFCF1E6D072__BABHFHHB">
                        <p class="titleintable">Table 6-4 Example Treatment of Mutable Objects by Products During Replay</p>
                        <table cellpadding="4" cellspacing="0" class="Formal" title="Example Treatment of Mutable Objects by Products During Replay" summary="Example treatment of mutable functions by products (called Product 1, Product 2, and Product 3) during replay" width="100%" frame="hsides" border="1" rules="rows">
                           <thead>
                              <tr align="left" valign="top">
                                 <th align="left" valign="bottom" width="34%" id="d23610e9567">Mutable Function</th>
                                 <th align="left" valign="bottom" width="24%" id="d23610e9570">Product 1</th>
                                 <th align="left" valign="bottom" width="21%" id="d23610e9573">Product 2</th>
                                 <th align="left" valign="bottom" width="21%" id="d23610e9576">Product 3</th>
                              </tr>
                           </thead>
                           <tbody>
                              <tr align="left" valign="top">
                                 <td align="left" valign="top" width="34%" id="d23610e9581" headers="d23610e9567 ">
                                    <p><code class="codeph">SYSDATE</code>, <code class="codeph">SYSTIMESTAMP</code></p>
                                 </td>
                                 <td align="left" valign="top" width="24%" headers="d23610e9581 d23610e9570 ">
                                    <p>Original</p>
                                 </td>
                                 <td align="left" valign="top" width="21%" headers="d23610e9581 d23610e9573 ">
                                    <p>Original</p>
                                 </td>
                                 <td align="left" valign="top" width="21%" headers="d23610e9581 d23610e9576 ">
                                    <p>Current</p>
                                 </td>
                              </tr>
                              <tr align="left" valign="top">
                                 <td align="left" valign="top" width="34%" id="d23610e9598" headers="d23610e9567 ">
                                    <p>Sequence <code class="codeph">NEXTVAL</code> and <code class="codeph">CURRVAL</code></p>
                                 </td>
                                 <td align="left" valign="top" width="24%" headers="d23610e9598 d23610e9570 ">
                                    <p>Original</p>
                                 </td>
                                 <td align="left" valign="top" width="21%" headers="d23610e9598 d23610e9573 ">
                                    <p>Original</p>
                                 </td>
                                 <td align="left" valign="top" width="21%" headers="d23610e9598 d23610e9576 ">
                                    <p>(Not applicable)</p>
                                 </td>
                              </tr>
                              <tr align="left" valign="top">
                                 <td align="left" valign="top" width="34%" id="d23610e9616" headers="d23610e9567 ">
                                    <p><code class="codeph">SYS_GUID</code></p>
                                 </td>
                                 <td align="left" valign="top" width="24%" headers="d23610e9616 d23610e9570 ">
                                    <p>Original</p>
                                 </td>
                                 <td align="left" valign="top" width="21%" headers="d23610e9616 d23610e9573 ">
                                    <p>(Not applicable)</p>
                                 </td>
                                 <td align="left" valign="top" width="21%" headers="d23610e9616 d23610e9576 ">
                                    <p>(Not applicable)</p>
                                 </td>
                              </tr>
                           </tbody>
                        </table>
                     </div>
                     <!-- class="inftblhruleinformal" -->
                     <p>To allow Application Continuity to keep and use original function results at replay:</p>
                     <ul style="list-style-type: disc;">
                        <li>
                           <p>The database user running the application might have the <code class="codeph">KEEP DATE TIME</code> and <code class="codeph">KEEP SYSGUID</code> privileges granted, and the <code class="codeph">KEEP SEQUENCE</code> object privilege on each sequence whose value is to be kept. For example:
                           </p><pre class="pre codeblock"><code>GRANT KEEP DATE TIME TO user2;
GRANT KEEP SYSGUID TO user2;
GRANT KEEP SEQUENCE ON sales.seq1 TO user2;</code></pre><div class="infoboxnote" id="GUID-E4A114A2-EA77-4037-A62A-BDFCF1E6D072__GUID-4E323586-9AAA-42E4-B205-09FFB9328E87">
                              <p class="notep1">Notes:</p>
                              <ul style="list-style-type: disc;">
                                 <li>
                                    <p><code class="codeph">GRANT ALL ON <span class="variable" translate="no">object</span></code> <span class="italic">does not</span> include (that is, does not grant the access provided by) the <code class="codeph">KEEP DATE TIME</code> and <code class="codeph">KEEP SYSGUID</code> privileges, and the <code class="codeph">KEEP SEQUENCE</code> object privilege.
                                    </p>
                                 </li>
                                 <li>
                                    <p>Grant privileges related to mutable function support only to application users, and to each application user grant only the necessary privileges.</p>
                                 </li>
                                 <li>
                                    <p>Do <span class="italic"><span class="bold">not</span></span> grant DBA privileges to database users running applications for which you want replay to be enabled.
                                    </p>
                                 </li>
                              </ul>
                           </div>
                        </li>
                        <li>
                           <p>Sequences in the application can use the <code class="codeph">KEEP</code> attribute, which keeps the original values of <code class="codeph"><span class="variable" translate="no">sequence</span></code><code class="codeph">.NEXTVAL</code> for the sequence owner, so that the keys match during replay. Most applications need sequence values to be kept at replay. The following example sets the <code class="codeph">KEEP</code> attribute for a sequence (in this case, one owned by the user executing the statement; for others, use <code class="codeph">GRANT KEEP SEQUENCE</code>):
                           </p><pre class="pre codeblock"><code>SQL&gt; CREATE SEQUENCE my_seq KEEP;
SQL&gt; -- Or, if the sequence already exists but without KEEP:
SQL&gt; ALTER SEQUENCE my_seq KEEP;</code></pre><div class="infoboxnote" id="GUID-E4A114A2-EA77-4037-A62A-BDFCF1E6D072__GUID-E6BB8A33-1FD3-42CC-B379-9513EB15668D">
                              <p class="notep1">Note:</p>Specifying <code class="codeph">ALTER SEQUENCE ... KEEP/NOKEEP</code> applies to the owner of the sequence. It does not affect other users (not the owner) that have the <code class="codeph">KEEP SEQUENCE</code> object privileges. If you want <code class="codeph">NOKEEP</code> for all users, then be sure <span class="italic">not</span> to grant the <code class="codeph">KEEP SEQUENCE</code> object privilege to these users (or to revoke it from each user if the privilege has been granted).
                           </div>
                        </li>
                        <li>
                           <p>To keep function results (for named functions) at replay, the DBA must grant <code class="codeph">KEEP</code> privileges to the user invoking the function. This security restriction ensures that it is valid for replay to save and restore function results for code that is not owned by that user.
                           </p>
                        </li>
                     </ul>
                  </div>
                  <div>
                     <div class="relinfo">
                        <p><strong>Related Topics</strong></p>
                        <ul>
                           <li><a href="ensuring-application-continuity.html#GUID-C8C97971-5440-49C8-BFA2-541AEDCD8853" title="These considerations apply to granting and revoking privileges on mutable functions.">Rules for Grants on Mutables</a></li>
                           <li><a href="../sqlrf/ALTER-SEQUENCE.html#SQLRF-GUID-A6468B63-E7C9-4EF0-B048-82FE2449B26D" target="_blank">ALTER SEQUENCE</a></li>
                           <li><a href="https://www.oracle.com/pls/topic/lookup?ctx=en/database/oracle/oracle-database/19/racad&amp;id=SQLRF-GUID-20B4E2C0-A7F8-4BC8-A5E8-BE61BDC41AC3" target="_blank">GRANT</a></li>
                        </ul>
                     </div>
                  </div>
               </div>
               <div class="sect3"><a id="GUID-3EADEA74-3224-48B5-9376-ABE3B34429B0" name="GUID-3EADEA74-3224-48B5-9376-ABE3B34429B0"></a><h4 id="RACAD-GUID-3EADEA74-3224-48B5-9376-ABE3B34429B0" class="sect4">Administering Mutable Values</h4>
                  <p>To manage mutable values you need to grant certain privileges.</p>
                  <div class="sect4"><a id="GUID-2DDC256E-A15F-406C-B292-CBD38D887128" name="GUID-2DDC256E-A15F-406C-B292-CBD38D887128"></a><h5 id="RACAD-GUID-2DDC256E-A15F-406C-B292-CBD38D887128" class="sect5">Granting and Revoking Keep Permissions for Mutables</h5>
                     <div>
                        <p>To keep function results at replay, you must grant <code class="codeph">KEEP</code> privileges to the user invoking the function.
                        </p>
                        <ul id="GUID-2DDC256E-A15F-406C-B292-CBD38D887128__STEPS-UNORDERED_AKH_RLJ_LHB">
                           <li class="stepexpand"><span>To grant and revoke permission to keep <a href="glossary.html#GUID-386FA371-4D78-40FD-9E7E-96EB59CCE2E3"><span class="xrefglossterm">mutables</span></a> for Oracle Dates and <code class="codeph">SYS_GUID</code>:</span><div><pre class="pre codeblock"><code>GRANT [KEEP DATE_TIME | KEEP SYS_GUID]...[to <span class="variable" translate="no">USER</span>]
REVOKE [KEEP DATE_TIME | KEEP SYS_GUID]...[from <span class="variable" translate="no">USER</span>]</code></pre><p>For example, for possible Oracle E-Business Suite usage with original dates:</p><pre class="pre codeblock"><code>GRANT KEEP DATE_TIME, KEEP SYS_GUID to [custom user];
GRANT KEEP DATE_TIME, KEEP SYS_GUID to [apps user];</code></pre></div>
                           </li>
                        </ul>
                     </div>
                  </div>
                  <div class="sect4"><a id="GUID-1A1C0B10-CD5A-42F8-BE21-ED74B362E2CA" name="GUID-1A1C0B10-CD5A-42F8-BE21-ED74B362E2CA"></a><h5 id="RACAD-GUID-1A1C0B10-CD5A-42F8-BE21-ED74B362E2CA" class="sect5">Granting Permission to Keep Mutables for Oracle Sequences</h5>
                     <div>
                        <p>To keep the original values of <code class="codeph">sequence.nextval</code> for replaying so that keys match, you must grant permissions on the sequence.
                        </p>
                        <ul id="GUID-1A1C0B10-CD5A-42F8-BE21-ED74B362E2CA__STEPS-UNORDERED_AKH_RLJ_LHB">
                           <li class="stepexpand"><span>To grant permission as the owner of the sequence:</span><div><pre class="pre codeblock"><code>CREATE SEQUENCE [sequence object] [KEEP|NOKEEP];
ALTER SEQUENCE [sequence object] [KEEP|NOKEEP];
</code></pre></div>
                           </li>
                           <li class="stepexpand"><span>To grant and revoke permission for others using the sequence:</span><div><pre class="pre codeblock"><code>GRANT KEEP SEQUENCE...[to <span class="variable" translate="no">USER</span>] on [<span class="variable" translate="no">sequence object</span>];
REVOKE KEEP SEQUENCE...[from <span class="variable" translate="no">USER</span>] on [<span class="variable" translate="no">sequence object</span>];</code></pre><p>For example, for possible Oracle E-Business Suite usage with original sequence values:</p><pre class="pre codeblock"><code>GRANT KEEP SEQUENCE to [apps user] on [<span class="variable" translate="no">sequence object</span>];
GRANT KEEP SEQUENCE to [custom user] on [<span class="variable" translate="no">sequence object</span>];</code></pre></div>
                           </li>
                        </ul>
                     </div>
                  </div>
                  <div class="sect4"><a id="GUID-C8C97971-5440-49C8-BFA2-541AEDCD8853" name="GUID-C8C97971-5440-49C8-BFA2-541AEDCD8853"></a><h5 id="RACAD-GUID-C8C97971-5440-49C8-BFA2-541AEDCD8853" class="sect5">Rules for Grants on Mutables</h5>
                     <div>
                        <p>These considerations apply to granting and revoking privileges on mutable functions.</p>
                        <ul style="list-style-type: disc;" id="GUID-C8C97971-5440-49C8-BFA2-541AEDCD8853__UL_OCP_DNJ_LHB">
                           <li>
                              <p>If you grant all on an object for a user, then mutables are excluded. Mutables require explicit grants. Oracle does not support granting mutables to the users supplied or created by Oracle Database, such as SYS, AUDSYS, GSMUSER, and SYSTEM.</p>
                           </li>
                           <li>
                              <p>The DBA role includes mutable permission.</p>
                           </li>
                           <li>
                              <p>If a user has mutables granted, then the objects inherit mutable access when the mutable functions are called (in <code class="codeph">SYS_GUID</code>, <code class="codeph">SYSDATE</code> and <code class="codeph">SYSTIMESTAMP</code>).
                              </p>
                           </li>
                           <li>
                              <p>If keeping mutables on a sequence object is revoked, then SQL or PL/SQL commands using that object does not allow mutable collection or application for that sequence.</p>
                           </li>
                           <li>
                              <p>If grants are revoked between run time and failover, then the mutables that were collected are not applied.</p>
                           </li>
                           <li>
                              <p>If grants are granted between run time and failover, then mutables are not collected and so none are applied.</p>
                           </li>
                        </ul>
                     </div>
                  </div>
               </div>
               <div class="sect3"><a id="GUID-987F5EE6-6C32-455A-AEF6-16066EE33F20" name="GUID-987F5EE6-6C32-455A-AEF6-16066EE33F20"></a><h4 id="RACAD-GUID-987F5EE6-6C32-455A-AEF6-16066EE33F20" class="sect4">Protection-Level Statistics</h4>
                  <div>
                     <p>Use the statistics for request boundaries and protection level to monitor the level of coverage.</p>
                     <div class="p">Application Continuity collects statistics from the system, the session, and the service, enabling you to monitor your protection levels. The statistics are available in V$SESSTAT, V$SYSSTAT, and, when service statistics are enabled, in V$SERVICE_STATS. These statistics are saved in the Automatic Workload Repository and are available in Automatic Workload Repository reports. Statistics include:
                        <ul style="list-style-type: disc;">
                           <li>
                              <p>Requests completed per second</p>
                           </li>
                           <li>
                              <p>User calls in a request</p>
                           </li>
                           <li>
                              <p>Protected user calls</p>
                           </li>
                        </ul>The output is similar to the following:<pre class="pre codeblock"><code>Statistic &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;          Total &nbsp; &nbsp; per Second &nbsp; &nbsp; per Trans
---------------------------------------- -------- ------------- ---------
cumulative requests &nbsp; &nbsp;        &nbsp; &nbsp;  &nbsp;     &nbsp; 177,406 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 49.2 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;   5.0
cumulative user calls in request &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;493,329 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;136.8 &nbsp; &nbsp; &nbsp;   &nbsp; &nbsp;13.8
cumulative user calls protected &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 493,329 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;136.8 &nbsp; &nbsp; &nbsp; &nbsp;   &nbsp;13.8</code></pre></div>
                     <p>To enable protection-level statistics, use <code class="codeph">(_request_boundaries = 3)</code>.
                     </p>
                  </div>
               </div><a id="ADFNS1432"></a><a id="ADFNS358"></a><div class="sect3"><a id="GUID-D49C131A-5931-473E-A878-AF4B99E97F1D" name="GUID-D49C131A-5931-473E-A878-AF4B99E97F1D"></a><h4 id="RACAD-GUID-D49C131A-5931-473E-A878-AF4B99E97F1D" class="sect4">Session State Consistency</h4>
                  <div>
                     <p>Session state consistency describes how non-transactional state is changed during a request.</p>
                     <p>Oracle recommends that you set <code class="codeph">session_state_consistency</code> to <code class="codeph">AUTO</code> available with Transparent Application Continuity, which tracks and manages session states. If you choose to use Transparent Application Continuity, then you do not have to do anything else to ensure session state consistency.
                     </p>
                     <p>You can set <code class="codeph">session_state_consistency</code> to <code class="codeph">DYNAMIC</code> or <code class="codeph">STATIC</code> for manual Application Continuity. Set <code class="codeph">session_state_consistency</code> to <code class="codeph">DYNAMIC</code> or <code class="codeph">STATIC</code> if you fully understand the application, and the application is not expected to change from the value set.
                     </p>
                     <p>Examples of session state are NLS settings, optimizer preferences, event settings, PL/SQL global variables, temporary tables, advanced queues, LOBs, and result cache. If non-transactional values change in committed transactions, then use the default value, <code class="codeph">DYNAMIC</code> (<code class="codeph">session_state_consistency</code> is a service level attribute, the default value of which is <code class="codeph">DYNAMIC</code>).
                     </p>
                     <p>Using <code class="codeph">DYNAMIC</code> mode, after a <code class="codeph">COMMIT</code> has executed, if the state was changed in that transaction, then it is not possible to replay the transaction to reestablish that state if the session is lost. Applications can be categorized depending on whether the session state after the initial setup is static or dynamic, and hence whether it is correct to continue past a <code class="codeph">COMMIT</code> operation.
                     </p>
                     <p><code class="codeph">DYNAMIC</code> mode is appropriate for almost all applications. If you are unsure, then use <code class="codeph">DYNAMIC</code> mode. If your customers or users can modify your application, then you must use <code class="codeph">DYNAMIC</code> mode.
                     </p>
                     <div class="infoboxnote" id="GUID-D49C131A-5931-473E-A878-AF4B99E97F1D__GUID-19018A12-29A9-4884-8512-04B978B1C6CE">
                        <p class="notep1">Note:</p>Set <code class="codeph">session_state_consistency</code> to <code class="codeph">AUTO</code> or <code class="codeph">STATIC</code> for long-running, stateless applications. Do not set <code class="codeph">session_state_consistency</code> to <code class="codeph">STATIC</code> for applications that are not stateless. Unless you require manual Application Continuity, Oracle recommends setting <code class="codeph">session_state_consistency</code> to <code class="codeph">AUTO</code>.
                     </div>
                     <p>This section includes the following topics:</p>
                     <ul style="list-style-type: disc;">
                        <li>
                           <p><a href="ensuring-application-continuity.html#GUID-FE576341-43A9-40EC-85EB-11A7CA9F5AE7" title="When you set session_state_consistency to AUTO, Transparent Application Continuity tracks and records session and transactional states so the database session can be recovered following recoverable outages. Setting session_state_consistency to AUTO is the only value permitted for Transparent Application Continuity.">Auto Session State Consistency</a></p>
                        </li>
                        <li>
                           <p><a href="ensuring-application-continuity.html#GUID-B5FD2E5A-69BE-4BAC-9143-D79BFC993833" title="A session has dynamic state if the session state values are not fully restored by FAILOVER_RESTORE, or by adding the initialization callback.">Dynamic Session State Consistency</a></p>
                        </li>
                        <li>
                           <p><a href="ensuring-application-continuity.html#GUID-E980359F-C3EB-403C-9115-ECFE4B1D2AF0" title="Static mode is used for long running stateless applications. Do not use Static mode for applications that are not stateless.">Static Session State Consistency</a></p>
                        </li>
                     </ul>
                  </div>
                  <div class="sect4"><a id="GUID-FE576341-43A9-40EC-85EB-11A7CA9F5AE7" name="GUID-FE576341-43A9-40EC-85EB-11A7CA9F5AE7"></a><h5 id="RACAD-GUID-FE576341-43A9-40EC-85EB-11A7CA9F5AE7" class="sect5">Auto Session State Consistency</h5>
                     <div>
                        <p>When you set <code class="codeph">session_state_consistency</code> to <code class="codeph">AUTO</code>, Transparent Application Continuity tracks and records session and transactional states so the database session can be recovered following recoverable outages. Setting <code class="codeph">session_state_consistency</code> to <code class="codeph">AUTO</code> is the only value permitted for Transparent Application Continuity.
                        </p>
                        <p>When set to <code class="codeph">AUTO</code>, a state-tracking infrastructure categorizes session state usage as the application issues user calls. Tracked session states are monitored and verified.
                        </p>
                     </div>
                  </div><a id="ADFNS359"></a><a id="ADFNS1433"></a><div class="sect4"><a id="GUID-B5FD2E5A-69BE-4BAC-9143-D79BFC993833" name="GUID-B5FD2E5A-69BE-4BAC-9143-D79BFC993833"></a><h5 id="RACAD-GUID-B5FD2E5A-69BE-4BAC-9143-D79BFC993833" class="sect5">Dynamic Session State Consistency</h5>
                     <div>
                        <p>A session has <span class="bold">dynamic</span> state if the session state values are not fully restored by FAILOVER_RESTORE, or by adding the initialization callback.
                        </p>
                        <p>Once the first transaction completes, failover is internally disabled until the next request starts. In <code class="codeph">Dynamic</code> session state consistency mode, state changes occur during the request and replay is enabled at the beginning of the next request.
                        </p>
                        <p>Set the session state consistency mode to <code class="codeph">Dynamic</code> if the nontransactional session state changes while transactions are executing. Examples of nontransactional session state that can change at runtime are <code class="codeph">ALTER</code> <code class="codeph">SESSION</code>, PL/SQL global variables, <code class="codeph">SYS_CONTEXT</code>, and temporary table contents. If the application changes nontransactional state inside transactions and commits, this state cannot be replayed and the state setting must be <code class="codeph">Dynamic</code>. When using <code class="codeph">Dynamic</code> mode for Application Continuity, replay is disabled at <code class="codeph">COMMIT</code> until the next request begins. <code class="codeph">Dynamic</code> is the default value.
                        </p>
                        <p>The nontransactional session state (NTSS) changes during a request when the session state consistency mode is <code class="codeph">Dynamic</code>.
                        </p>
                        <div class="p">Replay (that is, Application Continuity) is enabled at the <code class="codeph">beginRequest</code> call, and is disabled on a <code class="codeph">COMMIT</code> , an <code class="codeph">endRequest</code> call, or a restricted call. Following is the step logic for three application scenarios:
                           <ul style="list-style-type: disc;">
                              <li>
                                 <p> No transaction</p>
                              </li>
                              <li>
                                 <p>A transaction with <code class="codeph">COMMIT</code> as the last statement
                                 </p>
                              </li>
                              <li>
                                 <p>A transaction with an embedded <code class="codeph">COMMIT</code> statement
                                 </p>
                              </li>
                           </ul>
                        </div>
                        <p>For the request with <span class="bold">no transaction</span>, the logical steps are as follows:
                        </p>
                        <ol>
                           <li>
                              <p>Check out.</p>
                           </li>
                           <li>
                              <p>Begin request and enable replay.</p>
                           </li>
                           <li>
                              <p>Issue one or more <code class="codeph">SELECT</code> statements and perhaps other PL/SQL statements.
                              </p>
                           </li>
                           <li>
                              <p>Other actions.</p>
                           </li>
                           <li>
                              <p>Check in.</p>
                           </li>
                           <li>
                              <p>End request and disable replay.</p>
                           </li>
                        </ol>
                        <p>For the request with <span class="bold">a transaction with COMMIT as the last statement</span>, the logical steps are as follows:
                        </p>
                        <ol>
                           <li>
                              <p>Check out.</p>
                           </li>
                           <li>
                              <p>Begin request and enable replay.</p>
                           </li>
                           <li>
                              <p>Issue one or more <code class="codeph">SELECT</code> statements and perhaps other PL/SQL statements.
                              </p>
                           </li>
                           <li>
                              <p>The transaction begins.</p>
                           </li>
                           <li>
                              <p>Other actions.</p>
                           </li>
                           <li>
                              <p>Commit (which disables replay).</p>
                           </li>
                           <li>
                              <p>Check in.</p>
                           </li>
                           <li>
                              <p>End request.</p>
                           </li>
                        </ol>
                        <p>For the request with <span class="bold">a transaction with an embedded COMMIT statement</span>, the logical steps are as follows:
                        </p>
                        <ol>
                           <li>
                              <p>Check out.</p>
                           </li>
                           <li>
                              <p>Begin request and enable replay.</p>
                           </li>
                           <li>
                              <p>Issue one or more <code class="codeph">SELECT</code> statements and perhaps other PL/SQL statements.
                              </p>
                           </li>
                           <li>
                              <p>The transaction begins.</p>
                           </li>
                           <li>
                              <p>Other actions.</p>
                           </li>
                           <li>
                              <p>Commit (which disables replay).</p>
                           </li>
                           <li>
                              <p>Other actions, during which Application Continuity is not covering the application.</p>
                           </li>
                           <li>
                              <p>Check in.</p>
                           </li>
                           <li>
                              <p>End request.</p>
                           </li>
                        </ol>
                     </div>
                  </div><a id="ADFNS1420"></a><a id="ADFNS360"></a><div class="sect4"><a id="GUID-E980359F-C3EB-403C-9115-ECFE4B1D2AF0" name="GUID-E980359F-C3EB-403C-9115-ECFE4B1D2AF0"></a><h5 id="RACAD-GUID-E980359F-C3EB-403C-9115-ECFE4B1D2AF0" class="sect5">Static Session State Consistency</h5>
                     <div>
                        <p><code class="codeph">Static</code> mode is used for long running stateless applications. Do not use <code class="codeph">Static</code> mode for applications that are not stateless.
                        </p>
                        <p>Set the session state consistency mode to <code class="codeph">Static</code>, only if all non-transactional state changes, such as NLS settings, <code class="codeph">SYS_CONTEXT</code>, PL/SQL variables, and optimizer preferences, are set as part of the initialization once per request, and if this session state does not change during transactions. The settings can be established once per connection at connection establishment when&nbsp;using <code class="codeph">FAILOVER_RESTORE=LEVEL1</code>, a callback, or labels, for example, or at each checkout from a pool.
                        </p>
                        <p>When using <code class="codeph">Static</code> mode for Application Continuity, transactional failover continues beyond the first transaction of a request. This is useful for applications that set <code class="codeph">beginRequest</code> once and run long processing operations such as batch jobs, and long reports.
                        </p>
                        <p>Static mode is not supported for applications that use calls that change non-transactional state in transactions. Specific examples of such calls include:</p>
                        <ul style="list-style-type: disc;">
                           <li>
                              <p>PL/SQL subprograms</p>
                           </li>
                           <li>
                              <p><code class="codeph">SYS_CONTEXT</code></p>
                           </li>
                           <li>
                              <p><code class="codeph">ALTER</code> <code class="codeph">SESSION</code></p>
                           </li>
                        </ul>
                        <p>Specify static mode with caution. Use static mode only when the application does not change the non-transactional session state inside transactions. Declaring the session state consistency mode as <code class="codeph">Static</code> indicates that it is safe to continue beyond the first <code class="codeph">COMMIT</code> in a request. Dynamic mode is appropriate for most applications. Do <span class="italic">not</span> use static mode if users or customers can modify or customize the application.
                        </p>
                        <p>The non-transactional session state remaining constant (that is, not changing) during a request when the session state consistency mode is <code class="codeph">Static</code>.
                        </p>
                        <p>Replay (that is, Application Continuity) is enabled at the <code class="codeph">beginRequest</code> call, and is disabled on a restricted call, on a <code class="codeph">disableReplay</code> or <code class="codeph">OCIRequestDisableReplay</code> call, or on an <code class="codeph">endRequest</code> call.
                        </p>
                        <div class="p">Following is the step logic for three application scenarios: 
                           <ul style="list-style-type: disc;">
                              <li>
                                 <p>No transaction</p>
                              </li>
                              <li>
                                 <p>One or more transactions each ending with <code class="codeph">COMMIT</code> as the last statement
                                 </p>
                              </li>
                              <li>
                                 <p>A transaction with a <code class="codeph">COMMIT</code> statement followed by a transaction with a restricted call that disables Application Continuity
                                 </p>
                              </li>
                           </ul>
                        </div>
                        <p>For the request with <span class="bold">no transaction</span>, the logical steps are as follows:
                        </p>
                        <ol>
                           <li>
                              <p>Check out.</p>
                           </li>
                           <li>
                              <p>Begin request and enable replay.</p>
                           </li>
                           <li>
                              <p>Issue one or more <code class="codeph">SELECT</code> statements and perhaps other PL/SQL statements.
                              </p>
                           </li>
                           <li>
                              <p>Other actions.</p>
                           </li>
                           <li>
                              <p>Check in.</p>
                           </li>
                           <li>
                              <p>End request and disable replay.</p>
                           </li>
                        </ol>
                        <p>Replay is disabled at <code class="codeph">endRequest</code>, at a restricted call, and for an explicit <code class="codeph">disableReplay</code> or <code class="codeph">OCIRequestDisableReplay</code> call.
                        </p>
                        <p>For the request with <span class="bold">one or more transactions (each with COMMIT as the last statement)</span>, the logical steps are as follows:
                        </p>
                        <ol>
                           <li>
                              <p>Check out.</p>
                           </li>
                           <li>
                              <p>Begin request and enable replay.</p>
                           </li>
                           <li>
                              <p>Issue one or more <code class="codeph">SELECT</code> statements and perhaps other PL/SQL statements.
                              </p>
                           </li>
                           <li>
                              <p>The transaction begins.</p>
                           </li>
                           <li>
                              <p>The transaction commits.</p>
                           </li>
                           <li>
                              <p>The transaction is purged.</p>
                              <p>(For each additional transaction, steps 4 through 6 occur.)</p>
                           </li>
                           <li>
                              <p>Other actions.</p>
                           </li>
                           <li>
                              <p>Check in.</p>
                           </li>
                           <li>
                              <p>End request.</p>
                           </li>
                        </ol>
                        <p>Replay is disabled at <code class="codeph">endRequest</code>, at a restricted call, and for an explicit <code class="codeph">disableReplay</code> or <code class="codeph">OCIRequestDisableReplay</code> call.
                        </p>
                        <p>For the request with <span class="bold">a transaction with a COMMIT followed by a transaction with a restricted call</span>, the logical steps are as follows:
                        </p>
                        <ol>
                           <li>
                              <p>Check out.</p>
                           </li>
                           <li>
                              <p>Begin request and enable replay.</p>
                           </li>
                           <li>
                              <p>Issue one or more <code class="codeph">SELECT</code> statements and perhaps other PL/SQL statements.
                              </p>
                           </li>
                           <li>
                              <p>The transaction begins.</p>
                           </li>
                           <li>
                              <p>The transaction commits.</p>
                           </li>
                           <li>
                              <p>The transaction is purged.</p>
                           </li>
                           <li>
                              <p>The second transaction begins.</p>
                           </li>
                           <li>
                              <p>The transaction makes a restricted call, which causes Application Continuity to be disabled.</p>
                           </li>
                           <li>
                              <p>The transaction is purged.</p>
                           </li>
                           <li>
                              <p>Other actions</p>
                           </li>
                           <li>
                              <p>Check in.</p>
                           </li>
                           <li>
                              <p>End request.</p>
                           </li>
                        </ol>
                        <p>Replay is disabled at <code class="codeph">endRequest</code>, at a restricted call, and for an explicit <code class="codeph">disableReplay</code> or <code class="codeph">OCIRequestDisableReplay</code> call.
                        </p>
                     </div>
                     <div>
                        <div class="relinfo">
                           <p><strong>Related Topics</strong></p>
                           <ul>
                              <li><a href="ensuring-application-continuity.html#GUID-751D4D16-BE2C-44DC-9A7B-20348E4EC24B" title="Setting FAILOVER_RESTORE to LEVEL1 (for manual Application Continuity) or AUTO (for Transparent Application Continuity) automatically restores common state initial settings before replaying the request.">FAILOVER_RESTORE = LEVEL1 or AUTO</a></li>
                           </ul>
                        </div>
                     </div>
                  </div>
               </div>
            </div><a id="ADFNS1205"></a><div class="sect2"><a id="GUID-A250F3F8-D681-4F44-8969-7A8434E065DD" name="GUID-A250F3F8-D681-4F44-8969-7A8434E065DD"></a><h3 id="RACAD-GUID-A250F3F8-D681-4F44-8969-7A8434E065DD" class="sect3">Potential Side Effects of Application Continuity</h3>
               <div>
                  <p>When you use Application Continuity with <code class="codeph">FAILOVER_TYPE</code> set to <code class="codeph">TRANSACTION</code>, statements that leave side effects are replayed.
                  </p>
                  <div class="infoboxnote" id="GUID-A250F3F8-D681-4F44-8969-7A8434E065DD__GUID-4D50642E-BF16-44FD-9C42-CBBF75BEA4DE">
                     <p class="notep1">Note:</p>As an application owner you can elect to disable replay for requests that contain side effects that you do not want to repeat. The simplest way to disable side effects is to use Transparent Application Continuity (set <code class="codeph">FAILOVER_TYPE</code> to <code class="codeph">AUTO</code>, which disables side effects for you.
                  </div>
                  <p>Application Continuity replays PL/SQL chronologically to restore database state. This serves to rebuild the session as if the user submission was delayed. Most applications want the full state rebuilt as if the submission was repeated, such as writing a report or completing some auditing. However, the actions that are replayed to build the state might include some for which you want to take action to accommodate or mitigate the effects of the replay. Some applications elect to disable replay for requests that contain calls that they do not want to repeat.</p>
                  <p>Examples of actions that create side effects include the following:</p>
                  <ul style="list-style-type: disc;">
                     <li>
                        <p><code class="codeph">DBMS_ALERT</code> calls (email or other notifications)
                        </p>
                     </li>
                     <li>
                        <p><code class="codeph">DBMS_FILE_TRANSFER</code> calls (copying files)
                        </p>
                     </li>
                     <li>
                        <p><code class="codeph">DBMS_PIPE</code> and RPC calls (to external sources)
                        </p>
                     </li>
                     <li>
                        <p><code class="codeph">UTL_FILE</code> calls (writing text files)
                        </p>
                     </li>
                     <li>
                        <p><code class="codeph">UTL_HTTP</code> calls (making HTTP callouts)
                        </p>
                     </li>
                     <li>
                        <p><code class="codeph">UTL_MAIL</code> calls (sending email)
                        </p>
                     </li>
                     <li>
                        <p><code class="codeph">UTL_SMTP</code> calls (sending SMTP messages)
                        </p>
                     </li>
                     <li>
                        <p><code class="codeph">UTL_TCP</code> calls (sending TCP messages)
                        </p>
                     </li>
                     <li>
                        <p><code class="codeph">UTL_URL</code> calls (accessing URLs)
                        </p>
                     </li>
                  </ul>
                  <p>For applications with external actions (such as autonomous transactions or using <code class="codeph">UTL_HTTP</code> to issue a service-oriented application (SOA) call), Application Continuity is transparent when the application is satisfied with replaying external actions, such as resending email, auditing, and transferring a file.
                  </p>
               </div>
               <div>
                  <div class="relinfo">
                     <p><strong>Related Topics</strong></p>
                     <ul>
                        <li><a href="ensuring-application-continuity.html#GUID-696EB534-5B9C-49A9-902A-3F00169EC9AB" title="Replay occurs following a recoverable error but you can disable replay.">Disabling Replay in Application Continuity</a></li>
                     </ul>
                  </div>
               </div>
            </div><a id="ADFNS1206"></a><div class="sect2"><a id="GUID-2400FAAD-0BB2-48AF-B1F6-358EBA724028" name="GUID-2400FAAD-0BB2-48AF-B1F6-358EBA724028"></a><h3 id="RACAD-GUID-2400FAAD-0BB2-48AF-B1F6-358EBA724028" class="sect3">Restrictions and Other Considerations for Application Continuity</h3>
               <div>
                  <p>Be aware of these restrictions and considerations when using Application Continuity.</p>
                  <ul style="list-style-type: disc;">
                     <li>
                        <div class="p">Application Continuity excludes:
                           <ul style="list-style-type: disc;">
                              <li>
                                 <p>JDBC OCI driver (type 2)</p>
                              </li>
                              <li>
                                 <p>ODP.NET, Managed Driver</p>
                              </li>
                              <li>
                                 <p>OLE DB</p>
                              </li>
                              <li>
                                 <p>ODBC</p>
                              </li>
                           </ul>
                        </div>
                     </li>
                     <li>
                        <p>For applications using JDBC, there is no support for <code class="codeph">oracle.sql</code> deprecated concrete classes: <code class="codeph">BLOB</code>, <code class="codeph">CLOB</code>, <code class="codeph">BFILE</code>, <code class="codeph">OPAQUE</code>, <code class="codeph">ARRAY</code>, <code class="codeph">STRUCT</code>, or <code class="codeph">ORADATA</code>.
                        </p>
                     </li>
                     <li>
                        <p>For streams arguments, replay is on a "best effort" basis. For example, if the application is using physical addresses, the address has gone with the outage and cannot be repositioned. JDBC stream setters (such as <code class="codeph">setBinaryStream</code>), for example, cause replay to be disabled.
                        </p>
                     </li>
                     <li>
                        <p>The replay target database must be in the same database cluster (Oracle RAC, Oracle Data Guard, Oracle Active Data Guard, or Oracle Multitenant) as the source database.</p>
                        <p>To protect the integrity of business transactions, Application Continuity does not replay if the target is a different database or if it is the same database or same pluggable database but with data loss, such as one flashed back, recovered incompletely by media recovery, or opened by Oracle Data Guard earlier in time.</p>
                     </li>
                     <li>
                        <p>For OCI and ODP.NET, in Oracle Database 12<span class="italic">c</span> release 2 (12.2.0.1), Application Continuity on OCI driver excludes ADTs, advance queues, and some LOB APIs. These exclusions do not apply to Java.
                        </p>
                     </li>
                     <li>
                        <p>If a statement cache at the application server level is enabled (for example, the WebLogic or third-party application server statement cache), this must be disabled when the replay is used. Instead, configure the JDBC statement cache, which performs better because it is optimized for JDBC and Oracle and because it supports Application Continuity. Use <code class="codeph">oracle.jdbc.implicitstatementcachesize=<span class="variable" translate="no">nnn</span></code>.
                        </p>
                     </li>
                     <li>
                        <p>Starting with Oracle Database 12 release 2 (12.2), replay is supported for the XA data source for Java and ODP.NET, Unmanaged Driver. Replay supports local transactions. Replay silently disables when two-phase is used. This enables Application Continuity to work very well with promotable XA and with applications using the XA data source and mostly not using XA.</p>
                     </li>
                     <li>
                        <p>Replay is disabled if a request issues an <code class="codeph">ALTER SYSTEM</code> or <code class="codeph">ALTER DATABASE</code> statement.
                        </p>
                     </li>
                     <li>
                        <p>Replay is disabled at a request level for <code class="codeph">ALTER SESSION</code> statements that are deemed unsafe to rebuild the session. These include statements for setting support-level events, and disabling and enabling <code class="codeph">COMMIT IN PROCEDURE</code> and <code class="codeph">GUARD</code>.
                        </p>
                        <p>However, <code class="codeph">ALTER SESSION</code> statements at an application level are supported for replay. These include statements for globalization support (NLS) settings, stored and private outlines, setting the container (CDB/PDB), SQL trace, and PL/SQL warnings.
                        </p>
                     </li>
                     <li>
                        <p>Replay is not supported if you are using Oracle Active Data Guard with read/write database links back to the primary database. This is a security restriction from Transaction Guard.</p>
                     </li>
                     <li>
                        <p>Replay does not apply for failure of a parallel query call when this is a statement-level failure. For example, replay would not occur after an <code class="codeph">ORA-12805:parallel query server died unexpectedly</code> error for a call failure encountered during an instance or node failure or memory issue.
                        </p>
                     </li>
                     <li>
                        <p>For Java only, replay does not support DRCP. Dedicated and Shared Servers are supported.</p>
                     </li>
                     <li>
                        <p>The request uses 2PC XA. Starting with Oracle Database 12<span class="italic">c</span> release 2 (12.2), Application Continuity is supported for promotable XA and using XA data sources, while XA is not in use.
                        </p>
                     </li>
                  </ul>
                  <div class="infoboxnote" id="GUID-2400FAAD-0BB2-48AF-B1F6-358EBA724028__GUID-1B619C90-0D61-4E64-B443-67E07D696EE2">
                     <p class="notep1">Note:</p>If you are creating clones of databases by splitting disk images (for example, BCVs) or by cloning so it is a "different" database to make a logical standby or logical copy that is not a physical or Oracle Active Data Guard database, then <code class="codeph">nid</code> <span class="italic"><span class="bold">must</span></span> be used to change the DBID to differentiate the databases.
                  </div>
               </div>
               <div>
                  <div class="relinfo">
                     <p><strong>Related Topics</strong></p>
                     <ul>
                        <li><a href="../lnoci/high-availability-in-oci.html#LNOCI-GUID-D30079AC-4E59-4CC3-86E8-6487A4891BA2" target="_blank">When Application Continuity in OCI Can Fail Over</a></li>
                        <li><a href="https://support.oracle.com/rs?type=doc&amp;id=863800.1" target="_blank">How to Change the DBID, DBNAME Using NID Utility (My Oracle Support Doc ID 863800.1)</a></li>
                     </ul>
                  </div>
               </div>
            </div><a id="RACAD8423"></a><div class="sect2"><a id="GUID-097A5067-8CCF-4FF0-B97B-BF109DFA1841" name="GUID-097A5067-8CCF-4FF0-B97B-BF109DFA1841"></a><h3 id="RACAD-GUID-097A5067-8CCF-4FF0-B97B-BF109DFA1841" class="sect3">Transaction Guard for Improving Client Failover</h3>
               <div>
                  <p>Transaction Guard prevents a transaction being replayed by Application Continuity from being applied more than once.</p>
                  <p>Failing to recognize that the last submission has committed, or that it shall commit sometime soon, or that the last submission has not run to completion, is a problem for applications. It can cause users who resubmit or applications that use their own replay to issue duplicate requests, repeating changes that are already committed to the database, and other forms of logical corruption. Transaction Guard can be used to solve this problem.</p>
                  <p>Application Continuity automatically enables and uses Transaction Guard, but you can also enable Transaction Guard independently. If the application has implemented an application-level replay, then it requires the application to be integrated with Transaction Guard to provide idempotence.</p>
                  <p>In Oracle Database 12<span class="italic">c</span>, Transaction Guard provides a new, fully integrated tool for applications to use to achieve idempotence automatically and transparently, and in a manner that scales. Transaction Guard uses Logical Transaction ID (LTXID) to avoid submitting duplicate transactions. This is referred to as <span class="italic">transaction idempotence</span>. The LTXID persists on commit and is reused following a rollback. During normal runtime, a LTXID is automatically held in the session at both the client and server for each database transaction. At commit, the LTXID is persisted as part of committing the transaction and the next LTXID to use is returned to the client.
                  </p>
                  <div class="section">
                     <p class="subhead2" id="GUID-097A5067-8CCF-4FF0-B97B-BF109DFA1841__GUID-CE9857DD-5524-4704-B666-8936CFD0545F">Transaction Guard for XA Transactions</p>
                     <p>Transaction Guard also supports XA-based transactions, which are transactions that are an option for transaction managers, such as Oracle WebLogic Server, Oracle Tuxedo, and MicroSoft Transaction Server (exposed to Oracle Database through Oracle ODP.NET).</p>
                     <p>Transaction Guard support for XA transactions provides safe replay following recoverable outages for XA transactions on Oracle WebLogic Server. With the addition of XA support, Oracle WebLogic Server can provide replay with idempotence enforced using Transaction Guard.</p>
                  </div>
                  <!-- class="section" -->
                  <div class="section">This section includes the following topics:
                     <ul style="list-style-type: disc;">
                        <li>
                           <p><a href="ensuring-application-continuity.html#GUID-E3DA6FA0-B139-4877-83A1-FDE559AD5DFE">Transaction Guard Configuration Checklist</a></p>
                        </li>
                        <li>
                           <p><a href="ensuring-application-continuity.html#GUID-E61555E3-B694-4F20-85BB-D4650ACBAEFE" title="To configure services to use Transaction Guard, set the following service parameters:">Configuring Services for Transaction Guard</a></p>
                        </li>
                        <li>
                           <p><a href="ensuring-application-continuity.html#GUID-DEF850F6-27E9-428E-B8FC-530230D78AD2" title="When Oracle Net Services establishes a connection to an instance, the connection remains open until the client closes the connection, the instance is shutdown, or a failure occurs.">Failing Over OCI Clients with TAF</a></p>
                        </li>
                     </ul>
                  </div>
                  <!-- class="section" -->
               </div>
               <div>
                  <div class="relinfo">
                     <p><strong>Related Topics</strong></p>
                     <ul>
                        <li><a href="https://www.oracle.com/pls/topic/lookup?ctx=en/database/oracle/oracle-database/19/racad&amp;id=ADFNS-GUID-0D79C66F-A106-412F-9EE6-7D43CBFE2AB5" target="_blank"><span><cite>Oracle Database Development Guide</cite></span></a></li>
                        <li><a href="../adfns/transaction-guard.html#ADFNS-GUID-6C5880E5-C45F-4858-A069-A28BB25FD1DB" target="_blank"><span><cite>Oracle Database Development Guide</cite></span></a></li>
                        <li><a href="../jjdbc/transaction-guard.html#JJDBC-GUID-6F363D40-9EEB-4D34-B085-B5BF4E988D38" target="_blank"><span><cite>Oracle Database JDBC Developers Guide</cite></span></a></li>
                     </ul>
                  </div>
               </div><a id="RACAD8663"></a><div class="sect3"><a id="GUID-E3DA6FA0-B139-4877-83A1-FDE559AD5DFE" name="GUID-E3DA6FA0-B139-4877-83A1-FDE559AD5DFE"></a><h4 id="RACAD-GUID-E3DA6FA0-B139-4877-83A1-FDE559AD5DFE" class="sect4">Transaction Guard Configuration Checklist</h4>
                  <div>
                     <p>Before configuring services for Transaction Guard, use the following configuration checklist:</p>
                     <ul style="list-style-type: disc;">
                        <li>
                           <p>Grant permission to the application user who will call <code class="codeph">GET_LTXID_OUTCOME</code>, as follows:
                           </p><pre class="oac_no_warn" dir="ltr">GRANT EXECUTE ON DBMS_APP_CONT to <span class="italic">user_name</span>;
</pre><div class="infoboxnote" id="GUID-E3DA6FA0-B139-4877-83A1-FDE559AD5DFE__GUID-4C5E8D1F-5F93-477D-86B2-886C227D5D18">
                              <p class="notep1">Note:</p><span class="italic">Do not</span> run this statement if you use Application Continuity.
                           </div>
                        </li>
                        <li>
                           <p>Locate and define the transaction history table for optimal performance.</p>
                           <p>The <a id="d23610e12617" class="indexterm-anchor"></a><a id="d23610e12619" class="indexterm-anchor"></a>transaction history table (<code class="codeph">LTXID_HIST</code>) is created, by default, in the SYSAUX tablespace when you create or upgrade an Oracle Database. New partitions are added when you add instances, using the storage of the last partition. If the location of transaction history table is not optimal for performance, then you can move it to another tablespace and create partitions there. For example, the following statement moves the transaction history table to a tablespace named FastPace:
                           </p><pre class="oac_no_warn" dir="ltr">ALTER TABLE LTXID_TRANS move partition LTXID_TRANS_1 tablespace FastPace
   storage ( initial 10G next 10G minextents 1 maxextents 121 );
</pre></li>
                        <li>
                           <p>Set values for the <code class="codeph">-commit_outcome</code> and <code class="codeph">-retention</code> service parameters.
                           </p>
                        </li>
                        <li>
                           <p>If you are using Oracle RAC, Oracle Data Guard, or Oracle Active Data Guard, then Oracle recommends that you use FAN for fast notification of an outage.</p>
                        </li>
                     </ul>
                  </div>
               </div><a id="RACAD8664"></a><div class="sect3"><a id="GUID-E61555E3-B694-4F20-85BB-D4650ACBAEFE" name="GUID-E61555E3-B694-4F20-85BB-D4650ACBAEFE"></a><h4 id="RACAD-GUID-E61555E3-B694-4F20-85BB-D4650ACBAEFE" class="sect4">Configuring Services for Transaction Guard</h4>
                  <div>
                     <p>To configure services to use Transaction Guard, set the following service parameters:</p>
                     <ul style="list-style-type: disc;">
                        <li>
                           <p><span class="bold"><code class="codeph">-commit_outcome</code></span>: Set the <code class="codeph">-commit_outcome</code> service parameter to <code class="codeph">TRUE</code>. This service parameter determines whether the transaction <a href="glossary.html#GUID-86C1CD88-560A-46FD-80F8-BDA0340D7189"><span class="xrefglossterm">commit outcome	</span></a> is accessible after the COMMIT has executed and an outage has occurred. While Oracle Database has always made COMMIT durable, Transaction Guard makes <span class="italic">the outcome</span> of the COMMIT durable, and is used by applications to enforce the status of the last transaction executed before an outage.
                           </p>
                        </li>
                        <li>
                           <p><span class="bold"><code class="codeph">-retention</code></span>: Use the <code class="codeph">-retention</code> service parameter with <code class="codeph">-commit_outcome</code>. This service parameter determines the amount of time, in seconds, that the COMMIT outcome is retained. Oracle recommends that most installations use the default value.
                           </p>
                        </li>
                     </ul>
                     <p>The following SRVCTL command configures a policy-managed service named <code class="codeph">sales</code> for Transaction Guard:
                     </p><pre class="pre codeblock"><code>$ srvctl add service -db crm -service sales -serverpool spool_1
  -commit_outcome TRUE -retention 86400 -notification TRUE</code></pre><p>The following SRVCTL command configures an administrator-managed service named <code class="codeph">sales</code> for Transaction Guard:
                     </p><pre class="pre codeblock"><code>$ srvctl add service -db crm -service sales -preferred crm_1,crm_2
  -available crm_3,crm_4 -commit_outcome TRUE -retention 86400
  -notification TRUE</code></pre><p>You can also modify an existing service to configure it for Transaction Guard by using the <code class="codeph">srvctl modify service</code> command.
                     </p>
                     <div class="infoboxnote" id="GUID-E61555E3-B694-4F20-85BB-D4650ACBAEFE__GUID-7811D577-095C-4FBD-A325-FC0A47819792">
                        <p class="notep1">Note:</p>
                        <p>Do not use the default database service, the service which has the name set to the value of <code class="codeph">db_name</code> or <code class="codeph">db_unique_name</code>. The default service is used for administrative purposes and does not have the same properties as user-created services.
                        </p>
                     </div>
                  </div>
                  <div>
                     <div class="relinfo">
                        <p><strong>Related Topics</strong></p>
                        <ul>
                           <li><a href="server-control-utility-reference.html#GUID-EC1BA6D7-D538-4E11-9B31-C59389FDF93B" title="Adds services to a database and assigns them to instances.">srvctl add service</a></li>
                           <li><a href="server-control-utility-reference.html#GUID-DCA45A3F-78AD-4259-A8C3-8FCE49A0F4BC" title="Modifies service configuration.">srvctl modify service</a></li>
                           <li><a href="ensuring-application-continuity.html#GUID-BD699AEB-9F85-42A8-8687-5A979918938D" title="Application Continuity masks many recoverable database outages (when replay is successful) from applications and users by restoring the database session: the full session, including all states, cursors, variables, and the last transaction if there is one.">About Application Continuity</a></li>
                           <li><a href="../jjdbc/transaction-guard.html#JJDBC-GUID-DFD6DD11-127F-40F1-94CC-22AEC53BBFFF" target="_blank"><span><cite>Oracle Database JDBC Developers Guide</cite></span></a></li>
                           <li><a href="../lnoci/high-availability-in-oci.html#LNOCI-GUID-6A12DE3A-479A-4D06-8305-AA450BFF6B23" target="_blank"><span><cite>Oracle Call Interface Programmer's Guide</cite></span></a></li>
                        </ul>
                     </div>
                  </div>
               </div>
            </div>
            <div class="sect2"><a id="GUID-DEF850F6-27E9-428E-B8FC-530230D78AD2" name="GUID-DEF850F6-27E9-428E-B8FC-530230D78AD2"></a><h3 id="RACAD-GUID-DEF850F6-27E9-428E-B8FC-530230D78AD2" class="sect3">Failing Over OCI Clients with TAF</h3>
               <div>
                  <p>When Oracle Net Services establishes a connection to an instance, the connection remains open until the client closes the connection, the instance is shutdown, or a failure occurs.</p>
                  <p>If you configure transparent application failover (TAF) for the connection, then Oracle Database replays the session at a surviving instance when an outage occurs.</p>
                  <p>TAF can restart a query after failover has completed but for other types of transactions, such as <code class="codeph">INSERT</code>, <code class="codeph">UPDATE</code>, or <code class="codeph">DELETE</code>, the application must rollback the failed transaction and resubmit the transaction. You must also reexecute any session customizations, in other words, <code class="codeph">ALTER SESSION</code> statements, after failover has occurred if you did not set <code class="codeph">FAILOVER_RESTORE</code> to <code class="codeph">LEVEL1</code> or <code class="codeph">AUTO</code>. However, with TAF, a connection is not moved during normal processing, even if the workload changes over time. 
                  </p>
                  <p>Services simplify the deployment of TAF. You can define a TAF policy for a service, and all connections using this service will automatically have TAF enabled. This does not require any client-side changes. The TAF setting on a service overrides any TAF setting in the client connection definition.</p>
                  <p>You can define a TAF policy for all users of a service by defining the <code class="codeph">-failovermethod</code> and <code class="codeph">-failovertype</code> parameters. You can further define the TAF policy by setting the number of times that a failed session attempts to reconnect to the service and how long it should wait between reconnection attempts using the <code class="codeph">-failoverretry</code> and <code class="codeph">-failoverdelay</code> parameters, respectively.
                  </p>
                  <p>To define a TAF policy for a service, use SRVCTL as in the following example, where the service name is <code class="codeph">tafconn.example.com</code> and the database name is CRM:
                  </p><pre class="pre codeblock"><code>$ srvctl modify service -db crm -service tafconn.example.com -failovermethod BASIC
  -failovertype SELECT -failoverretry 10 -failoverdelay 30</code></pre><p>OCI applications with TAF enabled should use FAN high availability events for fast connection failover. </p>
                  <div class="section">
                     <p class="subhead2" id="GUID-DEF850F6-27E9-428E-B8FC-530230D78AD2__GUID-63B12C8C-FC92-4D37-A887-D5722734FDAE">TAF Supports Transaction Guard and FAILOVER_RESTORE</p>
                     <p>When you are using Transaction Guard, TAF manages the errors for the developers. When you use both TAF and Transaction Guard, developers can use the TAF errors to roll back and safely resubmit or return uncommitted transactions (for TAF error codes ORA-25402, ORA-25408, ORA-25405).</p>
                     <p>When you are using <code class="codeph">FAILOVER_RESTORE</code>, TAF automatically restores common states, which avoids the need for a callback for most applications.
                     </p>
                  </div>
                  <!-- class="section" -->
               </div>
               <div>
                  <div class="relinfo">
                     <p><strong>Related Topics</strong></p>
                     <ul>
                        <li><a href="ensuring-application-continuity.html#GUID-751D4D16-BE2C-44DC-9A7B-20348E4EC24B" title="Setting FAILOVER_RESTORE to LEVEL1 (for manual Application Continuity) or AUTO (for Transparent Application Continuity) automatically restores common state initial settings before replaying the request.">FAILOVER_RESTORE = LEVEL1 or AUTO</a></li>
                     </ul>
                  </div>
               </div>
            </div>
         </div>
      </article>
   </body>
</html>